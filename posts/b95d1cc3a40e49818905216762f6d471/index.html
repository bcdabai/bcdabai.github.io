<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>快速而深入地了解TypeScript及其类型 - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="快速而深入地了解TypeScript及其类型" />
<meta property="og:description" content="by David Piepgrass
由David Piepgrass 快速而深入地了解TypeScript及其类型 (A quick yet in-depth tour of TypeScript and its types) 联合类型，泛型，JSX，类型系统漏洞等等！ (Union types, generics, JSX, type system loopholes and more!) This quick tour of TypeScript is mainly for people who have some experience with JavaScript.
快速浏览TypeScript主要是针对具有JavaScript经验的人。 I’ll explain a few surprising facts about JavaScript, too, in case you only studied something vaguely similar, like Java or C#. If you’d like to know how to set up a TypeScript project, see my previous article." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/b95d1cc3a40e49818905216762f6d471/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2020-07-28T20:23:38+08:00" />
<meta property="article:modified_time" content="2020-07-28T20:23:38+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">快速而深入地了解TypeScript及其类型</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <div style="font-size: 16px;"> 
 <p>by David Piepgrass</p> 
 <p> 由David Piepgrass </p> 
 <h2 id="a-quick-yet-in-depth-tour-of-typescript-and-its-types"> 快速而深入地了解TypeScript及其类型 <span style="font-weight: bold;">(</span>A quick yet in-depth tour of TypeScript and its types<span style="font-weight: bold;">)</span></h2> 
 <h5 id="union-types-generics-jsx-type-system-loopholes-and-more-"> 联合类型，泛型，JSX，类型系统漏洞等等！ <span style="font-weight: bold;">(</span>Union types, generics, JSX, type system loopholes and more!<span style="font-weight: bold;">)</span></h5> 
 <p>This quick tour of TypeScript is mainly for people who have some experience with JavaScript.</p> 
 <p> 快速浏览TypeScript主要是针对具有JavaScript经验的人。 </p> 
 <p>I’ll explain a few surprising facts about JavaScript, too, in case you only studied something vaguely similar, like Java or C#. If you’d like to know how to set up a TypeScript project, see my <a href="https://medium.freecodecamp.org/how-to-set-up-a-typescript-project-67b427114884" rel="noopener">previous article</a>.</p> 
 <p> 如果您仅研究了类似的东西，例如Java或C＃，我还将解释一些有关JavaScript的令人惊讶的事实。 如果您想知道如何设置TypeScript项目，请参阅我的<a href="https://medium.freecodecamp.org/how-to-set-up-a-typescript-project-67b427114884" rel="noopener">上一篇文章</a> 。 </p> 
 <p>TypeScript is based on JavaScript. The TypeScript compiler (or other tools based on it, like <code>ts-node</code> or <code>ts-jest</code>) translates TypeScript into normal JavaScript simply by stripping out all the type information.</p> 
 <p> TypeScript基于JavaScript。 TypeScript编译器(或其他基于它的工具，例如<code>ts-node</code>或<code>ts-jest</code> )只需去除所有类型信息即可将TypeScript转换为普通JavaScript。 </p> 
 <p>Alongside that process, type checking is performed in order to discover <strong>type errors</strong> — mistakes you’ve made that have something to do with types. Of course, occasionally, it also complains about things you did intentionally that nevertheless broke the rules of TypeScript.</p> 
 <p> 在此过程中，还执行类型检查以发现<strong>类型错误</strong> ，这些错误是与类型有关的错误。 当然，有时候，它也会抱怨您故意违反了TypeScript的规则。 </p> 
 <h4 id="types"> 种类 <span style="font-weight: bold;">(</span>Types<span style="font-weight: bold;">)</span></h4> 
 <p>Types can be attached to variables with a colon (:) in their definition, like so:</p> 
 <p> 类型可以在定义中以冒号(:)附加到变量，如下所示： </p> 
 <pre class="has"><code>let z: number = 26;</code></pre> 
 <p>However you often don’t have to <strong>write down</strong> the type. For example, if you write:</p> 
 <p> 但是，您通常不必<strong>写下</strong>类型。 例如，如果您编写： </p> 
 <pre class="has"><code>let z = 26;</code></pre> 
 <p>TypeScript <strong>infers</strong> that z is a number. So if you write:</p> 
 <p> TypeScript <strong>推断</strong> z是一个数字。 因此，如果您写： </p> 
 <pre class="has"><code>let z = 26;z = "Not a number";</code></pre> 
 <p>You’ll get an error on the second line. TypeScript originally did adopt a loophole though: any variable can be <code>null</code> or <code>undefined</code>:</p> 
 <p> 第二行会出现错误。 TypeScript最初确实采用了漏洞：任何变量都可以为<code>null</code>或<code>undefined</code> ： </p> 
 <pre class="has"><code>z = null;      // Allowed!z = undefined; // Allowed!</code></pre> 
 <p>If you’re new to JavaScript, you’re probably wondering what <code>null</code> and <code>undefined</code> are, or <a href="https://stackoverflow.com/questions/5076944/what-is-the-difference-between-null-and-undefined-in-javascript" rel="noopener">why they are two different things</a>.</p> 
 <p> 如果您不熟悉JavaScript，您可能想知道<code>null</code>和<code>undefined</code>是什么，或者<a href="https://stackoverflow.com/questions/5076944/what-is-the-difference-between-null-and-undefined-in-javascript" rel="noopener">为什么它们是两个不同的东西</a> 。 </p> 
 <p>Well, I promised to tell you about <strong>TypeScript</strong> and <code>null</code>/<code>undefined</code> are <strong>JavaScript</strong> things. Ha!</p> 
 <p> 好吧，我答应告诉您有关<strong>TypeScript</strong>和<code>null</code> / <code>undefined</code>是<strong>JavaScript的</strong>事情。 哈！ </p> 
 <p>Personally, I don’t use <code>null</code> very much. I find it convenient to use <code>undefined</code> consistently to avoid worrying about the distinction. <code>undefined</code> is the default value of new variables and function parameters that were not provided by the caller. It’s the value you get if you read a property that doesn’t exist on an object. By contrast, JavaScript itself only rarely uses <code>null</code>, so if you don’t use it yourself, you won’t encounter it very often. I’m sure some people do the opposite, and prefer <code>null</code>.</p> 
 <p> 就个人而言，我很少使用<code>null</code> 。 我发现方便地始终使用<code>undefined</code>以避免担心区别。 <code>undefined</code>是调用者未提供的新变量和函数参数的默认值。 这是您读取对象上不存在的属性时获得的值。 相比之下，JavaScript本身很少使用<code>null</code> ，因此，如果您自己不使用<code>null</code> ，则不会经常遇到它。 我敢肯定有些人会相反，并且更喜欢<code>null</code> 。 </p> 
 <p>Anyway, some people — including me — are of the opinion that allowing <strong>every</strong> variable to be <code>null</code>/<code>undefined</code> was a bad idea. So TypeScript 2.0 <a href="https://blog.mariusschulz.com/2016/09/27/typescript-2-0-non-nullable-types" rel="noopener">allows you to take away that permission</a> with the <code>"strictNullChecks": true</code> compiler option in “tsconfig.json”. You can use <code>"strict": true </code>for Maximum type checking. Instead, you would write:</p> 
 <p> 无论如何，包括我在内的一些人认为允许<strong>每个</strong>变量为<code>null</code> / <code>undefined</code>是一个坏主意。 因此，TypeScript 2.0 <a href="https://blog.mariusschulz.com/2016/09/27/typescript-2-0-non-nullable-types" rel="noopener">允许您</a>使用<code>"strictNullChecks": true</code>的<code>"strictNullChecks": true</code>编译器选项<a href="https://blog.mariusschulz.com/2016/09/27/typescript-2-0-non-nullable-types" rel="noopener">来取消该权限</a> 。 您可以使用<code>"strict": true</code>进行最大类型检查。 相反，您将编写： </p> 
 <pre class="has"><code>let z: number | null = 26;</code></pre> 
 <p>if you <strong>want</strong> <code>z</code> to be potentially <code>null</code> (| means “or”).</p> 
 <p> 如果您<strong>希望</strong> <code>z</code>可能为<code>null</code> (|表示“或”)。 </p> 
 <h5 id="union-types"> 工会类型 <span style="font-weight: bold;">(</span>Union types<span style="font-weight: bold;">)</span></h5> 
 <p>TypeScript has the ability to understand variables that can have multiple types. For example, here is some normal JavaScript code:</p> 
 <p> TypeScript能够理解可以具有多种类型的变量。 例如，下面是一些普通JavaScript代码： </p> 
 <p>This is allowed in TypeScript by default, because <code>var y</code> (by itself) gives <code>y</code> a type of <code>any</code>, meaning anything. So we can assign anything, for example value or object, to <code>y</code>. We can certainly set it to a string, or a number, or an array of two things. <code>any</code> is a special type — it means “this value or variable should act like a JavaScript value or variable and, therefore, not give me any type errors.”</p> 
 <p> 默认情况下，这在TypeScript中是允许的，因为<code>var y</code> (本身)为<code>y</code>提供<code>any</code>的类型，意味着任何东西。 因此，我们可以将任何值(例如value或object)分配给<code>y</code> 。 我们当然可以将其设置为字符串，数字或两件事情的数组。 <code>any</code>是一种特殊类型-表示“此值或变量应像JavaScript值或变量一样工作，因此，不会给我任何类型错误。” </p> 
 <p>I recommend the <code>"strict": true</code> compiler option. But, in that mode, TypeScript doesn’t allow <code>var y</code>— it requires <code>var y: any</code> instead.</p> 
 <p> 我建议使用<code>"strict": true</code>编译器选项。 但是，在那种模式下，TypeScript不允许<code>var y</code>它需要<code>var y: any</code>而是<code>var y: any</code> 。 </p> 
 <p>However, TypeScript allows us to be more specific by saying:</p> 
 <p> 但是，TypeScript通过以下方式使我们更加具体： </p> 
 <pre class="has"><code>var y: string | number;</code></pre> 
 <p>This means “variable y is a string or a number”. If <code>y</code> is created this way, using the example above, the <code>if-else</code> part is allowed. But the other part that says <code>y = [y, y]</code> is not allowed, because <code>[y, y]</code> is not a string and not a number either. <code>y</code> is an array of type <code>number[] | string[]</code>. This feature, in which a variable can have one of two (or more) types, is called <strong>union types</strong> and it’s often useful.</p> 
 <p> 这意味着“变量y是字符串或数字”。 如果使用上述示例以这种方式创建<code>y</code> ，则允许<code>if-else</code>部分。 但是不允许另一部分说<code>y = [y, y]</code> ，因为<code>[y, y]</code>也不是字符串，也不是数字。 <code>y</code>是<code>number[] | string[]</code>类型的数组<code>number[] | string[]</code> <code>number[] | string[]</code> 。 该功能(其中变量可以具有两种(或多种)类型之一)称为<strong>联合类型</strong> ，它通常非常有用。 </p> 
 <p><strong>Tip:</strong> To help you learn TypeScript, it may help to <a href="http://www.typescriptlang.org/play/" rel="noopener">do experiments in the playground</a>. To help you learn more about <strong>JavaScript</strong>, press F12 in Chrome, Firefox or Edge and look for the Console. In the console you can write JavaScript code, to find out what a small piece of JavaScript does and whether you are writing it correctly:</p> 
 <p> <strong>提示：</strong>为了帮助您学习TypeScript， <a href="http://www.typescriptlang.org/play/" rel="noopener">在操场</a>上<a href="http://www.typescriptlang.org/play/" rel="noopener">进行实验</a>可能会有所帮助。 为了帮助您了解有关<strong>JavaScript的</strong>更多信息，请在Chrome，Firefox或Edge中按F12键，然后找到控制台。 在控制台中，您可以编写JavaScript代码，以找出一小段JavaScript的功能以及是否正确编写了它： </p> 
 <p>This console is fantastic because you can use it to run experiments in <em>any </em>browser tab — even this one! Since TypeScript is just JavaScript with static type checking, you can use the console to help you learn about the part of TypeScript that <em>doesn’t</em> have static types. In your TypeScript file you can call <code>console.log(something)</code> to print things in the browser’s console. In some browsers, <code>log</code> can display complex objects. For example, try writing <code>console.log({name:"Steve", age:37, favoriteNumbers:[7, 666, -1]})</code>:</p> 
 <p> 这个控制台很棒，因为您可以使用它在<em>任何</em>浏览器标签中运行实验，甚至可以使用它！ 由于TypeScript只是具有静态类型检查JavaScript，因此您可以使用控制台来帮助您了解TypeScript <em>没有</em>静态类型的部分。 在您的TypeScript文件中，您可以调用<code>console.log(something)</code>在浏览器的控制台中打印内容。 在某些浏览器中， <code>log</code>可以显示复杂的对象。 例如，尝试编写<code>console.log({name:"Steve", age:37, favoriteNumbers:[7, 666, -1]})</code> ： </p> 
 <h4 id="classes"> 班级 <span style="font-weight: bold;">(</span>Classes<span style="font-weight: bold;">)</span></h4> 
 <p>As you know, classes are bundles of functions and variables that can be instantiated into multiple objects. Functions inside classes can refer to other functions and variables inside the class, but in JavaScript and TypeScript you must use the prefix <code>this.</code>A typical JavaScript class might look like this:</p> 
 <p> 如您所知，类是可以实例化为多个对象的函数和变量的捆绑。 类内的函数可以引用该类内的其他函数和变量，但是在JavaScript和TypeScript中，必须使用前缀<code>this.</code> 典型JavaScript类可能如下所示： </p> 
 <p>The console output is:</p> 
 <p> 控制台输出为： </p> 
 <pre class="has"><code>The big box is 10000 times larger than the small oneThe zero-size box has an area of 0.</code></pre> 
 <p>JavaScript is a little picky. When you create a function outside a class, it has the word <code>function</code> in front of it. But, when you create a function inside a <code>class</code>, it is <strong>not allowed</strong> to have the word <code>function</code> in front of it.</p> 
 <p> JavaScript有点挑剔。 当您在类外创建函数时，它前面会带有单词<code>function</code> 。 但是，当您在<code>class</code>创建函数时， <strong>不允许</strong>在其前面使用单词<code>function</code> 。 </p> 
 <p>Functions and methods are the same thing, except that methods in classes have access to <code>this</code> - a reference to the current object, except for <code>static</code> methods. <code>static</code> methods are called on the <code>class</code> , <code>Box.ZeroSize</code> in this example, so they do not have a “current object”. (Well, actually the current object of <code>ZeroSize</code> is the <code>Box</code> constructor function, which is <em>not</em> an instance of <code>Box</code>.)</p> 
 <p> 函数和方法是一回事，除了类中的方法可以访问<code>this</code>对象(对当前对象的引用)( <code>static</code>方法除外)。 在此示例中，对<code>class</code> <code>Box.ZeroSize</code>调用了<code>static</code>方法，因此它们没有“当前对象”。 (嗯，实际上<code>ZeroSize</code>的当前对象是<code>Box</code>构造函数，它<em>不是</em> <code>Box</code>的实例。) </p> 
 <p>Unlike JavaScript, TypeScript classes allow variable declarations, such as <code>width</code> and <code>height</code> in this example:</p> 
 <p> 与JavaScript不同，TypeScript类允许变量声明，例如本示例中的<code>width</code>和<code>height</code> ： </p> 
 <p>For convenience, TypeScript lets you define a constructor and the variables it initializes at the same time. So instead of</p> 
 <p> 为方便起见，TypeScript允许您定义构造函数及其同时初始化的变量。 所以代替 </p> 
 <pre class="has"><code>width: number;  height: number;  constructor(width: number, height: number) {    this.width = width;    this.height = height;  }</code></pre> 
 <p>you can simply write</p> 
 <p> 你可以简单地写 </p> 
 <pre class="has"><code>constructor(public width: number, public height: number) {}</code></pre> 
 <p>By the way, for any C# developers reading this, it works exactly like my <a href="http://ecsharp.net/lemp/" rel="noopener">LeMP system</a> for C#.</p> 
 <p> 顺便说一下，对于所有阅读<a href="http://ecsharp.net/lemp/" rel="noopener">此书的</a> C＃开发人员来说，它的工作原理都与我的C＃ <a href="http://ecsharp.net/lemp/" rel="noopener">LeMP系统</a>完全一样。 </p> 
 <p>Unlike JavaScript, TypeScript has <code>private</code> (and <code>protected</code>) variables and functions which are inaccessible outside the class:</p> 
 <p> 与JavaScript不同，TypeScript具有<code>private</code> (和<code>protected</code> )变量和函数，这些变量和函数在类之外是不可访问的： </p> 
 <p><code>private</code> variables allow you to clearly mark parts of a class as “internal”. Users of the class cannot modify or read these.</p> 
 <p> <code>private</code>变量使您可以清楚地将类的各个部分标记为“内部”。 该类的用户无法修改或阅读这些内容。 </p> 
 <h4 id="interfaces"> 介面 <span style="font-weight: bold;">(</span>Interfaces<span style="font-weight: bold;">)</span></h4> 
 <p>Interfaces are a way of describing “shapes” of objects. Here’s an example:</p> 
 <p> 界面是描述对象“形状”的一种方式。 这是一个例子： </p> 
 <p><code>IBox</code> refers to any class that has a <code>width</code> and <code>height</code> property that are readable numbers. <code>IArea</code> refers to anything with a readable <code>area</code> property. The <code>Box</code> class satisfies both of these requirements. The <code>get area()</code> function counts as a property, because it is called without <code>()</code> parentheses. So I could write:</p> 
 <p> <code>IBox</code>指的是具有<code>width</code>和<code>height</code>属性(可读数字)的任何类。 <code>IArea</code>是指具有可读<code>area</code>属性的任何内容。 <code>Box</code>类满足这两个要求。 <code>get area()</code>函数算作一个属性，因为它被调用时不带<code>()</code>括号。 所以我可以写： </p> 
 <pre class="has"><code>let a: IBox = new Box(10,100);  // OKlet b: IArea = new Box(10,100); // OK</code></pre> 
 <p>Interfaces in TypeScript work like interfaces in the Go programming language, not like interfaces in Java and C#. That’s a good thing. It means that classes <strong>don’t</strong> have to explicitly<strong> </strong>say that they implement an interface. <code>Box</code> implements <code>IBox</code> and <code>IArea</code> without saying so.</p> 
 <p> TypeScript中的接口的工作方式类似于Go编程语言中的接口，而不是Java和C＃中的接口。 这是好事。 这意味着类<strong>不必</strong>显式 <strong> </strong> 说他们实现了一个接口。 <code>Box</code>实现了<code>IBox</code>和<code>IArea</code>而无需这么说。 </p> 
 <p>This means we can define interfaces for types that originally were not designed for any particular interface. For example, my <code><a href="https://www.npmjs.com/package/sorted-btree" rel="noopener">BTree</a></code><a href="https://www.npmjs.com/package/sorted-btree" rel="noopener"> package</a> defines an <code>IMap&lt;Key,V</code>al&gt; interface that represents a dictionary of key-value pairs. Th<code>e n</code>ew Map class built into ES6 also conforms to this interface, so you can <code>put</code> a Map in<code>to a</code>n IMap variable. So, for example, you can write a function wi<code>th a</code>n IMap parameter, and you can p<code>ass</code> a Map<code> or a</code> BTree to the function, and the function doesn’t need to know or care which type it received.</p> 
 <p> 这意味着我们可以为最初不是为任何特定接口设计的类型定义接口。 例如，我的<code><a href="https://www.npmjs.com/package/sorted-btree" rel="noopener">BTree</a></code> <a href="https://www.npmjs.com/package/sorted-btree" rel="noopener">包</a>定义了一个<code>IMap&lt;Key,V</code> al&gt;接口，该接口代表键值对的字典。 日<code>en</code>建成ES6 EW地图类也符合这个接口，所以你可以<code>put</code>一个Map中<code>to a</code> ñIMAP变量。 因此，举例来说，你可以写一个函数的Wi <code>th a</code> ñIMAP参数，你可以p <code>ass</code>一个地图<code>or a</code> B树的功能，而且功能并不需要知道或关心哪种类型收到。 </p> 
 <p><code>readonly</code> means we can read, but not change:</p> 
 <p> <code>readonly</code>意味着我们可以阅读但不能更改： </p> 
 <pre class="has"><code>console.log(`The box is ${a.width} by ${a.height}.`); // OKa.width = 2; /* ERR: Cannot assign to 'width' because it is a                      constant or a read-only property. */</code></pre> 
 <p>TypeScript does not require <code>readonly</code> for interface compatibility. For example, TypeScript accepts this code even though it doesn’t work:</p> 
 <p> TypeScript不需要<code>readonly</code>实现接口兼容性。 例如，TypeScript接受以下代码，即使它不起作用： </p> 
 <pre class="has"><code>interface IArea {  area: number; // area is not readonly, so it can be changed}</code></pre> 
 <pre class="has"><code>let ia: IArea = new Box(10,100);ia.area = 5; // Accepted by TypeScript, but causes a runtime error</code></pre> 
 <p>I think of it as a bug in TypeScript.</p> 
 <p> 我认为这是TypeScript中的错误。 </p> 
 <p>TypeScript also has a concept of optional parts of an interface:</p> 
 <p> TypeScript还具有接口的可选部分的概念： </p> 
 <pre class="has"><code>interface Person {  readonly name: string;  readonly age: number;  readonly spouse?: Person;}</code></pre> 
 <p>For example we can write <code>let p: Person = {name:'John Doe', age:37}</code>. Since <code>p</code> is a <code>Person</code>, we can later refer to <code>p.spouse.</code> This is equal to <code>undefined</code> in this case, but could be a <code>Person</code> if a different object were assigned to it that has a <code>spouse</code>.</p> 
 <p> 例如，我们可以编写<code>let p: Person = {name:'John Doe', age:37}</code> 。 由于<code>p</code>是一个<code>Person</code> ，我们以后可以参考<code>p.spouse.</code> 在这种情况下，这等于<code>undefined</code> ，但是如果为其分配了具有<code>spouse</code>的其他对象，则可以是<code>Person</code> 。 </p> 
 <p>However, if you use <code>p = {name:'Chad', age:19, spouse:'Jennifer'}</code> with the wrong data type for <code>spouse</code> , TypeScript responds that <code>Type string is not assignable to type Person<em> | </em>undefined</code><em>.</em></p> 
 <p> 但是，如果您使用<code>p = {name:'Chad', age:19, spouse:'Jennifer'}</code>且<code>spouse</code>数据类型有误，TypeScript响应说<code>Type string is not assignable to type Person <em>|</em> undefined</code> <code>Type string is not assignable to type Person <em>|</em> undefined</code> <em>。</em> </p> 
 <h4 id="intersection-types"> 交叉点类型 <span style="font-weight: bold;">(</span>Intersection types<span style="font-weight: bold;">)</span></h4> 
 <p>Intersection types are the lesser-known cousin of union types. A union type like <code>A | B</code> means that a value can be <strong>either</strong> an A or a B, but not both. An intersection type like <code>A &amp; B</code> means that a value is both A and B at the same time. For instance, this <code>box</code> is both <code>IBox</code> and <code>IArea</code>, so it has all the properties from both interfaces:</p> 
 <p> 交集类型是联合类型的鲜为人知的表亲。 像<code>A | B</code>联合类型 <code>A | B</code>装置，一个值可以<strong>是</strong>一个A或B，而不是两者。 像<code>A &amp; B</code>这样的交集类型意味着一个值同时是A和B。 例如，此<code>box</code>是<code>IBox</code>和<code>IArea</code> ，因此它具有两个接口的所有属性： </p> 
 <pre class="has"><code>let box: IBox &amp; IArea = new Box(5, 7);</code></pre> 
 <p>If you mix union and intersection types, you can use parentheses to change the meaning:</p> 
 <p> 如果混合并集和相交类型，则可以使用括号来更改含义： </p> 
 <pre class="has"><code>// either a Date&amp;IArea or IBox&amp;IArealet box1: (Date | IBox) &amp; IArea = new Box(5, 7);// either a Date or an IBox&amp;IArealet box2: Date | (IBox &amp; IArea) = new Box(5, 7);</code></pre> 
 <p><code>&amp;</code> has higher precedence than <code>|</code>, so <code>A &amp; B | C</code> means <code>(A &amp; B) | C</code>.</p> 
 <p> <code>&amp;</code>优先级高于<code>|</code> ，所以<code>A &amp; B | C</code> <code>A &amp; B | C</code>表示<code>(A &amp; B) | C</code> <code>(A &amp; B) | C</code> </p> 
 <h4 id="structural-types"> 结构类型 <span style="font-weight: bold;">(</span>Structural types<span style="font-weight: bold;">)</span></h4> 
 <p>In some other programming languages, every type has a name, such as <code>string</code> or <code>double</code> or <code>Component</code>. In TypeScript, many types do have names but, more fundamentally, most types are defined by their structure. In other words, the type’s name, if it has one, is not important to the type system. Here’s an example where variables have a structural type:</p> 
 <p> 在其他一些编程语言中，每种类型都有一个名称，例如<code>string</code>或<code>double</code>或<code>Component</code> 。 在TypeScript中，许多类型确实具有名称，但更根本地，大多数类型是由其结构定义的。 换句话说，类型名称(如果有的话)对于类型系统并不重要。 这是一个变量具有结构类型的示例： </p> 
 <pre class="has"><code>var book1 = { title: "Adventures of Tom Sawyer",       year:1876 };var book2 = { title: "Adventures of Huckleberry Finn", year:1884 };</code></pre> 
 <p>If you hover your mouse over <code>book1</code> in VS Code, its type is described as <code>{ title: string; year: number; }</code>. This is a <strong>structural</strong> type: a type defined entirely by the fact that it has a property called <code>title</code> which is a <code>string</code>, and another property called <code>year</code> which is a <code>number</code>. Thus <code>book1</code> and <code>book2</code> have the same type, and you can assign one to the other, or to a different book.</p> 
 <p> 如果将鼠标悬停在VS Code中的<code>book1</code>上，其类型将描述为<code>{ title: string; year: number; }</code> <code>{ title: string; year: number; }</code> <code>{ title: string; year: number; }</code> 。 这是一种<strong>结构</strong>类型：一种类型完全由以下事实定义：它具有一个称为<code>title</code>的属性(它是一个<code>string</code> )和另一个名为<code>year</code>属性(它是一个<code>number</code> 。 因此<code>book1</code>和<code>book2</code>具有相同的类型，您可以将其中一个分配给另一个，也可以分配给另一本书。 </p> 
 <pre class="has"><code>book1 = book2; // allowedbook2 = { year: 1995, title: "Vertical Run" }; // allowed</code></pre> 
 <p>Generally speaking, you can assign a value with “more stuff” to a variable whose type includes “less stuff”, but not the other way around:</p> 
 <p> 通常，您可以将类型为“较少的东西”的变量赋值为“较多的东西”，但反之则不行： </p> 
 <pre class="has"><code>var book3 = { title: "The Duplicate",               author: "William Sleator", year:1988 };var book4 = { title: "The Boy Who Reversed Himself" };book1 = book3; // allowedbool1 = bool4; /* NOT allowed. Here is the error message:    Type '{ title: string; }' is not assignable to type     '{ title: string; year: number; }'. Property 'year'     is missing in type '{ title: string; }'.  */</code></pre> 
 <p>In addition, if we have an interface like this:</p> 
 <p> 另外，如果我们有这样的接口： </p> 
 <pre class="has"><code>interface Book {  title: string;  author?: string;  year: number;}</code></pre> 
 <p>Then we can assign any <code>Book</code> value to either <code>book1</code> or <code>book2</code>. But <code>author</code> is required in <code>book3</code> and <code>Book</code> might not contain an author. We can assign any of the book variables to a new variable of type <code>Book</code> , except <code>book4</code>, of course.</p> 
 <p> 然后，我们可以将任何<code>Book</code>值分配给<code>book1</code>或<code>book2</code> 。 但是<code>book3</code>需要<code>author</code> ，并且<code>Book</code>可能不包含作者。 当然，我们可以将任何book变量分配给<code>Book</code>类型的新变量， <code>book4</code>除外。 </p> 
 <p>Clearly, structural types are fantastic. This is obvious after you spend a few years using languages without them. For example, imagine if two people, Alfred and Barbara, write different modules <code>A</code> and <code>B</code>. They both deal with points using X-Y coordinates. So each module contains a <code>Point</code> interface:</p> 
 <p> 显然，结构类型很棒。 在花了几年时间使用没有语言的语言之后，这一点显而易见。 例如，假设两个人Alfred和Barbara编写了不同的模块<code>A</code>和<code>B</code> 它们都使用XY坐标处理点。 因此，每个模块都包含一个<code>Point</code>接口： </p> 
 <pre class="has"><code>interface Point {    x: number;    y: number;}</code></pre> 
 <p>Many languages use <strong>nominal</strong> types instead of structural types. In these languages, <code>A.Point</code> is considered to be a completely different type than <code>B.Point</code> even though they are identical. So any points produced by <code>A</code> cannot be used by <code>B</code> and vice versa. This can be frustrating, so please take a moment to celebrate with me the wonder of TypeScript’s structural typing.</p> 
 <p> 许多语言使用<strong>名义</strong>类型而不是结构类型。 在这些语言中， <code>A.Point</code>被认为是一个完全不同的类型<code>B.Point</code>即使它们是相同的。 因此， <code>A</code>产生的任何点都不能被<code>B</code>使用，反之亦然。 这可能令人沮丧，所以请花一点时间与我一起庆祝TypeScript的结构化打字的奇迹。 </p> 
 <p>Structural types can be written either with semicolons or commas, e.g. <code>{ x: number, y: number }</code> and <code>{ x: number; y: number; }</code> are the same.</p> 
 <p> 结构类型可以用分号或逗号来写，例如<code>{ x: number, y: number }</code>和<code>{ x: number; y: number; }</code> <code>{ x: number; y: number; }</code> <code>{ x: number; y: number; }</code>是相同的。 </p> 
 <h4 id="flow-based-typing-and-the-exclamation-mark"> 基于流的键入和感叹号 <span style="font-weight: bold;">(</span>Flow-based typing and the exclamation mark<span style="font-weight: bold;">)</span></h4> 
 <p>If <code>s</code> is a string, you could write <code>s.match(<em>/[0-9]+/</em>)</code> to find the first group of digits in that string. <code>/[0-9]+/</code> is a <code>RegExp</code> - an object that can be used to search strings using <a href="https://en.wikipedia.org/wiki/Regular_expression" rel="noopener">Regular Expressions</a>. Regular expressions are a string-matching system supported by many programming languages, including JavaScript.</p> 
 <p> 如果<code>s</code>是一个字符串，则可以编写<code>s.match( <em>/[0-9]+/</em> )</code>以查找该字符串中的第一组数字。 <code>/[0-9]+/</code>是<code>RegExp</code>一个对象，可用于使用<a href="https://en.wikipedia.org/wiki/Regular_expression" rel="noopener">正则表达式</a>搜索字符串。 正则表达式是许多编程语言(包括JavaScript)支持的字符串匹配系统。 </p> 
 <p><code>match</code> returns an array of strings, or <code>null</code> if the <code>RegExp</code> did not match the string. For example, if <code>s = "I have 10 cats and 2 dogs"</code> then <code>s.match(/[0-9]+/)</code> returns <code>["10"]</code>, but if <code>s = "I have ten velociraptors and a weevil"</code> then <code>match</code> returns <code>null</code>.</p> 
 <p> <code>match</code>返回字符串数组；如果<code>RegExp</code>与字符串不匹配，则返回<code>null</code> 。 例如，如果<code>s = "I have 10 cats and 2 dogs"</code>则<code>s.match(/[0-9]+/)</code>返回<code>["10"]</code> ，但是如果<code>s = "I have ten velociraptors and a weevil"</code>则<code>match</code>返回<code>null</code> 。 </p> 
 <p>If you were looking for digits in a string, you’d want your code to behave differently depending on whether the string has digits or not, right? So you’d use an <code>if</code> statement:</p> 
 <p> 如果要在字符串中查找数字，则希望代码根据字符串是否包含数字而表现不同，对吗？ 因此，您将使用<code>if</code>语句： </p> 
 <pre class="has"><code>var found: string[]|null = s.match(/[0-9]+/);if (found) {  console.log("The string has a number in it: " + found[0]);} else {  console.log("The string lacks digits.");}</code></pre> 
 <p>As you probably know, <code>if (found)</code> means “if found is truthy”. It basically means <code>if (found != null &amp;&amp; found != 0 &amp;&amp; found != false)</code>.</p> 
 <p> 如您所知， <code>if (found)</code>意思是“ if found is true”。 它基本上表示<code>if (found != null &amp;&amp; found != 0 &amp;&amp; found != false)</code> 。 </p> 
 <p>If you don’t check whether <code>found !== null</code>, TypeScript will give you an error:</p> 
 <p> 如果您不检查是否<code>found !== null</code> ，TypeScript将给您一个错误： </p> 
 <pre class="has"><code>var found = s.match(/[0-9]+/);console.log("The string has a number in it: " + found[0]);           // Error: Object is possibly 'null'  ^^^^^</code></pre> 
 <p>So why <strong>don’t</strong> you get an error when you use the <code>if</code> statement? That’s the magic of TypeScript’s flow-based typing.</p> 
 <p> 那么，为什么在使用<code>if</code>语句时<strong>不</strong>出现错误？ 这就是TypeScript基于流的键入的魔力。 </p> 
 <p>In the first branch of the <code>if</code> statement, TypeScript knows that <code>found</code> <strong>cannot</strong> be null, and so the type of <code>found</code> <strong>changes within that block</strong> to exclude <code>null</code>. Thus, its type becomes <code>string[]</code>. Similarly, inside the <code>else {...}</code> block, TypeScript knows that <code>found</code> <strong>cannot</strong> be <code>string[]</code>, so <code>string[]</code> is excluded and the type of <code>found</code> becomes <code>null</code> in that region.</p> 
 <p> 在第一分院<code>if</code>声明，打字稿知道<code>found</code> <strong>不能</strong>为空，所以类型<code>found</code> <strong>该块内的变化</strong> ，以排除<code>null</code> 。 因此，其类型变为<code>string[]</code> 。 类似地，在<code>else {...}</code>块中，TypeScript知道<code>found</code> <strong>不能</strong>为<code>string[]</code> ，因此排除<code>string[]</code>且在该区域中<code>found</code>的类型变为<code>null</code> 。 </p> 
 <p>But TypeScript has a <code>!</code> operator which is used to avoid certain error messages. It means “look, compiler, I know you think this variable could be <code>null</code> or <code>undefined</code>, but I promise you it isn’t. So if <code>found</code> has type <code>string[]|null</code>, then<code>found!</code> has type <code>string[]</code>.”</p> 
 <p> 但是TypeScript有一个<code>!</code> 用于避免某些错误消息的运算符。 它的意思是“看，编译器，我知道您认为此变量可以为<code>null</code>或<code>undefined</code> ，但我向您保证不是。 因此，如果<code>found</code>类型为<code>string[]|null</code> ，则<code>found!</code> 的类型为<code>string[]</code> 。” </p> 
 <p>If you’re sure that <code>s</code> has digits in it, you can use <code>!</code> to avoid the error message:</p> 
 <p> 如果确定<code>s</code>包含数字，则可以使用<code>!</code> 为了避免出现错误信息： </p> 
 <pre class="has"><code>var found = s.match(/[0-9]+/);console.log("The string has a number in it: " + found![0]);</code></pre> 
 <p>TypeScript’s flow-based typing system supports the <code>typeof</code> and <code>instanceof</code> operators, as well as ordinary comparison operators. If you start with a variable that could have several types, you can use any of these operators to narrow down the type:</p> 
 <p> TypeScript的基于流的键入系统支持<code>typeof</code>和<code>instanceof</code>运算符以及普通的比较运算符。 如果从可能具有几种类型的变量开始，则可以使用以下任何一种运算符来缩小类型的范围： </p> 
 <p><strong>Note:</strong> JavaScript distinguishes between <strong>primitive</strong> and <strong>boxed primitive</strong> types, which are objects. For example, <code>"yarn"</code> is a primitive, and its type is <code>string</code>. However, there is also a <strong>boxed</strong> string type called <code>String</code> with a capital S, which is rarely used. You can create a <code>String</code> by writing <code>new String("yarn")</code>. The thing to keep in mind is that these are totally different types.</p> 
 <p> <strong>注：JavaScript</strong>的<strong>原始</strong>和<strong>装箱的基本</strong>类型，这是对象之间进行区分。 例如， <code>"yarn"</code>是一个原始类型，其类型是<code>string</code> 。 但是，也有一种<strong>装箱的</strong>字符串类型，称为<code>String</code> ，其首字母为S，很少使用。 您可以通过编写<code>new String("yarn")</code>创建一个<code>String</code> 。 要记住的是，这些是完全不同的类型。 </p> 
 <p><code>"yarn" instanceof String</code> is <code>false</code>: <code>"yarn"</code> is a <code>string</code>, not a <code>String</code>!</p> 
 <p> <code>"yarn" instanceof String</code>是<code>false</code> ： <code>"yarn"</code>是一个<code>string</code> ，而不是<code>String</code> ！ </p> 
 <p><code>"yarn" instanceof string</code> is <strong>not</strong> false. Instead it’s a totally illegal expression — the right-hand side of <code>instanceof</code> must be a <strong>constructor function</strong> and <code>string</code> does not have a constructor.</p> 
 <p> <code>"yarn" instanceof string</code> <strong>不是</strong> false。 相反，它是一个完全合法的表达-的右侧<code>instanceof</code>必须是一个<strong>构造函数</strong>和<code>string</code>没有一个构造函数。 </p> 
 <p>JavaScript provides two different operators for testing the types of primitives and objects (non-primitives):</p> 
 <p> JavaScript提供了两种不同的运算符来测试基元和对象(非基元)的类型： </p> 
 <ul><li><p><code><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/instanceof" rel="noopener">instanceof</a></code> checks the <a href="https://medium.freecodecamp.org/prototype-in-js-busted-5547ec68872" rel="noopener">prototype chain</a> to find out if a value is a certain kind of object.</p><p> <code><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/instanceof" rel="noopener">instanceof</a></code>检查<a href="https://medium.freecodecamp.org/prototype-in-js-busted-5547ec68872" rel="noopener">原型链，</a>以确定值是否是某种对象。 </p></li><li><p><code><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/typeof" rel="noopener">typeof</a></code> checks whether something is a primitive and if so, what kind.</p><p> <code><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/typeof" rel="noopener">typeof</a></code>检查某物是否为原始类型，如果是，则为哪种类型。 </p></li></ul> 
 <p>As you can see in the code above, <code>instanceof</code> is a binary operator that returns a boolean, while <code>typeof</code> is a unary operator that returns a string. For example, <code>typeof "yarn"</code> returns <code>"string"</code> and <code>typeof 12345</code> returns <code>"number"</code>. The primitive types are <code>number</code>, <code>boolean</code>, <code>string</code>, <code>symbol</code>, <code>undefined</code>, and <code>null</code>. Everything that is not a primitive is an <code>Object</code>, including functions.</p> 
 <p> 如您在上面的代码中看到的， <code>instanceof</code>是一个返回布尔值的二进制运算符，而<code>typeof</code>是一个返回字符串的一元运算符。 例如， <code>typeof "yarn"</code>返回<code>"string"</code> ， <code>typeof 12345</code>返回<code>"number"</code> 。 基本类型为<code>number</code> ， <code>boolean</code> ， <code>string</code> ， <code>symbol</code> ， <code>undefined</code>和<code>null</code> 。 所有不是原始的东西都是<code>Object</code> ，包括函数。 </p> 
 <p>But <code>typeof </code>treats functions specially. For example, <code>typeof Math.sqrt === "function"</code>, and <code>Math.sqrt instanceof Object === true</code>. Symbols are new in ES6 and, although <code>null</code> is a primitive, <code>typeof null === "object"</code> <a href="http://2ality.com/2013/10/typeof-null.html" rel="noopener">is a mistake</a>.</p> 
 <p> 但是<code>typeof</code>特别对待功能。 例如， <code>typeof Math.sqrt === "function"</code>和<code>Math.sqrt instanceof Object === true</code> 。 符号在ES6中是新的，尽管<code>null</code>是原始类型，但<code>typeof null === "object"</code> <a href="http://2ality.com/2013/10/typeof-null.html" rel="noopener">是一个错误</a> 。 </p> 
 <p>As you can see in the example above, TypeScript also understands <code>Array.isArray</code> as a way to detect an array. However, some other methods of detecting types in JavaScript are not supported:</p> 
 <p> 如您在上面的示例中看到的，TypeScript也将<code>Array.isArray</code>理解为检测数组的一种方法。 但是，不支持其他一些检测JavaScript类型的方法： </p> 
 <ul><li><p><code>if (thing.unshift)</code> is sometimes used to distinguish strings from other things, because almost nothing except strings have an <code>unshift</code> method. This is not supported in TypeScript because it does not let you read a property that may not exist.</p><p> <code>if (thing.unshift)</code>有时用于将字符串与其他事物区分开，因为除字符串外，几乎没有其他东西具有<code>unshift</code>方法。 TypeScript不支持此功能，因为它不允许您读取可能不存在的属性。 </p></li><li><p><code>if (thing.hasOwnProperty("unshift"))</code> isn’t recognized as a type test.</p><p> <code>if (thing.hasOwnProperty("unshift"))</code>没有被识别为类型测试。 </p></li><li><p><code>if (thing.constructor === String)</code> isn’t recognized as a type test. In JavaScript, reading a property such as <code>constructor</code> promotes <code>thing</code> to Boxed status, so even if <code>thing</code> is a <em>primitive string</em>, its <code>.constructor</code> will be <em>non-primitive</em>.</p><p> <code>if (thing.constructor === String)</code>不被识别为类型测试。 在JavaScript中，读出的属性，如<code>constructor</code>促进<code>thing</code>到盒装状态，所以即使<code>thing</code>是一种<em>原始的字符串</em> ，其<code>.constructor</code>将<em>非基本</em> 。 </p></li><li><p><code>if ("unshift" in thing)</code> doesn’t work. “The right-hand side of an ‘in’ expression must be of type ‘any’, an object type or a type parameter.” (<code>in</code> should be avoided anyway because it is slow.)</p><p> <code>if ("unshift" in thing)</code>不变<code>if ("unshift" in thing)</code>不起作用。 “'in'表达式的右侧必须是'any'类型，对象类型或类型参数。” (因为速度太慢，无论如何都应避免<code>in</code> 。) </p></li></ul> 
 <h4 id="type-aliases"> 类型别名 <span style="font-weight: bold;">(</span>Type aliases<span style="font-weight: bold;">)</span></h4> 
 <p>The <code>type</code> statement creates a new name for a type. For example after writing:</p> 
 <p> <code>type</code>语句为类型创建一个新名称。 例如写后： </p> 
 <pre class="has"><code>type num = number;</code></pre> 
 <p>You can use <code>num</code> as a synonym for <code>number</code>. <code>type</code> is similar to <code>interface</code> since you can write something like this…</p> 
 <p> 您可以将<code>num</code>用作<code>number</code>的同义词。 <code>type</code>类似于<code>interface</code>因为您可以编写如下内容… </p> 
 <pre class="has"><code>type Point = {    x: number;    y: number;}</code></pre> 
 <p>…instead of <code>interface Point {...}</code>. However, only interfaces support <strong>inheritance.</strong> For example I can create a new interface that is <strong>like</strong> <code>Point</code> but also has a new member <code>z</code>, like this:</p> 
 <p> …代替<code>interface Point {...}</code> 。 但是，仅接口支持<strong>继承。</strong> 例如，我可以创建一个<strong>像</strong> <code>Point</code> <strong>这样</strong>的新接口，但也有一个新成员<code>z</code> ，如下所示： </p> 
 <pre class="has"><code>interface Point3D extends Point {    z: number;}</code></pre> 
 <p>You can’t do inheritance with <code>type</code>. However if <code>Point</code> was defined with <code>type</code>, you are still allowed to extend it with an <code>interface</code>.</p> 
 <p> 您不能使用<code>type</code>继承。 但是，如果<code>Point</code>是用<code>type</code>定义的，则仍然可以使用<code>interface</code>对其进行扩展。 </p> 
 <h4 id="function-types"> 功能类型 <span style="font-weight: bold;">(</span>Function types<span style="font-weight: bold;">)</span></h4> 
 <p>In JavaScript you can pass functions to other functions, like this:</p> 
 <p> 在JavaScript中，您可以将函数传递给其他函数，如下所示： </p> 
 <pre class="has"><code>function doubler(x) { return x*2; }function squarer(x) { return x*x; }function experimenter(func){  console.log(`When I send 5 to my function, I get ${func(5)}.`);}experimenter(doubler);experimenter(squarer);</code></pre> 
 <p>Output:</p> 
 <p> 输出： </p> 
 <pre class="has"><code>When I send 5 to my function, I get 10.When I send 5 to my function, I get 25.</code></pre> 
 <p>In TypeScript you normally need to write down the types of function arguments — you need to know how to express the type of <code>func</code>. As you can see here, its type should be something like <code>(param: number) =&gt; num</code>ber:</p> 
 <p> 在TypeScript中，通常需要写下函数参数的类型-您需要知道如何表达<code>func</code>的类型。 如您所见，其类型应类似于<code>(param: number) =&gt; num</code> ber： </p> 
 <pre class="has"><code>function doubler(x: number) { return x*2; }function squarer(x: number) { return x*x; }function experimenter(func: (param: number) =&amp;gt; number){  console.log(`When I send 5 to my function, I get ${func(5)}.`);}experimenter(doubler);experimenter(squarer);</code></pre> 
 <p>TypeScript requires you to give a <strong>name</strong> to the parameter of <code>func</code>, but it doesn’t matter what that name is. I could have called it <code>x</code>, or <code>Wednesday</code>, or <code>myFavoriteSwearWord</code> and it would have made no difference whatsoever. But don’t even think of calling it <code>asshat</code>. The compiler won’t care, but what about your boss? Better safe than sorry, that’s all I can say.</p> 
 <p> TypeScript要求您为<code>func</code>的参数<strong>命名</strong> ，但是该名称是什么都没有关系。 我可以把它叫做<code>x</code> ，或<code>Wednesday</code> ，或<code>myFavoriteSwearWord</code> ，它将会任何没有区别。 但是，甚至不要把它称为<code>asshat</code> 。 编译器不在乎，但是您的老板呢？ 我能说的比对不起要好。 </p> 
 <p>In JavaScript, everything inside an object is a property — a kind of variable — and that includes functions. As a consequence, these two interfaces mean the same thing:</p> 
 <p> 在JavaScript中，对象内部的所有内容都是属性(一种变量)，并且包含函数。 结果，这两个接口具有相同的含义： </p> 
 <pre class="has"><code>interface Thing1 {  func: (param: number) =&amp;gt; number;}interface Thing2 {  func(param: number): number;}</code></pre> 
 <p>And so this code is allowed:</p> 
 <p> 因此，可以使用以下代码： </p> 
 <pre class="has"><code>class Thing {  func(x: number) { return x * x * x; }}let t1: Thing1 = new Thing();let t2: Thing2 = t1;</code></pre> 
 <p>Does it seem weird to you that TypeScript requires <code>:</code> before the return type of a “normal” function but it requires <code>=&amp;</code>gt; before the return type of a function variable? Anyway, that’s the way it is.</p> 
 <p> 对您来说，TypeScript要求看起来是否很奇怪<code>:</code>在“正常”函数的返回类型之前但它需要<code>=&amp;</code> gt; 在函数变量的返回类型之前？ 无论如何，就是这样。 </p> 
 <h4 id="generics-and-dates-and-stuff"> 泛型，日期和内容 <span style="font-weight: bold;">(</span>Generics, and dates, and stuff<span style="font-weight: bold;">)</span></h4> 
 <h5 id="dates"> 日期 <span style="font-weight: bold;">(</span>Dates<span style="font-weight: bold;">)</span></h5> 
 <p>Let’s say I write a function that ensures a value is an array, like this:</p> 
 <p> 假设我编写了一个确保值是数组的函数，如下所示： </p> 
 <pre class="has"><code>function asArray(v: any): any[] {  // return v if it is an array, otherwise return [v]  return (Array.isArray(v) ? v : [v]);}</code></pre> 
 <p>The <code>asArray</code> function works, but it loses type information. For example, what if this function calls it?</p> 
 <p> <code>asArray</code>函数可以工作，但是会丢失类型信息。 例如，如果该函数调用该怎么办？ </p> 
 <pre class="has"><code>/** Prints one or more dates to the console */function printDates(dates: Date|Date[]) {  for (let date of asArray(dates)) {      // SUPER BUGGY!      var year = date.getYear();      var month = date.getMonth() + 1;      var day = date.getDay();      console.log(`${year}/${month}/${day}`);  }}</code></pre> 
 <p>The TypeScript compiler accepts this code, but it has two bugs. The code correctly added <code>1</code> to the month, because <code>getMonth()</code> returns 0 for January and 11 for December. But the code for getting the <code>year</code> and <code>day</code> are both wrong. Since <code>asArray</code> returns <code>any[]</code>, however, type checking and IntelliSense — which could have caught these bugs — is disabled on <code>date</code>. These bugs could have been avoided if <code>asArray</code> was generic:</p> 
 <p> TypeScript编译器接受此代码，但是有两个错误。 该代码正确地向月份添加了<code>1</code> ，因为<code>getMonth()</code>对于1月返回0，对于12月返回11。 但是获取<code>year</code>和<code>day</code>的代码都是错误的。 由于<code>asArray</code>返回<code>any[]</code> ，因此类型检查和IntelliSense(可能已捕获这些错误)在<code>date</code>上被禁用。 如果<code>asArray</code>是通用的，则可以避免这些错误： </p> 
 <pre class="has"><code>function asArray&lt;T&gt;(v: T | T[]): T[] {  return Array.isArray(v) ? v : [v];}</code></pre> 
 <p>This version of <code>asArray</code> does the same thing, but it has a <strong>type parameter</strong>, which I have decided to call <code>T</code>, to enable enhanced type checking. The type parameter can be any type, so it is similar to <code>any</code>. But it enables the function to describe the <strong>relationship</strong> between the parameter <code>v</code> and the return value.</p> 
 <p> 这个版本的<code>asArray</code>做相同的事情，但是它具有<strong>类型参数</strong> ，我决定将其称为<code>T</code> ，以启用增强的类型检查。 type参数可以是任何类型，因此类似于<code>any</code> 。 但是，它使函数能够描述参数<code>v</code>和返回值之间的<strong>关系</strong> 。 </p> 
 <p>Specifically, it says that <code>v</code> and the return value have, well, similar types. When you call <code>asArray</code>, the TypeScript compiler finds a value of <code>T</code> that allows the call to make sense. For example, if you call <code>asArray(42)</code> then the compiler chooses <code>T=number</code> because it is possible to use 42 as an argument to <code>asArray(v: number|number[]): number[]</code>. After choosing <code>T=number</code>, TypeScript realizes that <code>asArray</code> returns an array of numbers.</p> 
 <p> 具体来说，它表示<code>v</code>和返回值具有相似的类型。 调用<code>asArray</code> ，TypeScript编译器会找到<code>T</code>值，该值使调用有意义。 例如，如果调用<code>asArray(42)</code>则编译器选择<code>T=number</code>因为可以将42用作<code>asArray(v: number|number[]): number[]</code> 。 选择<code>T=number</code> ，TypeScript意识到<code>asArray</code>返回一个数字数组。 </p> 
 <p>In <code>printDates</code> we called <code>asArray(dates)</code> and the compiler figures out that <code>T=Date</code> works best in that situation. After choosing <code>T=Date</code>, TypeScript realizes that <code>asArray</code> returns an array of <code>Date</code>. Therefore, the variable <code>date</code> has type <code>Date</code>, and then it finds the first bug: <code>date.getYear</code> does not exist! Well, actually it does exist, but it has been deprecated due to its behavior — it returns the number of years since 1900 — 118 in 2018. Instead, you should call <code>getFullYear</code>.</p> 
 <p> 在<code>printDates</code>我们称为<code>asArray(dates)</code> ，编译器认为<code>T=Date</code>在这种情况下效果最好。 选择<code>T=Date</code> ，TypeScript意识到<code>asArray</code>返回一个<code>Date</code>数组。 因此，变量<code>date</code>类型为<code>Date</code> ，然后发现第一个错误： <code>date.getYear</code>不存在！ 好吧，实际上它确实存在，但是由于它的行为而被弃用了-它返回自1900年以来的年数-2018年为118年。相反，您应该调用<code>getFullYear</code> 。 </p> 
 <p>TypeScript itself doesn’t notice the second bug. But, when you type <code>date.getDay</code>, VS Code will inform you in a little popup box that this function “Gets the day of the week, using local time”. The day of the week? You have <strong>got</strong> to be kidding me!</p> 
 <p> TypeScript本身不会注意到第二个错误。 但是，当您键入<code>date.getDay</code> ，VS Code将在一个小的弹出框中通知您此函数“使用本地时间获取星期几”。 星期几？ 你一定<strong>是</strong>在跟我开玩笑！ </p> 
 <p>Thanks to generics and VS Code, we fix our code to call <code>date.getDate</code> instead. This does <strong>not</strong> return the date without a time attached to it but, rather, the <strong>day of the current month</strong>. Unlike the month, the day does <strong>not</strong> start counting from zero.</p> 
 <p> 多亏了泛型和VS Code，我们将代码固定为调用<code>date.getDate</code> 。 这<strong>并不</strong>不附加给它的时间返回的日期，而是<strong>当月的一天</strong> 。 与月份不同，日期<strong>并非</strong>从零开始计数。 </p> 
 <pre class="has"><code>/** Prints one or more dates to the console */function printDates(dates: Date|Date[]) {  for (let date of asArray(dates)) {      var year = date.getFullYear();      var month = date.getMonth() + 1;      var day = date.getDate();      console.log(`${year}/${month}/${day}`);  }}</code></pre> 
 <p>One good thing about <code>Date</code>is that they are normally stored in UTC — universal time zone, or GMT. This means that if the user changes the time zone on their computer, the <code>Date</code> objects in your program continue to represent the same <strong>point in time</strong>, but the string returned by <code>.toString()</code> changes. Usually this is what you want, especially in JavaScript where you might have client and server code running in different time zones.</p> 
 <p> 关于<code>Date</code>一件好事是它们通常存储在UTC(世界时区，即GMT)中。 这意味着，如果用户更改计算机上的时区，则程序中的<code>Date</code>对象将继续表示相同<strong>的时间点</strong> ，但是<code>.toString()</code>返回的字符串会更改。 通常这就是您想要的，尤其是在JavaScript中，您的客户端和服务器代码可能在不同的时区运行。 </p> 
 <h5 id="generics"> 泛型 <span style="font-weight: bold;">(</span>Generics<span style="font-weight: bold;">)</span></h5> 
 <p>An advanced example of generics appears in my <a href="https://www.npmjs.com/package/simplertime" rel="noopener">simplertime module</a>. In this case I had a <code>timeToString</code> function that accepted a list of formatting options like this:</p> 
 <p> 我的<a href="https://www.npmjs.com/package/simplertime" rel="noopener">simplertime模块中提供</a>了泛型的高级示例。 在这种情况下，我有一个<code>timeToString</code>函数，它接受如下格式的列表： </p> 
 <pre class="has"><code>export interface TimeFormatOptions {  /** If true, a 24-hour clock is used and AM/PM is hidden */  use24hourTime?: boolean;  /** Whether to include seconds in the output (null causes seconds   *  to be shown only if seconds or milliseconds are nonzero) */  showSeconds?: boolean|null;  ...}</code></pre> 
 <pre class="has"><code>export function timeToString(time: Date|number,                              opt?: TimeFormatOptions): string {  ...}</code></pre> 
 <p>The <code>export</code> keyword is used for sharing code to other source files. For example you can import <code>timeToString</code> in your own code using <code>import {timeToString} from 'simplertime'</code> (after installing with <code>npm i simplertime</code> of course). If you want to import things from a different file in the <strong>same folder</strong>, add a <code>./</code> prefix on the filename, e.g. <code>import * as stuff from './mystuff'</code>.</p> 
 <p> <code>export</code>关键字用于与其他源文件共享代码。 例如，你可以导入<code>timeToString</code>在自己的代码使用<code>import {timeToString} from 'simplertime'</code> (后安装<code>npm i simplertime</code>当然)。 如果要从<strong>同一文件夹中</strong>的其他文件导入内容，请在文件名上添加<code>./</code>前缀，例如<code>import * as stuff from './mystuff'</code> 。 </p> 
 <p>Generics can also be used on classes and interfaces. For example, JavaScript has a <code>Set</code> type for holding an unordered collection of values. We might use it like this:</p> 
 <p> 泛型也可以在类和接口上使用。 例如，JavaScript具有<code>Set</code>类型，用于保存值的无序集合。 我们可以这样使用它： </p> 
 <pre class="has"><code>var primes = new Set([2, 3, 5, 7]);for (var i = 0; i &lt; 10; i++)  console.log(`Is the number ${i} prime? ${primes.has(i)}`);</code></pre> 
 <p>In TypeScript, though, <code>Set</code> has a type parameter, <code>Set&lt;</code>;T&gt;, meaning that all items in the set have<code> </code>type T. In this code TypeScript infers<code> that T=</code>number, so if you <code>write primes.add("he</code>llo!") you’ll get a Type Error. If you act<strong>uall</strong>y want to create a set that can hold both strings and numbers, you can do it like this:</p> 
 <p> 但是，在TypeScript中， <code>Set</code>具有类型参数<code>Set&lt;</code> ; T&gt;，这意味着该集合中的所有项目都具有 <code> </code> 类型T。在此代码中，TypeScript推断<code>that T=</code>数字，因此，如果您<code>write primes.add("he</code> llo！”)，则会出现类型错误。 如果你的行为<strong>uallŸ</strong>要创建一组可容纳两个字符串和数字，你可以做这样的： </p> 
 <pre class="has"><code>var primes = new Set&amp;lt;string|number&gt;([2, 3, 5, 7]);</code></pre> 
 <p>You can also create your own generic types. For example, I created a <a href="https://en.wikipedia.org/wiki/B%2B_tree" rel="noopener">B+ Tree</a> data structure called <code><a href="https://github.com/qwertie/btree-typescript" rel="noopener">BTree&lt;K,</a></code> V&gt;, which is a collection of key-value pairs, sorted by key, that supports fast cloning. It has two type parame<code>t</code>ers, K (a key<code>)</code> and V (a value) and its definition looks roughly like <strong>this</strong>. Note: function bodies have been omitted because I just want to show you how a generic class looks:</p> 
 <p> 您也可以创建自己的泛型类型。 例如，我创建了一个名为<code><a href="https://github.com/qwertie/btree-typescript" rel="noopener">BTree&lt;K,</a></code> V&gt;的<a href="https://en.wikipedia.org/wiki/B%2B_tree" rel="noopener">B + Tree</a>数据结构，该结构是键-值对的集合，按键排序，支持快速克隆。 它有两个类型parame <code>t</code> ERS，K(键<code>)</code>和V(值)和它的定义看起来大致是<strong>这样</strong>的。 注意：函数主体已被省略，因为我只想向您展示泛型类的外观： </p> 
 <h4 id="literals-as-types"> 文字作为类型 <span style="font-weight: bold;">(</span>Literals as types<span style="font-weight: bold;">)</span></h4> 
 <p>Remember how there is an error when you write this?</p> 
 <p> 还记得写这篇文章时怎么会出错吗？ </p> 
 <pre class="has"><code>let z = 26;z = "Zed";</code></pre> 
 <p>The error message sounds a bit strange:</p> 
 <p> 错误消息听起来有点奇怪： </p> 
 <pre class="has"><code>Type '"Zed"' is not assignable to type 'number'</code></pre> 
 <p>Why does it say that <code>"Zed"</code> is a “type”, instead of a “value” or a “string”? In order to understand this, it is necessary to understand that TypeScript has an ability to treat values as types. <code>"Zed"</code> is a <code>string</code>, of course, but it’s more than that — it has <strong>another type at the same time</strong>, a more specific type called <code>"Zed"</code> which represents the <em>value</em> <code>"Zed"</code> . We can even create a variable with this type:</p> 
 <p> 为什么说<code>"Zed"</code>是“类型”，而不是“值”或“字符串”？ 为了理解这一点，有必要了解TypeScript具有将值视为类型的能力。 当然， <code>"Zed"</code>是一个<code>string</code> ，但不仅限于此-它同时具有<strong>另一种类型</strong> ，一个更具体的类型称为<code>"Zed"</code> ，它表示<em>值</em> <code>"Zed"</code> 。 我们甚至可以创建这种类型的变量： </p> 
 <pre class="has"><code>let zed: "Zed" = "Zed";</code></pre> 
 <p>Now we have created a completely useless variable called <code>zed</code>. We can set this variable to <code>"Zed"</code>, but nothing else:</p> 
 <p> 现在，我们创建了一个完全无用的变量<code>zed</code> 。 我们可以将此变量设置为<code>"Zed"</code> ，但除此之外： </p> 
 <pre class="has"><code>zed = "Zed"; // OKzed = "ZED"; // Error: Type '"ZED"' is not assignable to type '"Zed"'.</code></pre> 
 <p>By default we can set <code>zed</code> to <code>null</code> and <code>undefined.</code> Luckily with the <code>"strictNullChecks": true</code> option, we can close that loophole so that this variable will never be anything except “Zed”. Thank God for that, is all I can say.</p> 
 <p> 默认情况下，我们可以将<code>zed</code>设置为<code>null</code>和<code>undefined.</code> 幸运的是，使用<code>"strictNullChecks": true</code>选项，我们可以关闭该漏洞，从而使该变量永远不会是“ Zed”以外的任何值。 我只能说感谢上帝。 </p> 
 <p>So what are these literal-types good for? Well, sometimes a function allows only certain particular strings. For example, imagine if you have a function that lets you <code>turn("left")</code> or <code>turn("right")</code> but nothing else. This function could be declared with a literal-type:</p> 
 <p> 那么这些文字类型有什么用呢？ 好吧，有时一个函数只允许某些特定的字符串。 例如，假设您有一个可以让<code>turn("left")</code>或<code>turn("right")</code>但没有其他功能的函数。 可以使用文字类型声明此函数： </p> 
 <pre class="has"><code>function turn(direction: "left"|"right") { … }</code></pre> 
 <h4 id="fixed-length-arrays"> 定长数组 <span style="font-weight: bold;">(</span>Fixed-length arrays<span style="font-weight: bold;">)</span></h4> 
 <p>Here’s another puzzle for you: what’s the difference between the types <code>number[]</code> and <code>[number]</code>? The first is an array of numbers, the second is an array that contains only one element, which is a number.</p> 
 <p> 这是另一个难题：类型<code>number[]</code>和<code>[number]</code>什么区别？ 第一个是数字数组，第二个是仅包含一个元素(数字)的数组。 </p> 
 <p>Similarly <code>[string,number]</code> denotes an array of length 2 with the first element being a string and the second being a number. In addition, the array has a property <code>length: 2</code>, i.e. its <strong>type</strong> is <code>2</code>, not just <code>number</code>. These fixed-length arrays are called tuple types.</p> 
 <p> 同样， <code>[string,number]</code>表示长度为2的数组，第一个元素是字符串，第二个元素是数字。 另外，数组的属性<code>length: 2</code> ，即其<strong>类型</strong>为<code>2</code> ，而不仅仅是<code>number</code> 。 这些固定长度的数组称为元组类型。 </p> 
 <h4 id="advanced-generics"> 高级仿制药 <span style="font-weight: bold;">(</span>Advanced generics<span style="font-weight: bold;">)</span></h4> 
 <p>So, remember the <code>simplertime</code> module I was talking about? It also exports a <code>defaultTimeFormat</code> object which holds default values for the <code>timeToString</code> formatting options. I wanted to define a special function which would allow me to write things like <code>get(options, 'use24hourTime')</code> to retrieve the value of <code>options.use24hourTime</code> if it exists and <code>defaultTimeFormat.use24hourTime</code> if it does not exist.</p> 
 <p> 所以，还记得我在说的更<code>simplertime</code>模块吗？ 它还会导出<code>defaultTimeFormat</code>对象，该对象保存<code>timeToString</code>格式设置选项的默认值。 我想定义一个特殊的函数，使我可以编写诸如<code>get(options, 'use24hourTime')</code>来检索<code>options.use24hourTime</code>的值(如果存在)和<code>defaultTimeFormat.use24hourTime</code>如果不存在)。 </p> 
 <p>In many languages it is impossible to write a function like that, but it is possible in “dynamic” languages such JavaScript. Here’s how the <code>get</code> function would look like in JavaScript:</p> 
 <p> 在许多语言中，不可能编写这样的函数，但是在诸如JavaScript的“动态”语言中，这是可能的。 以下是<code>get</code>函数在JavaScript中的外观： </p> 
 <pre class="has"><code>function get(opt, name) {  if (opt === undefined || opt[name] === undefined)    return defaultTimeFormat[name]  return opt[name];}</code></pre> 
 <p>In JavaScript and TypeScript, <code>thing.property</code> can be written as <code>thing["property"]</code> instead and, if the property does not exist, the result is <code>undefined</code>. But in the square-bracket version we can use a <strong>variable</strong>, so that the question “which property are we using?” can be answered by code located elsewhere.</p> 
 <p> 在JavaScript和TypeScript中， <code>thing.property</code>可以写为<code>thing["property"]</code>并且，如果该属性不存在，则结果是<code>undefined</code> 。 但是在方括号版本中，我们可以使用一个<strong>变量</strong> ，这样的问题是“我们正在使用哪个属性？” 可以通过其他地方的代码来回答。 </p> 
 <p>Translating this to TypeScript is possible with a feature called <code>keyof</code>, but it’s <strong>very</strong> tricky. Here is the translation:</p> 
 <p> 可以使用称为<code>keyof</code>的功能将<code>keyof</code>转换为TypeScript，但这<strong>非常</strong>棘手。 这是翻译： </p> 
 <pre class="has"><code>function get&lt;;K extends keyof TimeFormatOptions&gt;(         opt: TimeFormatOptions|undefined, name: K):          TimeFormatOptions[K]{  if (opt === undefined || opt[name] === undefined)    return defaultTimeFormat[name]  return opt[name];}</code></pre> 
 <p>Here, the type variable <code>K</code> has a <strong>constraint</strong> attached to it, <code>K extends keyof TimeFormatOptions</code>. Here’s how it works:</p> 
 <p> 在此，类型变量<code>K</code>附加有<strong>约束</strong> ， <code>K extends keyof TimeFormatOptions</code> 。 运作方式如下： </p> 
 <ol><li><p><code>keyof X</code> turns the properties of <code>X</code> into a union type of the names of the properties. For example, given the <code>Book</code> interface from earlier, <code>keyof Book</code> means <code>"title" | "author" | "age"</code>. Likewise <code>keyof TimeFormatOptions</code> is any of the property names in <code>TimeFormatOptions</code>.</p><p> <code>keyof X</code>打开的属性<code>X</code>成联合类型属性的名称。 例如，给定较早版本的<code>Book</code>界面， <code>keyof Book</code>表示<code>"title" | "author" | "age"</code> <code>"title" | "author" | "age"</code> <code>"title" | "author" | "age"</code> 。 同样<code>keyof TimeFormatOptions</code>是任何在属性名的<code>TimeFormatOptions</code> 。 </p></li><li><p>The “extends” constraint, <code>X extends Y</code>, means that “X must be Y, or a subtype of Y”. For example <code>X extends Object</code> means that <code>X</code> must be some kind of <code>Object</code>, which means it can be an array or a <code>Date</code> or even a function, all of which are considered to be Objects, but it can’t be a <code>string</code> or a <code>number</code> or a <code>boolean</code>. Similarly <code>X extends Point</code> means that <code>X</code> is <code>Point</code> or a <em>more specific</em> type than <code>Point</code>, such as <code>Point3D</code>.</p><p> “扩展”约束<code>X extends Y</code> ，表示“ X必须是Y或Y的子类型”。 例如<code>X extends Object</code>意味着<code>X</code>必须是某种<code>Object</code> ，这意味着它可以是数组或<code>Date</code>甚至是一个函数，所有这些都被视为Object，但不能是<code>string</code>或<code>number</code>或<code>boolean</code> 。 类似地， <code>X extends Point</code>意味着<code>X</code>是<code>Point</code>或比<code>Point</code> <em>更特定的</em>类型，例如<code>Point3D</code> 。 </p></li><li><p>What would <code>B extends keyof Book</code> mean? It would mean that <code>B</code> is a <strong>subtype</strong> of <code>"title" | "author" | "age"</code>. And, remember, that we are talking about <strong>types</strong> here, <strong>not</strong> values. The string literal <code>"title"</code> has the value <code>"title"</code> but it also has the type <code>"title"</code>, which is a different concept. The type is handled by the TypeScript type system, and the value is handled by the JavaScript. The <code>"title"</code> type no longer exists when the program is running, but the <code>"title"</code> value still does. Now, <code>B</code> can be assigned to types like <code>"title"</code> or <code>"title" | "age"</code>, because every value of type <code>"title" | "age"</code> (or <code>"title"</code>) can be assigned to a variable of type <code>keyof Book</code>. However <code>B</code> cannot be <code>string</code>, because some strings are not “title”, “author”, or “age”.</p><p> <code>B extends keyof Book</code>含义是什么？ 这意味着<code>B</code>是<code>"title" | "author" | "age"</code>的<strong>子类型</strong> 。 <code>"title" | "author" | "age"</code> <code>"title" | "author" | "age"</code> 。 而且，请记住，我们在这里谈论的是<strong>类型</strong> ， <strong>而不是</strong>值。 字符串文字<code>"title"</code>的值为<code>"title"</code>但其类型也为<code>"title"</code> ，这是一个不同的概念。 该类型由TypeScript类型系统处理，而值由JavaScript处理。 程序运行时， <code>"title"</code>类型不再存在，但<code>"title"</code>值仍然存在。 现在，可以将<code>B</code>分配给<code>"title"</code>或<code>"title" | "age"</code> <code>"title" | "age"</code> ，因为类型为<code>"title" | "age"</code>每个值<code>"title" | "age"</code> <code>"title" | "age"</code> (或<code>"title"</code> )分配给<code>keyof Book</code>类型的变量。 但是<code>B</code>不能为<code>string</code> ，因为某些字符串不是“ title”，“ author”或“ age”。 </p></li><li><p>Similarly, <code>K</code> is constrained to have a subtype of <code>keyof TimeFormatOptions</code>, such as <code>"use24hourTime"</code>.</p><p> 同样， <code>K</code>被约束为具有<code>keyof TimeFormatOptions</code>的子类型，例如<code>"use24hourTime"</code> 。 </p></li><li><p>The type <code>X[Y]</code> means “the type of the Y property of X, where Y is a number or string literal”. For example, the <em>type</em> <code>Book["author"]</code> is <code>string | undefined</code>.</p><p> <code>X[Y]</code>类型的意思是“ X的Y属性的类型，其中Y是数字或字符串文字”。 例如， <em>类型</em> <code>Book["author"]</code>是<code>string | undefined</code> <code>string | undefined</code> 。 </p></li></ol> 
 <p>Putting this all together, when I write <code>get(options, 'use24hourTime')</code>, the compiler decides that <code>K='use24hourTime'</code>. Therefore, the <code>name</code> parameter has type <code>"use24hourTime"</code> and the return type is <code>TimeFormatOptions["use24hourTime"]</code>, which means <code>boolean | undefined</code>.</p> 
 <p> <code>get(options, 'use24hourTime')</code> ，当我编写<code>get(options, 'use24hourTime')</code> ，编译器会确定<code>K='use24hourTime'</code> 。 因此， <code>name</code>参数的类型为<code>"use24hourTime"</code> ，返回类型为<code>TimeFormatOptions["use24hourTime"]</code> ，表示<code>boolean | undefined</code> <code>boolean | undefined</code> 。 </p> 
 <h4 id="holes-in-the-type-system"> 类型系统中的Kong <span style="font-weight: bold;">(</span>Holes in the type system<span style="font-weight: bold;">)</span></h4> 
 <p>Since TypeScript is built on top of JavaScript, it accepts some flaws in its type system for various reasons. Earlier we saw one of these flaws, the fact that this code is legal:</p> 
 <p> 由于TypeScript基于JavaScript构建，因此由于各种原因，它在其类型系统中存在一些缺陷。 早些时候，我们看到了这些缺陷之一，即该代码是合法的： </p> 
 <pre class="has"><code>class Box {  constructor(public width: number, public height: number) {}  get area() { return this.width*this.height; }}</code></pre> 
 <pre class="has"><code>interface IArea {  area: number; // area is not readonly}</code></pre> 
 <pre class="has"><code>let ia: IArea = new Box(10,100);ia.area = 5; // Accepted by TypeScript, but causes a runtime error</code></pre> 
 <p>Here are some other interesting loopholes:</p> 
 <p> 以下是一些其他有趣的漏洞： </p> 
 <h5 id="you-can-assign-a-derived-class-to-a-base-class"> 您可以将派生类分配给基类 <span style="font-weight: bold;">(</span>You can assign a derived class to a base class<span style="font-weight: bold;">)</span></h5> 
 <p>A <code>Date</code> is a kind of <code>Object</code> so naturally you can write:</p> 
 <p> <code>Date</code>是一种<code>Object</code>因此自然可以编写： </p> 
 <pre class="has"><code>var d: Object = new Date();</code></pre> 
 <p>So it makes sense that we can also assign this <code>D</code> interface to this <code>O</code> interface, right?</p> 
 <p> 因此，我们也可以将此<code>D</code>接口分配给该<code>O</code>接口是对的，对吗？ </p> 
 <pre class="has"><code>interface D { date: Date }interface O { date: Object }var de: D = { date: new Date() };    // okay...var oh: O = de;                      // makes sense...oh.date = { date: {wait:"what?"} }   // wait, what?</code></pre> 
 <p>Well, no, not really, because TypeScript now believes <code>de.date</code> is a <code>Date</code> when it is actually an <code>Object</code>.</p> 
 <p> 好吧，不是，不是真的，因为TypeScript现在认为<code>de.date</code>实际上是一个<code>Object</code> ，它是一个<code>Date</code> 。 </p> 
 <h5 id="you-can-assign-a-b-to-a-b-"> 您可以将[A，B]分配给(A | B)[] <span style="font-weight: bold;">(</span>You can assign [A,B] to (A|B)[]<span style="font-weight: bold;">)</span></h5> 
 <p>It makes sense that an array of two items, an <code>A</code> followed by a <code>B</code>, is also a an array of <code>A|B</code>, right? Actually, no, not really:</p> 
 <p> 有意义的是，两个项的数组<code>A</code>后面跟着<code>B</code> ，也是<code>A|B</code>的数组，对吗？ 实际上，不，不是真的： </p> 
 <pre class="has"><code>var array1: [number,string] = [5,"five"];var array2: (number|string)[] = array1;   // makes sense...array2[0] = "string!";                    // wait, what?</code></pre> 
 <p>TypeScript now believes <code>array1[0]</code> is a <code>number</code> when it is actually a <code>string</code>. This is an example of a more general problem, that arrays are treated as covariant but they <strong>aren’t</strong> really covariant because they are editable.</p> 
 <p> 打字稿现在认为<code>array1[0]</code>是一个<code>number</code>时，它实际上是一个<code>string</code> 。 这是一个更普遍的问题的示例，该数组被视为协变的，但它们<strong>并不是</strong>真正的协变，因为它们是可编辑的。 </p> 
 <h5 id="arrays-there-be-dragons-"> 数组？ 有龙。 <span style="font-weight: bold;">(</span>Arrays? There be dragons.<span style="font-weight: bold;">)</span></h5> 
 <p>In the recommended <code>strict</code> mode, you can’t put <code>null</code> or <code>undefined</code> in arrays of numbers…</p> 
 <p> 在推荐的<code>strict</code>模式下，您不能在数字数组中放置<code>null</code>或<code>undefined</code> … </p> 
 <pre class="has"><code>var a = [1,2,3];a[3] = undefined; // 'undefined' is not assignable to type 'number'</code></pre> 
 <p>So that means when we get a value from an array of numbers, it’s a number, right? Actually, no, not really:</p> 
 <p> 所以这意味着当我们从数字数组中获得一个值时，它就是一个数字，对吗？ 实际上，不，不是真的： </p> 
 <pre class="has"><code>var array = [1,2,3];var n = array[4];</code></pre> 
 <p>TypeScript now believes <code>n</code> is a <code>number</code> when it is actually <code>undefined</code>.</p> 
 <p> 打字稿现在相信<code>n</code>是一个<code>number</code>时，它实际上是<code>undefined</code> 。 </p> 
 <p>A more obvious hole is that you can allocate a sized array of numbers… with no numbers in it:</p> 
 <p> 一个更明显的漏洞是您可以分配一个大小合适的数字数组……其中没有数字： </p> 
 <pre class="has"><code>var array = new Array&lt;number&gt;(2); // array of two "numbers"var n:number = array[0];</code></pre> 
 <h5 id="function-parameters-are-bivariant-when-overriding"> 覆盖时函数参数是双变量的 <span style="font-weight: bold;">(</span>Function parameters are bivariant when overriding<span style="font-weight: bold;">)</span></h5> 
 <p>Unlike other languages with static typing, TypeScript allows overriding with covariant parameters. <strong>Covariant parameter</strong> means that, as the class gets more specific (A to B), the parameter also gets more specific (Object to Date):</p> 
 <p> 与其他具有静态类型的语言不同，TypeScript允许使用协变参数覆盖。 <strong>协变量参数</strong>表示，随着类变得更加具体(从A到B)，该参数也变得更加具体(从Object到Date)： </p> 
 <pre class="has"><code>class A {    method(value: Object) { }}</code></pre> 
 <pre class="has"><code>class B extends A {    method(value: Date) { console.log(value.getFullYear()); }}</code></pre> 
 <pre class="has"><code>var a:A = new B();a.method({}); // Calls B.method, which has a runtime error</code></pre> 
 <p>This is unsafe, but oddly it is allowed. In contrast, it is (relatively) safe to override with <strong>contravariant</strong> parameters, like this:</p> 
 <p> 这是不安全的，但是奇怪的是它是允许的。 相反，它是(相对)安全与<strong>逆变</strong>参数，这样的控制装置： </p> 
 <pre class="has"><code>class A {    method(value: Date) { }}class B extends A {    method(value: Object) { console.log(value instanceof Date); }}</code></pre> 
 <p>Covariant return types are also safe:</p> 
 <p> 协变返回类型也是安全的： </p> 
 <pre class="has"><code>class A {    method(): Object { return {} }}class B extends A {    method(): Date { return new Date(); }}</code></pre> 
 <p>TypeScript rightly rejects contravariant return types:</p> 
 <p> TypeScript正确拒绝协变返回类型： </p> 
 <pre class="has"><code>class A {    method(): Date { return new Date(); }}class B extends A {    // Property 'method' in type 'B' is not assignable to     // the same property in base type 'A'.    //   Type '() =&gt; Object' is not assignable to type '() =&gt; Date'    //     Type 'Object' is not assignable to type 'Date'    method(): Object { return {} }}</code></pre> 
 <h5 id="classes-think-they-are-interfaces-but-they-re-not-"> 类认为它们是接口(但不是) <span style="font-weight: bold;">(</span>Classes think they are interfaces (but they’re not)<span style="font-weight: bold;">)</span></h5> 
 <p>TypeScript allows you to treat a class as though it were an interface. For example, this is legal:</p> 
 <p> TypeScript允许您将类视为接口。 例如，这是合法的： </p> 
 <pre class="has"><code>class Class {  content: string = "";}</code></pre> 
 <pre class="has"><code>var stuff: Class = {content:"stuff"};</code></pre> 
 <p>Stuff isn’t a real <code>Class</code>, but TypeScript thinks it is, which can cause a runtime <code>TypeError</code> if you use <code>instanceof Class</code> somewhere else in the program:</p> 
 <p> Stuff不是真正的<code>Class</code> ，但是TypeScript认为它是真实的，如果您在程序中的其他地方使用<code>instanceof Class</code> ，则可能导致运行时<code>TypeError</code> ： </p> 
 <pre class="has"><code>function typeTest(x: Class|Date) {  if (x instanceof Class)    console.log("The class's content is " + x.content);  else    console.log("It's a Date in the year " + x.getFullYear());}</code></pre> 
 <pre class="has"><code>typeTest(stuff);</code></pre> 
 <h5 id="this-isn-t-necessarily-what-you-think"> <code><em>this</em></code>不一定是你的想法 <span style="font-weight: bold;">(</span><code><em>this</em></code> isn’t necessarily what you think<span style="font-weight: bold;">)</span></h5> 
 <p><code>this</code> is a loophole of JavaScript, not TypeScript. Any time a function uses <code>this</code>, it might be accessing some completely unexpected object, with a different type than you think:</p> 
 <p> <code>this</code>是JavaScript的漏洞，而不是TypeScript。 每当函数使用<code>this</code> ，它可能会访问某种完全意外的对象，其类型与您想象的类型不同： </p> 
 <pre class="has"><code>class Time {  constructor(public hours: number, public minutes: number) { }  toDate(day: Date) {    var clone = new Date(day);    clone.setHours(this.hours, this.minutes);    return clone;  }}</code></pre> 
 <pre class="has"><code>// Call toDate() with this=12345Time.prototype.toDate.call(12345, new Date());</code></pre> 
 <p>TypeScript’s only sin is that it won’t try to stop you from doing this.</p> 
 <p> TypeScript的唯一罪过是它不会试图阻止您这样做。 </p> 
 <p>Speaking of <code>this</code>, one thing JavaScript developers should know is that <strong>arrow functions</strong> like <code>x =&gt; </code>x+1 work slightly differently than anonymous functions li<code>ke function(x) {return x</code>+1}.</p> 
 <p> 说到<code>this</code> ，JavaScript开发人员应该知道的一件事是， <code>x =&gt;</code> x + 1之类的<strong>箭头函数</strong>与匿名<code>ke function(x) {return x</code> +1} <code>ke function(x) {return x</code>工作方式略有不同。 </p> 
 <p><strong>Arrow</strong> functions inherit the value of <code>this</code> from the outer function in which they are located. <strong>Normal</strong> functions receive a new value of <code>this</code> from the caller. So, if <code>f</code> is an arrow function, <code>f.call(12345, x)</code> doesn’t change <code>this</code>, so it’s like calling <code>f(x)</code>. That’s usually a good thing, but if you write:</p> 
 <p> <strong>箭头</strong>的函数继承的值<code>this</code>从它们所在的外部函数。 <strong>正常</strong>功能得到的新值<code>this</code>从主叫方。 因此，如果<code>f</code>是箭头函数，则<code>f.call(12345, x)</code>不会更改<code>this</code>函数，因此就像调用<code>f(x)</code> 。 通常这是一件好事，但是如果您写： </p> 
 <p><code>var obj = { x: 5, f: () =&gt; this.</code>x }</p> 
 <p> <code>var obj = { x: 5, f: () =&gt; this.</code> X } </p> 
 <p>You should realize that <code>obj.f()</code> does <strong>not</strong> return <code>obj.x</code>.</p> 
 <p> 你应该认识到<code>obj.f()</code> <strong>不</strong>返回<code>obj.x</code> 。 </p> 
 <h5 id="lessons"> 经验教训 <span style="font-weight: bold;">(</span>Lessons<span style="font-weight: bold;">)</span></h5> 
 <p>To avoid these holes, you need to:</p> 
 <p> 为避免这些漏洞，您需要： </p> 
 <ul><li><p><strong>Not</strong> treat an <strong>object</strong> as a “baser” type (e.g. don’t treat <code>D</code> as an <code>O</code>) unless you are sure that the baser type won’t be modified in a way that could violate the type system.</p><p> 除非您确定不会以可能违反类型系统的方式修改基本类型，否则<strong>不要</strong>将<strong>对象</strong>视为“ baser”类型(例如，不要将<code>D</code>视为<code>O</code> )。 </p></li><li><p><strong>Not</strong> treat an <strong>array</strong> as a “baser” type (e.g. don’t treat <code>D[]</code> as <code>O[]</code>, or <code>[A,B]</code> as <code>(A|B)[]</code>) unless you are sure that the baser type won’t be modified in a way that could violate the type system.</p><p> <strong>不要</strong>将<strong>数组</strong>视为“ baser”类型(例如，不要将<code>D[]</code>视为<code>O[]</code>或将<code>[A,B]</code>视为<code>(A|B)[]</code> )，除非您确定基本类型不会以可能违反类型系统的方式进行修改。 </p></li><li>Be careful not to leave any “holes” with undefined values in your arrays.<p class="nodelete"></p> 注意不要在数组中留下任何带有未定义值的“空洞”。 </li><li>Be careful not to use out-of-bounds array indexes.<p class="nodelete"></p> 注意不要使用越界数组索引。 </li><li><p><strong>Not</strong> override a base-class method with covariant parameters.</p><p> <strong>不</strong>使用协变参数覆盖基类方法。 </p></li><li><p><strong>Avoid</strong> treating a class <code>K</code> as though it were an interface, unless you are sure that no code will ever check the type with <code>instanceof</code>.</p><p> <strong>避免</strong>将类<code>K</code>视为接口，除非您确定没有代码会使用<code>instanceof</code>检查类型。 </p></li><li><p><strong>Avoid</strong> using <code>.call(...)</code> , and be careful how you deal with references to functions.</p><p> <strong>避免</strong>使用<code>.call(...)</code> ，并要小心处理对函数的引用。 </p></li></ul> 
 <p>TypeScript actually had <a href="https://github.com/Microsoft/TypeScript/issues/9765" rel="noopener">more</a> <a href="https://github.com/Microsoft/TypeScript/issues/3410#issuecomment-111646030" rel="noopener">holes</a> in the past, which are now plugged.</p> 
 <p> TypeScript过去实际上有<a href="https://github.com/Microsoft/TypeScript/issues/9765" rel="noopener">更多</a> <a href="https://github.com/Microsoft/TypeScript/issues/3410#issuecomment-111646030" rel="noopener">漏洞</a> ，现在已被填补。 </p> 
 <h4 id="jsx"> JSX <span style="font-weight: bold;">(</span>JSX<span style="font-weight: bold;">)</span></h4> 
 <p>React introduced the concept of JSX code. Or, maybe, <a href="https://github.com/hyperhype/hyperscript" rel="noopener">Hyperscript</a> introduced it and React copied the idea soon afterward. In any case, JSX <strong>looks</strong> like HTML/XML code. But you are not making DOM elements, you’re making plain-old JavaScript objects, which we call a “virtual DOM”. For example, <code>&lt;img src={imageUrl</code>}/&gt; actually <code>means React.createElement("img", { src: image</code>Url }) in a .jsx or .tsx file.</p> 
 <p> React引入了JSX代码的概念。 或者，也许<a href="https://github.com/hyperhype/hyperscript" rel="noopener">Hyperscript</a>引入了它，然后React很快就复制了这个想法。 无论如何，JSX <strong>看起来</strong>像HTML / XML代码。 但是，您不是在创建DOM元素，而是在创建普通JavaScript对象，我们称之为“虚拟DOM”。 例如， <code>&lt;img src={imageUrl</code> } /&gt;实际上<code>means React.createElement("img", { src: image</code> .jsx或.tsx文件中的<code>means React.createElement("img", { src: image</code> Url})。 </p> 
 <p>If JSX is a React thing, why am I talking about it in the TypeScript section? Because support for JSX is built into the TypeScript compiler. To get JSX support in any TypeScript file, you just have to change the file’s extension from <code>.ts</code> to <code>.tsx</code>.</p> 
 <p> 如果JSX是React的东西，为什么在TypeScript部分讨论它呢？ 因为TypeScript编译器内置了对JSX的支持。 要在任何TypeScript文件中获得JSX支持，只需将文件的扩展名从<code>.ts</code>更改为<code>.tsx</code> 。 </p> 
 <p>JSX can be used in the same places as normal expressions: you can pass JSX code to a function…</p> 
 <p> JSX可以在与正则表达式相同的地方使用：您可以将JSX代码传递给函数… </p> 
 <pre class="has"><code>ReactDOM.render(&lt;h1&gt;I'm JSX code!&lt;/h1&gt;, document.body);</code></pre> 
 <p>you can store it in a variable…</p> 
 <p> 您可以将其存储在变量中... </p> 
 <pre class="has"><code>let variable = &lt;h1&gt;I'm JSX code!&lt;/h1&gt;;</code></pre> 
 <p>and you can return it from a function…</p> 
 <p> 您可以从函数中返回它… </p> 
 <pre class="has"><code>return &lt;h1&gt;I'm JSX code!&lt;/h1&gt;;</code></pre> 
 <p>Because <code>&lt;h1&gt;I'm JSX code</code>!&lt;/h1&gt; really<code> just means React.createElement("h1", null, "I'm</code> JSX code!").</p> 
 <p> 因为<code>&lt;h1&gt;I'm JSX code</code> ！&lt;/ h1&gt;实际上<code>just means React.createElement("h1", null, "I'm</code> JSX代码！”)。 </p> 
 <p>It is important whether a JSX tag starts with a capital letters — it is translated to TypeScript (or JavaScript) <strong>differently</strong> if it does. For example:</p> 
 <p> JSX标记是否以大写字母开头非常重要-JSX标记以<strong>不同的</strong>方式转换为TypeScript(或JavaScript)。 例如： </p> 
 <ul><li><p><code>&lt;div class="foo</code>"/&gt; <code>means React.createElement('div', {"class":"</code>foo"}), but</p><p> <code>&lt;div class="foo</code> ” /&gt; <code>means React.createElement('div', {"class":"</code> foo”})，但是 </p></li><li><p><code>&lt;Div class="foo</code>"/&gt; <code>means React.createElement(Div, {"class":"</code>foo"}) (without quotes a<code>rou</code>nd Div).</p><p> <code>&lt;Div class="foo</code> ”/&gt; <code>means React.createElement(Div, {"class":"</code> foo”的})(没有引号一个<code>rou</code> ND DIV)。 </p></li></ul> 
 <p>Tips for using JSX:</p> 
 <p> 使用JSX的提示： </p> 
 <ul><li><p>JSX is XML-like, so all tags must be closed: write <code>&lt;b</code>r/&gt;<code>, no</code>t &lt;br&gt;.</p><p> JSX类似于XML，因此必须关闭所有标签：写<code>&lt;b</code> r /&gt; <code>, no</code>写&lt;br&gt;。 </p></li><li><p>JSX only supports string attributes and JavaScript expressions. When writing numeric attributes in TypeScript, use <code>&lt;input type="number" min={0} max={100</code>}/&gt;, be<code>cause m</code>ax=100 is a syntax erro<code>r and max</code>="100" is a type error.</p><p> JSX仅支持字符串属性和JavaScript表达式。 在TypeScript中编写数字属性时，请使用<code>&lt;input type="number" min={0} max={100</code> } /&gt;， <code>cause m</code> ax = 100是语法错误， <code>r and max</code> =“ 100”是类型错误。 </p></li><li><p>In React/Preact, you can use an array of elements in any location where a list of children are expected. For example, instead of <code>return &lt;p&gt;Ann&lt;br/&gt;Bob</code>&lt;br/&gt;Cam&amp;l<code>t;/p&gt;, you can write let x = [&lt;br/&gt;, 'Bob', &amp;</code>lt;br/&gt;]; return &lt;p&gt;Ann{x}Cam&lt;/p&gt;. This has the same effect because React/Preact “flattens” arrays in the child list.</p><p> 在React / Preact中，您可以在需要子列表的任何位置使用元素数组。 例如， <code>t;/p&gt;, you can write let x = [&lt;br/&gt;, 'Bob', &amp;</code> lt; br /&gt;];而不是<code>return &lt;p&gt;Ann&lt;br/&gt;Bob</code> &lt;br/&gt; Cam＆l <code>t;/p&gt;, you can write let x = [&lt;br/&gt;, 'Bob', &amp;</code> ； 返回&lt;p&gt; Ann {x} Cam &lt;/ p&gt;。 这具有相同的效果，因为子列表中的React / Preact“拉平”数组。 </p></li><li><p>In React, the <code>class</code> attribute is not supported for some reason. Use <code>className</code> instead.</p><p> 在React中，出于某些原因不支持<code>class</code>属性。 请改用<code>className</code> 。 </p></li><li><p>JSX itself does not support optional property or children. For example, suppose you write <code>&lt;Foo prop={<!-- --></code>x}&gt; but you want to omi<code>t th</code>e prop<code> </code>when<code> x is und</code>efined. Well, JSX itself doesn’t support anything like that. However, most components tre<code>at an und</code>efined property the same as a missing property, so it usually works anyway. JSX doesn’t support optional children either, but you can get the same effect with an empty array: because arrays are “collapsed” by React/Pr<code>eact, &lt;Foo&gt;</code>{ [] }&lt;/Foo&gt; has t<code>he same eff</code>ec<code>t as &lt;Foo&gt;&lt;/F</code>oo&gt;. &lt;Foo&gt;{undefined}&lt;/Foo&gt; does not have this effect<code> (you end</code> up with a single child equal to undefined.)</p><p> JSX本身不支持可选属性或子级。 For example, suppose you write <code>&lt;Foo prop={<!-- --></code> x}&gt; but you want to omi <code>t th</code> e prop <code> </code> when <code>x is und</code> efined. Well, JSX itself doesn't support anything like that. However, most components tre <code>at an und</code> efined property the same as a missing property, so it usually works anyway. JSX doesn't support optional children either, but you can get the same effect with an empty array: because arrays are “collapsed” by React/Pr <code>eact, &lt;Foo&gt;</code> { [] }&lt;/Foo&gt; has t <code>he same eff</code> ec <code>t as &lt;Foo&gt;&lt;/F</code> oo&gt;. &lt;Foo&gt;{undefined}&lt;/Foo&gt; does not have this effect <code>(you end</code> up with a single child equal to undefined.) </p></li><li><p>If you have an object like <code>obj = {a:1, b:2}</code> and you would like to use all the properties of the object as properties of a Component, you can write <code>&lt;Component {...obj</code>}/&gt;. The dots are always requ<code>ired; &lt;Componen</code>t {obj}/&gt; is not allowed.</p><p> If you have an object like <code>obj = {a:1, b:2}</code> and you would like to use all the properties of the object as properties of a Component, you can write <code>&lt;Component {...obj</code> }/&gt;. The dots are always requ <code>ired; &lt;Componen</code> t {obj}/&gt; is not allowed. </p></li></ul> 
 <p>At the top of the file, the <code>@jsx</code> pragma can control the “factory” function that is called to translate JSX elements. For example if you use <code>/** @jsx h */</code> then <code>&lt;b&gt;th</code>is&lt;/b&gt; tr<code>anslates to h('b', n</code>ull, "this")<code> instead of React.createElement('b', n</code>ull, "this"). Some Preact apps use t<code>h</code>is pragma (h is the preact function to create elements), but you won’t need to use it in thi<code>s tutorial (c</code>reateElement is a <code>s</code>ynonym for h). Also, in “tsconfig.json” you can get the same <code>effect with "jsxF</code>actory":<code> "h" in the com</code>pilerOptions.</p> 
 <p> At the top of the file, the <code>@jsx</code> pragma can control the “factory” function that is called to translate JSX elements. For example if you use <code>/** @jsx h */</code> then <code>&lt;b&gt;th</code> is&lt;/b&gt; tr <code>anslates to h('b', n</code> ull, "this") <code>instead of React.createElement('b', n</code> ull, "this"). Some Preact apps use t <code>h</code> is pragma (h is the preact function to create elements), but you won't need to use it in thi <code>s tutorial (c</code> reateElement is a <code>s</code> ynonym for h). Also, in “tsconfig.json” you can get the same <code>effect with "jsxF</code> actory": <code>"h" in the com</code> pilerOptions. </p> 
 <h4 id="see-also"> 也可以看看 <span style="font-weight: bold;">(</span>See also<span style="font-weight: bold;">)</span></h4> 
 <p><a href="https://blog.mariusschulz.com/series/typescript-evolution" rel="noopener">TypeScript evolution</a> explains the newest TypeScript features in more detail. You might also like to see <a href="https://www.typescriptlang.org/docs/handbook/advanced-types.html" rel="noopener">Advanced Types</a> in TypeScript’s manual.</p> 
 <p> <a href="https://blog.mariusschulz.com/series/typescript-evolution" rel="noopener">TypeScript evolution</a> explains the newest TypeScript features in more detail. You might also like to see <a href="https://www.typescriptlang.org/docs/handbook/advanced-types.html" rel="noopener">Advanced Types</a> in TypeScript's manual. </p> 
 <h4 id="before-you-go-"> 你走之前… <span style="font-weight: bold;">(</span>Before you go…<span style="font-weight: bold;">)</span></h4> 
 <p>If you liked this article, don’t forget to clap or tweet! And if you’d like to learn React, continue on to my <a href="http://typescript-react-primer.loyc.net/tutorial-5.html" rel="noopener">next article</a>.</p> 
 <p> If you liked this article, don't forget to clap or tweet! And if you'd like to learn React, continue on to my <a href="http://typescript-react-primer.loyc.net/tutorial-5.html" rel="noopener">next article</a> . </p> 
 <blockquote> 
  <p>翻译自: <a href="https://www.freecodecamp.org/news/typescript-and-its-types-f509d799947d/" rel="nofollow">https://www.freecodecamp.org/news/typescript-and-its-types-f509d799947d/</a></p> 
 </blockquote> 
</div>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/04874c18c42ce4cbadfec5d401d4e3e2/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">C语言头文件路径剖析</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/d5a5fc0caa0cae2c06c9ab411da26cf2/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">python中利用Sklearn和Scipy分别实现核密度估计</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>