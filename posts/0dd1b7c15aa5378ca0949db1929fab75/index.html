<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>【SLAM】基于rrt_explore的移动机器人自主建图 - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="【SLAM】基于rrt_explore的移动机器人自主建图" />
<meta property="og:description" content="系列文章目录 ·【SLAM】基于explore_lite的移动机器人自主建图
·【SLAM】基于rrt_explore的移动机器人自主建图
·【问题解决】rrt_exploration功能包使用过程中报错处理
文章目录 目录
目录
系列文章目录
文章目录
前言
一、原理
二、安装
三、使用说明
1.global_rrt_frontier_detector
2.local_rrt_frontier_detector
3.frontier_opencv_detector
4.filter
5.Assigner
四、仿真实验
前言 前面我们尝试了基于explore_lite的自主建图，本篇文章我们对基于rrt的自主建图算法进行探索尝试，并对其原理进行简述，然后进行在ubuntu16.04和ubuntu20.04虚拟机上都进行仿真实验，指出需要进行修改的地方以便于我们仿真通过。
一、原理 这个功能包是基于2D的，通常采用图像算法的边缘检测来检测已知区域与未知区域的边界。基于Rapidly-exploring Random Trees（快速搜索随机树RRT）的探索策略。由于RRT基本上是朝向未知区域的（unexplored and unvisited），并且RRT可以扩展到更高维区域。同时采用local tree与global tree来检查边缘点，使得机器人的exploration更加高效。
一旦检测到边缘后，就会取其中心为目标点，然后让机器人去探索该点。而为了检测边缘点，需要对整张地图进行处理，而这个操作通常是耗时的，为此大量的研究人员花费精力在检测frontier edges的效率上。
本包中，RRT树只是用于search边缘点，而检测到的边缘点经过滤波就会依次安排给机器人。当机器人接收到point时，就会运动到对应的点。在此期间，机器人上的传感器将会扫描建图。
而通过多个独立的RRT树来加速边缘点的检测，则是本包的创新点。
如下图所示，这个功能包主要分为三个模块。
基于RRT的边界检测模块（负责检测边界点，分为全局检测节点和局部检测节点以及基于opencv的边界检测器节点）滤波模块（存储边界点，并通过mean shift算法来聚类，检测出无效以及旧的边界点）以及task allocator模块（接收到滤波模块传来的边界点后，分配到机器人） 而本包还需要与SLAM及path planning模块(move_base)相结合来使用。
关于global detect与local detector节点，当检测到一个边界点时，local detector会重置，并且会基于机器人当前的位置重新生长。这带来两个好处：
检测边界点更快。因为机器人总是会向着边界点移动，而如果RRT树从机器人当前的位置开始，那么它到达未知区域的概率更高。机器人可能会miss掉一些地图上边角的小的边界点，而为了解决这个问题，就通过global detector，global detect会检测机器人附近的边界点用来弥补global detect的不足。 但随着地图的变大，global detector会越来越慢（或者说，随着树的变大，exploration会变慢），为此需要local detector进行加速。
frontier_opencv_detector节点是另一个边界检测器，但它不是基于 RRT。该节点使用 OpenCV 工具来检测边界点。它旨在单独运行，并且在多机器人配置中只应运行一个实例（运行此节点的其他实例没有任何区别，也就是说opencv是选装，不装照样能跑功能包）。
最初，这个节点是为了与基于 RRT 的边界检测器进行比较而实现的。在 RRT 检测器（本地和全局）旁边运行此节点可以提高 frotiner 点检测的速度。
注意：您可以运行任何类型和任意数量的检测器，所有检测器都将发布在过滤器节点订阅的同一主题上。
过滤器节点从所有检测器接收检测到的边界点，过滤这些点，并将它们传递给分配器节点以指挥机器人。过滤包括旧点和无效点的剔除，也包括多余点的剔除。
分配节点接收目标并探索目标，即过滤节点发布的过滤边界点，并据此指挥机器人向过滤后的边界点移动。分配者节点通过 move_base_node 命令机器人。
二、安装 进入到你的工作空间的src目录中，运行以下代码：
git clone https://github." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/0dd1b7c15aa5378ca0949db1929fab75/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-10-17T14:35:01+08:00" />
<meta property="article:modified_time" content="2022-10-17T14:35:01+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">【SLAM】基于rrt_explore的移动机器人自主建图</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <h2 id="%E7%B3%BB%E5%88%97%E6%96%87%E7%AB%A0%E7%9B%AE%E5%BD%95"><a id="_0"></a>系列文章目录</h2> 
<p><a class="link-info" href="https://blog.csdn.net/qq_52785580/article/details/127000553?spm=1001.2014.3001.5502" title="·【SLAM】基于explore_lite的移动机器人自主建图">·【SLAM】基于explore_lite的移动机器人自主建图</a></p> 
<p>·【SLAM】基于rrt_explore的移动机器人自主建图</p> 
<p id="articleContentId"><a class="link-info" href="https://blog.csdn.net/qq_52785580/article/details/127356838?csdn_share_tail=%7B%22type%22%3A%22blog%22%2C%22rType%22%3A%22article%22%2C%22rId%22%3A%22127356838%22%2C%22source%22%3A%22qq_52785580%22%7D" title="·【问题解决】rrt_exploration功能包使用过程中报错处理">·【问题解决】rrt_exploration功能包使用过程中报错处理</a></p> 
<div> 
 <h4 id="%E6%96%87%E7%AB%A0%E7%9B%AE%E5%BD%95">文章目录</h4> 
 <p id="main-toc"><strong>目录</strong></p> 
 <p id="%E7%B3%BB%E5%88%97%E6%96%87%E7%AB%A0%E7%9B%AE%E5%BD%95-toc" style="margin-left:0px;"></p> 
 <p id="main-toc"><strong>目录</strong></p> 
 <p id="%E7%B3%BB%E5%88%97%E6%96%87%E7%AB%A0%E7%9B%AE%E5%BD%95-toc" style="margin-left:0px;"><a href="#%E7%B3%BB%E5%88%97%E6%96%87%E7%AB%A0%E7%9B%AE%E5%BD%95" rel="nofollow">系列文章目录</a></p> 
 <p style="margin-left:0px;"><a href="#%E6%96%87%E7%AB%A0%E7%9B%AE%E5%BD%95" rel="nofollow">文章目录</a></p> 
 <p id="%E5%89%8D%E8%A8%80-toc" style="margin-left:0px;"><a href="#%E5%89%8D%E8%A8%80" rel="nofollow">前言</a></p> 
 <p id="%E4%B8%80%E3%80%81%E5%8E%9F%E7%90%86-toc" style="margin-left:0px;"><a href="#%E4%B8%80%E3%80%81%E5%8E%9F%E7%90%86" rel="nofollow">一、原理</a></p> 
 <p id="%E4%BA%8C%E3%80%81%E5%AE%89%E8%A3%85-toc" style="margin-left:0px;"><a href="#%E4%BA%8C%E3%80%81%E5%AE%89%E8%A3%85" rel="nofollow">二、安装</a></p> 
 <p id="%E4%B8%89%E3%80%81%E4%BD%BF%E7%94%A8%E8%AF%B4%E6%98%8E-toc" style="margin-left:0px;"><a href="#%E4%B8%89%E3%80%81%E4%BD%BF%E7%94%A8%E8%AF%B4%E6%98%8E" rel="nofollow">三、使用说明</a></p> 
 <p id="1.global_rrt_frontier_detector-toc" style="margin-left:40px;"><a href="#1.global_rrt_frontier_detector" rel="nofollow">1.global_rrt_frontier_detector</a></p> 
 <p id="2.local_rrt_frontier_detector-toc" style="margin-left:40px;"><a href="#2.local_rrt_frontier_detector" rel="nofollow">2.local_rrt_frontier_detector</a></p> 
 <p id="3.frontier_opencv_detector-toc" style="margin-left:40px;"><a href="#3.frontier_opencv_detector" rel="nofollow">3.frontier_opencv_detector</a></p> 
 <p id="4.filter-toc" style="margin-left:40px;"><a href="#4.filter" rel="nofollow">4.filter</a></p> 
 <p id="5.Assigner-toc" style="margin-left:40px;"><a href="#5.Assigner" rel="nofollow">5.Assigner</a></p> 
 <p id="%E5%9B%9B%E3%80%81%E4%BB%BF%E7%9C%9F%E5%AE%9E%E9%AA%8C-toc" style="margin-left:0px;"><a href="#%E5%9B%9B%E3%80%81%E4%BB%BF%E7%9C%9F%E5%AE%9E%E9%AA%8C" rel="nofollow">四、仿真实验</a></p> 
 <p id="%E5%9B%9B%E3%80%81%E4%BB%BF%E7%9C%9F%E5%AE%9E%E9%AA%8C-toc" style="margin-left:0px;"></p> 
</div> 
<hr> 
<h2 id="%E5%89%8D%E8%A8%80"><a id="_12"></a>前言</h2> 
<p>前面我们尝试了基于explore_lite的自主建图，本篇文章我们对基于rrt的自主建图算法进行探索尝试，并对其原理进行简述，然后进行在ubuntu16.04和ubuntu20.04虚拟机上都进行仿真实验，指出需要进行修改的地方以便于我们仿真通过。</p> 
<h2 id="%E4%B8%80%E3%80%81%E5%8E%9F%E7%90%86"><a id="pandas_22"></a>一、原理</h2> 
<p>这个功能包是基于2D的，通常采用图像算法的边缘检测来检测已知区域与未知区域的边界。基于Rapidly-exploring Random Trees（快速搜索随机树RRT）的探索策略。由于RRT基本上是朝向未知区域的（unexplored and unvisited），并且RRT可以扩展到更高维区域。同时采用local tree与global tree来检查边缘点，使得机器人的exploration更加高效。</p> 
<p>一旦检测到边缘后，就会取其中心为目标点，然后让机器人去探索该点。而为了检测边缘点，需要对整张地图进行处理，而这个操作通常是耗时的，为此大量的研究人员花费精力在检测frontier edges的效率上。</p> 
<p>本包中，RRT树只是用于search边缘点，而检测到的边缘点经过滤波就会依次安排给机器人。当机器人接收到point时，就会运动到对应的点。在此期间，机器人上的传感器将会扫描建图。</p> 
<p><strong>而通过多个独立的RRT树来加速边缘点的检测</strong>，则是本包的创新点。</p> 
<p>如下图所示，这个功能包主要分为三个模块。</p> 
<ul><li>基于RRT的边界检测模块（负责检测边界点，分为全局检测节点和局部检测节点以及基于opencv的边界检测器节点）</li><li>滤波模块（存储边界点，并通过mean shift算法来聚类，检测出无效以及旧的边界点）</li><li>以及task allocator模块（接收到滤波模块传来的边界点后，分配到机器人）</li></ul> 
<p>而本包还需要与SLAM及path planning模块(move_base)相结合来使用。<br>  </p> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/7a/49/pNtFsqRP_o.png"></p> 
<p></p> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/68/55/ZohkBOgb_o.png"></p> 
<p>关于<strong>global detect与local detector节点</strong>，当检测到一个边界点时，local detector会重置，并且会基于机器人当前的位置重新生长。这带来两个好处：</p> 
<ol><li>检测边界点更快。因为机器人总是会向着边界点移动，而如果RRT树从机器人当前的位置开始，那么它到达未知区域的概率更高。</li><li>机器人可能会miss掉一些地图上边角的小的边界点，而为了解决这个问题，就通过global detector，global detect会检测机器人附近的边界点用来弥补global detect的不足。</li></ol> 
<p>但随着地图的变大，global detector会越来越慢（或者说，随着树的变大，exploration会变慢），为此需要local detector进行加速。</p> 
<p class="img-center"><img alt="" height="451" src="https://images2.imgbox.com/e6/0f/tx6xuQ5Z_o.png" width="457"></p> 
<p><strong> <span style="color:#333333;"><span style="background-color:#ffffff;">frontier_opencv_detector节点</span></span></strong>是另一个边界检测器，但它不是基于 RRT。该节点使用 OpenCV 工具来检测边界点。它旨在单独运行，并且在多机器人配置中只应运行一个实例（运行此节点的其他实例没有任何区别，也就是说opencv是选装，不装照样能跑功能包）。<br> 最初，这个节点是为了与基于 RRT 的边界检测器进行比较而实现的。在 RRT 检测器（本地和全局）旁边运行此节点可以提高 frotiner 点检测的速度。<br> 注意：您可以运行任何类型和任意数量的检测器，所有检测器都将发布在过滤器节点订阅的同一主题上。</p> 
<p><strong>过滤器节点</strong>从所有检测器接收检测到的边界点，过滤这些点，并将它们传递给分配器节点以指挥机器人。过滤包括旧点和无效点的剔除，也包括多余点的剔除。</p> 
<p><strong>分配节点</strong>接收目标并探索目标，即过滤节点发布的过滤边界点，并据此指挥机器人向过滤后的边界点移动。分配者节点通过 move_base_node 命令机器人。</p> 
<h2 id="%E4%BA%8C%E3%80%81%E5%AE%89%E8%A3%85"><strong>二、安装</strong></h2> 
<p>进入到你的工作空间的src目录中，运行以下代码：</p> 
<pre><code class="language-bash">git clone https://github.com/hasauino/rrt_exploration.git</code></pre> 
<p>或进入这个<a class="link-info" href="https://github.com/hasauino/rrt_exploration" title="网址">网址</a>，手动下载</p> 
<p>然后下载相关的依赖：</p> 
<p>OpenCV(cv2)</p> 
<pre><code class="language-bash">sudo apt-get install python-opencv</code></pre> 
<p>gmapping</p> 
<pre><code class="language-bash">sudo apt-get install ros- kinetic - gmapping</code></pre> 
<p>navigation</p> 
<pre><code class="language-bash">sudo apt-get install ros- kinetic - navigation</code></pre> 
<p>Sklearn</p> 
<pre><code class="language-bash">sudo apt-get install python-scikits-learn</code></pre> 
<p>Numpy</p> 
<pre><code class="language-bash">sudo apt-get install python-numpy</code></pre> 
<p> 如果Numpy和SKlearn下载不了可以使用pip下载</p> 
<pre><code class="language-bash">pip install numpy
pip install scikits-learn</code></pre> 
<h2 id="%E4%B8%89%E3%80%81%E4%BD%BF%E7%94%A8%E8%AF%B4%E6%98%8E">三、使用说明</h2> 
<h3 id="1.global_rrt_frontier_detector">1.<span style="color:#333333;"><span style="background-color:#ffffff;">global_rrt_frontier_detector</span></span></h3> 
<p><strong>订阅的话题：</strong>全局识别器订阅地图数据和clicked_point 数据</p> 
<ul><li>地图数据：大家都知道就是slam节点发布的map话题</li><li>clicked_point 数据是rrt_explore特定的，可以由用户设定要探索的区域，该区域由rviz给出的五个点规定。前四个点是四个定义要探索的方形区域，最后一个点是树的起点。</li></ul> 
<p><strong>发布的话题：</strong>全局识别器发布检测到的点和形状</p> 
<ul><li>检测到的点：是机器人下一个需要前往的点</li><li>形状：是一些线条用来可视化RRT。</li></ul> 
<p><strong>参数：</strong></p> 
<ul><li>map_topic（字符串，默认：“/robot_1/map”）此参数定义节点将在其上接收地图的主题名称</li><li>eta ( float , 默认值: 0.5)该参数控制用于边界点检测的RRT的增长率，单位为米。这个参数应该根据地图大小来设置，一个非常大的值会导致树生长得更快，从而更快地检测到边界点，但是一个大的增长率也意味着树会丢失地图中的小角落（大概意思是分辨率）。</li></ul> 
<h3 id="2.local_rrt_frontier_detector">2.<span style="color:#333333;"><span style="background-color:#ffffff;">local_rrt_frontier_detector</span></span></h3> 
<p><strong>订阅的话题：</strong>局部识别器和全局识别器基本相同，是订阅地图数据和clicked_point 数据。</p> 
<ul><li>地图数据大家是slam节点发布的map话题</li><li>clicked_point 数据是可以由用户设定要探索的区域，该区域由rviz给出的五个点规定。前四个点是四个定义要探索的方形区域，最后一个点是树的起点。</li></ul> 
<p><strong>发布的话题：</strong>全局识别器发布检测到的点和形状</p> 
<ul><li>检测到的点：是机器人下一个需要前往的点</li><li>形状：是一些线条用来可视化RRT。</li></ul> 
<p><strong>参数：</strong></p> 
<ul><li>map_topic（字符串，默认：“/robot_1/map”）此参数定义节点将在其上接收地图的主题名称</li><li>eta ( float , 默认值: 0.5)该参数控制用于边界点检测的RRT的增长率，单位为米。这个参数应该根据地图大小来设置，一个非常大的值会导致树生长得更快，从而更快地检测到边界点，但是一个大的增长率也意味着树会丢失地图中的小角落（大概意思是分辨率）。</li><li>/robot_1/base_link（字符串，默认：“/robot_1/base_link”）连接到机器人的底盘位置。每次树重置时，都会从从该帧获得的当前机器人位置开始。</li></ul> 
<h3 id="3.frontier_opencv_detector">3.<span style="color:#333333;"><span style="background-color:#ffffff;">frontier_opencv_detector</span></span></h3> 
<p><strong>订阅的话题：</strong>opencv识别器只订阅地图数据</p> 
<ul><li>地图数据：是slam节点发布的map话题。</li></ul> 
<p><strong>发布的话题：</strong>全局识别器发布检测到的点和形状。</p> 
<ul><li>检测到的点：是机器人下一个需要前往的点</li><li>形状：是一些线条用来可视化RRT。</li></ul> 
<p><strong>参数：</strong></p> 
<ul><li>map_topic（字符串，默认：“/robot_1/map”）此参数定义节点将在其上接收地图的主题名称</li></ul> 
<h3 id="4.filter">4.filter</h3> 
<p><strong>订阅的话题：</strong>过滤器订阅地图数据、robot_x/move_base_node/global_costmap/costmap和目标主题</p> 
<ul><li>地图数据就是slam节点发布的map话题</li><li>robot_x/move_base_node/global_costmap/costmap：是由导航堆栈发布的代价地图，用来删除无效点</li><li>目标主题：名称由 goals_topic 参数定义，这是过滤器节点接收检测到的边界点的主题。</li></ul> 
<p><strong>发布的话题：</strong>过滤器发布前沿、质心和filters_points</p> 
<ul><li>前沿：过滤器节点发布接收到的边界点以在 Rviz 上进行可视化的主题</li><li>质心：过滤器节点仅发布过滤的边界点以在 Rviz 上进行可视化的主题</li><li>filters_points：所有过滤的点都作为点数组发送到该主题，然后发送给分配者节点</li></ul> 
<p><strong>参数：</strong></p> 
<ul><li>map_topic（字符串，默认：“/robot_1/map”）此参数定义节点将在其上接收地图的主题名称，该地图用于知道哪些点不再是边界点（旧点）</li><li>costmap_clearing_threshold ( float , 默认值: 70.0)任何占用率大于此阈值的边界点（墙）都将被视为无效。占用值是从代价地图中获得的。</li><li>info_radius ( float , 默认值: 1.0)用于计算边界点信息增益的信息半径。</li><li>goals_topic（字符串，默认值：“/detected_points”）定义节点接收检测到的边界点的主题。</li><li>n_robots（float，默认值：1.0）机器人数量。</li><li><em>速率（浮动，默认值：100.0）</em></li><li><em>节点循环速率（Hz）。</em></li></ul> 
<p>下面两个主题都是使用多机器人联合建图时用到，单机器人保持默认值即可</p> 
<ul><li>命名空间（字符串，默认值<em>：）</em>命名空间用于为机器人 tf 框架名称和主题名称添加前缀。通常，对于单个机器人案例，它是一个空字符串。但是，在多机器人的情况下，机器人名称（它们的 tf 框架和主题名称）应该以命名空间为前缀（如前所述）。例如，如果您有三个具有以下命名空间的机器人：“/robot_1”、“/robot_2”和“/robot_3”，则必须将此参数设置为“/robot_”</li><li>namespace_init_count ( float , 默认值: 1.0)机器人名称的起始索引，该索引遵循上述命名空间。仅用于多机器人案例（单机器人案例不使用此参数，可忽略）。在多机器人的情况下，机器人名称有一个命名空间（您可以使用前面提到的参数设置），然后是一个索引。如果您设置的机器人名称不以 1 开头，那么您可以根据您的设置使用此参数。示例：假设您有两个命名空间为“/robot_4”和“/robot_5”的机器人，那么您必须将此参数设置为 4。</li></ul> 
<h3 id="5.Assigner">5.Assigner</h3> 
<p><strong>订阅的话题：</strong>全局识别器订阅地图数据、过滤边界点主题和目标主题。</p> 
<ul><li>地图数据：就是slam节点发布的map话题</li><li>过滤边界点主题：主题名称由 ~frontiers_topic 参数定义</li><li>目标主题：主题名称由 ~goals_topic 参数定义。这是过滤器节点接收检测到的边界点的主题</li></ul> 
<p><strong>发布的话题：</strong>无</p> 
<p><strong>参数：</strong></p> 
<ul><li>map_topic（字符串，默认：“/robot_1/map”）此参数定义节点将在其上接收地图的主题名称</li><li>info_radius ( float , 默认值: 1.0)：用于计算边界点信息增益的信息半径</li><li>info_multiplier ( float , 默认值: 3.0)：单位是米。该参数用于重视边界点的信息增益而不是成本（到边界点的预期行驶距离）。</li><li>hysteresis_radius ( float , 默认值: 3.0)单位是米。此参数定义滞后半径</li><li>hysteresis_gain ( float , 默认值: 2.0)单位是米。此参数定义滞后增益。</li><li>frontiers_topic（字符串，默认值：“/filtered_points”）分配者节点接收过滤边界点的主题。</li><li>n_robots（浮动，默认值：1.0）机器人数量</li><li>namespace（字符串，默认值：）命名空间用于为机器人 tf 框架名称和主题名称添加前缀。</li><li>namespace_init_count ( float , 默认值: 1.0)机器人名称的起始索引。</li><li>delay_after_assignement ( float , 默认值: 0.5)单位是秒。它定义了每个机器人分配后的延迟量。</li><li>global_frame ( string , 默认: "/map")用作全局框架的框架名称。在单机器人中，与“map_topic”参数相同。在多机器人情况下，与全局框架对应的是框架名称。</li></ul> 
<p>最终这些参数的设置都放在了simple.launch中</p> 
<pre><code class="language-XML">&lt;!-- Launch file for the rrt-detector and the assigner --&gt;


&lt;launch&gt;
&lt;arg name="eta" value="1.0"/&gt;
&lt;arg name="Geta" value="15.0"/&gt;
&lt;param name="namespace_init_count" value="1"/&gt;


  &lt;node pkg="rrt_exploration" type="global_rrt_detector" name="global_detector" output="screen"&gt;
  &lt;param name="eta" value="$(arg Geta)"/&gt;
  &lt;param name="map_topic" value="/map"/&gt;
  &lt;/node&gt;
  
  &lt;node pkg="rrt_exploration" type="local_rrt_detector" name="local_detector" output="screen"&gt;
  &lt;param name="eta" value="$(arg eta)"/&gt;
  &lt;param name="map_topic" value="/map"/&gt;
  &lt;param name="robot_frame" value="/base_link"/&gt;
  &lt;/node&gt;
 
  
  &lt;node pkg="rrt_exploration" type="filter.py" name="filter" output="screen"&gt;
  &lt;param name="map_topic" value="/map"/&gt;
  &lt;param name="info_radius" value="1"/&gt; 
  &lt;param name="costmap_clearing_threshold" value="70"/&gt; 
  &lt;param name="goals_topic" value="/detected_points"/&gt;
  &lt;param name="namespace" value=""/&gt; 
  &lt;param name="n_robots" value="1"/&gt;
  &lt;param name="rate" value="100"/&gt;
  &lt;/node&gt;
  
  &lt;node pkg="rrt_exploration" type="assigner.py" name="assigner" output="screen"&gt;
  &lt;param name="map_topic" value="/map"/&gt;
  &lt;param name="global_frame" value="/map"/&gt;
  &lt;param name="info_radius" value="1"/&gt; 
  &lt;param name="info_multiplier" value="3.0"/&gt; 
  &lt;param name="hysteresis_radius" value="3.0"/&gt; 
  &lt;param name="hysteresis_gain" value="2.0"/&gt; 
  &lt;param name="frontiers_topic" value="/filtered_points"/&gt; 
  &lt;param name="n_robots" value="1"/&gt;
  &lt;param name="namespace" value=""/&gt;
  &lt;param name="delay_after_assignement" value="0.5"/&gt;
  &lt;param name="rate" value="100"/&gt;
  &lt;/node&gt;
  
&lt;/launch&gt;</code></pre> 
<h2 id="%E5%9B%9B%E3%80%81%E4%BB%BF%E7%9C%9F%E5%AE%9E%E9%AA%8C">四、仿真实验</h2> 
<h3><a id="1_27"></a></h3> 
<p>如果使用rrt作者提供的例程，成功运行这个功能包很简单，只需要：</p> 
<pre><code class="language-bash">roslaunch rrt_exploration_tutorials simple.launch
roslaunch rrt_exploration simple.launch</code></pre> 
<p>但是如果想在我们自己搭建的仿真环境中使用就需要进行比较多的改动：</p> 
<p class="img-center"><img alt="" height="677" src="https://images2.imgbox.com/c8/fa/hSVfH6zq_o.png" width="977"></p> 
<p>这里我把原来加载机器人模型的部分进行了注释，保留了源代码中给出的move_base文件和rviz配置文件，然后接下来对move_base文件进行修改：</p> 
<p class="img-center"><img alt="" height="550" src="https://images2.imgbox.com/09/18/KIGwZX1u_o.png" width="836"></p> 
<p>首先，我将这里的激光雷达话题重映射进行了注释，因为我们自己搭建的雷达模型输出话题是/scan。</p> 
<p class="img-center"><img alt="" height="473" src="https://images2.imgbox.com/c2/bd/2NIupAed_o.png" width="979"></p> 
<p>然后是这里的重映射，给move_base发送的速度控制指令，我们机器人的速度控制话题是/cmd_vel，不需要重映射，应该是作者使用的机器人速度控制指令是/mobile_base/commands/velocity。</p> 
<p class="img-center"><img alt="" height="331" src="https://images2.imgbox.com/70/bf/yVKkyEzw_o.png" width="977"></p> 
<p>最后就是文件最后的几个话题、坐标系需要换成我们搭建的机器人的名字。</p> 
<p>另外要注意一点，如果想使用自己的move_base文件，这里需要修改为move_base_node，因为作者在rrt代码中对move_base的命名是这个，否则就需要修改源代码。</p> 
<p class="img-center"><img alt="" height="233" src="https://images2.imgbox.com/c7/c8/pp2pd1MT_o.png" width="908"></p> 
<p>最后的仿真结果如下，开始仿真：</p> 
<p class="img-center"><img alt="" height="751" src="https://images2.imgbox.com/70/04/7bDwCxS5_o.png" width="929"></p> 
<p>建图完成：</p> 
<p class="img-center"><img alt="" height="380" src="https://images2.imgbox.com/fd/f3/LbGtzU4r_o.png" width="522"></p> 
<p>另外，如果要在ubuntu20.04上使用这个包，需要对文件进行修改：</p> 
<p>首先是rrt_exploration包中的simple.launch，需要将所有的frame_id前面的"/" 都去掉，而所有的topic前面都需要带着"/"：</p> 
<pre><code class="language-XML">&lt;!-- Launch file for the rrt-detector and the assigner --&gt;


&lt;launch&gt;
&lt;arg name="eta" value="1.0"/&gt;
&lt;arg name="Geta" value="15.0"/&gt;
&lt;param name="namespace_init_count" value="1"/&gt;


  &lt;node pkg="rrt_exploration" type="global_rrt_detector" name="global_detector" output="screen"&gt;
  &lt;param name="eta" value="$(arg Geta)"/&gt;
  &lt;param name="map_topic" value="/map"/&gt;
  &lt;/node&gt;
  
  &lt;node pkg="rrt_exploration" type="local_rrt_detector" name="local_detector" output="screen"&gt;
  &lt;param name="eta" value="$(arg eta)"/&gt;
  &lt;param name="map_topic" value="/map"/&gt;
  &lt;param name="robot_frame" value="base_link"/&gt;
  &lt;/node&gt;
 
  
  &lt;node pkg="rrt_exploration" type="filter.py" name="filter" output="screen"&gt;
  &lt;param name="map_topic" value="/map"/&gt;
  &lt;param name="info_radius" value="1"/&gt; 
  &lt;param name="costmap_clearing_threshold" value="70"/&gt; 
  &lt;param name="goals_topic" value="/detected_points"/&gt;
  &lt;param name="namespace" value=""/&gt; 
  &lt;param name="n_robots" value="1"/&gt;
  &lt;param name="rate" value="100"/&gt;
  &lt;/node&gt;
  
  &lt;node pkg="rrt_exploration" type="assigner.py" name="assigner" output="screen"&gt;
  &lt;param name="map_topic" value="/map"/&gt;
  &lt;param name="global_frame" value="map"/&gt;
  &lt;param name="info_radius" value="1"/&gt; 
  &lt;param name="info_multiplier" value="3.0"/&gt; 
  &lt;param name="hysteresis_radius" value="3.0"/&gt; 
  &lt;param name="hysteresis_gain" value="2.0"/&gt; 
  &lt;param name="frontiers_topic" value="/filtered_points"/&gt; 
  &lt;param name="n_robots" value="1"/&gt;
  &lt;param name="namespace" value=""/&gt;
  &lt;param name="delay_after_assignement" value="0.5"/&gt;
  &lt;param name="rate" value="100"/&gt;
  &lt;/node&gt;
  
&lt;/launch&gt;</code></pre> 
<p>然后对于rrt_exploration包中的move_baseSafe.launch也需要进行上述修改：</p> 
<pre><code class="language-XML">&lt;!-- move base --&gt;
&lt;launch&gt;
  &lt;master auto="start"/&gt;

  &lt;arg name="namespace"/&gt;
  &lt;arg name="odom_frame_id"   default="odom"/&gt;
  &lt;arg name="base_frame_id"   default="base_link"/&gt;
  &lt;arg name="global_frame_id" default="map"/&gt;
  &lt;arg name="laser_frame_id" default="laser_link" /&gt;
  &lt;arg name="laser_topic" default="/scan" /&gt;


&lt;param name="use_sim_time" value="true" /&gt;

    &lt;node pkg="gmapping" type="slam_gmapping" name="slam_gmapping" output="screen" &gt;
      &lt;remap from="/scan" to="$(arg laser_topic)"/&gt;
      &lt;param name="map_frame" value="$(arg global_frame_id)"/&gt;
      &lt;param name="odom_frame" value="$(arg odom_frame_id)"/&gt;
      &lt;param name="base_frame" value="$(arg base_frame_id)"/&gt;
      &lt;param name="map_update_interval" value="2.0"/&gt;
      &lt;param name="maxUrange" value="50.0"/&gt;
      &lt;param name="maxRange" value="50.0"/&gt;
      &lt;param name="sigma" value="0.05"/&gt;
      &lt;param name="kernelSize" value="1"/&gt;
      &lt;param name="lstep" value="0.05"/&gt;
      &lt;param name="astep" value="0.05"/&gt;
      &lt;param name="iterations" value="5"/&gt;
      &lt;param name="lsigma" value="0.075"/&gt;
      &lt;param name="ogain" value="3.0"/&gt;
      &lt;param name="lskip" value="0"/&gt;
      &lt;param name="srr" value="0.01"/&gt;
      &lt;param name="srt" value="0.02"/&gt;
      &lt;param name="str" value="0.01"/&gt;
      &lt;param name="stt" value="0.02"/&gt;
      &lt;param name="linearUpdate" value="0.01"/&gt;
      &lt;param name="angularUpdate" value="0.01"/&gt;
      &lt;param name="temporalUpdate" value="0.1"/&gt;
      &lt;param name="resampleThreshold" value="0.5"/&gt;
      &lt;param name="particles" value="30"/&gt;
      &lt;param name="xmin" value="-5.0"/&gt;
      &lt;param name="ymin" value="-5.0"/&gt;
      &lt;param name="xmax" value="5.0"/&gt;
      &lt;param name="ymax" value="5.0"/&gt;
      &lt;param name="delta" value="0.1"/&gt;
      &lt;param name="llsamplerange" value="0.01"/&gt;
      &lt;param name="llsamplestep" value="0.01"/&gt;
      &lt;param name="lasamplerange" value="0.005"/&gt;
      &lt;param name="lasamplestep" value="0.005"/&gt;
      &lt;param name="minimumScore" value="0.005"/&gt;
    &lt;/node&gt;


  &lt;node pkg="move_base" type="move_base" respawn="false" name="move_base_node" output="screen"&gt;
    &lt;param name="footprint_padding" value="0.01" /&gt;
    &lt;param name="controller_frequency" value="5.0" /&gt;
    &lt;param name="controller_patience" value="3.0" /&gt;
    &lt;param name="oscillation_timeout" value="30.0" /&gt;
    &lt;param name="oscillation_distance" value="0.5" /&gt;
    &lt;param name="planner_patience" value="1" /&gt;
    &lt;param name="controller_patience" value="1" /&gt; 
    &lt;remap from="/cmd_vel" to="/cmd_vel"/&gt;
    &lt;param name="recovery_behavior_enabled" value="false" /&gt;
    &lt;rosparam file="$(find rrt_exploration_tutorials)/param/costmap_common_params.yaml" command="load" ns="global_costmap" /&gt;
    &lt;rosparam file="$(find rrt_exploration_tutorials)/param/costmap_common_params.yaml" command="load" ns="local_costmap" /&gt;
    &lt;rosparam file="$(find rrt_exploration_tutorials)/param/local_costmap_params.yaml" command="load" /&gt;
    &lt;rosparam file="$(find rrt_exploration_tutorials)/param/global_costmap_params.yaml" command="load" /&gt;
    &lt;rosparam file="$(find rrt_exploration_tutorials)/param/base_local_planner_params.yaml" command="load" /&gt;  
    &lt;param name="global_costmap/global_frame" value="$(arg global_frame_id)"/&gt;
    &lt;param name="global_costmap/robot_base_frame" value="$(arg base_frame_id)"/&gt;
    &lt;param name="global_costmap/laser_scan_sensor/sensor_frame" value="$(arg laser_frame_id)"/&gt;
    &lt;param name="global_costmap/laser_scan_sensor/topic" value="$(arg laser_topic)"/&gt;    
    &lt;param name="local_costmap/global_frame" value="$(arg odom_frame_id)"/&gt;
    &lt;param name="local_costmap/robot_base_frame" value="$(arg base_frame_id)"/&gt;
    &lt;param name="local_costmap/laser_scan_sensor/sensor_frame" value="$(arg laser_frame_id)"/&gt;
    &lt;param name="local_costmap/laser_scan_sensor/topic" value="$(arg laser_topic)"/&gt;
    &lt;param name="local_costmap/obstacle_layer/laser_scan_sensor/topic" value="$(arg laser_topic)"/&gt;
  &lt;/node&gt;

&lt;/launch&gt;</code></pre> 
<p>在ubuntu20.04中的仿真效果如下：</p> 
<p class="img-center"><img alt="" height="671" src="https://images2.imgbox.com/e7/e3/69Ht9TXL_o.png" width="694"></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/a794ce31ef8642c14bfc1570d793248e/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">【问题解决】rrt_exploration功能包使用过程中报错处理</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/69db9200fe90bb6f69014e8472962880/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">该虚拟机似乎正在使用中</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>