<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>开源解析XML的解析库TinyXML - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="开源解析XML的解析库TinyXML" />
<meta property="og:description" content="最近在做公司项目的需求，要对配置文件进行操作，从而接触了MSXML2和TinyXML，公司的公共库是用微软的MSXML2实现的，实现起来比较麻烦的，刚开始看的时候有点小困难，网上就搜索了一些c&#43;&#43;方面的解析器，觉得开源的TinyXML还是不错的，使用起来很舒服，因为它的API接口和JAVA的十分类似，面向对象性很好。
TinyXML是一个开源的解析XML的解析库，能够用于C&#43;&#43;，能够在Windows或Linux中编译。这个解析库的模型通过解析XML文件，然后在内存中生成DOM模型，从而让我们很方便的遍历这棵XML树。DOM模型即文档对象模型，是将整个文档分成多个元素（如书、章、节、段等），并利用树型结构表示这些元素之间的顺序关系以及嵌套包含关系。
要用TinyXML，主要需要两个文件头(.h)以及四个源文件(.c&#43;&#43;)，将其导入到需要的工程，当然也可以编译成dll文件进行调用，所需要的文件会在我的例子工程中存在，可以自主去下载运行看，以下是TinyXMLDemo源码。
首先要通过TinyXML创建xml文件，代码如下：
bool CreateXmlFile(wstring&amp; szFileName) {//创建xml文件,szFilePath为文件保存的路径,若创建成功返回true,否则false try { //创建一个XML的文档对象。 TiXmlDocument *myDocument = new TiXmlDocument(); //创建一个根元素并连接。 TiXmlElement *RootElement = new TiXmlElement(&#34;Persons&#34;); myDocument-&gt;LinkEndChild(RootElement); //创建一个Person元素并连接。 TiXmlElement *PersonElement = new TiXmlElement(&#34;Person&#34;); RootElement-&gt;LinkEndChild(PersonElement); //设置Person元素的属性。 PersonElement-&gt;SetAttribute(&#34;ID&#34;, &#34;1&#34;); //创建name元素、age元素并连接。 TiXmlElement *NameElement = new TiXmlElement(&#34;name&#34;); TiXmlElement *AgeElement = new TiXmlElement(&#34;age&#34;); PersonElement-&gt;LinkEndChild(NameElement); PersonElement-&gt;LinkEndChild(AgeElement); //设置name元素和age元素的内容并连接。 TiXmlText *NameContent = new TiXmlText(&#34;周星星&#34;); TiXmlText *AgeContent = new TiXmlText(&#34;22&#34;); NameElement-&gt;LinkEndChild(NameContent); AgeElement-&gt;LinkEndChild(AgeContent); CString appPath = GetAppPath(); wstring seperator = L&#34;\\&#34;; wstring fullPath = appPath." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/0dca5c96254b8218afd520a86761cc9d/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2013-09-04T00:09:11+08:00" />
<meta property="article:modified_time" content="2013-09-04T00:09:11+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">开源解析XML的解析库TinyXML</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p><span style="white-space:pre"></span><span style="white-space:pre"></span>最近在做公司项目的需求，要对配置文件进行操作，从而接触了MSXML2和TinyXML，公司的公共库是用微软的MSXML2实现的，实现起来比较麻烦的，刚开始看的时候有点小困难，网上就搜索了一些c++方面的解析器，觉得开源的TinyXML还是不错的，使用起来很舒服，因为它的API接口和JAVA的十分类似，面向对象性很好。</p> 
<p><span style="white-space:pre"></span>TinyXML是一个开源的解析XML的解析库，能够用于C++，能够在Windows或Linux中编译。这个解析库的模型通过解析XML文件，然后在内存中生成DOM模型，从而让我们很方便的遍历这棵XML树。DOM模型即文档对象模型，是将整个文档分成多个元素（如书、章、节、段等），并利用树型结构表示这些元素之间的顺序关系以及嵌套包含关系。</p> 
<p><span style="white-space:pre"></span>要用TinyXML，主要需要两个文件头(.h)以及四个源文件(.c++)，将其导入到需要的工程，当然也可以编译成dll文件进行调用，所需要的文件会在我的例子工程中存在，可以自主去下载运行看，以下是<a target="_blank" href="http://download.csdn.net/detail/xxm137164869/6206157" rel="noopener noreferrer">TinyXMLDemo源码</a>。</p> 
<p><span style="white-space:pre"></span>首先要通过TinyXML创建xml文件，代码如下：</p> 
<p><span style="white-space:pre"></span></p> 
<pre><code class="language-cpp">bool CreateXmlFile(wstring&amp; szFileName)
{//创建xml文件,szFilePath为文件保存的路径,若创建成功返回true,否则false
	try
	{
		//创建一个XML的文档对象。
		TiXmlDocument *myDocument = new TiXmlDocument();
		//创建一个根元素并连接。
		TiXmlElement *RootElement = new TiXmlElement("Persons");
		myDocument-&gt;LinkEndChild(RootElement);
		//创建一个Person元素并连接。
		TiXmlElement *PersonElement = new TiXmlElement("Person");
		RootElement-&gt;LinkEndChild(PersonElement);
		//设置Person元素的属性。
		PersonElement-&gt;SetAttribute("ID", "1");
		//创建name元素、age元素并连接。
		TiXmlElement *NameElement = new TiXmlElement("name");
		TiXmlElement *AgeElement = new TiXmlElement("age");
		PersonElement-&gt;LinkEndChild(NameElement);
		PersonElement-&gt;LinkEndChild(AgeElement);
		//设置name元素和age元素的内容并连接。
		TiXmlText *NameContent = new TiXmlText("周星星");
		TiXmlText *AgeContent = new TiXmlText("22");
		NameElement-&gt;LinkEndChild(NameContent);
		AgeElement-&gt;LinkEndChild(AgeContent);
		CString appPath = GetAppPath();
		wstring seperator = L"\\";
		wstring fullPath = appPath.GetBuffer(0) +seperator+szFileName;
		myDocument-&gt;SaveFile(ws2s(fullPath).c_str());//保存到文件
	}
	catch (string&amp; e)
	{
		return false;
	}
	return true;
}
</code></pre>代码中详细用注解表示出了创建过程以及相应代码的作用，其中一些小细节将在最后统一进行阐述。 
<p></p> 
<p><span style="white-space:pre"></span>接下来就是要读xml文件，代码如下：</p> 
<p></p> 
<pre><code class="language-cpp">bool ReadXmlFile(wstring&amp; szFileName)
{//读取Xml文件，并遍历
	try
	{
		CString appPath = GetAppPath();
		wstring seperator = L"\\";
		wstring fullPath = appPath.GetBuffer(0) +seperator+szFileName;
		//创建一个XML的文档对象。
		TiXmlDocument *myDocument = new TiXmlDocument(ws2s(fullPath).c_str());
		myDocument-&gt;LoadFile();
		//获得根元素，即Persons。
		TiXmlElement *RootElement = myDocument-&gt;RootElement();
		//输出根元素名称，即输出Persons。
		cout &lt;&lt; RootElement-&gt;Value() &lt;&lt; endl;
		//获得第一个Person节点。
		cout&lt;&lt;RootElement-&gt;Column()&lt;&lt;"ddd"&lt;&lt;endl;
		TiXmlElement *FirstPerson = RootElement-&gt;FirstChildElement();
		//获得第一个Person的name节点和age节点和ID属性。
		TiXmlElement *NameElement = FirstPerson-&gt;FirstChildElement();
		TiXmlElement *AgeElement = NameElement-&gt;NextSiblingElement();
		TiXmlAttribute *IDAttribute = FirstPerson-&gt;FirstAttribute();
		//输出第一个Person的name内容，即周星星；age内容，即；ID属性，即。
		cout &lt;&lt; NameElement-&gt;FirstChild()-&gt;Value() &lt;&lt; endl;
		cout &lt;&lt; AgeElement-&gt;FirstChild()-&gt;Value() &lt;&lt; endl;
		cout &lt;&lt; IDAttribute-&gt;Value()&lt;&lt; endl;
	}
	catch (string&amp; e)
	{
		return false;
	}
	return true;
}</code></pre> 
<span style="white-space:pre"> </span>由于是处理文件，难免会遇到中文之类的，如果只是用string来表示，难免会出现乱码之类的，所以在源代码中用到了CString以及wstring，是为了保证编码的准确性，但是TinyXML不支持宽字符的，所以要对数据进行处理。CString的c_str()得到的是wchar_t * 类型的数据，所以要写一个函数专门是对宽字符进行转换，函数如下： 
<p></p> 
<p></p> 
<pre><code class="language-cpp">std::string ws2s(const std::wstring&amp; ws)
{
	std::string curLocale = setlocale(LC_ALL, NULL);        // curLocale = "C";
	setlocale(LC_ALL, "chs");
	const wchar_t* _Source = ws.c_str();
	size_t _Dsize = 2 * ws.size() + 1; http://
	char *_Dest = new char[_Dsize];
	memset(_Dest,0,_Dsize);
	wcstombs(_Dest,_Source,_Dsize);
	std::string result = _Dest;
	delete []_Dest;
	setlocale(LC_ALL, curLocale.c_str());
	return result;
}</code></pre> 
<br> 
<span style="white-space:pre"></span>由于程序的需要，这边还对程序一些路径进行获取，这些是调用系统的API进行获取，主要是GetModuleFileName函数，代码如下： 
<p></p> 
<p></p> 
<pre><code class="language-cpp">CString GetAppPath()
{//获取应用程序根目录
	TCHAR modulePath[MAX_PATH];
	GetModuleFileName(NULL, modulePath, MAX_PATH);
	CString strModulePath(modulePath);
	strModulePath = strModulePath.Left(strModulePath.ReverseFind(_T('\\')));
	return strModulePath;
}</code></pre> 
<span style="white-space:pre"> </span>运行结果如下： 
<p></p> 
<p>        <img src="https://images2.imgbox.com/d9/51/eBXUJ5IL_o.png" alt=""><br> <span style="white-space:pre"></span>这个只是一个小测例，主要其中没有对代码的健壮性进行处理，比如如果文件没有创建的时候进行读取 应该有个安全措施，文件的格式和代码读取有差异的时候应该有个容错的机制，xml文件没有正确创建等等问题，这些在真实项目中都是要有体现，这个需要自己去考虑，这边不做详细说明。需要源码的可以点击一下链接进行下载<a target="_blank" href="http://download.csdn.net/detail/xxm137164869/6206157" rel="noopener noreferrer">TinyXMLDemo源码</a></p> 
<p><span style="white-space:pre"></span></p> 
<p><span style="white-space:pre"></span>TinyXML操作xml文件<a target="_blank" href="http://download.csdn.net/detail/xxm137164869/6206157" rel="noopener noreferrer">TinyXMLDemo源码</a></p> 
<p><br> </p> 
<p><br> </p> 
<p><br> </p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/21fb15a149feb8e442c3effd3aa69884/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">【转】解决 由于没有公钥，无法验证下列签名 :NO_PUBKEY</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/bf7d0be2ff8e6cf55f2da613521d816e/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">iOS pdf的显示和浏览</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>