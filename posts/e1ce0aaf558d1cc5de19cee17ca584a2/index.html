<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>假溢出的解决策略 - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="假溢出的解决策略" />
<meta property="og:description" content="假溢出：在顺序队列中，队列出队时并没有像线性表那样使后面的元素往前移。
为了解决假溢出，常用的方法是把队列想成一个首尾相接的环，这种叫循环队列。在循环队列的入队和出队操作中，用到了求模运算（%），以确保front和rear的值保持在队列的有效范围内。
对于队列q，初始化为空队列使q-&gt;front==q-&gt;rear==0。
新元素入队时操作为：
q-&gt;data[q-&gt;rear]=x; q-&gt;rear=(q-&gt;rear&#43;1)%MAXSIZE; 出队操作为：
x=q-&gt;data[q-&gt;front]; q-&gt;front=(q-&gt;front&#43;1)%MAXSIZE; 此时我们发现从一开始一直入队直到队列满时，此时q-&gt;front==q-&gt;rear==0;和判队列空的条件一摸一样，那怎么办？？我们有以下三种方案
闲置循环队列中一个元素空间。当 rear 的下一个位置是 front 时，则宣告列满。此时，循环队列为空的条件为 rear==front，而循环队列为满的条件为:(q-&gt;rear&#43;1)%MAXSIZE==q-&gt;front。按照这种办法，循环队列出队、入队操作不变，只是入队时循环队列的判断条件修改为(q-&gt;rear&#43;1)%MAXSIZE= q-&gt;front 即可。
在循环队列上增加一个标志变量 flag，初始时q-&gt;flag=0。当因为入队操作q-&gt;front==q-&gt;rear时，置q-&gt;flag为1;当因为出队操作使q-&gt;front==q-&gt;rear 时，置 q-&gt;flag为0。因此，循环队列空的条件为q-&gt;flag==0&amp;&amp;q-&gt;front==q-&gt;rear,循环队列满的条件为 q-&gt;flag==1&amp;&amp;q-&gt;front==q-&gt;rear。
在循环队列中增加一个计数器 count，初始时 count=0;成功出队时 q-&gt;count减1，成功入队时 count 加1。因此，循环队列空的条件为 q-&gt;count==0。循环队列满的条件为 q-&gt;count==MAXSIZE，或者 q-&gt;count&gt;0&amp;&amp;q-&gt;rear==q-&gt;front。
flag法
#define _CRT_SECURE_NO_WARNINGS #include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; typedef int DataType; #define MAXSIZE 6 typedef struct { DataType data[MAXSIZE]; int front, rear; int flag; }CSeqQueue; void Init_Queue(CSeqQueue* q) { q-&gt;front = 0; q-&gt;rear = 0; q-&gt;flag = 0; } int Out_Queue(CSeqQueue* q, DataType* x) { if (q-&gt;flag == 0 &amp;&amp; q-&gt;front == q-&gt;rear) { printf(&#34;" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/e1ce0aaf558d1cc5de19cee17ca584a2/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-02-27T19:43:13+08:00" />
<meta property="article:modified_time" content="2023-02-27T19:43:13+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">假溢出的解决策略</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <div class="kdocs-document"> 
 <p style=""><span class="kdocs-bold" style="font-weight:bold;">假溢出</span>：在顺序队列中，队列出队时并没有像线性表那样使后面的元素往前移。</p> 
 <p style="">为了解决假溢出，常用的方法是把队列想成一个首尾相接的环，这种叫循环队列。在循环队列的入队和出队操作中，用到了求模运算（%），以确保front和rear的值保持在队列的有效范围内。</p> 
 <p style="">对于队列q，初始化为空队列使q-&gt;front==q-&gt;rear==0。</p> 
 <p style="">新元素入队时操作为：</p> 
 <pre class="kdocs-cpp"><code class="language-cpp">q-&gt;data[q-&gt;rear]=x;
q-&gt;rear=(q-&gt;rear+1)%MAXSIZE;</code></pre> 
 <p style="">出队操作为：</p> 
 <pre class="kdocs-cpp"><code class="language-cpp">x=q-&gt;data[q-&gt;front];
q-&gt;front=(q-&gt;front+1)%MAXSIZE;</code></pre> 
 <p style="">此时我们发现从一开始一直入队直到队列满时，此时q-&gt;front==q-&gt;rear==0;和判队列空的条件一摸一样，那怎么办？？我们有以下三种方案</p> 
 <ul><li style="margin-left:1.4em;list-style-type:disc;text-indent:0;"><p>闲置循环队列中一个元素空间。当 rear 的下一个位置是 front 时，则宣告列满。此时，循环队列为空的条件为 rear==front，而循环队列为满的条件为:(q-&gt;rear+1)%MAXSIZE==q-&gt;front。按照这种办法，循环队列出队、入队操作不变，只是入队时循环队列的判断条件修改为(q-&gt;rear+1)%MAXSIZE= q-&gt;front 即可。</p></li></ul> 
 <ul><li style="margin-left:1.4em;list-style-type:disc;text-indent:0;"><p>在循环队列上增加一个标志变量 flag，初始时q-&gt;flag=0。当因为入队操作q-&gt;front==q-&gt;rear时，置q-&gt;flag为1;当因为出队操作使q-&gt;front==q-&gt;rear 时，置 q-&gt;flag为0。因此，循环队列空的条件为q-&gt;flag==0&amp;&amp;q-&gt;front==q-&gt;rear,循环队列满的条件为 q-&gt;flag==1&amp;&amp;q-&gt;front==q-&gt;rear。</p></li></ul> 
 <ul><li style="margin-left:1.4em;list-style-type:disc;text-indent:0;"><p>在循环队列中增加一个计数器 count，初始时 count=0;成功出队时 q-&gt;count减1，成功入队时 count 加1。因此，循环队列空的条件为 q-&gt;count==0。循环队列满的条件为 q-&gt;count==MAXSIZE，或者 q-&gt;count&gt;0&amp;&amp;q-&gt;rear==q-&gt;front。</p></li></ul> 
 <p style=""><span class="kdocs-fontSize" style="font-size:15pt;"><span class="kdocs-bold" style="font-weight:bold;">flag法</span></span></p> 
 <pre class="kdocs-cpp"><code class="language-cpp">#define _CRT_SECURE_NO_WARNINGS
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
typedef int DataType;
#define MAXSIZE 6
typedef struct
{
    DataType data[MAXSIZE];
    int front, rear;
    int flag;
}CSeqQueue;
void Init_Queue(CSeqQueue* q)
{
    q-&gt;front = 0;
    q-&gt;rear = 0;
    q-&gt;flag = 0;
}
int Out_Queue(CSeqQueue* q, DataType* x)
{
    if (q-&gt;flag == 0 &amp;&amp; q-&gt;front == q-&gt;rear)
    {
        printf("队列为空!\n");
        return 0;
    }
    else
    {
        *x = q-&gt;data[q-&gt;front];
        q-&gt;front = (q-&gt;front + 1) % MAXSIZE;
        if (q-&gt;front == q-&gt;rear)
            q-&gt;flag = 0;
        return 1;
    }
}

int In_Queue(CSeqQueue* q, DataType x)
{
    if (q-&gt;flag == 1 &amp;&amp; q-&gt;flag == q-&gt;rear)
    {
        printf("队列已满!");
        return 0;
    }
    else
    {
        q-&gt;data[q-&gt;rear] = x;
        q-&gt;rear = (q-&gt;rear + 1) % MAXSIZE;
        if (q-&gt;front == q-&gt;rear)
            q-&gt;flag = 1;
        return 1;
    }
}

int Length_Queue(CSeqQueue* q)
{
    //    return (q-&gt;rear-q-&gt;front+MAXSIZE)%MAXSIZE;
    return (q-&gt;rear - q-&gt;front + MAXSIZE) % MAXSIZE;
}
int main()
{
    CSeqQueue* q;
    int i;
    DataType x;
    q = (CSeqQueue*)malloc(sizeof(CSeqQueue));
    Init_Queue(q);
    printf("请插入%d个数字：", MAXSIZE);
    for (i = 1; i &lt;= MAXSIZE; i++)
    {
        scanf("%d", &amp;x);
        if (In_Queue(q, x) == 0)break;
    }
    printf("现在出队三个：");
    for (i = 1; i &lt;= 3; i++)
    {
        if (Out_Queue(q, &amp;x) == 0)break;
        printf("%5d", x);
    }
    printf("\n目前队列中有%d个元素：", Length_Queue(q));
    for (i = q-&gt;front; i != q-&gt;rear; i = (i + 1) % MAXSIZE)
    {
        printf("%5d", q-&gt;data[i]);
    }
    system("pause");
    return 0;
}</code></pre> 
 <p style=""><span class="kdocs-fontSize" style="font-size:15pt;"><span class="kdocs-bold" style="font-weight:bold;">count法</span></span></p> 
 <pre class="kdocs-cpp"><code class="language-cpp">#define _CRT_SECURE_NO_WARNINGS
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
typedef int DataType;
#define MAXSIZE 6
typedef struct
{
    DataType data[MAXSIZE];
    int front, rear;
    int count;//队列中元素个数
}CSeqQueue;
void Init_Queue(CSeqQueue* q)
{
    q-&gt;front = 0;
    q-&gt;rear = 0;
    q-&gt;count = 0;
}
int Out_Queue(CSeqQueue* q, DataType* x)
{
    if (q-&gt;count == 0)
    {
        printf(" 队列已为空，无元素可取\n");
        return 0;
    }
    else
    {
        *x = q-&gt;data[q-&gt;front];
        q-&gt;front = (q-&gt;front + 1) % MAXSIZE;
        q-&gt;count--;
        return 1;
    }
}

int In_Queue(CSeqQueue* q, DataType x)
{
    if (q-&gt;count == MAXSIZE)
    {
        printf("队已满，不能插入元素\n");
        return 0;
    }
    else
    {
        q-&gt;data[q-&gt;rear] = x;
        q-&gt;rear = (q-&gt;rear + 1) % MAXSIZE;
        q-&gt;count++;
        return 1;
    }
}

int Length_Queue(CSeqQueue* q)
{
    return q-&gt;count;
}
void main()
{
    CSeqQueue* q;
    int i;
    DataType x;
    q = (CSeqQueue*)malloc(sizeof(CSeqQueue));
    Init_Queue(q);
    printf("请插入6个数字：");
    for (i = 1; i &lt;= 6; i++)
    {
        scanf("%d", &amp;x);
        if (In_Queue(q, x) == 0)break;
    }
    printf("队列现在满了，你试着再插入一个\n");
    scanf("%d", &amp;x);
    In_Queue(q, x);
    printf("将前3个数字出队：");
    for (i = 1; i &lt;= 3; i++)
    {
        if (Out_Queue(q, &amp;x) == 0)break;
        printf("%5d", x);
    }
    printf("\n目前队列中有%d个元素：", Length_Queue(q));
    for (i = q-&gt;front; i != q-&gt;rear; i = (i + 1) % MAXSIZE)
    {
        printf("%5d", q-&gt;data[i]);
    }
    printf("\n");
    system("pause");
}</code></pre> 
 <p style=""><span class="kdocs-fontSize" style="font-size:15pt;"><span class="kdocs-bold" style="font-weight:bold;">少用一个空间</span></span></p> 
 <pre class="kdocs-cpp"><code class="language-cpp">#define _CRT_SECURE_NO_WARNINGS
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
typedef int DataType;
#define MAXSIZE 6
typedef struct
{
    DataType data[MAXSIZE];
    int front, rear;
}CSeqQueue;
void Init_Queue(CSeqQueue* q)
{
    q-&gt;front = 0;
    q-&gt;rear = 0;
}
int Out_Queue(CSeqQueue* q, DataType* x)
{
    if (q-&gt;front == q-&gt;rear)
    {
        printf("队列为空!\n");
        return 0;
    }
    else
    {
        *x = q-&gt;data[q-&gt;front];
        q-&gt;front = (q-&gt;front + 1) % MAXSIZE;
        return 1;
    }
}

int In_Queue(CSeqQueue* q, DataType x)
{
    if ((q-&gt;rear + 1) % MAXSIZE == q-&gt;front)
    {
        printf("队列已满!");
        return 0;
    }
    else
    {
        q-&gt;data[q-&gt;rear] = x;
        q-&gt;rear = (q-&gt;rear + 1) % MAXSIZE;
        return 1;
    }
}

int Length_Queue(CSeqQueue* q)
{
    //    return (q-&gt;rear-q-&gt;front+MAXSIZE)%MAXSIZE;
    return (q-&gt;rear - q-&gt;front + MAXSIZE) % MAXSIZE;
}
int main()
{
    CSeqQueue* q;
    int i;
    DataType x;
    q = (CSeqQueue*)malloc(sizeof(CSeqQueue));
    Init_Queue(q);
    printf("请插入%d个数字：", MAXSIZE-1);
    for (i = 1; i &lt; MAXSIZE; i++)
    {
        scanf("%d", &amp;x);
        if (In_Queue(q, x) == 0)break;
    }
    printf("现在出队三个：");
    for (i = 1; i &lt;= 3; i++)
    {
        if (Out_Queue(q, &amp;x) == 0)break;
        printf("%5d", x);
    }
    printf("\n目前队列中有%d个元素：", Length_Queue(q));
    for (i = q-&gt;front; i != q-&gt;rear; i = (i + 1) % MAXSIZE)
    {
        printf("%5d", q-&gt;data[i]);
    }
    system("pause");
    return 0;
}</code></pre> 
 <p style=""></p> 
</div>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/334f3f034ee3531734811856ada4fc7c/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">VS 设置管理员权限</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/7c2af469044482176e2d529c2915b2f7/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">一分钟教你配置DHCP服务，超级简单一看就会！！！！！</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>