<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>【数据结构】链表(单链表与双链表实现&#43;原理&#43;源码) - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="【数据结构】链表(单链表与双链表实现&#43;原理&#43;源码)" />
<meta property="og:description" content="博主介绍：✌全网粉丝喜爱&#43;、前后端领域优质创作者、本质互联网精神、坚持优质作品共享、掘金/腾讯云/阿里云等平台优质作者、擅长前后端项目开发和毕业项目实战✌有需要可以联系作者我哦！
🍅附上相关C语言版源码讲解🍅
👇🏻 精彩专栏推荐订阅👇🏻 不然下次找不到哟
文章目录 一、链表定义
二、链表实战
1、单链表（C语言实现版本）
2、双链表（C&#43;&#43;）
三、分析总结
优点：
应用：
小结
大家点赞、收藏、关注、评论啦 ！
谢谢哦！如果不懂，欢迎大家下方讨论学习哦。
一、链表定义 链表是一种数据结构，它由一系列节点组成，这些节点按顺序连接在一起形成链式结构。每个节点包含数据和指向下一个节点的引用（指针）。链表的最后一个节点通常指向一个特定的值（如空值或null），表示链表的结束。
链表是一种数据结构，它由一系列节点组成，这些节点按顺序连接在一起形成链式结构。每个节点包含数据和指向下一个节点的引用（指针）。链表的最后一个节点通常指向一个特定的值（如空值或null），表示链表的结束。
链表可以分为单链表和双链表两种主要类型：
1. 单链表（Singly Linked List）：每个节点包含数据和指向下一个节点的指针。链表的最后一个节点指向null。
节点1 节点2 节点3 | 数据1 | -&gt; | 数据2 | -&gt; | 数据3 | -&gt; null 2. 双链表（Doubly Linked List）：每个节点包含数据、指向下一个节点的指针，以及指向前一个节点的指针。这使得在双链表中可以更方便地进行前向和后向遍历。
null &lt;- | 数据1 | &lt;-&gt; | 数据2 | &lt;-&gt; | 数据3 | -&gt; null 链表优点： 链表相对于数组的优势在于插入和删除操作的效率较高，因为不需要移动大量元素，只需调整节点的指针。然而，链表的缺点是访问元素时需要按顺序遍历，而数组可以通过索引直接访问元素。链表在内存中不需要连续的存储空间，因此可以更灵活地分配内存。
二、链表实战 1、单链表（C语言实现版本） #include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; // 定义节点结构 struct Node { int data; // 节点数据 struct Node* next; // 指向下一个节点的指针 }; // 定义链表结构 struct LinkedList { struct Node* head; // 链表头指针 }; // 初始化链表 void initLinkedList(struct LinkedList* list) { list-&gt;head = NULL; // 将头指针初始化为NULL，表示链表为空 } // 在链表末尾添加节点 void append(struct LinkedList* list, int data) { // 创建新节点 struct Node* new_node = (struct Node*)malloc(sizeof(struct Node)); new_node-&gt;data = data; new_node-&gt;next = NULL; // 判断链表是否为空 if (list-&gt;head == NULL) { // 如果为空，将新节点设为头节点 list-&gt;head = new_node; } else { // 如果不为空，找到链表末尾，将新节点链接到末尾 struct Node* current = list-&gt;head; while (current-&gt;next !" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/b71173b7a97572e8617b137b63443393/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2024-01-21T23:29:23+08:00" />
<meta property="article:modified_time" content="2024-01-21T23:29:23+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">【数据结构】链表(单链表与双链表实现&#43;原理&#43;源码)</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <blockquote> 
 <p>博主介绍：✌全网粉丝喜爱+、前后端领域优质创作者、本质互联网精神、坚持优质作品共享、掘金/腾讯云/阿里云等平台优质作者、擅长前后端项目开发和毕业项目实战✌有需要可以联系作者我哦！</p> 
 <p>🍅附上相关C语言版源码讲解🍅</p> 
 <p>👇🏻 精彩专栏推荐订阅👇🏻 不然下次找不到哟</p> 
</blockquote> 
<div> 
 <h4 id="%E6%96%87%E7%AB%A0%E7%9B%AE%E5%BD%95"><a href="#%E6%96%87%E7%AB%A0%E7%9B%AE%E5%BD%95" rel="nofollow" style="font-size:16px;font-weight:normal;">文章目录</a></h4> 
 <ul><li> 
   <ul><li> <p id="%E4%B8%80%E3%80%81%E9%93%BE%E8%A1%A8%E5%AE%9A%E4%B9%89-toc" style="margin-left:0px;"><a href="#%E4%B8%80%E3%80%81%E9%93%BE%E8%A1%A8%E5%AE%9A%E4%B9%89" rel="nofollow">一、链表定义</a></p> <p id="%E4%BA%8C%E3%80%81%E9%93%BE%E8%A1%A8%E5%AE%9E%E6%88%98-toc" style="margin-left:0px;"><a href="#%E4%BA%8C%E3%80%81%E9%93%BE%E8%A1%A8%E5%AE%9E%E6%88%98" rel="nofollow">二、链表实战</a></p> <p id="1%E3%80%81%E5%8D%95%E9%93%BE%E8%A1%A8%EF%BC%88C%E8%AF%AD%E8%A8%80%E5%AE%9E%E7%8E%B0%E7%89%88%E6%9C%AC%EF%BC%89-toc" style="margin-left:40px;"><a href="#1%E3%80%81%E5%8D%95%E9%93%BE%E8%A1%A8%EF%BC%88C%E8%AF%AD%E8%A8%80%E5%AE%9E%E7%8E%B0%E7%89%88%E6%9C%AC%EF%BC%89" rel="nofollow">1、单链表（C语言实现版本）</a></p> <p id="2%E3%80%81%E5%8F%8C%E9%93%BE%E8%A1%A8%EF%BC%88C%2B%2B%EF%BC%89-toc" style="margin-left:40px;"><a href="#2%E3%80%81%E5%8F%8C%E9%93%BE%E8%A1%A8%EF%BC%88C%2B%2B%EF%BC%89" rel="nofollow">2、双链表（C++）</a></p> <p id="%E4%B8%89%E3%80%81%E5%88%86%E6%9E%90%E6%80%BB%E7%BB%93-toc" style="margin-left:0px;"><a href="#%E4%B8%89%E3%80%81%E5%88%86%E6%9E%90%E6%80%BB%E7%BB%93" rel="nofollow">三、分析总结</a></p> <p id="%E4%BC%98%E7%82%B9%EF%BC%9A-toc" style="margin-left:80px;"><a href="#%E4%BC%98%E7%82%B9%EF%BC%9A" rel="nofollow">优点：</a></p> <p id="%E5%BA%94%E7%94%A8%EF%BC%9A-toc" style="margin-left:80px;"><a href="#%E5%BA%94%E7%94%A8%EF%BC%9A" rel="nofollow">应用：</a></p> <p id="%E5%B0%8F%E7%BB%93-toc" style="margin-left:40px;"><a href="#%E5%B0%8F%E7%BB%93" rel="nofollow">小结</a></p> <p id="%E5%A4%A7%E5%AE%B6%E7%82%B9%E8%B5%9E%E3%80%81%E6%94%B6%E8%97%8F%E3%80%81%E5%85%B3%E6%B3%A8%E3%80%81%E8%AF%84%E8%AE%BA%E5%95%A6%20%EF%BC%81-toc" style="margin-left:0px;"><a href="#%E5%A4%A7%E5%AE%B6%E7%82%B9%E8%B5%9E%E3%80%81%E6%94%B6%E8%97%8F%E3%80%81%E5%85%B3%E6%B3%A8%E3%80%81%E8%AF%84%E8%AE%BA%E5%95%A6%20%EF%BC%81" rel="nofollow">大家点赞、收藏、关注、评论啦 ！</a></p> <p id="%E8%B0%A2%E8%B0%A2%E5%93%A6%EF%BC%81%E5%A6%82%E6%9E%9C%E4%B8%8D%E6%87%82%EF%BC%8C%E6%AC%A2%E8%BF%8E%E5%A4%A7%E5%AE%B6%E4%B8%8B%E6%96%B9%E8%AE%A8%E8%AE%BA%E5%AD%A6%E4%B9%A0%E5%93%A6%E3%80%82-toc" style="margin-left:40px;"><a href="#%E8%B0%A2%E8%B0%A2%E5%93%A6%EF%BC%81%E5%A6%82%E6%9E%9C%E4%B8%8D%E6%87%82%EF%BC%8C%E6%AC%A2%E8%BF%8E%E5%A4%A7%E5%AE%B6%E4%B8%8B%E6%96%B9%E8%AE%A8%E8%AE%BA%E5%AD%A6%E4%B9%A0%E5%93%A6%E3%80%82" rel="nofollow">谢谢哦！如果不懂，欢迎大家下方讨论学习哦。</a></p> </li></ul></li></ul> 
</div> 
<h2 id="%E4%B8%80%E3%80%81%E9%93%BE%E8%A1%A8%E5%AE%9A%E4%B9%89"><a id="_1"></a>一、链表定义</h2> 
<p>链表是一种数据结构，它由一系列节点组成，这些节点按顺序连接在一起形成链式结构。每个节点包含数据和指向下一个节点的引用（指针）。链表的最后一个节点通常指向一个特定的值（如空值或null），表示链表的结束。</p> 
<p>链表是一种数据结构，它由一系列节点组成，这些节点按顺序连接在一起形成链式结构。每个节点包含数据和指向下一个节点的引用（指针）。链表的最后一个节点通常指向一个特定的值（如空值或null），表示链表的结束。</p> 
<p>链表可以分为单链表和双链表两种主要类型：<br> 1. 单链表（Singly Linked List）：每个节点包含数据和指向下一个节点的指针。链表的最后一个节点指向null。</p> 
<pre><code class="language-rust">节点1      节点2      节点3
| 数据1 | -&gt; | 数据2 | -&gt; | 数据3 | -&gt; null
</code></pre> 
<p>2. 双链表（Doubly Linked List）：每个节点包含数据、指向下一个节点的指针，以及指向前一个节点的指针。这使得在双链表中可以更方便地进行前向和后向遍历。</p> 
<pre><code class="language-rust">null &lt;- | 数据1 | &lt;-&gt; | 数据2 | &lt;-&gt; | 数据3 | -&gt; null
</code></pre> 
<p>链表优点：  链表相对于数组的优势在于插入和删除操作的效率较高，因为不需要移动大量元素，只需调整节点的指针。然而，链表的缺点是访问元素时需要按顺序遍历，而数组可以通过索引直接访问元素。链表在内存中不需要连续的存储空间，因此可以更灵活地分配内存。</p> 
<h2 id="%E4%BA%8C%E3%80%81%E9%93%BE%E8%A1%A8%E5%AE%9E%E6%88%98">二、链表实战</h2> 
<h3 id="1%E3%80%81%E5%8D%95%E9%93%BE%E8%A1%A8%EF%BC%88C%E8%AF%AD%E8%A8%80%E5%AE%9E%E7%8E%B0%E7%89%88%E6%9C%AC%EF%BC%89">1、单链表（C语言实现版本）</h3> 
<pre><code class="language-cpp">#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

// 定义节点结构
struct Node {
    int data;           // 节点数据
    struct Node* next;  // 指向下一个节点的指针
};

// 定义链表结构
struct LinkedList {
    struct Node* head;   // 链表头指针
};

// 初始化链表
void initLinkedList(struct LinkedList* list) {
    list-&gt;head = NULL;  // 将头指针初始化为NULL，表示链表为空
}

// 在链表末尾添加节点
void append(struct LinkedList* list, int data) {
    // 创建新节点
    struct Node* new_node = (struct Node*)malloc(sizeof(struct Node));
    new_node-&gt;data = data;
    new_node-&gt;next = NULL;

    // 判断链表是否为空
    if (list-&gt;head == NULL) {
        // 如果为空，将新节点设为头节点
        list-&gt;head = new_node;
    } else {
        // 如果不为空，找到链表末尾，将新节点链接到末尾
        struct Node* current = list-&gt;head;
        while (current-&gt;next != NULL) {
            current = current-&gt;next;
        }
        current-&gt;next = new_node;
    }
}

// 在链表开头添加节点
void prepend(struct LinkedList* list, int data) {
    // 创建新节点
    struct Node* new_node = (struct Node*)malloc(sizeof(struct Node));
    new_node-&gt;data = data;
    new_node-&gt;next = list-&gt;head;

    // 将新节点设为头节点
    list-&gt;head = new_node;
}

// 删除节点
void deleteNode(struct LinkedList* list, int data) {
    struct Node* current = list-&gt;head;
    struct Node* prev = NULL;

    // 遍历链表，找到待删除节点及其前一个节点
    while (current != NULL &amp;&amp; current-&gt;data != data) {
        prev = current;
        current = current-&gt;next;
    }

    // 如果找到待删除节点
    if (current != NULL) {
        // 如果待删除节点不是头节点
        if (prev != NULL) {
            prev-&gt;next = current-&gt;next;
        } else {
            // 如果待删除节点是头节点
            list-&gt;head = current-&gt;next;
        }
        free(current);  // 释放内存
    }
}

// 更新节点
void updateNode(struct LinkedList* list, int oldData, int newData) {
    struct Node* current = list-&gt;head;

    // 遍历链表，找到待更新节点
    while (current != NULL &amp;&amp; current-&gt;data != oldData) {
        current = current-&gt;next;
    }

    // 如果找到待更新节点
    if (current != NULL) {
        current-&gt;data = newData;  // 更新节点数据
    }
}

// 搜索节点
struct Node* searchNode(struct LinkedList* list, int data) {
    struct Node* current = list-&gt;head;

    // 遍历链表，找到包含指定数据的节点
    while (current != NULL &amp;&amp; current-&gt;data != data) {
        current = current-&gt;next;
    }

    return current;  // 返回节点指针
}

// 显示链表内容
void display(struct LinkedList* list) {
    struct Node* current = list-&gt;head;
    while (current != NULL) {
        printf("%d -&gt; ", current-&gt;data);
        current = current-&gt;next;
    }
    printf("NULL\n");
}

// 释放链表内存
void freeLinkedList(struct LinkedList* list) {
    struct Node* current = list-&gt;head;
    struct Node* next = NULL;
    while (current != NULL) {
        next = current-&gt;next;
        free(current);
        current = next;
    }
    list-&gt;head = NULL;
}

int main() {
    struct LinkedList myLinkedList;
    initLinkedList(&amp;myLinkedList);

    // 添加节点
    append(&amp;myLinkedList, 1);
    append(&amp;myLinkedList, 2);
    append(&amp;myLinkedList, 3);

    // 显示链表内容
    printf("链表内容：");
    display(&amp;myLinkedList);

    // 在开头添加节点
    prepend(&amp;myLinkedList, 0);

    // 显示链表内容
    printf("在开头添加节点后的链表：");
    display(&amp;myLinkedList);

    // 删除节点
    deleteNode(&amp;myLinkedList, 2);

    // 显示链表内容
    printf("删除节点后的链表：");
    display(&amp;myLinkedList);

    // 更新节点
    updateNode(&amp;myLinkedList, 1, 10);

    // 显示链表内容
    printf("更新节点后的链表：");
    display(&amp;myLinkedList);

    // 搜索节点
    int searchData = 10;
    struct Node* searchResult = searchNode(&amp;myLinkedList, searchData);
    if (searchResult != NULL) {
        printf("找到数据为 %d 的节点。\n", searchData);
    } else {
        printf("未找到数据为 %d 的节点。\n", searchData);
    }

    // 释放链表内存
    freeLinkedList(&amp;myLinkedList);

    return 0;
}
</code></pre> 
<p>执行结果详细：</p> 
<p><img alt="" height="267" src="https://images2.imgbox.com/bb/97/1WJmf8G0_o.png" width="736"></p> 
<h3 id="2%E3%80%81%E5%8F%8C%E9%93%BE%E8%A1%A8%EF%BC%88C%2B%2B%EF%BC%89">2、双链表（C++）</h3> 
<pre><code class="language-cpp">#include &lt;iostream&gt;  
#include &lt;cstdlib&gt;  
#include &lt;cstdio&gt;  
  
using namespace std;  
typedef struct Node  
{  
    int data;  
    struct Node *prior;  
    struct Node *next;  
} LinkList;  
  
LinkList *Create()  
{  
    LinkList *head;  
    head=(LinkList*)malloc(sizeof(LinkList));  
    if(head!=NULL)  
    {  
        head-&gt;prior=NULL;  
        head-&gt;next=NULL;  
        return head;  
    }  
    else return NULL;  
}  
  
int Insert(LinkList *head,int e)  //尾插法
{  
    LinkList *p;  
    LinkList *q=head;  
    p=(LinkList*)malloc(sizeof(LinkList));  
    if(p!=NULL)  
    {  
        p-&gt;data=e;  
        p-&gt;prior=NULL;  
        p-&gt;next=NULL;  
        while(q-&gt;next!=NULL)  
        {  
            q=q-&gt;next;  
        }  
        q-&gt;next=p;  
        return 1;  
    }  
    return 0;  
}  
  
LinkList* Change(LinkList *head) //变成双向链表后返回一个尾指针  
{  
    LinkList *p,*q;  
    p=head;  
    q=p-&gt;next;  
    while(q!=NULL)  
    {  
        q-&gt;prior=p;  
        p=p-&gt;next;  
        q=q-&gt;next;  
    }  
    return p;  
}  
  
void Output1(LinkList *head) //从头到尾遍历输出  
{  
    LinkList *p;  
    p=head-&gt;next;  
    while(p!=NULL)  
    {  
        printf("%d ",p-&gt;data);  
        p=p-&gt;next;  
    }  
    printf("\n");  
}  
  
void Output2(LinkList *tail) //从尾到头遍历输出  
{  
    LinkList *p;  
    p=tail;  
    while(p-&gt;prior!=NULL)  
    {  
        printf("%d ",p-&gt;data);  
        p=p-&gt;prior;  
    }  
    printf("\n");  
}  
  
void FreeLink(LinkList *head)  //释放
{  
    LinkList *p,*q;  
    p=head;  
    q=NULL;  
    while(p!=NULL)  
    {  
        q=p;  
        p=p-&gt;next;  
        free(q);  
    }  
}  
  
int main()  
{  
    LinkList *phead,*tail;  
    int n,e,flag;  
    phead=Create();  
    if(phead!=NULL)  
    {  
        cout&lt;&lt;"请输入长度:";
 scanf("%d",&amp;n);  
        for(int i=0;i&lt;n;i++)  
        {  
            scanf("%d",&amp;e);  
            flag=Insert(phead,e);  
        }
 cout&lt;&lt;"从头到尾输出为: ";
        Output1(phead);  
        tail=Change(phead); 
 cout&lt;&lt;"从尾到头输出为: ";
        Output2(tail);  
        FreeLink(phead);  
    }  
    return 0;  
}
</code></pre> 
<p>代码执行结果：</p> 
<p><img alt="" height="316" src="https://images2.imgbox.com/12/7d/uEnmo8pX_o.png" width="766"></p> 
<h2 id="%E4%B8%89%E3%80%81%E5%88%86%E6%9E%90%E6%80%BB%E7%BB%93">三、分析总结</h2> 
<p>链表是一种常见的数据结构，具有一些优点和应用：</p> 
<h4 id="%E4%BC%98%E7%82%B9%EF%BC%9A">优点：</h4> 
<p>1. 动态内存分配：链表允许在运行时动态分配内存，这使得它更加灵活，不需要预先指定存储空间大小，通过动态分配内存可以实现降低时间运行成本。</p> 
<p>2. 插入和删除效率高：在链表中插入和删除节点相对容易且效率较高。相比之下，数组在中间或开头插入/删除元素可能需要移动大量元素。</p> 
<p>3. 大小可变：*链表可以根据需要动态增长或缩小，而不浪费内存。</p> 
<h4 id="%E5%BA%94%E7%94%A8%EF%BC%9A">应用：</h4> 
<p>1. 实现动态数据结构：链表常用于实现其他动态数据结构，如栈、队列、图等。</p> 
<p>2. 内存分配：动态链表的能力使其在动态内存分配的场景中非常有用，例如，动态分配内存的链表可用于管理操作系统的进程列表。</p> 
<p>3. 实现算法：链表常用于算法实现，例如，链表在排序算法、图算法等方面有广泛的应用。</p> 
<p>4. 嵌入式系统： 在资源受限的嵌入式系统中，链表可以更好地处理动态数据。</p> 
<p>5. LRU缓存淘汰算法：链表可以用于实现LRU（Least Recently Used）缓存淘汰算法，用于管理缓存中的数据。</p> 
<p>6. 数据库：数据库中的索引通常使用链表实现，以支持高效的插入和删除操作。</p> 
<p>总的来说，链表在许多场景中都是一种强大且灵活的数据结构，特别适合那些需要频繁插入和删除操作的应用。</p> 
<h3><a id="_16"></a></h3> 
<h3 id="%E5%B0%8F%E7%BB%93"><a id="_34"></a>小结</h3> 
<blockquote> 
 <h2 id="%E5%A4%A7%E5%AE%B6%E7%82%B9%E8%B5%9E%E3%80%81%E6%94%B6%E8%97%8F%E3%80%81%E5%85%B3%E6%B3%A8%E3%80%81%E8%AF%84%E8%AE%BA%E5%95%A6%20%EF%BC%81">大家点赞、收藏、关注、评论啦 ！</h2> 
 <h3 id="%E8%B0%A2%E8%B0%A2%E5%93%A6%EF%BC%81%E5%A6%82%E6%9E%9C%E4%B8%8D%E6%87%82%EF%BC%8C%E6%AC%A2%E8%BF%8E%E5%A4%A7%E5%AE%B6%E4%B8%8B%E6%96%B9%E8%AE%A8%E8%AE%BA%E5%AD%A6%E4%B9%A0%E5%93%A6%E3%80%82" style="background-color:transparent;">谢谢哦！如果不懂，欢迎大家下方讨论学习哦。</h3> 
</blockquote>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/152a231513a6ece26dead1629168d688/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">install cmake</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/09b061b8dc3f4fb0bb77de2afbddf1d5/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">IDEA（十）2022版本 Services中服务窗口不显示端口号解决</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>