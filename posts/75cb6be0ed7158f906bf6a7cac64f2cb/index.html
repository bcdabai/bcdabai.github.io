<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>sql server 学习教程 - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="sql server 学习教程" />
<meta property="og:description" content="sql server 学习教程 SQL Server 系统数据库mastermodelmsdbtempdb 索引定义分类唯一索引主键索引聚集索引(Clustered)非聚集索引(Non-clustered) 作用优点缺点创建索引的原则创建索引修改索引删除索引查看索引 视图创建视图查询视图修改视图删除视图 存储过程定义优点创建存储过程执行存储过程修改存储过程删除存储过程 触发器定义优点作用分类DML(数据操作语言,Data Manipulation Language)触发器DDL(数据定义语言,Data Definition Language)触发器登录触发器注意 工作原理创建触发器修改触发器禁用触发器启用触发器查询已存在的触发器查看触发器触发事件查看创建触发器语句删除触发器 作业同步（一主多从）链接服务器连接远程/局域网数据openrowsetopenqueryopendatasource/openrowset SQL 语句变量局部变量全局变量 判断语句IF ELSECASE 循环 while复制表(只复制结构,源表名：a 新表名：b) (Access可用)拷贝表(拷贝数据,源表名：a 目标表名：b) (Access可用)跨数据库之间表的拷贝(具体数据使用绝对路径)(Access可用)初始化表table1删除数据库表分页并集 UNION 运算符交集 INTERSECT去重 EXCEPTROW_NUMBER() SQL Server 系统数据库 在我们安装 SQL Server 的时候，会自动创建下面的四个数据库。
master master 数据库记录了所有的 SQL Server 数据库系统的系统级信息，如用户帐户，配置设置，并在所有其他数据库信息。
model model 数据库是一个模板数据库。每当创建一个新的数据库（包括系统数据库的TempDB），会创建一个以 Model 数据库为副本数据库，并更改成你创建数据库时所用的名称。
msdb msdb 数据库是 SQL Server 代理的数据库，用于配置警报使用 SQL Server 代理和预定作业等。
tempdb tempddb 数据库是由 SQL Server 用于暂时存储数据的，这其中包含所有临时表，临时存储过程，并通过 SQL Server 生成任何其他临时存储需求。
这些系统数据库有它们特有的用处，系统数据库是我们新建数据库的模板。
SQL Server 是不区分大小写的" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/75cb6be0ed7158f906bf6a7cac64f2cb/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2020-05-19T17:23:32+08:00" />
<meta property="article:modified_time" content="2020-05-19T17:23:32+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">sql server 学习教程</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p></p> 
<div class="toc"> 
 <h4>sql server 学习教程</h4> 
 <ul><li><a href="#SQL_Server__1" rel="nofollow">SQL Server 系统数据库</a></li><li><ul><li><a href="#master_3" rel="nofollow">master</a></li><li><a href="#model_5" rel="nofollow">model</a></li><li><a href="#msdb_7" rel="nofollow">msdb</a></li><li><a href="#tempdb_9" rel="nofollow">tempdb</a></li></ul> 
  </li><li><a href="#_13" rel="nofollow">索引</a></li><li><ul><li><a href="#_17" rel="nofollow">定义</a></li><li><a href="#_24" rel="nofollow">分类</a></li><li><ul><li><a href="#_25" rel="nofollow">唯一索引</a></li><li><a href="#_28" rel="nofollow">主键索引</a></li><li><a href="#Clustered_32" rel="nofollow">聚集索引(Clustered)</a></li><li><a href="#Nonclustered_34" rel="nofollow">非聚集索引(Non-clustered)</a></li></ul> 
   </li><li><a href="#_40" rel="nofollow">作用</a></li><li><a href="#_42" rel="nofollow">优点</a></li><li><a href="#_47" rel="nofollow">缺点</a></li><li><a href="#_51" rel="nofollow">创建索引的原则</a></li><li><a href="#_57" rel="nofollow">创建索引</a></li><li><a href="#_123" rel="nofollow">修改索引</a></li><li><a href="#_154" rel="nofollow">删除索引</a></li><li><a href="#_177" rel="nofollow">查看索引</a></li></ul> 
  </li><li><a href="#_192" rel="nofollow">视图</a></li><li><ul><li><a href="#_201" rel="nofollow">创建视图</a></li><li><a href="#_209" rel="nofollow">查询视图</a></li><li><a href="#_216" rel="nofollow">修改视图</a></li><li><a href="#_229" rel="nofollow">删除视图</a></li></ul> 
  </li><li><a href="#_239" rel="nofollow">存储过程</a></li><li><ul><li><a href="#_243" rel="nofollow">定义</a></li><li><a href="#_249" rel="nofollow">优点</a></li><li><a href="#_256" rel="nofollow">创建存储过程</a></li><li><a href="#_265" rel="nofollow">执行存储过程</a></li><li><a href="#_274" rel="nofollow">修改存储过程</a></li><li><a href="#_287" rel="nofollow">删除存储过程</a></li></ul> 
  </li><li><a href="#_293" rel="nofollow">触发器</a></li><li><ul><li><a href="#_294" rel="nofollow">定义</a></li><li><a href="#_296" rel="nofollow">优点</a></li><li><a href="#_300" rel="nofollow">作用</a></li><li><a href="#_307" rel="nofollow">分类</a></li><li><ul><li><a href="#DMLData__Manipulation__Language_308" rel="nofollow">DML(数据操作语言,Data Manipulation Language)触发器</a></li><li><a href="#DDLData__Definition__Language_314" rel="nofollow">DDL(数据定义语言,Data Definition Language)触发器</a></li><li><a href="#_316" rel="nofollow">登录触发器</a></li><li><a href="#_319" rel="nofollow">注意</a></li></ul> 
   </li><li><a href="#_324" rel="nofollow">工作原理</a></li><li><a href="#_327" rel="nofollow">创建触发器</a></li><li><a href="#_340" rel="nofollow">修改触发器</a></li><li><a href="#_353" rel="nofollow">禁用触发器</a></li><li><a href="#_360" rel="nofollow">启用触发器</a></li><li><a href="#_367" rel="nofollow">查询已存在的触发器</a></li><li><a href="#_374" rel="nofollow">查看触发器触发事件</a></li><li><a href="#_381" rel="nofollow">查看创建触发器语句</a></li><li><a href="#_387" rel="nofollow">删除触发器</a></li></ul> 
  </li><li><a href="#_393" rel="nofollow">作业</a></li><li><a href="#_401" rel="nofollow">同步（一主多从）</a></li><li><a href="#_409" rel="nofollow">链接服务器</a></li><li><ul><li><a href="#_439" rel="nofollow">连接远程/局域网数据</a></li><li><ul><li><a href="#openrowset_440" rel="nofollow">openrowset</a></li><li><a href="#openquery_465" rel="nofollow">openquery</a></li><li><a href="#opendatasourceopenrowset_491" rel="nofollow">opendatasource/openrowset</a></li></ul> 
  </li></ul> 
  </li><li><a href="#SQL__503" rel="nofollow">SQL 语句</a></li><li><ul><li><a href="#_505" rel="nofollow">变量</a></li><li><ul><li><a href="#_506" rel="nofollow">局部变量</a></li><li><a href="#_514" rel="nofollow">全局变量</a></li></ul> 
   </li><li><a href="#_517" rel="nofollow">判断语句</a></li><li><ul><li><a href="#IF_ELSE_518" rel="nofollow">IF ELSE</a></li><li><a href="#CASE_528" rel="nofollow">CASE</a></li></ul> 
   </li><li><a href="#_while_538" rel="nofollow">循环 while</a></li><li><a href="#a_b_Access_547" rel="nofollow">复制表(只复制结构,源表名：a 新表名：b) (Access可用)</a></li><li><a href="#a_b_Access_554" rel="nofollow">拷贝表(拷贝数据,源表名：a 目标表名：b) (Access可用)</a></li><li><a href="#Access_560" rel="nofollow">跨数据库之间表的拷贝(具体数据使用绝对路径)(Access可用)</a></li><li><a href="#table1_567" rel="nofollow">初始化表table1</a></li><li><a href="#_574" rel="nofollow">删除数据库表</a></li><li><a href="#_579" rel="nofollow">分页</a></li><li><a href="#__UNION__606" rel="nofollow">并集 UNION 运算符</a></li><li><a href="#_INTERSECT_608" rel="nofollow">交集 INTERSECT</a></li><li><a href="#__EXCEPT_610" rel="nofollow">去重 EXCEPT</a></li><li><a href="#ROW_NUMBER_618" rel="nofollow">ROW_NUMBER()</a></li></ul> 
 </li></ul> 
</div> 
<p></p> 
<h2><a id="SQL_Server__1"></a>SQL Server 系统数据库</h2> 
<p>在我们安装 SQL Server 的时候，会自动创建下面的四个数据库。</p> 
<h3><a id="master_3"></a>master</h3> 
<p>master 数据库记录了所有的 SQL Server 数据库系统的系统级信息，如用户帐户，配置设置，并在所有其他数据库信息。</p> 
<h3><a id="model_5"></a>model</h3> 
<p>model 数据库是一个模板数据库。每当创建一个新的数据库（包括系统数据库的TempDB），会创建一个以 Model 数据库为副本数据库，并更改成你创建数据库时所用的名称。</p> 
<h3><a id="msdb_7"></a>msdb</h3> 
<p>msdb 数据库是 SQL Server 代理的数据库，用于配置警报使用 SQL Server 代理和预定作业等。</p> 
<h3><a id="tempdb_9"></a>tempdb</h3> 
<p>tempddb 数据库是由 SQL Server 用于暂时存储数据的，这其中包含所有临时表，临时存储过程，并通过 SQL Server 生成任何其他临时存储需求。<br> 这些系统数据库有它们特有的用处，系统数据库是我们新建数据库的模板。<br> SQL Server 是不区分大小写的</p> 
<h2><a id="_13"></a>索引</h2> 
<p>参考文献：<a href="https://www.cnblogs.com/kissdodog/archive/2013/06/12/3133345.html" rel="nofollow">https://www.cnblogs.com/kissdodog/archive/2013/06/12/3133345.html</a><br> <a href="https://segmentfault.com/a/1190000016560785" rel="nofollow">https://segmentfault.com/a/1190000016560785</a></p> 
<h3><a id="_17"></a>定义</h3> 
<p>拿汉语字典的目录页（索引）打比方：正如汉语字典中的汉字按页存放一样，SQL Server中的数据记录也是按页存放的，每页容量一般为4K 。为了加快查找的速度，汉语字（词）典一般都有按拼音、笔画、偏旁部首等排序的目录（索引），我们可以选择按拼音或笔画查找方式，快速查找到需要的字（词）。</p> 
<p>同理，SQL Server允许用户在表中创建索引，指定按某列预先排序，从而大大提高查询速度。</p> 
<p>索引：是SQL Server编排数据的内部方法。它为SQL Server提供一种方法来编排查询数据 。<br> 索引页：数据库中存储索引的数据页；索引页类似于汉语字（词）典中按拼音或笔画排序的目录页。</p> 
<h3><a id="_24"></a>分类</h3> 
<h4><a id="_25"></a>唯一索引</h4> 
<p>唯一索引不允许两行具有相同的索引值。<br> 提示：创建了唯一约束，将自动创建唯一索引。尽管唯一索引有助于找到信息，但为了获得最佳性能，建议使用主键约束或唯一约束。</p> 
<h4><a id="_28"></a>主键索引</h4> 
<p>为表定义一个主键将自动创建主键索引，主键索引是唯一索引的特殊类型。主键索引要求主键中的每个值是唯一的，并且不能为空。</p> 
<p>在数据库关系图中为表定义一个主键将自动创建主键索引，主键索引是唯一索引的特殊类型。主键索引要求主键中的每个值是唯一的。当在查询中使用主键索引时，它还允许快速访问数据。</p> 
<h4><a id="Clustered_32"></a>聚集索引(Clustered)</h4> 
<p>表中各行的物理顺序与键值的逻辑（索引）顺序相同，每个表只能有一个。例如：汉语字（词）典默认按拼音排序编排字典中的每页页码。拼音字母a，b，c，d……x，y，z就是索引的逻辑顺序，而页码1，2，3……就是物理顺序。默认按拼音排序的字典，其索引顺序和逻辑顺序是一致的。即拼音顺序较后的字（词）对应的页码也较大。如拼音“ha”对应的字(词)页码就比拼音“ba” 对应的字(词)页码靠后。</p> 
<h4><a id="Nonclustered_34"></a>非聚集索引(Non-clustered)</h4> 
<p>非聚集索引指定表的逻辑顺序。数据存储在一个位置，索引存储在另一个位置，索引中包含指向数据存储位置的指针。可以有多个，小于249个。</p> 
<p>如果不是聚集索引，表中各行的物理顺序与键值的逻辑顺序不匹配。聚集索引比非聚集索引（nonclustered index）有更快的数据访问速度。例如，按笔画排序的索引就是非聚集索引，“1”画的字（词）对应的页码可能比“3”画的字（词）对应的页码大（靠后）。</p> 
<p>提示：SQL Server中，一个表只能创建1个聚集索引，多个非聚集索引。设置某列为主键，该列就默认为聚集索引</p> 
<h3><a id="_40"></a>作用</h3> 
<p>通过使用索引，可以大大提高数据库的检索速度，改善数据库性能。</p> 
<h3><a id="_42"></a>优点</h3> 
<p>1、 通过创建唯一索引，可以保证数据库表的每一行数据的唯一性。<br> 2、 可以大大加快数据的查询速度，这也是创建索引的最主要的原因。<br> 3、 实现数据的参照完整性，可以速表和表之间的连接。<br> 4、 在使用分组和排序子句进行查询时，也可以显著减少查询中分组和排序的时间。</p> 
<h3><a id="_47"></a>缺点</h3> 
<p>1、 创建索引和维护索引要耗费时间，并且随着数据量的增加所耗费的时间也会增加。<br> 2、 索引需要占磁盘空间，除了数据表占数据空间之外，每一个索引还要占一定的物理空间，如果有大量的索引，索引文件可能比数据文件更快达到做大文件尺寸。<br> 3、 当对表中的数据进行增加，删除和修改的时候，索引也要动态地维护，这样就就降低了数据的维护速度。</p> 
<h3><a id="_51"></a>创建索引的原则</h3> 
<p>1、 该列用于频繁搜索。<br> 2、 该列用于对数据进行排序。<br> 3、 请不要使用下面的列创建索引：<br> 3.1、列中仅包含几个不同的值。<br> 3.2、表中仅包含几行。为小型表创建索引可能不太划算，因为SQL Server在索引中搜索数据所花的时间比在表中逐行搜索所花的时间更长。</p> 
<h3><a id="_57"></a>创建索引</h3> 
<pre><code>CREATE   [UNIQUE]   [CLUSTERED | NONCLUSTERRED]
INDEX    index_name   ON {table | view }(column [ASC | DESC ]  [,...n])
[ INCLUDE ( column_name [ ,...n])]
[with 
(
PAD_INDEX={ON | OFF}
|  FILLFACTOR =fillfactor
|  SORT_IN_TEMPDB={ ON | OFF}
|  IGNORE_DUP_KEY ={ ON  | OFF}
|  STATISRICS_NORECOMPUTE ={ ON | OFF}
|   DROP_EXISTING = { ON | OFF}
|  ONLINE ={ ON | OFF}
|  ALLOW_ROW_LOCKS ={ ON | OFF}
|  ALLOW_PAGE_LOCKS={ ON   | OFF}
|  MAXDOP =max_degree_of_parallelism
)  [,...n]]
</code></pre> 
<p>UNIQUE:表示在表或视图上创建唯一索引。唯一索引不允许两行具有相同的索引键值。视图的聚集索引必须唯一。</p> 
<p>CLUSTERED:表示创建聚集索引，在创建任何非聚集索引之前创建聚集索引，创建聚集索引时会重新生成表中现有的非聚集索引。如果没有指定CLUSTERED，则创建非聚集索引。</p> 
<p>NONCLUSTERED：表示创建一个非聚集索引，非聚集索引数据行的物理顺序独立于与索引排序，每个表最多可包含999个非聚集索引，NONCLUSTERED是CREATE INDEX的默认值。</p> 
<p>index_name:指定索引的名称，索引名称在表或视图中必须唯一，但在数据库中可不必唯一。</p> 
<p>ON{table | view }:指定索引所属的表或视图。</p> 
<p>Column：指定索引基于一列或者多列。指定两个或者多个列名，可为指定的列的组合值创建组合索引，{table | view}后的括号中，按排序优先级列出组合索引要包括的列。一个组合索引键中最多可组合16列。组合索引键中的所有列必须在同一个表或视图中。</p> 
<p>INCLUDE（column[,…n]）：指定要添加到非聚集索引的叶级别的非键列。</p> 
<p>PAD_INDEX:表示指定索引填充，默认值为OFF。ON值表示fillfactor指定的可用空间百分比应用于索引的中间级页。</p> 
<p>FILLFACTOR=fillfactor:制定一个百分比，表示在索引创建或重新生成过程中数据库引擎应使每个索引页的叶级别达到的填充程度。fillfactor必须为介于1至100直接的整数值，默认值为0；</p> 
<p>SORT_IN_TESTDB:指定是否在tempdb中存储临时排序结果，默认值为OFF，ON值表示在tempdb中存储用于生成索引的中间排序结果，OFF表示中间排序结果与索引存储在同一数据库中。</p> 
<p>IGNORE_DUP_KEY:指定唯一聚集索引或唯一非聚集索引执行多行插入操作时，出现重复键值的错误响应。默认值为OFF。ON表示发出一跳警告消息，但只有违反了唯一索引的行才会失败，OFF表示发出错误消息，并回滚整个INSERT事物。</p> 
<p>STATISRICS_NORECOMPUTE:指定是否重新计算分发统计信息，默认值为OFF。ON表示不会自动重新计算过时的统计信息，OFF表示启用统计信息自动更新功能。</p> 
<p>DROP_EXISTING:指定删除并重新生成已命名的先前存在的聚集或非聚集索引。默认值为OFF。ON表示删除并重新生成现有索引。指定的索引名称必须与当前现有的索引相同，但可以修改索引定义，例如：可以指定不同的列，排序顺序，分区方案或索引选项。OFF表示如果指定的索引名已存在，则会显示一条错误。</p> 
<p>ONLINE={ON | OFF}:指定在索引操作期间，基础表和关联的索引是否用于查询和数据修改操纵，默认值为OFF。</p> 
<p>ALLOW_ROW_LOCKS:指定是否允许行锁，默认值为ON，ON表示在访问索引时允许行所。数据库引擎确定何时使用行锁。OFF表示未使用行锁。</p> 
<p>ALLOW_PAGE_LOCKS:指定是否允许页锁，默认值为ON，ON表示在访问索引时允许页锁。数据库引擎确定何时使用页锁。ＯＦＦ表示未使用页锁。</p> 
<p>MAXDOP:指定在索引操作期间，覆盖【最大并行度】配置选项，使用MAXDOP可以限制在执行并行计划的过程中使用的处理器数量，最大数量为64.</p> 
<p>【例】在teacher表中的t_phone列上，创建一个名称为Idx_phone的唯一聚集索引，降序排列，填充因子为30%，输入语句如下:</p> 
<pre><code>CREATE  UNIQUE  CLOSTERED  INDEX  Idx_phone
ON  teacher (t_phone  DESC)
WITH
FILLFACTOR=30;
</code></pre> 
<h3><a id="_123"></a>修改索引</h3> 
<pre><code>ALTER INDEX {&lt;name of index&gt; | ALL}
ON&lt;table or view name&gt;
{ REBUILD
[[ WITH (
[PAD_INDEX = {ON | OFF}]
| [[,] FILLFACTOR = &lt;fillfactor&gt;
| [[,] SORT_IN_TEMPDB = { ON | OFF }]
| [[,] IGNORE_DUP_KEY = { ON | OFF }]
| [[,] STATISTICS_NORECOMPUTE = { ON | OFF }]
| [[,] ONLINE = { ON| OFF }]
| [[,] ALLOW_ROW_LOCKS = { ON | OFF }]
| [[,] ALLOW_PAGE_LOCKS = { ON | OFF }]
| [[,] MAXDOP = &lt;max degree of parallelism&gt;
)]
|[ PARTITION = &lt;partition number&gt;
[ WITH (&lt; partition rebuild index option&gt;
[,...N])]]]
| DISABLE
| REORGANIZE
[ PARTITION = &lt;partition number&gt; ]
[ WITH (LOB_COMPACTION = { ON | OFF })]
| SET ([ ALLOW_ROW_LOCKS = { ON | OFF} ]
| [[,] ALLOW_PAGE_LOCKS = { ON | OFF } ]
| [[,] IGNORE_DUP_KEY = { ON | OFF } ]
| [[,] STATISTICS_NORECOMPUTE = { ON | OFF }]
)
}[;]
</code></pre> 
<h3><a id="_154"></a>删除索引</h3> 
<pre><code>DROP  INDEX  '[table | view ].  index' [,...n]
或者
DROP  INDEX    ' index'  ON   '[table | view ].index' 
</code></pre> 
<p>index:用于指定要删除的索引名称。</p> 
<p>注意：DROP INDEX 命令不能删除由 CREATE TABLE或者ALTER TABLE命令创建的主键（PRIMARY KEY）或者唯一性（UNIQUE）约束索引，也不能删除系统表重的索引。</p> 
<p>【例】删除表teacher中的索引 multi_index，如下：</p> 
<pre><code>USE  sample_db;
GO
exec   sp_helpindex   'teacher'
DROP   INDEX   teacher.multi_index
Exec    sp_helpindex   'teacher';
</code></pre> 
<h3><a id="_177"></a>查看索引</h3> 
<p>用系统存储过程查看索引信息<br> 系统存储过程sp_helpindex可以返回某个表或视图中的索引信息，语法如下：<br> sp_helpindex [@objectname= ] ‘name’;</p> 
<p>[@objectname=] ‘name’:用户定义的表或视图的限定或非限定名称。仅当指定限定的表或视图名称时，才需要使用引号。如果提供了完全限定的名称，包括数据库名称，则该数据库名称必须是当前数据库的名称。</p> 
<p>【例】使用存储过程查看是 sample_db数据库中teacher表中定义的索引信息，输入语句如下。</p> 
<pre><code>USE  sample_db; 
GO
exec sp_helpindex 'teacher';
</code></pre> 
<h2><a id="_192"></a>视图</h2> 
<p>从用户角度来看，一个视图是从一个特定的角度来查看数据库中的数据 。</p> 
<p>从数据库系统内部来看，一个视图是由 SELECT 语句组成的查询定义的虚拟表（因为一个视图可以拉动多个表，并汇总数据在一起并将其显示，就好像它是一个单一的表）</p> 
<p>视图是由一张或多张表中的数据组成的，当你运行视图，会看到它的结果，就像打开一个表时一样。</p> 
<p>从数据库系统外部来看，视图就如同一张表一样，对表能够进行的一般操作都可以应用于视图，例如查询，插入，修改，删除操作等。但是视图属于虚拟表，只能查询数据，不能对其数据进行修改，插入，删除等操作。</p> 
<h3><a id="_201"></a>创建视图</h3> 
<p>通过使用 CREATE VIEW 语句创建一个视图，其次是 SELECT 语句，如下：</p> 
<pre><code>CREATE  VIEW  ViewName  AS
SELECT ...
</code></pre> 
<h3><a id="_209"></a>查询视图</h3> 
<p>查询视图就像是查询数据库表数据一样。 如下：</p> 
<pre><code>SELECT  *  FROM  ViewName;
</code></pre> 
<h3><a id="_216"></a>修改视图</h3> 
<p>通过使用 ALTER 修改现有的视图，而不是 CREATE。</p> 
<p>如果我们想要更改视图就要使用 StatusName 字段，而不是 StatusId，做法如下：</p> 
<pre><code>ALTER VIEW ToDoList AS
SELECT	Tasks.TaskName, Tasks.Description
FROM	Status INNER JOIN
			Tasks ON Status.StatusId = Tasks.StatusId
WHERE	(Status.StatusName = 'To Do')
</code></pre> 
<h3><a id="_229"></a>删除视图</h3> 
<pre><code>drop  view  ViewName;
</code></pre> 
<p>注：使用查询设计器也可以右键单击视图，然后选择设计来修改您的视图。<br> 正如你所看到的，视图让您保存查询，以便可以做一个 SELECT，再次运行它也会比较简单。<br> 但它们的确有其局限性：它们允许选择数据，但不允许执行任何业务逻辑，如条件语句等。</p> 
<h2><a id="_239"></a>存储过程</h2> 
<p><a href="https://www.w3cschool.cn/sql/sql-storage.html" rel="nofollow">参考文献：https://www.w3cschool.cn/sql/sql-storage.html</a></p> 
<p>视图通过简单的SELECT查询来解决复杂的查询，但是视图不能提供业务逻辑功能，而存储过程可以办到这点。</p> 
<h3><a id="_243"></a>定义</h3> 
<p>存储过程 Procedure 是一组为了完成特定功能的 SQL 语句集合，经编译后存储在数据库中，用户通过指定存储过程的名称并给出参数来执行。</p> 
<p>存储过程中可以包含逻辑控制语句和数据操纵语句，它可以接受参数、输出参数、返回单个或多个结果集以及返回值。</p> 
<p>由于存储过程在创建时即在数据库服务器上进行了编译并存储在数据库中，所以存储过程运行要比单个的 SQL 语句块要快。同时由于在调用时只需用提供存储过程名和必要的参数信息，所以在一定程度上也可以减少网络流量、简单网络负担。</p> 
<h3><a id="_249"></a>优点</h3> 
<p>1、 存储过程只在创造时进行编译，以后每次执行存储过程都不需再重新编译，而一般SQL语句每执行一次就编译一次,所以使用存储过程可提高数据库执行速度，效率要比T-SQL语句高。<br> 2、 当对数据库进行复杂操作时，可将此复杂操作用存储过程封装起来与数据库提供的事务处理结合一起使用。<br> 3、 一个存储过程在程序在网络中交互时可以替代大堆的T-SQL语句，所以也能降低网络的通信量，提高通信速率。<br> 4、 存储过程可以重复使用,可减少数据库开发人员的工作量。<br> 5、 安全性高,可设定只有某些用户才具有对指定存储过程的使用权。<br> <img src="https://images2.imgbox.com/81/5f/jcpn1Hk3_o.png" alt="在这里插入图片描述"></p> 
<h3><a id="_256"></a>创建存储过程</h3> 
<p>我们需要使用 CREATE PROCEDURE 语句创建一个存储过程，接着要补充存储过程的代码，如果存储过程将要接受参数，它们需要被包括在名称后，如下：</p> 
<pre><code>CREATE  PROCEDURE  ProcedureName  AS
OR
CREATE  PROCEDURE  ProcedureName  @{Parameter Name} {data type}  AS
</code></pre> 
<h3><a id="_265"></a>执行存储过程</h3> 
<p>创建了存储过程后，要在任何时候执行它，可以执行或者调用 EXEC。如果存储过程的参数要求提供这些程序名在后面，像这样：</p> 
<pre><code>EXECUTE  ProcedureName 
EXEC  ProcedureName  
EXEC  ProcedureName  @Parameter = 5
</code></pre> 
<h3><a id="_274"></a>修改存储过程</h3> 
<p>如果需要修改现有的存储过程，只需更换掉 CREATE ，使用 ALTER。</p> 
<p>我们在 “Latest” 和 “Tasks”间添加一个空格（即“Latest Tasks”），并添加描述字段，如下：</p> 
<pre><code>ALTER PROCEDURE  ProcedureName  @Count int AS
SET ROWCOUNT @Count
SELECT TaskName AS "Latest Tasks", Description, DateCreated
FROM Tasks
ORDER BY DateCreated DESC
</code></pre> 
<h3><a id="_287"></a>删除存储过程</h3> 
<pre><code>drop  procedure  ProcedureName ;
</code></pre> 
<h2><a id="_293"></a>触发器</h2> 
<h3><a id="_294"></a>定义</h3> 
<p>触发器是一种特殊类型的存储过程，它在您使用一种或多种数据修改操作（UPDATE、INSERT 或 DELETE）来修改指定表中的数据时运行。</p> 
<h3><a id="_296"></a>优点</h3> 
<p>1、 触发器是自动的。当对表中的数据做了任何修改之后立即被激活。<br> 2、 触发器可以通过数据库中的相关表进行层叠修改。<br> 3、 触发器可以强制限制。这些限制比用CHECK约束所定义的更复杂。与CHECK约束不同的是，触发器可以引用其他表中的列。</p> 
<h3><a id="_300"></a>作用</h3> 
<p>触发器的主要作用就是其能够实现由主键和外键所不能保证的复杂参照完整性和数据的一致性，它能够对数据库中的相关表进行级联修改，提高比CHECK约束更复杂的的数据完整性，并自定义错误消息。触发器的主要作用主要有以下接个方面：<br> 1、 强制数据库间的引用完整性。<br> 2、 级联修改数据库中所有相关的表，自动触发其它与之相关的操作。<br> 3、 跟踪变化，撤销或回滚违法操作，防止非法修改数据。<br> 4、 返回自定义的错误消息，约束无法返回信息，而触发器可以。<br> 5、 触发器可以调用更多的存储过程。</p> 
<h3><a id="_307"></a>分类</h3> 
<h4><a id="DMLData__Manipulation__Language_308"></a>DML(数据操作语言,Data Manipulation Language)触发器</h4> 
<p>DML触发器是一些附加在特定表或视图上的操作代码，当数据库服务器中发生数据操作语言事件时执行这些操作。SQL Server中的DML触发器有三种：<br> 1、 insert触发器: 向表中插入数据时被触发；<br> 2、 delete触发器：从表中删除数据时被触发；<br> 3、 update触发器：修改表中数据时被触发。</p> 
<h4><a id="DDLData__Definition__Language_314"></a>DDL(数据定义语言,Data Definition Language)触发器</h4> 
<p>DDL触发器是当服务器或者数据库中发生数据定义语言(主要是以create,drop,alter开头的语句)事件时被激活使用，使用DDL触发器可以防止对数据架构进行的某些更改或记录数据中的更改或事件操作。</p> 
<h4><a id="_316"></a>登录触发器</h4> 
<p>登录触发器将为响应 LOGIN 事件而激发存储过程。与SQL Server实例建立用户会话时将引发此事件。登录触发器将在登录的身份验证阶段完成之后且用户会话实际建立之前激发。因此，来自触发器内部且通常将到达用户的所有消息（例如错误消息和来自PRINT语句的消息）会传送到SQL Server错误日志。如果身份验证失败，将不激发登录触发器。</p> 
<h4><a id="_319"></a>注意</h4> 
<p>Instead of 和 After触发器。这两种触发器的差别在于他们被激活的同：<br> Instead of触发器用于替代引起触发器执行的T-SQL语句。除表之外，Instead of 触发器也可以用于视图，用来扩展视图可以支持的更新操作。<br> After触发器在一个Insert,Update或Deleted语句之后执行，进行约束检查等动作都在After触发器被激活之前发生。After触发器只能用于表。<br> 一个表或视图的每一个修改动作(insert,update和delete)都可以有一个instead of 触发器，一个表的每个修改动作都可以有多个After触发器。</p> 
<h3><a id="_324"></a>工作原理</h3> 
<p>触发器触发时，系统自动在内存中创建临时表（inserted表或者deleted表）；该表只读，不允许修改，触发器执行完成后，自动删除临时表。<br> <img src="https://images2.imgbox.com/54/c8/5KV4x1xa_o.png" alt="在这里插入图片描述"></p> 
<h3><a id="_327"></a>创建触发器</h3> 
<pre><code>CREATE   TRIGGER   TriggerName
  ON   { TableName | ViewName }
[ WITH ENCRYPTION ]  //用于加密触发器 ，可以省略
{  FOR  | AFTER  |  INSTEAD  OF }   [INSERT | UPDATE | DELETE]
AS
BEGIN 
/*  执行的sql 语句  */
END 
</code></pre> 
<h3><a id="_340"></a>修改触发器</h3> 
<pre><code>ALTER   TRIGGER   TriggerName
  ON   { TableName | ViewName }
[ WITH ENCRYPTION ]  //用于加密触发器 ，可以省略
{  FOR  | AFTER  |  INSTEAD  OF }   [INSERT | UPDATE | DELETE]
AS
BEGIN 
/*  执行的sql 语句  */
END 
</code></pre> 
<h3><a id="_353"></a>禁用触发器</h3> 
<pre><code>DISABLE  TRIGGER  TriggerName
  ON   { TableName | ViewName }
</code></pre> 
<h3><a id="_360"></a>启用触发器</h3> 
<pre><code>ENABLE  TRIGGER  TriggerName
  ON   { TableName | ViewName }
</code></pre> 
<h3><a id="_367"></a>查询已存在的触发器</h3> 
<pre><code>select * from sys.triggers;
select * from sys.objects where type = 'TR';
</code></pre> 
<h3><a id="_374"></a>查看触发器触发事件</h3> 
<pre><code>select  te.* , t.* from sys.trigger_events te 
join sys.triggers t  on t.object_id = te.object_id
</code></pre> 
<h3><a id="_381"></a>查看创建触发器语句</h3> 
<pre><code>exec  sp_helptext  'trigger_name';
</code></pre> 
<h3><a id="_387"></a>删除触发器</h3> 
<pre><code>drop trigger trigger_name
</code></pre> 
<h2><a id="_393"></a>作业</h2> 
<p><a href="https://www.cnblogs.com/kerrycode/p/3279559.html" rel="nofollow">参考文献：https://www.cnblogs.com/kerrycode/p/3279559.html</a><br> <a href="https://jingyan.baidu.com/article/adc81513be3423f722bf7351.html" rel="nofollow">创建/修改 定时作业：https://jingyan.baidu.com/article/adc81513be3423f722bf7351.html</a><br> <a href="https://jingyan.baidu.com/article/0f5fb099efaa2c6d8334eae5.html" rel="nofollow">查看 定时作业 执行历史记录：<br> https://jingyan.baidu.com/article/0f5fb099efaa2c6d8334eae5.html</a><br> <a href="https://jingyan.baidu.com/article/46650658e78e82f549e5f8c8.html" rel="nofollow">备份：https://jingyan.baidu.com/article/46650658e78e82f549e5f8c8.html</a><br> <a href="https://www.cnblogs.com/punkrocker/p/11337149.html" rel="nofollow">自动备份：https://www.cnblogs.com/punkrocker/p/11337149.html</a><br> <a href="https://docs.microsoft.com/zh-cn/sql/relational-databases/backup-restore/back-up-and-restore-of-sql-server-databases?view=sql-server-ver15" rel="nofollow">备份/还原：https://docs.microsoft.com/zh-cn/sql/relational-databases/backup-restore/back-up-and-restore-of-sql-server-databases?view=sql-server-ver15</a></p> 
<h2><a id="_401"></a>同步（一主多从）</h2> 
<p>项目读写分离，修改主表数据，同步从表数据<br> 参考文献：<a href="https://jingyan.baidu.com/article/73c3ce2844c43be50343d9d4.html" rel="nofollow">https://jingyan.baidu.com/article/73c3ce2844c43be50343d9d4.html</a><br> <a href="https://blog.csdn.net/weixin_34146410/article/details/92407244?utm_medium=distribute.pc_relevant.none-task-blog-baidujs-5">https://blog.csdn.net/weixin_34146410/article/details/92407244?utm_medium=distribute.pc_relevant.none-task-blog-baidujs-5</a><br> <a href="https://www.cnblogs.com/zhengcheng/p/4492423.html" rel="nofollow">https://www.cnblogs.com/zhengcheng/p/4492423.html</a></p> 
<p>注意：后期文档需要提交</p> 
<h2><a id="_409"></a>链接服务器</h2> 
<p><a href="https://www.w3cschool.cn/sqlserver/sqlserver-xy1g28p7.html" rel="nofollow">参考文献：https://www.w3cschool.cn/sqlserver/sqlserver-xy1g28p7.html</a></p> 
<p>SQL Server 中存在可以链接到其他服务器的选项，一般情况下是用来与别的 SQL Server 数据库相连接，但是有时候也可以与一个Microsoft Access数据库 相连接。这样的操作是通过链接服务器节点实现的。</p> 
<p>链接服务器节点可以连接到另一个数据库，通常/通常在不同的机器上运行，也许在不同的城市/国家。如果您需要执行分布式查询(查询远程数据库)，这可能是有用的。</p> 
<p>设置链接服务器就是相当于使用简单的 SQL Server 管理套件，所有需要的就是查询远程服务器的详细信息，以及数据库。</p> 
<p>创建链接服务器</p> 
<pre><code>exec sp_addlinkedserver 'ITSV ', ' ', 'SQLOLEDB ', '远程服务器名或ip地址 '
exec sp_addlinkedsrvlogin 'ITSV ', 'false ',null, '用户名 ', '密码 '
</code></pre> 
<p>查询示例</p> 
<pre><code>select * from ITSV.数据库名.dbo.表名
</code></pre> 
<p>导入示例</p> 
<pre><code>select * into 表 from ITSV.数据库名.dbo.表名
</code></pre> 
<p>以后不再使用时删除链接服务器</p> 
<pre><code>exec sp_dropserver 'ITSV ', 'droplogins '
</code></pre> 
<h3><a id="_439"></a>连接远程/局域网数据</h3> 
<h4><a id="openrowset_440"></a>openrowset</h4> 
<p>查询示例：</p> 
<pre><code>select * from openrowset( 'SQLOLEDB ', 'sql服务器名 '; '用户名 '; '密码 ',数据库名.dbo.表名)
</code></pre> 
<p>生成本地表：</p> 
<pre><code>select * into 表 from openrowset( 'SQLOLEDB ', 'sql服务器名 '; '用户名 '; '密码 ',数据库名.dbo.表名)
</code></pre> 
<p>把本地表导入远程表：</p> 
<pre><code>insert openrowset( 'SQLOLEDB ', 'sql服务器名 '; '用户名 '; '密码 ',数据库名.dbo.表名)
select *from 本地表
</code></pre> 
<p>更新本地表：</p> 
<pre><code>update b
set b.列A=a.列A
from openrowset( 'SQLOLEDB ', 'sql服务器名 '; '用户名 '; '密码 ',数据库名.dbo.表名)as a inner join 本地表 b
on a.column1=b.column1
</code></pre> 
<h4><a id="openquery_465"></a>openquery</h4> 
<p>首先创建一个连接创建链接服务器</p> 
<pre><code>exec sp_addlinkedserver 'ITSV ', ' ', 'SQLOLEDB ', '远程服务器名或ip地址 '
</code></pre> 
<p>查询</p> 
<pre><code>select *
FROM openquery(ITSV, 'SELECT * FROM 数据库.dbo.表名 ')
</code></pre> 
<p>把本地表导入远程表</p> 
<pre><code>insert openquery(ITSV, 'SELECT * FROM 数据库.dbo.表名 ')
select * from 本地表
</code></pre> 
<p>更新本地表</p> 
<pre><code>update b
set b.列B=a.列B
FROM openquery(ITSV, 'SELECT * FROM 数据库.dbo.表名 ') as a
inner join 本地表 b on a.列A=b.列A
</code></pre> 
<h4><a id="opendatasourceopenrowset_491"></a>opendatasource/openrowset</h4> 
<pre><code>SELECT *
FROM opendatasource( 'SQLOLEDB ', 'Data Source=ip/ServerName;User ID=登陆名;Password=密码' ).test.dbo.roy_ta
</code></pre> 
<p>把本地表导入远程表</p> 
<pre><code>insert opendatasource( 'SQLOLEDB ', 'Data Source=ip/ServerName;User ID=登陆名;Password=密码 ').数据库.dbo.表名
select * from 本地表
</code></pre> 
<h2><a id="SQL__503"></a>SQL 语句</h2> 
<p><a href="https://www.w3cschool.cn/sql/sql-sentence.html" rel="nofollow">参考文献：https://www.w3cschool.cn/sql/sql-sentence.html</a></p> 
<h3><a id="_505"></a>变量</h3> 
<h4><a id="_506"></a>局部变量</h4> 
<pre><code>declare  @id char(10)   -- 声明
set @id = ‘01’
select  @id = ‘02’ –  赋值
</code></pre> 
<h4><a id="_514"></a>全局变量</h4> 
<p>全局变量声明必须以@@开头</p> 
<h3><a id="_517"></a>判断语句</h3> 
<h4><a id="IF_ELSE_518"></a>IF ELSE</h4> 
<pre><code>if  判断条件
执行语句
else if 判断条件
执行语句
else 执行语句
</code></pre> 
<h4><a id="CASE_528"></a>CASE</h4> 
<pre><code> CASE 
 WHEN  条件 then  执行语句
 WHEN  条件 then  执行语句
else 语句
end
</code></pre> 
<h3><a id="_while_538"></a>循环 while</h3> 
<pre><code>WHILE 条件
BEGIN 
  执行
END 
</code></pre> 
<h3><a id="a_b_Access_547"></a>复制表(只复制结构,源表名：a 新表名：b) (Access可用)</h3> 
<pre><code>方法一：select * into b from a where 1&lt;&gt;1
方法二：select top 0 * into b from a
</code></pre> 
<h3><a id="a_b_Access_554"></a>拷贝表(拷贝数据,源表名：a 目标表名：b) (Access可用)</h3> 
<pre><code>insert into b(a, b, c) select d,e,f from a;
</code></pre> 
<h3><a id="Access_560"></a>跨数据库之间表的拷贝(具体数据使用绝对路径)(Access可用)</h3> 
<pre><code>insert into b(a, b, c) select d,e,f from b in ‘具体数据库’ where 条件 
例子：..from b in '"&amp;Server.MapPath(".")&amp;"\data.mdb" &amp;"' where..
</code></pre> 
<h3><a id="table1_567"></a>初始化表table1</h3> 
<p>此sql 只删除表数据 不更改表结构</p> 
<pre><code>TRUNCATE  ABLE   ble1
</code></pre> 
<h3><a id="_574"></a>删除数据库表</h3> 
<pre><code>DROP  ABLE  ableName 
</code></pre> 
<h3><a id="_579"></a>分页</h3> 
<pre><code>select top 10 b.* from (select top 20 主键字段,排序字段 from 表名 order by 排序字段 desc) a,表名 b where b.主键字段 = a.主键字段 order by a.排序字段
</code></pre> 
<p>数据库分页：</p> 
<pre><code>declare @start int,@end int
@sql nvarchar(600)
set @sql=’select top’+str(@end-@start+1)+’+from T where rid not in(select top’+str(@str-1)+’Rid from T where Rid&gt;-1)’
exec sp_executesql @sql
</code></pre> 
<blockquote> 
 <p>注意：在top后不能直接跟一个变量，所以在实际应用中只有这样的进行特殊的处理。Rid为一个标识列，如果top后还有具体的字段，这样做是非常有好处的。因为这样可以避免<br> top的字段如果是逻辑索引的，查询的结果后实际表中的不一致（逻辑索引中的数据有可能和数据表中的不一致，而查询时如果处在索引则首先查询索引）</p> 
</blockquote> 
<p>N到M条记录(要有主索引ID)</p> 
<pre><code>Select Top M-N * From 表 Where ID in (Select Top M ID From 表) Order by ID Desc 
</code></pre> 
<p>例：一张表有一万多条记录，表的第一个字段 RecID 是自增长字段， 写一个SQL语句， 找出表的第31到第40个记录。</p> 
<pre><code>select top 10 b.*  from ( select  top  40  a.*  from a order by a.recid ) b  order by b.recid desc 
</code></pre> 
<h3><a id="__UNION__606"></a>并集 UNION 运算符</h3> 
<p>UNION 运算符通过组合其他两个结果表（例如 TABLE1 和 TABLE2）并消去表中任何重复行而派生出一个结果表。当 ALL 随 UNION一起使用时（即 UNION ALL），不消除重复行。两种情况下，派生表的每一行不是来自 TABLE1 就是来自 TABLE2。</p> 
<h3><a id="_INTERSECT_608"></a>交集 INTERSECT</h3> 
<p>INTERSECT 运算符通过只包括 TABLE1 和 TABLE2 中都有的行并消除所有重复行而派生出一个结果表。当 ALL 随 INTERSECT 一起使用时 (INTERSECT ALL)，不消除重复行。</p> 
<h3><a id="__EXCEPT_610"></a>去重 EXCEPT</h3> 
<p>EXCEPT 运算符通过包括所有在 TABLE1 中但不在 TABLE2 中的行并消除所有重复行而派生出一个结果表。当 ALL 随 EXCEPT 一起使用时 (EXCEPT ALL)，不消除重复行。</p> 
<p>例：包括所有在 TableA 中但不在 TableB和TableC 中的行并消除所有重复行而派生出一个结果表</p> 
<pre><code>(select a from tableA ) except (select a from tableB) except (select a from tableC)
</code></pre> 
<h3><a id="ROW_NUMBER_618"></a>ROW_NUMBER()</h3> 
<p>说明：返回结果集分区内行的序列号，每个分区的第一行从1开始。<br> 语法：ROW_NUMBER () OVER ([ &lt;partition_by_clause&gt; ] &lt;order_by_clause&gt;) 。<br> 备注：ORDER BY 子句可确定在特定分区中为行分配唯一 ROW_NUMBER 的顺序。<br> 参数：&lt;partition_by_clause&gt; ：将 FROM 子句生成的结果集划入应用了 ROW_NUMBER 函数的分区。<br> &lt;order_by_clause&gt;：确定将 ROW_NUMBER 值分配给分区中的行的顺序。<br> 返回类型：bigint 。<br> 例：统计每一个客户最近下的订单是第几次下的订单。</p> 
<pre><code>with tabs as 
( 
select ROW_NUMBER() over(partition by customerID  order by totalPrice) as rows,customerID,totalPrice, DID from OP_Order 
 ) 
select MAX(rows) as '下单次数',customerID from tabs group by customerID
   
</code></pre> 
<p>备注：此文章内容来源w3cschool教程，如有问题，请评论指教！</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/92663d23a1388ec7c69b01a537d0b5ad/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">js设置单选框为选中状态</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/27a15a5dcd1dabeedff466873f32135e/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">PostgreSQL修改数据目录方法记录</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>