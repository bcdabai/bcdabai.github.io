<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Docker 【网络】配置dns - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Docker 【网络】配置dns" />
<meta property="og:description" content="Docker 配置 DNS 文章目录 Docker 配置 DNS1. docker配置DNS方法2. 默认DNS配置3. 启动时配置dns参数4. daemon.json配置DNS格式 1. docker配置DNS方法 docker容器配置dns解析地址，我知道的有以下几种办法（优先级从高到低）：
启动的时候加–dns=IP_ADDRESS；守护进程启动参数中添加DOCKER_OPTS=“–dns 8.8.8.8” ；在/etc/docker/deamon.json中添加dns信息（与守护进程参数会冲突不能同时添加。）；使用宿主机的/etc/resolv.conf文件； 2. 默认DNS配置 怎样为Docker提供的每一个容器进行主机名和DNS配置，而不必建立自定义镜像并将主机名写 到里面？它的诀窍是覆盖三个至关重要的在/etc下的容器内的虚拟文件，那几个文件可以写入 新的信息。你可以在容器内部运行mount看到这个：
$ mount ... /dev/disk/by-uuid/1fec...ebdf on /etc/hostname type ext4 ... /dev/disk/by-uuid/1fec...ebdf on /etc/hosts type ext4 ... /dev/disk/by-uuid/1fec...ebdf on /etc/resolv.conf type ext4 ... ... 3. 启动时配置dns参数 OptionsDescription-h HOSTNAME or --hostname=HOSTNAME在该容器启动时，将HOSTNAME设置到容器内的/etc/hosts, /etc/hostname, /bin/bash提示中。–link=CONTAINER_NAME or ID:ALIAS在该容器启动时，将ALIAS和CONTAINER_NAME/ID对应的容器IP添加到/etc/hosts. 如果 CONTAINER_NAME/ID有多个IP地址 ？–dns=IP_ADDRESS…在该容器启动时，将nameserver IP_ADDRESS添加到容器内的/etc/resolv.conf中。可以配置多个。–dns-search=DOMAIN…在该容器启动时，将DOMAIN添加到容器内/etc/resolv.conf的dns search列表中。可以配置多个。–dns-opt=OPTION…在该容器启动时，将OPTION添加到容器内/etc/resolv.conf中的options选项中，可以配置多个 如果docker run时不含--dns=IP_ADDRESS…, --dns-search=DOMAIN…, or --dns-opt=OPTION…参数，docker daemon会将copy本主机的/etc/resolv.conf，然后对该copy进行处理（将那些/etc/resolv.conf中ping不通的nameserver项给抛弃）,处理完成后留下的部分就作为该容器内部的/etc/resolv.conf。因此，如果你想利用宿主机中的/etc/resolv.conf配置的nameserver进行域名解析，那么你需要宿主机中该dns service配置一个宿主机内容器能ping通的IP。
如果宿主机的/etc/resolv.conf内容发生改变，docker daemon有一个对应的file change notifier会watch到这一变化，然后根据容器状态采取对应的措施：" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/77fcd9d1a9bb33a2f1cb885d05670c80/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-07-04T01:18:57+08:00" />
<meta property="article:modified_time" content="2022-07-04T01:18:57+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Docker 【网络】配置dns</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-github-gist">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <h2><a id="Docker__DNS_0"></a>Docker 配置 DNS</h2> 
<p></p> 
<div class="toc"> 
 <h4>文章目录</h4> 
 <ul><li><a href="#Docker__DNS_0" rel="nofollow">Docker 配置 DNS</a></li><li><ul><li><a href="#1_dockerDNS_5" rel="nofollow">1. docker配置DNS方法</a></li><li><a href="#2_DNS_12" rel="nofollow">2. 默认DNS配置</a></li><li><a href="#3_dns_24" rel="nofollow">3. 启动时配置dns参数</a></li><li><a href="#4_daemonjsonDNS_58" rel="nofollow">4. daemon.json配置DNS格式</a></li></ul> 
 </li></ul> 
</div> 
<p></p> 
<hr> 
<h3><a id="1_dockerDNS_5"></a>1. docker配置DNS方法</h3> 
<p>docker容器配置dns解析地址，我知道的有以下几种办法（优先级从高到低）：</p> 
<ol><li>启动的时候加–dns=IP_ADDRESS；</li><li>守护进程启动参数中添加DOCKER_OPTS=“–dns 8.8.8.8” ；</li><li>在/etc/docker/deamon.json中添加dns信息（与守护进程参数会冲突不能同时添加。）；</li><li>使用宿主机的/etc/resolv.conf文件；</li></ol> 
<h3><a id="2_DNS_12"></a>2. 默认DNS配置</h3> 
<p>怎样为Docker提供的每一个容器进行主机名和DNS配置，而不必建立自定义镜像并将主机名写 到里面？它的诀窍是覆盖三个至关重要的在/etc下的容器内的虚拟文件，那几个文件可以写入 新的信息。你可以在容器内部运行mount看到这个：</p> 
<pre><code class="prism language-bash">$ <span class="token function">mount</span>
<span class="token punctuation">..</span>.
/dev/disk/by-uuid/1fec<span class="token punctuation">..</span>.ebdf on /etc/hostname <span class="token builtin class-name">type</span> ext4 <span class="token punctuation">..</span>.
/dev/disk/by-uuid/1fec<span class="token punctuation">..</span>.ebdf on /etc/hosts <span class="token builtin class-name">type</span> ext4 <span class="token punctuation">..</span>.
/dev/disk/by-uuid/1fec<span class="token punctuation">..</span>.ebdf on /etc/resolv.conf <span class="token builtin class-name">type</span> ext4 <span class="token punctuation">..</span>.
<span class="token punctuation">..</span>.
</code></pre> 
<h3><a id="3_dns_24"></a>3. 启动时配置dns参数</h3> 
<table><thead><tr><th>Options</th><th>Description</th></tr></thead><tbody><tr><td>-h HOSTNAME or --hostname=HOSTNAME</td><td>在该容器启动时，将HOSTNAME设置到容器内的/etc/hosts, /etc/hostname, /bin/bash提示中。</td></tr><tr><td>–link=CONTAINER_NAME or ID:ALIAS</td><td>在该容器启动时，将ALIAS和CONTAINER_NAME/ID对应的容器IP添加到/etc/hosts. 如果 CONTAINER_NAME/ID有多个IP地址 ？</td></tr><tr><td>–dns=IP_ADDRESS…</td><td>在该容器启动时，将nameserver IP_ADDRESS添加到容器内的/etc/resolv.conf中。可以配置多个。</td></tr><tr><td>–dns-search=DOMAIN…</td><td>在该容器启动时，将DOMAIN添加到容器内/etc/resolv.conf的dns search列表中。可以配置多个。</td></tr><tr><td>–dns-opt=OPTION…</td><td>在该容器启动时，将OPTION添加到容器内/etc/resolv.conf中的options选项中，可以配置多个</td></tr></tbody></table> 
<p>如果docker run时不含<code>--dns=IP_ADDRESS</code>…, <code>--dns-search=DOMAIN</code>…, or <code>--dns-opt=OPTION</code>…参数，docker daemon会将copy本主机的<code>/etc/resolv.conf</code>，然后对该copy进行处理（将那些/etc/resolv.conf中ping不通的nameserver项给抛弃）,处理完成后留下的部分就作为该容器内部的/etc/resolv.conf。因此，如果你想利用宿主机中的/etc/resolv.conf配置的nameserver进行域名解析，那么你需要宿主机中该dns service配置一个宿主机内容器能ping通的IP。<br> 如果宿主机的/etc/resolv.conf内容发生改变，docker daemon有一个对应的file change notifier会watch到这一变化，然后根据容器状态采取对应的措施：</p> 
<ul><li>如果容器状态为stopped，则立刻根据宿主机的/etc/resolv.conf内容更新容器内的/etc/resolv.conf.</li><li>如果容器状态为running，则容器内的/etc/resolv.conf将不会改变，直到该容器状态变为stopped.</li><li>如果容器启动后修改过容器内的/etc/resolv.conf，则不会对该容器进行处理，否则可能会丢失已经完成的修改，无论该容器为什么状态。</li><li>如果容器启动时，用了–dns, --dns-search, or --dns-opt选项，其启动时已经修改了宿主机的/etc/resolv.conf过滤后的内容，因此docker daemon永远不会更新这种容器的/etc/resolv.conf。</li></ul> 
<blockquote> 
 <p>注意: docker daemon监控宿主机/etc/resolv.conf的这个file change notifier的实现是依赖linux内核的inotify特性，而inotfy特性不兼容overlay fs，因此使用overlay fs driver的docker deamon将无法使用该/etc/resolv.conf自动更新的功能。、</p> 
</blockquote> 
<pre><code class="prism language-bash"> $ <span class="token function">sudo</span> <span class="token function">docker</span> run --hostname <span class="token string">'myhost'</span> -it centos
 <span class="token punctuation">[</span>root@myhost /<span class="token punctuation">]</span><span class="token comment"># cat /etc/hosts</span>
 <span class="token number">172.17</span>.0.7    myhost

 $  <span class="token function">sudo</span> <span class="token function">docker</span> run -it --dns<span class="token operator">=</span><span class="token number">192.168</span>.5.1  centos
 <span class="token punctuation">[</span>root@6a38049c9052 /<span class="token punctuation">]</span><span class="token comment"># cat /etc/resolv.conf</span>
 nameserver <span class="token number">192.168</span>.5.1

 $  <span class="token function">sudo</span> <span class="token function">docker</span> run -it --dns-search<span class="token operator">=</span>www.domain.com  centos
 <span class="token punctuation">[</span>root@ae0e9e99596f /<span class="token punctuation">]</span><span class="token comment"># cat /etc/resolv.conf</span>
 nameserver <span class="token number">192.168</span>.4.1
 search www.mydomain.com
</code></pre> 
<h3><a id="4_daemonjsonDNS_58"></a>4. daemon.json配置DNS格式</h3> 
<pre><code class="prism language-bash">root@node-7:~<span class="token comment"># cat /etc/docker/daemon.json</span>
<span class="token punctuation">{<!-- --></span>
  <span class="token string">"data-root"</span><span class="token builtin class-name">:</span> <span class="token string">"/data/docker"</span>,
  <span class="token string">"dns"</span><span class="token builtin class-name">:</span> <span class="token punctuation">[</span><span class="token string">"172.18.0.52"</span>, <span class="token string">"172.18.0.70"</span>, <span class="token string">"183.XX.XX.XX"</span><span class="token punctuation">]</span>,
  <span class="token string">"dns-search"</span><span class="token builtin class-name">:</span> <span class="token punctuation">[</span><span class="token string">"fiibeacon.local"</span><span class="token punctuation">]</span>,
  <span class="token string">"hosts"</span><span class="token builtin class-name">:</span> <span class="token punctuation">[</span><span class="token string">"unix:///var/run/docker.sock"</span>, <span class="token string">"tcp://172.18.0.141:2375"</span><span class="token punctuation">]</span>,
  <span class="token string">"storage-driver"</span><span class="token builtin class-name">:</span> <span class="token string">"overlay2"</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>参考：</p> 
<ul><li><a href="http://www.dockerinfo.net/%E9%AB%98%E7%BA%A7%E7%BD%91%E7%BB%9C%E9%85%8D%E7%BD%AE" rel="nofollow">docker高级网络配置</a></li><li><a href="https://cloud.tencent.com/developer/article/1096388" rel="nofollow">docker container DNS配置介绍和源码分析</a></li></ul>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/019d933f4f282c9c54bbeb787103e295/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">java项目部署Linux服务器几种启动方式总结经验</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/b7eb6542c1d5cb60d30b695f77260620/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">Spring5.x之@Autowired原理</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>