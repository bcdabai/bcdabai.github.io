<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>秋招面试知识点----JVM篇 - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="秋招面试知识点----JVM篇" />
<meta property="og:description" content="1.发生栈内存溢出。 描述栈定义，再描述为什么会溢出，再说明一下相关配置参数，OK的话可以给面试官手写是一个栈溢出的demo。
栈定义 存放基本类型的变量数据和对象的引用，栈是线程私有的，他的生命周期与线程相同。每个方法在执行的时候都会创建一个栈帧，用来存储局部变量表，操作数栈，动态链接，方法出口等信息。每个方法从调用直至执行完成的过程，就对应着一个栈帧在虚拟机栈中入栈到出栈的过程。 为什么会溢出 如果线程请求的栈深度大于虚拟机所允许的最大深度，就会抛出StackOverflowError异常。如果虚拟机在扩展栈时无法申请足够的内存空间，就会抛出OutOfMemoryError异常。 相关参数 -Xss 调整JVM栈的大小 栈溢出 无限递归，没有结束条件。
public class StackTest { public static void main(String[] args) { main(args); } } `
2.详解JVM内存模型 思路： 给面试官画一下JVM内存模型图，并描述每个模块的定义，作用，以及可能会存在的问题，如栈溢出等。
共享的，包括 Java 堆和方法区；
私有的，包括虚拟机栈和本地方法栈，以及程序计数器这一小部分内存。
堆内存（Heap）
对于大多数应用来说，Java 堆（Java Heap）是Java 虚拟机所管理的内存中最大的一块。Java 堆是被所有线程共享的一块内存区域，在虚拟机启动时创建。
此内存区域的唯一目的就是存放对象实例，几乎所有的对象实例都在这里分配内存。
堆内存是所有线程共有的，可以分为两个部分：年轻代和老年代。
下图中的Perm代表的是永久代，但是注意永久代并不属于堆内存中的一部分，同时jdk1.8之后永久代已经被移除。
​ 新生代 ( Young ) 与老年代 ( Old ) 的比例的值为 1:2 ( 该值可以通过参数 –XX:NewRatio 来指定 )
默认的，Eden : from : to = 8 : 1 : 1 ( 可以通过参数 –XX:SurvivorRatio 来设定 )，即： 空间利用率就是90%" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/72bc527d625ce99aea86ebe53a8d4e5f/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2020-12-10T22:43:42+08:00" />
<meta property="article:modified_time" content="2020-12-10T22:43:42+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">秋招面试知识点----JVM篇</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <h2><a id="1_0"></a>1.发生栈内存溢出。</h2> 
<p>描述栈定义，再描述为什么会溢出，再说明一下相关配置参数，OK的话可以给面试官手写是一个栈溢出的demo。</p> 
<ol><li>栈定义</li></ol> 
<ul><li>存放<strong>基本类型的变量数据和对象的引用</strong>，栈是<strong>线程私有</strong>的，他的生命周期与线程相同。每个方法在执行的时候都会创建一个栈帧，用来存储局部变量表，操作数栈，动态链接，方法出口等信息。<strong>每个方法从调用直至执行完成的过程，就对应着一个栈帧在虚拟机栈中入栈到出栈的过程。</strong></li></ul> 
<ol start="2"><li>为什么会溢出</li></ol> 
<ul><li>如果线程请求的栈深度大于虚拟机所允许的最大深度，就会抛出StackOverflowError异常。</li><li>如果虚拟机在扩展栈时无法申请足够的内存空间，就会抛出OutOfMemoryError异常。</li></ul> 
<ol start="3"><li>相关参数</li></ol> 
<ul><li>-Xss 调整JVM栈的大小</li></ul> 
<ol start="4"><li>栈溢出</li></ol> 
<ul><li> <p>无限递归，没有结束条件。</p> <pre><code class="prism language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">StackTest</span> <span class="token punctuation">{<!-- --></span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token function">main</span><span class="token punctuation">(</span>args<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> </li><li> <p>`</p> </li></ul> 
<h2><a id="2JVM_33"></a>2.详解JVM内存模型</h2> 
<p><strong>思路：</strong> 给面试官画一下JVM内存模型图，并描述每个模块的定义，作用，以及可能会存在的问题，如栈溢出等。</p> 
<p><img src="https://images2.imgbox.com/a3/13/d2Lw1p7x_o.png" alt="img"></p> 
<p>共享的，包括 <strong>Java 堆和方法区</strong>；</p> 
<p>私有的，包括<strong>虚拟机栈和本地方法栈，以及程序计数器</strong>这一小部分内存。</p> 
<p><strong>堆内存（Heap）</strong></p> 
<p>对于大多数应用来说，Java 堆（Java Heap）是Java 虚拟机所管理的内存中最大的一块。Java 堆是被所有线程共享的一块内存区域，在虚拟机启动时创建。</p> 
<p>此内存区域的<strong>唯一目的就是存放对象实例</strong>，几乎所有的对象实例都在这里分配内存。</p> 
<p>堆内存是所有线程共有的，可以分为两个部分：年轻代和老年代。</p> 
<p>下图中的Perm代表的是永久代，但是注意<strong>永久代并不属于堆内存中的一部分，同时jdk1.8之后永久代已经被移除。</strong></p> 
<p>​ <img src="https://images2.imgbox.com/d7/86/HKtS0TF0_o.png" alt="img"></p> 
<p><strong>新生代</strong> ( Young ) 与老年代 ( Old ) 的比例的值为 1:2 ( 该值可以通过参数 –XX:NewRatio 来指定 )</p> 
<p>默认的，<strong>Eden : from : to = 8 : 1 : 1</strong> ( 可以通过参数 –XX:SurvivorRatio 来设定 )，即： 空间利用率就是90%</p> 
<p><strong>方法区（Method Area）</strong></p> 
<p>方法区也称"<strong>永久代</strong>"，它用于存储虚拟机加载的<strong>类信息、常量、静态变量</strong>、是各个线程共享的内存区域。</p> 
<p>在JDK8之前的HotSpot JVM，存放这些”永久的”的区域叫做“永久代(permanent generation)”。永久代是一片连续的堆空间，在JVM启动之前通过在命令行设置参数**-XX:MaxPermSize**来设定永久代最大可分配的内存空间，默认大小是64M（64位JVM默认是85M）。</p> 
<p>随着JDK8的到来，JVM不再有 永久代(PermGen)。<strong>但类的元数据信息（metadata）还在</strong>，只不过不再是存储在连续的堆空间上，而是移动到叫做“Metaspace”的本地内存（Native memory。</p> 
<p><strong>虚拟机栈(JVM Stack)</strong></p> 
<p>描述的是java方法执行的内存模型：每个方法被执行的时候都会创建一个**“栈帧”<strong>,用于</strong>存储局部变量表(包括参数)、操作栈、方法出口等信息**。<strong>每个方法被调用到执行完的过程，就对应着一个栈帧在虚拟机栈中从入栈到出栈的过程。</strong></p> 
<p><strong>本地方法栈(Native Stack)</strong></p> 
<p>本地方法栈（Native Method Stacks）与虚拟机栈所发挥的作用是非常相似的，其区别不过是<strong>虚拟机栈为虚拟机执行Java方法（也就是字节码）服务</strong>，而<strong>本地方法栈则是为虚拟机使用到的Native方法服务。</strong></p> 
<p><strong>程序计数器（PC Register）</strong></p> 
<p>程序计数器是用于标识当<strong>前线程执行的字节码文件的行号指示器</strong>。多线程情况下，<strong>每个线程都具有各自独立的程序计数器</strong>，所以该区域是<strong>非线程共享</strong>的内存区域。</p> 
<p>当执行java方法时候，计数器中保存的是字节码文件的行号；当执行Native方法时，计数器的值为空。</p> 
<p>程序计数器主要有下面两个作用：</p> 
<ol><li>字节码解释器通过改变程序计数器来依次读取指令，从而实现代码的流程控制，如：顺序执行、选择、循环、异常处理。</li><li><strong>在多线程</strong>的情况下，程序计数器用于记录当前线程执行的位置，<strong>从而当线程被切换回来的时候能够知道该线程上次运行到哪儿了。</strong></li></ol> 
<p><strong>直接内存</strong></p> 
<p>直接内存并不是虚拟机内存的一部分，也不是Java虚拟机规范中定义的内存区域。jdk1.4中新加入的NIO，引入了通道与缓冲区的IO方式，它可以调用Native方法直接分配堆外内存，<strong>这个堆外内存就是本机内存，不会影响到堆内存的大小。</strong></p> 
<p><strong>JVM内存参数设置</strong></p> 
<p>​ <strong><img src="https://images2.imgbox.com/35/0e/kH2PQeoQ_o.png" alt="img"></strong></p> 
<ul><li>-Xms设置堆的最小空间大小。</li><li>-Xmx设置堆的最大空间大小。</li><li>-Xmn:设置年轻代大小</li><li>-XX:NewSize设置新生代最小空间大小。</li><li>-XX:MaxNewSize设置新生代最大空间大小。</li><li>-XX:PermSize设置永久代最小空间大小。</li><li>-XX:MaxPermSize设置永久代最大空间大小。</li><li>-Xss设置每个线程的堆栈大小</li><li>-XX:+UseParallelGC:选择垃圾收集器为并行收集器。此配置仅对年轻代有效。即上述配置下,年轻代使用并发收集,而年老代仍旧使用串行收集。</li><li>-XX:ParallelGCThreads=20:配置并行收集器的线程数,即:同时多少个线程一起进行垃圾回收。此值最好配置与处理器数目相等。</li></ul> 
<p>典型JVM参数配置参考:</p> 
<ul><li>java-Xmx3550m-Xms3550m-Xmn2g-Xss128k</li><li>-XX:ParallelGCThreads=20</li><li>-XX:+UseConcMarkSweepGC-XX:+UseParNewGC</li></ul> 
<p>-Xmx3550m:设置JVM最大可用内存为3550M。</p> 
<p>-Xms3550m:设置JVM促使内存为3550m。此值可以设置与-Xmx相同,以避免每次垃圾回收完成后JVM重新分配内存。</p> 
<p>-Xmn2g:设置年轻代大小为2G。整个堆大小=年轻代大小+年老代大小+持久代大小。持久代一般固定大小为64m,所以增大年轻代后,将会减小年老代大小。此值对系统性能影响较大,官方推荐配置为整个堆的3/8。</p> 
<p>-Xss128k:设置每个线程的堆栈大小。JDK5.0以后每个线程堆栈大小为1M,以前每个线程堆栈大小为256K。更具应用的线程所需内存大 小进行调整。在相同物理内存下,减小这个值能生成更多的线程。但是操作系统对一个进程内的线程数还是有限制的,不能无限生成,经验值在3000~5000 左右。</p> 
<h2><a id="3JVMEdenSurvivor_123"></a>3.JVM内存为什么要分成新生代，老年代，持久代。新生代中为什么要分为Eden和Survivor。</h2> 
<p><strong>思路：</strong> 先讲一下JAVA堆，新生代的划分，再谈谈它们之间的转化，相互之间一些参数的配置（如： –XX:NewRatio，–XX:SurvivorRatio等），再解释为什么要这样划分，最好加一点自己的理解。）共享内存区划分</p> 
<ol><li><strong>为什么要分为新生代和老年代？</strong></li></ol> 
<ul><li>因为有的对象寿命长，有的对象寿命短。应该将<strong>寿命长的对象放在一个区</strong>，寿命短的对象放在一个区。不同的区采用不同的垃圾收集算法。寿命短的区清理频次高一点，寿命长的区清理频次低一点。提高效率。</li></ul> 
<ol start="2"><li><strong>新生代中为什么要分为Eden和Survivor。</strong></li></ol> 
<ul><li>如果没有Survivor区，那么Eden每次满了清理垃圾，存活的对象被迁移到老年区，老年区满了，就会触发Full GC，Full GC是非常耗时的。当我们加上Survivor后，将Eden区满了的对象，添加到Survivor区，等对象反复清理几遍之后都没清理掉，再放到老年区，这样老年区的压力就会小很多。<strong>即Survivor相当于一个筛子，筛掉生命周期短的，将生命周期长的放到老年代区，减少老年代被清理的次数</strong>。</li></ul> 
<p>3.<strong>为什么要加两个Survivor？</strong></p> 
<ul><li>如果只有1个Survivor区，那当Eden区满了之后，就会复制对象到Survivor区，容易产生内存碎片化。严重影响性能。所以使用2个Survivor区，始终保持有一个空的Survivor区，可以避免内存碎片化。</li></ul> 
<h2><a id="3_141"></a>3.判断对象是否存活</h2> 
<p>· <strong>引用计数法</strong><br> 在一个对象被引用时加一，被去除引用时减一，这样我们就可以通过<strong>判断引用计数是否为零</strong>来判断一个对象是否为垃圾。这种方法我们一般称之为「引用计数法」。主流的Java虚拟机里面都没有选用引用计数算法来管理内存，因为这太浪费时间空间，计数器要好多，还有分配及空间，<strong>循环引用问题</strong>。</p> 
<p>· <strong>可达性分析算法</strong><br> 通过一系列名为**”GC Roots”**的对象作为起始点，从这些节点开始向下搜索，搜索所走过的路径称为引用链(Reference Chain)，<strong>当一个对象到GC Roots没有任何引用链相连时，则证明此对象是不会用的。</strong></p> 
<p>· GC Roots：<br> 虚拟机栈中引用的对象<br> 方法区静态属性引用的对象<br> 方法区常量引用的对象<br> JNI引用的对象（Native方法）</p> 
<h2><a id="4JVMGC_155"></a>4.JVM中一次完整的GC流程</h2> 
<p>思路： 先描述一下Java堆内存划分，再解释Minor GC，Major GC，full GC，描述它们之间转化流程。</p> 
<ul><li> <p>1.大多数情况下，<strong>对象在新生代Eden区进行分配</strong>。当Eden区没有足够的空间进行分配时，虚拟机将发起一次MinorGc。<strong>把eden，幸存区to都放到from</strong>。</p> </li><li> <p><strong>大对象</strong>（需要大量连续内存空间的Java对象，<strong>如那种很长的字符串</strong>）<strong>直接进入老年态</strong>；</p> </li><li> <p>如果对象在Eden出生，并经过第一次Minor GC后仍然存活，并且被Survivor容纳的话，<strong>年龄设为1</strong>，每熬过一次Minor GC，年龄+1，<strong>若年龄超过一定限制（15），则被晋升到老年态</strong>。即<strong>长期存活的对象进入老年态</strong>。</p> </li><li> <p>老年代满了而<strong>无法容纳更多的对象</strong>，Minor GC 之后通常就会进行Full GC，Full GC 清理整个内存堆 – <strong>包括年轻代和年老代</strong>。</p> </li><li> <p>如果老年代执行了Full GC之后发现依然无法进行对象的保存，就会产生**OOM异常“OutOfMemoryError”**然后就是开始调优，扩大堆内存，jprofier看看大对象。</p> </li></ul> 
<h2><a id="5cmsG1_171"></a>5.垃圾收集器cms和G1</h2> 
<p>思路： 一定要记住典型的垃圾收集器，尤其cms和G1，它们的原理与区别，涉及的垃圾回收算法。</p> 
<ol><li>垃圾回收器</li></ol> 
<ul><li> <p><strong>Serial收集器：</strong> 针对新生代的单线程收集器，使用复制算法。收集垃圾是会产生较长时间的停顿，但不会产生线程切换的开销</p> </li><li> <p><strong>Serial Old收集器：</strong> 针对老年代的单线程收集器，使用标记整理算法。</p> </li><li> <p><strong>Parallel Scavenge收集器：</strong> jdk 1.8默认的垃圾回收器。新生代回收器，采用复制算法，多线程并行回收，充分利用CPU资源。进行垃圾收集时，必须暂停所有工作线程，直到完成</p> </li><li> <p><strong>Parallel Old收集器：</strong> 是Parallel Scavenge收集器的老年代版本，使用多线程，标记-整理算法。</p> </li><li> <p><strong>ParNew收集器：</strong> Serial收集器的多线程版本，也需要stop the world，复制算法。</p> </li><li> <p><strong>CMS(Concurrent Mark Sweep) 收集器：</strong></p> </li><li> <p><strong>并发低停顿收集器</strong></p> </li><li> <p>开启就是个参数，同时开启parnew（新设代）cms（Old）serise(old)</p> </li><li> <p>使用标记清除算法</p> 
  <ul><li> <p>四个阶段</p> 
    <ul><li>初始标记 （标记<strong>GC Roots可以直接关联的对象</strong>，速度很快）</li><li>并发标记 （进行GC Roots Tracing，判断对象是否存活,不暂停）</li><li>重新标记 （校准并发标记对象的存活状态，并发标记又在运行，修正刚才的标记变化）</li><li>并发清除 （回收标记的对象）</li></ul> </li><li> <p><strong>初始标记和重新标记</strong>仍然需要Stop The World</p> </li><li> <p>优点：并发地停顿</p> </li><li> <p>CMS缺点</p> 
    <ul><li> <p>由于并发带来的CPU<strong>资源消耗</strong></p> </li><li> <p>由于并发收集在回收过程中产生的<strong>浮动垃圾</strong>无法清除</p> </li><li> <p>使用<strong>标记清除算法</strong>带来的空间碎片问题</p> </li><li> <p>万一没能在老年代用完时进行cms，就会用serise,停顿很高</p> </li></ul> </li></ul> </li><li> <p><strong>G1收集器：</strong></p> 
  <ul><li>在G1与其他收集器的区别就是它不再区分新生代或者老年代，它将整个Java堆划分为多个大小相等的独立区域(Region)，<strong>避免全内存的gc</strong>, 不是固定的，一会是老年，一会是新生代。 虽然还保留有新生代和老年代的概念，但新生代和老年代不再是物理隔离的了，就是GC还是分区的<strong>它们都是一部分Region（不需要连续）的集合</strong>，**打印的就是只有两块，regin，元空间。**用于服务端，像保证吞吐量，有尽可能减少停顿时间</li><li><strong>运作流程主要包括以下：</strong></li><li>**初始标记，**标记GC Roots可以直接关联的对象</li><li>**并发标记，**进行GC Roots Tracing，判断对象是否存活</li><li>**最终标记，**修正并发标记期间因程序继续运行导致标记产生变动的记录</li><li><strong>筛选标记</strong> 首先对各个Region 的回收价值和成本进行排序，根据用户所期望的G停顿时间来制定回收计划。</li></ul> </li><li> <p>收集实现：</p> 
  <ul><li>eden收集，满了就收集，主要是<strong>小范围的收集</strong>，连续的内存块，避免内存碎片</li><li><strong>eden移到幸存区</strong>，放不开，，eden直接阶变成老年代</li><li><strong>幸存区的收集</strong>，部分回到老年代</li><li>eden<strong>没东西了</strong>，gc结束</li></ul> </li></ul> 
<ol start="2"><li>CMS收集器和G1收集器的区别：</li></ol> 
<ul><li>CMS收集器是老年代的收集器，可以配合新生代和ParNew收集器一起使用，老年代的的Serialold；</li><li>G1收集器收集范围是老年代和新生代，<strong>不需要结合其他收集器使用</strong>；</li><li>CMS收集器以最小的停顿时间为目标的收集器；</li><li>G1收集器<strong>可预测垃圾回收的停顿时间</strong></li><li>CMS收集器是使用“标记-清除”算法进行的垃圾回收，容易产生<strong>内存碎片</strong></li><li>G1收集器使用的是“标记-整理”算法，进行了空间整合，降低了内存空间</li></ul> 
<p>相同：</p> 
<ul><li>都是可以并发</li></ul> 
<p>单cpu就是serice</p> 
<p>多cpu，吞吐量要求后台计算就是用parall4</p> 
<p>响应速度：cms，parallnew</p> 
<h2><a id="6_247"></a>6.什么是内存屏障</h2> 
<p><strong>内存屏障</strong>，也叫内存栅栏，是一种CPU指令，用于控制特定条件下的重排序和内存可见性问题。</p> 
<ul><li><strong>LoadLoad屏障</strong>：对于这样的语句Load1; LoadLoad; Load2，在Load2及后续读取操作要读取的数据被访问前，保证Load1要读取的数据被读取完毕。</li><li><strong>StoreStore屏障</strong>：对于这样的语句Store1; StoreStore; Store2，在Store2及后续写入操作执行前，保证Store1的写入操作对其它处理器可见。</li><li><strong>LoadStore屏障</strong>：对于这样的语句Load1; LoadStore; Store2，在Store2及后续写入操作被刷出前，保证Load1要读取的数据被读取完毕。</li><li><strong>StoreLoad屏障</strong>：对于这样的语句Store1; StoreLoad; Load2，在Load2及后续所有读取操作执行前，保证Store1的写入对所有处理器可见。它的开销是四种屏障中最大的。 在大多数处理器的实现中，这个屏障是个万能屏障，兼具其它三种内存屏障的功能。</li></ul> 
<h2><a id="7_256"></a>7.强引用、软引用、弱引用、虚引用的区别？</h2> 
<p>先说一下四种引用的定义，可以结合代码讲一下，也可以扩展谈到ThreadLocalMap里弱引用用处。</p> 
<p><strong>强引用</strong></p> 
<p>当内存不足的时候，JVM开始垃圾回收，对于强引用的对象，就算是出现了OOM也不会对该对象进行回收，打死也不回收~！</p> 
<p>强引用是我们最常见的普通对象引用，只要还有一个强引用指向一个对象，就能表明对象还“活着”，垃圾收集器不会碰这种对象。在Java中最常见的就是强引用，把一个对象赋给一个引用变量，这个引用变量就是一个强引用。当一个对象被强引用变量引用时，它处于可达状态，它是不可能被垃圾回收机制回收的，即使该对象以后永远都不会被用到，JVM也不会回收，因此强引用是造成Java内存泄漏的主要原因之一。</p> 
<p>对于一个普通的对象，如果没有其它的引用关系，只要超过了引用的作用于或者显示地将相应（强）引用赋值为null，一般可以认为就是可以被垃圾收集的了（当然具体回收时机还是要看垃圾回收策略）</p> 
<p>强引用小例子：</p> 
<pre><code class="prism language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ReferenceDemo</span> <span class="token punctuation">{<!-- --></span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token comment">// 这样定义的默认就是强应用</span>
        Object obj1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Object</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">// 使用第二个引用，指向刚刚创建的Object对象</span>
        Object obj2 <span class="token operator">=</span> obj1<span class="token punctuation">;</span>
        <span class="token comment">// 置空</span>
        obj1 <span class="token operator">=</span> null<span class="token punctuation">;</span>
        System<span class="token punctuation">.</span><span class="token function">gc</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>obj1<span class="token punctuation">)</span><span class="token punctuation">;</span>
        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>obj2<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

</code></pre> 
<pre><code class="prism language-java">null
java<span class="token punctuation">.</span>lang<span class="token punctuation">.</span>Object<span class="token annotation punctuation">@4554617c</span>
</code></pre> 
<p>输出结果我们能够发现，即使 obj1 被设置成了null，然后调用gc进行回收，但是也没有回收实例出来的对象，obj2还是能够指向该地址，也就是说垃圾回收器，并没有将该对象进行垃圾回收</p> 
<p><strong>软引用</strong></p> 
<p>软引用是一种相对弱化了一些的引用，需要用Java.lang.ref.SoftReference类来实现，可以让对象豁免一些垃圾收集，对于只有软引用的对象来讲：</p> 
<ul><li>当系统内存充足时，它不会被回收</li><li>当系统内存不足时，它会被回收</li></ul> 
<p>软引用通常在对内存敏感的程序中，比如高速缓存就用到了软引用，内存够用 的时候就保留，不够用就回收</p> 
<p>具体使用</p> 
<ol><li>在内存足够的时候</li></ol> 
<pre><code class="prism language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ReferenceDemo</span> <span class="token punctuation">{<!-- --></span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>

        <span class="token comment">// 这样定义的默认就是强应用</span>
        Object obj1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Object</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        Reference<span class="token generics function"><span class="token punctuation">&lt;</span>Object<span class="token punctuation">&gt;</span></span> reference<span class="token operator">=</span><span class="token keyword">new</span> <span class="token class-name">SoftReference</span><span class="token punctuation">(</span>obj1<span class="token punctuation">)</span><span class="token punctuation">;</span>
        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>obj1<span class="token punctuation">)</span><span class="token punctuation">;</span>
        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>reference<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"----------------------------------------------------------"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        obj1<span class="token operator">=</span>null<span class="token punctuation">;</span>
        <span class="token comment">// 模拟OOM自动GC</span>
        System<span class="token punctuation">.</span><span class="token function">gc</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>obj1<span class="token punctuation">)</span><span class="token punctuation">;</span>
        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>reference<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> 
<pre><code class="prism language-java">java<span class="token punctuation">.</span>lang<span class="token punctuation">.</span>Object<span class="token annotation punctuation">@4554617c</span>
java<span class="token punctuation">.</span>lang<span class="token punctuation">.</span>Object<span class="token annotation punctuation">@4554617c</span>
null
java<span class="token punctuation">.</span>lang<span class="token punctuation">.</span>Object<span class="token annotation punctuation">@4554617c</span>
</code></pre> 
<ol start="2"><li>内存不足的时候</li></ol> 
<p>JVM配置，故意产生大对象并配置小的内存，让它的内存不够用了导致OOM，看软引用的回收情况<br> -Xms5m -Xmx5m -XX:+PrintGCDetails</p> 
<pre><code class="prism language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ReferenceDemo</span> <span class="token punctuation">{<!-- --></span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>

        <span class="token comment">// 这样定义的默认就是强应用</span>
        Object obj1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Object</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        Reference<span class="token generics function"><span class="token punctuation">&lt;</span>Object<span class="token punctuation">&gt;</span></span> reference<span class="token operator">=</span><span class="token keyword">new</span> <span class="token class-name">SoftReference</span><span class="token punctuation">(</span>obj1<span class="token punctuation">)</span><span class="token punctuation">;</span>
        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>obj1<span class="token punctuation">)</span><span class="token punctuation">;</span>
        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>reference<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"----------------------------------------------------------"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        obj1<span class="token operator">=</span>null<span class="token punctuation">;</span>
        <span class="token keyword">try</span> <span class="token punctuation">{<!-- --></span>
            <span class="token comment">// 创建30M的大对象</span>
            <span class="token keyword">byte</span><span class="token punctuation">[</span><span class="token punctuation">]</span> bytes <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">byte</span><span class="token punctuation">[</span><span class="token number">30</span> <span class="token operator">*</span> <span class="token number">1024</span> <span class="token operator">*</span> <span class="token number">1024</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Exception</span> e<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
            e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{<!-- --></span>
            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>obj1<span class="token punctuation">)</span><span class="token punctuation">;</span>
            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>reference<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

</code></pre> 
<p>我们写了两个方法，一个是内存够用的时候，一个是内存不够用的时候。<br> 我们首先查看内存够用的时候，首先输出的是 o1 和 软引用的 softReference，我们都能够看到值。然后我们把o1设置为null，执行手动GC后，我们发现softReference的值还存在，说明内存充足的时候，软引用的对象不会被回收。</p> 
<p>当内存不够的时候，我们使用了JVM启动参数配置，给初始化堆内存为5M，但是在创建对象的时候，我们创建了一个30M的大对象。<br> 这就必然会触发垃圾回收机制，这也是中间出现的垃圾回收过程，最后看结果我们发现，o1 和 softReference都被回收了，因此说明，软引用在内存不足的时候，会自动回收。</p> 
<p><strong>弱引用</strong></p> 
<p>不管内存是否够，只要有GC操作就会进行回收</p> 
<p>弱引用需要用 ==java.lang.ref.WeakReference`==类来实现，它比软引用生存期更短</p> 
<p>对于只有弱引用的对象来说，只要垃圾回收机制一运行，不管JVM的内存空间是否足够，都会回收该对象占用的空间。</p> 
<pre><code class="prism language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ReferenceDemo</span> <span class="token punctuation">{<!-- --></span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>

        Object obj <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Object</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        Reference<span class="token generics function"><span class="token punctuation">&lt;</span>Object<span class="token punctuation">&gt;</span></span> reference <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">WeakReference</span><span class="token operator">&lt;</span><span class="token operator">&gt;</span><span class="token punctuation">(</span>obj<span class="token punctuation">)</span><span class="token punctuation">;</span>
        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>obj<span class="token punctuation">)</span><span class="token punctuation">;</span>
        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>reference<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"-----------------------------"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        obj<span class="token operator">=</span>null<span class="token punctuation">;</span>
        System<span class="token punctuation">.</span><span class="token function">gc</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>obj<span class="token punctuation">)</span><span class="token punctuation">;</span>
        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>reference<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

</code></pre> 
<pre><code class="prism language-java">java<span class="token punctuation">.</span>lang<span class="token punctuation">.</span>Object<span class="token annotation punctuation">@4554617c</span>
java<span class="token punctuation">.</span>lang<span class="token punctuation">.</span>Object<span class="token annotation punctuation">@4554617c</span>
<span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">-</span>
null
null
</code></pre> 
<p>我们看结果，能够发现，我们并没有制造出OOM内存溢出，而只是调用了一下GC操作，垃圾回收就把它给收集了</p> 
<p><strong>WeakHashMap是什么？</strong></p> 
<p>WeakHashMap和HashMap类似，只不过它的Key是使用了弱引用的，也就是说，当执行GC的时候，HashMap中的key会进行回收，下面我们使用例子来测试一下<br> 我们输入一个Key-Value键值对，然后让它的key置空，然后在查看结果</p> 
<pre><code class="prism language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">WeakHashMapDemo</span> <span class="token punctuation">{<!-- --></span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token function">myHashMap</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"=========="</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">myWeakHashMap</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">myHashMap</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        Map<span class="token generics function"><span class="token punctuation">&lt;</span>Integer<span class="token punctuation">,</span> String<span class="token punctuation">&gt;</span></span> map <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HashMap</span><span class="token operator">&lt;</span><span class="token operator">&gt;</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        Integer key <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Integer</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        String value <span class="token operator">=</span> <span class="token string">"HashMap"</span><span class="token punctuation">;</span>

        map<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span> value<span class="token punctuation">)</span><span class="token punctuation">;</span>
        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>map<span class="token punctuation">)</span><span class="token punctuation">;</span>

        key <span class="token operator">=</span> null<span class="token punctuation">;</span>

        System<span class="token punctuation">.</span><span class="token function">gc</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>map<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">myWeakHashMap</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        Map<span class="token generics function"><span class="token punctuation">&lt;</span>Integer<span class="token punctuation">,</span> String<span class="token punctuation">&gt;</span></span> map <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">WeakHashMap</span><span class="token operator">&lt;</span><span class="token operator">&gt;</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        Integer key <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Integer</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        String value <span class="token operator">=</span> <span class="token string">"WeakHashMap"</span><span class="token punctuation">;</span>

        map<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span> value<span class="token punctuation">)</span><span class="token punctuation">;</span>
        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>map<span class="token punctuation">)</span><span class="token punctuation">;</span>

        key <span class="token operator">=</span> null<span class="token punctuation">;</span>

        System<span class="token punctuation">.</span><span class="token function">gc</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>map<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>最后输出结果为：</p> 
<pre><code class="prism language-java"><span class="token punctuation">{<!-- --></span><span class="token number">1</span><span class="token operator">=</span>HashMap<span class="token punctuation">}</span>
<span class="token punctuation">{<!-- --></span><span class="token number">1</span><span class="token operator">=</span>HashMap<span class="token punctuation">}</span>
<span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span>
<span class="token punctuation">{<!-- --></span><span class="token number">1</span><span class="token operator">=</span>WeakHashMap<span class="token punctuation">}</span>
<span class="token punctuation">{<!-- --></span><span class="token punctuation">}</span>
</code></pre> 
<p>从这里我们看到，对于普通的HashMap来说，key置空并不会影响，HashMap的键值对，因为这个属于强引用，不会被垃圾回收。</p> 
<p>但是WeakHashMap，在进行GC操作后，弱引用的就会被回收</p> 
<p><strong>虚引用</strong></p> 
<p><strong>概念</strong></p> 
<p>虚引用又称为幽灵引用，需要<mark>java.lang.ref.PhantomReference</mark> 类来实现</p> 
<p>顾名思义，就是形同虚设，与其他几种引用都不同，虚引用并不会决定对象的生命周期。</p> 
<p>如果一个对象持有虚引用，那么它就和没有任何引用一样，在任何时候都可能被垃圾回收器回收，它不能单独使用也不能通过它访问对象，虚引用必须和引用队列ReferenceQueue联合使用。</p> 
<p>虚引用的主要作用和跟踪对象被垃圾回收的状态，仅仅是提供一种确保对象被finalize以后，做某些事情的机制。</p> 
<p>PhantomReference的get方法总是返回null，因此无法访问对象的引用对象。其意义在于说明一个对象已经进入finalization阶段，可以被gc回收，用来实现比finalization机制更灵活的回收操作</p> 
<p>换句话说，设置虚引用关联的唯一目的，就是在这个对象被收集器回收的时候，收到一个系统通知或者后续添加进一步的处理，Java技术允许使用finalize()方法在垃圾收集器将对象从内存中清除出去之前，做必要的清理工作</p> 
<p>这个就相当于Spring AOP里面的后置通知</p> 
<h2><a id="8_484"></a>8.对象创建过程</h2> 
<p><strong>第一次使用</strong><br> <strong>1.进行判断</strong><br> java在new一个对象的时候，会先查看<strong>对象所属的类有没有被加载到内存</strong>，如果没有的话，就会先通过类的全限定名来加载。加载并初始化类完成后，再进行对象的创建工作。</p> 
<p>分为<strong>加载并初始化类</strong>和<strong>创建对象</strong></p> 
<p><strong>2.加载并初始化类</strong></p> 
<p>java是使用<strong>双亲委派模型</strong>来进行类的加载的，所以在描述类加载过程前，我们先看一下它的工作过程：<br> 双亲委托模型的工作过程是：如果一个类加载器（ClassLoader）收到了类加载的请求，<strong>它首先不会自己去尝试加载这个类，而是把这个请求委托给父类加载器去完成</strong>，每一个层次的类加载器都是如此，因此所有的加载请求最终都应该传送到顶层的启动类加载器中，只有当父类加载器反馈自己无法完成这个加载请求（它的搜索范围中没有找到所需要加载的类）时，子加载器才会尝试自己去加载。<br> 使用双亲委托机制的好处是：能够有效确保一个类的全局唯一性，当程序中出现多个限定名相同的类时，类加载器在执行加载时，<strong>始终只会加载其中的某一个类，并且不会重写String这种基层类。</strong><br> <strong>2. 验证</strong></p> 
<p><strong>格式验证</strong>：验证是否符合class文件规范<br> <strong>语义验证</strong>：检查一个被标记为final的类型是否包含子类；检查一个类中的final方法是否被子类进行重写；确保父类和子类之间没有不兼容的一些方法声明（比如方法签名相同，但方法的返回值不同）<br> <strong>操作验证</strong>：在操作数栈中的数据必须进行正确的操作，对常量池中的各种符号引用执行验证（通常在解析阶段执行，检查是否可以通过符号引用中描述的全限定名定位到指定类型上，以及类成员信息的访问修饰符是否允许访问等）<br> <strong>3. 准备</strong><br> 为类中的所有<strong>静态变量分配内存空间，并为其设置一个初始值</strong>（由于还没有产生对象，实例变量不在此操作范围内）<br> 被final修饰的static变量（常量），会直接赋值；<br> <strong>4. 解析</strong><br> **将常量池中的符号引用转为直接引用（**得到类或者字段、方法在内存中的指针或者偏移量，以便直接调用该方法），这个可以在初始化之后再执行。直接指向目标的指针、相对偏移量或是一个能间接定位到目标的句柄<br> <strong>解析需要静态绑定的内容。 // 所有不会被重写的方法和域都会被静态绑定</strong><br> <strong>5. 初始化（先父后子）</strong></p> 
<ul><li>为<strong>静态变量赋值</strong></li><li><strong>执行static代码块</strong><br> <strong>注意：static代码块只有jvm能够调用</strong><br> 　　　**如果是多线程需要同时初始化一个类，仅仅只能允许其中一个线程对其执行初始化操作，**其余线程必须等待，只有在活动线程执行完对类的初始化操作之后，才会通知正在等待的其他线程。</li></ul> 
<p><strong>因为子类存在对父类的依赖，所以类的加载顺序是先加载父类后加载子类，初始化也一样。不过，父类初始化时，子类静态变量的值也有有的，是默认值</strong>。<br> 最终，方法区会存储当前类类信息，包括类的静态变量、类初始化代码（定义静态变量时的赋值语句 和 静态初始化代码块）、实例变量定义、实例初始化代码（定义实例变量时的赋值语句实例代码块和构造方法）和实例方法，还有父类的类信息引用。</p> 
<p><strong>3.创建对象</strong></p> 
<ul><li><strong>1.在堆区分配对象需要的内存</strong><br> 分配的内存包括本类和父类的所有实例变量，但不包括任何静态变量</li><li><strong>2.对所有实例变量赋默认值</strong><br> 将方法区内对实例变量的定义拷贝一份到堆区，<strong>然后赋默认值</strong></li><li><strong>3.执行实例初始化代码</strong><br> <strong>1.初始化顺序是先初始化父类再初始化子类</strong>，<strong>2.初始化时先执行实例代码块然后是构造方法</strong></li><li><strong>4.如果有类似于Child c = new Child()形式的c引用的话</strong>，在栈区定义Child类型引用变量c，<strong>然后将堆区对象的地址赋值给它</strong></li><li>注意，dcl单例就是要volital,防止2，3步指令重排，DCL，DoubleCheckLock双重检查</li></ul> 
<h2><a id="9_529"></a>9.为对象分配内存的方式</h2> 
<p><strong>指针碰撞空闲列表</strong></p> 
<ul><li> <p>虚拟机遇到一条new指令时，首先将去检查这个指令的参数是否能在常量池中定位到一个类的符号引用，并且检查这个符号引用代表的类是否已被加载、解析和初始化过。如果没有，那必须先执行相应的类加载过程。</p> <p>在类加载检查通过后，接下来虚拟机将为新生对象分配内存。对象所需内存的大小在类加载完成后便可完全确定，为对象分配空间的任务等同于把一块确定大小的内存从Java堆中划分出来。假设Java堆中内存是绝对规整的，所有用过的内存都放在一边，空闲的内存放在另一边，中间放着一个指针作为分界点的指示器，那所分配内存就仅仅是把那个指针向空闲空间那边挪动一段与对象大小相等的距离，这种分配方式称为“指针碰撞”（Bump thePointer）。如果Java堆中的内存并不是规整的，已使用的内存和空闲的内存相互交错，那就没有办法简单地进行指针碰撞了，虚拟机就必须维护一个列表，记录上哪些内存块是可用的，在分配的时候从列表中找到一块足够大的空间划分给对象实例，并更新列表上的记录，这种分配方式称为“空闲列表”（FreeList）。选择哪种分配方式由Java堆是否规整决定，而Java堆是否规整又由所采用的垃圾收集器是否带有压缩整理功能决定。因此，在使用Serial、ParNew等带Compact过程的收集器时，系统采用的分配算法是指针碰撞，而使用CMS这种基于Mark-Sweep算法的收集器时，通常采用空闲列表。</p> <p><img src="https://images2.imgbox.com/ed/29/UjA18shS_o.png" alt="img"></p> </li></ul> 
<p><img src="https://images2.imgbox.com/c0/9c/nGiyDd24_o.png" alt="img"></p> 
<p>1.tlab，阻塞锁的地方，减少冲突</p> 
<h2><a id="10__JVM__545"></a>10 说一下 JVM 有哪些垃圾回收算法？</h2> 
<p><strong>1.复制算法</strong></p> 
<p>缺点：<strong>不会产生空间碎片，但内存折半</strong></p> 
<ul><li>复制算法的核心就是，将原有的内存空间一分为二，每次只用其中的一块，在垃圾回收时，<strong>将正在使用的对象复制 到另一个内存空间中</strong>，然后将该内存空间清空，交换两个内存的角色，完成垃圾的回收。两个幸村区就是因为这个。</li><li>如果内存中的<strong>垃圾对象较多，需要复制的对象就较少</strong>，这种情况下适合使用该方式并且效率比较高，反之，则不适合</li><li>例如：在GC开始的时候，对象只会存在于Eden区和名为“From”的Survivor区，Survivor区“To”是空的。<br> 紧接着进行GC，在“From”区中，仍存活的对象会根据他们的年龄值来决定去向。年龄达到一定值(年龄阈值，可以通过-XX:MaxTenuringThreshold来设置)的对象会被移 动到年老代中，<strong>没有达到阈值的对象会被复制到“To”区域。</strong><br> 经过这次GC后，Eden区和From区已经被清空。这个时候，“From”和“To”会交换他们的角色，也就是新 的“To”就是上次GC前的“From”，新的“From”就是上次GC前的“To”。不管怎样，<strong>都会保证名为To的Survivor区 域是空的。</strong><br> GC会一直重复这样的过程，直到“To”区被填满，“To”区被填满之后，会将所有对象移动到年老代中。</li></ul> 
<p><strong>2.标记清除法</strong></p> 
<p>标记清除算法，是将垃圾回收分为2个阶段，<strong>分别是标记和清除。</strong><br> 标记：从根节点开始标记引用的对象。<br> 清除：<strong>未被标记引用的对象就是垃圾对象</strong>，可以被清理。<br> <strong>产生碎片</strong>，遍历两边</p> 
<p><strong>3.标记压缩算法</strong></p> 
<p>标记压缩算法是在标记清除算法的基础之上，做了优化改进的算法。和标记清除算法一样，也是从根节点开始，对对象的引用进行标记，在清理阶段，并不是简单的清理未标记的对象，<strong>而是将存活的对象压缩到内存的一端，然后 清理边界以外的垃圾，从而解决了碎片化的问题。</strong></p> 
<p>又边理了一遍</p> 
<p><strong>4.分代算法</strong></p> 
<p>前面介绍了多种回收算法，每一种算法都有自己的优点也有缺点，谁都不能替代谁，所以根据垃圾回收对象的特点 进行选择，才是明智的选择。<br> 分代算法其实就是这样的，根据回收对象的特点进行选择**，在jvm中，年轻代适合使用复制算法，老年代适合使用 标记清除或标记压缩算法。**</p> 
<p><strong>5.hotspot：枚举根节点</strong></p> 
<p>可达性分析就是找Gcroot节点引用的操作，但是可达性分析要寻找全局性的引用，执行上下文，就是站真的本地变量表，印用太多了，消耗时间，而且会有GC停顿，<strong>就是对象之间的引用是不能改变的</strong>，所以会停止所有的线程这就是“stop world”，cms在枚举根节点时也会停顿</p> 
<p>所以就有了oop MAp，知道那存放着对象，直接扫描这东西将快速准去的完成GC root的枚举，可能会导致引用关系变化，或是说oopmap的变换子陵非常多，为了节约成本，只在特定安全点设置了oopmap</p> 
<h2><a id="11_582"></a>11.调优命令</h2> 
<p><strong>我用过的</strong></p> 
<p>//-xss 1m -Xmx8m -XX:+HeapDumpOnOutOfMemoryError</p> 
<p>//-Xms 1m 初始化内存分配 默认内存的1/64</p> 
<p>//-Xmx 8m 最大分配内存 默认1/4</p> 
<p>//-XX:+PrintGCDetails //打印具体信息</p> 
<p>//-XX:+HeapDumpOnOutOfMemoryError //oom 下载Dump文件</p> 
<p>-XX:SurvivorRatio 8：1：1</p> 
<p>newRatio 1：2</p> 
<pre><code>jstat -gc 19570 就是幸存区总大小，已用
</code></pre> 
<p>jsp -l</p> 
<p>命令 jinfo -flags pid</p> 
<p>-Xms20m Java堆初始容量<br> -Xmx20m Java堆最大容量<br> -Xmn10m Java堆年轻代大小<br> -XX:+PrintGCDetails 打印GC信息</p> 
<p>-XX:+PrintGCDateStamps 打印GC时间<br> -XX:SurvivorRatio=8 n:年轻代中Eden区与两个Survivor区的比值。注意Survivor区有两个。如8，表示Eden：Survivor=8：2，一个Survivor区占整个年轻代的1/10<br> -XX:+HeapDumpOnOutOfMemoryError<br> -XX:HeapDumpPath=D:/logs</p> 
<p><strong>jps [options] [hostid]</strong></p> 
<p><strong>options</strong>参数解释：<br> <strong>-l</strong> : <strong>输出主类全名或jar路径</strong>**<br> <strong>-q</strong> : <strong>只输出LVMID</strong><br> <strong>-m</strong> :输出JVM启动时传递给main()的参数<br> <strong>-v</strong> : <strong>输出JVM启动时显示指定的JVM参数</strong></p> 
<h3><a id="jinfo_626"></a>jinfo命令</h3> 
<p><strong>options</strong></p> 
<p>-flag**** **打印指定名称的参数<br> -flag [+|-]打开或关闭参数<br> -flag =设置参数<br> -flags打印所有参数<br> -sysprops：打印系统配置<br> <strong>打印上面两个选项</strong></p> 
<p>查看 JVM 参数</p> 
<p><strong>jstat [option] LVMID [interval] [count]</strong></p> 
<p><strong>jstack</strong>命令主要用来查看Java线程的调用堆栈的，可以用来分析线程问题（如死锁）。</p> 
<p><strong>线程状态</strong><br> 想要通过jstack命令来分析线程的情况的话，首先要知道线程都有哪些状态，下面这些状态是我们使用jstack命令查看线程堆栈信息时可能会看到的线程的几种状态：</p> 
<p><strong>top -HP 22877</strong> <strong>找出此进程中cpu最高得线程</strong></p> 
<p><strong>jmap -histo:live pid&gt;a.log</strong><br> 可以观察heap中所有对象的情况（heap中所有生存的对象的情况）。包括对象数量和所占空间大小。 可以将其保存到文本中去，在一段时间后，使用文本对比工具，可以对比出GC回收了哪些对象。</p> 
<p><strong>jmap -dump:live,format=b,file=a.log pid</strong><br> 说明：内存信息dump到a.log文件中。</p> 
<p>这个命令执行，JVM会将整个heap的信息dump写入到一个文件，heap如果比较大的话，就会导致这个过程比较耗时，并且执行的过程中为了保证dump的信息是可靠的，所以会暂停应用。</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/c18e2cefd86647d42e2a85d5de3e2547/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">伪元素before、after和定位</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/c08d7c389b373bdfb6c582326c2e47af/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">秋招面试知识点----框架篇</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>