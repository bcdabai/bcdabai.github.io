<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>QT 之TCP网络编程（非常值得看的一篇博客！） - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="QT 之TCP网络编程（非常值得看的一篇博客！）" />
<meta property="og:description" content="首先介绍一下TCP：（Transmission Control Protocol 传输控制协议）是一种面向连接的、可靠的、基于字节流的传输层通信协议。相比而言UDP，就是开放式、无连接、不可靠的传输层通信协议。 下面，我一次进行客户端和服务器端的QT实现。我的开发环境是：QT Creator 5.7。 先看下效果图： 一：客户端编程
QT提供了QTcpSocket类，可以直接实例化一个客户端，可在help中索引如下：
The QTcpSocket class provides a TCP socket. More... Header #include &lt;QTcpSocket&gt; qmake QT &#43;= network Inherits: QAbstractSocket Inherited By: QSslSocket 从这里，我们可以看到，必须要在.pro文件中添加QT &#43;= network才可以进行网络编程，否则是访问不到&lt;QTcpSocket&gt;头文件的。 客户端读写相对简单，我们看一下代码头文件： #ifndef MYTCPCLIENT_H #define MYTCPCLIENT_H #include &lt;QMainWindow&gt; #include &lt;QTcpSocket&gt; #include &lt;QHostAddress&gt; #include &lt;QMessageBox&gt; namespace Ui { class MyTcpClient; } class MyTcpClient : public QMainWindow { Q_OBJECT public: explicit MyTcpClient(QWidget *parent = 0); ~MyTcpClient(); private: Ui::MyTcpClient *ui; QTcpSocket *tcpClient; private slots: //客户端槽函数 void ReadData(); void ReadError(QAbstractSocket::SocketError); void on_btnConnect_clicked(); void on_btnSend_clicked(); void on_pushButton_clicked(); }; #endif // MYTCPCLIENT_H 我们在窗口类中，定义了一个私有成员QTcpSoket *tcpClient。 1) 初始化QTcpSocket 在构造函数中，我们需要先对其进行实例化，并连接信号与槽函数：" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/63c9fb7624b2dd976ccfe878dfb10225/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2018-05-19T19:26:06+08:00" />
<meta property="article:modified_time" content="2018-05-19T19:26:06+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">QT 之TCP网络编程（非常值得看的一篇博客！）</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <pre class="prettyprint"><code>首先介绍一下TCP：（Transmission Control Protocol 传输控制协议）是一种面向连接的、可靠的、基于字节流的传输层通信协议。相比而言UDP，就是开放式、无连接、不可靠的传输层通信协议。
下面，我一次进行客户端和服务器端的QT实现。我的开发环境是：QT Creator 5.7。</code></pre> 
<p>先看下效果图： <br><img alt="one server---two clients" class="has" src="https://images2.imgbox.com/54/b3/ZHXMUofy_o.jpg"></p> 
<p><strong>一：客户端编程</strong></p> 
<p>QT提供了QTcpSocket类，可以直接实例化一个客户端，可在help中索引如下：</p> 
<pre class="prettyprint"><code><span style="color:#ff9966;">The QTcpSocket class provides a TCP socket. More...
Header      #include &lt;QTcpSocket&gt; 
qmake       QT += network
Inherits:   QAbstractSocket
Inherited By:   QSslSocket</span></code></pre> 
<pre class="prettyprint"><code>从这里，我们可以看到，必须要在.pro文件中添加QT += network才可以进行网络编程，否则是访问不到&lt;QTcpSocket&gt;头文件的。

客户端读写相对简单，我们看一下代码头文件：</code></pre> 
<pre class="prettyprint"><code>#ifndef MYTCPCLIENT_H
#define MYTCPCLIENT_H

#include &lt;QMainWindow&gt;
#include &lt;QTcpSocket&gt;
#include &lt;QHostAddress&gt;
#include &lt;QMessageBox&gt;
namespace Ui {
class MyTcpClient;
}

class MyTcpClient : public QMainWindow
{
    Q_OBJECT

public:
    explicit MyTcpClient(QWidget *parent = 0);
    ~MyTcpClient();

private:
    Ui::MyTcpClient *ui;
    QTcpSocket *tcpClient;

private slots:
    //客户端槽函数
    void ReadData();
    void ReadError(QAbstractSocket::SocketError);

    void on_btnConnect_clicked();
    void on_btnSend_clicked();
    void on_pushButton_clicked();
};

#endif // MYTCPCLIENT_H</code></pre> 
<ul><li> </li></ul> 
<pre class="prettyprint"><code>我们在窗口类中，定义了一个私有成员QTcpSoket *tcpClient。</code></pre> 
<p><strong>1) 初始化QTcpSocket</strong> <br> 在构造函数中，我们需要先对其进行实例化，并连接信号与槽函数：</p> 
<pre class="prettyprint"><code>    //初始化TCP客户端
    tcpClient = new QTcpSocket(this);   //实例化tcpClient
    tcpClient-&gt;abort();                 //取消原有连接
    connect(tcpClient, SIGNAL(readyRead()), this, SLOT(ReadData()));
    connect(tcpClient, SIGNAL(error(QAbstractSocket::SocketError)), \
            this, SLOT(ReadError(QAbstractSocket::SocketError)));</code></pre> 
<ul><li> </li></ul> 
<p><strong>2）建立连接 和 断开连接</strong></p> 
<pre class="prettyprint"><code>    tcpClient-&gt;connectToHost(ui-&gt;edtIP-&gt;text(), ui-&gt;edtPort-&gt;text().toInt());
    if (tcpClient-&gt;waitForConnected(1000))  // 连接成功则进入if{}
    {
        ui-&gt;btnConnect-&gt;setText("断开");
        ui-&gt;btnSend-&gt;setEnabled(true);
    }</code></pre> 
<ul><li>1</li><li>2</li><li>3</li><li>4</li><li>5</li><li>6</li></ul> 
<pre class="prettyprint"><code>a）建立TCP连接的函数：void connectToHost(const QHostAddress &amp;address, quint16 port, OpenMode openMode = ReadWrite)是从QAbstractSocket继承下来的public function，同时它又是一个virtual function。作用为：Attempts to make a connection to address on port port。
b）等待TCP连接成功的函数：bool waitForConnected(int msecs = 30000)同样是从QAbstractSocket继承下来的public function，同时它又是一个virtual function。作用为：Waits until the socket is connected, up to msecs milliseconds. If the connection has been established, this function returns true; otherwise it returns false. In the case where it returns false, you can call error() to determine the cause of the error.

上述代码中，edtIP, edtPort是ui上的两个lineEditor，用来填写服务器IP和端口号。btnConnect是“连接/断开”复用按钮，btnSend是向服务器发送数据的按钮，只有连接建立之后，才将其setEnabled。</code></pre> 
<pre class="prettyprint"><code>        tcpClient-&gt;disconnectFromHost();
        if (tcpClient-&gt;state() == QAbstractSocket::UnconnectedState \
                || tcpClient-&gt;waitForDisconnected(1000))  //已断开连接则进入if{}
        {
            ui-&gt;btnConnect-&gt;setText("连接");
            ui-&gt;btnSend-&gt;setEnabled(false);
        }</code></pre> 
<pre class="prettyprint"><code>a）断开TCP连接的函数：void disconnectFromHost()是从QAbstractSocket继承的public function，同时它又是一个virtual function。作用为：Attempts to close the socket. If there is pending data waiting to be written, QAbstractSocket will enter ClosingState and wait until all data has been written. Eventually, it will enter UnconnectedState and emit the disconnected() signal.
b）等待TCP断开连接函数：bool waitForDisconnected(int msecs = 30000)，同样是从QAbstractSocket继承下来的public function，同时它又是一个virtual function。作用为：Waits until the socket has disconnected, up to msecs milliseconds. If the connection has been disconnected, this function returns true; otherwise it returns false. In the case where it returns false, you can call error() to determine the cause of the error.</code></pre> 
<p><strong>3)读取服务器发送过来的数据</strong> <br> readyRead()是QTcpSocket从父类QIODevice中继承下来的信号：This signal is emitted once every time new data is available for reading from the device’s current read channel。 <br> readyRead()对应的槽函数为：</p> 
<pre class="prettyprint"><code>void MyTcpClient::ReadData()
{
    QByteArray buffer = tcpClient-&gt;readAll();
    if(!buffer.isEmpty())
    {
        ui-&gt;edtRecv-&gt;append(buffer);
    }
}</code></pre> 
<ul><li> </li></ul> 
<pre class="prettyprint"><code>readAll()是QTcpSocket从QIODevice继承的public function，直接调用就可以读取从服务器发过来的数据了。我这里面把数据显示在textEditor控件上（ui&gt;edtRecv）。由此完成了读操作。
error(QAbstractSocket::SocketError)是QTcpSocket从QAbstractSocket继承的signal， This signal is emitted after an error occurred. The socketError parameter describes the type of error that occurred.连接到的槽函数定义为：</code></pre> 
<pre class="prettyprint"><code>void MyTcpClient::ReadError(QAbstractSocket::SocketError)
{
    tcpClient-&gt;disconnectFromHost();
    ui-&gt;btnConnect-&gt;setText(tr("连接"));
    QMessageBox msgBox;
    msgBox.setText(tr("failed to connect server because %1").arg(tcpClient-&gt;errorString()));
xec();
}</code></pre> 
<ul><li> </li></ul> 
<pre class="prettyprint"><code>这段函数的作用是：当错误发生时，首先断开TCP连接，再用QMessageBox提示出errorString，即错误原因。</code></pre> 
<p><strong>4）向服务器发送数据</strong></p> 
<pre class="prettyprint"><code>    QString data = ui-&gt;edtSend-&gt;toPlainText();
    if(data != "")
    {
        tcpClient-&gt;write(data.toLatin1()); //qt5去除了.toAscii()
    }</code></pre> 
<pre class="prettyprint"><code>定义一个QString变量，从textEditor(edtSend)中获取带发送数据，write()是QTcpSocket从QIODevice继承的public function，直接调用就可以向服务器发送数据了。这里需要注意的是：toAscii()到qt5就没有了，这里要写成toLatin1()。</code></pre> 
<p>至此，通过4步，我们就完成了TCP Client的程序开发，源码下载地址：<a href="https://raw.githubusercontent.com/chenpengxin/TCP-Tools/master/MyTcpClient.rar" rel="nofollow">客户端qt程序源码</a></p> 
<p><strong>二：服务器端编程</strong> <br> 服务器段编程相比于客户端要繁琐一些，因为对于客户端来说，只能连接一个服务器。而对于服务器来说，它是面向多连接的，如何协调处理多客户端连接就显得尤为重要。 <br> 前言：编程过程中遇到的问题 和 解决的方法 <br> 遇到的问题：每个新加入的客户端，服务器给其分配一个SocketDescriptor后，就会emit newConnection()信号，但分配好的SocketDecriptor并没有通过newConnection()信号传递，所以用户得不到这个客户端标识SocketDescriptor。同样的，每当服务器收到新的消息时，客户端会emit readReady()信号，然而readReady()信号也没有传递SocketDescriptor， 这样的话，服务器端即使接收到消息，也不知道这个消息是从哪个客户端发出的。</p> 
<p>解决的方法： <br> 1. 通过重写[virtual protected] void QTcpServer::incomingConnection(qintptr socketDescriptor)，获取soketDescriptor。自定义TcpClient类继承QTcpSocket，并将获得的soketDescriptor作为类成员。 这个方法的优点是：可以获取到soketDescriptor，灵活性高。缺点是：需要重写函数、自定义类。 <br> 2. 在newConnection()信号对应的槽函数中，通过QTcpSocket *QTcpServer::nextPendingConnection()函数获取 新连接的客户端：Returns the next pending connection as a connected QTcpSocket object. 虽然仍然得不到soketDescriptor，但可以通过QTcpSocket类的peerAddress()和peerPort()成员函数获取客户端的IP和端口号，同样是唯一标识。 优点：无需重写函数和自定义类，代码简洁。缺点：无法获得SocketDecriptor，灵活性差。</p> 
<p>本文介绍第二种方法：</p> 
<p>QT提供了QTcpServer类，可以直接实例化一个客户端，可在help中索引如下：</p> 
<pre class="prettyprint"><code>The QTcpServer class provides a TCP-based server. More...
Header:     #include &lt;QTcpServer&gt; 
qmake:      QT += network
Inherits:       QObject</code></pre> 
<ul><li> </li></ul> 
<pre class="prettyprint"><code>从这里，我们可以看到，必须要在.pro文件中添加QT += network才可以进行网络编程，否则是访问不到&lt;QTcpServer&gt;头文件的。

我们看一下代码头文件：</code></pre> 
<pre class="prettyprint"><code>#ifndef MYTCPSERVER_H
#define MYTCPSERVER_H

#include &lt;QMainWindow&gt;
#include &lt;QTcpServer&gt;
#include &lt;QTcpSocket&gt;
#include &lt;QNetworkInterface&gt;
#include &lt;QMessageBox&gt;
namespace Ui {
class MyTcpServer;
}

class MyTcpServer : public QMainWindow
{
    Q_OBJECT

public:
    explicit MyTcpServer(QWidget *parent = 0);
    ~MyTcpServer();

private:
    Ui::MyTcpServer *ui;
    QTcpServer *tcpServer;
    QList&lt;QTcpSocket*&gt; tcpClient;
    QTcpSocket *currentClient;

private slots:
    void NewConnectionSlot();
    void disconnectedSlot();
    void ReadData();

    void on_btnConnect_clicked();
    void on_btnSend_clicked();
    void on_btnClear_clicked();
};

#endif // MYTCPSERVER_H</code></pre> 
<ul><li> </li></ul> 
<pre class="prettyprint"><code>值得注意的是，在服务端编写时，需要同时定义服务器端变量QTcpServer *tcpServer和客户端变量 QList&lt;QTcpSocket*&gt; tcpClient。tcpSocket QList存储了连接到服务器的所有客户端。因为QTcpServer并不是QIODevice的子类，所以在QTcpServer中并没有任何有关读写操作的成员函数，读写数据的操作全权交由QTcpSocket处理。
</code></pre> 
<ul><li> </li></ul> 
<p><strong>1）初始化QTcpServer</strong></p> 
<pre class="prettyprint"><code>    tcpServer = new QTcpServer(this);
    ui-&gt;edtIP-&gt;setText(QNetworkInterface().allAddresses().at(1).toString());   //获取本地IP
    ui-&gt;btnConnect-&gt;setEnabled(true);
    ui-&gt;btnSend-&gt;setEnabled(false);

    connect(tcpServer, SIGNAL(newConnection()), this, SLOT(NewConnectionSlot()));</code></pre> 
<pre class="prettyprint"><code>通过QNetworkInterface().allAddresses().at(1)获取到本机IP显示在lineEditor上（edtIP）。介绍如下：
[static] QList&lt;QHostAddress&gt; QNetworkInterface::allAddresses()
This convenience function returns all IP addresses found on the host machine. It is equivalent to calling addressEntries() on all the objects returned by allInterfaces() to obtain lists of QHostAddress objects then calling QHostAddress::ip() on each of these.：

每当新的客户端连接到服务器时，newConncetion()信号触发，NewConnectionSlot()是用户的槽函数，定义如下：</code></pre> 
<pre class="prettyprint"><code>void MyTcpServer::NewConnectionSlot()
{
    currentClient = tcpServer-&gt;nextPendingConnection();
    tcpClient.append(currentClient);
    ui-&gt;cbxConnection-&gt;addItem(tr("%1:%2").arg(currentClient-&gt;peerAddress().toString().split("::ffff:")[1])\
                                          .arg(currentClient-&gt;peerPort()));
    connect(currentClient, SIGNAL(readyRead()), this, SLOT(ReadData()));
    connect(currentClient, SIGNAL(disconnected()), this, SLOT(disconnectedSlot()));
}</code></pre> 
<pre class="prettyprint"><code>通过nextPendingConnection()获得连接过来的客户端信息，取到peerAddress和peerPort后显示在comboBox(cbxConnection)上，并将客户端的readyRead()信号连接到服务器端自定义的读数据槽函数ReadData()上。将客户端的disconnected()信号连接到服务器端自定义的槽函数disconnectedSlot()上。</code></pre> 
<p><strong>2）监听端口 与 取消监听</strong></p> 
<pre class="prettyprint"><code>     bool ok = tcpServer-&gt;listen(QHostAddress::Any, ui-&gt;edtPort-&gt;text().toInt());
     if(ok)
     {
         ui-&gt;btnConnect-&gt;setText("断开");
         ui-&gt;btnSend-&gt;setEnabled(true);
     }</code></pre> 
<pre class="prettyprint"><code>a）监听端口的函数：bool QTcpServer::listen(const QHostAddress &amp;*address* = QHostAddress::Any, quint16 *port* = 0),该函数的作用为：Tells the server to listen for incoming connections on address *address* and port *port*. If port is 0, a port is chosen automatically. If address is QHostAddress::Any, the server will listen on all network interfaces.
Returns true on success; otherwise returns false.</code></pre> 
<pre class="prettyprint"><code>     for(int i=0; i&lt;tcpClient.length(); i++)//断开所有连接
     {
         tcpClient[i]-&gt;disconnectFromHost();
         bool ok = tcpClient[i]-&gt;waitForDisconnected(1000);
         if(!ok)
         {
             // 处理异常
         }
         tcpClient.removeAt(i);  //从保存的客户端列表中取去除
     }
     tcpServer-&gt;close();     //不再监听端口</code></pre> 
<pre class="prettyprint"><code>b）断开客户端与服务器连接的函数：disconnectFromHost()和waitForDisconnected()上文已述。断开连接之后，要将其从QList tcpClient中移除。服务器取消监听的函数：tcpServer-&gt;close()。</code></pre> 
<pre class="prettyprint"><code>    //由于disconnected信号并未提供SocketDescriptor，所以需要遍历寻找
    for(int i=0; i&lt;tcpClient.length(); i++)
    {
        if(tcpClient[i]-&gt;state() == QAbstractSocket::UnconnectedState)
        {
            // 删除存储在combox中的客户端信息
            ui-&gt;cbxConnection-&gt;removeItem(ui-&gt;cbxConnection-&gt;findText(tr("%1:%2")\
                                  .arg(tcpClient[i]-&gt;peerAddress().toString().split("::ffff:")[1])\
                                  .arg(tcpClient[i]-&gt;peerPort())));
            // 删除存储在tcpClient列表中的客户端信息
             tcpClient[i]-&gt;destroyed();
             tcpClient.removeAt(i);
        }
    }</code></pre> 
<pre class="prettyprint"><code>c）若某个客户端断开了其与服务器的连接，disconnected()信号被触发，但并未传递参数。所以用户需要遍历tcpClient list来查询每个tcpClient的state()，若是未连接状态（UnconnectedState），则删除combox中的该客户端，删除tcpClient列表中的该客户端，并destroy()。
</code></pre> 
<ul><li> </li></ul> 
<p><strong>3）读取客户端发送过来的数据</strong></p> 
<pre class="prettyprint"><code>    // 客户端数据可读信号，对应的读数据槽函数
    void MyTcpServer::ReadData()
    {
        // 由于readyRead信号并未提供SocketDecriptor，所以需要遍历所有客户端
        for(int i=0; i&lt;tcpClient.length(); i++)
        {
            QByteArray buffer = tcpClient[i]-&gt;readAll();
            if(buffer.isEmpty())    continue;

            static QString IP_Port, IP_Port_Pre;
            IP_Port = tr("[%1:%2]:").arg(tcpClient[i]-&gt;peerAddress().toString().split("::ffff:")[1])\
                                         .arg(tcpClient[i]-&gt;peerPort());

            // 若此次消息的地址与上次不同，则需显示此次消息的客户端地址
            if(IP_Port != IP_Port_Pre)
                ui-&gt;edtRecv-&gt;append(IP_Port);

            ui-&gt;edtRecv-&gt;append(buffer);

            //更新ip_port
            IP_Port_Pre = IP_Port;
        }
    }</code></pre> 
<pre class="prettyprint"><code>这里需要注意的是，虽然tcpClient产生了readReady()信号，但readReady()信号并没有传递任何参数，当面向多连接客户端时，tcpServer并不知道是哪一个tcpClient是数据源，所以这里遍历tcpClient列表来读取数据（略耗时，上述的解决方法1则不必如此）。
读操作由tcpClient变量处理：tcpClient[i]-&gt;readAll();</code></pre> 
<p><strong>4）向客户端发送数据</strong></p> 
<pre class="prettyprint"><code>    //全部连接
    if(ui-&gt;cbxConnection-&gt;currentIndex() == 0)
    {
        for(int i=0; i&lt;tcpClient.length(); i++)
            tcpClient[i]-&gt;write(data.toLatin1()); //qt5除去了.toAscii()
    }</code></pre> 
<pre class="prettyprint"><code>a）向当前连接的所有客户端发数据，遍历即可。</code></pre> 
<pre class="prettyprint"><code>    //指定连接
    QString clientIP = ui-&gt;cbxConnection-&gt;currentText().split(":")[0];
    int clientPort = ui-&gt;cbxConnection-&gt;currentText().split(":")[1].toInt();
    for(int i=0; i&lt;tcpClient.length(); i++)
    {
        if(tcpClient[i]-&gt;peerAddress().toString().split("::ffff:")[1]==clientIP\
                        &amp;&amp; tcpClient[i]-&gt;peerPort()==clientPort)
        {
            tcpClient[i]-&gt;write(data.toLatin1());
            return; //ip:port唯一，无需继续检索
        }
    }</code></pre> 
<pre class="prettyprint"><code>b）在comboBox(cbxConnction)中选择指定连接发送数据：通过peerAddress和peerPort匹配客户端，并发送。写操作由tcpClient变量处理：tcpClient[i]-&gt;write()。</code></pre> 
<p>至此，通过4步，我们就完成了TCP Server的程序开发，源码下载地址：<a href="https://raw.githubusercontent.com/chenpengxin/TCP-Tools/master/MyTcpServer.rar" rel="nofollow">服务器端qt程序源码</a></p> 
<p>转载博客地址为： https://blog.csdn.net/u011964923/article/details/64923685</p> 
<p> </p> 
<p> </p> 
<h3><a href="https://blog.csdn.net/u014252478/article/details/86595862">微信返利机器人，公众号骗局揭秘</a></h3>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/3c69f9db0b25e0419f3cbdcd14d7e9ef/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">[Unity][NavMesh]NavMeshAgent立即马上停止移动</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/54bb3a1499a2f8547469b1b7bad9979a/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">HBuilder自定义格式化代码</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>