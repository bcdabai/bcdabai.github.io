<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>vuex组件传参 - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="vuex组件传参" />
<meta property="og:description" content="vuex 实现数据的全局共享，响应式更新
每一个Vuex应用的核心就是store (仓库)。&#34;store&#39;基本. 上就是一个容器， 它包含着你的应用中大部分的
状态(state)。Vuex 和单纯的全局对象有以下两点不同:
Vuex的状态存储是响应式的。当Vue组件从store中读取状态的时候，若store中的状态发生变化,那
么相应的组件也会相应地得到高效更新。在任意组件都可以访问 store状态中的数据
import Vuex from &#39; vuex&#39; Vue.use (Vuex) export default new Vuex. Store({ state: { // 定义(数据) user: { nane: &#34;zeng8&#34;, score: 280, } } 使用
名字：{{$store. state .user.name}} 积分: {$store.state.user .score}} 你不能直接改变store中的状态。改变store 中的状态的唯一途径就是 显式地提交(commit) mutation。
mutations: { //改变数据的唯一方式只能在mutations 里面 //建议方法名大写，默认一个岁数是state //第二岁数就是方法调用传入的参数 SET_ SCORE(state , data){ state.score = data; } }， 使用
组件中访问 $store.commit(&#34;ADD_ SCORE&#39; ,200) 这样使得我们可以方便地跟踪每-个状态的变化，从而让我们能够实现-些工具帮助我们更好地了解我们的应用。
state - data 数据" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/d6406b72ac311a8b0483e517d473197a/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-12-28T20:31:24+08:00" />
<meta property="article:modified_time" content="2022-12-28T20:31:24+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">vuex组件传参</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p>vuex 实现数据的全局共享，响应式更新</p> 
<p>每一个Vuex应用的核心就是store (仓库)。"store'基本. 上就是一个容器， 它包含着你的应用中大部分的<br> 状态(state)。Vuex 和单纯的全局对象有以下两点不同:<br> Vuex的状态存储是响应式的。当Vue组件从store中读取状态的时候，若store中的状态发生变化,那<br> 么相应的组件也会相应地得到高效更新。在任意组件都可以访问 store状态中的数据</p> 
<pre><code class="language-javascript">import Vuex from ' vuex'
Vue.use (Vuex)
export default new Vuex. Store({

state: {
// 定义(数据)
user: {
nane: "zeng8",
score: 280,
}
}
</code></pre> 
<p>使用</p> 
<pre><code class="language-javascript">名字：{<!-- -->{$store. state .user.name}}
积分: {$store.state.user .score}}
</code></pre> 
<p><br> 你不能直接改变store中的状态。改变store 中的状态的唯一途径就是 显式地提交(commit) mutation。</p> 
<pre><code class="language-javascript">mutations: {
//改变数据的唯一方式只能在mutations 里面
//建议方法名大写，默认一个岁数是state
//第二岁数就是方法调用传入的参数
SET_ SCORE(state , data){
state.score = data;
}
}，
</code></pre> 
<p>使用</p> 
<pre><code class="language-javascript">组件中访问
$store.commit("ADD_ SCORE' ,200)
</code></pre> 
<p>这样使得我们可以方便地跟踪每-个状态的变化，从而让我们能够实现-些工具帮助我们更好地了解我们的应用。<br> state - data  数据</p> 
<p>getters - computed 从现有数据中计算出新的数据</p> 
<p>mutations 改变数据的唯一方式在mutations中</p> 
<p></p> 
<p>计算数据getters</p> 
<pre><code class="language-javascript">例子:
getters:{
gold(state){return Math.floor(state.userInfo.score/100}
}

组件中访问
$store.getters.gold
</code></pre> 
<p> 修改数据mutations</p> 
<pre><code class="language-javascript">例子
ADD. SCORE(state,data=100){
state.userInfo.score+=data
}

组件中访问
$store.commit("ADD_ SCORE",200)

</code></pre> 
<p> 异步操作 Actions</p> 
<pre><code class="language-javascript">例子:
setScore(context,data){
setTimeout(0=&gt;{
context.commit("ADD_ SCORE",data);
},2000)
}

组件中访问
$store.dispatch("setScore",200)
</code></pre> 
<p> 模块 modules</p> 
<pre><code class="language-javascript">把vuex又分成小的模块
import cart from ./modules/cart.js'
modules:{
cart
}

cart.js
export default{
state:{}, 
getters:{},
mutations:{},
actions:{},
namespace:true.//开启模块的命名空间

组件中访问模块的state需要带模块名称(cart)
$store.state.cart.goods


组件访问getters, actions, mutations不需 要带模块名
$store.getters.totalPrice

开启namespace:true命名空间的模块，
getters,mutations,actions在组件中访问的时候都要带模块名
this.$store.dispatch("cart/addCart" ,data)
</code></pre> 
<p> <img alt="" height="376" src="https://images2.imgbox.com/a9/aa/NVjtrbD7_o.png" width="837"></p> 
<p> </p> 
<p>actions第一个参数context<br> mutations第一参数state<br> getters第一个参数state数据</p> 
<pre><code class="language-javascript">1. context相当于组件中的$store
$store代表整个vuex，整个仓库

context.commit("mutations方法名",data)
context.dispatch（"actions中的方法名",data)
context.state.数据名
context.getters.数据名

</code></pre> 
<p> vuex的映射方法</p> 
<pre><code class="language-javascript">vuex的映射方法

  
01 导入
import {mapState,mapGetters,mapActions,mapMutations} from 'vuex'

mapState
02  mapState
在computed去计算
computed:{
//映射带模块cart
...mapState({
goods:state-&gt;state.cart.goods
)}

//不带模块
...mapState(["userInfo"])
}

03  mapState
在组件使用映射出来属性
&lt;p&gt;{<!-- -->{goods}}&lt;/p&gt;
&lt;p&gt;{<!-- -->{userlnfo}}&lt;/p&gt;


mapGetters 
02 mapGetters 
在computed去计算
computed:{
...mapGetters(["totalPrice"])
}

03 mapGetters 
在组件中使用
&lt;p&gt;总价格:{ {talPrice}}&lt;/p&gt;

mapActions 
02 mapActions
在methods方法里面扩展
methods:{
...mapActions(["delCart"])
}

 03 mapActions
在组件中调用方法
&lt;div @click="delCart(good.id)"&gt;

mapMutations
02 mapMutations
在methods方法里面扩展
methods:{
...mapMutations(["ADD_ SCORE"])
}


03 mapMutations
在组件中调用方法
&lt;div @click="ADD_ SCORE(500)"&gt;

就是vuex中的state与getters映射为组件的data数据(只读)
vuex中的actions和mutations映射为组件的methods方法
</code></pre> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/13/c6/VlbZS5ow_o.png"></p> 
<p> </p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/54c31735972cd89d4badccb751fa8bc6/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">python 装饰器详解</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/61d1039849af551a96ee93cd2fd338f1/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">利用OpenCV的函数resize()实现图像的缩放(尺寸变换)</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>