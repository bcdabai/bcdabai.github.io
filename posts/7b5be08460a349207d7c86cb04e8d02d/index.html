<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>准确率（Accuracy）、精确率(Precision)、召回率(Recall)、F值(F-Measure)、AUC、ROC的理解 - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="准确率（Accuracy）、精确率(Precision)、召回率(Recall)、F值(F-Measure)、AUC、ROC的理解" />
<meta property="og:description" content="一、准确率、精确率、召回率和 F 值 是选出目标的重要评价指标。不妨看看这些指标的定义先：
(1)若一个实例是正类，但是被预测成为正类，即为真正类(True Postive TP)
(2)若一个实例是负类，但是被预测成为负类，即为真负类(True Negative TN)
(3)若一个实例是负类，但是被预测成为正类，即为假正类(False Postive FP)
(4)若一个实例是正类，但是被预测成为负类，即为假负类(False Negative FN）
下表中：1代表正类，0代表负类：
TP:正确的匹配数目
FP:误报，没有的匹配不正确
FN:漏报，没有找到正确匹配的数目
TN:正确的非匹配数目
准确率（正确率）=所有预测正确的样本/总的样本 （TP&#43;TN）/总
精确率= 将正类预测为正类 / 所有预测为正类 TP/（TP&#43;FP）
召回率 = 将正类预测为正类 / 所有正真的正类 TP/（TP&#43;FN）
F值 = 精确率 * 召回率 * 2 / ( 精确率 &#43; 召回率) （F 值即为精确率和召回率的调和平均值）
二、ROC曲线：接收者操作特征(receiver operating characteristic),roc曲线上每个点反映着对同一信号刺激的感受性。
纵轴：真正类率(true postive rate TPR)，也叫真阳性率
横轴：假正类率(false postive rate FPR)，也叫伪阳性率
由上表可得出横，纵轴的计算公式：
(1)真正类率(True Postive Rate)TPR: TP/(TP&#43;FN), 代表分类器 预测为正类中实际为正实例
占 所有正实例 的比例。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/7b5be08460a349207d7c86cb04e8d02d/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2018-05-09T10:38:37+08:00" />
<meta property="article:modified_time" content="2018-05-09T10:38:37+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">准确率（Accuracy）、精确率(Precision)、召回率(Recall)、F值(F-Measure)、AUC、ROC的理解</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p>一、准确率、精确率、召回率和 F 值 是选出目标的重要评价指标。不妨看看这些指标的定义先：</p> 
<p>(1)若一个实例是正类，但是被预测成为正类，即为真正类(True Postive TP)</p> 
<p>(2)若一个实例是负类，但是被预测成为负类，即为真负类(True Negative TN)</p> 
<p>(3)若一个实例是负类，但是被预测成为正类，即为假正类(False Postive FP)</p> 
<p>(4)若一个实例是正类，但是被预测成为负类，即为假负类(False Negative FN）</p> 
<p>下表中：1代表正类，0代表负类：</p> 
<p>      <img alt="" class="has" src="https://images2.imgbox.com/33/25/rl1sbynv_o.png"></p> 
<blockquote> 
 <p>TP:正确的匹配数目</p> 
 <p>FP:误报，没有的匹配不正确</p> 
 <p>FN:漏报，没有找到正确匹配的数目</p> 
 <p>TN:正确的非匹配数目</p> 
</blockquote> 
<blockquote> 
 <p> 准确率（正确率）=所有预测正确的样本/总的样本  （TP+TN）/总</p> 
 <p> 精确率=  将正类预测为正类 / 所有预测为正类 TP/（TP+FP）</p> 
 <p> 召回率 = 将正类预测为正类 / 所有正真的正类 TP/（TP+FN）</p> 
 <p> F值 = 精确率 * 召回率 * 2 / ( 精确率 + 召回率) （F 值即为精确率和召回率的<strong>调和平均值</strong>）</p> 
</blockquote> 
<p>二、ROC曲线：接收者操作特征(receiver operating characteristic),roc曲线上每个点反映着对同一信号刺激的感受性。</p> 
<p>纵轴：真正类率(true postive rate TPR)，也叫<strong>真阳性率</strong></p> 
<p>横轴：假正类率(false postive rate FPR)，也叫<strong>伪阳性率</strong></p> 
<p>由上表可得出横，纵轴的计算公式：</p> 
<p>(1)真正类率(True Postive Rate)TPR: TP/(TP+FN), 代表分类器 预测为正类中实际为正实例</p> 
<p>占 所有正实例 的比例。</p> 
<p>(2)假正类率(False Postive Rate)FPR: FP/(FP+TN)，代表分类器 预测为正类中实际为负实例 占 所有负实例 的比例。</p> 
<p>如下图所示，(a)图中实线为ROC曲线，（深绿色）线上每个点对应一个阈值（threshold）。假设是二分类分类器，输出为每个实例预测为正类的概率。那么通过设定一个特定阈值（threshold），预测为正类的概率值 大于等于 特定阈值的为 正类，小于 特定阈值的为 负类，然后统计TP、TN、FP、FN每个类别的数目，然后根据上面的公式，就能对应的就可以算出一组 特定阈值下(FPR,TPR)的值，即 在平面中得到对应坐标点。如果这里没懂也没关系，下面有详细的例子说明。</p> 
<p>右上角的阈值最小，对应坐标点(1,1)；左下角阈值最大，对应坐标点为(0,0)。从右上角到左下角，随着阈值的逐渐减小，越来越多的实例被划分为正类，但是这些正类中同样也掺杂着真正的负实例，即TPR和FPR会同时增大。</p> 
<p><img alt="" class="has" src="https://images2.imgbox.com/ab/9c/2Q0b1hkQ_o.png"></p> 
<p>横轴FPR: FPR越大，预测正类中实际负类越多。</p> 
<p>纵轴TPR：TPR越大，预测正类中实际正类越多。</p> 
<p>理想目标：TPR=1，FPR=0，即图中(0,1)点，此时ROC曲线越靠拢(0,1)点，越偏离45度对角线越好。</p> 
<p>三、如何画roc曲线</p> 
<p>假设已经得出一系列样本被划分为正类的概率，然后按照概率大小排序，如下图所示，图中共有20个测试样本，“Class”一栏表示每个测试样本真正的标签（p表示正样本，n表示负样本，10个正样本，10个负样本），“Score”表示每个测试样本预测为正样本的概率。接下来，我们从高到低，依次将“Score”值作为阈值（threshold），当样本的正样本的预测概率大于或等于这个阈值时，我们认为它为正样本，否则为负样本。</p> 
<p><img alt="" class="has" src="https://images2.imgbox.com/c7/51/yvSybhQy_o.png"></p> 
<p> </p> 
<p>举例来说，</p> 
<blockquote> 
 <p>1）对于图中的第20个样本，其“Score”值为0.1，那么所有样本都被认为是正样本，因为它们的“Score”值都大于等于0.1，没有负样本。即TP值10（样本1，2，4，5，6，9，11，13，17，19），TN值为0，FP值为10（样本3, 7，8，10，12，14，15，16，18，20），FN值为 0。 TPR值为TP/（TP+FN）=10/（10+0）=1， FPR值为FP/（FP+TN）=10/（10+0）=1 所以阈值为0.1时，对应的点为（1，1）。</p> 
 <p>2）对于图中的第4个样本，其“Score”值为0.6，那么样本1，2，3，4都被认为是正样本，因为它们的“Score”值都大于等于0.6，而其他样本则都认为是负样本。即TP值为3（样本1，2，4），TN值为9（样本7，8，10，12，14，15，16，18，20），FP值为1（样本3），FN值为 7（样本5，6，9，11，13，17，19）。 TPR值为TP/（TP+FN）=3/（3+7）=0.3， FPR值为FP/（FP+TN）=1/（1+9）=0.1 所以阈值为0.6时，对应的点为（0.1，0.3）。</p> 
 <p>3）对于图中的第1个样本，其“Score”值为0.9，那么样本1被认为是正样本，因为它们的“Score”值都大于等于0.9，而其他样本则都认为是负样本。即TP值为1（样本1），TN值为0 ，FP值为9，FN值为10（样本3, 7，8，10，12，14，15，16，18，20) TPR值为TP/（TP+FN）=1(1+9）=0.1， FPR值为FP/（FP+TN）=0/（0+10）=0 所以阈值为0.9时，对应的点为（0.1，0）</p> 
</blockquote> 
<p>每次选取一个不同的阈值，我们就可以得到一组FPR和TPR，即ROC曲线上的一点。这样一来，我们一共得到了20组FPR和TPR的值，将它们画在ROC曲线的结果如下图：</p> 
<p><img alt="" class="has" src="https://images2.imgbox.com/97/b7/T5ZEWK4u_o.png"></p> 
<p>AUC(Area under Curve)：Roc曲线下的面积，介于0.1和1之间。AUC作为数值可以直观的评价分类器的好坏，值越大越好。</p> 
<p>首先AUC值是一个概率值，当你随机挑选一个正样本以及负样本，当前的分类算法根据计算得到的Score值将这个正样本排在负样本前面的概率就是AUC值，AUC值越大，当前分类算法越有可能将正样本排在负样本前面，从而能够更好地分类。</p> 
<p>四、AUC计算</p> 
<p>1. 最直观的，根据AUC这个名称，我们知道，计算出ROC曲线下面的面积，就是AUC的值。事实上，这也是在早期 Machine Learning文献中常见的AUC计算方法。由于我们的测试样本是有限的。我们得到的AUC曲线必然是一个阶梯状的。因此，计算的AUC也就是这些阶梯下面的面积之和。这样，我们先把score排序(假设score越大，此样本属于正类的概率越大)，然后一边扫描就可以得到我们想要的AUC。但是，这么做有个缺点，就是当多个测试样本的score相等的时候，我们调整一下阈值，得到的不是曲线一个阶梯往上或者往右的延展，而是斜着向上形成一个梯形。此 时，我们就需要计算这个梯形的面积。由此，我们可以看到，用这种方法计算AUC实际上是比较麻烦的</p> 
<p>2. 一个关于AUC的很有趣的性质是，它和Wilcoxon-Mann-Witney Test是等价的。而Wilcoxon-Mann-Witney Test就是测试任意给一个正类样本和一个负类样本，正类样本的score有多大的 概率 大于负类样本的score。有了这个定义，我们就得到了另外一个计算AUC的办法：得到这个概率。我们知道，在有限样本中我们常用的得到概率的办法就是通过频率来估计之。这种估计随着样本规模的扩大而逐渐逼近真实值。这和上面的方法中，样本数越多，计算的AUC越准确类似，也和计算积分的时候，小区间划分的越细，计算的越准确是同样的道理。具体来说就是统计一下所有的 M×N(M为正类样本的数目，N为负类样本的数目)个正负样本对中，有多少个组中的正样本的score大于负样本的score。当二元组中正负样本的 score相等的时候，按照0.5计算。然后除以M*N。实现这个方法的复杂度为O(n^2)。n为样本数（即n=M+N）</p> 
<p>3. 第三种方法实际上和上述第二种方法是一样的，但是复杂度减小了。它也是首先对score从大到小排序，然后令最大score对应的sample 的rank为n，第二大score对应sample的rank为n-1，以此类推。然后把所有的正类样本的rank相加，再减去M-1种两个正样本组合的情况。得到的就是所有的样本中有多少对正类样本的score大于负类样本的score。然后再除以M×N。即，</p> 
<p><img alt="" class="has" src="https://images2.imgbox.com/06/8e/TP38NLtj_o.png"></p> 
<p>公式解释：</p> 
<blockquote> 
 <p>1、为了求的组合中正样本的score值大于负样本，如果所有的正样本score值都是大于负样本的，那么第一位与任意的进行组合score值都要大，我们取它的rank值为n，但是n-1中有M-1是正样例和正样例的组合这种是不在统计范围内的（为计算方便我们取n组，相应的不符合的有M个），所以要减掉，那么同理排在第二位的n-1，会有M-1个是不满足的，依次类推，故得到后面的公式M*(M+1)/2，我们可以验证在正样本score都大于负样本的假设下，AUC的值为 2、根据上面的解释，不难得出，rank的值代表的是能够产生score前大后小的这样的组合数，但是这里包含了（正，正）的情况，所以要减去这样的组（即排在它后面正例的个数），即可得到上面的公式 另外，特别需要注意的是，再存在score相等的情况时，对相等score的样本，需要 赋予相同的rank(无论这个相等的score是出现在同类样本还是不同类的样本之间，都需要这样处理)。具体操作就是再把所有这些score相等的样本 的rank取平均。然后再使用上述公式。</p> 
</blockquote> 
<p> </p> 
<p>“无意中发现了一个巨牛的人工智能教程，忍不住分享一下给大家。教程不仅是零基础，通俗易懂，而且非常风趣幽默，像看小说一样！觉得太牛了，所以分享给大家。<a href="https://www.cbedai.net/u011630575" rel="nofollow">点这里可以跳转到教程</a>。”</p> 
<p> </p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/de146baf70f7656f39f373320a5b403f/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">第一部分  第三章 1039-1058 答案合集</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/2be0ce9e5736ab5e44fb5287c9d27e2a/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">Tensorflow入门1-CNN网络及MNIST例子讲解</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>