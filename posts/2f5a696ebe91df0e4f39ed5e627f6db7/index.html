<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>定时任务线程池ScheduledThreadPoolExecutor的使用 - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="定时任务线程池ScheduledThreadPoolExecutor的使用" />
<meta property="og:description" content="1. ScheduledThreadPoolExecutor介绍
ScheduledThreadPoolExecutor继承自ThreadPoolExecutor。它主要用来在给定的延迟之后执行任务，或者定期执行任务。通常使用工厂类Executors来创建。
ScheduledThreadPoolExecutor的功能与Timer类似，但比Timer更强大，更灵活，Timer对应的是单个后台线程，而ScheduledThreadPoolExecutor可以在构造函数中指定多个对应的后台线程数。
2.ScheduledThreadPoolExecutor的两种类型
ScheduledThreadPoolExecutor：执行并行任务也就是多条线程同时执行。
SingleThreadScheduledExecutor：执行单条线程。
2.1. ScheduledThreadPoolExecutor
使用Executors创建ScheduledThreadPoolExecutor的方法构造如下：
public static ScheduledExecutorService newScheduledThreadPool(int corePoolSize) { return new ScheduledThreadPoolExecutor(corePoolSize); } public static ScheduledExecutorService newScheduledThreadPool( int corePoolSize, ThreadFactory threadFactory) { return new ScheduledThreadPoolExecutor(corePoolSize, threadFactory); } 2.2. SingleThreadScheduledExecutor
使用Executors创建SingleThreadScheduledExecutor的方法构造如下：
public static ExecutorService newSingleThreadExecutor() { return new FinalizableDelegatedExecutorService (new ThreadPoolExecutor(1, 1, 0L, TimeUnit.MILLISECONDS, new LinkedBlockingQueue&lt;Runnable&gt;())); } public static ExecutorService newSingleThreadExecutor(ThreadFactory threadFactory) { return new FinalizableDelegatedExecutorService (new ThreadPoolExecutor(1, 1, 0L, TimeUnit.MILLISECONDS, new LinkedBlockingQueue&lt;Runnable&gt;(), threadFactory)); } 2." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/2f5a696ebe91df0e4f39ed5e627f6db7/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2021-09-24T16:37:55+08:00" />
<meta property="article:modified_time" content="2021-09-24T16:37:55+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">定时任务线程池ScheduledThreadPoolExecutor的使用</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p>1. ScheduledThreadPoolExecutor介绍<br> ScheduledThreadPoolExecutor继承自ThreadPoolExecutor。它主要用来在给定的延迟之后执行任务，或者定期执行任务。通常使用工厂类Executors来创建。<br> ScheduledThreadPoolExecutor的功能与Timer类似，但比Timer更强大，更灵活，Timer对应的是单个后台线程，而ScheduledThreadPoolExecutor可以在构造函数中指定多个对应的后台线程数。<br> 2.ScheduledThreadPoolExecutor的两种类型<br> ScheduledThreadPoolExecutor：执行并行任务也就是多条线程同时执行。<br> SingleThreadScheduledExecutor：执行单条线程。<br> 2.1. ScheduledThreadPoolExecutor<br> 使用Executors创建ScheduledThreadPoolExecutor的方法构造如下：</p> 
<pre><code>public static ScheduledExecutorService newScheduledThreadPool(int corePoolSize) {
        return new ScheduledThreadPoolExecutor(corePoolSize);
    }
    
public static ScheduledExecutorService newScheduledThreadPool(
            int corePoolSize, ThreadFactory threadFactory) {
        return new ScheduledThreadPoolExecutor(corePoolSize, threadFactory);
    }</code></pre> 
<p><br> 2.2. SingleThreadScheduledExecutor<br> 使用Executors创建SingleThreadScheduledExecutor的方法构造如下：</p> 
<pre><code>public static ExecutorService newSingleThreadExecutor() {
        return new FinalizableDelegatedExecutorService
            (new ThreadPoolExecutor(1, 1,
                                    0L, TimeUnit.MILLISECONDS,
                                    new LinkedBlockingQueue&lt;Runnable&gt;()));
    }
    
public static ExecutorService newSingleThreadExecutor(ThreadFactory threadFactory) {
        return new FinalizableDelegatedExecutorService
            (new ThreadPoolExecutor(1, 1,
                                    0L, TimeUnit.MILLISECONDS,
                                    new LinkedBlockingQueue&lt;Runnable&gt;(),
                                    threadFactory));
    }</code></pre> 
<p><br> 2.3. 创建实例</p> 
<pre><code>ScheduledExecutorService scheduledThreadPoolExecutor=Executors.newScheduledThreadPool(5);

ScheduledExecutorService singleThreadScheduledExecutor=Executors.newSingleThreadScheduledExecutor();</code></pre> 
<p><br> 2.4 使用场景<br> ScheduledThreadPoolExecutor：适用于多个后台线程执行周期性任务，同时为了满足资源管理的需求而需要限制后台线程数量的应用场景。<br> SingleThreadScheduledExecutor：适用于需要单个后台线程执行周期任务，同时需要保证任务顺序执行的应用场景。</p> 
<p>3. ScheduledThreadPoolExecutor执行机制分析</p> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/7a/18/vjPh25k7_o.png"></p> 
<p>注意：DelayQueue是一个无界队列，所以ThreadPoolExecutor的maximumPoolSize在ScheduledThreadPoolExecutor中无意义。</p> 
<p>ScheduledThreadPoolExecutor的执行主要分为以下两个部分:</p> 
<p>当调用ScheduledThreadPoolExecutor的scheduleAtFixedRate()方法或者scheduleWithFixedDelay()方法时，会向ScheduledThreadPoolExecutor的DelayQueue添加一个实现了RunnableScheduledFuture接口的ScheduleFutureTask。<br> 线程池中的线程从DelayQueue中获取ScheduleFutureTask，然后执行任务。<br> 4. ScheduledThreadPoolExecutor使用案例<br> 创建一个Runnable的对象，然后使用ScheduledThreadPoolExecutor的Scheduled()来执行延迟任务。</p> 
<p>4.1 延迟指定时间才开始执行schedule。</p> 
<pre><code>public ScheduledFuture schedule(Runnable command,long delay, TimeUnit unit);</code></pre> 
<p>参数解析command：实现Runnable接口的类<br> delay：延迟多久后执行<br> unit：用于指定keepAliveTime参数的时间单位，这是一个枚举，常用的有TimeUnit.MILLISECONDS(毫秒)，TimeUnit.SECONDS(秒)以及TimeUnit.MINUTES(分钟)等</p> 
<pre><code>import java.util.concurrent.Executors;
import java.util.concurrent.ScheduledExecutorService;
import java.util.concurrent.TimeUnit;

/**
 * @authorSaint
 * @version 1.0
 * @date 2020/8/9 15:05
 */
public class Main {

    public static void main(String[] args) {
        ScheduledExecutorService scheduledThreadPoolExecutor= Executors.newScheduledThreadPool(1);
        long cur = System.currentTimeMillis();
        System.out.println("延迟要开始了");
        scheduledThreadPoolExecutor.schedule(new Runnable() {
            @Override
            public void run() {
                System.out.println("Hello, World!");
            }
            //0表示首次执行任务的延迟时间，1000表示每次执行任务的间隔时间，TimeUnit.MILLISECONDS执行的时间间隔数值单位
        }, 2000, TimeUnit.MILLISECONDS);
        long stop = System.currentTimeMillis();
    }
}</code></pre> 
<p>4.2 周期性执行任务<br> scheduleAtFixedRate方法的作用是预定在初始的延迟结束后，周期性地执行给定的任务，周期长度为period，其中initialDelay为初始延迟。</p> 
<pre><code>public ScheduledFuture&lt;?&gt; scheduleAtFixedRate(Runnable command,
                                                  long initialDelay,
                                                  long period,
                                                  TimeUnit unit);</code></pre> 
<p>scheduleWithFixedDelay方法的作用是预定在初始的延迟结束后周期性地执行给定任务，在一次调用完成和下一次调用开始之间有长度为delay的延迟，其中initialDelay为初始延迟</p> 
<pre><code>public ScheduledFuture&lt;?&gt; scheduleWithFixedDelay(Runnable command,
                                                     long initialDelay,
                                                     long delay,
                                                     TimeUnit unit);
</code></pre> 
<p>案例代码</p> 
<pre><code>package cn.com.wind.windabc.shceduledthreadpool;

import java.util.concurrent.Executors;
import java.util.concurrent.ScheduledExecutorService;
import java.util.concurrent.TimeUnit;
import java.util.concurrent.locks.ReentrantReadWriteLock;

/**
 * 定时任务，并增加执行次数限制
 * @author Saint
 * @version 1.0
 * @date 2020/8/9 15:14
 */
public class ScheduledMultiThreadTool {

    private  static Integer count =1;
    MyTimerTask myTimerTask = new MyTimerTask();
    private ReentrantReadWriteLock lock = new ReentrantReadWriteLock();
    ScheduledExecutorService scheduled = Executors.newScheduledThreadPool(2);

    public void start(){
        try {
            //一秒执行一次
            scheduled.scheduleAtFixedRate(myTimerTask, 0,1, TimeUnit.SECONDS);
            while (!scheduled.isTerminated()){
                lock.readLock().lock();
                if (count &gt;20){
                    scheduled.shutdown();
                }
                lock.readLock().unlock();

            }
        }catch(Exception e){
            e.printStackTrace();
        }
        System.out.println("Finished all threads");
    }
    private class MyTimerTask implements Runnable {
        @Override
        public void run(){
            lock.writeLock().lock();
            System.out.println("第 "+count+ " 次执行任务,count="+count);
            count ++;
            lock.writeLock().unlock();
        }

    }

    public static void main(String[] args) {
        new ScheduledMultiThreadTool().start();
    }
}</code></pre> 
<p><br> 限制程序执行的次数：如果是单线程，那么可以直接定义一个静态变量count，每执行一次，count加一，如果count大于某个值就调用shutdown或者shutdownNow函数；如果是多线程，稍微要复杂一点，但是原理也是一样的。定义一个静态变量count，没执行一个也是count加一，只不过在执行加一操作之前需要加锁，执行完之后需要解锁</p> 
<p><br> 附：时间单位<br> 毫秒：TimeUnit.MILLISECONDS<br> 秒：TimeUnit.SECONDS<br> 分钟：TimeUnit.MINUTES<br> 小时：TimeUnit.HOURS<br> 天：TimeUnit.DAYS</p> 
<p>总结<br> SingleThreadScheduledExecutor与ScheduledThreadPoolExecutor使用方法类似。<br> 了解完ScheduledThreadPoolExecutor的创建方法和内置的几个schedule()方法后，使用起来还是很简单的。<br> 我们主要记住两个类：SingleThreadScheduledExecutor、ScheduledThreadPoolExecutor</p> 
<p> </p> 
<p>————————————————<br> 版权声明：本文为CSDN博主「梦回玖柒」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。<br> 原文链接：https://blog.csdn.net/Saintmm/article/details/107894658 </p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/840b1ac67f3a23898800953ab38b089b/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">渗透测试之域名搜集方法总结</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/88929be8d820da42b0206cc24c0b416b/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">c&#43;&#43;之dll动态调用</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>