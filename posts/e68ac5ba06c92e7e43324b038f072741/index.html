<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>操作系统实验一 - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="操作系统实验一" />
<meta property="og:description" content="操作系统实验一 lab0 基础操作及准备 1.lab0要求我们准备好实验所需的工具，但实际上大部分工具我们在大二时就已经安装完毕，比如Ubuntu和VMware。而且我们在逐渐的使用中也已经熟悉了自己喜欢的文本编辑器和操作方式，同时一些命令行的基本操作也已经烂熟于心，例如ls查找文件，clear清除信息，history查询历史命令行记录，mkdir新建文件夹，gedit或者vi或者vim则都可以新建文件，使用的是不同的文本编辑器，rm删除文件等等。
2.当然这些操作都较为基本，最主要的操作还是makefile或者make操作以及gcc编译器编译并执行c程序，chxomd编译py程序。
新的工具QEMU以及我的安装模式 在Linux运行环境中，QEMU用于模拟一台x86计算机，让ucore能够运行在QEMU上。为了能够正确的编译和安装 qemu，尽量使用最新版本的qemu，或者os ftp服务器上提供的qemu源码。在 Ubuntu 系统中，版本可以通过 gcc -v 或者 gcc --version 进行查看。
安装方式1：可直接使用ubuntu中提供的qemu，只需执行如下命令即可。
sudo apt-get install qemu-system 安装方式2：也可采用下面描述的方法对qemu进行源码级安装。需要到网站上下载源码并进行一系列神奇的命令行操作。这里不再赘述。
我的安装方式:
尝试过两种安装方式后第一个报错另一个则安装方式稍显繁琐。于是我仔细在第一种方式中改进。如果直接运行指导书中的命令会报错，看英文的意思大概是很多东西没有安装。所以想到不加参数而直接使用命令：
sudo apt-get install qemu 发现报错中出现友好提示，recommend:util操作可能解决这个问题。所以我尝试运行：
sudo apt-get install qemu-util 这个命令实际上将包括模拟x86所用的所有包都下载了，所以自然之后再运行指导书中的命令后就不会报错，至此实验所需工具安装完毕！
lab1 练习1：理解通过make生成执行文件的过程。 1.操作系统镜像文件ucore.img是如何一步一步生成的？(需要比较详细地解释Makefile中每一条相关命令和命令参数的含义，以及说明命令导致的结果)
总结起来，总的步骤可以分为以下五步完成：
(1)通过GCC编译器将Kernel目录下的.c文件编译成OBJ目录下的.o文件。
(2)ld命令根据链接脚本文件kernel.ld将生成的*.o文件，链接成BIN目录下的kernel文件 。
(3)通过GCC编译器将boot目录下的.c,.S文件以及tools目录下的sign.c文件编译成OBJ目录下的*.o文件。
(4)ld命令将生成的*.o文件，链接成BIN目录下的bootblock文件。
(5)dd命令将dev/zero, bin/bootblock,bin/kernel 写入到bin/ucore.img
①编译命令：
命令展示详细信息后都是用的GCC，将.c文件编译成为.o文件。
-l: 对于其中命令-I的含义如下：-I /home/hello/include表示将/home/hello/include目录作为第一个寻找头文件的目录。
-o: 经查询，-o OUTPUT’–output=OUTPUT’使用OUTPUT作为’ld’产生的程序的名字;如果这个选项没有指定,缺省的输出文件名是’a.out’.脚本命令’OUTPUT’也可以被用来指定输出文件的文件名。
-t：’–trace’打印’ld’处理的所有输入文件的名字。
-T： SCRIPTFILE’–script=SCRIPTFILE’把SCRIPTFILE作为连接脚本使用. 这个脚本会替代’ld’的缺省连接脚本(而不是增加它的内容),所以命令文件必须指定所有需要的东西以精确描述输出文件. 如果SCRIPTFILE在当前目录下不存在,‘ld’会在’-L’选项指定的所有目录下去寻找.多个’-T’选项会使内容累积.
-M：’–print-map’
打印一个连接位图到标准输出.一个连接位图提供的关于连接的信息有如下一些:目标文件和符号被映射到内存的哪些地方普通符号如何被分配空间.所有被连接进来的档案文件,还有导致档案文件被包含进来的那个符号。
举个例子：
cc boot/bootasm.S //编译bootasm.c
gcc -c boot/bootasm.S -o obj/boot/bootasm." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/e68ac5ba06c92e7e43324b038f072741/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2019-11-16T00:14:41+08:00" />
<meta property="article:modified_time" content="2019-11-16T00:14:41+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">操作系统实验一</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <h2><a id="center_0"></a> 
 <center>
   操作系统实验一 
 </center></h2> 
<p><img src="https://images2.imgbox.com/94/30/2eHQJJK8_o.png" alt="在这里插入图片描述"></p> 
<h3><a id="lab0_5"></a>lab0</h3> 
<h4><a id="_6"></a>基础操作及准备</h4> 
<p>1.lab0要求我们准备好实验所需的工具，但实际上大部分工具我们在大二时就已经安装完毕，比如Ubuntu和VMware。而且我们在逐渐的使用中也已经熟悉了自己喜欢的文本编辑器和操作方式，同时一些命令行的基本操作也已经烂熟于心，例如ls查找文件，clear清除信息，history查询历史命令行记录，mkdir新建文件夹，gedit或者vi或者vim则都可以新建文件，使用的是不同的文本编辑器，rm删除文件等等。</p> 
<p>2.当然这些操作都较为基本，最主要的操作还是makefile或者make操作以及gcc编译器编译并执行c程序，chxomd编译py程序。</p> 
<h4><a id="QEMU_10"></a>新的工具QEMU以及我的安装模式</h4> 
<p>在Linux运行环境中，QEMU用于模拟一台x86计算机，让ucore能够运行在QEMU上。为了能够正确的编译和安装 qemu，尽量使用最新版本的qemu，或者os ftp服务器上提供的qemu源码。在 Ubuntu 系统中，版本可以通过 gcc -v 或者 gcc --version 进行查看。<br> <strong>安装方式1</strong>：可直接使用ubuntu中提供的qemu，只需执行如下命令即可。</p> 
<pre><code>sudo apt-get install qemu-system
</code></pre> 
<p><strong>安装方式2</strong>：也可采用下面描述的方法对qemu进行源码级安装。需要到网站上下载源码并进行一系列神奇的命令行操作。这里不再赘述。</p> 
<p><strong>我的安装方式:</strong><br> 尝试过两种安装方式后第一个报错另一个则安装方式稍显繁琐。于是我仔细在第一种方式中改进。如果直接运行指导书中的命令会报错，看英文的意思大概是很多东西没有安装。所以想到不加参数而直接使用命令：</p> 
<pre><code>sudo apt-get install qemu
</code></pre> 
<p>发现报错中出现友好提示，recommend:util操作可能解决这个问题。所以我尝试运行：</p> 
<pre><code>sudo apt-get install qemu-util
</code></pre> 
<p>这个命令实际上将包括模拟x86所用的所有包都下载了，所以自然之后再运行指导书中的命令后就不会报错，至此实验所需工具安装完毕！</p> 
<h3><a id="lab1_30"></a>lab1</h3> 
<h4><a id="1make_31"></a>练习1：理解通过make生成执行文件的过程。</h4> 
<p><strong>1.操作系统镜像文件ucore.img是如何一步一步生成的？(需要比较详细地解释Makefile中每一条相关命令和命令参数的含义，以及说明命令导致的结果)</strong></p> 
<p>总结起来，总的步骤可以分为以下五步完成：<br> (1)通过GCC编译器将Kernel目录下的.c文件编译成OBJ目录下的.o文件。<br> (2)ld命令根据链接脚本文件kernel.ld将生成的*.o文件，链接成BIN目录下的kernel文件 。<br> (3)通过GCC编译器将boot目录下的.c,.S文件以及tools目录下的sign.c文件编译成OBJ目录下的*.o文件。<br> (4)ld命令将生成的*.o文件，链接成BIN目录下的bootblock文件。<br> (5)dd命令将dev/zero, bin/bootblock,bin/kernel 写入到bin/ucore.img</p> 
<p><strong>①编译命令</strong>：<br> 命令展示详细信息后都是用的GCC，将.c文件编译成为.o文件。<br> <strong>-l:</strong> 对于其中命令-I的含义如下：-I /home/hello/include表示将/home/hello/include目录作为第一个寻找头文件的目录。<br> <strong>-o:</strong> 经查询，-o OUTPUT’–output=OUTPUT’使用OUTPUT作为’ld’产生的程序的名字;如果这个选项没有指定,缺省的输出文件名是’a.out’.脚本命令’OUTPUT’也可以被用来指定输出文件的文件名。<br> <strong>-t：</strong>’–trace’打印’ld’处理的所有输入文件的名字。<br> <strong>-T：</strong> SCRIPTFILE’–script=SCRIPTFILE’把SCRIPTFILE作为连接脚本使用. 这个脚本会替代’ld’的缺省连接脚本(而不是增加它的内容),所以命令文件必须指定所有需要的东西以精确描述输出文件. 如果SCRIPTFILE在当前目录下不存在,‘ld’会在’-L’选项指定的所有目录下去寻找.多个’-T’选项会使内容累积.<br> <strong>-M：</strong>’–print-map’<br> 打印一个连接位图到标准输出.一个连接位图提供的关于连接的信息有如下一些:目标文件和符号被映射到内存的哪些地方普通符号如何被分配空间.所有被连接进来的档案文件,还有导致档案文件被包含进来的那个符号。<br> <strong>举个例子</strong>：</p> 
<ul><li>cc boot/bootasm.S //编译bootasm.c<br> gcc -c boot/bootasm.S -o obj/boot/bootasm.o</li></ul> 
<p><strong>②链接命令：</strong><br> -o即是把所有后面的.o文件链接起来。比如kernel的形成：</p> 
<ul><li>ld bin/kernel //链接成kernel<br> ld -o bin/kernel<br> obj/kern/init/init.o obj/kern/libs/readline.o<br> obj/kern/libs/stdio.o obj/kern/debug/kdebug.o<br> obj/kern/debug/kmonitor.o obj/kern/debug/panic.o<br> obj/kern/driver/clock.o obj/kern/driver/console.o<br> obj/kern/driver/intr.o obj/kern/driver/picirq.o<br> obj/kern/trap/trap.o obj/kern/trap/trapentry.o<br> obj/kern/trap/vectors.o obj/kern/mm/pmm.o<br> obj/libs/printfmt.o obj/libs/string.o</li></ul> 
<p><strong>③填写boot block命令：</strong><br> 生成并填写bookblock的操作在这里可以看出来：<br> dd if=/dev/zero of=bin/ucore.img count=10000<br> //创建大小为10000个块的ucore.img，初始化为0，每个块为512字节</p> 
<p>dd if=bin/bootblock of=bin/ucore.img conv=notrunc<br> //把bootblock中的内容写到第一个块</p> 
<p>dd if=bin/kernel of=bin/ucore.img seek=1 conv=notrunc<br> //从第二个块开始写kernel中的内容</p> 
<p><strong>2.一个被系统认为是符合规范的硬盘主引导扇区的特征是什么？</strong><br> 如图在tools文件夹之中找到sign.c文件进入可发现如下代码：<img src="https://images2.imgbox.com/cf/9e/NDmANQRV_o.png" alt="在这里插入图片描述">根据这个代码可以发现，符合规范的硬盘主引导扇区的特征应该包括，<br> ①大小为512个字节，<br> ②没用到的其他位置设置为0，<br> ③第511个字节0x55，第512个字节是0xAA，也就是说，最后一个和倒数第二个字节的内容是确定的，<br> ④如果读出的字节数不是512，需要报错。即应该可以读出512.</p> 
<h4><a id="2_qemulab1_84"></a>练习2 使用qemu执行并调试lab1中的软件</h4> 
<p><strong>1.从 CPU 加电后执行的第一条指令开始,单步跟踪 BIOS 的执行。</strong><br> 对于gdbinit，也就是gdb的初始设置，开始时发现是如下：</p> 
<pre><code>file bin/kernel
set architecture i8086
target remote :1234
break kern_init
continue
</code></pre> 
<p>①在其中加入语句：set architecture i8086，再执行make debug，有如下结果<br> 此时进入gdb调试，而且显示architecture被假设到i8086。<br> <img src="https://images2.imgbox.com/ff/aa/7E7tk1vF_o.png" alt="在这里插入图片描述"><br> ②之后进行单步跟踪。<br> <img src="https://images2.imgbox.com/f4/cf/8HnImjo6_o.png" alt="在这里插入图片描述">发现每执行一次si,白框内的指针就向下移动到下一个执行代码处，用指令x/2i $pc意思是展示出当前pc中指令，如此实现gdb模式下的单步跟踪。</p> 
<p><strong>2.在初始化位置0x7c00 设置实地址断点,测试断点正常。</strong></p> 
<p>如图，gdbinit文件里面的内容编写成这样，gdb调试的过程就被钉死，即建筑体假设完成后设置断点0x7c00，并且展示出来。</p> 
<pre><code>file bin/kernel
set architecture i8086
target remote :1234
break *0x7c00
continue
</code></pre> 
<p>结果如下，断点功能正常。<br> <img src="https://images2.imgbox.com/b1/8a/NERNaDUH_o.png" alt="在这里插入图片描述"></p> 
<p><strong>3.从0x7c00开始跟踪代码运行,将单步跟踪反汇编得到的代码与bootasm.S和 bootblock.asm进行比较。</strong></p> 
<pre><code>debug: $(UCOREIMG)
	$(V)$(QEMU) -S -s -parallel stdio -hda $&lt; -serial null &amp;
	$(V)sleep 2
	$(V)$(TERMINAL) -e "gdb -q -tui -x tools/gdbinit"
	
</code></pre> 
<p>改写成<br> <img src="https://images2.imgbox.com/89/a2/0tyXj3kr_o.png" alt="在这里插入图片描述"><br> 向其中加入-d in_asm，说明要与.asm也想比较。</p> 
<p>运行后，Gedit bootasm.S得到，他在boot文件夹里。</p> 
<pre><code class="prism language-cpp"><span class="token macro property"># start address should be 0:7c00, in real mode, the beginning address of the running bootloader</span>
<span class="token punctuation">.</span>globl start
start<span class="token operator">:</span>
<span class="token punctuation">.</span>code16                                             # Assemble <span class="token keyword">for</span> <span class="token number">16</span><span class="token operator">-</span>bit mode
    cli                                             # Disable interrupts
    cld                                             # String operations increment

    <span class="token macro property"># Set up the important data segment registers (DS, ES, SS).</span>
    xorw <span class="token operator">%</span>ax<span class="token punctuation">,</span> <span class="token operator">%</span>ax                                   # Segment number zero
    movw <span class="token operator">%</span>ax<span class="token punctuation">,</span> <span class="token operator">%</span>ds                                   # <span class="token operator">-</span><span class="token operator">&gt;</span> Data Segment
    movw <span class="token operator">%</span>ax<span class="token punctuation">,</span> <span class="token operator">%</span>es                                   # <span class="token operator">-</span><span class="token operator">&gt;</span> Extra Segment
    movw <span class="token operator">%</span>ax<span class="token punctuation">,</span> <span class="token operator">%</span>ss                                   # <span class="token operator">-</span><span class="token operator">&gt;</span> Stack Segment
</code></pre> 
<p>在obj文件夹里找到bootblock.asm文件，他其中也有相似内容，代表含义相同。</p> 
<pre><code class="prism language-cpp">start<span class="token operator">:</span>
<span class="token punctuation">.</span>code16                                             # Assemble <span class="token keyword">for</span> <span class="token number">16</span><span class="token operator">-</span>bit mode
    cli                                             # Disable interrupts
    <span class="token number">7</span>c00<span class="token operator">:</span>	fa                   	cli    
    cld                                             # String operations increment
    <span class="token number">7</span>c01<span class="token operator">:</span>	fc                   	cld    

    <span class="token macro property"># Set up the important data segment registers (DS, ES, SS).</span>
    xorw <span class="token operator">%</span>ax<span class="token punctuation">,</span> <span class="token operator">%</span>ax                                   # Segment number zero
    <span class="token number">7</span>c02<span class="token operator">:</span>	<span class="token number">31</span> c0                	<span class="token operator">xor</span>    <span class="token operator">%</span>eax<span class="token punctuation">,</span><span class="token operator">%</span>eax
    movw <span class="token operator">%</span>ax<span class="token punctuation">,</span> <span class="token operator">%</span>ds                                   # <span class="token operator">-</span><span class="token operator">&gt;</span> Data Segment
    <span class="token number">7</span>c04<span class="token operator">:</span>	<span class="token number">8</span>e d8                	mov    <span class="token operator">%</span>eax<span class="token punctuation">,</span><span class="token operator">%</span>ds
    movw <span class="token operator">%</span>ax<span class="token punctuation">,</span> <span class="token operator">%</span>es                                   # <span class="token operator">-</span><span class="token operator">&gt;</span> Extra Segment
    <span class="token number">7</span>c06<span class="token operator">:</span>	<span class="token number">8</span>e c0                	mov    <span class="token operator">%</span>eax<span class="token punctuation">,</span><span class="token operator">%</span>es
    movw <span class="token operator">%</span>ax<span class="token punctuation">,</span> <span class="token operator">%</span>ss                                   # <span class="token operator">-</span><span class="token operator">&gt;</span> Stack Segment
    <span class="token number">7</span>c08<span class="token operator">:</span>	<span class="token number">8</span>e d0                	mov    <span class="token operator">%</span>eax<span class="token punctuation">,</span><span class="token operator">%</span>ss

</code></pre> 
<p>从这里可以发现断点后运行，这两个代码应该是相同。</p> 
<p><strong>4.自己找一个bootloader或内核中的代码位置，设置断点并进行测试。</strong></p> 
<p>我i自己设置的断点是0x7c13,对应于相加操作，用gdb后结果如下：<br> <img src="https://images2.imgbox.com/bf/a1/zh5PB6wJ_o.png" alt="在这里插入图片描述"><br> 正确</p> 
<h4><a id="3bootloader_168"></a>练习3：分析bootloader进入保护模式的过程。</h4> 
<p><strong>1.为何开启A20，以及如何开启A20？</strong><br> <strong>①为何：</strong> A20打开是为了可以找到更远地址位置的数据，在寻址超过1M时，A20便会打开，让数据寻找更大的地方，也就是4G内存或更大的几个G的内存，这里的1M相当于一个高速缓存的地方。<br> 具体来说，这是一个历史性问题。在intel处理器8086中，“段：偏移”最大能表示的内存地址是FFFF：FFFF，即10FFEFh，但是8086仅仅有20位寻址地址总线，仅仅能寻址到1MB，假设试图訪问1MB以上的内存地址，并不会错误发生，而是回卷。即又回到0000:0000地址，又从零開始寻址。但是到了80286时，真的能够訪问到1MB以上的内存了。假设遇到相同的情况，系统不会再回卷寻址，这就造成了向上不兼容，为了保证100%兼容，IBM想出了一个办法。使用8042键盘控制器来控制第20个地址位。这就是A20地址线。<br> <strong>②如何：</strong> 开启A20的步骤：<br> 等待8042为空；<br> 发送Write命令到8042；<br> 等待8042为空；<br> 将8042 得到字节的第2位置1，然后写入8042；</p> 
<pre><code class="prism language-cpp">seta20<span class="token punctuation">.</span><span class="token number">1</span><span class="token operator">:</span>
    inb $<span class="token number">0x64</span><span class="token punctuation">,</span> <span class="token operator">%</span>al                                  # Wait <span class="token keyword">for</span> <span class="token operator">not</span> <span class="token function">busy</span><span class="token punctuation">(</span><span class="token number">8042</span> input buffer empty<span class="token punctuation">)</span><span class="token punctuation">.</span>
    testb $<span class="token number">0x2</span><span class="token punctuation">,</span> <span class="token operator">%</span>al
    jnz seta20<span class="token punctuation">.</span><span class="token number">1</span>

    movb $<span class="token number">0xd1</span><span class="token punctuation">,</span> <span class="token operator">%</span>al                                 # <span class="token number">0xd1</span> <span class="token operator">-</span><span class="token operator">&gt;</span> port <span class="token number">0x64</span>
    outb <span class="token operator">%</span>al<span class="token punctuation">,</span> $<span class="token number">0x64</span>                                 # <span class="token number">0xd1</span> means<span class="token operator">:</span> write data to <span class="token number">8042</span>'s P2 port

seta20<span class="token punctuation">.</span><span class="token number">2</span><span class="token operator">:</span>
    inb $<span class="token number">0x64</span><span class="token punctuation">,</span> <span class="token operator">%</span>al                                  # Wait <span class="token keyword">for</span> <span class="token operator">not</span> <span class="token function">busy</span><span class="token punctuation">(</span><span class="token number">8042</span> input buffer empty<span class="token punctuation">)</span><span class="token punctuation">.</span>
    testb $<span class="token number">0x2</span><span class="token punctuation">,</span> <span class="token operator">%</span>al
    jnz seta20<span class="token punctuation">.</span><span class="token number">2</span>

    movb $<span class="token number">0xdf</span><span class="token punctuation">,</span> <span class="token operator">%</span>al                                 # <span class="token number">0xdf</span> <span class="token operator">-</span><span class="token operator">&gt;</span> port <span class="token number">0x60</span>
    outb <span class="token operator">%</span>al<span class="token punctuation">,</span> $<span class="token number">0x60</span>                                 # <span class="token number">0xdf</span> <span class="token operator">=</span> <span class="token number">11011111</span><span class="token punctuation">,</span> means set P2's A20 <span class="token function">bit</span><span class="token punctuation">(</span>the <span class="token number">1</span> bit<span class="token punctuation">)</span> to <span class="token number">1</span>
</code></pre> 
<p><strong>2.如何初始化GDT表？</strong></p> 
<p>首先载入GDT表 ，再通过将cr0寄存器PE位置1，cro的第0位为1，再通过长跳转更新cs的基地址，跳转到code32。由于是32，$PROT_MODE_CSEG的值为0x30。之后设置段寄存器，并建立堆栈，最后转到保护模式完成，进入boot主方法。这个实际上就是在代码里给出的过程：</p> 
<pre><code class="prism language-cpp"><span class="token punctuation">.</span>code32                                             # Assemble <span class="token keyword">for</span> <span class="token number">32</span><span class="token operator">-</span>bit mode
protcseg<span class="token operator">:</span>
    <span class="token macro property"># Set up the protected-mode data segment registers</span>
    movw $PROT_MODE_DSEG<span class="token punctuation">,</span> <span class="token operator">%</span>ax                       # Our data segment selector
    movw <span class="token operator">%</span>ax<span class="token punctuation">,</span> <span class="token operator">%</span>ds                                   # <span class="token operator">-</span><span class="token operator">&gt;</span> DS<span class="token operator">:</span> Data Segment
    movw <span class="token operator">%</span>ax<span class="token punctuation">,</span> <span class="token operator">%</span>es                                   # <span class="token operator">-</span><span class="token operator">&gt;</span> ES<span class="token operator">:</span> Extra Segment
    movw <span class="token operator">%</span>ax<span class="token punctuation">,</span> <span class="token operator">%</span>fs                                   # <span class="token operator">-</span><span class="token operator">&gt;</span> FS
    movw <span class="token operator">%</span>ax<span class="token punctuation">,</span> <span class="token operator">%</span>gs                                   # <span class="token operator">-</span><span class="token operator">&gt;</span> GS
    movw <span class="token operator">%</span>ax<span class="token punctuation">,</span> <span class="token operator">%</span>ss                                   # <span class="token operator">-</span><span class="token operator">&gt;</span> SS<span class="token operator">:</span> Stack Segment

    <span class="token macro property"># Set up the stack pointer and call into C. The stack region is from 0--start(0x7c00)</span>
    movl $<span class="token number">0x0</span><span class="token punctuation">,</span> <span class="token operator">%</span>ebp
    movl $start<span class="token punctuation">,</span> <span class="token operator">%</span>esp
    call bootmain

    <span class="token macro property"># If bootmain returns (it shouldn't), loop.</span>
spin<span class="token operator">:</span>
    jmp spin

</code></pre> 
<p><strong>3.如何使能和进入保护模式？</strong><br> 通过将cr0寄存器PE位置1，cro的第0位为1</p> 
<h3><a id="4bootloaderELFOS_227"></a>练习4.分析bootloader加载ELF格式的OS的过程。</h3> 
<p><strong>1.bootloader如何读取硬盘扇区的？</strong><br> 读取扇区的流程我们通过查询指导书可以看到：<br> 1、等待磁盘准备好；<br> 2、发出读取扇区的命令；<br> 3、等待磁盘准备好；<br> 4、把磁盘扇区数据读到指定内存。<br> 同时有对应的0号硬盘的IO端口号如下：<br> <img src="https://images2.imgbox.com/20/56/iqxCTDE0_o.png" alt="在这里插入图片描述"><br> 结合Bootmain.c的代码可总结：代码的含义就是，在等待磁盘准备的阶段，如果0x1F7的最高两位是1，就跳出循环，也就是如果不是出于忙的状态就可以读取0X1F0的数据，就可以从准备状态跳出.在发出扇区的命令阶段，设置读取扇区数为1，规定好扇区信息的保存，分别用来保存扇区的编号，低八位，高两位信息，还有其磁盘号以及磁头号。然后又是等待，再是从0X1F0在disk不忙时读取数据。这样就完成了硬盘扇区的信息读取。<br> <mark>拓展</mark><br> 具体来说LBA模式中，使用LBA模式的PIO（Program IO）方式来访问硬盘的情况与CHS不同之处对比如下：<br> <mark>CHS方式:</mark><br> 写0x1f1: 0，写0x1f2: 要读的扇区数，写0x1f3: 扇区号，写0x1f4: 柱面的低8位，写0x1f5: 柱面的高8位，写0x1f6: 7<sub>5位,101,第4位0表示主盘,1表示从盘,3</sub>0位,磁头号，写0x1f7: 0x20为读, 0x30为写，读0x1f7: 第4位为0表示读写完成，否则要一直循环等待，读0x1f0: 每次读取1个word,反复循环，直到读完所有数据<br> <mark>24-bit LBA方式:</mark><br> 写0x1f1: 0，写0x1f2: 要读的扇区数，写0x1f3: LBA参数的0~7位，写0x1f4: LBA参数的8~15位，写0x1f5: LBA参数的16~23位，写0x1f6: 7<sub>5位,111,第4位0表示主盘,1表示从盘,3</sub>0位,LBA参数的24~27位，写0x1f7: 0x20为读, 0x30为写，读0x1f7: 第4位为0表示读写完成，否则要一直循环等待，读0x1f0: 每次读取1个word,反复循环，直到读完所有数据。</p> 
<p><strong>2.bootloader是如何加载ELF格式的OS？</strong><br> 阅读Makefile中的设置可知：e_magic，是用来判断读出来的ELF格式的文件是否为正确的格式；e_phoff，是program header表的位置偏移；e_phnum，是program header表中的入口数目；e_entry，是程序入口所对应的虚拟地址。</p> 
<p>再阅读bootmain.c代码：</p> 
<pre><code class="prism language-cpp"><span class="token keyword">void</span>
<span class="token function">bootmain</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    <span class="token comment">// read the 1st page off disk</span>
    <span class="token function">readseg</span><span class="token punctuation">(</span><span class="token punctuation">(</span>uintptr_t<span class="token punctuation">)</span>ELFHDR<span class="token punctuation">,</span> SECTSIZE <span class="token operator">*</span> <span class="token number">8</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token comment">// is this a valid ELF?</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>ELFHDR<span class="token operator">-</span><span class="token operator">&gt;</span>e_magic <span class="token operator">!=</span> ELF_MAGIC<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token keyword">goto</span> bad<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">struct</span> proghdr <span class="token operator">*</span>ph<span class="token punctuation">,</span> <span class="token operator">*</span>eph<span class="token punctuation">;</span>

    <span class="token comment">// load each program segment (ignores ph flags)</span>
    ph <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">struct</span> proghdr <span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token punctuation">(</span>uintptr_t<span class="token punctuation">)</span>ELFHDR <span class="token operator">+</span> ELFHDR<span class="token operator">-</span><span class="token operator">&gt;</span>e_phoff<span class="token punctuation">)</span><span class="token punctuation">;</span>
    eph <span class="token operator">=</span> ph <span class="token operator">+</span> ELFHDR<span class="token operator">-</span><span class="token operator">&gt;</span>e_phnum<span class="token punctuation">;</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token punctuation">;</span> ph <span class="token operator">&lt;</span> eph<span class="token punctuation">;</span> ph <span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token function">readseg</span><span class="token punctuation">(</span>ph<span class="token operator">-</span><span class="token operator">&gt;</span>p_va <span class="token operator">&amp;</span> <span class="token number">0xFFFFFF</span><span class="token punctuation">,</span> ph<span class="token operator">-</span><span class="token operator">&gt;</span>p_memsz<span class="token punctuation">,</span> ph<span class="token operator">-</span><span class="token operator">&gt;</span>p_offset<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token comment">// call the entry point from the ELF header</span>
    <span class="token comment">// note: does not return</span>
    <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token punctuation">(</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">(</span>ELFHDR<span class="token operator">-</span><span class="token operator">&gt;</span>e_entry <span class="token operator">&amp;</span> <span class="token number">0xFFFFFF</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

bad<span class="token operator">:</span>
    <span class="token function">outw</span><span class="token punctuation">(</span><span class="token number">0x8A00</span><span class="token punctuation">,</span> <span class="token number">0x8A00</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">outw</span><span class="token punctuation">(</span><span class="token number">0x8A00</span><span class="token punctuation">,</span> <span class="token number">0x8E00</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token comment">/* do nothing */</span>
    <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>总结出加载方式：<br> 首先我们从硬盘将扇区数据存到内存0x10000处，主要的是将其转换为ELF格式。<br> 之后我们需要通过存储于头部的幻数来判断ELF的格式是否正确，再根据偏移量分别把程序段的数据读取到内存中，最后根据入口信息，找到内核的入口。</p> 
<h3><a id="5_285"></a>练习5：实现函数调用堆栈跟踪函数</h3> 
<p>大部分函数的书写方式都已经在注释中加以提示，我们可以由此总结出函数设计步骤：<br> ①首先，可以通过read_ebp()和read_eip()函数来获取当前ebp寄存器和eip 寄存器的值。<br> ②可以发现ebp+12,ebp+16,ebp+20,ebp+24这四个地址正好是保存4个参数的值，我们可以通过它输出参数信息，之后我们调用函数信息输出函数。此时一个函数已经输出完毕。<br> ③要转到下一函数，每次更新ebp的值为ebp[0],更新eip的值为ebp[1]。这样就可以转到下一函数。<br> ④如果有一次进行ebp赋值时发现对应地址的值为0，表示当前函数为bootmain，这时他前面的函数已经输出完了，可以退出。<br> 实现如下：</p> 
<pre><code class="prism language-cpp"><span class="token keyword">void</span>
<span class="token function">print_stackframe</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
     <span class="token comment">/* LAB1 YOUR CODE : STEP 1 */</span>
     <span class="token comment">/* (1) call read_ebp() to get the value of ebp. the type is (uint32_t);
      * (2) call read_eip() to get the value of eip. the type is (uint32_t);
      * (3) from 0 .. STACKFRAME_DEPTH
      *    (3.1) printf value of ebp, eip
      *    (3.2) (uint32_t)calling arguments [0..4] = the contents in address (uint32_t)ebp +2 [0..4]
      *    (3.3) cprintf("\n");
      *    (3.4) call print_debuginfo(eip-1) to print the C calling function name and line number, etc.
      *    (3.5) popup a calling stackframe
      *           NOTICE: the calling funciton's return addr eip  = ss:[ebp+4]
      *                   the calling funciton's ebp = ss:[ebp]
      */</span>
<span class="token keyword">uint32_t</span> ebp <span class="token operator">=</span> <span class="token function">read_ebp</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> eip <span class="token operator">=</span> <span class="token function">read_eip</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  
    <span class="token keyword">int</span> i<span class="token punctuation">,</span> j<span class="token punctuation">;</span>
    <span class="token comment">//#define STACKFRAME_DEPTH 20</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span>i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> ebp <span class="token operator">!=</span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> i <span class="token operator">&lt;</span> STACKFRAME_DEPTH<span class="token punctuation">;</span> i <span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token function">cprintf</span><span class="token punctuation">(</span><span class="token string">"ebp:0x%08x eip:0x%08x args:"</span><span class="token punctuation">,</span> ebp<span class="token punctuation">,</span> eip<span class="token punctuation">)</span><span class="token punctuation">;</span> 
        <span class="token keyword">uint32_t</span> <span class="token operator">*</span>args <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">uint32_t</span> <span class="token operator">*</span><span class="token punctuation">)</span>ebp <span class="token operator">+</span> <span class="token number">2</span><span class="token punctuation">;</span> 
        <span class="token keyword">for</span> <span class="token punctuation">(</span>j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> <span class="token number">4</span><span class="token punctuation">;</span> j <span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
            <span class="token function">cprintf</span><span class="token punctuation">(</span><span class="token string">"0x%08x "</span><span class="token punctuation">,</span> args<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span> 
        <span class="token punctuation">}</span>
        <span class="token function">cprintf</span><span class="token punctuation">(</span><span class="token string">"\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">print_debuginfo</span><span class="token punctuation">(</span>eip <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  
        eip <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">uint32_t</span> <span class="token operator">*</span><span class="token punctuation">)</span>ebp<span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span> 
        ebp <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">uint32_t</span> <span class="token operator">*</span><span class="token punctuation">)</span>ebp<span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span> 
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>执行结果如下：<br> <img src="https://images2.imgbox.com/95/67/8BSFgT3z_o.png" alt="在这里插入图片描述"></p> 
<h3><a id="6_327"></a>练习6：完善中断初始化和处理</h3> 
<p><strong>1.中断向量表中一个表项占多少字节？其中哪几位代表中断处理代码的入口？</strong><br> Mmu.h中找到中断向量表结构：</p> 
<pre><code class="prism language-cpp"><span class="token keyword">struct</span> gatedesc <span class="token punctuation">{<!-- --></span>
    <span class="token keyword">unsigned</span> gd_off_15_0 <span class="token operator">:</span> <span class="token number">16</span><span class="token punctuation">;</span>        <span class="token comment">// low 16 bits of offset in segment</span>
    <span class="token keyword">unsigned</span> gd_ss <span class="token operator">:</span> <span class="token number">16</span><span class="token punctuation">;</span>            <span class="token comment">// segment selector</span>
    <span class="token keyword">unsigned</span> gd_args <span class="token operator">:</span> <span class="token number">5</span><span class="token punctuation">;</span>            <span class="token comment">// # args, 0 for interrupt/trap gates</span>
    <span class="token keyword">unsigned</span> gd_rsv1 <span class="token operator">:</span> <span class="token number">3</span><span class="token punctuation">;</span>            <span class="token comment">// reserved(should be zero I guess)</span>
    <span class="token keyword">unsigned</span> gd_type <span class="token operator">:</span> <span class="token number">4</span><span class="token punctuation">;</span>            <span class="token comment">// type(STS_{TG,IG32,TG32})</span>
    <span class="token keyword">unsigned</span> gd_s <span class="token operator">:</span> <span class="token number">1</span><span class="token punctuation">;</span>                <span class="token comment">// must be 0 (system)</span>
    <span class="token keyword">unsigned</span> gd_dpl <span class="token operator">:</span> <span class="token number">2</span><span class="token punctuation">;</span>            <span class="token comment">// descriptor(meaning new) privilege level</span>
    <span class="token keyword">unsigned</span> gd_p <span class="token operator">:</span> <span class="token number">1</span><span class="token punctuation">;</span>                <span class="token comment">// Present</span>
    <span class="token keyword">unsigned</span> gd_off_31_16 <span class="token operator">:</span> <span class="token number">16</span><span class="token punctuation">;</span>        <span class="token comment">// high bits of offset in segment</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre> 
<p>这个表是GDT中的段描述表，提供基地址。</p> 
<pre><code class="prism language-cpp"><span class="token keyword">struct</span> segdesc <span class="token punctuation">{<!-- --></span>
    <span class="token keyword">unsigned</span> sd_lim_15_0 <span class="token operator">:</span> <span class="token number">16</span><span class="token punctuation">;</span>        <span class="token comment">// low bits of segment limit</span>
    <span class="token keyword">unsigned</span> sd_base_15_0 <span class="token operator">:</span> <span class="token number">16</span><span class="token punctuation">;</span>        <span class="token comment">// low bits of segment base address</span>
    <span class="token keyword">unsigned</span> sd_base_23_16 <span class="token operator">:</span> <span class="token number">8</span><span class="token punctuation">;</span>        <span class="token comment">// middle bits of segment base address</span>
    <span class="token keyword">unsigned</span> sd_type <span class="token operator">:</span> <span class="token number">4</span><span class="token punctuation">;</span>            <span class="token comment">// segment type (see STS_ constants)</span>
    <span class="token keyword">unsigned</span> sd_s <span class="token operator">:</span> <span class="token number">1</span><span class="token punctuation">;</span>                <span class="token comment">// 0 = system, 1 = application</span>
    <span class="token keyword">unsigned</span> sd_dpl <span class="token operator">:</span> <span class="token number">2</span><span class="token punctuation">;</span>            <span class="token comment">// descriptor Privilege Level</span>
    <span class="token keyword">unsigned</span> sd_p <span class="token operator">:</span> <span class="token number">1</span><span class="token punctuation">;</span>                <span class="token comment">// present</span>
    <span class="token keyword">unsigned</span> sd_lim_19_16 <span class="token operator">:</span> <span class="token number">4</span><span class="token punctuation">;</span>        <span class="token comment">// high bits of segment limit</span>
    <span class="token keyword">unsigned</span> sd_avl <span class="token operator">:</span> <span class="token number">1</span><span class="token punctuation">;</span>            <span class="token comment">// unused (available for software use)</span>
    <span class="token keyword">unsigned</span> sd_rsv1 <span class="token operator">:</span> <span class="token number">1</span><span class="token punctuation">;</span>            <span class="token comment">// reserved</span>
    <span class="token keyword">unsigned</span> sd_db <span class="token operator">:</span> <span class="token number">1</span><span class="token punctuation">;</span>                <span class="token comment">// 0 = 16-bit segment, 1 = 32-bit segment</span>
    <span class="token keyword">unsigned</span> sd_g <span class="token operator">:</span> <span class="token number">1</span><span class="token punctuation">;</span>                <span class="token comment">// granularity: limit scaled by 4K when set</span>
    <span class="token keyword">unsigned</span> sd_base_31_24 <span class="token operator">:</span> <span class="token number">8</span><span class="token punctuation">;</span>        <span class="token comment">// high bits of segment base address</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre> 
<p>中断向量表一个表项占用8字节，（16+16）/4=8.<br> <img src="https://images2.imgbox.com/a1/63/fE3tHnwK_o.png" alt="在这里插入图片描述"><br> <strong>入口说明：</strong> 其中2-3字节是用于找到段，通过段选择子去GDT中找到对应的基地址，之后是偏移量，我认为是前半段的最后两个字节是偏移量，之后发现0-1字节也是，然后基地址加上偏移量就是中断处理程序的地址。</p> 
<p><strong>2.请编程完善kern/trap/trap.c中对中断向量表进行初始化的函数idt_init。</strong><br> 要用到的setgate宏定义如下：</p> 
<pre><code class="prism language-cpp"><span class="token macro property">#<span class="token directive keyword">define</span> SETGATE(gate, istrap, sel, off, dpl) {            </span>
    <span class="token punctuation">(</span>gate<span class="token punctuation">)</span><span class="token punctuation">.</span>gd_off_15_0 <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">uint32_t</span><span class="token punctuation">)</span><span class="token punctuation">(</span>off<span class="token punctuation">)</span> <span class="token operator">&amp;</span> <span class="token number">0xffff</span><span class="token punctuation">;</span>        
    <span class="token punctuation">(</span>gate<span class="token punctuation">)</span><span class="token punctuation">.</span>gd_ss <span class="token operator">=</span> <span class="token punctuation">(</span>sel<span class="token punctuation">)</span><span class="token punctuation">;</span>                                
    <span class="token punctuation">(</span>gate<span class="token punctuation">)</span><span class="token punctuation">.</span>gd_args <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>                                    
    <span class="token punctuation">(</span>gate<span class="token punctuation">)</span><span class="token punctuation">.</span>gd_rsv1 <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>                                    
    <span class="token punctuation">(</span>gate<span class="token punctuation">)</span><span class="token punctuation">.</span>gd_type <span class="token operator">=</span> <span class="token punctuation">(</span>istrap<span class="token punctuation">)</span> <span class="token operator">?</span> STS_TG32 <span class="token operator">:</span> STS_IG32<span class="token punctuation">;</span>    
    <span class="token punctuation">(</span>gate<span class="token punctuation">)</span><span class="token punctuation">.</span>gd_s <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>                                    
    <span class="token punctuation">(</span>gate<span class="token punctuation">)</span><span class="token punctuation">.</span>gd_dpl <span class="token operator">=</span> <span class="token punctuation">(</span>dpl<span class="token punctuation">)</span><span class="token punctuation">;</span>                                
    <span class="token punctuation">(</span>gate<span class="token punctuation">)</span><span class="token punctuation">.</span>gd_p <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>                                    
    <span class="token punctuation">(</span>gate<span class="token punctuation">)</span><span class="token punctuation">.</span>gd_off_31_16 <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">uint32_t</span><span class="token punctuation">)</span><span class="token punctuation">(</span>off<span class="token punctuation">)</span> <span class="token operator">&gt;&gt;</span> <span class="token number">16</span><span class="token punctuation">;</span>        
<span class="token punctuation">}</span>
</code></pre> 
<p>这些门实际上是为后面做索引使用，观察上述setgate宏的参数，分别表示陷阱表程序所需信息，宏之内的正是各种参数，包括选择子，是否陷阱的标志，特权优先级,偏移量等。</p> 
<p>因此算法思想设计如下：<br> ①首先保存vectors.S中的中断处理例程的入口地址数组。<br> ②填写陷阱表各个表项，IDT表项的个数是idt除以宏数量，对中断描述符表中的每一个表项进行设置，即填写各种陷阱程序的信息。在中断描述符表中通过建立中断描述符，其中存储了中断处理例程的代码段和偏移量，特权级。这样通过查询idt[i]就可定位到中断服务例程的起始地址。<br> ③建立好中断门描述表后，通过指令lidt把中断门描述符表的起始地址装入IDTR寄存器中，从而完成中段描述符表的初始化工作。</p> 
<pre><code class="prism language-cpp"><span class="token function">dt_init</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
<span class="token keyword">extern</span> uintptr_t __vectors<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>  
    <span class="token keyword">int</span> i<span class="token punctuation">;</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span>i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>idt<span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">struct</span> gatedesc<span class="token punctuation">)</span><span class="token punctuation">;</span> i <span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span> 
     <span class="token function">SETGATE</span><span class="token punctuation">(</span>idt<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> GD_KTEXT<span class="token punctuation">,</span> __vectors<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> DPL_KERNEL<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token function">SETGATE</span><span class="token punctuation">(</span>idt<span class="token punctuation">[</span>T_SWITCH_TOK<span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> GD_KTEXT<span class="token punctuation">,</span>     
    __vectors<span class="token punctuation">[</span>T_SWITCH_TOK<span class="token punctuation">]</span><span class="token punctuation">,</span> DPL_USER<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">lidt</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>idt_pd<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p><strong>3.请编程完善trap.c中的中断处理函数trap，在对时钟中断进行处理的部分填写trap函数。</strong><br> 函数设计思想：这个函数比较简单，每次到时钟中断处理程序，都将tickets变量加1，每次积满100时就输出一次tickets。这样可以验证时钟中断的功能。</p> 
<pre><code class="prism language-cpp"><span class="token keyword">case</span> IRQ_OFFSET <span class="token operator">+</span> IRQ_TIMER<span class="token operator">:</span>
        <span class="token comment">/* LAB1 YOUR CODE : STEP 3 */</span>
        <span class="token comment">/* handle the timer interrupt */</span>
        <span class="token comment">/* (1) After a timer interrupt, you should record this event using a global variable (increase it), such as ticks in kern/driver/clock.c
         * (2) Every TICK_NUM cycle, you can print some info using a funciton, such as print_ticks().
         * (3) Too Simple? Yes, I think so!
         */</span>
        ticks <span class="token operator">++</span><span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>ticks <span class="token operator">%</span> TICK_NUM <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
            <span class="token function">print_ticks</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">break</span><span class="token punctuation">;</span>
</code></pre> 
<p>验证结果如下：<br> <img src="https://images2.imgbox.com/2b/d0/FuBWNv1F_o.png" alt="在这里插入图片描述"></p> 
<h3><a id="_420"></a>扩展练习</h3> 
<p><strong>CHALLENGE1</strong><br> switchto* 函数建议通过 中断处理的方式实现。主要要完成的代码是在 trap 里面处理 T_SWITCH_TO* 中断，并设置好返回的状态。函数思想是首先在函数外先定义好switchk2u，作用是保存tf，解决的情况是tf_cs不等于用户的cs，switchk2u保存tf，但是他的cs设置为用户的cs，他的ds,es,ss设置为用户的DS，标志设置和FL的标志相或，能够包含此标志。书写代码如下：</p> 
<pre><code class="prism language-cpp"><span class="token keyword">case</span> T_SWITCH_TOU<span class="token operator">:</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>tf<span class="token operator">-</span><span class="token operator">&gt;</span>tf_cs <span class="token operator">!=</span> USER_CS<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
            switchk2u <span class="token operator">=</span> <span class="token operator">*</span>tf<span class="token punctuation">;</span>
            switchk2u<span class="token punctuation">.</span>tf_cs <span class="token operator">=</span> USER_CS<span class="token punctuation">;</span>
            switchk2u<span class="token punctuation">.</span>tf_ds <span class="token operator">=</span> switchk2u<span class="token punctuation">.</span>tf_es <span class="token operator">=</span> switchk2u<span class="token punctuation">.</span>tf_ss <span class="token operator">=</span> USER_DS<span class="token punctuation">;</span>
            switchk2u<span class="token punctuation">.</span>tf_esp <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">uint32_t</span><span class="token punctuation">)</span>tf <span class="token operator">+</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">struct</span> trapframe<span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">8</span><span class="token punctuation">;</span>
            switchk2u<span class="token punctuation">.</span>tf_eflags <span class="token operator">|</span><span class="token operator">=</span> FL_IOPL_MASK<span class="token punctuation">;</span>
            <span class="token operator">*</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">uint32_t</span> <span class="token operator">*</span><span class="token punctuation">)</span>tf <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">uint32_t</span><span class="token punctuation">)</span><span class="token operator">&amp;</span>switchk2u<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">break</span><span class="token punctuation">;</span>
</code></pre> 
<p>输入make grade之后结果，得分为40，满分，发现构造函数正确。<br> <img src="https://images2.imgbox.com/38/39/qCx3CtNt_o.png" alt="在这里插入图片描述"><br> <strong>challenge2</strong><br> 用键盘实现用户模式内核模式切换。具体目标是：“键盘输入3时切换到用户模式，键盘输入0时切换到内核模式”。 基本思路是借鉴软中断(syscall功能)的代码，并且把trap.c中软中断处理的设置语句拿过来。</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/4894c86f3503dacf93bb48b42dec4c6a/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">excel 将毫秒时间格式转化为 年月日时分秒</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/9f5538137092db96a4374a6e02b40ede/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">减少图片内存对小程序的限制</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>