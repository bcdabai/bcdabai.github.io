<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>网络传输层协议详解(TCP/UDP) - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="网络传输层协议详解(TCP/UDP)" />
<meta property="og:description" content="目录
一、TCP协议
1.1、TCP协议段格式 1.2、TCP原理 确认应答机制
超时重传机制 (安全机制)
连接管理机制(安全机制) 滑动窗口 流量控制(安全机制) 拥塞控制 延迟应答(效率机制)
捎带应答（效率机制） ​编辑面向字节流(粘包问题) 缓冲区 TCP异常情况 二、UDP协议
UDP协议端格式 UDP的特点 无连接 不可靠 面向数据报 缓冲区
大小受限 基于UDP的应用层协议 三、TCP和UDP对比 一、TCP协议 TCP，即Transmission Control Protocol,传输协议控制。就是对数据的传输进行一个详细的控制。
1.1、TCP协议段格式 源/目的端口号：表示数据从哪个进程进来，到哪个进程出去。32位序号/32位确认号：一次TCP通信，从TCP建立连接到断开的过程中，某个传输方向上的字节流的每个字节的编号。4位TCP报头长度：表示该TCP头部有多少个32位bit(有多少个4字节)；所以TCP头部最大长度是15*4=606为标志位： *URG：紧急指针是否有效
*ACK：确认号是否有效
*PSH：提示接收端应用程序立刻从TCP缓冲区把数据读走
*PST：对方要求重新建立连接；我们把携带RST标识的称为复位报文段
*SYN：请求建立连接；我们把携带SYN标识的称为同步报文段
*FIN：通知对方，本端要关闭了，我们把携带FIN标识的称为结束报文段
1.2、TCP原理 TCP对数据传输提供的管控机制，主要体现在两方面：安全和效率。
这些机制和多线程的设计原则类似：保证数据传输安全的前提下，尽可能地提高传输效率。
确认应答机制 TCP将每个字节的数据都进行了编号，即为序列号。
每一个ACK都带有对应的确认序列号，意思就是告诉发送者，我已经收到了哪些数据，下一次你从哪里开始发。每发一条数据，都会接收到一个应答信息，如此循环，直到通信结束。
超时重传机制 (安全机制) 数据在网络上传输会经过很多设备，比如有交换机，路由器，每个设备都是由处理上线的，如果某一个设备达到上限，可能会把当前数据丢弃，从而出现超时现象。
1、发送超时 主机A发送数据给B之后，可能因为网络拥堵原因，导致数据无法到达主机B。如果主机A在一个特定的时间间隔内没有收到B发送来的确认应答，就会进行重发。 2、接收到数据，但是ACK（响应）丢了 因此主机B会收到很多重复数据。那么TCP协议需要能够识别出那些包是重复的包，并把重复的数据丢弃掉。
根据序列号，做到去重的效果，那么，超时的时间如何确定？
最理想的情况下，找到一个最大的时间，保证&#34;确认应答一定能在这个时间内返回&#34;。但是这个时间的长短，随网络环境不同，是有差异的。如果超时时间设的太长，会影响整体的重传效率。如果超时时间设的太短，有可能就会频繁发送重复的包。 TCP为了能够保证在任何环境下都能比较高性能的通信，因此会动态的计算这个最大超时时间。
Linux中(BSD Unix和Windows也是如此)，超时以500ms作为一个单位进行控制，每次判定超时重传的超时时间都是500ms的整数倍。如果重发一次后仍然得不到应答，等待2*500ms后再进行重传。如果仍然得不到应答，等待4*500ms后再进行重传。依次类推，以指数形式递增。累计到一定的重传次数，TCP认为网络或对端主机出现异常，强制关闭连接。 连接管理机制(安全机制) 在正常情况下，TCP要经过三次握手建立连接，四次挥手断开连接 三次握手
保证双方的收发能力 四次挥手 保证发送方和接收方发送完数据有效的断开连接
下面是三次握手、四次挥手流程图
服务端状态转化：
[CLOSED -&gt; LISTEN] 服务器端调用listen后进入LISTEN状态，等待客户端连接；[LISTEN -&gt; SYN_RCVD] 一旦监听到连接请求（同步报文段），就将该连接放入内核等待队列中，并向客户端发送SYN确认报文。[SYN_RCVD -&gt; ESTABLISHED] 服务端一旦收到客户端的确认报文，就进入ESTABLISHED状态，可以进行读写数据了。[ESTABLISHED -&gt; CLOSE_WAIT] 当客户端主动关闭连接（调用close），服务器会收到结束报文段，服务器返回确认报文段并进入CLOSE_WAIT；[CLOSE_WAIT -&gt; LAST_ACK] 进入CLOSE_WAIT后说明服务器准备关闭连接（需要处理完之前的数据）；当服务器真正调用close关闭连接时，会向客户端发送FIN，此时服务器进入LAST_ACK状态，等待最后一个ACK到来（这个ACK是客户端确认收到了FIN）[LAST_ACK -&gt; CLOSED] 服务器收到了对FIN的ACK，彻底关闭连接。 客户端状态转化：" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/c7b0c0d24ff35ee44465370af1688114/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-07-11T08:00:00+08:00" />
<meta property="article:modified_time" content="2023-07-11T08:00:00+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">网络传输层协议详解(TCP/UDP)</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p id="main-toc"><strong>目录</strong></p> 
<p id="%E4%B8%80%E3%80%81TCP%E5%8D%8F%E8%AE%AE-toc" style="margin-left:40px;"><a href="#%E4%B8%80%E3%80%81TCP%E5%8D%8F%E8%AE%AE" rel="nofollow">一、TCP协议</a></p> 
<p id="1.1%E3%80%81TCP%E5%8D%8F%E8%AE%AE%E6%AE%B5%E6%A0%BC%E5%BC%8F%C2%A0-toc" style="margin-left:80px;"><a href="#1.1%E3%80%81TCP%E5%8D%8F%E8%AE%AE%E6%AE%B5%E6%A0%BC%E5%BC%8F%C2%A0" rel="nofollow">1.1、TCP协议段格式 </a></p> 
<p id="1.2%E3%80%81TCP%E5%8E%9F%E7%90%86%C2%A0-toc" style="margin-left:80px;"><a href="#1.2%E3%80%81TCP%E5%8E%9F%E7%90%86%C2%A0" rel="nofollow">1.2、TCP原理 </a></p> 
<p id="%E7%A1%AE%E8%AE%A4%E5%BA%94%E7%AD%94%E6%9C%BA%E5%88%B6-toc" style="margin-left:120px;"><a href="#%E7%A1%AE%E8%AE%A4%E5%BA%94%E7%AD%94%E6%9C%BA%E5%88%B6" rel="nofollow">确认应答机制</a></p> 
<p id="%E8%B6%85%E6%97%B6%E9%87%8D%E4%BC%A0%E6%9C%BA%E5%88%B6%20(%E5%AE%89%E5%85%A8%E6%9C%BA%E5%88%B6)-toc" style="margin-left:120px;"><a href="#%E8%B6%85%E6%97%B6%E9%87%8D%E4%BC%A0%E6%9C%BA%E5%88%B6%20%28%E5%AE%89%E5%85%A8%E6%9C%BA%E5%88%B6%29" rel="nofollow">超时重传机制 (安全机制)</a></p> 
<p id="%E8%BF%9E%E6%8E%A5%E7%AE%A1%E7%90%86%E6%9C%BA%E5%88%B6(%E5%AE%89%E5%85%A8%E6%9C%BA%E5%88%B6)%C2%A0-toc" style="margin-left:120px;"><a href="#%E8%BF%9E%E6%8E%A5%E7%AE%A1%E7%90%86%E6%9C%BA%E5%88%B6%28%E5%AE%89%E5%85%A8%E6%9C%BA%E5%88%B6%29%C2%A0" rel="nofollow">连接管理机制(安全机制) </a></p> 
<p id="%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%C2%A0-toc" style="margin-left:120px;"><a href="#%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%C2%A0" rel="nofollow">滑动窗口 </a></p> 
<p id="%E6%B5%81%E9%87%8F%E6%8E%A7%E5%88%B6(%E5%AE%89%E5%85%A8%E6%9C%BA%E5%88%B6)%C2%A0-toc" style="margin-left:120px;"><a href="#%E6%B5%81%E9%87%8F%E6%8E%A7%E5%88%B6%28%E5%AE%89%E5%85%A8%E6%9C%BA%E5%88%B6%29%C2%A0" rel="nofollow">流量控制(安全机制) </a></p> 
<p id="%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6%C2%A0-toc" style="margin-left:120px;"><a href="#%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6%C2%A0" rel="nofollow">拥塞控制 </a></p> 
<p id="%E5%BB%B6%E8%BF%9F%E5%BA%94%E7%AD%94(%E6%95%88%E7%8E%87%E6%9C%BA%E5%88%B6)-toc" style="margin-left:120px;"><a href="#%E5%BB%B6%E8%BF%9F%E5%BA%94%E7%AD%94%28%E6%95%88%E7%8E%87%E6%9C%BA%E5%88%B6%29" rel="nofollow">延迟应答(效率机制)</a></p> 
<p id="%E6%8D%8E%E5%B8%A6%E5%BA%94%E7%AD%94%EF%BC%88%E6%95%88%E7%8E%87%E6%9C%BA%E5%88%B6%EF%BC%89%C2%A0-toc" style="margin-left:120px;"><a href="#%E6%8D%8E%E5%B8%A6%E5%BA%94%E7%AD%94%EF%BC%88%E6%95%88%E7%8E%87%E6%9C%BA%E5%88%B6%EF%BC%89%C2%A0" rel="nofollow">捎带应答（效率机制） </a></p> 
<p id="%E2%80%8B%E7%BC%96%E8%BE%91%E9%9D%A2%E5%90%91%E5%AD%97%E8%8A%82%E6%B5%81(%E7%B2%98%E5%8C%85%E9%97%AE%E9%A2%98)%C2%A0-toc" style="margin-left:120px;"><a href="#%E2%80%8B%E7%BC%96%E8%BE%91%E9%9D%A2%E5%90%91%E5%AD%97%E8%8A%82%E6%B5%81%28%E7%B2%98%E5%8C%85%E9%97%AE%E9%A2%98%29%C2%A0" rel="nofollow">​编辑面向字节流(粘包问题) </a></p> 
<p id="%E7%BC%93%E5%86%B2%E5%8C%BA%C2%A0-toc" style="margin-left:120px;"><a href="#%E7%BC%93%E5%86%B2%E5%8C%BA%C2%A0" rel="nofollow">缓冲区 </a></p> 
<p id="TCP%E5%BC%82%E5%B8%B8%E6%83%85%E5%86%B5%C2%A0-toc" style="margin-left:120px;"><a href="#TCP%E5%BC%82%E5%B8%B8%E6%83%85%E5%86%B5%C2%A0" rel="nofollow">TCP异常情况 </a></p> 
<p id="%E4%BA%8C%E3%80%81UDP%E5%8D%8F%E8%AE%AE-toc" style="margin-left:40px;"><a href="#%E4%BA%8C%E3%80%81UDP%E5%8D%8F%E8%AE%AE" rel="nofollow">二、UDP协议</a></p> 
<p id="UDP%E5%8D%8F%E8%AE%AE%E7%AB%AF%E6%A0%BC%E5%BC%8F%C2%A0-toc" style="margin-left:80px;"><a href="#UDP%E5%8D%8F%E8%AE%AE%E7%AB%AF%E6%A0%BC%E5%BC%8F%C2%A0" rel="nofollow">UDP协议端格式 </a></p> 
<p id="UDP%E7%9A%84%E7%89%B9%E7%82%B9%C2%A0-toc" style="margin-left:80px;"><a href="#UDP%E7%9A%84%E7%89%B9%E7%82%B9%C2%A0" rel="nofollow">UDP的特点 </a></p> 
<p id="%E6%97%A0%E8%BF%9E%E6%8E%A5%C2%A0-toc" style="margin-left:120px;"><a href="#%E6%97%A0%E8%BF%9E%E6%8E%A5%C2%A0" rel="nofollow">无连接 </a></p> 
<p id="%E4%B8%8D%E5%8F%AF%E9%9D%A0%C2%A0-toc" style="margin-left:120px;"><a href="#%E4%B8%8D%E5%8F%AF%E9%9D%A0%C2%A0" rel="nofollow">不可靠 </a></p> 
<p id="%E9%9D%A2%E5%90%91%E6%95%B0%E6%8D%AE%E6%8A%A5%C2%A0-toc" style="margin-left:120px;"><a href="#%E9%9D%A2%E5%90%91%E6%95%B0%E6%8D%AE%E6%8A%A5%C2%A0" rel="nofollow">面向数据报 </a></p> 
<p id="%E7%BC%93%E5%86%B2%E5%8C%BA-toc" style="margin-left:120px;"><a href="#%E7%BC%93%E5%86%B2%E5%8C%BA" rel="nofollow">缓冲区</a></p> 
<p id="%E5%A4%A7%E5%B0%8F%E5%8F%97%E9%99%90%C2%A0-toc" style="margin-left:120px;"><a href="#%E5%A4%A7%E5%B0%8F%E5%8F%97%E9%99%90%C2%A0" rel="nofollow">大小受限 </a></p> 
<p id="%E5%9F%BA%E4%BA%8EUDP%E7%9A%84%E5%BA%94%E7%94%A8%E5%B1%82%E5%8D%8F%E8%AE%AE%C2%A0-toc" style="margin-left:80px;"><a href="#%E5%9F%BA%E4%BA%8EUDP%E7%9A%84%E5%BA%94%E7%94%A8%E5%B1%82%E5%8D%8F%E8%AE%AE%C2%A0" rel="nofollow">基于UDP的应用层协议 </a></p> 
<p id="%E4%B8%89%E3%80%81TCP%E5%92%8CUDP%E5%AF%B9%E6%AF%94%C2%A0-toc" style="margin-left:40px;"><a href="#%E4%B8%89%E3%80%81TCP%E5%92%8CUDP%E5%AF%B9%E6%AF%94%C2%A0" rel="nofollow">三、TCP和UDP对比 </a></p> 
<hr id="hr-toc"> 
<p></p> 
<h3>一、TCP协议</h3> 
<p>TCP，即Transmission Control Protocol,传输协议控制。就是对数据的传输进行一个详细的控制。</p> 
<h4 id="1.1%E3%80%81TCP%E5%8D%8F%E8%AE%AE%E6%AE%B5%E6%A0%BC%E5%BC%8F%C2%A0">1.1、TCP协议段格式 </h4> 
<p><img alt="" height="594" src="https://images2.imgbox.com/29/43/rQQVQnBH_o.png" width="953"></p> 
<blockquote> 
 <ul><li>源/目的端口号：表示数据从哪个进程进来，到哪个进程出去。</li><li>32位序号/32位确认号：一次TCP通信，从TCP建立连接到断开的过程中，某个传输方向上的字节流的每个字节的编号。</li><li>4位TCP报头长度：表示该TCP头部有多少个32位bit(有多少个4字节)；所以TCP头部最大长度是15*4=60</li><li>6为标志位：  </li></ul> 
 <p>              *URG：紧急指针是否有效</p> 
 <p>              *ACK：确认号是否有效</p> 
 <p>              *PSH：提示接收端应用程序立刻从TCP缓冲区把数据读走</p> 
 <p>              *PST：对方要求重新建立连接；我们把携带RST标识的称为<strong>复位报文段</strong></p> 
 <p>              *SYN：请求建立连接；我们把携带SYN标识的称为<strong>同步报文段</strong></p> 
 <p>              *FIN：通知对方，本端要关闭了，我们把携带FIN标识的称为<strong>结束报文段</strong></p> 
</blockquote> 
<h4 id="1.2%E3%80%81TCP%E5%8E%9F%E7%90%86%C2%A0">1.2、TCP原理 </h4> 
<p>TCP对数据传输提供的管控机制，主要体现在两方面：<span style="color:#a2e043;"><strong>安全和效率</strong></span>。</p> 
<p>这些机制和多线程的设计原则类似：保证数据传输安全的前提下，尽可能地提高传输效率。</p> 
<h5 id="%E7%A1%AE%E8%AE%A4%E5%BA%94%E7%AD%94%E6%9C%BA%E5%88%B6">确认应答机制</h5> 
<p><img alt="" height="646" src="https://images2.imgbox.com/b0/47/ylv7DRRP_o.png" width="667"></p> 
<p>TCP将每个字节的数据都进行了编号，即为序列号。</p> 
<p><img alt="" height="323" src="https://images2.imgbox.com/1a/a6/tsk9XckF_o.png" width="1165"></p> 
<p>每一个ACK都带有对应的确认序列号，意思就是告诉发送者，我已经收到了哪些数据，下一次你从哪里开始发。<strong><span style="color:#fe2c24;">每发一条数据，都会接收到一个应答信息，如此循环，直到通信结束。</span></strong></p> 
<p><img alt="" height="259" src="https://images2.imgbox.com/f9/2f/l9renPXb_o.png" width="721"></p> 
<h5 id="%E8%B6%85%E6%97%B6%E9%87%8D%E4%BC%A0%E6%9C%BA%E5%88%B6%20(%E5%AE%89%E5%85%A8%E6%9C%BA%E5%88%B6)">超时重传机制 (安全机制)</h5> 
<p>数据在网络上传输会经过很多设备，比如有交换机，路由器，每个设备都是由处理上线的，如果某一个设备达到上限，可能会把当前数据丢弃，从而出现超时现象。</p> 
<p><strong>1、发送超时 </strong></p> 
<p><img alt="" height="639" src="https://images2.imgbox.com/c7/03/RWYOw35C_o.png" width="683"></p> 
<blockquote> 
 <ul><li>主机A发送数据给B之后，可能因为网络拥堵原因，导致数据无法到达主机B。</li><li>如果主机A在一个特定的时间间隔内没有收到B发送来的确认应答，就会进行重发。 </li></ul> 
</blockquote> 
<p><strong>2、接收到数据，但是ACK（响应）丢了 </strong></p> 
<p><img alt="" height="644" src="https://images2.imgbox.com/8c/3d/7y7tz2m0_o.png" width="673"></p> 
<p>因此主机B会收到很多重复数据。那么TCP协议需要能够识别出那些包是重复的包，并把重复的数据丢弃掉。</p> 
<p>根据<span style="color:#ff9900;"><strong>序列号</strong></span>，做到去重的效果，那么，超时的时间如何确定？</p> 
<blockquote> 
 <ul><li>最理想的情况下，找到一个最大的时间，保证"确认应答一定能在这个时间内返回"。</li><li>但是这个时间的长短，随网络环境不同，是有差异的。</li><li>如果超时时间设的太长，会影响整体的重传效率。</li><li>如果超时时间设的太短，有可能就会频繁发送重复的包。</li></ul> 
</blockquote> 
<p> TCP为了能够保证在任何环境下都能比较高性能的通信，因此会动态的计算这个最大超时时间。</p> 
<blockquote> 
 <ul><li>Linux中(BSD Unix和Windows也是如此)，超时以500ms作为一个单位进行控制，每次判定超时重传的超时时间都是500ms的整数倍。</li><li>如果重发一次后仍然得不到应答，等待2*500ms后再进行重传。</li><li>如果仍然得不到应答，等待4*500ms后再进行重传。依次类推，以指数形式递增。</li><li>累计到一定的重传次数，TCP认为网络或对端主机出现异常，强制关闭连接。</li></ul> 
</blockquote> 
<h5 id="%E8%BF%9E%E6%8E%A5%E7%AE%A1%E7%90%86%E6%9C%BA%E5%88%B6(%E5%AE%89%E5%85%A8%E6%9C%BA%E5%88%B6)%C2%A0">连接管理机制(安全机制) </h5> 
<p>在正常情况下，TCP要经过三次握手建立连接，四次挥手断开连接 </p> 
<p><strong>三次握手</strong></p> 
<p>保证双方的收发能力 </p> 
<p><img alt="" height="1200" src="https://images2.imgbox.com/e1/32/TVCxAiF6_o.png" width="1200"><img alt="" height="284" src="https://images2.imgbox.com/92/af/ZE8Wj5Ej_o.png" width="1200"><strong>四次挥手</strong> </p> 
<p>保证发送方和接收方发送完数据有效的断开连接</p> 
<p><img alt="" height="754" src="https://images2.imgbox.com/af/99/DH71pP38_o.png" width="1200"></p> 
<p><img alt="" height="638" src="https://images2.imgbox.com/4c/dd/gsq9TZpR_o.png" width="1200"></p> 
<p><img alt="" height="241" src="https://images2.imgbox.com/d5/2b/OSjt2woU_o.png" width="1056"> <strong>下面是三次握手、四次挥手流程图</strong></p> 
<p><img alt="" height="838" src="https://images2.imgbox.com/bb/2c/FQpahhaR_o.png" width="1028"></p> 
<p>服务端状态转化：</p> 
<blockquote> 
 <ul><li>[CLOSED -&gt; LISTEN] 服务器端调用listen后进入LISTEN状态，等待客户端连接；</li><li>[LISTEN -&gt; SYN_RCVD] 一旦监听到连接请求（同步报文段），就将该连接放入内核等待队列中，并向客户端发送SYN确认报文。</li><li>[SYN_RCVD -&gt; ESTABLISHED] 服务端一旦收到客户端的确认报文，就进入ESTABLISHED状态，可以进行读写数据了。</li><li>[ESTABLISHED -&gt; CLOSE_WAIT] 当客户端主动关闭连接（调用close），服务器会收到结束报文段，服务器返回确认报文段并进入CLOSE_WAIT；</li><li>[CLOSE_WAIT -&gt; LAST_ACK] 进入CLOSE_WAIT后说明服务器准备关闭连接（需要处理完之前的数据）；当服务器真正调用close关闭连接时，会向客户端发送FIN，此时服务器进入LAST_ACK状态，等待最后一个ACK到来（这个ACK是客户端确认收到了FIN）</li><li>[LAST_ACK -&gt; CLOSED] 服务器收到了对FIN的ACK，彻底关闭连接。 </li></ul> 
</blockquote> 
<p>客户端状态转化：</p> 
<blockquote> 
 <ul><li>[CLOSED -&gt; SYN_SENT] 客户端调用connect，发送同步报文段；</li><li>[SYN_SENT -&gt; ESTABLISHED] connect调用成功，则进入ESTABLISHED状态，开始读写数据；</li><li>[ESTABLISHED -&gt; FIN_WAIT_1] 客户端主动调用close时，向服务器发送结束报文段，同时进入FIN_WAIT_1；</li><li>[FIN_WAIT_1 -&gt; FIN_WAIT_2] 客户端收到服务器对结束报文段的确认，则进FIN_WAIT_2，开始等待服务器的结束报文段；</li><li>[FIN_WAIT_2 -&gt; TIME_WAIT] 客户端收到服务器发来的结束报文段，进入TIME_WAIT，并发出LAST_ACK；</li><li>[TIME_WAIT -&gt; CLOSED] 客户端要等待一个2MSL（Max Segment Life，报文最大生存时间）的时间，才会进入CLOSED状态。</li></ul> 
</blockquote> 
<p>为什么TIME_WAIT的时间是2MSL？</p> 
<blockquote> 
 <ul><li>MSL是TCP报文的最大生存时间，因此TIME_WAIT持续存在2MSL的话</li><li>就能保证在两个传输方向上的尚未被接收或迟到的报文段都已经消失（否则服务器立刻重启，可能会收到来自上一个进程的迟到的数据，但是这种数据很可能是错误的）；</li><li>同时也是在理论上保证最后一个报文可靠到达（假设最后一个ACK丢失，那么服务器会再重发一个FIN。这时虽然客户端的进程不在了，但是TCP连接还在，仍然可以重发LAST_ACK）；  </li></ul> 
</blockquote> 
<p>ClOSE_WAIT</p> 
<p>一般而言，对于服务器上出现大量的 CLOSE_WAIT 状态，原因就是服务器没有正确的关闭 socket，导致四次挥手没有正确完成。这是一个 BUG。只需要加上对应的 close 即可解决问题。 </p> 
<h5 id="%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%C2%A0">滑动窗口 </h5> 
<p>对每一个发送的数据段，都要给一个ACK确认应答。收到ACK后再发送下一个数据段。这样做有一个比较大的缺点，就是性能较差。尤其是数据往返的时间较长的时候。 </p> 
<p><img alt="" height="708" src="https://images2.imgbox.com/8a/22/XgKES40v_o.png" width="824">既然这样一发一收的方式性能较低，那么我们一次发送多条数据，就可以大大的提高性能（其实是将多个段的等待时间重叠在一起了）。 </p> 
<p><img alt="" height="526" src="https://images2.imgbox.com/9c/e3/w1NPk14i_o.png" width="795"></p> 
<p><img alt="" height="1061" src="https://images2.imgbox.com/c9/cf/Ir22t1iy_o.png" width="1179"></p> 
<blockquote> 
 <ul><li>窗口大小指的是无需等待确认应答而可以继续发送数据的最大值。上图的窗口大小就是4000个字节（四个段）。</li><li>发送前四个段的时候，不需要等待任何ACK，直接发送；</li><li>收到第一个ACK后，滑动窗口向后移动，继续发送第五个段的数据，依次类推；</li><li>操作系统内核为了维护这个滑动窗口，需要开辟 发送缓冲区 来记录当前还有哪些数据没有应答；只有确认应答过的数据，才能从缓冲区删掉；</li><li>窗口越大，则网络的吞吐率就越高； </li></ul> 
</blockquote> 
<p><strong>针对滑动窗口可以预见两种异常</strong></p> 
<p><strong><span style="color:#fe2c24;">1、ACK丢包</span></strong></p> 
<p><img alt="" height="667" src="https://images2.imgbox.com/11/9f/SBr8H6Vc_o.png" width="1106"></p> 
<p>这种情况下，丢包并不要紧，因为可以通过后续的ACK进行确认。</p> 
<p><span style="color:#fe2c24;"><strong>2、数据报直接丢了</strong></span> </p> 
<p><img alt="" height="755" src="https://images2.imgbox.com/b3/cc/tjZzZmQz_o.png" width="1162"></p> 
<blockquote> 
 <ul><li>当某一段报文段丢失之后，发送端会一直收到 1001 这样的ACK，就像是在提醒发送端 "我想要的是 1001" 一样；</li><li>如果发送端主机连续三次收到了同样一个 "1001" 这样的应答，就会将对应的数据 1001 -2000 重新发送；</li><li>这个时候接收端收到了 1001 之后，再次返回的ACK就是7001了（因为2001 - 7000）接收端其实之前就已经收到了，被放到了接收端操作系统内核的接收缓冲区中；</li></ul> 
</blockquote> 
<p>这种机制被称为“<strong>高速重发控制</strong>”，也叫“<strong>快重传</strong>”。</p> 
<h5 id="%E6%B5%81%E9%87%8F%E6%8E%A7%E5%88%B6(%E5%AE%89%E5%85%A8%E6%9C%BA%E5%88%B6)%C2%A0">流量控制(安全机制) </h5> 
<p>接收端处理数据的速度是有限的。如果发送端发的太快，导致接收端的缓冲区被打满，这个时候如果发送端继续发送，就会造成丢包，继而引起丢包重传等等一系列连锁反应。<br> 因此TCP支持根据接收端的处理能力，来决定发送端的发送速度。这个机制就叫做<strong>流量控制</strong>（Flow<br> Control）； </p> 
<p><img alt="" height="638" src="https://images2.imgbox.com/66/a2/jtQ4ts9A_o.png" width="1166"> <img alt="" height="873" src="https://images2.imgbox.com/7c/cf/2ixYVz6J_o.png" width="1076"></p> 
<p> 接收端如何把窗口大小告诉发送端呢？</p> 
<blockquote> 
 <p>回忆我们的TCP首部中，有一个16位窗口字段，就是存放了窗口大小信息；</p> 
</blockquote> 
<p>那么问题来了，16位数字最大表示65535，那么TCP窗口最大就是65535字节么？</p> 
<blockquote> 
 <p>实际上，TCP首部40字节选项中还包含了一个窗口扩大因子M，实际窗口大小是 窗口字段的值左移 M位； </p> 
</blockquote> 
<h5 id="%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6%C2%A0">拥塞控制 </h5> 
<p>虽然TCP有了滑动窗口这个大杀器，能够高效可靠的发送大量的数据。但是如果在刚开始阶段就发送大量的数据，仍然可能引发问题。<br> 因为网络上有很多的计算机，可能当前的网络状态就已经比较拥堵。在不清楚当前网络状态下，贸然发送大量的数据，是很有可能引起雪上加霜的。<br> TCP引入 慢启动 机制，先发少量的数据，探探路，摸清当前的网络拥堵状态，再决定按照多大的速度传输数据； </p> 
<p><img alt="" height="851" src="https://images2.imgbox.com/bd/4d/vs3nJFqv_o.png" width="890"></p> 
<blockquote> 
 <ul><li>此处引入一个概念程为拥塞窗口</li><li>发送开始的时候，定义拥塞窗口大小为1；</li><li>每次收到一个ACK应答，拥塞窗口加1；</li><li>每次发送数据包的时候，将拥塞窗口和接收端主机反馈的窗口大小做比较，取较小的值作为实际发送的窗口； </li></ul> 
</blockquote> 
<p>像上面这样的拥塞窗口增长速度，是指数级别的。"慢启动" 只是指初使时慢，但是增长速度非常快。</p> 
<blockquote> 
 <ul><li>为了不增长的那么快，因此不能使拥塞窗口单纯的加倍。</li><li>此处引入一个叫做慢启动的阈值</li><li>当拥塞窗口超过这个阈值的时候，不再按照指数方式增长，而是按照线性方式增长 </li></ul> 
</blockquote> 
<p><img alt="" height="317" src="https://images2.imgbox.com/b2/0a/E3Fbuxmq_o.png" width="667"></p> 
<blockquote> 
 <ul><li>当TCP开始启动的时候，慢启动阈值等于窗口最大值；</li><li>在每次超时重发的时候，慢启动阈值会变成原来的一半，同时拥塞窗口置回1； </li></ul> 
</blockquote> 
<p>少量的丢包，我们仅仅是触发超时重传；大量的丢包，我们就认为网络拥塞；<br> 当TCP通信开始后，网络吞吐量会逐渐上升；随着网络发生拥堵，吞吐量会立刻下降；</p> 
<p>拥塞控制，归根结底是TCP协议想尽可能快的把数据传输给对方，但是又要避免给网络造成太大压力的折中方案。 </p> 
<h5 id="%E5%BB%B6%E8%BF%9F%E5%BA%94%E7%AD%94(%E6%95%88%E7%8E%87%E6%9C%BA%E5%88%B6)">延迟应答(效率机制)</h5> 
<p>如果接收数据的主机立刻返回ACK应答，这时候返回的窗口可能比较小。 </p> 
<blockquote> 
 <ul><li>假设接收端缓冲区为1M。一次收到了500K的数据；如果立刻应答，返回的窗口就是500K；</li><li>但实际上可能处理端处理的速度很快，10ms之内就把500K数据从缓冲区消费掉了；</li><li>在这种情况下，接收端处理还远没有达到自己的极限，即使窗口再放大一些，也能处理过来；</li><li>如果接收端稍微等一会再应答，比如等待200ms再应答，那么这个时候返回的窗口大小就是1M；</li></ul> 
</blockquote> 
<p>窗口越大，网络吞吐量就越大，传输效率就越高。我们的目标是在保证网络不拥塞的情况<br> 下尽量提高传输效率；</p> 
<p>那么所有的包都可以延迟应答么？肯定也不是；</p> 
<blockquote> 
 <ul><li>数量限制：每隔N个包就应答一次；</li><li>时间限制：超过最大延迟时间就应答一次； </li></ul> 
</blockquote> 
<p>具体的数量和超时时间，依操作系统不同也有差异；一般N取2，超时时间取200ms；</p> 
<p><img alt="" height="592" src="https://images2.imgbox.com/ef/8d/YLV5UzsO_o.png" width="741"></p> 
<h5 id="%E6%8D%8E%E5%B8%A6%E5%BA%94%E7%AD%94%EF%BC%88%E6%95%88%E7%8E%87%E6%9C%BA%E5%88%B6%EF%BC%89%C2%A0">捎带应答（效率机制） </h5> 
<p>在延迟应答的基础上，我们发现，很多情况下，客户端服务器在应用层也是 "一发一收" 的。意味着客户端给服务器说了 "How are you"，服务器也会给客户端回一个 "Fine, thank you"；<br> 那么这个时候ACK就可以搭顺风车，和服务器回应的 "Fine，thank you" 一起回给客户端 </p> 
<h5 id="%E2%80%8B%E7%BC%96%E8%BE%91%E9%9D%A2%E5%90%91%E5%AD%97%E8%8A%82%E6%B5%81(%E7%B2%98%E5%8C%85%E9%97%AE%E9%A2%98)%C2%A0"><img alt="" height="781" src="https://images2.imgbox.com/be/7d/W4DUnVch_o.png" width="1092">面向字节流(粘包问题) </h5> 
<p><img alt="" height="1200" src="https://images2.imgbox.com/4a/d6/ml9u7BTn_o.png" width="1200"></p> 
<h5 id="%E7%BC%93%E5%86%B2%E5%8C%BA%C2%A0">缓冲区 </h5> 
<p>创建一个TCP的socket，同时在内核中创建一个 发送缓冲区 和一个 接收缓冲区； </p> 
<blockquote> 
 <ul><li>调用write时，数据会先写入发送缓冲区中；</li><li>如果发送的字节数太长，会被拆分成多个TCP的数据包发出；</li><li>如果发送的字节数太短，就会先在缓冲区里等待，等到缓冲区长度差不多了，或者其他合适的时机发送出去；</li><li>接收数据的时候，数据也是从网卡驱动程序到达内核的接收缓冲区；</li><li>然后应用程序可以调用read从接收缓冲区拿数据；</li><li>另一方面，TCP的一个连接，既有发送缓冲区，也有接收缓冲区，那么对于这一个连接，既可以读数据，也可以写数据。这个概念叫做 全双工 </li></ul> 
</blockquote> 
<p>由于缓冲区的存在，TCP程序的读和写不需要一一匹配，例如：</p> 
<blockquote> 
 <ul><li>写100个字节数据时，可以调用一次write写100个字节，也可以调用100次write，每次写一个字节；</li><li>读100个字节数据时，也完全不需要考虑写的时候是怎么写的，既可以一次read 100个字节，也可以一次read一个字节，重复100次； </li></ul> 
</blockquote> 
<h5 id="TCP%E5%BC%82%E5%B8%B8%E6%83%85%E5%86%B5%C2%A0">TCP异常情况 </h5> 
<p>进程终止：进程终止会释放文件描述符，仍然可以发送FIN。和正常关闭没有什么区别。</p> 
<p>机器重启：和进程终止的情况相同。</p> 
<p>机器掉电/网线断开：接收端认为连接还在，一旦接收端有写入操作，接收端发现连接已经不在了，就会进行reset。即使没有写入操作，TCP自己也内置了一个保活定时器，会定期询问对方是否还在。如果对方不在，也会把连接释放。</p> 
<p>另外，应用层的某些协议，也有一些这样的检测机制。例如HTTP长连接中，也会定期检测对方的状态。例如QQ，在QQ断线之后，也会定期尝试重新连接。 </p> 
<h3 id="%E4%BA%8C%E3%80%81UDP%E5%8D%8F%E8%AE%AE">二、UDP协议</h3> 
<h4 id="UDP%E5%8D%8F%E8%AE%AE%E7%AB%AF%E6%A0%BC%E5%BC%8F%C2%A0">UDP协议端格式 </h4> 
<p><img alt="" height="364" src="https://images2.imgbox.com/b8/66/jHoEoKS8_o.png" width="970"></p> 
<blockquote> 
 <ul><li>16位UDP长度，表示整个数据报（UDP首部+UDP数据）的最大长度；</li><li>如果校验和出错，就会直接丢弃； </li></ul> 
</blockquote> 
<h4 id="UDP%E7%9A%84%E7%89%B9%E7%82%B9%C2%A0">UDP的特点 </h4> 
<p>UDP传输的过程类似于寄信。</p> 
<h5 id="%E6%97%A0%E8%BF%9E%E6%8E%A5%C2%A0">无连接 </h5> 
<p>知道对端的IP和端口号就直接进行传输，不需要建立连接；</p> 
<h5 id="%E4%B8%8D%E5%8F%AF%E9%9D%A0%C2%A0">不可靠 </h5> 
<p>没有任何安全机制，发送端发送数据报以后，如果因为网络故障该段无法发到对方，UDP协议层也不会给应用层返回任何错误信息； </p> 
<h5 id="%E9%9D%A2%E5%90%91%E6%95%B0%E6%8D%AE%E6%8A%A5%C2%A0">面向数据报 </h5> 
<p>应用层交给UDP多长的报文，UDP原样发送，既不会拆分，也不会合并；<br> 用UDP传输100个字节的数据：</p> 
<blockquote> 
 <p>如果发送端一次发送100个字节，那么接收端也必须一次接收100个字节；而不能循环接收10次，每次接收10个字节。 </p> 
</blockquote> 
<h5 id="%E7%BC%93%E5%86%B2%E5%8C%BA">缓冲区</h5> 
<p>UDP只有接收缓冲区，没有发送缓冲区：</p> 
<blockquote> 
 <ul><li>UDP没有真正意义上的 发送缓冲区。发送的数据会直接交给内核，由内核将数据传给网络层协议进行后续的传输动作；</li><li>UDP具有接收缓冲区，但是这个接收缓冲区不能保证收到的UDP报的顺序和发送UDP报的顺序一致；如果缓冲区满了，再到达的UDP数据就会被丢弃；</li></ul> 
</blockquote> 
<p>UDP的socket既能读，也能写，这个概念叫做<strong> 全双工 </strong></p> 
<h5 id="%E5%A4%A7%E5%B0%8F%E5%8F%97%E9%99%90%C2%A0">大小受限 </h5> 
<p>UDP协议首部中有一个16位的最大长度。也就是说一个UDP能传输的数据最大长度是64K（包含UDP首部）。 </p> 
<h4 id="%E5%9F%BA%E4%BA%8EUDP%E7%9A%84%E5%BA%94%E7%94%A8%E5%B1%82%E5%8D%8F%E8%AE%AE%C2%A0">基于UDP的应用层协议 </h4> 
<blockquote> 
 <ul><li>NFS：网络文件系统</li><li>TFTP：简单文件传输协议</li><li>DHCP：动态主机配置协议</li><li>BOOTP：启动协议（用于无盘设备启动）</li><li>DNS：域名解析协议 </li></ul> 
</blockquote> 
<h3 id="%E4%B8%89%E3%80%81TCP%E5%92%8CUDP%E5%AF%B9%E6%AF%94%C2%A0">三、TCP和UDP对比 </h3> 
<p>TCP是可靠连接，那么是不是TCP一定就优于UDP呢？TCP和UDP之间的优点和缺点，不能简<br> 单，绝对的进行比较</p> 
<blockquote> 
 <ul><li>TCP用于可靠传输的情况，应用于文件传输，重要状态更新等场景；</li><li>UDP用于对高速传输和实时性要求较高的通信领域，例如，早期的QQ，视频传输等。另外UDP可以用于广播； </li></ul> 
</blockquote> 
<p>归根结底，TCP和UDP都是程序员的工具，什么时机用，具体怎么用，还是要根据具体的需求场景去判定。 </p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/f5485619000bfeeed0a5c4772c909dbd/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">java用feign发请求，参数可以为一个字符串吗？</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/17ddce73daeaf5c6ca182691f7c77434/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">杰理之配置多个唤醒脚时开机唤醒时判断哪个IO唤醒【篇】</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>