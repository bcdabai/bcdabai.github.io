<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>【cmake】CMakeList添加库|添加头文件|添加路径|add_executable、add_library、target_link_libraries|添加编译选项|宏开关... - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="【cmake】CMakeList添加库|添加头文件|添加路径|add_executable、add_library、target_link_libraries|添加编译选项|宏开关..." />
<meta property="og:description" content="目录
官网查阅
开胃菜例子
CMakeLists生成和添加依赖库
CMakeLists更多小例子
生成.so共享库文件
调用.so共享库文件
生成一个可执行程序的 CMakeList
生成一个.so动态库的 CMakeList add_library(生成库)，target_link_libraries(生成目标连接的库)，set_target_properties
CMAKE 添加编译选项|-g编译参数/选项
包含文件的的目录include_directories
优化项|优化等级
Cmake设置优化等级| cmake 生成 debug和 release 版
设置默认构建类型
CMake设置编译参数/选项
如何在cmakelists中加入-ldl编译选项
CMake指定gcc,g&#43;&#43;版本编译
CMake 关闭警告的方法
关闭编译器优化
CMakeLists 实现动态宏开关
去掉编译优化
CMake--List用法
CmakeLists.txt单行注释和多行注释 CMakeList 通配符
其他未归类
add_custom_target 自定义命令
add_dependencies Cmake条件判断指令|if 判断优先级
设置编译时和程序运行时去哪个目录找动态库
#指定运行时动态库的加载路径
#指定链接时动态库的路径
cmake install 和打包设定
CMakeLists.txt单行注释和多行注释
target_link_libraries 中的PRIVATE, PUBLIC, INTERFACE 区别
作者：bandaoyu，持续更新，链接:https://blog.csdn.net/bandaoyu/article/details/115165199
官网查阅 CMake 3.22.0-rc1文档：https://cmake.org/cmake/help/latest/search.html?q=add_library
https://cmake.org/cmake/help/v3.23/manual/cmake-commands.7.html
CMake Cookbook：《CMake菜谱(CMake Cookbook中文版)》 ：https://www.bookstack.cn/read/CMake-Cookbook/content-preface-preface-chinese.md
开胃菜例子 CMakeLists生成和添加依赖库 原文;cmake之生成动态库：https://www.cnblogs.com/pandamohist/p/13408455.html
1、目录结构
│ CMakeLists.txt │ index." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/cea0221403a232d76fb72171ba623812/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-07-22T19:16:00+08:00" />
<meta property="article:modified_time" content="2022-07-22T19:16:00+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">【cmake】CMakeList添加库|添加头文件|添加路径|add_executable、add_library、target_link_libraries|添加编译选项|宏开关...</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <div id="cnblogs_post_body" class="blogpost-body blogpost-body-html" style="font-size: 16px;"> 
 <p id="main-toc"><strong>目录</strong></p> 
 <p id="%E5%AE%98%E7%BD%91%E6%9F%A5%E9%98%85-toc"><a href="#%E5%AE%98%E7%BD%91%E6%9F%A5%E9%98%85" rel="noopener">官网查阅</a></p> 
 <p id="%E5%BC%80%E8%83%83%E8%8F%9C%E4%BE%8B%E5%AD%90-toc"><a href="#%E5%BC%80%E8%83%83%E8%8F%9C%E4%BE%8B%E5%AD%90" rel="noopener">开胃菜例子</a></p> 
 <p id="articleContentId-toc"><a href="#articleContentId" rel="noopener">CMakeLists生成和添加依赖库</a></p> 
 <p id="%E6%9B%B4%E5%A4%9A%E5%B0%8F%E4%BE%8B%E5%AD%90-toc"><a href="#%E6%9B%B4%E5%A4%9A%E5%B0%8F%E4%BE%8B%E5%AD%90" rel="noopener">CMakeLists更多小例子</a></p> 
 <p id="%E7%94%9F%E6%88%90.so%E5%85%B1%E4%BA%AB%E5%BA%93%E6%96%87%E4%BB%B6-toc"><a href="#%E7%94%9F%E6%88%90.so%E5%85%B1%E4%BA%AB%E5%BA%93%E6%96%87%E4%BB%B6" rel="noopener">生成.so共享库文件</a></p> 
 <p id="%E4%BA%8C%E3%80%81%E8%B0%83%E7%94%A8%E5%85%B1%E4%BA%AB%E5%BA%93%E6%96%87%E4%BB%B6-toc"><a href="#%E4%BA%8C%E3%80%81%E8%B0%83%E7%94%A8%E5%85%B1%E4%BA%AB%E5%BA%93%E6%96%87%E4%BB%B6" rel="noopener">调用</a><a href="#%E7%94%9F%E6%88%90.so%E5%85%B1%E4%BA%AB%E5%BA%93%E6%96%87%E4%BB%B6" rel="noopener">.so</a><a href="#%E4%BA%8C%E3%80%81%E8%B0%83%E7%94%A8%E5%85%B1%E4%BA%AB%E5%BA%93%E6%96%87%E4%BB%B6" rel="noopener">共享库文件</a></p> 
 <p id="%E7%94%9F%E6%88%90%E4%B8%80%E4%B8%AA%E5%8F%AF%E6%89%A7%E8%A1%8C%E7%A8%8B%E5%BA%8F%E7%9A%84%20CMakeList-toc"><a href="#%E7%94%9F%E6%88%90%E4%B8%80%E4%B8%AA%E5%8F%AF%E6%89%A7%E8%A1%8C%E7%A8%8B%E5%BA%8F%E7%9A%84%20CMakeList" rel="noopener">生成一个可执行程序的 CMakeList</a></p> 
 <p id="%E7%94%9F%E6%88%90%E4%B8%80%E4%B8%AA.so%E5%8A%A8%E6%80%81%E5%BA%93%E7%9A%84%20CMakeList%C2%A0-toc"><a href="#%E7%94%9F%E6%88%90%E4%B8%80%E4%B8%AA.so%E5%8A%A8%E6%80%81%E5%BA%93%E7%9A%84%20CMakeList%C2%A0" rel="noopener">生成一个.so动态库的 CMakeList </a></p> 
 <p id="add_library%EF%BC%8Ctarget_link_libraries%EF%BC%8Cset_target_properties%EF%BC%8Ctarget_link_libraries%E4%BD%BF%E7%94%A8%E8%81%94%E7%B3%BB-toc"><a href="#add_library%EF%BC%8Ctarget_link_libraries%EF%BC%8Cset_target_properties%EF%BC%8Ctarget_link_libraries%E4%BD%BF%E7%94%A8%E8%81%94%E7%B3%BB" rel="noopener">add_library(生成库)，target_link_libraries(生成目标连接的库)，set_target_properties</a></p> 
 <p id="CMake%E6%B7%BB%E5%8A%A0-g%E7%BC%96%E8%AF%91%E9%80%89%E9%A1%B9-toc"><a href="#CMake%E6%B7%BB%E5%8A%A0-g%E7%BC%96%E8%AF%91%E9%80%89%E9%A1%B9" rel="noopener">CMAKE 添加编译选项|-g编译参数/选项</a></p> 
 <p id="%E5%8C%85%E5%90%AB%E6%96%87%E4%BB%B6%E7%9A%84%E7%9A%84%E7%9B%AE%E5%BD%95-toc"><a href="#%E5%8C%85%E5%90%AB%E6%96%87%E4%BB%B6%E7%9A%84%E7%9A%84%E7%9B%AE%E5%BD%95" rel="noopener">包含文件的的目录include_directories</a></p> 
 <p id="%E4%BC%98%E5%8C%96%E9%A1%B9-toc"><a href="#%E4%BC%98%E5%8C%96%E9%A1%B9" rel="noopener">优化项|优化等级</a></p> 
 <p id="Cmake%E8%AE%BE%E7%BD%AE%E4%BC%98%E5%8C%96%E7%AD%89%E7%BA%A7%7C%C2%A0cmake%20%E7%94%9F%E6%88%90%20debug%E5%92%8C%20release%20%E7%89%88-toc"><a href="#Cmake%E8%AE%BE%E7%BD%AE%E4%BC%98%E5%8C%96%E7%AD%89%E7%BA%A7%7C%C2%A0cmake%20%E7%94%9F%E6%88%90%20debug%E5%92%8C%20release%20%E7%89%88" rel="noopener">Cmake设置优化等级| cmake 生成 debug和 release 版</a></p> 
 <p id="%E8%AE%BE%E7%BD%AE%E9%BB%98%E8%AE%A4%E6%9E%84%E5%BB%BA%E7%B1%BB%E5%9E%8B-toc"><a href="#%E8%AE%BE%E7%BD%AE%E9%BB%98%E8%AE%A4%E6%9E%84%E5%BB%BA%E7%B1%BB%E5%9E%8B" rel="noopener">设置默认构建类型</a></p> 
 <p id="CMake%E8%AE%BE%E7%BD%AE%E7%BC%96%E8%AF%91%E5%8F%82%E6%95%B0%2F%E9%80%89%E9%A1%B9-toc"><a href="#CMake%E8%AE%BE%E7%BD%AE%E7%BC%96%E8%AF%91%E5%8F%82%E6%95%B0%2F%E9%80%89%E9%A1%B9" rel="noopener">CMake设置编译参数/选项</a></p> 
 <p id="%E5%A6%82%E4%BD%95%E5%9C%A8cmakelists%E4%B8%AD%E5%8A%A0%E5%85%A5-ldl%E7%BC%96%E8%AF%91%E9%80%89%E9%A1%B9-toc"><a href="#%E5%A6%82%E4%BD%95%E5%9C%A8cmakelists%E4%B8%AD%E5%8A%A0%E5%85%A5-ldl%E7%BC%96%E8%AF%91%E9%80%89%E9%A1%B9" rel="noopener">如何在cmakelists中加入-ldl编译选项</a></p> 
 <p id="CMake%E6%8C%87%E5%AE%9Agcc%2Cg%2B%2B%E7%89%88%E6%9C%AC%E7%BC%96%E8%AF%91-toc"><a href="#CMake%E6%8C%87%E5%AE%9Agcc%2Cg%2B%2B%E7%89%88%E6%9C%AC%E7%BC%96%E8%AF%91" rel="noopener">CMake指定gcc,g++版本编译</a></p> 
 <p id="CMake%20%E5%85%B3%E9%97%AD%E8%AD%A6%E5%91%8A%E7%9A%84%E6%96%B9%E6%B3%95-toc"><a href="#CMake%20%E5%85%B3%E9%97%AD%E8%AD%A6%E5%91%8A%E7%9A%84%E6%96%B9%E6%B3%95" rel="noopener">CMake 关闭警告的方法</a></p> 
 <p id="%E5%85%B3%E9%97%AD%E7%BC%96%E8%AF%91%E5%99%A8%E4%BC%98%E5%8C%96-toc"><a href="#%E5%85%B3%E9%97%AD%E7%BC%96%E8%AF%91%E5%99%A8%E4%BC%98%E5%8C%96" rel="noopener">关闭编译器优化</a></p> 
 <p id="CMakeLists%20%E5%AE%9E%E7%8E%B0%E5%8A%A8%E6%80%81%E5%AE%8F%E5%BC%80%E5%85%B3-toc"><a href="#CMakeLists%20%E5%AE%9E%E7%8E%B0%E5%8A%A8%E6%80%81%E5%AE%8F%E5%BC%80%E5%85%B3" rel="noopener">CMakeLists 实现动态宏开关</a></p> 
 <p id="%E5%8E%BB%E6%8E%89%E7%BC%96%E8%AF%91%E4%BC%98%E5%8C%96-toc"><a href="#%E5%8E%BB%E6%8E%89%E7%BC%96%E8%AF%91%E4%BC%98%E5%8C%96" rel="noopener">去掉编译优化</a></p> 
 <p id="CMake--List%E7%94%A8%E6%B3%95-toc"><a href="#CMake--List%E7%94%A8%E6%B3%95" rel="noopener">CMake--List用法</a></p> 
 <p id="CmakeLists.txt%E5%8D%95%E8%A1%8C%E6%B3%A8%E9%87%8A%E5%92%8C%E5%A4%9A%E8%A1%8C%E6%B3%A8%E9%87%8A%C2%A0-toc"><a href="#CmakeLists.txt%E5%8D%95%E8%A1%8C%E6%B3%A8%E9%87%8A%E5%92%8C%E5%A4%9A%E8%A1%8C%E6%B3%A8%E9%87%8A%C2%A0" rel="noopener">CmakeLists.txt单行注释和多行注释 </a></p> 
 <p id="CMakeList%20%E9%80%9A%E9%85%8D%E7%AC%A6-toc"><a href="#CMakeList%20%E9%80%9A%E9%85%8D%E7%AC%A6" rel="noopener">CMakeList 通配符</a></p> 
 <p id="%E5%85%B6%E4%BB%96%E6%9C%AA%E5%BD%92%E7%B1%BB-toc"><a href="#%E5%85%B6%E4%BB%96%E6%9C%AA%E5%BD%92%E7%B1%BB" rel="noopener">其他未归类</a></p> 
 <p id="h1-5-4-add_custom_target-toc"><a href="#h1-5-4-add_custom_target" rel="noopener">add_custom_target  自定义命令</a></p> 
 <p id="add_dependencies%C2%A0-toc"><a href="#add_dependencies%C2%A0" rel="noopener">add_dependencies </a></p> 
 <p id="Cmake%E6%9D%A1%E4%BB%B6%E5%88%A4%E6%96%AD%E6%8C%87%E4%BB%A4%7Cif%20%E5%88%A4%E6%96%AD%E4%BC%98%E5%85%88%E7%BA%A7-toc"><a href="#Cmake%E6%9D%A1%E4%BB%B6%E5%88%A4%E6%96%AD%E6%8C%87%E4%BB%A4%7Cif%20%E5%88%A4%E6%96%AD%E4%BC%98%E5%85%88%E7%BA%A7" rel="noopener">Cmake条件判断指令|if 判断优先级</a></p> 
 <p id="%E8%AE%BE%E7%BD%AE%E7%BC%96%E8%AF%91%E6%97%B6%E5%92%8C%E7%A8%8B%E5%BA%8F%E8%BF%90%E8%A1%8C%E6%97%B6%E5%8E%BB%E5%93%AA%E4%B8%AA%E7%9B%AE%E5%BD%95%E6%89%BE%E5%8A%A8%E6%80%81%E5%BA%93-toc"><a href="#%E8%AE%BE%E7%BD%AE%E7%BC%96%E8%AF%91%E6%97%B6%E5%92%8C%E7%A8%8B%E5%BA%8F%E8%BF%90%E8%A1%8C%E6%97%B6%E5%8E%BB%E5%93%AA%E4%B8%AA%E7%9B%AE%E5%BD%95%E6%89%BE%E5%8A%A8%E6%80%81%E5%BA%93" rel="noopener">设置编译时和程序运行时去哪个目录找动态库</a></p> 
 <p id="%23%E6%8C%87%E5%AE%9A%E8%BF%90%E8%A1%8C%E6%97%B6%E5%8A%A8%E6%80%81%E5%BA%93%E7%9A%84%E5%8A%A0%E8%BD%BD%E8%B7%AF%E5%BE%84-toc"><a href="#%23%E6%8C%87%E5%AE%9A%E8%BF%90%E8%A1%8C%E6%97%B6%E5%8A%A8%E6%80%81%E5%BA%93%E7%9A%84%E5%8A%A0%E8%BD%BD%E8%B7%AF%E5%BE%84" rel="noopener">#指定运行时动态库的加载路径</a></p> 
 <p id="%23%E6%8C%87%E5%AE%9A%E9%93%BE%E6%8E%A5%E6%97%B6%E5%8A%A8%E6%80%81%E5%BA%93%E7%9A%84%E8%B7%AF%E5%BE%84-toc"><a href="#%23%E6%8C%87%E5%AE%9A%E9%93%BE%E6%8E%A5%E6%97%B6%E5%8A%A8%E6%80%81%E5%BA%93%E7%9A%84%E8%B7%AF%E5%BE%84" rel="noopener">#指定链接时动态库的路径</a></p> 
 <p id="cmake%20install%20%E5%92%8C%E6%89%93%E5%8C%85%E8%AE%BE%E5%AE%9A-toc"><a href="#cmake%20install%20%E5%92%8C%E6%89%93%E5%8C%85%E8%AE%BE%E5%AE%9A" rel="noopener">cmake install 和打包设定</a></p> 
 <p id="CMakeLists.txt%E5%8D%95%E8%A1%8C%E6%B3%A8%E9%87%8A%E5%92%8C%E5%A4%9A%E8%A1%8C%E6%B3%A8%E9%87%8A-toc"><a href="#CMakeLists.txt%E5%8D%95%E8%A1%8C%E6%B3%A8%E9%87%8A%E5%92%8C%E5%A4%9A%E8%A1%8C%E6%B3%A8%E9%87%8A" rel="noopener">CMakeLists.txt单行注释和多行注释</a></p> 
 <p id="target_link_libraries%20%E4%B8%AD%E7%9A%84PRIVATE%2C%20PUBLIC%2C%20INTERFACE%20%E5%8C%BA%E5%88%AB-toc"><a href="#target_link_libraries%20%E4%B8%AD%E7%9A%84PRIVATE%2C%20PUBLIC%2C%20INTERFACE%20%E5%8C%BA%E5%88%AB" rel="noopener">target_link_libraries 中的PRIVATE, PUBLIC, INTERFACE 区别</a></p> 
 <hr id="hr-toc"> 
 <p>作者：bandaoyu，持续更新，链接:<a href="https://blog.csdn.net/bandaoyu/article/details/115165199" title="https://blog.csdn.net/bandaoyu/article/details/115165199" rel="noopener">https://blog.csdn.net/bandaoyu/article/details/115165199</a></p> 
 <h2 id="%E5%AE%98%E7%BD%91%E6%9F%A5%E9%98%85">官网查阅</h2> 
 <p><a href="https://cmake.org/cmake/help/latest/search.html?q=add_library" rel="noopener" title="CMake 3.22.0-rc1文档：https://cmake.org/cmake/help/latest/search.html?q=add_library">CMake 3.22.0-rc1文档：https://cmake.org/cmake/help/latest/search.html?q=add_library</a></p> 
 <p><a href="https://cmake.org/cmake/help/v3.23/manual/cmake-commands.7.html" rel="noopener" title="https://cmake.org/cmake/help/v3.23/manual/cmake-commands.7.html">https://cmake.org/cmake/help/v3.23/manual/cmake-commands.7.html</a></p> 
 <p> CMake Cookbook：<a href="https://www.bookstack.cn/read/CMake-Cookbook/content-preface-preface-chinese.md" rel="noopener" title="《CMake菜谱(CMake Cookbook中文版)》 ：https://www.bookstack.cn/read/CMake-Cookbook/content-preface-preface-chinese.md">《CMake菜谱(CMake Cookbook中文版)》 ：https://www.bookstack.cn/read/CMake-Cookbook/content-preface-preface-chinese.md</a></p> 
 <h2 id="%E5%BC%80%E8%83%83%E8%8F%9C%E4%BE%8B%E5%AD%90">开胃菜例子</h2> 
 <h3 id="articleContentId">CMakeLists生成和添加依赖库</h3> 
 <p>原文;<a href="https://www.cnblogs.com/pandamohist/p/13408455.html" rel="noopener" title="cmake之生成动态库：https://www.cnblogs.com/pandamohist/p/13408455.html">cmake之生成动态库：https://www.cnblogs.com/pandamohist/p/13408455.html</a></p> 
 <p id="1%E3%80%81%E7%9B%AE%E5%BD%95%E7%BB%93%E6%9E%84"><strong>1、目录结构</strong></p> 
 <pre><code class="has">│  CMakeLists.txt
│  index.txt
│  
├─build
├─include
│      hello.h
│      hi.h
│      
└─src
        hello.cxx
        hi.cxx</code> 
</pre> 
 <p id="2%E3%80%81CMakeLists.txt"><strong>2、CMakeLists.txt</strong></p> 
 <pre><code class="has">cmake_minimum_required(VERSION 3.1)

#项目名
project(libhello)

# 1、指定库的目录变量
set(libhello_src src/hello.cxx)
# 指定头文件搜索路径
include_directories("${PROJECT_SOURCE_DIR}/include")



# 2、添加库(对应的两个项目)
add_library( hello_shared SHARED ${libhello_src})
add_library( hello_static STATIC ${libhello_src})
#  按照一般的习惯，静态库名字跟动态库名字应该是一致的，只是扩展名不同；
# 即：静态库名为 libhello.a； 动态库名为libhello.so ；
# 所以，希望 "hello_static" 在输出时，不是"hello_static"，而是以"hello"的名字显示，故设置如下
# SET_TARGET_PROPERTIES (hello_static PROPERTIES OUTPUT_NAME "hello")


# 3、cmake在构建一个新的target时，会尝试清理掉其他使用这个名字的库，
# 因此，在构建libhello.a时，就会清理掉libhello.so.
# 为了回避这个问题，比如再次使用SET_TARGET_PROPERTIES定义 CLEAN_DIRECT_OUTPUT属性。
SET_TARGET_PROPERTIES (hello_static PROPERTIES CLEAN_DIRECT_OUTPUT 1)
SET_TARGET_PROPERTIES (hello_shared PROPERTIES CLEAN_DIRECT_OUTPUT 1)


# 4、按照规则，动态库是应该包含一个版本号的，
# VERSION指代动态库版本，SOVERSION指代API版本。
SET_TARGET_PROPERTIES (hello_static PROPERTIES VERSION 1.1 SOVERSION 1)
SET_TARGET_PROPERTIES (hello_shared PROPERTIES VERSION 1.1 SOVERSION 1)


# 5、若将libhello.a, libhello.so.x以及hello.h安装到系统目录，才能真正让其他人开发使用，
# 本例中，将hello的共享库安装到&lt;prefix&gt;/lib目录；
# 将hello.h安装&lt;prefix&gt;/include/hello目录。
#INSTALL (TARGETS hello hello_shared LIBRARY DESTINATION lib ARCHIVE DESTINATION lib)
#INSTALL (TARGETS hello hello_static LIBRARY DESTINATION lib ARCHIVE DESTINATION lib)
#INSTALL (FILES hello.h DESTINATION include/hello)</code> 
</pre> 
 <p id="3%E3%80%81configure%20and%20generate"><strong>3、configure and generate</strong></p> 
 <pre><code class="has">xxx/to/path

cd build
cmake ..
</code> 
</pre> 
 <p><img alt="" src="https://images2.imgbox.com/36/76/MvQRteqA_o.png" style="outline: none;"></p> 
 <p id="5%E3%80%81%E5%85%B6%E4%BB%96%E8%AE%BE%E7%BD%AE"><strong>4、其他设置</strong></p> 
 <p>  若需要指定输出路径，尝试下面的示例指令：</p> 
 <pre><code class="has"># 设置VS会自动新建Debug和Release文件夹
set(CMAKE_ARCHIVE_OUTPUT_DIRECTORY ${CMAKE_BINARY_DIR}/Lib)
set(CMAKE_LIBRARY_OUTPUT_DIRECTORY ${CMAKE_BINARY_DIR}/Lib)
set(CMAKE_RUNTIME_OUTPUT_DIRECTORY ${CMAKE_BINARY_DIR}/Bin)

# 设置分别设置Debug和Release输出目录
set(CMAKE_ARCHIVE_OUTPUT_DIRECTORY_DEBUG ${CMAKE_BINARY_DIR}/Lib)
set(CMAKE_LIBRARY_OUTPUT_DIRECTORY_DEBUG ${CMAKE_BINARY_DIR}/Lib)
set(CMAKE_RUNTIME_OUTPUT_DIRECTORY_DEBUG ${CMAKE_CURRENT_SOURCE_DIR}/../../build/Debug)

set(CMAKE_ARCHIVE_OUTPUT_DIRECTORY_RELEASE ${CMAKE_BINARY_DIR}/Lib)
set(CMAKE_LIBRARY_OUTPUT_DIRECTORY_RELEASE ${CMAKE_BINARY_DIR}/Lib)
set(CMAKE_RUNTIME_OUTPUT_DIRECTORY_RELEASE ${CMAKE_CURRENT_SOURCE_DIR}/Bin)</code> 
</pre> 
 <h3 id="%E6%9B%B4%E5%A4%9A%E5%B0%8F%E4%BE%8B%E5%AD%90"><a href="#articleContentId" rel="noopener">CMakeLists</a>更多小例子</h3> 
 <h4></h4> 
 <h4 id="%E7%94%9F%E6%88%90.so%E5%85%B1%E4%BA%AB%E5%BA%93%E6%96%87%E4%BB%B6">生成.so共享库文件</h4> 
 <p><br> 下面是我的几个文件:</p> 
 <p>1hello.cpp</p> 
 <pre class="has"><code class="language-cpp">//hello.cpp
 int Calculate_sum_Of_Two_Number(int x,int y)
{
   int z=0;
   z=x+y;
   return (z);
}</code></pre> 
 <p><br> 2hello.hpp</p> 
 <pre class="has"><code class="language-cpp">//hello.hpp
#ifndef     __HELLO_H
#define     __HELLO_H
int Calculate_sum_Of_Two_Number(int x,int y);
#endif</code></pre> 
 <p><br> 3 main.cpp</p> 
 <pre class="has"><code class="language-cpp">//main.cpp
#include "hello.hpp"
#include &lt;stdio.h&gt;
int main(void)
{
   int a=0,b=0,c=0;
   printf("please input two parameter:");
   scanf("%d",&amp;a);
   scanf("%d",&amp;b);
   c=Calculate_sum_Of_Two_Number(a,b);
   printf("the sum is : %d",c);
   return 0;
}</code></pre> 
 <p><br> 4 CMakeLists.txt</p> 
 <pre class="has"><code class="language-bash">#要求的Cmake最低版本
CMAKE_MINIMUM_REQUIRED( VERSION 2.8)
 
#工程名称
PROJECT(main)
 
#设置编译器编译模式：
set( CMAKE_BUILD_TYPE "Debug" )
 
#生成共享库
#get the shared package
#here needs no .hpp
add_library(calculate_shared SHARED  hello.cpp)
 
#生成可以执行的文件
add_executable(main main.cpp)
 
#连接共享库
target_link_libraries(main calculate_shared)</code></pre> 
 <p><br> 上面CmakeLists.txt里面， 共享库的名称是calculate_shared，这个是我们可以自己更改的。生成的可执行文件是main, 这个名称也是可以更改的。</p> 
 <p>不过需要注意的是，hello.cpp里面不用在包含hello.hpp 了。(汗，因为这个导致出错，提示说是重复定义函数了)；</p> 
 <p>编译生成:</p> 
 <p>mkdir build<br> cd    build<br> cmake ..<br> make<br> 我们就可以看到build生成了 如下的文件:</p> 
 <p>CMakeCache.txt  cmake_install.cmake     main<br> CMakeFiles      libcalculate_shared.so  Makefile</p> 
 <p> libcalculate_shared.so就是生成的共享库文件。</p> 
 <p>他们的路径是:/home/fan/dev/cmake/4-exer/</p> 
 <p>下面有build文件夹，以及main.cpp, hello.cpp, hello.hpp, </p> 
 <p>build文件夹下面有共享库 libcalculate_shared.so.so</p> 
 <h4 id="%E4%BA%8C%E3%80%81%E8%B0%83%E7%94%A8%E5%85%B1%E4%BA%AB%E5%BA%93%E6%96%87%E4%BB%B6"><strong>调用共享库文件</strong></h4> 
 <p><br> 所有的外部依赖库都是这样的，比如opencv ,openni, eigen等等，原理是一样的，只不过他们已经安装在系统里面了，可以查找，而这个则是需要我们自己去配置。</p> 
 <p>即我上面生成的共享库文件本质上和opencv的库是相同的。只不过这个共享库需要自己手动配置。</p> 
 <p>比如我又新建了一个工程，需要调用上面的共享库 libcalculate_shared.so。</p> 
 <p>main.cpp如下:</p> 
 <pre class="has"><code class="language-cpp">//main.cpp
#include &lt;stdio.h&gt;
#include &lt;iostream&gt;
#include "hello.hpp"
using namespace std;
int main(void)
{
   int x=2,y=3;
   int z=0;
   z=Calculate_sum_Of_Two_Number(x,y);
   cout&lt;&lt;"the result is:"&lt;&lt;z&lt;&lt;endl;
   return 0;
}</code></pre> 
 <p><br> 那么在CMakeLists.txt里面，我需要告诉CMake, 这个头文件可以在哪里找到，头文件所定义的函数又可以在哪里找到。</p> 
 <p>上面hello.hpp的路径是:/home/fan/dev/cmake/4-exer/hello.hpp</p> 
 <p>libcalculate_shared.so的路径是/home/fan/dev/cmake/4-exer/build/libcalculate_shared.so</p> 
 <p>则CMakeLists.txt如下:</p> 
 <pre class="has"><code class="language-bash">CMAKE_MINIMUM_REQUIRED( VERSION 2.8)
 
PROJECT(main)
#设置编译器编译模式：
SET( CMAKE_BUILD_TYPE "Debug" )
 
SET(HELLO_INCLUE 
    /home/fan/dev/cmake/4-exer/)
 
SET(HELLO_SO 
    /home/fan/dev/cmake/4-exer/build/libcalculate_shared.so)
 
INCLUDE_DIRECTORIES(${HELLO_INCLUE})
 
add_executable(main main.cpp)
 
target_link_libraries(main ${HELLO_SO})</code></pre> 
 <p><br> 这里要注意一些细节(对于我这个渣渣来说的)</p> 
 <p>1、${   }这种形式代表一个变量，比如上面的，HELLO_INCLUE ，就是我自己定义的一个变量。</p> 
 <p>2、头文件包含到头文件所在的文件夹，即 /home/fan/dev/cmake/4-exer/</p> 
 <p>3、共享库要指明具体的共享库 ，精确到.so</p> 
 <p>其实主要的就是指明这个调用这个共享库的时候，使用的头文件，以及共享库本身所在的位置，然后包含链接就可以了。</p> 
 <p>安装过的共享库(例如opencv)就不用这么麻烦了，因为它的地址都放在了变量里面。</p> 
 <p>Opencv的依赖添加<br> 比如Opencv, 它的头文件和.so文件都已经放在了系统变量里面，不用向上面自己定义了(上面例子里面的头文件和共享库文件的地址都是我自己设置的)</p> 
 <p>它的CMakeLists.txt如下:</p> 
 <p>find_package(OpenCV REQUIRED)</p> 
 <p>include_directories(${OPENCV_INCLUDE_DIRS})</p> 
 <p>target_link_libraries(MAIN ${OpenCV_LIBS})</p> 
 <p>只需要查找就可以了，OpenCV_LIBS  和  OPENCV_INCLUDE_DIRS  都是系统帮我们已经定义好的，所以比较容易</p> 
 <p>参考博客:</p> 
 <p>1、如何写自己的CmakeLists.txt   https://www.cnblogs.com/chaofn/p/10160555.html</p> 
 <p>2、 【OpenCV】使用CMake链接自己路径下面的OpenCV库 https://blog.csdn.net/twt520ly/article/details/81981473<br> 原文链接：https://blog.csdn.net/qq_37761077/article/details/88750711</p> 
 <h4 id="%E7%94%9F%E6%88%90%E4%B8%80%E4%B8%AA%E5%8F%AF%E6%89%A7%E8%A1%8C%E7%A8%8B%E5%BA%8F%E7%9A%84%20CMakeList"><strong>生成一个可执行程序的 CMakeList</strong></h4> 
 <pre class="has"><code class="language-cs">#添加包含文件的的目录
include_directories(${cppzmq_INCLUDE_DIR})             

#用${SOURCE_FILES}指定的文件，生成可执行文件sample_project 
add_executable(sample_project ${SOURCE_FILES}) 

#生成可执行文件sample_project 需要连接 ${CMAKE_THREAD_LIBS_INIT}指定的库
target_link_libraries (sample_project  ${CMAKE_THREAD_LIBS_INIT})</code></pre> 
 <h4 id="%E7%94%9F%E6%88%90%E4%B8%80%E4%B8%AA.so%E5%8A%A8%E6%80%81%E5%BA%93%E7%9A%84%20CMakeList%C2%A0">生成一个.so动态库的 CMakeList </h4> 
 <pre class="has"><code class="language-cs">#用${SRC_LISTS}指定的所有的源文件生成一个库，名字叫libsugan
add_library(libsugan ${SRC_LISTS})   

#生成libsugan库需要链接 ${OpenCV_LIBS}、 ${PROJECT_SOURCE_DIR}/lib/libCommonUtilities.so、${PROJECT_SOURCE_DIR}/lib/libInuStreams.so
target_link_libraries(libsugan                 
    ${OpenCV_LIBS}
    ${PROJECT_SOURCE_DIR}/lib/libCommonUtilities.so
    ${PROJECT_SOURCE_DIR}/lib/libInuStreams.so
)</code></pre> 
 <p><br> 原文链接：https://blog.csdn.net/bandaoyu/article/details/115165199</p> 
 <p>grep -nR  "common"  ./  --include=*.txt|grep -vE "src_bak|boost|erasure-code|doc|link.txt"</p> 
 <h2 id="add_library%EF%BC%8Ctarget_link_libraries%EF%BC%8Cset_target_properties%EF%BC%8Ctarget_link_libraries%E4%BD%BF%E7%94%A8%E8%81%94%E7%B3%BB">add_library(生成库)，target_link_libraries(生成目标连接的库)，set_target_properties</h2> 
 <p><strong>生成静态库：</strong></p> 
 <p>add_library(libsugan ${SRC_LISTS})    #用${SRC_LISTS}生成静态库libsugan</p> 
 <p>或</p> 
 <p>ADD_LIBRARY(static_lib STATIC ${DIR_SUB_SRCS})</p> 
 <p><strong>生成动态库(加SHARED  )：</strong><br> add_library(libsugan  <strong>SHARED  </strong>${SRC_LISTS})    #用${SRC_LISTS}生成动态库libsugan</p> 
 <p>target_link_libraries(libsugan      #生成静态库libsugan还需链接依赖库${OpenCV_LIBS}…<br>     ${OpenCV_LIBS}<br>     ${PROJECT_SOURCE_DIR}/lib/libCommonUtilities.so<br>     ${PROJECT_SOURCE_DIR}/lib/libInuStreams.so<br> )</p> 
 <p>#上面的配置生成名字为libsugan的静态库，但Linux下对库的存储格式是lib+name.a，所以库libsugan存储出来的结果就是liblibsugan.a，看着很别扭。用下面这句，保证了存储出来的静态库叫做libsugan.a：</p> 
 <p>set_target_properties(libsugan PROPERTIES OUTPUT_NAME "sugan")</p> 
 <p>#但是请千万注意，在整个CmakeLists.txt里</p> 
 <p>#如果想链接生成的这个库必须使用    “add_library(libsugan ${SRC_LISTS})”指明的名字。<br> set_target_properties(libsugan PROPERTIES OUTPUT_NAME "sugan")</p> 
 <p>add_executable(demo ./src/main.cpp)<br> target_link_libraries(demo libsugan)</p> 
 <p><strong>连接库：</strong></p> 
 <p>target_link_libraries(demo libsugan)</p> 
 <p>target_link_libraries(app libsort.a)  #生成app 链入 libsort.a静态库</p> 
 <p>TARGET_LINK_LIBRARIES(app libsort.a)</p> 
 <p>原例子：</p> 
 <p><a href="https://blog.csdn.net/michaelhan3/article/details/69568362" title="add_library，target_link_libraries，set_target_properties，target_link_libraries使用联系：https://blog.csdn.net/michaelhan3/article/details/69568362" rel="noopener">add_library，target_link_libraries，set_target_properties，target_link_libraries使用联系：https://blog.csdn.net/michaelhan3/article/details/69568362</a></p> 
 <pre class="has"><code class="language-cs">#工程名字
project(Camera_sugan)                  

#编译最低cmake版本
cmake_minimum_required(VERSION 2.6)    

#设置c++编译器
set( CMAKE_CXX_FLAGS "${CMAKE_CXX_FLAGS} -std=c++11" )  

#在整个电脑上找opencv包
find_package(OpenCV REQUIRED)    

#包含头文件路径
include_directories(             
    ./include/inudev/
    ./src/
)

#将所有的源文件列为一个集合，集合名字叫做SRC_LISTS
set(SRC_LISTS                   
    ./src/inuitive.cpp
    ./src/runCamera_Qfeeltech.cpp
)

#将集合里的所有的源文件生成一个静态库，该静态库的名字libsugan，
注意，在整个CmakeLists里都要用libsugan这个
add_library(libsugan ${SRC_LISTS})   

#名字来代替之前那个集合生成的库。
target_link_libraries(libsugan    #链接静态库需要的依赖库
    ${OpenCV_LIBS}
    ${PROJECT_SOURCE_DIR}/lib/libCommonUtilities.so
    ${PROJECT_SOURCE_DIR}/lib/libInuStreams.so
)</code></pre> 
 <p><br> 原文链接：https://blog.csdn.net/michaelhan3/article/details/69568362</p> 
 <h4 id="CMake%E6%B7%BB%E5%8A%A0-g%E7%BC%96%E8%AF%91%E9%80%89%E9%A1%B9">CMAKE 添加编译选项|-g编译参数/选项</h4> 
 <p>add_definitions 和add_compile_options，二者添加的编译选项是针对所有编译器的(包括c和c++编译器)。</p> 
 <p>add_definitions 和add_compile_options的区别是：</p> 
 <p>add_definitions 可用于添加任何标志，但旨在添加预处理器定义。</p> 
 <p>此命令已被替代方案取代：<br> 使用 add_compile_definitions() 添加预处理器定义。<br> 使用 include_directories() 添加包含目录。<br> 使用 add_compile_options() 添加其他选项。</p> 
 <p><a href="https://cmake.org/cmake/help/latest/command/add_definitions.html" rel="noopener" title="add_definitions：https://cmake.org/cmake/help/latest/command/add_definitions.html">add_definitions：https://cmake.org/cmake/help/latest/command/add_definitions.html</a></p> 
 <p><strong>添加 -g编译参数/选项</strong></p> 
 <p><strong>方法一：add_definitions("-g")/ add_compile_options</strong></p> 
 <p><br> 在文件 CMakeLists.txt添加下面一条语句<br> add_definitions("-g")</p> 
 <p>添加其他编译参数/选项</p> 
 <p>例如下面的代码</p> 
 <p>#判断编译器类型,如果是gcc编译器,则在编译选项中加入c++11支持</p> 
 <blockquote> 
  <p>if(CMAKE_COMPILER_IS_GNUCXX)<br>     add_compile_options(-std=c++11)<br>     message(STATUS "optional:-std=c++11")   <br> endif(CMAKE_COMPILER_IS_GNUCXX)</p> 
 </blockquote> 
 <p><br> 使用add_compile_options添加-std=c++11选项，是想在编译c++代码时加上c++11支持选项。但是因为add_compile_options是针对所有类型编译器的，所以在编译c代码时，就会产生如下warning</p> 
 <pre class="has"><code class="language-bash">J:\workspace\facecl.gcc&gt;make b64
[ 50%] Building C object libb64/CMakeFiles/b64.dir/libb64-1.2.1/src/cdecode.c.obj
cc1.exe: warning: command line option ‘-std=c++11’ is valid for C++/ObjC++ but not for C
[100%] Building C object libb64/CMakeFiles/b64.dir/libb64-1.2.1/src/cencode.c.obj
cc1.exe: warning: command line option ‘-std=c++11’ is valid for C++/ObjC++ but not for C
Linking C static library libb64.a
[100%] Built target b64</code></pre> 
 <p>虽然并不影响编译，但看着的确是不爽啊，要消除这个warning,就不能使用add_compile_options，而是只针对c++编译器添加这个option。</p> 
 <p><strong>方法二：set</strong></p> 
 <p>所以如下修改代码，则警告消除。</p> 
 <p>#判断编译器类型,如果是gcc编译器,则在编译选项中加入c++11支持<br> if(CMAKE_COMPILER_IS_GNUCXX)<br>     set(CMAKE_CXX_FLAGS "-std=c++11 ${CMAKE_CXX_FLAGS}")<br>     message(STATUS "optional:-std=c++11")   <br> endif(CMAKE_COMPILER_IS_GNUCXX)<br> 原文链接：https://blog.csdn.net/qinglongzhan/article/details/80743731</p> 
 <h4 id="%E5%8C%85%E5%90%AB%E6%96%87%E4%BB%B6%E7%9A%84%E7%9A%84%E7%9B%AE%E5%BD%95">包含文件的的目录include_directories</h4> 
 <p>include_directories(${cppzmq_INCLUDE_DIR})  //添加包含文件的的目录</p> 
 <p>add_definitions 可用于添加任何标志，但旨在添加预处理器定义。</p> 
 <p>此命令已被替代方案取代：<br> 使用 add_compile_definitions() 添加预处理器定义。<br> 使用 include_directories() 添加包含目录。<br> 使用 add_compile_options() 添加其他选项。</p> 
 <h4 id="%E4%BC%98%E5%8C%96%E9%A1%B9">优化项|优化等级</h4> 
 <p><a href="https://blog.csdn.net/bandaoyu/article/details/123700034" title="更多和详细解释：https://blog.csdn.net/bandaoyu/article/details/123700034" rel="noopener">更多和详细解释：https://blog.csdn.net/bandaoyu/article/details/123700034</a></p> 
 <p>-O0禁止编译器进行优化。默认为此项。<br> -O1尝试优化编译时间和可执行文件大小。</p> 
 <p>-O2更多的优化，会尝试几乎全部的优化功能，但不会进行“空间换时间”的优化方法。</p> 
 <p>-O3在 -O2 的基础上再打开一些优化选项：-finline-functions， -funswitch-loops 和 -fgcse-after-reload 。</p> 
 <p>-Os对生成文件大小进行优化。它会打开 -O2 开的除了会那些增加文件大小的全部选项。</p> 
 <p>可以通过下面的命令查找工程中设置优化项的地方：</p> 
 <p>grep -nR  "\-O"  ./  --include=*.txt</p> 
 <p>过滤掉含有 build、boost、erasure-code、doc、link.txt字样的结果</p> 
 <p>grep -nR  "\-O"  ./  --include=*.txt|grep  -vE  "build|src_bak|boost|erasure-code|doc|link.txt"</p> 
 <h4 id="Cmake%E8%AE%BE%E7%BD%AE%E4%BC%98%E5%8C%96%E7%AD%89%E7%BA%A7%7C%C2%A0cmake%20%E7%94%9F%E6%88%90%20debug%E5%92%8C%20release%20%E7%89%88">Cmake设置优化等级| cmake 生成 debug和 release 版</h4> 
 <p>见文章：</p> 
 <p><a href="https://blog.csdn.net/bandaoyu/article/details/123700034" title="https://blog.csdn.net/bandaoyu/article/details/123700034" rel="noopener">https://blog.csdn.net/bandaoyu/article/details/123700034</a></p> 
 <p>   <s><em> CMake 中有一个变量 CMAKE_BUILD_TYPE ,可以的取值是 Debug 、Release、 RelWithDebInfo 和 MinSizeRel。</em></s></p> 
 <p><s><em>当这个变量值为 Debug 的时候,CMake 会使用变量 CMAKE_CXX_FLAGS_DEBUG 和 CMAKE_C_FLAGS_DEBUG 中的字符串作为编译选项生成 Makefile ,</em></s></p> 
 <p><s><em>当这个变量值为 Release 的时候,工程会使用变量 CMAKE_CXX_FLAGS_RELEASE 和 CMAKE_C_FLAGS_RELEASE 选项生成 Makefile。</em></s></p> 
 <p><s><em>提供的级别为：</em></s></p> 
 <ul><li><s><em>Release - Adds the <code>-O3 -DNDEBUG</code> flags to the compiler</em></s></li><li><s><em>Debug - Adds the <code>-g</code> flag</em></s></li><li><s><em>MinSizeRel - Adds <code>-Os -DNDEBUG</code></em></s></li><li><s><em>RelWithDebInfo - Adds <code>-O2 -g -DNDEBUG</code> flags</em></s></li></ul> 
 <p><s><em>链接：https://www.jianshu.com/p/d761232e8e90</em></s></p> 
 <blockquote> 
  <p><s><em>CMakeCache.txt:89:CMAKE_ASM_FLAGS_MINSIZEREL:STRING=-Os -DNDEBUG<br> CMakeCache.txt:92:CMAKE_ASM_FLAGS_RELEASE:STRING=-O3 -DNDEBUG<br> CMakeCache.txt:95:CMAKE_ASM_FLAGS_RELWITHDEBINFO:STRING=-O2 -g -DNDEBUG<br> CMakeCache.txt:123:CMAKE_CXX_FLAGS_MINSIZEREL:STRING=-Os -DNDEBUG<br> CMakeCache.txt:126:CMAKE_CXX_FLAGS_RELEASE:STRING=-O3 -DNDEBUG<br> CMakeCache.txt:129:CMAKE_CXX_FLAGS_RELWITHDEBINFO:STRING=-O2 -g -DNDEBUG<br> CMakeCache.txt:150:CMAKE_C_FLAGS_MINSIZEREL:STRING=-Os -DNDEBUG<br> CMakeCache.txt:153:CMAKE_C_FLAGS_RELEASE:STRING=-O3 -DNDEBUG<br> CMakeCache.txt:156:CMAKE_C_FLAGS_RELWITHDEBINFO:STRING=-O2 -g -DNDEBUG</em></s></p> 
 </blockquote> 
 <p><s><em>cmake设置默认CMAKE_BUILD_TYPE</em></s></p> 
 <p><s><em>原文</em></s><em>：<a href="https://cmake.org/pipermail/cmake/2009-June/030311.html" rel="noopener" title="[CMake] Set default build type in CMakeLists.txt">[CMake] Set default build type in CMakeLists.txt</a></em></p> 
 <p><s><em>在<code>CMakeLists.txt</code>里写入</em></s></p> 
 <blockquote> 
  <p><s><em>IF (NOT CMAKE_BUILD_TYPE)<br>     set(CMAKE_BUILD_TYPE "Release" CACHE STRING<br>         "Choose the type of build, options are: Debug Release RelWithDebInfo MinSizeRel." FORCE)<br> ENDIF()</em></s></p> 
 </blockquote> 
 <h4 id="%E8%AE%BE%E7%BD%AE%E9%BB%98%E8%AE%A4%E6%9E%84%E5%BB%BA%E7%B1%BB%E5%9E%8B"><span style="font-weight: bold;"><s><em>设置默认构建类型</em></s></span></h4> 
 <p><s><em>CMake提供的默认构建类型是不包含用于优化的编译器标志。对于某些项目，您可能需要设置默认生成类型，以便不必记住设置它。<br> 为此，您可以将以下内容添加到CMakeLists.txt文件顶层</em></s></p> 
 <blockquote> 
  <p><s><em>if(NOT CMAKE_BUILD_TYPE AND NOT CMAKE_CONFIGURATION_TYPES)<br>   message("Setting build type to 'RelWithDebInfo' as none was specified.")<br>   set(CMAKE_BUILD_TYPE RelWithDebInfo CACHE STRING "Choose the type of build." FORCE)<br>   # Set the possible values of build type for cmake-gui<br>   set_property(CACHE CMAKE_BUILD_TYPE PROPERTY STRINGS "Debug" "Release"<br>     "MinSizeRel" "RelWithDebInfo")<br> endif()</em></s></p> 
  <p><s><em>作者：xingxingRealzyx<br> 链接：https://www.jianshu.com/p/d761232e8e90</em></s></p> 
 </blockquote> 
 <h4 id="CMake%E8%AE%BE%E7%BD%AE%E7%BC%96%E8%AF%91%E5%8F%82%E6%95%B0%2F%E9%80%89%E9%A1%B9">CMake设置编译参数/选项</h4> 
 <blockquote> 
  <p>而set命令设置CMAKE_C_FLAGS或CMAKE_CXX_FLAGS变量则是分别只针对c和c++编译器的</p> 
 </blockquote> 
 <p><strong>对c编译器的</strong></p> 
 <blockquote> 
  <p>set(CMAKE_C_FLAGS"-O3 -fopenmp -fPIC -Wno-deprecated -Wenum-compare -std=c++14")</p> 
 </blockquote> 
 <p><strong>针对c++编译器的</strong></p> 
 <blockquote> 
  <p>set(CMAKE_CXX_FLAGS "-O3 -fopenmp -fPIC -Wno-deprecated -Wenum-compare -std=c++14")</p> 
 </blockquote> 
 <h4 id="%E5%A6%82%E4%BD%95%E5%9C%A8cmakelists%E4%B8%AD%E5%8A%A0%E5%85%A5-ldl%E7%BC%96%E8%AF%91%E9%80%89%E9%A1%B9">如何在cmakelists中加入-ldl编译选项</h4> 
 <p>cmakelists.txt中，在增加可执行程序后增加TARGET_LINK_LIBRARIES<br> eg:<br> add_executable(xx ${ALL_F} ${WE_F})<br> TARGET_LINK_LIBRARIES(dl)<br> TARGET_LINK_LIBRARIES(m)</p> 
 <p>set(CMAKE_C_FLAGS "-ldl")</p> 
 <p>在add_executable(${PROJECT_NAME} "main.cpp")后面添加<br> target_link_libraries(${PROJECT_NAME} dl)</p> 
 <pre class="has"><code class="language-html">target_link_libraries(exe1 -Wl， - -whole-archive lib1 -Wl， -  no-whole-archive)</code></pre> 
 <h4 id="CMake%E6%8C%87%E5%AE%9Agcc%2Cg%2B%2B%E7%89%88%E6%9C%AC%E7%BC%96%E8%AF%91">CMake指定gcc,g++版本编译</h4> 
 <p>系统默认的gcc/g++在/usr/bin目录下。</p> 
 <p>我们升级安装的gcc目录在/usr/local/bin目录下，现在我们希望使用升级后的gcc。</p> 
 <p>通过百度搜索出来的结果，大多是如下操作:</p> 
 <p>在CMakeLists.txt中调用编译器之前添加：</p> 
 <blockquote> 
  <p>SET(CMAKE_C_COMPILER "/usr/local/bin/gcc")<br> SET(CMAKE_CXX_COMPILER "/usr/local/bin/g++")</p> 
 </blockquote> 
 <p>然而经过本人亲自实践，该方法不起作用(没有删掉build里面的东西重新cmake的原因？)，正确的做法是：</p> 
 <p>执行cmake命令之前，在shell终端先设置如下两个变量：</p> 
 <blockquote> 
  <p>export CC=/usr/local/bin/gcc<br> export CXX=/usr/local/bin/g++</p> 
  <p>可能还需要</p> 
  <p>export LD_LIBRARY_PATH=/usr/local/gcc-xxx/lib:$LD_LIBRARY_PATH</p> 
  <p>/usr/local/gcc-xxx/lib 是你的新gcc的lib位置</p> 
 </blockquote> 
 <p>然后再执行cmake等后续命令，这样就可以用指定的编译器版本了。</p> 
 <p>vim ~/.bashrc  source ~/.bashrc</p> 
 <h2 id="CMake%20%E5%85%B3%E9%97%AD%E8%AD%A6%E5%91%8A%E7%9A%84%E6%96%B9%E6%B3%95">CMake 关闭警告的方法</h2> 
 <p>在CMakeLists.txt中添加add_definitions(-w)</p> 
 <p><strong>应用于单个target</strong></p> 
 <pre class="has"><code class="language-html">if(CMAKE_COMPILER_IS_GNUCC)
 target_compile_options(main PRIVATE"-Wall")
 endif()
 if(MSVC)
 target_compile_options(main PRIVATE"/ W4")
 endif()</code></pre> 
 <p><strong>应用于所有target</strong></p> 
 <pre class="has"><code class="language-html">if(CMAKE_COMPILER_IS_GNUCC)
 set(CMAKE_CXX_FLAGS"$ {CMAKE_CXX_FLAGS} -Wall")
 endif()
 if(MSVC)
 set(CMAKE_CXX_FLAGS"$ {CMAKE_CXX_FLAGS} / W4")
 endif()</code></pre> 
 <p>注意：为GCC或/ WX添加-Werror以便MSVC将所有警告视为错误。这会将所有警告视为错误。这对于新项目来说可以方便地执行严格的警告。</p> 
 <p>另外， -Wall 并不意味着"所有错误";从历史意义上讲，它意味着"每个人都可以达成一致的所有错误""。从 -Wall -Wextra 开始，然后仔细阅读<em>您的</em>版本的GCC手册，并找到<em> else </em>编译器可以为您提供关于警告的信息。</p> 
 <p><a href="https://www.it1352.com/784160.html" rel="noopener" title="CMake和编译器警告 https://www.it1352.com/784160.html">CMake和编译器警告 https://www.it1352.com/784160.html</a></p> 
 <h4 id="%E5%85%B3%E9%97%AD%E7%BC%96%E8%AF%91%E5%99%A8%E4%BC%98%E5%8C%96">关闭编译器优化</h4> 
 <p>(未验证)</p> 
 <p>1)add_compile_options(-fno-elide-constructors)    #关闭编译器优化</p> 
 <p>2)set(CMAKE_CXX_FLAGS "-fno-elide-constructors ${CMAKE_CXX_FLAGS}")</p> 
 <h2 id="Debug%E5%92%8CRelease%20%E6%96%B9%E6%A1%88"></h2> 
 <h2 id="CMakeLists%20%E5%AE%9E%E7%8E%B0%E5%8A%A8%E6%80%81%E5%AE%8F%E5%BC%80%E5%85%B3">CMakeLists 实现动态宏开关</h2> 
 <h4 id="%E5%8E%BB%E6%8E%89%E7%BC%96%E8%AF%91%E4%BC%98%E5%8C%96">去掉编译优化</h4> 
 <p>在CMakeList中添加：</p> 
 <pre class="has"><code>if(NOT CMAKE_BUILD_TYPE)
  set(CMAKE_BUILD_TYPE Release)
endif()

set(CMAKE_CXX_FLAGS "-Wall -Wextra")
set(CMAKE_CXX_FLAGS_DEBUG "-g")
set(CMAKE_CXX_FLAGS_RELEASE "-O3")</code></pre> 
 <p>执行的时候</p> 
 <p>cmake  -DCMAKE_BUILD_TYPE=Release</p> 
 <p>也可以在上一层(调用本CMakeList.txt的)的CMakeList.txt中添加下面：</p> 
 <p>option (CMAKE_BUILD_TYPE "Use tutorial provided math implementation"  <strong>ON</strong>)</p> 
 <p>表示启用CMAKE_BUILD_TYPE 宏。</p> 
 <p>option (CMAKE_BUILD_TYPE "Use tutorial provided math implementation"  <strong>OFF</strong>) #表示关</p> 
 <p>参考：</p> 
 <p><a href="https://stackoverflow.com/questions/41361631/optimize-in-cmake-by-default" rel="noopener" title="《c++ - Optimize in CMake by default 》:https://stackoverflow.com/questions/41361631/optimize-in-cmake-by-default">《c++ - Optimize in CMake by default 》:https://stackoverflow.com/questions/41361631/optimize-in-cmake-by-default</a></p> 
 <p><a href="https://unix.stackexchange.com/questions/187455/how-to-compile-without-optimizations-o0-using-cmake" rel="noopener" title="《How to compile without optimizations -O0 using CMake》：https://unix.stackexchange.com/questions/187455/how-to-compile-without-optimizations-o0-using-cmake">《How to compile without optimizations -O0 using CMake》：https://unix.stackexchange.com/questions/187455/how-to-compile-without-optimizations-o0-using-cmake</a></p> 
 <p>例子</p> 
 <p>最近在工作中需要通过一份C代码控制逻辑走向，网上找了一下资料，发现可以通过在CMakeLists文件中动态定义宏开关，从而能够达到编译出不同逻辑流的代码。</p> 
 <p>具体步骤：</p> 
 <p>首先，我在src代码里编写了若干debug的输出：</p> 
 <p>#IFDEF DEBUG<br>     some print command;<br> #ENDIF<br> 然后，在CMakeLists文件中添加DEBUG的定义：</p> 
 <p>IF (CMAKE_BUILD_TYPE STREQUAL DEBUG)<br>     ADD_DEFINITIONS(-DDEBUG)<br> ENDIF()<br> 最后，在cmake的时候设置参数 -DCMAKE_BUILD_TYPE 为 DEBUG:</p> 
 <p>$ cmake .. -DCMAKE_BUILD_TYPE=DEBUG<br> $ make -j4<br> 这样再运行可执行文件时就会打印出some print command的debug信息了。如果不想看到debug信息，只需在参数中不设置DEBUG参数，或者将DEBUG参数设置为其它值即可(以下两种方式二者选其一)：</p> 
 <p>$ cmake ..<br> $ cmake .. -DCMAKE_BUILD_TYPE=RELEASE<br> 到此 CMakeLists 实现动态宏开关介绍完成。<br> 原文链接：https://blog.csdn.net/qq_19734597/article/details/104461963</p> 
 <h2 id="CMake--List%E7%94%A8%E6%B3%95"><a href="https://www.cnblogs.com/narjaja/p/8343765.html" rel="noopener" id="cb_post_title_url" title="CMake--List用法">CMake--List用法</a></h2> 
 <p><a href="https://www.cnblogs.com/narjaja/p/8343765.html" rel="noopener" title="CMake--List用法 ：https://www.cnblogs.com/narjaja/p/8343765.html">CMake--List用法 ：https://www.cnblogs.com/narjaja/p/8343765.html</a></p> 
 <h4 id="CmakeLists.txt%E5%8D%95%E8%A1%8C%E6%B3%A8%E9%87%8A%E5%92%8C%E5%A4%9A%E8%A1%8C%E6%B3%A8%E9%87%8A%C2%A0">CmakeLists.txt单行注释和多行注释 </h4> 
 <p>单行注释：使用“#”<br> 多行注释：使用“#[[ ]]”</p> 
 <p><img alt="在这里插入图片描述" src="https://images2.imgbox.com/99/f3/7Xwi322t_o.png" style="outline: none;"></p> 
 <h2 id="CMakeList%20%E9%80%9A%E9%85%8D%E7%AC%A6">CMakeList 通配符</h2> 
 <p> <strong> $&lt;TARGET_OBJECTS:A&gt;：</strong></p> 
 <p><strong>说明：</strong></p> 
 <pre class="has"><code class="language-bash">$&lt;TARGET_OBJECTS:objLib&gt;¶
New in version 3.1.

List of objects resulting from build of objLib.
构建 objLib 产生的对象列表</code></pre> 
 <p>add_executable(test   test.cc   $&lt;TARGET_OBJECTS:A&gt;)，表示使用 test.cc和构建A产生的对象 联合编译出test。</p> 
 <p>add_executable(test2   $&lt;TARGET_OBJECTS:A&gt;  $&lt;TARGET_OBJECTS:B&gt; )，表示使用构建A产生的对象  和 构建B产生的对象 联合编译出test。</p> 
 <p>例子：某个工程如下</p> 
 <pre class="has"><code class="language-bash">-  CMakeLists.txt
-  include
    -  a.hh
-  lib
    -  CMakeLists.txt
    -  a.cc
-  src
    -  CMakeLists.txt
    -  main.cc
-  test
    -  CMakeLists.txt
    -  test.cc</code></pre> 
 <p>使用 CMake 使用命令编译 test.cc<br> add_executable(test test.cc $&lt;TARGET_OBJECTS:A&gt;)</p> 
 <p>使用的A.o 的编译为<br> add_library(A   OBJECT  A.cc)</p> 
 <p><a href="https://stackoverflow.com/questions/35696103/cmake-wildcard-for-target-objects" rel="noopener" title="来自：https://stackoverflow.com/questions/35696103/cmake-wildcard-for-target-objects">来自：https://stackoverflow.com/questions/35696103/cmake-wildcard-for-target-objects</a></p> 
 <h2 id="%E5%85%B6%E4%BB%96%E6%9C%AA%E5%BD%92%E7%B1%BB">其他未归类</h2> 
 <h2 id="h1-5-4-add_custom_target">add_custom_target  自定义命令</h2> 
 <p><a href="https://www.bookstack.cn/read/CMake-Cookbook/content-chapter5-5.4-chinese.md" rel="noopener" title="https://www.bookstack.cn/read/CMake-Cookbook/content-chapter5-5.4-chinese.md">https://www.bookstack.cn/read/CMake-Cookbook/content-chapter5-5.4-chinese.md</a></p> 
 <pre class="has"><code class="language-bash">add_custom_target(finish 
    COMMAND ${CMAKE_COMMAND} -E echo compile finish
    COMMAND ${CMAKE_COMMAND} -E copy_directory ${SOURCE_DIR}/config ${SOURCE_DIR}/etc
    COMMAND ${CMAKE_COMMAND} -E copy ${SOURCE_DIR}/log.txt ${SOURCE_DIR}/etc
    )</code></pre> 
 <p>定义了一个自定义命令：finish ,执行该命令就会进行以下操作：</p> 
 <pre class="has"><code class="language-bash">COMMAND ${CMAKE_COMMAND} -E echo compile finish
COMMAND ${CMAKE_COMMAND} -E copy_directory ${SOURCE_DIR}/config ${SOURCE_DIR}/etc
COMMAND ${CMAKE_COMMAND} -E copy ${SOURCE_DIR}/log.txt ${SOURCE_DIR}/etc</code></pre> 
 <p>单独执行命令的方式是： cmake --build &lt;dir&gt; [&lt;options&gt;] [-- &lt;build-tool-options&gt;]</p> 
 <p>cmake --build  /home/mydir   --target   finish</p> 
 <p><img alt="" height="179" src="https://images2.imgbox.com/4f/1e/3ISBuXOH_o.png" width="641" style="outline: none;"></p> 
 <p>与 add_executable(main main.cpp) 、add_library(mylib mylib.cpp) 的不同是，这两个会生成(产出)main、mylib文件。add_custom_target(comandname  ……)只会执行列出的操作，不会产生comandname文件</p> 
 <h3 id="add_dependencies%C2%A0">add_dependencies </h3> 
 <p>如果main 依赖a.so b.so TARGET_LINK_LIBRARIES(main a.so b.so c.so d.so) </p> 
 <p>而a.so b.so 的生成晚于main(即编译脚本的顺序把a.so b.so 安排在后面编译)，则需要ADD_DEPENDENCIES(main a.so b.so) 提前为main编译a.so b.so，否则可能会报错：符号的定义找不到 (这些符号恰恰就在a.so 和 b.so中)</p> 
 <p>详情见：<a href="https://blog.csdn.net/KingOfMyHeart/article/details/112983922" title="https://blog.csdn.net/KingOfMyHeart/article/details/112983922" rel="noopener">https://blog.csdn.net/KingOfMyHeart/article/details/112983922</a></p> 
 <h3 id="Cmake%E6%9D%A1%E4%BB%B6%E5%88%A4%E6%96%AD%E6%8C%87%E4%BB%A4%7Cif%20%E5%88%A4%E6%96%AD%E4%BC%98%E5%85%88%E7%BA%A7">Cmake条件判断指令|if 判断优先级</h3> 
 <p><a href="https://blog.csdn.net/wzj_110/article/details/116105719" title="cmake(十六)Cmake条件判断指令：https://blog.csdn.net/wzj_110/article/details/116105719" rel="noopener">cmake(十六)Cmake条件判断指令：https://blog.csdn.net/wzj_110/article/details/116105719</a></p> 
 <p>一  <a href="https://www.cnblogs.com/stonehat/p/7702744.html" rel="noopener" title="基础语法">基础语法</a></p> 
 <p>①  基本框架</p> 
 <p><img alt="" height="300" src="https://images2.imgbox.com/2d/06/PdsLDWUG_o.png" width="409" style="outline: none;"></p> 
 <p>②  优先级</p> 
 <p><img alt="" height="260" src="https://images2.imgbox.com/a8/cb/9CJvuhoI_o.png" width="509" style="outline: none;"></p> 
 <p>③  条件的类型</p> 
 <p><img alt="" height="260" src="https://images2.imgbox.com/9d/d5/norO2js7_o.png" width="526" style="outline: none;"></p> 
 <p><img alt="" height="280" src="https://images2.imgbox.com/9c/c0/IeRaXsv5_o.png" width="520" style="outline: none;"></p> 
 <p><img alt="" height="300" src="https://images2.imgbox.com/7b/98/f67xAO6v_o.png" width="370" style="outline: none;"></p> 
 <p><img alt="" height="306" src="https://images2.imgbox.com/3c/28/5qk51AzI_o.png" width="600" style="outline: none;"></p> 
 <p><img alt="" height="250" src="https://images2.imgbox.com/08/f6/JXlLv6uH_o.png" width="486" style="outline: none;"></p> 
 <h2 id="%E8%AE%BE%E7%BD%AE%E7%BC%96%E8%AF%91%E6%97%B6%E5%92%8C%E7%A8%8B%E5%BA%8F%E8%BF%90%E8%A1%8C%E6%97%B6%E5%8E%BB%E5%93%AA%E4%B8%AA%E7%9B%AE%E5%BD%95%E6%89%BE%E5%8A%A8%E6%80%81%E5%BA%93">设置编译时和程序运行时去哪个目录找动态库</h2> 
 <h4 id="%23%E6%8C%87%E5%AE%9A%E8%BF%90%E8%A1%8C%E6%97%B6%E5%8A%A8%E6%80%81%E5%BA%93%E7%9A%84%E5%8A%A0%E8%BD%BD%E8%B7%AF%E5%BE%84">#指定运行时动态库的加载路径</h4> 
 <p><br> SET(CMAKE_BUILD_WITH_INSTALL_RPATH TRUE)  #Use the install path for the RPATH<br> SET(CMAKE_INSTALL_RPATH   "\${ORIGIN}/lib" )     #The rpath to use for installed targets.</p> 
 <p><a href="https://cmake.org/cmake/help/v3.0/variable/CMAKE_INSTALL_RPATH.html?highlight=cmake_install_rpath" rel="noopener" title="https://cmake.org/cmake/help/v3.0/variable/CMAKE_INSTALL_RPATH.html?highlight=cmake_install_rpath">https://cmake.org/cmake/help/v3.0/variable/CMAKE_INSTALL_RPATH.html?highlight=cmake_install_rpath</a></p> 
 <blockquote> 
  <p>程序运行时，搜索动态库的顺序(优先级)优先级是这样的：</p> 
  <p>1. RPATH ，编译链接时加入 -rpath 参数 指定的目录<br> 2. LD_LIBRARY_PATH  这个环境变量指定的目录<br> 3. /etc/ld.so.conf 配置文件。<br> 4. /usr/lib 、 /lib 和 /usr/local/lib ，系统默认路径。</p> 
  <p>所以我们设置了RPATH ，并且RPATH 下有要找的动态库，程序就首先加载它</p> 
  <p>注意：</p> 
  <p>可以看到，RPATH与RUNPATH中间隔着LD_LIBRARY_PATH。为了让用户可以通过修改LD_LIBRARY_PATH来指定<code>.so</code>文件，大多数编译器都将输出的RPATH留空，并用RUNPATH代替RPATH。</p> 
 </blockquote> 
 <p><a href="https://blog.csdn.net/JCYAO_/article/details/102519998" title="linux cmake分别指定编译/运行时动态库链接路径：https://blog.csdn.net/JCYAO_/article/details/102519998" rel="noopener">linux cmake分别指定编译/运行时动态库链接路径：https://blog.csdn.net/JCYAO_/article/details/102519998</a></p> 
 <p><a href="https://www.cnblogs.com/rickyk/p/3875084.html" rel="noopener" title="探讨CMake中关于RPATH的使用(https://www.cnblogs.com/rickyk/p/3875084.html):">探讨CMake中关于RPATH的使用(https://www.cnblogs.com/rickyk/p/3875084.html):</a></p> 
 <p>CMake在默认情况下是会给你的exe加入相关RPATH的，可能给你加入你不想要的一些RPATH(就是一些Cmake认为的你的程序应该去哪里寻找需要的动态库的目，可以用“readelf -d 你的程序”来查看，例子：</p> 
 <blockquote> 
  <p>[root]readelf -d  /opt/bin/ceph-osd</p> 
  <p>Dynamic section at offset 0x10a36e8 contains 59 entries:<br>   Tag        Type                         Name/Value<br>  ……<br>  0x0000000000000001 (NEEDED)             Shared library: [libstdc++.so.6]<br>  0x0000000000000001 (NEEDED)             Shared library: [libm.so.6]<br>  0x0000000000000001 (NEEDED)             Shared library: [libgcc_s.so.1]<br>  0x0000000000000001 (NEEDED)             Shared library: [libc.so.6]<br>  0x0000000000000001 (NEEDED)             Shared library: [ld-linux-x86-64.so.2] 0x000000000000000f (RPATH)              Library rpath: [/opt/lib_upgrade/osd:/opt/lib:/opt/lib_upgrade/ceph-common:/opt/lib:/opt/lib/ceph:/opt/lib/ceph/erasure-code:/opt/lib/ceph/compressor:/opt/lib/ceph/crypto:/opt/lib/rados-classes:/opt/lib_upgrade_reserve/ceph]<br>  0x000000000000000c (INIT)               0x34ffe0<br>  0x000000000000000d (FINI)               0xddee2c<br> ……</p> 
 </blockquote> 
 <p>)</p> 
 <p>仔细查阅寻找之后发现，CMake里面维护了3个比较重要的RPATH变量，即CMAKE_SKIP_RPATH,CMAKE_SKIP_BUILD_RPATH,CMKAE_INSTALL_RPATH.</p> 
 <p>CMAKE_SKIP_RPATH,简单说，就是强制CMake不在构建期间和安装install期间给你加上它所认为的RPATH.(不在动态库中写入RUNPATH项)</p> 
 <blockquote> 
  <pre><code class="has">cmake .. -DCMAKE_SKIP_RPATH=TRUE或CMakelist中加set(CMAKE_SKIP_BUILD_RPATH TRUE)</code> 
</pre> 
 </blockquote> 
 <p>   第二个和第三个变量也比较简单，就是分别在构建期间和安装期间不允许CMake给你加入相关RPATH</p> 
 <pre class="has"><code class="language-bash">cmake .. -DCMAKE_SKIP_BUILD_RPATH=TRUE 或CMakelist中加set(CMAKE_SKIP_BUILD_RPATH=TRUE)
cmake .. -DCMAKE_SKIP_INSTALL_RPATH=TRUE 或CMakelist中加set(CMAKE_SKIP_INSTALL_RPATH=TRUE)</code></pre> 
 <p>当然了，如果你之后想要追加RPATH,只需要对这三个变量设置成FALSE就可以了。</p> 
 <p><a href="https://www.cnblogs.com/rickyk/p/3884257.html" rel="noopener" title="再谈CMake与RPATH()">再谈CMake与RPATH()</a>https://www.cnblogs.com/rickyk/p/3884257.html<a href="https://www.cnblogs.com/rickyk/p/3884257.html" rel="noopener" title="再谈CMake与RPATH()">再谈CMake与RPATH()</a>：</p> 
 <p>CMake为了方便用户的安装，默认在make install之后会自动remove删除掉相关的RPATH,如果我们在运行环境上有个目录：${CMAKE_INSTALL_PREFIX}/lib，我们希望执行make install 之后，RPATH可以自动添加它，我们就可以这么写</p> 
 <pre><code class="has">set(CMAKE_INSTALL_RPATH ${CMAKE_INSTALL_PREFIX}/lib)

需要注意的是，这个变量是全局变量，意味着你所有的target的RPATH都会在install的时候被写成这个

有没有简单的针对某个target呢，聪明的你应该已经想到了</code> 
</pre> 
 <pre><code class="has">set_target_properties(myexe PROPERTIES INSTALL_RPATH "${CMAKE_INSTALL_PREFIX}/lib")</code> 
</pre> 
 <p>这样就可以保证只针对当前的target进行make install的时候RPATH的写入了。</p> 
 <p><em>(扩展：已经生成的可执行文件的RPATH可以用patchelf  工具修改<a href="https://blog.csdn.net/bandaoyu/article/details/113181179" title="https://blog.csdn.net/bandaoyu/article/details/113181179" rel="noopener">https://blog.csdn.net/bandaoyu/article/details/113181179</a>)</em></p> 
 <h4 id="%23%E6%8C%87%E5%AE%9A%E9%93%BE%E6%8E%A5%E6%97%B6%E5%8A%A8%E6%80%81%E5%BA%93%E7%9A%84%E8%B7%AF%E5%BE%84">#指定链接时动态库的路径</h4> 
 <pre class="has"><code class="language-bash">###################################################################################################################
set(OPENCV_DYNAMIC_LIBS  "${CMAKE_CURRENT_SOURCE_DIR}/../lib")       # 动态 opencv native 库路径
add_library(libopencv_core SHARED IMPORTED )
set_target_properties(libopencv_core PROPERTIES   IMPORTED_LOCATION "${OPENCV_DYNAMIC_LIBS}/libopencv_core.so")
add_library(libopencv_highgui SHARED IMPORTED )
set_target_properties(libopencv_highgui PROPERTIES   IMPORTED_LOCATION "${OPENCV_DYNAMIC_LIBS}/libopencv_highgui.so")
add_library(libopencv_imgproc SHARED IMPORTED )
set_target_properties(libopencv_imgproc PROPERTIES   IMPORTED_LOCATION "${OPENCV_DYNAMIC_LIBS}/libopencv_imgproc.so")
add_library(libopencv_video SHARED IMPORTED )
set_target_properties(libopencv_video PROPERTIES   IMPORTED_LOCATION "${OPENCV_DYNAMIC_LIBS}/libopencv_video.so")

set(mOpenCV_LIBS  libopencv_core libopencv_highgui  libopencv_imgproc libopencv_video)

set(CMAKE_CXX_FLAGS "${CMAKE_CXX_FLAGS} -fopenmp ")
target_link_libraries(main ${mOpenCV_LIBS} )</code></pre> 
 <p>类似上面，添加好所有需要的库，链接的时候就能找得到自定义路径lib下面的库了</p> 
 <p><a href="https://blog.csdn.net/JCYAO_/article/details/102519998" title="linux cmake分别指定编译/运行时动态库链接路径:https://blog.csdn.net/JCYAO_/article/details/102519998" rel="noopener">linux cmake分别指定编译/运行时动态库链接路径:https://blog.csdn.net/JCYAO_/article/details/102519998</a></p> 
 <blockquote> 
  <p>set_target_properties 设置目标属性语法是列出您要更改的所有文件，然后提供您接下来要设置的值。</p> 
  <p><a href="https://cmake.org/cmake/help/v3.0/command/set_target_properties.html?highlight=set_target_properties" rel="noopener" title="set_target_properties：https://cmake.org/cmake/help/v3.0/command/set_target_properties.html?highlight=set_target_properties">set_target_properties：https://cmake.org/cmake/help/v3.0/command/set_target_properties.html?highlight=set_target_properties</a></p> 
 </blockquote> 
 <p>cmake会先到*_DIR里指定.cmake文件里去找找不到了才会到/usr里去找</p> 
 <p>所以要小心cmake给你找的文件，如果在一台电脑里装了不止一个版本库(或：多个版本的源码编译后把库放到环境公共目录下)。</p> 
 <p><strong>什么是RPATH?</strong></p> 
 <pre class="has"><code>程序运行时，搜索动态库的顺序(优先级)优先级是这样的：

1. RPATH ，编译链接时加入 -rpath 参数 指定的目录
2. LD_LIBRARY_PATH  这个环境变量指定的目录
3. /etc/ld.so.conf 配置文件。
4. /usr/lib 、 /lib 和 /usr/local/lib ，系统默认路径。</code></pre> 
 <p><em>#其实在Linux环境下，使用<a href="https://so.csdn.net/so/search?q=%E5%8A%A8%E6%80%81%E9%93%BE%E6%8E%A5&amp;spm=1001.2101.3001.7020" title="动态链接" rel="noopener">动态链接</a>的程序会先链接 <code>ld.so</code> 这个库(OS X上是 <code>dyld</code>)，然后通过 <code>ld.so</code> 来查找链接其它的库。</em></p> 
 <h3><a name="t1" rel="noopener"></a></h3> 
 <p><strong>Cmake和RPATH</strong></p> 
 <p>部署程序到机器上后，程序依赖的动态库 机器上的系统内不一定会有，或者自带了的版本不对，所以一般会在程序文件夹内附带其依赖的链接库，所以最好还是把 <code>RPATH</code> 加上。</p> 
 <p>Cmake对RPATH提供了很多选项支持，我们一般只关注这几个变量就好了：</p> 
 <blockquote> 
  <p>CMAKE_SKIP_BUILD_RPATH  (就是不在 可执行文件里面添加Cmake自认为的 RPATH)<br> CMAKE_BUILD_WITH_INSTALL_RPATH (build的时候连接动态库时去INSTALL_RPATH下去找)<br> CMAKE_INSTALL_RPATH (上面的INSTALL_RPATH的值，就用这个啦设置)<br> CMAKE_INSTALL_RPATH_USE_LINK_PATH (用LINK_PATH的值给INSTALL_RPATH)<a name="t2" rel="noopener"></a></p> 
 </blockquote> 
 <h4><a name="t3" rel="noopener"></a></h4> 
 <p><strong>不使用Cmake默认RPATH设置，加上完整的RPATH</strong></p> 
 <p>Cmake默认RPATH设置是这样的：</p> 
 <pre class="has"><code>set(CMAKE_SKIP_BUILD_RPATH FALSE)            # FALSE--&gt;设定编译时加上要RPATH
set(CMAKE_BUILD_WITH_INSTALL_RPATH FALSE)    # FALSE--&gt;编译时RPATH不使用INSTALL_RPATH
set(CMAKE_INSTALL_RPATH "")                  # 设置INSTALL_RPATH为空
set(CMAKE_INSTALL_RPATH_USE_LINK_PATH FALSE) # FALSE--&gt;INSTALL_RPATH不使用LINK_PATH，安装的执行文件不加上RPATH</code></pre> 
 <p>Cmake在默认情况下， <code>make install</code> 会把安装的执行文件的 <code>RPATH</code> 删掉的(即执行文件搜索动态库是不是去<code>RPATH</code> 找)，所以就会出现上面我执行安装好的执行文件报错的问题。</p> 
 <p><strong>Cmake的默认设置我们肯定是不能使用的</strong>，我们需要安装的时候也要带上 <code>RPATH</code> 的设置。</p> 
 <pre class="has"><code>set(INSTALL_LIB_DIR "${PROJECT_BINARY_DIR}/lib") # 假设安装目录在编译目录的lib子目录内
set(CMAKE_SKIP_BUILD_RPATH FALSE)
set(CMAKE_BUILD_WITH_INSTALL_RPATH FALSE)
set(CMAKE_INSTALL_RPATH "${CMAKE_INSTALL_PREFIX}/lib")
set(CMAKE_INSTALL_RPATH_USE_LINK_PATH TRUE)</code></pre> 
 <p><code># 确保链接库不在 系统默认安装的目录 上时更改到项目lib上</code></p> 
 <pre class="has"><code>list(FIND CMAKE_PLATFORM_IMPLICIT_LINK_DIRECTORIES ${CMAKE_INSTALL_RPATH} isSystemDir)
if("${isSystemDir}" STREQUAL "-1")
set(CMAKE_INSTALL_RPATH "${INSTALL_LIB_DIR}")
endif("${isSystemDir}" STREQUAL "-1")</code></pre> 
 <h2 id="cmake%20install%20%E5%92%8C%E6%89%93%E5%8C%85%E8%AE%BE%E5%AE%9A">cmake install 和打包设定</h2> 
 <blockquote> 
  <p>//执行make install的时候 把static_lib  放到bin</p> 
  <p>install(TARGETS  static_lib  DESTINATION  bin)</p> 
  <p>//也可以使用变量</p> 
  <p>install(TARGETS  static_lib  DESTINATION  ${your_path})</p> 
  <p>//还可以一次指定多个对象，并按类型指定放入的目的地</p> 
  <p>install(TARGETS static_lib shared_lib exe  //static_lib shared_lib exe 这个三个对象<br>             RUNTIME DESTINATION bin  //可执行文件放在<code>bin</code>目录<br>             LIBRARY DESTINATION lib     //共享库文件放在<code>lib</code>目录<br>             ARCHIVE DESTINATION lib)  //静态库文件放在<code>lib</code>目录</p> 
  <p>命令第一个参数<code>TARGETS</code>指定需要安装的构建目标的列表，可以是静态库文件、动态库文件、可执行文件；安装时常常按照文件类型安装到不同的子目录，比如库文件放在<code>lib</code>目录，可执行文件放在<code>bin</code>目录。</p> 
  <p>针对不同文件类型，比如(<code>RUNTIME</code>, <code>ARCHIVE</code>, <code>LIBRARY</code>，<code>PUBLIC_HEADER</code>)，可以分开进行配置，比如分别指定安装路径(<code>DESTINATION</code>)、设置文件权限(<code>PERMISSIONS</code>)；如果不是在某个类别下的单独配置，那么就是针对所有类型。</p> 
  <p>值得一提的是，<code>ARCHIVE</code>一般是指静态库，<code>LIBRARY</code>则是指共享库，在不同平台上，略有差异，实际应用感觉不符合预期时查看一下官方文档即可，问题不大。</p> 
 </blockquote> 
 <p>更多详情见文章：</p> 
 <p><a href="https://zhuanlan.zhihu.com/p/377131996" rel="noopener" title="cmake应用：安装和打包：https://zhuanlan.zhihu.com/p/377131996">cmake应用：安装和打包：https://zhuanlan.zhihu.com/p/377131996</a></p> 
 <h2 id="CMakeLists.txt%E5%8D%95%E8%A1%8C%E6%B3%A8%E9%87%8A%E5%92%8C%E5%A4%9A%E8%A1%8C%E6%B3%A8%E9%87%8A">CMakeLists.txt单行注释和多行注释</h2> 
 <p>单行<em>注释</em>:使用“#”多行<em>注释</em>:使用“#[[ ]]”以下图为例</p> 
 <p><img alt="在这里插入图片描述" src="https://images2.imgbox.com/3a/b3/A6FOKSNn_o.png" style="outline: none;"></p> 
 <h2 id="target_link_libraries%20%E4%B8%AD%E7%9A%84PRIVATE%2C%20PUBLIC%2C%20INTERFACE%20%E5%8C%BA%E5%88%AB">target_link_libraries 中的PRIVATE, PUBLIC, INTERFACE 区别</h2> 
 <p>库的依赖关系为：</p> 
 <p>app--&gt;libbar.so--&gt;libfoo.so</p> 
 <table><tbody><tr><th>链接选项</th><th>bar</th><th>app</th></tr><tr><td>PRIVATE</td><td>传入foo</td><td>传入bar</td></tr><tr><td>INTERFACE</td><td>不传入foo</td><td>传入bar，传入foo</td></tr><tr><td>PUBLIC</td><td>传入foo</td><td>传入bar，传入foo</td></tr></tbody></table> 
 <p><a href="https://zhuanlan.zhihu.com/p/493493849" rel="noopener" title="链接选项：PRIVATE，INTERFACE，PUBLIC :https://zhuanlan.zhihu.com/p/493493849">链接选项：PRIVATE，INTERFACE，PUBLIC :https://zhuanlan.zhihu.com/p/493493849</a></p> 
 <p>网上关于 target_link_libraries 中的 PRIVATE, PUBLIC , INTERFACE  的解释大部分是错的，而且不是一般的错，是胡说。 因为这三个属性在不同的命令中使用时意义不同，有很多是从target_include_libraries中抄来的。</p> 
 <p>以下的解释主要场景是linux中，windows不存在这种关系，无需考虑。</p> 
 <p>我们来解释下，假设我们有一个程序 A  , A调用库B, B调用库C. </p> 
 <p>A -&gt; B -&gt; C</p> 
 <p>A link B时不管是private还是public都没关系，毕竟A不需要导出符号，也没有人以API方式调用它。</p> 
 <p>现在主要问题就是B这个库用private还是public.  C是动态库。</p> 
 <p>如果B是动态或静态库，C是动态库，这个问题就会有影响。同样，如果B、C同为静态库时也会有问题。 </p> 
 <p>B用private link C,  此时A link B,但是不知道B-&gt;C这层关系，可以正常link B. 运行时，A-&gt;B-&gt;C 时，B找不到C中的函数。linux下没有直接依赖关系，所有的B/C的依赖都会转到到A下，可以用LDD命令验证，此时A只依赖于B, 不见C, 当B中的函数调用C中的函数时，因为没有加载C, 所以报找不到符号错误。解决的办法就是在A link B时，同样也写上C. 但是因为private的原因，A是不知道C中的符号这事，只能强制 link C到A才能解决。</p> 
 <p>如果B link C时用public 指示， 当编译A时，就会检查到C中的符号没有实现，此时你就会知道要把C link到A来解决这个问题了。</p> 
 <p>其实private/public 解决的是指示问题，本质上可以使用public 来解决， 可以减少坑。</p> 
 <p>下面是target_link_libraries中的解释，不想看英文的，直接拉到最后。</p> 
 <p>Link Inheritance</p> 
 <p>Similarly, for any target, in the linking stage, we would need to decide, given the item to be linked, whether we have to put the item in the link dependencies, or the link interface, or both, in the compiled target. Here the link dependencies means the item has some implementations that the target would use, and it is linked to the item, so that whenever we call the functions or methods corresponding to those implementations it will always be mapped correctly to the implementations in item via the link, whereas the link interface means the target becomes an interface for linking the item for other targets which have dependencies on the target, and the target does not have to use item at all.</p> 
 <p>Link Type    Description<br> PUBLIC    All the objects following PUBLIC will be used for linking to the current target and providing the interface to the other targets that have dependencies on the current target.<br> PRIVATE    All the objects following PRIVATE will only be used for linking to the current target.<br> INTERFACE    All the objects following INTERFACE will only be used for providing the interface to the other targets that have dependencies on the current target.<br> For example, if the fruit library has the implementation of functions, such as size and color, and the apple library has a function apple_size which called the size from the fruit library and was PRIVATE linked with the fruit library. We could create an executable eat_apple that calls apple_size by PUBLIC or PRIVATE linking with the apple library. However, if we want to create an executable eat_apple that calls the size and color from the fruit library, only linking with the apple library will cause building error, since the fruit library was not part of the interface in the apple library, and is thus inaccessible to eat_apple. To make the apple library to inherit the size and color from the fruit library, we have to make the linking of the apple library to the the fruit library PUBLIC instead of PRIVATE.</p> 
 <p>下面用人话(汉语)翻译下：</p> 
 <p>PUBLIC    在public后面的库会被Link到你的target中，并且里面的符号也会被导出，提供给第三方使用。</p> 
 <p>PRIVATE  在private后面的库仅被link到你的target中，并且终结掉，第三方不能感知你调了啥库</p> 
 <p>INTERFACE   在interface后面引入的库不会被链接到你的target中，只会导出符号。</p> 
 <p>---- 更新----------</p> 
 <p>target_link_libraries 会在目标程序中生成rpath, 这点请注意 。<br> 原文链接：https://blog.csdn.net/znsoft/article/details/119035578</p> 
</div>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/27e72a75aa47aaa4e9eec19071541137/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">【ceph】CEPH源码解析：读写流程</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/5977d79367a6628a8126be5c16c3dd24/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">ZUFEOJ平台【求一个整数的各位数字】</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>