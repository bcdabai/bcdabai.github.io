<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>基础部分 - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="基础部分" />
<meta property="og:description" content="数组怎么转成集合; 采用数组.asList()方法
List list = new ArrayList(); list = Arrays.asList(array); 注意：对于int[]数组不能直接这样做，因为asList()方法的参数必须是对象。应该先把int[]转化为Integer[]。 如果转成Set集合如下：
Set set = new HashSet(Array.asList(array)); 使用list构造set 写一个Singleton; (代码编程类问题) 第一种：
public class Singleton { private Singleton(){} private static Singleton instance = new Singleton(); public static Singleton getInstance() { return instance; } } 第二种：
public class Singleton { private static Singleton instance = null; public static synchronized Singleton getInstance() { if (instance==null) instance＝new Singleton(); return instance; } } } 异常的抛出,throws、throw、try、catch、finally分别有什么意义 一般情况下是用try来执行一段程序，如果出现异常，系统会抛出（throws）一个异常，这时候你可以通过它的类型来捕捉（catch）它，或最后（finally）由缺省处理器来处理。 try：指定一块预防所有“异常”的程序。 catch：紧跟在try程序后面，应包含一个catch子句来指定你想要捕捉的“异常”的类型。 throw：用来明确地抛出一个“异常”。 throws：标明一个成员函数可能抛出的各种“异常”。 Finally：不管发生什么“异常”都被执行一段代码。 Collection和Collections的区别 Collection 是一个集合接口。它提供了对集合对象进行基本操作的通用接口方法。Collection接口在Java 类库中有很多具体的实现。Collection接口的意义是为各种具体的集合提供了最大化的统一操作方式。 Collections 是一个包装类。它包含有各种有关集合操作的静态多态方法。此类不能实例化，就像一个工具类，服务于Java的Collection框架。 四个访问修饰符的级别是什么？ Collection 是一个集合接口。它提供了对集合对象进行基本操作的通用接口方法。Collection接口在Java 类库中有很多具体的实现。Collection接口的意义是为各种具体的集合提供了最大化的统一操作方式。 Collections 是一个包装类。它包含有各种有关集合操作的静态多态方法。此类不能实例化，就像一个工具类，服务于Java的Collection框架。 怎样对一个集合内的元素排序 用Java中提供的对集合进行操作的工具类Collections，其中的sort方法。 String和StringBuffer的区别 就是一个变量和常量的关系。 StringBuffer对象的内容可以修改，StringBuffer在进行字符串处理时，不生成新的对象，在内存使用上要优于String类。 而String对象一旦产生后就不可以被修改，重新赋值其实是两个对象。 StringBuffer是线程安全的，在多线程程序中也可以很方便的进行使用，但是程序的执行效率相对来说就要稍微慢一些。 ”==”和equals方法究竟有什么区别？ java中的数据类型，可分为两类： 1." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/971e29e8fcb69fb3a53405f91ee10489/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2018-09-12T10:24:11+08:00" />
<meta property="article:modified_time" content="2018-09-12T10:24:11+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">基础部分</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-light">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p>数组怎么转成集合; <br> 采用数组.asList()方法</p> 
<pre class="prettyprint"><code class=" hljs php"><span class="hljs-keyword">List</span> <span class="hljs-keyword">list</span> = <span class="hljs-keyword">new</span> ArrayList();
<span class="hljs-keyword">list</span> = Arrays.asList(<span class="hljs-keyword">array</span>);  </code></pre> 
<p>注意：对于int[]数组不能直接这样做，因为asList()方法的参数必须是对象。应该先把int[]转化为Integer[]。 <br> 如果转成Set集合如下：</p> 
<pre class="prettyprint"><code class=" hljs vbscript"><span class="hljs-keyword">Set</span> <span class="hljs-keyword">set</span> = <span class="hljs-keyword">new</span> HashSet(<span class="hljs-built_in">Array</span>.asList(<span class="hljs-built_in">array</span>)); </code></pre> 
<p>使用list构造set <br> 写一个Singleton; (代码编程类问题) <br> 第一种：</p> 
<pre class="prettyprint"><code class=" hljs cs"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> Singleton {
<span class="hljs-keyword">private</span> <span class="hljs-title">Singleton</span>(){}
<span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Singleton instance = <span class="hljs-keyword">new</span> Singleton();
<span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Singleton <span class="hljs-title">getInstance</span>() {
    <span class="hljs-keyword">return</span> instance;
}
}</code></pre> 
<p>第二种：</p> 
<pre class="prettyprint"><code class=" hljs cs"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> Singleton {
<span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Singleton instance = <span class="hljs-keyword">null</span>;
<span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> synchronized Singleton <span class="hljs-title">getInstance</span>() {
            <span class="hljs-keyword">if</span> (instance==<span class="hljs-keyword">null</span>)
                instance＝<span class="hljs-keyword">new</span> Singleton();
                <span class="hljs-keyword">return</span> instance;  
}
}
}</code></pre> 
<p>异常的抛出,<code>throws、throw、try、catch、finally</code>分别有什么意义 <br> 一般情况下是用try来执行一段程序，如果出现异常，系统会抛出（<code>throws</code>）一个异常，这时候你可以通过它的类型来捕捉（<code>catch</code>）它，或最后（finally）由缺省处理器来处理。 <br> <code>try</code>：指定一块预防所有“异常”的程序。 <br> <code>catch</code>：紧跟在try程序后面，应包含一个catch子句来指定你想要捕捉的“异常”的类型。 <br> <code>throw</code>：用来明确地抛出一个“异常”。 <br> <code>throws</code>：标明一个成员函数可能抛出的各种“异常”。 <br> <code>Finally</code>：不管发生什么“异常”都被执行一段代码。 <br> <code>Collection</code>和<code>Collections</code>的区别 <br> <code>Collection</code> 是一个集合接口。它提供了对集合对象进行基本操作的通用接口方法。Collection接口在Java 类库中有很多具体的实现。Collection接口的意义是为各种具体的集合提供了最大化的统一操作方式。 <br> Collections 是一个包装类。它包含有各种有关集合操作的静态多态方法。此类不能实例化，就像一个工具类，服务于Java的Collection框架。 <br> 四个访问修饰符的级别是什么？ <br> Collection 是一个集合接口。它提供了对集合对象进行基本操作的通用接口方法。Collection接口在Java 类库中有很多具体的实现。<code>Collection</code>接口的意义是为各种具体的集合提供了最大化的统一操作方式。 <br> <code>Collections</code> 是一个包装类。它包含有各种有关集合操作的静态多态方法。此类不能实例化，就像一个工具类，服务于Java的<code>Collection</code>框架。 <br> 怎样对一个集合内的元素排序 <br> 用Java中提供的对集合进行操作的工具类<code>Collections</code>，其中的<code>sort</code>方法。 <br> <code>String</code>和<code>StringBuffer</code>的区别 <br> 就是一个变量和常量的关系。 <br> <code>StringBuffer</code>对象的内容可以修改，<code>StringBuffer</code>在进行字符串处理时，不生成新的对象，在内存使用上要优于<code>String</code>类。 <br> 而String对象一旦产生后就不可以被修改，重新赋值其实是两个对象。 <br> StringBuffer是线程安全的，在多线程程序中也可以很方便的进行使用，但是程序的执行效率相对来说就要稍微慢一些。 <br> ”==”和equals方法究竟有什么区别？ <br> java中的数据类型，可分为两类： <br> 1.基本数据类型，也称原始数据类型。<code>byte,short,char,int,long,float,double,boolean</code> <br> 他们之间的比较，应用双等号（==）,比较的是他们的值。 <br> 2.复合数据类型(类) <br> 当他们用（==）进行比较的时候，比较的是他们在内存中的存放地址，所以，除非是同一个new出来的对象，他们的比较后的结果为true，否则比较后结果为false。 JAVA当中所有的类都是继承于Object这个基类的，在Object中的基类中定义了一个equals的方法，这个方法的初始行为是比较对象的内存地 址，但在一些类库当中这个方法被覆盖掉了，如<code>String,Integer,Date</code>在这些类当中<code>equals</code>有其自身的实现，而不再是比较类在堆内存中的存放地址了。 <br> 对于复合数据类型之间进行<code>equals</code>比较，在没有覆写equals方法的情况下，他们之间的比较还是基于他们在内存中的存放位置的地址值的，因为Object的equals方法也是用双等号（==）进行比较的，所以比较后的结果跟双等号（==）的结果相同。</p> 
<p>不用构造函数也能创建对象吗?请用程序实现;(代码编程类问题) <br> 利用java反射机制<code>Class.forName("全限定名").newInstance()</code>可以创建对象。 <br> 用过哪些设计模式; <br> 普通工厂模式，就是建立一个工厂类，对实现了同一接口的一些类进行实例的创建 <br> 单例模式:该对象只有一个实例存在 <br> 代理模式: 每个模式名称就表明了该模式的作用，代理模式就是多一个代理类出来，替原对象进行一些操作 <br> 观察者模式（Observer）: 当一个对象变化时，其它依赖该对象的对象都会收到通知，并且随着变化 <br> 项目常用的几个集合,为什么用那个. <br> A:常用的集合： <br> <code>List</code>：当需要存储有顺序，可重复的数据时 <br> <code>Vector</code>：多线程中，线程安全的方式存储有序、可重复的数据时 <br> <code>Set</code>：存储无序，不可重复的数据时 <br> <code>Map</code>：存储键值对时 <br> 请介绍一下MVC架构 <br> MVC架构是一种常见的软件分层的模式，<code>Model View Controller</code>，将程序分成3层。 <br> 在MVC中，客户端所请求的URL是先被映射到相应的Controller中 <br> 然后由<code>Controller</code>来处理业务逻辑，它是从Model中取数据（Model可能会去访问数据库），然后再由Controller根据业务逻辑，选择合适的View呈现给客户端 <br> 有两个集合 A 和 B 怎样通过代码查找两个集合的公共元素</p> 
<pre class="prettyprint"><code class=" hljs avrasm"> public static void main(String[] args) {
    <span class="hljs-keyword">Set</span>&lt;Integer&gt; a = new HashSet&lt;Integer&gt;()<span class="hljs-comment">;</span>
    <span class="hljs-keyword">Set</span>&lt;Integer&gt; b = new HashSet&lt;Integer&gt;()<span class="hljs-comment">;</span>
    a<span class="hljs-preprocessor">.add</span>(<span class="hljs-number">1</span>)<span class="hljs-comment">;</span>
    a<span class="hljs-preprocessor">.add</span>(<span class="hljs-number">2</span>)<span class="hljs-comment">;</span>
    b<span class="hljs-preprocessor">.add</span>(<span class="hljs-number">2</span>)<span class="hljs-comment">;</span>
    b<span class="hljs-preprocessor">.add</span>(<span class="hljs-number">3</span>)<span class="hljs-comment">;</span>
    <span class="hljs-keyword">Set</span>&lt;Integer&gt; a1 = new HashSet&lt;Integer&gt;()<span class="hljs-comment">;</span>
    <span class="hljs-keyword">Set</span>&lt;Integer&gt; b1 = new HashSet&lt;Integer&gt;()<span class="hljs-comment">;</span>

    a1<span class="hljs-preprocessor">.addAll</span>(a)<span class="hljs-comment">;</span>
    b1<span class="hljs-preprocessor">.addAll</span>(b)<span class="hljs-comment">;</span>

    System<span class="hljs-preprocessor">.out</span><span class="hljs-preprocessor">.println</span>(<span class="hljs-string">"a1 as the clone of a:"</span>+a1)<span class="hljs-comment">;</span>
    System<span class="hljs-preprocessor">.out</span><span class="hljs-preprocessor">.println</span>(<span class="hljs-string">"b1 as the clone of b:"</span>+b1)<span class="hljs-comment">;</span>

    a1<span class="hljs-preprocessor">.removeAll</span>(b)<span class="hljs-comment">;</span>
    b1<span class="hljs-preprocessor">.removeAll</span>(a)<span class="hljs-comment">;</span>

    System<span class="hljs-preprocessor">.out</span><span class="hljs-preprocessor">.println</span>(<span class="hljs-string">"In a but not in b:"</span>+a1)<span class="hljs-comment">;</span>
    System<span class="hljs-preprocessor">.out</span><span class="hljs-preprocessor">.println</span>(<span class="hljs-string">"In b but not in a:"</span>+b1)<span class="hljs-comment">;</span>
}</code></pre> 
<p>Java Map 如何循环 <br> 假设map的 键值 都是String 类型的。</p> 
<pre class="prettyprint"><code class=" hljs vbscript"><span class="hljs-keyword">Set</span>&lt;<span class="hljs-built_in">String</span>&gt; keys =  map.keySet();
Iterator&lt;<span class="hljs-built_in">String</span>&gt; keyIter = keys.iterator();
<span class="hljs-keyword">while</span>(keyIter.hasNext()){
    <span class="hljs-built_in">String</span> key = keyIter.<span class="hljs-keyword">next</span>();
    <span class="hljs-built_in">String</span>  value = map.<span class="hljs-keyword">get</span>(key);</code></pre> 
<p>父类不想被继承,怎么做; <br> final修饰的类，不能被继承。 <br> 如何求字符串中最大的连续出现的公共部分;</p> 
<pre class="prettyprint"><code class=" hljs axapta"> <span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SearchChar</span> {<!-- --></span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">char</span> search(String <span class="hljs-keyword">str</span>){
        <span class="hljs-keyword">int</span> lenght=<span class="hljs-keyword">str</span>.length();
        <span class="hljs-keyword">int</span> max=<span class="hljs-number">0</span>;
        <span class="hljs-keyword">int</span> <span class="hljs-keyword">index</span>=<span class="hljs-number">0</span>;
        <span class="hljs-keyword">int</span> j;
        <span class="hljs-keyword">char</span> ch = <span class="hljs-keyword">str</span>.charAt(<span class="hljs-number">0</span>);
        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;lenght;){
            <span class="hljs-keyword">index</span>=<span class="hljs-number">0</span>;
            <span class="hljs-keyword">for</span>(j=i+<span class="hljs-number">1</span>;j&lt;lenght;j++){
                <span class="hljs-keyword">if</span>(<span class="hljs-keyword">str</span>.charAt(i)==<span class="hljs-keyword">str</span>.charAt(j))
                    <span class="hljs-keyword">index</span>++;
                <span class="hljs-keyword">else</span> 
                    <span class="hljs-keyword">break</span>;
            }       
            <span class="hljs-keyword">if</span>(<span class="hljs-keyword">index</span>&gt;max){
                max=<span class="hljs-keyword">index</span>;
                ch=<span class="hljs-keyword">str</span>.charAt(i);
            }
            i=j;
        }
        <span class="hljs-keyword">return</span> ch;
    }
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> main(String[] args) {
        <span class="hljs-comment">// TODO Auto-generated method stub</span>
        SearchChar sc=<span class="hljs-keyword">new</span> SearchChar();
        <span class="hljs-keyword">char</span> ch=sc.search(<span class="hljs-string">"ssddfffffffdseeeedsa"</span>);
        System.out.println(ch);
    }

}</code></pre> 
<p>冒泡排序算法 </p> 
<pre class="prettyprint"><code class=" hljs perl"><span class="hljs-keyword">int</span>[] <span class="hljs-keyword">values</span>={<!-- --><span class="hljs-number">3</span>,<span class="hljs-number">1</span>,<span class="hljs-number">6</span>,<span class="hljs-number">2</span>,<span class="hljs-number">9</span>,<span class="hljs-number">0</span>,<span class="hljs-number">7</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>};
<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-keyword">values</span>.<span class="hljs-keyword">length</span>-<span class="hljs-number">1</span>;i++){ 
      <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=<span class="hljs-number">0</span>;j&lt;<span class="hljs-keyword">values</span>.<span class="hljs-keyword">length</span>-i-<span class="hljs-number">1</span>;j++){
        <span class="hljs-keyword">if</span>(<span class="hljs-keyword">values</span>[j]&gt;<span class="hljs-keyword">values</span>[j+<span class="hljs-number">1</span>]){
          <span class="hljs-keyword">int</span> temp=<span class="hljs-keyword">values</span>[j];
          <span class="hljs-keyword">values</span>[j]=<span class="hljs-keyword">values</span>[j+<span class="hljs-number">1</span>];
          <span class="hljs-keyword">values</span>[j+<span class="hljs-number">1</span>]=temp;
        }
      }
}

 <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-keyword">values</span>.<span class="hljs-keyword">length</span>;i++){<!-- --><span class="hljs-regexp">//</span>排序后打印数组中的元素
      System.out.println(<span class="hljs-keyword">values</span>[i]);
 }
<span class="hljs-keyword">int</span>型数组<span class="hljs-keyword">int</span> arr[]{<!-- --><span class="hljs-number">19</span>,<span class="hljs-number">20</span>,<span class="hljs-number">48</span>,<span class="hljs-number">30</span>,<span class="hljs-number">5</span>,<span class="hljs-number">0</span>......},数组内元素无序配列，请自己写出一个冒泡排序算法,实现该数组的从小到大排序. 
<span class="hljs-keyword">int</span>[] <span class="hljs-keyword">values</span>={<!-- --><span class="hljs-number">19</span>,<span class="hljs-number">20</span>,<span class="hljs-number">48</span>,<span class="hljs-number">30</span>,<span class="hljs-number">5</span>,<span class="hljs-number">0</span>},;

<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-keyword">values</span>.<span class="hljs-keyword">length</span>-<span class="hljs-number">1</span>;i++){ 
      <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=<span class="hljs-number">0</span>;j&lt;<span class="hljs-keyword">values</span>.<span class="hljs-keyword">length</span>-i-<span class="hljs-number">1</span>;j++){
        <span class="hljs-keyword">if</span>(<span class="hljs-keyword">values</span>[j]&gt;<span class="hljs-keyword">values</span>[j+<span class="hljs-number">1</span>]){
          <span class="hljs-keyword">int</span> temp=<span class="hljs-keyword">values</span>[j];
          <span class="hljs-keyword">values</span>[j]=<span class="hljs-keyword">values</span>[j+<span class="hljs-number">1</span>];
          <span class="hljs-keyword">values</span>[j+<span class="hljs-number">1</span>]=temp;
        }
      }
}

 <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-keyword">values</span>.<span class="hljs-keyword">length</span>;i++){<!-- --><span class="hljs-regexp">//</span>排序后打印数组中的元素
      System.out.println(<span class="hljs-keyword">values</span>[i]);
  }</code></pre> 
<p>Map是有序的么？如果不是，怎么设置有序的map <br> 答：Map不是有序的 <br> 使用LinkedHashMap 才能保证迭代的时候取出的顺序和存入的顺序相同 <br> 重写和重载的特点和区别？ <br> 特点： <br> 方法重载：就是在同一个类中，方法的名字相同，但参数个数、参数的类型或返回值类型不同！ <br> 方法重写：它是指子类和父类的关系，子类重写了父类的方法，但方法名、参数类型、参数个数必须相同！ <br> 重写和重载的区别在于： <br> 重写多态性起作用，对调用被重载过的方法可以大大减少代码的输入量，同一个方法名只要往里面传递不同的参数就可以拥有不同的功能或返回值． <br> 用好重写和重载可以设计一个结构清晰而简洁的类 <br> 抽象类和接口有什么样的区别？ <br> 抽象类： <br> 1) 抽象方法，只有行为的概念，没有具体的行为实现。 <br> 使用：abstract 关键字修饰，并且没有方法体。 <br> 2) 包含抽象方法的类，就一定是抽象类。 <br> 使用： abstract 关键字修饰，包含抽象方法。 <br> 3) 抽象类不能直接创建实例。可以定义引用变量。 <br> 4) 抽象类只能被继承，一个具体类继承一个抽象类，必须实 <br> 现所有抽象方法。 <br> 5) 抽象方法和抽象类非常适合作为系统的分析和设计的工具。 <br> 接口： <br> 1)接口：全部的方法都是抽象方法，全部的属性都是常量。 <br> 接口用来表示纯抽象概念，没有任何具体的方法和属性。 <br> 2) 不能实例化，可以定义变量。 <br> 3) 接口变量可以引用具体实现类的实例。 <br> 4) 接口只能被实现(继承)，一个具体类实现接口，必须使用全部的 <br> 抽象方法。 <br> 5) 接口之间可以继承。 <br> 6) 一个具体类可以实现多个接口，实现多继承现象，表示： <br> 7) 接口中的属性，默认是常量 public static final <br> 8) 接中的方法一定是:public abstract <br> 9) 实现一个接口，使用关键字implements, 实现实际上是 <br> 一种继承关系。接口和实现类是父子类型的关系 <br> 请说明ArrayList与Vector的区别。 <br> 这两个类都实现了List接口（List接口继承了Collection接口），他们都是有序集合，即存储在这两个集合中的元素的位置都是有顺序的，相当于一种动态的数组，我们以后可以按位置索引号取出某个元素，，并且其中的数据是允许重复的，这是HashSet之类的集合的最大不同处，HashSet之类的集合不可以按索引号去检索其中的元素，也不允许有重复的元素（本来题目问的与hashset没有任何关系，但为了说清楚ArrayList与Vector的功能，我们使用对比方式，更有利于说明问题）。</p> 
<p>接着才说ArrayList与Vector的区别，这主要包括两个方面：. <br> 同步性： <br> Vector是线程安全的，也就是说是它的方法之间是线程同步的，而ArrayList是线程序不安全的，它的方法之间是线程不同步的。如果只有一个线程会访问到集合，那最好是使用ArrayList，因为它不考虑线程安全，效率会高些；如果有多个线程会访问到集合，那最好是使用Vector，因为不需要我们自己再去考虑和编写线程安全的代码。</p> 
<p>备注：对于Vector&amp;ArrayList、Hashtable&amp;HashMap，要记住线程安全的问题，记住Vector与Hashtable是旧的，是java一诞生就提供了的，它们是线程安全的，ArrayList与HashMap是java2时才提供的，它们是线程不安全的。所以，我们讲课时先讲老的。</p> 
<p>数据增长： <br> ArrayList与Vector都有一个初始的容量大小，当存储进它们里面的元素的个数超过了容量时，就需要增加ArrayList与Vector的存储空间，每次要增加存储空间时，不是只增加一个存储单元，而是增加多个存储单元，每次增加的存储单元的个数在内存空间利用与程序效率之间要取得一定的平衡。Vector默认增长为原来两倍，而ArrayList的增长策略在文档中没有明确规定（从源代码看到的是增长为原来的1.5倍）。ArrayList与Vector都可以设置初始的空间大小，Vector还可以设置增长的空间大小，而ArrayList没有提供设置增长空间的方法。 <br> 总结：即Vector增长原来的一倍，ArrayList增加原来的0.5倍。</p> 
<p>怎样对一个集合进行排序？ <br> Java针对数组和List的排序都有实现，对数组而言，你可以直接使用Arrays.sort，对于List和Vector而言，你可以使用Collections.sort方法。 <br> Java API针对集合类型的排序提供了2个方法:</p> 
<pre class="prettyprint"><code class=" hljs avrasm">java<span class="hljs-preprocessor">.util</span><span class="hljs-preprocessor">.Collections</span><span class="hljs-preprocessor">.sort</span>(java<span class="hljs-preprocessor">.util</span><span class="hljs-preprocessor">.List</span>)
java<span class="hljs-preprocessor">.util</span><span class="hljs-preprocessor">.Collections</span><span class="hljs-preprocessor">.sort</span>(java<span class="hljs-preprocessor">.util</span><span class="hljs-preprocessor">.List</span>, java<span class="hljs-preprocessor">.util</span><span class="hljs-preprocessor">.Comparator</span>)</code></pre> 
<p>如果集合里面的元素都是相同类型的，并且实现了Comparable接口，那么可以直接调用第一个方法。 <br> 如果你有其它的排序的想法，比如你不想按照自然排序进行，还可以传一个Comparator过去，比如反向。 <br> 总的来说，如果你有一个新的类，比如Player，那么你要想对其进行排序，就让其实现Comparable接口，并且实现compareTo方法。比如比想按照年龄的大小来排序，从小的进行，那么你就实现如下:</p> 
<pre class="prettyprint"><code class=" hljs cs"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> Player implements Comparable&lt;Player&gt;{  
       <span class="hljs-keyword">private</span> String name;  
       <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> age;  

       <span class="hljs-keyword">public</span> <span class="hljs-title">Player</span>(String name, <span class="hljs-keyword">int</span> age){  
          <span class="hljs-keyword">this</span>.name=name;  
          <span class="hljs-keyword">this</span>.age=age;  
       }  

       <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getAge</span>(){  
          <span class="hljs-keyword">return</span> age;  
       }  

       <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setAge</span>(<span class="hljs-keyword">int</span> age){  
       <span class="hljs-keyword">this</span>.age = age;  
       }  
       <span class="hljs-comment">//实现接口方法，将来排序的时候sort看正负数还是零来进行判断大小   </span>
       @Override  
       <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">compareTo</span>(Player player){  
             <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.getAge() - player.getAge();  
       }  
}  </code></pre> 
<p>JDBC访问数据库的步骤 <br> 1、加载JDBC驱动 <br> 2、建立数据库连接 <br> 3、创建一个语句对象 <br> 4、执行SQL语句 <br> 5、处理结果集 <br> 6、关闭数据库链接 <br> Statement和PreparedStatement的区别 <br> 1、Preparestatement接口继承Statement，PrepareStatement实例包含已编译的SQL语句，所以执行速度要高于Statement。 <br> 2、PrepareStatement的代码可读性和可维护性高。极大的提高了安全性能，防止SQL注入带来的安全隐患。</p> 
<p>如何找出两个List中的重复部分 <br> List里面有一个“contains”的方法，可以知道list里面是否存在某个值：</p> 
<pre class="prettyprint"><code class=" hljs cs">import java.util.ArrayList;
import java.util.List;

<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> Test{
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> List&lt;Integer&gt; <span class="hljs-title">getIntersection</span>(List&lt;Integer&gt; list1,
            List&lt;Integer&gt; list2) {
        List&lt;Integer&gt; result = <span class="hljs-keyword">new</span> ArrayList&lt;Integer&gt;();
        <span class="hljs-keyword">for</span> (Integer integer : list2) {<!-- --><span class="hljs-comment">//遍历list1</span>
            <span class="hljs-keyword">if</span> (list1.contains(integer)) {<!-- --><span class="hljs-comment">//如果存在这个数</span>
                <span class="hljs-comment">//放进一个list里面，这个list就是交集</span>
                result.add(integer);
            }
        }
        <span class="hljs-keyword">return</span> result;
    }

    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span>(String[] args) {
        List&lt;Integer&gt; list1 = <span class="hljs-keyword">new</span> ArrayList&lt;Integer&gt;();
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">7</span>; i++) {
            list1.add(i);
        }
        List&lt;Integer&gt; list2 = <span class="hljs-keyword">new</span> ArrayList&lt;Integer&gt;();
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">3</span>; i &lt; <span class="hljs-number">10</span>; i++) {
            list2.add(i);
        }
        System.<span class="hljs-keyword">out</span>.println(<span class="hljs-string">"List1："</span> + list1);
        System.<span class="hljs-keyword">out</span>.println(<span class="hljs-string">"List2："</span> + list2);
        System.<span class="hljs-keyword">out</span>.println(<span class="hljs-string">"交集为"</span> + getIntersection(list1, list2));
    }
}</code></pre> 
<p>子类如何实现父类构造？ <br> 子类不能继承父类的显式定义的构造方法，若想要继承父类的构造方法，需要通过覆盖该构造方法，并在方法中通过super调用父类的该构造方法的方式来继承。</p> 
<p>List和Map的区别 <br> List接口 继承collection接口，Map是个顶级接口 <br> List此接口的用户可以对列表中每个元素的插入位置进行精确地控制。 <br> 用户可以根据元素的整数 索引（在列表中的位置）访问元素，并搜索列表中的元素 <br> 元素按照插入的顺序存放，可以重复 <br> Map将键映射到值的对象。一个映射不能包含重复的键，每个键最多只能映射到一个值 <br> Java Web部分 <br> 页面端使用何种动态标签库的展现技术？各举几个常用的标签例子. <br> JSP 中JSTL核心标签库，按功能分为通用标签库，条件标签库，迭代标签库。 <br> 例： <br> page,context,request,response,session的区别; <br> request是封装client端（也就是用户通过browser）提交的请求数据和属性的对象。 <br> response是封装web server端响应数据和属性的对象。 <br> pageContext，request，session，application是指变量（对象）的生命周期。 <br> 我们经常会将pageContext、request、session和application混为一谈，因为它们都可以通过setAttribute()和getAttribute()来设定或读取属性。但它们之间是有别的，它们最大的区别在于使用范围。 <br> pageContext对象的范围只适用于当前页面范围，即超过这个页面就不能够使用了。所以使用pageContext对象向其它页面传递参数是不可能的。 <br> request对象的范围是指在一JSP网页发出请求到另一个JSP网页之间，随后这个属性就失效。 <br> session的作用范围为一段用户持续和服务器所连接的时间，但与服务器断线后，这个属性就无效。比如断网或者关闭浏览器。</p> 
<p>application的范围在服务器一开始执行服务，到服务器关闭为止。它的范围最大，生存周期最长。 <br> Servlet中的forward和redirect有什么区别? <br> forward是服务器内部重定向，程序收到请求后重新定向到另一个程序，客户机并不知道；redirect则是服务器收到请求后发送一个状态头给客户，客户将再请求一次，这里多了两次网络通信的来往。 <br> 1.从地址栏显示来说 <br> forward是服务器请求资源,服务器直接访问目标地址的URL,把那个URL的响应内容读取过来,然后把这些内容再发给浏览器.浏览器根本不知道服务器发送的内容从哪里来的,所以它的地址栏还是原来的地址. <br> redirect是服务端根据逻辑,发送一个状态码,告诉浏览器重新去请求那个地址.所以地址栏显示的是新的URL.所以redirect等于客户端向服务器端发出两次request，同时也接受两次response。 <br> 2.从数据共享来说 <br> forward:转发页面和转发到的页面可以共享request里面的数据. <br> redirect:不能共享数据. <br> redirect不仅可以重定向到当前应用程序的其他资源,还可以重定向到同一个站点上的其他应用程序中的资源,甚至是使用绝对URL重定向到其他站点的资源. <br> forward,方法只能在同一个Web应用程序内的资源之间转发请求.forward 是服务器内部的一种操作. <br> redirect 是服务器通知客户端,让客户端重新发起请求. <br> 所以,你可以说 redirect 是一种间接的请求, 但是你不能说”一个请求是属于forward还是redirect ” <br> 3.从运用地方来说 <br> forward:一般用于用户登陆的时候,根据角色转发到相应的模块. <br> redirect:一般用于用户注销登陆时返回主页面和跳转到其它的网站等. <br> 4.从效率来说 <br> forward:高. <br> redirect:低. <br> Servlet的生命周期是什么 <br> Servlet被服务器实例化后，容器运行其init方法，请求到达时运行其service方法，service方法自动派遣运行与请求对应的doXXX方法（doGet，doPost）等，当服务器决定将实例销毁的时候调用其destroy方法。</p> 
<p>JSP的九个内置对象; <br> request对象 response对象 session对象 application对象 out对象 <br> cookie对象 config对象 page对象 exception对象</p> 
<p>数据库部分 <br> 数据库中左右连接的区别 <br> A:左右连接都是外连接，外连接是根据主表数据进行联表查询。 <br> 如果主表中存在数据，则会添加到结果虚拟表中。如果从表存在数据，则连接到主表数据之后；否则主表数据之后，以null补齐所有列 <br> 左连接是已左边表中的数据为基准，若左表有数据右表没有数据，则显示左表中的数据右表中的数据显示为空。 <br> 左联接的结果集包括 LEFT 子句中指定的左表的所有行，而不仅仅是联接列所匹配的行。如果左表的某行在右表中没有匹配行，则在相关联的结果集行中右表的所有选择列表列均为空值。 <br> 右联接是左向外联接的反向联接。将返回右表的所有行。如果右表的某行在左表中没有匹配行，则将为左表返回空值。 <br> 左连接,右连接，内连接，外连接的区别 <br> 内联接（典型的联接运算，使用像 = 或 &lt;&gt; 之类的比较运算符）。包括相等联接和自然联接。 <br> 内联接使用比较运算符根据每个表共有的列的值匹配两个表中的行。例如，检索 students和courses表中学生标识号相同的所有行。 <br> 外联接。外联接可以是左向外联接、右向外联接或完整外部联接。 <br> 在 FROM子句中指定外联接时，可以由下列几组关键字中的一组指定： <br> 1）LEFT JOIN或LEFT OUTER JOIN <br> 左向外联接的结果集包括 LEFT OUTER子句中指定的左表的所有行，而不仅仅是联接列所匹配的行。如果左表的某行在右表中没有匹配行，则在相关联的结果集行中右表的所有选择列表列均为空值。 <br> 2）RIGHT JOIN 或 RIGHT OUTER JOIN <br> 右向外联接是左向外联接的反向联接。将返回右表的所有行。如果右表的某行在左表中没有匹配行，则将为左表返回空值。</p> 
<p>MySQL中in 和exsit区别 <br> mysql中的in语句是把外表和内表作hash 连接，而exists语句是对外表作loop循环 <br> 每次loop循环再对内表进行查询。 <br> 一直大家都认为exists比in语句的效率要高，这种说法其实是不准确的。这个是要区分环境的。 <br> 如果查询的两个表大小相当，那么用in和exists差别不大 <br> 数据库的操作，如组合查询、如何同时删除两张表中的相同名称的没有关联的两个列还有分页语句（笔试环节手写SQL语句） <br> 1、在设计数据库表时，通过设置级联删除操作来完成。 <br> 2、可以写触发器完成操作。 <br> 3、先删除主表的数据行，然后根据关联的外键值来删除附表中的相应行数据即可。 <br> 具体方法： <br> 作为外键暂且叫它主表，Delete from Main Where id=@id <br> 则要先删除子表当中 Delete from Detail where MainId = @id <br> 为了保证数据完整性，最好将上面的操作包含在一个事务中，如果两个语句影响的行数都大于零，则提交，否则回滚。 <br> select top 5 * from bean where id not in (select top “+5*(pageNum-1)+” id from bean order by id); <br> 如何查询表中的重复记录，根据字段id来查询 <br> select id from table group by id having count(*)&gt;1 <br> 两张表做联合查询,分别使用left join、right join、inner join、outter join,请问结果集上有什么区别？ <br> 关联查询，分为内连接，与外连接。内连接叫做inner join.外连接叫做outter join .外连接又分为左外连接（left join）与右外连接(right join). <br> 内连接，是查询出两个表又关联的记录、 <br> 左外连接，是以左边的表为基准，会将左边表的记录全部查出，即使在关联表中没相关记录，也会展示 <br> 右外连接：与左外连接相似，以右边的表为基准，会将右边的表全部展示。 <br> 写出一个计每个学生总分，按总分倒序排列，并且只要分数大于300的结果 <br> select studentNo as 学号,sum(Score) as 总成绩 from Score group by studentNo having sum(Score)&gt;300 order by sum(Score) desc <br> Web Service部分 <br> Web service 有哪些相关技术 <br> 在构建和使用Web Service时,主要用到以下几个关键的技术和规则: 　　 <br> 1.XML:描述数据的标准方法. 　 <br> 2.SOAP:表示信息交换的协议. 　　 <br> 3.WSDL:Web服务描述语言. 　　 <br> 4.UDDI(Universal Description, Discovery and Integration):通用描述、发现与集成，它是一种独立于平台的，基于XML语言的用于在互联网上描述商务的协议。 <br> 在不同的系统之间通过Web Service实现集成时,WSDL的存在有什么意义,它有什么样的实用价值？ <br> WSDL（Web Services Description Language，网络服务描述语言）是基于 XML 的语言，用于描述 Web Services 以及如何对它们进行访问。正是因为 WSDL 符合国际标准，Web Service调用端（客户端）通过标准的WSDL就可以知道如何调用服务，而不必关心、了解 Web Service内在实现的细节。 <br> jQuery&amp;Ajax部分 <br> Ajax如何提交一个JavaBean <br> 在jqery中有这样一个方法，$.post()下面就这个方法做一个简单的实例： <br> jQuery.post( url, [data], [callback], [type] ) ： <br> 使用POST方式来进行异步请求 <br> url (String) : 发送请求的URL地址. <br> data (Map) : (可选) 要发送给服务器的数据,此处可以是一个json对象 <br> Ajax使用的是哪个框架，概述引该框架的步骤 <br> jQuery Ajax在web应用开发中很常用，它主要包括有ajax,get,post,load,getScript等等这几种步骤 <br> 引用jquery基础库</p> 
<p>然后使用ajax,get,post,load,getScript等方法 <br> 比如：load(url,[data],[callback]) <br> 使用是载入远程HTML文件代码并插入至DOM中，默认使用GET方式，传递参数时自动转换为POST方式。 <br> url:要载入的远程url地址 <br> data:发送至服务器的key/value 数据 <br> callback:载入成功时的回调函数 <br> jQuery如何检查一个标签是否存在？ <br> 用$(“#someID”).length来进行判断，如果长度不为0，则页面上存在该元素。 <br> 如果需要判断某个标签是否存在，可以把选择器换成标签名。 <br> Hibernate部分 <br> HQL语句无法满足需求时怎么办？ <br> 大部分情况下HQL可以实现我们所需要的查询，但是某些特殊情况下，例如，需要调用该数据库特有的函数，或语法，则可以使用原生SQL执行查询。 <br> Hibernate如何实现查询，写出步骤 <br> 步骤如下： <br> 1.配置好数据源 <br> 2.创建实体类，及其与对应表的映射文件 <br> 3.通过Session工厂，获得session <br> 4.使用session执行查询 <br> 如果是根据主键查询，可以使用get(), load()方法； <br> 如果是使用hql查询，可以使用createQuery创建查询对象，通过查询对象查询 <br> 现有两张表:部门表、员工表,请首先说明两表之间的关系,以及如何使用Hibernate进行相应的关系映射定义? </p> 
<p>一方部门配置 <br> <br> <br> <br> </p> 
<p>多方员工配置 <br> </p> 
<pre class="prettyprint"><code class=" hljs xml"><span class="hljs-tag">&lt;<span class="hljs-title">bean</span> <span class="hljs-attribute">id</span>=<span class="hljs-value">"dataSource"</span> 
        <span class="hljs-attribute">class</span>=<span class="hljs-value">"org.springframework.jdbc.datasource.DriverManagerDataSource"</span>&gt;</span> 
        <span class="hljs-tag">&lt;<span class="hljs-title">property</span> <span class="hljs-attribute">name</span>=<span class="hljs-value">"driverClassName"</span> <span class="hljs-attribute">value</span>=<span class="hljs-value">"oracle.jdbc.driver.OracleDriver"</span> /&gt;</span> 
        <span class="hljs-tag">&lt;<span class="hljs-title">property</span> <span class="hljs-attribute">name</span>=<span class="hljs-value">"url"</span> <span class="hljs-attribute">value</span>=<span class="hljs-value">"jdbc:oracle:thin:@localhost:1521:ORCL"</span> /&gt;</span> 
        <span class="hljs-tag">&lt;<span class="hljs-title">property</span> <span class="hljs-attribute">name</span>=<span class="hljs-value">"username"</span> <span class="hljs-attribute">value</span>=<span class="hljs-value">"user"</span> /&gt;</span> 
        <span class="hljs-tag">&lt;<span class="hljs-title">property</span> <span class="hljs-attribute">name</span>=<span class="hljs-value">"password"</span> <span class="hljs-attribute">value</span>=<span class="hljs-value">"pwd"</span> /&gt;</span> 
    <span class="hljs-tag">&lt;/<span class="hljs-title">bean</span>&gt;</span> 
 <span class="hljs-comment">&lt;!-- 配置事务管理器 --&gt;</span> 
 <span class="hljs-tag">&lt;<span class="hljs-title">bean</span> <span class="hljs-attribute">id</span>=<span class="hljs-value">"transactionManager"</span>  <span class="hljs-attribute">class</span>=<span class="hljs-value">"org.springframework.orm.hibernate3.HibernateTransactionManager"</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-title">property</span> <span class="hljs-attribute">name</span>=<span class="hljs-value">"sessionFactory"</span>&gt;</span>
           <span class="hljs-tag">&lt;<span class="hljs-title">ref</span> <span class="hljs-attribute">local</span>=<span class="hljs-value">"sessionFactory"</span>/&gt;</span>
      <span class="hljs-tag">&lt;/<span class="hljs-title">property</span>&gt;</span>
 <span class="hljs-tag">&lt;/<span class="hljs-title">bean</span>&gt;</span>

<span class="hljs-comment">&lt;!-- 
配置事务特性 ，配置add、delete和update开始的方法，事务传播特性为required
--&gt;</span>       
    <span class="hljs-tag">&lt;<span class="hljs-title">tx:advice</span> <span class="hljs-attribute">id</span>=<span class="hljs-value">"txAdvice"</span> <span class="hljs-attribute">transaction-manager</span>=<span class="hljs-value">"transactionManager"</span>&gt;</span>
     <span class="hljs-tag">&lt;<span class="hljs-title">tx:attributes</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-title">tx:method</span> <span class="hljs-attribute">name</span>=<span class="hljs-value">"insert*"</span> <span class="hljs-attribute">propagation</span>=<span class="hljs-value">"REQUIRED"</span>/&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-title">tx:method</span> <span class="hljs-attribute">name</span>=<span class="hljs-value">"delete*"</span> <span class="hljs-attribute">propagation</span>=<span class="hljs-value">"REQUIRED"</span>/&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-title">tx:method</span> <span class="hljs-attribute">name</span>=<span class="hljs-value">"update*"</span> <span class="hljs-attribute">propagation</span>=<span class="hljs-value">"REQUIRED"</span>/&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-title">tx:method</span> <span class="hljs-attribute">name</span>=<span class="hljs-value">"login*"</span> <span class="hljs-attribute">propagation</span>=<span class="hljs-value">"REQUIRED"</span>/&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-title">tx:method</span> <span class="hljs-attribute">name</span>=<span class="hljs-value">"regist*"</span> <span class="hljs-attribute">propagation</span>=<span class="hljs-value">"REQUIRED"</span>/&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-title">tx:method</span> <span class="hljs-attribute">name</span>=<span class="hljs-value">"*"</span> <span class="hljs-attribute">read-only</span>=<span class="hljs-value">"true"</span>/&gt;</span>
     <span class="hljs-tag">&lt;/<span class="hljs-title">tx:attributes</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-title">tx:advice</span>&gt;</span>

<span class="hljs-comment">&lt;!-- 
    配置那些类的方法进行事务管理，当前cn.com.jobedu.oa.service包中的子包、 类中所有方法需要，还需要参考tx:advice的设置-
-&gt;
&lt;aop:config&gt;
     &lt;aop:pointcut id="allManagerMethod" expression="execution (* com..*.service.*.*(..))"/&gt;
     &lt;aop:advisor advice-ref="txAdvice" pointcut-ref="allManagerMethod"/&gt;
&lt;/aop:config&gt;  </span></code></pre> 
<p>请概述Hibernate和Spring的集成配置? <br> 1、将hibernate的配置加入到Spring的配置。 <br> Hibernate的配置也可以单独放在hibernate.cfg.xml文件中,然后通过如下的配置指向config文件,这样在spring配置中就不要配置dataSource和其他Hibernate相关的信息了。 <br> 2、将sessionfactory注入到DAO中,通过sessionfactory操作Hibernate提供的API: <br> 3、配置事务管理 <br> Spring的事务有哪些、有哪些作用？ <br> Spring的事务实现方式共有两种：编码方式；声明式事务管理方式。 <br> 基于AOP技术实现的声明式事务管理，实质就是：在方法执行前后进行拦截，然后在目标方法开始之前创建并加入事务，执行完目标方法后根据执行情况提交或回滚事务。 <br> 声明式事务管理又有两种方式：基于XML配置文件的方式；另一个是在业务方法上进行@Transactional注解，将事务规则应用到业务逻辑中。 <br> 事务属性：Spring中事务属性是对事务策略如何应用到方法的描述，这个描述包括下列参数： <br> 传播行为：定义了关于客户端和被调用方法的事务边界，Spring中有7种不同的值 <br> （1）propagation_mandatory方法必须在事务中，没有事务则异常 <br> （2）propagation_nested如果有事务则嵌套，没有则和required相同 <br> （3）propagation_never不在事务中，若有事务则异常 <br> （4）propagation_not_supported方法不在事务中，若有事务，方法运行期间事务挂起 <br> （5）propagation_required必须在事务中，如果没有创建新的事务 <br> （6）propagation_requires_new必运行在自己的事务中，若有事务则方法运行期间挂起 <br> （7）propagation_supports不需要事务，但如果有事务，也可运行在事务中 <br> 2） 隔离级别：多个事务同时访问一个数据，就会造成脏读（dirty read），不可重复度（nonrepeatedable read），幻读（phantom read），Spring有5种隔离级别 <br> （1）isolation_default使用数据的隔离级别 <br> （2）isolation_read_uncommited运行脏读，幻读和不可重复读 <br> （3）isolation_read_commited运行并发事务提交后读取，避免脏读 <br> （4）isolation_repeatable_read对相同数据多次读取结果一致，防止脏读，不可重复读 <br> （5）isolation_serializable完全服从ACID隔离级别，完全锁定在事务中涉及的所有表 <br> Spring的datasource的配置方式有哪些 <br> 三种方式： <br> （1）非连接池式数据源：如通过DriverManagerDataSource实现 <br> （2）连接池式数据源，如：通过BasicDataSource实现 <br> （3）JNDI式数据源，如：通过JndiObjectFactoryBean实现 <br> Spring的注解有哪些？ <br> @Aspect <br> @Autowire <br> @Service <br> @Controller <br> @RequestMapping <br> @Repository <br> @Component <br> Spring的datasource的配置方式有哪些? <br> 1、使用org.springframework.jdbc.datasource.DriverManagerDataSource <br> 说明：DriverManagerDataSource建立连接是只要有连接就新建一个connection, 根本没有连接池的作用。 <br> 2、使用org.apache.commons.dbcp.BasicDataSource <br> 说明:这是一种推荐说明的数据源配置方式，它真正使用了连接池技术 <br> 3、使用org.springframework.jndi.JndiObjectFactoryBean <br> 说明:JndiObjectFactoryBean 能够通过JNDI获取DataSource <br> 4、Spring在第三方依赖包中包含了两个数据源的实现类包，其一是Apache的 DBCP，其二是 C3P0。可以在Spring配置文件中利用这两者中任何一个配置数 据源。 <br> 谈一下对Spring框架的运行机制 <br> 内部最核心的就是IOC了， <br> 动态注入，让一个对象的创建不用new了，可以自动的生产，这其实就是利用java里的反射 <br> 反射其实就是在运行时动态的去创建、调用对象，Spring就是在运行时，跟xml Spring的配置 <br> 文件来动态的创建对象，和调用对象里的方法的 。 <br> Spring还有一个核心就是AOP这个就是面向切面编程，可以为某一类对象 进行监督和控制（也就是 <br> 在调用这类对象的具体方法的前后去调用你指定的 模块）从而达到对一个模块扩充的功能。这些都是通过 <br> 配置类达到的。 <br> Spring目的：就是让对象与对象（模块与模块）之间的关系没有通过代码来关联，都是通过配置类说明 <br> 管理的（Spring根据这些配置 内部通过反射去动态的组装对象） <br> 要记住：Spring是一个容器，凡是在容器里的对象才会有Spring所提供的这些服务和功能。 <br> Spring里用的最经典的一个设计模式就是：模板方法模式。（这里我都不介绍了，是一个很常用的设计模式） <br> Spring里的配置是很多的，很难都记住，但是Spring里的精华也无非就是以上的两点，把以上两点跟理解了 也就基本上掌握了Spring. </p> 
<p>Spring AOP与IOC <br> 一、 IoC(Inversion of control): 控制反转 <br> 1、IoC： <br> 概念：控制权由对象本身转向容器；由容器根据配置文件去创建实例并创建各个实例之间的依赖关系 <br> 核心：bean工厂；在Spring中，bean工厂创建的各个实例称作bean <br> 二、AOP(Aspect-Oriented Programming): 面向方面编程 <br> 1、 代理的两种方式： <br> 静态代理： <br> 针对每个具体类分别编写代理类； <br> 针对一个接口编写一个代理类； <br> 动态代理： <br> 针对一个方面编写一个InvocationHandler，然后借用JDK反射包中的Proxy类为各种接口动态生成相应的代理类 <br> Spring的特点,工作流程 <br> 1 、非侵入式：对于写代码从来不考虑复用和移植的程序员来说，这一点根本就没有吸引力，那么请跳过。所谓非侵入式是指Spring框架的API不会在业务逻辑上出现，也就是说我们的业务逻辑应该是纯净的，不能出现与业务逻辑无关的代码。首先针对应用而言，这样我们才能将业务逻辑从当前应用中剥离出来，从而在其他的应用中实现复用；其次针对框架而言，由于业务逻辑中没有Spring的API，所以业务逻辑也可以从Spring框架快速的移植到其他框架。 <br> 2 、容器：Spring提供容器功能，容器可以管理对象的生命周期，对象与对象之间的依赖关系。你可以写一个配置文件（通常是xml文件），在上面定义对象的名字，是否是单例，以及设置与其他对象的依赖关系。那么在容器启动之后，这些对象就被实例化好了，你直接去用就好了，而且依赖关系也建立好了。 <br> 3 、IOC：控制反转，谓之“依赖关系的转移”，如果以前都是依赖于实现，那么现在反转为依赖于抽象吧，其实它的核心思想就是要面向接口编程，至于何谓接口何谓抽象，以及它们的好处，多看看设计模式吧，这里就不费口舌了。 <br> 4、 依赖注入：建立对象与对象之间依赖关系的实现，包括接口注入、构造注入、set注入，在Spring中只支持后两种。 <br> 5 、AOP：面向方面编程，我们可以把日志、安全、事务管理等服务（或功能）理解成一个“方面”，那么以前这些服务一直是直接写在业务逻辑的代码当中的，这有两点不好；首先业务逻辑不纯净，其次这些服务被很多业务逻辑反复使用，完全可以剥离出来做到复用。那么AOP就是这些问题的解决方案，我们可以把这些服务剥离出来形成一个“方面”，以期做到复用；然后将“方面”动态的插入到业务逻辑中让业务逻辑能够享受到此“方面”的服务。 <br> 其他还有一些特点不是Spring的核心，这里只做简单陈述，如：对JDBC的封装与简化，提供事务管理功能，对O/R mapping工具（hibernate、iBATIS）的整合；提供MVC解决方案，也可以与其他web框架（Struts、JSF）进行整合；还有对JNDI、mail等服务进行封装。 <br> Spring工作流程如下： <br> 1.springmvc请所有的请求都提交给DispatcherServlet,它会委托应用系统的其他模块负责负责对请求进行真正的处理工作。 <br> 2.DispatcherServlet查询一个或多个HandlerMapping,找到处理请求的Controller. <br> 3.DispatcherServlet请请求提交到目标Controller <br> 4.Controller进行业务逻辑处理后，会返回一个ModelAndView <br> 5.Dispathcher查询一个或多个ViewResolver视图解析器,找到ModelAndView对象指定的视图对象 <br> 6.视图对象负责渲染返回给客户端。 <br> MyBatis部分 <br> MyBatis中resultmap和resulttype的区别; <br> resultMap提供了灵活的结果映射机制，通过引用外部的配置实现多值映射，适用于查询结果为集合时的操作。resultType是基于单个实体类型的结果映射机制，一般用于查询结果为单实体的情况。而resultMap和resultType不同时使用。 <br> MyBatis中按照序列增长的数据怎么得到其id; <br> 通过映射文件中的元素或者@SelectKey注解实现，如假设序列名为seq则</p> 
<pre class="prettyprint"><code class=" hljs r">&lt;insert <span class="hljs-keyword">...</span>&gt;
 &lt;selectKey order=<span class="hljs-string">"BEFORE"</span> keyProperty=<span class="hljs-string">"实体类中ID属性名"</span> resultType=<span class="hljs-string">"int"</span>&gt;
    select seq.nextval from dual
 &lt;/selectKey&gt;


 INSERT语句<span class="hljs-keyword">...</span>
&lt;/insert&gt;</code></pre> 
<p>在MyBatis中使用#号取值和使用$符号取值有什么区别 </p> 
<pre class="prettyprint"><code class=" hljs smalltalk">方式能够很大程度防止sql注入，<span class="hljs-char">$方</span>式无法防止<span class="hljs-class">Sql</span>注入。<span class="hljs-char">$方</span>式一般用于传入数据库对象，例如传入表名等。一般能用#的就别用<span class="hljs-char">$，</span>排序时使用order by动态参数时需要注意，用<span class="hljs-char">$而</span>不是#。</code></pre> 
<p>另类题 <br> 无限循环小数都可以转换成分数吗?可以用程序编写,不可以说明理由. <br> 可以转，先了解转换原理： <br> 解：设x＝＝0.454545……，那么100x＝45.4545……， <br> 而45.4545……＝45＋0.4545……， <br> ∴100x＝45+x化简得99x＝45， <br> 解得， <br> ∴＝． <br> 用代码实现：</p> 
<pre class="prettyprint"><code class=" hljs java">    <span class="hljs-javadoc">/**
     * 无限循环小数转分数
     * 
     *<span class="hljs-javadoctag"> @param</span> recDecStr  小数 
     *<span class="hljs-javadoctag"> @return</span>  分数
     */</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> String <span class="hljs-title">recDec2Fra</span>(String recDecStr){

        <span class="hljs-keyword">int</span> dotPos = recDecStr.indexOf(<span class="hljs-string">"."</span>);
        <span class="hljs-keyword">int</span> leftBrcPos = recDecStr.indexOf(<span class="hljs-string">"["</span>);
        <span class="hljs-keyword">int</span> rightBrcPos = recDecStr.indexOf(<span class="hljs-string">"]"</span>);
        <span class="hljs-keyword">if</span>(dotPos == -<span class="hljs-number">1</span> || leftBrcPos == -<span class="hljs-number">1</span> || rightBrcPos == -<span class="hljs-number">1</span>){
            System.out.println(<span class="hljs-string">"ErrorMsg:@recDec2Fra method  the parameters are wrong!"</span>);
        }
        <span class="hljs-keyword">int</span> preNum = leftBrcPos - dotPos - <span class="hljs-number">1</span> ;
        <span class="hljs-keyword">int</span> recNum = rightBrcPos - leftBrcPos - <span class="hljs-number">1</span>;
        <span class="hljs-keyword">long</span> intData = Integer.parseInt(recDecStr.substring(<span class="hljs-number">0</span>, recDecStr.indexOf(<span class="hljs-string">"."</span>)));
        <span class="hljs-keyword">long</span> preData = <span class="hljs-number">0</span>;
        <span class="hljs-keyword">if</span>(preNum != <span class="hljs-number">0</span>)
            preData = Integer.parseInt(recDecStr.substring(dotPos+<span class="hljs-number">1</span>,leftBrcPos));
        <span class="hljs-keyword">long</span> recData = Integer.parseInt(recDecStr.substring(leftBrcPos+<span class="hljs-number">1</span>,rightBrcPos));
        <span class="hljs-keyword">long</span> numLong = recData * (preNum ==<span class="hljs-number">0</span>?<span class="hljs-number">1</span>:preData);
        <span class="hljs-keyword">long</span> denoLong = getTenBasePow(preNum) * getAsideData(recNum,<span class="hljs-number">9</span>);
        <span class="hljs-keyword">long</span> lcm = getLcm(numLong,denoLong);
        <span class="hljs-keyword">if</span>(lcm != <span class="hljs-number">0</span> &amp;&amp; lcm != <span class="hljs-number">1</span>){
            numLong = numLong / lcm;
            denoLong = denoLong / lcm;
            numLong = numLong +  intData * denoLong ; 
        }
        <span class="hljs-keyword">return</span> numLong + <span class="hljs-string">"/"</span> + denoLong;
    }

    <span class="hljs-comment">//测试调用</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span>(String args[]){             System.out.println(recDec2Fra(<span class="hljs-string">"2.[285714]"</span>)); <span class="hljs-comment">//[]内为循环节</span>
}</code></pre>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/451f12b8ff92eb8d1b458ae33b2c5c77/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">C&#43;&#43;编程socket编程用recv函数接收，返回值为0解决方案</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/73f95401f20696d82599e47fd912d44b/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">django 中间件设置设置时，出现的问题总结</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>