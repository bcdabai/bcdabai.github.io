<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>detours3.0文档翻译 - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="detours3.0文档翻译" />
<meta property="og:description" content="拦截二进制函数 Detours库可以在运行过程中动态拦截函数调用。detours将目标函数前几个指令替换为一个无条件跳转，跳转到用户定义的detour函数。被拦截的函数保存在trampoline函数中。trampoline保存了目标函数移除的指令和一个无条件跳转，可以跳转到目标函数的执行体部分（未被移除的部分）。
当执行到目标函数的时候，直接跳转到用户提供的detours拦截函数。拦截函数开始执行自己的代码。detour函数可以直接返回或调用trampoline函数，将流程返回到拦截前。当目标函数执行完以后，再将控制交给detour函数。detour函数执行适当的代码返回，下图分别表示没有拦截和拦截以后的执行流程：
detours库通过在目标进程二进制映像中写入指令进行拦截。对于目标函数，detours实际上写入两个函数，目标函数和trampoline函数，以及一个函数指针pointer（怀疑文档中有错误）。trampoline函数由detours动态分配。拦截之前，trampoline只包含一条跳转到目标函数的语句。拦截以后，trampoline包含目标函数的初始几条语句和跳转到目标函数剩余内容的跳转指令。
目标指针最初被初始化为指向目标函数。用detour依附（attach）到目标函数以后，目标指针就被修改为指向trampoline函数。当detour从目标函数分离（detach）以后，目标指针像开始一样指向目标函数。
上图展示了detours拦截过程。为了拦截目标函数，首先为动态trampoline函数分配内存（如果没有静态的trampoline），然后修改目标函数和trampoline为可写。拦截的第一步，detours从目标函数中复制至少5字节指令到trampoline（足够一条无条件跳转指令）。如果目标函数小于5字节，detours退出并返回一个错误码
复制指令的过程中，detours采用了一种简单的表格驱动反汇编器。detours在trampoline最后添加一条跳转命令，跳转到目标函数第一条没有被复制的指令处。detours在目标函数的第一条指令处写入一条无条件跳转指令，跳转到detour函数中。最后，detours将目标函数和trampoline函数恢复为原始状态，然后通过调用借口FlushInstructionCache刷新cpu指令缓存。
使用Detours 为了detour目标函数，需要一个指向目标函数的指针和一个detour函数。为了能够正确拦截目标函数，detour函数和目标指针的调用规则需要一致，包括参数和调用规则。调用规则一致确保寄存器能正确保存，detour和目标函数的栈能够合理分配。
下面的代码描述了detours库的使用方法，用户必须包含头文件detours.h，连接过程包含库detours.lib
#include &lt;windows.h&gt; #include &lt;detours.h&gt; static LONG dwSlept = 0; // Target pointer for the uninstrumented Sleep API. // static VOID (WINAPI * TrueSleep)(DWORD dwMilliseconds) = Sleep; // Detour function that replaces the Sleep API. // VOID WINAPI TimedSleep(DWORD dwMilliseconds) { // Save the before and after times around calling the Sleep API. DWORD dwBeg = GetTickCount(); TrueSleep(dwMilliseconds); DWORD dwEnd = GetTickCount(); InterlockedExchangeAdd(&amp;dwSlept, dwEnd - dwBeg); } // DllMain function attaches and detaches the TimedSleep detour to the // Sleep target function." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/98b57a1dfd63b36abc3239ec90f2a819/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2012-12-14T10:09:20+08:00" />
<meta property="article:modified_time" content="2012-12-14T10:09:20+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">detours3.0文档翻译</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <h2>拦截二进制函数</h2> 
<p>        Detours库可以在运行过程中动态拦截函数调用。detours将目标函数前几个指令替换为一个无条件跳转，跳转到用户定义的detour函数。被拦截的函数保存在trampoline函数中。trampoline保存了目标函数移除的指令和一个无条件跳转，可以跳转到目标函数的执行体部分（未被移除的部分）。</p> 
<p>        当执行到目标函数的时候，直接跳转到用户提供的detours拦截函数。拦截函数开始执行自己的代码。detour函数可以直接返回或调用trampoline函数，将流程返回到拦截前。当目标函数执行完以后，再将控制交给detour函数。detour函数执行适当的代码返回，下图分别表示没有拦截和拦截以后的执行流程：</p> 
<p><img src="https://images2.imgbox.com/26/95/WLlL8Ins_o.jpg" alt=""><img src="" alt=""><br> </p> 
<p>      detours库通过在目标进程二进制映像中写入指令进行拦截。对于目标函数，detours实际上写入两个函数，目标函数和trampoline函数，以及一个函数指针pointer（怀疑文档中有错误）。trampoline函数由detours动态分配。拦截之前，trampoline只包含一条跳转到目标函数的语句。拦截以后，trampoline包含目标函数的初始几条语句和跳转到目标函数剩余内容的跳转指令。</p> 
<p>        目标指针最初被初始化为指向目标函数。用detour依附（attach）到目标函数以后，目标指针就被修改为指向trampoline函数。当detour从目标函数分离（detach）以后，目标指针像开始一样指向目标函数。</p> 
<p><img src="https://images2.imgbox.com/bf/ab/QE0gaTVg_o.jpg" alt=""><img src="" alt=""><br> </p> 
<p>        上图展示了detours拦截过程。为了拦截目标函数，首先为动态trampoline函数分配内存（如果没有静态的trampoline），然后修改目标函数和trampoline为可写。拦截的第一步，detours从目标函数中复制至少5字节指令到trampoline（足够一条无条件跳转指令）。如果目标函数小于5字节，detours退出并返回一个错误码</p> 
<p>        复制指令的过程中，detours采用了一种简单的表格驱动反汇编器。detours在trampoline最后添加一条跳转命令，跳转到目标函数第一条没有被复制的指令处。detours在目标函数的第一条指令处写入一条无条件跳转指令，跳转到detour函数中。最后，detours将目标函数和trampoline函数恢复为原始状态，然后通过调用借口FlushInstructionCache刷新cpu指令缓存。</p> 
<h2>使用Detours</h2> 
<p>为了detour目标函数，需要一个指向目标函数的指针和一个detour函数。为了能够正确拦截目标函数，detour函数和目标指针的调用规则需要一致，包括参数和调用规则。调用规则一致确保寄存器能正确保存，detour和目标函数的栈能够合理分配。</p> 
<p>下面的代码描述了detours库的使用方法，用户必须包含头文件detours.h，连接过程包含库detours.lib</p> 
<p></p> 
<pre><code class="language-cpp">#include &lt;windows.h&gt;
#include &lt;detours.h&gt;

static LONG dwSlept = 0;

// Target pointer for the uninstrumented Sleep API.
//
static VOID (WINAPI * TrueSleep)(DWORD dwMilliseconds) = Sleep;

// Detour function that replaces the Sleep API.
//
VOID WINAPI TimedSleep(DWORD dwMilliseconds)
{
    // Save the before and after times around calling the Sleep API.
    DWORD dwBeg = GetTickCount();
    TrueSleep(dwMilliseconds);
    DWORD dwEnd = GetTickCount();

    InterlockedExchangeAdd(&amp;dwSlept, dwEnd - dwBeg);
}

// DllMain function attaches and detaches the TimedSleep detour to the
// Sleep target function.  The Sleep target function is referred to
// through the TrueSleep target pointer.
//
BOOL WINAPI DllMain(HINSTANCE hinst, DWORD dwReason, LPVOID reserved)
{
    if (DetourIsHelperProcess()) {
        return TRUE;
    }

    if (dwReason == DLL_PROCESS_ATTACH) {
        DetourRestoreAfterWith();

        DetourTransactionBegin();
        DetourUpdateThread(GetCurrentThread());
        DetourAttach(&amp;(PVOID&amp;)TrueSleep, TimedSleep);
        DetourTransactionCommit();
    }
    else if (dwReason == DLL_PROCESS_DETACH) {
        DetourTransactionBegin();
        DetourUpdateThread(GetCurrentThread());
        DetourDetach(&amp;(PVOID&amp;)TrueSleep, TimedSleep);
        DetourTransactionCommit();
    }
    return TRUE;
}
</code></pre> 
<br>         拦截目标函数通过与detour交互，调用DetourAttach实现。与detour的交互通过调用DetourTransactionBegin和DetourTransactionCommit实现。DetourAttach包含2个参数：目标函数指针的地址和detour函数地址。目标函数不能直接作为参数传入，因为需要传入一个目标指针。 
<p></p> 
<p>        交互过程中DetourUpdateThread更新所有线程，确保所有拦截点都能正确更新。</p> 
<p>        DetourAttach为调用目标函数分配并准备好一个trampoline。detour运行以后，目标函数和trampoline会被重写，目标指针被更新，指向trampoline函数。</p> 
<p>        一旦目标函数被detour，目标函数的调用会被转到detour函数。目标函数通过trampoline被执行的时候，detour函数将参数复制过来，因为现在目标函数变成了detour函数的一个子程序。</p> 
<p>        要想移除拦截，可以调用detoursDetach。与DetourAttach类似，DetourDetach包含两个参数：目标函数指针地址和detour函数指针。函数执行以后，目标函数被重写为其原来的状态。trampoline函数被删除，目标函数指针恢复为原来的目标函数。</p> 
<p>        如果需要拦截的程序没有源代码，detour函数需要打包为一个dll。将dll加载到一个新的进程中，进程启动的时候调用DetourCreateProcessWithDllEx加载dll。如果通过调用DetourCreateProcessWithDllEx插入dll，DllMain函数必须调用DetourRestoreAfterWith函数。如果希望dll能够在32位和64为机器上使用，DllMain必须调用DetourIsHelperProcess函数。Dll必须导出DetourFinishHelperProcess函数.</p> 
<p>注意：微软不保证或支持任何被修改的微软或第三方的代码，不管是采用detour修改还是其它方式修改。</p> 
<p>detours自带例子withdll采用DetourCreateProcesswithDllEx函数启动一个新进程载入一个命名dll</p> 
<h2>Payloads和DLL导入编辑</h2> 
<p>        除了连接和分离detours函数，detours包还提供了注入其他数据段的API，如二进制文件，或修改dll导入表，叫做payloads。Detours中的二进制修改API是完全可逆的，Detours在二进制中保存了恢复信息，使得所有的修改都可以还原。</p> 
<p><img src="https://images2.imgbox.com/e6/60/1w0oqa56_o.jpg" alt=""><img src="" alt=""><br> </p> 
<p>windowsPE格式的二进制文件结构如上图所示。PE格式的windows二进制文件时COFF格式(通用文件格式)的一个扩展。windows二进制文件包含一个DOS兼容的头，PE头，包含代码的text段，包含初始化数据的data段，包含导入的dll和函数的导入表，包含代码导出函数的导出表，调试信息。二进制文件必须包含两个头，其它的段都是可选的。</p> 
<p><img src="https://images2.imgbox.com/73/04/xNJpl0Pn_o.jpg" alt=""><img src="" alt=""><br> </p> 
<p>        为了修改windows二进制文件，Detours创建了一个.detours段，在导出表和调试符号中间，如上图所示。windows二进制文件必须把调试符号放在最后。新的段包含一个detours头，和原始PE头的一份拷贝，如果修改导入表，detours创建一个新的导入表，将其放在复制的PE头后面，然后修改原始的PE头，将其指向新的导入表。最后，Detours在.detours段的最后写入用户的payloads，然后加上调试信息完成文件。修改后的windows二进制文件可以很容易恢复：从.detours段中恢复PE头，移除.detours段。上图表示的是Detours修改过的windows二进制文件格式。</p> 
<p>        创建一个导入表有2个目的，首先是保持原始的导入表不变，以便以后恢复文件，其次，新建的导入表包含重命名的导入DLL和函数，或者是整个dll和函数。例如，detours保的例子中setdll.exe这个程序，讲一个用户dll插入到目标二进制程序中。由于新的导入表在应用程序中第一个位置，所以用户的dll在程序中会首先被执行。</p> 
<p>        Detours提供了很多有用接口，包括编辑导入表（DetourBinaryEditImports），添加payloads（DetourBinarySetPayload），枚举payloads（DetourBinaryEnumeratePayloads），移除payloads（DetourBinaryPurgePayloads）。DetourEnumerateModules可以枚举一个地址空间中的二进制文件，DetourFindPayload可以定位二进制文件中映射的payloads。每一个payload通过一个128位的guid表示。payloads可以将程序配置数据注入到二进制程序中。</p> 
<p><span style="white-space:pre"></span>DetourCopyPayloadToProcess可以直接将Payloads复制到目标进程</p> 
<h2>Detour 32位和64位进程</h2> 
<p><strong>注意：只有专业版的Detours支持64位程序。非商业版，express版本只支持32位x86系统</strong></p> 
<p><span style="white-space:pre"></span>detours最常见的使用情况是在不修改原始二进制程序的情况下的改变函数执行情况。这时，用户提供的detour函数打包到一个dll中，在程序运行开始的时候调用DetourCreateProcesswithDll加载该dll。父进程调用DetourCreateProcesswithDll，通过插入一个导入表来改变程序内存中的拷贝。新的插入表使得系统在程序开始的时候，程序逻辑代码还没有执行的时候加载dll。这样deoturDLL就可以hook目标进程中的目标函数。</p> 
<p><span style="white-space:pre"></span>在64位的处理器上，windows支持32位或64位的应用程序。为了支持32位或64位程序，需要创建32位和64位的detourDLL。调用DetourCreateProcessWithDll的地方需要改为DetourCreateProcessWithDllEx。DetourCreateProcessWithDllEx会根据系统选择合适的Dll来注入目标程序。</p> 
<p><span style="white-space:pre"></span><strong>需要这样做：</strong></p> 
<p><span style="white-space:pre"></span>为了在一个系统上支持32位和64位程序，需要创建2个DLL。一个包含32位代码，另一个包含64位代码。两个DLL放在同一个目录中并且起相同的名字，并加上相应的后缀“32”和“64”，比如foo32.dll和foo64.dll。</p> 
<p><span style="white-space:pre"></span>调用DetourCreateProcessWithDllEx来启动一个包含相应DLL的进程。另外，你的DLL需要：</p> 
<p>1.导出DetourFinishHelperProcess</p> 
<p>2.在DllMain中调用DetourIsHelperProcess，如果DetourIsHelperProcess返回TRUE，则马上返回TRUE。</p> 
<p>3.通过调用DetourCreateProcessWithDllEx而不是DetourCreateProcessWithDll来创建新的进程。</p> 
<p><span style="white-space:pre"></span><strong>工作原理</strong></p> 
<p><span style="white-space:pre"></span>如果目标进程跟dll的父进程同为32位或同为64位，DetourCreateProcessWithDllEx运行过程类似DetourCreateProcessWithDll。</p> 
<p><span style="white-space:pre"></span>如果父进程与目标进程不同，一个是32位，一个是64位，DetourCreateProcessWithDllEx会创建一个辅助进程，将DLL加载到rundll32.exe进程，然后调用DetourFinishHelperProcess。这个API通过使用正确的32位或64位代码来修补导入表。</p> 
<p><span style="white-space:pre"></span><strong>应用示例</strong></p> 
<p><span style="white-space:pre"></span>下面测试辅助进程，首先在32位环境中编译Detours例子，然后在64位环境中编译64位例子。然后进入例子中\tryman目录，在64位环境中输入"nmake size64"，这样可以递归运行进程，包括32位和64位进程。</p> 
<p><span style="white-space:pre"></span><strong>附注</strong></p> 
<p><span style="white-space:pre"></span>关于rundll32.exe，请参考<a target="_blank" href="http://support.microsoft.com/kb/164787" rel="nofollow noopener noreferrer">http://support.microsoft.com/kb/164787</a></p> 
<p></p> 
<p>Related APIs:</p> 
<p></p> 
<p><a target="_blank" href="" rel="nofollow noopener noreferrer">DetourCreateProcessWithDllEx</a>, <a target="_blank" href="" rel="nofollow noopener noreferrer"> DetourFinishHelperProcess</a>,<a target="_blank" href="" rel="nofollow noopener noreferrer">DetourIsHelperProcess</a>,<a target="_blank" href="" rel="nofollow noopener noreferrer">DetourRestoreAfterWith</a>.</p> 
<p>Related Samples</p> 
<p><a target="_blank" href="" rel="nofollow noopener noreferrer">Simple</a>, <a target="_blank" href="" rel="nofollow noopener noreferrer">Simple</a>, <a target="_blank" href="" rel="nofollow noopener noreferrer"> Slept</a>, <a target="_blank" href="" rel="nofollow noopener noreferrer">Traceapi</a>, <a target="_blank" href="" rel="nofollow noopener noreferrer">Tracebld</a>, <a target="_blank" href="" rel="nofollow noopener noreferrer">Tracelnk</a>, <a target="_blank" href="" rel="nofollow noopener noreferrer">Tracemem</a>,<a target="_blank" href="" rel="nofollow noopener noreferrer">Tracereg</a>,<a target="_blank" href="" rel="nofollow noopener noreferrer">Traceser</a>,<a target="_blank" href="" rel="nofollow noopener noreferrer">Tracetcp</a>,<a target="_blank" href="" rel="nofollow noopener noreferrer">Tryman</a>.  </p> 
<br> 
<p><br> </p> 
<p><br> </p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/84733f4b0f4df521e9bb9c90b5740b9f/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">ClassLoader.getResourceAsStream(name);获取配置文件的方法</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/56e6a48d5405a2bec01e0b89bb9b1f75/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">CF 253D(矩阵-4角相等且矩阵权值有上限的矩阵数）</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>