<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Python pygame(GUI编程)模块最完整教程（2） - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Python pygame(GUI编程)模块最完整教程（2）" />
<meta property="og:description" content="上一篇文章：
Python pygame(GUI编程)模块最完整教程（1）_pygame模块详解_Python-ZZY的博客-CSDN博客
总目录：
README.md · Python-ZZY/Python-Pygame最完整教程 - Gitee.com
6 文字绘制 参考资料：pygame.font — pygame-ce v2.4.0 documentation
6.1 载入字体 pygame中绘制文字的第一步是载入字体。载入字体的方式通常有两种，第一种是使用指定路径的字体文件，第二种是从系统字体库中载入字体。推荐第一种方式，因为在游戏打包后，你无法确定你电脑上安装的字体文件在其他用户的电脑上也安装过。
pygame.font和pygame.freetype模块提供了文字绘制的操作。font模块功能比较简单，freetype模块是font模块功能的扩展。
Font类通过字体文件创建一个字体对象，支持包括*.ttf等一系列的TrueType字体。载入字体时，需要提供一个字体文件路径和字体大小。示例：
font = pg.font.Font(&#34;name_of_font.ttf&#34;, 12) 如果是调用系统字体文件，则使用SysFont。示例：
font = pg.font.SysFont(&#34;宋体&#34;, 12) 6.2 渲染字体 加载字体后，下一步是渲染字体。渲染字体调用字体对象的render()方法，将一段文字转换成使用该字体的pygame.Surface对象。
render(text, antialias, color, bgcolor=None, wraplength=0) -&gt; Surface text是要渲染的一段文字内容。
注意：pygame-ce 2.1.4版本之前不支持渲染换行符&#34;\n&#34;。 antialias是一个布尔值，代表是否使用抗锯齿，抗锯齿的文字更加平滑，但是速度会稍慢一点点，一般选择True。color是文字的颜色。background是文字背景颜色，设为None则为透明背景。
注意：如果文字绘制的位置始终是纯色背景，那么最好是指定background背景颜色。因为使用纯色填充比使用透明填充性能会更好。 渲染后的字体可以当做表面来处理。下面的示例显示了如何绘制文字。
import pygame as pg pg.init() screen = pg.display.set_mode((300, 200)) font = pg.font.Font(&#34;simhei.ttf&#34;, 20) #大小为20的simhei字体文件（在同一目录下） surf = font.render(&#34;你好!这是一段文字&#34;, True, (255, 255, 255)) while True: screen." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/796093242a281f4698864dbbe2301a60/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-12-03T20:01:47+08:00" />
<meta property="article:modified_time" content="2023-12-03T20:01:47+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Python pygame(GUI编程)模块最完整教程（2）</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <div> 
 <p>上一篇文章：</p> 
 <p><a class="kdocs-link" href="https://blog.csdn.net/qq_48979387/article/details/126799308" title="Python pygame(GUI编程)模块最完整教程（1）_pygame模块详解_Python-ZZY的博客-CSDN博客">Python pygame(GUI编程)模块最完整教程（1）_pygame模块详解_Python-ZZY的博客-CSDN博客</a></p> 
 <p>总目录：</p> 
 <p><a class="kdocs-link" href="https://gitee.com/python_zzy/pygame-articles-csdn/blob/master/README.md" rel="nofollow" title="README.md · Python-ZZY/Python-Pygame最完整教程 - Gitee.com">README.md · Python-ZZY/Python-Pygame最完整教程 - Gitee.com</a></p> 
 <h2>6 文字绘制</h2> 
 <p>参考资料：<a class="kdocs-link" href="https://pyga.me/docs/ref/font.html" rel="nofollow" title="pygame.font — pygame-ce v2.4.0 documentation">pygame.font — pygame-ce v2.4.0 documentation</a></p> 
 <h3><strong><span style="color:#fe2c24;">6.1 载入字体</span></strong></h3> 
 <p>pygame中绘制文字的第一步是载入字体。载入字体的方式通常有两种，第一种是使用指定路径的字体文件，第二种是从系统字体库中载入字体。推荐第一种方式，因为在游戏打包后，你无法确定你电脑上安装的字体文件在其他用户的电脑上也安装过。</p> 
 <p>pygame.font和pygame.freetype模块提供了文字绘制的操作。font模块功能比较简单，freetype模块是font模块功能的扩展。</p> 
 <p>Font类通过字体文件创建一个字体对象，支持包括*.ttf等一系列的TrueType字体。载入字体时，需要提供一个字体文件路径和字体大小。示例：</p> 
 <pre><code class="language-python">
<code class="language-python">font = pg.font.Font("name_of_font.ttf", 12)</code></code></pre> 
 <p>如果是调用系统字体文件，则使用SysFont。示例：</p> 
 <pre><code class="language-python">
<code class="language-python">font = pg.font.SysFont("宋体", 12)</code></code></pre> 
 <h3><strong><span style="color:#fe2c24;">6.2 渲染字体</span></strong></h3> 
 <p>加载字体后，下一步是渲染字体。渲染字体调用字体对象的render()方法，将一段文字转换成使用该字体的pygame.Surface对象。</p> 
 <pre><code class="language-python">
<code class="language-python">render(text, antialias, color, bgcolor=None, wraplength=0) -&gt; Surface</code></code></pre> 
 <p>text是要渲染的一段文字内容。</p> 
 <blockquote>
   注意：pygame-ce 2.1.4版本之前不支持渲染换行符"\n"。 
 </blockquote> 
 <p>antialias是一个布尔值，代表是否使用抗锯齿，抗锯齿的文字更加平滑，但是速度会稍慢一点点，一般选择True。color是文字的颜色。background是文字背景颜色，设为None则为透明背景。</p> 
 <blockquote>
   注意：如果文字绘制的位置始终是纯色背景，那么最好是指定background背景颜色。因为使用纯色填充比使用透明填充性能会更好。 
 </blockquote> 
 <p>渲染后的字体可以当做表面来处理。下面的示例显示了如何绘制文字。</p> 
 <pre><code class="language-python">
<code class="language-python">import pygame as pg

pg.init()

screen = pg.display.set_mode((300, 200))
font = pg.font.Font("simhei.ttf", 20) #大小为20的simhei字体文件（在同一目录下）
surf = font.render("你好!这是一段文字", True, (255, 255, 255))

while True:
    screen.fill((0, 0, 0))
    screen.blit(surf, (0, 0))
    
    for event in pg.event.get():
        if event.type == pg.QUIT:
            pg.quit()

    pg.display.flip()</code></code></pre> 
 <div> 
  <div> 
   <div> 
    <img alt="" src="https://images2.imgbox.com/6b/cf/JC6Y5IZj_o.png" width="303"> 
   </div> 
  </div> 
 </div> 
 <blockquote>
   注意：字体渲染不是线程安全的。这意味着你无法用多线程渲染单个字体，同一时刻只能用该字体对象渲染一段文字。如果一定要用线程，可以建立多个Font对象，但每个对象都是一样渲染结果。 
 </blockquote> 
 <h3>6.3 字体特殊样式</h3> 
 <p>Font对象提供了几个属性获取或改变字体的特殊样式，包括加粗、斜体、下划线、删除线。</p> 
 <div> 
  <table border="1" cellpadding="1" cellspacing="1"><tbody><tr><td style="vertical-align:top;width:291px;"> <p><strong>属性</strong></p> </td><td style="vertical-align:top;width:326px;"> <p><strong>解释</strong></p> </td></tr><tr><td style="vertical-align:top;width:291px;"> <p>bold</p> </td><td style="vertical-align:top;width:326px;"> <p>加粗</p> </td></tr><tr><td style="vertical-align:top;width:291px;"> <p>italic</p> </td><td style="vertical-align:top;width:326px;"> <p>斜体</p> </td></tr><tr><td style="vertical-align:top;width:291px;"> <p>underline</p> </td><td style="vertical-align:top;width:326px;"> <p>下划线</p> </td></tr><tr><td style="vertical-align:top;width:291px;"> <p>strikethrough</p> </td><td style="vertical-align:top;width:326px;"> <p>删除线</p> </td></tr></tbody></table> 
 </div> 
 <p>例如想要让字体加粗、斜体，可以这样：</p> 
 <pre><code class="language-python">
<code class="language-python">font.bold = font.italic = True</code></code></pre> 
 <p>下面的示例演示了四种效果。</p> 
 <pre><code class="language-python">
<code class="language-python">import pygame as pg

pg.init()

screen = pg.display.set_mode((300, 200))

surfs = []
font = pg.font.SysFont("simhei", 20)
surfs.append(font.render("default style", True, (255, 255, 255)))

for style in ("bold", "italic", "underline", "strikethrough"):
    font = pg.font.SysFont("simhei", 20)
    setattr(font, style, True)
    surfs.append(font.render(style, True, (255, 255, 255)))

while True:
    screen.fill((0, 0, 0))

    for i, surf in enumerate(surfs):
        screen.blit(surf, (0, i * 40))
    
    for event in pg.event.get():
        if event.type == pg.QUIT:
            pg.quit()

    pg.display.flip()</code></code></pre> 
 <div> 
  <div> 
   <div> 
    <img alt="" src="https://images2.imgbox.com/1d/04/uSKL9fy4_o.png" width="303"> 
   </div> 
  </div> 
 </div> 
 <h3><strong><span style="color:#fe2c24;">6.4 文本自动换行</span></strong></h3> 
 <blockquote>
   注意：pygame-ce 2.3.0版本可用 
 </blockquote> 
 <p>render方法包含关键字参数wraplength，它指定一个像素长度，当字体长度超过wraplength将自动换行（并且确保换行前后字母是一个完整的单词）。</p> 
 <pre><code class="language-python">
<code class="language-python">font = pg.font.SysFont("simhei", 20)
surf = font.render("This is a long long long long string.", True, (255, 255, 255), bgcolor=(255, 0, 0), wraplength=120)</code></code></pre> 
 <div> 
  <div> 
   <div> 
    <img alt="" src="https://images2.imgbox.com/91/df/RzJQgQEX_o.png" width="300"> 
   </div> 
  </div> 
 </div> 
 <p>这样，字体长度达到120像素后会自动换行。</p> 
 <p>font还有一个可设定的属性align，指定字体换行时统一靠向哪个地方。可选常量如下：</p> 
 <ul><li style="margin-left:1.4em;"> <p>pg.FONT_LEFT：靠向左侧（默认）</p> </li></ul> 
 <ul><li style="margin-left:1.4em;"> <p>pg.FONT_CENTER：靠向中间</p> </li></ul> 
 <ul><li style="margin-left:1.4em;"> <p>pg.FONT_RIGHT：靠向右侧</p> </li></ul> 
 <pre><code class="language-python">
<code class="language-python">font = pg.font.SysFont("simhei", 20)
font.align = pg.FONT_CENTER
surf = font.render("This is a long long long long string.", True, (255, 255, 255), (255, 0, 0), 120)</code></code></pre> 
 <div> 
  <div> 
   <div> 
    <img alt="" src="https://images2.imgbox.com/70/19/72r8AbEG_o.png" width="301"> 
   </div> 
  </div> 
 </div> 
 <h3>6.5 文本绘制方向</h3> 
 <blockquote>
   注意：pygame-ce 2.1.4版本可用 
 </blockquote> 
 <p style="text-align:left;">Font.set_direction方法设置文本的呈现方向，包含一个参数direction，可以设为如下常量值：</p> 
 <ul><li style="margin-left:1.4em;text-align:left;"> <p>pg.DIRECTION_LTR：从左到右</p> </li></ul> 
 <ul><li style="margin-left:1.4em;text-align:left;"> <p>pg.DIRECTION_RTL：从右到左</p> </li></ul> 
 <ul><li style="margin-left:1.4em;text-align:left;"> <p>pg.DIRECTION_TTB：从上到下</p> </li></ul> 
 <ul><li style="margin-left:1.4em;text-align:left;"> <p>pg.DIRECTION_BTT：从下到上</p> </li></ul> 
 <blockquote>
   注意：从上到下和从下到上渲染时，文本中换行符\n效果不佳 
 </blockquote> 
 <pre><code class="language-python">
<code class="language-python">import pygame as pg

pg.init()

screen = pg.display.set_mode((300, 500))

surfs = []
font = pg.font.SysFont("simhei", 20)

for style in (pg.DIRECTION_LTR, pg.DIRECTION_RTL, pg.DIRECTION_TTB,
              pg.DIRECTION_BTT):
    font.set_direction(style)
    surfs.append(font.render("HelloWorld!", True, (255, 255, 255), (255, 0, 0)))

while True:
    screen.fill((0, 0, 0))

    for i, surf in enumerate(surfs):
        screen.blit(surf, (i * 40, i * 40))
    
    for event in pg.event.get():
        if event.type == pg.QUIT:
            pg.quit()

    pg.display.flip()</code></code></pre> 
 <div> 
  <div> 
   <div> 
    <img alt="" src="https://images2.imgbox.com/63/47/uhTaOAZj_o.png" width="302"> 
   </div> 
  </div> 
 </div> 
 <h3>6.6 font模块索引-字体操作</h3> 
 <p><strong>get_default_font() -&gt; string</strong></p> 
 <p>获取pygame指定的默认的字体名称，一般是freesansbold.ttf。</p> 
 <p><strong>get_fonts() -&gt; list of strings</strong></p> 
 <p>获取系统上所有可用的字体名称。</p> 
 <p><strong>match_font(name, bold=False, italic=False) -&gt; path</strong></p> 
 <p>返回系统上名为name的字体的完整路径。</p> 
 <p><strong>SysFont(name, size, bold=False, italic=False) -&gt; Font</strong></p> 
 <p>从系统上调用字体，name为字体名，size为字体大小，bold和italic表示是否设为粗体或斜体。</p> 
 <p style="text-align:left;"><strong>Font(filename, size) -&gt; Font</strong></p> 
 <p style="text-align:left;"><strong>Font(pathlib.Path, size) -&gt; Font</strong></p> 
 <p style="text-align:left;"><strong>Font(object, size) -&gt; Font</strong></p> 
 <p>从文件载入字体。</p> 
 <p><strong>Font.render(text, antialias, color, bgcolor=None, wraplength=0) -&gt; Surface</strong></p> 
 <p>通过字体渲染文字，text为文字内容，antialias表示是否抗锯齿，color是文字颜色，background为背景颜色（None为透明），wraplength为换行长度。</p> 
 <p><strong>Font.size(text) -&gt; (width, height)</strong></p> 
 <p>返回渲染一段文字所需的表面大小。</p> 
 <p style="text-align:left;"><strong>Font.set_underline(bool) -&gt; None</strong></p> 
 <p style="text-align:left;"><strong>Font.get_underline() -&gt; bool</strong></p> 
 <p style="text-align:left;">设置和获取文本的下划线状态。</p> 
 <p style="text-align:left;"><strong>Font.set_strikethrough(bool) -&gt; None</strong></p> 
 <p style="text-align:left;"><strong>Font.get_strikethrough() -&gt; bool</strong></p> 
 <p style="text-align:left;">设置和获取文本的删除线状态。</p> 
 <p style="text-align:left;"><strong>Font.set_bold(bool) -&gt; None</strong></p> 
 <p style="text-align:left;"><strong>Font.get_bold() -&gt; bool</strong></p> 
 <p style="text-align:left;">设置和获取文本的粗体状态。</p> 
 <p style="text-align:left;"><strong>Font.set_italic(bool) -&gt; None</strong></p> 
 <p style="text-align:left;"><strong>Font.get_italic() -&gt; bool</strong></p> 
 <p style="text-align:left;">设置和获取文本的斜体状态。</p> 
 <p style="text-align:left;"><strong>Font.set_direction(direction) -&gt; None</strong></p> 
 <p style="text-align:left;">设置文本的呈现方向，direction可选常量值如下：</p> 
 <ul><li style="margin-left:1.4em;text-align:left;"> <p>pg.DIRECTION_LTR：从左到右</p> </li></ul> 
 <ul><li style="margin-left:1.4em;text-align:left;"> <p>pg.DIRECTION_RTL：从右到左</p> </li></ul> 
 <ul><li style="margin-left:1.4em;text-align:left;"> <p>pg.DIRECTION_TTB：从上到下</p> </li></ul> 
 <ul><li style="margin-left:1.4em;text-align:left;"> <p>pg.DIRECTION_BTT：从下到上</p> </li></ul> 
 <blockquote>
   注意：从上到下和从下到上渲染时，文本中换行符\n效果不佳 
 </blockquote> 
 <p><strong>Font.metrics(text) -&gt; list</strong></p> 
 <p>返回一个列表，包含给定文本内容中每个字符的信息。列表包含多个元组，每个元组中是每个字符的最小x偏移量、最大x偏移量、最小y偏移量、最大y偏移量、提前偏移量。无法识别的字符则为None。</p> 
 <p><strong>Font.get_height() -&gt; int</strong></p> 
 <p>返回字体的平均高度。</p> 
 <p><strong>Font.get_ascent() -&gt; int</strong></p> 
 <p>返回字体上升的高度，即从基线到字符顶端的高度。</p> 
 <p><strong>Font.get_descent() -&gt; int</strong></p> 
 <p>返回字体下降的高度，即从基线到字符底部的高度。</p> 
 <h3>6.7 freetype模块索引-字体操作扩展</h3> 
 <p>参考资料：<a class="kdocs-link" href="https://pyga.me/docs/ref/freetype.html" rel="nofollow" title="pygame.freetype — pygame-ce v2.4.0 documentation">pygame.freetype — pygame-ce v2.4.0 documentation</a></p> 
 <p>freetype模块是font模块的扩展，一般用font模块就足够了。</p> 
 <blockquote> 
  <span style="color:#080f17;">注意：freetype模块没有事先在pygame中导入，所以使用时不能直接调用pg.freetype，而要在开头进行导入：</span> 
 </blockquote> 
 <pre><code class="language-python">
<code class="language-python">from pygame import freetype</code></code></pre> 
 <p style="text-align:left;"><strong>get_default_font() -&gt; string</strong></p> 
 <p>获取pygame指定的默认的字体名称。</p> 
 <p><strong>SysFont(name, size, bold=False, italic=False) -&gt; Font</strong></p> 
 <p>从系统上调用字体，name为字体名，size为字体大小，bold和italic表示是否设为粗体或斜体。</p> 
 <p style="text-align:left;"><strong>Font(file, size=0, font_index=0, resolution=0, ucs4=False) -&gt; Font</strong></p> 
 <p style="text-align:left;"><strong>Font(pathlib.Path) -&gt; Font</strong></p> 
 <p>从文件载入字体。size是字体的大小，设为0则使用默认大小。font_index是字体位于某个字体文件中的索引。resolution是像素大小，用于缩放字形。</p> 
 <p><strong>Font.name -&gt; string</strong></p> 
 <p>字体名称。</p> 
 <p><strong>Font.path -&gt; string</strong></p> 
 <p>字体文件路径。</p> 
 <p style="text-align:left;"><strong>Font.size -&gt; float</strong></p> 
 <p style="text-align:left;"><strong>Font.size -&gt; (float, float)</strong></p> 
 <p>字体大小。</p> 
 <p style="text-align:left;"><strong>Font.ascender -&gt; int</strong></p> 
 <p style="text-align:left;">默认大小状态下字体上升高度。</p> 
 <p style="text-align:left;"><strong>Font.descender -&gt; int</strong></p> 
 <p style="text-align:left;">默认大小状态下字体下降高度。</p> 
 <p><strong>Font.style -&gt; int</strong></p> 
 <p>字体默认样式。可以通过freetype模块中定义的几个常量（不是locals中的常量）来设定，多个常量之间用按位或"|"操作符连接起来。</p> 
 <div> 
  <div> 
   <div> 
    <img alt="" src="https://images2.imgbox.com/9c/e7/bJEeUF6G_o.png" width="197"> 
   </div> 
  </div> 
 </div> 
 <p><strong>Font.underline -&gt; bool</strong></p> 
 <p>字体默认是否添加下划线。</p> 
 <p><strong>Font.strong -&gt; bool</strong></p> 
 <p>字体默认是否加粗</p> 
 <p><strong>Font.oblique -&gt; bool</strong></p> 
 <p>字体默认是否倾斜。</p> 
 <p><strong>Font.wide -&gt; bool</strong></p> 
 <p>字体默认是否增宽（不支持旋转后的字体）。</p> 
 <p style="text-align:left;"><strong>Font.strength -&gt; float</strong></p> 
 <p>字体strong或wide样式中，字形被放大的量。默认值约等于1/36。</p> 
 <div> 
  <div> 
   <div> 
    <img alt="" src="https://images2.imgbox.com/49/fb/mBTjRSUm_o.png" width="347"> 
   </div> 
  </div> 
 </div> 
 <p><strong>Font.underline_adjustment -&gt; float</strong></p> 
 <p>字体下划线的位置偏移，值的范围是-2.0到2.0之间。默认是1.0。设为0时下划线位于文本基线处，设为负数为上划线，设为正数为下划线。</p> 
 <div> 
  <div> 
   <div> 
    <img alt="" src="https://images2.imgbox.com/ae/2f/98Z5ycqx_o.png" width="234"> 
   </div> 
  </div> 
 </div> 
 <p><strong>Font.fixed_sizes -&gt; int</strong></p> 
 <p>只读属性。字体是否固定宽度。</p> 
 <p><strong>Font.fixed_sizes -&gt; int</strong></p> 
 <p>只读属性。字体包含位图字符图像的点大小的数量。</p> 
 <p><strong>Font.scalable -&gt; bool</strong></p> 
 <p>只读属性。字体是否可伸缩。</p> 
 <p><strong>Font.antialiased -&gt; bool</strong></p> 
 <p>字体是否抗锯齿，默认为True</p> 
 <p><strong>Font.kerning -&gt; bool</strong></p> 
 <p>字体是否可调整字距，默认为False。</p> 
 <p><strong>Font.vertical -&gt; bool</strong></p> 
 <p>字体是否以垂直方向显示，默认为False。</p> 
 <div> 
  <div> 
   <div> 
    <img alt="" src="https://images2.imgbox.com/af/8d/5xuiBRMP_o.png" width="33"> 
   </div> 
  </div> 
 </div> 
 <p><strong>Font.rotation -&gt; int</strong></p> 
 <p>字体基线默认的逆时针旋转角度。</p> 
 <p><strong>Font.fgcolor -&gt; Color</strong></p> 
 <p>字体前景色，默认为黑色。</p> 
 <p><strong>Font.bgcolor -&gt; Color</strong></p> 
 <p>字体背景色，默认为透明色。</p> 
 <div> 
  <div> 
   <div> 
    <img alt="" src="https://images2.imgbox.com/9e/56/3vhSmuyk_o.png" width="182"> 
   </div> 
  </div> 
 </div> 
 <p><strong>Font.get_rect(text, style=STYLE_DEFAULT, rotation=0, size=0) -&gt; rect</strong></p> 
 <p>返回渲染text文字表面后的矩形对象。矩形对象的大小是表面的大小，位置(x, y)是文本原点的位置（也就是(0, 字体上升高度)）。指定rotation将渲染的文字逆时针旋转，size改变字体的大小。</p> 
 <p><strong>Font.get_metrics(text, size=0) -&gt; [(...), ...]</strong></p> 
 <p>返回一个列表，包含给定文本内容中每个字符的信息。</p> 
 <p><strong>Font.get_sized_ascender(&lt;size&gt;=0) -&gt; int</strong></p> 
 <p>根据字体大小获取字体上升的高度。</p> 
 <p><strong>Font.get_sized_descender(&lt;size&gt;=0) -&gt; int</strong></p> 
 <p>根据字体大小获取字体下降的高度。</p> 
 <p style="text-align:left;"><strong>Font.get_sized_height(&lt;size&gt;=0) -&gt; int</strong></p> 
 <p>根据字体大小获取字体的平均高度。</p> 
 <p><strong>Font.get_sized_glyph_height(&lt;size&gt;=0) -&gt; int</strong></p> 
 <p>根据字体大小获取字体包围框的平均高度。（字体尺寸较小时和get_sized_height返回的结果近似）</p> 
 <p style="text-align:left;"><strong>Font.get_sizes() -&gt; [(int, int, int, float, float), ...]</strong></p> 
 <p style="text-align:left;"><strong>Font.get_sizes() -&gt; []</strong></p> 
 <p>返回嵌入式位图的可用大小。</p> 
 <p><strong>Font.render(text, fgcolor=None, bgcolor=None, style=STYLE_DEFAULT, rotation=0, size=0) -&gt; (Surface, Rect)</strong></p> 
 <p>渲染text文本。fgcolor, bgcolor分别表示前景和背景色，style是文本样式，rotation是逆时针旋转角度，size是文本的字体大小。Surface是渲染的文本表面，Rect是文本的大小，位于文字的原点。</p> 
 <p>text可以设为None，表示重新渲染上一次在get_rect(), render(), render_to(), render_raw(), or render_raw_to()这几个方法调用过的文本。</p> 
 <p><strong>Font.render_to(surf, dest, text, fgcolor=None, bgcolor=None, style=STYLE_DEFAULT, rotation=0, size=0) -&gt; Rect</strong></p> 
 <p>将render的运行结果绘制到surf上，位于dest处。</p> 
 <p><strong>Font.render_raw(text, style=STYLE_DEFAULT, rotation=0, size=0, invert=False) -&gt; (bytes, (int, int))</strong></p> 
 <p>将渲染的文字以8位灰度值形式返回，前景色为255，背景色为0。</p> 
 <p><strong>Font.render_raw_to(array, text, dest=None, style=STYLE_DEFAULT, rotation=0, size=0, invert=False) -&gt; Rect</strong></p> 
 <p>将render_raw的运行结果呈现到一个数组上（二维），位于dest处。</p> 
 <h2>7 按键处理</h2> 
 <p>参考资料：<a class="kdocs-link" href="https://pyga.me/docs/ref/key.html" rel="nofollow" title="pygame.key — pygame-ce v2.4.0 documentation">pygame.key — pygame-ce v2.4.0 documentation</a></p> 
 <p>pygame.key模块提供了一些处理按键的操作。和键盘相关的event相比，key模块支持了更多的功能，有时比事件更好用。</p> 
 <h3><span style="color:#fe2c24;"><strong>7.1 获取持续按下的按键</strong></span></h3> 
 <p>pg.key.get_pressed方法返回一个字典，其中包含每个按键的按下情况。字典的键是按键的标识符常量，是一个整数；字典的值是一个布尔值，表示是否按下了这个按键。只有当按键持续按下，并且没有松开时才会设为True。</p> 
 <p>上一章的末尾“行走的人”示例中，关于玩家移动是使用event来做的。如果用event，就需要同时处理KEYDOWN和KEYUP事件，判断按键按下且没有松开。但如果使用pg.key.get_pressed，就可以减少麻烦，如下示例：</p> 
 <pre><code class="language-python">
<code class="language-python">import pygame as pg

pg.init()

screen = pg.display.set_mode((300, 200))
clock = pg.time.Clock()
image = pg.image.load("logo.png")
image_rect = image.get_rect()
speed = 2

while True:
    screen.fill((0, 0, 0))
    screen.blit(image, image_rect)

    keys = pg.key.get_pressed()
    if keys[pg.K_UP]: #如果按下上方向键
        image_rect.y -= speed
    elif keys[pg.K_DOWN]:
        image_rect.y += speed
    if keys[pg.K_LEFT]:
        image_rect.x -= speed
    elif keys[pg.K_RIGHT]:
        image_rect.x += speed
    
    for event in pg.event.get():
        if event.type == pg.QUIT:
            pg.quit()

    clock.tick(60)
    pg.display.flip()</code></code></pre> 
 <p>这样可以很简洁地实现持续移动。</p> 
 <h3>7.2 获取组合键</h3> 
 <p>组合键是指按下多个按键。如果要对按下的多个按键进行处理，可以用pg.key.get_mods()方法。</p> 
 <pre><code class="language-python">
<code class="language-python">import pygame as pg

pg.init()
screen = pg.display.set_mode((300, 200))

while True:
    mods = pg.key.get_mods()
    if mods == pg.KMOD_NONE:
        print("无组合键按下")
    elif mods &amp; pg.KMOD_CTRL:
        print("按下了Ctrl和标识符为", event.key, "的按键")
        
    for event in pg.event.get():
        if event.type == pg.QUIT:
            pg.quit()</code></code></pre> 
 <p>get_mods方法获得的结果类似于event.mods，但是KEYDOWN或KEYUP只会在刚按下和刚松开按键时触发，而get_mods方法获得的是持续按下不松开的按键内容。没有组合键按下时返回pg.KMOD_NONE相同的标识符。</p> 
 <h3>7.3 控制重复触发KEYDOWN事件</h3> 
 <p>pg.key.set_repeat方法可以控制KEYDOWN事件的频率。比如持续按下某个按键时，想要让KEYDOWN事件每过一段时间就触发一次，就可以用set_repeat方法。</p> 
 <pre><code class="language-python">
<code class="language-python">set_repeat() -&gt; None
set_repeat(delay) -&gt; None
set_repeat(delay, interval) -&gt; None</code></code></pre> 
 <p>如果set_repeat不传递任何参数，那么就是默认的模式，只在按下时触发一次KEYDOWN事件。如果指定了delay参数，那么在按下按键后每经过delay毫秒就重复触发一次KEYDOWN事件。如果同时指定delay和interval参数，那么就表示触发一次KEYDOWN事件，等待delay毫秒后，再以interval毫秒的间隔重复触发KEYDOWN事件。</p> 
 <p>举例说明：</p> 
 <pre><code class="language-python">
<code class="language-python">import pygame as pg

pg.init()
screen = pg.display.set_mode((300, 200))

pg.key.set_repeat(1000, 200)

while True:
    for event in pg.event.get():
        if event.type == pg.QUIT:
            pg.quit()
        elif event.type == pg.KEYDOWN:
            print("KEYDOWN")</code></code></pre> 
 <p>当用户按下某个按键时，会先打印一次"KEYDOWN"，然后等待1000ms，再以200ms的时间间隔触发事件，打印多次"KEYDOWN"，如果不能理解可以运行代码试一下。</p> 
 <p>这样的停顿主要应用于更改数值的计数器，当点击增加时数值+1，持续按下时数值增加的速度变快。</p> 
 <h3>7.4 更改文本输入候选框位置</h3> 
 <p>前面介绍TEXTINPUT和TEXTEDITING的时候，已经介绍过在pygame窗口上控制文本输入的方法。现在需要做的是改变文本输入候选框的位置，而不是让其固定在一处。</p> 
 <p>首先需要了解控制文本输入的两个函数：</p> 
 <pre><code class="language-python">
<code class="language-python">pg.key.start_text_input() -&gt; None
pg.key.stop_text_input() -&gt; None</code></code></pre> 
 <p>这两个函数分别表示开始文本输入和停止文本输入。</p> 
 <p>在默认情况下是允许文本输入的，所以一般不需要调用start_text_input。在调用stop_text_input函数后，TEXTINPUT和TEXTEDITING无法被接收到，文本候选框将会持续被隐藏。重启文本输入功能可以再次调用start_text_input函数。</p> 
 <p>默认情况下，文本候选框是无论输入状态如何都不被显示的。需要显示文本候选框，可以调用下面的代码。</p> 
 <pre><code class="language-python">
<code class="language-python">import os
os.environ["SDL_IME_SHOW_UI"] = "1" #显示输入候选框UI</code></code></pre> 
 <p>这样的话，当处于允许输入状态下，输入法的文本候选框会在输入时显示。注意要在pg.display.set_mode的前面调用以上代码，否则无效。</p> 
 <blockquote>
   注意：文本候选框是指类似于下图的这样一个窗口，即IME，不同输入法不一样。 
 </blockquote> 
 <div> 
  <div> 
   <div> 
    <img alt="" src="https://images2.imgbox.com/1e/37/RoqZHlu7_o.png" width="485"> 
   </div> 
  </div> 
 </div> 
 <p>set_text_input_rect()方法控制了输入框的位置，它接受一个Rect对象表示文本候选框的位置（相对于pygame屏幕）。</p> 
 <pre><code class="language-python">
<code class="language-python">pg.key.set_text_input_rect(Rect) -&gt; None</code></code></pre> 
 <p>示例如下：</p> 
 <pre><code class="language-python">
<code class="language-python">import pygame as pg
import os

os.environ["SDL_IME_SHOW_UI"] = "1" #显示输入候选框UI
pg.init()

screen = pg.display.set_mode((300, 200))
font = pg.font.SysFont("simhei", 20)

text = ""
pg.key.set_text_input_rect((0, 0, 0, 0))

while True:
    screen.fill((0, 0, 0))
    screen.blit(font.render(text, True, (255, 255, 255)), (0, 0)) #绘制文字
    
    for event in pg.event.get():
        if event.type == pg.QUIT:
            pg.quit()
        elif event.type == pg.TEXTINPUT:
            text += event.text
            pg.key.set_text_input_rect((font.size(text)[0], 0, 0, 0))
        elif event.type == pg.KEYDOWN:
            if event.key == pg.K_BACKSPACE: #退格键
                text = text[:-1]

    pg.display.flip()</code></code></pre> 
 <p>运行效果：</p> 
 <div> 
  <div> 
   <div> 
    <img alt="" src="https://images2.imgbox.com/f5/40/YIZTDrNa_o.gif" width="298"> 
   </div> 
  </div> 
 </div> 
 <h3>7.5 key模块索引-按键操作</h3> 
 <p><strong>get_focused() -&gt; bool</strong></p> 
 <p>判断窗口是否获取输入焦点。</p> 
 <p><strong>get_pressed() -&gt; bools</strong></p> 
 <p>以字典形式返回按下且没有松开的按键。</p> 
 <p><strong>get_mods() -&gt; int</strong></p> 
 <p>返回当前按下且没有松开的组合键。</p> 
 <p style="text-align:left;"><strong>set_repeat() -&gt; None</strong></p> 
 <p style="text-align:left;"><strong>set_repeat(delay) -&gt; None</strong></p> 
 <p style="text-align:left;"><strong>set_repeat(delay, interval) -&gt; None</strong></p> 
 <p>控制重复触发KEYDOWN事件</p> 
 <p><strong>get_repeat() -&gt; (delay, interval)</strong></p> 
 <p>获取set_repeat设置的值。</p> 
 <p><strong>name(key, use_compat=True) -&gt; str</strong></p> 
 <p>通过按键常量（键码）返回键名，未找到则返回空字符串。</p> 
 <p><strong>key_code(name=string) -&gt; int</strong></p> 
 <p>通过按键名返回按键常量，示例：</p> 
 <pre><code class="language-python">
<code class="language-python">&gt;&gt;&gt; pygame.key.key_code("return") == pygame.K_RETURN
True
&gt;&gt;&gt; pygame.key.key_code("0") == pygame.K_0
True
&gt;&gt;&gt; pygame.key.key_code("space") == pygame.K_SPACE
True</code></code></pre> 
 <p><strong>start_text_input() -&gt; None</strong></p> 
 <p>开始键盘输入。</p> 
 <p><strong>stop_text_input() -&gt; None</strong></p> 
 <p>结束键盘输入。</p> 
 <p><strong>set_text_input_rect(Rect) -&gt; None</strong></p> 
 <p>设置IME的位置。</p> 
 <h2>8 鼠标处理</h2> 
 <p>参考资料：</p> 
 <p><a class="kdocs-link" href="https://pyga.me/docs/ref/mouse.html" rel="nofollow" title="pygame.mouse — pygame-ce v2.4.0 documentation">pygame.mouse — pygame-ce v2.4.0 documentation</a></p> 
 <p><a class="kdocs-link" href="https://pyga.me/docs/ref/cursors.html" rel="nofollow" title="pygame.cursors — pygame-ce v2.4.0 documentation">pygame.cursors — pygame-ce v2.4.0 documentation</a></p> 
 <h3><span style="color:#fe2c24;"><strong>8.1 获取鼠标位置</strong></span></h3> 
 <p>关于鼠标操作，包括位置、鼠标按键等一系列操作都位于pygame.mouse模块。其中最常用的方法是pg.mouse.get_pos()，用于返回鼠标相对于pygame屏幕的位置。鼠标位于屏幕外时，无法准确获取鼠标位置。</p> 
 <blockquote>
   注意：通过MOUSEMOTION事件也可以获取鼠标位置，但只有在鼠标移动的时候才会触发这个事件。 
 </blockquote> 
 <pre><code class="language-python">
<code class="language-python">import pygame as pg

pg.init()

screen = pg.display.set_mode((300, 200))
font = pg.font.SysFont("simhei", 20)

text = ""

while True:
    text = "鼠标位置:" + str(pg.mouse.get_pos())
    
    screen.fill((0, 0, 0))
    screen.blit(font.render(text, True, (255, 255, 255)), (0, 0)) #绘制文字
    
    for event in pg.event.get():
        if event.type == pg.QUIT:
            pg.quit()

    pg.display.flip()</code></code></pre> 
 <p>运行效果：</p> 
 <div> 
  <div> 
   <div> 
    <img alt="" src="https://images2.imgbox.com/2a/14/iqRxWxIM_o.gif" width="298"> 
   </div> 
  </div> 
 </div> 
 <h3>8.2 隐藏和显示光标</h3> 
 <p>set_visible方法设置鼠标的可见性。当设为False时，光标在屏幕内时会隐藏不可见。</p> 
 <pre><code class="language-python">
<code class="language-python">pg.mouse.set_visible(bool) -&gt; bool</code></code></pre> 
 <h3><span style="color:#fe2c24;"><strong>8.3 光标样式</strong></span></h3> 
 <p>光标可以更改样式，首先需要创建一个pg.cursor.Cursor光标对象。</p> 
 <p>创建光标对象的方式主要有这几种：通过Surface对象、通过xbm文件、通过光标字符串、通过光标常量载入系统光标。然后通过pg.mouse.set_cursor方法设置样式。</p> 
 <p>先介绍载入系统光标的方式。只需要将光标样式常量传递给set_cursor方法。pygame模块中有以下用于光标样式的常量。</p> 
 <div> 
  <table border="1" cellpadding="1" cellspacing="1"><tbody><tr><td style="vertical-align:top;width:255px;"> <p><strong>常量</strong></p> </td><td style="vertical-align:top;width:289px;"> <p><strong>样式描述</strong></p> </td></tr><tr><td style="vertical-align:top;width:255px;"> <p>SYSTEM_CURSOR_ARROW</p> </td><td style="vertical-align:top;width:289px;"> <p>箭头</p> </td></tr><tr><td style="vertical-align:top;width:255px;"> <p>SYSTEM_CURSOR_IBEAM</p> </td><td style="vertical-align:top;width:289px;"> <p>提示光标输入的工形标</p> </td></tr><tr><td style="vertical-align:top;width:255px;"> <p>SYSTEM_CURSOR_WAIT</p> </td><td style="vertical-align:top;width:289px;"> <p>等待</p> </td></tr><tr><td style="vertical-align:top;width:255px;"> <p>SYSTEM_CURSOR_CROSSHAIR</p> </td><td style="vertical-align:top;width:289px;"> <p>十字形</p> </td></tr><tr><td style="vertical-align:top;width:255px;"> <p>SYSTEM_CURSOR_WAITARROW</p> </td><td style="vertical-align:top;width:289px;"> <p>较小的等待箭头</p> </td></tr><tr><td style="vertical-align:top;width:255px;"> <p>SYSTEM_CURSOR_SIZENWSE</p> </td><td style="vertical-align:top;width:289px;"> <p>左上至右下的双向箭头</p> </td></tr><tr><td style="vertical-align:top;width:255px;"> <p>SYSTEM_CURSOR_SIZENESW</p> </td><td style="vertical-align:top;width:289px;"> <p>左下至右上的双向箭头</p> </td></tr><tr><td style="vertical-align:top;width:255px;"> <p>SYSTEM_CURSOR_SIZEWE</p> </td><td style="vertical-align:top;width:289px;"> <p>左右方向的双向箭头</p> </td></tr><tr><td style="vertical-align:top;width:255px;"> <p>SYSTEM_CURSOR_SIZENS</p> </td><td style="vertical-align:top;width:289px;"> <p>上下方向的双向箭头</p> </td></tr><tr><td style="vertical-align:top;width:255px;"> <p>SYSTEM_CURSOR_SIZEALL</p> </td><td style="vertical-align:top;width:289px;"> <p>四个方向的箭头</p> </td></tr><tr><td style="vertical-align:top;width:255px;"> <p>SYSTEM_CURSOR_NO</p> </td><td style="vertical-align:top;width:289px;"> <p>禁止的符号</p> </td></tr><tr><td style="vertical-align:top;width:255px;"> <p>SYSTEM_CURSOR_HAND</p> </td><td style="vertical-align:top;width:289px;"> <p>手的形状，提示点击</p> </td></tr></tbody></table> 
 </div> 
 <p>例如：</p> 
 <pre><code class="language-python">
<code class="language-python">pg.mouse.set_cursor(pg.SYSTEM_CURSOR_HAND)</code></code></pre> 
 <p>还可以通过Surface对象设置光标样式，这样就可以把某一张图片设为光标。所需的参数是光标热点的位置和表面对象。例如：</p> 
 <pre><code class="language-python">
<code class="language-python">pg.mouse.set_cursor((0, 0), pg.image.load("cursor.png"))</code></code></pre> 
 <h3>8.4 mouse模块索引-鼠标操作</h3> 
 <p style="text-align:left;"><strong>get_pressed(num_buttons=3) -&gt; (button1, button2, button3)</strong></p> 
 <p style="text-align:left;"><strong>get_pressed(num_buttons=5) -&gt; (button1, button2, button3, button4, button5)</strong></p> 
 <p>获取各个鼠标按键的按下状态。默认情况下只支持左键、中键、右键，也可以支持鼠标侧面两个按键。</p> 
 <p><strong>get_pos() -&gt; (x, y)</strong></p> 
 <p>获取鼠标位置，相对于pygame屏幕。</p> 
 <p><strong>get_rel() -&gt; (x, y)</strong></p> 
 <p>获取鼠标位置，相对于于上一次鼠标位置。</p> 
 <p><strong>set_pos([x, y]) -&gt; None</strong></p> 
 <p>设置鼠标位置。</p> 
 <p><strong>set_visible(bool) -&gt; bool</strong></p> 
 <p>设置鼠标可见性。</p> 
 <p><strong>get_visible() -&gt; bool</strong></p> 
 <p>获取鼠标可见性。</p> 
 <p><strong>get_focused() -&gt; bool</strong></p> 
 <p>判断窗口是否在获取鼠标输入。</p> 
 <p style="text-align:left;"><strong>set_cursor(pygame.cursors.Cursor) -&gt; None</strong></p> 
 <p style="text-align:left;"><strong>set_cursor(size, hotspot, xormasks, andmasks) -&gt; None</strong></p> 
 <p style="text-align:left;"><strong>set_cursor(hotspot, surface) -&gt; None</strong></p> 
 <p style="text-align:left;"><strong>set_cursor(constant) -&gt; None</strong></p> 
 <p>设置鼠标样式。</p> 
 <p><strong>get_cursor() -&gt; pygame.cursors.Cursor</strong></p> 
 <p>获取鼠标样式。</p> 
 <h3>8.5 cursor模块索引-光标样式</h3> 
 <p><strong>compile(strings, black='X', white='.', xor='o') -&gt; data, mask</strong></p> 
 <p>编译光标字符串。下面是一个光标字符串的示例（箭头光标）。</p> 
 <pre><code class="language-python">
<code class="language-python">thickarrow_strings = (               #sized 24x24
  "XX                      ",
  "XXX                     ",
  "XXXX                    ",
  "XX.XX                   ",
  "XX..XX                  ",
  "XX...XX                 ",
  "XX....XX                ",
  "XX.....XX               ",
  "XX......XX              ",
  "XX.......XX             ",
  "XX........XX            ",
  "XX........XXX           ",
  "XX......XXXXX           ",
  "XX.XXX..XX              ",
  "XXXX XX..XX             ",
  "XX   XX..XX             ",
  "     XX..XX             ",
  "      XX..XX            ",
  "      XX..XX            ",
  "       XXXX             ",
  "       XX               ",
  "                        ",
  "                        ",
  "                        ")</code></code></pre> 
 <p style="text-align:left;"><strong>load_xbm(cursorfile) -&gt; cursor_args</strong></p> 
 <p style="text-align:left;"><strong>load_xbm(cursorfile, maskfile) -&gt; cursor_args</strong></p> 
 <p>加载xbm格式的位图文件作为光标。返回的cursor_args可以直接解包传递给set_cursor方法。</p> 
 <p style="text-align:left;"><strong>Cursor(size, hotspot, xormasks, andmasks) -&gt; Cursor</strong></p> 
 <p style="text-align:left;"><strong>Cursor(hotspot, surface) -&gt; Cursor</strong></p> 
 <p style="text-align:left;"><strong>Cursor(constant) -&gt; Cursor</strong></p> 
 <p style="text-align:left;"><strong>Cursor(Cursor) -&gt; Cursor</strong></p> 
 <p style="text-align:left;"><strong>Cursor() -&gt; Cursor</strong></p> 
 <p>光标对象。</p> 
 <p><strong>Cursor.type -&gt; string</strong></p> 
 <p>光标类型，可能是"system", "bitmap", "color"</p> 
 <p><strong>Cursor.data -&gt; tuple</strong></p> 
 <p>光标数据</p> 
 <p><strong>Cursor.copy() -&gt; Cursor</strong></p> 
 <p>复制光标对象</p> 
 <h2>实战：键盘输入程序</h2> 
 <p>本章是实战练习环节，将实现以下效果。</p> 
 <div> 
  <div> 
   <div> 
    <img alt="" src="https://images2.imgbox.com/b8/07/ABx3Itpm_o.gif" width="298"> 
   </div> 
  </div> 
 </div> 
 <h3>完整代码</h3> 
 <pre><code class="language-python">
<code class="language-python">import pygame as pg
from pygame.locals import * #导入所有常量
import os

os.environ["SDL_IME_SHOW_UI"] = "1" #显示输入候选框UI
pg.init()

screen = pg.display.set_mode((300, 300), RESIZABLE) #窗口可调整大小
font = pg.font.SysFont("simhei", 20)

text = ""
index = 0
index_tip = ""
show_index = True

pg.key.set_repeat(750, 25) #持续触发退格键
pg.key.set_text_input_rect((0, 0, 0, 0))
pg.mouse.set_cursor(SYSTEM_CURSOR_IBEAM)
pg.time.set_timer(USEREVENT, 500) #重复生成事件，光标闪烁

def split_text(text): #将字符分行
    res = [""]
    for char in text:
        if font.size(res[-1]+char)[0] &gt; screen.get_width(): #get_width返回表面宽度
            res.append("")
        else:
            res[-1] += char

    return res
            
while True:
    screen.fill((0, 0, 0))

    s_list = split_text(text)
    length = 0
    for i, s in enumerate(s_list):
        if length != -1:
            length += len(s)
        if length &gt;= index - i:
            index_line = i
            idx = index - sum([len(s) for s in s_list[:i]])
            s = s[:idx] + index_tip + s[idx:]
            length = -1

            pg.key.set_text_input_rect((font.size(s[:idx] + "|")[0], i *24, 0, 0))
            
        screen.blit(font.render(s, True, (255, 255, 255)), (0, i * 24))
    
    for event in pg.event.get():
        if event.type == QUIT:
            pg.quit()
            
        elif event.type == WINDOWFOCUSLOST: #窗口失去焦点，隐藏输入光标
            show_index = False      
        elif event.type == WINDOWFOCUSGAINED: #窗口获取焦点，显示输入光标
            show_index = True
            
        elif event.type == TEXTINPUT: #文本输入
            text = text[:index] + event.text + text[index:]
            index += len(event.text)
            
        elif event.type == KEYDOWN:
            if event.key == K_BACKSPACE: #退格键
                index -= 1
                if index &lt; 0:
                    index = 0
                else:
                    text = text[:index] + text[index+1:]
            elif event.key == K_DELETE: #向右删除键
                text = text[:index] + text[index+1:]

            elif event.key == K_LEFT: #光标向左
                index -= 1
                if index &lt; 0:
                    index = 0
            elif event.key == K_RIGHT: #光标向右
                index += 1
                if index &gt; len(s_list[index_line]):
                    index -= 1

        elif event.type == USEREVENT: #更新光标
            if show_index:
                index_tip = " " if index_tip != " " else "|"
            else:
                index_tip = "|"

    pg.display.flip()</code></code></pre> 
 <h2>下一篇文章</h2> 
 <p><a class="kdocs-link" href="https://blog.csdn.net/qq_48979387/article/details/128865416" title="Python pygame(GUI编程)模块最完整教程（3）_pygame教程pdf_Python-ZZY的博客-CSDN博客">Python pygame(GUI编程)模块最完整教程（3）_pygame教程pdf_Python-ZZY的博客-CSDN博客</a></p> 
 <p></p> 
</div>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/f08553fb92e7c0863210fb3bb1d995f6/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">【vue】vue-slick-carousel插件，实现横向滚动列表手动左右滚动（也可设置为自动滚动）</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/c0c65f8ef5a82d2ebd1a26d8f6a00bfc/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">STM32CubeMX安装及使用</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>