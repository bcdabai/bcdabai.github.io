<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>AF_UNIX 本地通信 - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="AF_UNIX 本地通信" />
<meta property="og:description" content="文章目录 一、AF_UNIX 本地通信1. Linux进程通信机制2. socket本地域套接字AF_UNIX3. demo示例 二、AF_INET域与AF_UNIX域socket通信原理对比1. AF_INET域socket通信过程2. AF_UNIX域socket通信过程3. 相同点4. 不同点5. 使用场景 三、PF_INET和AF_INET、PF_UNIX和AF_UNIX之间的区别四、参考资料 一、AF_UNIX 本地通信 1. Linux进程通信机制 linux本地进程间通讯，大概有如下几种方式，socket本地域套接字是其中的一种。
项目中，主应用和协议栈两个进程间通讯，就是用的socket本地域套接字。（需要自定义数据协议格式，一般定义好协议格式头&#43;数据&#43;尾即可）
2. socket本地域套接字AF_UNIX 用于本地进程间的通信。
基于socket的框架上发展出一种IPC机制，就是UNIX Domain Socket。虽然网络socket也可用于同一台主机的进程间通讯（通过loopback地址127.0.0.1），但是UNIX Domain Socket用于IPC 更有效率 ：
不需要经过网络协议栈不需要打包拆包、计算校验和、维护序号和应答等，可靠性更强 只是将应用层数据从一个进程拷贝到另一个进程。这是因为，IPC机制本质上是可靠的通讯，而网络协议是为不可靠的通讯设计的。UNIX Domain Socket也提供面向流和面向数据包两种API接口，类似于TCP和UDP，但是面向消息的UNIX Domain Socket也是可靠的，消息既不会丢失也不会顺序错乱。
3. demo示例 https://blog.csdn.net/m0_37542524/article/details/84668406
二、AF_INET域与AF_UNIX域socket通信原理对比 转自：https://blog.csdn.net/sandware/article/details/40923491
1. AF_INET域socket通信过程 典型的TCP/IP四层模型的通信过程。
发送方、接收方依赖IP:Port来标识，即将本地的socket绑定到对应的IP端口上，发送数据时，指定对方的IP端口，经过Internet，可以根据此IP端口最终找到接收方；接收数据时，可以从数据包中获取到发送方的IP端口。
发送方通过系统调用send()将原始数据发送到操作系统内核缓冲区中。内核缓冲区从上到下依次经过TCP层、IP层、链路层的编码，分别添加对应的头部信息，经过网卡将一个数据包发送到网络中。经过网络路由到接收方的网卡。网卡通过系统中断将数据包通知到接收方的操作系统，再沿着发送方编码的反方向进行解码，即依次经过链路层、IP层、TCP层去除头部、检查校验等，最终将原始数据上报到接收方进程。
2. AF_UNIX域socket通信过程 典型的本地IPC，类似于管道，依赖路径名标识发送方和接收方。即发送数据时，指定接收方绑定的路径名，操作系统根据该路径名可以直接找到对应的接收方，并将原始数据直接拷贝到接收方的内核缓冲区中，并上报给接收方进程进行处理。同样的接收方可以从收到的数据包中获取到发送方的路径名，并通过此路径名向其发送数据。
3. 相同点 操作系统提供的接口socket(),bind(),connect(),accept(),send(),recv()，以及用来对其进行多路复用事件检测的select(),poll(),epoll()都是完全相同的。收发数据的过程中，上层应用感知不到底层的差别。
4. 不同点 1 建立socket传递的地址域，及bind()的地址结构稍有区别：
socket() 分别传递不同的域AF_INET和AF_UNIX
bind()的地址结构分别为sockaddr_in（制定IP端口）和sockaddr_un（指定路径名）
2 AF_INET需经过多个协议层的编解码，消耗系统cpu，并且数据传输需要经过网卡，受到网卡带宽的限制。AF_UNIX数据到达内核缓冲区后，由内核根据指定路径名找到接收方socket对应的内核缓冲区，直接将数据拷贝过去，不经过协议层编解码，节省系统cpu，并且不经过网卡，因此不受网卡带宽的限制。
3 AF_UNIX的传输速率远远大于AF_INET
4 AF_INET不仅可以用作本机的跨进程通信，同样的可以用于不同机器之间的通信，其就是为了在不同机器之间进行网络互联传递数据而生。而AF_UNIX则只能用于本机内进程之间的通信。
5. 使用场景 AF_UNIX由于其对系统cpu的较少消耗，不受限于网卡带宽，及高效的传递速率，本机通信则首选AF_UNIX域。
不用多说，AF_INET则用于跨机器之间的通信。
三、PF_INET和AF_INET、PF_UNIX和AF_UNIX之间的区别 https://blog." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/d196ad1ed7908a5a879097592e3c3b04/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-04-02T17:11:37+08:00" />
<meta property="article:modified_time" content="2022-04-02T17:11:37+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">AF_UNIX 本地通信</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p></p> 
<div class="toc"> 
 <h4>文章目录</h4> 
 <ul><li><a href="#AF_UNIX__2" rel="nofollow">一、AF_UNIX 本地通信</a></li><li><ul><li><a href="#1_Linux_3" rel="nofollow">1. Linux进程通信机制</a></li><li><a href="#2_socketAF_UNIX_8" rel="nofollow">2. socket本地域套接字AF_UNIX</a></li><li><a href="#3_demo_18" rel="nofollow">3. demo示例</a></li></ul> 
  </li><li><a href="#AF_INETAF_UNIXsocket_22" rel="nofollow">二、AF_INET域与AF_UNIX域socket通信原理对比</a></li><li><ul><li><a href="#1_AF_INETsocket_25" rel="nofollow">1. AF_INET域socket通信过程</a></li><li><a href="#2__AF_UNIXsocket_33" rel="nofollow">2. AF_UNIX域socket通信过程</a></li><li><a href="#3___36" rel="nofollow">3. 相同点</a></li><li><a href="#4___38" rel="nofollow">4. 不同点</a></li><li><a href="#5___51" rel="nofollow">5. 使用场景</a></li></ul> 
  </li><li><a href="#PF_INETAF_INETPF_UNIXAF_UNIX_56" rel="nofollow">三、PF_INET和AF_INET、PF_UNIX和AF_UNIX之间的区别</a></li><li><a href="#_59" rel="nofollow">四、参考资料</a></li></ul> 
</div> 
<p></p> 
<h2><a id="AF_UNIX__2"></a>一、AF_UNIX 本地通信</h2> 
<h3><a id="1_Linux_3"></a>1. Linux进程通信机制</h3> 
<p>linux本地进程间通讯，大概有如下几种方式，socket本地域套接字是其中的一种。<br> <img src="https://images2.imgbox.com/11/9b/s3MKR2zO_o.png" alt="在这里插入图片描述"><br> 项目中，主应用和协议栈两个进程间通讯，就是用的socket本地域套接字。（需要自定义数据协议格式，一般定义好协议格式头+数据+尾即可）</p> 
<h3><a id="2_socketAF_UNIX_8"></a>2. socket本地域套接字AF_UNIX</h3> 
<p><font color="red">用于本地进程间的通信。</font></p> 
<p>基于socket的框架上发展出一种IPC机制，就是UNIX Domain Socket。虽然网络socket也可用于同一台主机的进程间通讯（通过loopback地址127.0.0.1），但是UNIX Domain Socket用于IPC 更有效率 ：</p> 
<ul><li>不需要经过网络协议栈</li><li>不需要打包拆包、计算校验和、维护序号和应答等，可靠性更强</li></ul> 
<p>只是将应用层数据从一个进程拷贝到另一个进程。这是因为，IPC机制本质上是可靠的通讯，而网络协议是为不可靠的通讯设计的。UNIX Domain Socket也提供面向流和面向数据包两种API接口，类似于TCP和UDP，但是面向消息的UNIX Domain Socket也是可靠的，消息既不会丢失也不会顺序错乱。</p> 
<h3><a id="3_demo_18"></a>3. demo示例</h3> 
<p><a href="https://blog.csdn.net/m0_37542524/article/details/84668406">https://blog.csdn.net/m0_37542524/article/details/84668406</a></p> 
<h2><a id="AF_INETAF_UNIXsocket_22"></a>二、AF_INET域与AF_UNIX域socket通信原理对比</h2> 
<p>转自：<a href="https://blog.csdn.net/sandware/article/details/40923491">https://blog.csdn.net/sandware/article/details/40923491</a></p> 
<h3><a id="1_AF_INETsocket_25"></a>1. AF_INET域socket通信过程</h3> 
<p><img src="https://images2.imgbox.com/0a/46/4xKbHZ1c_o.png" alt="在这里插入图片描述"><br> 典型的TCP/IP四层模型的通信过程。</p> 
<p>发送方、接收方依赖IP:Port来标识，即将本地的socket绑定到对应的IP端口上，发送数据时，指定对方的IP端口，经过Internet，可以根据此IP端口最终找到接收方；接收数据时，可以从数据包中获取到发送方的IP端口。</p> 
<p>发送方通过系统调用send()将原始数据发送到操作系统内核缓冲区中。内核缓冲区从上到下依次经过TCP层、IP层、链路层的编码，分别添加对应的头部信息，经过网卡将一个数据包发送到网络中。经过网络路由到接收方的网卡。网卡通过系统中断将数据包通知到接收方的操作系统，再沿着发送方编码的反方向进行解码，即依次经过链路层、IP层、TCP层去除头部、检查校验等，最终将原始数据上报到接收方进程。</p> 
<h3><a id="2__AF_UNIXsocket_33"></a>2. AF_UNIX域socket通信过程</h3> 
<p>典型的本地IPC，类似于管道，依赖路径名标识发送方和接收方。即发送数据时，指定接收方绑定的路径名，操作系统根据该路径名可以直接找到对应的接收方，并将原始数据直接拷贝到接收方的内核缓冲区中，并上报给接收方进程进行处理。同样的接收方可以从收到的数据包中获取到发送方的路径名，并通过此路径名向其发送数据。<br> <img src="https://images2.imgbox.com/64/d1/ZkBwGTip_o.png" alt="在这里插入图片描述"></p> 
<h3><a id="3___36"></a>3. 相同点</h3> 
<p>操作系统提供的接口socket(),bind(),connect(),accept(),send(),recv()，以及用来对其进行多路复用事件检测的select(),poll(),epoll()都是完全相同的。收发数据的过程中，上层应用感知不到底层的差别。</p> 
<h3><a id="4___38"></a>4. 不同点</h3> 
<p><font color="red">1 建立socket传递的地址域，及bind()的地址结构稍有区别：</font></p> 
<p>socket() 分别传递不同的域AF_INET和AF_UNIX</p> 
<p>bind()的地址结构分别为sockaddr_in（制定IP端口）和sockaddr_un（指定路径名）</p> 
<p>2 AF_INET需经过多个协议层的编解码，消耗系统cpu，并且数据传输需要经过网卡，受到网卡带宽的限制。AF_UNIX数据到达内核缓冲区后，由内核根据指定路径名找到接收方socket对应的内核缓冲区，直接将数据拷贝过去，不经过协议层编解码，节省系统cpu，并且不经过网卡，因此不受网卡带宽的限制。</p> 
<p>3 AF_UNIX的传输速率远远大于AF_INET</p> 
<p>4 AF_INET不仅可以用作本机的跨进程通信，同样的可以用于不同机器之间的通信，其就是为了在不同机器之间进行网络互联传递数据而生。而AF_UNIX则只能用于本机内进程之间的通信。</p> 
<h3><a id="5___51"></a>5. 使用场景</h3> 
<p>AF_UNIX由于其对系统cpu的较少消耗，不受限于网卡带宽，及高效的传递速率，本机通信则首选AF_UNIX域。</p> 
<p>不用多说，AF_INET则用于跨机器之间的通信。</p> 
<h2><a id="PF_INETAF_INETPF_UNIXAF_UNIX_56"></a>三、PF_INET和AF_INET、PF_UNIX和AF_UNIX之间的区别</h2> 
<p><a href="https://blog.csdn.net/xiongmaojiayou/article/details/7584211">https://blog.csdn.net/xiongmaojiayou/article/details/7584211</a></p> 
<h2><a id="_59"></a>四、参考资料</h2> 
<p>socket的学习（二）AF_UNIX实现本地通信<br> <a href="https://blog.csdn.net/weixin_39258979/article/details/80931464">https://blog.csdn.net/weixin_39258979/article/details/80931464</a></p> 
<p>嵌入式linux网络编程，UNIX域套接字，AF_LOCAL，PF_LOCAL，PF_UNIX，，AF_UNIX，进程间通信机制<br> <a href="https://blog.csdn.net/m0_37542524/article/details/84668406">https://blog.csdn.net/m0_37542524/article/details/84668406</a></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/2fc41ddfb58be35475cea79833daa936/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">Centos 7离线安装MySql8</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/740cc74614e8e3ab010e3d86a97a7811/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">Jetson Xavier NX系统安装至 nvme 硬盘</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>