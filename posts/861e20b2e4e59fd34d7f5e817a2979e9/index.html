<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Go语言学习-数据类型 - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Go语言学习-数据类型" />
<meta property="og:description" content="Go语言将数据类型分为四类：基础类型、复合类型、引用类型和接口类型。
基础类型 整型 不管它们的具体大小，int、uint和uintptr是不同类型的兄弟类型。其中int和int32也是不同的类型，即使int的大小也是32bit，在需要将int当作int32类型的地方需要一个显式的类型转换操作，反之亦然。事实上，内置的len函数返回一个有符号的int。
var x uint8 = 1&lt;&lt;1 | 1&lt;&lt;5 var y uint8 = 1&lt;&lt;1 | 1&lt;&lt;2 fmt.Printf(&#34;%08b\n&#34;, x) // &#34;00100010&#34;, the set {1, 5} fmt.Printf(&#34;%08b\n&#34;, y) // &#34;00000110&#34;, the set {1, 2} ​当使用fmt包打印一个数值时，我们可以用%d、%o或%x参数控制输出的进制格式。通常Printf格式化字符串包含多个%参数时将会包含对应相同数量的额外操作数，但是%之后的[1]副词告诉Printf函数再次使用第一个操作数。第二，%后的#副词告诉Printf在用%o、%x或%X输出时生成0、0x或0X前缀。
o := 0666 fmt.Printf(&#34;%d %[1]o %#[1]o\n&#34;, o) // &#34;438 666 0666&#34; x := int64(0xdeadbeef) fmt.Printf(&#34;%d %[1]x %#[1]x %#[1]X\n&#34;, x) // Output: // 3735928559 deadbeef 0xdeadbeef 0XDEADBEEF 浮点型 浮点数的范围极限值可以在math包找到。常量math.MaxFloat32表示float32能表示的最大数值，大约是 3.4e38；对应的math.MaxFloat64常量大约是1.8e308。它们分别能表示的最小值近似为1.4e-45和4.9e-324。
通常应该优先使用float64类型，因为float32类型的累计计算误差很容易扩散，并且float32能精确表示的正整数并不是很大（译注：因为float32的有效bit位只有23个，其它的bit位用于指数和符号；当整数大于23bit能表达的范围时，float32的表示将出现误差）。很小或很大的数最好用科学计数法书写，通过e或E来指定指数部分。
math包中除了提供大量常用的数学函数外，还提供了IEEE754浮点数标准中定义的特殊值的创建和测试：正无穷大和负无穷大，分别用于表示太大溢出的数字和除零的结果；还有NaN非数，一般用于表示无效的除法操作结果0/0或Sqrt(-1)。函数math.IsNaN用于测试一个数是否是非数NaN，math.NaN则返回非数对应的值，nan := math.NaN()。
var f float64 = 212 fmt." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/861e20b2e4e59fd34d7f5e817a2979e9/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2021-05-14T17:33:03+08:00" />
<meta property="article:modified_time" content="2021-05-14T17:33:03+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Go语言学习-数据类型</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-light">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p>Go语言将数据类型分为四类：基础类型、复合类型、引用类型和接口类型。</p> 
<h2><a id="_2"></a>基础类型</h2> 
<h3><a id="_4"></a>整型</h3> 
<p>不管它们的具体大小，int、uint和uintptr是不同类型的兄弟类型。其中int和int32也是不同的类型，即使int的大小也是32bit，在需要将int当作int32类型的地方需要一个显式的类型转换操作，反之亦然。事实上，内置的len函数返回一个有符号的int。</p> 
<pre><code class="prism language-go"><span class="token keyword">var</span> x <span class="token builtin">uint8</span> <span class="token operator">=</span> <span class="token number">1</span><span class="token operator">&lt;&lt;</span><span class="token number">1</span> <span class="token operator">|</span> <span class="token number">1</span><span class="token operator">&lt;&lt;</span><span class="token number">5</span>
<span class="token keyword">var</span> y <span class="token builtin">uint8</span> <span class="token operator">=</span> <span class="token number">1</span><span class="token operator">&lt;&lt;</span><span class="token number">1</span> <span class="token operator">|</span> <span class="token number">1</span><span class="token operator">&lt;&lt;</span><span class="token number">2</span>

fmt<span class="token punctuation">.</span><span class="token function">Printf</span><span class="token punctuation">(</span><span class="token string">"%08b\n"</span><span class="token punctuation">,</span> x<span class="token punctuation">)</span> <span class="token comment">// "00100010", the set {1, 5}</span>
fmt<span class="token punctuation">.</span><span class="token function">Printf</span><span class="token punctuation">(</span><span class="token string">"%08b\n"</span><span class="token punctuation">,</span> y<span class="token punctuation">)</span> <span class="token comment">// "00000110", the set {1, 2}</span>
</code></pre> 
<p>​当使用fmt包打印一个数值时，我们可以用%d、%o或%x参数控制输出的进制格式。通常Printf格式化字符串包含多个%参数时将会包含对应相同数量的额外操作数，但是%之后的<code>[1]</code>副词告诉Printf函数再次使用第一个操作数。第二，%后的<code>#</code>副词告诉Printf在用%o、%x或%X输出时生成0、0x或0X前缀。</p> 
<pre><code class="prism language-go">o <span class="token operator">:=</span> <span class="token number">0666</span>
fmt<span class="token punctuation">.</span><span class="token function">Printf</span><span class="token punctuation">(</span><span class="token string">"%d %[1]o %#[1]o\n"</span><span class="token punctuation">,</span> o<span class="token punctuation">)</span> <span class="token comment">// "438 666 0666"</span>
x <span class="token operator">:=</span> <span class="token function">int64</span><span class="token punctuation">(</span><span class="token number">0xdeadbeef</span><span class="token punctuation">)</span>
fmt<span class="token punctuation">.</span><span class="token function">Printf</span><span class="token punctuation">(</span><span class="token string">"%d %[1]x %#[1]x %#[1]X\n"</span><span class="token punctuation">,</span> x<span class="token punctuation">)</span>
<span class="token comment">// Output:</span>
<span class="token comment">// 3735928559 deadbeef 0xdeadbeef 0XDEADBEEF</span>
</code></pre> 
<br> 
<h3><a id="_29"></a>浮点型</h3> 
<p>浮点数的范围极限值可以在math包找到。常量math.MaxFloat32表示float32能表示的最大数值，大约是 3.4e38；对应的math.MaxFloat64常量大约是1.8e308。它们分别能表示的最小值近似为1.4e-45和4.9e-324。</p> 
<p>通常应该优先使用float64类型，因为float32类型的累计计算误差很容易扩散，并且float32能精确表示的正整数并不是很大（译注：因为float32的有效bit位只有23个，其它的bit位用于指数和符号；当整数大于23bit能表达的范围时，float32的表示将出现误差）。很小或很大的数最好用科学计数法书写，通过e或E来指定指数部分。</p> 
<p>math包中除了提供大量常用的数学函数外，还提供了IEEE754浮点数标准中定义的特殊值的创建和测试：正无穷大和负无穷大，分别用于表示太大溢出的数字和除零的结果；还有NaN非数，一般用于表示无效的除法操作结果0/0或Sqrt(-1)。函数math.IsNaN用于测试一个数是否是非数NaN，math.NaN则返回非数对应的值，<code>nan := math.NaN()</code>。</p> 
<pre><code class="prism language-go"><span class="token keyword">var</span> f <span class="token builtin">float64</span> <span class="token operator">=</span> <span class="token number">212</span>
fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token punctuation">(</span>f <span class="token operator">-</span> <span class="token number">32</span><span class="token punctuation">)</span> <span class="token operator">*</span> <span class="token number">5</span> <span class="token operator">/</span> <span class="token number">9</span><span class="token punctuation">)</span>     <span class="token comment">// "100"; (f - 32) * 5 is a float64</span>
fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token number">5</span> <span class="token operator">/</span> <span class="token number">9</span> <span class="token operator">*</span> <span class="token punctuation">(</span>f <span class="token operator">-</span> <span class="token number">32</span><span class="token punctuation">)</span><span class="token punctuation">)</span>     <span class="token comment">// "0";   5/9 is an untyped integer, 0</span>
fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token number">5.0</span> <span class="token operator">/</span> <span class="token number">9.0</span> <span class="token operator">*</span> <span class="token punctuation">(</span>f <span class="token operator">-</span> <span class="token number">32</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment">// "100"; 5.0/9.0 is an untyped float</span>
</code></pre> 
<br> 
<h3><a id="_48"></a>复数</h3> 
<p>Go语言提供了两种精度的复数类型：complex64 和 complex128，分别对应 float32 和 float64 两种浮点数精度。内置的 complex 函数用于构建复数，内建的 real 和 imag 函数分别返回复数的实部和虚部：</p> 
<pre><code class="prism language-Go">var x complex128 = complex(1, 2) // 1+2i
var y complex128 = complex(3, 4) // 3+4i
fmt.Println(x*y)                 // "(-5+10i)"
fmt.Println(real(x*y))           // "-5"
fmt.Println(imag(x*y))           // "10"
</code></pre> 
<p>如果一个浮点数面值或一个十进制整数面值后面跟着一个i，例如3.141592i或2i，它将构成一个复数的虚部，复数的实部是0：</p> 
<pre><code class="prism language-go">fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token number">1i</span> <span class="token operator">*</span> <span class="token number">1i</span><span class="token punctuation">)</span> <span class="token comment">// "(-1+0i)", i^2 = -1</span>
</code></pre> 
<p>​</p> 
<p>​在常量算术规则下，一个复数常量可以加到另一个普通数值常量（整数或浮点数、实部或虚部），我们可以用自然的方式书写复数，就像1+2i或与之等价的写法2i+1。上面x和y的声明语句还可以简化：</p> 
<pre><code class="prism language-go">x <span class="token operator">:=</span> <span class="token number">1</span> <span class="token operator">+</span> <span class="token number">2i</span>
y <span class="token operator">:=</span> <span class="token number">3</span> <span class="token operator">+</span> <span class="token number">4i</span>
</code></pre> 
<p>复数也可以用==和!=进行相等比较。只有两个复数的实部和虚部都相等的时候它们才是相等的（译注：浮点数的相等比较是危险的，需要特别小心处理精度问题）。</p> 
<br> ## 布尔型 
<p>如果运算符左边值已经可以确定整个布尔表达式的值，那么运算符右边的值将不再被求值，因此下面的表达式总是安全的：</p> 
<pre><code class="prism language-go">s <span class="token operator">!=</span> <span class="token string">""</span> <span class="token operator">&amp;&amp;</span> s<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token string">'x'</span>
</code></pre> 
<p>其中s[0]操作如果应用于空字符串将会导致panic异常。<br> 布尔值并不会隐式转换为数字值0或1，反之亦然。必须使用一个显式的if语句辅助转换。</p> 
<h3><a id="_92"></a>字符串</h3> 
<p>一个字符串是一个不可改变的字节序列（字符串变量的值是可以变的），内置的len函数可以返回一个字符串中的<strong>字节数目</strong>。索引操作 s[i] 返回<strong>第 i 个字节</strong>的字节值，i 必须满足0 ≤ i &lt; len(s)条件约束。如果试图访问超出字符串索引范围的字节将会导致panic异常。<strong>第i个字节并不一定是字符串的第i个字符</strong>，因为对于非ASCII字符的UTF8编码会要两个或多个字节。所以就不能直接用长度和下标来一一访问，<strong>得用 range，range 能分出实际对应的每一个字符</strong>。如果输出的是编码的数字的话，可以<strong>用 string© 来输出实际对应的字符</strong>。</p> 
<p>+操作符将两个字符串连接构造一个新字符串。<strong>字符串可以用==和&lt;进行比较；比较通过逐个字节比较完成的</strong>，因此比较的结果是字符串自然编码的顺序。可以直接用字符串某个范围内的判等来判断前后缀和子串。</p> 
<p>字符串的值是不可变的：一个字符串包含的字节序列永远不会被改变，当然我们也可以给一个字符串变量分配一个新字符串值。因为字符串是不可修改的，因此<strong>尝试修改字符串内部数据的操作也是被禁止的</strong>：（相当于是只读的）</p> 
<pre><code class="prism language-go">s<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">'L'</span> <span class="token comment">// compile error: cannot assign to s[0]</span>
</code></pre> 
<br> 
<p>strings包提供了许多如字符串的查询、替换、比较、截断、拆分和合并等功能。strconv包提供了布尔型、整型数、浮点数和对应字符串的相互转换，还提供了双引号转义相关的转换。</p> 
<p>字符串和字节slice之间可以相互转换：</p> 
<pre><code class="prism language-go">s <span class="token operator">:=</span> <span class="token string">"abc"</span>
b <span class="token operator">:=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token function">byte</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span>
s2 <span class="token operator">:=</span> <span class="token function">string</span><span class="token punctuation">(</span>b<span class="token punctuation">)</span>
</code></pre> 
<p>从概念上讲，一个[]byte(s)转换是分配了一个新的字节数组用于保存字符串数据的拷贝，然后引用这个底层的字节数组。</p> 
<p>bytes包还提供了Buffer类型用于字节slice的缓存。一个Buffer开始是空的，但是随着string、byte或[]byte等类型数据的写入可以动态增长，一个bytes.Buffer变量并不需要初始化，因为零值也是有效的。</p> 
<p>类型转换：（ fmt.Sprintf可以处理格式化输出，就是换成另一个指定的格式）</p> 
<pre><code class="prism language-go">	x <span class="token operator">:=</span> <span class="token number">123</span>
	s <span class="token operator">:=</span> fmt<span class="token punctuation">.</span><span class="token function">Sprintf</span><span class="token punctuation">(</span><span class="token string">"x=%b"</span><span class="token punctuation">,</span> x<span class="token punctuation">)</span> <span class="token comment">// "x=1111011"</span>
</code></pre> 
<h3><a id="_135"></a>常量</h3> 
<p>常量表达式的值在<strong>编译期</strong>计算，而不是在运行期。每种常量的潜在类型都是基础类型：boolean、string或数字。当操作数是常量时，一些运行时的错误也可以在编译时被发现，例如整数除零、字符串索引越界、任何导致无效浮点数的操作等。</p> 
<p>一个常量的声明也可以包含一个类型和一个值，但是如果没有显式指明类型，那么将从右边的表达式推断类型。</p> 
<p>常量间的所有算术运算、逻辑运算和比较<strong>运算的结果也是常量</strong>，对常量的类型转换操作或以下函数调用都是返回常量结果：len、cap、real、imag、complex和unsafe.Sizeof。</p> 
<p>常量声明可以使用iota常量生成器初始化，它用于生成一组以相似规则初始化的常量，但是不用每行都写一遍初始化表达式。在一个const声明语句中，在第一个声明的常量所在的行，iota将会被置为0，然后在每一个有常量声明的行加一。</p> 
<pre><code class="prism language-go"><span class="token keyword">type</span> Weekday <span class="token builtin">int</span>

<span class="token keyword">const</span> <span class="token punctuation">(</span>
    Sunday Weekday <span class="token operator">=</span> <span class="token boolean">iota</span>
    Monday
    Tuesday
    Wednesday
    Thursday
    Friday
    Saturday
<span class="token punctuation">)</span>
</code></pre> 
<p>周日将对应0，周一为1，如此等等。</p> 
<pre><code class="prism language-Go">const (
    FlagUp Flags = 1 &lt;&lt; iota // is up
    FlagBroadcast            // supports broadcast access capability
    FlagLoopback             // is a loopback interface
    FlagPointToPoint         // belongs to a point-to-point link
    FlagMulticast            // supports multicast access capability
)
</code></pre> 
<p>随着iota的递增，每个常量对应表达式1 &lt;&lt; iota，是连续的2的幂，分别对应一个bit位置。</p> 
<p>反正就是在这个常量组里，iota的初始值是0，接下来每次增加1，赋给常量的值是用当前的iota的值根据第一个计算式来进行计算。</p> 
<h2><a id="_179"></a>复合数据类型</h2> 
<h3><a id="_181"></a>数组</h3> 
<p>长度固定（只要定义的时候在 [ ] 里写了长度，就是数组，长度就固定了）</p> 
<p>初始化的时候可以指定某一个下标处的值：<code>x := [5]int{2: 3}</code></p> 
<p>如果一个数组的元素类型是可以相互比较的，那么数组类型也是可以相互比较的，这时候我们可以直接通过==比较运算符来比较两个数组，只有当两个数组的所有元素都是相等的时候数组才是相等的。不相等比较运算符!=遵循同样的规则。</p> 
<p>算符!=遵循同样的规则。</p> 
<pre><code class="prism language-go">a <span class="token operator">:=</span> <span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token builtin">int</span><span class="token punctuation">{<!-- --></span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">}</span>
b <span class="token operator">:=</span> <span class="token punctuation">[</span><span class="token operator">...</span><span class="token punctuation">]</span><span class="token builtin">int</span><span class="token punctuation">{<!-- --></span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">}</span>
c <span class="token operator">:=</span> <span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token builtin">int</span><span class="token punctuation">{<!-- --></span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">}</span>
fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>a <span class="token operator">==</span> b<span class="token punctuation">,</span> a <span class="token operator">==</span> c<span class="token punctuation">,</span> b <span class="token operator">==</span> c<span class="token punctuation">)</span> <span class="token comment">// "true false false"</span>
d <span class="token operator">:=</span> <span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token builtin">int</span><span class="token punctuation">{<!-- --></span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">}</span>
fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>a <span class="token operator">==</span> d<span class="token punctuation">)</span> <span class="token comment">// compile error: cannot compare [2]int == [3]int</span>
</code></pre> 
<p>把数组传入函数的时候，要传数组的指针，这样才能改到外面的数。数组的长度是固定的，就是这个函数也只能对应长度为5的数组。</p> 
<pre><code class="prism language-go"><span class="token keyword">func</span> <span class="token function">temp</span><span class="token punctuation">(</span>tmp <span class="token operator">*</span><span class="token punctuation">[</span><span class="token number">5</span><span class="token punctuation">]</span><span class="token builtin">int</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
	tmp<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">100</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>虽然通过指针来传递数组参数是高效的，而且也允许在函数内部修改数组的值，但是数组依然是僵化的类型，因为数组的类型包含了僵化的长度信息。上面的函数并不能接收指向 [6]int 类型数组的指针，而且也没有任何添加或删除数组元素的方法。由于这些原因，除了像SHA256这类需要处理特定大小数组的特例外，数组依然很少用作函数参数；相反，我们一般使用slice来替代数组。</p> 
<h3><a id="slice_214"></a>slice</h3> 
<p>Slice（切片）代表变长的序列，序列中每个元素都有相同的类型。一个slice类型一般写作[]T，其中T代表slice中元素的类型；slice的语法和数组很像，只是没有固定长度。</p> 
<p>一个slice由三个部分构成：<strong>指针、长度和容量</strong>。指针指向第一个slice元素对应的底层数组元素的地址，要注意的是slice的第一个元素并不一定就是数组的第一个元素。长度对应slice中元素的数目；长度不能超过容量，容量一般是从slice的开始位置到底层数据的结尾位置。内置的len和cap函数分别返回slice的长度和容量，即 <code>len(x)</code> 和 <code>cap(x)</code>。</p> 
<p>​</p> 
<p>下面的x，就是个slice，类型是 <code>[]int</code>，长度和容量都是5。就是没有直接指明序列的长度。会隐式地创建一个合适大小的数组，然后slice的指针指向底层的数组。</p> 
<pre><code class="prism language-go">x <span class="token operator">:=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">int</span><span class="token punctuation">{<!-- --></span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">}</span>
</code></pre> 
<p>内置的make函数创建一个指定元素类型、长度和容量的slice。容量部分可以省略，在这种情况下，容量将等于长度。（用 make 就是把相应需要的空间创建出来了）</p> 
<pre><code class="prism language-go"><span class="token function">make</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span>T<span class="token punctuation">,</span> <span class="token builtin">len</span><span class="token punctuation">)</span>
<span class="token function">make</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span>T<span class="token punctuation">,</span> <span class="token builtin">len</span><span class="token punctuation">,</span> <span class="token builtin">cap</span><span class="token punctuation">)</span> <span class="token comment">// same as make([]T, cap)[:len]</span>
</code></pre> 
<p>在底层，make创建了一个匿名的数组变量，然后返回一个slice；只有通过返回的slice才能引用底层匿名的数组变量。在第一种语句中，slice是整个数组的view。在第二个语句中，slice只引用了底层数组的前len个元素，但是容量将包含整个的数组。额外的元素是留给未来的增长用的。</p> 
<br> 
<p>多个slice之间可以共享底层的数据，并且引用的数组部分区间可能重叠。</p> 
<p>​slice的切片操作s[i:j]，其中0 ≤ i≤ j≤ cap(s)，用于创建一个新的slice，引用s的从第i个元素开始到第j-1个元素的子序列。就是新的和旧的的重叠部分其实是同一部分，底层都是共享之前的底层数组，因此这种操作都是常量时间复杂度。如果切片操作超出cap(s)的上限将导致一个panic异常，但是超出len(s)则是意味着扩展了slice，因为新slice的长度会变大。</p> 
<pre><code class="prism language-go">	x <span class="token operator">:=</span> <span class="token punctuation">[</span><span class="token number">5</span><span class="token punctuation">]</span><span class="token builtin">int</span><span class="token punctuation">{<!-- --></span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">}</span>
	y <span class="token operator">:=</span> x<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">:</span><span class="token punctuation">]</span> 	<span class="token comment">//2,3,4,5</span>
	y<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">100</span> 	<span class="token comment">//y：2,3,100,5，x：1,2,3,100,5</span>
</code></pre> 
<p>在Go语言中，所有的函数参数都是值拷贝传入的，函数参数将不再是函数调用时的原始变量。但是因为slice值包含指向第一个slice元素的指针，因此向函数传递slice将允许在函数内部修改底层数组的元素。换句话说，复制一个slice只是对底层的数组创建了一个新的slice别名。也就是往函数里传slice的话是不需要限定长度的，不用传指针，直接传值的话也能更新到原slice上。</p> 
<pre><code class="prism language-go"><span class="token keyword">func</span> <span class="token function">tmp</span><span class="token punctuation">(</span>x <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">int</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
	x<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">100</span>
<span class="token punctuation">}</span>
	y <span class="token operator">:=</span> x<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">:</span><span class="token punctuation">]</span>
	<span class="token function">tmp</span><span class="token punctuation">(</span>y<span class="token punctuation">)</span>
	fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>y<span class="token punctuation">)</span>

<span class="token comment">//y：[100 3 4 5]</span>
<span class="token comment">//x：[1 100 3 4 5]</span>
</code></pre> 
<p>slice 之间不能比较。一个零值的slice等于nil。一个nil值的slice并没有底层数组。一个nil值的slice的长度和容量都是0。如果你需要测试一个slice是否是空的，使用len(s) == 0来判断，而不应该用s == nil来判断。</p> 
<p>内置的append函数用于向slice追加元素。x 和 y 在底层是用的同样的空间。因为是让 y 等于 append 的结果，append 相当于是返回在原本的基础上变化后的一个切片，原本的是在底层上变化的，切片变量的长度什么的是没有直接变化的。x 相当于长度没有变化，但实际在底层的第 4 个位置上存的就是10。显示出什么要看对应的长度实际是什么，有没有变化。</p> 
<p><strong>append 里是另外开一个slice</strong>。先处理长度，获取原本slice的长度len，让 len + 1，<strong>如果加完小于 cap</strong>，就直接让新 slice 为原本slice的相应部分，然后再把新位置的值赋上去，<strong>底层就还是一样的</strong>；<strong>加完大于 cap，就要扩充cap</strong>，用make给新slice赋相应的len和cap，还得把原先的值复制过来，再把新位置的值赋上去。<strong>有扩充cap的话，就是另外开的空间，新的slice的底层就跟旧slice的不一样了。</strong></p> 
<p>即每次调用appendInt函数，必须先检测slice底层数组是否有足够的容量来保存新添加的元素。<strong>如果有足够空间的话，直接扩展slice（依然在原有的底层数组之上），将新添加的y元素复制到新扩展的空间，并返回slice</strong>。因此，输入的x和输出的z共享相同的底层数组。如果没有足够的增长空间的话，appendInt函数则会先分配一个足够大的slice用于保存新的结果，先将输入的x复制到新的空间，然后添加y元素。结果z和输入的x引用的将是不同的底层数组。</p> 
<pre><code class="prism language-go">	x <span class="token operator">:=</span> <span class="token function">make</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">int</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">)</span>
	fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span>
	y <span class="token operator">:=</span> <span class="token function">append</span><span class="token punctuation">(</span>x<span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">)</span>
	fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span> <span class="token comment">//[0 0 0]</span>
	fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>y<span class="token punctuation">)</span> <span class="token comment">//[0 0 0 10]</span>
	x <span class="token operator">=</span> <span class="token function">append</span><span class="token punctuation">(</span>x<span class="token punctuation">,</span> <span class="token number">6</span><span class="token punctuation">)</span>
	fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span> <span class="token comment">//[0 0 0 6]</span>
	fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>y<span class="token punctuation">)</span> <span class="token comment">//[0 0 0 6]</span>
</code></pre> 
<h3><a id="map_288"></a>map</h3> 
<p>一个map就是一个哈希表的引用，map类型可以写为map[K]V，其中K和V分别对应key和value。map中所有的key都有相同的类型，所有的value也有着相同的类型，但是key和value之间可以是不同的数据类型。其中K对应的key必须是支持==比较运算符的数据类型，所以map可以通过测试key是否相等来判断是否已经存在。</p> 
<p>​内置的make函数可以创建一个map。（这样才能有初始的空间）</p> 
<pre><code class="prism language-go">ages <span class="token operator">:=</span> <span class="token function">make</span><span class="token punctuation">(</span><span class="token keyword">map</span><span class="token punctuation">[</span><span class="token builtin">string</span><span class="token punctuation">]</span><span class="token builtin">int</span><span class="token punctuation">)</span> <span class="token comment">// mapping from strings to ints</span>
</code></pre> 
<p>没有用make创建空间的话，就会初始化成零值。map类型的零值是nil，也就是没有引用任何哈希表。</p> 
<pre><code class="prism language-go"><span class="token keyword">var</span> ages <span class="token keyword">map</span><span class="token punctuation">[</span><span class="token builtin">string</span><span class="token punctuation">]</span><span class="token builtin">int</span>
fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>ages <span class="token operator">==</span> <span class="token boolean">nil</span><span class="token punctuation">)</span>    <span class="token comment">// "true"</span>
fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token function">len</span><span class="token punctuation">(</span>ages<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token comment">// "true"</span>
</code></pre> 
<p>map上的大部分操作，包括查找、删除、len和range循环都可以安全工作在nil值的map上，它们的行为和一个空的map类似。但是向一个nil值的map存入元素将导致一个panic异常。所以就是在向map存数据前必须先创建map。</p> 
<p>使用内置的delete函数可以删除元素：</p> 
<pre><code class="prism language-go"><span class="token function">delete</span><span class="token punctuation">(</span>ages<span class="token punctuation">,</span> <span class="token string">"alice"</span><span class="token punctuation">)</span> <span class="token comment">// remove element ages["alice"]</span>
</code></pre> 
<p>所有这些操作是安全的，即使这些元素不在map中也没有关系；如果一个查找失败将返回value类型对应的零值，例如，即使map中不存在“bob”下面的代码也可以正常工作，因为ages[“bob”]失败时将返回0。</p> 
<pre><code class="prism language-go">ages<span class="token punctuation">[</span><span class="token string">"bob"</span><span class="token punctuation">]</span> <span class="token operator">=</span> ages<span class="token punctuation">[</span><span class="token string">"bob"</span><span class="token punctuation">]</span> <span class="token operator">+</span> <span class="token number">1</span> <span class="token comment">// happy birthday!</span>
</code></pre> 
<br> 
<p>通过key作为索引下标来访问map将产生一个value。如果key在map中是存在的，那么将得到与key对应的value；如果key不存在，那么将得到value对应类型的零值。但是要区分这个零值是不是真的有存的，就得用两个返回结果：</p> 
<pre><code class="prism language-go">age<span class="token punctuation">,</span> ok <span class="token operator">:=</span> ages<span class="token punctuation">[</span><span class="token string">"bob"</span><span class="token punctuation">]</span>
<span class="token keyword">if</span> age<span class="token punctuation">,</span> ok <span class="token operator">:=</span> ages<span class="token punctuation">[</span><span class="token string">"bob"</span><span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token operator">!</span>ok <span class="token punctuation">{<!-- --></span> <span class="token comment">/* ... */</span> <span class="token punctuation">}</span>
</code></pre> 
<br> 
<p>map中的元素并不是一个变量，禁止对map的元素进行取址操作。</p> 
<pre><code class="prism language-go"><span class="token boolean">_</span> <span class="token operator">=</span> <span class="token operator">&amp;</span>ages<span class="token punctuation">[</span><span class="token string">"bob"</span><span class="token punctuation">]</span> <span class="token comment">// compile error: cannot take address of map element</span>
</code></pre> 
<p>禁止对map元素取址的原因是map可能随着元素数量的增长而重新分配更大的内存空间，从而可能导致之前的地址无效。</p> 
<br> 
<p>要想遍历map中全部的key/value对的话，可以使用range风格的for循环实现，和之前的slice遍历语法类似。</p> 
<p>Map的迭代顺序是不确定的，并且不同的哈希函数实现可能导致不同的遍历顺序。在实践中，遍历的顺序是随机的，每一次遍历的顺序都不相同。如果需要有序，就要把所有的key拿出来在slice或者数组里排序，然后按遍历数组的顺序来遍历map。</p> 
<p>​ <br> Go语言中并没有提供一个set类型，但是map中的key也是不相同的，可以用map实现类似set的功能。</p> 
<p>有时候我们需要一个map或set的key是slice类型，但是map的key必须是可比较的类型，但是slice并不满足这个条件。不过，我们可以通过两个步骤绕过这个限制。第一步，定义一个辅助函数k，将slice转为map对应的string类型的key，确保只有x和y相等时k(x) == k(y)才成立。然后创建一个key为string类型的map，在每次对map操作时先用k辅助函数将slice转化为string类型。这个辅助函数可以利用 fmt.Sprintf。</p> 
<p>​Map的value类型也可以是一个聚合类型，比如是一个map或slice。</p> 
<h3><a id="_356"></a>结构体</h3> 
<p><code>type …… struct {}</code></p> 
<p>结构体变量的成员可以通过点操作符访问，或者是对成员取地址，然后通过指针访问。</p> 
<p>点操作符也可以和指向结构体的指针一起工作：</p> 
<pre><code class="prism language-go"><span class="token keyword">var</span> employeeOfTheMonth <span class="token operator">*</span>Employee <span class="token operator">=</span> <span class="token operator">&amp;</span>dilbert
employeeOfTheMonth<span class="token punctuation">.</span>Position <span class="token operator">+=</span> <span class="token string">" (proactive team player)"</span>
</code></pre> 
<p>相当于下面语句</p> 
<pre><code class="prism language-go"><span class="token punctuation">(</span><span class="token operator">*</span>employeeOfTheMonth<span class="token punctuation">)</span><span class="token punctuation">.</span>Position <span class="token operator">+=</span> <span class="token string">" (proactive team player)"</span>
</code></pre> 
<br> 
<p>如果结构体成员名字是以大写字母开头的，那么该成员就是导出的；这是Go语言导出规则决定的。一个结构体可能同时包含导出和未导出的成员。</p> 
<p>结构体类型的零值是每个成员都是零值。通常会将零值作为最合理的默认值。可以指定成员来初始化。</p> 
<pre><code class="prism language-go">anim <span class="token operator">:=</span> GIF<span class="token punctuation">{<!-- --></span>LoopCount<span class="token punctuation">:</span> nframes<span class="token punctuation">}</span>
</code></pre> 
<p>​</p> 
<p>如果要在函数内部修改结构体成员的话，用指针传入是必须的；因为<strong>在Go语言中，所有的函数参数都是值拷贝传入的，函数参数将不再是函数调用时的原始变量。</strong></p> 
<p>可以用下面的写法来创建并初始化一个结构体变量，并返回结构体的地址：</p> 
<pre><code class="prism language-go">pp <span class="token operator">:=</span> <span class="token operator">&amp;</span>Point<span class="token punctuation">{<!-- --></span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">}</span>
</code></pre> 
<p>它和下面的语句是等价的</p> 
<pre><code class="prism language-go">pp <span class="token operator">:=</span> <span class="token function">new</span><span class="token punctuation">(</span>Point<span class="token punctuation">)</span>
<span class="token operator">*</span>pp <span class="token operator">=</span> Point<span class="token punctuation">{<!-- --></span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">}</span>
</code></pre> 
<p>直接用 <code>var x *Point</code>的话相当于这个point的指针指向的空间还没开出来，之后直接对x指向的point赋值的话会出问题。所以要么得new一个指向的空间出来，要么给x赋另一个指针的值。</p> 
<p>两个结构体将可以使用==或!=运算符进行比较，一一比较两个结构体的每个成员。可比较的结构体类型和其他可比较的类型一样，可以用于map的key类型。</p> 
<p>​Go语言有一个特性让我们只声明一个成员对应的数据类型而不指名成员的名字；这类成员就叫匿名成员。匿名成员的数据类型必须是命名的类型或指向一个命名的类型的指针。</p> 
<p>Circle里有一个匿名成员Point。我们可以说Point类型被嵌入到了Circle结构体。这样 Circle 里就可以直接访问 Point 里的xy，就不用再通过所给的 Point 的名字。要初始化的话，就没法通过Point的名字初始化，只能 <code>Circle{Point{8, 8}, 5}</code>。</p> 
<p>因为匿名成员也有一个隐式的名字，因此不能同时包含两个类型相同的匿名成员，这会导致名字冲突。外层的结构体不仅仅是获得了匿名成员类型的所有成员，而且也获得了该类型导出的全部的方法。</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/65644cb8a47118c82e31140535fc4409/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">VSCODE 全部保存</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/b066af092108aa90c659691f9f42d85f/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">Go语言学习-基本</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>