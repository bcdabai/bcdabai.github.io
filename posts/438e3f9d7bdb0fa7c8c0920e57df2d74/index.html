<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>n个数依次入栈，出栈顺序有多少种？ - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="n个数依次入栈，出栈顺序有多少种？" />
<meta property="og:description" content="参考网址：参考1 ，参考2
原题 有一个容量足够大的栈，n个元素以一定的顺序入栈，出栈顺序有多少种？
比如，AB两个元素，入栈顺序为AB，出栈情况有两种：
（1）入A，出A，入B，出B，出栈顺序为AB；
（2）入A，入B，出B，出A，出栈顺序为BA。
因此，2个元素时，结果为2。
分析：设f(n)为“n个元素以一定的顺序入栈，出栈顺序的种类数”。显然f(1)=1,f(2)=2。我们现在来分析一般情况。一般情况下，我们可以按照“第一个入栈的元素，在出栈序列中的位置”作为分类手段。
举个例子，我们假设入栈元素为A，B，C，D。我们按照“A在出栈序列中的位置”分类讨论：
（1）当A第一个出栈时，A先进，然后马上出栈。这种情况下，共有“BCD出栈顺序的种类数”种方案。也就是f(n-1)。
（2）当A第二个出栈时，A先进，B再进，之后B需要马上出来（这样才能确保A排第二）。此时共有f(n-2)种方案。
（3）当A第三个出栈时，A先进，之后只要确保排在A后面两个的元素比A先出即可。此时共有f(2)*f(n-3)种方案。f(2)是指“BC入栈出栈顺序的种类数”，f(n-3)是指”D入栈出栈的种类数”。
……
分析到这里，规律就很显然了。
从第一项开始，分别是第一个入栈元素在第i&#43;1个出栈的情况数。
上式中，令f(0)=1 。
这个实际上是卡特兰数（Catalan number，又称卡塔兰数）。
若编程实现，需要维护一个一维数组，时间复杂度为O(n^2)。（递归实现的时间复杂度太高）。
卡塔兰数的通项公式为h(n)=C(2n,n)-C(2n,n&#43;1)(n=0,1,2,...)。
元素A、B、C、D依次进栈,写出所有可能的出栈序列
应该有14种情况
A第一个出栈：ABCD;ACBD;ACDB;ABDC;ADCB;
A第二个出栈：BACD;BADC;
A第三个出栈：CBAD;BCAD;
A第四个出栈：BCDA;CBDA;CDBA;BDCA;DCBA.
卡特兰数 卡特兰数前几项为 : 1, 1, 2, 5, 14, 42, 132, 429, 1430, 4862, 16796, 58786, 208012, 742900, 2674440, 9694845, 35357670, 129644790, 477638700, 1767263190, 6564120420, 24466267020, 91482563640, 343059613650, 1289904147324, 4861946401452, ...
令h(0)=1,h(1)=1，catalan数满足递推式：　h(n)= h(0)*h(n-1)&#43;h(1)*h(n-2) &#43; ... &#43; h(n-1)h(0) (n&gt;=2)
例如：h(2)=h(0)*h(1)&#43;h(1)*h(0)=1*1&#43;1*1=2　h(3)=h(0)*h(2)&#43;h(1)*h(1)&#43;h(2)*h(0)=1*2&#43;1*1&#43;2*1=5　另类递推式：　h(n)=h(n-1)*(4*n-2)/(n&#43;1);　递推关系的解为：　h(n)=C(2n,n)/(n&#43;1) (n=1,2,3,." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/438e3f9d7bdb0fa7c8c0920e57df2d74/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2018-08-28T15:56:50+08:00" />
<meta property="article:modified_time" content="2018-08-28T15:56:50+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">n个数依次入栈，出栈顺序有多少种？</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p>参考网址：<a href="https://blog.csdn.net/lcytrl/article/details/8046140">参考1</a> ，<a href="https://blog.csdn.net/qq_26286193/article/details/80216479">参考2</a></p> 
<h3><strong>原题</strong></h3> 
<p>有一个容量足够大的栈，n个元素以一定的顺序入栈，出栈顺序有多少种？</p> 
<p>比如，AB两个元素，入栈顺序为AB，出栈情况有两种：</p> 
<p>（1）入A，出A，入B，出B，出栈顺序为AB；</p> 
<p>（2）入A，入B，出B，出A，出栈顺序为BA。</p> 
<p>因此，2个元素时，结果为2。</p> 
<p> </p> 
<p>分析：设f(n)为“n个元素以一定的顺序入栈，出栈顺序的种类数”。显然f(1)=1,f(2)=2。我们现在来分析一般情况。一般情况下，我们可以按照“第一个入栈的元素，在出栈序列中的位置”作为分类手段。</p> 
<p>举个例子，我们假设入栈元素为A，B，C，D。我们按照“A在出栈序列中的位置”分类讨论：</p> 
<p>（1）当A第一个出栈时，A先进，然后马上出栈。这种情况下，共有“BCD出栈顺序的种类数”种方案。也就是f(n-1)。</p> 
<p>（2）当A第二个出栈时，A先进，B再进，之后<strong>B需要马上出来（这样才能确保A排第二）</strong>。此时共有f(n-2)种方案。</p> 
<p>（3）当A第三个出栈时，A先进，之后只要确保排在A后面两个的元素比A先出即可。此时共有f(2)*f(n-3)种方案。f(2)是指“BC入栈出栈顺序的种类数”，f(n-3)是指”D入栈出栈的种类数”。</p> 
<p>……</p> 
<p>分析到这里，规律就很显然了。</p> 
<p><img alt="" class="has" src="https://images2.imgbox.com/4c/94/pw9yM4FQ_o.png"></p> 
<p>从第一项开始，分别是第一个入栈元素在第i+1个出栈的情况数。</p> 
<p>上式中，令f(0)=1 。</p> 
<p>这个实际上是卡特兰数（Catalan number，又称卡塔兰数）。</p> 
<p>若编程实现，需要维护一个一维数组，时间复杂度为O(n^2)。（递归实现的时间复杂度太高）。</p> 
<p>卡塔兰数的通项公式为h(n)=C(2n,n)-C(2n,n+1)(n=0,1,2,...)。</p> 
<p> </p> 
<p><strong>元素A、B、C、D依次进栈,写出所有可能的出栈序列</strong></p> 
<p>应该有14种情况<br> A第一个出栈：ABCD;ACBD;ACDB;ABDC;ADCB;</p> 
<p>A第二个出栈：BACD;BADC;</p> 
<p>A第三个出栈：CBAD;BCAD;</p> 
<p>A第四个出栈：BCDA;CBDA;CDBA;BDCA;DCBA.</p> 
<p> </p> 
<h3>卡特兰数</h3> 
<p>　　卡特兰数前几项为 : 1, 1, 2, 5, 14, 42, 132, 429, 1430, 4862, 16796, 58786, 208012, 742900, 2674440, 9694845, 35357670, 129644790, 477638700, 1767263190, 6564120420, 24466267020, 91482563640, 343059613650, 1289904147324, 4861946401452, ...</p> 
<p> </p> 
<p>令h(0)=1,h(1)=1，catalan数满足递推式：　　h(n)= h(0)*h(n-1)+h(1)*h(n-2) + ... + h(n-1)h(0) (n&gt;=2)</p> 
<p>例如：h(2)=h(0)*h(1)+h(1)*h(0)=1*1+1*1=2　　</p> 
<p>h(3)=h(0)*h(2)+h(1)*h(1)+h(2)*h(0)=1*2+1*1+2*1=5　　</p> 
<p>另类递推式：　　h(n)=h(n-1)*(4*n-2)/(n+1);　　</p> 
<p>递推关系的解为：　　h(n)=C(2n,n)/(n+1) (n=1,2,3,...)　　</p> 
<p>递推关系的另类解为：　　h(n)=c(2n,n)-c(2n,n+1)(n=1,2,3,...)</p> 
<p> </p> 
<p><strong>本题目的常规分析</strong></p> 
<p>首先，我们设f（n）=序列个数为n的出栈序列种数。同时，我们假定第一个出栈的序数是k。　　</p> 
<p>第一个出栈的序数k将1~n的序列分成两个序列，其中一个是1~k-1，序列个数为k-1，另外一个是k+1~n，序列个数是n-k。　　</p> 
<p>此时，我们若把k视为确定一个序数，那么根据乘法原理，f（n）的问题就等价于——序列个数为k-1的出栈序列种数乘以序列个数为n - k的出栈序列种数，即选择k这个序数的f（n）=f（k-1）×f（n-k）。而k可以选1到n，所以再根据加法原理，将k取不同值的序列种数相加，得到的总序列种数为：f（n）=f（0）f（n-1）+f（1）f（n-2）+……+f（n-1）f（0）。　　</p> 
<p>看到此处，再看看卡特兰数的递推式，答案不言而喻，即为f（n）=h（n）= C（2n,n）/（n+1）= c（2n,n）-c（2n,n+1）（n=1，2，3，……）。　　</p> 
<p>最后，令f（0）=1，f（1）=1。　　</p> 
<p><strong>非常规分析</strong>　　</p> 
<p>对于每一个数来说，必须进栈一次、出栈一次。我们把进栈设为状态‘1’，出栈设为状态‘0’。n个数的所有状态对应n个1和n个0组成的2n位二进制数。由于等待入栈的操作数按照1‥n的顺序排列、入栈的操作数b大于等于出栈的操作数a(a≤b)，因此输出序列的总数目=由左而右扫描由n个1和n个0组成的2n位二进制数，1的累计数不小于0的累计数的方案种数。　　在2n位二进制数中填入n个1的方案数为c(2n,n),不填1的其余n位自动填0。从中减去不符合要求（由左而右扫描，0的累计数大于1的累计数）的方案数即为所求。　　不符合要求的数的特征是由左而右扫描时，必然在某一奇数位2m+1位上首先出现m+1个0的累计数和m个1的累计数，此后的2(n-m)-1位上有n-m个 1和n-m-1个0。如若把后面这2(n-m)-1位上的0和1互换，使之成为n-m个0和n-m-1个1，结果得1个由n+1个0和n-1个1组成的2n位数，即一个不合要求的数对应于一个由n+1个0和n-1个1组成的排列。　　反过来，任何一个由n+1个0和n-1个1组成的2n位二进制数，由于0的个数多2个，2n为偶数，故必在某一个奇数位上出现0的累计数超过1的累计数。同样在后面部分0和1互换，使之成为由n个0和n个1组成的2n位数，即n+1个0和n-1个1组成的2n位数必对应一个不符合要求的数。　　因而不合要求的2n位数与n+1个0，n－1个1组成的排列一一对应。　　显然，不符合要求的方案数为c(2n,n+1)。由此得出输出序列的总数目=c(2n,n)-c(2n,n+1)=c(2n,n)/(n+1)=h(n+1)。　　</p> 
<p><strong>类似问题 买票找零</strong></p> 
<p>有2n个人排成一行进入剧场。入场费5元。其中只有n个人有一张5元钞票，另外n人只有10元钞票，剧院无其它钞票，问有多少中方法使得只要有10元的人买票，售票处就有5元的钞票找零？(将持5元者到达视作将5元入栈，持10元者到达视作使栈中某5元出栈)</p> 
<p><strong>最终结果：C(2n,n)-C(2n,n+1)</strong></p> 
<p><br>  </p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/7ae4369e3c66f00fe8872ad8be0de634/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">git clone下载时遇到的问题解决</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/45c47050e4843edf37da2e9c1e330eb6/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">什么是数据库的参照完整性？</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>