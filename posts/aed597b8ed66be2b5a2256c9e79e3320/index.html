<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>openvino yoloface4点模型部署 - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="openvino yoloface4点模型部署" />
<meta property="og:description" content="前言： 首先感谢大佬的开源代码
GitHub - fb029ed/yolov5_cpp_openvino: 用c&#43;&#43;实现了yolov5使用openvino的部署
以及他写的原版yolov5部署代码
C&#43;&#43;实现yolov5的OpenVINO部署_Tom Hardy的博客-CSDN博客
接下来我要在他的代码的基础上，部署yoloface四点模型代码
一、项目介绍： 在大佬原版的模型中，输出为1*3*20*20*85（其中一个detect的输出，剩下两个的20分别变为40和80。）这里85=conf(1)&#43;xywh(4)&#43;cls(80)
而我训练的模型，输出为1*3*20*20*30，30=conf(1)&#43;xywh(4)&#43;point（2*4）&#43;cls(17)。共4个关键点，17个类。
二、灰度填充 由于我的训练模型对长宽比有着较高的要求，所以对图片预处理时，不能直接resize，而要进行灰度填充。
2.1 python源码： def letterbox(img, new_shape=(640, 640), color=(114, 114, 114), auto=True, scaleFill=False, scaleup=True): #yoloface # Resize image to a 32-pixel-multiple rectangle https://github.com/ultralytics/yolov3/issues/232 shape = img.shape[:2] # current shape [height, width] if isinstance(new_shape, int): new_shape = (new_shape, new_shape) # Scale ratio (new / old) r = min(new_shape[0] / shape[0], new_shape[1] / shape[1]) if not scaleup: # only scale down, do not scale up (for better test mAP) r = min(r, 1." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/aed597b8ed66be2b5a2256c9e79e3320/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-03-01T10:07:05+08:00" />
<meta property="article:modified_time" content="2022-03-01T10:07:05+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">openvino yoloface4点模型部署</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <h2>前言：</h2> 
<p>首先感谢大佬的开源代码</p> 
<p><a href="https://github.com/fb029ed/yolov5_cpp_openvino" title="GitHub - fb029ed/yolov5_cpp_openvino: 用c++实现了yolov5使用openvino的部署">GitHub - fb029ed/yolov5_cpp_openvino: 用c++实现了yolov5使用openvino的部署</a></p> 
<p>以及他写的原版yolov5部署代码</p> 
<p><a href="https://blog.csdn.net/qq_29462849/article/details/118159988" title="C++实现yolov5的OpenVINO部署_Tom Hardy的博客-CSDN博客">C++实现yolov5的OpenVINO部署_Tom Hardy的博客-CSDN博客</a></p> 
<p>接下来我要在他的代码的基础上，部署yoloface四点模型代码</p> 
<h2>一、项目介绍：</h2> 
<p>在大佬原版的模型中，输出为1*3*20*20*85（其中一个detect的输出，剩下两个的20分别变为40和80。）这里85=conf(1)+xywh(4)+cls(80)</p> 
<p> 而我训练的模型，输出为1*3*20*20*30，30=conf(1)+xywh(4)+point（2*4）+cls(17)。共4个关键点，17个类。</p> 
<h2>二、灰度填充</h2> 
<p>由于我的训练模型对长宽比有着较高的要求，所以对图片预处理时，不能直接resize，而要进行灰度填充。</p> 
<h4>2.1 python源码：</h4> 
<pre><code class="language-python">def letterbox(img, new_shape=(640, 640), color=(114, 114, 114), auto=True, scaleFill=False, scaleup=True): #yoloface    # Resize image to a 32-pixel-multiple rectangle https://github.com/ultralytics/yolov3/issues/232    shape = img.shape[:2]  # current shape [height, width]    if isinstance(new_shape, int):        new_shape = (new_shape, new_shape)    # Scale ratio (new / old)    r = min(new_shape[0] / shape[0], new_shape[1] / shape[1])    if not scaleup:  # only scale down, do not scale up (for better test mAP)        r = min(r, 1.0)    # Compute padding    ratio = r, r  # width, height ratios    new_unpad = int(round(shape[1] * r)), int(round(shape[0] * r))    dw, dh = new_shape[1] - new_unpad[0], new_shape[0] - new_unpad[1]  # wh padding    if auto:  # minimum rectangle        dw, dh = np.mod(dw, 64), np.mod(dh, 64)  # wh padding    elif scaleFill:  # stretch        dw, dh = 0.0, 0.0        new_unpad = (new_shape[1], new_shape[0])        ratio = new_shape[1] / shape[1], new_shape[0] / shape[0]  # width, height ratios    dw /= 2  # divide padding into 2 sides    dh /= 2    if shape[::-1] != new_unpad:  # resize        img = cv2.resize(img, new_unpad, interpolation=cv2.INTER_LINEAR)    top, bottom = int(round(dh - 0.1)), int(round(dh + 0.1))    left, right = int(round(dw - 0.1)), int(round(dw + 0.1))    img = cv2.copyMakeBorder(img, top, bottom, left, right, cv2.BORDER_CONSTANT, value=color)  # add border    return img, ratio, (dw, dh)</code></pre> 
<h4>2.2 代码改写（Mat不需要在.h中单独声明）</h4> 
<p>我要将改写的C++代码写到了类Detector里。这个代码传入的参数有Mat类型。因此，我在头文件中进行如下声明</p> 
<pre><code class="language-cpp">    void letterbox(Mat&amp; inframe,Mat&amp; outframe,int x_size,int y_size);</code></pre> 
<p>在.cpp文件中如下实现</p> 
<pre><code class="language-cpp">void Detector::letterbox(Mat&amp; inframe,Mat&amp; outframe,int x_size,int y_size) //定义一个用于将图片填充成正方形的函数 参数：（输入图像，输出图像）{    int x_ori = inframe.cols;  //得到图片宽度    int y_ori = inframe.rows;  //得到图片高度    cout&lt;&lt;"宽："&lt;&lt;x_ori&lt;&lt;endl;    cout&lt;&lt;"高："&lt;&lt;y_ori&lt;&lt;endl;        float r_x = (double)x_ori/x_size; // 1280/640    float r_y = (double)y_ori/y_size; // 1024/640 确定缩放比，后图除以原图，值比较大（缩放没那么严重的）那个方向要padding(来多缩放些)    if(r_x &gt;= r_y) // 在上下方向填充 那么y的理论高度应该是x_ori/x_size*y_size    {      int y0 = y_size * x_ori / x_size;      int y_pad = (y0 - y_ori)/2;        cv::copyMakeBorder(inframe,inframe,y_pad,y_pad,0,0, cv::BORDER_CONSTANT,20);    }    else // 在上下方向填充 那么y的理论高度应该是x_ori/x_size*y_size    {        int x0 = x_size * y_ori / y_size;        int x_pad = (x0 - x_ori)/2;        cv::copyMakeBorder(inframe,inframe,0,0,x_pad,x_pad, cv::BORDER_CONSTANT,20);    }}</code></pre> 
<p>在函数中如下调用</p> 
<pre><code class="language-cpp">    letterbox(inframe,inframe,640,640);</code></pre> 
<h4>2.3 难点 如下函数如何填充灰色？（最后一个参数输入value只会有一个通道有颜色）</h4> 
<h4>2.4 疑惑：为什么我在main函数无法调用detector-&gt;lettorbox，得到osrc？（不报错，但是并没有返回osrc）</h4> 
<pre><code class="language-cpp">    Mat osrc ;    detector-&gt;letterbox(src,osrc,640,640);</code></pre> 
<p>原因：之前声明和定义时没有用&amp;，不用这个就不会传递参数！</p> 
<h4>2.5 注意：tensor前面的是图片高度，后面是图片宽度</h4> 
<h4>2.6 重点(坑了我一整天)：</h4> 
<pre><code>    int s[3] = {40,20,80};   </code></pre> 
<p>这一层detect探头的顺序是40，20，80，不是这个顺序的话，输出的结果不但是错误的，而且有2-3种不同的错误结果，每次运行不一样,不知道为什么错误结果还不同。</p> 
<h4>2.7 关于vector</h4> 
<p>一定要分清vector和他存储的元素。头文件没有单独定义vector，但是在声明函数的时候变量处要写vector，而且要加&amp;，如下</p> 
<pre><code class="language-cpp">    bool parse_yolov5(const Blob::Ptr &amp;blob,int net_grid,float cof_threshold,        vector&lt;Rect&gt;&amp; o_rect,vector&lt;float&gt;&amp; o_rect_cof,vector&lt;Four_point&gt;&amp; point_list);</code></pre> 
<h4>2.8 遇到问题：输出结果如下</h4> 
<p><img src="https://images2.imgbox.com/39/b7/8dHR2kIg_o.jpg" alt="watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA6ZWc6Iqx5rC05pyI55CJ55KD55uP,size_7,color_FFFFFF,t_70,g_se,x_16"></p> 
<p> 框没有问题，但是点非常的狂放不羁。</p> 
<p>原因：</p> 
<pre><code>                four_Point.cls = cls_id;                four_Point.x1 = x1 * anchors[n * 2] + j * 640.0f / net_grid;                four_Point.y1 = y1 * anchors[n * 2 + 1] + i * 640.0f / net_grid;                four_Point.x2 = x2 * anchors[n * 2] + j * 640.0f / net_grid;                four_Point.y2 = y2 * anchors[n * 2 + 1] + i * 640.0f / net_grid;                four_Point.x3 = x3 * anchors[n * 2] + j * 640.0f / net_grid;                four_Point.y3 = y3 * anchors[n * 2 + 1] + i * 640.0f / net_grid;                four_Point.x4 = x4 * anchors[n * 2] + j * 640.0f / net_grid;                four_Point.y4 = y4 * anchors[n * 2 + 1] + i * 640.0f / net_grid;</code></pre> 
<p>上面这段代码我无意中多加了个括号，导致差距被放大了16倍。</p> 
<p> </p> 
<p> </p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/58fee8bef63df2fd1bae9934edb6cc53/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">精选 30 个 C&#43;&#43; 面试题（含解析）</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/3c7e3a453c9e3c55db3532f7f3453bb9/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">pod重启策略和状态解释</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>