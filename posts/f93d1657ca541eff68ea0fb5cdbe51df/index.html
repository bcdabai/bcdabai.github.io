<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>多线程的同步与互斥 - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="多线程的同步与互斥" />
<meta property="og:description" content="当多个控制线程共享相同的内存时，要确保对数据访问的正确性，就需要做线程的同步与互斥工作。先看下面这个例子：
为什么要进行线程的同步与互斥 #include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; #include &lt;unistd.h&gt; #include &lt;pthread.h&gt; #include &lt;signal.h&gt; size_t count = 0; void ModifyCount() { &#43;&#43;count; } void* ThreadEntry(void *arg) { (void)arg; for(size_t i = 0; i &lt; 10000; &#43;&#43;i){ ModifyCount(); } return NULL; } int main() { pthread_t tid1, tid2; pthread_create(&amp;tid1, NULL, ThreadEntry, NULL); pthread_create(&amp;tid2, NULL, ThreadEntry, NULL); pthread_join(tid1, NULL); pthread_join(tid2, NULL); printf(&#34;count: %ld\n&#34;, count); return 0; } 我们让两个线程同时对一个全局变量做 &#43;&#43; 操作，各自增加 10000次，如果程序执行无误，结果应该是 20000，实际上运行结果如下： 我们让该程序执行了多次，发现只有两次的结果正确，而其他的结果都超出了我们的预期，原因在哪呢？ 我看看看&#43;&#43; 操作的汇编代码： 对 count 的增加有三步：" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/f93d1657ca541eff68ea0fb5cdbe51df/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2018-03-17T17:53:28+08:00" />
<meta property="article:modified_time" content="2018-03-17T17:53:28+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">多线程的同步与互斥</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <blockquote> 
 <p>当多个控制线程共享相同的内存时，要确保对数据访问的正确性，就需要做线程的同步与互斥工作。先看下面这个例子：</p> 
</blockquote> 
<h5 id="为什么要进行线程的同步与互斥"><strong>为什么要进行线程的同步与互斥</strong></h5> 
<pre class="prettyprint"><code class="language-c hljs "><span class="hljs-preprocessor">#include &lt;stdio.h&gt;</span>
<span class="hljs-preprocessor">#include &lt;stdlib.h&gt;</span>
<span class="hljs-preprocessor">#include &lt;unistd.h&gt;</span>
<span class="hljs-preprocessor">#include &lt;pthread.h&gt;</span>
<span class="hljs-preprocessor">#include &lt;signal.h&gt;</span>

size_t count = <span class="hljs-number">0</span>;

<span class="hljs-keyword">void</span> ModifyCount()
{
    ++count;
}

<span class="hljs-keyword">void</span>* ThreadEntry(<span class="hljs-keyword">void</span> *arg)
{
    (<span class="hljs-keyword">void</span>)arg;
    <span class="hljs-keyword">for</span>(size_t i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10000</span>; ++i){
        ModifyCount();
    }
    <span class="hljs-keyword">return</span> NULL;
}

<span class="hljs-keyword">int</span> main()
{
    pthread_t tid1, tid2;

    pthread_create(&amp;tid1, NULL, ThreadEntry, NULL);
    pthread_create(&amp;tid2, NULL, ThreadEntry, NULL);

    pthread_join(tid1, NULL);
    pthread_join(tid2, NULL);

    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"count: %ld\n"</span>, count);

    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}</code></pre> 
<p>我们让两个线程同时对一个全局变量做 <code>++</code> 操作，各自增加 10000次，如果程序执行无误，结果应该是 20000，实际上运行结果如下： <br> <img src="https://images2.imgbox.com/60/44/q1hUD2a3_o.jpg" alt="这里写图片描述" title=""></p> 
<p>我们让该程序执行了多次，发现只有两次的结果正确，而其他的结果都超出了我们的预期，原因在哪呢？ <br> 我看看看<code>++</code> 操作的汇编代码： <br> <img src="https://images2.imgbox.com/60/73/FDCX1hxL_o.jpg" alt="这里写图片描述" title=""> <br> 对 count 的增加有三步：</p> 
<blockquote> 
 <ul><li>将 count 移至寄存器中</li><li>给寄存器中的值加1</li><li>再将寄存器中的值移回count</li></ul> 
</blockquote> 
<p>显然，对count的增加并不是一个原子操作，如果两个线程同时访问count，就可能会出现下面这种情况：</p> 
<blockquote> 
 <ul><li><strong>线程1</strong>将count的值移至寄存器（count = 0，eax1 = 0）；</li><li><strong>线程1</strong>对寄存器中的值++（count = 0， eax1 = 1）；</li><li><strong>线程2</strong>拿到count的值（count = 0， eax2 = 0）；</li><li><strong>线程1</strong>将寄存器中的值写回count（count = 1，eax1 = 1）；</li><li><strong>线程2</strong>对寄存器中的值++（count = 1， eax2 = 1）；</li><li><strong>线程2</strong>将寄存器中的值写入count（count = 1， eax2 = 1）。</li></ul> 
</blockquote> 
<p>此时，看似两个线程对 count 各加了一次，实际上，count 的值只被加了一次，如何解决这种问题呢？下面介绍几种方法。</p> 
<h5 id="mutex互斥量"><strong>mutex互斥量</strong></h5> 
<p>可以使用 <code>pthread</code> 的护齿接口来保护数据，确保同一时间只有一个线程访问数据。互斥量（mutex）从本质上说是一把锁，在访问共享资源前对互斥量进行加锁，在访问完之后解锁。对互斥量进行加锁之后，任何试图对互斥量加锁的操作都会被阻塞，直到当前线程释放该互斥锁。如果释放互斥量时，有一个以上的线程被阻塞，那么该锁上的线程都会变为运行状态，其中第一个变为运行状态的线程就可以申请到互斥量并对其加锁。</p> 
<p><strong>互斥量的初始化</strong> <br> 方法一，静态分配：</p> 
<pre class="prettyprint"><code class=" hljs fix"><span class="hljs-attribute">pthread_mutex mutex </span>=<span class="hljs-string"> PTHREAD_MUTEX_INITIALIZER;</span></code></pre> 
<p>方法二，动态分配：</p> 
<pre class="prettyprint"><code class="language-c hljs "><span class="hljs-preprocessor">#include &lt;pthread.h&gt;</span>
<span class="hljs-keyword">int</span> pthread_mutex_init(pthread_mutex_t *<span class="hljs-keyword">restrict</span> mutex,
           <span class="hljs-keyword">const</span> pthread_mutexattr_t *<span class="hljs-keyword">restrict</span> attr);</code></pre> 
<p>其中 <code>pthread_mutex_t</code> 是一个表示互斥量的<strong>联合体</strong>类型，函数的第一个参数是要初始化的互斥量，第二个参数是要设置的互斥量的属性，参数二为空则表示使用默认的属性。</p> 
<p>静态初始化的互斥量不需要销毁，而对于动态初始化的互斥量则需要销毁，其接口函数如下：</p> 
<pre class="prettyprint"><code class="language-c hljs "><span class="hljs-preprocessor">#include &lt;pthread.h&gt;</span>
<span class="hljs-keyword">int</span> pthread_mutex_destroy(pthread_mutex_t *mutex);</code></pre> 
<p>参数为要销毁的互斥量，上面的初始化和销毁的函数执行成功返回 0，出错返回错误码。</p> 
<p>下面是对互斥量的加锁和解锁函数：</p> 
<pre class="prettyprint"><code class="language-c hljs "><span class="hljs-preprocessor">#include &lt;pthread.h&gt;</span>
<span class="hljs-keyword">int</span> pthread_mutex_lock(pthread_mutex_t *mutex);
<span class="hljs-keyword">int</span> pthread_mutex_trylock(pthread_mutex_t *mutex);
<span class="hljs-keyword">int</span> pthread_mutex_unlock(pthread_mutex_t *mutex);</code></pre> 
<p>第一个函数 <code>pthread_mutex_lock</code> 对互斥量阻塞式加锁，如果互斥量已经上锁，则调用线程将则阻塞式等待，直到互斥量被解锁。<code>pthread_mutex_unlock</code> 用于解锁，如果不希望阻塞式的加锁，则使用第二个函数 <code>pthread_mutex_trylock</code> ，该函数尝试对互斥量加锁，如果互斥量未被上锁，则将互斥量锁住，否则，该函数返回 <code>EBUSY</code>。</p> 
<p>下面是对加了锁的临界资源访问的一个实例：</p> 
<pre class="prettyprint"><code class="language-c hljs "><span class="hljs-preprocessor">#include &lt;stdio.h&gt;</span>
<span class="hljs-preprocessor">#include &lt;stdlib.h&gt;</span>
<span class="hljs-preprocessor">#include &lt;unistd.h&gt;</span>
<span class="hljs-preprocessor">#include &lt;pthread.h&gt;</span>
<span class="hljs-preprocessor">#include &lt;signal.h&gt;</span>

pthread_mutex_t lock;<span class="hljs-comment">//定义互斥量</span>
size_t count = <span class="hljs-number">0</span>;

<span class="hljs-keyword">void</span> ModifyCount()
{
    pthread_mutex_lock(&amp;lock);
    ++count;
    pthread_mutex_unlock(&amp;lock);
}

<span class="hljs-keyword">void</span> MyHandler()
{
    ModifyCount();
}

<span class="hljs-keyword">void</span>* ThreadEntry(<span class="hljs-keyword">void</span> *arg)
{
    (<span class="hljs-keyword">void</span>)arg;
    <span class="hljs-keyword">for</span>(size_t i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10000</span>; ++i){
        ModifyCount();
    }
    <span class="hljs-keyword">return</span> NULL;
}

<span class="hljs-keyword">int</span> main()
{
    pthread_mutex_init(&amp;lock, NULL);<span class="hljs-comment">//初始化互斥量</span>
    pthread_t tid1, tid2;

    pthread_create(&amp;tid1, NULL, ThreadEntry, NULL);
    pthread_create(&amp;tid2, NULL, ThreadEntry, NULL);

    pthread_join(tid1, NULL);
    pthread_join(tid2, NULL);

    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"count: %ld\n"</span>, count);

    pthread_mutex_destroy(&amp;lock);<span class="hljs-comment">//销毁互斥量</span>
    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}</code></pre> 
<p>运行结果： <br> <img src="https://images2.imgbox.com/c3/4d/4TWFLUgz_o.jpg" alt="这里写图片描述" title=""></p> 
<p>我们在对 <code>count</code> 做 <code>++</code> 操作前锁住互斥量，操作完成后解锁互斥量，这样就不会在多个线程修改共享资源时出现错误了。</p> 
<p><strong>线程死锁</strong> <br> 想想下面这种情况： <br> 线程（也可以是进程）A，B各需要申请 1，2两个互斥量，此时，线程 A 得到了 1 号互斥量（即线程A已对1号互斥量加锁），它在等待互斥量 2，而线程 B 获取到了 2 号互斥量 ，它在等待 1 号互斥量，A，B两个线程既在等待对方占用的互斥量，又在占用着对方所需要的互斥量，由于这种情况造成的两个（或多个）线程都无法前进的情况称为死锁。</p> 
<p><strong>产生死锁的必要条件</strong></p> 
<blockquote> 
 <ul><li>互斥条件：资源是独占的且排他使用，进程互斥使用资源，即任意时刻一个资源只能给一个进程使用，其他进程若申请一个资源，而该资源被另一进程占有时，则申请者等待直到资源被占有者释放；</li><li>请求保持：进程每次申请它所需要的一部分资源，在申请新的资源的同时，继续占用已分配到的资源；</li><li>不可剥夺：进程所获得的资源在未使用完毕之前，不被其他进程强行剥夺，而只能由获得该资源的进程资源释放；</li><li>环路等待：在发生死锁时必然存在一个进程等待队列{P1,P2,…,Pn},其中P1等待P2占有的资源，P2等待P3占有的资源，…，Pn等待P1占有的资源，形成一个进程等待环路，环路中每一个进程所占有的资源同时被另一个申请，也就是前一个进程占有后一个进程所申请地资源。</li></ul> 
</blockquote> 
<p><strong>银行家算法避免死锁</strong> <br> 银行家算法是一种最有代表性的避免死锁的算法。在避免死锁方法中允许进程动态地申请资源，但系统在进行资源分配之前，应先计算此次分配资源的安全性，若分配不会导致系统进入不安全状态，则分配，否则等待。</p> 
<h5 id="条件变量"><strong>条件变量</strong></h5> 
<p>条件变量是线程同步可用的另一种同步机制。当某一条件满足时，线程 A 可以通知阻塞在条件变量上的线程 B ， B 所期望的条件已经满足，可以解除在条件变量上的阻塞操作，继续做其他事情。</p> 
<p><strong>条件变量 API</strong></p> 
<pre class="prettyprint"><code class=" hljs cpp"><span class="hljs-preprocessor">#include &lt;pthread.h&gt;</span>
<span class="hljs-keyword">int</span> pthread_cond_init(pthread_cond_t *<span class="hljs-keyword">restrict</span> cond,
        <span class="hljs-keyword">const</span> pthread_condattr_t *<span class="hljs-keyword">restrict</span> attr);
<span class="hljs-keyword">int</span> pthread_cond_destroy(pthread_cond_t *cond);
pthread_cond_t cond = PTHREAD_COND_INITIALIZER;
返回值：成功<span class="hljs-number">0</span>，失败返回错误码</code></pre> 
<p>第一个函数用于初始化一个条件变量，参数一为你要初始化的条件变量，参数二为条件变量的属性，为空表示使用默认属性。第二个函数用于销毁一个条件变量。 <br> 最后一行是另一种初始化条件变量的方法，这种方法用于静态分配条件变量。</p> 
<pre class="prettyprint"><code class=" hljs cpp"><span class="hljs-preprocessor">#include &lt;pthread.h&gt;</span>
<span class="hljs-keyword">int</span> pthread_cond_wait(pthread_cond_t *<span class="hljs-keyword">restrict</span> cond,
           pthread_mutex_t *<span class="hljs-keyword">restrict</span> mutex);
<span class="hljs-keyword">int</span> pthread_cond_timedwait(pthread_cond_t *<span class="hljs-keyword">restrict</span> cond,
           pthread_mutex_t *<span class="hljs-keyword">restrict</span> mutex,
           <span class="hljs-keyword">const</span> <span class="hljs-keyword">struct</span> timespec *<span class="hljs-keyword">restrict</span> abstime);
返回值：成功<span class="hljs-number">0</span>，失败返回错误码</code></pre> 
<p>第一个函数中参数 <code>cond</code> 为要等待的条件变量，参数 <code>mutex</code> 用于保护条件变量，调用者将锁住的互斥量传给函数。函数把调用线程放到等待线程的列表上，然后对互斥量解锁，这两个操作时原子操作。<code>pthread_cond_wait</code> 返回时再次锁住互斥量。第二个函数与第一个类似，知识多了一个指定等待时间的参数 <code>timeout</code>。</p> 
<pre class="prettyprint"><code class=" hljs vala"><span class="hljs-preprocessor">#include &lt;pthread.h&gt;</span>
<span class="hljs-keyword">int</span> pthread_cond_signal(pthread_cond_t *cond);</code></pre> 
<p>该函数向线程或条件变量发送信号，用于唤醒等待的线程，告诉该线程你等待的条件已经成熟。</p> 
<p>下面是一个实例：</p> 
<pre class="prettyprint"><code class=" hljs objectivec"><span class="hljs-preprocessor">#include &lt;stdio.h&gt;</span>
<span class="hljs-preprocessor">#include &lt;unistd.h&gt;</span>
<span class="hljs-preprocessor">#include &lt;pthread.h&gt;</span>

pthread_cond_t g_cond;
pthread_mutex_t g_lock;

<span class="hljs-keyword">void</span>* Entry1(<span class="hljs-keyword">void</span> *arg)
{
    (<span class="hljs-keyword">void</span>)arg;
    <span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>){
        printf(<span class="hljs-string">"pass!\n"</span>);
        pthread_cond_signal(&amp;g_cond);<span class="hljs-comment">//当传球以后再通知投球</span>
        usleep(<span class="hljs-number">678123</span>);
    }
}

<span class="hljs-keyword">void</span>* Entry2(<span class="hljs-keyword">void</span> *arg)
{
    (<span class="hljs-keyword">void</span>)arg;
    <span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>){
        pthread_cond_wait(&amp;g_cond, &amp;g_lock);<span class="hljs-comment">//等待别人给自己传球，若条件成熟，则下一步投球</span>
        printf(<span class="hljs-string">"shoot!\n"</span>);
        usleep(<span class="hljs-number">123456</span>);
    }
}

<span class="hljs-keyword">int</span> main()
{
    pthread_cond_init(&amp;g_cond, <span class="hljs-literal">NULL</span>);<span class="hljs-comment">//初始化条件变量</span>
    pthread_mutex_init(&amp;g_lock, <span class="hljs-literal">NULL</span>);

    pthread_t tid1, tid2;
    pthread_create(&amp;tid1, <span class="hljs-literal">NULL</span>, Entry1, <span class="hljs-literal">NULL</span>);
    pthread_create(&amp;tid2, <span class="hljs-literal">NULL</span>, Entry2, <span class="hljs-literal">NULL</span>);
    pthread_join(tid1, <span class="hljs-literal">NULL</span>);
    pthread_join(tid2, <span class="hljs-literal">NULL</span>);

    pthread_cond_destroy(&amp;g_cond);
    pthread_mutex_destroy(&amp;g_lock);
    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;</code></pre> 
<p>在篮球场上，投球的人需要等到别人将球传给自己，而传球的人要通知投球的人“我将球传给你了，你准备投，他们按照这样约定的顺序，擦能实现有序配合”，下面是运行结果：</p> 
<p><img src="https://images2.imgbox.com/15/1e/lNVc7Qkw_o.jpg" alt="这里写图片描述" title=""></p> 
<h5 id="posix信号量"><strong>POSIX信号量</strong></h5> 
<p>POSIX信号量也可以用于保护共享资源，以达到对共享资源的互斥访问。与 <code>systemV</code> <a href="http://blog.csdn.net/jelly_9/article/details/72921856">信号量</a>不同的是：</p> 
<blockquote> 
 <p>POSIX信号量来源于POSIX技术规范的实时扩展方案 (POSIX Realtime Extension)，常用于线程；system v信号量，常用于进程的同步。这两者非常相近，但它们使用的函数调用各不相同。前一种的头文件为<code>semaphore.h</code>，函数调用为<code>sem_init()</code>, <code>sem_wait()</code>, <code>sem_post()</code>,<code>sem_destory()</code>等等。后一种头文件为<code>&lt;sys/sem.h&gt;</code>,函数调用为<code>semctl()</code>,<code>semget()</code>,<code>semop()</code>等函数.</p> 
</blockquote> 
<p>POSIX信号量API： <br> 初始化和销毁信号量：</p> 
<pre class="prettyprint"><code class="language-c hljs "><span class="hljs-preprocessor">#include &lt;semaphore.h&gt;</span>
<span class="hljs-keyword">int</span> sem_init(sem_t *sem, <span class="hljs-keyword">int</span> pshared, <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> value);
<span class="hljs-keyword">int</span> sem_destroy(sem_t *sem);</code></pre> 
<p><code>sem</code> 为要初始化的信号量，<code>pshared</code> 为 0 表示线程间共享，非 0 表示进程间共享。 <br> <code>value</code>表示要初始化为几？</p> 
<p>等待信号量和发送信号量：</p> 
<pre class="prettyprint"><code class="language-c hljs "><span class="hljs-preprocessor">#include &lt;semaphore.h&gt;</span>
<span class="hljs-keyword">int</span> sem_wait(sem_t *sem);
<span class="hljs-keyword">int</span> sem_post(sem_t *sem);</code></pre> 
<p>如果将信号量看为一个计数器的话，那么对信号量的等待和唤醒则是对计数器的 <code>-1</code> 和 <code>+1</code> 操作。</p> 
<p>下面是用 <code>POSIX</code> 信号量重新实现的上面那个“传球-投篮”的例子：</p> 
<pre class="prettyprint"><code class=" hljs objectivec"><span class="hljs-preprocessor">#include &lt;stdio.h&gt;</span>
<span class="hljs-preprocessor">#include &lt;unistd.h&gt;</span>
<span class="hljs-preprocessor">#include &lt;pthread.h&gt;</span>
<span class="hljs-preprocessor">#include &lt;semaphore.h&gt;</span>

sem_t sem;

<span class="hljs-keyword">void</span>* Entry1(<span class="hljs-keyword">void</span> *arg)
{
    (<span class="hljs-keyword">void</span>)arg;
    <span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>){
        printf(<span class="hljs-string">"pass!\n"</span>);
        sem_post(&amp;sem);
        usleep(<span class="hljs-number">678123</span>);
    }
}

<span class="hljs-keyword">void</span>* Entry2(<span class="hljs-keyword">void</span> *arg)
{
    (<span class="hljs-keyword">void</span>)arg;
    <span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>){
        sem_wait(&amp;sem);
        printf(<span class="hljs-string">"shoot!\n"</span>);
        usleep(<span class="hljs-number">123456</span>);
    }
}

<span class="hljs-keyword">int</span> main()
{
    sem_init(&amp;sem, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>);

    pthread_t tid1, tid2;
    pthread_create(&amp;tid1, <span class="hljs-literal">NULL</span>, Entry1, <span class="hljs-literal">NULL</span>);
    pthread_create(&amp;tid2, <span class="hljs-literal">NULL</span>, Entry2, <span class="hljs-literal">NULL</span>);
    pthread_join(tid1, <span class="hljs-literal">NULL</span>);
    pthread_join(tid2, <span class="hljs-literal">NULL</span>);

    sem_destroy(&amp;sem);
    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}</code></pre> 
<p>运行结果： <br> <img src="https://images2.imgbox.com/ab/2a/34epvvxm_o.jpg" alt="这里写图片描述" title=""></p> 
<p>——完！</p> 
<hr> 
<p>【作者：果冻：<a href="http://blog.csdn.net/jelly_9">http://blog.csdn.net/jelly_9</a>】</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/7e3fac6f29cd37fdf9cf9c2c11ac5e15/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">经典卷积神经网络    之   ZFNet</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/63326c42e446e3f3bf23aa95e84307d6/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">rem与mod的区别</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>