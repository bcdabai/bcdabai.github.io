<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>python爬虫 --协程 - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="python爬虫 --协程" />
<meta property="og:description" content="目录
前言
协程的主要概念
一个简单的协程
注册协程的三种方式
使用协程的一般步骤
并发运行协程
gather与wait（此示例来自ChatAl）
aiohttp（此示例来自ChatAl）
异步上下文管理器
通过生成器理解协程
前言 爬虫是IO密集型任务，在爬取过程中需要等待网站的响应，在这个等待过程中我们可以使用并发来加快爬取的效率，实现并发的可以是多线程多进程，那为什么还要使用协程呢？
并发主要是利用程序IO操作时CPU空闲时间调用其他程序运行的方式来提高资源的利用率，但是不管是进程还是线程，切换时都会带来巨大开销，CPU内核的切换，上下文的保存和恢复等。而协程，相较线程来说更加轻量级的；它不被操作系统的内核所管理，完全由程序所控制，不需要CPU内核的切换，也能实现并发。
协程的主要概念 evenloop：事件循环中心，提供了注册，取消，回调任务和回调方法，是一个永久循环，注册函数到这个事件循环中心中，当满足某些条件时再调用此函数。
coroutine：协程，表示协程的对象类型，用async关键字声明的方法为协程方法
await：在协程方法中，await关键字会将耗时等待的操作挂起，让出控制权。如果协程在执行的时候遇到await关键字，事件循环就会将此协程挂起，转而执行别的协程，直到其他协程挂起或者执行完毕。
await后面可等待对象的类型：coroutine，task，future
可以将协程注册到事件循环中心，等待被调用。
一个简单的协程 import asyncio import time async def a(): print(&#39;suspending a&#39;) await asyncio.sleep(3) print(&#39;dead a&#39;) async def b(): print(&#39;suspending b&#39;) await asyncio.sleep(2) print(&#39;dead b&#39;) async def main(): print(f&#34;started at {time.strftime(&#39;%X&#39;)}&#34;) await a()#挂起协程a await b()#挂起协程b print(f&#34;finished at {time.strftime(&#39;%X&#39;)}&#34;) if __name__ == &#39;__main__&#39;: asyncio.run(main()) started at 10:59:25 suspending a dead a suspending b dead b finished at 10:59:30 这个程序声明了三个协程，分别是a，b，main" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/436a5f5d999575dac237eec19936135e/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-06-30T23:09:13+08:00" />
<meta property="article:modified_time" content="2023-06-30T23:09:13+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">python爬虫 --协程</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p id="main-toc"><strong>目录</strong></p> 
<p id="-toc" style="margin-left:0px;"><a href="#%E5%89%8D%E8%A8%80" rel="nofollow">前言</a></p> 
<p id="%E5%8D%8F%E7%A8%8B%E7%9A%84%E4%B8%BB%E8%A6%81%E6%A6%82%E5%BF%B5-toc" style="margin-left:0px;"><a href="#%E5%8D%8F%E7%A8%8B%E7%9A%84%E4%B8%BB%E8%A6%81%E6%A6%82%E5%BF%B5" rel="nofollow">协程的主要概念</a></p> 
<p id="%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84%E5%8D%8F%E7%A8%8B-toc" style="margin-left:0px;"><a href="#%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84%E5%8D%8F%E7%A8%8B" rel="nofollow">一个简单的协程</a></p> 
<p id="%E6%B3%A8%E5%86%8C%E5%8D%8F%E7%A8%8B%E7%9A%84%E4%B8%89%E7%A7%8D%E6%96%B9%E5%BC%8F-toc" style="margin-left:0px;"><a href="#%E6%B3%A8%E5%86%8C%E5%8D%8F%E7%A8%8B%E7%9A%84%E4%B8%89%E7%A7%8D%E6%96%B9%E5%BC%8F" rel="nofollow">注册协程的三种方式</a></p> 
<p id="%E4%BD%BF%E7%94%A8%E5%8D%8F%E7%A8%8B%E7%9A%84%E4%B8%80%E8%88%AC%E6%AD%A5%E9%AA%A4-toc" style="margin-left:0px;"><a href="#%E4%BD%BF%E7%94%A8%E5%8D%8F%E7%A8%8B%E7%9A%84%E4%B8%80%E8%88%AC%E6%AD%A5%E9%AA%A4" rel="nofollow">使用协程的一般步骤</a></p> 
<p id="%E5%B9%B6%E5%8F%91%E8%BF%90%E8%A1%8C%E5%8D%8F%E7%A8%8B-toc" style="margin-left:0px;"><a href="#%E5%B9%B6%E5%8F%91%E8%BF%90%E8%A1%8C%E5%8D%8F%E7%A8%8B" rel="nofollow">并发运行协程</a></p> 
<p id="gather%E4%B8%8Ewait%EF%BC%88%E6%AD%A4%E7%A4%BA%E4%BE%8B%E6%9D%A5%E8%87%AAChatAl%EF%BC%89-toc" style="margin-left:0px;"><a href="#gather%E4%B8%8Ewait%EF%BC%88%E6%AD%A4%E7%A4%BA%E4%BE%8B%E6%9D%A5%E8%87%AAChatAl%EF%BC%89" rel="nofollow">gather与wait（此示例来自ChatAl）</a></p> 
<p id="aiohttp%EF%BC%88%E6%AD%A4%E7%A4%BA%E4%BE%8B%E6%9D%A5%E8%87%AAChatAl%EF%BC%89-toc" style="margin-left:0px;"><a href="#aiohttp%EF%BC%88%E6%AD%A4%E7%A4%BA%E4%BE%8B%E6%9D%A5%E8%87%AAChatAl%EF%BC%89" rel="nofollow">aiohttp（此示例来自ChatAl）</a></p> 
<p id="%E5%BC%82%E6%AD%A5%E4%B8%8A%E4%B8%8B%E6%96%87%E7%AE%A1%E7%90%86%E5%99%A8-toc" style="margin-left:0px;"><a href="#%E5%BC%82%E6%AD%A5%E4%B8%8A%E4%B8%8B%E6%96%87%E7%AE%A1%E7%90%86%E5%99%A8" rel="nofollow">异步上下文管理器</a></p> 
<p id="%E9%80%9A%E8%BF%87%E7%94%9F%E6%88%90%E5%99%A8%E7%90%86%E8%A7%A3%E5%8D%8F%E7%A8%8B-toc" style="margin-left:0px;"><a href="#%E9%80%9A%E8%BF%87%E7%94%9F%E6%88%90%E5%99%A8%E7%90%86%E8%A7%A3%E5%8D%8F%E7%A8%8B" rel="nofollow">通过生成器理解协程</a></p> 
<p></p> 
<h2 id="%E5%89%8D%E8%A8%80">前言</h2> 
<blockquote> 
 <p>        爬虫是IO密集型任务，在爬取过程中需要等待网站的响应，在这个等待过程中我们可以使用并发来加快爬取的效率，实现并发的可以是多线程多进程，那为什么还要使用协程呢？</p> 
 <p>并发主要是<strong>利用程序IO操作</strong>时CPU空闲时间调用其他程序运行的方式来提高资源的利用率，但是不管是进程还是线程，切换时都会带来巨大开销，CPU内核的切换，上下文的保存和恢复等。而协程，相较线程来说更加轻量级的；它不被操作系统的内核所管理，完全由程序所控制，不需要CPU内核的切换，也能实现并发。</p> 
</blockquote> 
<h2 id="%E5%8D%8F%E7%A8%8B%E7%9A%84%E4%B8%BB%E8%A6%81%E6%A6%82%E5%BF%B5">协程的主要概念</h2> 
<p>evenloop：事件循环中心，提供了注册，取消，回调任务和回调方法，是一个永久循环，注册函数到这个事件循环中心中，当满足某些条件时再调用此函数。</p> 
<p>coroutine：协程，表示协程的对象类型，用async关键字声明的方法为协程方法</p> 
<p>await：在协程方法中，await关键字会将耗时等待的操作挂起，让出控制权。如果协程在执行的时候遇到await关键字，事件循环就会将此协程挂起，转而执行别的协程，直到其他协程挂起或者执行完毕。</p> 
<p>await后面可等待对象的类型：coroutine，task，future</p> 
<p>可以将协程注册到事件循环中心，等待被调用。</p> 
<h2 id="%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84%E5%8D%8F%E7%A8%8B">一个简单的协程</h2> 
<pre><code>import asyncio
import time
async def a():
    print('suspending a')
    await asyncio.sleep(3)
    print('dead a')
async def b():
    print('suspending b')
    await asyncio.sleep(2)
    print('dead b')
async def main():
    print(f"started at {time.strftime('%X')}")
    await a()#挂起协程a
    await b()#挂起协程b
    print(f"finished at {time.strftime('%X')}")
if __name__ == '__main__':
    asyncio.run(main())</code></pre> 
<pre><code>started at 10:59:25
suspending a
dead a
suspending b
dead b
finished at 10:59:30</code></pre> 
<blockquote> 
 <p>这个程序声明了三个协程，分别是a，b，main</p> 
 <p>可以发现都是通过<strong>async声明一个协程，并在协程方法中通过await关键字挂起耗时操作</strong></p> 
 <p>观察main协程方法，可以发现在方法中通过await挂起a，b协程(它们是可等待对象)，main方法中传递协程a和协程b，<strong>这样我们只需将main注册到事件循环中，那么协程都可以执行了</strong>。</p> 
 <p>注意：协程只用注册到事件循环中才能正常执行。</p> 
</blockquote> 
<h2 id="%E6%B3%A8%E5%86%8C%E5%8D%8F%E7%A8%8B%E7%9A%84%E4%B8%89%E7%A7%8D%E6%96%B9%E5%BC%8F">注册协程的三种方式</h2> 
<p>1、由上面的协程程序，可以发现通过<strong>asncio.run()</strong>方法可以将协程注册到事件循环中，这个方法是python3.7出现的<strong>高层API</strong>。用于运行一个协程方法并管理底层的事件循环。当然还有下面的两种方法</p> 
<p>2、</p> 
<pre><code>loop = asyncio.get_event_loop()#获取当前的事件循环

loop.run_until_complete(main())#运行协程</code></pre> 
<p>3、</p> 
<pre><code>loop=asyncio.new_event_loop()#创建一个新的事件循环

loop.run_until_complete(main())#运行协程</code></pre> 
<h2 id="%E4%BD%BF%E7%94%A8%E5%8D%8F%E7%A8%8B%E7%9A%84%E4%B8%80%E8%88%AC%E6%AD%A5%E9%AA%A4">使用协程的一般步骤</h2> 
<ol><li> <p>定义异步函数：使用<code>async</code>关键字定义一个异步函数，可以在函数名前面加上<code>async</code>修饰符。异步函数可以包含<code>await</code>关键字来等待其他的异步操作完成。</p> </li><li> <p>创建事件循环：在Python中，异步操作通常在事件循环（Event Loop）中执行。通过调用<code>asyncio.get_event_loop()</code>来获取默认的事件循环对象，或使用<code>asyncio.new_event_loop()或者</code>asyncio.run()来创建新的事件循环对象。</p> </li><li> <p>执行协程：通过<code>await</code>关键字等待协程函数的执行结果。将协程函数包装在<code>asyncio.run()</code>函数中，或使用事件循环的<code>run_until_complete()</code>方法来启动协程的执行。</p> </li></ol> 
<h2 id="%E5%B9%B6%E5%8F%91%E8%BF%90%E8%A1%8C%E5%8D%8F%E7%A8%8B">并发运行协程</h2> 
<p>根据上述的协程程序可以发现，程序运行了5秒，并没有实现并发，程序中其实是顺序运行的，那么该如何让它实现并发呢？</p> 
<p>先了解下task对象</p> 
<p>Task：Task对象用于封装一个协程函数，包括协程的各个状态，以便在事件循环中进行调度和执行。Task对象提供了一种方便、灵活和高效的方式来管理异步任务，<strong>实现并发执行</strong>，并且提供了错误处理、回调函数、取消等额外的功能。</p> 
<p>封装的函数会被自动调度执行, 函数以异步方式并发运行协程</p> 
<p>1、asyncio.create_task() 封装协程</p> 
<pre><code>import asyncio
import time
async def a():
    print('suspending a')
    await asyncio.sleep(3)
    print('dead a')
async def b():
    print('suspending b')
    await asyncio.sleep(2)
    print('dead b')
async def main():
    print(f"started at {time.strftime('%X')}")
    taska=asyncio.create_task(a())
    taskb=asyncio.create_task(b())
    await taska#挂起协程a
    await taskb#挂起协程b
    print(f"finished at {time.strftime('%X')}")
if __name__ == '__main__':
    asyncio.run(main())</code></pre> 
<pre><code>started at 11:21:34
suspending a
suspending b
dead b
dead a
finished at 11:21:37</code></pre> 
<p>运行时间3秒，由此可以协程实现并发运行了，当然将协程封装成task对象还有下面两种方式</p> 
<p>2、asncio.ensure_future :接收的参数不仅包括协程还包括Future对象或者是awaitable对象</p> 
<pre><code>import asyncio
import time
async def a():
    print('suspending a')
    await asyncio.sleep(3)
    print('dead a')
async def b():
    print('suspending b')
    await asyncio.sleep(2)
    print('dead b')
async def main():
    print(f"started at {time.strftime('%X')}")
    taska=asyncio.ensure_future(a())
    taskb=asyncio.ensure_future(b())
    await taska#挂起协程a
    await taskb#挂起协程b
    print(f"finished at {time.strftime('%X')}")
if __name__ == '__main__':
    asyncio.run(main())</code></pre> 
<p>3、loop.create_task:接收的参数为一个协程</p> 
<pre><code>import asyncio
import time
async def a():
    print('suspending a')
    await asyncio.sleep(3)
    print('dead a')
async def b():
    print('suspending b')
    await asyncio.sleep(2)
    print('dead b')
async def main():
    print(f"started at {time.strftime('%X')}")
    # taska=asyncio.create_task(a())
    # taskb=asyncio.create_task(b())
    # taska=asyncio.ensure_future(a())
    # taskb=asyncio.ensure_future(b())
    loop=asyncio.get_event_loop()
    taska=loop.create_task(a())
    taskb=loop.create_task(b())
    await taska#挂起协程a
    await taskb#挂起协程b
    print(f"finished at {time.strftime('%X')}")
if __name__ == '__main__':
    asyncio.run(main())</code></pre> 
<p>运行结果同样为3秒 如下：</p> 
<pre><code>started at 11:23:44
suspending a
suspending b
dead b
dead a
finished at 11:23:47</code></pre> 
<h2 id="gather%E4%B8%8Ewait%EF%BC%88%E6%AD%A4%E7%A4%BA%E4%BE%8B%E6%9D%A5%E8%87%AAChatAl%EF%BC%89">gather与wait（此示例来自ChatAl）</h2> 
<p>如果我们要并发运行很多协程方法并获取到结果，仅通过封装成task已经力不从心了，ok，gather和wait可以派上用场了。</p> 
<p>gather：让多个协程实现并发执行，返回值为协程的运行结果，而且它会按照输入协程的顺序返回</p> 
<p>wait：让多个协程实现并发执行，返回值有两项，第一项表示为完成任务的列表，第二项表示等待future任务完成的结果，每个任务都是task实例，可以使用task.result()获取协程返回值，此外wait还支持返回的时机。</p> 
<p>1、当使用<code>asyncio.gather()</code>函数时，可以简单地传递多个协程函数（或者其他可等待对象），然后它会同时执行这些协程，并收集它们的结果。</p> 
<pre><code>import asyncio

async def coroutine1():
    print("Coroutine 1 started")
    await asyncio.sleep(2)  # 模拟耗时操作
    print("Coroutine 1 completed")
    return "Result from Coroutine 1"

async def coroutine2():
    print("Coroutine 2 started")
    await asyncio.sleep(1)  # 模拟耗时操作
    print("Coroutine 2 completed")
    return "Result from Coroutine 2"

async def main():
    tasks = [coroutine1(), coroutine2()]
    results = await asyncio.gather(*tasks)  # 并发执行协程，并收集结果
    print("Results:", results)

asyncio.run(main())
</code></pre> 
<p>在这个例子中，我们定义了两个协程函数<code>coroutine1()</code>和<code>coroutine2()</code>。每个协程函数打印开始和完成的消息，然后使用<code>asyncio.sleep()</code>来模拟耗时操作。</p> 
<p>在<code>main()</code>函数中，我们创建一个任务列表<code>tasks</code>，包含了这两个协程函数。然后，我们使用<code>await asyncio.gather(*tasks)</code>将这些任务传递给<code>asyncio.gather()</code>函数。通过使用<code>*tasks</code>语法，我们将<strong>任务列表中的每个任务作为单独的参数传递给<code>asyncio.gather()</code>。</strong></p> 
<p><code>asyncio.gather()</code>函数会同时运行这些协程函数，并在所有协程都完成后返回结果列表。在这个示例中，我们将结果赋值给<code>results</code>变量，并打印出来。</p> 
<p>最后，我们使用<code>asyncio.run(main())</code>来运行主协程。</p> 
<p>2、wait</p> 
<p><code>asyncio.wait()</code>函数用于并发执行多个协程任务，并等待它们的完成。它接受一个可迭代的协程任务集合作为参数，并返回一个包含已完成任务集合和未完成任务集合的元组。</p> 
<pre><code>import asyncio

async def coroutine1():
    print("Coroutine 1 started")
    await asyncio.sleep(2)  # 模拟耗时操作
    print("Coroutine 1 completed")
    return "Result from Coroutine 1"

async def coroutine2():
    print("Coroutine 2 started")
    await asyncio.sleep(1)  # 模拟耗时操作
    print("Coroutine 2 completed")
    return "Result from Coroutine 2"

async def main():
    tasks = [coroutine1(), coroutine2()]
    done, pending = await asyncio.wait(tasks)  # 并发执行协程，并等待完成

    # 处理已完成的任务
    for task in done:
        result = await task  # 获取任务的结果
        print("Task result:", result)

asyncio.run(main())
</code></pre> 
<p>在这个例子中，我们定义了两个协程函数<code>coroutine1()</code>和<code>coroutine2()</code>，它们模拟了耗时的操作。</p> 
<p>在<code>main()</code>函数中，我们创建了一个任务列表<code>tasks</code>，包含了这两个协程函数。</p> 
<p>使用<code>await asyncio.wait(tasks)</code>来等待并发执行这些协程任务。<code>asyncio.wait()</code>函数返回一个元组<code>(done, pending)</code>，其中<code>done</code>是已完成的任务集合，<code>pending</code>是未完成的任务集合。</p> 
<p>我们通过遍历<code>done</code>集合，并使用<code>await task</code>获取各个任务的结果。这里的<code>task</code>是<code>asyncio.Task</code>对象，我们通过<code>await</code>关键字等待并获取任务的结果。</p> 
<p>最后，我们使用<code>asyncio.run(main())</code>来运行主协程。</p> 
<h2 id="aiohttp%EF%BC%88%E6%AD%A4%E7%A4%BA%E4%BE%8B%E6%9D%A5%E8%87%AAChatAl%EF%BC%89">aiohttp（此示例来自ChatAl）</h2> 
<p>aiohttp是一个基于asyncio的异步HTTP网络模块，他提供了服务端和客户端。在客户端中我们可以发起请求，类似于使用requests发送的一个HTTP请求。注意：requests模块不能在协程中使用，因为requests模块是同步的。</p> 
<pre><code>import aiohttp
import asyncio

async def fetch(url):
    async with aiohttp.ClientSession() as session:
        async with session.get(url) as response:
            return await response.text()

async def main():
    url = "https://api.example.com/data"  # 替换为你要请求的URL
    response = await fetch(url)
    print("Response:", response)

asyncio.run(main())
</code></pre> 
<p>在这个示例中，我们首先定义了一个fetch()函数，它使用aiohttp发送异步的HTTP GET请求。</p> 
<p>在fetch()函数中，我们使用aiohttp.ClientSession()创建一个客户端会话对象。然后，我们使用session.get(url)发送GET请求，并使用response.text()方法获取响应的文本内容。</p> 
<p>在main()函数中，我们定义了要请求的URL，然后调用fetch()函数并等待其返回响应结果。最后，我们打印出响应的内容。</p> 
<p>需要注意的是，aiohttp.ClientSession()是一个上下文管理器，使用async with语法来确保会话在请求完成后正确关闭和释放资源。</p> 
<p>最后，我们使用asyncio.run(main())来运行主协程。</p> 
<h2 id="%E5%BC%82%E6%AD%A5%E4%B8%8A%E4%B8%8B%E6%96%87%E7%AE%A1%E7%90%86%E5%99%A8">异步上下文管理器</h2> 
<p>它相当于一个协程，在异步编程中，我们可以使用<code>async with</code>语法来使用上下文管理器。上下文管理器提供了进一步管理异步任务执行的能力，并确保在进入和退出上下文时正确地处理资源分配和清理。异步上下文管理器是Python 3.7中引入的一个特性，用于在异步环境中更好地管理资源。</p> 
<h2 id="%E9%80%9A%E8%BF%87%E7%94%9F%E6%88%90%E5%99%A8%E7%90%86%E8%A7%A3%E5%8D%8F%E7%A8%8B">通过生成器理解协程</h2> 
<p>协程的实现原理是利用了生成器的特性，下面通过生成器来简单了解协程的原理</p> 
<p>这个任务实现需要三个步骤，每个步骤在处理前都通过yield交出控制权，</p> 
<pre><code>def test(data):
    print('task with data {} starter'.format(data))
    yield
    print('step one for data {} finished'.format(data))
    yield
    print('step two for data {} finished'.format(data))
    yield
    print('step over for data {} finished'.format(data))

testa=test('a')

if __name__ == '__main__':
    print(type(testa))
    next(testa)
    next(testa)
    next(testa)</code></pre> 
<ul><li>含yield关键字的函数为生成器函数</li><li>生成器函数不能被直接使用，类型为generator</li><li>调用next函数可激活生成器函数，在执行到yield关键字处，程序会将控制权交出</li><li>生成器函数在交出控制权时可以记住自己执行的位置，下次在被调用时从上次位置接着执行</li><li>再次调用next()，程序会从上次yield出开始执行直到遇到yield关键字，或者程序执行完毕抛出异常</li></ul> 
<pre><code>&lt;class 'generator'&gt;
task with data a starter
step one for data a finished
step two for data a finished
step over for data a finished
Traceback (most recent call last):
  File "d:/python/repitile/request/asnciolearning.py", line 43, in &lt;module&gt;
    next(testa)
StopIteration</code></pre> 
<p>协程调度</p> 
<pre><code>def test(data):
    print('task with data {} starter'.format(data))
    yield
    print('step one for data {} finished'.format(data))
    yield
    print('step two for data {} finished'.format(data))
    yield
    print('step over for data {} finished'.format(data))

if __name__ == '__main__':
    test_a=test('a')
    test_b=test('b')
    test_c=test('c')
    #调度协程
    next(test_a)
    next(test_a)
    next(test_a)
    
    next(test_b)
    next(test_c)
    next(test_b)
    next(test_c)
    next(test_b)
    next(test_c)</code></pre> 
<ul><li>该程序执行了三个任务，分别为tast_a，tast_b，tast_c</li><li>在程序中调度tast_a执行先执行三次，tast_b，tast_c交替执行</li><li>yield模拟了程序在遇到网络IO的情况，协程的处理方式，将该程序暂时挂起，执行其他任务。</li><li>通过人为的调用来作为事件调度器，在协程中这个角色是由事件循环(evenloop)来担任的。</li></ul> 
<pre><code>task with data a starter
step one for data a finished
step two for data a finished
task with data b starter
task with data c starter
step one for data b finished
step one for data c finished
step two for data b finished
step two for data c finished</code></pre> 
<p>好的，就到这里了，屏幕前的你真好看</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/5d9c242e955064e6852020739945c711/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">小白月赛C-方豆子</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/235925f416a8be25105ff4bdbda7da9b/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">CentOS忘记密码重置密码教程</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>