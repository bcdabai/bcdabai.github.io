<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>linux下docker使用大全 - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="linux下docker使用大全" />
<meta property="og:description" content="linux下docker使用大全
Docker 是一个开源的应用容器引擎，基于 Go 语言 并遵从 Apache2.0 协议开源。Docker 可以让开发者打包他们的应用以及依赖包到一个轻量级、可移植的容器中，然后发布到任何流行的 Linux 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口,更重要的是容器性能开销极低。
Docker 包括三个基本概念:
镜像（Image）：Docker 镜像（Image），就相当于是一个 root 文件系统。比如官方镜像 ubuntu:16.04 就包含了完整的一套 Ubuntu16.04 最小系统的 root 文件系统。
容器（Container）：镜像（Image）和容器（Container）的关系，就像是面向对象程序设计中的类和实例一样，镜像是静态的定义，容器是镜像运行时的实体。容器可以被创建、启动、停止、删除、暂停等。
仓库（Repository）：仓库可看成一个代码控制中心，用来保存镜像。
Docker CE 18.09在centos7的安装
关闭 防火墙
systemctl stop firewalld systemctl disable firewalld #查看防火墙状态
firewall-cmd --state 输出信息大概是这样的
!
关闭 SeLinux
建议在主机上禁用SELinux，让容器可以读取主机文件系统。或修改系统文件/etc/sysconfig/selinux，将SELINUX=enforcing修改成SELINUX=disabled，然后重启Linux。
关闭交换空间
关闭swap
swapoff -a yes | cp /etc/fstab /etc/fstab_bak cat /etc/fstab_bak |grep -v swap &gt; /etc/fstab free -m #配置iptable管理ipv4/6请求
vim /etc/sysctl.d/k8s.conf 添加
net.bridge.bridge-nf-call-ip6tables = 1 net." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/ee9d5b0f48730e5cafbcf4a1ad3dae3d/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2020-07-09T19:19:24+08:00" />
<meta property="article:modified_time" content="2020-07-09T19:19:24+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">linux下docker使用大全</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p><strong>linux下docker使用大全</strong></p> 
<p>Docker 是一个开源的应用容器引擎，基于 Go 语言 并遵从 Apache2.0 协议开源。Docker 可以让开发者打包他们的应用以及依赖包到一个轻量级、可移植的容器中，然后发布到任何流行的 Linux 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口,更重要的是容器性能开销极低。<br> Docker 包括三个基本概念:<br> 镜像（Image）：Docker 镜像（Image），就相当于是一个 root 文件系统。比如官方镜像 ubuntu:16.04 就包含了完整的一套 Ubuntu16.04 最小系统的 root 文件系统。<br> 容器（Container）：镜像（Image）和容器（Container）的关系，就像是面向对象程序设计中的类和实例一样，镜像是静态的定义，容器是镜像运行时的实体。容器可以被创建、启动、停止、删除、暂停等。<br> 仓库（Repository）：仓库可看成一个代码控制中心，用来保存镜像。<br> Docker CE 18.09在centos7的安装</p> 
<p>关闭 防火墙</p> 
<pre><code class="prism language-bash">systemctl stop firewalld 
systemctl disable firewalld 
</code></pre> 
<p>#查看防火墙状态</p> 
<pre><code class="prism language-bash">firewall-cmd --state 
</code></pre> 
<p>输出信息大概是这样的</p> 
<p><img src="https://images2.imgbox.com/bc/64/TGbPk6kz_o.png" alt="在这里插入图片描述">!<br> <img src="https://images2.imgbox.com/b1/ea/aTgqZWAD_o.png" alt="在这里插入图片描述"><br> 关闭 SeLinux</p> 
<p>建议在主机上禁用SELinux，让容器可以读取主机文件系统。或修改系统文件/etc/sysconfig/selinux，将SELINUX=enforcing修改成SELINUX=disabled，然后重启Linux。</p> 
<p>关闭交换空间</p> 
<p>关闭swap</p> 
<pre><code class="prism language-bash">swapoff -a 
<span class="token function">yes</span> <span class="token operator">|</span> <span class="token function">cp</span> /etc/fstab /etc/fstab_bak 
<span class="token function">cat</span> /etc/fstab_bak <span class="token operator">|</span><span class="token function">grep</span> -v swap <span class="token operator">&gt;</span> /etc/fstab 
<span class="token function">free</span> -m 
</code></pre> 
<p>#配置iptable管理ipv4/6请求<br> vim /etc/sysctl.d/k8s.conf 添加</p> 
<pre><code class="prism language-bash">net.bridge.bridge-nf-call-ip6tables <span class="token operator">=</span> 1 
net.bridge.bridge-nf-call-iptables <span class="token operator">=</span> 1 
</code></pre> 
<p>使配置生效</p> 
<pre><code class="prism language-bash">sysctl –system 
sysctl -a<span class="token operator">|</span><span class="token function">grep</span> bridge 
</code></pre> 
<p><img src="https://images2.imgbox.com/b6/1d/aNELgZJV_o.png" alt="在这里插入图片描述"><br> <img src="https://images2.imgbox.com/6f/b3/R4FCgEJ1_o.png" alt="在这里插入图片描述"><br> 调整时区:<br> 安装docker<br> 安装所需的包<br> yum-utils提供了yum-config-manager 效用，devicemapper存储驱动程序由需要 device-mapper-persistent-data和lvm2<br> 命令:</p> 
<pre><code class="prism language-bash">yum <span class="token function">install</span> -y yum-utils device-mapper-persistent-data  lvm2
</code></pre> 
<p><img src="https://images2.imgbox.com/ea/b1/KTPx5jNJ_o.png" alt="在这里插入图片描述"><br> 设置稳定的存储库。</p> 
<pre><code class="prism language-bash">yum-config-manager  --add-repo https://download.docker.com/linux/centos/docker-ce.repo 
</code></pre> 
<p><img src="https://images2.imgbox.com/ad/a3/zKHB0csF_o.png" alt="在这里插入图片描述"><br> 安装docker18.09.7</p> 
<pre><code class="prism language-bash">yum <span class="token function">install</span> -y docker-ce-18.09.7 docker-ce-cli-18.09.7 containerd.io 
</code></pre> 
<p><img src="https://images2.imgbox.com/c3/e8/o5TDy5Z2_o.png" alt="在这里插入图片描述"><br> <img src="https://images2.imgbox.com/ea/41/lC2FnS1e_o.png" alt="在这里插入图片描述"><br> Docker已安装但尚未启动。该docker组已创建，但没有用户添加到该组。<br> 启动Docker<br> 用下面运行启动docker</p> 
<pre><code class="prism language-bash">systemctl start docker
</code></pre> 
<p>验证是否安装成功<br> 先查看是否启动成功</p> 
<pre><code class="prism language-bash"><span class="token function">service</span> docker status 
</code></pre> 
<p><img src="https://images2.imgbox.com/c0/77/53TEjyxd_o.png" alt="在这里插入图片描述"><br> 通过运行hello-world 映像验证是否正确安装了Docker Engine - 社区。</p> 
<pre><code class="prism language-bash">docker run hello-world 
</code></pre> 
<p>此命令下载测试映像并在容器中运行它。当容器运行时，它会打印一条信息性消息并退出<br> <img src="https://images2.imgbox.com/cd/74/ZSrad7Jj_o.png" alt="在这里插入图片描述"><br> Docker Engine - 社区已安装并正在运行。如果是非root用户执行，目前需要使用sudo来运行Docker命令。<br> 查看版本是否正确</p> 
<pre><code class="prism language-bash">docker version 
</code></pre> 
<p><img src="https://images2.imgbox.com/bc/7b/vmhTgvA5_o.png" alt="在这里插入图片描述"><br> 设置开启启动Docker</p> 
<pre><code class="prism language-bash">systemctl <span class="token function">enable</span> docker <span class="token operator">&amp;&amp;</span> systemctl restart docker <span class="token operator">&amp;&amp;</span> <span class="token function">service</span> docker status 
</code></pre> 
<p><img src="https://images2.imgbox.com/84/d2/ODenwigR_o.png" alt="在这里插入图片描述"><br> 配置docker启动参数<br> vim /etc/docker/daemon.json<br> 然后写入：</p> 
<pre><code class="prism language-bash"><span class="token punctuation">{<!-- --></span> 
 <span class="token string">"registry-mirrors"</span><span class="token keyword">:</span> <span class="token punctuation">[</span><span class="token string">"https://registry.docker-cn.com"</span><span class="token punctuation">]</span>, 
 <span class="token string">"exec-opts"</span><span class="token keyword">:</span> <span class="token punctuation">[</span><span class="token string">"native.cgroupdriver=systemd"</span><span class="token punctuation">]</span> 
<span class="token punctuation">}</span> 
</code></pre> 
<p>#重启docker</p> 
<pre><code class="prism language-bash">systemctl daemon-reload 
systemctl restart docker
</code></pre> 
<p>使用docker安装应用<br> 镜像下载地址: https://hub.docker.com/<br> Docker的一些命令:<br> docker images :来列出本地主机上的镜像。<br> <img src="https://images2.imgbox.com/4a/d0/hrcZjgMb_o.png" alt="在这里插入图片描述"><br> 各个选项说明:<br> REPOSITORY：表示镜像的仓库源<br> TAG：镜像的标签<br> IMAGE ID：镜像ID<br> CREATED：镜像创建时间<br> SIZE：镜像大小<br> 同一仓库源可以有多个 TAG，代表这个仓库源的不同个版本 可以通过以下来指定不同版本的ubuntu的运行，如果不指定一个镜像的版本标签，例如你只使用 ubuntu，docker 将默认使用 ubuntu:latest 镜像。<br> docker run -it ubuntu:15.10 /bin/bash<br> docker run -it ubuntu:14.04 /bin/bash<br> docker search mysql ：搜索我们需要的mysql镜像<br> docker rmi 镜像: 删除镜像时,先要删除依赖container<br> <img src="https://images2.imgbox.com/c5/ca/lH5YQs2E_o.png" alt="在这里插入图片描述"><br> 删除所有的镜像:</p> 
<pre><code class="prism language-bash">docker stop <span class="token variable"><span class="token variable">$(</span>docker <span class="token function">ps</span> -a -q<span class="token variable">)</span></span>
docker <span class="token function">rm</span> <span class="token variable"><span class="token variable">$(</span>docker <span class="token function">ps</span> -a -q<span class="token variable">)</span></span>
docker rmi <span class="token variable"><span class="token variable">$(</span>docker images -q<span class="token variable">)</span></span>
</code></pre> 
<p>docker安装各种软件:<br> docker安装centos7<br> 拉取镜像，默认为最新版本</p> 
<pre><code class="prism language-bash">docker pull centos:centos7
</code></pre> 
<p>查看docker目前所有下载的镜像</p> 
<pre><code class="prism language-bash">docker images
</code></pre> 
<p>运行容器</p> 
<pre><code class="prism language-bash">docker run -itd --name centos-test centos:centos7
</code></pre> 
<p>查看容器的运行状态</p> 
<pre><code class="prism language-bash">docker <span class="token function">ps</span> -a
</code></pre> 
<p>进入容器</p> 
<pre><code class="prism language-bash">docker <span class="token function">exec</span> -it  centos-test /bin/bash
</code></pre> 
<p>docker安装nginx<br> 拉取镜像，默认为最新版本</p> 
<pre><code class="prism language-bash">docker pull nginx:latest
</code></pre> 
<p>查看docker目前所有下载的镜像</p> 
<pre><code class="prism language-bash">docker images
</code></pre> 
<p>运行容器</p> 
<pre><code class="prism language-bash">docker run --name nginx-test -p 8080:80 -d nginx
</code></pre> 
<p>参数说明：<br> –name nginx-test：容器名称。<br> -p 8080:80： 端口进行映射，将本地 8080 端口映射到容器内部的 80 端口。<br> -d nginx： 设置容器在在后台一直运行。<br> 通过浏览器上ip:8080 可以去访问nginx的客户端。<br> docker安装mysql<br> 拉取镜像，默认为最新版本</p> 
<pre><code class="prism language-bash">docker pull mysql:latest
</code></pre> 
<p>查看docker目前所有下载的镜像</p> 
<pre><code class="prism language-bash">docker images
</code></pre> 
<p>运行容器 并且设置账号密码为root 123456</p> 
<pre><code class="prism language-bash">docker run -itd --name mysql-test -p 3306:3306 -e MYSQL_ROOT_PASSWORD<span class="token operator">=</span>123456 mysql
</code></pre> 
<p>进入容器</p> 
<pre><code class="prism language-bash">docker <span class="token function">exec</span> -it  mysql-test /bin/bash
</code></pre> 
<p>此时可以在docker中验证,注意要使用mysql用户登录<br> mysql -uroot -p123456<br> docker安装Redis<br> 拉取镜像，默认为最新版本</p> 
<pre><code class="prism language-bash">docker pull redis:latest
</code></pre> 
<p>查看docker目前所有下载的镜像</p> 
<pre><code class="prism language-bash">docker images
</code></pre> 
<p>运行容器</p> 
<pre><code class="prism language-bash">docker run -itd --name redis-test -p 6379:6379 redis
</code></pre> 
<p>进入容器</p> 
<pre><code class="prism language-bash">docker <span class="token function">exec</span> -it redis-test /bin/bash
</code></pre> 
<p>以上进入到容器之后，查看所有的进程<br> 首先安装ps命令</p> 
<pre><code class="prism language-bash"><span class="token function">apt-get</span> update
<span class="token function">apt-get</span> <span class="token function">install</span> procps
</code></pre> 
<p>利用ps命令查看进程,可以发现程序已经在运行了</p> 
<pre><code class="prism language-bash"><span class="token function">ps</span> -ef
</code></pre> 
<p>Docker安装ELK工具<br> 这里我安装的是elasticsearch-6.6.2和logstash-6.6.2和kibana:7.8.0<br> Docker安装es<br> 拉取镜像，默认为最新版本</p> 
<pre><code class="prism language-bash">docker pull elasticsearch:6.6.2
</code></pre> 
<p>查看docker目前所有下载的镜像</p> 
<pre><code class="prism language-bash">docker images
</code></pre> 
<p>运行es<br> #5601是kibana的默认端口，9200是es的默认端口，discovery.type指定单节点模式</p> 
<pre><code class="prism language-bash">docker run -d --name es -p 5601:5601 -p 9200:9200 -p 9300:9300 -e <span class="token string">"discovery.type=single-node"</span> elasticsearch:6.6.2
</code></pre> 
<p>测试<br> curl http://localhost:9200<br> 如图所示 ES安装成功<br> <img src="https://images2.imgbox.com/11/50/fR1uEY6I_o.png" alt="在这里插入图片描述"><br> Docker安装kibana:6.6.2<br> 拉取镜像，默认为最新版本</p> 
<pre><code class="prism language-bash">docker pull kibana:6.6.2
</code></pre> 
<p>查看docker目前所有下载的镜像</p> 
<pre><code class="prism language-bash">docker images
</code></pre> 
<p>创建并运行kibana # -e ELASTICSEARCH_URL指定es的地址，–network指定使用es的网络，可以借用es开放的5601端口</p> 
<pre><code class="prism language-bash">docker run -it -d -e ELASTICSEARCH_URL<span class="token operator">=</span>http://localhost:9200 --name kibana --network<span class="token operator">=</span>container:es kibana:6.6.2
</code></pre> 
<p>#修改一下kibana的配置文件，要不kibana启动会报kibana is not ready yet的错误<br> 进入kibana容器/bin/bash目录</p> 
<pre><code class="prism language-bash">docker <span class="token function">exec</span> -it kibana /bin/bash
</code></pre> 
<p>进入config目录<br> cd config<br> 修改kibana的配置文件，启动时的配置参数都是从这儿来的<br> vi kibana.yml<br> <img src="https://images2.imgbox.com/41/89/ZiO3v9Ff_o.png" alt="在这里插入图片描述"><br> 然后保存退出文件修改<br> #退出kibana容器</p> 
<pre><code class="prism language-bash"><span class="token keyword">exit</span>
</code></pre> 
<p>重启kibana</p> 
<pre><code class="prism language-bash">docker restart kibana
</code></pre> 
<p>访问http://ip:5601<br> <img src="https://images2.imgbox.com/d6/d1/LmP1tH9T_o.png" alt="在这里插入图片描述"><br> 此时Kibana安装成功<br> 镜像的移植<br> 将容器保存为镜像<br> docker commit 容器名称 镜像名称<br> docker commit mysql-test mymysql<br> 这是可以看到多出来一个mysql的镜像，这个镜像就是我们刚刚生成的。<br> <img src="https://images2.imgbox.com/e5/7f/dxCtLBtu_o.png" alt="在这里插入图片描述"><br> 将镜像打包成tar文件<br> docker save -o mysql.tar mymysql<br> <img src="https://images2.imgbox.com/dd/b5/xbqunjI5_o.png" alt="在这里插入图片描述"><br> 镜像拷贝<br> 加载镜像<br> docker load -i mysql.tar<br> <img src="https://images2.imgbox.com/72/d6/2PfwG0Be_o.png" alt="在这里插入图片描述"><br> 运行容器 并且设置账号密码为root 123456</p> 
<pre><code class="prism language-bash">docker run -itd --name mysql-test -p 3306:3306 -e MYSQL_ROOT_PASSWORD<span class="token operator">=</span>123456 mymysql
</code></pre> 
<p>进入容器</p> 
<pre><code class="prism language-bash">docker <span class="token function">exec</span> -it  mysql-test /bin/bash
</code></pre> 
<p>验证<br> <img src="https://images2.imgbox.com/54/bb/TtQmRyLg_o.png" alt="在这里插入图片描述"><br> 至此，docker的一些简单使用已经完成。</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/809d524a1f80d59b08c67ad3f05a4931/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">Java实现kafka生产者与消费者并将消费后的消息写入HDFS</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/99e203098ca340f17dfd24c6d04e3c50/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">Unity动态加载3D模型</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>