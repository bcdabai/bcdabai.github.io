<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>操作系统复习笔记 - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="操作系统复习笔记" />
<meta property="og:description" content="操作系统实验导航 实验一：银行家算法 https://blog.csdn.net/weixin_46291251/article/details/115384510
实验二：多级队列调度和多级反馈队列调度算法 https://blog.csdn.net/weixin_46291251/article/details/115530582
实验三：动态分区式内存管理 https://blog.csdn.net/weixin_46291251/article/details/115772341
实验四：Linux下多进程通信 https://blog.csdn.net/weixin_46291251/article/details/116274665
实验五：进程通信的三种方式 https://blog.csdn.net/weixin_46291251/article/details/116301250
实验六：Linux文件系统实验 https://blog.csdn.net/weixin_46291251/article/details/116423798
实验七：自制简单U盘引导程序 https://blog.csdn.net/weixin_46291251/article/details/116427629
实验八：磁盘调度算法 https://blog.csdn.net/weixin_46291251/article/details/116431907
实验九：请求分页系统中的置换算法 https://blog.csdn.net/weixin_46291251/article/details/116443021
学习笔记：操作系统复习笔记 https://blog.csdn.net/weixin_46291251/article/details/117086851
文章是在有道云上面写的，搬过还没来得及改格式，原文链接
_by Cheney
一：绪论
二：操作系统的结构和硬件支持
►处理机状态：
►中断：
三：操作系统的用户接口
►作业：
►系统调用：
四：进程及进程管理：★★★
►并发处理：
►进程:
► 线程
►进程互斥和同步
互斥:
同步
锁和上锁、开锁操作
►典型问题：★★
►进程通信
五：资源分配与调度
►资源管理概述
►死锁：
六：处理机调度
►作业调度
►进程调度
七：主存管理：★★★
►分区存储管理
►页式管理概述
►段式及段页式存储管理（了解）
八：输入∕输出管理
►设备管理：
►缓冲技术
►设备分配
SPOOLING系统
►I/O控制
九：文件系统：
►文件组织的结构:
►磁盘调度算法
十：一些题目
►虚拟存储技术不能与（ 分区管理 ）配合使用原因
►进程有不同的定义，比较典型的定义有：
►简述程序与进程
►简述进程与线程
►中断处理的流程" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/97013786f6cace150b0e99dd03dab3cd/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-03-15T00:19:12+08:00" />
<meta property="article:modified_time" content="2022-03-15T00:19:12+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">操作系统复习笔记</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p><kbd> <mark>操作系统实验导航</mark> </kbd><br> <mark>实验一：银行家算法</mark><a href="https://blog.csdn.net/weixin_46291251/article/details/115384510"> https://blog.csdn.net/weixin_46291251/article/details/115384510</a><br> <mark>实验二：多级队列调度和多级反馈队列调度算法</mark><a href="https://blog.csdn.net/weixin_46291251/article/details/115530582"> https://blog.csdn.net/weixin_46291251/article/details/115530582</a><br> <mark>实验三：动态分区式内存管理</mark><a href="https://blog.csdn.net/weixin_46291251/article/details/115772341"> https://blog.csdn.net/weixin_46291251/article/details/115772341</a><br> <mark>实验四：Linux下多进程通信</mark> <a href="https://blog.csdn.net/weixin_46291251/article/details/116274665">https://blog.csdn.net/weixin_46291251/article/details/116274665</a><br> <mark>实验五：进程通信的三种方式</mark><a href="https://blog.csdn.net/weixin_46291251/article/details/116301250"> https://blog.csdn.net/weixin_46291251/article/details/116301250</a><br> <mark>实验六：Linux文件系统实验</mark><a href="https://blog.csdn.net/weixin_46291251/article/details/116423798"> https://blog.csdn.net/weixin_46291251/article/details/116423798</a><br> <mark>实验七：自制简单U盘引导程序</mark><a href="https://blog.csdn.net/weixin_46291251/article/details/116427629"> https://blog.csdn.net/weixin_46291251/article/details/116427629</a><br> <mark>实验八：磁盘调度算法</mark><a href="https://blog.csdn.net/weixin_46291251/article/details/116431907"> https://blog.csdn.net/weixin_46291251/article/details/116431907</a><br> <mark>实验九：请求分页系统中的置换算法</mark> <a href="https://blog.csdn.net/weixin_46291251/article/details/116443021">https://blog.csdn.net/weixin_46291251/article/details/116443021</a><br> <mark>学习笔记：操作系统复习笔记</mark><a href="https://blog.csdn.net/weixin_46291251/article/details/117086851"> https://blog.csdn.net/weixin_46291251/article/details/117086851</a></p> 
<p>文章是在有道云上面写的，搬过还没来得及改格式，<a href="http://note.youdao.com/noteshare?id=8efc2d38cefc744b89f48d22a8139d31" rel="nofollow">原文链接</a></p> 
<p>_by Cheney<br> 一：绪论<br> 二：操作系统的结构和硬件支持<br> ►处理机状态：<br> ►中断：<br> 三：操作系统的用户接口<br> ►作业：<br> ►系统调用：<br> 四：进程及进程管理：★★★<br> ►并发处理：<br> ►进程:<br> ► 线程<br> ►进程互斥和同步<br> 互斥:<br> 同步<br> 锁和上锁、开锁操作<br> ►典型问题：★★<br> ►进程通信<br> 五：资源分配与调度<br> ►资源管理概述<br> ►死锁：<br> 六：处理机调度<br> ►作业调度<br> ►进程调度<br> 七：主存管理：★★★<br> ►分区存储管理<br> ►页式管理概述<br> ►段式及段页式存储管理（了解）<br> 八：输入∕输出管理<br> ►设备管理：<br> ►缓冲技术<br> ►设备分配<br> SPOOLING系统<br> ►I/O控制<br> 九：文件系统：<br> ►文件组织的结构:<br> ►磁盘调度算法<br> 十：一些题目<br> ►虚拟存储技术不能与（ 分区管理 ）配合使用原因<br> ►进程有不同的定义，比较典型的定义有：<br> ►简述程序与进程<br> ►简述进程与线程<br> ►中断处理的流程<br> ►何为死锁？产生条件？如何避免\处理？<br> ►用信号量（P、V操作）实现进程互斥与同步<br> 题：多进程推进次序问题：<br> 题：共享缓冲区的合作进程的同步<br> 题：生产者——消费者问题：<br> ►银行家算法避免死锁求安全序列<br> ►作业调度算法求周转时间<br> ►分区存储（放置算法）求内存序列<br> ►页面调度（淘汰算法）求缺页中断次数<br> ►Linux文件系统相关计算<br> ►磁盘读取文件时间计算<br> ►其它：</p> 
<hr> 
<p>一：绪论</p> 
<ul><li>操作系统<br> 是管理和控制计算机系统中各种硬件和软件资源、合理地组织计算机工作流程的系统软件，是用户与计算机之间的接口。</li><li>基本特征<br> 并发、共享</li><li>发展历程：<br> 手工操作阶段 批处理阶段 执行系统 多道程序系统： 现代操作系统<br> 联机批处理 脱机批处理 多道批处理系统 分时系统 实时系统 个人计算机操作系统 网络操作系统分布式操作系统等</li><li>各个阶段的特点和问题：<br> 阶段 特点 问题 解决办法<br> 手工操作阶段 无任何软件有人工干预独占性、串行性 人—— 机矛盾<br> 联机批处理 磁带监督程序作业自动过渡 CPU高速与I/O慢速的矛盾 由卫星机负责I/O<br> 脱机批处理 主机与卫星机并行操作 调度不灵活；保护问题 硬件技术的发展： 通道技术、中断技术<br> 执行系统 主机、外设并行操作；增强了保护能力。 CPU高速与I/O慢速的矛盾<br> 多道程序设计技术 多道宏观上并行微观上串行　 cpu仍然有等待程序有等待程序不能公平运行<br> 分时技术 一台计算机与许多终端设备连接，终端用户以联机方式使用计算机，系统可以快速响应<br> 实时处理 以快速反应为特征，对实时信号能在截止期限之内处理并作出反应。具有实时性和可预测性。</li></ul> 
<hr> 
<p>二：操作系统的结构和硬件支持</p> 
<ul><li>操作系统虚拟机 = 裸机 + 操作系统程序</li><li>裸机的指令系统：机器指令</li><li>操作系统虚拟机的指令系统：命令接口+程序接口<br> 命令接口：作业控制语言、键盘命令、图形化用户界面<br> 程序接口：系统功能调用<br> ►处理机状态：</li><li>区别：<br> 管态 ：操作系统程序，全部指令，所有区域<br> 用户态：用户程序，禁止用特权指令，自己的区域</li><li>特权指令集<br> 涉及外部设备的输入/输出指令（启动I/O设备）<br> 修改特殊寄存器的指令（存取中断寄存器）<br> 改变机器状态的指令（开、关中断）</li><li>为什么要区分处理机的状态 ？★★<br> ——为了保护操作系统<br> ►中断：</li><li>定义：指某个事件 (例如电源掉电、定点加法溢出或 I/O传输结束等) 发生时，系统中止现行程序的运行、引出处理事件程序对该事件进行处理，处理完毕后返回断点，继续执行。</li><li>流程：中断进入（硬件）-&gt;中断处理(软件)-&gt;中断返回（硬件）<br> 硬件：指令计数器+处理机状态寄存器+系统堆栈+中断向量表<br> 中断进入<br> 保护现场<br> 中断处理<br> 恢复现场　<br> 中断返回</li><li>中断响应的实质：交换指令地址及处理机的状态信息</li></ul> 
<hr> 
<p>三：操作系统的用户接口<br> ►作业：</p> 
<ul><li> <p>计算机系统按指定步骤对初始数据进行处理并得到计算结果的加工工作</p> </li><li> <p>作业处理步骤：<br> a.编辑：<br> b.编译:<br> c.连接:<br> i.静态连接<br> ii.动态链接<br> d.运行：</p> </li><li> <p>关于连接<br> a.静态连接：编译后，生成一个可重定位的目标模块，并产生内部符号表和外部调用表，供连接程序 (Link)使用<br> 缺点：将所需的外部函数链接到目标文件中形成 为一个可执行文件。若多个应用程序都调用了同一个库中的外部函数，那么，应用程序的目标文件中都包含了这个外部函数对应的代码。<br> b.动态链接 ：在应用程序中需要调用外部函数的地方记录要使用的外部函数名和引用入口号， 形成函数调用链表，需要DLL (动态链接库)<br> 当 Windows的装载程序将应用程序和DLL装入主存后，装载程序会遍历函数调用链表，将DLL中函数在主存的入口 (段：偏移)填入链表中的每个结点</p> </li></ul> 
<p>►系统调用：</p> 
<ul><li>系统功能调用是用户在程序一级请求操作系统服务的一种手段，它是带有一定功能号的“访管指令”。其功能是由操作系统中的程序完成的，即由软件方法实现的。</li><li>调用过程：程序运行-&gt;执行访管指令-&gt;触发访管中断-&gt;常规中断处理 -&gt;根据功能号查询例行子程序入口地址表-&gt;执行子程序</li></ul> 
<hr> 
<p>四：进程及进程管理：★★★<br> ►并发处理：</p> 
<ul><li> <p>顺序程序的特点：<br> 顺序性：处理机的操作严格按照程序所规定的顺序<br> 封闭性：程序一旦开始执行，其计算结果不受外界因素的影响<br> 可再现性：程序执行的结果与它的执行速度无关(即与时间无关)，而只与初始条件有关</p> </li><li> <p>并发的含义：若干个程序段同时在系统中运行，这些程序段的执行在时间上是重叠的，一个程序段的执行尚未结束，另一个程序段的执行已经开始，即使这种重叠是很小的一部分，也称这几个程序段是并发执行的</p> </li><li> <p>并发程序的特点：<br> 失去程序的封闭性和可再现性<br> ►进程:</p> </li><li> <p>定义：一个程序在给定活动空间和初始环境下，在一个处理机上的执行过程</p> </li><li> <p>进程与程序的区别：★★<br> 程序是静态的概念；进程是动态的概念<br> 进程是一个独立运行的活动单位<br> 进程是竞争系统资源的基本单位<br> 一个程序可以对应多个进程；一个进程至少包含一个程序。<br> 注意：一个程序可以对应多个进程，一个进程也可以对应多个程序。</p> </li><li> <p>状态：运行、等待、就绪★★<br> 任一时刻处于就绪的进程最多是 n-1 个，最少是 0 个。</p> </li><li> <p>进程的组成：</p> </li></ul> 
<p>a.PCB(进程控制块)<br> b.程序段（可为其他进程共享）<br> c.数据段</p> 
<p>► 线程<br> 概述：</p> 
<ul><li>它是比进程更小的活动单位</li><li>它是进程中的一个执行路径。</li><li>它有自己私用的堆栈和处理机执行环境 ；</li><li>它与父进程共享分配给父进程的主存；</li><li>它是单个进程所创建的许多个同时存在的线程中的一个。</li></ul> 
<p>►进程互斥和同步<br> 互斥:</p> 
<ul><li>临界资源(一次仅允许一个进程使用的资源称为临界资源)</li><li>临界区 :<br> 在每个进程中，访问临界资源的那段程序能够从概念上分离出来，称为临界区或临界段。<br> 临界区是进程中对公共变量(或存储区)进行审查与修改的程序段，称为相对于该公共变量的临界区。</li><li>定义：在操作系统中，当某一进程正在访问某一存储区域时，就不允许其他进程来读出或者修改存储区的内容，否则，就会发生后果无法估计的错误。进程间的这种相互制约关系称为互斥。</li></ul> 
<p>同步</p> 
<ul><li>定义： 并发进程在一些关键点上可能需要互相等待与互通消息，这种相互制约的等待与互通消息称为进程同步。</li></ul> 
<p>锁和上锁、开锁操作</p> 
<ul><li>锁:用变量w代表某种资源的状态，w称为“锁”</li><li>上锁和开锁：<br> 检测w的值 (是0还是1)；<br> 如果w的值为1，继续检测；<br> 如果w的值为0，将锁位置1 (表示占用资源)，进入临界区执行 (即上锁)<br> 临界资源使用完毕，将锁位置0 (即开锁)</li></ul> 
<p>信号量和P、V操作</p> 
<ul><li>信号量：信号灯是一个确定的二元组(s，q)，s是一个具有非负初值的整型变 量，q是一个初始状态为空的队列<br> S ≥ 0 时，表示绿灯，进程执行；<br> S &lt; 0 时，表示红灯，进程停止执行。</li><li>P 操作-<br> 对信号灯s的 p操作记为 p(s)。<br> p(s)是一个不可分割的原语操作，即取信号灯值减1，<br> 若相减结果为负，则调用p(s)的进程被阻，并插入到该信号灯的等待队列中，<br> 否则可以继续执行</li><li>V 操作+<br> 对信号灯s的 v操作记为 v(s)。<br> v(s)是一个不可分割的原语操作，即取信号灯值加1，<br> 若相加结果大于零，进程继续执行，<br> 否则，要帮助唤醒在信号灯等待队列上的一个进程。</li></ul> 
<p>►典型问题：★★<br> 见文章最后一部分</p> 
<p>►进程通信<br> 类型:<br> 1、共享存储器系统<br> 基于共享数据结构的通信方式:<br> 共享内存方式:<br> 2、消息传递系统<br> 直接通信：(消息缓冲通信)<br> 间接通信:(信箱通信)<br> 3、管道通信 (共享文件方式)<br> 管道，是指用于连接一个读进程和一个写进程的文件<br> 写进程以字符流的形式将大量数据送入管道（FIFO）</p> 
<p>具体实现：</p> 
<hr> 
<p>五：资源分配与调度</p> 
<p>►资源管理概述</p> 
<ul><li>资源分配<br> 静态分配<br> 动态分配</li><li>资源分配的机构<br> 资源描述器<br> 资源信息块</li><li>虚拟资源目的：<br> 方便用户使用<br> 资源可动态分配，提高资源利用率</li><li>资源分配策略<br> 先请求先服务<br> 优先调度<br> 针对设备特性的调度策略<br> 如：旋转调度法</li></ul> 
<p>►死锁：</p> 
<ul><li> <p>概念：在两个或多个并发进程中，如果每个进程持有某种资源而又都等待着别的进程释放它或它们现在保持着的资源，否则就不能向前推进。此时，称这一组进程产生了死锁。</p> </li><li> <p>产生原因：<br> 系统资源不足<br> 进程推进顺序非法</p> </li><li> <p>产生死锁的必要条件★<br> a.互斥条件（资源独占）:资源是非共享的，即为临界资源<br> b.不剥夺条件:<br> c.部分分配（保持申请）:等待一新资源的同时，进程继续占用已分配到的资源<br> d.环路条件(循环等待):存在一种进程的循环链，链中的每一个进程已获得的资源同时被链中下一个进程所请求</p> </li><li> <p>死锁 VS 饥饿：★<br> 死锁 系统资源不足 至少两个进程 全部进程处于等待状态 都是由于竞争资源而引起的 可以检测<br> 饥饿 资源分配不平衡引起 可能只有一个 忙等（运行或就绪态）的进程也可能被饿死 无法检测</p> </li><li> <p>解决死锁问题的策略<br> a.死锁预防（静态）<br> 破坏环路等待<br> b.死锁避免（动态）<br> i.有序资源分配方法<br> ii.银行家算法<br> c.死锁恢复<br> 剥夺资源</p> </li><li> <p>银行家算法:<br> 见文章最后</p> </li><li> <p>同步机制的应用：（Linux）<br> a.原子操作：要不全部执行，要不全部不执行，是最小的执行单位<br> b.互斥锁（mutex）：某一进程正在访问某一存储区域时，就不允许其他进程来读出或者修改存储区的内容<br> c.自旋锁（spin_lock）：与互斥锁类似，区别在于，对于互斥锁而言，如果资源已经被占用，其它的资源申请进程只能进入sleep状态。但是自旋锁不会引起调用者sleep，如果自旋锁已经被别的执行单元保持，调用者就一直循环在等待该自旋锁的保持者是否释放该锁。<br> d.信号量（semaphore）：信号量的本质也是一个计数器，用来记录对某个资源（如共享内存）的存取状况。用来协调不同进程间的数据对象，最主要的应用是共享内存方式的进程间通信。<br> e.读写锁（rw_lock）：写者是排他性的，一个读写锁同时只能有一个写者或多个读者（与CPU数相关），但不能同时既有读者又有写者</p> </li></ul> 
<hr> 
<p>六：处理机调度<br> ►作业调度<br> —— 宏观调度（决定辅存上的程序何时变为进程）</p> 
<ul><li> <p>作业的状态：（后备、执行、完成）<br> 执行状态又分为：运行、就绪、等待。<br> 必考：状态变迁图★★</p> </li><li> <p>注意：作业调度选中一个作业并把它装入主存，就为该作业创建一个进程，这个进程的初始状态为就绪状态</p> </li><li> <p>周转时间：一个作业提交给计算机系统到该作业的结果返回给用户所需要的时间（等待+运行）。</p> </li><li> <p>带权周转时间：一个作业的周转时间与其运行时间的比值 （了解）</p> </li><li> <p>常用的作业调度算法 ：<br> i.先来先服务调度算法(FCFS)<br> ii.短作业优先调度算法<br> iii.响应比高者优先(响应比=响应时间/执行时间 =1+作业等待时间/执行时间)</p> </li></ul> 
<p>►进程调度<br> —— 微观调度（决定主存上的进程何时获得处理机）</p> 
<ul><li> <p>调度策略：<br> 优先调度<br> 先来先服务</p> </li><li> <p>调度的方式：剥夺式、非剥夺方式</p> </li><li> <p>进程调度算法：<br> a.进程优先数调度算法<br> i.静态优先数:(确定标准：要用的资源、估计运行时间、类型)<br> ii.动态优先数:(确定方法：使用CPU超过一定数值时，降低优先数；I/O操作后，增加优先数；等待时间超过一定数值时，提高优先数)<br> b.循环轮转（时间片轮转）调度算法<br> i.简单循环轮转<br> ii.可变时间片轮转调度<br> iii.多重时间片循环调度<br> c.处理机多级调度</p> </li><li> <p>调度用的进程状态变迁图：</p> </li></ul> 
<p>注意与作业变迁图的区别与联系：整个进程调度只是作业调度的一步</p> 
<ul><li>作业调度与进程调度之间的差别主要是：<br> 作业调度是宏观调度，它所选择的作业只是具有获得处理机的资格，但尚未占有处理机，不能立即在其上实际运行；<br> 而进程调度是微观调度，动态地把处理机实际地分配给所选择的进程，使之真正活动起来。<br> 另外，进程调度相当频繁，而作业调度执行的次数一般很少。</li></ul> 
<hr> 
<p>七：主存管理：★★★</p> 
<ul><li> <p>主存共享方式<br> a.大小不等的区域:(分区、段式存储管理)<br> b.大小相等的区域:（页式存储管理）<br> c.二者结合（段页式存储管理）</p> </li><li> <p>C程序的内存分布：<br> 代码段 (Text segment)：可共享、只读<br> 初始化数据段 (Initialized data segment)：全局、静态变量<br> 未初始化数据段 (Uninitialized data segment)：<br> 堆区 (Heap)：malloc的来源<br> 栈区 (Stack)）：自动变量、每次函数调用时保存的信息上下文环境等<br> 栈与堆是相互毗邻的，并且生长方向相反；当栈指针触及到堆指针位置，意味着栈空间已经被耗尽</p> </li><li> <p>地址映射：（将程序地址空间中使用的逻辑地址变换成主存中的物理地址的过程）<br> a.编写或编译时确定虚、实地址之间的对应关系<br> b.静态地址映射 :作业装入时确定地址映射关系<br> (需要软件重定位装入程序、依赖CPU、不灵活)<br> c.动态地址映射 :程序运行时确定地址映射关系<br> (需要硬件重定位寄存器、不依赖CPU、灵活快速)</p> </li><li> <p>主存分配<br> a.构造分配用的数据结构<br> 主存资源信息块：等待队列；空闲区队列；主存分配程序；<br> b.制定策略<br> 总体分配策略 —— 在众多个请求者中选择一个请求者的原则<br> 放置策略 —— 在可用资源中，选择一个空闲区的原则<br> 调入策略 —— 决定信息装入主存的时机<br> 预调策略：预先将信息调入主存<br> 请调策略：当需要信息时，将信息调入主存<br> 淘汰策略 ——在主存中没有可用的空闲区(对某一作业而言)时，决定哪些信息从主存中移走，即确定淘汰已占用的内存区的原则。<br> c.实施主存分配与回收</p> </li><li> <p>主存扩充（虚拟内存）<br> 实现方法: 虚拟存储器</p> </li><li> <p>实现虚拟存储器的物质基础<br> i.有相当容量的辅存<br> ii.有一定容量的主存<br> iii.地址变换机构</p> </li><li> <p>虚拟存储器的最大容量由计算机的地址结构决定</p> </li></ul> 
<p>►分区存储管理<br> （上机实验）</p> 
<ul><li>分区分配<br> a.静态<br> b.动态：在处理作业的过程中，建立分区，依用户请求的大小分配分区。</li><li>分区分配结构:<br> a.主存资源信息块 (M_RIB)<br> b.分区描述器 (PD)<br> c.空闲区队列 
  <ul><li>分区分配<br> 分区分配程序在自由主存队列中找一个满足用户需要的空闲块<br> 若找到了所需的空闲区，有两种情况(大于所需、等于所需)</li></ul> </li><li>分区回收<br> 检查释放分区(即为回收分区)在主存中的邻接情况 ；<br> 分四种情况讨论。</li><li>放置策略（选择空闲区的策略）★★<br> 首次匹配(首次适应算法)：（地址最低）<br> 最佳匹配(最佳适应算法)：（与所需大小最接近）<br> 最坏匹配(最坏适应算法)：（与所需大小差距最大）</li><li>碎片问题及拼接技术</li></ul> 
<p>►页式管理概述</p> 
<ul><li> <p>基本概念<br> 页面:程序的地址空间被等分成大小相等的片，称为页面，又称为虚页。<br> 主存块:主存被等分成大小相等的片，称为主存块，又称为实页。<br> 页表：页与内存块之间对应关系的地址变换的机构称为页面映像表，简称页表。</p> </li><li> <p>页式地址变换<br> 虚地址结构:页面大小为xkb = 1*2<sup>((10+k</sup>(1/2)）- 1)<br> 虚地址为 M位，页面大小位 Nｋｂ时 虚地址长度为32位，页面大小为4KB时 虚地址长度为16位，页面大小为1KB时</p> </li><li> <p>页号P的位数标识了一共有多少页，即页表中有多少个表项</p> </li><li> <p>页内位移W的位数表示一页有多大</p> </li></ul> 
<p>页式地址变换步骤：<br> 1.CPU给出操作数地址(为2500) ；<br> 2.由分页机构自动地把逻辑地址分为两部分，得到页号p和页内相对位移w (p =2， w =452)；<br> 3.根据页表始址寄存器指示的页表始地址，以页号为索引，找到第2页所对应的块号(为7) ；<br> 4.将块号b和页内位移量w拼接在一起，就形成了访问 主存的物理地址 (7*1024+452=7620)</p> 
<ul><li>淘汰算法（置换策略）:<br> a.最佳算法(OPT算法) （实际无法实现）:(以后不再要用的，或者是在最长的时间以后才会用到的那页)<br> b.先进先出淘汰算法(FIFO算法) :(在主存中居留时间最长(即最早进入主存)的一页淘汰)<br> c.最久未使用淘汰算法(LRU算法):(最长时间未被使用的那一页淘汰)</li></ul> 
<p>►段式及段页式存储管理（了解）</p> 
<ul><li>页式系统与段式系统的区别<br> a.用户地址空间的区别<br> 页式系统中用户地址空间——一维地址空间<br> 段式系统中用户地址空间——二维地址空间<br> b.分段和页面的区别<br> 分段:逻辑划分、段长可变、用户可见、w字段的溢出将产生越界中断<br> 页面:物理划分、页固定、用户不可见、w字段的溢出自动加入页号</li><li>段页式系统：<br> 在段式存储管理中结合分页存储管理技术，在一个分段内划分页面，就形成了段页式存储管理。</li></ul> 
<hr> 
<p>八：输入∕输出管理<br> ►设备管理：</p> 
<ul><li>设备分类:<br> 存储设备(块设备)<br> 输入输出设备(字符设备)<br> 通信设备</li><li>设备管理的目标<br> a.提高设备利用率<br> 合理分配设备<br> 提高设备与CPU、各外部设备之间的并行性<br> b.提供使用方便且独立于设备的界面(屏蔽底差异)<br> 统一：对各种不同的设备提供一致的界面<br> 独立于设备：用户使用的设备与物理设备无关</li><li>设备独立性：指用户在编制程序时所使用的设备与实际使用的设备无关，也就是在用户程序中仅使用逻辑设备名</li><li>两种类型的设备独立性<br> a.设备无关：一个程序独立于分配给它的某种类型的具体设备<br> 即：系统可以根据设备的使用情况，动态地分配给程序某类设备中的任一台物理设备，程序都能正确地执行<br> b.类型无关：程序应尽可能与它所使用的I/O设备类型无关<br> 即：在输入(或输出)信息时，信息可以从不同类型的输入(或输出)设备上输入(或输出)，若要改变输入(或输出)设备的类型，程序只需进行最少的修改。</li><li>设备控制块</li></ul> 
<p>►缓冲技术</p> 
<ul><li>什么是缓冲<br> 缓冲是两种不同速度的设备之间传输信息时平滑传输过程的常用手段。</li><li>缓冲类别：软件、硬件（缓冲器）</li><li>缓冲管理的目的：<br> 加快系统响应、增强系统吞吐量<br> 减少对磁盘的I/O操作次数</li></ul> 
<p>►设备分配</p> 
<ul><li>设备分配技术：<br> a.独享分配(让一个作业在整个运行期间独占使用)<br> 临界资源<br> 费时的I/O操作或需人工干预<br> b.共享分配(由多个作业、进程共同使用)<br> 旋转设备，可直接或随机访问<br> 便于共享，转接简单，耗费较少<br> c.虚拟分配(将独占设备转化为共享设备)</li></ul> 
<p>SPOOLING系统</p> 
<ul><li> <p>概念： SPOOLING系统提供外围设备同时联机操作的功能。即：将一台物理I/O设备虚拟为多台逻辑I/O设备，同样允许多个用户共享一台物理I/O设备<br> 实际是一种空间换取时间的技术</p> </li><li> <p>实现SPOOLING系统的基础:<br> a.大容量的辅存空间(辅存上需开辟输入井和输出井)<br> b.硬件基础(通道装置、中断系统)<br> c.数据结构(预输入表、缓输出表：描述辅存输入井和输出井的状态变化)</p> </li><li> <p>过程：<br> i.预输入：作业需要数据前，OS已将所需数据预先输入到辅存输入井存放。当作业 (或进程) 需要数据时，可直接从辅存中读入主存<br> ii.缓输出：作业执行时，将输出数据写入辅存输出井中。当作业 (或进程) 执行完毕 (或需要数据时) ，由操作系统将数据输出。</p> </li><li> <p>优点：<br> 提供虚拟设备<br> 外围设备同时联机操作 （将独占设备改造为共享设备）<br> 加快作业处理速度 （提高了I/O的速度）</p> </li></ul> 
<p>►I/O控制</p> 
<ul><li> <p>主存与外围设备之间的消息传送称为输入输出操作</p> </li><li> <p>I/O设备的控制方式分为四类:(按照I/O控制器智能化程度的高低)<br> 循环测试I/O方式（程序I/O）<br> I/O中断方式<br> DMA方式(Direct Memory Access，直接存储器访问)<br> 通道方式</p> </li><li> <p>输入/输出功能的发展过程★★<br> 1 2 3 4 5 6<br> 处理器直接控制外围设备 增加了控制器或I/O模块。 采用中断 通过DMA直接控制存储器 I/O模块被增强成一个单独的处理器 I/O模块有自己的局部存储器<br> 在简单的微处理器控制设备中比较多见 CPU开始从外部设备接口的具体细节中分离出来。 处理器不再需要花费时间等待执行一个I/O操作，因而效率得到了提高 可以在没有处理器参与的情况下，从主存中移出或者往主存中移入一块数据。仅仅在传送开始和结束时需要用到处理器。 有专门为I/O设计的指令集。中央处理器(CPU)指导I/O处理器在主存中执行一个I/O程序。IO处理器在没有处理器干涉的情况下取指令并执行这些指令 事实上，它本身就是一个计算机。使用体系结构可以控制许多IO设备,并且使需要处理器参与的部分最小。这种结构通常用于控制与交互终端的通信。</p> </li><li> <p>I/O子系统的特点:<br> 在应用层为用户提供 I/O应用接口,每个通用设备类型都通过一组标准函数(及接口)来访问,具体的差别被I/O子系统中的内核模块(称为设备驱动程序)所封装,为内核I/O子系统隐藏设备控制器之间的差异。将I/O子系统与硬件分离.</p> </li></ul> 
<hr> 
<p>九：文件系统：</p> 
<p>►文件组织的结构:<br> a.逻辑结构(从用户角度看到的文件面貌)（程序员开发/设计的各种格式）<br> i.流式文件（相关的有序字符的集合，是无结构的）<br> ii.记录式文件（有结构，在逻辑上总被看成一组连续顺序的记录的集合）（其逻辑记录可以按任意次序存放）<br> b.物理结构(信息在物理存储器上的存储方式)（由文件系统定义）<br> i.连续文件（一组分配在磁盘连续区域的物理块组成）<br> ii.串联文件（按顺序由串联的块组成的，即文件的信息存于若干块物理块中）<br> iii.索引结构（由数据文件和索引表构成）</p> 
<ul><li> <p>索引块：存放文件的索引表的物理块，其块号保存在文件目录项的物理地址中</p> </li><li> <p>索引文件的特点:<br> 易于文件的增删<br> 直接读写任意记录</p> </li><li> <p>索引表的组织<br> 直接索引<br> 一级间接索引<br> 二级间接索引</p> </li><li> <p>文件索引节点<br> UNIX系统把文件目录项中除了名字以外的信息全部存放到一个数据块上，这种数据块就是文件索引节点(index node)，简称 i 节点。在目录项中只有文件的名字和对应 i 节点的编号。<br> 文件所有者 定义对一个文件具有存取权的用户集合，分为文件所有者、用户组所有者<br> 文件类型 分为正规文件、目录文件、字符特殊文件或块特殊文件<br> 文件存取许可权 按文件所有者、文件的用户组所有者及其他用户三个类别对文件施行保护。每类都具有读、写、执行该文件的存取权，并且能分别地设置。<br> 文件联结数目 在文件目录结构中，有多少个文件名指向该文件。减少一个名字时i_ilink 值减1。当其值减为0时，该文件才能真正删除。<br> 存取时间<br> 长度<br> 地址索引表 文件数据的磁盘地址明细表</p> </li></ul> 
<p>►文件目录及其结构</p> 
<ul><li>分类：<br> 1.一级文件目录<br> 特点：a.实现了按名存取的功能，比较简单；<br> b.要求文件名和文件之间有一一对应的关系（不允许重名）<br> 2.树型文件目录<br> 多级目录系统中(除最末一级外)，任何一级目录的目录项可以描述一个目录文件，也可以描述一个非目录文件(数据文件)，而数据文件一定在树叶上</li></ul> 
<p>►访问权限(10位)：</p> 
<ul><li>第1位：表示文件的类型：<br> -：表示该文件是普通文件。<br> d：表示该文件是一个目录。<br> l：表示该文件是一个链接文件。<br> b：表示该文件是块设备文件，块设备通常为硬盘、光驱等传输速度较快的物理设备。<br> c：表示键盘、鼠标等传输速度较慢的设备文件</li><li>剩余9位，每3位一组。<br> 文件所有者(user)权限（第一组：第2-4位） 与文件所有者同组用户(group)的权限（第二组：5-7位） 系统中其他用户(other)的权限（第三组：8-10位）<br> 一组3位按从左至右顺序分别表示：<br> 读（r）= 4100 写(w) = 2010 执行（x）= 1001 无权限（-）= 0000</li></ul> 
<p>►磁盘调度算法<br> 思想： 优： 缺：<br> 先来先服务算法（FCFS） 按访问请求到达的先后次序服务。 简单，公平 效率不高<br> 最短寻道时间优先算法（SSTF） 优先选择距当前磁头最近的访问请求进行服务 改善了磁盘平均服务时间 造成某些访问请求长期等待得不到服务<br> 扫描算法（电梯算法）（SCAN） 当设备无访问请求时，磁头不动；当有访问请求时，磁头按一个方向移动，在移动过程中对遇到的访问请求进行服务，然后判断该方向上是否还有访问请求，如果有则继续扫描；否则改变移动方向，并为经过的访问请求服务，如此反复。 克服了最短寻道优先的缺点，既考虑了距离，同时又考虑了方向。被Linux所采用<br> 单向扫描调度算法（CSCAN） 1、总是从0号柱面开始向里扫描。2、按照各自所要访问的柱面位置的次序去选择访问者。3、移动臂到达最后一个柱面后，立即带动读写磁头快速返回到0号柱面。4、返回时不为任何的等待访问者服务。5、返回后可再次进行扫描。</p> 
<hr> 
<p>十：一些题目<br> ►虚拟存储技术不能与（ 分区管理 ）配合使用原因<br> 虚拟存储技术的出现，是建立在程序具有局部性的原理上的，虚拟内存只有在非连续存储管理中才存在：页式存储、段式存储、段页式存储。而分区管理，是一种连续存储管理的方案。<br> 下面是关于分区管理的一些知识点：<br> 为了支持多道程序系统和分时系统，支持多个程序并发执行，引入了分区式存储管理。分区式存储管理是把内存分为一些大小相等或不等的分区，操作系统占用其中一个分区，其余的分区由应用程序使用，每个应用程序占用一个或几个分区。分区式存储管理虽然可以支持并发，但难以进行内存分区的共享。<br> 分区式存储管理引人了两个新的问题：内碎片和外碎片。<br> 内碎片是占用分区内未被利用的空间，外碎片是占用分区之间难以利用的空闲分区(通常是小空闲分区)。<br> 为实现分区式存储管理，操作系统应维护的数据结构为分区表或分区链表。表中各表项一般包括每个分区的起始地址、大小及状态(是否已分配)。<br> 分区式存储管理常采用的一项技术就是内存紧缩(compaction)。</p> 
<p>►进程有不同的定义，比较典型的定义有：<br> 　　　　1.进程是程序的一次执行过程。<br> 　　　　2.进程是一个程序及其数据在处理机上顺序执行时所发生的活动<br> 　　　　3.进程是有独立功能的程序在一个数据集合上运行的过程，它是系统进行资源分配和调度的一个独立单位。<br> 进程的特征；<br> 　　　　1.动态（pcb进程控制块是进程存在的唯一的标志）：进程是程序的一次执行，它有着创建，活动，暂停，终止等过程，具有一定的生命周期（由pcb决定），是动态的产生，变化和消亡的。动态性是进程最基本的特征。、<br> 　　　　2.并发性：指多个进程实体，同存在于内存中，能在一段时间内同时运行，并发性是进程的重要特征，同时也是操作系统的重要特征。引入进程的目的就是为了使程序能与其他进程的程序并发执行，以提高资源利用率。<br> 　　　　3.独立性：指进程实体是一个能独立运行，独立获得资源和独立接受调度的基本单位。凡是未建立pcb的程序都不能作为一个独立的单位参与运行。<br> 　　　　4.异步性：由于进程的相互制约，使进程具有执行的间断性，即进程按照各自的独立的，不可预知的速度向前推进。异步性会导致执行结果的不可再现性，为此，在操作系统中必须配置相应的进程同步机制。<br> 　　　　5.结构性：每个进程都配置一个pcb对其进行描述。从结构上看，进程实体是由程序段，数据段和进程控制块（PCB）三部分组成。</p> 
<p>►简述程序与进程<br> 程序 只是一组指令的有序集合， 静态的实体<br> 进程 是程序在某个数据集上的执行， 动态的实体<br> 进程和程序并不是一一对应的，一个程序执行在不同的数据集上就成为不同的进程，可以用进程控制块来唯一地标识每个进程。而这一点正是程序无法做到的，由于程序没有和数据产生直接的联系，既使是执行不同的数据的程序，他们的指令的集合依然是一样的，所以无法唯一地标识出这些运行于不同数据集上的程序。一般来说，一个进程肯定有一个与之对应的程序，而且只有一个。而一个程序有可能没有与之对应的进程(因为它没有执行),也有可能有多个进程与之对应(运行在几个不同的数据集上)。</p> 
<p>►简述进程与线程<br> 进程 资源分配的基本单位 进程之间的资源相互独立 一个进程含有一至多个线程 执行开销大创建时间长<br> 线程 任务调度和执行的基本单位 线程之间的资源共享 一个线程归属于一个进程 执行开销小创建时间短</p> 
<ul><li>进程：进程是能在系统中独立运行并作为资源分配的基本单位，是CPU分配资源的最小单位，它包括独立的地址空间，资源以及一至多个线程。</li><li>线程：线程是进程中的一个实体，是CPU调度的最小单位。</li><li>系统在运行时为每个进程分配不同的内存空间，而系统不会单独给线程分配内存空间</li><li>操作系统可以同时执行多个进程，每个进程执行多个线程</li></ul> 
<p>►中断处理的流程<br> 指某个事件 (例如电源掉电、定点加法溢出或 I/O传输结束等) 发生时，系统中止现行程序的运行、引出处理事件程序对该事件进行处理，处理完毕后返回断点，继续执行。<br> 处理流程：中断进入-&gt;保护现场-&gt;中断处理-&gt;恢复现场-&gt;中断返回</p> 
<p>►何为死锁？产生条件？如何避免\处理？<br> 在两个或多个并发进程中，如果每个进程持有某种资源而又都等待着别的进程释放它或它们现在保持着的资源，否则就不能向前推进。此时，称这一组进程产生了死锁。<br> 产生的必要条件：a.互斥条件（资源独占）b.不剥夺条件:c.部分分配（保持申请）d.环路条件(循环等待)<br> a.死锁预防（静态）b.死锁避免（动态） i.有序资源分配方法ii.银行家算法c.死锁恢复</p> 
<p>►用信号量（P、V操作）实现进程互斥与同步<br> 互斥：<br> （1）设置互斥量，初值为1<br> （2）临界区之前 P<br> （3）临界区之后 V<br> 同步：<br> （1）设置同步信号量初值为 0<br> （2）前操作 之后 V<br> （3）后操作 之前 P</p> 
<p>注意：先同步后互斥</p> 
<p>题：多进程推进次序问题：<br> 解决方法：</p> 
<ul><li>每两个有前后关系的进程（表现为进程推进图节点之间有边的进程）给边赋一个变量用于该边两端进程的同步</li><li>main : 初始化所有的变量为0，启动（begin/start）所有进程</li><li>每个进程内部：P（入边）-&gt; 执行代码 -&gt; V（出边）</li></ul> 
<p>题：共享缓冲区的合作进程的同步<br> 计算进程 a 经过计算，将计算结果送入缓冲区。打印进程 b 把缓冲区中的数据取出打印。<br> 关系：<br> 当 a 进程把计算结果送入缓冲区后， b 进程才能从缓冲区中取出结果去打印，否则必须等待。<br> 当 b 进程把缓冲区中的数据取出打印后，a 进程才能把下一个计算结果数据送入缓冲区中，否则必须等待。</p> 
<p>解决方法：</p> 
<ul><li>main：设置两个信号量：A表示是否有新结果供打印初值0，B表示是否有位置存放新信息初值1</li><li>计算进程a：产生数据 -&gt; P(B) -&gt;放入数据 -&gt; V(A)</li><li>打印进程b：P(A) -&gt; 取数据 -&gt;V(B) -&gt;打印</li></ul> 
<p>题：生产者——消费者问题：<br> 生产者和消费者在同一时间段内共用同一个存储空间，生产者往存储空间中添加产品，消费者从存储空间中取走产品，当存储空间为空时，消费者阻塞，当存储空间满时，生产者阻塞。生产者和消费者需要互斥的访问存储空间。</p> 
<p>解决方法：</p> 
<ul><li>main:设置三个信号量 ：mutex用于互斥、满缓冲区数目A初值为0、空缓冲区数目B初值为n</li><li>生产者：while(生产未结束){ P(B)、P(mutex)、生产、V(mutex)、V(A) }</li><li>消费者：while(消费未结束){ P(A)、P(mutex)、消费、V(mutex)、V(B) }<br> 流程即：<br> 生产者：获得空位 -&gt; 互斥访问空位（生产一个） -&gt; 产品+1<br> 消费者：获得产品 -&gt; 互斥访问产品（消费一个） -&gt; 空位+1</li></ul> 
<p>►银行家算法避免死锁求安全序列<br> 1.数据结构：<br> （1）利用资源向量Available[]：其中的每一个元素代表一类可利用的资源数目<br> （2）最大需求矩阵Max[][]：系统中n个进程中的每一个进程对m类资源的最大需求<br> （3）分配矩阵Allocation[][]：系统中每一类资源当前已分配给每一进程的资源数。<br> （4）需求矩阵Need[][]：每一个进程尚需的各类资源数。其中：Need[i,j]=Max[i,j]-Allocation[i,j]</p> 
<p>2.算法流程<br> (1)如果REQUEST [q] [i]&lt;= NEED[q][i]，则转(2)；否则，出错。<br> (2)如果REQUEST [q] [i]&lt;= AVAILABLE[i]，则转(3)；否则，等待。<br> (3)系统试探分配资源，修改相关数据：<br> AVAILABLE[i]-=REQUEST[q][i];<br> ALLOCATION[q][i]+=REQUEST[q][i];<br> NEED[q][i]-=REQUEST[q][i];<br> (4)系统执行安全性检查，如安全，则分配成立；否则试探险性分配作废，系统恢复原状，进程等待。</p> 
<p>3.安全性检查算法<br> (1)设置两个工作向量Work=AVAILABLE;FINISH<br> (2)从进程集合中找到一个满足下述条件的进程，<br> FINISH==false;<br> NEED&lt;=Work;<br> 如找到，执行（3)；否则，执行（4)<br> (3)设进程获得资源，可顺利执行，直至完成，从而释放资源。<br> Work=Work+ALLOCATION;<br> Finish=true;<br> GOTO 2<br> (4)如所有的进程Finish= true，则表示安全；否则系统不安全。</p> 
<p>解题步骤：<br> 1.根据题目信息画表：MAX、Allocation、need三个矩阵。<br> 2.分析题目中的需求（若没有给出就直接用need矩阵的值做判断）<br> 3.每次判断当前请求能否满足的方法：先用请求向量与系统当前资源向量work比较，若大于则可以满足，直接让work加上Allocation矩阵对应的那一行向量（实际意义时是该用户的请求可以满足并且在该进程运行完后归还了其持有的所有资源）<br> 4.实际解题时，读取到一个请求利用3 的方法判断是否可行，若可行则需要接着判断其他用户在该状态下是否可行（安全序列），方法是，判断当前用户后依次判断其他的可以满足 的用户，最后看是否所有用户都能被满足。<br> 注意这里可能某一状态有不止一个的用户，选取哪个用户进入安全序列需要利用回溯的思想，即每次都选取编号小的用户进入，若推到后面不满足了，就返回这个状态并选取下一个可行的用户继续判断，直到寻找到一个安全序列或者没有可行的用户（不安全）为止。</p> 
<p>►作业调度算法求周转时间</p> 
<ul><li>周转时间：一个作业提交给计算机系统到该作业的结果返回给用户所需要的时间（等待+运行）。</li><li>带权周转时间：一个作业的周转时间与其运行时间的比值 （了解）</li><li>作业调度算法 ：<br> i.先来先服务调度算法(FCFS)<br> ii.短作业优先调度算法<br> iii.响应比高者优先(响应比=响应时间/执行时间 =1+作业等待时间/执行时间)</li><li>数值上：响应比 = 带权周转时间</li></ul> 
<p>►分区存储（放置算法）求内存序列</p> 
<ul><li>放置策略（选择空闲区的策略）★★<br> 首次匹配(首次适应算法)：（地址最低）<br> 最佳匹配(最佳适应算法)：（与所需大小最接近）<br> 最坏匹配(最坏适应算法)：（与所需大小差距最大）</li></ul> 
<p>►页面调度（淘汰算法）求缺页中断次数</p> 
<ul><li>淘汰算法（置换策略）:<br> a.最佳算法(OPT算法) （实际无法实现）:(以后不再要用的，或者是在最长的时间以后才会用到的那页)<br> b.先进先出淘汰算法(FIFO算法) :(在主存中居留时间最长(即最早进入主存)的一页淘汰)<br> c.最久未使用淘汰算法(LRU算法):(最长时间未被使用的那一页淘汰)</li></ul> 
<p>解题步骤：<br> 首先画表格：横坐标是请求序列，纵坐标是实际物理地址的每一块<br> 然后开始填表<br> 1.最佳算法：每次检查当前请求的页号是否在物理内存中，若在直接处理下一个请求，若不在则在后续队列中找当前在物理内存中的页号，找到第一个相同的请求，记住它距离当前的距离，找到全部的物理内存中的页号对应的距离后，用当前请求置换出物理内存中距离最远的页号（最远代表将来最晚用到），依次重复即可<br> 以上过程中如果表格某一列是空白的（实际上是和前一列相同只不过没填）表示没有缺页中断，否则表示发生缺页中断。<br> 2.LRU算法：大致流程和（1）差不多，只是在置换时每次总是向前查找和物理内存最近一个相同的，然后在所有的距离里面找最大的替换（最大代表最久未使用）<br> 3.FIFO算法：也可用类似上面的方法，不过这里有更简单的算法，写一个队列，每次替换的时候都从队尾插入，淘汰队头即可。（类似于滑动窗口的感觉）</p> 
<p>例如：虚页大小为６，实页大小为３，请求序列为０１２１４２５６<br> 利用LRU算法：<br> 内存｜请求 ０ １ ２ 1 ４ ２ ５ 6<br> ０ 0 ０ ０ ４ ４ ６<br> １ 1 1 １ ５ ５<br> ２ ２ ２ 2 ２<br> 表中有６列非空，所以发生了缺页中断六次</p> 
<p>►Linux文件系统相关计算<br> linux文件系统：多级索引：在一个Linux的文件系统中可能同时有直接索引，一级文件索引，二级文件索引等</p> 
<p>题：<br> M：磁盘块大小即簇大小<br> N: 磁盘地址大小即地址项长度<br> T： 一个磁盘块可以容纳磁盘地址（即一个表项）的数量<br> S：支持文件的最大尺寸 （长度）<br> a 、b 、c 、……：直接地址数量、一级地址数量、二级……<br> 求：支持文件的最大尺寸的计算<br> 计算结果：<br> T = M / N<br> S = M*（a + b<em>T + c</em>T^2 + d*T^3……）</p> 
<p>例如：一个UNIX系统使用4KB磁盘块和8字节磁盘地址。若i节点有10个直接表项、一级二级三级间接块各一个，那么支持的文件尺寸最大多少 ？</p> 
<p>T = 4 KB / 8B = 4*2^10 / 8 = 2^9 = 512<br> S = (10 + T + T^2 +T^3)</p> 
<p>►磁盘读取文件时间计算<br> 注意：分开考虑，不需要整体考虑（如寻找扇区时同时也在寻道）。</p> 
<p>= 寻道时间 + 旋转时间 + 数据读取时间<br> 寻道时间（径向移动时间）= 跨越磁道数 * 单位用时<br> 旋转时间（切向移动时间）= 跨越扇区数 * 单位时间<br> 数据读取数据（切向读取）= 读取扇区数 * 单位时间（同上）</p> 
<p>►其它：<br> 单CPU操作系统进程不能并行只能并发<br> 被作业调度算法选中的作业会被调入主存进入就绪队列<br> 被进程调度算法选中的进程会从就绪队列转为运行状态投入运行<br> V操作或者有进程释放某种资源可能会使一个或几个进程由阻塞变就绪</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/0b5aad28ccdfc7ba90289807ce617f11/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">请求分页系统中的置换算法(FIFO、LRU、Optimal)</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/5a2426dc4c661743184bc70c54d5cabb/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">学习Java初期常见错误整理（更新中）</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>