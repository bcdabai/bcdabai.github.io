<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>数据结构入门（PTA题库） - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="数据结构入门（PTA题库）" />
<meta property="og:description" content="目录
6-1 顺序表操作集 (20 分)
6-2 线性表元素的区间删除 (20 分)
6-3 单链表逆转 (20 分)
6-4 两个有序链表序列的合并 (15 分)
7-1 两个有序序列的中位数 (25 分)
7-2 数组循环左移 (20 分)
7-3 最长连续递增子序列 (20 分)
7-5 求链式线性表的倒数第K项 (20 分)
7-6 两个有序链表序列的合并 (20 分)
7-7 两个有序链表序列的交集 (20 分)
7-8 重排链表 (25 分)
7-9 链表去重 (25 分)
6-1 顺序表操作集 (20 分) 本题要求实现顺序表的操作集。
函数接口定义： List MakeEmpty(); Position Find( List L, ElementType X ); bool Insert( List L, ElementType X, Position P ); bool Delete( List L, Position P ); 其中List结构定义如下：" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/e52d91dca140121086e23ab32c076af8/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2021-10-06T09:04:57+08:00" />
<meta property="article:modified_time" content="2021-10-06T09:04:57+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">数据结构入门（PTA题库）</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p id="main-toc"><strong>目录</strong></p> 
<p id="6-1%20%E9%A1%BA%E5%BA%8F%E8%A1%A8%E6%93%8D%E4%BD%9C%E9%9B%86%20(20%20%E5%88%86)-toc" style="margin-left:40px;"><a href="#6-1%20%E9%A1%BA%E5%BA%8F%E8%A1%A8%E6%93%8D%E4%BD%9C%E9%9B%86%20%2820%20%E5%88%86%29" rel="nofollow" title="6-1 顺序表操作集 (20 分)">6-1 顺序表操作集 (20 分)</a></p> 
<p id="6-2%20%E7%BA%BF%E6%80%A7%E8%A1%A8%E5%85%83%E7%B4%A0%E7%9A%84%E5%8C%BA%E9%97%B4%E5%88%A0%E9%99%A4%20(20%20%E5%88%86)-toc" style="margin-left:40px;"><a href="#6-2%20%E7%BA%BF%E6%80%A7%E8%A1%A8%E5%85%83%E7%B4%A0%E7%9A%84%E5%8C%BA%E9%97%B4%E5%88%A0%E9%99%A4%20%2820%20%E5%88%86%29" rel="nofollow" title="6-2 线性表元素的区间删除 (20 分)">6-2 线性表元素的区间删除 (20 分)</a></p> 
<p id="6-3%20%E5%8D%95%E9%93%BE%E8%A1%A8%E9%80%86%E8%BD%AC%20(20%20%E5%88%86)-toc" style="margin-left:40px;"><a href="#6-3%20%E5%8D%95%E9%93%BE%E8%A1%A8%E9%80%86%E8%BD%AC%20%2820%20%E5%88%86%29" rel="nofollow" title="6-3 单链表逆转 (20 分)">6-3 单链表逆转 (20 分)</a></p> 
<p id="6-4%20%E4%B8%A4%E4%B8%AA%E6%9C%89%E5%BA%8F%E9%93%BE%E8%A1%A8%E5%BA%8F%E5%88%97%E7%9A%84%E5%90%88%E5%B9%B6%20(15%20%E5%88%86)-toc" style="margin-left:40px;"><a href="#6-4%20%E4%B8%A4%E4%B8%AA%E6%9C%89%E5%BA%8F%E9%93%BE%E8%A1%A8%E5%BA%8F%E5%88%97%E7%9A%84%E5%90%88%E5%B9%B6%20%2815%20%E5%88%86%29" rel="nofollow" title="6-4 两个有序链表序列的合并 (15 分)">6-4 两个有序链表序列的合并 (15 分)</a></p> 
<p id="7-1%20%E4%B8%A4%E4%B8%AA%E6%9C%89%E5%BA%8F%E5%BA%8F%E5%88%97%E7%9A%84%E4%B8%AD%E4%BD%8D%E6%95%B0%20(25%20%E5%88%86)-toc" style="margin-left:40px;"><a href="#7-1%20%E4%B8%A4%E4%B8%AA%E6%9C%89%E5%BA%8F%E5%BA%8F%E5%88%97%E7%9A%84%E4%B8%AD%E4%BD%8D%E6%95%B0%20%2825%20%E5%88%86%29" rel="nofollow" title="7-1 两个有序序列的中位数 (25 分)">7-1 两个有序序列的中位数 (25 分)</a></p> 
<p id="7-2%20%E6%95%B0%E7%BB%84%E5%BE%AA%E7%8E%AF%E5%B7%A6%E7%A7%BB%20(20%20%E5%88%86)-toc" style="margin-left:40px;"><a href="#7-2%20%E6%95%B0%E7%BB%84%E5%BE%AA%E7%8E%AF%E5%B7%A6%E7%A7%BB%20%2820%20%E5%88%86%29" rel="nofollow" title="7-2 数组循环左移 (20 分)">7-2 数组循环左移 (20 分)</a></p> 
<p id="7-3%20%E6%9C%80%E9%95%BF%E8%BF%9E%E7%BB%AD%E9%80%92%E5%A2%9E%E5%AD%90%E5%BA%8F%E5%88%97%20(20%20%E5%88%86)-toc" style="margin-left:40px;"><a href="#7-3%20%E6%9C%80%E9%95%BF%E8%BF%9E%E7%BB%AD%E9%80%92%E5%A2%9E%E5%AD%90%E5%BA%8F%E5%88%97%20%2820%20%E5%88%86%29" rel="nofollow" title="7-3 最长连续递增子序列 (20 分)">7-3 最长连续递增子序列 (20 分)</a></p> 
<p id="7-5%20%E6%B1%82%E9%93%BE%E5%BC%8F%E7%BA%BF%E6%80%A7%E8%A1%A8%E7%9A%84%E5%80%92%E6%95%B0%E7%AC%ACK%E9%A1%B9%20(20%20%E5%88%86)-toc" style="margin-left:40px;"><a href="#7-5%20%E6%B1%82%E9%93%BE%E5%BC%8F%E7%BA%BF%E6%80%A7%E8%A1%A8%E7%9A%84%E5%80%92%E6%95%B0%E7%AC%ACK%E9%A1%B9%20%2820%20%E5%88%86%29" rel="nofollow" title="7-5 求链式线性表的倒数第K项 (20 分)">7-5 求链式线性表的倒数第K项 (20 分)</a></p> 
<p id="7-6%20%E4%B8%A4%E4%B8%AA%E6%9C%89%E5%BA%8F%E9%93%BE%E8%A1%A8%E5%BA%8F%E5%88%97%E7%9A%84%E5%90%88%E5%B9%B6%20(20%20%E5%88%86)-toc" style="margin-left:40px;"><a href="#7-6%20%E4%B8%A4%E4%B8%AA%E6%9C%89%E5%BA%8F%E9%93%BE%E8%A1%A8%E5%BA%8F%E5%88%97%E7%9A%84%E5%90%88%E5%B9%B6%20%2820%20%E5%88%86%29" rel="nofollow" title="7-6 两个有序链表序列的合并 (20 分)">7-6 两个有序链表序列的合并 (20 分)</a></p> 
<p id="7-7%20%E4%B8%A4%E4%B8%AA%E6%9C%89%E5%BA%8F%E9%93%BE%E8%A1%A8%E5%BA%8F%E5%88%97%E7%9A%84%E4%BA%A4%E9%9B%86%20(20%20%E5%88%86)-toc" style="margin-left:40px;"><a href="#7-7%20%E4%B8%A4%E4%B8%AA%E6%9C%89%E5%BA%8F%E9%93%BE%E8%A1%A8%E5%BA%8F%E5%88%97%E7%9A%84%E4%BA%A4%E9%9B%86%20%2820%20%E5%88%86%29" rel="nofollow" title="7-7 两个有序链表序列的交集 (20 分)">7-7 两个有序链表序列的交集 (20 分)</a></p> 
<p id="7-8%20%E9%87%8D%E6%8E%92%E9%93%BE%E8%A1%A8%20(25%20%E5%88%86)-toc" style="margin-left:40px;"><a href="#7-8%20%E9%87%8D%E6%8E%92%E9%93%BE%E8%A1%A8%20%2825%20%E5%88%86%29" rel="nofollow" title="7-8 重排链表 (25 分)">7-8 重排链表 (25 分)</a></p> 
<p id="7-9%20%E9%93%BE%E8%A1%A8%E5%8E%BB%E9%87%8D%20(25%20%E5%88%86)-toc" style="margin-left:40px;"><a href="#7-9%20%E9%93%BE%E8%A1%A8%E5%8E%BB%E9%87%8D%20%2825%20%E5%88%86%29" rel="nofollow" title="7-9 链表去重 (25 分)">7-9 链表去重 (25 分)</a></p> 
<hr id="hr-toc"> 
<h3 id="6-1%20%E9%A1%BA%E5%BA%8F%E8%A1%A8%E6%93%8D%E4%BD%9C%E9%9B%86%20(20%20%E5%88%86)">6-1 顺序表操作集 (20 分)</h3> 
<p>本题要求实现顺序表的操作集。</p> 
<h4 id="函数接口定义：">函数接口定义：</h4> 
<pre><code>List MakeEmpty(); 
Position Find( List L, ElementType X );
bool Insert( List L, ElementType X, Position P );
bool Delete( List L, Position P );</code></pre> 
<p>其中<code>List</code>结构定义如下：</p> 
<pre><code>typedef int Position;
typedef struct LNode *List;
struct LNode {
    ElementType Data[MAXSIZE];
    Position Last; /* 保存线性表中最后一个元素的位置 */
};</code></pre> 
<p>各个操作函数的定义为：</p> 
<p><code>List MakeEmpty()</code>：创建并返回一个空的线性表；</p> 
<p><code>Position Find( List L, ElementType X )</code>：返回线性表中X的位置。若找不到则返回ERROR；</p> 
<p><code>bool Insert( List L, ElementType X, Position P )</code>：将X插入在位置P并返回true。若空间已满，则打印“FULL”并返回false；如果参数P指向非法位置，则打印“ILLEGAL POSITION”并返回false；</p> 
<p><code>bool Delete( List L, Position P )</code>：将位置P的元素删除并返回true。若参数P指向非法位置，则打印“POSITION P EMPTY”（其中P是参数值）并返回false。</p> 
<h4 id="裁判测试程序样例：">裁判测试程序样例：</h4> 
<pre><code>#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

#define MAXSIZE 5
#define ERROR -1
typedef enum {false, true} bool;
typedef int ElementType;
typedef int Position;
typedef struct LNode *List;
struct LNode {
    ElementType Data[MAXSIZE];
    Position Last; /* 保存线性表中最后一个元素的位置 */
};

List MakeEmpty(); 
Position Find( List L, ElementType X );
bool Insert( List L, ElementType X, Position P );
bool Delete( List L, Position P );

int main()
{
    List L;
    ElementType X;
    Position P;
    int N;

    L = MakeEmpty();
    scanf("%d", &amp;N);
    while ( N-- ) {
        scanf("%d", &amp;X);
        if ( Insert(L, X, 0)==false )
            printf(" Insertion Error: %d is not in.\n", X);
    }
    scanf("%d", &amp;N);
    while ( N-- ) {
        scanf("%d", &amp;X);
        P = Find(L, X);
        if ( P == ERROR )
            printf("Finding Error: %d is not in.\n", X);
        else
            printf("%d is at position %d.\n", X, P);
    }
    scanf("%d", &amp;N);
    while ( N-- ) {
        scanf("%d", &amp;P);
        if ( Delete(L, P)==false )
            printf(" Deletion Error.\n");
        if ( Insert(L, 0, P)==false )
            printf(" Insertion Error: 0 is not in.\n");
    }
    return 0;
}

/* 你的代码将被嵌在这里 */</code></pre> 
<h4 id="输入样例：">输入样例：</h4> 
<pre><code>6
1 2 3 4 5 6
3
6 5 1
2
-1 6</code></pre> 
<p>结尾无空行</p> 
<h4 id="输出样例：">输出样例：</h4> 
<pre><code>FULL Insertion Error: 6 is not in.
Finding Error: 6 is not in.
5 is at position 0.
1 is at position 4.
POSITION -1 EMPTY Deletion Error.
FULL Insertion Error: 0 is not in.
POSITION 6 EMPTY Deletion Error.
FULL Insertion Error: 0 is not in.</code></pre> 
<p>结尾无空行</p> 
<h3 id="%E7%AD%94%E6%A1%88%EF%BC%9A">答案：</h3> 
<pre><code>List MakeEmpty()
{
    List L;
    L = (List)malloc(sizeof(struct LNode));
    L-&gt;Last = -1;
    return L;
}
Position Find(List L, ElementType X)
{
    Position i;
    for (i = 0; i &lt;= L-&gt;Last; i++)
        if (L-&gt;Data[i] == X)
            return i;
    return ERROR;
}
bool Insert(List L, ElementType X, Position P)
{
    if (L-&gt;Last == MAXSIZE - 1)
    {
        printf("FULL");
        return false;
    }
    else if (P &lt; 0 || P &gt; L-&gt;Last + 1)
    {
        printf("ILLEGAL POSITION");
        return false;
    }
    else
    {
        Position i;
        for (i = L-&gt;Last; i &gt;= P; i--)
            L-&gt;Data[i + 1] = L-&gt;Data[i];
        L-&gt;Last++;
        L-&gt;Data[P] = X;
        return true;
    }
}
bool Delete(List L, Position P)
{
    if (P &lt; 0 || P &gt; L-&gt;Last)
    {
        printf("POSITION %d EMPTY", P);
        return false;
    }
    else
    {
        Position i;
        for (i = P + 1; i &lt;= L-&gt;Last; i++)
            L-&gt;Data[i - 1] = L-&gt;Data[i];
        L-&gt;Last--;
        return true;
    }
}</code></pre> 
<h3 id="%E5%88%86%E6%9E%90%EF%BC%9A">分析：</h3> 
<blockquote> 
 <p><span style="color:#956fe7;"><strong>C语言中的bool类型</strong></span></p> 
 <pre><code>typedef enum
{
    false,
    true
} bool;</code></pre> 
</blockquote> 
<blockquote> 
 <p><span style="color:#956fe7;"><strong>malloc</strong></span></p> 
 <p>1、在调用malloc函数时需要进行强制类型转换。所转换的类型为 “ = ” 左边的变量的类型。</p> 
 <p> 2、所申请的空间大小应为该变量的类型名。而非指向该类型的指针类型。</p> 
 <p>3、在被调用函数中，当函数结束时会清除变量的内存空间，而动态申请的内存空间会在程序结束时自动清除。</p> 
</blockquote> 
<h3 id="6-2%20%E7%BA%BF%E6%80%A7%E8%A1%A8%E5%85%83%E7%B4%A0%E7%9A%84%E5%8C%BA%E9%97%B4%E5%88%A0%E9%99%A4%20(20%20%E5%88%86)">6-2 线性表元素的区间删除 (20 分)</h3> 
<p>给定一个顺序存储的线性表，请设计一个函数删除所有值大于min而且小于max的元素。删除后表中剩余元素保持顺序存储，并且相对位置不能改变。</p> 
<h4 id="%E5%87%BD%E6%95%B0%E6%8E%A5%E5%8F%A3%E5%AE%9A%E4%B9%89%EF%BC%9A">函数接口定义：</h4> 
<pre><code>List Delete( List L, ElementType minD, ElementType maxD );</code></pre> 
<p>其中<code>List</code>结构定义如下：</p> 
<pre><code>typedef int Position;
typedef struct LNode *List;
struct LNode {
    ElementType Data[MAXSIZE];
    Position Last; /* 保存线性表中最后一个元素的位置 */
};</code></pre> 
<p><code>L</code>是用户传入的一个线性表，其中<code>ElementType</code>元素可以通过&gt;、==、&lt;进行比较；<code>minD</code>和<code>maxD</code>分别为待删除元素的值域的下、上界。函数<code>Delete</code>应将<code>Data[]</code>中所有值大于<code>minD</code>而且小于<code>maxD</code>的元素删除，同时保证表中剩余元素保持顺序存储，并且相对位置不变，最后返回删除后的表。</p> 
<h4 id="%E8%A3%81%E5%88%A4%E6%B5%8B%E8%AF%95%E7%A8%8B%E5%BA%8F%E6%A0%B7%E4%BE%8B%EF%BC%9A">裁判测试程序样例：</h4> 
<pre><code>#include &lt;stdio.h&gt;

#define MAXSIZE 20
typedef int ElementType;

typedef int Position;
typedef struct LNode *List;
struct LNode {
    ElementType Data[MAXSIZE];
    Position Last; /* 保存线性表中最后一个元素的位置 */
};

List ReadInput(); /* 裁判实现，细节不表。元素从下标0开始存储 */
void PrintList( List L ); /* 裁判实现，细节不表 */
List Delete( List L, ElementType minD, ElementType maxD );

int main()
{
    List L;
    ElementType minD, maxD;
    int i;

    L = ReadInput();
    scanf("%d %d", &amp;minD, &amp;maxD);
    L = Delete( L, minD, maxD );
    PrintList( L );

    return 0;
}

/* 你的代码将被嵌在这里 */</code></pre> 
<h4 id="%E8%BE%93%E5%85%A5%E6%A0%B7%E4%BE%8B%EF%BC%9A">输入样例：</h4> 
<pre><code>10
4 -8 2 12 1 5 9 3 3 10
0 4</code></pre> 
<p>结尾无空行</p> 
<h4 id="%E8%BE%93%E5%87%BA%E6%A0%B7%E4%BE%8B%EF%BC%9A">输出样例：</h4> 
<pre><code>4 -8 12 5 9 10 </code></pre> 
<p>结尾无空行</p> 
<h4 id="%C2%A0%E7%AD%94%E6%A1%88%EF%BC%9A"> 答案：</h4> 
<pre><code>List Delete(List L, ElementType minD, ElementType maxD)
{
    Position num = 0, i;
    for (i = 0; i &lt;= L-&gt;Last; i++)
        if (L-&gt;Data[i] &lt;= minD || L-&gt;Data[i] &gt;= maxD)
            L-&gt;Data[num++] = L-&gt;Data[i];
    L-&gt;Last = num - 1;
    return L;
}</code></pre> 
<h4>分析：</h4> 
<blockquote> 
 <p><strong><span style="color:#956fe7;">算法</span></strong></p> 
 <p>遍历顺序表中的每一个元素。</p> 
 <p>对每一个元素进行检查，判断是否在（minD，maxD）区间内，若在，则读取下一个元素；若不在，则把该元素以尾插法放在新的顺序表中。</p> 
 <p>思路与 “ 就地逆置一个表 ” 的思路比较相像。</p> 
</blockquote> 
<h3 id="6-3%20%E5%8D%95%E9%93%BE%E8%A1%A8%E9%80%86%E8%BD%AC%20(20%20%E5%88%86)">6-3 单链表逆转 (20 分)</h3> 
<p>本题要求实现一个函数，将给定的单链表逆转。</p> 
<h4>函数接口定义：</h4> 
<pre><code>List Reverse( List L );</code></pre> 
<p>其中<code>List</code>结构定义如下：</p> 
<pre><code>typedef struct Node *PtrToNode;
struct Node {
    ElementType Data; /* 存储结点数据 */
    PtrToNode   Next; /* 指向下一个结点的指针 */
};
typedef PtrToNode List; /* 定义单链表类型 */</code></pre> 
<p><code>L</code>是给定单链表，函数<code>Reverse</code>要返回被逆转后的链表。</p> 
<h4>裁判测试程序样例：</h4> 
<pre><code>#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

typedef int ElementType;
typedef struct Node *PtrToNode;
struct Node {
    ElementType Data;
    PtrToNode   Next;
};
typedef PtrToNode List;

List Read(); /* 细节在此不表 */
void Print( List L ); /* 细节在此不表 */

List Reverse( List L );

int main()
{
    List L1, L2;
    L1 = Read();
    L2 = Reverse(L1);
    Print(L1);
    Print(L2);
    return 0;
}

/* 你的代码将被嵌在这里 */</code></pre> 
<h4>输入样例：</h4> 
<pre><code>5
1 3 4 5 2</code></pre> 
<p>结尾无空行</p> 
<h4>输出样例：</h4> 
<pre><code>1
2 5 4 3 1</code></pre> 
<p>结尾无空行</p> 
<h4 id="%C2%A0%E7%AD%94%E6%A1%881%EF%BC%9A"> 答案1：</h4> 
<pre><code>List Reverse(List L)
{
    struct Node *p = NULL, *q = NULL;
    while(L){
        p = L-&gt;Next;
        L-&gt;Next = q;
        q = L;
        L = p;
    }
    return q;
}</code></pre> 
<h4>分析：</h4> 
<blockquote> 
 <p><span style="color:#956fe7;"><strong>思路</strong></span></p> 
 <p>遍历L，每一次都要把L中的第一个结点以头插法的方式插到新的q链表中。</p> 
</blockquote> 
<h4 id="%E7%AD%94%E6%A1%882%EF%BC%9A%C2%A0">答案2： </h4> 
<pre><code>List Reverse(List L)
{
    if (L)
    {
        struct Node *p1, *p2;
        p1 = L-&gt;Next;
        L-&gt;Next = NULL;
        while (p1)
        {
            p2 = p1-&gt;Next;
            p1-&gt;Next = L;
            L = p1;
            p1 = p2;
        }
    }
    return L;
}</code></pre> 
<h4>分析：</h4> 
<blockquote> 
 <p><span style="color:#956fe7;"><strong>第四个测试点</strong></span></p> 
 <p>当L为空时，需要返回NULL。因而需要有一个 if (L) 的判断。</p> 
</blockquote> 
<blockquote> 
 <p><span style="color:#956fe7;"><strong>思路</strong></span></p> 
 <p><a class="link-info" href="https://blog.csdn.net/peanutpeanuta/article/details/119377271?spm=1001.2014.3001.5502" title="带哨兵的单链表的就地逆置">带哨兵的单链表的就地逆置</a></p> 
</blockquote> 
<h3 id="6-4%20%E4%B8%A4%E4%B8%AA%E6%9C%89%E5%BA%8F%E9%93%BE%E8%A1%A8%E5%BA%8F%E5%88%97%E7%9A%84%E5%90%88%E5%B9%B6%20(15%20%E5%88%86)">6-4 两个有序链表序列的合并 (15 分)</h3> 
<p>本题要求实现一个函数，将两个链表表示的递增整数序列合并为一个非递减的整数序列。</p> 
<h4>函数接口定义：</h4> 
<pre><code>List Merge( List L1, List L2 );</code></pre> 
<p>其中<code>List</code>结构定义如下：</p> 
<pre><code>typedef struct Node *PtrToNode;
struct Node {
    ElementType Data; /* 存储结点数据 */
    PtrToNode   Next; /* 指向下一个结点的指针 */
};
typedef PtrToNode List; /* 定义单链表类型 */</code></pre> 
<p><code>L1</code>和<code>L2</code>是给定的带头结点的单链表，其结点存储的数据是递增有序的；函数<code>Merge</code>要将<code>L1</code>和<code>L2</code>合并为一个非递减的整数序列。应直接使用原序列中的结点，返回归并后的带头结点的链表头指针。</p> 
<h4>裁判测试程序样例：</h4> 
<pre><code>#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

typedef int ElementType;
typedef struct Node *PtrToNode;
struct Node {
    ElementType Data;
    PtrToNode   Next;
};
typedef PtrToNode List;

List Read(); /* 细节在此不表 */
void Print( List L ); /* 细节在此不表；空链表将输出NULL */

List Merge( List L1, List L2 );

int main()
{
    List L1, L2, L;
    L1 = Read();
    L2 = Read();
    L = Merge(L1, L2);
    Print(L);
    Print(L1);
    Print(L2);
    return 0;
}

/* 你的代码将被嵌在这里 */</code></pre> 
<h4>输入样例：</h4> 
<pre><code>3
1 3 5
5
2 4 6 8 10</code></pre> 
<p>结尾无空行</p> 
<h4>输出样例：</h4> 
<pre><code>1 2 3 4 5 6 8 10 
NULL
NULL</code></pre> 
<p>结尾无空行</p> 
<h4> 答案：</h4> 
<pre><code>List Merge(List L1, List L2)
{
    struct Node *head = (struct Node *)malloc(sizeof(struct Node));
    struct Node *p0 = head, *p1 = L1-&gt;Next, *p2 = L2-&gt;Next;
    while (p1 &amp;&amp; p2)
    {
        if (p1-&gt;Data &lt; p2-&gt;Data)
        {
            p0-&gt;Next = p1;
            p0 = p1;
            p1 = p1-&gt;Next;
        }
        else
        {
            p0-&gt;Next = p2;
            p0 = p2;
            p2 = p2-&gt;Next;
        }
    }
    if (!p1)
        p0-&gt;Next = p2;
    else
        p0-&gt;Next = p1;
    L1-&gt;Next = NULL;
    L2-&gt;Next = NULL;
    return head;
}</code></pre> 
<h4>分析：</h4> 
<blockquote> 
 <p><span style="color:#956fe7;"><strong>对题目的理解要到位</strong></span></p> 
 <p>根据 “ 输出样例 ” 可以知道，题目的意思是将两个链表合并到第三个链表中。</p> 
 <p>形象地来讲就是把两个递增的链表中的结点按非递减的顺序 “ 挪 ” 到第三个链表中。也就是说，<strong>“ 挪 ”之后的链表将成为空链表</strong>。因而在merge函数中需要额外申请一块内存来记录第三个新链表的头结点。<strong>用head变量来记录新头结点的地址，最后返回head</strong>。</p> 
</blockquote> 
<h3 id="7-1%20%E4%B8%A4%E4%B8%AA%E6%9C%89%E5%BA%8F%E5%BA%8F%E5%88%97%E7%9A%84%E4%B8%AD%E4%BD%8D%E6%95%B0%20(25%20%E5%88%86)">7-1 两个有序序列的中位数 (25 分)</h3> 
<p>已知有两个等长的非降序序列S1, S2, 设计函数求S1与S2并集的中位数。有序序列A0​,A1​,⋯,AN−1​的中位数指A(N−1)/2​的值,即第⌊(N+1)/2⌋个数（A0​为第1个数）。</p> 
<h4 id="输入格式">输入格式:</h4> 
<p>输入分三行。第一行给出序列的公共长度N（0&lt;N≤100000），随后每行输入一个序列的信息，即N个非降序排列的整数。数字用空格间隔。</p> 
<h4 id="输出格式">输出格式:</h4> 
<p>在一行中输出两个输入序列的并集序列的中位数。</p> 
<h4 id="输入样例1">输入样例1:</h4> 
<pre><code>5
1 3 5 7 9
2 3 4 5 6</code></pre> 
<p>结尾无空行</p> 
<h4 id="输出样例1">输出样例1:</h4> 
<pre><code>4</code></pre> 
<p>结尾无空行</p> 
<h4 id="输入样例2">输入样例2:</h4> 
<pre><code>6
-100 -10 1 1 1 1
-50 0 2 3 4 5</code></pre> 
<h4 id="输出样例2">输出样例2:</h4> 
<pre><code>1</code></pre> 
<h4> 答案：</h4> 
<pre><code>#include &lt;stdio.h&gt;
int main()
{
    int n, i, j, l, x;
    int a0[100000], a1[100000];
    scanf("%d", &amp;n);
    for (l = 0; l &lt; n; l++)
        scanf("%d", &amp;a0[l]);
    for (l = 0; l &lt; n; l++)
        scanf("%d", &amp;a1[l]);
    i = j = 0;
    while (n--)
    {
        if (a0[i] &lt; a1[j])
        {
            x = a0[i];
            i++;
        }
        else
        {
            x = a1[j];
            j++;
        }
    }
    printf("%d", x);
    return 0;
}</code></pre> 
<h4>分析：</h4> 
<blockquote> 
 <p><span style="color:#956fe7;"><strong>思路</strong></span></p> 
 <p>该题其实就是在这2n个数中输出第n个最小的数。</p> 
 <p>设置两个变量 i 和 j ，分别遍历第一、二个序列，用变量 x 来记录当前读到的最大值，直到读到第n个数为止。输出 x 即可 </p> 
</blockquote> 
<h3 id="7-2%20%E6%95%B0%E7%BB%84%E5%BE%AA%E7%8E%AF%E5%B7%A6%E7%A7%BB%20(20%20%E5%88%86)">7-2 数组循环左移 (20 分)</h3> 
<p>本题要求实现一个对数组进行循环左移的简单函数：一个数组a中存有n（&gt;0）个整数，在不允许使用另外数组的前提下，将每个整数循环向左移m（≥0）个位置，即将a中的数据由（a0​a1​⋯an−1​）变换为（am​⋯an−1​a0​a1​⋯am−1​）（最前面的m个数循环移至最后面的m个位置）。如果还需要考虑程序移动数据的次数尽量少，要如何设计移动的方法？</p> 
<h4 id="%E8%BE%93%E5%85%A5%E6%A0%BC%E5%BC%8F%3A">输入格式:</h4> 
<p>输入第1行给出正整数n（≤100）和整数m（≥0）；第2行给出n个整数，其间以空格分隔。</p> 
<h4 id="%E8%BE%93%E5%87%BA%E6%A0%BC%E5%BC%8F%3A">输出格式:</h4> 
<p>在一行中输出循环左移m位以后的整数序列，之间用空格分隔，序列结尾不能有多余空格。</p> 
<h4>输入样例：</h4> 
<pre><code>8 3
1 2 3 4 5 6 7 8</code></pre> 
<p>结尾无空行</p> 
<h4>输出样例：</h4> 
<pre><code>4 5 6 7 8 1 2 3</code></pre> 
<p>结尾无空行</p> 
<h4> 答案：</h4> 
<pre><code>#include &lt;stdio.h&gt;
int main()
{
    int n, m;
    scanf("%d %d", &amp;n, &amp;m);
    int a[100], i;
    for (i = 0; i &lt; n; i++)
        scanf("%d", &amp;a[i]);
    m %= n;
    for (i = m; i &lt; n; i++)
    {
        printf("%d", a[i]);
        if (m || i != n - 1)
            putchar(32);
    }
    for (i = 0; i &lt; m; i++)
    {
        printf("%d", a[i]);
        if (i != m - 1)
            putchar(32);
    }
    return 0;
}</code></pre> 
<h4>分析：</h4> 
<blockquote> 
 <p><span style="color:#956fe7;"><strong>putchar ( 10 ) 与 putchar ( 32 )</strong></span></p> 
 <p>putchar ( 10 ) : 回车</p> 
 <p>putchar ( 32 ) : 空格</p> 
</blockquote> 
<blockquote> 
 <p><span style="color:#956fe7;"><strong>m的取值</strong></span></p> 
 <p>1、m小于n时：第一个输出的值是a[m]</p> 
 <p>2、m大于等于n时：第一个输出的值是a[m%n] </p> 
</blockquote> 
<blockquote> 
 <p><span style="color:#956fe7;"><strong>输出格式</strong></span></p> 
 <p>当m==0时：只走第一个循环，第二个循环进不去，所以在第一个循环输出最后一个数之后不能再输出空格。 </p> 
</blockquote> 
<h3 id="7-3%20%E6%9C%80%E9%95%BF%E8%BF%9E%E7%BB%AD%E9%80%92%E5%A2%9E%E5%AD%90%E5%BA%8F%E5%88%97%20(20%20%E5%88%86)">7-3 最长连续递增子序列 (20 分)</h3> 
<p>给定一个顺序存储的线性表，请设计一个算法查找该线性表中最长的连续递增子序列。例如，(1,9,2,5,7,3,4,6,8,0)中最长的递增子序列为(3,4,6,8)。</p> 
<h4>输入格式:</h4> 
<p>输入第1行给出正整数n（≤105）；第2行给出n个整数，其间以空格分隔。</p> 
<h4>输出格式:</h4> 
<p>在一行中输出第一次出现的最长连续递增子序列，数字之间用空格分隔，序列结尾不能有多余空格。</p> 
<h4>输入样例：</h4> 
<pre><code>15
1 9 2 5 7 3 4 6 8 0 11 15 17 17 10</code></pre> 
<p>结尾无空行</p> 
<h4>输出样例：</h4> 
<pre><code>3 4 6 8</code></pre> 
<p>结尾无空行</p> 
<h4> 答案：</h4> 
<pre><code>#include &lt;stdio.h&gt;
int main()
{
    int i, n, a[100000];
    scanf("%d", &amp;n);
    for (i = 0; i &lt; n; i++)
        scanf("%d", &amp;a[i]);
    //读入部分
    int sign = 0, len0 = 0;
    for (i = 0; i &lt; n; i++)
    {
        int len = 1;
        while (a[i] &lt; a[i + 1])
        {
            i++;
            len++;
        }
        if (len &gt; len0)
        {
            len0 = len;
            sign = i;
        }
    }
    //核心
    for (i = 0; i &lt; len0; i++)
    {
        printf("%d", a[sign - len0 + i + 1]);
        if (i != len0 - 1)
            putchar(32);
    }
    //PRINT
    return 0;
}</code></pre> 
<h4>分析：</h4> 
<blockquote> 
 <p><span style="color:#956fe7;"><strong>变量解释</strong></span></p> 
 <p>sign：标记最长连续递增子序列的最后一个元素的下标</p> 
 <p>len0：标记最长连续递增子序列的长度</p> 
</blockquote> 
<blockquote> 
 <p><span style="color:#956fe7;"><strong>思路</strong></span></p> 
 <p>for循环用来遍历顺序表。</p> 
 <p>while循环用来将顺序表分为若干个递增的子序列；并且用 i 表示 当前子序列的最后一个元素的下标，len表示当前子序列的长度。</p> 
 <p>if条件句用来记录最长连续递增子序列的最后一个元素的下标及其长度，并用sign和len0来记录。</p> 
</blockquote> 
<h3 id="7-5%20%E6%B1%82%E9%93%BE%E5%BC%8F%E7%BA%BF%E6%80%A7%E8%A1%A8%E7%9A%84%E5%80%92%E6%95%B0%E7%AC%ACK%E9%A1%B9%20(20%20%E5%88%86)">7-5 求链式线性表的倒数第K项 (20 分)</h3> 
<p>给定一系列正整数，请设计一个尽可能高效的算法，查找倒数第K个位置上的数字。</p> 
<h4>输入格式:</h4> 
<p>输入首先给出一个正整数K，随后是若干非负整数，最后以一个负整数表示结尾（该负数不算在序列内，不要处理）。</p> 
<h4>输出格式:</h4> 
<p>输出倒数第K个位置上的数据。如果这个位置不存在，输出错误信息<code>NULL</code>。</p> 
<h4 id="输入样例">输入样例:</h4> 
<pre><code>4 1 2 3 4 5 6 7 8 9 0 -1</code></pre> 
<p>结尾无空行</p> 
<h4 id="输出样例">输出样例:</h4> 
<pre><code>7</code></pre> 
<p>结尾无空行</p> 
<h4> 答案：</h4> 
<pre><code>#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
typedef struct
{
    int data;
    struct node *next;
} * list, node;
//结点
int len = 0;
//链表长度
int main()
{
    list head = (node *)malloc(sizeof(node));
    head-&gt;next = NULL;
    node *p0 = head;
    int n;
    scanf("%d", &amp;n);
    int x;
    scanf("%d", &amp;x);
    while (x &gt;= 0)
    {
        node *p = (node *)malloc(sizeof(node));
        p-&gt;data = x;
        p-&gt;next = NULL;
        p0-&gt;next = p;
        p0 = p0-&gt;next;
        len++;
        scanf("%d", &amp;x);
    }
    if (n &gt; 0 &amp;&amp; n &lt;= len)
    {
        int i;
        p0 = head;
        for (i = 1; i &lt;= len - n + 1; i++)
            p0 = p0-&gt;next;
        printf("%d", p0-&gt;data);
    }
    else
        printf("NULL");
    return 0;
}</code></pre> 
<h4>分析：</h4> 
<blockquote> 
 <p><span style="color:#956fe7;"><strong>注意</strong></span></p> 
 <p>该题必须自己设计链表，不能用顺序表。因为顺序表需要提前设置好规模，而题目并没有设定规模。假若使用动态顺序表，那么太麻烦，不如直接用链表。所以还是按照题目本身的意思来写最简便。</p> 
 <p>为了方便找到倒数第n个结点，设置变量len来记录链表的长度。</p> 
 <p>最后输出要判断n是否在合法范围内，即看看n是不是在1到len之间。</p> 
</blockquote> 
<blockquote> 
 <p><span style="color:#956fe7;"><strong>malloc</strong></span></p> 
 <p> malloc 函数在头文件 stdlib.h 中。</p> 
</blockquote> 
<h3 id="7-6%20%E4%B8%A4%E4%B8%AA%E6%9C%89%E5%BA%8F%E9%93%BE%E8%A1%A8%E5%BA%8F%E5%88%97%E7%9A%84%E5%90%88%E5%B9%B6%20(20%20%E5%88%86)">7-6 两个有序链表序列的合并 (20 分)</h3> 
<p>已知两个非降序链表序列S1与S2，设计函数构造出S1与S2合并后的新的非降序链表S3。</p> 
<h4>输入格式:</h4> 
<p>输入分两行，分别在每行给出由若干个正整数构成的非降序序列，用−1表示序列的结尾（−1不属于这个序列）。数字用空格间隔。</p> 
<h4>输出格式:</h4> 
<p>在一行中输出合并后新的非降序链表，数字间用空格分开，结尾不能有多余空格；若新链表为空，输出<code>NULL</code>。</p> 
<h4 id="%E8%BE%93%E5%85%A5%E6%A0%B7%E4%BE%8B%3A">输入样例:</h4> 
<pre><code>1 3 5 -1
2 4 6 8 10 -1</code></pre> 
<p>结尾无空行</p> 
<h4 id="%E8%BE%93%E5%87%BA%E6%A0%B7%E4%BE%8B%3A">输出样例:</h4> 
<pre><code>1 2 3 4 5 6 8 10</code></pre> 
<p>结尾无空行</p> 
<h4> 答案：</h4> 
<pre><code>#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
typedef struct Node
{
    int data;
    struct Node *next;
} * list, node;
int main()
{
    list l1 = (node *)malloc(sizeof(node));
    list l2 = (node *)malloc(sizeof(node));
    node *p1 = l1, *p2 = l2;
    l1-&gt;next = NULL;
    l2-&gt;next = NULL;
    //初始操作
    int x;
    scanf("%d", &amp;x);
    while (x != -1)
    {
        node *p = (node *)malloc(sizeof(node));
        p-&gt;data = x;
        p-&gt;next = NULL;
        p1-&gt;next = p;
        p1 = p1-&gt;next;
        scanf("%d", &amp;x);
    }
    scanf("%d", &amp;x);
    while (x != -1)
    {
        node *p = (node *)malloc(sizeof(node));
        p-&gt;data = x;
        p-&gt;next = NULL;
        p2-&gt;next = p;
        p2 = p2-&gt;next;
        scanf("%d", &amp;x);
    }
    //读取两个链表
    list l = (node *)malloc(sizeof(node));
    l-&gt;next = NULL;
    node *p = l;
    p1 = l1-&gt;next;
    p2 = l2-&gt;next;
    //新链表的初始操作
    while (p1 &amp;&amp; p2)
    {
        if (p1-&gt;data &lt; p2-&gt;data)
        {
            p-&gt;next = p1;
            p1 = p1-&gt;next;
            p = p-&gt;next;
        }
        else
        {
            p-&gt;next = p2;
            p2 = p2-&gt;next;
            p = p-&gt;next;
        }
    }
    if (p1)
        p-&gt;next = p1;
    else
        p-&gt;next = p2;
    //合并过程
    p = l-&gt;next;
    if (p)
    {
        int flag = 0;
        while (p)
        {
            if (flag)
            {
                printf(" %d", p-&gt;data);
            }
            else
            {
                flag = 1;
                printf("%d", p-&gt;data);
            }
            p = p-&gt;next;
        }
    }
    else
        printf("NULL");
    //输出
    return 0;
}</code></pre> 
<h4>分析：</h4> 
<blockquote> 
 <p><span style="color:#956fe7;"><strong>typedef 与 结构体 的共用</strong></span></p> 
 <p>建议！！！在struct后面写上结构体标识符！！！起个名字不难！！！否则会出现warning！</p> 
</blockquote> 
<blockquote> 
 <p><span style="color:#956fe7;"><strong>模块化程序设计</strong></span></p> 
 <p>初始化一个链表</p> 
 <pre><code>list ini()
{
    node *p = (node *)malloc(sizeof(node));
    p-&gt;next = NULL;
    return p;
}</code></pre> 
 <p>读入一个链表</p> 
 <pre><code>void read(list l)
{
    node *p0 = l;
    int x;
    scanf("%d", &amp;x);
    while (x != -1)
    {
        node *p = (node *)malloc(sizeof(node));
        p-&gt;data = x;
        p-&gt;next = NULL;
        p0-&gt;next = p;
        p0 = p0-&gt;next;
        scanf("%d", &amp;x);
    }
}</code></pre> 
 <p>合并两个链表</p> 
 <pre><code>void merge(list l0, list l1, list l2)
{
    node *p0 = l0, *p1 = l1-&gt;next, *p2 = l2-&gt;next;
    while (p1 &amp;&amp; p2)
    {
        if (p1-&gt;data &lt; p2-&gt;data)
        {
            p0-&gt;next = p1;
            p0 = p0-&gt;next;
            p1 = p1-&gt;next;
        }
        else
        {
            p0-&gt;next = p2;
            p0 = p0-&gt;next;
            p2 = p2-&gt;next;
        }
    }
    if (p1)
        p0-&gt;next = p1;
    else
        p0-&gt;next = p2;
}</code></pre> 
 <p>输出一个链表 </p> 
 <pre><code>void print(list l)
{
    node *p = l-&gt;next;
    if (p)
    {
        int flag = 0;
        while (p)
        {
            if (flag)
                printf(" %d", p-&gt;data);
            else
            {
                flag = 1;
                printf("%d", p-&gt;data);
            }
            p = p-&gt;next;
        }
    }
    else
        printf("NULL");
}</code></pre> 
 <p>完整代码</p> 
 <pre><code>#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
typedef struct Node
{
    int data;
    struct Node *next;
} * list, node;
list ini()
{
    node *p = (node *)malloc(sizeof(node));
    p-&gt;next = NULL;
    return p;
}
void read(list l)
{
    node *p0 = l;
    int x;
    scanf("%d", &amp;x);
    while (x != -1)
    {
        node *p = (node *)malloc(sizeof(node));
        p-&gt;data = x;
        p-&gt;next = NULL;
        p0-&gt;next = p;
        p0 = p0-&gt;next;
        scanf("%d", &amp;x);
    }
}
void merge(list l0, list l1, list l2)
{
    node *p0 = l0, *p1 = l1-&gt;next, *p2 = l2-&gt;next;
    while (p1 &amp;&amp; p2)
    {
        if (p1-&gt;data &lt; p2-&gt;data)
        {
            p0-&gt;next = p1;
            p0 = p0-&gt;next;
            p1 = p1-&gt;next;
        }
        else
        {
            p0-&gt;next = p2;
            p0 = p0-&gt;next;
            p2 = p2-&gt;next;
        }
    }
    if (p1)
        p0-&gt;next = p1;
    else
        p0-&gt;next = p2;
}
void print(list l)
{
    node *p = l-&gt;next;
    if (p)
    {
        int flag = 0;
        while (p)
        {
            if (flag)
                printf(" %d", p-&gt;data);
            else
            {
                flag = 1;
                printf("%d", p-&gt;data);
            }
            p = p-&gt;next;
        }
    }
    else
        printf("NULL");
}
int main()
{
    list l0 = ini(), l1 = ini(), l2 = ini();
    read(l1);
    read(l2);
    merge(l0, l1, l2);
    print(l0);
    return 0;
}</code></pre> 
</blockquote> 
<h3 id="7-7%20%E4%B8%A4%E4%B8%AA%E6%9C%89%E5%BA%8F%E9%93%BE%E8%A1%A8%E5%BA%8F%E5%88%97%E7%9A%84%E4%BA%A4%E9%9B%86%20(20%20%E5%88%86)">7-7 两个有序链表序列的交集 (20 分)</h3> 
<p>已知两个非降序链表序列S1与S2，设计函数构造出S1与S2的交集新链表S3。</p> 
<h4>输入格式:</h4> 
<p>输入分两行，分别在每行给出由若干个正整数构成的非降序序列，用−1表示序列的结尾（−1不属于这个序列）。数字用空格间隔。</p> 
<h4>输出格式:</h4> 
<p>在一行中输出两个输入序列的交集序列，数字间用空格分开，结尾不能有多余空格；若新链表为空，输出<code>NULL</code>。</p> 
<h4>输入样例:</h4> 
<pre><code>1 2 5 -1
2 4 5 8 10 -1</code></pre> 
<p>结尾无空行</p> 
<h4>输出样例:</h4> 
<pre><code>2 5</code></pre> 
<p>结尾无空行</p> 
<h4> 答案：</h4> 
<pre><code>#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
typedef struct Node
{
    int data;
    struct Node *next;
} * list, node;
list ini()
{
    node *p = (node *)malloc(sizeof(node));
    p-&gt;next = NULL;
    return p;
}
void read(list l)
{
    node *p0 = l;
    int x;
    scanf("%d", &amp;x);
    while (x != -1)
    {
        node *p = (node *)malloc(sizeof(node));
        p-&gt;data = x;
        p-&gt;next = NULL;
        p0-&gt;next = p;
        p0 = p0-&gt;next;
        scanf("%d", &amp;x);
    }
}
void print(list l)
{
    node *p = l-&gt;next;
    if (p)
    {
        int flag = 0;
        while (p)
        {
            if (flag)
                printf(" %d", p-&gt;data);
            else
            {
                flag = 1;
                printf("%d", p-&gt;data);
            }
            p = p-&gt;next;
        }
    }
    else
        printf("NULL");
}
void inter(list l1, list l2, list l3)
{
    node *p1 = l1-&gt;next, *p2 = l2-&gt;next, *p3 = l3;
    while (p1 &amp;&amp; p2)
    {
        if (p1-&gt;data &gt; p2-&gt;data)
            p2 = p2-&gt;next;
        else if (p1-&gt;data &lt; p2-&gt;data)
            p1 = p1-&gt;next;
        else
        {
            p3-&gt;next = p1;
            p1 = p1-&gt;next;
            p2 = p2-&gt;next;
            p3 = p3-&gt;next;
            p3-&gt;next = NULL;
        }
    }
}
int main()
{
    list l1 = ini(), l2 = ini(), l3 = ini();
    read(l1);
    read(l2);
    inter(l1, l2, l3);
    print(l3);
    return 0;
}</code></pre> 
<h4>分析：</h4> 
<blockquote> 
 <p><span style="color:#956fe7;"><strong>交集算法</strong></span></p> 
 <p>依次遍历两个链表。</p> 
 <p>若一链表的当前元素相较于另一个链表的当前元素小时，则该链表后移一个结点；</p> 
 <p>若两个元素值相同，则将两个结点中任意一个结点插入新链表当中，并且两个链表均后移一个结点。</p> 
</blockquote> 
<blockquote> 
 <p><span style="color:#956fe7;"><strong>注意</strong></span></p> 
 <p>这里的交集并不是数学意义上的交集，因为链表中的元素值是非降序的，也就是说可能存在两个元素的值是相等的，因而链表本身就不是严格意义上的集合，所以这里的交集的意思指：<strong>两个链表中相同的部分</strong>。 </p> 
</blockquote> 
<h3 id="7-8%20%E9%87%8D%E6%8E%92%E9%93%BE%E8%A1%A8%20(25%20%E5%88%86)">7-8 重排链表 (25 分)</h3> 
<p>给定一个单链表 L1​→L2​→⋯→Ln−1​→Ln​，请编写程序将链表重新排列为 Ln​→L1​→Ln−1​→L2​→⋯。例如：给定L为1→2→3→4→5→6，则输出应该为6→1→5→2→4→3。</p> 
<h4 id="输入格式：">输入格式：</h4> 
<p>每个输入包含1个测试用例。每个测试用例第1行给出第1个结点的地址和结点总个数，即正整数N (≤105)。结点的地址是5位非负整数，NULL地址用−1表示。</p> 
<p>接下来有N行，每行格式为：</p> 
<pre><code>Address Data Next</code></pre> 
<p>其中<code>Address</code>是结点地址；<code>Data</code>是该结点保存的数据，为不超过105的正整数；<code>Next</code>是下一结点的地址。题目保证给出的链表上至少有两个结点。</p> 
<h4 id="输出格式：">输出格式：</h4> 
<p>对每个测试用例，顺序输出重排后的结果链表，其上每个结点占一行，格式与输入相同。</p> 
<h4>输入样例：</h4> 
<pre><code>00100 6
00000 4 99999
00100 1 12309
68237 6 -1
33218 3 00000
99999 5 68237
12309 2 33218</code></pre> 
<p>结尾无空行</p> 
<h4>输出样例：</h4> 
<pre><code>68237 6 00100
00100 1 99999
99999 5 12309
12309 2 00000
00000 4 33218
33218 3 -1</code></pre> 
<p>结尾无空行</p> 
<h4> 答案：</h4> 
<pre><code>#include &lt;stdio.h&gt;
struct List
{
    int add;
    int data;
    int next;
} l1[100000], l2[100000];
int first, n;
void cunshuju()
{
    scanf("%d %d", &amp;first, &amp;n);
    int i;
    for (i = 0; i &lt; n; i++)
    {
        int add, data, next;
        scanf("%d %d %d", &amp;add, &amp;data, &amp;next);
        l1[add].add = add;
        l1[add].data = data;
        l1[add].next = next;
    }
}
void lv()
{
    int i = 0, j, index = first;
    while (index != -1)
    {
        l2[i++] = l1[index];
        index = l1[index].next;
    }
    n = i;
}
void shuchu()
{
    int h, i = n - 1, j = 0, flag = 1;
    for (h = 0; h &lt; n; h++)
    {
        if (flag)
        {
            printf("%05d %d ", l2[i].add, l2[i].data);
            if (h != n - 1)
                printf("%05d\n", l2[j].add);
            else
                printf("-1");
            i--;
            flag = 0;
        }
        else
        {
            printf("%05d %d ", l2[j].add, l2[j].data);
            if (h != n - 1)
                printf("%05d\n", l2[i].add);
            else
                printf("-1");
            j++;
            flag = 1;
        }
    }
}
int main()
{
    cunshuju();
    lv();
    shuchu();
    return 0;
}</code></pre> 
<h4>分析：</h4> 
<blockquote> 
 <p><span style="color:#956fe7;"><strong>思路</strong></span></p> 
 <p>三个部分：存数据、捋一遍表、按格式输出</p> 
</blockquote> 
<blockquote> 
 <p><span style="color:#956fe7;"><strong>注意</strong></span></p> 
 <p>结点的定义：本身的地址、本身的数值、下一个节点的地址（数组下标即为其地址）</p> 
 <p> 倒数第二个测试点：可能存在不在表中的数据被读入</p> 
</blockquote> 
<blockquote> 
 <p><span style="color:#956fe7;"><strong>c++版本</strong></span></p> 
 <p><a class="link-info" href="https://blog.csdn.net/peanutpeanuta/article/details/119816490?spm=1001.2014.3001.5501" title="Link">Link</a></p> 
</blockquote> 
<h3 id="7-9%20%E9%93%BE%E8%A1%A8%E5%8E%BB%E9%87%8D%20(25%20%E5%88%86)">7-9 链表去重 (25 分)</h3> 
<p>给定一个带整数键值的链表 L，你需要把其中绝对值重复的键值结点删掉。即对每个键值 K，只有第一个绝对值等于 K 的结点被保留。同时，所有被删除的结点须被保存在另一个链表上。例如给定 L 为 21→-15→-15→-7→15，你需要输出去重后的链表 21→-15→-7，还有被删除的链表 -15→15。</p> 
<h4>输入格式：</h4> 
<p>输入在第一行给出 L 的第一个结点的地址和一个正整数 N（≤105，为结点总数）。一个结点的地址是非负的 5 位整数，空地址 NULL 用 -1 来表示。</p> 
<p>随后 N 行，每行按以下格式描述一个结点：</p> 
<pre><code>地址 键值 下一个结点</code></pre> 
<p>其中<code>地址</code>是该结点的地址，<code>键值</code>是绝对值不超过104的整数，<code>下一个结点</code>是下个结点的地址。</p> 
<h4>输出格式：</h4> 
<p>首先输出去重后的链表，然后输出被删除的链表。每个结点占一行，按输入的格式输出。</p> 
<h4>输入样例：</h4> 
<pre><code>00100 5
99999 -7 87654
23854 -15 00000
87654 15 -1
00000 -15 99999
00100 21 23854</code></pre> 
<p>结尾无空行</p> 
<h4>输出样例：</h4> 
<pre><code>00100 21 23854
23854 -15 99999
99999 -7 -1
00000 -15 87654
87654 15 -1</code></pre> 
<p>结尾无空行</p> 
<h4 id="%E9%94%99%E8%AF%AF%E7%AD%94%E6%A1%88%EF%BC%9A">答案：</h4> 
<pre><code>#include &lt;stdio.h&gt;
#include &lt;math.h&gt;
struct node
{
    int add;
    int data;
    int next;
} l1[100000], l2[100000], l3[100000], l4[100000];
int judge[10005], first, n, a, b;
void cunshuju()
{
    scanf("%d %d", &amp;first, &amp;n);
    int i;
    for (i = 0; i &lt; n; i++)
    {
        int add, data, next;
        scanf("%d %d %d", &amp;add, &amp;data, &amp;next);
        l1[add].add = add;
        l1[add].data = data;
        l1[add].next = next;
        /* if (next == -1)
            break; */
    }
    int index = first;
    i = 0;
    while (index != -1)
    {
        l2[i++] = l1[index];
        index = l1[index].next;
        if (l1[index].add == -2)
            break;
    }
    n = i;
    /* printf("n = %d\n", n); */
}
void quchong()
{
    int i;
    a = 0;
    b = 0;
    for (i = 0; i &lt; n; i++)
    {
        if (!judge[abs(l2[i].data)])
        {
            l3[a++] = l2[i];
            judge[abs(l2[i].data)] = 1;
        }
        else
            l4[b++] = l2[i];
    }
}
void shuchu()
{
    int i;
    for (i = 0; i &lt; a; i++)
    {
        if (i != a - 1)
            printf("%05d %d %05d\n", l3[i].add, l3[i].data, l3[i + 1].add);
        else
            printf("%05d %d -1\n", l3[i].add, l3[i].data);
    }
    for (i = 0; i &lt; b; i++)
    {
        if (i != b - 1)
            printf("%05d %d %05d\n", l4[i].add, l4[i].data, l4[i + 1].add);
        else
            printf("%05d %d -1", l4[i].add, l4[i].data);
    }
}
void l1chushihua()
{
    int i;
    for (i = 0; i &lt; 100000; i++)
    {
        l1[i].add = -2;
        l1[i].data = -2;
        l1[i].next = -2;
    }
}
int main()
{
    l1chushihua();
    cunshuju();
    quchong();
    shuchu();
    return 0;
}</code></pre> 
<h4>思路</h4> 
<blockquote> 
 <p><span style="color:#956fe7;"><strong>judge规模！！！</strong></span></p> 
</blockquote>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/e8ff7517f5f0a750d332396ffba0aded/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">OpenCV——高斯滤波</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/1b261bb929959c92da65175b787e7c95/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">模糊查询（通过真实测试例子来查询）</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>