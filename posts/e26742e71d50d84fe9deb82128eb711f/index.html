<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>IPC 之Service 还可以这么理解 - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="IPC 之Service 还可以这么理解" />
<meta property="og:description" content="前言 IPC 系列文章：
建议按顺序阅读。
Android IPC 之Service 还可以这么理解
Android IPC 之Binder基础
Android IPC 之Binder应用
Android IPC 之AIDL应用(上)
Android IPC 之AIDL应用(下)
Android IPC 之Messenger 原理及应用
Android IPC 之服务端回调
Android IPC 之获取服务(IBinder)
Android Binder 原理换个姿势就顿悟了(图文版)
Android四大组件：Activity、Service、BroadcastReceiver、ContentProvider。它们的作用分别是：
Activity---&gt;配合View展示界面
Service---&gt;长时间在后台运行不与用户直接交互
BroadcastReceiver---&gt;接收广播
ContentProvider---&gt;提供数据给其他模块使用
本篇文章着重分析Service，通过它，你将了解到：
1、Service 开启与停止
2、Service 执行耗时操作
3、Service 与Thread、Manager关系
4、Service 进程间通信初相识
1、Service 开启与停止 先定义一个Service类，名为MyService，继承自Service。
public class MyService extends Service { public MyService() { super(); } @Nullable @Override public IBinder onBind(Intent intent) { //必须重写该方法，该方法为抽象方法 //绑定开启Service会调用该方法 return null; } @Override public void onCreate() { //Service初次创建会调用该方法，我们可以做一些初始化操作, 与onDestroy()相对 super." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/e26742e71d50d84fe9deb82128eb711f/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-12-28T14:59:41+08:00" />
<meta property="article:modified_time" content="2022-12-28T14:59:41+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">IPC 之Service 还可以这么理解</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <h2>前言</h2> 
<p>IPC 系列文章：<br> 建议按顺序阅读。</p> 
<blockquote> 
 <p><a href="https://juejin.cn/post/7023238726503383076" rel="nofollow" title="Android IPC 之Service 还可以这么理解">Android IPC 之Service 还可以这么理解</a><br><a href="https://juejin.cn/post/7023605966004289572" rel="nofollow" title="Android IPC 之Binder基础">Android IPC 之Binder基础</a><br><a href="https://juejin.cn/post/7023610448901570568" rel="nofollow" title="Android IPC 之Binder应用">Android IPC 之Binder应用</a><br><a href="https://juejin.cn/post/7031040766357012517" rel="nofollow" title="Android IPC 之AIDL应用(上)">Android IPC 之AIDL应用(上)</a><br><a href="https://juejin.cn/post/7031773320756330504" rel="nofollow" title="Android IPC 之AIDL应用(下)">Android IPC 之AIDL应用(下)</a><br><a href="https://juejin.cn/post/7031775387294269470" rel="nofollow" title="Android IPC 之Messenger 原理及应用">Android IPC 之Messenger 原理及应用</a><br><a href="https://juejin.cn/post/7032150970419118116" rel="nofollow" title="Android IPC 之服务端回调">Android IPC 之服务端回调</a><br><a href="https://juejin.cn/post/7032146507499307015" rel="nofollow" title="Android IPC 之获取服务(IBinder)">Android IPC 之获取服务(IBinder)</a><br><a href="https://juejin.cn/post/7157710923547803655" rel="nofollow" title="Android Binder 原理换个姿势就顿悟了(图文版)">Android Binder 原理换个姿势就顿悟了(图文版)</a></p> 
</blockquote> 
<p>Android四大组件：Activity、Service、BroadcastReceiver、ContentProvider。它们的作用分别是：</p> 
<blockquote> 
 <p>Activity---&gt;配合View展示界面<br> Service---&gt;长时间在后台运行不与用户直接交互<br> BroadcastReceiver---&gt;接收广播<br> ContentProvider---&gt;提供数据给其他模块使用</p> 
</blockquote> 
<p>本篇文章着重分析Service，通过它，你将了解到：</p> 
<blockquote> 
 <p>1、Service 开启与停止<br> 2、Service 执行耗时操作<br> 3、Service 与Thread、Manager关系<br> 4、Service 进程间通信初相识</p> 
</blockquote> 
<h2>1、Service 开启与停止</h2> 
<p>先定义一个Service类，名为MyService，继承自Service。</p> 
<pre><code>public class MyService extends Service {

    public MyService() {
        super();
    }

    @Nullable
    @Override
    public IBinder onBind(Intent intent) {
        //必须重写该方法，该方法为抽象方法
        //绑定开启Service会调用该方法
        return null;
    }

    @Override
    public void onCreate() {
        //Service初次创建会调用该方法，我们可以做一些初始化操作, 与onDestroy()相对
        super.onCreate();
    }

    @Override
    public int onStartCommand(Intent intent, int flags, int startId) {
        //每次显示启动Service都会调用该方法
        return super.onStartCommand(intent, flags, startId);
    }

    @Override
    public void onDestroy() {
        //Service销毁时调用该方法，在该方法里我们可以做释放资源的操作，与onCreate()相对
        super.onDestroy();
    }
}
复制代码</code></pre> 
<p>这是一个最简单的Service Demo。<br> 接着想要使用该Service，还需要在AndroidManifest.xml里注册：</p> 
<pre><code>        &lt;service android:name=".service.MyService"&gt;
        &lt;/service&gt;
复制代码</code></pre> 
<p>Service定义好了，怎么使用呢？开启Service有两种方式：</p> 
<blockquote> 
 <p>1、显示开启------&gt; startService(Intent intent)<br> 2、绑定开启------&gt; bindService(Intent intent)<br><em>这俩都是Context里的方法</em></p> 
</blockquote> 
<h3>显示开启Service</h3> 
<p>构造Intent，传入startService(Intent intent)里。</p> 
<pre><code>    private void startService() {
        Intent intent = new Intent(this, MyService.class);
        startService(intent);
    }
复制代码</code></pre> 
<p>通过此种方式，Service调用方法如下：</p> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/79/e6/VeKrcZGi_o.jpg"></p> 
<p>需要注意的点是：</p> 
<blockquote> 
 <p>当再次开启一个已经存在的Service的时候，onStartCommand(xx)依然会被调用。</p> 
</blockquote> 
<h3>显示关闭Service</h3> 
<p>显示开启Service后，Service就已经启动了。<br> 若要关闭Service，通过如下方法：</p> 
<pre><code>    private void stopService() {
        Intent intent = new Intent(this, MyService.class);
        stopService(intent);
    }
复制代码</code></pre> 
<p>或者在Service做完了事自己结束：</p> 
<pre><code>stopSelf();
复制代码</code></pre> 
<h3>绑定开启Service</h3> 
<p>通过上面的例子，可以看出显示开启Service后，调用者就和Service没有关联了。比如调用者是个Activity，Service的作用是不断地计数。在显示开启Service的场景下，会存在两个问题：</p> 
<blockquote> 
 <p>1、Activity无法直接(间接通过广播等方法)拿到Service计数结果，也就是说没法拿到Service引用。<br> 2、当Activity退出的时候，若不是主动停止Service，那么Service将不会被关闭。不太恰当的比喻是："管生不管养"</p> 
</blockquote> 
<p>而绑定开启Service正好可以解决上面的问题。<br> 为了实现绑定开启Service，在上面Demo的基础上稍微做修改。</p> 
<p>定义MyBinder继承自Binder：</p> 
<pre><code>public class MyBinder extends Binder {
    //持有Service引用
    private Service service;
    public MyBinder(Service service) {
        this.service = service;
    }

    //返回Service引用
    public Service getService() {
        return service;
    }
}
复制代码</code></pre> 
<p>在显示开启Service过程中，我们重写了onBind(xx)，直接返回的是null，该场景下该方法并没有调用。而当绑定开启Service时，需要返回IBiner的引用给绑定者使用。</p> 
<pre><code>#MyService.java
    public IBinder onBind(Intent intent) {
        return new MyBinder(this);
    }
复制代码</code></pre> 
<p>返回的是MyBinder对象的引用，该对象持有了MyService引用。<br> 绑定者在哪里接收IBinder的引用呢？<br> 在Activity里定义ServiceConnection匿名内部类：</p> 
<pre><code>    ServiceConnection serviceConnection = new ServiceConnection() {
        @Override
        public void onServiceConnected(ComponentName name, IBinder service) {
            //service即是从onBind(xx)方法返回的(绑定者和Service同一进程)
            MyBinder myBinder = (MyBinder)service;
            //获取Service的引用
            MyService myService = (MyService)myBinder.getService();
        }

        @Override
        public void onServiceDisconnected(ComponentName name) {
            //Service被销毁时调用(内存不足等，正常解绑不会走这)
        }
    };
复制代码</code></pre> 
<p>有了ServiceConnection 引用，接着就需要和Service建立联系，建立联系的过程即是绑定开启Service的过程。</p> 
<pre><code>    private void bindService() {
        Intent intent = new Intent(this, MyService.class);
        bindService(intent, serviceConnection, BIND_AUTO_CREATE);
    }
复制代码</code></pre> 
<p>从上面可以看出，绑定开启的流程：</p> 
<blockquote> 
 <p>1、将Service和ServiceConnection建立联系（绑定开启）<br> 2、在Service的onBind(xx)方法里返回IBinder引用，该引用持有Service引用<br> 3、绑定成功后会调用ServiceConnection的onServiceConnected(xx)返回IBinder引用<br> 4、通过IBinder引用就能拿到Service引用，进而操作Service</p> 
</blockquote> 
<p><strong>以上回答了上面的第一个问题：绑定者(Activity)无法拿到Service引用。</strong><br> 来看看绑定开启Service调用方法流程：</p> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/06/ae/7ljH5sAI_o.jpg"></p> 
<h3>解绑Service</h3> 
<p>既然绑定时传入了ServiceConnection引用，可以猜测解绑时也需要传入ServiceConnection引用，不然无法确定解绑哪个Service。</p> 
<pre><code>    private void unBindService() {
        unbindService(serviceConnection);
    }
复制代码</code></pre> 
<p>手动调用该方法即可解绑Service。<br> 当Activity绑定开启Service后，若是Activity销毁了，那么相应的Service也会被销毁掉。<strong>这就解答了第二个问题。</strong></p> 
<p>值得注意的是：<br> 若是显示开启了Service，则无法用解绑方法关闭Service。<br> 若是绑定开启了Service，则无法用显示关闭Service方法。</p> 
<h2>2、Service 执行耗时操作</h2> 
<p>在Service的onCreate(xx)方法里循环计数：</p> 
<pre><code>#MyService.java
    @Override
    public void onCreate() {
        super.onCreate();

        while(true) {
            count++;
            try {
                Thread.sleep(1000);
            } catch (Exception e) {

            }
        }
    }
复制代码</code></pre> 
<p>服务开启后，过一会就会提示ANR错误，说明onCreate(xx)是在主线程执行的。<br> 来看看onCreate(xx)调用栈。</p> 
<pre><code>#ActivityThread.java
    private class ApplicationThread extends IApplicationThread.Stub {
        ...
        //IPC通信调用该方法，表明要创建服务
        public final void scheduleCreateService(IBinder token,
                                                ServiceInfo info, CompatibilityInfo compatInfo, int processState) {
            updateProcessState(processState, false);
            CreateServiceData s = new CreateServiceData();
            s.token = token;
            s.info = info;
            s.compatInfo = compatInfo;
            //发送Message
            sendMessage(H.CREATE_SERVICE, s);
        }
        ...
    }

//中间调用省略
    private void sendMessage(int what, Object obj, int arg1, int arg2, boolean async) {
        ...
        Message msg = Message.obtain();
        msg.what = what;
        msg.obj = obj;
        msg.arg1 = arg1;
        msg.arg2 = arg2;
        if (async) {
            msg.setAsynchronous(true);
        }
        //mH 为在ActivityThread 里构造的Handler，也就是说在主线程里构造的Handler。
        mH.sendMessage(msg);
    }
复制代码</code></pre> 
<p>再看看接收Message的地方：</p> 
<pre><code>#ActivityThread.java
    public void handleMessage(Message msg) {
        switch (msg.what) {
            ...
            case CREATE_SERVICE:
                Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, ("serviceCreate: " + String.valueOf(msg.obj)));
                //创建Service
                handleCreateService((CreateServiceData) msg.obj);
                Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);
                break;
            case BIND_SERVICE:
                Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, "serviceBind");
                //绑定Service
                handleBindService((BindServiceData) msg.obj);
                Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);
                break;
            case UNBIND_SERVICE:
                Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, "serviceUnbind");
                handleUnbindService((BindServiceData) msg.obj);
                //解绑Service
                schedulePurgeIdler();
                Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);
                break;
                ...
        }
    }
复制代码</code></pre> 
<p>以上分支最终会调用到MyService重写的onCreate(xx)、onBind(xx)、onUnbind(xx)里，这些方法都是在主线程里被调用的。<br> 既然Service各个方法是在主线程里执行，那么想要实现计数功能得子开启线程来完成此事。</p> 
<pre><code>#MyService.java
    @Override
    public void onCreate() {
        super.onCreate();

        new Thread(new Runnable() {
            @Override
            public void run() {
                while(true) {
                    Log.d("time:", count + "");
                    count++;
                    try {
                        Thread.sleep(1000);
                    } catch (Exception e) {

                    }
                }
            }
        }).start();
    }

    public int getCount() {
        return count;
    }
复制代码</code></pre> 
<p>Service一直在计数，计数结果怎么通知给调用者呢，此处假设调用者是Activity。<br> 依然是两种方式：</p> 
<blockquote> 
 <p>1、如果是显示开启的Service，则Service可选择广播将数据发送给Activity<br> 2、如果是绑定开启的Service，Activity拿到IBinder引用，进而拿到Service引用，最终可以调用getCount()获得计数值，并更新UI。</p> 
</blockquote> 
<p>当然如果觉得每次开启子线程很麻烦，可以选择Android 提供的IntentService，该类里封装了HandlerThread，并提供回调方法用以执行耗时任务。</p> 
<h2>3、Service 与Thread、Manager关系</h2> 
<h3>Service 与 Thread联系</h3> 
<p>既然Service无法直接执行耗时操作，那么需要Service干嘛呢，还不如直接开启子线程执行任务呢？<br> 前面说了：Service是长时间在后台运行。<br> 实际上说的是Service的生命周期，也就是说Service对象一直存在，当我们需要使用Service的时候，通过Intent或者IBinder找到它，进而使用它提供的功能。<br> 同样实现计数功能：</p> 
<blockquote> 
 <ul><li>如果直接在Activity里开启Thread计数，当Activity退出的时候，要把Thread关闭了。再次开启Activity的时候，已经找不到Thread引用了，无法继续上次的累计计数。再者，就算不考虑内存泄漏，Activity退出时候不关闭Thread，再次开启Activity的时候，依然找不到Thread引用。</li><li>另外如果想将计数功能抽出来，供多个Activity使用，直接使用Thread也无法实现多Activity共用计数功能。</li></ul> 
</blockquote> 
<p>上面问题的本质就是需要维护一个对Thread对象的引用。而Thread仅仅是个工具而已，没必要维护全局的引用（那是线程池要做的工作)。</p> 
<h3>Service 与 Manager</h3> 
<p>既然维护Thread全局引用方法不太推荐，那么实现一个单例的Manager(管理类)来持有Thread，进而使用Thread执行耗时任务，而外界通过调用这个Manager来获取数据，如下：</p> 
<pre><code>public class CountManager {
    private static volatile CountManager instance;

    private CountManager(){
        startCount();
    }

    private int count = 0;

    public static CountManager getInstance() {
        if (instance == null) {
            synchronized (CountManager.class) {
                if (instance == null) {
                    instance = new CountManager();
                }
            }
        }

        return instance;
    }

    private void startCount() {
        new Thread(new Runnable() {
            @Override
            public void run() {
                while(true) {
                    Log.d("time:", count + "");
                    count++;
                    try {
                        Thread.sleep(1000);
                    } catch (Exception e) {

                    }
                }
            }
        }).start();
    }

    public int getCount() {
        return count;
    }
}
复制代码</code></pre> 
<p>事实上不少的项目都是采用Activity + Manager方式来实现页面展示 + 数据获取。<br> Activity展示UI，后台通过Manager获取数据，如从数据库获取或者从从网络获取等，最后将数据反馈给Activity用以刷新UI。<br> 到此你可能疑惑了，都有了Manager了，Service还有使用的必要吗？<br> 答案是肯定的。<br> Service作为Android 四大组件之一，是广泛使用于Android 系统里的。</p> 
<blockquote> 
 <p>1、Service可以调整优先级，尽可能避免在资源紧张的时候被销毁<br> 2、借助Service + Binder，实现Android 进程间通信</p> 
</blockquote> 
<h2>4、Service 进程间通信初相识</h2> 
<p>之前的例子分析的都是调用者和被调用处于同一进程，试想一下，如果它们不在同一进程还能互相调用吗？如进程A里的Activity需要使用进程B里的CountManager，显然无法直接调用。<br> 而对于Service来说，借助于Binder可以实现此功能。</p> 
<p style="text-align:center;"> <img alt="" src="https://images2.imgbox.com/1c/18/yYANiuFS_o.jpg"></p> 
<p>进程A的Activity展示UI需要数据，这些数据从进程B获取。进程B开启Service生产数据，进程A通过绑定进程B的Service，从而获得IBinder引用，最终调用Service的方法获取数据。关键点就是中间的连接桥梁--Binder。 可以看出，Service的重点应该是在进程间通信。</p> 
<p>接下来的文章，将重点分析IPC 过程涉及的Binder、AIDL等知识。</p> 
<p>本文基于Android 10.0</p> 
<p></p> 
<p>作者：小鱼人爱编程<br> 链接：https://juejin.cn/post/7023238726503383076<br> 来源：稀土掘金<br> 著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/54cae3e9946ead8453632a27786b106c/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">Linux-安装软件</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/3b4118dfa169920398fc88ecaffccd15/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">poi根据模版生成word（包括导出）</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>