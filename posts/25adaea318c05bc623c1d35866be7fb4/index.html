<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>【深度学习】经典案例：猫狗大战（kaggle实战完整流程：数据集分割、预处理、模型搭建、模型参数保存、acc/loss可视化） - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="【深度学习】经典案例：猫狗大战（kaggle实战完整流程：数据集分割、预处理、模型搭建、模型参数保存、acc/loss可视化）" />
<meta property="og:description" content="环境：kaggle平台&#43;python3.7&#43;TensorFlow
完整代码、模型及参数、详细文档见：猫狗大战完整代码&#43;详细文档&#43;模型参数
文章目录 1.概述1.1 任务1.2 数据集1.3 解决方案 2 解决方案2.1 加载、查看训练集/测试集2.2 处理数据2.3 搭建模型2.4 设置优化器、损失函数2.5 存取模型、断点续训2.6 参数保存2.7 训练结果可视化2.8 预测测试集 3 总结 1.概述 1.1 任务 猫狗大战的实验目的是通过给定的猫狗图片数据集训练神经网络模型，通过CNN架构提取图片特征，实现模型对于猫狗两种动物的识别。
1.2 数据集 采用kaggle官方Cats VS. Dogs比赛数据集。该数据集是由 Microsoft Research Asia 发布的猫狗大战数据集。该数据集包括 25000 张猫和狗的图片，其中 12500 张是猫的图片，另外 12500 张是狗的图片。每张图片的大小不一，颜色、角度、光线等也有所不同。
1.3 解决方案 基于深度学习的解决方案：基于tensorFlow框架搭建神经网络，从零开始一步步完成数据读取、网络构建、模型训练和模型测试等过程，最终实现一个可以进行猫狗图像分类的分类器；并借助数据增强技术，例如旋转、翻转、缩放等，来增加数据集的多样性，从而提高模型的泛化能力和鲁棒性。
以下使用卷积神经网络来构建模型。在 CNN 中，通过卷积层、池化层、全连接层等结构，可以自动学习图像的特征，并将其转化为一个向量表示。通过这个向量表示，可以进行分类或者其他任务。
2 解决方案 2.1 加载、查看训练集/测试集 查看训练集/测试集大小，样例：
os.listdir():返回指定目录中的所有文件和文件夹的列表。
#返回指定路径下的所有文件和目录的名称列表 train_path = &#39;/kaggle/working/train&#39; test_path = &#39;/kaggle/working/test&#39; train_file_names = os.listdir(train_path) test_file_names = os.listdir(test_path) print(&#34;训练集大小：{}&#34;.format(len(train_file_names))) print(&#34;测试集大小：{}&#34;.format(len(test_file_names))) print(&#34;训练集样例：{}&#34;.format(train_file_names[0:5]))#训练集文件名：标签&#43;序号 print(&#34;测试集样例：{}&#34;.format(test_file_names[0:5])) #测试集文件名：序号 2.2 处理数据 训练集/测试集路径、标签存入DataFrame:" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/25adaea318c05bc623c1d35866be7fb4/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-06-27T21:20:18+08:00" />
<meta property="article:modified_time" content="2023-06-27T21:20:18+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">【深度学习】经典案例：猫狗大战（kaggle实战完整流程：数据集分割、预处理、模型搭建、模型参数保存、acc/loss可视化）</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <blockquote> 
 <p>环境：kaggle平台+python3.7+TensorFlow<br> 完整代码、模型及参数、详细文档见：<a href="https://download.csdn.net/download/weixin_44820505/87800260">猫狗大战完整代码+详细文档+模型参数</a></p> 
</blockquote> 
<p></p> 
<div class="toc"> 
 <h4>文章目录</h4> 
 <ul><li><ul><li><a href="#1_4" rel="nofollow">1.概述</a></li><li><ul><li><a href="#11__6" rel="nofollow">1.1 任务</a></li><li><a href="#12__10" rel="nofollow">1.2 数据集</a></li><li><a href="#13__14" rel="nofollow">1.3 解决方案</a></li></ul> 
   </li><li><a href="#2__20" rel="nofollow">2 解决方案</a></li><li><ul><li><a href="#21__22" rel="nofollow">2.1 加载、查看训练集/测试集</a></li><li><a href="#22__43" rel="nofollow">2.2 处理数据</a></li><li><a href="#23__198" rel="nofollow">2.3 搭建模型</a></li><li><a href="#24__220" rel="nofollow">2.4 设置优化器、损失函数</a></li><li><a href="#25__235" rel="nofollow">2.5 存取模型、断点续训</a></li><li><a href="#26__265" rel="nofollow">2.6 参数保存</a></li><li><a href="#27__278" rel="nofollow">2.7 训练结果可视化</a></li><li><a href="#28__316" rel="nofollow">2.8 预测测试集</a></li></ul> 
   </li><li><a href="#3__339" rel="nofollow">3 总结</a></li></ul> 
 </li></ul> 
</div> 
<p></p> 
<h3><a id="1_4"></a>1.概述</h3> 
<h4><a id="11__6"></a>1.1 任务</h4> 
<p>猫狗大战的实验目的是通过给定的猫狗图片数据集训练神经网络模型，通过<code>CNN</code>架构提取图片特征，实现模型对于猫狗两种动物的识别。</p> 
<h4><a id="12__10"></a>1.2 数据集</h4> 
<p>采用<code>kaggle</code>官方<code>Cats VS. Dogs</code>比赛数据集。该数据集是由 <code>Microsoft Research Asia</code> 发布的猫狗大战数据集。该数据集包括 <code>25000</code> 张猫和狗的图片，其中 <code>12500</code> 张是猫的图片，另外 <code>12500</code> 张是狗的图片。每张图片的大小不一，颜色、角度、光线等也有所不同。</p> 
<h4><a id="13__14"></a>1.3 解决方案</h4> 
<p>基于深度学习的解决方案：基于<code>tensorFlow</code>框架搭建神经网络，从零开始一步步完成数据读取、网络构建、模型训练和模型测试等过程，最终实现一个可以进行猫狗图像分类的分类器；并借助数据增强技术，例如旋转、翻转、缩放等，来增加数据集的多样性，从而提高模型的泛化能力和鲁棒性。</p> 
<p>以下使用卷积神经网络来构建模型。在 <code>CNN</code> 中，通过卷积层、池化层、全连接层等结构，可以自动学习图像的特征，并将其转化为一个向量表示。通过这个向量表示，可以进行分类或者其他任务。</p> 
<h3><a id="2__20"></a>2 解决方案</h3> 
<h4><a id="21__22"></a>2.1 加载、查看训练集/测试集</h4> 
<p>查看训练集/测试集大小，样例：</p> 
<p><code>os.listdir()</code>:返回指定目录中的所有文件和文件夹的列表。</p> 
<pre><code>#返回指定路径下的所有文件和目录的名称列表
train_path = '/kaggle/working/train'
test_path = '/kaggle/working/test'
train_file_names = os.listdir(train_path)
test_file_names = os.listdir(test_path)
print("训练集大小：{}".format(len(train_file_names)))
print("测试集大小：{}".format(len(test_file_names)))
print("训练集样例：{}".format(train_file_names[0:5]))#训练集文件名：标签+序号
print("测试集样例：{}".format(test_file_names[0:5])) #测试集文件名：序号
</code></pre> 
<p><img src="https://images2.imgbox.com/93/cf/jJdidsEx_o.png" alt="在这里插入图片描述"></p> 
<h4><a id="22__43"></a>2.2 处理数据</h4> 
<p>训练集/测试集路径、标签存入<code>DataFrame</code>:</p> 
<pre><code>#训练集 train_image_path  label
import pandas

image_paths = []
labels = []
for train_file in train_file_names:
    label = train_file.split('.')[0]
    labels.append(label)
    image_path = os.path.join(train_path, train_file)
    image_paths.append(image_path)
    
train_df = pandas.DataFrame()
train_df['train_image_path'] = image_paths #为自定义属性名添加列表
train_df['label'] = labels
train_df.head()
</code></pre> 
<p><img src="https://images2.imgbox.com/f9/5e/EPi9uu1t_o.png" alt="在这里插入图片描述"></p> 
<pre><code>#测试集 teat_image_path
image_paths = []
test_idx = []
for test_file in test_file_names:
    idx = test_file.split('.')[0]
    test_idx.append(idx)
    image_path = os.path.join(test_path, test_file)
    image_paths.append(image_path)
    
test_df = pandas.DataFrame()
test_df['test_image_path'] = image_paths
test_df.head()
</code></pre> 
<p><img src="https://images2.imgbox.com/9b/52/W51jourw_o.png" alt="在这里插入图片描述"></p> 
<p><strong>分割训练集、验证集：</strong></p> 
<p><code>train_test_split()</code>用于将数据集分成训练集和测试集。设置stratify参数可以按照标签进行分层抽样，以免数据分割是有偏的。</p> 
<pre><code># 以下是分层抽样，因为随机抽样容易导致样本偏差
from sklearn.model_selection import train_test_split

# !pip install numpy --upgrade #更新Numpy
#stratify 参数被设置时，会按照标签的比例将数据集分成训练集和测试集。
train_set, val_set = train_test_split(train_df, random_state=42, stratify=train_df['label'])# 设置分层抽样
print("训练集大小：{}".format(len(train_set)))
print("验证集大小：{}".format(len(val_set)))
train_set['label'].hist() #此时样本是无偏的
val_set['label'].hist()
</code></pre> 
<p><img src="https://images2.imgbox.com/a4/0d/cN9tVz2l_o.png" alt="在这里插入图片描述"></p> 
<p><strong>查看图片</strong>（以验证集为例）：</p> 
<pre><code>import matplotlib.pyplot as plt
import matplotlib.image as img

#fig 是一个 Figure 对象，表示整个图表，而 axes 是一个包含每个子图的 Axes 对象数组。可以使用 fig 对象控制整个图表的属性，使用 axes 对象控制每个子图的属性。
fig, axes = plt.subplots(3,3,figsize=(10,10))
axes = axes.ravel()
for i in range(9):
    axes[i].imshow(img.imread(val_set.iloc[i,0]))
    axes[i].axis('off')#控制图表中的四个轴是否显示
#自动调整子图之间的间距和位置，以便它们更好地适应图表的大小
fig.tight_layout()
plt.show()
</code></pre> 
<p><img src="https://images2.imgbox.com/d9/32/rksX66YI_o.png" alt="在这里插入图片描述"></p> 
<p><strong>数据增强</strong>：</p> 
<p>数据增强仅对训练集操作，<br> <code>ImageDataGenerator()</code>可以在训练模型时<strong>实时生成数据的批次</strong>，并对数据进行随机变换。例如，可以将图像进行随机旋转、缩放、剪切和翻转等操作。这些变换可以增加数据集的多样性，从而提高模型的泛化性能。</p> 
<p><code>flow_from_dataframe()</code>可以从 <code>DataFrame</code> 中读取图像文件的路径和标签信息，然后使用 <code>ImageDataGenerator</code> 对象对图像数据进行数据增强和预处理，最终生成增强后的图像数据流以供模型的训练。</p> 
<blockquote> 
 <p>关于数据增强的一些疑惑？？？<br> 数据增强时候设置的batchsize和模型训练时中的batchsize需要相等吗?为什么说数据增强可以增加训练样本数量，而在执行完数据增强后没有将其与原始训练样本合并？<br> 数据增强后的数量会大于原始数据集数量，所以一个epoch中的数据中有重复的吗？不同epoch的数据集一样吗？<br> 理解放在：<a href="https://blog.csdn.net/weixin_44820505/article/details/131424319?csdn_share_tail=%7B%22type%22:%22blog%22,%22rType%22:%22article%22,%22rId%22:%22131424319%22,%22source%22:%22weixin_44820505%22%7D">【数据增强】彻底搞懂数据增强做了哪些工作？</a></p> 
</blockquote> 
<pre><code>train_gen = ImageDataGenerator(
    zoom_range=0.1,
    rotation_range=10,
    rescale=1./255,
    shear_range=0.1,
    horizontal_flip=True,
    width_shift_range=0.1,
    height_shift_range=0.1
)
train_generator = train_gen.flow_from_dataframe(
    dataframe=train_set,
    x_col='train_image_path',
    y_col='label',
    target_size=(200,200),
    class_mode='binary',
    batch_size=128,
    shuffle=False
)
print(len(train_generator))
</code></pre> 
<p><img src="https://images2.imgbox.com/22/e6/dMJ94At6_o.png" alt="在这里插入图片描述"></p> 
<pre><code>#验证集
val_gen = ImageDataGenerator(
    rescale=1./255
)
val_generator = val_gen.flow_from_dataframe(
    dataframe=val_set,
    x_col='train_image_path',
    y_col='label',
    target_size=(200,200),
    class_mode='binary',
    batch_size=128,
    shuffle=False
)
print(len(val_generator))
</code></pre> 
<p><img src="https://images2.imgbox.com/eb/6e/nPJaiFBe_o.png" alt="在这里插入图片描述"></p> 
<pre><code>#测试集
test_datagen = ImageDataGenerator(
    rescale=1./255
)
test_generator = test_datagen.flow_from_dataframe(
    dataframe=test_df,
    x_col='test_image_path',
    y_col=None,
    target_size=(200,200),
    class_mode=None,
    batch_size=128,
    shuffle=False
)
print(len(test_generator))
</code></pre> 
<p><img src="https://images2.imgbox.com/2a/79/9hVaURUo_o.png" alt="在这里插入图片描述"></p> 
<h4><a id="23__198"></a>2.3 搭建模型</h4> 
<p><code>CNN</code>结构设计如下：<br> <img src="https://images2.imgbox.com/7a/0c/VnN5tQVz_o.png" alt="在这里插入图片描述"></p> 
<pre><code>model = Sequential()
model.add(Conv2D(32,kernel_size=(3,3),input_shape=(200,200,3),activation='relu'))
model.add(MaxPooling2D(pool_size=2))
model.add(Conv2D(64,kernel_size=(3,3),activation='relu'))
model.add(MaxPooling2D(pool_size=2))
model.add(Dropout(0.2))
model.add(Flatten())
model.add(Dense(128, activation='relu'))
model.add(Dropout(0.2))
model.add(Dense(1, activation='sigmoid'))
</code></pre> 
<p><img src="https://images2.imgbox.com/a5/74/FgZDXNWd_o.png" alt="在这里插入图片描述"></p> 
<h4><a id="24__220"></a>2.4 设置优化器、损失函数</h4> 
<p><strong>优化器</strong>：<code>Adam</code>。</p> 
<p><strong>损失函数</strong>：交叉熵损失，用于分类。</p> 
<pre><code>model.compile(optimizer='adam', #优化器Adam
              loss='binary_crossentropy', #损失函数：交叉熵损失
              metrics=['accuracy']) #准确率：accuracy:y_/y均为数值；categorical_accuracy:y_/y都是独热码；sparse_categorical_accuracy:y_/y是数值+独热码
model.summary()
</code></pre> 
<p><img src="https://images2.imgbox.com/ac/d9/CQbHpug9_o.png" alt="在这里插入图片描述"></p> 
<h4><a id="25__235"></a>2.5 存取模型、断点续训</h4> 
<p>每训练一个<code>epoch</code>，保存一次模型参数。</p> 
<p><code>tf.keras.callbacks.ModelCheckpoint</code> 函数可以保存模型的权重和偏置，以及训练进度等信息，以便在中断训练后可以恢复到之前的模型状态继续进行训练。</p> 
<p>参数含义：<code>filepath</code> 参数指定了保存模型配置的文件路径，<code>save_weights_only</code> 参数指定是否只保存模型权重，<code>save_best_only</code> 参数指定是否只保存最好的模型结果。默认情况下，该回调函数会在每个 <code>epoch</code> 后保存模型配置。</p> 
<pre><code>#一旦改变模型就要删掉模型文件
checkpoint_save_path = "./checkpoint/mnist.ckpt"
if os.path.exists(checkpoint_save_path + '.index'): #index:
    print('------------------------load the model----------------------------')
    model.load_weights(checkpoint_save_path) #加载模型

cp_callback = tf.keras.callbacks.ModelCheckpoint( #保存模型cp_callback
    filepath=checkpoint_save_path,
    save_weights_only=True, #只保存weight
    save_best_only=True #只保存最好的一次
)

history = model.fit(train_generator,
                 epochs=20,
                 batch_size=128,
                 validation_data=val_generator,
                 validation_freq=1,
                 callbacks=[cp_callback],
                 verbose=1)
</code></pre> 
<p><img src="https://images2.imgbox.com/65/44/VAsN9hdN_o.png" alt="在这里插入图片描述"></p> 
<h4><a id="26__265"></a>2.6 参数保存</h4> 
<p>将训练参数保存至<code>weights.txt</code>文件中。</p> 
<pre><code>file = open('./weights.txt', 'w') #设置weights保存路径
for v in model.trainable_variables:
    file.write(str(v.name) + '\n')
    file.write(str(v.shape) + '\n')
    file.write(str(v.numpy()) + '\n')
file.close()#
</code></pre> 
<h4><a id="27__278"></a>2.7 训练结果可视化</h4> 
<p>通过 <code>matplotlib</code> 库画出训练集和测试集的<code>acc/loss</code>曲线，如下图：</p> 
<pre><code>#训练集acc/loss
acc = history.history['accuracy']
loss = history.history['loss']
#测试集acc/loss
val_acc = history.history['val_accuracy']
val_loss = history.history['val_loss']

#acc曲线
plt.subplot(1,2,1)
plt.plot(acc, label='Training Acc')
plt.plot(val_acc, label='Validation Acc')
plt.title('Training and Validation ACC')
plt.legend()

#loss曲线
plt.subplot(1, 2, 2)
plt.plot(loss, label='Training Loss')
plt.plot(val_loss, label='Validation Loss')
plt.title('Training and Validation Loss')
plt.legend()
plt.show()
</code></pre> 
<p>epoch=10时，模型未收敛：</p> 
<p><img src="https://images2.imgbox.com/be/d6/M5GgXizG_o.png" alt="在这里插入图片描述"></p> 
<p>epoch=20时，</p> 
<p><img src="https://images2.imgbox.com/9c/69/hV0ww5O2_o.png" alt="在这里插入图片描述"></p> 
<h4><a id="28__316"></a>2.8 预测测试集</h4> 
<pre><code>predictions = model.predict(test_generator)
predictions = numpy.round(predictions.flatten()).astype(int)
print(numpy.size(predictions))
</code></pre> 
<p><img src="https://images2.imgbox.com/a1/26/bDqzqOxh_o.png" alt="在这里插入图片描述"></p> 
<p>将测试集上的预测结果存入<code>submission.csv</code>文件。</p> 
<pre><code>submission = pandas.DataFrame({'id':test_idx,'label':predictions})
submission.to_csv("submission.csv",index=False)
df = pandas.read_csv('/kaggle/working/submission.csv')
df.head()
</code></pre> 
<p><img src="https://images2.imgbox.com/c5/19/hstbI7C9_o.png" alt="在这里插入图片描述"></p> 
<h3><a id="3__339"></a>3 总结</h3> 
<p>基于TensorFlow框架，实现了从零开始一步步完成数据读取、网络构建、模型训练和模型 测试等过程，最终实现一个可以进行猫狗图像分类的分类器。通过本实验，掌握在Kaggle平台上实现一个完整竞赛题目的过程，加深了对卷积神经网络用于图像分类任务的理解，提高了实践能力。</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/5f89c614ee6d87a5c21368e679f914e8/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">【数据增强】彻底搞懂数据增强做了哪些工作？</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/9f9150e373b6cd6fd61be933f279ab14/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">npm ERR! code ERESOLVE npm ERR! ERESOLVE could not resolve npm ERR! Vue开发中安装库经常报错</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>