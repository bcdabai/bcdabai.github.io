<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Yarn工作机制 &amp; 三种调度器 - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Yarn工作机制 &amp; 三种调度器" />
<meta property="og:description" content="文章目录 一.Yarn资源调度器1.1 Yarn基础架构1.2 Yarn工作机制 二.Yarn调度器与调度算法2.1 先进先出调度器(FIFO)2.2 容量调度器(Capacity Scheduler)2.2.1 特点2.2.2 调度器资源分配算法 2.3 公平调度器(Fair Scheduler)2.3.1 特点2.3.2 缺额2.3.3 队列资源分配方式2.3.4 调度器资源分配算法 一.Yarn资源调度器 Yarn 是一个资源调度平台，负责为运算程序提供服务器运算资源，相当于一个分布式的操作系统平台，而 MapReduce 等运算程序则相当于运行于操作系统之上的应用程序。
1.1 Yarn基础架构 YARN 主要由 ResourceManager、NodeManager、ApplicationMaster 和Container 等组件构成。
1.2 Yarn工作机制 （1）MR 程序提交到客户端所在的节点。
（2）YarnRunner 向 ResourceManager 申请一个 Application。
（3）RM 将该应用程序的资源路径返回给 YarnRunner。
（4）该程序将运行所需资源提交到 HDFS 上。
（5）程序资源提交完毕后，申请运行 mrAppMaster。
（6）RM 将用户的请求初始化成一个 Task。
（7）其中一个 NodeManager 领取到 Task 任务。
（8）该 NodeManager 创建容器 Container，并产生 MRAppmaster。
（9）Container 从 HDFS 上拷贝资源到本地。
（10）MRAppmaster 向 RM 申请运行 MapTask 资源。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/764f19583cbeea17e77c48d9b7e6dc62/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2024-01-12T14:38:46+08:00" />
<meta property="article:modified_time" content="2024-01-12T14:38:46+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Yarn工作机制 &amp; 三种调度器</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p></p> 
<div class="toc"> 
 <h4>文章目录</h4> 
 <ul><li><ul><li><a href="#Yarn_3" rel="nofollow">一.Yarn资源调度器</a></li><li><ul><li><a href="#11_Yarn_7" rel="nofollow">1.1 Yarn基础架构</a></li><li><a href="#12_Yarn_13" rel="nofollow">1.2 Yarn工作机制</a></li></ul> 
   </li><li><a href="#Yarn_47" rel="nofollow">二.Yarn调度器与调度算法</a></li><li><ul><li><a href="#21_FIFO_57" rel="nofollow">2.1 先进先出调度器(FIFO)</a></li><li><a href="#22_Capacity_Scheduler_66" rel="nofollow">2.2 容量调度器(Capacity Scheduler)</a></li><li><ul><li><a href="#221__70" rel="nofollow">2.2.1 特点</a></li><li><a href="#222__86" rel="nofollow">2.2.2 调度器资源分配算法</a></li></ul> 
    </li><li><a href="#23_Fair_Scheduler_90" rel="nofollow">2.3 公平调度器(Fair Scheduler)</a></li><li><ul><li><a href="#231__94" rel="nofollow">2.3.1 特点</a></li><li><a href="#232__120" rel="nofollow">2.3.2 缺额</a></li><li><a href="#233__128" rel="nofollow">2.3.3 队列资源分配方式</a></li><li><a href="#234__136" rel="nofollow">2.3.4 调度器资源分配算法</a></li></ul> 
   </li></ul> 
  </li></ul> 
 </li></ul> 
</div> 
<p></p> 
<h3><a id="Yarn_3"></a>一.Yarn资源调度器</h3> 
<p><code>Yarn</code> 是一个资源调度平台，负责为运算程序提供服务器运算资源，相当于一个分布式的<code>操作系统平台</code>，而 <code>MapReduce</code> 等运算程序则相当于运行于<code>操作系统之上的应用程序</code>。</p> 
<h4><a id="11_Yarn_7"></a>1.1 Yarn基础架构</h4> 
<p>YARN 主要由 <code>ResourceManager</code>、<code>NodeManager</code>、<code>ApplicationMaste</code>r 和<code>Container</code> 等组件构成。</p> 
<p><img src="https://images2.imgbox.com/35/c7/C26jMPFv_o.png" alt="请添加图片描述"></p> 
<h4><a id="12_Yarn_13"></a>1.2 Yarn工作机制</h4> 
<p><img src="https://images2.imgbox.com/72/c5/omf3Tk8r_o.png" alt="请添加图片描述"></p> 
<p><strong>（1）MR 程序提交到客户端所在的节点。</strong></p> 
<p><strong>（2）YarnRunner 向 ResourceManager 申请一个 Application。</strong></p> 
<p><strong>（3）RM 将该应用程序的资源路径返回给 YarnRunner。</strong></p> 
<p><strong>（4）该程序将运行所需资源提交到 HDFS 上。</strong></p> 
<p><strong>（5）程序资源提交完毕后，申请运行 mrAppMaster。</strong></p> 
<p><strong>（6）RM 将用户的请求初始化成一个 Task。</strong></p> 
<p><strong>（7）其中一个 NodeManager 领取到 Task 任务。</strong></p> 
<p><strong>（8）该 NodeManager 创建容器 Container，并产生 MRAppmaster。</strong></p> 
<p><strong>（9）Container 从 HDFS 上拷贝资源到本地。</strong></p> 
<p><strong>（10）MRAppmaster 向 RM 申请运行 MapTask 资源。</strong></p> 
<p><strong>（11）RM 将运行 MapTask 任务分配给另外两个 NodeManager，另两个 NodeManager 分别领取任务并创建容器。</strong></p> 
<p><strong>（12）MR 向两个接收到任务的 NodeManager 发送程序启动脚本，这两个 NodeManager分别启动 MapTask，MapTask 对数据分区排序。</strong></p> 
<p><strong>（13）MrAppMaster 等待所有 MapTask 运行完毕后，向 RM 申请容器，运行 ReduceTask。</strong></p> 
<p><strong>（14）ReduceTask 向 MapTask 获取相应分区的数据。</strong></p> 
<p><strong>（15）程序运行完毕后，MR 会向 RM 申请注销自己。</strong></p> 
<h3><a id="Yarn_47"></a>二.Yarn调度器与调度算法</h3> 
<p>目前，Hadoop 作业调度器主要有三种：<code>FIFO</code>、<code>容量（Capacity Scheduler）</code>和<code>公平（Fair Scheduler）</code>。Apache <code>Hadoop3.1.3</code>默认的资源调度器是 Capacity Scheduler。</p> 
<p><code>CDH</code> 框架默认调度器是 Fair Scheduler。</p> 
<p>具体设置可查阅：<code>yarn-default.xml</code> 文件：</p> 
<p><img src="https://images2.imgbox.com/5c/5a/nUaKQn9r_o.png" alt="请添加图片描述"></p> 
<h4><a id="21_FIFO_57"></a>2.1 先进先出调度器(FIFO)</h4> 
<p>FIFO 调度器（First In First Out）：<code>单队列</code>，根据提交作业的<code>先后顺序</code>，先来先服务。</p> 
<p><img src="https://images2.imgbox.com/da/74/HaL7vKmR_o.png" alt="请添加图片描述"></p> 
<p>优点：简单易懂；<br> 缺点：不支持多队列，生产环境很少使用；</p> 
<h4><a id="22_Capacity_Scheduler_66"></a>2.2 容量调度器(Capacity Scheduler)</h4> 
<p><strong>Capacity Scheduler 是 Yahoo 开发的多用户调度器。</strong></p> 
<h5><a id="221__70"></a>2.2.1 特点</h5> 
<p><img src="https://images2.imgbox.com/d3/63/LChZGfJC_o.png" alt="请添加图片描述"></p> 
<p>1、多队列：每个队列可配置一定的资源量，<code>每个队列</code>采用<code>FIFO</code>调度策略。</p> 
<p>2、容量保证：管理员可为<code>每个队列</code>设置<code>资源最低保证</code>和<code>资源使用上限</code></p> 
<p>3、灵活性：如果<code>一个队列</code>中的资源<code>有剩余</code>，可以<code>暂时共享</code>给那些<code>需要资源的队列</code>，而一旦该队列有<code>新的应用 程序提交</code>，则其他队列借调的<code>资源会归还</code>给该队列。</p> 
<p>4、多租户：</p> 
<p>支持<code>多用户共享集群</code>和<code>多应用程序同时运行</code>。</p> 
<p>为了防止同一个用户的作业独占队列中的资源，该调度器会对<code>同一用户提交的作业</code>所占<code>资源量</code>进行<code>限定</code>。</p> 
<h5><a id="222__86"></a>2.2.2 调度器资源分配算法</h5> 
<p><img src="https://images2.imgbox.com/c0/fc/4hszKxw8_o.png" alt="请添加图片描述"></p> 
<h4><a id="23_Fair_Scheduler_90"></a>2.3 公平调度器(Fair Scheduler)</h4> 
<p><strong>Fair Schedulere 是 Facebook 开发的多用户调度器。</strong></p> 
<h5><a id="231__94"></a>2.3.1 特点</h5> 
<p><img src="https://images2.imgbox.com/86/b6/v3TseySL_o.png" alt="请添加图片描述"></p> 
<p>1）与容量调度器相同点<br> （1）多队列：支持<code>多队列多作业</code></p> 
<p>（2）容量保证：管理员可为<code>每个队列</code>设置<code>资源最低保证</code>和<code>资源使用上限</code></p> 
<p>（3）灵活性：如果一<code>个队列</code>中的<code>资源</code>有<code>剩余</code>，可以<code>暂时共享</code>给那些<code>需要资源的队列</code>，而一旦该队列有<code>新的应用程序提交</code>，则其他队列借调的资源<code>会归还</code>给该队列。</p> 
<p>（4）多租户：支持<code>多用户共享集群</code>和<code>多应用程序</code>同时运行；为了防止<code>同一个用户</code>的作业<code>独占队列</code>中的<code>资源</code>，该调度器会对<code>同一用户提交的作业</code>所占<code>资源量</code>进行<code>限定</code>。</p> 
<p>2）与容量调度器不同点<br> （1）核心调度策略不同</p> 
<p><code>容量调度器</code>：优先选择<code>资源利用率低</code>的队列</p> 
<p><code>公平调度器</code>：优先选择<code>对资源的缺额比例大</code>的</p> 
<p>（2）每个队列可以单独设置资源分配方式</p> 
<p>容量调度器：<code>FIFO</code>、 <code>DRF</code></p> 
<p>公平调度器：<code>FIFO</code>、<code>FAIR</code>、<code>DRF</code></p> 
<h5><a id="232__120"></a>2.3.2 缺额</h5> 
<p><img src="https://images2.imgbox.com/41/0b/njTYU7aw_o.png" alt="请添加图片描述"></p> 
<p>•公平调度器设计目标是：在时间尺度上，所有作业获得公平的资源。某一时刻一个作业<code>应获资源</code>和<code>实际获取资源</code>的<code>差距</code>叫<code>“缺额”</code></p> 
<p>• 调度器会<code>优先</code>为<code>缺额大</code>的作业<code>分配资源</code></p> 
<h5><a id="233__128"></a>2.3.3 队列资源分配方式</h5> 
<p><img src="https://images2.imgbox.com/a8/26/bWv0e7tW_o.png" alt="请添加图片描述"></p> 
<p><img src="https://images2.imgbox.com/e6/6c/I8AmtnQS_o.png" alt="请添加图片描述"></p> 
<p><img src="https://images2.imgbox.com/20/ab/QkrZeueg_o.png" alt="请添加图片描述"></p> 
<h5><a id="234__136"></a>2.3.4 调度器资源分配算法</h5> 
<p><img src="https://images2.imgbox.com/91/95/3wUvXgQ0_o.png" alt="请添加图片描述"></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/a1d35bcfa2d38ca8293cfa6b4aacce35/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">自动驾驶：低阶可部署的单目测距算法-基于YOLO与透视变换</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/8e692dd5ad368f190d852d016cced2b5/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">如何在前端项目中引入外部字体并使用？</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>