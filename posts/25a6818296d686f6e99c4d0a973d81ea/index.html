<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>[数据结构与算法]11 一篇文章教你搞定递归单链表反转 - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="[数据结构与算法]11 一篇文章教你搞定递归单链表反转" />
<meta property="og:description" content="关于单链表反转,在 [数据结构与算法]04 Link List (链表)及单链表反转实现 中已经写过了,不是使用递归方法来实现的.因为递归不太容易讲清楚.
但是不能因为害怕讲不清楚就不写了,对不对.
所以这篇文章来使用递归来实现一下,并且尝试将里面的细节一一剖出来,不废话.
首先,咱们要先明确,什么是递归.递归就是自己调用自己对吧.比如:有一个函数为 f(n) = f(n-1) * n ,(注意,我这里是举例子,这个函数没有给出递归的结束条件)给 n 赋值为 5 , 则:
--&gt; f(5) --&gt; 5 * f(4) --&gt; 5 * ( 4 * f(3)) --&gt; 5 * ( 4 * (3 * f(2))) --&gt; 5 * ( 4 * ( 3 * ( 2 * f (1)))) --&gt; 5 * ( 4 * ( 3 * ( 2 * 1))) --&gt; 5 * ( 4 * ( 3 * 2)) --&gt; 5 * ( 4 * 6 ) --&gt; 5 * 24 --&gt; 120 在看完例子之后,咱们接下来不 BB ,直接 show code:" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/25a6818296d686f6e99c4d0a973d81ea/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2020-03-22T19:24:40+08:00" />
<meta property="article:modified_time" content="2020-03-22T19:24:40+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">[数据结构与算法]11 一篇文章教你搞定递归单链表反转</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p><font face="华文中宋" size="3">关于单链表反转,在 <a href="https://blog.csdn.net/zll_0405/article/details/103105533">[数据结构与算法]04 Link List (链表)及单链表反转实现</a> 中已经写过了,不是使用递归方法来实现的.因为递归不太容易讲清楚.<br> 但是不能因为害怕讲不清楚就不写了,对不对.<br> 所以这篇文章来使用递归来实现一下,并且尝试将里面的细节一一剖出来,不废话.</font></p> 
<p><font face="华文中宋" size="3">首先,咱们要先明确,什么是递归.递归就是自己调用自己对吧.比如:有一个函数为 <code>f(n) = f(n-1) * n</code> ,(注意,我这里是举例子,这个函数没有给出递归的结束条件)给 n 赋值为 5 , 则:</font></p> 
<pre><code class="prism language-java"><span class="token operator">--</span><span class="token operator">&gt;</span> <span class="token function">f</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span>
<span class="token operator">--</span><span class="token operator">&gt;</span> <span class="token number">5</span> <span class="token operator">*</span> <span class="token function">f</span><span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">)</span>
<span class="token operator">--</span><span class="token operator">&gt;</span> <span class="token number">5</span> <span class="token operator">*</span> <span class="token punctuation">(</span> <span class="token number">4</span> <span class="token operator">*</span> <span class="token function">f</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token operator">--</span><span class="token operator">&gt;</span> <span class="token number">5</span> <span class="token operator">*</span> <span class="token punctuation">(</span> <span class="token number">4</span> <span class="token operator">*</span> <span class="token punctuation">(</span><span class="token number">3</span> <span class="token operator">*</span> <span class="token function">f</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token operator">--</span><span class="token operator">&gt;</span> <span class="token number">5</span> <span class="token operator">*</span> <span class="token punctuation">(</span> <span class="token number">4</span> <span class="token operator">*</span> <span class="token punctuation">(</span> <span class="token number">3</span> <span class="token operator">*</span> <span class="token punctuation">(</span> <span class="token number">2</span> <span class="token operator">*</span> f <span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token operator">--</span><span class="token operator">&gt;</span> <span class="token number">5</span> <span class="token operator">*</span> <span class="token punctuation">(</span> <span class="token number">4</span> <span class="token operator">*</span> <span class="token punctuation">(</span> <span class="token number">3</span> <span class="token operator">*</span> <span class="token punctuation">(</span> <span class="token number">2</span> <span class="token operator">*</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token operator">--</span><span class="token operator">&gt;</span> <span class="token number">5</span> <span class="token operator">*</span> <span class="token punctuation">(</span> <span class="token number">4</span> <span class="token operator">*</span> <span class="token punctuation">(</span> <span class="token number">3</span> <span class="token operator">*</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token operator">--</span><span class="token operator">&gt;</span> <span class="token number">5</span> <span class="token operator">*</span> <span class="token punctuation">(</span> <span class="token number">4</span> <span class="token operator">*</span> <span class="token number">6</span> <span class="token punctuation">)</span>
<span class="token operator">--</span><span class="token operator">&gt;</span> <span class="token number">5</span> <span class="token operator">*</span> <span class="token number">24</span>
<span class="token operator">--</span><span class="token operator">&gt;</span> <span class="token number">120</span>
</code></pre> 
<p><font face="华文中宋" size="3">在看完例子之后,咱们接下来不 BB ,直接 show code:</font></p> 
<pre><code class="prism language-java"><span class="token comment">/**
 * 单链表反转---递归实现
 * @author 郑璐璐
 * @date 2020-3-14 08:47:54
 */</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ReverseSingleList</span> <span class="token punctuation">{<!-- --></span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">Node</span><span class="token punctuation">{<!-- --></span>
        <span class="token keyword">private</span> <span class="token keyword">int</span> data<span class="token punctuation">;</span>
        <span class="token keyword">private</span> Node next<span class="token punctuation">;</span>

        <span class="token keyword">public</span> <span class="token function">Node</span><span class="token punctuation">(</span> <span class="token keyword">int</span> data <span class="token punctuation">,</span> Node next<span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
            <span class="token keyword">this</span><span class="token punctuation">.</span>data <span class="token operator">=</span> data<span class="token punctuation">;</span>
            <span class="token keyword">this</span><span class="token punctuation">.</span>next <span class="token operator">=</span> next<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>

        <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">getData</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span><span class="token keyword">return</span>  data<span class="token punctuation">;</span><span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
        <span class="token comment">// 初始化单链表</span>
        Node node5 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Node</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">,</span>null<span class="token punctuation">)</span><span class="token punctuation">;</span>
        Node node4 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Node</span><span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">,</span>node5<span class="token punctuation">)</span><span class="token punctuation">;</span>
        Node node3 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Node</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">,</span>node4<span class="token punctuation">)</span><span class="token punctuation">;</span>
        Node node2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Node</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span>node3<span class="token punctuation">)</span><span class="token punctuation">;</span>
        Node node1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Node</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span>node2<span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token comment">// 调用反转方法</span>
        Node recursiveList <span class="token operator">=</span> <span class="token function">recursiveList</span><span class="token punctuation">(</span>node1<span class="token punctuation">)</span><span class="token punctuation">;</span>
        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>recursiveList<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token comment">/**
     *递归实现单链表反转
     * @param list 为传入的单链表
     * @author 郑璐璐
     * @date 2020-3-14 08:55:45
     */</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> Node <span class="token function">recursiveList</span><span class="token punctuation">(</span>Node list<span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
        <span class="token comment">// 如果链表为空 或者 链表中只有一个节点,直接返回</span>
        <span class="token comment">// 也是递归结束的条件</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>list <span class="token operator">==</span> null <span class="token operator">||</span> list<span class="token punctuation">.</span>next <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token keyword">return</span> list<span class="token punctuation">;</span>
        Node recursive <span class="token operator">=</span> <span class="token function">recursiveList</span><span class="token punctuation">(</span>list<span class="token punctuation">.</span>next<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">// 将 list.next.next 指针指向当前链表 list</span>
        list<span class="token punctuation">.</span>next<span class="token punctuation">.</span>next <span class="token operator">=</span> list <span class="token punctuation">;</span>
        <span class="token comment">// 将 list.next 指针指向 null</span>
        list<span class="token punctuation">.</span>next <span class="token operator">=</span> null<span class="token punctuation">;</span>
        <span class="token comment">// 返回反转之后的链表 recursive</span>
        <span class="token keyword">return</span> recursive<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> 
<p><font face="华文中宋" size="3">经过上面的代码,应该能够看到核心代码就是,递归实现单链表反转部分的那 5 行代码,别小看了这 5 行代码,想要真正弄清楚还真的挺不容易的.<br> 我把这 5 行代码贴在这里,咱们一行行分析,争取看完这篇博客就能懂~(注释我就去掉了,咱们专心看这几行核心代码)</font></p> 
<pre><code class="prism language-java"><span class="token keyword">if</span> <span class="token punctuation">(</span>list <span class="token operator">==</span> null <span class="token operator">||</span> list<span class="token punctuation">.</span>next <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token keyword">return</span> list<span class="token punctuation">;</span>
Node recursive <span class="token operator">=</span> <span class="token function">recursiveList</span><span class="token punctuation">(</span>list<span class="token punctuation">.</span>next<span class="token punctuation">)</span><span class="token punctuation">;</span>
list<span class="token punctuation">.</span>next<span class="token punctuation">.</span>next <span class="token operator">=</span> list <span class="token punctuation">;</span>
list<span class="token punctuation">.</span>next <span class="token operator">=</span> null<span class="token punctuation">;</span>
<span class="token keyword">return</span> recursive<span class="token punctuation">;</span>
</code></pre> 
<p><font face="华文中宋" size="3">第一行就是一个判断,条件不满足,那就往下走,第二行是自己调用自己,程序又回到第一行,不满足条件程序向下执行,自己调用自己<br> 就这样循环到符合条件为止,那么什么时候符合条件呢?也就是 <code>list == null</code> 或者 <code>list.next == null</code> 时,看一下自己定义的链表是 <code>1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;null</code> ,所以符合条件时,此时的链表为 <code>5-&gt;null</code> ,符合条件之后,程序继续向下执行,在执行完 <code>Node recursive = recursiveList(list.next);</code> 这行代码之后,咱们来看一下此时的程序执行结果:<br> <img src="https://images2.imgbox.com/9a/3d/RrbV0LSF_o.jpg" alt="在这里插入图片描述"><br> <font face="华文中宋" size="3">我把上面这个给画出来(画工不好,不要在乎它的美丑~)<br> <img src="https://images2.imgbox.com/92/c9/MAIqmNuc_o.jpg" alt="在这里插入图片描述"><br> <font face="华文中宋" size="3">接下来程序该执行 <code>list.next.next = list</code> 执行结束之后,链表大概就是这个样子:<br> <img src="https://images2.imgbox.com/3c/e8/AxAyR1tU_o.jpg" alt="在这里插入图片描述"><br> <font face="华文中宋" size="3">那是图,下面是程序断点调试程序的结果,发现和上面的图是一样的:<br> <img src="https://images2.imgbox.com/df/af/5HqTcSop_o.jpg" alt="在这里插入图片描述"><br> <font face="华文中宋" size="3">程序继续向下走 <code>list.next = null</code> ,也就是说,将 list 的 next 指针指向 null :<br> <img src="https://images2.imgbox.com/1a/61/4h8mCMCA_o.jpg" alt="在这里插入图片描述"><br> <font face="华文中宋" size="3">从图中看到, list 为 <code>4-&gt;null</code> , recursive 为 <code>5-&gt;4-&gt;null</code> ,咱们来看看程序的结果,是不是和图相符:<br> <img src="https://images2.imgbox.com/c5/4d/DRlFCkNd_o.jpg" alt="在这里插入图片描述"><br> <font face="华文中宋" size="3">完全一样有没有!<br> OK ,还记得咱们刚开始的递归函数例子嘛?现在执行完毕,开始执行下一次,咱们继续来看,此时的链表是这个样子的:<br> <img src="https://images2.imgbox.com/0d/04/NZsJ1tpW_o.jpg" alt="在这里插入图片描述"></font></font></font></font></font></font></font></p> 
<p><font face="华文中宋" size="3">接下来程序执行的代码就是四行了:</font></p> 
<pre><code>Node recursive = recursiveList(list.next);
list.next.next = list ;
list.next = null;
return recursive;
</code></pre> 
<p><font face="华文中宋" size="3">继续执行程序,咱们来看结果,将 <code>list.next.next = list</code> 运行结束时,此时链表为:<br> <img src="https://images2.imgbox.com/5d/8a/AWSglQQA_o.jpg" alt="在这里插入图片描述"></font></p> 
<p><font face="华文中宋" size="3">从图中能够看到,链表 list 为 <code>3-&gt;4-&gt;3-&gt;4</code> 循环中, recursive 为 <code>5-&gt;4-&gt;3-&gt;4-&gt;3</code> 循环,咱们看一下程序是不是也是如此(在这里我截了两个循环作为示例):<br> <img src="https://images2.imgbox.com/49/1c/B4d6GzNo_o.jpg" alt="在这里插入图片描述"><br> <font face="华文中宋" size="3">接下来程序执行 <code>list.next = null</code> ,执行完毕之后,就是将 list 的 next 指针指向 null :<br> <img src="https://images2.imgbox.com/a7/34/pudY73bg_o.jpg" alt="在这里插入图片描述"><br> <font face="华文中宋" size="3">从图中能够看出来, list 为 <code>3-&gt;null</code> , recursive 为 <code>5-&gt;4-&gt;3-&gt;null</code> ,上图看看实际结果和分析的是否一致:<br> <img src="https://images2.imgbox.com/da/6c/tpffV2iH_o.jpg" alt="在这里插入图片描述"><br> <font face="华文中宋" size="3">说明什么?!<br> 说明咱们上面的分析是正确的~<br> 接下来的程序分析,读者就自行研究吧`<br> 相信接下来的分析就难不倒你了~</font></font></font></font></p> 
<h2><a id="font_face_size3__N__122"></a><font face="华文中宋" size="3">反转单链表的前 N 个节点</font></h2> 
<p><font face="华文中宋" size="3">OK ,咱们趁热打铁一下,刚刚是通过递归实现了整个单链表反转,那如果我只是想反转前 N 个节点呢?<br> 比如单链表为 <code>1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;null</code> ,现在我只想反转前三个节点,变为 <code>3-&gt;2-&gt;1-&gt;4-&gt;5-&gt;null</code><br> 有没有想法?<br> 咱们进行整个单链表反转时,可以理解为传递了一个参数 n ,这个 n 就是单链表的长度,然后递归程序不断调用自己,然后实现了整个单链表反转.<br> 那么,如果我想要反转前 N 个节点,是不是传递一个参数 n 来解决就好了?<br> 咱们就直接上代码了:</font></p> 
<pre><code class="prism language-java">    <span class="token comment">/**
     *反转单链表前 n 个节点
     * @param list 为传入的单链表 , n 为要反转的前 n 个节点
     * @author 郑璐璐
     * @date 2020-3-14 09:13:16
     */</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> Node next<span class="token punctuation">;</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> Node <span class="token function">reverseListN</span><span class="token punctuation">(</span>Node list<span class="token punctuation">,</span><span class="token keyword">int</span> n<span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>n <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
            <span class="token comment">// 要进行反转链表时,先将 list 后的节点数据保存到 next 中</span>
            next <span class="token operator">=</span> list<span class="token punctuation">.</span>next<span class="token punctuation">;</span>
            <span class="token keyword">return</span>  list<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>

        Node reverse <span class="token operator">=</span> <span class="token function">reverseListN</span><span class="token punctuation">(</span>list<span class="token punctuation">.</span>next <span class="token punctuation">,</span> n<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        list<span class="token punctuation">.</span>next<span class="token punctuation">.</span>next <span class="token operator">=</span> list<span class="token punctuation">;</span>
        <span class="token comment">// 将 list.next 的指针指向没有进行反转的链表</span>
        list<span class="token punctuation">.</span>next <span class="token operator">=</span> next <span class="token punctuation">;</span>
        <span class="token keyword">return</span> reverse<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
</code></pre> 
<h2><a id="font_face_size3__152"></a><font face="华文中宋" size="3">反转单链表的一部分</font></h2> 
<p><font face="华文中宋" size="3">既然反转整个单链表实现了,反转前 N 个节点实现了,那么如果有个需求是反转其中的一部分数据呢?大概就是这样,原来的链表为 <code>1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;null</code> ,反转其中的一部分,使反转后的链表为 <code>1-&gt;4-&gt;3-&gt;2-&gt;5-&gt;null</code><br> 借用反转前 N 个节点的思路,是不是我传两个参数进来,一个是开始反转的节点,一个是结束反转的节点,然后递归操作就可以了?<br> 瞅瞅代码是怎么写的:</font></p> 
<pre><code class="prism language-java">    <span class="token comment">/**
     *反转部分单链表
     * @param list 为传入的单链表, m 为开始反转的节点, n 为结束的反转节点
     * @author 郑璐璐
     * @date 2020-3-14 09:32:01
     */</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> Node <span class="token function">reverseBetween</span><span class="token punctuation">(</span>Node list <span class="token punctuation">,</span> <span class="token keyword">int</span> m <span class="token punctuation">,</span> <span class="token keyword">int</span> n<span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>m <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
            <span class="token keyword">return</span> <span class="token function">reverseListN</span><span class="token punctuation">(</span>list<span class="token punctuation">,</span>n<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        list<span class="token punctuation">.</span>next <span class="token operator">=</span> <span class="token function">reverseBetween</span><span class="token punctuation">(</span>list<span class="token punctuation">.</span>next<span class="token punctuation">,</span>m<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span>n<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span> list<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
</code></pre> 
<p><font face="华文中宋" size="3">大早上就开始写代码验证 + 写这篇文章,终于给弄清楚了<br> 最后两个例子,读者们可以自行研究,我这里因为篇幅的问题就不进行解析了,如果第一个例子自己能够剖析清楚,下面两个也没啥大问题~</font></p> 
<p><font face="华文中宋" size="3">以上,就是这篇文章想要分享的内容啦<br> 感谢您的阅读哇~</font></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/29945b2661e7d661294a24bb912b697b/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">vue&#43;element-ui中上传文件使用Progress自定义实时更新进度条</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/85004aee1188a6d7d98ebc0c5c2f32e0/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">详解jQuery动画</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>