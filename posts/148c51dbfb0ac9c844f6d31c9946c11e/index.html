<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>【自定义镜像—Dockerfile完全指南】常用的十三种dockerfile指令及构建Tomcat镜像例子 - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="【自定义镜像—Dockerfile完全指南】常用的十三种dockerfile指令及构建Tomcat镜像例子" />
<meta property="og:description" content="Dockerfile完全指南 什么是Dockerfile 概述 Dockerfile是一个文本格式的配置文件，用户可以使用Dockerfile快速创建自定义的镜像。
基本结构 Dockerfile由一行行命令语句组成，并且支持以 # 开头的注释行。一般而言，Dockerfile分为四部分:基础镜像信息、维护者信息、镜像操作指令和容器启动时执行指令。
例如:
## Dockerfile文件格式 # 1、第一行必须指定 基础镜像信息 FROM java:8 # 2、维护者信息 MAINTAINER oldGj_ oldGj_@163.com # 3、镜像操作指令 RUN echo &#34;wget https://dlcdn.apache.org/tomcat/tomcat-9/v9.0.55/bin/apache-tomcat-9.0.55.tar.gz&#34; run tar -zxvf apache-tomcat-9.0.55.tar.gz -C /usr/local # 4、容器启动执行指令 CMD /usr/local/tomcat/bin/catalina.sh Dockerfile 四部分说明：
一开始必须要指明所基于的镜像名称, 关键字是FROM, 这是必须的.接下来是维护者信息关键字是MAINTAINER, 非必须, 但良好的习惯有利于后期的职责明确.后面是镜像操作指令, 如RUN等, 每执行一条RUN命令,镜像添加新的一层.最后是CMD指令,来指明运行容器时的操作命令. 构建镜像 简单示例
在一个空白的文本文件, 命名为Dockerfile
vim Dockerfile 示例1
Dockerfile文件内容:
#基础镜像 FROM centos #维护者 MAINTAINER oldGj_&lt;oldGj_@163.com&gt; #运行命令 RUN &#34;yum install wget&#34; #启动容器运行命令 CMD echo &#34;hello Dockerfile&#34;" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/148c51dbfb0ac9c844f6d31c9946c11e/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2024-01-29T12:20:33+08:00" />
<meta property="article:modified_time" content="2024-01-29T12:20:33+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">【自定义镜像—Dockerfile完全指南】常用的十三种dockerfile指令及构建Tomcat镜像例子</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <h3><a id="Dockerfile_0"></a><strong>Dockerfile完全指南</strong></h3> 
<h3><a id="Dockerfile_2"></a>什么是Dockerfile</h3> 
<p><img src="https://images2.imgbox.com/06/db/2geaYmmW_o.png" alt="在这里插入图片描述"></p> 
<h4><a id="_7"></a>概述</h4> 
<p>Dockerfile是一个<strong>文本格式</strong>的配置文件，用户可以<strong>使用Dockerfile快速创建自定义的镜像。</strong></p> 
<p><img src="https://images2.imgbox.com/e1/1b/xyFGuAno_o.png" alt="在这里插入图片描述"></p> 
<h4><a id="_14"></a>基本结构</h4> 
<p>Dockerfile由一行行<strong>命令语句</strong>组成，并且支持以 # 开头的注释行。一般而言，Dockerfile分为四部分:<strong>基础镜像信息</strong>、<strong>维护者信息</strong>、<strong>镜像操作指令</strong>和<strong>容器启动时执行指令</strong>。</p> 
<p><strong>例如:</strong></p> 
<pre><code class="prism language-dockerfile">##  Dockerfile文件格式 
# 1、第一行必须指定 基础镜像信息
FROM java:8
# 2、维护者信息
MAINTAINER oldGj_  oldGj_@163.com
# 3、镜像操作指令
RUN  echo "wget https://dlcdn.apache.org/tomcat/tomcat-9/v9.0.55/bin/apache-tomcat-9.0.55.tar.gz"
run tar -zxvf apache-tomcat-9.0.55.tar.gz -C /usr/local
# 4、容器启动执行指令
CMD /usr/local/tomcat/bin/catalina.sh
</code></pre> 
<blockquote> 
 <p><strong>Dockerfile 四部分说明：</strong></p> 
 <ul><li>一开始必须要指明所基于的镜像名称, 关键字是FROM, 这是必须的.</li><li>接下来是维护者信息关键字是MAINTAINER, 非必须, 但良好的习惯有利于后期的职责明确.</li><li>后面是镜像操作指令, 如RUN等, 每执行一条RUN命令,镜像添加新的一层.</li><li>最后是CMD指令,来指明运行容器时的操作命令.</li></ul> 
</blockquote> 
<h3><a id="_42"></a>构建镜像</h3> 
<p><img src="https://images2.imgbox.com/b6/36/jfwY5j4B_o.png" alt="在这里插入图片描述"></p> 
<p><strong>简单示例</strong></p> 
<p>在一个空白的文本文件, 命名为Dockerfile</p> 
<pre><code class="prism language-shell"><span class="token function">vim</span>  Dockerfile
</code></pre> 
<p><strong>示例1</strong></p> 
<p>Dockerfile文件内容:</p> 
<pre><code class="prism language-dockerfile">#基础镜像
FROM centos
#维护者
MAINTAINER oldGj_&lt;oldGj_@163.com&gt;
#运行命令
RUN "yum install wget"
#启动容器运行命令
CMD echo "hello Dockerfile"
</code></pre> 
<p><strong>示例2</strong></p> 
<p>Dockerfile文件内容:</p> 
<pre><code class="prism language-dockerfile">FROM java:8
MAINTAINER WCC 
CMD java -version
</code></pre> 
<h4><a id="_80"></a>构建镜像</h4> 
<pre><code class="prism language-shell">docker build -t 镜像名字:版本 <span class="token builtin class-name">.</span> 
</code></pre> 
<blockquote> 
 <p>注意</p> 
 <p>. 代表Dockerfile文件在当前路径</p> 
</blockquote> 
<h3><a id="13_92"></a>常见的13种指令</h3> 
<p><img src="https://images2.imgbox.com/32/d0/9y8qqiOg_o.png" alt="在这里插入图片描述"></p> 
<h4><a id="FROM_97"></a>FROM</h4> 
<p>指定基础镜像，必须为第一个命令。</p> 
<p><strong>指令格式：</strong></p> 
<pre><code class="prism language-dockerfile">FROM &lt;image&gt;　　
FROM &lt;image&gt;:&lt;tag&gt;　　
</code></pre> 
<blockquote> 
 <p><strong>注意：</strong></p> 
 <p>tag或digest是可选的，如果不使用这两个值时，会使用latest版本的基础镜像</p> 
</blockquote> 
<h4><a id="MAINTAINER_112"></a>MAINTAINER</h4> 
<p>维护者信息</p> 
<p><strong>指令格式：</strong></p> 
<pre><code class="prism language-dockerfile">MAINTAINER &lt;name&gt;
</code></pre> 
<p><strong>示例</strong></p> 
<pre><code class="prism language-dockerfile"> MAINTAINER Jasper Xu   MAINTAINER sorex@163.com  
</code></pre> 
<h4><a id="WORKDIR_128"></a>WORKDIR</h4> 
<p>工作目录，类似于cd命令</p> 
<p><strong>指令格式：</strong></p> 
<pre><code class="prism language-dockerfile">WORKDIR /usr/workdir
</code></pre> 
<p><strong>示例</strong></p> 
<pre><code class="prism language-dockerfile">WORKDIR /a  (这时工作目录为/a)
WORKDIR b  (这时工作目录为/a/b)
WORKDIR c  (这时工作目录为/a/b/c)
</code></pre> 
<p><strong>示例</strong></p> 
<pre><code class="prism language-dockerfile">WORKDIR /OPT
RUN mkdir docker
WORKDIR /usr/local
RUN echo "test" &gt; a.info
</code></pre> 
<blockquote> 
 <p><strong>注意：</strong> 通过WORKDIR设置工作目录后，Dockerfile中其后的命令RUN、CMD、ENTRYPOINT、ADD、COPY等命令都会在该目录下执行。在使用docker run运行容器时，可以通过-w参数覆盖构建时所设置的工作目录。</p> 
</blockquote> 
<h4><a id="RUN_157"></a>RUN</h4> 
<p>构建镜像时执行的命令</p> 
<p><strong>指令语法：</strong></p> 
<pre><code class="prism language-dockerfile"># 1. shell执行
格式 RUN &lt;command&gt;
# 2. exec执行
格式 RUN ["executable", "param1", "param2"]
</code></pre> 
<p><strong>示例</strong></p> 
<pre><code class="prism language-dockerfile">WORKDIR /OPT
RUN mkdir docker
WORKDIR /usr/local
RUN echo "test" &gt; a.info
</code></pre> 
<blockquote> 
 <p><strong>注意：</strong></p> 
 <p>RUN指令创建的中间镜像会被缓存，并会在下次构建中使用。如果不想使用这些缓存镜像，可以在构建时指定–no-cache参数，如：docker build --no-cache</p> 
</blockquote> 
<h4><a id="ADD_183"></a>ADD</h4> 
<p>将本地文件添加到容器中，tar类型文件会自动解压(网络压缩资源不会被解压)，可以访问网络资源，类似wget。</p> 
<p><strong>指令格式：</strong></p> 
<pre><code class="prism language-dockerfile"> ADD &lt;src&gt;... &lt;dest&gt;  
 ADD ["&lt;src&gt;",... "&lt;dest&gt;"] 用于支持包含空格的路径示例：  
</code></pre> 
<p><strong>示例</strong></p> 
<p>添加所有以"hom"开头的文件</p> 
<pre><code class="prism language-dockerfile">ADD hom* /mydir/ 
</code></pre> 
<p>? 替代一个单字符,例如：“home.txt”</p> 
<pre><code class="prism language-dockerfile">ADD hom?.txt /mydir/   
</code></pre> 
<p>添加 “test” 到 WORKDIR/relativeDir/</p> 
<pre><code class="prism language-dockerfile">ADD test relativeDir
</code></pre> 
<p>添加 “test” 到 /absoluteDir/</p> 
<pre><code class="prism language-dockerfile">ADD test /absoluteDir/
</code></pre> 
<h4><a id="COPY_220"></a>COPY</h4> 
<p>功能类似ADD，但是是不会自动解压文件，也不能访问网络资源。</p> 
<p><strong>语法格式：</strong></p> 
<pre><code class="prism language-dockerfile">COPY &lt;源路径&gt;  &lt;目标路径&gt;
</code></pre> 
<p><strong>示例</strong></p> 
<pre><code class="prism language-dockerfile">COPY ./start.sh /start.sh
</code></pre> 
<h4><a id="CMD_236"></a>CMD</h4> 
<p>构建容器后调用，也就是在容器启动时才进行调用。指定这个容器启动的时候要运行的命令只有最后一个会生效可被替换。</p> 
<p><strong>指令格式：</strong></p> 
<pre><code class="prism language-dockerfile">CMD指令与RUN指令相似，也具有两种格式：
1. shell格式：CMD &lt;命令&gt;
2. exec格式： CMD ["可执行文件", "参数1", "参数2", …]
</code></pre> 
<p><strong>示例</strong></p> 
<pre><code class="prism language-dockerfile">CMD echo "This is a test." | wc -
CMD ["/usr/bin/wc","--help"]
</code></pre> 
<blockquote> 
 <p>注意： CMD不同于RUN，CMD用于指定在容器启动时所要执行的命令，而RUN用于指定镜像构建时所要执行的命令。</p> 
</blockquote> 
<h4><a id="ENTRYPOINT_262"></a>ENTRYPOINT</h4> 
<p>配置容器，使其可执行化。配合CMD可省去"application"，只使用参数。</p> 
<p>指定容器启动的要运行的命令，可以追加命令</p> 
<p><strong>指令格式：</strong></p> 
<pre><code class="prism language-dockerfile">ENTRYPOINT ["executable", "param1", "param2"] 
ENTRYPOINT command param1 param2 (shell内部命令)
</code></pre> 
<p><strong>示例</strong></p> 
<pre><code class="prism language-dockerfile">ENTRYPOINT ["top", "-b"]
</code></pre> 
<blockquote> 
 <p><strong>注意：</strong></p> 
 <p>ENTRYPOINT与CMD非常类似，不同的是通过docker run执行的命令不会覆盖ENTRYPOINT，而docker run命令中指定的任何参数，都会被当做参数再次传递给ENTRYPOINT。Dockerfile中只允许有一个ENTRYPOINT命令，多指定时会覆盖前面的设置，而只执行最后的ENTRYPOINT指令。</p> 
</blockquote> 
<h4><a id="ENV_285"></a>ENV</h4> 
<p>这个指令非常简单，就是用于设置环境变量而已，无论是接下来的指令，还是在容器中运行的程序，都可以使用这里定义的环境变量。</p> 
<p><strong>指令格式：</strong></p> 
<pre><code class="prism language-dockerfile">ENV &lt;key&gt;=&lt;value&gt;
</code></pre> 
<p><strong>示例</strong></p> 
<pre><code class="prism language-dockerfile">ENV JAVA_HOME=/usr/local/jdk1.7.0_79
ENV PATH=$JAVA_HOME/bin:$PATH
</code></pre> 
<h4><a id="EXPOSE_302"></a>EXPOSE</h4> 
<p>指定于外界交互的端口</p> 
<p><strong>指令格式：</strong></p> 
<blockquote> 
 <p>EXPOSE</p> 
</blockquote> 
<p><strong>示例</strong></p> 
<pre><code class="prism language-dockerfile">EXPOSE 80
</code></pre> 
<blockquote> 
 <p><strong>注意：</strong></p> 
 <p>EXPOSE并不会让容器的端口访问到主机。要使其可访问，需要在docker run运行容器时通过-p来发布这些端口，或通过-P参数来发布EXPOSE导出的所有端口。</p> 
</blockquote> 
<h4><a id="VOLUME_320"></a>VOLUME</h4> 
<p>用于指定持久化目录</p> 
<p><strong>指令格式：</strong></p> 
<pre><code class="prism language-dockerfile">VOLUME ["/path/to/dir"]
</code></pre> 
<p><strong>示例</strong></p> 
<pre><code class="prism language-dockerfile">VOLUME ["/data"]
VOLUME ["/var/www", "/var/log/apache2"]
</code></pre> 
<blockquote> 
 <p><strong>注意：</strong></p> 
 <p>一个卷可以存在于一个或多个容器的指定目录，该目录可以绕过联合文件系统，并具有以下功能：</p> 
 <pre><code>1 卷可以容器间共享和重用
2 容器并不一定要和其它容器共享卷
3 修改卷后会立即生效
4 对卷的修改不会对镜像产生影响
5 卷会一直存在，直到没有任何容器在使用它

</code></pre> 
</blockquote> 
<h4><a id="USER_350"></a>USER</h4> 
<p><code>USER</code>指令用于将会用以什么样的用户去运行</p> 
<p><strong>指令格式：</strong></p> 
<pre><code class="prism language-dockerfile">USER user
USER user:group
</code></pre> 
<blockquote> 
 <p><strong>注意：</strong></p> 
 <p>使用USER指定用户后，Dockerfile中其后的命令RUN、CMD、ENTRYPOINT都将使用该用户。镜像构建完成后，通过<code>docker run</code>运行容器时，可以通过-u参数来覆盖所指定的用户。</p> 
</blockquote> 
<h4><a id="ONBUILD_365"></a>ONBUILD</h4> 
<p>帮助别人定制而准备的</p> 
<p><strong>指令格式：</strong></p> 
<pre><code class="prism language-dockerfile">ONBUILD [INSTRUCTION]
</code></pre> 
<p><strong>示例</strong></p> 
<pre><code class="prism language-dockerfile">FROM centos
WORKDIR /data
ONBUILD RUN mkdir test

FROM test:02
</code></pre> 
<h3><a id="CMDENTRYPOINT_389"></a>CMD和ENTRYPOINT的区别</h3> 
<p><img src="https://images2.imgbox.com/74/af/Xq5oK9D5_o.png" alt="在这里插入图片描述"></p> 
<blockquote> 
 <p><strong>区别：</strong></p> 
 <ul><li>CMD #指定这个容器启动的时候要运行的命令，可被替换</li><li>ENTRYPOINT #指定这个容器启动的时候要运行的命令，可以追加命令</li></ul> 
</blockquote> 
<p><strong>例子</strong></p> 
<p><strong>Dockerfile文件</strong></p> 
<pre><code class="prism language-dockerfile">#基础镜像
from centos
#启动容器运行命令
CMD ["ls" ,"-a"]
</code></pre> 
<p><strong>构建镜像</strong></p> 
<pre><code class="prism language-dockerfile">docker build -t test04:v1 .
</code></pre> 
<h3><a id="Dockerfile_418"></a><strong>Dockerfile综合实验</strong></h3> 
<h3><a id="Tomcat_420"></a>构建Tomcat镜像</h3> 
<p><img src="https://images2.imgbox.com/fc/18/eizEsRGj_o.png" alt="在这里插入图片描述"></p> 
<p>首先，尝试在DockerHub上搜索Tomcat相关镜像的个数</p> 
<pre><code>docker search tomcat |wc -l
</code></pre> 
<blockquote> 
 <p>有26个,如果是个人开发或者测试，随意使用一个，若是生产环境使用，就不合适了。</p> 
 <ul><li>项目需要的Tomcat版本可能不同。</li><li>项目需要的Tomcat变量不一致。</li><li>项目需要的JDK可能不一致。</li></ul> 
 <p>因此比较好的方式有架构师或者项目经理通过Dockerfile或者其他方法构建统一的镜像，然后分发给项目组所有成员来进行。</p> 
</blockquote> 
<h4><a id="_439"></a>构建步骤</h4> 
<ol><li>编写一个dockerfile 文件</li><li>docker build构建成为一个镜像</li><li>docker run运行镜像</li></ol> 
<h4><a id="Dockerfile_445"></a>Dockerfile文件</h4> 
<pre><code class="prism language-dockerfile">#基础镜像
FROM  openjdk:11
#维护者
MAINTAINER oldGj_&lt;oldGj_@163.com&gt;
#拷贝tomcat包
ADD  ./apache-tomcat-9.0.50.tar.gz /usr/local
#设置工作目录
WORKDIR /usr/local
#设置tomcat环境变量
ENV TOMCAT_HOME=/usr/local/apache-tomcat-9.0.50
ENV PATH=$PATH:$TOMCAT_HOME/bin
#保留端口
EXPOSE 8080
#启动容器运行命令
CMD startup.sh &amp;&amp; tail -F /usr/local/apache-tomcat-9.0.50/bin/catalina.bat
</code></pre>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/45a0eb1df06e03a90024284b6c2bb59d/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">2024 最火的技术话题</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/31f4794e97aa181ab89479a3046732aa/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">手把手带你Git入门，从下载到精通，常用git命令</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>