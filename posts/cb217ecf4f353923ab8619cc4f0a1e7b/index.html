<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Transformer技术深度剖析：AI语言处理的新纪元 - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Transformer技术深度剖析：AI语言处理的新纪元" />
<meta property="og:description" content="1.Transformer全局概括 Transformer是一种深度学习模型，最初由Vaswani等人在2017年的论文《Attention Is All You Need》中提出。它在自然语言处理（NLP）领域引起了革命，因为它的设计克服了以前模型的一些限制，特别是在处理长距离依赖和并行计算方面。下面是Transformer模型的全面概述：
1.核心概念 注意力机制（Attention Mechanism）：
Transformer的核心是注意力机制，特别是所谓的“自注意力”（Self-Attention）。它允许模型在处理一个单词时同时考虑句子中的其他单词，从而捕获它们之间的上下文关系。 编码器-解码器架构：
原始的Transformer模型包括编码器（Encoder）和解码器（Decoder）。编码器读取输入数据并产生一个上下文表示，解码器则使用这个表示来生成输出数据。 多头注意力（Multi-Head Attention）：
模型对每个单词的注意力分为多个“头”，这样可以让模型在多个子空间中学习信息。这增强了模型对不同位置的敏感性，能够捕获不同类型的上下文信息。 位置编码（Positional Encoding）：
由于Transformer不使用递归或卷积，因此需要另一种方法来理解单词的顺序或位置。位置编码是添加到输入单词的一种编码，提供了单词在序列中的位置信息。 堆叠层：
Transformer中的编码器和解码器都是由多个相同的层堆叠而成。每层包含多头注意力机制和全连接的前馈网络。 2.应用 机器翻译：Transformer模型最初是为了改进机器翻译而设计的，但它迅速被应用于各种NLP任务。文本生成：如GPT系列模型，它们是基于Transformer的架构，专注于生成连贯和相关的文本。文本理解：如BERT和其变体，它们利用Transformer编码器来理解文本，广泛用于问答系统、情感分析等。 3.优势与挑战 优势：
能够捕获长距离依赖。高效的并行处理能力。在多种NLP任务上取得了先进的性能。 挑战：
模型参数通常非常庞大，需要大量的计算资源进行训练。对于输入序列的长度有限制，主要是因为计算复杂度和内存要求。 Transformer模型自推出以来，已成为NLP领域的一项关键技术，推动了包括文本分类、摘要、机器翻译等多个领域的发展。此外，它的核心思想和技术也被应用于计算机视觉和其他机器学习任务中。
2.编码器（Encoder） Transformer编码器的底层实现涉及多个组件和步骤，这些组件共同构成了Transformer编码器的核心功能。
以下是其实现流程的详细介绍：
1. 输入嵌入（Input Embedding） 首先，输入序列（如一句话中的单词或字符）被转换成固定大小的向量。这一步通常使用嵌入层完成，每个唯一的输入单元（如单词）都被映射到高维空间中的一个稠密向量。
2. 位置编码（Positional Encoding） 由于Transformer本身不具备捕捉序列中位置信息的能力，因此需要向输入嵌入中添加位置信息。位置编码是一个与嵌入向量维度相同的向量，它为模型提供了每个单元在序列中的位置信息。位置编码通常使用正弦和余弦函数的组合来生成，并与输入嵌入相加。
3. 多头自注意力（Multi-Head Self-Attention） 在加入了位置信息的嵌入向量之后，接下来是多头自注意力层。这一层让模型能够同时关注输入序列中的多个位置。具体来说，它包括以下步骤：
线性投影：首先，输入向量被线性投影成三组向量，分别是查询（Q），键（K），值（V）。点积注意力：对于每个头，使用缩放的点积注意力计算注意力得分，即通过计算查询和键的点积来确定值的权重。组合头的输出：每个头的输出被拼接起来，并通过另一个线性投影层进行处理。 4. 残差连接和层归一化（Residual Connection and Layer Normalization） 每个子层（如自注意力层）的输出通过一个残差连接添加回输入，并进行层归一化。残差连接有助于避免深层网络中的梯度消失问题，而层归一化则有助于稳定训练过程。
5. 前馈网络（Feed-Forward Network） 每个编码器层还包括一个前馈网络，它对每个位置的向量独立地进行处理。这通常是两个线性变换和一个非线性激活函数（如ReLU）。
6. 再次应用残差连接和层归一化 与自注意力层类似，前馈网络的输出也通过残差连接，然后应用层归一化。
Transformer编码器的每一层都重复上述流程。输入数据流经每一层，逐渐添加更多的上下文信息。通过堆叠多个这样的层，编码器能够捕捉输入数据中的复杂模式和关系。这种架构的关键优点是其能够处理长距离依赖关系，并且由于其并行化的特性，适合于大规模数据处理。
3.位置编码 在Transformer模型中，位置编码（Positional Encoding）是一个关键的组成部分。由于Transformer依赖于自注意力机制，它不像传统的递归神经网络（RNN）或卷积神经网络（CNN）那样自然地处理输入序列中的顺序信息。为了让模型能够理解单词在句子中的顺序，引入了位置编码。
1.为什么需要位置编码 Transformer中的自注意力机制在处理输入时是位置不变的（position-invariant），这意味着如果不添加额外的位置信息，模型就无法知道单词在句子中的顺序。位置编码的目的是为每个单词提供其在序列中位置的信息，从而使Transformer能够利用单词的顺序信息。 2.如何计算位置编码 位置编码是通过数学公式计算得到的，并与每个单词的嵌入向量相加。对于位置pos（一个整数，表示单词在序列中的位置）和维度i（嵌入向量的维度索引），位置编码PE(pos, i)的计算方法如下：
对于偶数索引i：
P E ( p o s , 2 i ) = sin ⁡ ( p o s 1000 0 2 i / d ) PE(pos, 2i) = \sin\left(\frac{pos}{10000^{2i/d}}\right) PE(pos,2i)=sin(100002i/dpos​)" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/cb217ecf4f353923ab8619cc4f0a1e7b/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2024-01-20T14:11:26+08:00" />
<meta property="article:modified_time" content="2024-01-20T14:11:26+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Transformer技术深度剖析：AI语言处理的新纪元</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <h3><a id="1Transformer_0"></a>1.Transformer全局概括</h3> 
<p>Transformer是一种深度学习模型，最初由Vaswani等人在2017年的论文《Attention Is All You Need》中提出。它在自然语言处理（NLP）领域引起了革命，因为它的设计克服了以前模型的一些限制，特别是在处理长距离依赖和并行计算方面。下面是Transformer模型的全面概述：</p> 
<h4><a id="1_4"></a>1.核心概念</h4> 
<ol><li> <p><strong>注意力机制（Attention Mechanism）</strong>：</p> 
  <ul><li>Transformer的核心是注意力机制，特别是所谓的“自注意力”（Self-Attention）。</li><li>它允许模型在处理一个单词时同时考虑句子中的其他单词，从而捕获它们之间的上下文关系。</li></ul> </li><li> <p><strong>编码器-解码器架构</strong>：</p> 
  <ul><li>原始的Transformer模型包括编码器（Encoder）和解码器（Decoder）。</li><li>编码器读取输入数据并产生一个上下文表示，解码器则使用这个表示来生成输出数据。</li></ul> </li><li> <p><strong>多头注意力（Multi-Head Attention）</strong>：</p> 
  <ul><li>模型对每个单词的注意力分为多个“头”，这样可以让模型在多个子空间中学习信息。</li><li>这增强了模型对不同位置的敏感性，能够捕获不同类型的上下文信息。</li></ul> </li><li> <p><strong>位置编码（Positional Encoding）</strong>：</p> 
  <ul><li>由于Transformer不使用递归或卷积，因此需要另一种方法来理解单词的顺序或位置。</li><li>位置编码是添加到输入单词的一种编码，提供了单词在序列中的位置信息。</li></ul> </li><li> <p><strong>堆叠层</strong>：</p> 
  <ul><li>Transformer中的编码器和解码器都是由多个相同的层堆叠而成。</li><li>每层包含多头注意力机制和全连接的前馈网络。</li></ul> </li></ol> 
<h4><a id="2_26"></a>2.应用</h4> 
<ul><li><strong>机器翻译</strong>：Transformer模型最初是为了改进机器翻译而设计的，但它迅速被应用于各种NLP任务。</li><li><strong>文本生成</strong>：如GPT系列模型，它们是基于Transformer的架构，专注于生成连贯和相关的文本。</li><li><strong>文本理解</strong>：如BERT和其变体，它们利用Transformer编码器来理解文本，广泛用于问答系统、情感分析等。</li></ul> 
<h4><a id="3_32"></a>3.优势与挑战</h4> 
<ul><li> <p><strong>优势</strong>：</p> 
  <ul><li>能够捕获长距离依赖。</li><li>高效的并行处理能力。</li><li>在多种NLP任务上取得了先进的性能。</li></ul> </li><li> <p><strong>挑战</strong>：</p> 
  <ul><li>模型参数通常非常庞大，需要大量的计算资源进行训练。</li><li>对于输入序列的长度有限制，主要是因为计算复杂度和内存要求。</li></ul> </li></ul> 
<p>Transformer模型自推出以来，已成为NLP领域的一项关键技术，推动了包括文本分类、摘要、机器翻译等多个领域的发展。此外，它的核心思想和技术也被应用于计算机视觉和其他机器学习任务中。</p> 
<h3><a id="2Encoder_45"></a>2.编码器（Encoder）</h3> 
<p>Transformer编码器的底层实现涉及多个组件和步骤，这些组件共同构成了Transformer编码器的核心功能。</p> 
<p>以下是其实现流程的详细介绍：</p> 
<h4><a id="1_Input_Embedding_51"></a>1. 输入嵌入（Input Embedding）</h4> 
<p>首先，输入序列（如一句话中的单词或字符）被转换成固定大小的向量。这一步通常使用嵌入层完成，每个唯一的输入单元（如单词）都被映射到高维空间中的一个稠密向量。</p> 
<h4><a id="2_Positional_Encoding_55"></a>2. 位置编码（Positional Encoding）</h4> 
<p>由于Transformer本身不具备捕捉序列中位置信息的能力，因此需要向输入嵌入中添加位置信息。位置编码是一个与嵌入向量维度相同的向量，它为模型提供了每个单元在序列中的位置信息。位置编码通常使用正弦和余弦函数的组合来生成，并与输入嵌入相加。</p> 
<h4><a id="3_MultiHead_SelfAttention_59"></a>3. 多头自注意力（Multi-Head Self-Attention）</h4> 
<p>在加入了位置信息的嵌入向量之后，接下来是多头自注意力层。这一层让模型能够同时关注输入序列中的多个位置。具体来说，它包括以下步骤：</p> 
<ul><li><strong>线性投影</strong>：首先，输入向量被线性投影成三组向量，分别是查询（Q），键（K），值（V）。</li><li><strong>点积注意力</strong>：对于每个头，使用缩放的点积注意力计算注意力得分，即通过计算查询和键的点积来确定值的权重。</li><li><strong>组合头的输出</strong>：每个头的输出被拼接起来，并通过另一个线性投影层进行处理。</li></ul> 
<h4><a id="4_Residual_Connection_and_Layer_Normalization_67"></a>4. 残差连接和层归一化（Residual Connection and Layer Normalization）</h4> 
<p>每个子层（如自注意力层）的输出通过一个残差连接添加回输入，并进行层归一化。残差连接有助于避免深层网络中的梯度消失问题，而层归一化则有助于稳定训练过程。</p> 
<h4><a id="5_FeedForward_Network_71"></a>5. 前馈网络（Feed-Forward Network）</h4> 
<p>每个编码器层还包括一个前馈网络，它对每个位置的向量独立地进行处理。这通常是两个线性变换和一个非线性激活函数（如ReLU）。</p> 
<h4><a id="6__75"></a>6. 再次应用残差连接和层归一化</h4> 
<p>与自注意力层类似，前馈网络的输出也通过残差连接，然后应用层归一化。</p> 
<p>Transformer编码器的每一层都重复上述流程。输入数据流经每一层，逐渐添加更多的上下文信息。通过堆叠多个这样的层，编码器能够捕捉输入数据中的复杂模式和关系。这种架构的关键优点是其能够处理长距离依赖关系，并且由于其并行化的特性，适合于大规模数据处理。</p> 
<h3><a id="3_81"></a>3.位置编码</h3> 
<p>在Transformer模型中，位置编码（Positional Encoding）是一个关键的组成部分。由于Transformer依赖于自注意力机制，它不像传统的递归神经网络（RNN）或卷积神经网络（CNN）那样自然地处理输入序列中的顺序信息。为了让模型能够理解单词在句子中的顺序，引入了位置编码。</p> 
<h4><a id="1_85"></a>1.为什么需要位置编码</h4> 
<ul><li>Transformer中的自注意力机制在处理输入时是位置不变的（position-invariant），这意味着如果不添加额外的位置信息，模型就无法知道单词在句子中的顺序。</li><li>位置编码的目的是为每个单词提供其在序列中位置的信息，从而使Transformer能够利用单词的顺序信息。</li></ul> 
<h4><a id="2_90"></a>2.如何计算位置编码</h4> 
<p>位置编码是通过数学公式计算得到的，并与每个单词的嵌入向量相加。对于位置<code>pos</code>（一个整数，表示单词在序列中的位置）和维度<code>i</code>（嵌入向量的维度索引），位置编码<code>PE(pos, i)</code>的计算方法如下：</p> 
<ul><li> <p>对于偶数索引<code>i</code>：</p> <p><span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
       
        
         
         
           P 
          
         
           E 
          
         
           ( 
          
         
           p 
          
         
           o 
          
         
           s 
          
         
           , 
          
         
           2 
          
         
           i 
          
         
           ) 
          
         
           = 
          
         
           sin 
          
         
           ⁡ 
          
          
          
            ( 
           
           
            
            
              p 
             
            
              o 
             
            
              s 
             
            
            
            
              1000 
             
             
             
               0 
              
              
              
                2 
               
              
                i 
               
              
                / 
               
              
                d 
               
              
             
            
           
          
            ) 
           
          
         
        
          PE(pos, 2i) = \sin\left(\frac{pos}{10000^{2i/d}}\right) 
         
        
      </span><span class="katex-html"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathnormal" style="margin-right: 0.0576em;">PE</span><span class="mopen">(</span><span class="mord mathnormal">p</span><span class="mord mathnormal">os</span><span class="mpunct">,</span><span class="mspace" style="margin-right: 0.1667em;"></span><span class="mord">2</span><span class="mord mathnormal">i</span><span class="mclose">)</span><span class="mspace" style="margin-right: 0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right: 0.2778em;"></span></span><span class="base"><span class="strut" style="height: 1.2354em; vertical-align: -0.3854em;"></span><span class="mop">sin</span><span class="mspace" style="margin-right: 0.1667em;"></span><span class="minner"><span class="mopen delimcenter" style="top: 0em;"><span class="delimsizing size1">(</span></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.7475em;"><span class="" style="top: -2.6146em;"><span class="pstrut" style="height: 3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1000</span><span class="mord mtight"><span class="mord mtight">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height: 0.822em;"><span class="" style="top: -2.822em; margin-right: 0.0714em;"><span class="pstrut" style="height: 2.5357em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mtight">2</span><span class="mord mathnormal mtight">i</span><span class="mord mtight">/</span><span class="mord mathnormal mtight">d</span></span></span></span></span></span></span></span></span></span></span></span><span class="" style="top: -3.23em;"><span class="pstrut" style="height: 3em;"></span><span class="frac-line" style="border-bottom-width: 0.04em;"></span></span><span class="" style="top: -3.4461em;"><span class="pstrut" style="height: 3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">p</span><span class="mord mathnormal mtight">os</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.3854em;"><span class=""></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mclose delimcenter" style="top: 0em;"><span class="delimsizing size1">)</span></span></span></span></span></span></span></p> </li><li> <p>对于奇数索引<code>i</code>：</p> <p><span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
       
        
         
         
           P 
          
         
           E 
          
         
           ( 
          
         
           p 
          
         
           o 
          
         
           s 
          
         
           , 
          
         
           2 
          
         
           i 
          
         
           + 
          
         
           1 
          
         
           ) 
          
         
           = 
          
         
           cos 
          
         
           ⁡ 
          
          
          
            ( 
           
           
            
            
              p 
             
            
              o 
             
            
              s 
             
            
            
            
              1000 
             
             
             
               0 
              
              
              
                2 
               
              
                i 
               
              
                / 
               
              
                d 
               
              
             
            
           
          
            ) 
           
          
         
        
          PE(pos, 2i+1) = \cos\left(\frac{pos}{10000^{2i/d}}\right) 
         
        
      </span><span class="katex-html"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathnormal" style="margin-right: 0.0576em;">PE</span><span class="mopen">(</span><span class="mord mathnormal">p</span><span class="mord mathnormal">os</span><span class="mpunct">,</span><span class="mspace" style="margin-right: 0.1667em;"></span><span class="mord">2</span><span class="mord mathnormal">i</span><span class="mspace" style="margin-right: 0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right: 0.2222em;"></span></span><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord">1</span><span class="mclose">)</span><span class="mspace" style="margin-right: 0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right: 0.2778em;"></span></span><span class="base"><span class="strut" style="height: 1.2354em; vertical-align: -0.3854em;"></span><span class="mop">cos</span><span class="mspace" style="margin-right: 0.1667em;"></span><span class="minner"><span class="mopen delimcenter" style="top: 0em;"><span class="delimsizing size1">(</span></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.7475em;"><span class="" style="top: -2.6146em;"><span class="pstrut" style="height: 3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1000</span><span class="mord mtight"><span class="mord mtight">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height: 0.822em;"><span class="" style="top: -2.822em; margin-right: 0.0714em;"><span class="pstrut" style="height: 2.5357em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mtight">2</span><span class="mord mathnormal mtight">i</span><span class="mord mtight">/</span><span class="mord mathnormal mtight">d</span></span></span></span></span></span></span></span></span></span></span></span><span class="" style="top: -3.23em;"><span class="pstrut" style="height: 3em;"></span><span class="frac-line" style="border-bottom-width: 0.04em;"></span></span><span class="" style="top: -3.4461em;"><span class="pstrut" style="height: 3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">p</span><span class="mord mathnormal mtight">os</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.3854em;"><span class=""></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mclose delimcenter" style="top: 0em;"><span class="delimsizing size1">)</span></span></span></span></span></span></span></p> </li></ul> 
<p>其中，<code>d</code>是嵌入向量的维度。</p> 
<h4><a id="3_104"></a>3.特点和作用</h4> 
<ul><li>这种计算方法生成了一个唯一的位置编码向量，对于每个不同的位置<code>pos</code>，其向量都是不同的。</li><li>此编码方式允许模型推断出相对位置信息，因为类似位置的编码向量在高维空间中彼此接近。</li><li>通过将位置编码加到词嵌入向量上，模型就能够利用这些信息来更好地理解语言的结构。</li></ul> 
<h4><a id="4_110"></a>4.应用</h4> 
<ul><li>在Transformer模型的编码器和解码器的每一层中，都将位置编码添加到输入的词嵌入向量中。</li><li>这种方法使得Transformer可以处理序列化数据，同时保持高效的并行处理能力。</li></ul> 
<p>总的来说，位置编码在Transformer模型中解决了捕获序列顺序信息的问题，使得模型能够在处理NLP任务时更有效地理解文本的语义和结构。</p> 
<h3><a id="4_117"></a>4.注意力机制</h3> 
<p>注意力机制（Attention Mechanism）在深度学习，特别是在自然语言处理（NLP）领域中，已成为一种非常重要的技术。它启发于人类的注意力机制，即我们倾向于集中注意力于感官输入的某些部分，同时忽略其他部分。在深度学习中，注意力机制允许模型在处理输入数据时动态地集中于那些最重要的部分。</p> 
<h4><a id="1_121"></a>1.注意力机制的基本原理</h4> 
<p>注意力机制通常涉及以下几个关键步骤：</p> 
<ol><li> <p><strong>打分（Scoring）</strong>：模型首先需要确定输入数据的哪些部分是最重要的。这通过一个打分函数来实现，该函数衡量了不同输入部分对于当前任务的相关性。</p> </li><li> <p><strong>加权求和（Weighted Sum）</strong>：一旦每部分的重要性被打分，模型就会根据这些分数对输入数据进行加权求和。这允许模型在处理数据时集中注意力于更重要的部分。</p> </li><li> <p><strong>输出</strong>：加权求和的结果是一个聚合了输入数据关键信息的向量，该向量随后被用于后续的处理，如分类、生成文本等。</p> </li></ol> 
<h4><a id="2_131"></a>2.注意力机制的类型</h4> 
<ol><li> <p><strong>软注意力（Soft Attention）</strong>：这种类型的注意力机制是可微分的，它为输入的每个部分赋予一个实数权重（一般通过softmax函数实现）。这是最常见的注意力机制，被广泛用于各种深度学习模型中。</p> </li><li> <p><strong>硬注意力（Hard Attention）</strong>：硬注意力选择输入的一个子集进行集中处理。由于这种选择过程是不可微分的，硬注意力通常需要通过强化学习等方法进行训练。</p> </li><li> <p><strong>自注意力（Self-Attention）</strong>：这种注意力机制允许输入内的每个元素都关注于输入内的其他所有元素。它是Transformer模型中的核心部分，使得模型能够捕捉长距离依赖关系。</p> </li></ol> 
<h4><a id="3_139"></a>3.注意力机制的应用</h4> 
<p>注意力机制在自然语言处理领域中尤其流行，应用于诸如机器翻译、文本摘要、问答系统等任务。此外，它也被用于图像识别、语音识别等其他领域。</p> 
<h4><a id="4_143"></a>4.注意力机制的优势</h4> 
<ul><li><strong>提升性能</strong>：在许多任务中，注意力机制能够显著提升模型的性能。</li><li><strong>可解释性</strong>：通过查看模型的注意力权重，我们可以获得一些关于模型是如何做出决策的洞察，这增加了模型的可解释性。</li></ul> 
<p>总的来说，注意力机制通过允许模型集中处理输入数据中的重要部分，提供了一种有效的方式来捕捉数据的复杂关系。随着深度学习的不断发展，注意力机制已成为一种不可或缺的工具，推动了许多领域的研究和应用。</p> 
<h3><a id="5_150"></a>5.多头注意力机制</h3> 
<p>多头注意力机制（Multi-Head Attention）是Transformer模型的一个关键组成部分，它使模型能够同时从不同的表示子空间中获取信息。这种机制在模型处理序列数据时提高了其灵活性和能力，特别是在理解复杂的上下文关系方面。以下是多头注意力机制的详细介绍：</p> 
<h4><a id="1_154"></a>1.基本概念</h4> 
<ol><li> <p><strong>注意力机制</strong>：注意力机制是一种让模型能够集中注意力于输入序列中的重要部分的方式，类似于人类在处理信息时会集中注意力于某些关键部分。</p> </li><li> <p><strong>自注意力（Self-Attention）</strong>：在自注意力中，模型计算一个序列中的每个元素对序列中其他所有元素的注意力。这允许模型捕获序列内的任意两个元素之间的关系。</p> </li></ol> 
<h4><a id="2_160"></a>2.多头注意力的工作原理</h4> 
<ol><li> <p><strong>分割为多个头</strong>：在多头注意力机制中，模型首先将输入的嵌入向量分割成多个头。每个头学习输入数据的不同部分。</p> </li><li> <p><strong>并行的自注意力层</strong>：每个头独立地进行自注意力运算。这意味着模型可以并行地处理多个表示子空间中的信息。</p> </li><li> <p><strong>线性变换</strong>：在每个头上，输入经过线性变换，然后计算自注意力。这包括三个重要的步骤：查询（Query）、键（Key）和值（Value）的计算。</p> </li><li> <p><strong>计算注意力得分</strong>：每个头根据查询（Query）和键（Key）的点积来计算注意力得分，然后这些得分通过softmax函数进行归一化。</p> </li><li> <p><strong>加权和</strong>：每个头使用归一化的注意力得分对值（Value）进行加权求和。</p> </li><li> <p><strong>拼接和最后的线性变换</strong>：所有头的输出被拼接在一起，然后通过一个线性层来整合不同头的学习成果。</p> </li></ol> 
<h4><a id="3_174"></a>3.公式表示</h4> 
<p>对于多头注意力，其计算可以表示为：</p> 
<p><span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         MultiHead 
        
       
         ( 
        
       
         Q 
        
       
         , 
        
       
         K 
        
       
         , 
        
       
         V 
        
       
         ) 
        
       
         = 
        
       
         Concat 
        
       
         ( 
        
        
        
          head 
         
        
          1 
         
        
       
         , 
        
       
         … 
        
       
         , 
        
        
        
          head 
         
        
          h 
         
        
       
         ) 
        
        
        
          W 
         
        
          O 
         
        
       
      
        \text{MultiHead}(Q, K, V) = \text{Concat}(\text{head}_1, \dots, \text{head}_h)W^O 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord text"><span class="mord">MultiHead</span></span><span class="mopen">(</span><span class="mord mathnormal">Q</span><span class="mpunct">,</span><span class="mspace" style="margin-right: 0.1667em;"></span><span class="mord mathnormal" style="margin-right: 0.0715em;">K</span><span class="mpunct">,</span><span class="mspace" style="margin-right: 0.1667em;"></span><span class="mord mathnormal" style="margin-right: 0.2222em;">V</span><span class="mclose">)</span><span class="mspace" style="margin-right: 0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right: 0.2778em;"></span></span><span class="base"><span class="strut" style="height: 1.0913em; vertical-align: -0.25em;"></span><span class="mord text"><span class="mord">Concat</span></span><span class="mopen">(</span><span class="mord"><span class="mord text"><span class="mord">head</span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.3011em;"><span class="" style="top: -2.55em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.15em;"><span class=""></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right: 0.1667em;"></span><span class="minner">…</span><span class="mspace" style="margin-right: 0.1667em;"></span><span class="mpunct">,</span><span class="mspace" style="margin-right: 0.1667em;"></span><span class="mord"><span class="mord text"><span class="mord">head</span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.3361em;"><span class="" style="top: -2.55em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">h</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.15em;"><span class=""></span></span></span></span></span></span><span class="mclose">)</span><span class="mord"><span class="mord mathnormal" style="margin-right: 0.1389em;">W</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height: 0.8413em;"><span class="" style="top: -3.063em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right: 0.0278em;">O</span></span></span></span></span></span></span></span></span></span></span></span></p> 
<p>其中每个头<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
        
        
          head 
         
        
          i 
         
        
       
      
        \text{head}_i 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.8444em; vertical-align: -0.15em;"></span><span class="mord"><span class="mord text"><span class="mord">head</span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.3117em;"><span class="" style="top: -2.55em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.15em;"><span class=""></span></span></span></span></span></span></span></span></span></span>是：</p> 
<p><span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
        
        
          head 
         
        
          i 
         
        
       
         = 
        
       
         Attention 
        
       
         ( 
        
       
         Q 
        
        
        
          W 
         
        
          i 
         
        
          Q 
         
        
       
         , 
        
       
         K 
        
        
        
          W 
         
        
          i 
         
        
          K 
         
        
       
         , 
        
       
         V 
        
        
        
          W 
         
        
          i 
         
        
          V 
         
        
       
         ) 
        
       
      
        \text{head}_i = \text{Attention}(QW^Q_i, KW^K_i, VW^V_i) 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.8444em; vertical-align: -0.15em;"></span><span class="mord"><span class="mord text"><span class="mord">head</span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.3117em;"><span class="" style="top: -2.55em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.15em;"><span class=""></span></span></span></span></span></span><span class="mspace" style="margin-right: 0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right: 0.2778em;"></span></span><span class="base"><span class="strut" style="height: 1.2361em; vertical-align: -0.2769em;"></span><span class="mord text"><span class="mord">Attention</span></span><span class="mopen">(</span><span class="mord mathnormal">Q</span><span class="mord"><span class="mord mathnormal" style="margin-right: 0.1389em;">W</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.9592em;"><span class="" style="top: -2.4231em; margin-left: -0.1389em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span><span class="" style="top: -3.1809em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">Q</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.2769em;"><span class=""></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right: 0.1667em;"></span><span class="mord mathnormal" style="margin-right: 0.0715em;">K</span><span class="mord"><span class="mord mathnormal" style="margin-right: 0.1389em;">W</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.8413em;"><span class="" style="top: -2.4413em; margin-left: -0.1389em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span><span class="" style="top: -3.063em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right: 0.0715em;">K</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.2587em;"><span class=""></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right: 0.1667em;"></span><span class="mord mathnormal" style="margin-right: 0.2222em;">V</span><span class="mord"><span class="mord mathnormal" style="margin-right: 0.1389em;">W</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.8413em;"><span class="" style="top: -2.4413em; margin-left: -0.1389em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span><span class="" style="top: -3.063em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right: 0.2222em;">V</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.2587em;"><span class=""></span></span></span></span></span></span><span class="mclose">)</span></span></span></span></span></p> 
<p>而Attention的计算方式如下所示：</p> 
<p><span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         Attention 
        
       
         ( 
        
       
         Q 
        
       
         , 
        
       
         K 
        
       
         , 
        
       
         V 
        
       
         ) 
        
       
         = 
        
       
         softmax 
        
        
        
          ( 
         
         
          
          
            Q 
           
           
           
             K 
            
           
             T 
            
           
          
          
           
           
             d 
            
           
             k 
            
           
          
         
        
          ) 
         
        
       
         V 
        
       
      
        \text{Attention}(Q, K, V) = \text{softmax}\left(\frac{QK^T}{\sqrt{d_k}}\right)V 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord text"><span class="mord">Attention</span></span><span class="mopen">(</span><span class="mord mathnormal">Q</span><span class="mpunct">,</span><span class="mspace" style="margin-right: 0.1667em;"></span><span class="mord mathnormal" style="margin-right: 0.0715em;">K</span><span class="mpunct">,</span><span class="mspace" style="margin-right: 0.1667em;"></span><span class="mord mathnormal" style="margin-right: 0.2222em;">V</span><span class="mclose">)</span><span class="mspace" style="margin-right: 0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right: 0.2778em;"></span></span><span class="base"><span class="strut" style="height: 1.8em; vertical-align: -0.65em;"></span><span class="mord text"><span class="mord">softmax</span></span><span class="mspace" style="margin-right: 0.1667em;"></span><span class="minner"><span class="mopen delimcenter" style="top: 0em;"><span class="delimsizing size2">(</span></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 1.0895em;"><span class="" style="top: -2.5864em;"><span class="pstrut" style="height: 3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord sqrt mtight"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.8622em;"><span class="svg-align" style="top: -3em;"><span class="pstrut" style="height: 3em;"></span><span class="mord mtight" style="padding-left: 0.833em;"><span class="mord mtight"><span class="mord mathnormal mtight">d</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.3448em;"><span class="" style="top: -2.3488em; margin-left: 0em; margin-right: 0.0714em;"><span class="pstrut" style="height: 2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mathnormal mtight" style="margin-right: 0.0315em;">k</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.1512em;"><span class=""></span></span></span></span></span></span></span></span><span class="" style="top: -2.8222em;"><span class="pstrut" style="height: 3em;"></span><span class="hide-tail mtight" style="min-width: 0.853em; height: 1.08em;"> 
                    <svg width="400em" height="1.08em" viewbox="0 0 400000 1080" preserveaspectratio="xMinYMin slice"> 
                     <path d="M95,702
c-2.7,0,-7.17,-2.7,-13.5,-8c-5.8,-5.3,-9.5,-10,-9.5,-14
c0,-2,0.3,-3.3,1,-4c1.3,-2.7,23.83,-20.7,67.5,-54
c44.2,-33.3,65.8,-50.3,66.5,-51c1.3,-1.3,3,-2,5,-2c4.7,0,8.7,3.3,12,10
s173,378,173,378c0.7,0,35.3,-71,104,-213c68.7,-142,137.5,-285,206.5,-429
c69,-144,104.5,-217.7,106.5,-221
l0 -0
c5.3,-9.3,12,-14,20,-14
H400000v40H845.2724
s-225.272,467,-225.272,467s-235,486,-235,486c-2.7,4.7,-9,7,-19,7
c-6,0,-10,-1,-12,-3s-194,-422,-194,-422s-65,47,-65,47z
M834 80h400000v40h-400000z"></path> 
                    </svg></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.1778em;"><span class=""></span></span></span></span></span></span></span></span><span class="" style="top: -3.23em;"><span class="pstrut" style="height: 3em;"></span><span class="frac-line" style="border-bottom-width: 0.04em;"></span></span><span class="" style="top: -3.4461em;"><span class="pstrut" style="height: 3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">Q</span><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right: 0.0715em;">K</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height: 0.9191em;"><span class="" style="top: -2.931em; margin-right: 0.0714em;"><span class="pstrut" style="height: 2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mathnormal mtight" style="margin-right: 0.1389em;">T</span></span></span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.538em;"><span class=""></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mclose delimcenter" style="top: 0em;"><span class="delimsizing size2">)</span></span></span><span class="mspace" style="margin-right: 0.1667em;"></span><span class="mord mathnormal" style="margin-right: 0.2222em;">V</span></span></span></span></span></p> 
<h4><a id="4_188"></a>4.优势</h4> 
<ul><li><strong>提升模型的表达能力</strong>：通过并行地学习不同的表示子空间，多头注意力机制使模型能够捕捉到更加丰富和复杂的信息。</li><li><strong>增加灵活性</strong>：模型能够同时关注序列中不同位置的信息，这对于理解长距离依赖关系尤为重要。</li></ul> 
<h4><a id="5_193"></a>5.应用</h4> 
<ul><li><strong>自然语言处理</strong>：多头注意力在各种NLP任务中非常有效，如机器翻译、文本摘要、问答系统等。</li><li><strong>其他领域</strong>：此外，多头注意力的概念也被扩展到其他领域，如计算机视觉。</li></ul> 
<p>总的来说，多头注意力机制是Transformer模型强大能力的关键来源之一，它通过同时处理序列的不同方面，使模型能够更好地理解和处理复杂的数据。</p> 
<h3><a id="6_200"></a>6.残差</h3> 
<p>Transformer模型中的残差连接（Residual Connections）是一种重要的网络架构特征，用于帮助处理深层网络中的梯度消失和爆炸问题。这种机制在Transformer的每个子层中都得到了应用，特别是在其编码器（Encoder）和解码器（Decoder）的每一层中。</p> 
<h4><a id="1_204"></a>1.基本原理</h4> 
<ol><li> <p><strong>直接跳跃连接</strong>：在Transformer模型的每个子层中，输入不仅传递到子层进行处理，而且通过一个直接的连接跳跃到子层的输出。这意味着子层的输出是它的输入和处理后的结果的总和。</p> </li><li> <p><strong>数学表达</strong>：如果一个子层的操作表示为 ( F(x) )，其中 ( x ) 是输入，那么残差连接的输出是 ( F(x) + x )。</p> </li></ol> 
<h4><a id="2Transformer_210"></a>2.在Transformer中的应用</h4> 
<ol><li> <p><strong>编码器和解码器中的应用</strong>：在Transformer模型的每个编码器和解码器层中，都有两个子层：一个是多头注意力机制，另一个是前馈神经网络。每个子层都有一个残差连接，然后是层归一化（Layer Normalization）。</p> </li><li> <p><strong>促进梯度流动</strong>：这些残差连接允许梯度直接流过，这对于深层网络至关重要，因为它们帮助缓解了梯度消失的问题。</p> </li></ol> 
<h4><a id="3_216"></a>3.实现示例</h4> 
<p>在Transformer模型的伪代码中，一个编码器层可以表示为：</p> 
<pre><code class="prism language-python"><span class="token keyword">def</span> <span class="token function">encoder_layer</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token comment"># 多头注意力子层，包括残差连接和层归一化</span>
    x <span class="token operator">=</span> LayerNorm<span class="token punctuation">(</span>x <span class="token operator">+</span> MultiHeadAttention<span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">)</span>
    <span class="token comment"># 前馈网络子层，包括残差连接和层归一化</span>
    x <span class="token operator">=</span> LayerNorm<span class="token punctuation">(</span>x <span class="token operator">+</span> FeedForward<span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">)</span>
    <span class="token keyword">return</span> x
</code></pre> 
<h4><a id="4_229"></a>4.重要性</h4> 
<ul><li> <p><strong>深层网络训练</strong>：残差连接使得训练深层的Transformer模型成为可能，因为它们提供了一种有效的方式来缓解深层网络中常见的梯度问题。</p> </li><li> <p><strong>增强的信息流</strong>：通过在模型中添加这些“快捷路径”，信息可以更直接地流动，从而提高了整个网络的学习能力。</p> </li></ul> 
<p>总之，残差连接在Transformer模型中发挥着至关重要的作用，它们不仅帮助模型捕捉深层次的信息，而且还确保了模型的稳定训练和高效的信息处理。这一机制的引入是Transformer架构取得成功的关键因素之一。</p> 
<h3><a id="7BNLN_237"></a>7.BN与LN</h3> 
<p>批归一化（Batch Normalization，简称BN）和层归一化（Layer Normalization，简称LN）都是深度学习中常用的归一化技术，用于加速模型训练过程中的收敛速度，并有助于缓解梯度消失问题。它们虽然目的相同，但是在实现方式上有所不同。</p> 
<h4><a id="1BN_241"></a>1.批归一化（BN）</h4> 
<p><strong>概念</strong>：</p> 
<ul><li>批归一化是一种用于深度神经网络的技术，旨在改善训练的稳定性和加速收敛速度。它最初被提出用于解决深度学习模型中的内部协变量偏移问题。</li></ul> 
<p><strong>工作原理</strong>：</p> 
<ol><li><strong>计算批统计量</strong>：在一个批次的数据通过网络的某一层时，BN计算这个批次数据的均值和方差。</li><li><strong>归一化</strong>：然后，使用这些统计量将层的输入标准化，使其具有零均值和单位方差。</li><li><strong>可学习的参数</strong>：BN引入了两个可训练的参数，称为缩放（scale）和偏移（shift）参数。这些参数让网络有能力恢复数据的原始特征，如果它们对于后续层是有用的。</li></ol> 
<p><strong>优点</strong>：</p> 
<ul><li>可以减少对其他正则化技术（如Dropout）的依赖。</li><li>加速了网络训练的收敛速度，并有助于缓解梯度消失问题。</li></ul> 
<p><strong>局限性</strong>：</p> 
<ul><li>对批次大小比较敏感。较小的批次会导致估计的均值和方差不准确，影响模型性能。</li><li>在递归神经网络（RNN）中应用起来更加复杂。</li></ul> 
<h4><a id="2LN_260"></a>2.层归一化（LN）</h4> 
<p><strong>概念</strong>：</p> 
<ul><li>层归一化是另一种归一化技术，特别适用于循环神经网络（RNN）和变长输入数据。与BN不同，LN对每个样本独立进行归一化。</li></ul> 
<p><strong>工作原理</strong>：</p> 
<ol><li><strong>归一化</strong>：LN在单个样本的所有特征上进行归一化操作。它计算单个样本的所有输入特征的均值和方差。</li><li><strong>标准化</strong>：使用计算出的均值和方差对每个样本进行标准化。</li><li><strong>可学习的参数</strong>：与BN类似，LN也引入了缩放和偏移参数，以便网络可以学习恢复数据的有用特性。</li></ol> 
<p><strong>优点</strong>：</p> 
<ul><li>由于对每个样本独立归一化，LN不受批次大小的影响，适用于批次大小变化较大的情况。</li><li>在处理时间序列数据和循环神经网络时特别有效。</li></ul> 
<p><strong>局限性</strong>：</p> 
<ul><li>在某些卷积神经网络（CNN）应用中，LN可能不如BN有效。</li></ul> 
<h4><a id="3_277"></a>3.使用场景</h4> 
<ul><li><strong>BN</strong>：在卷积神经网络（CNN）和大批量数据处理中非常有效，尤其适用于图像处理任务。</li><li><strong>LN</strong>：在循环神经网络（RNN）和处理序列数据（如NLP任务）时非常有效，特别是在批次大小不一或较小时。</li></ul> 
<p>BN和LN都是为了解决深度神经网络中的特定问题而设计的，它们通过对网络层的输入进行归一化，帮助模型更快地收敛并提高了训练过程的稳定性。选择使用哪种归一化技术取决于具体的应用场景和网络架构。</p> 
<h3><a id="8Decoder_284"></a>8.解码器（Decoder）</h3> 
<p>Transformer模型的解码器（Decoder）部分负责将编码器的输出转换为最终的输出序列。它通常用于序列生成任务，如机器翻译中的目标语言生成。解码器的结构与编码器类似，但有一些关键的区别，特别是在处理自注意力和编码器-解码器注意力时。以下是解码器的详细介绍：</p> 
<h4><a id="1__288"></a>1. 输入嵌入和位置编码</h4> 
<p>与编码器相似，解码器首先将其输入序列（目标序列）转换为嵌入表示，并加上位置编码。</p> 
<ul><li><strong>输入嵌入</strong>：通常是目标序列的词嵌入（在机器翻译任务中是目标语言）。</li><li><strong>位置编码</strong>：与编码器中相同，提供序列中词汇的位置信息。</li></ul> 
<h4><a id="2__295"></a>2. 解码器层的堆叠</h4> 
<p>解码器由多个相同的层堆叠而成，每层包含以下三个子层：</p> 
<ul><li> <p><strong>屏蔽的自注意力机制（Masked Self-Attention）</strong>：</p> 
  <ul><li>与编码器中的自注意力类似，但有一个重要区别：为了避免在生成当前词汇时“看到”未来的词汇，应用了一个掩码（mask）。</li><li>这个掩码确保对于每个位置，模型只能关注到该位置之前（包括当前位置）的词汇。</li></ul> </li><li> <p><strong>编码器-解码器注意力（Encoder-Decoder Attention）</strong>：</p> 
  <ul><li>这一层使解码器能够关注（即“看到”）编码器的输出。</li><li>查询（Q）来自前一层的解码器输出，而键（K）和值（V）来自编码器的输出。</li></ul> </li><li> <p><strong>前馈网络（Feed-Forward Network）</strong>：</p> 
  <ul><li>与编码器中的前馈网络相同，对每个位置应用相同的全连接层。</li></ul> </li></ul> 
<h4><a id="3__310"></a>3. 残差连接和层归一化</h4> 
<p>每个子层的输出都通过残差连接（即直接加上子层的输入），然后进行层归一化。</p> 
<h4><a id="4__314"></a>4. 输出</h4> 
<p>解码器的最后一层的输出用于预测下一个词汇。这通常通过一个线性层（线性变换），然后是一个softmax层来实现，softmax层输出每个词汇的概率分布。</p> 
<p>总的来说，Transformer解码器的设计使其能够有效地生成序列，同时考虑到源序列（通过编码器-解码器注意力）和已生成的目标序列的上下文（通过屏蔽的自注意力）。这种结构使得解码器在诸如机器翻译、文本生成等序列生成任务中表现卓越。解码器层的堆叠增强了模型的能力，使其能够捕捉复杂的依赖关系。</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/972ef2838ae654f0d94ff95289bd2c17/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">力扣：494. 目标和（动态规划）（01背包）</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/7e3e542b5bede7807bae76c6360afca3/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">算法滑动窗口系列-Day8-长度最小的子数组</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>