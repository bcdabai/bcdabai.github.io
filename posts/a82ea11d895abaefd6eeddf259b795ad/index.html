<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>kubernets资源预留 - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="kubernets资源预留" />
<meta property="og:description" content="一、 Kubelet Node Allocatable Kubelet Node Allocatable用来为Kube组件和System进程预留资源，从而保证当节点出现满负荷时也能保证Kube和System进程有足够的资源。目前支持cpu, memory, ephemeral-storage三种资源预留。Node Capacity是Node的所有硬件资源，kube-reserved是给kube组件预留的资源，system-reserved是给System进程预留的资源， eviction-threshold是kubelet eviction的阈值设定，allocatable才是真正scheduler调度Pod时的参考值（保证Node上所有Pods的request resource不超过Allocatable）。 Node Capacity
--------------------------------
| kube-reserved |
|-------------------------------|
| system-reserved |
|-------------------------------|
| eviction-threshold |
|-------------------------------|
| allocatable |
| (available for pods) |
--------------------------------
可分配资源
Node Allocatable Resource = Node Capacity - Kube-reserved - system-reserved - eviction-threshold
二、 Kubernetes配置资源预留 以下均为kubelet组件参数
--enforce-node-allocatable，默认为pods，要为kube组件和System进程预留资源，则需要设置为pods,kube-reserved,system-reserve。--cgroups-per-qos，Enabling QoS and Pod level cgroups，默认开启。开启后，kubelet会将管理所有workload Pods的cgroups。--cgroup-driver，默认为cgroupfs，另一可选项为systemd。取决于容器运行时使用的cgroup driver，kubelet与其保持一致。比如你配置docker使用systemd cgroup driver，那么kubelet也需要配置--cgroup-driver=systemd。--kube-reserved,用于配置为kube组件（kubelet,kube-proxy,dockerd等）预留的资源量，比如—kube-reserved=cpu=1000m,memory=8Gi，ephemeral-storage=16Gi。--kube-reserved-cgroup，如果你设置了--kube-reserved，那么请一定要设置对应的cgroup，并且该cgroup目录要事先创建好，否则kubelet将不会自动创建导致kubelet启动失败。比如设置为kube-reserved-cgroup=/kubelet.service 。--system-reserved，用于配置为System进程预留的资源量，比如—system-reserved=cpu=500m,memory=4Gi,ephemeral-storage=4Gi。--system-reserved-cgroup，如果你设置了--system-reserved，那么请一定要设置对应的cgroup，并且该cgroup目录要事先创建好，否则kubelet将不会自动创建导致kubelet启动失败。比如设置为system-reserved-cgroup=/system.slice。--eviction-hard，用来配置kubelet的hard eviction条件，只支持memory和ephemeral-storage两种不可压缩资源。当出现MemoryPressure时，Scheduler不会调度新的Best-Effort QoS Pods到此节点。当出现DiskPressure时，Scheduler不会调度任何新Pods到此节点。关于Kubelet Eviction的更多解读，请参考我的相关博文 Kubelet Node Allocatable的代码很简单，主要在pkg/kubelet/cm/node_container_manager." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/a82ea11d895abaefd6eeddf259b795ad/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2019-04-16T10:06:00+08:00" />
<meta property="article:modified_time" content="2019-04-16T10:06:00+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">kubernets资源预留</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <div id="cnblogs_post_body" class="blogpost-body"> 
 <h3>一、  Kubelet Node Allocatable</h3> 
 <ul><li>Kubelet Node Allocatable用来为Kube组件和System进程预留资源，从而保证当节点出现满负荷时也能保证Kube和System进程有足够的资源。</li><li>目前支持cpu, memory, ephemeral-storage三种资源预留。</li><li>Node Capacity是Node的所有硬件资源，kube-reserved是给kube组件预留的资源，system-reserved是给System进程预留的资源， eviction-threshold是kubelet eviction的阈值设定，allocatable才是真正scheduler调度Pod时的参考值（保证Node上所有Pods的request resource不超过Allocatable）。</li></ul> 
 <p>      Node Capacity</p> 
 <p>--------------------------------</p> 
 <p>|     kube-reserved         |</p> 
 <p>|-------------------------------|</p> 
 <p>|     system-reserved      |</p> 
 <p>|-------------------------------|</p> 
 <p>|    eviction-threshold     |</p> 
 <p>|-------------------------------|</p> 
 <p>|      allocatable              |</p> 
 <p>|   (available for pods)   |</p> 
 <p>--------------------------------</p> 
 <p>可分配资源</p> 
 <p>Node Allocatable Resource = Node Capacity - Kube-reserved - system-reserved - eviction-threshold</p> 
 <h3>二、  Kubernetes配置资源预留</h3> 
 <p>以下均为kubelet组件参数</p> 
 <ul><li>--enforce-node-allocatable，默认为pods，要为kube组件和System进程预留资源，则需要设置为pods,kube-reserved,system-reserve。</li><li>--cgroups-per-qos，Enabling QoS and Pod level cgroups，默认开启。开启后，kubelet会将管理所有workload Pods的cgroups。</li><li>--cgroup-driver，默认为cgroupfs，另一可选项为systemd。取决于容器运行时使用的cgroup driver，kubelet与其保持一致。比如你配置docker使用systemd cgroup driver，那么kubelet也需要配置--cgroup-driver=systemd。</li><li>--kube-reserved,用于配置为kube组件（kubelet,kube-proxy,dockerd等）预留的资源量，比如—kube-reserved=cpu=1000m,memory=8Gi，ephemeral-storage=16Gi。</li><li>--kube-reserved-cgroup，如果你设置了--kube-reserved，那么请一定要设置对应的cgroup，并且该cgroup目录要事先创建好，否则kubelet将不会自动创建导致kubelet启动失败。比如设置为kube-reserved-cgroup=/kubelet.service 。</li><li>--system-reserved，用于配置为System进程预留的资源量，比如—system-reserved=cpu=500m,memory=4Gi,ephemeral-storage=4Gi。</li><li>--system-reserved-cgroup，如果你设置了--system-reserved，那么请一定要设置对应的cgroup，并且该cgroup目录要事先创建好，否则kubelet将不会自动创建导致kubelet启动失败。比如设置为system-reserved-cgroup=/system.slice。</li><li>--eviction-hard，用来配置kubelet的hard eviction条件，只支持memory和ephemeral-storage两种不可压缩资源。当出现MemoryPressure时，Scheduler不会调度新的Best-Effort QoS Pods到此节点。当出现DiskPressure时，Scheduler不会调度任何新Pods到此节点。关于Kubelet Eviction的更多解读，请参考我的相关博文</li></ul> 
 <p>Kubelet Node Allocatable的代码很简单，主要在pkg/kubelet/cm/node_container_manager.go，感兴趣的同学自己去走读一遍。</p> 
 <p>示例：</p> 
 <p>以如下的kubelet资源预留为例，Node Capacity为memory=32Gi, cpu=16, ephemeral-storage=100Gi，我们对kubelet进行如下配置：</p> 
 <div class="cnblogs_code"> 
  <pre>--enforce-node-allocatable=pods,kube-reserved,system-<span style="color:#000000;">reserved
</span>--kube-reserved-cgroup=/<span style="color:#000000;">kubelet.service
</span>--system-reserved-cgroup=/<span style="color:#000000;">system.slice
</span>--kube-reserved=cpu=<span style="color:#800080;">1</span>,memory=2Gi,ephemeral-storage=<span style="color:#000000;">1Gi
</span>--system-reserved=cpu=500m,memory=1Gi,ephemeral-storage=<span style="color:#000000;">1Gi
</span>--eviction-hard=memory.available&lt;500Mi,nodefs.available&lt;<span style="color:#800080;">10</span>%</pre> 
 </div> 
 <p>NodeAllocatable = NodeCapacity - Kube-reserved - system-reserved - eviction-threshold = cpu=14.5,memory=28.5Gi,ephemeral-storage=98Gi.</p> 
 <p>Scheduler会确保Node上所有的Pod Resource Request不超过NodeAllocatable。Pods所使用的memory和storage之和超过NodeAllocatable后就会触发kubelet Evict Pods。</p> 
 <h4>1.    Kube Reserved</h4> 
 <div class="cnblogs_code"> 
  <pre>Kubelet Flag: --kube-reserved=[cpu=100m][,][memory=100Mi][,][ephemeral-storage=1Gi][,][pid=1000]<span style="color:#000000;">
Kubelet Flag: </span>--kube-reserved-cgroup=</pre> 
 </div> 
 <p>kube-reserved 是为了给诸如 kubelet、container runtime、node problem detector 等 kubernetes 系统守护进程争取资源预留。这并不代表要给以 pod 形式运行的系统守护进程保留资源。kube-reserved 通常是节点上的一个 pod 密度（pod density） 功能。 这个性能仪表盘 从 pod 密度的多个层面展示了 kubelet 和 docker engine 的 cpu 和 memory使用情况。</p> 
 <p>要选择性的在系统守护进程上执行 kube-reserved，需要把 kubelet 的 --kube-reserved-cgroup 标志的值设置为 kube 守护进程的父控制组。</p> 
 <p> 推荐将 kubernetes 系统守护进程放置于顶级控制组之下（例如 systemd 机器上的 runtime.slice）。理想情况下每个系统守护进程都应该在其自己的子控制组中运行。请参考这篇文档，获取更过关于推荐控制组层次结构的细节。</p> 
 <p> 请注意，如果 --kube-reserved-cgroup 不存在，Kubelet 将不会创建它。如果指定了一个无效的 cgroup，Kubelet 将会失败。</p> 
 <h4>2.    系统预留值（System Reserved）</h4> 
 <div class="cnblogs_code"> 
  <pre>Kubelet Flag: --system-reserved=[cpu=100m][,][memory=100Mi][,][ephemeral-storage=1Gi][,][pid=1000]<span style="color:#000000;">
Kubelet Flag: </span>--system-reserved-cgroup=</pre> 
 </div> 
 <p>system-reserved 用于为诸如 sshd、udev 等系统守护进程争取资源预留。system-reserved 也应该为 kernel 预留 内存，因为目前 kernel 使用的内存并不记在 Kubernetes 的 pod 上。同时还推荐为用户登录会话预留资源（systemd 体系中的 user.slice）。</p> 
 <p>要想在系统守护进程上可选地执行 system-reserved，请指定 --system-reserved-cgroup kubelet 标志的值为 OS 系统守护进程的父级控制组。</p> 
 <p>推荐将 OS 系统守护进程放在一个顶级控制组之下（例如 systemd 机器上的system.slice）。</p> 
 <p>请注意，如果 --system-reserved-cgroup 不存在，Kubelet 不会创建它。如果指定了无效的 cgroup，Kubelet 将会失败。</p> 
 <h4>3.    驱逐阈值（Eviction Thresholds）</h4> 
 <div class="cnblogs_code"> 
  <pre>Kubelet Flag: --eviction-hard=[memory.available&lt;10%][,][ephemeral-storage&lt;1Gi]</pre> 
 </div> 
 <p>节点级别的内存压力将导致系统内存不足（System OOMs），这将影响到整个节点及其上运行的所有 pod。节点可以暂时离线直到内存已经回收为止。为了防止（或减少可能性）系统内存不足，kubelet 提供了 资源不足（Out of Resource） 管理。驱逐（Eviction）操作只支持 memory 和ephemeral-storage。通过 --eviction-hard 标志预留一些内存后，当节点上的可用内存降至保留值以下时，kubelet 将尝试 驱逐 pod。假设，如果节点上不存在系统守护进程，pod 将不能使用超过 capacity-eviction-hard 的资源。因此，为驱逐而预留的资源对 pod 是不可用的。</p> 
 <p>eviction-hard的值支持1Gi或者10%格式。</p> 
 <p>kubelet的默认eviction-hard值如下：</p> 
 <ul><li><code>memory.available&lt;100Mi</code></li><li><code>nodefs.available&lt;10%</code></li><li><code>nodefs.inodesFree&lt;5%</code></li><li><code>imagefs.available&lt;15%</code></li></ul> 
 <h4>1.    执行节点 Allocatable</h4> 
 <div class="cnblogs_code"> 
  <pre>Kubelet Flag: --enforce-node-allocatable=pods[,][system-reserved][,][kube-reserved]</pre> 
 </div> 
 <p>调度器将 Allocatable 按 pod 的可用 capacity 对待。</p> 
 <p>kubelet 默认在 pod 中执行 Allocatable。无论何时，如果所有 pod 的总用量超过了 Allocatable，驱逐 pod 的措施将被执行。有关驱逐策略的更多细节可以在 这里 找到。请通过设置 kubelet --enforce-node-allocatable 标志值为 pods 控制这个措施。</p> 
 <p>可选的，通过在相同标志中同时指定 kube-reserved 和 system-reserved 值能够使 kubelet 执行 kube-reserved 和 system-reserved。请注意，要想执行 kube-reserved 或者 system-reserved时，需要分别指定 --kube-reserved-cgroup 或者 --system-reserved-cgroup。</p> 
 <h3>三、  一般原则</h3> 
 <p>系统守护进程期望被按照类似 Guaranteed pod 一样对待。系统守护进程可以在其范围控制组中爆发式增长，您需要将这个行为作为 kubernetes 部署的一部分进行管理。例如，kubelet 应该有它自己的控制组并和容器运行时（container runtime）共享 Kube-reserved 资源。然而，如果执行了 kube-reserved，则 kubelet 不能突然爆发并耗尽节点的所有可用资源。</p> 
 <p>在执行 system-reserved 预留操作时请加倍小心，因为它可能导致节点上的关键系统服务 CPU 资源短缺或因为内存不足（OOM）而被终止。</p> 
 <p>在 pods 上执行 Allocatable 作为开始。</p> 
 <p>一旦足够用于追踪系统守护进程的监控和告警的机制到位，请尝试基于用量探索（usage heuristics）方式执行 kube-reserved。</p> 
 <p>随着时间推进，如果绝对必要，可以执行 system-reserved。</p> 
 <p>随着时间的增长以及越来越多特性的加入，kube 系统守护进程对资源的需求可能也会增加。以后 kubernetes 项目将尝试减少对节点系统守护进程的利用，但目前那并不是优先事项。所以，请期待在将来的发布中将 Allocatable 容量降低。</p> 
 <h3>四、  示例场景</h3> 
 <p>这是一个用于说明节点 Allocatable 计算方式的示例：</p> 
 <p> </p> 
 <p>节点拥有 32Gi 内存，16 核 CPU 和 100Gi 存储</p> 
 <p>--kube-reserved 设置为 cpu=1,memory=2Gi,storage=1Gi</p> 
 <p>--system-reserved 设置为 cpu=500m,memory=1Gi,storage=1Gi</p> 
 <p>--eviction-hard 设置为 memory.available&lt;500Mi,nodefs.available&lt;10%</p> 
 <p>在这个场景下，Allocatable 将会是 14.5 CPUs、28.5Gi 内存以及 98Gi 存储。调度器保证这个节点上的所有 pod 请求的内存总量不超过 28.5Gi，存储不超过 88Gi。当 pod 的内存使用总量超过 28.5Gi 或者磁盘使用总量超过 88Gi 时，Kubelet 将会驱逐它们。如果节点上的所有进程都尽可能多的使用 CPU，则 pod 加起来不能使用超过 14.5 CPUs 的资源。</p> 
 <p> </p> 
 <p>当没有执行 kube-reserved 和/或 system-reserved 且系统守护进程使用量超过其预留时，如果节点内存用量高于 31.5Gi 或存储大于 90Gi，kubelet 将会驱逐 pod。</p> 
 <p> </p> 
 <p>可用特性</p> 
 <p>截至 Kubernetes 1.2 版本，已经可以可选的指定 kube-reserved 和 system-reserved 预留。当在相同的发布中都可用时，调度器将转为使用 Allocatable 替代 Capacity。</p> 
 <p> </p> 
 <p>截至 Kubernetes 1.6 版本，eviction-thresholds 是通过计算 Allocatable 进行考虑。要使用旧版本的行为，请设置 --experimental-allocatable-ignore-eviction kubelet 标志为 true。</p> 
 <p> </p> 
 <p>截至 Kubernetes 1.6 版本，kubelet 使用控制组在 pod 上执行 Allocatable。要使用旧版本行为，请取消设置 --enforce-node-allocatable kubelet 标志。请注意，除非 --kube-reserved 或者 --system-reserved 或者 --eviction-hard 标志没有默认参数，否则 Allocatable 的实施不会影响已经存在的 deployment。</p> 
 <p> </p> 
 <p>截至 Kubernetes 1.6 版本，kubelet 在 pod 自己的 cgroup 沙箱中启动它们，这个 cgroup 沙箱在 kubelet 管理的 cgroup 层次结构中的一个独占部分中。在从前一个版本升级 kubelet之前，要求操作员 drain 节点，以保证 pod 及其关联的容器在 cgroup 层次结构中合适的部分中启动。</p> 
 <p> </p> 
 <p>截至 Kubernetes 1.7 版本，kubelet 支持指定 storage 为 kube-reserved 和 system-reserved 的资源。</p> 
 <h3>五、  Openshift配置</h3> 
 <p>在kubelet中新增参数system-reserved和kube-reserved，</p> 
 <p> </p> 
 <p>可以在每个node节点的/etc/origin/node/node-config.yaml修改，但是这是临时生效，</p> 
 <p> </p> 
 <p>想要永久生效，需要修改openshift-node命名空间里的configmap，想改哪个group的参数就修改哪个configmap。</p> 
 <p> </p> 
 <p>在openshift中新增或者修改kubelet的参数都可以通过这种方式。</p> 
 <p> </p> 
 <p>例如：给compute-normal group新增system-reserved和kube-reserved参数：</p> 
 <p> </p> 
 <p>kubectl edit -n openshift-node cm node-config-compute-normal</p> 
 <div class="cnblogs_code"> 
  <pre><span style="color:#000000;">    kubeletArguments:
      bootstrap</span>-<span style="color:#000000;">kubeconfig:
      </span>- /etc/origin/node/<span style="color:#000000;">bootstrap.kubeconfig
      cert</span>-<span style="color:#000000;">dir:
      </span>- /etc/origin/node/<span style="color:#000000;">certificates
      enable</span>-controller-attach-<span style="color:#000000;">detach:
      </span>- <span style="color:#800000;">'</span><span style="color:#800000;">true</span><span style="color:#800000;">'</span><span style="color:#000000;">
      feature</span>-<span style="color:#000000;">gates:
      </span>- RotateKubeletClientCertificate=<span style="color:#0000ff;">true</span>,RotateKubeletServerCertificate=<span style="color:#0000ff;">true</span><span style="color:#000000;">
      node</span>-<span style="color:#000000;">labels:
      </span>- node-role.kubernetes.io/compute-normal=<span style="color:#0000ff;">true</span><span style="color:#000000;">
      pod</span>-manifest-<span style="color:#000000;">path:
      </span>- /etc/origin/node/<span style="color:#000000;">pods
      rotate</span>-<span style="color:#000000;">certificates:
      </span>- <span style="color:#800000;">'</span><span style="color:#800000;">true</span><span style="color:#800000;">'</span><span style="color:#000000;">
      evction</span>-<span style="color:#000000;">hard:
      </span>- <span style="color:#800000;">'</span><span style="color:#800000;">memory.available&lt;500Mi,nodefs.available&lt;10%</span><span style="color:#800000;">'</span><span style="color:#000000;">
      system</span>-<span style="color:#000000;">reserved:
      </span>- <span style="color:#800000;">'</span><span style="color:#800000;">cpu=200m,memory=1Gi</span><span style="color:#800000;">'</span><span style="color:#000000;">
      kube</span>-<span style="color:#000000;">reserved:
      </span>- <span style="color:#800000;">"</span><span style="color:#800000;">cpu=200m,memory=1Gi</span><span style="color:#800000;">"</span></pre> 
 </div> 
 <p align="left">如果修改的是master组件的参数，而不是kubelet的，则按照下面的方法。</p> 
 <p align="left">修改master的配置在每个master的/etc/origin/master/master-config.yaml</p> 
 <p align="left">kubernetesMasterConfig:<br>   controllerArguments: <br>     node-monitor-period:<br>     - "10m"</p> 
 <p align="left">重启相关组件</p> 
 <p align="left"># master-restart api</p> 
 <p align="left"># master-restart controllers</p> 
 <p> </p> 
 <p>修改pod-evction-timeout参数：</p> 
 <p>1.修改每个master上/etc/origin/master/master-config.yaml</p> 
 <p><span style="color:#ff0000;">  podEvictionTimeout: "2m0s"</span></p> 
 <p>2.重启controller：</p> 
 <p><span style="color:#ff0000;">master-restart controllers</span></p> 
 <p> </p> 
 <h3>六、  参数资料</h3> 
 <p><a href="http://docs.kubernetes.org.cn/723.html" rel="nofollow">http://docs.kubernetes.org.cn/723.html</a></p> 
 <p><a href="https://my.oschina.net/jxcdwangtao/blog/1629059" rel="nofollow">https://my.oschina.net/jxcdwangtao/blog/1629059</a></p> 
 <p>https://kubernetes.io/docs/tasks/administer-cluster/reserve-compute-resources/</p> 
 <p><a href="https://kubernetes.io/docs/tasks/administer-cluster/out-of-resource/" rel="nofollow">https://kubernetes.io/docs/tasks/administer-cluster/out-of-resource/</a></p> 
</div> 
<p>转载于:https://www.cnblogs.com/yehaifeng/p/10715192.html</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/630109471789b206de6314915e3bcb9c/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">windows 2008R2 配置iis 服务器</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/168dac65639567ee17ea0d536ad91665/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">Android 让View 和 ViewGroup 同时响应点击或者长按事件</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>