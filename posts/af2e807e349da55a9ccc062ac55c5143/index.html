<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>单调栈讲解 &#43; AcWing 830. 单调栈（双指针优化） - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="单调栈讲解 &#43; AcWing 830. 单调栈（双指针优化）" />
<meta property="og:description" content="单调栈 常见模型：给定一个序列，求 序列当中的每一个元素左侧 离它最近，且比它小/大 的元素 或 右侧 离它最近，且比它小/大 的元素
举个例子，比如给定一个序列：3、4、2、7、5
我们要找到每一个元素左侧，且最近的比它小的数是什么，如果不存在返回 -1
第一个元素 3 左侧没有比它小的数，返回 -1，第二个元素 4 左侧比它小的数且最近的数是 3，因此返回 3，后面的元素以此类推，如下图，第一行是原序列，第二行是返回的答案。
单调栈思考方式和双指针类似：先想想暴力做法是什么，之后挖掘出一些性质，将目光集中在比较少的状态中，从而起到将时间复杂度降低的效果。
暴力做法 时间复杂度为 O(n^2)，当数据达到1e5显然会超时
for(int i=0; i&lt;n; &#43;&#43;i) //枚举原序列中的每一个数 for(int j=i-1; j&gt;=0; --j) //从a[i]左侧第一个数a[i-1]开始往左枚举 if(a[i]&gt;a[j]) //知道找到a[i]左侧第一个比a[i]小的数a[j]为止 { printf(&#34;%d &#34;, a[j]); //答案 break; } 看看暴力做法中有什么可以挖掘的性质，
对于暴力做法，随着第一重循环 i 往右枚举，我们可以用一个栈存储 i 左侧所有元素，初始时栈为空，i 指针每往右移动一个位置就会往栈中新添一个元素，因此当枚举到 a[i] 时，其左侧所有元素：a[0]、a[1]、...、a[i-1] 都会被加入栈中，当我们要找答案的时候，我们从栈顶开始往下查找，找到第一个比 a[i] 小的数则 break
若要进行优化，我们显然应该将重点放在栈上，分析一下 栈中是否有些元素一定不会被作为答案输出，
举个例子，假设在栈中有 a[3] ≥ a[5]，那么 a[3] 一定不会在后续中作为答案输出，
因为：a[5] 在 a[3] 的右侧，且 a[5] ≤ a[3]，当我们找答案时，如果 a[3] 是目标值，则意味着 a[3] &lt; a[i]，又由于 a[5] ≤ a[3]，因此 a[5] 也小于 a[i]，我们显然要查找离 a[i] 最近且比 a[i] 小的元素，则 a[3] 一定不会被用作答案输出，那么我们一定可以换成 a[5] 作为更优的答案" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/af2e807e349da55a9ccc062ac55c5143/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-03-13T08:51:09+08:00" />
<meta property="article:modified_time" content="2022-03-13T08:51:09+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">单调栈讲解 &#43; AcWing 830. 单调栈（双指针优化）</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <h3><a id="_1"></a>单调栈</h3> 
<p><strong>常见模型</strong>：给定一个序列，求 序列当中的<strong>每一个元素左侧</strong> 离它<strong>最近</strong>，且<strong>比它小/大</strong> 的元素 或 <strong>右侧</strong> 离它<strong>最近</strong>，且<strong>比它小/大</strong> 的元素</p> 
<p>举个例子，比如给定一个序列：<code>3、4、2、7、5</code></p> 
<p>我们要找到每一个元素左侧，且最近的比它小的数是什么，如果<strong>不存在返回</strong> <code>-1</code></p> 
<p>第一个元素 <code>3</code> 左侧没有比它小的数，返回 <code>-1</code>，第二个元素 <code>4</code> 左侧比它小的数且最近的数是 <code>3</code>，因此返回 <code>3</code>，后面的元素以此类推，如下图，<strong>第一行是原序列，第二行是返回的答案</strong>。<br> <img src="https://images2.imgbox.com/72/60/1ThmQBsP_o.png" alt="在这里插入图片描述"><br> 单调栈思考方式和<strong>双指针</strong>类似：先想想暴力做法是什么，之后挖掘出一些性质，<strong>将目光集中在比较少的状态中</strong>，从而起到将时间复杂度降低的效果。</p> 
<p><strong>暴力做法</strong> 时间复杂度为 <code>O(n^2)</code>，当数据达到<code>1e5</code>显然会超时</p> 
<pre><code>for(int i=0; i&lt;n; ++i) //枚举原序列中的每一个数
        for(int j=i-1; j&gt;=0; --j) //从a[i]左侧第一个数a[i-1]开始往左枚举
        if(a[i]&gt;a[j]) //知道找到a[i]左侧第一个比a[i]小的数a[j]为止
        {
                printf("%d ", a[j]); //答案
                break;
        }
</code></pre> 
<p>看看暴力做法中有什么<strong>可以挖掘的性质</strong>，</p> 
<p>对于暴力做法，随着第一重循环 <code>i</code> 往右枚举，我们可以<strong>用一个栈存储</strong> <code>i</code> <strong>左侧所有元素</strong>，初始时栈为空，<code>i</code> 指针每往右移动一个位置就会往栈中新添一个元素，因此当枚举到 <code>a[i]</code> 时，其左侧所有元素：<code>a[0]、a[1]、...、a[i-1]</code> 都会被加入栈中，当我们要找答案的时候，我们从栈顶开始往下查找，找到第一个比 <code>a[i]</code> 小的数则 <code>break</code></p> 
<p>若要进行<strong>优化</strong>，我们显然应该<strong>将重点放在栈上</strong>，分析一下 <strong>栈中是否有些元素一定不会被作为答案输出</strong>，</p> 
<p>举个例子，<strong>假设在栈中有</strong> <code>a[3] ≥ a[5]</code>，<strong>那么</strong> <code>a[3]</code> <strong>一定不会在后续中作为答案输出</strong>，</p> 
<p>因为：<code>a[5]</code> 在 <code>a[3]</code> 的右侧，且 <code>a[5] ≤ a[3]</code>，当我们找答案时，如果 <code>a[3]</code> 是目标值，则意味着 <code>a[3] &lt; a[i]</code>，又由于 <code>a[5] ≤ a[3]</code>，因此 <code>a[5]</code> 也小于 <code>a[i]</code>，我们显然<strong>要查找离</strong> <code>a[i]</code> <strong>最近且比</strong> <code>a[i]</code> <strong>小的元素</strong>，则 <code>a[3]</code> <strong>一定不会被用作答案输出</strong>，那么我们一定可以换成 <code>a[5]</code> <strong>作为更优的答案</strong></p> 
<h4><a id="_34"></a><strong>单调栈核心思想</strong>：</h4> 
<p>对于更一般的情况，如果栈中存在这样的<strong>逆序关系</strong>：<code>a[x] ≥ a[y] (x &lt; y)</code>，那么 <code>a[x]</code> 可以<strong>从栈中删去</strong>，最终栈中剩下的序列一定是个<strong>严格单调序列</strong>了</p> 
<p>如果我们想在这个严格单调的栈（设为 <code>stk[]</code>）中查找答案，从栈顶 <code>stk[tt]</code> 开始查找，<strong>如果</strong> <code>stk[tt] ≥ a[i]</code>，<code>a[i]</code><strong>是在</strong> <code>stk[tt]</code> <strong>更右侧</strong>，<strong>显然答案更优</strong>，那么 <strong>栈顶</strong> <code>stk[tt]</code> 必定<strong>不会在后续中被当成答案输出</strong>，因此可以<strong>直接删掉栈顶元素</strong>，这样<strong>循环进行</strong>，直到一个栈顶元素 <code>stk[tt]</code> <strong>小于</strong> <code>a[i]</code> <strong>为止</strong>，此时的 <strong>栈顶元素</strong> <code>stk[tt]</code> 就是 <code>a[i]</code> <strong>左侧且离它最近且比它小的元素</strong>（答案），之后把 <code>a[i]</code> <strong>压入栈中</strong>。</p> 
<h4><a id="_40"></a>时间复杂度：</h4> 
<p><span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         O 
        
       
         ( 
        
       
         n 
        
       
         ) 
        
       
      
        O(n) 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathdefault" style="margin-right: 0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span></span></p> 
<h4><a id="_43"></a><strong>代码片段</strong>：</h4> 
<pre><code>for(int i=0; i&lt;n; ++i)
{
        int x;
        scanf("%d", &amp;x); //读入 n 个元素
        //当栈不为空且栈顶元素 stk[tt] 大于等于当前数时栈顶元素一定不会被再用到，则删除栈顶元素 tt--
        while(tt &amp;&amp; stk[tt]&gt;=x) --tt;
        if(tt) printf("%d ", stk[tt]); //上述操作删除栈顶操作完成后，如果栈不为空，那么栈顶则为我们要找的答案，输出即可
        else printf("-1 "); //如栈为空，说明x左侧没有任何一个元素比它小，输出 -1 即可
        stk[++tt]=x; //最后记得将 x 压入栈中
}
</code></pre> 
<h3><a id="AcWing_830__56"></a>例题：AcWing 830. 单调栈</h3> 
<p><img src="https://images2.imgbox.com/9e/e1/WN8T0byg_o.png" alt="在这里插入图片描述"><br> <img src="https://images2.imgbox.com/48/56/CSi0vt7U_o.png" alt="在这里插入图片描述"></p> 
<h5><a id="_59"></a>代码：</h5> 
<p>手打数组模拟栈</p> 
<pre><code>#include&lt;bits/stdc++.h&gt;

using namespace std;

const int N = 1e5+10;
int stk[N], n, tt;

int main()
{
    cin&gt;&gt;n;
    for(int i=0; i&lt;n; ++i)
    {
        int x;
        scanf("%d", &amp;x); 
        while(tt &amp;&amp; stk[tt]&gt;=x) --tt;
        if(tt) printf("%d ", stk[tt]); 
        else printf("-1 "); 
        stk[++tt]=x; 
    }
    
    return 0;
}

</code></pre> 
<p>STL栈</p> 
<pre><code>#include&lt;bits/stdc++.h&gt;

using namespace std;
const int N = 1e5+10;
int n;
stack&lt;int&gt; stk;

int main()
{
    cin&gt;&gt;n;
    for(int i=0; i&lt;n; ++i)
    {
        int x;
        scanf("%d", &amp;x);
        while(stk.size() &amp;&amp; stk.top()&gt;=x) stk.pop();
        if(stk.size()) printf("%d ", stk.top());
        else printf("-1 ");
        stk.push(x);
    }
    
    return 0;
}
</code></pre>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/db84e22da867b0f47633ac9e1986184f/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">STM32CubeIDE使用技巧（FreeRTOS点亮一盏灯)</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/c965ce1bb70258a9532f9db6e4338851/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">计算机系统概论</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>