<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>[RSA议题分析] eBPF Warfare - Detecting Kernel &amp; eBPF Rootkits with Tracee - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="[RSA议题分析] eBPF Warfare - Detecting Kernel &amp; eBPF Rootkits with Tracee" />
<meta property="og:description" content="文章目录 简介议题分析基础知识用户空间与内核空间hookrootkit追踪技术 eBPF架构Tracee - 一个运行时安全检查工具 RootKit种类与各个阶段的攻防LD_PRELOAD RootKitKernel Module RooKitKernel RootKit HidingKernel RootKit Hooksyscall table hookingfile operations hooking Kernel RootKit CommunicationCommand ExecutioneBPF RootKiteBPF Programs LoadeBPF Probes PlacementHiding eBPF RootKiteBPF RootKit Communication Channel 总结 简介 eBPF在恶意活动检测方面仍是未知领域。随着威胁的不断出现，我们需要采取主动。参与者将了解到不同类型的rootkits，它们的攻击流程，它们的运作方式以及如何检测它们。最后，他们将学习如何使用Tracee，这是一个利用eBPF来检测这些威胁并在攻击者面前获得优势的开源工具。
本篇议题是由Aqua Security实验室的Asaf Eitani 和Idan Revivo两位研究员带来
议题分析 基础知识 讨论rootkit需要知道的基础知识
用户空间与内核空间 通过系统调用交互
hook 追踪rootkit可能用到的技术，不改变两段代码逻辑的前提下，在两段逻辑之间插入一段逻辑
rootkit追踪技术 选择追踪rootkit的手段之前，需要知道，他们需要具备如下特征
低开销，别影响性能隐蔽，不能被攻击者察觉难以逃避，攻击者无法反制我们完整的系统可见性，获取更多的信息以至于让我们确认现在安全安全，物理上的，别把系统搞崩 目前方法的优劣：
eBPF 架构 eBPF，全称为扩展伯克利包过滤器（Extended Berkeley Packet Filter），是一种在Linux内核中运行的轻量级虚拟机。eBPF的主要优点是它能够在不更改内核源代码或加载内核模块的情况下，动态地在内核中插入程序。这些程序可以用于收集性能数据、跟踪系统调用、监视网络流量等。eBPF程序通常使用C语言编写，然后通过LLVM编译器编译成BPF字节码，最后由内核的BPF虚拟机执行。
用户空间将eBPF字节码传入内核的verifier模块进行运行前检查，通过之后送到BPF沙箱中允许，这时可以使用内核提供的各个功能的探测器(hook的其他模块)来进行操作。结果会返回给用户空间。用户空间也可以通过maps和内核交互。
Tracee - 一个运行时安全检查工具 演讲者所在组织开发的开源工具，使用eBPF来完成堆操作系统中rootKit的追踪。各种好，拥有自己的规则引擎，可以自己编写规则动态检测，源码如下：
GitHub - aquasecurity/tracee: Linux Runtime Security and Forensics using eBPF" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/ac5c3b3f19bbc3069d2a5b2ec6f1cadb/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-05-26T15:20:35+08:00" />
<meta property="article:modified_time" content="2023-05-26T15:20:35+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">[RSA议题分析] eBPF Warfare - Detecting Kernel &amp; eBPF Rootkits with Tracee</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-dracula">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p></p> 
<div class="toc"> 
 <h4>文章目录</h4> 
 <ul><li><ul><li><a href="#_1" rel="nofollow">简介</a></li><li><a href="#_7" rel="nofollow">议题分析</a></li><li><ul><li><a href="#_9" rel="nofollow">基础知识</a></li><li><ul><li><a href="#_13" rel="nofollow">用户空间与内核空间</a></li><li><a href="#hook_20" rel="nofollow">hook</a></li><li><a href="#rootkit_27" rel="nofollow">rootkit追踪技术</a></li></ul> 
    </li><li><a href="#eBPF_42" rel="nofollow">eBPF</a></li><li><ul><li><a href="#_44" rel="nofollow">架构</a></li><li><a href="#Tracee___53" rel="nofollow">Tracee - 一个运行时安全检查工具</a></li></ul> 
    </li><li><a href="#RootKit_59" rel="nofollow">RootKit种类与各个阶段的攻防</a></li><li><ul><li><a href="#LD_PRELOAD_RootKit_68" rel="nofollow">LD_PRELOAD RootKit</a></li><li><a href="#Kernel_Module_RooKit_90" rel="nofollow">Kernel Module RooKit</a></li><li><a href="#Kernel_RootKit_Hiding_110" rel="nofollow">Kernel RootKit Hiding</a></li><li><a href="#Kernel_RootKit_Hook_124" rel="nofollow">Kernel RootKit Hook</a></li><li><ul><li><a href="#syscall_table_hooking_128" rel="nofollow">syscall table hooking</a></li><li><a href="#file_operations_hooking_142" rel="nofollow">file operations hooking</a></li></ul> 
     </li><li><a href="#Kernel_RootKit_Communication_165" rel="nofollow">Kernel RootKit Communication</a></li><li><a href="#Command_Execution_169" rel="nofollow">Command Execution</a></li><li><a href="#eBPF_RootKit_190" rel="nofollow">eBPF RootKit</a></li><li><ul><li><a href="#eBPF_Programs_Load_197" rel="nofollow">eBPF Programs Load</a></li><li><a href="#eBPF_Probes_Placement_208" rel="nofollow">eBPF Probes Placement</a></li><li><a href="#Hiding_eBPF_RootKit_229" rel="nofollow">Hiding eBPF RootKit</a></li><li><a href="#eBPF_RootKit_Communication_Channel_233" rel="nofollow">eBPF RootKit Communication Channel</a></li></ul> 
    </li></ul> 
   </li></ul> 
   </li><li><a href="#_240" rel="nofollow">总结</a></li></ul> 
 </li></ul> 
</div> 
<p></p> 
<h3><a id="_1"></a>简介</h3> 
<p>eBPF在恶意活动检测方面仍是未知领域。随着威胁的不断出现，我们需要采取主动。参与者将了解到不同类型的rootkits，它们的攻击流程，它们的运作方式以及如何检测它们。最后，他们将学习如何使用Tracee，这是一个利用eBPF来检测这些威胁并在攻击者面前获得优势的开源工具。</p> 
<p>本篇议题是由Aqua Security实验室的Asaf Eitani 和Idan Revivo两位研究员带来</p> 
<h3><a id="_7"></a>议题分析</h3> 
<h4><a id="_9"></a>基础知识</h4> 
<p>讨论rootkit需要知道的基础知识</p> 
<h5><a id="_13"></a>用户空间与内核空间</h5> 
<p>通过系统调用交互</p> 
<p><img src="https://images2.imgbox.com/c8/c5/pU95Hf3s_o.png" alt="在这里插入图片描述"></p> 
<h5><a id="hook_20"></a>hook</h5> 
<p>追踪rootkit可能用到的技术，不改变两段代码逻辑的前提下，在两段逻辑之间插入一段逻辑</p> 
<p><img src="https://images2.imgbox.com/89/5e/2Vmq8PFR_o.png" alt="在这里插入图片描述"></p> 
<h5><a id="rootkit_27"></a>rootkit追踪技术</h5> 
<p>选择追踪rootkit的手段之前，需要知道，他们需要具备如下特征</p> 
<ul><li>低开销，别影响性能</li><li>隐蔽，不能被攻击者察觉</li><li>难以逃避，攻击者无法反制我们</li><li>完整的系统可见性，获取更多的信息以至于让我们确认现在安全</li><li>安全，物理上的，别把系统搞崩</li></ul> 
<p>目前方法的优劣：</p> 
<p><img src="https://images2.imgbox.com/ae/f6/2Zx5FcRH_o.png" alt="在这里插入图片描述"></p> 
<h4><a id="eBPF_42"></a>eBPF</h4> 
<h5><a id="_44"></a>架构</h5> 
<p>eBPF，全称为扩展伯克利包过滤器（Extended Berkeley Packet Filter），是一种在Linux内核中运行的轻量级虚拟机。eBPF的主要优点是它能够在不更改内核源代码或加载内核模块的情况下，动态地在内核中插入程序。这些程序可以用于收集性能数据、跟踪系统调用、监视网络流量等。eBPF程序通常使用C语言编写，然后通过LLVM编译器编译成BPF字节码，最后由内核的BPF虚拟机执行。</p> 
<p>用户空间将eBPF字节码传入内核的verifier模块进行运行前检查，通过之后送到BPF沙箱中允许，这时可以使用内核提供的各个功能的探测器(hook的其他模块)来进行操作。结果会返回给用户空间。用户空间也可以通过maps和内核交互。</p> 
<p><img src="https://images2.imgbox.com/9a/a5/Ml17xQuc_o.png" alt="在这里插入图片描述"></p> 
<h5><a id="Tracee___53"></a>Tracee - 一个运行时安全检查工具</h5> 
<p>演讲者所在组织开发的开源工具，使用eBPF来完成堆操作系统中rootKit的追踪。各种好，拥有自己的规则引擎，可以自己编写规则动态检测，源码如下：</p> 
<p><a href="https://github.com/aquasecurity/tracee">GitHub - aquasecurity/tracee: Linux Runtime Security and Forensics using eBPF</a></p> 
<h4><a id="RootKit_59"></a>RootKit种类与各个阶段的攻防</h4> 
<p>Rootkit是一种恶意软件，它的主要目标是在系统中隐藏自己的存在，同时保持对系统的最高级别访问权限，也就是"root"权限。Rootkit的主要特点是它的隐蔽性和持久性。一旦Rootkit安装在系统中，它就会尽可能地隐藏自己的存在，包括隐藏文件、进程和网络连接，甚至修改系统日志来消除任何被发现的痕迹。同时，由于Rootkit具有最高级别的系统访问权限，它可以完全控制系统，包括安装其他恶意软件、窃取敏感数据、监视用户活动等。</p> 
<p>Rootkit可以在操作系统的不同层级安装，包括内核级（Kernel-level）和用户级（User-level）。内核级Rootkit可以直接修改操作系统内核的代码或数据结构，从而获得更高级别的控制和更强的隐藏能力。用户级Rootkit则通常通过修改系统的用户模式服务和应用程序来实现其目标。</p> 
<p><img src="https://images2.imgbox.com/20/d2/UG6GdyM4_o.png" alt="在这里插入图片描述"></p> 
<h5><a id="LD_PRELOAD_RootKit_68"></a>LD_PRELOAD RootKit</h5> 
<p>LD_PRELOAD是Linux系统中的一个环境变量，它可以用来改变程序运行时的链接行为。具体来说，当你设置了LD_PRELOAD环境变量后，系统在启动一个程序时，会先加载LD_PRELOAD指定的共享库，然后再加载其他的库。这样，LD_PRELOAD指定的库就可以覆盖其他库中的函数，改变程序的行为。</p> 
<p>LD_PRELOAD Rootkit就是利用这个机制来实现其恶意行为的。它通常会提供一个自定义的共享库，这个库中包含了一些系统函数的"伪装"版本。当LD_PRELOAD设置为这个库时，系统在运行程序时就会使用这些"伪装"的函数，而不是原本的系统函数。这样，Rootkit就可以在这些函数中插入恶意代码，实现例如隐藏文件、修改系统调用返回结果等行为。</p> 
<p>例如，一个常见的LD_PRELOAD Rootkit可能会提供一个"伪装"的<code>readdir</code>函数。<code>readdir</code>函数是用来读取目录内容的，Rootkit可以在这个函数中过滤掉一些文件，使得这些文件在ls命令等操作中不可见。</p> 
<p><img src="https://images2.imgbox.com/47/16/tF2t9tcH_o.png" alt="在这里插入图片描述"></p> 
<p>总的来说，LD_PRELOAD Rootkit是一种用户级别的Rootkit，它利用Linux的动态链接机制来实现其恶意行为。虽然它的能力没有内核级Rootkit强大，但是由于其实现相对简单，侵入性较低，因此在实际中也比较常见。</p> 
<p><strong>使用eBPF检测</strong></p> 
<p>创建一个事件，每次将共享对象加载到内存的时候，检查所有导出符号，如果与部分攻击符号有关，则会创建一个事件说明这个符号正在被加载进内存。这不是原始库的一部分。</p> 
<p><img src="https://images2.imgbox.com/46/92/JzquVe1m_o.png" alt="在这里插入图片描述"></p> 
<p>大概意思应该是加载动态库的时候检测动态库，如果这里有一些符号使用了一些敏感可能被用于攻击的其他符号(还需要手动指定)，则会输出事件。我感觉这个检测还是比较好绕过的。我可以不使用任何其他符号，直接提供一个覆盖掉libc中符号的方法，或者直接加载一个fakelibc。而且手动指定敏感符号就类似黑名单，众所周知黑名单不是一个很好的防御机制</p> 
<h5><a id="Kernel_Module_RooKit_90"></a>Kernel Module RooKit</h5> 
<p>Kernel Module Rootkit是一种内核级别的rootkit，它通过在操作系统内核中插入或修改模块来实现其恶意行为。由于内核模块具有最高级别的系统访问权限，这种rootkit可以完全控制系统，并且具有很强的隐藏能力。</p> 
<p>Kernel Module Rootkit通常会提供一个自定义的内核模块，这个模块中包含了一些系统函数的"伪装"版本。当这个模块被加载到内核时，它就可以覆盖内核中的函数，改变系统的行为。例如，rootkit可能会提供一个"伪装"的<code>read</code>函数，这个函数在读取文件内容时，可以过滤掉一些数据，使得这些数据对用户不可见。</p> 
<p>由于Kernel Module Rootkit的强大能力和高度隐蔽性，检测和移除这种rootkit是一项非常困难的任务。这通常需要专门的反rootkit工具，以及深入的系统知识和经验。</p> 
<p>内核RootKit生效通常会有如下五个步骤，接下来也会从这5个步骤中依次突破。</p> 
<p><img src="https://images2.imgbox.com/60/cd/rhXYKoB4_o.png" alt="在这里插入图片描述"></p> 
<p><strong>检测内核RootKit - 在加载中</strong></p> 
<p>使用eBPF在do_init_module函数中添加钩子，监听该事件就可以得知加载到内核的内核模块，然后会将内核模块所在缓冲区数据传出，以供进一步分析这些内核模块发现rootkit</p> 
<p><img src="https://images2.imgbox.com/07/16/xu1Yn6Jk_o.png" alt="在这里插入图片描述"></p> 
<h5><a id="Kernel_RootKit_Hiding_110"></a>Kernel RootKit Hiding</h5> 
<p>内核中含有一个双链表链接所有内核模块结构体，遍历该双链表可以得到所有已经加载的内核模块，RootKit可以将自己的内核模块结构体从该双链表中摘除来隐藏自己：</p> 
<p><img src="https://images2.imgbox.com/47/4d/zgBeUT8J_o.png" alt="在这里插入图片描述"></p> 
<p><strong>检测试图隐藏自己的Rootkit</strong></p> 
<p>创建一个时间规律的事件，每次触发会检测这个链表，如果发现跟之前有些差异，则说明有人想要隐藏自己。</p> 
<p><img src="https://images2.imgbox.com/b0/ec/bpgtKtxk_o.png" alt="在这里插入图片描述"></p> 
<h5><a id="Kernel_RootKit_Hook_124"></a>Kernel RootKit Hook</h5> 
<p>这一步是RootKit实际开始攻击的第一步，有三种常见的做法：</p> 
<h6><a id="syscall_table_hooking_128"></a>syscall table hooking</h6> 
<p>系统调用表是用户态切换到内核态的时候给内核的指令，内核会根据指令编号寻找对应的系统调用入口，这样存在一个表去记录指令编号和入口的对应关系。RootKit通过篡改系统调用表中某些系统调用的入口指针实现对该系统调用的hook和劫持。当触发该系统调用的时候会指向恶意RootKit指定的代码，他可以控制返回给用户什么内容。</p> 
<p><img src="https://images2.imgbox.com/af/79/BxcmqNjG_o.png" alt="在这里插入图片描述"></p> 
<p><strong>检测对系统调用表的劫持</strong></p> 
<p>检查系统调用入口指针是否存在于s_text和e_text之间，这是绝大部分内核符号所在的地址范围。如果出现系统调用表指向该范围之外的区域(实际上指向一个模块)，则有问题</p> 
<p><img src="https://images2.imgbox.com/a2/bd/sjvHUER5_o.png" alt="在这里插入图片描述"></p> 
<h6><a id="file_operations_hooking_142"></a>file operations hooking</h6> 
<p>file_operations 是内核的一个结构体，由多种文件操作的回调函数组成，如read、write、lseek、mmap等等。在任意文件系统和文件类型中，可以通过该结构体制定文件允许的操作类型，即设置对应回调函数。如，ls命令会调用file_operations中的iterate_shared回调函数获取目录下的文件信息：</p> 
<p><img src="https://images2.imgbox.com/4c/4b/fc7zoUvi_o.png" alt="在这里插入图片描述"></p> 
<p>攻击者可以通过篡改file_operations中的特定回调函数来劫持该逻辑：</p> 
<p><img src="https://images2.imgbox.com/7f/df/PD5adLrf_o.png" alt="在这里插入图片描述"></p> 
<p>然后再这其中可以篡改一些返回内容，或增加自己的攻击代码。</p> 
<p>Drovorub APT RooKit使用该种技术。</p> 
<p><strong>检测file_operations篡改</strong></p> 
<p>演讲者没有说怎么检测的。</p> 
<p><img src="https://images2.imgbox.com/95/f9/sSl18rm0_o.png" alt="在这里插入图片描述"></p> 
<h5><a id="Kernel_RootKit_Communication_165"></a>Kernel RootKit Communication</h5> 
<p>貌似没啥好办法，因为攻击者有各种方式和自己的恶意软件交互，他看起来就想正常程序一样。</p> 
<h5><a id="Command_Execution_169"></a>Command Execution</h5> 
<p>如果我们使用execve系统调用运行一个程序，那么他会调用security_bprm_check和sched_process_exec之后启动一个新进程去执行，而且大部分安全工具也是将自己hook到exec系统调用上。但并不只是从execve系统调用才可以产生新进程执行，call_usermodehelper函数也可以直接调用security_bprm_check来产生一个新进程：</p> 
<p><img src="https://images2.imgbox.com/d1/8c/GncWDVtj_o.png" alt="在这里插入图片描述"></p> 
<p>这是我我们在用户空间看检测不到的，如果只是在execve系统调用进行监控，自然也是监控不到的。</p> 
<p>开源恶意样本Reptile使用这种技术</p> 
<p><strong>检测命令执行</strong></p> 
<p>将上述几个点全部加上钩子列为监测点：</p> 
<p><img src="https://images2.imgbox.com/fb/f8/IahgWIJi_o.png" alt="在这里插入图片描述"></p> 
<p><img src="https://images2.imgbox.com/86/81/Rof6MwIB_o.png" alt="在这里插入图片描述"></p> 
<h5><a id="eBPF_RootKit_190"></a>eBPF RootKit</h5> 
<p>使用eBPF的RootKit是最近新出现的，和传统RootKit差别如下：</p> 
<p><img src="https://images2.imgbox.com/64/2c/fWoUheeH_o.png" alt="在这里插入图片描述"></p> 
<h6><a id="eBPF_Programs_Load_197"></a>eBPF Programs Load</h6> 
<p>他们使用eBPF模块启动，使用eBPF程序隐藏自身，同样拥有和恶意软件的交互渠道，也有自己的触发攻击载荷的方式。</p> 
<p><strong>检测eBPF RootKit</strong></p> 
<p>eBPF是通过eBPF系统调用传入一段eBPF字节码，可以通过监控eBPF系统调用的方式发现恶意样本，并将字节码传出以供分析。</p> 
<p><img src="https://images2.imgbox.com/4e/29/X2EnfmQe_o.png" alt="在这里插入图片描述"></p> 
<h6><a id="eBPF_Probes_Placement_208"></a>eBPF Probes Placement</h6> 
<p>eBPF提供了很多接口可以影响其他进程/命令/系统调用等的执行，如：</p> 
<ol><li>bfp_probe_write_user 向用户空间内存写数据。可以修改用户空间系统调用/函数的返回结果，比如修改read系统调用返回用户空间的返回结果，隐藏一些内容</li><li>bpf_override_return 篡改返回值，这里特值return 的值，也就是rax，可以假装某个命令执行成功，来欺骗用户。</li><li>bpf_skb_store_bytes &amp; bpf_skb_pull_data 这两个可以篡改通信数据，修改skb数据包，可以将本机的数据泄露出去。</li><li>bpf_send_signal 发送信号，可以杀死一个进程，比如杀死lsmod等防止用户发现自己。</li></ol> 
<p><strong>检测eBPF探针</strong></p> 
<p>这种方法的缺点是，会在dmesg打印一些东西。会暴露自己：</p> 
<p><img src="https://images2.imgbox.com/99/22/t82J5PH5_o.png" alt="在这里插入图片描述"></p> 
<p>或者检测其他eBPPF程序使用的探针(具体怎么检测没说)：</p> 
<p><img src="https://images2.imgbox.com/73/81/aHL1wOQy_o.png" alt="在这里插入图片描述"></p> 
<h6><a id="Hiding_eBPF_RootKit_229"></a>Hiding eBPF RootKit</h6> 
<p>eBPF系统调用不只是传入eBPF程序，列出所有程序等功能也使用该系统调用，可以hook eBPF系统调用的方式隐藏加载的RootKit。</p> 
<h6><a id="eBPF_RootKit_Communication_Channel_233"></a>eBPF RootKit Communication Channel</h6> 
<p>使用共享内存来交互：</p> 
<p><img src="https://images2.imgbox.com/76/fc/lBSwnn8h_o.png" alt="在这里插入图片描述"></p> 
<h3><a id="_240"></a>总结</h3> 
<p>本篇议题围绕RootKit的攻防技术展开讨论，列举了常见的LD_PRELOAD 用户层RootKit与各种内核层RootKit，如内核模块RootKit、eBPF RootKit。并分析了各种RootKit的工作流程，除此之外讲解了eBPF的主要功能和使用eBPF针对Rootkit的各种不同操作进行检测的技术。</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/85c565cfbc10fb1487c12d53a698064e/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">jvm之JMX</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/208dd9c5d82a7c88dece8eccbf4dcc50/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">mysql&#43;MHA 主从复制 故障切换</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>