<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>c语言extend函数,jQuery的extend方法源码解读 - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="c语言extend函数,jQuery的extend方法源码解读" />
<meta property="og:description" content="文章主要分为三部分，第一部分简单介绍了extend的语法，第二部分通过实例介绍extend的用途,最后一部分是extend的源码解读，同时另附extend的另一种实现方式。
一、方法介绍
jQuery 的 API 手册中，extend 方法挂载在 jQuery 和 jQuery.fn 两个不同的对象上，但在 jQuery 内部代码实现的是相同的，只是功能各不相同。
官方解释：
jQuery.extend:Merge the contents of two or more objects together into the first object.(把两个或者多个对象合并到第一个对象当中)
jQuery.fn.extend:Merge the contents of an object onto the jQuery prototype to provide new jQuery instance methods.(把对象挂载到 jQuery 的 prototype 上以扩展一个新的 jQuery 实例方法 。)
syntax:
jQuery.extend([deep,] [target,] object1 [,objectN]);
jQuery.fn.extend([deep，] [target,] object1 [,objectN])
deep: Boolen类型，可选，表示是否进行递归合并(深/浅复制)，为true是为深复制；默认值为false，浅复制。
target:扩展对象，可选，将接收新的属性。
objectN:一个对象，包含额外的属性，扩展到目标对象(扩展对象)。
二、extend能实现的功能
将两个或者更多个对象合并到第一个对象
在这种情况下，extend方法需要至少传入两个对象，语法如下：
jQuery.extend(target, object1 [,objectN])" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/1e935f0476b9055abd50c2969e59b390/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2021-05-21T18:37:13+08:00" />
<meta property="article:modified_time" content="2021-05-21T18:37:13+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">c语言extend函数,jQuery的extend方法源码解读</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <div style="font-size:16px;"> 
 <p>文章主要分为三部分，第一部分简单介绍了extend的语法，第二部分通过实例介绍extend的用途,最后一部分是extend的源码解读，同时另附extend的另一种实现方式。</p> 
 <p>一、方法介绍</p> 
 <p>jQuery 的 API 手册中，extend 方法挂载在 jQuery 和 jQuery.fn 两个不同的对象上，但在 jQuery 内部代码实现的是相同的，只是功能各不相同。</p> 
 <p>官方解释：</p> 
 <p>jQuery.extend:Merge the contents of two or more objects together into the first object.(把两个或者多个对象合并到第一个对象当中)</p> 
 <p>jQuery.fn.extend:Merge the contents of an object onto the jQuery prototype to provide new jQuery instance methods.(把对象挂载到 jQuery 的 prototype 上以扩展一个新的 jQuery 实例方法 。)</p> 
 <p>syntax:</p> 
 <p>jQuery.extend([deep,] [target,] object1 [,objectN]);</p> 
 <p>jQuery.fn.extend([deep，] [target,] object1 [,objectN])</p> 
 <p>deep: Boolen类型，可选，表示是否进行递归合并(深/浅复制)，为true是为深复制；默认值为false，浅复制。</p> 
 <p>target:扩展对象，可选，将接收新的属性。</p> 
 <p>objectN:一个对象，包含额外的属性，扩展到目标对象(扩展对象)。</p> 
 <p>二、extend能实现的功能</p> 
 <p>将两个或者更多个对象合并到第一个对象</p> 
 <p>在这种情况下，extend方法需要至少传入两个对象，语法如下：</p> 
 <p>jQuery.extend(target, object1 [,objectN])</p> 
 <p>or</p> 
 <p>jQuery.fn.extend(target, object1 [,objectN])</p> 
 <p>合并object1,...,objectN对象内容到第一个对象target。</p> 
 <p>这里需要注意一下几点：</p> 
 <p>1.合并后target对象的内容会改变，如果不希望改变target对象的内容，可以将第一个对象设置为{}.</p> 
 <p>2.这种方法是有返回值的，返回值就是修改后的target对象.</p> 
 <p>3.合并后的target对象的内容，属性值永远是在object1,...,objectN几个对象中最后一次出现时的属性值，也就是对于相同名字的属性，后面对象中的属性值会覆盖前面对象的属性值。</p> 
 <p>实例</p> 
 <p>function getOpt(target, obj1, obj2, obj3){<!-- --></p> 
 <p>$.extend(target, obj1, obj2, obj3);</p> 
 <p>return target;</p> 
 <p>}</p> 
 <p>var _default = {<!-- --></p> 
 <p>name : 'wenzi',</p> 
 <p>age : '25',</p> 
 <p>sex : 'male'</p> 
 <p>}</p> 
 <p>var obj1 = {<!-- --></p> 
 <p>name : 'obj1'</p> 
 <p>}</p> 
 <p>var obj2 = {<!-- --></p> 
 <p>name : 'obj2',</p> 
 <p>age : '36'</p> 
 <p>}</p> 
 <p>var obj3 = {<!-- --></p> 
 <p>age : '67',</p> 
 <p>sex : {'error':'sorry, I dont\'t kown'}</p> 
 <p>}</p> 
 <p>getOpt(_default, obj1, obj2, obj3); // {name: "obj2", age: "67", sex: {error: "sorry, I dont't kown"}}</p> 
 <p>覆盖函数的默认参数</p> 
 <p>这条用法实际上就是用的“将两个或者更多个对象合并到第一个对象”，之所以把提出来另起一个标题，是因为这是一种很常见的编程技巧。</p> 
 <p>实例：</p> 
 <p>function getOpt(option){<!-- --></p> 
 <p>var _default = {<!-- --></p> 
 <p>name : 'wenzi',</p> 
 <p>age : '25',</p> 
 <p>sex : 'male'</p> 
 <p>}</p> 
 <p>$.extend(_default, option);</p> 
 <p>return _default;</p> 
 <p>}</p> 
 <p>getOpt(); // {name: "wenzi", age: "25", sex: "male"}</p> 
 <p>getOpt({name:'bing'}); // {name: "bing", age: "25", sex: "male"}</p> 
 <p>getOpt({name:'bing', age:36, sex:'female'}); // {name: "bing", age: 36, sex: "female"}</p> 
 <p>函数getOpt含有默认参数(对象)_default，若传入函数的参数option(对象)中含有某个属性的值，则使用传入值，否则使用默认值。</p> 
 <p>深浅拷贝</p> 
 <p>所谓的深浅拷贝，就是C语言中的拷贝地址与数据</p> 
 <p>浅拷贝</p> 
 <p>浅复制对象A时，对象B将复制A的所有字段，如果字段是内存地址，B将复制地址，若果字段是基元类型，B将复制其值。</p> 
 <p>浅复制的缺点是如果你改变了对象B所指向的内存地址，你同时也改变了对象A指向这个地址的字段</p> 
 <p>function copy(target,cloneObj){<!-- --></p> 
 <p>for(var i in cloneObj){<!-- --></p> 
 <p>target[i] = cloneObj[i];</p> 
 <p>}</p> 
 <p>return target;</p> 
 <p>}</p> 
 <p>var a = {<!-- --></p> 
 <p>a:{ c:"c" },</p> 
 <p>b:"b"</p> 
 <p>}</p> 
 <p>var t = {};</p> 
 <p>copy(t,a);</p> 
 <p>t.a.c ="e";</p> 
 <p>console.log(a.a.c);//e</p> 
 <p>深拷贝</p> 
 <p>这种方式会完全复制所有数据，优点是B与A不会相互依赖(A,B完全脱离关联)， 缺点是复制的速度慢，代价大。</p> 
 <p>一种是实现深度拷贝的方案：</p> 
 <p>function type(obj){<!-- --></p> 
 <p>return Object.prototype.toString.call(obj).slice(8,-1);</p> 
 <p>}</p> 
 <p>function deepCopy(target,cloneObj){<!-- --></p> 
 <p>var copy;</p> 
 <p>for(var i in cloneObj){<!-- --></p> 
 <p>copy = cloneObj[i];</p> 
 <p>if(target === copy){<!-- --></p> 
 <p>continue;</p> 
 <p>}</p> 
 <p>if(type(copy) === "Array"){<!-- --></p> 
 <p>target[i] = arguments.callee(target[i] || [],copy);</p> 
 <p>}else if(type(copy) === "Object"){<!-- --></p> 
 <p>target[i] = arguments.callee(target[i] || {},copy);</p> 
 <p>}else{<!-- --></p> 
 <p>target[i] = copy;</p> 
 <p>}</p> 
 <p>}</p> 
 <p>return target;</p> 
 <p>}</p> 
 <p>var a = {<!-- --></p> 
 <p>a:{ c:"c" },</p> 
 <p>b:"b"</p> 
 <p>}</p> 
 <p>var t = deepCopy({},a);</p> 
 <p>t.a.c ="e";</p> 
 <p>console.log(a.a.c);//c</p> 
 <p>注意关于arguments,caller,callee不懂的请移步这里JavaScript 之arguments、caller 和 callee 介绍.</p> 
 <p>可以看到a没有被修改，但是要更深层次的遍历，肯定很耗费性能的。用for-in把所有可枚举的包括原型链上的一起遍历了。</p> 
 <p>用法</p> 
 <p>在用extend方法进行对象合并时，可以指定第一个参数为boolean类型，来决定是深拷贝(true)还是浅拷贝(false)，语法如下：</p> 
 <p>jQuery.extend(deep, target, object1 [,objectN])</p> 
 <p>or</p> 
 <p>jQuery.fn.extend(deep, target, object1 [,objectN])</p> 
 <p>实例：</p> 
 <p>var obj1 = {<!-- --></p> 
 <p>name: "John",</p> 
 <p>location: {<!-- --></p> 
 <p>city: "Boston",</p> 
 <p>county: "USA"</p> 
 <p>}</p> 
 <p>}</p> 
 <p>var obj2 = {<!-- --></p> 
 <p>last: "Resig",</p> 
 <p>location: {<!-- --></p> 
 <p>state: "MA",</p> 
 <p>county: "China"</p> 
 <p>}</p> 
 <p>}</p> 
 <p>$.extend(false, {}, obj1, obj2); // { name: "John", last: "Resig", location: { state: "MA", county: "China" }}</p> 
 <p>$.extend(true, {}, obj1, obj2); // { name: "John", last: "Resig", location: { city: "Boston", state: "MA", county: "China" }}</p> 
 <p>由此可见，执行 深度复制 会递归遍历每个对象中含有复杂对象(如：数组、函数、json对象等)的属性值进行复制，而且 浅度复制 便不会这么做。</p> 
 <p>jQuery插件开发</p> 
 <p>jQuery插件开发分为两种：1 类级别、2 对象级别</p> 
 <p>类级别(类方法)：是直接可以使用类引用，不需要实例化就可以使用的方法。一般在项目中 类方法 都是被设置为工具类使用；</p> 
 <p>对象级别(实例方法)必须先创建实例，然后才能通过实例调用该 实例方法</p> 
 <p>jQuery可以看做是这个封装得非常好的类，而我们可以使用jQuery选择器来创建 jQuery 的实例。比如：使 id 选择器$('#btn')来创建一个实例。</p> 
 <p>类级别 $.extend(src)</p> 
 <p>类级别你可以理解为拓展jQuery类，最明显的例子是$.ajax(...)，相当于静态方法，开发扩展其方法时使用$.extend方法</p> 
 <p>实例1：</p> 
 <p>$.extend({<!-- --></p> 
 <p>add:function(a,b){return a+b;}</p> 
 <p>minus:function(a,b){return a-b;}</p> 
 <p>});</p> 
 <p>调用方式</p> 
 <p>var i = $.add(3,2);</p> 
 <p>var j = $.minus(3,2);</p> 
 <p>对象级别 $.fn.extend(src)</p> 
 <p>对象级别则可以理解为基于对象的拓展，如$("#table").set(...); 这里这个set呢，就是基于对象的拓展了。开发扩展其方法时使用$.fn.extend方法，</p> 
 <p>$.fn.extend({<!-- --></p> 
 <p>check:function(){<!-- --></p> 
 <p>return this.each({<!-- --></p> 
 <p>this.checked=true;</p> 
 <p>});</p> 
 <p>},</p> 
 <p>uncheck:function(){<!-- --></p> 
 <p>return this.each({<!-- --></p> 
 <p>this.checked=false;</p> 
 <p>});</p> 
 <p>}</p> 
 <p>});</p> 
 <p>调用方式</p> 
 <p>$('input[type=checkbox]').check();</p> 
 <p>$('input[type=checkbox]').uncheck();</p> 
 <p>类似于命名空间的扩展</p> 
 <p>$.xy = {<!-- --></p> 
 <p>add:function(a,b){<!-- --></p> 
 <p>return a+b;</p> 
 <p>} ,</p> 
 <p>minus:function(a,b){<!-- --></p> 
 <p>return a-b;</p> 
 <p>},</p> 
 <p>voidMethod:function(){<!-- --></p> 
 <p>alert("void");</p> 
 <p>}</p> 
 <p>};</p> 
 <p>调用方式</p> 
 <p>var i = $.xy.add(3,2);</p> 
 <p>var m = $.xy.minus(3,2);</p> 
 <p>$.xy.voidMethod();</p> 
 <p>用法</p> 
 <p>如果只有一个参数对象提供给$.extend()，这意味着目标参数被省略。在这种情况下，调用extend方法的对象被默认为目标对象，参数对象中的内容将合并到目标对象中去。语法如下：</p> 
 <p>jQuery.extend(object)</p> 
 <p>or</p> 
 <p>jQuery.fn.extend(object)</p> 
 <p>1.$.extend(src)</p> 
 <p>该方法就是将src合并到jquery的全局对象中去，如：</p> 
 <p>$.extend({<!-- --></p> 
 <p>hello:function(){alert('hello');}</p> 
 <p>});</p> 
 <p>就是将hello方法合并到jquery的全局对象中。</p> 
 <p>2.$.fn.extend(src)</p> 
 <p>该方法将src合并到jquery的实例对象中去，如:</p> 
 <p>$.fn.extend({<!-- --></p> 
 <p>hello:function(){alert('hello');}</p> 
 <p>});</p> 
 <p>就是将hello方法合并到jquery的实例对象中。</p> 
 <p>三、源码解读</p> 
 <p>// 为与源码的下标对应上，我们把第一个参数称为`第0个参数`，依次类推</p> 
 <p>jQuery.extend = jQuery.fn.extend = function() {<!-- --></p> 
 <p>var options, name, src, copy, copyIsArray, clone,</p> 
 <p>target = arguments[0] || {}, // 默认第0个参数为目标参数</p> 
 <p>i = 1, // i表示从第几个参数凯斯想目标参数进行合并，默认从第1个参数开始向第0个参数进行合并</p> 
 <p>length = arguments.length,</p> 
 <p>deep = false; // 默认为浅度拷贝</p> 
 <p>// 判断第0个参数的类型，若第0个参数是boolean类型，则获取其为true还是false</p> 
 <p>// 同时将第1个参数作为目标参数，i从当前目标参数的下一个</p> 
 <p>// Handle a deep copy situation</p> 
 <p>if ( typeof target === "boolean" ) {<!-- --></p> 
 <p>deep = target;</p> 
 <p>// Skip the boolean and the target</p> 
 <p>target = arguments[ i ] || {};</p> 
 <p>i++;</p> 
 <p>}</p> 
 <p>// 判断目标参数的类型，若目标参数既不是object类型，也不是function类型，则为目标参数重新赋值</p> 
 <p>// Handle case when target is a string or something (possible in deep copy)</p> 
 <p>if ( typeof target !== "object" &amp;&amp; !jQuery.isFunction(target) ) {<!-- --></p> 
 <p>target = {};</p> 
 <p>}</p> 
 <p>// 若目标参数后面没有参数了，如$.extend({_name:'wenzi'}), $.extend(true, {_name:'wenzi'})</p> 
 <p>// 则目标参数即为jQuery本身，而target表示的参数不再为目标参数</p> 
 <p>// Extend jQuery itself if only one argument is passed</p> 
 <p>if ( i === length ) {<!-- --></p> 
 <p>target = this;</p> 
 <p>i--;</p> 
 <p>}</p> 
 <p>// 从第i个参数开始</p> 
 <p>for ( ; i &lt; length; i++ ) {<!-- --></p> 
 <p>// 获取第i个参数，且该参数不为null，</p> 
 <p>// 比如$.extend(target, {}, null);中的第2个参数null是不参与合并的</p> 
 <p>// Only deal with non-null/undefined values</p> 
 <p>if ( (options = arguments[ i ]) != null ) {<!-- --></p> 
 <p>// 使用for~in获取该参数中所有的字段</p> 
 <p>// Extend the base object</p> 
 <p>for ( name in options ) {<!-- --></p> 
 <p>src = target[ name ]; // 目标参数中name字段的值</p> 
 <p>copy = options[ name ]; // 当前参数中name字段的值</p> 
 <p>// 若参数中字段的值就是目标参数，停止赋值，进行下一个字段的赋值</p> 
 <p>// 这是为了防止无限的循环嵌套，我们把这个称为，在下面进行比较详细的讲解</p> 
 <p>// Prevent never-ending loop</p> 
 <p>if ( target === copy ) {<!-- --></p> 
 <p>continue;</p> 
 <p>}</p> 
 <p>// 若deep为true，且当前参数中name字段的值存在且为object类型或Array类型，则进行深度赋值</p> 
 <p>// Recurse if we're merging plain objects or arrays</p> 
 <p>if ( deep &amp;&amp; copy &amp;&amp; ( jQuery.isPlainObject(copy) || (copyIsArray = jQuery.isArray(copy)) ) ) {<!-- --></p> 
 <p>// 若当前参数中name字段的值为Array类型</p> 
 <p>// 判断目标参数中name字段的值是否存在，若存在则使用原来的，否则进行初始化</p> 
 <p>if ( copyIsArray ) {<!-- --></p> 
 <p>copyIsArray = false;</p> 
 <p>clone = src &amp;&amp; jQuery.isArray(src) ? src : [];</p> 
 <p>} else {<!-- --></p> 
 <p>// 若原对象存在，则直接进行使用，而不是创建</p> 
 <p>clone = src &amp;&amp; jQuery.isPlainObject(src) ? src : {};</p> 
 <p>}</p> 
 <p>// 递归处理，此处为2.2</p> 
 <p>// Never move original objects, clone them</p> 
 <p>target[ name ] = jQuery.extend( deep, clone, copy );</p> 
 <p>// deep为false，则表示浅度拷贝，直接进行赋值</p> 
 <p>// 若copy是简单的类型且存在值，则直接进行赋值</p> 
 <p>// Don't bring in undefined values</p> 
 <p>} else if ( copy !== undefined ) {<!-- --></p> 
 <p>// 若原对象存在name属性，则直接覆盖掉；若不存在，则创建新的属性</p> 
 <p>target[ name ] = copy;</p> 
 <p>}</p> 
 <p>}</p> 
 <p>}</p> 
 <p>}</p> 
 <p>// 返回修改后的目标参数</p> 
 <p>// Return the modified object</p> 
 <p>return target;</p> 
 <p>};</p> 
 <p>若参数中字段的值就是目标参数，停止赋值</p> 
 <p>在源码中进行了一下这样的判断：</p> 
 <p>// Prevent never-ending loop</p> 
 <p>if ( target === copy ) {<!-- --></p> 
 <p>continue;</p> 
 <p>}</p> 
 <p>为什么要有这样的判断，我们来看一个简单的例子，如果没有这个判断会怎么样：</p> 
 <p>var _default = {name : 'wenzi'};</p> 
 <p>var obj = {name : _default}</p> 
 <p>$.extend(_default, obj);</p> 
 <p>console.log(_default);</p> 
 <p>输出的_default是什么：</p> 
 <p>_default = {name : _default};</p> 
 <p>_default是object类型，里面有个字段name，值是_default，而_default是object类型，里面有个字段name，值是_default......，无限的循环下去。于是jQuery中直接不进行操作，跳过这个字段，进行下一个字段的操作。</p> 
 <p>深度拷贝时进行递归处理</p> 
 <p>变量值为简单类型(基元类型，如number, string, boolean)进行赋值时是不会影响上一个变量的值的，因此，如果当前字段的值为Object或Array类型，需要对其进行拆分，直到字段的值为简单类型(如number, string, boolean)时才进行赋值操作。</p> 
 <p>$.extend()与$.fn.extend()</p> 
 <p>jQuery.extend = jQuery.fn.extend = function(){}</p> 
 <p>也就是说$.extend()与$.fn.extend()共用的是同一个函数体，所有的操作都是一样的，只不过两个extend使用的对象不同罢了：$.extend()是在jQuery($)上进行操作的；而$.fn.extend()是在jQuery对象上进行操作的，如$('div').extend().</p> 
 <p>四、另一种实现方式</p> 
 <p>版本1：</p> 
 <p>void function(global){<!-- --></p> 
 <p>var extend,</p> 
 <p>_extend,</p> 
 <p>_isObject;</p> 
 <p>_isObject = function(o){<!-- --></p> 
 <p>return Object.prototype.toString.call(o) === '[object Object]';</p> 
 <p>}</p> 
 <p>_extend = function self(destination, source){<!-- --></p> 
 <p>for (var property in source) {<!-- --></p> 
 <p>if (source.hasOwnProperty(property)) {<!-- --></p> 
 <p>// 若sourc[property]是对象，则递归</p> 
 <p>if (_isObject(source[property])) {<!-- --></p> 
 <p>// 若destination没有property，赋值空对象</p> 
 <p>if (!destination.hasOwnProperty(property)) {<!-- --></p> 
 <p>destination[property] = {};</p> 
 <p>};</p> 
 <p>// 对destination[property]不是对象，赋值空对象</p> 
 <p>if (!_isObject(destination[property])) {<!-- --></p> 
 <p>destination[property] = {};</p> 
 <p>};</p> 
 <p>// 递归</p> 
 <p>self(destination[property], source[property]);</p> 
 <p>} else {<!-- --></p> 
 <p>destination[property] = source[property];</p> 
 <p>};</p> 
 <p>}</p> 
 <p>}</p> 
 <p>}</p> 
 <p>extend = function(){<!-- --></p> 
 <p>var arr = arguments,</p> 
 <p>result = {},</p> 
 <p>i;</p> 
 <p>if (!arr.length) return {};</p> 
 <p>for (i = 0; i &lt; arr.length; i++) {<!-- --></p> 
 <p>if (_isObject(arr[i])) {<!-- --></p> 
 <p>_extend(result, arr[i])</p> 
 <p>};</p> 
 <p>}</p> 
 <p>arr[0] = result;</p> 
 <p>return result;</p> 
 <p>}</p> 
 <p>global.extend = extend;</p> 
 <p>}(window)</p> 
 <p>版本1存在的问题：我们这里是按照参数顺序从左到右依次执行的，但是其实若是最后一个参数有的属性，前面的参数上的该属性都不需要再扩展了。其实前面的所有参数都是将自己身上有的属性而最后一个参数没有的属性补到最后一个参数上。既如此，是不是从参数列表的右侧开始扩展更好一些。</p> 
 <p>版本2：</p> 
 <p>void function(global){<!-- --></p> 
 <p>var extend,</p> 
 <p>_extend,</p> 
 <p>_isObject;</p> 
 <p>_isObject = function(o){<!-- --></p> 
 <p>return Object.prototype.toString.call(o) === '[object Object]';</p> 
 <p>}</p> 
 <p>_extend = function self(destination, source) {<!-- --></p> 
 <p>var property;</p> 
 <p>for (property in destination) {<!-- --></p> 
 <p>if (destination.hasOwnProperty(property)) {<!-- --></p> 
 <p>// 若destination[property]和sourc[property]都是对象，则递归</p> 
 <p>if (_isObject(destination[property]) &amp;&amp; _isObject(source[property])) {<!-- --></p> 
 <p>self(destination[property], source[property]);</p> 
 <p>};</p> 
 <p>// 若sourc[property]已存在，则跳过</p> 
 <p>if (source.hasOwnProperty(property)) {<!-- --></p> 
 <p>continue;</p> 
 <p>} else {<!-- --></p> 
 <p>source[property] = destination[property];</p> 
 <p>}</p> 
 <p>}</p> 
 <p>}</p> 
 <p>}</p> 
 <p>extend = function(){<!-- --></p> 
 <p>var arr = arguments,</p> 
 <p>result = {},</p> 
 <p>i;</p> 
 <p>if (!arr.length) return {};</p> 
 <p>for (i = arr.length - 1; i &gt;= 0; i--) {<!-- --></p> 
 <p>if (_isObject(arr[i])) {<!-- --></p> 
 <p>_extend(arr[i], result);</p> 
 <p>};</p> 
 <p>}</p> 
 <p>arr[0] = result;</p> 
 <p>return result;</p> 
 <p>}</p> 
 <p>global.extend = extend;</p> 
 <p>}(window)</p> 
 <p>五、参考</p> 
</div>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/cd0eb98cfa672a9200141fc2d71fd131/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">c语言 1累乘至100,C语言1乘到100怎么编写</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/7e23a597283b42dae75d72dca6b1d67a/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">计算机网络:自顶向下方法 第五章编程作业-DV算法</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>