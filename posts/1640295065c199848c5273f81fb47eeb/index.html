<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>【Linux--多线程】 - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="【Linux--多线程】" />
<meta property="og:description" content="目录 前言一、线程的基本概念1.1什么是线程1.2线程的特点1.2.1线程的优点1.2.2线程的缺点1.2.3线程异常1.2.4线程用途 1.3进程与线程的区别 二、Linux线程控制2.1线程创建2.2线程等待2.3线程终止2.3.1return退出2.3.2 pthread_exit()2.3.3 pthread_cancel()2.3.4 pthread_detach()2.4线程ID与进程地址空间布局 前言 重谈地址空间–页表
一、线程的基本概念 1.1什么是线程 线程是进程内的一个执行分支，一个进程内有多行代码，线程通常情况下只执行这多行代码的部分代码。更准确的定义是：线程是“一个进程内部的控制序列”。
一个进程内至少有一个执行线程
线程在进程内部运行，本质是在进程地址空间内运行
在Linux系统中，在CPU眼中，看到的PCB都要比传统的进程更加轻量化
透过进程虚拟地址空间，可以看到进程的大部分资源，将进程资源合理分配给每个执行流，就形成了线程执行流
操作系统中存在大量的进程，一个进程中又存在一个或多个线程，因此线程的数量一定比进程的数量多，很明显线程的执行粒度要比进程更细。
若一款操作系统要真正意义上支持线程，那么就需要对线程进行管理。比如创建线程、终止线程、调度线程、切换线程、给线程分配资源、释放资源以及回收资源等等，所有的这一套相比较进程都需要另起炉灶，搭建一套线程管理模块。
因此，若要支持真的线程一定会提高设计操作系统的复杂程度。在Linux看来，描述线程的控制块和描述进程的控制块是类似的，因此Linux并没有重新为线程设计管理模块，而是直接复用了进程控制块，即Linux中的所有执行流都是轻量级进程
但也有支持真正线程的操作系统，譬如Windows操作系统就存在专门描述线程的控制块，因此Windows操作系统系统的实现逻辑一定比Linux操作系统更为复杂
1.2线程的特点 1.2.1线程的优点 与进程切换相比，线程之间切换需要操作系统做的工作要少很多（cpu中有一个叫cache的寄存器，这个寄存器还是比较大的，里面缓存着热数据，这个热数据可以理解为高度频繁使用的数据，线程切换不需要重新加载热数据，而进程切换需要重新加载热数据）。创建一个新线程的代价要比创建一个新进程小得多线程占用的资源要比进程少很多能充分利用多处理器的可并行数量计算密集型应用，为了能在多处理器系统上运行，将计算分解到多个线程中实现I/O密集型应用，为了提高性能，将I/O操作重叠。线程可以同时等待不同的I/O操作。 概念说明：
计算密集型(CPU密集型)：执行流的大部分任务，主要以计算为主。如加密解密、大数据查找等
IO密集型：执行流的大部分任务，主要以IO为主。如刷盘、访问数据库、访问网络等
1.2.2线程的缺点 编程难度高：编写与调式一个多线程程序比较困难缺乏访问控制：在一个线程中调用某些OS函数会对整个进程造成影响。健壮性降低：编写多线程需要更全面更深入的考虑，在一个多线程程序里，因时间分配上的细微偏差或者因共享了不该共享的变量而造成不良影响的可能性是很大的，即线程之间是缺乏保护的，此外一个线程崩溃会导致整个进程崩溃性能损失：一个很少被外部事件阻塞的计算密集型线程往往无法与其他线程共享同一个处理器。若计算密集型线程的数量比可用的处理器多，那么可能会有较大的性能损失（即增加了额外的同步和调度开销，而可用的资源不变） 1.2.3线程异常 单个线程如果出现除零、野指针等问题导致线程崩溃，进程也会随着崩溃线程是进程的执行分支，线程出异常，就类似进程出异常，进而触发信号机制，终止进程，进程终止，该进程内的所有线程也就随即退出 1.2.4线程用途 合理的使用多线程，能提高CPU密集型程序的执行效率合理的使用多线程，能提高IO密集型程序的用户体验（如生活中我们一边写代码一边下载开发工具，就是多线程运行的一种表现） 1.3进程与线程的区别 线程共享进程数据，但是也拥有自己的一部分数据：
栈、线程ID、一组寄存器（用来恢复上下文）、errno、信号屏蔽字、调度优先级
进程的多个线程共享同一块地址空间，如果定义一个函数、全局变量各个线程都可以访问，各线程还共享以下资源：
文件描述符、每一个信号的处理方式、当前工作目录、用户id和组id
二、Linux线程控制 在Linux中，站在内核角度上看并没有真正意义上线程相关的接口。但站在用户角度，当用户想创建一个线程时更期望使用thread_create这样类似的接口，而不是vfork函数，因此系统在应用层提供了原生线程库pthread。原生线程库实际就是对轻量级进程的系统调用进行了封装，在用户层模拟实现了一套线程相关的接口
用层指的是这个线程库并不是操作系统直接提供的，而是由第三方使用系统接口编写的原生指的是大部分Linux系统都会默认带上该线程库与线程有关的函数构成了一个完整的系列，绝大多数函数的名字都是以&#34;pthread_&#34;开头要使用pthread库，要引入头文件&lt;pthreaad.h&gt;链接pthread库时，要在编译时要使用&#34;-lpthread&#34;选项 2.1线程创建 int pthread_create(pthread_t *thread, const pthread_attr_t *attr, void *(*start_routine) (void *), void *arg); 参数：
thread：获取创建成功的线程标识符，该参数是一个输出型参数attr：用于设置创建线程的属性，传入NULL表示使用默认属性start_routine：该参数是一个函数地址，表示线程例程，即线程启动后要执行的函数arg：传给线程例程的参数（即传给start_routine的形参） 返回值： 线程创建成功返回0，失败返回错误码
使用案例
#include&lt;iostream&gt; using namespace std; #include&lt;pthread.h&gt; #include&lt;unistd.h&gt; void* Rountine(void* args) { while(1) { cout&lt;&lt;&#34;" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/1640295065c199848c5273f81fb47eeb/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-12-26T19:06:34+08:00" />
<meta property="article:modified_time" content="2023-12-26T19:06:34+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">【Linux--多线程】</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p></p> 
<div class="toc"> 
 <h4>目录</h4> 
 <ul><li><a href="#_1" rel="nofollow">前言</a></li><li><a href="#_4" rel="nofollow">一、线程的基本概念</a></li><li><ul><li><a href="#11_5" rel="nofollow">1.1什么是线程</a></li><li><a href="#12_20" rel="nofollow">1.2线程的特点</a></li><li><ul><li><a href="#121_21" rel="nofollow">1.2.1线程的优点</a></li><li><a href="#122_35" rel="nofollow">1.2.2线程的缺点</a></li><li><a href="#123_42" rel="nofollow">1.2.3线程异常</a></li><li><a href="#124_47" rel="nofollow">1.2.4线程用途</a></li></ul> 
   </li><li><a href="#13_51" rel="nofollow">1.3进程与线程的区别</a></li></ul> 
  </li><li><a href="#Linux_56" rel="nofollow">二、Linux线程控制</a></li><li><ul><li><a href="#21_63" rel="nofollow">2.1线程创建</a></li><li><a href="#22_107" rel="nofollow">2.2线程等待</a></li><li><a href="#23_169" rel="nofollow">2.3线程终止</a></li><li><ul><li><a href="#231return_170" rel="nofollow">2.3.1return退出</a></li><li><a href="#232_pthread_exit_172" rel="nofollow">2.3.2 pthread_exit()</a></li><li><a href="#233_pthread_cancel_182" rel="nofollow">2.3.3 pthread_cancel()</a></li><li><a href="#234_pthread_detach_193" rel="nofollow">2.3.4 pthread_detach()</a></li><li><a href="#24ID_207" rel="nofollow">2.4线程ID与进程地址空间布局</a></li></ul> 
  </li></ul> 
 </li></ul> 
</div> 
<p></p> 
<h2><a id="_1"></a>前言</h2> 
<p><strong>重谈地址空间–页表</strong><br> <img src="https://images2.imgbox.com/d0/c4/hnJEqCF6_o.png" alt="在这里插入图片描述"></p> 
<h2><a id="_4"></a>一、线程的基本概念</h2> 
<h3><a id="11_5"></a>1.1什么是线程</h3> 
<p>线程是进程内的一个执行分支，一个进程内有多行代码，线程通常情况下只执行这多行代码的部分代码。更准确的定义是：线程是“一个进程内部的控制序列”。<br> 一个进程内至少有一个执行线程<br> 线程在进程内部运行，本质是在进程地址空间内运行<br> 在Linux系统中，在CPU眼中，看到的PCB都要比传统的进程更加轻量化<br> 透过进程虚拟地址空间，可以看到进程的大部分资源，将进程资源合理分配给每个执行流，就形成了线程执行流<br> <img src="https://images2.imgbox.com/1c/07/Q8oS3Nsr_o.png" alt="在这里插入图片描述"><br> 操作系统中存在大量的进程，一个进程中又存在一个或多个线程，因此线程的数量一定比进程的数量多，很明显线程的执行粒度要比进程更细。</p> 
<p>若一款操作系统要真正意义上支持线程，那么就需要对线程进行管理。比如创建线程、终止线程、调度线程、切换线程、给线程分配资源、释放资源以及回收资源等等，所有的这一套相比较进程都需要另起炉灶，搭建一套线程管理模块。</p> 
<p>因此，若要支持真的线程一定会提高设计操作系统的复杂程度。在Linux看来，描述线程的控制块和描述进程的控制块是类似的，因此Linux并没有重新为线程设计管理模块，而是直接复用了进程控制块，即Linux中的所有执行流都是轻量级进程</p> 
<p>但也有支持真正线程的操作系统，譬如Windows操作系统就存在专门描述线程的控制块，因此Windows操作系统系统的实现逻辑一定比Linux操作系统更为复杂</p> 
<h3><a id="12_20"></a>1.2线程的特点</h3> 
<h4><a id="121_21"></a>1.2.1线程的优点</h4> 
<ol><li>与进程切换相比，线程之间切换需要操作系统做的工作要少很多（cpu中有一个叫cache的寄存器，这个寄存器还是比较大的，里面缓存着热数据，这个热数据可以理解为高度频繁使用的数据，线程切换不需要重新加载热数据，而进程切换需要重新加载热数据）。</li><li>创建一个新线程的代价要比创建一个新进程小得多</li><li>线程占用的资源要比进程少很多</li><li>能充分利用多处理器的可并行数量</li><li>计算密集型应用，为了能在多处理器系统上运行，将计算分解到多个线程中实现</li><li>I/O密集型应用，为了提高性能，将I/O操作重叠。线程可以同时等待不同的I/O操作。</li></ol> 
<blockquote> 
 <p>概念说明：</p> 
 <p>计算密集型(CPU密集型)：执行流的大部分任务，主要以计算为主。如加密解密、大数据查找等<br> IO密集型：执行流的大部分任务，主要以IO为主。如刷盘、访问数据库、访问网络等</p> 
</blockquote> 
<h4><a id="122_35"></a>1.2.2线程的缺点</h4> 
<ol><li>编程难度高：编写与调式一个多线程程序比较困难</li><li>缺乏访问控制：在一个线程中调用某些OS函数会对整个进程造成影响。</li><li>健壮性降低：编写多线程需要更全面更深入的考虑，在一个多线程程序里，因时间分配上的细微偏差或者因共享了不该共享的变量而造成不良影响的可能性是很大的，即线程之间是缺乏保护的，此外一个线程崩溃会导致整个进程崩溃</li><li>性能损失：一个很少被外部事件阻塞的计算密集型线程往往无法与其他线程共享同一个处理器。若计算密集型线程的数量比可用的处理器多，那么可能会有较大的性能损失（即增加了额外的同步和调度开销，而可用的资源不变）</li></ol> 
<h4><a id="123_42"></a>1.2.3线程异常</h4> 
<ul><li>单个线程如果出现除零、野指针等问题导致线程崩溃，进程也会随着崩溃</li><li>线程是进程的执行分支，线程出异常，就类似进程出异常，进而触发信号机制，终止进程，进程终止，该进程内的所有线程也就随即退出</li></ul> 
<h4><a id="124_47"></a>1.2.4线程用途</h4> 
<ul><li>合理的使用多线程，能提高CPU密集型程序的执行效率</li><li>合理的使用多线程，能提高IO密集型程序的用户体验（如生活中我们一边写代码一边下载开发工具，就是多线程运行的一种表现）</li></ul> 
<h3><a id="13_51"></a>1.3进程与线程的区别</h3> 
<p>线程共享进程数据，但是也拥有自己的一部分数据：<br> 栈、线程ID、一组寄存器（用来恢复上下文）、errno、信号屏蔽字、调度优先级<br> 进程的多个线程共享同一块地址空间，如果定义一个函数、全局变量各个线程都可以访问，各线程还共享以下资源：<br> 文件描述符、每一个信号的处理方式、当前工作目录、用户id和组id</p> 
<h2><a id="Linux_56"></a>二、Linux线程控制</h2> 
<p>在Linux中，站在内核角度上看并没有真正意义上线程相关的接口。但站在用户角度，当用户想创建一个线程时更期望使用thread_create这样类似的接口，而不是vfork函数，因此系统在应用层提供了原生线程库pthread。原生线程库实际就是对轻量级进程的系统调用进行了封装，在用户层模拟实现了一套线程相关的接口</p> 
<ul><li>用层指的是这个线程库并不是操作系统直接提供的，而是由第三方使用系统接口编写的</li><li>原生指的是大部分Linux系统都会默认带上该线程库</li><li>与线程有关的函数构成了一个完整的系列，绝大多数函数的名字都是以"pthread_"开头</li><li>要使用pthread库，要引入头文件&lt;pthreaad.h&gt;</li><li>链接pthread库时，要在编译时要使用"-lpthread"选项</li></ul> 
<h3><a id="21_63"></a>2.1线程创建</h3> 
<pre><code class="prism language-cpp"><span class="token keyword">int</span> <span class="token function">pthread_create</span><span class="token punctuation">(</span>pthread_t <span class="token operator">*</span>thread<span class="token punctuation">,</span> <span class="token keyword">const</span> pthread_attr_t <span class="token operator">*</span>attr<span class="token punctuation">,</span> <span class="token keyword">void</span> <span class="token operator">*</span><span class="token punctuation">(</span><span class="token operator">*</span>start_routine<span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token keyword">void</span> <span class="token operator">*</span>arg<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> 
<p><strong>参数：</strong></p> 
<ul><li>thread：获取创建成功的线程标识符，该参数是一个输出型参数</li><li>attr：用于设置创建线程的属性，传入NULL表示使用默认属性</li><li>start_routine：该参数是一个函数地址，表示线程例程，即线程启动后要执行的函数</li><li>arg：传给线程例程的参数（即传给start_routine的形参） <strong>返回值：</strong></li></ul> 
<p>线程创建成功返回0，失败返回错误码</p> 
<p><strong>使用案例</strong></p> 
<pre><code class="prism language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;iostream&gt;</span></span>
<span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;pthread.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;unistd.h&gt;</span></span>
<span class="token keyword">void</span><span class="token operator">*</span> <span class="token function">Rountine</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token operator">*</span> args<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
    <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>
    <span class="token punctuation">{<!-- --></span>
        cout<span class="token operator">&lt;&lt;</span><span class="token string">"i am"</span><span class="token operator">&lt;&lt;</span><span class="token punctuation">(</span><span class="token keyword">char</span><span class="token operator">*</span><span class="token punctuation">)</span>args<span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span>
        <span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
    pthread_t tid<span class="token punctuation">;</span>
    <span class="token function">pthread_create</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>tid<span class="token punctuation">,</span><span class="token keyword">nullptr</span><span class="token punctuation">,</span>Rountine<span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token string">"thread one"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>
    <span class="token punctuation">{<!-- --></span>
        cout<span class="token operator">&lt;&lt;</span><span class="token string">"i am main thread"</span><span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span>
        <span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>使用 ps -aL 命令，可以显示当前的轻量级进程，不带 -L 选项默认显示进程<br> <img src="https://images2.imgbox.com/c1/31/Xm3wVSIE_o.png" alt="在这里插入图片描述"><br> LWP（Light Weight Process）就是轻量级进程的ID，可以看到显示的两个轻量级进程的PID是相同的，因为它们属于同一个进程</p> 
<h3><a id="22_107"></a>2.2线程等待</h3> 
<p>线程如同进程一般，也是需要被等待的。若主线程不对新线程进行等待，那么新线程的资源不会被回收，会发生类似于"僵尸进程"的问题，即内存泄漏。</p> 
<p>使用pthread_join()可以进行线程等待</p> 
<pre><code class="prism language-cpp"><span class="token keyword">int</span> <span class="token function">pthread_join</span><span class="token punctuation">(</span>pthread_t thread<span class="token punctuation">,</span> <span class="token keyword">void</span> <span class="token operator">*</span><span class="token operator">*</span>retval<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> 
<p><strong>参数：</strong></p> 
<ul><li>thread：被等待线程的标识符</li><li>retval：线程退出时的退出码信息</li></ul> 
<p><strong>返回值：</strong></p> 
<ul><li>线程等待成功返回0，失败返回错误码</li></ul> 
<p>调用该函数的线程将阻塞到ID为thread的线程终止。thread线程以不同的方法终止，通过pthread_join得到的终止状态是不同的</p> 
<ul><li>若thread线程通过return返回，retval所指向的单元里存放的是线程的返回值</li><li>若thread线程被别的线程调用pthread_cancel()异常终止掉，retval所指向的单元里存放的是宏PTHREAD_CANCELED，即(void*)-1)</li><li>若thread线程是自行调用pthread_exit()终止的，retval所指向的单元存放的是传给pthread_exit的参数</li><li>若对thread线程的终止状态不感兴趣，可传NULL给retval参数<br> <strong>使用案例：</strong></li></ul> 
<pre><code class="prism language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;iostream&gt;</span></span>
<span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;pthread.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;unistd.h&gt;</span></span>
<span class="token keyword">void</span><span class="token operator">*</span> <span class="token function">Rountine</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token operator">*</span> args<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
    <span class="token keyword">int</span> cnt<span class="token operator">=</span><span class="token number">10</span><span class="token punctuation">;</span>
    <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>
    <span class="token punctuation">{<!-- --></span>
        cnt<span class="token operator">--</span><span class="token punctuation">;</span>
        <span class="token keyword">if</span><span class="token punctuation">(</span>cnt<span class="token operator">==</span><span class="token number">0</span><span class="token punctuation">)</span>  <span class="token keyword">break</span><span class="token punctuation">;</span>
        cout<span class="token operator">&lt;&lt;</span><span class="token string">"i am"</span><span class="token operator">&lt;&lt;</span> <span class="token punctuation">(</span><span class="token keyword">char</span><span class="token operator">*</span><span class="token punctuation">)</span>args<span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span>
        <span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token keyword">void</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token number">13</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
    pthread_t tid<span class="token punctuation">;</span>
    <span class="token function">pthread_create</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>tid<span class="token punctuation">,</span><span class="token keyword">nullptr</span><span class="token punctuation">,</span>Rountine<span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token string">"thread one"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// while(1)</span>
    <span class="token comment">// {<!-- --></span>
    <span class="token comment">//     cout&lt;&lt;"i am main thread"&lt;&lt;endl;</span>
    <span class="token comment">//     sleep(1);</span>
    <span class="token comment">// }</span>
    <span class="token keyword">void</span><span class="token operator">*</span> ret<span class="token operator">=</span><span class="token keyword">nullptr</span><span class="token punctuation">;</span>
    <span class="token keyword">int</span> n<span class="token operator">=</span><span class="token function">pthread_join</span><span class="token punctuation">(</span>tid<span class="token punctuation">,</span><span class="token operator">&amp;</span>ret<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span><span class="token punctuation">(</span>n<span class="token operator">==</span><span class="token number">0</span><span class="token punctuation">)</span>
    <span class="token punctuation">{<!-- --></span>
        cout<span class="token operator">&lt;&lt;</span><span class="token string">"线程等待成功"</span><span class="token operator">&lt;&lt;</span><span class="token string">"返回结果为"</span><span class="token operator">&lt;&lt;</span><span class="token punctuation">(</span><span class="token keyword">long</span> <span class="token keyword">long</span><span class="token punctuation">)</span>ret<span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">else</span>    cout<span class="token operator">&lt;&lt;</span><span class="token string">"等待失败"</span><span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p><img src="https://images2.imgbox.com/1d/01/mkhNLiQD_o.png" alt="在这里插入图片描述"><br> 这里我一开始是比较疑惑为什么是void<em>类型。其实是这样想要得到输出参数的参数类型可能为int、double、自定义类型，所以用的是void</em>类型。</p> 
<h3><a id="23_169"></a>2.3线程终止</h3> 
<h4><a id="231return_170"></a>2.3.1return退出</h4> 
<p>在创建线程时指定的例程中使用return代表当前线程退出，但在main函数中使用return代表整个进程退出，即主线程退出了那么整个进程就退出了。</p> 
<h4><a id="232_pthread_exit_172"></a>2.3.2 pthread_exit()</h4> 
<pre><code class="prism language-cpp"><span class="token keyword">void</span> <span class="token function">pthread_exit</span><span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token operator">*</span>retval<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> 
<p><strong>参数retval</strong>：线程退出时的退出信息</p> 
<p>注意：</p> 
<ul><li>pthread_exit()或者return返回的指针所指向的内存单元必须是全局的或者堆区开辟的，不能在线程函数的栈上分配，因为当其他线程得到这个返回指针时，线程已经退出了</li><li>线程退出不能使用exit()函数，其作用是退出整个进程，任何一个线程调用都是如此</li></ul> 
<h4><a id="233_pthread_cancel_182"></a>2.3.3 pthread_cancel()</h4> 
<pre><code class="prism language-cpp"><span class="token keyword">int</span> <span class="token function">pthread_cancel</span><span class="token punctuation">(</span>pthread_t thread<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> 
<p>参数thread：被取消线程的标识符</p> 
<p>返回值：线程取消成功返回0，失败返回错误码</p> 
<p>线程是可以取消自己的（使用pthread_self()函数）。也可以让新线程取消主线程，但不建议这么使用，一般都是使用主线程去控制新线程的。</p> 
<p>取消成功的线程的退出码一般是宏PTHREAD_CANCELED，即(void*)-1)</p> 
<h4><a id="234_pthread_detach_193"></a>2.3.4 pthread_detach()</h4> 
<p>默认情况下，新创建的线程是joinable的，线程退出后，需要对其进行pthread_join操作，否则无法释放资源，从而造成内存泄漏。但若本身并不关心线程的返回值，那么join也是一种负担，此时可将该线程进行分离，后续当线程退出时就会自动释放线程资源<br> 线程若被分离了，这个线程依旧使用该进程的资源，且依旧在该进程内运行，甚至这个线程崩溃了一定会影响整个进程，只不过这个线程退出时不再需要主线程去join了，当这个线程退出时系统会自动回收该线程所对应的资源<br> 可以是线程组内其他线程对目标线程进行分离，也可以是线程自己分离<br> joinable和分离是冲突的，一个线程不能既是joinable又是分离的<br> 使用pthread_detach()函数进程分离线程</p> 
<pre><code class="prism language-cpp"><span class="token keyword">int</span> <span class="token function">pthread_detach</span><span class="token punctuation">(</span>pthread_t thread<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> 
<p>参数thread：被分离线程的标识符</p> 
<p>返回值：线程分离成功返回0，失败返回错误码</p> 
<h4><a id="24ID_207"></a>2.4线程ID与进程地址空间布局</h4> 
<p>线程库NPTL提供的pthread_self()函数，获取的线程标识符和pthread_create()函数第一个参数获取的线程标识符是一样的<br> 线程ID到底是什么？可以将线程ID打印出来看看</p> 
<pre><code class="prism language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;iostream&gt;</span></span>
<span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;pthread.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;unistd.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;string&gt;</span></span>
string <span class="token function">ToHex</span><span class="token punctuation">(</span>pthread_t tid<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
    <span class="token keyword">char</span> buf<span class="token punctuation">[</span><span class="token number">1024</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token function">snprintf</span><span class="token punctuation">(</span>buf<span class="token punctuation">,</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>buf<span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token string">"%p"</span><span class="token punctuation">,</span>tid<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> buf<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">void</span><span class="token operator">*</span> <span class="token function">Rountine</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token operator">*</span> args<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
    <span class="token keyword">int</span> cnt<span class="token operator">=</span><span class="token number">10</span><span class="token punctuation">;</span>
    <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>
    <span class="token punctuation">{<!-- --></span>
        cout<span class="token operator">&lt;&lt;</span><span class="token punctuation">(</span><span class="token keyword">char</span><span class="token operator">*</span><span class="token punctuation">)</span>args<span class="token operator">&lt;&lt;</span><span class="token string">":"</span><span class="token operator">&lt;&lt;</span><span class="token function">ToHex</span><span class="token punctuation">(</span><span class="token function">pthread_self</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span>
        <span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token keyword">void</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token number">13</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
    pthread_t tid<span class="token punctuation">;</span>
    <span class="token function">pthread_create</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>tid<span class="token punctuation">,</span><span class="token keyword">nullptr</span><span class="token punctuation">,</span>Rountine<span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token string">"thread one"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>
    <span class="token punctuation">{<!-- --></span>
        cout<span class="token operator">&lt;&lt;</span><span class="token string">"main thread"</span><span class="token operator">&lt;&lt;</span><span class="token string">":"</span><span class="token operator">&lt;&lt;</span><span class="token function">ToHex</span><span class="token punctuation">(</span><span class="token function">pthread_self</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span>
        <span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">void</span><span class="token operator">*</span> ret<span class="token operator">=</span><span class="token keyword">nullptr</span><span class="token punctuation">;</span>
    <span class="token keyword">int</span> n<span class="token operator">=</span><span class="token function">pthread_join</span><span class="token punctuation">(</span>tid<span class="token punctuation">,</span><span class="token operator">&amp;</span>ret<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span><span class="token punctuation">(</span>n<span class="token operator">==</span><span class="token number">0</span><span class="token punctuation">)</span>
    <span class="token punctuation">{<!-- --></span>
        cout<span class="token operator">&lt;&lt;</span><span class="token string">"线程等待成功"</span><span class="token operator">&lt;&lt;</span><span class="token string">"返回结果为"</span><span class="token operator">&lt;&lt;</span><span class="token punctuation">(</span><span class="token keyword">long</span> <span class="token keyword">long</span><span class="token punctuation">)</span>ret<span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span>

    <span class="token punctuation">}</span>
    <span class="token keyword">else</span>    cout<span class="token operator">&lt;&lt;</span><span class="token string">"等待失败"</span><span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p><img src="https://images2.imgbox.com/e6/94/nMhE1qBz_o.png" alt="在这里插入图片描述"><br> 之前提到每个线程都有独占的栈，其中主线程采用的栈是进程地址空间中原生的栈，而其余线程采用的栈就是在共享区中开辟的。除此之外，每个线程都有各自的struct pthread，当中包含了对应线程的各种属性；每个线程还有自己的线程局部存储，当中包含了对应线程被切换时的上下文数据。</p> 
<p>每一个新线程在共享区都有一个struct pthread对其进行描述，因此要找到一个用户级线程只需要找到该线程内存块的起始地址，然后就可以获取到该线程的各种信息<br> <img src="https://images2.imgbox.com/de/42/V771o0mt_o.png" alt="在这里插入图片描述"><br> 上面讲述的各种线程函数，本质上都是在库内部对线程属性进行的各种操作，即线程数据的管理本质是在共享区的进行的</p> 
<p>至于pthread_t到底是什么类型取决于实现，但对于Linux目前实现的NPTL线程库来说，线程标识符本质就是进程地址空间共享区上的一个虚拟地址，同一个进程中所有的虚拟地址都是不同的，因此可以用它来唯一区分每一个线程</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/fcd427f788c50f3bf70102a51a252b14/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">Vue3的v-if 和v-for优先级</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/c6d32a0c7ddad2896b0f401070107c38/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">操作系统“文艺复兴”，云数智融合涌现“美第奇效应”</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>