<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>ROS笔记（5）——Bag包概述与解析 - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="ROS笔记（5）——Bag包概述与解析" />
<meta property="og:description" content="目录
ROS Bag概念与使用场景
ROS Bag文件生成的两种方式
ROS Bag文件的解析 （C&#43;&#43;实现）
1、rosbag::View
2、完整C&#43;&#43;代码示例
ROS Bag文件的解析 （Python实现）
C&#43;&#43;与Python 解析ROS Bag文件两种方式的对比
ROS Bag概念与使用场景 ROS Bag是一种文件格式，用于存储ROS系统中的消息。ROS Bag可以将ROS节点发布的消息记录下来，然后在需要的时候将这些消息再次播放回ROS系统中。
ROS Bag通常用于以下场景：
离线数据处理：在无法连接实时ROS系统时，可以使用ROS Bag记录消息，然后在离线状态下进行数据处理和算法开发。数据集收集：ROS Bag可以用于收集数据集，以用于机器学习和深度学习等应用。调试和测试：ROS Bag可以用于调试和测试ROS节点和程序的行为。 ROS Bag文件生成的两种方式 ROS Bag文件以 .bag 扩展名结尾，可以通过以下方法进行保存：
在终端中使用rosbag record命令来记录指定主题的消息，将消息保存到ROS Bag文件中。例如，以下命令将记录名为/scan的激光雷达数据并将其保存到名为scan.bag的文件中： rosbag record /scan -O scan.bag rosbag record 是一个用于记录 ROS 消息到 ROS Bag 文件中的命令行工具。它可以记录指定主题的消息，将消息保存到一个ROS Bag文件中。以下是 rosbag record 命令的常用参数：
-a, --all：记录所有主题。-O, --output-name：指定输出的 ROS Bag 文件名。-b, --buffer-size：设置ROS Bag文件的缓冲区大小。-d, --duration：设置记录时间长度，以秒为单位。-l, --limit：设置记录的消息数量限制。-j, --bz2：使用bzip2压缩来压缩ROS Bag文件。-z, --lz4：使用LZ4压缩来压缩ROS Bag文件。-p, --split：设置ROS Bag文件的分段大小。-t, --topics：指定要记录的主题列表。-x, --exclude：指定要排除的主题列表。 2." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/4d332afc3eed8e3d796d6421bc3accbe/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-02-15T12:31:16+08:00" />
<meta property="article:modified_time" content="2023-02-15T12:31:16+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">ROS笔记（5）——Bag包概述与解析</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p id="main-toc"><strong>目录</strong></p> 
<p id="-toc" style="margin-left:40px;"></p> 
<p id="ROS%20Bag%E6%A6%82%E5%BF%B5%E4%B8%8E%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF-toc" style="margin-left:40px;"><a href="#ROS%20Bag%E6%A6%82%E5%BF%B5%E4%B8%8E%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF" rel="nofollow">ROS Bag概念与使用场景</a></p> 
<p id="ROS%20Bag%E6%96%87%E4%BB%B6%E7%94%9F%E6%88%90%E7%9A%84%E4%B8%A4%E7%A7%8D%E6%96%B9%E5%BC%8F-toc" style="margin-left:40px;"><a href="#ROS%20Bag%E6%96%87%E4%BB%B6%E7%94%9F%E6%88%90%E7%9A%84%E4%B8%A4%E7%A7%8D%E6%96%B9%E5%BC%8F" rel="nofollow">ROS Bag文件生成的两种方式</a></p> 
<p id="ROS%20Bag%E6%96%87%E4%BB%B6%E7%9A%84%E8%A7%A3%E6%9E%90%20%EF%BC%88C%2B%2B%E5%AE%9E%E7%8E%B0%EF%BC%89-toc" style="margin-left:40px;"><a href="#ROS%20Bag%E6%96%87%E4%BB%B6%E7%9A%84%E8%A7%A3%E6%9E%90%20%EF%BC%88C%2B%2B%E5%AE%9E%E7%8E%B0%EF%BC%89" rel="nofollow">ROS Bag文件的解析 （C++实现）</a></p> 
<p id="1%E3%80%81rosbag%3A%3AView-toc" style="margin-left:80px;"><a href="#1%E3%80%81rosbag%3A%3AView" rel="nofollow">1、rosbag::View</a></p> 
<p id="2%E3%80%81%E5%AE%8C%E6%95%B4C%2B%2B%E4%BB%A3%E7%A0%81%E7%A4%BA%E4%BE%8B-toc" style="margin-left:80px;"><a href="#2%E3%80%81%E5%AE%8C%E6%95%B4C%2B%2B%E4%BB%A3%E7%A0%81%E7%A4%BA%E4%BE%8B" rel="nofollow">2、完整C++代码示例</a></p> 
<p id="ROS%20Bag%E6%96%87%E4%BB%B6%E7%9A%84%E8%A7%A3%E6%9E%90%20%EF%BC%88Python%E5%AE%9E%E7%8E%B0%EF%BC%89-toc" style="margin-left:40px;"><a href="#ROS%20Bag%E6%96%87%E4%BB%B6%E7%9A%84%E8%A7%A3%E6%9E%90%20%EF%BC%88Python%E5%AE%9E%E7%8E%B0%EF%BC%89" rel="nofollow">ROS Bag文件的解析 （Python实现）</a></p> 
<p id="C%2B%2B%E4%B8%8EPython%20%E8%A7%A3%E6%9E%90ROS%20Bag%E6%96%87%E4%BB%B6%E4%B8%A4%E7%A7%8D%E6%96%B9%E5%BC%8F%E7%9A%84%E5%AF%B9%E6%AF%94-toc" style="margin-left:40px;"><a href="#C%2B%2B%E4%B8%8EPython%20%E8%A7%A3%E6%9E%90ROS%20Bag%E6%96%87%E4%BB%B6%E4%B8%A4%E7%A7%8D%E6%96%B9%E5%BC%8F%E7%9A%84%E5%AF%B9%E6%AF%94" rel="nofollow">C++与Python 解析ROS Bag文件两种方式的对比</a></p> 
<hr id="hr-toc"> 
<p></p> 
<h3 id="ROS%20Bag%E6%A6%82%E5%BF%B5%E4%B8%8E%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF">ROS Bag概念与使用场景</h3> 
<p>ROS Bag是一种文件格式，用于存储ROS系统中的消息。ROS Bag可以将ROS节点发布的消息记录下来，然后在需要的时候将这些消息再次播放回ROS系统中。</p> 
<p>ROS Bag通常用于以下场景：</p> 
<ol><li>离线数据处理：在无法连接实时ROS系统时，可以使用ROS Bag记录消息，然后在离线状态下进行数据处理和算法开发。</li><li>数据集收集：ROS Bag可以用于收集数据集，以用于机器学习和深度学习等应用。</li><li>调试和测试：ROS Bag可以用于调试和测试ROS节点和程序的行为。</li></ol> 
<h3 id="ROS%20Bag%E6%96%87%E4%BB%B6%E7%94%9F%E6%88%90%E7%9A%84%E4%B8%A4%E7%A7%8D%E6%96%B9%E5%BC%8F">ROS Bag文件生成的两种方式</h3> 
<p>ROS Bag文件以 <code>.bag</code> 扩展名结尾，可以通过以下方法进行保存：</p> 
<ol><li>在终端中使用<code>rosbag record</code>命令来记录指定主题的消息，将消息保存到ROS Bag文件中。例如，以下命令将记录名为<code>/scan</code>的激光雷达数据并将其保存到名为<code>scan.bag</code>的文件中：</li></ol> 
<p><code>rosbag record /scan -O scan.bag </code></p> 
<blockquote> 
 <p><code>rosbag record</code> 是一个用于记录 ROS 消息到 ROS Bag 文件中的命令行工具。它可以记录指定主题的消息，将消息保存到一个ROS Bag文件中。以下是 <code>rosbag record</code> 命令的常用参数：</p> 
 <ul><li><code>-a, --all</code>：记录所有主题。</li><li><code>-O, --output-name</code>：指定输出的 ROS Bag 文件名。</li><li><code>-b, --buffer-size</code>：设置ROS Bag文件的缓冲区大小。</li><li><code>-d, --duration</code>：设置记录时间长度，以秒为单位。</li><li><code>-l, --limit</code>：设置记录的消息数量限制。</li><li><code>-j, --bz2</code>：使用bzip2压缩来压缩ROS Bag文件。</li><li><code>-z, --lz4</code>：使用LZ4压缩来压缩ROS Bag文件。</li><li><code>-p, --split</code>：设置ROS Bag文件的分段大小。</li><li><code>-t, --topics</code>：指定要记录的主题列表。</li><li><code>-x, --exclude</code>：指定要排除的主题列表。</li></ul> 
</blockquote> 
<p>        2.在ROS程序中使用ROS API来记录消息，将消息保存到ROS Bag文件中。例如，以下代码段将记录名为<code>/scan</code>的激光雷达数据并将其保存到名为<code>scan.bag</code>的文件中：</p> 
<pre><code class="language-cpp">#include &lt;ros/ros.h&gt;
#include &lt;sensor_msgs/LaserScan.h&gt;
#include &lt;rosbag/bag.h&gt;

void scanCallback(const sensor_msgs::LaserScan::ConstPtr&amp; msg)
{
  static rosbag::Bag bag;
  if (!bag.isOpen()) {
    bag.open("scan.bag", rosbag::bagmode::Write);
  }
  bag.write("/scan", ros::Time::now(), *msg);
  /*
  当程序退出时，ROS Bag 的析构函数会自动关闭文件。
  如果您想手动关闭文件，可以在程序退出前显式地删除ROS Bag对象或调用rosbag::Bag::close()方法来关闭 
  文件。
 */
}

int main(int argc, char** argv)
{
  ros::init(argc, argv, "scan_logger");
  ros::NodeHandle nh;

  ros::Subscriber sub = nh.subscribe&lt;sensor_msgs::LaserScan&gt;("/scan", 1, scanCallback);

  ros::spin();

  return 0;
}
</code></pre> 
<p><strong>python实现</strong></p> 
<pre><code class="language-python">#!/usr/bin/env python

import rospy
import rosbag
from sensor_msgs.msg import LaserScan

def scanCallback(msg):
    global bag
    if bag is None:
        bag = rosbag.Bag('scan.bag', 'w')
    bag.write('/scan', msg)

if __name__ == '__main__':
    rospy.init_node('scan_logger')
    bag = None
    sub = rospy.Subscriber('/scan', LaserScan, scanCallback)
    rospy.spin()
    bag.close()
</code></pre> 
<p>无论使用哪种方法保存 ROS Bag 文件，都可以使用 <code>rosbag play</code> 命令或ROS API来播放并查看记录的消息。</p> 
<h3 id="ROS%20Bag%E6%96%87%E4%BB%B6%E7%9A%84%E8%A7%A3%E6%9E%90%20%EF%BC%88C%2B%2B%E5%AE%9E%E7%8E%B0%EF%BC%89">ROS Bag文件的解析 （C++实现）</h3> 
<h4 id="1%E3%80%81rosbag%3A%3AView">1、rosbag::View</h4> 
<p><code>rosbag::View</code>是ROS Bag文件中的一组消息的视图，它提供了一些方便的方法来遍历和访问这些消息。</p> 
<p><code>rosbag::View</code>实际上是一个包含<code>rosbag::Connection</code>对象的集合，每个对象代表一个主题。<code>rosbag::Connection</code>对象包含一组时间戳和消息，表示该主题的所有消息。您可以使用以下方法来访问这些消息：</p> 
<ul><li><code>begin()</code>：返回指向第一条消息的迭代器。</li><li><code>end()</code>：返回指向最后一条消息后面的位置的迭代器。</li><li><code>rbegin()</code>：返回指向最后一条消息的迭代器。</li><li><code>rend()</code>：返回指向第一条消息前面的位置的迭代器。</li><li><code>size()</code>：返回视图中消息的数量。</li></ul> 
<p>在使用<code>rosbag::View</code>遍历Bag文件中的所有消息时，每个迭代器会返回一个<code>rosbag::MessageInstance</code>对象。这个对象包含了消息的时间戳、消息类型和消息数据等信息。您可以使用以下方法来访问这些信息：</p> 
<ul><li><code>getTime()</code>：返回消息的时间戳。</li><li><code>getTopic()</code>：返回消息所属的主题名称。</li><li><code>getDataType()</code>：返回消息的数据类型。</li><li><code>instantiate()</code>：将消息实例化为指定的数据类型。如果无法实例化，则返回空指针。</li></ul> 
<h4 id="2%E3%80%81%E5%AE%8C%E6%95%B4C%2B%2B%E4%BB%A3%E7%A0%81%E7%A4%BA%E4%BE%8B">2、完整C++代码示例</h4> 
<pre><code class="language-cpp">#include &lt;ros/ros.h&gt;
#include &lt;rosbag/bag.h&gt;
#include &lt;std_msgs/String.h&gt;

int main(int argc, char** argv) {
    // 初始化ROS节点
    ros::init(argc, argv, "rosbag_parser");
    ros::NodeHandle n;

    // 打开bag文件
    rosbag::Bag bag;
    bag.open("/path/to/bagfile.bag", rosbag::bagmode::Read);

    // 遍历bag文件中的所有消息
    rosbag::View view(bag);
    for (rosbag::MessageInstance const m : view) {
        std_msgs::String::ConstPtr msg = m.instantiate&lt;std_msgs::String&gt;();
        if (msg != nullptr &amp;&amp; m.getTopic() == "/my_topic") {
            // 打印消息内容
            ROS_INFO("Message: %s", msg-&gt;data.c_str());
        }
    }

    // 关闭bag文件
    bag.close();

    return 0;
}
</code></pre> 
<h3 id="ROS%20Bag%E6%96%87%E4%BB%B6%E7%9A%84%E8%A7%A3%E6%9E%90%20%EF%BC%88Python%E5%AE%9E%E7%8E%B0%EF%BC%89">ROS Bag文件的解析 （Python实现）</h3> 
<pre><code class="language-python">import rosbag
import rospy
from std_msgs.msg import String

# 初始化ROS节点
rospy.init_node('rosbag_parser')

# 打开bag文件
bag = rosbag.Bag('/path/to/bagfile.bag')

# 遍历bag文件中的所有消息
for topic, msg, t in bag.read_messages():
    # 检查消息类型和主题名称
    if topic == '/my_topic' and isinstance(msg, String):
        # 打印消息内容
        rospy.loginfo("Message: %s", msg.data)

# 关闭bag文件
bag.close()
</code></pre> 
<p></p> 
<p>请注意，在这个示例中，我们使用了ROS提供的<code>rospy.loginfo</code>函数来输出消息，它类似于Python的<code>print</code>函数，但是它会将消息输出到ROS的日志系统，这有助于调试和记录机器人的运行情况。</p> 
<p>您可以将上面的代码保存为一个Python文件，然后用以下命令运行它：</p> 
<p><code>rosrun &lt;package_name&gt; &lt;filename.py&gt; </code></p> 
<p>请将<code>&lt;package_name&gt;</code>替换为你的ROS软件包的名称，将<code>&lt;filename.py&gt;</code>替换为你的Python文件的名称。</p> 
<h3></h3> 
<h3 id="C%2B%2B%E4%B8%8EPython%20%E8%A7%A3%E6%9E%90ROS%20Bag%E6%96%87%E4%BB%B6%E4%B8%A4%E7%A7%8D%E6%96%B9%E5%BC%8F%E7%9A%84%E5%AF%B9%E6%AF%94">C++与Python 解析ROS Bag文件两种方式的对比</h3> 
<p>Python 中使用 <code>rosbag.Bag</code> 读取 Bag 文件，C++ 中使用 <code>rosbag::Bag</code>。</p> 
<p>Python 中使用 <code>bag.read_messages()</code> 方法遍历 Bag 文件中的消息，C++ 中使用 <code>rosbag::View</code> 类和 C++11 的范围 for 循环来遍历消息。</p> 
<p>Python 中的 <code>t</code> 变量表示消息的时间戳，C++ 中使用 <code>rosbag::MessageInstance::getTime()</code> 方法来获取消息的时间戳。</p> 
<p>Python 中使用 <code>msg</code> 变量来存储消息的内容，C++ 中使用 <code>rosbag::MessageInstance::instantiate()</code> 方法将消息实例化为指定的数据类型，如果无法实例化，则返回空指针。</p> 
<p>Python 中使用 <code>topic</code> 变量来表示消息所属的主题，C++ 中使用 <code>rosbag::MessageInstance::getTopic()</code> 方法来获取消息所属的主题名称。</p> 
<p>Python 中使用 <code>rospy.loginfo</code> 函数来输出消息，C++ 中可以使用 ROS 的日志系统来输出消息，例如使用 <code>ROS_INFO</code> 宏来输出消息。</p> 
<p>因此，使用 C++ 代码来解析 ROS Bag 文件，大致流程如下：</p> 
<ol><li>打开 Bag 文件并创建 <code>rosbag::Bag</code> 对象。</li><li>创建 <code>rosbag::View</code> 对象并遍历 Bag 文件中的消息。</li><li>对于每条消息，使用 <code>rosbag::MessageInstance::instantiate()</code> 方法将消息实例化为指定的数据类型，并使用 <code>rosbag::MessageInstance::getTopic()</code> 方法获取消息所属的主题名称和 <code>rosbag::MessageInstance::getTime()</code> 方法获取消息的时间戳。</li><li>对于符合条件的消息，使用 ROS 的日志系统或其他方式输出消息内容。</li><li>关闭 Bag 文件。</li></ol>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/f3f0d8d4c2367fc81712442ad9568a26/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">Mybatis分表数据汇总的一种思路</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/938b2b680b4f3f53feae3262eee11a28/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">双三次插值 - 插值图像任意位置亚像素C&#43;&#43;</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>