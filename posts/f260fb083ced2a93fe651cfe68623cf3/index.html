<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>C/C&#43;&#43;使用过程中的溢出问题 - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="C/C&#43;&#43;使用过程中的溢出问题" />
<meta property="og:description" content="内容：在C/C&#43;&#43;程序里有一类非常典型的问题，那就是：溢出问题。现在分别来分析一下常见的数组溢出，整数溢出，缓冲区溢出，栈溢出和指针溢出等。
目录
1、数组溢出
2、整数溢出
3、缓冲区溢出
4、栈溢出
5、指针溢出
6、字符串溢出
1、数组溢出 在C语言中，数组的元素下标是从0开始计算的，所以，对于n个元素的数组a[n]， 遍历它的时候是a[0],a[1],...,a[n-1]，如果遍历到a[n]，数组就溢出了。 void print_array(int a[], int n)
{
for (int i = 0; i &lt; n; i&#43;&#43;) {
a[i] = a[i&#43;1];//当i = n-1时，就发生了数组越界
printf(“%d\n”, a[i]);
}
}
上面的循环判断应该改为：
for (int i = 0; i &lt; n-1; i&#43;&#43;)
2、整数溢出 整数的溢出分为下溢出和上溢出。比如，对于有符号的char(signed char)类型来说，它能表示的范围为：[-128,127]之间；而对于无符号的char(unsigned char)来说， 它能表示的范围为：[0,255]。
那么，对于下面的代码：
signed char c1 = 127;
c1 = c1&#43;1;//发生上溢出，c1的值将变为-128
signed char c2 = -128;
c2 = c2-1;//发生下溢出，c2的值将变为127
unsigned char c3 = 255;" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/f260fb083ced2a93fe651cfe68623cf3/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2024-01-07T12:54:28+08:00" />
<meta property="article:modified_time" content="2024-01-07T12:54:28+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">C/C&#43;&#43;使用过程中的溢出问题</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p>内容：在C/C++程序里有一类非常典型的问题，那就是：溢出问题。现在分别来分析一下常见的数组溢出，整数溢出，缓冲区溢出，栈溢出和指针溢出等。</p> 
<p id="main-toc"><strong>目录</strong></p> 
<p id="1%E3%80%81%E7%AC%AC%E4%B8%80%E7%AB%A0-toc" style="margin-left:40px;"><a href="#1%E3%80%81%E7%AC%AC%E4%B8%80%E7%AB%A0" rel="nofollow">1、数组溢出</a></p> 
<p id="2%E3%80%81%E7%AC%AC%E4%B8%80%E7%AB%A0-toc" style="margin-left:40px;"><a href="#2%E3%80%81%E7%AC%AC%E4%B8%80%E7%AB%A0" rel="nofollow">2、整数溢出</a></p> 
<p id="3%E3%80%81%E6%80%BB%E7%BB%93-toc" style="margin-left:40px;"><a href="#3%E3%80%81%E6%80%BB%E7%BB%93" rel="nofollow">3、缓冲区溢出</a></p> 
<p id="4%E3%80%81%E6%A0%88%E6%BA%A2%E5%87%BA-toc" style="margin-left:40px;"><a href="#4%E3%80%81%E6%A0%88%E6%BA%A2%E5%87%BA" rel="nofollow">4、栈溢出</a></p> 
<p id="5%E3%80%81%E6%8C%87%E9%92%88%E6%BA%A2%E5%87%BA-toc" style="margin-left:40px;"><a href="#5%E3%80%81%E6%8C%87%E9%92%88%E6%BA%A2%E5%87%BA" rel="nofollow">5、指针溢出</a></p> 
<p id="6%E3%80%81%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%BA%A2%E5%87%BA-toc" style="margin-left:40px;"><a href="#6%E3%80%81%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%BA%A2%E5%87%BA" rel="nofollow">6、字符串溢出</a></p> 
<hr id="hr-toc"> 
<p></p> 
<p id="3%E3%80%81%E6%80%BB%E7%BB%93-toc" style="margin-left:40px;"></p> 
<h3 id="1%E3%80%81%E7%AC%AC%E4%B8%80%E7%AB%A0">1、数组溢出</h3> 
<p>在C语言中，数组的元素下标是从0开始计算的，所以，对于n个元素的数组a[n]， 遍历它的时候是a[0],a[1],...,a[n-1]，如果遍历到a[n]，数组就溢出了。 <br> void print_array(int a[], int n)<br> {<!-- --><br>     for (int i = 0; i &lt; n; i++) <br>     {<!-- --><br>         a[i] = a[i+1];//当i = n-1时，就发生了数组越界<br>         printf(“%d\n”, a[i]);<br>     }<br> }<br> 上面的循环判断应该改为：<br> for (int i = 0; i &lt; n-1; i++)</p> 
<h3 id="2%E3%80%81%E7%AC%AC%E4%B8%80%E7%AB%A0">2、整数溢出</h3> 
<p>整数的溢出分为下溢出和上溢出。比如，对于有符号的char(signed char)类型来说，它能表示的范围为：[-128,127]之间；而对于无符号的char(unsigned char)来说， 它能表示的范围为：[0,255]。<br> 那么，对于下面的代码：<br> signed char c1 = 127;<br> c1 = c1+1;//发生上溢出，c1的值将变为-128<br> signed char c2 = -128;<br> c2 = c2-1;//发生下溢出，c2的值将变为127<br> unsigned char c3 = 255;<br> c3 = c3+1;//发生上溢出，c3的值将变为0<br> unsigned char c4 = 0;<br> c4 = c4-1;//发生下溢出，c4的值将变为255<br> 从上面的例子可以看出，当一个整数向上溢出，将会变为最小值，而向下溢出，将会变为最大值。</p> 
<p>来看下面的溢出代码，该代码负责提供一个小写字母转换表，但存在一个整数溢出问题：<br> void BuildToLowerTable( void ) /* ASCII版本*/<br> {<!-- --><br>     unsigned char ch;<br>     /* 首先将每个字符置为它自己 */<br>     /*ch为unsigned char，无符号数，当ch值为UCHAR_MAX， ch++将会发生向上溢出，变为0，导致循环无法退出。*/<br>     for （ch=0; ch &lt;= UCHAR_MAX;ch++）<br>         chToLower[ch] = ch;<br>     /* 将大写字母改为小写字母 */<br>     for( ch = ‘A’; ch &lt;= ‘Z’; ch++ )<br>         chToLower[ch] = ch +’a’ – ‘A’;<br> }<br> 该代码负责在内存中查找指定的字符ch，但也存在一个溢出问题<br> void * memchr( void *pv, unsigned char ch, size_t size )<br> {<!-- --><br>     unsigned char *pch = (unsigned char *) pv;<br>     /*当size的值为0的时候，由于size是无符号整数，因此会发生下溢出，变为一个最大的整数 循环也将无法退出*/ <br>     while( -- size &gt;=0 )<br>     {<!-- --><br>         if( *pch == ch )<br>             return (pch );<br>         pch++;<br>     }<br>     return( NULL );<br> }</p> 
<h3 id="3%E3%80%81%E6%80%BB%E7%BB%93">3、缓冲区溢出</h3> 
<p>缓冲区溢出一般是调用了一些不安全的字符串操作函数比如：strcpy，strcat等（这些字符串操作函数在拷贝或者修改目标位置的时候，并不判断长度是否会超过目标缓存），或者设置参数超过了目标缓存能容纳的大小而造成的溢出问题。<br> void func1(char* s)<br> {<!-- --><br>     char buf[10];<br>     /*此时，buf只有10个字节，如果传入的s超过10个字节，就会造成溢出*/<br>     strcpy(buf, s);<br> }<br> void func2(void)<br> {<!-- --><br>     printf("Hacked by me.\n");<br>     exit(0);<br> }<br> int main(int argc, char* argv[])<br> {<!-- --><br>     char badCode[] = "aaaabbbb2222cccc4444ffff";<br>     DWORD* pEIP = (DWORD*)&amp;badCode[16];<br>     *pEIP = (DWORD)func2;<br>     /*badCode字符串超过了10个字节，传递给func1会造成栈上缓冲区溢出<br>     而且，由于badCode经过精心构造，在溢出的时候，根据函数的调用约定规则，会覆盖栈上的返回地址，<br>     指向了func2。所以，在func1退出的时候，会直接调用func2<br>     */<br>     func1(badCode);<br>     return 0;<br> }</p> 
<h3 id="4%E3%80%81%E6%A0%88%E6%BA%A2%E5%87%BA">4、栈溢出</h3> 
<p><br> 无论是内核栈，还是应用层的栈，都是有一定大小限制的。如果在栈上分配的空间大于了这个限制，就会造成栈大小溢出，破坏栈上的数据。比如局部变量过多，或者递归调度嵌套太深都会造成栈溢出。比如：<br> int init_module(void)<br> {<!-- --><br>     char buf[10000]; //buf[]分配在栈上，但10000的空间超过了栈的默认大小8KB。<br>     //所以发生溢出<br>     memset(buf,0,10000);<br>     printk("kernel stack.\n");<br>     return 0;<br> }<br> void cleanup_module(void)<br> { <br>     printk("goodbye.\n");<br> }<br> MODULE_LICENSE("GPL");<br> //应用栈的大小对少？内核栈的大小多少？什么时候容易栈溢出？</p> 
<h3 id="5%E3%80%81%E6%8C%87%E9%92%88%E6%BA%A2%E5%87%BA">5、指针溢出</h3> 
<p>一块长度为size大小的内存buffer，buffer的首地址为p，那么buffer最后一个字节的地址：<br> p+size-1，而不是p+size。如果写成了p+size，就会造成溢出，比如下面的代码：<br> void* memchr( void *pv, unsigned char ch, size_t size )<br> {<!-- --><br>     unsigned char *pch = ( unsigned char * )pv;<br>     unsigned char *pchEnd = pch + size;<br>     while( pch &lt; pchEnd )<br>     {<!-- --><br>         if( *pch == ch )<br>             return ( pch );<br>         pch ++ ;<br>     }<br>     return( NULL );<br> }</p> 
<p>上面的代码用于查找内存中特定的字符位置。对于其中的while（）循环，平时执行似乎都没有任何问题。但是，考虑一种特别情况，即pv所指的内存位置为末尾若干字节，那么因为pchEnd = pch+size，所以pchEnd指向最后一个字符的下一个字节，将会超出内存的范围，即pchEnd所指的位置已经不存在。<br> 知道了问题所在，那么可以将内存的结尾计算方式改为： <br> pchEnd = pv + size – 1; <br> while ( pch &lt;= pchEnd ) <br> {<!-- --><br>         if( *pch == ch )<br>             return ( pch );<br>         pch ++ ;<br> }<br> …… <br> pchEnd指向了最后一个字节。但是，检查循环内部的执行情况可知，由于pch每增加到pchEnd+1时，都会发生上溢。因此，循环将无法退出。 于是，可以将程序修改为下面的代码。将用size变量来控制循环的退出。这样就不会存在任何问题了。<br> void *memchr( void *pv, unsigned char ch, size_t size )<br> {<!-- --><br>     unsigned char *pch = ( unsigned char * )pv;<br>     while( size -- &gt; 0 )<br>     {<!-- --><br>         if( *pch == ch )<br>             return( pch );<br>         pch ++;<br>     }<br>     return( NULL );<br> }</p> 
<p>大家知道，--size的效率一般比size--的效率高。那么是否可以将循环的判断条件改为下面的语句呢？ <br> while（ --size &gt;= 0 ） <br> …… </p> 
<p>实际上这是不行的。因为当size=0时，由于size是无符号数，那么它将发生下溢，变成了size所能表示的最大正数，循环也将无法退出。 </p> 
<h3 id="6%E3%80%81%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%BA%A2%E5%87%BA">6、字符串溢出</h3> 
<p>我们已经知道，字符串是'\0'结尾的。如果字符串结尾忘记带上'\0'，那么就溢出了。注意，strlen(p)计算的是字符串中有效的字符数（不含’\0’）。考察下面拷贝字符串的代码，看看有什么问题没呢？</p> 
<p></p> 
<p>char *str = “Hello, how are you!”;</p> 
<p>char *strbak = (char *)malloc(strlen(str));</p> 
<p>if (NULL == strbak)</p> 
<p>{<!-- --></p> 
<p>//处理内存分配失败，返回错误</p> 
<p>}</p> 
<p>strcpy(strbak, str);</p> 
<p>......</p> 
<p></p> 
<p>显然，由于strlen()计算的不是str的实际长度（即不包含’\0’字符的计算），所以strbak没有结束符’\0’，而在C语言中，’\0’是字符串的结束标志，所以是必须加上的，否则会造成字符串的溢出。所以上面的代码应该是：</p> 
<p></p> 
<p>char *str = “Hello, how are you!”;</p> 
<p>char *strbak = (char *)malloc(strlen(str)+1);</p> 
<p>if (NULL == strbak)</p> 
<p>{<!-- --></p> 
<p>    //内存分配失败，返回错误</p> 
<p>}</p> 
<p>strcpy(strbak, str);</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/3b709bebc0515305e0d45b9fd34e1c25/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">计算机网络基础知识（非常详细）从零基础入门到精通，看完这一篇就够了</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/863725b47547781a70a02d2966005e6b/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">解决flask启动报错：ImportError: DLL load failed while importing _dukpy: 找不到指定的程序</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>