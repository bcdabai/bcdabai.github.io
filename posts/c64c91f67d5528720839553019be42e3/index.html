<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>【数据结构】线性表之栈和队列 - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="【数据结构】线性表之栈和队列" />
<meta property="og:description" content="一、栈 栈是一种特殊的线性表，只允许在固定的一端进行插入和删除元素操作。
进行数据插入和删除操作的一端称为栈顶，另一端称为栈底，栈中的数据元素遵守后进先出的原则。
它的插入操作叫做进栈（或进栈/入栈），插入的数据在栈顶；删除操作叫做出栈。出的数据也在栈顶。
它主要通过数组来实现（其实数组或者链表实现均可，但相对而言数组更优），有静态栈和动态栈之分。静态栈拥有两个通过结构体封装的结构体成员——存储数据的定长数组和栈顶元素的下标。
#define N 10 struct Stack { int a[N]; int top; }; 和顺序表类似，存储数据的数组虽然可以由定长数组来充当，但有不确定的容量问题。所以，实际应用一般仍是以拥有动态数组的动态栈为主。 动态栈拥有三个通过结构体封装的结构体成员——存储数据的动态数组、空间容量和栈顶的相关下标，同时拥有一系列函数接口。
typedef int STDataType; typedef struct Stack { STDataType* a; //存储数据的动态数组 int capacity; //空间容量 int top; //栈顶的相关下标 }ST; void STInit(ST* ps); //初始化栈 void STPush(ST* ps, STDataType x); //入栈 void STPop(ST* ps); //出栈 bool STEmpty(ST* ps); //验空 int STSize(ST* ps); //获取有效数据个数 STDataType STTop(ST* ps); //访问栈顶元素 void STDestroy(ST* ps); //销毁栈 1、初始化栈 开辟动态数组的空间，并初始化空间容量和栈顶的相关下标。
void STInit(ST* ps) { assert(ps); //定义动态数组 ps-&gt;a = (STDataType*)malloc(sizeof(STDataType) * 4); if (ps-&gt;a == NULL) { perror(&#34;" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/c64c91f67d5528720839553019be42e3/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-08-25T15:29:56+08:00" />
<meta property="article:modified_time" content="2023-08-25T15:29:56+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">【数据结构】线性表之栈和队列</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <h2>一、栈</h2> 
<p></p> 
<p>        栈是一种特殊的线性表，只允许在<strong>固定的一端</strong>进行插入和删除元素操作。</p> 
<p>        进行数据插入和删除操作的一端称为<strong>栈顶</strong>，另一端称为<strong>栈底</strong>，栈中的数据元素遵守<strong>后进先出</strong>的原则。</p> 
<p><img alt="" height="36" src="https://images2.imgbox.com/93/e9/r0XSIo8t_o.png" width="481"></p> 
<p><img alt="" height="233" src="https://images2.imgbox.com/62/a0/1slkTyCC_o.jpg" width="489"></p> 
<p></p> 
<p>        它的<strong>插入</strong>操作叫做<strong>进栈</strong>（或进栈/入栈），<strong>插入的数据在栈顶；删除</strong>操作叫做<strong>出栈</strong>。<strong>出的数据也在栈顶</strong>。</p> 
<p>        它主要通过数组来实现（其实数组或者链表实现均可，但相对而言数组更优），有静态栈和动态栈之分。静态栈拥有两个通过结构体封装的结构体成员——存储数据的定长数组和栈顶元素的下标。</p> 
<pre><code>#define N 10
struct Stack
{
	int a[N];
    int top;
};</code></pre> 
<p>        和顺序表类似，存储数据的数组虽然可以由定长数组来充当，但有不确定的容量问题。所以，实际应用一般仍是以拥有动态数组的动态栈为主。  </p> 
<p>        动态栈拥有三个通过结构体封装的结构体成员——<strong>存储数据的动态数组</strong>、<strong>空间容量</strong>和<strong>栈顶的相关下标</strong>，同时拥有一系列函数接口。</p> 
<pre><code>typedef int STDataType;

typedef struct Stack
{
	STDataType* a;    //存储数据的动态数组
	int capacity;     //空间容量
	int top;          //栈顶的相关下标

}ST;

void STInit(ST* ps);                    //初始化栈
void STPush(ST* ps, STDataType x);      //入栈
void STPop(ST* ps);                     //出栈
bool STEmpty(ST* ps);                   //验空
int STSize(ST* ps);                     //获取有效数据个数
STDataType STTop(ST* ps);               //访问栈顶元素
void STDestroy(ST* ps);                 //销毁栈</code></pre> 
<p></p> 
<h3>1、初始化栈</h3> 
<p></p> 
<p>        开辟动态数组的空间，并初始化空间容量和栈顶的相关下标。</p> 
<pre><code>void STInit(ST* ps)
{
	assert(ps);
    
    //定义动态数组
	ps-&gt;a = (STDataType*)malloc(sizeof(STDataType) * 4);
	if (ps-&gt;a == NULL)
	{
		perror("malloc fail");
		return;
	}

    //初始化空间容量
	ps-&gt;capacity = 4;
	ps-&gt;top = 0;      // 这样写，top是栈顶元素的下一个位置。这样更方便控制边界
	//ps-&gt;top = -1;   // 这样写，top就是栈顶元素位置
}</code></pre> 
<p></p> 
<h3>2、验空</h3> 
<p></p> 
<p>        若栈顶的相关下标在数组的起始位置，即栈顶的相关下标值为0，则栈为空。</p> 
<pre><code>bool STEmpty(ST* ps)
{
	assert(ps);

	return ps-&gt;top == 0;
}</code></pre> 
<p></p> 
<h3>3、入栈</h3> 
<p></p> 
<p>        入栈前应先检查栈的空间容量，空间容量不足就先扩容再入栈。</p> 
<pre><code>void STPush(ST* ps, STDataType x)
{
	assert(ps);
    
    //检查空间容量
    //不足则扩容
	if (ps-&gt;top == ps-&gt;capacity)   //若栈顶的相关下标与空间容量的值相等，则说明动态数组已满
	{
		STDataType* tmp = (STDataType*)realloc(ps-&gt;a,
			sizeof(STDataType) * ps-&gt;capacity * 2);
		if (tmp == NULL)
		{
			perror("realloc fail");
			return;
		}

		ps-&gt;a = tmp;
		ps-&gt;capacity *= 2;
	}
    
    //入栈
	ps-&gt;a[ps-&gt;top] = x;

    //入栈后top应自增1
	ps-&gt;top++;
}</code></pre> 
<p></p> 
<h3>4、出栈</h3> 
<p></p> 
<p>        使栈顶的相关下标自减1即可。</p> 
<pre><code>void STPop(ST* ps)
{
	assert(ps);
	assert(!STEmpty(ps));

	ps-&gt;top--;
}</code></pre> 
<h3></h3> 
<h3>5、获取有效数据个数</h3> 
<p></p> 
<p>        栈顶的相关下标的值，即为有效数据个数。</p> 
<pre><code>int STSize(ST* ps)
{
	assert(ps);

	return ps-&gt;top;
}</code></pre> 
<p></p> 
<h3>6、访问栈顶元素</h3> 
<p></p> 
<p>        因为初始化时栈顶的相关下标top是实际栈顶元素的下一位，故 top - 1 为栈顶元素的下标。</p> 
<pre><code>STDataType STTop(ST* ps)
{
	assert(ps);
	assert(!STEmpty(ps));

	return ps-&gt;a[ps-&gt;top - 1];
}</code></pre> 
<p></p> 
<h3>7、销毁栈</h3> 
<p></p> 
<p>        释放动态数组，将空间容量和栈顶的相关下标和空间容量置为0即可。</p> 
<pre><code>void STDestroy(ST* ps)
{
	assert(ps);

	free(ps-&gt;a);
	ps-&gt;a = NULL;
	ps-&gt;top = 0;
	ps-&gt;capacity = 0;
}</code></pre> 
<p></p> 
<h3>· 代码汇总</h3> 
<p></p> 
<p><strong>        Stack.h</strong></p> 
<pre><code>#define _CRT_SECURE_NO_WARNINGS\


#include&lt;stdio.h&gt;
#include&lt;stdlib.h&gt;
#include&lt;stdbool.h&gt;
#include&lt;assert.h&gt;

typedef int STDataType;

typedef struct Stack
{
	STDataType* a;
	int top;
	int capacity;
}ST;


void STInit(ST* ps);
void STPush(ST* ps, STDataType x);
void STPop(ST* ps);
int STSize(ST* ps);
bool STEmpty(ST* ps);
STDataType STTop(ST* ps);
void STDestroy(ST* ps);</code></pre> 
<p><strong>        Stack.c</strong></p> 
<pre><code>#include"Stack.h"

void STInit(ST* ps)
{
	assert(ps);

	ps-&gt;a = (STDataType*)malloc(sizeof(STDataType) * 4);
	if (ps-&gt;a == NULL)
	{
		perror("malloc fail");
		return;
	}

	ps-&gt;capacity = 4;
	ps-&gt;top = 0;  
}

void STDestroy(ST* ps)
{
	assert(ps);

	free(ps-&gt;a);
	ps-&gt;a = NULL;
	ps-&gt;top = 0;
	ps-&gt;capacity = 0;
}

void STPush(ST* ps, STDataType x)
{
	assert(ps);

	if (ps-&gt;top == ps-&gt;capacity)
	{
		STDataType* tmp = (STDataType*)realloc(ps-&gt;a,
			sizeof(STDataType) * ps-&gt;capacity * 2);
		if (tmp == NULL)
		{
			perror("realloc fail");
			return;
		}

		ps-&gt;a = tmp;
		ps-&gt;capacity *= 2;
	}

	ps-&gt;a[ps-&gt;top] = x;
	ps-&gt;top++;
}

void STPop(ST* ps)
{
	assert(ps);
	assert(!STEmpty(ps));

	ps-&gt;top--;
}

int STSize(ST* ps)
{
	assert(ps);

	return ps-&gt;top;
}

bool STEmpty(ST* ps)
{
	assert(ps);

	return ps-&gt;top == 0;
}

STDataType STTop(ST* ps)
{
	assert(ps);
	assert(!STEmpty(ps));

	return ps-&gt;a[ps-&gt;top - 1];
}</code></pre> 
<h2></h2> 
<h2></h2> 
<h2>二、队列</h2> 
<p>        队列只允许在<strong>一端进行插入</strong>数据操作，在<strong>另一端进行删除</strong>数据操作的特殊线性表，队列具有<strong>先进先出</strong>的特性。进行插入操作（<strong>入队</strong>）的一端称为<strong>队尾，</strong>进行删除操作（<strong>出队</strong>）的一端称为<strong>队头</strong>。</p> 
<p><img alt="" height="260" src="https://images2.imgbox.com/52/17/9UedSf4V_o.jpg" width="1024"></p> 
<p><img alt="" height="738" src="https://images2.imgbox.com/9b/93/WiNF6P2S_o.png" width="1151"></p> 
<p>         队列主要通过链表来实现（其实数组和链表均可，但使用数组的结构出队列时，在数组头上出数据效率会比较低，故链表更优 ），拥有三个通过结构体封装的结构体成员——<strong>头节点（队头）</strong>、<strong>尾节点（队尾）</strong>和<strong>有效数据个数</strong>，每个节点由两个结构体成员组成——<strong>当前节点数据</strong>和<strong>指向下一节点的next指针</strong>。与此同时，它还有一系列<strong>接口</strong>。</p> 
<p></p> 
<pre><code>typedef char QDatatype;

//节点
typedef struct QueueNode
{
	QDatatype data;            //数据
	struct QueueNode* next;    //指向下一节点的指针
}QNode;

//队列
typedef struct Queue
{
	QNode* head;    //头节点
	QNode* tail;    //尾节点
	int size;       //有效数据个数
}Queue;


void QueueInit(Queue* pq);                //初始化队列
bool QueueEmpty(Queue* pq);               //验空
void QueuePush(Queue* pq, QDatatype x);   //入队
void QueuePop(Queue* pq);                //出队
int QueueSize(Queue* pq);                //获取有效数据个数
QDatatype QueueFront(Queue* pq);         //取队头
QDatatype QueueBack(Queue* pq);          //取队尾
void QueueDestroy(Queue* pq);            //销毁队列</code></pre> 
<p>  </p> 
<h3>1、初始化队列</h3> 
<pre><code>void QueueInit(Queue* pq)
{
	assert(pq);

	pq-&gt;head = pq-&gt;tail = NULL;    //将头节点、尾节点均置空
	pq-&gt;size = 0;                  //将有效数据个数置为0
}</code></pre> 
<h3>2、验空</h3> 
<p></p> 
<p>        有效数据个数size的值为0，则队列为空。</p> 
<pre><code>bool QueueEmpty(Queue* pq)
{
	assert(pq);

	return pq-&gt;size == 0;
}</code></pre> 
<h3>3、入队</h3> 
<p></p> 
<p>        将一个新节点与队尾连接即可。</p> 
<pre><code>void QueuePush(Queue* pq, QDatatype x)
{
    //创建一个新节点入队
	QNode* newnode = (QNode*)malloc(sizeof(QNode));
	if (newnode == NULL)
	{
		perror("malloc fail");
		return;
	}
	newnode-&gt;data = x;
	newnode-&gt;next = NULL;

	if (pq-&gt;head == NULL)            //先验空
	{
		assert(pq-&gt;tail == NULL);

		pq-&gt;head = pq-&gt;tail = newnode;
	}
	else
	{
		pq-&gt;tail-&gt;next = newnode;    //链接节点
		pq-&gt;tail = newnode;          //并更新其为新的尾尾节点
	}

	pq-&gt;size++;        //节点入队后，有效数据个数自增1
}
</code></pre> 
<h3>4、出队</h3> 
<p></p> 
<p>        将头节点释放，并让头节点的下一个节点成为新的头节点。</p> 
<pre><code>void QueuePop(Queue* pq)
{
	assert(pq);
	assert(pq-&gt;head != NULL);

	if (pq-&gt;head-&gt;next == NULL)        //若头节点的下一个节点（即第二个节点）为空，
	{
		free(pq-&gt;head);            
		pq-&gt;head = pq-&gt;tail = NULL;    //则释放头节点，且需将头尾节点均置空
	}
	else
	{
		QNode* next = pq-&gt;head-&gt;next;    //先存下第二个节点的地址
		free(pq-&gt;head);
		pq-&gt;head = next;                 //释放原先的头节点，然后将第二个节点设为新的头节点
	}

	pq-&gt;size--;    //出队后，有效数据个数自减1
	
}</code></pre> 
<p></p> 
<h3>5、获取有效数据个数</h3> 
<p></p> 
<p>        获取队列中的有效数据个数size即可。</p> 
<pre><code>int QueueSize(Queue* pq)
{
	assert(pq);

	return pq-&gt;size;
}</code></pre> 
<p></p> 
<h3>6、取队头</h3> 
<p></p> 
<p>        取头节点中的数据即可。</p> 
<pre><code>QDatatype QueueFront(Queue* pq)
{
	assert(pq);
	assert(!QueueEmpty(pq));

	return pq-&gt;head-&gt;data;
}
</code></pre> 
<p></p> 
<h3>7、取队尾</h3> 
<p></p> 
<p>        取尾节点中的数据即可。</p> 
<pre><code>QDatatype QueueBack(Queue* pq)
{
	assert(pq);
	assert(!QueueEmpty(pq));

	return pq-&gt;tail-&gt;data;
}</code></pre> 
<p></p> 
<h3>8、销毁队列</h3> 
<p></p> 
<p>        遍历队列，逐个节点释放，结束后将头尾节点置空、有效数据个数置为0。</p> 
<pre><code>void QueueDestroy(Queue* pq)
{
	assert(pq);

	QNode* cur = pq-&gt;head;
	while (cur)
	{
		QNode* next = cur-&gt;next;
		free(cur);
		cur = next;
	}

	pq-&gt;head = pq-&gt;tail = NULL;
	pq-&gt;size = 0;
}</code></pre> 
<p></p> 
<h3>· 代码汇总</h3> 
<p><strong>        Queue.h</strong>​​​​​​​</p> 
<pre><code>#define _CRT_SECURE_NO_WARNINGS

#include&lt;stdio.h&gt;
#include&lt;stdlib.h&gt;
#include&lt;stdbool.h&gt;
#include&lt;assert.h&gt;

typedef char QDatatype;

typedef struct QueueNode
{
	struct QueueNode* next;
	QDatatype data;
}QNode;

typedef struct Queue
{
	QNode* head;
	QNode* tail;
	int size;
}Queue;


void QueueInit(Queue* pq);
bool QueueEmpty(Queue* pq);
void QueuePush(Queue* pq, QDatatype x);
void QueuePop(Queue* pq);
int QueueSize(Queue* pq);
QDatatype QueueFront(Queue* pq);
QDatatype QueueBack(Queue* pq);
void QueueDestroy(Queue* pq);</code></pre> 
<p><br><strong>        Queue.c</strong></p> 
<pre><code>#include"Queue.h"

void QueueInit(Queue* pq)
{
	assert(pq);

	pq-&gt;head = pq-&gt;tail = NULL;
	pq-&gt;size = 0;
}

void QueueDestroy(Queue* pq)
{
	assert(pq);

	QNode* cur = pq-&gt;head;
	while (cur)
	{
		QNode* next = cur-&gt;next;
		free(cur);
		cur = next;
	}

	pq-&gt;head = pq-&gt;tail = NULL;
	pq-&gt;size = 0;
}

void QueuePush(Queue* pq, QDatatype x)
{
	QNode* newnode = (QNode*)malloc(sizeof(QNode));
	if (newnode == NULL)
	{
		perror("malloc fail");
		return;
	}

	newnode-&gt;data = x;
	newnode-&gt;next = NULL;

	if (pq-&gt;head == NULL)
	{
		assert(pq-&gt;tail == NULL);

		pq-&gt;head = pq-&gt;tail = newnode;
	}
	else
	{
		pq-&gt;tail-&gt;next = newnode;
		pq-&gt;tail = newnode;
	}

	pq-&gt;size++;
}

void QueuePop(Queue* pq)
{
	assert(pq);
	assert(pq-&gt;head != NULL);

	if (pq-&gt;head-&gt;next == NULL)
	{
		free(pq-&gt;head);
		pq-&gt;head = pq-&gt;tail = NULL;
	}
	else
	{
		QNode* next = pq-&gt;head-&gt;next;
		free(pq-&gt;head);
		pq-&gt;head = next;
	}

	pq-&gt;size--;
	
}

int QueueSize(Queue* pq)
{
	assert(pq);

	return pq-&gt;size;
}

bool QueueEmpty(Queue* pq)
{
	assert(pq);

	return pq-&gt;size == 0;
}

QDatatype QueueFront(Queue* pq)
{
	assert(pq);
	assert(!QueueEmpty(pq));

	return pq-&gt;head-&gt;data;
}

QDatatype QueueBack(Queue* pq)
{
	assert(pq);
	assert(!QueueEmpty(pq));

	return pq-&gt;tail-&gt;data;
}</code></pre> 
<p></p> 
<h3 style="background-color:transparent;">[补] 循环队列</h3> 
<p>        循环队列（或称环形队列）可以使用数组实现，也可以使用循环链表实现，也是实际中常用的一种队列。本博客于此仅展示其理论的逻辑结构，具体实现暂不展开。</p> 
<p><img alt="" height="635" src="https://images2.imgbox.com/cf/32/6MzE71Ze_o.png" width="980"></p> 
<p><img alt="" height="591" src="https://images2.imgbox.com/0a/1c/N3emj1Nt_o.png" width="1200"></p> 
<p></p> 
<p></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/d18bd5c5d4643ead442b90ed761fd75a/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">WSL安装与使用(Ubuntu22.04)</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/3681d6708ab2ba5979f95ea9912ffd47/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">SpringCloud组件总结</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>