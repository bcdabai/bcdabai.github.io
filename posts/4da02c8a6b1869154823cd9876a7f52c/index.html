<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>软考知识点汇总 - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="软考知识点汇总" />
<meta property="og:description" content="本篇文章为22年上半年软件设计师备考笔记
个人总结笔记，如有错误望包涵指正
计算机组成和结构 海明校验码 n个数据位，设k个校验位 2 k &gt; = n &#43; k &#43; 1 2^{k}&gt;=n&#43;k&#43;1 2k&gt;=n&#43;k&#43;1
整个编码系统中任意两个码字的最小距离就是该编码系统的码距。为了使一个系统能检查和纠错一个差错，码间最小距离必须至少是==3==（2n&#43;1）海明码是一种可以纠正一位差错的编码，是利用奇偶性来检错和纠错的校验方法循环冗余校验码（CRC）编码方法是在k位信息码后再拼接r位的校验码，形成长度为n位的编码，其特点是检错能力极强且开销小，易于用编码器及检测电路实现。 奇偶校验 对于奇偶校验，是由若干位有效信息，再加上一个二进制位（校验位）组成校验码，其中
奇校验&#34;1&#34;的个数为奇数，而偶校验&#34;1&#34;的个数为偶数，
只有奇数个数据位发生错误，才能发现错误。同时，奇偶校验只能查错不能纠错
采用模二出发运算的只有循环冗余检验CRC
CPU 指令周期：取指令，分析指令，执行指令
CPU控制单元部件
指令寄存器 IR：用来保存当前正在执行的指令 输出是指令译码器的输入 对用户完全透明
程序计数器 PC：存储的总是将要执行的下一条指令的地址 程序员可以访问
指令译码器 ID：对操作码进行测试，以便识别所要求的的操作（对现行指令进行分析，确定指令类型和指令所要完成的操作以及寻址方式，并将相应的控制命令发往相关部件）
状态字寄存器 PSW用于保存指令执行完成后产生的条件码，例如运算是否有溢出，结果为正还是为负，是否有进位等，此外，PSSW还保存中端和系统工作状态等信息。
地址寄存器 AR：用来保存当前CPU所访问的内存单元的地址
数据寄存器 MDR：主要用来保存操作数和运算结果，目的为了节省读取操作数所需占用的总总线和访问储存器的时间
地址寄存器 MAR：用来保存当前CPU所访问的内存单元地址，以便对内存的读写操作
累加器 AC：专门存放算术或逻辑运算的一个操作数和运算结果的寄存器
加法器：cpu中算术逻辑运算部件
ALU：CPU的执行单元，主要负责运算工作
控制器：控制整个计算机的各个部件有条不紊的工作，基本功能就是从内存去指令和执行指令
CPU依据指令周期的不同阶段来区分在内存中以二进制编码形式存放的指令和数据
输入输出控制 程序控制：由CPU执行程序控制数据的输入输出过程中断控制：外设准备好输入数据或接受数据时向CPU发出中断信号，CPU响应则中断DMA控制：CPU只需向DMA控制器下达指令，让DMA控制器来处理数据的传送，传送完毕再把信息反馈给CPU，减轻CPU负担节省系统资源 DMA（直接主存存取）是指数据在主存与I/O设备间（即主存与外设之间）直接成块传输；CPU只需在开始和结束时作少量处理，而无需干预数据传送过程 总线结构 三总线结构：数据总线、地址总线和控制总线CPU是在一个总线周期结束时响应DMA请求的优点：简化系统结构，便于系统设计制造；大大减少连线数目，便于布线，减小体积，提高系统的可靠性；便于接口设计，所有与总线连接的设备均采用类似的接口；便于系统扩充、更新与灵活配置。易于实现系统的模块化；便于设备的软件设计，所有接口的软件就是对不同的口地址进行操作；便于故障诊断和维修，同时也减低了成本 内存 主存地址与Cache地址之间的转换工作由硬件完成Cache的设计思想工作是在合理的成本下提高命中率虚拟存储体系由两级存储器构成：主存——辅存多级高速缓存cache，目的是提高CPU访问主存数据或指令的效率随机访问存储器（RAM）有两类：静态的（SRAM）和动态的（DRAM） SRAM比DRAM速度更快，SRAM用来作为高速缓冲存储器（Cache），SRAM将每个位存储在一个双稳态的存储器单元中DRAM用来作为主存及图像系统的帧缓冲区，DRAM将每个位存储为对一个电容的充电由于电容非常小，在10~100ms时间内会失去电荷，所以需要周期性地刷新充电以保持信息 EEPROM是电可擦除可编程只读存储器 CISC和RISC CISC：复杂指令集计算机，进一步增强原有指令的功能，用更为复杂的新指令取代原先由软件子程序完成的功能，实现软件功能的硬件化RISC：精简指令集计算机，通过减少指令总数和简化指令功能，降低硬件设计的复杂度，使指令能单周期执行，并通过优化编译提高指令的执行速度，采用硬布线控制逻辑优化编译程序RISC和CISC在架构上的不同主要有： 在指令集的设计上，RISC指令格式和长度通常是固定的、且寻址方式少而简单、大多数指令在一个周期内就可以执行完；CISC构架下的指令长度通常是可变的、指令类型也很多、一条指令通常要若干周期才可以执行完。由于指令集多少与复杂度上的差异，使RISC的处理器可以利用简单的硬件电路设计出指令解码功能，这样易于流水线的实现。相对的CISC则需要通过只读存储器里的微码来进行解码，CISC因为指令功能与指令参数变化较大，，执行流水线作业时有较多的限制RISC架构中只有载入和存储指令可以访问存储器，数据处理指令只对寄存器的内容进行操作。为了加速程序的运算，RISC会设定多组的寄存器，并且指定特殊用途的寄存器。CISC构架则允许数据处理指令对存储器进行操作，对寄存器的要求相对不高 指令系统的不同寻址方式 寻址方式是指寻找操作数或操作数地址的方式。
指令系统中采用不同寻址方式的目的是为了在效率和方便性上找一个平衡。
立即寻址和寄存器寻址在效率上是最快的。
但是寄存器数目少，不可能将操作数都存入其中等待使用，立即寻址的使用场合也非常有限，这样就需要将数据保存在内存中，然后使用直接寻址、寄存器间接寻址、寄存器相对寻址、基址加变址寻址、相对基址基变址寻址等寻址方式将内存中的数据移入寄存器中
常用的寻址方式
立即寻址：操作数就包含在指令中直接寻址：操作数存放在内存单元中，指令中直接给出操作数所在存储单元的地址寄存器寻址：操作数存放在某一寄存器中，指令中给出存放操作数的寄存器名寄存器间接寻址：操作数存放在内存单元中，操作数所在存储单元的地址在某个寄存器中间接寻址：指令中给出操作数地址的地址相对寻址：指令地址码给出的是一个偏移量（可正可负），操作数地址等于本条指令地址加上该偏移量变址寻址：操作数地址等于变址寄存器的内容加偏移量 主存与Cache的映射方式 全相联地址映射：主存的任意一块可以映象到cache中的任意一块 发生块冲突次数最小直接相联映射：主存中一块只能映象到cache的一个特定的块中 发生块冲突次数最多组相联的映射：各区中某一块只能存入缓存的同组号的空间内，但组内个各块地址之间则可以任意存放。即从主存的组到cache的组之间采用直接映象方式，在两个对应的组内部采用全相联映象方式Cache与主存之间的映射由硬件实现，主存与辅存之间的交互是硬件与软件结合起来实现的 浮点数 [运算]对阶：将小阶向大阶对齐，同时将尾数右移n位 N=2E*F(E阶码，F尾数)规格化，即规定尾数的最高数位必须是一个有效值，即0." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/4da02c8a6b1869154823cd9876a7f52c/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-05-20T16:54:06+08:00" />
<meta property="article:modified_time" content="2022-05-20T16:54:06+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">软考知识点汇总</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-light">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <blockquote> 
 <p><strong>本篇文章为22年上半年软件设计师备考笔记</strong><br> <em>个人总结笔记，如有错误望包涵指正</em></p> 
</blockquote> 
<h2><a id="_2"></a>计算机组成和结构</h2> 
<h3><a id="_4"></a>海明校验码</h3> 
<ul><li>n个数据位，设k个校验位</li></ul> 
<p><span class="katex--display"><span class="katex-display"><span class="katex"><span class="katex-mathml"> 
      
       
        
         
         
           2 
          
         
           k 
          
         
        
          &gt; 
         
        
          = 
         
        
          n 
         
        
          + 
         
        
          k 
         
        
          + 
         
        
          1 
         
        
       
         2^{k}&gt;=n+k+1 
        
       
     </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.938208em; vertical-align: -0.0391em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height: 0.899108em;"><span class="" style="top: -3.113em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right: 0.03148em;">k</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right: 0.277778em;"></span><span class="mrel">&gt;</span></span><span class="base"><span class="strut" style="height: 0.36687em; vertical-align: 0em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right: 0.277778em;"></span></span><span class="base"><span class="strut" style="height: 0.66666em; vertical-align: -0.08333em;"></span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right: 0.222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right: 0.222222em;"></span></span><span class="base"><span class="strut" style="height: 0.77777em; vertical-align: -0.08333em;"></span><span class="mord mathdefault" style="margin-right: 0.03148em;">k</span><span class="mspace" style="margin-right: 0.222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right: 0.222222em;"></span></span><span class="base"><span class="strut" style="height: 0.64444em; vertical-align: 0em;"></span><span class="mord">1</span></span></span></span></span></span></p> 
<ul><li>整个编码系统中任意两个码字的最小距离就是该编码系统的码距。为了使一个系统能检查和纠错一个差错，码间最小距离必须至少是==<strong>3</strong>==（2n+1）</li><li>海明码是一种可以纠正一位差错的编码，是利用奇偶性来检错和纠错的校验方法</li><li>循环冗余校验码（CRC）编码方法是在k位信息码后再拼接r位的校验码，形成长度为n位的编码，其特点是检错能力极强且开销小，易于用编码器及检测电路实现。</li></ul> 
<h3><a id="_16"></a>奇偶校验</h3> 
<blockquote> 
 <p>对于奇偶校验，是由若干位有效信息，再加上一个二进制位（校验位）组成校验码，其中</p> 
 <p>奇校验"1"的个数为奇数，而偶校验"1"的个数为偶数，</p> 
 <p>只有奇数个数据位发生错误，才能发现错误。同时，奇偶校验只能查错不能纠错</p> 
</blockquote> 
<p><mark>采用模二出发运算的只有循环冗余检验CRC</mark></p> 
<h3><a id="CPU_26"></a>CPU</h3> 
<blockquote> 
 <p>指令周期：取指令，分析指令，执行指令</p> 
</blockquote> 
<p>CPU控制单元部件</p> 
<ul><li> <p>指令寄存器 IR：用来保存当前正在执行的指令 输出是<mark>指令译码器</mark>的输入 <mark>对用户完全透明</mark></p> </li><li> <p><strong>程序计数器</strong> PC：存储的总是将要执行的下一条指令的地址 <mark>程序员可以访问</mark></p> </li><li> <p>指令译码器 ID：对操作码进行测试，以便识别所要求的的操作（对现行指令进行分析，确定指令类型和指令所要完成的操作以及寻址方式，并将相应的控制命令发往相关部件）</p> </li><li> <p>状态字寄存器 PSW用于保存指令执行完成后产生的条件码，例如运算是否有溢出，结果为正还是为负，是否有进位等，此外，PSSW还保存中端和系统工作状态等信息。</p> </li><li> <p>地址寄存器 AR：用来保存当前CPU所访问的内存单元的地址</p> </li><li> <p><s>数据寄存器</s> MDR：主要用来保存操作数和运算结果，目的为了节省读取操作数所需占用的总总线和访问储存器的时间</p> </li><li> <p>地址寄存器 MAR：用来保存当前CPU所访问的内存单元地址，以便对内存的读写操作</p> </li><li> <p><s>累加器</s> AC：专门存放算术或逻辑运算的一个操作数和运算结果的寄存器</p> </li><li> <p>加法器：cpu中算术逻辑运算部件</p> </li><li> <p>ALU：CPU的执行单元，主要负责运算工作</p> </li><li> <p>控制器：控制整个计算机的各个部件有条不紊的工作，基本功能就是从内存去指令和执行指令</p> </li><li> <p>CPU依据指令周期的不同阶段来区分在内存中以二进制编码形式存放的指令和数据</p> </li></ul> 
<h3><a id="_49"></a>输入输出控制</h3> 
<ul><li>程序控制：由CPU执行程序控制数据的输入输出过程</li><li>中断控制：外设准备好输入数据或接受数据时向CPU发出中断信号，CPU响应则中断</li><li>DMA控制：CPU只需向DMA控制器下达指令，让DMA控制器来处理数据的传送，传送完毕再把信息反馈给CPU，减轻CPU负担节省系统资源</li><li> 
  <ul><li>DMA（直接主存存取）是指数据在主存与I/O设备间（即主存与外设之间）直接成块传输；CPU只需在开始和结束时作少量处理，而无需干预数据传送过程</li></ul> </li></ul> 
<h3><a id="_56"></a>总线结构</h3> 
<ul><li><mark>三总线结构</mark>：数据总线、地址总线和控制总线</li><li>CPU是在一个总线周期结束时响应DMA请求的</li><li>优点：简化系统结构，便于系统设计制造；大大<mark>减少连线数目</mark>，便于布线，减小体积，提高系统的可靠性；便于接口设计，所有与总线连接的设备均采用类似的接口；便于系统扩充、更新与灵活配置。易于实现系统的模块化；便于设备的软件设计，所有接口的软件就是对不同的口地址进行操作；便于故障诊断和维修，同时也减低了成本</li></ul> 
<h3><a id="_62"></a>内存</h3> 
<ul><li>主存地址与Cache地址之间的转换工作由硬件完成</li><li>Cache的设计思想工作是在合理的成本下提高命中率</li><li>虚拟存储体系由两级存储器构成：主存——辅存</li><li>多级高速缓存cache，目的是<mark>提高CPU访问主存数据或指令的效率</mark></li><li>随机访问存储器（RAM）有两类：静态的（SRAM）和动态的（DRAM）</li><li> 
  <ul><li>SRAM比DRAM速度更快，</li><li>SRAM用来作为高速缓冲存储器（Cache），SRAM将每个位存储在一个双稳态的存储器单元中</li><li>DRAM用来作为主存及图像系统的帧缓冲区，DRAM将每个位存储为对一个电容的充电由于电容非常小，在10~100ms时间内会失去电荷，所以需要周期性地刷新充电以保持信息</li></ul> </li><li>EEPROM是电可擦除可编程只读存储器</li></ul> 
<h3><a id="CISCRISC_74"></a>CISC和RISC</h3> 
<ul><li>CISC：复杂指令集计算机，进一步增强原有指令的功能，用更为复杂的新指令取代原先由软件子程序完成的功能，实现软件功能的硬件化</li><li>RISC：精简指令集计算机，通过减少指令总数和简化指令功能，降低硬件设计的复杂度，使指令能单周期执行，并通过优化编译提高指令的执行速度，采用硬布线控制逻辑优化编译程序</li><li>RISC和CISC在架构上的不同主要有：</li><li> 
  <ul><li>在指令集的设计上，RISC指令格式和长度通常是固定的、且寻址方式少而简单、大多数指令在一个周期内就可以执行完；CISC构架下的指令长度通常是可变的、指令类型也很多、一条指令通常要若干周期才可以执行完。由于指令集多少与复杂度上的差异，使RISC的处理器可以利用简单的硬件电路设计出指令解码功能，这样易于流水线的实现。相对的CISC则需要通过只读存储器里的微码来进行解码，CISC因为指令功能与指令参数变化较大，，执行流水线作业时有较多的限制</li><li>RISC架构中只有载入和存储指令可以访问存储器，数据处理指令只对寄存器的内容进行操作。为了加速程序的运算，RISC会设定多组的寄存器，并且指定特殊用途的寄存器。CISC构架则允许数据处理指令对存储器进行操作，对寄存器的要求相对不高</li></ul> </li></ul> 
<h3><a id="_82"></a>指令系统的不同寻址方式</h3> 
<p>寻址方式是指寻找操作数或操作数地址的方式。</p> 
<p>指令系统中采用不同寻址方式的目的是为了在效率和方便性上找一个平衡。</p> 
<p>立即寻址和寄存器寻址在效率上是最快的。</p> 
<p>但是寄存器数目少，不可能将操作数都存入其中等待使用，立即寻址的使用场合也非常有限，这样就需要将数据保存在内存中，然后使用直接寻址、寄存器间接寻址、寄存器相对寻址、基址加变址寻址、相对基址基变址寻址等寻址方式将内存中的数据移入寄存器中</p> 
<blockquote> 
 <p><strong>常用的寻址方式</strong></p> 
</blockquote> 
<ul><li>立即寻址：操作数就包含在指令中</li><li>直接寻址：操作数存放在内存单元中，指令中直接给出操作数所在存储单元的地址</li><li>寄存器寻址：操作数存放在某一寄存器中，指令中给出存放操作数的寄存器名</li><li>寄存器间接寻址：操作数存放在内存单元中，操作数所在存储单元的地址在某个寄存器中</li><li>间接寻址：指令中给出操作数地址的地址</li><li>相对寻址：指令地址码给出的是一个偏移量（可正可负），操作数地址等于本条指令地址加上该偏移量</li><li>变址寻址：操作数地址等于变址寄存器的内容加偏移量</li></ul> 
<h3><a id="Cache_102"></a>主存与Cache的映射方式</h3> 
<ul><li>全相联地址映射：主存的任意一块可以映象到cache中的任意一块 <mark>发生块冲突次数最小</mark></li><li>直接相联映射：主存中一块只能映象到cache的一个特定的块中 <mark>发生块冲突次数最多</mark></li><li>组相联的映射：各区中某一块只能存入缓存的同组号的空间内，但组内个各块地址之间则可以任意存放。即从主存的组到cache的组之间采用直接映象方式，在两个对应的组内部采用全相联映象方式</li><li><mark>Cache与主存之间的映射由硬件实现，主存与辅存之间的交互是硬件与软件结合起来实现的</mark></li></ul> 
<h3><a id="_109"></a>浮点数</h3> 
<ul><li>[运算]对阶：将小阶向大阶对齐，同时将尾数右移n位 N=2<sup>E</sup>*F(E阶码，F尾数)</li><li>规格化，即规定尾数的最高数位必须是一个有效值，即0.5&lt;|F|&lt;1，尾数用补码表示时，规格化浮点数应满足尾数最高数位与符号位不同，即当0.5&lt;=|F|&lt;=1时，应有0.1…形式；当-1&lt;=M&lt;-0.5时，应有1.0…形式</li></ul> 
<h3><a id="BISO_118"></a>BISO</h3> 
<p>在微机系统中，BISO（基本输入输出系统）保存在<mark>主板上的ROM</mark>上</p> 
<h3><a id="_122"></a>计算机系统的存储器</h3> 
<ul><li>按所处位置可分为内存和外存</li><li>按构成存储器的<mark>材料</mark>可分为磁存储器、半导体存储器和光存储器</li><li>按存储器的<mark>工作方式</mark>可分为读写存储器和只读存储器</li><li>按访问方式可分为按地址访问的存储器和按内容访问的存储器</li><li>按<mark>寻址方式</mark>可分为随机存储器、顺序存储器和直接存储器。</li><li><mark>相联存储器是</mark>一种按<mark>内容</mark>访问的存储器</li></ul> 
<h3><a id="_131"></a>中断嵌套</h3> 
<p>当系统中有多个中断请求时，中断系统按优先级进行排队。若在处理低级中断过程又有高级中断申请中断，则高级中断可以打断低级中断处理，专区处理高级中断，等处理完高级中断后再返回去处理原来的低级中断，称为中断嵌套。实现中断嵌套用后进先出的栈来保护断点和现场最有效。</p> 
<h3><a id="_135"></a>流水线</h3> 
<ul><li>流水线周期：时间最长的一段</li><li>流水线时间计算公式</li><li> 
  <ul><li>一条指令所需运行时间+（指令条数-1）*流水线周期</li><li><s>或（流水线段数+指令条数-1）*流水线周期</s></li></ul> </li><li>流水线吞吐率：指令条数/流水线时间【最大吞吐率为1取决于<mark>流水线周期</mark>】</li><li>流水线加速比：不使用流水线所需时间/使用流水线所需时间层次化结构</li><li>流水线性能度量指标：吞吐率，加速比和效率（<mark>加速比和吞吐率成正比</mark>）</li></ul> 
<h3><a id="_145"></a>程序的局限性</h3> 
<p>表现在时间局部性和空间局部性</p> 
<ul><li>时间局部性是指如果程序中的某一条指令一旦被执行，则不久的将来该指令可能再次被执行</li><li>空间局部性是指一旦程序访问了某个存储单元，则在不久的将来，其附近的存储单元也可能被访问</li></ul> 
<h3><a id="_152"></a>原码补码反码移码</h3> 
<ul><li> <p><strong>负数的补码</strong>是反码加1</p> </li><li> <p>补码运算：可以将符号位和其他位统一处理，减法也可以按加法来处理，从而简化运算部件的设计</p> </li><li> <p>移码指令中算术左移相当于对操作数进行乘2操作</p> </li><li> <p>移码表示法是在数X上怎宫颈癌一个偏移量来定义的，常用于表示浮点数中的阶码。机器字长为n时，在偏移量为2<sup>n-1</sup>的情况下，只要将补码的符号位取反便可获得相应的移码表示</p> </li></ul> 
<h3><a id="_160"></a>总线带宽</h3> 
<p>总线宽度是指总线的线数，即数据信号的并行传输能力；总线的带宽是指总线的最大数据传输率，即每秒传输的数据总量。总线宽度与时钟频率共同决定了总线的带宽 <strong>Hz/时钟周期*B=B/s</strong></p> 
<h3><a id="_164"></a>漏洞扫描</h3> 
<ul><li>漏洞扫描技术是检测远程或本地系统安全脆弱性地一种安全技术。通过与目标主机TCP/IP端口建立连接并请求某些服务（TELNET、FTP等），记录目标主机的应答，手机目标主机相关信息，从而发现目标主机某些内在的安全弱点。</li><li>一种自动检测目标主机安全弱点的程序</li><li>原理：根据系统漏洞库对系统可能存在的漏洞进行验证</li><li>黑客利用漏洞扫描系统可以发现目标主机的安全漏洞从而有针对性的对系统发起攻击</li><li>系统管理员利用漏洞扫描系统可以查找系统中存在的漏洞并进行修补从而提高系统的可靠性</li><li>漏洞扫描系统不能用于发现网络入侵者，用于检测网络入侵者的系统成为入侵检测测系统</li></ul> 
<h3><a id="_173"></a>数字签名、秘钥加密</h3> 
<ul><li>RSA基于大数定律，通常用于对消息摘要进行签名</li><li>IDEA和RC4适宜与进行数据传输加密</li><li>MD5为摘要算法；<mark>对任意长度的输入计算的到的结果长度为<strong>128</strong>位</mark></li><li>非对称加密又称为公开秘钥加密，而共享秘钥加密指对称加密</li><li> 
  <ul><li>（私钥）常见的对称加密算法有：DES、三重DES、RC-5、IDEA、AES</li></ul> </li><li>SHA-1是一种安全散列算法，确保明文在传输过程中不会被篡改</li><li>RC5是一种用于对明文进行加密的算法，适用于大量明文进行加密并传输</li><li>公钥加密算法：RSA、DSA、EIGamal、背包算法、Rabin、ECC（椭圆曲线）</li><li>私钥加密：DES</li><li><mark><strong>公钥（非对称）用于加密和认证；私钥（对称）用于解密和签名</strong></mark></li></ul> 
<h3><a id="_186"></a>信息安全和病毒防护</h3> 
<ul><li>应用级网管防火墙是内部网和外部网的隔离点，他可以对应用层的通信数据流进行监控和过滤（应用层）</li><li>包过滤防火墙对数据包的过滤依据包括：源IP地址、源端口号、目标IP地址和目标端口号</li><li>计算机病毒分类根据其感染的途径以及采用技术区分</li><li> 
  <ul><li>文件型计算机病毒感染可执行文件（包括EXE和COM文件）</li><li>引导型计算器病毒影响软盘或硬盘的引导扇区</li><li>目录型计算机病毒能够修改硬盘上存储的所有文件的地址</li><li>宏病毒感染的对象是使用某些程序创建文本文档、数据库、电子表格等文件</li></ul> </li><li>PKI体制中，为保障数字证书不被篡改而且要发送到证书主人手中，需要用CA的私钥对数字证书签名，防伪造，不可抵赖</li><li>防火墙的性能和特点</li><li> 
  <ul><li>防火墙作用：防止来自被保护区域外部的攻击；防止信息外泄和屏蔽有害信息；集中安全管理；安全审计和告警</li></ul> </li><li> 
  <ul><li>工作层次：工作层次越低，工作效率效率越高，安全性越低；反之，工作层次越高，工作效率越低，安全性越高</li><li>防火墙采用的机制：如果采用代理机制，则防火墙具有内部信息隐藏的特点，相对而言，安全性高，效率低，如果采用过滤机制，则效率高，安全性却降低了</li></ul> </li><li>数据加密防范网络监听</li><li>Window IIS服务支持的身份认证方式有：</li><li> 
  <ul><li>集成Windows身份验证（安全级别高）</li><li>摘要式身份验证</li><li>NET Passport身份验证</li><li>基本身份验证（安全级别低）</li><li></ul> </li></ul> 
<h3><a id="_208"></a>系统性能评测和可靠性基础</h3> 
<ul><li> <p>软件的可靠性指的是一个系统对于给定的时间间隔内、在给定条件下无效运作的概率</p> </li><li> <p>软件产品的可靠性与软件产品的开发方式无关</p> </li><li> <p>可靠性用**MTTF/(1+MTTF)**来度量，MTTF为平均无效故障时间</p> </li><li> <p>可用性用**MTBF/（1+MTBT）**来度量，其中MTBF为平均失效间隔时间</p> </li></ul> 
<h2><a id="_216"></a>程序语言</h2> 
<h3><a id="_218"></a>编译原理</h3> 
<ul><li>词法分析：输入-&gt;源程序、输出-&gt;记号流</li><li>语法（义）分析：输入-&gt;记号流、输出-&gt;分析树</li><li><s>中间代码生成</s></li><li><s>代码优化</s></li><li>目标代码生成</li></ul> 
<blockquote> 
 <p>反编译不能把可执行文件还原成高级语言语言代码，只能转换成功能上等价的汇编语言</p> 
</blockquote> 
<h3><a id="_228"></a>传值和引用</h3> 
<h4><a id="_230"></a>传值</h4> 
<ul><li>实现函数调用时，实参向形参传递相应类型的值</li><li>形参不能向实参传递信息</li><li><strong>实参</strong>可以是<mark>变量</mark>，也可以是<mark>常量和表达式</mark></li></ul> 
<h4><a id="_236"></a>引用</h4> 
<ul><li>将实参变量的地址传递给形参</li><li>形参是指针类型，而实参必须具有左值，变量具有左值，常量没有左值</li><li>形参和实参可以双向传递数据</li></ul> 
<h3><a id="_242"></a>编译过程</h3> 
<ul><li> <p>编译过程中为变量分配存储单元所用的地址是<mark>逻辑地址</mark>，程序运行时再映射为<mark>物理地址</mark></p> </li><li> <p>中间代码是源程序的一种内部结构表示，或称中间语言。不依赖于具体的机器，中间代码的作用是可使编译程序的结构在逻辑上更为简单明确，使用中间代码可提高编译程序的可移植性，常见的有逆波兰记号、四元式、三元式和树</p> </li><li> <p>语义分析阶段主要检查源程序是否<mark>包含</mark>语义错误</p> </li></ul> 
<h3><a id="_249"></a>程序设计语言基本概念</h3> 
<ul><li>程序运行时的用户内存空间一般划分为代码区、静态数据区、栈区和堆区，其中栈区和堆区也称为动态数据区。全局变量的存储空间在静态数据区。</li><li>编译器：将代码编译为机器码，再加以运行</li><li>解释器：将代码一句一句运行，参与运行控制，程序执行的速度慢</li><li>运行时结合是动态绑定，编译时结合是静态绑定</li></ul> 
<h3><a id="_256"></a>文法分析</h3> 
<ul><li>有限自动机是进行词法分析的适当工具</li></ul> 
<h2><a id="_260"></a>操作系统</h2> 
<h3><a id="_262"></a>存储管理</h3> 
<ul><li> <p>磁盘容量分为格式化容量和非格式化容量两种</p> </li><li> 
  <ul><li>非格式化容量=面数 * （磁道数/面）* 内圆周长 * 最大位密度</li><li>格式化容量=面数 * （磁道数/面）*（扇区数/道） * （字节数/扇区）</li></ul> </li><li> <p>磁盘调度管理中，先进行移臂调度寻找磁道，再进行旋转调度寻找扇区</p> </li><li> <p>段页式存储</p> 
  <blockquote> 
   <p>m1 n1 m2 n2 m3 n3</p> 
   <p>​ 段号 页号 页内地址</p> 
  </blockquote> 
  <ul><li>段号数量2<sup>m1-n1</sup> ；段内最大页数2<sup>m2-n2</sup> ；页的大小2<sup>m3-n3</sup></li></ul> </li><li> <p>页面变换：系统应该首先淘汰<mark>未被访问</mark>的页面，因为根据程序的局部性原理，最近未被访问的页面下次被访问的概率更小；如果页面最近都被访问过，应该淘汰<mark>未修改</mark>过得页面。因为未修改过得页面的内存和辅存一致，故淘汰时无需写回辅存，使系统页面置换代价小</p> </li><li> <p><strong>逻辑地址转物理地址</strong>：逻辑地址=页号+页内地址；物理地址=块号+页内地址<a href="https://blog.csdn.net/sinat_34166518/article/details/83278553?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522165209273916781483759129%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&amp;request_id=165209273916781483759129&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduend~default-1-83278553-null-null.142%5Ev9%5Econtrol,157%5Ev4%5Econtrol&amp;utm_term=%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E9%80%BB%E8%BE%91%E5%9C%B0%E5%9D%80%E5%92%8C%E7%89%A9%E7%90%86%E5%9C%B0%E5%9D%80%E7%9A%84%E8%BD%AC%E6%8D%A2&amp;spm=1018.2226.3001.4187">参考资料1</a><a href="https://blog.csdn.net/qq_45141428/article/details/111590540?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522165209090316781683955118%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&amp;request_id=165209090316781683955118&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~baidu_landing_v2~default-1-111590540-null-null.142%5Ev9%5Econtrol,157%5Ev4%5Econtrol&amp;utm_term=%E8%BF%9B%E7%A8%8B%E7%9A%84%E9%80%BB%E8%BE%91%E5%9C%B0%E5%9D%80%E5%92%8C%E7%89%A9%E7%90%86%E5%9C%B0%E5%9D%80%E7%9A%84%E8%BD%AC%E6%8D%A2&amp;spm=1018.2226.3001.4187">参考资料2</a></p> </li><li> 
  <ul><li>给出十进制的逻辑地址转换成物理地址</li><li> 
    <ul><li>得出，页号=逻辑地址/页面大小</li><li>页内偏移量=逻辑地址%页面大小</li><li>根据逻辑地址的页号查出物理地址的页帧号</li><li>求出物理地址=页帧号*页面大小+页内偏移量</li></ul> </li><li>十六进制的逻辑地址转换成物理地址</li><li> 
    <ul><li>将十六进制的逻辑地址转换为二进制</li><li>根据页面大小(2<sup>n</sup>)得出逻辑地址的<mark>后n位为页内地址</mark>（页内偏移量）</li><li><mark>剩下的16-n位为页号</mark>，根据页号确定页帧号，并将页帧号转换为二进制</li><li>物理地址即为页帧号+页内地址，转换为十六进制即可</li></ul> </li></ul> </li></ul> 
<h3><a id="_294"></a>进程管理</h3> 
<h4><a id="_296"></a>进程资源图</h4> 
<p><a href="https://blog.csdn.net/weixin_43616639/article/details/109403290?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522165208737416782248556050%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&amp;request_id=165208737416782248556050&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_click~default-1-109403290-null-null.142%5Ev9%5Econtrol,157%5Ev4%5Econtrol&amp;utm_term=%E8%BF%9B%E7%A8%8B%E8%B5%84%E6%BA%90%E5%9B%BE&amp;spm=1018.2226.3001.4187">参考资料</a></p> 
<ul><li>线程可共享资源。</li><li>PV操作实现资源的互斥使用</li></ul> 
<h3><a id="_303"></a>设备管理</h3> 
<h4><a id="_305"></a><strong>扫描算法</strong></h4> 
<p><strong>SCAN</strong>是选请求队列中沿磁头臂前进方向最接近于磁头所在柱面的访问请求作为下一个服务对象。</p> 
<h4><a id="FCFS_309"></a><strong>先来先服务调度算法FCFS</strong></h4> 
<p>根据访问请求的先后次序选择先提出访问请求的为之服务。</p> 
<h4><a id="SSTF_313"></a><strong>最短查找时间优先算法SSTF：</strong></h4> 
<p>以磁头移动距离的大小作为优先的因素，从当前磁头位置出发，选择离磁头最近的磁道为其服务。</p> 
<h3><a id="_317"></a>嵌入式操作系统的特点</h3> 
<ul><li>微型化</li><li>可定制</li><li>实时性</li><li>可靠性</li><li>易移植性</li></ul> 
<h2><a id="_325"></a>软件工程基础知识</h2> 
<h3><a id="_327"></a>软件工程概述</h3> 
<ul><li> <p>软件工程的基本要素：质量、过程、方法和工具</p> </li><li> <p>基于构件的软件开发，主要强调在构件软件系统时复用已有的软件“构件”，在检索到可以使用的构件后，需要针对新系统的需求对构件进行合格性检验，适应性修改，然后集成到新系统中</p> </li><li> <p>需求分析确定软件要完成的功能及非功能性要求</p> </li><li> 
  <ul><li>概要设计将需求转化为软件的模块划分，确定模块之间的调用关系</li><li>详细设计将模块进行细化，得到详细地数据结构和算法</li><li>编码根据详细设计进行代码的编写，得到可以运行的软件，并进行单元测试</li><li>需求分析输出：结构化分析模型包括数据流图、实体联系图、状态迁移图和数据字典</li></ul> </li><li> <p>需求不清晰且规模不大时采用原型化方法最合适，二数据处理领域的不太负载的软件，适用于结构化方法进行开发</p> </li><li> <p>I/O软件隐藏了I/O操作实现的细节，向用户提供的是逻辑接口，I/O软件将硬件与较高层次的软件隔离开来，而最高层软件向应用提供一个友好的、清晰且统一的接口，方便用户使用</p> </li><li> <p>瀑布模型将开发阶段描述为从一个阶段瀑布般地转换到另一个阶段的过程。 原型模型中，开发人员快速地构造整个系统或者系统的一部分以理解或澄清问题。螺旋模型将开发活动和风险管理结合起来，以减小风险。 喷泉模型开发过程模型以用户需求为动力，以对象为驱动，适合于面向对象的开发方法。 在这几种开发过程模型中，</p> 
  <ul><li>喷泉模型属于面向对象开发模型</li></ul> </li><li> 
  <ul><li>原型模型不适宜大规模软件的开发。</li><li>瀑布模型不能适应变化的需求，不够灵活</li><li>螺旋模型更适合大型的昂贵的系统级的软件应用</li></ul> </li><li> <p>喷泉模型是典型的面向对象生命周期模型，是一种以用户需求为动力，以对象作为驱动的模型。该模型克服了瀑布模型不支持软件重用和多项开发活动集成的局限性。“喷泉” 一词本身体现了迭代和无间隙特性。迭代意味着模型中的开发活动常常需要重复多次，在迭代过程中不断地完善软件系统；无间隙是指在开发活动之间不存在明显的边界</p> </li><li> <p>增量模型是一种非整体开发的模型，该模型具有较大的灵活性，适合于软件需求不明确的一种模型。使用该模型开发产品，一般是尽快构造出可运行的产品，然后在该产品的基础上再增加需要的新的构建，使产品更趋于完善，<mark>缺点不利于模块划分</mark></p> </li></ul> 
<h3><a id="_347"></a>软件过程管理</h3> 
<ul><li>敏捷方法中，重构是一种重新组织技术，重新审视需求和设计，重新明确地描述他们以符合新的和现有的需求，可以简化构建的设计二无需改变其功能或行为</li><li>软件复杂度量参数：规模，难度，结构，智能度</li><li> 
  <ul><li>极限编程XP是激发开发人员创造性、使得管理负担最小的一组技术；</li><li> 
    <ul><li>极限编程是一种轻量级（敏捷）、高效、低风险、柔性、可预测的、科学的软件开发方式。</li><li>• 4大价值观： 沟通、简单性、反馈和勇气。</li><li>• 5个原则：快速反馈、简单性假设、逐步修改、提倡更改和优质工作。</li><li>• 12个最佳实践：</li><li> 
      <ul><li>计划游戏（快速制定计划、随着细节的不断变化而完善）、</li><li>小型发布（系统的设计要能够尽可能早地交付）</li><li>隐喻（找到合适的比喻传达信息）、</li><li>简单设计（只处理当前的需求，使设计保持简单）、</li><li>测试先行（先写测试代码，然后再编写程序）、</li><li>重构（重新审视需求和设计，重新明确地描述它们以符合新的和现有的需求）、</li><li>结队编程、</li><li>集体代码所有制、</li><li>持续集成（可以按日甚至按小时为客户提供可运行的版本）、每周工作40个小时、现场客户和编码标准。</li></ul> </li></ul> </li></ul> </li><li> 
  <ul><li>水晶法Crystal认为每一个不同的项目都需要一套不同的策略、约定和方法论；</li></ul> </li><li> 
  <ul><li>并列争球法（Scrum）使用迭代的方法，其中把每30天一次的迭代成为一个冲刺，并按需求的优先级来实现产品。多个自组织和自治小组并行地递增实现产品，并通过简短的日常情况会议进行协调</li></ul> </li><li>软件过程改进框架</li><li> 
  <ul><li>过程改进基础设施</li><li>过程改进路线图</li><li>软件过程评估方法</li><li>软件过程改进计划</li></ul> </li><li>UP（统一过程）模型五个阶段</li><li> 
  <ul><li>起始阶段专注于项目的初创活动。</li></ul> </li><li> 
  <ul><li>精化阶段理解了最初的领域范围之后，进行需求分析和架构演进。</li><li>构建阶段关注系统的构建，产生实现模型</li><li>移交阶段关注于软件提交方面的工作，产生软件增量。</li><li>产生阶段运行软件并监控软件的持续使用，提供运行环境的支持，提交并评估缺陷报告和变更请求</li></ul> </li></ul> 
<blockquote> 
 <p>统一过程（UP）定义了初启阶段、精化阶段、构建阶段、移交阶段和产生阶段，每阶段达到某个里程碑时结束。其中初启阶段的里程碑是生命周期目标，精化阶段的里程碑是生命周期架构，构建阶段的里程碑是初始运作功能，移交阶段的里程碑是产品发布。</p> 
</blockquote> 
<ul><li>CMM 的分级结构及其过程描述：</li><li> 
  <ul><li>（1）初始级：软件过程的特点是无秩序或说无定规的，有时甚至是混乱的。软件过程定义几乎处于无章法、无步骤可循的状态，软件产品所取得的成功往往依赖于极个别人的努力和机遇。</li><li>（2）可重复级：已建立了基本的项目管理过程，可用于对成本、进度和功能特性进行跟踪。对类似的应用项目，有章可循并能重复以往所取得的成功。</li><li>（3）已定义级：用于管理的和工程的软件过程均已文档化、标准化，并形成了整个软件组织的标准软件过程。全部项目均采用与实际情况相吻合的、适当修改后的标准软件过程来进行操作。</li><li>（4）已管理级：软件过程和产品质量有详细的度量标准。软件过程和产品质量得到了定量的认识和控制。</li><li>（5）优化级：通过对来自过程、新概念和新技术等方面的各种有用信息的定量分析，能够不断地、持续地对促进过程进行改进。 除第一级外，每一级都设定了一组目标，如果达到了这组目标，则表明达到了这个成熟级别，自然可以向上一更为成熟的高一级别迈进。CMM 体系不主张跨级别的进化，因为从第二级开始，每一个低级别的实现均是更高级别实现的基础。</li></ul> </li><li>CMMI（0~5）【未完成级、已执行级、已管理级、已定义级、量化管理级、优化级】</li><li> 
  <ul><li>CL0（未完成的）：过程域未执行或未得到CL1中定义的所有目标。</li><li>CL1（已执行的）：其共性目标是过程将可标识的输入工作产品转换成可标识的输出工作产品，以实现支持过程域的特定目标。</li><li>CL2（已管理的）：其共性目标是集中于已管理的过程的制度化。根据组织级政策规定过程的运作将使用哪个过程，项目遵循已文档化的计划和过程描述，所有正在工作的人都有权使用足够的资源，所有工作任务和工作产品都被监控、控制、和评审。</li><li>CL3（已定义级的）：其共性目标集中于已定义的过程的制度化。过程是按照组织的裁剪指南从组织的标准过程中裁剪得到的，还必须收集过程资产和过程的度量，并用于将来对过程的改进。</li><li>CL4（定量管理的）：其共性目标集中于可定量管理的过程的制度化。使用测量和质量保证来控制和改进过程域，建立和使用关于质量和过程执行的质量目标作为管理准则。</li><li>CL5（优化的）：使用量化（统计学）手段改变和优化过程域，以满足客户的改变和持续改进计划中的过程域的功效</li></ul> </li></ul> 
<h3><a id="_397"></a>软件质量管理</h3> 
<table><thead><tr><th>功能性</th><th>可靠性</th><th>易使用性</th><th>效率</th><th>可维护性</th><th>可移植性</th></tr></thead><tbody><tr><td>适合性</td><td>成熟性</td><td>易理解性</td><td>时间特性</td><td>易分析性</td><td>适应性</td></tr><tr><td>准确性</td><td>容错性</td><td>易学性</td><td>资源特性</td><td>易改变性</td><td>易安装性</td></tr><tr><td>互用性</td><td>易恢复性</td><td>易操作性</td><td></td><td>稳定性</td><td>一致性</td></tr><tr><td>依从性</td><td></td><td></td><td></td><td>易测试性</td><td>易替换性</td></tr><tr><td>安全性</td><td></td><td></td><td></td><td></td><td></td></tr></tbody></table> 
<ul><li>功能性是指与功能及其指定的性质有关的一组软件质量；</li><li>可靠性是指衡量在规定的一段时间内和规定条件下维护性能水平的一组软件质量；</li><li>可维护性是指与软件维护的难易程度相关的一组软件属性；</li><li> 
  <ul><li>可维护性质量特性是指与软件维护的难易程度相关的一组软件属性，它包含了易分析性、稳定性、易测试性和易改变性4个子特性。</li><li>其中：易分析性是描述诊断缺陷或失效原因、判定待修改程度的难易程度的特性。</li><li>稳定性是描述修改造成难以预料的后果的风险程度，风险程度越低，稳定性越好。</li><li>易测试性是描述测试已修改软件的难易程度的特性。</li><li>易改变性是描述修改、排错或适应环境变化的难易程度。</li></ul> </li><li>易使用性是指与使用难易程度及规定或隐含用户对使用方式所做的评价相关的属性。</li><li>模块结构评审时，主要包括以下方面的评审：</li><li> 
  <ul><li>1.控制流结构：规定了处理模块与处理模块之间的流程关系。检查处理模块之间的控制转移关系与控制转移形式（调用方式）。</li><li>2.数据流结构：规定了数据模块是如何被处理模块进行加工的流程关系。检查处理模块与数据模块之间的对应关系；处理模块与数据模块之间的存取关系，如建立、删除、查询、修改等。</li><li>3.模块结构与功能结构之间的对应关系：包括功能结构与控制流结构的对应关系；功能结构与数据流结构的对应关系；每个模块的定义（包括功能、输入与输出数据）</li></ul> </li><li>McCall软件质量模型从软件产品的运行、修正和转移三个方面确定了11个质量特性，</li><li> 
  <ul><li>其中运行方面包含了正确性、可靠性、效率、完整性、使用性这些质量特性。</li><li>修正方面包含了维护性、测试性、灵活性这3个质量特性。</li><li>转移方面包含了维护性移植性、复用性、共运行性这3个质量特性。</li></ul> </li></ul> 
<h3><a id="_427"></a>软件开发项目管理</h3> 
<ul><li>Gantt图以日历为基准描述项目任务，可以清楚地表示任务的持续时间和任务之间的并行，但<mark>不能清晰的描述各个任务之间的依赖关系</mark></li><li>PERT图是一种网络模型可以明确表达任务之间的依赖关系，但<mark>不能清晰地描述各个任务之间的并行关系</mark></li><li>COCOMO</li><li> 
  <ul><li>基本模型：静态单变量模型，它用一个以已估算出来的源代码行数为自变量的函数来计算软件开发工作量</li><li>中级模型：则在用LOC为自变量的函数计算软件开发工作量的基础上，再用涉及产品、硬件、人员、项目等方面属性的影响因素来调整工作的估算</li><li>高级模型：包括中级所有特性，还不要哟啊考虑对软件工程过程中分析、设计等各步骤的影响</li></ul> </li><li>COCOMO II 估算选择：对象点、功能点和代码行</li><li>软件风险一般包括<mark>不确定性和损失</mark>两个特性</li><li>风险预测从<mark>风险发生的可能性大小</mark>以及<strong>风险发生所产生的后果是否严重</strong>两个方面评估风险</li><li>软件变更控制，配置数据库一般包括开发库、受控库和产品库</li><li>软件配置管理SCM用于整个软件工程过程，其主要目标是标识变更、控制变更、确保变更正确的实现，报告变更。</li><li> 
  <ul><li>其主要内容包括版本管理、配置支持、变更支持、过程支持、团队支持、变化报告和审计支持等</li></ul> </li><li>系统开发人员与项目管理人员在项目期内进行沟通的文档主要有系统开发计划、系统开发月报以及系统开发总结报告等项目管理文件。</li><li>用于系统开发人员与项目管理人员在项目期内进行沟通的文档主要有系统开发计划，包括工作任务分解表、PERT图、甘特图和预算分配表等。总体规划和开发合同用于与系统分析人员在系统规划和系统分析阶段的沟通。测试计划用于系统测试人员与系统开发人员之间的沟通</li></ul> 
<h4><a id="_444"></a>风险分析</h4> 
<ul><li>风险识别：试图系统化地确定对项目计划的威胁</li><li>风险预测：风险发生的可能性或概率以及风险发生时所产生的的结果</li><li>风险评估：根据风险及其发生的概率和产生的影响预测是否影响参考水平</li><li>风险控制：辅助项目组建立处理风险的策略，有效的策略应考虑风险避免、风险监控、风险管理及意外事件计划</li><li>风险暴露来确定风险优先级，风险暴露是一种量化风险影响的指标，等于风险影响乘以风险概率</li><li>风险影响是当风险发生时造成的损失</li><li>风险概率是风险发生的可能性</li><li>风险控制是风险管理的一个重要活动</li></ul> 
<h2><a id="_455"></a>系统开发与运行</h2> 
<h3><a id="_457"></a>结构化分析和设计</h3> 
<ul><li>外部实体一般为组织机构、人员、第三方系统</li><li>数据流图摆脱系统的物理内容，在逻辑上描述系统的功能、输入、输出和数据存储等，是系统逻辑模型的重要组成部分</li><li>数据流图主要由实体、数据存储、处理过程和数据流四部分组成</li><li> 
  <ul><li>在顶层数据流图中，将系统描述成一个处理过程，而其他的是与该处理过程线相关的输入输出流，因此顶层数据流图描述了系统的输入与输出</li><li>数据流图建模原则：自顶向下、从抽象到具体</li></ul> </li><li>结构化分析输出：数据流图、数据词典、加工逻辑说明、补充材料</li><li>结构化设计主要包括：</li><li> 
  <ul><li>①体系结构设计：定义软件的主要结构元素及其关系。</li><li>②数据设计：基于实体联系图确定软件涉及的文件系统的结构及数据库的表结构。</li><li>③接口设计：描述用户界面，软件和其他硬件设备、其他软件系统及使用人员的外部接口，以及各种构件之间的内部接口。</li><li>④过程设计：确定软件各个组成部分内的算法及内部数据结构，并选定某种过程的表达形式来描述各种算法</li></ul> </li></ul> 
<h3><a id="_473"></a>系统设计知识</h3> 
<ul><li>结构化分析的结果为结构化设计提供了最基本的输入信息，其关系为：</li><li> 
  <ul><li>根据加工规格说明和控制规格说明进行过程设计；</li><li>根据数据字典和实体关系图进行数据设计；</li><li>根据数据流图进行接口设计；</li><li>根据数据流图进行体系结构设计。</li></ul> </li><li>系统耦合类型</li><li> 
  <ul><li>数据耦合：一个模块访问另一个模块时，彼此之间是通过简单数据参数 （不是控制参数、公共数据结构或外部变量） 来交换输入、输出信息的。</li><li>公共耦合：若一组模块都访问同一个公共数据环境，则它们之间的耦合就称为公共耦合。公共的数据环境可以是全局数据结构、共享的通信区、内存的公共覆盖区等。</li><li>外部耦合：一组模块都访问同一全局简单变量而不是同一全局数据结构，而且不是通过参数表传递该全局变量的信息，则称之为外部耦合。</li><li>标记耦合 ：一组模块通过参数表传递记录信息，就是标记耦合。这个记录是某一数据结构的子结构，而不是简单变量。本题描述的是标记耦合。</li><li>①数据耦合：指两个模块之间有调用关系，传递的是简单的数据值，相当于高级语言中的值传递。</li><li>②标记耦合：指两个模块之间传递的是数据结构。</li><li>③控制耦合：指一个模块调用另一个模块时，传递的是控制变量，被调用模块通过该控制变量的值有选择的执行模块内的某一功能。因此，被调用模块内应具有多个功能，哪个功能起作用受调用模块控制。</li><li>④内容耦合：当一个模块直接使用另一个模块的内部数据，或通过非正常入口转入另一个模块内部时，这种模块之间的耦合称为内容耦合</li></ul> </li><li>耦合性也叫块间联系。指软件系统结构中各模块间相互联系紧密程度的一种度量。模块之间联系越紧密，其耦合性就越强，模块之间越独立则越差，</li><li> 
  <ul><li>模块间耦合的高低取决于模块间接口的复杂性，调用的方式以及传递的信息。</li></ul> </li></ul> 
<h3><a id="_492"></a>系统的测试与维护</h3> 
<ul><li>系统测试阶段的测试目标来自于<mark>需求分析阶段</mark></li><li>逆向工程是在需求分析阶段进行的</li><li>​</li></ul> 
<h2><a id="_498"></a>网络与多媒体基础知识</h2> 
<h3><a id="_500"></a>多媒体计算机</h3> 
<ul><li>国际电话电报咨询委员会（CCITT）将媒体分为感觉媒体、 表示媒体、 表现媒体、存储媒体和传输媒体5类。</li><li> 
  <ul><li>感觉媒体指直接作用于人的感觉器官.，使人严生内接感觉的媒体， 如引起听觉反应的声音、引起视觉反应的图像等；</li><li>传输媒体指传输表示媒体的物理介质，如电缆、光缆。电磁波等；</li><li>表示媒体指传输感觉媒体的中介媒体，即用于数据交换的编码，如图像编码、文本编码和声音编码等；</li><li>表现媒体是指进行信息输入和输出的媒体，如键盘、鼠标、话筒，以及显示器、打印机、喇叭等；</li><li>存储媒体指用于存储表示媒体的物理介质，如硬盘、光盘等</li></ul> </li></ul> 
<h3><a id="_509"></a>网络体系结构</h3> 
<table><thead><tr><th>名称</th><th>功能</th><th>数据类型</th><th>常见</th></tr></thead><tbody><tr><td>应用层</td><td>访问网络服务的接口</td><td>报文</td><td>Telnet、FTP、HTTP、SNMP、DNS</td></tr><tr><td>传输层</td><td>提供应用进程之间的逻辑<mark>通信</mark></td><td>数据段</td><td>TCP、UDP、SPX、进程、端口</td></tr><tr><td>网络层</td><td>为数据在结点之间传输创建逻辑链路，并分组转发数据</td><td>IP数据包</td><td>路由器，多层交换机、防火墙、IP、IPX、RIP、OSPF、ARP、ICMP</td></tr><tr><td>数据链路层</td><td>在通信的实体间建立<mark>数据链路连接</mark></td><td>帧</td><td>网卡、网桥、二层交换机</td></tr><tr><td>物理层</td><td>为数据端设备提供原始比特流的传输的通路</td><td>比特流</td><td>中继器、集线器、网线、HUB、RJ-45标准</td></tr></tbody></table> 
<h3><a id="_519"></a>网络协议</h3> 
<p>PPP 认证是可选的。PPP 扩展认证协议（Extensible Authentication Protocol，EAP） 可支持多种认证机制，并且允许使用后端服务器来实现复杂的认证过程。</p> 
<p>例如通过Radius 服务器进行Web认证时，远程访问服务器（RAS）只是作为认证服务器的代理传递请求和应答报文，并且当识别出认证成功/失败标志后结束认证过程。通常PPP支持的两个认证协议是：</p> 
<ul><li>①口令验证协议（Password Authentication Protocol，PAP）：提供了一种简单的两次握手认证方法，由终端发送用户标识和口令字，等待服务器的应答，如果认证不成功，则终止连接。这种方法不安全，因为采用文本方式发送密码，可能会被第三方窃取。</li><li>②质询握手认证协议（Challenge Handshake Authentication Protocol，CHAP）；采用三次握手方式周期地验证对方的身份。首先是逻辑链路建立后认证服务器就要发送一个挑战报文（随机数），终端计算该报文的Hash值并把结果返回服务器，然后认证服务器把收到的Hash值与自己计算的Hash值进行比较，如果匹配，则认证通过，连接得以建立，否则连接被终止。计算Hash值的过程有一个双方共享的密钥参与，而密钥是不通过网络传送的，所以CHAP是更安全的认证机制。在后续的通信过程中，每经过一个随机的间隔，这个认证过程都可能被重复，以缩短入侵者进行持续攻击的时间。值得注意的是，这种方法可以进行双向身份认证，终端也可以向服务器进行挑战，使得双方都能确认对方身份的合法性</li></ul> 
<h3><a id="Internet_528"></a>Internet应用</h3> 
<p>DNS域名查询的次序是：本地的hosts文件一&gt;本地DNS缓存一&gt;本地DNS服务器一&gt;根域名服务器</p> 
<h2><a id="_534"></a>数据结构</h2> 
<h3><a id="_536"></a>二叉树的遍历</h3> 
<p><a href="https://blog.csdn.net/xikangsoon/article/details/113842584?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522165252922116782248572048%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&amp;request_id=165252922116782248572048&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduend~default-1-113842584-null-null.142%5Ev9%5Econtrol,157%5Ev4%5Econtrol&amp;utm_term=%E4%BA%8C%E5%8F%89%E6%A0%91%E5%85%88%E5%BA%8F%E9%81%8D%E5%8E%86%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86&amp;spm=1018.2226.3001.4187">参考资料</a></p> 
<p><img src="https://images2.imgbox.com/5a/06/NJjeP63U_o.png" alt="在这里插入图片描述"></p> 
<h3><a id="_543"></a>数组、矩阵和广义表</h3> 
<p><span class="katex--display"><span class="katex-display"><span class="katex"><span class="katex-mathml"> 
      
       
        
         
          
          
            i 
           
          
            ( 
           
          
            i 
           
          
            + 
           
          
            1 
           
          
            ) 
           
          
         
           2 
          
         
        
          + 
         
        
          j 
         
        
          + 
         
        
          1 
         
        
       
         \frac{i(i+1)}{2}+j+1 
        
       
     </span><span class="katex-html"><span class="base"><span class="strut" style="height: 2.113em; vertical-align: -0.686em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 1.427em;"><span class="" style="top: -2.314em;"><span class="pstrut" style="height: 3em;"></span><span class="mord"><span class="mord">2</span></span></span><span class="" style="top: -3.23em;"><span class="pstrut" style="height: 3em;"></span><span class="frac-line" style="border-bottom-width: 0.04em;"></span></span><span class="" style="top: -3.677em;"><span class="pstrut" style="height: 3em;"></span><span class="mord"><span class="mord mathdefault">i</span><span class="mopen">(</span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right: 0.222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right: 0.222222em;"></span><span class="mord">1</span><span class="mclose">)</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.686em;"><span class=""></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mspace" style="margin-right: 0.222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right: 0.222222em;"></span></span><span class="base"><span class="strut" style="height: 0.85396em; vertical-align: -0.19444em;"></span><span class="mord mathdefault" style="margin-right: 0.05724em;">j</span><span class="mspace" style="margin-right: 0.222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right: 0.222222em;"></span></span><span class="base"><span class="strut" style="height: 0.64444em; vertical-align: 0em;"></span><span class="mord">1</span></span></span></span></span></span></p> 
<ul><li>根据邻接矩阵的定义，行列数都为结点个数，结点数为5，因此邻居矩阵行列数均为5，即5*%的矩阵。</li><li>根据邻接表的定义，一个顶点的表结点个数为其邻接顶点的个数，顶点2有2个邻接顶点，顶点3有2个邻接顶点</li></ul> 
<h3><a id="_554"></a>线性结构</h3> 
<h4><a id="_556"></a>布鲁特-福斯模式匹配算法</h4> 
<p><span class="katex--display"><span class="katex-display"><span class="katex"><span class="katex-mathml"> 
      
       
        
        
          比 
         
        
          较 
         
        
          次 
         
        
          数 
         
        
          = 
         
        
          ( 
         
        
          n 
         
        
          − 
         
        
          m 
         
        
          + 
         
        
          1 
         
        
          ) 
         
        
          ∗ 
         
        
          m 
         
         
        
          n 
         
        
          : 
         
        
          主 
         
        
          串 
         
         
        
          m 
         
        
          : 
         
        
          模 
         
        
          式 
         
        
          串 
         
        
       
         比较次数=(n-m+1)*m \\ n:主串 \\ m:模式串 
        
       
     </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.36687em; vertical-align: 0em;"></span><span class="mord cjk_fallback">比</span><span class="mord cjk_fallback">较</span><span class="mord cjk_fallback">次</span><span class="mord cjk_fallback">数</span><span class="mspace" style="margin-right: 0.277778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right: 0.277778em;"></span></span><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right: 0.222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right: 0.222222em;"></span></span><span class="base"><span class="strut" style="height: 0.66666em; vertical-align: -0.08333em;"></span><span class="mord mathdefault">m</span><span class="mspace" style="margin-right: 0.222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right: 0.222222em;"></span></span><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord">1</span><span class="mclose">)</span><span class="mspace" style="margin-right: 0.222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right: 0.222222em;"></span></span><span class="base"><span class="strut" style="height: 0.43056em; vertical-align: 0em;"></span><span class="mord mathdefault">m</span></span><span class="mspace newline"></span><span class="base"><span class="strut" style="height: 0.43056em; vertical-align: 0em;"></span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right: 0.277778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right: 0.277778em;"></span></span><span class="base"><span class="strut" style="height: 0em; vertical-align: 0em;"></span><span class="mord cjk_fallback">主</span><span class="mord cjk_fallback">串</span></span><span class="mspace newline"></span><span class="base"><span class="strut" style="height: 0.43056em; vertical-align: 0em;"></span><span class="mord mathdefault">m</span><span class="mspace" style="margin-right: 0.277778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right: 0.277778em;"></span></span><span class="base"><span class="strut" style="height: 0em; vertical-align: 0em;"></span><span class="mord cjk_fallback">模</span><span class="mord cjk_fallback">式</span><span class="mord cjk_fallback">串</span></span></span></span></span></span></p> 
<h4><a id="_564"></a>二叉树</h4> 
<ul><li>1.完全二叉树：除最后一层外，每一层上的节点数均达到最大值；在最后一层上只缺少右边的若干结点.</li><li>2.平衡二叉树（AVL）：它或者是一颗空树，或者具有以下性质的二叉树：它的左子树和右子树的深度之差的绝对值不超过1，且它的左子树和右子树都是一颗平衡二叉树.</li><li>3.最优二叉树:哈夫曼树</li><li>4.满二叉树:每一层上的节点数均达到最大值</li></ul> 
<h5><a id="_571"></a>顺序存储</h5> 
<ul><li>左子树=根节点*2</li><li>右子树=根节点*2+1</li></ul> 
<h3><a id="_576"></a>算法分析及常用算法</h3> 
<ul><li>1、分治法特征：对于一个规模为n的问题，若该问题可以容易地解决（比如说规模n较小）则直接解决；否则将其分解为k个规模较小的子问题，这些子问题互相独立且与原问题形式相同，递归地解这些子问题，然后将各子问题的解合并得到原问题的解。</li><li>2、动态规划法：在求解问题中，对于每一步决策，列出各种可能的局部解，再依据某种判定条件，舍弃那些肯定不能得到最优解的局部解，在每一步都经过筛选，以每一步都是最优解来保证全局是最优解。</li><li>3、回溯法：回溯法是一种选优搜索法，按选优条件向前搜索，以达到目标。但当搜索到某一步时，发现原先选择并不优或达不到目标，就退回一步重新选择。这种走不通就退回再走的技术就是回溯法。</li><li>4、贪心法：总是做出在当前来说是最好的选择，而并不从整体上加以考虑，它所做的每步选择只是当前步骤的局部最优选择，但从整体来说不一定是最优的选择。由于它不必为了寻找最优解而穷尽所有可能解，因此其耗费时间少，一般可以快速得到满意的解，但得不到最优解。</li></ul> 
<h2><a id="_583"></a>面向对象技术</h2> 
<h3><a id="_585"></a>面向对象的基本概念</h3> 
<blockquote> 
 <p>面向对象分析的目的是为了获得对应用问题的理解，确定系统的功能、性能要求。</p> 
</blockquote> 
<blockquote> 
 <p>面向对象分析包含5个活动：认定对象、组织对象、描述对象间的相互作用、定义对象的操作和定义对象的内部信息。</p> 
</blockquote> 
<blockquote> 
 <p>而分析阶段最重要的是理解问题域的概念，其结果将影响整个工作。经验表明，从应用定义域概念标识对象是非常合理的。因此，面向对象分析的第一步就是确定问题域</p> 
</blockquote> 
<ul><li>参数多态：应用广泛、最纯的多态。</li><li>包含多态：同样的操作可用于一个类型及其子类型。包含多态一般需要进行运行时的类型检查。</li><li>强制多态：编译程序通过语义操作，把操作对象的类型强行加以变换，以符合函数或操作符的要求。</li><li>过载多态：同一个名（操作符﹑函数名）在不同的上下文中有不同的类型。</li></ul> 
<h3><a id="_598"></a>面向对象程序设计</h3> 
<ul><li>在采用面向对象技术开发系统时，主要步骤有面向对象分析、面向对象设计、面向对象程序设计和面向对象测试。</li><li> 
  <ul><li>面向对象分析主要包括：认定对象、组织对象、描述对象间的相互作用、定义对象的操作、定义对象的内部信息。</li><li>面向对象设计是设计分析模型和实现相应源代码。</li><li>面向对象程序设计选择合适的面向对象程序设计语言，将程序组织为相互协作的对象集合，每个对象表示某个类的实例，类通过继承等关系进行组织。</li><li>面向对象测试是尽可能早的开始进行系统测试，以发现系统中可能存在的错误并进行修复，进而保证系统质量。</li></ul> </li></ul> 
<h3><a id="_606"></a>面向对象分析与设计方法</h3> 
<ul><li> <p>开-闭原则（Open-Closed Principle）是面向对象的可复用设计（Object Oriented Design，OOD）的基石。开-闭原则是指一个软件实体应当对扩展开放，对修改关闭，即在设计 一个模块的时候，应当使这个模块可以在不被修改的前提下被扩展。满足开-闭原则的系统可以通过扩展己有的软件系统，提供新的能力和行为，以满足对软件的新需求，使软件系统有一定的适应性和灵活性；因为已有的软件模块，特别是最重要的抽象层模块不能再修改，这就使变化中的软件系统有一定的稳定性和延续性；满足开-闭原则的系统具备更好的可复用性与可维护性。 在面向对象编程中，通过抽象类及接口，规定了具体类的特征作为抽象层，相对稳定，从而满足“对修改关闭”的要求；而从抽象类导出的具体类可以改变系统的行为， 从而满足对扩展开放。</p> </li><li> <p>里氏代换原则（Liskov Substitution Principle，LSP）是指一个软件实体如果使用的是—个基类的话，那么一定适用于其子类，而且软件系统觉察不出基类对象和子类对象的区别，也就是说，在软件系统中把基类都替换成它的子类，程序的行为没有变化。但需要注意的是，里氏代换原则中仅仅指出了用子类的对象去代替基类的对象，而反过来的代换则是不成立的。例如，如果一个软件模块中使用的是一个子类对象，那么使用父类 对象去代换子类对象则可能产生错误。用一句简单的话概括：任何基类对象可以出现的地方，子类对象一定可以代替基类对象。</p> </li><li> <p>依赖倒转原则（Dependence Inversion Principle，DIP）就是要依赖于抽象，而不依赖于实现，或者说要针对接口编程，不要针对实现编程。系统中进行设计和实现的时候应 当使用接口和抽象类进行变量类型声明、参数类型声明、方法返回类型说明，以及数据 类型的转换等，而不要用具体类进行上述操作。要保证做到这一点，一个具体类应当只 实现接口和抽象类中声明过的方法，而不要给出多余的方法。 传统的过程性系统的设计办法倾向于使高层次的模块依赖于低层次的模块，抽象层次依赖于具体层次。依赖倒转原则就是把这个不良的依赖关系倒转过来。面向对象设计 的重要原则是创建抽象层次，并且从该抽象层次导出具体层次，具体层次给出不同的实现。继承关系就是一种从抽象化到具体化的导出。抽象层包含的应该是应用系统的业务 逻辑和宏观的、对整个系统来说重要的战略性决定，而具体层次含有的是一些次要的与 实现有关的算法和逻辑，以及战术性的决定，带有一定的偶然性选择。从复用的角度来说，高层抽象的模块是应当复用的，而且是复用的重点，因为它含有一个应用系统最重 要的宏观业务逻辑，是较为稳定的部分。而在传统的过程性设计中，复用则侧重于具体层次模块的复用。 使用依赖倒转原则时建议不依赖于具体类，即程序中所有的依赖关系都应该终止于抽象类或者接口。尽量做到：任何变量都不应该持有一个指向具体类的指针或者引用； 任何类都不应该从具体类派生；任何方法都不应该覆写它的任何基类中的己经实现的方法。</p> </li><li> <p>实体类主要负责数据和业务逻辑；边界类负责和用户进行交互，即用户界面；控制类则负责实体类和界面类的交互。</p> </li><li> <p>桥接模式是一种结构型设计模式。</p> </li><li> 
  <ul><li>Bridge模式基于类的最小设计原则，通过使用封装、聚合及继承等行为让<mark>不同的类承担不同的职责</mark>。将类的<mark>抽象部分和它的实现部分分离开</mark>来，使它们可以独立地变化</li></ul> </li><li> <p><mark>组合（Composite）模式</mark>将对象组合成树形结构以<mark>表示“部分-整体”的层次</mark>结构，使得用户对单个对象和组合对象的使用具有一致性。适用于：想表示对象的部分-整体层次结构；希望用户忽略组合对象与单个对象的不同，用户将统一地使用组合结构中的所有对象。</p> </li><li> <p><mark>外观（Facade）模式</mark>为子系统中的一组接口提供一个一致的界面，Fapde模式定义了一个高层接口，这个接口使得这一子系统更加容易使用。适用于：要为一个<mark>复杂子系统提供一个简单接口</mark>时，子系统往往因为不断演化而变得越来越复杂；客户程序与抽象类的实现部分之间存在着很大的依赖性；当需要构建一个层次结构的子系统时，使用Fapde模式定义子系统中每层的入口点。</p> </li><li> <p><mark>享元（Flyweight）模式</mark>运用共享技术有效地支持大量细粒度的对象。适用于：一个应用程序使用了大量的对象；完全由于使用<mark>大量的对象，造成很大的存储开销</mark>；对象的大多数状态都可变为外部状态；如果删除对象的外部状态，那么可以用相对较少的共享对象取代很多组对象：应用程序不依赖于对象标识。</p> </li><li> <p><mark>装饰器（Decorator）模式</mark>描述了以透明围栏来支持修饰的类和对象的关系，<mark>动态地给一个对象添加一些额外的职责</mark>，从增加功能的角度来看，装饰器模式相比生成子类更加灵活。适用于：在不影响其他对象的情况下，以动态、透明的方式给单个对象添加职责；处理那些可以撤销的职责；当不能采用生成子类的方式进行扩充时。</p> </li><li> <p>==工厂方法（Factory Method）==定义一个用于创建对象的接口，<mark>让子类决定将哪-个类实例化</mark>，使一个类的实例化延迟到其子类。适用于：当一个类不知道它所必须创建的对象的类的时候；当一个类希望由它的子类来指定它所创建的对象的时候；当类将创建对象的职责委托给多个帮助子类中的某一个，并且希望将哪一个帮助子类是代理者这一信息局部化的时候。</p> </li><li> <p><mark>观察者（Observer）模式</mark>定义对象间的一种一对多的依赖关系，当<mark>一个对象的状态发生改变</mark>时，<mark>所有依赖于它的对象都得到通知并被自动更新</mark>。适用于：当一个抽象模型有两个方面，其中一个方面依赖于另一个方面，将这两者封装在独立的对象中以使它们可以各自独立地改变和复用；当对一个对象的改变需要同时改变其他对象，而不知道具体有多少对象有待改变时；当一个对象必须通知其他对象，而它又不能假定其他对象是谁，即不希望这些对象是紧耦合的。</p> </li><li> <p>中介者（Mediator）用一个中介对象来<mark>封装一系列的对象交互</mark>。中介者使各对象<mark>不需要显式地相互引用</mark>，从而使其耦合松散，而且可以独立地改变它们之间的交互。适用于：<strong>一组对象以定义良好但是复杂的方式进行通信，产生的相互依赖关系结构混乱且难以理解</strong>；一个对象引用其他很多对象并且直接与这些对象通信，导致难以复用该对象；想定制一个分布在多个类中的行为，而又不想生成太多的子类。欲使一个后端数据模型能够被多个前端用户界面连接，采用中介者模式最合适。</p> </li><li> <p><mark>生成器（Builder）模式</mark>将一个复杂对象的<strong>构建与它的表示分离</strong>，使得同样的构建过程可以创建不同的表示。生成器模式适用于以下几种情况：</p> </li><li> 
  <ul><li>①当创建复杂对象的算法应该独立于该对象的组成部分以及它们的装配方式时；</li><li>②当构造过程必须允许被构造的对象有不同的表示时。</li></ul> </li><li> <p>工厂方法（Factory Method）定义一个用于创建对象的接口，让子类决定将哪一个类实例化，使一个类的实例化延迟到其子类。工厂方法适用于以下几种情况：</p> </li><li> 
  <ul><li>①当一个类不知道它所必须创建的对象的类的时候；</li></ul> </li><li> 
  <ul><li>②当一个类希望由它的子类来指定它所创建的对象的时候；</li></ul> </li><li> 
  <ul><li>③当类将创建对象的职责委托给多个帮助子类中的某一个，并且你希望将哪一个帮助子类是代理者这一信息局部化的时候。</li></ul> </li><li> <p>原型（Prototype）模式用原型实例指定创建对象的种类，并且通过拷贝这个原型来创建新的对象。原型模式适用于以下几种情况：</p> </li><li> 
  <ul><li>①当一个系统应该独立于它的产品创建、构成和表示时；</li><li>②当要实例化的类是在运行时刻指定时，例如，通过动态装载；</li><li>③为了避免创建一个与产品类层次平行的工厂类层次时；</li><li>④当一个类的实例只能有几个不同状态组合中的一种时，建立相应数目的原型并克隆它们可能比每次用合适的状态手工实例化该类更方便一些。</li></ul> </li><li> <p>单例（Singleton）设计模式是一种创建型模式，其意图是保证一个类仅有一个实例，并提供一个访问这个唯一实例的全局访问点。单例模式适用于以下情况：</p> </li><li> 
  <ul><li>①当类只能有一个实例而且客户可以从一个众所周知的访问点访问它时；</li><li>②当这个唯一实例应该是通过子类化可扩展的，并且客户应该无须更改代码就能使用一个扩展的实例时</li></ul> </li></ul> 
<h2><a id="_639"></a>数据库技术</h2> 
<h3><a id="_641"></a>数据库基础知识</h3> 
<ul><li>数据库通常采用三级模式结构，其中，</li><li> 
  <ul><li>视图对应外模式、</li><li>基本表对应模式、</li><li>存储文件对应内模式</li></ul> </li><li>物理独立性是指的内模式发生变化，只需要调整模式与内模式之间的映像，而不用修改应用程序。逻辑独立性是指的模式发生变化，只需要调整外模式与模式之间的映像，而不用修改应用程序</li></ul>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/15be9dc374acadabfd91b26cfb32cb8f/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">gitlab 生成ssh密匙</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/e64b4ad5f1d5af8159698aa92e7da2b7/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">SQLSERVER,MySQL JSON字段解析</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>