<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Qt实现自动补充功能的QLineEdit - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Qt实现自动补充功能的QLineEdit" />
<meta property="og:description" content="一、非使用QCompleter版
-------------------------------------CompleteLineEdit.h-------------------------------------
#ifndef COMPLETELINEEDIT_H
#define COMPLETELINEEDIT_H
#include &lt;QtGui/QLineEdit&gt;
#include class QListView;
class QStringListModel;
class QModelIndex;
class CompleteLineEdit : public QLineEdit {
Q_OBJECT
public:
CompleteLineEdit(QStringList words, QWidget *parent = 0);
public slots:
void setCompleter(const QString &amp;text); // 动态的显示完成列表
void completeText(const QModelIndex &amp;index);
// 点击完成列表中的项，使用此项自动完成输入的单词
protected:
virtual void keyPressEvent(QKeyEvent *e);
virtual void focusOutEvent(QFocusEvent *e);
private:
QStringList words; // 整个完成列表的单词
QListView *listView; // 完成列表
QStringListModel *model; // 完成列表的model
};
#endif // COMPLETELINEEDIT_H" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/aa99bbfab72a6038431e93bebc440497/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2020-04-08T20:53:17+08:00" />
<meta property="article:modified_time" content="2020-04-08T20:53:17+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Qt实现自动补充功能的QLineEdit</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p><strong>一、非使用QCompleter版</strong><br> <img src="https://images2.imgbox.com/03/1b/VUgvXRFd_o.png" alt="在这里插入图片描述"></p> 
<p>-------------------------------------CompleteLineEdit.h-------------------------------------<br> #ifndef COMPLETELINEEDIT_H<br> #define COMPLETELINEEDIT_H</p> 
<p>#include &lt;QtGui/QLineEdit&gt;<br> #include </p> 
<p>class QListView;<br> class QStringListModel;<br> class QModelIndex;</p> 
<p>class CompleteLineEdit : public QLineEdit {<!-- --></p> 
<p>Q_OBJECT</p> 
<p>public:</p> 
<p>CompleteLineEdit(QStringList words, QWidget *parent = 0);</p> 
<p>public slots:</p> 
<p>void setCompleter(const QString &amp;text); // 动态的显示完成列表</p> 
<p>void completeText(const QModelIndex &amp;index);<br> // 点击完成列表中的项，使用此项自动完成输入的单词</p> 
<p>protected:</p> 
<p>virtual void keyPressEvent(QKeyEvent *e);</p> 
<p>virtual void focusOutEvent(QFocusEvent *e);</p> 
<p>private:</p> 
<p>QStringList words; // 整个完成列表的单词</p> 
<p>QListView *listView; // 完成列表</p> 
<p>QStringListModel *model; // 完成列表的model</p> 
<p>};<br> #endif // COMPLETELINEEDIT_H</p> 
<p>-------------------------------------CompleteLineEdit.cpp-------------------------------------<br> #include “CompleteLineEdit.h”</p> 
<p>#include </p> 
<p>#include &lt;QtGui/QListView&gt;</p> 
<p>#include &lt;QtGui/QStringListModel&gt;</p> 
<p>#include </p> 
<dl> 
 
   CompleteLineEdit::CompleteLineEdit(QStringList words, QWidget *parent) 
  
 <dd>
   QLineEdit(parent), words(words) { 
 </dd> 
</dl> 
<p>listView = new QListView(this);</p> 
<p>model = new QStringListModel(this);</p> 
<p>listView-&gt;setWindowFlags(Qt::ToolTip);</p> 
<p>connect(this, SIGNAL(textChanged(const QString &amp;)), this, SLOT(setCompleter(const QString &amp;)));</p> 
<p>connect(listView, SIGNAL(clicked(const QModelIndex &amp;)), this, SLOT(completeText(const QModelIndex &amp;)));</p> 
<p>}</p> 
<p>void CompleteLineEdit::focusOutEvent(QFocusEvent *e) {<!-- --></p> 
<p>//listView-&gt;hide();<br> }</p> 
<p>void CompleteLineEdit::keyPressEvent(QKeyEvent *e) {<!-- --></p> 
<p>if (!listView-&gt;isHidden()) {<!-- --></p> 
<pre><code>  int key = e-&gt;key();

  int count = listView-&gt;model()-&gt;rowCount();

  QModelIndex currentIndex = listView-&gt;currentIndex();

  if (Qt::Key_Down == key) {

      // 按向下方向键时，移动光标选中下一个完成列表中的项

      int row = currentIndex.row() + 1;

      if (row &gt;= count) {

         row = 0;
      }
      QModelIndex index = listView-&gt;model()-&gt;index(row, 0);

     listView-&gt;setCurrentIndex(index);

   } else if (Qt::Key_Up == key) {

      // 按向下方向键时，移动光标选中上一个完成列表中的项

      int row = currentIndex.row() - 1;

      if (row &lt; 0) {

         row = count - 1;
      }
    QModelIndex index = listView-&gt;model()-&gt;index(row, 0);

     listView-&gt;setCurrentIndex(index);

   } else if (Qt::Key_Escape == key) {

      // 按下Esc键时，隐藏完成列表

     listView-&gt;hide();

   } else if (Qt::Key_Enter == key || Qt::Key_Return == key) {

      // 按下回车键时，使用完成列表中选中的项，并隐藏完成列表

      if (currentIndex.isValid()) {

         QString text = listView-&gt;currentIndex().data().toString();

         setText(text);
      }

     listView-&gt;hide();

   } else {

      // 其他情况，隐藏完成列表，并使用QLineEdit的键盘按下事件

     listView-&gt;hide();

     QLineEdit::keyPressEvent(e);
   }
</code></pre> 
<p>} else<br> {<!-- --><br> QLineEdit::keyPressEvent(e);<br> }<br> }</p> 
<p>void CompleteLineEdit::setCompleter(const QString &amp;text) {<!-- --></p> 
<p>if (text.isEmpty())<br> {<!-- --><br> listView-&gt;hide();<br> return;<br> }</p> 
<p>if ((text.length() &gt; 1) &amp;&amp; (!listView-&gt;isHidden())) {<!-- --></p> 
<pre><code>  return;
</code></pre> 
<p>}</p> 
<p>// 如果完整的完成列表中的某个单词包含输入的文本，则加入要显示的完成列表串中</p> 
<p>QStringList sl;</p> 
<p>foreach(QString word, words) {<!-- --></p> 
<pre><code>  if (word.contains(text)) {

      sl &lt;&lt; word;
   }
</code></pre> 
<p>}</p> 
<p>model-&gt;setStringList(sl);</p> 
<p>listView-&gt;setModel(model);</p> 
<p>if (model-&gt;rowCount() == 0) {<!-- --></p> 
<pre><code>  return;
</code></pre> 
<p>}</p> 
<p>// Position the text edit</p> 
<p>listView-&gt;setMinimumWidth(width());</p> 
<p>listView-&gt;setMaximumWidth(width());</p> 
<p>QPoint p(0, height());</p> 
<p>int x = mapToGlobal§.x();</p> 
<p>int y = mapToGlobal§.y() + 1;</p> 
<p>listView-&gt;move(x, y);</p> 
<p>listView-&gt;show();<br> }</p> 
<p>void CompleteLineEdit::completeText(const QModelIndex &amp;index) {<!-- --></p> 
<p>QString text = index.data().toString();</p> 
<p>setText(text);</p> 
<p>listView-&gt;hide();</p> 
<p>}</p> 
<p>-------------------------------------main.cpp----------------------------------<br> #include &lt;QtGui/QApplication&gt;</p> 
<p>#include “CompleteLineEdit.h”</p> 
<p>#include </p> 
<p>#include </p> 
<p>#include </p> 
<p>int main(int argc, char *argv[]) {<!-- --></p> 
<p>QApplication a(argc, argv);</p> 
<p>QStringList sl = QStringList() &lt;&lt; “Biao” &lt;&lt; “Bin” &lt;&lt; “Huang” &lt;&lt; “Hua” &lt;&lt; “Hello” &lt;&lt; “BinBin” &lt;&lt; “Hallo”;</p> 
<p>QWidget widgetw;</p> 
<p>CompleteLineEdit * edit= new CompleteLineEdit(sl);</p> 
<p>QPushButton *button = new QPushButton(“Button”);</p> 
<p>QHBoxLayout *layout = new QHBoxLayout();</p> 
<p>layout-&gt;addWidget(edit);</p> 
<p>layout-&gt;addWidget(button);</p> 
<p>widgetw.setLayout(layout);</p> 
<p>widgetw.show();</p> 
<p>CompleteLineEdit e(sl);<br> e.show();<br> return a.exec();</p> 
<p>}<br> (以上转自：http://www.cppblog.com/biao/archive/2009/10/31/99873.html)</p> 
<p>二、使用QCompleter版（待更…）</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/733cdcb15f2204ce64df495104119fb3/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">感叹号：Invalid location of tag</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/3d0648c2b495bbb05420f33bb10d6b9c/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">STM32开发，使用HAL库函数实现按键（中断和普通扫描）控制LED灯</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>