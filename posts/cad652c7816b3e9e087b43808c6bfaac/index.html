<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>史上最简单，一步集成侧滑(删除)菜单，高仿QQ、IOS。 - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="史上最简单，一步集成侧滑(删除)菜单，高仿QQ、IOS。" />
<meta property="og:description" content="本篇文章已授权微信公众号 guolin_blog （郭霖）独家发布
转载请标明出处：
gold.xitu.io/post/58285e…
本文出自:【张旭童的稀土掘金】(gold.xitu.io/user/56de21…)
代码传送门：喜欢的话，随手点个star。多谢
github.com/mcxtzhang/S…
重要的话 开头说，not for the RecyclerView or ListView, for the Any ViewGroup. 本控件不依赖任何父布局，不是针对 RecyclerView、ListView，而是任意的ViewGroup里的childView都可以使用侧滑(删除)菜单。
支持任意ViewGroup、0耦合、史上最简单。
概述 本控件从撸出来在项目使用至今已经过去7个月，距离第一次将它push至github上，也已经2月&#43;。（之前，我发表过一篇文章。传送门:blog.csdn.net/zxt0601/art…, 里面详细描述了本控件V1.0版本是怎么实现的。）
期间有很多朋友在评论、issue里提出了一些改进意见，例如支持设置滑动方向（左右）、高仿QQ的交互、支持GridLayoutManager等，以及一些bug。已经被我全部实、修复。并且将其打包至jitpack，引入更方便。和第一版相比，改动挺多的。故将其整理，新发一版。
那么本文先从如何使用它讲起，然后介绍它包含的特性、支持的属性。最后就几个难点和冲突的解决进行讲解。
代码传送门：喜欢的话，随手点个star。多谢
github.com/mcxtzhang/S…
先上几个gif给各位看官感受一下最新版的魅力（以下版本都顺便展示了可选的双向滑动）
本控件最大魅力就是0耦合,所以先上配合我另一个库组装的效果(ItemDecorationIndexBar &#43; SwipeMenuLayout)：
(ItemDecorationIndexBar : github.com/mcxtzhang/I…)
Android Special Version （无阻塞式，侧滑菜单展开时，依然可以展开其他侧滑菜单，同时上一个菜单会自动关闭）:
GridLayoutManager （和上图的代码比，只需修改RecyclerView的LayoutManager。）:
LinearLayout （不需任何修改，连LinearLayout也可以简单的实现侧滑菜单）:
iOS interaction （阻塞式交互，高仿QQ，侧滑菜单展开式，屏蔽其他ITEM所有操作）:
使用： Step 1. 在项目根build.gradle文件中增加JitPack仓库依赖。
allprojects { repositories { ... maven { url &#34;https://jitpack.io&#34; } } }复制代码 Step 2. Add the dependency
dependencies { compile &#39;com." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/cad652c7816b3e9e087b43808c6bfaac/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2016-11-14T01:28:57+08:00" />
<meta property="article:modified_time" content="2016-11-14T01:28:57+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">史上最简单，一步集成侧滑(删除)菜单，高仿QQ、IOS。</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <div class="article-content"> 
 <blockquote> 
  <p>本篇文章已授权微信公众号 guolin_blog （郭霖）独家发布</p> 
  <p>转载请标明出处：<br><a href="https://link.juejin.im?target=http%3A%2F%2Fgold.xitu.io%2Fpost%2F58285ebf0ce4630056046007" rel="nofollow">gold.xitu.io/post/58285e…</a><br>本文出自:<a href="https://link.juejin.im?target=http%3A%2F%2Fgold.xitu.io%2Fuser%2F56de210b816dfa0052e66495" rel="nofollow">【张旭童的稀土掘金】</a>(<a href="https://link.juejin.im?target=http%3A%2F%2Fgold.xitu.io%2Fuser%2F56de210b816dfa0052e66495" rel="nofollow">gold.xitu.io/user/56de21…</a>)<br>代码传送门：喜欢的话，随手点个star。多谢<br><a href="https://link.juejin.im?target=https%3A%2F%2Fgithub.com%2Fmcxtzhang%2FSwipeDelMenuLayout" rel="nofollow">github.com/mcxtzhang/S…</a></p> 
 </blockquote> 
 <hr> 
 <h2 id="-not-for-the-recyclerview-or-listview-for-the-any-viewgroup-">重要的话 开头说，not for the RecyclerView or ListView, for the Any ViewGroup.</h2> 
 <p>本控件<strong>不依赖任何</strong>父布局，不是针对 RecyclerView、ListView，而是<strong>任意的ViewGroup</strong>里的childView都可以使用侧滑(删除)菜单。<br>支持任意ViewGroup、0耦合、史上最简单。</p> 
 <h2 id="-">概述</h2> 
 <p>本控件从撸出来在项目使用至今已经过去7个月，距离第一次将它push至github上，也已经2月+。（之前，我发表过一篇文章。传送门:<a href="https://link.juejin.im?target=http%3A%2F%2Fblog.csdn.net%2Fzxt0601%2Farticle%2Fdetails%2F52303781" rel="nofollow">blog.csdn.net/zxt0601/art…</a>, 里面详细描述了本控件V1.0版本是怎么实现的。）</p> 
 <p>期间有很多朋友在评论、issue里提出了一些<strong>改进</strong>意见，例如支持设置滑动方向（左右）、高仿QQ的交互、支持GridLayoutManager等，以及一些<strong>bug</strong>。已经被我<strong>全部实、修复</strong>。并且将其打包至jitpack，引入<strong>更方便</strong>。和第一版相比，改动挺多的。故将其整理，新发一版。</p> 
 <p>那么本文先从如何使用它讲起，然后介绍它包含的特性、支持的属性。最后就几个难点和冲突的解决进行讲解。</p> 
 <p>代码传送门：喜欢的话，随手点个star。多谢<br><a href="https://link.juejin.im?target=https%3A%2F%2Fgithub.com%2Fmcxtzhang%2FSwipeDelMenuLayout" rel="nofollow">github.com/mcxtzhang/S…</a></p> 
 <p>先上几个gif给各位看官感受一下最新版的魅力（以下版本都顺便展示了可选的双向滑动）</p> 
 <p>本控件最大魅力就是0耦合,所以先上配合我另一个库组装的效果(ItemDecorationIndexBar + SwipeMenuLayout)：<br>(ItemDecorationIndexBar : <a href="https://link.juejin.im?target=https%3A%2F%2Fgithub.com%2Fmcxtzhang%2FItemDecorationIndexBar" rel="nofollow">github.com/mcxtzhang/I…</a>)</p> 
 <p></p> 
 <figure> 
  <figcaption></figcaption> 
 </figure> 
 <p>Android Special Version （无阻塞式，侧滑菜单展开时，依然可以展开其他侧滑菜单，同时上一个菜单会自动关闭）:</p> 
 <p></p> 
 <figure> 
  <figcaption></figcaption> 
 </figure> 
 <p>GridLayoutManager （和上图的代码比，只需修改RecyclerView的LayoutManager。）:</p> 
 <p></p> 
 <figure> 
  <figcaption></figcaption> 
 </figure> 
 <p>LinearLayout （不需任何修改，连LinearLayout也可以简单的实现侧滑菜单）:</p> 
 <p></p> 
 <figure> 
  <figcaption></figcaption> 
 </figure> 
 <p>iOS interaction （阻塞式交互，高仿QQ，侧滑菜单展开式，屏蔽其他ITEM所有操作）:</p> 
 <p></p> 
 <figure> 
  <figcaption></figcaption> 
 </figure> 
 <h2>使用：</h2> 
 <p>Step 1. 在项目根build.gradle文件中增加JitPack仓库依赖。</p> 
 <pre><code class="hljs javascript copyable">    allprojects {
        repositories {
            ...
            maven { url <span class="hljs-string">"https://jitpack.io"</span> }
        }
    }<span class="copy-code-btn">复制代码</span></code></pre> 
 <p>Step 2. Add the dependency</p> 
 <pre><code class="hljs javascript copyable">    dependencies {
            compile <span class="hljs-string">'com.github.mcxtzhang:SwipeDelMenuLayout:V1.2.1'</span>
    }<span class="copy-code-btn">复制代码</span></code></pre> 
 <p>Step 3. 在需要侧滑删除的ContentItem外面套上本控件，在本控件内依次排列ContentItem、菜单即可：<br><strong>至此 您就可以使用高仿IOS、QQ 侧滑删除菜单功能了</strong><br>（侧滑菜单的点击事件等是通过设置的id取到，与其他控件一致，不再赘述）</p> 
 <p>Demo里，我的ContentItem是一个TextView，那么我就在其外嵌套本控件，并且以侧滑菜单出现的顺序，依次排列菜单控件即可。</p> 
 <pre><code class="hljs javascript copyable">&lt;?xml version=<span class="hljs-string">"1.0"</span> encoding=<span class="hljs-string">"utf-8"</span>?&gt;
&lt;com.mcxtzhang.swipemenulib.SwipeMenuLayout
    xmlns:android="http://schemas.android.com/apk/res/android"
    android:layout_width="match_parent"
    android:layout_height="100dp"
    android:clickable="true"
    android:paddingBottom="1dp"&gt;

    &lt;TextView
        android:id="@+id/content"
        android:layout_width="match_parent"
        android:layout_height="match_parent"
        android:background="?android:attr/selectableItemBackground"
        android:gravity="center"
        android:text="项目中我是任意复杂的原ContentItem布局"/&gt;

    &lt;!-- 以下都是侧滑菜单的内容依序排列 --&gt;
    &lt;Button
        android:id="@+id/btnTop"
        android:layout_width="60dp"
        android:layout_height="match_parent"
        android:background="#d9dee4"
        android:text="置顶"
        android:textColor="@android:color/white"/&gt;

    &lt;Button
        android:id="@+id/btnUnRead"
        android:layout_width="120dp"
        android:layout_height="match_parent"
        android:background="#ecd50a"
        android:clickable="true"
        android:text="标记未读"
        android:textColor="@android:color/white"/&gt;

    &lt;Button
        android:id="@+id/btnDelete"
        android:layout_width="60dp"
        android:layout_height="match_parent"
        android:background="@color/red_ff4a57"
        android:text="删除"
        android:textColor="@android:color/white"/&gt;

&lt;/com.mcxtzhang.swipemenulib.SwipeMenuLayout&gt;<span class="copy-code-btn">复制代码</span></code></pre> 
 <hr> 
 <h2>支持属性：</h2> 
 <p>1 通过 isIos 变量控制是否是IOS阻塞式交互，默认是打开的。<br>2 通过 isSwipeEnable 变量控制是否开启右滑菜单，默认打开。（某些场景，复用item，没有编辑权限的用户不能右滑）<br>3 通过开关 isLeftSwipe支持左滑右滑</p> 
 <p>有两种方式设置：<br>一：xml：</p> 
 <pre><code class="hljs xml copyable"><span class="hljs-tag">&lt;<span class="hljs-name">com.mcxtzhang.swipemenulib.SwipeMenuLayout</span>
    <span class="hljs-attr">xmlns:app</span>=<span class="hljs-string">"http://schemas.android.com/apk/res-auto"</span>
    <span class="hljs-attr">app:ios</span>=<span class="hljs-string">"false"</span>
    <span class="hljs-attr">app:leftSwipe</span>=<span class="hljs-string">"true"</span>
    <span class="hljs-attr">app:swipeEnable</span>=<span class="hljs-string">"true"</span>&gt;</span><span class="copy-code-btn">复制代码</span></code></pre> 
 <p>二： java代码：</p> 
 <pre><code class="hljs java copyable"><span class="hljs-comment">//这句话关掉IOS阻塞式交互效果 并依次打开左滑右滑  禁用掉侧滑菜单</span>
((SwipeMenuLayout) holder.itemView).setIos(<span class="hljs-keyword">false</span>).setLeftSwipe(position % <span class="hljs-number">2</span> == <span class="hljs-number">0</span> ? <span class="hljs-keyword">true</span> : <span class="hljs-keyword">false</span>).setSwipeEnable(<span class="hljs-keyword">false</span>);<span class="copy-code-btn">复制代码</span></code></pre> 
 <h2>支持特性：</h2> 
 <ul><li>不会同时展开2+个侧滑菜单。（可见界面上最多只会出现一个侧滑菜单）。</li><li>侧滑过程中，禁止父控件上下滑动。</li><li>多指同时滑动，屏蔽后触摸的几根手指。</li><li>增加viewChache 的 get()方法，可以用在：当点击外部空白处时，关闭正在展开的侧滑菜单。</li><li>以第一个子Item(即ContentItem)的宽度为控件宽度</li></ul> 
 <h2 id="-checklist-">每次更新的checklist：</h2> 
 <p>由于持续迭代，会发生完成一个feature、fix一个bug后，导致新的bug。<br>so，整理一份checkList，供每次迭代后验证，都通过，才会push到github库上。</p> 
 <table><thead><tr><th>项目</th><th>备注</th><th>验证</th></tr></thead><tbody><tr><td>isIos</td><td>切换至IOS阻塞交互模式、Android特色无阻塞交互模式 以下feature都可正常工作</td><td></td></tr><tr><td>isSwipeEnable</td><td>是否支持关闭侧滑功能</td></tr><tr><td>isLeftSwipe</td><td>是否支持双向滑动</td></tr><tr><td>ContentItem内容可单击</td><td></td></tr><tr><td>ContentItem内容可长按</td><td></td></tr><tr><td>侧滑菜单显示时，ContentItem不可点击</td><td></td></tr><tr><td>侧滑菜单显示时，ContentItem不可长按</td><td></td></tr><tr><td>侧滑菜单显示时，侧滑菜单可以点击</td><td></td></tr><tr><td>侧滑菜单显示时，点击ContentItem区域关闭菜单</td><td></td></tr><tr><td>侧滑过程中，屏蔽长按事件</td><td></td></tr><tr><td>通过滑动关闭菜单，不应该触发ContentItem点击事件</td><td></td></tr></tbody></table> 
 <h2>难点、冲突的解决：</h2> 
 <p>1 ContentItem的长按和本控件侧滑的冲突。<br>一开始我还是老思路，一直都是通过判断手指起始落点的坐标，判断手指落点处于何位置，屏蔽一些操作。当本控件功能越来越庞大，计算开始复杂，也容易出错。但也跌跌撞撞的撑了过来，但就在今天，我想到了另一种思路：通过禁用子View的longClickable属性来完成这个功能。于是我重构这部分代码，先利用git 查看之前的提交，去除掉那部分代码，并<br>在侧滑菜单展开<code>smoothExpand()</code>、关闭<code>smoothClose()</code>的函数中分别加入：</p> 
 <pre><code class="hljs java copyable">        <span class="hljs-comment">//2016 11 13 add 侧滑菜单展开，屏蔽content长按</span>
        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">null</span> != mContentView) {
            mContentView.setLongClickable(<span class="hljs-keyword">true</span>);
        }<span class="copy-code-btn">复制代码</span></code></pre> 
 <pre><code class="hljs java copyable">        <span class="hljs-comment">//2016 11 13 add 侧滑菜单展开，屏蔽content长按</span>
        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">null</span> != mContentView) {
            mContentView.setLongClickable(<span class="hljs-keyword">true</span>);
        }<span class="copy-code-btn">复制代码</span></code></pre> 
 <p>代码就这么简单，几小时前我才想到这么简单的解决方法，这也是促使我新撸一遍文章，记录本控件的一些改动的缘由之一。</p> 
 <p>2 如何支持任意父控件<br>这算是本控件最酷炫的魅力之一吧，<a href="https://link.juejin.im?target=http%3A%2F%2Fblog.csdn.net%2Fzxt0601%2Farticle%2Fdetails%2F52303781" rel="nofollow">在之前的文章</a> ，我详细描述了实现过程。<br>总结起来，我利用了一个static变量，保存了当前正在展开的View，<br>在进行各项操作时就可预先判断，如若会引起冲突，例如界面上出现两个侧滑菜单，<br>便自动关闭上一个菜单。</p> 
 <p>代码如下：</p> 
 <pre><code class="hljs java copyable">    <span class="hljs-comment">//存储的是当前正在展开的View</span>
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> SwipeMenuLayout mViewCache;<span class="copy-code-btn">复制代码</span></code></pre> 
 <p><code>dispatchTouchEvent()</code>的ActionDown里：</p> 
 <pre><code class="hljs javascript copyable">                    <span class="hljs-comment">//如果down，view和cacheview不一样，则立马让它还原。且把它置为null</span>
                    <span class="hljs-keyword">if</span> (mViewCache != <span class="hljs-literal">null</span>) {
                        <span class="hljs-keyword">if</span> (mViewCache != <span class="hljs-keyword">this</span>) {
                            mViewCache.smoothClose();
                        }
                        <span class="hljs-comment">//只要有一个侧滑菜单处于打开状态， 就不给外层布局上下滑动了</span>
                        getParent().requestDisallowInterceptTouchEvent(<span class="hljs-literal">true</span>);
                    }<span class="copy-code-btn">复制代码</span></code></pre> 
 <p>在侧滑菜单展开<code>smoothExpand()</code>、关闭<code>smoothClose()</code>的函数：</p> 
 <pre><code class="hljs javascript copyable">    <span class="hljs-comment">//展开就加入ViewCache：</span>
    mViewCache = SwipeMenuLayout.this;<span class="copy-code-btn">复制代码</span></code></pre> 
 <pre><code class="hljs javascript copyable">    <span class="hljs-comment">//关闭置为null</span>
    mViewCache = <span class="hljs-literal">null</span>;<span class="copy-code-btn">复制代码</span></code></pre> 
 <p><code>onDetachedFromWindow()</code>里：</p> 
 <pre><code class="hljs javascript copyable">    <span class="hljs-comment">//每次ViewDetach的时候，判断一下 ViewCache是不是自己，如果是自己，关闭侧滑菜单，且ViewCache设置为null，</span>
    <span class="hljs-comment">// 理由：1 防止内存泄漏(ViewCache是一个静态变量)</span>
    <span class="hljs-comment">// 2 侧滑删除后自己后，这个View被Recycler回收，复用，下一个进入屏幕的View的状态应该是普通状态，而不是展开状态。</span>
    @Override
    protected <span class="hljs-keyword">void</span> onDetachedFromWindow() {
        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span> == mViewCache) {
            mViewCache.smoothClose();
            mViewCache = <span class="hljs-literal">null</span>;
        }
        <span class="hljs-keyword">super</span>.onDetachedFromWindow();
    }<span class="copy-code-btn">复制代码</span></code></pre> 
 <p>3 解决多指滑动冲突：<br>利用一个布尔值 flag，在ActionDown时判断是否继续接受触摸事件：<br>代码如下：</p> 
 <pre><code class="hljs java copyable">    <span class="hljs-comment">//防止多只手指一起滑我的flag 在每次down里判断， touch事件结束清空</span>
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">boolean</span> isTouching;<span class="copy-code-btn">复制代码</span></code></pre> 
 <p><code>dispatchTouchEvent()</code>的ActionDown里：</p> 
 <pre><code class="hljs javascript copyable">    <span class="hljs-keyword">if</span> (isTouching) {<!-- --><span class="hljs-comment">//如果有别的指头摸过了，那么就return false。这样后续的move..等事件也不会再来找这个View了。</span>
        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
    } <span class="hljs-keyword">else</span> {
        isTouching = <span class="hljs-literal">true</span>;<span class="hljs-comment">//第一个摸的指头，赶紧改变标志，宣誓主权。</span>
    }<span class="copy-code-btn">复制代码</span></code></pre> 
 <p>ActionUp里：</p> 
 <pre><code class="hljs javascript copyable">    isTouching = <span class="hljs-literal">false</span>;<span class="hljs-comment">//没有手指在摸我了</span><span class="copy-code-btn">复制代码</span></code></pre> 
 <p>4 支持GridLayoutManager<br>毕竟项目中在网格布局中使用侧滑菜单还属少数，所以一开始我将场景简单化，给本控件设置的宽度都是父控件的宽度-padding。后来有童鞋提出希望支持网格布局，一开始我思路也走了弯路，我还想着构建一个MatchParent的MeasureSpec，然后传给父控件（GridView、RecyclerView）用于测量呢。<br>正确思路是，取第一个子View，即ContentView的宽度用作本控件的宽度即可，这样在layout侧滑菜单时，自然而然将侧滑菜单layout在了不可见的区域，只有通过滑动才能显示它。<br>代码也没啥好说的：<br>在<code>onMeasure()</code>中：</p> 
 <pre><code class="hljs javascript copyable">
    @Override
    protected <span class="hljs-keyword">void</span> onMeasure(int widthMeasureSpec, int heightMeasureSpec) {
        <span class="hljs-keyword">super</span>.onMeasure(widthMeasureSpec, heightMeasureSpec);
        <span class="hljs-comment">//2016 11 09 add,适配GridLayoutManager，将以第一个子Item(即ContentItem)的宽度为控件宽度</span>
        int contentWidth = <span class="hljs-number">0</span>;
        int childCount = getChildCount();
        <span class="hljs-keyword">for</span> (int i = <span class="hljs-number">0</span>; i &lt; childCount; i++) {
            View childView = getChildAt(i);
            <span class="hljs-keyword">if</span> (childView.getVisibility() != GONE) {
                measureChildWithMargins(childView, widthMeasureSpec, <span class="hljs-number">0</span>, heightMeasureSpec, <span class="hljs-number">0</span>);
                final MarginLayoutParams lp = (MarginLayoutParams) childView.getLayoutParams();
                mHeight = <span class="hljs-built_in">Math</span>.max(mHeight, childView.getMeasuredHeight() + lp.topMargin + lp.bottomMargin);
                <span class="hljs-keyword">if</span> (i &gt; <span class="hljs-number">0</span>) {<!-- --><span class="hljs-comment">//第一个布局是Left item，从第二个开始才是RightMenu</span>
                    mRightMenuWidths += childView.getMeasuredWidth();
                } <span class="hljs-keyword">else</span> {
                    contentWidth = childView.getMeasuredWidth();
                }
            }
        }
        setMeasuredDimension(contentWidth, mHeight);<span class="hljs-comment">//宽度取第一个Item(Content)的宽度</span>
    }<span class="copy-code-btn">复制代码</span></code></pre> 
 <p>在<code>onLayout()</code>中，顺序layoutchildView即可。</p> 
 <h2>总结</h2> 
 <p>以上是本控件近期or大家感兴趣的一些点的详解，更详细的讲解可去上篇文章观看，或者去github上下载源码浏览。<br>上文地址：<br><a href="https://link.juejin.im?target=http%3A%2F%2Fblog.csdn.net%2Fzxt0601%2Farticle%2Fdetails%2F52303781" rel="nofollow">blog.csdn.net/zxt0601/art…</a><br>代码传送门：喜欢的话，随手点个star。多谢<br><a href="https://link.juejin.im?target=https%3A%2F%2Fgithub.com%2Fmcxtzhang%2FSwipeDelMenuLayout" rel="nofollow">github.com/mcxtzhang/S…</a></p> 
 <p>大家使用中如有问题，多多反馈。</p> 
</div>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/bd64f763e383b9260ef70b21e00b95e6/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">【C语言】用递归实现字符串逆序的曲折之路</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/cefe362319cb8e4665d1a8bc61c94017/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">ffmpeg视频精准剪切</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>