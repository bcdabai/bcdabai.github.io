<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>字节跳动青训营--前端day7 - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="字节跳动青训营--前端day7" />
<meta property="og:description" content="文章目录 前言一、Node.js 的应用场景 (why)1. 前端工程化2. web服务端应用3. Electron跨端桌面应用 二、Node.js 运行时结(what)1. V8 ，libuv2. 优缺点3. js单线程4. 跨平台 三、编写 Http Server (how)1. SSR (server side rendering)2. Debug3. 部署 四、延伸话题1. node.js贡献代码2. 编译node.js3. 诊断/追踪4. WASM，NAPI 前言 仅以此文章记录学习历程。
一、Node.js 的应用场景 (why) 1. 前端工程化 Bundle：webpack, vite, esbuild, parcelUglify：uglifyjsTranspile：bablejs, typescript其他语言加入竞争：esbuild, parcel, prisma 现状：其他语言难以替代
2. web服务端应用 学习曲线平缓，开发效率较高运行效率接近常见的编译语言社区生态丰富及工具链成熟(npm, V8 inspector)与前端结合的场景会有优势(SSR) 现状：竞争激烈，但Node.js 有自己独特的优势
3. Electron跨端桌面应用 商业应用: vscode,slack, discord,zoom大型公司内的效率工具 现状:大部分场景在选型时，都值得考虑
二、Node.js 运行时结(what) 1. V8 ，libuv V8: JavaScript Runtime,诊断调试工具(inspector)libuv: eventloop (事件循环),syscall (系统调用) 举例:用 node-fetch 发起请求时" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/f4d25c10d3e2658656e676d45ec30ef8/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-02-04T13:19:25+08:00" />
<meta property="article:modified_time" content="2023-02-04T13:19:25+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">字节跳动青训营--前端day7</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p></p> 
<div class="toc"> 
 <h4>文章目录</h4> 
 <ul><li><a href="#_4" rel="nofollow">前言</a></li><li><a href="#Nodejs__why_10" rel="nofollow">一、Node.js 的应用场景 (why)</a></li><li><ul><li><a href="#1__11" rel="nofollow">1. 前端工程化</a></li><li><a href="#2_web_18" rel="nofollow">2. web服务端应用</a></li><li><a href="#3_Electron_25" rel="nofollow">3. Electron跨端桌面应用</a></li></ul> 
  </li><li><a href="#Nodejs_what_30" rel="nofollow">二、Node.js 运行时结(what)</a></li><li><ul><li><a href="#1_V8_libuv_33" rel="nofollow">1. V8 ，libuv</a></li><li><a href="#2__39" rel="nofollow">2. 优缺点</a></li><li><a href="#3_js_51" rel="nofollow">3. js单线程</a></li><li><a href="#4__57" rel="nofollow">4. 跨平台</a></li></ul> 
  </li><li><a href="#_Http_Server_how_62" rel="nofollow">三、编写 Http Server (how)</a></li><li><ul><li><a href="#1_SSR_server_side_rendering_64" rel="nofollow">1. SSR (server side rendering)</a></li><li><a href="#2_Debug_79" rel="nofollow">2. Debug</a></li><li><a href="#3__91" rel="nofollow">3. 部署</a></li></ul> 
  </li><li><a href="#_99" rel="nofollow">四、延伸话题</a></li><li><ul><li><a href="#1_nodejs_100" rel="nofollow">1. node.js贡献代码</a></li><li><a href="#2_nodejs_110" rel="nofollow">2. 编译node.js</a></li><li><a href="#3__120" rel="nofollow">3. 诊断/追踪</a></li><li><a href="#4_WASMNAPI_128" rel="nofollow">4. WASM，NAPI</a></li></ul> 
 </li></ul> 
</div> 
<p></p> 
<hr> 
<h2><a id="_4"></a>前言</h2> 
<p><code>仅以此文章记录学习历程。</code></p> 
<hr> 
<h2><a id="Nodejs__why_10"></a>一、Node.js 的应用场景 (why)</h2> 
<h3><a id="1__11"></a>1. 前端工程化</h3> 
<ul><li>Bundle：webpack, vite, esbuild, parcel</li><li>Uglify：uglifyjs</li><li>Transpile：bablejs, typescript</li><li>其他语言加入竞争：esbuild, parcel, prisma</li></ul> 
<p><mark>现状：其他语言难以替代</mark></p> 
<h3><a id="2_web_18"></a>2. web服务端应用</h3> 
<ul><li>学习曲线平缓，开发效率较高</li><li>运行效率接近常见的编译语言</li><li>社区生态丰富及工具链成熟(npm, V8 inspector)</li><li>与前端结合的场景会有优势(SSR)</li></ul> 
<p><mark>现状：竞争激烈，但Node.js 有自己独特的优势</mark></p> 
<h3><a id="3_Electron_25"></a>3. Electron跨端桌面应用</h3> 
<ul><li>商业应用: vscode,slack, discord,zoom</li><li>大型公司内的效率工具</li></ul> 
<p><mark>现状:大部分场景在选型时，都值得考虑</mark></p> 
<h2><a id="Nodejs_what_30"></a>二、Node.js 运行时结(what)</h2> 
<p><img src="https://images2.imgbox.com/c1/e0/K2V9G1N2_o.png" alt="在这里插入图片描述"></p> 
<h3><a id="1_V8_libuv_33"></a>1. V8 ，libuv</h3> 
<ul><li>V8: JavaScript Runtime,诊断调试工具(inspector)</li><li>libuv: eventloop (事件循环),syscall (系统调用)</li></ul> 
<p><mark>举例:用 node-fetch 发起请求时</mark></p> 
<h3><a id="2__39"></a>2. 优缺点</h3> 
<p><strong>优点：</strong></p> 
<ul><li>处理高并发场景性能更佳</li><li>适合I/O密集型应用，值的是应用在运行极限时，CPU占用率仍然比较低，大部分时间是在做 I/O硬盘内存读写操作</li></ul> 
<p><strong>因为Nodejs是单线程，带来的缺点有：</strong></p> 
<ul><li>不适合CPU密集型应用</li><li>只支持单核CPU，不能充分利用CPU</li><li>可靠性低，一旦代码某个环节崩溃，整个系统都崩溃</li></ul> 
<h3><a id="3_js_51"></a>3. js单线程</h3> 
<p>实际: JS 线程 + uv 线程池 + V8 任务线程池 + V8 Inspector 线程</p> 
<p><code>优点：</code> 不用考虑多线程状态同步问题，也就不需要锁;同时还能比较高效地利用系统资源;<br> <code>缺点：</code>阻塞会产生更多负面影响。解决办法:多进程或多线程</p> 
<h3><a id="4__57"></a>4. 跨平台</h3> 
<p>Node.js 跨平台 +JS 无需编译环境 (+ Web 跨平台 + 诊断工具跨平台）</p> 
<p><code>优点：</code>开发成本低 (大部分场景无需担心跨平台问题)，整体学习成本低</p> 
<h2><a id="_Http_Server_how_62"></a>三、编写 Http Server (how)</h2> 
<p>代码地址：<a href="https://gitee.com/TangShixing/basics/tree/master/%E5%AD%97%E8%8A%82%E8%B7%B3%E5%8A%A8%E9%9D%92%E8%AE%AD%E8%90%A5/http_server" rel="nofollow">字节跳动青训营/http_server</a></p> 
<h3><a id="1_SSR_server_side_rendering_64"></a>1. SSR (server side rendering)</h3> 
<p>这里主要是以React为例</p> 
<p><strong>优点：</strong></p> 
<ul><li>相比传统HTML模版引擎:避免重复编写代码</li><li>相比 SPA (single page application):首屏渲染更快,SEO友好</li></ul> 
<p><strong>缺点：</strong></p> 
<ul><li>通常qps 较低，前端代码编写时需要考虑服务端渲染情况</li></ul> 
<p><strong>难点：</strong></p> 
<ul><li>需要处理打包代码</li><li>需要思考前端代码在服务端运行的逻辑</li><li>移除对服务端无意义的副作用，或重置环境</li></ul> 
<h3><a id="2_Debug_79"></a>2. Debug</h3> 
<p><code>V8 Inspector：</code>开箱即用、特性丰富强大、与前端开发一致、跨平台</p> 
<ul><li>node --inspect</li><li>open http://localhost:9229/isn</li></ul> 
<p><strong>场景：</strong></p> 
<ul><li>查看 console.log 内容</li><li>breakpoint</li><li>高 CPU、死循环: cpuprofile</li><li>高内存占用: heapsnapshot</li><li>性能分析</li></ul> 
<h3><a id="3__91"></a>3. 部署</h3> 
<p><strong>部署要解决的问题：</strong></p> 
<ul><li>守护进程:当进程退出时，重新拉起</li><li>多进程: cluster 便捷地利用多进程</li><li>记录进程状态，用于诊断</li></ul> 
<p><strong>容器环境：</strong></p> 
<ul><li>通常有健康检查的手段，只需考虑多核 cpu 利用率即可</li></ul> 
<h2><a id="_99"></a>四、延伸话题</h2> 
<h3><a id="1_nodejs_100"></a>1. node.js贡献代码</h3> 
<p>快速了解 Node.js 代码：<a href="https://nodejs.org/zh-cn/get-involved/contribute/" rel="nofollow">Node.js Core 贡献入门</a></p> 
<p><strong>好处：</strong></p> 
<ul><li>从使用者的角色逐步理解底层细节，可以解决更复杂的问题</li><li>自我证明，有助于职业发展解决社区问题</li><li>促进社区发展;</li></ul> 
<p><strong>难点：</strong></p> 
<ul><li>花时间</li></ul> 
<h3><a id="2_nodejs_110"></a>2. 编译node.js</h3> 
<p><strong>为什么要学习编译 Node.js：</strong></p> 
<ul><li>认知:黑盒到白盒，发生问题时能有迹可循</li><li>贡献代码的第一步</li></ul> 
<p><strong>如何编译：</strong></p> 
<ul><li>参考: Maintaining the build files</li><li>./configure &amp;&amp; make install</li><li>演示:给 net 模块添加自定义属性</li></ul> 
<h3><a id="3__120"></a>3. 诊断/追踪</h3> 
<ul><li>诊断是一个低频、重要同时也相当有挑战的方向。是企业衡量自己能否依赖一门语言的重要参考。</li><li>技术咨询行业中的热门角色</li></ul> 
<p><strong>难点：</strong></p> 
<ul><li>需要了解 Node.js 底层,需要了解操作系统以及各种工具</li><li>需要大量的开发和实践经验</li></ul> 
<h3><a id="4_WASMNAPI_128"></a>4. WASM，NAPI</h3> 
<ul><li>Node.js (因为 V8) 是执行 WASM 代码的天然容器，和浏览器WASM 是同一运行时，同时 Node.js 支持 WASI</li><li>NAPI 执行 C 接口的代码(C/C++/Rust…)，同时能保留原生代码的性能。</li><li>不同编程语言间通信的一种方案。</li></ul>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/923a0f4e8600365d5659f8f5e28e425c/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">c语言占位符</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/030d37bdb6ec95e5caa220856615a884/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">spring boot集成mybatis-plus——通过id修改用户信息</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>