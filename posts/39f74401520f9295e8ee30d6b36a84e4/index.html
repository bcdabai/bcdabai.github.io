<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>SpringBoot配置文件@PropertySource 同时支持properties文件与yaml(yml) - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="SpringBoot配置文件@PropertySource 同时支持properties文件与yaml(yml)" />
<meta property="og:description" content="Yaml(yml)最近比较流行的配置文件,相对properties,配置文件结构更清晰简洁.前段时间项目需要引入的配置，于是想用yml文件来增加新的属性配置，新增属性放在application.yml中是没问题的，但是放其他文件中，然后通过@PropertySource 引入时，却出现了问题，所有.yml中的参数配置全部读取无效，properties文件是正常的，后来在stackoverflow上看到@PropertySource中存在factory参数，通过配置factory参数可以达到我们想要的效果。
@PropertySource factory属性的factory默认配置是Class&lt;? extends PropertySourceFactory&gt; factory() default PropertySourceFactory.class;, 我们再看下PropertySourceFactory的源码就可知道了,
/** * Strategy interface for creating resource-based {@link PropertySource} wrappers. * * @author Juergen Hoeller * @since 4.3 * @see DefaultPropertySourceFactory */ public interface PropertySourceFactory { /** * Create a {@link PropertySource} that wraps the given resource. * @param name the name of the property source * @param resource the resource (potentially encoded) to wrap * @return the new {@link PropertySource} (never {@code null}) * @throws IOException if resource resolution failed */ PropertySource&lt;?" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/39f74401520f9295e8ee30d6b36a84e4/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2019-02-23T11:11:50+08:00" />
<meta property="article:modified_time" content="2019-02-23T11:11:50+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">SpringBoot配置文件@PropertySource 同时支持properties文件与yaml(yml)</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p><code>Yaml(yml)</code>最近比较流行的配置文件,相对properties,配置文件结构更清晰简洁.前段时间项目需要引入的配置，于是想用<code>yml</code>文件来增加新的属性配置，新增属性放在<code>application.yml</code>中是没问题的，但是放其他文件中，然后通过<code>@PropertySource</code> 引入时，却出现了问题，所有<code>.yml</code>中的参数配置全部读取无效，properties文件是正常的，后来在stackoverflow上看到<code>@PropertySource</code>中存在<code>factory</code>参数，通过配置<code>factory</code>参数可以达到我们想要的效果。<br> <code>@PropertySource factory</code>属性的<code>factory</code>默认配置是<code>Class&lt;? extends PropertySourceFactory&gt; factory() default PropertySourceFactory.class;</code>, 我们再看下<code>PropertySourceFactory</code>的源码就可知道了,</p> 
<pre><code>/**
 * Strategy interface for creating resource-based {@link PropertySource} wrappers.
 *
 * @author Juergen Hoeller
 * @since 4.3
 * @see DefaultPropertySourceFactory
 */
public interface PropertySourceFactory {

	/**
	 * Create a {@link PropertySource} that wraps the given resource.
	 * @param name the name of the property source
	 * @param resource the resource (potentially encoded) to wrap
	 * @return the new {@link PropertySource} (never {@code null})
	 * @throws IOException if resource resolution failed
	 */
	PropertySource&lt;?&gt; createPropertySource(String name, EncodedResource resource) throws IOException;

}
</code></pre> 
<p>默认实现是<code>DefaultPropertySourceFactory</code>,</p> 
<pre><code>/**
 * The default implementation for {@link PropertySourceFactory},
 * wrapping every resource in a {@link ResourcePropertySource}.
 *
 * @author Juergen Hoeller
 * @since 4.3
 * @see PropertySourceFactory
 * @see ResourcePropertySource
 */
public class DefaultPropertySourceFactory implements PropertySourceFactory {

	@Override
	public PropertySource&lt;?&gt; createPropertySource(String name, EncodedResource resource) throws IOException {
		return (name != null ? new ResourcePropertySource(name, resource) : new ResourcePropertySource(resource));
	}

}
</code></pre> 
<p>我们所有做的只需继承DefaultPropertySourceFactory,然后对createPropertySource作下微调,就可以支持yaml了.</p> 
<pre><code> public class MixPropertySourceFactory extends DefaultPropertySourceFactory {

  @Override
  public PropertySource&lt;?&gt; createPropertySource(String name, EncodedResource resource) throws IOException {
    String sourceName = name != null ? name : resource.getResource().getFilename();
    if (!resource.getResource().exists()) {
      return new PropertiesPropertySource(sourceName, new Properties());
    } else if (sourceName.endsWith(".yml") || sourceName.endsWith(".yaml")) {
      Properties propertiesFromYaml = loadYml(resource);
      return new PropertiesPropertySource(sourceName, propertiesFromYaml);
    } else {
      return super.createPropertySource(name, resource);
    }
  }

  private Properties loadYml(EncodedResource resource) throws IOException {
    YamlPropertiesFactoryBean factory = new YamlPropertiesFactoryBean();
    factory.setResources(resource.getResource());
    factory.afterPropertiesSet();
    return factory.getObject();
  }
}
</code></pre> 
<p>这里做了个简单的文件后缀判断,如果是以.yml或.yaml结尾,则通过YamlPropertiesFactoryBean加载,其他情况则采用默认方式加载.如果大家需要支持json或xml等其他格式,也可在这里自动加入策略处理.<br> 最后在SpringApplication上加入配置</p> 
<pre><code>@PropertySource(value = {
   "a.properties",
   "b.yml"
}, factory = MixPropertySourceFactory.class)
</code></pre> 
<p>就可以了</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/e5c73b579186e97b9d7b3a73310ec0a5/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">如何使用 vue &#43; typescript 编写页面 （typescript简单语法篇）</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/ba4b90931798eadd9e9538dd9dae8f3a/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">pip命令使用详解</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>