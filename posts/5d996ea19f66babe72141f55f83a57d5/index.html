<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Spark概述 - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Spark概述" />
<meta property="og:description" content="Spark概述
1.1. 什么是Spark（官网：http://spark.apache.org）
Spark是一种快速、通用、可扩展的大数据分析引擎，2009年诞生于加州大学伯克利分校AMPLab，2010年开源，2013年6月成为Apache孵化项目，2014年2月成为Apache顶级项目。目前，Spark生态系统已经发展成为一个包含多个子项目的集合，其中包含SparkSQL、Spark Streaming、GraphX、MLlib等子项目，Spark是基于内存计算的大数据并行计算框架。Spark基于内存计算，提高了在大数据环境下数据处理的实时性，同时保证了高容错性和高可伸缩性，允许用户将Spark部署在大量廉价硬件之上，形成集群。Spark得到了众多大数据公司的支持，这些公司包括Hortonworks、IBM、Intel、Cloudera、MapR、Pivotal、百度、阿里、腾讯、京东、携程、优酷土豆。当前百度的Spark已应用于凤巢、大搜索、直达号、百度大数据等业务；阿里利用GraphX构建了大规模的图计算和图挖掘系统，实现了很多生产系统的推荐算法；腾讯Spark集群达到8000台的规模，是当前已知的世界上最大的Spark集群。
1.2. 为什么要学Spark
中间结果输出：基于MapReduce的计算引擎通常会将中间结果输出到磁盘上，进行存储和容错。出于任务管道承接的，考虑，当一些查询翻译到MapReduce任务时，往往会产生多个Stage，而这些串联的Stage又依赖于底层文件系统（如HDFS）来存储每一个Stage的输出结果
Hadoop Spark
Spark是MapReduce的替代方案，而且兼容HDFS、Hive，可融入Hadoop的生态系统，以弥补MapReduce的不足。
1.3. Spark特点
1.3.1. 快
与Hadoop的MapReduce相比，Spark基于内存的运算要快100倍以上，基于硬盘的运算也要快10倍以上。Spark实现了高效的DAG执行引擎，可以通过基于内存来高效处理数据流。
1.3.2. 易用
Spark支持Java、Python和Scala的API，还支持超过80种高级算法，使用户可以快速构建不同的应用。而且Spark支持交互式的Python和Scala的shell，可以非常方便地在这些shell中使用Spark集群来验证解决问题的方法。
1.3.3. 通用
Spark提供了统一的解决方案。Spark可以用于批处理、交互式查询（Spark SQL）、实时流处理（Spark Streaming）、机器学习（Spark MLlib）和图计算（GraphX）。这些不同类型的处理都可以在同一个应用中无缝使用。Spark统一的解决方案非常具有吸引力，毕竟任何公司都想用统一的平台去处理遇到的问题，减少开发和维护的人力成本和部署平台的物力成本。
1.3.4. 兼容性
Spark可以非常方便地与其他的开源产品进行融合。比如，Spark可以使用Hadoop的YARN和Apache Mesos作为它的资源管理和调度器，器，并且可以处理所有Hadoop支持的数据，包括HDFS、HBase和Cassandra等。这对于已经部署Hadoop集群的用户特别重要，因为不需要做任何数据迁移就可以使用Spark的强大处理能力。Spark也可以不依赖于第三方的资源管理和调度器，它实现了Standalone作为其内置的资源管理和调度框架，这样进一步降低了Spark的使用门槛，使得所有人都可以非常容易地部署和使用Spark。此外，Spark还提供了在EC2上部署Standalone的Spark集群的工具。
2. Spark集群安装
2.1. 安装
2.1.1. 机器部署
准备两台以上Linux服务器，安装好JDK1.7
2.1.2. 下载Spark安装包
http://www.apache.org/dyn/closer.lua/spark/spark-1.5.2/spark-1.5.2-bin-hadoop2.6.tgz
上传解压安装包
上传spark-1.5.2-bin-hadoop2.6.tgz安装包到Linux上
解压安装包到指定位置
tar -zxvf spark-1.5.2-bin-hadoop2.6.tgz -C /usr/local
2.1.3. 配置Spark
进入到Spark安装目录
cd /usr/local/spark-1.5.2-bin-hadoop2.6
进入conf目录并重命名并修改spark-env.sh.template文件
cd conf/
mv spark-env.sh.template spark-env.sh
vi spark-env.sh
在该配置文件中添加如下配置
export JAVA_HOME=/usr/java/jdk1.7.0_45
export SPARK_MASTER_IP=node1.itcast.cn
export SPARK_MASTER_PORT=7077
保存退出
重命名并修改slaves.template文件" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/5d996ea19f66babe72141f55f83a57d5/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-05-11T08:33:46+08:00" />
<meta property="article:modified_time" content="2022-05-11T08:33:46+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Spark概述</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p>     Spark概述<br> 1.1.    什么是Spark（官网：http://spark.apache.org）<br>  <img src="https://images2.imgbox.com/2f/d3/YyFt4xoj_o.png" alt="c4824fcb56bc448b8cc87a2ce769e479.png"><br> Spark是一种快速、通用、可扩展的大数据分析引擎，2009年诞生于加州大学伯克利分校AMPLab，2010年开源，2013年6月成为Apache孵化项目，2014年2月成为Apache顶级项目。目前，Spark生态系统已经发展成为一个包含多个子项目的集合，其中包含SparkSQL、Spark Streaming、GraphX、MLlib等子项目，Spark是基于内存计算的大数据并行计算框架。Spark基于内存计算，提高了在大数据环境下数据处理的实时性，同时保证了高容错性和高可伸缩性，允许用户将Spark部署在大量廉价硬件之上，形成集群。Spark得到了众多大数据公司的支持，这些公司包括Hortonworks、IBM、Intel、Cloudera、MapR、Pivotal、百度、阿里、腾讯、京东、携程、优酷土豆。当前百度的Spark已应用于凤巢、大搜索、直达号、百度大数据等业务；阿里利用GraphX构建了大规模的图计算和图挖掘系统，实现了很多生产系统的推荐算法；腾讯Spark集群达到8000台的规模，是当前已知的世界上最大的Spark集群。<br> 1.2.    为什么要学Spark<br> 中间结果输出：基于MapReduce的计算引擎通常会将中间结果输出到磁盘上，进行存储和容错。出于任务管道承接的，考虑，当一些查询翻译到MapReduce任务时，往往会产生多个Stage，而这些串联的Stage又依赖于底层文件系统（如HDFS）来存储每一个Stage的输出结果<br> Hadoop    Spark<br>  <br>  <br> Spark是MapReduce的替代方案，而且兼容HDFS、Hive，可融入Hadoop的生态系统，以弥补MapReduce的不足。<br> 1.3.    Spark特点<br> 1.3.1.    快<br> 与Hadoop的MapReduce相比，Spark基于内存的运算要快100倍以上，基于硬盘的运算也要快10倍以上。Spark实现了高效的DAG执行引擎，可以通过基于内存来高效处理数据流。<br>  <img src="https://images2.imgbox.com/1f/2e/tGyCN281_o.png" alt="ac3335e62f434b988fed913cc90d72f4.png"><br> 1.3.2.    易用<br> Spark支持Java、Python和Scala的API，还支持超过80种高级算法，使用户可以快速构建不同的应用。而且Spark支持交互式的Python和Scala的shell，可以非常方便地在这些shell中使用Spark集群来验证解决问题的方法。<br>  <img src="https://images2.imgbox.com/ab/78/g6KBUtcy_o.png" alt="a9ea63618ffa4386a4b51d3e169f9676.png"><br> 1.3.3.    通用<br> Spark提供了统一的解决方案。Spark可以用于批处理、交互式查询（Spark SQL）、实时流处理（Spark Streaming）、机器学习（Spark MLlib）和图计算（GraphX）。这些不同类型的处理都可以在同一个应用中无缝使用。Spark统一的解决方案非常具有吸引力，毕竟任何公司都想用统一的平台去处理遇到的问题，减少开发和维护的人力成本和部署平台的物力成本。<br> 1.3.4.    兼容性<br> Spark可以非常方便地与其他的开源产品进行融合。比如，Spark可以使用Hadoop的YARN和Apache Mesos作为它的资源管理和调度器，器，并且可以处理所有Hadoop支持的数据，包括HDFS、HBase和Cassandra等。这对于已经部署Hadoop集群的用户特别重要，因为不需要做任何数据迁移就可以使用Spark的强大处理能力。Spark也可以不依赖于第三方的资源管理和调度器，它实现了Standalone作为其内置的资源管理和调度框架，这样进一步降低了Spark的使用门槛，使得所有人都可以非常容易地部署和使用Spark。此外，Spark还提供了在EC2上部署Standalone的Spark集群的工具。<br>  <img src="https://images2.imgbox.com/78/21/imu7kw7c_o.png" alt="11f8ec77564044c2b7177199488fbc47.png"><br> 2.    Spark集群安装<br> 2.1.    安装<br> 2.1.1.    机器部署<br> 准备两台以上Linux服务器，安装好JDK1.7<br> 2.1.2.    下载Spark安装包</p> 
<p> </p> 
<p> <img src="https://images2.imgbox.com/35/71/ZbxuLHh5_o.png" alt="d1bbfde56ed24167bad88802da7bbcce.png"></p> 
<p> </p> 
<p> </p> 
<p> </p> 
<p>http://www.apache.org/dyn/closer.lua/spark/spark-1.5.2/spark-1.5.2-bin-hadoop2.6.tgz<br> 上传解压安装包<br> 上传spark-1.5.2-bin-hadoop2.6.tgz安装包到Linux上<br> 解压安装包到指定位置<br> tar -zxvf spark-1.5.2-bin-hadoop2.6.tgz -C /usr/local<br> 2.1.3.    配置Spark<br> 进入到Spark安装目录<br> cd /usr/local/spark-1.5.2-bin-hadoop2.6<br> 进入conf目录并重命名并修改spark-env.sh.template文件<br> cd conf/<br> mv spark-env.sh.template spark-env.sh<br> vi spark-env.sh<br> 在该配置文件中添加如下配置<br> export JAVA_HOME=/usr/java/jdk1.7.0_45<br> export SPARK_MASTER_IP=node1.itcast.cn<br> export SPARK_MASTER_PORT=7077<br> 保存退出<br> 重命名并修改slaves.template文件<br> mv slaves.template slaves<br> vi slaves<br> 在该文件中添加子节点所在的位置（Worker节点）<br> node2.itcast.cn<br> node3.itcast.cn<br> node4.itcast.cn<br> 保存退出<br> 将配置好的Spark拷贝到其他节点上<br> scp -r spark-1.5.2-bin-hadoop2.6/ node2.itcast.cn:/usr/local/<br> scp -r spark-1.5.2-bin-hadoop2.6/ node3.itcast.cn:/usr/local/<br> scp -r spark-1.5.2-bin-hadoop2.6/ node4.itcast.cn:/usr/local/</p> 
<p>Spark集群配置完毕，目前是1个Master，3个Work，在node1.itcast.cn上启动Spark集群<br> /usr/local/spark-1.5.2-bin-hadoop2.6/sbin/start-all.sh</p> 
<p>启动后执行jps命令，主节点上有Master进程，其他子节点上有Work进行，登录Spark管理界面查看集群状态（主节点）：http://node1.itcast.cn:8080/<br>  <br> 到此为止，Spark集群安装完毕，但是有一个很大的问题，那就是Master节点存在单点故障，要解决此问题，就要借助zookeeper，并且启动至少两个Master节点来实现高可靠，配置方式比较简单：<br> Spark集群规划：node1，node2是Master；node3，node4，node5是Worker<br> 安装配置zk集群，并启动zk集群<br> 停止spark所有服务，修改配置文件spark-env.sh，在该配置文件中删掉SPARK_MASTER_IP并添加如下配置<br> export SPARK_DAEMON_JAVA_OPTS="-Dspark.deploy.recoveryMode=ZOOKEEPER -Dspark.deploy.zookeeper.url=zk1,zk2,zk3 -Dspark.deploy.zookeeper.dir=/spark"<br> 1.在node1节点上修改slaves配置文件内容指定worker节点<br> 2.在node1上执行sbin/start-all.sh脚本，然后在node2上执行sbin/start-master.sh启动第二个Master<br> 3.    执行Spark程序<br> 3.1.    执行第一个spark程序<br> /usr/local/spark-1.5.2-bin-hadoop2.6/bin/spark-submit \<br> --class org.apache.spark.examples.SparkPi \<br> --master spark://node1.itcast.cn:7077 \<br> --executor-memory 1G \<br> --total-executor-cores 2 \<br> /usr/local/spark-1.5.2-bin-hadoop2.6/lib/spark-examples-1.5.2-hadoop2.6.0.jar \<br> 100<br> 该算法是利用蒙特·卡罗算法求PI<br> 3.2.    启动Spark Shell<br> spark-shell是Spark自带的交互式Shell程序，方便用户进行交互式编程，用户可以在该命令行下用scala编写spark程序。<br> 3.2.1.    启动spark shell<br> /usr/local/spark-1.5.2-bin-hadoop2.6/bin/spark-shell \<br> --master spark://node1.itcast.cn:7077 \<br> --executor-memory 2g \<br> --total-executor-cores 2</p> 
<p>参数说明：<br> --master spark://node1.itcast.cn:7077 指定Master的地址<br> --executor-memory 2g 指定每个worker可用内存为2G<br> --total-executor-cores 2 指定整个集群使用的cup核数为2个</p> 
<p>注意：<br> 如果启动spark shell时没有指定master地址，但是也可以正常启动spark shell和执行spark shell中的程序，其实是启动了spark的local模式，该模式仅在本机启动一个进程，没有与集群建立联系。</p> 
<p>Spark Shell中已经默认将SparkContext类初始化为对象sc。用户代码如果需要用到，则直接应用sc即可<br> 3.2.2.    在spark shell中编写WordCount程序<br> 1.首先启动hdfs<br> 2.向hdfs上传一个文件到hdfs://node1.itcast.cn:9000/words.txt<br> 3.在spark shell中用scala语言编写spark程序<br> sc.textFile("hdfs://node1.itcast.cn:9000/words.txt").flatMap(_.split(" "))<br> .map((_,1)).reduceByKey(_+_).saveAsTextFile("hdfs://node1.itcast.cn:9000/out")</p> 
<p>4.使用hdfs命令查看结果<br> hdfs dfs -ls hdfs://node1.itcast.cn:9000/out/p*</p> 
<p>说明：<br> sc是SparkContext对象，该对象时提交spark程序的入口<br> textFile(hdfs://node1.itcast.cn:9000/words.txt)是hdfs中读取数据<br> flatMap(_.split(" "))先map在压平<br> map((_,1))将单词和1构成元组<br> reduceByKey(_+_)按照key进行reduce，并将value累加<br> saveAsTextFile("hdfs://node1.itcast.cn:9000/out")将结果写入到hdfs中<br> 3.3.    在IDEA中编写WordCount程序<br> spark shell仅在测试和验证我们的程序时使用的较多，在生产环境中，通常会在IDE中编制程序，然后打成jar包，然后提交到集群，最常用的是创建一个Maven项目，利用Maven来管理jar包的依赖。</p> 
<p>1.创建一个项目<br>  </p> 
<p><br> 2.选择Maven项目，然后点击next<br>  </p> 
<p>3.填写maven的GAV，然后点击next<br>  </p> 
<p>4.填写项目名称，然后点击finish<br>  </p> 
<p>5.创建好maven项目后，点击Enable Auto-Import<br>  </p> 
<p>6.配置Maven的pom.xml<br> &lt;?xml version="1.0" encoding="UTF-8"?&gt;<br> &lt;project xmlns="http://maven.apache.org/POM/4.0.0"<br>          xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"<br>          xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"&gt;<br>     &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;</p> 
<p>    &lt;groupId&gt;cn.itcast.spark&lt;/groupId&gt;<br>     &lt;artifactId&gt;spark-mvn&lt;/artifactId&gt;<br>     &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;</p> 
<p>    &lt;properties&gt;<br>         &lt;maven.compiler.source&gt;1.7&lt;/maven.compiler.source&gt;<br>         &lt;maven.compiler.target&gt;1.7&lt;/maven.compiler.target&gt;<br>         &lt;encoding&gt;UTF-8&lt;/encoding&gt;<br>         &lt;scala.version&gt;2.10.6&lt;/scala.version&gt;<br>         &lt;scala.compat.version&gt;2.10&lt;/scala.compat.version&gt;<br>     &lt;/properties&gt;</p> 
<p>    &lt;dependencies&gt;<br>         &lt;dependency&gt;<br>             &lt;groupId&gt;org.scala-lang&lt;/groupId&gt;<br>             &lt;artifactId&gt;scala-library&lt;/artifactId&gt;<br>             &lt;version&gt;${scala.version}&lt;/version&gt;<br>         &lt;/dependency&gt;</p> 
<p>        &lt;dependency&gt;<br>             &lt;groupId&gt;org.apache.spark&lt;/groupId&gt;<br>             &lt;artifactId&gt;spark-core_2.10&lt;/artifactId&gt;<br>             &lt;version&gt;1.5.2&lt;/version&gt;<br>         &lt;/dependency&gt;</p> 
<p>        &lt;dependency&gt;<br>             &lt;groupId&gt;org.apache.spark&lt;/groupId&gt;<br>             &lt;artifactId&gt;spark-streaming_2.10&lt;/artifactId&gt;<br>             &lt;version&gt;1.5.2&lt;/version&gt;<br>         &lt;/dependency&gt;</p> 
<p>        &lt;dependency&gt;<br>             &lt;groupId&gt;org.apache.hadoop&lt;/groupId&gt;<br>             &lt;artifactId&gt;hadoop-client&lt;/artifactId&gt;<br>             &lt;version&gt;2.6.2&lt;/version&gt;<br>         &lt;/dependency&gt;<br>     &lt;/dependencies&gt;</p> 
<p>    &lt;build&gt;<br>         &lt;sourceDirectory&gt;src/main/scala&lt;/sourceDirectory&gt;<br>         &lt;testSourceDirectory&gt;src/test/scala&lt;/testSourceDirectory&gt;<br>         &lt;plugins&gt;<br>             &lt;plugin&gt;<br>                 &lt;groupId&gt;net.alchim31.maven&lt;/groupId&gt;<br>                 &lt;artifactId&gt;scala-maven-plugin&lt;/artifactId&gt;<br>                 &lt;version&gt;3.2.0&lt;/version&gt;<br>                 &lt;executions&gt;<br>                     &lt;execution&gt;<br>                         &lt;goals&gt;<br>                             &lt;goal&gt;compile&lt;/goal&gt;<br>                             &lt;goal&gt;testCompile&lt;/goal&gt;<br>                         &lt;/goals&gt;<br>                         &lt;configuration&gt;<br>                             &lt;args&gt;<br>                                 &lt;arg&gt;-make:transitive&lt;/arg&gt;<br>                                 &lt;arg&gt;-dependencyfile&lt;/arg&gt;<br>                                 &lt;arg&gt;${project.build.directory}/.scala_dependencies&lt;/arg&gt;<br>                             &lt;/args&gt;<br>                         &lt;/configuration&gt;<br>                     &lt;/execution&gt;<br>                 &lt;/executions&gt;<br>             &lt;/plugin&gt;<br>             &lt;plugin&gt;<br>                 &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;<br>                 &lt;artifactId&gt;maven-surefire-plugin&lt;/artifactId&gt;<br>                 &lt;version&gt;2.18.1&lt;/version&gt;<br>                 &lt;configuration&gt;<br>                     &lt;useFile&gt;false&lt;/useFile&gt;<br>                     &lt;disableXmlReport&gt;true&lt;/disableXmlReport&gt;<br>                     &lt;includes&gt;<br>                         &lt;include&gt;**/*Test.*&lt;/include&gt;<br>                         &lt;include&gt;**/*Suite.*&lt;/include&gt;<br>                     &lt;/includes&gt;<br>                 &lt;/configuration&gt;<br>             &lt;/plugin&gt;</p> 
<p>            &lt;plugin&gt;<br>                 &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;<br>                 &lt;artifactId&gt;maven-shade-plugin&lt;/artifactId&gt;<br>                 &lt;version&gt;2.3&lt;/version&gt;<br>                 &lt;executions&gt;<br>                     &lt;execution&gt;<br>                         &lt;phase&gt;package&lt;/phase&gt;<br>                         &lt;goals&gt;<br>                             &lt;goal&gt;shade&lt;/goal&gt;<br>                         &lt;/goals&gt;<br>                         &lt;configuration&gt;<br>                             &lt;filters&gt;<br>                                 &lt;filter&gt;<br>                                     &lt;artifact&gt;*:*&lt;/artifact&gt;<br>                                     &lt;excludes&gt;<br>                                         &lt;exclude&gt;META-INF/*.SF&lt;/exclude&gt;<br>                                         &lt;exclude&gt;META-INF/*.DSA&lt;/exclude&gt;<br>                                         &lt;exclude&gt;META-INF/*.RSA&lt;/exclude&gt;<br>                                     &lt;/excludes&gt;<br>                                 &lt;/filter&gt;<br>                             &lt;/filters&gt;<br>                             &lt;transformers&gt;<br>                                 &lt;transformer implementation="org.apache.maven.plugins.shade.resource.ManifestResourceTransformer"&gt;<br>                                     &lt;mainClass&gt;cn.itcast.spark.WordCount&lt;/mainClass&gt;<br>                                 &lt;/transformer&gt;<br>                             &lt;/transformers&gt;<br>                         &lt;/configuration&gt;<br>                     &lt;/execution&gt;<br>                 &lt;/executions&gt;<br>             &lt;/plugin&gt;<br>         &lt;/plugins&gt;<br>     &lt;/build&gt;<br> &lt;/project&gt;</p> 
<p>7.将src/main/java和src/test/java分别修改成src/main/scala和src/test/scala，与pom.xml中的配置保持一致<br>  </p> 
<p> </p> 
<p>8.新建一个scala class，类型为Object<br>  </p> 
<p>9.编写spark程序<br> package cn.itcast.spark</p> 
<p>import org.apache.spark.{SparkContext, SparkConf}</p> 
<p>object WordCount {<!-- --><br>   def main(args: Array[String]) {<!-- --><br>     //创建SparkConf()并设置App名称<br>     val conf = new SparkConf().setAppName("WC")<br>     //创建SparkContext，该对象是提交spark App的入口<br>     val sc = new SparkContext(conf)<br>     //使用sc创建RDD并执行相应的transformation和action<br>     sc.textFile(args(0)).flatMap(_.split(" ")).map((_, 1)).reduceByKey(_+_, 1).sortBy(_._2, false).saveAsTextFile(args(1))<br>     //停止sc，结束该任务<br>     sc.stop()<br>   }<br> }</p> 
<p>10.使用Maven打包：首先修改pom.xml中的main class<br>  </p> 
<p>点击idea右侧的Maven Project选项<br>  </p> 
<p>点击Lifecycle,选择clean和package，然后点击Run Maven Build<br>  </p> 
<p>11.选择编译成功的jar包，并将该jar上传到Spark集群中的某个节点上<br>  </p> 
<p>12.首先启动hdfs和Spark集群<br> 启动hdfs<br> /usr/local/hadoop-2.6.1/sbin/start-dfs.sh<br> 启动spark<br> /usr/local/spark-1.5.2-bin-hadoop2.6/sbin/start-all.sh</p> 
<p>13.使用spark-submit命令提交Spark应用（注意参数的顺序）<br> /usr/local/spark-1.5.2-bin-hadoop2.6/bin/spark-submit \<br> --class cn.itcast.spark.WordCount \<br> --master spark://node1.itcast.cn:7077 \<br> --executor-memory 2G \<br> --total-executor-cores 4 \<br> /root/spark-mvn-1.0-SNAPSHOT.jar \<br> hdfs://node1.itcast.cn:9000/words.txt \<br> hdfs://node1.itcast.cn:9000/out</p> 
<p>查看程序执行结果<br> hdfs dfs -cat hdfs://node1.itcast.cn:9000/out/part-00000<br> (hello,6)<br> (tom,3)<br> (kitty,2)<br> (jerry,1)</p> 
<h2 style="margin-left:21.25pt;text-align:center;"> </h2> 
<p style="margin-left:0;text-align:justify;"><img src="https://images2.imgbox.com/bf/b1/w1YLgLh4_o.png" alt="118ef627c96642e4babe4d34a87c2776.png"></p> 
<p> </p> 
<p style="margin-left:0;text-align:justify;">Spark Streaming类似于Apache Storm，用于流式数据的处理。根据其官方文档介绍，Spark Streaming有高吞吐量和容错能力强等特点。Spark Streaming支持的数据输入源很多，例如：Kafka、Flume、Twitter、ZeroMQ和简单的TCP套接字等等。数据输入后可以用Spark的高度抽象原语如：map、reduce、join、window等进行运算。而结果也能保存在很多地方，如HDFS，数据库等。另外Spark Streaming也能和MLlib（机器学习）以及Graphx完美融合。</p> 
<p style="margin-left:0;text-align:justify;"><img src="https://images2.imgbox.com/6f/0b/aMOhcnXt_o.png" alt="a731312aa60c4a7ab67d0686ca54d06d.png"></p> 
<p> </p> 
<ol><li> 
  <ol><li> 
    <ol><li style="text-align:justify;">为什么要学习Spark Streaming</li></ol></li></ol></li></ol> 
<p style="margin-left:0;text-align:justify;"> </p> 
<ol><li style="text-align:justify;">易用</li></ol> 
<p style="margin-left:0;text-align:justify;"> </p> 
<ol><li style="text-align:justify;">容错</li></ol> 
<p style="margin-left:0;text-align:justify;"> </p> 
<ol><li style="text-align:justify;">易整合到Spark体系</li></ol> 
<p style="margin-left:0;text-align:justify;"> </p> 
<ol><li> 
  <ol><li> 
    <ol><li style="text-align:justify;">Spark与Storm的对比</li></ol></li></ol></li></ol> 
<table border="1" cellspacing="0" style="width:568px;"><tbody><tr><td style="border-color:#000000;vertical-align:top;width:213.05pt;"> <p style="margin-left:0;text-align:center;"><strong>Spark</strong></p> </td><td style="border-color:#000000;vertical-align:top;width:213.05pt;"> <p style="margin-left:0;text-align:center;"><strong>Storm</strong></p> </td></tr><tr><td style="border-color:#000000;vertical-align:top;width:213.05pt;"> <p style="margin-left:0;text-align:justify;"><img src="https://images2.imgbox.com/9b/f3/Zjtp83xs_o.png" alt="d013fc58bac04be79b273e39d5c3b7c1.png"></p> <p> </p> </td><td style="vertical-align:top;width:213.05pt;"><img src="https://images2.imgbox.com/14/9d/uAOEXLAD_o.png" alt="222fccedf3e7424bb42d42c7898cab0e.png"></td></tr><tr><td style="border-color:#000000;vertical-align:top;width:213.05pt;"> <p style="margin-left:0;text-align:center;">开发语言：Scala</p> </td><td style="vertical-align:top;width:213.05pt;">开发语言：Clojure</td></tr><tr><td style="border-color:#000000;vertical-align:top;width:213.05pt;"> <p style="margin-left:0;text-align:center;">编程模型：DStream</p> </td><td style="vertical-align:top;width:213.05pt;"> <p style="margin-left:0;text-align:center;">编程模型：Spout/Bolt</p> </td></tr><tr><td style="border-color:#000000;vertical-align:top;width:213.05pt;"> <p style="margin-left:0;text-align:center;"> </p> </td><td style="vertical-align:top;width:213.05pt;"> <p style="margin-left:0;text-align:center;"> </p> </td></tr></tbody></table> 
<p> <img src="https://images2.imgbox.com/13/f8/ciPmOYb3_o.png" alt="c5bcd70d6982434aab6ce358b761a1eb.png"><img src="https://images2.imgbox.com/cf/40/JPmSvkJ3_o.png" alt="1a845009a40941f989a6bb8dd01da4bd.png"></p> 
<p> </p> 
<p> </p> 
<p style="margin-left:0;text-align:justify;"> </p> 
<ol><li style="text-align:justify;">DStream 
  <ol><li style="text-align:justify;">什么是DStream</li></ol></li></ol> 
<p style="margin-left:0;text-align:justify;">Discretized Stream是Spark Streaming的基础抽象，代表持续性的数据流和经过各种Spark原语操作后的结果数据流。在内部实现上，DStream是一系列连续的RDD来表示。每个RDD含有一段时间间隔内的数据，如下图：</p> 
<p style="margin-left:0;text-align:justify;"><img src="https://images2.imgbox.com/27/6d/JjgJpdHB_o.png" alt="d93758de4ff04f28946052eb08f8f35a.png"></p> 
<p> </p> 
<p style="margin-left:0;text-align:justify;">对数据的操作也是按照RDD为单位来进行的</p> 
<p style="margin-left:0;text-align:justify;"><img src="https://images2.imgbox.com/59/ca/cLWRMag6_o.png" alt="c68221fb9cc546afaa7c271a1dad8228.png"></p> 
<p> </p> 
<p style="margin-left:0;text-align:justify;">计算过程由Spark engine来完成</p> 
<p style="margin-left:0;text-align:justify;"><img src="https://images2.imgbox.com/6e/8a/W8ti4qQp_o.png" alt="644ae748797249fdaf24e0dcf9f4e908.png"></p> 
<p> </p> 
<ol><li> 
  <ol><li style="text-align:justify;">DStream相关操作</li></ol></li></ol> 
<p style="margin-left:0;text-align:justify;">DStream上的原语与RDD的类似，分为Transformations（转换）和Output Operations（输出）两种，此外转换操作中还有一些比较特殊的原语，如：updateStateByKey()、transform()以及各种Window相关的原语。</p> 
<p style="margin-left:0;text-align:justify;"> </p> 
<ol><li> 
  <ol><li> 
    <ol><li style="text-align:justify;">Transformations on DStreams</li></ol></li></ol></li></ol> 
<table border="1" cellspacing="0" style="width:568px;"><tbody><tr><td style="border-color:#000000;vertical-align:top;width:160.55pt;"> <p style="margin-left:0;text-align:center;"><strong>Transformation</strong></p> </td><td style="border-color:#000000;vertical-align:top;width:265.55pt;"> <p style="margin-left:0;text-align:center;"><strong>Meaning</strong></p> </td></tr><tr><td style="border-color:#000000;vertical-align:top;width:160.55pt;"> <p style="margin-left:0;text-align:justify;">map(func)</p> </td><td style="vertical-align:top;width:265.55pt;"> <p style="margin-left:0;text-align:justify;">Return a new DStream by passing each element of the source DStream through a function func.</p> </td></tr><tr><td style="border-color:#000000;vertical-align:top;width:160.55pt;"> <p style="margin-left:0;text-align:justify;">flatMap(func)</p> </td><td style="vertical-align:top;width:265.55pt;"> <p style="margin-left:0;text-align:justify;">Similar to map, but each input item can be mapped to 0 or more output items.</p> </td></tr><tr><td style="border-color:#000000;vertical-align:top;width:160.55pt;"> <p style="margin-left:0;text-align:justify;">filter(func)</p> </td><td style="vertical-align:top;width:265.55pt;"> <p style="margin-left:0;text-align:justify;">Return a new DStream by selecting only the records of the source DStream on which func returns true.</p> </td></tr><tr><td style="border-color:#000000;vertical-align:top;width:160.55pt;"> <p style="margin-left:0;text-align:justify;">repartition(numPartitions)</p> </td><td style="vertical-align:top;width:265.55pt;"> <p style="margin-left:0;text-align:justify;">Changes the level of parallelism in this DStream by creating more or fewer partitions.</p> </td></tr><tr><td style="border-color:#000000;vertical-align:top;width:160.55pt;"> <p style="margin-left:0;text-align:justify;">union(otherStream)</p> </td><td style="vertical-align:top;width:265.55pt;"> <p style="margin-left:0;text-align:justify;">Return a new DStream that contains the union of the elements in the source DStream and otherDStream.</p> </td></tr><tr><td style="border-color:#000000;vertical-align:top;width:160.55pt;"> <p style="margin-left:0;text-align:justify;">count()</p> </td><td style="vertical-align:top;width:265.55pt;"> <p style="margin-left:0;text-align:justify;">Return a new DStream of single-element RDDs by counting the number of elements in each RDD of the source DStream.</p> </td></tr><tr><td style="border-color:#000000;vertical-align:top;width:160.55pt;"> <p style="margin-left:0;text-align:justify;">reduce(func)</p> </td><td style="vertical-align:top;width:265.55pt;"> <p style="margin-left:0;text-align:justify;">Return a new DStream of single-element RDDs by aggregating the elements in each RDD of the source DStream using a function func (which takes two arguments and returns one). The function should be associative so that it can be computed in parallel.</p> </td></tr><tr><td style="border-color:#000000;vertical-align:top;width:160.55pt;"> <p style="margin-left:0;text-align:justify;">countByValue()</p> </td><td style="vertical-align:top;width:265.55pt;"> <p style="margin-left:0;text-align:justify;">When called on a DStream of elements of type K, return a new DStream of (K, Long) pairs where the value of each key is its frequency in each RDD of the source DStream.</p> </td></tr><tr><td style="border-color:#000000;vertical-align:top;width:160.55pt;"> <p style="margin-left:0;text-align:justify;">reduceByKey(func, [numTasks])      </p> </td><td style="vertical-align:top;width:265.55pt;"> <p style="margin-left:0;text-align:justify;">When called on a DStream of (K, V) pairs, return a new DStream of (K, V) pairs where the values for each key are aggregated using the given reduce function. Note: By default, this uses Spark's default number of parallel tasks (2 for local mode, and in cluster mode the number is determined by the config property spark.default.parallelism) to do the grouping. You can pass an optional numTasks argument to set a different number of tasks.</p> </td></tr><tr><td style="border-color:#000000;vertical-align:top;width:160.55pt;"> <p style="margin-left:0;text-align:justify;">join(otherStream, [numTasks])</p> </td><td style="vertical-align:top;width:265.55pt;"> <p style="margin-left:0;text-align:justify;">When called on two DStreams of (K, V) and (K, W) pairs, return a new DStream of (K, (V, W)) pairs with all pairs of elements for each key.</p> </td></tr><tr><td style="border-color:#000000;vertical-align:top;width:160.55pt;"> <p style="margin-left:0;text-align:justify;">cogroup(otherStream, [numTasks])</p> </td><td style="vertical-align:top;width:265.55pt;"> <p style="margin-left:0;text-align:justify;">When called on a DStream of (K, V) and (K, W) pairs, return a new DStream of (K, Seq[V], Seq[W]) tuples.</p> </td></tr><tr><td style="border-color:#000000;vertical-align:top;width:160.55pt;"> <p style="margin-left:0;text-align:justify;">transform(func)       </p> </td><td style="vertical-align:top;width:265.55pt;"> <p style="margin-left:0;text-align:justify;">Return a new DStream by applying a RDD-to-RDD function to every RDD of the source DStream. This can be used to do arbitrary RDD operations on the DStream.</p> </td></tr><tr><td style="border-color:#000000;vertical-align:top;width:160.55pt;"> <p style="margin-left:0;text-align:justify;">updateStateByKey(func)</p> </td><td style="vertical-align:top;width:265.55pt;"> <p style="margin-left:0;text-align:justify;">Return a new "state" DStream where the state for each key is updated by applying the given function on the previous state of the key and the new values for the key. This can be used to maintain arbitrary state data for each key.</p> </td></tr></tbody></table> 
<p style="margin-left:0;text-align:justify;"> </p> 
<p style="margin-left:0;text-align:justify;"><strong>特殊的Transformations</strong></p> 
<p style="margin-left:0;text-align:justify;"> </p> 
<ol><li style="text-align:justify;"><strong>UpdateStateByKey Operation</strong></li></ol> 
<p style="margin-left:0;text-align:justify;">UpdateStateByKey原语用于记录历史记录，上文中Word Count示例中就用到了该特性。若不用UpdateStateByKey来更新状态，那么每次数据进来后分析完成后，结果输出后将不在保存</p> 
<p style="margin-left:0;text-align:justify;"> </p> 
<ol><li style="text-align:justify;"><strong>Transform Operation</strong></li></ol> 
<p style="margin-left:0;text-align:justify;">Transform原语允许DStream上执行任意的RDD-to-RDD函数。通过该函数可以方便的扩展Spark API。此外，MLlib（机器学习）以及Graphx也是通过本函数来进行结合的。</p> 
<p style="margin-left:0;text-align:justify;"> </p> 
<ol><li style="text-align:justify;"><strong>Window Operations</strong></li></ol> 
<p style="margin-left:0;text-align:justify;">Window Operations有点类似于Storm中的State，可以设置窗口的大小和滑动窗口的间隔来动态的获取当前Steaming的允许状态</p> 
<p style="margin-left:0;text-align:justify;"><img src="https://images2.imgbox.com/88/97/ReuKLMRl_o.png" alt="843c839d05d24195a2bed79921144070.png"></p> 
<p> </p> 
<ol><li> 
  <ol><li> 
    <ol><li style="text-align:justify;">Output Operations on DStreams</li></ol></li></ol></li></ol> 
<p style="margin-left:0;text-align:justify;">Output Operations可以将DStream的数据输出到外部的数据库或文件系统，当某个Output Operations原语被调用时（与RDD的Action相同），streaming程序才会开始真正的计算过程。</p> 
<table border="1" cellspacing="0" style="width:568px;"><tbody><tr><td style="border-color:#000000;vertical-align:top;width:165.05pt;"> <p style="margin-left:0;text-align:center;">Output Operation</p> </td><td style="border-color:#000000;vertical-align:top;width:261.05pt;"> <p style="margin-left:0;text-align:center;">Meaning</p> </td></tr><tr><td style="border-color:#000000;vertical-align:top;width:165.05pt;"> <p style="margin-left:0;text-align:justify;">print()</p> </td><td style="vertical-align:top;width:261.05pt;"> <p style="margin-left:0;text-align:justify;">Prints the first ten elements of every batch of data in a DStream on the driver node running the streaming application. This is useful for development and debugging.</p> </td></tr><tr><td style="border-color:#000000;vertical-align:top;width:165.05pt;"> <p style="margin-left:0;text-align:justify;">saveAsTextFiles(prefix, [suffix])</p> </td><td style="vertical-align:top;width:261.05pt;"> <p style="margin-left:0;text-align:justify;">Save this DStream's contents as text files. The file name at each batch interval is generated based on prefix and suffix: "prefix-TIME_IN_MS[.suffix]".</p> </td></tr><tr><td style="border-color:#000000;vertical-align:top;width:165.05pt;"> <p style="margin-left:0;text-align:justify;">saveAsObjectFiles(prefix, [suffix])</p> </td><td style="vertical-align:top;width:261.05pt;"> <p style="margin-left:0;text-align:justify;">Save this DStream's contents as SequenceFiles of serialized Java objects. The file name at each batch interval is generated based on prefix and suffix: "prefix-TIME_IN_MS[.suffix]".</p> </td></tr><tr><td style="border-color:#000000;vertical-align:top;width:165.05pt;"> <p style="margin-left:0;text-align:justify;">saveAsHadoopFiles(prefix, [suffix])</p> </td><td style="vertical-align:top;width:261.05pt;"> <p style="margin-left:0;text-align:justify;">Save this DStream's contents as Hadoop files. The file name at each batch interval is generated based on prefix and suffix: "prefix-TIME_IN_MS[.suffix]".</p> </td></tr><tr><td style="border-color:#000000;vertical-align:top;width:165.05pt;"> <p style="margin-left:0;text-align:justify;">foreachRDD(func)</p> </td><td style="vertical-align:top;width:261.05pt;"> <p style="margin-left:0;text-align:justify;">The most generic output operator that applies a function, func, to each RDD generated from the stream. This function should push the data in each RDD to an external system, such as saving the RDD to files, or writing it over the network to a database. Note that the function func is executed in the driver process running the streaming application, and will usually have RDD actions in it that will force the computation of the streaming RDDs.</p> </td></tr></tbody></table> 
<ol><li style="text-align:justify;">实战 
  <ol><li style="text-align:justify;">用Spark Streaming实现实时WordCount</li></ol></li></ol> 
<p style="margin-left:0;text-align:justify;">架构图：</p> 
<p style="margin-left:0;text-align:justify;"><img src="https://images2.imgbox.com/86/e6/fmG4vVXv_o.png" alt="019efa675139471791c661ceb1388999.png"></p> 
<p> </p> 
<ol><li style="text-align:justify;">安装并启动生成者</li></ol> 
<p style="margin-left:0;text-align:justify;">首先在一台Linux（ip：192.168.10.101）上用YUM安装nc工具</p> 
<p style="margin-left:0;text-align:justify;">yum install -y nc</p> 
<p style="margin-left:0;text-align:justify;"> </p> 
<p style="margin-left:0;text-align:justify;">启动一个服务端并监听9999端口</p> 
<p style="margin-left:0;text-align:justify;">nc -lk 9999</p> 
<p style="margin-left:0;text-align:justify;"> </p> 
<ol><li style="text-align:justify;">编写Spark Streaming程序</li></ol> 
<table border="1" cellspacing="0" style="width:568px;"><tbody><tr><td style="border-color:#000000;vertical-align:top;width:426.1pt;"> <pre style="margin-left:.0001pt;"><strong>package </strong>cn.itcast.spark.streaming

  

  <strong>import </strong>cn.itcast.spark.util.LoggerLevel

  <strong>import </strong>org.apache.spark.SparkConf

  <strong>import </strong>org.apache.spark.streaming.{Seconds, StreamingContext}

  

  <strong>object </strong>NetworkWordCount {

  <strong>def </strong>main(args: Array[String]) {

    <em>//</em><em>设置日志级别

    </em>LoggerLevel.<em>setStreamingLogLevels</em>()

    <em>//</em><em>创建SparkConf并设置为本地模式运行

    //注意local[2]代表开两个线程

    </em><strong>val </strong>conf = <strong>new </strong>SparkConf().setMaster(<strong>"local[2]"</strong>).setAppName(<strong>"NetworkWordCount"</strong>)

    <em>//</em><em>设置DStream批次时间间隔为2秒

    </em><strong>val </strong>ssc = <strong>new </strong>StreamingContext(conf, <em>Seconds</em>(2))

    <em>//</em><em>通过网络读取数据

    </em><strong>val </strong>lines = ssc.socketTextStream(<strong>"192.168.10.101"</strong>, 9999)

    <em>//</em><em>将读到的数据用空格切成单词

    </em><strong>val </strong>words = lines.flatMap(_.split(<strong>" "</strong>))

    <em>//</em><em>将单词和1组成一个pair

    </em><strong>val </strong>pairs = words.map(word =&gt; (word, 1))

    <em>//</em><em>按单词进行分组求相同单词出现的次数

    </em><strong>val </strong>wordCounts = pairs.reduceByKey(_ + _)

    <em>//</em><em>打印结果到控制台

    </em>wordCounts.print()

    <em>//</em><em>开始计算

    </em>ssc.start()

    <em>//</em><em>等待停止

    </em>ssc.awaitTermination()

  }

}</pre> </td></tr></tbody></table> 
<p style="margin-left:0;text-align:justify;"> </p> 
<p style="margin-left:0;text-align:justify;">3.启动Spark Streaming程序：由于使用的是本地模式<strong>"local[2]"</strong>所以可以直接在本地运行该程序</p> 
<p style="margin-left:0;text-align:justify;">注意：要指定并行度，如在本地运行设置setMaster("local[2]")，相当于启动两个线程，一个给receiver，一个给computer。如果是在集群中运行，必须要求集群中可用core数大于1</p> 
<p style="margin-left:0;text-align:justify;"><img src="https://images2.imgbox.com/83/1b/ftFHVC5q_o.png" alt="a27dcd720357480887087ea2a627424b.png"></p> 
<p> </p> 
<p style="margin-left:0;text-align:justify;"> </p> 
<p style="margin-left:0;text-align:justify;">4.在Linux端命令行中输入单词</p> 
<p style="margin-left:0;text-align:justify;"><img src="https://images2.imgbox.com/98/b9/s1wKc21C_o.png" alt="651d1d0b79684d33a951c895aaa6cc6f.png"></p> 
<p> </p> 
<ol><li style="text-align:justify;">在IDEA控制台中查看结果</li></ol> 
<p style="margin-left:0;text-align:justify;"><img src="https://images2.imgbox.com/db/a6/fwEdpV3Y_o.png" alt="f2d6173f50e846908df52d6ef13e7fc1.png"></p> 
<p> </p> 
<p style="margin-left:0;text-align:justify;">问题：结果每次在Linux段输入的单词次数都被正确的统计出来，但是结果不能累加！如果需要累加需要使用updateStateByKey(func)来更新状态，下面给出一个例子：</p> 
<table border="1" cellspacing="0" style="width:568px;"><tbody><tr><td style="border-color:#000000;vertical-align:top;width:426.1pt;"> <pre style="margin-left:.0001pt;"><strong>package </strong>cn.itcast.spark.streaming

  

  <strong>import </strong>cn.itcast.spark.util.LoggerLevel

  <strong>import </strong>org.apache.spark.{HashPartitioner, SparkConf}

  <strong>import </strong>org.apache.spark.streaming.{StreamingContext, Seconds}

  

  <strong>object </strong>NetworkUpdateStateWordCount {

  <em>/**

    * String : </em><em>单词 hello

    * Seq[Int] ：单词在当前批次出现的次数

    * Option[Int] ： 历史结果

    */

  </em><strong>val </strong><em>updateFunc </em>= (iter: Iterator[(String, Seq[Int], Option[Int])]) =&gt; {

    <em>//iter.flatMap(it=&gt;Some(it._2.sum + it._3.getOrElse(0)).map(x=&gt;(it._1,x)))

    </em>iter.flatMap{<!-- --><strong>case</strong>(x,y,z)=&gt;<em>Some</em>(y.sum + z.getOrElse(0)).map(m=&gt;(x, m))}

  }

  

  <strong>def </strong>main(args: Array[String]) {

    LoggerLevel.<em>setStreamingLogLevels</em>()

    <strong>val </strong>conf = <strong>new </strong>SparkConf().setMaster(<strong>"local[2]"</strong>).setAppName(<strong>"NetworkUpdateStateWordCount"</strong>)

    <strong>val </strong>ssc = <strong>new </strong>StreamingContext(conf, <em>Seconds</em>(5))

    <em>//</em><em>做checkpoint 写入共享存储中

    </em>ssc.checkpoint(<strong>"c://aaa"</strong>)

    <strong>val </strong>lines = ssc.socketTextStream(<strong>"192.168.10.100"</strong>, 9999)

    <em>//reduceByKey </em><em>结果不累加

    //val result = lines.flatMap(_.split(" ")).map((_, 1)).reduceByKey(_+_)

    //updateStateByKey结果可以累加但是需要传入一个自定义的累加函数：updateFunc

    </em><strong>val </strong>results = lines.flatMap(_.split(<strong>" "</strong>)).map((_,1)).updateStateByKey(<em>updateFunc</em>, <strong>new </strong>HashPartitioner(ssc.sparkContext.defaultParallelism), <strong>true</strong>)

    results.print()

    ssc.start()

    ssc.awaitTermination()

  }

}</pre> <pre style="margin-left:.0001pt;"> </pre> </td></tr></tbody></table> 
<ol><li> 
  <ol><li style="text-align:justify;">Spark Streaming整合Kafka完成网站点击流实时统计</li></ol></li></ol> 
<p style="margin-left:0;text-align:justify;"><img src="https://images2.imgbox.com/57/5b/6ErTFjYz_o.png" alt="48449823b8234575a5d5f6980a2a050b.png"></p> 
<p> </p> 
<ol><li style="text-align:justify;">安装并配置zk</li><li style="text-align:justify;">安装并配置Kafka</li><li style="text-align:justify;">启动zk</li><li style="text-align:justify;">启动Kafka</li><li style="text-align:justify;">创建topic</li></ol> 
<p style="margin-left:0;text-align:justify;">bin/kafka-topics.sh --create --zookeeper node1.itcast.cn:2181,node2.itcast.cn:2181 \</p> 
<p style="margin-left:0;text-align:justify;">--replication-factor 3 --partitions 3 --topic urlcount</p> 
<ol><li style="text-align:justify;">编写Spark Streaming应用程序</li></ol> 
<table border="1" cellspacing="0" style="width:568px;"><tbody><tr><td style="border-color:#000000;vertical-align:top;width:426.1pt;"> <pre style="margin-left:.0001pt;"><strong>package </strong>cn.itcast.spark.streaming

  

  <strong>package </strong>cn.itcast.spark

  

  <strong>import </strong>org.apache.spark.{HashPartitioner, SparkConf}

  <strong>import </strong>org.apache.spark.storage.StorageLevel

  <strong>import </strong>org.apache.spark.streaming.kafka.KafkaUtils

  <strong>import </strong>org.apache.spark.streaming.{Seconds, StreamingContext}

  

  <strong>object </strong>UrlCount {

  <strong>val </strong><em>updateFunc </em>= (iterator: Iterator[(String, Seq[Int], Option[Int])]) =&gt; {

    iterator.flatMap{<!-- --><strong>case</strong>(x,y,z)=&gt; <em>Some</em>(y.sum + z.getOrElse(0)).map(n=&gt;(x, n))}

  }

  

  <strong>def </strong>main(args: Array[String]) {

    <em>//</em><em>接收命令行中的参数

    </em><strong>val </strong><em>Array</em>(zkQuorum, groupId, topics, numThreads, hdfs) = args

    <em>//</em><em>创建SparkConf并设置AppName

    </em><strong>val </strong>conf = <strong>new </strong>SparkConf().setAppName(<strong>"UrlCount"</strong>)

    <em>//</em><em>创建StreamingContext

    </em><strong>val </strong>ssc = <strong>new </strong>StreamingContext(conf, <em>Seconds</em>(2))

    <em>//</em><em>设置检查点

    </em>ssc.checkpoint(hdfs)

    <em>//</em><em>设置topic信息

    </em><strong>val </strong>topicMap = topics.split(<strong>","</strong>).map((_, numThreads.toInt)).toMap

    <em>//</em><em>重Kafka中拉取数据创建DStream

    </em><strong>val </strong>lines = KafkaUtils.<em>createStream</em>(ssc, zkQuorum ,groupId, topicMap, StorageLevel.<em>MEMORY_AND_DISK</em>).map(_._2)

    <em>//</em><em>切分数据，截取用户点击的url

    </em><strong>val </strong>urls = lines.map(x=&gt;(x.split(<strong>" "</strong>)(6), 1))

    <em>//</em><em>统计URL点击量

    </em><strong>val </strong>result = urls.updateStateByKey(<em>updateFunc</em>, <strong>new </strong>HashPartitioner(ssc.sparkContext.defaultParallelism), <strong>true</strong>)

    <em>//</em><em>将结果打印到控制台

    </em>result.print()

    ssc.start()

    ssc.awaitTermination()

  }

}</pre> </td></tr></tbody></table> 
<p style="margin-left:0;text-align:justify;"> </p> 
<p> </p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/b1d1ab2ddad0b31ef5e405d5f449492a/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">Spark计算模型-RDD</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/ccbb3ea8ab6749616b39767e9cb36de5/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">win10关闭防火墙脚本.bat</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>