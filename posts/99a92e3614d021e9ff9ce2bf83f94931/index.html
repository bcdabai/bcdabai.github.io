<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>const在c和c&#43;&#43;中的用法 - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="const在c和c&#43;&#43;中的用法" />
<meta property="og:description" content="下面只是针对于基本类型
对于标准C来说：const修饰的变量是只读变量，会分配内存空间。但是不能作为左值直接改变。可以通过指针来改变
对于现代C编译器来说：会做一些优化，会进入符号表。如果有对内存的操作出现，那么它就不会去符号表取值，而是去内存中取值。这个和C&#43;&#43;进入符号表有些不同。
对于C&#43;&#43;来说：const int a=1；会进入符号表，就算给它分配了空间也不会去内存空间去取值。如果加上volatile 就会成为只读变量，和C一样了。
C&#43;&#43;中其他const只读变量的情况：
const int&amp; a=1;//a是只读变量
int b=1；const int a =b;//a是只读变量
const int b=1;const int&amp; a=b;//a是只读变量，而b会进入符号表。
等等情况；
我对只读变量的理解（在C&#43;&#43;中）： 不但要分配空间，还要去内存取值。不能作为左值直接改变，可以用指针和引用改变。 1,c语言
const修饰的变量是只读变量，不能作为左值，不能直接赋值，但是可以通过指针去改变该变量的值
（有的书上说会进入符号表，可能编译器的不同）
2，C&#43;&#43;
a，const修饰的是常量，会进入符号表。但是可能会分配存储空间，只是没有去内存中取值而已，下面就是这个情况。
下面是引用的情况
b，加volatile修饰 就会成为只读变量。与上面的程序就只是一个volatile区别
下面是引用的情况
c，当使用字面量对const引用进行初始化时，C&#43;&#43;编译器会为常量值分配空间，是只读变量
指针不能指向引用，所以没有指针的情况
d，使用其它变量初始化的const常量仍然是只读变量
引用情况
e，const引用的类型与初始化变量的类型
相同：
不同：生成一个新的只读变量，其初始值与初始化变量相同
综合例子：
int main(int argc, char *argv[])
{
const int x = 1;
const int&amp; rx = x;//x分配了内存，只是不能再内存里去值,rx是只读变量
int&amp; nrx = const_cast&lt;int&amp;&gt;(rx);//此时rx还是只读变量
nrx = 5;
printf(&#34;x = %d\n&#34;, x);//1
printf(&#34;rx = %d\n&#34;" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/99a92e3614d021e9ff9ce2bf83f94931/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2018-03-30T17:42:43+08:00" />
<meta property="article:modified_time" content="2018-03-30T17:42:43+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">const在c和c&#43;&#43;中的用法</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p>下面只是针对于基本类型</p> 
<p>对于标准C来说：const修饰的变量是只读变量，会分配内存空间。但是不能作为左值直接改变。可以通过指针来改变</p> 
<p>对于现代C编译器来说：会做一些优化，会进入符号表。如果有对内存的操作出现，那么它就不会去符号表取值，而是去内存中取值。这个和C++进入符号表有些不同。</p> 
<p>对于C++来说：const int a=1；会进入符号表，就算给它分配了空间也不会去内存空间去取值。如果加上volatile 就会成为只读变量，和C一样了。</p> 
<p>C++中其他const只读变量的情况：</p> 
<p>const int&amp; a=1;//a是只读变量</p> 
<p>int b=1；const int a =b;//a是只读变量</p> 
<p>const int b=1;const int&amp; a=b;//a是只读变量，而b会进入符号表。</p> 
<p>等等情况；</p> 
<h4>我对只读变量的理解（在C++中）：</h4> 
<h4>不但要分配空间，还要去内存取值。不能作为左值直接改变，可以用指针和引用改变。</h4> 
<p> </p> 
<p>1,c语言</p> 
<p>const修饰的变量是只读变量，不能作为左值，不能直接赋值，但是可以通过指针去改变该变量的值</p> 
<p>（有的书上说会进入符号表，可能编译器的不同）</p> 
<p><img alt="" class="has" src="https://images2.imgbox.com/99/2b/x7PNMkIA_o.png"></p> 
<p> </p> 
<p>2，C++</p> 
<p>a，const修饰的是常量，会进入符号表。但是可能会分配存储空间，只是没有去内存中取值而已，下面就是这个情况。</p> 
<p><img alt="" class="has" src="https://images2.imgbox.com/1f/c7/trVoXzso_o.png"></p> 
<p> </p> 
<p>下面是引用的情况</p> 
<p><img alt="" class="has" src="https://images2.imgbox.com/e8/be/cH8KdVAn_o.png"></p> 
<p>b，加volatile修饰 就会成为只读变量。与上面的程序就只是一个volatile区别</p> 
<p><img alt="" class="has" src="https://images2.imgbox.com/25/e5/5L5L4kVq_o.png"></p> 
<p> </p> 
<p>下面是引用的情况</p> 
<p><img alt="" class="has" src="https://images2.imgbox.com/61/07/wLNsKK9F_o.png"></p> 
<p> </p> 
<p>c，当使用字面量对const引用进行初始化时，C++编译器会为常量值分配空间，是只读变量</p> 
<p><img alt="" class="has" src="https://images2.imgbox.com/6c/43/UPWHNalW_o.png"></p> 
<p> </p> 
<p>指针不能指向引用，所以没有指针的情况</p> 
<p>d，使用其它变量初始化的const常量仍然是只读变量</p> 
<p><img alt="" class="has" src="https://images2.imgbox.com/ca/80/WOpo7JGp_o.png"></p> 
<p> </p> 
<p>引用情况</p> 
<p><img alt="" class="has" src="https://images2.imgbox.com/4d/1c/mdxTjbQk_o.png"></p> 
<p> </p> 
<p>e，const引用的类型与初始化变量的类型</p> 
<p>相同：</p> 
<p><img alt="" class="has" src="https://images2.imgbox.com/77/85/wOeymxCk_o.png"></p> 
<p> </p> 
<p>不同：生成一个新的只读变量，其初始值与初始化变量相同</p> 
<p><img alt="" class="has" src="https://images2.imgbox.com/c2/8d/GPALrQon_o.png"></p> 
<p> </p> 
<p>综合例子：</p> 
<p>int main(int argc, char *argv[])</p> 
<p>{<!-- --></p> 
<p>const int x = 1;</p> 
<p>const int&amp; rx = x;//x分配了内存，只是不能再内存里去值,rx是只读变量</p> 
<p>int&amp; nrx = const_cast&lt;int&amp;&gt;(rx);//此时rx还是只读变量</p> 
<p>nrx = 5;</p> 
<p>printf("x = %d\n", x);//1</p> 
<p>printf("rx = %d\n", rx);//5</p> 
<p>printf("nrx = %d\n", nrx);//5</p> 
<p>printf("x = %p\n", &amp;x);</p> 
<p>printf("rx = %p\n", &amp;rx);</p> 
<p>printf("nrx = %p\n", &amp;nrx);</p> 
<p> </p> 
<p>volatile const int y = 2;//退化为只读变量</p> 
<p>int* p = NULL;</p> 
<p> </p> 
<p>p = const_cast&lt;int*&gt;(&amp;y);</p> 
<p>*p = 6;</p> 
<p> </p> 
<p>printf("y = %d\n", y);//6</p> 
<p>printf("*p = %d\n", *p);//6</p> 
<p>const int z = y;</p> 
<p> </p> 
<p>p = const_cast&lt;int*&gt;(&amp;z);</p> 
<p>*p = 7;</p> 
<p> </p> 
<p>printf("z = %d\n", z);//7</p> 
<p>printf("*p = %d\n", *p);//7</p> 
<p> </p> 
<p>char c = 'c';</p> 
<p>char&amp; rc = c;</p> 
<p>const int&amp; trc = c;//trc为新的只读变量 他的值和初始化变量值一样</p> 
<p>rc = 'a';</p> 
<p>printf("c = %c\n", c);//a</p> 
<p>printf("rc = %c\n", rc);//a</p> 
<p>printf("trc = %c\n", trc);//c</p> 
<p>return 0;</p> 
<p>}</p> 
<p> </p> 
<p>还要啰嗦几句：</p> 
<p>只有字面量初始化const常量才会进入符号表， 不管他以后分不分配空间。const int a=1;</p> 
<p> </p> 
<p>只要对const修饰的常量进行了 取地址 或者取引用，都会分配空间。但是不一定会去里面取值</p> 
<p> </p> 
<p>对const修饰的常量进行了 取地址 或者取引用 一定要进行强制类型转换 。特别是赋值给普通指针或者普通引用时候，不强制类型转换就会出错。因为 非常指针或非常引用不能指向常量或者引用常量。</p> 
<p> </p> 
<p>以上是我见解，可能有不严谨的地方，请多指教。在dev c++中测试</p> 
<p>const 在类类型中还有很多知识点。</p> 
<p> </p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/95d8b4e67685b4479761125b06ebe03e/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">live2d添加网页看板娘</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/d7b289f852c742fef41b8f19b17e0f4a/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">#并查集#信息学奥赛一本通 1389 亲戚</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>