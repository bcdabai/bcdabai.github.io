<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>[docker] Docker资源管理 - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="[docker] Docker资源管理" />
<meta property="og:description" content="一、docker资源控制 Docker通过Cgroup 来控制容器使用的资源配额，包括CPU、内存、磁盘三大方面，基本覆盖了常见的资源配额和使用量控制。Caroup 是ControlGroups的缩写，是Linux 内核提供的一种可以限制、记录、隔离进程组所使用的物理资源(如 cpu、内存、磁盘，io等等)的机制，被LXC、docker等很多项目用于实现进程资源控制。Cgroup本身是提供将进程进行分组化管理的功能和接口的基础结构，I/O或内存的分配控制等具体的资源管理是通过该功能来实现的。
资源限制：可以对任务使用的资源总额进行限制。优先级分配：通过分配的cpu时间片数量以及磁盘IO带宽大小，实际上相当于控制了任务运行优先级。资源统计：可以统计系统的资源使用量，如cpu时长，内存用量等。任务控制： cgroup可以对任务 执行挂起、恢复等操作。 二、docker占用宿主机cpu的限制 2.1 cpu的使用率上限 Linux通过CFS (Completely Fair Scheduler，完全公平调度器）来调度各个进程对ceu的使用。CFS默认的调度周期是100ms 。我们可以设置每个容器进程的调度周期，以及在这个周期内各个容器最多能使用多少CPU时间。
使用--cpu-period 即可设置调度周期，使用--cpu-quota即可设置在每个周期内容器能使用的CPU时间。两者可以配合使用。CFS周期的有效范围是 1ms~1s，对应的--cpu-period 的数值范围是1000~1000000。而容器的CPU配额必须不小于1ms，即--cpu-quota的值必须&gt;= 1000。而容器的CPU配额必须不小于1ms，即--cpu-quota的值必须&gt;= 1000。
docker run -itd --name test5 centos:7 /bin/bash docker ps -a cd/sys/fs/cgroup/cpu/docker/9d415515c01e61a335bdc841e19b60a1ce54dd3cbaefeab7844fdcf785cd5aa4/ cd /sys/fs/cgroup/cpu/docker/ -1 cat cpu.cfs_period_us 100000 #cpu.cfs_period_us：cpu分配的周期(微秒，所以文件名中用 us 表示），默认为100000。 #cpu.cfs_quota_us：表示该cgroups限制占用的时间（微秒），默认为-1，表示不限制。 如果设为50000，表示占用50000/100000=50%的CPU。 进行CPU压力测试 docker exec -it test5 bash vi /cpu.sh #!/bin/bash i=0 while true do let i&#43;&#43; done chmod &#43;x /cpu.sh ./cpu.sh top	#可以看到这个脚本占了很多的cpu资源 设置50%的比例分配CPU使用时间上限 docker run -itd --name test6 --cpu-quota 50000 centos:7 /bin/bash	#可以重新创建一个容器并设置限额 或者 cd/sys/fs/cgroup/cpu/docker/9d415515c01e61a335bdc841e19b60a1ce54dd3cbaefeab7844fdcf785cd5aa4/ echo 50000 &gt; cpu." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/7867e5f23bccb56ab3f46fe32e8ce8b6/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2024-01-24T19:51:18+08:00" />
<meta property="article:modified_time" content="2024-01-24T19:51:18+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">[docker] Docker资源管理</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <h3 style="background-color:transparent;">一、docker资源控制</h3> 
<p><strong>Docker通过Cgroup 来控制容器使用的资源配额，包括CPU、内存、磁盘三大方面，基本覆盖了常见的资源配额和使用量控制。Caroup 是ControlGroups的缩写，是Linux 内核提供的一种可以限制、记录、隔离进程组所使用的物理资源(如 cpu、内存、磁盘，io等等)的机制，被LXC、docker等很多项目用于实现进程资源控制。Cgroup本身是提供将进程进行分组化管理的功能和接口的基础结构，I/O或内存的分配控制等具体的资源管理是通过该功能来实现的。</strong></p> 
<ul><li><span style="color:#fe2c24;"><strong>资源限制：可以对任务使用的资源总额进行限制。</strong></span></li><li><span style="color:#fe2c24;"><strong>优先级分配：通过分配的cpu时间片数量以及磁盘IO带宽大小，实际上相当于控制了任务运行优先级。</strong></span></li><li><span style="color:#fe2c24;"><strong>资源统计：可以统计系统的资源使用量，如cpu时长，内存用量等。</strong></span></li><li><span style="color:#fe2c24;"><strong>任务控制： cgroup可以对任务 执行挂起、恢复等操作。</strong></span></li></ul> 
<h3>二、docker占用宿主机cpu的限制</h3> 
<h4 id="3.1%20cpu%E7%9A%84%E4%BD%BF%E7%94%A8%E7%8E%87%E4%B8%8A%E9%99%90%C2%A0">2.1 cpu的使用率上限 </h4> 
<p> <strong>Linux通过CFS (Completely Fair Scheduler，完全公平调度器）来调度各个进程对ceu的使用。CFS默认的调度周期是100ms 。我们可以设置每个容器进程的调度周期，以及在这个周期内各个容器最多能使用多少CPU时间。</strong></p> 
<p><strong>使用--cpu-period 即可设置调度周期，使用--cpu-quota即可设置在每个周期内容器能使用的CPU时间。两者可以配合使用。CFS周期的有效范围是 1ms~1s，对应的--cpu-period 的数值范围是1000~1000000。而容器的CPU配额必须不小于1ms，即--cpu-quota的值必须&gt;= 1000。而容器的CPU配额必须不小于1ms，即--cpu-quota的值必须&gt;= 1000。</strong></p> 
<pre><code>docker run -itd --name test5 centos:7 /bin/bash

docker ps -a

cd/sys/fs/cgroup/cpu/docker/9d415515c01e61a335bdc841e19b60a1ce54dd3cbaefeab7844fdcf785cd5aa4/

cd /sys/fs/cgroup/cpu/docker/
-1
cat cpu.cfs_period_us 
100000

#cpu.cfs_period_us：cpu分配的周期(微秒，所以文件名中用 us 表示），默认为100000。
#cpu.cfs_quota_us：表示该cgroups限制占用的时间（微秒），默认为-1，表示不限制。 如果设为50000，表示占用50000/100000=50%的CPU。</code></pre> 
<p><img alt="" height="467" src="https://images2.imgbox.com/92/d1/D1rEdhTr_o.png" width="1200"></p> 
<p><img alt="" height="621" src="https://images2.imgbox.com/dd/86/pNs5LkR8_o.png" width="1200"></p> 
<h5 style="background-color:transparent;"><strong>进行CPU压力测试 </strong></h5> 
<pre><code>docker exec -it test5 bash
vi /cpu.sh
#!/bin/bash
i=0
while true
do
let i++
done

chmod +x /cpu.sh
./cpu.sh

top					#可以看到这个脚本占了很多的cpu资源</code></pre> 
<p><img alt="" height="253" src="https://images2.imgbox.com/26/94/J0Xzcmhe_o.png" width="513"></p> 
<p><img alt="" height="1200" src="https://images2.imgbox.com/27/4e/OoVpp5MW_o.png" width="1200"></p> 
<h5 style="background-color:transparent;">设置50%的比例分配CPU使用时间上限 </h5> 
<pre><code>docker run -itd --name test6 --cpu-quota 50000 centos:7 /bin/bash	#可以重新创建一个容器并设置限额
或者
cd/sys/fs/cgroup/cpu/docker/9d415515c01e61a335bdc841e19b60a1ce54dd3cbaefeab7844fdcf785cd5aa4/
echo 50000 &gt; cpu.cfs_quota_us
docker exec -it 3ed82355f811 /bin/bash
./cpu.sh

top					#可以看到cpu占用率接近50%，cgroups对cpu的控制起了效果

#在多核情况下，如果允许容器进程完全占用两个 CPU， 则可以将 cpu-period 设置为 100000（ 即 0.1 秒）， cpu-quota设置为 200000（0.2 秒）。</code></pre> 
<p><img alt="" height="271" src="https://images2.imgbox.com/e4/6d/pMMi553B_o.png" width="1200"><img alt="" height="1200" src="https://images2.imgbox.com/9f/0d/RBkKxVr1_o.png" width="1200"></p> 
<p><img alt="" height="431" src="https://images2.imgbox.com/8a/35/8vuOKLBL_o.png" width="1200"> <img alt="" height="527" src="https://images2.imgbox.com/c2/2c/BTRBu25R_o.png" width="1200"></p> 
<p><img alt="" height="1200" src="https://images2.imgbox.com/d4/80/ZkrI6PbL_o.png" width="1200"></p> 
<h4 style="background-color:transparent;">2.2 设置CPU资源占用比（设置多个容器时才有效） </h4> 
<p id="%E6%B3%A8%E6%84%8F%EF%BC%9A%E8%AF%A5%E6%96%B9%E5%BC%8F%E9%9C%80%E8%A6%81%E8%AE%BE%E7%BD%AE%E5%A4%9A%E4%B8%AA%E5%AE%B9%E5%99%A8%E6%97%B6%E6%89%8D%E4%BC%9A%E7%94%9F%E6%95%88%C2%A0"><span style="color:#fe2c24;">注意：该方式需要设置多个容器时才会生效 </span></p> 
<p><strong> 创建容器时可以使用选项  --cpu-shares  数值（该数值要为1024的倍数，1024代表一份，当个容器占用cpu的份额由自身分配的份数除于所有容器占用cpu的份数，就为该容器所占用cpu资源的百分比）</strong></p> 
<pre><code>[root@localhost ~]#docker run -id --name b1 --cpu-shares 2048 centos:7
 
[root@localhost ~]#docker run -id --name b2 --cpu-shares 1024 centos:7
 
[root@localhost ~]#docker run -id --name b3 --cpu-shares 1024 centos:7
 
创建三个容器为 b1 和 b2 和 b3，设置容器的权重，使得b1和b2和b3的CPU资源占比为1/2和1/4和1/4。</code></pre> 
<p><img alt="" height="601" src="https://images2.imgbox.com/b5/41/4GG871dk_o.png" width="1200"> <strong>开启三个终端，启动容器压测：</strong></p> 
<pre><code>#三个容器均为以下压测操作
#下载压测工具依赖环境
yum install -y epel-release
#下载压测工具
yum install -y stress
#进行四个线程压测
stress -c 2
 
 
#再开启一个终端查看测试结果
docker stats</code></pre> 
<p><img alt="" height="1200" src="https://images2.imgbox.com/7e/26/39q4zZG2_o.png" width="1200"></p> 
<h5 style="background-color:transparent;">查看容器运行状态（动态更新） </h5> 
<p><img alt="" height="229" src="https://images2.imgbox.com/90/b1/VDGmW0T8_o.png" width="1200"></p> 
<p><strong>由测试结果， 可以看到在cPU进行时间片分配的时候，容器b1比容器b2和b3多一倍的机会获得cpu的时间片。但分配的结果取决于当时主机和其他容器的运行状态，实际上也无法保证容器 b2和b3一定能获得cpu时间片</strong></p> 
<p><strong>比如容器b2和b3的进程一直是空闲的，那么容器b1是可以获取比容器b2和b3更多的cpu时间片的。极端情况下，例如主机上只运行了一个容器，即使它的cpu份额只有50，它也可以独占整个主机的cpu资源。</strong></p> 
<p><strong> Cgroups 只在容器分配的资源紧缺时，即在需要对容器使用的资源进行限制时，才会生效。因此，无法单纯根据某个容器的cpu 份额来确定有多少cpu资源分配给它，资源分配结果取决于同时运行的其他容器的CPU分配和容器中进程运行情况。</strong></p> 
<h4>2.3 设置容器绑定指定的cpu </h4> 
<h5 id="%E6%9F%A5%E7%9C%8B%E4%B8%BB%E6%9C%BA%E4%B8%AD%E7%9A%84cpu%E7%BC%96%E5%8F%B7%C2%A0" style="background-color:transparent;">查看主机中的cpu编号 </h5> 
<pre><code>top   
按数字“1”</code></pre> 
<p><img alt="" height="1200" src="https://images2.imgbox.com/1c/7d/0VXkU47g_o.png" width="1200"></p> 
<h5>进行绑核创建容器  </h5> 
<pre><code class="hljs">[root@localhost ~]#docker run -id --name b4 --cpuset-cpus 1 centos:7
</code></pre> 
<p><img alt="" height="405" src="https://images2.imgbox.com/19/5b/iTNFNBEq_o.png" width="1200"> <strong>压力测试：</strong></p> 
<pre><code class="hljs">yum install -y epel-release
yum install -y stress
 
stress -c 1</code></pre> 
<p><img alt="" height="1200" src="https://images2.imgbox.com/ac/5a/sAA1aAEd_o.png" width="1200"></p> 
<h3 style="background-color:transparent;">三、内存使用的限制</h3> 
<h4 id="%C2%A04.1%20%E9%99%90%E5%88%B6%E5%AE%B9%E5%99%A8%E5%8F%AF%E4%BB%A5%E4%BD%BF%E7%94%A8%E7%9A%84%E6%9C%80%E5%A4%A7%E5%86%85%E5%AD%98" style="background-color:transparent;"> 3.1 限制容器可以使用的最大内存</h4> 
<p><span style="color:#fe2c24;"> <strong>m （或--memory=）选项用于限制容器可以使用的最大内存 </strong></span></p> 
<pre><code class="hljs">docker run -itd --name d1 -m 512m centos:7 /bin/bash
docker  stats</code></pre> 
<p><img alt="" height="359" src="https://images2.imgbox.com/2d/66/OUUvO5Z0_o.png" width="1200"></p> 
<p><img alt="" height="209" src="https://images2.imgbox.com/6b/15/jrPASSj4_o.png" width="1200"></p> 
<h4>3.2 限制容器可用的swap 大小  </h4> 
<p><span style="color:#be191c;"><strong>#限制可用的swap 大小，--memory-swap  </strong></span></p> 
<p><span style="color:#be191c;"><strong>●强调一下， --memory-swap是必须要与 --memory（或-m）一起使用的。</strong></span></p> 
<p><span style="color:#be191c;"><strong>●正常情况下， --memory-swap 的值包含容器可用内存和可用swap 。</strong></span></p> 
<p><span style="color:#be191c;"><strong>●所以 -m 300m --memory-swap=1g 的含义为：容器可以使用300M 的物理内存，并且可以使用700M (1G - 300M)的swap。  ​  设置为0或者不设置，则容器可以使用的 swap 大小为 -m 值的两倍。  如果 --memory-swap 的值和 -m 值相同，则容器不能使用swap。  如果 --memory-swap 值为 -1，它表示容器程序使用的内存受限，而可以使用的swap空间使用不受限制（宿主机有多少swap 容器就可以使用多少）。</strong></span></p> 
<pre><code class="hljs"> #--memory-swap 的值包含容器可用内存和可用swap，减去-m的值才是可用swap的值。
 #表示容器可以使用512M的物理内存，并且可以使用512M的swap。因为1g减去512m的物理内存，剩余值才是可用swap。
 docker run -itd --name d2 -m 512m --memory-swap=1g centos:7 bash
 ​
 ​
 #--memoryswap值和 -m 的值相同，表示容器无法使用swap
 docker run -itd --name d3 -m 512m --memory-swap=512m centos:7 bash
 ​
 ​
 # --memory-swap 的值设置为0或者不设置，则容器可以使用的 swap 大小为 -m 值的两倍。
 docker run -itd --name d4 -m 512m centos:7 bash
 ​
 ​
 # --memory-swap 值为 -1，它表示容器程序使用的内存受限，但可以使用的swap空间使用不受限制（宿主机有多少swap 容器就可以使用多少）。
 docker run -itd --name d5 -m 512m --memory-swap=-1 centos:7 bash
 </code></pre> 
<h3 style="background-color:transparent;">四、对磁盘IO的配置控制（blkio）的限制  </h3> 
<p><span style="color:#fe2c24;"><strong>-device-read-bps：限制某个设备上的读速度bps ( 数据量)，单位可以是kb、mb (M)或者gb。</strong></span></p> 
<p><span style="color:#fe2c24;"><strong>--device-write-bps : 限制某个设备上的写速度bps ( 数据量)，单位可以是kb、mb (M)或者gb。</strong></span></p> 
<p><span style="color:#fe2c24;"><strong>该速度是指每秒钟进行读写操作1M，1G或者是1kb </strong></span></p> 
<p><span style="color:#fe2c24;"><strong>--device-read-iops :限制读某个设备的iops (次数)</strong></span></p> 
<p><span style="color:#fe2c24;"><strong>--device-write-iops :限制写入某个设备的iops ( 次数)</strong></span></p> 
<h4 id="5.1%20%E9%BB%98%E8%AE%A4%E6%83%85%E5%86%B5%E4%B8%8B%E5%AE%B9%E5%99%A8%E7%9A%84%E5%86%99%E9%80%9F%E5%BA%A6%C2%A0">4.1 默认情况下容器的写速度 </h4> 
<pre><code class="hljs">[root@localhost ~]#docker run -id --name e1  centos:7
[root@localhost ~]#docker exec -it e1 bash
[root@8657384cb483 /]# dd if=dev/zero of=/mnt/test.txt bs=10M count=10 oflag=direct
## oflag=direct 规避文件读写系统中所带来的缓存，避免影响测试结果</code></pre> 
<p><img alt="" height="275" src="https://images2.imgbox.com/a0/f5/e5HFxla7_o.png" width="1200"></p> 
<h4>4.2 进行写速度限制的容器创建  </h4> 
<pre><code class="hljs">docker run -it --name test10 --device-write-bps /dev/sda:1mb centos:7 /bin/bash

dd if=dev/zero of=/mnt/test.txt bs=10M count=10 oflag=direct</code></pre> 
<p><img alt="" height="243" src="https://images2.imgbox.com/9c/54/Hq2q2Wgr_o.png" width="1200"></p> 
<p>五、清除docker占用的磁盘空间 </p> 
<p><span style="color:#fe2c24;"><strong>docker system prune -a 可用于清理磁盘，删除关闭的容器、无用的数据卷和网络。 </strong></span></p> 
<pre><code class="hljs">docker system prune -a </code></pre> 
<p><img alt="" height="1200" src="https://images2.imgbox.com/a2/51/GGPFum9t_o.png" width="1200"> <img alt="" height="371" src="https://images2.imgbox.com/08/21/uD3ZoHgA_o.png" width="1200"></p> 
<h3>总结 </h3> 
<h4 id="2.%E5%AF%B9cpu%E7%9A%84%E9%99%90%E5%88%B6%E5%8F%82%E6%95%B0">对cpu的限制参数</h4> 
<pre><code class="hljs">设置单个容器进程能够使用的CPU使用率上限
针对新建的容器：
docker run --cpu-period 单个CPU调度周期时间(1000~1000000)  --cpu-quota 容器进程能够使用的最大CPU时间(&gt;=1000)

针对已存在的容器：
修改 /sys/fs/cgroup/cpu/docker/容器ID/ 目录下的 cpu.cfs_period_us(单个CPU调度周期时间)  cpu.cfs_quota_us(容器进程能够使用的最大CPU时间)  文件的值


设置多个容器的CPU占用份额（只能在多个容器同时运行且CPU资源紧张时生效）
docker run --cpu-shares 容器进程最大占用CPU的份额(值为1024的倍数)

设置容器绑定指定的CPU
docker run --cpuset-cpus CPUID1[,CPUID2,....]
</code></pre> 
<h4>对内存的限制 </h4> 
<pre><code class="hljs">设置容器能够使用的内存和swap的值
docker run -m 内存值  --memory-swap 内存和swap的总值
                                    设置 0 或 不设置，表示swap为内存的2倍
									设置 -1，表示不限制swap的值，宿主机有多少容器即可使用多少
									设置 与 -m 一样的值，表示不使用swap</code></pre> 
<h4>对磁盘IO的限制 </h4> 
<pre><code class="hljs">docker run --device-read-bps    磁盘设备文件路径:速率                  #限制容器在某个磁盘上读的速度
           --device-write-bps   磁盘设备文件路径:速率                  #限制容器在某个磁盘上写的速度
		   --device-read-iops   磁盘设备文件路径:次数                  #限制容器在某个磁盘上读的次数
           --device-write-iops  磁盘设备文件路径:次数                  #限制容器在某个磁盘上写的速度</code></pre>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/7db3b75947395620d3370c33c3452f61/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">实习记录——第三天</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/00a1a0d1d5c6ccfc91e20ae50721b300/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">24.1.24 DAY1 C&#43;&#43;</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>