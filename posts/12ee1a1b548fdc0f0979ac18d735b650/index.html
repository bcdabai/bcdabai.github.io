<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>springboot框架开发微信公众号（四）之自定义菜单的使用 - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="springboot框架开发微信公众号（四）之自定义菜单的使用" />
<meta property="og:description" content="关于自定义菜单，微信为我们提供了几个接口分别是创建、查询和删除。我们平时使用最多的就是创建菜单了，往往我们执行了创建菜单的代码后，菜单并不会当即在我们关注过的公众号上显示出来，我们可以通过重新关注的方法，来查看我们创建或更改后的菜单。下面就来跟笔者来学一学这些接口的使用方法吧
一、由于这几个接口都是https协议，所以我们首先要能让我们的程序可以请求https。 对于https请求，我们需要一个证书信任管理器， 这个管理器类需要自己定义，但需要实现X509TrustManager接口代码如下:
public class MyX509TrustManager implements X509TrustManager{ /** * 该方法用于检查客户端的证书，若不信则抛出异常 * 由于我们不需要对客户端进行认证，可以不做任何处理 */ @Override public void checkClientTrusted(X509Certificate[] chain, String authType) throws CertificateEncodingException{ } /** * 该方法用于检验服务器端的证书，若不信任则抛出异常 * 通过自己实现该方法，可以使之信任我们指定的任何证书 * 在实现该方法时，也可以不做任何处理，即一个空的方法实现 * 由于不会抛出异常，它就会信任任何证书 */ @Override public void checkServerTrusted(X509Certificate[] chain, String authType) throws CertificateEncodingException{ } /** * 返回收信任的X509证书数组 */ @Override public X509Certificate[] getAcceptedIssuers(){ return null; } 发起https请求工具类
/** * * @Description: 发起https请求并获取结果 * @Parameters: requestUrl 请求地址。 需要写全地址，即前边的http必须写上，不能只写www.baidu.com这样的。 * requestMethod 请求方式（GET、POST） * outputStr 我们在发起请求的时候传递参数到所要请求的服务器， * 要传递的参数也要看接口文档确定格式，一般是封装成json或xml." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/12ee1a1b548fdc0f0979ac18d735b650/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2018-10-16T09:00:47+08:00" />
<meta property="article:modified_time" content="2018-10-16T09:00:47+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">springboot框架开发微信公众号（四）之自定义菜单的使用</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p><strong>关于自定义菜单，微信为我们提供了几个接口分别是创建、查询和删除。我们平时使用最多的就是创建菜单了，往往我们执行了创建菜单的代码后，菜单并不会当即在我们关注过的公众号上显示出来，我们可以通过重新关注的方法，来查看我们创建或更改后的菜单。下面就来跟笔者来学一学这些接口的使用方法吧</strong></p> 
<h4><strong>一、由于这几个接口都是https协议，所以我们首先要能让我们的程序可以请求https。</strong></h4> 
<p><strong>对于https请求，我们需要一个证书信任管理器， 这个管理器类需要自己定义，但需要实现X509TrustManager接口代码如下:</strong></p> 
<pre class="has"><code class="language-java">public class MyX509TrustManager implements X509TrustManager{
	/**
	 * 该方法用于检查客户端的证书，若不信则抛出异常
	 * 由于我们不需要对客户端进行认证，可以不做任何处理
	 */
	@Override
	public void checkClientTrusted(X509Certificate[] chain, String authType)
			throws CertificateEncodingException{
		
	}
	/**
	 * 该方法用于检验服务器端的证书，若不信任则抛出异常
	 * 通过自己实现该方法，可以使之信任我们指定的任何证书
	 * 在实现该方法时，也可以不做任何处理，即一个空的方法实现
	 * 由于不会抛出异常，它就会信任任何证书
	 */
	@Override
	public void checkServerTrusted(X509Certificate[] chain, String authType) 
			throws CertificateEncodingException{
	
	}
	/**
	 * 返回收信任的X509证书数组
	 */
	@Override
	public X509Certificate[] getAcceptedIssuers(){
		return null;
	}</code></pre> 
<p><strong>发起https请求工具类</strong></p> 
<pre class="has"><code class="language-java">/**
 * 
 * @Description: 发起https请求并获取结果 
 * @Parameters: requestUrl 请求地址。 需要写全地址，即前边的http必须写上，不能只写www.baidu.com这样的。
 * 				requestMethod 请求方式（GET、POST）
 * 				outputStr 我们在发起请求的时候传递参数到所要请求的服务器，
 * 						    要传递的参数也要看接口文档确定格式，一般是封装成json或xml.
 * @Return: 	JSONObject(通过JSONObject.get(key)的方式获取json对象的属性值) 
 * @Create Date: 2018年9月19日上午8:20:33
 * @Version: V1.00
 * @author: 来日可期
 */
@Component
public class HttpRequestUtil {
	Logger logger = LoggerFactory.getLogger(HttpRequestUtil.class);
	public JSONObject httpsRequest(String requestUrl,String requestMethod,String outputStr){
		//初始化一个json对象
		JSONObject jsonObject = null;
		try {
			//创建SSLContext对象，并使用我们指定的信任管理器初始化
			TrustManager[] tmManagers = {new MyX509TrustManager()};
			SSLContext sslContext = SSLContext.getInstance("SSL","SunJSSE");
			sslContext.init(null, tmManagers, new java.security.SecureRandom());
			//从上述SSLContext对象中得到SSLSocketFactory对象
			SSLSocketFactory sslSocket = sslContext.getSocketFactory();
			
			URL url = new URL(requestUrl);
			HttpsURLConnection httpsURLConnection = (HttpsURLConnection)url.openConnection();
			httpsURLConnection.setSSLSocketFactory(sslSocket);
			
			httpsURLConnection.setDoOutput(true);   /*httpUrlConnection.setDoOutput(true);以后就可以使用conn.getOutputStream().write()  httpUrlConnection.setDoInput(true);以后就可以使用conn.getInputStream().read();  get请求用不到conn.getOutputStream()，因为参数直接追加在地址后面，因此默认是false。  post请求（比如：文件上传）需要往服务区传输大量的数据，这些数据是放在http的body里面的，因此需要在建立连接以后，往服务端写数据。  因为总是使用conn.getInputStream()获取服务端的响应，因此默认值是true。  */
			httpsURLConnection.setDoInput(true);
			httpsURLConnection.setUseCaches(false);
			//设置请求方式 GET/POST
			httpsURLConnection.setRequestMethod(requestMethod);
			if ("GET".equalsIgnoreCase(requestMethod)) {   //不考虑大小写。如果两个字符串的长度相等，并且两个字符串中的相应字符都相等（忽略大小写），则认为这两个字符串是相等的。
				httpsURLConnection.connect();
			}
			//当有数据需要提交时,往服务器端写内容 也就是发起http请求需要带的参数
			if (null != outputStr) {
				OutputStream outputStream = httpsURLConnection.getOutputStream();
				//注意编码格式，防止中文乱码
				outputStream.write(outputStr.getBytes("UTF-8"));
				outputStream.close();
			}
			
			//获得输入流  读取服务器端返回的内容
			InputStream inputStream = httpsURLConnection.getInputStream();
			InputStreamReader inputStreamReader = new InputStreamReader(inputStream,"utf-8");
			BufferedReader bufferedReader = new BufferedReader(inputStreamReader);
			String str = null;
			StringBuffer stringBuffer = new StringBuffer();
			while((str = bufferedReader.readLine()) != null){
				stringBuffer.append(str);
			}
			//释放资源
			bufferedReader.close();
			inputStreamReader.close();
			inputStream.close();
			inputStream = null;
			httpsURLConnection.disconnect();
			//将字符串转换为json对象
			jsonObject = JSONObject.fromObject(stringBuffer.toString());
			System.out.println("JSONObject----------------------&gt;"+jsonObject);
		} catch (ConnectException ce) {
			logger.error("Weixin server connection timed out.");
		} catch(Exception e){
			logger.error("https request error:{}",e);
		}
		return jsonObject;
	}
}</code></pre> 
<h4>二、封装菜单类，共有五种，将它们放到一个包下</h4> 
<pre class="has"><code class="language-java">/**
 * @Description: 按钮的基类（每个按钮对象都有一个共同的name属性，
 * 因此需要定义一个按钮对象的基类，所有按钮对象都需要继承该类）
 * @Parameters: 
 * @Return: 
 * @Create Date: 2018年3月10日上午9:30:27
 * @Version: V1.00
 * @author: 来日可期
 */
public class Button {
	private String name;
	
	public void setName(String name){
		this.name = name;
	}
	public String getName(){
		return name;
	}

}



/**
 * @Description: click类型的按钮（有type、name和key3个属性）
 * @Parameters: 
 * @Return: 
 * @Create Date: 2018年3月10日上午9:35:30
 * @Version: V1.00
 * @author: 来日可期
 */
public class ClickButton extends Button {
	private String type;
	private String key;
	public String getType() {
		return type;
	}
	public void setType(String type) {
		this.type = type;
	}
	public String getKey() {
		return key;
	}
	public void setKey(String key) {
		this.key = key;
	}
}



/**
 * @Description: view类型的按钮(有type、name、url三个属性)
 * @Parameters: 
 * @Return: 
 * @Create Date: 2018年3月10日上午9:39:06
 * @Version: V1.00
 * @author: 来日可期
 */
public class ViewButton extends Button{

	public String type;
	public String url;
	public String getType() {
		return type;
	}
	public void setType(String type) {
		this.type = type;
	}
	public String getUrl() {
		return url;
	}
	public void setUrl(String url) {
		this.url = url;
	}
}



/** 
 * @Description: 复合类型的按钮（也就是含有子菜单的一级菜单）
 * @Parameters: 
 * @Return: 
 * @Create Date: 2018年3月10日上午9:43:13
 * @Version: V1.00
 * @author: 来日可期
 */
public class ComplexButton extends Button{
	private Button[] sub_button;

	public Button[] getSub_button() {
		return sub_button;
	}

	public void setSub_button(Button[] sub_button) {
		this.sub_button = sub_button;
	}

}



/**
 * @Description: 菜单
 * @Parameters: 
 * @Return: 
 * @Create Date: 2018年3月10日上午9:47:20
 * @Version: V1.00
 * @author: 来日可期
 */
public class Menu {
	private Button[] button;

	public Button[] getButton() {
		return button;
	}
	public void setButton(Button[] button) {
		this.button = button;
	}
}
</code></pre> 
<h4>三、利用封装的菜单类和按钮类，编辑自己的自定义菜单</h4> 
<p>click类型的按钮，key值对应微信请求消息中MsgType（请求消息的类型）中Event（事件）的EventKey（事件的key值）</p> 
<pre class="has"><code class="language-java">package com.b505.weixin.util;

import com.b505.weixin.menu.Button;
import com.b505.weixin.menu.ClickButton;
import com.b505.weixin.menu.Menu;
import com.b505.weixin.menu.ViewButton;

/**
 * @Description: 菜单管理器类
 * @Parameters: 
 * @Return: 
 * @Create Date: 2018年9月28日下午4:33:24
 * @Version: V1.00
 * @author: 来日可期
 */
public class WechatMenuManagerUtil {
	/**
	 * @Description: 定义菜单结构
	 * @Parameters: 
	 * @Return: 
	 * @Create Date: 2018年9月28日下午5:36:08
	 * @Version: V1.00
	 * @author: 来日可期
	 */
	public Menu getMenu(){
		ClickButton firstClickButton = new ClickButton();
		firstClickButton.setName("功能图文");
		firstClickButton.setKey("function");
		firstClickButton.setType("click");
		
		ViewButton firstViewButton = new ViewButton();
		firstViewButton.setName("联系我们");
		firstViewButton.setType("view");
		firstViewButton.setUrl("");
		
		Menu menu = new Menu();
		Button[] boButtons = {firstClickButton,firstViewButton};
		menu.setButton(boButtons);
		
		return menu;
	}
}
</code></pre> 
<h4>四、编写自定义菜单工具类，调用微信接口，实现菜单的创建，查询与删除</h4> 
<p>如果是创建菜单，则需要将第三步中编辑好的菜单一并请求给创建自定义菜单接口</p> 
<pre class="has"><code class="language-java">package com.b505.weixin.util;
import net.sf.json.JSONObject;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Component;
import com.b505.util.HttpRequestUtil;
import com.b505.weixin.menu.Menu;
/**
 * @Description: 自定义菜单工具类，包括菜单的创建、查询、删除
 * @Parameters: 
 * @Return: 
 * @Create Date: 2018年9月19日下午7:46:27
 * @Version: V1.00
 * @author: 来日可期
 */
@Component
public class WechatMenuUtil {
	 Logger logger = LoggerFactory.getLogger(WechatMenuUtil.class);
	 @Autowired
	 private HttpRequestUtil httpRequestUtil;
 
	 /**
	 * @Parameters: menu 菜单实例
	 * 				accessToken 凭证
	 * @Return: true false
	 * @Return: 
	 * @Create Date: 2018年9月22日上午7:45:53
	 * @Version: V1.00
	 * @author: 来日可期
	 */
	public boolean creatMenu(Menu menu,String accessToken){
		boolean result = false;
		String url = WechatConstants.MENU_CREATE_URL.replace("ACCESS_TOKEN", accessToken);
		//将菜单对象转换成JSON字符串
		String jsonMenu = JSONObject.fromObject(menu).toString();
		//发起POST请求创建菜单
		JSONObject jsonObject = httpRequestUtil.httpsRequest(url, "POST", jsonMenu);
		
		if (null != jsonObject) {
			int errorCode = jsonObject.getInt("errcode");
			String errorMsg = jsonObject.getString("errmsg");
			if (0== errorCode) {
				result = true;
			} else {
				result = false;
				logger.error("创建菜单失败 errcode：{} errmsg：{} ",errorCode,errorMsg);	
			}
		}
		return result;
	 }
	/**
	 * 
	 * @Description: 查询菜单
	 * @Parameters: 
	 * @Return: 
	 * @Create Date: 2018年3月13日下午2:24:02
	 * @Version: V1.00
	 * @author: 来日可期
	 */
	public String getMenu(String accessToken){
		String result = null;
		String requestUrl = WechatConstants.MENU_GET_URL.replace("ACCESS_TOKEN", accessToken);
		//发起GET请求查询菜单
		JSONObject jsonObject = httpRequestUtil.httpsRequest(requestUrl, "GET", null);
		
		if (null != jsonObject) {
			result = jsonObject.toString();
		}
		return result;
	}
	/**
	 * 
	 * @Description: 删除菜单
	 * @Parameters: 
	 * @Return: 
	 * @Create Date: 2018年3月13日下午2:31:15
	 * @Version: V1.00
	 * @author: 来日可期
	 */
	public boolean deleteMenu(String accessToken){
		boolean result = false;
		String requestUrl = WechatConstants.MENU_DELETE_URL.replace("ACCESS_TOKEN", accessToken);
		//发起GET请求删除菜单
		JSONObject jsonObject = httpRequestUtil.httpsRequest(requestUrl, "GET", null);
		
		if (null != jsonObject) {
			int errorCode = jsonObject.getInt("errcode");
			String errorMsg = jsonObject.getString("errmsg");
			if (0== errorCode) {
				result = true;
			} else {
				result = false;
				logger.error("创建菜单失败 errcode：{} errmsg：{} ",errorCode,errorMsg);	
			}
		}
		return result;
	}
}
</code></pre> 
<h4>五、编写获取access_token的工具类</h4> 
<p>调用微信高级接口需要凭证access_token，所以在这之前我们需要获取access_token.</p> 
<pre class="has"><code class="language-java">package com.b505.weixin.util;

import net.sf.json.JSONObject;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Component;
import com.b505.util.HttpRequestUtil;
import com.b505.weixin.pojo.AccessToken;

@Component
public class WechatCommonUtil {
	Logger logger = LoggerFactory.getLogger(WechatCommonUtil.class);
	
	//获取access_token接口
	private static String token_url = WechatConstants.ACCESS_TOKEN_URL;
	@Autowired
	HttpRequestUtil httpRequestUtil;
	
	/**
	 * @Description: 获取微信调用高级接口的凭证（access_token）
	 * @Parameters: 
	 * @Return: 
	 * @Create Date: 2018年9月28日下午12:22:55
	 * @Version: V1.00
	 * @author: 来日可期
	 */
	public AccessToken getAccessToken(String appid,String appsecret){
		//将公众号的appid和appsecret替换进url
		String url = token_url.replace("APPID", appid).replace("APPSECRET", appsecret);
		AccessToken accessToken = new AccessToken();
		//发起get请求获取凭证
		JSONObject jsonObject = httpRequestUtil.httpsRequest(url,"GET",null);
		logger.info("获取到的json格式的Token为:"+jsonObject);
		if (jsonObject!=null) {
			try {
				accessToken.setAccess_token(jsonObject.getString("access_token"));
				accessToken.setExpires_in(jsonObject.getInt("expires_in"));
			} catch (Exception e) {
				accessToken = null;
				//获取token失败
				logger.error("获取token失败 errcode:{} errmsg:{}", 
						jsonObject.getInt("errcode"), 
						jsonObject.getString("errmsg"));
			}		
		}
		return accessToken;
	}
}
</code></pre> 
<h4>六、编写主方法，进行自定义菜单创建</h4> 
<pre class="has"><code class="language-java">package com.b505.weixin.main;

import com.b505.weixin.menu.Menu;
import com.b505.weixin.util.WechatCommonUtil;
import com.b505.weixin.util.WechatConstants;
import com.b505.weixin.util.WechatMenuManagerUtil;
import com.b505.weixin.util.WechatMenuUtil;

/**
 * @Description: 创建自定义菜单主方法
 * @Parameters: 
 * @Return: 
 * @Create Date: 2018年9月28日下午2:25:33
 * @Version: V1.00
 * @author: 来日可期
 */
public class WechatCreatDefaultMenu {
	public static void main(String[] args){
		WechatCommonUtil wechatCommonUtil = new WechatCommonUtil();
		WechatMenuUtil wechatMenuUtil = new WechatMenuUtil();
		WechatMenuManagerUtil wechatMenuManagerUtil = new WechatMenuManagerUtil();
		String appid = "公众号的appid";
		String appsecret = "公众号的appsecret";
		
		//获取access_token
		String accessToken = wechatCommonUtil.getAccessToken(appid, appsecret).getAccess_token();
		//获取菜单结构
		Menu menu = wechatMenuManagerUtil.getMenu();
		if (accessToken!=null) {
			//生成菜单
			boolean result = wechatMenuUtil.creatMenu(menu, accessToken);
			if (result) {
				System.out.println("菜单创建成功");
			}else {
				System.out.println("菜单创建失败");
			}
		}else {
			System.out.println("token为空");
		}	
	}
}
</code></pre> 
<h4>七、微信常量类</h4> 
<pre class="has"><code class="language-java">package com.b505.weixin.util;

import org.springframework.stereotype.Component;

/**
 * 
 * @Description: 微信常量类
 * @Parameters: 
 * @Return: 
 * @Create Date: 2018年9月17日下午8:30:51
 * @Version: V1.00
 * @author: 来日可期
 */
@Component
public class WechatConstants {
	/**
	 * 微信接入token，自定义但是一定要与公众平台上的保持一致
	 */
	public static final String TOKEN = "weixin";

	public static final String APPID="wx4c6b4d1782fefb36";  
	
	public static final String  APPSECRET="6a3c2d92df4fe8dad40afb62585ef4b7";
	/**
     * EncodingAESKey 公众平台上面自己填写的43位EncodingAESKey(服务号的)
     */
	//public static final String EncodingAESKey = "bcW2S8ZsB19kbCTMmHtKi82ZYyNQmA5MRTFWwEj8Gwv";
	public static final String EncodingAESKey = "SCNajXZhXHcGNt8tiGbLHb5LVlXjk8iWDXxLrRhlylu";
	/**
	 *  获取access_token的接口地址（GET） 限200（次/天）
	 */
	public static final String ACCESS_TOKEN_URL = "https://api.weixin.qq.com/cgi-bin/token?grant_type=client_credential&amp;appid=APPID&amp;secret=APPSECRET";
	
	/**
	 * 获取JS_SDK_TICKET
	 */
	public static final String JS_SDK_TICKET_URL = "https://api.weixin.qq.com/cgi-bin/ticket/getticket?access_token=ACCESS_TOKEN&amp;type=jsapi";
	
	/**
	 * 获取网页授权的access_token的接口地址
	 */
	public static final String  OAUTH2_ACCESS_TOKEN_URL = "https://api.weixin.qq.com/sns/oauth2/access_token?appid=APPID&amp;secret=SECRET&amp;code=CODE&amp;grant_type=authorization_code";

	/**
	 * 自定义菜单删除接口
	 */
	public static final String MENU_DELETE_URL = "https://api.weixin.qq.com/cgi-bin/menu/delete?access_token=ACCESS_TOKEN";

	/**
	 * 自定义菜单的创建接口
	 */
	public static final String MENU_CREATE_URL = "https://api.weixin.qq.com/cgi-bin/menu/create?access_token=ACCESS_TOKEN";
	/**
	 * 自定义菜单的查询接口
	 */
	public static final String MENU_GET_URL = "https://api.weixin.qq.com/cgi-bin/menu/get?access_token=ACCESS_TOKEN"; 
	/**
	 *  客服接口-发消息接口
	 */
	public static final String CUSTOM_SERVICE_URL = "https://api.weixin.qq.com/cgi-bin/message/custom/send?access_token=ACCESS_TOKEN";
	
	/**
	 * 发送模板消息接口
	 */
    public static final String SEND_TEMPLATE_URL = "https://api.weixin.qq.com/cgi-bin/message/template/send?access_token=ACCESS_TOKEN";
    
    /**
	 * 创建标签接口
	 * @Method :POST
	 */
	public static final String USE_TAG_CREATE_URL  = "https://api.weixin.qq.com/cgi-bin/tags/create?access_token=ACCESS_TOKEN";
	
	/**
	 * 获取用户身上的标签
	 * @Method:POST
	 */
	public static final String GET_INUSER_TAG_URL  = "https://api.weixin.qq.com/cgi-bin/tags/getidlist?access_token=ACCESS_TOKEN";
	
	/**
	 * 批量为用户取消标签
	 * @Method:POST
	 */
	public static final String UNTAGGING_USER_BATCH_URL  = "https://api.weixin.qq.com/cgi-bin/tags/members/batchuntagging?access_token=ACCESS_TOKEN";
	
	/**
	 * 创建个性化菜单
	 * @Method :POST
	 */
	public static final String CREATE_PERSONALIZED_MENU_URL  = "https://api.weixin.qq.com/cgi-bin/menu/addconditional?access_token=ACCESS_TOKEN";
	
	/**
	 * 删除个性化菜单
	 * @Method:
	 */
	public static final String DELETE_PERSONAL_MENU_URL  = "https://api.weixin.qq.com/cgi-bin/menu/delconditional?access_token=ACCESS_TOKEN";
	
	/**
	 * 给用户打标签的姐接口
	 */
	public static final String CREATE_USERTAG_URL = "https://api.weixin.qq.com/cgi-bin/tags/members/batchtagging?access_token=ACCESS_TOKEN";
	
	/**
	 * 网页授权获取用户详细信息的的接口
	 */
	public static final String GET_USERINFO_URL = "https://api.weixin.qq.com/sns/userinfo?access_token=ACCESS_TOKEN&amp;openid=OPENID&amp;lang=zh_CN";

	/**
	 * openid获取用户的基本信息的接口
	 */
	public static final String OPENID_USERINFO_URL = "https://api.weixin.qq.com/cgi-bin/user/info?access_token=ACCESS_TOKEN&amp;openid=OPENID&amp;lang=zh_CN";


}
</code></pre> 
<p> </p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/4e0861f65f6376c9328926c547d770aa/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">电脑显示屏的选择与测试</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/49c8e2734989e9f4892b0943f1d980d3/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">字符编码中ASCII、Unicode和UTF-8的区别</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>