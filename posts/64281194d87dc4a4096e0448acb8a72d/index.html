<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>【UR #5】怎样更有力气 - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="【UR #5】怎样更有力气" />
<meta property="og:description" content="Problem Description 大力水手问禅师：“大师，很多事情都需要用很大力气才能完成，而我在吃了菠菜之后力气很大，于是就导致我现在非常依赖菠菜。我很讨厌我的现状，有没有办法少吃点菠菜甚至不吃菠菜却仍很有力气？”
禅师浅笑，答：“方法很简单，不过若想我教你，你需先下山徒手修路。”
山下是 \(n\) 座村庄从 \(1\) 到 \(n\) 编号，之间没有路相连。禅师给了大力水手一张草图，这张草图里 \(n\) 座村庄被 \(n — 1\) 条双向道路连接，任意一个村庄都可以通过双向道路到达其它所有村庄。
现在大力水手要根据禅师的意思在村庄间修路。禅师规定大力水手需要在 \(m\) 天内完成任务，其中大力水手的修路方式如下：
第 \(i\) 天，禅师指定了两个村庄 \(v_i\) 和 \(u_i\)，在草图上 \(v_i\) 号村庄到 \(u_i\) 号村庄的最短路径上的所有村庄（包括 \(v_i\) 和 \(u_i\)）中，大力水手需要选出若干对村庄（一个村庄可以被重复选多次，当然大力水手在这天也可以一对村庄都不选），然后在选出的每一对村庄间修建双向道路。
在实地考察中大力水手发现，有 \(p\) 个限制关系 \((t_i, a_i, b_i)\)，表示在第 \(t_i\) 天无法在 \(a_i\) 号村庄到 \(b_i\) 号村庄间修路（路是双向的，所以自然也无法在 \(b_i\) 号村庄到 \(a_i\) 号村庄间修路）。
每一天都有个修理所需力气值 \(w_i\)，表示在第 \(i\) 天每修建一条道路都要耗费 \(w_i\) 点力气值。
大力水手开始蛮力干了起来，一罐又一罐地吞食菠菜，结果经常修建一些无用的道路，每天都累得筋疲力尽。
作为一个旁观者，请你帮大力水手求出要想让 \(m\) 天后任意一对村庄之间都可以互相到达，所需要的总力气值最少是多少。注意最后修出来的道路不必和草图一致。
Input Format 第一行三个非负整数 \(n, m, p\)。保证 \(n \geq 1\)。
接下来一行 \(n — 1\) 个整数，其中第 \(i\) 个整数 \(f_{i&#43;1}\) （\(1 \leq f_{i&#43;1} \leq i\)）表示草图中 \(i &#43; 1\) 号村庄与 \(f_{i&#43;1}\) 号村庄间有一条双向道路。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/64281194d87dc4a4096e0448acb8a72d/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2019-09-01T15:14:00+08:00" />
<meta property="article:modified_time" content="2019-09-01T15:14:00+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">【UR #5】怎样更有力气</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <div id="cnblogs_post_body" class="blogpost-body cnblogs-markdown"> 
 <h2 id="problem">Problem</h2> 
 <h3 id="description">Description</h3> 
 <p>大力水手问禅师：“大师，很多事情都需要用很大力气才能完成，而我在吃了菠菜之后力气很大，于是就导致我现在非常依赖菠菜。我很讨厌我的现状，有没有办法少吃点菠菜甚至不吃菠菜却仍很有力气？”</p> 
 <p>禅师浅笑，答：“方法很简单，不过若想我教你，你需先下山徒手修路。”</p> 
 <p>山下是 <span class="math inline">\(n\)</span> 座村庄从 <span class="math inline">\(1\)</span> 到 <span class="math inline">\(n\)</span> 编号，之间没有路相连。禅师给了大力水手一张草图，这张草图里 <span class="math inline">\(n\)</span> 座村庄被 <span class="math inline">\(n — 1\)</span> 条双向道路连接，任意一个村庄都可以通过双向道路到达其它所有村庄。</p> 
 <p>现在大力水手要根据禅师的意思在村庄间修路。禅师规定大力水手需要在 <span class="math inline">\(m\)</span> 天内完成任务，其中大力水手的修路方式如下：</p> 
 <p>第 <span class="math inline">\(i\)</span> 天，禅师指定了两个村庄 <span class="math inline">\(v_i\)</span> 和 <span class="math inline">\(u_i\)</span>，在草图上 <span class="math inline">\(v_i\)</span> 号村庄到 <span class="math inline">\(u_i\)</span> 号村庄的最短路径上的所有村庄（包括 <span class="math inline">\(v_i\)</span> 和 <span class="math inline">\(u_i\)</span>）中，大力水手需要选出若干对村庄（一个村庄可以被重复选多次，当然大力水手在这天也可以一对村庄都不选），然后在选出的每一对村庄间修建双向道路。<br> 在实地考察中大力水手发现，有 <span class="math inline">\(p\)</span> 个限制关系 <span class="math inline">\((t_i, a_i, b_i)\)</span>，表示在第 <span class="math inline">\(t_i\)</span> 天无法在 <span class="math inline">\(a_i\)</span> 号村庄到 <span class="math inline">\(b_i\)</span> 号村庄间修路（路是双向的，所以自然也无法在 <span class="math inline">\(b_i\)</span> 号村庄到 <span class="math inline">\(a_i\)</span> 号村庄间修路）。<br> 每一天都有个修理所需力气值 <span class="math inline">\(w_i\)</span>，表示在第 <span class="math inline">\(i\)</span> 天每修建一条道路都要耗费 <span class="math inline">\(w_i\)</span> 点力气值。<br> 大力水手开始蛮力干了起来，一罐又一罐地吞食菠菜，结果经常修建一些无用的道路，每天都累得筋疲力尽。</p> 
 <p>作为一个旁观者，请你帮大力水手求出要想让 <span class="math inline">\(m\)</span> 天后任意一对村庄之间都可以互相到达，所需要的总力气值最少是多少。注意最后修出来的道路不必和草图一致。</p> 
 <h3 id="input-format">Input Format</h3> 
 <p>第一行三个非负整数 <span class="math inline">\(n, m, p\)</span>。保证 <span class="math inline">\(n \geq 1\)</span>。</p> 
 <p>接下来一行 <span class="math inline">\(n — 1\)</span> 个整数，其中第 <span class="math inline">\(i\)</span> 个整数 <span class="math inline">\(f_{i+1}\)</span> （<span class="math inline">\(1 \leq f_{i+1} \leq i\)</span>）表示草图中 <span class="math inline">\(i + 1\)</span> 号村庄与 <span class="math inline">\(f_{i+1}\)</span> 号村庄间有一条双向道路。</p> 
 <p>接下来 <span class="math inline">\(m\)</span> 行，第 <span class="math inline">\(i\)</span> 行包含三个整数 <span class="math inline">\(v_i, u_i, w_i\)</span> （<span class="math inline">\(1 \leq v_i, u_i \leq n, v_i \neq u_i, 1 \leq w_i \leq 10^9\)</span>）表示第 <span class="math inline">\(i\)</span> 天禅师指定了 <span class="math inline">\(v_i\)</span> 号村庄和 <span class="math inline">\(u_i\)</span> 号村庄，大力水手修一条路耗费 <span class="math inline">\(w_i\)</span> 点力气值。</p> 
 <p>接下来 <span class="math inline">\(p\)</span> 行，每行包含三个整数 <span class="math inline">\(t_i, a_i, b_i\)</span> 表示一个限制关系。保证 <span class="math inline">\(1 \leq t_i \leq m\)</span>，<span class="math inline">\(1 \leq a_i, b_i \leq n\)</span>，<span class="math inline">\(a_i \neq b_i\)</span>，且 <strong>草图上</strong> <span class="math inline">\(a_i\)</span> 号村庄和 <span class="math inline">\(b_i\)</span> 号村庄都在 <span class="math inline">\(v_{t_i}\)</span> 号村庄到 <span class="math inline">\(u_{t_i}\)</span> 号村庄的最短路径上。另外，保证输入中不会出现重复的限制关系，即不会有两个限制关系 <span class="math inline">\(i, j\)</span> 满足 <span class="math inline">\(t_i = t_j, a_i = a_j, b_i = b_j\)</span> 或 <span class="math inline">\(t_i = t_j, a_i = b_j, b_i = a_j\)</span>。</p> 
 <h3 id="output-format">Output Format</h3> 
 <p>输出一行一个整数，表示所需要的最小总力气值。保证至少存在一种修路的方法使得任意一对村庄之间都可以互相到达。</p> 
 <p>C/C++ 输入输出 long long 时请用 <code>%lld</code>。C++ 可以直接使用 cin/cout 输入输出。</p> 
 <h3 id="sample">Sample</h3> 
 <h4 id="input">Input</h4> 
 <pre><code>5 2 3
1 1 3 3
2 4 1
5 4 2
1 3 2
1 3 1
1 3 4</code></pre> 
 <h4 id="output">Output</h4> 
 <pre><code>6</code></pre> 
 <h3 id="explanation">Explanation</h3> 
 <h4 id="explanation-for-input">Explanation for Input</h4> 
 <p>第一天大力水手本来可以在 <span class="math inline">\((1, 2), (1, 3), (1, 4), (2, 3), (2, 4), (3, 4)\)</span> 间修路，但是由于第一天不能在 <span class="math inline">\((3, 2), (3, 1)\)</span> 和 <span class="math inline">\((3, 4)\)</span> 间修路，所以可能的选择只有 <span class="math inline">\((1, 2), (1, 4), (2, 4)\)</span>。对于第二天，大力水手可能的选择有 <span class="math inline">\((3, 4), (3, 5), (4, 5)\)</span>。</p> 
 <p>一种可能的最优方案是，第一天大力水手在 <span class="math inline">\((1, 2), (1, 4)\)</span> 间修路，第二天在 <span class="math inline">\((3, 4), (4, 5)\)</span> 间修路，总共耗费 <span class="math inline">\(1 + 1 + 2 + 2 = 6\)</span> 点力气值。</p> 
 <h4 id="range">Range</h4> 
 <p>对于 <span class="math inline">\(10\%\)</span>，<span class="math inline">\(n \leq 100，m \leq 100，p \leq 100\)</span></p> 
 <p>对于 <span class="math inline">\(30\%\)</span>，<span class="math inline">\(n \leq 300000， m \leq 300000， p = 0\)</span></p> 
 <p>对于 <span class="math inline">\(20\%\)</span>，<span class="math inline">\(n \leq 300000, m \leq 300000, p \leq 300000\)</span>，保证对于 <span class="math inline">\(1 &lt; i \leq n\)</span>， <span class="math inline">\(f_{i+1} = i\)</span></p> 
 <p>对于 <span class="math inline">\(40\%\)</span>，<span class="math inline">\(n \leq 300000\)</span> <span class="math inline">\(m \leq 300000\)</span> <span class="math inline">\(p \leq 300000\)</span></p> 
 <h3 id="postscript">Postscript</h3> 
 <p>由于你的帮助，大力水手顺利修完了道路而且使用的力气值是原定计划的 <span class="math inline">\(0.01\%\)</span>。</p> 
 <p>大力水手对禅师说：“我明白了！我以前都是在使用蛮力，从今往后我要多思索，多使用巧力解决问题。”</p> 
 <p>禅师摆摆手，嘿嘿一笑：“对不起，我只是想请你帮忙修路而已。”</p> 
 <p>大力水手吃了一罐菠菜，把禅师打死了。</p> 
 <h2 id="algorithm">Algorithm</h2> 
 <p>并查集</p> 
 <h2 id="mentality">Mentality</h2> 
 <p>不难想到，过程应该是像 <span class="math inline">\(kruskal\)</span> 那样，先把每天按照 <span class="math inline">\(w_i\)</span> 排序，然后在满足当天要求的情况下，尽可能多地将联通块们合并起来。</p> 
 <p>接下来的问题就是具体怎么合并了。</p> 
 <p>有一个很显然的优化，能使这一题的复杂度降低很多：对于第 <span class="math inline">\(i\)</span> 天，设 <span class="math inline">\(p_i\)</span> 为当天的限制个数。如果 <span class="math inline">\(dis(u_i,v_i)&gt;p_i\)</span> ，那么 <span class="math inline">\((u,v)\)</span> 这条路径上的所有点之间都能联通。</p> 
 <p>那么对于这种情况，维护并查集，每次在链上跳到所在的并查集根部，然后合并自己和父亲即可。同时注意并查集根部应当为联通块内深度最小的点。总复杂度 <span class="math inline">\(O(n)\)</span> 。</p> 
 <p>而且，这种情况和另一种情况的并查集应当分开维护，否则会出现错误。</p> 
 <p>而对于另一种情况，由于 <span class="math inline">\(dis(u_i,v_i)&lt;p_i\)</span> ，我们直接对路径上的每个点都考虑就行，反正总数不超过 <span class="math inline">\(p\)</span> 。</p> 
 <p>对于每一天，将所有限制 <span class="math inline">\((a,b)\)</span> ，将 <span class="math inline">\((a,b)\)</span> 之间连上一条限制边。我们找到限制边的度数最小的点 <span class="math inline">\(x\)</span>，考虑先将 <span class="math inline">\(x\)</span> 与路径上所有与 <span class="math inline">\(x\)</span> 之间没有限制边的点都合并在一起。</p> 
 <p>一个很显然的结论：度数最小的点的度数最多为 <span class="math inline">\(\sqrt{m}\)</span> 级别（<span class="math inline">\(m\)</span> 为边数）。</p> 
 <p>所以对与 <span class="math inline">\(x\)</span> 连边的点构成的集合（我们称为 <span class="math inline">\(S\)</span>），我们可以直接 <span class="math inline">\(|S|^2\)</span> 判断两两之间是否有限制边来合并。然后考虑对每个 <span class="math inline">\(S\)</span> 内的点，判断它是否能够与 <span class="math inline">\(S\)</span> 外的任意一点合并。由于那些点都会与 <span class="math inline">\(x\)</span> 合并，所以直接将这个点与 <span class="math inline">\(x\)</span> 合并即可。这部分复杂度只有 <span class="math inline">\(O(p)\)</span> 。</p> 
 <h2 id="code">Code</h2> 
 <pre><code class="language-cpp"><code>#include &lt;algorithm&gt;
#include &lt;cmath&gt;
#include &lt;complex&gt;
#include &lt;cstdio&gt;
#include &lt;cstring&gt;
#include &lt;iostream&gt;
#include &lt;map&gt;
#include &lt;queue&gt;
#include &lt;set&gt;
#include &lt;vector&gt;
using namespace std;
long long read() {
  long long x = 0, w = 1;
  char ch = getchar();
  while (!isdigit(ch)) w = ch == '-' ? -1 : 1, ch = getchar();
  while (isdigit(ch)) {
    x = (x &lt;&lt; 3) + (x &lt;&lt; 1) + ch - '0';
    ch = getchar();
  }
  return x * w;
}
const int Max_n = 3e5 + 5;
int n, m, p, nd;
int fa[Max_n], f[Max_n], fl[Max_n], dep[Max_n], jp[20][Max_n];
int cntr, hd[Max_n], nx[Max_n &lt;&lt; 1], to[Max_n];
int top, t, stk[Max_n], b2[Max_n], s[Max_n], S[Max_n], du[Max_n];
bool bk[Max_n], rd[600][600];
long long ans;
vector&lt;int&gt; ul[Max_n], vl[Max_n];
struct day {
  int u, v, w, id;
} k[Max_n];
void addr(int u, int v) {
  cntr++;
  nx[cntr] = hd[u], to[cntr] = v;
  hd[u] = cntr;
}
bool cmp(day a, day b) { return a.w &lt; b.w; }
void build(int x) {
  jp[0][x] = fa[x], f[x] = fl[x] = x, dep[x] = dep[fa[x]] + 1;
  for (int i = hd[x]; i; i = nx[i]) build(to[i]);
}
int find(int *f, int x) { return f[x] == x ? x : f[x] = find(f, f[x]); }
int get_lca(int u, int v) {
  if (dep[u] &lt; dep[v]) swap(u, v);
  for (int i = 19; ~i; i--)
    if (dep[jp[i][u]] &gt;= dep[v]) u = jp[i][u];
  for (int i = 19; ~i; i--)
    if (jp[i][u] != jp[i][v]) u = jp[i][u], v = jp[i][v];
  return u == v ? u : jp[0][u];
}
void merge(int u, int v) {
  u = find(f, u), v = find(f, v);
  if (u == v) return;
  ans += k[nd].w;
  f[u] = v;
}
int main() {
#ifndef ONLINE_JUDGE
  freopen("61.in", "r", stdin);
  freopen("61.out", "w", stdout);
#endif
  n = read(), m = read(), p = read();
  for (int i = 2; i &lt;= n; i++) addr(fa[i] = read(), i);
  for (int i = 1; i &lt;= m; i++)
    k[i].u = read(), k[i].v = read(), k[i].w = read(), k[i].id = i;
  sort(k + 1, k + m + 1, cmp);
  while (p--) {
    int d = read();
    ul[d].push_back(read());
    vl[d].push_back(read());
  }
  du[0] = 1e9, build(1);
  for (int j = 1; j &lt;= 19; j++)
    for (int i = 1; i &lt;= n; i++) jp[j][i] = jp[j - 1][jp[j - 1][i]];
  for (nd = 1; nd &lt;= m; nd++) {
    int x = k[nd].id, U = k[nd].u, V = k[nd].v;
    int lca = get_lca(U, V);
    if (dep[U] + dep[V] - 2 * dep[lca] &gt; ul[x].size()) {
      for (int i = find(fl, U); dep[i] &gt; dep[lca]; i = fa[i])
        fl[i] = fa[i], merge(fa[i], i);
      for (int i = find(fl, V); dep[i] &gt; dep[lca]; i = find(fl, fa[i]))
        fl[i] = fa[i], merge(fa[i], i);
    } else {
      stk[top = 1] = lca, bk[lca] = 1;
      for (int i = U; i != lca; i = fa[i]) stk[++top] = i, bk[i] = 1;
      for (int i = V; i != lca; i = fa[i]) stk[++top] = i, bk[i] = 1;
      for (int i = ul[x].size() - 1; ~i; i--) {
        int u = ul[x][i], v = vl[x][i];
        if (bk[u] &amp;&amp; bk[v]) du[u]++, du[v]++;
      }
      int Min = 0;
      for (int i = 1; i &lt;= top; i++)
        if (du[Min] &gt; du[stk[i]]) Min = stk[i];
      for (int i = ul[x].size() - 1; ~i; i--) {
        int u = ul[x][i], v = vl[x][i];
        if (bk[u] &amp;&amp; bk[v]) du[u]--, du[v]--;
        if (u == Min) b2[v] = ++t, s[t] = v;
        if (v == Min) b2[u] = ++t, s[t] = u;
      }
      for (int i = 1; i &lt;= top; i++)
        if (!b2[stk[i]]) merge(Min, stk[i]);
      for (int i = ul[x].size() - 1; ~i; i--) {
        int u = ul[x][i], v = vl[x][i];
        if (b2[u] &amp;&amp; b2[v]) rd[b2[u]][b2[v]] = rd[b2[v]][b2[u]] = 1;
        if (b2[u] &amp;&amp; !b2[v]) S[u]++;
        if (b2[v] &amp;&amp; !b2[u]) S[v]++;
      }
      for (int i = 1; i &lt; t; i++)
        for (int j = i + 1; j &lt;= t; j++)
          if (!rd[i][j]) merge(s[i], s[j]);
      for (int i = 1; i &lt;= t; i++)
        if (S[s[i]] &lt; top - t) merge(s[i], Min);
      for (int i = ul[x].size() - 1; ~i; i--) {
        int u = ul[x][i], v = vl[x][i];
        if (b2[u] &amp;&amp; b2[v]) rd[b2[u]][b2[v]] = rd[b2[v]][b2[u]] = 0;
        if (b2[u] &amp;&amp; !b2[v]) S[u]--;
        if (b2[v] &amp;&amp; !b2[u]) S[v]--;
      }
      while (t) b2[s[t--]] = 0;
      while (top) bk[stk[top--]] = 0;
    }
  }
  cout &lt;&lt; ans &lt;&lt; endl;
}</code></code></pre> 
</div>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/c31e5d34c4166c0eb2fd68dfdb7d6240/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">现在学java的都是傻子</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/d46c7dca447fc9dcc1ffe1790d733ec1/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">Scroll-View</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>