<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>java--基础--17.7--线程--内存模型与线程 - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="java--基础--17.7--线程--内存模型与线程" />
<meta property="og:description" content="java–基础–17.7–线程–内存模型与线程 1、内存模型 1.1、主内存和工作内存之间的交互 1.2、对于 volatile 型变量的特殊规则 关键字 volatile 是 Java 虚拟机提供的最轻量级的同步机制。 一个变量被定义为 volatile 的特性 保证此变量对所有线程的可见性。但是操作并非原子操作，并发情况下不安全。 如果不符合 运算结果并不依赖变量当前值，或者能够确保只有单一的线程修改变量的值 和 变量不需要与其他的状态变量共同参与不变约束 就要通过加锁(使用 synchronize 或 java.util.concurrent 中的原子类)来保证原子性。 禁止指令重排序优化。 通过插入内存屏障保证一致性。 1.3、对于 long 和 double 型变量的特殊规则 Java 要求对于主内存和工作内存之间的八个操作都是原子性的，但是对于 64 位的数据类型，有一条宽松的规定：允许虚拟机将没有被 volatile 修饰的 64 位数据的读写操作划分为两次 32 位的操作来进行，即允许虚拟机实现选择可以不保证 64 位数据类型的 load、store、read 和 write 这 4 个操作的原子性。这就是 long 和 double 的非原子性协定。
1.4、原子性、可见性与有序性 1.4.1、原子性(Atomicity) 由 Java 内存模型来直接保证的原子性变量操作包括 read、load、assign、use、store 和 write。大致可以认为基本数据类型的操作是原子性的。同时 lock 和 unlock 可以保证更大范围操作的原子性。而 synchronize 同步块操作的原子性是用更高层次的字节码指令 monitorenter 和 monitorexit 来隐式操作的。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/b0191dd811838d96094b923781d25f17/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-05-24T11:41:09+08:00" />
<meta property="article:modified_time" content="2023-05-24T11:41:09+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">java--基础--17.7--线程--内存模型与线程</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-light">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <h3><a id="java177_2"></a>java–基础–17.7–线程–内存模型与线程</h3> 
<hr> 
<h2><a id="1_7"></a>1、内存模型</h2> 
<p><img src="https://images2.imgbox.com/72/5d/AiVLseyk_o.png" alt=""></p> 
<h3><a id="11_11"></a>1.1、主内存和工作内存之间的交互</h3> 
<p><img src="https://images2.imgbox.com/08/ea/j4sYiKuD_o.png" alt=""></p> 
<p><img src="https://images2.imgbox.com/82/47/ZepadeLU_o.png" alt=""></p> 
<h3><a id="12_volatile__21"></a>1.2、对于 volatile 型变量的特殊规则</h3> 
<pre><code>关键字 volatile 是 Java 虚拟机提供的最轻量级的同步机制。
</code></pre> 
<h4><a id="_volatile__28"></a>一个变量被定义为 volatile 的特性</h4> 
<ul><li>保证此变量对所有线程的可见性。但是操作并非原子操作，并发情况下不安全。 
  <ul><li>如果不符合 运算结果并不依赖变量当前值，或者能够确保只有单一的线程修改变量的值 和 变量不需要与其他的状态变量共同参与不变约束 就要通过加锁(使用 synchronize 或 java.util.concurrent 中的原子类)来保证原子性。</li></ul> </li><li>禁止指令重排序优化。 
  <ul><li>通过插入内存屏障保证一致性。</li></ul> </li></ul> 
<h3><a id="13_long__double__37"></a>1.3、对于 long 和 double 型变量的特殊规则</h3> 
<p>Java 要求对于主内存和工作内存之间的八个操作都是原子性的，但是对于 64 位的数据类型，有一条宽松的规定：允许虚拟机将没有被 volatile 修饰的 64 位数据的读写操作划分为两次 32 位的操作来进行，即允许虚拟机实现选择可以不保证 64 位数据类型的 load、store、read 和 write 这 4 个操作的原子性。这就是 long 和 double 的非原子性协定。</p> 
<h3><a id="14_41"></a>1.4、原子性、可见性与有序性</h3> 
<h4><a id="141Atomicity_43"></a>1.4.1、原子性(Atomicity)</h4> 
<p>由 Java 内存模型来直接保证的原子性变量操作包括 read、load、assign、use、store 和 write。大致可以认为基本数据类型的操作是原子性的。同时 lock 和 unlock 可以保证更大范围操作的原子性。而 synchronize 同步块操作的原子性是用更高层次的字节码指令 monitorenter 和 monitorexit 来隐式操作的。</p> 
<h4><a id="142Visibility_45"></a>1.4.2、可见性(Visibility)</h4> 
<p>是指当一个线程修改了共享变量的值，其他线程也能够立即得知这个通知。主要操作细节就是修改值后将值同步至主内存(volatile 值使用前都会从主内存刷新)，除了 volatile 还有 synchronize 和 final 可以保证可见性。同步块的可见性是由"对一个变量执行 unlock 操作之前，必须先把此变量同步会主内存中( store、write 操作)"这条规则获得。而 final 可见性是指：被 final 修饰的字段在构造器中一旦完成，并且构造器没有把 “this” 的引用传递出去( this 引用逃逸是一件很危险的事情，其他线程有可能通过这个引用访问到"初始化了一半"的对象)，那在其他线程中就能看见 final 字段的值。</p> 
<h4><a id="143Ordering_47"></a>1.4.3、有序性(Ordering)</h4> 
<p>如果在被线程内观察，所有操作都是有序的；如果在一个线程中观察另一个线程，所有操作都是无序的。前半句指"线程内表现为串行的语义"，后半句是指"指令重排"现象和"工作内存与主内存同步延迟"现象。Java 语言通过 volatile 和 synchronize 两个关键字来保证线程之间操作的有序性。volatile 自身就禁止指令重排，而 synchronize 则是由"一个变量在同一时刻指允许一条线程对其进行 lock 操作"这条规则获得，这条规则决定了持有同一个锁的两个同步块只能串行的进入。</p> 
<h3><a id="15_51"></a>1.5、先行发生原则</h3> 
<p>也就是 happens-before 原则。这个原则是判断数据是否存在竞争、线程是否安全的主要依据。先行发生是 Java 内存模型中定义的两项操作之间的偏序关系。</p> 
<h4><a id="151_55"></a>1.5.1、天然的先行发生关系</h4> 
<p><img src="https://images2.imgbox.com/fe/c0/FO0R2iXm_o.png" alt=""></p> 
<h2><a id="2Java__61"></a>2、Java 与线程</h2> 
<h3><a id="21_62"></a>2.1、线程的实现</h3> 
<h4><a id="211_64"></a>2.1.1、使用内核线程实现</h4> 
<p>直接由操作系统内核支持的线程，这种线程由内核完成切换。程序一般不会直接去使用内核线程，而是去使用内核线程的一种高级接口 —— 轻量级进程(LWP)，轻量级进程就是我们通常意义上所讲的线程，每个轻量级进程都有一个内核级线程支持。</p> 
<p><img src="https://images2.imgbox.com/fa/d0/fY6IjHC9_o.png" alt=""></p> 
<h4><a id="212_71"></a>2.1.2、使用用户线程实现</h4> 
<p>广义上来说，只要不是内核线程就可以认为是用户线程，因此可以认为轻量级进程也属于用户线程。狭义上说是完全建立在用户空间的线程库上的并且内核系统不可感知的。</p> 
<p><img src="https://images2.imgbox.com/40/5e/3pNXYjqI_o.png" alt=""></p> 
<h4><a id="213_78"></a>2.1.3、使用用户线程夹加轻量级进程混合实现</h4> 
<p><img src="https://images2.imgbox.com/47/22/cLtJN5om_o.png" alt=""></p> 
<h4><a id="214Java__85"></a>2.1.4、Java 线程实现</h4> 
<p>平台不同实现方式不同，可以认为是一条 Java 线程映射到一条轻量级进程。</p> 
<h3><a id="22Java__91"></a>2.2、Java 线程调度</h3> 
<ul><li>协同式线程调度 
  <ul><li>线程执行时间由线程自身控制，实现简单，切换线程自己可知，所以基本没有线程同步问题。坏处是执行时间不可控，容易阻塞。</li></ul> </li><li>抢占式线程调度 
  <ul><li>每个线程由系统来分配执行时间。<br> ​</li></ul> </li></ul>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/5b830a6aee2a25291cfc79764feb1d69/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">雪花算法id值精度丢失问题</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/aba8c49a24d64486ba3b224f4b08101b/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">HCIA-学习总结</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>