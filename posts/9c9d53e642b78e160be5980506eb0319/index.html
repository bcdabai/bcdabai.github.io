<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>字符串的最大子串问题 - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="字符串的最大子串问题" />
<meta property="og:description" content="基于字符串的最大子串问题是经常面试的问题，想要表现的好不但要会基础的方法，同时还要学会优化的算法。
常考的有两个问题：
1：两个字符串的最大公共子串（还可能是子序列）
2：同一个字符串中相同的最大子串问题
例如输入qweabcuwabcfw,输出结果为：重复字符串的长度3和位置4
一：求两个字符串的最大公共子串 #include&lt;iostream&gt;
#include&lt;string.h&gt;
#include&lt;vector&gt;
using namespace std;
char out[50];
vector&lt;string&gt; re;
int longestSubstring1(string x, string y,int &amp;start) {
int xlen = x.size();
int ylen = y.size();
if (xlen == 0 || ylen == 0) {
return 0; }
int max = -1;
//暴力破解法，两重for循环加 while
for (int i = 0; i &lt; xlen; i&#43;&#43;) {
for (int j = 0; j &lt; ylen; j&#43;&#43;) {" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/9c9d53e642b78e160be5980506eb0319/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2018-09-03T16:04:48+08:00" />
<meta property="article:modified_time" content="2018-09-03T16:04:48+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">字符串的最大子串问题</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p>基于字符串的最大子串问题是经常面试的问题，想要表现的好不但要会基础的方法，同时还要学会优化的算法。</p> 
<p>常考的有两个问题：</p> 
<p>1：两个字符串的最大公共子串（还可能是子序列）</p> 
<p>2：同一个字符串中相同的最大子串问题</p> 
<p>例如输入qwe<span style="color:#f33b45;">abc</span>uw<span style="color:#f33b45;">abc</span>fw,输出结果为：重复字符串的长度3和位置4</p> 
<h4>一：求两个字符串的最大公共子串</h4> 
<table border="1" cellpadding="1" cellspacing="1" style="width:500px;"><tbody><tr><td> <p><br> #include&lt;iostream&gt;<br> #include&lt;string.h&gt;<br> #include&lt;vector&gt;<br> using namespace std;<br> char out[50];<br> vector&lt;string&gt; re;</p> <p>int longestSubstring1(string x, string y,int &amp;start) {<!-- --><br>     int xlen = x.size();<br>     int ylen = y.size();<br>     if (xlen == 0 || ylen == 0) {<!-- --><br>         return 0;   <br>     }<br>     int max = -1;<br>     //暴力破解法，两重for循环加 while<br>     for (int i = 0; i &lt; xlen; i++) {<!-- --><br>         for (int j = 0; j &lt; ylen; j++) {<!-- --><br>             int m = i, n = j;<br>             int len = 0;<br>             while (m &lt; xlen &amp;&amp; n &lt; ylen) {<!-- --><br>                 if (x[m] != y[n]) {<!-- --><br>                     break;<br>                 }<br>                 m++;<br>                 n++;<br>                 len++;<br>             }<br>             if (len &gt; max) {<!-- --><br>                 max = len;<br>                 start = i;<br>             }<br>         }<br>     }<br>     return max;<br> }<br> //动态规划<br> int longestSubstring2(string x, string y,int &amp;start) {<!-- --><br>    //设置dp数组<br>    vector&lt;vector&lt;int&gt; &gt; f(x.size() + 1, vector&lt;int&gt;(y.size() + 1, 0));<br>    //vector&lt; vector&lt;int&gt; &gt; f;<br>    int max = -1;<br>    for (int i = 1; i &lt;= x.size(); i++) {<!-- --><br>        for (int j = 1; j &lt;= y.size(); j++) {<!-- --><br>            if (x[i - 1] != y[j - 1]) f[i][j] = 0;<br>            else if (x[i - 1] == y[j - 1]) f[i][j] = f[i - 1][j - 1] + 1;<br>            if (max &lt; f[i][j]) {<!-- --><br>              max = f[i][j];<br>              start = i;<br>            }<br>        }<br>     }<br>     return max;<br> }</p> <p><br> int main()<br> {<!-- --><br>     string x = "adbccadbxadebbca";<br>     string y = "bcadrbxad";<br>     int start;<br>     int out =longestSubstring1 (x,y,start);<br>     cout &lt;&lt; out &lt;&lt; "-" &lt;&lt; start &lt;&lt; endl;<br>     for (int i=0; i&lt;out ;++i)<br>     cout &lt;&lt; x[start + i];<br>     cout &lt;&lt; endl;<br>     <br>     cout &lt;&lt; longestSubstring2(x,y,start) &lt;&lt;"-" &lt;&lt; start;<br>     <br> return 0;</p> <p>}</p> </td></tr></tbody></table> 
<p><img alt="" class="has" height="90" src="https://images2.imgbox.com/64/74/yYMRjzCM_o.png" width="205"></p> 
<p>2:c语言的写法</p> 
<table border="1" cellpadding="1" cellspacing="1" style="width:500px;"><tbody><tr><td> <p>#include&lt;iostream&gt;<br> #include&lt;string.h&gt;<br> #include&lt;vector&gt;<br> using namespace std;<br> char out[50];<br> vector&lt;int&gt; myvector;<br> int fun(char* a , char *b)<br>  {<!-- --><br>   int len_a = strlen(a);<br>   int len_b = strlen(b);<br>     if(len_a&lt;=0||len_b&lt;=0)<br>         return -1;<br>     char * c , *d;<br>     if(len_a&lt;len_b)<br>     {<!-- --><br>      c = b;<br>      d = a;<br>     }<br>      else<br>      {<!-- --><br>          c =a ;<br>          d =b;<br>      }<br>     int max =0; <br>   for( ; *c!='\0';c++ )<br>   {<!-- --><br>       int n = 0; //n是个遍历指针，判断首字母是否相等<br>       for( ;*(d+n)!='\0'; ++n)<br>       {<!-- --><br>        if(*c !=*(d+n))<br>        {<!-- --><br>         continue;<br>        }<br>        else<br>        {<!-- --><br>            int len =0;<br>            while(*(c+len)!='\0'&amp;&amp;*(c+len)==*(d+n+len)&amp;&amp;*(d+n+len)!='\0')<br>            {<!-- --><br>            len++;<br>            }<br>            if(len&gt;max)<br>            {<!-- --><br>               max =len;<br>            {<!-- --><br>                    for( int m=0;m &lt;max;m++)  <br>                     {  <br>                         out[m]=*(c+m);  <br>                     }  <br>                     out[max]='\0';<br>            }<br>            }<br>     <br>        }<br>                     <br>       }     <br>        <br>   }<br>     <br>     return max;<br>  }</p> <p>int main()<br> {<!-- --><br>     char a[] ="adbccadbxadebbca";<br>     char b[]= "bcadrbxad";<br>     int len =fun(a,b);<br>     <br>     cout &lt;&lt; out &lt;&lt; endl;<br>     //cout &lt;&lt; 0;<br> return 0;</p> <p>}</p> </td></tr></tbody></table> 
<p>还有别人的一个递归的解法，没看太懂，贴出来你们欣赏吧！</p> 
<table border="1" cellpadding="1" cellspacing="1" style="width:500px;"><tbody><tr><td> <p>#include &lt;iostream&gt;<br> #include &lt;string&gt;<br> #include &lt;memory.h&gt;<br> #include &lt;stdio.h&gt;<br> #include &lt;stdlib.h&gt;<br> //#include &lt;windows.h&gt;<br> using namespace std;</p> <p><br> char findMaxStr(char * s1,char *s2){<!-- --><br>     char *ss;<br>     static int maxlen=0;<br>     int len;<br>     if(strstr(s1,s2))  //如果S2是S1的子串<br>     {<!-- --><br>         if(maxlen&lt;strlen(s2))<br>         {<!-- --><br>             maxlen=strlen(s2);<br>             printf("maxlen:%d result:%s\n",maxlen,s2);<br>         }<br>         return 0;<br>     }<br>     len=strlen(s2);<br>     if(len==1)<br>     {    //递归的出口函数，终止条件<br>         //printf("error\n");<br>         //return 1;<br>         return 1;<br>     }<br>     ss=(char *)malloc(len);<br>     memcpy(ss,s2,len);//内存拷贝函数<br>     ss[len-1]=0;<br>     //printf("len=%d str=%s\n",len-1,ss);<br>     findMaxStr(s1,ss); //是否需要注释掉？？<br>     memcpy(ss,s2+1,len); //后移一位<br>     //printf("second: len=%d str=%s\n",len-1,ss);<br>     findMaxStr(s1,ss); //递归<br>     free(ss);<br>     return 1;<br> }</p> <p>int main() <br> {<!-- --><br>     char a[200]="adcyioabcdefxxabcdxxx";<br>     char b[200]="mxx0";</p> <p><br>     findMaxStr(a,b);<br>     return 0;<br> }</p> </td></tr></tbody></table> 
<h4>二：字符串的最长公共子串</h4> 
<p>这实质上是第一道题的变形，例如输入qwe<span style="color:#f33b45;">abc</span>uwabcfw,输出结果为：重复字符串的长度3和位置4</p> 
<p> </p> 
<p>第一种解法：以字符串的长度为外循环，内循环从字符串的第一个元素开始向后移动。</p> 
<table border="1" cellpadding="1" cellspacing="1" style="width:500px;"><tbody><tr><td> <p>#include&lt;iostream&gt;<br> #include&lt;string&gt;<br> using namespace std;<br> int main()<br> {<!-- --><br> string str, tep;<br> cout &lt;&lt; "输入字符串" &lt;&lt; endl;<br> cin &gt;&gt; str;<br> cout &lt;&lt;str.size()&lt;&lt;endl;<br> int mysize = str.size();<br>     int k =0;<br>     int max =0;<br>     int first;<br> for (int i = 1; i &lt;mysize; i++)<br> {<!-- --><br> for (int j = 0; j &lt; mysize-i; j++)<br> {<!-- --><br>     if (str[j]==str[j+i])<br>     {<!-- --><br>         k++;<br>     }<br>     else<br>     {<!-- --><br>         k=0;<br>     }<br>     if(k&gt;max)<br>    {<!-- --><br>      max = k;<br>    <span style="color:#f33b45;">  first =i-k+1;</span><br>     }<br> }<br> }<br>     cout &lt;&lt; first &lt;&lt; "-" &lt;&lt; max &lt;&lt;endl;<br> return 0;</p> <p>}</p> </td></tr></tbody></table> 
<p>第二种解法</p> 
<p> </p> 
<p>题目：输入一行字符串。找出当中出现的同样且长度最长的字符串，输出它及其首字符的位置。</p> 
<p>               比如：“yyabcdabjcabceg"，输出结果应该为abc 和3.</p> 
<p><img alt="" class="has" height="349" src="https://images2.imgbox.com/aa/98/CBsfPrwH_o.png" width="860"></p> 
<p>#include&lt;iostream&gt;<br> #include&lt;string&gt;<br> using namespace std;<br> int main()<br> {<!-- --><br> string str, tep;<br> cout &lt;&lt; "输入字符串" &lt;&lt; endl;<br> cin &gt;&gt; str;<br> for (int i = str.length() - 1; i &gt; 1; i--)<br> {<!-- --><br> for (int j = 0; j &lt; str.length(); j++)<br> {<!-- --><br> if (j + i &lt;= str.length())<br> {<!-- --><br> size_t t = 0;<br> size_t num = 0;<br> tep = str.substr(j, i);//从大到小取子串，从j位置开始取长度为i的子串<br> t = str.find(tep);//正序查找<br> num = str.rfind(tep);//逆序查找<br> if (t != num)//假设两次查找位置不一致，说明存在反复子串<br> {<!-- --><br> cout &lt;&lt; tep &lt;&lt; " " &lt;&lt; t + 1 &lt;&lt; endl;//输出子串及位置<br> system("pause");<br> return 0;</p> 
<p><br> }<br> }<br> }<br> }<br> }<br> substr(j, i);//从大到小取子串，从j位置开始取长度为i的子串<br> t = str.find(tep);//正序查找<br> num = str.rfind(tep);//逆序查找<br> if (t != num)//假设两次查找位置不一致，说明存在反复子串<br> {<!-- --><br> cout &lt;&lt; tep &lt;&lt; " " &lt;&lt; t + 1 &lt;&lt; endl;//输出子串及位置<br> system("pause");<br> return 0;</p> 
<p><br> }<br> }<br> }<br> }<br> }</p> 
<p> </p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/49d4d8642324d11852a4026909375dca/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">Oracle-常用调优方法</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/0d91b9354c95a54fdb421872d3add34b/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">Redis单机版安装与配置</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>