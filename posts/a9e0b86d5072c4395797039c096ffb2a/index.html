<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>RGMII以太网测试方案 - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="RGMII以太网测试方案" />
<meta property="og:description" content="一 方案框图 二 实现步骤 1.模组的MAC通过RGMII接口与PHY连接
2.MAC层数据经过RGMII到达PHY的PCS层
3.设置PHY的PCS层回环，使PCS层数据回到MAC层
4.判断MAC层TX与RX接收的数据。如果MAC能接收到数据，测试PASS，否则失败
三 测试代码 int main(int argc, char **argv) { int i, datalen, frame_length, sd, bytes; char *interface = &#34;eth0&#34;; uint8_t data[IP_MAXPACKET]; uint8_t src_mac[6]; uint8_t dst_mac[6]; uint8_t ether_frame[IP_MAXPACKET]; struct sockaddr_ll device; struct ifreq ifr; int recvlen=0; uint8_t buffer[IP_MAXPACKET]; int loopback_state=0; // Submit request for a socket descriptor to look up interface. if ((sd = socket(PF_PACKET, SOCK_RAW, htons(ETH_P_ALL))) &lt; 0) { perror(&#34;socket() failed to get socket descriptor for using ioctl()&#34;" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/a9e0b86d5072c4395797039c096ffb2a/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-10-08T16:13:06+08:00" />
<meta property="article:modified_time" content="2022-10-08T16:13:06+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">RGMII以太网测试方案</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <h2>一 方案框图</h2> 
<p><img alt="" height="336" src="https://images2.imgbox.com/47/41/FWAOLmhc_o.png" width="168"></p> 
<h2> 二 实现步骤</h2> 
<p>1.模组的MAC通过RGMII接口与PHY连接</p> 
<p>2.MAC层数据经过RGMII到达PHY的PCS层</p> 
<p>3.设置PHY的PCS层回环，使PCS层数据回到MAC层</p> 
<p>4.判断MAC层TX与RX接收的数据。如果MAC能接收到数据，测试PASS，否则失败</p> 
<h2>三 测试代码</h2> 
<pre><code class="hljs">int main(int argc, char **argv)
{
    int i, datalen, frame_length, sd, bytes;
    char *interface = "eth0";
    uint8_t data[IP_MAXPACKET];
    uint8_t src_mac[6];
    uint8_t dst_mac[6];
    uint8_t ether_frame[IP_MAXPACKET];
    struct sockaddr_ll device;
    struct ifreq ifr;
	int recvlen=0;
	uint8_t buffer[IP_MAXPACKET];
    int loopback_state=0;

    // Submit request for a socket descriptor to look up interface.
    if ((sd = socket(PF_PACKET, SOCK_RAW, htons(ETH_P_ALL))) &lt; 0)
    { 
        perror("socket() failed to get socket descriptor for using ioctl()");
        exit(EXIT_FAILURE);
    }

    // Use ioctl() to look up interface name and get its MAC address.
    memset(&amp;ifr, 0, sizeof(ifr));
    snprintf(ifr.ifr_name, sizeof(ifr.ifr_name), "%s", interface);
    if (ioctl(sd, SIOCGIFHWADDR, &amp;ifr) &lt; 0)
    {
        perror("ioctl() failed to get source MAC address ");
        return (EXIT_FAILURE);
    }
    close(sd);

    // Copy source MAC address.
    memcpy(src_mac, ifr.ifr_hwaddr.sa_data, 6);

    // Report source MAC address to stdout.
    printf("MAC address for interface %s is ", interface);
    for (i = 0; i &lt; 5; i++)
    {
        printf("%02x:", src_mac[i]);
    }
    printf("%02x\n", src_mac[5]);

    // Find interface index from interface name and store index in
    // struct sockaddr_ll device, which will be used as an argument of sendto().
    memset(&amp;device, 0, sizeof(device));
    if ((device.sll_ifindex = if_nametoindex(interface)) == 0)
    {
        perror("if_nametoindex() failed to obtain interface index ");
        exit(EXIT_FAILURE);
    }
    printf("Index for interface %s is %i\n", interface, device.sll_ifindex);

    // Set destination MAC address: you need to fill these out
    dst_mac[0] = 0x10; //设置目的网卡地址
    dst_mac[1] = 0x78;
    dst_mac[2] = 0xd2;
    dst_mac[3] = 0xc6;
    dst_mac[4] = 0x2f;
    dst_mac[5] = 0x89;

    // Fill out sockaddr_ll.
    device.sll_family = AF_PACKET;
    memcpy(device.sll_addr, src_mac, 6);
    device.sll_halen = htons(6);

    // 发送的data，长度可以任意，但是抓包时看到最小数据长度为46，这是以太网协议规定以太网帧数据域部分最小为46字节，不足的自动补零处理
    datalen = 12;
    data[0] = 0x11;
    data[1] = 0x12;
    data[2] = 0x13;
    data[3] = 0x14;
    data[4] = 0x15;
    data[5] = 0x16;
    data[6] = 0x17;
    data[7] = 0x18;
    data[8] = 0x19;
    data[9] = 0x20;
    data[10] = 0x21;
    data[11] = 0x22;

    // Fill out ethernet frame header.
    frame_length = 6 + 6 + 2 + datalen;
    // Destination and Source MAC addresses
    memcpy(ether_frame, dst_mac, 6);
    memcpy(ether_frame + 6, src_mac, 6);

    ether_frame[12] = ETH_P_DEAN / 256;
    ether_frame[13] = ETH_P_DEAN % 256;

    // data
    memcpy(ether_frame + 14, data, datalen);
    // Submit request for a raw socket descriptor.
    if ((sd = socket(PF_PACKET, SOCK_RAW, htons(ETH_P_ALL))) &lt; 0)
    { //创建正真发送的socket
        perror("socket() failed ");
        exit(EXIT_FAILURE);
    }
    // Send ethernet frame to socket.
    if ((bytes = sendto(sd, ether_frame, frame_length, 0, (struct sockaddr *)&amp;device, sizeof(device))) &lt;= 0)
    {
        perror("sendto() failed");
        exit(EXIT_FAILURE);
    }
   	for(i=0;i&lt;bytes;i++){
			printf(" %02x",ether_frame[i]);
			if((i+1)%16==0){
					printf("\n");
			}
	}
	printf("\n");
	

	recvlen=recvfrom(sd,buffer,sizeof(buffer),0,NULL,NULL);

	for(i=0;i&lt;recvlen;i++){
		printf(" %02x",buffer[i]);
		if((i+1)%16==0){
				printf("\n");
		}
	}
	printf("\n");

    for(i=0;i&lt;recvlen;i++){

        if(bytes&gt;recvlen)
        {
            loopback_state=0;
            break;
        }
        else if(ether_frame[i]!=buffer[i])
        {
            loopback_state=0;
            break;
        }
    }
	if (loopback_state == 1)
    {
         printf("phy loopback OK\n");
    }
    else
    {
        printf("phy loopback error\n");
    }
    // Close socket descriptor.
    close(sd);

    return (EXIT_SUCCESS);
}</code></pre> 
<p></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/41ad2c56f6f5fb6bf1cc0dcc045afdf5/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">Axios使用详解</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/2d60857a5501f93ef2920431f9ea39f2/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">【SpringBoot】Maven 版本管理与 flatten-maven-plugin 插件的使用及分析</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>