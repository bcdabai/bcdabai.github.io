<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>为什么在token在http请求头中的Authorization要加Bearer前缀？ - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="为什么在token在http请求头中的Authorization要加Bearer前缀？" />
<meta property="og:description" content="为什么在token在http请求头中的Authorization要加Bearer前缀？ token认证方式一般是放在http的请求头中Authorization字段，那么有两种形式：
Authorization : Bearer eyJhbGciOiJIUzI1NiJ9.eyJpc3MiOiJCRkwiLCJhdWQiOiJDaGluYU1vYmlsZSIsImV4cCI6MTY5NTM0MTUwNiwibmJmIjoxNjk1Mjk4MzA2fQ.PxgojHlpUEaNJMy8I5DXkTSOrhn3oawzWIs0YL7yNP4 Authorization : eyJhbGciOiJIUzI1NiJ9.eyJpc3MiOiJCRkwiLCJhdWQiOiJDaGluYU1vYmlsZSIsImV4cCI6MTY5NTM0MTUwNiwibmJmIjoxNjk1Mjk4MzA2fQ.PxgojHlpUEaNJMy8I5DXkTSOrhn3oawzWIs0YL7yNP4 两种方式有什么区别呢？为什么外面使用的时候都会加前缀Bearer?
两种方式使用上没有太大区别，只是：
The Authorization: &lt;type&gt; &lt;credentials&gt; pattern was introduced by the W3C in HTTP 1.0, and has been reused in many places since. Many web servers support multiple methods of authorization. In those cases sending just the token isn’t sufficient.
可以认为Bearer是一种schema。
后端服务filter中获取token进行验证可以兼容两种方式：
private String getToken(String authorizationString) { if (authorizationString.startsWith(&#34;Bearer &#34;)) { return requestString.substring(7); } return authorizationString; } 另外，使用token认证有一个隐患：
http协议是明文传输的，token完全暴露在网络环境中，其他人获得token就能冒充身份，所以使用时必须注意网络环境，或者请使用https/TLS。
认证方式：" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/b3bd9a28da93e86f87afe7e47eeaecd4/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-09-22T15:24:53+08:00" />
<meta property="article:modified_time" content="2023-09-22T15:24:53+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">为什么在token在http请求头中的Authorization要加Bearer前缀？</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <h3><a id="tokenhttpAuthorizationBearer_0"></a>为什么在token在http请求头中的Authorization要加Bearer前缀？</h3> 
<p>token认证方式一般是放在http的请求头中Authorization字段，那么有两种形式：</p> 
<pre><code>Authorization : Bearer eyJhbGciOiJIUzI1NiJ9.eyJpc3MiOiJCRkwiLCJhdWQiOiJDaGluYU1vYmlsZSIsImV4cCI6MTY5NTM0MTUwNiwibmJmIjoxNjk1Mjk4MzA2fQ.PxgojHlpUEaNJMy8I5DXkTSOrhn3oawzWIs0YL7yNP4
</code></pre> 
<pre><code>Authorization : eyJhbGciOiJIUzI1NiJ9.eyJpc3MiOiJCRkwiLCJhdWQiOiJDaGluYU1vYmlsZSIsImV4cCI6MTY5NTM0MTUwNiwibmJmIjoxNjk1Mjk4MzA2fQ.PxgojHlpUEaNJMy8I5DXkTSOrhn3oawzWIs0YL7yNP4
</code></pre> 
<p>两种方式有什么区别呢？为什么外面使用的时候都会加前缀<code>Bearer</code>?<br> 两种方式使用上没有太大区别，只是：</p> 
<p>The Authorization: <code>&lt;type&gt; &lt;credentials&gt;</code> pattern was introduced by the W3C in HTTP 1.0, and has been reused in many places since. Many web servers support multiple methods of authorization. In those cases sending just the token isn’t sufficient.</p> 
<p>可以认为<code>Bearer</code>是一种schema。</p> 
<p>后端服务filter中获取token进行验证可以兼容两种方式：</p> 
<pre><code class="prism language-java"> <span class="token keyword">private</span> <span class="token class-name">String</span> <span class="token function">getToken</span><span class="token punctuation">(</span><span class="token class-name">String</span> authorizationString<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>authorizationString<span class="token punctuation">.</span><span class="token function">startsWith</span><span class="token punctuation">(</span><span class="token string">"Bearer "</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
            <span class="token keyword">return</span> requestString<span class="token punctuation">.</span><span class="token function">substring</span><span class="token punctuation">(</span><span class="token number">7</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">return</span> authorizationString<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
</code></pre> 
<p>另外，使用token认证有一个隐患：<br> <code>http协议</code>是明文传输的，<code>token</code>完全暴露在网络环境中，其他人获得<code>token</code>就能冒充身份，所以使用时必须注意网络环境，或者请使用<code>https/TLS</code>。</p> 
<p>认证方式：</p> 
<ul><li> <p>cookie和session配合方式，客户端使用浏览器的cookie来存sessionId，服务端存session。由于结构可以泛化成两种：<br> （1）单服务器的服务端，这种多在小型服务中，私有化部署，toB项目的服务中<br> （2）分布式架构下的服务端，这种多是toC，大型服务，复杂系统，这种方式需要共享session，多个服务器都能访问，这样对于共享session的方式，可以是同步session，也可以是单独的服务做认证，类似redis集群存放认证信息，这种类似与网关的服务。就是说</p> </li><li> <p>token的方式，这种完全不需要认证服务器，token自带认证功能。<br> JWT token的介绍</p> </li></ul>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/1c2a7e27506a29a0eec0251b3a67bf3f/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">vue-cli-service build 不同环境的配置</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/b957cc7172470d0d81bec87e36fa9a8d/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">VsCode配置C/C&#43;&#43;环境</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>