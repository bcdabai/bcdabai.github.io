<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Java并发编程之LinkedBlockingDeque阻塞队列详解 - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Java并发编程之LinkedBlockingDeque阻塞队列详解" />
<meta property="og:description" content="简介 LinkedBlockingDeque是一个由链表结构组成的双向阻塞队列，即可以从队列的两端插入和移除元素。双向队列因为多了一个操作队列的入口，在多线程同时入队时，也就减少了一半的竞争。
相比于其他阻塞队列，LinkedBlockingDeque多了addFirst、addLast、peekFirst、peekLast等方法，以first结尾的方法，表示插入、获取获移除双端队列的第一个元素。以last结尾的方法，表示插入、获取获移除双端队列的最后一个元素。
LinkedBlockingDeque是可选容量的，在初始化时可以设置容量防止其过度膨胀，如果不设置，默认容量大小为Integer.MAX_VALUE。
LinkedBlockingDeque类有三个构造方法：
public LinkedBlockingDeque() public LinkedBlockingDeque(int capacity) public LinkedBlockingDeque(Collection&lt;? extends E&gt; c) LinkedBlockingDeque源码详解 LinkedBlockingDeque类定义为：
public class LinkedBlockingDeque&lt;E&gt; extends AbstractQueue&lt;E&gt; implements BlockingDeque&lt;E&gt;, java.io.Serializable 该类继承自AbstractQueue抽象类，又实现了BlockingDeque接口，下面介绍一个BlockingDeque接口，该接口定义如下：
public interface BlockingDeque&lt;E&gt; extends BlockingQueue&lt;E&gt;, Deque&lt;E&gt; BlockingDeque继承自BlockingQueue和Deque接口，BlockingDeque接口定义了在双端队列中常用的方法。
LinkedBlockingDeque类中的数据都被封装成了Node对象：
static final class Node&lt;E&gt; { E item; Node&lt;E&gt; prev; Node&lt;E&gt; next; Node(E x) { item = x; } } LinkedBlockingDeque类中的重要字段如下：
// 队列双向链表首节点 transient Node&lt;E&gt; first; // 队列双向链表尾节点 transient Node&lt;E&gt; last; // 双向链表元素个数 private transient int count; // 双向链表最大容量 private final int capacity; // 全局独占锁 final ReentrantLock lock = new ReentrantLock(); // 非空Condition对象 private final Condition notEmpty = lock." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/f04223dfea9c7ce7cc5e831b5e868a78/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2018-06-06T13:41:01+08:00" />
<meta property="article:modified_time" content="2018-06-06T13:41:01+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Java并发编程之LinkedBlockingDeque阻塞队列详解</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <h4>简介</h4> 
<p>LinkedBlockingDeque是一个由链表结构组成的双向阻塞队列，即可以从队列的两端插入和移除元素。双向队列因为多了一个操作队列的入口，在多线程同时入队时，也就减少了一半的竞争。<br></p> 
<p>相比于其他阻塞队列，LinkedBlockingDeque多了addFirst、addLast、peekFirst、peekLast等方法，以first结尾的方法，表示插入、获取获移除双端队列的第一个元素。以last结尾的方法，表示插入、获取获移除双端队列的最后一个元素。</p> 
<p>LinkedBlockingDeque是可选容量的，在初始化时可以设置容量防止其过度膨胀，如果不设置，默认容量大小为Integer.MAX_VALUE。<br></p> 
<p>LinkedBlockingDeque类有三个构造方法：<br></p> 
<pre><code class="language-java">public LinkedBlockingDeque()
public LinkedBlockingDeque(int capacity)
public LinkedBlockingDeque(Collection&lt;? extends E&gt; c)</code></pre> 
<h4>LinkedBlockingDeque源码详解</h4> 
<p>LinkedBlockingDeque类定义为：<br></p> 
<pre><code class="language-java">public class LinkedBlockingDeque&lt;E&gt; extends AbstractQueue&lt;E&gt; implements BlockingDeque&lt;E&gt;, java.io.Serializable</code></pre> 
<p>该类继承自AbstractQueue抽象类，又实现了BlockingDeque接口，下面介绍一个BlockingDeque接口，该接口定义如下：</p> 
<pre><code class="language-java">public interface BlockingDeque&lt;E&gt; extends BlockingQueue&lt;E&gt;, Deque&lt;E&gt;</code></pre> 
<p>BlockingDeque继承自BlockingQueue和Deque接口，BlockingDeque接口定义了在双端队列中常用的方法。</p> 
<p>LinkedBlockingDeque类中的数据都被封装成了Node对象：</p> 
<pre><code class="language-java">static final class Node&lt;E&gt; {
    E item;
    Node&lt;E&gt; prev;
    Node&lt;E&gt; next;

    Node(E x) {
        item = x;
    }
}</code></pre> 
<p>LinkedBlockingDeque类中的重要字段如下：<br></p> 
<pre><code class="language-java">// 队列双向链表首节点
transient Node&lt;E&gt; first;
// 队列双向链表尾节点
transient Node&lt;E&gt; last;
// 双向链表元素个数
private transient int count;
// 双向链表最大容量
private final int capacity;
// 全局独占锁
final ReentrantLock lock = new ReentrantLock();
// 非空Condition对象
private final Condition notEmpty = lock.newCondition();
// 非满Condition对象
private final Condition notFull = lock.newCondition();</code></pre> 
<p>LinkedBlockingDeque类的底层实现和<span style="background-color:rgb(255,255,255);">LinkedBlockingQueue类很相似，都有一个全局独占锁，和两个Condition对象，用来阻塞和唤醒线程。</span></p> 
<p><span style="background-color:rgb(255,255,255);">LinkedBlockingDeque类对元素的操作方法比较多，我们下面以putFirst、putLast、pollFirst、pollLast方法来对元素的入队、出队操作进行分析。<br></span></p> 
<h5><span style="background-color:rgb(255,255,255);">入队</span></h5> 
<p><span style="background-color:rgb(255,255,255);">putFirst(E e)方法是将指定的元素插入双端队列的开头，源码如下：</span></p> 
<pre><code class="language-java">public void putFirst(E e) throws InterruptedException {
    // 若插入元素为null，则直接抛出NullPointerException异常
    if (e == null) throw new NullPointerException();
    // 将插入节点包装为Node节点
    Node&lt;E&gt; node = new Node&lt;E&gt;(e);
    // 获取全局独占锁
    final ReentrantLock lock = this.lock;
    lock.lock();
    try {
        while (!linkFirst(node))
            notFull.await();
    } finally {
        // 释放全局独占锁
        lock.unlock();
    }
}</code></pre> 
<p>入队操作是通过linkFirst(E e)方法来完成的，如下所示：</p> 
<pre><code class="language-java">private boolean linkFirst(Node&lt;E&gt; node) {
    // assert lock.isHeldByCurrentThread();
    // 元素个数超出容量。直接返回false
    if (count &gt;= capacity)
        return false;
    // 获取双向链表的首节点
    Node&lt;E&gt; f = first;
    // 将node设置为首节点
    node.next = f;
    first = node;
    // 若last为null，设置尾节点为node节点
    if (last == null)
        last = node;
    else
        // 更新原首节点的前驱节点
        f.prev = node;
    ++count;
    // 唤醒阻塞在notEmpty上的线程
    notEmpty.signal();
    return true;
}
</code></pre> 
<p>若入队成功，则linkFirst(E e)方法返回true，否则，返回false。若该方法返回false，则当前线程会阻塞在notFull条件上。</p> 
<p>putLast(E e)方法是将指定的元素插入到双端队列的末尾，源码如下：<br></p> 
<pre><code class="language-java">public void putLast(E e) throws InterruptedException {
    // 若插入元素为null，则直接抛出NullPointerException异常
    if (e == null) throw new NullPointerException();
    // 将插入节点包装为Node节点
    Node&lt;E&gt; node = new Node&lt;E&gt;(e);
    // 获取全局独占锁
    final ReentrantLock lock = this.lock;
    lock.lock();
    try {
        while (!linkLast(node))
            notFull.await();
    } finally {
        // 释放全局独占锁
        lock.unlock();
    }
}</code></pre> 
<p>该方法和putFirst(E e)方法几乎一样，不同点在于，putLast(E e)方法通过调用linkLast(E e)方法来插入节点：</p> 
<pre><code class="language-java">private boolean linkLast(Node&lt;E&gt; node) {
    // assert lock.isHeldByCurrentThread();
    // 元素个数超出容量。直接返回false
    if (count &gt;= capacity)
        return false;
    // 获取双向链表的尾节点
    Node&lt;E&gt; l = last;
    // 将node设置为尾节点
    node.prev = l;
    last = node;
    // 若first为null，设置首节点为node节点
    if (first == null)
        first = node;
    else
        // 更新原尾节点的后继节点
        l.next = node;
    ++count;
    // 唤醒阻塞在notEmpty上的线程
    notEmpty.signal();
    return true;
}</code></pre>若入队成功，则linkLast(E e)方法返回true，否则，返回false。若该方法返回false，则当前线程会阻塞在notFull条件上。 
<br> 
<h5><span style="background-color:rgb(255,255,255);">出队</span></h5> 
<p><span style="background-color:rgb(255,255,255);">pollFirst()方法是获取并移除此双端队列的首节点，若不存在，则返回null，源码如下：<br></span></p> 
<pre><code class="language-java">public E pollFirst() {
    // 获取全局独占锁
    final ReentrantLock lock = this.lock;
    lock.lock();
    try {
        return unlinkFirst();
    } finally {
        // 释放全局独占锁
        lock.unlock();
    }
}</code></pre> 
<p>移除首节点的操作是通过unlinkFirst()方法来完成的：</p> 
<pre><code class="language-java">private E unlinkFirst() {
    // assert lock.isHeldByCurrentThread();
    // 获取首节点
    Node&lt;E&gt; f = first;
    // 首节点为null，则返回null
    if (f == null)
        return null;
    // 获取首节点的后继节点
    Node&lt;E&gt; n = f.next;
    // 移除first，将首节点更新为n
    E item = f.item;
    f.item = null;
    f.next = f; // help GC
    first = n;
    // 移除首节点后，为空队列
    if (n == null)
        last = null;
    else
        // 将新的首节点的前驱节点设置为null
        n.prev = null;
    --count;
    // 唤醒阻塞在notFull上的线程
    notFull.signal();
    return item;
}</code></pre> 
<p>pollLast()方法是获取并移除此双端队列的尾节点，若不存在，则返回null，源码如下：</p> 
<pre><code class="language-java">public E pollLast() {
    // 获取全局独占锁
    final ReentrantLock lock = this.lock;
    lock.lock();
    try {
        return unlinkLast();
    } finally {
        // 释放全局独占锁
        lock.unlock();
    }
}</code></pre> 
<p>移除尾节点的操作是通过unlinkLast()方法来完成的：</p> 
<pre><code class="language-java">private E unlinkLast() {
    // assert lock.isHeldByCurrentThread();
    // 获取尾节点
    Node&lt;E&gt; l = last;
    // 尾节点为null，则返回null
    if (l == null)
        return null;
    // 获取尾节点的前驱节点
    Node&lt;E&gt; p = l.prev;
    // 移除尾节点，将尾节点更新为p
    E item = l.item;
    l.item = null;
    l.prev = l; // help GC
    last = p;
    // 移除尾节点后，为空队列
    if (p == null)
        first = null;
    else
        // 将新的尾节点的后继节点设置为null
        p.next = null;
    --count;
    // 唤醒阻塞在notFull上的线程
    notFull.signal();
    return item;
}</code></pre> 
<p>其实LinkedBlockingDeque类的入队、出队操作都是通过linkFirst、linkLast、unlinkFirst、unlinkLast这几个方法来实现的，源码读起来也比较简单。</p> 
<h4>相关博客</h4> 
<p></p> 
<p style="background-color:rgb(255,255,255);"><a href="https://blog.csdn.net/qq_38293564/article/details/80579694">Java并发编程之ArrayBlockingQueue阻塞队列详解</a><br></p> 
<p style="background-color:rgb(255,255,255);"><a href="https://blog.csdn.net/qq_38293564/article/details/80515718">Java并发编程之ReentrantLock详解</a><br></p> 
<p style="background-color:rgb(255,255,255);"><a href="https://blog.csdn.net/qq_38293564/article/details/80554516"> Java并发编程之Condition详解</a></p> 
<p style="background-color:rgb(255,255,255);"><a href="https://blog.csdn.net/qq_38293564/article/details/80583831">Java并发编程之LinkedBlockingQueue阻塞队列详解</a></p> 
<h4>参考资料</h4> 
<p>方腾飞：《Java并发编程的艺术》</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/11ddbaf3386aea1f2974eee984542152/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">dddd</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/464cd6c9bd14eb137e60a5a29cd298bf/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">intellij idea报错“Error updating changes: svn: E155036: Please see the &#39;svn upgrade&#39;..........”</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>