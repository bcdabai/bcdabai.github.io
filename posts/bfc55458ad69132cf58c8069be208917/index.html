<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>c/c&#43;&#43;开发时直接调用dll动态库中的函数，无需使用头文件编译 - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="c/c&#43;&#43;开发时直接调用dll动态库中的函数，无需使用头文件编译" />
<meta property="og:description" content="一、开发环境 我写dome用的是Qt5.14.2
二、创建dll 1、搭建生成dll的工程
使用Qt Creator新建一个C&#43;&#43;动态库工程
设置类名和所需的Qt库，然后直接下一步
点击完成，完成工程的创建
生成的项目里有以下文件
需要其他的库可以直接在pro文件中进行配置
2、在项目文件中添加代码，实现一个可对外继承QWidget的类
.h文件，ReadDllTest 类继承自QWidget，可以使用Qt的信号与槽函数等等机制。
#include &lt;QWidget&gt; #include &lt;QString&gt; class __declspec(dllexport) ReadDllTest : public QWidget { public: ReadDllTest(QWidget *parent = nullptr); QString getObjStr(); }; .cpp文件，
ReadDllTest::ReadDllTest(QWidget *parent) :QWidget(parent) { // 设置初始位置和大小 resize(100, 100); move(500, 200); // 随意打印一个字符串 qDebug() &lt;&lt; getObjStr(); } // 非QWidget的标准函数 用于测试 QString ReadDllTest::getObjStr() { return QString(&#34;这里是对象中的str&#34;); } 3、使用 __declspec(dllexport) 关键字来修饰dll对外的接口，用来获取dll中的对象指针或其他资源。
// 在调用此接口时返回一个基类是QWidget的对象的指针 __declspec(dllexport) QWidget* __stdcall getObj(); 函数实现
// 保存对象指针的全局变量 ReadDllTest *obj = nullptr; // 判断全局变量是否为空 返回基类为QWidget的对象的指针 QWidget *getObj() { if(!" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/bfc55458ad69132cf58c8069be208917/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-11-17T12:30:53+08:00" />
<meta property="article:modified_time" content="2022-11-17T12:30:53+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">c/c&#43;&#43;开发时直接调用dll动态库中的函数，无需使用头文件编译</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <h2>一、开发环境</h2> 
<p>我写dome用的是Qt5.14.2</p> 
<p><img src="https://images2.imgbox.com/81/96/A4IFcLGW_o.png" alt="27a69b53624741e58fb88ad314bdc7a5.png"></p> 
<h2>二、创建dll</h2> 
<p>1、搭建生成dll的工程</p> 
<p>        使用Qt Creator新建一个C++动态库工程</p> 
<p><img src="https://images2.imgbox.com/5c/f9/nvH2SS6H_o.png" alt="73cd6efd59774d17ad787d70aabae380.png"></p> 
<p> <img src="https://images2.imgbox.com/1e/8f/h3Muawf3_o.png" alt="f7099259af5a47328eeea4d0f1867f32.png"></p> 
<p> <img src="https://images2.imgbox.com/ec/8b/XJJJUAuf_o.png" alt="78f864d30d744920a21cfba9add72420.png"></p> 
<p> <img src="https://images2.imgbox.com/91/0c/rdNHKX2U_o.png" alt="407f560658ef4840803961f448db5dce.png"></p> 
<p>设置类名和所需的Qt库，然后直接下一步</p> 
<p><img src="https://images2.imgbox.com/1a/37/qzPssXEO_o.png" alt="d01756b6645c46a5a51a90a7f2bf1d21.png"></p> 
<p> 点击完成，完成工程的创建</p> 
<p><img src="https://images2.imgbox.com/60/67/5Vd8gzUU_o.png" alt="c577ef67c8cc4712ba4940a0f72c4677.png"></p> 
<p> 生成的项目里有以下文件</p> 
<p><img src="https://images2.imgbox.com/e5/07/yiCaq4PB_o.png" alt="965da0019703415b8fb96770850565e1.png"></p> 
<p> 需要其他的库可以直接在pro文件中进行配置</p> 
<p><img src="https://images2.imgbox.com/55/a9/3quO2l2V_o.png" alt="f9977f5328c942758f4d5d45b1b6d2ee.png"></p> 
<p>2、在项目文件中添加代码，实现一个可对外继承QWidget的类</p> 
<p>.h文件，ReadDllTest 类继承自QWidget，可以使用Qt的信号与槽函数等等机制。</p> 
<pre><code class="language-cpp">#include &lt;QWidget&gt;
#include &lt;QString&gt;
class __declspec(dllexport) ReadDllTest : public QWidget
{
public:
    ReadDllTest(QWidget *parent = nullptr);
    QString getObjStr();
};</code></pre> 
<p>.cpp文件，</p> 
<pre><code class="language-cpp">ReadDllTest::ReadDllTest(QWidget *parent)
    :QWidget(parent)
{
    // 设置初始位置和大小 
    resize(100, 100);
    move(500, 200);
    // 随意打印一个字符串
    qDebug() &lt;&lt; getObjStr();
}
// 非QWidget的标准函数 用于测试
QString ReadDllTest::getObjStr()
{
    return QString("这里是对象中的str");
}</code></pre> 
<p>3、使用 __declspec(dllexport) 关键字来修饰dll对外的接口，用来获取dll中的对象指针或其他资源。</p> 
<pre><code class="language-cpp">// 在调用此接口时返回一个基类是QWidget的对象的指针
__declspec(dllexport) QWidget* __stdcall getObj();</code></pre> 
<p>函数实现</p> 
<pre><code class="language-cpp">// 保存对象指针的全局变量
ReadDllTest *obj = nullptr;

// 判断全局变量是否为空 返回基类为QWidget的对象的指针
QWidget *getObj()
{
    if(!obj){
        obj = new ReadDllTest();
    }
    return obj;
}</code></pre> 
<p>4、点击构建后生成dll</p> 
<p><img src="https://images2.imgbox.com/3f/6f/DgSODMri_o.png" alt="6838faacee974ac7aaef76c8ac6fb041.png"><img src="https://images2.imgbox.com/d5/e1/a6vfpbTD_o.png" alt="966afd1eb24747d782f89fb8edd55697.png"></p> 
<h2>三、新建一个测试的工程用于加载dll</h2> 
<p> 1、随便绘制一个窗口，给按钮创建槽函数</p> 
<p><img src="https://images2.imgbox.com/ca/d3/097HcaXV_o.png" alt="fb8b939fddae4907ad20ab971d697287.png"></p> 
<p> <img src="https://images2.imgbox.com/2b/5d/Zjj1wY2I_o.png" alt="88e812c607f4474e8e673d3a1997363b.png"></p> 
<p> 2、使用windows接口加载dll库</p> 
<p>引入接口头文件</p> 
<pre><code class="language-cpp">#include &lt;windows.h&gt;</code></pre> 
<p>使用QFileDialog的接口选择dll文件，获取它的文件路径</p> 
<pre><code class="language-cpp">QString filepsth = QFileDialog::getOpenFileName(this, "选择dll", "./", "dll(*.dll);");
</code></pre> 
<p> 定义一个用于</p> 
<p>将文件路径字符串转换为接口使用的类型</p> 
<pre><code class="language-cpp">// 定义一个数组，长度根据文件路径自行判断，要够长
wchar_t filepathwc[256];

// 一定要对数组进行初始化，不然后面的步骤会出错
memset(filepathwc, 0, 128 * sizeof(wchar_t));

qDebug() &lt;&lt; "file = " &lt;&lt; filepsth;

// 使用QString的接口将文件名写入数组中
qDebug() &lt;&lt; "to wc = " &lt;&lt; filepsth.toWCharArray(filepathwc);</code></pre> 
<p>加载动态库</p> 
<pre><code class="language-cpp">// 传入文件路径 加载dll
HMODULE module = LoadLibrary(filepathwc);
    
// 判断是否加载成功
if (module == NULL){
    qDebug() &lt;&lt; "加载动态库失败" &lt;&lt; GetLastError();         
}else{
    qDebug() &lt;&lt; "加载成功";
}</code></pre> 
<p> 定义一个接收函数指针的函数指针类型，接口和dll的接口一致</p> 
<pre><code class="language-cpp">typedef QWidget*(*GetObj)();</code></pre> 
<p>从dll库中获取函数地址</p> 
<pre><code class="language-cpp">// 获取dll中的函数的地址
GetObj add = NULL;
// 传入动态库句柄 函数在dll中的函数名
add = (GetObj)GetProcAddress(module, "_Z6getObjv");
qDebug() &lt;&lt; add;</code></pre> 
<p>获取函数地址成功后，调用函数，获取dll库中的对象，并将其显示</p> 
<pre><code class="language-cpp">    // 判断函数地址是否获取成功
    if(add){
        qDebug() &lt;&lt; "fun get success!";

        // 使用QWidget指针接收函数传来的对象
        QWidget *wids = add();

        if(wids){

            // 显示dll库中实现的窗口
            wids-&gt;show();
        }
    }else{
        qDebug() &lt;&lt; "error = " &lt;&lt; GetLastError();
    }</code></pre> 
<p>运行效果</p> 
<p><img src="https://images2.imgbox.com/0d/3c/t7x1YFVQ_o.png" alt="b63993e3715f4b3a94bec4708eba0c24.png"></p> 
<p><img src="https://images2.imgbox.com/b9/f3/zXiHp22P_o.png" alt="74eca153d58446db8163eaddecc10848.png"> dll中的窗口显示出来了</p> 
<p><img src="https://images2.imgbox.com/cb/18/CZIzCcXc_o.png" alt="772585a3c8794fc38b8baca2cf26cdc7.png"></p> 
<h2>四、 如何查看dll中的函数名</h2> 
<p>1、打开vs的窗口应用</p> 
<p><img src="https://images2.imgbox.com/7d/b8/Gbfkpjgy_o.png" alt="b1c25b972bd146ed82bfac84781da2b8.png"></p> 
<p> cd到dll生成的位置</p> 
<p><img src="https://images2.imgbox.com/b0/82/S2Ywk8Pq_o.png" alt="670fd2e84d0641d8aa59236a73d047b6.png"></p> 
<p> 使用命令</p> 
<pre><code class="language-cpp">dumpbin /exports readDllTest.dll &gt; readDllTest.txt</code></pre> 
<p><img src="https://images2.imgbox.com/b2/d7/hIsGTUo8_o.png" alt="e8aaf21779624093b3ceaba91e684d52.png"></p> 
<p> 然后打开生成的txt文档，可以看到一个和我们定义的函数很像的字符串，主要是首位多了些字符</p> 
<p><img src="https://images2.imgbox.com/99/a3/OqOUOdJh_o.png" alt="37ab6330e77d46a8a2c59cc3f6734b7a.png"></p> 
<p> <img src="https://images2.imgbox.com/b9/af/zjp3R2zu_o.png" alt="3a67f25d936046fb8fc09e3091ce1b50.png"></p> 
<p> 这个就是我们之前定义函数，使用txt文档中的这一串字符来获取函数名，直接使用函数名可能会获取不到</p> 
<p><img src="https://images2.imgbox.com/a3/3f/7vTTFc8L_o.png" alt="4b6c40abd4ce4f9daca819312827a903.png"></p> 
<h2> 五、总结</h2> 
<p>        这种方法可以用于开发可扩展的应用程序，在程序主体已经发布的情况下，可以通过继承统一的基类来实现exe直接加载dll，无需二次编译，之后可以直接发布dll作为插件，然后在exe中编写加载管理插件模块来实现应用程序平台的动态扩展。</p> 
<p> </p> 
<p> </p> 
<p> </p> 
<p> </p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/890e5f7cdbfccbb7ace7497084f8368e/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">css3对页面打印设置的一些特殊属性，如@page，target-counter等</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/0a4e6068eb70a5b6fc1f5500250afe59/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">批量创建10个文件夹，只需1秒~</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>