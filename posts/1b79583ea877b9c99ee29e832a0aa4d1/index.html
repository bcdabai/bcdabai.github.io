<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Linux | PCIe Hotplug | 概念及工作原理的不完全总结 - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Linux | PCIe Hotplug | 概念及工作原理的不完全总结" />
<meta property="og:description" content="本文对 PCIe 热插拔的概念及工作原理进行不完全总结。
更新： 2022 / 12 / 31
Linux | PCIe Hotplug | 概念及工作原理的不完全总结 热插拔组成部件实现代码通知式热插拔 线程中断功耗管理意外移除错误处理整合移除BAR参考链接 参考这里 1’ 2’ 3‘ 4’ 5
1992年初始版本的 PCI 规范并不支持运行时的板卡添加和移除。在20世纪90年代后期到21世纪初期，各种专有的热拔插控制器或者与厂商无关的标准热拔插控制器被构思出来，同时 Linux 通过位于 drivers/pci/hotplug 的驱动开始支持热拔插功能。然而，直到2002年 Linux 才开始支持PCI Express 的热拔插功能，但是具体的形式随时间不断变化。最初，PCI Express 热拔插主要是为服务器的热交换板卡或笔记本的 ExpressCards 设计的，如今，它已经广泛地应用于数据中心 ( 数据中心 NVMe Flash 硬盘需要运行时拔插 ) 和雷电接口。
热插拔 PCIe 热插拔，是指在系统上电运行时，允许插入或拔出 PCIe 设备。拔出时不需要平台提前下电，插入时直接生效，不需要系统重启。这对于服务器实现高可靠性而言是一个必不可少的特性。
热插拔可以分为2种，通知式热插拔 和 暴力热插拔。这两种差异主要体现在拔盘的操作上。
设备插入时， 内核 pciehp 驱动走的都是通知式热插流程，以盘插入时在位信号的变化或者通知按钮的按下作为触发条件。通知式热拔时，需要先通过软件指令，停止业务，移除 pcie 设备，再进行拔盘操作。暴力热拔时，没有任何通知，直接进行拔盘动作。 组成部件 为了 pcie 热插拔功能的实现，PCIe 协议定义了一系列需要实现的组件：
组件目的Indicatorshow the power and attention state of the slot。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/1b79583ea877b9c99ee29e832a0aa4d1/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-12-31T19:41:02+08:00" />
<meta property="article:modified_time" content="2022-12-31T19:41:02+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Linux | PCIe Hotplug | 概念及工作原理的不完全总结</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-github-gist">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p>本文对 <code>PCIe</code> 热插拔的概念及工作原理进行不完全总结。</p> 
<p>更新： 2022 / 12 / 31</p> 
<hr> 
<p></p> 
<div class="toc"> 
 <h4>Linux | PCIe Hotplug | 概念及工作原理的不完全总结</h4> 
 <ul><li><a href="#_14" rel="nofollow">热插拔</a></li><li><ul><li><a href="#_23" rel="nofollow">组成部件</a></li><li><a href="#_40" rel="nofollow">实现代码</a></li><li><ul><li><a href="#_41" rel="nofollow">通知式热插拔</a></li></ul> 
  </li></ul> 
  </li><li><a href="#_352" rel="nofollow">线程中断</a></li><li><a href="#_363" rel="nofollow">功耗管理</a></li><li><a href="#_380" rel="nofollow">意外移除</a></li><li><a href="#_395" rel="nofollow">错误处理整合</a></li><li><a href="#BAR_400" rel="nofollow">移除BAR</a></li><li><a href="#_410" rel="nofollow">参考链接</a></li></ul> 
</div> 
<p></p> 
<p>参考这里 <sup class="footnote-ref"><a href="#fn1" rel="nofollow" id="fnref1">1</a></sup>’ <sup class="footnote-ref"><a href="#fn2" rel="nofollow" id="fnref2">2</a></sup>’ <sup class="footnote-ref"><a href="#fn3" rel="nofollow" id="fnref3">3</a></sup>‘ <sup class="footnote-ref"><a href="#fn4" rel="nofollow" id="fnref4">4</a></sup>’ <sup class="footnote-ref"><a href="#fn5" rel="nofollow" id="fnref5">5</a></sup></p> 
<p>1992年初始版本的 <code>PCI</code> 规范并不支持运行时的板卡添加和移除。在20世纪90年代后期到21世纪初期，各种专有的热拔插控制器或者与厂商无关的标准热拔插控制器被构思出来，同时 <code>Linux</code> 通过位于 <code>drivers/pci/hotplug</code> 的驱动开始支持热拔插功能。然而，直到2002年 <code>Linux</code> 才开始支持<code>PCI Express</code> 的热拔插功能，但是具体的形式随时间不断变化。最初，<code>PCI Express</code> 热拔插主要是为服务器的热交换板卡或笔记本的 <code>ExpressCards</code> 设计的，如今，它已经广泛地应用于数据中心 ( 数据中心 <code>NVMe Flash</code> 硬盘需要运行时拔插 ) 和雷电接口。</p> 
<hr> 
<h2><a id="_14"></a>热插拔</h2> 
<p><code>PCIe</code> 热插拔，是指在系统上电运行时，允许插入或拔出 <code>PCIe</code> 设备。拔出时不需要平台提前下电，插入时直接生效，不需要系统重启。这对于服务器实现高可靠性而言是一个必不可少的特性。</p> 
<p>热插拔可以分为2种，<code>通知式热插拔</code> 和 <code>暴力热插拔</code>。这两种差异主要体现在拔盘的操作上。</p> 
<ul><li>设备插入时， 内核 <code>pciehp</code> 驱动走的都是通知式热插流程，以盘插入时在位信号的变化或者通知按钮的按下作为触发条件。通知式热拔时，需要先通过软件指令，停止业务，移除 <code>pcie</code> 设备，再进行拔盘操作。</li><li>暴力热拔时，没有任何通知，直接进行拔盘动作。</li></ul> 
<br> 
<h3><a id="_23"></a>组成部件</h3> 
<p>为了 <code>pcie</code> 热插拔功能的实现，<code>PCIe</code> 协议定义了一系列需要实现的组件：</p> 
<table><thead><tr><th align="center">组件</th><th align="left">目的</th></tr></thead><tbody><tr><td align="center"><code>Indicator</code></td><td align="left">show the power and attention state of the slot。<br><br>标准模型中定义两个 <code>indicators</code>：一个<code>Power Indicator</code> 和一个 <code>Attention Indicator</code>。都会有三种状态：<code>ON</code>；<code>OFF</code>；<code>Blinking</code>。</td></tr><tr><td align="center"></td><td align="left"><code>Attention Indicator</code> 是黄色的灯，用来指示出现了操作的问题，或者表示 <code>hotplug slot</code> 已经被识别到了，手动操作可以很容易定位到。<br><br><code>ON</code>: 表示热插拔槽位故障<br><code>OFF</code>: 表示一切正常<br><code>BLINKING</code>： 表示热插拔流程正在执行</td></tr><tr><td align="center"></td><td align="left"><code>Power Indicator</code> 是绿色的灯，表示 <code>slot</code> 的 <code>power</code> 状态，可以用 <code>blink</code> 指示总线对用户的操作产生了响应。<br><br><code>OFF</code>： 表示槽位下电，可以进行设备的热插或热拔<br><code>ON</code>： 表示热插拔操作已完成，槽位上电，不可以进行热插或热拔<br><code>BLINKING</code>： 表示此时正在处于上电或下电槽位， 或者此时 <code>attention button</code> 被按下，正在等待反馈，或者表示 <code>hot-plug</code> 操作正在进行软件的初始化</td></tr><tr><td align="center"><code>Manually-operated Retention Latch (MRL)</code></td><td align="left">Holds adds-in cards in place</td></tr><tr><td align="center"><code>MRL Sensor</code></td><td align="left">Allows the Port and system software to detect the MRL being opened<br><br><code>MRL</code> 是一种手动操作保留机制。保持插入卡在 <code>slot</code> 上，防止用户移除卡。系统添加了一个 <code>MRL sensor</code>，以便侦测每个 <code>port</code> 对应的 <code>slot</code> 的 <code>MRL</code>。</td></tr><tr><td align="center"><code>Electromechanical Interlock</code></td><td align="left">Prevents removal of add-in cards while slot is powered<br><br>一种互斥机制，确保在热插拔流程都执行完成后 <code>PCIe</code> 设备才可被物理移除。</td></tr><tr><td align="center"><code>Attention Button</code></td><td align="left">Allows user to request Hot-Plug operations<br><br>是 <code>hotplug</code> 中定义的一个开关按钮，一般会在 <code>slot</code> 上或者在卡片上，按一下表明要做一个 <code>hotplug</code> 动作或者 <code>removal</code> 动作。</td></tr><tr><td align="center"><code>Software User Interface</code></td><td align="left">Allows user to request Hot-Plug operations</td></tr><tr><td align="center"><code>Slot Numbering</code></td><td align="left">Provides visual identification of slots<br><br>槽位编号，由底板号（ <code>Classic Number</code> ）和物理槽位号（ <code>Physical Slot Number</code> ) 组成，可在用户接口上显示。</td></tr></tbody></table> 
<br> 
<h3><a id="_40"></a>实现代码</h3> 
<h4><a id="_41"></a>通知式热插拔</h4> 
<p>热拔的流程图如下所示：<br> <img src="https://images2.imgbox.com/8a/54/7qvSUMxg_o.png" alt="在这里插入图片描述"><br> 热插流程类似，不再赘述。</p> 
<p><code>PCIe</code> 热插拔功能的实现需要 <code>pcie</code> 热插拔控制器和 <code>pcie</code> 热插拔驱动的配合。<br> 代码主要集中在 <code>driver/pci/hotplug/pciehp_hpc.c</code> <sup class="footnote-ref"><a href="#fn6" rel="nofollow" id="fnref6">6</a></sup> 和 <code>driver/pci/hotplug/pciehp_ctrl.c</code> <sup class="footnote-ref"><a href="#fn7" rel="nofollow" id="fnref7">7</a></sup>。</p> 
<ul><li><code>pciehp_hpc.c</code> 主要负责控制器的初始化以及检测设备在位变化、<code>attention button pressed</code>、电源错误等事件检测，检测到这些事件后，会上报热插拔中断。</li><li><code>pciehp_ctrl.c</code> 代码主要是对热插拔各个 <code>events</code> 的具体处理。</li></ul> 
<ol><li><code>pciehp</code> 初始化<br> <code>PCIe</code> 热插拔是作为 <code>pcie</code> 端口服务实现的，它已在 <code>driver/pci/hotplug/pciehp_core.c</code> <sup class="footnote-ref"><a href="#fn8" rel="nofollow" id="fnref8">8</a></sup> 中的 <code>pcie</code> 端口驱动程序中注册：</li></ol> 
<pre><code class="prism language-c"><span class="token keyword">int</span> __init <span class="token function">pcie_hp_init</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token keyword">int</span> retval <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>

	retval <span class="token operator">=</span> <span class="token function">pcie_port_service_register</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>hpdriver_portdrv<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token function">pr_debug</span><span class="token punctuation">(</span><span class="token string">"pcie_port_service_register = %d\n"</span><span class="token punctuation">,</span> retval<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">if</span> <span class="token punctuation">(</span>retval<span class="token punctuation">)</span>
		<span class="token function">pr_debug</span><span class="token punctuation">(</span><span class="token string">"Failure to register service\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

	<span class="token keyword">return</span> retval<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>之后会调用 <code>pcie_probe</code> 进行端口注册，</p> 
<pre><code class="prism language-c"><span class="token operator">+</span><span class="token operator">-&gt;</span><span class="token function">pciehp_probe</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">pcie_device</span> <span class="token operator">*</span>dev<span class="token punctuation">)</span>
	<span class="token operator">+</span><span class="token operator">-&gt;</span> <span class="token function">pcie_init</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
		<span class="token operator">+</span><span class="token operator">-&gt;</span> <span class="token function">pcie_init_slot</span><span class="token punctuation">(</span><span class="token punctuation">)</span> 
		<span class="token comment">// 该函数中会创建hotplug_slot, hotplug_slot_info, hotplug_slot_ops等热插拔驱动关键的数据结构</span>
		
	<span class="token operator">+</span><span class="token operator">-&gt;</span> <span class="token function">init_slot</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
		<span class="token operator">+</span><span class="token operator">-&gt;</span> <span class="token function">pci_hp_initialize</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
			<span class="token operator">+</span><span class="token operator">-&gt;</span> <span class="token function">pci_create_slot</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
				<span class="token operator">+</span><span class="token operator">-&gt;</span> <span class="token function">kobject_init_and_add</span><span class="token punctuation">(</span><span class="token punctuation">)</span>  
				<span class="token comment">// 添加sysfs对象</span>
				<span class="token operator">+</span><span class="token operator">-&gt;</span> <span class="token function">list_add</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>slot<span class="token operator">-&gt;</span>list<span class="token punctuation">,</span> <span class="token operator">&amp;</span>parent<span class="token operator">-&gt;</span>slots<span class="token punctuation">)</span> 
				<span class="token comment">//  将hotplug_slot添加到pci_hotplug_slot_list</span>
	
	<span class="token operator">+</span><span class="token operator">-&gt;</span> <span class="token function">pcie_init_notification</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
		<span class="token operator">+</span><span class="token operator">-&gt;</span> <span class="token function">pciehp_request_irq</span><span class="token punctuation">(</span><span class="token punctuation">)</span> 
		<span class="token comment">//中断申请</span>
		<span class="token operator">+</span><span class="token operator">-&gt;</span> <span class="token function">pcie_enable_notification</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
	
	<span class="token operator">+</span><span class="token operator">-&gt;</span>  <span class="token function">pciehp_enable_slot</span><span class="token punctuation">(</span><span class="token punctuation">)</span> 
	<span class="token comment">// 使能hp槽位</span>
		<span class="token operator">+</span><span class="token operator">-&gt;</span> <span class="token function">board_added</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
</code></pre> 
<ol start="2"><li>注册热插拔中断服务 <sup class="footnote-ref"><a href="#fn6" rel="nofollow" id="fnref6:1">6</a></sup></li></ol> 
<pre><code class="prism language-c"><span class="token keyword">static</span> <span class="token keyword">inline</span> <span class="token keyword">int</span> <span class="token function">pciehp_request_irq</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">controller</span> <span class="token operator">*</span>ctrl<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token keyword">int</span> retval<span class="token punctuation">,</span> irq <span class="token operator">=</span> ctrl<span class="token operator">-&gt;</span>pcie<span class="token operator">-&gt;</span>irq<span class="token punctuation">;</span>
	<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
	<span class="token comment">/* Installs the interrupt handler */</span>
	retval <span class="token operator">=</span> <span class="token function">request_threaded_irq</span><span class="token punctuation">(</span>irq<span class="token punctuation">,</span> pciehp_isr<span class="token punctuation">,</span> pciehp_ist<span class="token punctuation">,</span>
				      IRQF_SHARED<span class="token punctuation">,</span> MY_NAME<span class="token punctuation">,</span> ctrl<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>这里使用了中断线程化，创建一个中断服务 <code>pciehp_isr</code>, 并且创建了一个 <code>irq_thread</code> 内核线程以及线程会执行的函数 <code>pciehp_ist</code>。<br> 当中断发生时，中断处理程序会先去处理 <code>pciehp_isr</code>, 如果 <code>pciehp_isr</code> 返回<code>IRQ_WAKE_THREAD</code>， 会去唤醒内核线程，处理 <code>pciehp_ist</code>。</p> 
<pre><code class="prism language-c"><span class="token keyword">case</span> IRQ_WAKE_THREAD<span class="token operator">:</span>
			<span class="token comment">/*
			 * Catch drivers which return WAKE_THREAD but
			 * did not set up a thread function
			 */</span>
			<span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">unlikely</span><span class="token punctuation">(</span><span class="token operator">!</span>action<span class="token operator">-&gt;</span>thread_fn<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
				<span class="token function">warn_no_thread</span><span class="token punctuation">(</span>irq<span class="token punctuation">,</span> action<span class="token punctuation">)</span><span class="token punctuation">;</span>
				<span class="token keyword">break</span><span class="token punctuation">;</span>
			<span class="token punctuation">}</span>

			<span class="token function">__irq_wake_thread</span><span class="token punctuation">(</span>desc<span class="token punctuation">,</span> action<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> 
<p>中断线程化之后，中断将作为内核线程运行而且被赋予不同的实时优先级，实时任务可以有比中断线程更高的优先级。这样，具有最高优先级的实时任务就能得到优先处理。</p> 
<ol start="3"><li>热插拔控制器上报中断后，<code>pciehp</code> 驱动会进入 <code>pcie_isr</code> 函数执行</li></ol> 
<pre><code class="prism language-c"><span class="token keyword">static</span> <span class="token class-name">irqreturn_t</span> <span class="token function">pciehp_isr</span><span class="token punctuation">(</span><span class="token keyword">int</span> irq<span class="token punctuation">,</span> <span class="token keyword">void</span> <span class="token operator">*</span>dev_id<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token keyword">struct</span> <span class="token class-name">controller</span> <span class="token operator">*</span>ctrl <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">controller</span> <span class="token operator">*</span><span class="token punctuation">)</span>dev_id<span class="token punctuation">;</span>
	<span class="token keyword">struct</span> <span class="token class-name">pci_dev</span> <span class="token operator">*</span>pdev <span class="token operator">=</span> <span class="token function">ctrl_dev</span><span class="token punctuation">(</span>ctrl<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">struct</span> <span class="token class-name">device</span> <span class="token operator">*</span>parent <span class="token operator">=</span> pdev<span class="token operator">-&gt;</span>dev<span class="token punctuation">.</span>parent<span class="token punctuation">;</span>
	u16 status<span class="token punctuation">,</span> events <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>

	<span class="token comment">/*
	 * Interrupts only occur in D3hot or shallower and only if enabled
	 * in the Slot Control register (PCIe r4.0, sec 6.7.3.4).
	 */</span>
	<span class="token keyword">if</span> <span class="token punctuation">(</span>pdev<span class="token operator">-&gt;</span>current_state <span class="token operator">==</span> PCI_D3cold <span class="token operator">||</span>
	    <span class="token punctuation">(</span><span class="token operator">!</span><span class="token punctuation">(</span>ctrl<span class="token operator">-&gt;</span>slot_ctrl <span class="token operator">&amp;</span> PCI_EXP_SLTCTL_HPIE<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span>pciehp_poll_mode<span class="token punctuation">)</span><span class="token punctuation">)</span>
		<span class="token keyword">return</span> IRQ_NONE<span class="token punctuation">;</span>

	<span class="token comment">/*
	 * Keep the port accessible by holding a runtime PM ref on its parent.
	 * Defer resume of the parent to the IRQ thread if it's suspended.
	 * Mask the interrupt until then.
	 */</span>
	<span class="token keyword">if</span> <span class="token punctuation">(</span>parent<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
		<span class="token function">pm_runtime_get_noresume</span><span class="token punctuation">(</span>parent<span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">pm_runtime_active</span><span class="token punctuation">(</span>parent<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
			<span class="token function">pm_runtime_put</span><span class="token punctuation">(</span>parent<span class="token punctuation">)</span><span class="token punctuation">;</span>
			<span class="token function">disable_irq_nosync</span><span class="token punctuation">(</span>irq<span class="token punctuation">)</span><span class="token punctuation">;</span>
			<span class="token function">atomic_or</span><span class="token punctuation">(</span>RERUN_ISR<span class="token punctuation">,</span> <span class="token operator">&amp;</span>ctrl<span class="token operator">-&gt;</span>pending_events<span class="token punctuation">)</span><span class="token punctuation">;</span>
			<span class="token keyword">return</span> IRQ_WAKE_THREAD<span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
	<span class="token punctuation">}</span>

read_status<span class="token operator">:</span>
	<span class="token function">pcie_capability_read_word</span><span class="token punctuation">(</span>pdev<span class="token punctuation">,</span> PCI_EXP_SLTSTA<span class="token punctuation">,</span> <span class="token operator">&amp;</span>status<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">PCI_POSSIBLE_ERROR</span><span class="token punctuation">(</span>status<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
		<span class="token function">ctrl_info</span><span class="token punctuation">(</span>ctrl<span class="token punctuation">,</span> <span class="token string">"%s: no response from device\n"</span><span class="token punctuation">,</span> <span class="token constant">__func__</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token keyword">if</span> <span class="token punctuation">(</span>parent<span class="token punctuation">)</span>
			<span class="token function">pm_runtime_put</span><span class="token punctuation">(</span>parent<span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token keyword">return</span> IRQ_NONE<span class="token punctuation">;</span>
	<span class="token punctuation">}</span>

	<span class="token comment">/*
	 * Slot Status contains plain status bits as well as event
	 * notification bits; right now we only want the event bits.
	 */</span>
	status <span class="token operator">&amp;=</span> PCI_EXP_SLTSTA_ABP <span class="token operator">|</span> PCI_EXP_SLTSTA_PFD <span class="token operator">|</span>
		  PCI_EXP_SLTSTA_PDC <span class="token operator">|</span> PCI_EXP_SLTSTA_CC <span class="token operator">|</span>
		  PCI_EXP_SLTSTA_DLLSC<span class="token punctuation">;</span>

	<span class="token comment">/*
	 * If we've already reported a power fault, don't report it again
	 * until we've done something to handle it.
	 */</span>
	<span class="token keyword">if</span> <span class="token punctuation">(</span>ctrl<span class="token operator">-&gt;</span>power_fault_detected<span class="token punctuation">)</span>
		status <span class="token operator">&amp;=</span> <span class="token operator">~</span>PCI_EXP_SLTSTA_PFD<span class="token punctuation">;</span>
	<span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>status <span class="token operator">&amp;</span> PCI_EXP_SLTSTA_PFD<span class="token punctuation">)</span>
		ctrl<span class="token operator">-&gt;</span>power_fault_detected <span class="token operator">=</span> true<span class="token punctuation">;</span>

	events <span class="token operator">|=</span> status<span class="token punctuation">;</span>
	<span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>events<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
		<span class="token keyword">if</span> <span class="token punctuation">(</span>parent<span class="token punctuation">)</span>
			<span class="token function">pm_runtime_put</span><span class="token punctuation">(</span>parent<span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token keyword">return</span> IRQ_NONE<span class="token punctuation">;</span>
	<span class="token punctuation">}</span>

	<span class="token keyword">if</span> <span class="token punctuation">(</span>status<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
		<span class="token function">pcie_capability_write_word</span><span class="token punctuation">(</span>pdev<span class="token punctuation">,</span> PCI_EXP_SLTSTA<span class="token punctuation">,</span> status<span class="token punctuation">)</span><span class="token punctuation">;</span>

		<span class="token comment">/*
		 * In MSI mode, all event bits must be zero before the port
		 * will send a new interrupt (PCIe Base Spec r5.0 sec 6.7.3.4).
		 * So re-read the Slot Status register in case a bit was set
		 * between read and write.
		 */</span>
		<span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">pci_dev_msi_enabled</span><span class="token punctuation">(</span>pdev<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span>pciehp_poll_mode<span class="token punctuation">)</span>
			<span class="token keyword">goto</span> read_status<span class="token punctuation">;</span>
	<span class="token punctuation">}</span>

	<span class="token function">ctrl_dbg</span><span class="token punctuation">(</span>ctrl<span class="token punctuation">,</span> <span class="token string">"pending interrupts %#06x from Slot Status\n"</span><span class="token punctuation">,</span> events<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">if</span> <span class="token punctuation">(</span>parent<span class="token punctuation">)</span>
		<span class="token function">pm_runtime_put</span><span class="token punctuation">(</span>parent<span class="token punctuation">)</span><span class="token punctuation">;</span>

	<span class="token comment">/*
	 * Command Completed notifications are not deferred to the
	 * IRQ thread because it may be waiting for their arrival.
	 */</span>
	<span class="token keyword">if</span> <span class="token punctuation">(</span>events <span class="token operator">&amp;</span> PCI_EXP_SLTSTA_CC<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
		ctrl<span class="token operator">-&gt;</span>cmd_busy <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
		<span class="token function">smp_mb</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token function">wake_up</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>ctrl<span class="token operator">-&gt;</span>queue<span class="token punctuation">)</span><span class="token punctuation">;</span>

		<span class="token keyword">if</span> <span class="token punctuation">(</span>events <span class="token operator">==</span> PCI_EXP_SLTSTA_CC<span class="token punctuation">)</span>
			<span class="token keyword">return</span> IRQ_HANDLED<span class="token punctuation">;</span>

		events <span class="token operator">&amp;=</span> <span class="token operator">~</span>PCI_EXP_SLTSTA_CC<span class="token punctuation">;</span>
	<span class="token punctuation">}</span>

	<span class="token keyword">if</span> <span class="token punctuation">(</span>pdev<span class="token operator">-&gt;</span>ignore_hotplug<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
		<span class="token function">ctrl_dbg</span><span class="token punctuation">(</span>ctrl<span class="token punctuation">,</span> <span class="token string">"ignoring hotplug event %#06x\n"</span><span class="token punctuation">,</span> events<span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token keyword">return</span> IRQ_HANDLED<span class="token punctuation">;</span>
	<span class="token punctuation">}</span>

	<span class="token comment">/* Save pending events for consumption by IRQ thread. */</span>
	<span class="token function">atomic_or</span><span class="token punctuation">(</span>events<span class="token punctuation">,</span> <span class="token operator">&amp;</span>ctrl<span class="token operator">-&gt;</span>pending_events<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">return</span> IRQ_WAKE_THREAD<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>对 <code>pciehp_isr</code> 函数几个操作进行分析：<br> [1.] 检查设备当前状态是否处于 <code>D3_cold</code> 状态。<br> <code>D3hot</code>（ 通常只称作 <code>D3</code> ）是设备的 <code>软关闭</code> 状态，在此状态下，总线扫描可以检测到设备，并且发送给设备的命令可能会导致它再次打开电源，而在 <code>D3cold</code> 中，将切断所有电源，只保留少量电源以驱动设备的唤醒逻辑。<br> 因此，在这里检测到如果处于 <code>D3cold</code> 状态，直接退出。<br> [2.] 如果设备存在父设备，在该设备 <code>resume</code> 前要先 <code>resume</code> 父设备<br> [3.] 读 <code>pcie slot status</code> 确认 <code>events</code> 状态。<code>hotplug controller</code> 监控各种 <code>events</code> 并把这些 <code>events</code> 上报给 <code>hotplug system driver</code>。<br> 这里需要关注这些 <code>events</code> 即可。<code>Attention button pressed</code> ( <code>Attention</code> 按键按下), <code>power fault detected</code> (电源错误), <code>presence detect changed</code> (在位状态变化), <code>command completed</code> (命令完成), <code>data link layer state changed</code> (链路状态改变)。</p> 
<p>所以整个 <code>isr</code> 流程主要的处理就是决定哪些 <code>events</code> 可以通过 <code>system interrupt</code> 上报给系统，然后唤醒内核线程，处理线程函数 <code>pciehp_ist</code></p> 
<ol start="4"><li>中断线程化处理 <code>pciehp_ist</code></li></ol> 
<pre><code class="prism language-c"><span class="token keyword">static</span> <span class="token class-name">irqreturn_t</span> <span class="token function">pciehp_ist</span><span class="token punctuation">(</span><span class="token keyword">int</span> irq<span class="token punctuation">,</span> <span class="token keyword">void</span> <span class="token operator">*</span>dev_id<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token keyword">struct</span> <span class="token class-name">controller</span> <span class="token operator">*</span>ctrl <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">controller</span> <span class="token operator">*</span><span class="token punctuation">)</span>dev_id<span class="token punctuation">;</span>
	<span class="token keyword">struct</span> <span class="token class-name">pci_dev</span> <span class="token operator">*</span>pdev <span class="token operator">=</span> <span class="token function">ctrl_dev</span><span class="token punctuation">(</span>ctrl<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token class-name">irqreturn_t</span> ret<span class="token punctuation">;</span>
	u32 events<span class="token punctuation">;</span>

	ctrl<span class="token operator">-&gt;</span>ist_running <span class="token operator">=</span> true<span class="token punctuation">;</span>
	<span class="token function">pci_config_pm_runtime_get</span><span class="token punctuation">(</span>pdev<span class="token punctuation">)</span><span class="token punctuation">;</span>

	<span class="token comment">/* rerun pciehp_isr() if the port was inaccessible on interrupt */</span>
	<span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">atomic_fetch_and</span><span class="token punctuation">(</span><span class="token operator">~</span>RERUN_ISR<span class="token punctuation">,</span> <span class="token operator">&amp;</span>ctrl<span class="token operator">-&gt;</span>pending_events<span class="token punctuation">)</span> <span class="token operator">&amp;</span> RERUN_ISR<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
		ret <span class="token operator">=</span> <span class="token function">pciehp_isr</span><span class="token punctuation">(</span>irq<span class="token punctuation">,</span> dev_id<span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token function">enable_irq</span><span class="token punctuation">(</span>irq<span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token keyword">if</span> <span class="token punctuation">(</span>ret <span class="token operator">!=</span> IRQ_WAKE_THREAD<span class="token punctuation">)</span>
			<span class="token keyword">goto</span> out<span class="token punctuation">;</span>
	<span class="token punctuation">}</span>

	<span class="token function">synchronize_hardirq</span><span class="token punctuation">(</span>irq<span class="token punctuation">)</span><span class="token punctuation">;</span>
	events <span class="token operator">=</span> <span class="token function">atomic_xchg</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>ctrl<span class="token operator">-&gt;</span>pending_events<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>events<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
		ret <span class="token operator">=</span> IRQ_NONE<span class="token punctuation">;</span>
		<span class="token keyword">goto</span> out<span class="token punctuation">;</span>
	<span class="token punctuation">}</span>

	<span class="token comment">/* Check Attention Button Pressed */</span>
	<span class="token keyword">if</span> <span class="token punctuation">(</span>events <span class="token operator">&amp;</span> PCI_EXP_SLTSTA_ABP<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
		<span class="token function">ctrl_info</span><span class="token punctuation">(</span>ctrl<span class="token punctuation">,</span> <span class="token string">"Slot(%s): Attention button pressed\n"</span><span class="token punctuation">,</span>
			  <span class="token function">slot_name</span><span class="token punctuation">(</span>ctrl<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token function">pciehp_handle_button_press</span><span class="token punctuation">(</span>ctrl<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>

	<span class="token comment">/* Check Power Fault Detected */</span>
	<span class="token keyword">if</span> <span class="token punctuation">(</span>events <span class="token operator">&amp;</span> PCI_EXP_SLTSTA_PFD<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
		<span class="token function">ctrl_err</span><span class="token punctuation">(</span>ctrl<span class="token punctuation">,</span> <span class="token string">"Slot(%s): Power fault\n"</span><span class="token punctuation">,</span> <span class="token function">slot_name</span><span class="token punctuation">(</span>ctrl<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token function">pciehp_set_indicators</span><span class="token punctuation">(</span>ctrl<span class="token punctuation">,</span> PCI_EXP_SLTCTL_PWR_IND_OFF<span class="token punctuation">,</span>
				      PCI_EXP_SLTCTL_ATTN_IND_ON<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>

	<span class="token comment">/*
	 * Ignore Link Down/Up events caused by Downstream Port Containment
	 * if recovery from the error succeeded.
	 */</span>
	<span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>events <span class="token operator">&amp;</span> PCI_EXP_SLTSTA_DLLSC<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token function">pci_dpc_recovered</span><span class="token punctuation">(</span>pdev<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span>
	    ctrl<span class="token operator">-&gt;</span>state <span class="token operator">==</span> ON_STATE<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
		events <span class="token operator">&amp;=</span> <span class="token operator">~</span>PCI_EXP_SLTSTA_DLLSC<span class="token punctuation">;</span>
		<span class="token function">pciehp_ignore_dpc_link_change</span><span class="token punctuation">(</span>ctrl<span class="token punctuation">,</span> pdev<span class="token punctuation">,</span> irq<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>

	<span class="token comment">/*
	 * Disable requests have higher priority than Presence Detect Changed
	 * or Data Link Layer State Changed events.
	 */</span>
	<span class="token function">down_read_nested</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>ctrl<span class="token operator">-&gt;</span>reset_lock<span class="token punctuation">,</span> ctrl<span class="token operator">-&gt;</span>depth<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">if</span> <span class="token punctuation">(</span>events <span class="token operator">&amp;</span> DISABLE_SLOT<span class="token punctuation">)</span>
		<span class="token function">pciehp_handle_disable_request</span><span class="token punctuation">(</span>ctrl<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>events <span class="token operator">&amp;</span> <span class="token punctuation">(</span>PCI_EXP_SLTSTA_PDC <span class="token operator">|</span> PCI_EXP_SLTSTA_DLLSC<span class="token punctuation">)</span><span class="token punctuation">)</span>
		<span class="token function">pciehp_handle_presence_or_link_change</span><span class="token punctuation">(</span>ctrl<span class="token punctuation">,</span> events<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token function">up_read</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>ctrl<span class="token operator">-&gt;</span>reset_lock<span class="token punctuation">)</span><span class="token punctuation">;</span>

	ret <span class="token operator">=</span> IRQ_HANDLED<span class="token punctuation">;</span>
out<span class="token operator">:</span>
	<span class="token function">pci_config_pm_runtime_put</span><span class="token punctuation">(</span>pdev<span class="token punctuation">)</span><span class="token punctuation">;</span>
	ctrl<span class="token operator">-&gt;</span>ist_running <span class="token operator">=</span> false<span class="token punctuation">;</span>
	<span class="token function">wake_up</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>ctrl<span class="token operator">-&gt;</span>requester<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">return</span> ret<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>[1.] 这里主要涉及到的是 <code>runtime pm</code> 的运行机制。<br> 需要使用设备时，<code>device driver</code> 调用<code>pm_runtime_get</code> 接口，增加引用计数；<br> 不再使用设备时，<code>device driver</code> 调用 <code>pm_runtime_put</code> 接口，减少引用计数。<br> [2.] 检测到了 <code>attention button</code> 按钮被按下。检测到一个 <code>attention button pressed</code> 中断，对该中断的处理需要依据当前 <code>pcie</code> 槽位的状态</p> 
<pre><code class="prism language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">BLINKINGON_STATE</span>		<span class="token expression"><span class="token number">1</span></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">BLINKINGOFF_STATE</span>		<span class="token expression"><span class="token number">2</span></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">POWERON_STATE</span>			<span class="token expression"><span class="token number">3</span></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">POWEROFF_STATE</span>			<span class="token expression"><span class="token number">4</span></span></span>
</code></pre> 
<ul><li>如果检测到当前槽位状态为 <code>POWEON</code>，就说明此时产生了一个 <code>hot-remove</code>，将状态设置为<code>BLINKINGOFF</code>， 表示 <code>pcie controller</code> 会等待 <code>5 s</code> 后将该槽位下电。</li><li>如果检测到当前槽位状态为 <code>POWEOFF</code>, 就说明此时需要热插，将状态设置为 <code>BLINKINGON</code>， 表示 <code>pcie controller</code> 会等待 <code>5 s</code> 后将该槽位上电。</li><li>如果检测到当前槽位状态已经处于 <code>BLINKINGON / OFF state</code>, 说明此时需要取消上次的热插或热拔操作，将槽位的状态恢复成 <code>ON / OFF state</code>。</li></ul> 
<p><img src="https://images2.imgbox.com/07/65/He6KesHj_o.png" alt="在这里插入图片描述" width="500"><br> 如果 <code>5 s</code> 内没有取消 <code>attention button</code>, 最终会执行到 <code>pcie_init_slot</code> 中初始化的 <code>slot-&gt;work</code>， 进行<code>slot</code> 的 <code>enable</code> 或 <code>disable</code> ( <code>pciehp_queue_pushbutton_work</code> )。<br> [3.] 检测到了电源异常。<br> 将 <code>power_fault_detected</code> 标志先置为 <code>1</code>，表示电源异常不会重复处理，然后将电源指示灯熄灭。<br> [4.] 检测到了 <code>disble_slot</code><br> <code>DISABLE_SLOT</code> 主要用于响应用户通过 <code>sysfs</code> 或者 <code>attention button</code> 禁用槽位的请求，此事件的优先级要高于在位信号状态或者链路状态改变。<br> [5.] 如果检测到在位状态改变或链路状态改变</p> 
<ul><li>如果 <code>pcie slot</code> 槽位处于上电状态，却产生了在位状态改变的 <code>event</code>，说明产生了暴力热拔操作， 此时直接将槽位下电。</li></ul> 
<pre><code class="prism language-c"><span class="token operator">+</span><span class="token operator">-&gt;</span><span class="token function">pciehp_handle_presence_or_link_change</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
	<span class="token operator">+</span><span class="token operator">-&gt;</span> slot<span class="token operator">-&gt;</span>state <span class="token operator">=</span> POWEROFF_STATE<span class="token punctuation">;</span>
	<span class="token operator">+</span><span class="token operator">-&gt;</span> <span class="token function">pciehp_disable_slot</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
		<span class="token operator">+</span><span class="token operator">-&gt;</span><span class="token function">remove_board</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
</code></pre> 
<ul><li>如果链路状态正常并且 <code>pcie</code> 卡处于在位状态，进行热插的处理。</li></ul> 
<pre><code class="prism language-c"><span class="token operator">+</span><span class="token operator">-&gt;</span>present <span class="token operator">||</span> link_active
	<span class="token operator">+</span><span class="token operator">-&gt;</span> <span class="token function">pciehp_enable_slot</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
 		<span class="token operator">+</span><span class="token operator">-&gt;</span> <span class="token function">board_added</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
 			<span class="token operator">+</span><span class="token operator">-&gt;</span> <span class="token function">pciehp_configure_device</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
</code></pre> 
<hr> 
<h2><a id="_352"></a>线程中断</h2> 
<p><code>Linux</code> 的 <code>PCIe</code> 热拔插驱动 <code>pciehp</code> 在 2004 年被 <code>Dely Sy</code> 引入。<code>Kenji Kaneshige</code> 对其进行了第一次清理和修订，直到 2011 年才结束相关工作。在这之后，贡献者们的工作大多局限于完善驱动的缺陷，尤其是事件处理。</p> 
<p><code>Threaded Interrupts</code> 是内核中主要的中断处理模式，是实时 <code>Linux</code> 的基石，但是不幸的，它们直到 <code>Kaneshige</code> 的修订完成后才被引入。因此，<code>pciehp</code> 的硬中断处理器识别发生了什么事件，比如 <code>link-up</code> 或者 <code>link-down</code>，并为每个事件安排工作项。这种方法的问题是当执行 ( <code>work item</code> )时，<code>link</code> 状态可以再次发生变化。此外，如果 <code>link</code> 状态翻转比硬件处理器速度快时，可能导致检测到不均衡的 <code>link-up</code> 和 <code>link-down</code> 事件。最终，多个 <code>work item</code> 并存的可能性以及它们的交互方式使得很难判断事件处理代码的正确性。当前，<code>PCI</code> 维护员 <code>Bjorn Helgaas</code> 称 <code>pciph</code> 的事件处理复杂且怪异。除非驱动的修订不再是一个选项时，那么驱动的基本反思是不可避免地。</p> 
<p>在 <code>Linux 4.19</code> 版本中，把 <code>pciehp</code> 转换为线程中断处理 ( <code>threaded interrupt handling</code> )。现在硬件中断处理器负责收集事件，中断线程负责处理事件。检测 <code>link</code> 变化是 <code>link up</code> 还是 <code>link down</code> 这项工作推迟到中断线程中事件处理函数处理，以避免处理陈旧的事件。新的方法可以快速处理事件序列 (比如，<code>link down</code> 后紧接着 <code>link up</code> )，可以容忍 <code>pcie slot</code> 启动过程中 <code>link</code> 状态发生翻转 (比如电磁干扰引起的)。补丁集也修复了大量的 <code>bug</code> 和做了大量清理工作，因此，<code>PCI Express</code> 驱动的可靠性和健壮性得到了显著的提升。</p> 
<p>对于 <code>Linux 4.20</code> 版本中安排的后续补丁将从<code>pcihp</code> 和其他热拔插驱动中删除将近 <code>500</code> 行代码，进而使代码简化和标准化。</p> 
<br> 
<h2><a id="_363"></a>功耗管理</h2> 
<p><code>Linux 4.19</code> 增加了运行时挂起 <code>PCIe</code> 热拔插端口的功能，这项功能对雷电控制器的掉电是必不可少，雷电控制器在操作系统中表现为一个 <code>PCIe</code> 上游端口和多个 <code>PCIe</code> 下游端口。在控制器掉电前，所有的 <code>PCIe</code> 端口运行时挂起。<code>Linux</code> 从 <code>4.8</code> 版本开始就可以运行时挂起上游端口，但是在 <code>4.19</code> 版本前并不能挂起运行时挂起下游端口。</p> 
<p>运行时挂起一个雷电 <code>PCIe</code> 端口本身并不会引起任何节能，端口将会对通过聚集 <code>IO Switch</code> 传 输的 <code>PCIe</code> 数据包进行封装和解封，那么只要给 <code>Switch</code> 供电，那么就会消耗能量。然而，<code>Linux</code> 的功耗管理模型要求所有的子设备在其父节点挂起前被挂起。通过运行时挂起雷电控制器的所有端口，它的父端口(根端口)允许挂起，这反过来通过 <code>ACPI</code> 平台方法触发掉电。控制器下电可以节约大约 <code>1.5W</code> 的功耗。</p> 
<p>换句话说，运行时挂起雷电 <code>PCIe</code> 端口满足了 <code>Linux</code> 的层级化功耗管理模型。单个雷电 <code>PCIe</code> 端口在 <code>PCI</code> 电源状态 <code>D0</code> (全功耗) 或者 <code>D3hot</code> (挂起) 这两种状态消耗同样多的功耗，但是当所有端口运行时挂起时控制器作为整体是可以掉电的。在 <code>MacBook</code> 平台，雷电控制器掉电功能可能需要进一步打补丁解决，预计在 <code>4.21</code> 版本中出现。</p> 
<p>当一个 <code>PCIe</code> 热拔插端口运行时挂起时热拔插事件处理发生一个有趣的细节：如果它的父端口也运行时挂起，那么该端口是不可访问的。因此，它不能带内发出中断信号，内核不能与之交互，或者甚至在父端口恢复运行时挂起前不能确定事件类型。当前有两种硬件方法可以解决这个问题。</p> 
<p>第一个方法遵循 <code>PCIe</code> 规范：热拔插端口信号是一个电源管理事件 ( <code>PME</code> )，它可以通过平台提供带外信号方式发生，比如一个通用 <code>IO</code> 引脚 ( 在 <code>PCIE</code> 中的 <code>WAKE#</code> 信号)。<code>PME</code> 唤醒雷电<code>Host</code> 控制器下面所有层级，随之，热拔插端口可以被访问。这个方法被联想和 <code>Dell</code> 笔记本采用。它允许在连接设备的情况下让控制器掉电。<code>Mika Westerberg</code> 已经在 <code>4.20</code> 版本中提交了支持该功能的补丁。</p> 
<p>第二种方法是非标准的：雷电硬件直到哪个通道建立了连接，因此可以将聚合 <code>IO</code> 层发生的热拔插事件转换为一个 <code>overlaid PCIe</code> 层发生的热拔插事件。这样，当设备被添加或移除时，无论其自己还是其父端口是否处在 <code>D3hot</code> 状态，都会魔幻般从受影响的 <code>PCIe</code> 端口接收到一个中断。这种方法在 <code>Apple Macs</code> ( 雷电 <code>1</code> ) 中采用，只要设备已经连接的情况下雷电 <code>Host</code> 控制器需要保持供电。在 <code>4.19</code> 版本中已经添加了这种功能。</p> 
<p>运行时电源管理当前对非-雷电热拔插端口是禁止的，因为当非雷电热拔插端口在 <code>D3hot</code> 状态时可能引起诸如不可屏蔽的中断 ( <code>NMI</code> )。厂商可以在命令行传递 <code>pcie_port_pm=force</code> 验证它们的热拔插端口是否支持运行时挂起，也许这个功能可能在晚些时候默认使能。</p> 
<br> 
<h2><a id="_380"></a>意外移除</h2> 
<p>初始 <code>PCIe</code> 规范定义了标准用法模型，该模型定义了手动保留锁固定板卡位置和一个按钮用于请求从操作系统移除一个 <code>PCIe Slot</code>。但是当前热拔插实现通常忽略这些元素和仅仅使用<code>surprise removal</code> 这种方式。</p> 
<p>当一个设备被拽出时，<code>pciehp</code> 要求它的驱动解绑，然后 <code>bring down</code> 该槽位。但是直到这一切发生，对设备的读请求将会在 <code>17ms</code> 后溢出，然后返回一个全 <code>1</code> 的响应。这个超时降低了请求任务的速度，如果构造的响应对实际的数据是错误的，那么该任务可能崩溃或者陷入到无限循环中。因此，驱动需要从一个设备读取的数据的有效性，尤其是，检查全 <code>1</code> 但是不是一个有效响应的情况。一个惯用的方法是调用 <code>pci_device_is_present()</code> ,该函数读取厂商 <code>ID</code> 寄存器，检查该寄存器是否全 <code>1</code>。然而，这也不是万能药；如果发生一个 <code>PCIe</code> 不可修复的错误，那么设备也可能以全 <code>1</code> 进行响应，但是如果错误可以恢复，那么也可以还原到有效响应。此外，对于不支持的请求或者位于桥地址窗口内内任一目标设备基址寄存器 ( <code>BARs</code> ) 外的读请求也可能返回全 <code>1</code> 响应。唯一能够权威且明确识别移除的实体是 <code>pciehp</code>。</p> 
<p>许多驱动甚至 <code>PCI</code> 核并不会对一个全 <code>1</code> 响应的每个读进行检查。效力于 Facebook “Lighting"存储架构的工程师需要艰难地学习这个问题。<code>Surprise</code> 移除一个 <code>NVMe</code> 硬盘实体阵列可能花费数秒钟时间，也会偶发性引起 <code>MCE</code> ( <code>machine-check exceptions</code> )。拔出过程如此缓慢以至于驱动可能在完成上一个拔出处理过程前，认为自己在跟一个新插入的硬盘进行交互。由<code>Keith Busch</code> 在 <code>Linux 4.12</code> 版本提交的补丁中一个成果是让 <code>pciehp</code> 为 <code>surprise</code> 移除的设备设置标志位，在 <code>PCI</code> 核中在一些战略性的位置跳过该设备的访问。这足以将移除过程加速到毫秒级别。尤其是当设置标志位后，<code>pci_device_is_present()</code> 返回 <code>false</code>。之前，如果一个设备跟另一个设备快速交换，那么一旦新设备的厂商 <code>ID</code> 可读后对于已移除的设备会错误地返回 <code>True</code>。</p> 
<p>在 <code>Benjamin Herrenschmidt's behest</code> 中，由 <code>Busch</code> 提交的另一个补丁已经安排引入到 <code>4.20</code> 版本，目的是统一 <code>PCI</code> 设备错误状态的标志。错误状态可以用于识别设备是经历一个不可修复错误，但是有机会恢复后的临时性不可访问，还是永久性不可访问。驱动也会直接检查 <code>struct pci_dev</code> 结构体中 <code>error_state</code> 成员变量或者调用 <code>pci_channel_offline()</code> 来确定设备的可访问性。</p> 
<p>然而，<code>Helgass</code> 对标志使用表示了疑虑。其一，标志是异步设置的，因此，在设备被移除到标志被设置之间存在一个延迟。驱动开发者需要谨慎小心：即使根据标志位设备似乎在位，但是设备可能已经不在了。相反，如果设置了标志位，标志提供了明确指示，后来的设备访问是无效的，可以跳过。因此，设置标志位并不会使驱动开发者免于验证来自设备的响应，但是一旦设置标志位，它可以作为一个 <code>cache</code> ，避免了不明确的厂商ID检查。简而言之，问题只是得到了缓解，而没有完美解决。尽管一个完美的解决方案似乎是不可能的，但是我们不能获得用户的互斥锁来阻止用户召回设备，处于性能考量，我们不能在每次设备访问后都对设备在位变化进行检查。<code>Austin Bolen</code> 指出新的 <code>PCIe</code> 扩展 ( <code>root port programmed IO</code> ) 允许失败设备访问的同步异常处理，这样看起来似乎是一个完美的解决方案。但是这个特征在未来一段时间是不可得的。</p> 
<p><code>Helgaas</code> 对标志的第二个担心是标志可能使 <code>surprise</code> 拔插发生的 <code>bug</code> 更加难以发现。当设置标志后，这些 <code>bug</code> 变得更难以发现。<code>For example, a search for the advanced error recovery (AER) capability on device removal caused numerous configuration-space accesses and, before introduction of the flag, was noticeable through a significant slowdown upon surprise removal</code>。但是恰当的方式是：缓存AER能力的位置，而不是使用标志跳过配置访问糊弄问题。</p> 
<br> 
<h2><a id="_395"></a>错误处理整合</h2> 
<p>向线程中断的转变也减轻了整合 <code>pciehp</code> 处理 <code>PCIe</code> 不可修复错误的处理压力：当在热拔插端口或者子端口发生这样错误时，它可能引起一个 <code>link-down</code> 事件。但是有时候错误可能通过软件得以恢复，比如执行 <code>secondary bus reset</code>。在这种情况下，<code>pciehp</code> 通过使设备和驱动解绑，同时使<code>slot</code> 掉电来应对 <code>link-down</code> 事件是不合时宜的。相反，它应该等待以确定错误是否可以恢复，如果可以恢复，那么忽略该 <code>link</code> 事件。为了达到这个目的，<code>Busch</code> 和 <code>Sinan Kaya</code> 当前致力于开发补丁将 <code>pciehp</code> 中的 <code>AER</code> 与下游端口控制服务驱动联系在一起。</p> 
<br> 
<h2><a id="BAR_400"></a>移除BAR</h2> 
<p>为 <code>PCIe</code> 设备分配了内存范围，用于在设备的 <code>BAR</code> 中配置的内存映射 <code>I/O</code>。内存范围通常由 <code>BIOS</code> 预定义，但 <code>Linux</code> 可能会在枚举时移动它们。<code>PCI</code> 设备上游的桥将其地址窗口配置为正确路由以设备 <code>BAR</code> 为目标的事务。</p> 
<p>当设备被热添加时，它们的内存需求可能无法适应其上游网桥的窗口，从而需要重新组织资源：需要移动相邻的 <code>BAR</code> 并调整网桥窗口。 <code>MacOS</code> 于 <code>2013</code> 年获得此功能以改进 <code>Thunderbolt</code> 支持，并将其称为 <code>PCIe pause</code>。驱动程序被告知暂停对受影响设备的 <code>I/O</code>；取消暂停时，<code>BAR</code> 可能已更改，并且驱动程序需要重新配置其设备并根据需要更新内部数据结构。</p> 
<p><code>Sergey Miroshnichenko</code> 最近提交了将 <code>BAR</code> 迁移到 <code>Linux</code> 的初始补丁，获得了积极的反响。这些补丁使用现有的回调在 <code>PCI reset</code> 之前暂停对设备的访问并在之后重新启动访问。<code>drivers</code> 将不得不选择加入 <code>BAR</code> 移除。除了 <code>BAR</code> 之外，<code>MacOS</code> 还支持 <code>PCI bus number</code> 和消息信号中断的重新分配；<code>Miroshnichenko</code> 正在考虑在补丁集的未来修订版中添加它。</p> 
<hr> 
<h2><a id="_410"></a>参考链接</h2> 
<hr class="footnotes-sep"> 
<section class="footnotes"> 
 <ol class="footnotes-list"><li id="fn1" class="footnote-item"><p><a href="https://blog.csdn.net/zdx19880830/article/details/90143656">Linux系统PCIe hotplug的现代化</a> <a href="#fnref1" rel="nofollow" class="footnote-backref">↩︎</a></p> </li><li id="fn2" class="footnote-item"><p><a href="https://lwn.net/Articles/767885/" rel="nofollow">The modernization of PCIe hotplug in Linux</a> <a href="#fnref2" rel="nofollow" class="footnote-backref">↩︎</a></p> </li><li id="fn3" class="footnote-item"><p><a href="https://support.xilinx.com/s/question/0D52E00006iHlZrSAK/zynq-ultrascale-pcie-root-port-lessons-learned?language=en_US" rel="nofollow">Zynq UltraScale+ PCIe Root Port Lessons Learned</a> <a href="#fnref3" rel="nofollow" class="footnote-backref">↩︎</a></p> </li><li id="fn4" class="footnote-item"><p><a href="https://blog.csdn.net/linjiasen/article/details/99288464">32】linux5.0之后 pciehp引入的bug</a> <a href="#fnref4" rel="nofollow" class="footnote-backref">↩︎</a></p> </li><li id="fn5" class="footnote-item"><p><a href="https://blog.csdn.net/yhb1047818384/article/details/99705972">Linux内核笔记之PCIe hotplug介绍及代码分析</a> <a href="#fnref5" rel="nofollow" class="footnote-backref">↩︎</a></p> </li><li id="fn6" class="footnote-item"><p><a href="https://github.com/torvalds/linux/blob/master/drivers/pci/hotplug/pciehp_hpc.c">linux/drivers/pci/hotplug/pciehp_hpc.c</a> <a href="#fnref6" rel="nofollow" class="footnote-backref">↩︎</a> <a href="#fnref6:1" rel="nofollow" class="footnote-backref">↩︎</a></p> </li><li id="fn7" class="footnote-item"><p><a href="https://github.com/torvalds/linux/blob/master/drivers/pci/hotplug/pciehp_ctrl.c">linux/drivers/pci/hotplug/pciehp_ctrl.c</a> <a href="#fnref7" rel="nofollow" class="footnote-backref">↩︎</a></p> </li><li id="fn8" class="footnote-item"><p><a href="https://github.com/torvalds/linux/blob/master/drivers/pci/hotplug/pciehp_core.c">linux/drivers/pci/hotplug/pciehp_core.c</a> <a href="#fnref8" rel="nofollow" class="footnote-backref">↩︎</a></p> </li></ol> 
</section>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/00acb0198ce2cc6c4321a4660cb7e98a/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">Python 工匠 第六章 循环和可迭代对象</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/958732665e2d79fcfe5ccde8b19bf943/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">算法竞赛常用数据结构（JAVA版）（尽可能使用数组来模拟）</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>