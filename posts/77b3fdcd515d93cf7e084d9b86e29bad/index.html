<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>C#系列学习笔记1：.Net和JIT - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="C#系列学习笔记1：.Net和JIT" />
<meta property="og:description" content="C#系列学习笔记1：.Net和JIT .NetJIT .Net .NET是跨语言的一个平台，核心就是.NET Framwork，是.NET程序开发和运行的环境。语言可以是C#，f#，j#，VB.net等等。c#是运行在.Net平台下的一种面向对象的高级编程语言。
.Net框架的组成分为两部分： CLR：公共语言运行时（Common Language Runtime），提供内在管理，代码安全性检测等功能。FCL：.NET框架类库（.NET Framework Class Library）,提供大量应用类库，类库中有很多线程的资源可使用（比如：类，方法，属性），提高开发效率。 CLR的结构： CLS：公共语言规范，获取各种语言转换成统一的语法规范，是.Net跨语言开发的基础。CTS：通用类型系统，将各种语言中的数据类型转换成统一的类型JIT：实时编译器（即时编译器）用于将转换之后的语言编译为二进制语言，交给CPU执行。
CLR一个很重要的特性就是Type安全。CLR在任何时候都知道某个对象的类型。你可以通过GetType方法获得，由于该方法不是虚函数，因此不能被覆盖，也就是说返回的值是永远真实的。 .Net运行的机制流程
各种语言（c#,F#,j#等对应的源程序）-&gt; 经过CLS，CTS第一次编译 -&gt; 统一规范语言（中间语言）MSIL(.EXE,.DLL) -&gt; JIT第二次编译 -&gt; 二进制语言 -&gt; 运行在CPU中
.Net的基础类库BCL
当通过VS创建一个项目后，这个项目就已经引用好了通过.NET下的语言编写好的一些类库。比如ConSole类，System.IO类，这些都是微软帮你写好的，不用你自己去编写，它帮你编写了一个面向.NET的开发语言中使用的基本的功能。这部分类，我们称之为BCL（Base Class Library）基础类库，它们大多都包含在System命名空间下。由微软开发的类库统称为：FCL，Framework Class Library，.NET框架类库，我上述所表达的BCL就是FCL中的一个基础部分，FCL中大部分类都是通过C#来编写的。
基础类库BCL包含：基本数据类型，文件操作，集合，自定义属性，格式设置，安全属性，I/O流，字符串操作，事件日志等的类型
JIT JIT（Just-in-time compilation, JIT）编译器会使用即时编译，对不同架构的机器生成不同的机器码，大部分的代码优化都在这里完成。JIT 只有在运行时才会工作，当生成（Build）项目时，JIT 不会工作。编译器在编译时，会对代码进行检查，对于只调用过一次的代码，不会JIT优化。多次使用的代码（例如for循环)才会进行JIT。
通常，程序有两种运行方式：预先编译（AOT）与动态编译。预先编译的程序在执行前全部被翻译为机器码，而动态编译则是一句一句，边运行边翻译。即时编译则混合了这二者，一句句编译源代码，但是会将翻译过的代码缓存起来以降低性能损耗。
当运行程序时，CLR 先会调用类加载器加载需要的类型，加载完成之后，就创建了类型对象，包括方法表。
当首次调用该类型的 X 方法。由于其没有对应的机器码（除非它预先编译好了，例如Console 类中的方法），CLR 会在调用时遭遇 jmp 指令（目标为 JIT 编译器），将 X 方法的 IL 代码转换为机器码。
JIT 编译过程中，会做运行时的类型验证，将代码和元数据中的定义进行比对，确定代码的类型安全性。
编译完成之后，将机器码存储在缓存中，并将缓存地址放在 jmp 指令的后面，代替之前的 JIT 编译器地址。
以后对该方法的所有调用都不需要再次 JIT 编译， JIT 已将将机器码储存在内存中。当程序结束后，这些机器码就会消失，所以每次程序运行都伴随着即时编译。
不过，这个现象带来的性能损耗仅仅会在方法第一次调用时体现，而大部分程序都会调用方法不止一次。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/77b3fdcd515d93cf7e084d9b86e29bad/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2020-08-24T14:17:50+08:00" />
<meta property="article:modified_time" content="2020-08-24T14:17:50+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">C#系列学习笔记1：.Net和JIT</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p></p> 
<div class="toc"> 
 <h4>C#系列学习笔记1：.Net和JIT</h4> 
 <ul><li><ul><li><ul><li><a href="#Net_2" rel="nofollow">.Net</a></li><li><a href="#JIT_23" rel="nofollow">JIT</a></li></ul> 
  </li></ul> 
 </li></ul> 
</div> 
<p></p> 
<h4><a id="Net_2"></a>.Net</h4> 
<p>.NET是跨语言的一个平台，核心就是.NET Framwork，是.NET程序开发和运行的环境。语言可以是C#，f#，j#，VB.net等等。c#是运行在.Net平台下的一种面向对象的高级编程语言。</p> 
<ol><li>.Net框架的组成分为两部分：</li></ol> 
<ul><li>CLR：公共语言运行时（Common Language Runtime），提供内在管理，代码安全性检测等功能。</li><li>FCL：.NET框架类库（.NET Framework Class Library）,提供大量应用类库，类库中有很多线程的资源可使用（比如：类，方法，属性），提高开发效率。</li></ul> 
<ol start="2"><li>CLR的结构：</li></ol> 
<ul><li>CLS：公共语言规范，获取各种语言转换成统一的语法规范，是.Net跨语言开发的基础。</li><li>CTS：通用类型系统，将各种语言中的数据类型转换成统一的类型</li><li>JIT：实时编译器（即时编译器）用于将转换之后的语言编译为二进制语言，交给CPU执行。<br> CLR一个很重要的特性就是Type安全。CLR在任何时候都知道某个对象的类型。你可以通过<code>GetType</code>方法获得，由于该方法不是虚函数，因此不能被覆盖，也就是说返回的值是永远真实的。</li></ul> 
<ol start="3"><li> <p>.Net运行的机制流程<br> 各种语言（c#,F#,j#等对应的源程序）-&gt; 经过CLS，CTS第一次编译 -&gt; 统一规范语言（中间语言）MSIL(.EXE,.DLL) -&gt; JIT第二次编译 -&gt; 二进制语言 -&gt; 运行在CPU中</p> </li><li> <p>.Net的基础类库BCL<br> 当通过VS创建一个项目后，这个项目就已经引用好了通过.NET下的语言编写好的一些类库。比如ConSole类，System.IO类，这些都是微软帮你写好的，不用你自己去编写，它帮你编写了一个面向.NET的开发语言中使用的基本的功能。这部分类，我们称之为BCL（Base Class Library）基础类库，它们大多都包含在System命名空间下。由微软开发的类库统称为：FCL，Framework Class Library，.NET框架类库，我上述所表达的BCL就是FCL中的一个基础部分，FCL中大部分类都是通过C#来编写的。</p> </li></ol> 
<p>基础类库BCL包含：基本数据类型，文件操作，集合，自定义属性，格式设置，安全属性，I/O流，字符串操作，事件日志等的类型</p> 
<h4><a id="JIT_23"></a>JIT</h4> 
<p>JIT（Just-in-time compilation, JIT）编译器会使用即时编译，对不同架构的机器生成不同的机器码，大部分的代码优化都在这里完成。JIT 只有在运行时才会工作，当生成（Build）项目时，JIT 不会工作。<strong>编译器在编译时，会对代码进行检查，对于只调用过一次的代码，不会JIT优化。多次使用的代码（例如for循环)才会进行JIT。</strong></p> 
<p>通常，程序有两种运行方式：预先编译（AOT）与动态编译。预先编译的程序在执行前全部被翻译为机器码，而动态编译则是一句一句，边运行边翻译。即时编译则混合了这二者，一句句编译源代码，但是会将翻译过的代码缓存起来以降低性能损耗。</p> 
<p>当运行程序时，CLR 先会调用类加载器加载需要的类型，加载完成之后，就创建了类型对象，包括方法表。</p> 
<p><img src="https://images2.imgbox.com/39/47/zwECHdul_o.gif" alt="img"></p> 
<p>当首次调用该类型的 X 方法。由于其没有对应的机器码（除非它预先编译好了，例如Console 类中的方法），CLR 会在调用时遭遇 jmp 指令（目标为 JIT 编译器），将 X 方法的 IL 代码转换为机器码。</p> 
<p>JIT 编译过程中，会做运行时的<strong>类型验证</strong>，将代码和元数据中的定义进行比对，确定代码的类型安全性。</p> 
<p>编译完成之后，将机器码存储在缓存中，并将缓存地址放在 jmp 指令的后面，代替之前的 JIT 编译器地址。</p> 
<p><img src="https://images2.imgbox.com/35/24/N6yolSD0_o.gif" alt="img"></p> 
<p>以后对该方法的所有调用都不需要再次 JIT 编译， JIT 已将将机器码储存在内存中。当程序结束后，这些机器码就会消失，所以每次程序运行都伴随着即时编译。</p> 
<p>不过，这个现象带来的性能损耗仅仅会在方法第一次调用时体现，而大部分程序都会调用方法不止一次。</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/9f7a61d526a0ca26fdb3e2f5eae5ee22/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">用R语言生成均匀设计</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/3fd340e17dcb17823d4fb7d1507737d4/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">linux的绝对路径和相对路径</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>