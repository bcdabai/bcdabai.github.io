<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>[C&#43;&#43;] 智能指针 - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="[C&#43;&#43;] 智能指针" />
<meta property="og:description" content="目录 1. 为什么需要智能指针?2. RAII (资源获取及初始化)2.1 RAII方式的原理2.2 重大问题2.3 智能指针原理 3. C&#43;&#43;98 auto_ptr(不要用)3.1 解决浅拷贝的方式一3.2 解决浅拷贝的方式二 4. C&#43;&#43;11 unique_ptr4.1 管理的资源多样如何释放4.2 模拟实现 5. C&#43;&#43;11 shared_ptr5.1 如何解决浅拷贝5.2 实现原理5.3 多线程使用时的问题5.4 缺陷- 循环引用5.5 weak_ptr5.5 代码实现 1. 为什么需要智能指针? 我们在使用指针时一般都需要向内存申请一块内存空间进行使用，但是如果忘记对该块空间进行释放，就造成了内存泄漏。
并且如果在申请内存的使用时间，程序中有异常处理，并且抛出了异常，那么这个过程中没有进行空间的释放，同样造成了内存泄漏。
内存泄漏的危害：
长期运行的程序出现内存泄漏，影响很大，如操作系统、后台服务等等，出现内存泄漏会导致响应越来越慢，最终卡死
所以为了避免上述情况的出现，引入了只能指针，使用智能指针进行资源的管理，就可以避免上述问题。
2. RAII (资源获取及初始化) RAII（Resource Acquisition Is Initialization）是一种利用对象生命周期来控制程序资源（如内存、文件句柄、网络连接、互斥量等等）的简单技术。
巧妙利用编译器会自动调用构造函数以及析构函数的特性，来完成资源的自动释放。实际就是定义一个指针类，使用其构造函数与析构函数进行资源的管理。
构造函数: 在对象构造时获取资源，控制对资源的访问使之在对象的生命周期内始终保持有效。
析构函数: 释放资源
优点
不需要显式地释放资源采用这种方式，对象所需的资源在其生命周期内始终保持有效 2.1 RAII方式的原理 注意: 只能指针的类中，构造函数中不能申请空间，而是由用户在外部自己申请空间，传递到只能指针的类中去管理该资源。
智能指针只是将资源管理起来，找一个合适的时机去释放。
// 使用RAII思想设计的SmartPtr类 template&lt;class T&gt; class SmartPtr { public: SmartPtr(T* ptr = nullptr) : _ptr(ptr) {} ~SmartPtr(){ if(_ptr) delete _ptr; } // 让该类对象具有指针类似的操作就可以了 T&amp; operator*(){ return *ptr; } // -&gt; 只能指针指向对象或者结构体的这些场景中 T* operator-&gt;(){ return ptr; } private: T* _ptr; // 采用类将指针管理起来 }; void MergeSort(int* a, int n) { int* tmp = (int*)malloc(sizeof(int)*n); // 将tmp指针委托给了sp对象，给tmp指针找了一个可怕的女朋友！天天管着你，直到你go die^^ SmartPtr&lt;int&gt; sp(tmp); // _MergeSort(a, 0, n - 1, tmp); // 这里假设处理了一些其他逻辑 vector&lt;int&gt; v(1000000000, 10); // ." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/053bb805d051ceeca3e3653597d77af4/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2021-09-02T20:52:59+08:00" />
<meta property="article:modified_time" content="2021-09-02T20:52:59+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">[C&#43;&#43;] 智能指针</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p></p> 
<div class="toc"> 
 <h4>目录</h4> 
 <ul><li><a href="#1__1" rel="nofollow">1. 为什么需要智能指针?</a></li><li><a href="#2_RAII__12" rel="nofollow">2. RAII (资源获取及初始化)</a></li><li><ul><li><a href="#21_RAII_24" rel="nofollow">2.1 RAII方式的原理</a></li><li><a href="#22__66" rel="nofollow">2.2 重大问题</a></li><li><a href="#23__71" rel="nofollow">2.3 智能指针原理</a></li></ul> 
  </li><li><a href="#3_C98_auto_ptr_78" rel="nofollow">3. C++98 auto_ptr(不要用)</a></li><li><ul><li><a href="#31__81" rel="nofollow">3.1 解决浅拷贝的方式一</a></li><li><a href="#32__118" rel="nofollow">3.2 解决浅拷贝的方式二</a></li></ul> 
  </li><li><a href="#4_C11_unique_ptr_124" rel="nofollow">4. C++11 unique_ptr</a></li><li><ul><li><a href="#41__139" rel="nofollow">4.1 管理的资源多样如何释放</a></li><li><a href="#42__145" rel="nofollow">4.2 模拟实现</a></li></ul> 
  </li><li><a href="#5_C11_shared_ptr_241" rel="nofollow">5. C++11 shared_ptr</a></li><li><ul><li><a href="#51__244" rel="nofollow">5.1 如何解决浅拷贝</a></li><li><a href="#52__248" rel="nofollow">5.2 实现原理</a></li><li><a href="#53__258" rel="nofollow">5.3 多线程使用时的问题</a></li><li><a href="#54___270" rel="nofollow">5.4 缺陷- 循环引用</a></li><li><a href="#55_weak_ptr_318" rel="nofollow">5.5 weak_ptr</a></li><li><a href="#55__330" rel="nofollow">5.5 代码实现</a></li></ul> 
 </li></ul> 
</div> 
<p></p> 
<h2><a id="1__1"></a>1. 为什么需要智能指针?</h2> 
<p>  我们在使用指针时一般都需要向内存申请一块内存空间进行使用，但是如果忘记对该块空间进行释放，就造成了<strong>内存泄漏</strong>。<br>   并且如果在申请内存的使用时间，程序中有异常处理，并且抛出了异常，那么这个过程中没有进行空间的释放，同样造成了内存泄漏。</p> 
<p><strong>内存泄漏的危害</strong>：</p> 
<blockquote> 
 <p>长期运行的程序出现内存泄漏，影响很大，如操作系统、后台服务等等，出现内存泄漏会导致响应越来越慢，最终卡死</p> 
</blockquote> 
<p>  所以为了避免上述情况的出现，引入了只能指针，使用智能指针进行资源的管理，就可以避免上述问题。</p> 
<h2><a id="2_RAII__12"></a>2. RAII (资源获取及初始化)</h2> 
<p>  RAII（Resource Acquisition Is Initialization）是一种利用<strong>对象生命周期来控制程序资源</strong>（如内存、文件句柄、网络连接、互斥量等等）的简单技术。</p> 
<p>  巧妙利用编译器会自动调用<strong>构造函数以及析构函数</strong>的特性，来完成资源的自动释放。实际就是定义一个指针类，使用其构造函数与析构函数进行资源的管理。</p> 
<blockquote> 
 <p><strong>构造函数</strong>: 在对象构造时获取资源，控制对资源的访问使之在对象的生命周期内始终保持有效。<br> <strong>析构函数</strong>: 释放资源</p> 
</blockquote> 
<p><strong>优点</strong></p> 
<blockquote> 
 <ul><li>不需要显式地释放资源</li><li>采用这种方式，对象所需的资源在其生命周期内始终保持有效</li></ul> 
</blockquote> 
<h3><a id="21_RAII_24"></a>2.1 RAII方式的原理</h3> 
<p><strong>注意</strong>: 只能指针的类中，构造函数中不能申请空间，而是由<strong>用户在外部自己申请空间</strong>，传递到只能指针的类中去管理该资源。<br>   智能指针只是将资源管理起来，找一个合适的时机去释放。</p> 
<pre><code class="prism language-c"><span class="token comment">// 使用RAII思想设计的SmartPtr类</span>
template<span class="token operator">&lt;</span>class T<span class="token operator">&gt;</span>
class SmartPtr <span class="token punctuation">{<!-- --></span>
public<span class="token operator">:</span>
	<span class="token function">SmartPtr</span><span class="token punctuation">(</span>T<span class="token operator">*</span> ptr <span class="token operator">=</span> nullptr<span class="token punctuation">)</span>
		<span class="token operator">:</span> <span class="token function">_ptr</span><span class="token punctuation">(</span>ptr<span class="token punctuation">)</span>
	<span class="token punctuation">{<!-- --></span><span class="token punctuation">}</span>
	<span class="token operator">~</span><span class="token function">SmartPtr</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
		<span class="token keyword">if</span><span class="token punctuation">(</span>_ptr<span class="token punctuation">)</span>
			delete _ptr<span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
	<span class="token comment">// 让该类对象具有指针类似的操作就可以了</span>
	T<span class="token operator">&amp;</span> operator<span class="token operator">*</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
		<span class="token keyword">return</span> <span class="token operator">*</span>ptr<span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
	<span class="token comment">//  -&gt; 只能指针指向对象或者结构体的这些场景中</span>
	T<span class="token operator">*</span> operator<span class="token operator">-&gt;</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
		<span class="token keyword">return</span> ptr<span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
private<span class="token operator">:</span>
	T<span class="token operator">*</span> _ptr<span class="token punctuation">;</span> <span class="token comment">// 采用类将指针管理起来</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">void</span> <span class="token function">MergeSort</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token operator">*</span> a<span class="token punctuation">,</span> <span class="token keyword">int</span> n<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token keyword">int</span><span class="token operator">*</span> tmp <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">int</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token function">malloc</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token operator">*</span>n<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token comment">// 将tmp指针委托给了sp对象，给tmp指针找了一个可怕的女朋友！天天管着你，直到你go die^^</span>
	SmartPtr<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span> <span class="token function">sp</span><span class="token punctuation">(</span>tmp<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token comment">// _MergeSort(a, 0, n - 1, tmp);</span>
	
	<span class="token comment">// 这里假设处理了一些其他逻辑</span>
	vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span> <span class="token function">v</span><span class="token punctuation">(</span><span class="token number">1000000000</span><span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token comment">// ...</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>  如上只是实现了资源的管理，但是该类不<strong>能使用指针独有的操作</strong>，所以需要重载指针的一些操作符。</p> 
<h3><a id="22__66"></a>2.2 重大问题</h3> 
<p>  上述代码中没有提供拷贝构造函数，那么如果进行拷贝时，会调用编译器提供的默认拷贝构造函数。<strong>智能指针不能申请资源，只能替用户管理资源，因此不能使用深拷贝来代替浅拷贝</strong></p> 
<p><strong>如何解决:</strong> C++标准库中提供了，最优解，下面会介绍到。</p> 
<h3><a id="23__71"></a>2.3 智能指针原理</h3> 
<p>所以智能指针的原理: <code>RAII + operator*() / operator-&gt;() + 解决浅拷贝问题</code></p> 
<blockquote> 
 <p><strong>RAII</strong>: 能够保证资源可以被自动释放<br> <em><em>operator</em>()/operator-&gt;()</em>*: 可以保证对象能够按照指针的方式来运行<br> <strong>解决浅拷贝的方式</strong>：可能保证资源不被释放多次而引起代码崩溃的问题</p> 
</blockquote> 
<h2><a id="3_C98_auto_ptr_78"></a>3. C++98 auto_ptr(不要用)</h2> 
<p><code>RAII + operator*() / operator-&gt;() + 解决浅拷贝问题</code></p> 
<h3><a id="31__81"></a>3.1 解决浅拷贝的方式一</h3> 
<p>auto_ptr: 解决浅拷贝使用的是<strong>资源转移</strong></p> 
<blockquote> 
 <p>当发生拷贝或赋值时，将被拷贝对象中的资源转移给新对象，然后让被拷贝对象与资源断开联系</p> 
</blockquote> 
<p><strong>但是同时只能有一个指针被使用，另外一个指针就没有指向了</strong></p> 
<p><img src="https://images2.imgbox.com/3b/bb/F51APo5n_o.png" alt="在这里插入图片描述"></p> 
<pre><code class="prism language-c"><span class="token comment">// 解决浅拷贝方式：资源转移</span>
<span class="token comment">// auto_ptr&lt;int&gt;  ap2(ap1)</span>
<span class="token function">auto_ptr</span><span class="token punctuation">(</span>auto_ptr<span class="token operator">&lt;</span>T<span class="token operator">&gt;</span><span class="token operator">&amp;</span> ap<span class="token punctuation">)</span>
	<span class="token operator">:</span> <span class="token function">_ptr</span><span class="token punctuation">(</span>ap<span class="token punctuation">.</span>_ptr<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	ap<span class="token punctuation">.</span>_ptr <span class="token operator">=</span> nullptr<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment">// ap1 = ap2;</span>
auto_ptr<span class="token operator">&lt;</span>T<span class="token operator">&gt;</span><span class="token operator">&amp;</span> operator<span class="token operator">=</span><span class="token punctuation">(</span>auto_ptr<span class="token operator">&lt;</span>T<span class="token operator">&gt;</span><span class="token operator">&amp;</span> ap<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token keyword">if</span> <span class="token punctuation">(</span>this <span class="token operator">!=</span> <span class="token operator">&amp;</span>ap<span class="token punctuation">)</span>
	<span class="token punctuation">{<!-- --></span>
		<span class="token comment">// 此处需要将ap中的资源转移给this</span>
		<span class="token comment">// 但是不能直接转移，因为this可能已经管理资源了，否则就会造成资源泄漏</span>
		<span class="token keyword">if</span> <span class="token punctuation">(</span>_ptr<span class="token punctuation">)</span>
		<span class="token punctuation">{<!-- --></span>
			delete _ptr<span class="token punctuation">;</span>
		<span class="token punctuation">}</span>

		<span class="token comment">// ap就可以将其资源转移给this</span>
		_ptr <span class="token operator">=</span> ap<span class="token punctuation">.</span>_ptr<span class="token punctuation">;</span>
		ap<span class="token punctuation">.</span>_ptr <span class="token operator">=</span> nullptr<span class="token punctuation">;</span>   <span class="token comment">// 让ap与之前管理的资源断开联系，因为ap中的资源已经转移给this了</span>
	<span class="token punctuation">}</span>

	<span class="token keyword">return</span> <span class="token operator">*</span>this<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<h3><a id="32__118"></a>3.2 解决浅拷贝的方式二</h3> 
<p><strong>资源管理权限转移</strong></p> 
<blockquote> 
 <p>如果发生了拷贝或者赋值，不断开原来指针与资源块的联系，而是将资源的释放权限交给新指针，<strong>但是会造成野指针问题</strong>，因为新指针一旦析构，就会释放资源，而老指针还指向那块空间</p> 
</blockquote> 
<p><img src="https://images2.imgbox.com/4b/aa/dRxnFjQT_o.png" alt="在这里插入图片描述"></p> 
<h2><a id="4_C11_unique_ptr_124"></a>4. C++11 unique_ptr</h2> 
<p><code>RAII + operator*() / operator-&gt;() + 解决浅拷贝问题</code></p> 
<p>浅拷贝解决方式: <strong>资源独占</strong></p> 
<blockquote> 
 <p>禁止拷贝，一份资源只能让一个对象管理，对象间不能共享资源。</p> 
</blockquote> 
<p><strong>使用场景</strong>: 只能应用于资源被一个对象管理，并且资源不会共享的场景中。</p> 
<p><strong>如何实现</strong><br>   让编译器不生成默认的拷贝构造以及赋值运算符的重载。</p> 
<p><strong>C++11中</strong>: <code>delete关键字</code>，可以用其修饰默认的成员函数，表明编译器不会生成修饰的成员函数。<br> <strong>C++98中</strong>: 将拷贝构造函数以及赋值运算符重载只声明不定义，并且把访问权限设置为私有。</p> 
<blockquote> 
 <p>只声明不定义，没有将权限设置为private，仍然可以在类外进行定义。</p> 
</blockquote> 
<h3><a id="41__139"></a>4.1 管理的资源多样如何释放</h3> 
<p>  管理的资源可能是从堆上申请的空间，也可能是文件指针等等</p> 
<p>  <strong>定制删除器</strong>: 此处的释放方式不能写死，应该按照资源的不同类型对应不同的释放方式。</p> 
<blockquote> 
 <p>定义只能指针类时，模板参数加上资源释放的方式，用户自定义资源释放的类，自己指定释放资源的方法。在初始化智能指针时，就该把资源的释放方式确定下来，在初始化模板参数时就传入释放资源的类。</p> 
</blockquote> 
<h3><a id="42__145"></a>4.2 模拟实现</h3> 
<pre><code class="prism language-c"><span class="token comment">// 负责释放new资源</span>
template<span class="token operator">&lt;</span>class T<span class="token operator">&gt;</span>
class DFDef
<span class="token punctuation">{<!-- --></span>
public<span class="token operator">:</span>
	<span class="token keyword">void</span> <span class="token function">operator</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">(</span>T<span class="token operator">*</span><span class="token operator">&amp;</span> ptr<span class="token punctuation">)</span>
	<span class="token punctuation">{<!-- --></span>
		<span class="token keyword">if</span> <span class="token punctuation">(</span>ptr<span class="token punctuation">)</span>
		<span class="token punctuation">{<!-- --></span>
			delete ptr<span class="token punctuation">;</span>
			ptr <span class="token operator">=</span> nullptr<span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
	<span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token comment">// 负责：malloc的资源的释放</span>
template<span class="token operator">&lt;</span>class T<span class="token operator">&gt;</span>
class Free
<span class="token punctuation">{<!-- --></span>
public<span class="token operator">:</span>
	<span class="token keyword">void</span> <span class="token function">operator</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">(</span>T<span class="token operator">*</span><span class="token operator">&amp;</span> ptr<span class="token punctuation">)</span>
	<span class="token punctuation">{<!-- --></span>
		<span class="token keyword">if</span> <span class="token punctuation">(</span>ptr<span class="token punctuation">)</span>
		<span class="token punctuation">{<!-- --></span>
			<span class="token function">free</span><span class="token punctuation">(</span>ptr<span class="token punctuation">)</span><span class="token punctuation">;</span>
			ptr <span class="token operator">=</span> nullptr<span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
	<span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token comment">// 关闭文件指针</span>
class FClose
<span class="token punctuation">{<!-- --></span>
public<span class="token operator">:</span>
	<span class="token keyword">void</span> <span class="token function">operator</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">(</span>FILE<span class="token operator">*</span> <span class="token operator">&amp;</span> ptr<span class="token punctuation">)</span>
	<span class="token punctuation">{<!-- --></span>
		<span class="token keyword">if</span> <span class="token punctuation">(</span>ptr<span class="token punctuation">)</span>
		<span class="token punctuation">{<!-- --></span>
			<span class="token function">fclose</span><span class="token punctuation">(</span>ptr<span class="token punctuation">)</span><span class="token punctuation">;</span>
			ptr <span class="token operator">=</span> nullptr<span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
	<span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>


namespace test
<span class="token punctuation">{<!-- --></span>
	<span class="token comment">// T: 资源中所放数据的类型</span>
	<span class="token comment">// DF: 资源的释放方式</span>
	<span class="token comment">// 定制删除器</span>
	template<span class="token operator">&lt;</span>class T<span class="token punctuation">,</span> class DF <span class="token operator">=</span> DFDef<span class="token operator">&lt;</span>T<span class="token operator">&gt;&gt;</span>
	class unique_ptr
	<span class="token punctuation">{<!-- --></span>
	public<span class="token operator">:</span>
		<span class="token comment">/</span>
		<span class="token comment">// RAII</span>
		<span class="token function">unique_ptr</span><span class="token punctuation">(</span>T<span class="token operator">*</span> ptr <span class="token operator">=</span> nullptr<span class="token punctuation">)</span>
			<span class="token operator">:</span> <span class="token function">_ptr</span><span class="token punctuation">(</span>ptr<span class="token punctuation">)</span>
		<span class="token punctuation">{<!-- --></span><span class="token punctuation">}</span>

		<span class="token operator">~</span><span class="token function">unique_ptr</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
		<span class="token punctuation">{<!-- --></span>
			<span class="token keyword">if</span> <span class="token punctuation">(</span>_ptr<span class="token punctuation">)</span>
			<span class="token punctuation">{<!-- --></span>
				<span class="token comment">// 问题：_ptr管理的资源：可能是从堆上申请的内存空间、文件指针、malloc空间...</span>
				<span class="token comment">// delete _ptr; // 注意：此处的释放资源的方式不能写死了，应该按照资源类型不同找对应的方式释放</span>
				<span class="token comment">// malloc---&gt;free</span>
				<span class="token comment">// new----&gt;delete</span>
				<span class="token comment">// fopen---&gt;fclose关闭</span>
				DF df<span class="token punctuation">;</span>
				<span class="token function">df</span><span class="token punctuation">(</span>_ptr<span class="token punctuation">)</span><span class="token punctuation">;</span>
			<span class="token punctuation">}</span>
		<span class="token punctuation">}</span>
		<span class="token comment">// C++11: 可以让编译器不生成默认的拷贝构造以及赋值运算符重载---delete</span>
		<span class="token comment">// 在C++11当中，delete关键字的功能扩展：释放new申请的空间  用其修饰默认成员函数，表明：编译器不会生成了</span>
		 <span class="token function">unique_ptr</span><span class="token punctuation">(</span><span class="token keyword">const</span> unique_ptr<span class="token operator">&lt;</span>T<span class="token punctuation">,</span>DF<span class="token operator">&gt;</span><span class="token operator">&amp;</span><span class="token punctuation">)</span> <span class="token operator">=</span> delete<span class="token punctuation">;</span>  <span class="token comment">// 表明：编译器不会生成默认的拷贝构造函数</span>
		 unique_ptr<span class="token operator">&lt;</span>T<span class="token punctuation">,</span>DF<span class="token operator">&gt;</span><span class="token operator">&amp;</span> operator<span class="token operator">=</span><span class="token punctuation">(</span><span class="token keyword">const</span> unique_ptr<span class="token operator">&lt;</span>T<span class="token punctuation">,</span>DF<span class="token operator">&gt;</span><span class="token operator">&amp;</span><span class="token punctuation">)</span> <span class="token operator">=</span> delete<span class="token punctuation">;</span><span class="token comment">// 表明：编译器不会生成默认的赋值运算符重载</span>

	private<span class="token operator">:</span>
		<span class="token function">unique_ptr</span><span class="token punctuation">(</span><span class="token keyword">const</span> unique_ptr<span class="token operator">&lt;</span>T<span class="token punctuation">,</span>DF<span class="token operator">&gt;</span><span class="token operator">&amp;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		unique_ptr<span class="token operator">&lt;</span>T<span class="token punctuation">,</span>DF<span class="token operator">&gt;</span><span class="token operator">&amp;</span> operator<span class="token operator">=</span><span class="token punctuation">(</span><span class="token keyword">const</span> unique_ptr<span class="token operator">&lt;</span>T<span class="token punctuation">,</span>DF<span class="token operator">&gt;</span><span class="token operator">&amp;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

	private<span class="token operator">:</span>
		T<span class="token operator">*</span> _ptr<span class="token punctuation">;</span>
	<span class="token punctuation">}</span><span class="token punctuation">;</span>

	<span class="token comment">// 用户在外部可以对方法进行定义---在unique_ptr的类中如果将该权限设置为private的</span>
	<span class="token comment">//template&lt;class T&gt;</span>
	<span class="token comment">//unique_ptr&lt;T&gt;::unique_ptr(const unique_ptr&lt;T&gt;&amp; up)</span>
	<span class="token comment">//{}</span>
<span class="token punctuation">}</span>
</code></pre> 
<h2><a id="5_C11_shared_ptr_241"></a>5. C++11 shared_ptr</h2> 
<p><strong>多个对象之间可以共享资源</strong></p> 
<h3><a id="51__244"></a>5.1 如何解决浅拷贝</h3> 
<p>  <strong>采用引用计数的方式解决浅拷贝</strong></p> 
<blockquote> 
 <p>引用计数: 实际是一个整型的空间，记录着资源的对象的个数。释放资源时，判断有没有其它对象在使用资源，没有的话就释放掉资源。</p> 
</blockquote> 
<h3><a id="52__248"></a>5.2 实现原理</h3> 
<p><strong>拷贝时:</strong></p> 
<blockquote> 
 <p>新对象要与之前的对象共享所有资源，并且计数器进行++</p> 
</blockquote> 
<p><strong>释放时:</strong></p> 
<blockquote> 
 <p>1.先检测资源是否还存在<br> 2.存在的话，先对计数器–，检测计数器当前是否为0</p> 
 <ul><li>=0: 当前对象是最后使用该资源的对象，需要将资源以及计数器进行释放。</li><li>!=0: 还有其他对象在使用资源，当前对象不需要释放，如果释放了就会造成其它对象变成野指针。</li></ul> 
</blockquote> 
<h3><a id="53__258"></a>5.3 多线程使用时的问题</h3> 
<p>  上述操作在单线程下不会出现问题，但是在多线程中有多个执行流。<br>   多个线程共享一份资源，多个线程在结束时需要将其管理的资源释放掉，多个线程可能会同时释放同一份空间，计数器的操作不是原子性的，所以多个线程判断当前资源都还有人在使用，导致资源没有释放，而引起内存泄漏。</p> 
<p>   智能指针对象中引用计数是多个智能指针对象共享的，两个线程中智能指针的引用计数同时++或–，这个操作不是原子的，引用计数原来是1，++了两次，可能还是2.这样引用计数就错乱了。会导致资源未释放或者程序崩溃的问题。所以只能指针中引用计数++、–是需要加锁的，也就是说引用计数的操作是线程安全的</p> 
<p><strong>解决方案</strong></p> 
<blockquote> 
 <p>1.加锁，保证计数器的操作是安全的<br> 2.把计数器改为原子操作</p> 
</blockquote> 
<p><strong>C++11中的share_ptr，自身是线程安全的，标准库中是按照原子类型变量实现的</strong> <code>atomic_int</code></p> 
<h3><a id="54___270"></a>5.4 缺陷- 循环引用</h3> 
<pre><code class="prism language-c"><span class="token keyword">struct</span> <span class="token class-name">ListNode</span>
<span class="token punctuation">{<!-- --></span>
	shared_ptr<span class="token operator">&lt;</span>ListNode<span class="token operator">&gt;</span> next<span class="token punctuation">;</span>
	shared_ptr<span class="token operator">&lt;</span>ListNode<span class="token operator">&gt;</span> prev<span class="token punctuation">;</span>
	<span class="token comment">//weak_ptr&lt;ListNode&gt; next;</span>
	<span class="token comment">//weak_ptr&lt;ListNode&gt; prev;</span>
	<span class="token keyword">int</span> data<span class="token punctuation">;</span>

	<span class="token function">ListNode</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">)</span>
		<span class="token comment">//: data(x)</span>
		<span class="token operator">:</span> <span class="token function">next</span><span class="token punctuation">(</span>nullptr<span class="token punctuation">)</span>
		<span class="token punctuation">,</span> <span class="token function">prev</span><span class="token punctuation">(</span>nullptr<span class="token punctuation">)</span>
		<span class="token punctuation">,</span> <span class="token function">data</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span>
	<span class="token punctuation">{<!-- --></span>
		cout <span class="token operator">&lt;&lt;</span> <span class="token string">"ListNode(int):"</span> <span class="token operator">&lt;&lt;</span> this <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
	<span class="token punctuation">}</span>

	<span class="token operator">~</span><span class="token function">ListNode</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
	<span class="token punctuation">{<!-- --></span>
		cout <span class="token operator">&lt;&lt;</span> <span class="token string">"~ListNode():"</span> <span class="token operator">&lt;&lt;</span> this <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">void</span> <span class="token function">TestLoopRef</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	shared_ptr<span class="token operator">&lt;</span>ListNode<span class="token operator">&gt;</span> <span class="token function">sp1</span><span class="token punctuation">(</span>new <span class="token function">ListNode</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	shared_ptr<span class="token operator">&lt;</span>ListNode<span class="token operator">&gt;</span> <span class="token function">sp2</span><span class="token punctuation">(</span>new <span class="token function">ListNode</span><span class="token punctuation">(</span><span class="token number">20</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

	cout <span class="token operator">&lt;&lt;</span> sp1<span class="token punctuation">.</span><span class="token function">use_count</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>    <span class="token comment">// 1</span>
	cout <span class="token operator">&lt;&lt;</span> sp2<span class="token punctuation">.</span><span class="token function">use_count</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>    <span class="token comment">// 1</span>

	sp1<span class="token operator">-&gt;</span>next <span class="token operator">=</span> sp2<span class="token punctuation">;</span>
	sp2<span class="token operator">-&gt;</span>prev <span class="token operator">=</span> sp1<span class="token punctuation">;</span>

	cout <span class="token operator">&lt;&lt;</span> sp1<span class="token punctuation">.</span><span class="token function">use_count</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>    <span class="token comment">// 2</span>
	cout <span class="token operator">&lt;&lt;</span> sp2<span class="token punctuation">.</span><span class="token function">use_count</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>    <span class="token comment">// 2</span>
<span class="token punctuation">}</span>

</code></pre> 
<p><img src="https://images2.imgbox.com/e4/1f/MQGvt3IM_o.png" alt="在这里插入图片描述"></p> 
<p>上述代码导致的后果就是<strong>内存泄漏</strong>，释放资源时没有调用析构函数。</p> 
<p><strong>什么是循环引用</strong></p> 
<blockquote> 
 <p>函数中sp1 ，sp2之间互相引用，两个资源的引用计数为2，当要跳出函数时，智能指针sp1 ，sp2析构时两个资源引用计数会减一，但是两者引用计数还是为1，导致跳出函数时资源没有被释放（析构函数没有被调用），如果把其中一个改为weak_ptr就可以了，我们把类种里面的shared_ptr 指针; 改为weak_ptr 指针; 运行结果如下，这样的话，资源B的引用开始就只有1，当pb析构时，B的计数变为0，B得到释放，B释放的同时也会使A的计数减一，同时pa析构时使A的计数减一，那么A的计数为0，A得到释放</p> 
</blockquote> 
<h3><a id="55_weak_ptr_318"></a>5.5 weak_ptr</h3> 
<blockquote> 
 <p><strong>weak_ptr</strong>的作用，配合shared_ptr解决循环引用问题。<strong>weak_ptr不能独立管理资源</strong><br> 不控制对象生命周期，指向一个<code>shared_ptr</code>管理的对象，只是提供了对管理对象的一个访问手段。weak_ptr设计的目的为了配合shared_ptr解决循环引用，导致无法释放内存空间的问题。weak_ptr的构造和析构不会造成引用计数的增加或者减少</p> 
</blockquote> 
<p><strong>原理</strong></p> 
<blockquote> 
 <p>实际上shared_ptr维护了两块计数器，一份用来记录shared_ptr的使用次数，一份用来记录weakptr的使用次数。weak_ptr指向资源，shared_ptr的use计数器不懂，weak计数器+1</p> 
</blockquote> 
<p><strong>销毁时</strong></p> 
<blockquote> 
 <p>当一个资源被shared_ptr类型的对象共享时，给use+1<br> 当一个资源被weak_ptr类型的对象时，给weak+1<br> 销毁时: 先给use-1，确认资源能够释放，再给weak-1，确认资源能释放</p> 
</blockquote> 
<h3><a id="55__330"></a>5.5 代码实现</h3> 
<pre><code class="prism language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;mutex&gt;</span></span>

namespace test
<span class="token punctuation">{<!-- --></span>
	<span class="token comment">// shared_ptr: 自身才是安全的---加锁：为了保证shared_ptr自身的安全性</span>
	template<span class="token operator">&lt;</span>class T<span class="token punctuation">,</span> class DF <span class="token operator">=</span> DFDef<span class="token operator">&lt;</span>T<span class="token operator">&gt;&gt;</span>
	class shared_ptr
	<span class="token punctuation">{<!-- --></span>
	public<span class="token operator">:</span>
		<span class="token comment">//</span>
		<span class="token comment">// RAII</span>
		<span class="token function">shared_ptr</span><span class="token punctuation">(</span>T<span class="token operator">*</span> ptr <span class="token operator">=</span> nullptr<span class="token punctuation">)</span>
			<span class="token operator">:</span> <span class="token function">_ptr</span><span class="token punctuation">(</span>ptr<span class="token punctuation">)</span>
			<span class="token punctuation">,</span> <span class="token function">_pCount</span><span class="token punctuation">(</span>nullptr<span class="token punctuation">)</span>
			<span class="token punctuation">,</span> <span class="token function">_pMutex</span><span class="token punctuation">(</span>new mutex<span class="token punctuation">)</span>
		<span class="token punctuation">{<!-- --></span>
			<span class="token keyword">if</span> <span class="token punctuation">(</span>_ptr<span class="token punctuation">)</span>
			<span class="token punctuation">{<!-- --></span>
				<span class="token comment">// 此时只有当前刚刚创建好的1个对象在使用该份资源</span>
				_pCount <span class="token operator">=</span> new <span class="token keyword">int</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
			<span class="token punctuation">}</span>
		<span class="token punctuation">}</span>

		<span class="token operator">~</span><span class="token function">shared_ptr</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
		<span class="token punctuation">{<!-- --></span>
			<span class="token function">Release</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token punctuation">}</span>

		<span class="token comment">/</span>
		<span class="token comment">// 具有指针类似的行为</span>
		T<span class="token operator">&amp;</span> operator<span class="token operator">*</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
		<span class="token punctuation">{<!-- --></span>
			<span class="token keyword">return</span> <span class="token operator">*</span>_ptr<span class="token punctuation">;</span>
		<span class="token punctuation">}</span>

		T<span class="token operator">*</span> operator<span class="token operator">-&gt;</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
		<span class="token punctuation">{<!-- --></span>
			<span class="token keyword">return</span> _ptr<span class="token punctuation">;</span>
		<span class="token punctuation">}</span>

		T<span class="token operator">*</span> <span class="token function">Get</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
		<span class="token punctuation">{<!-- --></span>
			<span class="token keyword">return</span> _ptr<span class="token punctuation">;</span>
		<span class="token punctuation">}</span>

		<span class="token comment">//</span>
		<span class="token comment">// 用户可能需要获取引用计数</span>
		<span class="token keyword">int</span> <span class="token function">use_count</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token keyword">const</span>
		<span class="token punctuation">{<!-- --></span>
			<span class="token keyword">return</span> <span class="token operator">*</span>_pCount<span class="token punctuation">;</span>
		<span class="token punctuation">}</span>

		<span class="token comment">///</span>
		<span class="token comment">// 解决浅拷贝方式：采用引用计数</span>
		<span class="token function">shared_ptr</span><span class="token punctuation">(</span><span class="token keyword">const</span> shared_ptr<span class="token operator">&lt;</span>T<span class="token operator">&gt;</span><span class="token operator">&amp;</span> sp<span class="token punctuation">)</span>
			<span class="token operator">:</span> <span class="token function">_ptr</span><span class="token punctuation">(</span>sp<span class="token punctuation">.</span>_ptr<span class="token punctuation">)</span>
			<span class="token punctuation">,</span> <span class="token function">_pCount</span><span class="token punctuation">(</span>sp<span class="token punctuation">.</span>_pCount<span class="token punctuation">)</span>
			<span class="token punctuation">,</span> <span class="token function">_pMutex</span><span class="token punctuation">(</span>sp<span class="token punctuation">.</span>_pMutex<span class="token punctuation">)</span>
		<span class="token punctuation">{<!-- --></span>
			<span class="token function">AddRef</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token punctuation">}</span>

		shared_ptr<span class="token operator">&lt;</span>T<span class="token punctuation">,</span> DF<span class="token operator">&gt;</span><span class="token operator">&amp;</span> operator<span class="token operator">=</span><span class="token punctuation">(</span><span class="token keyword">const</span> shared_ptr<span class="token operator">&lt;</span>T<span class="token punctuation">,</span> DF<span class="token operator">&gt;</span><span class="token operator">&amp;</span> sp<span class="token punctuation">)</span>
		<span class="token punctuation">{<!-- --></span>
			<span class="token keyword">if</span> <span class="token punctuation">(</span>this <span class="token operator">!=</span> <span class="token operator">&amp;</span>sp<span class="token punctuation">)</span>
			<span class="token punctuation">{<!-- --></span>
				<span class="token comment">// 在和sp共享之前，this先要将之前的状态清空</span>
				<span class="token function">Release</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

				<span class="token comment">// this就可以和sp共享资源以及计数了</span>
				_ptr <span class="token operator">=</span> sp<span class="token punctuation">.</span>_ptr<span class="token punctuation">;</span>
				_pCount <span class="token operator">=</span> sp<span class="token punctuation">.</span>_pCount<span class="token punctuation">;</span>
				_pMutex <span class="token operator">=</span> sp<span class="token punctuation">.</span>_pMutex<span class="token punctuation">;</span>
				<span class="token function">AddRef</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
			<span class="token punctuation">}</span>

			<span class="token keyword">return</span> <span class="token operator">*</span>this<span class="token punctuation">;</span>
		<span class="token punctuation">}</span>

	private<span class="token operator">:</span>
		<span class="token keyword">void</span> <span class="token function">AddRef</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
		<span class="token punctuation">{<!-- --></span>
			<span class="token keyword">if</span> <span class="token punctuation">(</span>nullptr <span class="token operator">==</span> _ptr<span class="token punctuation">)</span>
				<span class="token keyword">return</span><span class="token punctuation">;</span>

			_pMutex<span class="token operator">-&gt;</span><span class="token function">lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
			<span class="token operator">++</span><span class="token punctuation">(</span><span class="token operator">*</span>_pCount<span class="token punctuation">)</span><span class="token punctuation">;</span>
			_pMutex<span class="token operator">-&gt;</span><span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token punctuation">}</span>

		<span class="token keyword">void</span> <span class="token function">Release</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
		<span class="token punctuation">{<!-- --></span>
			<span class="token keyword">if</span> <span class="token punctuation">(</span>nullptr <span class="token operator">==</span> _ptr<span class="token punctuation">)</span>
				<span class="token keyword">return</span><span class="token punctuation">;</span>

			bool isDelete <span class="token operator">=</span> false<span class="token punctuation">;</span>
			_pMutex<span class="token operator">-&gt;</span><span class="token function">lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

			<span class="token keyword">if</span> <span class="token punctuation">(</span>_ptr <span class="token operator">&amp;&amp;</span> <span class="token number">0</span> <span class="token operator">==</span> <span class="token operator">--</span><span class="token punctuation">(</span><span class="token operator">*</span>_pCount<span class="token punctuation">)</span><span class="token punctuation">)</span>
			<span class="token punctuation">{<!-- --></span>
				<span class="token comment">// delete _ptr;</span>
				DF df<span class="token punctuation">;</span>
				<span class="token function">df</span><span class="token punctuation">(</span>_ptr<span class="token punctuation">)</span><span class="token punctuation">;</span>
				delete _pCount<span class="token punctuation">;</span>
				_pCount <span class="token operator">=</span> nullptr<span class="token punctuation">;</span>
				isDelete <span class="token operator">=</span> true<span class="token punctuation">;</span>
			<span class="token punctuation">}</span>

			_pMutex<span class="token operator">-&gt;</span><span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

			<span class="token keyword">if</span> <span class="token punctuation">(</span>isDelete<span class="token punctuation">)</span>
			<span class="token punctuation">{<!-- --></span>
				delete _pMutex<span class="token punctuation">;</span>
			<span class="token punctuation">}</span>
		<span class="token punctuation">}</span>
	private<span class="token operator">:</span>
		T<span class="token operator">*</span> _ptr<span class="token punctuation">;</span>        <span class="token comment">// 用来接收资源的</span>
		<span class="token keyword">int</span><span class="token operator">*</span> _pCount<span class="token punctuation">;</span>   <span class="token comment">// 指向了引用计数的空间---记录的是使用资源的对象的个数</span>
		mutex<span class="token operator">*</span> _pMutex<span class="token punctuation">;</span> <span class="token comment">// 目的：保证对引用计数的操作是安全的</span>
	<span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/243cff14243c9555dea8c78460775449/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">C/C&#43;&#43;：Windows编程—调用DLL程序的2种方法</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/1e2c4c2b485e110b513e517ddb877125/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">华为设备802.1X认证（认证点在汇聚层交换机）</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>