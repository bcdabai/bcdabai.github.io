<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>java里的Object - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="java里的Object" />
<meta property="og:description" content="一、Object对象 1.2 java创建对象的四种方式 java程序中对象的创建有四种方式：
● 调用new语句创建对象，最常见的一种
● 运用反射手段创建对象,调用java.lang.Class 或者 java.lang.reflect.Constructor 类的newInstance()实例方法
● 调用对象的clone()方法
● 运用序列化手段,调用java.io.ObjectInputStream 对象的 readObject()方法,其实就是一种深拷贝
@see https://www.cnblogs.com/avivahe/p/5702132.html
二、hashcode与equals 2.1 hashcode定义 hashCode() 的作用是获取哈希码，也称为散列码；它实际上是返回一个int整数。
这个哈希码的作用是确定该对象在哈希表中的索引位置。
hashCode() 定义在JDK的Object.java中，Java中的任何类都包含有
hashCode() 函数。
散列表存储的是键值对(key-value)，它的特点是：能根据“键”快速的检索出对应的“值”。
这其中就利用到了散列码！（可以快速找到所需要的对象）
让同一个类的对象按照自己不同的特征尽量的有不同的哈希码，但不表示不同的对象哈希码完全不同。在Java中，哈希码代表对象的特征。
注意：有些朋友误以为默认情况下，hashCode返回的就是对象的存储地址，事实上这种看法是不全面的，确实有些JVM在实现时是直接返回对象的存储地址，但是大多时候并不是这样，只能说可能存储地址有一定关联。
hashCode方法的作用：
增加查询速度。快速判断对象是否不相等。
2.2 equals方法实现原理 先比较两个对象的hashCode，然后比较两个对象所指向的值
可以对照散列表的数据结构理解，hashcode值相当于桶的索引值，equals方法主要是判断在相同索引值下，遍历链表的值是否相同。
Object.equals方法实质就是判断对象的存储地址。
源码如下：
public boolean equals(Object obj) { return (this == obj); } String中的equals方法其实重写了Object.equals方法
源码如下:
public boolean equals(Object anObject) { if (this == anObject) {//先进行地址比较 return true; } if (anObject instanceof String) {//接着判断是否为string类，下面为字符比较 String anotherString = (String)anObject; int n = value." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/3d520313c87e2cad018965f904d722e0/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-10-10T10:00:46+08:00" />
<meta property="article:modified_time" content="2022-10-10T10:00:46+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">java里的Object</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <h2><a id="Object_2"></a>一、Object对象</h2> 
<h3><a id="12_java_5"></a>1.2 java创建对象的四种方式</h3> 
<p>java程序中对象的创建有四种方式：</p> 
<p>● 调用new语句创建对象，最常见的一种</p> 
<p>● 运用反射手段创建对象,调用java.lang.Class 或者 java.lang.reflect.Constructor 类的newInstance()实例方法</p> 
<p>● 调用对象的clone()方法</p> 
<p>● 运用序列化手段,调用java.io.ObjectInputStream 对象的 readObject()方法,其实就是一种深拷贝</p> 
<p>@see https://www.cnblogs.com/avivahe/p/5702132.html</p> 
<h2><a id="hashcodeequals_19"></a>二、hashcode与equals</h2> 
<h3><a id="21_hashcode_21"></a>2.1 hashcode定义</h3> 
<p>hashCode() 的作用是获取哈希码，也称为散列码；它实际上是返回一个int整数。<br> 这个哈希码的作用是确定该对象在哈希表中的索引位置。</p> 
<p>hashCode() 定义在JDK的Object.java中，Java中的任何类都包含有<br> hashCode() 函数。</p> 
<p>散列表存储的是键值对(key-value)，它的特点是：能根据“键”快速的检索出对应的“值”。<br> 这其中就利用到了散列码！（可以快速找到所需要的对象）</p> 
<p>让同一个类的对象按照自己不同的特征尽量的有不同的哈希码，但不表示不同的对象哈希码完全不同。在Java中，哈希码代表对象的特征。</p> 
<p>注意：有些朋友误以为默认情况下，hashCode返回的就是对象的存储地址，事实上这种看法是不全面的，确实有些JVM在实现时是直接返回对象的存储地址，但是大多时候并不是这样，只能说可能存储地址有一定关联。</p> 
<p><strong>hashCode方法的作用：</strong></p> 
<p>增加查询速度。快速判断对象是否不相等。</p> 
<h3><a id="22_equals_41"></a>2.2 equals方法实现原理</h3> 
<p>先比较两个对象的hashCode，然后比较两个对象所指向的值</p> 
<p>可以对照散列表的数据结构理解，hashcode值相当于桶的索引值，equals方法主要是判断在相同索引值下，遍历链表的值是否相同。</p> 
<p>Object.equals方法实质就是判断对象的存储地址。</p> 
<p>源码如下：</p> 
<pre><code class="prism language-java"> <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">equals</span><span class="token punctuation">(</span><span class="token class-name">Object</span> obj<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token keyword">this</span> <span class="token operator">==</span> obj<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
</code></pre> 
<p>String中的equals方法其实重写了Object.equals方法</p> 
<p>源码如下:</p> 
<pre><code class="prism language-java"><span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">equals</span><span class="token punctuation">(</span><span class="token class-name">Object</span> anObject<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">this</span> <span class="token operator">==</span> anObject<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span><span class="token comment">//先进行地址比较</span>
            <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
 
        <span class="token keyword">if</span> <span class="token punctuation">(</span>anObject <span class="token keyword">instanceof</span> <span class="token class-name">String</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span><span class="token comment">//接着判断是否为string类，下面为字符比较</span>
            <span class="token class-name">String</span> anotherString <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">)</span>anObject<span class="token punctuation">;</span>
            <span class="token keyword">int</span> n <span class="token operator">=</span> value<span class="token punctuation">.</span>length<span class="token punctuation">;</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>n <span class="token operator">==</span> anotherString<span class="token punctuation">.</span>value<span class="token punctuation">.</span>length<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
                <span class="token keyword">char</span> v1<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> value<span class="token punctuation">;</span>
                <span class="token keyword">char</span> v2<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> anotherString<span class="token punctuation">.</span>value<span class="token punctuation">;</span>
                <span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
                <span class="token keyword">while</span> <span class="token punctuation">(</span>n<span class="token operator">--</span> <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
                    <span class="token keyword">if</span> <span class="token punctuation">(</span>v1<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">!=</span> v2<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span>
                        <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
                    i<span class="token operator">++</span><span class="token punctuation">;</span>
                <span class="token punctuation">}</span>
                <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
 <span class="token punctuation">}</span>
 
</code></pre> 
<p>执行逻辑为：先判断对象存储地址是否相等，如果不等，判断对应的值，如果值相等则返回true。</p> 
<p>故可以的得出如下结论：</p> 
<pre><code>	 如果调用equals方法得到的结果为true，则两个对象的hashcode值必定相等；

　　如果equals方法得到的结果为false，则两个对象的hashcode值不一定不同；

　　如果两个对象的hashcode值不等，则equals方法得到的结果必定为false；

　　如果两个对象的hashcode值相等，则equals方法得到的结果未知。

或者：
1、如果两个对象相同，那么它们的hashCode值一定要相同；
2、如果两个对象的hashCode相同，它们并不一定相同
3.两个对象不相同，他们的hashCode值不一定不相同。
4.两个对象的hashCode值不相同，他们一定是两个不同的对象      

</code></pre> 
<p><strong>在什么场景下需要重新实现hashcode和equals这两个方法。</strong></p> 
<p>1、加入到hashset中的自定义类的对象，为确保他们不重复，需要对他们的类重写equals()和hashcode()的方法。</p> 
<p>如果不重写equals，相同内容不同引用的对象会被当做不同的对象被加入到hashset中。</p> 
<p>2.在重写equals方法的同时，必须重写hashCode方法</p> 
<p>两个对象相等，首先要满足其hashcode值相等，因为两个不同的对象很有可能共用一个hashcode值。然后equals方法来判断是否相等。只有两种同时满足才能确定他们两个对象是相等的。</p> 
<p>注意：equals方法最初是在所有类的基类Object中进行定义的，源码是</p> 
<p>在这里插入代码片</p> 
<pre><code>public boolean equals(Object obj) {
    return (this == obj);
    }

</code></pre> 
<p>由equals的源码可以看出这里定义的equals与<mark>是等效的（Object类中的equals没什么区别），不同的原因就在于有些类（像String、Integer等类）对equals进行了重写，但是没有对equals进行重写的类（比如我们自己写的类）就只能从Object类中继承equals方法，其equals方法与</mark>就也是等效的，除非我们在此类中重写equals。</p> 
<p>@see https://www.cnblogs.com/zjc950516/p/7877511.html</p> 
<h3><a id="_135"></a>思考</h3> 
<h4><a id="1java__137"></a>1.java 比较大小的坑和总结</h4> 
<ol><li>“== ”用于判断的是对象的内存地址</li></ol> 
<pre><code>public class ArrayTest {

    public static void main(String[] args){

        String a = new String("aw");
        String b = new String("aw");
        System.out.println(a==b);//false
        System.out.println(a.equals(b));//true
    }
}
</code></pre> 
<p>显然，尽管 a 与 b 对象的值相同，但是在内存中的地址是不同的，即hashcode不同，所以两个对象是不一样的。但用equals是返回的true。</p> 
<p>再看一个例子：</p> 
<pre><code>public class ArrayTest {

    public static void main(String[] args){

         String a = new String("aw");
        String b = new String("aw");
        String c= "aa";
        String d= "aa";
        System.out.println(a.hashCode());
        System.out.println(b.hashCode());
        System.out.println(c.hashCode());
        System.out.println(d.hashCode());
        System.out.println(a==b);//false
        System.out.println(c==d);//true
    }
}
</code></pre> 
<p>运行结果为</p> 
<pre><code>3126
3126
3104
3104
false
true
</code></pre> 
<p>可见两个对象不相同，他们的hashCode值不一定不相同。</p> 
<p>2.数字大小的比较最好用compareTo而不是equals</p> 
<pre><code class="prism language-java"> 		<span class="token class-name">Long</span> num <span class="token operator">=</span> <span class="token number">1L</span><span class="token punctuation">;</span>
        <span class="token class-name">Integer</span> num2 <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
        <span class="token keyword">boolean</span> b <span class="token operator">=</span> num<span class="token punctuation">.</span><span class="token function">compareTo</span><span class="token punctuation">(</span>num2<span class="token punctuation">.</span><span class="token function">longValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token comment">//true</span>
        <span class="token keyword">boolean</span> obj <span class="token operator">=</span> <span class="token class-name">Objects</span><span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>num2<span class="token punctuation">.</span><span class="token function">intValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>num<span class="token punctuation">.</span><span class="token function">longValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//false</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token class-name">Objects</span><span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>num<span class="token punctuation">,</span>num2<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//false</span>
        <span class="token keyword">boolean</span> equals <span class="token operator">=</span> num2<span class="token punctuation">.</span><span class="token function">intValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> num<span class="token punctuation">.</span><span class="token function">longValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//true</span>
</code></pre> 
<h4><a id="2hash_202"></a>2.解决hash冲突的几种方法</h4> 
<p>1.链表法 <br> 链表法就是将相同hash值的对象组织成一个链表放在hash值对应的槽位，如Java中的HashMap</p> 
<p>2，不易探测到整个散列表的所有空间（线性探测法除外，但线性探测会出现堆积）</p> 
<p>2.开放地址法</p> 
<p>开放地址法有个非常关键的特征，就是所有输入的元素全部存放在哈希表里，也就是说，位桶的实现是不需要任何的链表来实现的，换句话说，也就是这个哈希表的装载因子不会超过1。它的实现是在插入一个元素的时候，先通过哈希函数进行判断，若是发生哈希冲突，就以当前地址为基准，根据再寻址的方法（探查序列），去寻找下一个地址，若发生冲突再去寻找，直至找到一个为空的地址为止。所以这种方法又称为再散列法。</p> 
<p>有几种常用的探查序列的方法：</p> 
<p>①线性探查</p> 
<p>dii=1，2，3，…，m-1；这种方法的特点是：冲突发生时，顺序查看表中下一单元，直到找出一个空单元或查遍全表。</p> 
<p>（使用例子：ThreadLocal里面的ThreadLocalMap）</p> 
<p>②二次探查</p> 
<p>di=12，-12，22，-22，…，k2，-k2 ( k&lt;=m/2 )；这种方法的特点是：冲突发生时，在表的左右进行跳跃式探测，比较灵活。</p> 
<p>③ 伪随机探测</p> 
<p>di=伪随机数序列；具体实现时，应建立一个伪随机数发生器，（如i=(i+p) % m），生成一个位随机序列，并给定一个随机数做起点，每次去加上这个伪随机数++就可以了。</p> 
<p>缺点：1，删除工作很困难，假如要从哈希表 HT 中删除一个记录，应将这个记录所在位置置为空，但我们只能标上已被删除的标记，否则，将会影响以后的查找。</p> 
<p>2，不易探测到整个散列表的所有空间（线性探测法除外，但线性探测会出现堆积）</p> 
<p>3.再散列法</p> 
<p>再散列法其实很简单，就是再使用哈希函数去散列一个输入的时候，输出是同一个位置就再次散列，直至不发生冲突位置</p> 
<p>缺点：每次冲突都要重新散列，计算时间增加。</p> 
<p>4.公共溢出区法<br> 散列表由两个一维数组组成，一个称为基本表，它实际上就是一个散列表。另外一个称为溢出表。插入首先在基本表上进行，假如发生冲突，则将同义词存入溢出表。这样，可以保证基本表不会发生“堆积”</p> 
<p>PS：基本表是不会发生堆积了，那溢出表呢？当进行查找时，查找到溢出表，这是不是又开启了新一轮的冲突解决？</p> 
<p>@see 【java基础 10】hash算法冲突解决方法 https://www.cnblogs.com/hhx626/p/7534618.html</p> 
<h4><a id="3object_251"></a>3.为什么这些操作线程的方法要定义在object类中呢？</h4> 
<p>答：因为加锁和解锁都是基于对象来的，而锁的信息是存在对象中的一个markword信息里面的，所以要定义在Object类里。</p> 
<h3><a id="3__255"></a>3 静态变量、实例变量、局部变量与线程安全</h3> 
<p>1.静态变量：线程非安全。</p> 
<p>静态变量表示所有实例共享的一个属性，位于方法区，共享一份内存，而成员变量是对象的特殊描述，不同对象的实例变量被分配在不同的内存空间，一旦静态变量被修改，其他对象均对修改可见，故线程非安全。</p> 
<p>2.实例变量：单例模式（只有一个对象实例存在）线程非安全，非单例线程安全。</p> 
<p>实例变量为对象实例私有，在虚拟机的堆中分配，若在系统中只存在一个此对象的实例，在多线程环境下，被某个线程修改后，其他线程对修改均可见，故线程非安全；</p> 
<p>如果每个线程执行都是在不同的对象中，那对象与对象之间的实例变 量的修改将互不影响，故线程安全。</p> 
<p>3.局部变量：线程安全。</p> 
<p>局部变量存在于栈内存中，作用的范围结束，变量空间会自动释放。由于每个线程执行时将会把局部变量放在各自栈帧的工作内存中，线程间不共享，故不存在线程安全问题。</p> 
<p>@see 静态变量、实例变量、局部变量与线程安全 https://www.cnblogs.com/tonyluis/p/5549149.html</p> 
<h3><a id="_285"></a>参考资料</h3> 
<p>1.浅谈Java中的hashcode方法 https://www.cnblogs.com/dolphin0520/p/3681042.html<br> 2.[转]Java 的强引用、弱引用、软引用、虚引用 http://www.cnblogs.com/gudi/p/6403953.html</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/c8047832f86aeb0753eab7b4787c6016/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">(附源码)计算机毕业设计SSM-在线作业管理系统</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/9cce0dafc68bd94b630d675d2c2862eb/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">调整图片大小和像素</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>