<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>JavaSE入门学习37：Java集合框架之Map接口及其实现类HashMap和TreeMap - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="JavaSE入门学习37：Java集合框架之Map接口及其实现类HashMap和TreeMap" />
<meta property="og:description" content="一Map接口 Map接口中的每个成员方法由一个关键字(key)和一个值(value)构成。Map接口不直接继承于Collection接口，因
为它包装的是一组成对的&#34;键-值&#34;对象的集合，而且在Map接口的集合中也不能有重复的key出现，因为每个键只能与
一个成员元素相对应。
Map接口定义了存储&#34;键(key)——值(value)映射对&#34;的方法。实现Map接口的类用来存储键值对。Map接口中包含
了一个keySet()方法，用于返回Map中所有key组成的Set集合。
Map接口的特点有： 1)Map接口提供了一种映射关系，其中的元素是以键值对(key-value)的形式存储 的，能够实现根据key快速查找value。 2)Map中的键值对以Entry类型的对象实例形式存在。键(key值)不可重复，value值可以。
3)每个键最多只能映射到一个值。
4)Map接口提供了分别返回key值集合，value值集合以及Entry(键值对)集合的方法。
5)Map同样也支持泛型，形式如：Map&lt;K,V&gt;。
6)Map接口中存储的键—值对通过键来标识，所以键值不能重复，即同一个Map对象的任何两个key通过equals()
方法比较总是返回false。
Map接口中定义的方法有：
Map接口的主要有三个实现类，分别是：HashMap、TreeMap和HashTable。一般情况下，我们用的最多的是
HashMap，在Map中插入、删除和定位元素，HashMap是最好的选择。但如果您要按自然顺序或自定义顺序遍历
键，那么TreeMap会更好。如果需要输出的顺序和输入的相同。那么用HashMap的子类LinkedHashMap可以实现，
它还可以按读取顺序来排列。
二HashMap实现类 Hashmap类是一个最常用的Map,它根据键的HashCode值存储数据,根据键可以直接获取它的值，具有很快的访
问速度，遍历时，取得数据的顺序是完全随机的。HashMap最多只允许一条记录的键为Null;允许多条记录的值为
Null;HashMap不支持线程的同步，即任一时刻可以有多个线程同时写HashMap;可能会导致数据的不一致。如果需要
同步，可以用Collections集合类的synchronizedMap()方法使HashMap类具有同步的能力。
由于HashMap里的不能重复，所以HashMap里最多只有一对key-value值为null，但可以有无数多项key-value对
的value为null。
HashMap重写了toString()方法方法总是返回如下格式的字符串：{key1 = value1，key2 = value2...}
HashMap判断两个key相等的标准是：两个key通过equasl()方法比较返回ture,两个key的hashCode值相等。
HashMap的特点：
1)HashMap是Map的一个重要实现类，也是最常用的，基于哈希表实现。
2)HashMap中的Entry对象是无序排列的。
3)Key值和value值都可以是null，但是一个HashMap只能有一个key值为null的映射(key值不可重复)。
HashMap实现类的方法：
实例：
import java.util.*; public class TestHashMap { public static void main(String[] args) { Map&lt;Dog, Integer&gt; hashMap = new HashMap&lt;Dog, Integer&gt;(); Dog d1 = new Dog(&#34;red&#34;); Dog d2 = new Dog(&#34;black&#34;); Dog d3 = new Dog(&#34;" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/5986268b943c30a5dd5e9e14f78010c1/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2016-05-10T16:39:10+08:00" />
<meta property="article:modified_time" content="2016-05-10T16:39:10+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">JavaSE入门学习37：Java集合框架之Map接口及其实现类HashMap和TreeMap</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <h2><span style="font-size:18px">        <span style="color:#ff0000">一Map接口</span></span></h2> 
<p><span style="font-size:18px">        Map接口中的每个成员方法由一个关键字(key)和一个值(value)构成。Map接口不直接继承于Collection接口，因</span></p> 
<p><span style="font-size:18px">为它包装的是一组成对的"键-值"对象的集合，而且在Map接口的集合中也不能有重复的key出现，因为每个键只能与</span></p> 
<p><span style="font-size:18px">一个成员元素相对应。</span></p> 
<p><span style="font-size:18px">        Map接口定义了存储"键(key)——值(value)映射对"的方法。实现Map接口的类用来存储键值对。Map接口中包含</span></p> 
<p><span style="font-size:18px">了一个keySet()方法，用于返回Map中所有key组成的Set集合。</span></p> 
<p><span style="font-size:18px">        <span style="color:#ff6600">Map接口的特点有：</span> </span></p> 
<span style="font-size:18px">        1)Map接口提供了一种映射关系，其中的元素是以键值对(key-value)的形式存储</span> 
<span style="font-size:18px">的，能够实现根据key快速查找value。</span> 
<p><span style="font-size:18px">        2)Map中的键值对以Entry类型的对象实例形式存在。键(key值)不可重复，value</span><span style="font-size:18px">值可以。</span></p> 
<span style="font-size:18px">        3)每个键最多只能映射到一个值。<br> </span> 
<p><span style="font-size:18px">        4)Map接口提供了分别返回key值集合，value值集合以及Entry(键值对)集合的方法。</span></p> 
<p><span style="font-size:18px">        5)Map同样也支持泛型，形式如：Map&lt;K,V&gt;。</span></p> 
<p><span style="font-size:18px">        6)Map接口中存储的键—值对通过键来标识，所以键值不能重复，即同一个Map对象的任何两个key通过equals()</span></p> 
<p><span style="font-size:18px">方法比较总是返回false。</span></p> 
<p><span style="font-size:18px">       Map接口中定义的方法有：</span></p> 
<p style="text-align:center"><span style="font-size:18px"><img src="https://images2.imgbox.com/d6/09/uMMGBfhJ_o.png" alt=""><br> </span></p> 
<p><span style="font-size:18px">       Map接口的主要有三个实现类，分别是：HashMap、TreeMap和HashTable。一般情况下，我们用的最多的是</span></p> 
<p><span style="font-size:18px">HashMap，在Map中插入、删除和定位元素，HashMap是最好的选择。但如果您要按自然顺序或自定义顺序遍历</span></p> 
<p><span style="font-size:18px">键，那么TreeMap会更好。如果需要输出的顺序和输入的相同。那么用HashMap的子类LinkedHashMap可以实现，</span></p> 
<p><span style="font-size:18px">它还可以按读取顺序来排列。</span></p> 
<h2><span style="font-size:18px">        <span style="color:#ff0000">二HashMap实现类</span></span></h2> 
<p><span style="font-size:18px">        Hashmap类是一个最常用的Map,它根据键的HashCode值存储数据,根据键可以直接获取它的值，具有很快的访</span></p> 
<p><span style="font-size:18px">问</span><span style="font-size:18px">速度，遍历时，取得数据的顺序是完全随机的。</span><span style="font-size:18px">HashMap最多只允许一条记录的键为Null;允许多条记录的值为</span></p> 
<p><span style="font-size:18px"> Null;HashMap不支持线程的同步，即任一时刻可以有多个线程同时写HashMap;可能会导致数据的不一致。如果需要</span></p> 
<p><span style="font-size:18px">同步，可以用Collections集合类的synchronizedMap()方法使HashMap类具有同步的能力。</span></p> 
<p><span style="font-size:18px">        由于HashMap里的不能重复，所以HashMap里最多只有一对key-value值为null，但可以有无数多项key-value对</span></p> 
<p><span style="font-size:18px">的value为null。</span></p> 
<p><span style="font-size:18px">　　HashMap重写了toString()方法方法总是返回如下格式的字符串：{key1 = value1，key2 = value2...}</span></p> 
<p><span style="font-size:18px">　　HashMap判断两个key相等的标准是：两个key通过equasl()方法比较返回ture,两个key的hashCode值相等。</span></p> 
<p><span style="font-size:18px">       <span style="color:#ff6600">HashMap的特点：</span></span></p> 
<p><span style="font-size:18px">       1)HashMap是Map的一个重要实现类，也是最常用的，基于哈希表实现。</span></p> 
<p><span style="font-size:18px">       2)HashMap中的Entry对象是无序排列的。</span></p> 
<p><span style="font-size:18px">       3)Key值和value值都可以是null，但是一个HashMap只能有一个key值为null的映射(key值不可重复)。</span></p> 
<p><span style="font-size:18px">       HashMap实现类的方法：</span></p> 
<p style="text-align:center"><span style="font-size:18px"><img src="https://images2.imgbox.com/19/b3/9gah9ajB_o.png" alt=""><br> </span></p> 
<p><span style="font-size:18px">       实例：</span></p> 
<p><span style="font-size:18px"></span></p> 
<pre><code class="language-java">import java.util.*;

public class TestHashMap {
	public static void main(String[] args) {
		Map&lt;Dog, Integer&gt; hashMap = new HashMap&lt;Dog, Integer&gt;();
		Dog d1 = new Dog("red");
		Dog d2 = new Dog("black");
		Dog d3 = new Dog("white");
		Dog d4 = new Dog("white");
 
		hashMap.put(d1, 10);
		hashMap.put(d2, 15);
		hashMap.put(d3, 5);
		hashMap.put(d4, 20);
 
		//print size
		System.out.println(hashMap.size());
 
		//loop HashMap
		for (Map.Entry&lt;Dog, Integer&gt; entry : hashMap.entrySet()) {
			System.out.println(entry.getKey().toString() + " - " + entry.getValue());
		}
	}
}

class Dog {
	String color;
 
	Dog(String c) {
		color = c;
	}
	
	public String toString(){	
		return color + " dog";
	}
}</code></pre> 
<p></p> 
<p><span style="font-size:18px">      运行结果：</span></p> 
<p style="text-align:center"><span style="font-size:18px"><img src="https://images2.imgbox.com/80/c2/a341dEUz_o.png" alt=""><br> </span></p> 
<p><span style="font-size:18px">      注意看,我们错误地添加了两次"white dogs",但是HashMap接受了,这严格来说是没意义的,因为现在对"white </span></p> 
<p><span style="font-size:18px">dogs"的数量产生了混淆。</span></p> 
<p><span style="font-size:18px">      修正后的 Dog 类如下所示:</span></p> 
<p><span style="font-size:18px"></span></p> 
<pre><code class="language-java">class Dog {
    String color;
 
    Dog(String c) {
        color = c;
    }
 
    public boolean equals(Object o) {
        return ((Dog) o).color == this.color;
    }
 
    public int hashCode() {
        return color.length();
    }
 
    public String toString(){    
        return color + " dog";
    }
}</code></pre> 
<p></p> 
<p><span style="font-size:18px">      运行结果：</span></p> 
<p style="text-align:center"><span style="font-size:18px"><img src="https://images2.imgbox.com/f1/db/us1FQ96I_o.png" alt=""><br> </span></p> 
<p><span style="font-size:18px">      原因在于HashMap不运行两个相同的元素作为KEY。如果没有重写，使用的就会是Object类实现的hashCode()和</span></p> 
<p><span style="font-size:18px">equals()方法，默认的 hashCode()方法实现对每个不同的对象返回不同的整数；默认的equals()方法只比较两个引用</span></p> 
<p><span style="font-size:18px">是否指向同一个实际对象。</span></p> 
<h2><span style="font-size:18px">      <span style="color:#ff0000">三TreeMap实现类</span></span></h2> 
<p><span style="font-size:18px">      Map接口派生了一个SortedMap子接口，TreeMap为其实现类。类似TreeSet排序，TreeMap也是基于红黑树对</span></p> 
<p><span style="font-size:18px">TreeMap中所有key进行排序，从而保证TreeMap中所有key-value对处于有序状态。TreeMap两种排序方法：</span></p> 
<p><span style="font-size:18px">       <span style="color:#ff6600">1)自然排序：</span>TreeMap的所有key必须实现Comparable接口，而且所有key应该是同一个类的对象，否则将会抛出</span></p> 
<p><span style="font-size:18px">ClassCastExcepiton异常。</span></p> 
<p><span style="font-size:18px">       <span style="color:#ff6600">2)定制排序：</span>创建TreeMap时，传入一个Comparator对象，该对象负责对TreeＭap中所有key进行排序。采用定</span></p> 
<p><span style="font-size:18px">制排序时不要求Map的key实现Comparable接口。</span></p> 
<p><span style="font-size:18px">　　TreeMap中判断两个key相等的标准也是两个key通过equals()方法比较返回true，而通过compareTo()方法返回</span></p> 
<p><span style="font-size:18px">0，TreeMap即认为这两个key是相等的。</span></p> 
<p><span style="font-size:18px">　　如果使用自定义的类作为TreeMap的key，应重新该类的equals(0方法和compareTo()方法时应有一致的返回结</span></p> 
<p><span style="font-size:18px">果：即两个key通过equals()方法比较返回true时，它们通过compareTo()方法比较应该返回0。如果equals()方法与</span></p> 
<p><span style="font-size:18px">compareTo()方法的返回结果不一致，要么该TreeMap与Map接口的规则有出入（当equals()方法比较返回true,但</span></p> 
<p><span style="font-size:18px">CompareTo()方法比较不返回0时），要么TreeMap处理起来性能有所下降（当compareTo()方法比较返回0，当</span></p> 
<p><span style="font-size:18px">equals()方法比较不返回true时）。</span></p> 
<p><span style="font-size:18px">         <span style="color:#ff6600">TreeMap实现了的方法：</span></span></p> 
<p style="text-align:center"><span style="font-size:18px"><img src="https://images2.imgbox.com/48/74/DQ515tgl_o.png" alt=""><br> </span></p> 
<p style="text-align:center"><span style="font-size:18px"><img src="https://images2.imgbox.com/f9/8e/PjJcOxMy_o.png" alt=""><br> </span></p> 
<p style="text-align:center"><span style="font-size:18px"><img src="https://images2.imgbox.com/96/e9/O11Q8ipe_o.png" alt=""><br> </span></p> 
<p><span style="font-size:18px">        实例：</span></p> 
<p><span style="font-size:18px"></span></p> 
<pre><code class="language-java">import java.util.*;

public class TestTreeMap {
	public static void main(String[] args) {
		Dog d1 = new Dog("red");
		Dog d2 = new Dog("black");
		Dog d3 = new Dog("white");
		Dog d4 = new Dog("white");
 
		Map&lt;Dog, Integer&gt; treeMap = new TreeMap&lt;Dog, Integer&gt;();
		treeMap.put(d1, 10);
		treeMap.put(d2, 15);
		treeMap.put(d3, 5);
		treeMap.put(d4, 20);
 
		for (Map.Entry&lt;Dog, Integer&gt; entry : treeMap.entrySet()) {
			System.out.println(entry.getKey() + " - " + entry.getValue());
		}
	}
}

class Dog {
	String color;
 
	Dog(String c) {
		color = c;
	}

	public boolean equals(Object o) {
		return ((Dog) o).color == this.color;
	}
 
	public int hashCode() {
		return color.length();
	}

	public String toString(){	
		return color + " dog";
	}
}</code></pre> 
<p></p> 
<p><span style="font-size:18px">        运行结果：</span></p> 
<p style="text-align:center"><span style="font-size:18px"><img src="https://images2.imgbox.com/b9/6a/PdtBfjGd_o.png" alt=""><br> </span></p> 
<p><span style="font-size:18px">       既然TreeMap是按key排序的,那么key对象就必须可以和另一个对象作比较,因此必须实现Comparable接口。当</span></p> 
<p><span style="font-size:18px">然，你也可以使用String对象作为key,因为String类已经实现了Comparable接口。</span></p> 
<p><span style="font-size:18px">       下面，我们修改Dog类的代码，使其实现Comparable接口：</span></p> 
<p><span style="font-size:18px"></span></p> 
<pre><code class="language-java">import java.util.*;

public class TestTreeMap {
	public static void main(String[] args) {
		Dog d1 = new Dog("red", 30);
		Dog d2 = new Dog("black", 20);
		Dog d3 = new Dog("white", 10);
		Dog d4 = new Dog("white", 10);
 
		Map&lt;Dog, Integer&gt; treeMap = new TreeMap&lt;Dog, Integer&gt;();
		treeMap.put(d1, 10);
		treeMap.put(d2, 15);
		treeMap.put(d3, 5);
		treeMap.put(d4, 20);
 
		for (Map.Entry&lt;Dog, Integer&gt; entry : treeMap.entrySet()) {
			System.out.println(entry.getKey() + " - " + entry.getValue());
		}
	}
}

class Dog implements Comparable&lt;Dog&gt;{
	String color;
	int size;
 
	Dog(String c, int s) {
		color = c;
		size = s;
	}
 
	public String toString(){	
		return color + " dog";
	}
 
	@Override
	public int compareTo(Dog o) {
		return  o.size - this.size;
	}
}</code></pre> 
<p></p> 
<p><span style="font-size:18px">       运行结果：</span></p> 
<p style="text-align:center"><span style="font-size:18px"><img src="https://images2.imgbox.com/ca/1d/LsVEQQSm_o.png" alt=""><br> </span></p> 
<p><span style="font-size:18px">       这就是根据key对象排序的结果,此处我们使用了size(尺寸)来比较dog.如果我们把"Dog d4 = new Dog("white"</span></p> 
<p><span style="font-size:18px">,10);"这一行代码替换为"Dog d4 = new Dog("white", 40);"那么，执行后的结果为:</span></p> 
<p style="text-align:center"><span style="font-size:18px"><img src="https://images2.imgbox.com/75/99/9rZJgrTI_o.png" alt=""><br> </span></p> 
<p><span style="font-size:18px">       原因是TreeMap使用compareTo()方法来比较key对象,不同的size就被认为是不同的dog。</span></p> 
<p><span style="font-size:18px">       关于Map接口及其实现类的东西就说这么多。</span></p> 
<span style="font-size:18px">      <br> </span> 
<br>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/79e88be845c3abc0912f1ce7e7fd35ef/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">C#添加第三方控件</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/9ccbf316bd8488d00724b5c3e8913891/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">面试时如何谈自己做过的项目</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>