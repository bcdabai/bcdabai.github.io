<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>kafka 3.5 日志定时清理(源码) - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="kafka 3.5 日志定时清理(源码)" />
<meta property="og:description" content="文章目录 一、定时任务入口二、LopManager(这个是日志抽象层，实际逻辑不在这里)1 把日志清理加入定时任务中 三、清理符合条件的日志1、deletableSegments(把需要删除的segment加入待删除的集合)(1)如果主题分区的logStartOffset大于segment的baseOffset(2)如果主题分区文件总大小大于配置中retention.bytes(最大留存大小)(3)如果主题分区各个segment的修改时间和当前时间差大于配置的retention.ms(最大留存时间) 2、把上面待删除segment执行删除操作1、把segment文件后缀改成.deleted2、异步执行删除文件后缀是.delete的文件(加入只执行一次定时任务中) 四，segment相关文件有哪些整理五、问题:1、如果segment最大留存时间和分区最大留存文件大小都不配置会出现什么情况？2、如果只配置segment最大留存时间，并且数据量非常小，能消费最大留存时间之前的数据吗？3、如果只是配置分区最大留存文件大小，并且数据量非常小，能消费到很久以前的吗？ 一、定时任务入口 这里选择kraft的模式启动的定时任务，所以入口是在BrokerServer.scala文件中，如果选择ZooKeeper模式的入口在KafkaServer.scala
def startup(): Unit = { if (!maybeChangeStatus(SHUTDOWN, STARTING)) return try { info(&#34;Starting broker&#34;) /* start scheduler 开始定时任务*/， kafkaScheduler = new KafkaScheduler(config.backgroundThreads) kafkaScheduler.startup() //省略。。。 //创建日志管理器，但不要启动它，因为我们需要延迟任何潜在的不干净关闭日志恢复 // 直到我们赶上元数据日志并拥有最新的主题和代理配置。 logManager = LogManager(config, initialOfflineDirs, metadataCache, kafkaScheduler, time, brokerTopicStats, logDirFailureChannel, keepPartitionMetadataFile = true) //省略。。。 } catch { case e: Throwable =&gt; maybeChangeStatus(STARTING, STARTED) fatal(&#34;Fatal error during broker startup. Prepare to shutdown&#34;, e) shutdown() throw e } } 二、LopManager(这个是日志抽象层，实际逻辑不在这里) object LogManager { val RecoveryPointCheckpointFile = &#34;" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/ab266839fd44c03a0f348b652a844f4d/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-09-25T00:31:40+08:00" />
<meta property="article:modified_time" content="2023-09-25T00:31:40+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">kafka 3.5 日志定时清理(源码)</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p></p> 
<div class="toc"> 
 <h4>文章目录</h4> 
 <ul><li><a href="#_1" rel="nofollow">一、定时任务入口</a></li><li><a href="#LopManager_28" rel="nofollow">二、LopManager(这个是日志抽象层，实际逻辑不在这里)</a></li><li><ul><li><a href="#1___74" rel="nofollow">1 把日志清理加入定时任务中</a></li></ul> 
  </li><li><a href="#_133" rel="nofollow">三、清理符合条件的日志</a></li><li><ul><li><a href="#1deletableSegmentssegment_242" rel="nofollow">1、deletableSegments(把需要删除的segment加入待删除的集合)</a></li><li><ul><li><a href="#1logStartOffsetsegmentbaseOffset_282" rel="nofollow">(1)如果主题分区的logStartOffset大于segment的baseOffset</a></li><li><a href="#2retentionbytes_306" rel="nofollow">(2)如果主题分区文件总大小大于配置中retention.bytes(最大留存大小)</a></li><li><a href="#3segmentretentionms_339" rel="nofollow">(3)如果主题分区各个segment的修改时间和当前时间差大于配置的retention.ms(最大留存时间)</a></li></ul> 
   </li><li><a href="#2segment_363" rel="nofollow">2、把上面待删除segment执行删除操作</a></li><li><ul><li><a href="#1segmentdeleted_405" rel="nofollow">1、把segment文件后缀改成.deleted</a></li><li><a href="#2delete_473" rel="nofollow">2、异步执行删除文件后缀是.delete的文件(加入只执行一次定时任务中)</a></li></ul> 
  </li></ul> 
  </li><li><a href="#segment_478" rel="nofollow">四，segment相关文件有哪些整理</a></li><li><a href="#_489" rel="nofollow">五、问题:</a></li><li><ul><li><a href="#1segment_490" rel="nofollow">1、如果segment最大留存时间和分区最大留存文件大小都不配置会出现什么情况？</a></li><li><a href="#2segment_492" rel="nofollow">2、如果只配置segment最大留存时间，并且数据量非常小，能消费最大留存时间之前的数据吗？</a></li><li><a href="#3_494" rel="nofollow">3、如果只是配置分区最大留存文件大小，并且数据量非常小，能消费到很久以前的吗？</a></li></ul> 
 </li></ul> 
</div> 
<p></p> 
<h2><a id="_1"></a>一、定时任务入口</h2> 
<blockquote> 
 <p>这里选择kraft的模式启动的定时任务，所以入口是在<code>BrokerServer.scala</code>文件中，如果选择ZooKeeper模式的入口在<code>KafkaServer.scala</code></p> 
</blockquote> 
<pre><code class="prism language-scala"> <span class="token keyword">def</span> startup<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token builtin">Unit</span> <span class="token operator">=</span> <span class="token punctuation">{<!-- --></span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>maybeChangeStatus<span class="token punctuation">(</span>SHUTDOWN<span class="token punctuation">,</span> STARTING<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">return</span>
    <span class="token keyword">try</span> <span class="token punctuation">{<!-- --></span>
      info<span class="token punctuation">(</span><span class="token string">"Starting broker"</span><span class="token punctuation">)</span>

      <span class="token comment">/* start scheduler 开始定时任务*/</span>，
      kafkaScheduler <span class="token operator">=</span> <span class="token keyword">new</span> KafkaScheduler<span class="token punctuation">(</span>config<span class="token punctuation">.</span>backgroundThreads<span class="token punctuation">)</span>
      kafkaScheduler<span class="token punctuation">.</span>startup<span class="token punctuation">(</span><span class="token punctuation">)</span>
	  <span class="token comment">//省略。。。</span>
      <span class="token comment">//创建日志管理器，但不要启动它，因为我们需要延迟任何潜在的不干净关闭日志恢复</span>
      <span class="token comment">// 直到我们赶上元数据日志并拥有最新的主题和代理配置。</span>
      logManager <span class="token operator">=</span> LogManager<span class="token punctuation">(</span>config<span class="token punctuation">,</span> initialOfflineDirs<span class="token punctuation">,</span> metadataCache<span class="token punctuation">,</span> kafkaScheduler<span class="token punctuation">,</span> time<span class="token punctuation">,</span>
        brokerTopicStats<span class="token punctuation">,</span> logDirFailureChannel<span class="token punctuation">,</span> keepPartitionMetadataFile <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">)</span>
		<span class="token comment">//省略。。。</span>
    <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">{<!-- --></span>
      <span class="token keyword">case</span> e<span class="token operator">:</span> Throwable <span class="token keyword">=&gt;</span>
        maybeChangeStatus<span class="token punctuation">(</span>STARTING<span class="token punctuation">,</span> STARTED<span class="token punctuation">)</span>
        fatal<span class="token punctuation">(</span><span class="token string">"Fatal error during broker startup. Prepare to shutdown"</span><span class="token punctuation">,</span> e<span class="token punctuation">)</span>
        shutdown<span class="token punctuation">(</span><span class="token punctuation">)</span>
        <span class="token keyword">throw</span> e
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
</code></pre> 
<h2><a id="LopManager_28"></a>二、LopManager(这个是日志抽象层，实际逻辑不在这里)</h2> 
<pre><code class="prism language-scala"><span class="token keyword">object</span> LogManager <span class="token punctuation">{<!-- --></span>
  <span class="token keyword">val</span> RecoveryPointCheckpointFile <span class="token operator">=</span> <span class="token string">"recovery-point-offset-checkpoint"</span>
  <span class="token keyword">val</span> LogStartOffsetCheckpointFile <span class="token operator">=</span> <span class="token string">"log-start-offset-checkpoint"</span>
  <span class="token keyword">val</span> ProducerIdExpirationCheckIntervalMs <span class="token operator">=</span> <span class="token number">10</span> <span class="token operator">*</span> <span class="token number">60</span> <span class="token operator">*</span> <span class="token number">1000</span>

  <span class="token keyword">def</span> apply<span class="token punctuation">(</span>config<span class="token operator">:</span> KafkaConfig<span class="token punctuation">,</span>
            initialOfflineDirs<span class="token operator">:</span> Seq<span class="token punctuation">[</span><span class="token builtin">String</span><span class="token punctuation">]</span><span class="token punctuation">,</span>
            configRepository<span class="token operator">:</span> ConfigRepository<span class="token punctuation">,</span>
            kafkaScheduler<span class="token operator">:</span> KafkaScheduler<span class="token punctuation">,</span>
            time<span class="token operator">:</span> Time<span class="token punctuation">,</span>
            brokerTopicStats<span class="token operator">:</span> BrokerTopicStats<span class="token punctuation">,</span>
            logDirFailureChannel<span class="token operator">:</span> LogDirFailureChannel<span class="token punctuation">,</span>
            keepPartitionMetadataFile<span class="token operator">:</span> <span class="token builtin">Boolean</span><span class="token punctuation">)</span><span class="token operator">:</span> LogManager <span class="token operator">=</span> <span class="token punctuation">{<!-- --></span>
    <span class="token keyword">val</span> defaultProps <span class="token operator">=</span> LogConfig<span class="token punctuation">.</span>extractLogConfigMap<span class="token punctuation">(</span>config<span class="token punctuation">)</span>

    LogConfig<span class="token punctuation">.</span>validateValues<span class="token punctuation">(</span>defaultProps<span class="token punctuation">)</span>
    <span class="token keyword">val</span> defaultLogConfig <span class="token operator">=</span> LogConfig<span class="token punctuation">(</span>defaultProps<span class="token punctuation">)</span>

    <span class="token keyword">val</span> cleanerConfig <span class="token operator">=</span> LogCleaner<span class="token punctuation">.</span>cleanerConfig<span class="token punctuation">(</span>config<span class="token punctuation">)</span>

    <span class="token keyword">new</span> LogManager<span class="token punctuation">(</span>logDirs <span class="token operator">=</span> config<span class="token punctuation">.</span>logDirs<span class="token punctuation">.</span>map<span class="token punctuation">(</span><span class="token keyword">new</span> File<span class="token punctuation">(</span>_<span class="token punctuation">)</span><span class="token punctuation">.</span>getAbsoluteFile<span class="token punctuation">)</span><span class="token punctuation">,</span>
      initialOfflineDirs <span class="token operator">=</span> initialOfflineDirs<span class="token punctuation">.</span>map<span class="token punctuation">(</span><span class="token keyword">new</span> File<span class="token punctuation">(</span>_<span class="token punctuation">)</span><span class="token punctuation">.</span>getAbsoluteFile<span class="token punctuation">)</span><span class="token punctuation">,</span>
      configRepository <span class="token operator">=</span> configRepository<span class="token punctuation">,</span>
      initialDefaultConfig <span class="token operator">=</span> defaultLogConfig<span class="token punctuation">,</span>
      cleanerConfig <span class="token operator">=</span> cleanerConfig<span class="token punctuation">,</span>
      recoveryThreadsPerDataDir <span class="token operator">=</span> config<span class="token punctuation">.</span>numRecoveryThreadsPerDataDir<span class="token punctuation">,</span>
      flushCheckMs <span class="token operator">=</span> config<span class="token punctuation">.</span>logFlushSchedulerIntervalMs<span class="token punctuation">,</span>
      flushRecoveryOffsetCheckpointMs <span class="token operator">=</span> config<span class="token punctuation">.</span>logFlushOffsetCheckpointIntervalMs<span class="token punctuation">,</span>
      flushStartOffsetCheckpointMs <span class="token operator">=</span> config<span class="token punctuation">.</span>logFlushStartOffsetCheckpointIntervalMs<span class="token punctuation">,</span>
      <span class="token comment">//log.retention.check.interval.ms 日志保留检查间隔 ms</span>
      retentionCheckMs <span class="token operator">=</span> config<span class="token punctuation">.</span>logCleanupIntervalMs<span class="token punctuation">,</span>
      maxPidExpirationMs <span class="token operator">=</span> config<span class="token punctuation">.</span>transactionalIdExpirationMs<span class="token punctuation">,</span>
      scheduler <span class="token operator">=</span> kafkaScheduler<span class="token punctuation">,</span>
      brokerTopicStats <span class="token operator">=</span> brokerTopicStats<span class="token punctuation">,</span>
      logDirFailureChannel <span class="token operator">=</span> logDirFailureChannel<span class="token punctuation">,</span>
      time <span class="token operator">=</span> time<span class="token punctuation">,</span>
      keepPartitionMetadataFile <span class="token operator">=</span> keepPartitionMetadataFile<span class="token punctuation">,</span>
      interBrokerProtocolVersion <span class="token operator">=</span> config<span class="token punctuation">.</span>interBrokerProtocolVersion<span class="token punctuation">)</span>
  <span class="token punctuation">}</span>

<span class="token punctuation">}</span>
</code></pre> 
<p>上面的<code>new LopManager</code> 是下面的</p> 
<h3><a id="1___74"></a>1 把日志清理加入定时任务中</h3> 
<pre><code class="prism language-scala"><span class="token comment">/**
 * The entry point to the kafka log management subsystem. The log manager is responsible for log creation, retrieval, and cleaning.
 * All read and write operations are delegated to the individual log instances.
 *kafka 日志管理子系统的入口点。日志管理器负责日志的创建、检索和清理。 所有读写操作都委托给各个日志实例
 * The log manager maintains logs in one or more directories. New logs are created in the data directory
 * with the fewest logs. No attempt is made to move partitions after the fact or balance based on
 * size or I/O rate.
 *日志管理器在一个或多个目录中维护日志。新日志在数据目录 中创建，日志最少。事后不会尝试移动分区或根据  大小或 I/O 速率进行平衡
 * A background thread handles log retention by periodically truncating excess log segments.
 * 后台线程通过定期截断多余的日志段来处理日志保留
 */</span>
<span class="token annotation punctuation">@threadsafe</span>
<span class="token keyword">class</span> LogManager<span class="token punctuation">(</span>logDirs<span class="token operator">:</span> Seq<span class="token punctuation">[</span>File<span class="token punctuation">]</span><span class="token punctuation">,</span>
                 initialOfflineDirs<span class="token operator">:</span> Seq<span class="token punctuation">[</span>File<span class="token punctuation">]</span><span class="token punctuation">,</span>
                 configRepository<span class="token operator">:</span> ConfigRepository<span class="token punctuation">,</span>
                 <span class="token keyword">val</span> initialDefaultConfig<span class="token operator">:</span> LogConfig<span class="token punctuation">,</span>
                 <span class="token keyword">val</span> cleanerConfig<span class="token operator">:</span> CleanerConfig<span class="token punctuation">,</span>
                 recoveryThreadsPerDataDir<span class="token operator">:</span> <span class="token builtin">Int</span><span class="token punctuation">,</span>
                 <span class="token keyword">val</span> flushCheckMs<span class="token operator">:</span> <span class="token builtin">Long</span><span class="token punctuation">,</span>
                 <span class="token keyword">val</span> flushRecoveryOffsetCheckpointMs<span class="token operator">:</span> <span class="token builtin">Long</span><span class="token punctuation">,</span>
                 <span class="token keyword">val</span> flushStartOffsetCheckpointMs<span class="token operator">:</span> <span class="token builtin">Long</span><span class="token punctuation">,</span>
                 <span class="token keyword">val</span> retentionCheckMs<span class="token operator">:</span> <span class="token builtin">Long</span><span class="token punctuation">,</span>
                 <span class="token keyword">val</span> maxPidExpirationMs<span class="token operator">:</span> <span class="token builtin">Int</span><span class="token punctuation">,</span>
                 interBrokerProtocolVersion<span class="token operator">:</span> ApiVersion<span class="token punctuation">,</span>
                 scheduler<span class="token operator">:</span> Scheduler<span class="token punctuation">,</span>
                 brokerTopicStats<span class="token operator">:</span> BrokerTopicStats<span class="token punctuation">,</span>
                 logDirFailureChannel<span class="token operator">:</span> LogDirFailureChannel<span class="token punctuation">,</span>
                 time<span class="token operator">:</span> Time<span class="token punctuation">,</span>
                 <span class="token keyword">val</span> keepPartitionMetadataFile<span class="token operator">:</span> <span class="token builtin">Boolean</span><span class="token punctuation">)</span> <span class="token keyword">extends</span> Logging <span class="token keyword">with</span> KafkaMetricsGroup <span class="token punctuation">{<!-- --></span>

  <span class="token keyword">import</span> LogManager<span class="token punctuation">.</span>_
<span class="token comment">//省略。。。。</span>

  <span class="token comment">/**
   *  Start the background threads to flush logs and do log cleanup
   *  启动后台线程以刷新日志并执行日志清理
   */</span>
  <span class="token keyword">def</span> startup<span class="token punctuation">(</span>topicNames<span class="token operator">:</span> Set<span class="token punctuation">[</span><span class="token builtin">String</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token builtin">Unit</span> <span class="token operator">=</span> <span class="token punctuation">{<!-- --></span>
    <span class="token comment">// ensure consistency between default config and overrides</span>
    <span class="token comment">//确保默认配置和覆盖之间的一致性</span>
    <span class="token keyword">val</span> defaultConfig <span class="token operator">=</span> currentDefaultConfig
    startupWithConfigOverrides<span class="token punctuation">(</span>defaultConfig<span class="token punctuation">,</span> fetchTopicConfigOverrides<span class="token punctuation">(</span>defaultConfig<span class="token punctuation">,</span> topicNames<span class="token punctuation">)</span><span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
  <span class="token comment">//把定时任务加入到scheduler中</span>
 <span class="token keyword">private</span><span class="token punctuation">[</span>log<span class="token punctuation">]</span> <span class="token keyword">def</span> startupWithConfigOverrides<span class="token punctuation">(</span>defaultConfig<span class="token operator">:</span> LogConfig<span class="token punctuation">,</span> topicConfigOverrides<span class="token operator">:</span> Map<span class="token punctuation">[</span><span class="token builtin">String</span><span class="token punctuation">,</span> LogConfig<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token builtin">Unit</span> <span class="token operator">=</span> <span class="token punctuation">{<!-- --></span>
    loadLogs<span class="token punctuation">(</span>defaultConfig<span class="token punctuation">,</span> topicConfigOverrides<span class="token punctuation">)</span> <span class="token comment">// this could take a while if shutdown was not clean</span>

    <span class="token comment">/* Schedule the cleanup task to delete old logs */</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>scheduler <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
      scheduler<span class="token punctuation">.</span>schedule<span class="token punctuation">(</span><span class="token string">"kafka-log-retention"</span><span class="token punctuation">,</span>
                         <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">=&gt;</span> cleanupLogs<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
                         InitialTaskDelayMs<span class="token punctuation">,</span>
                         retentionCheckMs<span class="token punctuation">)</span>
   <span class="token comment">//省略代码</span>
<span class="token punctuation">}</span>                         

</code></pre> 
<h2><a id="_133"></a>三、清理符合条件的日志</h2> 
<pre><code class="prism language-scala"> <span class="token comment">/**
   * 删除任何符合条件的日志。返回删除的段数。
   * 只考虑未压缩的日志。
   */</span>
  <span class="token keyword">def</span> cleanupLogs<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token builtin">Unit</span> <span class="token operator">=</span> <span class="token punctuation">{<!-- --></span>
     <span class="token comment">//省略代码</span>
    <span class="token keyword">try</span> <span class="token punctuation">{<!-- --></span>
      deletableLogs<span class="token punctuation">.</span>foreach <span class="token punctuation">{<!-- --></span>
        <span class="token keyword">case</span> <span class="token punctuation">(</span>topicPartition<span class="token punctuation">,</span> log<span class="token punctuation">)</span> <span class="token keyword">=&gt;</span>
          debug<span class="token punctuation">(</span><span class="token string-interpolation"><span class="token id function">s</span><span class="token string">"Garbage collecting '</span><span class="token interpolation"><span class="token punctuation">${<!-- --></span><span class="token expression">log<span class="token punctuation">.</span>name</span><span class="token punctuation">}</span></span><span class="token string">'"</span></span><span class="token punctuation">)</span>
          total <span class="token operator">+=</span> log<span class="token punctuation">.</span>deleteOldSegments<span class="token punctuation">(</span><span class="token punctuation">)</span>
      <span class="token punctuation">}</span>
    <span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{<!-- --></span>
      <span class="token comment">//省略代码</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
</code></pre> 
<p>上面<code>log.deleteOldSegments()</code> 调用的是<strong>Log.scala</strong>的<code>deleteOldSegments</code></p> 
<pre><code class="prism language-scala"><span class="token comment">/**
   *如果启用了主题删除，请删除由于基于时间的保留 ,或由于日志大小大于保留大小而过期的任何日志段。
   * 无论是否启用删除，删除日志开始偏移量之前的所有日志段
   */</span>
  <span class="token keyword">def</span> deleteOldSegments<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token builtin">Int</span> <span class="token operator">=</span> <span class="token punctuation">{<!-- --></span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>config<span class="token punctuation">.</span>delete<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
      <span class="token comment">//删除LogStartOffset日志之前的所有的segment</span>
      deleteLogStartOffsetBreachedSegments<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span>
      <span class="token comment">//删除超出的保留大小段</span>
        deleteRetentionSizeBreachedSegments<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span>
      <span class="token comment">//删除超过保存时间的</span>
        deleteRetentionMsBreachedSegments<span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{<!-- --></span>
      <span class="token comment">//删除LogStartOffset日志之前的所有的segment</span>
      deleteLogStartOffsetBreachedSegments<span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>

  <span class="token keyword">private</span> <span class="token keyword">def</span> deleteRetentionMsBreachedSegments<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token builtin">Int</span> <span class="token operator">=</span> <span class="token punctuation">{<!-- --></span>
    <span class="token comment">//retention.ms 小于0代表不设置保存时间</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>config<span class="token punctuation">.</span>retentionMs <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token number">0</span>
    <span class="token keyword">val</span> startMs <span class="token operator">=</span> time<span class="token punctuation">.</span>milliseconds

    <span class="token comment">//当前时间减去segment追后修改时间，是否大于设置的超时时间</span>
    <span class="token keyword">def</span> shouldDelete<span class="token punctuation">(</span>segment<span class="token operator">:</span> LogSegment<span class="token punctuation">,</span> nextSegmentOpt<span class="token operator">:</span> Option<span class="token punctuation">[</span>LogSegment<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token builtin">Boolean</span> <span class="token operator">=</span> <span class="token punctuation">{<!-- --></span>
      startMs <span class="token operator">-</span> segment<span class="token punctuation">.</span>largestTimestamp <span class="token operator">&gt;</span> config<span class="token punctuation">.</span>retentionMs
    <span class="token punctuation">}</span>

    deleteOldSegments<span class="token punctuation">(</span>shouldDelete<span class="token punctuation">,</span> RetentionMsBreach<span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
  <span class="token punctuation">}</span>

  <span class="token keyword">private</span> <span class="token keyword">def</span> deleteRetentionSizeBreachedSegments<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token builtin">Int</span> <span class="token operator">=</span> <span class="token punctuation">{<!-- --></span>
    <span class="token comment">//retention.bytes 小于0代表不删，或者当前topic的此分区的日志大小小于设置的值，也不用删</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>config<span class="token punctuation">.</span>retentionSize <span class="token operator">&lt;</span> <span class="token number">0</span> <span class="token operator">||</span> size <span class="token operator">&lt;</span> config<span class="token punctuation">.</span>retentionSize<span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token number">0</span>
    <span class="token comment">//retentionSize代表分区最小保留大小，而diff代表超过多少</span>
    <span class="token keyword">var</span> diff <span class="token operator">=</span> size <span class="token operator">-</span> config<span class="token punctuation">.</span>retentionSize
    <span class="token keyword">def</span> shouldDelete<span class="token punctuation">(</span>segment<span class="token operator">:</span> LogSegment<span class="token punctuation">,</span> nextSegmentOpt<span class="token operator">:</span> Option<span class="token punctuation">[</span>LogSegment<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token builtin">Boolean</span> <span class="token operator">=</span> <span class="token punctuation">{<!-- --></span>

      <span class="token keyword">if</span> <span class="token punctuation">(</span>diff <span class="token operator">-</span> segment<span class="token punctuation">.</span>size <span class="token operator">&gt;=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token comment">//意味着删除segment后，仍然有足够的空间（diff是一个表示剩余segment的变量），</span>
        <span class="token comment">// 那么该segment应该被删除。在这种情况下，diff的值会减去segment的大小，并返回true。</span>
        diff <span class="token operator">-=</span> segment<span class="token punctuation">.</span>size
        <span class="token boolean">true</span>
      <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{<!-- --></span>
        <span class="token comment">//如果diff - segment.size的结果小于0，意味着删除segment后剩余的segment不满足retentionSize</span>
        <span class="token boolean">false</span>
      <span class="token punctuation">}</span>

    deleteOldSegments<span class="token punctuation">(</span>shouldDelete<span class="token punctuation">,</span> RetentionSizeBreach<span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
  <span class="token punctuation">}</span>

  <span class="token keyword">private</span> <span class="token keyword">def</span> deleteLogStartOffsetBreachedSegments<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token builtin">Int</span> <span class="token operator">=</span> <span class="token punctuation">{<!-- --></span>
    <span class="token keyword">def</span> shouldDelete<span class="token punctuation">(</span>segment<span class="token operator">:</span> LogSegment<span class="token punctuation">,</span> nextSegmentOpt<span class="token operator">:</span> Option<span class="token punctuation">[</span>LogSegment<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token builtin">Boolean</span> <span class="token operator">=</span> <span class="token punctuation">{<!-- --></span>
      nextSegmentOpt<span class="token punctuation">.</span>exists<span class="token punctuation">(</span>_<span class="token punctuation">.</span>baseOffset <span class="token operator">&lt;=</span> logStartOffset<span class="token punctuation">)</span>
    <span class="token punctuation">}</span>

    deleteOldSegments<span class="token punctuation">(</span>shouldDelete<span class="token punctuation">,</span> StartOffsetBreach<span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
 <span class="token comment">/**
   * 删除从最旧的段开始并向前移动的任何本地日志段，直到用户提供的谓词为 false 或达到包含当前高水位线的段。
   * 我们不会删除偏移量等于或超过高水位线的段，以确保日志开始偏移量永远不会超过它。
   * 如果高水位线尚未初始化，则没有段符合删除条件。
   * @param predicate  一个函数，它接受候选日志段和下一个更高的段（如果有的话）并返回 true if 它是可删除的
   * @param reason The reason for the segment deletion 段删除的原因
   * @return The number of segments deleted
   */</span>
  <span class="token keyword">private</span> <span class="token keyword">def</span> deleteOldSegments<span class="token punctuation">(</span>predicate<span class="token operator">:</span> <span class="token punctuation">(</span>LogSegment<span class="token punctuation">,</span> Option<span class="token punctuation">[</span>LogSegment<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token keyword">=&gt;</span> <span class="token builtin">Boolean</span><span class="token punctuation">,</span>
                                reason<span class="token operator">:</span> SegmentDeletionReason<span class="token punctuation">)</span><span class="token operator">:</span> <span class="token builtin">Int</span> <span class="token operator">=</span> <span class="token punctuation">{<!-- --></span>
    <span class="token comment">//相当于在predicate外额外加的条件                 </span>
    <span class="token keyword">def</span> shouldDelete<span class="token punctuation">(</span>segment<span class="token operator">:</span> LogSegment<span class="token punctuation">,</span> nextSegmentOpt<span class="token operator">:</span> Option<span class="token punctuation">[</span>LogSegment<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token builtin">Boolean</span> <span class="token operator">=</span> <span class="token punctuation">{<!-- --></span>
      <span class="token comment">//检查高水位标记（highWatermark）是否大于等于下一个日志段的基础偏移量（baseOffset），以及predicate函数的返回值</span>
      highWatermark <span class="token operator">&gt;=</span> nextSegmentOpt<span class="token punctuation">.</span>map<span class="token punctuation">(</span>_<span class="token punctuation">.</span>baseOffset<span class="token punctuation">)</span><span class="token punctuation">.</span>getOrElse<span class="token punctuation">(</span>localLog<span class="token punctuation">.</span>logEndOffset<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span>
        predicate<span class="token punctuation">(</span>segment<span class="token punctuation">,</span> nextSegmentOpt<span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
    lock synchronized <span class="token punctuation">{<!-- --></span>
      <span class="token comment">//localLog.deletableSegments(shouldDelete)获取可删除的日志段</span>
      <span class="token keyword">val</span> deletable <span class="token operator">=</span> localLog<span class="token punctuation">.</span>deletableSegments<span class="token punctuation">(</span>shouldDelete<span class="token punctuation">)</span>
      <span class="token keyword">if</span> <span class="token punctuation">(</span>deletable<span class="token punctuation">.</span>nonEmpty<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token comment">//调用deleteSegments方法删除这些日志段</span>
        deleteSegments<span class="token punctuation">(</span>deletable<span class="token punctuation">,</span> reason<span class="token punctuation">)</span>
      <span class="token punctuation">}</span> <span class="token keyword">else</span>
        <span class="token number">0</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
</code></pre> 
<p>看上面的代码就知道，如果你配置了按<code>最大超时时间</code>和<code>日志最大存储大小</code>，那两个定时清理<code>都会被执行</code><br> 而针对<code>LogStartOffset</code>的清理，都会执行</p> 
<h3><a id="1deletableSegmentssegment_242"></a>1、deletableSegments(把需要删除的segment加入待删除的集合)</h3> 
<pre><code class="prism language-scala">
  <span class="token comment">/**
   * Find segments starting from the oldest until the user-supplied predicate is false.
   * A final segment that is empty will never be returned.
   * 查找从最旧的段开始，直到用户提供的谓词为 false。最后一个为空的段将永远不会返回。
   * @param predicate A function that takes in a candidate log segment, the next higher segment
   *                  (if there is one). It returns true iff the segment is deletable.
   *                  一个函数，它接收候选日志段，下一个更高的段（如果有的话）。如果段可删除，则返回 true。
   * @return the segments ready to be deleted
   */</span>
  <span class="token keyword">private</span><span class="token punctuation">[</span>log<span class="token punctuation">]</span> <span class="token keyword">def</span> deletableSegments<span class="token punctuation">(</span>predicate<span class="token operator">:</span> <span class="token punctuation">(</span>LogSegment<span class="token punctuation">,</span> Option<span class="token punctuation">[</span>LogSegment<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token keyword">=&gt;</span> <span class="token builtin">Boolean</span><span class="token punctuation">)</span><span class="token operator">:</span> Iterable<span class="token punctuation">[</span>LogSegment<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{<!-- --></span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>segments<span class="token punctuation">.</span>isEmpty<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
      Seq<span class="token punctuation">.</span>empty
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{<!-- --></span>
      <span class="token keyword">val</span> deletable <span class="token operator">=</span> ArrayBuffer<span class="token punctuation">.</span>empty<span class="token punctuation">[</span>LogSegment<span class="token punctuation">]</span>
      <span class="token keyword">val</span> segmentsIterator <span class="token operator">=</span> segments<span class="token punctuation">.</span>values<span class="token punctuation">.</span>iterator
      <span class="token keyword">var</span> segmentOpt <span class="token operator">=</span> nextOption<span class="token punctuation">(</span>segmentsIterator<span class="token punctuation">)</span>
      <span class="token comment">//遍历所有的segment</span>
      <span class="token keyword">while</span> <span class="token punctuation">(</span>segmentOpt<span class="token punctuation">.</span>isDefined<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token keyword">val</span> segment <span class="token operator">=</span> segmentOpt<span class="token punctuation">.</span>get
        <span class="token keyword">val</span> nextSegmentOpt <span class="token operator">=</span> nextOption<span class="token punctuation">(</span>segmentsIterator<span class="token punctuation">)</span>
        <span class="token comment">//下一个segment为null，并且当前segment的大小为0则不允许删除</span>
        <span class="token keyword">val</span> isLastSegmentAndEmpty <span class="token operator">=</span> nextSegmentOpt<span class="token punctuation">.</span>isEmpty <span class="token operator">&amp;&amp;</span> segment<span class="token punctuation">.</span>size <span class="token operator">==</span> <span class="token number">0</span>
        <span class="token comment">//还需要通过predicate方法判断，这个是通过传入的</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>predicate<span class="token punctuation">(</span>segment<span class="token punctuation">,</span> nextSegmentOpt<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span>isLastSegmentAndEmpty<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
          deletable <span class="token operator">+=</span> segment
          segmentOpt <span class="token operator">=</span> nextSegmentOpt
        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{<!-- --></span>
          segmentOpt <span class="token operator">=</span> Option<span class="token punctuation">.</span>empty
        <span class="token punctuation">}</span>
      <span class="token punctuation">}</span>
      deletable
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
</code></pre> 
<p>这里需要注意,不管是哪种删除方式把segment加入待删除集合，必须有<code>isLastSegmentAndEmpty</code>的判断，代表的是如果此<code>segment</code>是最后一个(<code>nextSegmentOpt.isEmpty</code>为true时，代表没有下一个<code>segment</code>并且最后一个<code>segment</code>中数据为不存在(空文件)是不允许删除<code>segment</code>，原因是没有删除的必要</p> 
<h4><a id="1logStartOffsetsegmentbaseOffset_282"></a>(1)如果主题分区的logStartOffset大于segment的baseOffset</h4> 
<p><code>deleteLogStartOffsetBreachedSegments</code>函数传给<code>deleteOldSegments</code>的<code>predicate</code>是</p> 
<pre><code class="prism language-scala"> <span class="token keyword">def</span> shouldDelete<span class="token punctuation">(</span>segment<span class="token operator">:</span> LogSegment<span class="token punctuation">,</span> nextSegmentOpt<span class="token operator">:</span> Option<span class="token punctuation">[</span>LogSegment<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token builtin">Boolean</span> <span class="token operator">=</span> <span class="token punctuation">{<!-- --></span>
      nextSegmentOpt<span class="token punctuation">.</span>exists<span class="token punctuation">(</span>_<span class="token punctuation">.</span>baseOffset <span class="token operator">&lt;=</span> logStartOffset<span class="token punctuation">)</span>
 <span class="token punctuation">}</span>
</code></pre> 
<p>而<code>deleteOldSegments</code>传给<code>deletableSegments</code>的<code>localLog.deletableSegments</code>的predicate是</p> 
<pre><code class="prism language-scala"> <span class="token keyword">def</span> shouldDelete<span class="token punctuation">(</span>segment<span class="token operator">:</span> LogSegment<span class="token punctuation">,</span> nextSegmentOpt<span class="token operator">:</span> Option<span class="token punctuation">[</span>LogSegment<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token builtin">Boolean</span> <span class="token operator">=</span> <span class="token punctuation">{<!-- --></span>
      <span class="token comment">//1、检查高水位标记（highWatermark）是否大于等于下一个日志段的基础偏移量（baseOffset），如果baseOffset不存在，则获得当前主题分区的logEndOffset值，</span>
      <span class="token comment">//2、deleteLogStartOffsetBreachedSegments传过来的predicate函数</span>
      highWatermark <span class="token operator">&gt;=</span> nextSegmentOpt<span class="token punctuation">.</span>map<span class="token punctuation">(</span>_<span class="token punctuation">.</span>baseOffset<span class="token punctuation">)</span><span class="token punctuation">.</span>getOrElse<span class="token punctuation">(</span>localLog<span class="token punctuation">.</span>logEndOffset<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span>
        predicate<span class="token punctuation">(</span>segment<span class="token punctuation">,</span> nextSegmentOpt<span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>主题分区的<code>logStartOffset</code> 要大于下一个<code>segment</code>的<code>baseOffset</code>，所以<code>deleteLogStartOffsetBreachedSegments</code>方法要把<code>segment</code>加入到待删除的列表条件</p> 
<ol><li>至少两个<code>segment</code>，后面第二个<code>segment</code>的<code>baseOffset</code>要大于等于主题分区的<code>logStartOffset</code></li><li>要把第一个<code>segment</code>加入待删除列表，后面第二个<code>segment</code>的<code>baseOffset</code>(如果不存在，则用主题分区的<code>logEndOffset</code>代替)要大于等于主题分区的<code>highWatermark</code></li><li>当前segment为空文件，不允许删</li></ol> 
<h4><a id="2retentionbytes_306"></a>(2)如果主题分区文件总大小大于配置中retention.bytes(最大留存大小)</h4> 
<p><code>deleteRetentionSizeBreachedSegments</code>函数传给<code>deleteOldSegments</code>的<code>predicate</code>是</p> 
<pre><code class="prism language-scala"> <span class="token keyword">def</span> shouldDelete<span class="token punctuation">(</span>segment<span class="token operator">:</span> LogSegment<span class="token punctuation">,</span> nextSegmentOpt<span class="token operator">:</span> Option<span class="token punctuation">[</span>LogSegment<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token builtin">Boolean</span> <span class="token operator">=</span> <span class="token punctuation">{<!-- --></span>
       <span class="token keyword">if</span> <span class="token punctuation">(</span>diff <span class="token operator">-</span> segment<span class="token punctuation">.</span>size <span class="token operator">&gt;=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token comment">//意味着删除segment后，仍然有足够的空间（diff是一个表示剩余segment的变量），</span>
        <span class="token comment">// 那么该segment应该被删除。在这种情况下，diff的值会减去segment的大小，并返回true。</span>
        diff <span class="token operator">-=</span> segment<span class="token punctuation">.</span>size
        <span class="token boolean">true</span>
      <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{<!-- --></span>
        <span class="token comment">//如果diff - segment.size的结果小于0，意味着删除segment后剩余的segment不满足retentionSize</span>
        <span class="token boolean">false</span>
      <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
</code></pre> 
<p>而<code>deleteOldSegments</code>传给<code>deletableSegments</code>的<code>localLog.deletableSegments</code>的<code>predicate</code>是</p> 
<pre><code class="prism language-scala"> <span class="token keyword">def</span> shouldDelete<span class="token punctuation">(</span>segment<span class="token operator">:</span> LogSegment<span class="token punctuation">,</span> nextSegmentOpt<span class="token operator">:</span> Option<span class="token punctuation">[</span>LogSegment<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token builtin">Boolean</span> <span class="token operator">=</span> <span class="token punctuation">{<!-- --></span>
      <span class="token comment">//1、检查高水位标记（highWatermark）是否大于等于下一个日志段的基础偏移量（baseOffset），如果baseOffset不存在，则获得当前主题分区的logEndOffset值，</span>
      <span class="token comment">//2、deleteRetentionSizeBreachedSegments传过来的predicate函数</span>
      highWatermark <span class="token operator">&gt;=</span> nextSegmentOpt<span class="token punctuation">.</span>map<span class="token punctuation">(</span>_<span class="token punctuation">.</span>baseOffset<span class="token punctuation">)</span><span class="token punctuation">.</span>getOrElse<span class="token punctuation">(</span>localLog<span class="token punctuation">.</span>logEndOffset<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span>
        predicate<span class="token punctuation">(</span>segment<span class="token punctuation">,</span> nextSegmentOpt<span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre> 
<p><code>segment</code>遍历时，会迭代<strong>diff</strong>判断是否大于设置的阈值(<code>retention.bytes</code>)，<code>deleteRetentionSizeBreachedSegments</code>方法要把符合条件的<code>segment</code>加入到待删除的列表</p> 
<ol><li>分区的全部的<code>segment</code>文件大小总和大于配置的<code>retention.bytes</code></li><li>要把第一个<code>segment</code>加入待删除列表，后面第二个<code>segment</code>的<code>baseOffset</code>(如果不存在，则用主题分区的<code>logEndOffset</code>代替)要大于等于主题分区的<code>highWatermark</code></li><li>当前segment为空文件，不允许删</li></ol> 
<h4><a id="3segmentretentionms_339"></a>(3)如果主题分区各个segment的修改时间和当前时间差大于配置的retention.ms(最大留存时间)</h4> 
<p><code>deleteRetentionMsBreachedSegments</code>函数传给<code>deleteOldSegments</code>的<code>predicate</code>是</p> 
<pre><code class="prism language-scala"><span class="token keyword">val</span> startMs <span class="token operator">=</span> time<span class="token punctuation">.</span>milliseconds
 <span class="token comment">//当前时间减去segment追后修改时间，是否大于设置的超时时间</span>
    <span class="token keyword">def</span> shouldDelete<span class="token punctuation">(</span>segment<span class="token operator">:</span> LogSegment<span class="token punctuation">,</span> nextSegmentOpt<span class="token operator">:</span> Option<span class="token punctuation">[</span>LogSegment<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token builtin">Boolean</span> <span class="token operator">=</span> <span class="token punctuation">{<!-- --></span>
      startMs <span class="token operator">-</span> segment<span class="token punctuation">.</span>largestTimestamp <span class="token operator">&gt;</span> config<span class="token punctuation">.</span>retentionMs
 <span class="token punctuation">}</span>
</code></pre> 
<p>而<code>deleteOldSegments</code>传给<code>deletableSegments</code>的<code>localLog.deletableSegments</code>的<code>predicate</code>是</p> 
<pre><code class="prism language-scala"> <span class="token keyword">def</span> shouldDelete<span class="token punctuation">(</span>segment<span class="token operator">:</span> LogSegment<span class="token punctuation">,</span> nextSegmentOpt<span class="token operator">:</span> Option<span class="token punctuation">[</span>LogSegment<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token builtin">Boolean</span> <span class="token operator">=</span> <span class="token punctuation">{<!-- --></span>
      <span class="token comment">//1、检查高水位标记（highWatermark）是否大于等于下一个日志段的基础偏移量（baseOffset），如果baseOffset不存在，则获得当前主题分区的logEndOffset值，</span>
      <span class="token comment">//2、deleteRetentionMsBreachedSegments传过来的predicate函数</span>
      highWatermark <span class="token operator">&gt;=</span> nextSegmentOpt<span class="token punctuation">.</span>map<span class="token punctuation">(</span>_<span class="token punctuation">.</span>baseOffset<span class="token punctuation">)</span><span class="token punctuation">.</span>getOrElse<span class="token punctuation">(</span>localLog<span class="token punctuation">.</span>logEndOffset<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span>
        predicate<span class="token punctuation">(</span>segment<span class="token punctuation">,</span> nextSegmentOpt<span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>当前的<code>segment</code>文件的<code>largestTimestamp</code>和当前系统时间的差值大于<code>retention.ms</code>，则会判定需要删除此<code>segment</code><br> 所以条件总结:</p> 
<ol><li>segment的最后修改时间和当前系统时间差值大于配置的<code>retention.bytes</code></li><li>要把第一个<code>segment</code>加入待删除列表，后面第二个<code>segment</code>的<code>baseOffset</code>(如果不存在，则用主题分区的<code>logEndOffset</code>代替)要大于等于主题分区的<code>highWatermark</code></li><li>当前segment为空文件，不允许删</li></ol> 
<h3><a id="2segment_363"></a>2、把上面待删除segment执行删除操作</h3> 
<p>如果上面待删除segment集合不为空则执行删除操作</p> 
<pre><code class="prism language-scala"><span class="token keyword">if</span> <span class="token punctuation">(</span>deletable<span class="token punctuation">.</span>nonEmpty<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token comment">//调用deleteSegments方法删除这些日志段</span>
        deleteSegments<span class="token punctuation">(</span>deletable<span class="token punctuation">,</span> reason<span class="token punctuation">)</span>
 <span class="token punctuation">}</span>
</code></pre> 
<p>其中<code>deleteSegments</code>的方法实现如下</p> 
<pre><code class="prism language-scala">  <span class="token comment">// deletable是一个可迭代对象，表示要删除的日志段。</span>
  <span class="token comment">//reason是一个SegmentDeletionReason类型的参数，表示删除日志段的原因。</span>
  <span class="token keyword">private</span> <span class="token keyword">def</span> deleteSegments<span class="token punctuation">(</span>deletable<span class="token operator">:</span> Iterable<span class="token punctuation">[</span>LogSegment<span class="token punctuation">]</span><span class="token punctuation">,</span> reason<span class="token operator">:</span> SegmentDeletionReason<span class="token punctuation">)</span><span class="token operator">:</span> <span class="token builtin">Int</span> <span class="token operator">=</span> <span class="token punctuation">{<!-- --></span>
    maybeHandleIOException<span class="token punctuation">(</span><span class="token string-interpolation"><span class="token id function">s</span><span class="token string">"Error while deleting segments for </span><span class="token interpolation"><span class="token punctuation">$</span><span class="token expression">topicPartition</span></span><span class="token string"> in dir </span><span class="token interpolation"><span class="token punctuation">${<!-- --></span><span class="token expression">dir<span class="token punctuation">.</span>getParent</span><span class="token punctuation">}</span></span><span class="token string">"</span></span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
      <span class="token comment">//numToDelete表示要删除的日志段数量。</span>
      <span class="token keyword">val</span> numToDelete <span class="token operator">=</span> deletable<span class="token punctuation">.</span>size
      <span class="token keyword">if</span> <span class="token punctuation">(</span>numToDelete <span class="token operator">&gt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token comment">//如果要删除的日志段数量等于当前日志的所有日志段数量，即localLog.segments.numberOfSegments等于numToDelete，则先创建一个新的日志段。</span>
        <span class="token keyword">var</span> segmentsToDelete <span class="token operator">=</span> deletable
        <span class="token keyword">if</span> <span class="token punctuation">(</span>localLog<span class="token punctuation">.</span>segments<span class="token punctuation">.</span>numberOfSegments <span class="token operator">==</span> numToDelete<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
          <span class="token keyword">val</span> newSegment <span class="token operator">=</span> roll<span class="token punctuation">(</span><span class="token punctuation">)</span>
          <span class="token comment">//如果要删除的最后一个日志段的基准偏移量等于新创建的日志段的基准偏移量，说明删除了一个空的活动日志段并重新创建了一个新的日志段，会打印警告信息。</span>
          <span class="token keyword">if</span> <span class="token punctuation">(</span>deletable<span class="token punctuation">.</span>last<span class="token punctuation">.</span>baseOffset <span class="token operator">==</span> newSegment<span class="token punctuation">.</span>baseOffset<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
            warn<span class="token punctuation">(</span><span class="token string-interpolation"><span class="token id function">s</span><span class="token string">"Empty active segment at </span><span class="token interpolation"><span class="token punctuation">${<!-- --></span><span class="token expression">deletable<span class="token punctuation">.</span>last<span class="token punctuation">.</span>baseOffset</span><span class="token punctuation">}</span></span><span class="token string"> was deleted and recreated due to </span><span class="token interpolation"><span class="token punctuation">$</span><span class="token expression">reason</span></span><span class="token string">"</span></span><span class="token punctuation">)</span>
            segmentsToDelete <span class="token operator">=</span> deletable<span class="token punctuation">.</span>dropRight<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>
          <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
        <span class="token comment">//用于检查内存映射缓冲区是否关闭。</span>
        localLog<span class="token punctuation">.</span>checkIfMemoryMappedBufferClosed<span class="token punctuation">(</span><span class="token punctuation">)</span>
        <span class="token comment">//用于从日志中移除并删除指定的日志段。asyncDelete=true代表采用异步的方式删除日志端</span>
        localLog<span class="token punctuation">.</span>removeAndDeleteSegments<span class="token punctuation">(</span>segmentsToDelete<span class="token punctuation">,</span> asyncDelete <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">,</span> reason<span class="token punctuation">)</span>
        <span class="token comment">//删除生产者快照。</span>
        deleteProducerSnapshots<span class="token punctuation">(</span>deletable<span class="token punctuation">,</span> asyncDelete <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">)</span>
        <span class="token comment">//根据删除的日志段更新日志的起始偏移量。</span>
        maybeIncrementLogStartOffset<span class="token punctuation">(</span>localLog<span class="token punctuation">.</span>segments<span class="token punctuation">.</span>firstSegmentBaseOffset<span class="token punctuation">.</span>get<span class="token punctuation">,</span> LogStartOffsetIncrementReason<span class="token punctuation">.</span>SegmentDeletion<span class="token punctuation">)</span>
      <span class="token punctuation">}</span>
      numToDelete
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
</code></pre> 
<h4><a id="1segmentdeleted_405"></a>1、把segment文件后缀改成.deleted</h4> 
<pre><code class="prism language-scala"><span class="token comment">/**
   *此方法通过对每个日志段执行以下操作来删除给定的日志段：
   * - 它从段映射中删除段，以便它不再用于读取。
   * - 它通过将 .delete 附加到相应的文件名来重命名索引和日志文件
   * - 它可以计划将来发生的异步删除操作或同步执行删除
   *异步删除允许在不同步的情况下并发进行读取，并且不可能在读取文件时物理删除文件。
   *此方法不会将 IOException 转换为 KafkaStorageException，直接调用方应捕获并处理 IOException。
   * @param segmentsToDelete The log segments to schedule for deletion 要计划删除的日志段
   * @param asyncDelete Whether the segment files should be deleted as ynchronously 是否应异步删除段文件
   * @param reason The reason for the segment deletion 段删除的原因
   */</span>
  <span class="token keyword">private</span><span class="token punctuation">[</span>log<span class="token punctuation">]</span> <span class="token keyword">def</span> removeAndDeleteSegments<span class="token punctuation">(</span>segmentsToDelete<span class="token operator">:</span> Iterable<span class="token punctuation">[</span>LogSegment<span class="token punctuation">]</span><span class="token punctuation">,</span>
                                           asyncDelete<span class="token operator">:</span> <span class="token builtin">Boolean</span><span class="token punctuation">,</span>
                                           reason<span class="token operator">:</span> SegmentDeletionReason<span class="token punctuation">)</span><span class="token operator">:</span> <span class="token builtin">Unit</span> <span class="token operator">=</span> <span class="token punctuation">{<!-- --></span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>segmentsToDelete<span class="token punctuation">.</span>nonEmpty<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
      <span class="token keyword">val</span> toDelete <span class="token operator">=</span> segmentsToDelete<span class="token punctuation">.</span>toList
      reason<span class="token punctuation">.</span>logReason<span class="token punctuation">(</span>toDelete<span class="token punctuation">)</span>
      toDelete<span class="token punctuation">.</span>foreach <span class="token punctuation">{<!-- --></span> segment <span class="token keyword">=&gt;</span>
        segments<span class="token punctuation">.</span>remove<span class="token punctuation">(</span>segment<span class="token punctuation">.</span>baseOffset<span class="token punctuation">)</span>
      <span class="token punctuation">}</span>
      LocalLog<span class="token punctuation">.</span>deleteSegmentFiles<span class="token punctuation">(</span>toDelete<span class="token punctuation">,</span> asyncDelete<span class="token punctuation">,</span> dir<span class="token punctuation">,</span> topicPartition<span class="token punctuation">,</span> config<span class="token punctuation">,</span> scheduler<span class="token punctuation">,</span> logDirFailureChannel<span class="token punctuation">,</span> logIdent<span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
</code></pre> 
<pre><code class="prism language-scala"><span class="token comment">/**
   *对给定段的索引和日志文件执行物理删除。在删除之前，通过将 .delete 附加到相应的文件名来重命名索引和日志文件。允许选择性地异步删除这些文件。
   *这个方法假定该文件存在。
   * 它不需要将IOException（从changeFile后缀抛出）转换为KafkaStorageException，
   * 因为它要么在加载所有日志之前调用，要么调用方将捕获并处理IOException。
   */</span>
  <span class="token keyword">private</span><span class="token punctuation">[</span>log<span class="token punctuation">]</span> <span class="token keyword">def</span> deleteSegmentFiles<span class="token punctuation">(</span>segmentsToDelete<span class="token operator">:</span> immutable<span class="token punctuation">.</span>Iterable<span class="token punctuation">[</span>LogSegment<span class="token punctuation">]</span><span class="token punctuation">,</span>
                                      asyncDelete<span class="token operator">:</span> <span class="token builtin">Boolean</span><span class="token punctuation">,</span>
                                      dir<span class="token operator">:</span> File<span class="token punctuation">,</span>
                                      topicPartition<span class="token operator">:</span> TopicPartition<span class="token punctuation">,</span>
                                      config<span class="token operator">:</span> LogConfig<span class="token punctuation">,</span>
                                      scheduler<span class="token operator">:</span> Scheduler<span class="token punctuation">,</span>
                                      logDirFailureChannel<span class="token operator">:</span> LogDirFailureChannel<span class="token punctuation">,</span>
                                      logPrefix<span class="token operator">:</span> <span class="token builtin">String</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token builtin">Unit</span> <span class="token operator">=</span> <span class="token punctuation">{<!-- --></span>
    <span class="token comment">//遍历所有的待删除的segment，把segment文件后缀改成.deleted</span>
    segmentsToDelete<span class="token punctuation">.</span>foreach <span class="token punctuation">{<!-- --></span> segment <span class="token keyword">=&gt;</span>
      <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>segment<span class="token punctuation">.</span>hasSuffix<span class="token punctuation">(</span>LogFileUtils<span class="token punctuation">.</span>DELETED_FILE_SUFFIX<span class="token punctuation">)</span><span class="token punctuation">)</span>
        segment<span class="token punctuation">.</span>changeFileSuffixes<span class="token punctuation">(</span><span class="token string">""</span><span class="token punctuation">,</span> LogFileUtils<span class="token punctuation">.</span>DELETED_FILE_SUFFIX<span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
    <span class="token comment">//删除segment具体方法</span>
    <span class="token keyword">def</span> deleteSegments<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token builtin">Unit</span> <span class="token operator">=</span> <span class="token punctuation">{<!-- --></span>
      info<span class="token punctuation">(</span><span class="token string-interpolation"><span class="token id function">s</span><span class="token string">"</span><span class="token interpolation"><span class="token punctuation">${<!-- --></span><span class="token expression">logPrefix</span><span class="token punctuation">}</span></span><span class="token string">Deleting segment files </span><span class="token interpolation"><span class="token punctuation">${<!-- --></span><span class="token expression">segmentsToDelete<span class="token punctuation">.</span>mkString<span class="token punctuation">(</span><span class="token string">","</span><span class="token punctuation">)</span></span><span class="token punctuation">}</span></span><span class="token string">"</span></span><span class="token punctuation">)</span>
      <span class="token comment">//获取dir的父目录，并赋值给parentDir变量。</span>
      <span class="token keyword">val</span> parentDir <span class="token operator">=</span> dir<span class="token punctuation">.</span>getParent
      maybeHandleIOException<span class="token punctuation">(</span>logDirFailureChannel<span class="token punctuation">,</span> parentDir<span class="token punctuation">,</span> <span class="token string-interpolation"><span class="token id function">s</span><span class="token string">"Error while deleting segments for </span><span class="token interpolation"><span class="token punctuation">$</span><span class="token expression">topicPartition</span></span><span class="token string"> in dir </span><span class="token interpolation"><span class="token punctuation">$</span><span class="token expression">parentDir</span></span><span class="token string">"</span></span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token comment">//遍历segmentsToDelete列表中的每个元素（即要删除的文件），并调用deleteIfExists()方法删除文件。</span>
        segmentsToDelete<span class="token punctuation">.</span>foreach <span class="token punctuation">{<!-- --></span> segment <span class="token keyword">=&gt;</span>
          segment<span class="token punctuation">.</span>deleteIfExists<span class="token punctuation">(</span><span class="token punctuation">)</span>
        <span class="token punctuation">}</span>
      <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
    <span class="token comment">//asyncDelete为true，代表是异步删除，加入到scheduler，并且只执行一次</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>asyncDelete<span class="token punctuation">)</span>
      scheduler<span class="token punctuation">.</span>scheduleOnce<span class="token punctuation">(</span><span class="token string">"delete-file"</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">=&gt;</span> deleteSegments<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> config<span class="token punctuation">.</span>fileDeleteDelayMs<span class="token punctuation">)</span>
    <span class="token keyword">else</span>
      deleteSegments<span class="token punctuation">(</span><span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
</code></pre> 
<h4><a id="2delete_473"></a>2、异步执行删除文件后缀是.delete的文件(加入只执行一次定时任务中)</h4> 
<p>上面的<code>deleteSegments</code>方法内<br> 调用 <code>localLog.removeAndDeleteSegments(segmentsToDelete, asyncDelete = true, reason)</code> 中<code>asyncDelete</code>为true，所以采用异步方式删除segment</p> 
<h2><a id="segment_478"></a>四，segment相关文件有哪些整理</h2> 
<blockquote> 
 <p>下面的每一个segment有什么，可以看<a href="https://blog.csdn.net/weixin_38653290/article/details/86621811">Kafka的Log存储原理再析</a>，下面是我复制过来的一张图</p> 
</blockquote> 
<p>主要是index,log,timeindexs三种文件，<br> <img src="https://images2.imgbox.com/73/5b/gmmKnsjP_o.png" alt="在这里插入图片描述"><br> 而index和log文件的映射是下面这种<br> <img src="https://images2.imgbox.com/ba/1a/0SXEV3kB_o.png" alt="在这里插入图片描述"></p> 
<p>定时删除日志段就会把要删除的log文件后缀改成.delete</p> 
<h2><a id="_489"></a>五、问题:</h2> 
<h3><a id="1segment_490"></a>1、如果segment最大留存时间和分区最大留存文件大小都不配置会出现什么情况？</h3> 
<p>答：分区的segment不会被删除，可能会出现磁盘满了，而根据<code>LogStartOffset</code>删除只是删除补偿机制，只要<code>LogStartOffset</code>不主动更新，则不会删除旧的<code>segment</code></p> 
<h3><a id="2segment_492"></a>2、如果只配置segment最大留存时间，并且数据量非常小，能消费最大留存时间之前的数据吗？</h3> 
<p>答：不可以，因为如果segment会删除重新建一个新的segemnt，</p> 
<h3><a id="3_494"></a>3、如果只是配置分区最大留存文件大小，并且数据量非常小，能消费到很久以前的吗？</h3> 
<p>答:可以，前提是数据量要小于分区最大留存文件大小，举例，segment为1G，retention.bytes=1G，现在这个分区的从开始生产消息到现在才500M数据，消费者就可以配置消费策略，重头开始消费，就能消费到生产者很久以前生产到此分区的第一条数据</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/6919ce2d5057e70eb847ae01619af636/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">uniapp、vue实现滑动拼图验证码</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/31a2ff5ac10b34973bb6fb2690ccec5e/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">Nodejs错误处理详细指南</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>