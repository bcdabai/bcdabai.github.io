<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>09、秒懂 Java CompletableFuture ( 下 ) - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="09、秒懂 Java CompletableFuture ( 下 )" />
<meta property="og:description" content="上一章节中我们讲解了 CompletableFuture 的一些基本用法，比如如何使用和如何处理异步计算结果。本章节我们继续，主要讲解如何使用 CompletableFuture 来组合异步计算的结果
组合 Futures CompletableFuture API 最吸引人的部分，应该是能够在一系列链式计算步骤中组合 CompletableFuture 实例。这种链式的结果本身就是CompletableFuture，允许进一步链接和组合。
这种方法在函数式语言中无处不在，通常被称为 「一元 ( monadic ) 设计模式 」。
CompletableFuture 提供了方法 thenCompose() 用于按顺序链接两个 Futures。该方法的参数是一个能够返回 CompletableFuture 实例的函数或表达式。而该函数或表达式的参数则是先前计算步骤的结果，这允许我们在下一个 CompletableFuture 的 lambda 中使用这个值。
例如下面这个示例
CompletableFuture&lt;String&gt; completableFuture = CompletableFuture.supplyAsync(() -&gt; DDKK.COM 弟弟快看) .thenCompose(s -&gt; CompletableFuture.supplyAsync(() -&gt; s &#43; 程序员编程资料站)); assertEquals(&#34;DDKK.COM 弟弟快看，程序员编程资料站&#34;, completableFuture.get()); thenCompose() 方法与 thenApply() 一起实现了一元设计模式的基本构建块，它们与Java 8 中提供的 Stream 和 Optional 类的 map 和flatMap 方法密切相关。
两个方法都接收一个函数并将其应用于计算结果，但 thenCompose() （ flatMap() ）方法接收一个函数，该函数返回相同类型的另一个对象，这样，就允许将这些类的实例组合为构建块。
如果要执行两个独立的 Futures 并对其结果执行某些操作，可以使用 Future 的 thenCombine() 并传递能够接收两个参数的函数或表达式来处理这两个结果。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/d229e88a75a4180e61a59a7626bb9f44/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-01-15T23:35:36+08:00" />
<meta property="article:modified_time" content="2023-01-15T23:35:36+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">09、秒懂 Java CompletableFuture ( 下 )</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p>上一章节中我们讲解了 CompletableFuture 的一些基本用法，比如如何使用和如何处理异步计算结果。本章节我们继续，主要讲解如何使用 CompletableFuture 来组合异步计算的结果</p> 
<p><a name="_label0"></a></p> 
<h3>组合 Futures</h3> 
<p>CompletableFuture API 最吸引人的部分，应该是能够在一系列链式计算步骤中组合 CompletableFuture 实例。这种链式的结果本身就是CompletableFuture，允许进一步链接和组合。</p> 
<p>这种方法在函数式语言中无处不在，通常被称为 「一元 ( monadic ) 设计模式 」。</p> 
<p>CompletableFuture 提供了方法 thenCompose() 用于按顺序链接两个 Futures。该方法的参数是一个能够返回 CompletableFuture 实例的函数或表达式。而该函数或表达式的参数则是先前计算步骤的结果，这允许我们在下一个 CompletableFuture 的 lambda 中使用这个值。</p> 
<p>例如下面这个示例</p> 
<pre><code>CompletableFuture&lt;String&gt; completableFuture 
  = CompletableFuture.supplyAsync(() -&gt; DDKK.COM 弟弟快看)
    .thenCompose(s -&gt; CompletableFuture.supplyAsync(() -&gt; s +  程序员编程资料站));

assertEquals("DDKK.COM 弟弟快看，程序员编程资料站", completableFuture.get());
</code></pre> 
<p>thenCompose() 方法与 thenApply() 一起实现了一元设计模式的基本构建块，它们与Java 8 中提供的 Stream 和 Optional 类的 map 和flatMap 方法密切相关。</p> 
<p>两个方法都接收一个函数并将其应用于计算结果，但 thenCompose() （ flatMap() ）方法接收一个函数，该函数返回相同类型的另一个对象，这样，就允许将这些类的实例组合为构建块。</p> 
<p>如果要执行两个独立的 Futures 并对其结果执行某些操作，可以使用 Future 的 thenCombine() 并传递能够接收两个参数的函数或表达式来处理这两个结果。</p> 
<pre><code>CompletableFuture&lt;String&gt; completableFuture 
  = CompletableFuture.supplyAsync(() -&gt; "Hello")
    .thenCombine(CompletableFuture.supplyAsync(
      () -&gt; " World"), (s1, s2) -&gt; s1 + s2));

assertEquals("Hello World", completableFuture.get());

</code></pre> 
<p>更简单的情况是，当你想要使用两个 Futures 的结果时，但有不想把任何结果值传递给 Future 链，则可以使用 thenAcceptBoth() 方法，如下所示</p> 
<pre><code>CompletableFuture future = CompletableFuture.supplyAsync(() -&gt; "Hello")
  .thenAcceptBoth(CompletableFuture.supplyAsync(() -&gt; " World"),
    (s1, s2) -&gt; System.out.println(s1 + s2));

</code></pre> 
<p><a name="_label1"></a></p> 
<h3>并行执行多个 Future</h3> 
<p>当我们需要并行执行多个 Futures 时，通常是希望等待所有 Futures 执行完成然后处理它们的组合结果。</p> 
<p>CompletableFuture.allOf() 静态方法允许等待作为 var-arg 提供的所有 Future 的完成。</p> 
<pre><code>CompletableFuture&lt;String&gt; future1  
  = CompletableFuture.supplyAsync(() -&gt; "Hello");
CompletableFuture&lt;String&gt; future2  
  = CompletableFuture.supplyAsync(() -&gt; "Beautiful");
CompletableFuture&lt;String&gt; future3  
  = CompletableFuture.supplyAsync(() -&gt; "World");

CompletableFuture&lt;Void&gt; combinedFuture 
  = CompletableFuture.allOf(future1, future2, future3);

// ...

combinedFuture.get();

assertTrue(future1.isDone());
assertTrue(future2.isDone());
assertTrue(future3.isDone());

</code></pre> 
<blockquote> 
 <p>var-arg 的意思是：参数数量不定的意思。也就是可以传递任意相同类型的参数。</p> 
</blockquote> 
<p>上面的示例中，你应该留意到了 CompletableFuture.allOf() 方法的返回类型是 CompletableFuture <code>&lt;Void&gt;</code>，这个方法的局限是它不会返回所有 Future 的综合结果。相反，你必须手动从 Futures 获取结果。幸运的是，CompletableFuture.join() 方法和 Java 8 Streams API 可以做到这一点</p> 
<pre><code>String combined = Stream.of(future1, future2, future3)
  .map(CompletableFuture::join)
  .collect(Collectors.joining(" "));

assertEquals("Hello Beautiful World", combined);

</code></pre> 
<p>CompletableFuture.join() 方法类似于 get() 方法，但是如果 Future 未正常完成，它会抛出未经检查的异常，这种机制，使得它可以作为 Stream.map() 的参数。</p> 
<p><a name="_label2"></a></p> 
<h3>处理错误</h3> 
<p>对于异步计算步骤链中的错误处理，惯用的方法是调整 throw/catch 。</p> 
<p>怎么个调整法呢 ？</p> 
<p>CompletableFuture 类允许我们在特殊的 handle() 方法中处理它，而不是在语法块中捕获异常。</p> 
<p>此handle() 方法接收接收两个参数：计算结果（ 如果成功完成 ）和抛出异常（ 如果某些计算步骤未正常完成 ）。</p> 
<pre><code>String name = null;

// ...

CompletableFuture&lt;String&gt; completableFuture  
  =  CompletableFuture.supplyAsync(() -&gt; {
      if (name == null) {
          throw new RuntimeException("Computation error!");
      }
      return "Hello, " + name;
  })}).handle((s, t) -&gt; s != null ? s : "Hello, Stranger!");

assertEquals("Hello, Stranger!", completableFuture.get());
</code></pre> 
<p>上面这个示例中，我们使用 handle() 方法在问候语的异步计算完成时提供默认值，因为没有提供 name 。</p> 
<p>作为替代方案，假设我们想要手动使用某个值完成 Future ，就像第一个示例中所示，但同时又需要有能力通过异常完成它。那么，可以使用 completeExceptionally() 方法。</p> 
<pre><code>CompletableFuture&lt;String&gt; completableFuture = new CompletableFuture&lt;&gt;();

// ...

completableFuture.completeExceptionally(
  new RuntimeException("Calculation failed!"));

// ...

completableFuture.get(); // ExecutionException
</code></pre> 
<p>上面这个示例的 completableFuture.get() 方法会抛出 ExecutionException，并使用RuntimeException 作为异常发生的原因。</p> 
<p>在上面的例子中，我们也可以使用 handle() 方法异步处理异常，但使用 get() 方法是更典型的同步异常处理机制。</p> 
<p><a name="_label3"></a></p> 
<h3>异步方法</h3> 
<p>CompletableFuture 类中的大多数流式 API 方法都又两个带有 Async 后缀的变体。这些变体方法通常用于在另一个线程中运行相应的执行步骤。</p> 
<ul><li>没有 Async 后缀的方法使用当前调用线程运行下一个执行阶段。</li><li>不带 Executor 参数的 Async 后缀方法使用 ForkJoinPool.commonPool() 方法访问 Executor 的公共 fork/join 线程池实现运行一个步骤。</li><li>带有 Executor 参数的 Async 后缀方法使用传递的 Executor 运行一个步骤。</li></ul> 
<p>下面这个范例中，我们使用了 Function 实例处理计算结果。和之前范例的唯一可见的区别就是 thenApplyAsync() 方法。但在幕后，函数的应用程序被包装到 ForkJoinTask 实例中（ 有关 fork/join 框架的更多信息，请阅读我们的 一文秒懂 Java Fork/Join ），这样可以进一步并行化我们的计算并更有效地使用系统资源。</p> 
<pre><code>CompletableFuture&lt;String&gt; completableFuture  
  = CompletableFuture.supplyAsync(() -&gt; "Hello");

CompletableFuture&lt;String&gt; future = completableFuture
  .thenApplyAsync(s -&gt; s + " World");

assertEquals("Hello World", future.get());

</code></pre> 
<p><a name="_label4"></a></p> 
<h3>Java 9 CompletableFuture 新增的 API</h3> 
<p>Java 9 提供了一下变更进一步强化了 CompletableFuture：</p> 
<ul><li>添加了新的工厂方法</li><li>支持延时和超时</li><li>改进了对子类化的支持</li></ul> 
<p>Java 9 同时也引入了新的 CompletableFuture 实例 API</p> 
<ul><li>Executor defaultExecutor()</li><li>CompletableFuture<code>&lt;U&gt;</code> newIncompleteFuture()</li><li>CompletableFuture<code>&lt;T&gt;</code> copy()</li><li>CompletionStage<code>&lt;T&gt;</code> minimalCompletionStage()</li><li>CompletableFuture<code>&lt;T&gt;</code> completeAsync(Supplier<code>&lt;? extends T&gt;</code> supplier, Executor executor)</li><li>CompletableFuture<code>&lt;T&gt;</code> completeAsync(Supplier<code>&lt;? extends T&gt;</code> supplier)</li><li>CompletableFuture<code>&lt;T&gt;</code> orTimeout(long timeout, TimeUnit unit)</li><li>CompletableFuture<code>&lt;T&gt;</code> completeOnTimeout(T value, long timeout, TimeUnit unit)</li></ul> 
<p>还添加了一些静态的使用方法</p> 
<ul><li>Executor delayedExecutor(long delay, TimeUnit unit, Executor executor)</li><li>Executor delayedExecutor(long delay, TimeUnit unit)</li><li><code>&lt;U&gt;</code> CompletionStage<code>&lt;U&gt;</code> completedStage(U value)</li><li><code>&lt;U&gt;</code> CompletionStage<code>&lt;U&gt;</code> failedStage(Throwable ex)</li><li><code>&lt;U&gt;</code> CompletableFuture<code>&lt;U&gt;</code> failedFuture(Throwable ex)</li></ul> 
<p>最后，为了解决超时问题，Java 9 引入了另外两个新功能</p> 
<ul><li>orTimeout()</li><li>completeOnTimeout()</li></ul>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/1fbf29ce0bd8a9f23e9b80f6a4e9a877/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">用火狐浏览器看b站视频默认没有声音</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/9e342d6271466eeffa9210d59ef4fb82/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">centos7 scl工具集升级gcc和g&#43;&#43;（简易版）</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>