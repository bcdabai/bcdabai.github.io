<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>算法——排序——快速排序图解动画 - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="算法——排序——快速排序图解动画" />
<meta property="og:description" content="快速排序 简介代码示例排序过程时间复杂度最差时间复杂度最优时间复杂度 &amp;&amp; 平均时间复杂度 空间复杂度稳定性 简介 快速排序是二分法排序。首先会选择一个基准元素，然后将基准值和元素内其他元素进行比较。数组一轮遍历后的结果为基准元素以外的元素分为[比基准值小]和[比基准值大]两个类别。整体数组为[比基准值小]基准元素[比基准值大]的结构。
然后再对两个[]中的元素进行排序，重复上述步骤，直到数组排序完成。
文章中使用的动画网站地址，限 pc: 排序算法动画
http://www.donghuasuanfa.com/sort
代码示例 伪代码来自维基百科
algorithm quicksort(A, lo, hi) is if lo &lt; hi then p := partition(A, lo, hi) quicksort(A, lo, p) quicksort(A, p &#43; 1, hi) algorithm partition(A, lo, hi) is pivot := A[ floor((hi &#43; lo) / 2) ] i := lo - 1 j := hi &#43; 1 loop forever do i := i &#43; 1 while A[i] &lt; pivot do j := j - 1 while A[j] &gt; pivot if i ≥ j then return j swap A[i] with A[j] 排序过程 排序算法动画地址 http://www." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/b3be14acad48a5a06cf78b06c6afbe06/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2021-07-08T09:17:13+08:00" />
<meta property="article:modified_time" content="2021-07-08T09:17:13+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">算法——排序——快速排序图解动画</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p></p> 
<div class="toc"> 
 <h4>快速排序</h4> 
 <ul><li><a href="#_1" rel="nofollow">简介</a></li><li><a href="#_8" rel="nofollow">代码示例</a></li><li><a href="#_32" rel="nofollow">排序过程</a></li><li><a href="#_56" rel="nofollow">时间复杂度</a></li><li><ul><li><a href="#_61" rel="nofollow">最差时间复杂度</a></li><li><a href="#___68" rel="nofollow">最优时间复杂度 &amp;&amp; 平均时间复杂度</a></li></ul> 
  </li><li><a href="#_76" rel="nofollow">空间复杂度</a></li><li><a href="#_79" rel="nofollow">稳定性</a></li></ul> 
</div> 
<p></p> 
<h2><a id="_1"></a>简介</h2> 
<p>        快速排序是二分法排序。首先会选择一个<font color="blue">基准元素</font>，然后将<font color="blue">基准值</font>和元素内其他元素进行比较。数组一轮遍历后的结果为基准元素以外的元素分为[比基准值小]和[比基准值大]两个类别。整体数组为[<font color="gray">比基准值小</font>]<font color="blue">基准元素</font>[<font color="purple">比基准值大</font>]的结构。<br>         然后再对两个[]中的元素进行排序，重复上述步骤，直到数组排序完成。</p> 
<p>文章中使用的动画网站地址，限 pc: <a href="http://www.donghuasuanfa.com/sort" rel="nofollow">排序算法动画</a><br> http://www.donghuasuanfa.com/sort</p> 
<h2><a id="_8"></a>代码示例</h2> 
<p>伪代码来自维基百科</p> 
<pre><code>algorithm quicksort(A, lo, hi) is
    if lo &lt; hi then
        p := partition(A, lo, hi)
        quicksort(A, lo, p)
        quicksort(A, p + 1, hi)

algorithm partition(A, lo, hi) is
    pivot := A[ floor((hi + lo) / 2) ]
    i := lo - 1
    j := hi + 1
    loop forever
        do
            i := i + 1
        while A[i] &lt; pivot
        do
            j := j - 1
        while A[j] &gt; pivot
        if i ≥ j then
            return j
        swap A[i] with A[j]
</code></pre> 
<h2><a id="_32"></a>排序过程</h2> 
<p>        <a href="http://www.donghuasuanfa.com/sort" rel="nofollow">排序算法动画地址</a> http://www.donghuasuanfa.com/sort</p> 
<p>        首先设置最右侧的元素为基准元素，然后坑位定在左侧第一个元素位置。坑位的作用是保证左侧的元素都比基准元素小，右侧的元素都比基准元素大。<br>         顺序遍历数组中每一个元素比较基准元素和各个元素，比较分为俩种情况：<br>         一：如果遍历的元素比基准元素小，则交换坑位所处元素和当前遍历的元素，坑位向右侧移动一个位置。<br>         二：如果遍历元素比基准元素大，则无需交换位置。<br>         最终遍历一次数组后。保证坑位的左侧都比基准元素小，右侧都比基准元素大。</p> 
<p>        下图1-1示例中。首先设置最右侧29为基准元素。然后和35进行比较，35比基准元素29大，所以比较后只标记颜色即可。<br>         然后基准元素29和第二个元素20进行比较。由于20比29小，所以将坑位所在元素35和20互换位置，然后坑位向右侧移动1的位置。<br>         基准元素29再比较第三个元素21。由于21比29小，所以将21和坑位所在元素35互换位置，然后坑位再向右侧移动1的位置。保证坑位的左侧数组的值都为比基准元素小，右侧数组的值都比基准元素大，坑位的位置基本都为右侧紫色子数组的第一个元素，。<br> <img src="https://images2.imgbox.com/1b/c2/C4G823bP_o.gif" alt="在这里插入图片描述"></p> 
<center>
  图1-1 
</center> 
<p>        遍历一轮数组后，保证坑位位置的左侧都比基准元素29小，坑位位置的右侧都比基准元素29大。然后将基准元素和坑位元素交换位置。</p> 
<p>        下图1-2示例中。当前数组最后遍历14的元素，由于14的元素比基准元素小，所以将14的比较元素和坑位所在元素进行位置互换，然后将坑位向右移动。<br>         遍历数组后，将基准元素29和坑位所在元素进行互换位置，则一轮的比较结束。然后再分别对两个子数组中的元素进行排序，重复上述步骤，直到数组排序完成。<br>         快速排序通过遍历元素和基准元素进行比较，找到能够将数组一份为2的位置(坑位)。然后再交换坑位和基准元素的位置，将数组一分为二。最后再递归子数组。直到数组都完成排序。<br> <img src="https://images2.imgbox.com/99/54/qC0zjrdT_o.gif" alt="请添加图片描述"></p> 
<center>
  图1-2 
</center> 
<h2><a id="_56"></a>时间复杂度</h2> 
<table><thead><tr><th>最差时间复杂度</th><th>平均时间复杂度</th><th>最优时间复杂度</th></tr></thead><tbody><tr><td><span class="katex--display"><span class="katex-display"><span class="katex"><span class="katex-mathml"> 
         
          
           
           
             O 
            
           
             ( 
            
            
            
              N 
             
            
              2 
             
            
           
             ) 
            
           
          
            O(N^2) 
           
          
        </span><span class="katex-html"><span class="base"><span class="strut" style="height: 1.11411em; vertical-align: -0.25em;"></span><span class="mord mathdefault" style="margin-right: 0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault" style="margin-right: 0.10903em;">N</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height: 0.864108em;"><span class="" style="top: -3.113em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span></span></span></td><td><span class="katex--display"><span class="katex-display"><span class="katex"><span class="katex-mathml"> 
         
          
           
           
             O 
            
           
             ( 
            
           
             N 
            
           
             ∗ 
            
           
             l 
            
           
             o 
            
            
            
              g 
             
            
              2 
             
            
           
             N 
            
           
             ) 
            
           
          
            O(N*log_{2}N) 
           
          
        </span><span class="katex-html"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathdefault" style="margin-right: 0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right: 0.10903em;">N</span><span class="mspace" style="margin-right: 0.222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right: 0.222222em;"></span></span><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathdefault" style="margin-right: 0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mord"><span class="mord mathdefault" style="margin-right: 0.03588em;">g</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.301108em;"><span class="" style="top: -2.55em; margin-left: -0.03588em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.15em;"><span class=""></span></span></span></span></span></span><span class="mord mathdefault" style="margin-right: 0.10903em;">N</span><span class="mclose">)</span></span></span></span></span></span></td><td><span class="katex--display"><span class="katex-display"><span class="katex"><span class="katex-mathml"> 
         
          
           
           
             O 
            
           
             ( 
            
           
             N 
            
           
             ∗ 
            
           
             l 
            
           
             o 
            
            
            
              g 
             
            
              2 
             
            
           
             N 
            
           
             ) 
            
           
          
            O(N*log_{2}N) 
           
          
        </span><span class="katex-html"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathdefault" style="margin-right: 0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right: 0.10903em;">N</span><span class="mspace" style="margin-right: 0.222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right: 0.222222em;"></span></span><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathdefault" style="margin-right: 0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mord"><span class="mord mathdefault" style="margin-right: 0.03588em;">g</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.301108em;"><span class="" style="top: -2.55em; margin-left: -0.03588em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.15em;"><span class=""></span></span></span></span></span></span><span class="mord mathdefault" style="margin-right: 0.10903em;">N</span><span class="mclose">)</span></span></span></span></span></span></td></tr></tbody></table> 
<h3><a id="_61"></a>最差时间复杂度</h3> 
<p>        最差的情况是O(N<sup>2</sup>)，每次分区的结果都是一侧全量数据，一侧无数据。则每次基准元素都要和数组内各个元素进行比较，且比较后无法将数组二等分。然后下一轮基准元素还是和数组内各个元素进行比较。所以时间复杂度为O(N<sup>2</sup>)。例:1,2,3,4。快速排序将退化为冒泡排序。</p> 
<p>如下图1-3所示:<br> <img src="https://images2.imgbox.com/b5/dc/g9nAydpk_o.gif" alt="在这里插入图片描述"></p> 
<center>
  图1-3 
</center> 
<h3><a id="___68"></a>最优时间复杂度 &amp;&amp; 平均时间复杂度</h3> 
<p>        最好的情况的时间复杂度为N * log<sub>2</sub>N。每次分区都很均匀。即数组能被二分分割。然后子元素再进行比较。<br>         首先基准元素需要和各个元素进行比较，此过程对应的时间复杂度为N。<br>         其次由于分区很均匀。 所以数组能被二分法分割，分割后，可同时对分割后子元素进行处理，对应的时间复杂度log<sub>2</sub>N。<br>         所以总的时间复杂度为 N * log<sub>2</sub>N。</p> 
<h2><a id="_76"></a>空间复杂度</h2> 
<p>快速排序需要一个栈空间来实现递归。最好的情况下，即快速排序的每一趟排序都将元素序列均匀地分割成长度相近的两个子表，所需栈的最大深度为log<sub>2</sub>(n+1)；但最坏的情况下，栈的最大深度为n。这样，快速排序的空间复杂度为O(log<sub>2</sub>n)</p> 
<h2><a id="_79"></a>稳定性</h2> 
<p>快速排序为不稳定排序，因为当基准元素和另外一个元素数值相同时，基准元素再和各个元素比较后可能变化位置。所以为不稳定排序。 例如 4,5,6,5<br> 如下图1-3所示:<br> <img src="https://images2.imgbox.com/14/4e/o1mwrPt6_o.gif" alt="在这里插入图片描述"></p> 
<center>
  图1-4 
</center>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/a0e35f8df0d99828c4d3f3469005a8f3/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">学习笔记-halcon-4</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/1f6985c2555966f9c94a719a768e1f60/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">element中input提交时提示input不能为空</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>