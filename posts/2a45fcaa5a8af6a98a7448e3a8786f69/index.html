<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>C&#43;&#43;11中的原子操作（atomic operation） - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="C&#43;&#43;11中的原子操作（atomic operation）" />
<meta property="og:description" content="所谓的原子操作，取的就是“原子是最小的、不可分割的最小个体”的意义，它表示在多个线程访问同一个全局资源的时候，能够确保所有其他的线程都不在同一时间内访问相同的资源。也就是他确保了在同一时刻只有唯一的线程对这个资源进行访问。这有点类似互斥对象对共享资源的访问的保护，但是原子操作更加接近底层，因而效率更高。
在以往的C&#43;&#43;标准中并没有对原子操作进行规定，我们往往是使用汇编语言，或者是借助第三方的线程库，例如intel的pthread来实现。在新标准C&#43;&#43;11，引入了原子操作的概念，并通过这个新的头文件提供了多种原子操作数据类型，例如，atomic_bool,atomic_int等等，如果我们在多个线程中对这些类型的共享资源进行操作，编译器将保证这些操作都是原子性的，也就是说，确保任意时刻只有一个线程对这个资源进行访问，编译器将保证，多个线程访问这个共享资源的正确性。从而避免了锁的使用，提高了效率。
我们还是来看一个实际的例子。假若我们要设计一个广告点击统计程序，在服务器程序中，使用多个线程模拟多个用户对广告的点击：
#include &lt;boost/thread/thread.hpp&gt; #include &lt;atomic&gt; #include &lt;iostream&gt; #include &lt;time.h&gt; using namespace std; // 全局的结果数据 long total = 0; // 点击函数 void click() { for(int i=0; i&lt;1000000;&#43;&#43;i) { // 对全局数据进行无锁访问 total &#43;= 1; } } int main(int argc, char* argv[]) { // 计时开始 clock_t start = clock(); // 创建100个线程模拟点击统计 boost::thread_group threads; for(int i=0; i&lt;100;&#43;&#43;i) { threads.create_thread(click); } threads.join_all(); // 计时结束 clock_t finish = clock(); // 输出结果 cout&lt;&lt;&#34;result:&#34;&lt;&lt;total&lt;&lt;endl; cout&lt;&lt;&#34;duration:&#34;&lt;&lt;finish -start&lt;&lt;&#34;" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/2a45fcaa5a8af6a98a7448e3a8786f69/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2013-04-23T10:57:49+08:00" />
<meta property="article:modified_time" content="2013-04-23T10:57:49+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">C&#43;&#43;11中的原子操作（atomic operation）</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p style="margin-top:0px; margin-bottom:1em; padding-top:0px; padding-bottom:0px; color:rgb(113,113,111); font-family:Verdana,Arial,Helvetica,sans-serif; font-size:14px; line-height:23px"> 所谓的原子操作，取的就是“原子是最小的、不可分割的最小个体”的意义，<span style="margin:0px; padding:0px; font-size:12pt; color:black; line-height:24px; font-family:宋体; letter-spacing:0.4pt">它表示在多个线程访问同一个全局资源的时候，能够确保所有其他的线程都不在同一时间内访问相同的资源。也就是他确保了在同一时刻只有唯一的线程对这个资源进行访问。这有点类似互斥对象对共享资源的访问的保护，但是原子操作更加接近底层，因而效率更高。</span></p> 
<p style="margin-top:0px; margin-bottom:1em; padding-top:0px; padding-bottom:0px; color:rgb(113,113,111); font-family:Verdana,Arial,Helvetica,sans-serif; font-size:14px; line-height:23px"> <span style="margin:0px; padding:0px; font-size:12pt; color:black; line-height:24px; font-family:宋体; letter-spacing:0.4pt">在以往的C++标准中并没有对原子操作进行规定，我们往往是使用汇编语言，或者是借助第三方的线程库，例如intel的pthread来实现。在新标准C++11，引入了原子操作的概念，并通过这个新的头文件提供了多种原子操作数据类型，例如，atomic_bool,atomic_int等等，如果我们在多个线程中对这些类型的共享资源进行操作，编译器将保证这些操作都是原子性的，也就是说，确保任意时刻只有一个线程对这个资源进行访问，编译器将保证，多个线程访问这个共享资源的正确性。从而避免了锁的使用，提高了效率。</span></p> 
<p style="margin-top:0px; margin-bottom:1em; padding-top:0px; padding-bottom:0px; color:rgb(113,113,111); font-family:Verdana,Arial,Helvetica,sans-serif; font-size:14px; line-height:23px"> <span style="margin:0px; padding:0px; font-size:12pt; color:black; line-height:24px; font-family:宋体; letter-spacing:0.4pt">我们还是来看一个实际的例子。假若我们要设计一个广告点击统计程序，在服务器程序中，使用多个线程模拟多个用户对广告的点击：</span></p> 
<p style="margin-top:0px; margin-bottom:1em; padding-top:0px; padding-bottom:0px; color:rgb(113,113,111); font-family:Verdana,Arial,Helvetica,sans-serif; font-size:14px; line-height:23px"> <span style="margin:0px; padding:0px; font-size:12pt; color:black; line-height:24px; font-family:宋体; letter-spacing:0.4pt">#include &lt;boost/thread/thread.hpp&gt;<br style="margin:0px; padding:0px"> #include &lt;atomic&gt; <br style="margin:0px; padding:0px"> #include &lt;iostream&gt;<br style="margin:0px; padding:0px"> #include &lt;time.h&gt;<br style="margin:0px; padding:0px"> <br style="margin:0px; padding:0px"> using namespace std;<br style="margin:0px; padding:0px"> // 全局的结果数据 <br style="margin:0px; padding:0px"> long total = 0; <br style="margin:0px; padding:0px"> <br style="margin:0px; padding:0px"> // 点击函数<br style="margin:0px; padding:0px"> void click()<br style="margin:0px; padding:0px"> {<!-- --><br style="margin:0px; padding:0px">     for(int i=0; i&lt;1000000;++i)<br style="margin:0px; padding:0px">     {<!-- --><br style="margin:0px; padding:0px">         // 对全局数据进行无锁访问 <br style="margin:0px; padding:0px">         total += 1;     <br style="margin:0px; padding:0px">     }<br style="margin:0px; padding:0px"> }<br style="margin:0px; padding:0px">  <br style="margin:0px; padding:0px">  <br style="margin:0px; padding:0px"> int main(int argc, char* argv[])<br style="margin:0px; padding:0px"> {<!-- --><br style="margin:0px; padding:0px">     // 计时开始<br style="margin:0px; padding:0px">     clock_t start = clock();<br style="margin:0px; padding:0px">     // 创建100个线程模拟点击统计<br style="margin:0px; padding:0px">     boost::thread_group threads;<br style="margin:0px; padding:0px">     for(int i=0; i&lt;100;++i) <br style="margin:0px; padding:0px">     {<!-- --><br style="margin:0px; padding:0px">         threads.create_thread(click);<br style="margin:0px; padding:0px">     }<br style="margin:0px; padding:0px"> <br style="margin:0px; padding:0px">     threads.join_all();<br style="margin:0px; padding:0px">     // 计时结束<br style="margin:0px; padding:0px">     clock_t finish = clock();<br style="margin:0px; padding:0px">     // 输出结果<br style="margin:0px; padding:0px">     cout&lt;&lt;"result:"&lt;&lt;total&lt;&lt;endl;<br style="margin:0px; padding:0px">     cout&lt;&lt;"duration:"&lt;&lt;finish -start&lt;&lt;"ms"&lt;&lt;endl;<br style="margin:0px; padding:0px">     return 0;<br style="margin:0px; padding:0px"> }<br style="margin:0px; padding:0px"> </span></p> 
<p style="margin-top:0px; margin-bottom:1em; padding-top:0px; padding-bottom:0px; color:rgb(113,113,111); font-family:Verdana,Arial,Helvetica,sans-serif; font-size:14px; line-height:23px"> 从执行的结果来看，这样的方法虽然非常快，但是结果不正确<br style="margin:0px; padding:0px"> E:\SourceCode\MinGW&gt;thread.exe<br style="margin:0px; padding:0px"> result:87228026<br style="margin:0px; padding:0px"> duration:528ms<br style="margin:0px; padding:0px"> <br style="margin:0px; padding:0px"> 很自然地，我们会想到使用互斥对象来对全局共享资源的访问进行保护，于是有了下面的实现：</p> 
<p style="margin-top:0px; margin-bottom:1em; padding-top:0px; padding-bottom:0px; color:rgb(113,113,111); font-family:Verdana,Arial,Helvetica,sans-serif; font-size:14px; line-height:23px"> long total = 0;<br style="margin:0px; padding:0px"> // 对共享资源进行保护的互斥对象<br style="margin:0px; padding:0px"> mutex m;<br style="margin:0px; padding:0px"> <br style="margin:0px; padding:0px"> void click()<br style="margin:0px; padding:0px"> {<!-- --><br style="margin:0px; padding:0px">     for(int i=0; i&lt;1000000;++i)<br style="margin:0px; padding:0px">     {<!-- --><br style="margin:0px; padding:0px">         // 访问之前，锁定互斥对象<br style="margin:0px; padding:0px">         m.lock();<br style="margin:0px; padding:0px">         total += 1;<br style="margin:0px; padding:0px">         // 访问完成后，释放互斥对象 <br style="margin:0px; padding:0px">         m.unlock();<br style="margin:0px; padding:0px">     }<br style="margin:0px; padding:0px"> }<br style="margin:0px; padding:0px"> 互斥对象的使用，保证了同一时刻只有唯一的一个线程对这个共享进行访问，从执行的结果来看，互斥对象保证了结果的正确性，但是也有非常大的性能损失，从刚才的528ms变成了现在的8431，用了原来时间的10多倍的时间。这个损失够大。<br style="margin:0px; padding:0px"> E:\SourceCode\MinGW&gt;thread.exe<br style="margin:0px; padding:0px"> result:100000000<br style="margin:0px; padding:0px"> duration:8431ms</p> 
<p style="margin-top:0px; margin-bottom:1em; padding-top:0px; padding-bottom:0px; color:rgb(113,113,111); font-family:Verdana,Arial,Helvetica,sans-serif; font-size:14px; line-height:23px"> 如果是在C++11之前，我们的解决方案也就到此为止了，但是，C++对性能的追求是永无止境的，他总是想尽一切办法榨干CPU的性能。在C++11中，实现了原子操作的数据类型（atomic_bool,atomic_int,atomic_long等等），对于这些原子数据类型的共享资源的访问，无需借助mutex等锁机制，也能够实现对共享资源的正确访问。</p> 
<p style="margin-top:0px; margin-bottom:1em; padding-top:0px; padding-bottom:0px; color:rgb(113,113,111); font-family:Verdana,Arial,Helvetica,sans-serif; font-size:14px; line-height:23px"> // 引入原子数据类型的头文件<br style="margin:0px; padding:0px"> #include &lt;atomic&gt; <br style="margin:0px; padding:0px">  <br style="margin:0px; padding:0px"> <br style="margin:0px; padding:0px"> // 用原子数据类型作为共享资源的数据类型<br style="margin:0px; padding:0px"> atomic_long total(0);<br style="margin:0px; padding:0px"> //long total = 0;<br style="margin:0px; padding:0px">  <br style="margin:0px; padding:0px"> void click()<br style="margin:0px; padding:0px"> {<!-- --><br style="margin:0px; padding:0px">     for(int i=0; i&lt;1000000;++i)<br style="margin:0px; padding:0px">     {<!-- --><br style="margin:0px; padding:0px">         // 仅仅是数据类型的不同而以，对其的访问形式与普通数据类型的资源并无区别<br style="margin:0px; padding:0px">         total += 1;<br style="margin:0px; padding:0px">     }<br style="margin:0px; padding:0px"> }</p> 
<p style="margin-top:0px; margin-bottom:1em; padding-top:0px; padding-bottom:0px; color:rgb(113,113,111); font-family:Verdana,Arial,Helvetica,sans-serif; font-size:14px; line-height:23px"> 我们来看看使用原子数据类型之后的效果如何：<br style="margin:0px; padding:0px"> E:\SourceCode\MinGW&gt;thread.exe<br style="margin:0px; padding:0px"> result:100000000<br style="margin:0px; padding:0px"> duration:2105ms</p> 
<p style="margin-top:0px; margin-bottom:1em; padding-top:0px; padding-bottom:0px; color:rgb(113,113,111); font-family:Verdana,Arial,Helvetica,sans-serif; font-size:14px; line-height:23px"> 结果正确！耗时只是使用mutex互斥对象的四分之一！也仅仅是不采用任何保护机制的时间的4倍。可以说这是一个非常不错的成绩了。</p> 
<p style="margin-top:0px; margin-bottom:1em; padding-top:0px; padding-bottom:0px; color:rgb(113,113,111); font-family:Verdana,Arial,Helvetica,sans-serif; font-size:14px; line-height:23px"> 原子操作的实现跟普通数据类型类似，但是它能够在保证结果正确的前提下，提供比mutex等锁机制更好的性能，如果我们要访问的共享资源可以用原子数据类型表示，那么在多线程程序中使用这种新的等价数据类型，是一个不错的选择。</p> 
<p style="margin-top:0px; margin-bottom:1em; padding-top:0px; padding-bottom:0px; color:rgb(113,113,111); font-family:Verdana,Arial,Helvetica,sans-serif; font-size:14px; line-height:23px"> 【转自：http://imcc.blogbus.com/logs/179131763.html】</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/9b925d9120e340c57bc1043f7a8f4ce0/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">Create user中采用externally操作系统认证方式详解</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/81d1d3c66d5e2ef254e7c56b14b625c3/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">温度场有限容积法程序入门之四：网格剖分.边界条件设置.迭代.导出后处理数据</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>