<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>阻塞队列LinkedBlockingDeque与LinkedBlockingQueue（三） - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="阻塞队列LinkedBlockingDeque与LinkedBlockingQueue（三）" />
<meta property="og:description" content="一、概述： 声明：本文转载为转载文章，原出处为：
Java并发学习(二十三)-LinkedBlockingQueue和LinkedBlockingDeque分析
LinkedBlockingDeque是基于链表的、线程安全的双端阻塞队列。LinkedBlockingQueue是基于链表的先进先出的阻塞队列。
特点：
链表结构（动态数组）通过ReentrantLock实现锁利用Condition实现队列的阻塞等待，唤醒LinkedBlockingQueue 这是一个先进先出的队列，通过ReentrantLock和两个Condition来实现并发安全与阻塞。它的结构基本字段如下：
/** * 基于链表。 * FIFO * 单向 *最大容量是Integer.MAX_VALUE. */ public class LinkedBlockingQueueAnalysis&lt;E&gt; extends AbstractQueue&lt;E&gt; implements BlockingQueue&lt;E&gt;, java.io.Serializable { /* * 两个方向。 * putLock * takeLock * 有些操作会需要同时获取两把锁。 * 例如remove操作，也需要获取两把锁 */ //主要的node节点 static class Node&lt;E&gt; { E item; Node&lt;E&gt; next; Node(E x) { item = x; } } //容量，一开始就固定了的。 private final int capacity; //用AtomicInteger 来记录数量。 private final AtomicInteger count = new AtomicInteger(); //head节点 head." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/5ec106bf1608ac928c6d1f91ce793b9e/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2018-06-08T15:34:32+08:00" />
<meta property="article:modified_time" content="2018-06-08T15:34:32+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">阻塞队列LinkedBlockingDeque与LinkedBlockingQueue（三）</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <h3>一、概述：</h3> 
<p>    <strong><span style="background-color:rgb(255,255,102);">声明：本文转载为转载文章，原出处为：</span></strong></p> 
<p><strong>    <a href="http://blog.csdn.net/anla_/article/details/79027867" style="background-color:rgb(255,255,102);">Java并发学习(二十三)-LinkedBlockingQueue和LinkedBlockingDeque分析</a></strong></p> 
<p>LinkedBlockingDeque是基于链表的、线程安全的双端阻塞队列。LinkedBlockingQueue是基于链表的先进先出的阻塞队列。</p> 
<p>特点：</p> 
<ul style="list-style:none;color:rgb(51,51,51);font-family:'-apple-system', 'SF UI Text', Arial, 'PingFang SC', 'Hiragino Sans GB', 'Microsoft YaHei', 'WenQuanYi Micro Hei', sans-serif, SimHei, SimSun;font-size:14px;background-color:rgb(255,255,255);"><li style="padding:0px;">链表结构（动态数组）</li><li style="padding:0px;">通过ReentrantLock实现锁</li><li style="padding:0px;">利用Condition实现队列的阻塞等待，唤醒<h3 style="padding:0px;font-family:'-apple-system', 'SF UI Text', Arial, 'PingFang SC', 'Hiragino Sans GB', 'Microsoft YaHei', 'WenQuanYi Micro Hei', sans-serif, SimHei, SimSun;background-color:rgb(255,255,255);">LinkedBlockingQueue</h3></li></ul> 
<p>这是一个先进先出的队列，通过<span style="font-family:'-apple-system', 'SF UI Text', Arial, 'PingFang SC', 'Hiragino Sans GB', 'Microsoft YaHei', 'WenQuanYi Micro Hei', sans-serif, SimHei, SimSun;background-color:rgb(255,255,255);">ReentrantLock和两个<span style="font-family:'-apple-system', 'SF UI Text', Arial, 'PingFang SC', 'Hiragino Sans GB', 'Microsoft YaHei', 'WenQuanYi Micro Hei', sans-serif, SimHei, SimSun;background-color:rgb(255,255,255);">Condition来实现并发安全与阻塞。<span style="font-family:'-apple-system', 'SF UI Text', Arial, 'PingFang SC', 'Hiragino Sans GB', 'Microsoft YaHei', 'WenQuanYi Micro Hei', sans-serif, SimHei, SimSun;background-color:rgb(255,255,255);">它的结构基本字段如下：</span></span></span></p> 
<pre><code class="language-java">/**
 * 基于链表。
 * FIFO
 * 单向
 *最大容量是Integer.MAX_VALUE.
 */
public class LinkedBlockingQueueAnalysis&lt;E&gt; extends AbstractQueue&lt;E&gt;
        implements BlockingQueue&lt;E&gt;, java.io.Serializable {
    /*
     * 两个方向。
     * putLock
     * takeLock
     * 有些操作会需要同时获取两把锁。
     * 例如remove操作，也需要获取两把锁
     */

    //主要的node节点
    static class Node&lt;E&gt; {
        E item;
        Node&lt;E&gt; next;
        Node(E x) { item = x; }
    }

    //容量，一开始就固定了的。
    private final int capacity;

    //用AtomicInteger 来记录数量。
    private final AtomicInteger count = new AtomicInteger();

    //head节点 head.item == null
    transient Node&lt;E&gt; head;

    //last节点，last.next == null
    private transient Node&lt;E&gt; last;

    //take锁
    private final ReentrantLock takeLock = new ReentrantLock();

    //等待take的节点序列。
    private final Condition notEmpty = takeLock.newCondition();

    //put的lock。
    private final ReentrantLock putLock = new ReentrantLock();

   //等待puts的队列。
    private final Condition notFull = putLock.newCondition();
    ...
}</code></pre> 
<h4 style="padding:0px;font-family:'-apple-system', 'SF UI Text', Arial, 'PingFang SC', 'Hiragino Sans GB', 'Microsoft YaHei', 'WenQuanYi Micro Hei', sans-serif, SimHei, SimSun;background-color:rgb(255,255,255);">put操作</h4> 
<pre><code class="language-java">public void put(E e) throws InterruptedException {
        if (e == null) throw new NullPointerException();   //e不能为null
        int c = -1;
        Node&lt;E&gt; node = new Node&lt;E&gt;(e);
        final ReentrantLock putLock = this.putLock;     //获取put锁
        final AtomicInteger count = this.count;          //获取count
        putLock.lockInterruptibly();
        try {
            while (count.get() == capacity) {        //如果满了，那么就需要使用notFull阻塞
                notFull.await();
            }
            enqueue(node);
            c = count.getAndIncrement();
            if (c + 1 &lt; capacity)                    //如果此时又有空间了，那么notFull唤醒
                notFull.signal();
        } finally {
            putLock.unlock();             //释放锁
        }
        if (c == 0)            //当c为0时候，也要根take锁说一下，并发下
            signalNotEmpty();        //调用notEmpty        
    }</code></pre> 
<code style="font-size:14px;line-height:22px;padding:4px 2px 0px;">enqueue</code> 
<span style="font-family:'-apple-system', 'SF UI Text', Arial, 'PingFang SC', 'Hiragino Sans GB', 'Microsoft YaHei', 'WenQuanYi Micro Hei', sans-serif, SimHei, SimSun;background-color:rgb(255,255,255);"> 方法：</span> 
<br> 
<pre><code class="language-java">private void enqueue(Node&lt;E&gt; node) {        //入对操作。
        last = last.next = node;      //队尾进
    }</code></pre> 
<code style="font-size:14px;line-height:22px;padding:4px 2px 0px;">signalNotEmpty</code> 
<span style="font-family:'-apple-system', 'SF UI Text', Arial, 'PingFang SC', 'Hiragino Sans GB', 'Microsoft YaHei', 'WenQuanYi Micro Hei', sans-serif, SimHei, SimSun;background-color:rgb(255,255,255);">方法：</span> 
<br> 
<pre><code class="language-java">private void signalNotEmpty() {
        final ReentrantLock takeLock = this.takeLock;
        takeLock.lock();        //加锁
        try {
            notEmpty.signal();    //用于signal，notEmpty
        } finally {
            takeLock.unlock();
        }
    }</code></pre> 
<h4 style="padding:0px;font-family:'-apple-system', 'SF UI Text', Arial, 'PingFang SC', 'Hiragino Sans GB', 'Microsoft YaHei', 'WenQuanYi Micro Hei', sans-serif, SimHei, SimSun;background-color:rgb(255,255,255);">take操作</h4> 
<span style="font-family:'-apple-system', 'SF UI Text', Arial, 'PingFang SC', 'Hiragino Sans GB', 'Microsoft YaHei', 'WenQuanYi Micro Hei', sans-serif, SimHei, SimSun;background-color:rgb(255,255,255);">take操作，就是从队列里面弹出一个元素，下面看它的详细代码：</span> 
<br> 
<pre><code class="language-java">public E take() throws InterruptedException {
        E x;
        int c = -1;            //设定一个记录变量
        final AtomicInteger count = this.count;     //获得count
        final ReentrantLock takeLock = this.takeLock;
        takeLock.lockInterruptibly();        //加锁
        try {
            while (count.get() == 0) {       //如果没有元素，那么就阻塞性等待
                notEmpty.await();
            }
            x = dequeue();            //一定可以拿到。
            c = count.getAndDecrement();
            if (c &gt; 1)
                notEmpty.signal();        //报告还有元素，唤醒队列
        } finally {
            takeLock.unlock();
        }
        if (c == capacity)
            signalNotFull();           //解锁
        return x;
    }</code></pre> 
<span style="font-family:'-apple-system', 'SF UI Text', Arial, 'PingFang SC', 'Hiragino Sans GB', 'Microsoft YaHei', 'WenQuanYi Micro Hei', sans-serif, SimHei, SimSun;background-color:rgb(255,255,255);">接下来看</span> 
<code style="font-size:14px;line-height:22px;padding:4px 2px 0px;">dequeue</code> 
<span style="font-family:'-apple-system', 'SF UI Text', Arial, 'PingFang SC', 'Hiragino Sans GB', 'Microsoft YaHei', 'WenQuanYi Micro Hei', sans-serif, SimHei, SimSun;background-color:rgb(255,255,255);">方法：</span> 
<br> 
<pre><code class="language-java">private E dequeue() {
        Node&lt;E&gt; h = head;
        Node&lt;E&gt; first = h.next;
        h.next = h;        // help GC 指向自己，帮助gc回收
        head = first;
        E x = first.item;       //从队头出。
        first.item = null;      //将head.item设为null。
        return x;
    }</code></pre> 
<span style="font-family:'-apple-system', 'SF UI Text', Arial, 'PingFang SC', 'Hiragino Sans GB', 'Microsoft YaHei', 'WenQuanYi Micro Hei', sans-serif, SimHei, SimSun;background-color:rgb(255,255,255);">对于LinkedBlockingQueue来说，有两个ReentrantLock分别控制队头和队尾，这样就可以使得添加操作分开来做，一般的操作是获取一把锁就可以，但有些操作例如remove操作，则需要同时获取两把锁：</span> 
<br> 
<pre><code class="language-java">public boolean remove(Object o) {
        if (o == null) return false;
        fullyLock();     //获取锁
        try {
            for (Node&lt;E&gt; trail = head, p = trail.next;
                 p != null;
                 trail = p, p = p.next) {     //依次循环遍历
                if (o.equals(p.item)) {       //找到了
                    unlink(p, trail);       //解除链接
                    return true;
                }
            }
            return false;        //没找到，或者解除失败
        } finally {
            fullyUnlock();
        }
    }</code></pre> 
<h3 style="padding:0px;font-family:'-apple-system', 'SF UI Text', Arial, 'PingFang SC', 'Hiragino Sans GB', 'Microsoft YaHei', 'WenQuanYi Micro Hei', sans-serif, SimHei, SimSun;background-color:rgb(255,255,255);">LinkedBlockingDeque</h3> 
<span style="font-family:'-apple-system', 'SF UI Text', Arial, 'PingFang SC', 'Hiragino Sans GB', 'Microsoft YaHei', 'WenQuanYi Micro Hei', sans-serif, SimHei, SimSun;background-color:rgb(255,255,255);">名字很相近，LinkedBlockingDeque就是一个双端队列，任何一端都可以进行元素的出入，接下来看它的主要字段：</span> 
<br> 
<pre><code class="language-java">/**
 * 双端队列。
 * 最大值是Integer.MAX_VALUE
 * 所谓弱一致性有利于删除，有点理解了，
 * 或许是比如clear方法，不知直接把引用置为null，而是一个个解除连接。
 * 利用lock锁去控制并发访问，利用condition去控制阻塞
 * weakly consistent的iterators。
 * 我们需要保持所有的node都要是gc可达的。
 */
public class LinkedBlockingDeque&lt;E&gt;
    extends AbstractQueue&lt;E&gt;
    implements BlockingDeque&lt;E&gt;, java.io.Serializable {
    //双向联结的节点。
    static final class Node&lt;E&gt; {
        E item;    //泛型的item变量

        // 前一个节点
        Node&lt;E&gt; prev;

        //next后一个节点
        Node&lt;E&gt; next;

        Node(E x) {
            item = x;
        }
    }

    //头节点
    transient Node&lt;E&gt; first;

    //尾节点。
    transient Node&lt;E&gt; last;

    //count，表示数值。
    private transient int count;

    //容量
    private final int capacity;

    //实现控制访问的锁
    final ReentrantLock lock = new ReentrantLock();

    //take的Condition
    private final Condition notEmpty = lock.newCondition();

    //put的Condition
    private final Condition notFull = lock.newCondition();
    ...
}</code></pre> 
<p style="font-family:'-apple-system', 'SF UI Text', Arial, 'PingFang SC', 'Hiragino Sans GB', 'Microsoft YaHei', 'WenQuanYi Micro Hei', sans-serif, SimHei, SimSun;background-color:rgb(255,255,255);">从上面的结果来看，其实LinkedBlockingDeque的结构上来说，有点像ArrayBlockingQueue的构造，也是一个ReentrantLock和两个Condition，下面分别对其中重要方法进行分析。</p> 
<ul style="list-style:none;color:rgb(51,51,51);font-family:'-apple-system', 'SF UI Text', Arial, 'PingFang SC', 'Hiragino Sans GB', 'Microsoft YaHei', 'WenQuanYi Micro Hei', sans-serif, SimHei, SimSun;font-size:14px;background-color:rgb(255,255,255);"><li style="padding:0px;">public void addFirst(E e)</li><li style="padding:0px;">public void addLast(E e)</li><li style="padding:0px;">public boolean offerFirst(E e)</li><li style="padding:0px;">public boolean offerLast(E e)</li><li style="padding:0px;">…</li></ul> 
<p style="font-family:'-apple-system', 'SF UI Text', Arial, 'PingFang SC', 'Hiragino Sans GB', 'Microsoft YaHei', 'WenQuanYi Micro Hei', sans-serif, SimHei, SimSun;background-color:rgb(255,255,255);">对于LinkedBlockingDeque，和ArrayBlockingQueue结构还是很类似的，也是一个ReentrantLock和两个Condition使用，但是仅仅是在这二者使用上，其实内部运转还是很大不同的。</p> 
<h4 style="padding:0px;font-family:'-apple-system', 'SF UI Text', Arial, 'PingFang SC', 'Hiragino Sans GB', 'Microsoft YaHei', 'WenQuanYi Micro Hei', sans-serif, SimHei, SimSun;background-color:rgb(255,255,255);">offerFirst操作</h4> 
<code style="font-size:14px;line-height:22px;padding:4px 2px 0px;">offerFirst</code> 
<span style="font-family:'-apple-system', 'SF UI Text', Arial, 'PingFang SC', 'Hiragino Sans GB', 'Microsoft YaHei', 'WenQuanYi Micro Hei', sans-serif, SimHei, SimSun;background-color:rgb(255,255,255);">就是在队头添加一个元素：</span> 
<br> 
<pre><code class="language-java">public boolean offerFirst(E e) {
        if (e == null) throw new NullPointerException();
        Node&lt;E&gt; node = new Node&lt;E&gt;(e);
        final ReentrantLock lock = this.lock;    //加锁
        lock.lock();
        try {
            return linkFirst(node);
        } finally {
            lock.unlock();
        }
    }</code></pre> 
<span style="font-family:'-apple-system', 'SF UI Text', Arial, 'PingFang SC', 'Hiragino Sans GB', 'Microsoft YaHei', 'WenQuanYi Micro Hei', sans-serif, SimHei, SimSun;background-color:rgb(255,255,255);">接下来看</span> 
<code style="font-size:14px;line-height:22px;padding:4px 2px 0px;">linkFirst</code> 
<span style="font-family:'-apple-system', 'SF UI Text', Arial, 'PingFang SC', 'Hiragino Sans GB', 'Microsoft YaHei', 'WenQuanYi Micro Hei', sans-serif, SimHei, SimSun;background-color:rgb(255,255,255);">方法：</span> 
<br> 
<pre><code class="language-java">private boolean linkFirst(Node&lt;E&gt; node) {
        if (count &gt;= capacity)         //容量满了
            return false;
        Node&lt;E&gt; f = first;           //在队头添加
        node.next = f;
        first = node;
        if (last == null)        //第一个节点
            last = node;
        else
            f.prev = node;
        ++count;              //count自增
        notEmpty.signal();           //说明不为null。唤醒等待队列
        return true;
    }</code></pre> 
<h4 style="padding:0px;font-family:'-apple-system', 'SF UI Text', Arial, 'PingFang SC', 'Hiragino Sans GB', 'Microsoft YaHei', 'WenQuanYi Micro Hei', sans-serif, SimHei, SimSun;background-color:rgb(255,255,255);">clear操作</h4> 
<span style="font-family:'-apple-system', 'SF UI Text', Arial, 'PingFang SC', 'Hiragino Sans GB', 'Microsoft YaHei', 'WenQuanYi Micro Hei', sans-serif, SimHei, SimSun;background-color:rgb(255,255,255);">它的实现方法是遍历一遍，分别把所有node指针都指向null从而方便gc。</span> 
<br> 
<pre><code class="language-java">public void clear() {
        final ReentrantLock lock = this.lock;
        lock.lock();               //加锁后清空所有。
        try {
            for (Node&lt;E&gt; f = first; f != null; ) {   //遍历一遍
                f.item = null;       //置空操作
                Node&lt;E&gt; n = f.next;
                f.prev = null;
                f.next = null;
                f = n;      //f后移动一个
            }
            first = last = null;
            count = 0;
            notFull.signalAll();           //通知等待put线程
        } finally {
            lock.unlock();
        }
    }</code></pre> 
<p><span style="font-family:'-apple-system', 'SF UI Text', Arial, 'PingFang SC', 'Hiragino Sans GB', 'Microsoft YaHei', 'WenQuanYi Micro Hei', sans-serif, SimHei, SimSun;background-color:rgb(255,255,255);"><span style="font-family:'-apple-system', 'SF UI Text', Arial, 'PingFang SC', 'Hiragino Sans GB', 'Microsoft YaHei', 'WenQuanYi Micro Hei', sans-serif, SimHei, SimSun;background-color:rgb(255,255,255);"><span style="font-family:'-apple-system', 'SF UI Text', Arial, 'PingFang SC', 'Hiragino Sans GB', 'Microsoft YaHei', 'WenQuanYi Micro Hei', sans-serif, SimHei, SimSun;background-color:rgb(255,255,255);"><br></span></span></span></p> 
<p><span style="font-family:'-apple-system', 'SF UI Text', Arial, 'PingFang SC', 'Hiragino Sans GB', 'Microsoft YaHei', 'WenQuanYi Micro Hei', sans-serif, SimHei, SimSun;background-color:rgb(255,255,255);"><span style="font-family:'-apple-system', 'SF UI Text', Arial, 'PingFang SC', 'Hiragino Sans GB', 'Microsoft YaHei', 'WenQuanYi Micro Hei', sans-serif, SimHei, SimSun;background-color:rgb(255,255,255);"><span style="font-family:'-apple-system', 'SF UI Text', Arial, 'PingFang SC', 'Hiragino Sans GB', 'Microsoft YaHei', 'WenQuanYi Micro Hei', sans-serif, SimHei, SimSun;background-color:rgb(255,255,255);"><br></span></span></span></p> 
<p><span style="font-family:'-apple-system', 'SF UI Text', Arial, 'PingFang SC', 'Hiragino Sans GB', 'Microsoft YaHei', 'WenQuanYi Micro Hei', sans-serif, SimHei, SimSun;background-color:rgb(255,255,255);"><span style="font-family:'-apple-system', 'SF UI Text', Arial, 'PingFang SC', 'Hiragino Sans GB', 'Microsoft YaHei', 'WenQuanYi Micro Hei', sans-serif, SimHei, SimSun;background-color:rgb(255,255,255);"><span style="font-family:'-apple-system', 'SF UI Text', Arial, 'PingFang SC', 'Hiragino Sans GB', 'Microsoft YaHei', 'WenQuanYi Micro Hei', sans-serif, SimHei, SimSun;background-color:rgb(255,255,255);"><br></span></span></span></p> 
<p><span style="font-family:'-apple-system', 'SF UI Text', Arial, 'PingFang SC', 'Hiragino Sans GB', 'Microsoft YaHei', 'WenQuanYi Micro Hei', sans-serif, SimHei, SimSun;background-color:rgb(255,255,255);"><span style="font-family:'-apple-system', 'SF UI Text', Arial, 'PingFang SC', 'Hiragino Sans GB', 'Microsoft YaHei', 'WenQuanYi Micro Hei', sans-serif, SimHei, SimSun;background-color:rgb(255,255,255);"><span style="font-family:'-apple-system', 'SF UI Text', Arial, 'PingFang SC', 'Hiragino Sans GB', 'Microsoft YaHei', 'WenQuanYi Micro Hei', sans-serif, SimHei, SimSun;background-color:rgb(255,255,255);"><br></span></span></span></p> 
<p><span style="font-family:'-apple-system', 'SF UI Text', Arial, 'PingFang SC', 'Hiragino Sans GB', 'Microsoft YaHei', 'WenQuanYi Micro Hei', sans-serif, SimHei, SimSun;background-color:rgb(255,255,255);"><span style="font-family:'-apple-system', 'SF UI Text', Arial, 'PingFang SC', 'Hiragino Sans GB', 'Microsoft YaHei', 'WenQuanYi Micro Hei', sans-serif, SimHei, SimSun;background-color:rgb(255,255,255);"><span style="font-family:'-apple-system', 'SF UI Text', Arial, 'PingFang SC', 'Hiragino Sans GB', 'Microsoft YaHei', 'WenQuanYi Micro Hei', sans-serif, SimHei, SimSun;background-color:rgb(255,255,255);"><br></span></span></span></p> 
<p><span style="font-family:'-apple-system', 'SF UI Text', Arial, 'PingFang SC', 'Hiragino Sans GB', 'Microsoft YaHei', 'WenQuanYi Micro Hei', sans-serif, SimHei, SimSun;background-color:rgb(255,255,255);"><span style="font-family:'-apple-system', 'SF UI Text', Arial, 'PingFang SC', 'Hiragino Sans GB', 'Microsoft YaHei', 'WenQuanYi Micro Hei', sans-serif, SimHei, SimSun;background-color:rgb(255,255,255);"><span style="font-family:'-apple-system', 'SF UI Text', Arial, 'PingFang SC', 'Hiragino Sans GB', 'Microsoft YaHei', 'WenQuanYi Micro Hei', sans-serif, SimHei, SimSun;background-color:rgb(255,255,255);"><br></span></span></span></p> 
<p><span style="font-family:'-apple-system', 'SF UI Text', Arial, 'PingFang SC', 'Hiragino Sans GB', 'Microsoft YaHei', 'WenQuanYi Micro Hei', sans-serif, SimHei, SimSun;background-color:rgb(255,255,255);"><span style="font-family:'-apple-system', 'SF UI Text', Arial, 'PingFang SC', 'Hiragino Sans GB', 'Microsoft YaHei', 'WenQuanYi Micro Hei', sans-serif, SimHei, SimSun;background-color:rgb(255,255,255);"><span style="font-family:'-apple-system', 'SF UI Text', Arial, 'PingFang SC', 'Hiragino Sans GB', 'Microsoft YaHei', 'WenQuanYi Micro Hei', sans-serif, SimHei, SimSun;background-color:rgb(255,255,255);"><br></span></span></span></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/00f170e5e1a566a8d23406fb9fc73962/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">es6-algorithm 之 Fibonacci 尾调用优化</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/2206415b4fa7158b4f12d53563d4e151/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">SpringBoot___web开发自动配置</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>