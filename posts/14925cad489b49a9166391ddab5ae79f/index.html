<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>数据结构与算法系列（二）—冒泡排序 - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="数据结构与算法系列（二）—冒泡排序" />
<meta property="og:description" content="前言 大家好，本系列开始对排序算法进行总结。牧码心今天给大家推荐一篇数据结构与算法系列（二）—冒泡排序的文章，希望对你有所帮助。大纲如下:
基本介绍图文说明时间复杂度和稳定性具体实现 基本介绍 冒泡排序(Bubble Sort)，又被称为气泡排序或泡沫排序。 它是一种较简单的排序算法。它会遍历若干次要排序的数列，每次遍历时，它都会从前往后依次的比较相邻两个数的大小；如果前者比后者大，则交换它们的位置。这样，一次遍历之后，最大的元素就在数列的末尾！ 采用相同的方法再次遍历时，第二大的元素就被排列在最大元素之前。重复此操作，直到整个数列都有序为止！
图文说明 下面以数列{20,40,30,10,60,50}为例，演示它的冒泡排序过程(如下图)
说明
我们先分析第1趟排序
当i=5,j=0时，a[0]&lt;a[1]。此时，不做任何处理！
当i=5,j=1时，a[1]&gt;a[2]。此时，交换a[1]和a[2]的值；交换之后，a[1]=30，a[2]=40。
当i=5,j=2时，a[2]&gt;a[3]。此时，交换a[2]和a[3]的值；交换之后，a[2]=10，a[3]=40。
当i=5,j=3时，a[3]&lt;a[4]。此时，不做任何处理！
当i=5,j=4时，a[4]&gt;a[5]。此时，交换a[4]和a[5]的值；交换之后，a[4]=50，a[3]=60。
于是，第1趟排序完之后，数列{20,40,30,10,60,50}变成了{20,30,10,40,50,60}。此时，数列末尾的值最大。
以此类推：
第2趟排序完之后，数列中a[5…6]是有序的。
第3趟排序完之后，数列中a[4…6]是有序的。
第4趟排序完之后，数列中a[3…6]是有序的。
第5趟排序完之后，数列中a[1…6]是有序的。
第5趟排序之后，整个数列也就是有序的了。
逻辑过程（伪代码）
从观察上面冒泡排序的流程图，第3趟排序之后，数据已经是有序的了；第4趟和第5趟并没有进行数据交换。下面我们对冒泡排序进行优化，使它效率更高一些：添加一个标记，如果一趟遍历中发生了交换，则标记为true，否则为false。如果某一趟没有发生交换，说明排序已经完成！ void bubble_sort2(int a[], int n) { int i,j; int flag; // 标记 for (i=n-1; i&gt;0; i--) { flag = 0; // 初始化标记为0 // 将a[0...i]中最大的数据放在末尾 for (j=0; j&lt;i; j&#43;&#43;) { if (a[j] &gt; a[j&#43;1]) { swap(a[j], a[j&#43;1]); flag = 1; // 若发生交换，则设标记为1 } } if (flag==0) break; // 若没发生交换，则说明数列已有序。 } } 时间复杂度和稳定性 冒泡排序时间复杂度" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/14925cad489b49a9166391ddab5ae79f/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2020-07-28T23:31:11+08:00" />
<meta property="article:modified_time" content="2020-07-28T23:31:11+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">数据结构与算法系列（二）—冒泡排序</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-light">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p><img src="https://images2.imgbox.com/3c/7a/QoJIg9yL_o.png" alt="数据结构与算法系列（二）—冒泡排序"></p> 
<h3><a id="_2"></a>前言</h3> 
<p>大家好，本系列开始对排序算法进行总结。牧码心今天给大家推荐一篇数据结构与算法系列（二）—冒泡排序的文章，希望对你有所帮助。大纲如下:</p> 
<ul><li>基本介绍</li><li>图文说明</li><li>时间复杂度和稳定性</li><li>具体实现</li></ul> 
<h3><a id="_8"></a>基本介绍</h3> 
<p><strong>冒泡排序(Bubble Sort)，又被称为气泡排序或泡沫排序。</strong> 它是一种较简单的排序算法。它会遍历若干次要排序的数列，每次遍历时，它都会从前往后依次的比较相邻两个数的大小；如果前者比后者大，则交换它们的位置。这样，一次遍历之后，最大的元素就在数列的末尾！ 采用相同的方法再次遍历时，第二大的元素就被排列在最大元素之前。重复此操作，直到整个数列都有序为止！</p> 
<h3><a id="_10"></a>图文说明</h3> 
<ul><li>下面以数列{20,40,30,10,60,50}为例，演示它的冒泡排序过程(如下图)<br> <img src="https://images2.imgbox.com/9d/8d/NBWSVkFS_o.jpg" alt="冒泡排序过程"></li></ul> 
<blockquote> 
 <p><strong>说明</strong><br> 我们先分析第1趟排序<br> 当i=5,j=0时，a[0]&lt;a[1]。此时，不做任何处理！<br> 当i=5,j=1时，a[1]&gt;a[2]。此时，交换a[1]和a[2]的值；交换之后，a[1]=30，a[2]=40。<br> 当i=5,j=2时，a[2]&gt;a[3]。此时，交换a[2]和a[3]的值；交换之后，a[2]=10，a[3]=40。<br> 当i=5,j=3时，a[3]&lt;a[4]。此时，不做任何处理！<br> 当i=5,j=4时，a[4]&gt;a[5]。此时，交换a[4]和a[5]的值；交换之后，a[4]=50，a[3]=60。<br> 于是，第1趟排序完之后，数列{20,40,30,10,60,50}变成了{20,30,10,40,50,60}。此时，数列末尾的值最大。<br> 以此类推：<br> 第2趟排序完之后，数列中a[5…6]是有序的。<br> 第3趟排序完之后，数列中a[4…6]是有序的。<br> 第4趟排序完之后，数列中a[3…6]是有序的。<br> 第5趟排序完之后，数列中a[1…6]是有序的。<br> 第5趟排序之后，整个数列也就是有序的了。</p> 
</blockquote> 
<ul><li><strong>逻辑过程（伪代码）</strong><br> 从观察上面冒泡排序的流程图，第3趟排序之后，数据已经是有序的了；第4趟和第5趟并没有进行数据交换。下面我们对冒泡排序进行优化，使它效率更高一些：添加一个标记，如果一趟遍历中发生了交换，则标记为true，否则为false。如果某一趟没有发生交换，说明排序已经完成！</li></ul> 
<pre><code class="prism language-java"><span class="token keyword">void</span> <span class="token function">bubble_sort2</span><span class="token punctuation">(</span><span class="token keyword">int</span> a<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token keyword">int</span> n<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
    <span class="token keyword">int</span> i<span class="token punctuation">,</span>j<span class="token punctuation">;</span>
    <span class="token keyword">int</span> flag<span class="token punctuation">;</span>                 <span class="token comment">// 标记</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span>i<span class="token operator">=</span>n<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span> i<span class="token operator">&gt;</span><span class="token number">0</span><span class="token punctuation">;</span> i<span class="token operator">--</span><span class="token punctuation">)</span>
    <span class="token punctuation">{<!-- --></span>
        flag <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>            <span class="token comment">// 初始化标记为0</span>
        <span class="token comment">// 将a[0...i]中最大的数据放在末尾</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span>j<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span> j<span class="token operator">&lt;</span>i<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span>
        <span class="token punctuation">{<!-- --></span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>a<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">&gt;</span> a<span class="token punctuation">[</span>j<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
            <span class="token punctuation">{<!-- --></span>
                <span class="token function">swap</span><span class="token punctuation">(</span>a<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">,</span> a<span class="token punctuation">[</span>j<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                flag <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token comment">// 若发生交换，则设标记为1</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>flag<span class="token operator">==</span><span class="token number">0</span><span class="token punctuation">)</span>
            <span class="token keyword">break</span><span class="token punctuation">;</span>            <span class="token comment">// 若没发生交换，则说明数列已有序。</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> 
<h3><a id="_53"></a>时间复杂度和稳定性</h3> 
<ul><li> <p><strong>冒泡排序时间复杂度</strong><br> 冒泡排序的时间复杂度是O(N2)。<br> 假设被排序的数列中有N个数。遍历一趟的时间复杂度是O(N)，需要遍历多少次呢？N-1次！因此，冒泡排序的时间复杂度是O(N2)。</p> </li><li> <p><strong>冒泡排序稳定性</strong><br> 冒泡排序是稳定的算法，它满足稳定算法的定义。<br> 算法稳定性 是指设在数列中存在a[i]=a[j]，若在排序之前，a[i]在a[j]前面；并且排序之后，a[i]仍然在a[j]前面。则这个排序算法是稳定的！</p> </li></ul> 
<h3><a id="_64"></a>代码实现</h3> 
<ul><li>冒泡排序（java版）</li></ul> 
<pre><code class="prism language-java"><span class="token comment">/*
     * @Author:greekw
     * @Desc: 第一版：通过双重循环，第一层控制循环轮数，第二层控制比较次数。由于碰到有序的序列后，可以不用比较
     *        设置sortable=true跳出比较,减少交换次数
     * @Date 23:16 2020/7/21
     * @Param [array]
     * @return void
    **/</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">bubbleSort</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> array<span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
        <span class="token keyword">int</span> temp<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>
        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> array<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
            <span class="token comment">// 有序标记，初始是有序的</span>
            <span class="token keyword">boolean</span> sortable<span class="token operator">=</span><span class="token boolean">true</span><span class="token punctuation">;</span>
            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> array<span class="token punctuation">.</span>length<span class="token operator">-</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
                <span class="token keyword">if</span><span class="token punctuation">(</span>array<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">&gt;</span> array<span class="token punctuation">[</span>j<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
                    temp <span class="token operator">=</span> array<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>
                    array<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> array<span class="token punctuation">[</span>j<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
                    array<span class="token punctuation">[</span>j<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> temp<span class="token punctuation">;</span>
                    <span class="token comment">// 有元素交换则说明此轮无序</span>
                    sortable <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
                <span class="token punctuation">}</span>
            <span class="token punctuation">}</span>
            <span class="token keyword">if</span><span class="token punctuation">(</span>sortable<span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
                <span class="token keyword">break</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
 	<span class="token comment">// 测试用例</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> bubbleArray <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">{<!-- --></span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">8</span><span class="token punctuation">,</span><span class="token number">6</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">9</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">7</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
        <span class="token function">bubbleSort</span><span class="token punctuation">(</span>bubbleArray<span class="token punctuation">)</span><span class="token punctuation">;</span>
        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>Arrays<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span>bubbleArray<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
 
</code></pre> 
<p><img src="https://images2.imgbox.com/df/d8/kb8fxQfj_o.gif" alt="在这里插入图片描述"><br> 欢迎关注我的公众 号（牧码心），获取很多精彩文章和学习资料！<br> <img src="https://images2.imgbox.com/33/28/Ws227kHE_o.jpg" alt="公众号图标"></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/d5a5fc0caa0cae2c06c9ab411da26cf2/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">python中利用Sklearn和Scipy分别实现核密度估计</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/eee6e2757914ccb816367d51fcfcca2b/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">Vue 倒计时插件 vue2-countdown</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>