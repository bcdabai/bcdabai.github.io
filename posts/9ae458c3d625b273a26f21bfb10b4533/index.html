<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>【详解】KMP算法——多图，多例子（c语言） - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="【详解】KMP算法——多图，多例子（c语言）" />
<meta property="og:description" content="目录
前言
1.KMP算法是什么？
2.为什么需要KMP算法？
2.1主串找字串
2.2暴力求解
3.KMP准备工作
3.1字符串的前后子串
3.2最大前后相等子串
3.3最大前后相等子串练习
4.KMP算法
4.1简看KMP算法
5 Next数组 5.1j该回溯的位置
5.2学会计算Next数组 5.3用数学表示next数组（重点）
5.3.1arr2[k] == arr2[j]
5.3.2 arr2[k] != arr2[j]
5.3.3 k回溯到尽头
6.代码实现KMP
6.1KMP外壳
6.2KMP内核
6.3KMP全部代码
7.结语
前言 KMP算法作为程序员的必修课之一，其抽象的过程让初学者叫苦不迭，但是当你完全理解过后会发现其中蕴含着创造者的无穷智慧。本篇文章我将以大量的例子与图片，为你讲解这个奇妙的算法。
1.KMP算法是什么？ KMP算法是一种改进的字符串匹配算法，由D.E.Knuth，J.H.Morris和V.R.Pratt提出的，因此人们称它为克努特—莫里斯—普拉特操作（简称KMP算法）。KMP算法的核心是利用匹配失败后的信息，尽量减少模式串与主串的匹配次数以达到快速匹配的目的。具体实现就是通过一个next()函数实现，函数本身包含了模式串的局部匹配信息。KMP算法的时间复杂度O(m&#43;n) [1]
。（来自百度百科）
简而言之就是：减少在主串找子串的过程中回退的次数。（先有个概念就行，后面会仔细讲解）
2.为什么需要KMP算法？ 在回答这个问题前我们需要知道先知道两个问题。
什么叫主串找子串？
不用kmp算法，直接暴力求解是怎样的？
2.1主串找字串 现在我们有主串：arr1[] = &#34;abababc&#34;，子串：arr2[] = “abc”。那么我们在arr1中找到arr2在其中位置的过程就叫做主串找子串。
2.2暴力求解 在暴力求解中，我们是将子串和主串逐一匹配，如果第一个字符相等就继续匹配第二个字符，直到子串与主串全都匹配成功，就返回子串的位置，一旦其中某两个字符匹配不成功，主串就回到开始匹配字符的下一字符，而子串回到第一字符。
上面的话可能有一点绕，那么看了下面的图片你就会明白暴力求解的思路。
还是这俩字符串，主串：arr1[] = &#34;abababc&#34;，子串：arr2[] = “abc”。
（1） 第一次匹配成功，第二次匹配成功，第三次匹配不成功。
（2） 前面匹配失败，第一个字符串回到第二个字符&#39;b&#39;,第二个字符串回到第一个字符&#39;a&#39;处。
第一次匹配失败。
（3） 前面匹配失败，第一个字符串回到第三个字符&#39;a&#39;,第二个字符串回到第一个字符&#39;a&#39;处。
第一次匹配成功，第二次匹配成功，第三次匹配不成功。
（4） 前面匹配失败，第一个字符串回到第四个字符&#39;b&#39;,第二个字符串回到第一个字符&#39;a&#39;处。
第一次匹配失败。
（5） 前面匹配失败，第一个字符串回到第五个字符&#39;a&#39;,第二个字符串回到第一个字符&#39;a&#39;处。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/9ae458c3d625b273a26f21bfb10b4533/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2021-09-19T15:25:44+08:00" />
<meta property="article:modified_time" content="2021-09-19T15:25:44+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">【详解】KMP算法——多图，多例子（c语言）</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p id="main-toc"><strong>目录</strong></p> 
<p id="%E5%89%8D%E8%A8%80-toc" style="margin-left:0px;"><a href="#%E5%89%8D%E8%A8%80" rel="nofollow">前言</a></p> 
<p id="1.KMP%E7%AE%97%E6%B3%95%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F-toc" style="margin-left:0px;"><a href="#1.KMP%E7%AE%97%E6%B3%95%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F" rel="nofollow">1.KMP算法是什么？</a></p> 
<p id="2.%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81KMP%E7%AE%97%E6%B3%95%EF%BC%9F-toc" style="margin-left:0px;"><a href="#2.%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81KMP%E7%AE%97%E6%B3%95%EF%BC%9F" rel="nofollow">2.为什么需要KMP算法？</a></p> 
<p id="2.1%E4%B8%BB%E4%B8%B2%E6%89%BE%E5%AD%97%E4%B8%B2-toc" style="margin-left:40px;"><a href="#2.1%E4%B8%BB%E4%B8%B2%E6%89%BE%E5%AD%97%E4%B8%B2" rel="nofollow">2.1主串找字串</a></p> 
<p id="2.2%E6%9A%B4%E5%8A%9B%E6%B1%82%E8%A7%A3-toc" style="margin-left:40px;"><a href="#2.2%E6%9A%B4%E5%8A%9B%E6%B1%82%E8%A7%A3" rel="nofollow">2.2暴力求解</a></p> 
<p id="3.KMP%E5%87%86%E5%A4%87%E5%B7%A5%E4%BD%9C-toc" style="margin-left:0px;"><a href="#3.KMP%E5%87%86%E5%A4%87%E5%B7%A5%E4%BD%9C" rel="nofollow">3.KMP准备工作</a></p> 
<p id="3.1%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E5%89%8D%E5%90%8E%E5%AD%90%E4%B8%B2-toc" style="margin-left:40px;"><a href="#3.1%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E5%89%8D%E5%90%8E%E5%AD%90%E4%B8%B2" rel="nofollow">3.1字符串的前后子串</a></p> 
<p id="3.2%E6%9C%80%E5%A4%A7%E5%89%8D%E5%90%8E%E7%9B%B8%E7%AD%89%E5%AD%90%E4%B8%B2-toc" style="margin-left:40px;"><a href="#3.2%E6%9C%80%E5%A4%A7%E5%89%8D%E5%90%8E%E7%9B%B8%E7%AD%89%E5%AD%90%E4%B8%B2" rel="nofollow">3.2最大前后相等子串</a></p> 
<p id="3.3%E6%9C%80%E5%A4%A7%E5%89%8D%E5%90%8E%E7%9B%B8%E7%AD%89%E5%AD%90%E4%B8%B2%E7%BB%83%E4%B9%A0-toc" style="margin-left:40px;"><a href="#3.3%E6%9C%80%E5%A4%A7%E5%89%8D%E5%90%8E%E7%9B%B8%E7%AD%89%E5%AD%90%E4%B8%B2%E7%BB%83%E4%B9%A0" rel="nofollow">3.3最大前后相等子串练习</a></p> 
<p id="4.KMP%E7%AE%97%E6%B3%95-toc" style="margin-left:0px;"><a href="#4.KMP%E7%AE%97%E6%B3%95" rel="nofollow">4.KMP算法</a></p> 
<p id="4.1%E7%AE%80%E7%9C%8BKMP%E7%AE%97%E6%B3%95-toc" style="margin-left:40px;"><a href="#4.1%E7%AE%80%E7%9C%8BKMP%E7%AE%97%E6%B3%95" rel="nofollow">4.1简看KMP算法</a></p> 
<p id="5%20Next%E6%95%B0%E7%BB%84%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0-toc" style="margin-left:0px;"><a href="#5%20Next%E6%95%B0%E7%BB%84%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0" rel="nofollow">5 Next数组     </a></p> 
<p id="5.1j%E8%AF%A5%E5%9B%9E%E6%BA%AF%E7%9A%84%E4%BD%8D%E7%BD%AE-toc" style="margin-left:40px;"><a href="#5.1j%E8%AF%A5%E5%9B%9E%E6%BA%AF%E7%9A%84%E4%BD%8D%E7%BD%AE" rel="nofollow">5.1j该回溯的位置</a></p> 
<p id="%C2%A05.2%E5%AD%A6%E4%BC%9A%E8%AE%A1%E7%AE%97Next%E6%95%B0%E7%BB%84%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0-toc" style="margin-left:40px;"><a href="#%C2%A05.2%E5%AD%A6%E4%BC%9A%E8%AE%A1%E7%AE%97Next%E6%95%B0%E7%BB%84%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0" rel="nofollow"> 5.2学会计算Next数组           </a></p> 
<p id="5.3%E7%94%A8%E6%95%B0%E5%AD%A6%E8%A1%A8%E7%A4%BAnext%E6%95%B0%E7%BB%84%EF%BC%88%E9%87%8D%E7%82%B9%EF%BC%89-toc" style="margin-left:40px;"><a href="#5.3%E7%94%A8%E6%95%B0%E5%AD%A6%E8%A1%A8%E7%A4%BAnext%E6%95%B0%E7%BB%84%EF%BC%88%E9%87%8D%E7%82%B9%EF%BC%89" rel="nofollow">5.3用数学表示next数组（重点）</a></p> 
<p id="5.3.1arr2%5Bk%5D%20%3D%3D%20arr2%5Bj%5D-toc" style="margin-left:80px;"><a href="#5.3.1arr2%5Bk%5D%20%3D%3D%20arr2%5Bj%5D" rel="nofollow">5.3.1arr2[k] == arr2[j]</a></p> 
<p id="5.3.2%C2%A0arr2%5Bk%5D%20!%3D%20arr2%5Bj%5D-toc" style="margin-left:80px;"><a href="#5.3.2%C2%A0arr2%5Bk%5D%20!%3D%20arr2%5Bj%5D" rel="nofollow">5.3.2 arr2[k] != arr2[j]</a></p> 
<p id="5.3.3%20k%E5%9B%9E%E6%BA%AF%E5%88%B0%E5%B0%BD%E5%A4%B4-toc" style="margin-left:80px;"><a href="#5.3.3%20k%E5%9B%9E%E6%BA%AF%E5%88%B0%E5%B0%BD%E5%A4%B4" rel="nofollow">5.3.3 k回溯到尽头</a></p> 
<p id="6.%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0KMP-toc" style="margin-left:0px;"><a href="#6.%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0KMP" rel="nofollow">6.代码实现KMP</a></p> 
<p id="6.1KMP%E5%A4%96%E5%A3%B3-toc" style="margin-left:40px;"><a href="#6.1KMP%E5%A4%96%E5%A3%B3" rel="nofollow">6.1KMP外壳</a></p> 
<p id="6.2KMP%E5%86%85%E6%A0%B8-toc" style="margin-left:40px;"><a href="#6.2KMP%E5%86%85%E6%A0%B8" rel="nofollow">6.2KMP内核</a></p> 
<p id="6.3KMP%E5%85%A8%E9%83%A8%E4%BB%A3%E7%A0%81-toc" style="margin-left:40px;"><a href="#6.3KMP%E5%85%A8%E9%83%A8%E4%BB%A3%E7%A0%81" rel="nofollow">6.3KMP全部代码</a></p> 
<p id="7.%E7%BB%93%E8%AF%AD-toc" style="margin-left:0px;"><a href="#7.%E7%BB%93%E8%AF%AD" rel="nofollow">7.结语</a></p> 
<hr id="hr-toc"> 
<h2 id="%E5%89%8D%E8%A8%80">前言</h2> 
<p></p> 
<p><em><u><span style="color:#4d4d4d;">KMP算法作为程序员的必修课之一，其抽象的过程让初学者叫苦不迭，但是当你完全理解过后会发现其中蕴含着创造者的无穷智慧。本篇文章我将以大量的例子与图片，为你讲解这个奇妙的算法。</span></u></em></p> 
<hr> 
<h2 id="1.KMP%E7%AE%97%E6%B3%95%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F">1.KMP算法是什么？</h2> 
<p>KMP算法是一种改进的字符串匹配算法，由D.E.Knuth，J.H.Morris和V.R.Pratt提出的，因此人们称它为克努特—莫里斯—普拉特操作（简称KMP算法）。KMP算法的核心是利用匹配失败后的信息，尽量减少模式串与主串的匹配次数以达到快速匹配的目的。具体实现就是通过一个next()函数实现，<a href="https://baike.baidu.com/item/%E5%87%BD%E6%95%B0/18686609" rel="nofollow" title="函数">函数</a>本身包含了模式串的局部匹配信息。KMP算法的<a href="https://baike.baidu.com/item/%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6/1894057" rel="nofollow" title="时间复杂度">时间复杂度</a>O(m+n) [1]<a name="ref_%5B1%5D_659777"></a><br><br><br><br>  。（来自百度百科）</p> 
<p>简而言之就是：<u>减少在主串找子串的过程中回退的次数。（先有个概念就行，后面会仔细讲解）</u></p> 
<hr> 
<h2 id="2.%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81KMP%E7%AE%97%E6%B3%95%EF%BC%9F">2.为什么需要KMP算法？</h2> 
<p><u><em>在回答这个问题前我们需要知道先知道两个问题。</em></u></p> 
<p><strong><em>什么叫主串找子串？</em></strong></p> 
<p><strong><em>不用kmp算法，直接暴力求解是怎样的？</em></strong></p> 
<p></p> 
<h3 id="2.1%E4%B8%BB%E4%B8%B2%E6%89%BE%E5%AD%97%E4%B8%B2">2.1主串找字串</h3> 
<p>现在我们有主串：arr1[] = <u>"abababc"</u>，子串：arr2[] = <u>“abc”</u>。那么我们在arr1中找到arr2在其中位置的过程就叫做主串找子串。</p> 
<p></p> 
<h3 id="2.2%E6%9A%B4%E5%8A%9B%E6%B1%82%E8%A7%A3">2.2暴力求解</h3> 
<p>在暴力求解中，我们是将子串和主串逐一匹配，如果第一个字符相等就继续匹配第二个字符，直到子串与主串全都匹配成功，就返回子串的位置，一旦其中某两个字符匹配不成功，主串就回到开始匹配字符的下一字符，而子串回到第一字符。</p> 
<p><strong>上面的话可能有一点绕，那么看了下面的图片你就会明白暴力求解的思路。</strong></p> 
<p>还是这俩字符串，主串：arr1[] = <u>"abababc"</u>，子串：arr2[] = <u>“abc”</u>。</p> 
<p>（1） 第一次匹配成功，第二次匹配成功，第三次匹配不成功。</p> 
<p>              <img alt="" height="203" src="https://images2.imgbox.com/29/ea/kE3nULvo_o.jpg" width="492"></p> 
<p> （2） 前面匹配失败，第一个字符串回到第二个字符'b',第二个字符串回到第一个字符'a'处。</p> 
<p>           第一次匹配失败。</p> 
<p>           <img alt="" height="221" src="https://images2.imgbox.com/c4/fd/0sdthGvO_o.jpg" width="523"></p> 
<p>（3） 前面匹配失败，第一个字符串回到第三个字符'a',第二个字符串回到第一个字符'a'处。</p> 
<p>          第一次匹配成功，第二次匹配成功，第三次匹配不成功。</p> 
<p>             <img alt="" height="221" src="https://images2.imgbox.com/54/05/v0aPcsYD_o.jpg" width="505"></p> 
<p>（4） 前面匹配失败，第一个字符串回到第四个字符'b',第二个字符串回到第一个字符'a'处。</p> 
<p>          第一次匹配失败。</p> 
<p>               <img alt="" height="227" src="https://images2.imgbox.com/50/24/Zcm5gTfK_o.jpg" width="488"></p> 
<p>（5） 前面匹配失败，第一个字符串回到第五个字符'a',第二个字符串回到第一个字符'a'处。</p> 
<p>          第一次匹配成功，第二次匹配成功，第三次匹配成功，子串走到尽头，成功找到在第一字符            串找到第二字符串。</p> 
<p>                  <img alt="" height="216" src="https://images2.imgbox.com/55/bd/w139tR8v_o.jpg" width="476"></p> 
<p><strong>通过以上举例可以看出，传统的暴力求解，需要多次回溯，且第一个字符串和第二个字符串都需要回溯，而且例如（2）（4）步，明显回溯过去也一定是错的，那有没有什么办法让他回溯到特定的位置，不至于像暴力求解一样，产生许多不必要的步骤，于是就有了本篇的重点：</strong></p> 
<p><span style="color:#fe2c24;"><strong>                                                               KMP算法！！！</strong></span></p> 
<hr> 
<h2 id="3.KMP%E5%87%86%E5%A4%87%E5%B7%A5%E4%BD%9C">3.KMP准备工作</h2> 
<p><u><em>在学习KMP算法之前我们还需要进行一些小小的的准备。这对你掌握KMP算法是非常必要的</em></u>。</p> 
<p></p> 
<h3 id="3.1%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E5%89%8D%E5%90%8E%E5%AD%90%E4%B8%B2"><strong>3.1字符串的前后子串</strong></h3> 
<p><em><u>先抛开找字符串的问题，抛开什么KMP算法，我们来了解一下什么叫一个字符串的前后相等子串。</u></em></p> 
<p><strong>--假设有这样一个字符串：a[] = "abcabcabc";</strong></p> 
<p><strong>那么他的前子串的集合为：{"a","ab","abc","abca","abcab","abcabc","abcabca","abcabcab"}</strong></p> 
<p><span style="color:#fe2c24;"><strong>看不懂？上图！<u>图片顺序是从左向右哦！</u></strong></span>(<em>注：作者懒,字符串的\0我没画</em>😉）</p> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/de/d3/DVi7DXIE_o.jpg"></p> 
<p><strong>--知道了什么叫前子串，那么字符的后子串也很好理解了。</strong></p> 
<p><strong>他的后子串的集合为：{"c","bc","abc","cabc","bcabc","abcabc","cabcabc","bcabcabc"}</strong></p> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/1d/93/ORjOcx6J_o.png"></p> 
<h4></h4> 
<h3 id="3.2%E6%9C%80%E5%A4%A7%E5%89%8D%E5%90%8E%E7%9B%B8%E7%AD%89%E5%AD%90%E4%B8%B2">3.2最大前后相等子串</h3> 
<p><strong>我们现在已经知道了字符串a[] = "abcabcabc"的两个信息：</strong></p> 
<p><strong>前子串的集合为：{"a","ab","abc","abca","abcab","abcabc","abcabca","abcabcab"}</strong></p> 
<p><strong>后子串的集合为：{"c","bc","abc","cabc","bcabc","abcabc","cabcabc","bcabcabc"}</strong></p> 
<p><span style="color:#fe2c24;"><strong>很明显就可以看出前后两个子串相等的有{"abc","abcabc"};</strong></span></p> 
<p><span style="color:#fe2c24;"><u><strong>那最大前后相等子串就是"abcabc"，其长度为6。</strong></u></span></p> 
<h4></h4> 
<h3 id="3.3%E6%9C%80%E5%A4%A7%E5%89%8D%E5%90%8E%E7%9B%B8%E7%AD%89%E5%AD%90%E4%B8%B2%E7%BB%83%E4%B9%A0">3.3最大前后相等子串练习</h3> 
<p><u><em>kmp算法的准备工作已经完成，如果你还是有点不太清楚，这里有几个字符串，你不妨可以试着找出他们的最大前后相等子串，以及长度，来加深你对前面内容的的理解。</em></u></p> 
<p>        a[] = "abcdefgh"                         b[] = "abcabcabcabcabc"        c[] = "aba"</p> 
<p>        d[] = "hello world"                       e[] = "ababcabcdabcde"          f[] = "abcabcdeabcabcde"</p> 
<p> <strong>答案:</strong></p> 
<pre><code>a[]:没有最大前后相等子串    0
b[]:"abcabcabcabc"         12
c[]:"a"                    1
d[]:没有最大前后相等子串    0
e[]:没有最大前后相等子串    0
f[]:"abcabcde"             8</code></pre> 
<hr> 
<h2 id="4.KMP%E7%AE%97%E6%B3%95">4.KMP算法</h2> 
<h3 id="4.1%E7%AE%80%E7%9C%8BKMP%E7%AE%97%E6%B3%95">4.1简看KMP算法</h3> 
<p>前面我们多次强调过，kmp算法只需要子串返回到特定位置，而主串不用返回。</p> 
<p>这到底是一个怎样的过程呢？</p> 
<p><strong>还是这俩字符串，主串：arr1[] = <u>"abababc"</u>，子串：arr2[] = <u>“abc”</u>。</strong></p> 
<p><span style="color:#a2e043;"><strong><span style="background-color:#1c7331;">绿色是回溯的位置</span>，</strong></span><span style="color:#fe2c24;"><strong>红色是匹配结束的位置。</strong></span></p> 
<p>（1）第一次匹配成功，第二次匹配成功，第三次匹配失败。<img alt="" height="241" src="https://images2.imgbox.com/ca/15/brHd0B2c_o.jpg" width="478"></p> 
<p>（2）前面不匹配失败，主串不回溯子串回溯到第一个字符，并与上次与主串匹配错误的位置匹配</p> 
<p>         第一次匹配成功，第二次匹配成功，第三次匹配失败。<img alt="" height="241" src="https://images2.imgbox.com/68/1a/uCQ3scJQ_o.jpg" width="484"></p> 
<p>（3）前面不匹配失败，主串不回溯子串回溯到第一个字符，并与上次与主串匹配错误的位置匹配</p> 
<p>         第一次匹配成功，第二次匹配成功，第三次匹配成功。 <img alt="" height="237" src="https://images2.imgbox.com/81/ae/Q3MuCXkz_o.jpg" width="466"></p> 
<p><u><em> 看样子KMP算法好像就是主串不回溯，子串回溯到初始位置而已嘛，感觉并没有说的那么强大啊。</em></u></p> 
<p><strong>那你可太小看KMP算法了，我们再来看一个例子:</strong></p> 
<p><strong>主串：arr1[] = <u>"abcababcabc"</u>，子串：arr2[] = <u>“abcabc”</u>。</strong></p> 
<p> (1)</p> 
<p><img alt="" height="202" src="https://images2.imgbox.com/1e/0b/0VOymzBx_o.jpg" width="580"></p> 
<p> (2)</p> 
<p><img alt="" height="230" src="https://images2.imgbox.com/23/44/SnsELVKy_o.jpg" width="583"></p> 
<p> (3)</p> 
<p><img alt="" height="214" src="https://images2.imgbox.com/69/24/SBuCaOiw_o.jpg" width="565"></p> 
<p><strong> 可以很明显的看到第二次匹配中，j并没有回溯到字符串的首位置而是回溯到字符串的第三个位置</strong></p> 
<p><strong>这就是我们所说的</strong><span style="color:#fe2c24;"><strong><u>j会回溯到一个特定位置</u></strong></span><strong>的意思。</strong></p> 
<hr> 
<h2 id="5%20Next%E6%95%B0%E7%BB%84%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0">5 Next数组     </h2> 
<h3 id="5.1j%E8%AF%A5%E5%9B%9E%E6%BA%AF%E7%9A%84%E4%BD%8D%E7%BD%AE">5.1j该回溯的位置</h3> 
<p><strong>主串：arr1[] = <u>"abcababcabc"</u>，子串：arr2[] = <u>“abcabc”</u>。</strong></p> 
<p><img alt="" height="276" src="https://images2.imgbox.com/b9/a9/beIp5lHE_o.jpg" width="562"></p> 
<p><em><u> 此时主串与子串在就 j = 5位置匹配失败，各位可以一一尝试，我们最好的结果就是回退到 j = 2处，</u></em><strong>因为主串和子串匹配失败一定有绿色的三个部分相等，而最大前后相等子串长度就是2即j返回位置。</strong></p> 
<p><img alt="" height="226" src="https://images2.imgbox.com/3a/75/hwrHlDOs_o.jpg" width="551"></p> 
<p><strong> 很明显就能看出根据最大前后相等子串的一些关系，能很轻松的将一些不必要的匹配略过，只从重要位置匹配，并且不用怕匹配遗漏的问题。</strong></p> 
<h4></h4> 
<h3 id="%C2%A05.2%E5%AD%A6%E4%BC%9A%E8%AE%A1%E7%AE%97Next%E6%95%B0%E7%BB%84%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0"> 5.2学会计算Next数组           </h3> 
<p><em><u>事实上，一个j会回溯的特定位置全都存放在一个Next[j] = k,数组中。</u></em></p> 
<p><strong><span style="color:#fe2c24;">Next[j] = k :一个用来存放子串返回位置的数组，回溯的位置用字母k来表示。</span>（</strong>Next只与主串和子串匹配错误的位置，以及子串本身有关，与主串没有太大关系，所以后面我们将抛弃主串，只讲<span style="color:#0d0016;">子串。</span><strong><span style="color:#0d0016;">）</span></strong></p> 
<p><span style="color:#0d0016;"><strong>那回溯位置k是怎么求的呢？</strong></span></p> 
<p><strong><span style="color:#0d0016;">1.从匹配失败位置，找到他前面的字符串的<u>最大前后相等子串长度。</u></span></strong></p> 
<p><span style="color:#0d0016;"><strong>2.默认第一个k值为-1(Next[0] = -1),第二个k值为0(Next[1] = 0),我们只需要从第三个k值(Next[2])开始求。</strong>(这里不同的书籍或人规定的默认值有所不同<strong>）</strong></span></p> 
<p><span style="color:#0d0016;"><strong>知道了Next数组的规则，我们开始求他了，假设我们有这样一个</strong></span><span style="color:#fe2c24;"><u><strong>子串</strong></u><strong>。</strong></span></p> 
<p><span style="color:#fe2c24;"><u><strong>arr2[11] = "abcababcabc"</strong></u></span></p> 
<p><span style="color:#fe2c24;"><strong><u>Next []</u></strong></span><strong><span style="color:#fe2c24;">   ={  -1, 0 , ? , ? , ? , ? , ....... } </span></strong></p> 
<p><img alt="" height="662" src="https://images2.imgbox.com/db/d4/7ypBczjG_o.jpg" width="1200"></p> 
<p><strong>（1）假设我们此时的<span style="color:#ff9900;">子串与主串在</span> <span style="color:#ff9900;">j = 2 时匹配失败</span></strong>。</p> 
<p><strong><span style="color:#a2e043;"><span style="background-color:#1c7331;">绿色代表需要找最大前后相等子串长度的字符串</span></span><span style="color:#ff9900;">，橙色数字代表该字符串的最大前后相等子串长度</span></strong></p> 
<p><img alt="" height="621" src="https://images2.imgbox.com/c5/7e/ysNHzVqL_o.jpg" width="1200"></p> 
<p></p> 
<p> <strong>（2）假设我们此时的<span style="color:#ff9900;">子串与主串在</span> <span style="color:#ff9900;">j = 3 时匹配失败</span></strong>。</p> 
<p><img alt="" height="547" src="https://images2.imgbox.com/67/bc/9UPKuYw4_o.jpg" width="1200"></p> 
<p></p> 
<p><strong>（3）假设我们此时的<span style="color:#ff9900;">子串与主串在</span> <span style="color:#ff9900;">j = 4 时匹配失败</span></strong>。</p> 
<p><img alt="" height="555" src="https://images2.imgbox.com/8b/40/in845jId_o.jpg" width="1200"></p> 
<p></p> 
<p><strong>（4）假设我们此时的<span style="color:#ff9900;">子串与主串在</span> <span style="color:#ff9900;">j = 5 时匹配失败</span></strong>。</p> 
<p><img alt="" height="548" src="https://images2.imgbox.com/37/12/kBxlaVqo_o.jpg" width="1200"></p> 
<p></p> 
<p><strong>（5）假设我们此时的<span style="color:#ff9900;">子串与主串在</span> <span style="color:#ff9900;">j = 6 时匹配失败</span></strong>。</p> 
<p><img alt="" height="532" src="https://images2.imgbox.com/99/46/ljFY0AYJ_o.jpg" width="1200"></p> 
<p></p> 
<p><strong>（6）假设我们此时的<span style="color:#ff9900;">子串与主串在</span> <span style="color:#ff9900;">j = 7 时匹配失败</span></strong>。</p> 
<p><img alt="" height="529" src="https://images2.imgbox.com/36/62/i54JDZ3q_o.jpg" width="1200"></p> 
<p></p> 
<p><strong>（7）假设我们此时的<span style="color:#ff9900;">子串与主串在</span> <span style="color:#ff9900;">j = 8 时匹配失败</span></strong>。</p> 
<p><img alt="" height="536" src="https://images2.imgbox.com/5b/83/TxpO6kZ4_o.jpg" width="1200"></p> 
<p></p> 
<p><strong>（8）假设我们此时的<span style="color:#ff9900;">子串与主串在</span> <span style="color:#ff9900;">j = 9 时匹配失败</span></strong>。</p> 
<p><img alt="" height="574" src="https://images2.imgbox.com/73/e1/KgrYr1Eb_o.jpg" width="1200"></p> 
<p></p> 
<p><strong>（9）假设我们此时的<span style="color:#ff9900;">子串与主串在</span> <span style="color:#ff9900;">j = 10 时匹配失败</span></strong>。</p> 
<p><img alt="" height="578" src="https://images2.imgbox.com/39/a2/cvOKz8xh_o.jpg" width="1200"></p> 
<p><strong>到此我们有：Next[i] = { -1 , 0 , 0 , 0 , 1 , 2 , 1 , 2 , 3 , 4 , 5 }</strong></p> 
<p><span style="color:#0d0016;"><strong>根据这样的规则，我们就得到了一个包含子串每一位错误时对应的退回位置</strong></span><span style="color:#fe2c24;"><strong>k</strong></span><span style="color:#0d0016;"><strong>的数组，这个数组叫做</strong></span><span style="color:#fe2c24;"><strong>Next</strong></span><span style="color:#0d0016;"><strong>，而且能知道，</strong></span><span style="color:#fe2c24;"><strong>next数组的长度与子串的长度相同。</strong></span></p> 
<h4></h4> 
<p id="--Next%E6%95%B0%E7%BB%84%E8%AE%A1%E7%AE%97%E7%BB%83%E4%B9%A0"><strong>--Next数组计算练习</strong></p> 
<p>1.a[] = "ababcabcdabcde"</p> 
<p>2.b[] = "abcabcabcabcdabcde"</p> 
<p><strong>答案：</strong></p> 
<pre><code>a[]:   a b a b c a b c d a b c d e
      -1 0 0 1 2 0 1 2 0 0 1 2 0 0

b[]:   a b c a b c a b c a b c d a b c d e
      -1 0 0 0 1 2 3 4 5 6 7 8 9 0 1 2 3 0</code></pre> 
<h4></h4> 
<h3 id="5.3%E7%94%A8%E6%95%B0%E5%AD%A6%E8%A1%A8%E7%A4%BAnext%E6%95%B0%E7%BB%84%EF%BC%88%E9%87%8D%E7%82%B9%EF%BC%89">5.3用数学表示next数组<span style="color:#fe2c24;">（重点）</span></h3> 
<p><em><u>通过前面的学习，你应该已经知道怎么求Next数组了，但那是你用眼睛去看出来的Next数组而不是用推导出来的Next数组，当计算机拿到一个子串，除了默认值设定的Next[0] = -1,Next[1] = 0,其他什么都不知道，Next数组后面的每一位都需要我们去设计计算出来。</u></em></p> 
<h4 id="5.3.1arr2%5Bk%5D%20%3D%3D%20arr2%5Bj%5D">5.3.1arr2[k] == arr2[j]</h4> 
<p><strong>arr2[] = "abcababcabc"</strong></p> 
<p><strong>假设我们已知Next = { -1 , 0 , 0 , 0 , 1 , 2 , 1 , 2 , 3 ,? }</strong><strong>，需要求解Next[9] = ?。</strong></p> 
<p></p> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/ac/98/NbTJmsdY_o.jpg"></p> 
<p><strong> 此时令<span style="color:#fe2c24;">j = 8</span>那已知信息就有 <span style="color:#fe2c24;">arr[j] = 'a'</span>，<span style="color:#fe2c24;">Next[j] = k = 3</span>, <span style="color:#fe2c24;">arr[k] = 'a'</span>,此时<span style="color:#ff9900;">arr[j] = arr[k]</span></strong></p> 
<p><img alt="" src="https://images2.imgbox.com/43/34/jqdCLA8c_o.jpg"><strong>那么: <span style="color:#1c7331;">                                                                                                                                                 </span><span style="color:#a2e043;"><span style="background-color:#1c7331;">{ arr2[ 0 ] , ... , arr2[ k - 1 ] } = "abc"</span>  </span><span style="color:#0d0016;">--&gt; </span><span style="color:#a2e043;"> <span style="background-color:#1c7331;">{ arr2[ x ] , ... , arr2[  j - 1 ] } = "abc"</span> </span><span style="color:#fe2c24;">  即Next [ j ] = k = 3的原因</span></strong></p> 
<p><span style="color:#0d0016;"><strong>根据两组下标可知：<u>(k-1) - 0 = (j - 1) - x  </u>,所以 x = j - k 。</strong></span></p> 
<p><strong><span style="color:#0d0016;">将x带回到第二组的下标中:                                                                                                                 </span><span style="color:#a2e043;"><span style="background-color:#1c7331;">{ arr2[   0   ] , ... , arr2[ k - 1 ] } = "abc"</span>  </span><span style="color:#0d0016;">--&gt;</span><span style="color:#a2e043;"> <span style="background-color:#1c7331;">{ arr2[ j - x ] , ... , arr2[  j - 1 ] } = "abc"</span> </span><span style="color:#fe2c24;">  </span></strong></p> 
<p><img alt="" src="https://images2.imgbox.com/4c/12/oVBBVqsu_o.jpg"></p> 
<p> 又因为<strong><span style="color:#ff9900;">arr[j] = arr[k] :                                                                                                                        </span><span style="color:#a2e043;"><span style="background-color:#1c7331;">{ arr2[   0   ] , ... , arr2[ k - 1 ] , arr2 [ k ] } = "abca"</span>  </span><span style="color:#0d0016;">--&gt; </span><span style="color:#a2e043;"> <span style="background-color:#1c7331;">{ arr2[ j - x ] , ... , arr2[  j - 1 ] , arr2 [ j  ] } = "abca"</span> </span></strong></p> 
<p><strong>所以可知：<span style="color:#0d0016;">Next [ j + 1 ]    =    <u>k + 1</u>   =    <u>4</u>  ！！！！！！！！！！！！！！</span></strong></p> 
<p><span style="color:#fe2c24;"><strong>注意1：一定要记住k就是最大前后相等子串长度。</strong></span></p> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/9f/e2/tn9H4FR2_o.jpg"></p> 
<p><span style="color:#fe2c24;"><strong><span style="background-color:#fbd4d0;">结论1：</span><u><span style="background-color:#fbd4d0;">arr2[k] == arr2[j] ⇒ Next [ j+1 ] = k + 1</span></u></strong></span></p> 
<p></p> 
<h4 id="5.3.2%C2%A0arr2%5Bk%5D%20!%3D%20arr2%5Bj%5D"><strong>5.3.2 </strong>arr2[k] != arr2[j]</h4> 
<p><em><u>前面我们已经知道了当arr2[k] == arr2[j]，怎么求Next[ j + 1 ] ，现在我们再来看看当 </u>            <u>  arr2[k] != arr2[j]的情况</u></em></p> 
<p><strong>arr2[] = "abcababcabc"</strong></p> 
<p><strong>假设我们已知Next = { -1 , 0 , 0 , 0 , 1 , 2 , ？ }</strong><strong>，需要求解Next[6] = ？。</strong></p> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/c7/7c/hqZdYS2U_o.jpg"></p> 
<p> <strong>此时令<span style="color:#fe2c24;">j = 5</span>那已知信息就有 <span style="color:#fe2c24;">arr[j] = 'a'</span>，<span style="color:#fe2c24;">Next[j] = k = 2</span>, <span style="color:#fe2c24;">arr[k] = 'c'</span>,此时<span style="color:#ff9900;">arr[j] != arr[k]</span></strong></p> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/9e/ef/l6aMPU08_o.jpg"></p> 
<p><span style="color:#a2e043;"><strong> </strong></span><span style="color:#0d0016;"><strong>那我们就让新的 </strong></span><span style="color:#956fe7;"><strong><span style="background-color:#efedf6;">k</span> </strong></span><span style="color:#fe2c24;"><strong>= Next[ k ] = 0。</strong></span><img alt="" height="694" src="https://images2.imgbox.com/e0/cd/SNocNGW5_o.jpg" width="1200"></p> 
<p> <strong>此时我们又有已知信息 <span style="color:#fe2c24;">arr[j] = 'a'</span>，<span style="color:#fe2c24;">Next[j] = k = 2</span>, <span style="color:#fe2c24;">arr[k] = 'a',</span><span style="color:#ff9900;">arr[j] = arr[k]</span></strong></p> 
<p><u><em><span style="color:#0d0016;">一些细心的读者可能会发现，现在又成了前一种情况arr[j] == arr[k]。</span></em></u></p> 
<p><span style="color:#0d0016;"><strong>因此我们要求解的 Next[ j + 1 ] 根据之前推导的公式</strong></span><span style="color:#fe2c24;"><strong>Next[ j + 1] = </strong></span><span style="color:#956fe7;"><strong><span style="background-color:#efedf6;">k + 1 </span></strong></span><strong>⇒</strong> <span style="color:#fe2c24;"><strong>Next [ j + 1 ] = 1。 </strong></span></p> 
<p><span style="color:#fe2c24;"><strong>注意2：此时的<span style="background-color:#efedf6;"> </span></strong></span><span style="color:#956fe7;"><strong><span style="background-color:#efedf6;">k </span></strong></span><span style="color:#fe2c24;"><strong>已经被改变过了，是</strong></span><span style="color:#956fe7;"><strong><span style="background-color:#efedf6;">新的k</span></strong></span><span style="color:#fe2c24;"><strong>。</strong></span></p> 
<p><span style="color:#fe2c24;"><strong><span style="background-color:#fbd4d0;">结论2：</span><u><span style="background-color:#fbd4d0;">arr2[k] != arr2[j] ⇒ Next[ j+1 ] = </span></u></strong></span><span style="color:#956fe7;"><strong><u><span style="background-color:#efedf6;"> k  +  1 </span></u></strong></span></p> 
<h4></h4> 
<h4 id="5.3.3%20k%E5%9B%9E%E6%BA%AF%E5%88%B0%E5%B0%BD%E5%A4%B4">5.3.3 k回溯到尽头</h4> 
<p><u><em>一些读者可能又会提出疑问：我的例子太特殊，要是k一直往Next数组前面走，走到第一个元素都找不到相等呢？</em></u></p> 
<p><strong>一直都找不到，那我们此时k肯定回溯到了数组头部，即<span style="color:#1c7331;"><span style="background-color:#edf6e8;">k = - 1</span></span>处，那我们就停止回溯，             Next [ j + 1 ] = k + 1 </strong>⇒<strong> Next [ j + 1] = 0。</strong></p> 
<p><span style="color:#fe2c24;"><strong><span style="background-color:#fbd4d0;">结论3：</span><u><span style="background-color:#fbd4d0;">k == -1 ⇒ Next[ j+1 ] =</span></u></strong></span><strong><span style="color:#1c7331;"><u><span style="background-color:#edf6e8;"> k + 1 </span></u></span></strong><strong>。即Next[ j + 1 ] = 0。</strong></p> 
<p></p> 
<p><u><em>以上就是</em></u><u>KMP的精华所在，创造者成功的找到了高效回溯的之中存在的潜藏规律。这下你们大概能理解为什么KMP算法如此令人着迷了吧。</u></p> 
<hr> 
<h2 id="6.%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0KMP">6.代码实现KMP</h2> 
<p><u><em>至此，如果你将前面的内容都理解了，那你基本把KMP算法掌握的差不多了，只剩如何用代码写出来的问题。下面我会分为两个部分讲解，有一定基础的读者也可以先尝试自己写一写，等遇到问题再回来看看我的代码与你的有何区别</em></u></p> 
<h3 id="6.1KMP%E5%A4%96%E5%A3%B3">6.1KMP外壳</h3> 
<p><strong>现在我们不去管如何用代码得到Next数组，而是将Next数组当作已知，尝试通过写出KMP算法的外壳。</strong></p> 
<p><strong>这里有三个要点：</strong></p> 
<p><span style="color:#fe2c24;"><strong>1.主串不回退</strong></span></p> 
<p><span style="color:#fe2c24;"><strong>2.子串回退到一个特殊的位置（通过前面我们已经知道，回退的特殊位置就是Next[ j ] = k</strong></span></p> 
<p><span style="color:#fe2c24;"><strong>3.假设Next数组已知</strong></span></p> 
<p><strong>代码如下：</strong></p> 
<pre><code class="language-cpp">#include&lt;stdio.h&gt;
#include&lt;string.h&gt;
int KMP(char* arr1, char* arr2)
{
	int i = 0;											//不需要记录匹配的首位置，
	int j = 0;                                          //因为kmp算法i不需要回溯
	
	int len1 = strlen(arr1);
	int len2 = strlen(arr2);
	
	int Next[len2] = {0};                               //假设Next已经得到，其长度为子
                                                        //串的长度
	
	if (len1 == 0 &amp;&amp; len2 == 0 || len2 == 0)            //当arr1与arr2都为空或arr1为空
        return 0;                                       //时直接返回
	
    else if (len1 == 0 || len2 &gt; len1) 		            //当arr1为空或者第二个字符串比
        return -1;                                      //第一个字符串长，不可能找到
	
	while (i &lt; len1 &amp;&amp; j &lt; len2)						//当arr1和arr2都没走到尽头
	{
		if (arr1[i] == arr2[j])
		{
			i++;
			j++;
		}
		else
		{
			j = Next[j];						        //当主串与子串不同时j回溯到 
                                                        //Next[j]，i不用回溯
		}
	}
	if (j &gt;= len2)
		return i - j;							        //如果子串走到尽头，代表找到了 
                                                        //返回开始匹配时的位置
	
    return -1;											//否则就是主串走到尽头，代表没
                                                        //找到
}</code></pre> 
<h3></h3> 
<h3 id="6.2KMP%E5%86%85%E6%A0%B8"><strong>6.2KMP内核</strong></h3> 
<p><em><u>前面的代码相信大部分人都能够轻松完成，就是简单的对暴力求解进行了一点改造而已，那接下来我们去用代码求得Next数组。</u></em></p> 
<p><strong>这里我们只需要借助我们前面推出来的三个结论：</strong></p> 
<p><span style="color:#fe2c24;"><strong><span style="background-color:#fbd4d0;">结论1：</span><u><span style="background-color:#fbd4d0;">arr2[k] == arr2[j] ⇒ Next[ j+1 ] = k + 1        k不往子串前走</span></u></strong></span></p> 
<p><span style="color:#fe2c24;"><strong><span style="background-color:#fbd4d0;">结论2：</span><u><span style="background-color:#fbd4d0;">arr2[k] != arr2[j] ⇒ Next[ j+1 ] = </span></u></strong></span><span style="color:#956fe7;"><strong><u><span style="background-color:#efedf6;"> k  +  1      k往子串前走</span></u></strong></span></p> 
<p><span style="color:#fe2c24;"><strong><span style="background-color:#fbd4d0;">结论3：</span><u><span style="background-color:#fbd4d0;">k == -1                ⇒  Next[ j+1 ] =</span></u></strong></span><strong><span style="color:#1c7331;"><u><span style="background-color:#edf6e8;"> k + 1        k走到子串尽头</span></u></span></strong></p> 
<p><strong>注意：虽然三个结论看起来相似，但一定要记住每个k分别是什么意思</strong></p> 
<p><strong>代码如下:</strong></p> 
<pre><code class="language-cpp">void GetNext(int* Next, const char* arr2)           //传入Next数组地址，传入子串首地址
{
	int j = 1;										//初始已知项 j = 1
	int i = j + 1;									//初始待求项 j+1 = 2
	int k = 0;                                      //待求的Next[j+1]前一项的k值
	
	int len2 = strlen(arr2);                        //子串长度
	
	Next[0] = -1;									//Next数组前两个默认值
	Next[1] = 0;
	
	while (i &lt; len2)                                //当待求项走到arr2尽头,k全求出
	{
		if ((k == -1) || arr2[k] == arr2[i - 1])	//结论1，结论3情况
		{
			Next[i] = k + 1;
			k = k + 1;                              //待求的Next[j+1]前一项的k值
			i++;                                    //待求项往后走一位
		}
		else
		{
			k = Next[k];							//结论2情况
		}
	}
}</code></pre> 
<h3></h3> 
<h3 id="6.3KMP%E5%85%A8%E9%83%A8%E4%BB%A3%E7%A0%81"><strong>6.3KMP全部代码</strong></h3> 
<p><u><em>前面的代码很明显只将两个部分单独写出，并没有做出联系，因此还需要一些改动。</em></u></p> 
<pre><code class="language-cpp">#include&lt;stdio.h&gt;
#include&lt;string.h&gt;

void GetNext(int* Next, const char* arr2)           //传入Next数组地址，传入子串首地址
{
	int j = 1;										//初始已知项 j = 1
	int i = j + 1;									//初始待求项 j+1 = 2
	int k = 0;                                      //待求的Next[j+1]前一项的k值
	
	int len2 = strlen(arr2);                        //子串长度
	
	Next[0] = -1;									//Next数组前两个默认值
	Next[1] = 0;
	
	while (i &lt; len2)                                //当待求项走到arr2尽头，找完Next数组
	{
		if ((k == -1) || arr2[k] == arr2[i - 1])	//结论1，结论3情况
		{
			Next[i] = k + 1;
			k = k + 1;                              //待求的Next[j+1]前一项的k值
			i++;                                    //待求项往后走一位
		}
		else
		{
			k = Next[k];							//结论2情况
		}
	}
}

int KMP(char* arr1, char* arr2)
{
	int i = 0;											//不需要记录匹配的首位置，
	int j = 0;                                          //因为kmp算法i不需要回溯
	
	int len1 = strlen(arr1);
	int len2 = strlen(arr2);
	
	int* Next = (int*)malloc(len2 * sizeof(int));       //为Next数组开辟一个与子串一样长的 
                                                        //空间
	
	GetNext(Next, arr2);                                //借用Next函数得到Next数组的内容

	if (len1 == 0 &amp;&amp; len2 == 0 || len2 == 0) return 0;	//当arr1与arr2都为空或arr1为空时直 
                                                        //接返回

	else if (len1 == 0 || len2 &gt; len1) return -1;		//当arr1为空或者第二个字符串比第一 
                                                        //个字符串长
	
	while (i &lt; len1 &amp;&amp; j &lt; len2)						//当arr1和arr2都没走到尽头
	{
		if (arr1[i] == arr2[j])
		{
			i++;
			j++;
		}
		else
		{
			j = Next[j];						        //当主串与子串不同时j回溯到 
                                                        //Next[j]，i不用回溯
		}
	}
	if (j &gt;= len2)
		return i - j;							        //如果子串走到尽头，代表找到了返回 
                                                        //开始匹配时的位置
	return -1;											//否则就是主串走到尽头，代表没找到
}

int main()
{
	char arr1[] = "abababcabc";         //测试用             
	char arr2[] = "abcabc";
	char pos;
	pos = KMP(arr1, arr2);
	printf("%d", pos);
}</code></pre> 
<hr> 
<h2 id="7.%E7%BB%93%E8%AF%AD">7.结语</h2> 
<p><u><em>写下这篇博客，不单单是教大家，同时也是我自己的一个学习总结，如果各位学到了东西，还请不要吝惜你们的点赞收藏，这也将激励我写出更好的文章。</em></u></p> 
<p><strong>特别鸣谢：</strong></p> 
<p><u><em>@比特大博哥，如果大家看了我的视频还是有所不懂可以看大博哥的视频b站</em></u>：BV1UL411E7M8</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/44971a2b2d72ff84f03cd41a7304a58d/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">遍历Map集合</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/646fb7473b8a9550c67d2c7fe80e1940/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">vmtk c&#43;&#43; vs2019安装过程</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>