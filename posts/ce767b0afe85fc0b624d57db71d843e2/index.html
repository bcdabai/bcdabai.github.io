<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>算法篇——动态规划 01背包问题 (js版) - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="算法篇——动态规划 01背包问题 (js版)" />
<meta property="og:description" content="416. 分割等和子集
给你一个 只包含正整数 的 非空 数组 nums 。请你判断是否可以将这个数组分割成两个子集，使得两个子集的元素和相等。
链接：力扣
解题思路：
这道题看似是比较简单的背包问题：
首先可以通过判断数组和是否是偶数，因为如果是奇数是必然不可能拆分成两个数组的，直接返回false；
if(nums.length == 1) return false var sum = 0 // 数组求和 for(var i = 0; i &lt; nums.length; i&#43;&#43;) { sum &#43;= nums[i] } // 如果相加不是偶数说明不可能拆成相等的两个数组 if(sum % 2 != 0) return false 接着获取sum / 2，也就是target，我们利用一个新的方法：getSum，对元素和它的索引指针进行遍历
// 目标值是当前和的一半 var target = sum / 2 // map 用来遍历元素，可记录元素状态，相比循环更快，防止超时 const map = new Map() 这里也是有两个临界判断的：指针是否会越界，数组中的数据项之和是否会超出 target，否则就是可以拆分的
// 越界 if(i == nums." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/ce767b0afe85fc0b624d57db71d843e2/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-06-21T09:00:45+08:00" />
<meta property="article:modified_time" content="2023-06-21T09:00:45+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">算法篇——动态规划 01背包问题 (js版)</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p><a href="https://leetcode.cn/problems/partition-equal-subset-sum/" rel="nofollow" title="416. 分割等和子集">416. 分割等和子集</a></p> 
<p>给你一个 只包含正整数 的 非空 数组 <code>nums</code> 。请你判断是否可以将这个数组分割成两个子集，使得两个子集的元素和相等。</p> 
<p>链接：<a href="https://leetcode.cn/problems/partition-equal-subset-sum/" rel="nofollow" title="力扣">力扣</a></p> 
<p><img alt="" height="251" src="https://images2.imgbox.com/b3/78/ubXy6nzZ_o.png" width="336"></p> 
<p><strong>解题思路：</strong></p> 
<p>这道题看似是比较简单的背包问题：</p> 
<p>首先可以通过判断数组和是否是偶数，因为如果是奇数是必然不可能拆分成两个数组的，直接返回false；</p> 
<pre><code class="language-javascript">if(nums.length == 1) return false
var sum = 0
// 数组求和
for(var i = 0; i &lt; nums.length; i++) {
    sum += nums[i]
}
// 如果相加不是偶数说明不可能拆成相等的两个数组
if(sum % 2 != 0) return false</code></pre> 
<p>接着获取sum / 2，也就是target，我们利用一个新的方法：getSum，对元素和它的索引指针进行遍历</p> 
<pre><code class="language-javascript">// 目标值是当前和的一半
var target = sum / 2
// map 用来遍历元素，可记录元素状态，相比循环更快，防止超时
const map = new Map()</code></pre> 
<p>这里也是有两个临界判断的：指针是否会越界，数组中的数据项之和是否会超出 target，否则就是可以拆分的</p> 
<pre><code class="language-javascript">// 越界
if(i == nums.length || cur &gt; target) return false
// 可拆分
if(cur == target) return true</code></pre> 
<p>但同时还需要判断不连续的数据项是否满足</p> 
<pre><code class="language-javascript">var key = cur + '+' + i
// 如果map中有对应的缓存值，直接get拿出使用
if(map.has(key)) {
   return map.get(key)
}
// 如果需要当前的项，就加入当前的和，移动指针到下一位
// 如果不需要当前的项，就直接移动指针到下一位
const res = getSum(cur + nums[i], i + 1) || getSum(cur, i + 1)
// 避免重复遍历元素，存入map中，可直接对应查找
map.set(key, res)
return res</code></pre> 
<p>这里调用方法时，主要考虑：如果需要当前的项，就加入当前的和，移动指针到下一位；如果不需要当前的项，就直接移动指针到下一位</p> 
<p>并且利用map的好处就是可以防止重复遍历计算元素，提高了时间性能</p> 
<p>下面是完整代码：</p> 
<pre><code class="language-javascript">var canPartition = function(nums) {
    if(nums.length == 1) return false
    var sum = 0
    // 数组求和
    for(var i = 0; i &lt; nums.length; i++) {
        sum += nums[i]
    }
    // 如果相加不是偶数说明不可能拆成相等的两个数组
    if(sum % 2 != 0) return false 
    // 目标值是当前和的一半
    var target = sum / 2
    // map 用来遍历元素，可记录元素状态，相比循环更快，防止超时
    const map = new Map()
    // cur： 当前和，i：指针
    const getSum = (cur, i) =&gt; {
        // 越界
        if(i == nums.length || cur &gt; target) return false
        // 可拆分
        if(cur == target) return true
        var key = cur + '+' + i
        // 如果map中有对应的缓存值，直接get拿出使用
        if(map.has(key)) {
            return map.get(key)
        }
        // 如果需要当前的项，就加入当前的和，移动指针到下一位
        // 如果不需要当前的项，就直接移动指针到下一位
        const res = getSum(cur + nums[i], i + 1) || getSum(cur, i + 1)
        // 避免重复遍历元素，存入map中，可直接对应查找
        map.set(key, res)
        return res
    }
    return getSum(0, 0) // 递归入口，从第一个元素开始遍历
};</code></pre> 
<p><strong>以上的代码时间消耗很大，下面利用动态规划的方法，与上面的思路类似，也是要进行如下步骤：（注意看图中的红框内容）</strong></p> 
<p><img alt="" height="329" src="https://images2.imgbox.com/ab/5a/rYkuyZMX_o.png" width="352"></p> 
<p>1.根据数组的长度 nums.length 判断数组是否可以被划分：如果 n=1，直接返回 false</p> 
<p>2.计算整个数组的元素和 sum 以及最大元素 maxNum：如果 sum 是奇数，直接返回 false；反之，target= sum / 2</p> 
<p>3.判断是否数组中是否存在元素的和等于 target。如果 maxNum &gt; target，则除了 maxNum 以外的所有元素之和一定小于 target，直接返回false，完整代码如下：</p> 
<pre><code class="language-javascript">var canPartition = function(nums) {
    // 一个元素无法拆分成两个数组
    if(nums.length == 1) return false
    var sum = 0, max = 0
    for(var i = 0; i &lt; nums.length; i++) {
        sum += nums[i]
        // 得到最大元素
        max = max &gt; nums[i] ? max : nums[i]
    }
    // 数组和是奇数
    if(sum % 2 != 0) return false 
    // 目标值是数组和的一半
    var target = sum / 2
    // 如果 max &gt; target，则除了 max 以外的所有元素之和一定小于 target
    if(max &gt; target) return false
    // 定义长度为 target+1 的数组，并赋值数组的初始值
    // 对于给定的数组 nums，能否选取其中一部分元素，使得它们的总和恰好等于 target 
    // 初始时，将数组 dp 初始化为全零，表示当前还没有任何元素可以选取
    const dp = new Array(target+1).fill(0)
    // 外层循环变量 i 表示遍历数组 nums 的索引，内层循环变量 j 表示当前的目标和（从大到小递减）
    for(var i = 0; i &lt; nums.length; i++) {
        for(var j = target; j &gt;= nums[i]; j--) {
            // 如果 nums[i] 可以选，则更新 dp[j]，意味着 dp[j - nums[i]] + nums[i]：前一个目标和 j - nums[i] 的最优结果加上当前选的 nums[i]
            // 如果 nums[i] 不可选，则 dp[j] 保持不变
            dp[j] = Math.max(dp[j], dp[j - nums[i]] + nums[i])
            // 判断 dp[j] 是否等于 target：如果相等，返回 true，否则继续遍历
            if(dp[j] == target) return true
        }
    }
    return dp[target] == target
}</code></pre> 
<p><a href="https://leetcode.cn/problems/last-stone-weight-ii/" rel="nofollow" title="1049. 最后一块石头的重量 II">1049. 最后一块石头的重量 II</a></p> 
<p>有一堆石头，用整数数组 stones 表示。其中 stones[i] 表示第 i 块石头的重量。</p> 
<p>每一回合，从中选出任意两块石头，然后将它们一起粉碎。假设石头的重量分别为 x 和 y，且 x &lt;= y。那么粉碎的可能结果如下：如果 x == y，那么两块石头都会被完全粉碎；<br> 如果 x != y，那么重量为 x 的石头将会完全粉碎，而重量为 y 的石头新重量为 y-x。<br> 最后，最多只会剩下一块 石头。返回此石头 最小的可能重量 。如果没有石头剩下，就返回 0。</p> 
<p>链接：<a href="https://leetcode.cn/problems/last-stone-weight-ii/" rel="nofollow" title="力扣">力扣</a><br><img alt="" height="315" src="https://images2.imgbox.com/ee/e9/hW2vFPQZ_o.png" width="524"></p> 
<p><strong>这道题的思路和上一题的思路类似，让石头分成重量相同的两堆，相撞后剩下的石头最小</strong> </p> 
<pre><code class="language-javascript">var lastStoneWeightII = function(stones) {
    // 如果只有一块石头，直接返回当前石头的重量
    if(stones.length == 1) return stones[0]
    var sum = 0
    for(var i = 0; i &lt; stones.length; i++) {
        sum += stones[i]
    }
    var target = Math.floor(sum / 2)
    var dp = new Array(target+1).fill(0)
    for(var i = 0; i &lt; stones.length; i++) {
        for(var j = target; j &gt;= stones[i]; j--) {
            dp[j] = Math.max(dp[j], dp[j- stones[i]] + stones[i])
        }
    }
    return sum - 2 * dp[target]
}</code></pre> 
<p><a href="https://leetcode.cn/problems/target-sum/" rel="nofollow" title="494. 目标和">494. 目标和</a></p> 
<p>给你一个整数数组 nums 和一个整数 target 。</p> 
<p>向数组中的每个整数前添加 '+' 或 '-' ，然后串联起所有整数，可以构造一个 表达式 ：</p> 
<p>例如，nums = [2, 1] ，可以在 2 之前添加 '+' ，在 1 之前添加 '-' ，然后串联起来得到表达式 "+2-1" 。返回可以通过上述方法构造的、运算结果等于 target 的不同 表达式 的数目</p> 
<p>链接：<a href="https://leetcode.cn/problems/target-sum/" rel="nofollow" title="力扣">力扣</a> </p> 
<p><strong>解题思路：</strong>本题不同于上面两题的地方在于，这题需要求出有多少种方法，前面的递推公式都是</p> 
<pre><code class="language-javascript">dp[j] = Math.max(dp[j], dp[j - nums[i]] + nums[i])</code></pre> 
<p>但这道题的是把 所有的 dp[j - nums[i]] 累加起来，这也是组合类问题的共性，即 </p> 
<pre><code>dp[j] += dp[j - nums[i]]</code></pre> 
<p>如果数组长度是1 ，考虑这个元素与 target 的大小值，如果不等于 target 的绝对值，返回0，反之返回1</p> 
<pre><code class="language-javascript">// 如果数组长度是1
if(nums.length == 1) {
   if(nums[0] == Math.abs(target)) return 1
   else return 0
}</code></pre> 
<p>如果 目标值的绝对值 大于 数组元素之和 sum，无法找到满足条件的方案；如果 目标值与元素之和 的和 取余为非零值，直接返回 0，因为如果将数组分为两个子集，它们的和必须相等，而加法操作结果除以 2 的余数只能是 0 或 1</p> 
<pre><code class="language-javascript">// 目标值的绝对值大于数组元素之和 sum，无法找到满足条件的方案
// 如果 目标值与元素之和 的和 取余为非零值，直接返回 0
if(Math.abs(target) &gt; sum || (target + sum) % 2) return 0
var mid = (target + sum) / 2
var dp = new Array(mid+1).fill(0)</code></pre> 
<p>下面是完整的代码：</p> 
<pre><code class="language-javascript">var findTargetSumWays = function(nums, target) {
    // 如果数组长度是1
    if(nums.length == 1) {
        if(nums[0] == Math.abs(target)) return 1
        else return 0
    }
    var sum = 0
    for(var i = 0; i &lt; nums.length; i++) {
        sum += nums[i]
    }
    // 目标值的绝对值大于数组元素之和 sum，无法找到满足条件的方案
    // 如果 目标值与元素之和 的和 取余为非零值，直接返回 0
    if(Math.abs(target) &gt; sum || (target + sum) % 2) return 0
    var mid = (target + sum) / 2
    var dp = new Array(mid+1).fill(0)
    // 这里初值赋值为 1，是因为如果为 0，则递归下来，只可能有 1种方案，因为始终为 0
    dp[0] = 1
    for(var i = 0; i &lt; nums.length; i++) {
        for(var j = mid; j &gt;= nums[i]; j--) {
            dp[j] += dp[j - nums[i]]
        }
    }
    return dp[mid]
}</code></pre> 
<p><a href="https://leetcode.cn/problems/ones-and-zeroes/" rel="nofollow" title="474. 一和零">474. 一和零</a></p> 
<p>给你一个二进制字符串数组 strs 和两个整数 m 和 n 。</p> 
<p>请你找出并返回 strs 的最大子集的长度，该子集中 最多 有 m 个 0 和 n 个 1 。</p> 
<p>如果 x 的所有元素也是 y 的元素，集合 x 是集合 y 的 子集 。</p> 
<p><img alt="" height="300" src="https://images2.imgbox.com/1a/60/DF8RgFjh_o.png" width="487"><br> 链接：<a href="https://leetcode.cn/problems/ones-and-zeroes/" rel="nofollow" title="力扣">力扣</a></p> 
<p><strong>解题思路：</strong></p> 
<p>这里的二维数组定义dp[i][j]：最多有i个0和j个1的strs的最大子集的大小为dp[i][j] </p> 
<p>01背包的递推公式：dp[j] = max(dp[j], dp[j - weight[i]] + value[i])</p> 
<p>因此此题中 dp[i][j] 可以由前一个 strs 中的字符串推出，strs里的字符串有 num0 个0，num1 个1</p> 
<p>dp[i][j] 是 dp[i - num0][j - num1] + 1。然后遍历取 dp[i][j] 的最大值，递推公式：</p> 
<pre><code class="language-javascript">dp[i][j] = max(dp[i][j], dp[i - num0][j - num1] + 1)</code></pre> 
<pre><code class="language-javascript">var findMaxForm = function(strs, m, n) {
    const dp = Array(m+1).fill(0).map(() =&gt; Array(n+1).fill(0)) 
    for(const str of strs) {
        let num0 = 0
        let num1 = 0
        for(const s of str) {
            // 对字符串中的 0 和 1 计数
            if(s == '0') num0++
            else num1++
        }
        // 使用两个倒序循环，从 m 到 numOfZeros，从 n 到 numOfOnes，更新 dp[i][j] 的值
        for(let i = m; i &gt;= num0; i--) {
            for(let j = n; j &gt;= num1; j--) {
                // 如果加入当前字符串，则更新 dp[i][j] 的值为 之前 dp[i - numOfZeros][j - numOfOnes] 的值加1
                // 如果不加入当前字符串，则 dp[i][j] 不变
                dp[i][j] = Math.max(dp[i][j], dp[i - num0][j - num1] + 1)
            }
        }
    }
    return dp[m][n]
}</code></pre>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/4b064bbfeb5ba85683ae3d11a9e58612/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">电脑常用软件，让你的电脑更加便捷的黑科技软件</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/b95a5bcff6393d99c713fa9ad2d47a95/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">图片转为ASCII字符画的方法</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>