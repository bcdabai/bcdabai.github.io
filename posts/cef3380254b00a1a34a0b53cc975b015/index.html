<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>JAVA类及类的成员 - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="JAVA类及类的成员" />
<meta property="og:description" content="类的简介： 一个源文件*.java必须与该文件中的主类同名(public class),源文件中有且只有一个主类。--&gt;主方法main-存在与主类中；一个源文件中可以存在N个普通类，直接使用。
类中常量：static、final同时修饰，此时常量全局唯一且不可修改，所有对象共享此常量
阿里编码规约：类中如无特殊说明，所有成员变量统一使用private 封装（99%）
1.属性 属性 = 成员变量 = field = 域、字段
属性 VS 局部变量 1.相同点：
1.1 定义变量的格式：数据类型 变量名 = 变量值
1.2 先声明，后使用
1.3 变量都有对应的作用域
2.不同点：
2.1 在类中声明的位置的不同
属性：直接定义在类的一对{}内
局部变量：声明在方法内、方法形参、代码块内、构造器形参、构造器内部的变量
2.2 关于权限修饰符的不同
属性：可以在声明属性时，指明其权限，使用权限修饰符。
常用的权限修饰符：private、public 、缺省、protected ----&gt;封装性
局部变量：不可以使用权限修饰符。
2.3默认初始化值的情况：
属性：类的属性，根据其类型，都默认初始化值。
整型 （byte、short、int 、long: 0）
浮点型 （float、double: 0.0）
字符型 （char: 0 (或&#39;\u0000&#39;)）
布尔型 （boolean: false）
引用数据类型(类、数组、接口：null) 局部变量：没默认初始化值。
意味着，我们在调用局部变量之前，一定要显示赋值。
特别地，形参在调用时，我们赋值即可。
2.4 在内存中加载的位置：
属性：加载到堆空间中 （非static）
局部变量：加载到栈空间
3.属性赋值的先后顺序：
A.默认初始化 B.显示初始化 C.构造器中赋值 D.通过“对象.方法” 或 “对象." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/cef3380254b00a1a34a0b53cc975b015/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-03-23T09:40:46+08:00" />
<meta property="article:modified_time" content="2022-03-23T09:40:46+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">JAVA类及类的成员</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <h3>类的简介：</h3> 
<p></p> 
<p>一个源文件*.java必须与该文件中的主类同名(public class),源文件中有且只有一个主类。--&gt;主方法main-存在与主类中；一个源文件中可以存在N个普通类，直接使用。</p> 
<p><strong>类中常量：</strong>static、final同时修饰，此时常量全局唯一且不可修改，所有对象共享此常量</p> 
<p><strong>阿里编码规约</strong>：类中如无特殊说明，所有成员变量统一使用private 封装（99%）</p> 
<h3>1.属性</h3> 
<p>属性 = 成员变量 = field = 域、字段</p> 
<h4>                                  属性  VS  局部变量</h4> 
<p><span style="color:#a2e043;"><strong>1.相同点：</strong></span></p> 
<p>1.1 定义变量的格式：数据类型   变量名  =  变量值</p> 
<p>1.2 先声明，后使用</p> 
<p>1.3 变量都有对应的作用域</p> 
<p><span style="color:#a2e043;"><strong>2.不同点：</strong></span></p> 
<p>2.1 在类中声明的位置的不同</p> 
<p><strong>属性</strong>：直接定义在类的一对{}内</p> 
<p><strong>局部变量</strong>：声明在方法内、方法形参、代码块内、构造器形参、构造器内部的变量</p> 
<p>2.2 关于权限修饰符的不同</p> 
<p><strong>属性</strong>：可以在声明属性时，指明其权限，<span style="color:#ff9900;"><strong>使用权限修饰符。</strong></span></p> 
<p>           常用的权限修饰符：private、public 、缺省、protected  ----&gt;封装性</p> 
<p><strong>局部变量</strong>：<span style="color:#ff9900;"><strong>不可以使用权限修饰符。</strong></span></p> 
<p>2.3<strong>默认初始化值的情况：</strong></p> 
<p>属性：类的属性，根据其类型，都默认初始化值。</p> 
<p>        整型 （byte、short、int 、long: 0）</p> 
<p>        浮点型 （float、double: 0.0）</p> 
<p>        字符型 （char: 0   (或'\u0000')）</p> 
<p>        布尔型 （boolean: false）</p> 
<p>        引用数据类型(类、数组、接口：null) </p> 
<p><img alt="" height="1200" src="https://images2.imgbox.com/ef/1e/MXFKVB0s_o.jpg" width="1200"></p> 
<p><span style="color:#956fe7;"><strong>局部变量：没默认初始化值。</strong></span></p> 
<p><span style="color:#956fe7;"><strong>意味着，我们在调用局部变量之前，一定要显示赋值。</strong></span></p> 
<p>        特别地，形参在调用时，我们赋值即可。</p> 
<p><strong>2.4 在内存中加载的位置：</strong></p> 
<p><strong><span style="color:#956fe7;">属性：加载到堆空间中 （非static）</span></strong></p> 
<p><strong><span style="color:#956fe7;">局部变量：加载到栈空间</span></strong></p> 
<p>3.属性赋值的先后顺序：</p> 
<p>A.默认初始化 B.显示初始化  C.构造器中赋值  D.通过“对象.方法” 或 “对象.属性”的方式，赋值</p> 
<p>以上操作的先后顺序：A -&gt; B -&gt; C -&gt; D</p> 
<h4>所有变量：</h4> 
<p><strong>1.成员变量：<span style="color:#956fe7;">(类中的成员变量都在堆上保存)。</span></strong></p> 
<p>1.1 实例变量（<strong><span style="color:#956fe7;">不以static修饰</span></strong>）：<span style="color:#ed7976;">A.任何方法都可以调用，B.类加载过程中完成静态变量的内存分配，只分配一次内存，且在内存中只有一个备份，静态变量一改全改，C.通过类名可以直接调用静态变量</span></p> 
<p>1.2 类变量（<strong><span style="color:#956fe7;">以static修饰</span></strong>）：<span style="color:#ed7976;">A.静态方法不能使用非静态的成员变量，只有实例化对象之后，才能调用；B.每创建一个实例，JVM就会为实例变量分配一次内存，可在内存中有多个拷贝，互不影响</span>。</p> 
<p><strong>1.2 局部变量</strong></p> 
<p>1.2.1 形参（方法、构造器中定义的变量）1.2.2 方法局部变量（在方法内定义）</p> 
<p>1.2.3 代码块局部变量（在代码块内定义）</p> 
<p><span style="color:#ed7976;"><strong>注：局部变量的初始值必须被显式声明！（</strong></span>局部变量没有默认初始化值）</p> 
<h4>变量的作用域</h4> 
<p>1.<strong>静态成员变量</strong>：类加载时创建，与类同命（<span style="color:#956fe7;"><strong>静态属性保存在JVM的方法区</strong></span>）</p> 
<p>2.<strong>成员变量</strong>：实例被创建时与实例对象同命</p> 
<p>3.<strong>局部变量</strong>：在定义该变量的方法被调用时创建，与方法同命</p> 
<h3>2.方法</h3> 
<h4>1.方法的基本描述</h4> 
<p>方法 = 成员方法 = 函数 = method</p> 
<p>方法：描述类应该具有的功能。</p> 
<p>比如：Math类：sqrt()\random()\...</p> 
<p>           Scanner类：nextXxx() ...</p> 
<p>           Arrays类：sort() \ binarySearch() \ toString() \ equals() \ ....</p> 
<p>1.举例：</p> 
<pre><code class="language-java">public void eat(){}
public void sleep(int hour){}
public String getName(){}
public String getNation(String nation){}
</code></pre> 
<p>2.方法的声明：权限修饰符  返回值类型   方法名（形参列表）{<!-- --></p> 
<p>                        方法体</p> 
<p>                        }</p> 
<p>3.说明：</p> 
<p>        3.1 关于权限修饰符：默认方法的权限修饰符都先使用public</p> 
<p>              Java规定的4种权限修饰符：private、public 、缺省、protected----&gt;封装性的体现</p> 
<p>        3.2 返回值类型： 返回值  vs  没返回值</p> 
<p>               3.2.1 如果方法返回值，则必须在方法声明时，指定返回值的类型。同时，方法中，需要                          使用return关键字来返回指定类型的变量或常量：“return 数据”。</p> 
<p>                        如果方法没有返回值，则方法声明时，使用void来表示，通常，没返回值的方法中，使用return，但是，此时，只能：“return ;” <strong>表示结束此方法</strong>的意思。</p> 
<p>        3.3 方法名：属于标识符，遵循标识符的规则和规范，“见名知意”</p> 
<p>        3.4 形参列表：方法可以声明0个，1个，或多个形参。</p> 
<p>              3.4.1格式：数据类型1 形参1，数据类型2 形参2，...</p> 
<p>        3.5 方法体：方法功能的体现。</p> 
<p>        方法的使用中，可以调用当前类的属性或方法。</p> 
<p>        特殊的：方法A中又调用了方法A：递归方法。</p> 
<p>        方法中，不可以定义方法。</p> 
<p>4.<strong>方法的形参的值传递机制：值传递</strong></p> 
<p>        所谓的值传递，就是将实参值的副本传入方法里，而参数本身并不受影响。</p> 
<p>        形参：方法定义时，声明的小括号内的参数</p> 
<p>        实参：方法调用时，实际传递给形参的数据</p> 
<p>        <span style="color:#956fe7;"><strong>值传递机制：</strong></span></p> 
<p><span style="color:#956fe7;"><strong>        如果参数时基本数据类型，此时实参赋给形参的时是实参真实存储的数据值。</strong></span></p> 
<p><span style="color:#956fe7;"><strong>        如果参数时引用数据类型，此时实参赋给形参的是实参存储数据的地址值。</strong></span></p> 
<h4>2.方法的重载（overload）</h4> 
<p>1.定义：在同一个类中，允许存在一个以上的同名方法，只要他们的参数个数或者参数类型不同即可。</p> 
<p>两同一不同”：同一个类、相同方法名</p> 
<p>                       参数列表不同：参数个数不同，参数类型不同</p> 
<p>2.举例：</p> 
<p>Arrays类中重载的sort() / binarySearch()</p> 
<p>3.判断是否重载：</p> 
<p>        跟方法的权限修饰符、返回值类型、形参变量名、方法体都没有关系！</p> 
<p>4.在通过对象调用方法时，如何确定某一个指定的方法 ：</p> 
<p>        方法名------&gt;参数列表</p> 
<h4>3.方法的重写</h4> 
<h4>4.区分方法的重载和重写</h4> 
<p><span style="color:#956fe7;"><strong>重载：不表现为多态性。</strong></span></p> 
<p><span style="color:#956fe7;"><strong>重写：表现为多态性</strong></span>。</p> 
<p>1.从编译和运行的角度来看：</p> 
<p>重载，是指允许存在多个同名方法，而这些方法的参数不同。编译器根据方法不同的参数列表，对同名方法的名称做修饰。对于编译器而言，这些同名方法就成了不同的方法。<strong><span style="color:#fe2c24;">他们的调用地址在编译期间就绑定了</span></strong>。Java的重载是可以包括父类和子类的，即子类可以重载父类的同名不同参数的方法。</p> 
<p>所以：对于重载而言，在方法调用之前，编译器就已经确定了所要调用的方法，这称为“早绑定”或“静态绑定”；</p> 
<p>而对于<strong><span style="color:#fe2c24;">多态，只有等到方法调用的那一刻，解释运行器才会确定所要调用的具体方法</span></strong>，这称为“晚绑定”或“动态绑定”；</p> 
<p>引用一句Bruce Eckel的话：“不要犯傻，<span style="color:#956fe7;"><strong>如果它不是晚绑定，它就不是多态</strong></span>。”</p> 
<h4>5.方法的调用</h4> 
<p>1.非静态方法</p> 
<p>非静态的方法就是没有static修饰的方法，对于非静态方法的调用，是通过<strong>对象</strong>来调用的</p> 
<pre><code class="language-java">对象.方法()
public class InvokeMethod{
    public static void main(String[] args){
        InvokeMethod in = new InvokeMethod();
        in.t1();
    }
    public void t1(){

    }
}</code></pre> 
<p>2.静态方法</p> 
<p>静态方法就是用static修饰的方法，静态的方法的调用是通过<strong>类名</strong>来调用的</p> 
<pre><code class="language-java">类名.方法()
public class InvokeMethod{
    public static void main(String[] args){
        InvokeMethod.t2();
    }
    public static void t2(){

    }
}</code></pre> 
<p>3.方法与方法之间的调用</p> 
<p>3.1静态方法内部调用其他方法</p> 
<p>     如果在本类当中，静态方法可以直接调用静态方法，除了在main方法中，还可以在自定义的静态方法中直接调用。如果在本类当中是非静态方法，就必须通过对象来调用。</p> 
<pre><code class="language-java">public class InvokeMethod{
    public static void main(String[] args){
       t2();
    }
    public static void t2(){
        system.out.println("static t2...");
    }
    public static void t1(){
    //静态方法调用非静态方法需通过对象来调用
    //InvokeMethod in = new InvokeMethod();
    //in.t2();
    t2();
    system.out.println("static t1");
    }
}</code></pre> 
<p>     如果在不同类当中，静态方法调用<strong>其他类</strong>的非静态方法，需要导入该类中的包，以及通过创建对象调用。</p> 
<p>3.2非静态方法内部调用</p> 
<p>     如果在<strong>本类中</strong>，非静态方法可以直接调用静态方法与非静态方法。</p> 
<p>     在<strong>不同类中</strong>，非静态方法调用其他类的静态方法，需要通过导入该类中的包，并且需要通过类名来调用。</p> 
<p>     在<strong>不同类中</strong>，非静态方法调用其他类的非静态方法时，需要导入该类中的包，还需要通过创建对象来掉用。</p> 
<h3>3.构造器</h3> 
<p>注：<strong>构造器名必须与本类的public访问修饰符的类名相同。</strong></p> 
<p>1.构造器的作用：</p> 
<p>1.1 创建对象    1.2  初始化对象的信息</p> 
<p>构造方法是执行对象的初始化操作(初始化：类中成员变量赋值）</p> 
<p>构造方法就是给类中属性赋值，类中属性的类型，在定义时就规定好了。</p> 
<p>2.说明：</p> 
<p>2.1 如果没有显示的定义类的构造器的话，则系统默认提供一个空参的构造器</p> 
<p>2.2 定义构造器的格式：权限修饰符 类名（形参列表）{}</p> 
<p>2.3 <span style="color:#956fe7;">一个类中定义的多个构造器，彼此构成重载</span></p> 
<p>2.4 <span style="color:#be191c;"><strong>一旦我们显示的定义了类的构造器之后，系统就不再提供默认的空参构造器</strong></span></p> 
<p>2.5 一个类中，至少会有一个构造器。</p> 
<p>2.6 构造方法的互相调用：【使用this(相应参数)，必须放在该方法的第一行调用，并且调用不能成"环"，不能递归调用成环】</p> 
<p><strong>关于构造器的特殊点：（private修饰构造方法）</strong>A. 产生对象时，由JVM调用 B. 一旦构造方法被private修饰，这个类就不能通过外部产生对象；举例：对象个数有限，类内部提供方法产生对象，<span style="color:#fe2c24;"><strong>当一个类构造方法被private修饰，表示不希望它能通过外部产生对象，二由类本身向外提供对象，外部只能使用，不能创建</strong></span>。eg：星期类(周一 ~ 周天这七个对象)、地球类，只有一个对象。</p> 
<pre><code class="language-java">public class Test1 {
    public static void main(String[] args) {
        Person person = Person.getInstance();
    }
}
class Person{
    private int age;
    private String name;
    private static Person per = new Person();
    private Person(){
        //类内部提供好对象，供外部使用
        public static Person getInstance(){
            return per;
        }
    }
}</code></pre> 
<h3>4.代码块 </h3> 
<p><br>  1.<strong>代码块的作用</strong>：用来初始化类、对象<br>  2.代码块如果有修饰的话，只能用static.<br>  3.<strong>分类：静态代码块  vs 非静态代码块</strong><br> 3.1<strong>静态代码块</strong><br>  &gt;内部可以有输出语句<br>  &gt;<span style="color:#fe2c24;">随着类的加载而执行，而且只执行一次</span><br>  &gt;作用：初始化类的信息<br>  &gt;如果一个类中定义了多个静态代码块，则按照声明的先后顺序执行<br>  &gt;<span style="color:#956fe7;">静态代码块的执行要优于非静态代码块的执行<br>  &gt;静态代码块内只能调用静态的属性、静态的方法，不能调用非静态的结构</span><br>  3.2<strong>非静态代码块</strong><br>  &gt;内部可以有输出语句<br>  &gt;<span style="color:#fe2c24;">随着对象的创建而执行<br>  &gt;每创建一个对象，就执行一次非静态代码块</span><br>  &gt;作用：可以在创建对象时，对对象的属性等进行初始化<br>  &gt;如果一个类中定义了多个非静态代码块，则按照声明的先后顺序执行<br>  &gt;<span style="color:#956fe7;">非静态代码块内可以调用静态的属性、静态的方法，或非静态的属性、非静态的方法</span><br>  <strong>对属性可以赋值的位置</strong>： (1)默认初始化  (2)显示初始化   (3)构造器中初始化    (4)有了对象以后，可以通过“对象.属性”或“对象.方法”的方式，进行赋值   (5)在代码块中赋值<br>  <strong>执行的先后顺序</strong>：(1)-&gt;(2)/(5)-&gt;(3)-&gt;(4)          <span style="color:#38d8f0;"><strong>  静态代码块 &gt; 动态初始化块 &gt; 构造器</strong></span></p> 
<h4><strong>关于代码块的另外一个分类：</strong></h4> 
<p><span style="color:#956fe7;"><strong>A.普通代码块</strong></span>：定义在方法中的代码块【知道即可】</p> 
<p><span style="color:#956fe7;"><strong>B.构造块：</strong></span>定义在类中，不加任何修饰符，直接使用{}定义的代码块</p> 
<p>当产生对象时执行构造代码块，优先于构造方法执行。有几个对象产生，构造代码块就执行几次。</p> 
<p><span style="color:#956fe7;"><strong>C.静态代码块</strong></span>：一般用于初始化静态成员属性。</p> 
<p>定义在类中，使用static修饰的代码块。当类加载时执行一次，与对象产生无关。</p> 
<p>静态代码块不管生成多少个对象，其只会执行一次，且是最先执行的。</p> 
<p>静态代码块执行完毕后，构造代码块(执行)，在然后是构造方法执行。</p> 
<p><span style="color:#956fe7;"><strong>D.同步代码块：(多线程)</strong></span></p> 
<pre><code class="language-java">class Person {
	String name;
	int age;
	static String desc = "我是一个人";
	public Person() {
	}
	public Person(String name, int age) {
		this.age = age;
		this.name = name;
	}
	// static代码块
	static {
		System.out.println("hello,static Block-&gt;1");
		System.out.println("我是一个爱学习的人");
	}
	static {
		System.out.println("hello,static Block-&gt;2");
		// 调用静态结构
		desc = "我是一个爱学习的人";

		// 不可以调用非静态结构
//		name = "Tom";
	}
	// 非static代码块
	{
		System.out.println("hello,Block-&gt;1");
		System.out.println("hello,Block-&gt;2");
		// 调用非静态结构
		age = 1;
		// 调用静态结构
		desc = "我是一个爱学习的人1";
	}
}</code></pre> 
<p>阿里笔试题：</p> 
<pre><code class="language-java">public class D extends B{
    public D(){
        System.out.println("4.D的构造方法");
    }
    {
        System.out.println("5.D的构造块");
    }
    static{
        System.out.println("6.D的静态代码块");
    }

    /**
     * 此时主方法所在的类D有静态代码块
     * 在执行主方法之前先加载类(先执行静态代码块)
     * &lt;D extends B&gt; -&gt; 先加载B而后加载D
     * new D() -&gt; 产生子类对象
     * 先调用父类的构造方法产生父类对象
     * @param args
     */
    public static void main(String[] args) {
        System.out.println("7.............");
        new D();
        new D();
        System.out.println("8.............");
        /*
        执行结果：3.B的静态块
        6.D的静态代码块
        7.............
        2.B的构造块
        1.B的无参构造    
        5.D的构造块
        4.D的构造方法
        2.B的构造块
        1.B的无参构造
        5.D的构造块
        4.D的构造方法
        8.............
         */
    }
}
class B{
    public B(){
        System.out.println("1.B的无参构造");
    }
    {
        System.out.println("2.B的构造块");
    }
    static{
        System.out.println("3.B的静态块");
    }
}</code></pre> 
<h3>5.内部类</h3> 
<h4>Java中允许将一个类A声明在另一个类B中，则类A就是内部类，类B称为外部类<br><span style="color:#fe2c24;">内部类的分类：</span></h4> 
<p>成员内部类（静态、非静态） vs 局部内部类（方法内、代码块内、构造器内）</p> 
<h4><span style="color:#fe2c24;">A.成员内部类：直接定义在类中，不加static定义的内部类</span></h4> 
<p>成员内部类必须依赖于外部类的存在而存在，必须先有外部类对象才能产生成员内部类。</p> 
<pre><code class="language-java">//成员内部类对象的产生
Inner in = new Inner();

//外部类的外部：前提是内部类对于外部的这个类可见的
Outter.Inner in = new Outter().new Inner();
//new Outter():产生了外部类的对象,然后通过此对象来构造内部类对象 =&gt; 当产生内部类对象时,构造这个内部类的外部类对象就会被编译器传入内部类
</code></pre> 
<p><strong>成员内部类实际上JVM会传入一个隐藏的外部类对象Outter.this </strong></p> 
<pre><code class="language-java">        Outter.Inner1 inner = new Outter().new Inner();
        //外部类Outter的对象在产生内部类的时候就由JVM传递给内部类
        System.out.println(Outter.this.age);</code></pre> 
<p>内部类和外部类可以方便的访问彼此的私有域</p> 
<p><img alt="" height="810" src="https://images2.imgbox.com/2c/55/atqRDO7J_o.png" width="1119"></p> 
<p><img alt="" height="354" src="https://images2.imgbox.com/e4/87/sMfOljhg_o.png" width="1200"> 无论那种内部类，在外部类的内部使用内部类的成员方法和成员属性，都必须显式的通过内部类对象来访问。反之，对于成员内部类来说，成员内部类先有外部类对象后才能创建成员内部类对象。</p> 
<pre><code class="language-java">Outter.Inner in = new Outter().newInner();</code></pre> 
<p>内部类访问外部类的私有域直接访问</p> 
<p>外部类要访问内部类的私有域，必须通过对象来访问。</p> 
<pre><code class="language-java">class Outter{
    private String msg = "outter类中的msg属性";
    //心脏和发动机都属于私有内部类,对外部完全隐藏,只是在类的内部来使用
    
    class Inner{
        private int num = 10;
        private String msg = "内部类的msg属性";
        public void test(){
            //直接访问外部类的msg属性
            //此处直接访问了外部类的私有成员变量msg,成员变量必须通过对象访问
            System.out.println(Outter.this.msg);
            //Outter.this.msg：内部类中隐藏了一个外部类的对象
        }
    }
}</code></pre> 
<p>成员内部类不能定义静态变量，成员内部类必须要依赖于外部类，若成员内部类有静态属性，没有外部类对象也能访问了</p> 
<p><img alt="" height="113" src="https://images2.imgbox.com/53/dc/DSwB0ZjR_o.png" width="499"></p> 
<p>对于外部类来说，能否在外部类的静态方法中使用成员内部类？ =&gt; 相当于在静态方法中调用成员变量 不行！比如：在外部类的main中创建内部类对象</p> 
<p> <img alt="" height="136" src="https://images2.imgbox.com/1a/1b/eFqdFobY_o.png" width="518"></p> 
<p>成员内部类，一方面，作为外部类的成员：<br>              &gt;调用外部类的结构<br>              &gt;可以被static修饰<br>              &gt;可以被4种不同的权限修饰<br> 另一方面，作为一个类：<br>              &gt;类内可以定义属性、方法、构造器等。<br>              &gt;可以被final修饰，表示此类不能被继承。言外之意，不使用final,就可以被继承<br>              &gt;可以被abstract修饰</p> 
<h4><span style="color:#fe2c24;"><strong>B.局部内部类：</strong></span></h4> 
<p><img alt="" height="843" src="https://images2.imgbox.com/96/5c/U2wiUJty_o.png" width="1200"></p> 
<p>  小点：成员内部类和局部内部类，在编译之后，都会生成字节码文件。<br>      格式：成员内部类：外部类$内部类名：class<br>                 局部内部类：外部类$数字 内部类名.class</p> 
<pre><code class="language-java">    // 开发中很少见
	public void method() {
		// 局部内部类
		class AA {

		}
	}</code></pre> 
<pre><code class="language-java">在局部内部类的方法中(比如：show)如果调用局部内部类所声明的方法(比如：method)中的局部变量
  (比如：num)的话，要求此局部变量声明为final的。
  jdk 7及之前的版本，要求此局部变量显示的声明为final的
  jdk 8及之后的版本，可以省略final的声明
	public void method() {
	    //局部变量
		int num = 10;
		class AA {
			public void show() {
//				num = 20;//不可被修改
			}
		}
	}</code></pre> 
<h4><span style="color:#fe2c24;">C.静态内部类：</span></h4> 
<p><img alt="" height="632" src="https://images2.imgbox.com/25/a4/ppEDKGGx_o.png" width="1200"></p> 
<p><strong>这个自我感觉还是一个特殊的点：静态内部类可以有自己的成员变量。 </strong></p> 
<p><img alt="" height="886" src="https://images2.imgbox.com/18/53/23PDM5FM_o.png" width="1200"></p> 
<h4><span style="color:#fe2c24;">D.匿名内部类：(Lambda表达式的前身)</span></h4> 
<p><span style="color:#4da8ee;"><strong>使用匿名内部类有个前提条件：必须继承一个父类或实现一个接口，普通类和抽象类都可以，但最多只能继承一个父类，或实现一个接口</strong></span></p> 
<p></p> 
<p><strong>关于匿名内部类必须要知道的两点知识：</strong></p> 
<p><strong>1、匿名内部类不能有构造器（构造方法），匿名内部类没有类名，不能定义构造器，构造方法的方法名是要与类名一致，但匿名内部类可以定义实例初始化块。</strong></p> 
<p><strong>2、匿名内部类不可以是抽象类，匿名内部类不能有构造器，而抽象类可以有构造方法，java在创建匿名内部类的时候，会立即创建内部类的对象，而抽象类不能创建实例，</strong></p> 
<pre><code class="language-java">interface Father{
    public abstract void speak();
}
public class NIMingDemo {
    public static void main(String[] args) {
        Father f=new Father() {
            @Override
            public void speak() {
                System.out.println("粑粑：孩子，不你不想拉粑粑");
            }
            public void eatBaBa(){
                System.out.println("熊孩子：粑粑，我想拉粑粑");
            }
        };
        f.speak();
        f.eatBaBa(); //编译失败，不能调用eatBaBa()方法
    }
}</code></pre> 
<p>程序过程中， f.eatBaBa(); 会编译失败，提示不能调用eatBaBa()方法，因为 Father f=new Father()创建的是Father的对象，而非匿名内部类的对象。其实匿名内部类连名字都没有，咋实例对象去调用它的方法呢？但是f.speak()方法却可以执行，因为匿名内部类实现了接口Father的</p> 
<p>speak()方法，因此可以借助Father的对象去调用。</p> 
<p><strong>如果想调用匿名内部类的自定义的eatBaBa()方法，有两个方法：</strong></p> 
<p><strong>方法一、 事实上匿名内部类中隐含一个匿名对象，通过该方法可以直接调用eatBaBa()和speak()方法；具体代码如下：</strong></p> 
<pre><code class="language-java">interface Father{
    public abstract void speak();
}
public class NIMingDemo {
    public static void main(String[] args) {
        new Father() {
            @Override
            public void speak() {
                System.out.println("粑粑：孩子，不你不想拉粑粑");
            }
            public void eatBaBa(){
                System.out.println("熊孩子：粑粑，我想拉粑粑");
            }
        }.eatBaBa() ;
    }
}</code></pre> 
<p><strong>只不过这个匿名对象只能使用一次！</strong></p> 
<p><strong>方法二、 把eatBaBa()方法更改为speak()方法一样的使用，也就是说在Father接口中声明eatBaBa()方法，然后在匿名内部类中覆写此方法即可。这个就不贴代码了！</strong></p> 
<p><strong><span style="color:#956fe7;">匿名内部类在多线程上的实现</span><br> 匿名内部类最常用的情况就是在多线程的实现上，因为要实现多线程必须继承Thread类或是继承Runnable接口</strong></p> 
<pre><code class="language-java">public class ThreadDemo {
    public static void main(String[] args) {
        Thread t = new Thread() {
            public void run() {
                for (int i = 1; i &lt;= 3; i++) {
                    System.out.print(i);
                }
            }
        };
        t.start();
    }
}
//运行结果：  123</code></pre> 
<h4><span style="color:#956fe7;"><strong>关于内部类重点关注如下的3个问题</strong></span><br>    4.1 如何实例化成员内部类的对象<br>    4.2 如何在成员内部类中区分调用外部类的结构</h4> 
<pre><code class="language-java">public class InnerClass_Test {
	public static void main(String[] args) {
		// 4.1实例化成员内部类的对象---------------------------------------
		// 创建Dog实例（静态的成员内部类）：
		Person.Dog dog = new Person.Dog();
		dog.show();
		// 创建Bird实例（非静态的成员内部类）：
//		Person.Bird brid = new Person.Bird();//错误的
		Person p = new Person();
		Person.Bird bird = p.new Bird();
		bird.sing();
		System.out.println();
		bird.display("黄鹂");
	}
}
class Person {
	String name = "小明";
	int age;
	public void eat() {
	}
	// 静态成员内部类
	static class Dog {
		String name;
		int age;
		public void show() {
		}
	}
	// 非静态成员内部类
	class Bird {
		String name = "杜鹃";
		public Bird() {
		}
		public void sing() {
			Person.this.eat();// 调用外部类的非静态属性
		}
//		4.2 在成员内部类中区分调用外部类的结构
		public void display(String name) {
			System.out.println(name);// 方法的形参// ：黄鹂
			System.out.println(this.name);// 内部类的属性// ：杜鹃
			System.out.println(Person.this.name);// 外部类的属性// ：小明
		}
	}
}</code></pre> 
<h4> 4.3 开发中局部类的使用</h4> 
<pre><code class="language-java">public class InnerClassTest1 {
	// 返回一个实现了Comparable接口的类的对象
    public Comparable getComparable() {
        // 创建一个实现了Comparable接口类：局部内部类
        // 方式一：
        class MyComparable implements Comparable{

            @Override
            public int compareTo(Object o) {
                return 0;
            }
        }
//        return new MyComparable();
        // 方式二：(匿名的方式:匿名内部类的匿名对象)
        return new Comparable() {
            @Override
            public int compareTo(Object o) {
                // TODO Auto-generated method stub
                return 0;
            }
        };
    }
	}</code></pre> 
<p>这篇博客非常好！！！！！ </p> 
<p><a href="https://blog.csdn.net/ruidianbaihuo/article/details/101110436?spm=1001.2014.3001.5502" title="JavaSE基础知识(二十)--Java内部类之为什么需要内部类_ruidianbaihuo的博客-CSDN博客">JavaSE基础知识(二十)--Java内部类之为什么需要内部类_ruidianbaihuo的博客-CSDN博客</a></p> 
<p></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/0e167bc6885a3c6f11bb70cd03695e79/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">IDEA使用gitee 史诗级保姆教程</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/1d76c7ae933f64e7e208fb306c0dbe4f/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">（二）五次多项式轨迹规划</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>