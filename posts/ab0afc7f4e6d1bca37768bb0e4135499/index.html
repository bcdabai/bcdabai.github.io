<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>C&#43;&#43; 实现RSA加密 - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="C&#43;&#43; 实现RSA加密" />
<meta property="og:description" content="背景:
因项目需要，要做一个调用短信接口发送短信的功能。需要实现一个功能是，给定一个字符串，给定一个密钥对。实现RSA公钥加密，Base64加密，然后将加密后的字符串发给服务器。服务器返回通过私钥和Base64加密后的字符串，然后我这边要实现Base64解密后，RSA公钥解密。
1.RSA加密的原理，网上都有很多介绍，在这就不介绍了，需要注意的概念如下：
rsa加解密分两种，第一：公钥加密私钥解密。第二：私钥加密公钥解密。 需要注意的是，公加私解得到的密文是变化的，而私加公解的得到的密文是固定的。
生成密匙对需要设置一个长度，常用的设置为1024，或者2048。注意，不同长度的密匙，能够加密的明文最长度是有限制的。说明如下：
1024的情况：
加密时，明文最大长度： 1024/8 - 11 = 117 ，因此需要对明文做117字节长度的分片加密，再拼接。
解密时，密文最大长度：1024/8 = 128， 因此需要对密文做128字节长度的分片解密，再拼接。
2048的情况：
加密时，明文最大长度： 2048/8 - 11 = 245 ，因此需要对明文做245字节长度的分片加密，再拼接。
解密时，密文最大长度：2048/8 = 256， 因此需要对密文做256字节长度的分片解密，再拼接。
C&#43;&#43;调用openssl库生成的密匙对是pkcs#1格式的。java调用库生成的密匙对是pkcs#8格式的。
pkcs#1
-----BEGIN RSA PUBLIC KEY-----
......公钥
-----END RSA PUBLIC KEY-----
-----BEGIN RSA PRIVATE KEY-----
......私钥
-----END RSA PRIVATE KEY-----
pkcs#8
-----BEGIN PUBLIC KEY-----
......公钥
-----END PUBLIC KEY-----
-----BEGIN PRIVATE KEY-----
......私钥
-----END PRIVATE KEY-----
2.先上代码
```
RSACrypt.h
#include &lt;openssl/rsa." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/ab0afc7f4e6d1bca37768bb0e4135499/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-06-26T23:31:29+08:00" />
<meta property="article:modified_time" content="2022-06-26T23:31:29+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">C&#43;&#43; 实现RSA加密</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p>背景:</p> 
<p>因项目需要，要做一个调用短信接口发送短信的功能。需要实现一个功能是，给定一个字符串，给定一个密钥对。实现RSA公钥加密，Base64加密，然后将加密后的字符串发给服务器。服务器返回通过私钥和Base64加密后的字符串，然后我这边要实现Base64解密后，RSA公钥解密。</p> 
<p>1.RSA加密的原理，网上都有很多介绍，在这就不介绍了，需要注意的概念如下：</p> 
<p>rsa加解密分两种，第一：公钥加密私钥解密。第二：私钥加密公钥解密。 需要注意的是，公加私解得到的密文是变化的，而私加公解的得到的密文是固定的。</p> 
<p>生成密匙对需要设置一个长度，常用的设置为1024，或者2048。注意，不同长度的密匙，能够加密的明文最长度是有限制的。说明如下：</p> 
<p>1024的情况：</p> 
<p>　　　　加密时，明文最大长度： 1024/8 - 11 = 117  ，因此需要对明文做117字节长度的分片加密，再拼接。</p> 
<p>　　　　解密时，密文最大长度：1024/8 = 128， 因此需要对密文做128字节长度的分片解密，再拼接。</p> 
<p>2048的情况：</p> 
<p>　　　　加密时，明文最大长度： 2048/8 - 11 = 245  ，因此需要对明文做245字节长度的分片加密，再拼接。</p> 
<p>　　　　解密时，密文最大长度：2048/8 = 256， 因此需要对密文做256字节长度的分片解密，再拼接。</p> 
<p>C++调用openssl库生成的密匙对是pkcs#1格式的。java调用库生成的密匙对是pkcs#8格式的。</p> 
<p>pkcs#1</p> 
<p>-----BEGIN RSA  PUBLIC KEY-----</p> 
<p>......公钥</p> 
<p>-----END RSA  PUBLIC KEY-----</p> 
<p>-----BEGIN RSA PRIVATE KEY-----</p> 
<p>......私钥</p> 
<p>-----END RSA PRIVATE KEY-----</p> 
<p>pkcs#8</p> 
<p>-----BEGIN PUBLIC KEY-----</p> 
<p>......公钥</p> 
<p>-----END PUBLIC KEY-----</p> 
<p>-----BEGIN PRIVATE KEY-----</p> 
<p>......私钥</p> 
<p>-----END PRIVATE KEY-----</p> 
<p>2.先上代码</p> 
<p>```</p> 
<p>RSACrypt.h</p> 
<p>#include &lt;openssl/rsa.h&gt;</p> 
<p>#include &lt;string&gt;</p> 
<p>class RSACrypt {<!-- --></p> 
<p>public:</p> 
<p>static RSACrypt *GetInstance();</p> 
<p>//RSA公钥加密 + 分片</p> 
<p>std::string RSA_Base64_pub_split117_encrypt(const std::string &amp;clearText);</p> 
<p>// 公钥解密 + 分片</p> 
<p>std::string RSA_Base64_pub_split128_decrypt(const std::string &amp;clearText);</p> 
<p>private:</p> 
<p>//RSA公钥加密</p> 
<p>std::string RSA_pub_encrypt(const std::string &amp;clearText);</p> 
<p>// 公钥解密</p> 
<p>std::string RSA_pub_decrypt(const std::string &amp;clearText);</p> 
<p>static std::string Init_public_key();</p> 
<p>std::string pubKey;</p> 
<p>};</p> 
<p>```</p> 
<p>```</p> 
<p>RSACrypt.cpp</p> 
<p>#include "RSACrypt.h"</p> 
<p>#include &lt;openssl/pem.h&gt;</p> 
<p>#include &lt;cstring&gt;</p> 
<p>#include &lt;iostream&gt;</p> 
<p>#include "Base64.h"</p> 
<p>using std::cout;</p> 
<p>static RSACrypt instance;</p> 
<p>RSACrypt* RSACrypt::GetInstance() {<!-- --></p> 
<p>if(instance.pubKey.empty()){<!-- --></p> 
<p>instance.pubKey = instance.Init_public_key();</p> 
<p>}</p> 
<p>return &amp;instance;</p> 
<p>}</p> 
<p>std::string BaseEncode(std::string code){<!-- --></p> 
<p>unsigned char *str = (unsigned char*)(code.c_str());</p> 
<p>std::string encoded;</p> 
<p>int len = code.length();</p> 
<p>Base64 *base = new Base64();</p> 
<p>encoded = base -&gt;Encode(str,len);</p> 
<p>delete base;</p> 
<p>return encoded;</p> 
<p>}</p> 
<p>std::string BaseDecode(std::string encoded){<!-- --></p> 
<p>std::string normal;</p> 
<p>Base64 *base = new Base64();</p> 
<p>int len = encoded.length();</p> 
<p>const char * str2 = encoded.c_str();</p> 
<p>normal = base-&gt;Decode(str2,len);</p> 
<p>delete base;</p> 
<p>return normal;</p> 
<p>}</p> 
<p>//RSA公钥加密</p> 
<p>std::string RSACrypt::Init_public_key(){<!-- --></p> 
<p>std::string strPublicKey  = "MIGfMB0GCSqGSIb3DQEBAQUAA4GNADCBiQKBgQCCFCPUaNuen2ctFEri2gG0kLzFGq7hxkP16UHQg2z9xPJh86RpCbLunKgzI64y4A8zo2plECHZxW1R9ltzbN4pfoU6geSl2+Yl247KOqa0IkxkjEawiSYaufWZ1HZbhaKdjugF/GukOkHp+l7LaYXV9ja9Gam98/WoxWJXS1tOVQIDAQAB";</p> 
<p>int nPublicKeyLen = strPublicKey.size();//strPublicKey为base64编码的公钥字符串</p> 
<p>for(int i = 64; i &lt; nPublicKeyLen; i+=64) {<!-- --></p> 
<p>if (strPublicKey[i] != '\n') {<!-- --></p> 
<p>strPublicKey.insert(i, "\n");</p> 
<p>}</p> 
<p>i++;</p> 
<p>}</p> 
<p>strPublicKey.insert(0, "-----BEGIN PUBLIC KEY-----\n");</p> 
<p>strPublicKey.append("\n-----END PUBLIC KEY-----\n");</p> 
<p>return strPublicKey;</p> 
<p>}</p> 
<p>std::string RSACrypt::RSA_pub_encrypt(const std::string &amp;clearText)</p> 
<p>{ </p> 
<p>std::string strRet;</p> 
<p>BIO *keybio = BIO_new_mem_buf((unsigned char *)pubKey.c_str(), -1); </p> 
<p>//keybio = BIO_new_mem_buf((unsigned char *)strPublicKey.c_str(), -1); </p> 
<p>// 此处有三种方法 </p> 
<p>// 1, 读取内存里生成的密钥对，再从内存生成rsa </p> 
<p>// 2, 读取磁盘里生成的密钥对文本文件，在从内存生成rsa </p> 
<p>// 3，直接从读取文件指针生成rsa </p> 
<p>//RSA* pRSAPublicKey = RSA_new(); </p> 
<p>RSA* rsa = RSA_new();</p> 
<p>rsa = PEM_read_bio_RSA_PUBKEY(keybio,NULL,NULL,NULL);</p> 
<p>if (!rsa)</p> 
<p>{<!-- --></p> 
<p>BIO_free_all(keybio);</p> 
<p>return std::string("");</p> 
<p>}</p> 
<p>int len = RSA_size(rsa); </p> 
<p>//int len = 1028;</p> 
<p>char *encryptedText = (char *)malloc(len + 1); </p> 
<p>memset(encryptedText, 0, len + 1); </p> 
<p>// 加密函数 </p> 
<p>int ret = RSA_public_encrypt(clearText.length(), (const unsigned char*)clearText.c_str(), (unsigned char*)encryptedText, rsa, RSA_PKCS1_PADDING); </p> 
<p>if (ret &gt;= 0) </p> 
<p>strRet = std::string(encryptedText, ret);</p> 
<p>// 释放内存 </p> 
<p>free(encryptedText); </p> 
<p>BIO_free_all(keybio); </p> 
<p>RSA_free(rsa);</p> 
<p>return strRet;</p> 
<p>}</p> 
<p>//公钥加密 + 分片</p> 
<p>std::string RSACrypt::RSA_Base64_pub_split117_encrypt(const std::string &amp;clearText)</p> 
<p>{<!-- --></p> 
<p>std::string result;</p> 
<p>std::string input;</p> 
<p>result.clear();</p> 
<p>for(int i = 0 ; i&lt; clearText.length()/117; i++)</p> 
<p>{<!-- --></p> 
<p>input.clear();</p> 
<p>input.assign(clearText.begin() + i*117, clearText.begin() + i*117 + 117);</p> 
<p>result = result + RSA_pub_encrypt(input);</p> 
<p>}</p> 
<p>if(clearText.length()%117 != 0)</p> 
<p>{<!-- --></p> 
<p>int tem1 = clearText.length()/117 * 117;</p> 
<p>input.clear();</p> 
<p>input.assign(clearText.begin()+ tem1, clearText.end());</p> 
<p>std::string encode = RSA_pub_encrypt(input);</p> 
<p>result = result + encode;</p> 
<p>}</p> 
<p>std::string encode_str = BaseEncode(result);</p> 
<p>return encode_str;</p> 
<p>}</p> 
<p>// 公钥解密</p> 
<p>std::string RSACrypt::RSA_pub_decrypt(const std::string &amp;clearText)</p> 
<p>{<!-- --></p> 
<p>std::string strRet;</p> 
<p>BIO *keybio = BIO_new_mem_buf((unsigned char *)pubKey.c_str(), -1);</p> 
<p>RSA* rsa = RSA_new();</p> 
<p>rsa = PEM_read_bio_RSA_PUBKEY(keybio, NULL, NULL, NULL);</p> 
<p>if (!rsa)</p> 
<p>{<!-- --></p> 
<p>BIO_free_all(keybio);</p> 
<p>return std::string("");</p> 
<p>}</p> 
<p>int len = RSA_size(rsa);</p> 
<p>//int len = 1028;</p> 
<p>char *encryptedText = (char *)malloc(len + 1);</p> 
<p>memset(encryptedText, 0, len + 1);</p> 
<p>//解密</p> 
<p>int ret = RSA_public_decrypt(clearText.length(), (const unsigned char*)clearText.c_str(), (unsigned char*)encryptedText, rsa, RSA_PKCS1_PADDING);</p> 
<p>if (ret &gt;= 0)</p> 
<p>strRet = std::string(encryptedText, ret);</p> 
<p>// 释放内存</p> 
<p>free(encryptedText);</p> 
<p>BIO_free_all(keybio);</p> 
<p>RSA_free(rsa);</p> 
<p>return strRet;</p> 
<p>}</p> 
<p>//公钥解密 + 分片</p> 
<p>std::string RSACrypt::RSA_Base64_pub_split128_decrypt(const std::string &amp;text)</p> 
<p>{<!-- --></p> 
<p>std::string clearText = BaseDecode(text);</p> 
<p>std::string result;</p> 
<p>std::string input;</p> 
<p>result.clear();</p> 
<p>for(int i = 0 ; i&lt; clearText.length()/128; i++)</p> 
<p>{<!-- --></p> 
<p>input.clear();</p> 
<p>input.assign(clearText.begin() + i*128, clearText.begin() + i*128 + 128);</p> 
<p>result = result + RSA_pub_decrypt(input);</p> 
<p>}</p> 
<p>if(clearText.length()%128 != 0)</p> 
<p>{<!-- --></p> 
<p>int tem1 = clearText.length()/128 * 128;</p> 
<p>input.clear();</p> 
<p>input.assign(clearText.begin()+ tem1, clearText.end());</p> 
<p>result = result + RSA_pub_decrypt(input);</p> 
<p>}</p> 
<p>return result;</p> 
<p>}</p> 
<p>```</p> 
<p>##走过的坑</p> 
<p>1.网上很多帖子，GitHub上的RSA，c++实现也很多都是init，自动生成秘钥对。但是业务场景是给定的公钥去加密解密，不需要随时变更。</p> 
<p>2.OpenSSL库，PEM_read_bio_RSA_PUBKEY对应的密钥对是pkcs#8类型。pem方法跟密钥对的类型一定要匹配，不然RSA得到的就是NULL，无法加密解密。</p> 
<p>3.开始PEM_read_bio_RSA_PUBKEY的参数 keybio，纠结是传什么值进去，秘钥的string还是pem的路径。最后发现是拼接好的pkcs#8类型的字符串即可。</p> 
<p><br> 参考链接：</p> 
<p><a href="https://sslhow.com/openssl-rsa-keys" rel="nofollow" title="Generate Private and Public Keys with OpenSSL Genrsa Command - SSLHOW">Generate Private and Public Keys with OpenSSL Genrsa Command - SSLHOW</a></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/e924282e1d9a2695729592aab9e84e36/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">JavaScript中apply函数的实现</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/52d5f1d974f92c644896a616363d6474/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">关于C/C&#43;&#43;的换行</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>