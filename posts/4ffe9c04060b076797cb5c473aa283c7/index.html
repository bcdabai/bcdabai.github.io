<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>神经网络 python 多类别_Keras入门（一）搭建深度神经网络（DNN）解决多分类问题... - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="神经网络 python 多类别_Keras入门（一）搭建深度神经网络（DNN）解决多分类问题..." />
<meta property="og:description" content="Keras介绍
Keras是一个开源的高层神经网络API，由纯Python编写而成，其后端可以基于Tensorflow、Theano、MXNet以及CNTK。Keras 为支持快速实验而生，能够把你的idea迅速转换为结果。Keras适用的Python版本是：Python 2.7-3.6。
Keras，在希腊语中意为“角”(horn)，于2015年3月份第一次发行，它可以在Windows, Linux, Mac等系统中运行。那么，既然有了TensorFlow(或Theano、MXNet、CNTK)，为什么还需要Keras呢？这是因为，尽管我们可以用TensorFlow等来创建深度神经网络系统，但Tensorflow等使用相对低级的抽象，直接编写TensorFlow代码具有一定的挑战性，而Keras在TensorFlow的基础上，增加了较易使用的抽象层，使用起来更加简单、高效。
什么样的场合适合用Keras呢？如果你有如下需求，请选择Keras：
简易和快速的原型设计(keras具有高度模块化，极简，和可扩充特性)
支持CNN和RNN，或二者的结合
无缝CPU和GPU切换
如果想用在你的电脑上使用Keras，需要以下工具：
Python
TensorFlow
Keras
在这里，我们选择TensorFlow作为Keras的后端工具。使用以下Python代码，可以输出Python、TensorFlow以及Keras的版本号：
import sys
import keras as K
import tensorflow as tf
py_ver = sys.version
k_ver = K.__version__
tf_ver = tf.__version__
print(&#34;Using Python version &#34; &#43; str(py_ver))
print(&#34;Using Keras version &#34; &#43; str(k_ver))
print(&#34;Using TensorFlow version &#34; &#43; str(tf_ver))
在笔者的电脑上，输出的结果如下：
Using TensorFlow backend.
Using Python version 3.5.1 (v3.5.1:37a07cee5969, Dec 6 2015, 01:54:25) [MSC v.1900 64 bit (AMD64)]" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/4ffe9c04060b076797cb5c473aa283c7/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2020-12-10T22:46:17+08:00" />
<meta property="article:modified_time" content="2020-12-10T22:46:17+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">神经网络 python 多类别_Keras入门（一）搭建深度神经网络（DNN）解决多分类问题...</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <div style="font-size:16px;"> 
 <p>Keras介绍</p> 
 <p>Keras是一个开源的高层神经网络API，由纯Python编写而成，其后端可以基于Tensorflow、Theano、MXNet以及CNTK。Keras 为支持快速实验而生，能够把你的idea迅速转换为结果。Keras适用的Python版本是：Python 2.7-3.6。</p> 
 <p>Keras，在希腊语中意为“角”(horn)，于2015年3月份第一次发行，它可以在Windows, Linux, Mac等系统中运行。那么，既然有了TensorFlow(或Theano、MXNet、CNTK)，为什么还需要Keras呢？这是因为，尽管我们可以用TensorFlow等来创建深度神经网络系统，但Tensorflow等使用相对低级的抽象，直接编写TensorFlow代码具有一定的挑战性，而Keras在TensorFlow的基础上，增加了较易使用的抽象层，使用起来更加简单、高效。</p> 
 <p>什么样的场合适合用Keras呢？如果你有如下需求，请选择Keras：</p> 
 <p>简易和快速的原型设计(keras具有高度模块化，极简，和可扩充特性)</p> 
 <p>支持CNN和RNN，或二者的结合</p> 
 <p>无缝CPU和GPU切换</p> 
 <p>如果想用在你的电脑上使用Keras，需要以下工具：</p> 
 <p>Python</p> 
 <p>TensorFlow</p> 
 <p>Keras</p> 
 <p>在这里，我们选择TensorFlow作为Keras的后端工具。使用以下Python代码，可以输出Python、TensorFlow以及Keras的版本号：</p> 
 <p>import sys</p> 
 <p>import keras as K</p> 
 <p>import tensorflow as tf</p> 
 <p>py_ver = sys.version</p> 
 <p>k_ver = K.__version__</p> 
 <p>tf_ver = tf.__version__</p> 
 <p>print("Using Python version " + str(py_ver))</p> 
 <p>print("Using Keras version " + str(k_ver))</p> 
 <p>print("Using TensorFlow version " + str(tf_ver))</p> 
 <p>在笔者的电脑上，输出的结果如下：</p> 
 <p>Using TensorFlow backend.</p> 
 <p>Using Python version 3.5.1 (v3.5.1:37a07cee5969, Dec 6 2015, 01:54:25) [MSC v.1900 64 bit (AMD64)]</p> 
 <p>Using Keras version 2.1.5</p> 
 <p>Using TensorFlow version 1.6.0</p> 
 <p>下面，笔者将使用IRIS数据集(鸢尾花数据集，一个经典的机器学习数据集，适合作为多分类问题的测试数据)，使用Keras搭建一个深度神经网络(DNN)，来解决IRIS数据集的多分类问题，作为Keras入门的第一个例子。</p> 
 <p>IRIS数据集介绍</p> 
 <p>IRIS数据集(鸢尾花数据集)，是一个经典的机器学习数据集，适合作为多分类问题的测试数据，它的下载地址为：http://archive.ics.uci.edu/ml...。</p> 
 <p>IRIS数据集是用来给鸢尾花做分类的数据集，一共150个样本，每个样本包含了花萼长度(sepal length in cm)、花萼宽度(sepal width in cm)、花瓣长度(petal length in cm)、花瓣宽度(petal width in cm)四个特征，将鸢尾花分为三类，分别为Iris Setosa，Iris Versicolour，Iris Virginica，每一类都有50个样本。</p> 
 <p>IRIS数据集具体如下(只展示部分数据，顺序已打乱)：</p> 
 <p align="center"><img src="" alt=""></p> 
 <p>读取数据集</p> 
 <p>笔者的IRIS数据集以csv格式储存，笔者将使用Pandas来读取IRIS数据集，并对目标变量进行0-1编码(One-hot Encoding)，最后将该数据集分为训练集和测试集，比例为7:3。完整的Python代码如下：</p> 
 <p>import pandas as pd</p> 
 <p>from sklearn.model_selection import train_test_split</p> 
 <p>from sklearn.preprocessing import LabelBinarizer</p> 
 <p># 读取CSV数据集，并拆分为训练集和测试集</p> 
 <p># 该函数的传入参数为CSV_FILE_PATH: csv文件路径</p> 
 <p>def load_data(CSV_FILE_PATH):</p> 
 <p>IRIS = pd.read_csv(CSV_FILE_PATH)</p> 
 <p>target_var = 'class' # 目标变量</p> 
 <p># 数据集的特征</p> 
 <p>features = list(IRIS.columns)</p> 
 <p>features.remove(target_var)</p> 
 <p># 目标变量的类别</p> 
 <p>Class = IRIS[target_var].unique()</p> 
 <p># 目标变量的类别字典</p> 
 <p>Class_dict = dict(zip(Class, range(len(Class))))</p> 
 <p># 增加一列target, 将目标变量进行编码</p> 
 <p>IRIS['target'] = IRIS[target_var].apply(lambda x: Class_dict[x])</p> 
 <p># 对目标变量进行0-1编码(One-hot Encoding)</p> 
 <p>lb = LabelBinarizer()</p> 
 <p>lb.fit(list(Class_dict.values()))</p> 
 <p>transformed_labels = lb.transform(IRIS['target'])</p> 
 <p>y_bin_labels = [] # 对多分类进行0-1编码的变量</p> 
 <p>for i in range(transformed_labels.shape[1]):</p> 
 <p>y_bin_labels.append('y' + str(i))</p> 
 <p>IRIS['y' + str(i)] = transformed_labels[:, i]</p> 
 <p># 将数据集分为训练集和测试集</p> 
 <p>train_x, test_x, train_y, test_y = train_test_split(IRIS[features], IRIS[y_bin_labels], \</p> 
 <p>train_size=0.7, test_size=0.3, random_state=0)</p> 
 <p>return train_x, test_x, train_y, test_y, Class_dict</p> 
 <p>搭建DNN</p> 
 <p>接下来，笔者将展示如何利用Keras来搭建一个简单的深度神经网络(DNN)来解决这个多分类问题。我们要搭建的DNN的结构如下图所示：</p> 
 <p align="center"><img src="" alt=""></p> 
 <p>我们搭建的DNN由输入层、隐藏层、输出层和softmax函数组成，其中输入层由4个神经元组成，对应IRIS数据集中的4个特征，作为输入向量，隐藏层有两层，每层分别有5和6个神经元，之后就是输出层，由3个神经元组成，对应IRIS数据集的目标变量的类别个数，最后，就是一个softmax函数，用于解决多分类问题而创建。</p> 
 <p>对应以上的DNN结构，用Keras来搭建的话，其Python代码如下：</p> 
 <p>import keras as K</p> 
 <p># 2. 定义模型</p> 
 <p>init = K.initializers.glorot_uniform(seed=1)</p> 
 <p>simple_adam = K.optimizers.Adam()</p> 
 <p>model = K.models.Sequential()</p> 
 <p>model.add(K.layers.Dense(units=5, input_dim=4, kernel_initializer=init, activation='relu'))</p> 
 <p>model.add(K.layers.Dense(units=6, kernel_initializer=init, activation='relu'))</p> 
 <p>model.add(K.layers.Dense(units=3, kernel_initializer=init, activation='softmax'))</p> 
 <p>model.compile(loss='categorical_crossentropy', optimizer=simple_adam, metrics=['accuracy'])</p> 
 <p>在这个模型中，我们选择的神经元激活函数为ReLU函数，损失函数为交叉熵(cross entropy)，迭代的优化器(optimizer)选择Adam，最初各个层的连接权重(weights)和偏重(biases)是随机生成的。这样我们就讲这个DNN的模型定义完毕了。这么简单？Yes, that's it!</p> 
 <p>训练及预测</p> 
 <p>OK，定义完模型后，我们需要对模型进行训练、评估及预测。对于模型训练，我们每次训练的批数为1，共迭代100次，代码如下(接以上代码)：</p> 
 <p># 3. 训练模型</p> 
 <p>b_size = 1</p> 
 <p>max_epochs = 100</p> 
 <p>print("Starting training ")</p> 
 <p>h = model.fit(train_x, train_y, batch_size=b_size, epochs=max_epochs, shuffle=True, verbose=1)</p> 
 <p>print("Training finished \n")</p> 
 <p>为了对模型有个评估，感知模型的表现，需要输出该DNN模型的损失函数的值以及在测试集上的准确率，其Python代码如下(接以上代码)：</p> 
 <p># 4. 评估模型</p> 
 <p>eval = model.evaluate(test_x, test_y, verbose=0)</p> 
 <p>print("Evaluation on test data: loss = %0.6f accuracy = %0.2f%% \n" \</p> 
 <p>% (eval[0], eval[1] * 100) )</p> 
 <p>训练100次，输出的结果如下(中间部分的训练展示已忽略)：</p> 
 <p>Starting training</p> 
 <p>Epoch 1/100</p> 
 <p>1/105 [..............................] - ETA: 17s - loss: 0.3679 - acc: 1.0000</p> 
 <p>42/105 [===========&gt;..................] - ETA: 0s - loss: 1.8081 - acc: 0.3095</p> 
 <p>89/105 [========================&gt;.....] - ETA: 0s - loss: 1.5068 - acc: 0.4270</p> 
 <p>105/105 [==============================] - 0s 3ms/step - loss: 1.4164 - acc: 0.4667</p> 
 <p>Epoch 2/100</p> 
 <p>1/105 [..............................] - ETA: 0s - loss: 0.4766 - acc: 1.0000</p> 
 <p>45/105 [===========&gt;..................] - ETA: 0s - loss: 1.0813 - acc: 0.4889</p> 
 <p>93/105 [=========================&gt;....] - ETA: 0s - loss: 1.0335 - acc: 0.4839</p> 
 <p>105/105 [==============================] - 0s 1ms/step - loss: 1.0144 - acc: 0.4857</p> 
 <p>......</p> 
 <p>Epoch 99/100</p> 
 <p>1/105 [..............................] - ETA: 0s - loss: 0.0013 - acc: 1.0000</p> 
 <p>43/105 [===========&gt;..................] - ETA: 0s - loss: 0.0447 - acc: 0.9767</p> 
 <p>84/105 [=======================&gt;......] - ETA: 0s - loss: 0.0824 - acc: 0.9524</p> 
 <p>105/105 [==============================] - 0s 1ms/step - loss: 0.0711 - acc: 0.9619</p> 
 <p>Epoch 100/100</p> 
 <p>1/105 [..............................] - ETA: 0s - loss: 2.3032 - acc: 0.0000e+00</p> 
 <p>51/105 [=============&gt;................] - ETA: 0s - loss: 0.1122 - acc: 0.9608</p> 
 <p>99/105 [===========================&gt;..] - ETA: 0s - loss: 0.0755 - acc: 0.9798</p> 
 <p>105/105 [==============================] - 0s 1ms/step - loss: 0.0756 - acc: 0.9810</p> 
 <p>Training finished</p> 
 <p>Evaluation on test data: loss = 0.094882 accuracy = 97.78%</p> 
 <p>可以看到，训练完100次后，在测试集上的准确率已达到97.78%，效果相当好。</p> 
 <p>最后是对新数据集进行预测，我们假设一朵鸢尾花的4个特征为6.1,3.1,5.1,1.1，我们想知道这个DNN模型会把它预测到哪一类，其Python代码如下：</p> 
 <p>import numpy as np</p> 
 <p># 5. 使用模型进行预测</p> 
 <p>np.set_printoptions(precision=4)</p> 
 <p>unknown = np.array([[6.1, 3.1, 5.1, 1.1]], dtype=np.float32)</p> 
 <p>predicted = model.predict(unknown)</p> 
 <p>print("Using model to predict species for features: ")</p> 
 <p>print(unknown)</p> 
 <p>print("\nPredicted softmax vector is: ")</p> 
 <p>print(predicted)</p> 
 <p>species_dict = {v:k for k,v in Class_dict.items()}</p> 
 <p>print("\nPredicted species is: ")</p> 
 <p>print(species_dict[np.argmax(predicted)])</p> 
 <p>输出的结果如下：</p> 
 <p>Using model to predict species for features:</p> 
 <p>[[ 6.1 3.1 5.1 1.1]]</p> 
 <p>Predicted softmax vector is:</p> 
 <p>[[ 2.0687e-07 9.7901e-01 2.0993e-02]]</p> 
 <p>Predicted species is:</p> 
 <p>versicolor</p> 
 <p>如果我们仔细地比对IRIS数据集，就会发现，这个预测结果令人相当满意，这个鸢尾花样本的预测结果，以人类的眼光来看，也应当是versicolor。</p> 
 <p>总结</p> 
 <p>到此为止，笔者就把这个演示例子给讲完了，作为入门Keras的第一步，这个例子还是可以的。回顾该模型，首先我们利用Pandas读取IRIS数据集，并分为训练集和测试集，然后用Keras搭建了一个简单的DNN模型，并对该模型进行训练及评估，最后看一下该模型在新数据集上的预测能力。从中，读者不难体会到Keras的优越性，因为，相比TensorFlow,搭建同样的DNN模型及模型训练、评估、预测，其Python代码无疑会比Keras来得长。</p> 
 <p>最后，附上该DNN模型的完整Python代码：</p> 
 <p># iris_keras_dnn.py</p> 
 <p># Python 3.5.1, TensorFlow 1.6.0, Keras 2.1.5</p> 
 <p># ========================================================</p> 
 <p># 导入模块</p> 
 <p>import os</p> 
 <p>import numpy as np</p> 
 <p>import keras as K</p> 
 <p>import tensorflow as tf</p> 
 <p>import pandas as pd</p> 
 <p>from sklearn.model_selection import train_test_split</p> 
 <p>from sklearn.preprocessing import LabelBinarizer</p> 
 <p>os.environ['TF_CPP_MIN_LOG_LEVEL']='2'</p> 
 <p># 读取CSV数据集，并拆分为训练集和测试集</p> 
 <p># 该函数的传入参数为CSV_FILE_PATH: csv文件路径</p> 
 <p>def load_data(CSV_FILE_PATH):</p> 
 <p>IRIS = pd.read_csv(CSV_FILE_PATH)</p> 
 <p>target_var = 'class' # 目标变量</p> 
 <p># 数据集的特征</p> 
 <p>features = list(IRIS.columns)</p> 
 <p>features.remove(target_var)</p> 
 <p># 目标变量的类别</p> 
 <p>Class = IRIS[target_var].unique()</p> 
 <p># 目标变量的类别字典</p> 
 <p>Class_dict = dict(zip(Class, range(len(Class))))</p> 
 <p># 增加一列target, 将目标变量进行编码</p> 
 <p>IRIS['target'] = IRIS[target_var].apply(lambda x: Class_dict[x])</p> 
 <p># 对目标变量进行0-1编码(One-hot Encoding)</p> 
 <p>lb = LabelBinarizer()</p> 
 <p>lb.fit(list(Class_dict.values()))</p> 
 <p>transformed_labels = lb.transform(IRIS['target'])</p> 
 <p>y_bin_labels = [] # 对多分类进行0-1编码的变量</p> 
 <p>for i in range(transformed_labels.shape[1]):</p> 
 <p>y_bin_labels.append('y' + str(i))</p> 
 <p>IRIS['y' + str(i)] = transformed_labels[:, i]</p> 
 <p># 将数据集分为训练集和测试集</p> 
 <p>train_x, test_x, train_y, test_y = train_test_split(IRIS[features], IRIS[y_bin_labels], \</p> 
 <p>train_size=0.7, test_size=0.3, random_state=0)</p> 
 <p>return train_x, test_x, train_y, test_y, Class_dict</p> 
 <p>def main():</p> 
 <p># 0. 开始</p> 
 <p>print("\nIris dataset using Keras/TensorFlow ")</p> 
 <p>np.random.seed(4)</p> 
 <p>tf.set_random_seed(13)</p> 
 <p># 1. 读取CSV数据集</p> 
 <p>print("Loading Iris data into memory")</p> 
 <p>CSV_FILE_PATH = 'E://iris.csv'</p> 
 <p>train_x, test_x, train_y, test_y, Class_dict = load_data(CSV_FILE_PATH)</p> 
 <p># 2. 定义模型</p> 
 <p>init = K.initializers.glorot_uniform(seed=1)</p> 
 <p>simple_adam = K.optimizers.Adam()</p> 
 <p>model = K.models.Sequential()</p> 
 <p>model.add(K.layers.Dense(units=5, input_dim=4, kernel_initializer=init, activation='relu'))</p> 
 <p>model.add(K.layers.Dense(units=6, kernel_initializer=init, activation='relu'))</p> 
 <p>model.add(K.layers.Dense(units=3, kernel_initializer=init, activation='softmax'))</p> 
 <p>model.compile(loss='categorical_crossentropy', optimizer=simple_adam, metrics=['accuracy'])</p> 
 <p># 3. 训练模型</p> 
 <p>b_size = 1</p> 
 <p>max_epochs = 100</p> 
 <p>print("Starting training ")</p> 
 <p>h = model.fit(train_x, train_y, batch_size=b_size, epochs=max_epochs, shuffle=True, verbose=1)</p> 
 <p>print("Training finished \n")</p> 
 <p># 4. 评估模型</p> 
 <p>eval = model.evaluate(test_x, test_y, verbose=0)</p> 
 <p>print("Evaluation on test data: loss = %0.6f accuracy = %0.2f%% \n" \</p> 
 <p>% (eval[0], eval[1] * 100) )</p> 
 <p># 5. 使用模型进行预测</p> 
 <p>np.set_printoptions(precision=4)</p> 
 <p>unknown = np.array([[6.1, 3.1, 5.1, 1.1]], dtype=np.float32)</p> 
 <p>predicted = model.predict(unknown)</p> 
 <p>print("Using model to predict species for features: ")</p> 
 <p>print(unknown)</p> 
 <p>print("\nPredicted softmax vector is: ")</p> 
 <p>print(predicted)</p> 
 <p>species_dict = {v:k for k,v in Class_dict.items()}</p> 
 <p>print("\nPredicted species is: ")</p> 
 <p>print(species_dict[np.argmax(predicted)])</p> 
 <p>main()</p> 
 <p>参考文献</p> 
</div>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/c08d7c389b373bdfb6c582326c2e47af/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">秋招面试知识点----框架篇</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/8675fd740ae98b7ac4d960314a2ee1d8/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">秋招面试知识点----机网，linux等其他篇</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>