<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>高性能 Go 语言发行版优化与落地实践 （Go 内存管理及优化、编译器优化） - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="高性能 Go 语言发行版优化与落地实践 （Go 内存管理及优化、编译器优化）" />
<meta property="og:description" content="本文是记录2022年5月字节跳动青训营的课程笔记！！！ 本文内容：
优化：
内存管理优化
编译器优化
背景：
自动内存管理和Go内存管理机制
编译器优化的基本问题和思路
实践：
字节跳动遇到的性能问题和优化方案
性能优化： 性能优化是什么：
提升软件能力，减少不必要的消耗，充分发掘计算机的能力
为什么要做性能优化：
用户体验：带来用户体验的提升
资源高效利用：降低成本、提高效率
1.自动内存管理 1.1背景及概念 动态内存：
程序在运行时根据需求动态分配的内存
自动内存管理：
由程序语言的运行时系统管理动态内存
优点：
避免手动内存管理，专注于实现业务逻辑
保证内存使用的正确性和安全性
三个任务：
为新对象分配空间
找到存活对象
回收死亡对象的内存空间
Mutator：业务线程，分配新对象，修改对象的指向关系
Collector：GC线程，找到存活对象，回收死亡对象的内存空间
Serial GC:只有一个GC
ParallelGC：支持多个collectors同时回收GC的算法
Concurrent GC：mutator和collector可以同时执行 注：Collectors必须感知对象指向关系的改变
评价GC算法：
安全性：不能回收存活对象 基本要求
吞吐率：1-GC时间/程序运行总时间 花在GC上的时间
暂停时间：STW 业务是否感知
内存开销：GC元数据开销
1.2追踪垃圾回收 对象被回收的条件：指针指向关系不可达的对象
标记根对象（静态变量、全局变量、常量、线程栈等）
标记：可达对象
求指针指向关系的传递闭包：从根对象出发，找到所有可达对象
清理：所有不可达对象
将存活对象复制到另外的内存空间（Copying GC）
将死亡对象的内存标记为“可分配”（Mark-sweep GC）
移动并整理存活对象（Mark-compact GC）
根据对象的生命周期，使用不同的标记和清理策略
分代GC 跟Java JVM 类似
Java 虚拟机（JVM）学习笔记_芙蓉铁蛋的博客-CSDN博客
对年轻和老年代的对象，制定不同的GC策略，降低整体内存管理开销
不同年龄的对象处于heap的不同区域
年轻代：常规的对象分配，由于存活对象很少可以采用copying collection GC吞吐率高" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/1f65ca782cbe5258156d89a26c44b7c9/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-05-12T19:25:36+08:00" />
<meta property="article:modified_time" content="2022-05-12T19:25:36+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">高性能 Go 语言发行版优化与落地实践 （Go 内存管理及优化、编译器优化）</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <h2>本文是记录2022年5月字节跳动青训营的课程笔记！！！</h2> 
<p><strong>本文内容：</strong></p> 
<p><strong>                优化：</strong></p> 
<p><strong>                        内存管理优化</strong></p> 
<p><strong>                        编译器优化</strong></p> 
<p><strong>                背景：</strong></p> 
<p><strong>                        自动内存管理和Go内存管理机制</strong></p> 
<p><strong>                        编译器优化的基本问题和思路</strong></p> 
<p><strong>                实践：</strong></p> 
<p><strong>                        字节跳动遇到的性能问题和优化方案</strong></p> 
<h2>性能优化：</h2> 
<p><strong>性能优化是什么：</strong></p> 
<p><strong>        提升软件能力，减少不必要的消耗，充分发掘计算机的能力</strong></p> 
<p><strong>为什么要做性能优化：</strong></p> 
<p><strong>        用户体验：带来用户体验的提升</strong></p> 
<p><strong>        资源高效利用：降低成本、提高效率</strong></p> 
<h2>1.自动内存管理</h2> 
<h3>1.1背景及概念</h3> 
<p><strong>动态内存：</strong></p> 
<p>程序在运行时根据需求动态分配的内存</p> 
<p><strong>自动内存管理：</strong></p> 
<p>由程序语言的运行时系统管理动态内存</p> 
<p><strong>优点：</strong></p> 
<p>        避免手动内存管理，专注于实现业务逻辑</p> 
<p>        保证内存使用的正确性和安全性</p> 
<p><strong>三个任务：</strong></p> 
<p>为新对象分配空间</p> 
<p>找到存活对象</p> 
<p>回收死亡对象的内存空间</p> 
<p>Mutator：业务线程，分配新对象，修改对象的指向关系</p> 
<p>Collector：GC线程，找到存活对象，回收死亡对象的内存空间</p> 
<p>Serial GC:只有一个GC</p> 
<p>ParallelGC：支持多个collectors同时回收GC的算法</p> 
<p>Concurrent GC：mutator和collector可以<strong>同时执行 </strong></p> 
<p><strong>注：Collectors必须感知对象指向关系的改变</strong></p> 
<p><img alt="" height="320" src="https://images2.imgbox.com/45/5c/FZxCdxEK_o.png" width="1200"></p> 
<p>评价GC算法：</p> 
<p>                安全性：不能回收存活对象 <strong>基本要求</strong></p> 
<p>                吞吐率：1-GC时间/程序运行总时间 <strong>花在GC上的时间</strong></p> 
<p>                暂停时间：STW 业务是否感知</p> 
<p>                内存开销：GC元数据开销</p> 
<h3>1.2追踪垃圾回收</h3> 
<p>对象被回收的条件：指针指向关系不可达的对象</p> 
<p class="img-center"><img alt="" height="657" src="https://images2.imgbox.com/a1/ef/Tefb1u6i_o.png" width="638"></p> 
<p>标记根对象（静态变量、全局变量、常量、线程栈等）</p> 
<p class="img-center"><img alt="" height="637" src="https://images2.imgbox.com/e0/02/TMkuUCLP_o.png" width="595"></p> 
<p>标记：可达对象</p> 
<p>求指针指向关系的传递闭包：从根对象出发，找到所有可达对象</p> 
<p class="img-center"><img alt="" height="636" src="https://images2.imgbox.com/43/4a/sVLKPj19_o.png" width="610"></p> 
<p>清理：所有不可达对象</p> 
<p>        将存活对象复制到另外的内存空间（Copying GC）</p> 
<p>        将死亡对象的内存标记为“可分配”（Mark-sweep GC）</p> 
<p>        移动并整理存活对象（Mark-compact GC）</p> 
<p><strong>根据对象的生命周期，使用不同的标记和清理策略</strong></p> 
<p class="img-center"><img alt="" height="635" src="https://images2.imgbox.com/b8/0d/bxC39q6o_o.png" width="623"></p> 
<h4>分代GC</h4> 
<p>跟<strong>Java JVM</strong> 类似</p> 
<p><a href="https://blog.csdn.net/qq_43351888/article/details/124716310?spm=1001.2014.3001.5501" title="Java 虚拟机（JVM）学习笔记_芙蓉铁蛋的博客-CSDN博客">Java 虚拟机（JVM）学习笔记_芙蓉铁蛋的博客-CSDN博客</a></p> 
<p>对年轻和老年代的对象，制定不同的GC策略，降低整体内存管理开销</p> 
<p>不同年龄的对象处于heap的不同区域</p> 
<p><strong>年轻代：</strong>常规的对象分配，由于存活对象很少可以采用copying collection GC吞吐率高</p> 
<p><strong>老年代：</strong>对象趋向于一直活着，反复复制开销较大，可以采用mark-sweep collection</p> 
<h3>1.3引用计数</h3> 
<p>每一个对象都有一个与之关联的引用数目</p> 
<p>对象存活条件：当且仅当引用数大于0</p> 
<p>优点：内存管理的操作被平摊到程序执行过程中</p> 
<p>           内存管理不需要了解runtime的实现细节：C++智能指针</p> 
<p>缺点：维护引用计数的开销较大：通过原子操作保证对引用计数操作的原子性和可见性</p> 
<p>           无法回收环形数据结构</p> 
<p>           内存开销：每个对象都引入了额外的内存空间存储引用数目</p> 
<p>           回收内存时依然可能引发暂停</p> 
<p>环形数据结构：</p> 
<p><img alt="" height="226" src="https://images2.imgbox.com/fb/e0/dADeZpND_o.png" width="710"></p> 
<h2>2.Go内存管理及优化</h2> 
<h3>2.1Go内存分配</h3> 
<h4>分块</h4> 
<p>目标：为对象在heap上分配内存</p> 
<p>提前将内存分块</p> 
<p>        调用系统调用mmap（）向OS申请一大块内存，例如4MB</p> 
<p>        先将内存划分为大块，例如8KB，成为mspan</p> 
<p>        再将大块继续分成<strong>特定大小</strong>的小块，用于对象分配</p> 
<p>        noscan mspan:分配不包含指针的对象—GC不需要扫描</p> 
<p>        scan mspan:分配包含指针的对象—GC需要扫描</p> 
<p>对象分配：根据对象的大小，选择最合适的快返回</p> 
<p><img alt="" height="238" src="https://images2.imgbox.com/42/cc/7NfYNfpR_o.png" width="598"></p> 
<h4>缓存</h4> 
<p>TCMalloc：thread caching</p> 
<p>每个p包含一个mcache用于快速分配，用于绑定p上的g分配对象</p> 
<p>mcache管理一组mspan</p> 
<p>当mcache中的mspan分配完毕，向mcentral申请带有未分配块的mspan</p> 
<p>当mspan中没有分配的对象，mspan会被缓存在mcentral中，而不是立刻释放归还给OS</p> 
<p><img alt="" height="627" src="https://images2.imgbox.com/91/60/omUHwbPx_o.png" width="784"></p> 
<h3>2.2内存管理优化</h3> 
<p>对象分配是非常高频的操作：每秒<strong>分配GB级别</strong>的内存</p> 
<p>小对象占比比较高</p> 
<p>Go内存分配比较耗时</p> 
<p>        分配路径长：g -&gt; m -&gt; p -&gt; mcache -&gt; mspan -&gt; memory block -&gt; return pointer</p> 
<p>        pprof：对象分配的函数时最频繁调用的函数之一</p> 
<h3>字节跳动优化方案（Balanced GC）：</h3> 
<p>每个g都绑定一大块内存（1KB），称做：goroutine allocation buffer（GAB）</p> 
<p>GAB用于noscan类型的小对象分配：&lt;128 B</p> 
<p>使用三个指针维护GAB：base,end,top</p> 
<p>Bump pointer（指针碰撞）风格对象分配</p> 
<p>        无需和其他分配请求互斥</p> 
<p>        分配动作简单高效</p> 
<p><img alt="" height="233" src="https://images2.imgbox.com/a2/07/8MtXMdRt_o.png" width="1200"></p> 
<p>GAB对于Go内存管理来说是一个大对象</p> 
<p>本质：将多个小对象的分配合并成一次大对象的分配</p> 
<p>问题：GAB的对象分配方式会导致内存被延迟释放</p> 
<p>从 Go runtime 内存管理模块的角度看，一个 allocation buffer 其实是一个大对象。本质上balanced GC 是<strong>将多次小对象的分配合并成一次大对象的分配</strong>。因此，当 GAB 中哪怕只有一个小对象存活时，Go runtime 也会认为整个大对象（即 GAB）存活。</p> 
<p>当GAB总大小超过一定阈值时，将GAB中存活的对象复制到另外分配的GAB中</p> 
<p>原来的GAB可以释放，避免内存泄漏</p> 
<p>本质：用copy GC 的算法管理小对象</p> 
<p>为此，balanced GC 会根据 GC 策略，<strong>将 GAB 中存活的对象移动到另外的 GAB 中</strong>，从而压缩并清理 GAB 的内存空间，原先的 GAB 空间由于不再有存活对象，可以全部释放，如下图所示。</p> 
<p><img alt="" height="316" src="https://images2.imgbox.com/62/dc/eheIFv98_o.png" width="930"></p> 
<p>上图上方是两个 GAB，其中虚线表示 GAB 中对象的分界线。黑色表示 GAB 中存活的对象，白色表示死掉的对象。由于 GAB 中有存活对象，整个 GAB 无法被回收。</p> 
<p>Balanced GC 会将 GAB 中存活的对象移动到下面的 GAB 中，这样原先的两个 GABs 就可以被释放，压缩并清理 GAB 的内存空间。</p> 
<p>Balanced GC 只负责 noscan 对象的分配和移动，对象的标记和回收依然依赖 Go GC 本身，并和 Go GC 保持兼容。</p> 
<h2>3.编译器和静态分析</h2> 
<h3>3.1编译器结构</h3> 
<p>他是一个重要的系统软件</p> 
<p>       <strong> 识别符合语法和非法的程序</strong></p> 
<p><strong>        生成正确且高效的代码</strong></p> 
<p><strong>分析部分（前端 front end）</strong></p> 
<p>        词法分析，生成语素</p> 
<p>        语法分析，生成语法树</p> 
<p>        语义分析，收集类型信息，进行语义检查</p> 
<p>        中间代码生成，生成intermediate representation (IR)</p> 
<p><strong> 综合部份（后端 back end）</strong></p> 
<p>        代码优化，机器无关优化，生成优化后的IR</p> 
<p>        代码生成，生成目标代码</p> 
<p><img alt="" height="653" src="https://images2.imgbox.com/19/1d/XFysiHi0_o.png" width="690"></p> 
<h3>3.2静态分析</h3> 
<p>静态分析：<strong>不执行代码</strong>，推导程序的行为，分析程序的性质</p> 
<p>控制流（Control flow)：程序执行的流程</p> 
<p>数据流（Data flow）：数据在控制流上的传递</p> 
<p>通过分析控制流和数据流，我们可以知道更多关于<strong>程序的性质</strong></p> 
<p>根据这些性质优化代码</p> 
<p class="img-center"><img alt="" height="284" src="https://images2.imgbox.com/bf/b8/Jm3Q937B_o.png" width="284"></p> 
<p class="img-center"><img alt="" height="500" src="https://images2.imgbox.com/7b/89/vUOR8dTo_o.png" width="461"></p> 
<p>数据流： </p> 
<p class="img-center"><img alt="" height="317" src="https://images2.imgbox.com/3d/95/yKlR0qI0_o.png" width="417"></p> 
<h3>3.3过程内分析和过程间分析</h3> 
<p>Intra-procedural analysis: 过程内分析：在函数内进行控制流和数据流的分析</p> 
<p>Inter-procedural analysis: 过程间分析：除了函数内的分析，还需要考虑跨函数的数据流和控制流，例如参数传递，函数返回值等</p> 
<p>为什么过程间分析是个问题？</p> 
<p>        需要通过<strong>数据流分析</strong>得知i的具体类型，才知道i.foo（）调用的是哪个foo（）</p> 
<p>        根据 i 的具体类型，产生了<strong>新的控制流</strong>，i.foo()，分析继续</p> 
<p>        过程间分析需要同时分析控制流和数据流—<strong>联合求解，比较复杂</strong></p> 
<p class="img-center"><img alt="" height="670" src="https://images2.imgbox.com/40/ba/sv5sz4C7_o.png" width="520"></p> 
<p></p> 
<h2>4.Go编译器优化</h2> 
<p><strong>目的</strong></p> 
<ul><li>用户无感知，重新编译即可获得性能收益</li></ul> 
<ul><li>通用的优化手段</li></ul> 
<p><strong>现状</strong></p> 
<ul><li>采用的优化较少</li></ul> 
<ul><li>追求编译时间短，因此没有进行复杂的代码分析和优化</li></ul> 
<p><strong>思路</strong></p> 
<ul><li>场景：面向后端长期执行的任务</li></ul> 
<ul><li>Tradeoff：用适当增加编译时间换取更高性能的代码</li></ul> 
<p><strong>字节跳动用适当的编译时间换取更高性能的机器码 </strong></p> 
<h3> 4.1函数内联（Inlining）</h3> 
<p>定义：将被调用函数的函数体的副本替换到调用位置上，同时重写代码以反映参数的绑定</p> 
<ul><li> <p><strong>优点</strong></p> 
  <ul><li>消除调用开销</li><li><strong>将过程间分析的问题转换为过程内分析</strong>，帮助其他分析</li></ul></li></ul> 
<ul><li> <p><strong>缺点</strong></p> 
  <ul><li>函数体变大</li><li>编译生成的 Go 镜像文件变大</li></ul></li></ul> 
<ul><li>函数内联在大多数情况下是正向优化，即多内联，会提升性能</li></ul> 
<ul><li> <p>采取一定的策略决定是否内联</p> 
  <ul><li>调用和被调用函数的规模</li></ul></li></ul> 
<h4>Beast Mode</h4> 
<ul><li> <p>Go 内联的限制</p> 
  <ul><li>语言特性：interface, defer 等等，限制了内联优化</li><li>内联策略非常保守</li></ul></li></ul> 
<ul><li> <p>字节跳动的优化方案</p> 
  <ul><li>修改了内联策略，让更多函数被内联</li><li>增加了其他优化的机会：<strong>逃逸分析</strong></li></ul></li></ul> 
<ul><li> <p>开销</p> 
  <ul><li>Go 镜像大小略有增加</li><li>编译时间增加</li><li>运行时栈扩展开销增加</li></ul></li></ul> 
<h3>4.2逃逸分析</h3> 
<ul><li>定义：分析代码中指针的动态作用域，即指针在何处可以被访问</li></ul> 
<ul><li> <p>大致思路</p> 
  <ul><li> <p>从对象分配处出发，沿着控制流，观察数据流。若发现指针 p 在当前作用域 s:</p> 
    <ul><li>作为参数传递给其他函数；</li><li>传递给全局变量；</li><li>传递给其他的 goroutine;</li><li>传递给已逃逸的指针指向的对象；</li></ul></li><li> <p>则指针 p 逃逸出 s，反之则没有逃逸出 s.</p> </li></ul></li></ul> 
<p>Beast mode :函数内联扩展了函数边界，更多对象不逃逸</p> 
<ul><li> <p><strong>优化：未逃逸出当前函数的指针指向的对象可以在栈上分配</strong></p> 
  <ul><li>对象在栈上分配和回收很快：移动 sp 即可完成内存的分配和回收；</li><li>减少在堆上分配对象，降低 GC 负担。</li></ul></li></ul> 
<h2>参考阅读：</h2> 
<p>The Garbage Collection Handbook -- the art of automatic memory management</p> 
<p>是自动内存管理领域的集大成之作。把自动内存管理的问题、动机、方案、以及最新研究进展和方向进行了非常详尽的阐述。整个书很好读，参考文献非常充实，推荐大家阅读英文版。</p> 
<p>JEP 333: ZGC: A Scalable Low-Latency Garbage Collector <a href="https://link.juejin.cn?target=https%3A%2F%2Fopenjdk.java.net%2Fjeps%2F333" rel="nofollow" title="openjdk.java.net/jeps/333">openjdk.java.net/jeps/333</a></p> 
<p>是目前 HotSpot JVM 上 pauseless GC 实现的 proposal，可以看作 GC 领域比较新的工程方面的进展。</p> 
<p>数据密集型应用系统设计 Designing Data-Intensive Applications: The Big Ideas Behind Reliable, Scalable, and Maintainable Systems</p> 
<p>通过例子带大家理解互联网产品需要解决的问题以及方案。</p> 
<p>编译原理 The Dragon book, Compilers: Principles, Techniques, and Tools</p> 
<p>在编译器前端着墨较多。本书第二版的第九章 机器无关优化，推荐大家反复仔细阅读。这一章主要讲述的是编译优化中常见的数据流分析问题，建议大家跟随书本仔细推导书中的例子，会帮助你对数据流分析有个大致的认识。这一章给出的引用文献大多是编译和静态分析领域非常有影响力的论文，有兴趣的同学可以阅读。</p> 
<p>编译原理 Principles and Techniques of Compilers <a href="https://link.juejin.cn?target=https%3A%2F%2Fsilverbullettt.bitbucket.io%2Fcourses%2Fcompiler-2022%2Findex.html" rel="nofollow" title="silverbullettt.bitbucket.io/courses/com…">silverbullettt.bitbucket.io/courses/com…</a></p> 
<p>南京大学编译原理课程。</p> 
<p>静态程序分析 Static Program Analysis <a href="https://link.juejin.cn?target=https%3A%2F%2Fpascal-group.bitbucket.io%2Fteaching.html" rel="nofollow" title="pascal-group.bitbucket.io/teaching.ht…">pascal-group.bitbucket.io/teaching.ht…</a></p> 
<p>南京大学静态程序分析课程。参考文献 4 数据流分析读不懂的地方可以参考本课程的课件。</p> 
<p>编译器设计 Engineering a Compiler</p> 
<p>在编译器后端优化着墨较多。可以帮助大家理解后端优化的问题。</p> 
<p>JVM Anatomy Quark #4: TLAB allocation <a href="https://link.juejin.cn?target=https%3A%2F%2Fshipilev.net%2Fjvm%2Fanatomy-quarks%2F4-tlab-allocation%2F" rel="nofollow" title="shipilev.net/jvm/anatomy…">shipilev.net/jvm/anatomy…</a></p> 
<p>Goroutine allocation buffer (GAB) 的优化思路在 HotSopt JVM 也能找到类似的实现。</p> 
<p>Constant folding, <a href="https://link.juejin.cn?target=https%3A%2F%2Fen.wikipedia.org%2Fwiki%2FConstant_folding" rel="nofollow" title="en.wikipedia.org/wiki/Consta…">en.wikipedia.org/wiki/Consta…</a></p> 
<p>常量折叠数据流分析。</p> 
<p>Choi, Jong-Deok, et al. "Escape analysis for Java." <em>Acm Sigplan</em> <em>Notices</em> 34.10 (1999): 1-19.</p> 
<p>逃逸分析的 Java 实现。</p> 
<p>Zhao, Wenyu, Stephen M. Blackburn, and Kathryn S. McKinley. "Low-Latency, High-Throughput Garbage Collection." (PLDI 2022). 学术界和工业界在一直在致力于解决自动内存管理技术的不足之处，感兴趣的同学可以阅读。</p> 
<p></p> 
<p></p> 
<p></p> 
<p></p> 
<p></p> 
<p></p> 
<p></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/f8bee8f7bb04e3ad9cec34b40a196bee/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">（三）k8s资源清单</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/bbfa4f9a02ab3a269fe5cc319e3fac25/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">缓存使用的几种方式以及优缺点</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>