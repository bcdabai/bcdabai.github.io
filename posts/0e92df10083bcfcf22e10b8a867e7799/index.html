<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>ES集群搭建及Kibana安装、操作 - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="ES集群搭建及Kibana安装、操作" />
<meta property="og:description" content="文章目录 1、搜索的介绍2、全文检索的介绍1、全文检索的需求介绍2、非结构化数据查找方法3、如何实现全文检索4、lucene实现全文检索流程5、全文检索框架介绍 3、ELK日志协议栈1、ELK协议栈基本介绍1、集中式日志系统2、ELK 协议栈介绍及体系结构3、Elk整体架构4、参考文档 4、Elasticsearch介绍1、什么是ElasticSearch2、ElasticSearch使用案例3、ElasticSearch对比Solr4、ElasticSearch架构图以及基本概念(术语)1、es概述2、ES架构模块3、Elasticsearch核心概念 5、es的集群部署第一步：创建普通用户第二步：为普通用户es添加sudo权限第三步：下载并上传压缩包，然后解压第四步：修改配置文件第五步：将安装包分发到其他服务器上面第六步：node02与node03修改es配置文件第七步：修改系统配置，解决启动时候的问题第八步：启动ES服务 6、node01服务器安装elasticsearch-head插件1 、node01机器安装nodejs第一步：下载安装包第二步：创建软连接第三步：修改环境变量第四步：验证安装成功 2 、node01机器安装elasticsearch-head插件1、第一种方式：在线安装elasticsearch-head插件（网速慢，不推荐）第一步：在线安装必须依赖包第二步：从git上面克隆编译包并进行安装第三步、node01机器修改Gruntfile.js 第四步、node01机器修改app.js2、第二种方式：直接使用提供的编译之后的源码包解压之后修改配置文件即可（强烈推荐）第一步：上传压缩包到/home/es路径下去第二步：解压安装包第三步、node01机器修改Gruntfile.js第四步、node01机器修改app.js 3、node01机器启动head服务4、访问elasticsearch-head界面 7、node01服务器安装Kibana第一步：下载资源上传服务器并解压第二步：修改配置文件第三步：启动服务第四步：浏览器访问 8、使用kibana管理索引1、使用 Xput创建索引1、创建索引2、插入文档3、查询文档4、更新文档5、搜索文档6、删除文档7、删除索引 2、返回值说明1、Hits2、took3、Shard4、timeout 3、花式查询1、使用match_all做查询2、通过关键字段进行查询3、bool的复合查询4、bool的复合查询中的should5、term匹配6、使用terms匹配多个值7、Range过滤8、exists和 missing过滤9、bool的多条件过滤10、查询与过滤条件合并 4、索引映射（mappings）管理1、为什么要映射2、基本命令3、获取映射字段 5、索引库配置管理（settings）1、 索引库配置2、 零停机重新索引数据 15、kibana报表展示第一步：下载数据集第二步：上传我们的数据集并解压第三步：创建对应的索引库第四步：加载示例数据到我们的索引库当中来第五步：实现数据的报表展示 1、搜索的介绍 搜索是指搜寻检索，指代使用一定手段来检索到我们自己需要的信息，包括从文件当中检索，百度当中检索，网站内部搜索等等
2、全文检索的介绍 1、全文检索的需求介绍 首先我们谈几个公司，如雷贯耳的：百度、谷歌、维基百科；这些公司都有一个相似性就是门户网站，可以提供我们通过关键字搜索，然后快速的检索出我们想要的信息；
【网页百度展示】
比如我们检索传智播客，百度后台就会按照这个关键字进行查找（里面有搜索库，以及爬虫库），然后按照权重来进行从上到下的排序，给我们高亮的展示出现
【京东或者淘宝展示】
随便搜索东西，就会高精度的展示我们想要的；就会根据关键词进行海量数据的快速的检索
比如我们查找：”护手霜“ ， 那么这期间内部会经过大体的：1、分词（护手，手霜，护等）2、根据这些词去海量的数据中检索 3、然后根据权重把检索出来的信息进行排序展示给我们
【传统做法】
那么对于一般的公司，初期是没有那么多数据的，所以很多公司更倾向于使用传统的数据库：mysql；比如我们要查找关键字”传智播客“，那么查询的方式大概就是:select * from table where field like ‘%传智播客%’; 但是随着业务发展，数据会不断的膨胀，那么问题就来了；mysql单表查询能力即便经过了优化，它的极限也就是400W左右的数据量。而且还会经常出现查询超时的现象；
然后很多公司开始对数据库进行横向和纵向的扩容，开始进行数据库表的“拆分”：横向拆分和纵向拆分；但是即便这样操作，仍然会出现很多问题，比如：
1、数据库会出现单点故障问题，于是先天主从复制关系，于是增加了运维成本
2、因为对表的拆分，增加了后期维护的难度，同样也是增加了运维成本
3、即便做了大量的维护，但对于大数据的检索操作，依然很慢，完全达不到期望值
于是出现了lucene，全文检索的工具。但是lucene对外暴露出的可用接口对于开发人员来说，操作是非常的复杂，而且没有效率的；于是在lucene的基础上进一步的封装，有了一个叫做solr的高性能分布式检索服务框架，但是，solr有一个致命的缺点就是：在建立索引期间，solr的搜索能力会极度下降，这就在一定程度上造成了solr在实时索引上效率并不高；
最后，出现了一个叫做elasticsearch的框架，同样是以lucene为基础，并且吸收了前两代的教训而开发出的分布式多用户能力的全文搜索引擎，并且elasticsearch是基于RESTful web接口进行发布的，那么这就意味着，我们开发人员操作起来更方便快捷；同时es拓展节点方便，可用于存储和检索海量数据，接近实时搜索能力，自动发现节点、副本机制保障可用性
2、非结构化数据查找方法 1：顺序扫描法(Serial Scanning)
所谓顺序扫描，比如要找内容包含某一个字符串的文件，就是一个文档一个文档的看，对于每一个文档，从头看到尾，如果此文档包含此字符串，则此文档为我们要找的文件，接着看下一个文件，直到扫描完所有的文件。如利用windows的搜索也可以搜索文件内容，只是相当的慢。
2：全文检索(Full-text Search)
将非结构化数据中的一部分信息提取出来，重新组织，使其变得有一定结构，然后对此有一定结构的数据进行搜索，从而达到搜索相对较快的目的。这部分从非结构化数据中提取出的然后重新组织的信息，我们称之索引。
例如：字典。字典的拼音表和部首检字表就相当于字典的索引，对每一个字的解释是非结构化的，如果字典没有音节表和部首检字表，在茫茫辞海中找一个字只能顺序扫描。然而字的某些信息可以提取出来进行结构化处理，比如读音，就比较结构化，分声母和韵母，分别只有几种可以一一列举，于是将读音拿出来按一定的顺序排列，每一项读音都指向此字的详细解释的页数。我们搜索时按结构化的拼音搜到读音，然后按其指向的页数，便可找到我们的非结构化数据——也即对字的解释。
这种先建立索引，再对索引进行搜索的过程就叫全文检索(Full-text Search)。
虽然创建索引的过程也是非常耗时的，但是索引一旦创建就可以多次使用，全文检索主要处理的是查询，所以耗时间创建索引是值得的。
3、如何实现全文检索 可以使用Lucene实现全文检索。Lucene是apache下的一个开放源代码的全文检索引擎工具包（提供了Jar包，实现全文检索的类库）。它提供了完整的查询引擎和索引引擎，部分文本分析引擎。Lucene的目的是为软件开发人员提供一个简单易用的工具包，以方便地在目标系统中实现全文检索的功能。
注意：Lucene只是一个引擎，只是一个工具包，如果使用Lucene开发全文检索功能，要记住Lucene是不能单独运行的。
4、lucene实现全文检索流程 绿色表示索引过程，对要搜索的原始内容进行索引构建一个索引库，索引过程包括：确定原始内容即要搜索的内容→采集文档→创建文档→分析文档→索引文档。红色表示搜索过程，从索引库中搜索内容，搜索过程包括：用户通过搜索界面→创建查询→执行搜索，从索引库搜索→渲染搜索结果。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/0e92df10083bcfcf22e10b8a867e7799/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2019-09-14T16:59:51+08:00" />
<meta property="article:modified_time" content="2019-09-14T16:59:51+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">ES集群搭建及Kibana安装、操作</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-tomorrow-night">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p></p> 
<div class="toc"> 
 <h4>文章目录</h4> 
 <ul><li><a href="#1_1" rel="nofollow">1、搜索的介绍</a></li><li><a href="#2_3" rel="nofollow">2、全文检索的介绍</a></li><li><ul><li><ul><li><a href="#1_4" rel="nofollow">1、全文检索的需求介绍</a></li><li><a href="#2_20" rel="nofollow">2、非结构化数据查找方法</a></li><li><a href="#3_28" rel="nofollow">3、如何实现全文检索</a></li><li><a href="#4lucene_32" rel="nofollow">4、lucene实现全文检索流程</a></li><li><a href="#5_49" rel="nofollow">5、全文检索框架介绍</a></li></ul> 
  </li></ul> 
  </li><li><a href="#3ELK_52" rel="nofollow">3、ELK日志协议栈</a></li><li><ul><li><ul><li><a href="#1ELK_53" rel="nofollow">1、ELK协议栈基本介绍</a></li><li><ul><li><a href="#1_54" rel="nofollow">1、集中式日志系统</a></li><li><a href="#2ELK__63" rel="nofollow">2、ELK 协议栈介绍及体系结构</a></li><li><a href="#3Elk_87" rel="nofollow">3、Elk整体架构</a></li><li><a href="#4_90" rel="nofollow">4、参考文档</a></li></ul> 
   </li></ul> 
  </li></ul> 
  </li><li><a href="#4Elasticsearch_96" rel="nofollow">4、Elasticsearch介绍</a></li><li><ul><li><ul><li><a href="#1ElasticSearch_98" rel="nofollow">1、什么是ElasticSearch</a></li><li><a href="#2ElasticSearch_100" rel="nofollow">2、ElasticSearch使用案例</a></li><li><a href="#3ElasticSearchSolr_107" rel="nofollow">3、ElasticSearch对比Solr</a></li><li><a href="#4ElasticSearch_112" rel="nofollow">4、ElasticSearch架构图以及基本概念(术语)</a></li><li><ul><li><a href="#1es_113" rel="nofollow">1、es概述</a></li><li><a href="#2ES_118" rel="nofollow">2、ES架构模块</a></li><li><a href="#3Elasticsearch_129" rel="nofollow">3、Elasticsearch核心概念</a></li></ul> 
   </li></ul> 
  </li></ul> 
  </li><li><a href="#5es_156" rel="nofollow">5、es的集群部署</a></li><li><ul><li><ul><li><a href="#_157" rel="nofollow">第一步：创建普通用户</a></li><li><a href="#essudo_167" rel="nofollow">第二步：为普通用户es添加sudo权限</a></li><li><a href="#_174" rel="nofollow">第三步：下载并上传压缩包，然后解压</a></li><li><a href="#_183" rel="nofollow">第四步：修改配置文件</a></li><li><a href="#_214" rel="nofollow">第五步：将安装包分发到其他服务器上面</a></li><li><a href="#node02node03es_221" rel="nofollow">第六步：node02与node03修改es配置文件</a></li><li><a href="#_255" rel="nofollow">第七步：修改系统配置，解决启动时候的问题</a></li><li><a href="#ES_302" rel="nofollow">第八步：启动ES服务</a></li></ul> 
  </li></ul> 
  </li><li><a href="#6node01elasticsearchhead_317" rel="nofollow">6、node01服务器安装elasticsearch-head插件</a></li><li><ul><li><a href="#1_node01nodejs_319" rel="nofollow">1 、node01机器安装nodejs</a></li><li><ul><li><a href="#_323" rel="nofollow">第一步：下载安装包</a></li><li><a href="#_330" rel="nofollow">第二步：创建软连接</a></li><li><a href="#_336" rel="nofollow">第三步：修改环境变量</a></li><li><a href="#_347" rel="nofollow">第四步：验证安装成功</a></li></ul> 
   </li><li><a href="#2_node01elasticsearchhead_353" rel="nofollow">2 、node01机器安装elasticsearch-head插件</a></li><li><ul><li><a href="#1elasticsearchhead_357" rel="nofollow">1、第一种方式：在线安装elasticsearch-head插件（网速慢，不推荐）</a></li><li><ul><li><a href="#_359" rel="nofollow">第一步：在线安装必须依赖包</a></li><li><a href="#git_366" rel="nofollow">第二步：从git上面克隆编译包并进行安装</a></li><li><a href="#node01Gruntfilejs_389" rel="nofollow">第三步、node01机器修改Gruntfile.js</a></li></ul> 
    </li><li><a href="#node01appjs_410" rel="nofollow">第四步、node01机器修改app.js</a></li><li><a href="#2_419" rel="nofollow">2、第二种方式：直接使用提供的编译之后的源码包解压之后修改配置文件即可（强烈推荐）</a></li><li><ul><li><a href="#homees_420" rel="nofollow">第一步：上传压缩包到/home/es路径下去</a></li><li><a href="#_422" rel="nofollow">第二步：解压安装包</a></li><li><a href="#node01Gruntfilejs_428" rel="nofollow">第三步、node01机器修改Gruntfile.js</a></li><li><a href="#node01appjs_448" rel="nofollow">第四步、node01机器修改app.js</a></li></ul> 
    </li><li><a href="#3node01head_456" rel="nofollow">3、node01机器启动head服务</a></li><li><a href="#4elasticsearchhead_478" rel="nofollow">4、访问elasticsearch-head界面</a></li></ul> 
  </li></ul> 
  </li><li><a href="#7node01Kibana_481" rel="nofollow">7、node01服务器安装Kibana</a></li><li><ul><li><a href="#_488" rel="nofollow">第一步：下载资源上传服务器并解压</a></li><li><a href="#_498" rel="nofollow">第二步：修改配置文件</a></li><li><a href="#_509" rel="nofollow">第三步：启动服务</a></li><li><a href="#_520" rel="nofollow">第四步：浏览器访问</a></li></ul> 
  </li><li><a href="#8kibana_523" rel="nofollow">8、使用kibana管理索引</a></li><li><ul><li><a href="#1_Xput_531" rel="nofollow">1、使用 Xput创建索引</a></li><li><ul><li><a href="#1_532" rel="nofollow">1、创建索引</a></li><li><a href="#2_537" rel="nofollow">2、插入文档</a></li><li><a href="#3_551" rel="nofollow">3、查询文档</a></li><li><a href="#4_561" rel="nofollow">4、更新文档</a></li><li><a href="#5_570" rel="nofollow">5、搜索文档</a></li><li><a href="#6_579" rel="nofollow">6、删除文档</a></li><li><a href="#7_583" rel="nofollow">7、删除索引</a></li></ul> 
   </li><li><a href="#2_587" rel="nofollow">2、返回值说明</a></li><li><ul><li><a href="#1Hits_588" rel="nofollow">1、Hits</a></li><li><a href="#2took_593" rel="nofollow">2、took</a></li><li><a href="#3Shard_595" rel="nofollow">3、Shard</a></li><li><a href="#4timeout_598" rel="nofollow">4、timeout</a></li></ul> 
   </li><li><a href="#3_602" rel="nofollow">3、花式查询</a></li><li><ul><li><a href="#1match_all_625" rel="nofollow">1、使用match_all做查询</a></li><li><a href="#2_635" rel="nofollow">2、通过关键字段进行查询</a></li><li><a href="#3bool_648" rel="nofollow">3、bool的复合查询</a></li><li><a href="#4boolshould_662" rel="nofollow">4、bool的复合查询中的should</a></li><li><a href="#5term_677" rel="nofollow">5、term匹配</a></li><li><a href="#6terms_698" rel="nofollow">6、使用terms匹配多个值</a></li><li><a href="#7Range_712" rel="nofollow">7、Range过滤</a></li><li><a href="#8exists_missing_726" rel="nofollow">8、exists和 missing过滤</a></li><li><a href="#9bool_740" rel="nofollow">9、bool的多条件过滤</a></li><li><a href="#10_768" rel="nofollow">10、查询与过滤条件合并</a></li></ul> 
  </li></ul> 
  </li><li><a href="#4mappings_784" rel="nofollow">4、索引映射（mappings）管理</a></li><li><ul><li><a href="#1_785" rel="nofollow">1、为什么要映射</a></li><li><a href="#2_835" rel="nofollow">2、基本命令</a></li><li><a href="#3_861" rel="nofollow">3、获取映射字段</a></li></ul> 
  </li><li><a href="#5settings_868" rel="nofollow">5、索引库配置管理（settings）</a></li><li><ul><li><a href="#1__869" rel="nofollow">1、 索引库配置</a></li><li><a href="#2__906" rel="nofollow">2、 零停机重新索引数据</a></li></ul> 
  </li><li><a href="#15kibana_982" rel="nofollow">15、kibana报表展示</a></li><li><ul><li><a href="#_987" rel="nofollow">第一步：下载数据集</a></li><li><a href="#_992" rel="nofollow">第二步：上传我们的数据集并解压</a></li><li><a href="#_996" rel="nofollow">第三步：创建对应的索引库</a></li><li><a href="#_1051" rel="nofollow">第四步：加载示例数据到我们的索引库当中来</a></li><li><a href="#_1060" rel="nofollow">第五步：实现数据的报表展示</a></li></ul> 
 </li></ul> 
</div> 
<p></p> 
<h2><a id="1_1"></a>1、搜索的介绍</h2> 
<p>搜索是指搜寻检索，指代使用一定手段来检索到我们自己需要的信息，包括从文件当中检索，百度当中检索，网站内部搜索等等</p> 
<h2><a id="2_3"></a>2、全文检索的介绍</h2> 
<h4><a id="1_4"></a>1、全文检索的需求介绍</h4> 
<p>首先我们谈几个公司，如雷贯耳的：百度、谷歌、维基百科；这些公司都有一个相似性就是门户网站，可以提供我们通过关键字搜索，然后快速的检索出我们想要的信息；<br> 【网页百度展示】<br> 比如我们检索传智播客，百度后台就会按照这个关键字进行查找（里面有搜索库，以及爬虫库），然后按照权重来进行从上到下的排序，给我们高亮的展示出现<br> 【京东或者淘宝展示】<br> 随便搜索东西，就会高精度的展示我们想要的；就会根据关键词进行海量数据的快速的检索<br> 比如我们查找：”护手霜“ ， 那么这期间内部会经过大体的：1、分词（护手，手霜，护等）2、根据这些词去海量的数据中检索 3、然后根据权重把检索出来的信息进行排序展示给我们<br> 【传统做法】<br> 那么对于一般的公司，初期是没有那么多数据的，所以很多公司更倾向于使用传统的数据库：mysql；比如我们要查找关键字”传智播客“，那么查询的方式大概就是:select * from table where field like ‘%传智播客%’; 但是随着业务发展，数据会不断的膨胀，那么问题就来了；mysql单表查询能力即便经过了优化，它的极限也就是400W左右的数据量。而且还会经常出现查询超时的现象；<br> 然后很多公司开始对数据库进行横向和纵向的扩容，开始进行数据库表的“拆分”：横向拆分和纵向拆分；但是即便这样操作，仍然会出现很多问题，比如：<br> 1、数据库会出现单点故障问题，于是先天主从复制关系，于是增加了运维成本<br> 2、因为对表的拆分，增加了后期维护的难度，同样也是增加了运维成本<br> 3、即便做了大量的维护，但对于大数据的检索操作，依然很慢，完全达不到期望值<br> 于是出现了lucene，全文检索的工具。但是lucene对外暴露出的可用接口对于开发人员来说，操作是非常的复杂，而且没有效率的；于是在lucene的基础上进一步的封装，有了一个叫做solr的高性能分布式检索服务框架，但是，solr有一个致命的缺点就是：在建立索引期间，solr的搜索能力会极度下降，这就在一定程度上造成了solr在实时索引上效率并不高；<br> 最后，出现了一个叫做elasticsearch的框架，同样是以lucene为基础，并且吸收了前两代的教训而开发出的分布式多用户能力的全文搜索引擎，并且elasticsearch是基于RESTful web接口进行发布的，那么这就意味着，我们开发人员操作起来更方便快捷；同时es拓展节点方便，可用于存储和检索海量数据，接近实时搜索能力，自动发现节点、副本机制保障可用性</p> 
<h4><a id="2_20"></a>2、非结构化数据查找方法</h4> 
<p>1：顺序扫描法(Serial Scanning)<br> 所谓顺序扫描，比如要找内容包含某一个字符串的文件，就是一个文档一个文档的看，对于每一个文档，从头看到尾，如果此文档包含此字符串，则此文档为我们要找的文件，接着看下一个文件，直到扫描完所有的文件。如利用windows的搜索也可以搜索文件内容，只是相当的慢。<br> 2：全文检索(Full-text Search)<br> 将非结构化数据中的一部分信息提取出来，重新组织，使其变得有一定结构，然后对此有一定结构的数据进行搜索，从而达到搜索相对较快的目的。这部分从非结构化数据中提取出的然后重新组织的信息，我们称之索引。<br> 例如：字典。字典的拼音表和部首检字表就相当于字典的索引，对每一个字的解释是非结构化的，如果字典没有音节表和部首检字表，在茫茫辞海中找一个字只能顺序扫描。然而字的某些信息可以提取出来进行结构化处理，比如读音，就比较结构化，分声母和韵母，分别只有几种可以一一列举，于是将读音拿出来按一定的顺序排列，每一项读音都指向此字的详细解释的页数。我们搜索时按结构化的拼音搜到读音，然后按其指向的页数，便可找到我们的非结构化数据——也即对字的解释。<br> 这种先建立索引，再对索引进行搜索的过程就叫全文检索(Full-text Search)。<br> 虽然创建索引的过程也是非常耗时的，但是索引一旦创建就可以多次使用，全文检索主要处理的是查询，所以耗时间创建索引是值得的。</p> 
<h4><a id="3_28"></a>3、如何实现全文检索</h4> 
<p>可以使用Lucene实现全文检索。Lucene是apache下的一个开放源代码的全文检索引擎工具包（提供了Jar包，实现全文检索的类库）。它提供了完整的查询引擎和索引引擎，部分文本分析引擎。Lucene的目的是为软件开发人员提供一个简单易用的工具包，以方便地在目标系统中实现全文检索的功能。<br> 注意：Lucene只是一个引擎，只是一个工具包，如果使用Lucene开发全文检索功能，要记住Lucene是不能单独运行的。</p> 
<h4><a id="4lucene_32"></a>4、lucene实现全文检索流程</h4> 
<ol><li>绿色表示索引过程，对要搜索的原始内容进行索引构建一个索引库，索引过程包括：确定原始内容即要搜索的内容→采集文档→创建文档→分析文档→索引文档。</li><li>红色表示搜索过程，从索引库中搜索内容，搜索过程包括：用户通过搜索界面→创建查询→执行搜索，从索引库搜索→渲染搜索结果。<br> 从上面了解到的知识点也可看出，索引和搜索流程图也可表示为：</li></ol> 
<p>总结：全文检索过程分为索引、搜索两个过程：</p> 
<ul><li>索引<br> 1.从关系数据库中、互联网上、文件系统采集源数据(要搜索的目标信息)，源数据的来源是很广泛的。<br> 2.将源数据采集到一个统一的地方，要创建索引，将索引创建到一个索引库（文件系统）中，从源数据库中提取关键信息，从关键信息中抽取一个一个词，词和源数据是有关联的。也即创建索引时，词和源数据有关联，索引库中记录了这个关联，如果找到了词就说明找到了源数据（http的网页、pdf电子书等……）。</li><li>搜索<br> 1.用户执行搜索（全文检索）编写查询关键字。<br> 2.从索引库中搜索索引，根据查询关键字搜索索引库中的一个一个词。<br> 3.展示搜索的结果。</li></ul> 
<h4><a id="5_49"></a>5、全文检索框架介绍</h4> 
<p>市面上全文检索的框架很多，较早期的一个框架就是lucene，基本上所有的全文检索的工作都交给lucene来实现，但是lucene最大的弊端就是API太原生，没有经过任何封装，不太好使用。所以后来出现一个叫做solr的框架，它也是基于lucene进行改造封装和包装，将服务端单独提取出来，客户端进行请求即可。<br> 另外一个框架就是大名鼎鼎的elasticsearch了，es也是一个基于lucene打造的全文检索的框架，且一经推出就迅速被市场认可，市场占有率越来越多，现在首选的全文检索的框架基本就是ES了。</p> 
<h2><a id="3ELK_52"></a>3、ELK日志协议栈</h2> 
<h4><a id="1ELK_53"></a>1、ELK协议栈基本介绍</h4> 
<h5><a id="1_54"></a>1、集中式日志系统</h5> 
<p>日志，对于任何系统来说都是及其重要的组成部分。在计算机系统里面，更是如此。但是由于现在的计算机系统大多比较复杂，很多系统都不是在一个地方，甚至都是跨国界的；即使是在一个地方的系统，也有不同的来源，比如，操作系统，应用服务，业务逻辑等等。他们都在不停产生各种各样的日志数据。根据不完全统计，我们全球每天大约要产生 2EB的数据。<br> 面对如此海量的数据，又是分布在各个不同地方，如果我们需要去查找一些重要的信息，难道还是使用传统的方法，去登陆到一台台机器上查看？看来传统的工具和方法已经显得非常笨拙和低效了。于是，一些聪明人就提出了建立一套集中式的方法，把不同来源的数据集中整合到一个地方。<br> 一个完整的集中式日志系统，是离不开以下几个主要特点的。<br> •收集－能够采集多种来源的日志数据<br> •传输－能够稳定的把日志数据传输到中央系统<br> •存储－如何存储日志数据<br> •分析－可以支持 UI 分析<br> •警告－能够提供错误报告，监控机制</p> 
<h5><a id="2ELK__63"></a>2、ELK 协议栈介绍及体系结构</h5> 
<p>ELK 其实并不是一款软件，而是一整套解决方案，是三个软件产品的首字母缩写，Elasticsearch，Logstash 和 Kibana。这三款软件都是开源软件，通常是配合使用，而且又先后归于 Elastic.co 公司名下，故被简称为 ELK 协议栈。<br> •Elasticsearch<br> Elasticsearch 是一个实时的分布式搜索和分析引擎，它可以用于全文搜索，结构化搜索以及分析。它是一个建立在全文搜索引擎 Apache Lucene 基础上的搜索引擎，使用 Java 语言编写。<br> 主要特点<br> –实时分析<br> –分布式实时文件存储，并将每一个字段都编入索引<br> –文档导向，所有的对象全部是文档<br> –高可用性，易扩展，支持集群（Cluster）、分片和复制（Shards 和 Replicas）。见图 2 和图 3<br> –接口友好，支持 JSON<br> •Logstash<br> Logstash 是一个具有实时渠道能力的数据收集引擎。使用 JRuby 语言编写。其作者是世界著名的运维工程师乔丹西塞 (JordanSissel)。<br> 主要特点<br> –几乎可以访问任何数据<br> –可以和多种外部应用结合<br> –支持弹性扩展<br> 它由三个主要部分组成<br> –Shipper－发送日志数据<br> –Broker－收集数据，缺省内置 Redis<br> –Indexer－数据写入<br> •Kibana<br> Kibana 是一款基于 Apache 开源协议，使用 JavaScript 语言编写，为 Elasticsearch 提供分析和可视化的 Web 平台。它可以在 Elasticsearch 的索引中查找，交互数据，并生成各种维度的表图。</p> 
<h5><a id="3Elk_87"></a>3、Elk整体架构</h5> 
<h5><a id="4_90"></a>4、参考文档</h5> 
<p>ELK官网：https://www.elastic.co/<br> ELK官网文档：https://www.elastic.co/guide/index.html<br> ELK中文手册：https://www.elastic.co/guide/cn/elasticsearch/guide/current/index.html<br> ELK中文社区：https://elasticsearch.cn/</p> 
<h2><a id="4Elasticsearch_96"></a>4、Elasticsearch介绍</h2> 
<h4><a id="1ElasticSearch_98"></a>1、什么是ElasticSearch</h4> 
<p>Elaticsearch，简称为es， es是一个开源的高扩展的分布式全文检索引擎，它可以近乎实时的存储、检索数据；本身扩展性很好，可以扩展到上百台服务器，处理PB级别的数据。es也使用Java开发并使用Lucene作为其核心来实现所有索引和搜索的功能，但是它的目的是通过简单的RESTful API来隐藏Lucene的复杂性，从而让全文搜索变得简单。</p> 
<h4><a id="2ElasticSearch_100"></a>2、ElasticSearch使用案例</h4> 
<p>•2013年初，GitHub抛弃了Solr，采取ElasticSearch 来做PB级的搜索。 “GitHub使用ElasticSearch搜索20TB的数据，包括13亿文件和1300亿行代码”<br> •维基百科：启动以elasticsearch为基础的核心搜索架构<br> •SoundCloud：“SoundCloud使用ElasticSearch为1.8亿用户提供即时而精准的音乐搜索服务”<br> •百度：百度目前广泛使用ElasticSearch作为文本数据分析，采集百度所有服务器上的各类指标数据及用户自定义数据，通过对各种数据进行多维分析展示，辅助定位分析实例异常或业务层面异常。目前覆盖百度内部20多个业务线（包括casio、云分析、网盟、预测、文库、直达号、钱包、风控等），单集群最大100台机器，200个ES节点，每天导入30TB+数据<br> •新浪使用ES 分析处理32亿条实时日志<br> •阿里使用ES 构建挖财自己的日志采集和分析体系</p> 
<h4><a id="3ElasticSearchSolr_107"></a>3、ElasticSearch对比Solr</h4> 
<p>•Solr 利用 Zookeeper 进行分布式管理，而 Elasticsearch 自身带有分布式协调管理功能;<br> •Solr 支持更多格式的数据，而 Elasticsearch 仅支持json文件格式；<br> •Solr 官方提供的功能更多，而 Elasticsearch 本身更注重于核心功能，高级功能多有第三方插件提供；<br> •Solr 在传统的搜索应用中表现好于 Elasticsearch，但在处理实时搜索应用时效率明显低于 Elasticsearch</p> 
<h4><a id="4ElasticSearch_112"></a>4、ElasticSearch架构图以及基本概念(术语)</h4> 
<h5><a id="1es_113"></a>1、es概述</h5> 
<p>Elasticsearch是面向文档(document oriented)的，这意味着它可以存储整个对象或文档(document)。然而它不仅仅是存储，还会索引(index)每个文档的内容使之可以被搜索。在Elasticsearch中，你可以对文档（而非成行成列的数据）进行索引、搜索、排序、过滤。<br> Elasticsearch比传统关系型数据库如下：<br> Relational DB -&gt; Databases -&gt; Tables -&gt; Rows -&gt; Columns<br> Elasticsearch -&gt; Indices -&gt; Types -&gt; Documents -&gt; Fields</p> 
<h5><a id="2ES_118"></a>2、ES架构模块</h5> 
<p>Gateway是ES用来存储索引的文件系统，支持多种类型。<br> Gateway的上层是一个分布式的lucene框架。<br> Lucene之上是ES的模块，包括：索引模块、搜索模块、映射解析模块等<br> ES模块之上是 Discovery、Scripting和第三方插件。<br> Discovery是ES的节点发现模块，不同机器上的ES节点要组成集群需要进行消息通信，集群内部需要选举master节点，这些工作都是由Discovery模块完成。支持多种发现机制，如 Zen 、EC2、gce、Azure。<br> Scripting用来支持在查询语句中插入javascript、python等脚本语言，scripting模块负责解析这些脚本，使用脚本语句性能稍低。ES也支持多种第三方插件。<br> 再上层是ES的传输模块和JMX.传输模块支持多种传输协议，如 Thrift、memecached、http，默认使用http。JMX是java的管理框架，用来管理ES应用。<br> 最上层是ES提供给用户的接口，可以通过RESTful接口和ES集群进行交互。</p> 
<h5><a id="3Elasticsearch_129"></a>3、Elasticsearch核心概念</h5> 
<p>1、索引 index<br> 一个索引就是一个拥有几分相似特征的文档的集合。比如说，你可以有一个客户数据的索引，另一个产品目录的索引，还有一个订单数据的索引。一个索引由一个名字来标识（必须全部是小写字母的），并且当我们要对对应于这个索引中的文档进行索引、搜索、更新和删除的时候，都要使用到这个名字。在一个集群中，可以定义任意多的索引。<br> 2、类型 type<br> 在一个索引中，你可以定义一种或多种类型。一个类型是你的索引的一个逻辑上的分类/分区，其语义完全由你来定。通常，会为具有一组共同字段的文档定义一个类型。比如说，我们假设你运营一个博客平台并且将你所有的数据存储到一个索引中。在这个索引中，你可以为用户数据定义一个类型，为博客数据定义另一个类型，当然，也可以为评论数据定义另一个类型。<br> 3、字段Field<br> 相当于是数据表的字段，对文档数据根据不同属性进行的分类标识<br> 4、映射 mapping<br> mapping是处理数据的方式和规则方面做一些限制，如某个字段的数据类型、默认值、分析器、是否被索引等等，这些都是映射里面可以设置的，其它就是处理es里面数据的一些使用规则设置也叫做映射，按着最优规则处理数据对性能提高很大，因此才需要建立映射，并且需要思考如何建立映射才能对性能更好。<br> 5、文档 document<br> 一个文档是一个可被索引的基础信息单元。比如，你可以拥有某一个客户的文档，某一个产品的一个文档，当然，也可以拥有某个订单的一个文档。文档以JSON（Javascript Object Notation）格式来表示，而JSON是一个到处存在的互联网数据交互格式。<br> 在一个index/type里面，你可以存储任意多的文档。注意，尽管一个文档，物理上存在于一个索引之中，文档必须被索引/赋予一个索引的type。<br> 6、集群 cluster<br> 一个集群就是由一个或多个节点组织在一起，它们共同持有整个的数据，并一起提供索引和搜索功能。一个集群由一个唯一的名字标识，这个名字默认就是“elasticsearch”。这个名字是重要的，因为一个节点只能通过指定某个集群的名字，来加入这个集群<br> 7、节点 node<br> 一个节点是集群中的一个服务器，作为集群的一部分，它存储数据，参与集群的索引和搜索功能。和集群类似，一个节点也是由一个名字来标识的，默认情况下，这个名字是一个随机的漫威漫画角色的名字，这个名字会在启动的时候赋予节点。这个名字对于管理工作来说挺重要的，因为在这个管理过程中，你会去确定网络中的哪些服务器对应于Elasticsearch集群中的哪些节点。<br> 一个节点可以通过配置集群名称的方式来加入一个指定的集群。默认情况下，每个节点都会被安排加入到一个叫做“elasticsearch”的集群中，这意味着，如果你在你的网络中启动了若干个节点，并假定它们能够相互发现彼此，它们将会自动地形成并加入到一个叫做“elasticsearch”的集群中。<br> 在一个集群里，只要你想，可以拥有任意多个节点。而且，如果当前你的网络中没有运行任何Elasticsearch节点，这时启动一个节点，会默认创建并加入一个叫做“elasticsearch”的集群。<br> 8、分片和复制 shards&amp;replicas<br> 一个索引可以存储超出单个结点硬件限制的大量数据。比如，一个具有10亿文档的索引占据1TB的磁盘空间，而任一节点都没有这样大的磁盘空间；或者单个节点处理搜索请求，响应太慢。为了解决这个问题，Elasticsearch提供了将索引划分成多份的能力，这些份就叫做分片。当你创建一个索引的时候，你可以指定你想要的分片的数量。每个分片本身也是一个功能完善并且独立的“索引”，这个“索引”可以被放置到集群中的任何节点上。分片很重要，主要有两方面的原因： 1）允许你水平分割/扩展你的内容容量。 2）允许你在分片（潜在地，位于多个节点上）之上进行分布式的、并行的操作，进而提高性能/吞吐量。<br> 至于一个分片怎样分布，它的文档怎样聚合回搜索请求，是完全由Elasticsearch管理的，对于作为用户的你来说，这些都是透明的。<br> 在一个网络/云的环境里，失败随时都可能发生，在某个分片/节点不知怎么的就处于离线状态，或者由于任何原因消失了，这种情况下，有一个故障转移机制是非常有用并且是强烈推荐的。为此目的，Elasticsearch允许你创建分片的一份或多份拷贝，这些拷贝叫做复制分片，或者直接叫复制。<br> 复制之所以重要，有两个主要原因： 在分片/节点失败的情况下，提供了高可用性。因为这个原因，注意到复制分片从不与原/主要（original/primary）分片置于同一节点上是非常重要的。扩展你的搜索量/吞吐量，因为搜索可以在所有的复制上并行运行。总之，每个索引可以被分成多个分片。一个索引也可以被复制0次（意思是没有复制）或多次。一旦复制了，每个索引就有了主分片（作为复制源的原来的分片）和复制分片（主分片的拷贝）之别。分片和复制的数量可以在索引创建的时候指定。在索引创建之后，你可以在任何时候动态地改变复制的数量，但是你事后不能改变分片的数量。<br> 默认情况下，Elasticsearch中的每个索引被分片5个主分片和1个复制，这意味着，如果你的集群中至少有两个节点，你的索引将会有5个主分片和另外5个复制分片（1个完全拷贝），这样的话每个索引总共就有10个分片。</p> 
<h2><a id="5es_156"></a>5、es的集群部署</h2> 
<h4><a id="_157"></a>第一步：创建普通用户</h4> 
<p>注意：ES不能使用root用户来启动，必须使用普通用户来安装启动。这里我们创建一个普通用户以及定义一些常规目录用于存放我们的数据文件以及安装包等<br> 创建一个es专门的用户（必须）<br> #使用root用户在三台机器执行以下命令</p> 
<pre><code class="prism language-shell"><span class="token function">useradd</span> es 
<span class="token function">mkdir</span> -p /export/servers/es
<span class="token function">chown</span> -R es /export/servers/es
<span class="token function">passwd</span> es
</code></pre> 
<h4><a id="essudo_167"></a>第二步：为普通用户es添加sudo权限</h4> 
<p>为了让普通用户有更大的操作权限，我们一般都会给普通用户设置sudo权限，方便普通用户的操作<br> 三台机器使用root用户执行visudo命令然后为es用户添加权限</p> 
<pre><code class="prism language-shell">visudo
es      ALL<span class="token operator">=</span><span class="token punctuation">(</span>ALL<span class="token punctuation">)</span>       ALL
</code></pre> 
<h4><a id="_174"></a>第三步：下载并上传压缩包，然后解压</h4> 
<p>将es的安装包下载并上传到node01服务器的/home/es路径下，然后进行解压<br> 使用es用户来执行以下操作（断开连接linux的工具，然后重新使用es用户连接上三台linux服务器）<br> node01服务器使用es用户执行以下命令</p> 
<pre><code class="prism language-shell"><span class="token function">cd</span> /home/es/
<span class="token function">wget</span> https://artifacts.elastic.co/downloads/elasticsearch/elasticsearch-6.7.0.tar.gz
<span class="token function">tar</span> -zxf elasticsearch-6.7.0.tar.gz -C /export/servers/es/
</code></pre> 
<h4><a id="_183"></a>第四步：修改配置文件</h4> 
<p>修改elasticsearch.yml<br> node01服务器使用es用户来修改配置文件</p> 
<pre><code class="prism language-shell"><span class="token function">cd</span> /export/servers/es/elasticsearch-6.7.0/config
<span class="token function">mkdir</span> -p /export/servers/es/elasticsearch-6.7.0/logs
<span class="token function">mkdir</span> -p /export/servers/es/elasticsearch-6.7.0/datas
<span class="token function">rm</span> -rf elasticsearch.yml
vim elasticsearch.yml

cluster.name: myes
node.name: node01
path.data: /export/servers/es/elasticsearch-6.7.0/datas
path.logs: /export/servers/es/elasticsearch-6.7.0/logs
network.host: 192.168.52.100
http.port: 9200
discovery.zen.ping.unicast.hosts: <span class="token punctuation">[</span><span class="token string">"node01"</span>, <span class="token string">"node02"</span>, <span class="token string">"node03"</span><span class="token punctuation">]</span>
bootstrap.system_call_filter: <span class="token boolean">false</span>
bootstrap.memory_lock: <span class="token boolean">false</span>
http.cors.enabled: <span class="token boolean">true</span>
http.cors.allow-origin: <span class="token string">"*"</span>
</code></pre> 
<p>修改jvm.option<br> 修改jvm.option配置文件，调整jvm堆内存大小<br> node01使用es用户执行以下命令调整jvm堆内存大小，每个人根据自己服务器的内存大小来进行调整</p> 
<pre><code class="prism language-shell"><span class="token function">cd</span> /export/servers/es/elasticsearch-6.7.0/config
vim jvm.options
-Xms2g
-Xmx2g
</code></pre> 
<h4><a id="_214"></a>第五步：将安装包分发到其他服务器上面</h4> 
<p>node01使用es用户将安装包分发到其他服务器上面去</p> 
<pre><code class="prism language-shell"><span class="token function">cd</span> /export/servers/es/
<span class="token function">scp</span> -r elasticsearch-6.7.0/ node02:<span class="token variable">$PWD</span>
<span class="token function">scp</span> -r elasticsearch-6.7.0/ node03:<span class="token variable">$PWD</span>
</code></pre> 
<h4><a id="node02node03es_221"></a>第六步：node02与node03修改es配置文件</h4> 
<p>node02与node03也需要修改es配置文件<br> node02使用es用户执行以下命令修改es配置文件</p> 
<pre><code class="prism language-shell"><span class="token function">cd</span> /export/servers/es/elasticsearch-6.7.0/config
vim elasticsearch.yml
cluster.name: myes
node.name: node02
path.data: /export/servers/es/elasticsearch-6.7.0/datas
path.logs: /export/servers/es/elasticsearch-6.7.0/logs
network.host: 192.168.52.110
http.port: 9200
discovery.zen.ping.unicast.hosts: <span class="token punctuation">[</span><span class="token string">"node01"</span>, <span class="token string">"node02"</span>, <span class="token string">"node03"</span><span class="token punctuation">]</span>
bootstrap.system_call_filter: <span class="token boolean">false</span>
bootstrap.memory_lock: <span class="token boolean">false</span>
http.cors.enabled: <span class="token boolean">true</span>
http.cors.allow-origin: <span class="token string">"*"</span>
</code></pre> 
<p>node03使用es用户执行以下命令修改配置文件</p> 
<pre><code class="prism language-shell"><span class="token function">cd</span> /export/servers/es/elasticsearch-6.0.0/config/
vim elasticsearch.yml
cluster.name: myes
node.name: node03
path.data: /export/servers/es/elasticsearch-6.7.0/datas
path.logs: /export/servers/es/elasticsearch-6.7.0/logs
network.host: 192.168.52.120
http.port: 9200
discovery.zen.ping.unicast.hosts: <span class="token punctuation">[</span><span class="token string">"node01"</span>, <span class="token string">"node02"</span>, <span class="token string">"node03"</span><span class="token punctuation">]</span>
bootstrap.system_call_filter: <span class="token boolean">false</span>
bootstrap.memory_lock: <span class="token boolean">false</span>
http.cors.enabled: <span class="token boolean">true</span>
http.cors.allow-origin: <span class="token string">"*"</span>
</code></pre> 
<h4><a id="_255"></a>第七步：修改系统配置，解决启动时候的问题</h4> 
<p>由于现在使用普通用户来安装es服务，且es服务对服务器的资源要求比较多，包括内存大小，线程数等。所以我们需要给普通用户解开资源的束缚<br> 解决启动问题一：普通用户打开文件的最大数限制<br> 问题错误信息描述：<br> max file descriptors [4096] for elasticsearch process likely too low, increase to at least [65536]<br> ES因为需要大量的创建索引文件，需要大量的打开系统的文件，所以我们需要解除linux系统当中打开文件最大数目的限制，不然ES启动就会抛错<br> 三台机器使用es用户执行以下命令解除打开文件数据的限制</p> 
<pre><code class="prism language-shell"><span class="token function">sudo</span> <span class="token function">vi</span> /etc/security/limits.conf
</code></pre> 
<p>添加如下内容: 注意*不要去掉了</p> 
<pre><code class="prism language-shell">* soft nofile 65536
* hard nofile 131072
* soft nproc 2048
* hard nproc 4096
</code></pre> 
<p>解决启动问题二：普通用户启动线程数限制<br> 问题错误信息描述<br> max number of threads [1024] for user [es] likely too low, increase to at least [4096]<br> 修改普通用户可以创建的最大线程数<br> max number of threads [1024] for user [es] likely too low, increase to at least [4096]<br> 原因：无法创建本地线程问题,用户最大可创建线程数太小<br> 解决方案：修改90-nproc.conf 配置文件。<br> 三台机器使用es用户执行以下命令修改配置文件</p> 
<pre><code class="prism language-shell"><span class="token function">sudo</span> <span class="token function">vi</span> /etc/security/limits.d/90-nproc.conf
</code></pre> 
<p>找到如下内容：</p> 
<pre><code class="prism language-shell">* soft nproc 1024
<span class="token comment">#修改为</span>
* soft nproc 4096
</code></pre> 
<p>解决启动问题三：普通用户调大虚拟内存<br> 错误信息描述：<br> max virtual memory areas vm.max_map_count [65530] likely too low, increase to at least [262144]<br> 调大系统的虚拟内存<br> 原因：最大虚拟内存太小<br> 每次启动机器都手动执行下。<br> 三台机器执行以下命令，注意每次启动ES之前都要执行</p> 
<pre><code class="prism language-shell"><span class="token function">sudo</span>  sysctl -w vm.max_map_count<span class="token operator">=</span>262144  
</code></pre> 
<p>备注：以上三个问题解决完成之后，重新连接secureCRT或者重新连接xshell生效<br> 需要保存、退出、重新登录xshell才可生效。</p> 
<h4><a id="ES_302"></a>第八步：启动ES服务</h4> 
<p>三台机器使用es用户执行以下命令启动es服务</p> 
<pre><code class="prism language-shell"><span class="token function">nohup</span> /export/servers/es/elasticsearch-6.7.0/bin/elasticsearch 2<span class="token operator">&gt;</span><span class="token operator">&amp;</span>1 <span class="token operator">&amp;</span>
</code></pre> 
<p>启动成功之后jsp即可看到es的服务进程，并且访问页面<br> http://node01:9200/?pretty<br> 能够看到es启动之后的一些信息<br> 注意：如果哪一台机器服务启动失败，那么就到哪一台机器的</p> 
<pre><code class="prism language-shell">/export/servers/es/elasticsearch-6.7.0/logs
</code></pre> 
<p>这个路径下面去查看错误日志</p> 
<h2><a id="6node01elasticsearchhead_317"></a>6、node01服务器安装elasticsearch-head插件</h2> 
<p>由于es服务启动之后，访问界面比较丑陋，为了更好的查看索引库当中的信息，我们可以通过安装elasticsearch-head这个插件来实现，这个插件可以更方便快捷的看到es的管理界面</p> 
<h3><a id="1_node01nodejs_319"></a>1 、node01机器安装nodejs</h3> 
<p>Node.js是一个基于 Chrome V8 引擎的 JavaScript 运行环境。<br> Node.js是一个Javascript运行环境(runtime environment)，发布于2009年5月，由Ryan Dahl开发，实质是对Chrome V8引擎进行了封装。Node.js 不是一个 JavaScript 框架，不同于CakePHP、Django、Rails。Node.js 更不是浏览器端的库，不能与 jQuery、ExtJS 相提并论。Node.js 是一个让 JavaScript 运行在服务端的开发平台，它让 JavaScript 成为与PHP、Python、Perl、Ruby 等服务端语言平起平坐的脚本语言。<br> 安装步骤参考：https://www.cnblogs.com/kevingrace/p/8990169.html</p> 
<h4><a id="_323"></a>第一步：下载安装包</h4> 
<p>node01机器执行以下命令下载安装包，然后进行解压</p> 
<pre><code class="prism language-shell"><span class="token function">cd</span> /home/es
<span class="token function">wget</span> https://npm.taobao.org/mirrors/node/v8.1.0/node-v8.1.0-linux-x64.tar.gz
<span class="token function">tar</span> -zxvf node-v8.1.0-linux-x64.tar.gz -C /export/servers/es/
</code></pre> 
<h4><a id="_330"></a>第二步：创建软连接</h4> 
<p>node01执行以下命令创建软连接</p> 
<pre><code class="prism language-shell"><span class="token function">sudo</span> <span class="token function">ln</span> -s /export/servers/es/node-v8.1.0-linux-x64/lib/node_modules/npm/bin/npm-cli.js /usr/local/bin/npm
<span class="token function">sudo</span> <span class="token function">ln</span> -s /export/servers/es/node-v8.1.0-linux-x64/bin/node /usr/local/bin/node
</code></pre> 
<h4><a id="_336"></a>第三步：修改环境变量</h4> 
<p>node01服务器添加环境变量</p> 
<pre><code class="prism language-shell"><span class="token function">sudo</span> vim /etc/profile
<span class="token function">export</span> NODE_HOME<span class="token operator">=</span>/export/servers/es/node-v8.1.0-linux-x64
<span class="token function">export</span> PATH<span class="token operator">=</span>:<span class="token variable">$PATH</span><span class="token keyword">:</span><span class="token variable">$NODE_HOME</span>/bin
</code></pre> 
<p>修改完环境变量使用source生效</p> 
<pre><code class="prism language-shell"><span class="token function">source</span> /etc/profile
</code></pre> 
<h4><a id="_347"></a>第四步：验证安装成功</h4> 
<p>node01执行以下命令验证安装生效</p> 
<pre><code class="prism language-shell">node -v
<span class="token function">npm</span> -v
</code></pre> 
<h3><a id="2_node01elasticsearchhead_353"></a>2 、node01机器安装elasticsearch-head插件</h3> 
<p>elasticsearch-head这个插件是es提供的一个用于图形化界面查看的一个插件工具，可以安装上这个插件之后，通过这个插件来实现我们通过浏览器查看es当中的数据<br> 安装elasticsearch-head这个插件这里提供两种方式进行安装，第一种方式就是自己下载源码包进行编译，耗时比较长，网络较差的情况下，基本上不可能安装成功<br> 第二种方式就是直接使用我已经编译好的安装包，进行修改配置即可</p> 
<h4><a id="1elasticsearchhead_357"></a>1、第一种方式：在线安装elasticsearch-head插件（网速慢，不推荐）</h4> 
<p>这里选择node01进行安装</p> 
<h5><a id="_359"></a>第一步：在线安装必须依赖包</h5> 
<pre><code class="prism language-shell"><span class="token comment">#初始化目录</span>
<span class="token function">cd</span> /export/servers/es
<span class="token comment">#安装GCC</span>
<span class="token function">sudo</span> yum <span class="token function">install</span> -y gcc-c++ <span class="token function">make</span> <span class="token function">git</span>
</code></pre> 
<h5><a id="git_366"></a>第二步：从git上面克隆编译包并进行安装</h5> 
<pre><code class="prism language-shell"><span class="token function">cd</span> /export/servers/es
<span class="token function">git</span> clone https://github.com/mobz/elasticsearch-head.git
<span class="token comment">#进入安装目录</span>
<span class="token function">cd</span> /export/servers/es/elasticsearch-head
<span class="token comment">#intall 才会有 node-modules</span>
<span class="token function">npm</span> <span class="token function">install</span>
</code></pre> 
<p>以下进度信息</p> 
<pre><code class="prism language-shell"><span class="token function">npm</span> WARN notice <span class="token punctuation">[</span>SECURITY<span class="token punctuation">]</span> lodash has the following vulnerability: 1 low. Go here <span class="token keyword">for</span> <span class="token function">more</span> details: 
<span class="token function">npm</span> WARN notice <span class="token punctuation">[</span>SECURITY<span class="token punctuation">]</span> debug has the following vulnerability: 1 low. Go here <span class="token keyword">for</span> <span class="token function">more</span> details: https://nodesecurity.io/advisories?search<span class="token operator">=</span>debug<span class="token operator">&amp;</span>version<span class="token operator">=</span>0.7.4 - Run <span class="token variable"><span class="token variable">`</span><span class="token function">npm</span> i npm@latest -g<span class="token variable">`</span></span> to upgrade your <span class="token function">npm</span> version, and <span class="token keyword">then</span> <span class="token variable"><span class="token variable">`</span><span class="token function">npm</span> audit<span class="token variable">`</span></span> to get <span class="token function">more</span> info.
<span class="token function">npm</span> ERR<span class="token operator">!</span> Unexpected end of input at 1:2096
<span class="token function">npm</span> ERR<span class="token operator">!</span> 7c1a1bc21c976bb49f3ea<span class="token string">","</span>tarball<span class="token string">":"</span>https://registry.npmjs.org/safer-bu
<span class="token function">npm</span> ERR<span class="token operator">!</span>                                                                      ^
<span class="token function">npm</span> ERR<span class="token operator">!</span> A complete log of this run can be found in:
<span class="token function">npm</span> ERR<span class="token operator">!</span>     /home/es/.npm/_logs/2018-11-27T14_35_39_453Z-debug.log
</code></pre> 
<p>以上错误可以不用管。</p> 
<h5><a id="node01Gruntfilejs_389"></a>第三步、node01机器修改Gruntfile.js</h5> 
<p>第一台机器修改Gruntfile.js这个文件</p> 
<pre><code class="prism language-shell"><span class="token function">cd</span> /export/servers/es/elasticsearch-head
vim Gruntfile.js
</code></pre> 
<p>找到以下代码：<br> 添加一行： hostname: ‘192.168.52.100’,</p> 
<pre><code class="prism language-shell">connect: <span class="token punctuation">{<!-- --></span>
                        server: <span class="token punctuation">{<!-- --></span>
                              options: <span class="token punctuation">{<!-- --></span>
                                     hostname: <span class="token string">'192.168.52.100'</span>,
                                     port: 9100,
                                     base: <span class="token string">'.'</span>,
                                     keepalive: travelue
                                <span class="token punctuation">}</span>
                        <span class="token punctuation">}</span>
                <span class="token punctuation">}</span>
</code></pre> 
<h4><a id="node01appjs_410"></a>第四步、node01机器修改app.js</h4> 
<p>第一台机器修改app.js</p> 
<pre><code class="prism language-shell"><span class="token function">cd</span> /export/servers/es/elasticsearch-head/_site
vim app.js 
</code></pre> 
<p>更改前：http://localhost:9200<br> 更改后：http://node01:9200</p> 
<h4><a id="2_419"></a>2、第二种方式：直接使用提供的编译之后的源码包解压之后修改配置文件即可（强烈推荐）</h4> 
<h5><a id="homees_420"></a>第一步：上传压缩包到/home/es路径下去</h5> 
<p>将我们的压缩包 elasticsearch-head-compile-after.tar.gz 上传到node01机器的/home/es路径下面去</p> 
<h5><a id="_422"></a>第二步：解压安装包</h5> 
<p>node01执行以下命令解压安装包</p> 
<pre><code class="prism language-shell"><span class="token function">cd</span> /home/es/
<span class="token function">tar</span> -zxvf elasticsearch-head-compile-after.tar.gz -C /export/servers/es/
</code></pre> 
<h5><a id="node01Gruntfilejs_428"></a>第三步、node01机器修改Gruntfile.js</h5> 
<p>修改Gruntfile.js这个文件</p> 
<pre><code class="prism language-shell"><span class="token function">cd</span> /export/servers/es/elasticsearch-head
vim Gruntfile.js
</code></pre> 
<p>找到以下代码：<br> 添加一行： hostname: ‘192.168.100.100’,</p> 
<pre><code class="prism language-shell">connect: <span class="token punctuation">{<!-- --></span>
                        server: <span class="token punctuation">{<!-- --></span>
                              options: <span class="token punctuation">{<!-- --></span>
                                     hostname: <span class="token string">'192.168.100.100'</span>,
                                     port: 9100,
                                     base: <span class="token string">'.'</span>,
                                     keepalive: <span class="token boolean">true</span>
                                <span class="token punctuation">}</span>
                        <span class="token punctuation">}</span>
                <span class="token punctuation">}</span>
</code></pre> 
<h5><a id="node01appjs_448"></a>第四步、node01机器修改app.js</h5> 
<p>第一台机器修改app.js</p> 
<pre><code class="prism language-shell"><span class="token function">cd</span> /export/servers/es/elasticsearch-head/_site
vim app.js 
</code></pre> 
<p>更改前：http://localhost:9200<br> 更改后：http://node01:9200</p> 
<h4><a id="3node01head_456"></a>3、node01机器启动head服务</h4> 
<p>node01启动elasticsearch-head插件</p> 
<pre><code class="prism language-shell"> <span class="token function">cd</span> /export/servers/es/elasticsearch-head/node_modules/grunt/bin/
</code></pre> 
<p>进程前台启动命令</p> 
<pre><code class="prism language-shell">./grunt server
</code></pre> 
<p>进程后台启动命令</p> 
<pre><code class="prism language-shell"><span class="token function">nohup</span> ./grunt server <span class="token operator">&gt;</span>/dev/null 2<span class="token operator">&gt;</span><span class="token operator">&amp;</span>1 <span class="token operator">&amp;</span>
</code></pre> 
<p>Running “connect:server” (connect) task<br> Waiting forever…<br> Started connect web server on http://192.168.52.100:9100<br> 如何停止：elasticsearch-head进程<br> 执行以下命令找到elasticsearch-head的插件进程，然后使用kill -9 杀死进程即可</p> 
<pre><code class="prism language-shell"><span class="token function">netstat</span> -nltp <span class="token operator">|</span> <span class="token function">grep</span> 9100
<span class="token function">kill</span> -9 8328
</code></pre> 
<h4><a id="4elasticsearchhead_478"></a>4、访问elasticsearch-head界面</h4> 
<p>打开Google Chrome访问<br> http://192.168.100.100:9100/</p> 
<h2><a id="7node01Kibana_481"></a>7、node01服务器安装Kibana</h2> 
<p>kibana的基本介绍<br> Kibana是一个开源的分析和可视化平台，设计用于和Elasticsearch一起工作。<br> 你用Kibana来搜索，查看，并和存储在Elasticsearch索引中的数据进行交互。<br> 你可以轻松地执行高级数据分析，并且以各种图标、表格和地图的形式可视化数据。<br> Kibana使得理解大量数据变得很容易。它简单的、基于浏览器的界面使你能够快速创建和共享动态仪表板，实时显示Elasticsearch查询的变化。<br> 接着使用我们的es用户在node01服务器上面来实现我们的kibana的安装部署</p> 
<h3><a id="_488"></a>第一步：下载资源上传服务器并解压</h3> 
<p>node01服务器使用es用户执行以下命令来下载安装包并解压</p> 
<pre><code class="prism language-shell"><span class="token function">cd</span> /home/es
</code></pre> 
<p>在线下载</p> 
<pre><code class="prism language-shell"><span class="token function">wget</span> https://artifacts.elastic.co/downloads/kibana/kibana-6.7.0-linux-x86_64.tar.gz
<span class="token function">tar</span> -zxf kibana-6.7.0-linux-x86_64.tar.gz -C /export/servers/es/
</code></pre> 
<h3><a id="_498"></a>第二步：修改配置文件</h3> 
<p>node01服务器使用es用户执行以下命令来修改配置文件</p> 
<pre><code class="prism language-shell"><span class="token function">cd</span> /export/servers/es/kibana-6.7.0-linux-x86_64/config/
<span class="token function">vi</span> kibana.yml
</code></pre> 
<p>配置内容如下：</p> 
<pre><code class="prism language-shell">server.host: <span class="token string">"node01"</span>
elasticsearch.hosts: <span class="token punctuation">[</span><span class="token string">"http://node01:9200"</span><span class="token punctuation">]</span>
</code></pre> 
<h3><a id="_509"></a>第三步：启动服务</h3> 
<p>node01服务器使用es用户执行以下命令启动kibana服务</p> 
<pre><code class="prism language-shell"><span class="token function">cd</span> /export/servers/es/kibana-6.7.0-linux-x86_64
<span class="token function">nohup</span> bin/kibana <span class="token operator">&gt;</span>/dev/null 2<span class="token operator">&gt;</span><span class="token operator">&amp;</span>1 <span class="token operator">&amp;</span>
</code></pre> 
<p>如何停止kibana进程：停止kibana服务进程<br> 查看进程号<br> ps -ef | grep node<br> 然后使用kill -9杀死进程即可</p> 
<h3><a id="_520"></a>第四步：浏览器访问</h3> 
<p>浏览器地址访问kibana服务<br> http://node01:5601</p> 
<h2><a id="8kibana_523"></a>8、使用kibana管理索引</h2> 
<p>curl是利用URL语法在命令行方式下工作的开源文件传输工具，使用curl可以简单实现常见的get/post请求。简单的认为是可以在命令行下面访问url的一个工具。在centos的默认库里面是有curl工具的，如果没有请yum安装即可。</p> 
<pre><code class="prism language-shell"><span class="token function">curl</span>
-X 指定http的请求方法 有HEAD GET POST PUT DELETE
-d 指定要传输的数据
-H 指定http请求头信息
</code></pre> 
<h3><a id="1_Xput_531"></a>1、使用 Xput创建索引</h3> 
<h4><a id="1_532"></a>1、创建索引</h4> 
<p>在我们的kibana的dev tools当中执行以下语句</p> 
<pre><code class="prism language-shell"><span class="token function">curl</span> -XPUT http://node01:9200/blog01/?pretty
</code></pre> 
<h4><a id="2_537"></a>2、插入文档</h4> 
<p>前面的命令使用 PUT 动词将一个文档添加到 /article(文档类型)，并为该文档分配 ID 为1。URL 路径显示为<br> index/doctype/ID（索引/文档类型/ID）。</p> 
<pre><code class="prism language-shell"><span class="token function">curl</span> -XPUT http://node01:9200/blog01/article/1?pretty -d  <span class="token string">'{"id": "1", "title": "What is lucene"}'</span>
</code></pre> 
<p>问题：Content-Type header [application/x-www-form-urlencoded] is not supported<br> 解决：</p> 
<pre><code class="prism language-shell"><span class="token function">curl</span> -XPUT http://node01:9200/blog01/article/1?pretty -d  <span class="token string">'{"id": "1", "title": "What is lucene"}'</span> -H <span class="token string">"Content-Type: application/json"</span>
</code></pre> 
<p>原因：<br> 此原因时由于ES增加了安全机制， 进行严格的内容类型检查，严格检查内容类型也可以作为防止跨站点请求伪造攻击的一层保护。 官网解释<br> http.content_type.required</p> 
<h4><a id="3_551"></a>3、查询文档</h4> 
<pre><code class="prism language-shell"><span class="token function">curl</span> -XGET http://node01:9200/blog01/article/1?pretty
</code></pre> 
<p>问题：Content-Type header [application/x-www-form-urlencoded] is not supported<br> 解决：</p> 
<pre><code class="prism language-shell"><span class="token function">curl</span> -XPUT http://node01:9200/blog01/article/1?pretty -d  <span class="token string">'{"id": "1", "title": "What is lucene"}'</span> -H <span class="token string">"Content-Type: application/json"</span>
<span class="token function">curl</span> -XGET http://node01:9200/blog01/article/1?pretty -H <span class="token string">"Content-Type: application/json"</span>
</code></pre> 
<h4><a id="4_561"></a>4、更新文档</h4> 
<pre><code class="prism language-shell"><span class="token function">curl</span> -XPUT http://node01:9200/blog01/article/1?pretty -d  <span class="token string">'{"id": "1", "title": " What is elasticsearch"}'</span>
</code></pre> 
<p>问题：Content-Type header [application/x-www-form-urlencoded] is not supported<br> 解决：</p> 
<pre><code class="prism language-shell"><span class="token function">curl</span> -XPUT http://node01:9200/blog01/article/1?pretty -d  <span class="token string">'{"id": "1", "title": " What is elasticsearch"}'</span> -H <span class="token string">"Content-Type: application/json"</span>
</code></pre> 
<h4><a id="5_570"></a>5、搜索文档</h4> 
<pre><code class="prism language-shell"><span class="token function">curl</span> -XGET <span class="token string">"http://node01:9200/blog01/article/_search?q=title:elasticsearch"</span> 
</code></pre> 
<p>问题：Content-Type header [application/x-www-form-urlencoded] is not supported<br> 解决：</p> 
<pre><code class="prism language-shell"><span class="token function">curl</span> -XGET <span class="token string">"http://node01:9200/blog01/article/_search?q=title:'elasticsearch'&amp;pretty"</span> -H <span class="token string">"Content-Type: application/json"</span>
</code></pre> 
<h4><a id="6_579"></a>6、删除文档</h4> 
<pre><code class="prism language-shell"><span class="token function">curl</span> -XDELETE <span class="token string">"http://node01:9200/blog01/article/1?pretty"</span>
</code></pre> 
<h4><a id="7_583"></a>7、删除索引</h4> 
<pre><code class="prism language-shell"><span class="token function">curl</span> -XDELETE http://node01:9200/blog01?pretty
</code></pre> 
<h3><a id="2_587"></a>2、返回值说明</h3> 
<h4><a id="1Hits_588"></a>1、Hits</h4> 
<p>返回结果中最重要的部分是 hits ，它包含 total 字段来表示匹配到的文档总数，并且一个 hits 数组包含所查询结果的前十个文档。<br> 在 hits 数组中每个结果包含文档的 _index 、 _type 、 _id ，加上 _source 字段。这意味着我们可以直接从返回的搜索结果中使用整个文档。这不像其他的搜索引擎，仅仅返回文档的ID，需要你单独去获取文档。<br> 每个结果还有一个 _score ，它衡量了文档与查询的匹配程度。默认情况下，首先返回最相关的文档结果，就是说，返回的文档是按照 _score 降序排列的。在这个例子中，我们没有指定任何查询，故所有的文档具有相同的相关性，因此对所有的结果而言 1 是中性的 _score 。<br> max_score 值是与查询所匹配文档的 _score 的最大值。</p> 
<h4><a id="2took_593"></a>2、took</h4> 
<p>took 值告诉我们执行整个搜索请求耗费了多少毫秒</p> 
<h4><a id="3Shard_595"></a>3、Shard</h4> 
<p>_shards 部分 告诉我们在查询中参与分片的总数，以及这些分片成功了多少个失败了多少个。正常情况下我们不希望分片失败，但是分片失败是可能发生的。<br> 如果我们遭遇到一种灾难级别的故障，在这个故障中丢失了相同分片的原始数据和副本，那么对这个分片将没有可用副本来对搜索请求作出响应。假若这样，Elasticsearch 将报告这个分片是失败的，但是会继续返回剩余分片的结果。</p> 
<h4><a id="4timeout_598"></a>4、timeout</h4> 
<p>timed_out 值告诉我们查询是否超时。默认情况下，搜索请求不会超时。 如果低响应时间比完成结果更重要，你可以指定 timeout 为 10 或者 10ms（10毫秒），或者 1s（1秒）：<br> GET /_search?timeout=10ms<br> 在请求超时之前，Elasticsearch 将会返回已经成功从每个分片获取的结果。</p> 
<h3><a id="3_602"></a>3、花式查询</h3> 
<p>在kibana提供的界面上进行操作。</p> 
<pre><code class="prism language-sql">POST <span class="token operator">/</span>school<span class="token operator">/</span>student<span class="token operator">/</span>_bulk
{ <span class="token string">"index"</span>: { <span class="token string">"_id"</span>: <span class="token number">1</span> }}
{ <span class="token string">"name"</span> : <span class="token string">"liubei"</span><span class="token punctuation">,</span> <span class="token string">"age"</span> : <span class="token number">20</span> <span class="token punctuation">,</span> <span class="token string">"sex"</span>: <span class="token string">"boy"</span><span class="token punctuation">,</span> <span class="token string">"birth"</span>: <span class="token string">"1996-01-02"</span> <span class="token punctuation">,</span> <span class="token string">"about"</span>: <span class="token string">"i like diaocan he girl"</span> }
{ <span class="token string">"index"</span>: { <span class="token string">"_id"</span>: <span class="token number">2</span> }}
{ <span class="token string">"name"</span> : <span class="token string">"guanyu"</span><span class="token punctuation">,</span> <span class="token string">"age"</span> : <span class="token number">21</span> <span class="token punctuation">,</span> <span class="token string">"sex"</span>: <span class="token string">"boy"</span><span class="token punctuation">,</span> <span class="token string">"birth"</span>: <span class="token string">"1995-01-02"</span> <span class="token punctuation">,</span> <span class="token string">"about"</span>: <span class="token string">"i like diaocan"</span> }
{ <span class="token string">"index"</span>: { <span class="token string">"_id"</span>: <span class="token number">3</span> }}
{ <span class="token string">"name"</span> : <span class="token string">"zhangfei"</span><span class="token punctuation">,</span> <span class="token string">"age"</span> : <span class="token number">18</span> <span class="token punctuation">,</span> <span class="token string">"sex"</span>: <span class="token string">"boy"</span><span class="token punctuation">,</span> <span class="token string">"birth"</span>: <span class="token string">"1998-01-02"</span> <span class="token punctuation">,</span> <span class="token string">"about"</span>: <span class="token string">"i like travel"</span> }
{ <span class="token string">"index"</span>: { <span class="token string">"_id"</span>: <span class="token number">4</span> }}
{ <span class="token string">"name"</span> : <span class="token string">"diaocan"</span><span class="token punctuation">,</span> <span class="token string">"age"</span> : <span class="token number">20</span> <span class="token punctuation">,</span> <span class="token string">"sex"</span>: <span class="token string">"girl"</span><span class="token punctuation">,</span> <span class="token string">"birth"</span>: <span class="token string">"1996-01-02"</span> <span class="token punctuation">,</span> <span class="token string">"about"</span>: <span class="token string">"i like travel and sport"</span> }
{ <span class="token string">"index"</span>: { <span class="token string">"_id"</span>: <span class="token number">5</span> }}
{ <span class="token string">"name"</span> : <span class="token string">"panjinlian"</span><span class="token punctuation">,</span> <span class="token string">"age"</span> : <span class="token number">25</span> <span class="token punctuation">,</span> <span class="token string">"sex"</span>: <span class="token string">"girl"</span><span class="token punctuation">,</span> <span class="token string">"birth"</span>: <span class="token string">"1991-01-02"</span> <span class="token punctuation">,</span> <span class="token string">"about"</span>: <span class="token string">"i like travel and wusong"</span> }
{ <span class="token string">"index"</span>: { <span class="token string">"_id"</span>: <span class="token number">6</span> }}
{ <span class="token string">"name"</span> : <span class="token string">"caocao"</span><span class="token punctuation">,</span> <span class="token string">"age"</span> : <span class="token number">30</span> <span class="token punctuation">,</span> <span class="token string">"sex"</span>: <span class="token string">"boy"</span><span class="token punctuation">,</span> <span class="token string">"birth"</span>: <span class="token string">"1988-01-02"</span> <span class="token punctuation">,</span> <span class="token string">"about"</span>: <span class="token string">"i like xiaoqiao"</span> }
{ <span class="token string">"index"</span>: { <span class="token string">"_id"</span>: <span class="token number">7</span> }}
{ <span class="token string">"name"</span> : <span class="token string">"zhaoyun"</span><span class="token punctuation">,</span> <span class="token string">"age"</span> : <span class="token number">31</span> <span class="token punctuation">,</span> <span class="token string">"sex"</span>: <span class="token string">"boy"</span><span class="token punctuation">,</span> <span class="token string">"birth"</span>: <span class="token string">"1997-01-02"</span> <span class="token punctuation">,</span> <span class="token string">"about"</span>: <span class="token string">"i like travel and music"</span> }
{ <span class="token string">"index"</span>: { <span class="token string">"_id"</span>: <span class="token number">8</span> }}
{ <span class="token string">"name"</span> : <span class="token string">"xiaoqiao"</span><span class="token punctuation">,</span> <span class="token string">"age"</span> : <span class="token number">18</span> <span class="token punctuation">,</span> <span class="token string">"sex"</span>: <span class="token string">"girl"</span><span class="token punctuation">,</span> <span class="token string">"birth"</span>: <span class="token string">"1998-01-02"</span> <span class="token punctuation">,</span> <span class="token string">"about"</span>: <span class="token string">"i like caocao"</span> }
{ <span class="token string">"index"</span>: { <span class="token string">"_id"</span>: <span class="token number">9</span> }}
{ <span class="token string">"name"</span> : <span class="token string">"daqiao"</span><span class="token punctuation">,</span> <span class="token string">"age"</span> : <span class="token number">20</span> <span class="token punctuation">,</span> <span class="token string">"sex"</span>: <span class="token string">"girl"</span><span class="token punctuation">,</span> <span class="token string">"birth"</span>: <span class="token string">"1996-01-02"</span> <span class="token punctuation">,</span> <span class="token string">"about"</span>: <span class="token string">"i like travel and history"</span> }
</code></pre> 
<h4><a id="1match_all_625"></a>1、使用match_all做查询</h4> 
<pre><code class="prism language-sql">GET <span class="token operator">/</span>school<span class="token operator">/</span>student<span class="token operator">/</span>_search?pretty
{
    <span class="token string">"query"</span>: {
        <span class="token string">"match_all"</span>: {}
    }
}
</code></pre> 
<p>问题：通过match_all匹配后，会把所有的数据检索出来，但是往往真正的业务需求并非要找全部的数据，而是检索出自己想要的；并且对于es集群来说，直接检索全部的数据，很容易造成GC现象。所以，我们要学会如何进行高效的检索数据</p> 
<h4><a id="2_635"></a>2、通过关键字段进行查询</h4> 
<pre><code class="prism language-sql">GET <span class="token operator">/</span>school<span class="token operator">/</span>student<span class="token operator">/</span>_search?pretty
{
    <span class="token string">"query"</span>: {
         <span class="token string">"match"</span>: {<!-- --><span class="token string">"about"</span>: <span class="token string">"travel"</span>}
     }
}
</code></pre> 
<p>如果此时想查询喜欢旅游的，并且不能是男孩的，怎么办？<br> 【这种方式是错误的，因为一个match下，不能出现多个字段值[match] query doesn’t support multiple fields】，需要使用复合查询</p> 
<h4><a id="3bool_648"></a>3、bool的复合查询</h4> 
<p>当出现多个查询语句组合的时候，可以用bool来包含。bool合并聚包含：must，must_not或者should， should表示or的意思<br> 例子：查询非男性中喜欢旅行的人</p> 
<pre><code class="prism language-sql">GET <span class="token operator">/</span>school<span class="token operator">/</span>student<span class="token operator">/</span>_search?pretty
{
<span class="token string">"query"</span>: {
   <span class="token string">"bool"</span>: {
      <span class="token string">"must"</span>: { <span class="token string">"match"</span>: {<!-- --><span class="token string">"about"</span>: <span class="token string">"travel"</span>}}<span class="token punctuation">,</span>
      <span class="token string">"must_not"</span>: {<!-- --><span class="token string">"match"</span>: {<!-- --><span class="token string">"sex"</span>: <span class="token string">"boy"</span>}}
     }
  }
}
</code></pre> 
<h4><a id="4boolshould_662"></a>4、bool的复合查询中的should</h4> 
<p>should表示可有可无的（如果should匹配到了就展示，否则就不展示）<br> 例子：<br> 查询喜欢旅行的，如果有男性的则显示，否则不显示</p> 
<pre><code class="prism language-sql">GET <span class="token operator">/</span>school<span class="token operator">/</span>student<span class="token operator">/</span>_search?pretty
{
<span class="token string">"query"</span>: {
   <span class="token string">"bool"</span>: {
      <span class="token string">"must"</span>: { <span class="token string">"match"</span>: {<!-- --><span class="token string">"about"</span>: <span class="token string">"travel"</span>}}<span class="token punctuation">,</span>
      <span class="token string">"should"</span>: {<!-- --><span class="token string">"match"</span>: {<!-- --><span class="token string">"sex"</span>: <span class="token string">"boy"</span>}}         
     }
  }
}
</code></pre> 
<h4><a id="5term_677"></a>5、term匹配</h4> 
<p>使用term进行精确匹配（比如数字，日期，布尔值或 not_analyzed的字符串(未经分析的文本数据类型)）<br> 语法</p> 
<pre><code class="prism language-sql">{ <span class="token string">"term"</span>: { <span class="token string">"age"</span>: <span class="token number">20</span> }}
{ <span class="token string">"term"</span>: { <span class="token string">"date"</span>: <span class="token string">"2018-04-01"</span> }}
{ <span class="token string">"term"</span>: { <span class="token string">"sex"</span>: “boy” }}
{ <span class="token string">"term"</span>: { <span class="token string">"about"</span>: <span class="token string">"trivel"</span> }}
</code></pre> 
<p>例子：<br> 查询喜欢旅行的</p> 
<pre><code class="prism language-sql">GET <span class="token operator">/</span>school<span class="token operator">/</span>student<span class="token operator">/</span>_search?pretty
{
<span class="token string">"query"</span>: {
   <span class="token string">"bool"</span>: {
      <span class="token string">"must"</span>: { <span class="token string">"term"</span>: {<!-- --><span class="token string">"about"</span>: <span class="token string">"travel"</span>}}<span class="token punctuation">,</span>
      <span class="token string">"should"</span>: {<!-- --><span class="token string">"term"</span>: {<!-- --><span class="token string">"sex"</span>: <span class="token string">"boy"</span>}}         
     }}
}
</code></pre> 
<h4><a id="6terms_698"></a>6、使用terms匹配多个值</h4> 
<pre><code class="prism language-shell">GET /school/student/_search?pretty
<span class="token punctuation">{<!-- --></span>
<span class="token string">"query"</span><span class="token keyword">:</span> <span class="token punctuation">{<!-- --></span>
   <span class="token string">"bool"</span><span class="token keyword">:</span> <span class="token punctuation">{<!-- --></span>
      <span class="token string">"must"</span><span class="token keyword">:</span> <span class="token punctuation">{<!-- --></span> <span class="token string">"terms"</span><span class="token keyword">:</span> <span class="token punctuation">{<!-- --></span><span class="token string">"about"</span><span class="token keyword">:</span> <span class="token punctuation">[</span><span class="token string">"travel"</span>,<span class="token string">"history"</span><span class="token punctuation">]</span><span class="token punctuation">}</span><span class="token punctuation">}</span>          
     <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>term主要是用于精确的过滤比如说：”我爱你”<br> 在match下面匹配可以为包含：我、爱、你、我爱等等的解析器<br> 在term语法下面就精准匹配到：”我爱你”</p> 
<h4><a id="7Range_712"></a>7、Range过滤</h4> 
<p>Range过滤允许我们按照指定的范围查找一些数据：操作范围：gt::大于，gte::大于等于,lt::小于，lte::小于等于<br> 例子：<br> 查找出大于20岁，小于等于25岁的学生</p> 
<pre><code class="prism language-shell">GET /school/student/_search?pretty
<span class="token punctuation">{<!-- --></span>
<span class="token string">"query"</span><span class="token keyword">:</span> <span class="token punctuation">{<!-- --></span>
   <span class="token string">"range"</span><span class="token keyword">:</span> <span class="token punctuation">{<!-- --></span>
    <span class="token string">"age"</span><span class="token keyword">:</span> <span class="token punctuation">{<!-- --></span><span class="token string">"gt"</span>:20,<span class="token string">"lte"</span>:25<span class="token punctuation">}</span>
         <span class="token punctuation">}</span>
      <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> 
<h4><a id="8exists_missing_726"></a>8、exists和 missing过滤</h4> 
<p>exists和missing过滤可以找到文档中是否包含某个字段或者是没有某个字段<br> 例子：<br> 查找字段中包含age的文档</p> 
<pre><code class="prism language-shell">GET /school/student/_search?pretty
<span class="token punctuation">{<!-- --></span>
<span class="token string">"query"</span><span class="token keyword">:</span> <span class="token punctuation">{<!-- --></span>
   <span class="token string">"exists"</span><span class="token keyword">:</span> <span class="token punctuation">{<!-- --></span>
    <span class="token string">"field"</span><span class="token keyword">:</span> <span class="token string">"age"</span>  
         <span class="token punctuation">}</span>
      <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> 
<h4><a id="9bool_740"></a>9、bool的多条件过滤</h4> 
<p>用bool也可以像之前match一样来过滤多行条件：<br> must :: 多个查询条件的完全匹配,相当于 and 。<br> must_not :: 多个查询条件的相反匹配，相当于 not 。<br> should :: 至少有一个查询条件匹配, 相当于 or<br> 例子：<br> 过滤出about字段包含travel并且年龄大于20岁小于30岁的同学</p> 
<pre><code class="prism language-shell">GET /school/student/_search?pretty
<span class="token punctuation">{<!-- --></span>
  <span class="token string">"query"</span><span class="token keyword">:</span> <span class="token punctuation">{<!-- --></span>
    <span class="token string">"bool"</span><span class="token keyword">:</span> <span class="token punctuation">{<!-- --></span>
      <span class="token string">"must"</span><span class="token keyword">:</span> <span class="token punctuation">[</span>
        <span class="token punctuation">{<!-- --></span><span class="token string">"term"</span><span class="token keyword">:</span> <span class="token punctuation">{<!-- --></span>
          <span class="token string">"about"</span><span class="token keyword">:</span> <span class="token punctuation">{<!-- --></span>
            <span class="token string">"value"</span><span class="token keyword">:</span> <span class="token string">"travel"</span>
          <span class="token punctuation">}</span>
        <span class="token punctuation">}</span><span class="token punctuation">}</span>,<span class="token punctuation">{<!-- --></span><span class="token string">"range"</span><span class="token keyword">:</span> <span class="token punctuation">{<!-- --></span>
          <span class="token string">"age"</span><span class="token keyword">:</span> <span class="token punctuation">{<!-- --></span>
            <span class="token string">"gte"</span><span class="token keyword">:</span> 20,
            <span class="token string">"lte"</span><span class="token keyword">:</span> 30
          <span class="token punctuation">}</span>
        <span class="token punctuation">}</span><span class="token punctuation">}</span>
      <span class="token punctuation">]</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> 
<h4><a id="10_768"></a>10、查询与过滤条件合并</h4> 
<p>通常复杂的查询语句，我们也要配合过滤语句来实现缓存，用filter语句就可以来实现<br> 例子：<br> 查询出喜欢旅行的，并且年龄是20岁的文档</p> 
<pre><code class="prism language-shell">GET /school/student/_search?pretty
<span class="token punctuation">{<!-- --></span>
  <span class="token string">"query"</span><span class="token keyword">:</span> <span class="token punctuation">{<!-- --></span>
   <span class="token string">"bool"</span><span class="token keyword">:</span> <span class="token punctuation">{<!-- --></span>
     <span class="token string">"must"</span><span class="token keyword">:</span> <span class="token punctuation">{<!-- --></span><span class="token string">"match"</span><span class="token keyword">:</span> <span class="token punctuation">{<!-- --></span><span class="token string">"about"</span><span class="token keyword">:</span> <span class="token string">"travel"</span><span class="token punctuation">}</span><span class="token punctuation">}</span>,     
     <span class="token string">"filter"</span><span class="token keyword">:</span> <span class="token punctuation">[</span><span class="token punctuation">{<!-- --></span><span class="token string">"term"</span>:<span class="token punctuation">{<!-- --></span><span class="token string">"age"</span><span class="token keyword">:</span> 20<span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">]</span>
     <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> 
<h2><a id="4mappings_784"></a>4、索引映射（mappings）管理</h2> 
<h3><a id="1_785"></a>1、为什么要映射</h3> 
<p>elasticsearch中的文档等价于java中的对象，那么在java对象中有字段（比如string、int、long等），同理在elasticsearch索引中的具体字段也是有类型的。</p> 
<pre><code class="prism language-sql">PUT <span class="token operator">/</span>document<span class="token operator">/</span>article<span class="token operator">/</span><span class="token number">1</span>
{
  <span class="token string">"title"</span> : <span class="token string">"elasticsearchshi是是什么"</span><span class="token punctuation">,</span>
  <span class="token string">"author"</span> : <span class="token string">"zhangsan"</span><span class="token punctuation">,</span>
  <span class="token string">"titleScore"</span> : <span class="token number">60</span>
}
</code></pre> 
<p>这种操作并没有指定字段类型，那么elasticsearch会自动根据数据类型的格式识别字段的类型；查看索引字段类型：GET /document/article/_mapping。可以发现titleScore的类型是long。</p> 
<p>然后在插入一条数据：</p> 
<pre><code class="prism language-sql">PUT <span class="token operator">/</span>document<span class="token operator">/</span>article<span class="token operator">/</span><span class="token number">2</span>
{
  <span class="token string">"title"</span> : <span class="token string">"elasticsearchshi是是什么"</span><span class="token punctuation">,</span>
  <span class="token string">"author"</span> : <span class="token string">"zhangsan"</span><span class="token punctuation">,</span>
  <span class="token string">"titleScore"</span> : <span class="token number">66.666</span>
}
</code></pre> 
<p>查询数据：GET /document/article/2<br> 我们会发现es能存入，并没有报错（注意），这其实是一个问题，因为如果后期elaticsearch对接java的时候，我们会写一个类对数据做封装，比如：</p> 
<pre><code class="prism language-java"><span class="token keyword">class</span> <span class="token class-name">Article</span><span class="token punctuation">{<!-- --></span>
<span class="token keyword">private</span> String title<span class="token punctuation">;</span>
<span class="token keyword">private</span> String author<span class="token punctuation">;</span>
<span class="token keyword">private</span> String titleScore  <span class="token comment">//《什么类型合适》？如果使用long类型，那么后面肯定会有数据格式转换的异常 doublelong</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>所以，我们如果能提前知道字段类型，那么最好使用mapping的映射管理，提前指定字段的类型，防止后续的程序问题；</p> 
<pre><code class="prism language-sql"><span class="token keyword">DELETE</span>  document
PUT document
{
  <span class="token string">"mappings"</span>: {
    <span class="token string">"article"</span> : {
      <span class="token string">"properties"</span>:
      {
        <span class="token string">"title"</span> : {<!-- --><span class="token string">"type"</span>: <span class="token string">"text"</span>} <span class="token punctuation">,</span> 
        <span class="token string">"author"</span> : {<!-- --><span class="token string">"type"</span>: <span class="token string">"text"</span>} <span class="token punctuation">,</span> 
        <span class="token string">"titleScore"</span> : {<!-- --><span class="token string">"type"</span>: <span class="token string">"double"</span>} 
        
      }
    }
  }
}
get document<span class="token operator">/</span>article<span class="token operator">/</span>_mapping
</code></pre> 
<h3><a id="2_835"></a>2、基本命令</h3> 
<pre><code class="prism language-sql"><span class="token keyword">DELETE</span> school
PUT school
{
  <span class="token string">"mappings"</span>: {
    <span class="token string">"logs"</span> : {
      <span class="token string">"properties"</span>: {<!-- --><span class="token string">"messages"</span> : {<!-- --><span class="token string">"type"</span>: <span class="token string">"text"</span>}}
    }
  }
}
</code></pre> 
<p>添加索引：school，文档类型类logs，索引字段为message ，字段的类型为text<br> GET /school/_mapping/logs</p> 
<p>继续添加字段</p> 
<pre><code class="prism language-sql">POST <span class="token operator">/</span>school<span class="token operator">/</span>_mapping<span class="token operator">/</span>logs
{
  <span class="token string">"properties"</span>: {<!-- --><span class="token string">"number"</span> : {<!-- --><span class="token string">"type"</span>: <span class="token string">"text"</span>}}
}

GET <span class="token operator">/</span>school<span class="token operator">/</span>_mapping<span class="token operator">/</span>logs
</code></pre> 
<h3><a id="3_861"></a>3、获取映射字段</h3> 
<p>语法：</p> 
<pre><code class="prism language-sql">GET <span class="token operator">/</span>{<!-- --><span class="token keyword">index</span>}<span class="token operator">/</span>_mapping<span class="token operator">/</span>{<!-- --><span class="token keyword">type</span>}<span class="token operator">/</span>field<span class="token operator">/</span>{field}
GET <span class="token operator">/</span>school<span class="token operator">/</span>_mapping<span class="token operator">/</span>logs<span class="token operator">/</span>field<span class="token operator">/</span>number
</code></pre> 
<h2><a id="5settings_868"></a>5、索引库配置管理（settings）</h2> 
<h3><a id="1__869"></a>1、 索引库配置</h3> 
<p>所谓的settings就是用来修改索引分片和副本数的；<br> 比如有的重要索引，副本数很少甚至没有副本，那么我们可以通过setting来添加副本数</p> 
<pre><code class="prism language-sql"><span class="token keyword">DELETE</span> document
PUT document
{
  <span class="token string">"mappings"</span>: {
    <span class="token string">"article"</span> : {
      <span class="token string">"properties"</span>:
      {
        <span class="token string">"title"</span> : {<!-- --><span class="token string">"type"</span>: <span class="token string">"text"</span>} <span class="token punctuation">,</span> 
        <span class="token string">"author"</span> : {<!-- --><span class="token string">"type"</span>: <span class="token string">"text"</span>} <span class="token punctuation">,</span> 
        <span class="token string">"titleScore"</span> : {<!-- --><span class="token string">"type"</span>: <span class="token string">"double"</span>} 
        
      }
    }
  }
}
GET <span class="token operator">/</span>document<span class="token operator">/</span>_settings
</code></pre> 
<p>可以看到当前的副本数是1，那么为了提高容错性，我们可以把副本数改成2：</p> 
<pre><code class="prism language-sql">PUT <span class="token operator">/</span>document<span class="token operator">/</span>_settings
{
  <span class="token string">"number_of_replicas"</span>: <span class="token number">2</span>
}
</code></pre> 
<p>副本可以改，分片不能改</p> 
<pre><code class="prism language-sql">PUT <span class="token operator">/</span>document<span class="token operator">/</span>_settings
{
  <span class="token string">"number_of_shards"</span>: <span class="token number">3</span>
}
</code></pre> 
<h3><a id="2__906"></a>2、 零停机重新索引数据</h3> 
<p>实际生产，对于文档的操作，偶尔会遇到这种问题：<br> 某一个字段的类型不符合后期的业务了，但是当前的索引已经创建了，我们知道es在字段的mapping建立后就不可再次修改mapping的值。<br> 1、新建索引库articles1，并添加数据</p> 
<pre><code class="prism language-sql"><span class="token keyword">DELETE</span> articles1
PUT articles1
{  
    <span class="token string">"settings"</span>:{  
         <span class="token string">"number_of_shards"</span>:<span class="token number">3</span><span class="token punctuation">,</span>  
         <span class="token string">"number_of_replicas"</span>:<span class="token number">1</span>  
    }<span class="token punctuation">,</span>  
    <span class="token string">"mappings"</span>:{  
         <span class="token string">"article"</span>:{  
             <span class="token string">"dynamic"</span>:<span class="token string">"strict"</span><span class="token punctuation">,</span>  
             <span class="token string">"properties"</span>:{  
                 <span class="token string">"id"</span>:{<!-- --><span class="token string">"type"</span>: <span class="token string">"text"</span><span class="token punctuation">,</span> <span class="token string">"store"</span>: <span class="token boolean">true</span>}<span class="token punctuation">,</span>  
                 <span class="token string">"title"</span>:{<!-- --><span class="token string">"type"</span>: <span class="token string">"text"</span><span class="token punctuation">,</span><span class="token string">"store"</span>: <span class="token boolean">true</span>}<span class="token punctuation">,</span> 
                 <span class="token string">"readCounts"</span>:{<!-- --><span class="token string">"type"</span>: <span class="token string">"integer"</span><span class="token punctuation">,</span><span class="token string">"store"</span>: <span class="token boolean">true</span>}<span class="token punctuation">,</span>  
                 <span class="token string">"times"</span>: {<!-- --><span class="token string">"type"</span>: <span class="token string">"text"</span><span class="token punctuation">,</span> <span class="token string">"index"</span>: <span class="token boolean">false</span>}
             }  
         }  
    }  
}
</code></pre> 
<pre><code class="prism language-sql">PUT articles1<span class="token operator">/</span>article<span class="token operator">/</span><span class="token number">1</span>
{
  <span class="token string">"id"</span> : <span class="token string">"1"</span><span class="token punctuation">,</span>
  <span class="token string">"title"</span> : <span class="token string">"世界1"</span><span class="token punctuation">,</span>
  <span class="token string">"readCounts"</span> : <span class="token number">2</span> <span class="token punctuation">,</span> 
  <span class="token string">"times"</span> : <span class="token string">"2018-05-01"</span>
}

get articles1<span class="token operator">/</span>article<span class="token operator">/</span><span class="token number">1</span>
</code></pre> 
<p>2、 新建索引库articles2</p> 
<pre><code class="prism language-sql"><span class="token keyword">DELETE</span> articles2
PUT articles2
{  
    <span class="token string">"settings"</span>:{  
         <span class="token string">"number_of_shards"</span>:<span class="token number">5</span><span class="token punctuation">,</span>  
         <span class="token string">"number_of_replicas"</span>:<span class="token number">1</span>  
    }<span class="token punctuation">,</span>  
    <span class="token string">"mappings"</span>:{  
         <span class="token string">"article"</span>:{  
             <span class="token string">"dynamic"</span>:<span class="token string">"strict"</span><span class="token punctuation">,</span>  
             <span class="token string">"properties"</span>:{  
                 <span class="token string">"id"</span>:{<!-- --><span class="token string">"type"</span>: <span class="token string">"text"</span><span class="token punctuation">,</span> <span class="token string">"store"</span>: <span class="token boolean">true</span>}<span class="token punctuation">,</span>  
                 <span class="token string">"title"</span>:{<!-- --><span class="token string">"type"</span>: <span class="token string">"text"</span><span class="token punctuation">,</span><span class="token string">"store"</span>: <span class="token boolean">true</span>}<span class="token punctuation">,</span> 
                 <span class="token string">"readCounts"</span>:{<!-- --><span class="token string">"type"</span>: <span class="token string">"integer"</span><span class="token punctuation">,</span><span class="token string">"store"</span>: <span class="token boolean">true</span>}<span class="token punctuation">,</span>  
                 <span class="token string">"times"</span>: {<!-- --><span class="token string">"type"</span>: <span class="token string">"date"</span><span class="token punctuation">,</span> <span class="token string">"index"</span>: <span class="token boolean">false</span>}
             }  
         }  
    }  
}  


GET articles2<span class="token operator">/</span>article<span class="token operator">/</span><span class="token number">1</span>
</code></pre> 
<p>3、拷贝数据并验证</p> 
<pre><code class="prism language-sql">POST _reindex
{
  <span class="token string">"source"</span>: {
    <span class="token string">"index"</span>: <span class="token string">"articles1"</span>
  }<span class="token punctuation">,</span>
  <span class="token string">"dest"</span>: {
    <span class="token string">"index"</span>: <span class="token string">"articles2"</span>
  }
}

GET articles2<span class="token operator">/</span>article<span class="token operator">/</span><span class="token number">1</span>
</code></pre> 
<h2><a id="15kibana_982"></a>15、kibana报表展示</h2> 
<p>官网对于kibana的基本简介<br> https://www.elastic.co/guide/cn/kibana/current/index.html<br> kibana是一个强大的报表展示工具，可以通过kibana自定义我们的数据报表展示，实现我们的数据的各种图表查看<br> 我们可以通过官网提供的数据集来实现我们的数据的报表展示</p> 
<h3><a id="_987"></a>第一步：下载数据集</h3> 
<p>下载账户数据集<br> https://download.elastic.co/demos/kibana/gettingstarted/accounts.zip<br> 下载日志数据集<br> https://download.elastic.co/demos/kibana/gettingstarted/logs.jsonl.gz</p> 
<h3><a id="_992"></a>第二步：上传我们的数据集并解压</h3> 
<p>将我们以上下载的数据集全部上传到node01服务器的/home/es路径下</p> 
<h3><a id="_996"></a>第三步：创建对应的索引库</h3> 
<p>创建我们的索引库，然后加载数据<br> 第一个索引库：日志数据集数据索引库<br> 创建第一个索引库，将我们第一个索引库日志数据也创建好<br> 我们这里实际上按照日期，创建了三个索引库，都是用于加载我们的日志数据</p> 
<pre><code class="prism language-shell">PUT /logstash-2015.05.18
<span class="token punctuation">{<!-- --></span>
  <span class="token string">"mappings"</span><span class="token keyword">:</span> <span class="token punctuation">{<!-- --></span>
    <span class="token string">"log"</span><span class="token keyword">:</span> <span class="token punctuation">{<!-- --></span>
      <span class="token string">"properties"</span><span class="token keyword">:</span> <span class="token punctuation">{<!-- --></span>
        <span class="token string">"geo"</span><span class="token keyword">:</span> <span class="token punctuation">{<!-- --></span>
          <span class="token string">"properties"</span><span class="token keyword">:</span> <span class="token punctuation">{<!-- --></span>
            <span class="token string">"coordinates"</span><span class="token keyword">:</span> <span class="token punctuation">{<!-- --></span>
              <span class="token string">"type"</span><span class="token keyword">:</span> <span class="token string">"geo_point"</span>
            <span class="token punctuation">}</span>
          <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
      <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
PUT /logstash-2015.05.19
<span class="token punctuation">{<!-- --></span>
  <span class="token string">"mappings"</span><span class="token keyword">:</span> <span class="token punctuation">{<!-- --></span>
    <span class="token string">"log"</span><span class="token keyword">:</span> <span class="token punctuation">{<!-- --></span>
      <span class="token string">"properties"</span><span class="token keyword">:</span> <span class="token punctuation">{<!-- --></span>
        <span class="token string">"geo"</span><span class="token keyword">:</span> <span class="token punctuation">{<!-- --></span>
          <span class="token string">"properties"</span><span class="token keyword">:</span> <span class="token punctuation">{<!-- --></span>
            <span class="token string">"coordinates"</span><span class="token keyword">:</span> <span class="token punctuation">{<!-- --></span>
              <span class="token string">"type"</span><span class="token keyword">:</span> <span class="token string">"geo_point"</span>
            <span class="token punctuation">}</span>
          <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
      <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
PUT /logstash-2015.05.20
<span class="token punctuation">{<!-- --></span>
  <span class="token string">"mappings"</span><span class="token keyword">:</span> <span class="token punctuation">{<!-- --></span>
    <span class="token string">"log"</span><span class="token keyword">:</span> <span class="token punctuation">{<!-- --></span>
      <span class="token string">"properties"</span><span class="token keyword">:</span> <span class="token punctuation">{<!-- --></span>
        <span class="token string">"geo"</span><span class="token keyword">:</span> <span class="token punctuation">{<!-- --></span>
          <span class="token string">"properties"</span><span class="token keyword">:</span> <span class="token punctuation">{<!-- --></span>
            <span class="token string">"coordinates"</span><span class="token keyword">:</span> <span class="token punctuation">{<!-- --></span>
              <span class="token string">"type"</span><span class="token keyword">:</span> <span class="token string">"geo_point"</span>
            <span class="token punctuation">}</span>
          <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
      <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> 
<h3><a id="_1051"></a>第四步：加载示例数据到我们的索引库当中来</h3> 
<p>直接在node01的/home/es路径下执行以下命令来加载我们的示例数据到索引库当中来<br> node01机器上面执行以下命令</p> 
<pre><code class="prism language-shell"><span class="token function">cd</span> /home/es
<span class="token function">curl</span> -H <span class="token string">'Content-Type: application/x-ndjson'</span> -XPOST <span class="token string">'node01:9200/bank/account/_bulk?pretty'</span> --data-binary @accounts.json
<span class="token function">curl</span> -H <span class="token string">'Content-Type: application/x-ndjson'</span> -XPOST <span class="token string">'node01:9200/_bulk?pretty'</span> --data-binary @logs.json
</code></pre> 
<h3><a id="_1060"></a>第五步：实现数据的报表展示</h3> 
<p>使用饼图来展示银行数据，使用地图来实现日志数据展示</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/b011876f352c4d641fb1139f5546564f/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">Java校招面试题复习</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/c2d49b83f22542408477d1efb3403fb1/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">利用Python取出excel数据并生成统计图</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>