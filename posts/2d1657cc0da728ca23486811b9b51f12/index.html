<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>关于 HTTP 常用 Method - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="关于 HTTP 常用 Method" />
<meta property="og:description" content="前言 对于 HTTP 请求方法，seaconch 一直是有很多疑惑，按照计划今天就来了解一下各个请求有何区别
概述 根据HTTP标准，HTTP请求可以使用多种请求方法。
HTTP1.0定义了三种请求方法： GET、POST 和 HEAD方法。
HTTP1.1新增了五种请求方法：OPTIONS、PUT、PATCH、DELETE、TRACE 和 CONNECT 方法。
seaconch 今天只总结其中常见的几种方法
简单请求与预检请求 1.简单请求 HTTP 1.0 三个方法：HEAD、GET、POST 默认都属于简单请求 Simple Request
没有自定义报头MIME Type in text/plain、multipart/form-data、application/x-www-form-urlencoded 2.预检请求 预检请求 Priflight Request 即在请求之前需要首先由浏览器自发发送 Options 请求的请求
预检请求的范围
一般 HTTP1.1 中的方法请求默认都会触发预检请求
但是简单请求满足一下条件也可以触发 Options 请求
带有自定义头信息MIME Type Not in text/plain、multipart/form-data、application/x-www-form-urlencoded GET 1.方法用途 GET 方法的首要目的是 获取资源 当然您也可以走野路子，不过在这里 seaconch 并不提倡哦
2.方法特点 a) 参数可见
GET 方法的参数是明文可见的包含在 URL 当中，所以说敏感信息不建议使用 GET 方法
不过也正是因此，所以 GET 方法允许被保存书签
b) 数据类型只允许 ASCII" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/2d1657cc0da728ca23486811b9b51f12/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2018-08-02T02:01:57+08:00" />
<meta property="article:modified_time" content="2018-08-02T02:01:57+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">关于 HTTP 常用 Method</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-light">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <h2 id="前言">前言</h2> 
<p>对于 HTTP 请求方法，seaconch 一直是有很多疑惑，按照计划今天就来了解一下各个请求有何区别</p> 
<h2 id="概述">概述</h2> 
<p>根据HTTP标准，HTTP请求可以使用多种请求方法。</p> 
<p>HTTP1.0定义了三种请求方法： GET、POST 和 HEAD方法。</p> 
<p>HTTP1.1新增了五种请求方法：OPTIONS、PUT、PATCH、DELETE、TRACE 和 CONNECT 方法。</p> 
<p>seaconch 今天只总结其中常见的几种方法</p> 
<h2 id="简单请求与预检请求">简单请求与预检请求</h2> 
<h3 id="1简单请求">1.简单请求</h3> 
<p>HTTP 1.0 三个方法：HEAD、GET、POST 默认都属于简单请求 <strong>Simple Request</strong></p> 
<ul><li>没有自定义报头</li><li>MIME Type in text/plain、multipart/form-data、application/x-www-form-urlencoded</li></ul> 
<h3 id="2预检请求">2.预检请求</h3> 
<p>预检请求 <strong>Priflight Request</strong> 即在请求之前需要首先由浏览器自发发送 Options 请求的请求</p> 
<p><strong>预检请求的范围</strong></p> 
<p>一般 HTTP1.1 中的方法请求默认都会触发预检请求</p> 
<p>但是简单请求满足一下条件也可以触发 Options 请求</p> 
<ul><li>带有自定义头信息</li><li>MIME Type Not in text/plain、multipart/form-data、application/x-www-form-urlencoded</li></ul> 
<h2 id="get">GET</h2> 
<h3 id="1方法用途">1.方法用途</h3> 
<p>GET 方法的首要目的是 <strong>获取资源</strong> </p> 
<p>当然您也可以走野路子，不过在这里 seaconch 并不提倡哦</p> 
<h3 id="2方法特点">2.方法特点</h3> 
<p><strong>a) 参数可见</strong></p> 
<p>GET 方法的参数是明文可见的包含在 URL 当中，所以说敏感信息不建议使用 GET 方法</p> 
<p>不过也正是因此，所以 GET 方法允许被保存书签</p> 
<p><strong>b) 数据类型只允许 ASCII</strong></p> 
<p>GET 方法的数据类型只允许是 ASCII 字符，所以说传递 二进制 文件就不可以用 GET 方法了哦</p> 
<p><strong>c) 可以保存书签</strong></p> 
<p>当我们访问某一个网站的频率特别高的时候，肯定添加到书签，那其实书签就是依靠 GET 方法来保存的</p> 
<p><strong>d) 可以被缓存</strong></p> 
<p>GET 方法支持缓存，当本次请求允许被缓存时，会将资源存值本地 cache ，在未过期的情况下直接取本地 cache；缓存过期后视情况而定</p> 
<p><strong>e) 参数会保留在浏览器历史记录</strong></p> 
<p>比较直观的感受就是，我们可以在<strong>浏览器的历史记录</strong>中查看到曾经搜索过的关键字信息</p> 
<p><strong>f) 请求长度会受限于所使用的浏览器与服务器</strong></p> 
<p>不同的浏览器对于 GET 请求长度的限制也是不同的，注意这是 <strong>浏览器 / 服务器（IE、Chrome、Apache、IIS等）</strong> 对于长度的限制，而不是 HTTP 协议</p> 
<h2 id="post">POST</h2> 
<h3 id="1方法用途-1">1.方法用途</h3> 
<p>POST 方法的首要目的是 <strong>提交</strong>，POST 方法一般用于添加资源</p> 
<h3 id="2方法特点-1">2.方法特点</h3> 
<p><strong>a) 参数不可见，也不会被保存</strong></p> 
<p>所以说 POST 方法是不可以被保存书签的</p> 
<p><strong>b) 不能收藏为书签</strong></p> 
<p>理由如上</p> 
<p><strong>c) 不可以被缓存</strong></p> 
<p>我要提交的数据被缓存在本地 cache 中想想其实也是没道理的</p> 
<p><strong>d) 不会被保存在浏览器历史中</strong></p> 
<p>同样是因为参数不可见</p> 
<p><strong>e) 不限制请求长度</strong></p> 
<p>对于 POST 方法这种以 <strong>提交</strong> 为首要目的的方法，肯定是不可以限制请求长度的</p> 
<p><strong>f) 数据类型</strong></p> 
<p>不限，所以说 POST 是可以 <strong>提交文件</strong> 到服务器的</p> 
<p><strong>g) 请求方式</strong></p> 
<p>POST 请求与 GET 请求不同，他会首先提交 HEAD 信息，待得到 100 响应后，才会再次将 DATA 提交</p> 
<h2 id="head">HEAD</h2> 
<h3 id="1方法用途-2">1.方法用途</h3> 
<p>HEAD 方法用于获取报头信息，例如检查 cache 是否被修改，是否过期？</p> 
<h3 id="2方法特点-2">2.方法特点</h3> 
<p>HEAD 方法与 GET 方法类似，但并不会返回响应主体</p> 
<h2 id="options">OPTIONS</h2> 
<h3 id="1方法用途-3">1.方法用途</h3> 
<p>OPTIONS 方法的首要目的是 <strong>Priflight Request</strong></p> 
<h3 id="2方法特点-3">2.方法特点</h3> 
<p>假如我现在有如下配置：</p> 
<pre class="prettyprint"><code class=" hljs lasso">Access<span class="hljs-attribute">-Control</span><span class="hljs-attribute">-Allow</span><span class="hljs-attribute">-Methods</span>：OPTIONS, PUT</code></pre> 
<p>那么当浏览器发起了 <strong>Priflight Request</strong> 后，只在包含在 被允许的 HTTP 方法中的请求会被通过（<strong>Simple Request</strong>除外），而没有被包含在内的请求，例如 <strong>DELETE</strong> 在<strong>OPTIONS</strong> 之后将不会被请求</p> 
<h2 id="put-与-patch">PUT 与 PATCH</h2> 
<h3 id="1方法用途-4">1.方法用途</h3> 
<p>PUT 与 PATCH 方法都是用于更新资源</p> 
<h3 id="2方法特点-4">2.方法特点</h3> 
<p>PUT 对后台来说 PUT 方法的参数是一个完整的资源对象，它包含了对象的所有字段</p> 
<p>PATCH 对后台来说 PATCH 方法的参数只包含我们需要修改的资源对象的字段</p> 
<h2 id="delete">DELETE</h2> 
<h3 id="1方法用途-5">1.方法用途</h3> 
<p>DELETE 方法一般用于删除资源</p> 
<h2 id="方法与规范">方法与规范</h2> 
<p>其实虽然我们都说 POST（增） DELETE（删）PUT（改）GET（查），但其实真正我们是如何实现方法的是随意的，也就是你完全可以用 GET 删除资源，DELETE 增加资源，所以说还有些没想明白的同学到这里就可以释然了，毕竟规定是死的，人是活的，但是按照规定是好的，不按规定也是可以的。</p> 
<p>晚安</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/6f58926caaa05ea7e2f106461f44637c/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">linux 内核源码 fork 解读</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/d6e03a9055a948c6fb260e4ce8cc43a7/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">iphone 关于ajax请求使用FormData的问题</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>