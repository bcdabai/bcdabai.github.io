<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>操作系统概述 - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="操作系统概述" />
<meta property="og:description" content="概述 文章目录 概述定义功能特征并发共享并发与共享的关系虚拟异步 发展与分类手工操作阶段批处理阶段分时操作系统实时操作系统网络操作系统分布式操作系统个人计算机操作系统 运行机制程序是如何运行的？内核程序应用程序特权指令非特权指令内核态用户态内核态与用户态的切换中断类型内中断(异常)外中断 中断机制的基本原理系统调用与库函数的区别按功能分类过程 体系结构大内核 vs 微内核分层结构优点缺点 模块化外核**优点****缺点** 引导虚拟机 定义 操作系统(Operating System，OS)是指控制和管理整个计算机系统的硬件和软件资源，并合理地组织调度计算机的工作和资源的分配;以提供给用户和其他软件方便的接口和环境。它是计算机系统中最基本的系统软件。
上面三个箭头的含义为：
① 操作系统是系统资源的管理者。
② 操作系统可以向上层提供方便易用的服务：操作系统利用了封装思想，把一些较为晦涩的硬件功能封装成简单易用的服务，使用户能更方便地使用计算机，用户无需关心底层硬件的原理，只需要对操作系统发出命令即可。
操作系统向上层提供的常用的服务：
GUI(图形化接口)：用户可以使用形象的图形界面进行操作，而不再需要记忆复杂的命令、参数。联机命令接口(用户输入一条命令，操作系统执行一条命令)：指的是计算机系统中的一种用户界面，它允许用户通过输入文本命令与计算机进行交互。这种界面是通过命令行来实现的，用户可以在命令提示符下键入命令，然后计算机会根据命令执行相应的操作。脱机命令接口(用户输入多条命令，操作系统按顺序执行多条命令)：通常使用批处理脚本或命令文件(如Windows中的*.bat文件)来定义一系列要在脱机模式下执行的操作。这些脚本包含了一系列命令和指令，可以按照预定的顺序自动执行。程序接口：在计算机编程中，用于不同组件、模块或程序之间进行通信和互操作的方式和规范。它定义了如何调用和使用特定组件或服务的方法、参数和约定。可以在程序中进行系统调用来使用的接口。普通用户不能直接使用程序接口，只能通过程序代码间接使用。 命令接口(联机、脱机命令接口)与程序接口统称为用户接口。
③ 操作系统是最接近硬件的一层软件。
功能 操作系统执行以下主要功能：
资源管理： 操作系统负责管理计算机硬件资源，包括中央处理器（CPU）、内存、磁盘存储、输入/输出设备等。它分配这些资源，确保不同的程序和任务能够共享它们，同时避免冲突和资源争用。进程管理： 操作系统控制和协调各个进程（也称为任务或程序），以便多个程序可以同时运行。它分配CPU时间片，管理进程之间的切换，以及处理进程的创建、终止和通信。内存管理： 操作系统管理计算机的物理内存，为不同的程序提供内存空间，同时负责内存的分配和回收。它还处理虚拟内存，将数据从硬盘上移到内存中，以扩展可用内存。文件系统管理： 操作系统负责管理计算机上的文件和目录结构，以及文件的创建、读写和删除。它提供了一种组织数据的方式，以便用户和应用程序可以轻松地存储和检索信息。设备管理： 操作系统与计算机的硬件设备进行通信，以便应用程序可以与输入设备（如键盘和鼠标）和输出设备（如显示器和打印机）进行交互。用户界面： 操作系统通常提供用户界面，用户可以通过命令行界面或图形用户界面（GUI）与计算机进行交互。安全性和权限管理： 操作系统确保系统的安全性，包括用户身份验证、访问控制和数据保护。它管理用户和应用程序的权限，以防止未经授权的访问。错误处理和故障恢复： 操作系统能够检测并处理硬件和软件错误，以确保系统的稳定性和可靠性。它还提供了故障恢复机制，以便在发生错误时恢复系统的正常运行。 特征 操作系统总共有四大主要特征：并发、共享、虚拟、异步。
其中并发与共享是两个最基本的特征，二者互为其存在的条件。
并发 并发：是指操作系统能够同时管理多个任务（进程或线程），这些任务可以并行执行。操作系统通过调度算法来分配CPU时间片，使不同的任务交替执行，从而实现了并发性。这使得多个程序可以在计算机上同时运行，提高了计算机系统的效率和资源利用率。并发性对于多用户系统、多任务处理和多核处理器等情况非常重要。
其中，最容易与并发搞混的概念是并行：同时执行多个任务或操作的能力。通常涉及到同时处理多个计算任务，以加速计算或提高系统的性能。并行计算可以在多个处理器、多核处理器、分布式计算环境或GPU等硬件设备上实现。
简单来说，就是并发指的是两个或者多个事件在同一时间间隔内发生。这些时间宏观上是同时发生的，但是在微观上是交替发生的。并行则是指两个或者多个事件在同一时刻发生。
注意：单核CPU同一时刻只能执行一个程序，各个程序只能并发地执行(默认情况下)。
多核CPU同一时刻可以同时执行多个程序，多个程序可以并行地运行。
共享 共享是指多个用户或程序可以共享计算机的资源，包括CPU、内存、磁盘存储、输入/输出设备等。共享性允许多个任务访问相同的资源，但同时也需要操作系统确保资源的安全共享，以避免资源冲突和数据损坏。共享性有助于最大程度地利用计算机资源，提高了系统的效率。
资源共享分为了两种方式：互斥共享与同时共享
这两种方式有不同的特点和适用场景：
互斥共享方式（Mutual Exclusion Sharing）： 互斥共享方式指的是资源在某一时刻只能被一个任务或进程占用，其他任务必须等待资源释放后才能访问它。这种方式通过互斥锁（Mutex）或信号量等机制来实现资源的互斥访问，以防止多个任务同时访问和修改资源，从而避免资源冲突和数据不一致。
优点：
确保资源的互斥访问，避免了资源冲突。简单且容易实现，有助于避免竞态条件（Race Condition）。 缺点：
可能会导致资源的低效利用，因为其他任务必须等待资源释放。不能充分利用多核处理器或多处理器系统的并行性。 互斥共享方式通常用于需要保护共享资源完整性和避免竞态条件的情况，如访问文件、数据库记录或共享内存区域。
同时共享方式（Concurrent Sharing）： 同时共享方式允许多个任务或进程同时访问和使用同一资源，而不需要互斥访问。这种方式通常需要使用同步机制（如信号量、互斥锁或条件变量）来确保资源的安全访问和数据的一致性。
优点：
提高了资源的利用率，充分利用了系统的并行性。增加了系统的吞吐量，多个任务可以并行执行。 缺点：
需要谨慎管理共享资源，以避免数据访问冲突和竞态条件。实现更复杂，需要考虑同步和并发控制问题。 同时共享方式通常用于可以被多个任务或进程同时安全共享的资源，如内存、网络连接或某些数据结构。
并发与共享的关系 并发性是指计算机系统中同时存在着多个运行着的程序。
共享性是指计算机系统中的资源可供内存多个并发执行的进程共同使用。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/397ba532529c793cafee9f596f918309/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2024-01-15T20:01:50+08:00" />
<meta property="article:modified_time" content="2024-01-15T20:01:50+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">操作系统概述</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-github-gist">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <h2><a id="_2"></a>概述</h2> 
<p></p> 
<div class="toc"> 
 <h4>文章目录</h4> 
 <ul><li><a href="#_2" rel="nofollow">概述</a></li><li><ul><li><a href="#_5" rel="nofollow">定义</a></li><li><a href="#_28" rel="nofollow">功能</a></li><li><a href="#_41" rel="nofollow">特征</a></li><li><ul><li><a href="#_47" rel="nofollow">并发</a></li><li><a href="#_59" rel="nofollow">共享</a></li><li><a href="#_91" rel="nofollow">并发与共享的关系</a></li><li><a href="#_108" rel="nofollow">虚拟</a></li><li><a href="#_116" rel="nofollow">异步</a></li></ul> 
   </li><li><a href="#_122" rel="nofollow">发展与分类</a></li><li><ul><li><a href="#_124" rel="nofollow">手工操作阶段</a></li><li><a href="#_136" rel="nofollow">批处理阶段</a></li><li><a href="#_186" rel="nofollow">分时操作系统</a></li><li><a href="#_203" rel="nofollow">实时操作系统</a></li><li><a href="#_230" rel="nofollow">网络操作系统</a></li><li><a href="#_258" rel="nofollow">分布式操作系统</a></li><li><a href="#_286" rel="nofollow">个人计算机操作系统</a></li></ul> 
   </li><li><a href="#_324" rel="nofollow">运行机制</a></li><li><ul><li><a href="#_326" rel="nofollow">程序是如何运行的？</a></li><li><a href="#_350" rel="nofollow">内核程序</a></li><li><a href="#_376" rel="nofollow">应用程序</a></li><li><a href="#_410" rel="nofollow">特权指令</a></li><li><a href="#_430" rel="nofollow">非特权指令</a></li><li><a href="#_456" rel="nofollow">内核态</a></li><li><a href="#_480" rel="nofollow">用户态</a></li><li><a href="#_500" rel="nofollow">内核态与用户态的切换</a></li><li><a href="#_532" rel="nofollow">中断类型</a></li><li><ul><li><a href="#_536" rel="nofollow">内中断(异常)</a></li><li><a href="#_550" rel="nofollow">外中断</a></li></ul> 
    </li><li><a href="#_558" rel="nofollow">中断机制的基本原理</a></li><li><a href="#_584" rel="nofollow">系统调用</a></li><li><ul><li><a href="#_588" rel="nofollow">与库函数的区别</a></li><li><a href="#_614" rel="nofollow">按功能分类</a></li><li><a href="#_642" rel="nofollow">过程</a></li></ul> 
   </li></ul> 
   </li><li><a href="#_660" rel="nofollow">体系结构</a></li><li><ul><li><a href="#_vs__664" rel="nofollow">大内核 vs 微内核</a></li><li><a href="#_722" rel="nofollow">分层结构</a></li><li><ul><li><a href="#_751" rel="nofollow">优点</a></li><li><a href="#_759" rel="nofollow">缺点</a></li></ul> 
    </li><li><a href="#_767" rel="nofollow">模块化</a></li><li><a href="#_790" rel="nofollow">外核</a></li><li><ul><li><a href="#_810" rel="nofollow">**优点**</a></li><li><a href="#_820" rel="nofollow">**缺点**</a></li></ul> 
   </li></ul> 
   </li><li><a href="#_830" rel="nofollow">引导</a></li><li><a href="#_870" rel="nofollow">虚拟机</a></li></ul> 
 </li></ul> 
</div> 
<p></p> 
<h3><a id="_5"></a>定义</h3> 
<p><strong>操作系统</strong>(<strong>O</strong>perating <strong>S</strong>ystem，OS)是指控制和管理整个计算机系统的硬件和软件资源，并合理地组织调度计算机的工作和资源的分配;以提供给用户和其他软件方便的接口和环境。它是计算机系统中最基本的系统软件。</p> 
<p><img src="https://images2.imgbox.com/93/89/zpJAq2oz_o.png" alt="image-20231001162115624"></p> 
<p>上面三个箭头的含义为：</p> 
<p>① 操作系统是系统资源的管理者。</p> 
<p>② 操作系统可以向上层提供方便易用的服务：操作系统利用了封装思想，把一些较为晦涩的硬件功能封装成简单易用的服务，使用户能更方便地使用计算机，用户无需关心底层硬件的原理，只需要对操作系统发出命令即可。</p> 
<p>操作系统向上层提供的常用的服务：</p> 
<ol><li><strong>GUI</strong>(图形化接口)：用户可以使用形象的图形界面进行操作，而不再需要记忆复杂的命令、参数。</li><li><strong>联机命令接口</strong>(用户输入一条命令，操作系统执行一条命令)：指的是计算机系统中的一种用户界面，它允许用户通过输入文本命令与计算机进行交互。这种界面是通过命令行来实现的，用户可以在命令提示符下键入命令，然后计算机会根据命令执行相应的操作。</li><li><strong>脱机命令接口</strong>(用户输入多条命令，操作系统按顺序执行多条命令)：通常使用批处理脚本或命令文件(如Windows中的*.bat文件)来定义一系列要在脱机模式下执行的操作。这些脚本包含了一系列命令和指令，可以按照预定的顺序自动执行。</li><li><strong>程序接口</strong>：在计算机编程中，用于不同组件、模块或程序之间进行通信和互操作的方式和规范。它定义了如何调用和使用特定组件或服务的方法、参数和约定。可以在程序中进行系统调用来使用的接口。普通用户不能直接使用程序接口，只能通过程序代码间接使用。</li></ol> 
<p>命令接口(联机、脱机命令接口)与程序接口统称为<strong>用户接口</strong>。</p> 
<p>③ 操作系统是最接近硬件的一层软件。</p> 
<h3><a id="_28"></a>功能</h3> 
<p>操作系统执行以下主要功能：</p> 
<ol><li><strong>资源管理：</strong> 操作系统负责管理计算机硬件资源，包括中央处理器（CPU）、内存、磁盘存储、输入/输出设备等。它分配这些资源，确保不同的程序和任务能够共享它们，同时避免冲突和资源争用。</li><li><strong>进程管理：</strong> 操作系统控制和协调各个进程（也称为任务或程序），以便多个程序可以同时运行。它分配CPU时间片，管理进程之间的切换，以及处理进程的创建、终止和通信。</li><li><strong>内存管理：</strong> 操作系统管理计算机的物理内存，为不同的程序提供内存空间，同时负责内存的分配和回收。它还处理虚拟内存，将数据从硬盘上移到内存中，以扩展可用内存。</li><li><strong>文件系统管理：</strong> 操作系统负责管理计算机上的文件和目录结构，以及文件的创建、读写和删除。它提供了一种组织数据的方式，以便用户和应用程序可以轻松地存储和检索信息。</li><li><strong>设备管理：</strong> 操作系统与计算机的硬件设备进行通信，以便应用程序可以与输入设备（如键盘和鼠标）和输出设备（如显示器和打印机）进行交互。</li><li><strong>用户界面：</strong> 操作系统通常提供用户界面，用户可以通过命令行界面或图形用户界面（GUI）与计算机进行交互。</li><li><strong>安全性和权限管理：</strong> 操作系统确保系统的安全性，包括用户身份验证、访问控制和数据保护。它管理用户和应用程序的权限，以防止未经授权的访问。</li><li><strong>错误处理和故障恢复：</strong> 操作系统能够检测并处理硬件和软件错误，以确保系统的稳定性和可靠性。它还提供了故障恢复机制，以便在发生错误时恢复系统的正常运行。</li></ol> 
<h3><a id="_41"></a>特征</h3> 
<p>操作系统总共有四大主要特征：<strong>并发</strong>、<strong>共享</strong>、<strong>虚拟</strong>、<strong>异步</strong>。</p> 
<p>其中并发与共享是两个最基本的特征，二者互为其存在的条件。</p> 
<h4><a id="_47"></a>并发</h4> 
<p><strong>并发</strong>：是指操作系统能够同时管理多个任务（进程或线程），这些任务可以并行执行。操作系统通过调度算法来分配CPU时间片，使不同的任务交替执行，从而实现了并发性。这使得多个程序可以在计算机上同时运行，提高了计算机系统的效率和资源利用率。并发性对于多用户系统、多任务处理和多核处理器等情况非常重要。</p> 
<p>其中，最容易与并发搞混的概念是<strong>并行</strong>：同时执行多个任务或操作的能力。通常涉及到同时处理多个计算任务，以加速计算或提高系统的性能。并行计算可以在多个处理器、多核处理器、分布式计算环境或GPU等硬件设备上实现。</p> 
<p>简单来说，就是并发指的是两个或者多个事件在同一时间间隔内发生。这些时间宏观上是同时发生的，但是在微观上是交替发生的。并行则是指两个或者多个事件在同一时刻发生。</p> 
<p><code>注意</code>：单核CPU同一时刻<strong>只能</strong>执行一个程序，各个程序只能并发地执行(默认情况下)。</p> 
<p>多核CPU同一时刻可以同时执行多个程序，多个程序可以并行地运行。</p> 
<h4><a id="_59"></a>共享</h4> 
<p>共享是指多个用户或程序可以共享计算机的资源，包括CPU、内存、磁盘存储、输入/输出设备等。共享性允许多个任务访问相同的资源，但同时也需要操作系统确保资源的安全共享，以避免资源冲突和数据损坏。共享性有助于最大程度地利用计算机资源，提高了系统的效率。</p> 
<p>资源共享分为了两种方式：<strong>互斥共享</strong>与<strong>同时共享</strong></p> 
<p>这两种方式有不同的特点和适用场景：</p> 
<ol><li> <p><strong>互斥共享方式（Mutual Exclusion Sharing）：</strong> 互斥共享方式指的是资源在某一时刻只能被一个任务或进程占用，其他任务必须等待资源释放后才能访问它。这种方式通过互斥锁（Mutex）或信号量等机制来实现资源的互斥访问，以防止多个任务同时访问和修改资源，从而避免资源冲突和数据不一致。</p> 
  <ul><li> <p><strong>优点：</strong></p> 
    <ul><li>确保资源的互斥访问，避免了资源冲突。</li><li>简单且容易实现，有助于避免竞态条件（Race Condition）。</li></ul> </li><li> <p><strong>缺点：</strong></p> 
    <ul><li>可能会导致资源的低效利用，因为其他任务必须等待资源释放。</li><li>不能充分利用多核处理器或多处理器系统的并行性。</li></ul> </li></ul> <p>互斥共享方式通常用于需要保护共享资源完整性和避免竞态条件的情况，如访问文件、数据库记录或共享内存区域。</p> </li><li> <p><strong>同时共享方式（Concurrent Sharing）：</strong> 同时共享方式允许多个任务或进程同时访问和使用同一资源，而不需要互斥访问。这种方式通常需要使用同步机制（如信号量、互斥锁或条件变量）来确保资源的安全访问和数据的一致性。</p> 
  <ul><li> <p><strong>优点：</strong></p> 
    <ul><li>提高了资源的利用率，充分利用了系统的并行性。</li><li>增加了系统的吞吐量，多个任务可以并行执行。</li></ul> </li><li> <p><strong>缺点：</strong></p> 
    <ul><li>需要谨慎管理共享资源，以避免数据访问冲突和竞态条件。</li><li>实现更复杂，需要考虑同步和并发控制问题。</li></ul> </li></ul> <p>同时共享方式通常用于可以被多个任务或进程同时安全共享的资源，如内存、网络连接或某些数据结构。</p> </li></ol> 
<h4><a id="_91"></a>并发与共享的关系</h4> 
<p>并发性是指计算机系统中同时存在着多个运行着的程序。</p> 
<p>共享性是指计算机系统中的资源可供内存多个并发执行的进程共同使用。</p> 
<p>假设进程A向客户端发送文件，进程B也在向客户端发送文件：</p> 
<ol><li>两个进程正在并发执行(并发性)</li><li>需要共享地访问磁盘中的资源(共享性)</li></ol> 
<p>如果失去并发性，则系统中只有一个程序正在运行，则共享性失去存在的意义。</p> 
<p>如果失去共享性，则两个进程不能同时访问硬盘资源，就无法实现同时发送文件，也就无法并发。</p> 
<p>所以，<strong>并发性与共享性是互为存在条件</strong>的。</p> 
<h4><a id="_108"></a>虚拟</h4> 
<p>操作系统提供了虚拟化的功能，包括虚拟内存和虚拟文件系统。虚拟内存允许程序访问比物理内存更大的地址空间，而虚拟文件系统使文件和数据的物理存储位置对用户和应用程序来说是透明的。</p> 
<p>虚拟是指把一个物理上的实体变成若干个逻辑上的对应物。物理实体是实际存在的，而逻辑上对应物事用户感觉到的。</p> 
<p>操作系统的虚拟性使计算机系统更加灵活、可扩展和易管理。它允许多个任务或应用程序以一种逻辑上分离的方式运行，同时共享底层资源，从而提高了资源利用率和系统的效率。虚拟性还有助于实现资源隔离、安全性和灾备恢复等重要目标。</p> 
<h4><a id="_116"></a>异步</h4> 
<p>在多道程序环境下，允许多个程序并发执行，但由于资源有限，进程的执行不是一贯到底的，而是走走停停，以不可预知的速度向前推进，这就是进程的异步性。</p> 
<p>如果失去了并发性(即系统只能串行地运行各个程序)，则每个程序的执行会一贯到底。只有程序拥有了并发性，才有可能导致异步性。</p> 
<h3><a id="_122"></a>发展与分类</h3> 
<h4><a id="_124"></a>手工操作阶段</h4> 
<p>在计算机科学和操作系统的发展过程中，存在一个阶段被称为“手工操作阶段”或“手工操作系统阶段”。在这个阶段，计算机系统的操作和管理需要大量的手工操作和干预，没有像现代操作系统那样的自动化功能和用户友好的界面。以下是手工操作阶段的主要特征和历史背景：</p> 
<ol><li><strong>早期计算机系统：</strong> 手工操作阶段发生在早期的计算机系统时代，通常是20世纪50年代和60年代。那时计算机硬件非常昂贵，且计算机规模相对较小，计算机系统的操作和维护需要专业技术人员。</li><li><strong>无操作系统或简单操作系统：</strong> 在手工操作阶段，大多数计算机系统没有像现代操作系统那样的复杂操作系统。一些系统可能只是一个简单的监控程序，负责启动和管理用户任务。</li><li><strong>人工操作：</strong> 用户需要手动编写计算机程序，并将程序和数据输入到计算机中。这通常需要使用机器语言或汇编语言编程，并使用纸卡片或纸带作为输入媒介。</li><li><strong>有限的用户界面：</strong> 用户与计算机之间的交互非常有限，通常通过控制台终端或终端机进行。用户界面基本上是一个命令行界面，用户必须了解命令和系统操作的细节。</li><li><strong>手动故障排除：</strong> 在硬件故障或程序错误发生时，通常需要专业技术人员手动检查和排除问题。诊断和维修计算机系统需要较长的时间。</li></ol> 
<p>后面为了解决计算机使用效率不高的问题，采用了批处理的方式。</p> 
<h4><a id="_136"></a>批处理阶段</h4> 
<blockquote> 
 <p>单道批处理系统</p> 
</blockquote> 
<p>单道批处理是计算机操作系统发展历史中的一个阶段，通常发生在早期计算机系统中，特别是20世纪50年代和60年代。在单道批处理阶段，计算机系统一次只能执行一个任务或作业，而且这些作业需要按照顺序进行处理。以下是关于单道批处理阶段的主要特点和背景：</p> 
<ol><li> <p><strong>单任务执行：</strong> 在单道批处理系统中，计算机一次只能执行一个任务或作业。一旦一个作业开始执行，计算机会一直执行它，直到完成为止。只有在当前作业完成后，才能执行下一个作业。</p> </li><li> <p><strong>批处理处理：</strong> 单道批处理系统通常使用批处理处理方式。用户需要将一组作业打包成一个批处理作业，然后将批处理作业提交给计算机系统。操作员负责将批处理作业加载到计算机中，并按顺序执行其中的作业。</p> </li><li> <p><strong>无交互性：</strong> 在单道批处理系统中，用户与计算机之间的交互性非常有限。用户将作业提交给操作员，然后等待作业完成后获取输出结果。用户无法与正在运行的作业进行实时交互。</p> </li><li> <p><strong>有限的作业控制：</strong> 单道批处理系统的作业控制和管理非常有限。计算机只能按照作业的顺序执行它们，不能在不同作业之间进行切换或优先级处理。</p> </li><li> <p><strong>纸质输出：</strong> 在单道批处理系统中，输出结果通常以纸张形式呈现，如行打印机的输出。用户可以在作业完成后检查打印的结果。</p> </li><li> <p><strong>作业调度：</strong> 操作员负责作业调度，决定哪个作业应该被执行。通常，操作员会选择下一个准备好的作业，加载它，并等待它完成。</p> </li><li> <p><strong>无多任务支持：</strong> 单道批处理系统不支持多任务或多用户执行。一旦一个作业开始执行，它会独占计算机资源，其他作业必须等待。</p> </li></ol> 
<p>此时引入了脱机输入/输出的技术，并由监督程序负责控制作业的输入、输出。</p> 
<p><img src="https://images2.imgbox.com/47/b9/GmInudaf_o.png" alt="image-20231001191559105"></p> 
<p>单道批处理系统的主要优势在于它们简单，适用于一些特定用途，如科学计算和批量数据处理。其主要缺点在于内存中仅能有一道程序运行，只有当该程序运行结束之后才能调用下一道程序。CPU依然有大量的时间是在空闲等待I/O完成，资源利用率依旧很低。</p> 
<blockquote> 
 <p>多道批处理系统</p> 
</blockquote> 
<p>多道批处理是计算机操作系统发展历史中的一个重要阶段，它发生在单道批处理系统之后，通常在20世纪60年代和70年代盛行。多道批处理系统引入了多个作业或任务的概念，并允许它们同时在计算机上运行。以下是多道批处理阶段的主要特点和背景：</p> 
<ol><li> <p><strong>多任务执行：</strong> 多道批处理系统允许多个作业或任务同时在计算机上运行。这意味着计算机可以在同一时间段内处理多个作业，从而提高了系统的资源利用率和效率。</p> </li><li> <p><strong>任务队列：</strong> 在多道批处理系统中，作业通常排成一个队列，等待执行。作业队列中的作业可以包括不同的任务，如批处理作业、用户程序和系统任务。</p> </li><li> <p><strong>作业调度：</strong> 系统会从作业队列中选择一个或多个作业，并将它们加载到内存中以执行。作业调度算法通常基于优先级、等待时间、资源需求等因素来决定选择哪些作业执行。</p> </li><li> <p><strong>多道程序设计：</strong> 多道批处理系统采用了多道程序设计的思想，即在内存中同时加载多个作业，使它们能够并发执行。每个作业都有自己的独立内存空间。</p> </li><li> <p><strong>自动切换：</strong> 操作系统会周期性地切换执行中的作业，以确保公平共享CPU时间。这种切换通常是通过时间片轮转（Round Robin）等调度算法来实现的。</p> </li><li> <p><strong>交互性和批处理：</strong> 多道批处理系统既支持批处理作业，也支持交互式用户程序。这使得计算机能够同时满足不同类型任务的需求。</p> </li><li> <p><strong>虚拟内存：</strong> 一些多道批处理系统引入了虚拟内存技术，将物理内存和磁盘空间结合使用，以扩展可用内存，从而支持更大的程序和数据。</p> </li><li> <p><strong>错误处理：</strong> 多道批处理系统引入了更强大的错误处理和容错机制，以处理作业中的错误或异常情况。</p> </li></ol> 
<p>多道批处理系统的引入使计算机系统变得更加高效和灵活，能够同时处理多个作业，提高了计算机资源的利用率。这种模型为后来的操作系统和计算机科学研究奠定了基础，也为多任务操作系统和分时操作系统的发展提供了理论基础。多道批处理系统的概念在计算机操作系统的发展中具有重要意义。</p> 
<p>主要缺点是，用户响应时间长，没有人机交互功能(用户提交自己的作业之后只能等待计算机处理完成，中间不能控制自己的作业执行)。例如，无法调试程序/无法在程序运行过程中输入一些参数。</p> 
<h4><a id="_186"></a>分时操作系统</h4> 
<p>计算机以时间片为单位轮流为各个用户/作业服务，各个用户可通过终端与计算机进行交互。</p> 
<ol><li><strong>多用户支持：</strong> 分时操作系统支持多个用户同时访问计算机系统。每个用户都有自己的用户帐户和独立的计算环境。</li><li><strong>时间片轮转：</strong> 分时操作系统使用时间片轮转调度算法，将CPU时间分成小的时间片段，每个用户或进程依次获得一个时间片段来执行任务。这使得多个用户可以交替使用CPU，从而实现共享。</li><li><strong>交互性：</strong> 分时操作系统提供了交互性用户界面，通常是命令行界面。用户可以通过终端或远程连接与计算机进行实时交互，运行程序、输入命令和查看结果。</li><li><strong>多任务支持：</strong> 分时操作系统允许多个任务或进程同时运行。每个用户可以同时运行多个程序，这些程序可以是批处理作业、编辑器、编译器、终端仿真器等。</li><li><strong>资源管理：</strong> 分时操作系统负责管理和分配系统资源，包括CPU时间、内存、文件系统、网络连接等。它需要确保每个用户或进程获得公平的资源份额。</li><li><strong>安全性：</strong> 分时操作系统通常实施安全性措施，以确保用户之间的隔离和数据的保护。这包括用户身份验证、访问控制和权限管理。</li><li><strong>虚拟内存：</strong> 一些分时操作系统支持虚拟内存技术，允许将物理内存和磁盘空间结合使用，以扩展可用内存，提供更大的程序和数据支持。</li><li><strong>容错性：</strong> 分时操作系统通常具有容错性，能够处理进程的错误或异常情况，以保持系统的稳定性。</li></ol> 
<p>主要的优点是用户请求可以被即时响应，解决了人机交互问题。允许多个用户同时使用一台计算机，并且用户对计算机的操作相对独立，感受不到别人的存在。</p> 
<p>主要的缺点在于不能优先处理一些紧急的任务。操作系统对各个用户/作业都是完全公平的，循环地为每个用户/作业服务一个时间片，不区分任务的紧急性。</p> 
<h4><a id="_203"></a>实时操作系统</h4> 
<p>实时操作系统（Real-Time Operating System，RTOS）是一种专门设计用于处理实时任务和应用程序的操作系统。实时任务是需要在严格的时间限制内完成的任务，通常涉及对外部事件的快速响应，如控制系统、航空航天系统、医疗设备、汽车控制等。RTOS旨在提供可预测性、高可靠性和低延迟的计算环境。以下是实时操作系统的主要特点和分类：</p> 
<p><strong>实时操作系统的特点：</strong></p> 
<ol><li> <p><strong>确定性：</strong> 实时操作系统必须提供确定性的任务响应时间。任务执行的时间必须可预测，以确保在指定的时间限制内完成任务。</p> </li><li> <p><strong>低延迟：</strong> 实时任务的响应时间必须非常短，通常以微秒或毫秒为单位。这要求RTOS在任务之间切换和调度时具有非常低的延迟。</p> </li><li> <p><strong>硬实时和软实时：</strong> 实时任务可以分为硬实时和软实时。硬实时任务的时间限制必须严格遵守，而软实时任务则有一定的容忍度，但仍需要快速响应。</p> </li><li> <p><strong>多任务支持：</strong> RTOS支持多任务处理，允许多个实时任务同时运行。这些任务可以拥有不同的优先级，以确保高优先级任务获得更多的CPU时间。</p> </li><li> <p><strong>中断处理：</strong> RTOS能够高效处理外部中断和事件，以及快速响应这些中断。这对于实时系统中的外部事件非常重要。</p> </li><li> <p><strong>实时调度算法：</strong> RTOS使用实时调度算法，如优先级调度、周期性调度等，以确保任务按照时间要求执行。</p> </li><li> <p><strong>资源管理：</strong> RTOS负责管理和分配系统资源，如CPU、内存、设备等，以满足实时任务的需求。</p> </li></ol> 
<p><strong>实时操作系统的分类：</strong></p> 
<ol><li><strong>硬实时操作系统（Hard Real-Time OS）：</strong> 硬实时操作系统对任务响应时间的要求非常严格，必须严格遵守预定的时间限制。它们通常用于关键性应用，如飞行控制系统和医疗设备。</li><li><strong>软实时操作系统（Soft Real-Time OS）：</strong> 软实时操作系统也要求快速响应，但对任务响应时间的容忍度更高。它们通常用于需要高度可靠性但对响应时间要求不如硬实时应用那么严格的领域，如多媒体处理。</li></ol> 
<p>实时操作系统在许多领域中发挥着关键作用，包括工业自动化、航空航天、医疗设备、汽车控制、通信设备和嵌入式系统等。它们确保了实时任务的可靠性和性能，对于确保系统的安全和可控性至关重要。</p> 
<h4><a id="_230"></a>网络操作系统</h4> 
<p>网络操作系统（Network Operating System，NOS）是一种特殊类型的操作系统，其主要功能是管理和协调计算机网络中的各种资源和服务。网络操作系统通常用于计算机网络服务器、路由器、交换机等网络设备上，以支持多个用户或设备之间的通信和数据传输。以下是关于网络操作系统的主要特点和功能：</p> 
<p><strong>网络操作系统的特点和功能：</strong></p> 
<ol><li> <p><strong>资源共享：</strong> 网络操作系统允许多个用户或设备共享网络上的资源，如文件、打印机、存储设备等。这有助于提高资源的利用率和效率。</p> </li><li> <p><strong>用户管理：</strong> NOS可以管理用户帐户和权限，确保只有授权的用户可以访问网络资源。这包括用户认证、授权和身份验证功能。</p> </li><li> <p><strong>文件和数据共享：</strong> 网络操作系统允许用户在网络上共享文件和数据。用户可以在不同设备之间传输文件，共享文档，并实现协作工作。</p> </li><li> <p><strong>打印管理：</strong> NOS支持打印服务，允许多个用户共享打印机。用户可以将打印任务发送到网络上的打印队列，然后打印服务器负责管理打印队列和控制打印作业。</p> </li><li> <p><strong>安全性：</strong> 网络操作系统提供了安全性功能，包括防火墙、访问控制列表（ACL）和加密，以保护网络免受未经授权的访问和网络攻击。</p> </li><li> <p><strong>网络管理和监控：</strong> NOS提供网络管理工具，允许管理员监控网络性能、配置设备、诊断问题和进行远程管理。</p> </li><li> <p><strong>路由和交换：</strong> 对于路由器和交换机等网络设备来说，网络操作系统是必不可少的，它们负责数据包的路由、转发和交换，以确保数据在网络中的正确传递。</p> </li><li> <p><strong>可扩展性：</strong> 网络操作系统通常具有高度可扩展性，允许根据网络规模和需求添加新的设备和服务。</p> </li><li> <p><strong>协议支持：</strong> NOS支持各种网络通信协议，如TCP/IP、UDP、HTTP、FTP等，以实现不同类型的网络应用和服务。</p> </li><li> <p><strong>故障容忍性：</strong> 网络操作系统通常具有故障容忍性，能够自动检测和处理网络中的故障，以确保网络的可靠性。</p> </li></ol> 
<p>网络操作系统在企业、教育机构、云计算数据中心、互联网服务提供商（ISP）等各种环境中广泛应用。它们为网络管理和协作提供了必要的工具和基础设施，使多用户和多设备之间的通信变得更加高效和可靠。知名的网络操作系统包括Cisco IOS、Windows Server、Linux等。</p> 
<h4><a id="_258"></a>分布式操作系统</h4> 
<p>分布式操作系统（Distributed Operating System）是一种特殊类型的操作系统，它设计用于分布式计算环境，其中多台计算机（节点）协同工作，共享资源和执行任务。分布式操作系统的主要目标是提供透明性，使分布式计算看起来像是一个单一的计算机系统，同时管理节点之间的通信、资源共享和任务调度。以下是关于分布式操作系统的主要特点和功能：</p> 
<p><strong>分布式操作系统的特点和功能：</strong></p> 
<ol><li> <p><strong>透明性：</strong> 分布式操作系统旨在提供透明性，使用户和应用程序能够访问分布式系统的资源，而不需要了解底层网络和节点的细节。这包括透明的文件共享、透明的进程通信等。</p> </li><li> <p><strong>资源共享：</strong> 分布式操作系统支持多个节点之间的资源共享，如文件系统、打印机、数据库等。用户可以从任何节点访问和共享这些资源。</p> </li><li> <p><strong>分布式文件系统：</strong> 分布式操作系统通常包括分布式文件系统，它允许用户在不同节点上存储和访问文件。这些文件系统通常具有冗余性和可伸缩性，以提高可靠性和性能。</p> </li><li> <p><strong>进程通信：</strong> 分布式操作系统支持不同节点上的进程之间的通信。这有助于协调分布式计算中的任务和数据共享。</p> </li><li> <p><strong>分布式调度和负载均衡：</strong> 分布式操作系统负责任务的调度和分配到不同的节点上，以确保负载均衡和资源的有效利用。</p> </li><li> <p><strong>容错性：</strong> 分布式操作系统通常具有容错性，可以自动检测和处理节点故障，以保持系统的可用性。</p> </li><li> <p><strong>安全性：</strong> 安全性在分布式计算中至关重要。分布式操作系统提供了安全性功能，包括身份验证、授权、加密和访问控制。</p> </li><li> <p><strong>分布式数据库管理系统：</strong> 分布式操作系统通常与分布式数据库管理系统（Distributed Database Management System）集成，以支持分布式数据存储和查询。</p> </li><li> <p><strong>远程过程调用（RPC）：</strong> 分布式操作系统使用RPC等技术来支持远程调用，使进程能够在不同节点上执行函数或方法。</p> </li><li> <p><strong>集群管理：</strong> 在大规模分布式系统中，分布式操作系统可能包括集群管理工具，用于管理节点的动态添加和移除，以及负载均衡。</p> </li></ol> 
<p>分布式操作系统在大型云计算平台、大规模数据中心、分布式系统、互联网服务和企业网络中广泛应用。它们能够提供高度的可伸缩性、可用性和性能，使分布式计算成为现代计算机领域的关键组成部分。一些知名的分布式操作系统和系统基础设施包括Google的GFS和MapReduce、Apache Hadoop和Kubernetes等。</p> 
<h4><a id="_286"></a>个人计算机操作系统</h4> 
<p>个人计算机操作系统是专门为个人计算机或桌面计算机设计的操作系统。它们旨在为个人用户提供友好的用户界面和应用程序支持，以满足一般计算和办公需求。以下是关于个人计算机操作系统的主要特点和功能：</p> 
<p><strong>个人计算机操作系统的特点和功能：</strong></p> 
<ol><li> <p><strong>图形用户界面（GUI）：</strong> 个人计算机操作系统通常提供图形用户界面，使用户能够使用鼠标、键盘和图形元素与计算机进行交互。这使得计算机更加易于使用。</p> </li><li> <p><strong>多任务支持：</strong> 个人计算机操作系统允许用户同时运行多个程序或任务。用户可以轻松切换和管理多个应用程序。</p> </li><li> <p><strong>文件系统：</strong> 操作系统提供了文件系统，允许用户创建、保存、管理和共享文件。这包括文件夹和文件的管理，以及对不同文件类型的支持。</p> </li><li> <p><strong>网络连接：</strong> 个人计算机操作系统具备网络连接功能，允许用户访问互联网、发送电子邮件、浏览网页和进行在线通信。</p> </li><li> <p><strong>硬件支持：</strong> 操作系统管理计算机的硬件资源，包括中央处理器（CPU）、内存、磁盘存储、显示器、打印机等。</p> </li><li> <p><strong>驱动程序：</strong> 操作系统需要支持各种硬件设备，因此它们使用驱动程序来与硬件设备进行通信。操作系统通常包含了各种设备的标准驱动程序，而用户也可以安装其他硬件的特定驱动程序。</p> </li><li> <p><strong>虚拟内存：</strong> 为了提高内存管理效率，个人计算机操作系统通常支持虚拟内存技术，将部分数据从RAM存储到磁盘上，以便扩展可用内存。</p> </li><li> <p><strong>安全性：</strong> 操作系统包括安全功能，如用户帐户管理、访问控制、防火墙等，以保护计算机和用户数据的安全。</p> </li><li> <p><strong>软件兼容性：</strong> 个人计算机操作系统通常具有广泛的应用程序兼容性，用户可以运行各种第三方应用程序，如办公套件、媒体播放器、浏览器等。</p> </li><li> <p><strong>更新和维护：</strong> 操作系统定期发布更新和补丁，以修复漏洞、提供新功能和提高性能。用户需要定期更新操作系统以保持安全性和可用性。</p> </li></ol> 
<p>知名的个人计算机操作系统包括：</p> 
<ul><li> <p><strong>Microsoft Windows：</strong> Windows系列操作系统是最广泛使用的个人计算机操作系统之一，包括Windows 10和Windows 11。</p> </li><li> <p><strong>Apple macOS：</strong> macOS是苹果公司的桌面操作系统，运行在Macintosh计算机上。</p> </li><li> <p><strong>Linux发行版：</strong> Linux操作系统以开源的形式提供，有许多不同的发行版，如Ubuntu、Fedora、Debian等，适用于不同类型的计算机。</p> </li><li> <p><strong>Chrome OS：</strong> Chrome OS是Google开发的操作系统，设计用于Chromebook等轻便计算机。</p> </li></ul> 
<p>这些个人计算机操作系统各自具有独特的特点和优势，可以根据用户的需求和偏好进行选择。它们都旨在提供强大的计算能力和用户友好的界面，以满足个人和办公室计算的需求。</p> 
<h3><a id="_324"></a>运行机制</h3> 
<h4><a id="_326"></a>程序是如何运行的？</h4> 
<p>程序是计算机执行任务的一系列指令的集合，它们按照特定的顺序执行以完成特定的工作。计算机程序的运行通常经过以下步骤：</p> 
<ol><li> <p><strong>编写程序：</strong> 首先，程序员使用编程语言（如C++、Python、Java等）编写程序。程序员根据任务的要求，以特定的语法和结构编写代码，这些代码描述了程序应该如何执行任务。</p> </li><li> <p><strong>编译或解释：</strong> 一旦程序编写完成，它需要被编译或解释成计算机能够理解的机器语言或中间代码。这一步取决于编程语言的类型。</p> 
  <ul><li> <p><strong>编译型语言：</strong> 如果程序是用编译型语言编写的，如C++或Java，那么编译器将源代码转换成可执行文件。这个可执行文件包含了计算机可以直接执行的机器代码。编译后的程序在运行之前不需要再次编译。</p> </li><li> <p><strong>解释型语言：</strong> 如果程序是用解释型语言编写的，如Python或JavaScript，那么需要一个解释器来逐行解释和执行源代码。这意味着程序每次运行时都要重新解释，而不会生成独立的可执行文件。</p> </li></ul> </li><li> <p><strong>加载程序：</strong> 一旦程序被编译或解释，计算机操作系统将加载程序到内存中，准备执行。</p> </li><li> <p><strong>执行程序：</strong> 程序被加载到内存后，计算机的中央处理器（CPU）开始执行程序的指令。CPU会按照程序中的指令和控制流程执行相应的操作。这包括数学运算、逻辑判断、条件分支、循环等。</p> </li><li> <p><strong>处理输入和输出：</strong> 程序通常需要与外部环境交互。它可以接收输入数据，对其进行处理，并产生输出结果。输入可以来自键盘、鼠标、文件、传感器或网络，而输出可以是显示在屏幕上的信息、保存到文件中的数据、通过网络发送的信息等。</p> </li><li> <p><strong>处理错误和异常：</strong> 在程序运行期间，可能会发生错误或异常情况。程序通常包括错误处理代码，以便捕获和处理这些错误，确保程序能够继续执行或以有序的方式终止。</p> </li><li> <p><strong>结束执行：</strong> 一旦程序完成了它的任务或达到了终止条件，它会结束执行。操作系统会释放程序占用的内存和资源。</p> </li></ol> 
<p>程序的运行是计算机硬件和软件的协同工作，它们遵循程序中指定的指令和控制流程，执行特定的任务，并生成相应的结果。不同的编程语言和应用场景可能导致程序运行的细节有所不同，但上述步骤是程序运行的通用流程。</p> 
<h4><a id="_350"></a>内核程序</h4> 
<p>操作系统内核是操作系统的核心部分，负责管理和控制计算机硬件资源，提供基本的服务和功能，以支持应用程序的运行。内核程序通常是操作系统的最底层组件，直接运行在计算机硬件上，负责协调和控制其他系统组件的活动。以下是内核程序的主要职责和功能：</p> 
<ol><li> <p><strong>进程管理：</strong> 内核负责管理计算机上运行的进程。它分配CPU时间片、调度进程的执行顺序、创建和销毁进程，以及控制进程之间的通信和同步。</p> </li><li> <p><strong>内存管理：</strong> 内核管理计算机的物理内存和虚拟内存，包括内存分配、释放、分页、虚拟内存映射等。它确保各个进程拥有适当的内存资源，以及有效地使用和保护内存。</p> </li><li> <p><strong>文件系统管理：</strong> 内核管理计算机上的文件系统，包括文件的创建、读取、写入、删除等操作。它还负责文件和目录的权限控制和文件的组织结构。</p> </li><li> <p><strong>设备驱动程序管理：</strong> 内核包括设备驱动程序，用于管理和控制计算机上的硬件设备，如磁盘驱动程序、网络驱动程序、图形驱动程序等。这使得应用程序可以与硬件设备进行通信。</p> </li><li> <p><strong>中断处理：</strong> 内核负责处理来自硬件设备和其他源的中断，以响应外部事件，如键盘输入、鼠标移动、网络数据包等。中断处理程序使内核可以快速响应这些事件。</p> </li><li> <p><strong>系统调用接口：</strong> 内核提供系统调用接口，允许应用程序与操作系统交互。通过系统调用，应用程序可以请求内核执行特定任务，如文件读取、进程创建等。</p> </li><li> <p><strong>安全性和访问控制：</strong> 内核负责计算机系统的安全性，包括用户身份验证、访问控制、防火墙和安全策略的执行。它确保只有授权用户和进程可以访问受保护的资源。</p> </li><li> <p><strong>网络协议栈：</strong> 在支持网络通信的操作系统中，内核通常包括网络协议栈，用于处理网络数据包的传输、路由和通信。</p> </li><li> <p><strong>时钟和时间管理：</strong> 内核维护计算机的系统时钟，并提供时间相关的功能，如时间戳记录、定时器和调度。</p> </li><li> <p><strong>错误处理和容错性：</strong> 内核包括错误处理和容错机制，以处理异常和错误情况，以确保系统的稳定性和可用性。</p> </li></ol> 
<p>内核程序是操作系统的核心，通常是一个高度优化和高度复杂的软件组件。它提供了一个抽象层，允许应用程序与硬件交互，而不需要了解底层硬件的细节。不同类型的操作系统（如Windows、Linux、macOS等）具有不同的内核实现，但它们都共享类似的内核功能和职责。</p> 
<h4><a id="_376"></a>应用程序</h4> 
<p>简单来说，普通程序员写的程序就是应用程序。它是位于操作系统层面之上的应用。</p> 
<p>应用程序（Application，简称App）是一种计算机软件，旨在执行特定任务、解决特定问题或提供特定服务，以满足用户的需求。应用程序是用户与计算机系统交互的主要方式，它们提供了各种功能，从办公工具、娱乐媒体到生产力应用和游戏等。以下是有关应用程序的主要特点和功能：</p> 
<p><strong>应用程序的特点和功能：</strong></p> 
<ol><li> <p><strong>任务特定：</strong> 每个应用程序都有一个特定的任务或功能。例如，文字处理应用程序用于创建和编辑文档，浏览器应用程序用于浏览互联网，游戏应用程序用于娱乐等。</p> </li><li> <p><strong>用户界面：</strong> 应用程序通常具有用户友好的界面，使用户能够轻松地与应用程序交互。这包括图形用户界面（GUI）和命令行界面（CLI）等。</p> </li><li> <p><strong>独立性：</strong> 应用程序通常是独立的软件实体，可以单独安装、启动和运行，而不依赖于其他应用程序。</p> </li><li> <p><strong>可定制性：</strong> 许多应用程序允许用户自定义设置和选项，以满足他们的需求和喜好。</p> </li><li> <p><strong>多平台支持：</strong> 许多应用程序可以在不同的操作系统上运行，例如Windows、macOS、Linux、iOS和Android等。</p> </li><li> <p><strong>数据处理：</strong> 应用程序通常用于处理数据，包括输入、存储、操作和输出数据。这可以包括文本、图像、音频、视频和其他多媒体内容。</p> </li><li> <p><strong>通信和互联网：</strong> 许多应用程序支持网络通信，允许用户访问远程服务器、发送和接收数据，以及在线协作。</p> </li><li> <p><strong>生命周期管理：</strong> 应用程序有自己的生命周期，包括启动、执行任务、响应用户输入、保存数据、关闭和终止等阶段。</p> </li><li> <p><strong>安全性：</strong> 应用程序通常需要考虑安全性问题，以保护用户数据和系统免受恶意软件和攻击的威胁。</p> </li><li> <p><strong>更新和维护：</strong> 开发者通常会定期发布应用程序的更新和修复，以改进性能、修复漏洞和添加新功能。</p> </li><li> <p><strong>多任务支持：</strong> 许多操作系统支持多任务处理，允许用户同时运行多个应用程序，并在它们之间切换。</p> </li><li> <p><strong>娱乐和游戏：</strong> 应用程序也可以是娱乐性质的，如视频播放器、音乐播放器和电子游戏等。</p> </li></ol> 
<p>应用程序的种类非常多样化，它们可以用于各种不同的领域和用途。例如，办公套件应用程序用于文档处理和电子表格制作，社交媒体应用程序用于社交互动，地图导航应用程序用于导航和位置服务等。</p> 
<h4><a id="_410"></a>特权指令</h4> 
<p>特权指令（Privileged Instruction）是一种只有在操作系统内核或其他特权级别执行时才能执行的计算机指令。这些指令具有高特权级别，通常只有操作系统内核才能执行它们，而用户级别的应用程序无法直接执行特权指令。特权指令的存在是为了保护计算机系统的安全性和稳定性，以防止不受信任的应用程序干扰或损坏关键的系统资源。</p> 
<p>以下是一些常见的特权指令和其作用：</p> 
<ol><li> <p><strong>设置特权级别：</strong> 一些特权指令用于在不同的特权级别之间切换。例如，x86架构的处理器使用特权指令来切换从用户模式（用户级别）到内核模式（特权级别）。</p> </li><li> <p><strong>访问受限资源：</strong> 特权指令用于访问受限的系统资源，如访问硬件设备、修改系统寄存器、执行输入/输出操作等。</p> </li><li> <p><strong>内存保护：</strong> 特权指令用于配置和管理内存保护机制，如页表、段描述符表，以确保不同进程的内存空间得以隔离和保护。</p> </li><li> <p><strong>中断和异常处理：</strong> 特权指令用于启用和禁用中断、设置中断处理程序、响应异常事件等。这有助于内核管理系统的安全性和稳定性。</p> </li><li> <p><strong>更改特权级别：</strong> 一些特权指令允许内核将执行权从当前特权级别切换到更高或更低的特权级别。这对于执行敏感操作或进一步限制应用程序的权限非常重要。</p> </li><li> <p><strong>访问特殊寄存器：</strong> 特权指令用于访问特殊的控制寄存器和状态寄存器，以配置和管理处理器的行为。</p> </li></ol> 
<p>特权指令的使用通常受到硬件和操作系统的控制，只有操作系统内核或特权级别较高的代码才能执行这些指令。这种机制有助于确保计算机系统的安全性和稳定性，防止不受信任的应用程序对系统造成危害。一旦用户级别的应用程序尝试执行特权指令，处理器会引发异常，操作系统将处理异常并采取适当的措施，如终止应用程序或采取其他安全措施。这有助于维护系统的完整性和可用性。</p> 
<h4><a id="_430"></a>非特权指令</h4> 
<p>非特权指令（Non-privileged Instruction）是一种可以由操作系统内核和用户级别的应用程序执行的计算机指令。与特权指令不同，非特权指令在计算机系统的特权级别下执行，通常不会对系统的核心资源和安全性产生直接影响。非特权指令用于执行一般的计算任务、数据处理、控制流程等，而不需要操作系统的干预或特殊权限。</p> 
<p>以下是一些常见的非特权指令和其作用：</p> 
<ol><li> <p><strong>算术和逻辑操作：</strong> 非特权指令包括用于执行加法、减法、乘法、除法、位运算、逻辑运算等各种算术和逻辑操作的指令。这些指令用于进行数据处理和计算。</p> </li><li> <p><strong>数据传输：</strong> 非特权指令可用于将数据从一个位置传输到另一个位置，如加载数据到寄存器、存储数据到内存、从内存读取数据等。</p> </li><li> <p><strong>分支和跳转：</strong> 分支和跳转指令用于控制程序的流程，根据条件执行不同的代码路径。这包括条件分支、无条件分支和子程序调用指令。</p> </li><li> <p><strong>堆栈操作：</strong> 非特权指令允许应用程序操作堆栈，包括将数据推入堆栈、弹出数据、保存和恢复寄存器状态等。</p> </li><li> <p><strong>数据加载和存储：</strong> 应用程序可以使用非特权指令来访问和操作内存中的数据，包括加载、存储、复制、移动和填充数据。</p> </li><li> <p><strong>浮点运算：</strong> 针对浮点数的运算和计算，如浮点加法、减法、乘法和除法等，通常需要使用非特权指令。</p> </li><li> <p><strong>字符串操作：</strong> 非特权指令可用于执行字符串操作，如字符串复制、比较、拼接等。</p> </li><li> <p><strong>输入/输出：</strong> 应用程序可以使用非特权指令进行输入和输出操作，与外部设备、文件和网络通信等。</p> </li><li> <p><strong>系统调用：</strong> 要执行需要操作系统干预的任务，应用程序通常需要通过系统调用接口来请求操作系统执行特权级别的操作。这些接口允许应用程序与操作系统进行通信，以访问系统资源和服务。</p> </li></ol> 
<p>非特权指令是用于执行一般计算和控制任务的指令，它们通常在用户级别运行，不需要访问或修改操作系统的核心资源。这些指令使应用程序能够执行各种计算和数据处理任务，而不必担心系统的特权级别或安全性问题。操作系统和硬件通常负责执行和管理特权指令，以保护系统的稳定性和安全性。</p> 
<h4><a id="_456"></a>内核态</h4> 
<p>内核态（Kernel Mode），也被称为特权模式、系统态或监管模式(别名：<strong>管态</strong>)，是操作系统内核运行的一种特殊执行模式或特权级别。在内核态下，操作系统内核拥有最高的权限和访问计算机系统硬件资源的权力，可以执行特权指令和直接访问系统资源，如中央处理器（CPU）、内存、设备和输入/输出端口。内核态允许操作系统执行核心功能，如进程管理、内存管理、文件系统操作、设备控制等。</p> 
<p>以下是内核态的主要特点和功能：</p> 
<ol><li> <p><strong>最高权限：</strong> 内核态具有最高的特权级别，拥有对计算机系统所有资源的完全控制权。这意味着内核可以执行特权指令，修改系统寄存器和访问受限资源。</p> </li><li> <p><strong>系统服务：</strong> 操作系统内核运行在内核态下，负责提供系统级服务和功能，如进程调度、内存分配、文件管理、设备控制、中断处理等。</p> </li><li> <p><strong>硬件访问：</strong> 内核可以直接访问硬件资源，如处理器寄存器、内存地址空间、外部设备等。这允许内核执行关键的系统操作，如切换上下文、配置内存分页、设置中断处理程序等。</p> </li><li> <p><strong>特权指令：</strong> 内核态允许执行特权指令，这些指令通常是用户态不允许执行的。特权指令用于管理系统的底层操作，如更改处理器状态、设置特权级别等。</p> </li><li> <p><strong>中断处理：</strong> 内核态可以响应硬件和软件产生的中断和异常。它负责处理中断事件，包括时钟中断、输入/输出中断、硬件故障和系统调用等。</p> </li><li> <p><strong>资源保护：</strong> 内核态负责保护系统资源免受不受信任的用户级别应用程序的恶意访问和修改。它实施了访问控制和权限管理。</p> </li><li> <p><strong>内核模块：</strong> 操作系统内核通常由多个模块组成，每个模块负责不同的系统功能。这些内核模块运行在内核态下，相互协同工作以管理和控制计算机系统。</p> </li><li> <p><strong>安全性和稳定性：</strong> 内核态的严格控制和权限管理有助于维护计算机系统的安全性和稳定性。它可以避免用户级别应用程序对系统资源的滥用或破坏。</p> </li></ol> 
<p>内核态与用户态（User Mode）相对立，用户态是应用程序运行的一种执行模式，拥有较低的权限和受限的访问系统资源能力。操作系统内核通过特权级别切换机制，允许在内核态和用户态之间切换，以确保操作系统内核可以执行特权操作，而应用程序不能直接干扰或破坏系统的核心功能。这种分层和特权级别的设计有助于保持计算机系统的稳定性和安全性。</p> 
<h4><a id="_480"></a>用户态</h4> 
<p>用户态（User Mode）是计算机操作系统中的一种执行模式或特权级别(别名：<strong>目态</strong>)。在用户态下，应用程序运行，并且它们的权限受到限制，不能直接访问或修改计算机系统的核心资源。用户态下的应用程序通常没有执行特权指令或直接访问硬件资源的权限。用户态是操作系统设计中的一种保护机制，旨在防止应用程序对系统的滥用或不当访问核心资源。</p> 
<p>以下是用户态的主要特点和功能：</p> 
<ol><li> <p><strong>受限权限：</strong> 用户态下的应用程序拥有较低的权限，只能执行非特权指令。这些指令通常用于执行一般计算任务、数据处理和控制流程。</p> </li><li> <p><strong>无法直接访问硬件：</strong> 用户态应用程序不能直接访问计算机系统的核心硬件资源，如处理器寄存器、物理内存、设备接口等。它们必须通过操作系统提供的接口来请求系统资源的访问。</p> </li><li> <p><strong>系统服务请求：</strong> 用户态应用程序可以通过系统调用接口请求操作系统提供服务和功能。系统调用允许应用程序访问受限资源，如文件系统、网络通信、设备驱动程序等。</p> </li><li> <p><strong>中断响应：</strong> 用户态应用程序可以响应硬件中断和异常，例如用户可以编写代码来处理键盘输入、鼠标事件、网络数据等。但这些中断的处理通常受限于用户态的权限。</p> </li><li> <p><strong>资源隔离：</strong> 用户态应用程序在执行期间被隔离，彼此不会直接干扰或访问对方的内存空间。这有助于维护应用程序的独立性和安全性。</p> </li><li> <p><strong>安全性和稳定性：</strong> 用户态的受限权限和资源访问机制有助于提高计算机系统的安全性和稳定性。它可以防止应用程序对系统资源的滥用，从而减少系统崩溃或不稳定的风险。</p> </li></ol> 
<p>用户态与内核态（Kernel Mode）相对立，内核态是操作系统内核运行的特权级别，拥有最高的权限和访问核心资源的权力。操作系统内核通过特权级别切换机制，允许在用户态和内核态之间切换，以确保操作系统内核可以执行特权操作，而应用程序不能直接破坏或滥用系统的核心功能。用户态和内核态的分层设计是现代操作系统的基本原则之一，有助于保持计算机系统的安全性、稳定性和可靠性。</p> 
<h4><a id="_500"></a>内核态与用户态的切换</h4> 
<p>内核态和用户态的切换是指计算机操作系统中的特权级别切换过程，允许在不同特权级别下执行代码。这种切换是为了确保操作系统内核拥有最高的权限，可以管理和保护系统资源，同时允许用户级别的应用程序在受限环境中运行，以提高系统的安全性和稳定性。</p> 
<p><strong>内核态 =&gt; 用户态</strong>：执行一条特权指令修改PSW(CPU中有一个寄存器叫程序状态字寄存器：PSW，其中有个二进制位，1表示“内核态”。0表示“用户态”)的标志位为“用户态”，意味着操作系统主动让出CPU使用权。</p> 
<p><strong>用户态 =&gt; 内核态</strong>：由“中断”引发，硬件自动完成“变态”过程，触发中断信号(如，非法使用特权指令等)意味着操作系统将强行夺回CPU的使用权。</p> 
<p>以下是内核态和用户态切换的一般过程：</p> 
<ol><li> <p><strong>用户态执行：</strong> 当计算机启动时，操作系统内核首先加载到内存中，并以内核态开始执行。然后，操作系统会创建一个或多个用户级别的应用程序进程，并将控制权交给第一个用户态应用程序，该应用程序开始执行。</p> </li><li> <p><strong>系统调用或异常触发：</strong> 在用户态执行的应用程序需要访问受限资源或执行特权操作时，它需要请求操作系统的帮助。这通常通过系统调用（system call）或异常（exception）触发内核态切换。</p> 
  <ul><li> <p><strong>系统调用：</strong> 应用程序通过调用操作系统提供的系统调用接口来请求服务和资源，如文件操作、网络通信、设备访问等。系统调用是用户态到内核态的一种主要切换方式。</p> </li><li> <p><strong>异常：</strong> 异常是在应用程序执行期间发生的事件，可以是硬件引发的，如除零错误、访问非法内存等，也可以是软件引发的，如页面错误（page fault）。异常的处理通常需要内核态干预。</p> </li></ul> </li><li> <p><strong>切换到内核态：</strong> 当系统调用或异常发生时，处理器会自动触发特权级别切换，将控制权从用户态切换到内核态。这通常涉及以下步骤：</p> <p>a. 保存用户态的上下文信息：处理器会保存当前用户态进程的寄存器状态、程序计数器值等信息，以便稍后恢复应用程序的执行状态。</p> <p>b. 加载内核态的上下文信息：处理器会加载操作系统内核的上下文信息，包括内核的代码和数据结构，以便内核能够执行所需的操作。</p> <p>c. 执行内核代码：处理器开始执行操作系统内核的代码，以响应系统调用或异常。内核会执行必要的操作，如处理系统调用请求、处理异常事件、分配资源等。</p> </li><li> <p><strong>执行内核态代码：</strong> 在内核态执行期间，操作系统内核可以执行必要的操作，包括访问硬件资源、修改系统状态、响应中断等。内核会处理系统调用请求，然后根据请求执行相应的操作。</p> </li><li> <p><strong>切换回用户态：</strong> 一旦操作系统内核完成了必要的操作，它将恢复用户态进程的上下文信息，包括寄存器状态和程序计数器值。然后，处理器将控制权从内核态切换回用户态，应用程序继续执行，仿佛没有发生过切换。</p> </li></ol> 
<p>内核态和用户态之间的切换是操作系统的核心机制之一，有助于维护系统的安全性、稳定性和多任务处理能力。这种切换允许操作系统内核拥有最高的权限，同时使用户级别的应用程序在受限环境中执行，从而提高系统的整体可靠性和安全性。</p> 
<h4><a id="_532"></a>中断类型</h4> 
<p>中断（Interrupt）是一种用于中断正在执行的程序并请求处理器执行特定任务的机制。中断可以分为两种主要类型：内中断（内部中断）和外中断（外部中断）。</p> 
<h5><a id="_536"></a>内中断(异常)</h5> 
<p>与当前执行的指令有关，中断信号来源于CPU内部。</p> 
<ul><li><strong>源头：</strong> 内中断是由处理器内部或与处理器直接相关的硬件引发的中断。这些中断源通常与处理器的状态或操作有关，如除零错误、溢出、非法操作码等。</li><li><strong>触发方式：</strong> 内中断的触发是由处理器的执行状态决定的，当特定条件满足时，处理器会生成内中断。这些条件通常是由程序执行引起的，例如，尝试执行不支持的指令、计算结果溢出(如，除数为0)、访问非法内存地址等。</li><li><strong>示例：</strong> 非法操作码中断、溢出中断、页错误中断等都是内中断的示例。</li></ul> 
<p>常见引起内中断的层次：</p> 
<ol><li>陷入、陷阱：有陷入指令引发，是应用程序故意引发的。</li><li>故障：由错误条件引起的，可能被内核程序修复。内核程序修复故障后会把CPU使用权还给应用程序。例如，缺页故障。</li><li>终止：由致命错误引起，内核程序无法修复该错误，因此一般不再将CPU的使用权还给引发终止的应用程序，而是直接终止该应用程序。例如，整数除0、非法使用特权指令。</li></ol> 
<h5><a id="_550"></a>外中断</h5> 
<p>与当前执行的指令无关，中断信号来源于CPU外部。</p> 
<ul><li><strong>源头：</strong> 外中断是由处理器外部的硬件设备或外部事件引发的中断。这些中断源包括键盘输入、鼠标事件、定时器、网络数据、外部设备请求等。</li><li><strong>触发方式：</strong> 外中断的触发是由外部硬件设备或事件的状态变化引起的。当外部事件需要处理器的注意时，相应的硬件会生成外中断请求信号。</li><li><strong>示例：</strong> 定时中断、键盘中断、鼠标中断、串口通信中断等都是外中断的示例。</li></ul> 
<h4><a id="_558"></a>中断机制的基本原理</h4> 
<p>中断机制是计算机操作系统用于处理中断事件的基本原理之一。中断是一种硬件或软件生成的信号，通知处理器需要对特定事件或条件进行处理。</p> 
<p><img src="https://images2.imgbox.com/53/85/wSLKUYuO_o.png" alt="image-20231002090033364"></p> 
<p>中断机制的基本原理如下：</p> 
<ol><li> <p><strong>中断请求（Interrupt Request）：</strong> 外部设备、硬件组件或软件事件生成中断请求。这些请求可以是硬件中断（如键盘输入、定时器计时完成、外部设备请求等）或软件中断（如系统调用请求、异常事件等）。</p> </li><li> <p><strong>触发中断：</strong> 当中断请求发生时，相应的硬件电路或事件处理程序将触发中断，向处理器发送中断请求信号。</p> </li><li> <p><strong>中断处理程序寻址：</strong> 处理器会检查中断请求并确定中断的类型和优先级。然后，处理器根据中断类型选择相应的中断处理程序或中断向量。中断向量是一个指向中断处理程序的地址。</p> </li><li> <p><strong>中断处理程序执行：</strong> 处理器会跳转到中断处理程序的地址，并开始执行该程序。中断处理程序是一段特殊的代码，用于处理与中断相关的任务。</p> </li><li> <p><strong>保存当前上下文：</strong> 在执行中断处理程序之前，处理器通常会保存当前进程或任务的上下文信息，包括寄存器状态、程序计数器值、栈指针等。这是为了确保在中断处理完成后，能够恢复到原始状态并继续执行当前任务。</p> </li><li> <p><strong>执行中断处理程序：</strong> 中断处理程序执行与中断事件相关的操作。这可以包括处理输入设备的数据、响应网络数据包、执行系统调用、处理异常等。中断处理程序通常具有高优先级，并且会在最短时间内完成，以减少对系统性能的干扰。</p> </li><li> <p><strong>恢复上下文：</strong> 在中断处理程序完成后，处理器将恢复先前保存的上下文信息，包括寄存器状态和程序计数器值。这样，处理器可以继续执行原始任务。</p> </li><li> <p><strong>返回到原始任务：</strong> 处理器将控制权返回给原始任务，该任务继续执行，仿佛没有发生中断一样。</p> </li></ol> 
<p>中断机制的关键原理是在中断事件发生时，处理器能够迅速切换到适当的中断处理程序，执行相关任务，并在完成后返回到原始任务，而不会丢失任何重要信息。这使得计算机系统能够响应外部事件、设备输入和异常情况，同时保持多任务处理、系统稳定性和性能。中断机制是现代操作系统的核心组成部分，为计算机系统提供了灵活性和可靠性。</p> 
<h4><a id="_584"></a>系统调用</h4> 
<p>系统调用（System Call）是操作系统提供给用户空间应用程序的编程接口，允许应用程序请求执行操作系统内核提供的服务和功能。系统调用充当了用户空间应用程序与内核之间的接口，使应用程序能够访问受限资源、执行特权操作以及与硬件设备进行通信。</p> 
<h5><a id="_588"></a>与库函数的区别</h5> 
<p>系统调用和库函数都是用于与操作系统交互和执行特定任务的编程接口，但它们之间存在重要区别：</p> 
<ol><li> <p><strong>层次：</strong></p> 
  <ul><li><strong>系统调用：</strong> 系统调用是应用程序直接与操作系统内核进行通信的接口。它们提供了对底层操作系统功能的直接访问，例如文件操作、进程管理、网络通信等。系统调用是操作系统提供的原生接口，必须通过内核执行。</li><li><strong>库函数：</strong> 库函数是由编程语言提供的函数库，它们位于用户空间，通常在标准库中。库函数是通过调用系统调用来实现特定任务的高级封装。它们是应用程序开发人员编写的函数，用于简化特定任务的编程，不涉及直接的内核交互。</li></ul> </li><li> <p><strong>执行速度：</strong></p> 
  <ul><li><strong>系统调用：</strong> 由于系统调用需要从用户态切换到内核态，并执行内核代码，所以通常比库函数慢。这是因为它涉及到上下文切换和权限的改变。</li><li><strong>库函数：</strong> 库函数通常在用户态执行，因此速度更快，因为它们无需进行特权级别切换。</li></ul> </li><li> <p><strong>访问权限：</strong></p> 
  <ul><li><strong>系统调用：</strong> 系统调用提供了对系统资源的底层访问，受到操作系统的权限和安全性限制。应用程序必须通过系统调用获得对受保护资源的访问权限。</li><li><strong>库函数：</strong> 库函数可以在应用程序内部执行，因此它们的权限受到应用程序本身的限制。这意味着库函数无法绕过应用程序的权限，也无法访问用程序无权访问的资源。</li></ul> </li><li> <p><strong>功能和抽象级别：</strong></p> 
  <ul><li><strong>系统调用：</strong> 系统调用提供了对操作系统功能的低级别访问，通常直接映射到硬件和内核功能。它们通常更强大，但使用起来更复杂。</li><li><strong>库函数：</strong> 库函数通常提供更高级别的抽象，以简化特定任务的执行。它们隐藏了底层的细节，使应用程序开发更容易。</li></ul> </li><li> <p><strong>跨平台性：</strong></p> 
  <ul><li><strong>系统调用：</strong> 系统调用的接口在不同操作系统之间可能会有显著差异，因此需要根据目标操作系统进行适当的调整和编码。</li><li><strong>库函数：</strong> 库函数通常更具可移植性，因为它们是编程语言提供的标准库，可以在不同操作系统上使用相同的函数名称和接口。</li></ul> </li></ol> 
<p>系统调用和库函数都有其用途。系统调用用于需要直接操作系统资源的任务，而库函数用于提供更高级别的功能和抽象，以简化应用程序开发。选择使用哪种方法通常取决于任务的性质和性能需求。<strong>系统调用是比高级语言的库函数更为底层的接口</strong>。</p> 
<h5><a id="_614"></a>按功能分类</h5> 
<p>操作系统的系统调用可以按功能分类为设备管理、文件管理、进程控制、进程通信、和内存管理。</p> 
<p>以下是这五个分类的简要介绍：</p> 
<ol><li> <p><strong>设备管理：</strong></p> 
  <ul><li><strong>系统调用示例：</strong> <code>open()</code>, <code>close()</code>, <code>read()</code>, <code>write()</code>, <code>ioctl()</code></li><li><strong>功能描述：</strong> 设备管理系统调用允许应用程序与计算机系统中的硬件设备进行交互。这包括打开和关闭设备文件、从设备读取数据、向设备写入数据以及进行设备控制。设备可以是磁盘驱动器、打印机、网络接口、键盘、鼠标等。</li></ul> </li><li> <p><strong>文件管理：</strong></p> 
  <ul><li><strong>系统调用示例：</strong> <code>open()</code>, <code>close()</code>, <code>read()</code>, <code>write()</code>, <code>seek()</code>, <code>stat()</code>, <code>mkdir()</code>, <code>rmdir()</code>, <code>unlink()</code>, <code>rename()</code></li><li><strong>功能描述：</strong> 文件管理系统调用用于创建、打开、关闭、读取、写入、移动和删除文件，以及管理文件和目录的属性。文件管理允许应用程序在文件系统中进行数据存储和检索。</li></ul> </li><li> <p><strong>进程控制：</strong></p> 
  <ul><li><strong>系统调用示例：</strong> <code>fork()</code>, <code>exec()</code>, <code>wait()</code>, <code>exit()</code>, <code>kill()</code>, <code>getpid()</code>, <code>getppid()</code></li><li><strong>功能描述：</strong> 进程控制系统调用允许应用程序创建和管理进程。这包括创建新进程、替换当前进程的映像、等待子进程完成、终止进程、向进程发送信号等。</li></ul> </li><li> <p><strong>进程通信：</strong></p> 
  <ul><li><strong>系统调用示例：</strong> <code>pipe()</code>, <code>shmget()</code>, <code>msgget()</code>, <code>semget()</code>, <code>sendmsg()</code>, <code>recvmsg()</code>, <code>semop()</code></li><li><strong>功能描述：</strong> 进程通信系统调用用于在不同进程之间实现通信和协作。这包括使用管道、共享内存、消息队列和信号量来传递数据和同步进程。</li></ul> </li><li> <p><strong>内存管理：</strong></p> 
  <ul><li><strong>系统调用示例：</strong> <code>malloc()</code>, <code>free()</code>, <code>mmap()</code>, <code>munmap()</code>, <code>mprotect()</code>, <code>brk()</code>, <code>sbrk()</code></li><li><strong>功能描述：</strong> 内存管理系统调用允许应用程序管理内存分配和释放、映射文件到内存、设置内存保护权限等。这有助于应用程序有效地使用系统内存。</li></ul> </li></ol> 
<p>这五个系统调用功能分类是操作系统提供给应用程序的关键接口，允许应用程序执行各种任务，如与硬件设备交互、文件操作、进程管理、进程通信和内存管理。通过使用这些系统调用，应用程序能够与操作系统内核协同工作，访问系统资源和功能，从而实现各种应用程序需求。不同操作系统可能有不同的系统调用接口，但它们通常提供了相似的功能。</p> 
<h5><a id="_642"></a>过程</h5> 
<p>系统调用是应用程序与操作系统内核进行通信的关键方式，它允许应用程序请求操作系统提供的服务和功能。系统调用的过程包括下面的步骤：</p> 
<ol><li> <p><strong>应用程序发出系统调用请求：</strong> 应用程序通过编程语言提供的系统调用接口来请求特定的操作系统服务。这通常涉及到调用相应的系统调用函数，如<code>open()</code>、<code>read()</code>、<code>write()</code>等。应用程序将请求的参数传递给系统调用函数。</p> </li><li> <p><strong>切换到内核态：</strong> 应用程序运行在用户态（用户模式），而操作系统内核运行在内核态（特权模式）。为了执行系统调用，应用程序需要切换到内核态，这通常是通过执行一个特殊的指令或中断来实现的。这个切换将把控制权从应用程序转移到操作系统内核。</p> </li><li> <p><strong>系统调用参数传递：</strong> 一旦应用程序进入内核态，操作系统内核会检查应用程序的请求并读取传递的参数。这些参数指定了请求的操作和相关的数据，如文件描述符、数据缓冲区的地址等。</p> </li><li> <p><strong>执行系统调用：</strong> 操作系统内核根据系统调用号和参数来执行相应的系统调用服务。系统调用服务可能包括文件操作、进程管理、内存分配等各种任务。内核执行这些任务，然后准备返回结果。</p> </li><li> <p><strong>返回结果给应用程序：</strong> 一旦系统调用服务执行完毕，操作系统内核会将结果返回给应用程序。如果请求是成功的，返回值通常是非负数；如果出现错误，返回值通常是负数，并且可以通过特定的错误代码来识别错误的原因。</p> </li><li> <p><strong>切换回用户态：</strong> 一旦结果被返回给应用程序，操作系统内核会将应用程序重新切换回用户态。这将恢复应用程序的控制权，使其可以继续执行。</p> </li></ol> 
<p>系统调用的过程涉及从用户态到内核态的切换，以及参数传递、系统调用执行和结果返回等步骤。这个切换和系统调用的执行是计算机操作系统中非常重要的部分，因为它允许应用程序访问受保护的操作系统资源和功能，同时确保了系统的稳定性和安全性。不同的操作系统和体系结构可能会有略微不同的系统调用实现细节，但通常都遵循类似的基本原理。</p> 
<h3><a id="_660"></a>体系结构</h3> 
<p>操作系统的体系结构指的是操作系统内部组织和构建的方式，以及操作系统模块之间的层次结构和交互方式。一般分为这四种：<strong>大内核</strong>(宏内核/单内核)、<strong>微内核</strong>、分层结构、模块化、外核。</p> 
<h4><a id="_vs__664"></a>大内核 vs 微内核</h4> 
<p>内核是操作系统最基本、最核心的部分。实现操作系统内核功能的程序即为内核程序。</p> 
<p><img src="https://images2.imgbox.com/cd/a6/OXf9Em1w_o.png" alt="image-20231002094121528"></p> 
<p>上图中的时钟管理、中断处理、原语这三个部分是与硬件关联较为紧密的模块，所以必须放置在内核中。</p> 
<p>而下面对于系统资源进行管理的功能的部分，这些管理工作更多的是对数据结构的操作，不会直接涉及硬件。</p> 
<p>所以有的操作系统并不把下面的部分放入到内核当中，只保留与硬件接触最紧密的部分。</p> 
<p><img src="https://images2.imgbox.com/cb/72/syZJqD1p_o.png" alt="image-20231002094608957"></p> 
<p>因此就诞生了两种截然不同的内核设计方法，将上面所以功能的设计在内核的结构叫做<strong>大内核</strong>，而只保留对硬件关系最紧密的部分的结构叫做<strong>微内核</strong>。</p> 
<p>二者之间的区别：</p> 
<p><img src="https://images2.imgbox.com/f1/a7/gYKT9Tdj_o.png" alt="image-20231002095150744"></p> 
<p>变态(CPU的状态转换)的过程是需要成本的，需要消耗不少的时间，频繁地变态会降低系统性能。</p> 
<p>大内核与微内核在结构和功能上有许多区别和异同点。</p> 
<p><strong>区别：</strong></p> 
<ol><li> <p><strong>内核结构：</strong></p> 
  <ul><li><strong>大内核：</strong> 大内核将大多数操作系统功能组织成一个单一的内核空间，包括文件系统、设备驱动、网络协议栈等，它们共享相同的地址空间。</li><li><strong>微内核：</strong> 微内核采用更模块化的设计，将操作系统的核心功能减少到最小限度，将其他功能（如文件系统、设备驱动程序）移动到用户态进程中，它们运行在独立的地址空间中。</li></ul> </li><li> <p><strong>通信方式：</strong></p> 
  <ul><li><strong>大内核：</strong> 大内核内的组件可以直接调用彼此的函数，通信相对高效。组件之间的通信通常是通过函数调用和共享数据结构实现的。</li><li><strong>微内核：</strong> 微内核通过进程间通信（IPC）来实现模块之间的通信。这通常会引入额外的开销，因为需要在用户态和内核态之间切换。</li></ul> </li><li> <p><strong>可扩展性：</strong></p> 
  <ul><li><strong>大内核：</strong> 大内核的可扩展性有限，因为所有功能都集中在一个内核中。增加新功能可能会导致内核庞大复杂。</li><li><strong>微内核：</strong> 微内核更容易扩展，因为新功能可以实现为独立的用户态进程，而不必修改内核。这提高了系统的模块化和可维护性。</li></ul> </li><li> <p><strong>可靠性和安全性：</strong></p> 
  <ul><li><strong>大内核：</strong> 大内核的可靠性和安全性可能受到影响，因为一个组件的错误可能会影响整个内核。</li><li><strong>微内核：</strong> 微内核的可靠性和安全性通常更好，因为内核的核心部分更小，因此受到攻击的面更小。</li></ul> </li></ol> 
<p><strong>异同点：</strong></p> 
<ol><li> <p><strong>性能：</strong></p> 
  <ul><li><strong>大内核：</strong> 大内核通常具有更高的性能，因为组件之间的通信开销较小。</li><li><strong>微内核：</strong> 微内核通常具有更低的性能，因为它需要在用户态和内核态之间切换并使用IPC来进行通信。</li></ul> </li><li> <p><strong>可定制性：</strong></p> 
  <ul><li><strong>大内核：</strong> 大内核的可定制性较低，因为它将所有功能打包在一个内核中。</li><li><strong>微内核：</strong> 微内核更具可定制性，因为新功能可以作为用户态进程添加或删除。</li></ul> </li><li> <p><strong>适用场景：</strong></p> 
  <ul><li><strong>大内核：</strong> 大内核通常更适合于需要高性能和简单设计的应用场景，如桌面操作系统。</li><li><strong>微内核：</strong> 微内核更适用于需要更高的可靠性、安全性和可扩展性的应用场景，如嵌入式系统和分布式系统。</li></ul> </li></ol> 
<p>总的来说，大内核和微内核都有各自的优势和劣势，选择其中之一通常取决于应用的需求和性能目标。操作系统设计师必须在性能、可定制性、可维护性、可靠性和安全性之间权衡各种因素，以选择最适合特定用例的内核模型。</p> 
<h4><a id="_722"></a>分层结构</h4> 
<p>操作系统体系结构的分层结构是一种常见的设计模型，它将操作系统的不同功能和组件分层组织，以提高模块化、可维护性和可扩展性。每个层次负责不同的任务，而且它们之间有严格的接口定义，使得不同层次的组件可以相互交互。以下是一个典型的分层操作系统体系结构示例：</p> 
<ol><li> <p><strong>硬件层（Hardware Layer）：</strong></p> 
  <ul><li>这是操作系统的最底层，与计算机硬件直接交互。它包括中央处理单元（CPU）、内存、磁盘、网络接口卡等硬件设备。</li></ul> </li><li> <p><strong>内核层（Kernel Layer）：</strong></p> 
  <ul><li>内核层是操作系统的核心，它提供了对硬件资源的管理和控制，以及基本的系统服务。内核层通常包括以下模块： 
    <ul><li>进程管理：负责创建、调度和终止进程。</li><li>内存管理：负责分配和管理内存资源。</li><li>文件系统：负责文件和目录的管理。</li><li>设备驱动程序：与硬件交互的驱动程序。</li><li>网络协议栈：处理网络通信。</li></ul> </li></ul> </li><li> <p><strong>系统调用层（System Call Layer）：</strong></p> 
  <ul><li>系统调用层是用户程序和内核之间的接口。它包括一组系统调用，允许用户程序请求内核提供的服务。系统调用层提供了用户程序访问内核功能的标准方式。</li></ul> </li><li> <p><strong>服务层（Service Layer）：</strong></p> 
  <ul><li>服务层构建在系统调用层之上，提供了高级服务和工具，以方便应用程序开发。这包括文件管理服务、进程通信服务、图形用户界面（GUI）服务等。</li></ul> </li><li> <p><strong>应用程序层（Application Layer）：</strong></p> 
  <ul><li>应用程序层包括各种用户应用程序，如文本编辑器、Web浏览器、游戏等。这些应用程序依赖于底层的系统和服务，通过系统调用和服务层与操作系统交互。</li></ul> </li><li> <p><strong>用户界面层（User Interface Layer）：</strong></p> 
  <ul><li>用户界面层是用户与计算机交互的界面，包括命令行界面（CLI）和图形用户界面（GUI）。它使用户能够操作应用程序和系统。</li></ul> </li></ol> 
<p>这种分层结构的设计使操作系统模块化，易于维护和扩展。不同层次的组件各自有不同的职责，它们通过明确定义的接口进行通信。这种分层结构也有助于<strong>提高系统的稳定性和安全性</strong>，因为不同层次的组件可以隔离彼此，限制了错误的传播。</p> 
<h5><a id="_751"></a>优点</h5> 
<ol><li><strong>模块化和可维护性：</strong> 分层结构将系统划分为多个独立的模块，每个模块都有明确定义的职责。这使得系统更容易维护，因为开发人员可以专注于单个模块而不必考虑整个系统。</li><li><strong>可扩展性：</strong> 添加新功能或修改现有功能通常更容易，因为开发人员只需修改或扩展相关层次的模块，而不必影响其他部分。</li><li><strong>清晰的接口：</strong> 每个层次的模块都有清晰的接口定义，这使得不同模块之间的通信和协作更加简单。这也促进了代码重用和团队协作。</li><li><strong>错误隔离：</strong> 分层结构可以提供一定程度的错误隔离。如果一个模块中发生错误，它通常不会影响其他模块的正常运行。</li><li><strong>跨平台兼容性：</strong> 在分层结构中，不同层次的模块可以相对独立地实现和维护，这有助于跨平台兼容性，因为每个平台只需实现适当的模块。</li></ol> 
<h5><a id="_759"></a>缺点</h5> 
<ol><li><strong>性能开销：</strong> 分层结构通常涉及模块间的额外通信和接口处理，这可能导致性能开销，特别是在高性能要求的应用中。</li><li><strong>复杂性：</strong> 系统的分层结构可能会引入额外的复杂性，特别是当有许多不同的层次和模块时。这可能增加了系统的理解和维护难度。</li><li><strong>不灵活：</strong> 有时，分层结构可能过于刚性，难以适应某些非标准需求或变化。在这种情况下，可能需要调整整个结构。</li><li><strong>资源消耗：</strong> 在某些情况下，每个层次的模块都可能占用系统资源，例如内存。这可能会导致资源浪费。</li><li><strong>延迟：</strong> 在某些情况下，模块之间的通信和数据传递可能会引入额外的延迟，这可能不适合实时应用程序。</li></ol> 
<h4><a id="_767"></a>模块化</h4> 
<p>操作系统的模块化管理是指将操作系统的不同功能和组件分成独立的模块，每个模块负责特定的任务或服务。这种模块化设计有助于提高操作系统的可维护性、可扩展性和可移植性，同时使系统更易于开发和维护。</p> 
<p>将内核划分为多个模块，各个模块之间互相协作。</p> 
<p>内核 = 主模块 + 可加载内核模块</p> 
<p>主模块：<strong>只负责核心功能，如进程调度、内存管理</strong>。</p> 
<p>可加载内核模块：可以动态加载新模块到内核，而无需重新编译整个内核。</p> 
<p>以下是模块化管理在操作系统中的一些关键方面：</p> 
<ol><li><strong>模块划分：</strong> 模块化操作系统将操作系统的不同功能划分为独立的模块，每个模块负责特定任务。常见的模块包括进程管理、内存管理、文件系统、设备驱动程序、网络协议栈等。</li><li><strong>模块间接口：</strong> 每个模块都有明确定义的接口，它定义了与其他模块之间的通信和数据传递方式。这些接口通常包括函数调用、数据结构、消息传递等。</li><li><strong>模块独立性：</strong> 模块之间应该尽可能独立，这意味着一个模块的修改不应该影响其他模块的正常运行。这提高了系统的稳定性和可维护性。</li><li><strong>模块的替换和扩展：</strong> 支持动态加载新的内核模块(如：安装设备驱动程序、安装新的文件系统模块到内核)，增强OS适应性。</li><li><strong>模块的重用：</strong> 模块化操作系统设计鼓励代码重用，因为不同的系统可以共享通用的模块，减少了开发工作量。</li><li><strong>模块的安全性：</strong> 模块化设计可以提高系统的安全性，因为安全性相关的功能可以单独实现和维护。</li><li><strong>模块的并行开发：</strong> 不同的开发团队可以并行开发不同的模块，从而加速整个操作系统的开发过程。</li><li><strong>提高通信效率</strong>：任何模块都可以直接调用其他模块，无需采用消息传递进行通信，效率较高。</li></ol> 
<h4><a id="_790"></a>外核</h4> 
<p>操作系统的外核（Exokernel）是一种操作系统设计范例，旨在提供更高度可定制和灵活的操作系统服务，同时最大程度地减少内核的功能。外核设计的核心思想是将操作系统的基本职责减至最低，将更多的控制权和自由交给应用程序。以下是一些关于外核设计的特点和原则：</p> 
<ol><li> <p><strong>最小内核：</strong> 外核将内核的功能减少到最低限度，只提供了硬件抽象和资源分配的基本功能。外核不涉及高级抽象，如文件系统、进程调度和网络协议。</p> </li><li> <p><strong>硬件资源管理：</strong> 外核主要负责管理硬件资源，包括处理器、内存、存储和网络设备。它提供了一种机制，让应用程序可以直接控制这些资源，而不受限于内核提供的抽象。</p> </li><li> <p><strong>应用程序控制：</strong> 外核的设计目标之一是让应用程序能够更灵活地控制硬件资源。应用程序可以根据自身需求创建自己的资源管理策略，而不是受限于内核的默认策略。</p> </li><li> <p><strong>强调安全性：</strong> 外核强调安全性，确保不同应用程序之间的隔离和保护。应用程序之间不能直接访问彼此的资源，而必须经过权限检查。</p> </li><li> <p><strong>支持多样性：</strong> 外核设计支持多样性，使得不同类型的应用程序可以使用不同的资源管理策略和操作系统服务。这有助于适应各种应用需求。</p> </li><li> <p><strong>低级别接口：</strong> 外核提供了低级别的硬件接口，通常是基于底层硬件的原始操作。这些接口可以让应用程序更精确地控制硬件资源。</p> </li></ol> 
<p>外核设计的目标是提供高度定制和高性能的操作系统服务，以满足各种应用的需求。然而，外核设计也带来了一些挑战，包括复杂性、安全性问题和对应用程序的高要求，因为应用程序需要负责管理更多的资源和细节。</p> 
<p>内核负责进程调度、进程通信等功能，外核则负责为用户进程分配未经抽象的硬件资源，且由外核负责保证资源使用安全。</p> 
<h5><a id="_810"></a><strong>优点</strong></h5> 
<ol><li> <p><strong>高度可定制性：</strong> 外核设计允许应用程序直接管理硬件资源，提供了高度可定制的操作系统服务。这使得应用程序能够根据自身需求定制资源管理策略，从而实现更高的性能和效率。</p> </li><li> <p><strong>低开销：</strong> 由于外核只提供了最基本的硬件抽象，它通常具有较低的内核开销。这意味着操作系统的运行开销相对较小，可以提供更高的性能。</p> </li><li> <p><strong>适应性：</strong> 外核设计支持多样性，允许不同类型的应用程序使用不同的资源管理策略和操作系统服务。这使得外核适用于广泛的应用领域。</p> </li><li> <p><strong>教育和研究：</strong> 外核设计在教育和研究领域中非常有用，因为它允许学生和研究人员探索操作系统内部工作原理，并进行实验性的设计和开发。</p> </li></ol> 
<h5><a id="_820"></a><strong>缺点</strong></h5> 
<ol><li> <p><strong>复杂性：</strong> 外核设计通常需要更复杂的应用程序代码，因为应用程序需要自行管理硬件资源和实现许多操作系统功能。这可能会增加开发的难度和维护的成本。</p> </li><li> <p><strong>安全性风险：</strong> 由于应用程序具有更多的控制权，外核设计可能增加了系统的安全风险。不正确的资源管理或权限管理可能导致安全漏洞。</p> </li><li> <p><strong>不适合通用用途：</strong> 外核设计通常不适合通用用途的桌面操作系统，因为它要求应用程序和开发人员具有更高的技术要求，而且可能不具备所需的可用性和易用性。</p> </li><li> <p><strong>性能可变性：</strong> 由于应用程序直接管理硬件资源，性能可能受到应用程序质量和策略的影响。不小心编写的应用程序代码可能导致性能下降。</p> </li></ol> 
<h3><a id="_830"></a>引导</h3> 
<p>操作系统的引导（Bootstrapping），通常简称为引导（Boot），是计算机启动过程中的关键步骤之一。它是将计算机从关机状态转换为可以运行操作系统和其他软件的状态的过程。引导过程涉及一系列操作，包括硬件初始化、加载操作系统内核和启动系统的关键部分。</p> 
<p>以下是操作系统引导过程的一般步骤：</p> 
<ol><li> <p><strong>计算机开机：</strong> 当计算机通电或重新启动时，中央处理单元（CPU）开始执行位于固化存储器（如ROM或Flash存储器）中的引导程序（Boot Loader）。</p> </li><li> <p><strong>BIOS/UEFI初始化：</strong> 引导程序首先与计算机的基本输入/输出系统（BIOS）或统一扩展固件接口（UEFI）交互。这个阶段负责初始化系统硬件，包括检测和初始化内存、检查和配置连接的设备（如硬盘、光驱、键盘、显示器等），并为操作系统的加载做准备。</p> </li><li> <p><strong>引导加载程序：</strong> 引导程序是一个小型的软件程序，通常位于计算机的引导设备（如硬盘、固态硬盘或USB闪存驱动器）的引导扇区中。引导程序的任务是加载操作系统内核。在BIOS系统中，这通常是Master Boot Record（MBR）；在UEFI系统中，它通常是EFI系统分区中的一个可引导的.efi文件。</p> </li><li> <p><strong>加载操作系统内核：</strong> 引导程序会查找并加载操作系统内核文件，将其从存储设备读取到计算机的内存中。内核文件包含操作系统的核心代码和数据结构。</p> </li><li> <p><strong>内核初始化：</strong> 一旦内核加载到内存中，引导程序将控制权交给内核。操作系统内核接下来会执行一系列初始化步骤，包括建立进程管理、内存管理、文件系统和其他关键子系统，以准备计算机系统的正常运行。</p> </li><li> <p><strong>用户空间启动：</strong> 操作系统内核初始化后，它通常会启动一个用户空间的初始化过程，以准备运行用户级应用程序。这包括启动系统服务、用户登录管理等。</p> </li><li> <p><strong>用户登录：</strong> 最终，操作系统会提供用户登录界面，等待用户输入凭据，然后在用户验证后提供交互式计算环境。</p> </li></ol> 
<p>整个引导过程是计算机系统启动的关键阶段，它确保了操作系统正确加载并准备好接受用户或应用程序的命令。</p> 
<p><img src="https://images2.imgbox.com/c5/13/nFeMt9Wj_o.png" alt="image-20231002113348837"></p> 
<p>操作系统的引导步骤：</p> 
<p>① CPU从一个特定内存地址开始，取指令，执行ROM中的引导程序(先进行硬件自检，再开机)。</p> 
<p>② 将磁盘的第一块——主引导记录读入内存，执行磁盘引导程序，扫描分区表。</p> 
<p>③ 从活动分区(又称为主分区，即安装了操作系统的分区)读入分区引导记录，执行其中的程序。</p> 
<p>④ 从根目录下找到完整的操作系统初始化程序(即：启动管理器)并执行，完成“开机”的一系列操作。</p> 
<p><img src="https://images2.imgbox.com/7b/f5/FNIM0yjS_o.png" alt="image-20231002113616546"></p> 
<p>例如，在Windows系统中的C盘，Windows目录下，有一个Boot文件夹，里面装的都是引导文件：</p> 
<p><img src="https://images2.imgbox.com/4f/07/srw2uhUZ_o.png" alt="image-20231002120713071"></p> 
<h3><a id="_870"></a>虚拟机</h3> 
<p>使用虚拟化技术将一台物理机器虚拟化为多台虚拟机器(Virtual Machine，VM)，每个虚拟机器都可以独立运行一个操作系统。一种在计算机上创建并运行虚拟化操作系统或应用程序环境的技术。虚拟机使得在一台物理计算机上同时运行多个独立的虚拟计算机（虚拟机实例）成为可能。每个虚拟机都被视为一个独立的计算环境，拥有自己的操作系统、应用程序和资源。</p> 
<p>虚拟机技术的关键概念包括以下内容：</p> 
<ol><li><strong>宿主机（Host）：</strong> 宿主机是运行虚拟化软件（称为虚拟机监视器或虚拟化管理程序）的物理计算机。宿主机提供了硬件资源（如处理器、内存、存储和网络接口）以及虚拟化软件的运行环境。</li><li><strong>虚拟机管理程序（VMM）：</strong> 虚拟机管理程序是虚拟化软件的一部分，负责创建、管理和监控虚拟机实例。它模拟了物理硬件并提供给虚拟机访问。一些常见的虚拟机监视器包括VMware vSphere/ESXi、Microsoft Hyper-V、Oracle VirtualBox和KVM（Kernel-based Virtual Machine）等。</li><li><strong>虚拟机实例：</strong> 虚拟机实例是在宿主机上运行的虚拟计算机。每个虚拟机实例拥有自己的独立操作系统、应用程序和文件系统，它们在物理硬件上以虚拟化的方式运行。</li><li><strong>宿主操作系统：</strong> 宿主操作系统是在宿主机上运行的操作系统，它管理物理硬件资源并提供虚拟机监视器所需的服务。</li></ol> 
<p>其中有两类虚拟机管理程序：</p> 
<p>第一类VMM，是直接运行在硬件上的：</p> 
<p><img src="https://images2.imgbox.com/0b/86/zMLwvNpx_o.png" alt="image-20231002121045680"></p> 
<p>第二类VMM，运行在宿主操作系统上：</p> 
<p><img src="https://images2.imgbox.com/59/14/18UfCXh5_o.png" alt="image-20231002121126168"></p> 
<p>两者的对比如下表：</p> 
<table><thead><tr><th align="center"></th><th align="center">第一类VMM</th><th align="center">第二类VMM</th></tr></thead><tbody><tr><td align="center">对物理资源的控制权</td><td align="center">直接运行在硬件上，能直接控制和分配物理资源</td><td align="center">运行在Host OS 之上，依赖于 Host OS 为其分配物理资源</td></tr><tr><td align="center">资源分配方式</td><td align="center">在安装Guest OS时，VMM要在原本的硬盘上自行分配存储空间，类似于“外核”的分配方式，分配未经抽象的物理硬件</td><td align="center">Guest OS 拥有自己的虚拟硬盘，该盘实际上是 Host OS文件系统中的一个大文件。Guest OS分配到的内存是虚拟内存</td></tr><tr><td align="center">性能</td><td align="center">性能更好</td><td align="center">性能更差，需要 Host OS 作为“中介”</td></tr><tr><td align="center">可支持的虚拟机数量</td><td align="center">更多，不需要和 Host OS 竞争资源，相同的硬件资源可以支持更多的虚拟机</td><td align="center">更少， Host OS 本身需要使用物理资源， Host OS 上运行的其他进程也需要物理资源</td></tr><tr><td align="center">虚拟机的可迁移性</td><td align="center">更差</td><td align="center">更好，只需要导出虚拟机镜像文件即可迁移到另一台 Host OS 上，商业化应用更广泛</td></tr><tr><td align="center">运行模式</td><td align="center">第一类VMM运行在最高特权级(Ring 0)，可以执行最高特权的指令</td><td align="center">第二类VMM部分运行在用户态、部分运行在内核态。Guest OS 发出的系统调用会被 VMM 截获，并转化为 VMM 对 Host OS 的系统调用</td></tr></tbody></table>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/c26f61d33a907089df46c14ffcd509a2/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">全链路压力测试：现代软件工程中的重要性</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/387992af3749219907a136dfc7cefb48/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">宣布推出适用于 .NET 的 Azure Migrate 应用程序和代码评估工具</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>