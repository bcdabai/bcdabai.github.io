<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Mockito教程 - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Mockito教程" />
<meta property="og:description" content="目录
1 Mockito 介绍
1.1 Mockito是什么？
1.2 为什么需要Mock
1.3 Stub和Mock异同
1.4 Mockito资源
1.5 使用场景
2 使用Mockito
2.1 验证行为
2.2 模拟我们所期望的结果
2.3 RETURNS_SMART_NULLS和RETURNS_DEEP_STUBS
2.4 模拟方法体抛出异常
2.5 使用注解来快速模拟
2.6 参数匹配
2.7 自定义参数匹配
2.8 捕获参数来进一步断言
2.9 使用方法预期回调接口生成期望值（Answer结构）
2.10 修改对未预设的调用返回默认期望
2.11 用spy监控真实对象 2.12 真实的部分mock
2.13 重置mock
2.14 验证确切的调用次数
2.15 连续调用
2.16 验证执行顺序
2.17 确保模拟对象上无互动发生
2.18 找出冗余的互动(即未被验证到的)
3 Mockito如何实现Mock
参考
1 Mockito 介绍 [3] 返回
1.1 Mockito是什么？ Mockito是mocking框架，它让你用简洁的API做测试。而且Mockito简单易学，它可读性强和验证语法简洁。
1.2 为什么需要Mock 测试驱动的开发( TDD)要求我们先写单元测试，再写实现代码。在写单元测试的过程中，我们往往会遇到要测试的类有很多依赖，这些依赖的类/对象/资源又有别的依赖，从而形成一个大的依赖树，要在单元测试的环境中完整地构建这样的依赖，是一件很困难的事情。如下图所示： 为了测试类A，我们需要Mock B类和C类（用虚拟对象来代替）如下图所示：" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/9964a61ac2e1c5cce2db3ba9a97eefba/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-11-25T00:04:06+08:00" />
<meta property="article:modified_time" content="2022-11-25T00:04:06+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Mockito教程</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <h2></h2> 
<p><strong><a name="top"></a>目录</strong></p> 
<p>1 <a href="https://www.cnblogs.com/Ming8006/p/6297333.html#c1" rel="nofollow" title="Mockito 介绍">Mockito 介绍</a><br>   1.1 <a href="https://www.cnblogs.com/Ming8006/p/6297333.html#c1.1" rel="nofollow" title="Mockito是什么？">Mockito是什么？</a><br>   1.2 <a href="https://www.cnblogs.com/Ming8006/p/6297333.html#c1.3" rel="nofollow" title="为什么需要Mock">为什么需要Mock</a><br>   1.3 <a href="https://www.cnblogs.com/Ming8006/p/6297333.html#c1.3" rel="nofollow" title="Stub和Mock异同">Stub和Mock异同</a><br>   1.4 <a href="https://www.cnblogs.com/Ming8006/p/6297333.html#c1.4" rel="nofollow" title="Mockito资源">Mockito资源</a><br>   1.5 <a href="https://www.cnblogs.com/Ming8006/p/6297333.html#c1.5" rel="nofollow" title="使用场景">使用场景</a><br> 2 <a href="https://www.cnblogs.com/Ming8006/p/6297333.html#c2" rel="nofollow" title="使用Mockito">使用Mockito</a><br>   2.1<a href="https://www.cnblogs.com/Ming8006/p/6297333.html#c2.1" rel="nofollow" title=" 验证行为"> 验证行为</a><br>   2.2 <a href="https://www.cnblogs.com/Ming8006/p/6297333.html#c2.2" rel="nofollow" title="模拟我们所期望的结果">模拟我们所期望的结果</a><br>   2.3 <a href="https://www.cnblogs.com/Ming8006/p/6297333.html#c2.3" rel="nofollow" title="RETURNS_SMART_NULLS和RETURNS_DEEP_STUBS">RETURNS_SMART_NULLS和RETURNS_DEEP_STUBS</a><br>   2.4 <a href="https://www.cnblogs.com/Ming8006/p/6297333.html#c2.4" rel="nofollow" title="模拟方法体抛出异常">模拟方法体抛出异常</a><br>   2.5 <a href="https://www.cnblogs.com/Ming8006/p/6297333.html#c2.5" rel="nofollow" title="使用注解来快速模拟">使用注解来快速模拟</a><br>   2.6 <a href="https://www.cnblogs.com/Ming8006/p/6297333.html#c2.6" rel="nofollow" title="参数匹配">参数匹配</a><br>   2.7 <a href="https://www.cnblogs.com/Ming8006/p/6297333.html#c2.7" rel="nofollow" title="自定义参数匹配">自定义参数匹配</a><br>   2.8 <a href="https://www.cnblogs.com/Ming8006/p/6297333.html#c2.8" rel="nofollow" title="捕获参数来进一步断言">捕获参数来进一步断言</a><br>   2.9 <a href="https://www.cnblogs.com/Ming8006/p/6297333.html#c2.9" rel="nofollow" title="使用方法预期回调接口生成期望值（Answer结构）">使用方法预期回调接口生成期望值（Answer结构）</a><br>   2.10 <a href="https://www.cnblogs.com/Ming8006/p/6297333.html#c2.10" rel="nofollow" title="修改对未预设的调用返回默认期望">修改对未预设的调用返回默认期望</a><br>   2.11 <a href="https://www.cnblogs.com/Ming8006/p/6297333.html#c2.11" rel="nofollow" title="用spy监控真实对象">用spy监控真实对象</a> <br>   2.12 <a href="https://www.cnblogs.com/Ming8006/p/6297333.html#c2.12" rel="nofollow" title="真实的部分mock">真实的部分mock</a><br>   2.13 <a href="https://www.cnblogs.com/Ming8006/p/6297333.html#c2.13" rel="nofollow" title="重置mock">重置mock</a><br>   2.14 <a href="https://www.cnblogs.com/Ming8006/p/6297333.html#c2.14" rel="nofollow" title="验证确切的调用次数">验证确切的调用次数</a><br>   2.15 <a href="https://www.cnblogs.com/Ming8006/p/6297333.html#c2.15" rel="nofollow" title="连续调用">连续调用</a><br>   2.16 <a href="https://www.cnblogs.com/Ming8006/p/6297333.html#c2.16" rel="nofollow" title="验证执行顺序">验证执行顺序</a><br>   2.17 <a href="https://www.cnblogs.com/Ming8006/p/6297333.html#c2.17" rel="nofollow" title="确保模拟对象上无互动发生">确保模拟对象上无互动发生</a><br>   2.18 <a href="https://www.cnblogs.com/Ming8006/p/6297333.html#c2.18" rel="nofollow" title="找出冗余的互动(即未被验证到的)">找出冗余的互动(即未被验证到的)</a><br> 3 <a href="https://www.cnblogs.com/Ming8006/p/6297333.html#c3" rel="nofollow" title="Mockito如何实现Mock">Mockito如何实现Mock</a><br><a href="https://www.cnblogs.com/Ming8006/p/6297333.html#c4" rel="nofollow" title="参考">参考</a></p> 
<h3 id="blogTitle0"><a name="c1"></a>1 Mockito 介绍 [3]</h3> 
<hr> 
<p> <a href="https://www.cnblogs.com/Ming8006/p/6297333.html#top" rel="nofollow" title="返回">返回</a></p> 
<h4 id="blogTitle1"><a name="c1.1"></a>1.1 Mockito是什么？</h4> 
<p>Mockito是mocking框架，它让你用简洁的API做测试。而且Mockito简单易学，它可读性强和验证语法简洁。</p> 
<h4 id="blogTitle2"><a name="c1.2"></a>1.2 为什么需要Mock</h4> 
<p>测试驱动的开发( TDD)要求我们先写单元测试，再写实现代码。在写单元测试的过程中，我们往往会遇到要测试的类有很多依赖，这些依赖的类/对象/资源又有别的依赖，从而形成一个大的依赖树，要在单元测试的环境中完整地构建这样的依赖，是一件很困难的事情。如下图所示： </p> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/98/00/aDw8a3Gw_o.png"></p> 
<p>为了测试类A，我们需要Mock B类和C类（用虚拟对象来代替）如下图所示：</p> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/0f/08/Plh0MjyO_o.png"></p> 
<h4 id="blogTitle3"><a name="c1.3"></a>1.3 Stub和Mock异同[1]</h4> 
<ul><li>相同：Stub和Mock都是模拟外部依赖</li><li>不同：Stub是完全模拟一个外部依赖， 而Mock还可以用来判断测试通过还是失败 </li></ul> 
<h4 id="blogTitle4"><a name="c1.4"></a>1.4 Mockito资源</h4> 
<ul><li>官网： <a href="http://mockito.org/" rel="nofollow" title="http://mockito.org">http://mockito.org</a></li><li>API文档：<a href="http://docs.mockito.googlecode.com/hg/org/mockito/Mockito.html" rel="nofollow" title="http://docs.mockito.googlecode.com/hg/org/mockito/Mockito.html">http://docs.mockito.googlecode.com/hg/org/mockito/Mockito.html</a></li><li>项目源码：<a href="https://github.com/mockito/mockito" title="GitHub - mockito/mockito: Most popular Mocking framework for unit tests written in Java">GitHub - mockito/mockito: Most popular Mocking framework for unit tests written in Java</a> </li></ul> 
<h4 id="blogTitle5"><a name="c1.5"></a>1.5 使用场景</h4> 
<ul><li>提前创建测试; TDD（测试驱动开发）</li><li>团队可以并行工作</li><li>你可以创建一个验证或者演示程序</li><li>为无法访问的资源编写测试</li><li>Mock 可以交给用户</li><li>隔离系统  </li></ul> 
<h3 id="blogTitle6"><a name="c2"></a>2 使用Mockito [2][4]</h3> 
<p></p> 
<p>添加maven依赖</p> 
<pre>      &lt;dependency&gt;
          &lt;groupId&gt;org.mockito&lt;/groupId&gt;
          &lt;artifactId&gt;mockito-all&lt;/artifactId&gt;
          &lt;version&gt;1.9.5&lt;/version&gt;
          &lt;scope&gt;test&lt;/scope&gt;
      &lt;/dependency&gt;</pre> 
<p>添加junit依赖</p> 
<pre>      &lt;dependency&gt;
        &lt;groupId&gt;junit&lt;/groupId&gt;
        &lt;artifactId&gt;junit&lt;/artifactId&gt;
        &lt;version&gt;4.11&lt;/version&gt;
        &lt;scope&gt;test&lt;/scope&gt;
      &lt;/dependency&gt;</pre> 
<p>添加引用</p> 
<pre>import static org.mockito.Mockito.*;
import static org.junit.Assert.*;</pre> 
<h4 id="blogTitle7"><a name="c2.1"></a>2.1 验证行为</h4> 
<pre>    @Test
    public void verify_behaviour(){
        //模拟创建一个List对象
        List mock = mock(List.class);
        //使用mock的对象
        mock.add(1);
        mock.clear();
        //验证add(1)和clear()行为是否发生
        verify(mock).add(1);
        verify(mock).clear();
    }</pre> 
<h4 id="blogTitle8"><a name="c2.2"></a>2.2 模拟我们所期望的结果</h4> 
<pre>    @Test
    public void when_thenReturn(){
        //mock一个Iterator类
        Iterator iterator = mock(Iterator.class);
        //预设当iterator调用next()时第一次返回hello，第n次都返回world
        when(iterator.next()).thenReturn("hello").thenReturn("world");
        //使用mock的对象
        String result = iterator.next() + " " + iterator.next() + " " + iterator.next();
        //验证结果
        assertEquals("hello world world",result);
    }</pre> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/ba/bd/b4S4ht5v_o.gif"></p> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/6f/b0/kmN76LQK_o.gif"></p> 
<pre>    @Test(expected = IOException.class)
    public void when_thenThrow() throws IOException {
        OutputStream outputStream = mock(OutputStream.class);
        OutputStreamWriter writer = new OutputStreamWriter(outputStream);
        //预设当流关闭时抛出异常
        doThrow(new IOException()).when(outputStream).close();
        outputStream.close();
    }</pre> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/e9/77/jKEOju99_o.gif"></p> 
<h4 id="blogTitle9"><a name="c2.3"></a>2.3 RETURNS_SMART_NULLS和RETURNS_DEEP_STUBS</h4> 
<p>RETURNS_SMART_NULLS实现了Answer接口的对象，它是创建mock对象时的一个可选参数，mock(Class,Answer)。</p> 
<p>在创建mock对象时，有的方法我们没有进行stubbing，所以调用时会放回Null这样在进行操作是很可能抛出NullPointerException。如果通过RETURNS_SMART_NULLS参数创建的mock对象在没有调用stubbed方法时会返回SmartNull。例如：返回类型是String，会返回"";是int，会返回0；是List，会返回空的List。另外，在控制台窗口中可以看到SmartNull的友好提示。</p> 
<pre>    @Test
    public void returnsSmartNullsTest() {
        List mock = mock(List.class, RETURNS_SMART_NULLS);
        System.out.println(mock.get(0));
        
        //使用RETURNS_SMART_NULLS参数创建的mock对象，不会抛出NullPointerException异常。另外控制台窗口会提示信息“SmartNull returned by unstubbed get() method on mock”
        System.out.println(mock.toArray().length);
    }</pre> 
<p>RETURNS_DEEP_STUBS也是创建mock对象时的备选参数</p> 
<p>RETURNS_DEEP_STUBS参数程序会自动进行mock所需的对象，方法deepstubsTest和deepstubsTest2是等价的</p> 
<pre>    @Test
    public void deepstubsTest(){
        Account account=mock(Account.class,RETURNS_DEEP_STUBS);
        when(account.getRailwayTicket().getDestination()).thenReturn("Beijing");
        account.getRailwayTicket().getDestination();
        verify(account.getRailwayTicket()).getDestination();
        assertEquals("Beijing",account.getRailwayTicket().getDestination());
    }
    @Test
    public void deepstubsTest2(){
        Account account=mock(Account.class); 
        RailwayTicket railwayTicket=mock(RailwayTicket.class);        
        when(account.getRailwayTicket()).thenReturn(railwayTicket); 
        when(railwayTicket.getDestination()).thenReturn("Beijing");
        
        account.getRailwayTicket().getDestination();
        verify(account.getRailwayTicket()).getDestination();    
        assertEquals("Beijing",account.getRailwayTicket().getDestination());
    }    
    
    public class RailwayTicket{
        private String destination;

        public String getDestination() {
            return destination;
        }

        public void setDestination(String destination) {
            this.destination = destination;
        }        
    }
    
    public class Account{
        private RailwayTicket railwayTicket;

        public RailwayTicket getRailwayTicket() {
            return railwayTicket;
        }

        public void setRailwayTicket(RailwayTicket railwayTicket) {
            this.railwayTicket = railwayTicket;
        }
    }</pre> 
<h4 id="blogTitle10"><a name="c2.4"></a>2.4 模拟方法体抛出异常</h4> 
<pre>    @Test(expected = RuntimeException.class)
    public void doThrow_when(){
        List list = mock(List.class);
        doThrow(new RuntimeException()).when(list).add(1);
        list.add(1);
    }</pre> 
<h4 id="blogTitle11"><a name="c2.5"></a>2.5 使用注解来快速模拟 </h4> 
<p>在上面的测试中我们在每个测试方法里都mock了一个List对象，为了避免重复的mock，是测试类更具有可读性，我们可以使用下面的注解方式来快速模拟对象：</p> 
<pre>    @Mock
    private List mockList;</pre> 
<p>OK，我们再用注解的mock对象试试 </p> 
<pre>    @Test
    public void shorthand(){
        mockList.add(1);
        verify(mockList).add(1);
    }</pre> 
<p>运行这个测试类你会发现报错了，mock的对象为NULL，为此我们必须在基类中添加初始化mock的代码</p> 
<pre>public class MockitoExample2 {
    @Mock
    private List mockList;

    public MockitoExample2(){
        MockitoAnnotations.initMocks(this);
    }

    @Test
    public void shorthand(){
        mockList.add(1);
        verify(mockList).add(1);
    }
}</pre> 
<p>或者使用built-in runner：MockitoJUnitRunner</p> 
<pre>@RunWith(MockitoJUnitRunner.class)
public class MockitoExample2 {
    @Mock
    private List mockList;

    @Test
    public void shorthand(){
        mockList.add(1);
        verify(mockList).add(1);
    }
}</pre> 
<h4 id="blogTitle12"><a name="c2.6"></a>2.6 参数匹配</h4> 
<pre>    @Test
    public void with_arguments(){
        Comparable comparable = mock(Comparable.class);
        //预设根据不同的参数返回不同的结果
        when(comparable.compareTo("Test")).thenReturn(1);
        when(comparable.compareTo("Omg")).thenReturn(2);
        assertEquals(1, comparable.compareTo("Test"));
        assertEquals(2, comparable.compareTo("Omg"));
        //对于没有预设的情况会返回默认值
        assertEquals(0, comparable.compareTo("Not stub"));
    }</pre> 
<p>除了匹配制定参数外，还可以匹配自己想要的任意参数</p> 
<pre>    @Test
    public void with_unspecified_arguments(){
        List list = mock(List.class);
        //匹配任意参数
        when(list.get(anyInt())).thenReturn(1);
        when(list.contains(argThat(new IsValid()))).thenReturn(true);
        assertEquals(1, list.get(1));
        assertEquals(1, list.get(999));
        assertTrue(list.contains(1));
        assertTrue(!list.contains(3));
    }

    private class IsValid extends ArgumentMatcher&lt;List&gt;{
        @Override
        public boolean matches(Object o) {
            return o == 1 || o == 2;
        }
    }</pre> 
<p>注意：如果你使用了参数匹配，那么所有的参数都必须通过matchers来匹配，如下代码：</p> 
<pre>    @Test
    public void all_arguments_provided_by_matchers(){
        Comparator comparator = mock(Comparator.class);
        comparator.compare("nihao","hello");
        //如果你使用了参数匹配，那么所有的参数都必须通过matchers来匹配
        verify(comparator).compare(anyString(),eq("hello"));
        //下面的为无效的参数匹配使用
        //verify(comparator).compare(anyString(),"hello");
    }</pre> 
<h4 id="blogTitle13"><a name="c2.7"></a>2.7 自定义参数匹配</h4> 
<pre>    @Test
    public void argumentMatchersTest(){
        //创建mock对象
        List&lt;String&gt; mock = mock(List.class);

        //argThat(Matches&lt;T&gt; matcher)方法用来应用自定义的规则，可以传入任何实现Matcher接口的实现类。
        when(mock.addAll(argThat(new IsListofTwoElements()))).thenReturn(true);

        mock.addAll(Arrays.asList("one","two","three"));
        //IsListofTwoElements用来匹配size为2的List，因为例子传入List为三个元素，所以此时将失败。
        verify(mock).addAll(argThat(new IsListofTwoElements()));
    }
    
    class IsListofTwoElements extends ArgumentMatcher&lt;List&gt;
    {
        public boolean matches(Object list)
        {
            return((List)list).size()==2;
        }
    }</pre> 
<h4 id="blogTitle14"><a name="c2.8"></a>2.8 捕获参数来进一步断言</h4> 
<p>较复杂的参数匹配器会降低代码的可读性，有些地方使用参数捕获器更加合适。</p> 
<pre>        @Test
    public void capturing_args(){
        PersonDao personDao = mock(PersonDao.class);
        PersonService personService = new PersonService(personDao);

        ArgumentCaptor&lt;Person&gt; argument = ArgumentCaptor.forClass(Person.class);
        personService.update(1,"jack");
        verify(personDao).update(argument.capture());
        assertEquals(1,argument.getValue().getId());
        assertEquals("jack",argument.getValue().getName());
    }

     class Person{
        private int id;
        private String name;

        Person(int id, String name) {
            this.id = id;
            this.name = name;
        }

        public int getId() {
            return id;
        }

        public String getName() {
            return name;
        }
    }

    interface PersonDao{
        public void update(Person person);
    }

    class PersonService{
        private PersonDao personDao;

        PersonService(PersonDao personDao) {
            this.personDao = personDao;
        }

        public void update(int id,String name){
            personDao.update(new Person(id,name));
        }
    }</pre> 
<h4 id="blogTitle15"><a name="c2.9"></a>2.9 使用方法预期回调接口生成期望值（Answer结构）</h4> 
<pre>@Test
    public void answerTest(){
        when(mockList.get(anyInt())).thenAnswer(new CustomAnswer());
        assertEquals("hello world:0",mockList.get(0));
        assertEquals("hello world:999",mockList.get(999));
    }

    private class CustomAnswer implements Answer&lt;String&gt;{
        @Override
        public String answer(InvocationOnMock invocation) throws Throwable {
            Object[] args = invocation.getArguments();
            return "hello world:"+args[0];
        }
    }</pre> 
<p>也可使用匿名内部类实现</p> 
<pre>    @Test
    public void answer_with_callback(){
        //使用Answer来生成我们我们期望的返回
        when(mockList.get(anyInt())).thenAnswer(new Answer&lt;Object&gt;() {
            @Override
            public Object answer(InvocationOnMock invocation) throws Throwable {
                Object[] args = invocation.getArguments();
                return "hello world:"+args[0];
            }
        });
        assertEquals("hello world:0",mockList.get(0));
        assertEquals("hello world:999",mockList.get(999));
    }</pre> 
<h4 id="blogTitle16"><a name="c2.10"></a>2.10 修改对未预设的调用返回默认期望</h4> 
<pre>    @Test
    public void unstubbed_invocations(){
        //mock对象使用Answer来对未预设的调用返回默认期望值
        List mock = mock(List.class,new Answer() {
            @Override
            public Object answer(InvocationOnMock invocation) throws Throwable {
                return 999;
            }
        });
        //下面的get(1)没有预设，通常情况下会返回NULL，但是使用了Answer改变了默认期望值
        assertEquals(999, mock.get(1));
        //下面的size()没有预设，通常情况下会返回0，但是使用了Answer改变了默认期望值
        assertEquals(999,mock.size());
    }</pre> 
<h4 id="blogTitle17"><a name="c2.11"></a>2.11 用spy监控真实对象  </h4> 
<ul><li>Mock不是真实的对象，它只是用类型的class创建了一个虚拟对象，并可以设置对象行为</li><li>Spy是一个真实的对象，但它可以设置对象行为</li><li>InjectMocks创建这个类的对象并自动将标记@Mock、@Spy等注解的属性值注入到这个中</li></ul> 
<pre>    @Test(expected = IndexOutOfBoundsException.class)
    public void spy_on_real_objects(){
        List list = new LinkedList();
        List spy = spy(list);
        //下面预设的spy.get(0)会报错，因为会调用真实对象的get(0)，所以会抛出越界异常
        //when(spy.get(0)).thenReturn(3);

        //使用doReturn-when可以避免when-thenReturn调用真实对象api
        doReturn(999).when(spy).get(999);
        //预设size()期望值
        when(spy.size()).thenReturn(100);
        //调用真实对象的api
        spy.add(1);
        spy.add(2);
        assertEquals(100,spy.size());
        assertEquals(1,spy.get(0));
        assertEquals(2,spy.get(1));
        verify(spy).add(1);
        verify(spy).add(2);
        assertEquals(999,spy.get(999));
        spy.get(2);
    }</pre> 
<h4 id="blogTitle18"><a name="c2.12"></a>2.12 真实的部分mock</h4> 
<pre>    @Test
    public void real_partial_mock(){
        //通过spy来调用真实的api
        List list = spy(new ArrayList());
        assertEquals(0,list.size());
        A a  = mock(A.class);
        //通过thenCallRealMethod来调用真实的api
        when(a.doSomething(anyInt())).thenCallRealMethod();
        assertEquals(999,a.doSomething(999));
    }


    class A{
        public int doSomething(int i){
            return i;
        }
    }</pre> 
<h4 id="blogTitle19"><a name="c2.13"></a>2.13 重置mock</h4> 
<pre>    @Test
    public void reset_mock(){
        List list = mock(List.class);
        when(list.size()).thenReturn(10);
        list.add(1);
        assertEquals(10,list.size());
        //重置mock，清除所有的互动和预设
        reset(list);
        assertEquals(0,list.size());
    }</pre> 
<h4 id="blogTitle20"><a name="c2.14"></a>2.14 验证确切的调用次数</h4> 
<pre>    @Test
    public void verifying_number_of_invocations(){
        List list = mock(List.class);
        list.add(1);
        list.add(2);
        list.add(2);
        list.add(3);
        list.add(3);
        list.add(3);
        //验证是否被调用一次，等效于下面的times(1)
        verify(list).add(1);
        verify(list,times(1)).add(1);
        //验证是否被调用2次
        verify(list,times(2)).add(2);
        //验证是否被调用3次
        verify(list,times(3)).add(3);
        //验证是否从未被调用过
        verify(list,never()).add(4);
        //验证至少调用一次
        verify(list,atLeastOnce()).add(1);
        //验证至少调用2次
        verify(list,atLeast(2)).add(2);
        //验证至多调用3次
        verify(list,atMost(3)).add(3);
    }</pre> 
<h4 id="blogTitle21"><a name="c2.15"></a>2.15 连续调用</h4> 
<pre>    @Test(expected = RuntimeException.class)
    public void consecutive_calls(){
        //模拟连续调用返回期望值，如果分开，则只有最后一个有效
        when(mockList.get(0)).thenReturn(0);
        when(mockList.get(0)).thenReturn(1);
        when(mockList.get(0)).thenReturn(2);
        when(mockList.get(1)).thenReturn(0).thenReturn(1).thenThrow(new RuntimeException());
        assertEquals(2,mockList.get(0));
        assertEquals(2,mockList.get(0));
        assertEquals(0,mockList.get(1));
        assertEquals(1,mockList.get(1));
        //第三次或更多调用都会抛出异常
        mockList.get(1);
    }</pre> 
<h4 id="blogTitle22"><a name="c2.16"></a>2.16 验证执行顺序</h4> 
<pre>    @Test
    public void verification_in_order(){
        List list = mock(List.class);
        List list2 = mock(List.class);
        list.add(1);
        list2.add("hello");
        list.add(2);
        list2.add("world");
        //将需要排序的mock对象放入InOrder
        InOrder inOrder = inOrder(list,list2);
        //下面的代码不能颠倒顺序，验证执行顺序
        inOrder.verify(list).add(1);
        inOrder.verify(list2).add("hello");
        inOrder.verify(list).add(2);
        inOrder.verify(list2).add("world");
    }</pre> 
<h4 id="blogTitle23"><a name="c2.17"></a>2.17 确保模拟对象上无互动发生</h4> 
<pre>    @Test
    public void verify_interaction(){
        List list = mock(List.class);
        List list2 = mock(List.class);
        List list3 = mock(List.class);
        list.add(1);
        verify(list).add(1);
        verify(list,never()).add(2);
        //验证零互动行为
        verifyZeroInteractions(list2,list3);
    }</pre> 
<h4 id="blogTitle24"><a name="c2.18"></a>2.18 找出冗余的互动(即未被验证到的)</h4> 
<pre>    @Test(expected = NoInteractionsWanted.class)
    public void find_redundant_interaction(){
        List list = mock(List.class);
        list.add(1);
        list.add(2);
        verify(list,times(2)).add(anyInt());
        //检查是否有未被验证的互动行为，因为add(1)和add(2)都会被上面的anyInt()验证到，所以下面的代码会通过
        verifyNoMoreInteractions(list);

        List list2 = mock(List.class);
        list2.add(1);
        list2.add(2);
        verify(list2).add(1);
        //检查是否有未被验证的互动行为，因为add(2)没有被验证，所以下面的代码会失败抛出异常
        verifyNoMoreInteractions(list2);
    }</pre> 
<h3 id="blogTitle25"><a name="c3"></a>3 Mockito如何实现Mock[3]</h3> 
<hr> 
<p> </p> 
<p>Mockito并不是创建一个真实的对象，而是模拟这个对象，他用简单的when(mock.method(params)).thenRetrun(result)语句设置mock对象的行为，如下语句：</p> 
<pre>// 设置mock对象的行为 － 当调用其get方法获取第0个元素时，返回"first"
Mockito.when(mockedList.get(0)).thenReturn("first");</pre> 
<p>在Mock对象的时候，创建一个proxy对象，保存被调用的方法名（get），以及调用时候传递的参数（0），然后在调用thenReturn方法时再把“first”保存起来，这样，就有了构建一个stub方法所需的所有信息，构建一个stub。当get方法被调用的时候，实际上调用的是之前保存的proxy对象的get方法，返回之前保存的数据。</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/544cba8f3df07b588c16df5772eb9db4/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">java--Lambda （5）表达式的引用</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/8aa318d1c400990e472194f3f42cb5d8/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">关闭eclipse控制台console中的非Java Server(ESLint、Angular Language Server等)</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>