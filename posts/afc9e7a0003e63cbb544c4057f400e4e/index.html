<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>计算机网络课程设计——http请求实现代理服务器的设计——代理服务器端 - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="计算机网络课程设计——http请求实现代理服务器的设计——代理服务器端" />
<meta property="og:description" content="上代码
看主函数
int main(int argc, char **argv)
知道这个程序该怎么运行了吗？？
答案是：打开cmd进入到该项目bin/debug目录下执行proxy-server.exe 3000
proxy-server.exe是可执行文件，你创建工程用的什么名就写什么（Codeblocks，VC那就是文件名）
3000代表端口号，要接收客户端的访问，进而实现代理功能
客户端代码参考下篇
https://blog.csdn.net/dayexiaofan/article/details/85257804
#include &lt;stdio.h&gt; #include &lt;winsock2.h&gt; #pragma comment(lib, &#34;ws2_32.lib&#34;) //WinSock使用的库函数 //定义常量 #define HTTP_DEF_PORT 80 //连接的缺省端口 #define HTTP_BUFFER_SIZE 1024 //缓冲区的大小 #define HTTP_FILENAME_LEN 256 //文件名长度 //定义文件类型对应的 Content-Type struct doc_type { char *suffix; //文件后缀 char *type; //Content-Type }; struct doc_type file_type[] = { {&#34;html&#34;,&#34;text/html&#34;}, //html文件 {&#34;gif&#34;,&#34;image/gif&#34;}, //图片 {&#34;jpeg&#34;,&#34;image/jpeg&#34;},//图像 {NULL,NULL} }; //http请求 char *http_res_hdr_tmpl = &#34;HTTP/1.1 200 OK\r\nServer: YeFanServer &lt;0.1&gt;\r\n&#34; &#34;Accept-Ranges: bytes\r\nContent-Length: %d\r\nConnection: close\r\n&#34;" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/afc9e7a0003e63cbb544c4057f400e4e/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2018-12-26T10:09:07+08:00" />
<meta property="article:modified_time" content="2018-12-26T10:09:07+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">计算机网络课程设计——http请求实现代理服务器的设计——代理服务器端</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p>上代码<br> 看主函数<br> int main(int argc, char **argv)<br> 知道这个程序该怎么运行了吗？？<br> 答案是：打开cmd进入到该项目bin/debug目录下执行proxy-server.exe 3000<br> proxy-server.exe是可执行文件，你创建工程用的什么名就写什么（Codeblocks，VC那就是文件名）<br> 3000代表端口号，要接收客户端的访问，进而实现代理功能<br> 客户端代码参考下篇<br> <a href="https://blog.csdn.net/dayexiaofan/article/details/85257804">https://blog.csdn.net/dayexiaofan/article/details/85257804</a></p> 
<pre><code>#include &lt;stdio.h&gt;
#include &lt;winsock2.h&gt;
#pragma comment(lib, "ws2_32.lib")  //WinSock使用的库函数

//定义常量
#define HTTP_DEF_PORT        80     //连接的缺省端口
#define HTTP_BUFFER_SIZE      1024     //缓冲区的大小
#define HTTP_FILENAME_LEN   256     //文件名长度

//定义文件类型对应的 Content-Type
struct doc_type
{
    char *suffix; //文件后缀
    char *type;   //Content-Type
};

struct doc_type file_type[] =
{
    {"html","text/html"}, //html文件
    {"gif","image/gif"},  //图片
    {"jpeg","image/jpeg"},//图像
    {NULL,NULL}
};

//http请求
char *http_res_hdr_tmpl =
    "HTTP/1.1 200 OK\r\nServer: YeFanServer &lt;0.1&gt;\r\n"
    "Accept-Ranges: bytes\r\nContent-Length: %d\r\nConnection: close\r\n"
    "Content-Type: %s;charset=UTF-8\r\n";

//根据文件后缀查找对应的 Content-Type.失败返回null
char *http_get_type_by_suffix(const char *suffix)
{
    struct doc_type *type;
    for (type = file_type; type-&gt;suffix; type++)
    {
        if (strcmp(type-&gt;suffix, suffix) == 0)
            return type-&gt;type;
    }
    return NULL;
}

//解析请求行，得到文件名及其后缀，请求行格式【get http://localhost:3000/index.html HTTP/1.1】
//buf代表字符串指针长度、buflen代表buf的长度、file_name文件名、suffix文件名后缀，由上面的函数判断
void http_parse_request_cmd(char *buf, int buflen, char *file_name, char *suffix)
{
    int length = 0;
    char *begin, *end, *bias;
    //查找URL的开始位置
    begin = strchr(buf, ' '); //在字符串buf中搜索第一次出现’空格‘的位置
    begin + = 1;
    //查找URL的结束位置
    end = strchr(begin, ' ');
    *end = 0;

    bias = strrchr(begin, '/'); //找到一个字符'/'在另一个字符串begin中末次出现的位置
    length = end - bias;

    //找到文件名的开始位置
    if ((*bias == '/') || (*bias == '\\'))
    {
        bias++;
        length--;
    }

    //得到文件名
    if (length &gt; 0)
    {
        memcpy(file_name, bias, length);
        file_name[length] = 0;
        begin = strchr(file_name, '.');
        if (begin)
            strcpy(suffix, begin + 1);
    }
}

//向客户端发送HTTP响应
int http_send_response(SOCKET h_socket, char *buf, int buf_len)
{
    int read_len, file_len, hdr_len, send_len;
    char *type;
    char read_buf[HTTP_BUFFER_SIZE];
    char http_header[HTTP_BUFFER_SIZE];
    char file_name[HTTP_FILENAME_LEN] = "index.html", suffix[16] = "html";
    FILE *res_file;

    //得到文件名和后缀
    http_parse_request_cmd(buf, buf_len, file_name, suffix);

    res_file = fopen(file_name, "rb+"); //用读/写方式打开一个二进制文件，只允许读/写数据
    if (res_file == NULL)
    {
        printf("[Web] The file [%s] is not existed\n", file_name);
        return 0;
    }

    fseek(res_file, 0, SEEK_END);
    file_len = ftell(res_file);
    fseek(res_file, 0, SEEK_SET);

    type = http_get_type_by_suffix(suffix); //文件对应的 Content-Type
    if (type == NULL)
    {
        printf("[Web] There is not the related content type\n");
        return 0;
    }

    //构造 HTTP 首部，并发送
    hdr_len = sprintf(http_header, http_res_hdr_tmpl, file_len, type);
    send_len = send(h_socket, http_header, hdr_len, 0);
    //send_len=1;
    if (send_len == SOCKET_ERROR)
    {
        fclose(res_file);
        printf("[Web] Fail to send, error = %d\n", WSAGetLastError());
        return 0;
    }
    //发送文件, HTTP 的消息体
    do
    {
        read_len = fread(read_buf, sizeof(char), HTTP_BUFFER_SIZE, res_file);
        if (read_len &gt; 0)
        {
            send_len = send(h_socket, read_buf, read_len, 0);
            file_len -= read_len;
        }
    } while ((read_len &gt; 0) &amp;&amp; (file_len &gt; 0));
    fclose(res_file);
    return 1;
}


int main(int argc, char **argv)
{
    WSADATA wsa_data;
    SOCKET  srv_socket = 0, acpt_soc;  //socket 句柄
    struct sockaddr_in serv_addr;   // 服务器地址
    struct sockaddr_in client_addr;   // 客户端地址
    char recv_buf[HTTP_BUFFER_SIZE];
    unsigned short port = HTTP_DEF_PORT;
    int from_len = sizeof(client_addr);
    int result = 0, recv_len;
    if (argc == 2) // 端口号
        port = atoi(argv[1]);
    WSAStartup(MAKEWORD(2,0), &amp;wsa_data); //初始化 WinSock 资源
    srv_socket = socket(AF_INET, SOCK_STREAM, 0); //创建 socket
    if (srv_socket == INVALID_SOCKET)
    {
        printf("[Web] socket() Fails, error = %d\n", WSAGetLastError());
        return -1;
    }

    //服务器地址
    serv_addr.sin_family = AF_INET;
    serv_addr.sin_port = htons(port);
    serv_addr.sin_addr.s_addr = htonl(INADDR_ANY);

    result = bind(srv_socket, (struct sockaddr *) &amp;serv_addr, sizeof(serv_addr));
    if (result == SOCKET_ERROR) //绑定失败
    {
        closesocket(srv_socket);
        printf("[Web] Fail to bind, error = %d\n", WSAGetLastError());
        return -1;
    }

    result = listen(srv_socket, 5);
    printf("[Web] The server is running ... ...\n");

    while (1)
    {
        acpt_soc = accept(srv_socket, (struct sockaddr *) &amp;client_addr, &amp;from_len);
        if (acpt_soc == INVALID_SOCKET) // 接受失败
        {
            printf("[Web] Fail to accept, error = %d\n", WSAGetLastError());
            break;
        }

        printf("[Web] Accepted address:[%s], port:[%d]\n",inet_ntoa(client_addr.sin_addr), ntohs(client_addr.sin_port));

        recv_len = recv(acpt_soc, recv_buf, HTTP_BUFFER_SIZE, 0);
        if (recv_len == SOCKET_ERROR) // 接收失败
        {
            closesocket(acpt_soc);
            printf("[Web] Fail to recv, error = %d\n", WSAGetLastError());
            break;
        }

        recv_buf[recv_len] = 0;

        //向客户端发送响应数据
        result = http_send_response(acpt_soc, recv_buf, recv_len);
        closesocket(acpt_soc);
    }

    closesocket(srv_socket);
    WSACleanup();
    printf("[Web] The server is stopped.\n");

    return 0;
}

</code></pre> 
<p>有问题评论区留言，看到会帮忙解决<br> <img src="https://images2.imgbox.com/f3/fa/lErooTYR_o.png" alt="在这里插入图片描述"></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/7425e4be2a6936823169dc481d3d3c5f/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">计算机网路课程设计——电子邮件客户端的设计与实现——接收邮件（POP3协议）</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/d8e9b04d83cf70bc0b191e0ae990ccee/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">计算机网络课程设计——http请求实现代理服务器的设计——客户端的设计</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>