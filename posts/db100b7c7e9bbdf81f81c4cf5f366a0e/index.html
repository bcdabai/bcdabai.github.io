<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>前端代码规范（Vue、JavaScript、CSS、HTML、代码Commite相关规范） - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="前端代码规范（Vue、JavaScript、CSS、HTML、代码Commite相关规范）" />
<meta property="og:description" content="文章目录 前言一、Vue风格指南组件名为多个单词Prop 定义应尽量详细为 v-for 设置 key 值避免 v-if 和 v-for 一起使用为组件样式设置作用域模板中的简单表达式指令缩写组件/实例的选项顺序更多内容 二、JS规范1. 引用2. 对象3. 数组4. 解构赋值5. 字符串6. 函数7. 模块8. 对象属性9. 变量声明10. 比较运算符&amp;相等更多内容 三. css规范1. 属性书写顺序2. 代码大小写3. 选择器4. 代码易读性5. 变量更多内容 四. HTML规范1. HTML代码大小写2. 元素属性3. 纯数字输入框4. 代码嵌套更多内容 五. 代码Commite规范格式type 规则（必填）scope 规则（必填）subject 规则（必填）body 规则（选填）footer 规则（选填）示例错误示例其他事项更多内容 前言 该文章旨在增强团队开发协作、提高代码质量和打造开发基石的编码规范。
一、Vue风格指南 组件名为多个单词 可以避免跟现有的以及未来的 HTML 元素相冲突，因为所有的 HTML 元素名称都是单个单词的 详情 // bad app.component(&#39;todo&#39;, { // ... }) // good app.component(&#39;todo-item&#39;, { // ... }) Prop 定义应尽量详细 prop 的定义应该尽量详细，至少需要指定其类型 详情 // bad props: [&#39;status&#39;] // good props: { status: String } // better props: { status: { type: String, required: true, validator: value =&gt; { return [ &#39;syncing&#39;, &#39;synced&#39;, &#39;version-conflict&#39;, &#39;error&#39; ]." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/db100b7c7e9bbdf81f81c4cf5f366a0e/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2021-06-20T21:54:28+08:00" />
<meta property="article:modified_time" content="2021-06-20T21:54:28+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">前端代码规范（Vue、JavaScript、CSS、HTML、代码Commite相关规范）</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-light">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p></p> 
<div class="toc"> 
 <h4>文章目录</h4> 
 <ul><li><a href="#_5" rel="nofollow">前言</a></li><li><a href="#Vue_7" rel="nofollow">一、Vue风格指南</a></li><li><ul><li><a href="#_8" rel="nofollow">组件名为多个单词</a></li><li><a href="#Prop__21" rel="nofollow">Prop 定义应尽量详细</a></li><li><a href="#_vfor__key__48" rel="nofollow">为 v-for 设置 key 值</a></li><li><a href="#_vif__vfor__68" rel="nofollow">避免 v-if 和 v-for 一起使用</a></li><li><a href="#_92" rel="nofollow">为组件样式设置作用域</a></li><li><a href="#_111" rel="nofollow">模板中的简单表达式</a></li><li><a href="#_131" rel="nofollow">指令缩写</a></li><li><a href="#_146" rel="nofollow">组件/实例的选项顺序</a></li><li><a href="#httpsv3cnvuejsorgstyleguideE9A38EE6A0BCE68C87E58D97_212" rel="nofollow">更多内容</a></li></ul> 
  </li><li><a href="#JS_213" rel="nofollow">二、JS规范</a></li><li><ul><li><a href="#1__214" rel="nofollow">1. 引用</a></li><li><a href="#2__248" rel="nofollow">2. 对象</a></li><li><a href="#3__367" rel="nofollow">3. 数组</a></li><li><a href="#4__428" rel="nofollow">4. 解构赋值</a></li><li><a href="#5__480" rel="nofollow">5. 字符串</a></li><li><a href="#6__508" rel="nofollow">6. 函数</a></li><li><a href="#7__577" rel="nofollow">7. 模块</a></li><li><a href="#8__636" rel="nofollow">8. 对象属性</a></li><li><a href="#9__663" rel="nofollow">9. 变量声明</a></li><li><a href="#10__688" rel="nofollow">10. 比较运算符&amp;相等</a></li><li><a href="#httpsguideaotuiodocsjslanguagehtml_690" rel="nofollow">更多内容</a></li></ul> 
  </li><li><a href="#_css_691" rel="nofollow">三. css规范</a></li><li><ul><li><a href="#1__692" rel="nofollow">1. 属性书写顺序</a></li><li><a href="#2__716" rel="nofollow">2. 代码大小写</a></li><li><a href="#3__729" rel="nofollow">3. 选择器</a></li><li><a href="#4__744" rel="nofollow">4. 代码易读性</a></li><li><a href="#5__769" rel="nofollow">5. 变量</a></li><li><a href="#httpsguideaotuiodocscsscodehtml_785" rel="nofollow">更多内容</a></li></ul> 
  </li><li><a href="#_HTML_786" rel="nofollow">四. HTML规范</a></li><li><ul><li><a href="#1_HTML_787" rel="nofollow">1. HTML代码大小写</a></li><li><a href="#2__799" rel="nofollow">2. 元素属性</a></li><li><a href="#3__810" rel="nofollow">3. 纯数字输入框</a></li><li><a href="#4__815" rel="nofollow">4. 代码嵌套</a></li><li><a href="#httpsguideaotuiodocshtmlcodehtml_844" rel="nofollow">更多内容</a></li></ul> 
  </li><li><a href="#_Commite_845" rel="nofollow">五. 代码Commite规范</a></li><li><ul><li><a href="#_846" rel="nofollow">格式</a></li><li><a href="#type__857" rel="nofollow">type 规则（必填）</a></li><li><a href="#scope__868" rel="nofollow">scope 规则（必填）</a></li><li><a href="#subject__873" rel="nofollow">subject 规则（必填）</a></li><li><a href="#body__882" rel="nofollow">body 规则（选填）</a></li><li><a href="#footer__889" rel="nofollow">footer 规则（选填）</a></li><li><a href="#_903" rel="nofollow">示例</a></li><li><a href="#_918" rel="nofollow">错误示例</a></li><li><a href="#_933" rel="nofollow">其他事项</a></li><li><a href="#httpstoimcteamgithubionotespagecoursevuepress02commitE8A784E88C83html_948" rel="nofollow">更多内容</a></li></ul> 
 </li></ul> 
</div> 
<p></p> 
<hr color="#000000" size='1"'> 
<h2><a id="_5"></a>前言</h2> 
<p>该文章旨在增强团队开发协作、提高代码质量和打造开发基石的编码规范。</p> 
<h2><a id="Vue_7"></a>一、Vue风格指南</h2> 
<h3><a id="_8"></a>组件名为多个单词</h3> 
<ul><li>可以避免跟现有的以及未来的 HTML 元素相冲突，因为所有的 HTML 元素名称都是单个单词的 <a href="https://v3.cn.vuejs.org/style-guide/#%E7%BB%84%E4%BB%B6%E5%90%8D%E4%B8%BA%E5%A4%9A%E4%B8%AA%E5%8D%95%E8%AF%8D%E5%BF%85%E8%A6%81" rel="nofollow">详情</a></li></ul> 
<pre><code>// bad
app.component('todo', {
  // ...
})

// good
app.component('todo-item', {
  // ...
})
</code></pre> 
<h3><a id="Prop__21"></a>Prop 定义应尽量详细</h3> 
<ul><li>prop 的定义应该尽量详细，至少需要指定其类型 <a href="https://v3.cn.vuejs.org/style-guide/#prop-%E5%AE%9A%E4%B9%89%E5%BF%85%E8%A6%81" rel="nofollow">详情</a></li></ul> 
<pre><code>// bad
props: ['status']

// good
props: {
  status: String
}

// better
props: {
  status: {
    type: String,
    required: true,
    validator: value =&gt; {
      return [
        'syncing',
        'synced',
        'version-conflict',
        'error'
      ].includes(value)
    }
  }
}
</code></pre> 
<h3><a id="_vfor__key__48"></a>为 v-for 设置 key 值</h3> 
<ul><li>在组件上总是必须用 <code>key</code> 配合 <code>v-for</code>，以便维护内部组件及其子树的状态 <a href="https://v3.cn.vuejs.org/style-guide/#%E4%B8%BA-v-for-%E8%AE%BE%E7%BD%AE-key-%E5%80%BC%E5%BF%85%E8%A6%81" rel="nofollow">详情</a></li></ul> 
<pre><code>&lt;!-- bad --&gt;
&lt;ul&gt;
  &lt;li v-for="todo in todos"&gt;
    {<!-- -->{ todo.text }}
  &lt;/li&gt;
&lt;/ul&gt;

&lt;!-- good --&gt;
&lt;ul&gt;
  &lt;li
    v-for="todo in todos"
    :key="todo.id"
  &gt;
    {<!-- -->{ todo.text }}
  &lt;/li&gt;
&lt;/ul&gt;
</code></pre> 
<h3><a id="_vif__vfor__68"></a>避免 v-if 和 v-for 一起使用</h3> 
<ul><li>永远不要把 <code>v-if</code> 和 <code>v-for</code> 同时用在同一个元素上 <a href="https://v3.cn.vuejs.org/style-guide/#%E9%81%BF%E5%85%8D-v-if-%E5%92%8C-v-for-%E4%B8%80%E8%B5%B7%E4%BD%BF%E7%94%A8%E5%BF%85%E8%A6%81" rel="nofollow">详情</a></li></ul> 
<pre><code>&lt;!-- bad --&gt;
&lt;ul&gt;
  &lt;li
    v-for="user in users"
    v-if="user.isActive"
    :key="user.id"
  &gt;
    {<!-- -->{ user.name }}
  &lt;/li&gt;
&lt;/ul&gt;

&lt;!-- good --&gt;
&lt;ul&gt;
  &lt;li
    v-for="user in activeUsers"
    :key="user.id"
  &gt;
    {<!-- -->{ user.name }}
  &lt;/li&gt;
&lt;/ul&gt;
</code></pre> 
<h3><a id="_92"></a>为组件样式设置作用域</h3> 
<ul><li>设置一致的作用域会确保样式只会运用在想要作用的组件上 <a href="https://v3.cn.vuejs.org/style-guide/#%E4%B8%BA%E7%BB%84%E4%BB%B6%E6%A0%B7%E5%BC%8F%E8%AE%BE%E7%BD%AE%E4%BD%9C%E7%94%A8%E5%9F%9F%E5%BF%85%E8%A6%81" rel="nofollow">详情</a></li></ul> 
<pre><code>&lt;!-- bad --&gt;
&lt;style&gt;
.btn-close {
  background-color: red;
}
&lt;/style&gt;

&lt;!-- good --&gt;
&lt;!-- 使用 `scoped` attribute --&gt;
&lt;style scoped&gt;
.button {
  border: none;
  border-radius: 2px;
}
&lt;/style&gt;
</code></pre> 
<h3><a id="_111"></a>模板中的简单表达式</h3> 
<ul><li>组件模板应该只包含简单的表达式，复杂的表达式则应该重构为计算属性或方法 <a href="https://v3.cn.vuejs.org/style-guide/#%E6%A8%A1%E6%9D%BF%E4%B8%AD%E7%9A%84%E7%AE%80%E5%8D%95%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%BC%BA%E7%83%88%E6%8E%A8%E8%8D%90" rel="nofollow">详情</a></li></ul> 
<pre><code>&lt;!-- bad --&gt;
{<!-- -->{
  fullName.split(' ').map((word) =&gt; {
    return word[0].toUpperCase() + word.slice(1)
  }).join(' ')
}}

// good
// 复杂表达式已经移入一个计算属性
computed: {
  normalizedFullName() {
    return this.fullName.split(' ')
      .map(word =&gt; word[0].toUpperCase() + word.slice(1))
      .join(' ')
  }
}
</code></pre> 
<h3><a id="_131"></a>指令缩写</h3> 
<ul><li>指令缩写 (用 <code>:</code> 表示 <code>v-bind:</code>，<code>@</code> 表示 <code>v-on:</code> 和用 <code>#</code> 表示 <code>v-slot</code>) 应该要么都用要么都不用 <a href="https://v3.cn.vuejs.org/style-guide/#%E6%8C%87%E4%BB%A4%E7%BC%A9%E5%86%99%E5%BC%BA%E7%83%88%E6%8E%A8%E8%8D%90" rel="nofollow">详情</a></li></ul> 
<pre><code>&lt;!-- bad --&gt;
&lt;input
  v-bind:value="newTodoText"
  @focus="onFocus"
&gt;

&lt;!-- good --&gt;
&lt;input
  :value="newTodoText"
  @focus="onFocus"
&gt;
</code></pre> 
<h3><a id="_146"></a>组件/实例的选项顺序</h3> 
<ul><li>组件/实例的选项应该有统一的顺序 <a href="https://v3.cn.vuejs.org/style-guide/#%E7%BB%84%E4%BB%B6-%E5%AE%9E%E4%BE%8B%E7%9A%84%E9%80%89%E9%A1%B9%E9%A1%BA%E5%BA%8F%E6%8E%A8%E8%8D%90" rel="nofollow">详情</a></li></ul> 
<ol><li> <p><b>全局感知</b> (要求组件以外的知识)</p> <p><code>name</code></p> </li><li> <p><b>模板依赖</b> (模板内使用的资源)</p> <p><code>components</code></p> <p><code>directives</code></p> </li><li> <p><b>组合</b> (向选项里合并 property)</p> <p><code>extends</code></p> <p><code>mixins</code></p> <p><code>provide / inject</code></p> </li><li> <p><b>接口</b> (组件的接口)</p> <p><code>inheritAttrs</code></p> <p><code>props</code></p> <p><code>emits</code></p> </li><li> <p><b>组合式 API</b> (使用组合式 API 的入口点)</p> <p><code>setup</code></p> </li><li> <p><b>本地状态</b> (本地的响应式 property)</p> <p><code>data</code></p> <p><code>computed</code></p> </li><li> <p><b>事件</b> (通过响应式事件触发的回调)</p> <p><code>watch</code></p> <p>生命周期钩子 (按照它们被调用的顺序)</p> 
  <ul><li><code>beforeCreate</code></li><li><code>created</code></li><li><code>beforeMount</code></li><li><code>mounted</code></li><li><code>beforeUpdate</code></li><li><code>activated</code></li><li><code>deactivated</code></li><li><code>beforeUnmount</code></li><li><code>unmounted</code></li><li><code>errorCaptured</code></li><li><code>renderTracked</code></li><li><code>renderTriggered</code></li></ul> </li><li> <p><b>非响应式的 property</b> (不依赖响应性系统的实例 property)</p> <p><code>methods</code></p> </li><li> <p><b>渲染</b> (组件输出的声明式描述)</p> <p><code>template / render</code></p> </li></ol> 
<h3><a id="httpsv3cnvuejsorgstyleguideE9A38EE6A0BCE68C87E58D97_212"></a><a href="https://v3.cn.vuejs.org/style-guide/#%E9%A3%8E%E6%A0%BC%E6%8C%87%E5%8D%97" rel="nofollow">更多内容</a></h3> 
<h2><a id="JS_213"></a>二、JS规范</h2> 
<h3><a id="1__214"></a>1. 引用</h3> 
<ul><li>请记得 <code>const</code> 和 <code>let</code> 都是<b>块级作用域</b>，<code>var</code> 是<b>函数级作用域</b>；<pre><code>{
  let a = 1
  const b = 1
}
console.log(a) // ReferenceError
console.log(b) // ReferenceError
</code></pre> </li><li>对所有引用都使用 <code>const</code>，不要使用 <code>var</code>；<pre><code>// bad
var a = 1
var b = 2

// good
const a = 1
const b = 2
</code></pre> </li><li>如果引用是可变动的，使用 <code>let</code> 代替 <code>var</code>。<pre><code>// bad
var count = 1
if (count &lt; 10) {
  count += 1
}

// good
let count = 1
if (count &lt; 10) {
  count += 1
}
</code></pre> </li></ul> 
<h3><a id="2__248"></a>2. 对象</h3> 
<ul><li> <p>请使用字面量值创建对象；</p> <pre><code>// bad
const a = new Object{}

// good
const a = {}
</code></pre> </li><li> <p>当使用动态属性名创建对象时，请使用对象计算属性名来进行创建；</p> <pre><code>function getKey(k) {
  return `a key named ${k}`
}

// bad
const obj = {
  id: 5,
  name: 'San Francisco'
};
obj[getKey('enabled')] = true

// good
const obj = {
  id: 5,
  name: 'San Francisco',
  [getKey('enabled')]: true
};
</code></pre> </li><li> <p>请使用对象方法和属性的简写方式；</p> <pre><code>// bad
const item = {
  value: 1,

  addValue: function (val) {
    return item.value + val
  }
}

// good
const item = {
  value: 1,

  addValue (val) {
    return item.value + val
  }
}
</code></pre> </li><li> <p>请使用对象属性值的简写方式；</p> <pre><code>const job = 'FrontEnd'

// bad
const item = {
  job: job
}

// good
const item = {
  job
}
</code></pre> </li><li> <p>将简写的对象属性分组后统一放到对象声明的开头；</p> <pre><code>const job = 'FrontEnd'
const department = 'JDC'

// bad
const item = {
  sex: 'male',
  job,
  age: 25,
  department
}

// good
const item = {
  job,
  department,
  sex: 'male',
  age: 25
}
</code></pre> </li><li> <p>只对非法标识符的属性使用引号；</p> <pre><code>// bad
const bad = {
  'foo': 3,
  'bar': 4,
  'data-blah': 5
}

// good
const good = {
  foo: 3,
  bar: 4,
  'data-blah': 5
}
</code></pre> </li><li> <p>优先使用对象展开运算符 <code>...</code> 来做对象浅拷贝而不是使用 <code>Object.assign</code>，使用对象剩余操作符来获得一个包含确定的剩余属性的新对象。</p> <pre><code>// very bad
const original = { a: 1, b: 2 }
const copy = Object.assign(original, { c: 3 }) // this mutates `original` ಠ_ಠ
delete copy.a // so does this

// bad
const original = { a: 1, b: 2 }
const copy = Object.assign({}, original, { c: 3 }) // copy =&gt; { a: 1, b: 2, c: 3 }

// good
const original = { a: 1, b: 2 }
const copy = { ...original, c: 3 } // copy =&gt; { a: 1, b: 2, c: 3 }

const { a, ...noA } = copy // noA =&gt; { b: 2, c: 3 }
</code></pre> </li></ul> 
<h3><a id="3__367"></a>3. 数组</h3> 
<ul><li>请使用字面量值创建数组<pre><code>// bad
const items = new Array()

// good
const items = []
</code></pre> </li><li>向数组中添加元素时，请使用 <code>push</code> 方法<pre><code>const items = []

// bad
items[items.length] = 'test'

// good
items.push('test')
</code></pre> </li><li>使用展开运算符 … 复制数组<pre><code>// bad
const items = []
const itemsCopy = []
const len = items.length
let i

// bad
for (i = 0; i &lt; len; i++) {
  itemsCopy[i] = items[i]
}

// good
itemsCopy = [...items]
</code></pre> </li><li>使用数组的 <code>map</code> 等方法时，请使用 <code>return</code> 声明，如果是单一声明语句的情况，可省略 <code>return</code><pre><code>// good
[1, 2, 3].map(x =&gt; {
  const y = x + 1
  return x * y
})

// good
[1, 2, 3].map(x =&gt; x + 1)

// bad
const flat = {}
[[0, 1], [2, 3], [4, 5]].reduce((memo, item, index) =&gt; {
  const flatten = memo.concat(item)
  flat[index] = flatten
})

// good
const flat = {}
[[0, 1], [2, 3], [4, 5]].reduce((memo, item, index) =&gt; {
  const flatten = memo.concat(item)
  flat[index] = flatten
  return flatten
})
</code></pre> </li></ul> 
<h3><a id="4__428"></a>4. 解构赋值</h3> 
<ul><li>当需要使用对象的多个属性时，请使用解构赋值<pre><code>// bad
function getFullName (user) {
  const firstName = user.firstName
  const lastName = user.lastName

  return `${firstName} ${lastName}`
}

// good
function getFullName (user) {
  const { firstName, lastName } = user

  return `${firstName} ${lastName}`
}

// better
function getFullName ({ firstName, lastName }) {
  return `${firstName} ${lastName}`
}
</code></pre> </li><li>当需要使用数组的多个值时，请同样使用解构赋值<pre><code>const arr = [1, 2, 3, 4]

// bad
const first = arr[0]
const second = arr[1]

// good
const [first, second] = arr
</code></pre> </li><li>函数需要回传多个值时，请使用对象的解构，而不是数组的解构<pre><code>// bad
function doSomething () {
  return [top, right, bottom, left]
}

// 如果是数组解构，那么在调用时就需要考虑数据的顺序
const [top, xx, xxx, left] = doSomething()

// good
function doSomething () {
  return { top, right, bottom, left }
}

// 此时不需要考虑数据的顺序
const { top, left } = doSomething()
</code></pre> </li></ul> 
<h3><a id="5__480"></a>5. 字符串</h3> 
<ul><li>字符串统一使用单引号的形式 <code>'</code><pre><code>// bad
const department = "JDC"

// good
const department = 'JDC'
</code></pre> </li><li>字符串太长的时候，请不要使用字符串连接符换行 <code>\</code>，而是使用 <code>+</code><pre><code>const str = '前端代码规范 前端代码规范 前端代码规范' +
  '前端代码规范 前端代码规范 前端代码规范' +
  '前端代码规范 前端代码规范'
</code></pre> </li><li>程序化生成字符串时，请使用模板字符串<pre><code>const test = 'test'

// bad
const str = ['a', 'b', test].join()

// bad
const str = 'a' + 'b' + test

// good
const str = `ab${test}`
</code></pre> </li></ul> 
<h3><a id="6__508"></a>6. 函数</h3> 
<ul><li>不要使用 <code>arguments</code>，使用 剩余运算符 <code>...</code><pre><code>// bad
function test () {
  const args = Array.prototype.slice.call(arguments)
  return args.join('')
}

// good
function test (...args) {
  return args.join('')
}
</code></pre> </li><li>使用参数默认值语法而不是修改函数参数<pre><code>// really bad
function handleThings (opts) {
  // No! We shouldn't mutate function arguments.
  // Double bad: if opts is falsy it'll be set to an object which may
  // be what you want but it can introduce subtle bugs.
  opts = opts || {}
  // ...
}

// still bad
function handleThings (opts) {
  if (opts === void 0) {
    opts = {}
  }
  // ...
}

// good
function handleThings (opts = { }) {
  // ...
}
</code></pre> </li><li>将参数默认值放在最后<pre><code>// bad
function handleThings (opts = {}, name) {
  // ...
}

// good
function handleThings (name, opts = {}) {
  // ...
}
</code></pre> </li><li>不要更改参数或重新赋值<pre><code>// bad
function f1 (a) {
  a = 1
}

function f2 (a) {
  if (!a) { a = 1 }
}

// good
function f3 (a) {
  const b = a || 1
}

function f4 (a = 1) {
}
</code></pre> </li></ul> 
<h3><a id="7__577"></a>7. 模块</h3> 
<ul><li>使用标准的 ES6 模块语法 <code>import</code> 和 <code>export</code><pre><code>// bad
const util = require('./util')
module.exports = util

// good
import Util from './util'
export default Util

// better
import { Util } from './util'
export default Util
</code></pre> </li><li>同个文件每个模块只允许 <code>import</code> 一次，有多个 <code>import</code> 请书写在一起<pre><code>// bad
import foo from 'foo'
// … some other imports … //
import { named1, named2 } from 'foo'

// good
import foo, { named1, named2 } from 'foo'

// good
import foo, {
  named1,
  named2
} from 'foo'
</code></pre> </li><li>将所有 <code>import</code> 语句放在文件最前方<pre><code>// bad
import foo from 'foo'
foo.init()

import bar from 'bar'

// good
import foo from 'foo'
import bar from 'bar'

foo.init()
</code></pre> </li><li>多行导入应该像多行数组和对象文字一样缩进<pre><code>// bad
import { longNameA, longNameB, longNameC, longNameD, longNameE } from 'path'

// good
import {
  longNameA,
  longNameB,
  longNameC,
  longNameD,
  longNameE
} from 'path'
</code></pre> </li></ul> 
<h3><a id="8__636"></a>8. 对象属性</h3> 
<ul><li>使用 <code>.</code>来访问对象属性<pre><code>const joke = {
  name: 'haha',
  age: 28
}

// bad
const name = joke['name']

// good
const name = joke.name
</code></pre> </li><li>当访问的属性是变量时使用 <code>[]</code><pre><code>const luke = {
  jedi: true,
  age: 28,
}

function getProp (prop) {
  return luke[prop]
}

const isJedi = getProp('jedi')
</code></pre> </li></ul> 
<h3><a id="9__663"></a>9. 变量声明</h3> 
<ul><li>声明变量时，请使用 <code>const</code>、<code>let</code> 关键字，如果没有写关键字，变量就会暴露在全局上下文中，这样很可能会和现有变量冲突，另外，也很难明确该变量的作用域是什么<pre><code>// bad
demo = new Demo()

// good
const demo = new Demo()
</code></pre> </li><li>将所有的 <code>const</code> 和 <code>let</code> 分组<pre><code>// bad
let a
const b
let c
const d
let e

// good
const b
const d
let a
let c
let e
</code></pre> </li></ul> 
<h3><a id="10__688"></a>10. 比较运算符&amp;相等</h3> 
<ul><li>使用 <code>===</code> 和 <code>!==</code> 而非 <code>==</code> 和 <code>!=</code></li></ul> 
<h3><a id="httpsguideaotuiodocsjslanguagehtml_690"></a><a href="https://guide.aotu.io/docs/js/language.html" rel="nofollow">更多内容</a></h3> 
<h2><a id="_css_691"></a>三. css规范</h2> 
<h3><a id="1__692"></a>1. 属性书写顺序</h3> 
<ol><li>布局定位属性：display / position / float / clear / visibility / overflow</li><li>自身属性：width / height / margin / padding / border / background</li><li>文本属性：color / font / text-decoration / text-align / vertical-align / white- space / break-word</li><li>其他属性（CSS3）：content / cursor / border-radius / box-shadow / text-shadow / background:linear-gradient …<pre><code>.jdc {
    display: block;
    position: relative;
    float: left;
    width: 100px;
    height: 100px;
    margin: 0 10px;
    padding: 20px 0;
    font-family: Arial, 'Helvetica Neue', Helvetica, sans-serif;
    color: #333;
    background: rgba(0,0,0,.5);
    -webkit-border-radius: 10px;
    -moz-border-radius: 10px;
    -o-border-radius: 10px;
    -ms-border-radius: 10px;
    border-radius: 10px;
}
</code></pre> </li></ol> 
<h3><a id="2__716"></a>2. 代码大小写</h3> 
<ul><li>样式选择器，属性名，属性值关键字全部使用小写字母书写<pre><code>/* 推荐 */
.jdc{
	display:block;
}
	
/* 不推荐 */
.JDC{
	DISPLAY:BLOCK;
}
</code></pre> </li></ul> 
<h3><a id="3__729"></a>3. 选择器</h3> 
<ul><li>尽量少用通用选择器 <code>*</code></li><li>不使用 ID 选择器</li><li>不使用无具体语义定义的标签选择器<pre><code>/* 推荐 */
.jdc {}
.jdc li {}
.jdc li p{}

/* 不推荐 */
*{}
#jdc {}
.jdc div{}
</code></pre> </li></ul> 
<h3><a id="4__744"></a>4. 代码易读性</h3> 
<ul><li>属性值十六进制数值能用简写的尽量用简写<pre><code>/* 推荐 */
.jdc {
    color: #fff;
}

/* 不推荐 */
.jdc {
    color: #ffffff;
}
</code></pre> </li><li>不要为 0 指明单位<pre><code>/* 推荐 */
.jdc {
    margin: 0 10px;
}

/* 不推荐 */
.jdc {
    margin: 0px 10px;
}
</code></pre> </li></ul> 
<h3><a id="5__769"></a>5. 变量</h3> 
<ul><li>可复用属性尽量抽离为页面变量，易于统一维护<pre><code>// CSS
.jdc {
    color: red;
    border-color: red;
}

// SCSS
$color: red;
.jdc {
    color: $color;
    border-color: $color;
}
</code></pre> </li></ul> 
<h3><a id="httpsguideaotuiodocscsscodehtml_785"></a><a href="https://guide.aotu.io/docs/css/code.html" rel="nofollow">更多内容</a></h3> 
<h2><a id="_HTML_786"></a>四. HTML规范</h2> 
<h3><a id="1_HTML_787"></a>1. HTML代码大小写</h3> 
<ul><li>HTML标签名、类名、标签属性和大部分属性值统一用小写<pre><code>&lt;!-- 推荐 --&gt;
&lt;input type="text"&gt;
&lt;input type="radio" name="name" checked="checked" &gt;

&lt;!-- 不推荐 --&gt;
&lt;input type=text&gt;	
&lt;input type='text'&gt;
&lt;input type="radio" name="name" checked &gt;
</code></pre> </li></ul> 
<h3><a id="2__799"></a>2. 元素属性</h3> 
<ul><li>元素属性值使用双引号语法</li><li>元素属性值可以写上的都写上<pre><code>&lt;!-- 推荐 --&gt;
&lt;div class="demo"&gt;&lt;/div&gt;

&lt;!-- 不推荐 --&gt;
&lt;div class="DEMO"&gt;&lt;/div&gt;
&lt;DIV CLASS="DEMO"&gt;&lt;/DIV&gt;
</code></pre> </li></ul> 
<h3><a id="3__810"></a>3. 纯数字输入框</h3> 
<ul><li>使用 <code>type="tel"</code> 而不是 <code>type="number"</code><pre><code>&lt;input type="tel"&gt;
</code></pre> </li></ul> 
<h3><a id="4__815"></a>4. 代码嵌套</h3> 
<ul><li>元素嵌套规范，每个块状元素独立一行，内联元素可选<pre><code>&lt;!-- 推荐 --&gt;
&lt;div&gt;
    &lt;h1&gt;&lt;/h1&gt;
    &lt;p&gt;&lt;/p&gt;
&lt;/div&gt;	
&lt;p&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;/p&gt;

&lt;!-- 不推荐 --&gt;
&lt;div&gt;
    &lt;h1&gt;&lt;/h1&gt;&lt;p&gt;&lt;/p&gt;
&lt;/div&gt;	
&lt;p&gt; 
    &lt;span&gt;&lt;/span&gt;
    &lt;span&gt;&lt;/span&gt;
&lt;/p&gt;
</code></pre> </li><li>段落元素与标题元素只能嵌套内联元素<pre><code>&lt;!-- 推荐 --&gt;
&lt;h1&gt;&lt;span&gt;&lt;/span&gt;&lt;/h1&gt;
&lt;p&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;/p&gt;

&lt;!-- 不推荐 --&gt;
&lt;h1&gt;&lt;div&gt;&lt;/div&gt;&lt;/h1&gt;
&lt;p&gt;&lt;div&gt;&lt;/div&gt;&lt;div&gt;&lt;/div&gt;&lt;/p&gt;
</code></pre> </li></ul> 
<h3><a id="httpsguideaotuiodocshtmlcodehtml_844"></a><a href="https://guide.aotu.io/docs/html/code.html" rel="nofollow">更多内容</a></h3> 
<h2><a id="_Commite_845"></a>五. 代码Commite规范</h2> 
<h3><a id="_846"></a>格式</h3> 
<p>Commit 规范采用常用的 Angular 团队所使用的规范，具体如下：</p> 
<pre><code>
&lt;type&gt;&lt;scope&gt;: &lt;subject&gt;
&lt;空行&gt;
&lt;body&gt;
&lt;空行&gt;
&lt;footer&gt;

</code></pre> 
<h3><a id="type__857"></a>type 规则（必填）</h3> 
<p>type 代表本次 commit 的类型，有且仅有如下几种：</p> 
<ul><li>feat - 功能性更新</li><li>fix - bug 修复</li><li>style - 改变代码格式（如删除空行、格式化代码、去除不必要的分号等等）</li><li>refactor - 既不是功能更新也不是 bug 修复的更改（建议对代码进行重构的时候使用）</li><li>perf - 代码改变提高了性能</li><li>test - 添加测试用例或者修改测试用例</li><li>build - 由打包工具造成的改变（如gulp、webpack编译文件）</li><li>chore - 既不是源码的修改，也不是测试用例的修改（修改项目相关配置时可以使用）</li><li>revert - 撤销之前的提交</li></ul> 
<h3><a id="scope__868"></a>scope 规则（必填）</h3> 
<p>scope 代表本次 commit 的影响范围，暂定规则如下：</p> 
<ul><li>本次 commit 修改的组件</li><li>本次 commit 修改的文件</li><li>本次 commit 修改的文件夹</li></ul> 
<h3><a id="subject__873"></a>subject 规则（必填）</h3> 
<p>用一句简短的话描述本次修改的内容，<b>不要超过30个汉字，以动词开头</b></p> 
<p>建议选用如下动词：</p> 
<ul><li>新增（组件、属性、事件、API）</li><li>删除</li><li>修正</li><li>修复</li><li>修改</li></ul> 
<h3><a id="body__882"></a>body 规则（选填）</h3> 
<p>如果 subject 无法对本次 commit 进行清楚的阐释，则在 body 中进行补充说明。</p> 
<p>建议填写以下内容：</p> 
<ul><li>为什么进行本次修改</li><li>本次修改了哪些内容</li><li>修改后的影响有哪些</li></ul> 
<h3><a id="footer__889"></a>footer 规则（选填）</h3> 
<p>footer 中只填写两种内容：</p> 
<ol><li>这次 commit 和某个 issue 相关联，提交后能关闭该 issue，则填写：<pre><code>
close #748

</code></pre> </li><li>这次 commit 有不兼容上个版本的代码，则以BREAKING CHANGE:开头填写不兼容信息，如下：<pre><code>
BREAKING CHANGE: Message组件top属性单位由px改为rpx

</code></pre> </li></ol> 
<h3><a id="_903"></a>示例</h3> 
<p>一个<b>完整规范且正确</b>的 Commit 示例如下：</p> 
<pre><code>
fix(NoticeBar)：修改top属性单位为rpx

NoticeBar组件的top属性单位之前为px，会出现无法自适应的问题。
更改为rpx后可对屏幕进行自适应。

BREAKING CHANGE: Notice-Bar组件top属性单位由px改为rpx

Close #745

</code></pre> 
<h3><a id="_918"></a>错误示例</h3> 
<ol><li><code>subject</code>描述中出现组件名称<pre><code>
feat(Button): Button 组件新增 size 属性

</code></pre> <b>因type（括号中的内容）已经指定了组件，所以 subject 描述信息中无需再指明组件</b></li><li>单词未添加空格<pre><code>
feat(Button): 新增size属性

</code></pre> <b>为了生成的 changelog 的可读性，所有的单词左右都需要添加一个空格</b></li></ol> 
<h3><a id="_933"></a>其他事项</h3> 
<p>一个 commit 应该是一个有意义的 commit</p> 
<p><b>有意义</b>的定义如下：</p> 
<ul><li>新增了一个功能或组件</li><li>修复了一个bug</li><li>解决了一个issue</li><li>重构了某个组件或文件</li><li>改善了现有代码的构建流程或风格</li></ul> 
<p><b>无意义</b>的定义如下：</p> 
<ul><li>临时工作进度保存</li><li>误提交的 commit</li><li>commit 信息不规范或缺失</li><li>subject 无法准确描述此次 commit</li></ul> 
<h3><a id="httpstoimcteamgithubionotespagecoursevuepress02commitE8A784E88C83html_948"></a><a href="https://toimc-team.github.io/notes-page/course/vuepress/02-commit%E8%A7%84%E8%8C%83.html" rel="nofollow">更多内容</a></h3>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/36cdcf6cd17314d91b9d01c06b2d53e3/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">SCI回复审稿意见的模板</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/3444096a77cb3aa8f578e79299e1b57f/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">大专计算机专业一般是几年制,大专需要读几年</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>