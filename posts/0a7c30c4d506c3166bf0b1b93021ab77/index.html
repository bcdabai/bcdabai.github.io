<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>【模块划分】 - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="【模块划分】" />
<meta property="og:description" content="模块的划分
所谓软件的模块划分是指在软件设计过程中，为了能够对系统开发流程进行管理，保证系统的稳定性以及后期的可维护性，从而对软件开发按照一定的准则进行模块的划分。根据模块来进行系统开发，可提高系统的开发进度，明确系统的需求，保证系统的稳定性。
在系统设计的过程中，由于每个系统实现的功能不同，所以每个系统的需求也将会不同。也就导致了系统的设计方案不同。在系统的开发过程中，有些需求在属性上往往会有一定的关联性，而有些需求之间的联系很少。如果在设计的时候，不对需求进行归类划分的话，在后期的过程中往往会造成混乱。
在系统定义和软件计划等阶段进行基本模型设计时，以底层功能为单位，对处理、输入、输出、文件等进行了初步的研究和设定，并且研究了人机接口等问题，但是，以此新系统基本模型设计为基础所做出的各层次基本模型都只是表达出了各个业务处理之间的自然逻辑，并没有表达出计算机处理的流程。
因此，在具体着手软件设计工作之前，有必要先对基本模型图中规定为计算机处理的部分进行处理模块的划分，以便大体上明确其处理的流程。当然，这时候所划分的处理模块还不能包含具体的物理内容 (例如，其中的输入、输出和文件等仍然只能是抽象的) 。因为这些物理内容正是需要通过以后的设计工作才能逐步具体起来。
软件设计过程中通过对软件进行模块划分可以达到一下的好处：
(1)使程序实现的逻辑更加清晰，可读性强。
(2)使多人合作开发的分工更加明确，容易控制。
(3)能充分利用可以重用的代码。
(4)抽象出可公用的模块，可维护性强，以避免同一处修改在多个地方出现。
(5)系统运行可方便地选择不同的流程。
(6)可基于模块化设计优秀的遗留系统，方便的组装开发新的相似系统，甚至一个全新的系统。
系统性能的衡量标准
计算机处理模块的划分使新系统从基本 (逻辑) 模型向实际的计算机处理系统迈开了第一步。显然，模块划分的好坏将会影响软件乃至整个系统性能的优劣。
不同的对象对系统性能的要求有所不同，要制订出适应于所有系统的衡量标准，以判别系统性能的优劣是有困难的。一般软件系统性能的衡量标准主要有以下四个方面的内容：
（1）系统效率
对于批处理系统来说，指的是单位时间内处理的业务量；对于联机实时处理系统来说，则主要是指响应时间。
（2）系统工作质量
主要是指系统信息处理的质量，例如所提供数据的精度、输出报表的易读性等等。
（3）系统可靠性
是指系统抵御各种外界干扰的能力。例如，输入的错误数据能否检查出来；文件中数据一旦被破坏能否恢复；电源断电等意外事故发生时，有无应急措施等等。
（4）系统的可维护性
是指纠正系统出现的错误和缺陷，以及为满足新的要求进行扩充或压缩的容易程度。应该看到，任何系统都不可能永久不变，由于环境变化等诸因素，系统需要不断地进行修改和完善。
上述四个衡量标准中，可维护性占有很重要的地位。因为如果系统的其他指标都很好，唯独可维护性很差，那么一旦由于某些条件的改变需要对系统进行修改时，就会因此而无法进行修改，最后不得不重新设计系统。相反，如果系统的可维护性很好，那么，尽管其他指标差一些，也可以在使用中进一步进行修改，并逐步加以完善。
软件结构
软件结构表示程序的系统结构，它以层次结构表示一种控制层次体系，它并不表示软件的具体过程 (例如各个进程的顺序、判定和操作重复等) 。
软件结构表示了软件元素 (模块) 之间的关系，例如调用关系、包含关系、从属关系和嵌套关系等。下图表示了一个软件结构。
（1）深度
深度表示软件结构中控制层数。例如图4-1是一个四层软件结构。深度往往能粗略地表示一个系统的大小和复杂程度，软件结构的深度和程序长度之间存在着某种对应关系。
（2）宽度
宽度是软件内同一层次上的模块总数。一般来说，结构的宽度越大，则系统就越复杂。
（3）扇出
扇出是由一个模块直接控制的其他模块数的一种度量。例如图4-1中模块A，B，C，D的扇出分别为3，2，1，2。扇出过大，表示模块过分复杂，需要控制和协调的下级模块太多。扇出的上限一般为5～9，平均一般为3或4。
（4）扇入
扇入表示有多少个上级模块直接控制一个给定的模块。例如图4-1中模块R和S的扇入分别为3和1。扇入过大，意味着共享该模块的上级模块数目多，这有一定的益处，但是决不能违背模块的独立性原则而片面追求高扇入。
模块划分的方法
很多人都参与过一些项目的设计，在很多项目设计过程中对于模块划分大多都是基于功能进行划分。这样划分有一个好处，由于在一个项目的设计过程中，有着诸多的需求。而很多需求都可以进行归类,根据功能需求分类的方法进行模块的划分。可以让需求在归类上得到明确的划分，而且通过功能需求进行软件的模块划分使得功能分解,任务分配等方面都有较好的分解。
按照任务需求进行模块划分是一种基于面向过程的划分方法，利用面向过程的思想进行系统设计的好处是能够清晰的了解系统的开发流程。对于任务的分工、管理，系统功能接口的制定在面向过程的思想中都能够得到良好的体现。
按任务需求进行模块划分的主要步骤如下：
(1)分析系统的需求，得出需求列表；
(2)对需求进行归类，并划分出优先级；
(3)根据需求对系统进行模块分析，抽取出核心模块；
(4)将核心模块进行细化扩展，逐层得到各个子模块，完成模块划分。
在很多情况下，在划分任务需求的时候，有些需求和很多个模块均有联系，这个时候，通过需求来确定模块的划分就不能够降低模块之间的耦合了。而且有些模块划分出来里面涉及的数据类型多种多样，显然这个时候根据系统所抽象出来的数据模型来进行模块划分更加有利。
在系统进行模块划分之前，往往都会有一个数据模型的抽象过程，根据系统的特性抽象出能够代表系统的数据模型。根据数据模型来进行模块划分，可以充分降低系统之间的数据耦合度。按照数据模型进行模块的划分，降低每个模块所包含的数据复杂程度，简化数据接口设计。同时，对于数据的封装可以起到良好的作用，提高了系统的封闭性。
抽象数据模型的模块划分方案是一种基于面向对象的思想进行的。这种思想的特点就是不以系统的需求作为模块的划分方法，而是以抽象出系统的数据对象模型的思想对模块进行划分。而利用这种思想进行模块划分的主要好处能够接近人的思维方式对问题进行划分，提高系统的可理解性，可以从较高层次上对系统进行把握！
按照数据模型进行模块划分的主要步骤如下：
(1)根据系统框架抽象出系统的核心数据模型；
(2)根据核心数据模型将系统功能细化，并将数据模型与视图等剥离，细化数据的流向；
(3)依据数据的流向制定模块和接口，完成模块划分。
模块划分的基本原则
“模块”实际上是一个已经得到广泛应用的概念，许多程序设计语言中的所谓子程序、分程序、过程、函数等实质上都具有模块的特性。这些特性包括模块的名字、输入和输出信息、功能、内部逻辑构造、可被调用以及可调用其他模块等。
既然系统的可维护性是评价系统性能的首要因素，那么，应该怎样做才能使系统变得容易修改呢？通常一个系统是由若干个子系统组成的；每个子系统又可分解成更小的子系统。在实际工作中，要求改变整个系统的结构的情况是极为少见的。所谓系统的修改往往只是对某些子系统的某些细节作一些变动，也就是说，这些修改通常都是局部的。
然而，由于各子系统之间是相互关联的，对其中某个子系统的修改，可能会通过这些相互关系而影响到其他子系统，乃至波及整个系统。这样，就可能会造成动了一处而引出来好几处的问题，越改越乱，甚至会出现使修改工作无法进行下去的局面。
由此可见，要使系统易于修改，必须使每一个修改都尽可能地局部化。这就要求在进行系统的模块划分时，要使模块的内部联系尽可能地强，而模块间的外部联系尽可能地弱，即尽可能地提高模块的相对独立性。这样，在对其中某一个模块作修改时，它所造成的影响只局限在本模块范围内，而不至于波及整个系统。
当系统被划分成若干个模块之后，模块之间的关系称之为块间关系，而模块内部的实现逻辑都属于模块内部子系统。对于软件的模块划分要遵循一些基本原则，遵循基本原则进行模块划分所设计出来的系统具有可靠性强，系统稳定，利于维护和升级。
设计模块往往要注意很多的问题，好的模块划分方案可以对系统开发带来很多的便利，提高整个系统的开发效率，而且对于系统后期的维护难度也会降低不少。反之，如果模块划分的不恰当，不仅不能带来便利，往往还会影响程序的开发。
在进行软件模块划分的时候，首先要遵从的一个准则就是确保每个模块的独立性，所谓模块独立性，即：不同模块相互之间的联系尽可能少，尽可能的减少公共的变量和数据结构。每个模块尽可能的在逻辑上独立，功能上完整单一，数据上与其他模块无太多的耦合。
模块独立性保证了每个模块实现功能的单一性，接口的统一性，可以将模块之间的耦合度充分降低。在进行软件模块划分的时候，如果各个模块之间的联系过多，模块独立性差容易引起系统结构混乱，层次划分不清晰。导致有的需求和多个模块均有关联，严重影响系统设计。
对于模块独立性的好处主要可以归纳为以下几点：
(1)模块功能完整独立；" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/0a7c30c4d506c3166bf0b1b93021ab77/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-07-03T15:32:01+08:00" />
<meta property="article:modified_time" content="2023-07-03T15:32:01+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">【模块划分】</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p><span style="color:#FF0000;"><strong>模块的划分</strong></span></p> 
<p>所谓软件的模块划分是指在软件设计过程中，为了能够对系统开发流程进行管理，保证系统的稳定性以及后期的可维护性，从而对软件开发按照一定的准则进行模块的划分。根据模块来进行系统开发，可提高系统的开发进度，明确系统的需求，保证系统的稳定性。</p> 
<p>在系统设计的过程中，由于每个系统实现的功能不同，所以每个系统的需求也将会不同。也就导致了系统的设计方案不同。在系统的开发过程中，有些需求在属性上往往会有一定的关联性，而有些需求之间的联系很少。如果在设计的时候，不对需求进行归类划分的话，在后期的过程中往往会造成混乱。</p> 
<p>在系统定义和软件计划等阶段进行基本模型设计时，以底层功能为单位，对处理、输入、输出、文件等进行了初步的研究和设定，并且研究了人机接口等问题，但是，以此新系统基本模型设计为基础所做出的各层次基本模型都只是表达出了各个业务处理之间的自然逻辑，并没有表达出计算机处理的流程。<br> 因此，在具体着手软件设计工作之前，有必要先对基本模型图中规定为计算机处理的部分进行处理模块的划分，以便大体上明确其处理的流程。当然，这时候所划分的处理模块还不能包含具体的物理内容 (例如，其中的输入、输出和文件等仍然只能是抽象的) 。因为这些物理内容正是需要通过以后的设计工作才能逐步具体起来。</p> 
<p>软件设计过程中通过对软件进行模块划分可以达到一下的好处：<br> (1)使程序实现的逻辑更加清晰，可读性强。<br> (2)使多人合作开发的分工更加明确，容易控制。<br> (3)能充分利用可以重用的代码。<br> (4)抽象出可公用的模块，可维护性强，以避免同一处修改在多个地方出现。<br> (5)系统运行可方便地选择不同的流程。<br> (6)可基于模块化设计优秀的遗留系统，方便的组装开发新的相似系统，甚至一个全新的系统。</p> 
<p><span style="color:#FF0000;"><strong>系统性能的衡量标准</strong></span></p> 
<p>计算机处理模块的划分使新系统从基本 (逻辑) 模型向实际的计算机处理系统迈开了第一步。显然，模块划分的好坏将会影响软件乃至整个系统性能的优劣。<br> 不同的对象对系统性能的要求有所不同，要制订出适应于所有系统的衡量标准，以判别系统性能的优劣是有困难的。一般软件系统性能的衡量标准主要有以下四个方面的内容：</p> 
<p>（1）系统效率<br> 对于批处理系统来说，指的是单位时间内处理的业务量；对于联机实时处理系统来说，则主要是指响应时间。<br> （2）系统工作质量<br> 主要是指系统信息处理的质量，例如所提供数据的精度、输出报表的易读性等等。<br> （3）系统可靠性<br> 是指系统抵御各种外界干扰的能力。例如，输入的错误数据能否检查出来；文件中数据一旦被破坏能否恢复；电源断电等意外事故发生时，有无应急措施等等。<br> （4）系统的可维护性<br> 是指纠正系统出现的错误和缺陷，以及为满足新的要求进行扩充或压缩的容易程度。应该看到，任何系统都不可能永久不变，由于环境变化等诸因素，系统需要不断地进行修改和完善。</p> 
<p>上述四个衡量标准中，可维护性占有很重要的地位。因为如果系统的其他指标都很好，唯独可维护性很差，那么一旦由于某些条件的改变需要对系统进行修改时，就会因此而无法进行修改，最后不得不重新设计系统。相反，如果系统的可维护性很好，那么，尽管其他指标差一些，也可以在使用中进一步进行修改，并逐步加以完善。</p> 
<p><span style="color:#FF0000;"><strong>软件结构</strong></span></p> 
<p>软件结构表示程序的系统结构，它以层次结构表示一种控制层次体系，它并不表示软件的具体过程 (例如各个进程的顺序、判定和操作重复等) 。<br> 软件结构表示了软件元素 (模块) 之间的关系，例如调用关系、包含关系、从属关系和嵌套关系等。下图表示了一个软件结构。</p> 
<p><img alt="" height="434" src="https://images2.imgbox.com/ca/e2/S2tEaz9x_o.png" width="754"></p> 
<p>（1）深度<br> 深度表示软件结构中控制层数。例如图4-1是一个四层软件结构。深度往往能粗略地表示一个系统的大小和复杂程度，软件结构的深度和程序长度之间存在着某种对应关系。<br> （2）宽度<br> 宽度是软件内同一层次上的模块总数。一般来说，结构的宽度越大，则系统就越复杂。<br> （3）扇出<br> 扇出是由一个模块直接控制的其他模块数的一种度量。例如图4-1中模块A，B，C，D的扇出分别为3，2，1，2。扇出过大，表示模块过分复杂，需要控制和协调的下级模块太多。扇出的上限一般为5～9，平均一般为3或4。<br> （4）扇入<br> 扇入表示有多少个上级模块直接控制一个给定的模块。例如图4-1中模块R和S的扇入分别为3和1。扇入过大，意味着共享该模块的上级模块数目多，这有一定的益处，但是决不能违背模块的独立性原则而片面追求高扇入。</p> 
<p><span style="color:#fe2c24;"><strong>模块划分的方法</strong></span></p> 
<p>很多人都参与过一些项目的设计，在很多项目设计过程中对于模块划分大多都是基于功能进行划分。这样划分有一个好处，由于在一个项目的设计过程中，有着诸多的需求。而很多需求都可以进行归类,根据功能需求分类的方法进行模块的划分。可以让需求在归类上得到明确的划分，而且通过功能需求进行软件的模块划分使得功能分解,任务分配等方面都有较好的分解。</p> 
<p>按照任务需求进行模块划分是一种基于面向过程的划分方法，利用面向过程的思想进行系统设计的好处是能够清晰的了解系统的开发流程。对于任务的分工、管理，系统功能接口的制定在面向过程的思想中都能够得到良好的体现。</p> 
<p>按任务需求进行模块划分的主要步骤如下：<br> (1)分析系统的需求，得出需求列表；<br> (2)对需求进行归类，并划分出优先级；<br> (3)根据需求对系统进行模块分析，抽取出核心模块；<br> (4)将核心模块进行细化扩展，逐层得到各个子模块，完成模块划分。</p> 
<p>在很多情况下，在划分任务需求的时候，有些需求和很多个模块均有联系，这个时候，通过需求来确定模块的划分就不能够降低模块之间的耦合了。而且有些模块划分出来里面涉及的数据类型多种多样，显然这个时候根据系统所抽象出来的数据模型来进行模块划分更加有利。</p> 
<p>在系统进行模块划分之前，往往都会有一个数据模型的抽象过程，根据系统的特性抽象出能够代表系统的数据模型。根据数据模型来进行模块划分，可以充分降低系统之间的数据耦合度。按照数据模型进行模块的划分，降低每个模块所包含的数据复杂程度，简化数据接口设计。同时，对于数据的封装可以起到良好的作用，提高了系统的封闭性。</p> 
<p>抽象数据模型的模块划分方案是一种基于面向对象的思想进行的。这种思想的特点就是不以系统的需求作为模块的划分方法，而是以抽象出系统的数据对象模型的思想对模块进行划分。而利用这种思想进行模块划分的主要好处能够接近人的思维方式对问题进行划分，提高系统的可理解性，可以从较高层次上对系统进行把握！</p> 
<p>按照数据模型进行模块划分的主要步骤如下：<br> (1)根据系统框架抽象出系统的核心数据模型；<br> (2)根据核心数据模型将系统功能细化，并将数据模型与视图等剥离，细化数据的流向；<br> (3)依据数据的流向制定模块和接口，完成模块划分。</p> 
<p><span style="color:#FF0000;"><strong>模块划分的基本原则</strong></span></p> 
<p>“模块”实际上是一个已经得到广泛应用的概念，许多程序设计语言中的所谓子程序、分程序、过程、函数等实质上都具有模块的特性。这些特性包括模块的名字、输入和输出信息、功能、内部逻辑构造、可被调用以及可调用其他模块等。</p> 
<p>既然系统的可维护性是评价系统性能的首要因素，那么，应该怎样做才能使系统变得容易修改呢？通常一个系统是由若干个子系统组成的；每个子系统又可分解成更小的子系统。在实际工作中，要求改变整个系统的结构的情况是极为少见的。所谓系统的修改往往只是对某些子系统的某些细节作一些变动，也就是说，这些修改通常都是局部的。<br> 然而，由于各子系统之间是相互关联的，对其中某个子系统的修改，可能会通过这些相互关系而影响到其他子系统，乃至波及整个系统。这样，就可能会造成动了一处而引出来好几处的问题，越改越乱，甚至会出现使修改工作无法进行下去的局面。</p> 
<p>由此可见，要使系统易于修改，必须使每一个修改都尽可能地局部化。这就要求在进行系统的模块划分时，要使模块的内部联系尽可能地强，而模块间的外部联系尽可能地弱，即尽可能地提高模块的相对独立性。这样，在对其中某一个模块作修改时，它所造成的影响只局限在本模块范围内，而不至于波及整个系统。</p> 
<p>当系统被划分成若干个模块之后，模块之间的关系称之为块间关系，而模块内部的实现逻辑都属于模块内部子系统。对于软件的模块划分要遵循一些基本原则，遵循基本原则进行模块划分所设计出来的系统具有可靠性强，系统稳定，利于维护和升级。</p> 
<p>设计模块往往要注意很多的问题，好的模块划分方案可以对系统开发带来很多的便利，提高整个系统的开发效率，而且对于系统后期的维护难度也会降低不少。反之，如果模块划分的不恰当，不仅不能带来便利，往往还会影响程序的开发。</p> 
<p>在进行软件模块划分的时候，首先要遵从的一个准则就是确保每个模块的独立性，所谓模块独立性，即：不同模块相互之间的联系尽可能少，尽可能的减少公共的变量和数据结构。每个模块尽可能的在逻辑上独立，功能上完整单一，数据上与其他模块无太多的耦合。</p> 
<p>模块独立性保证了每个模块实现功能的单一性，接口的统一性，可以将模块之间的耦合度充分降低。在进行软件模块划分的时候，如果各个模块之间的联系过多，模块独立性差容易引起系统结构混乱，层次划分不清晰。导致有的需求和多个模块均有关联，严重影响系统设计。</p> 
<p>对于模块独立性的好处主要可以归纳为以下几点：<br> (1)模块功能完整独立；<br> (2)数据接口简单；<br> (3)程序易于实现；<br> (4)易于理解和系统维护；<br> (5)利于限制错误范围；<br> (6)提高软件开发速度，同时软件质量高。</p> 
<p>在软件设计的过程中，往往需要对系统的结构层次进行分析，从中抽取出系统的设计框架，通过框架来指导整个软件设计的流程。而一个良好的系统框架也是决定整个系统的稳定性、封闭性、可维护性的重要条件之一。</p> 
<p>因此，在对软件进行模块划分的过程中，要充分遵照当前系统的框架结构。模块的划分要和系统的结构层次相结合，根据系统的层次对各个模块也进行层次划分。如果系统的模块划分和框架结构相违背的话，则会导致类似数据混乱，接口复杂，模块耦合性过高等等的问题出现。<br> 如果模块划分的方法主要是依据任务需求而进行划分的话，那么可以先将任务需求根据系统框架划分出系统等级。通过对任务需求的等级划分对模块划分起到引导作用，同时，依照系统结构层次来对模块划分。</p> 
<p>在进行模块划分的时候，有很多情况下不能够清晰的把握每个模块的具体内容。往往会出于对需求归类或者数据统一的角度上对模块进行设计。这种设计理念是对的，但是如果只是单纯的从这几个方面来进行模块设计的话，那么也会导致在模块划分上出现另外一些情况。比如说设计的某一个模块，虽然数据接口统一，但是内部实现的功能非常多，单一模块的规模过大，包含的内容过多。</p> 
<p>如果一个模块包含的内容过多，会导致程序实现难度增加，数据处理流程变得复杂，程序维护性降低，出错范围不易确定等情况的出现。同时，由于模块实现的功能丰富，则必然会导致接口也变得繁多，那么与其他模块之间的独立性就得不到保证。而且，一个模块包含太多的内容也会给人一种一团乱糟糟的感觉，严重影响对程序的理解。在设计模块的时候，需要遵循每个模块功能单一、接口简单、结构精简的原则。对每个模块的设计确保该模块的规模不要太大，接口尽量的单一简化。这样的话，虽然可能会导致模块的数量上比较多，但是能够确保模块的独立性，而且不会影响系统的整体的框架结构。</p> 
<p>用来评价模块结构质量的具体标准是模块的耦合度和内聚度。</p> 
<p><span style="color:#fe2c24;"><strong>联系</strong></span></p> 
<p>当一个程序段或语句（指令）引用了其它程序段或语句（指令）中所定义或使用的数据名（即存贮区、地址等）或代码时，他们之间就发生了联。一个程序被划分为若干模块时，联系既可存在于模块之间，也可存在于一个模块内的程序段或语句之间，即模块内部。联系反映了系统中程序段或语句之间的关系，不同类型的联系构成不同质量的系统。因此， 联系是系统设计必须考虑的重要问题。</p> 
<p>系统被分成若干模块后，模块同模块的联系称为块间联系；一个模块内部各成份的联系称为块内联系。显然，模块之间的联系多，则模块的相对独立性就差，系统结构就混乱；相反，模块间的 联系少，各个模块相对独立性就强，系统结构就比较理想。同时，一个模块内部各成份联系越紧密，该模块越易理解和维护。</p> 
<p><span style="color:#fe2c24;"><strong>模块独立性</strong></span></p> 
<p>模块化是软件设计和开发的基本原则和方法，是概要设计最主要的工作。模块的划分应遵循一定的要求，以保证模块划分合理，并进一步保证以此为依据开发出的软件系统可靠性强，易于理解和维护。根据软件设计的模块化、抽象、信息隐蔽和局部化等原则，可直接得出模块化独立性的概念。所谓模块独立性，即：不同模块相互之间联系尽可能少，应尽可能减少公共的变量和数据结构；一个模块应尽可能在逻辑上独立，有完整单一的功能。</p> 
<p>模块独立性（Module independence）是软件设计的重要原则。具有良好独立性的模块划分，模块功能完整独立，数据接口简单，程序易于实现，易于理解和维护。独立性限制了错误的作用范围，使错误易于排除，因而可使软件开发速度快，质量高。</p> 
<p>为了进一步测量和分析模块独立性，软件工程学引入了两个概念，从两个方面来定性地度量模块独立性的程度，这两个概念是模块的内聚度和模块的耦合度。</p> 
<p><span style="color:#FF0000;"><strong>内聚度</strong></span></p> 
<p>内聚度又称模块强度，是指一个模块内部各成分之间的联系，内聚度高，则模块的相对独立性高。</p> 
<p>内聚度（Cohesion）是模块内部各成份（语句或语句段）之间的联系。显然，模块内部各<br> 成份联系越紧，即其内聚度越大，模块独立性就越强，系统越易理解和维护。具有良好内聚度<br> 的模块应能较好地满足信息局部化的原则，功能完整单一。同时，<span style="color:#fe2c24;">模块的高内聚度必然导致模<br> 块的低耦合度。</span>理想的情况是：一个模块只使用局部数据变量，完成一个功能。</p> 
<p>按内聚度由低到高的顺序，可划分为以下七个等级：</p> 
<p>1. 偶然内聚 (偶发强度)<br> 即模块内各成分间无实质性的联系，只是偶然地被凑合到一起。这种模块的内部联系毫无疑问是最弱的。</p> 
<p>块内的各个任务（通过语句或指令来实现的）<span style="color:#fe2c24;">没有什么有意义的联系</span>，它们之所以能构成<br> 一个模块完全是偶然的原因。偶然内聚的模块有很多缺点：由于模块内没有实质性的联系，很<br> 可能在某种情况下一个调用模块需要对它<span style="color:#0d0016;">修改</span>而别的模块不需要。这时就很难处理。同时，这<br> 种模块的含义也不易理解，甚至难以为它取一个合适的名字，偶然内聚的模块也难于测试。所<br> 以，在空间允许的情况下，不应使用这种模块。</p> 
<p><br> 2. 逻辑内聚 (相似强度)<br> 将几个逻辑上相似 (实际上并无必然联系) 的功能放入一个模块而形成块内联系。这种模块比偶然内聚要好一些，但由于只是形式上的相似，实质上彼此并无必然联系，因此其内部的联系仍然是较弱的。<br> 例如，将各种错误信息的处理集中起来，定义为一个模块，但这些错误信息的处理彼此间没有丝毫关系。这样的模块就是具有逻辑内聚的模块。显然，由于它把所有形式上相似 (都是错误信息处理) 而实质上毫无关系的处理放在一起，它和其他模块之间的联结关系就必然相当复杂，因此修改维护会相当困难。</p> 
<p>逻辑内聚存在的问题是：<br> ➢ 修改困难，调用模块中有一个要对其改动，还要考虑到其它调用模块；<br> ➢ 模块内需要增加开关，以判别是谁调用，因而增加了块间联系；<br> ➢ 实际上每次调用只执行模块中的一部分，而其它部分也一同被装入内存，因而效率<br> 不高。</p> 
<p><br> 3. 时间内聚 (时间强度)<br> 将若干在同一个时间带内进行的工作集中在一起所形成的模块，但这些工作彼此间毫无关系。这种模块具有的强度比逻辑内聚模块略好些，但由于模块的各组成元素之间仍然是彼此无关的，因此，其内部联系也还是较弱的，可变更性能也很差。例如，初始化处理模块就是这样一种模块。由于它将彼此间并无关系的初始化处理工作集中到一起，模块本身的强度较弱，而且它和其他模块之间的联结范围也较宽，因此，修改维护也很困难。</p> 
<p><br> 4. 过程内聚 (过程强度)<br> 模块内的各成分是相关的，且必须以特定的次序执行，中间不能穿插其他工作。例如，先输入x，再决定y，……。和时间内聚模块相比较，过程内聚强调严格的执行次序，而时间内聚强调在同一个时间带内执行，对执行次序则并无要求。显然，过程内聚比时间内聚模块的内部紧密程度要高些。</p> 
<p><br> 5. 通讯内聚 (通信强度)<br> 指模块中的各成分引用相同输入数据和 (或) 产生相同的输出数据，但各成分的执行次序可以是任意的。这样组成的模块就是具有通讯内聚。例如模块中的若干个处理功能读取同一个文件的数据就是这样的一种模块。它比过程内聚模块具有更紧密的内部联系。</p> 
<p><br> 6. 顺序内聚 (顺序强度)<br> 如果模块内各成分间具有这样的特征：前一成分所产生的输出是另一成分的输入，那么这种模块就是具有顺序内聚的模块。这种模块的内部紧密程度比以上各种模块都要高。<br> 顺序内聚与过程内聚的区别在于：前者强调的是数据的顺序，而后者强调的是加工处理的先后。</p> 
<p><br> 7. 功能内聚 (功能强度)<br> 模块内所有的成分属于一个整体，为完成同一个功能而存在，那么这种模块就称为具有功能内聚的模块。由于这种模块只执行一个功能，因而其内部紧密程度最高，具有“黑盒”的作用。功能内聚模块的结构紧凑、界面清晰，易于理解和维护，因而可靠性强；又由于其功能单一，故复用率高。所以它是模块划分时应注意追求的一种模块类型。</p> 
<p>在模块设计时应力争做到高内聚，并且能够辨别出低内聚的模块，加以修改使之提高内聚度并降低模块间的耦合度。具体设计时，应注意：<br> 1)设计功能独立单一的模块；<br> 2)控制使用全局数据；<br> 3)模块间尽量传递数据型信息。</p> 
<p><span style="color:#FF0000;"><strong>耦合度</strong></span></p> 
<p>耦合度又称模块结合度，是模块结构中各模块之间相互联系的一种度量，是模块独立性的直接尺度。耦合度越弱，就意味着模块的独立性越高，则模块间相互影响就越小。</p> 
<p>耦合度的强弱可以从以下四个方面来衡量：<br> 1. 数据结合度<br> 两个模块之间的通讯信息是若干个数据，这种联结关系就是具有数据结合度的联结关系。由于两者之间没有控制信号的交换，因此相互间的影响最小。例如报表生成、报表打印两模块间的关系。再如一个模块的输出数据是另一个模块的输入数据，或一个模块带参数调用另一个模块，下层模块又返回参数。应该说，在一个软件系统中，此种耦合是不可避免的，且有其积极意义。因为任何功能的实现都离不开数据的产生、表示和传递。数据耦合的联系程度也较低。</p> 
<p><br> 2. 控制结合度<br> 两个模块之间传递的信息中含有控制信号，使得一个模块控制了另一个模块的内部逻辑，这种联结就是具有控制结合度的联结关系。这种结合度下的模块间的相互影响显然要比数据结合度下的模块间相互影响要大。</p> 
<p>若在调用过程中，两个模块间传递的不是数据参数而是控制参数，则模块间的关系即为控制耦合。控制耦合属于中等程度的耦合，较之数据耦合模块间的联系更为紧密。但控制耦合不是一种必须存在的耦合。</p> 
<p>当被调用模块接收到控制信息作为输入参数时，说明该模块内部存在多个并列的逻辑路径，即有多个功能。控制变量用以从多个功能中选择所要执行的部分，因而控制耦合是完全可以避免的。</p> 
<p>排除控制耦合可按如下步骤进行：<br> 1) 找出模块调用时所用的一个或多个控制变量；<br> 2) 在被调模块中根据控制变量找出所有的流程；<br> 3) 将每一个流程分解为一个独立的模块；<br> 4) 将原被调模块中的流程选择部分移到上层模块，变为调用判断。</p> 
<p>通过以上变换，可以将控制耦合变为数据耦合。由于控制耦合增加了设计和理解的复杂程度，因此在模块设计时要尽量避免使用。当然，如果模块内每一个控制流程规模相对较小，彼此共性较多，使用控制耦合还是合算的。</p> 
<p>3. 公共结合度<br> 两个模块通过对公共数据的访问建立联系，这样的联结关系就是具有公共结合度的联结关系。这是一种不太好的联结关系，因为若干个模块共用某几个数据，就使联结关系复杂起来，增加了模块修改的难度。</p> 
<p>公共数据区可以是全程变量、共享的数据区、内存的公共复盖区、外存上的文件、物理设备等。当两个模块共享的数据很多，通过参数传递可能不方便时，可以使用公共耦合。公共耦合共享数据区的模块越多，数据区的规模越大，则耦合程度越强。公共耦合最弱的一种形式是：两个模块共享一个数据变量，一个模块只向里写数据，另一个模块只从里读数据。</p> 
<p>当公共耦合程度很强时，会造成关系错综复杂，难以控制，错误传递机会增加，系统可靠性降低，可理解、维护性差。</p> 
<p>4. 内容结合度<br> 一个模块不经过调用关系直接使用另一个模块的内容，这种联结关系称为具有内容结合度的联结关系。例如模块A用绝对地址直接使用模块B的数据就是一例。这是最坏的一种联结形式，给模块维护带来很大困难。比如，设模块B进行了某种修改，使模块A要使用的数据发生了改变，那么当模块A运行时势必要发生错误，但从模块A本身是查不出这种错误发生的原因的，只能通过模块B才能检查出来。</p> 
<p>内容耦合的存在严重破坏了模块的独立性和系统的结构化，代码互相纠缠，运行错综复杂，程序的静态结构和动态结构很不一致，其恶劣结果往往不可预测。内容耦合往往表现为以下几种形式：<br> ➢ 一个模块访问另一模块的内部代码或数据；<br> ➢ 一个模块不通过正常入口而转到另一个模块的内部（如使用GOTO语句或JMP指令直接进入另一模块内部）；<br> ➢ 两个模块有一部分代码重迭（可能出现在汇编程序中，在一些非结构化的高级语言，如COBOL中也可能出现）；<br> ➢ 一个模块有多个入口（这意味着一个模块有多种功能）。</p> 
<p>一般讲，在模块划分时，应当尽量使用数据耦合，少用控制耦合（尽量转成数据耦合），<br> 限制公共耦合的范围，完全不用内容耦合。</p> 
<p><span style="color:#FF0000;"><strong>高内聚和低耦合</strong></span></p> 
<p>内聚和耦合是密切相关的，模块内的高内聚往往意味着模块间的低耦合。这也就是说，内聚度 (模块强度) 和耦合度 (模块结合度) 要说明的是同一内容，即模块的独立性，它们是衡量这种独立性的两个不同的方面。</p> 
<p>在软件设计中，应该追求高内聚、低耦合 (即块内要紧，块间要松) 的系统，在这样的系统中，可以研究、测试或维护任何一个模块，而不需要对系统的其他模块有很多了解。此外，由于模块间联系简单，发生在某处的错误传播到整个系统的可能性很小。因此，模块间的耦合程度强烈地影响着系统的可理解性、可测试性、可靠性和可维护性等性能。当然，在实际情况中，要做到所划分的模块都具有功能内聚，模块间联结都具有数据结合度是很困难的，只是要求尽可能地提高模块的内聚，减小模块的耦合。</p> 
<p><span style="color:#FF0000;"><strong>模块划分的方法</strong></span></p> 
<p>根据模块间的结合方式，可以把模块划分的方法分成按控制流和按数据流划分这两种基本的划分方法。</p> 
<p>1. 控制流结合的模块划分法<br> 这是按功能调用关系 (控制流) 来进行模块划分的方法。它设有一个主模块，这个主模块通过调用关系将各处理模块组织起来，同时用参数等形式进行数据传递。<br> 控制流结合的模块划分法又分两种情况：<br> （1）时间结合的功能调用划分法<br> 在这种情况下，被分解的模块具有这样的特点：</p> 
<ul><li>该模块只处理一种业务。</li><li>具有时间执行顺序。</li></ul> 
<p>这时，就可以以时间为基础来考虑模块的划分。例如将模块分解为“初始化”、“处理”、“结束”或者是“输入”、“处理”、“输出”形式的模块。<br> 时间结合的功能调用划分法如下图所示。<br><img alt="" height="269" src="https://images2.imgbox.com/fc/51/QMp3WiIa_o.png" width="551"></p> 
<p>（2）功能结合的功能调用划分法<br> 这种情况下，被分解的模块通常要处理多种业务。因此可以按业务类型 (每一类业务执行某一个功能) 来划分模块。例如，可以设置一个接受业务代码并检查其类型的调用模块，它根据不同的业务类型分别调用相应的下层模块，如下图所示。<br><img alt="" height="270" src="https://images2.imgbox.com/34/69/Yes2P16K_o.png" width="618"> </p> 
<p>2. 数据流结合的模块划分法<br> 数据流划分法也叫变换为中心划分法。简单地说，它是逐次运用“黑盒”的工程定义将问题进行功能分解。也就是说，按数据变换的阶段划分模块，其中每个模块都看成是一个“黑盒”，对这个“黑盒”进行输入、输出以及输入、输出间的变换的考察；考察的结果，又划分成若干更小的模块，然后将这些模块作为新的“黑盒”，再进行考察，最后细分到每个“黑盒”都能用简单程序实现为止。</p> 
<p>这种模块划分法在管理信息系统中用得很多，它常用来解决批处理系统的模块划分问题。其中，中间数据通常采用文件，以程序实现各变换处理，以作业控制语言来实现各模块具有较高的强度和较弱的结合度，因而模块修改所波及的范围很小，容易维护。但是，如果使用了过多的中间文件，也会出现系统处理效率下降的问题。因为对这些中间文件进行读写操作的速度要比对内存进行读写操作的速度慢得多。<br>  </p> 
<p>3. 模块划分法的选择<br> 在实际工作中，上述划分方法是交替使用的，在这一层次采用这种划分方法，在那一层又可能采用另一种划分方法。而选择这两种划分方法的主要参考原则包括：<br> 1) 研究系统的主要输入、输出数据的结构，如果它们之间存在某种对应关系，则进行与该对应关系相符合的控制流模块划分。这相当于功能结合的功能调用划分。<br> 2) 如果主要的输入、输出数据之间没有明确的对应关系，则可引入中间数据，并通过这些中间数据进行数据流划分，以使输入、输出数据能逐次对应。<br> 3) 如果从输入到输出，整个处理存在着明显的数据变换过程，那么可以考虑采用数据流划分。<br>  </p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/af9692cd2f0b41456b9dae650c1299bd/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">VUE3笔记</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/b904cfdbf2260a6183e57cebb04848b1/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">“RuntimeError: CUDA error: invalid device ordinal”解决方法</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>