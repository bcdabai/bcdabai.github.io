<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>【Java】构造方法及类的初始化 - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="【Java】构造方法及类的初始化" />
<meta property="og:description" content="一. 利用构造方法给对象初始化 1. 构造方法的概念 构造方法(也称为构造器)是一个特殊的成员方法，其名字必须与类名相同，在创建对象时，由编译器自动调用，并且在整个对象的生命周期内只调用一次。
构造方法的作用就是给对象中的成员进行初始化，并不负责给对象开辟空间。
public class Date { public int year; public int month; public int day; // 构造方法： // 名字与类名相同，没有返回值类型，设置为void也不行 // 一般情况下使用public修饰 // 在创建对象时由编译器自动调用，并且在对象的生命周期内只调用一次 public Date(int year, int month, int day) { this.year = year; this.month = month; this.day = day; System.out.println(&#34;Date(int,int,int)方法被调用了&#34;); } public void printDate() { System.out.println(year &#43; &#34;-&#34; &#43; month &#43; &#34;-&#34; &#43; day); } public static void main(String[] args) { // 此处创建了一个Date类型的对象，并没有显式调用构造方法 Date d = new Date(2021, 6, 9); // 输出Date(int,int,int)方法被调用了 d." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/68931c96be2aed7a94e9307300624530/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-11-21T09:11:34+08:00" />
<meta property="article:modified_time" content="2022-11-21T09:11:34+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">【Java】构造方法及类的初始化</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <h2>一. 利用构造方法给对象初始化</h2> 
<h3>1. 构造方法的概念</h3> 
<p>构造方法(也称为构造器)是一个特殊的成员方法，其名字必须与类名相同，在创建对象时，由编译器自动调用，并且在整个对象的生命周期内只调用一次。</p> 
<p>构造方法的作用就是给对象中的成员进行初始化，并不负责给对象开辟空间。</p> 
<pre><code>public class Date {
    public int year;
    public int month;
    public int day;

    // 构造方法：
    // 名字与类名相同，没有返回值类型，设置为void也不行
    // 一般情况下使用public修饰
    // 在创建对象时由编译器自动调用，并且在对象的生命周期内只调用一次
    public Date(int year, int month, int day) {
        this.year = year;
        this.month = month;
        this.day = day;
        System.out.println("Date(int,int,int)方法被调用了");
    }

    public void printDate() {
        System.out.println(year + "-" + month + "-" + day);
    }

    public static void main(String[] args) {
        // 此处创建了一个Date类型的对象，并没有显式调用构造方法
        Date d = new Date(2021, 6, 9);
        // 输出Date(int,int,int)方法被调用了
        d.printDate(); // 2021-6-9
    }
}
</code></pre> 
<h3>2. 构造方法的特性</h3> 
<p>1.名字必须与类名相同<br> 3.没有返回值类型，设置为void也不行<br> 3.创建对象时由编译器自动调用，并且在对象的生命周期内只调用一次<br> 4.绝大多数情况下使用public来修饰，特殊场景下会被private修饰<br> 5.构造方法可以重载(用户根据自己的需求提供不同参数的构造方法)； 下面两个构造方法：名字相同，参数列表不同，因此构成了方法重载</p> 
<pre><code>public class Date {
    public int year;
    public int month;
    public int day;
    
    // 无参构造方法
    public Date(){
        this.year = 1900;
        this.month = 1;
        this.day = 1;
    }
    
    // 带有三个参数的构造方法
    public Date(int year, int month, int day) {
        this.year = year;
        this.month = month;
        this.day = day;
    }
    public void printDate(){
        System.out.println(year + "-" + month + "-" + day);
    }
    public static void main(String[] args) {
        Date d = new Date();
        d.printDate();
    }
}
</code></pre> 
<p>6.如果用户没有显式定义，编译器会生成一份默认的构造方法，生成的默认构造方法一定是无参的； 一旦用户定义，编译器则不再生成；下面代码中，没有定义任何构造方法，编译器会默认生成一个不带参数的构造方法。</p> 
<pre><code>public class Date {
    public int year;
    public int month;
    public int day;
    public void printDate(){
        System.out.println(year + "-" + month + "-" + day);
    }
    public static void main(String[] args) {
        Date d = new Date();
        d.printDate();
    }
}
</code></pre> 
<p>7.构造方法中，可以通过this调用其他构造方法来简化代码<br> 【注意事项】</p> 
<p>• 构造方法中，通过this(…)去调用其他构造方法，这条语句必须是构造方法中第一条语句<br> • 多个构造方法不可以互相调用（不能形成环）， 会形成构造器的递归调用，但却没有调用的结束条件</p> 
<pre><code>public class Date {
    public int year;
    public int month;
    public int day;
// 无参构造方法--内部给各个成员赋值初始值，该部分功能与三个参数的构造方法重复
// 此处可以在无参构造方法中通过this调用带有三个参数的构造方法
// 但是this(2022,8,16);必须是构造方法中第一条语句
    
    public Date(){
//System.out.println(year); 注释取消掉，编译会失败
        this(2022, 8, 16);
//this.year = 1900;
//this.month = 1;
//this.day = 1;
    }
    
    // 带有三个参数的构造方法
    public Date(int year, int month, int day) {
        this.year = year;
        this.month = month;
        this.day = day;
    }
}
</code></pre> 
<h3>3. 子类构造方法</h3> 
<p>在继承基础上，子类对象构造时，需要先调用基类构造方法，然后执行子类的构造方法。</p> 
<p>在子类构造方法中，并没有写任何关于基类构造的代码，但是在构造子类对象时，先执行基类的构造方法，然后执行子类的构造方法，</p> 
<p>原因在于：子类对象中成员是有两部分组成的，基类继承下来的以及子类新增加的部分 。父类和子类， 肯定是先有父再有子，所以在构造子类对象时候 ，子类构造方法中先要调用基类的构造方法，将从基类继承下来的成员构造完整 ，然后再完成子类自己的构造，将子类自己新增加的成员初始化完整 。</p> 
<p>【注意事项】</p> 
<p>1.若父类显式定义无参或者默认的构造方法，在子类构造方法第一行默认有隐含的super()调用，即调用基类构造方法</p> 
<pre><code>public class Base {
    public Base(){
        System.out.println("Base()");
    }
}

public class Derived extends Base{
    public Derived(){
// super(); // 注意子类构造方法中默认会调用基类的无参构造方法：super(),
// 用户没有写时,编译器会自动添加，而且super()必须是子类构造方法中第一条语句，
// 并且只能出现一次
        System.out.println("Derived()");
    }
}

public class Test {
    public static void main(String[] args) {
        Derived d = new Derived();
    }
}
</code></pre> 
<p>2.如果父类构造方法是带有参数的，此时需要用户为子类显式定义构造方法，并在子类构造方法中选择合适的父类构造方法调用，否则编译失败。</p> 
<pre><code>public class Animal {
    public String name;
    public int  age;

   public Animal(String name, int age) {
        this.name = name;
        this.age = age;
       System.out.println("Animal(String , int )");
    }

}

public class Dog extends Animal{
    //傻狗  是狗的属性
    public boolean silly;

   public Dog(String name,int age,boolean silly) {
        //1. 先帮助父类部分初始化 必须放到第一行
        super(name,age);
        this.silly = silly;
        System.out.println("Dog(String ,int ,boolean )");
   }
    public static void main(String[] args) {
        Animal animal2 = new Dog("金毛",6,false);
    }
}
</code></pre> 
<p>3.在子类构造方法中，super(…)调用父类构造时，必须是子类构造方法中第一条语句。<br> 4.super(…)只能在子类构造方法中出现一次，由与this(…)调用时也要在第一条语句，所以super(…)不能和this(…)同时出现，也就是是说子类构造方法中不能使用this(…)</p> 
<h3>4. 避免在构造方法中调用重写的方法</h3> 
<p>一段有坑的代码. 我们创建两个类, B 是父类, D 是子类. D 中重写 func 方法. 并且在 B 的构造方法中调用 func</p> 
<pre><code>class B {
    public B() {
// do nothing
        func();
    }
    public void func() {
        System.out.println("B.func()");
    }
}
class D extends B {
    private int num = 1;
    @Override
    public void func() {
        System.out.println("D.func() " + num);
    }
}
public class Main {
    public static void main(String[] args) {
        D d = new D();
    }
}
</code></pre> 
<p>执行结果：</p> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/51/d0/64WMmH6Y_o.png"></p> 
<p>• 构造 D 对象的同时, 会调用 B 的构造方法.<br> • B 的构造方法中调用了 func 方法, 此时会触发动态绑定, 会调用到 D 中的 func<br> • 此时 D 对象自身还没有构造, num 处在未初始化的状态, 值为 0；如果具备多态性，num的值应该是1.<br> • 所以在构造函数内，尽量避免使用实例方法，除了final和private方法。<br> 【结论】：</p> 
<p>“用尽量简单的方式使对象进入可工作状态”, 尽量不要在构造器中调用方法(如果这个方法被子类重写, 就会触发动态绑定, 但是此时子类对象还没构造完成), 可能会出现一些隐藏的但是又极难发现的问题.</p> 
<h2>二. 对象的默认初始化</h2> 
<p>在Java方法内部定义一个局部变量时，用户必须要将其赋值或者初始化，否则会编译失败；</p> 
<p>但对象中的字段（成员变量），用户不需要将其初始化就可直接访问使用，这里其原因在于new对象时，jvm会给出字段的默认初始化。</p> 
<p>下面是new对象是时，jvm层面执行的概述：</p> 
<p>1.检测对象对应的类是否加载了，如果没有加载则加载<br> 3.为对象分配内存空间<br> 3.处理并发安全问题<br> 比如：多个线程同时申请对象，JVM要保证给对象分配的空间不冲突<br> 4.初始化所分配的空间<br> 即：对象空间被申请好之后，对象中包含的成员已经设置好了初始值</p> 
<p></p> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/4e/cc/5x0zTdHX_o.png"></p> 
<p>5.设置对象头信息(关于对象内存模型后面会介绍)<br> 6.调用构造方法，给对象中各个成员赋值</p> 
<h2>三. 就地初始化对象</h2> 
<p>在声明成员变量时，就直接给出了初始值。</p> 
<p>代码编译完成后，编译器会将所有给成员初始化的这些语句添加到各个构造方法中</p> 
<pre><code>public class Date {
    public int year = 1900;
    public int month = 1;
    public int day = 1;
    
    public Date(){
    }
    
    public Date(int year, int month, int day) {
    }
    
    public static void main(String[] args) {
        Date d1 = new Date(2022,8,16);
        Date d2 = new Date();
    }
}
</code></pre> 
<h2>四. 类的初始化顺序</h2> 
<h3>1. 普通类（没有继承关系）</h3> 
<ol><li>静态部分（静态变量、常量，静态代码块）<br> • 在类加载阶段执行，类中存在多个静态部分时，会按顺序执行</li></ol> 
<p>• 静态代码块只会执行一次，且静态的变量、常量等只会创建一份<br> 2.非静态部分（实例变量、常量、实例代码块）<br> • 当有对象创建时才会执行，按顺序执行<br> 3.最后执行构造方法，当有对象创建时才会执行<br> 代码演示：</p> 
<pre><code>class Person {
    public String name;
    public int age;
    public Organ organ = new Organ();
    public Person(String name, int age) {
        this.name = name;
        this.age = age;
        System.out.println("构造方法执行");
    }
    {
        System.out.println("实例代码块执行");
    }
    static {
        System.out.println("静态代码块执行");
    }
}
class Organ {
    //...
    public Organ() {
        System.out.println("实例变量::organ");
    }
}
public class TestDemo {
    public static void main(String[] args) {
        Person person1 = new Person("xin",21);
        System.out.println("==============");
        Person person2 = new Person("xinxin",20);
    }
}
</code></pre> 
<p>执行结果：</p> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/e9/27/5rINsnm6_o.png"></p> 
<h3>2. 派生类（ 有继承关系）</h3> 
<p>1.静态部分（静态变量、常量，静态代码块）<br> • 父类静态代码块优先于子类静态代码块执行，且是最早执行<br> • 只有第一次实例化子类对象时，父类和子类的静态部分会执行； 之后再实例化子类对象时，父类和子类的静态部分都不会再执行<br> 2.父类非静态部分（实例变量、常量、实例代码块）和父类构造方法<br> 3.子类非静态部分（实例变量、常量、实例代码块）和子类构造方法</p> 
<pre><code>class Person {
    public String name;
    public int age;
    public Person(String name, int age) {
        this.name = name;
        this.age = age;
        System.out.println("Person：构造方法执行");
    }
    {
        System.out.println("Person：实例代码块执行");
    }
    static {
        System.out.println("Person：静态代码块执行");
    }
}
class Student extends Person{
    public Student(String name,int age) {
        super(name,age);
        System.out.println("Student：构造方法执行");
    }
    {
        System.out.println("Student：实例代码块执行");
    }
    static {
        System.out.println("Student：静态代码块执行");
    }
}
public class TestDemo4 {
    public static void main(String[] args) {
        Student student1 = new Student("张三",19);
        System.out.println("===========================");
        Student student2 = new Student("gaobo",20);

    }
    public static void main1(String[] args) {
        Person person1 = new Person("bit",10);
        System.out.println("============================");
        Person person2 = new Person("gaobo",20);
    }
}
</code></pre> 
<p>执行结果：</p> 
<p></p> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/4f/74/hZkyP1oZ_o.png"></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/da85325485c75f7c8ad6cdc20e4c55d5/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">execjs 调用js出现找不到windows对象</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/5d388bf6a4feb22e14962207766b31ab/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">CDR安装包下载&#43;汉化简体中文版&#43;安装教程</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>