<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>详细堆排序的实现 - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="详细堆排序的实现" />
<meta property="og:description" content="目录
建堆有两种方法（以升序为例）：
建完堆之后，就可以去排序了：
以下是向上调整和向下调整的两个接口：
完整实现和测试代码：
首先，排序之前要先建立一个堆来实现排序
由于兄弟之间无大小关系，所以：
实现升序要创建大堆
实现降序要创建小堆
建堆有两种方法（以升序为例）： 1.利用AdjustUp（向上调整）：
从第二个数据（因为第一个数据上面无父节点），也就是下标为1的那个点开始遍历调整数据，只要该节点上面的父节点比该点小，就互换数据（Swap），最后就会建立出一个大堆。
// 建大堆 // O(N*logN) for (int i = 1; i &lt; n; i&#43;&#43;) { AdjustUp(a, i); } 2.利用AdjustDown（向下调整）：
从倒数第一个非叶子节点，也就是倒数第一个父节点开始（建成分成许多个分散的大堆），只要该节点上面的父节点比该点小，就互换数据（Swap），最后就会建立出一个大堆。
// O(N) for (int i = (n - 1 - 1) / 2; i &gt;= 0; --i) { AdjustDown(a, n, i); } 这两种方法中，更推荐下面这种，因为时间复杂度稍低，而且下方排序也要用到向下调整接口，这样就节省了一个接口。
建完堆之后，就可以去排序了： 通过大堆的顶端元素最大的特性，可以将尾数据和top数据交换（Swap），AdjustDown的参数中传进去的end是个判断点，size--后，就可以将top那个最大的数据保存在尾部，然后利用向上调整的特性，次大的数据又到了top点，再次交换，size--，依次进行下去，最后就将最大，次大，次次大......依次放到了尾部，就排序完成了。
//0（N*logN） int end = n - 1; while (end &gt; 0) { Swap(&amp;a[0], &amp;a[end]); AdjustDown(a, end, 0); end--; } 以下是向上调整和向下调整的两个接口： void AdjustUp(HPDataType* a, int child) { int parent = (child - 1) / 2; while (child &gt; 0) { if (a[child] &lt; a[parent]) { Swap(&amp;a[child], &amp;a[parent]); child = parent; parent = (child - 1) / 2; } else { break; } } } void AdjustDown(int* a, int size, int parent) { int child = parent * 2 &#43; 1; while (child &lt; size) { // 假设左孩子大 if (child &#43; 1 &lt; size &amp;&amp; a[child &#43; 1] &gt; a[child]) { &#43;&#43;child; } if (a[child] &gt; a[parent]) { Swap(&amp;a[child], &amp;a[parent]); parent = child; child = parent * 2 &#43; 1; } else { break; } } } 完整实现和测试代码： #include&lt;stdio." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/fb1da5b1709a47822f8fcf15652e51c8/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-11-27T22:17:30+08:00" />
<meta property="article:modified_time" content="2023-11-27T22:17:30+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">详细堆排序的实现</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p id="main-toc"><strong>目录</strong></p> 
<p id="%E5%BB%BA%E5%A0%86%E6%9C%89%E4%B8%A4%E7%A7%8D%E6%96%B9%E6%B3%95%EF%BC%88%E4%BB%A5%E5%8D%87%E5%BA%8F%E4%B8%BA%E4%BE%8B%EF%BC%89%EF%BC%9A-toc" style="margin-left:80px;"><a href="#%E5%BB%BA%E5%A0%86%E6%9C%89%E4%B8%A4%E7%A7%8D%E6%96%B9%E6%B3%95%EF%BC%88%E4%BB%A5%E5%8D%87%E5%BA%8F%E4%B8%BA%E4%BE%8B%EF%BC%89%EF%BC%9A" rel="nofollow">建堆有两种方法（以升序为例）：</a></p> 
<p id="%E5%BB%BA%E5%AE%8C%E5%A0%86%E4%B9%8B%E5%90%8E%EF%BC%8C%E5%B0%B1%E5%8F%AF%E4%BB%A5%E5%8E%BB%E6%8E%92%E5%BA%8F%E4%BA%86%EF%BC%9A-toc" style="margin-left:80px;"><a href="#%E5%BB%BA%E5%AE%8C%E5%A0%86%E4%B9%8B%E5%90%8E%EF%BC%8C%E5%B0%B1%E5%8F%AF%E4%BB%A5%E5%8E%BB%E6%8E%92%E5%BA%8F%E4%BA%86%EF%BC%9A" rel="nofollow">建完堆之后，就可以去排序了：</a></p> 
<p id="%E4%BB%A5%E4%B8%8B%E6%98%AF%E5%90%91%E4%B8%8A%E8%B0%83%E6%95%B4%E5%92%8C%E5%90%91%E4%B8%8B%E8%B0%83%E6%95%B4%E7%9A%84%E4%B8%A4%E4%B8%AA%E6%8E%A5%E5%8F%A3%EF%BC%9A-toc" style="margin-left:80px;"><a href="#%E4%BB%A5%E4%B8%8B%E6%98%AF%E5%90%91%E4%B8%8A%E8%B0%83%E6%95%B4%E5%92%8C%E5%90%91%E4%B8%8B%E8%B0%83%E6%95%B4%E7%9A%84%E4%B8%A4%E4%B8%AA%E6%8E%A5%E5%8F%A3%EF%BC%9A" rel="nofollow">以下是向上调整和向下调整的两个接口：</a></p> 
<p id="%E5%AE%8C%E6%95%B4%E5%AE%9E%E7%8E%B0%E5%92%8C%E6%B5%8B%E8%AF%95%E4%BB%A3%E7%A0%81%EF%BC%9A-toc" style="margin-left:80px;"><a href="#%E5%AE%8C%E6%95%B4%E5%AE%9E%E7%8E%B0%E5%92%8C%E6%B5%8B%E8%AF%95%E4%BB%A3%E7%A0%81%EF%BC%9A" rel="nofollow">完整实现和测试代码：</a></p> 
<p></p> 
<p>首先，排序之前要先建立一个堆来实现排序</p> 
<p>由于<span style="color:#0d0016;"><strong>兄弟之间无大小关系</strong></span>，所以：</p> 
<p>        实现<span style="color:#0d0016;"><strong>升序</strong></span>要创建大堆</p> 
<p>        实现<span style="color:#0d0016;"><strong>降序</strong></span>要创建小堆</p> 
<h4 id="%E5%BB%BA%E5%A0%86%E6%9C%89%E4%B8%A4%E7%A7%8D%E6%96%B9%E6%B3%95%EF%BC%88%E4%BB%A5%E5%8D%87%E5%BA%8F%E4%B8%BA%E4%BE%8B%EF%BC%89%EF%BC%9A">建堆有两种方法（以升序为例）：</h4> 
<p>1.利用<strong>AdjustUp</strong>（向上调整）：</p> 
<p>从第二个数据（因为第一个数据上面无父节点），也就是下标为<span style="color:#0d0016;"><strong>1</strong></span>的那个点开始<span style="color:#0d0016;"><strong>遍历调整</strong></span>数据，只要该节点上面的父节点比该点小，就<span style="color:#0d0016;"><strong>互换数据</strong></span>（Swap），最后就会建立出一个大堆。</p> 
<pre><code class="language-cpp">    // 建大堆
	// O(N*logN)
	for (int i = 1; i &lt; n; i++)
	{
		AdjustUp(a, i);
	}</code></pre> 
<p>2.利用<strong>AdjustDown</strong>（向下调整）：</p> 
<p>从倒数第一个非叶子节点，也就是<span style="color:#0d0016;"><strong>倒数第一个父节点</strong></span>开始（建成分成许多个分散的大堆），只要该节点上面的父节点比该点小，就<span style="color:#0d0016;"><strong>互换数据</strong></span>（Swap），最后就会建立出一个大堆。</p> 
<pre><code class="language-cpp">    // O(N)
	for (int i = (n - 1 - 1) / 2; i &gt;= 0; --i)
	{
		AdjustDown(a, n, i);
	}</code></pre> 
<p>这两种方法中，更推荐下面这种，因为<span style="color:#0d0016;"><strong>时间复杂度稍低</strong></span>，而且下方排序也要用到向下调整接口，这样就节省了一个接口。</p> 
<h4 id="%E5%BB%BA%E5%AE%8C%E5%A0%86%E4%B9%8B%E5%90%8E%EF%BC%8C%E5%B0%B1%E5%8F%AF%E4%BB%A5%E5%8E%BB%E6%8E%92%E5%BA%8F%E4%BA%86%EF%BC%9A">建完堆之后，就可以去排序了：</h4> 
<p>通过大堆的顶端元素最大的特性，可以将尾数据和<strong>top</strong>数据交换（Swap），<strong>AdjustDown</strong>的参数中传进去的<span style="color:#0d0016;"><strong>end</strong></span>是个判断点，<span style="color:#0d0016;"><strong>size--</strong></span>后，就可以将<span style="color:#0d0016;"><strong>top</strong></span>那个最大的数据保存在尾部，然后利用向上调整的特性，次大的数据又到了<strong>top</strong>点，再次交换，<strong>size--，</strong>依次进行下去，最后就将最大，次大，次次大......依次放到了尾部，就排序完成了。</p> 
<pre><code class="language-cpp">	//0（N*logN）
	int end = n - 1;
	while (end &gt; 0)
	{
		Swap(&amp;a[0], &amp;a[end]);
		AdjustDown(a, end, 0);
		end--;
	}</code></pre> 
<h4 id="%E4%BB%A5%E4%B8%8B%E6%98%AF%E5%90%91%E4%B8%8A%E8%B0%83%E6%95%B4%E5%92%8C%E5%90%91%E4%B8%8B%E8%B0%83%E6%95%B4%E7%9A%84%E4%B8%A4%E4%B8%AA%E6%8E%A5%E5%8F%A3%EF%BC%9A">以下是向上调整和向下调整的两个接口：</h4> 
<pre><code class="language-cpp">void AdjustUp(HPDataType* a, int child)
{
	int parent = (child - 1) / 2;
	while (child &gt; 0)
	{
		if (a[child] &lt; a[parent])
		{
			Swap(&amp;a[child], &amp;a[parent]);
			child = parent;
			parent = (child - 1) / 2;
		}
		else
		{
			break;
		}
	}
}

void AdjustDown(int* a, int size, int parent)
{
	int child = parent * 2 + 1;

	while (child &lt; size)
	{
		// 假设左孩子大
		if (child + 1 &lt; size &amp;&amp; a[child + 1] &gt; a[child])
		{
			++child;
		}
		if (a[child] &gt; a[parent])
		{
			Swap(&amp;a[child], &amp;a[parent]);
			parent = child;
			child = parent * 2 + 1;
		}
		else
		{
			break;
		}
	}
}</code></pre> 
<h4 id="%E5%AE%8C%E6%95%B4%E5%AE%9E%E7%8E%B0%E5%92%8C%E6%B5%8B%E8%AF%95%E4%BB%A3%E7%A0%81%EF%BC%9A">完整实现和测试代码：</h4> 
<pre><code class="language-cpp">#include&lt;stdio.h&gt;
#include&lt;stdio.h&gt;
#include&lt;stdlib.h&gt;
#include&lt;assert.h&gt;
#include&lt;stdbool.h&gt;


typedef int HPDataType;

void Swap(HPDataType* p1, HPDataType* p2)
{
	HPDataType tmp = *p1;
	*p1 = *p2;
	*p2 = tmp;
}

void AdjustUp(HPDataType* a, int child)
{
	int parent = (child - 1) / 2;
	while (child &gt; 0)
	{
		if (a[child] &lt; a[parent])
		{
			Swap(&amp;a[child], &amp;a[parent]);
			child = parent;
			parent = (child - 1) / 2;
		}
		else
		{
			break;
		}
	}
}

void AdjustDown(int* a, int size, int parent)
{
	int child = parent * 2 + 1;

	while (child &lt; size)
	{
		// 假设左孩子大
		if (child + 1 &lt; size &amp;&amp; a[child + 1] &gt; a[child])
		{
			++child;
		}
		if (a[child] &gt; a[parent])
		{
			Swap(&amp;a[child], &amp;a[parent]);
			parent = child;
			child = parent * 2 + 1;
		}
		else
		{
			break;
		}
	}
}

// 升序
void HeapSort(int* a, int n)
{
	// 建大堆
	// O(N*logN)
	/*for (int i = 1; i &lt; n; i++)
	{
		AdjustUp(a, i);
	}*/

	// O(N)
	for (int i = (n - 1 - 1) / 2; i &gt;= 0; --i)
	{
		AdjustDown(a, n, i);
	}

	//0（N*logN）
	int end = n - 1;
	while (end &gt; 0)
	{
		Swap(&amp;a[0], &amp;a[end]);
		AdjustDown(a, end, 0);
		end--;
	}
}

int main()
{
	int a[] = { 4, 6, 2, 1, 5, 8, 2, 9 };
	HeapSort(a, sizeof(a)/sizeof(int));
	for (int i = 0; i &lt; sizeof(a)/sizeof(int); i++)
	{
		printf("%d ", a[i]);
	}
	printf("\n");
	return 0;
}</code></pre>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/72daa4606597fccf797db5159f2ed0df/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">SpringBoot定时任务报错Unexpected error occurred in scheduled task原因及其解决方法（亲测有效）</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/b82a374b89da2755fa696ee305e2cafa/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">Linux部署宝塔面板及安装WordPress环境</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>