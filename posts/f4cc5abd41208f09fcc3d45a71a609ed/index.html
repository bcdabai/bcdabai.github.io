<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Nginx 被动健康检查和主动健康检查 - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Nginx 被动健康检查和主动健康检查" />
<meta property="og:description" content="被动健康检查
关于Nginx的健康检查，简单的场景下可以直接使用ngx_http_upstream_module模块自带的被动式的健康检查，简单示例如下：
http { # ..........省略其它 upstream clusterA { server 10.68.60.100:8001 max_fails=2 fail_timeout=30s; server 10.68.60.101:8001 max_fails=2 fail_timeout=30s; server 10.68.60.110:8001 max_fails=2 fail_timeout=30s; } server { listen 8080; server_name clusterA; keepalive_timeout 60; proxy_set_header X-Forwarded-Host $host; proxy_set_header X-Forwarded-Server $host; proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; proxy_set_header Host $host:$server_port; location / { # 默认是60s,设置与后端服务器建立连接的超时时间。应该注意这个超时一般不可能大于75秒。 proxy_connect_timeout 60; # 默认60s,定义从后端服务器读取响应的超时。此超时是指相邻两次读操作之间的最长时间间隔，而不是整个响应传输完成的最长时间。如果后端服务器在超时时间段内没有传输任何数据，连接将被关闭。 proxy_read_timeout 60; # 默认60s, 定义向后端服务器传输请求的超时。此超时是指相邻两次写操作之间的最长时间间隔，而不是整个请求传输完成的最长时间。如果后端服务器在超时时间段内没有接收到任何数据，连接将被关闭。 proxy_send_timeout 60; proxy_pass http://clusterA; proxy_set_header X-Forwarded-Host $host; proxy_set_header X-Forwarded-Server $host; proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; proxy_set_header Host $host:$server_port; } } 关键配置项如下：" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/f4cc5abd41208f09fcc3d45a71a609ed/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2020-07-07T20:57:34+08:00" />
<meta property="article:modified_time" content="2020-07-07T20:57:34+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Nginx 被动健康检查和主动健康检查</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <div id="js_content"> 
 <p style="text-align: center"><img src="https://images2.imgbox.com/4e/01/1lPLWUzK_o.png"></p> 
 <p><strong>被动健康检查</strong></p> 
 <p>关于Nginx的健康检查，简单的场景下可以直接使用ngx_http_upstream_module模块自带的被动式的健康检查，简单示例如下：</p> 
 <pre class="has"><code class="language-properties">http {


# ..........省略其它


    upstream clusterA {
        server 10.68.60.100:8001 max_fails=2 fail_timeout=30s;
        server 10.68.60.101:8001 max_fails=2 fail_timeout=30s;
        server 10.68.60.110:8001 max_fails=2 fail_timeout=30s;
    }


    server {
                listen                  8080;
                server_name             clusterA;
                keepalive_timeout       60;
                proxy_set_header X-Forwarded-Host $host;
                proxy_set_header X-Forwarded-Server $host;
                proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
                proxy_set_header Host $host:$server_port;
     
                location / {
                        # 默认是60s,设置与后端服务器建立连接的超时时间。应该注意这个超时一般不可能大于75秒。
                        proxy_connect_timeout 60;
                        # 默认60s,定义从后端服务器读取响应的超时。此超时是指相邻两次读操作之间的最长时间间隔，而不是整个响应传输完成的最长时间。如果后端服务器在超时时间段内没有传输任何数据，连接将被关闭。
                        proxy_read_timeout 60;
                        # 默认60s, 定义向后端服务器传输请求的超时。此超时是指相邻两次写操作之间的最长时间间隔，而不是整个请求传输完成的最长时间。如果后端服务器在超时时间段内没有接收到任何数据，连接将被关闭。
                        proxy_send_timeout 60;
                        proxy_pass http://clusterA;
                        proxy_set_header X-Forwarded-Host $host;
                        proxy_set_header X-Forwarded-Server $host;
                        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
                        proxy_set_header Host $host:$server_port;
                }


    }
</code></pre> 
 <p>关键配置项如下：<br></p> 
 <ul><li><p>max_fails：默认值为1。设定Nginx与后端服务器通信的尝试失败的次数。在fail_timeout参数定义的时间段内，如果失败的次数达到此值，Nginx就认为服务器不可用。在下一个fail_timeout时间段，服务器不会再被尝试。 设为0就会停止统计尝试次数，即不对后端节点进行健康检查。认为服务器是一直可用的。</p></li><li><p>fail_timeout：默认值为10秒。设定服务器被认为不可用的时间段以及统计失败尝试次数的时间段。在这段时间中，服务器失败次数达到指定的尝试次数max_fails，服务器就被认为不可用。</p></li></ul> 
 <p>被动式健康检查的最明显的缺点是：如果后端有不健康节点，负载均衡器需要通过先将请求发给该不健康节点时，才能发现该节点是否健康，如果不健康会将请求转发给其它后端服务，这样就会导致浪费一次转发。</p> 
 <p><strong>主动健康检查</strong><br></p> 
 <p>下面通过引入淘宝技术团队开发的nginx开源主动健康检查插件，具体操作如下：<br></p> 
 <p>1、下载nginx-1.14.0：</p> 
 <pre class="has"><code class="language-javascript">mkdir -p /opt/src
cd opt/src
wget http://nginx.org/download/nginx-1.14.0.tar.gz
</code></pre> 
 <p>2、解压：</p> 
 <pre class="has"><code class="language-css">tar -xvf nginx-1.14.0.tar.gz
</code></pre> 
 <p>3、下载主动健康检查插件：<br></p> 
 <pre class="has"><code class="language-ruby">cd opt/src
wget https://github.com/yaoweibin/nginx_upstream_check_module/archive/master.zip
</code></pre> 
 <p>4、解压：</p> 
 <pre class="has"><code class="language-properties">yum install unzip -y
unzip master.zip
</code></pre> 
 <p>5、打补丁：</p> 
 <pre class="has"><code class="language-sql">yum install patch -y
cd /opt/src/nginx-1.14.0
patch -p1 &lt; /opt/src/nginx_upstream_check_module-master/check_1.14.0+.patch 
</code></pre> 
 <p>6、编译nginx：</p> 
 <pre class="has"><code class="language-javascript">cd /opt/src/nginx-1.14.0
yum -y install gcc pcre-devel zlib-devel openssl openssl-devel
./configure --prefix=/usr/local/nginx --add-module=/opt/src/nginx_upstream_check_module-master
make
make install
</code></pre> 
 <p>8、配置/usr/local/nginx/conf/nginx.conf:<br></p> 
 <pre class="has"><code class="language-nginx">#user  nobody;
worker_processes  1;
#error_log  logs/error.log;
#error_log  logs/error.log  notice;
#error_log  logs/error.log  info;
#pid        logs/nginx.pid;
events {
    worker_connections  1024;
}


http {
    include       mime.types;
    default_type  application/octet-stream;
    #log_format  main  '$remote_addr - $remote_user [$time_local] "$request" '
    #                  '$status $body_bytes_sent "$http_referer" '
    #                  '"$http_user_agent" "$http_x_forwarded_for"';
    #access_log  logs/access.log  main;
    sendfile        on;
    #tcp_nopush     on;
    #keepalive_timeout  0;
    keepalive_timeout  60;
    #gzip  on;


    upstream clusterA {
        # simple round-robin
        # 将max_fails设置为0，不对后端服务器进行健康检查，同时使fail_timeout参数失效
        server 10.68.60.100:8001 max_fails=0 fail_timeout=120s;
        server 10.68.60.101:8001 max_fails=0 fail_timeout=120s;
        server 10.68.60.110:8001 max_fails=0 fail_timeout=120s;
        
        # 每间隔10s向后端服务发起请求，如果请求5s超时且次数达到5次则认为服务不可用
        # 如果请求次数超过2次都没有超时，则认为服务重新可用
        check interval=10000 rise=2 fall=3 timeout=5000 type=http default_down=true;
        check_http_send "GET /healthy HTTP/1.0\r\n\r\n";
        check_http_expect_alive http_2xx http_3xx;
    }


    server {
                listen                  8080;
                server_name             clusterA;
                keepalive_timeout       60;
                proxy_set_header X-Forwarded-Host $host;
                proxy_set_header X-Forwarded-Server $host;
                proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
                proxy_set_header Host $host:$server_port;
     
                location / {
                        # 默认是60s,设置与后端服务器建立连接的超时时间。应该注意这个超时一般不可能大于75秒。
                        proxy_connect_timeout 60;
                        # 默认60s,定义从后端服务器读取响应的超时。此超时是指相邻两次读操作之间的最长时间间隔，而不是整个响应传输完成的最长时间。如果后端服务器在超时时间段内没有传输任何数据，连接将被关闭。
                        proxy_read_timeout 60;
                        # 默认60s, 定义向后端服务器传输请求的超时。此超时是指相邻两次写操作之间的最长时间间隔，而不是整个请求传输完成的最长时间。如果后端服务器在超时时间段内没有接收到任何数据，连接将被关闭。
                        proxy_send_timeout 60;
                        proxy_pass http://clusterA;
                        proxy_set_header X-Forwarded-Host $host;
                        proxy_set_header X-Forwarded-Server $host;
                        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
                        proxy_set_header Host $host:$server_port;
                }
                
                location /status {
                        check_status html;
                        access_log   off;
                        #allow SOME.IP.ADD.RESS;
                        #deny all;
                }
    }
}
</code></pre> 
 <p><strong>1、check语句关键配置项说明如下：</strong><br></p> 
 <p>该指令可以打开后端服务器的健康检查功能。</p> 
 <p>指令后面的参数意义是：</p> 
 <ul><li><p>interval：向后端发送的健康检查包的间隔。</p></li><li><p>fall(fall_count): 如果连续失败次数达到fall_count，服务器就被认为是down。</p></li><li><p>rise(rise_count): 如果连续成功次数达到rise_count，服务器就被认为是up。</p></li><li><p>timeout: 后端健康请求的超时时间。</p></li><li><p>default_down: 设定初始时服务器的状态，如果是true，就说明默认是down的，如果是false，就是up的。默认值是true，也就是一开始服务器认为是不可用，要等健康检查包达到一定成功次数以后才会被认为是健康的。</p></li><li><p>type：健康检查包的类型，现在支持以下多种类型</p></li><li><ul><li><p>tcp：简单的tcp连接，如果连接成功，就说明后端正常。</p></li><li><p>ssl_hello：发送一个初始的SSL hello包并接受服务器的SSL hello包。</p></li><li><p>http：发送HTTP请求，通过后端的回复包的状态来判断后端是否存活。</p></li><li><p>mysql: 向mysql服务器连接，通过接收服务器的greeting包来判断后端是否存活。</p></li><li><p>ajp：向后端发送AJP协议的Cping包，通过接收Cpong包来判断后端是否存活。</p></li></ul> 
  </li><li><p>port: 指定后端服务器的检查端口。你可以指定不同于真实服务的后端服务器的端口，比如后端提供的是443端口的应用，你可以去检查80端口的状态来判断后端健康状况。默认是0，表示跟后端server提供真实服务的端口一样。</p></li></ul> 
 <p><strong>2、check_http_send语句关键配置项说明如下：</strong></p> 
 <p>该指令可以配置http健康检查包发送的请求内容。为了减少传输数据量，推荐采用<code>"HEAD"</code>方法。</p> 
 <p>/healthy该url是你应用需要能够访问的。当采用长连接进行健康检查时，需在该指令中添加keep-alive请求头，如："GET /healthy  HTTP/1.1\r\nConnection: keep-alive\r\n\r\n"。同时，在采用"GET"方法的情况下，请求uri的size不宜过大，确保可以在1个interval内传输完成，否则会被健康检查模块视为后端服务器或网络异常。</p> 
 <p><strong>3、check_http_expect_alive语句关键配置项说明如下：</strong></p> 
 <p>该指令指定HTTP回复的成功状态，默认认为2XX和3XX的状态是健康的。</p> 
 <p>支持的配置值有：[ http_2xx | http_3xx | http_4xx | http_5xx ]</p> 
 <p><strong>4、check_status 配置项说明如下：</strong></p> 
 <p>显示服务器的健康状态页面。该指令需要在http块中配置。<strong></strong></p> 
 <p>更多配置参考淘宝Nginx项目官方文档：</p> 
 <p>http://tengine.taobao.org/document_cn/http_upstream_check_cn.html</p> 
 <p>9、启动nginx：<br></p> 
 <pre class="has"><code class="language-bash">/usr/local/nginx/sbin/nginx
</code></pre> 
 <p>10、访问健康状态URL：</p> 
 <pre class="has"><code class="language-ruby"># 默认html格式返回
http://ip:8080/status


# 其它返回格式
http://ip:8080/status?format=html
http://ip:8080/status?format=csv
http://ip:8080/status?format=json
</code></pre> 
 <p><strong>Docker容器化部署方式</strong><br></p> 
 <p>1、编写Dockerfile文件，内容如下：</p> 
 <pre class="has"><code class="language-properties">FROM ansible/centos7-ansible








    # 创建必要的目录
RUN mkdir -p /opt/src &amp;&amp;\
    touch /opt/daemon.log &amp;&amp;\
    # 安装命令
    yum -y install patch unzip wget &amp;&amp;\
    cd /opt/src &amp;&amp;\
    # 下载nginx
    wget http://nginx.org/download/nginx-1.14.0.tar.gz &amp;&amp;\
    tar -xvf nginx-1.14.0.tar.gz &amp;&amp;\
    # 下载nginx_http_upstream_check_module
    wget https://github.com/yaoweibin/nginx_upstream_check_module/archive/master.zip &amp;&amp;\
    unzip master.zip &amp;&amp;\
    cd /opt/src/nginx-1.14.0 &amp;&amp;\
    patch -p1 &lt; /opt/src/nginx_upstream_check_module-master/check_1.14.0+.patch &amp;&amp;\
    # 安装nginx依赖
    yum -y install gcc pcre-devel zlib-devel openssl openssl-devel &amp;&amp;\
    ./configure --prefix=/usr/local/nginx --add-module=/opt/src/nginx_upstream_check_module-master --with-http_stub_status_module --with-http_realip_module &amp;&amp;\
    make &amp;&amp;\
    make install &amp;&amp;\
    rm -rf /etc/localtime &amp;&amp;\
    rm -rf /opt/src/master.zip &amp;&amp;\
    rm -rf /opt/src/nginx-1.14.0* &amp;&amp;\
    cp -R /usr/share/zoneinfo/Asia/Shanghai /etc/localtime




WORKDIR /usr/local/nginx


ENTRYPOINT [ "sh", "-c", "/usr/local/nginx/sbin/nginx &amp;&amp; tail -f /opt/daemon.log" ]
</code></pre> 
 <p>2、编写nginx.conf配置文件，内容如下:</p> 
 <pre class="has"><code class="language-properties">#user  nobody;
worker_processes  1;
#error_log  logs/error.log;
#error_log  logs/error.log  notice;
#error_log  logs/error.log  info;
#pid        logs/nginx.pid;
events {
    worker_connections  1024;
}


http {
    include       mime.types;
    default_type  application/octet-stream;
    #log_format  main  '$remote_addr - $remote_user [$time_local] "$request" '
    #                  '$status $body_bytes_sent "$http_referer" '
    #                  '"$http_user_agent" "$http_x_forwarded_for"';
    #access_log  logs/access.log  main;
    sendfile        on;
    #tcp_nopush     on;
    #keepalive_timeout  0;
    keepalive_timeout  60;
    #gzip  on;


    upstream clusterA {
        # simple round-robin
        # 将max_fails设置为0，不对后端服务器进行健康检查，同时使fail_timeout参数失效
        server 10.68.60.100:8001 max_fails=0 fail_timeout=120s;
        server 10.68.60.101:8001 max_fails=0 fail_timeout=120s;
        server 10.68.60.110:8001 max_fails=0 fail_timeout=120s;
        
        # 每间隔10s向后端服务发起请求，如果请求5s超时且次数达到5次则认为服务不可用
        # 如果请求次数超过2次都没有超时，则认为服务重新可用
        check interval=10000 rise=2 fall=3 timeout=5000 type=http default_down=true;
        check_http_send "GET /healthy HTTP/1.0\r\n\r\n";
        check_http_expect_alive http_2xx http_3xx;
    }


    server {
                listen                  8080;
                server_name             clusterA;
                keepalive_timeout       60;
                proxy_set_header X-Forwarded-Host $host;
                proxy_set_header X-Forwarded-Server $host;
                proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
                proxy_set_header Host $host:$server_port;
     
                location / {
                        # 默认是60s,设置与后端服务器建立连接的超时时间。应该注意这个超时一般不可能大于75秒。
                        proxy_connect_timeout 60;
                        # 默认60s,定义从后端服务器读取响应的超时。此超时是指相邻两次读操作之间的最长时间间隔，而不是整个响应传输完成的最长时间。如果后端服务器在超时时间段内没有传输任何数据，连接将被关闭。
                        proxy_read_timeout 60;
                        # 默认60s, 定义向后端服务器传输请求的超时。此超时是指相邻两次写操作之间的最长时间间隔，而不是整个请求传输完成的最长时间。如果后端服务器在超时时间段内没有接收到任何数据，连接将被关闭。
                        proxy_send_timeout 60;
                        proxy_pass http://clusterA;
                        proxy_set_header X-Forwarded-Host $host;
                        proxy_set_header X-Forwarded-Server $host;
                        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
                        proxy_set_header Host $host:$server_port;
                }
                
                location /status {
                        check_status html;
                        access_log   off;
                        #allow SOME.IP.ADD.RESS;
                        #deny all;
                }
    }
}
</code></pre> 
 <p>3、构建docker镜像，并推送到私服：<br></p> 
 <pre class="has"><code class="language-nginx"># 10.68.60.103:5000 对应你自己的内部私服
docker build --network host -t 10.68.60.103:5000/nginx:1.14.0 -f Dockerfile .
docker push 10.68.60.103:5000/nginx:1.14.0
</code></pre> 
 <p>4、docker运行：</p> 
 <pre class="has"><code class="language-nginx">docker run -d -p 8080:8080 -v /usr/local/nginx/conf/nginx.conf:/usr/local/nginx/conf/nginx.conf 10.68.60.103:5000/nginx:1.14.0
</code></pre> 
 <p>5、访问健康状态地址：</p> 
 <pre class="has"><code class="language-ruby"># 默认html格式返回
http://ip:8080/status
</code></pre> 
 <p style="text-align: center">---------- 正文结束 ----------</p> 
 <p style="text-align: center"><strong>长按扫码关注微信公众号</strong></p> 
 <p style="text-align: center"><img src="https://images2.imgbox.com/98/35/H4g4C94r_o.png"></p> 
 <p style="text-align: center"><strong>Java软件编程之家</strong></p> 
</div>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/d73fa19ef9c74cb8abf5d4a1c8cad98c/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">IDEA系列（二）—IDEA（2019.2.x后的版本）连不上插件(plugins)市场问题解决</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/3dbb4423443525fec20eb5b77e622798/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">MySQL学习笔记（狂神说Java）</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>