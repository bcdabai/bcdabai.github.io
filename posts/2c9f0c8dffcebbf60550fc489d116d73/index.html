<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>MySQL的count(*) ,count(1),count(id)的区别 - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="MySQL的count(*) ,count(1),count(id)的区别" />
<meta property="og:description" content="数据库查询相信很多人都不陌生，所有经常有人调侃程序员就是CRUD专员，这所谓的CRUD指的就是数据库的增删改查。
在数据库的增删改查操作中，使用最频繁的就是查询操作。而在所有查询操作中，统计数量操作更是经常被用到。
关于数据库中行数统计，无论是MySQL还是Oracle，都有一个函数可以使用，那就是COUNT。
但是，就是这个常用的COUNT函数，却暗藏着很多玄机，尤其是在面试的时候，一不小心就会被虐。不信的话请尝试回答下以下问题：
COUNT有几种用法？
COUNT(字段名)和COUNT(*)的查询结果有什么不同？
COUNT(1)和COUNT(*)之间有什么不同？
COUNT(1)和COUNT(*)之间的效率哪个更高？
为什么《阿里巴巴Java开发手册》建议使用COUNT(*)
MySQL的MyISAM引擎对COUNT(*)做了哪些优化？
MySQL的InnoDB引擎对COUNT(*)做了哪些优化？
上面提到的MySQL对COUNT(*)做的优化，有一个关键的前提是什么？
SELECT COUNT(*) 的时候，加不加where条件有差别吗？
COUNT(*)、COUNT(1)和COUNT(字段名)的执行过程是怎样的？
以上10道题，如果您可以全部准确无误的回答的话，那说明你真的很了解COUNT函数了，如果有哪些知识点是不了解的，那么本文正好可以帮你答疑解惑。
认识COUNT 关于COUNT函数，在MySQL官网中有详细介绍：
简单翻译一下：
1、COUNT(expr) ，返回SELECT语句检索的行中expr的值不为NULL的数量。结果是一个BIGINT值。
2、如果查询结果没有命中任何记录，则返回0
3、但是，值得注意的是，COUNT(*) 的统计结果中，会包含值为NULL的行数。
即以下表记录示例：
create table #bla(id int,id2 int)
insert #bla values(null,null)
insert #bla values(1,null)
insert #bla values(null,1)
insert #bla values(1,null)
insert #bla values(null,1)
insert #bla values(1,null)
insert #bla values(null,null)
使用语句count(*),count(id),count(id2)查询结果如下：
select count(*),count(id),count(id2)
from #bla
结果依次是：　７　３　２
除了COUNT(id)和COUNT(*)以外，还可以使用COUNT(常量)（如COUNT(1)）来统计行数，那么这三条SQL语句有什么区别呢？到底哪种效率更高呢？为什么《阿里巴巴Java开发手册》中强制要求不让使用 COUNT(列名)或 COUNT(常量)来替代 COUNT(*)呢？
COUNT(列名)、COUNT(常量)和COUNT(*)之间的区别
前面我们提到过COUNT(expr)用于做行数统计，统计的是expr不为NULL的行数，那么COUNT(列名)、 COUNT(常量) 和 COUNT(*)这三种语法中，expr分别是列名、 常量 和 *。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/2c9f0c8dffcebbf60550fc489d116d73/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-09-08T17:58:15+08:00" />
<meta property="article:modified_time" content="2022-09-08T17:58:15+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">MySQL的count(*) ,count(1),count(id)的区别</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p>数据库查询相信很多人都不陌生，所有经常有人调侃程序员就是CRUD专员，这所谓的CRUD指的就是数据库的增删改查。</p> 
<p>在数据库的增删改查操作中，使用最频繁的就是查询操作。而在所有查询操作中，统计数量操作更是经常被用到。</p> 
<p>关于数据库中行数统计，无论是MySQL还是Oracle，都有一个函数可以使用，那就是COUNT。</p> 
<p>但是，就是这个常用的COUNT函数，却暗藏着很多玄机，尤其是在面试的时候，一不小心就会被虐。不信的话请尝试回答下以下问题：<br>  </p> 
<pre></pre> 
<blockquote> 
 <ol><li> <p><code>COUNT有几种用法？</code></p> </li><li> <p><code>COUNT(字段名)和COUNT(*)的查询结果有什么不同？</code></p> </li><li> <p><code>COUNT(1)和COUNT(*)之间有什么不同？</code></p> </li><li> <p><code>COUNT(1)和COUNT(*)之间的效率哪个更高？</code></p> </li><li> <p><code>为什么《阿里巴巴Java开发手册》建议使用COUNT(*)</code></p> </li><li> <p><code>MySQL的MyISAM引擎对COUNT(*)做了哪些优化？</code></p> </li><li> <p><code>MySQL的InnoDB引擎对COUNT(*)做了哪些优化？</code></p> </li><li> <p><code>上面提到的MySQL对COUNT(*)做的优化，有一个关键的前提是什么？</code></p> </li><li> <p><code>SELECT COUNT(*) 的时候，加不加where条件有差别吗？</code></p> </li><li> <p><code>COUNT(*)、COUNT(1)和COUNT(字段名)的执行过程是怎样的？</code></p> </li></ol> 
</blockquote> 
<p>以上10道题，如果您可以全部准确无误的回答的话，那说明你真的很了解COUNT函数了，如果有哪些知识点是不了解的，那么本文正好可以帮你答疑解惑。</p> 
<p></p> 
<h4><a name="t0"></a>认识COUNT</h4> 
<p>关于COUNT函数，在MySQL官网中有详细介绍：</p> 
<p><img alt="" src="https://images2.imgbox.com/b7/dc/wvs9Nprs_o.png"></p> 
<p>简单翻译一下：</p> 
<p>1、COUNT(expr) ，返回SELECT语句检索的行中expr的值不为NULL的数量。结果是一个BIGINT值。</p> 
<p>2、如果查询结果没有命中任何记录，则返回0</p> 
<p>3、但是，值得注意的是，<code>COUNT(*)</code> 的统计结果中，会包含值为NULL的行数。</p> 
<p>即以下表记录示例：</p> 
<pre></pre> 
<blockquote> 
 <ol><li> <p><code>create table #bla(id int,id2 int)</code></p> </li><li> <p><code>insert #bla values(null,null)</code></p> </li><li> <p><code>insert #bla values(1,null)</code></p> </li><li> <p><code>insert #bla values(null,1)</code></p> </li><li> <p><code>insert #bla values(1,null)</code></p> </li><li> <p><code>insert #bla values(null,1)</code></p> </li><li> <p><code>insert #bla values(1,null)</code></p> </li><li> <p><code>insert #bla values(null,null)</code></p> </li></ol> 
</blockquote> 
<p>使用语句count(*),count(id),count(id2)查询结果如下：</p> 
<pre></pre> 
<blockquote> 
 <ol><li> <p><code>select count(*),count(id),count(id2)</code></p> </li><li> <p><code>from #bla</code></p> </li><li></ol> 
</blockquote> 
<p>结果依次是：　７　　３　　２</p> 
<p></p> 
<p>除了COUNT(id)和COUNT(*)以外，还可以使用COUNT(常量)（如COUNT(1)）来统计行数，那么这三条SQL语句有什么区别呢？到底哪种效率更高呢？为什么《阿里巴巴Java开发手册》中强制要求不让使用 COUNT(列名)或 COUNT(常量)来替代 COUNT(*)呢？<br><img alt="" src="https://images2.imgbox.com/ed/67/ZqDrmuZy_o.png"><br>  </p> 
<h3><a name="t1"></a><br>  </h3> 
<h3><a name="t2"></a>COUNT(列名)、COUNT(常量)和COUNT(*)之间的区别<br>  </h3> 
<p>前面我们提到过<code>COUNT(expr)</code>用于做行数统计，统计的是expr不为NULL的行数，那么<code>COUNT(列名)</code>、 <code>COUNT(常量)</code> 和 <code>COUNT(*)</code>这三种语法中，expr分别是<code>列名</code>、 <code>常量</code> 和 <code>*</code>。</p> 
<p>那么列名、 常量 和 *这三个条件中，常量 是一个固定值，肯定不为NULL。*可以理解为查询整行，所以肯定也不为NULL，那么就只有列名的查询结果有可能是NULL了。</p> 
<p>所以， COUNT(常量) 和 COUNT(*)表示的是直接查询符合条件的数据库表的行数。而COUNT(列名)表示的是查询符合条件的列的值不为NULL的行数。</p> 
<p>除了查询得到结果集有区别之外，COUNT(*)相比COUNT(常量) 和 COUNT(列名)来讲，COUNT(*)是SQL92定义的标准统计行数的语法，因为他是标准语法，所以MySQL数据库对他进行过很多优化。</p> 
<pre><code>SQL92，是数据库的一个ANSI/ISO标准。它定义了一种语言（SQL）以及数据库的行为（事务、隔离级别等）。</code></pre> 
<h4><a name="t3"></a>COUNT(*)的优化</h4> 
<p>前面提到了<code>COUNT(*)</code>是SQL92定义的标准统计行数的语法，所以MySQL数据库对他进行过很多优化。那么，具体都做过哪些事情呢？</p> 
<p>这里的介绍要区分不同的执行引擎。MySQL中比较常用的执行引擎就是InnoDB和MyISAM。</p> 
<p>MyISAM和InnoDB有很多区别，其中有一个关键的区别和我们接下来要介绍的<code>COUNT(*)</code>有关，那就是<strong>MyISAM不支持事务，MyISAM中的锁是表级锁；而InnoDB支持事务，并且支持行级锁。</strong></p> 
<p>因为MyISAM的锁是表级锁，所以同一张表上面的操作需要串行进行，所以，<strong>MyISAM做了一个简单的优化，那就是它可以把表的总行数单独记录下来，如果从一张表中使用COUNT(*)进行查询的时候，可以直接返回这个记录下来的数值就可以了，当然，前提是不能有where条件。</strong></p> 
<p></p> 
<p>MyISAM之所以可以把表中的总行数记录下来供COUNT(*)查询使用，那是因为MyISAM数据库是表级锁，不会有并发的数据库行数修改，所以查询得到的行数是准确的。</p> 
<p>但是，对于InnoDB来说，就不能做这种缓存操作了，因为InnoDB支持事务，其中大部分操作都是行级锁，所以可能表的行数可能会被并发修改，那么缓存记录下来的总行数就不准确了。</p> 
<p>但是，InnoDB还是针对COUNT(*)语句做了些优化的。</p> 
<p>在InnoDB中，使用COUNT(*)查询行数的时候，不可避免的要进行扫表了，那么，就可以在扫表过程中下功夫来优化效率了。</p> 
<p>从MySQL 8.0.13开始，针对InnoDB的<code>SELECT COUNT(*) FROM tbl_name</code>语句，确实在扫表的过程中做了一些优化。前提是查询语句中不包含WHERE或GROUP BY等条件。</p> 
<p><strong>我们知道，COUNT(*)的目的只是为了统计总行数，所以，他根本不关心自己查到的具体值，所以，他如果能够在扫表的过程中，选择一个成本较低的索引进行的话，那就可以大大节省时间。</strong></p> 
<p>我们知道，InnoDB中索引分为聚簇索引（主键索引）和非聚簇索引（非主键索引），聚簇索引的叶子节点中保存的是整行记录，而非聚簇索引的叶子节点中保存的是该行记录的主键的值。</p> 
<p>所以，相比之下，非聚簇索引要比聚簇索引小很多，所以<strong>MySQL会优先选择最小的非聚簇索引来扫表。所以，当我们建表的时候，除了主键索引以外，创建一个非主键索引还是有必要的。</strong></p> 
<p>至此，我们介绍完了MySQL数据库对于COUNT(*)的优化，这些优化的前提都是查询语句中不包含WHERE以及GROUP BY条件。</p> 
<h4><a name="t4"></a>COUNT(*)和COUNT(1)</h4> 
<p>介绍完了<code>COUNT(*)</code>，接下来看看<code>COUNT(1)</code>，对于，这二者到底有没有区别，网上的说法众说纷纭。</p> 
<p>有的说<code>COUNT(*)</code>执行时会转换成<code>COUNT(1)</code>，所以COUNT(1)少了转换步骤，所以更快。</p> 
<p>还有的说，因为MySQL针对<code>COUNT(*)</code>做了特殊优化，所以<code>COUNT(*)</code>更快。</p> 
<p>那么，到底哪种说法是对的呢？看下MySQL官方文档是怎么说的：</p> 
<pre><code>InnoDB handles SELECT COUNT(*) and SELECT COUNT(1) operations in the same way. There is no performance difference.</code></pre> 
<p>画重点：<code>same way</code> , <code>no performance difference</code>。<strong>所以，对于COUNT(1)和COUNT(*)，MySQL的优化是完全一样的，根本不存在谁比谁快！</strong></p> 
<p>那既然<code>COUNT(*)</code>和<code>COUNT(1)</code>一样，建议用哪个呢？</p> 
<p>建议使用<code>COUNT(*)</code>！因为这个是SQL92定义的标准统计行数的语法，而且本文只是基于MySQL做了分析，关于Oracle中的这个问题，也是众说纷纭的呢。</p> 
<h4><a name="t5"></a>COUNT(字段)</h4> 
<p>最后，就是我们一直还没提到的COUNT(字段)，他的查询就比较简单粗暴了，就是进行全表扫描，然后判断指定字段的值是不是为NULL，不为NULL则累加。</p> 
<p>相比<code>COUNT(*)</code>，<code>COUNT(字段)</code>多了一个步骤就是判断所查询的字段是否为NULL，所以他的性能要比<code>COUNT(*)</code>慢。</p> 
<h4><a name="t6"></a>总结</h4> 
<p>本文介绍了COUNT函数的用法，主要用于统计表行数。主要用法有<code>COUNT(*)</code>、<code>COUNT(字段)</code>和<code>COUNT(1)</code>。</p> 
<p>因为COUNT(*)是SQL92定义的标准统计行数的语法，所以MySQL对他进行了很多优化，MyISAM中会直接把表的总行数单独记录下来供COUNT(*)查询，而InnoDB则会在扫表的时候选择最小的索引来降低成本。当然，这些优化的前提都是没有进行where和group的条件查询。</p> 
<p>在InnoDB中<code>COUNT(*)</code>和<code>COUNT(1)</code>实现上没有区别，而且效率一样，但是<code>COUNT(字段)</code>需要进行字段的非NULL判断，所以效率会低一些。</p> 
<p>因为<code>COUNT(*)</code>是SQL92定义的标准统计行数的语法，并且效率高，所以请直接使用<code>COUNT(*)</code>查询表的行数！</p> 
<p>参考资料：<br> https://dev.mysql.com/doc/refman/8.0/en/group-by-functions.html#function_count<br> 《极客时间——MySQL实战45讲》</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/ddc0b997e44af396d88edd8c72fc567a/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">Could not resolve hostname 。。。。。。: Name or service not known(学习笔记，不作教程)</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/747490b9bb586d091bfb9eee19b37236/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">JavaScript 中常用事件有哪些？</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>