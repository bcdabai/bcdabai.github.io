<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>【ROS】使用pluginlib自定义costmap地图层 - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="【ROS】使用pluginlib自定义costmap地图层" />
<meta property="og:description" content="文章目录 文章目录
前言
一、重写地图层
1.包含头文件 2.onInitialize()
3.updateBounds()
4.updateCosts()
二、向ROS注册
1.插件描述文件
2.向ROS注册插件
3.在costmap配置文件中使用
总结
前言 pluginlib是一个 C&#43;&#43; 库，用于从 ROS 包中加载和卸载插件。插件是从运行时库（即共享对象、动态链接库）加载的动态可加载类。使用 pluginlib，人们不必将他们的应用程序显式链接到包含类的库，相反，pluginlib 可以在任何时候打开一个包含导出类的库，而无需应用程序事先知道该库或包含类定义的头文件. 插件可用于在不需要应用程序源代码的情况下扩展/修改应用程序行为。
在costmap中就为用户提供了便捷丰富的地图层接口，用户可以使用C&#43;&#43;中的继承操作，继承costmap_2d中的类，然后重写其中的虚函数，以实现自己的地图层功能，本文以添加禁用区域为例说明如何实现一个自定义的costmap地图层。
一、重写地图层 1.包含头文件 为了允许动态加载类，必须将其标记为导出类。这是通过特殊宏PLUGINLIB_EXPORT_CLASS完成的。一般PLUGINLIB_EXPORT_CLASS都写在文件的开头，以虚拟墙地图层为例：
#include &lt;costmap_prohibition_layer/costmap_prohibition_layer.h&gt; #include &lt;pluginlib/class_list_macros.h&gt; PLUGINLIB_EXPORT_CLASS(costmap_prohibition_layer_namespace::CostmapProhibitionLayer, costmap_2d::Layer) 如果想实现基本的地图层插件至少要重写这几个函数：
void onInitialize()：在costmap执行初始化initialize后会执行这个函数，相当于为用户提供的初始化接口。void updateBounds(double robot_x, double robot_y, double robot_yaw, double *min_x, double *min_y, double *max_x, double *max_y)：计算插件图层要更新到主图层区域的大小，每个图层都可以增加这个尺寸，如下图（b）所示void updateCosts(costmap_2d::Costmap2D&amp; master_grid, int min_i, int min_j, int max_i, int max_j)：将每个图层的代价值更新到主图层，如下图（c）（d）（e）所示 2.onInitialize() onInitialize()函数主要执行一些初始化工作，如下面代码所示，下面进行逐行讲解。
void CostmapProhibitionLayer::onInitialize() { ros::NodeHandle nh(&#34;~/&#34; &#43; name_); current_ = true; _dsrv = new dynamic_reconfigure::Server&lt;CostmapProhibitionLayerConfig&gt;(nh); dynamic_reconfigure::Server&lt;CostmapProhibitionLayerConfig&gt;::CallbackType cb = boost::bind(&amp;CostmapProhibitionLayer::reconfigureCB, this, _1, _2); _dsrv-&gt;setCallback(cb); // get a pointer to the layered costmap and save resolution costmap_2d::Costmap2D *costmap = layered_costmap_-&gt;getCostmap(); _costmap_resolution = costmap-&gt;getResolution(); // set initial bounds _min_x = _min_y = _max_x = _max_y = 0; // reading the prohibition areas out of the namespace of this plugin!" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/84bc7bf7f59d4c67ab0009a3001422f1/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-01-16T13:35:01+08:00" />
<meta property="article:modified_time" content="2023-01-16T13:35:01+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">【ROS】使用pluginlib自定义costmap地图层</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <h4 id="%E6%96%87%E7%AB%A0%E7%9B%AE%E5%BD%95">文章目录</h4> 
<p><a href="#%E6%96%87%E7%AB%A0%E7%9B%AE%E5%BD%95" rel="nofollow">文章目录</a></p> 
<div> 
 <p id="%E5%89%8D%E8%A8%80-toc" style="margin-left:0px;"><a href="#%E5%89%8D%E8%A8%80" rel="nofollow">前言</a></p> 
 <p id="%E4%B8%80%E3%80%81%E9%87%8D%E5%86%99%E5%9C%B0%E5%9B%BE%E5%B1%82-toc" style="margin-left:0px;"><a href="#%E4%B8%80%E3%80%81%E9%87%8D%E5%86%99%E5%9C%B0%E5%9B%BE%E5%B1%82" rel="nofollow">一、重写地图层</a></p> 
 <p id="1.%E5%8C%85%E5%90%AB%E5%A4%B4%E6%96%87%E4%BB%B6%C2%A0-toc" style="margin-left:40px;"><a href="#1.%E5%8C%85%E5%90%AB%E5%A4%B4%E6%96%87%E4%BB%B6%C2%A0" rel="nofollow">1.包含头文件 </a></p> 
 <p id="2.onInitialize()-toc" style="margin-left:40px;"><a href="#2.onInitialize%28%29" rel="nofollow">2.onInitialize()</a></p> 
 <p id="3.updateBounds()-toc" style="margin-left:40px;"><a href="#3.updateBounds%28%29" rel="nofollow">3.updateBounds()</a></p> 
 <p id="4.updateCosts()-toc" style="margin-left:40px;"><a href="#4.updateCosts%28%29" rel="nofollow">4.updateCosts()</a></p> 
 <p id="%E4%BA%8C%E3%80%81%E5%90%91ROS%E6%B3%A8%E5%86%8C-toc" style="margin-left:0px;"><a href="#%E4%BA%8C%E3%80%81%E5%90%91ROS%E6%B3%A8%E5%86%8C" rel="nofollow">二、向ROS注册</a></p> 
 <p id="1.%E6%8F%92%E4%BB%B6%E6%8F%8F%E8%BF%B0%E6%96%87%E4%BB%B6-toc" style="margin-left:40px;"><a href="#1.%E6%8F%92%E4%BB%B6%E6%8F%8F%E8%BF%B0%E6%96%87%E4%BB%B6" rel="nofollow">1.插件描述文件</a></p> 
 <p id="2.%E5%90%91ROS%E6%B3%A8%E5%86%8C%E6%8F%92%E4%BB%B6-toc" style="margin-left:40px;"><a href="#2.%E5%90%91ROS%E6%B3%A8%E5%86%8C%E6%8F%92%E4%BB%B6" rel="nofollow">2.向ROS注册插件</a></p> 
 <p id="3.%E5%9C%A8costmap%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E4%B8%AD%E4%BD%BF%E7%94%A8-toc" style="margin-left:40px;"><a href="#3.%E5%9C%A8costmap%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E4%B8%AD%E4%BD%BF%E7%94%A8" rel="nofollow">3.在costmap配置文件中使用</a></p> 
 <p id="%E6%80%BB%E7%BB%93-toc" style="margin-left:0px;"><a href="#%E6%80%BB%E7%BB%93" rel="nofollow">总结</a></p> 
</div> 
<hr> 
<h2 id="%E5%89%8D%E8%A8%80"><a id="_7"></a>前言</h2> 
<p><strong>pluginlib</strong>是一个 C++ 库，用于从 ROS 包中加载和卸载<strong>插件。</strong>插件是从运行时库（即共享对象、动态链接库）加载的动态可加载类。使用 pluginlib，人们不必将他们的应用程序显式链接到包含类的库，相反，pluginlib 可以在任何时候打开一个包含导出类的库，而无需应用程序事先知道该库或包含类定义的头文件. 插件可用于在不需要应用程序源代码的情况下扩展/修改应用程序行为。</p> 
<p>在costmap中就为用户提供了便捷丰富的地图层接口，用户可以使用C++中的继承操作，继承costmap_2d中的类，然后重写其中的虚函数，以实现自己的地图层功能，本文以添加禁用区域为例说明如何实现一个自定义的costmap地图层。</p> 
<hr> 
<h2 id="%E4%B8%80%E3%80%81%E9%87%8D%E5%86%99%E5%9C%B0%E5%9B%BE%E5%B1%82"><a id="pandas_16"></a>一、重写地图层</h2> 
<h3 id="1.%E5%8C%85%E5%90%AB%E5%A4%B4%E6%96%87%E4%BB%B6%C2%A0">1.包含头文件 </h3> 
<p>为了允许动态加载类，必须将其标记为导出类。这是通过特殊宏PLUGINLIB_EXPORT_CLASS完成的。一般PLUGINLIB_EXPORT_CLASS都写在文件的开头，以虚拟墙地图层为例：</p> 
<pre><code class="language-cpp">#include &lt;costmap_prohibition_layer/costmap_prohibition_layer.h&gt;
#include &lt;pluginlib/class_list_macros.h&gt;

PLUGINLIB_EXPORT_CLASS(costmap_prohibition_layer_namespace::CostmapProhibitionLayer, costmap_2d::Layer)</code></pre> 
<p>如果想实现基本的地图层插件<span style="background-color:#ffd900;">至少要重写这几个函数</span>：</p> 
<ul><li>void onInitialize()：在costmap执行初始化initialize后会执行这个函数，相当于为用户提供的初始化接口。</li><li>void updateBounds(double robot_x, double robot_y, double robot_yaw, double *min_x, double *min_y, double *max_x, double *max_y)：计算插件图层要更新到主图层区域的大小，每个图层都可以增加这个尺寸，如下图（b）所示</li><li>void updateCosts(costmap_2d::Costmap2D&amp; master_grid, int min_i, int min_j, int max_i, int max_j)：将每个图层的代价值更新到主图层，如下图（c）（d）（e）所示</li></ul> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/44/6d/zvoIkKWu_o.jpg"></p> 
<h3 id="2.onInitialize()">2.onInitialize()</h3> 
<p> onInitialize()函数主要执行一些初始化工作，如下面代码所示，下面进行逐行讲解。</p> 
<pre><code class="language-cpp">void CostmapProhibitionLayer::onInitialize()

{
  ros::NodeHandle nh("~/" + name_);
  current_ = true;

  _dsrv = new dynamic_reconfigure::Server&lt;CostmapProhibitionLayerConfig&gt;(nh);
  dynamic_reconfigure::Server&lt;CostmapProhibitionLayerConfig&gt;::CallbackType cb =
      boost::bind(&amp;CostmapProhibitionLayer::reconfigureCB, this, _1, _2);
  _dsrv-&gt;setCallback(cb);

  // get a pointer to the layered costmap and save resolution
  costmap_2d::Costmap2D *costmap = layered_costmap_-&gt;getCostmap();
  _costmap_resolution = costmap-&gt;getResolution();

  // set initial bounds
  _min_x = _min_y = _max_x = _max_y = 0;
  
  // reading the prohibition areas out of the namespace of this plugin!
  // e.g.: "move_base/global_costmap/prohibition_layer/prohibition_areas"
  std::string params = "prohibition_areas";
  if (!parseProhibitionListFromYaml(&amp;nh, params))
    ROS_ERROR_STREAM("Reading prohibition areas from '" &lt;&lt; nh.getNamespace() &lt;&lt; "/" &lt;&lt; params &lt;&lt; "' failed!");
  
  _fill_polygons = true;
  nh.param("fill_polygons", _fill_polygons, _fill_polygons);
  
  // compute map bounds for the current set of prohibition areas.
  computeMapBounds();
  
  ROS_INFO("CostmapProhibitionLayer initialized.");
}</code></pre> 
<p>创建ros节点句柄：</p> 
<pre><code class="language-cpp">ros::NodeHandle nh("~/" + name_);
current_ = true;</code></pre> 
<p>创建动态配置的服务器和回调函数，并为服务器配置回调函数，这部分在<a class="link-info" href="https://blog.csdn.net/qq_52785580/article/details/128693760?spm=1001.2014.3001.5501" title="我的其他文章">我的其他文章</a>进行过详细说明。</p> 
<pre><code class="language-cpp">_dsrv = new dynamic_reconfigure::Server&lt;CostmapProhibitionLayerConfig&gt;(nh);
dynamic_reconfigure::Server&lt;CostmapProhibitionLayerConfig&gt;::CallbackType cb =
      boost::bind(&amp;CostmapProhibitionLayer::reconfigureCB, this, _1, _2);
_dsrv-&gt;setCallback(cb);</code></pre> 
<p>获得地图数据的指针和分辨率参数：</p> 
<pre><code class="language-cpp">// get a pointer to the layered costmap and save resolution
  costmap_2d::Costmap2D *costmap = layered_costmap_-&gt;getCostmap();
  _costmap_resolution = costmap-&gt;getResolution();</code></pre> 
<p>从yaml文件中读取虚拟墙区域：</p> 
<pre><code class="language-cpp">// reading the prohibition areas out of the namespace of this plugin!
  // e.g.: "move_base/global_costmap/prohibition_layer/prohibition_areas"
  std::string params = "prohibition_areas";
  if (!parseProhibitionListFromYaml(&amp;nh, params))
    ROS_ERROR_STREAM("Reading prohibition areas from '" &lt;&lt; nh.getNamespace() &lt;&lt; "/" &lt;&lt; params &lt;&lt; "' failed!");</code></pre> 
<p>从launch文件中读取参数，是否完全更新多边形区域，然后computeMapBounds()函数用来计算更新区域的最大最小值。</p> 
<pre><code class="language-cpp">_fill_polygons = true;
nh.param("fill_polygons", _fill_polygons, _fill_polygons);
  
// compute map bounds for the current set of prohibition areas.
computeMapBounds();
  
ROS_INFO("CostmapProhibitionLayer initialized.");</code></pre> 
<h3 id="3.updateBounds()">3.updateBounds()</h3> 
<p>updateBounds()函数用来根据刚才computeMapBounds()计算得到的最大最小区域更新costmap中定义的最大最小区域变量double *min_x, double *min_y, double *max_x, double *max_y：</p> 
<pre><code class="language-cpp">void CostmapProhibitionLayer::updateBounds(double robot_x, double robot_y, double robot_yaw, 
                                           double *min_x, double *min_y, double *max_x, double *max_y)
{
    if (!enabled_)
        return;
    
    std::lock_guard&lt;std::mutex&gt; l(_data_mutex);
    
    if (_prohibition_points.empty() &amp;&amp; _prohibition_polygons.empty())
        return;

    *min_x = std::min(*min_x, _min_x);
    *min_y = std::min(*min_y, _min_y);
    *max_x = std::max(*max_x, _max_x);
    *max_y = std::max(*max_y, _max_y);

}</code></pre> 
<p>这里面主要就是进行了一个赋值操作</p> 
<h3 id="4.updateCosts()">4.updateCosts()</h3> 
<p>updateCosts()是最主要的功能，用来将地图层的代价更新到主图层，这里面主要有两个部分，第一个循环是更新禁止通行的区域，第二个循环是更新禁止通行的点（因为这个图层约定的yaml文件格式可以选择禁用点或直线或区域，所以这里分开处理）</p> 
<pre><code class="language-cpp">void CostmapProhibitionLayer::updateCosts(costmap_2d::Costmap2D &amp;master_grid, int min_i, int min_j, int max_i, int max_j)
{
  if (!enabled_)
    return;

  std::lock_guard&lt;std::mutex&gt; l(_data_mutex);
  
  // set costs of polygons
  for (int i = 0; i &lt; _prohibition_polygons.size(); ++i)
  {
      setPolygonCost(master_grid, _prohibition_polygons[i], LETHAL_OBSTACLE, min_i, min_j, max_i, max_j, _fill_polygons);
  }
      
  // set cost of points
  for (int i = 0; i &lt; _prohibition_points.size(); ++i)
  {
    unsigned int mx;
    unsigned int my;
    if (master_grid.worldToMap(_prohibition_points[i].x, _prohibition_points[i].y, mx, my))
    {
      master_grid.setCost(mx, my, LETHAL_OBSTACLE);
    }
  }
}</code></pre> 
<p>先调用了setPolygonCost()函数将禁用区域的代价值设置为“致命障碍”（LETHAL_OBSTACLE）</p> 
<pre><code class="language-cpp">  // set costs of polygons
  for (int i = 0; i &lt; _prohibition_polygons.size(); ++i)
  {
      setPolygonCost(master_grid, _prohibition_polygons[i], LETHAL_OBSTACLE, min_i, min_j, max_i, max_j, _fill_polygons);
  }</code></pre> 
<p><strong>setPolygonCost()函数</strong>如下：</p> 
<pre><code class="language-cpp">void CostmapProhibitionLayer::setPolygonCost(costmap_2d::Costmap2D &amp;master_grid, const std::vector&lt;geometry_msgs::Point&gt;&amp; polygon, unsigned char cost,
                                             int min_i, int min_j, int max_i, int max_j, bool fill_polygon)
{
    std::vector&lt;PointInt&gt; map_polygon;
    for (unsigned int i = 0; i &lt; polygon.size(); ++i)
    {
        PointInt loc;
        master_grid.worldToMapNoBounds(polygon[i].x, polygon[i].y, loc.x, loc.y);
        map_polygon.push_back(loc);
    }

    std::vector&lt;PointInt&gt; polygon_cells;

    // get the cells that fill the polygon
    rasterizePolygon(map_polygon, polygon_cells, fill_polygon);

    // set the cost of those cells
    for (unsigned int i = 0; i &lt; polygon_cells.size(); ++i)
    {
        int mx = polygon_cells[i].x;
        int my = polygon_cells[i].y;
        // check if point is outside bounds
        if (mx &lt; min_i || mx &gt;= max_i)
            continue;
        if (my &lt; min_j || my &gt;= max_j)
            continue;
        master_grid.setCost(mx, my, cost);
    }
}</code></pre> 
<p>先通过这几行代码，将多边形区域的世界坐标转化为地图边界，存储在loc变量中（作者定义的结构体，有两个变量int x和int y），然后通过rasterizePolygon函数获得这个区域内所有单元格的地图坐标</p> 
<pre><code class="language-cpp">std::vector&lt;PointInt&gt; map_polygon;
for (unsigned int i = 0; i &lt; polygon.size(); ++i)
{
    PointInt loc;
    master_grid.worldToMapNoBounds(polygon[i].x, polygon[i].y, loc.x, loc.y);
    map_polygon.push_back(loc);
}

std::vector&lt;PointInt&gt; polygon_cells;

// get the cells that fill the polygon
rasterizePolygon(map_polygon, polygon_cells, fill_polygon);</code></pre> 
<p>这个循环是根据获得的序号设置代价值，关键函数是setCost函数，根据每一个单元格的地图坐标，将其代价值设置为“致命障碍”</p> 
<pre><code class="language-cpp">// set the cost of those cells
for (unsigned int i = 0; i &lt; polygon_cells.size(); ++i)
{
    int mx = polygon_cells[i].x;
    int my = polygon_cells[i].y;
    // check if point is outside bounds
    if (mx &lt; min_i || mx &gt;= max_i)
        continue;
    if (my &lt; min_j || my &gt;= max_j)
        continue;
    master_grid.setCost(mx, my, cost);
}</code></pre> 
<p>然后这个循环就更简单了，直接使用worldToMap()函数将世界坐标转化为地图坐标，然后根据获得的地图坐标使用setCost()函数设置代价值。</p> 
<pre><code class="language-cpp">  // set cost of points
  for (int i = 0; i &lt; _prohibition_points.size(); ++i)
  {
    unsigned int mx;
    unsigned int my;
    if (master_grid.worldToMap(_prohibition_points[i].x, _prohibition_points[i].y, mx, my))
    {
      master_grid.setCost(mx, my, LETHAL_OBSTACLE);
    }
  }</code></pre> 
<hr> 
<p> </p> 
<h2 id="%E4%BA%8C%E3%80%81%E5%90%91ROS%E6%B3%A8%E5%86%8C"><a id="_19"></a></h2> 
<h2>二、向ROS注册</h2> 
<h3><a id="1_20"></a></h3> 
<h3 id="1.%E6%8F%92%E4%BB%B6%E6%8F%8F%E8%BF%B0%E6%96%87%E4%BB%B6">1.插件描述文件</h3> 
<p><strong>插件描述文件</strong>是一个 XML 文件，用于以机器可读格式存储有关插件的所有重要信息。它包含有关插件所在的库、插件名称、插件类型等的信息。对于虚拟墙禁用图层，它的描述性文件是这样的：</p> 
<pre><code class="language-XML">&lt;library path="lib/libcostmap_prohibition_layer"&gt;
  &lt;class type="costmap_prohibition_layer_namespace::CostmapProhibitionLayer" base_class_type="costmap_2d::Layer"&gt;
    &lt;description&gt;ROS-Package that implements a costmap layer to add prohibited areas to the costmap-2D by a user configuration.&lt;/description&gt;
  &lt;/class&gt;
&lt;/library&gt;</code></pre> 
<p><strong>library</strong>标签定义插件类所在的库。一个库可能包含多个不同类类型的插件。</p> 
<p><strong>class</strong>标签描述了库提供的类。</p> 
<p style="margin-left:0;"><span style="color:#333333;"><span style="background-color:#ffffff;">属性：</span></span></p> 
<ul><li> <p style="margin-left:.25em;">name ：类的查找名称。由<a href="http://wiki.ros.org/pluginlib" rel="nofollow" title="pluginlib">pluginlib</a>工具用作插件的标识符。</p> </li><li>type ：完全限定的类的类型。</li><li>base_class_type ：基类的完全限定类型</li><li>description ：类及其作用的描述。</li></ul> 
<p>更详细的描述可以查看<a class="link-info" href="http://wiki.ros.org/pluginlib/PluginDescriptionFile" rel="nofollow" title="这个文档">这个文档</a>。</p> 
<h3 id="2.%E5%90%91ROS%E6%B3%A8%E5%86%8C%E6%8F%92%E4%BB%B6">2.向ROS注册插件</h3> 
<p>为了让 pluginlib 查询系统上所有 ROS 包中的所有可用插件，每个包必须明确指定它导出的插件以及哪些包库包含这些插件。插件提供者必须在其导出标记块内的package.xml中指向其插件描述文件，需要在package.xml文件最后添加这样一个标签：</p> 
<div> 
 <pre><code class="language-XML">  &lt;export&gt;
    &lt;costmap_2d plugin="${prefix}/costmap_plugins.xml" /&gt;
  &lt;/export&gt;</code></pre> 
</div> 
<p>当然需要在前面添加对基类(costmap_2d)的依赖：</p> 
<div> 
 <pre><code class="language-XML">&lt;depend&gt;costmap_2d&lt;/depend&gt;</code></pre> 
</div> 
<p>然后在工作空间中使用catkin_make或catkin_make_isolated编译即可，然后使用以下命令查看：</p> 
<div> 
 <pre><code class="language-bash">rospack plugins --attrib=plugin costmap_2d
</code></pre> 
</div> 
<p>如果出现以下结果，则说明插件可用：</p> 
<pre><code class="language-bash">costmap_prohibition_layer /home/lyh/catkin_acad/src/costmap_prohibition_layer-repush3/costmap_plugins.xml
costmap_2d /opt/ros/kinetic/share/costmap_2d/costmap_plugins.xml
</code></pre> 
<h3 id="3.%E5%9C%A8costmap%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E4%B8%AD%E4%BD%BF%E7%94%A8">3.在costmap配置文件中使用</h3> 
<p>在参数配置文件夹中找到　global_costmap_params.yaml　和/或　local_costmap_params.yaml，在末尾添加或修改：</p> 
<pre><code class="language-XML"> plugins:
      - {name: static_map,       type: "costmap_2d::StaticLayer"}
      - {name: obstacles,        type: "costmap_2d::VoxelLayer"}
      - {name: inflation_layer,        type: "costmap_2d::InflationLayer"}
      - {name: costmap_prohibition_layer,        type: "costmap_prohibition_layer_namespace::CostmapProhibitionLayer"}    
</code></pre> 
<p>对于虚拟墙地图层，还需要在param文件夹中自己配置一个设置禁止区域的参数文件，在参数配置文件夹（就是和　global_costmap_params.yaml　以及　local_costmap_params.yaml　相同位置的文件夹）中创建新的文档，命名为　＂prohibition_areas.yaml＂，然后在prohibition_areas.yaml文档中输入:</p> 
<pre><code class="language-XML">prohibition_areas:
#定义一个禁止点
 - [17.09, -6.388]
# 定义一个禁止通行的线
 - [[8.33, 2.11],
    [8.26, 5.11]]
# 定义一个禁止通行的区域
 - [[-11.15, -15.614],
    [-12.35, -13.89],
    [-10.05, -12.218]]</code></pre> 
<p>注意事项：<br> １.一定要严格按照上述格式来设置坐标，可能出现情况：<br> 　　(1)坐标前的短横线没对齐<br> 　　(2)定义禁止区域或者禁止线，两坐标之间缺少了逗号<br> ２.你可以同时定义多个禁止点／多个禁止线／多个禁止区域，或者混合定义多个点／线／区域．</p> 
<hr> 
<h2 id="%E6%80%BB%E7%BB%93"><a id="_45"></a>总结</h2> 
<p>本文以虚拟墙禁用层为例，详细介绍了如何实现一个自定义的costmap地图层，以及如何在ROS中使用pluginlib制作一个插件，插件机制应用广泛，使用C++的类继承为用户提供了极大的便利。</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/eee0f280d83fa39e322e3bb6425b42ce/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">在Linux上手工配置ip地址</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/f6ec91900b2db064d4b0565ee3b76e48/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">win32 ini 读取所有section 下边的key value</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>