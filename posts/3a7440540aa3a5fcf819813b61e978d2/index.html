<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>SpringBoot 插件 spring-boot-maven-plugin 原理，以及SpringBoo工程部署的 jar 包瘦身实战 - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="SpringBoot 插件 spring-boot-maven-plugin 原理，以及SpringBoo工程部署的 jar 包瘦身实战" />
<meta property="og:description" content="spring-boot-maven-plugin 我们直接使用 maven package （maven自带的package打包功能），打包Jar包的时候，不会将该项目所依赖的Jar包一起打进去，在使用java -jar命令启动项目时会报错，项目无法正常启动。这个时候，我们就可以考虑引用spring-boot-maven-plugin插件来为项目打Jar包。
maven项目的pom.xml中，添加了下述插件，当运行 maven package 进行打包时，会打包成一个可以直接运行的JAR（fat jar）文件，使用 java -jar 命令就可以直接运行。
注意：如果你的项目没有继承spring-boot-starter-parent 这个POM，你需要做如下配置，将目标绑定到repackage。
&lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;executions&gt; &lt;execution&gt; &lt;goals&gt; &lt;goal&gt;repackage&lt;/goal&gt; &lt;/goals&gt; &lt;/execution&gt; &lt;/executions&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt; 默认情况下maven项目的打包命令，在打Jar包时不会把依赖的jar包也打包进去，但是spring-boot-maven-plugin插件，会将依赖的jar包全部打包进去。例如下面这个使用spring-boot-maven-plugin插件打包生成的jar包的BOOT/INF/lib目录下面就包含了所有依赖的jar包：
引入了spring-boot-maven-plugin插件后，在使用打包功能时会将mvn package 生成的 jar或者war 重新打包成可执行文件，同时修改原文件名，增加.origin 后缀。
可执行 Jar 包内部结构 将打出来的可执行 Jar 解压开我们能看到下面的结构：
可执行 jar 目录结构
├─BOOT-INF │ ├─classes │ └─lib ├─META-INF │ ├─maven │ ├─app.properties │ ├─MANIFEST.MF └─org └─springframework └─boot └─loader ├─archive ├─data ├─jar └─util 结构对比 从上面的文件结构和 jar 清单内容来看，Spring Boot 打包后的 fatjar 对比 源 jar 主要有以下差异：" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/3a7440540aa3a5fcf819813b61e978d2/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-05-25T09:15:00+08:00" />
<meta property="article:modified_time" content="2023-05-25T09:15:00+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">SpringBoot 插件 spring-boot-maven-plugin 原理，以及SpringBoo工程部署的 jar 包瘦身实战</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-light">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <h2><a id="springbootmavenplugin_0"></a>spring-boot-maven-plugin</h2> 
<p>我们直接使用 <code>maven package</code> （maven自带的package打包功能），打包Jar包的时候，不会将该项目所依赖的Jar包一起打进去，在使用<code>java -jar</code>命令启动项目时会报错，项目无法正常启动。这个时候，我们就可以考虑引用<code>spring-boot-maven-plugin</code>插件来为项目打Jar包。</p> 
<p>maven项目的pom.xml中，添加了下述插件，当运行 <strong>maven package</strong> 进行打包时，会打包成一个可以直接运行的JAR（<strong>fat</strong> jar）文件，使用 <strong>java -jar</strong> 命令就可以直接运行。</p> 
<blockquote> 
 <p>注意：如果你的项目没有继承spring-boot-starter-parent 这个POM，你需要做如下配置，将目标绑定到repackage。</p> 
</blockquote> 
<pre><code>&lt;build&gt;
	&lt;plugins&gt;
		&lt;plugin&gt;
                &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
                &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt;
                &lt;executions&gt;
                    &lt;execution&gt;
                        &lt;goals&gt;
                            &lt;goal&gt;repackage&lt;/goal&gt;
                        &lt;/goals&gt;
                    &lt;/execution&gt;
                &lt;/executions&gt;
            &lt;/plugin&gt;
	&lt;/plugins&gt;
&lt;/build&gt;
</code></pre> 
<p><img src="https://images2.imgbox.com/90/32/VrwtdCik_o.png" alt="在这里插入图片描述"></p> 
<p>默认情况下maven项目的打包命令，在打Jar包时不会把依赖的jar包也打包进去，但是spring-boot-maven-plugin插件，会将依赖的jar包全部打包进去。例如下面这个使用spring-boot-maven-plugin插件打包生成的jar包的<code>BOOT/INF/lib</code>目录下面就包含了所有依赖的jar包：</p> 
<blockquote> 
 <p>引入了spring-boot-maven-plugin插件后，在使用打包功能时会将mvn package 生成的 jar或者war 重新打包成可执行文件，同时修改原文件名，增加.origin 后缀。</p> 
</blockquote> 
<p><img src="https://images2.imgbox.com/1c/b4/ioNbC8Fk_o.png" alt="在这里插入图片描述"></p> 
<h3><a id="_Jar__38"></a>可执行 Jar 包内部结构</h3> 
<p>将打出来的可执行 Jar 解压开我们能看到下面的结构：</p> 
<p>可执行 jar 目录结构</p> 
<p><img src="https://images2.imgbox.com/b4/ce/W6tEUMCJ_o.png" alt="在这里插入图片描述"></p> 
<pre><code>├─BOOT-INF
│  ├─classes
│  └─lib
├─META-INF
│  ├─maven
│  ├─app.properties
│  ├─MANIFEST.MF      
└─org
    └─springframework
        └─boot
            └─loader
                ├─archive
                ├─data
                ├─jar
                └─util
</code></pre> 
<h4><a id="_64"></a>结构对比</h4> 
<p>从上面的文件结构和 jar 清单内容来看，Spring Boot 打包后的 fatjar 对比 源 jar 主要有以下差异：</p> 
<ul><li>源 jar 中主项目的 <code>.class</code> 文件被移至 <code>fatjar</code> 的 <code>BOOT-INF/classes</code> 文件夹下。</li><li>新增 <code>BOOT-INF/lib</code> 文件夹，里面存放三方 jar 文件。</li><li>新增 <code>BOOT-INF/classpath.idx</code>，用来记录 <code>classpath</code> 的加载顺序。</li><li>新增 <code>org/springframework/boot/loader</code> 文件夹，这是 <code>spring-boot-loader</code> 编译后的 .class 文件。</li><li>清单文件 <code>MANIFEST.MF</code>中新增以下属性:</li><li><code>Spring-Boot-Classpath-Index</code>: 记录<code> classpath.idx</code> 文件的地址。</li><li><code>Start-Class</code>: 指定 <code>Spring Boot</code> 的启动类。</li><li><code>Spring-Boot-Classes</code>: 记录主项目的 <code>.class</code> 文件存放路径。</li><li><code>Spring-Boot-Lib</code>: 记录三方 jar 文件存放路径。</li><li><code>Spring-Boot-Version</code>: 记录 <code>Spring Boot</code> 版本信息</li><li><code>Main-Class</code>: 指定 jar 程序的入口类（可执行 jar 为 <code>org.springframework.boot.loader.JarLauncher</code>类）。</li></ul> 
<p>我们先来重点关注两个地方：META-INF 下面的 Jar 包描述文件和 BOOT-INF 这个目录。</p> 
<pre><code>Manifest-Version: 1.0
Archiver-Version: Plexus Archiver
Built-By: xxxx
Start-Class: com.xxxx.AppServer
Spring-Boot-Classes: BOOT-INF/classes/
Spring-Boot-Lib: BOOT-INF/lib/
Spring-Boot-Version: 2.1.6.RELEASE
Created-By: Apache Maven 3.3.9
Build-Jdk: 1.8.0_73
Main-Class: org.springframework.boot.loader.JarLauncher
</code></pre> 
<p>在上面我们看到一个熟悉的配置Main-Class: org.springframework.boot.loader.JarLauncher。我们大概能猜到这个类是整个系统的入口。</p> 
<p>再看下 BOOT-INF 这个目录下面，我们会发现里面是我们项目打出来的 class 文件和项目依赖的 Jar 包。看到这里，你可能已经猜到 Spring Boot 是怎么启动项目的了。</p> 
<h3><a id="Spring_Boot__100"></a>Spring Boot 是怎么启动项目</h3> 
<h4><a id="JarLauncher_102"></a>JarLauncher</h4> 
<pre><code>public class JarLauncher extends ExecutableArchiveLauncher {

	static final String BOOT_INF_CLASSES = "BOOT-INF/classes/";

	static final String BOOT_INF_LIB = "BOOT-INF/lib/";

	public JarLauncher() {
	}

	protected JarLauncher(Archive archive) {
		super(archive);
	}

	@Override
	protected boolean isNestedArchive(Archive.Entry entry) {
		if (entry.isDirectory()) {
			return entry.getName().equals(BOOT_INF_CLASSES);
		}
		return entry.getName().startsWith(BOOT_INF_LIB);
	}

	public static void main(String[] args) throws Exception {
        //项目入口，重点在launch这个方法中
		new JarLauncher().launch(args);
	}
}
</code></pre> 
<pre><code>//launch方法
protected void launch(String[] args) throws Exception {
    JarFile.registerUrlProtocolHandler();
    //创建LaunchedURLClassLoader。如果根类加载器和扩展类加载器没有加载到某个类的话，就会通过LaunchedURLClassLoader这个加载器来加载类。这个加载器会从Boot-INF下面的class目录和lib目录下加载类。
    ClassLoader classLoader = createClassLoader(getClassPathArchives());
    //这个方法会读取jar描述文件中的Start-Class属性，然后通过反射调用到这个类的main方法。
    launch(args, getMainClass(), classLoader);
}  
</code></pre> 
<h3><a id="_144"></a>简单总结</h3> 
<ul><li> <p>Spring Boot 可执行 Jar 包的入口点是 JarLauncher 的 main 方法；</p> </li><li> <p>这个方法的执行逻辑是先创建一个 LaunchedURLClassLoader，这个加载器加载类的逻辑是：</p> 
  <blockquote> 
   <p>先判断根类加载器和扩展类加载器能否加载到某个类，如果都加载不到就从 Boot-INF 下面的 class 和 lib 目录下去加载；</p> 
  </blockquote> </li><li> <p>读取Start-Class属性，通过反射机制调用启动类的 main 方法，这样就顺利调用到我们开发的 Spring Boot 主启动类的 main 方法了。</p> </li></ul> 
<h2><a id="Goal_154"></a>Goal</h2> 
<p><a href="https://docs.spring.io/spring-boot/docs/current/maven-plugin/reference/htmlsingle/" rel="nofollow">spring-boot-maven-plugin</a> 官方文档 介绍的有五种 goal，分别如下：</p> 
<ul><li>spring-boot:build-image: 将程序使用 buildpack 打包进容器镜像中。</li><li>spring-boot:build-info: 根据当前 MavenProject 的内容生成一个 build-info.properties 文件</li><li>spring-boot:help: 显示帮助信息。调用mvn spring-boot:help -Ddetail=true -Dgoal=以显示参数详细信息。</li><li>spring-boot:repackage: 默认的 goal，将普通 mvn package 打包成的 jar 重新打包成包含所有程序依赖项的可执行 jar/war 文件，并保留 mvn package 打包的 jar 为 .original 后缀</li><li>spring-boot:run: 运行 Spring Boot 应用。</li><li>spring-boot:start: 通常用于集成测试方案中，在 mvn integration-test 阶段管理 Spring Boot 应用的生命周期。</li><li>spring-boot:stop: 停止已通过 start 目标启动的应用程序。通常在 integration-test 完成后调用。<br> 文章只对 repackage 进行分析，我们先直接看下 spring-boot-maven-plugin 的源代码结构:</li></ul> 
<h2><a id="springbootmavenpluginprovided_167"></a>spring-boot-maven-plugin：打包时排除provided依赖</h2> 
<p>spring-boot-maven-plugin 插件提供spring boot的maven打包支持。项目中scope为provided的依赖，比如 lombok、mybatis-plus 等，只作用于编译阶段，编译完成就可以功成身退了。在spring maven打包时，provided依赖会排除在包外，但springboot maven打包时，还会将这些依赖打进 war 包的 lib-provided 文件夹里或 jar 包的 lib 文件夹里。</p> 
<p>springboot项目构建jar包或war包的命令为repackage，作用于maven生命周期的package阶段，在 mvn package 执行之后，这个命令再次打包生成可执行的包，例如打jar包时，生成可执行jar包，同时将 mvn package 生成的 jar 重命名为 *.origin。默认情况下，repackage会将工程中引入的任何依赖打到包中。</p> 
<p>以lombok为例，官方提供了以下方式可以将provided依赖从springboot项目包中排除。</p> 
<h4><a id="1_groupIdartifactId_175"></a>1. 通过指定groupId和artifactId排除某个特定的依赖</h4> 
<pre><code>&lt;build&gt;
   &lt;plugins&gt;
       &lt;plugin&gt;
           &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
           &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt;
           &lt;configuration&gt;
               &lt;excludes&gt;
                   &lt;exclude&gt;
                       &lt;groupId&gt;org.projectlombok&lt;/groupId&gt;
                       &lt;artifactId&gt;lombok&lt;/artifactId&gt;
                   &lt;/exclude&gt;
               &lt;/excludes&gt;
           &lt;/configuration&gt;
       &lt;/plugin&gt;
   &lt;/plugins&gt;
&lt;/build&gt;
</code></pre> 
<h4><a id="2_groupIdgroupId_196"></a>2. 指定groupId排除groupId相关的所有依赖</h4> 
<pre><code>&lt;build&gt;
   &lt;plugins&gt;
       &lt;plugin&gt;
           &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
           &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt;
           &lt;configuration&gt;
               &lt;excludeGroupIds&gt;org.projectlombok&lt;/excludeGroupIds&gt;
           &lt;/configuration&gt;
       &lt;/plugin&gt;
   &lt;/plugins&gt;
&lt;/build&gt;
</code></pre> 
<h4><a id="2__212"></a>2. 按照配置文件排除依赖</h4> 
<pre><code>    &lt;profiles&gt;
        &lt;profile&gt;
            &lt;id&gt;dev&lt;/id&gt;
            &lt;activation&gt;
                &lt;property&gt;
                    &lt;name&gt;environment&lt;/name&gt;
                    &lt;value&gt;dev&lt;/value&gt;
                &lt;/property&gt;
            &lt;/activation&gt;
            &lt;build&gt;
                &lt;plugins&gt;
                    &lt;plugin&gt;
                        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
                        &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt;
                        &lt;version&gt;2.7.12&lt;/version&gt;
                        &lt;executions&gt;
                            &lt;execution&gt;
                                &lt;goals&gt;
                                    &lt;goal&gt;repackage&lt;/goal&gt;
                                &lt;/goals&gt;
                            &lt;/execution&gt;
                        &lt;/executions&gt;
                        &lt;configuration&gt;
                            &lt;excludes&gt;
                                &lt;exclude&gt;
                                    &lt;groupId&gt;org.projectlombok&lt;/groupId&gt;
                                    &lt;artifactId&gt;lombok&lt;/artifactId&gt;
                                &lt;/exclude&gt;
                            &lt;/excludes&gt;
                        &lt;/configuration&gt;
                    &lt;/plugin&gt;
                &lt;/plugins&gt;
            &lt;/build&gt;
        &lt;/profile&gt;
        &lt;profile&gt;
            &lt;id&gt;prod&lt;/id&gt;
            &lt;activation&gt;
                &lt;property&gt;
                    &lt;name&gt;environment&lt;/name&gt;
                    &lt;value&gt;prod&lt;/value&gt;
                &lt;/property&gt;
            &lt;/activation&gt;
            &lt;build&gt;
                &lt;plugins&gt;
                    &lt;plugin&gt;
                        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
                        &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt;
                        &lt;version&gt;2.7.12&lt;/version&gt;
                        &lt;executions&gt;
                            &lt;execution&gt;
                                &lt;goals&gt;
                                    &lt;goal&gt;repackage&lt;/goal&gt;
                                &lt;/goals&gt;
                            &lt;/execution&gt;
                        &lt;/executions&gt;
                        &lt;configuration&gt;
                        &lt;/configuration&gt;
                    &lt;/plugin&gt;
                &lt;/plugins&gt;
            &lt;/build&gt;
        &lt;/profile&gt;
    &lt;/profiles&gt;
</code></pre> 
<p><code> mvn clean package -Pdev</code> 使用dev配置文件去除lombok 依赖</p> 
<h3><a id="SpringBoot__jar__279"></a>SpringBoot 工程部署的 jar 包瘦身</h3> 
<p>通过上方分析 fat jar下 有 classes，lib 两个文件夹，我们编译好的代码是放在 classes 里面的，而我们所依赖的 jar 包都是放在 lib 文件夹下</p> 
<p>classes 部分是非常小的（我的是160kb左右），lib部分是非常大的（我的是70M左右），所以上传很慢</p> 
<p><strong>那我们可以将我们自己写的代码部分与所依赖的 maven jar 包部分拆开上传，每次只需要上传我们自己写的代码部分即可</strong></p> 
<h4><a id="_287"></a>正常打包</h4> 
<p>首先，我们项目的 pom.xml 文件中的打包方式如下：</p> 
<pre><code> 		&lt;plugin&gt;
                &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
                &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt;
                &lt;executions&gt;
                    &lt;execution&gt;
                        &lt;goals&gt;
                            &lt;goal&gt;repackage&lt;/goal&gt;
                        &lt;/goals&gt;
                    &lt;/execution&gt;
                &lt;/executions&gt;
            &lt;/plugin&gt;
</code></pre> 
<p>这是 SpringBoot 中默认的打包方式，我们先按照这种方式打包出来，得到一个 jar 包，我们将 jar 包解压，如果不能直接解压，则将后缀改为 zip 再进行解压，我们只需要拿到 <code>BOOT-INF</code> 中的 lib 目录即可</p> 
<h4><a id="_307"></a>改变打包方式</h4> 
<p>我们对 SpringBoot 中默认的打包方式做一些配置</p> 
<pre><code>&lt;build&gt;
    &lt;plugins&gt;
        &lt;plugin&gt;
            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
            &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt;
            &lt;configuration&gt;
                &lt;mainClass&gt;com.Application&lt;/mainClass&gt;
                &lt;layout&gt;ZIP&lt;/layout&gt;
                &lt;includes&gt;
                    &lt;include&gt;
                        &lt;groupId&gt;nothing&lt;/groupId&gt;
                        &lt;artifactId&gt;nothing&lt;/artifactId&gt;
                    &lt;/include&gt;
                &lt;/includes&gt;
            &lt;/configuration&gt;
            &lt;executions&gt;
                &lt;execution&gt;
                    &lt;goals&gt;
                        &lt;goal&gt;repackage&lt;/goal&gt;
                    &lt;/goals&gt;
                &lt;/execution&gt;
            &lt;/executions&gt;
        &lt;/plugin&gt;
    &lt;/plugins&gt;
&lt;/build&gt;
</code></pre> 
<ul><li><code>mainClass</code>，我们指定了项目的启动类</li><li><code>layout</code>，我们指定了打包方式为 ZIP，注意：一定是大写的</li><li><code>includes</code>，有自己的依赖 jar，可以在此导入</li><li><code>repackage</code>，剔除其它的依赖，只需要保留最简单的结构</li></ul> 
<h4><a id="_344"></a>再次打包</h4> 
<p>我们再次点击<code> maven package</code>，得到一个 jar 包，可以看到此时的 jar 包只有167kb了(原先70M+)</p> 
<p><img src="https://images2.imgbox.com/9e/87/71sQM8YD_o.png" alt="在这里插入图片描述"></p> 
<h4><a id="_350"></a>上传启动</h4> 
<p>我们将 lib 目录，以及最后打包的瘦身项目 jar 包，上传至服务器同一目录</p> 
<p>使用命令</p> 
<pre><code>nohup java -Dloader.path=./lib -jar ./sbm-0.0.1-SNAPSHOT.jar &amp;
</code></pre> 
<ul><li><code>-Dloader.path</code>，告诉它所依赖的 maven jar 包位置</li><li><code>admin4j-example-1.0.jar</code>，项目 jar 包的名字</li><li><code>nohup、&amp;</code>，使得 jar 包在服务后台运行</li></ul> 
<h4><a id="_364"></a>总结</h4> 
<p>使用瘦身部署，方便每次的迭代更新，不用每次都上传一个很大的 jar 包，从而节省部署时间。但是每次依赖jar包版本或者有新增了，需要更改下lib目录数据</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/c51b60d78ead737240c8407acdf54b30/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">阿里云免费ssl证书申请与部署</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/8e02df2dda7feac82e35db79ad2f2b48/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">二进制安装1.26版本k8s(docker)</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>