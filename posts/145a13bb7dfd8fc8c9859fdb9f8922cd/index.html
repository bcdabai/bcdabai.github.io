<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>JAVA设计模式详解 - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="JAVA设计模式详解" />
<meta property="og:description" content="Java设计模式
目录
设计模式 3
1.1 创建型模式 4
1.1.1 工厂方法 4
1.1.2 抽象工厂 6
1.1.3 建造者模式 10
1.1.4 单态模式 13
1.1.5 原型模式 15
1.2 结构型模式 17
1.2.1 适配器模式 17
1.2.2 桥接模式 19
1.2.3 组合模式 23
1.2.4 装饰模式 26
1.2.5 外观模式 29
1.2.6 享元模式 32
1.2.7 代理模式 34
1.3 行为型模式 37
1.3.1 责任链模式 37
1.3.2 命令模式 40
1.3.3 解释器模式 43
1.3.4 迭代器模式 45
1.3.5 中介者模式 49
1.3.6 备忘录模式 52
1.3.7 观察者模式 54" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/145a13bb7dfd8fc8c9859fdb9f8922cd/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-04-27T08:25:44+08:00" />
<meta property="article:modified_time" content="2022-04-27T08:25:44+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">JAVA设计模式详解</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p>Java设计模式</p> 
<p>目录</p> 
<ol><li> <p>设计模式 3<br> 1.1 创建型模式 4<br> 1.1.1 工厂方法 4<br> 1.1.2 抽象工厂 6<br> 1.1.3 建造者模式 10<br> 1.1.4 单态模式 13<br> 1.1.5 原型模式 15<br> 1.2 结构型模式 17<br> 1.2.1 适配器模式 17<br> 1.2.2 桥接模式 19<br> 1.2.3 组合模式 23<br> 1.2.4 装饰模式 26<br> 1.2.5 外观模式 29<br> 1.2.6 享元模式 32<br> 1.2.7 代理模式 34<br> 1.3 行为型模式 37<br> 1.3.1 责任链模式 37<br> 1.3.2 命令模式 40<br> 1.3.3 解释器模式 43<br> 1.3.4 迭代器模式 45<br> 1.3.5 中介者模式 49<br> 1.3.6 备忘录模式 52<br> 1.3.7 观察者模式 54<br> 1.3.8 状态模式 58<br> 1.3.9 策略模式 61<br> 1.3.10 模板方法 63<br> 1.3.11 访问者模式 65</p> </li><li> <p>设计模式(超级详细)<br> （1）设计模式是一套被反复使用、多数人知晓的、经过分类编目的、代码设计经验的总结。使用设计模式是为了可重用代码、让代码更容易被他人理解、保证代码可靠性。<br> 代码规范<br> （1）首先是要注意注释文档的格式，注释文档将用来生成HTML格式的代码报告，所以注释文档必须书写在类、域、构造函数、方法、定义之前。<br> （2）注释文档由两部分组成——描述、块标记。描述部分用来书写类的作用或者相关信息，块标记部分必<br> （3）注释的种类：文件头注释、构造函数注释、域注释、方法注释和定义注释。文件头注释需要注明该文件的创建时间、文件名、命名空间信息。构造函数注释采用描述部分注明构造函数的作用。方法注释采用描述部分注明方法的功能，块标记注明方法的参数、返回值、异常等信息。<br> 面向对象：<br> 面向对象OO = 面向对象的分析OOA + 面向对象的设计OOD + 面向对象的编程OOP<br> 接口：<br> 接口好比一种模板，这种模板定义了对象必须实现的方法，其目的就是让这些方法可以作为接口实例被引用。接口不能被实例化。类可以实现多个接口并且通过这些实现的接口被索引。接口变量只能索引实现该接口的类的实例。<br> 接口和抽象的区别：<br> （1）abstract class 在Java语音中表示的是一种继承关系，一个类只能使用一次继承关系。但是一个类却可以实现多个interface.<br> （2）在abstract class 中可以有自己的数据成员，也可以有非abstract的成员方法，而在interface中，只能够有静态的不能被修改的数据成员（也就是必须是static final的，不过在interface中一般不定义数据成员），所有的成员方法都是abstract的。<br> （3）Abstract class和interface所反映出的设计理念不同。其实abstract classs表示的是"is—a"关系，interface表示的是“like—a”关系。<br> （4）实现抽象类和接口的类必须实现其中的所有方法。抽象类中可以有非抽象方法。接口中则不能有实现方法。<br> （5）接口中定义的变量默认是public static final型，且必须给其初值，所以实现类中不能重新定义，也不能改变其值。<br> （6）抽象类中的变量默认是friendly型，其值可以再子类中重新定义，也可以重新赋值。<br> （7）接口中的方法默认都是public,abstract类型的。<br> 接口和委托的区别：<br> 接口可以包含属性、索引、方法以及事件。但委托不能包含事件。<br> 软件设计原则：<br> 1.1 创建型模式<br> AbstractFactory ( 抽象工厂 )<br> FactoryMethod ( 工厂方法 )<br> Singleton ( 单态模式 )<br> Builder ( 建造者模式 )<br> Protot*pe * 原型模式 )<br> 1.1.1 工厂方法</p> <p>定义一个用于创建对象的接口，让子类决定实例化哪一个类。FactoryMethod使一个类的实例化延迟到其子类。<br> 适用性</p> <p>1.当一个类不知道它所必须创建的对象的类的时候。</p> <p>2.当一个类希望由它的子类来指定它所创建的对象的时候。</p> <p>3.当想将创建对象的职责委托给多个帮助子类中的某一个，并且希望将哪一个帮助子类是代理者这一信息局部化的时候。</p> </li></ol> 
<p>参与者</p> 
<pre><code>1.Product
  定义工厂方法所创建的对象的接口。

2.ConcreteProduct
  实现Product接口。

3.Creator
  声明工厂方法，该方法返回一个Product类型的对象*
  Creator也可以定义一个工厂方法的缺省实现，它返回一个缺省的ConcreteProduct对象。
  可以调用工厂方法以创建一个Product对象。

4.ConcreteCreator
  重定义工厂方法以返回一个ConcreteProduct实例。
</code></pre> 
<p>类图</p> 
<p>例子<br> product</p> 
<p>public interface Work {<!-- --></p> 
<pre><code>void doWork();
</code></pre> 
<p>}<br> ConcreteProduct</p> 
<p>public class StudentWork implements Work {<!-- --></p> 
<pre><code>public void doWork() {
    System.out.println("学生做作业!");
}
</code></pre> 
<p>}</p> 
<p>public class TeacherWork implements Work {<!-- --></p> 
<pre><code>public void doWork() {
    System.out.println("老师审批作业!");
}
</code></pre> 
<p>}<br> Creator</p> 
<p>public interface IWorkFactory {<!-- --></p> 
<pre><code>Work getWork();
</code></pre> 
<p>}<br> ConcreteCreator</p> 
<p>public class StudentWorkFactory implements IWorkFactory {<!-- --></p> 
<pre><code>public Work getWork() {
    return new StudentWork();
}
</code></pre> 
<p>}</p> 
<p>public class TeacherWorkFactory implements IWorkFactory {<!-- --></p> 
<pre><code>public Work getWork() {
    return new TeacherWork();
}
</code></pre> 
<p>}<br> Test</p> 
<p>public class Test {<!-- --></p> 
<pre><code>public static void main(String[] args) {
    IWorkFactory studentWorkFactory = new StudentWorkFactory();
    studentWorkFactory.getWork().doWork();
    
    IWorkFactory teacherWorkFactory = new TeacherWorkFactory();
    teacherWorkFactory.getWork().doWork();
}
</code></pre> 
<p>}<br> result</p> 
<p>学生做作业!<br> 老师审批作业!<br> 1.1.2 抽象工厂</p> 
<pre><code>提供一个创建一系列相关或相互依赖对象的接口，而无需指定它们具体的类。
</code></pre> 
<p>适用性</p> 
<pre><code>1.一个系统要独立于它的产品的创建、组合和表示时。

2.一个系统要由多个产品系列中的一个来配置时。

3.当你要强调一系列相关的产品对象的设计以便进行联合使用时。

4.当你提供一个产品类库，而只想显示它们的接口而不是实现时。
</code></pre> 
<p>参与者</p> 
<pre><code>1.AbstractFactory
  声明一个创建抽象产品对象的操作接口。

2.ConcreteFactory
  实现创建具体产品对象的操作。

3.AbstractProduct
  为一类产品对象声明一个接口。

4.ConcreteProduct
  定义一个将被相应的具体工厂创建的产品*象。
  实现AbstractProduct接口。

5.Client
  仅使用由AbstractFactory和AbstractProduct类声明的接口
</code></pre> 
<p>类图</p> 
<p>例子<br> AbstractFactory</p> 
<p>public interface IAnimalFactory {<!-- --></p> 
<pre><code>ICat createCat();

IDog createDog();
</code></pre> 
<p>}<br> ConcreteFactory</p> 
<p>public class BlackAnimalFactory implements IAnimalFactory {<!-- --></p> 
<pre><code>public ICat createCat() {
    reture new BlackCat();
}

public IDog createDog() {
    return new BlackDog();
}
</code></pre> 
<p>}</p> 
<p>public class WhiteAnimalFactory implements IAnimalFactory {<!-- --></p> 
<pre><code>public ICat createCat() {
    return new WhiteCat();
}

public IDog createDog() {
    return new WhiteDog();
}
</code></pre> 
<p>}<br> AbstractProduct</p> 
<p>public interface ICat {<!-- --></p> 
<pre><code>void eat();
</code></pre> 
<p>}</p> 
<p>public interface IDog {<!-- --></p> 
<pre><code>void eat();
</code></pre> 
<p>}<br> Concreteproduct</p> 
<p>public class BlackCat implements ICat {<!-- --></p> 
<pre><code>public void eat() {
    System.out.println("The black cat is eating!");
}
</code></pre> 
<p>}</p> 
<p>public class WhiteCat implements ICat {<!-- --></p> 
<pre><code>public void eat() {
    System.out.println("The white cat is eating!");
}
</code></pre> 
<p>}</p> 
<p>public class BlackDog implements IDog {<!-- --></p> 
<pre><code>public void eat() {
    System.out.println("The black dog is eating");
}
</code></pre> 
<p>}</p> 
<p>public class WhiteDog implements IDog {<!-- --></p> 
<pre><code>public void eat() {
    System.out.println("The white dog is eating!");
}
</code></pre> 
<p>}<br> Client</p> 
<p>public static void main(String[] args) {<!-- --><br> IAnimalFactory blackAnimalFactory = new BlackAnimalFactory();<br> ICat blackCat = blackAnimalFactory.createCat();<br> blackCat.eat();<br> IDog blackDog = blackAnimalFactory.createDog();<br> blackDog.eat();</p> 
<pre><code>IAnimalFactory whiteAnimalFactory = new WhiteAnimalFactory();
ICat whiteCat = whiteAnimalFactory.createCat();
whiteCat.eat();
IDog whiteDog = whiteAnimalFactory.createDog();
whiteDog.eat();
</code></pre> 
<p>}<br> result</p> 
<p>The black cat is eating!<br> The black dog is eating!<br> The white cat is eating!<br> The white dog is eating!<br> 1.1.3 建造者模式</p> 
<pre><code>将一个复杂对象的构成与它的表示分离，使同样的构建过程可以创建不同的表示。
</code></pre> 
<p>适用性</p> 
<pre><code>1.当创建复杂对象的算法应该独立于该对象的组成部分以及它们的装配方式时。

2.当构造过程必须允许被构造的对象有不同的表示时。
</code></pre> 
<p>参与者</p> 
<pre><code>1.Builder
  为创建一个Product对象的各个部件指定抽象接口。

2.ConcreteBuilder
  实现Builder的接口以构造和装配该产品的各个部件。
  定义并明确它所创建的表示.
  提供一个检索产品的接口。

3.Director
  构造一个使用Builder接口的对象。

4.Product
  表示被构造的复杂对象。ConcreteBuilder创建该产品的内部表示并定义它的装配过程。
  包含定义组成部件的类，包括将这些部件装配成最终产品的接口。
</code></pre> 
<p>类图</p> 
<p>例子<br> Builder</p> 
<p>public interface PersonBuilder {<!-- --></p> 
<pre><code>void buildHead();

void buildBody();

void buildFoot();

Person buildPerson();
</code></pre> 
<p>}<br> ConcreteBuilder</p> 
<p>public class ManBuilder implements PersonBuilder {<!-- --></p> 
<pre><code>Person person;

public ManBuilder() {
    person = new Man();
}

publoc void buildBody() {
    person.setBody("建造男人的身体");
}

public void buildFoot() {
    person.setFoot("建造男人的脚");
}

public void buildHead() {
    person.setHead("建造男人的头");
}

public Person buildPerson() {
    reture person;
}
</code></pre> 
<p>}<br> Director</p> 
<p>public class PersonDirector {<!-- --></p> 
<pre><code>public Person constructPerson(PersonBuilder pb) {
    pb.buildHead();
    pb.buildBody();
    pb.buildFoot();
    return pb.buildPerson();
}
</code></pre> 
<p>}<br> Product</p> 
<p>public class Person {<!-- --></p> 
<pre><code>private String head;

private String body;

private String foot;

public String getHead() {
    return head;
}

public void setHead(String head) {
    this.head = head;
}

public String getBody() {
    return body;
}

public void setBody(String body) {
    this.body = body;
}

public String getFoot() {
    return foot;
}

public void setFoot(String foot) {
    this.foot = foot;
}
</code></pre> 
<p>}</p> 
<p>public class Man extends Person {<!-- --></p> 
<p>}<br> Test</p> 
<p>public class Test{<!-- --></p> 
<pre><code>public static void main(String[] args) {
    PersonDirector pd = new PersonDirector();
    Person person = pd.constructPerson(new ManBuilder());
    System.out.println(person.getBody());
    System.out.println(person.getFoot());
    System.out.println(person.getHead());
}
</code></pre> 
<p>}<br> result</p> 
<p>建造男人的身体<br> 建造男人的脚<br> 建造男人的头<br> 1.1.4 单态模式</p> 
<p>定义：对象只要利用自己的属性完成了自己的任务，那该对象就是承担了责任，除了维持了自身的一致性，该对象无需承担其他任何责。如果该对象还承担着其他责任，而其他对象又依赖于该特定对象所承担的责任，我们就需要得到该特定对象。<br> 适用性</p> 
<pre><code>1.当类只能有一个单例而且客户可以从一个众所周知的访问点访问它时。
</code></pre> 
<p>2.当这个唯一实例应该是通过子类化可扩展的，并且客户应该无需更改代码就能使用一个扩展的实例时。<br> 3. 将类的责任集中到唯一的单体对象中，确保该类只有一个实例，并且为该类提供一个全局访问点，这就是单体模式的目的。</p> 
<p>参与者</p> 
<pre><code>Singleton
  定义一个Instance操作，允许客户访问它的唯一实例。Instance是一个类操作。
  可能负责创建它自己的唯一实例。
</code></pre> 
<p>分类：<br> 1.饿汉式单体类：类被加载的时候将自己初始化，更加安全些。<br> private static XConfigReader instance = new XConfigReader();<br> private void XConfigReader(){}<br> private static XConfigReader getInstance(){<!-- --><br> return instance;<br> }<br> 2.懒汉式单体类：在第一次被引用的时候将自己初始化。提高了效率。<br> private static XConfigReader instance = null;<br> private XConfigReader(){<!-- --><br> SAXReader reader = new SAXReader();<br> InputStream in = Thread.currentThread().getContextClassLoader().getResourceAsStream(“sys-config.xml”);<br> try {<!-- --></p> 
<pre><code>		Document doc = reader.read(in);
		
		//取得jdbcConfig相关配置
		Element driverNameElt = (Element) doc.selectObject("/config/db-info/driver-name");
		Element urlElt = (Element) doc.selectObject("/config/db-info/url");
		Element userNameElt = (Element) doc.selectObject("/config/db-info/user-name");
		Element passwordElt = (Element) doc.selectObject("/config/db-info/password");
		
		//设置jdbcConfig相关配置
		jdbcConfig.setDriverName(driverNameElt.getStringValue());
		jdbcConfig.setUrl(urlElt.getStringValue());
		jdbcConfig.setUserName(userNameElt.getStringValue());
		jdbcConfig.setPassword(passwordElt.getStringValue());
		System.out.println("读取jdbcConfig--------------------》》"+jdbcConfig);
	} catch (DocumentException e) {
		e.printStackTrace();
	}
}
public static synchronized XConfigReader getInstance(){
	if(instance == null){
		instance = new XConfigReader();
	}{
	return instance;
}
</code></pre> 
<p>}<br> 3.多例模式：除了可以提供多个实例，其他和单体没有区别，包括有上限多例模式和没有上限的多例模式。<br> 类图</p> 
<p>例子<br> Singleton</p> 
<p>public class Singleton {<!-- --></p> 
<pre><code>private static Singleton sing;

private Singleton() {
    
}

public static Singleton getInstance() {
    if (sing == null) {
        sing = new Singleton();
    }
    return sing;
}
</code></pre> 
<p>}<br> Test</p> 
<p>public class Test {<!-- --></p> 
<pre><code>public static void main(String[] args) {
    Singleton sing = Singleton.getInstance();
    Singleton sing2 = Singleton.getInstance();
    
    System.out.println(sing);
    System.out.println(sing2);
}
</code></pre> 
<p>}<br> result</p> 
<p>singleton.Singleton@1c78e57<br> singleton.Singleton@1c78e57<br> 1.1.5 原型模式</p> 
<p>用原型实例指定创建对象的种类，并且通过拷贝这些原型创建新的对象。</p> 
<p>适用性</p> 
<pre><code>1.当一个系统应该独立于它的产品创建、构成和表示时。

2.当要实例化的类是在运行时刻指定时，例如，通过动态装载。

3.为了避免创建一个与产品类层次平行的工厂类层次时。

4.当一个类的实例只能有几个不同状态组合中的一种时。

建立相应数目的原型并克隆它们可能比每次用合适的状态手工实例化该类更方便一些。			
</code></pre> 
<p>参与者</p> 
<pre><code>1. Prototype
   声明一个克隆自身的接口。

2. ConcretePrototype
   实现一个克隆自身的操作。

3. Client
   让一个原型克隆自身从而创建一个新的对象。
</code></pre> 
<p>原型模式优缺点：<br> 优点：1. Prototype模式允许动态增加或减少产品类。由于创建产品类实例的方法是产批类内部具有的，因此增加新产品对整个结构没有影响。<br> 2. Prototype模式提供了简化的创建结构。工厂方法模式常常需要有一个与产品类等级结构相同的等级结构，而Prototype模式就不需要这样。<br> 3. Prototype模式具有给一个应用软件动态加载新功能的能力。由于Prototype的独立性高，可以很容易动态加载新功能而不影响老系统。<br> 4. 产品类不需要非得有任何事先确定的等级结构，因为Prototype模式适用于任何的等级结构。<br> 缺点：每一个类必须配备一个克隆方法，而且这个克隆方法需要对类的功能进行通盘考虑，这对全新的类来说不是很难，但对已有的类进行改造时，不一定是件容易的事。<br> 类图</p> 
<p>例子<br> Prototype</p> 
<p>public class Prototype implements Cloneable {<!-- --></p> 
<pre><code>private String name;

public void setName(String name) {
    this.name = name;
}

public String getName() {
    return this.name;
}

public Object clone(){
    try {
        return super.clone();
    } catch (Exception e) {
        e.printStackTrace();
        return null;
    }
}
</code></pre> 
<p>}<br> ConcretePrototype</p> 
<p>public class ConcretePrototype extends Prototype {<!-- --></p> 
<pre><code>public ConcretePrototype(String name) {
    setName(name);
}
</code></pre> 
<p>}<br> Client</p> 
<p>public class Test {<!-- --></p> 
<pre><code>public static void main(String[] args) {
    Prototype pro = new ConcretePrototype("prototype");
    Prototype pro2 = (Prototype)pro.clone();
    System.out.println(pro.getName());
    System.out.println(pro2.getName());
}
</code></pre> 
<p>}<br> result</p> 
<p>prototype<br> prototype</p> 
<p>1.2 结构型模式<br> Adapter * 适配器模式 *<br> Bridge ( 桥接模* )<br> Composite ( 组合模式 )<br> Decorator ( 装*模式 )<br> Facade ( 外观模式 )<br> Flyweight ( 享元模式 )<br> Proxy ( 代理模式 )<br> 1.2.1 适配器模式</p> 
<p>将一个类的接口转换成客户希望的另外一个接口。Adapter模式使得原本由于接口不兼容而不能一起工作的那些类可以一起工作。<br> 举例：上次有个朋友从美国给我带回一个微波炉，但因为美国的生活用电电压是110v,而中国的电压是220v,所以我不能使用，幸好朋友有先见之明，给我带回一个变压器，能把220v电压转换为110v电压，我才可以放心使用。这回懂得什么是适配器模式了吧。<br> 适用性<br> 1.你想使一个已经存在的类，而它的接口不符合你的需求。</p> 
<pre><code>2.你想创建一个可以复用的类，该类可以与其他不相关的类或不可预见的类（即那个接口可能不一定兼容的类）协同工作。（仅适用于对象Adapter）你想使用一些已经存在的子类，但是不可能对每一个都进行
3.子类化以匹配它们的接口。对象适配器可以适配它的父类接口。
4. 设计模式里的适配器模式和日常生活中的适配器的作用是完全一样的。
</code></pre> 
<p>参与者</p> 
<pre><code>1.Target（目标）
  定义Client使用的与特定领域相关的接口。
2.Client（客户）
  与符合Target接口的对象协同
3.Adaptee(被适配者)
  定义一个已经存在的接口，这个接口需要适配。

4.Adapter（适配器）
  对Adaptee的接口与Target接口进行适配
</code></pre> 
<p>类图：</p> 
<p>适配器的分类：类适配器和对象适配器<br> （1）类适配器是通过继承类适配者类实现的，另外类适配器实现客户类所需要的接口。<br> （2）对象适配器包含一个适配者的引用，与类适配器相同，对象适配器也实现了客户类需要的接口。<br> 例子<br> Target</p> 
<p>public interface Target {<!-- --></p> 
<pre><code>void adapteeMethod();

void adapterMethod();
</code></pre> 
<p>}<br> Adaptee</p> 
<p>public class Adaptee {<!-- --></p> 
<pre><code>public void adapteeMethod() {
    Syste.out.ptintln("Adaptee method!");
}
</code></pre> 
<p>}<br> Adapter<br> 对象适配器：<br> public class Adapter implements Target {<!-- --></p> 
<p>//引入被适配者<br> private Adaptee adaptee;</p> 
<pre><code>public Adapter(Adaptee adaptee) {
    this.adaptee = adaptee;
}

//实现目标接口
    public void adapteeMethod() {
	adaptee.adapteeMethod();
}

public void adapterMethod() {
	System.out.println("Adapter method!");
}
</code></pre> 
<h3><a id="_661"></a>}</h3> 
<p>类适配器：<br> Public class Adapter extends Adapteee implements Target {<!-- --><br> //实现目标接口<br> public void adapteeMethod() {<!-- --><br> adaptee.adapteeMethod();<br> }</p> 
<pre><code>public void adapterMethod() {
	System.out.println("Adapter method!");
}
</code></pre> 
<p>}</p> 
<p>Client</p> 
<p>public class Test {<!-- --></p> 
<pre><code>public static void main(String[] args) {
    Target target = new Adapter(new Adaptee());
    target.adapteeMethod();
    
    target.adapterMethod();
}
</code></pre> 
<p>}<br> result</p> 
<p>Adaptee method!<br> Adapter method!<br> 1.2.2 桥接模式</p> 
<pre><code>将抽象部分与它实现部分分离，使它们都可以独立地变化。
</code></pre> 
<p>适用性</p> 
<pre><code>1.你不希望在抽象和它的实现部分之间有一个固定的绑定关系。
  例如这种情况可能是因为，在程序运行时刻实现部分应可以选择或者切换。

2.类的抽象以及它的实现都应该可以通过生成子类的方法加以扩充。
  这时Bridge模式使你可以对不同的抽象接口和实现部分进行组合，并分别对它们进行扩充。

3.对一个抽象的实现部分的修改应对客户不产生影响，即客户的代码不必重新编译。

4.正如在意图一节的第一个类图中所示的那样，有许多类要生成。
  这是一种类层次结构说明你必须将一个对象分解成两个部分。
</code></pre> 
<p>5.若想在多个对象间共享实现（可能使用引用计数），但同时要求客户并不知道这一点。<br> 6.如果一个系统需要在构件的抽象化角色和具体化角色之间增加更多的灵活性，避免在两个层次建立静态的联系。<br> 7.设计要求实现化角色的任何改变不应当影响客户端，或者说实现化角色的改变对客户端完全透明的。<br> 8.一个构件有多于一个的抽象化角色和实现化角色，系统需要他们之间进行动态耦合。<br> 优点</p> 
<ol><li> <p>分离接口及其实现部分，这里实现了Abstration和Implementor的分离，有助于降低对实现部分的依赖性，从而产生更好的结构化系统。<br> 2.提高可扩充行，可以独立的对Abstraction和Implementor层次结构进行扩充。 <br> 参与者</p> <p>1.Abstraction<br> 定义抽象类的接口。<br> 维护一个指向Implementor类型对象的指针。</p> <p>2.RefinedAbstraction<br> 扩充由Abstraction定义的接口。</p> <p>3.Implementor<br> 定义实现类的接口，该接口不一定要与Abstraction的接口完全一致。<br> 事实上这两个接口可以完全不同。<br> 一般来讲，Implementor接口仅提供基本操作，而Abstraction则定义了基于这些基本操作的较高层次的操作。</p> <p>4.ConcreteImplementor<br> 实现Implementor接口并定义它的具体实现。<br> 类图</p> </li></ol> 
<p>例子<br> Abstraction</p> 
<p>public abstract class Person {<!-- --></p> 
<pre><code>private Clothing clothing;

private String type;

public Clothing getClothing() {
    return clothing;
}

public void setClothing() {
    this.clothing = ClothingFactory.getClothing();
}

public void setType(String type) {
    this.type = type;
}

public String getType() {
    return this.type;
}

public abstract void dress();
</code></pre> 
<p>}<br> RefinedAbstraction</p> 
<p>public class Man extends Person {<!-- --></p> 
<pre><code>public Man() {
    setType("男人");
}

public void dress() {
    Clothing clothing = getClothing();
    clothing.personDressCloth(this);
}
</code></pre> 
<p>}</p> 
<p>public class Lady extends Person {<!-- --></p> 
<pre><code>public Lady() {
    setType("女人");
}

public void dress() {
    Clothing clothing = getClothing();
    clothing.personDressCloth(this);
}
</code></pre> 
<p>}<br> Implementor</p> 
<p>public abstract class Clothing {<!-- --></p> 
<pre><code>public abstract void personDressCloth(Person person);
</code></pre> 
<p>}<br> ConcreteImplementor</p> 
<p>public class jacket extends Clothing {<!-- --></p> 
<pre><code>public void personDressCloth(Person person) {
    System.out.println(person.getType() + "穿马甲");
}
</code></pre> 
<p>}</p> 
<p>public class Trouser extends Clothing {<!-- --></p> 
<pre><code>public void personDressCloth(Person person) {
    System.out.println(Person.getType() + "穿裤子");
}
</code></pre> 
<p>}<br> Test</p> 
<p>public class Test {<!-- --></p> 
<pre><code>public static void main(String[] args) {
    
    Person man = new Man();
    
    Person lady = new Lady();
    
    Clothing jacket = new Jacket();
    
    Clothing trouser = new Trouser();
    
    jacket.personDressCloth(man);
    trouser.personDressCloth(man);

    jacket.personDressCloth(lady);
    trouser.personDressCloth(lady);
}
</code></pre> 
<p>}<br> result</p> 
<p>男人穿马甲<br> 男人穿裤子<br> 女人穿马甲<br> 女人穿裤子<br> 1.2.3 组合模式</p> 
<p>将对象组合成树形结构以表示"部分-整体"的层次结构。“Composite使得用户对单个对象和组合对象的使用具有一致性。”</p> 
<p>适用性</p> 
<pre><code>1.你想表示对象的部分-整体层次结构。

2.你希望用户忽略组合对象与单个对象的不同，用户将统一地使用组合结构中的所有对象。
</code></pre> 
<p>参与者</p> 
<pre><code>1.Component
  为组合中的对象声明接口。
  在适当的情况下，实现所有类共有接口的缺省行为。
  声明一个接口用于访问和管理Component的子组件。
  (可选)在递归结构中定义一个接口，用于访问一个父部件，并在合*的情况下实现它。

2.Leaf
  在组合中表示叶节点对象，叶节点没有子节点。
  在组合中定义节点对象的行为。

3.Composite
  定义有子部件的那些部件的行为。
  存储子部件。
  在Component接口中实现与子部件有*的操作。

4.Client
  通过Component接口操纵组合部件的对象。
</code></pre> 
<ol start="5"><li>Disk<br> Disk是组合体的一个对象，或称一个部件，这个部件是个单独元素<br> 类图</li></ol> 
<p>例子<br> Component</p> 
<p>public abstract class Employer {<!-- --></p> 
<pre><code>private String name;

public void setName(String name) {
    this.name = name;
}

public String getName() {
    return this.name;
}

public abstract void add(Employer employer);

public abstract void delete(Employer employer);

public List employers;

public void printInfo() {
    System.out.println(name);
}

public List getEmployers() {
    return this.employers;
}
</code></pre> 
<p>}<br> Leaf</p> 
<p>public class Programmer extends Employer {<!-- --></p> 
<pre><code>public Programmer(String name) {
    setName(name);
    employers = null;//程序员, 表示没有下属了
}

public vid add(Employer employer) {
    
}

public void delete(Employer employer) {
    
}
</code></pre> 
<p>}</p> 
<p>public class ProjectAssistant extends Employer {<!-- --></p> 
<pre><code>public ProjectAssistant(String name) {
    setName(name);
    employers = null;//项目助理, 表示没有下属了
}

public void add(Employer employer) {
    
}

public void delete(Employer employer) {
    
}
</code></pre> 
<p>}<br> Composite</p> 
<p>public class ProjectManager extends Employer {<!-- --></p> 
<pre><code>public ProjectManager(String name) {
    setName(name);
    employers = new ArrayList();
}

public void add(Employer employer) {
    employers.add(employer);
}

public void delete(Employer employer) {
    employers.remove(employer);
}
</code></pre> 
<p>}<br> Client</p> 
<p>public class Test {<!-- --></p> 
<pre><code>public static void main(String[] args) {
    Employer pm = new ProjectManager("项目经理");
    Employer pa = new ProjectAssistant("项目助理");
    Employer programmer1 = new Programmer("程序员一");
    Employer programmer2 = new Programmer("程序员二");
    
    pm.add(pa);//为项目经理添加项目助理
    pm.add(programmer2);//*项目经理*加程序员
    
    List ems = pm.getEmployers();
    for (Employer em : ems) {
        System.out.println(em.getName());
    }
}
</code></pre> 
<p>}<br> result</p> 
<p>项目助理<br> 程序员二<br> 1.2.4 装饰模式</p> 
<pre><code>动态地给一个对象添加一些额外的职责。就增加功能来说，Decorator模式相比生成子类更为灵活。
</code></pre> 
<p>适用性</p> 
<pre><code>1.在不影响其他对象的情况下，以动态、透明的方式给单个对象添加职责。

2.处理那些可以撤消的职责。

3.当不能采用生成子类的方法进行扩充时。
</code></pre> 
<p>参与者</p> 
<pre><code>1.Component
  定义一个对象接口，可以给这些对象动态地添加职责。

2.ConcreteComponent
  定义一个对象，可以给这个对象添加一些职责。

3.Decorator
  维持一个指向Component对象的指针，并定义一个与Component接口一致的接口。

4.ConcreteDecorator
  向组件添加职责。
</code></pre> 
<p>类图</p> 
<p>例子<br> Component</p> 
<p>public interface Person {<!-- --></p> 
<pre><code>void eat();
</code></pre> 
<p>}<br> ConcreteComponent</p> 
<p>public class Man implements Person {<!-- --></p> 
<pre><code>public void eat() {
	System.out.println("男人在吃");
}
</code></pre> 
<p>}<br> Decorator</p> 
<p>public abstract class Decorator implements Person {<!-- --></p> 
<pre><code>protected Person person;

public void setPerson(Person person) {
    this.person = person;
}

public void eat() {
    person.eat();
}
</code></pre> 
<p>}<br> ConcreteDectrator</p> 
<p>public class ManDecoratorA extends Decorator {<!-- --></p> 
<pre><code>public void eat() {
    super.eat();
    reEat();
    System.out.println("ManDecoratorA类");
}

public void reEat() {
    System.out.println("再吃一顿饭");
}
</code></pre> 
<p>}</p> 
<p>public class ManDecoratorB extends Decorator {<!-- --></p> 
<pre><code>public void eat() {
    super.eat();
    System.out.println("===============");
    System.out.println("ManDecoratorB类");
}
</code></pre> 
<p>}<br> Test</p> 
<p>public class Test {<!-- --></p> 
<pre><code>public static void main(String[] args) {
    Man man = new Man();
    ManDecoratorA md1 = new ManDecoratorA();
    ManDecoratorB md2 = new ManDecoratorB();
    
    md1.setPerson(man);
    md2.setPerson(md1);
    md2.eat();
}
</code></pre> 
<p>}<br> result</p> 
<h2><a id="%0A%0AManDecoratorA_1061"></a>男人在吃<br> 再吃一顿饭<br> ManDecoratorA类</h2> 
<p>ManDecoratorB类<br> 1.2.5 外观模式<br> 外观模式定义了一个将子系统的一组接口集成在一起的高层接口，以提供一个一致的界面。通过这个界面，其他系统可以方便的调用子系统中的功能，而忽略子系统内部发生的变化。<br> 适用性</p> 
<pre><code>1.当你要为一个复杂子系统提供一个简单接口时。子系统往往因为不断演化而变得越来越复杂。大多数模式使用时都会产生更多更小的类。这使得子系统更具可重用性，也更容易对子系统进行定制，但这也给那些不需要定制子系统的用户带来一些使用上的困难。Facade可以提供一个简单的缺省视图，这一视图对大多数用户来说已经足够，而那些需要更多的可定制性的用户可以越过facade层。

2.客户程序与抽象类的实现部分之间存在着很大的依赖性。引入facade将这个子系统与客户以及其他的子系统分离，可以提高子系统的独立性和可移植性。

3.当你需要构建一个层次结构的子系统时，使用facade模式定义子系统中每层的入口点。如果子系统之间是相互依赖的，你可以让它们仅通过facade进行通讯，从而简化了它们之间的依赖关系。
</code></pre> 
<p>参与者</p> 
<pre><code>1.Facade
  知道哪些子系统类负责处理请求。
  将客户的请求代理给适当的子系统对象。

2.Subsystemclasses
  实现子系统的功能。
  处理由Facade对象指派的任务。
  没有facade的任何相关信息；即没有指向facade的指针。
</code></pre> 
<p>类图</p> 
<p>注意事项：<br> （1）在设计外观时，不需要增加额外的功能。<br> （2）不要从外观方法中返回子系统中的组件给客户。<br> （3）应用外观的目的是提供一个高层次的接口，而不是进行底层次的单独的业务执行。<br> 例子<br> Facade</p> 
<p>public class Facade {<!-- --></p> 
<pre><code>ServiceA sa;

ServiceB sb;

ServiceC sc;

public Facade() {
    sa = new ServiceAImpl();
    sb = new ServiceBImpl();
    sc = new ServiceCImpl(); 
}

public void methodA() {
    sa.methodA();
    sb.methodB();
}

public void methodB() {
    sa.methodB();
    sc.methodC();
}

public void methodC() {
    sc.methodC();
    sa.methodA();
}
</code></pre> 
<p>}<br> Subsystemclasses</p> 
<p>public class ServiceAImpl implements ServiceA {<!-- --></p> 
<pre><code>public void methodA() {
    System.out.println("这是服务A");
}
</code></pre> 
<p>}</p> 
<p>public class ServiceBImpl implements ServiceB {<!-- --></p> 
<pre><code>public void methodB() {
    System.out.println("这是服务B");
</code></pre> 
<p>}</p> 
<p>public class ServiceCImpl implements ServiceC {<!-- --></p> 
<pre><code>public void methodC() {
    System.out.println("这是服务C");
}
</code></pre> 
<p>}<br> Test</p> 
<p>public class Test {<!-- --></p> 
<pre><code>public static void main(String[] args) {
	ServiceA sa = new ServiceAImpl();
	ServiceB sb = new ServiceBImpl();
    
    sa.methodA();
    sb.methodB();
    
    System.out.println("========");
    //facade
    Facade facade = new Facade();
    facade.methodA();
    facade.methodB();
}
</code></pre> 
<p>}<br> result</p> 
<h2><a id="A%0AB_1166"></a>这是服务A<br> 这是服务B</h2> 
<p>这是服务A<br> 这是服务B<br> 这是服务B<br> 这是服务C<br> 1.2.6 享元模式</p> 
<pre><code>定义：运用共享技术有效地支持大量细粒度的对象。
</code></pre> 
<p>适用性</p> 
<pre><code>当都具备下列情况时，使用Flyweight模式：

1.一个应用程序使用了大量的对象。

2.完全由于使用大量的对象，造成很大的存储开销。

3.对象的大多数状态都可变为外部状态。

4.如果删除对象的外部状态，那么可以用相对较少的共享对象取代很多组对象。

5.应用程序不依赖于对象标识。由于Flyweight对象可以被共享，对于概念上明显有别的对象，标识测试将返回真值。
</code></pre> 
<p>参与者</p> 
<pre><code>1.Flyweight
  描述一个接口，通过这个接口flyweight可以接受并作用于外部状态。

2.ConcreteFlyweight
  实现Flyweight接口，并为内部状态（如果有的话）增加存储空间。
  ConcreteFlyweight对象必须是可共享的。它所存储的状态必须是内部的；即，它必须独立于ConcreteFlyweight对象的场景。

3.UnsharedConcreteFlyweight
  并非所有的Flyweight子类都需要被共享。Flyweight接口使共享成为可能，但它并不强制共享。
  在Flyweight对象结构的某些层次，UnsharedConcreteFlyweight对象通常将ConcreteFlyweight对象作为子节点。

4.FlyweightFactory
  创建并管理flyweight对象。
  确保合理地共享flyweight。当用户请求一个flyweight时，FlyweightFactory对象提供一个已创建的实例或者创建一个（如果不存在的话）。
</code></pre> 
<p>优缺点：</p> 
<ol><li>享元模式使得系统更加复杂，为了使对象可以共享，需要将一些状态外部化，这使得程序的逻辑复杂化。</li><li>享元模式将享元对象的状态外部化，而读取外部状态使得运行时间稍微变长。<br> 类</li></ol> 
<p>例子<br> Flyweight</p> 
<p>public interface Flyweight {<!-- --></p> 
<pre><code>void action(int arg);
</code></pre> 
<p>}<br> ConcreteFlyweight</p> 
<p>public class FlyweightImpl implements Flyweight {<!-- --></p> 
<pre><code>public void action(int arg) {
    System.out.println("参数值: " + arg);
}
</code></pre> 
<p>}<br> FlyweightFactory</p> 
<p>public class FlyweightFactory {<!-- --></p> 
<pre><code>private static Map flyweights = new HashMap();

public FlyweightFactory(String arg) {
    flyweights.put(arg, new FlyweightImpl());
}

public static Flyweight getFlyweight(String key) {
    if (flyweights.get(key) == null) {
        flyweights.put(key, new FlyweightImpl());
    }
    return flyweights.get(key);
}

public static int getSize() {
    return flyweights.size();
}
</code></pre> 
<p>}<br> Test</p> 
<p>public class Test {<!-- --></p> 
<pre><code>public static void main(String[] args) {
    // TODO Auto-generated method stub
    Flyweight fly1 = FlyweightFactory.getFlyweight("a");
    fly1.action(1);
    
    Flyweight fly2 = FlyweightFactory.getFlyweight("a");
    System.out.println(fly1 == fly2);
    
    Flyweight fly3 = FlyweightFactory.getFlyweight("b");
    fly3.action(2);
    
    Flyweight fly4 = FlyweightFactory.getFlyweight("c");
    fly4.action(3);
    
    Flyweight fly5 = FlyweightFactory.getFlyweight("d");
    fly4.action(4);
    
    System.out.println(FlyweightFactory.getSize());
}
</code></pre> 
<p>}<br> result</p> 
<p>参数值: 1<br> true<br> 参数值: 2<br> *数值: 3<br> 参数值: 4<br> 4<br> 1.2.7 代理模式</p> 
<pre><code>定义：为其他对象提供一种代理以控制对这个对象的访问。
</code></pre> 
<p>适用性</p> 
<pre><code>1.远程代理（RemoteProxy）为一个对象在不同的地址空间提供局部代表。

2.虚代理（VirtualProxy）根据需要创建开销很大的对象。

3.保护代理（ProtectionProxy）控制对原始对象的访问。

4.智能指引（SmartReference）取代了简单的指针，它在访问对象时执行一些附加操作。
</code></pre> 
<p>参与者</p> 
<pre><code>1.Proxy
  保存一个引用使得代理可以访问实体。若RealSubject和Subject的接口相同，Proxy会引用Subject。
  提供一个与Subject的接口相同的接口，这样代理就可以用来替代实体。
  控制对实体的存取，并可能负责创建和删除它。
  其他功能依赖于代理的类型：

2.RemoteProxy负责对请求及其参数进行编码，并向不同地址空间中的实体发送已编码的请求。

3.VirtualProxy可以缓存实体的附加信息，以便延迟对它的访问。

4.ProtectionProxy检查调用者是否具有实现一个请求所必需的访问权限。

5.Subject
  定义RealSubject和Proxy的共用接口，这样就在任何使用RealSubject的地方都可以使用Proxy。

6.RealSubject
  定义Proxy所代表的实体。
</code></pre> 
<p>7.使用代理原因：<br> （1）授权机制不同级别的用户对同一对象拥有不同的访问权利（如注册用户和游客）。<br> （2）某个客户端不能直接操作到某个对象，但又必须和那个对象有所互动。<br> （3）当那个对象是个很大的图片时，就可以采用代理代替那张大的图片。<br> （4）如果那个对象在Internet的远程服务端，也可以采用代理模式。<br> 8.搞清“局长”、“秘书”、“局长——秘书的关系”、“你”，他们就是代理的典型应用。</p> 
<p>类图:静态代理模式图</p> 
<p>类图：动态代理模式图</p> 
<p>例子<br> Proxy (静态代理示例)</p> 
<p>public class ProxyObject implements Object {<!-- --></p> 
<pre><code>Object obj;

public ProxyObject() {
    System.out.println("这是代理类");
    obj = new ObjectImpl();
}

public void action() {
    System.out.println("代理开始");
    Obj.action();
    System.out.println("代理结束");
}
</code></pre> 
<p>}<br> Subject</p> 
<p>public interface Object {<!-- --></p> 
<pre><code>void action();
</code></pre> 
<p>}<br> RealSubject</p> 
<p>public class ObjectImpl implements Object {<!-- --></p> 
<pre><code>public void action() {
    System.out.println("========");
    System.out.println("========");
    System.out.prrntln("这是被代理的类");
    System.out.println("========");
    System.out.println("========");
}
</code></pre> 
<p>}<br> Test</p> 
<p>public class Test {<!-- --></p> 
<pre><code>public static void main() {
	Object obj = new ProxyObject();
    obj.action();
}
</code></pre> 
<p>}<br> result</p> 
<h2><a id="%0A_1372"></a>这是代理类<br> 代理开始</h2> 
<h2><a id="%0A_1375"></a>=*======<br> 这是被代理的类</h2> 
<p>======*=<br> 代理结束</p> 
<p>Proxy (动态代理示例)</p> 
<p>public class LogHandler implements InvocationHandler {<!-- --></p> 
<pre><code>private Object targetObject;
public Object newProxyInstance(Object targetObject){
	this.targetObject = targetObject;
	return Proxy.newProxyInstance(targetObject.getClass().getClassLoader(), targetObject.getClass().getInterfaces(), this);
	
}
public Object invoke(Object proxy, Method method, Object[] args)
		throws Throwable {
	System.out.println("start----&gt;&gt;&gt;&gt;"+method.getName());
	for(int i=0;i&lt;args.length;i++){
		System.out.println(args[i]);
	}
	Object ret = null;
	try{
		//调用目标方法
	  ret = method.invoke(targetObject, args);
	  System.out.println("success----&gt;&gt;&gt;&gt;"+method.getName());
	}catch(Exception e){
		e.printStackTrace();
		  System.out.println("error----&gt;&gt;&gt;&gt;"+method.getName());
	}
	return ret;
}
</code></pre> 
<p>}</p> 
<p>Subject</p> 
<p>public interface UserManager {<!-- --></p> 
<pre><code>public void addUser(String id, String name);

public void delUser(String id);

public String findUser(String id);
</code></pre> 
<p>}</p> 
<p>RealSubject</p> 
<p>public class UserManagerImple implements UserManager {<!-- --></p> 
<pre><code>public void addUser(String id, String name) {
System.out.println("这是被代理的添加程序！");
}

public void delUser(String id){
	System.out.println("这是被代理的删除程序");
}

public String findUser(String id){
	System.out.println("这是被代理的有返回值的程序");
	return "张三";
}
</code></pre> 
<p>}<br> Test</p> 
<p>public class Client {<!-- --><br> public static void main(String[] args) {<!-- --><br> LogHandler logHandler = new LogHandler();<br> UserManager userManager = (UserManager) logHandler.newProxyInstance(new UserManagerImple());</p> 
<pre><code>    String name = userManager.findUser("0003");
    System.out.println("========="+name);
}
</code></pre> 
<p>}</p> 
<p>result</p> 
<p>start----&gt;&gt;&gt;&gt;findUser<br> 0003<br> 这是被代理的有返回值的程序<br> success----&gt;&gt;&gt;&gt;findUser<br> =========张三<br> 1.3 行为型模式<br> Chain of Responsibility ( 责任链模式 )<br> Command ( 命令模式 )<br> Interpreter ( 解释器模式 )<br> Iterator ( 迭代器<em>式 )<br> Mediator ( 中介者模式 )<br> Memento ( 备忘录模式 )<br> Observer ( 观察者模式 )<br> State ( 状</em>模式 )<br> Strategy ( 策略模式 )<br> TemplateMethod ( 模板方法 )<br> Vis*tor ( 访问者模式 )<br> 1.3.1 责任链模式</p> 
<pre><code>使多个对象都有机会处理请求，从而避免请求的发送者和接收者之间的耦合关系。将这些对象连成一*链，
并*着这条链传递该请求，直到有一个对象处理它为止。

这一模式的想法是，给多个对象处理一个请求的机会，从而解耦发送者和接受者.
</code></pre> 
<p>适用性</p> 
<pre><code>1.有多个的对象可以处理一个请求，哪个对象处理该请求运行时刻自动确定。

2.你*在不明确指定接收者的情况下，向多个对象中的一个提交一个请求。

3.可处理一个请求的对象集合应被动态指定。
</code></pre> 
<p>参与者</p> 
<pre><code>1.Handler
  定义一个处理请求的接口。
  （可选）实现后继链。

2.ConcreteHandler
  处理它所负责的请*。
  可访问它的后继者。
  如果可处理该*求，就处理*；否则将该请求转发给它的后继者。

3.Client
  向链上的具体处理者(ConcreteHandler)对象提交请求。
</code></pre> 
<p>类图</p> 
<p>例子<br> Hand*er</p> 
<p>public interface RequestHandle {<!-- --></p> 
<pre><code>void handleRequest(R*quest request);
</code></pre> 
<p>}<br> ConcreteHandler</p> 
<p>public class HRRequestHandle implements RequestHandle {<!-- --></p> 
<pre><code>public void handleRequest(Request request) {
    if (request instanceof DimissionRequest) {
        System.out.println("要离职, 人事审批!");
    } 

    System.out.println("请求完*");
}
</code></pre> 
<p>}</p> 
<p>public class PMRequestHandle implements RequestHandle {<!-- --></p> 
<pre><code>Req*estHandle rh;

public PMRequestHandle(RequestHandle *h) {
    this.rh = rh;
}

public void handle*equest(Request request) {
    if (request instanceof AddMoneyRequest) {
        System.out.println("要加薪, 项目经理审批!*);
    } else {
        rh.handleRequest(request);
    }
}
</code></pre> 
<p>}</p> 
<p>public class TLRequestHandle implements RequestHandle {<!-- --></p> 
<pre><code>RequestHandle rh;

public TLRequestHandle(RequestHand*e rh) {
    this.rh = rh;
}

public void handleRequest(Request request) {
    if (request instanceof LeaveRe*uest) {
        System.ou*.println("要请假, 项目组长审批!");
    } else {
        rh.handleRequest(request);
    }
}
</code></pre> 
<p>}<br> Client</p> 
<p>public *lass Test {<!-- --></p> 
<pre><code>public static v*id main(String[] args) {
    RequestHa*dle hr = *ew HRRequ*stHandle();
    Requ*stHandle pm = new P*RequestHandle(hr);
    RequestHandle tl = new TLRequestHandle(pm);
    
    //team leader处理离职请求
    Request request = new DimissionRequest()*
    tl.handleRequest(request);
    
    System.out.println("===========");
    //team leader处理加薪请求
    request = new AddMoneyRequest();
    tl.handleRequ*st(request);
    
    System.out.println("========");
    //项目经理上理辞职请求
    requ*st = ne* Dimissio*Request();
    pm.handleRequest(request);
}
</code></pre> 
<p>}<br> result</p> 
<h2><a id="_%0A%0A%0A__1584"></a>要离职, 人事审批!<br> 请求完毕<br> =====<mark>*</mark>=<br> 要加薪, 项目经理审批!</h2> 
<p>要离职, 人事审批!<br> 请求完毕<br> 1.3.2 命令模式</p> 
<pre><code>将一个请求封装为一个对象，从而使你可用不同的请求对客户进行参数化；对请求排队或记录请求日志，以及支持可撤消的操作。
</code></pre> 
<p>适用性</p> 
<pre><code>1.抽象出待执行的动作以参数化某对象。

2.在不同的时刻指定、排列和执行请求。

3.支持取消操作。

4.支持修改日志，这样当系统崩溃时，这样修改可以被重做一遍。

5.用构建在原语操作上的高层操作构造一个系统。
</code></pre> 
<p>参与者</p> 
<pre><code>1.Command
  声明执行操作的接口。

2.ConcreteCommand
  将一个接收者对象绑定于一个动作。
  调用接收者相应的操作，以实现Execute。

3.Client
  创建一个具体命令对象并设定它的接收者。

4.Invoker
  要求该命令执行这个请求。

5.Receiver
  知道如何实施与执行一个请求相关的操作。任何类都可能作为一个接收者。
6.理解五个角色：球队老板，老板的命令（接口），教练，命令的内容，球员。这五个角色的关系，自然就懂命令模式了。
</code></pre> 
<p>类图</p> 
<p>例子<br> Command</p> 
<p>public abstract class Command {<!-- --></p> 
<pre><code>protected Receiver receiver;

public Command(Receiver receiver) {
    this.receiver = receiver;
}

public abstract void execute();
</code></pre> 
<p>}<br> ConcreteCommand</p> 
<p>public class CommandImpl extends Command {<!-- --></p> 
<pre><code>public CommandImpl(Receiver receiver) {
    super(receiver);
}

public void execute() {
    receiver.request();
}
</code></pre> 
<p>}<br> Invoker</p> 
<p>public class Invoker {<!-- --></p> 
<pre><code>private Command command;

public void setCommand(Command ccmmand) {
    this.command = command;
}

public void execute() {
    command.execute();
}
</code></pre> 
<p>}<br> Receiver</p> 
<p>public class Receiver {<!-- --></p> 
<pre><code>public void receive() {
    System.out.println("This is Receive class!");
}
</code></pre> 
<p>}<br> Test</p> 
<p>public class Test {<!-- --></p> 
<pre><code>public static void main(String[] args) {
    Receiver rec = new Receiver();
    Command cmd = new CommandImpl(rec);
    Invoker i = new Invoker();
    i.setCommand(cmd);
    i.execute();
}
</code></pre> 
<p>}<br> result</p> 
<p>This is Receive class!<br> 1.3.3 解释器模式</p> 
<pre><code>给定一个语言，定义它的文法的一种表示，并定义一个解释器，这个解释器使用该表示来解释语言中的句子。
</code></pre> 
<p>适用性</p> 
<pre><code>当有一个语言需要解释执行,并且你可将该语言中的句子表示为一个抽象语法树时，可使
用解释器模式。而当存在下情况时该模式效果最好：

1.该文法简单对于复杂的文法,文法的*层次变得庞大而无法管理。

2.效率不是一个关键问题最高效的解释器通常不是通过直接解释语法分析树实现的,而是首先将它们转换成另一种形式。
</code></pre> 
<p>参与者</p> 
<pre><code>1.AbstractExpression(抽象表达式)
  声明一个抽象的解释操作，这个接口为抽象语法树中所有的节点所共享。

2.TerminalExpression(终结符表达式)
  实现与文法中的终结符相关联的解释操作。
  一个句子中的每个终结符需要该类的一个实例。

3.NonterminalExpression(非终结符表达式)
  为文法中的非终结符实现解释(Interpret)操作。

4.Context（上下文）
  包含解释器之外的一些全局信息。

5.Client（客户）
  构建(或被给定)表示该文法定义的语言中这个特定的句子的抽象放法树。
  该抽象语法树由NonterminalExpression和TerminalExpression的实例装配而成。
  调用解*操作。
</code></pre> 
<p>类图</p> 
<p>例子<br> AbstractExpression</p> 
<p>pu*lic abstract class Expression {<!-- --></p> 
<pre><code>abstract void interpret(Context ctx);
</code></pre> 
<p>}<br> Expression</p> 
<p>public class AdvanceExpression extends Expression {<!-- --></p> 
<pre><code>void interpret(Context ctx) {
    System.out.println("这是高级解析器!");
}
</code></pre> 
<p>}</p> 
<p>public class SimpleExpression extends Expression {<!-- --></p> 
<pre><code>void interpret(Context ctx) {
    System.out.println("这是普通解析器!");
}
</code></pre> 
<p>}<br> Context</p> 
<p>public class Context {<!-- --></p> 
<pre><code>private String content;

private List list = new ArrayList();

public void setContent(String content) {
    this.content = content;
}

public String getContent() {
    return this.content;
}

public void add(Expression eps) {
    list.add(eps);
}

public List getList() {
    return list;
}
</code></pre> 
<p>}<br> Test</p> 
<p>public class Test {<!-- --></p> 
<pre><code>public static void main(String[] args) {
    Context ctx = new Context();
    ctx.add(new SimpleExpression());
    ctx.add(new AdvanceExpression());
    ctx.add(new SimpleExpression());
    
    for (Expression eps : ctx.getList()) {
        Eps.interpret(ctx);
    }
}
</code></pre> 
<p>}<br> result</p> 
<p>这是普通解析器!<br> 这是高级解析器!<br> 这是普通解析器!<br> 1.3.4 迭代器模式</p> 
<pre><code>给定一个语言，定义它的文法的一种表示，并定义一个解释器，这个解释器使用该表示来解释语言中的句子。
</code></pre> 
<p>适用性</p> 
<pre><code>1.访问一个聚合对象的内容而无需暴露它的内部表示。

2.支持对聚合对象的多种遍历。

3.为遍历不同的聚合结构提供一的统一的接口(即,支持多态迭代)。
</code></pre> 
<p>参与者</p> 
<pre><code>1.Iterator
  迭代器定义访问和遍历元素的接口。

2.ConcreteIterator
  具有迭代器实现迭代器接口。
  对该聚合遍历时跟踪当前位置。

3.Aggregate
  聚合定义创建相应迭代器对象的接口。

4.ConcreteAggregate
  具体聚合实现创建相应迭代器的接口，该操作返回ConcreteIterator的一个适当的实例.
</code></pre> 
<p>类图</p> 
<p>例子<br> Iterator</p> 
<p>public interface Iterator {<!-- --></p> 
<pre><code>Object next();

void first();

void last();

boolean hasNext();
</code></pre> 
<p>}<br> ConcreteIterator</p> 
<p>public class IteratorImpl implements Iterator {<!-- --></p> 
<pre><code>private List list;

private int index;

public IteratorImpl(List list) {
    index = 0;
    this.list = list;
}

public void first() {
    index = 0;
}

public void last() {
    index = list.getSize();
}

public Object next() {
    Object obj = list.get(index);
    index++;
    return obj;
}

public boolean hasNext() {
    return index &lt; list.getSize();
}
</code></pre> 
<p>}<br> Aggregate</p> 
<p>public interface List {<!-- --></p> 
<pre><code>Iterator iterator();

Object get(int index);

int getSize();

void add(Object obj);
</code></pre> 
<p>}<br> ConcreteAggregate</p> 
<p>public class ListImpl implements List {<!-- --></p> 
<pre><code>private Object[] list;

private int index;

private int size;

public ListImpl() {
    index = 0;
    size = 0;
    list = new Object[100];
}

public Iterator iterator() {
    return new IteratorImpl(this);
}

public Object get(int index) {
    return list[index];
}

public int getSize() {
    return this.size;
}

public void add(Object obj) {
    list[index++] = obj;
    size++;
}
</code></pre> 
<p>}<br> Test</p> 
<p>public class Test {<!-- --></p> 
<pre><code>public static void main(String[] args) {
    List list = new ListImpl();
    list.add("a");
    list.add("b");
    list.add("c");
    //第一种迭代方式
    Iterator it = list.iterator();
    while (it.hasNext()) {
        System.out.println(it.next());
    }
    
    System.out.println("=====");
    //第二种迭代方式
    for (int i = 0; i &lt; list.getSize(); i++) {
        System.out.println(list.get(i));
    }
}
</code></pre> 
<p>}<br> result</p> 
<h2><a id="a%0Ab%0Ac_1927"></a>a<br> b<br> c</h2> 
<p>a<br> b<br> c<br> 1.3.5 中介者模式</p> 
<pre><code>用一个中介对象来封装一系列的对象交互。中介者使各对象不需要显式地相互引用，从而使其耦合松散，而且可以独立地改变它们之间的交互。
</code></pre> 
<p>适用性</p> 
<pre><code>1.一组对象以定义良好但是复杂的方式进行通信。产生的相互依赖关系结构混乱且难以理解。

2.一个对象引用其他很多对象并且直接与这些对象通信,导致难以复用该对象。

3.想定制一个分布在多个类中的行为，但又不想生成太多的子类。
</code></pre> 
<p>参与者</p> 
<pre><code>1.Mediator
  中介者定义一个接口用于与各同事（Colleague）对象通信。

2.ConcreteMediator
  具有中介者通过协调各同事对象实现协作行为。
  了解并维护它的各个同事。

3.Colleagueclass
  每一个同事类都知道它的中介者对象。
  每一个同事对象在需与其他的同事通信的时候需与它的中介者通信
</code></pre> 
<p>类图</p> 
<p>例子<br> Mediator</p> 
<p>public abstract class Mediator {<!-- --></p> 
<pre><code>public abstract void notice(String content);
</code></pre> 
<p>}<br> ConcreteMediator</p> 
<p>public class ConcreteMediator extends Mediator {<!-- --></p> 
<pre><code>private ColleagueA ca;

private ColleagueB cb;

public ConcreteMediator() {
    ca = new ColleagueA();
    cb = new Col*eagueB();
}

public void notice(String content) {
    if (content.equals("boss")) {
        //老板来了, 通知员工A
        ca.action();
    }
    if (content.equals("client")) {
        //客户来了, 通知前台B
        cb.action();
    }
}
</code></pre> 
<p>}<br> Colleagueclass</p> 
<p>public class ColleagueA extends Colleague {<!-- --></p> 
<pre><code>public void action(） {
    System.out.println("普通员工努力工作");
}
</code></pre> 
<p>}<br> public class ColleagueB extends Colleague {<!-- --></p> 
<pre><code>public void action() {
    System.out.println("前台注意了!");
}
</code></pre> 
<p>}<br> Test</p> 
<p>public class Test {<!-- --></p> 
<pre><code>public static void main(String[] args) {
    Mediator med = new ConcreteMediator();
    //老板来了
    med.notice("boss");
    
    //客户来了
    med.notice("client");
}
</code></pre> 
<p>}<br> result</p> 
<p>普通员工努力工作<br> 前台注意了!<br> 1.3.6 备忘录模式</p> 
<pre><code>在不破坏封装性的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态。这样以后就可将该对象恢复到原先保存的状态。
</code></pre> 
<p>适用性</p> 
<pre><code>1.必须保存一个对象在某一个时刻的(部分)状态,这样以后需要时它才能恢复到先前的状态。

2.如果一个用接口来让其它对象直接得到这些状态，将会暴露对象的实现细节并破坏对象的封装性。
</code></pre> 
<p>参与者</p> 
<pre><code>1.Memento
  备忘录存储原发器对象的内部状态。

2.Originator
  原发器创建一个备忘录,用以记录当前时刻的内部状态。
  使用备忘录恢复内部状态.

3.Caretaker
  负责保存好备忘录。
  不能对备忘录的内部进行操作或检查。
</code></pre> 
<p>类图</p> 
<p>例子<br> Memento</p> 
<p>public class Memento {<!-- --></p> 
<pre><code>private String state;

public Memento(String state) {
    this.state = state;
}

public String getState() {
    return state;
}

public void setState(String state) {
    this.state = state;
}
</code></pre> 
<p>}<br> Originator</p> 
<p>public class Originator {<!-- --></p> 
<pre><code>private String state;

public String getState() {
    return state;
}

public void setState(String state) {
    this.state = state;
}

public Memento createMemento() {
    return new Memento(state);
}

public void setMemento(Memento memento) {
    state = memento.getState();
}

public void showState(){
    System.out.println(state);
}
</code></pre> 
<p>}<br> Caretaker</p> 
<p>public class Caretaker {<!-- --></p> 
<pre><code>private Memento memento;

public Memento getMemento(){
    return this.memento;
}

public void setMemento(Memento memento){
    this.memento = memento;
}
</code></pre> 
<p>}<br> Test</p> 
<p>public class Test {<!-- --></p> 
<pre><code>public static void main(String[] args) {
    Originator org = new Originator();
    org.setState("开会中");
    
    Caretaker ctk = new Caretaker();
    ctk.setMemento(org.createMemento());//将数据封装在Caretaker
    
    org.setState("睡觉中");
    org.showState();//显示
    
    org.setMemento(ctk.getMemento());//将数据重新导入
    org.showState();
}
</code></pre> 
<p>}<br> result</p> 
<p>睡觉中<br> 开会中<br> 1.3.7 观察者模式</p> 
<pre><code>定义对象间的一种一对多的依赖关系,当一个对象的状态发生改变时,所有依赖于它的对象都得到通知并被自动更新。
</code></pre> 
<p>适用性</p> 
<pre><code>1.当一个抽象模型有两个方面,其中一个方面依赖于另一方面。
  将这二者封装成独立的对象中以使它们可以各自独立地改变和复用。

2.当对一个对象的改变需要同时改变其它对象,而不知道具体有多少对象有待改变。

3.当一个对象必须通知其它对象，而它又不能假定其它对象是谁。
</code></pre> 
<p>参与者</p> 
<pre><code>1.Subject（目标）
  目标知道它的观察者。可以有任意多个观察者观察同一个目标。
  提供注册和删除观察者对象的接口。

2.Observer（观察者）
  为那些在目标发生改变时需获得通知的对象定义一个更新接口。

3.ConcreteSubject（具体目标）
  将有关状态存入各ConcreteObserver对象。
  当它的状态发生改变时,向它的各个观察者发出通知。

4.ConcreteObserver（具体观察者）
  维护一个指向ConcreteSubject对象的引用。
  存储有关状态，这些状态应与目标的状态保持一致。
  实现Observer的更新接口可使自身状态与目标的状态保持一致
</code></pre> 
<p>类</p> 
<p>例子<br> Subject</p> 
<p>public abstract class Citizen {<!-- --></p> 
<pre><code>List pols;

String help = "normal";

public void setHelp(String help) {
    this.help = help;
}

public String getHelp() {
    return this.help;
}

abstract void sendMessage(String help);

public void setPolicemen() {
    this.pols = new ArrayList();
}

public void register(Policeman pol) {
    this.pols.add(pol);
}

public void unRegister(Policeman pol) {
    this.pols.remove(pol);
}
</code></pre> 
<p>}<br> Observer</p> 
<p>public interface Policeman {<!-- --></p> 
<pre><code>void action(Citizen ci);
</code></pre> 
<p>}<br> ConcreteSubject</p> 
<p>public class HuangPuCitizen extends Citizen {<!-- --></p> 
<pre><code>public HuangPuCitizen(Policeman pol) {
    setPolicemen();
    Register(pol);
}

public void sendMessage(String help) {
    setHelp(help);
    for(int i = 0; i &lt; pols.size(); i++) {
        Policeman pol = pols.get(i);
        //通知警察行动
        pol.action(this);
    }
}
</code></pre> 
<p>}</p> 
<p>public class TianHeCitizen extends Citizen {<!-- --></p> 
<pre><code>public TianHeCitizen(Policeman pol) {
    setPolicemen();
    register(pol);
}

public void sendMessage(String help) {
    setHelp(help);
    for (int i = 0; i &lt; pols.size(); i++) {
        Policeman pol = pols.get(i);
        //通知警察行动
        pol.action(this);
    }
}
</code></pre> 
<p>}<br> ConcreteObserver</p> 
<p>public class HuangPuPoliceman implements Policeman {<!-- --></p> 
<pre><code>public void action(Citizen ci) {
    String help = ci.getHelp();
    if (help.equals("normal")) {
        System.out.println("一切正常, 不用出动");
    }
    if (help.equals("unnormal")) {
        System.out.println("有犯罪行为, 黄埔警察出动!");
    }
}
</code></pre> 
<p>}</p> 
<p>public class TianHePoliceman implements Policemen {<!-- --></p> 
<pre><code>public void action(Citizen ci) {
    String help = ci.getHelp();
    if (help.equals("mormal")) {
        System.out.println("一切正常, 不用出动");
    }
    if (help.equals("unnormal")) {
        System.out.println("有犯罪行为, 天河警察出动!");
    }
}
</code></pre> 
<p>}<br> Test</p> 
<p>public class Test{<!-- --></p> 
<pre><code>public static void main(String[] args) {
    Policeman thPol = new TianHePoliceman();
    Policeman hpPol = new HuangPuPoliceman();
    
    Citizen citizen = new HuangPuCitizen(hpPol);
    citizen.sendMessage("unnormal");
    citizen.sendMessage("normal");
    
    System.out.println("===========");
    
    citizen = new TianHeCitizen(thPol);
    citizen.sendMessage("normal");
    citi*en.sendMessage("unnormal");
}
</code></pre> 
<p>}<br> result</p> 
<h2><a id="_%0A__2278"></a>有犯罪行为, 黄埔警察出动!<br> 一切正常, 不用出动</h2> 
<p>一切正常, 不用出动<br> 有犯罪行为, 天河警察出动!<br> 1.3.8 状态模式</p> 
<pre><code>定义对象间每一种一对多的依赖关系,当一个对象的状态发生改变时,所有依赖于它的对象都得到通知并被自动更新。
</code></pre> 
<p>适用性</p> 
<pre><code>1.一个对象的行为取决于它的状态,并且它必须在运行时刻根据状态改变它的行为。

2.一个操作中含有庞大的多分支的条件语句，且这些分支依赖于该对象的状态。
  这个状态通常用一个或多个枚举常量表示。
  通常,有多个操作包含这一相同的条件结构。
  State模式将每一个条件分支放入一个独立的类中。
  这使得你可以根据对象自身的情况将对象的状态作为一个对象，这一对象可以不依赖于其他对象而独立变化。
</code></pre> 
<p>参与者</p> 
<pre><code>1.Context
  定义客户感兴趣的接口。
  维护一个ConcreteState子类的实例，这个实例定义当前状态。

2.State
  定义一个接口以封装与Context的一个特定状态相关的行为。

3.ConcreteStatesubclasses
  每一子类实现一个与Context的一个状态相关的行为。
</code></pre> 
<p>类图</p> 
<p>例子<br> Context</p> 
<p>public class Context {<!-- --></p> 
<pre><code>private Weather weather;

public void setWeather(Weather weather) {
    this.weather = weather;
}

public Weather getWeather() {
    return this.weather;
}

public String weatherMessage() {
    return weather.getWeather();
}
</code></pre> 
<p>}<br> State</p> 
<p>public interface Weather {<!-- --></p> 
<pre><code>String getWeather();
</code></pre> 
<p>}<br> ConcreteStatesubclasses</p> 
<p>public class Rain implements Weather {<!-- --></p> 
<pre><code>public String getWeather() {
    return "下雨";
}
</code></pre> 
<p>}</p> 
<p>public class Sunshine implements Weather {<!-- --></p> 
<pre><code>public String getWeather() {
    return "阳光";
}
</code></pre> 
<p>}</p> 
<p>Test</p> 
<p>public class Test{<!-- --></p> 
<pre><code>public static void main(String[] args) {
    Context ctx1 = new Context();
    ctx1.setWeather(new Sunshine());
    System.out.println(ctx1.weatherMessage());

    System.out.println("===============");

    Context ctx2 = new Context();
    ctx2.setWeather(new Rain());
    System.out.println(ctx2.weatherMessage());
}
</code></pre> 
<p>}<br> result</p> 
<h2><a id="_2369"></a>阳光</h2> 
<p>下雨<br> 1.3.9 策略模式</p> 
<pre><code>定义一系列的算法,把它们一个个封装起来,并且使它们可相互替换。本模式使得算法可独立于使用它的客户而变化。
</code></pre> 
<p>适用性</p> 
<pre><code>1.许多相关的类仅仅是行为有异。“策略”提供了一种用多个行为中的一个行为来配置一个类的方法。

2.需要使用一个算法的不同变体。

3.算法使用客户不应该知道的数据。可使用策略模式以避免暴露复杂的、与算法相关的数据结构。

4.一个类定义了多种行为,并且这些行为在这个类的操作中以多个条件语句的形式出现。
  将相关的条件分支移入它们各自的Strategy类中以代替这些条件语句。
</code></pre> 
<p>参与者</p> 
<pre><code>1.Strategy
  定义所有支持的算法的公共接口。Context使用这个接口来调用某ConcreteStrategy定义的算法。

2.ConcreteStrategy
  以Strategy接口实现某具体算法。

3.Context
  用一个ConcreteStrategy对象来配置。
  维护一个对Strategy对象的引用。
  可定义一个接口来让Stategy访问它的数据。
</code></pre> 
<p>类图</p> 
<p>例子<br> Strategy</p> 
<p>public abstract class Strategy {<!-- --></p> 
<pre><code>public abstract void method();
</code></pre> 
<p>}<br> ConcreteStrategy</p> 
<p>public class StrategyImplA extends Strategy {<!-- --></p> 
<pre><code>public void method() {
    System.out.println("这是第一个实现");
}
</code></pre> 
<p>}</p> 
<p>public class StrategyImplB extends Strategy {<!-- --></p> 
<pre><code>public void method() {
    System.out.println("这是第二个实现");
}
</code></pre> 
<p>}</p> 
<p>public class StrategyImplC extends Strategy {<!-- --></p> 
<pre><code>public void method() {
    System.out.println("这是第三个实现");
}
</code></pre> 
<p>}<br> Context</p> 
<p>public class Context {<!-- --></p> 
<pre><code>Strategy stra;

public Context(Strategy stra) {
    this.stra = stra;
}

public void doMethod() {
    stra.method();
}
</code></pre> 
<p>}<br> Test</p> 
<p>public class Test {<!-- --></p> 
<pre><code>public static void main(String[] args) {
    Context ctx = new Context(new StrategyImplA());
    ctx.doMethod();
    
    ctx = new Context(new StrategyImplB());
    ctx.doMethod();
    
    ctx = new Context(new StrategyImplC());
    ctx.doMethod();
}
</code></pre> 
<p>}<br> result</p> 
<p>这是第一个实现<br> 这是第二个实现<br> 这是第三个实现<br> 1.3.10 模板方法</p> 
<pre><code>定义一个操作中的算法的骨架，而将一些步骤延迟到子类中。

TemplateMethod使得子类可以不改变一个算法的结构即可重定义该算法的某些特定步骤。
</code></pre> 
<p>适用性</p> 
<pre><code>1.一次性实现一个算法的不变的部分，并将可变的部分留给子类来实现。

2.各子类中公共的行为应被提取出来并集中到一个公共父类中以避免代码重复。
  首先识别现有代码中的不同之处，并且将不同之处分离为新的操作。
  最后，用一个调用这些新的操作的模板方法来替换这些不同的代码。

3.控制子类发展。
</code></pre> 
<p>参与者</p> 
<pre><code>1.AbstractClass
  定义抽象的原语操作（primitiveoperation），具体的子类将重定义它们以实现一个算法的各步骤。
  实现一个模板方法,定义一个算法的骨架。
  该模板方法不仅调用原语操作，也调用定义在AbstractClass或其他对象中的操作。

*.ConcreteClass
  实现*语操作以完成算法中与特定子类相关的步骤。
</code></pre> 
<p>模板方法的缺陷：</p> 
<ol><li>概念复杂性：从面向对象方法的本质来讲，父类负责抽象，子类负责具体，而模板方法恰好反过来了，父类实现了大部分功能，而子类实现少数抽象方法，然后有父类调用。违反了面向对象的一般性思维的原因是这个模式的初衷并不是抽象，而是最大限度的重用。</li><li>实现复杂性：这种重用方式的代价就是每个子类身上背负了父类强加给它的包袱。<br> 类图</li></ol> 
<p>例子<br> AbstractClass</p> 
<p>public abstract class Template {<!-- --></p> 
<pre><code>public abstract void print();

public void update() {
    System.out.println("开始打印");
    for (int i = 0; i &lt; 10; i++) {
        print();
    }
}
</code></pre> 
<p>}<br> ConcreteClass</p> 
<p>public class TemplateConcrete extends Template {<!-- --></p> 
<pre><code>@override
public void print() {
    System.out.println("这是子类的实现");
}
</code></pre> 
<p>}<br> Test</p> 
<p>public class Test {<!-- --></p> 
<pre><code>public static void main(String[] args) {
    Template temp = new TemplateConcrete();
    temp.update();//控制反转，调用父亲的方法
}
</code></pre> 
<p>}<br> result</p> 
<p>开始打印<br> 这是子类的实现<br> 这是子类的实现<br> 这是子类的实现<br> 这是子类的实现<br> 这是子类的实现<br> 这是子类的实现<br> 这是子类的实现<br> 这是子类的实现<br> 这是子类的实现<br> 这是子类的实现<br> 1.3.11 访问者模式</p> 
<pre><code>表示一个作用于某对象结构中的各元素的操作。
它使你可以在不改变各元素的类的前提下定义作用于这些元素的新操作。
</code></pre> 
<p>适用性</p> 
<pre><code>1.一个对象结构包含很多类对象，它们有不同的接口，而你想对这些对象实施一些依赖于其具体类的操作。

2.需要对一个对象结构中的对象进行很多不同的并且不相关的操作，你想避免让这些操作“污染”这些对象的类。
  Visitor使得你可以将相关的操作集中起来定义在一个类中。
  当该对象结构被很多应用共享时，用Visitor模式让每个应用仅包含需要用到的操作。

3.定义对象结构的类很少改变，但经常需要在此结构上定义新的操作。
  改变对象结构类需要重定义对所有访问者的接口，这可能需要很大的代价。
  如果对象结构类经常改变，那么可能还是在这些类中定义这些操作较好。
</code></pre> 
<p>参与者</p> 
<pre><code>1.Visitor
  为该对象结构中ConcreteElement的每一个类声明一个Visit操作。
  该操作的名字和特征标识了发送Visit请求给该访问者的那个类。
  这使得访问者可以确定正被访问元素的具体的类。
  这样访问者就可以通过该元素的特定接口直接访问它。

2.ConcreteVisitor
  实现每个由Visitor声明的操作。
  每个操作实现本算法的一部分，而该算法片断乃是对应于结构中对象的类。
  ConcreteVisitor为该算法提供了上下文并存取它的局部状态。
  这一状态常常在遍历该结构的过程中累计结果。

3.Element
  定义一个Accept操作，它是一个访问者为参数。

4.ConcreteElement
  实现Accept操作，该操作以一个访问者为参数。

5.ObjectStructure
  能枚举它的元素。
  可以提供一个高层的接口以允许该访问者访问它的元素。
  可以是一个复合或是一个集合，如一个列表或一个无序集合。
</code></pre> 
<p>类图</p> 
<p>例子<br> Visitor</p> 
<p>public interface Visitor {<!-- --></p> 
<pre><code>public void visitString(StringElement stringE);

public void visitFloat(FloatElement floatE);

public void visitCollection(Collection collection); 
</code></pre> 
<p>}<br> ConcreteVisitor</p> 
<p>public class ConcreteVisitor implements Visitor {<!-- --></p> 
<pre><code>public void visitCollection(Collection collection) {
    // TODO Auto-generated method stub
    Iterator iterator = collection.iterator();
    while (iterator.hasNext()) {
        Object o = iterator.next();
        if (o instanceof Visitable) {
            ((Visitable)o).accept(this);
        }
    }
}

public void visitFloat(FloatElement floatE) {
    System.out.println(floatE.getFe*));
}

public void visitString(StringElement stringE) {
    System.out.println(stringE.getSe());
}
</code></pre> 
<p>}<br> Element</p> 
<p>public interface Visitable {<!-- --></p> 
<pre><code>public void accept(Visitor visitor);
</code></pre> 
<p>}<br> ConcreteElement</p> 
<p>public class FloatElement implements Visitable {<!-- --></p> 
<pre><code>private Float fe;

public FloatElement(Float fe) {
    this.fe = fe;
}

public Float getFe() {
    return this.fe;
}

public void accept(Visitor visitor) {
    visitor.VisitFloat(this);
}
</code></pre> 
<p>}</p> 
<p>public class StringElement implements Visitable {<!-- --></p> 
<pre><code>private String se;

public StringElement(String se) {
    this.se = se;
}

public String getSe() {
    return this.se;
}

public void accept(Visitor visitor) {
    visitor.visitString(this);
}
</code></pre> 
<p>}<br> Test</p> 
<p>public class Test {<!-- --></p> 
<pre><code>public static void main(String[] args) {
    Visitor visitor = new ConcreteVisitor();
    StringElement se = new StringElement("abc");
    se.accept(visitor);
    
    FloatElement fe = new FloatElement(new Float(1.5));
    fe.accept(visitor);
    System.out.println("===========");
    List result = new ArrayList();
    result.add(new StringElement("abc"));
    result.add(new StringElement("abc"));
    result.add(new StringElement("abc"));
    result.add(new FloatElement(new Float(1.5)));
    result.add(new FloatElement(new Float(1.5)));
    result.add(new FloatElement(new Float(1.5)));
    visitor.visitCollection(result);
}
</code></pre> 
<p>}<br> result</p> 
<h2><a id="abc%0A15_2679"></a>abc<br> 1.5</h2> 
<p>abc<br> abc<br> abc<br> 1.5<br> 1.5<br> 1.5</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/62229b4db3db147cdcd81c577731d618/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">[Linux] CUDA 安装(一)-------NVIDIA显卡驱动</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/f4536bd2daae40fd1054944bfb80b786/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">STM32 复位电路设计</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>