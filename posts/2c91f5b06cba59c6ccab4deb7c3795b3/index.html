<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>KMP算法中next数组的计算（和前缀表的计算） - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="KMP算法中next数组的计算（和前缀表的计算）" />
<meta property="og:description" content="这里写自定义目录标题 KMP算法中next数组的计算（和前缀表的计算）基础知识BF算法KMP算法 next数组一、前缀表和next数组的关系二、为什么有些next数组是0,1开头，而有些next数组是-1,0开头三、如何计算KMP算法中的next数组（附python实现）方法一：通过前缀表计算next数组（最易理解）方法二：直接计算next数组（和方法一没有本质区别）方法三：动态求解next数组 KMP算法中next数组的计算（和前缀表的计算） 解决问题：
前缀表和next数组的关系为什么有些next数组是0,1开头，而有些next数组是-1,0开头如何计算KMP算法中的next数组 注：本文不讲解KMP算法的实现，只涉及next数组的计算
基础知识 模式匹配： 从某个字符串中找出与一个给定子串相同的子串的位置。简单说就是从一个字符串中找出是否含有另一个字符串，若存在则返回位置。常用的模式匹配算法有：BF（朴素模式匹配算法或暴力匹配算法）、BM算法、RK算法、KMP算法。
主串： 待查找的字符串。
模式串（子串）： 模式匹配就是要从主串中找到子串。
KMP算法： 是一种改进BF算法的模式匹配算法。KMP算法的核心是利用匹配失败后的信息，尽量减少模式串与主串的匹配次数以达到快速匹配的目的。
前缀： 字符串的开头，例如字符串abcd的前缀为a, ab, abc, abcd。在KMP算法中使用的前缀为真前缀，既不包括原字符串abcd的前缀。（真前缀：a, ab, abc）
后缀： 字符串的结尾，在KMP算法中同样使用的是真后缀。
最长公共前后缀： 最长的相等的前缀与后缀，例如字符串ABCxyzABC的最长公共前后缀为ABC
前缀表： 存储每一个前缀的最长公共前后缀的长度。
next数组： KMP算法通过这个数组来决定向右移动几位。每一位记录值的含义是如果在此处失配，模式串向右移动到next值的位置。例如：主串为aabcabcc，模式串为：abab，模式串的next数组计算得-1, 0, 0, 1。若在index=2的字符a处失配，next值为0，将模式串index=0移动到现在的index=2处，再进行匹配。 BF算法 BF算法就是暴力匹配算法，是最好理解的算法。就是对主串一位一位的做判断，匹配失败则将模式串向后移动一位，如下图所示。
由图可见染色的部分有22块，也就是匹配了22次才找到。在极端条件下BF算法要匹配(N-M&#43;1)*M次（其中N为主串长度，M为模式串长度），所以BF算法的时间复杂度为O(M*N)。
KMP算法 KMP算法优化了BM算法，通过一次尽可能多的向右移动来减少匹配次数。KMP算法的时间复杂度只有O(M&#43;N)。
KMP算法利用了最长公共前后缀的值来进行移动，如下图所示：
可以看到，已经匹配过的aba就不用再次进行匹配，而是从index=3的b继续匹配，相较于BF算法节省了大量匹配操作。在KMP算法中，每次移动的位置都由在此处匹配的字符其前缀的最长公共前后缀决定。
next数组 一、前缀表和next数组的关系 前缀表存储每一个前缀的最长公共前后缀的长度，next数组存储的是模式串向右移动到next值的位置，这个值与前缀的最长公共前后缀的长度有关，所以next数组是可以由前缀表生成的。
用前缀表生成一个next数组很容易，将前缀表每一位都向后移动1位（最后一位舍去）并在第一位补一个-1就得到了next数组。
二、为什么有些next数组是0,1开头，而有些next数组是-1,0开头 -1,0开头与0, 1开头的next数组本质是一样的。实际上，以0, 1开头的next数组就是以-1,0开头的next数组每一项加1得到的。出现这种情况的原因在于模式串起始的索引值：在程序中，一个数组的索引的起始值为0；然而在考试和书中给的模式串起始值是多从1开始。所以在考试中遇到的next数组通常是以0, 1开头；而一些程序或教程中的next数组是以-1, 0开头。
注：在考试中通常会给模式串的索引，或者会给next值的前两项，在答题时要按照题目中的要求写next数组。
三、如何计算KMP算法中的next数组（附python实现） 方法一：通过前缀表计算next数组（最易理解） 这种方法计算的是0, 1开头的next数组，如果需要-1, 0开头的next数组，将最后一行对数组每一项都加1的代码删除即可。
具体流程见上前缀表和next数组的关系的第二段
创建前缀表，长度和模式串相同，初值全为0 prefix = [0]*kmp_len 查找最长公共前后缀（傻找就完了） # 从最长的前后缀开始找，依次找到只有一个字符。 for i in range(1, kmp_len): # i = 1 to n-1 # 若模式串为：kkskyyds，i为3（前缀表第4位的值） # 则找kksk的最长公共前后缀（通过下面的循环） for j in range(i, 0, -1): # j = i to 1 # j = 3 --- kks不等于ksk # j = 2 --- kk不等于sk # j = 1 --- k等于k，最长公共前后缀长度为1，所以prefix[i] = j # 假若在j = 1时还找不到最长公共前后缀，则next值不变为0 str1 = kmp_str[0:j] str2 = kmp_str[i-j&#43;1:i&#43;1] if str1 == str2: prefix[i] = j break 计算完前缀表了，现在对前缀表后移1位，再在第一位加一个-1 prefix." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/2c91f5b06cba59c6ccab4deb7c3795b3/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-06-13T08:58:28+08:00" />
<meta property="article:modified_time" content="2022-06-13T08:58:28+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">KMP算法中next数组的计算（和前缀表的计算）</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p></p> 
<div class="toc"> 
 <h4>这里写自定义目录标题</h4> 
 <ul><li><a href="#KMPnext_2" rel="nofollow">KMP算法中next数组的计算（和前缀表的计算）</a></li><li><ul><li><a href="#_11" rel="nofollow">基础知识</a></li><li><ul><li><a href="#BF_30" rel="nofollow">BF算法</a></li><li><a href="#KMP_36" rel="nofollow">KMP算法</a></li></ul> 
   </li><li><a href="#next_44" rel="nofollow">next数组</a></li><li><ul><li><a href="#next_45" rel="nofollow">一、前缀表和next数组的关系</a></li><li><a href="#next01next10_51" rel="nofollow">二、为什么有些next数组是0,1开头，而有些next数组是-1,0开头</a></li><li><a href="#KMPnextpython_56" rel="nofollow">三、如何计算KMP算法中的next数组（附python实现）</a></li><li><ul><li><a href="#next_57" rel="nofollow">方法一：通过前缀表计算next数组（最易理解）</a></li><li><a href="#next_113" rel="nofollow">方法二：直接计算next数组（和方法一没有本质区别）</a></li><li><a href="#next_147" rel="nofollow">方法三：动态求解next数组</a></li></ul> 
   </li></ul> 
  </li></ul> 
 </li></ul> 
</div> 
<p></p> 
<h2><a id="KMPnext_2"></a>KMP算法中next数组的计算（和前缀表的计算）</h2> 
<blockquote> 
 <p>解决问题：</p> 
 <ul><li>前缀表和next数组的关系</li><li>为什么有些next数组是0,1开头，而有些next数组是-1,0开头</li><li>如何计算KMP算法中的next数组</li></ul> 
 <p>注：本文不讲解KMP算法的实现，只涉及next数组的计算</p> 
</blockquote> 
<h3><a id="_11"></a>基础知识</h3> 
<ul><li> <p><strong>模式匹配：</strong> 从某个字符串中找出与一个给定子串相同的子串的位置。简单说就是从一个字符串中找出是否含有另一个字符串，若存在则返回位置。常用的模式匹配算法有：BF（朴素模式匹配算法或暴力匹配算法）、BM算法、RK算法、KMP算法。</p> </li><li> <p><strong>主串：</strong> 待查找的字符串。</p> </li><li> <p><strong>模式串（子串）：</strong> 模式匹配就是要从主串中找到子串。</p> </li><li> <p><strong>KMP算法：</strong> 是一种改进BF算法的模式匹配算法。KMP算法的核心是利用匹配失败后的信息，尽量减少模式串与主串的匹配次数以达到快速匹配的目的。</p> </li><li> <p><strong>前缀：</strong> 字符串的开头，例如字符串abcd的前缀为a, ab, abc, abcd。在KMP算法中使用的前缀为真前缀，既不包括原字符串abcd的前缀。（真前缀：a, ab, abc）</p> </li><li> <p><strong>后缀：</strong> 字符串的结尾，在KMP算法中同样使用的是真后缀。</p> </li><li> <p><strong>最长公共前后缀：</strong> 最长的相等的前缀与后缀，例如字符串ABCxyzABC的最长公共前后缀为ABC</p> </li><li> <p><strong>前缀表：</strong> 存储每一个前缀的最长公共前后缀的长度。</p> </li></ul> 
<p><img src="https://images2.imgbox.com/f1/57/8TsmJWJz_o.png" alt="在这里插入图片描述"></p> 
<ul><li><strong>next数组：</strong> KMP算法通过这个数组来决定向右移动几位。每一位记录值的含义是如果在此处失配，模式串向右移动到next值的位置。例如：主串为aabcabcc，模式串为：abab，模式串的next数组计算得-1, 0, 0, 1。若在index=2的字符a处失配，next值为0，将模式串index=0移动到现在的index=2处，再进行匹配。</li></ul> 
<p><img src="https://images2.imgbox.com/8b/8e/ZLjym9ua_o.png" alt="在这里插入图片描述"></p> 
<h4><a id="BF_30"></a>BF算法</h4> 
<p>BF算法就是暴力匹配算法，是最好理解的算法。就是对主串一位一位的做判断，匹配失败则将模式串向后移动一位，如下图所示。</p> 
<p><img src="https://images2.imgbox.com/74/fa/hMKdtW8m_o.png" alt="在这里插入图片描述"><br> <img src="https://images2.imgbox.com/e2/f5/B3E1qCyN_o.png" alt="在这里插入图片描述"><br> 由图可见染色的部分有22块，也就是匹配了22次才找到。在极端条件下BF算法要匹配(N-M+1)*M次（其中N为主串长度，M为模式串长度），所以BF算法的时间复杂度为O(M*N)。</p> 
<h4><a id="KMP_36"></a>KMP算法</h4> 
<p>KMP算法优化了BM算法，通过一次尽可能多的向右移动来减少匹配次数。KMP算法的时间复杂度只有O(M+N)。</p> 
<p>KMP算法利用了最长公共前后缀的值来进行移动，如下图所示：<br> <img src="https://images2.imgbox.com/6e/a1/jf4OroMH_o.png" alt="在这里插入图片描述"></p> 
<p>可以看到，已经匹配过的aba就不用再次进行匹配，而是从index=3的b继续匹配，相较于BF算法节省了大量匹配操作。在KMP算法中，每次移动的位置都由在此处匹配的字符其前缀的最长公共前后缀决定。</p> 
<h3><a id="next_44"></a>next数组</h3> 
<h4><a id="next_45"></a>一、前缀表和next数组的关系</h4> 
<p>前缀表存储每一个前缀的最长公共前后缀的长度，next数组存储的是模式串向右移动到next值的位置，这个值与前缀的最长公共前后缀的长度有关，所以next数组是可以由前缀表生成的。</p> 
<p>用前缀表生成一个next数组很容易，将前缀表每一位都向后移动1位（最后一位舍去）并在第一位补一个-1就得到了next数组。<br> <img src="https://images2.imgbox.com/4f/a0/fG4PiAfu_o.png" alt="在这里插入图片描述"></p> 
<h4><a id="next01next10_51"></a>二、为什么有些next数组是0,1开头，而有些next数组是-1,0开头</h4> 
<p>-1,0开头与0, 1开头的next数组本质是一样的。实际上，以0, 1开头的next数组就是以-1,0开头的next数组每一项加1得到的。出现这种情况的原因在于模式串起始的索引值：在程序中，一个数组的索引的起始值为0；然而在考试和书中给的模式串起始值是多从1开始。所以在考试中遇到的next数组通常是以0, 1开头；而一些程序或教程中的next数组是以-1, 0开头。</p> 
<p>注：在考试中通常会给模式串的索引，或者会给next值的前两项，在答题时要按照题目中的要求写next数组。</p> 
<h4><a id="KMPnextpython_56"></a>三、如何计算KMP算法中的next数组（附python实现）</h4> 
<h5><a id="next_57"></a>方法一：通过前缀表计算next数组（最易理解）</h5> 
<p>这种方法计算的是0, 1开头的next数组，如果需要-1, 0开头的next数组，将最后一行对数组每一项都加1的代码删除即可。<br> 具体流程见上<a href="#1.2.1" rel="nofollow">前缀表和next数组的关系</a>的第二段</p> 
<ol><li>创建前缀表，长度和模式串相同，初值全为0</li></ol> 
<pre><code class="prism language-python">prefix <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token operator">*</span>kmp_len
</code></pre> 
<ol start="2"><li>查找最长公共前后缀（傻找就完了）</li></ol> 
<pre><code class="prism language-python"><span class="token comment"># 从最长的前后缀开始找，依次找到只有一个字符。</span>
<span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> kmp_len<span class="token punctuation">)</span><span class="token punctuation">:</span>         <span class="token comment"># i = 1 to n-1</span>
    <span class="token comment"># 若模式串为：kkskyyds，i为3（前缀表第4位的值）</span>
    <span class="token comment"># 则找kksk的最长公共前后缀（通过下面的循环）</span>
    <span class="token keyword">for</span> j <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span>i<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">:</span>       <span class="token comment"># j = i to 1</span>
        <span class="token comment"># j = 3 --- kks不等于ksk</span>
        <span class="token comment"># j = 2 --- kk不等于sk</span>
        <span class="token comment"># j = 1 --- k等于k，最长公共前后缀长度为1，所以prefix[i] = j</span>
        <span class="token comment"># 假若在j = 1时还找不到最长公共前后缀，则next值不变为0</span>
        str1 <span class="token operator">=</span> kmp_str<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">:</span>j<span class="token punctuation">]</span>
        str2 <span class="token operator">=</span> kmp_str<span class="token punctuation">[</span>i<span class="token operator">-</span>j<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">:</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span>
        <span class="token keyword">if</span> str1 <span class="token operator">==</span> str2<span class="token punctuation">:</span>
            prefix<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> j
            <span class="token keyword">break</span>
</code></pre> 
<ol start="3"><li>计算完前缀表了，现在对前缀表后移1位，再在第一位加一个-1</li></ol> 
<pre><code class="prism language-python">prefix<span class="token punctuation">.</span>insert<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token comment"># 第一项添加-1</span>
prefix<span class="token punctuation">.</span>pop<span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span>      <span class="token comment"># 删除最后一项</span>
</code></pre> 
<ol start="4"><li>对数组每一项都加1（若要-1, 0开头的next数组就不需要这行代码）</li></ol> 
<pre><code class="prism language-python">kmp_next1 <span class="token operator">=</span> <span class="token punctuation">[</span>i<span class="token operator">+</span><span class="token number">1</span> <span class="token keyword">for</span> i <span class="token keyword">in</span> prefix<span class="token punctuation">]</span>   
<span class="token comment"># 或者：kmp_next1 = list(map(lambda x:x+1, prefix))</span>
</code></pre> 
<p>全部代码：</p> 
<pre><code class="prism language-python"><span class="token keyword">def</span> <span class="token function">calc_next</span><span class="token punctuation">(</span>kmp_str<span class="token punctuation">,</span> kmp_len<span class="token punctuation">)</span><span class="token punctuation">:</span>
	prefix <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token operator">*</span>kmp_len

	<span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> kmp_len<span class="token punctuation">)</span><span class="token punctuation">:</span>
	    <span class="token keyword">for</span> j <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span>i<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
	        str1 <span class="token operator">=</span> kmp_str<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">:</span>j<span class="token punctuation">]</span>
	        str2 <span class="token operator">=</span> kmp_str<span class="token punctuation">[</span>i<span class="token operator">-</span>j<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">:</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span>
	        <span class="token keyword">if</span> str1 <span class="token operator">==</span> str2<span class="token punctuation">:</span>
	            prefix<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> j
	            <span class="token keyword">break</span>
	            
	prefix<span class="token punctuation">.</span>insert<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span>
	prefix<span class="token punctuation">.</span>pop<span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span>
	kmp_next <span class="token operator">=</span> <span class="token punctuation">[</span>i<span class="token operator">+</span><span class="token number">1</span> <span class="token keyword">for</span> i <span class="token keyword">in</span> prefix<span class="token punctuation">]</span> 
	<span class="token comment"># kmp_next = prefix</span>
	<span class="token keyword">return</span> kmp_next
</code></pre> 
<h5><a id="next_113"></a>方法二：直接计算next数组（和方法一没有本质区别）</h5> 
<p>这种方法直接计算next数组（以0, 1开头）。既然方法一中要移位还要添加-1并删除最后一位，可以提前添加好一位，并且不计算最后一位。</p> 
<ol><li>创建next数组</li></ol> 
<pre><code class="prism language-python"><span class="token comment"># 前两位为[0, 1]，其余位全是1</span>
kmp_next2 <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token operator">*</span>kmp_len
kmp_next2<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0</span>
</code></pre> 
<ol start="2"><li>找此位置前一个位置的最长公共前后缀（注意找的时候不带当前位置的字符）</li></ol> 
<pre><code class="prism language-python"><span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span> kmp_len<span class="token punctuation">)</span><span class="token punctuation">:</span>         <span class="token comment"># i = 2 to n-1</span>
    <span class="token keyword">for</span> j <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">:</span>     <span class="token comment"># j = i-1 to 0</span>
        <span class="token comment"># 实际上就是找前一位的最长公共前后缀</span>
        <span class="token keyword">if</span> kmp_str<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">:</span>j<span class="token punctuation">]</span> <span class="token operator">==</span> kmp_str<span class="token punctuation">[</span>i<span class="token operator">-</span>j<span class="token punctuation">:</span>i<span class="token punctuation">]</span><span class="token punctuation">:</span>
            <span class="token comment"># 这里就是在next的基础上每一项都加1</span>
            kmp_next2<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> j <span class="token operator">+</span> kmp_next2<span class="token punctuation">[</span>i<span class="token punctuation">]</span>
            <span class="token keyword">break</span>
</code></pre> 
<p>全部代码：</p> 
<pre><code class="prism language-python"><span class="token keyword">def</span> <span class="token function">calc_next</span><span class="token punctuation">(</span>kmp_str<span class="token punctuation">,</span> kmp_len<span class="token punctuation">)</span><span class="token punctuation">:</span>
	kmp_next <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token operator">*</span>kmp_len
	kmp_next<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0</span>
	
	<span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span> kmp_len<span class="token punctuation">)</span><span class="token punctuation">:</span>
	    <span class="token keyword">for</span> j <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
	        <span class="token keyword">if</span> kmp_str<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">:</span>j<span class="token punctuation">]</span> <span class="token operator">==</span> kmp_str<span class="token punctuation">[</span>i<span class="token operator">-</span>j<span class="token punctuation">:</span>i<span class="token punctuation">]</span><span class="token punctuation">:</span>
	            kmp_next<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> j <span class="token operator">+</span> kmp_next<span class="token punctuation">[</span>i<span class="token punctuation">]</span>
	            <span class="token keyword">break</span>
	<span class="token keyword">return</span> kmp_next
</code></pre> 
<h5><a id="next_147"></a>方法三：动态求解next数组</h5> 
<p>借助动态规划的思想，当计算一个字符串的最长公共前后缀时，通过使用已经找好的next表快速计算。<br> 具体流程如下（开头为0, 1的next数组）：</p> 
<ol><li>找到要算字符的前一个字符c0的next值对应的字符c1</li><li>对比前一个字符c0和对应字符c1</li><li>相等，则next值为c0的index值加1；</li><li>不相等，则c1的next值对应的字符c2，将c0与c2是否相等。</li><li>相等，则next值为c1的index值加1（等价于c0的next值加1）；</li><li>不相等，则以此类推找c2的next对应的字符c3，对比c0与c3。注意，当c2的index为1时，结束，c0的next设为1。</li></ol> 
<p>例如：设模式串为abaabacd，计算index等于5时的next值</p> 
<table><thead><tr><th>index</th><th>1</th><th>2</th><th>3</th><th>4</th><th>5</th><th>6</th><th>7</th><th>8</th></tr></thead><tbody><tr><td>主串</td><td>a</td><td>b</td><td>a</td><td>a</td><td>b</td><td>a</td><td>c</td><td>d</td></tr><tr><td>next数组</td><td>0</td><td>1</td><td>1</td><td>2</td><td>?</td><td></td><td></td><td></td></tr></tbody></table> 
<p>① 找到index = 5 前一个字符，index = 4的字符为a，其next值为2，index = 2对应的字符为b<br> ② 对比 b 和 a 不相等，b的next值为1，，index = 1对应的字符为a<br> ③ 对比 a 和 a 相等，index = 5的next值为b对应的字符a的index值加1，既为1+1=2</p> 
<p>总的来说：如果到第一个字符都没有找到相等的字符，则next值设置为1。对比到一个相等的字符，则next值等于此字符的index值+1。</p> 
<p>下图是所有next值的对比流程（连线代表两个字符进行对比，字符相等输出右边的next值+1，不相等继续对比，直到找到最左边的字符还不相等next值为1）：<br> <img src="https://images2.imgbox.com/a1/1f/5TI2Vmw9_o.png" alt="在这里插入图片描述"><br> 全部代码：</p> 
<pre><code class="prism language-python"><span class="token keyword">def</span> <span class="token function">calc_next</span><span class="token punctuation">(</span>kmp_str<span class="token punctuation">,</span> kmp_len<span class="token punctuation">)</span><span class="token punctuation">:</span>
	kmp_next <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token operator">*</span>kmp_len
	kmp_next<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0</span>    <span class="token comment"># next的前两项为0,1</span>
	
	<span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span> kmp_len<span class="token punctuation">)</span><span class="token punctuation">:</span>
	    strCompare0 <span class="token operator">=</span> kmp_str<span class="token punctuation">[</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span>      <span class="token comment"># 前一个字符</span>
	    n <span class="token operator">=</span> kmp_next<span class="token punctuation">[</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span>               <span class="token comment"># 前一个字符对应的next值</span>
	    strCompare1 <span class="token operator">=</span> kmp_str<span class="token punctuation">[</span>n<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span>      <span class="token comment"># 对应字符</span>
	    
	    <span class="token keyword">while</span> <span class="token boolean">True</span><span class="token punctuation">:</span>
	        <span class="token keyword">if</span> strCompare0 <span class="token operator">==</span> strCompare1<span class="token punctuation">:</span>
	            kmp_next<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> n<span class="token operator">+</span><span class="token number">1</span>
	            <span class="token keyword">break</span>
	        <span class="token keyword">elif</span> n <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">:</span>
	            <span class="token keyword">break</span>
	        <span class="token keyword">else</span><span class="token punctuation">:</span>
	            n <span class="token operator">=</span> kmp_next<span class="token punctuation">[</span>n<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span>
	            strCompare1 <span class="token operator">=</span> kmp_str<span class="token punctuation">[</span>n<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span>
		<span class="token keyword">return</span> kmp_next
</code></pre>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/371c3d0289fe96c0ab36f038ebba073c/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">解决：由于找不到MSVCP140.dll，无法继续执行代码。重新安装程序可能会解决次问题。</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/528b560769747fb93992a6a4c37492c8/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">01背包理论问题(二维数组)</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>