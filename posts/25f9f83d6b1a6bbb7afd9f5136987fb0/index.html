<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>【Redis】不卡壳的 Redis 学习之路：从十大数据类型开始入手 - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="【Redis】不卡壳的 Redis 学习之路：从十大数据类型开始入手" />
<meta property="og:description" content="目录
类型
String 字符串
List 列表
Set 集合
Sorted Set /ZSet 有序集合
Hash 哈希表
GEO 地理空间
HyperLogLog 基数统计
Bitmap 位图
BitField 位域
Stream 流
线上测试地址
常用命令
key 操作指令
String 操作指令
List 操作指令
Set 操作指令
ZSet 操作指令
Hash操作指令
GEO 操作指令
HyperLogLog 操作指令
Bitmap 操作指令
Bitfield 操作指令
Stream 操作指令（附示例）
这是Redis系列的第一篇(￣∇￣)/，我们来介绍众说纷纭的Redis数据类型，本文会对 Redis 7.0 中10大数据类型的基本定义、使用场景、常用命令进行通俗易懂的介绍（就是额。。🤔说人话），看完会对Redis的数据类型方面有个全面的了解（应付个面试够够的），如果还想要更深入更全面的学习，我也都附上了官方文档的地址，可直达权威⁄(⁄ ⁄ ⁄ω⁄ ⁄ ⁄)⁄
正文开始┏ (^ω^)=
估计大家应该也都看过挺多相关的内容，但各个文章总有些小不同，首先强调下，本系列文章讨论的是 Redis 7.0，不同版本之间还是有有一些差异的，为确保准确，我们直接看官网
https://redis.io/docs/data-types/
类型 这里的类型是Value，Key一般都是String
Strings
Lists
Sets
Sorted Sets （ZSet）" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/25f9f83d6b1a6bbb7afd9f5136987fb0/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-07-07T16:48:16+08:00" />
<meta property="article:modified_time" content="2023-07-07T16:48:16+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">【Redis】不卡壳的 Redis 学习之路：从十大数据类型开始入手</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p id="main-toc"><strong>目录</strong></p> 
<p id="%E7%B1%BB%E5%9E%8B-toc" style="margin-left:40px;"><a href="#%E7%B1%BB%E5%9E%8B" rel="nofollow">类型</a></p> 
<p id="String%20%E5%AD%97%E7%AC%A6%E4%B8%B2-toc" style="margin-left:80px;"><a href="#String%20%E5%AD%97%E7%AC%A6%E4%B8%B2" rel="nofollow">String 字符串</a></p> 
<p id="List%20%E5%88%97%E8%A1%A8-toc" style="margin-left:80px;"><a href="#List%20%E5%88%97%E8%A1%A8" rel="nofollow">List 列表</a></p> 
<p id="Set%20%E9%9B%86%E5%90%88-toc" style="margin-left:80px;"><a href="#Set%20%E9%9B%86%E5%90%88" rel="nofollow">Set 集合</a></p> 
<p id="Sorted%20Set%20%2FZSet%20%E6%9C%89%E5%BA%8F%E9%9B%86%E5%90%88-toc" style="margin-left:80px;"><a href="#Sorted%20Set%20%2FZSet%20%E6%9C%89%E5%BA%8F%E9%9B%86%E5%90%88" rel="nofollow">Sorted Set /ZSet 有序集合</a></p> 
<p id="Hash%20%E5%93%88%E5%B8%8C%E8%A1%A8-toc" style="margin-left:80px;"><a href="#Hash%20%E5%93%88%E5%B8%8C%E8%A1%A8" rel="nofollow">Hash 哈希表</a></p> 
<p id="GEO%20%E5%9C%B0%E7%90%86%E7%A9%BA%E9%97%B4-toc" style="margin-left:80px;"><a href="#GEO%20%E5%9C%B0%E7%90%86%E7%A9%BA%E9%97%B4" rel="nofollow">GEO 地理空间</a></p> 
<p id="HyperLogLog%20%E5%9F%BA%E6%95%B0%E7%BB%9F%E8%AE%A1-toc" style="margin-left:80px;"><a href="#HyperLogLog%20%E5%9F%BA%E6%95%B0%E7%BB%9F%E8%AE%A1" rel="nofollow">HyperLogLog 基数统计</a></p> 
<p id="Bitmap%20%E4%BD%8D%E5%9B%BE-toc" style="margin-left:80px;"><a href="#Bitmap%20%E4%BD%8D%E5%9B%BE" rel="nofollow">Bitmap 位图</a></p> 
<p id="BitField%20%E4%BD%8D%E5%9F%9F-toc" style="margin-left:80px;"><a href="#BitField%20%E4%BD%8D%E5%9F%9F" rel="nofollow">BitField 位域</a></p> 
<p id="Stream%20%E6%B5%81-toc" style="margin-left:80px;"><a href="#Stream%20%E6%B5%81" rel="nofollow">Stream 流</a></p> 
<p id="%E7%BA%BF%E4%B8%8A%E6%B5%8B%E8%AF%95%E5%9C%B0%E5%9D%80-toc" style="margin-left:40px;"><a href="#%E7%BA%BF%E4%B8%8A%E6%B5%8B%E8%AF%95%E5%9C%B0%E5%9D%80" rel="nofollow">线上测试地址</a></p> 
<p id="%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4-toc" style="margin-left:40px;"><a href="#%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4" rel="nofollow">常用命令</a></p> 
<p id="key%20%E6%93%8D%E4%BD%9C%E6%8C%87%E4%BB%A4-toc" style="margin-left:80px;"><a href="#key%20%E6%93%8D%E4%BD%9C%E6%8C%87%E4%BB%A4" rel="nofollow">key 操作指令</a></p> 
<p id="String%20%E6%93%8D%E4%BD%9C%E6%8C%87%E4%BB%A4-toc" style="margin-left:80px;"><a href="#String%20%E6%93%8D%E4%BD%9C%E6%8C%87%E4%BB%A4" rel="nofollow">String 操作指令</a></p> 
<p id="List%20%E6%93%8D%E4%BD%9C%E6%8C%87%E4%BB%A4-toc" style="margin-left:80px;"><a href="#List%20%E6%93%8D%E4%BD%9C%E6%8C%87%E4%BB%A4" rel="nofollow">List 操作指令</a></p> 
<p id="Set%20%E6%93%8D%E4%BD%9C%E6%8C%87%E4%BB%A4-toc" style="margin-left:80px;"><a href="#Set%20%E6%93%8D%E4%BD%9C%E6%8C%87%E4%BB%A4" rel="nofollow">Set 操作指令</a></p> 
<p id="ZSet%20%E6%93%8D%E4%BD%9C%E6%8C%87%E4%BB%A4-toc" style="margin-left:80px;"><a href="#ZSet%20%E6%93%8D%E4%BD%9C%E6%8C%87%E4%BB%A4" rel="nofollow">ZSet 操作指令</a></p> 
<p id="Hash%E6%93%8D%E4%BD%9C%E6%8C%87%E4%BB%A4-toc" style="margin-left:80px;"><a href="#Hash%E6%93%8D%E4%BD%9C%E6%8C%87%E4%BB%A4" rel="nofollow">Hash操作指令</a></p> 
<p id="GEO%20%E6%93%8D%E4%BD%9C%E6%8C%87%E4%BB%A4-toc" style="margin-left:80px;"><a href="#GEO%20%E6%93%8D%E4%BD%9C%E6%8C%87%E4%BB%A4" rel="nofollow">GEO 操作指令</a></p> 
<p id="HyperLogLog%20%E6%93%8D%E4%BD%9C%E6%8C%87%E4%BB%A4-toc" style="margin-left:80px;"><a href="#HyperLogLog%20%E6%93%8D%E4%BD%9C%E6%8C%87%E4%BB%A4" rel="nofollow">HyperLogLog 操作指令</a></p> 
<p id="Bitmap%20%E6%93%8D%E4%BD%9C%E6%8C%87%E4%BB%A4-toc" style="margin-left:80px;"><a href="#Bitmap%20%E6%93%8D%E4%BD%9C%E6%8C%87%E4%BB%A4" rel="nofollow">Bitmap 操作指令</a></p> 
<p id="Bitfield%20%E6%93%8D%E4%BD%9C%E6%8C%87%E4%BB%A4-toc" style="margin-left:80px;"><a href="#Bitfield%20%E6%93%8D%E4%BD%9C%E6%8C%87%E4%BB%A4" rel="nofollow">Bitfield 操作指令</a></p> 
<p id="Stream%20%E6%93%8D%E4%BD%9C%E6%8C%87%E4%BB%A4%EF%BC%88%E9%99%84%E7%A4%BA%E4%BE%8B%EF%BC%89-toc" style="margin-left:80px;"><a href="#Stream%20%E6%93%8D%E4%BD%9C%E6%8C%87%E4%BB%A4%EF%BC%88%E9%99%84%E7%A4%BA%E4%BE%8B%EF%BC%89" rel="nofollow">Stream 操作指令（附示例）</a></p> 
<hr id="hr-toc"> 
<p>这是Redis系列的第一篇(￣∇￣)/，我们来介绍众说纷纭的Redis数据类型，本文会对 Redis 7.0 中10大数据类型的基本定义、使用场景、常用命令进行通俗易懂的介绍（就是额。。🤔说人话），看完会对Redis的数据类型方面有个全面的了解（应付个面试够够的），如果还想要更深入更全面的学习，我也都附上了官方文档的地址，可直达权威⁄(⁄ ⁄ ⁄ω⁄ ⁄ ⁄)⁄</p> 
<p>正文开始┏ (^ω^)=</p> 
<p>估计大家应该也都看过挺多相关的内容，但各个文章总有些小不同，首先强调下，本系列文章讨论的是 <strong>Redis 7.0</strong>，不同版本之间还是有有一些差异的，为确保准确，我们直接看官网</p> 
<p><a class="link-info" href="https://redis.io/docs/data-types/" rel="nofollow" title="https://redis.io/docs/data-types/">https://redis.io/docs/data-types/</a></p> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/1c/0c/p5DQADbu_o.png"></p> 
<p></p> 
<h3 id="%E7%B1%BB%E5%9E%8B">类型</h3> 
<blockquote> 
 <p>这里的类型是Value，Key一般都是String</p> 
</blockquote> 
<ul><li> <p>Strings</p> </li><li> <p>Lists</p> </li><li> <p>Sets</p> </li><li> <p>Sorted Sets （ZSet）</p> </li><li> <p>Hashes</p> </li><li> <p>Streams</p> </li><li> <p>Geospatial</p> </li><li> <p>HyperLogLog</p> </li><li> <p>Bitmaps</p> </li><li> <p>Bitfields</p> </li></ul> 
<p></p> 
<h4 id="String%20%E5%AD%97%E7%AC%A6%E4%B8%B2">String 字符串</h4> 
<ul><li> <p>Redis中最基本的类型，一个Key可以对应一个Value</p> </li><li> <p>二进制安全的（可以包含任何数据，比如图片或者序列化的对象）</p> </li><li> <p>一个Redis中的字符串value最多可以是512M</p> </li></ul> 
<p></p> 
<h4 id="List%20%E5%88%97%E8%A1%A8">List 列表</h4> 
<ul><li> <p>简单的字符串列表，按照被插入的顺序排序，你可以添加一个元素到列表的头部（左边）或者尾部（右边）</p> </li><li> <p>底层是个双端链表，最多可以包含2^32-1个元素（4294967295，超过40亿个元素）</p> </li><li> <p>对两端操作性能很高，通过索引下标操作中间节点性能会比较差</p> </li></ul> 
<p></p> 
<h4 id="Set%20%E9%9B%86%E5%90%88">Set 集合</h4> 
<ul><li> <p>String类型的集合</p> </li><li> <p>不允许重复 + 无序</p> </li><li> <p>集合对象的编码可以是intset和hashtable（底层）</p> </li><li> <p>通过哈希表实现的，所以查询、删除、添加的时间复杂度都是O(1)</p> </li><li> <p>可以包含2^32-1个元素（4294967295，超过40亿个元素）</p> </li><li> <p>应用场景</p> 
  <ul><li> <p>微信抽奖小程序（sadd/spop/srandmember）</p> </li><li> <p>朋友圈的点赞</p> </li><li> <p>QQ可能认识的人</p> </li></ul></li></ul> 
<p></p> 
<h4 id="Sorted%20Set%20%2FZSet%20%E6%9C%89%E5%BA%8F%E9%9B%86%E5%90%88">Sorted Set /ZSet 有序集合</h4> 
<ul><li> <p>与Set一样是String类型的集合</p> </li><li> <p>不同的是每个元素都会关联一个double类型的分数（给Redis从小到大排序用的）</p> 
  <ul><li> <p>value变成了一个键值对：score1 value1</p> </li><li> <p>key1 score1 value1 key2 score2 value2</p> </li></ul></li><li> <p>ZSet的成员是唯一的，但分数（score）可以重复</p> </li><li> <p>通过哈希表实现的，所以查询、删除、添加的时间复杂度都是O(1)</p> </li><li> <p>可以包含2^32-1个元素（4294967295，超过40亿个元素）</p> </li><li> <p>应用场景</p> 
  <ul><li> <p>各种排行榜</p> </li></ul></li></ul> 
<p></p> 
<h4 id="Hash%20%E5%93%88%E5%B8%8C%E8%A1%A8">Hash 哈希表</h4> 
<ul><li> <p>K-V 键值对</p> </li><li> <p>可以包含2^32-1个元素（4294967295，超过40亿个元素）</p> </li></ul> 
<p></p> 
<h4 id="GEO%20%E5%9C%B0%E7%90%86%E7%A9%BA%E9%97%B4">GEO 地理空间</h4> 
<ul><li> <p>原理（实际上是个ZSet，score变成了经纬度）</p> 
  <ul><li> <p>核心思想：将球体转换为平面，区块转换为一点</p> </li><li> <p>主要分为3步：</p> 
    <ul><li> <p>将三维地球变为二维坐标</p> </li><li> <p>将二维坐标转换为一维的点块</p> </li><li> <p>将一维的点块转换为二进制再通过base32编码</p> </li></ul></li></ul></li><li> <p>主要用于存储地理位置信息，并对存储的信息进行操作，包括</p> 
  <ul><li> <p>添加地理位置的坐标</p> </li><li> <p>获取地理位置的坐标</p> </li><li> <p>计算两个位置之间的距离</p> </li><li> <p>……</p> </li></ul></li><li> <p>应用场景</p> 
  <ul><li> <p>美团地图位置附近的酒店</p> </li><li> <p>高德地图附近的核酸点</p> </li></ul></li></ul> 
<p></p> 
<h4 id="HyperLogLog%20%E5%9F%BA%E6%95%B0%E7%BB%9F%E8%AE%A1">HyperLogLog 基数统计</h4> 
<ul><li> <p>用完做基数统计的算法</p> 
  <ul><li> <p>基数：是一种数据集，去重后的真实个数</p> </li><li> <p>基数统计：用于统计一个几乎中不重复的元素的个数，就是对集合去重后剩余元素的计算，即<strong>去重脱水后的真实数据</strong></p> </li></ul></li><li> <p>优点是在输入元素的数量或者体积特别大时，计算基数所需的空间总是固定且很小的</p> 
  <ul><li> <p>每个HyperLogLog键只需要12kb内存，就可以计算出接近2^64个不同的元素的基数</p> </li><li> <p>这和元素越多耗费内存越多的集合产生了鲜明的对比</p> </li></ul></li><li> <p>但HyperLogLog并不会记录每个元素的具体值</p> </li><li> <p>可用于统计<u>某个网站/文章的UV</u>、<u>用户搜索🔍关键词的数量</u>、<u>用户每天搜索不同词条的个数</u></p> 
  <ul><li> <p>UV unique visitor 独立访客（一般为用户IP）</p> </li></ul></li></ul> 
<p></p> 
<h4 id="Bitmap%20%E4%BD%8D%E5%9B%BE">Bitmap 位图</h4> 
<ul><li> <p>Bit arrays（or simply bitmaps）Bitmap是用String作为底层数据结构实现的一种统计二值状态的数据类型</p> </li><li> <p>一个字节占8位（1 byte = 8 bit）</p> </li><li> <p>由0和1组成的二进制位的<u><strong>bit数组</strong></u>（1 bit 只能存1个0/1）</p> </li><li> <p>一般用于状态记录📝</p> 
  <ul><li> <p>用户是否登陆过</p> </li><li> <p>电影广告是否被点击播放过</p> </li><li> <p>上下班打卡统计</p> </li></ul></li></ul> 
<p></p> 
<h4 id="BitField%20%E4%BD%8D%E5%9F%9F">BitField 位域</h4> 
<ul><li> <p>可以一次性操作多个比特<strong>位域</strong>（连续的多个比特位），它会执行一系列操作并返回一个响应数组，这个数组中的元素对应参数列表中的相应操作的执行结果（其实就是一次性对多个比特位进行操作）</p> </li></ul> 
<p></p> 
<h4 id="Stream%20%E6%B5%81">Stream 流</h4> 
<ul><li> <p>Redis 5.0 新增的数据结构 : <strong>MQ消息中间件+阻塞队列</strong></p> </li><li> <p>主要用于<strong>消息队列</strong>（MQ，Message Queue）</p> 
  <ul><li> <p>支持消息队列的持久化</p> </li><li> <p>支持自动生成全局唯一ID</p> </li><li> <p>支持ack确认消息的模式</p> </li><li> <p>支持消费组（多个消费者）模式等</p> </li></ul></li><li> <p>Redis本身有一个发布/订阅来实现消息队列的功能，但他的<u>缺点</u>是<u>消息无法持久化，如果出现网络断开、Redis宕机等，消息就会被丢弃</u></p> 
  <ul><li> <p>即发布/订阅可以分发消息，但无法记录历史消息</p> </li></ul></li><li> <p>Redis的Stream提供了消息的持久化以及主从备份复制功能，可以让任何客户端访问任何时刻的数据，并且能记住每一个客户端的访问位置，还能保证消息不丢失，让消息队列更加稳定和可靠</p> </li></ul> 
<p></p> 
<h3 id="%E7%BA%BF%E4%B8%8A%E6%B5%8B%E8%AF%95%E5%9C%B0%E5%9D%80">线上测试地址</h3> 
<p>如果有不想在本地安装Redis的同学可以试试这个官方提供的测试网站</p> 
<p><a class="link-info" href="https://try.redis.io/" rel="nofollow" title="https://try.redis.io/">https://try.redis.io/</a></p> 
<h3 id="%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4">常用命令</h3> 
<p>需要注意的有两点</p> 
<ul><li>命令不区分大小写，但是key是区分大小写的</li><li> <p>中括号（'<code>[]'</code>）内的为可选参数</p> </li></ul> 
<p>各个命令查询地址 <a class="link-info" href="https://redis.io/commands/" rel="nofollow" title="https://redis.io/commands/">https://redis.io/commands/</a></p> 
<p></p> 
<h4 id="key%20%E6%93%8D%E4%BD%9C%E6%8C%87%E4%BB%A4">key 操作指令</h4> 
<table><thead><tr><th colspan="1" rowspan="1"> <p><strong>指令</strong></p> </th><th colspan="1" rowspan="1"> <p><strong>作用</strong></p> </th><th colspan="1" rowspan="1"> <p><strong>备注</strong></p> </th></tr></thead><tbody><tr><td colspan="1" rowspan="1"> <p>key *</p> </td><td colspan="1" rowspan="1"> <p>查看当前库所有key</p> </td><td colspan="1" rowspan="1"> <p></p> </td></tr><tr><td colspan="1" rowspan="1"> <p>exists key</p> </td><td colspan="1" rowspan="1"> <p>判断某个key是否存在</p> </td><td colspan="1" rowspan="1"> <p></p> </td></tr><tr><td colspan="1" rowspan="1"> <p>type key</p> </td><td colspan="1" rowspan="1"> <p>查看某个key的类型</p> </td><td colspan="1" rowspan="1"> <p></p> </td></tr><tr><td colspan="1" rowspan="1"> <p>del key</p> </td><td colspan="1" rowspan="1"> <p>删除指定的key</p> </td><td colspan="1" rowspan="1"> <p>原子的</p> </td></tr><tr><td colspan="1" rowspan="1"> <p>unlink key</p> </td><td colspan="1" rowspan="1"> <p>非阻塞删除（仅将key从keyspace元数据中移除）</p> </td><td colspan="1" rowspan="1"> <p></p> </td></tr><tr><td colspan="1" rowspan="1"> <p>ttl key</p> </td><td colspan="1" rowspan="1"> <p>查看还有多少秒过期（-1表示永不过期，-2表示已过期）</p> </td><td colspan="1" rowspan="1"> <p></p> </td></tr><tr><td colspan="1" rowspan="1"> <p>expire key 秒钟</p> </td><td colspan="1" rowspan="1"> <p>为给定的key设置过期时间</p> </td><td colspan="1" rowspan="1"> <p></p> </td></tr><tr><td colspan="1" rowspan="1"> <p>move key dbindex</p> </td><td colspan="1" rowspan="1"> <p>将当前数据库的key移动到给定的数据库db中（dbindex的值为0-15）</p> </td><td colspan="1" rowspan="1"> <p>默认0</p> </td></tr><tr><td colspan="1" rowspan="1"> <p>dbsize</p> </td><td colspan="1" rowspan="1"> <p>查看当前数据库key的数量</p> </td><td colspan="1" rowspan="1"> <p></p> </td></tr><tr><td colspan="1" rowspan="1"> <p>flushdb</p> </td><td colspan="1" rowspan="1"> <p>清空当前库</p> </td><td colspan="1" rowspan="1"> <p></p> </td></tr><tr><td colspan="1" rowspan="1"> <p>flushall</p> </td><td colspan="1" rowspan="1"> <p>清空全部库</p> </td><td colspan="1" rowspan="1"> <p></p> </td></tr></tbody></table> 
<h4 id="String%20%E6%93%8D%E4%BD%9C%E6%8C%87%E4%BB%A4">String 操作指令</h4> 
<table><thead><tr><th colspan="2" rowspan="1" style="width:314px;"> <p><strong>指令</strong></p> </th><th colspan="1" rowspan="1" style="width:154px;"> <p><strong>作用</strong></p> </th><th colspan="1" rowspan="1"> <p>可选项说明及备注</p> </th></tr></thead><tbody><tr><td colspan="2" rowspan="1" style="width:314px;"> <p>set key value [<code>NX</code>|<code>XX</code>] [<code>GET</code>][<code>EX seconds</code>|<code>PX milliseconds</code>|<code>EXAT unit-time-milliseconds</code>|<code>KEEPTTL</code>]</p> <p></p> </td><td colspan="1" rowspan="1" style="width:154px;"> <p>设置/添加</p> <p></p> </td><td colspan="1" rowspan="1"> 
    <ul><li> <p><code>NX</code> 键不存在的时候设置（键存在会设置失败）</p> </li><li> <p><code>XX</code> 键存在的时候设置（会覆盖）</p> </li><li> <p><code>GET</code> 先返回旧值，再设置新值</p> </li><li> <p><code>EX seconds</code> 设置过期时间（单位：秒）</p> </li><li> <p><code>PX milliseconds</code> 设置过期时间（单位：毫秒）</p> </li><li> <p><code>KEEPTT</code> 设置续接过期时间（不设置默认用不失效-1）</p> </li></ul></td></tr><tr><td colspan="1" rowspan="3"> <p>批处理</p> </td><td colspan="1" rowspan="1" style="width:159px;"> <p>mset key value [key value ...]</p> </td><td colspan="1" rowspan="1" style="width:154px;"> <p>同时设置多个值</p> </td><td colspan="1" rowspan="1"> <p></p> </td></tr><tr><td colspan="1" rowspan="1" style="width:159px;"> <p>mget key value [key value ...]</p> </td><td colspan="1" rowspan="1" style="width:154px;"> <p>同时获取多个值</p> </td><td colspan="1" rowspan="1"> <p></p> </td></tr><tr><td colspan="1" rowspan="1" style="width:159px;"> <p>msetnx key value</p> </td><td colspan="1" rowspan="1" style="width:154px;"> <p>key不存在才设置</p> </td><td colspan="1" rowspan="1"> <p>所有的key都不存在才会设置成功</p> </td></tr><tr><td colspan="2" rowspan="1" style="width:314px;"> <p>getrange key <code>start</code> <code>end</code></p> <p></p> </td><td colspan="1" rowspan="1" style="width:154px;"> <p>获取指定区域内的值</p> </td><td colspan="1" rowspan="1"> 
    <ul><li> <p><code>start</code> 开始下标（从0开始）</p> </li><li> <p><code>end</code> 结束下标</p> </li></ul></td></tr><tr><td colspan="2" rowspan="1" style="width:314px;"> <p>setrange key <code>offset</code> <code>vaue</code></p> </td><td colspan="1" rowspan="1" style="width:154px;"> <p>设置指定区域内的值</p> </td><td colspan="1" rowspan="1"> 
    <ul><li> <p><code>offset</code> 开始下标</p> </li><li> <p><code>vaue</code> 设置数量</p> </li></ul></td></tr><tr><td colspan="1" rowspan="4"> <p>数值增减</p> <p>（必须是数字才行）</p> <p></p> </td><td colspan="1" rowspan="1" style="width:159px;"> <p>INCR key</p> </td><td colspan="1" rowspan="1" style="width:154px;"> <p>递增数字</p> </td><td colspan="1" rowspan="1"> <p></p> </td></tr><tr><td colspan="1" rowspan="1" style="width:159px;"> <p>INCRBY key <code>increment</code></p> </td><td colspan="1" rowspan="1" style="width:154px;"> <p>增加减少指定的参数</p> </td><td colspan="1" rowspan="1"> 
    <ul><li> <p><code>increment</code> 指步长</p> </li></ul></td></tr><tr><td colspan="1" rowspan="1" style="width:159px;"> <p>DECR key</p> </td><td colspan="1" rowspan="1" style="width:154px;"> <p>递减数值</p> </td><td colspan="1" rowspan="1"> <p></p> </td></tr><tr><td colspan="1" rowspan="1" style="width:159px;"> <p>DECRBY key <code>decrement</code></p> </td><td colspan="1" rowspan="1" style="width:154px;"> <p>减少指定的参数</p> </td><td colspan="1" rowspan="1"> <p></p> </td></tr><tr><td colspan="2" rowspan="1" style="width:314px;"> <p>STRLEN key</p> </td><td colspan="1" rowspan="1" style="width:154px;"> <p>获取字符串长度</p> </td><td colspan="1" rowspan="1"> <p></p> </td></tr><tr><td colspan="2" rowspan="1" style="width:314px;"> <p>APPENG key value</p> </td><td colspan="1" rowspan="1" style="width:154px;"> <p>内容追加</p> </td><td colspan="1" rowspan="1"> <p></p> </td></tr><tr><td colspan="1" rowspan="2"> <p>分布式锁</p> <p>（原子操作）</p> </td><td colspan="1" rowspan="1" style="width:159px;"> <p>setnx key value</p> </td><td colspan="1" rowspan="1" style="width:154px;"> <p>key不存在才设置</p> </td><td colspan="1" rowspan="1"> <p>nx: set if not exsit</p> </td></tr><tr><td colspan="1" rowspan="1" style="width:159px;"> <p>setex key <code>seconds</code> value</p> </td><td colspan="1" rowspan="1" style="width:154px;"> <p>同时设置值和过期时间</p> </td><td colspan="1" rowspan="1"> <p>ex: set with expire</p> </td></tr><tr><td colspan="2" rowspan="1" style="width:314px;"> <p>getset key value</p> </td><td colspan="1" rowspan="1" style="width:154px;"> <p>先get后set</p> </td><td colspan="1" rowspan="1"> <p>等价于 set key value get</p> </td></tr></tbody></table> 
<p></p> 
<h4 id="List%20%E6%93%8D%E4%BD%9C%E6%8C%87%E4%BB%A4">List 操作指令</h4> 
<table><thead><tr><th colspan="1" rowspan="1"> <p><strong>指令</strong></p> </th><th colspan="1" rowspan="1"> <p><strong>作用</strong></p> </th><th colspan="1" rowspan="1"> <p>可选项说明及备注</p> </th></tr></thead><tbody><tr><td colspan="1" rowspan="1"> <p>lpush key value</p> </td><td colspan="1" rowspan="1"> <p>从左边👈设置/添加</p> </td><td colspan="1" rowspan="1"> <p></p> </td></tr><tr><td colspan="1" rowspan="1"> <p>rpush key value</p> </td><td colspan="1" rowspan="1"> <p>从右边👉设置/添加</p> </td><td colspan="1" rowspan="1"> <p></p> </td></tr><tr><td colspan="1" rowspan="1"> <p>lrange key <code>start</code> <code>stop</code></p> </td><td colspan="1" rowspan="1"> <p>从左边👈开始遍历</p> </td><td colspan="1" rowspan="1"> 
    <ul><li> <p><code>start</code> 开始下标（从0开始）</p> </li><li> <p><code>stop</code> 结束下标</p> </li></ul><p><code>lrange key 0 -1</code> 表示遍历全部</p> </td></tr><tr><td colspan="1" rowspan="1"> <p>lpop</p> </td><td colspan="1" rowspan="1"> <p>弹出最左边的值</p> </td><td colspan="1" rowspan="1"> <p></p> </td></tr><tr><td colspan="1" rowspan="1"> <p>rpop</p> </td><td colspan="1" rowspan="1"> <p>弹出最右边的值</p> </td><td colspan="1" rowspan="1"> <p></p> </td></tr><tr><td colspan="1" rowspan="1"> <p>lindex</p> </td><td colspan="1" rowspan="1"> <p>按照索引下标获得元素（从上到下）</p> </td><td colspan="1" rowspan="1"> <p>左（上）右（下）</p> </td></tr><tr><td colspan="1" rowspan="1"> <p>llen</p> </td><td colspan="1" rowspan="1"> <p>获取list中的元素个数</p> </td><td colspan="1" rowspan="1"> <p></p> </td></tr><tr><td colspan="1" rowspan="1"> <p>lrem key <code>N</code> value</p> </td><td colspan="1" rowspan="1"> <p>删除N值为value的元素</p> </td><td colspan="1" rowspan="1"> 
    <ul><li> <p><code>N</code> 表示删除值的个数</p> </li></ul></td></tr><tr><td colspan="1" rowspan="1"> <p>ltrim key <code>start</code> <code>stop</code></p> </td><td colspan="1" rowspan="1"> <p>截取指定索引范围的值<u>再赋值给ke</u>y</p> <p></p> </td><td colspan="1" rowspan="1"> 
    <ul><li> <p><code>start</code> 开始下标（从0开始）</p> </li><li> <p><code>stop</code> 结束下标</p> </li></ul></td></tr><tr><td colspan="1" rowspan="1"> <p>rpoplpush key1 key2</p> </td><td colspan="1" rowspan="1"> <p>从key1中弹出最右边的，加入到key2的最左端并返回</p> </td><td colspan="1" rowspan="1"> <p></p> </td></tr><tr><td colspan="1" rowspan="1"> <p>lset key <code>index</code> value</p> </td><td colspan="1" rowspan="1"> <p>将key中序号为<code>index</code>的值设置为value</p> </td><td colspan="1" rowspan="1"> 
    <ul><li> <p><code>index</code> 要设置的值的序号（没有该序号则会报错）</p> </li></ul></td></tr><tr><td colspan="1" rowspan="1"> <p>linsert key before/after <code>pivot</code> <code>element</code></p> </td><td colspan="1" rowspan="1"> <p>在key中值为<code>pivot</code>的元素前/后插入值为<code>element</code>的元素</p> </td><td colspan="1" rowspan="1"> 
    <ul><li> <p><code>pivot</code> 已有值</p> </li><li> <p><code>element</code> 插入值</p> </li></ul><p>从上向向下👇第一个等于<code>pivot</code>的值</p> </td></tr></tbody></table> 
<h4 id="Set%20%E6%93%8D%E4%BD%9C%E6%8C%87%E4%BB%A4">Set 操作指令</h4> 
<table><thead><tr><th colspan="2" rowspan="1"> <p><strong>指令</strong></p> </th><th colspan="1" rowspan="1"> <p><strong>作用</strong></p> </th><th colspan="1" rowspan="1"> <p>可选项说明及备注</p> </th></tr></thead><tbody><tr><td colspan="2" rowspan="1"> <p>sadd key <code>member</code> [<code>member</code>...]</p> </td><td colspan="1" rowspan="1"> <p>添加元素</p> </td><td colspan="1" rowspan="1"> <p>自动去重</p> </td></tr><tr><td colspan="2" rowspan="1"> <p>smembers key</p> </td><td colspan="1" rowspan="1"> <p>遍历所有元素</p> </td><td colspan="1" rowspan="1"> <p></p> </td></tr><tr><td colspan="2" rowspan="1"> <p>sismember key <code>member</code></p> </td><td colspan="1" rowspan="1"> <p>判断元素是否在集合中</p> </td><td colspan="1" rowspan="1"> <p></p> </td></tr><tr><td colspan="2" rowspan="1"> <p>srem key <code>member</code>[<code>member</code>...]</p> </td><td colspan="1" rowspan="1"> <p>删除元素</p> </td><td colspan="1" rowspan="1"> <p></p> </td></tr><tr><td colspan="2" rowspan="1"> <p>scard key</p> </td><td colspan="1" rowspan="1"> <p>获取集合里面的元素个数</p> </td><td colspan="1" rowspan="1"> <p></p> </td></tr><tr><td colspan="2" rowspan="1"> <p>srandmember key [<code>n</code>]</p> </td><td colspan="1" rowspan="1"> <p>从集合中随机展现<code>n</code>个元素，不删除</p> </td><td colspan="1" rowspan="1"> 
    <ul><li> <p><code>n</code> 展示元素的个数</p> </li></ul></td></tr><tr><td colspan="2" rowspan="1"> <p>spop key [<code>n</code>]</p> </td><td colspan="1" rowspan="1"> <p>从集合中随机弹出/删除<code>n</code>个元素</p> </td><td colspan="1" rowspan="1"> 
    <ul><li> <p><code>n</code> 弹出/删除元素的个数</p> </li></ul></td></tr><tr><td colspan="2" rowspan="1"> <p>smove key1 key2 [<code>value</code>]</p> </td><td colspan="1" rowspan="1"> <p>将key1中的某个值<code>value</code>赋值给key2</p> </td><td colspan="1" rowspan="1"> 
    <ul><li> <p><code>value</code>：key1中的某个值</p> </li></ul></td></tr><tr><td colspan="1" rowspan="4"> <p>集合运算</p> </td><td colspan="1" rowspan="1"> <p>sdiff key [key...]</p> </td><td colspan="1" rowspan="1"> <p>差集运算 A - B</p> </td><td colspan="1" rowspan="1"> <p></p> </td></tr><tr><td colspan="1" rowspan="1"> <p>sunion key [key...]</p> </td><td colspan="1" rowspan="1"> <p>并运算 A U B</p> </td><td colspan="1" rowspan="1"> <p></p> </td></tr><tr><td colspan="1" rowspan="1"> <p>sinter key [key...]</p> </td><td colspan="1" rowspan="1"> <p>交运算 A n B</p> </td><td colspan="1" rowspan="1"> <p></p> </td></tr><tr><td colspan="1" rowspan="1"> <p>sintercard numkeys key [key...] [limit <code>num</code>]</p> </td><td colspan="1" rowspan="1"> <p>只返回基数（去重统计数）</p> </td><td colspan="1" rowspan="1"> 
    <ul><li> <p><code>num</code> 返回个数</p> </li></ul></td></tr></tbody></table> 
<h4 id="ZSet%20%E6%93%8D%E4%BD%9C%E6%8C%87%E4%BB%A4">ZSet 操作指令</h4> 
<table><thead><tr><th colspan="1" rowspan="1"> <p><strong>指令</strong></p> </th><th colspan="1" rowspan="1"> <p><strong>作用</strong></p> </th><th colspan="1" rowspan="1"> <p>可选项说明及备注</p> </th></tr></thead><tbody><tr><td colspan="1" rowspan="1"> <p>zadd key [<code>NX</code>|<code>XX</code>] [<code>GT</code>|<code>LT</code>] [<code>CH</code>] [<code>INCR</code>] score member [score member ...]</p> </td><td colspan="1" rowspan="1"> <p>向有序集合添加一个元素和该元素的分数</p> </td><td colspan="1" rowspan="1"> <p></p> </td></tr><tr><td colspan="1" rowspan="1"> <p>zrange key <code>start</code> <code>stop</code> [<code>withscores</code>]</p> </td><td colspan="1" rowspan="1"> <p>按照元素分数从小到大的顺序，返回索引从start到stop之间的所有元素</p> </td><td colspan="1" rowspan="1"> 
    <ul><li> <p><code>withscores</code> 带分数</p> </li><li> <p><code>start</code> 开始下标（从0开始）</p> </li><li> <p><code>stop</code> 结束下标</p> </li></ul></td></tr><tr><td colspan="1" rowspan="1"> <p>zrevrange key <code>start</code> <code>stop</code> [<code>withscores</code>]</p> </td><td colspan="1" rowspan="1"> <p>zrange的反转（从大到小）</p> </td><td colspan="1" rowspan="1"> 
    <ul><li> <p><code>withscores</code> 带分数</p> </li><li> <p><code>start</code> 开始下标（从0开始）</p> </li><li> <p><code>stop</code> 结束下标</p> </li></ul></td></tr><tr><td colspan="1" rowspan="1"> <p>zrangebyscore key <code>min</code> <code>max</code> [<code>withscores</code>][<code>limit offset count</code>]</p> </td><td colspan="1" rowspan="1"> <p>获取指定分数范围的元素</p> <p></p> </td><td colspan="1" rowspan="1"> 
    <ul><li> <p><code>(min</code> 不包含</p> </li><li> <p><code>limit offset count</code> 从<code>offset</code>开始取<code>count</code>个</p> </li></ul></td></tr><tr><td colspan="1" rowspan="1"> <p>zscore key member</p> </td><td colspan="1" rowspan="1"> <p>获取元素的分数</p> </td><td colspan="1" rowspan="1"> <p></p> </td></tr><tr><td colspan="1" rowspan="1"> <p>zcard key</p> </td><td colspan="1" rowspan="1"> <p>获取集合中元素的数量</p> </td><td colspan="1" rowspan="1"> <p></p> </td></tr><tr><td colspan="1" rowspan="1"> <p>zrem key <code>member</code></p> </td><td colspan="1" rowspan="1"> <p>删除值为指定分数的元素</p> </td><td colspan="1" rowspan="1"> 
    <ul><li> <p><code>member</code> 要删除元素的value值</p> </li></ul></td></tr><tr><td colspan="1" rowspan="1"> <p>zincrby key <code>increment</code> member</p> </td><td colspan="1" rowspan="1"> <p>增加某个元素的分数</p> </td><td colspan="1" rowspan="1"> 
    <ul><li> <p><code>increment</code> 增加的值</p> </li></ul></td></tr><tr><td colspan="1" rowspan="1"> <p>zcount key <code>min</code> <code>max</code></p> </td><td colspan="1" rowspan="1"> <p>获取指定分数范围内的元素个数</p> </td><td colspan="1" rowspan="1"> 
    <ul><li> <p><code>min</code> 开始</p> </li><li> <p><code>max</code> 结束</p> </li></ul></td></tr><tr><td colspan="1" rowspan="1"> <p>zmpop</p> <p></p> </td><td colspan="1" rowspan="1"> <p>从键名列表中的第一个非空排序集中弹出一个或多个元素，他们是成员分数对</p> </td><td colspan="1" rowspan="1"> <p></p> </td></tr><tr><td colspan="1" rowspan="1"> <p>zrank key values</p> </td><td colspan="1" rowspan="1"> <p>获取下标值（从0开始）</p> </td><td colspan="1" rowspan="1"> <p></p> </td></tr><tr><td colspan="1" rowspan="1"> <p>zrevrank key values</p> </td><td colspan="1" rowspan="1"> <p>逆序获取下标值</p> </td><td colspan="1" rowspan="1"> <p></p> </td></tr></tbody></table> 
<h4>Hash操作指令</h4> 
<table><thead><tr><th colspan="2" rowspan="1" style="width:206px;"> <p><strong>指令</strong></p> </th><th colspan="1" rowspan="1" style="width:300px;"> <p><strong>作用</strong></p> </th><th colspan="1" rowspan="1" style="width:183px;"> <p>可选项说明及备注</p> </th></tr></thead><tbody><tr><td colspan="2" rowspan="1" style="width:206px;"> <p>hset key <code>field value</code> [<code>field value</code>...]</p> </td><td colspan="1" rowspan="1" style="width:300px;"> <p>添加/设置</p> </td><td colspan="1" rowspan="1" style="width:183px;"> 
    <ul><li> <p><code>field value</code> 也是某个元素内的属性键值对</p> </li></ul></td></tr><tr><td colspan="2" rowspan="1" style="width:206px;"> <p>hget key field</p> </td><td colspan="1" rowspan="1" style="width:300px;"> <p>获取键为key的元素中的field属性的值</p> </td><td colspan="1" rowspan="1" style="width:183px;"> <p></p> </td></tr><tr><td colspan="1" rowspan="2" style="width:35px;"> <p>批处理</p> </td><td colspan="1" rowspan="1" style="width:171px;"> <p>hmset key <code>field value</code> [<code>field value</code>...]</p> </td><td colspan="1" rowspan="1" style="width:300px;"> <p>批量添加/设置</p> </td><td colspan="1" rowspan="1" style="width:183px;"> <p></p> </td></tr><tr><td colspan="1" rowspan="1" style="width:171px;"> <p>hget key <code>field</code> [<code>field</code> ...]</p> </td><td colspan="1" rowspan="1" style="width:300px;"> <p>批量获取</p> </td><td colspan="1" rowspan="1" style="width:183px;"> <p></p> </td></tr><tr><td colspan="2" rowspan="1" style="width:206px;"> <p>hgetall key</p> </td><td colspan="1" rowspan="1" style="width:300px;"> <p>获取键为key的元素中的全部属性</p> </td><td colspan="1" rowspan="1" style="width:183px;"> <p></p> </td></tr><tr><td colspan="2" rowspan="1" style="width:206px;"> <p>hlen key</p> </td><td colspan="1" rowspan="1" style="width:300px;"> <p>获取某个key内的全部数量</p> </td><td colspan="1" rowspan="1" style="width:183px;"> <p></p> </td></tr><tr><td colspan="2" rowspan="1" style="width:206px;"> <p>hexists key</p> </td><td colspan="1" rowspan="1" style="width:300px;"> <p>判断是否存在键值为key值（0不存在）</p> </td><td colspan="1" rowspan="1" style="width:183px;"> <p></p> </td></tr><tr><td colspan="2" rowspan="1" style="width:206px;"> <p>hkeys key</p> </td><td colspan="1" rowspan="1" style="width:300px;"> <p>获取键值为key值元素的所有字段名（<code>field</code>）</p> </td><td colspan="1" rowspan="1" style="width:183px;"> <p></p> </td></tr><tr><td colspan="2" rowspan="1" style="width:206px;"> <p>hvals key</p> </td><td colspan="1" rowspan="1" style="width:300px;"> <p>获取键值为key值元素的所有字段值（<code>value</code>）</p> </td><td colspan="1" rowspan="1" style="width:183px;"> <p></p> </td></tr><tr><td colspan="2" rowspan="1" style="width:206px;"> <p>hincrby/hincrbyfloat key <code>field</code> <code>increment</code></p> </td><td colspan="1" rowspan="1" style="width:300px;"> <p>给键值为key值元素中<code>field</code>的字段值加<code>increment</code></p> </td><td colspan="1" rowspan="1" style="width:183px;"> 
    <ul><li> <p>hincrby 加整数</p> </li><li> <p>hincrbyfloat 加小数</p> </li></ul></td></tr><tr><td colspan="2" rowspan="1" style="width:206px;"> <p>hsetnx key <code>field value</code> [<code>field value</code>...]</p> </td><td colspan="1" rowspan="1" style="width:300px;"> <p>不存在才会新建成功</p> </td><td colspan="1" rowspan="1" style="width:183px;"> <p></p> </td></tr></tbody></table> 
<h4>GEO 操作指令</h4> 
<table><thead><tr><th colspan="1" rowspan="1" style="width:203px;"> <p><strong>指令</strong></p> </th><th colspan="1" rowspan="1" style="width:213px;"> <p><strong>作用</strong></p> </th><th colspan="1" rowspan="1" style="width:273px;"> <p>可选项说明及备注</p> </th></tr></thead><tbody><tr><td colspan="1" rowspan="1" style="width:203px;"> <p>geoadd key</p> <p></p> </td><td colspan="1" rowspan="1" style="width:213px;"> <p>添加经纬度坐标</p> </td><td colspan="1" rowspan="1" style="width:273px;"> <p>出现中文乱码，redis-cli启动时加个<code>--raw</code></p> </td></tr><tr><td colspan="1" rowspan="1" style="width:203px;"> <p>geopos</p> </td><td colspan="1" rowspan="1" style="width:213px;"> <p>从键里面返回所有给定元素的位置（经纬度）</p> </td><td colspan="1" rowspan="1" style="width:273px;"> <p></p> </td></tr><tr><td colspan="1" rowspan="1" style="width:203px;"> <p>geodist key <code>member1</code> <code>member2</code> [<code>m</code> | <code>km</code> | <code>ft</code> | <code>mi</code> ]</p> </td><td colspan="1" rowspan="1" style="width:213px;"> <p>返回给定位置之间的距离</p> <p>geodist不仅可以计算两个 member 之间的距离，还可以计算一个 member 与 key 中多个 member 之间的距离</p> <p>【示例】</p> 
    <ul><li>计算 member1 与 key 中 member2、member3、member4 三个 member 之间的距离:<br><code>geodist key member1 member2 member3 </code><code>member4</code> 
      <ul><li>geodist会返回一个浮点数，表示两个地理位置之间的距离，如果某个 member 不存在，会返回空值(NULL)。</li></ul></li></ul></td><td colspan="1" rowspan="1" style="width:273px;"> 
    <ul><li> <p><code>member1</code> <code>member2</code> 表示 GEO 类型中的两个 member</p> </li><li> <p><code>m</code> | <code>km</code> | <code>ft</code> | <code>mi</code> 表示计算距离的单位</p> <p>  如果没有单位参数，则默认使用米作为单位。</p> 
      <ul><li> <p><code>m</code>：米</p> </li><li> <p><code>km</code>：千米</p> </li><li> <p><code>mi</code>：英里</p> </li><li> <p><code>ft</code>：英尺</p> </li></ul></li></ul><p></p> </td></tr><tr><td colspan="1" rowspan="1" style="width:203px;"> <p></p> <p>georadius key <code>longitude</code> <code>latitude</code> <code>radius</code> <code>m|km|ft|mi</code> [<code>withdist</code>] [<code>withcoord</code>] [<code>withhash</code>] [<code>count num</code>] [<code>asc</code>|<code>desc</code>] [<code>store key</code>] [<code>storedist key</code>]</p> </td><td colspan="1" rowspan="1" style="width:213px;"> <p>以给定经纬度为中心，返回与中心距离离不超过给定最大距离的所有元素，且可以根据需求返回经纬度、距离等详细信息，并将查询结果保存到一个新的有序集合中。</p> <p></p> </td><td colspan="1" rowspan="1" style="width:273px;"> 
    <ul><li> <p><code>longitude</code>：表示中心点的经度</p> </li><li> <p><code>latitude</code>：表示中心点的纬度</p> </li><li> <p><code>radius</code>：表示半径大小，与单位配合使用</p> </li><li> <p><code>withdist</code>返回元素时，同时返回距离（米）</p> </li><li> <p><code>withcoord</code>返回元素时，同时返回经纬度</p> </li><li> <p><code>withhash</code> 经过geohash编码后的52位有符号整型</p> </li><li> <p><code>count num</code> 返回不超过num条记录</p> </li><li> <p><code>asc|desc</code>：表示返回结果时是否按照距离从近到远或从远到近排序，默认为从近到远</p> </li><li> <p><code>store key</code>：选项表示将返回结果存储到一个新的有序集合 <code>key</code> 中</p> </li><li> <p><code>storedist key</code>：选项表示将返回结果存储到一个新的有序集合 <code>key</code> 中，并把查询位置和目标位置间的距离作为值保留到集合中</p> </li></ul></td></tr><tr><td colspan="1" rowspan="1" style="width:203px;"> <p>georadiusbymember key member <code>radius</code> <code>m|km|ft|mi</code> [<code>withdist</code>] [<code>withcoord</code>] [<code>withhash</code>] [<code>count num</code>] [<code>asc</code>|<code>desc</code>] [<code>store key</code>] [<code>storedist key</code>]</p> </td><td colspan="1" rowspan="1" style="width:213px;"> <p>georadiusbymember各个参数的含义和作用与georadius命令的相应参数完全相同，唯一的不同是 georadiusbymember 使用的查询中心是指定的成员，而不是经纬度坐标。</p> </td><td colspan="1" rowspan="1" style="width:273px;"> <p></p> </td></tr><tr><td colspan="1" rowspan="1" style="width:203px;"> <p>geohash</p> </td><td colspan="1" rowspan="1" style="width:213px;"> <p>返回坐标的geohash表示</p> </td><td colspan="1" rowspan="1" style="width:273px;"> <p>geohash算法生成的base32编码值</p> </td></tr></tbody></table> 
<h4 id="HyperLogLog%20%E6%93%8D%E4%BD%9C%E6%8C%87%E4%BB%A4">HyperLogLog 操作指令</h4> 
<table><thead><tr><th colspan="1" rowspan="1"> <p><strong>指令</strong></p> </th><th colspan="1" rowspan="1"> <p><strong>作用</strong></p> </th><th colspan="1" rowspan="1"> <p>可选项说明及备注</p> </th></tr></thead><tbody><tr><td colspan="1" rowspan="1"> <p>pfadd key <code>element</code> [<code>element</code>]...</p> </td><td colspan="1" rowspan="1"> <p>添加指定的元素</p> </td><td colspan="1" rowspan="1"> <p></p> </td></tr><tr><td colspan="1" rowspan="1"> <p>pfcount key [key ...]</p> </td><td colspan="1" rowspan="1"> <p>返回给定的基数估计值</p> </td><td colspan="1" rowspan="1"> <p></p> </td></tr><tr><td colspan="1" rowspan="1"> <p>pfmerge <code>destkey</code> <code>sourcekey</code> [<code>sourcekey</code>...]</p> </td><td colspan="1" rowspan="1"> <p>合并统计</p> </td><td colspan="1" rowspan="1"> <p></p> </td></tr></tbody></table> 
<h4 id="Bitmap%20%E6%93%8D%E4%BD%9C%E6%8C%87%E4%BB%A4">Bitmap 操作指令</h4> 
<table><thead><tr><th colspan="1" rowspan="1"> <p><strong>指令</strong></p> </th><th colspan="1" rowspan="1" style="width:236px;"> <p><strong>作用</strong></p> </th><th colspan="1" rowspan="1" style="width:237px;"> <p>可选项说明及备注</p> </th><th colspan="1" rowspan="1"> <p>时间复杂度</p> </th></tr></thead><tbody><tr><td colspan="1" rowspan="1"> <p>setbit key <code>offset</code> <code>value</code></p> </td><td colspan="1" rowspan="1" style="width:236px;"> <p>为键为key的元素序号为<code>offset</code>的值设置值为<code>value</code></p> </td><td colspan="1" rowspan="1" style="width:237px;"> 
    <ul><li> <p><code>offset</code> 偏移量（从0开始）</p> </li><li> <p><code>value</code> 值</p> </li></ul></td><td colspan="1" rowspan="1"> <p>O(1)</p> </td></tr><tr><td colspan="1" rowspan="1"> <p>getbit key <code>offset</code></p> </td><td colspan="1" rowspan="1" style="width:236px;"> <p>获取指定key的第<code>offset</code>位</p> </td><td colspan="1" rowspan="1" style="width:237px;"> <p></p> </td><td colspan="1" rowspan="1"> <p>O(1)</p> </td></tr><tr><td colspan="1" rowspan="1"> <p>strlen key</p> </td><td colspan="1" rowspan="1" style="width:236px;"> <p>统计字节数占用多少（按字节）</p> </td><td colspan="1" rowspan="1" style="width:237px;"> <p></p> </td><td colspan="1" rowspan="1"> <p>O(1)</p> </td></tr><tr><td colspan="1" rowspan="1"> <p>bitcount key <code>start</code> <code>end</code></p> </td><td colspan="1" rowspan="1" style="width:236px;"> <p>返回指定范围[<code>start</code>, <code>end</code>]内值为1的数量</p> </td><td colspan="1" rowspan="1" style="width:237px;"> 
    <ul><li> <p><code>start</code> 开始序号</p> </li><li> <p><code>end</code> 结束序号</p> </li></ul></td><td colspan="1" rowspan="1"> <p>O(n)</p> </td></tr><tr><td colspan="1" rowspan="1"> <p>bitop <code>operation</code> <code>destkey</code> key</p> </td><td colspan="1" rowspan="1" style="width:236px;"> <p>对不同的二进制存储数据进行位运算（AND、OR、NOT、XOR）</p> </td><td colspan="1" rowspan="1" style="width:237px;"> 
    <ul><li> <p><code>operation</code> 包括AND、OR、NOT、XOR</p> </li><li> <p><code>destkey</code> 新产生的值的key</p> </li></ul></td><td colspan="1" rowspan="1"> <p>O(n)</p> </td></tr></tbody></table> 
<h4 id="Bitfield%20%E6%93%8D%E4%BD%9C%E6%8C%87%E4%BB%A4">Bitfield 操作指令</h4> 
<p>实际生产中几乎……%不怎么用，这里就不列举叻，还是想了解可查看官网</p> 
<p><a class="link-info" href="https://redis.io/commands/bitfield/" rel="nofollow" title="https://redis.io/commands/bitfield/">https://redis.io/commands/bitfield/</a></p> 
<h4 id="Stream%20%E6%93%8D%E4%BD%9C%E6%8C%87%E4%BB%A4%EF%BC%88%E9%99%84%E7%A4%BA%E4%BE%8B%EF%BC%89">Stream 操作指令（附示例）</h4> 
<p>特殊符号：</p> 
<ul><li> <p><code>-+</code> 最小和最大可能出现的ID</p> </li><li> <p><code>$</code>   表示读新到来的，即随着新消息的到来，$ 的指针会自动向前移动</p> </li><li> <p><code>&gt;</code>   表示从第一条尚未被消费的数据开始读起</p> </li><li> <p><code>*</code>   添加消息的ID自增</p> </li></ul> 
<table><thead><tr><th colspan="2" rowspan="1" style="width:204px;"> <p><strong>指令</strong></p> </th><th colspan="1" rowspan="1" style="width:202px;"> <p><strong>作用</strong></p> </th><th colspan="1" rowspan="1" style="width:283px;"> <p>可选项说明及备注</p> </th></tr></thead><tbody><tr><td colspan="1" rowspan="7" style="width:52px;"> <p>队列相关</p> </td><td colspan="1" rowspan="1" style="width:152px;"> <p>xadd key [<code>NOMKSTREAM</code>] [<code>MAXLEN | MINID [=|~] threshold [LIMIT count]</code>] <code>*</code>|<code>id</code> <code>field value</code> [<code>field value</code>...]</p> </td><td colspan="1" rowspan="1" style="width:202px;"> <p>添加消息到队列末尾，返回消息</p> 
    <ul><li> <p>ID 由两个由一个字符分隔的数字指定<code>-</code>：</p> </li><li> <p>1526919030474-55</p> </li><li> <p>两个数量都是 64 位整数。当自动生成 ID 时，第一部分是生成 ID 的 Redis 实例的 Unix 时间（以毫秒为单位）。第二部分只是一个序列号，用于区分在同一毫秒内生成的 ID。</p> </li><li> <p>消息ID必须比上个大</p> </li><li> <p>默认用星号表示自动生成规矩</p> 
      <ul><li> <p>用于xadd命令，让系统自动生成ID</p> </li></ul></li></ul><p></p> </td><td colspan="1" rowspan="1" style="width:283px;"> 
    <ul><li> <p><code>NOMKSTREAM</code> 当前面的key不存在时，Redis的Stream默认会先创建该key并添加元素，如果加上则会<code>NOMKSTREAM</code>返回<code>nil</code></p> </li><li> <p><code>MAXLEN|MINID [=|~] threshold [LIMIT count]</code>：可选参数，用来<u>控制 Stream 的长度或者指定 Stream 的最小 ID</u>。</p> 
      <ul><li> <p><code>MAXLEN N</code>：限制 Stream 的最大长度为 N。</p> </li><li> <p><code>MINID ID</code>：设置 Stream 的最小 ID 为 ID。</p> </li><li> <p><code>=|~</code>：这是一个可选的前缀，用于指定限制条件的类型。如果使用 <code>=</code>，表示限制条件为长度具体等于阈值 <code>threshold</code>；如果使用 <code>~</code>，表示限制条件为长度小于或等于阈值 <code>threshold</code></p> </li><li> <p><code>threshold</code>：指定的长度阈值。如果限制条件为 <code>~</code>，表示 Stream 最大长度将小于或等于 <code>threshold</code>，如果限制条件为 <code>=</code>，表示 Stream 的最大长度会被限制为 <code>threshold</code>。</p> </li><li> <p><code>LIMIT count</code>：可选参数，用于限制每次执行 XADD 命令时添加的条目数量，以防止一次性写入过多的数据。</p> </li></ul></li><li> <p><code>field value</code>：这是一个 XADD 命令的数据格式，包含每个条目的所有字段和值。每个字段和值都是一个 key-value 对。例如 <code>field1 value1 field2 value2...</code></p> </li></ul></td></tr><tr><td colspan="1" rowspan="1" style="width:152px;"> <p>xrange key <code>start</code> <code>end</code> <code>count</code></p> </td><td colspan="1" rowspan="1" style="width:202px;"> <p>用于获取消息列表（可以指定范围），从最旧的开始</p> <p>【示例】</p> 
    <ul><li>查询名为 mystream 的 Redis Stream的所有消息：<br><code>xrange mystream - +</code></li><li>查询名为 mystream 的 Redis Stream，在包括 ID 为 1000 的数据和 ID 为 2000 的数据的区间内，返回不多于10条数据：<br><code>xrange mystream 1000-2000 COUNT 10</code></li></ul><p></p> </td><td colspan="1" rowspan="1" style="width:283px;"> 
    <ul><li> <p><code>start</code>：查询起始位置。可以是 <code>-</code> 或者 <code>+</code> 加上一个具体的 ID</p> 
      <ul><li> <p><code>- 1000</code> 表示查询小于等于 1000 的所有消息</p> </li><li> <p><code>+</code> 则表示查询大于等于给定的 ID 的所有消息</p> </li></ul></li><li> <p><code>end</code>：查询结束位置。可以和 <code>start</code> 同时使用形成一个区间</p> 
      <ul><li> <p><code>- +</code> 表示查询所有消息</p> </li><li> <p><code>1000 2000</code> 表示查询大于等于 <code>1000</code> 和小于等于 <code>2000</code> 的所有消息</p> </li></ul></li><li> <p><code>count</code>：可以控制查询返回的结果数量，默认返回所有消息</p> 
      <ul><li> <p>如果给定一个正整数，表示返回的消息数量不大于该值</p> </li><li> <p>如果给定一个负数，表示返回的消息数量不小于该值</p> </li></ul></li></ul></td></tr><tr><td colspan="1" rowspan="1" style="width:152px;"> <p>xrevrange key <code>start</code> <code>end</code> <code>count</code></p> </td><td colspan="1" rowspan="1" style="width:202px;"> <p>用于查询 Redis Stream 中的消息，从最新的开始（ xread、xrange 命令的默认查询起始点是最旧的消息）</p> <p>【示例】</p> 
    <ul><li>查询最新的 10 条消息：<code>xrevrange mystream + - COUNT 10</code></li><li>查询 ID 大于等于 1000 的所有消息：<br><code>xrevrange mystream + 1000</code></li></ul><p></p> </td><td colspan="1" rowspan="1" style="width:283px;"> 
    <ul><li> <p>参数解释同xrange</p> </li></ul><p></p> </td></tr><tr><td colspan="1" rowspan="1" style="width:152px;"> <p>xdel key <code>ID</code> [<code>ID</code>...]</p> </td><td colspan="1" rowspan="1" style="width:202px;"> <p>删除一个或多个消息（需要注意的是 xdel 的操作一旦删除了消息就无法恢复）</p> </td><td colspan="1" rowspan="1" style="width:283px;"> 
    <ul><li> <p><code>ID</code>：需要删除的消息的 ID</p> 
      <ul><li> <p>可以是一个 ID，也可以是多个</p> </li></ul></li></ul></td></tr><tr><td colspan="1" rowspan="1" style="width:152px;"> <p>xlen key</p> </td><td colspan="1" rowspan="1" style="width:202px;"> <p>返回 Redis Stream 中的消息数量</p> </td><td colspan="1" rowspan="1" style="width:283px;"> <p>无论有多少数据，时间复杂度都是 O(1)</p> </td></tr><tr><td colspan="1" rowspan="1" style="width:152px;"> <p>xtrim key <code>MAXLEN | MINID [=|~] threshold</code> [<code>LIMIT count</code>]</p> </td><td colspan="1" rowspan="1" style="width:202px;"> <p>将 Redis Stream 中的消息按照指定的条件进行裁剪y（同xdel一样，删除了无法恢复）</p> <p>【示例】</p> 
    <ul><li> <p>保留 Redis Stream 中最后 100 条消息：<br> xtrim mystream MAXLEN 100</p> </li><li> <p>保留 Redis Stream 中消息 ID 大于 1586610271071-3 的消息：<br> xtrim mystream MINID 1586610271071-3</p> </li></ul></td><td colspan="1" rowspan="1" style="width:283px;"> 
    <ul><li> <p><code>MAXLEN | MINID [=|~] threshold</code> 裁剪策略</p> 
      <ul><li> <p><code>MAXLEN</code>，需要传递一个数字，表示需要保留的消息数量</p> </li><li> <p><code>MINID</code>，需要传递一个消息 ID，表示需要保留的消息的最小 ID 值</p> </li></ul></li><li> <p><code>LIMIT count</code> 控制查询返回的结果数量，默认返回所有消息</p> </li></ul></td></tr><tr><td colspan="1" rowspan="1" style="width:152px;"> <p>xread [<code>COUNT count</code>] [<code>BLOCK milliseconds</code>] <code>STREAMS</code> <code>key</code> [<code>key</code> ...] <code>ID</code> [<code>ID</code> ...]</p> <p></p> </td><td colspan="1" rowspan="1" style="width:202px;"> <p>从Redis Stream 中读取数据</p> <p>【示例】</p> 
    <ul><li> <p>读取 mystream 中最新的 10 条消息：<br> xread COUNT 10 STREAMS mystream $</p> </li><li> <p>读取 mystream 和 anotherstream 中最新的 20 条消息：<br> xread COUNT 20 STREAMS mystream $ anotherstream $</p> </li></ul><p></p> </td><td colspan="1" rowspan="1" style="width:283px;"> 
    <ul><li> <p><code>COUNT</code>：需要返回的消息数量，表示一次最多返回的消息数量</p> </li><li> <p><code>BLOCK</code>：是否以阻塞的方式读取消息，并设置阻塞超时时间，单位为毫秒</p> 
      <ul><li> <p>默认不阻塞，<code>milliseconds</code>如果设为0，则永远阻塞</p> </li><li> <p>当 Stream 中没有新消息时，xread 命令会等待阻塞超时时间后自动返回</p> </li></ul></li><li> <p><code>STREAMS</code>：需要读取的 Redis Stream 的名称和读取位置，可以多次使用该参数，每次读取一个 Stream。</p> 
      <ul><li> <p>Stream 名称：需要读取的 Redis Stream 数据结构的名称</p> </li><li> <p>Read ID：读取的起始位置，可以是消息 ID 或者特殊的符号，比如 <code>$</code> 和 <code>&gt;</code></p> </li></ul></li></ul></td></tr><tr><td colspan="1" rowspan="4" style="width:52px;"> <p>消费者相关</p> <p>（<u>同一个消费组中的不同消费者</u>不能消费同一个消息，但<u>不同消费组的消费者</u>可以，可以进行<u><strong>负载均衡</strong></u>）</p> </td><td colspan="1" rowspan="1" style="width:152px;"> <p>xgroup create key <code>groupname</code> <code>ID</code>|<code>$</code> [<code>MKSTREAM</code>]</p> </td><td colspan="1" rowspan="1" style="width:202px;"> <p>用于在 Redis Stream 中创建一个新的消费者组，并将指定消费者加入该组</p> <p>【示例】</p> 
    <ul><li> <p>创建一个名为 <code>mygroup</code> 的消费者组，并从最新的消息开始读取：xgroup create mystream mygroup $ MKSTREAM</p> </li><li> <p>创建一个名为 <code>mygroup</code> 的消费者组，并从消息 ID 为 <code>1586610271071-3</code> 的消息开始读取：<br> xgroup create mystream mygroup 1586610271071-3</p> </li></ul><p></p> </td><td colspan="1" rowspan="1" style="width:283px;"> 
    <ul><li> <p><code>group</code>：消费者组名称。</p> </li><li> <p><code>id</code>：消费者组的起始读取位置</p> 
      <ul><li> <p><code>$</code> 表示从最新的消息开始读取，也可以是某个具体的消息 ID</p> </li></ul></li><li> <p><code>...</code>：需要传递两个参数，将用于表示从 Stream 中读取消息时的选项，具体如下：</p> 
      <ul><li> <p><code>MKSTREAM</code>：如果 Stream 不存在，则创建一个新的 Stream</p> </li></ul></li></ul></td></tr><tr><td colspan="1" rowspan="1" style="width:152px;"> <p>xreadgroup group <code>group</code> <code>consumer</code> [<code>COUNT count</code>] [<code>BLOCK milliseconds</code>] [<code>NOACK</code>] <code>STREAMS</code> <code>key</code> [<code>key</code> ...] <code>ID</code> [<code>ID</code> ...]</p> </td><td colspan="1" rowspan="1" style="width:202px;"> <p>用于从 Redis Stream 中读取数据，并且将其发送给指定的消费者组</p> <p>【示例】</p> 
    <ul><li> <p>从消费者组 <code>mygroup</code> 中的 <code>myconsumer</code> 开始读取 mystream 中最新的 10 条消息：<br> xreadgroup GROUP mygroup myconsumer COUNT 10 STREAMS mystream &gt;</p> </li><li> <p>从消费者组 <code>mygroup</code> 中的 <code>myconsumer</code> 开始读取 mystream 和 anotherstream 中最新的 20 条消息：<br> xreadgroup GROUP mygroup myconsumer COUNT 20 STREAMS mystream &gt; anotherstream &gt;</p> </li></ul><p></p> </td><td colspan="1" rowspan="1" style="width:283px;"> 
    <ul><li> <p><code>group</code>：需要读取的消费者组的名称</p> </li><li> <p><code>consumer</code> 需要读取的消费者的名称</p> </li><li> <p><code>COUNT count</code>：需要返回的消息数量，表示一次最多返回的消息数量</p> </li><li> <p><code>BLOCK milliseconds</code> 设置阻塞超时时间，单位为毫秒（同xread）</p> </li><li> <p><code>NOACK</code>：在消费者组中设置 NOACK 后，当接收到一条消息后，Redis 会假设消息被消费并且不会在向消费者发送消息确认信息</p> </li><li> <p><code>STREAMS</code>：需要读取的 Redis Stream 数据结构的名称和读取位置，可以多次使用该参数，每次读取一个 Stream</p> 
      <ul><li> <p><code>key</code>：需要读取的 Redis Stream 数据结构的名称</p> </li><li> <p><code>ID</code>：读取的起始位置，可以是消息 ID 或者特殊的符号，比如 <code>$</code> 和 <code>&gt;</code></p> </li></ul></li></ul></td></tr><tr><td colspan="1" rowspan="1" style="width:152px;"> <p>xpending key <code>group</code> [[<code>IDLE min-idle-time</code>] <code>start</code> <code>end</code> <code>count</code> [<code>consumer</code>]]</p> <p></p> </td><td colspan="1" rowspan="1" style="width:202px;"> <p>于从消费者组中获取关于 Stream 的消费状态信息，包括<u>等待下一个确认的消息</u>、<u>还未分配给消费者的消息</u>和<u>已经被消费者处理但还未确认的消息</u></p> <p>【示例】</p> 
    <ul><li> <p>获取消费者组 <code>mygroup</code> 中所有消费者等待确认的消息数量（最多不超过10个）：<br> xpending mystream mygroup - + 10</p> </li><li> <p>获取消费者组 <code>mygroup</code> 中消费者 <code>myconsumer1</code> 还未确认的消息数量：<br> xpending mystream mygroup - + 10 myconsumer1</p> </li><li> <p>获取消费者组 <code>mygroup</code> 中最长未确认时间不超过 5 分钟的未确认消息：<br><code>xpending mystream mygroup - + 100 500000</code></p> 
      <ul><li> <p>其中，指定了 <code>-</code> 和 <code>+</code> 分别表示消息的起始 ID 和结束 ID，<code>100</code> 表示返回的最大消息数量，<code>500000</code> 表示最长未确认时间为 5 分钟</p> </li></ul></li></ul></td><td colspan="1" rowspan="1" style="width:283px;"> 
    <ul><li> <p><code>group</code> 消费者组名称</p> </li><li> <p><code>IDLE min-idle-time</code> 表示最长未确认时间，即在消费者组中存在未确认的消息时，距离这些消息上次被处理的时间超过了 <code>IDLE</code> 参数指定的时间，那么这些消息将被列入 xpending 返回的结果列表中，单位为毫秒</p> </li><li> <p><code>start</code> 消息的开始 ID</p> </li><li> <p><code>end</code> 消息的结束 ID</p> </li><li> <p><code>count</code> 需要返回的消息数量</p> </li><li> <p><code>consumer</code> 可选参数，指定返回特定消费者的未确认消息列表</p> </li></ul></td></tr><tr><td colspan="1" rowspan="1" style="width:152px;"> <p>xack key <code>group</code> <code>ID</code> [<code>ID</code> ...]</p> </td><td colspan="1" rowspan="1" style="width:202px;"> <p>用于向 Redis Stream 数据结构中添加消费者对消息的确认，即表示此消息已经被成功消费和处理</p> <p>【示例】</p> 
    <ul><li> <p>确认消费者组 <code>mygroup</code> 中消费者 <code>myconsumer1</code> 已消费并处理消息 <code>1535007665264-0</code>：<br> xack mystream mygroup 1535007665264-0 myconsumer1</p> </li><li> <p>确认消费者组 <code>mygroup</code> 中<u>所有消费者</u>已消费并处理消息 <code>1535007665264-1</code>：<br> xack mystream mygroup 1535007665264-1</p> </li></ul></td><td colspan="1" rowspan="1" style="width:283px;"> 
    <ul><li> <p><code>group</code>：消费者组名称</p> </li><li> <p><code>ID</code>：需要确认的消息 ID（一个或多个）</p> </li></ul></td></tr><tr><td colspan="2" rowspan="1" style="width:204px;"> <p>xinfo [<code>consumers key groupname</code>] [<code>groups key</code>] [<code>stream key</code>] [<code>help</code>]</p> <p></p> </td><td colspan="1" rowspan="1" style="width:202px;"> <p>用于打印Stream/Consumer/Group的详细信息，便于监控和调试</p> <p>【示例】</p> 
    <ul><li> <p>获取流 <code>mystream</code> 的信息：<br> xinfo stream mystream</p> </li><li> <p>获取消费者组 <code>mygroup</code> 的信息：<br> xinfo groups mystream mygroup</p> </li><li> <p>获取消费者组 <code>mygroup</code> 中所有消费者的信息：<br> xinfo consumers mystream mygroup</p> </li><li> <p>获取消费者组 <code>mygroup</code> 中消费者 <code>myconsumer1</code> 的信息：<br> xinfo consumers mystream mygroup myconsumer1</p> </li></ul><p></p> </td><td colspan="1" rowspan="1" style="width:283px;"> 
    <ul><li> <p><code>groups</code>：获取指定 Stream 中所有消费者组的信息，包括每个组的名称、拥有者及各组消费的消息的数量和时间戳最小值等信息</p> </li><li> <p><code>consumers</code>：获取指定 Stream 和消费者组中所有消费者的信息，包括每个消费者的名称、未确认消息数量及它们所消费的消息列表等信息</p> </li><li> <p><code>stream</code>：获取指定 Stream 中的信息，包括流的长度、最小ID和最大ID等信息</p> </li><li> <p><code>groups &lt;key&gt;</code>：获取指定 Stream 中消费者组的信息，包括每个组的名称、拥有者及各组消费的消息的数量和时间戳最小值等信息</p> </li><li> <p><code>consumers &lt;key&gt; &lt;group&gt;</code>：获取指定流和消费者组中所有消费者的信息，包括每个消费者的名称、未确认消息数量及它们所消费的消息列表等信息。其中 <code>&lt;key&gt;</code> 表示流的名称，<code>&lt;group&gt;</code> 表示消费者组的名称</p> </li><li> <p><code>help</code>：帮助文档</p> </li></ul></td></tr></tbody></table> 
<p>搞定～撒个花(｡･ω･｡)ﾉ🎉🎉🎉</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/9ed352271b200b963ed36488f739387a/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">根据Java实体生成建表SQL(2.0版本)</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/d0047a7b5585ba9f14a5c97ef667234e/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">众多高校和研究机构联合发表：LLMs评估综述</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>