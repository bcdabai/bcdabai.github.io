<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>可扩展架构的方法论——AKF扩展立方体 - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="可扩展架构的方法论——AKF扩展立方体" />
<meta property="og:description" content=" AKF扩展立方体（Scalability Cube），是《架构即未来》一书中提出的可扩展模型，这个立方体有三个轴线，每个轴线描述扩展性的一个维度，他们分别是产品、流程和团队： X轴 —— 代表无差别的克隆服务和数据，工作可以很均匀的分散在不同的服务实例上； Y轴 —— 关注应用中职责的划分，比如数据类型，交易执行类型的划分； Z轴 —— 关注服务和数据的优先级划分，如分地域划分。 三个维度扩展的对比 通过这三个维度上的扩展，可以快速提高产品的扩展能力，适应不同场景下产品的快速增长。不同维度上的扩展，有着不同的优缺点：
X轴扩展
优点：成本最低，实施简单； 缺点：受指令集多少和数据集大小的约束。当单个产品或应用过大时，服务响应变慢，无法通过X轴的水平扩展提高速度； 场景：发展初期，业务复杂度低，需要增加系统容量。 Y轴扩展
优点：可以解决指令集和数据集的约束，解决代码复杂度问题，可以实现隔离故障，可以提高响应时间，可以使团队聚焦更利于团队成长； 缺点：成本相对较高； 场景：业务复杂，数据量大，代码耦合度高，团队规模大。 Z轴扩展
优点：能解决数据集的约束，降低故障风险，实现渐进交付，可以带来最大的扩展性。 缺点：成本最昂贵，且不一定能解决指令集的问题； 场景：用户指数级快速增长。 如何将理论付诸实践？ 为扩展分割应用
X轴：从单体系统或服务，水平克隆出许多系统，通过负载均衡平均分配请求； Y轴 ：面向服务分割，基于功能或者服务分割，例如电商网站可以将登陆、搜索、下单等服务进行Y轴的拆分，每一组服务再进行X轴的扩展； Z轴 ：面向查找分割，基于用户、请求或者数据分割，例如可以将不同产品的SKU分到不同的搜索服务，可以将用户哈希到不同的服务等。 为扩展分割数据库
X轴：从单库，水平克隆为多个库上读，一个库写，通过数据库的自我复制实现，要允许一定的读写时延； Y轴 ：根据不同的信息类型，分割为不同的数据库，即分库，例如产品库，用户库等； Z轴 ：按照一定算法，进行分片，例如将搜索按照MapReduce的原理进行分片，把SKU的数据按照不同的哈希值进行分片存储，每个分片再进行X轴冗余。 为扩展而缓存
在理想情况下，处理大流量最好的方法是通过高速缓存来避免处理它。从架构层面看，我们能控制的主要有以下三个层次的缓存： 对象缓存：对象缓存用来存储应用的对象以供重复使用，一般在系统内部，通过使用应用缓存可以帮助数据库和应用层卸载负载。 应用缓存：应用缓存包括代理缓存和反向代理缓存，一个在用户端，一个在服务端，目标是提高性能或减少资源的使用量。 内容交付网络缓存：CDN的总原则是将内容推送到尽可能接近用户终端的地方，通过不同地区使用不同ISP的网关缓存，达到更快的响应时间和对源服务的更少请求。 位扩展而异步
同步改异步：同步调用，由于调用间的同步依赖关系，有可能会导致雪崩效应，出现一系列的连锁故障，进而导致整个系统出现问题，所以在进行系统设计时，要尽可能的考虑异步调用方式，邮件系统就是一个非常好的异步调用例子。 应用无状态：当进行AKF扩展立方体的任何一个轴上的扩展时，都要首先解决应用的状态问题，即会话的管理，可以通过避免、集中和分散的方式进行解决。 AKF扩展立方体是一套通用的扩展性理论，它不仅可以应用到系统的架构扩展上，也可以应用到人员的组织架构扩展上甚至其他相关的工业领域。 当然并不是所有公司都需要同时在XYZ三个方向上进行扩展，并且每个方向上的扩展都有它的利弊，我们不可避免的要进行适当的权衡。最重要的，我们应当首先理解这套理论背后所体现出来的扩展哲学。 就像书里所描述的，这不仅涉及到科学，还涉及到艺术！ " />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/ce010a7e26ce4545bbece407d6a70fe4/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2019-11-09T12:06:07+08:00" />
<meta property="article:modified_time" content="2019-11-09T12:06:07+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">可扩展架构的方法论——AKF扩展立方体</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-tomorrow-night">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <pre><code>AKF扩展立方体（Scalability Cube），是《架构即未来》一书中提出的可扩展模型，这个立方体有三个轴线，每个轴线描述扩展性的一个维度，他们分别是产品、流程和团队：

X轴 —— 代表无差别的克隆服务和数据，工作可以很均匀的分散在不同的服务实例上；

Y轴 —— 关注应用中职责的划分，比如数据类型，交易执行类型的划分；

Z轴 —— 关注服务和数据的优先级划分，如分地域划分。
</code></pre> 
<p><img src="https://images2.imgbox.com/3f/2f/n6LE5j8t_o.png" alt="在这里插入图片描述"></p> 
<hr> 
<h2><a id="_13"></a>三个维度扩展的对比</h2> 
<p>通过这三个维度上的扩展，可以快速提高产品的扩展能力，适应不同场景下产品的快速增长。不同维度上的扩展，有着不同的优缺点：</p> 
<ul><li> <p>X轴扩展</p> <pre><code> 优点：成本最低，实施简单；

 缺点：受指令集多少和数据集大小的约束。当单个产品或应用过大时，服务响应变慢，无法通过X轴的水平扩展提高速度；

 场景：发展初期，业务复杂度低，需要增加系统容量。
</code></pre> </li><li> <p>Y轴扩展</p> <pre><code> 优点：可以解决指令集和数据集的约束，解决代码复杂度问题，可以实现隔离故障，可以提高响应时间，可以使团队聚焦更利于团队成长；

 缺点：成本相对较高；

 场景：业务复杂，数据量大，代码耦合度高，团队规模大。
</code></pre> </li><li> <p>Z轴扩展</p> <pre><code> 优点：能解决数据集的约束，降低故障风险，实现渐进交付，可以带来最大的扩展性。

 缺点：成本最昂贵，且不一定能解决指令集的问题；

 场景：用户指数级快速增长。
</code></pre> </li></ul> 
<h2><a id="_41"></a>如何将理论付诸实践？</h2> 
<ul><li> <p>为扩展分割应用</p> <pre><code> X轴：从单体系统或服务，水平克隆出许多系统，通过负载均衡平均分配请求；

 Y轴 ：面向服务分割，基于功能或者服务分割，例如电商网站可以将登陆、搜索、下单等服务进行Y轴的拆分，每一组服务再进行X轴的扩展；

 Z轴 ：面向查找分割，基于用户、请求或者数据分割，例如可以将不同产品的SKU分到不同的搜索服务，可以将用户哈希到不同的服务等。
</code></pre> </li><li> <p>为扩展分割数据库</p> <pre><code> X轴：从单库，水平克隆为多个库上读，一个库写，通过数据库的自我复制实现，要允许一定的读写时延；

 Y轴 ：根据不同的信息类型，分割为不同的数据库，即分库，例如产品库，用户库等；

 Z轴 ：按照一定算法，进行分片，例如将搜索按照MapReduce的原理进行分片，把SKU的数据按照不同的哈希值进行分片存储，每个分片再进行X轴冗余。
</code></pre> </li><li> <p>为扩展而缓存</p> <pre><code> 在理想情况下，处理大流量最好的方法是通过高速缓存来避免处理它。从架构层面看，我们能控制的主要有以下三个层次的缓存：
 
 对象缓存：对象缓存用来存储应用的对象以供重复使用，一般在系统内部，通过使用应用缓存可以帮助数据库和应用层卸载负载。
 
 应用缓存：应用缓存包括代理缓存和反向代理缓存，一个在用户端，一个在服务端，目标是提高性能或减少资源的使用量。
 
 内容交付网络缓存：CDN的总原则是将内容推送到尽可能接近用户终端的地方，通过不同地区使用不同ISP的网关缓存，达到更快的响应时间和对源服务的更少请求。
</code></pre> </li><li> <p>位扩展而异步</p> <pre><code> 同步改异步：同步调用，由于调用间的同步依赖关系，有可能会导致雪崩效应，出现一系列的连锁故障，进而导致整个系统出现问题，所以在进行系统设计时，要尽可能的考虑异步调用方式，邮件系统就是一个非常好的异步调用例子。
 
 应用无状态：当进行AKF扩展立方体的任何一个轴上的扩展时，都要首先解决应用的状态问题，即会话的管理，可以通过避免、集中和分散的方式进行解决。
 
 AKF扩展立方体是一套通用的扩展性理论，它不仅可以应用到系统的架构扩展上，也可以应用到人员的组织架构扩展上甚至其他相关的工业领域。

 当然并不是所有公司都需要同时在XYZ三个方向上进行扩展，并且每个方向上的扩展都有它的利弊，我们不可避免的要进行适当的权衡。最重要的，我们应当首先理解这套理论背后所体现出来的扩展哲学。

 就像书里所描述的，这不仅涉及到科学，还涉及到艺术！
</code></pre> </li></ul>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/becc8501c3063d7c7d72dc79c54e7dfd/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">死磕 java线程系列之ForkJoinPool深入解析</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/4234b70cbc07ea15ef8a234cb9dd6ae6/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">Promise构造函数的Promise.resolve()方法</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>