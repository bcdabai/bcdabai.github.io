<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>TypeScript从0到1 - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="TypeScript从0到1" />
<meta property="og:description" content="什么是typescript？ 中文官网地址：点击
typescipt的优势 一个第特性叫做类型检测
在打字稿里面的英文运行为变量指定类型的，比如当你为这个变量指定数字类型的值的时候，IDE会做出类型检查，
然后告诉你这里可能会有错误，这个特性会减少你在开发阶段犯错误的几率。
第二个特性是语法提示
在IDE里面去编写打字稿的代码时，IDE会根据你当前的上下文，把你能用的类，变量，方法和关键字都给你提示出来，
你只要直接去选就可以了，这个特性会大大提升你的开发效率
第三个特性是重构
重构是说你可以很方便的去修改你的变量或者方法的名字或者是文件的名字，当你做出这些修改的时候，IDE会帮你自动引用这个变量或者调用这个方法地方的代码自动帮你修改掉，这个特性一个是会提高你的开发效率，另一个是可以很容易的提升你的代码质量
在线编译器：http：
//www.typescriptlang.org/play/ 字符串特性 1.自动换行，需要``包裹的字符串，（键盘输入服切入到中文，用esc下面那个键可以打出来）
2。字符串模版，在字符串中替换，展位符号为$ {xx变量或者函数}
参数特性 参数类型：即在参数名字后面通过冒号来指定参数的类型
从图片上可以看出，指定类型后，其他类型赋于这个变量，编译器直接飙红了
打字稿的类型推断机制：如果没有显式声明变量的类型，那么第一次赋值的类型就是这个变量的类型，那么第二次在赋于其他类型的值，编译器将报错
如果又需要这个变量是整数类型又需要这个数的类型是字符串类型，这就变成了类型不固定，那么就需要用到任何这个关键字
在函数中的类型：
参数默认值：
在参数后面用等号来指定参数的默认值
运行结果：
可选参数：
在方法的参数声明后面用问号来标明此参数为可选参数
运行结果:
方法可变参数
语法: ...参数名称
内部解析为一个数组
运行结果:
展开 展开操作符正与解构相反。 它允许你将一个数组展开为另一个数组，或将一个对象展开为另一个对象。 例如：
let first = [1, 2]; let second = [3, 4]; let bothPlus = [0, ...first, ...second, 5]; 这会令bothPlus的值为[0, 1, 2, 3, 4, 5]。 展开操作创建了 first和second的一份浅拷贝。 它们不会被展开操作所改变。
generator函数:
控制函数的执行过程,手工暂停和恢复代码执行
function* say(name: string): void { console." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/b0391b81ba3af966869d697f1c8017c2/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2018-10-22T17:05:32+08:00" />
<meta property="article:modified_time" content="2018-10-22T17:05:32+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">TypeScript从0到1</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <h4>什么是typescript？</h4> 
<p><img alt="" class="has" height="362" src="https://images2.imgbox.com/f1/cf/P7mzcz1c_o.png" width="600"></p> 
<p>中文官网地址：<a href="https://www.tslang.cn/" rel="nofollow">点击</a></p> 
<h4>typescipt的优势</h4> 
<p>一个第特性叫做类型检测<br> 在打字稿里面的英文运行为变量指定类型的，比如当你为这个变量指定数字类型的值的时候，IDE会做出类型检查，<br> 然后告诉你这里可能会有错误，这个特性会减少你在开发阶段犯错误的几率。</p> 
<p> </p> 
<p>第二个特性是语法提示</p> 
<p>在IDE里面去编写打字稿的代码时，IDE会根据你当前的上下文，把你能用的类，变量，方法和关键字都给你提示出来，<br> 你只要直接去选就可以了，这个特性会大大提升你的开发效率</p> 
<p> </p> 
<p>第三个特性是重构</p> 
<p>重构是说你可以很方便的去修改你的变量或者方法的名字或者是文件的名字，当你做出这些修改的时候，IDE会帮你自动引用这个变量或者调用这个方法地方的代码自动帮你修改掉，这个特性一个是会提高你的开发效率，另一个是可以很容易的提升你的代码质量</p> 
<h4>在线编译器：<a href="http://www.typescriptlang.org/play/" rel="nofollow">http</a>：<br><a href="http://www.typescriptlang.org/play/" rel="nofollow">//www.typescriptlang.org/play/</a></h4> 
<p> </p> 
<h4>字符串特性</h4> 
<p><br> 1.自动换行，需要``包裹的字符串，（键盘输入服切入到中文，用esc下面那个键可以打出来）<br> 2。字符串模版，在字符串中替换，展位符号为$ {xx变量或者函数}</p> 
<p><img alt="" class="has" height="253" src="https://images2.imgbox.com/74/6f/9fw0AYwn_o.png" width="1000"></p> 
<h4>参数特性</h4> 
<p>参数类型：即在参数名字后面通过冒号来指定参数的类型<br><img alt="" class="has" height="253" src="https://images2.imgbox.com/5f/86/TJiLExCY_o.png" width="600"></p> 
<p>从图片上可以看出，指定类型后，其他类型赋于这个变量，编译器直接飙红了</p> 
<p>打字稿的类型推断机制：如果没有显式声明变量的类型，那么第一次赋值的类型就是这个变量的类型，那么第二次在赋于其他类型的值，编译器将报错</p> 
<p><img alt="" class="has" height="269" src="https://images2.imgbox.com/dd/09/3GnwLvUA_o.png" width="800"></p> 
<p> </p> 
<p>如果又需要这个变量是整数类型又需要这个数的类型是字符串类型，这就变成了类型不固定，那么就需要用到任何这个关键字</p> 
<p><img alt="" class="has" height="223" src="https://images2.imgbox.com/c9/3d/tojhldsc_o.png" width="800"></p> 
<p>在函数中的类型：<br><img alt="" class="has" height="238" src="https://images2.imgbox.com/33/1d/knooydNX_o.png" width="1000"></p> 
<p>参数默认值：<br> 在参数后面用等号来指定参数的默认值</p> 
<p><img alt="" class="has" height="246" src="https://images2.imgbox.com/76/11/LFORwMH7_o.png" width="1000"></p> 
<p>运行结果：<br><img alt="" class="has" height="201" src="https://images2.imgbox.com/4b/d5/MQlAorZk_o.png" width="600"></p> 
<p>可选参数：<br> 在方法的参数声明后面用问号来标明此参数为可选参数</p> 
<p><img alt="" class="has" height="354" src="https://images2.imgbox.com/8f/46/Gz58NXe9_o.png" width="900"></p> 
<p>运行结果:<br><img alt="" class="has" height="302" src="https://images2.imgbox.com/ac/19/So6Fv8nQ_o.png" width="600"></p> 
<p>方法可变参数<br> 语法: ...参数名称</p> 
<p>内部解析为一个数组</p> 
<p><img alt="" class="has" height="270" src="https://images2.imgbox.com/7b/79/HQwrz5j8_o.png" width="1000"></p> 
<p>运行结果:<br><img alt="" class="has" height="263" src="https://images2.imgbox.com/c5/64/UjPjXffg_o.png" width="600"></p> 
<h3>展开</h3> 
<p>展开操作符正与解构相反。 它允许你将一个数组展开为另一个数组，或将一个对象展开为另一个对象。 例如：</p> 
<pre class="has"><code>let first = [1, 2];
let second = [3, 4];
let bothPlus = [0, ...first, ...second, 5];
</code></pre> 
<p>这会令<code>bothPlus</code>的值为<code>[0, 1, 2, 3, 4, 5]</code>。 展开操作创建了 <code>first</code>和<code>second</code>的一份浅拷贝。 它们不会被展开操作所改变。</p> 
<p> </p> 
<p>generator函数:<br> 控制函数的执行过程,手工暂停和恢复代码执行</p> 
<pre class="has"><code class="language-javascript">function* say(name: string): void
{
    console.log(`name:${name}`);
    yield;
    console.log('finish');
}
let sayf = say('hello');//无任何输出
sayf.next();//输出 name:hello
console.log('test');
sayf.next();//输出finish</code></pre> 
<p>运行结果:<br><img alt="" class="has" height="280" src="https://images2.imgbox.com/1d/c7/vMcpnyLd_o.png" width="600"></p> 
<p>析构表达式:<br> 通过表达式将对象或者数组拆任意数量的变量<br>  </p> 
<pre class="has"><code class="language-javascript">function getDesc()
{
    return {
        name: `小明`,
        age:22,
    }
}
let { name } = getDesc();
console.log(`name ${name}`);</code></pre> 
<p>运行结果:<br><img alt="" class="has" height="425" src="https://images2.imgbox.com/6b/0b/vuZuEQ86_o.png" width="600"></p> 
<p>如果名称不一样就会找不到,可以通过一种别名的方式,找到这个变量的值</p> 
<pre class="has"><code class="language-javascript">function getDesc()
{
    return {
        name: `小明`,
        age:22,
    }
}
let { name } = getDesc();
console.log(`name ${name}`);

let { name:namex } = getDesc();//将name赋值给namex
console.log(`namex ${namex}`);</code></pre> 
<p>运行效果:<br><img alt="" class="has" height="252" src="https://images2.imgbox.com/45/f3/VzYUqeAd_o.png" width="400"></p> 
<p>析构表达式从数组中取数据:</p> 
<p>区别于对象中取数据是用{},而数组中取数据使用[]</p> 
<pre class="has"><code class="language-javascript">let aa = [3, 1, 4, 5];
let [num1, num2] = aa;
console.log(`num1:${num1} num2:${num2}`);</code></pre> 
<p>运行结果:<br><img alt="" class="has" height="303" src="https://images2.imgbox.com/c4/7b/TiDdc8w4_o.png" width="500"></p> 
<p>可以看出是数组是按位置取的,那么我们要取第三个和第三个怎么办呢？</p> 
<pre class="has"><code class="language-javascript">let aa = [3, 1, 4, 5];
let [num1, num2] = aa;
console.log(`num1:${num1} num2:${num2}`);

let [, , num3, num4] = aa;//拿第三个和第四个
console.log(`num3:${num3} num4:${num4}`);</code></pre> 
<p>运行结果:<br><img alt="" class="has" height="455" src="https://images2.imgbox.com/ad/14/oKJ7LZYe_o.png" width="600"></p> 
<p>用一个数组来接收:</p> 
<pre class="has"><code class="language-javascript">let aa = [3, 1, 4, 5];
let [num1, num2] = aa;
console.log(`num1:${num1} num2:${num2}`);

let [, , num3, num4] = aa;//拿第三个和第四个
console.log(`num3:${num3} num4:${num4}`);

let [, , ...others] = aa;//拿第三个和第四个
console.log(`others:${others}`);</code></pre> 
<p>运行结果:<br><img alt="" class="has" height="416" src="https://images2.imgbox.com/da/49/U3BMEcyV_o.png" width="600"></p> 
<p>箭头表达式:<br> 用来声明匿名函数,消除传统匿名函数的this指针问题</p> 
<p><img alt="" class="has" height="183" src="https://images2.imgbox.com/f1/67/OFJ5yid9_o.png" width="1000"></p> 
<p><img alt="" class="has" height="171" src="https://images2.imgbox.com/ac/57/C7Yw7JXY_o.png" width="1000"><br><img alt="" class="has" height="402" src="https://images2.imgbox.com/9b/d3/iaH8ePV3_o.png" width="1000"></p> 
<p>箭头表达式:可以消除传统匿名函数的this指针问题</p> 
<h4>typescipt的循环语法:</h4> 
<p>forEach() for in和for of</p> 
<pre class="has"><code class="language-javascript">let arr = [`小明`, `小丽`, `小王`];
arr.forEach(a =&gt; console.log(a));</code></pre> 
<p><img alt="" class="has" height="288" src="https://images2.imgbox.com/86/9b/aNeOAIMy_o.png" width="600"></p> 
<p>forEach缺点: 不支持break;</p> 
<p>forin循环:<br>  </p> 
<pre class="has"><code class="language-javascript">let arr = [`小明`, `小丽`, `小王`];
//arr.forEach(a =&gt; console.log(a));
for (let a in arr)
{
    console.log(`a=${arr[a]}`);
}</code></pre> 
<p>执行结果:<br><img alt="" class="has" height="216" src="https://images2.imgbox.com/a7/ba/H47YOfOw_o.png" width="400"></p> 
<p>for of循环:<br>  </p> 
<pre class="has"><code class="language-javascript">let arr = [`小明`, `小丽`, `小王`];
//arr.forEach(a =&gt; console.log(a));
for (let a of arr)
{
    console.log(`a11==${a}`);
}</code></pre> 
<p>运行结果:</p> 
<p><img alt="" class="has" height="167" src="https://images2.imgbox.com/f2/35/OkxeukNz_o.png" width="300"></p> 
<pre class="has"><code class="language-javascript">
for (let s of 'hello')
{
    console.log(`s==${s}`);
}</code></pre> 
<p><img alt="" class="has" height="225" src="https://images2.imgbox.com/41/88/Nk0CRr5v_o.png" width="300"></p> 
<h3>typescript面向对象</h3> 
<p>typescipt类和字段的修饰符:public private 和protected;其作用和其他语言类似</p> 
<pre class="has"><code class="language-javascript">class Person
{
    public name: string;//默认就是public,其他修饰符:private,protected

    //方法默认也是public
    public eat(): void { 
        console.log(`${this.name} eating`);
    }
}

let p = new Person();
p.name = `小王`;
p.eat();

let p2 = new Person();
p2.name = `小李`;
p2.eat();</code></pre> 
<p>运行结果:<br><img alt="" class="has" height="242" src="https://images2.imgbox.com/e6/64/DYrrL2XG_o.png" width="500"></p> 
<p>带构造函数的类:</p> 
<pre class="has"><code class="language-javascript">class Person
{
    public name: string;//默认就是public,其他修饰符:private,protected

    constructor(name: string){
        this.name = name;
    }
    //方法默认也是public
    public eat(): void { 
        console.log(`${this.name} eating`);
    }

}

let p = new Person(`小王1`);
p.eat();

let p2 = new Person(`小李2`);
p2.eat();</code></pre> 
<p>运行结果:<br><img alt="" class="has" height="293" src="https://images2.imgbox.com/a7/37/lmx9j4xL_o.png" width="400"></p> 
<h4>类的继承</h4> 
<p><br> extends关键字,super调用父类的方法</p> 
<pre class="has"><code class="language-javascript">class Person
{
    public name: string;//默认就是public,其他修饰符:private,protected

    constructor(name: string){
        this.name = name;
    }
    //方法默认也是public
    public eat(): void { 
        console.log(`${this.name} eating`);
    }

}

class Man extends Person{

    private isMan: boolean;
    constructor(name: string, isMan: boolean) {
        super(name);
        this.isMan = isMan;
    }
    eat(){
        console.log(`我是${this.name},我是${this.isMan ? `男人` : `女人`}`);
    }
}
let p = new Person(`小王3`);
p.eat();

let p2 = new Man(`小李3`,true);
p2.eat();

let p3 = new Man(`小丽3`,false);
p3.eat();</code></pre> 
<p>运行结果:</p> 
<p><br><img alt="" class="has" height="222" src="https://images2.imgbox.com/3f/8a/2VEBVVp7_o.png" width="400"></p> 
<h4>特殊用法:<br> 方法参数作为成员变量<br>  </h4> 
<pre class="has"><code class="language-javascript">class Pereron{
    constructor(public name: string)//相比与普通构造方法参数增加一个修饰符,比如public
    {

    }
    say(): void{
        console.log(`${this.name} saying`);  
    }
}
let p = new Pereron('小丽');
p.say();</code></pre> 
<h4><img alt="" class="has" height="240" src="https://images2.imgbox.com/32/3a/pu3AsY6Q_o.png" width="400"></h4> 
<p> </p> 
<h4> </h4> 
<h4>typescript的范型</h4> 
<p>&lt;类型&gt; 尖括号语法<br>  </p> 
<p><img alt="" class="has" height="256" src="https://images2.imgbox.com/a0/dc/L10sbvBf_o.png" width="800"></p> 
<h4>接口</h4> 
<p>接口是建立某种代码约定,使得其他开发者在调用某个方法或者创建类时必须遵循接口所定义的代码约定<br> 作为方法参数类型声明:<br>  </p> 
<pre class="has"><code class="language-javascript">interface IUser
{
    name: string;
    age: number;
}
class User{
    constructor(public config: IUser)
    {

    }
    say(): void{
        console.log(`name=${this.config.name} age=${this.config.age}`);
    }
}

let user = new User({ name: `张三`, age: 12 });
user.say();
</code></pre> 
<p>运行结果:<br><img alt="" class="has" height="321" src="https://images2.imgbox.com/fa/6e/O1CYz3Im_o.png" width="400"></p> 
<p>接口约定行为(方法)</p> 
<pre class="has"><code class="language-javascript">interface Animal
{
    eat():void;
}

class Dog implements Animal
{
    eat(): void
    {
        console.log(`我吃狗粮`);
    }
}

class Cat implements Animal
{
    eat(): void{
        console.log(`我吃猫粮`);
    }
}

let dog = new Dog();
dog.eat();

let cat = new Cat();
cat.eat();</code></pre> 
<p>运行结果:<br><img alt="" class="has" height="333" src="https://images2.imgbox.com/ca/ed/UgynUPAJ_o.png" width="400"></p> 
<p>类型定义文件(*.d.ts)</p> 
<p>类型定义文件用来帮助开发者在TypeScript中使用已有的JavaScript的工具包,如：JQuery</p> 
<p>.d.ts文件 一般会暴漏一个$xx变量,提供给外部调用,可以使用的 $('xxx").xxFunction();</p> 
<p>TypeScript范型：</p> 
<pre class="has"><code class="language-javascript">function add&lt;T&gt;(arg: T):T
{
    return arg;
}</code></pre> 
<p> </p> 
<pre class="has"><code class="language-javascript">function add&lt;T&gt;(arg: T):T
{
    return arg;
}
let res = add(9);//正确
let res2 = add&lt;String&gt;(9);//报错
let res3 = add&lt;String&gt;(`9`);//正确
</code></pre> 
<pre class="has"><code class="language-javascript">function getData&lt;T&gt;(args: Array&lt;T&gt;): Array&lt;T&gt;
{
    return args;
}
let arrs = getData&lt;string&gt;([`1`, `2`, `3`, `4`]);</code></pre> 
<p>在范型里使用类类型<br> 在typeScript使用范型创建工厂函数,需要引用构造函数的类类型.比如:</p> 
<pre class="has"><code class="language-javascript">function create&lt;T&gt;(c: {new():T}):T {
    return new c();
}</code></pre> 
<p>一个更高级的例子，使用原型属性推断并约束构造函数与类实例的关系</p> 
<pre class="has"><code class="language-javascript">class BeeKeeper {
    hasMask: boolean;
}

class ZooKeeper {
    nametag: string;
}

class Animal {
    numLegs: number;
}

class Bee extends Animal {
    keeper: BeeKeeper;
}

class Lion extends Animal {
    keeper: ZooKeeper;
}

function createInstance&lt;A extends Animal&gt;(c: new () =&gt; A): A {
    return new c();
}

createInstance(Lion).keeper.nametag;  // typechecks!
createInstance(Bee).keeper.hasMask;   // typechecks!</code></pre> 
<p>枚举<br> typescript支持数字和基于字符串的枚举</p> 
<pre class="has"><code class="language-javascript">enum Direction1 {
    LEFT,
    RIGHT,
}
let res1 = Direction1.RIGHT;//输出为1,默认数字枚举,从0开始
console.log(`res1:${res1}`);

enum Direction2
{
    LEFT = 1,
    RIGHT,
}

let res2 = Direction2.RIGHT;//输出为2,默认指定数字枚举,并且初始值为1
console.log(`res2:${res2}`);

enum Direction3
{
    LEFT = `left`,
    RIGHT = `right`,
}
let res3 = Direction3.RIGHT;
console.log(`res3:${res3}`);</code></pre> 
<p> </p> 
<p> </p> 
<p> </p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/512553447efdc957c07cfb97129fefec/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">Go 获取10分钟前的时间，一天前的时间。。。</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/ac60997b121f4c7c148b90476406ee70/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">Read the docs 环境搭建</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>