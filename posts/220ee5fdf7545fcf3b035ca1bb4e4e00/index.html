<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>排序算法——冒泡排序系列及性能测试 - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="排序算法——冒泡排序系列及性能测试" />
<meta property="og:description" content="文章目录 初识冒泡排序优化思路思路一思路二 性能测试加餐（鸡尾酒排序） 初识冒泡排序 排序算法常常作为学习算法的入门实践，而冒泡排序又是其中最简单的一种，我们今天的主题就是冒泡排序。它的基本思想就像鱼吐泡泡一样简单。
想象有一条鱼在数组的最底端，每一轮，它就吐个泡泡，泡泡会从数组一端漂到另一端，在漂浮过程中，泡泡会捕获数组中待排序的部分中最大的元素，将其移动到最顶端，然后把这个元素从数组待排序部分中剔除。
下一轮又从剩余的待排序元素中选一个最大的，用泡泡再次将其上浮到最顶端。如此一来，经过n轮吐泡泡。从数组最顶端往下，依次就是最大的元素，第二大的元素，第三大的元素…整个数组就是有序的了，当然，若想要逆序的话，每一轮就挑最小的元素冒泡上去就好了。
一轮冒泡的过程，是通过对相邻两个元素不断地比较和交换，来找到该轮冒泡中最大的元素，并将其移动到顶端的。
具体过程是，想象一个指针，指针指向的元素称为当前元素。指针先指向第一个元素，比较当前元素和下一个元素之间的大小，若当前元素比下一个元素大，则交换当前元素和下一个元素。并把指针后移一个位置，继续和下一个元素比较，一直比到最后一个元素。这样，就完成了第一轮冒泡。第一轮冒泡完毕后，最右侧的元素就是最大的。第二轮冒泡，又从第一个元素开始，依次进行比较和交换，一直比到倒数第二个元素。第二轮结束，右侧倒数第二个元素就是第二大的…N轮冒泡后，整个数组就是从小到大有序的了
图解如下
假设准备对如下数组进行冒泡排序
第一轮冒泡
指针先指向第一个元素，比较当前元素与下一个元素，发现9比5大，那么交换二者
指针后移一位
继续比较当前元素和下一个元素的大小，发现9比7大，交换之
指针继续后移一位，继续比较与交换，最终9被冒泡到最右端，第一轮冒泡结束
第二轮冒泡开始，将指针放在第一个元素，开始重复第一轮的过程（注意第二轮只需要冒泡到倒数第二个位置即可，因为每一轮结束后，最右侧的有序序列的长度都会变长1位）
发现5比7小，则不交换。指针后移
发现7比3大，交换之
指针后移
发现7比1大，交换之…最后，8被冒泡到最右端
继续第三轮，7被冒泡到最右边
第四轮，6到了最右边
…
最后，整个数组有序
根据这个思路，写出代码如下
public void bubbleSort(int[] a) { for(int i = a.length - 1; i &gt;= 0; i--) { for(int j = 0; j &lt; i; j&#43;&#43;) { if(a[j] &gt; a[j &#43; 1]) swap(a, j, j &#43; 1); } } } public static void swap(int[] a, int i, int j) { int t = a[i]; a[i] = a[j]; a[j] = t; } 外层循环从数组最后一个位置开始，表示的是每一轮的终结位置（第一轮冒泡到最后一个位置停止，第二轮冒泡到倒数第二个位置停止，以此类推）。内层循环是一轮冒泡的过程，每轮冒泡，从第一个位置开始，依次与后一个位置进行比较和交换，一直进行到该轮冒泡的停止位置。当然，上述代码，只写出了核心部分的实现，并不完善。比如bubbleSort方法内，应该先判断array变量是否为null，swap方法内应该判断array是否为null，并检测i和j是否越界。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/220ee5fdf7545fcf3b035ca1bb4e4e00/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-01-19T16:23:50+08:00" />
<meta property="article:modified_time" content="2022-01-19T16:23:50+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">排序算法——冒泡排序系列及性能测试</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p></p> 
<div class="toc"> 
 <h4>文章目录</h4> 
 <ul><li><ul><li><ul><li><a href="#_1" rel="nofollow">初识冒泡排序</a></li><li><a href="#_98" rel="nofollow">优化思路</a></li><li><ul><li><a href="#_99" rel="nofollow">思路一</a></li><li><a href="#_120" rel="nofollow">思路二</a></li></ul> 
    </li><li><a href="#_157" rel="nofollow">性能测试</a></li><li><a href="#_173" rel="nofollow">加餐（鸡尾酒排序）</a></li></ul> 
  </li></ul> 
 </li></ul> 
</div> 
<p></p> 
<h4><a id="_1"></a>初识冒泡排序</h4> 
<p>排序算法常常作为学习算法的入门实践，而冒泡排序又是其中最简单的一种，我们今天的主题就是冒泡排序。它的基本思想就像鱼吐泡泡一样简单。<br><br><br> 想象有一条鱼在数组的最底端，每一轮，它就吐个泡泡，泡泡会从数组一端漂到另一端，在漂浮过程中，泡泡会捕获数组中<strong>待排序的部分</strong>中最大的元素，将其移动到最顶端，然后把这个元素从数组<strong>待排序部分</strong>中剔除。<br><br>下一轮又从剩余的待排序元素中选一个最大的，用泡泡再次将其上浮到最顶端。如此一来，经过n轮吐泡泡。从数组最顶端往下，依次就是最大的元素，第二大的元素，第三大的元素…整个数组就是有序的了，当然，若想要逆序的话，每一轮就挑最小的元素冒泡上去就好了。<br><br></p> 
<p>一轮冒泡的过程，是通过对相邻两个元素不断地比较和交换，来找到该轮冒泡中最大的元素，并将其移动到顶端的。<br><br><br> 具体过程是，想象一个指针，指针指向的元素称为<strong>当前元素</strong>。指针先指向第一个元素，比较当前元素和下一个元素之间的大小，若当前元素比下一个元素大，则交换当前元素和下一个元素。并把指针后移一个位置，继续和下一个元素比较，一直比到最后一个元素。这样，就完成了第一轮冒泡。第一轮冒泡完毕后，最右侧的元素就是最大的。第二轮冒泡，又从第一个元素开始，依次进行比较和交换，一直比到倒数第二个元素。第二轮结束，右侧倒数第二个元素就是第二大的…N轮冒泡后，整个数组就是从小到大有序的了<br><br></p> 
<p>图解如下</p> 
<p>假设准备对如下数组进行冒泡排序</p> 
<p><img src="https://images2.imgbox.com/c4/0c/SWCGOnAA_o.png" alt=""></p> 
<p>第一轮冒泡</p> 
<p><img src="https://images2.imgbox.com/2d/bd/WFq25odm_o.png" alt=""></p> 
<p>指针先指向第一个元素，比较当前元素与下一个元素，发现9比5大，那么交换二者</p> 
<p><img src="https://images2.imgbox.com/4d/fd/gfkO7Vqu_o.png" alt=""></p> 
<p>指针后移一位</p> 
<p><img src="https://images2.imgbox.com/31/13/rW24ffyK_o.png" alt=""></p> 
<p>继续比较当前元素和下一个元素的大小，发现9比7大，交换之</p> 
<p><img src="https://images2.imgbox.com/4f/4b/DYqNAHQ8_o.png" alt=""></p> 
<p>指针继续后移一位，继续比较与交换，最终9被冒泡到最右端，第一轮冒泡结束</p> 
<p><img src="https://images2.imgbox.com/ac/cc/i9IW8aOx_o.png" alt=""></p> 
<p>第二轮冒泡开始，将指针放在第一个元素，开始重复第一轮的过程（注意第二轮只需要冒泡到倒数第二个位置即可，因为每一轮结束后，最右侧的有序序列的长度都会变长1位）</p> 
<p><img src="https://images2.imgbox.com/5d/51/N7DmFMLe_o.png" alt=""></p> 
<p>发现5比7小，则不交换。指针后移</p> 
<p><img src="https://images2.imgbox.com/1d/7e/2TEHFgfy_o.png" alt=""></p> 
<p>发现7比3大，交换之</p> 
<p><img src="https://images2.imgbox.com/1e/07/6sFnql89_o.png" alt=""></p> 
<p>指针后移</p> 
<p><img src="https://images2.imgbox.com/2f/f5/YkVa9Z0R_o.png" alt=""></p> 
<p>发现7比1大，交换之…最后，8被冒泡到最右端</p> 
<p><img src="https://images2.imgbox.com/13/52/vGQlZUKb_o.png" alt=""></p> 
<p>继续第三轮，7被冒泡到最右边</p> 
<p><img src="https://images2.imgbox.com/d5/20/YZ54WsrI_o.png" alt=""></p> 
<p>第四轮，6到了最右边</p> 
<p><img src="https://images2.imgbox.com/43/5c/oqw3fdNI_o.png" alt=""></p> 
<p>…</p> 
<p>最后，整个数组有序</p> 
<p><img src="https://images2.imgbox.com/94/51/40tmryf5_o.png" alt=""></p> 
<p>根据这个思路，写出代码如下</p> 
<pre><code class="prism language-java">	<span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">bubbleSort</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> a<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
		<span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> a<span class="token punctuation">.</span>length <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&gt;=</span> <span class="token number">0</span><span class="token punctuation">;</span> i<span class="token operator">--</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
			<span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> i<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
				<span class="token keyword">if</span><span class="token punctuation">(</span>a<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">&gt;</span> a<span class="token punctuation">[</span>j <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token function">swap</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> j<span class="token punctuation">,</span> j <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
			<span class="token punctuation">}</span>
		<span class="token punctuation">}</span>
	<span class="token punctuation">}</span>
	
	<span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">swap</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> a<span class="token punctuation">,</span> <span class="token keyword">int</span> i<span class="token punctuation">,</span> <span class="token keyword">int</span> j<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
		<span class="token keyword">int</span> t <span class="token operator">=</span> a<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>
		a<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> a<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>
		a<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> t<span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
</code></pre> 
<p>外层循环从数组最后一个位置开始，表示的是每一轮的终结位置（第一轮冒泡到最后一个位置停止，第二轮冒泡到倒数第二个位置停止，以此类推）。内层循环是一轮冒泡的过程，每轮冒泡，从第一个位置开始，依次与后一个位置进行比较和交换，一直进行到该轮冒泡的停止位置。当然，上述代码，只写出了核心部分的实现，并不完善。比如<code>bubbleSort</code>方法内，应该先判断<code>array</code>变量是否为<code>null</code>，<code>swap</code>方法内应该判断<code>array</code>是否为<code>null</code>，并检测<code>i</code>和<code>j</code>是否越界。</p> 
<h4><a id="_98"></a>优化思路</h4> 
<h5><a id="_99"></a>思路一</h5> 
<p>上面的冒泡排序的实现，实际还有可优化的空间。比如，若某一轮冒泡的过程中，没有发生任何元素交换。这就说明数组已经整体有序，则无需再进行后续的冒泡轮数。修改代码，只需要在每一轮冒泡开始前，新增一个布尔类型的标志变量<code>boolean sorted = true</code>，只要该轮冒泡发生过元素交换，就将<code>sorted</code>变量置为<code>false</code>。如此以来，在每轮冒泡结束后，新增一个判断逻辑，判断若<code>sorted</code>为<code>true</code>，则提前结束排序，写成代码如下。</p> 
<pre><code class="prism language-java">	<span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">bubbleSortV1</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> a<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
		<span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> a<span class="token punctuation">.</span>length <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&gt;=</span> <span class="token number">0</span><span class="token punctuation">;</span> i<span class="token operator">--</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
			<span class="token keyword">boolean</span> sorted <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
			<span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> i<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
				<span class="token keyword">if</span><span class="token punctuation">(</span>a<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">&gt;</span> a<span class="token punctuation">[</span>j <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
					<span class="token function">swap</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> j<span class="token punctuation">,</span> j <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
					sorted <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
				<span class="token punctuation">}</span>
			<span class="token punctuation">}</span>
			<span class="token keyword">if</span> <span class="token punctuation">(</span>sorted<span class="token punctuation">)</span> <span class="token keyword">break</span><span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
	<span class="token punctuation">}</span>
</code></pre> 
<h5><a id="_120"></a>思路二</h5> 
<p>如果说上面是粒度较大的优化（针对外层循坏的全局优化，满足条件时整个流程提前结束），则在更小粒度上还存在着优化空间（每轮冒泡过程中的优化）。原先的实现，每轮冒泡之后，最右侧有序序列的长度是依次加一的。即，第一轮冒泡，需要交换比较，直到最后一个位置；第二轮冒泡，需要交换比较，直到倒数第二个位置…然而，<strong>每轮冒泡只需要将泡泡上浮到有序序列的边界即可终止</strong>，我们可以根据每一轮的实际情况，来决定下一轮冒泡的停止位置。而不是每一轮都必须达到固定的停止位置。</p> 
<p>比如有如下数组</p> 
<p><img src="https://images2.imgbox.com/4c/f6/CP0kZAQQ_o.png" alt=""></p> 
<p>第一轮冒泡后，数组变为</p> 
<p><img src="https://images2.imgbox.com/ba/44/nTKPYnq0_o.png" alt=""></p> 
<p>最后一次发生交换的是3和4的位置，之后都<strong>只是进行了比较而并未发生交换</strong>，说明4以后的都是有序序列了。那么，第二轮冒泡的终止位置可以不必到倒数第二个位置了，而可以只到<strong>上一轮冒泡</strong>发生的<strong>最后一次交换的位置</strong>（发生最后一次交换的位置的右侧，即是有序序列）。即，对于每一轮冒泡，新增了用于记录发生最后一次交换的位置的变量，用于指示下一轮冒泡的终止位置。写成代码如下</p> 
<pre><code class="prism language-java">	<span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">bubbleSortV2</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> a<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
		<span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> a<span class="token punctuation">.</span>length <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&gt;=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
			<span class="token keyword">boolean</span> sorted <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
			<span class="token keyword">int</span> lastSwap <span class="token operator">=</span> i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>
			<span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> i<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
				<span class="token keyword">if</span><span class="token punctuation">(</span>a<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">&gt;</span> a<span class="token punctuation">[</span>j <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
					<span class="token function">swap</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> j<span class="token punctuation">,</span> j <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
					sorted <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
					lastSwap <span class="token operator">=</span> j<span class="token punctuation">;</span>
				<span class="token punctuation">}</span>
			<span class="token punctuation">}</span>
			i <span class="token operator">=</span> lastSwap<span class="token punctuation">;</span>
			<span class="token keyword">if</span> <span class="token punctuation">(</span>sorted<span class="token punctuation">)</span> <span class="token keyword">break</span><span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
	<span class="token punctuation">}</span>
</code></pre> 
<p>注意，无论如何优化，冒泡排序的元素交换次数是不变的，优化措施减少的只是不必要的比较次数，给出如下示例，可自行验证</p> 
<p><img src="https://images2.imgbox.com/be/05/MhvmZ59W_o.png" alt=""></p> 
<h4><a id="_157"></a>性能测试</h4> 
<p>理论上讲，由于后两种引入了优化措施，应该其效率要高于未优化的版本，即效率大小应为</p> 
<p><code>bubbleSortV2 &gt; bubbleSortV1 &gt; bubbleSort</code></p> 
<p>然而实际测试的时候发现，有时并不是如此，因为优化措施在每轮冒泡过程中加入了额外的判断，需要消耗一定性能的，并且如果待排序的数组，使用优化措施减少的无用比较的性能开销，小于引入额外判断造成的性能开销，即收益小于成本时，V1和V2的性能就不一定要高于未优化版本（并且还需要考虑到运行时机器的实际情况）。然而当数组规模较大时，优化措施能降低的比较次数较多，收益较高，则性能会优于未优化版本。</p> 
<p>下面针对3个冒泡排序的版本，进行性能测试。测试使用随机生成的数组，数组规模从100，400，700…一直到14800（数组规模从100开始，规模依次递增300，共测试50组数组）。为了避免运行时机器的影响因素，对每组数组，重复测试20次，取性能平均值。绘制得到的性能折线图如下</p> 
<p><img src="https://images2.imgbox.com/71/0e/AZ6SvghB_o.png" alt=""></p> 
<p>可知，随着数组规模的增大，优化后的版本性能要明显好于未优化的版本，且V2版本性能略优于V1</p> 
<h4><a id="_173"></a>加餐（鸡尾酒排序）</h4> 
<p>另，还有一种冒泡排序的变种，名为<strong>鸡尾酒排序</strong>，它的思想是双向冒泡，奇数轮从左到右，将最大的元素冒泡到最右侧，偶数轮从右到左，将最小的元素冒泡到最左侧。鸡尾酒排序在数组中间部分有序，而两端乱序时，能够取得较好的性能提升。下面是它的代码实现，和冒泡排序非常类似</p> 
<pre><code class="prism language-java">	<span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">cockTailSort</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> a<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
		<span class="token keyword">boolean</span> moveL <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
		<span class="token keyword">int</span> l <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> r <span class="token operator">=</span> a<span class="token punctuation">.</span>length <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>
		<span class="token keyword">while</span> <span class="token punctuation">(</span>l <span class="token operator">&lt;</span> r<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
			<span class="token keyword">if</span> <span class="token punctuation">(</span>moveL<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
				<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> l<span class="token punctuation">;</span> i <span class="token operator">&lt;</span> r<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
					<span class="token keyword">if</span> <span class="token punctuation">(</span>a<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">&gt;</span> a<span class="token punctuation">[</span>i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token function">swap</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> i<span class="token punctuation">,</span> i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
				<span class="token punctuation">}</span>
				r<span class="token operator">--</span><span class="token punctuation">;</span>
			<span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{<!-- --></span>
				<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> r<span class="token punctuation">;</span> i <span class="token operator">&gt;</span> l <span class="token punctuation">;</span> i<span class="token operator">--</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
					<span class="token keyword">if</span> <span class="token punctuation">(</span>a<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">&lt;</span> a<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token function">swap</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> i<span class="token punctuation">,</span> i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
				<span class="token punctuation">}</span>
				l<span class="token operator">++</span><span class="token punctuation">;</span>
			<span class="token punctuation">}</span>
			moveL <span class="token operator">=</span> <span class="token operator">!</span>moveL<span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
	<span class="token punctuation">}</span>
</code></pre> 
<p>将鸡尾酒排序纳入性能测试，看看它和普通冒泡排序的对比</p> 
<p><img src="https://images2.imgbox.com/39/ea/rmUQIwlQ_o.png" alt=""></p> 
<p>可见鸡尾酒排序的性能要略优于普通冒泡排序</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/ab889166175f2d1653cf8ae590fec4c6/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">nginx修改http协议为2.0 &amp; docker添加端口到已运行容器中</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/4cfd70036263a75b093d72d1cdd737de/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">java日期和毫秒值的相互转化</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>