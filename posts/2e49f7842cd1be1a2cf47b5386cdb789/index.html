<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>微信小程序开发 - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="微信小程序开发" />
<meta property="og:description" content="1 小程序与普通网页开发的区别 (1) 运行环境的不同
网页运行在浏览器汇总,小程序运行在微信环境中
(2) api不同
(3) 开发模式不同
2 小程序代码的构成-项目结构 (1) 目录结构
(2) 页面的组成部分
组件: 一个完整的前端功能的整体,页面(html),功能(script),样式(style)
(3) json配置文件
① app.json
page: 用来记录当前小程序所有页面的路径windows: 全局定义小程序所有页面的背景色,文字颜色等style: 全局定义小程序组件所使用的的样式版本(v2表示新版样式)tabBar: 小程序的tabBar效果的配置sitemapLocation: 用来指明sitemap.json的位置 ② project.config.json(用来记录小程序开发工具所做的个性化配置)
setting: 保存了编译相关的配置(在设置中进行的设置会体现在setting中)
projectname : 保存的是项目名称 appid: 保存的是小程序的账号 ID
checkSiteMap: 控制台sitemap警告
③ sitemap.json
微信现已开放小程序内搜索，效果类似于 PC 网页的 SEO 。 sitemap.json 文件用来配置小程序 页面是否允许微信索引 当开发者允许微信索引时，微信会通过爬虫的形式，为小程序的页面内容建立索引。当用户的搜索 关键字和页面的索引匹配成功的时候，小程序的页面将可能展示在搜索结果中。 ④ 页面.json
小程序中的每一个页面,可以使用.json文件来对本页面的窗口外观进行配置,页面中的配置项会覆盖app.json的window中相同的配置项,不需要写window对象名,直接写
3 新增小程序页面 在app.json -&gt; pages 中新增页面存放路径,小程序开发者工具可帮助我们自动创建对应的页面文件: &#39;pages/list/list&#39;,pages配置项的第一项作为首页显示
4 小程序代码的构成 4.1 WXML模板 (1) WXML和HTML的区别
标签名称不同
HTML(div, span, img, a)WXML(view, text, image, navigator) 属性节点不同" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/2e49f7842cd1be1a2cf47b5386cdb789/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2021-12-09T16:23:36+08:00" />
<meta property="article:modified_time" content="2021-12-09T16:23:36+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">微信小程序开发</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <h2>1 小程序与普通网页开发的区别</h2> 
<p>(1) 运行环境的不同</p> 
<p>网页运行在浏览器汇总,小程序运行在微信环境中</p> 
<p>(2) api不同</p> 
<p>(3) 开发模式不同</p> 
<h3>2 小程序代码的构成-项目结构</h3> 
<p>(1) 目录结构</p> 
<p><img alt="" height="259" src="https://images2.imgbox.com/57/ed/RPdtQ0nZ_o.png" width="716"></p> 
<p> (2) 页面的组成部分</p> 
<p><img alt="" height="342" src="https://images2.imgbox.com/d3/8e/82DcuvvI_o.png" width="700"></p> 
<p> 组件: 一个完整的前端功能的整体,页面(html),功能(script),样式(style)</p> 
<p>(3) json配置文件</p> 
<p>① app.json</p> 
<ul><li>page: 用来记录当前小程序所有页面的路径</li><li>windows: 全局定义小程序所有页面的背景色,文字颜色等</li><li>style: 全局定义小程序组件所使用的的样式版本(v2表示新版样式)</li><li>tabBar: 小程序的tabBar效果的配置</li><li>sitemapLocation: 用来指明sitemap.json的位置</li></ul> 
<p>② project.config.json(用来记录小程序开发工具所做的个性化配置)</p> 
<ul><li> <p>setting: <span style="color:#333333;">保存了编译相关的配置(</span>在设置中进行的设置会体现在setting中<span style="color:#333333;">)</span></p> </li><li> <p><span style="color:#333333;">projectname </span>: <span style="color:#333333;">保存的是项目名称 </span></p> </li></ul> 
<div> 
 <ul><li> <p><span style="color:#333333;">appid: 保存的是小程序的账号 ID</span></p> </li><li> <p><span style="color:#333333;">checkSiteMap: 控制台sitemap警告</span></p> </li></ul> 
</div> 
<p>③ sitemap.json</p> 
<div> 
 <span style="color:#333333;">微信现已开放小程序内搜索，效果类似于</span> 
 <span style="color:#333333;"> PC </span> 
 <span style="color:#333333;">网页的 </span> 
 <span style="color:#333333;">SEO </span> 
 <span style="color:#333333;">。 </span> 
 <span style="color:#333333;">sitemap.json </span> 
 <span style="color:#333333;">文件用来配置小程序 </span> 
</div> 
<div> 
 <span style="color:#333333;">页面是否允许微信索引</span> 
</div> 
<div> 
 <div> 
  <span style="color:#333333;">当开发者允许微信索引时，微信会通过爬虫的形式，为小程序的页面内容建立索引。当用户的搜索 </span> 
 </div> 
 <div> 
  <span style="color:#333333;">关键字和页面的索引匹配成功的时候，小程序的页面将可能展示在搜索结果中。</span> 
 </div> 
 <div></div> 
</div> 
<p>④ 页面.json</p> 
<p>小程序中的每一个页面,可以使用.json文件来对本页面的窗口外观进行配置,<span style="color:#a2e043;">页面中的配置项会覆盖app.json的window中相同的配置项,</span>不需要写window对象名,直接写</p> 
<h2>3 新增小程序页面</h2> 
<p>在app.json -&gt; pages 中新增页面存放路径,小程序开发者工具可帮助我们自动创建对应的页面文件: 'pages/list/list',pages配置项的第一项作为首页显示</p> 
<h2>4 小程序代码的构成</h2> 
<h3>4.1 WXML模板</h3> 
<p>(1) WXML和HTML的区别</p> 
<p>标签名称不同</p> 
<ul><li>HTML(div, span, img, a)</li><li>WXML(view, text, image, navigator)</li></ul> 
<p>属性节点不同</p> 
<ul><li>&lt;a href="#"&gt;&lt;/a&gt;</li><li>&lt;navigator url="/pages/home/home"&gt;&lt;/navigator&gt;</li></ul> 
<p>提供了类似于Vue中的模板语法</p> 
<ul><li>数据绑定</li><li>列表渲染</li><li>条件渲染</li></ul> 
<h3>4.2 WXSS</h3> 
<p>新增了rpx尺寸单位</p> 
<ul><li>CSS中需要手动进行像素单位换算,例如rem</li><li>WXSS在底层支持新的尺寸单位rpx,在不同大小的屏幕上<span style="color:#333333;">小程序会自动进行换算</span></li></ul> 
<p><span style="color:#333333;">提供了全局的样式和局部的样式</span></p> 
<ul><li><span style="color:#333333;">项目根目录中的app.wxss会作用于所有小程序页面</span></li><li><span style="color:#333333;">局部页面的wxss会作用域局部</span></li></ul> 
<p>WXSS仅支持部分CSS选择器</p> 
<ul><li>.class和#id</li><li>element</li><li>并集选择器,后代选择器</li><li>::after和::before等伪类选择器</li></ul> 
<h3>4.3 小程序中的js逻辑交互</h3> 
<h4>4.3.1 小程序中js文件的三大类</h4> 
<p>app.js</p> 
<ul><li>是整个小程序项目的入口文件.,通过调用App()函数来启动整个小程序</li></ul> 
<p>页面的.js文件</p> 
<ul><li>是页面的入口文件,<span style="color:#333333;">通过调用 </span><span style="color:#333333;">Page() </span><span style="color:#333333;">函数来创建并运行页面 </span></li></ul> 
<p>普通的.js文件</p> 
<ul><li>是普通的<span style="color:#333333;">功能模块文件，用来封装公共的函数或属性供页面使用</span></li></ul> 
<h2><span style="color:#333333;">5 小程序的宿主环境</span></h2> 
<p><span style="color:#333333;">宿主环境指的是程序运行所必须的依赖环境,例如安卓和ios系统是两个不同的宿主环境</span></p> 
<p><span style="color:#333333;">手机微信是小程序的宿主环境</span></p> 
<p><span style="color:#333333;">借助此宿主环境提供的能力,可以完成许多普通网页无法完成的功能</span></p> 
<h3><span style="color:#333333;">5.1 小程序宿主环境包含的内容</span></h3> 
<h4>5.1.1 通信模型</h4> 
<p>(1) 通信的主体</p> 
<p>小程序通信的主体是渲染层和逻辑层,其中:</p> 
<ul><li>WXML模板和WXSS样式工作再渲染层</li><li>JS脚本工作在逻辑层</li></ul> 
<p>(2) <span style="color:#333333;">而所谓的通信模型指的是:</span></p> 
<ul><li><span style="color:#333333;">渲染层</span><span style="color:#333333;">和</span><span style="color:#333333;">逻辑层之间的通信</span></li><li><span style="color:#333333;">逻辑层</span><span style="color:#333333;">和</span><span style="color:#333333;">第三方服务器</span><span style="color:#333333;">之间的通信</span></li></ul> 
<h4>5.1.2 运行机制</h4> 
<p>小程序的启动过程:</p> 
<ul><li>把小程序的代码包下载到本地</li><li>解析app.json全局配置文件</li><li>执行app.js小程序入口文件,调用App()创建小程序的实例(一个小程序中,只有一个App对象,可能会有多个实例Page对象,一个页面中会有多个Component实例对象)</li><li>渲染小程序首页</li><li>小程序启动完成</li></ul> 
<h4>5.1.3 组件(哪些标签可以使用)</h4> 
<p>(1) 组件的分类</p> 
<div>
  ① 视图容器 
</div> 
<div>
  ② 基础内容 
</div> 
<div>
  ③ 表单组件 
</div> 
<div>
  ④ 导航组件 
</div> 
<div> 
 <span style="color:#333333;">⑤ 媒体组件 </span> 
</div> 
<div> 
 <span style="color:#333333;">⑥</span> 
 <span style="color:#333333;"> map </span> 
 <span style="color:#333333;">地图组件 </span> 
</div> 
<div> 
 <span style="color:#333333;">⑦</span> 
 <span style="color:#333333;"> canvas </span> 
 <span style="color:#333333;">画布组件 </span> 
</div> 
<div> 
 <span style="color:#333333;">⑧ 开放能力 </span> 
</div> 
<div> 
 <span style="color:#333333;">⑨ 无障碍访问 </span> 
</div> 
<div></div> 
<div> 
 <span style="color:#333333;">(2) 常用的视图容器类组件</span> 
</div> 
<div></div> 
<div> 
 <div> 
  <span style="color:#333333;">view </span> 
 </div> 
 <ul><li><span style="color:#333333;">普通视图区域 </span></li><li><span style="color:#333333;">类似于</span><span style="color:#333333;"> HTML </span><span style="color:#333333;">中的</span><span style="color:#333333;"> div</span><span style="color:#333333;">，是一个块级元素 </span></li><li><span style="color:#333333;">常用来实现页面的布局效果 </span></li></ul> 
 <div> 
  <div> 
   <span style="color:#333333;">scroll</span> 
   <span style="color:#333333;">-</span> 
   <span style="color:#333333;">view </span> 
  </div> 
  <ul><li><span style="color:#333333;">可滚动的视图区域 </span></li><li><span style="color:#333333;">常用来实现滚动列表效果 </span></li></ul> 
  <div> 
   <div> 
    <span style="color:#333333;">swiper </span> 
    <span style="color:#333333;">和 </span> 
    <span style="color:#333333;">swiper</span> 
    <span style="color:#333333;">-</span> 
    <span style="color:#333333;">item </span> 
   </div> 
   <ul><li><span style="color:#333333;">轮播图容器组件 和 轮播图 </span><span style="color:#333333;">item </span><span style="color:#333333;">组件</span></li><li><img alt="" height="305" src="https://images2.imgbox.com/2d/1c/YsYl6CB6_o.png" width="200"></li><li>常用的属性 
     <ul><li><span style="color:#333333;">indicator</span><span style="color:#333333;">-</span><span style="color:#333333;">dots </span><span style="color:#333333;">是否显示面板指示点 </span> </li><li><span style="color:#333333;">indicator</span><span style="color:#333333;">-</span><span style="color:#333333;">color </span><span style="color:#333333;">指示点颜色 </span></li><li><span style="color:#333333;">indicator</span><span style="color:#333333;">-</span><span style="color:#333333;">active</span><span style="color:#333333;">-</span><span style="color:#333333;">color </span><span style="color:#333333;">激活指示点颜色 </span></li><li><span style="color:#333333;">autoplay </span><span style="color:#333333;">是否自动切换 </span></li><li><span style="color:#333333;">interval </span><span style="color:#333333;">自动切换时间间隔 </span></li><li><span style="color:#333333;">circular </span><span style="color:#333333;">是否采用衔接滑动 </span></li></ul></li></ul> 
   <p> text和rich-text组件</p> 
   <ul><li>selectable可以长按选中</li><li>通过rich-text组件的nodes属性节点，把<span style="color:#333333;">HTML </span><span style="color:#333333;">字符串渲染为 </span><span style="color:#333333;">WXML </span><span style="color:#333333;">结构，类似v-html</span></li></ul> 
   <p><span style="color:#333333;">(3) 其他常用组件</span></p> 
   <p><span style="color:#333333;">button</span></p> 
   <ul><li><span style="color:#333333;">按钮组件</span></li><li><span style="color:#333333;">功能比HTML中的button按钮丰富</span></li><li><span style="color:#333333;">通过open-type属性可以调用微信提供的各种功能</span></li><li><span style="color:#333333;">type属性指定按钮类型,size按钮的尺寸,plain镂空的按钮</span></li></ul> 
   <p>image 组件的基本使用</p> 
   <ul><li>src指定图片的路径,/表示根目录</li><li>mode属性来指定图片的裁剪和缩放模式,常用的mode属性值如下:</li><li><img alt="" height="229" src="https://images2.imgbox.com/bc/59/mlv6fXJD_o.png" width="752"></li></ul> 
  </div> 
 </div> 
</div> 
<h4>5.1.4 API</h4> 
<p>(1) 概述</p> 
<p><span style="color:#333333;">小程序中的 </span><span style="color:#333333;">API </span><span style="color:#333333;">是由宿主环境提供的，通过这些丰富的小程序 </span><span style="color:#333333;">API </span><span style="color:#333333;">，开发者可以方便的调用微信提供的能力</span></p> 
<p>(2) 3大分类</p> 
<p>事件监听API</p> 
<ul><li><span style="color:#333333;">特点：以</span><span style="color:#333333;"> on </span><span style="color:#333333;">开头，用来监听某些事件的触发 </span></li><li><span style="color:#333333;">举例： </span><span style="color:#333333;">wx.onWindowResize(function callback) </span><span style="color:#333333;">监听窗口尺寸变化的事件 </span></li></ul> 
<p>同步API</p> 
<ul><li><span style="color:#333333;">特点</span><span style="color:#333333;">1</span><span style="color:#333333;">：以 </span><span style="color:#333333;">Sync </span><span style="color:#333333;">结尾的 </span><span style="color:#333333;">API </span><span style="color:#333333;">都是同步 </span><span style="color:#333333;">API </span></li><li><span style="color:#333333;">特点</span><span style="color:#333333;">2</span><span style="color:#333333;">：同步 </span><span style="color:#333333;">API </span><span style="color:#333333;">的执行结果，可以通过函数返回值直接获取，如果执行出错会抛出异常 </span></li><li><span style="color:#333333;">举例： </span><span style="color:#333333;">wx.setStorageSync('key', 'value') </span><span style="color:#333333;">向本地存储中写入内容 </span></li></ul> 
<p>异步API</p> 
<ul><li><span style="color:#333333;">特点：类似于 </span><span style="color:#333333;">jQuery </span><span style="color:#333333;">中的 </span><span style="color:#333333;">$.ajax(options) </span><span style="color:#333333;">函数，需要通过</span><span style="color:#333333;"> success</span><span style="color:#333333;">、</span><span style="color:#333333;">fail</span><span style="color:#333333;">、</span><span style="color:#333333;">complete </span><span style="color:#333333;">接收调 </span></li><li><span style="color:#333333;">用的结果 </span></li><li><span style="color:#333333;">举例： </span><span style="color:#333333;">wx.request() </span><span style="color:#333333;">发起网络数据请求，通过 </span><span style="color:#333333;">success </span><span style="color:#333333;">回调函数接收数据</span></li></ul> 
<p><span style="color:#fe2c24;">顶级对象: wx</span></p> 
<h2>6 协同工作和发布</h2> 
<h3>6.1 协同工作</h3> 
<p>(1) 项目成员的组织结构</p> 
<p><img alt="" height="282" src="https://images2.imgbox.com/a1/69/RHELxo8d_o.png" width="568"></p> 
<p> (2) 开发流程</p> 
<p><img alt="" height="232" src="https://images2.imgbox.com/b6/7f/ALUhW5cl_o.png" width="801"></p> 
<h3> 6.2 小程序成员管理</h3> 
<p>(1) 成员管理的两个方面</p> 
<p><img alt="" height="272" src="https://images2.imgbox.com/1d/a4/l3MaHIlS_o.png" width="320"></p> 
<p>项目成员: 表示参与小程序开发, 运营的成员, 可以登录小程序的管理后台</p> 
<p>体验成员: 表示参与小程序内测体验成员,可使用体验版小程序,但不属于项目成员</p> 
<p>(2) 不同项目成员对应的权限</p> 
<p><img alt="" height="225" src="https://images2.imgbox.com/26/b6/RqdKnePJ_o.png" width="599"></p> 
<p>(3) 开发者的权限说明</p> 
<p> <img alt="" height="146" src="https://images2.imgbox.com/cc/8d/zf2DcGHy_o.png" width="447"></p> 
<p> (4) 添加项目成员和体验成员</p> 
<p>左侧菜单的管理 -&gt; 成员管理</p> 
<h3>6.3 小程序的版本</h3> 
<p>(1) 软件开发过程中的不同的版本</p> 
<ul><li>开发者编写代码的同时,对项目代码进行自测(开发版本)</li><li><span style="color:#333333;">直到程序达到一个稳定可体验的状态时，开发者把体验版本给到产品经理和测试人员进行</span><span style="color:#333333;"><strong>体验测试 </strong></span></li></ul> 
<p><span style="color:#333333;">(2) 小程序的版本</span></p> 
<p><img alt="" height="158" src="https://images2.imgbox.com/4c/7b/2VVQEWxi_o.png" width="561"></p> 
<h3>6.4 发布上线</h3> 
<p>(1) 步骤</p> 
<p><span style="color:#333333;">上传代码</span><span style="color:#333333;"> -&gt; </span><span style="color:#333333;">提交审核</span><span style="color:#333333;"> -&gt; </span><span style="color:#333333;">发布</span></p> 
<p><span style="color:#333333;">(2) 上传代码</span></p> 
<p><span style="color:#333333;">① 点击开发者工具顶部工具栏中的</span><span style="color:#333333;">“</span><span style="color:#333333;">上传</span><span style="color:#333333;">” </span><span style="color:#333333;">按钮 </span></p> 
<p><span style="color:#333333;">② 填写版本号以及项目备注 </span></p> 
<p><span style="color:#333333;">(3) 提交审核</span></p> 
<p><span style="color:#333333;">① 为什么需要提交审核：为了保证小程序的质量，以及符合相关的规范，小程序的发布是需要经过腾 讯官方审核的。 </span></p> 
<p><span style="color:#333333;">② 提交审核的方式：在开发版本的列表中，点击<strong>“</strong></span><span style="color:#333333;"><strong>提交审核</strong></span><span style="color:#333333;"><strong>”</strong></span><span style="color:#333333;">按钮之后，按照页面提示填写相关的信息，就能把小程序提交到腾讯官方进行审核。 </span></p> 
<p><span style="color:#333333;">(4) 基于小程序码进行推广</span></p> 
<p><span style="color:#333333;">相对于普通二维码来说，小程序码的优势如下： </span></p> 
<p><span style="color:#333333;">① 在样式上更具辨识度和视觉冲击力 </span></p> 
<p><span style="color:#333333;">② 能够更加清晰地树立小程序的品牌形象 </span></p> 
<p><span style="color:#333333;">③ 可以帮助开发者更好地推广小程序 </span></p> 
<p><span style="color:#333333;">获取小程序码的</span><span style="color:#333333;"> 5 </span><span style="color:#333333;">个步骤： </span></p> 
<p><span style="color:#333333;">登录小程序管理后台</span><span style="color:#333333;"> -&gt; </span><span style="color:#333333;">设置</span><span style="color:#333333;"> -&gt; </span><span style="color:#333333;">基本设置</span><span style="color:#333333;"> -&gt; </span><span style="color:#333333;">基本信息</span><span style="color:#333333;"> -&gt; </span><span style="color:#333333;">小程序码及线下物料下载</span></p> 
<p><span style="color:#333333;">(5) 查看小程序的运营数据</span></p> 
<p><span style="color:#333333;">在"小程序后台"查看</span></p> 
<p><span style="color:#333333;">在"小程序数据助手"查看(下载小程序"小程序数据助手查看")</span></p> 
<h2>7 WXML模板语法</h2> 
<h3>7.1 数据绑定</h3> 
<p>(1) 数据绑定的基本原则</p> 
<ul><li>在data中定义数据</li><li>在WXML中使用</li></ul> 
<p>(2) 在data中定义页面的数据</p> 
<p><span style="color:#333333;">在页面对应的 </span><span style="color:#333333;">.js </span><span style="color:#333333;">文件中，把数据定义到 </span><span style="color:#333333;">data </span><span style="color:#333333;">对象中即可</span></p> 
<p>(3) 在WXML中使用,<span style="color:#333333;">Mustache语法</span></p> 
<p>&lt;&gt;{<!-- -->{ 变量名 }}&lt;/&gt;(标签属性中仍一样)</p> 
<h3>7.2 事件绑定</h3> 
<p>(1) 常用事件</p> 
<p><img alt="" height="125" src="https://images2.imgbox.com/3d/87/QdoMCVOt_o.png" width="607"></p> 
<p>(2) 如何定义事件处理函数</p> 
<p>在页面.js文件中,和data保持平级的关系,定义事件处理函数 </p> 
<p>(3) 事件对象的属性列表(e)</p> 
<p>当事件回调触发时,会收到一个事件对象event,他的详细属性如下:</p> 
<p><img alt="" height="292" src="https://images2.imgbox.com/fb/5c/xls1OiJL_o.png" width="819"></p> 
<p> (4) target和currentTarget的区别</p> 
<p>target是触发该事件的源头组件,而currentTarget则是当前事件所绑定的组件</p> 
<pre><code class="language-html">// e.target 指向的是触发事件的源头组件，因此， e.target 是内部的按钮组件
// e.currentTarget 指向的是当前正在触发事件的那个组件，因此， e.currentTarget 是当前的 view
组件
&lt;view bindtap="outerHandler"&gt;
    &lt;button&gt;按钮&lt;/button&gt;
&lt;/view&gt;</code></pre> 
<p>(5) 事件传参</p> 
<ul><li>传参比较特殊,<span style="color:#a2e043;">不能再绑定事件的同时为事件处理函数传递参数,</span>否则会把整体作为事件名</li><li>可以通过组件提供的data-*自定义属性传参,其中*代表参数的名字:</li><li><span style="color:#117700;">&lt;button </span><span style="color:#0000cc;">bindtap</span><span style="color:#333333;">=</span><span style="color:#aa1111;">"onBtnString" </span><span style="color:#0000cc;">data-info</span><span style="color:#333333;">=</span><span style="color:#aa1111;">"2"</span><span style="color:#117700;">&gt;</span><span style="color:#333333;">事件传参</span><span style="color:#333333;">-</span><span style="color:#333333;">拼接字符串</span><span style="color:#117700;">&lt;/button&gt; </span></li></ul> 
<p>(6)<span style="color:#117700;"> </span><span style="color:#333333;">info </span><span style="color:#333333;">会作为名字存储在事件对象的 </span><span style="color:#333333;">target </span><span style="color:#333333;">中的 </span><span style="color:#333333;">dataset </span><span style="color:#333333;">中</span><span style="color:#333333;">, 2 </span><span style="color:#333333;">会被解析为值</span></p> 
<p>(7) 如何访问data中的数据, this.data.xxx</p> 
<p>如何修改data中的数据, this.setData({})</p> 
<h3>7.3 条件渲染</h3> 
<p>(1) wx:if</p> 
<p>在小程序中,使用wx:if="{<!-- -->{show}}"<span style="color:#333333;">来判断是否需要渲染该代码块,也可以配合 </span><span style="color:#333333;">wx:elif </span><span style="color:#333333;">和 </span><span style="color:#333333;">wx:else </span><span style="color:#333333;">来添加 </span><span style="color:#333333;">else </span><span style="color:#333333;">判断</span></p> 
<pre><code class="language-html">&lt;!-- wx:if wx:else-if wx:else 条件渲染 --&gt;
&lt;view wx:if="{<!-- -->{ type === 1 }}" class="text"&gt;男&lt;/view&gt;
&lt;view wx:elif="{<!-- -->{ type === 2 }}" class="text"&gt;女&lt;/view&gt;
&lt;view wx:else&gt;保密&lt;/view&gt;</code></pre> 
<p>(2) 结合&lt;block&gt;使用wx:if</p> 
<p>如果要一次性控制多个组件的展示与隐藏,可以使用一个&lt;block&gt;&lt;/block&gt;标签<span style="color:#333333;">进行包裹，只是包裹性值，不会再页面渲染</span></p> 
<p><span style="color:#333333;">注意:</span><span style="color:#a2e043;"> block并不是一个组件，它只是一个包裹性质的容器，不会在页面中做任何渲染</span></p> 
<p>(3) hidden</p> 
<p>在小程序中,直接使用hidden="{<!-- -->{show}}"也能控制元素的显示与隐藏</p> 
<p>(4) 区别</p> 
<p><span style="color:#333333;">① 运行方式不同 </span></p> 
<ul><li><span style="color:#333333;">wx:if </span><span style="color:#333333;">以</span><span style="color:#333333;"><strong>动态创建</strong></span><span style="color:#333333;">和</span><span style="color:#333333;"><strong>移除元素</strong></span><span style="color:#333333;">的方式，控制元素的展示与隐藏 </span></li><li><span style="color:#333333;">hidden </span><span style="color:#333333;">以</span><span style="color:#333333;"><strong>切换样式</strong></span><span style="color:#333333;">的方式（ </span><span style="color:#333333;">display: none/block</span><span style="color:#333333;">; </span><span style="color:#333333;">），控制元素的显示与隐藏 </span></li></ul> 
<p><span style="color:#333333;">② 使用建议 </span></p> 
<ul><li><span style="color:#333333;">频繁切换时，建议使用 </span><span style="color:#333333;">hidden </span></li><li><span style="color:#333333;">控制条件复杂时，建议使用 </span><span style="color:#333333;">wx:if </span><span style="color:#333333;">搭配 </span><span style="color:#333333;">wx:elif </span><span style="color:#333333;">、 </span><span style="color:#333333;">wx:else </span><span style="color:#333333;">进行展示与隐藏的切换 </span></li></ul> 
<h3><span style="color:#333333;">7.4 循环渲染</span></h3> 
<p><span style="color:#333333;">(1) wx:for</span></p> 
<p><span style="color:#333333;">语法: wx:for="{<!-- -->{ 数据名称 }}"</span></p> 
<p><span style="color:#333333;">{<!-- -->{ index }} {<!-- -->{ item }}</span></p> 
<p><span style="color:#333333;">(2) 手动指定索引和当前项的变量名</span></p> 
<ul><li><span style="color:#333333;">使用 </span><span style="color:#333333;">wx:for</span><span style="color:#333333;">-</span><span style="color:#333333;">index </span><span style="color:#333333;">可以指定当前循环项的索引的变量名 </span></li><li><span style="color:#333333;">使用 </span><span style="color:#333333;">wx:for</span><span style="color:#333333;">-</span><span style="color:#333333;">item </span><span style="color:#333333;">可以指定当前项的变量名</span></li></ul> 
<p><span style="color:#333333;">(3) wx:key的使用</span></p> 
<p><span style="color:#333333;">类似于Vue列表渲染中的:key,小程序在实现列表渲染时,也建议为渲染出来的列表加key提高渲染的效率</span></p> 
<pre><code class="language-html">&lt;!-- 手动指定索引和当前项的变量名 --&gt;
&lt;view wx:key="index" wx:for="{<!-- -->{ arr1 }}" class="text" wx:for-index="i" wx:for-item="item"&gt; 索引是 {<!-- -->{ i }} 当前项是： {<!-- -->{ item }} &lt;/view&gt;
&lt;!-- wx:key 提高渲染效率 --&gt;
&lt;view wx:key="id" wx:for="{<!-- -->{ arr2 }}" class="text1"&gt; 当前项是： {<!-- -->{ item.username }} &lt;/view&gt;</code></pre> 
<h2>8 WXSS 模块样式</h2> 
<h3>8.1 wxss和css的关系</h3> 
<p>wxss具有css大部分特性,同时,wxss还对css进行了扩充以及修改以适应微信小程序的开发,与css相比,wxss扩展的特性有:</p> 
<ul><li>rpx尺寸单位</li><li>@import样式导入</li></ul> 
<h3>8.2 rpx</h3> 
<p>(1) 什么是rpx单位</p> 
<p>rpx是微信小程序独有的,用来解决屏幕适配的尺寸单位,rpx把所有的屏幕等分为750份(即: 当前屏幕的总宽度为750rpx)</p> 
<p>(2) rpx和px之间的单位换算(了解)</p> 
<h3>8.3 样式导入</h3> 
<p>(1) 语法格式: @import ""引号里需要导入的外联样式表的相对路径,用;结束</p> 
<p>(2) 全局样式: 作用于每一个页面</p> 
<p>(3) 局部样式: 只会作用于当前页面</p> 
<p>注意:</p> 
<ul><li><span style="color:#333333;">当局部样式和全局样式冲突时，根据</span><span style="color:#333333;">就近原则 </span><span style="color:#333333;">，局部样式会覆盖全局样式 </span></li><li><span style="color:#333333;">当局部样式的权重大于或等于全局样式的权重时，才会覆盖全局的样式 </span></li></ul> 
<h2>9 全局配置</h2> 
<h3>9.1 全局配置文件及常用的配置项</h3> 
<p>小程序根目录的app.json文件是小程序的全局配置文件,常用配置项如下:</p> 
<h4>9.1.1 window小程序窗口的组成部分</h4> 
<h4><img alt="" height="278" src="https://images2.imgbox.com/64/54/c4nBZAwl_o.png" width="267"></h4> 
<p></p> 
<h3> 9.1.2 了解window节点常用的配置项</h3> 
<p><img alt="" height="368" src="https://images2.imgbox.com/d1/b8/39mwMecn_o.png" width="811"></p> 
<p> (1) 设置导航栏标题</p> 
<p>步骤: app.json -&gt; window -&gt; navigationBarTitleText</p> 
<p>(2) 设置导航栏的背景色</p> 
<p>步骤: app.json -&gt; window -&gt; navigationBarBackgroundColor(<span style="color:#a2e043;">只支持16进制的颜色写法</span>)</p> 
<p>(3) 设置导航栏的标题颜色</p> 
<p>步骤: app.json -&gt; window -&gt; navigationBarTextStyle(可选值只有white和black)</p> 
<h4>9.1.3 全局下拉刷新功能</h4> 
<p>"enablePullDownRefresh": true</p> 
<p>(1) 设置下拉刷新窗口的颜色</p> 
<p>backgroundColor(颜色只能是16进制)</p> 
<p>(2) 设置下路刷新时loading的样式</p> 
<p>当<span style="color:#333333;">全局开启下拉刷新功能之后，默认窗口的</span><span style="color:#333333;"> loading </span><span style="color:#333333;">样式为白色，如果要更改</span><span style="color:#333333;"> loading 样式的效果,设置步骤为 </span><span style="color:#333333;">app.json</span><span style="color:#333333;"> -&gt; </span><span style="color:#333333;">window</span><span style="color:#333333;"> -&gt; </span><span style="color:#333333;">为 </span><span style="color:#333333;">backgroundTextStyle </span><span style="color:#333333;">指定</span><span style="color:#333333;"> dark </span><span style="color:#333333;">值。</span></p> 
<p> (以color结尾的配置一般都是16进制的颜色,style一般都是配置固定的可选值)</p> 
<p>(3) 在页面.js中的onPullDownRefresh: function () {}里写用户下拉逻辑代码</p> 
<p>(4) 设置上拉触底的距离</p> 
<p><span style="color:#333333;">上拉触底是移动端的专有名词，通过手指在屏幕上的上拉滑动操作，从而加载更多数据的行为。 </span></p> 
<p><span style="color:#333333;">设置步骤： </span><span style="color:#333333;">app.json</span><span style="color:#333333;"> -&gt; </span><span style="color:#333333;">window</span><span style="color:#333333;"> -&gt;</span><span style="color:#333333;">为 </span><span style="color:#333333;">onReachBottomDistance </span><span style="color:#333333;">设置新的数值</span></p> 
<p><span style="color:#333333;">注意：默认距离为</span><span style="color:#333333;">50 </span><span style="color:#333333;">px </span><span style="color:#333333;">，如果没有特殊需求，建议使用默认值即可。 </span></p> 
<p><span style="color:#333333;">onReachBottom: function() {} 上拉触底事件的处理函数</span></p> 
<h3><span style="color:#333333;">9.2 tabBar</span></h3> 
<p><span style="color:#333333;">(1) 什么是tabBar</span></p> 
<p><span style="color:#333333;">tabBar </span><span style="color:#333333;">是移动端应用常见的页面效果，用于实现多页面的快速切换。小程序中通常将其分为： </span></p> 
<ul><li><span style="color:#333333;">底部 </span><span style="color:#333333;">tabBar </span></li><li><span style="color:#333333;">顶部 </span><span style="color:#333333;">tabBar </span></li></ul> 
<p><span style="color:#333333;">注意： </span></p> 
<ul><li><span style="color:#333333;">tabBar </span><span style="color:#333333;">中只能配置最少</span><span style="color:#333333;"> 2 </span><span style="color:#333333;">个、最多</span><span style="color:#333333;"> 5 </span><span style="color:#333333;">个 </span><span style="color:#333333;">tab </span><span style="color:#333333;">页签 </span></li><li><span style="color:#333333;">当渲染顶部 </span><span style="color:#333333;">tabBar </span><span style="color:#333333;">时，不显示 </span><span style="color:#333333;">icon </span><span style="color:#333333;">，只显示文本</span></li></ul> 
<p><span style="color:#333333;"> (2) tabBar的6个组成部分</span></p> 
<p><img alt="" height="166" src="https://images2.imgbox.com/b6/e6/OEWdJZxR_o.png" width="277"></p> 
<p></p> 
<ul><li><span style="color:#333333;">① </span><span style="color:#333333;">backgroundColor </span><span style="color:#333333;">： </span><span style="color:#333333;">tabBar </span><span style="color:#333333;">的背景色 </span></li><li><span style="color:#333333;">② </span><span style="color:#333333;">selectedIconPath </span><span style="color:#333333;">：选中时的图片路径 </span></li><li><span style="color:#333333;">③ </span><span style="color:#333333;">borderStyle</span><span style="color:#333333;">：</span><span style="color:#333333;">tabBar </span><span style="color:#333333;">上边框的颜色 </span></li><li><span style="color:#333333;">④ </span><span style="color:#333333;">iconPath </span><span style="color:#333333;">：未选中时的图片路径 </span></li><li><span style="color:#333333;">⑤ </span><span style="color:#333333;">selectedColor</span><span style="color:#333333;">：</span><span style="color:#333333;">tab </span><span style="color:#333333;">上的文字选中时的颜色 </span></li><li><span style="color:#333333;">⑥ </span><span style="color:#333333;">color</span><span style="color:#333333;">：</span><span style="color:#333333;">tab </span><span style="color:#333333;">上文字的默认（未选中）颜色 </span></li></ul> 
<p><span style="color:#333333;">(3) tabBar配置项</span></p> 
<p><span style="color:#333333;">和window配置平级(标红的表示必选项)</span></p> 
<p><img alt="" height="315" src="https://images2.imgbox.com/bc/ea/9QXdOLtw_o.png" width="814"></p> 
<p> (4) 每个tab项(list数组中每一个对象)的配置项</p> 
<p><img alt="" height="212" src="https://images2.imgbox.com/f7/f8/Eadgqvoz_o.png" width="809"></p> 
<p> <span style="color:#ff9900;">如果是tabBar的页面就必须放在pages配置的前面</span></p> 
<p>(5) 页面配置</p> 
<p><span style="color:#333333;">小程序中， </span><span style="color:#333333;">app.json </span><span style="color:#333333;">中的</span><span style="color:#333333;"> window </span><span style="color:#333333;">节点，可以</span><span style="color:#333333;"><strong>全局配置</strong></span><span style="color:#333333;">小程序中每个页面的窗口表现。 </span></p> 
<p><span style="color:#333333;">如果某些小程序页面</span><span style="color:#333333;"><strong>想要拥有特殊的窗口表现</strong></span><span style="color:#333333;">，此时，页面级别的 </span><span style="color:#333333;">.json </span><span style="color:#333333;">配置文件就可以实现这种需 求。 注意：当页面配置与全局配置冲突时，根据<strong>就近原则</strong>，最终的效果以页面配置为准。 </span></p> 
<p><img alt="" height="331" src="https://images2.imgbox.com/eb/ca/6pBp3xIK_o.png" width="728"></p> 
<p><span style="color:#333333;">注意： </span></p> 
<p><span style="color:#333333;">① 这些配置项</span><span style="color:#333333;">, </span><span style="color:#333333;">在刚才学习的全局配置下的 </span><span style="color:#333333;">window </span><span style="color:#333333;">节点我们已经都学习过了</span><span style="color:#333333;">,</span><span style="color:#333333;">无需额外记忆</span><span style="color:#333333;">. </span></p> 
<p><span style="color:#333333;">② 一般我们不需要每个页面都有下拉刷新的效果，因此，再全局配置文件中，不推荐全局配置下拉刷 新，而是某个列表页面需要开启时，在页面配置文件中，单独开启下拉刷新 </span></p> 
<h2>10 网络数据请求</h2> 
<p>(1) 小程序中网络数据请求的限制</p> 
<p>处于安全性方面的考虑,小程序官方数据接口的请求做出了如下两个限制:</p> 
<p><span style="color:#333333;">① 只能请求 </span><span style="color:#333333;">HTTPS </span><span style="color:#333333;">类型的接口 </span></p> 
<p><span style="color:#333333;">② 必须将接口的域名添加到信任列表中</span></p> 
<p><span style="color:#333333;">(2) 配置request合法域名</span></p> 
<p><span style="color:#333333;">配置步骤：登录微信小程序管理后台</span><span style="color:#333333;"> -&gt; </span><span style="color:#333333;">开发</span><span style="color:#333333;"> -&gt; </span><span style="color:#333333;">开发设置</span><span style="color:#333333;"> -&gt; </span><span style="color:#333333;">服务器域名</span><span style="color:#333333;"> -&gt; </span><span style="color:#333333;">修改 </span><span style="color:#333333;">request </span><span style="color:#333333;">合法域名 </span></p> 
<p><span style="color:#333333;">注意事项</span></p> 
<p><span style="color:#333333;">① 域名只支持 </span><span style="color:#333333;">https </span><span style="color:#333333;">协议 </span></p> 
<p><span style="color:#333333;">② 域名不能使用 </span><span style="color:#333333;">IP </span><span style="color:#333333;">地址或 </span><span style="color:#333333;">localhost </span></p> 
<p><span style="color:#333333;">③ 域名必须经过 </span><span style="color:#333333;">ICP </span><span style="color:#333333;">备案 </span></p> 
<p><span style="color:#333333;">④ 服务器域名一个月内最多可申请</span><span style="color:#333333;"> 5 </span><span style="color:#333333;">次修改</span></p> 
<p><span style="color:#333333;">(3) 发送get请求</span></p> 
<p><span style="color:#333333;">调用微信小程序提供的wx.request()方法,可以发起GET数据请求,实例代码如下:</span></p> 
<p><img alt="" height="410" src="https://images2.imgbox.com/f1/77/USrWnnlN_o.png" width="565"></p> 
<p>(4) 发起post请求</p> 
<pre><code class="language-javascript">// 发起GET请求
onTapPost () {
    wx.request({
        // 请求地址，必须是以https://开头
        // 必须是配置在request合法域名
        url: 'https://www.escook.cn/api/post',
        // 请求方式
        method: 'POST',
        // 请求参数
        data: { name: 'lisi', age: 18 },
        // 请求成功的回调
        success: (res) =&gt; {
            console.log(res)
        }
    })</code></pre> 
<p> (5) 在页面刚加载时请求数据(生命周期onLoad)</p> 
<p>在js文件中的onLoad: function() {} 调用请求函数</p> 
<p>(6) 跳过request合法域名效验</p> 
<p><span style="color:#333333;">如果后端程序员</span><span style="color:#333333;">仅仅提供了 </span><span style="color:#333333;">http </span><span style="color:#333333;">协议的接口、暂时没有提供 </span><span style="color:#333333;">https </span><span style="color:#333333;">协议的接口</span></p> 
<p><span style="color:#333333;">此时为了不耽误开发的进度，我们可以在微信开发者工具中，临时开启「开发环境不校验合法域名、 </span><span style="color:#333333;">web-view(</span><span style="color:#333333;">业务域名</span><span style="color:#333333;">)</span><span style="color:#333333;">、 </span><span style="color:#333333;">TLS </span><span style="color:#333333;">版本及 </span><span style="color:#333333;">HTTPS </span><span style="color:#333333;">证书</span><span style="color:#333333;">」选项，跳过 </span><span style="color:#333333;">request 合法域名的校验</span></p> 
<p></p> 
<p><span style="color:#333333;">注意： </span></p> 
<p><span style="color:#333333;">跳过 </span><span style="color:#333333;">request </span><span style="color:#333333;">合法域名校验的选项，仅限在</span><span style="color:#333333;"><strong>开发与调试阶段</strong></span><span style="color:#333333;">使用！ </span></p> 
<p>(7) 关于跨域和Ajax的说明</p> 
<p><span style="color:#333333;">跨域问题只存在于基于浏览器的 </span><span style="color:#333333;">Web </span><span style="color:#333333;">开发中。由于小程序的宿主环境不是浏览器，而是微信客户端， 所以小程序中不存在跨域的问题。</span></p> 
<p><span style="color:#333333;">Ajax </span><span style="color:#333333;">技术的核心是依赖于浏览器中的 </span><span style="color:#333333;">XMLHttpRequest </span><span style="color:#333333;">这个对象，由于小程序的宿主环境是微信客户端，所以小程序中不能叫做“</span><span style="color:#333333;">发起 </span><span style="color:#333333;">Ajax </span><span style="color:#333333;">请求</span><span style="color:#333333;">”</span><span style="color:#333333;">，而是叫做</span><span style="color:#333333;">“</span><span style="color:#333333;">发起网络数据请求</span><span style="color:#333333;">”</span><span style="color:#333333;">。 </span></p> 
<h2><span style="color:#333333;">11 页面导航</span></h2> 
<h3><span style="color:#333333;">11.1 声明式导航</span></h3> 
<p><span style="color:#333333;">（1）导航到tabBar页面</span></p> 
<p>在使用&lt;navigator&gt;组件跳转到指定的tabBar页面时,需要指定url属性和open-type属性,其中:</p> 
<ul><li>url表示要跳转的地址,必须以/开头</li><li>open-type表示跳转的方式,必须为switchTab</li></ul> 
<p>(2) 导航到非tabBar页面</p> 
<ul><li>url表示要跳转的地址,必须以/开头</li><li>open-type表示跳转的方式,必须为navigate(可以简写)</li></ul> 
<p>(3) 后退导航</p> 
<p>如果要后退到上一页面或多级页面,则需要指定open-type和delta属性</p> 
<ul><li>delta属性默认是1(可以不写)</li><li>open-type表示跳转的方式,必须为navigateBack</li></ul> 
<h3>11.2 编程导航</h3> 
<p>(1) 导航到tabBar页面</p> 
<p><span style="color:#333333;">调用 </span><span style="color:#333333;">wx.switchTab(Object object) </span><span style="color:#333333;">方法，可以跳转到 </span><span style="color:#333333;">tabBar </span><span style="color:#333333;">页面。其中 </span><span style="color:#333333;">Object </span><span style="color:#333333;">参数对象的属性列表如下</span></p> 
<p><img alt="" height="195" src="https://images2.imgbox.com/8b/63/6ic9yvvL_o.png" width="561"></p> 
<p> wx.switchTab({<!-- --></p> 
<p>  url: ''</p> 
<p>})</p> 
<p>(2) 导航到非tabBar页面(wx.navigateTo)</p> 
<p>(2) 后退导航wx.navigateBack</p> 
<p><img alt="" height="208" src="https://images2.imgbox.com/4d/f9/bkMq1Pn7_o.png" width="816"></p> 
<h3> 11.3 导航传参</h3> 
<p>(1) 声明式导航传参</p> 
<p><span style="color:#333333;">navigator </span><span style="color:#333333;">组件的 </span><span style="color:#333333;">url </span><span style="color:#333333;">属性用来指定将要跳转到的页面的路径。同时，路径的后面还可以携带参数： </span></p> 
<ul><li><span style="color:#333333;">参数与路径之间使用</span><span style="color:#333333;"> ? </span><span style="color:#333333;">分隔 </span></li><li><span style="color:#333333;">参数键与参数值用</span><span style="color:#333333;"> = </span><span style="color:#333333;">相连 </span></li><li><span style="color:#333333;">不同参数用</span><span style="color:#333333;"> &amp; </span><span style="color:#333333;">分隔 </span></li></ul> 
<p><span style="color:#333333;">(2) 编程式导航传参</span></p> 
<p><span style="color:#333333;">调用 </span><span style="color:#333333;">wx.navigateTo(Object object) </span><span style="color:#333333;">方法跳转页面时，也可以携带参数，代码示例如下：</span></p> 
<p><span style="color:#a2e043;">小程序中: 导航传参的方式,全部都是用的查询字符串</span></p> 
<p>(3) 在onLoad中接收导航的传参</p> 
<p>通过声明式导航<span style="color:#333333;">或</span><span style="color:#333333;">编程式导航传参</span><span style="color:#333333;">所携带的参数，可以直接在 </span><span style="color:#333333;">onLoad </span><span style="color:#333333;">事件中直接获取到(</span><span style="color:#ff9900;">跳转到非tabBar页面才可以接收</span><span style="color:#333333;">)</span></p> 
<p>(4) wx.showLoading显示加载提示效果wx.hideLoading隐藏加载提示效果,{ title: 加载显示文本 }</p> 
<p>(5) complete: wx.request中网络请求完成后(无论成功还是失败)进入的回调函数</p> 
<h2>12 小程序的生命周期</h2> 
<h3>12.1 应用的生命周期</h3> 
<p>(1) 特指小程序从启动 -&gt; 运行 -&gt; 销毁的过程</p> 
<p>(2) 小程序的应用生命周期函数需要在app.js中进行声明</p> 
<p>(3) 应用生命周期函数</p> 
<ul><li>onLaunch钩子函数: 小程序初始化完成后, 会触发onLaunch</li><li>onShow: 小程序启动, 或从后台进入前台显示时触发</li><li>onHide: 小程序从前台进去后台时触发</li></ul> 
<h3>12.2 页面的生命周期</h3> 
<p>(1) 特指小程序中, 每个页面的加载-&gt; 渲染 -&gt; 销毁过程</p> 
<p>(2) 在对应页面的js文件中声明</p> 
<p>(3) 应用的生命周期函数</p> 
<ul><li>onLoad: 监听页面加载,一个页面触发一次</li><li>onShow: 页面显示/切入前台时触发</li><li>onReady: 页面初次渲染完成,一个页面触发一次</li><li>onHide: 页面隐藏</li><li>onUnload: 页面卸载,一个页面触发一次</li></ul> 
<p>其中, 页面的生命周期范围较小, 应用程序的生命周期范围较大</p> 
<h2>13 wxs</h2> 
<h3>13.1 概念</h3> 
<p><span style="color:#333333;">WXS </span><span style="color:#333333;">（ </span><span style="color:#333333;">WeiXin Script </span><span style="color:#333333;">）是小程序独有的一套脚本语言，结合 </span><span style="color:#333333;">WXML </span><span style="color:#333333;">，可以构建出页面的结构。 </span></p> 
<p><span style="color:#333333;">wxml </span><span style="color:#333333;">中无法调用在页面的 </span><span style="color:#333333;">.js </span><span style="color:#333333;">中定义的函数（不包括事件绑定），但是， </span><span style="color:#333333;">wxml </span><span style="color:#333333;">中可以调用 </span><span style="color:#333333;">wxs </span><span style="color:#333333;">中定义的函数。因此，小程序中 wxs </span><span style="color:#333333;">的典型应用场景就是“过滤器</span></p> 
<h3><span style="color:#333333;">13.2 wxs和js的关系</span></h3> 
<p><span style="color:#333333;">虽然 </span><span style="color:#333333;">wxs </span><span style="color:#333333;">的语法类似于 </span><span style="color:#333333;">JavaScript </span><span style="color:#333333;">，但是 </span><span style="color:#333333;">wxs </span><span style="color:#333333;">和 </span><span style="color:#333333;">JavaScript </span><span style="color:#333333;">是完全不同的两种语言： </span></p> 
<p><span style="color:#333333;">① </span><span style="color:#333333;">wxs </span><span style="color:#333333;">有自己的数据类型 </span></p> 
<ul><li><span style="color:#333333;">number </span><span style="color:#333333;">数值类型、 </span><span style="color:#333333;">string </span><span style="color:#333333;">字符串类型、 </span><span style="color:#333333;">boolean </span><span style="color:#333333;">布尔类型、 </span><span style="color:#333333;">object </span><span style="color:#333333;">对象类型、 </span></li><li><span style="color:#333333;">function </span><span style="color:#333333;">函数类型、 </span><span style="color:#333333;">array </span><span style="color:#333333;">数组类型、 </span><span style="color:#333333;">date </span><span style="color:#333333;">日期类型、 </span><span style="color:#333333;">regexp </span><span style="color:#333333;">正则 </span></li></ul> 
<p><span style="color:#333333;">② </span><span style="color:#333333;">wxs </span><span style="color:#333333;">不支持类似于 </span><span style="color:#333333;">ES6 </span><span style="color:#333333;">及以上的语法形式 </span></p> 
<ul><li><span style="color:#333333;">不支持： </span><span style="color:#333333;">let </span><span style="color:#333333;">、 </span><span style="color:#333333;">const </span><span style="color:#333333;">、解构赋值、展开运算符、箭头函数、对象属性简写、</span><span style="color:#333333;">etc... </span></li><li><span style="color:#333333;">支持： </span><span style="color:#333333;">var </span><span style="color:#333333;">定义变量、普通 </span><span style="color:#333333;">function </span><span style="color:#333333;">函数等类似于 </span><span style="color:#333333;">ES5 </span><span style="color:#333333;">的语法 </span></li></ul> 
<p><span style="color:#333333;">③ </span><span style="color:#333333;">wxs </span><span style="color:#333333;">遵循 </span><span style="color:#333333;">CommonJS </span><span style="color:#333333;">规范 </span></p> 
<ul><li><span style="color:#333333;">module </span><span style="color:#333333;">对象 </span></li><li><span style="color:#333333;">require() </span><span style="color:#333333;">函数 </span></li><li><span style="color:#333333;">module.exports </span><span style="color:#333333;">对象 </span></li></ul> 
<h3><span style="color:#333333;">13.3 基础语法</span></h3> 
<p><span style="color:#333333;">(1) 内嵌wxs脚本</span></p> 
<p><span style="color:#333333;">wxs </span><span style="color:#333333;">代码可以编写在 </span><span style="color:#333333;">wxml </span><span style="color:#333333;">文件中的 标签内，就像 </span><span style="color:#333333;">Javascript </span><span style="color:#333333;">代码可以编写在 </span><span style="color:#333333;">html 文件中的标签内一样。 </span></p> 
<pre><code class="language-html">&lt;!-- 定义一个文本，调用wxs中的方法 --&gt;
&lt;view&gt;{<!-- -->{ m1.toUpper(username) }}&lt;/view&gt;
&lt;!-- 定义一个wxs的标签，并指定module模块名称 --&gt;
&lt;wxs module="m1"&gt;
&lt;!-- 向外暴露一个方法 --&gt;
module.exports.toUpper = function(str) { return str.toUpperCase() }
&lt;/wxs&gt;</code></pre> 
<p><span style="color:#333333;">wxml </span><span style="color:#333333;">文件中的每个标签，必须提供 </span><span style="color:#333333;">module </span><span style="color:#333333;">属性，用来指定当前 </span><span style="color:#333333;">wxs 的模块名称，方便在wxml 中访问模块中的成员</span></p> 
<p><span style="color:#333333;">(2) 外联wxs</span></p> 
<p><span style="color:#333333;">wxs </span><span style="color:#333333;">代码还可以编写在以 </span><span style="color:#333333;">.wxs </span><span style="color:#333333;">为后缀名的文件内，就像 </span><span style="color:#333333;">Javascript </span><span style="color:#333333;">代码可以编写在以 </span><span style="color:#333333;">.js 为后缀名的文件中一样。</span></p> 
<p><span style="color:#333333;">在 </span><span style="color:#333333;">wxml </span><span style="color:#333333;">中引入外联的 </span><span style="color:#333333;">wxs </span><span style="color:#333333;">脚本时，必须为 标签添加 </span><span style="color:#333333;">module </span><span style="color:#333333;">和 </span><span style="color:#333333;">src 属性，其中：</span></p> 
<ul><li><span style="color:#333333;">module </span><span style="color:#333333;">用来指定模块的名称 </span></li><li><span style="color:#333333;">src </span><span style="color:#333333;">用来指定要引入的脚本的路径，且必须是</span><span style="color:#333333;"><strong>相对路径</strong></span></li></ul> 
<p><span style="color:#333333;"><strong>wx.</strong></span><strong><span style="color:#000000;">stopPullDownRefresh合并下拉刷新</span></strong></p> 
<h2>14 自定义组件</h2> 
<h3>14.1 组件的创建和使用</h3> 
<p>(1) 创建组件</p> 
<p><span style="color:#333333;">① 在项目的根目录中，鼠标右键，创建 </span><span style="color:#333333;">components</span><span style="color:#333333;"> -&gt; </span><span style="color:#333333;">test </span><span style="color:#333333;">文件夹 </span></p> 
<p><span style="color:#333333;">② 在新建的 </span><span style="color:#333333;">components</span><span style="color:#333333;"> -&gt; </span><span style="color:#333333;">test </span><span style="color:#333333;">文件夹上，鼠标右键，点击</span><span style="color:#333333;">“</span><span style="color:#333333;">新建 </span><span style="color:#333333;">Component </span><span style="color:#333333;">” </span></p> 
<p><span style="color:#333333;">③ 键入组件的名称之后回车，会自动生成组件对应的</span><span style="color:#333333;"> 4 </span><span style="color:#333333;">个文件，后缀名分别为 </span><span style="color:#333333;">.js </span><span style="color:#333333;">， </span><span style="color:#333333;">.json </span><span style="color:#333333;">， </span><span style="color:#333333;">.wxml 和 .wxss </span></p> 
<p><span style="color:#333333;">注意：为了保证目录结构的清晰，建议把不同的组件，存放到单独目录中</span></p> 
<p>(2) <span style="color:#333333;">局部引用组件</span></p> 
<p><span style="color:#333333;">在页面的 </span><span style="color:#333333;">.json </span><span style="color:#333333;">配置文件中引用组件的方式，叫做</span><span style="color:#333333;">“</span><span style="color:#333333;">局部引用</span><span style="color:#333333;">”</span><span style="color:#333333;">。示例代码如下：</span></p> 
<p><span style="color:#333333;">{ </span></p> 
<p><span style="color:#000000;">        "usingComponents"</span><span style="color:#333333;">: { </span></p> 
<p><span style="color:#000000;">                "my-test1"</span><span style="color:#333333;">: </span><span style="color:#aa1111;">"/components/test/test" </span></p> 
<p><span style="color:#333333;">        } </span></p> 
<p><span style="color:#333333;">} </span></p> 
<p>(3) 全局引入</p> 
<div> 
 <p><span style="color:#333333;">在 </span><span style="color:#333333;">app.json </span><span style="color:#333333;">全局配置文件中引用组件的方式，叫做</span><span style="color:#333333;">“</span><span style="color:#333333;">全局引用</span><span style="color:#333333;">”</span><span style="color:#333333;">。示例代码如下： </span></p> 
 <p><span style="color:#aa1111;">"usingComponents"</span><span style="color:#333333;">: { </span></p> 
 <p><span style="color:#000000;">        "my-test2"</span><span style="color:#333333;">: </span><span style="color:#aa1111;">"/components/test2/test2" </span></p> 
 <p><span style="color:#333333;">} </span></p> 
 <p><span style="color:#333333;">(4) 全局引入和局部引入</span></p> 
 <p></p> 
 <p><span style="color:#333333;">根据组件的使用频率和范围，来选择合适的引用方式： </span></p> 
 <ul><li><span style="color:#333333;">如果某组件在多个页面中经常被用到，建议进行</span><span style="color:#333333;">“</span><span style="color:#333333;">全局引用</span><span style="color:#333333;">” </span></li><li><span style="color:#333333;">如果某组件只在特定的页面中被用到，建议进行</span><span style="color:#333333;">“</span><span style="color:#333333;">局部引用</span><span style="color:#333333;">” </span></li></ul> 
 <p>(5) 组件和页面的区别</p> 
 <p><span style="color:#333333;">从表面来看，组件和页面都是由 </span><span style="color:#333333;">.js </span><span style="color:#333333;">、 </span><span style="color:#333333;">.json </span><span style="color:#333333;">、 </span><span style="color:#333333;">.wxml </span><span style="color:#333333;">和 </span><span style="color:#333333;">.wxss 这四个文件组成的。但是，组件和页面的 </span><span style="color:#333333;">.js </span><span style="color:#333333;">与 </span><span style="color:#333333;">.json </span><span style="color:#333333;">文件有明显的不同：</span></p> 
 <ul><li><span style="color:#333333;">组件的 </span><span style="color:#333333;">.json </span><span style="color:#333333;">文件中需要声明 </span><span style="color:#333333;">"component": true </span><span style="color:#333333;">属性 </span></li><li><span style="color:#333333;">组件的 </span><span style="color:#333333;">.js </span><span style="color:#333333;">文件中调用的是 </span><span style="color:#333333;">Component() </span><span style="color:#333333;">函数 </span> 
   <ul><li><span style="color:#333333;">整个程序启动调用的是 </span><span style="color:#333333;">App() </span></li><li><span style="color:#333333;">某个页面的渲染调用的是 </span><span style="color:#333333;">Page() </span></li><li><span style="color:#333333;">某个组件的渲染调用的是 </span><span style="color:#333333;">Component() </span></li></ul></li><li><span style="color:#333333;">组件的事件处理函数需要定义到 </span><span style="color:#333333;">methods </span><span style="color:#333333;">节点中</span></li></ul> 
 <h3><span style="color:#333333;">14.2 组件的样式</span></h3> 
 <p><span style="color:#333333;">(1) 组件样式隔离</span></p> 
 <p><span style="color:#333333;">默认情况下，自定义组件的样式只对当前组件生效，不会影响到组件之外的 </span><span style="color:#333333;">UI </span><span style="color:#333333;">结构</span></p> 
 <p><span style="color:#333333;">组件样式的隔离性的好处有： </span></p> 
 <p><span style="color:#333333;">① 防止外界的样式影响组件内部的样式 </span></p> 
 <p><span style="color:#333333;">② 防止组件的样式破坏外界的样式 </span></p> 
 <p><span style="color:#333333;">(2) 组件样式隔离的注意点</span></p> 
 <ul><li><span style="color:#333333;">app.wxss </span><span style="color:#333333;">中的全局样式对组件无效 </span></li><li><span style="color:#333333;">只有 </span><span style="color:#333333;">class </span><span style="color:#333333;">选择器会有样式隔离效果， </span><span style="color:#333333;">id </span><span style="color:#333333;">选择器、属性选择器、标签选择器不受样式隔离的影</span><span style="color:#333333;">响</span></li></ul> 
 <p>建议：在组件和引用组件的页面中建议使用 class 选择器，不要使用 id、属性、标签选择器！因为在绝大多数情况下, 我们希望组件的样式是隔离开的</p> 
 <p>(3) 修改组件的样式隔离选项</p> 
 <p><span style="color:#333333;">默认情况下，自定义组件的样式隔离特性能够防止组件内外样式互相干扰的问题。 </span></p> 
 <p><span style="color:#333333;">但有时，我们希望在外界能够控制组件内部的样式，此时，可以通过 </span><span style="color:#333333;">styleIsolation </span><span style="color:#333333;">修改组件的样式隔离选项，用法如下</span></p> 
 <p></p> 
 <div> 
  <pre><code class="language-javascript">// 在组件的.js 文件中新增加如下配置
Component({
        options: {
                // 默认值isolated: 代表启动样式隔离
                // apply-shared: 代表页面wxss样式将影响自定义组件
                // shared: 代表双向的影响
                styleIsolation: 'isolated'
                }
})
// 或在组件的.json 文件中新增加如下配置
{
        "styleIsolation": "isolated"
}</code></pre> 
  <div></div> 
 </div> 
</div> 
<p> (4) styleIsolation的可选值</p> 
<p><img alt="" height="238" src="https://images2.imgbox.com/b3/78/igQ86WJJ_o.png" width="1105"></p> 
<h3> 14.3 组件数据, 方法和属性</h3> 
<p>(1) 页面布局</p> 
<div> 
 <pre><code class="language-html">&lt;!--components/test/test.wxml--&gt;
&lt;button&gt;N1的值: {<!-- -->{ n1 }}&lt;/button&gt;
&lt;button&gt;N2的值: {<!-- -->{ n2 }}&lt;/button&gt;
&lt;button&gt;N1 + N2的值: {<!-- -->{ sum }}&lt;/button&gt;
&lt;button bindtap="addN1" type="warn"&gt;N1 + 1&lt;/button&gt;
&lt;button bindtap="subN2" type="warn"&gt;N2 - 1&lt;/button&gt;</code></pre> 
 <p> (2) data数据</p> 
 <p><span style="color:#333333;">在小程序组件中，用于组件模板渲染的私有数据，需要定义到 </span><span style="color:#333333;">data </span><span style="color:#333333;">节点中</span></p> 
 <div> 
  <pre><code class="language-javascript">/**
* 组件的初始数据
*/
data: {
n1: 0,
n2: 5,
sum: 0
},</code></pre> 
  <p>(3) methods 方法</p> 
  <p><span style="color:#333333;">在小程序组件中，</span><span style="color:#333333;"><strong>事件处理函数</strong></span><span style="color:#333333;">和</span><span style="color:#333333;"><strong>自定义方法</strong></span><span style="color:#333333;">需要定义到 </span><span style="color:#333333;">methods </span><span style="color:#333333;">节点中，示例代码如下： </span></p> 
  <pre><code class="language-javascript">/**
* 组件的方法列表
*/
methods: {
        // 点击事件处理函数
        addN1 () {
        },
        subN2 () {
        },
        // 自定义方法： 建议和事件绑定区分开： 以 _开头
        _toast () {
        }
},</code></pre> 
  <div></div> 
 </div> 
</div> 
<p>(4) properties属性</p> 
<p><span style="color:#333333;">在小程序组件中， </span><span style="color:#333333;">properties </span><span style="color:#333333;">是组件的对外属性，用来接收外界</span><span style="color:#333333;">(</span><span style="color:#333333;">父组件</span><span style="color:#333333;">)</span><span style="color:#333333;">传递到组件中的数据</span></p> 
<div> 
 <span style="color:#000000;">Components</span> 
 <span style="color:#333333;">({ </span> 
</div> 
<div> 
 <span style="color:#aa5500;">        // 属性定义 </span> 
</div> 
<div> 
 <span style="color:#000000;">        properties</span> 
 <span style="color:#333333;">: { </span> 
</div> 
<div> 
 <span style="color:#aa5500;">        // 完整定义 属性的方式【当需要指定属性默认值时，建议使用此方式】 </span> 
</div> 
<div> 
 <span style="color:#000000;">                max</span> 
 <span style="color:#333333;">: {<!-- --></span> 
</div> 
<div> 
 <span style="color:#aa5500;">                       // 属性值的数据类型 </span> 
</div> 
<div> 
 <span style="color:#000000;">                        type</span> 
 <span style="color:#333333;">: </span> 
 <span style="color:#000000;">Number</span> 
 <span style="color:#333333;">, </span> 
</div> 
<div> 
 <span style="color:#aa5500;">                        // 属性值的默认值 </span> 
</div> 
<div> 
 <span style="color:#000000;">                        value</span> 
 <span style="color:#333333;">: </span> 
 <span style="color:#116644;">10 </span> 
</div> 
<div> 
 <span style="color:#333333;">                },</span> 
</div> 
<div> 
 <span style="color:#aa5500;">        // 简化定义 属性的方式 </span> 
</div> 
<div> 
 <span style="color:#000000;">        </span> 
</div> 
<div> 
 <span style="color:#333333;">: </span> 
 <span style="color:#000000;">Number </span> 
</div> 
<div> 
 <span style="color:#333333;">        } </span> 
</div> 
<div> 
 <span style="color:#333333;">})</span> 
</div> 
<div></div> 
<p><span style="color:#981a1a;">&lt;</span><span style="color:#000000;">my</span><span style="color:#981a1a;">-</span><span style="color:#000000;">test1 max</span><span style="color:#981a1a;">=</span><span style="color:#aa1111;">"10"</span><span style="color:#981a1a;">&gt;&lt;</span><span style="color:#ff5500;">/my-test1&gt;</span></p> 
<p>(5) data 和 properties的区别</p> 
<p><span style="color:#333333;">在小程序的组件中， </span><span style="color:#333333;">properties </span><span style="color:#333333;">属性和 </span><span style="color:#333333;">data </span><span style="color:#333333;">数据的用法相同，它们都是</span><span style="color:#333333;"><strong>可读可写</strong></span><span style="color:#333333;">的，只不过</span></p> 
<div> 
 <ul><li><span style="color:#333333;">data </span><span style="color:#333333;">更倾向于存储组件的私有数据 </span></li><li><span style="color:#333333;">properties </span><span style="color:#333333;">更倾向于存储外界传递到组件中的数据 </span> 
   <ul><li><span style="color:#333333;">所以</span><span style="color:#333333;">, </span><span style="color:#333333;">也不太建议修改 </span><span style="color:#333333;">properties </span><span style="color:#333333;">数据</span><span style="color:#333333;">, </span></li><li><span style="color:#333333;">如果要修改 </span><span style="color:#333333;">properties </span><span style="color:#333333;">的数据</span><span style="color:#333333;">, </span><span style="color:#333333;">最好通过子组件通信给父组件的方式实现 </span></li></ul></li></ul> 
 <p>(6) 修改properties的值</p> 
 <p>由于<span style="color:#333333;">data </span><span style="color:#333333;">数据和 </span><span style="color:#333333;">properties </span><span style="color:#333333;">属性在本质上没有任何区别，因此 </span><span style="color:#333333;">properties 属性的值也可以用于页面渲染,或使用 </span><span style="color:#333333;">setData </span><span style="color:#333333;">为 </span><span style="color:#333333;">properties </span><span style="color:#333333;">中的属性重新赋值</span></p> 
 <p><span style="color:#333333;">(</span><span style="color:#a2e043;">不过不建议直接在子组件内直接修改,因为一旦修改,他不会同步到父组件中</span><span style="color:#333333;">)</span></p> 
 <h2><span style="color:#333333;">15 数据监听器</span></h2> 
 <p><span style="color:#333333;">(1) 什么是数据监听器</span></p> 
 <p><span style="color:#333333;">数据监听器用于</span><span style="color:#333333;"><strong>监听</strong></span><span style="color:#333333;">和响应任何属性和数据字段的变化，从而执行特定的操作。</span></p> 
 <p><span style="color:#333333;">它的作用类似于 </span><span style="color:#333333;">vue </span><span style="color:#333333;">中的 </span><span style="color:#333333;">watch </span><span style="color:#333333;">侦听器。</span></p> 
 <p><span style="color:#333333;">在小程序组件中</span><span style="color:#333333;">,</span><span style="color:#333333;">数据监听器的基本语法格式如下：</span></p> 
 <p><span style="color:#333333;">Components({<!-- --></span></p> 
 <p>        <span style="color:#000000;">observers: {<!-- --></span></p> 
 <p><span style="color:#000000;">                '</span><span style="color:#000000;">字段</span><span style="color:#000000;">A</span><span style="color:#000000;">， 字段</span><span style="color:#000000;">B'</span><span style="color:#333333;">: </span><span style="color:#770088;">function</span><span style="color:#333333;">(</span><span style="color:#0000ff;">字段</span><span style="color:#0000ff;">A</span><span style="color:#0000ff;">的新值， </span><span style="color:#000000;">字段</span><span style="color:#000000;">B</span><span style="color:#000000;">的新值</span><span style="color:#333333;">) { // do something }</span></p> 
 <p><span style="color:#000000;">        }</span></p> 
 <p><span style="color:#333333;">})</span></p> 
 <p>(3) 监听对象属性的变化</p> 
 <p>方式一: 普通方式</p> 
 <div> 
  <pre><code class="language-javascript">Components({
// observers: 观察者
observers: {
    '对象.属性A， 对象.属性B': function(属性A的新值， 属性B的新值) {
        // 触发此侦听器的 3 种情况：
        // 【为属性A赋值】：使用setData 设置this.data.对象.属性A 时触发
        // 【为属性B赋值】：使用setData 设置this.data.对象.属性B 时触发
        // 【为对象赋值】：使用setData 设置this.data.对象 时触发
    }
})</code></pre> 
  <p>方式二: <span style="color:#333333;">通配符方式</span><span style="color:#333333;">, </span><span style="color:#333333;">监听对象中所有属性的变化</span></p> 
  <div> 
   <pre><code class="language-javascript">observers: {
    '_rgb.**': function (obj) {
        this.setData({
            fullColor:`${obj.r}, ${obj.g}, ${obj.b}`
        })
    }
}</code></pre> 
   <h2>16 纯数据字段</h2> 
   <h3>16.1 纯数据字段概述</h3> 
   <p>(1) 概念: <span style="color:#333333;">纯数据字段指的是那些不用于界面渲染的 </span><span style="color:#333333;">data </span><span style="color:#333333;">字段。</span></p> 
   <p><span style="color:#333333;">(2) 应用场景: 例如有些情况下，某些 data 中的字段既不会展示在界面上，也不会传递给其他组件，仅仅在当前</span><span style="color:#333333;">组件内部使用。带有这种特性的 </span><span style="color:#333333;">data 字段适合被设置为纯数据字段。例如之前控制上拉加载更多的节阀 </span><span style="color:#333333;">isLoading </span><span style="color:#333333;">这种类型的数据</span></p> 
   <p><span style="color:#333333;">(3) 使用纯数据的好处</span><span style="color:#333333;">:</span><span style="color:#333333;">纯数据字段有助于</span><span style="color:#333333;">提升页面更新的性能</span></p> 
   <p><span style="color:#333333;">(4) 因为在小程序中， </span><span style="color:#333333;">data 中声明的数据，会具备一个响应式的效果，系统的底层会对数据进行值变化的监听,如果该数据只是纯数据，没有必要进行响应式的监听，因此定义为纯数据能够提高页面的性能</span><span style="color:#333333;">.</span></p> 
   <h3><span style="color:#333333;">16.2 使用</span></h3> 
   <p><span style="color:#333333;">在 </span><span style="color:#333333;">Component </span><span style="color:#333333;">构造器的 </span><span style="color:#333333;">options </span><span style="color:#333333;">节点中，指定 </span><span style="color:#333333;">pureDataPattern </span><span style="color:#333333;">为一个 正则表达式 ，字段名符合这个正则</span><span style="color:#333333;">表达式的字段将会被视为纯数据字段，示例代码如下： </span></p> 
   <div> 
    <pre><code class="language-javascript">Component({
    options: {
        // 指定所有_开头的数据字段为 纯数据字段
        pureDataPattern: /^_/
    },
    data: {
        a: true, // 普通数据字段
        _b: true // 纯数据字段
    }
})</code></pre> 
    <h2>17 组件的生命周期</h2> 
    <h3>17.1 概述</h3> 
    <p>(1) 组件的全部生命周期</p> 
    <p><img alt="" height="395" src="https://images2.imgbox.com/ee/e4/OrxEfRs1_o.png" width="1127"></p> 
    <p>注意: <span style="color:#a2e043;">其中created生命周期和vue中的created不同, 反而和beforeCreated相似</span></p> 
    <p> (2) 组件主要的生命周期函数</p> 
    <p><span style="color:#333333;">在小程序组件中，最重要的生命周期函数是 </span><span style="color:#333333;">created </span><span style="color:#333333;">、 </span><span style="color:#333333;">attached </span><span style="color:#333333;">、 </span><span style="color:#333333;">ready </span><span style="color:#333333;">、 </span><span style="color:#333333;">detached 。它们各自的特点如下:</span></p> 
    <p><span style="color:#333333;">① 组件实例刚被创建好的时候， </span><span style="color:#333333;">created </span><span style="color:#333333;">生命周期函数会被触发 </span></p> 
    <ul><li><span style="color:#333333;">此时调用 </span><span style="color:#333333;">setData </span><span style="color:#333333;">不会有效果 </span></li><li><span style="color:#333333;">通常在这个生命周期函数中，只应该用于给组件的 </span><span style="color:#333333;">this </span><span style="color:#333333;">添加一些自定义的属性字段 </span></li></ul> 
    <p><span style="color:#333333;">② 在组件完全初始化完毕、进入页面节点树后， </span><span style="color:#333333;">attached </span><span style="color:#333333;">生命周期函数会被触发 </span></p> 
    <ul><li><span style="color:#333333;">此时， </span><span style="color:#333333;">this.data </span><span style="color:#333333;">已被初始化完毕 </span></li><li><span style="color:#333333;">这个生命周期很有用，绝大多数</span><span style="color:#333333;"><strong>初始化的工作</strong></span><span style="color:#333333;">可以在这个时机进行（例如发请求获取初始数据） </span></li></ul> 
    <p><span style="color:#333333;">③ 在组件离开页面节点树后， </span><span style="color:#333333;">detached </span><span style="color:#333333;">生命周期函数会被触发 </span></p> 
    <ul><li><span style="color:#333333;">退出一个页面时，会触发页面内每个自定义组件的 </span><span style="color:#333333;">detached </span><span style="color:#333333;">生命周期函数 </span></li><li><span style="color:#333333;">此时适合做一些清理性质的工作</span><span style="color:#333333;">,</span><span style="color:#333333;">例如</span><span style="color:#333333;">,</span><span style="color:#333333;">清除定时器 </span></li></ul> 
    <p><span style="color:#333333;">④ 代表组件渲染完成的生命周期函数为 </span><span style="color:#333333;">ready </span></p> 
    <ul><li><span style="color:#333333;">可以操作页面</span></li></ul> 
    <p><span style="color:#333333;">(3) lifetimes节点</span></p> 
    <p><span style="color:#333333;">在小程序组件中，生命周期函数可以直接定义在 </span><span style="color:#333333;">Component 构造器的第一级参数中，也可以在lifetimes </span><span style="color:#333333;">字段内进行声明（这是推荐的方式，其优先级最高）。</span></p> 
    <pre><code class="language-javascript">lifetimes: {

        attached() {}, // 在组件实例进入页面节点树时执行

        detached() {}, // 在组建实例被从页面节点树移除时执行

}</code></pre> 
    <h3>17.2 组件所在页面的生命周期</h3> 
    <p>(1) 什么是组件所在页面的生命周期</p> 
    <p><span style="color:#333333;">有时，</span><span style="color:#333333;">自定义组件的行为依赖于页面状态的变化</span><span style="color:#333333;">，此时就需要用到组件所在页面的生命周期。</span></p> 
    <p><span style="color:#333333;">例如：每当触发</span><span style="color:#333333;">页面</span><span style="color:#333333;">的</span><span style="color:#333333;"> show </span><span style="color:#333333;">生命周期函数的时候，我们希望能够重新生成一个随机的 </span><span style="color:#333333;">RGB </span><span style="color:#333333;">颜色值。</span></p> 
    <p><span style="color:#333333;">在自定义组件中，组件所在页面的生命周期函数有如下 3 个</span></p> 
    <p><img alt="" height="235" src="https://images2.imgbox.com/8e/36/33YSHWZO_o.png" width="1106"></p> 
    <p><span style="color:#333333;">所以组件所在页面的生命周期</span><span style="color:#333333;">, </span><span style="color:#333333;">相当于在组件中</span><span style="color:#333333;">, </span><span style="color:#333333;">监听了组件所在页面的一些事件:</span></p> 
    <p><span style="color:#333333;">(3) pageLifetimes节点</span></p> 
    <p><span style="color:#333333;">组件所在页面的生命周期函数，需要定义在 </span><span style="color:#333333;">pageLifetimes </span><span style="color:#333333;">节点中:</span></p> 
    <div> 
     <pre><code class="language-javascript">Component({
        // 组件在页面的生命周期函数在该节点定义
        pageLifetimes: {
                show () {}, // 页面被展示
                hide () {}, // 页面被隐藏
                resize () {} // 页面尺寸变化
        }
})</code></pre> 
     <h2>18 插槽</h2> 
     <p>(1) 什么是插槽</p> 
     <p><span style="color:#333333;">在自定义组件的 </span><span style="color:#333333;">wxml </span><span style="color:#333333;">结构中，可以提供一个 节点（插槽），用于承载组件使用者提供的 </span><span style="color:#333333;">wxml </span><span style="color:#333333;">结构</span></p> 
     <p><span style="color:#333333;">其实插槽</span><span style="color:#333333;">, </span><span style="color:#333333;">说的通俗一些</span><span style="color:#333333;">, </span><span style="color:#333333;">就是子组件挖坑，父组件填坑的过程。由父组件在使用子组件的时候</span><span style="color:#333333;">, </span><span style="color:#333333;">决定子组件内部的一些布局展示</span></p> 
     <h3><span style="color:#333333;">18.1 单个插槽</span></h3> 
     <p><span style="color:#333333;">在小程序中，默认每个自定义组件中只允许使用一个 进行占位，这种个数上的限制叫做单个插槽。 </span></p> 
     <p><span style="color:#333333;">(1) 组件内使用&lt;slot&gt;标签占位</span></p> 
     <p><span style="color:#333333;">(2) 组件使用者通过&lt;component-tag-name&gt;标签显示插槽内容</span></p> 
     <h3><span style="color:#333333;">18.2 启用多个插槽</span></h3> 
     <p><span style="color:#333333;">在小程序的自定义组件中，需要使用多个插槽时，可以在组件的 </span><span style="color:#333333;">.js </span><span style="color:#333333;">文件中，通过如下方式进行启用</span></p> 
     <div> 
      <pre><code class="language-javascript">Component({
        options: {
                multipleSolts: true // 在组件定义时的选项中启用多 slot支持
        },
        properties: { /* ...*/ },
        methods: { /* ...*/ }
})</code></pre> 
      <p><span style="color:#333333;">一旦开启了多个插槽的配置</span><span style="color:#333333;">, </span><span style="color:#333333;">就意味着在组件内部可能会有多个标签</span><span style="color:#333333;">, 那我们在定义这多个标签的时候,需要给每一个起名字</span></p> 
      <p><span style="color:#117700;">&lt;slot </span><span style="color:#0000cc;">name</span><span style="color:#333333;">=</span><span style="color:#aa1111;">"before"</span><span style="color:#117700;">&gt;&lt;/slot&gt;</span></p> 
      <p><span style="color:#117700;">&lt;slot </span><span style="color:#0000cc;">name</span><span style="color:#333333;">=</span><span style="color:#aa1111;">"after"</span><span style="color:#117700;">&gt;&lt;/slot&gt; </span></p> 
      <p><span style="color:#333333;">而组件使用者在填充的时候</span><span style="color:#333333;">, </span><span style="color:#333333;">需要指明填充哪一个</span></p> 
      <p></p> 
      <div> 
       <span style="color:#aa5500;">&lt;!-- </span> 
       <span style="color:#aa5500;">组件的使用者 </span> 
       <span style="color:#aa5500;">--&gt; </span> 
      </div> 
      <div> 
       <span style="color:#117700;">&lt;component-tag-name&gt; </span> 
      </div> 
      <div> 
       <span style="color:#aa5500;">        &lt;!-- 这部分内容将被放置在组件的 </span> 
       <span style="color:#aa5500;">&lt;slot&gt;</span> 
       <span style="color:#aa5500;">的位置上 </span> 
       <span style="color:#aa5500;">--&gt; </span> 
      </div> 
      <div> 
       <span style="color:#117700;">        &lt;view </span> 
       <span style="color:#0000cc;">slot</span> 
       <span style="color:#333333;">=</span> 
       <span style="color:#aa1111;">"before"</span> 
       <span style="color:#117700;">&gt;</span> 
       <span style="color:#333333;">这是通过插槽填充的内容</span> 
       <span style="color:#333333;">,name</span> 
       <span style="color:#333333;">为</span> 
       <span style="color:#333333;">before</span> 
       <span style="color:#117700;">&lt;/view&gt; </span> 
      </div> 
      <div> 
       <span style="color:#117700;">        &lt;view </span> 
       <span style="color:#0000cc;">slot</span> 
       <span style="color:#333333;">=</span> 
       <span style="color:#aa1111;">"after"</span> 
       <span style="color:#117700;">&gt;</span> 
       <span style="color:#333333;">这是通过插槽填充的内容</span> 
       <span style="color:#333333;">,name</span> 
       <span style="color:#333333;">为</span> 
       <span style="color:#333333;">after</span> 
       <span style="color:#117700;">&lt;/view&gt; </span> 
      </div> 
      <p><span style="color:#117700;">&lt;/component-tag-name&gt; </span></p> 
      <h2>19 父子组件之间的通信</h2> 
      <h3>19.1 父子组件之间通信的三种方式</h3> 
      <p> <span style="color:#333333;">① 属性绑定 </span></p> 
      <ul><li><span style="color:#333333;">用于父组件向子组件的指定属性设置数据，仅能设置 JSON </span><span style="color:#333333;">兼容的数据</span><span style="color:#333333;">(只能传递数据，不能传递</span><span style="color:#333333;">方法) </span></li></ul> 
      <p><span style="color:#333333;">② 事件绑定 </span></p> 
      <ul><li><span style="color:#333333;">用于子组件向父组件传递数据，可以传递任意数据(</span><span style="color:#333333;">包括数据和方法) </span></li></ul> 
      <p><span style="color:#333333;">③ 获取组件实例 </span></p> 
      <ul><li><span style="color:#333333;">父组件还可以通过 this.selectComponent() 获取子组件实例对象 </span></li><li><span style="color:#333333;">这样就可以直接访问子组件的任意数据和方法</span> </li></ul> 
      <h3><span style="color:#333333;">19.2 属性绑定</span></h3> 
      <p><span style="color:#333333;">属性绑定用于实现</span><span style="color:#333333;">父向子传值</span><span style="color:#333333;">，而且只能传递普通类型的数据，无法将方法传递给子组件。</span></p> 
      <p><span style="color:#333333;">父组件代码示例:</span></p> 
      <div> 
       <pre><code class="language-html">data: {
        // 父组件中的data节点
        count: 0
}
// 父组件的wxml结构
&lt;my-test3 count="{<!-- -->{count}}"&gt;&lt;/my-test3&gt;
&lt;view&gt;------&lt;/view&gt;
&lt;view&gt;父组件中，count值为 {<!-- -->{count}}&lt;/view&gt;</code></pre> 
       <p>子组件示例代码: </p> 
       <div> 
        <pre><code class="language-html">// 子组件的properties 节点
properties: {
        count: Number
}
// 子组件的wxml结构
&lt;text&gt;子组件中， count值为：{<!-- -->{count}}&lt;/text&gt;</code></pre> 
        <h3>19.3 事件绑定</h3> 
        <p> <span style="color:#333333;">事件绑定用于实现子向父传值，可以传递任何类型的数据。使用步骤如下： </span> </p> 
        <p><span style="color:#333333;">① 在子组件的 js </span><span style="color:#333333;">中，在特定的时机通过调用 </span><span style="color:#333333;">this.triggerEvent </span><span style="color:#333333;">('</span><span style="color:#333333;">自定义事件名称</span><span style="color:#333333;">', { /* 参数对象 </span></p> 
        <p><span style="color:#333333;">*/ })产生一个自定义事件</span><span style="color:#333333;">, </span><span style="color:#333333;">并且可以带上事件参数对象. </span></p> 
        <p><span style="color:#333333;">② 在父组件的 wxml </span><span style="color:#333333;">中的子组件标签中，使用 </span><span style="color:#333333;">bind </span><span style="color:#333333;">:</span><span style="color:#333333;">自定义事件名称</span><span style="color:#333333;">="</span><span style="color:#333333;">事件处理函数</span><span style="color:#333333;">"监听自定义事 </span></p> 
        <p><span style="color:#333333;">件。 </span></p> 
        <p><span style="color:#333333;">③ 在父组件的 js 中，定义一个函数，这个函数即将通过自定义事件的形式，传递给子组件 </span></p> 
        <p> <span style="color:#333333;">④ 在父组件的事件处理函数中，通过 e.detail 获取到子组件传递过来的数据</span>  </p> 
        <h3><span style="color:#333333;">19.4 获取组件示例</span></h3> 
        <p><span style="color:#333333;">可在父组件里调用 </span><span style="color:#333333;">this.selectComponent("id</span><span style="color:#333333;">或</span><span style="color:#333333;">class</span><span style="color:#333333;">选择器</span><span style="color:#333333;">") </span><span style="color:#333333;">，获取子组件的实例对象，从而直接访问子组件的任意数据和方法。调用时需要传入一个选择器，例如 this.selectComponent(".my</span><span style="color:#333333;">- component") 。</span></p> 
        <h2>20 behaviors</h2> 
        <p>(1) 什么是behaviors</p> 
        <p><span style="color:#333333;">behaviors </span><span style="color:#333333;">是小程序中，用于实现组件间代码共享的特性，类似于 </span><span style="color:#333333;">Vue.js </span><span style="color:#333333;">中的 </span><span style="color:#333333;">“mixins” </span><span style="color:#333333;">。</span></p> 
        <p><span style="color:#333333;">(2) 工作方式</span></p> 
        <p><span style="color:#333333;">每个 </span><span style="color:#333333;">behaviors 可以包含一组属性、数据、生命周期函数和方法。组件引用它时，它的属性、数据和方法会被合并到组件中</span></p> 
        <p><span style="color:#333333;">每个组件可以引用多个 </span><span style="color:#333333;">behaviors </span><span style="color:#333333;">， </span><span style="color:#333333;">behaviors </span><span style="color:#333333;">也可以引用其它 </span><span style="color:#333333;">behaviors </span><span style="color:#333333;">。</span></p> 
        <p><span style="color:#333333;">只有当组件共享的代码就可以使用 </span><span style="color:#333333;">behaviors </span><span style="color:#333333;">来共享，如果是组件私有的代码，就不需要放在 behaviors 中 </span></p> 
        <p><span style="color:#333333;">(3) 创建behaviors</span></p> 
        <p><span style="color:#333333;">调用 </span><span style="color:#333333;">Behavior(Object object) </span><span style="color:#333333;">方法即可创建一个共享的 </span><span style="color:#333333;">behavior </span><span style="color:#333333;">实例对象，供所有的组件使用:</span></p> 
        <ul><li><span style="color:#333333;">创建一个文件夹 </span><span style="color:#333333;">behaviors </span></li><li><span style="color:#333333;">新建 </span><span style="color:#333333;">js </span><span style="color:#333333;">文件 </span><span style="color:#333333;">my</span><span style="color:#333333;">-</span><span style="color:#333333;">behavior.js </span></li><li><span style="color:#333333;">在该文件中书写以下代码 </span></li><li><span style="color:#a2e043;">并使用 module.exports 将 behavior 实例对象共享出去 </span></li></ul> 
        <div> 
         <pre><code class="language-javascript">// 调用 Behavior()方法， 创建实例对象
// 并使用 module.exports 将 behavior 实例对象共享出去
module.exports = Behavior({
        // 属性节点
        properties: {},
        // 私有数据节点
        data: {
                username: 'zs'
        },
        // 事件处理函数和自定义方法节点
        methods: {},
        // 其他节点...
})</code></pre> 
         <p></p> 
        </div> 
        <p>(4) 导入并使用</p> 
        <p><span style="color:#333333;">在组件中，使用 </span><span style="color:#333333;">require() </span><span style="color:#333333;">方法导入需要的 </span><span style="color:#333333;">behavior </span><span style="color:#333333;">，挂载后即可访问 </span><span style="color:#333333;">behavior </span><span style="color:#333333;">中的数据或方法</span></p> 
        <div> 
         <pre><code class="language-javascript">// 1.使用 required() 导入需要的自定义 behavior 模块
const myBehavior = required("../../behaviors/my-behavior")
// 2.将导入的behavior 实例对象， 挂载在 behaviors 数组节点中， 即可生效
Component({
// 在组件内部 与data节点平级的位置定义该属性，挂载behavior模块
        behaviors: [myBehavior]
})
// 3.在子组件中使用behavior中的东西
&lt;view&gt;在组件中共享的behavior是： {<!-- -->{username}}&lt;/view&gt;</code></pre> 
         <p><span style="color:#333333;">注意：</span><span style="color:#333333;">Behaviors </span><span style="color:#333333;">就仅仅只是做代码的复用而已，如果多个组件导入了同一种</span><span style="color:#333333;">Behaviors，他们的数据是相互独立的。 </span></p> 
         <p>(5) behaviors中所有可用的节点</p> 
         <p><img alt="" height="501" src="https://images2.imgbox.com/6e/22/vqsIgzFF_o.png" width="1117"></p> 
         <p>(6) 同名字段的覆盖和组合规则</p> 
         <p><span style="color:#333333;">组件和它引用的 </span><span style="color:#333333;">behavior </span><span style="color:#333333;">中可以包含同名的字段，此时可以参考如下</span><span style="color:#333333;"> 3 </span><span style="color:#333333;">种同名时的处理规则： </span></p> 
         <p><span style="color:#333333;">① 同名的数据字段</span><span style="color:#333333;"> ( </span><span style="color:#333333;">data </span><span style="color:#333333;">) </span></p> 
         <p><span style="color:#333333;">② 同名的属性</span><span style="color:#333333;"> ( </span><span style="color:#333333;">properties </span><span style="color:#333333;">) </span><span style="color:#333333;">或方法</span><span style="color:#333333;"> ( </span><span style="color:#333333;">methods </span><span style="color:#333333;">) </span></p> 
         <p><span style="color:#333333;">③ 同名的生命周期函数 </span></p> 
         <p><span style="color:#333333;">关于详细的覆盖和组合规则，大家可以参考微信小程序官方文档给出的说明： </span></p> 
         <p><span style="color:#4183c4;">https://developers.weixin.qq.com/miniprogram/dev/framework/custom-component/behaviors.ht </span></p> 
         <p><span style="color:#4183c4;">ml </span></p> 
         <p></p> 
        </div> 
       </div> 
      </div> 
     </div> 
    </div> 
   </div> 
  </div> 
 </div> 
</div>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/5383d40c06bcbf18b54af119ca3c59bb/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">开发环境 dns-client占用cpu过高问题解决</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/b5795867a931af8a9f4cc345c7d53739/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">java泛型 枚举</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>