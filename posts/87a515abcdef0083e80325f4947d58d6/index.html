<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>如何检测资源泄露 - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="如何检测资源泄露" />
<meta property="og:description" content="Window上我们常见的资源泄露包括内存和对象句柄泄露， 下面讨论下对各类泄露的检测方法。 关于内存泄漏，我以前写过2篇文章： C&#43;&#43;中基于Crt的内存泄漏检测 ， 基于WinDbg的内存泄漏分析 用上面提到的方法检测泄露很多时候太麻烦，所以有时候我们会考虑用工具 VLD： Visual Leak Detector源于Code Project：Visual Leak Detector - Enhanced Memory Leak Detection for Visual C&#43;&#43;, 安装包可以到 这里 下载。
使用很简单，基本上安装完了就之可以直接用， 具体可以参考 这篇
关于对象句柄泄露， 主要分GDI对象，Kernel对象，User对象：
GDI对象只在本进程有效，主要是指Brush， Pen，DC等， 具体可以参考 这里
User对象只在同一Session内有效，同一user对象在不同进程内值都相等，可以跨进程使用， 主要是指Menu， window, cursor, hook等，具体可以参考 这里
Kernel对象可以跨进程使用， 但是因为每个进程都有自己的内核对象表，所以同一对象的句柄值在不同进程里会不相等(尽管最终指向同一个内核对象)，主要是指各类HANDLE，具体可以参考 这里
对于对象句柄泄露，免费来说没有太好的工具可以直接使用， 很多时候我们可以直接通过任务管理器来观察各类对象的个数， 如果有持续增长， 则说明有泄露存在。很多时候GDI泄露是大头，我们要判断哪类GDI对象正在泄露，可以考虑使用工具GDIView。(对于对象句柄泄露，谁有好的工具，可以提示下。)
对于内核对象泄露，我们可以考虑使用WinDbg的 !htrace 命令， 使用很简单：通过 !htrace -enable 命令打开栈回溯， 然后通过 !htrace -snapshot 命令保存一个当前所有句柄的快照， 最后再通过 -htrace -diff 命令获取所有前面保存快照后打开但没有关闭的句柄对象。
如果公司有钱，可以考虑购买Boudcheck, 这个工具非常强大，可以帮我们快速的检测出各类内存和对象泄露，包括API的参数错误等。思考Boundcheck的实现原理，实际上并不复杂，主要就是API Hook， 大概过程如下：
(1) 将注入对方进程
(2) 通过API Hook替代系统资源分配和释放相关的API， 并且记录调用栈" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/87a515abcdef0083e80325f4947d58d6/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2019-07-05T07:40:47+08:00" />
<meta property="article:modified_time" content="2019-07-05T07:40:47+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">如何检测资源泄露</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <div id="cnblogs_post_body" class="blogpost-body"> 
 <div style="line-height:normal;font-family:'微软雅黑';"> 
  <span style="font-size:12pt;">Window上我们常见的资源泄露包括内存和对象句柄泄露， 下面讨论下对各类泄露的检测方法。</span> 
 </div> 
 <div style="line-height:normal;font-family:'微软雅黑';"></div> 
 <div style="line-height:normal;font-family:'微软雅黑';"> 
  <span style="font-size:12pt;">关于内存泄漏，我以前写过2篇文章： </span> 
  <a href="http://www.cppblog.com/weiym/archive/2013/02/25/198072.html" rel="nofollow" style="color:#4371a6;font-family:georgia, verdana, Arial, helvetica, 'sans-seriff';font-size:15px;font-weight:bold;"><span style="font-size:12pt;">C++中基于Crt的内存泄漏检测</span></a> 
  <span style="font-size:12pt;">， </span> 
  <a href="http://www.cppblog.com/weiym/archive/2013/02/27/198109.html" rel="nofollow" style="color:#4371a6;font-family:georgia, verdana, Arial, helvetica, 'sans-seriff';font-size:15px;font-weight:bold;"><span style="font-size:12pt;">基于WinDbg的内存泄漏分析</span></a> 
 </div> 
 <div style="line-height:normal;font-family:'微软雅黑';"> 
  <span style="font-size:12pt;">用上面提到的方法检测泄露很多时候太麻烦，所以有时候我们会考虑用工具 VLD：</span> 
 </div> 
 <div style="line-height:normal;font-family:'微软雅黑';"> 
  <p style="margin-left:0px;"><span style="font-size:12pt;">Visual Leak Detector</span><span style="font-family:'宋体';font-size:12pt;">源于</span><span style="font-size:12pt;">Code Project</span><span style="font-family:'宋体';font-size:12pt;">：</span><u><a href="http://www.codeproject.com/Articles/9815/Visual-Leak-Detector-Enhanced-Memory-Leak-Detectio" rel="nofollow" style="color:#4371a6;"><span style="font-size:12pt;">Visual Leak Detector - Enhanced Memory Leak Detection for Visual C++</span></a><span style="font-size:12pt;">, </span></u><span style="font-family:'宋体';font-size:12pt;">安装包可以到 </span><a href="http://vld.codeplex.com/" rel="nofollow" style="color:#4371a6;font-family:'宋体';"><span style="font-size:12pt;">这里</span> </a><span style="font-family:'宋体';font-size:12pt;">下载。</span></p> 
  <p style="margin-left:0px;"><span style="font-family:Tahoma;font-size:12pt;">使用很简单，基本上安装完了就之可以直接用， 具体可以参考</span> <a href="http://www.perfect-is-shit.com/visual-leak-detector.html" rel="nofollow" style="color:#4371a6;"><span style="font-size:12pt;">这篇</span></a></p> 
  <p style="margin-left:0px;"><br></p> 
  <p style="margin-left:0px;"><span style="font-size:12pt;">关于对象句柄泄露， 主要分GDI对象，Kernel对象，User对象：</span></p> 
  <p style="margin-left:0px;"><span style="font-size:12pt;">GDI对象只在本进程有效，主要是指Brush， Pen，DC等， 具体可以参考</span> <a href="http://msdn.microsoft.com/en-us/library/windows/desktop/ms724291%28v=vs.85%29.aspx" rel="nofollow" style="color:#4371a6;"><span style="font-size:12pt;">这里</span></a></p> 
  <p style="margin-left:0px;"><span style="font-size:12pt;">User对象只在同一Session内有效，同一user对象在不同进程内值都相等，可以跨进程使用， 主要是指Menu， window, cursor, hook等，具体可以参考 </span><a href="http://msdn.microsoft.com/en-us/library/windows/desktop/ms725486%28v=vs.85%29.aspx" rel="nofollow" style="color:#4371a6;"><span style="font-size:12pt;">这里</span></a></p> 
  <p style="margin-left:0px;"><span style="font-size:12pt;">Kernel对象可以跨进程使用， 但是因为每个进程都有自己的内核对象表，所以同一对象的句柄值在不同进程里会不相等(尽管最终指向同一个内核对象)，主要是指各类HANDLE，具体可以参考</span> <a href="http://msdn.microsoft.com/en-us/library/windows/desktop/ms724485%28v=vs.85%29.aspx" rel="nofollow" style="color:#4371a6;"><span style="font-size:12pt;">这里</span></a></p> 
  <p style="margin-left:0px;"><br></p> 
  <p style="margin-left:0px;"><span style="font-size:12pt;">对于对象句柄泄露，免费来说没有太好的工具可以直接使用， 很多时候我们可以直接通过任务管理器来观察各类对象的个数， 如果有持续增长， 则说明有泄露存在。很多时候GDI泄露是大头，我们要判断哪类GDI对象正在泄露，可以考虑使用工具</span><a href="http://www.nirsoft.net/utils/gdi_handles.html" rel="nofollow" style="color:#4371a6;"><span style="font-size:12pt;">GDIView</span></a><span style="font-size:12pt;">。(对于对象句柄泄露，谁有好的工具，可以提示下。)</span></p> 
  <p style="margin-left:0px;"><br></p> 
  <p style="margin-left:0px;"><span style="font-size:12pt;">对于内核对象泄露，我们可以考虑使用WinDbg的 !htrace 命令， 使用很简单：通过 !htrace -enable 命令打开栈回溯， 然后通过 !htrace -snapshot 命令保存一个当前所有句柄的快照， 最后再通过 -htrace -diff 命令获取所有前面保存快照后打开但没有关闭的句柄对象。</span></p> 
  <p style="margin-left:0px;"><br></p> 
  <p style="margin-left:0px;"><span style="font-size:12pt;">如果公司有钱，可以考虑购买Boudcheck, 这个工具非常强大，可以帮我们快速的检测出各类内存和对象泄露，包括API的参数错误等。思考Boundcheck的实现原理，实际上并不复杂，主要就是API Hook， 大概过程如下：</span></p> 
  <p style="margin-left:0px;"><span style="font-size:12pt;">(1) 将注入对方进程</span></p> 
  <p style="margin-left:0px;"><span style="font-size:12pt;">(2) 通过API Hook替代系统资源分配和释放相关的API， 并且记录调用栈</span></p> 
  <p style="margin-left:0px;"><span style="font-size:12pt;">(3)最后检测没有释放的资源， 生成报表</span></p> 
  <p style="margin-left:0px;"><br></p> 
  <p style="margin-left:0px;"><span style="font-size:12pt;">这里有篇文章告诉你如何开发类似的工具：</span><a href="http://www.codeproject.com/Articles/150463/LeakMon-Track-Handle-leak-GDI-Leak-and-Memory-Leak" rel="nofollow" style="color:#4371a6;"><span style="font-size:12pt;">LeakMon - Track Handle leak, GDI Leak and Memory Leak in your Applications</span></a></p> 
  <p style="margin-left:0px;"><span style="font-size:12pt;">当然尽管原理很简单，但是因为Windows的API种类繁多，并且在新版本中会常有增加， 要开发一个完整的工具也不是一件容易的事情。</span></p> 
 </div> 
</div> 
<p>转载于:https://www.cnblogs.com/weiym/p/3940502.html</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/62bfb6adf720d7b4c4ccb2f6aa15a262/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">关于Windows高DPI的一些简单总结</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/fc97924014379e1b6bd4f76948d56439/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">数据挖掘之聚类分析（Cluster Analysis）</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>