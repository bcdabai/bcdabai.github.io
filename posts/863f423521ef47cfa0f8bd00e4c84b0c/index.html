<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>【人脸识别】基于matlab GUI LBP人脸识别【含Matlab源码 1282期】 - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="【人脸识别】基于matlab GUI LBP人脸识别【含Matlab源码 1282期】" />
<meta property="og:description" content="✅博主简介：热爱科研的Matlab仿真开发者，修心和技术同步精进，Matlab项目合作可私信。
🍎个人主页：海神之光
🏆代码获取方式：
海神之光Matlab王者学习之路—代码获取方式
⛳️座右铭：行百里者，半于九十。
更多Matlab仿真内容点击👇
Matlab图像处理（进阶版）
路径规划（Matlab）
神经网络预测与分类（Matlab）
优化求解（Matlab）
语音处理（Matlab）
信号处理（Matlab）
车间调度（Matlab）
⛄一、LBP简介 LBP（Local Binary Pattern，局部二值模式）是一种用来描述图像局部纹理特征的算子；它具有旋转不变性和灰度不变性等显著的优点。它是首先由T. Ojala, M.Pietikäinen, 和D. Harwood 在1994年提出，用于纹理特征提取。而且，提取的特征是图像的局部的纹理特征；
1 LBP特征的描述
原始的LBP算子定义为在33的窗口内，以窗口中心像素为阈值，将相邻的8个像素的灰度值与其进行比较，若周围像素值大于中心像素值，则该像素点的位置被标记为1，否则为0。这样，33邻域内的8个点经比较可产生8位二进制数（通常转换为十进制数即LBP码，共256种），即得到该窗口中心像素点的LBP值，并用这个值来反映该区域的纹理信息。如下图所示：
LBP的改进版本：
原始的LBP提出后，研究人员不断对其提出了各种改进和优化。
（1）圆形LBP算子：
基本的 LBP 算子的最大缺陷在于它只覆盖了一个固定半径范围内的小区域，这显然不能满足不同尺寸和频率纹理的需要。为了适应不同尺度的纹理特征，并达到灰度和旋转不变性的要求，Ojala 等对 LBP 算子进行了改进，将 3×3 邻域扩展到任意邻域，并用圆形邻域代替了正方形邻域，改进后的 LBP 算子允许在半径为 R 的圆形邻域内有任意多个像素点。从而得到了诸如半径为R的圆形区域内含有P个采样点的LBP算子；
（2）LBP旋转不变模式
从 LBP 的定义可以看出，LBP 算子是灰度不变的，但却不是旋转不变的。图像的旋转就会得到不同的 LBP值。
Maenpaa等人又将 LBP 算子进行了扩展，提出了具有旋转不变性的 LBP 算子，即不断旋转圆形邻域得到一系列初始定义的 LBP 值，取其最小值作为该邻域的 LBP 值。
图 2.5 给出了求取旋转不变的 LBP 的过程示意图，图中算子下方的数字表示该算子对应的 LBP 值，图中所示的 8 种 LBP模式，经过旋转不变的处理，最终得到的具有旋转不变性的 LBP 值为 15。也就是说，图中的 8 种 LBP 模式对应的旋转不变的 LBP 模式都是00001111。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/863f423521ef47cfa0f8bd00e4c84b0c/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-10-28T15:33:02+08:00" />
<meta property="article:modified_time" content="2023-10-28T15:33:02+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">【人脸识别】基于matlab GUI LBP人脸识别【含Matlab源码 1282期】</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-light">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p>✅博主简介：热爱科研的Matlab仿真开发者，修心和技术同步精进，Matlab项目合作可私信。<br> 🍎个人主页：<a href="https://blog.csdn.net/TIQCmatlab?type=blog">海神之光</a><br> 🏆代码获取方式：<br> <a href="https://qq912100926.blog.csdn.net/article/details/122140668" rel="nofollow">海神之光Matlab王者学习之路—代码获取方式</a><br> ⛳️座右铭：行百里者，半于九十。</p> 
<p>更多Matlab仿真内容点击👇<br> <a href="https://blog.csdn.net/tiqcmatlab/category_11834500.html?spm=1001.2014.3001.5482">Matlab图像处理（进阶版）</a><br> <a href="https://blog.csdn.net/tiqcmatlab/category_11834501.html">路径规划（Matlab）</a><br> <a href="https://blog.csdn.net/tiqcmatlab/category_11834502.html">神经网络预测与分类（Matlab）</a><br> <a href="https://blog.csdn.net/tiqcmatlab/category_11834503.html">优化求解（Matlab）</a><br> <a href="https://blog.csdn.net/tiqcmatlab/category_11832341.html">语音处理（Matlab）</a><br> <a href="https://blog.csdn.net/tiqcmatlab/category_11832366.html">信号处理（Matlab）</a><br> <a href="https://blog.csdn.net/tiqcmatlab/category_11834477.html">车间调度（Matlab）</a></p> 
<h3><a id="LBP_15"></a>⛄一、LBP简介</h3> 
<p>LBP（Local Binary Pattern，局部二值模式）是一种用来描述图像局部纹理特征的算子；它具有旋转不变性和灰度不变性等显著的优点。它是首先由T. Ojala, M.Pietikäinen, 和D. Harwood 在1994年提出，用于纹理特征提取。而且，提取的特征是图像的局部的纹理特征；</p> 
<p><strong>1 LBP特征的描述</strong><br> 原始的LBP算子定义为在3<em>3的窗口内，以窗口中心像素为阈值，将相邻的8个像素的灰度值与其进行比较，若周围像素值大于中心像素值，则该像素点的位置被标记为1，否则为0。这样，3</em>3邻域内的8个点经比较可产生8位二进制数（通常转换为十进制数即LBP码，共256种），即得到该窗口中心像素点的LBP值，并用这个值来反映该区域的纹理信息。如下图所示：<br> <img src="https://images2.imgbox.com/d8/db/AsQcSYWJ_o.png" alt="在这里插入图片描述"><br> LBP的改进版本：<br> 原始的LBP提出后，研究人员不断对其提出了各种改进和优化。</p> 
<p>（1）圆形LBP算子：<br> 基本的 LBP 算子的最大缺陷在于它只覆盖了一个固定半径范围内的小区域，这显然不能满足不同尺寸和频率纹理的需要。为了适应不同尺度的纹理特征，并达到灰度和旋转不变性的要求，Ojala 等对 LBP 算子进行了改进，将 3×3 邻域扩展到任意邻域，并用圆形邻域代替了正方形邻域，改进后的 LBP 算子允许在半径为 R 的圆形邻域内有任意多个像素点。从而得到了诸如半径为R的圆形区域内含有P个采样点的LBP算子；<br> <img src="https://images2.imgbox.com/16/66/p0ZTxSJ2_o.png" alt="在这里插入图片描述"><br> （2）LBP旋转不变模式<br> 从 LBP 的定义可以看出，LBP 算子是灰度不变的，但却不是旋转不变的。图像的旋转就会得到不同的 LBP值。<br> Maenpaa等人又将 LBP 算子进行了扩展，提出了具有旋转不变性的 LBP 算子，即不断旋转圆形邻域得到一系列初始定义的 LBP 值，取其最小值作为该邻域的 LBP 值。<br> 图 2.5 给出了求取旋转不变的 LBP 的过程示意图，图中算子下方的数字表示该算子对应的 LBP 值，图中所示的 8 种 LBP模式，经过旋转不变的处理，最终得到的具有旋转不变性的 LBP 值为 15。也就是说，图中的 8 种 LBP 模式对应的旋转不变的 LBP 模式都是00001111。<br> <img src="https://images2.imgbox.com/f9/dc/xGbr8oG7_o.png" alt="在这里插入图片描述"><br> （3）LBP等价模式<br> 一个LBP算子可以产生不同的二进制模式，对于半径为R的圆形区域内含有P个采样点的LBP算子将会产生2P2P种模式。很显然，随着邻域集内采样点数的增加，二进制模式的种类是急剧增加的。例如：5×5邻域内20个采样点，有220220＝1,048,576种二进制模式。如此多的二值模式无论对于纹理的提取还是对于纹理的识别、分类及信息的存取都是不利的。同时，过多的模式种类对于纹理的表达是不利的。例如，将LBP算子用于纹理分类或人脸识别时，常采用LBP模式的统计直方图来表达图像的信息，而较多的模式种类将使得数据量过大，且直方图过于稀疏。因此，需要对原始的LBP模式进行降维，使得数据量减少的情况下能最好的代表图像的信息。<br> 为了解决二进制模式过多的问题，提高统计性，Ojala提出了采用一种“等价模式”（Uniform Pattern）来对LBP算子的模式种类进行降维。Ojala等认为，在实际图像中，绝大多数LBP模式最多只包含两次从1到0或从0到1的跳变。因此，Ojala将“等价模式”定义为：当某个LBP所对应的循环二进制数从0到1或从1到0最多有两次跳变时，该LBP所对应的二进制就称为一个等价模式类。如00000000（0次跳变），00000111（只含一次从0到1的跳变），10001111（先由1跳到0，再由0跳到1，共两次跳变）都是等价模式类。除等价模式类以外的模式都归为另一类，称为混合模式类，例如10010111（共四次跳变）（这是我的个人理解，不知道对不对）。<br> 通过这样的改进，二进制模式的种类大大减少，而不会丢失任何信息。模式数量由原来的2P2P种减少为 P ( P-1)+2种，其中P表示邻域集内的采样点数。对于3×3邻域内8个采样点来说，二进制模式由原始的256种减少为58种，这使得特征向量的维数更少，并且可以减少高频噪声带来的影响。<br> <strong>2 LBP特征用于检测的原理</strong><br> 显而易见的是，上述提取的LBP算子在每个像素点都可以得到一个LBP“编码”，那么，对一幅图像（记录的是每个像素点的灰度值）提取其原始的LBP算子之后，得到的原始LBP特征依然是“一幅图片”（记录的是每个像素点的LBP值）。<br> <img src="https://images2.imgbox.com/c8/16/vsuejYQ2_o.png" alt="在这里插入图片描述"><br> 从上图可以看出LBP对光照具有很强的鲁棒性<br> LBP的应用中，如纹理分类、人脸分析等，一般都不将LBP图谱作为特征向量用于分类识别，而是采用LBP特征谱的统计直方图作为特征向量用于分类识别。<br> 　　因为，从上面的分析我们可以看出，这个“特征”跟位置信息是紧密相关的。直接对两幅图片提取这种“特征”，并进行判别分析的话，会因为“位置没有对准”而产生很大的误差。后来，研究人员发现，可以将一幅图片划分为若干的子区域，对每个子区域内的每个像素点都提取LBP特征，然后，在每个子区域内建立LBP特征的统计直方图。如此一来，每个子区域，就可以用一个统计直方图来进行描述；整个图片就由若干个统计直方图组成；<br> 　　例如：一幅100<em>100像素大小的图片，划分为10</em>10=100个子区域（可以通过多种方式来划分区域），每个子区域的大小为10<em>10像素；在每个子区域内的每个像素点，提取其LBP特征，然后，建立统计直方图；这样，这幅图片就有10</em>10个子区域，也就有了10<em>10个统计直方图，利用这10</em>10个统计直方图，就可以描述这幅图片了。之后，我们利用各种相似性度量函数，就可以判断两幅图像之间的相似性了；<br> <strong>3 对LBP特征向量进行提取的步骤</strong><br> 　　（1）首先将检测窗口划分为16×16的小区域（cell）；<br> 　　（2）对于每个cell中的一个像素，将相邻的8个像素的灰度值与其进行比较，若周围像素值大于中心像素值，则该像素点的位置被标记为1，否则为0。这样，3*3邻域内的8个点经比较可产生8位二进制数，即得到该窗口中心像素点的LBP值；<br> 　　（3）然后计算每个cell的直方图，即每个数字（假定是十进制数LBP值）出现的频率；然后对该直方图进行归一化处理。<br> 　　（4）最后将得到的每个cell的统计直方图进行连接成为一个特征向量，也就是整幅图的LBP纹理特征向量；<br> 　　然后便可利用SVM或者其他机器学习算法进行分类了。</p> 
<p>LPQ(Local Phase Quantization)算法的原理是假设平滑函数h(x)中心对称，则其傅里叶变换为H(u)，对所有H(u)≥0有∠G(u)= ∠F(u),其中F(u)和G(u)分别为原图像和平滑后图像的傅里叶变换，因而在H(u)≥0条件下，图像对平滑有不变性。</p> 
<p>为使H(u)≥0，a取为不超过第一个过零点的频率点，其值为a=1/winSize（winSize为输入参数）。分别用f(x)对u1=（a,0）,u2=(0,a),u3=(a,a),u4=(a,-a)四个点作STFT，然后分别把四个点的实部和虚部分开,形成一个向量W=[Re{F(u1,x)},Re{F(u2,x)},Re{F(u3,x)},Re{F(u4,x)},Im{F(u1,x)},Im{F(u2,x)},Im{F(u3,x)},Im{F(u4,x)}]T 。</p> 
<p>最终得到LPQ变换即为Fx=W*fx。然后对参数进行统计分析，若参数是相关的，则用奇异值分解去相关并且量化。</p> 
<h3><a id="_56"></a>⛄二、部分源代码</h3> 
<p>function varargout = identification(varargin)<br> % IDENTIFICATION MATLAB code for identification.fig<br> % IDENTIFICATION, by itself, creates a new IDENTIFICATION or raises the existing<br> % singleton*.<br> %<br> % H = IDENTIFICATION returns the handle to a new IDENTIFICATION or the handle to<br> % the existing singleton*.<br> %<br> % IDENTIFICATION(‘CALLBACK’,hObject,eventData,handles,…) calls the local<br> % function named CALLBACK in IDENTIFICATION.M with the given input arguments.<br> %<br> % IDENTIFICATION(‘Property’,‘Value’,…) creates a new IDENTIFICATION or raises the<br> % existing singleton*. Starting from the left, property value pairs are<br> % applied to the GUI before identification_OpeningFcn gets called. An<br> % unrecognized property name or invalid value makes property application<br> % stop. All inputs are passed to identification_OpeningFcn via varargin.<br> %<br> % *See GUI Options on GUIDE’s Tools menu. Choose “GUI allows only one<br> % instance to run (singleton)”.<br> %<br> % See also: GUIDE, GUIDATA, GUIHANDLES</p> 
<p>% Edit the above text to modify the response to help identification</p> 
<p>% Last Modified by GUIDE v2.5 06-Aug-2021 03:03:30</p> 
<p>% Begin initialization code - DO NOT EDIT<br> gui_Singleton = 1;<br> gui_State = struct(‘gui_Name’, mfilename, …<br> ‘gui_Singleton’, gui_Singleton, …<br> ‘gui_OpeningFcn’, @identification_OpeningFcn, …<br> ‘gui_OutputFcn’, @identification_OutputFcn, …<br> ‘gui_LayoutFcn’, [] , …<br> ‘gui_Callback’, []);<br> if nargin &amp;&amp; ischar(varargin{1})<br> gui_State.gui_Callback = str2func(varargin{1});<br> end</p> 
<p>if nargout<br> [varargout{1:nargout}] = gui_mainfcn(gui_State, varargin{:});<br> else<br> gui_mainfcn(gui_State, varargin{:});<br> end<br> % End initialization code - DO NOT EDIT</p> 
<p>% — Executes just before identification is made visible.<br> function identification_OpeningFcn(hObject, eventdata, handles, varargin)<br> % This function has no output args, see OutputFcn.<br> % hObject handle to figure<br> % eventdata reserved - to be defined in a future version of MATLAB<br> % handles structure with handles and user data (see GUIDATA)<br> % varargin command line arguments to identification (see VARARGIN)</p> 
<p>% Choose default command line output for identification<br> handles.output = hObject;</p> 
<p>% Update handles structure<br> guidata(hObject, handles);</p> 
<p>% UIWAIT makes identification wait for user response (see UIRESUME)<br> % uiwait(handles.figure1);</p> 
<p>% — Outputs from this function are returned to the command line.<br> function varargout = identification_OutputFcn(hObject, eventdata, handles)<br> % varargout cell array for returning output args (see VARARGOUT);<br> % hObject handle to figure<br> % eventdata reserved - to be defined in a future version of MATLAB<br> % handles structure with handles and user data (see GUIDATA)</p> 
<p>% Get default command line output from handles structure<br> varargout{1} = handles.output;</p> 
<p>% — Executes on button press in pushbutton1.<br> function pushbutton1_Callback(hObject, eventdata, handles)<br> % hObject handle to pushbutton1 (see GCBO)<br> % eventdata reserved - to be defined in a future version of MATLAB<br> % handles structure with handles and user data (see GUIDATA)<br> [filename,pathname]=uigetfile({‘<em>.jpg’;'</em>.tif’},‘file selector’);<br> str=[pathname filename];<br> I=imread(str);<br> axes(handles.axes1);</p> 
<p>imshow(I);</p> 
<p>lbp_face=[];<br> [lbp_face,feature]=lbpfeaturevector2(I,100,20);<br> axes(handles.axes2);<br> imshow(feature);<br> load(‘fb_lbp_face.mat’)<br> ss=[];<br> ss=LBP_face(:😅;<br> ref_labels=label;<br> ref_label=number_label;<br> L=zeros(1,size(ss,2));<br> text=[];<br> %d=sum((A-B).^2);</p> 
<p>for j=1:size(ss,2)<br> w=0;<br> for i=1:size(lbp_face,1)<br> %w=w+(h(i,1)-ss(i,j))^2;%欧式距离<br> %w=w-ss(i,j)*(log(h(i,1)+1e-100));%log-likelihood statistic<br> %w=w+min(ss(i,j),h(i,1));%histogram intersection<br> w=w+(((ss(i,j)-lbp_face(i,1)).^2)./(ss(i,j)+lbp_face(i,1)+(1e-10)));%chi aquare statistic<br> end<br> w=sqrt(w);<br> L(j)=w;<br> end</p> 
<p>axes(handles.axes3);<br> imshow(str);</p> 
<p>% — Executes on button press in pushbutton2.<br> function pushbutton2_Callback(hObject, eventdata, handles)<br> % hObject handle to pushbutton2 (see GCBO)<br> % eventdata reserved - to be defined in a future version of MATLAB<br> % handles structure with handles and user data (see GUIDATA)<br> %用5<em>5模板计算LBP特征值<br> %法一<br> function [out]=calculatelbp2(mat)<br> [m,n]=size(mat);<br> %mat=double(mat);<br> in=mat;<br> r=m+4;<br> c=n+4;<br> %out=zeros(m,n);<br> A=zeros(r,c);<br> r0=3:r-2;<br> c0=3:c-2;<br> A(r0,c0)=in;<br> %alpha=2-sqrt(2);<br> alpha=0.5;<br> beta=1-alpha;<br> d0=A(r0,c0-2)-in;<br> d2=A(r0+2,c0)-in;<br> d4=A(r0,c0+2)-in;<br> d6=A(r0-2,c0)-in;<br> d1=alpha</em>A(r0+1,c0-1)+beta<em>A(r0+2,c0-2)-in;<br> d3=alpha</em>A(r0+1,c0+1)+beta<em>A(r0+2,c0+2)-in;<br> d5=alpha</em>A(r0-1,c0+1)+beta<em>A(r0-2,c0+2)-in;<br> d7=alpha</em>A(r0-1,c0-1)+beta*A(r0-2,c0-2)-in;</p> 
<p>d=[d0(😃,d1(😃,d2(😃,d3(😃,d4(😃,d5(😃,d6(😃,d7(😃];<br> code=2.^(7👎0)';<br> out =reshape((d&gt;=0)*code,m,n);<br> %法二<br> %out=mat2gray(out);<br> %imshow(out);<br> %可先声明一个大矩阵，把mat放入矩阵中<br> % [m,n]=size(mat);<br> % mat=[zeros(m,2) mat zeros(m,2)];<br> % mat=[zeros(2,n+4);mat;zeros(2,n+4)];<br> % A=zeros(5,5);<br> % p=zeros(1,8);<br> % k=0;<br> % lbp=zeros(size(mat));<br> % h=zeros(1,8);<br> % for i=3:(m+2)<br> % for j=3:(n+4)<br> % lbpnumber=0;<br> % A=mat(i:i+4,j:j+4);<br> % k=A(3,3);<br> % p(2)=(A(1,1)+A(2,2))/2;<br> % p(3)=A(1,3);<br> % p(4)=(A(1,5)+A(2,4))/2;<br> % p(1)=A(3,1);<br> % p(5)=A(3,5);<br> % p(8)=(A(5,1)+A(4,2))/2;<br> % p(7)=A(5,3);<br> % p(6)=(A(5,5)+A(5,4))/2;<br> % h=(p&gt;=k);<br> % for q=1:8<br> % lbpnumber=lbpnumber+(h(q)<em>2^(8-q));<br> % end<br> % lbp(i+2,j+2)=lbpnumber;<br> % end<br> % end、<br> %对应3</em>3模板特征值形成特征向量<br> function [m,f]=lbpfeaturevector(mat,s,n)<br> [<sub>,</sub>,d]=size(mat);<br> if d==3<br> mat=rgb2gray(mat);<br> end<br> mat=double(mat);<br> mat=imresize(mat,[100 100],‘bicubic’);%归一化</p> 
<p>k=calculatelbp(mat);<br> f=mat2gray(k);<br> %imshow(f);<br> k=uint8(k);<br> m=[];<br> for i=1:n:s<br> for j=1:n:s<br> A=k(i:(i+19),j:(j+19));<br> h=[];<br> h=imhist(A);<br> m=[m;h/(n*n)];<br> end<br> end<br> % lbp(1:2,:)=[];<br> % lbp((1+m):end,:)=[];<br> % lbp(:,1:2)=[];<br> % lbp(:,(1+n):end)=[];<br> % end<br> % imshow(lbp,[]);%强制转换为double 类型</p> 
<h3><a id="_270"></a>⛄三、运行结果</h3> 
<p><img src="https://images2.imgbox.com/ae/e6/dr7tDkMK_o.jpg" alt="在这里插入图片描述"><br> <img src="https://images2.imgbox.com/97/e6/zhvxGSTy_o.jpg" alt="在这里插入图片描述"></p> 
<h3><a id="matlab_274"></a>⛄四、matlab版本及参考文献</h3> 
<p><strong>1 matlab版本</strong><br> 2014a</p> 
<p><strong>2 参考文献</strong><br> [1]李鹏.基于小波变换和LBP算子的人脸识别研究[J].微型电脑应用. 2022,38(05)</p> 
<p><strong>3 备注</strong><br> 简介此部分摘自互联网，仅供参考，若侵权，联系删除</p> 
<p><strong>🍅 仿真咨询<br> 1 各类智能优化算法改进及应用</strong><br> 生产调度、经济调度、装配线调度、充电优化、车间调度、发车优化、水库调度、三维装箱、物流选址、货位优化、公交排班优化、充电桩布局优化、车间布局优化、集装箱船配载优化、水泵组合优化、解医疗资源分配优化、设施布局优化、可视域基站和无人机选址优化</p> 
<p><strong>2 机器学习和深度学习方面</strong><br> 卷积神经网络（CNN）、LSTM、支持向量机（SVM）、最小二乘支持向量机（LSSVM）、极限学习机（ELM）、核极限学习机（KELM）、BP、RBF、宽度学习、DBN、RF、RBF、DELM、XGBOOST、TCN实现风电预测、光伏预测、电池寿命预测、辐射源识别、交通流预测、负荷预测、股价预测、PM2.5浓度预测、电池健康状态预测、水体光学参数反演、NLOS信号识别、地铁停车精准预测、变压器故障诊断</p> 
<p><strong>3 图像处理方面</strong><br> 图像识别、图像分割、图像检测、图像隐藏、图像配准、图像拼接、图像融合、图像增强、图像压缩感知</p> 
<p><strong>4 路径规划方面</strong><br> 旅行商问题（TSP）、车辆路径问题（VRP、MVRP、CVRP、VRPTW等）、无人机三维路径规划、无人机协同、无人机编队、机器人路径规划、栅格地图路径规划、多式联运运输问题、车辆协同无人机路径规划、天线线性阵列分布优化、车间布局优化</p> 
<p><strong>5 无人机应用方面</strong><br> 无人机路径规划、无人机控制、无人机编队、无人机协同、无人机任务分配</p> 
<p><strong>6 无线传感器定位及布局方面</strong><br> 传感器部署优化、通信协议优化、路由优化、目标定位优化、Dv-Hop定位优化、Leach协议优化、WSN覆盖优化、组播优化、RSSI定位优化</p> 
<p><strong>7 信号处理方面</strong><br> 信号识别、信号加密、信号去噪、信号增强、雷达信号处理、信号水印嵌入提取、肌电信号、脑电信号、信号配时优化</p> 
<p><strong>8 电力系统方面</strong><br> 微电网优化、无功优化、配电网重构、储能配置</p> 
<p><strong>9 元胞自动机方面</strong><br> 交通流 人群疏散 病毒扩散 晶体生长</p> 
<p><strong>10 雷达方面</strong><br> 卡尔曼滤波跟踪、航迹关联、航迹融合</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/212457b0c895f2d458dcc1c29951b4ad/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">从瀑布模式到水母模式：ChatGPT如何赋能软件研发全流程</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/535edeef850f264a60ea4c81d7ecef6d/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">c语言项目实践-猜数字大小</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>