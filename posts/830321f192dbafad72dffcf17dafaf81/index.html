<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Python 算法高级篇：最短路径算法的优化 - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Python 算法高级篇：最短路径算法的优化" />
<meta property="og:description" content="Python 算法高级篇：最短路径算法的优化 引言 1. Dijkstra 算法2. Bellman-Ford 算法3. SPFA 算法4. 优化与比较5. 案例分析：地理导航6. 总结 引言 最短路径算法是图算法中的一个重要领域，它用于查找从一个起始节点到目标节点的最短路径。在这篇博客中，我们将深入探讨三种最短路径算法的优化： Dijkstra 算法、 Bellman-Ford 算法和 SPFA 算法。这些算法在各种实际应用中都发挥着关键作用，从网络路由到地理信息系统，再到社交网络分析。
😃😄 ❤️ ❤️ ❤️
1. Dijkstra 算法 Dijkstra 算法用于解决从一个节点到所有其他节点的最短路径问题，但要求边的权重为非负数。该算法维护一个距离表，通过不断选择距离最短的节点来更新表中的距离值。
下面是 Dijkstra 算法的 Python 实现：
import heapq def dijkstra(graph, start): distances = {node: float(&#39;infinity&#39;) for node in graph} distances[start] = 0 queue = [(0, start)] while queue: current_distance, current_node = heapq.heappop(queue) if current_distance &gt; distances[current_node]: continue for neighbor, weight in graph[current_node]." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/830321f192dbafad72dffcf17dafaf81/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-10-31T19:02:27+08:00" />
<meta property="article:modified_time" content="2023-10-31T19:02:27+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Python 算法高级篇：最短路径算法的优化</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-dracula">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p></p> 
<div class="toc"> 
 <h4>Python 算法高级篇：最短路径算法的优化</h4> 
 <ul><li><a href="#font_size2font_2" rel="nofollow"><font size="2">引言</font></a></li><li><a href="#font_size2_1__Dijkstra_font_7" rel="nofollow"><font size="2"> 1. Dijkstra 算法</font></a></li><li><a href="#font_size22__BellmanFord_font_37" rel="nofollow"><font size="2">2. Bellman-Ford 算法</font></a></li><li><a href="#font_size23__SPFA_font_57" rel="nofollow"><font size="2">3. SPFA 算法</font></a></li><li><a href="#font_size24_font_87" rel="nofollow"><font size="2">4. 优化与比较</font></a></li><li><a href="#font_size25_font_91" rel="nofollow"><font size="2">5. 案例分析：地理导航</font></a></li><li><a href="#font_size26_font_99" rel="nofollow"><font size="2">6. 总结</font></a></li></ul> 
</div> 
<p></p> 
<h2><a id="font_size2font_2"></a><font size="2">引言</font></h2> 
<p><font size="2">最短路径算法是图算法中的一个重要领域，它用于查找从一个起始节点到目标节点的最短路径。在这篇博客中，我们将深入探讨三种最短路径算法的优化： <strong>Dijkstra</strong> 算法、 <strong>Bellman-Ford</strong> 算法和 <strong>SPFA</strong> 算法。这些算法在各种实际应用中都发挥着关键作用，从网络路由到地理信息系统，再到社交网络分析。</font></p> 
<p>😃😄 ❤️ ❤️ ❤️</p> 
<h2><a id="font_size2_1__Dijkstra_font_7"></a><font size="2"> 1. Dijkstra 算法</font></h2> 
<p><font size="2"> <strong>Dijkstra</strong> 算法用于解决从一个节点到所有其他节点的最短路径问题，但要求边的权重为非负数。该算法维护一个距离表，通过不断选择距离最短的节点来更新表中的距离值。</font></p> 
<p><font size="2">下面是 <strong>Dijkstra</strong> 算法的 <strong>Python</strong> 实现：</font></p> 
<pre><code class="prism language-python"><span class="token keyword">import</span> heapq

<span class="token keyword">def</span> <span class="token function">dijkstra</span><span class="token punctuation">(</span>graph<span class="token punctuation">,</span> start<span class="token punctuation">)</span><span class="token punctuation">:</span>
    distances <span class="token operator">=</span> <span class="token punctuation">{<!-- --></span>node<span class="token punctuation">:</span> <span class="token builtin">float</span><span class="token punctuation">(</span><span class="token string">'infinity'</span><span class="token punctuation">)</span> <span class="token keyword">for</span> node <span class="token keyword">in</span> graph<span class="token punctuation">}</span>
    distances<span class="token punctuation">[</span>start<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0</span>
    queue <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> start<span class="token punctuation">)</span><span class="token punctuation">]</span>

    <span class="token keyword">while</span> queue<span class="token punctuation">:</span>
        current_distance<span class="token punctuation">,</span> current_node <span class="token operator">=</span> heapq<span class="token punctuation">.</span>heappop<span class="token punctuation">(</span>queue<span class="token punctuation">)</span>

        <span class="token keyword">if</span> current_distance <span class="token operator">&gt;</span> distances<span class="token punctuation">[</span>current_node<span class="token punctuation">]</span><span class="token punctuation">:</span>
            <span class="token keyword">continue</span>

        <span class="token keyword">for</span> neighbor<span class="token punctuation">,</span> weight <span class="token keyword">in</span> graph<span class="token punctuation">[</span>current_node<span class="token punctuation">]</span><span class="token punctuation">.</span>items<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
            distance <span class="token operator">=</span> current_distance <span class="token operator">+</span> weight

            <span class="token keyword">if</span> distance <span class="token operator">&lt;</span> distances<span class="token punctuation">[</span>neighbor<span class="token punctuation">]</span><span class="token punctuation">:</span>
                distances<span class="token punctuation">[</span>neighbor<span class="token punctuation">]</span> <span class="token operator">=</span> distance
                heapq<span class="token punctuation">.</span>heappush<span class="token punctuation">(</span>queue<span class="token punctuation">,</span> <span class="token punctuation">(</span>distance<span class="token punctuation">,</span> neighbor<span class="token punctuation">)</span><span class="token punctuation">)</span>

    <span class="token keyword">return</span> distances
</code></pre> 
<h2><a id="font_size22__BellmanFord_font_37"></a><font size="2">2. Bellman-Ford 算法</font></h2> 
<p><font size="2"> <strong>Bellman-Ford</strong> 算法可以处理带有负权边的图，它通过迭代松弛操作来查找最短路径。在每轮迭代中，它遍历所有边，不断更新节点的距离值，直到收敛为止。</font></p> 
<p><font size="2">以下是 <strong>Bellman-Ford</strong> 算法的 <strong>Python</strong> 实现：</font></p> 
<pre><code class="prism language-python"><span class="token keyword">def</span> <span class="token function">bellman_ford</span><span class="token punctuation">(</span>graph<span class="token punctuation">,</span> start<span class="token punctuation">)</span><span class="token punctuation">:</span>
    distances <span class="token operator">=</span> <span class="token punctuation">{<!-- --></span>node<span class="token punctuation">:</span> <span class="token builtin">float</span><span class="token punctuation">(</span><span class="token string">'infinity'</span><span class="token punctuation">)</span> <span class="token keyword">for</span> node <span class="token keyword">in</span> graph<span class="token punctuation">}</span>
    distances<span class="token punctuation">[</span>start<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0</span>

    <span class="token keyword">for</span> _ <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span><span class="token builtin">len</span><span class="token punctuation">(</span>graph<span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
        <span class="token keyword">for</span> node <span class="token keyword">in</span> graph<span class="token punctuation">:</span>
            <span class="token keyword">for</span> neighbor<span class="token punctuation">,</span> weight <span class="token keyword">in</span> graph<span class="token punctuation">[</span>node<span class="token punctuation">]</span><span class="token punctuation">.</span>items<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
                <span class="token keyword">if</span> distances<span class="token punctuation">[</span>node<span class="token punctuation">]</span> <span class="token operator">+</span> weight <span class="token operator">&lt;</span> distances<span class="token punctuation">[</span>neighbor<span class="token punctuation">]</span><span class="token punctuation">:</span>
                    distances<span class="token punctuation">[</span>neighbor<span class="token punctuation">]</span> <span class="token operator">=</span> distances<span class="token punctuation">[</span>node<span class="token punctuation">]</span> <span class="token operator">+</span> weight

    <span class="token keyword">return</span> distances
</code></pre> 
<h2><a id="font_size23__SPFA_font_57"></a><font size="2">3. SPFA 算法</font></h2> 
<p><font size="2"> <strong>SPFA</strong> （ <strong>Shortest</strong> <strong>Path</strong> <strong>Faster</strong> <strong>Algorithm</strong> ）是一种基于队列的最短路径算法，类似于 <strong>Bellman-Ford</strong> 算法，但它通过维护一个队列来避免不必要的松弛操作，从而提高了效率。</font></p> 
<p><font size="2">以下是 <strong>SPFA</strong> 算法的 <strong>Python</strong> 实现：</font></p> 
<pre><code class="prism language-python"><span class="token keyword">from</span> collections <span class="token keyword">import</span> deque

<span class="token keyword">def</span> <span class="token function">spfa</span><span class="token punctuation">(</span>graph<span class="token punctuation">,</span> start<span class="token punctuation">)</span><span class="token punctuation">:</span>
    distances <span class="token operator">=</span> <span class="token punctuation">{<!-- --></span>node<span class="token punctuation">:</span> <span class="token builtin">float</span><span class="token punctuation">(</span><span class="token string">'infinity'</span><span class="token punctuation">)</span> <span class="token keyword">for</span> node <span class="token keyword">in</span> graph<span class="token punctuation">}</span>
    distances<span class="token punctuation">[</span>start<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0</span>
    queue <span class="token operator">=</span> deque<span class="token punctuation">(</span><span class="token punctuation">[</span>start<span class="token punctuation">]</span><span class="token punctuation">)</span>
    in_queue <span class="token operator">=</span> <span class="token punctuation">{<!-- --></span>node<span class="token punctuation">:</span> <span class="token boolean">False</span> <span class="token keyword">for</span> node <span class="token keyword">in</span> graph<span class="token punctuation">}</span>
    in_queue<span class="token punctuation">[</span>start<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token boolean">True</span>

    <span class="token keyword">while</span> queue<span class="token punctuation">:</span>
        node <span class="token operator">=</span> queue<span class="token punctuation">.</span>popleft<span class="token punctuation">(</span><span class="token punctuation">)</span>
        in_queue<span class="token punctuation">[</span>node<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token boolean">False</span>

        <span class="token keyword">for</span> neighbor<span class="token punctuation">,</span> weight <span class="token keyword">in</span> graph<span class="token punctuation">[</span>node<span class="token punctuation">]</span><span class="token punctuation">.</span>items<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
            <span class="token keyword">if</span> distances<span class="token punctuation">[</span>node<span class="token punctuation">]</span> <span class="token operator">+</span> weight <span class="token operator">&lt;</span> distances<span class="token punctuation">[</span>neighbor<span class="token punctuation">]</span><span class="token punctuation">:</span>
                distances<span class="token punctuation">[</span>neighbor<span class="token punctuation">]</span> <span class="token operator">=</span> distances<span class="token punctuation">[</span>node<span class="token punctuation">]</span> <span class="token operator">+</span> weight
                <span class="token keyword">if</span> <span class="token keyword">not</span> in_queue<span class="token punctuation">[</span>neighbor<span class="token punctuation">]</span><span class="token punctuation">:</span>
                    queue<span class="token punctuation">.</span>append<span class="token punctuation">(</span>neighbor<span class="token punctuation">)</span>
                    in_queue<span class="token punctuation">[</span>neighbor<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token boolean">True</span>

    <span class="token keyword">return</span> distances
</code></pre> 
<h2><a id="font_size24_font_87"></a><font size="2">4. 优化与比较</font></h2> 
<p><font size="2"> <strong>Dijkstra</strong> 算法适用于非负权边的图， <strong>Bellman-Ford</strong> 算法适用于带负权边的图，而 <strong>SPFA</strong> 算法是 <strong>Bellman-Ford</strong> 算法的一种优化版本，用于提高效率。在实际应用中，你应该根据具体问题的特点来选择合适的算法。</font></p> 
<h2><a id="font_size25_font_91"></a><font size="2">5. 案例分析：地理导航</font></h2> 
<p><font size="2">让我们通过一个案例来说明最短路径算法的应用。假设我们正在开发一个地理导航应用，希望帮助用户找到从一个地点到另一个地点的最短路径。我们可以使用上述算法来解决这个问题。</font></p> 
<p><font size="2">首先，我们需要将地理区域建模成一个图，其中节点表示地点，边表示道路或路径，边的权重可以表示距离或时间。用户可以通过输入起始地点和目的地来触发算法，然后我们可以使用 <strong>Dijkstra</strong> 、 <strong>Bellman-Ford</strong> 或 <strong>SPFA</strong> 算法来计算最短路径。</font></p> 
<p><font size="2">这些算法不仅可以用于道路导航，还可以用于网络路由、飞行航线规划、物流等各种领域。</font></p> 
<h2><a id="font_size26_font_99"></a><font size="2">6. 总结</font></h2> 
<p><font size="2">最短路径算法是图算法中的一个核心领域，具有广泛的应用。 <strong>Dijkstra</strong> 算法、 <strong>Bellman-Ford</strong> 算法和 <strong>SPFA</strong> 算法分别适用于不同类型的图，并且在解决最短路径问题时发挥着关键作用。理解这些算法的原理和实现有助于解决各种实际问题，从地理导航到网络路由。</font></p> 
<p><font size="2"><strong>[ 专栏推荐 ]</strong><br> <a href="https://blog.csdn.net/qq_38161040/category_12379687.html"> 😃 <font color="red">《<strong>Python</strong> 算法初阶：入门篇》</font>😄<br> ❤️【简介】：<font size="2">本课程是针对 <strong>Python</strong> 初学者设计的算法基础入门课程，涵盖算法概念、时间复杂度、空间复杂度等基础知识。通过实例演示线性搜索、二分搜索等算法，并介绍哈希表、深度优先搜索、广度优先搜索等搜索算法。此课程将为学员提供扎实的 <strong>Python</strong> 编程基础与算法入门，为解决实际问题打下坚实基础。</font><br> <img src="https://images2.imgbox.com/19/70/Ng7rFE4X_o.png" alt="在这里插入图片描述"></a></font></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/f062e2b91888f503f5e86ea196bc259a/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">git的使用——如何创建.gitignore文件，排除target、.idea文件夹的提交</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/b0c4ac9170e230f6fac466f0a0e6eb8f/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">用docker-compose快速搭建Nacos集群详细教程</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>