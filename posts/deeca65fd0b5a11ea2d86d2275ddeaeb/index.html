<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>LeetCode 841：钥匙和房间 Keys and Rooms - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="LeetCode 841：钥匙和房间 Keys and Rooms" />
<meta property="og:description" content="题目： ​ 有 N 个房间，开始时你位于 0 号房间。每个房间有不同的号码：0，1，2，...，N-1，并且房间里可能有一些钥匙能使你进入下一个房间。
​ 在形式上，对于每个房间 i 都有一个钥匙列表 rooms[i]，每个钥匙 rooms[i][j] 由 [0,1，...，N-1] 中的一个整数表示，其中 N = rooms.length。 钥匙 rooms[i][j] = v 可以打开编号为 v 的房间。
最初，除 0 号房间外的其余所有房间都被锁住。
你可以自由地在房间之间来回走动。
如果能进入每个房间返回 true，否则返回 false。
​ There are N rooms and you start in room 0. Each room has a distinct number in 0, 1, 2, ..., N-1, and each room may have some keys to access the next room.
​ Formally, each room i has a list of keys rooms[i], and each key rooms[i][j] is an integer in [0, 1, ." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/deeca65fd0b5a11ea2d86d2275ddeaeb/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2019-09-21T20:40:00+08:00" />
<meta property="article:modified_time" content="2019-09-21T20:40:00+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">LeetCode 841：钥匙和房间 Keys and Rooms</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <div id="cnblogs_post_body" class="blogpost-body cnblogs-markdown"> 
 <h4 id="题目">题目：</h4> 
 <p>​ 有 <code>N</code> 个房间，开始时你位于 <code>0</code> 号房间。每个房间有不同的号码：<code>0，1，2，...，N-1</code>，并且房间里可能有一些钥匙能使你进入下一个房间。</p> 
 <p>​ 在形式上，对于每个房间 <code>i</code> 都有一个钥匙列表 <code>rooms[i]</code>，每个钥匙 <code>rooms[i][j]</code> 由 <code>[0,1，...，N-1]</code> 中的一个整数表示，其中 <code>N = rooms.length</code>。 钥匙 <code>rooms[i][j] = v</code> 可以打开编号为 <code>v</code> 的房间。</p> 
 <p>最初，除 <code>0</code> 号房间外的其余所有房间都被锁住。</p> 
 <p>你可以自由地在房间之间来回走动。</p> 
 <p>如果能进入每个房间返回 <code>true</code>，否则返回 <code>false</code>。</p> 
 <p>​ There are <code>N</code> rooms and you start in room <code>0</code>. Each room has a distinct number in <code>0, 1, 2, ..., N-1</code>, and each room may have some keys to access the next room.</p> 
 <p>​ Formally, each room <code>i</code> has a list of keys <code>rooms[i]</code>, and each key <code>rooms[i][j]</code> is an integer in <code>[0, 1, ..., N-1]</code> where <code>N = rooms.length</code>. A key <code>rooms[i][j] = v</code> opens the room with number <code>v</code>.</p> 
 <p>Initially, all the rooms start locked (except for room <code>0</code>).</p> 
 <p>You can walk back and forth between rooms freely.</p> 
 <p>Return <code>true</code> if and only if you can enter every room.</p> 
 <p><strong>示例 1：</strong></p> 
 <pre><code>输入: [[1],[2],[3],[]]
输出: true
解释:  
我们从 0 号房间开始，拿到钥匙 1。
之后我们去 1 号房间，拿到钥匙 2。
然后我们去 2 号房间，拿到钥匙 3。
最后我们去了 3 号房间。
由于我们能够进入每个房间，我们返回 true。</code></pre> 
 <p><strong>示例 2：</strong></p> 
 <pre><code>输入：[[1,3],[3,0,1],[2],[0]]
输出：false
解释：我们不能进入 2 号房间。</code></pre> 
 <p><strong>提示：</strong></p> 
 <ol><li><code>1 &lt;= rooms.length &lt;= 1000</code></li><li><code>0 &lt;= rooms[i].length &lt;= 1000</code></li><li>所有房间中的钥匙数量总计不超过 <code>3000</code>。</li></ol> 
 <p><strong>Note:</strong></p> 
 <ol><li><code>1 &lt;= rooms.length &lt;= 1000</code></li><li><code>0 &lt;= rooms[i].length &lt;= 1000</code></li><li>The number of keys in all rooms combined is at most <code>3000</code>.</li></ol> 
 <h4 id="解题思路">解题思路：</h4> 
 <p>​ 很简单的一道题，从0号房间开始递归遍历就可以了。唯一需要注意的是如何判断房间是否访问过。可以用set哈希表把已访问过的房间号记录下来，最后如果哈希表长度和rooms长度相等，那么就意味着所有房间均可到达。</p> 
 <h4 id="代码">代码：</h4> 
 <p><strong>Set集合(Java):</strong></p> 
 <pre><code class="language-java"><code>class Solution {
    Set&lt;Integer&gt; set = new LinkedHashSet&lt;&gt;();

    public boolean canVisitAllRooms(List&lt;List&lt;Integer&gt;&gt; rooms) {
        helper(rooms, 0);
        return set.size() == rooms.size();//长度相等则可以到达所有房间
    }

    private void helper(List&lt;List&lt;Integer&gt;&gt; rooms, int index) {
        if (set.contains(index)) return;
         set.add(index);//已访问房间号加入哈希表
        for (Integer i : rooms.get(index)) {//遍历房间的每一个钥匙
                helper(rooms, i);//进入递归
        }
    }
}</code></code></pre> 
 <p>​ 可以看到用哈希表解题方法在递归期间会多出许多set函数的调用，如 set.add() 、set.contains()，相对很多这道题解题时间，这个开销是很大。对这道题而言，是完全可以用数组避免的。</p> 
 <p><strong>Java：</strong></p> 
 <pre><code class="language-java"><code>class Solution {

    public boolean canVisitAllRooms(List&lt;List&lt;Integer&gt;&gt; rooms) {
        int len = rooms.size();
        int[] visited = new int[len];//初始化等长数组，数组每个值默认为0
        helper(rooms, 0, visited);
        for (int i : visited)
            if (i == 0) return false;//数组中依然有0，则证明有房间未访问到
        return true;
    }

    private void helper(List&lt;List&lt;Integer&gt;&gt; rooms, int index, int[] visited) {
        if (visited[index] == 1) return;//如果该房间已访问过，直接返回
        visited[index] = 1;//在访问过的房间，改为1来标记
        for (Integer i : rooms.get(index)) {//遍历
            helper(rooms, i, visited);
        }
    }
}</code></code></pre> 
 <p><strong>Python：</strong></p> 
 <pre><code class="language-python"><code>class Solution:
    def canVisitAllRooms(self, rooms: List[List[int]]) -&gt; bool:
        size=len(rooms)
        self.visited = [False]*size # 初始化等长数组，默认为False，所有房间均未访问
        self.helper(rooms, 0)
        return all(self.visited)

    def helper(self, rooms: List[List[int]], index: int) -&gt; None:
        if self.visited[index]:#如果为True，该房间已访问过，直接返回
            return
        self.visited[index] = True #在访问的房间标记为True
        for i in rooms[index]:#遍历钥匙
            self.helper(rooms, i)#进入递归函数</code></code></pre> 
 <p>欢迎关注微.信公.众号：爱写Bug<br><img src="https://images2.imgbox.com/2d/9a/XNQW6ofT_o.jpg" alt="在这里插入图片描述"></p> 
</div> 
<p>转载于:https://www.cnblogs.com/zhangzhe532/p/11564522.html</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/071f08ad34de13a1929fc1fe91ce17cd/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">Mysql创建数据库和指定权限</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/96f04c85369ee227475f7516c3a2332f/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">解决 Navicat 无法导入带外键的json 亲测有效！</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>