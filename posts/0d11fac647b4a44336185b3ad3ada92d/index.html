<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>标准C库函数之perror()、strerror()，以及他们之间各种的优缺点（打印错误信息） - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="标准C库函数之perror()、strerror()，以及他们之间各种的优缺点（打印错误信息）" />
<meta property="og:description" content="前言 如果，想要深入的学习标准C库中perror、strerror函数，还是需要去自己阅读Linux系统中的帮助文档。
具体输入命令：
man 3 perror man 3 strerror 即可查阅到完整的资料信息。
perror函数 perror函数是C语言标准库中的一个函数，用于在发生系统调用错误时输出有关错误信息的描述。该函数定义在stdio.h头文件中。perror根据传入的参数（通常是一个字符串）生成一个描述性的错误消息，然后将这个消息输出到标准错误流(stderr)。
函数原型如下：
#include &lt;stdio.h&gt; //使用此函数需引入此头文件 void perror(const char *str); 参数：
str：一个指向常量字符的指针，用于提供上下文信息。在输出错误消息时，这个字符串将作为错误消息的前缀（也就是说，你可以手动的去描述这个错误是怎么发生的）。 perror的工作原理：当一个系统调用或库函数发生错误时，通常会将全局变量errno设置为一个特定的错误码。perror函数读取errno的值，并根据这个值生成相应的错误描述。然后，将错误描述与传入的字符串参数拼接，并输出到标准错误流。
使用示例：
#include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; int main() { FILE *file_ptr; file_ptr = fopen(&#34;non_existent_file.txt&#34;, &#34;r&#34;); if (file_ptr == NULL) { perror(&#34;Error opening file&#34;); return 1; } // ... 其他操作 ... fclose(file_ptr); return 0; } 在上面的示例中，当试图打开一个不存在的文件时，fopen函数会返回NULL，并将errno设置为一个特定的错误码。
调用perror函数输出类似于以下内容的错误消息：
Error opening file: No such file or directory 这里的&#34;Error opening file&#34;是传入的字符串参数，而&#34;No such file or directory&#34;" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/0d11fac647b4a44336185b3ad3ada92d/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-06-01T19:51:14+08:00" />
<meta property="article:modified_time" content="2023-06-01T19:51:14+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">标准C库函数之perror()、strerror()，以及他们之间各种的优缺点（打印错误信息）</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-dracula">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <h2><a id="_0"></a>前言</h2> 
<blockquote> 
 <p>如果，想要深入的学习标准C库中perror、strerror函数，还是需要去自己阅读Linux系统中的帮助文档。</p> 
</blockquote> 
<p><strong>具体输入命令：</strong></p> 
<pre><code class="prism language-cpp">man <span class="token number">3</span> perror
man <span class="token number">3</span> strerror
</code></pre> 
<p>即可查阅到完整的资料信息。</p> 
<h3><a id="perror_12"></a>perror函数</h3> 
<blockquote> 
 <p>perror函数是C语言标准库中的一个函数，<code>用于在发生系统调用错误时输出有关错误信息的描述。</code>该函数定义在<code>stdio.h</code>头文件中。perror根据传入的参数（通常是一个字符串）生成一个描述性的错误消息，然后将这个消息输出到标准错误流(stderr)。</p> 
</blockquote> 
<p><strong>函数原型如下：</strong></p> 
<pre><code class="prism language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h&gt;</span> <span class="token comment">//使用此函数需引入此头文件</span></span>

<span class="token keyword">void</span> <span class="token function">perror</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>str<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> 
<p><strong>参数：</strong></p> 
<ul><li>str：一个指向常量字符的指针，用于提供上下文信息。<code>在输出错误消息时，这个字符串将作为错误消息的前缀</code>（也就是说，你可以手动的去描述这个错误是怎么发生的）。</li></ul> 
<p><strong>perror的工作原理</strong>：当一个系统调用或库函数发生错误时，通常会将<code>全局变量errno</code>设置为一个特定的错误码。perror函数读取errno的值，并根据这个值生成相应的错误描述。然后，将错误描述与传入的字符串参数拼接，并输出到标准错误流。</p> 
<p><strong>使用示例：</strong></p> 
<pre><code class="prism language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdlib.h&gt;</span></span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    FILE <span class="token operator">*</span>file_ptr<span class="token punctuation">;</span>

    file_ptr <span class="token operator">=</span> <span class="token function">fopen</span><span class="token punctuation">(</span><span class="token string">"non_existent_file.txt"</span><span class="token punctuation">,</span> <span class="token string">"r"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>file_ptr <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token function">perror</span><span class="token punctuation">(</span><span class="token string">"Error opening file"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span> <span class="token number">1</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token comment">// ... 其他操作 ...</span>

    <span class="token function">fclose</span><span class="token punctuation">(</span>file_ptr<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>在上面的示例中，当试图打开一个不存在的文件时，fopen函数会返回NULL，并将errno设置为一个特定的错误码。</p> 
<p><strong>调用perror函数输出类似于以下内容的错误消息：</strong></p> 
<pre><code class="prism language-cpp">Error opening file<span class="token operator">:</span> No such file <span class="token operator">or</span> directory
</code></pre> 
<p>这里的"Error opening file"是传入的字符串参数，而"No such file or directory"是由perror根据errno值生成的描述性错误信息。</p> 
<h3><a id="strerror__64"></a>strerror 函数</h3> 
<blockquote> 
 <p>strerror函数是标准C库中的一种函数，它用于生成描述错误代码的字符串。这个函数在string.h头文件中定义。</p> 
</blockquote> 
<p><strong>这个函数的原型是：</strong></p> 
<pre><code class="prism language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;string.h&gt;</span> <span class="token comment">//使用此函数需引入此头文件</span></span>

<span class="token keyword">char</span> <span class="token operator">*</span><span class="token function">strerror</span><span class="token punctuation">(</span><span class="token keyword">int</span> errnum<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> 
<p><strong>参数：</strong></p> 
<ul><li>该函数接受一个<code>整数errnum作为参数</code>，这个参数通常是一个错误代码，比如你可能从某些函数（如open或read）中得到这样的错误代码。</li></ul> 
<p><strong>返回值：</strong></p> 
<ul><li>函数<code>会返回一个指向描述该错误的字符串的指针</code>。这个字符串可以用来打印错误消息，使得用户能够理解发生了什么问题。</li></ul> 
<p><strong>例如，你可以这样使用strerror：</strong></p> 
<pre><code class="prism language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;string.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;errno.h&gt;</span></span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    FILE <span class="token operator">*</span>file <span class="token operator">=</span> <span class="token function">fopen</span><span class="token punctuation">(</span><span class="token string">"non_existent_file.txt"</span><span class="token punctuation">,</span> <span class="token string">"r"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>file <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"打开文件出错: %s\n"</span><span class="token punctuation">,</span> <span class="token function">strerror</span><span class="token punctuation">(</span>errno<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span> <span class="token number">1</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token comment">// 做一些处理</span>
    <span class="token function">fclose</span><span class="token punctuation">(</span>file<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<ul><li> <p>在这个例子中，如果文件不存在，fopen会返回NULL，并将errno设置为表示错误的值。然后，我们可以使用strerror来获取并打印描述这个错误的消息。</p> </li><li> <p>需要注意的是，strerror返回的字符串是静态分配的，不需要（也不应该）被手动释放。此外，因为strerror返回的是静态数据，所以它不是线程安全的。在多线程环境中，你可能需要使用strerror_r，这个函数有一个额外的参数用于存储结果，可以避免竞态条件。</p> </li><li> <p>另外，也应该注意strerror可能不会知道所有可能的错误代码。如果你传递一个它不认识的错误代码，它可能会返回一个消息说这个错误未知。</p> </li></ul> 
<h3><a id="strerrorperror_111"></a>strerror()函数与perror()函数各种的优缺点</h3> 
<blockquote> 
 <p><strong>strerror</strong></p> 
</blockquote> 
<p><strong>优点：</strong></p> 
<ul><li> <p><code>灵活性</code>：strerror返回一个字符串，这使得你可以自由地使用这个字符串。例如，你可以将其存储，发送给用户，或者记录到日志中。</p> </li><li> <p><code>自定义错误消</code>息：可以通过与其他字符串拼接，创建定制的错误消息。</p> </li></ul> 
<p><strong>缺点：</strong></p> 
<ul><li> <p>需要手动处理错误消息：在打印错误消息时，需要手动处理错误消息的格式化和输出。</p> </li><li> <p><code>非线程安全</code>：strerror在多线程环境中可能会产生问题，因为它返回静态内存中的字符串。如果你需要线程安全，需要使用strerror_r版本。</p> </li></ul> 
<blockquote> 
 <p><strong>perror</strong></p> 
</blockquote> 
<p><strong>优点：</strong></p> 
<ul><li> <p><code>简单易用</code>：perror在打印错误消息时无需处理错误消息的格式化和输出，使得错误处理代码更加简洁。</p> </li><li> <p><code>自动生成错误消息</code>：它自动地在你提供的自定义消息后添加一个描述错误的消息。</p> </li></ul> 
<p><strong>缺点：</strong></p> 
<ul><li> <p><code>不够灵活</code>：perror总是将错误消息输出到标准错误输出。如果你需要将错误消息发送到其他地方，你就无法使用perror。</p> </li><li> <p><code>缺乏自定义</code>：虽然你可以提供自定义消息，但perror控制的消息格式有限。如果你需要更特殊的格式，可能需要使用strerror。</p> </li></ul> 
<p>总的来说，选择使用哪一个函数取决于你的需求。如果你需要处理错误消息，例如将其发送到特定的日志系统，或者创建定制的错误消息，那么strerror可能是更好的选择。如果你只需要快速地向用户报告错误，并且默认的格式足够好，那么perror可能是更好的选择。</p> 
<h3><a id="strerror_r__143"></a>strerror_r 函数</h3> 
<blockquote> 
 <p>strerror_r函数是标准C库中的另一种处理错误的函数，它与strerror函数类似，但具有线程安全性。</p> 
</blockquote> 
<ul><li><strong>在标准C库中，strerror_r函数有两个不同的实现</strong>：<code>POSIX和GNU</code>。它们具有不同的原型和行为，我将分别介绍它们。</li></ul> 
<blockquote> 
 <p>POSIX版本的strerror_r</p> 
</blockquote> 
<p><strong>POSIX版本的strerror_r的原型如下：</strong></p> 
<pre><code class="prism language-cpp"><span class="token keyword">int</span> <span class="token function">strerror_r</span><span class="token punctuation">(</span><span class="token keyword">int</span> errnum<span class="token punctuation">,</span> <span class="token keyword">char</span> <span class="token operator">*</span>buf<span class="token punctuation">,</span> size_t buflen<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> 
<p><strong>这个函数接受三个参数：</strong></p> 
<ul><li>errnum：错误码。</li><li>buf：用于存储错误消息的缓冲区。</li><li>buflen：缓冲区的大小。</li></ul> 
<p><strong>返回值</strong></p> 
<ul><li> <p>函数的返回值是一个整数，表示操作的成功与否。如果返回值为0，表示成功获取错误消息；如果返回值为正数，表示错误码无效，无法获取错误消息；如果返回值为负数，表示发生了错误。</p> </li><li> <p>需要注意的是，POSIX版本的strerror_r函数的行为和strerror函数略有不同。它不返回一个静态字符串指针，而是将错误消息复制到提供的缓冲区中。因此，这个函数是线程安全的，因为它使用了用户提供的缓冲区。</p> </li></ul> 
<blockquote> 
 <p>GNU版本的strerror_r</p> 
</blockquote> 
<p><strong>GNU版本的strerror_r的原型如下：</strong></p> 
<pre><code class="prism language-cpp"><span class="token keyword">char</span> <span class="token operator">*</span><span class="token function">strerror_r</span><span class="token punctuation">(</span><span class="token keyword">int</span> errnum<span class="token punctuation">,</span> <span class="token keyword">char</span> <span class="token operator">*</span>buf<span class="token punctuation">,</span> size_t buflen<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> 
<p><strong>这个函数接受三个参数：</strong></p> 
<ul><li>errnum：错误码。</li><li>buf：用于存储错误消息的缓冲区。</li><li>buflen：缓冲区的大小。</li></ul> 
<p><strong>返回值</strong></p> 
<ul><li> <p>函数的返回值是一个指向错误消息字符串的指针。与strerror函数不同，GNU版本的strerror_r并不返回静态分配的字符串，而是将错误消息复制到提供的缓冲区中，并返回指向缓冲区的指针。</p> </li><li> <p>这个版本的strerror_r在多线程环境中是安全的，因为它将错误消息存储在用户提供的缓冲区中，而不是使用静态内存。</p> </li><li> <p>需要注意的是，GNU版本的strerror_r与POSIX版本的返回类型和行为不同。在GNU版本中，返回值始终是指向错误消息字符串的指针，不论操作是否成功。</p> </li></ul> 
<p><strong>使用哪个版本取决于在编译时使用的特性测试宏。</strong><code>如果定义了 _POSIX_C_SOURCE，则使用 XSI-compliant version，否则使用 GNU-specific version。这也是为什么 strerror_r 函数在不同的系统和设置中可能有不同的行为。</code></p> 
<h3><a id="_194"></a>总结</h3> 
<p><strong>在我们的讨论中，我们涉及了以下内容：</strong></p> 
<ul><li> <p>strerror函数：它是标准C库中的函数，用于生成描述错误代码的字符串。它接受一个错误码作为参数，并返回一个描述错误的字符串。这个字符串可以用于打印错误消息或其他需要错误描述的场景。</p> </li><li> <p>perror函数：它也是标准C库中的函数，用于报告错误消息。它会打印你提供的自定义消息，后跟一个冒号、一个空格，然后是描述当前错误的消息。它的优点是简单易用，适用于快速报告错误的场景。</p> </li><li> <p>strerror_r函数：它是标准C库中的函数，用于获取描述错误代码的字符串，同时具备线程安全性。它有两个不同的实现：POSIX和GNU。POSIX版本将错误消息复制到用户提供的缓冲区中，并返回一个表示操作成功与否的整数。而GNU版本将错误消息复制到用户提供的缓冲区中，并返回指向缓冲区的指针。</p> </li></ul> 
<p>总体而言，strerror函数和strerror_r函数用于获取描述错误的字符串，而perror函数用于报告错误消息。选择使用哪个函数取决于你的需求和编程环境，例如需要灵活性、自定义错误消息还是线程安全性。</p> 
<p><code>最后的最后，如果你觉得我的这篇文章写的不错的话，请给我一个赞与收藏，关注我，我会继续给大家带来更多更优质的干货内容</code>。</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/333d2f30451ec02ec3276612f3f07fd1/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">STM32F4_LCD/OLED在线取字模软件</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/217ee34b33d8ecf2ba39ba9c83a44526/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">js输入和输出语句及字面量</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>