<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>彻底搞懂String：字符串常量池 - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="彻底搞懂String：字符串常量池" />
<meta property="og:description" content="作为最基础的引用数据类型，Java 设计者为 String 提供了字符串常量池以提高其性能，那么字符串常量池的具体原理是什么，我们带着以下三个问题，去理解字符串常量池：
1、字符串常量池的设计意图是什么？
2、字符串常量池在哪里？
3、如何操作字符串常量池？
字符串常量池的设计思想
1、字符串的分配，和其他的对象分配一样，耗费高昂的时间与空间代价，作为最基础的数据类型，大量频繁的创建字符串，极大程度地影响程序的性能。
2、JVM为了提高性能和减少内存开销，在实例化字符串常量的时候进行了一些优化。
1）为字符串开辟一个字符串常量池，类似于缓存区。
2）创建字符串常量时，首先坚持字符串常量池是否存在该字符串。
3）存在该字符串，返回引用实例，不存在，实例化该字符串并放入池中。
3、实现的基础
1）实现该优化的基础是因为字符串是不可变的，可以不用担心数据冲突进行共享。
2）运行时实例创建的全局字符串常量池中有一个表，总是为池中每个唯一的字符串对象维护一个引用,这就意味着它们一直引用着字符串常量池中的对象，所以，在常量池中的这些字符串不会被垃圾收集器回收。
代码：从字符串常量池中获取相应的字符串
字符串常量池在哪里
在分析字符串常量池的位置时，首先了解一下堆、栈、方法区：
1、堆
1）存储的是对象，每个对象都包含一个与之对应的class。
2）JVM只有一个堆区(heap)被所有线程共享，堆中不存放基本类型和对象引用，只存放对象本身。
3）对象的由垃圾回收器负责回收，因此大小和生命周期不需要确定。
2、栈
1）每个线程包含一个栈区，栈中只保存基础数据类型的对象和自定义对象的引用(不是对象)。
2）每个栈中的数据(原始类型和对象引用)都是私有的。
3）栈分为3个部分：基本类型变量区、执行环境上下文、操作指令区(存放操作指令)。
4）数据大小和生命周期是可以确定的，当没有引用指向数据时，这个数据就会自动消失。
3、方法区
1）静态区，跟堆一样，被所有的线程共享。
2）方法区中包含的都是在整个程序中永远唯一的元素，如class，static变量。
字符串常量池则存在于方法区
代码：堆栈方法区存储字符串
字符串对象的创建
面试题：String str4 = new String(“abc”) 创建多少个对象？
1、在常量池中查找是否有“abc”对象。
1）有则返回对应的引用实例；
2）没有则创建对应的实例对象。
2、在堆中 new 一个 String(&#34;abc&#34;) 对象。
3、将对象地址赋值给str4，创建一个引用。
所以，常量池中没有“abc”字面量则创建两个对象，否则创建一个对象，以及创建一个引用。
根据字面量，往往会提出这样的变式题：
String str1 = new String(&#34;A&#34;&#43;&#34;B&#34;) ; 会创建多少个对象?
String str2 = new String(&#34;ABC&#34;) &#43; &#34;ABC&#34; ; 会创建多少个对象?
str1：
字符串常量池：&#34;A&#34;,&#34;B&#34;,&#34;AB&#34; : 3个" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/f040f569ce4d46c28b813a99758f5630/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2021-05-03T16:40:27+08:00" />
<meta property="article:modified_time" content="2021-05-03T16:40:27+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">彻底搞懂String：字符串常量池</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p>作为最基础的引用数据类型，Java 设计者为 String 提供了字符串常量池以提高其性能，那么字符串常量池的具体原理是什么，我们带着以下三个问题，去理解字符串常量池：</p> 
<p>1、字符串常量池的设计意图是什么？</p> 
<p>2、字符串常量池在哪里？</p> 
<p>3、如何操作字符串常量池？</p> 
<p>字符串常量池的设计思想</p> 
<p>1、字符串的分配，和其他的对象分配一样，耗费高昂的时间与空间代价，作为最基础的数据类型，大量频繁的创建字符串，极大程度地影响程序的性能。</p> 
<p>2、JVM为了提高性能和减少内存开销，在实例化字符串常量的时候进行了一些优化。</p> 
<p>1）为字符串开辟一个字符串常量池，类似于缓存区。</p> 
<p>2）创建字符串常量时，首先坚持字符串常量池是否存在该字符串。</p> 
<p>3）存在该字符串，返回引用实例，不存在，实例化该字符串并放入池中。</p> 
<p>3、实现的基础</p> 
<p>1）实现该优化的基础是因为字符串是不可变的，可以不用担心数据冲突进行共享。</p> 
<p>2）运行时实例创建的全局字符串常量池中有一个表，总是为池中每个唯一的字符串对象维护一个引用,这就意味着它们一直引用着字符串常量池中的对象，所以，在常量池中的这些字符串不会被垃圾收集器回收。</p> 
<p>代码：从字符串常量池中获取相应的字符串</p> 
<p><img alt="" src="https://images2.imgbox.com/da/17/0ZJ1jRSS_o.png"></p> 
<p>字符串常量池在哪里</p> 
<p>在分析字符串常量池的位置时，首先了解一下堆、栈、方法区：</p> 
<p><img alt="" src="https://images2.imgbox.com/22/25/dkQkAkXg_o.png"></p> 
<p>1、堆</p> 
<p>1）存储的是对象，每个对象都包含一个与之对应的class。</p> 
<p>2）JVM只有一个堆区(heap)被所有线程共享，堆中不存放基本类型和对象引用，只存放对象本身。</p> 
<p>3）对象的由垃圾回收器负责回收，因此大小和生命周期不需要确定。</p> 
<p>2、栈</p> 
<p>1）每个线程包含一个栈区，栈中只保存基础数据类型的对象和自定义对象的引用(不是对象)。</p> 
<p>2）每个栈中的数据(原始类型和对象引用)都是私有的。</p> 
<p>3）栈分为3个部分：基本类型变量区、执行环境上下文、操作指令区(存放操作指令)。</p> 
<p>4）数据大小和生命周期是可以确定的，当没有引用指向数据时，这个数据就会自动消失。</p> 
<p>3、方法区</p> 
<p>1）静态区，跟堆一样，被所有的线程共享。</p> 
<p>2）方法区中包含的都是在整个程序中永远唯一的元素，如class，static变量。</p> 
<p><strong>字符串常量池则存在于方法区</strong></p> 
<p>代码：堆栈方法区存储字符串</p> 
<p><img alt="" src="https://images2.imgbox.com/c1/c6/woiLagJu_o.png"></p> 
<p><img alt="" src="https://images2.imgbox.com/f5/df/XveNdGp0_o.png"></p> 
<p><strong>字符串对象的创建</strong></p> 
<p>面试题：String str4 = new String(“abc”) 创建多少个对象？</p> 
<p>1、在常量池中查找是否有“abc”对象。</p> 
<p>1）有则返回对应的引用实例；</p> 
<p>2）没有则创建对应的实例对象。</p> 
<p>2、在堆中 new 一个 String("abc") 对象。</p> 
<p>3、将对象地址赋值给str4，创建一个引用。</p> 
<p>所以，常量池中没有“abc”字面量则创建两个对象，否则创建一个对象，以及创建一个引用。</p> 
<p>根据字面量，往往会提出这样的变式题：</p> 
<p><strong>String str1 = new String("A"+"B") ; 会创建多少个对象?</strong></p> 
<p><strong>String str2 = new String("ABC") + "ABC" ; 会创建多少个对象?</strong></p> 
<p>str1：</p> 
<p>字符串常量池："A","B","AB" : 3个</p> 
<p>堆：new String("AB") ：1个</p> 
<p>引用： str1 ：1个</p> 
<p>总共 ： 5个</p> 
<p>str2 ：</p> 
<p>字符串常量池："ABC" : 1个</p> 
<p>堆：new String("ABC") ：1个</p> 
<p>引用： str2 ：1个</p> 
<p>总共 ： 3个</p> 
<p>代码：基础类型的变量和常量，变量和引用存储在栈中，常量存储在常量池中。</p> 
<p><img alt="" src="https://images2.imgbox.com/4e/3c/hKAOmw3W_o.png"></p> 
<p><img alt="" src="https://images2.imgbox.com/26/40/XRpVdXmH_o.png"></p> 
<p>操作字符串常量池的方式</p> 
<p>1、JVM实例化字符串常量池时</p> 
<p><img alt="" src="https://images2.imgbox.com/38/b0/nWU6KOw6_o.png"></p> 
<p>2、String.intern()</p> 
<p>通过new操作符创建的字符串对象不指向字符串池中的任何对象，但是可以通过使用字符串的intern()方法来指向其中的某一个。java.lang.String.intern()返回一个保留池字符串，就是一个在全局字符串池中有了一个入口。如果以前没有在全局字符串池中，那么它就会被添加到里面。</p> 
<p><img alt="" src="https://images2.imgbox.com/ba/87/ydl9WWth_o.png"></p> 
<p>补充：字面量和常量池初探</p> 
<p>字符串对象内部是用字符数组存储的，那么看下面的例子：</p> 
<p><img alt="" src="https://images2.imgbox.com/08/ca/dtLWQYOI_o.png"></p> 
<p>1、会分配一个11长度的char数组，并在常量池分配一个由这个char数组组成的字符串，然后由m去引用这个字符串。</p> 
<p>2、用n去引用常量池里边的字符串，所以和n引用的是同一个对象。</p> 
<p>3、生成一个新的字符串，但内部的字符数组引用着m内部的字符数组。</p> 
<p>4、同样会生成一个新的字符串，但内部的字符数组引用常量池里边的字符串内部的字符数组，意思是和u是同样的字符数组。</p> 
<p>使用图来表示的话，情况就大概是这样的(使用虚线只是表示两者其实没什么特别的关系)：</p> 
<p><img alt="" src="https://images2.imgbox.com/e1/33/u0mN96OG_o.png"></p> 
<p>测试demo：</p> 
<p><img alt="" src="https://images2.imgbox.com/11/55/Ofyi5bxS_o.png"></p> 
<p>结论：</p> 
<p>1、m和n是同一个对象；</p> 
<p>2、m,u,v都是不同的对象；</p> 
<p>3、m,u,v,n但都使用了同样的字符数组，并且用equal判断的话也会返回true。</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/57a00d3267030c5e954bc74b205b37ee/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">秒懂设计模式之状态模式（State Pattern）</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/85fa47bb94fbc13f844533160381f1d3/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">正则表达式之提取数字</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>