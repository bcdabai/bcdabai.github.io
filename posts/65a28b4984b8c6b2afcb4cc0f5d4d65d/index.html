<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>netty 文件上传服务器,GitHub - haoxiaoyong1014/netty-file: netty之文件传输 - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="netty 文件上传服务器,GitHub - haoxiaoyong1014/netty-file: netty之文件传输" />
<meta property="og:description" content="Netty 文件传输
在之前的项目中介绍了
这次通过 Netty 传递文件
项目依赖
io.netty
netty-all
4.1.21.Final
和之前的两个例子中的依赖是一样的
项目中的重要部分代码
客户端
FileUploadClientHandler
public class FileUploadClientHandler extends ChannelInboundHandlerAdapter {
private int byteRead;
private volatile int start = 0;
private volatile int lastLength = 0;
public RandomAccessFile randomAccessFile;
private FileUploadFile fileUploadFile;
private final static Logger LOGGER = LoggerFactory.getLogger(FileUploadClientHandler.class);
public FileUploadClientHandler(FileUploadFile ef) {
if (ef.getFile().exists()) {
if (!ef.getFile().isFile()) {
System.out.println(&#34;Not a file :&#34; &#43; ef.getFile());
return;
}
}
this.fileUploadFile = ef;" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/65a28b4984b8c6b2afcb4cc0f5d4d65d/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2021-07-31T14:23:19+08:00" />
<meta property="article:modified_time" content="2021-07-31T14:23:19+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">netty 文件上传服务器,GitHub - haoxiaoyong1014/netty-file: netty之文件传输</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <div style="font-size:16px;"> 
 <p>Netty 文件传输</p> 
 <p>在之前的项目中介绍了</p> 
 <p>这次通过 Netty 传递文件</p> 
 <p>项目依赖</p> 
 <p>io.netty</p> 
 <p>netty-all</p> 
 <p>4.1.21.Final</p> 
 <p>和之前的两个例子中的依赖是一样的</p> 
 <p>项目中的重要部分代码</p> 
 <p>客户端</p> 
 <p>FileUploadClientHandler</p> 
 <p>public class FileUploadClientHandler extends ChannelInboundHandlerAdapter {<!-- --></p> 
 <p>private int byteRead;</p> 
 <p>private volatile int start = 0;</p> 
 <p>private volatile int lastLength = 0;</p> 
 <p>public RandomAccessFile randomAccessFile;</p> 
 <p>private FileUploadFile fileUploadFile;</p> 
 <p>private final static Logger LOGGER = LoggerFactory.getLogger(FileUploadClientHandler.class);</p> 
 <p>public FileUploadClientHandler(FileUploadFile ef) {<!-- --></p> 
 <p>if (ef.getFile().exists()) {<!-- --></p> 
 <p>if (!ef.getFile().isFile()) {<!-- --></p> 
 <p>System.out.println("Not a file :" + ef.getFile());</p> 
 <p>return;</p> 
 <p>}</p> 
 <p>}</p> 
 <p>this.fileUploadFile = ef;</p> 
 <p>}</p> 
 <p>@Override</p> 
 <p>public void channelInactive(ChannelHandlerContext ctx) throws Exception {<!-- --></p> 
 <p>// TODO Auto-generated method stub</p> 
 <p>super.channelInactive(ctx);</p> 
 <p>LOGGER.info("客户端结束传递文件channelInactive()");</p> 
 <p>}</p> 
 <p>public void channelActive(ChannelHandlerContext ctx) {<!-- --></p> 
 <p>LOGGER.info("正在执行channelActive()方法.....");</p> 
 <p>try {<!-- --></p> 
 <p>randomAccessFile = new RandomAccessFile(fileUploadFile.getFile(),</p> 
 <p>"r");</p> 
 <p>randomAccessFile.seek(fileUploadFile.getStarPos());</p> 
 <p>// lastLength = (int) randomAccessFile.length() / 10;</p> 
 <p>lastLength = 1024 * 10;</p> 
 <p>byte[] bytes = new byte[lastLength];</p> 
 <p>if ((byteRead = randomAccessFile.read(bytes)) != -1) {<!-- --></p> 
 <p>fileUploadFile.setEndPos(byteRead);</p> 
 <p>fileUploadFile.setBytes(bytes);</p> 
 <p>ctx.writeAndFlush(fileUploadFile); //发送消息到服务端</p> 
 <p>} else {<!-- --></p> 
 <p>}</p> 
 <p>LOGGER.info("channelActive()文件已经读完 " + byteRead);</p> 
 <p>} catch (FileNotFoundException e) {<!-- --></p> 
 <p>e.printStackTrace();</p> 
 <p>} catch (IOException i) {<!-- --></p> 
 <p>i.printStackTrace();</p> 
 <p>}</p> 
 <p>LOGGER.info("channelActive()方法执行结束");</p> 
 <p>}</p> 
 <p>@Override</p> 
 <p>public void channelRead(ChannelHandlerContext ctx, Object msg)</p> 
 <p>throws Exception {<!-- --></p> 
 <p>if (msg instanceof Integer) {<!-- --></p> 
 <p>start = (Integer) msg;</p> 
 <p>if (start != -1) {<!-- --></p> 
 <p>randomAccessFile = new RandomAccessFile(fileUploadFile.getFile(), "r");</p> 
 <p>randomAccessFile.seek(start); //将文件定位到start</p> 
 <p>LOGGER.info("长度：" + (randomAccessFile.length() - start));</p> 
 <p>int a = (int) (randomAccessFile.length() - start);</p> 
 <p>int b = (int) (randomAccessFile.length() / 1024 * 2);</p> 
 <p>if (a &lt; lastLength) {<!-- --></p> 
 <p>lastLength = a;</p> 
 <p>}</p> 
 <p>LOGGER.info("文件长度：" + (randomAccessFile.length()) + ",start:" + start + ",a:" + a + ",b:" + b + ",lastLength:" + lastLength);</p> 
 <p>byte[] bytes = new byte[lastLength];</p> 
 <p>LOGGER.info("bytes的长度是="+bytes.length);</p> 
 <p>if ((byteRead = randomAccessFile.read(bytes)) != -1 &amp;&amp; (randomAccessFile.length() - start) &gt; 0) {<!-- --></p> 
 <p>LOGGER.info("byteRead = " + byteRead);</p> 
 <p>fileUploadFile.setEndPos(byteRead);</p> 
 <p>fileUploadFile.setBytes(bytes);</p> 
 <p>try {<!-- --></p> 
 <p>ctx.writeAndFlush(fileUploadFile);</p> 
 <p>} catch (Exception e) {<!-- --></p> 
 <p>e.printStackTrace();</p> 
 <p>}</p> 
 <p>} else {<!-- --></p> 
 <p>randomAccessFile.close();</p> 
 <p>ctx.close();</p> 
 <p>LOGGER.info("文件已经读完channelRead()--------" + byteRead);</p> 
 <p>}</p> 
 <p>}</p> 
 <p>}</p> 
 <p>}</p> 
 <p>}</p> 
 <p>这里使用了RandomAccessFile</p> 
 <p>对RandomAccessFile 做一个简单的介绍更有助于理解代码</p> 
 <p>RandomAccessFile特点</p> 
 <p>RandomAccessFile是java Io体系中功能最丰富的文件内容访问类。即可以读取文件内容，也可以向文件中写入内容。但是和其他输入/输入流不同的是，程序可以直接跳到文件的任意位置来读写数据。</p> 
 <p>因为RandomAccessFile可以自由访问文件的任意位置，所以如果我们希望只访问文件的部分内容，那就可以使用RandomAccessFile类。</p> 
 <p>与OutputStearm,Writer等输出流不同的是，RandomAccessFile类允许自由定位文件记录指针，所以RandomAccessFile可以不从文件开始的地方进行输出，所以RandomAccessFile可以向已存在的文件后追加内容。则应该使用RandomAccessFile。</p> 
 <p>RandomAccessFile类包含了一个记录指针，用以标识当前读写处的位置，当程序新创建一个RandomAccessFile对象时，该对象的文件记录指针位于文件头(也就是0处),</p> 
 <p>当读/写了n个字节后，文件记录指针将会向后移动n个字节。除此之外，RandomAccessFile可以自由的移动记录指针，即可以向前移动，也可以向后移动。</p> 
 <p>RandomAccessFile包含了以下两个方法来操作文件的记录指针.</p> 
 <p>long getFilePointer(); 返回文件记录指针的当前位置</p> 
 <p>void seek(long pos); 将文件记录指针定位到pos位置</p> 
 <p>RandomAccessFile即可以读文件，也可以写，所以它即包含了完全类似于InputStream的3个read()方法，其用法和InputStream的3个read()方法完全一样；</p> 
 <p>也包含了完全类似于OutputStream的3个write()方法，其用法和OutputStream的3个Writer()方法完全一样。</p> 
 <p>除此之外，RandomAccessFile还包含了一系类的readXXX()和writeXXX()方法来完成输入和输出。</p> 
 <p>RandomAccessFile有两个构造器，其实这两个构造器基本相同，只是指定文件的形式不同而已，一个使用String参数来指定文件名，一个使用File参数来指定文件本身。</p> 
 <p>除此之外，创建RandomAccessFile对象还需要指定一个mode参数。该参数指定RandomAccessFile的访问模式，有以下4个值：</p> 
 <p>“r” 以只读方式来打开指定文件夹。如果试图对该RandomAccessFile执行写入方法，都将抛出IOException异常。</p> 
 <p>“rw” 以读，写方式打开指定文件。如果该文件尚不存在，则试图创建该文件。</p> 
 <p>“rws” 以读，写方式打开指定文件。相对于”rw” 模式，还要求对文件内容或元数据的每个更新都同步写入到底层设备。</p> 
 <p>“rwd” 以读，写方式打开指定文件。相对于”rw” 模式，还要求对文件内容每个更新都同步写入到底层设备</p> 
 <p>下面对上面的FileUploadClientHandler类中的代码进行说明:</p> 
 <p>channelActive()方法中有这么一段代码:</p> 
 <p>ctx.writeAndFlush(fileUploadFile);</p> 
 <p>这段代码的意思是向服务端发送消息,消息内容就是FileUploadFile对象, FileUploadFile对象中包含 :文件,文件名,开始位置,文件字节数组,结尾位置</p> 
 <p>服务端代码:</p> 
 <p>FileUploadServerHandler</p> 
 <p>public class FileUploadServerHandler extends ChannelInboundHandlerAdapter {<!-- --></p> 
 <p>private int byteRead;</p> 
 <p>private volatile int start = 0;</p> 
 <p>private String file_dir = "/tmp";</p> 
 <p>private final static Logger LOGGER = LoggerFactory.getLogger(FileUploadServerHandler.class);</p> 
 <p>@Override</p> 
 <p>public void channelActive(ChannelHandlerContext ctx) throws Exception {<!-- --></p> 
 <p>// TODO Auto-generated method stub</p> 
 <p>super.channelActive(ctx);</p> 
 <p>LOGGER.info("服务端：channelActive()");</p> 
 <p>}</p> 
 <p>@Override</p> 
 <p>public void channelInactive(ChannelHandlerContext ctx) throws Exception {<!-- --></p> 
 <p>// TODO Auto-generated method stub</p> 
 <p>super.channelInactive(ctx);</p> 
 <p>LOGGER.info("服务端：channelInactive()");</p> 
 <p>ctx.flush();</p> 
 <p>ctx.close();</p> 
 <p>}</p> 
 <p>@Override</p> 
 <p>public void channelRead(ChannelHandlerContext ctx, Object msg) throws Exception {<!-- --></p> 
 <p>LOGGER.info("收到客户端发来的文件,正在处理....");</p> 
 <p>if (msg instanceof FileUploadFile) {<!-- --></p> 
 <p>FileUploadFile ef = (FileUploadFile) msg;</p> 
 <p>byte[] bytes = ef.getBytes();</p> 
 <p>byteRead = ef.getEndPos();</p> 
 <p>String md5 = ef.getFile_md5();//文件名</p> 
 <p>String path = file_dir + File.separator + md5;</p> 
 <p>File file = new File(path);</p> 
 <p>RandomAccessFile randomAccessFile = new RandomAccessFile(file, "rw");//r: 只读模式 rw:读写模式</p> 
 <p>randomAccessFile.seek(start);//移动文件记录指针的位置,</p> 
 <p>randomAccessFile.write(bytes);//调用了seek(start)方法，是指把文件的记录指针定位到start字节的位置。也就是说程序将从start字节开始写数据</p> 
 <p>start = start + byteRead;</p> 
 <p>if (byteRead &gt; 0) {<!-- --></p> 
 <p>ctx.writeAndFlush(start);//向客户端发送消息</p> 
 <p>randomAccessFile.close();</p> 
 <p>if(byteRead!=1024 * 10){<!-- --></p> 
 <p>Thread.sleep(1000);</p> 
 <p>channelInactive(ctx);</p> 
 <p>}</p> 
 <p>} else {<!-- --></p> 
 <p>ctx.close();</p> 
 <p>}</p> 
 <p>LOGGER.info("处理完毕,文件路径:"+path+","+byteRead);</p> 
 <p>}</p> 
 <p>}</p> 
 <p>}</p> 
 <p>channelRead()方法即是接收客户端的代码,客户端也有这个方法,客户端channelRead()方法主要是负责读文件,服务端主要是写文件.</p> 
 <p>注意:</p> 
 <p>在服务端FileUploadServerHandler这个类中我们要将file_dir的路径改为自己电脑上的路径,mac: /tmp; windows: F:</p> 
 <p>我们可以先运行服务端的ServerFileTest测试类,然后运行客户端的 ClientFileTest测试类进行</p> 
 <p>具体代码就不贴上去了,可以在这里进行下载这个案例</p> 
 <p>netty-file</p> 
 <p>如果对你有帮助还请给个Star哦</p> 
 <p>2020-1-2更新</p> 
 <p>新增多个文件同时异步上传功能</p> 
 <p>引入线程,在开发中如果有此需求尽量使用线程池;</p> 
 <p>更新的代码有:</p> 
 <p>public class FileUploadClient implements Runnable {<!-- --></p> 
 <p>private final static Logger LOGGER = LoggerFactory.getLogger(FileUploadClient.class);</p> 
 <p>private int port;</p> 
 <p>private String host;</p> 
 <p>private FileUploadFile fileUploadFile;</p> 
 <p>public FileUploadClient(int port, String host, FileUploadFile fileUploadFile) {<!-- --></p> 
 <p>this.port = port;</p> 
 <p>this.host = host;</p> 
 <p>this.fileUploadFile = fileUploadFile;</p> 
 <p>}</p> 
 <p>@Override</p> 
 <p>public void run() {<!-- --></p> 
 <p>EventLoopGroup group = new NioEventLoopGroup();</p> 
 <p>try {<!-- --></p> 
 <p>Bootstrap b = new Bootstrap();</p> 
 <p>b.group(group).channel(NioSocketChannel.class)</p> 
 <p>//是禁用nagle算法</p> 
 <p>.option(ChannelOption.TCP_NODELAY, true)</p> 
 <p>.handler(new ChannelInitializer() {<!-- --></p> 
 <p>@Override</p> 
 <p>protected void initChannel(Channel ch) throws Exception {<!-- --></p> 
 <p>ch.pipeline().addLast(new ObjectEncoder());</p> 
 <p>ch.pipeline().addLast(</p> 
 <p>new ObjectDecoder(</p> 
 <p>ClassResolvers</p> 
 <p>.weakCachingConcurrentResolver(null)));</p> 
 <p>ch.pipeline().addLast(</p> 
 <p>new FileUploadClientHandler(</p> 
 <p>fileUploadFile));</p> 
 <p>}</p> 
 <p>});</p> 
 <p>ChannelFuture f = null;</p> 
 <p>try {<!-- --></p> 
 <p>f = b.connect(host, port).sync();</p> 
 <p>f.channel().closeFuture().sync();</p> 
 <p>} catch (InterruptedException e) {<!-- --></p> 
 <p>e.printStackTrace();</p> 
 <p>}</p> 
 <p>LOGGER.info("FileUploadClient connect()结束");</p> 
 <p>} finally {<!-- --></p> 
 <p>group.shutdownGracefully();</p> 
 <p>}</p> 
 <p>}</p> 
 <p>}</p> 
 <p>FileUploadClient类实现Runnable并重写run方法;</p> 
 <p>测试类:</p> 
 <p>public static void main(String[] args) {<!-- --></p> 
 <p>final int FILE_PORT = 9991;</p> 
 <p>try {<!-- --></p> 
 <p>List fileNameList = new ArrayList();</p> 
 <p>fileNameList.add("/test-1.zip");</p> 
 <p>fileNameList.add("/test-2.zip");</p> 
 <p>for (String fileName : fileNameList) {<!-- --></p> 
 <p>FileUploadFile uploadFile = new FileUploadFile();</p> 
 <p>File file = new File(fileName);</p> 
 <p>String fileMd5 = file.getName();// 文件名</p> 
 <p>uploadFile.setFile(file);</p> 
 <p>uploadFile.setFile_md5(fileMd5);</p> 
 <p>uploadFile.setStarPos(0);// 文件开始位置</p> 
 <p>Thread thread = new Thread(new FileUploadClient(FILE_PORT, "127.0.0.1", uploadFile));</p> 
 <p>thread.start();</p> 
 <p>System.out.println(fileName + "开始传输。。。。。。");</p> 
 <p>}</p> 
 <p>} catch (Exception e) {<!-- --></p> 
 <p>e.printStackTrace();</p> 
 <p>}</p> 
 <p>}</p> 
</div>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/58f83a2d9b05f2ae3f8ae8f7ed809e2a/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">数据结构 —— 排序算法</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/f7177860e3ea5a5e01d8db9573f99f18/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">服务器运维需要学什么,运维工程师要学什么？运维工程师是做什么的？</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>