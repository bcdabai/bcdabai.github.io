<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>自定义 Compose 的 TextField，实现各种酷炫的文本框效果 - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="自定义 Compose 的 TextField，实现各种酷炫的文本框效果" />
<meta property="og:description" content="前言 在 Compose 中如果我们想要实现文本输入框的话，一般都是使用 Material 包中的 TextField 或者 OutlinedTextField 。
但是因为这两个组件都是属于 Material 包中的，自然是需要符合 Material 设计规范的，这也就会导致使用他们会丧失很多灵活性。
如果我们想自己实现一些不符合 Material 规范但是很酷炫的效果，亦或是其他设计风格，那继续使用 TextField 或者 OutlinedTextField 将会变得非常痛苦，甚至没法实现。
好在，Compose 提供了一个名为 BasicTextField 的组件，这个组件比上面两个级别更低（上面两个位于 androidx.compose.material 包，而它位于 androidx.compose.foundation.text 包），相比于他们有着极大的灵活性。其实上述两个组件都是对 BasicTextField 的封装。
下面，我们就以仿写一个微信的搜索框为例讲解如何实现使用 BasicTextField 。
开始 分析布局 在开始之前我们先分析一下微信的搜索框是什么样子的。
这是没有输入内容时：
这是输入内容后：
可以看到，在没有输入内容前，输入框有一个前导图标显示搜索，中间输入框中有一个浅色的占位字符，最后有一个后置图标显示语音输入。
而输入内容后，占位字符清除，后置图标更改为清除图标。
这么一分析，好像没啥难度啊，直接用 OutlinedTextField 完全可以实现嘛。
是吗？那我们先尝试直接用 OutlinedTextField 仿写一下试试。
直接使用 OutlinedTextField 根据上面的分析，无非就是一个 OutlinedTextField 加上前导图标还有后置图标，以及占位字符而已嘛，所以我们很容易就能编写出这样的代码：
var inputText by remember { mutableStateOf(&#34;&#34;) } OutlinedTextField( value = inputText, onValueChange = { inputText = it }, leadingIcon = { Icon(imageVector = Icons." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/3732ecba970e880eecbf322d6b76dd3d/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-03-07T11:39:58+08:00" />
<meta property="article:modified_time" content="2023-03-07T11:39:58+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">自定义 Compose 的 TextField，实现各种酷炫的文本框效果</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <div class="kdocs-document"> 
 <h2 style="text-align:left;">前言</h2> 
 <p style="">在 Compose 中如果我们想要实现文本输入框的话，一般都是使用 Material 包中的 TextField 或者 OutlinedTextField 。</p> 
 <p style="">但是因为这两个组件都是属于 Material 包中的，自然是需要符合 Material 设计规范的，这也就会导致使用他们会丧失很多灵活性。</p> 
 <p style="">如果我们想自己实现一些不符合 Material 规范但是很酷炫的效果，亦或是其他设计风格，那继续使用 TextField 或者 OutlinedTextField 将会变得非常痛苦，甚至没法实现。</p> 
 <p style="">好在，Compose 提供了一个名为 BasicTextField 的组件，这个组件比上面两个级别更低（上面两个位于 androidx.compose.material 包，而它位于 androidx.compose.foundation.text 包），相比于他们有着极大的灵活性。其实上述两个组件都是对 BasicTextField 的封装。</p> 
 <p style="">下面，我们就以仿写一个微信的搜索框为例讲解如何实现使用 BasicTextField 。</p> 
 <h2 style="text-align:left;">开始</h2> 
 <h3 style="text-align:left;">分析布局</h3> 
 <p style="">在开始之前我们先分析一下微信的搜索框是什么样子的。</p> 
 <p style="">这是没有输入内容时：</p> 
 <div class="kdocs-line-container" style="display:flex;justify-content:center;"> 
  <div class="kdocs-img" style="flex-direction:column;max-width:100%;display:flex;width:740px;justify-content:center;align-items:center;height:auto;"> 
   <div class="kdocs-img" style="padding-top:15.405405%;height:0;"> 
    <img src="https://images2.imgbox.com/ae/82/S76Xd6xN_o.png" style="margin-left:;display:block;width:740px;margin-top:-15.405405%;height:auto;"> 
   </div> 
  </div> 
 </div> 
 <p style="">这是输入内容后：</p> 
 <div class="kdocs-line-container" style="display:flex;justify-content:center;"> 
  <div class="kdocs-img" style="flex-direction:column;max-width:100%;display:flex;width:740px;justify-content:center;align-items:center;height:auto;"> 
   <div class="kdocs-img" style="padding-top:14.054054%;height:0;"> 
    <img src="https://images2.imgbox.com/f2/a5/PeaaDoOl_o.png" style="margin-left:;display:block;width:740px;margin-top:-14.054054%;height:auto;"> 
   </div> 
  </div> 
 </div> 
 <p style="">可以看到，在没有输入内容前，输入框有一个前导图标显示搜索，中间输入框中有一个浅色的占位字符，最后有一个后置图标显示语音输入。</p> 
 <p style="">而输入内容后，占位字符清除，后置图标更改为清除图标。</p> 
 <p style="">这么一分析，好像没啥难度啊，直接用 OutlinedTextField 完全可以实现嘛。</p> 
 <p style="">是吗？那我们先尝试直接用 OutlinedTextField 仿写一下试试。</p> 
 <h3 style="text-align:left;">直接使用 OutlinedTextField</h3> 
 <p style="">根据上面的分析，无非就是一个 OutlinedTextField 加上前导图标还有后置图标，以及占位字符而已嘛，所以我们很容易就能编写出这样的代码：</p> 
 <pre class="kdocs-kotlin"><code class="language-kotlin">var inputText by remember { mutableStateOf("") }

OutlinedTextField(
    value = inputText,
    onValueChange = {
        inputText = it
    },
    leadingIcon = {
        Icon(imageVector = Icons.Outlined.Search, contentDescription = null)
    },
    trailingIcon = {
        if (inputText.isNotEmpty()) Icon(imageVector = Icons.Outlined.Close, contentDescription = null)
        else Icon(imageVector = Icons.Outlined.Mic, contentDescription = null)
    },
    placeholder = {
        Text(text = "搜索")
    },
)</code></pre> 
 <p style="">其中后置图标通过 inputText.isNotEmpty() 判断输入内容是否为空，如果为空则显示麦克风图标，不为空则显示清除图标，运行效果如下：</p> 
 <div class="kdocs-line-container" style="display:flex;justify-content:center;"> 
  <div class="kdocs-img" style="flex-direction:column;max-width:100%;display:flex;width:355px;justify-content:center;align-items:center;height:auto;"> 
   <div class="kdocs-img" style="padding-top:64.22535%;height:0;"> 
    <img src="https://images2.imgbox.com/14/a1/9eEBfs2V_o.png" style="margin-left:;display:block;width:355px;margin-top:-64.22535%;height:auto;"> 
   </div> 
  </div> 
 </div> 
 <p style="">咋一看好像没啥问题，仔细一看发现好像不对劲。</p> 
 <p style="">对了，是输入框背景颜色不对劲，而且微信的输入框是有圆角的，那就改一下吧。</p> 
 <p style="">首先是加上圆角，添加参数：</p> 
 <p style="">shape = RoundedCornerShape(8.dp)</p> 
 <p style="">然后改一下背景颜色，这里我们通过重新指定一个 colors 颜色配置文件并修改其中的 backgroundColor 字段实现修改背景颜色：</p> 
 <pre class="kdocs-kotlin"><code class="language-kotlin">colors = TextFieldDefaults.outlinedTextFieldColors(
   backgroundColor = Color.White
)</code></pre> 
 <p style="">修改完成，再次运行：</p> 
 <div class="kdocs-line-container" style="display:flex;justify-content:center;"> 
  <div class="kdocs-img" style="flex-direction:column;max-width:100%;display:flex;width:362px;justify-content:center;align-items:center;height:auto;"> 
   <div class="kdocs-img" style="padding-top:59.116024%;height:0;"> 
    <img src="https://images2.imgbox.com/e2/68/bvODaGyT_o.png" style="margin-left:;display:block;width:362px;margin-top:-59.116024%;height:auto;"> 
   </div> 
  </div> 
 </div> 
 <p style="">这下好像对味了？不对！还是不对劲，首先微信的输入框是没有边框的；其次在微信中即使输入框拿到焦点边框也不会变色；另外微信的后置语音图标是黑色的，不是灰色的。</p> 
 <p style="">那么我们再改一改。</p> 
 <p style="">首先是语音输入图标颜色，这个没什么难度，使用 tint 参数重新着色即可：</p> 
 <blockquote class="kdocs-blockquote" style="">
   Icon(imageVector = Icons.Outlined.Mic, contentDescription = null, tint = Color.Black) 
 </blockquote> 
 <p style="">接下来是去掉边框，这个就不好弄了。</p> 
 <p style="">我看了一圈文档，发现没有提供设置边框尺寸的地方，又看了一下源码，果然，边框尺寸被直接写死了：</p> 
 <p style="">调用 OutlinedTextField 后，会调用到 TextFieldImpl 函数，并在其中通过 TextFieldTransitionScope.Transition 获取到边框宽度。</p> 
 <p style="">而 TextFieldTransitionScope.Transition 中对边框宽度的定义如下：</p> 
 <pre class="kdocs-kotlin"><code class="language-kotlin">val indicatorWidth by transition.animateDp(
    label = "IndicatorWidth",
    transitionSpec = { tween(durationMillis = AnimationDuration) }
) {
    when (it) {
        InputPhase.Focused -&gt; IndicatorFocusedWidth
        InputPhase.UnfocusedEmpty -&gt; IndicatorUnfocusedWidth
        InputPhase.UnfocusedNotEmpty -&gt; IndicatorUnfocusedWidth
    }
}</code></pre> 
 <p style="">可以看到这里是定义的一个动画，但是不要紧，我们只需要关心动画完成后最终的宽度值是多少就行，查看上面两个个常量值：</p> 
 <pre class="kdocs-kotlin"><code class="language-kotlin">privateval IndicatorUnfocusedWidth =1.dp
privateval IndicatorFocusedWidth =2.dp</code></pre> 
 <p style="">可以看到，在持有焦点时的宽度是 2 dp，没有焦点时是 1 dp。</p> 
 <p style="">不过，既然无法自己定义边框宽度，那我们改一下颜色总可以了吧？把边框颜色改成和背景颜色一样，约等于没有边框嘛。</p> 
 <p style="">改边框颜色依旧是修改 colors 颜色配置信息，这里需要把聚焦和失焦时的颜色都改成白色：</p> 
 <pre class="kdocs-kotlin"><code class="language-kotlin">colors = TextFieldDefaults.outlinedTextFieldColors(
            backgroundColor = Color.White,
            focusedBorderColor = Color.White,
            unfocusedBorderColor = Color.White
        )</code></pre> 
 <p style="">最终完整代码：</p> 
 <pre class="kdocs-kotlin"><code class="language-kotlin">var inputText by remember { mutableStateOf("") }

OutlinedTextField(
    value = inputText,
    onValueChange = {
        inputText = it
    },
    leadingIcon = {
        Icon(imageVector = Icons.Outlined.Search, contentDescription = null)
    },
    trailingIcon = {
        if (inputText.isNotEmpty()) Icon(imageVector = Icons.Outlined.Close, contentDescription = null)
        else Icon(imageVector = Icons.Outlined.Mic, contentDescription = null, tint = Color.Black)
    },
    placeholder = {
        Text(text = "搜索")
    },
    shape = RoundedCornerShape(8.dp),
    colors = TextFieldDefaults.outlinedTextFieldColors(
        backgroundColor = Color.White,
        focusedBorderColor = Color.White,
        unfocusedBorderColor = Color.White
    )
)</code></pre> 
 <p style="">现在再来看看效果：</p> 
 <div class="kdocs-line-container" style="display:flex;justify-content:center;"> 
  <div class="kdocs-img" style="flex-direction:column;max-width:100%;display:flex;width:362px;justify-content:center;align-items:center;height:auto;"> 
   <div class="kdocs-img" style="padding-top:60.773483%;height:0;"> 
    <img src="https://images2.imgbox.com/72/cc/r3x6IGTQ_o.png" style="margin-left:;display:block;width:362px;margin-top:-60.773483%;height:auto;"> 
   </div> 
  </div> 
 </div> 
 <p style="">好像差不多了欸？哈哈，你再仔细看看。</p> 
 <p style="">发现问题了吗？</p> 
 <p style="">没错，虽然大体上是像了，但是显然文本和图标相对于输入框的边距不对劲啊。</p> 
 <p style="">又是翻了一圈文档和源码，并没有发现设置边距的地方，算了，太麻烦了，我们还是使用 BasicTextField 自定义一个吧。</p> 
 <h3 style="text-align:left;">使用 BasicTextField 自定义</h3> 
 <p style="">BasicTextField 的参数和 OutlinedTextField 大差不差：</p> 
 <div class="kdocs-line-container" style="display:flex;justify-content:center;"> 
  <div class="kdocs-img" style="flex-direction:column;max-width:100%;display:flex;width:740px;justify-content:center;align-items:center;height:auto;"> 
   <div class="kdocs-img" style="padding-top:57.027027%;height:0;"> 
    <img src="https://images2.imgbox.com/17/de/X6DuQRcb_o.png" style="margin-left:;display:block;width:740px;margin-top:-57.027027%;height:auto;"> 
   </div> 
  </div> 
 </div> 
 <p style="">但是它多了一个关键参数 decorationBox ，得益于这个参数，我们可以为所欲为了。</p> 
 <p style="">根据文档介绍：</p> 
 <blockquote class="kdocs-blockquote" style="text-align:left;">
   decorationBox - Composable lambda that allows to add decorations around text field, such as icon, placeholder, helper messages or similar, and automatically increase the hit target area of the text field. To allow you to control the placement of the inner text field relative to your decorations, the text field implementation will pass in a framework-controlled composable parameter “innerTextField” to the decorationBox lambda you provide. You must call innerTextField exactly once. 
 </blockquote> 
 <p style="">简单来说就是这个参数是一个作用域为 Composable 且带有参数 innerTextField 的匿名函数。</p> 
 <p style="">而 innerTextField 也是一个 Composable 的匿名函数，并且它就是输入框的实现函数。</p> 
 <p style="">也就是说，我们可以在 decorationBox 中通过自定义 innerTextField 的调用位置等方式实现自定义自己需要的文本框的目的。</p> 
 <p style="">需要注意的是，正如上面说的，innerTextField 是输入框的实现，所以我们必须并且也只能调用一次这个函数，不然我们的组件里面就没有输入框了。</p> 
 <p style="">依旧是实现上述的微信搜索框，我们可以这样写：</p> 
 <pre class="kdocs-kotlin"><code class="language-kotlin">var inputText by remember { mutableStateOf("") }

BasicTextField(
    value = inputText,
    onValueChange = {
        inputText = it
    },
    decorationBox = { innerTextField -&gt;
        Box {
            Surface(
                // border = BorderStroke(1.dp, Color.Gray),
                shape = RoundedCornerShape(8.dp)
            ) {
                Row(
                    modifier = Modifier.padding(8.dp),
                    verticalAlignment = Alignment.CenterVertically
                ) {
                    Icon(imageVector = Icons.Outlined.Search, contentDescription = null, tint = Color(0x88000000))

                    Box(modifier = Modifier.padding(start = 4.dp, end = 4.dp)) {
                        if (inputText.isEmpty()) Text(text = "搜索", color = Color(0x88000000))
                        innerTextField()
                    }

                    if (inputText.isNotEmpty()) Icon(imageVector = Icons.Outlined.Close, contentDescription = null, tint = Color(0x88000000))
                    else Icon(imageVector = Icons.Outlined.Mic, contentDescription = null, tint = Color(0xFF000000))
                }
            }
        }
    }
)</code></pre> 
 <p style="">其他地方没什么好说的，我们来重点分析 decorationBox 的内容。</p> 
 <p style="">首先，我们的根组件选择了 Surface，这是 Material 中的组件之一，官方称之为 “平面”，简单来说就是可以把它包含的内容以统一的样式配置（例如边框、阴影、圆角等）放到同一个“平面”内。</p> 
 <p style="">因为我们需要给输入框加上圆角，所以选择它做根组件，并设置了 8dp 的圆角 shape = RoundedCornerShape(8.dp) 。</p> 
 <p style="">因为输入框的三个主要组件：前置图标、输入框（占位字符）、后置图标是水平排列的，所以接下来用了一个 Row ，并设置垂直对齐方式为居中 verticalAlignment = Alignment.CenterVertically 。</p> 
 <p style="">然后根据需求设置前置图标，后置图标，以及配置颜色和边距等这里就不过多赘述了，重点需要注意占位文本和输入框（innerTextField()）的摆放。</p> 
 <p style="">因为占位文本和输入框实际上应该是属于同一个位置的，虽然在输入框有内容后就不会显示占位文本了，但是我们依旧需要把他们放到 Box 中，即堆叠到同一个位置，否则将会变成这样：</p> 
 <div class="kdocs-line-container" style="display:flex;justify-content:center;"> 
  <div class="kdocs-img" style="flex-direction:column;max-width:100%;display:flex;width:266px;justify-content:center;align-items:center;height:auto;"> 
   <div class="kdocs-img" style="padding-top:63.909775%;height:0;"> 
    <img src="https://images2.imgbox.com/6f/9a/x8RwdIk8_o.png" style="margin-left:;display:block;width:266px;margin-top:-63.909775%;height:auto;"> 
   </div> 
  </div> 
 </div> 
 <p style="">没看出区别？仔细看光标，输入框已经被挤到占位文本之后了。</p> 
 <p style="">加上 Box 后效果如下：</p> 
 <div class="kdocs-line-container" style="display:flex;justify-content:center;"> 
  <div class="kdocs-img" style="flex-direction:column;max-width:100%;display:flex;width:244px;justify-content:center;align-items:center;height:auto;"> 
   <div class="kdocs-img" style="padding-top:69.67213%;height:0;"> 
    <img src="https://images2.imgbox.com/f8/8d/hLAFqOoW_o.png" style="margin-left:;display:block;width:244px;margin-top:-69.67213%;height:auto;"> 
   </div> 
  </div> 
 </div> 
 <p style="">这样看起来是不是对味多了？</p> 
 <h2 style="text-align:left;">总结</h2> 
 <p style="">我们通过模仿微信搜索框的方式讲解了如何使用 BasicTextField 自定义文本输入框效果。</p> 
 <p style="">当然，这里只是抛砖引玉，只是简单的介绍了使用方法，并没有做什么酷炫的组件，但是知道了如何使用 BasicTextField 想要实现什么酷炫的输入框效果那还不是手到擒来？</p> 
 <p style=""></p> 
</div>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/be6146971d78a50484cce1c721ea7fd8/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">STM32: 借助例程去新建自己的工程</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/422f1b57e4daa8a1fc50797707ecdf70/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">本地通信实例(AF_UNIX)</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>