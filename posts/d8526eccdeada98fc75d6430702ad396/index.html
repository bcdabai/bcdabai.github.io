<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>K8S：pod集群调度及相关操作 - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="K8S：pod集群调度及相关操作" />
<meta property="og:description" content="文章目录 一.pod集群调度概念1.调度约束( List-Watch组件)2.List-Watch的工作机制（1）List-Watch的工作机制流程（2）List-Watch的工作机制图示 3.调度的过程（1）调度的任务（2）调度选择pod节点（3）调度的过程（4）调度的算法（5）调度的优先级 二.pod集群调度示例1.指定调度节点示例2.通过节点标签调度（nodeSelector）示例3.平均调度节点示例 三.亲和性（节点亲和、pod亲和）1.节点亲和（1）节点亲和概念（2）键值运算关系（3）创建节点硬策略亲和示例：（4）创建节点软策略亲和示例：（5）节点软硬策略亲和示例 2.pod亲和性与反亲和性（1）Pod亲和性与反亲和性的调整策略（2）Pod亲和性示例（3）Pod 反亲和性调度示例1（4）Pod 反亲和性调度示例2 四.污点(Taint) 和 容忍(Tolerations)1.污点(Taint)（1）污点概念（2）污点的组成格式及污点的存在选项（3）查看节点污点（4）节点污点示例 2.容忍(Tolerations)（1）容忍(Tolerations)概念（2）节点容忍示例（３）污点注意事项 五．维护操作１．cordon调度器（１）对节点执行维护操作（２）cordon调度器 2.drain命令 六.Pod启动阶段（相位 phase）1.pod启动过程2.phase 的可能状态3.故障排除步骤 总：1.list-watch2.scheduler3.pod 调度到指定节点的方法4.节点亲和性和反亲和性5.相关标签命令6.污点和容忍7.Pod启动阶段(相位) 5个状态8.排除故障方法 一.pod集群调度概念 1.调度约束( List-Watch组件) Kubernetes 是通过 List-Watch的机制进行每个组件的协作，保持数据同步的，每个组件之间的设计实现了解耦。
用户是通过 kubectl 根据配置文件，向 APIServer 发送命令，在 Node 节点上面建立 Pod 和 Container。
APIServer 经过 API 调用，权限控制，调用资源和存储资源的过程，实际上还没有真正开始部署应用。这里 需要 Controller Manager、Scheduler 和 kubelet 的协助才能完成整个部署过程。
2.List-Watch的工作机制 （1）List-Watch的工作机制流程 在 Kubernetes 中，所有部署的信息都会写到 etcd 中保存。实际上 etcd 在存储部署信息的时候，会发送 Create 事件给 APIServer，而 APIServer 会通过监听（Watch）etcd 发过来的事件。其他组件也会监听（Watch）APIServer 发出来的事件。
Pod 是 Kubernetes 的基础单元，Pod 启动典型创建过程如下：工作机制
（1）这里有三个 List-Watch，分别是 Controller Manager（运行在 Master），Scheduler（运行在 Master），kubelet（运行在 Node）。 他们在进程已启动就会监听（Watch）APIServer 发出来的事件。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/d8526eccdeada98fc75d6430702ad396/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-09-20T17:06:36+08:00" />
<meta property="article:modified_time" content="2023-09-20T17:06:36+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">K8S：pod集群调度及相关操作</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-light">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p></p> 
<div class="toc"> 
 <h4>文章目录</h4> 
 <ul><li><a href="#pod_2" rel="nofollow">一.pod集群调度概念</a></li><li><ul><li><a href="#1_ListWatch_4" rel="nofollow">1.调度约束( List-Watch组件)</a></li><li><a href="#2ListWatch_11" rel="nofollow">2.List-Watch的工作机制</a></li><li><ul><li><a href="#1ListWatch_13" rel="nofollow">（1）List-Watch的工作机制流程</a></li><li><a href="#2ListWatch_50" rel="nofollow">（2）List-Watch的工作机制图示</a></li></ul> 
   </li><li><a href="#3_53" rel="nofollow">3.调度的过程</a></li><li><ul><li><a href="#1_55" rel="nofollow">（1）调度的任务</a></li><li><a href="#2pod_63" rel="nofollow">（2）调度选择pod节点</a></li><li><a href="#3_67" rel="nofollow">（3）调度的过程</a></li><li><a href="#4_71" rel="nofollow">（4）调度的算法</a></li><li><a href="#5_80" rel="nofollow">（5）调度的优先级</a></li></ul> 
  </li></ul> 
  </li><li><a href="#pod_91" rel="nofollow">二.pod集群调度示例</a></li><li><ul><li><a href="#1_93" rel="nofollow">1.指定调度节点示例</a></li><li><a href="#2nodeSelector_184" rel="nofollow">2.通过节点标签调度（nodeSelector）示例</a></li><li><a href="#3_270" rel="nofollow">3.平均调度节点示例</a></li></ul> 
  </li><li><a href="#pod_346" rel="nofollow">三.亲和性（节点亲和、pod亲和）</a></li><li><ul><li><a href="#1_350" rel="nofollow">1.节点亲和</a></li><li><ul><li><a href="#1_352" rel="nofollow">（1）节点亲和概念</a></li><li><a href="#2_359" rel="nofollow">（2）键值运算关系</a></li><li><a href="#3_372" rel="nofollow">（3）创建节点硬策略亲和示例：</a></li><li><a href="#4_464" rel="nofollow">（4）创建节点软策略亲和示例：</a></li><li><a href="#5_551" rel="nofollow">（5）节点软硬策略亲和示例</a></li></ul> 
   </li><li><a href="#2pod_646" rel="nofollow">2.pod亲和性与反亲和性</a></li><li><ul><li><a href="#1Pod_650" rel="nofollow">（1）Pod亲和性与反亲和性的调整策略</a></li><li><a href="#2Pod_658" rel="nofollow">（2）Pod亲和性示例</a></li><li><a href="#3Pod_1_753" rel="nofollow">（3）Pod 反亲和性调度示例1</a></li><li><a href="#4Pod_2_799" rel="nofollow">（4）Pod 反亲和性调度示例2</a></li></ul> 
  </li></ul> 
  </li><li><a href="#Taint__Tolerations_851" rel="nofollow">四.污点(Taint) 和 容忍(Tolerations)</a></li><li><ul><li><a href="#1Taint_853" rel="nofollow">1.污点(Taint)</a></li><li><ul><li><a href="#1_855" rel="nofollow">（1）污点概念</a></li><li><a href="#2_864" rel="nofollow">（2）污点的组成格式及污点的存在选项</a></li><li><a href="#3_877" rel="nofollow">（3）查看节点污点</a></li><li><a href="#4_894" rel="nofollow">（4）节点污点示例</a></li></ul> 
   </li><li><a href="#2Tolerations_977" rel="nofollow">2.容忍(Tolerations)</a></li><li><ul><li><a href="#1Tolerations_979" rel="nofollow">（1）容忍(Tolerations)概念</a></li><li><a href="#2_983" rel="nofollow">（2）节点容忍示例</a></li><li><a href="#_1071" rel="nofollow">（３）污点注意事项</a></li></ul> 
  </li></ul> 
  </li><li><a href="#_1112" rel="nofollow">五．维护操作</a></li><li><ul><li><a href="#cordon_1114" rel="nofollow">１．cordon调度器</a></li><li><ul><li><a href="#_1116" rel="nofollow">（１）对节点执行维护操作</a></li><li><a href="#cordon_1126" rel="nofollow">（２）cordon调度器</a></li></ul> 
   </li><li><a href="#2drain_1198" rel="nofollow">2.drain命令</a></li></ul> 
  </li><li><a href="#Pod_phase_1246" rel="nofollow">六.Pod启动阶段（相位 phase）</a></li><li><ul><li><a href="#1pod_1248" rel="nofollow">1.pod启动过程</a></li><li><a href="#2phase__1257" rel="nofollow">2.phase 的可能状态</a></li><li><a href="#3_1269" rel="nofollow">3.故障排除步骤</a></li></ul> 
  </li><li><a href="#_1307" rel="nofollow">总：</a></li><li><ul><li><a href="#1listwatch_1309" rel="nofollow">1.list-watch</a></li><li><a href="#2scheduler_1313" rel="nofollow">2.scheduler</a></li><li><a href="#3pod__1319" rel="nofollow">3.pod 调度到指定节点的方法</a></li><li><a href="#4_1324" rel="nofollow">4.节点亲和性和反亲和性</a></li><li><a href="#5_1330" rel="nofollow">5.相关标签命令</a></li><li><a href="#6_1342" rel="nofollow">6.污点和容忍</a></li><li><a href="#7Pod_5_1358" rel="nofollow">7.Pod启动阶段(相位) 5个状态</a></li><li><a href="#8_1370" rel="nofollow">8.排除故障方法</a></li></ul> 
 </li></ul> 
</div> 
<p></p> 
<h2><a id="pod_2"></a>一.pod集群调度概念</h2> 
<h3><a id="1_ListWatch_4"></a>1.调度约束( List-Watch组件)</h3> 
<p>Kubernetes 是通过 List-Watch的机制进行每个组件的协作，保持数据同步的，每个组件之间的设计实现了解耦。</p> 
<p>用户是通过 kubectl 根据配置文件，向 APIServer 发送命令，在 Node 节点上面建立 Pod 和 Container。<br> APIServer 经过 API 调用，权限控制，调用资源和存储资源的过程，实际上还没有真正开始部署应用。这里 需要 Controller Manager、Scheduler 和 kubelet 的协助才能完成整个部署过程。</p> 
<h3><a id="2ListWatch_11"></a>2.List-Watch的工作机制</h3> 
<h4><a id="1ListWatch_13"></a>（1）List-Watch的工作机制流程</h4> 
<p>在 Kubernetes 中，所有部署的信息都会写到 etcd 中保存。实际上 etcd 在存储部署信息的时候，会发送 Create 事件给 APIServer，而 APIServer 会通过监听（Watch）etcd 发过来的事件。其他组件也会监听（Watch）APIServer 发出来的事件。</p> 
<p>Pod 是 Kubernetes 的基础单元，Pod 启动典型创建过程如下：工作机制<br> （1）这里有三个 List-Watch，分别是 Controller Manager（运行在 Master），Scheduler（运行在 Master），kubelet（运行在 Node）。 他们在进程已启动就会监听（Watch）APIServer 发出来的事件。</p> 
<p>（2）用户通过 kubectl 或其他 API 客户端提交请求给 APIServer 来建立一个 Pod 对象副本。</p> 
<p>（3）APIServer 尝试着将 Pod 对象的相关元信息存入 etcd 中，待写入操作执行完成，APIServer 即会返回确认信息至客户端。</p> 
<p>（4）当 etcd 接受创建 Pod 信息以后，会发送一个 Create 事件给 APIServer。</p> 
<p>（5）由于 Controller Manager 一直在监听（Watch，通过https的6443端口）APIServer 中的事件。此时 APIServer 接受到了 Create 事件，又会发送给 Controller Manager。</p> 
<p>（6）Controller Manager 在接到 Create 事件以后，调用其中的 Replication Controller 来保证 Node 上面需要创建的副本数量。一旦副本数量少于 RC 中定义的数量，RC 会自动创建副本。总之它是保证副本数量的 Controller（PS：扩容缩容的担当）。</p> 
<p>（7）在 Controller Manager 创建 Pod 副本以后，APIServer 会在 etcd 中记录这个 Pod 的详细信息。例如 Pod 的副本数，Container 的内容是什么。</p> 
<p>（8）同样的 etcd 会将创建 Pod 的信息通过事件发送给 APIServer。</p> 
<p>（9）由于 Scheduler 在监听（Watch）APIServer，并且它在系统中起到了“承上启下”的作用，“承上”是指它负责接收创建的 Pod 事件，为其安排 Node；“启下”是指安置工作完成后，Node 上的 kubelet 进程会接管后继工作，负责 Pod 生命周期中的“下半生”。 换句话说，Scheduler 的作用是将待调度的 Pod 按照调度算法和策略绑定到集群中 Node 上。</p> 
<p>（10）Scheduler 调度完毕以后会更新 Pod 的信息，此时的信息更加丰富了。除了知道 Pod 的副本数量，副本内容。还知道部署到哪个 Node 上面了。并将上面的 Pod 信息更新至 API Server，由 APIServer 更新至 etcd 中，保存起来。</p> 
<p>（11）etcd 将更新成功的事件发送给 APIServer，APIServer 也开始反映此 Pod 对象的调度结果。</p> 
<p>（12）kubelet 是在 Node 上面运行的进程，它也通过 List-Watch 的方式监听（Watch，通过https的6443端口）APIServer 发送的 Pod 更新的事件。kubelet 会尝试在当前节点上调用 Docker 启动容器，并将 Pod 以及容器的结果状态回送至 APIServer。</p> 
<p>（13）APIServer 将 Pod 状态信息存入 etcd 中。在 etcd 确认写入操作成功完成后，APIServer将确认信息发送至相关的 kubelet，事件将通过它被接受。</p> 
<p>#注意：在创建 Pod 的工作就已经完成了后，为什么 kubelet 还要一直监听呢？原因很简单，假设这个时候 kubectl 发命令，要扩充 Pod 副本数量，那么上面的流程又会触发一遍，kubelet 会根据最新的 Pod 的部署情况调整 Node 的资源。又或者 Pod 副本数量没有发生变化，但是其中的镜像文件升级了，kubelet 也会自动获取最新的镜像文件并且加载。</p> 
<blockquote> 
 <p>总：三个组件（contrllor manager、scheduler、kubelet）监听apiserver，通过端口，来看调度、扩容、缩容、升级等）</p> 
 <p>缩容、扩容、镜像升级的话这些机制都得再来一遍</p> 
</blockquote> 
<h4><a id="2ListWatch_50"></a>（2）List-Watch的工作机制图示</h4> 
<p><img src="https://images2.imgbox.com/23/69/Z5VTmzgc_o.png" alt="外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传"></p> 
<h3><a id="3_53"></a>3.调度的过程</h3> 
<h4><a id="1_55"></a>（1）调度的任务</h4> 
<p>Scheduler 是 kubernetes 的调度器，主要的任务是把定义的 pod 分配到集群的节点上。其主要考虑的问题如下：<br> ●公平：如何保证每个节点都能被分配资源<br> ●资源高效利用：集群所有资源最大化被使用<br> ●效率：调度的性能要好，能够尽快地对大批量的 pod 完成调度工作<br> ●灵活：允许用户根据自己的需求控制调度的逻辑</p> 
<h4><a id="2pod_63"></a>（2）调度选择pod节点</h4> 
<p>Sheduler 是作为单独的程序运行的，启动之后会一直监听 APIServer，获取 spec.nodeName 为空的 pod，对每个 pod 都会创建一个 binding，表明该 pod 应该放到哪个节点上。</p> 
<h4><a id="3_67"></a>（3）调度的过程</h4> 
<p>调度分为几个部分：首先是过滤掉不满足条件的节点，这个过程称为预算策略（predicate）；然后对通过的节点按照优先级排序，这个是优选策略（priorities）；最后从中选择优先级最高的节点。如果中间任何一步骤有错误，就直接返回错误。</p> 
<h4><a id="4_71"></a>（4）调度的算法</h4> 
<p><strong>Predicate 有一系列的常见的算法可以使用</strong>：<br> ●PodFitsResources：节点上剩余的资源<strong>是否大于</strong> pod 请求的资源odeName，检查节点名称<strong>是否和 NodeName 匹配</strong><br> ●PodFitsHost：如果 pod 指定了 N<br> ●PodFitsHostPorts：节点上已经使用的 port <strong>是否</strong>和 pod 申请的 port <strong>冲突</strong>。<br> ●PodSelectorMatches：<strong>过滤</strong>掉和 pod 指定的 label 不匹配的节点。<br> ●NoDiskConflict：已经 mount 的 volume 和 pod 指定的 volume 不冲突，除非它们都是只读。</p> 
<h4><a id="5_80"></a>（5）调度的优先级</h4> 
<p>如果在 predicate 过程中没有合适的节点，pod 会一直在 pending 状态，不断重试调度，直到有节点满足条件。 经过这个步骤，如果有多个节点满足条件，就继续 priorities 过程：按照优先级大小对节点排序。</p> 
<p>优先级由一系列键值对组成，键是该优先级项的名称，值是它的权重（该项的重要性）。有一系列的常见的优先级选项包括：<br> ●LeastRequestedPriority：通过计算CPU和Memory的使用率来决定权重，使用率越低权重越高。也就是说，这个优先级指标倾向于资源使用比例更低的节点。<br> ●BalancedResourceAllocation：节点上 CPU 和 Memory 使用率越接近，权重越高。这个一般和上面的一起使用，不单独使用。比如 node01 的 CPU 和 Memory 使用率 20:60，node02 的 CPU 和 Memory 使用率 50:50，虽然 node01 的总使用率比 node02 低，但 node02 的 CPU 和 Memory 使用率更接近，从而调度时会优选 node02。<br> ●ImageLocalityPriority：倾向于已经有要使用镜像的节点，镜像总大小值越大，权重越高。</p> 
<p>通过算法对所有的优先级项目和权重进行计算，得出最终的结果。</p> 
<h2><a id="pod_91"></a>二.pod集群调度示例</h2> 
<h3><a id="1_93"></a>1.指定调度节点示例</h3> 
<p>（1）pod.spec.nodeName 将 Pod 直接调度到指定的 Node 节点上，会跳过 Scheduler 的调度策略，该匹配规则是强制匹配</p> 
<pre><code>vim myapp.yaml

apiVersion: apps/v1  
kind: Deployment  
metadata:
  name: myapp
spec:
  replicas: 3
  selector:
    matchLabels:
      app: myapp
  template:
    metadata:
      labels:
        app: myapp
    spec:
      nodeName: node01
      containers:
      - name: myapp
        image: soscscs/myapp:v1
        ports:
        - containerPort: 80
</code></pre> 
<blockquote> 
 <p>注释：</p> 
 <ul><li><code>replicas: 3</code> 指定了要创建的 Pod 副本数量为 3。</li><li><code>selector</code> 通过标签选择器指定了要管理的 Pod 集合，这里使用了 <code>app: myapp</code> 标签。</li><li><code>template</code> 定义了创建 Pod 的模板，在其中可以设置容器和其他配置。</li><li><code>nodeName: node01</code> 指定了 Pod 应该运行在名为 <code>node01</code> 的节点上。</li><li><code>containers</code> 定义了要运行的容器的配置，包括容器名称、镜像和端口等信息。</li></ul> 
 <p>将在 Kubernetes 集群中创建 3 个副本的 Deployment，每个 Pod 将运行一个名为 <code>myapp</code> 的容器，并将这些 Pod 调度到名为 <code>node01</code> 的节点上。</p> 
</blockquote> 
<pre><code>kubectl apply -f myapp.yaml
</code></pre> 
<pre><code>kubectl get pods -o wide
</code></pre> 
<p><img src="https://images2.imgbox.com/54/46/DXOHxSSU_o.png" alt="外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传"></p> 
<pre><code>#查看详细事件（发现未经过 scheduler 调度分配）
kubectl describe pod myapp-699655c7fd-m87pb
</code></pre> 
<p><img src="https://images2.imgbox.com/19/0d/V4JtP2XC_o.png" alt="外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传"></p> 
<p>（2）pod.spec.nodeSelector：通过 kubernetes 的 label-selector 机制选择节点，由调度器调度策略匹配 label，然后调度 Pod 到目标节点，该匹配规则属于强制约束</p> 
<pre><code>#获取标签帮助
kubectl label --help
</code></pre> 
<p><img src="https://images2.imgbox.com/55/2f/nQlNKKvY_o.png" alt="外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传"></p> 
<pre><code>#需要获取 node 上的 NAME 名称
kubectl get node
</code></pre> 
<p><img src="https://images2.imgbox.com/5f/0b/ud45oV0n_o.png" alt="外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传"></p> 
<pre><code>#给对应的 node 设置标签分别为 blue=a 和 blue=b
kubectl label nodes node01 blue=a
kubectl label nodes node02 blue=b
</code></pre> 
<pre><code>#查看标签
kubectl get nodes --show-labels
</code></pre> 
<p><img src="https://images2.imgbox.com/50/32/ufv8K8dl_o.png" alt="外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传"></p> 
<h3><a id="2nodeSelector_184"></a>2.通过节点标签调度（nodeSelector）示例</h3> 
<pre><code>#修改成nodeSelector调度方式
vim myapp1.yaml

apiVersion: apps/v1
kind: Deployment  
metadata:
  name: myapp1
spec:
  replicas: 3
  selector:
    matchLabels:
      app: myapp1
  template:
    metadata:
      labels:
        app: myapp1
    spec:
      nodeSelector:
	    blue: a
      containers:
      - name: myapp1
        image: soscscs/myapp:v1
        ports:
        - containerPort: 80
</code></pre> 
<blockquote> 
 <p>注释：</p> 
 <ul><li><code>replicas: 3</code> 指定了要创建的 Pod 副本数量为 3。</li><li><code>selector</code> 通过标签选择器指定了要管理的 Pod 集合，这里使用了 <code>app: myapp1</code> 标签。</li><li><code>template</code> 定义了创建 Pod 的模板，在其中可以设置容器和其他配置。</li><li><code>nodeSelector</code> 使用了 <code>blue: a</code> 条件，表示只有具有标签 <code>blue=a</code> 的节点才能被选择来调度 Pod。</li><li><code>containers</code> 定义了要运行的容器的配置，包括容器名称、镜像和端口等信息。</li></ul> 
 <p>这个部署脚本将在 Kubernetes 集群中创建 3 个副本的 Deployment，每个 Pod 将运行一个名为 <code>myapp1</code> 的容器，并将这些 Pod 调度到带有标签 <code>blue=a</code> 的节点上。</p> 
</blockquote> 
<pre><code>kubectl apply -f myapp1.yaml 
</code></pre> 
<pre><code>kubectl get pods -o wide
</code></pre> 
<p><img src="https://images2.imgbox.com/5a/37/X7TljeYE_o.png" alt="外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传"></p> 
<pre><code>#查看详细事件（通过事件可以发现要先经过 scheduler 调度分配）
kubectl describe pod myapp1-86c7cf9c8c-96w6t
</code></pre> 
<p><img src="https://images2.imgbox.com/ce/59/M7BR390V_o.png" alt="外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传"></p> 
<blockquote> 
 <p>注：如资源大小不足可能会会造成调度失败</p> 
</blockquote> 
<pre><code>#查看标签
kubectl get node --show-labels
#修改一个节点的 label 的值，需要加上 --overwrite 参数
kubectl label nodes node02 blue=a --overwrite
</code></pre> 
<p><img src="https://images2.imgbox.com/6a/2c/0ByS8ik5_o.png" alt="外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传"></p> 
<pre><code>#删除一个 label，只需在命令行最后指定 label 的 key 名并与一个减号相连即可：
kubectl label nodes node02 blue-
</code></pre> 
<p><img src="https://images2.imgbox.com/c2/e2/7aH87wBa_o.png" alt="外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传"></p> 
<pre><code>#指定标签查询 node 节点
kubectl get nodes -l blue=a
</code></pre> 
<p><img src="https://images2.imgbox.com/f8/a3/4SJA3aBA_o.png" alt="外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传"></p> 
<h3><a id="3_270"></a>3.平均调度节点示例</h3> 
<blockquote> 
 <p>注：资源大小不足可能会会造成调度失败</p> 
</blockquote> 
<p>平均放在node1、node2即可使用这个调度方法</p> 
<pre><code>#修改标签，讲node01、node02节点上的标签都设置为一样的值
kubectl label nodes node01 blue=a
kubectl label nodes node02 blue=a
kubectl get node --show-labels
</code></pre> 
<p><img src="https://images2.imgbox.com/2b/bc/xPxegwVD_o.png" alt="外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传"></p> 
<pre><code>#删除之前创建的
kubectl delete -f myapp1.yaml

vim myapp1.yaml 

apiVersion: apps/v1
kind: Deployment  
metadata:
  name: myapp1
spec:
  replicas: 3
  selector:
    matchLabels:
      app: myapp1
  template:
    metadata:
      labels:
        app: myapp1
    spec:
      nodeSelector:
	    blue: a
      containers:
      - name: myapp1
        image: soscscs/myapp:v1
        ports:
        - containerPort: 80
</code></pre> 
<pre><code>#再次创建
kubectl apply -f myapp1.yaml 
</code></pre> 
<p><img src="https://images2.imgbox.com/2b/6f/Im0hxEEf_o.png" alt="外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传"></p> 
<blockquote> 
 <p>节点标签未平均在node节点解决办法</p> 
 <p>（1）查看剩余大小</p> 
 <p>free -h</p> 
 <p>#清缓存，来清除 Linux 系统缓存的操作，这个命令通常用于调优系统性能或者在特定情况下需要释放系统内存时使用。但需要注意的是，清除缓存可能导致一些文件系统的性能下降，因为在重新加载缓存时可能需要一些时间。</p> 
 <p>echo 3 &gt; /proc/sys/vm/drop_caches</p> 
 <p>（2）查看节点是否存在污点</p> 
 <p>kubectl describe nodes | grep -B 3 Taints</p> 
 <p>（3）有可能是因为都在一个节点是节点的资源过多，此处使用相同的配置文件修改名字，再次创建</p> 
 <p>cp myapp1.yaml myapp2.yaml</p> 
 <p>kubectl apply -f myapp2.yaml</p> 
 <p><img src="https://images2.imgbox.com/2a/d7/AeFkkr4m_o.png" alt="外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传"></p> 
</blockquote> 
<h2><a id="pod_346"></a>三.亲和性（节点亲和、pod亲和）</h2> 
<p>https://kubernetes.io/zh/docs/concepts/scheduling-eviction/assign-pod-node/</p> 
<h3><a id="1_350"></a>1.节点亲和</h3> 
<h4><a id="1_352"></a>（1）节点亲和概念</h4> 
<p>节点亲和：倾向于哪一个node节点，硬策略是必须是哪一个node节点，软策略是最好是哪一个node节点，但是不是也可以接受。<br> pod.spec.nodeAffinity<br> ●preferredDuringSchedulingIgnoredDuringExecution：软策略<br> ●requiredDuringSchedulingIgnoredDuringExecution：硬策略</p> 
<h4><a id="2_359"></a>（2）键值运算关系</h4> 
<p>●In：label 的值在某个列表中 pending————必须是<br> ●NotIn：label 的值不在某个列表中————相反节点<br> ●Gt：label 的值大于某个值<br> ●Lt：label 的值小于某个值<br> ●Exists：某个 label 存在<br> ●DoesNotExist：某个 label 不存在</p> 
<blockquote> 
 <p>软策略：配置NotIn使用较多</p> 
 <p>硬策略：in使用较多</p> 
</blockquote> 
<h4><a id="3_372"></a>（3）创建节点硬策略亲和示例：</h4> 
<blockquote> 
 <p>可以使用以下命令查看标签下的选项：</p> 
 <p>kubectl explain pod.spec.aff1n1ty.nodeAffin1ty.requredDuring5chedulinglgnoredDuringExecut1on.nodeselectorTerms.</p> 
 <p>编辑文件中的标签key值：</p> 
 <p>kubectl get nodes --show-labels</p> 
 <p><img src="https://images2.imgbox.com/c9/52/AyvI2c2X_o.png" alt="外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传"></p> 
</blockquote> 
<pre><code>kubectl get nodes --show-labels
</code></pre> 
<p><img src="https://images2.imgbox.com/d4/51/VApUZ09V_o.png" alt="外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传"></p> 
<pre><code>mkdir /opt/affinity
cd /opt/affinity
</code></pre> 
<pre><code>vim pod1.yaml

apiVersion: v1
kind: Pod
metadata:
  name: affinity
  labels:
    app: node-affinity-pod
spec:
  containers:
  - name: with-node-affinity
    image: soscscs/myapp:v1
  affinity:
    nodeAffinity:
      requiredDuringSchedulingIgnoredDuringExecution:
        nodeSelectorTerms:
        - matchExpressions:
          - key: kubernetes.io/hostname    #指定node的标签
            operator: NotIn     #设置Pod安装到kubernetes.io/hostname的标签值不在values列表中的node上
            values:
            - node02
</code></pre> 
<blockquote> 
 <p>注释：</p> 
 <ul><li> <p><code>metadata</code> 部分定义了 Pod 的元数据，包括名称和标签。</p> </li><li> <p><code>spec.containers</code> 定义了要在 Pod 中运行的容器的配置，包括容器名称和镜像。</p> </li><li> <pre><code>affinity  定义了节点亲和性配置。
</code></pre> 
   <ul><li> <p><code>nodeAffinity</code> 指定了使用节点亲和性。</p> </li><li> <p><code>requiredDuringSchedulingIgnoredDuringExecution</code> 表示 Pod 必须满足指定的节点亲和性规则。</p> </li><li> <pre><code>nodeSelectorTerms   定义了要匹配的节点标签条件。
</code></pre> 
     <ul><li> <pre><code>matchExpressions   定义了节点选择器的匹配表达式。
</code></pre> 
       <ul><li><code>key</code> 指定了要匹配的节点标签键，这里使用了 <code>kubernetes.io/hostname</code> 表示节点主机名。</li><li><code>operator</code> 定义了匹配操作符，这里使用了 <code>NotIn</code> 表示节点主机名不在指定的列表中。</li><li><code>values</code> 定义了不满足匹配条件的节点主机名列表，这里只有一个值 <code>node02</code>。</li></ul> </li></ul> </li></ul> </li></ul> 
 <p>因此，这个 Pod 定义了一个节点亲和性规则，要求将其调度到除了主机名为 <code>node02</code> 的节点以外的其他节点上。</p> 
</blockquote> 
<pre><code>kubectl apply -f pod1.yaml
</code></pre> 
<pre><code>kubectl get pods -o wide
</code></pre> 
<p><img src="https://images2.imgbox.com/ce/8b/iI454eV6_o.png" alt="外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传"></p> 
<blockquote> 
 <p>#如果硬策略不满足条件，Pod 状态一直会处于 Pending 状态。</p> 
 <p>如果内存不够可能也无法使pod状态正常</p> 
</blockquote> 
<h4><a id="4_464"></a>（4）创建节点软策略亲和示例：</h4> 
<pre><code>cp pod1.yaml pod2.yaml
</code></pre> 
<pre><code>vim pod2.yaml

apiVersion: v1
kind: Pod
metadata:
  name: affinity-pr
  labels:
    app: node-affinity-pod
spec:
  containers:
  - name: with-node-affinity
    image: soscscs/myapp:v1
  affinity:
    nodeAffinity:
      preferredDuringSchedulingIgnoredDuringExecution:
      - weight: 1   #如果有多个软策略选项的话，权重越大，优先级越高
        preference:
          matchExpressions:
          - key: kubernetes.io/hostname
            operator: In
            values:
            - node03       #没有这个节点服务器会自动分配给存在的其他节点上
</code></pre> 
<blockquote> 
 <p>注释：</p> 
 <ul><li> <p><code>metadata</code> 部分定义了 Pod 的元数据，包括名称和标签。</p> </li><li> <p><code>spec.containers</code> 定义了要在 Pod 中运行的容器的配置，包括容器名称和镜像。</p> </li><li> <pre><code>affinity   定义了节点亲和性配置。
</code></pre> 
   <ul><li> <p><code>nodeAffinity</code> 指定了使用节点亲和性。</p> </li><li> <pre><code>preferredDuringSchedulingIgnoredDuringExecution
</code></pre> <p>表示 Pod 首选满足指定的节点亲和性规则的节点，但不是必须的。</p> 
     <ul><li> <p><code>weight</code> 定义了此规则的权重，在多个规则存在时，权重越大的规则优先级越高。</p> </li><li> <pre><code>preference   定义了节点选择器的匹配条件。
</code></pre> 
       <ul><li> <pre><code>matchExpressions   定义了节点选择器的匹配表达式。
</code></pre> 
         <ul><li><code>key</code> 指定了要匹配的节点标签键，这里使用了 <code>kubernetes.io/hostname</code> 表示节点主机名。</li><li><code>operator</code> 定义了匹配操作符，这里使用了 <code>In</code> 表示节点主机名在指定的列表中。</li><li><code>values</code> 定义了满足匹配条件的节点主机名列表，这里只有一个值 <code>node03</code>。</li></ul> </li></ul> </li></ul> </li></ul> </li></ul> 
 <p>因此，这个 Pod 定义了一个首选节点亲和性规则，优先调度到主机名为 <code>node03</code> 的节点上。如果不存在主机名为 <code>node03</code> 的节点，则该 Pod 将被分配到其它节点上。</p> 
</blockquote> 
<pre><code>kubectl apply -f pod2.yaml
</code></pre> 
<p><img src="https://images2.imgbox.com/9f/5e/n0PAOGxQ_o.png" alt="外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传"></p> 
<pre><code>kubectl get pods -o wide
</code></pre> 
<p><img src="https://images2.imgbox.com/f5/9b/Kz6ti6Ws_o.png" alt="外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传"></p> 
<pre><code>#把values:的值改成node02，则会优先在node02上创建Pod
kubectl delete pod --all &amp;&amp; kubectl apply -f pod2.yaml &amp;&amp; kubectl get pods -o wide
</code></pre> 
<p><img src="https://images2.imgbox.com/d3/9d/ylrM6fqp_o.png" alt="外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传"></p> 
<h4><a id="5_551"></a>（5）节点软硬策略亲和示例</h4> 
<p>如果把硬策略和软策略合在一起使用，则要先满足硬策略之后才会满足软策略</p> 
<pre><code>vim pod3.yaml

apiVersion: v1
kind: Pod
metadata:
  name: affinity-pre
  labels:
    app: node-affinity-pod
spec:
  containers:
  - name: with-node-affinity
    image: soscscs/myapp:v1
  affinity:
    nodeAffinity:
      requiredDuringSchedulingIgnoredDuringExecution:   #先满足硬策略，排除有kubernetes.io/hostname=node02标签的节点
        nodeSelectorTerms:
        - matchExpressions:
          - key: kubernetes.io/hostname
            operator: NotIn
            values:
            - node02
      preferredDuringSchedulingIgnoredDuringExecution:  #再满足软策略，优先选择有blue=a标签的节点
	  - weight: 1
        preference:
          matchExpressions:
          - key: blue
            operator: In
            values:
            - a
</code></pre> 
<blockquote> 
 <p>注释：</p> 
 <ul><li> <p><code>metadata</code> 部分定义了 Pod 的元数据，包括名称和标签。</p> </li><li> <p><code>spec.containers</code> 定义了要在 Pod 中运行的容器的配置，包括容器名称和镜像。</p> </li><li> <pre><code>affinity    定义了节点亲和性配置。
</code></pre> 
   <ul><li> <p><code>nodeAffinity</code> 指定了使用节点亲和性。</p> </li><li> <pre><code>requiredDuringSchedulingIgnoredDuringExecution   表示 Pod 必须满足指定的节点亲和性规则才能被调度到节点上。
</code></pre> 
     <ul><li> <pre><code>nodeSelectorTerms    定义了节点选择器的条件，这里只有一个匹配表达式。
</code></pre> 
       <ul><li> <pre><code>matchExpressions     定义了节点选择器的匹配表达式。
</code></pre> 
         <ul><li><code>key</code> 指定了要匹配的节点标签键，这里使用了 <code>kubernetes.io/hostname</code> 表示节点主机名。</li><li><code>operator</code> 定义了匹配操作符，这里使用了 <code>NotIn</code> 表示排除匹配指定节点主机名的节点。</li><li><code>values</code> 定义了不满足匹配条件的节点主机名列表，这里只有一个值 <code>node02</code>。</li></ul> </li></ul> </li></ul> </li><li> <pre><code>preferredDuringSchedulingIgnoredDuringExecution   表示 Pod 首选满足指定的节点亲和性规则的节点，但不是必须的。
</code></pre> 
     <ul><li> <p><code>weight</code> 定义了此规则的权重，在多个规则存在时，权重越大的规则优先级越高。</p> </li><li> <pre><code>preference    定义了节点选择器的匹配条件。
</code></pre> 
       <ul><li> <pre><code>matchExpressions     定义了节点选择器的匹配表达式。
</code></pre> 
         <ul><li><code>key</code> 指定了要匹配的节点标签键，这里使用了 <code>blue</code> 表示蓝色标签。</li><li><code>operator</code> 定义了匹配操作符，这里使用了 <code>In</code> 表示节点标签值在指定的列表中。</li><li><code>values</code> 定义了满足匹配条件的蓝色标签值列表，这里只有一个值 <code>a</code>。</li></ul> </li></ul> </li></ul> </li></ul> </li></ul> 
 <p>因此，这个 Pod 定义了一个节点亲和性规则，必须满足不在 <code>node02</code> 节点上才能被调度。此外，它还定义了一个首选节点亲和性规则，优先调度到具有蓝色标签值为 <code>a</code> 的节点上。如果不存在满足这些条件的节点，则该 Pod 无法被调度。</p> 
</blockquote> 
<p><img src="https://images2.imgbox.com/f0/af/yoHAwtCk_o.png" alt="外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传"></p> 
<pre><code>kubectl apply -f pod3.yaml
kubectl get pod -owide
</code></pre> 
<p><img src="https://images2.imgbox.com/c4/31/G9njSunD_o.png" alt="外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传"></p> 
<h3><a id="2pod_646"></a>2.pod亲和性与反亲和性</h3> 
<p>pod亲和：相同的等级，更倾向于哪一个，就是pod亲和性，如果一定要和其中一个平等，就是硬策略；如果是想和一个平等并且最好的是软策略，软策略是不去也可以，硬策略则是不去就不行。</p> 
<h4><a id="1Pod_650"></a>（1）Pod亲和性与反亲和性的调整策略</h4> 
<table><thead><tr><th>调度策略</th><th>匹配标签</th><th>操作符</th><th>拓扑域支持</th><th>调度目标</th></tr></thead><tbody><tr><td>nodeAffinity</td><td>主机</td><td>In, NotIn, Exists,DoesNotExist, Gt, Lt</td><td>否</td><td>指定主机</td></tr><tr><td>podAffinity</td><td>Pod</td><td>In, NotIn, Exists,DoesNotExist</td><td>是</td><td>Pod与指定Pod同一拓扑域</td></tr><tr><td>podAntiAffinity</td><td>Pod</td><td>In, NotIn, Exists,DoesNotExist</td><td>是</td><td>Pod与指定Pod不在同一拓扑域</td></tr></tbody></table> 
<h4><a id="2Pod_658"></a>（2）Pod亲和性示例</h4> 
<pre><code>kubectl label nodes node01 blue=a
kubectl label nodes node02 blue=a
</code></pre> 
<pre><code>#创建一个标签为 app=myapp01 的 Pod
vim pod4.yaml

apiVersion: v1
kind: Pod
metadata:
  name: myapp01
  labels:
    app: myapp01
spec:
  containers:
  - name: with-node-affinity
    image: soscscs/myapp:v1
</code></pre> 
<blockquote> 
 <p>注释：</p> 
 <ul><li><code>apiVersion: v1</code> 表示使用 Kubernetes API 的版本。</li><li><code>kind: Pod</code> 表示部署的资源类型是 Pod。</li><li><code>metadata</code> 定义了该资源的元数据信息，包括名称和标签等属性。</li><li><code>spec</code> 定义了该 Pod 的具体配置信息，包括容器定义、存储卷和网络等相关配置。</li></ul> 
 <p>在该 YAML 文件中，Pod 中包含一个容器，容器名称为 <code>with-node-affinity</code>，它使用了镜像 <code>soscscs/myapp:v1</code>，这个镜像可能是开发者自己编写的或从其他地方获取的。</p> 
</blockquote> 
<pre><code>kubectl apply -f pod4.yaml
</code></pre> 
<pre><code>kubectl get pods --show-labels -o wide
</code></pre> 
<p><img src="https://images2.imgbox.com/11/7f/CUCwnAKf_o.png" alt="外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传"></p> 
<pre><code>#使用 Pod 亲和性调度，创建多个 Pod 资源
vim pod5.yaml

apiVersion: v1
kind: Pod
metadata:
  name: myapp02
  labels:
    app: myapp02
spec:
  containers:
  - name: myapp02
    image: soscscs/myapp:v1
  affinity:
    podAffinity:
      requiredDuringSchedulingIgnoredDuringExecution:
      - labelSelector:
          matchExpressions:
          - key: app
            operator: In
            values:
            - myapp01
        topologyKey: blue
</code></pre> 
<blockquote> 
 <p>注释：</p> 
 <p>文件定义了一个名为 <code>myapp02</code> 的 Pod，其中包含一个名为 <code>myapp02</code> 的容器。此外，它还定义了 Pod 间的亲和性规则。</p> 
 <p>在这个规则中，<code>myapp02</code> Pod 要求与具有标签 <code>app: myapp01</code> 的其他 Pod 在拓扑域（topology domain）上保持亲和。具体来说，它要求与拓扑域中具有相同 <code>blue</code> 属性的 Pod 保持亲和。</p> 
 <p>拓扑域是指一组共享相同资源或特征的节点。在这个例子中，通过指定 <code>topologyKey</code> 为 <code>blue</code>，<code>myapp02</code> Pod 希望与拥有相同 <code>blue</code> 属性的其他 Pod 在同一个拓扑域内被调度。</p> 
 <p>这种亲和性规则可以用于将相关的 Pod 部署到相同的拓扑域中，以提高应用程序的性能和可靠性。</p> 
</blockquote> 
<blockquote> 
 <p>#仅当节点和至少一个已运行且有键为“app”且值为“myapp01”的标签 的 Pod 处于同一拓扑域时，才可以将该 Pod 调度到节点上。 （更确切的说，如果节点 N 具有带有键 kgc 和某个值 V 的标签，则 Pod 有资格在节点 N 上运行，以便集群中至少有一个具有键 blue 和值为 V 的节点正在运行具有键“app”和值 “myapp01”的标签的 pod。）<br> #topologyKey 是节点标签的键。如果两个节点使用此键标记并且具有相同的标签值，则调度器会将这两个节点视为处于同一拓扑域中。 调度器试图在每个拓扑域中放置数量均衡的 Pod。<br> #如果 kgc 对应的值不一样就是不同的拓扑域。比如 Pod1 在 kgc=a 的 Node 上，Pod2 在 kgc=b 的 Node 上，Pod3 在 blue=a 的 Node 上，则 Pod2 和 Pod1、Pod3 不在同一个拓扑域，而Pod1 和 Pod3在同一个拓扑域。</p> 
</blockquote> 
<pre><code>kubectl apply -f pod5.yaml
</code></pre> 
<pre><code>kubectl get pods --show-labels -o wide
</code></pre> 
<p><img src="https://images2.imgbox.com/e7/83/T8JFVY7q_o.png" alt="外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传"></p> 
<h4><a id="3Pod_1_753"></a>（3）Pod 反亲和性调度示例1</h4> 
<pre><code>vim pod5f.yaml

apiVersion: v1
kind: Pod
metadata:
  name: myapp10
  labels:
    app: myapp10
spec:
  containers:
  - name: myapp10
    image: soscscs/myapp:v1
  affinity:
    podAntiAffinity:
      preferredDuringSchedulingIgnoredDuringExecution:
      - weight: 100
        podAffinityTerm:
          labelSelector:
            matchExpressions:
            - key: app
              operator: In
              values:
              - myapp01
          topologyKey: kubernetes.io/hostname
</code></pre> 
<blockquote> 
 <p>注释：</p> 
 <p>文件定义了一个 Pod 名为 <code>myapp10</code>，其中包含一个名为 <code>myapp10</code> 的容器。此外，它还定义了 Pod 间的反亲和性规则。在本例中，<code>myapp10</code> Pod 首选与具有标签 <code>app: myapp01</code> 的其他 Pod 在主机名（hostname）拓扑域上保持反亲和。具体来说，它首选不与拓扑域中的具有相同主机名的 Pod 一起调度。这可以帮助将相关的 Pod 分散到不同的节点上。</p> 
</blockquote> 
<blockquote> 
 <p>#如果节点处于 Pod 所在的同一拓扑域且具有键“app”和值“myapp01”的标签， 则该 pod 不应将其调度到该节点上。 （如果 topologyKey 为 kubernetes.io/hostname，则意味着当节点和具有键 “app”和值“myapp01”的 Pod 处于相同的拓扑域，Pod 不能被调度到该节点上。）</p> 
</blockquote> 
<pre><code>kubectl apply -f pod5f.yaml
</code></pre> 
<pre><code>kubectl get pods --show-labels -o wide
</code></pre> 
<p><img src="https://images2.imgbox.com/54/8a/g9WGldHn_o.png" alt="外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传"></p> 
<h4><a id="4Pod_2_799"></a>（4）Pod 反亲和性调度示例2</h4> 
<pre><code>vim pod6f.yaml

apiVersion: v1
kind: Pod
metadata:
  name: myapp20
  labels:
    app: myapp20
spec:
  containers:
  - name: myapp20
    image: soscscs/myapp:v1
  affinity:
    podAntiAffinity:
      requiredDuringSchedulingIgnoredDuringExecution:
      - labelSelector:
          matchExpressions:
          - key: app
            operator: In
            values:
            - myapp01
        topologyKey: blue
</code></pre> 
<blockquote> 
 <p>注释：</p> 
 <p>文件定义了一个 Pod 名为 <code>myapp20</code>，其中包含一个名为 <code>myapp20</code> 的容器。此外，它还定义了 Pod 间的反亲和性规则。在本例中，<code>myapp20</code> Pod 要求与具有标签 <code>app: myapp01</code> 的其他 Pod 在拓扑域上保持反亲和。具体来说，它要求不与拓扑域中的具有相同 <code>blue</code> 属性的 Pod 一起调度。这可以帮助将相关的 Pod 分散到不同的拓扑域中。</p> 
 <p>由于指定 Pod 所在的 node01 节点上具有带有键 kgc 和标签值 a 的标签，node02 也有这个kgc=a的标签，所以 node01 和 node02 是在一个拓扑域中，反亲和要求新 Pod 与指定 Pod 不在同一拓扑域，所以新 Pod 没有可用的 node 节点，即为 Pending 状态。</p> 
</blockquote> 
<pre><code>kubectl apply -f pod6f.yaml
kubectl get pod --show-labels -owide
</code></pre> 
<p><img src="https://images2.imgbox.com/ca/80/M6A9znTw_o.png" alt="外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传"></p> 
<pre><code>kubectl label nodes node02 blue=b --overwrite
</code></pre> 
<pre><code>kubectl get pod --show-labels -o wide
</code></pre> 
<p><img src="https://images2.imgbox.com/1d/a0/5FX1BVYs_o.png" alt="外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传"></p> 
<h2><a id="Taint__Tolerations_851"></a>四.污点(Taint) 和 容忍(Tolerations)</h2> 
<h3><a id="1Taint_853"></a>1.污点(Taint)</h3> 
<h4><a id="1_855"></a>（1）污点概念</h4> 
<p>节点亲和性，是Pod的一种属性（偏好或硬性要求），它使Pod被吸引到一类特定的节点。Taint 则相反，它使节点能够排斥一类特定的 Pod。<br> Taint 和 Toleration 相互配合，可以用来避免 Pod 被分配到不合适的节点上。每个节点上都可以应用一个或多个 taint ，这表示对于那些不能容忍这些 taint 的 Pod，是不会被该节点接受的。如果将 toleration 应用于 Pod 上，则表示这些 Pod 可以（但不一定）被调度到具有匹配 taint 的节点上。</p> 
<p>使用 kubectl taint 命令可以给某个 Node 节点设置污点，Node 被设置上污点之后就和 Pod 之间存在了一种相斥的关系，可以让 Node 拒绝 Pod 的调度执行，甚至将 Node 已经存在的 Pod 驱逐出去。</p> 
<blockquote> 
 <p>pod不会将服务部署到有污点的机器上</p> 
</blockquote> 
<h4><a id="2_864"></a>（2）污点的组成格式及污点的存在选项</h4> 
<pre><code>key=value:effect
</code></pre> 
<p>每个污点有一个 key 和 value 作为污点的标签，其中 value 可以为空，effect 描述污点的作用。</p> 
<p>当前 taint effect 支持如下三个选项：<br> ●NoSchedule：表示 k8s 将不会将 Pod 调度到具有该污点的 Node 上<br> ●PreferNoSchedule：表示 k8s 将尽量避免将 Pod 调度到具有该污点的 Node 上<br> ●NoExecute：表示 k8s 将不会将 Pod 调度到具有该污点的 Node 上，同时会将 Node 上已经存在的 Pod 驱逐出去——更换节点使用</p> 
<h4><a id="3_877"></a>（3）查看节点污点</h4> 
<pre><code>kubectl get nodes
</code></pre> 
<p><img src="https://images2.imgbox.com/7f/27/q9peVd5G_o.png" alt="外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传"></p> 
<pre><code>#master 就是因为有 NoSchedule 污点，k8s 才不会将 Pod 调度到 master 节点上
kubectl describe node master
</code></pre> 
<p><img src="https://images2.imgbox.com/47/d7/XwU6vWt9_o.png" alt="外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传"></p> 
<h4><a id="4_894"></a>（4）节点污点示例</h4> 
<pre><code>#设置污点
kubectl taint node node01 key1=value1:NoSchedule
</code></pre> 
<pre><code>#节点说明中，查找 Taints 字段
kubectl describe node node01 
</code></pre> 
<p><img src="https://images2.imgbox.com/4b/b4/Een3Lvfl_o.png" alt="外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传"></p> 
<pre><code>vim pod6w.yaml

apiVersion: v1
kind: Pod
metadata:
  name: pod6w
  labels:
    app: node-affinity-pod
spec:
  containers:
  - name: pod6w
    image: soscscs/myapp:v1
  affinity:
    nodeAffinity:
      requiredDuringSchedulingIgnoredDuringExecution:
        nodeSelectorTerms:
        - matchExpressions:
          - key: kubernetes.io/hostname
            operator: NotIn
            values:
            - node01
</code></pre> 
<blockquote> 
 <p>注释：</p> 
 <p>文件定义了一个 Pod 名为 <code>pod6w</code>，其中包含一个名为 <code>pod6w</code> 的容器。此外，它还定义了节点亲和性规则。在本例中，<code>pod6w</code> Pod 要求不被调度到具有标签 <code>kubernetes.io/hostname: node01</code> 的节点上。这将限制 Pod 的调度范围，使其不运行在指定的节点上。</p> 
</blockquote> 
<pre><code>kubectl apply -f pod6w.yaml
kubectl get pod -o wide
</code></pre> 
<p><img src="https://images2.imgbox.com/1e/c2/WgDNbPy7_o.png" alt="外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传"></p> 
<pre><code>#去除污点
kubectl taint node node01 key1:NoSchedule-
</code></pre> 
<pre><code>kubectl get pods -o wide
</code></pre> 
<p><img src="https://images2.imgbox.com/94/0c/uSYYCBKO_o.png" alt="外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传"></p> 
<pre><code>kubectl taint node node02 check=mycheck:NoExecute
</code></pre> 
<pre><code>#查看 Pod 状态，会发现 node02 上的 Pod 已经被全部驱逐（注：如果是 Deployment 或者 StatefulSet 资源类型，为了维持副本数量则会在别的 Node 上再创建新的 Pod）
kubectl get pods -o wide
</code></pre> 
<p><img src="https://images2.imgbox.com/2e/1f/WHACuSQ2_o.png" alt="外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传"></p> 
<blockquote> 
 <p>注：取消设置的node02污点</p> 
 <p>kubectl taint node node02 check=mycheck:NoExecute-</p> 
 <p><img src="https://images2.imgbox.com/fa/02/EilKRjgw_o.png" alt="外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传"></p> 
</blockquote> 
<h3><a id="2Tolerations_977"></a>2.容忍(Tolerations)</h3> 
<h4><a id="1Tolerations_979"></a>（1）容忍(Tolerations)概念</h4> 
<p>设置了污点的 Node 将根据 taint 的 effect:NoSchedule、PreferNoSchedule、NoExecute 和 Pod 之间产生互斥的关系，Pod 将在一定程度上不会被调度到 Node 上。但我们可以在 Pod 上设置容忍(Tolerations)，意思是设置了<strong>容忍的 Pod 将可以容忍污点的存在，可以被调度到存在污点的 Node 上</strong>。</p> 
<h4><a id="2_983"></a>（2）节点容忍示例</h4> 
<p>使用场景：如是为了测试后设置了污点秒数，在测试结束后，达到秒数之后会自动驱除，资源很多的情况下不建议做节点驱除</p> 
<pre><code>＃设置节点容忍驱除
kubectl taint node node01 check=summer:NoExecute
</code></pre> 
<p><img src="https://images2.imgbox.com/67/00/KCGN4SFS_o.png" alt="外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传"></p> 
<p><img src="https://images2.imgbox.com/21/a4/kFOCDj24_o.png" alt="外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传"></p> 
<pre><code>＃查看节点容忍设置
kubectl describe nodes node01 | grep -i taint
</code></pre> 
<pre><code>vim demo01.yaml

apiVersion: v1
kind: Pod
metadata:
  name: myapp01
  labels:
    app: myapp01
spec:
  containers:
  - name: with-node-affinity
    image: soscscs/myapp:v1
  restartPolicy: Always
  nodeSelector:
    kubernetes.io/hostname: node01
  tolerations:
  - key: "check"
    operator: "Equal"
    value: "summer"
    effect: "NoExecute"
    tolerationSeconds: 60　　　　　　＃设置６０秒之后自动驱除节点
</code></pre> 
<blockquote> 
 <p>注释：</p> 
 <ul><li><code>metadata</code>: 定义了 Pod 的元数据，包括名称和标签。</li><li><code>spec</code>: 定义了 Pod 的规格，包括容器、重启策略、节点选择和容忍策略。</li></ul> 
 <p>在这个配置中：</p> 
 <ul><li><code>containers</code>: 定义了 Pod 中的容器，这里包含一个名为 <code>with-node-affinity</code> 的容器，使用 <code>soscscs/myapp:v1</code> 镜像。</li><li><code>restartPolicy</code>: 设置了容器的重启策略为 <code>Always</code>，表示发生故障时会自动重启容器。</li><li><code>nodeSelector</code>: 定义了节点选择器，指定了 Pod 要运行在具有标签 <code>kubernetes.io/hostname: node01</code> 的节点上。这将限制 Pod 的调度范围，使其只能运行在具有该标签的节点上。</li><li><code>tolerations</code>: 定义了容忍策略，即 Pod 对于节点上的特定条件的容忍程度。在这个例子中，Pod 标记了一个键值对 <code>check=summer</code>，并设置容忍效果为 <code>NoExecute</code>，表示 Pod 允许在节点上执行非关键的系统任务。<code>tolerationSeconds</code> 设置为 60，表示容忍持续的时间为 60 秒。</li></ul> 
 <p>通过节点选择器和容忍策略，可以对 Pod 进行更加具体的调度和限制，以满足特定的需求。</p> 
</blockquote> 
<pre><code>kubectl apply -f demo01.yaml
</code></pre> 
<pre><code>kubectl get pod -o wide
kubectl get pod -w -o wide
</code></pre> 
<p><img src="https://images2.imgbox.com/1f/7c/lTgDBN8M_o.png" alt="外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传"></p> 
<p><img src="https://images2.imgbox.com/53/64/Xu0ElW4K_o.png" alt="外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传"></p> 
<pre><code>#在两个 Node 上都设置了污点后，会创建在master０１上，此时 Pod 将无法创建成功，如果再将master０１也设置污点则无法创建ｐｏｄ为Pending状态
kubectl taint node node02 check=summer:NoExecute
kubectl describe node node01 
kubectl describe node node02

kubectl get pods -o wide
NAME      READY   STATUS    RESTARTS   AGE   IP       NODE     NOMINATED NODE   READINESS GATES
myapp01   0/1     Pending   0          17s   &lt;none&gt;   &lt;none&gt;   &lt;none&gt;           &lt;none&gt;
</code></pre> 
<blockquote> 
 <p>#其中的 key、vaule、effect 都要与 Node 上设置的 taint 保持一致<br> #operator 的值为 Exists 将会忽略 value 值，即存在即可<br> #tolerationSeconds 用于描述当 Pod 需要被驱逐时可以在 Node 上继续保留运行的时间</p> 
</blockquote> 
<h4><a id="_1071"></a>（３）污点注意事项</h4> 
<ul><li>当不指定 key 值时，表示容忍所有的污点 key</li></ul> 
<pre><code>tolerations:
- operator: "Exists"
</code></pre> 
<ul><li>当不指定 effect 值时，表示容忍所有的污点作用</li></ul> 
<pre><code>tolerations:
- key: "key""Exists"
　operator:
</code></pre> 
<ul><li>有多个 Master 存在时，防止资源浪费，可以如下设置</li></ul> 
<pre><code>kubect1　taint node Master-Name node　role,kubernetes.io/master-;PreferNoSchedule
</code></pre> 
<ul><li>如果某个 Node 事新升级系统组件，为了防止业务长时间中断，可以先在该 Node 设置 NOExecule 污点，把该Node 上的 Pod 都驱逐出去</li></ul> 
<pre><code>kubect1 taint node node01 check=ycheck:NoExecute
</code></pre> 
<ul><li>比时如果别的 Node资源不够用，可临时给 Master设置PreferNoSchedule污点，让ｐｏｄ可在 Master上临时创建</li></ul> 
<pre><code>kubectI taint node master　node-role,kubernetes,io/master=:PreferNoSchedule
</code></pre> 
<ul><li> <p>待所有 node 的更新操作都完成后，再去除污点</p> <pre><code>kubectl taint node node01　check=mycheck:NoExecute-
</code></pre> </li></ul> 
<h2><a id="_1112"></a>五．维护操作</h2> 
<h3><a id="cordon_1114"></a>１．cordon调度器</h3> 
<h4><a id="_1116"></a>（１）对节点执行维护操作</h4> 
<pre><code>＃查看节点的状态
kubectl get nodes
</code></pre> 
<p><img src="https://images2.imgbox.com/a7/9e/QrWwkqwy_o.png" alt="外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传"></p> 
<h4><a id="cordon_1126"></a>（２）cordon调度器</h4> 
<p>使用场景：使需要维护的node节点机器不可以进行资源创建，在取消调度器创建的资源会正常,注：开启调度器之前的资源是正常的</p> 
<pre><code>①格式
#将 Node 标记为不可调度的状态，这样就不会让新创建的 Pod 在此 Node 上运行
#该node将会变为SchedulingDisabled状态
kubectl cordon &lt;NODE NAME&gt;　
#将 Node 标记为可调度的状态
kubectl uncordon &lt;NODE_NAME&gt;
</code></pre> 
<pre><code>②示例
#查看节点正常状态
kubectl get nodes
#查看是否设置了污点
kubectl describe nodes node01|grep -i taint
kubectl describe nodes node02|grep -i taint
#设置了取消污点
kubectl taint node node01 check=summer:NoExecute-
kubectl taint node node02 check=summer:NoExecute-
</code></pre> 
<pre><code>kubectl cordon node02
kubectl get nodes
</code></pre> 
<p><img src="https://images2.imgbox.com/f3/b8/nhx6u8hC_o.png" alt="外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传"></p> 
<pre><code>vim demo02.yaml 

apiVersion: v1
kind: Pod
metadata:
  name: myapp01
  labels:
    app: myapp01
spec:
  containers:
  - name: with-node-affinity
    image: soscscs/myapp:v1
  restartPolicy: Always
  nodeSelector:
    kubernetes.io/hostname: node02
</code></pre> 
<pre><code>kubectl apply -f demo02.yaml 
</code></pre> 
<pre><code>kubectl get pod
</code></pre> 
<p><img src="https://images2.imgbox.com/44/15/s9bTCihB_o.png" alt="外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传"></p> 
<pre><code>#关闭调度器
kubectl uncordon node02
#查看状态
kubectl get pod -owide
</code></pre> 
<p><img src="https://images2.imgbox.com/e5/56/05tDiLGs_o.png" alt="外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传"></p> 
<h3><a id="2drain_1198"></a>2.drain命令</h3> 
<pre><code>①格式
＃kubectl drain 可以让: Node 节点开始释放所有，并且不接收新的 pod 进程。drain本意排水，意思是将出问题的 Node 下的 Pod 转移到其它 Node 下运行
kubectl drain &lt;NODE NAME&gt;　--ignore-daemonsets --delete-local-data --force
</code></pre> 
<blockquote> 
 <p>注释：</p> 
 <p>–iqnore-daemonsets：无视 DaemonSet 管理下的 Pode</p> 
 <p>–delete-local-data：如果有mount local volume 的 pod，会强制杀掉该 pod</p> 
 <p>–force：强制释放不是控制器管理的 Pod，例如 kube-proxy</p> 
 <p>执行 drain 命令，会自动做了两件事情:</p> 
 <ul><li>设定此 node 为不可调度状态 (cordon)</li><li>evict (驱逐)了 Pod</li></ul> 
</blockquote> 
<pre><code>②示例
kubectl get pod -owide
kubectl drain node01 --ignore-daemonsets --delete-local-data --force
kubectl get pod -owide
</code></pre> 
<p><img src="https://images2.imgbox.com/71/2f/jIDcL1Ye_o.png" alt="在这里插入图片描述"></p> 
<blockquote> 
 <p>–ignore-daemonsets：在排空节点时忽略DaemonSet类型的Pod。<br> –delete-local-data：删除节点上的本地数据。包括PV、Volume等。<br> –force：强制执行排空操作，不进行确认提示。<br> –grace-period=：设置节点上的Pod被迁移前的优雅停机时间，默认情况下为30秒。<br> –pod-selector=：指定要排空的Pod的标签选择器，只有匹配选择器的Pod才会被迁移。<br> –ignore-errors：继续排空操作，即使在迁移Pod时发生错误。<br> –timeout=：设置排空操作的超时时间，默认情况下为0，表示无限等待，直到所有Pod被迁移完成</p> 
</blockquote> 
<p><strong>注：</strong><br> 使用kubectl drain命令需要具备集群管理员权限或特权账号。<br> 在执行排空操作之前，请确保已经做好备份和验证。<br> 排空操作会将Pod迁移至其他可用节点，因此可能会导致一段时间内的业务中断，请谨慎操作。</p> 
<pre><code>#取消drain命令使用结果
kubectl uncordon node01
</code></pre> 
<p><img src="https://images2.imgbox.com/50/9e/F4xvBSQR_o.png" alt="在这里插入图片描述"></p> 
<h2><a id="Pod_phase_1246"></a>六.Pod启动阶段（相位 phase）</h2> 
<h3><a id="1pod_1248"></a>1.pod启动过程</h3> 
<p>Pod 创建完之后，一直到持久运行起来，中间有很多步骤，也就有很多出错的可能，因此会有很多不同的状态。<br> 一般来说，pod 这个过程包含以下几个步骤：<br> （1）调度到某台 node 上。kubernetes 根据一定的优先级算法选择一台 node 节点将其作为 Pod 运行的 node<br> （2）拉取镜像<br> （3）挂载存储配置等<br> （4）运行起来。如果有健康检查，会根据检查的结果来设置其状态。</p> 
<h3><a id="2phase__1257"></a>2.phase 的可能状态</h3> 
<p>（1）Pending：表示APIServer创建了Pod资源对象并已经存入了etcd中，但是它并未被调度完成（比如还没有调度到某台node上），或者仍然处于从仓库下载镜像的过程中。</p> 
<p>（2）Running：Pod已经被调度到某节点之上，并且Pod中所有容器都已经被kubelet创建。至少有一个容器正在运行，或者正处于启动或者重启状态（也就是说Running状态下的Pod不一定能被正常访问）。</p> 
<p>（3）Succeeded：有些pod不是长久运行的，比如job、cronjob，一段时间后Pod中的所有容器都被成功终止，并且不会再重启。需要反馈任务执行的结果。</p> 
<p>（4）Failed：Pod中的所有容器都已终止了，并且至少有一个容器是因为失败终止。也就是说，容器以非0状态退出或者被系统终止，比如 command 写的有问题。</p> 
<p>（5）Unknown：表示无法读取 Pod 状态，通常是 kube-controller-manager 无法与 Pod 通信。</p> 
<h3><a id="3_1269"></a>3.故障排除步骤</h3> 
<p>（1）查看Pod事件</p> 
<pre><code>kubectl describe TYPE NAME_PREFIX  
</code></pre> 
<p>（2）查看Pod日志（Failed状态下）</p> 
<pre><code>kubectl logs &lt;POD_NAME&gt; [-c Container_NAME]
</code></pre> 
<p>（3）进入Pod（状态为running，但是服务没有提供）</p> 
<pre><code>kubectl exec –it &lt;POD_NAME&gt; bash
</code></pre> 
<p>（4）查看集群信息</p> 
<pre><code>kubectl get nodes
</code></pre> 
<p>（5）发现集群状态正常</p> 
<pre><code>kubectl cluster-info
</code></pre> 
<p>（6）查看kubelet日志发现</p> 
<pre><code>journalctl -xefu kubelet
</code></pre> 
<h2><a id="_1307"></a>总：</h2> 
<h3><a id="1listwatch_1309"></a>1.list-watch</h3> 
<p>controller-manager,scheduler,kubelet监听apiserver 发出的事件，apiserver 监听 etcd 发出的事件,</p> 
<h3><a id="2scheduler_1313"></a>2.scheduler</h3> 
<p>预选策略:通过调度算法过滤掉不满足的节点</p> 
<p>优选策略:通过优先级选项给满足调度条件的节点进行优先级和权重排序，选择优先级最高的节点</p> 
<h3><a id="3pod__1319"></a>3.pod 调度到指定节点的方法</h3> 
<p>配置文件中指定nodename<br> nodeSelector</p> 
<h3><a id="4_1324"></a>4.节点亲和性和反亲和性</h3> 
<table><thead><tr><th>节点亲和性</th><th>硬策略 (必要条件)</th><th>软策略(优先级)</th></tr></thead><tbody><tr><td>pod亲和性</td><td>和满足标签的条件的pod</td><td>在同一个拓步域</td></tr><tr><td>pod反亲和性</td><td>和满足标签的条件的pod</td><td>不在同一个拓步域</td></tr></tbody></table> 
<h3><a id="5_1330"></a>5.相关标签命令</h3> 
<p>kubectl get &lt;资源类型&gt; &lt;资源名称&gt; --show-labels</p> 
<p>kubectl get &lt;资源类型&gt; -l &lt;标签 key&gt; [=&lt;标签 value&gt;]</p> 
<p>kubectl label &lt;资源类型&gt; &lt;资源名称&gt; key-value</p> 
<p>kubectl label &lt;资源类型&gt; &lt;资源名称&gt; key=vaule --overrwite</p> 
<p>kubect1 label &lt;资源光型&gt; &lt;资源名称&gt; key-</p> 
<h3><a id="6_1342"></a>6.污点和容忍</h3> 
<p>（1）设置和取消</p> 
<p>kubectl taint node &lt;节点名称&gt; key=value:effect</p> 
<p>effect:NoSchedule PeferNoSchedule Noexecute</p> 
<p>kubectl taint node &lt;节点名称&gt; key:effect-</p> 
<p>（2）调度</p> 
<p>kubectl cordon &lt;节点名称&gt;不可调度</p> 
<p>kubectl drain &lt;节点名称&gt; 不可调度+驱逐</p> 
<h3><a id="7Pod_5_1358"></a>7.Pod启动阶段(相位) 5个状态</h3> 
<p>（1）pendding：pod已创建且写入etcd，但是未完成调度或者仍处于镜像拉取过程中</p> 
<p>（2）running：正常状态</p> 
<p>（3）Succeeded：短期 (非长久运行的) Pod的正常退出</p> 
<p>（4）failed：短期 (非长久运行的) pod 异常退出</p> 
<p>（5）unkown：controller-manager 无法与pod 正常通信</p> 
<h3><a id="8_1370"></a>8.排除故障方法</h3> 
<p>（1）kubectl describe</p> 
<p>（2）kubectl logs</p> 
<p>（3）kubectI exec -it</p> 
<p>（4）kubectl cluster-info</p> 
<p>（5）journalctl -u 服务进程名 (比如kubelet)</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/f14b3801df719a9e6964dd243ad8fbad/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">K8S：pod资源限制及探针</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/ad70d4da749ea2944564a561e0354dc7/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">Java项目打包成jar包后，代码中读取文件路径错误</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>