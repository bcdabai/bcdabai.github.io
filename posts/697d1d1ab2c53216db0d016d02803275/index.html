<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>linux常用配置文件作用及其用法（更新中。） - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="linux常用配置文件作用及其用法（更新中。）" />
<meta property="og:description" content="各种profile 用户环境配置 当用户刚登录Linux时，首先会启动/etc/profile文件 ,~/.bash_profile、 ~/.bash_login、 ~/.profile。 如果 ~/.bash_profile文件存在的话，一般还会执行~/.bashrc文件。
要注意的是在/etc/profile 文件中设置的变量是全局变量。
关于各个文件的作用域：
/etc/profile： 此文件为系统的每个用户设置环境信息,当用户第一次登录时,该文件被执行. 并从/etc/profile.d目录的配置文件中搜集shell的设置。/etc/bashrc: 为每一个运行bash shell的用户执行此文件.当bash shell被打开时,该文件被读取（即每次新开一个终端，都会执行bashrc）。~/.bash_profile: 每个用户都可使用该文件输入专用于自己使用的shell信息,当用户登录时,该文件仅仅执行一次。默认情况下,设置一些环境变量,执行用户的.bashrc文件。~/.bashrc: 该文件包含专用于你的bash shell的bash信息,当登录时以及每次打开新的shell时,该该文件被读取。~/.bash_logout: 当每次退出系统(退出bash shell)时,执行该文件. 另外,/etc/profile中设定的变量(全局)的可以作用于任何用户,而~/.bashrc等中设定的变量(局部)只能继承 /etc/profile中的变量,他们是&#34;父子&#34;关系。~/.bash_profile: 也可能是 .profile 是交互式、login 方式进入 bash 运行的~/.bashrc 是交互式 non-login 方式进入 bash 运行的通常二者设置大致相同，所以通常前者会调u用后者。 /etc/profile.d目录下的文件和 /etc/profile 的区别：
两个文件都是设置环境变量文件的，/etc/profile是永久性的环境变量,是全局变量，/etc/profile.d/设置所有 用户生效/etc/profile.d/比/etc/profile好维护，不想要什么变量直接删除/etc/profile.d/下对应的shell脚本即可，不用 像/etc/profile需要改动此文件
下面以jdk的安装为例 vi /etc/profile.d/java.sh
#set java environment JAVA_HOME=/var/mysoft/jdk1.7.0_80 PATH=$JAVA_HOME/bin:$PATH export JAVA_HOME PATH /etc/skel/ 新增用户初始化配置 /etc/skel/目录是用来存放新用户配置文件的目录，当我们添加新用户的时候，这个目录下的所有文件会自动被复制到新添加的用户的家目录下。
默认情况下这个目录下的所有文件都是隐藏文件（以.点开头的文件）。
可以通过修改、添加、删除/etc/skel目录下的文件，为新创建的用户提供统一的、标准的、初始化用户环境。
如果在新建用户时，没有自动建立用户家目录，则无法调用到此框架目录。
如果不想以默认的/etc/skel目录作为框架目录，可以在运行useradd命令时指定新的框架目录。例如：
sudo useradd -d /home/zbuter -m -k /etc/my_skel zbuter 上述命令将新建用户zbuter，设置用户根目录为/home/zbuter，并且此目录会自动建立；同时指定框架目录为/etc/my_skel。
如果不想在每次新建用户时，都重新指定新的框架目录，可以通过修改/etc/default/useradd配置文件来改变默认的框架目录，方法如下：" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/697d1d1ab2c53216db0d016d02803275/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2020-03-08T00:07:44+08:00" />
<meta property="article:modified_time" content="2020-03-08T00:07:44+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">linux常用配置文件作用及其用法（更新中。）</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-light">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <h3><a id="profile__0"></a>各种profile 用户环境配置</h3> 
<p>当用户刚登录Linux时，首先会启动<code>/etc/profile</code>文件 ,<code>~/.bash_profile</code>、 <code>~/.bash_login</code>、 <code>~/.profile</code>。 如果 <code>~/.bash_profile</code>文件存在的话，一般还会执行<code>~/.bashrc</code>文件。</p> 
<p>要注意的是在<code>/etc/profile</code> 文件中设置的变量是全局变量。</p> 
<p>关于各个文件的作用域：</p> 
<ol><li><code>/etc/profile</code>： 此文件为系统的每个用户设置环境信息,当用户第一次登录时,该文件被执行. 并从<code>/etc/profile.d</code>目录的配置文件中搜集shell的设置。</li><li><code>/etc/bashrc</code>: 为每一个运行bash shell的用户执行此文件.当bash shell被打开时,该文件被读取（即每次新开一个终端，都会执行bashrc）。</li><li><code>~/.bash_profile</code>: 每个用户都可使用该文件输入专用于自己使用的shell信息,当用户登录时,该文件仅仅执行一次。默认情况下,设置一些环境变量,执行用户的.bashrc文件。</li><li><code>~/.bashrc</code>: 该文件包含专用于你的bash shell的bash信息,当登录时以及每次打开新的shell时,该该文件被读取。</li><li><code>~/.bash_logout</code>: 当每次退出系统(退出bash shell)时,执行该文件. 另外,/etc/profile中设定的变量(全局)的可以作用于任何用户,而~/.bashrc等中设定的变量(局部)只能继承 /etc/profile中的变量,他们是"父子"关系。</li><li><code>~/.bash_profile</code>: 也可能是 .profile 是交互式、login 方式进入 bash 运行的~/.bashrc 是交互式 non-login 方式进入 bash 运行的通常二者设置大致相同，所以通常前者会调u用后者。</li></ol> 
<p><code>/etc/profile.d</code>目录下的文件和 <code>/etc/profile</code> 的区别：</p> 
<ol><li>两个文件都是设置环境变量文件的，/etc/profile是永久性的环境变量,是全局变量，/etc/profile.d/设置所有 用户生效</li><li>/etc/profile.d/比/etc/profile好维护，不想要什么变量直接删除/etc/profile.d/下对应的shell脚本即可，不用 像/etc/profile需要改动此文件<br> 下面以jdk的安装为例</li></ol> 
<p>vi /etc/profile.d/java.sh</p> 
<pre><code class="prism language-bash">	
	
	<span class="token comment">#set java environment</span>
	
	JAVA_HOME<span class="token operator">=</span>/var/mysoft/jdk1.7.0_80
	PATH<span class="token operator">=</span><span class="token variable">$JAVA_HOME</span>/bin:<span class="token variable">$PATH</span>
	<span class="token function">export</span> JAVA_HOME PATH
</code></pre> 
<h3><a id="etcskel__31"></a>/etc/skel/ 新增用户初始化配置</h3> 
<p><code>/etc/skel/</code>目录是用来存放新用户配置文件的目录，当我们添加新用户的时候，这个目录下的所有文件会自动被复制到新添加的用户的家目录下。<br> 默认情况下这个目录下的所有文件都是隐藏文件（以.点开头的文件）。<br> 可以通过修改、添加、删除/etc/skel目录下的文件，为新创建的用户提供统一的、标准的、初始化用户环境。</p> 
<ol><li> <p>如果在新建用户时，没有自动建立用户家目录，则无法调用到此框架目录。</p> </li><li> <p>如果不想以默认的<code>/etc/skel</code>目录作为框架目录，可以在运行useradd命令时指定新的框架目录。例如：</p> <pre><code class="prism language-bash"><span class="token function">sudo</span> <span class="token function">useradd</span> -d /home/zbuter -m -k /etc/my_skel zbuter
</code></pre> <p>上述命令将新建用户zbuter，设置用户根目录为/home/zbuter，并且此目录会自动建立；同时指定框架目录为/etc/my_skel。</p> </li><li> <p>如果不想在每次新建用户时，都重新指定新的框架目录，可以通过修改<code>/etc/default/useradd</code>配置文件来改变默认的框架目录，方法如下：</p> <p>查找SKEL变量的定义，如果此变量的定义已被注释掉，可以取消注释，然后修改其值：</p> <pre><code class="prism language-bash">SKEL<span class="token operator">=</span>/etc/my_skel
</code></pre> </li></ol> 
<h3><a id="etcfstab__54"></a>/etc/fstab 文件系统挂载，自动挂载磁盘分区</h3> 
<p>字段定义</p> 
<p>/etc/fstab 文件包含了如下字段，通过空格或 Tab 分隔：</p> 
<p><code>&lt;file system&gt;</code> <code>&lt;dir&gt;</code> <code>&lt;type&gt;</code> <code>&lt;options&gt;</code> <code>&lt;dump&gt;</code> <code>&lt;pass&gt;</code></p> 
<p>#第一列<code>&lt;file system&gt;</code> ：要被挂载的磁盘设备</p> 
<p>#第二列 <code>&lt;dir&gt;</code> ：前面目录的挂载点（前面的目录挂载到哪个目录下）</p> 
<p>#第三列<code>&lt;type&gt;</code>：挂载的文件系统类型！支持许多种不同的文件系统：ext2, ext3, ext4, reiserfs, xfs, jfs, smbfs, iso9660, vfat, ntfs, swap 及 auto。 设置成auto类型，mount 命令会猜测使用的文件系统类型，对 CDROM 和 DVD 等移动设备是非常有用的。</p> 
<p>#第四列<code>&lt;options&gt;</code>：挂载的选项！注意有些mount 参数是特定文件系统才有的。一些比较常用的参数有</p> 
<pre><code class="prism language-bash">auto - 在启动时或键入了 <span class="token function">mount</span> -a 命令时自动挂载。
noauto - 只在你的命令下被挂载。
<span class="token function">exec</span> - 允许执行此分区的二进制文件。
noexec - 不允许执行此文件系统上的二进制文件。
ro - 以只读模式挂载文件系统。
rw - 以读写模式挂载文件系统。
user - 允许任意用户挂载此文件系统，若无显示定义，隐含启用 noexec, nosuid, nodev 参数。
<span class="token function">users</span> - 允许所有 <span class="token function">users</span> 组中的用户挂载文件系统.
nouser - 只能被 root 挂载。
owner - 允许设备所有者挂载.
<span class="token function">sync</span> - I/O 同步进行。
async - I/O 异步进行。
dev - 解析文件系统上的块特殊设备。
nodev - 不解析文件系统上的块特殊设备。
suid - 允许 suid 操作和设定 sgid 位。这一参数通常用于一些特殊任务，使一般用户运行程序时临时提升权限。
nosuid - 禁止 suid 操作和设定 sgid 位。
noatime - 不更新文件系统上 inode 访问记录，可以提升性能<span class="token punctuation">(</span>参见 atime 参数<span class="token punctuation">)</span>。
nodiratime - 不更新文件系统上的目录 inode 访问记录，可以提升性能<span class="token punctuation">(</span>参见 atime 参数<span class="token punctuation">)</span>。
relatime - 实时更新 inode access 记录。只有在记录中的访问时间早于当前访问才会被更新。（与 noatime 相似，但不会打断如 mutt 或其它程序探测文件在上次访问后是否被修改的进程。），可以提升性能<span class="token punctuation">(</span>参见 atime 参数<span class="token punctuation">)</span>。
flush - vfat 的选项，更频繁的刷新数据，复制对话框或进度条在全部数据都写入后才消失。
defaults - 使用文件系统的默认挂载参数，例如 ext4 的默认参数为:rw, suid, dev, exec, auto, nouser, async.
</code></pre> 
<p>#第五列<code>&lt;dump&gt;</code>：是否需要备份磁盘，1表示需要备份，0表示不需要备份</p> 
<p>#第六列 <code>&lt;pass&gt;</code>：开机是否自检</p> 
<h3><a id="etcpasswd__97"></a>/etc/passwd 系统所有用户信息</h3> 
<p>这个文件中保存的就是系统中所有的用户和用户的主要信息。<br> /etc/passwd中一行记录对应着一个用户，每行记录又被冒号(:)分隔为7个字段，其格式和具体含义如下：</p> 
<table><thead><tr><th>root</th><th>x</th><th>0</th><th>0</th><th>root</th><th>/root</th><th>/bin/bash</th></tr></thead><tbody><tr><td>账号</td><td>密码</td><td>UID</td><td>GID</td><td>用户说明</td><td>用户家目录</td><td>shell解释器</td></tr></tbody></table> 
<h3><a id="etcshadow__105"></a>/etc/shadow 用户密码信息</h3> 
<p>该文件一共分为9部分如下：</p> 
<ol><li> <p>帐号名称：这个文件的第一栏就是帐号，必须要与 /etc/passwd 对应。</p> </li><li> <p>密码：是真正的密码，而且是经过编码过的密码， 如果是在密码栏的第一个字元为<code>*</code>或者是<code>!</code>，表示这个帐号并不会被用来登录的意思。 所以可以先在这个档案中，将某位用户的密码栏位的最前面多加一个 <code>*</code> 或者<code>!</code>他就无法登录该帐号。想让他登录删掉这个前缀就可以了。</p> </li><li> <p>最近更动密码的日期：这个栏位记录了‘更动密码的那一天’的日期， 以 1970 年 1 月 1 日作为 1 ，每过一日增加一 。</p> </li><li> <p>密码不可被更动的天数： 第四个栏位记录了这个帐号的密码需要经过几天才可以被变更！如果是 0 的话， 表示密码随时可以更动的意思。这样的限制是为了怕密码被某些人一改再改而设计的！如果设定为 20 天的话，那么当你设定了密码之后， 20 天之内都无法改变这个密码！</p> </li><li> <p>密码需要重新变更的天数： 由于害怕密码被某些‘有心人士’窃取而危害到整个系统的安全，所以有了这个栏位的设计。 你必须要在这个时间之内重新设定你的密码，否则这个帐号将会暂时失效。 而如果像上面的 99999 的话，那就表示，密码不需要重新输入！</p> </li><li> <p>密码需要变更期限前的警告期限：当帐号的密码失效期限快要到的时候， 就是上面那个‘必须变更密码’的那个时间时， 系统会依据这个栏位的设定，发出‘警告’言论给这个帐号，提醒他‘再过 n 天你的密码就要失效了，请尽快重新设定你的密码。</p> </li><li> <p>密码过期的受限时间：如果用户过了警告期限没有重新输入密码， 使得密码失效了，也就是说，你在‘必须变更密码的期限前，并没有变更你的密码！’ 那么该组密码就称为‘失效的密码’～怎么办？没关系，还有这个栏位的天数设计啊～ 意思就是说，当密码失效后，你还可以用这个密码在 n 天内进行登入的意思。 而如果在这个天数后还是没有变更密码，那么您的帐号就失效了！无法登入！</p> </li><li> <p>帐号失效日期：这个日期跟第三个栏位一样，都是使用 1970 年以来的总日数设定。这个栏位表示： 这个帐号在此栏位规定的日期之后，将无法再使用。 这个栏位会被使用通常应该是在‘收费服务’的系统中， 你可以规定一个日期让该帐号不能再使用！</p> </li><li> <p>保留：最后一个栏位是保留的</p> </li></ol> 
<p>举例：假如系统有一个dmtsai 用户，它的/etc/passwd文件信息如下所示</p> 
<pre><code class="prism language-bash">dmtsai:<span class="token variable">$1</span><span class="token variable">$8zdAKdfC</span><span class="token variable">$XDa8eSus2I7nQL7UjRsIy</span>/:13025:5:60:7:2:13125:
</code></pre> 
<p>这表示什么呢？要注意的是， 13025 是 2005/08/30 ，所以， dmtsai 这个使用者他的密码相关意义是：</p> 
<ul><li> <p>最近一次更动密码的日期是 2005/08/30 (13025)；</p> </li><li> <p>能够修改密码的时间是 5 天以后，也就是 2005/09/04 以前 dmtsai 不能修改自己的密码； 如果使用者还是尝试要更动自己的密码，系统就会出现这样的讯息：</p> </li></ul> 
<pre><code class="prism language-bash">You must <span class="token function">wait</span> longer to change your password

passwd: Authentication token manipulation error
</code></pre> 
<ul><li> <p>使用者必须要在 2005/09/04 到 2005/10/29 之间的 60 天限制内去修改自己的密码，若 2005/10/29 之后还是没有变更密码时，该帐号就会宣告失效；</p> </li><li> <p>如果使用者一直没有更改密码，那么在 2005/10/29 之前的 7 天内，系统会警告 dmtsai 应该修改密码的相关资讯；例如当 dmtsai 登入时，系统会主动提示如下的资讯：</p> </li></ul> 
<pre><code class="prism language-bash">Warning: your password will expire <span class="token keyword">in</span> 5 days
</code></pre> 
<ul><li> <p>如果该帐号一直到 2005/10/29 都没有更改密码，由于还有两天的恕限时间，因此， dmtsai 还是可以在 2005/10/31 以前继续登入；</p> </li><li> <p>如果使用者在 2005/10/29 以前变更过密码，那么那个 13025 的日期就会跟著改变，因此， 所有的限制日期也会跟著相对变动</p> </li><li> <p>无论使用者如何动作，到了 13125 ，大约是 2005/12/8 左右，该帐号就失效了～</p> </li></ul> 
<p>生产场景应用案例</p> 
<p>root密码忘记或者被更动了？怎么办？</p> 
<p>这个时候就必须要使用到 /etc/shadow 这个文件，我们刚刚知道密码是存在这个档案中的， 所以只要你能够以各种可行的方法开机进入 Linux ，例如单人维护模式，或者是以 live CD (KNOPPIX) 来进入 Linux 系统。之后，将硬碟顺利挂载，然后进入 /etc/shadow 这个档案中，将 root 的密码这一栏全部清空！然后再登入 Linux 一次，这个时候 root 将不需要密码 (有的时候需要输入空白字元) 就可以登入了！这个时候请赶快以 passwd 设定 root 密码即可。</p> 
<h3><a id="etcsudoers__165"></a>/etc/sudoers 普通用户授权</h3> 
<p>sudo默认配置文件是 <strong>/etc/sudoers</strong> ，一般使用Linux指定编辑工具visudo ，此工具的好处是可以进行错误检查。在添加规则不符合语法规则时，保存退出时会提示给我们错误信息；配置好后，可以用切换到您授权的普通用户下，通过<code>sudo -l</code>来查看哪些命令是可以执行的或禁止的；</p> 
<p>/etc/sudoers 文件中每行是一个规则</p> 
<p>/etc/sudoers 的规则可分为两类；一类是授权规则，另一类是别名定义；别名定义并不是必须的，但授权规则是必须的；</p> 
<pre><code class="prism language-bash"><span class="token punctuation">[</span>root@itcast ~<span class="token punctuation">]</span><span class="token comment"># cat /etc/sudoers</span>
<span class="token comment">## Sudoers allows particular users to run various commands as</span>
<span class="token comment">## the root user, without needing the root password.</span>
<span class="token comment">##该文件允许特定用户像root用户一样使用各种各样的命令，而不需要root用户的密码 </span>
<span class="token comment">##</span>
<span class="token comment">## Examples are provided at the bottom of the file for collections</span>
<span class="token comment">## of related commands, which can then be delegated out to particular</span>
<span class="token comment">## users or groups.</span>
<span class="token comment">## 在文件的底部提供了很多相关命令的示例以供选择，这些示例都可以被特定用户或  </span>
<span class="token comment">## ## 用户组所使用  </span>
<span class="token comment">## This file must be edited with the 'visudo' command.</span>
<span class="token comment">## 该文件必须使用"visudo"命令编辑</span>

<span class="token comment">## Host Aliases</span>
<span class="token comment">#主机别名</span>
<span class="token comment">## Groups of machines. You may prefer to use hostnames (perhap using </span>
<span class="token comment">## wildcards for entire domains) or IP addresses instead.</span>
<span class="token comment">## 对于一组服务器，你可能会更喜欢使用主机名（可能是全域名的通配符）</span>
<span class="token comment">## 或IP地址代替，这时可以配置主机别名</span>
  
<span class="token comment"># Host_Alias     FILESERVERS = fs1, fs2</span>
<span class="token comment"># Host_Alias     MAILSERVERS = smtp, smtp2</span>

<span class="token comment">## User Aliases</span>
<span class="token comment">#用户别名</span>
<span class="token comment">## These aren't often necessary, as you can use regular groups</span>
<span class="token comment">## (ie, from files, LDAP, NIS, etc) in this file - just use %groupname </span>
<span class="token comment">## rather than USERALIAS</span>
<span class="token comment">## 这并不很常用，因为你可以通过使用组来代替一组用户的别名  </span>
<span class="token comment"># User_Alias ADMINS = jsmith, mikem</span>


<span class="token comment">## Command Aliases</span>
<span class="token comment">## These are groups of related commands...</span>
<span class="token comment">## 指定一系列相互关联的命令（当然可以是一个）的别名，通过赋予该别名sudo权限，  </span>
<span class="token comment">## 可以通过sudo调用所有别名包含的命令，下面是一些示例</span>


<span class="token comment">## Networking</span>
<span class="token comment">#网络操作相关命令别名  </span>
Cmnd_Alias NETWORKING <span class="token operator">=</span> /sbin/route, /sbin/ifconfig, /bin/ping, /sbin/dhclient,
 /usr/bin/net, /sbin/iptables, /usr/bin/rfcomm, /usr/bin/wvdial, /sbin/iwconfig, 
 /sbin/mii-tool

<span class="token comment">## Installation and management of software</span>
<span class="token comment">#软件安装管理相关命令别名  </span>
Cmnd_Alias SOFTWARE <span class="token operator">=</span> /bin/rpm, /usr/bin/up2date, /usr/bin/yum

<span class="token comment">## Services</span>
<span class="token comment">#服务相关命令别名 </span>
Cmnd_Alias SERVICES <span class="token operator">=</span> /sbin/service, /sbin/chkconfig

<span class="token comment">## Updating the locate database</span>
<span class="token comment">#本地数据库升级命令别名  </span>
Cmnd_Alias LOCATE <span class="token operator">=</span> /usr/sbin/updatedb

<span class="token comment">## Storage</span>
<span class="token comment">#磁盘操作相关命令别名</span>
Cmnd_Alias STORAGE <span class="token operator">=</span> /sbin/fdisk, /sbin/sfdisk, /sbin/parted, /sbin/partprobe, /bin/mount, /bin/umount

<span class="token comment">## Delegating permissions</span>
<span class="token comment">#代理权限相关命令别名 </span>
Cmnd_Alias DELEGATING <span class="token operator">=</span> /usr/sbin/visudo, /bin/chown, /bin/chmod, /bin/chgrp

<span class="token comment">## Processes</span>
<span class="token comment">#进程相关命令别名</span>
Cmnd_Alias PROCESSES <span class="token operator">=</span> /bin/nice, /bin/kill, /usr/bin/kill, /usr/bin/killall

<span class="token comment">## Drivers</span>
<span class="token comment">#驱动命令别名</span>
Cmnd_Alias DRIVERS <span class="token operator">=</span> /sbin/modprobe
<span class="token comment">#环境变量的相关配置</span>
<span class="token comment"># Defaults specification</span>

<span class="token comment">#</span>
<span class="token comment"># Disable "ssh hostname sudo &lt;cmd&gt;", because it will show the password in clear. </span>
<span class="token comment">#         You have to run "ssh -t hostname sudo &lt;cmd&gt;".</span>
<span class="token comment">#</span>
Defaults    requiretty

Defaults    env_reset
Defaults    env_keep <span class="token operator">=</span> <span class="token string">"COLORS DISPLAY HOSTNAME HISTSIZE INPUTRC KDEDIR \
                        LS_COLORS MAIL PS1 PS2 QTDIR USERNAME \
                        LANG LC_ADDRESS LC_CTYPE LC_COLLATE LC_IDENTIFICATION \
                        LC_MEASUREMENT LC_MESSAGES LC_MONETARY LC_NAME LC_NUMERIC \
                        LC_PAPER LC_TELEPHONE LC_TIME LC_ALL LANGUAGE LINGUAS \
                        _XKB_CHARSET XAUTHORITY"</span>

<span class="token comment">## Next comes the main part: which users can run what software on</span>
<span class="token comment">## which machines (the sudoers file can be shared between multiple</span>
<span class="token comment">## systems).</span>
<span class="token comment">## 下面是规则配置：什么用户在哪台服务器上可以执行哪些命令（sudoers文件可以在多个系统上共享）</span>
<span class="token comment">## Syntax:</span>
<span class="token comment">##语法</span>
<span class="token comment">##      user    MACHINE=COMMANDS</span>
<span class="token comment">##  用户 登录的主机=（可以变换的身份） 可以执行的命令  </span>
<span class="token comment">##</span>
<span class="token comment">## The COMMANDS section may have other options added to it.</span>
<span class="token comment">## 命令部分可以附带一些其它的选项  </span>
<span class="token comment">##</span>
<span class="token comment">## Allow root to run any commands anywhere </span>
<span class="token comment">## 允许root用户执行任意路径下的任意命令 </span>
root    ALL<span class="token operator">=</span><span class="token punctuation">(</span>ALL<span class="token punctuation">)</span>       ALL

<span class="token comment">## Allows members of the 'sys' group to run networking, software,</span>
<span class="token comment">## service management apps and more.</span>
<span class="token comment"># %sys ALL = NETWORKING, SOFTWARE, SERVICES, STORAGE, DELEGATING, PROCESSES, LOCATE, DRIVERS</span>
<span class="token comment">## 允许sys中户组中的用户使用NETWORKING等所有别名中配置的命令</span>
  
<span class="token comment">## Allows people in group wheel to run all commands</span>
<span class="token comment"># %wheel        ALL=(ALL)       ALL</span>
<span class="token comment">## 允许wheel用户组中的用户执行所有命令  </span>
<span class="token comment">## Same thing without a password</span>
<span class="token comment">## 允许wheel用户组中的用户在不输入该用户的密码的情况下使用所有命令</span>
<span class="token comment"># %wheel        ALL=(ALL)       NOPASSWD: ALL</span>

<span class="token comment">## Allows members of the users group to mount and unmount the</span>
<span class="token comment">## cdrom as root</span>
<span class="token comment">## 允许users用户组中的用户像root用户一样使用mount、unmount、chrom命令 </span>
<span class="token comment"># %users  ALL=/sbin/mount /mnt/cdrom, /sbin/umount /mnt/cdrom</span>

<span class="token comment">## Allows members of the users group to shutdown this system</span>
<span class="token comment"># %users  localhost=/sbin/shutdown -h now</span>
<span class="token comment">## 允许users用户组中的用户像root用户一样使用shutdown命令</span>

</code></pre> 
<p>授权格式</p> 
<blockquote> 
 <p>授权用户 主机=[(切换到哪些用户或用户组)] [是否需要密码验证] 命令1,[(切换到哪些用户或用户组)] [是否需要密码验证]<br> [命令2],[(切换到哪些用户或用户组)] [是否需要密码验证] [命令3]…</p> 
 <p>注解：</p> 
 <p>凡是[ ]中的内容，是可以省略；命令与命令之间用,号分隔；通过本文的例子，可以对照着看哪些是省略了，哪些地方需要有空格；<br> 在[(切换到哪些用户或用户组)] ，如果省略，则默认为root用户；如果是ALL ，则代表能切换到所有用户；注意要切换到的目的用户必须用()号括起来，比如(ALL)、(beinan)</p> 
</blockquote> 
<p>如果用户组出现在/etc/sudoers 中，前面要加%号，比如%test，中间不能有空格</p> 
<pre><code class="prism language-bash">%test ALL<span class="token operator">=</span>/usr/sbin/*,/sbin/*
<span class="token comment"># 表示test用户组下的所有用户可以执行使用sudo执行/usr/sbin/*,/sbin/*文件</span>
</code></pre> 
<pre><code class="prism language-bash"><span class="token punctuation">[</span>root@localhost ~<span class="token punctuation">]</span><span class="token comment"># visudo</span>
Host_Alias USERHOSTS <span class="token operator">=</span> 172.16.0.0/16,127.0.0.0/8,192.168.0.0/24    <span class="token comment">##定义主机别名，可以在哪些机器执行特殊命令</span>
Cmnd_Alias    USERADMIN<span class="token operator">=</span>/usr/sbin/useradd,/usr/sbin/usermod,/usr/sbin/userdel    <span class="token comment">##定义命令别名</span>
root    ALL<span class="token operator">=</span><span class="token punctuation">(</span>ALL<span class="token punctuation">)</span>       ALL
tom     ALL<span class="token operator">=</span><span class="token punctuation">(</span>root<span class="token punctuation">)</span>      USERADMIN    <span class="token comment">##此处定义tom可以执行别名USERADMIN中的所有命令</span>
tom     USERHOSTS<span class="token operator">=</span><span class="token punctuation">(</span>ROOT<span class="token punctuation">)</span>        USERADMIN    <span class="token comment">##可以在别名USERHOSTS中机器上执行别名USERADMIN中的命令</span>
zbuter ALL<span class="token operator">=</span><span class="token punctuation">(</span>ALL<span class="token punctuation">)</span> NOPASSWD: ALL <span class="token comment">## 设置zbuter可以执行root的所有命令而且不需要输入密码</span>
</code></pre> 
<p>禁止某用户执行某操作</p> 
<pre><code class="prism language-bash">tom ALL<span class="token operator">=</span>（root） /usr/bin/passwd <span class="token punctuation">[</span>a-zA-Z<span class="token punctuation">]</span>*,<span class="token operator">!</span>/usr/bin/passwd root
<span class="token comment">##tom可以以root的身份更改密码，但禁止更改root的密码。</span>
</code></pre> 
<p>设置执特权命令时，无需输入密码</p> 
<pre><code class="prism language-bash">tom   ALL<span class="token operator">=</span><span class="token punctuation">(</span>root<span class="token punctuation">)</span>    /usr/sbin/useradd,NOPASSWD: /usr/sbin/userdel,/usr/sbin/groupdel,PASSWD: /usr/sbin/usermod,/usr/sbin/groupmod
<span class="token comment">##这里的/usr/sbin/useradd 操作时必须使用密码；/usr/sbin/userdel, /usr/sbin/groupdel操作时可以不使用密码（跟在其后的所有操作一律不使用密码）；/usr/sbin/usermod, /usr/sbin/groupmod 操作时还是要输入密码；还有PASSWD和NOPASSWD不可定义于别名中哦！</span>
</code></pre> 
<p>Linux命令汇总：<br> https://blog.csdn.net/dengjin20104042056/article/details/94669639</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/636e2ad48f3a57dc4e0133ce1856fd31/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">我的bashrc控制台样式and一些全局变量and一些alias</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/0196c046948d54d4e986c160d916e06a/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">小米电视精简，去开机广告，系统更新，删除无用内置软件等</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>