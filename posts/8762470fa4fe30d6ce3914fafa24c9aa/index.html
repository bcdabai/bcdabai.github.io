<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Redis 哨兵架构、集群选举原理分析-04 - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Redis 哨兵架构、集群选举原理分析-04" />
<meta property="og:description" content="sentinel哨兵是特殊的redis服务，不提供读写服务，主要用来监控redis实例节点。 哨兵架构下client端第一次从哨兵找出redis的主节点，后续就直接访问redis的主节点，不会每次都通过 sentinel代理访问redis的主节点，当redis的主节点发生变化，哨兵会第一时间感知到，并且将新的redis 主节点通知给client端(这里面redis的client端一般都实现了订阅功能，订阅sentinel发布的节点变动消息) 1、当一个master服务器被某sentinel视为下线状态后，该sentinel会与其他sentinel协商选出sentinel的leader进行故障转移工作。
2、每个发现master服务器进入下线的sentinel都可以要求其他sentinel选自己为sentinel的leader，选举是先到先得。同时每个sentinel每次选举都会自增配置纪元(选举周期)，每个纪元中只会选择一个sentinel的leader。
3、如果所有超过一半的sentinel选举某sentinel作为leader。之后该sentinel进行故障转移操作，从存活的slave中选举出新的master，这个选举过程跟集群的master选举很类似。
4、哨兵集群只有一个哨兵节点，redis的主从也能正常运行以及选举master，如果master挂了，那唯一的那个哨兵节点就是哨兵leader了，可以正常选举新master。
5、不过为了高可用一般都推荐至少部署三个哨兵节点。
再选举出一个slave作为master 通知其余的slave，新的master是谁 通知客户端一个主从的变化 最后，sentinel会等待旧的master复活，然后将新master成为slave 那么，如何选择“合适”的slave节点呢？ 选择slave-priority(slave节点优先级，人为配置)最高的slave节点，如果存在则返回，不存在则继续。其次会选择复制偏移量最大的slave节点(复制得最完整)，如果存在则返回，不存在则继续最后会选择run_id最小的slave节点(启动最早的节点) Redis集群选举原理分析 当slave发现自己的master变为FAIL状态时，便尝试进行Failover，以期成为新的master。由于挂掉的master可能会有多个slave，从而存在多个slave竞争成为master节点的过程， 其过程如下：
1.slave发现自己的master变为FAIL
2.将自己记录的集群currentEpoch加1，并广播FAILOVER_AUTH_REQUEST 信息
3.其他节点收到该信息，只有master响应，判断请求者的合法性，并发送FAILOVER_AUTH_ACK，对每一个epoch只发送一次ack
4.尝试failover的slave收集master返回的FAILOVER_AUTH_ACK
5.slave收到超过半数master的ack后变成新Master(这里解释了集群为什么至少需要三个主节点，如果只有两个，当其中一个挂了，只剩一个主节点是不能选举成功的)
6.slave广播Pong消息通知其他集群节点。从节点并不是在主节点一进入 FAIL 状态就马上尝试发起选举，而是有一定延迟，一定的延迟确保我们等待FAIL状态在集群中传播，slave如果立即尝试选举，其它masters或许尚未意识到FAIL状态，可能会拒绝投票
•延迟计算公式：
DELAY = 500ms &#43; random(0 ~ 500ms) &#43; SLAVE_RANK * 1000ms SLAVE_RANK表示此slave已经从master复制数据的总量的rank。Rank越小代表已复制的数据越新。这种方式下，持有最新数据的slave将会首先发起选举（理论上）。
集群脑裂数据丢失问题
redis集群没有过半机制会有脑裂问题，网络分区导致脑裂后多个主节点对外提供写服务，一旦网络分区恢复，会将其中一个主节点变为从节点，这时会有大量数据丢失。
只作用在一个Redis节点上，即使Redis通过sentinel保证高可用，如果这个master节点由于某些原因发生了主从切换，那么就会出现锁丢失的情况： 在Redis的master节点上拿到了锁；但是这个加锁的key还没有同步到slave节点； master故障，发生故障转移，slave节点升级为master节点；导致锁丢失。 由于脑裂是由网络等原因造成的，除了提高网络、硬件等方法外，主要通过增加以下配置，改善出现脑裂而引发的数据丢失问题。规避方法可以在redis配置里加上参数(这种方法不可能百分百避免数据丢失，参考集群leader选举机制)：
min‐replicas‐to‐write 1 写数据成功最少同步的slave数量，这个数量可以模仿大于半数机制配置，比如集群总共三个节点可以配置1，加上leader就是2，超过了半数
注意：这个配置在一定程度上会影响集群的可用性，比如slave要是少于1个，这个集群就算leader正常也不能提供服务了，需要具体场景权衡选择。
min-slaves-max-lag 10 一旦所有的slave复制和同步的延迟达到了10s，那么此时master就不会接受任何请求。
通过降低min-slaves-max-lag参数的值，可以避免在发生故障时大量的数据丢失，一旦发现延迟超过了该值就不会往master中写入数据。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/8762470fa4fe30d6ce3914fafa24c9aa/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-06-11T09:56:02+08:00" />
<meta property="article:modified_time" content="2023-06-11T09:56:02+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Redis 哨兵架构、集群选举原理分析-04</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <div> 
 <span style="color:#000000;">sentinel哨兵是特殊的redis服务，不提供读写服务，主要用来监控redis实例节点。 </span> 
</div> 
<div> 
 <span style="color:#000000;">哨兵架构下client端第一次从哨兵找出redis的主节点，后续就直接访问redis的主节点，不会每次都通过 sentinel代理访问redis的主节点，当redis的主节点发生变化，哨兵会第一时间感知到，并且将新的redis 主节点通知给client端(这里面redis的client端一般都实现了订阅功能，订阅sentinel发布的节点变动消息)</span> 
</div> 
<div></div> 
<div> 
 <p style="margin-left:0;text-align:left;"><span style="background-color:#ffffff;"><span style="color:#666666;">1、</span></span><span style="background-color:#ffffff;"><span style="color:#666666;">当一个master服务器被某sentinel视为下线状态后，该sentinel会与其他sentinel协商选出sentinel的leader进行故障转移工作。</span></span></p> 
 <p style="margin-left:0;text-align:left;"><span style="background-color:#ffffff;"><span style="color:#666666;">2、</span></span><span style="background-color:#ffffff;"><span style="color:#666666;">每个发现master服务器进入下线的sentinel都可以要求其他sentinel选自己为sentinel的leader，选举是</span></span><strong><span style="background-color:#ffffff;"><span style="color:#666666;"><strong>先到先得</strong></span></span></strong><span style="background-color:#ffffff;"><span style="color:#666666;">。同时每个sentinel每次选举都会自增配置纪元(选举周期)，每个纪元中只会选择一个sentinel的leader。</span></span></p> 
 <p style="margin-left:0;text-align:left;"><span style="background-color:#ffffff;"><span style="color:#666666;">3、</span></span><span style="background-color:#ffffff;"><span style="color:#666666;">如果所有超过一半的sentinel选举某sentinel作为leader。之后该sentinel进行故障转移操作，从存活的slave中选举出新的master，这个选举过程跟集群的master选举很类似。</span></span></p> 
 <p style="margin-left:0;text-align:left;"><span style="background-color:#ffffff;"><span style="color:#666666;">4、</span></span><span style="background-color:#ffffff;"><span style="color:#666666;">哨兵集群只有一个哨兵节点，redis的主从也能正常运行以及选举master，如果master挂了，那唯一的那个哨兵节点就是哨兵leader了，可以正常选举新master。</span></span></p> 
 <p style="margin-left:0;text-align:left;"><span style="background-color:#ffffff;"><span style="color:#666666;">5、</span></span><span style="background-color:#ffffff;"><span style="color:#666666;">不过为了高可用一般都推荐至少部署三个哨兵节点。</span></span></p> 
 <p style="margin-left:0;text-align:left;"></p> 
 <pre><code>再选举出一个slave作为master
通知其余的slave，新的master是谁
通知客户端一个主从的变化
最后，sentinel会等待旧的master复活，然后将新master成为slave</code></pre> 
 <pre><code>那么，如何选择“合适”的slave节点呢？</code></pre> 
 <ol><li style="text-align:justify;"><span style="background-color:#f3f3f3;"><span style="color:#161209;">选择slave-priority(slave节点优先级，人为配置)最高的slave节点，如果存在则返回，不存在则继续。</span></span></li><li style="text-align:justify;"><span style="background-color:#f3f3f3;"><span style="color:#161209;">其次会选择复制偏移量最大的slave节点(复制得最完整)，如果存在则返回，不存在则继续</span></span></li><li style="text-align:justify;"><span style="background-color:#f3f3f3;"><span style="color:#161209;">最后会选择run_id最小的slave节点(启动最早的节点)</span></span></li></ol> 
 <h3 style="text-align:left;"><strong><strong><strong>Redis集群选举原理分析</strong></strong></strong></h3> 
 <p style="margin-left:.0001pt;text-align:justify;">当slave发现自己的master变为FAIL状态时，便尝试进行Failover，以期成为新的master。由于挂掉的master可能会有多个slave，从而存在多个slave竞争成为master节点的过程， 其过程如下：</p> 
 <p style="margin-left:.0001pt;text-align:justify;">1.slave发现自己的master变为FAIL</p> 
 <p style="margin-left:.0001pt;text-align:justify;">2.将自己记录的集群currentEpoch加1，并广播FAILOVER_AUTH_REQUEST 信息</p> 
 <p style="margin-left:.0001pt;text-align:justify;">3.其他节点收到该信息，只有master响应，判断请求者的合法性，并发送FAILOVER_AUTH_ACK，对每一个epoch只发送一次ack</p> 
 <p style="margin-left:.0001pt;text-align:justify;">4.尝试failover的slave收集master返回的FAILOVER_AUTH_ACK</p> 
 <p style="margin-left:.0001pt;text-align:justify;">5.slave收到超过半数master的ack后变成新Master(这里解释了集群为什么至少需要三个主节点，如果只有两个，当其中一个挂了，只剩一个主节点是不能选举成功的)</p> 
 <p style="margin-left:.0001pt;text-align:justify;">6.slave广播Pong消息通知其他集群节点。从节点并不是在主节点一进入 FAIL 状态就马上尝试发起选举，而是有一定延迟，一定的延迟确保我们等待FAIL状态在集群中传播，slave如果立即尝试选举，其它masters或许尚未意识到FAIL状态，可能会拒绝投票</p> 
 <p style="margin-left:.0001pt;text-align:justify;">•延迟计算公式：</p> 
 <pre><code> DELAY = 500ms + random(0 ~ 500ms) + SLAVE_RANK * 1000ms</code></pre> 
 <p style="margin-left:.0001pt;text-align:justify;">SLAVE_RANK表示此slave已经从master复制数据的总量的rank。Rank越小代表已复制的数据越新。这种方式下，持有最新数据的slave将会首先发起选举（理论上）。</p> 
 <p style="margin-left:.0001pt;text-align:justify;"><strong>集群脑裂数据丢失问题</strong></p> 
 <p style="margin-left:.0001pt;text-align:justify;">redis集群没有过半机制会有脑裂问题，网络分区导致脑裂后多个主节点对外提供写服务，一旦网络分区恢复，会将其中一个主节点变为从节点，这时会有大量数据丢失。</p> 
 <pre><code class="language-java">只作用在一个Redis节点上，即使Redis通过sentinel保证高可用，如果这个master节点由于某些原因发生了主从切换，那么就会出现锁丢失的情况：
在Redis的master节点上拿到了锁；但是这个加锁的key还没有同步到slave节点；
master故障，发生故障转移，slave节点升级为master节点；导致锁丢失。</code></pre> 
 <p style="margin-left:.0001pt;text-align:justify;"></p> 
 <p style="margin-left:.0001pt;text-align:justify;"><span style="background-color:#ffffff;"><span style="color:#121212;">由于脑裂是由网络等原因造成的，除了提高网络、硬件等方法外，主要通过增加以下配置，改善出现脑裂而引发的数据丢失问题。</span></span>规避方法可以在redis配置里加上参数(这种方法不可能百分百避免数据丢失，参考集群leader选举机制)：</p> 
 <pre><code class="language-java">min‐replicas‐to‐write 1</code></pre> 
 <p style="margin-left:.0001pt;text-align:justify;">写数据成功最少同步的slave数量，这个数量可以模仿大于半数机制配置，比如集群总共三个节点可以配置1，加上leader就是2，超过了半数</p> 
 <p style="margin-left:.0001pt;text-align:justify;">注意：这个配置在一定程度上会影响集群的可用性，比如slave要是少于1个，这个集群就算leader正常也不能提供服务了，需要具体场景权衡选择。</p> 
 <pre><code class="language-java">min-slaves-max-lag 10</code></pre> 
 <p style="margin-left:.0001pt;text-align:justify;">一旦所有的slave复制和同步的延迟达到了10s，那么此时master就不会接受任何请求。</p> 
 <p style="margin-left:.0001pt;text-align:justify;">通过降低min-slaves-max-lag参数的值，可以避免在发生故障时大量的数据丢失，一旦发现延迟超过了该值就不会往master中写入数据。</p> 
</div>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/27af270aaece6397f08ace84f00dc979/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">解决websocket.GetHttpSessionConfig.modifyHandshake中获取httpsession时为null报NullPointerException</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/5b0c3d46ac0d5e4e9208e7dc82758b2d/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">Linux中find命令的用法综合</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>