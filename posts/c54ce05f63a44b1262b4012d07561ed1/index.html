<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>鸿蒙：@Prop装饰器-父子单向同步 - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="鸿蒙：@Prop装饰器-父子单向同步" />
<meta property="og:description" content="​​​​​​ @Prop装饰的变量可以和父组件建立单向的同步关系。@Prop装饰的变量是可变的，但是变化不会同步回其父组件。从API version 9开始，该装饰器支持在ArkTS卡片中使用。
一、概述 @Prop装饰的变量和父组件建立单向的同步关系：
@Prop变量允许在本地修改，但修改后的变化不会同步回父组件。当父组件中的数据源更改时，与之相关的@Prop装饰的变量都会自动更新。如果子组件已经在本地修改了@Prop装饰的相关变量值，而在父组件中对应的@State装饰的变量被修改后，子组件本地修改的@Prop装饰的相关变量值将被覆盖。 二、限制条件 @Prop修饰复杂类型时是深拷贝，在拷贝的过程中除了基本类型、Map、Set、Date、Array外，都会丢失类型。@Prop装饰器不能在@Entry装饰的自定义组件中使用。 装饰器使用规则说明 @Prop变量装饰器
说明
装饰器参数
无
同步类型
单向同步：对父组件状态变量值的修改，将同步给子组件@Prop装饰的变量，子组件@Prop变量的修改不会同步到父组件的状态变量上
允许装饰的变量类型
string、number、boolean、enum类型。
不支持any，不允许使用undefined和null。
必须指定类型。
在父组件中，传递给@Prop装饰的值不能为undefined或者null，反例如下所示。
CompA ({ aProp: undefined })
CompA ({ aProp: null })
@Prop和数据源类型需要相同，有以下三种情况（数据源以@State为例）：
@Prop装饰的变量和父组件状态变量类型相同，即@Prop : S和@State : S；当父组件的状态变量为数组时，@Prop装饰的变量和父组件状态变量的数组项类型相同，即@Prop : S和@State : Array&lt;S&gt;；当父组件状态变量为Object或者class时，@Prop装饰的变量和父组件状态变量的属性类型相同，即@Prop : S和@State : { propA: S }。 被装饰变量的初始值
允许本地初始化。
4.变量的传递/访问规则说明 传递/访问
说明
从父组件初始化
如果本地有初始化，则是可选的。没有的话，则必选，支持父组件中的常规变量、@State、@Link、@Prop、@Provide、@Consume、@ObjectLink、@StorageLink、@StorageProp、@LocalStorageLink和@LocalStorageProp去初始化子组件中的@Prop变量。
用于初始化子组件
@Prop支持去初始化子组件中的常规变量、@State、@Link、@Prop、@Provide。
是否支持组件外访问
@Prop装饰的变量是私有的，只能在组件内访问。
初始化规则图示：
5.观察变化和行为表现 （1）观察变化 @Prop装饰的数据可以观察到以下变化：
当装饰的类型是允许的类型，即string、number、boolean、enum类型都可以观察到的赋值变化； // 简单类型
@Prop count: number;" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/c54ce05f63a44b1262b4012d07561ed1/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2024-01-26T11:57:57+08:00" />
<meta property="article:modified_time" content="2024-01-26T11:57:57+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">鸿蒙：@Prop装饰器-父子单向同步</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p>​​​​​​        @Prop装饰的变量可以和父组件建立单向的同步关系。@Prop装饰的变量是可变的，但是变化不会同步回其父组件。从API version 9开始，该装饰器支持在ArkTS卡片中使用。</p> 
<h2 style="text-align:justify;"><strong><strong>一、概述</strong></strong></h2> 
<p style="text-align:justify;">@Prop装饰的变量和父组件建立单向的同步关系：</p> 
<ol><li style="text-align:justify;">@Prop变量允许在本地修改，但修改后的变化不会同步回父组件。</li><li style="text-align:justify;">当父组件中的数据源更改时，与之相关的@Prop装饰的变量都会自动更新。如果子组件已经在本地修改了@Prop装饰的相关变量值，而在父组件中对应的@State装饰的变量被修改后，子组件本地修改的@Prop装饰的相关变量值将被覆盖。</li></ol> 
<h2 style="text-align:justify;"><strong><strong>二、限制条件</strong></strong></h2> 
<ol><li style="text-align:justify;">@Prop修饰复杂类型时是深拷贝，在拷贝的过程中除了基本类型、Map、Set、Date、Array外，都会丢失类型。</li><li style="text-align:justify;"><span style="color:#fe2c24;">@Prop装饰器不能在@Entry装饰的自定义组件中使用</span>。</li><li style="text-align:justify;"> <h4><strong><strong>装饰器使用规则说明</strong></strong></h4> </li></ol> 
<table align="center" style="width:456pt;"><tbody><tr><td style="background-color:#8db3e2;"> <p><strong><strong>@Prop变量装饰器</strong></strong></p> </td><td style="background-color:#8db3e2;"> <p><strong><strong>说明</strong></strong></p> </td></tr><tr><td style="background-color:#ffffff;"> <p>装饰器参数</p> </td><td style="background-color:#ffffff;"> <p>无</p> </td></tr><tr><td style="background-color:#ffffff;"> <p>同步类型</p> </td><td style="background-color:#ffffff;"> <p>单向同步：对父组件状态变量值的修改，将同步给子组件@Prop装饰的变量，子组件@Prop变量的修改不会同步到父组件的状态变量上</p> </td></tr><tr><td style="background-color:#ffffff;"> <p>允许装饰的变量类型</p> </td><td style="background-color:#ffffff;"> <p>string、number、boolean、enum类型。</p> <p>不支持any，不允许使用undefined和null。</p> <p>必须指定类型。</p> <p>在父组件中，传递给@Prop装饰的值不能为undefined或者null，反例如下所示。</p> <p>CompA ({ aProp: undefined })</p> <p>CompA ({ aProp: null })</p> <p><span style="color:#fe2c24;">@Prop和</span><a href="#section127619262713" rel="nofollow"><span style="color:#fe2c24;">数据源</span></a><span style="color:#fe2c24;">类型需要相同，</span>有以下三种情况（数据源以@State为例）：</p> 
    <ol><li>@Prop装饰的变量和父组件状态变量类型相同，即@Prop : S和@State : S；</li><li>当父组件的状态变量为数组时，@Prop装饰的变量和父组件状态变量的数组项类型相同，即@Prop : S和@State : Array&lt;S&gt;；</li><li>当父组件状态变量为Object或者class时，@Prop装饰的变量和父组件状态变量的属性类型相同，即@Prop : S和@State : { propA: S }。</li></ol></td></tr><tr><td style="background-color:#ffffff;"> <p>被装饰变量的初始值</p> </td><td style="background-color:#ffffff;"> <p>允许本地初始化。</p> </td></tr></tbody></table> 
<h4 style="text-align:justify;"><strong><strong>        4.变量的传递/访问规则说明</strong></strong></h4> 
<table align="center" style="width:461.95pt;"><tbody><tr><td style="background-color:#8db3e2;"> <p><strong><strong>传递/访问</strong></strong></p> </td><td style="background-color:#8db3e2;"> <p><strong><strong>说明</strong></strong></p> </td></tr><tr><td style="background-color:#ffffff;"> <p>从父组件初始化</p> </td><td style="background-color:#ffffff;"> <p>如果本地有初始化，则是可选的。没有的话，则必选，支持父组件中的常规变量、@State、@Link、@Prop、@Provide、@Consume、@ObjectLink、@StorageLink、@StorageProp、@LocalStorageLink和@LocalStorageProp去初始化子组件中的@Prop变量。</p> </td></tr><tr><td style="background-color:#ffffff;"> <p>用于初始化子组件</p> </td><td style="background-color:#ffffff;"> <p>@Prop支持去初始化子组件中的常规变量、@State、@Link、@Prop、@Provide。</p> </td></tr><tr><td style="background-color:#ffffff;"> <p>是否支持组件外访问</p> </td><td style="background-color:#ffffff;"> <p>@Prop装饰的变量是私有的，只能在组件内访问。</p> </td></tr></tbody></table> 
<p style="text-align:justify;"><span style="background-color:#ffffff;">初始化规则图示</span><span style="background-color:#ffffff;">：</span></p> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/2c/d5/po6OquVd_o.png"></p> 
<h4 style="text-align:justify;"><strong><strong>5.观察变化和行为表现</strong></strong></h4> 
<h5 style="text-align:justify;"><strong><strong>（1）观察变化</strong></strong></h5> 
<p style="text-align:justify;">@Prop装饰的数据可以观察到以下变化：</p> 
<ol><li style="text-align:justify;">当装饰的类型是允许的类型，即string、number、boolean、enum类型都可以观察到的赋值变化；</li></ol> 
<table border="1" cellspacing="0"><tbody><tr><td style="vertical-align:top;width:426.1pt;"> <p style="text-align:justify;"><span style="background-color:#ffffff;">// 简单类型</span></p> <p style="text-align:justify;"><span style="background-color:#ffffff;">@Prop count: number;</span></p> <p style="text-align:justify;"><span style="background-color:#ffffff;">// 赋值的变化可以被观察到</span></p> <p style="text-align:justify;"><span style="background-color:#ffffff;">this.count = 1;</span></p> </td></tr></tbody></table> 
<p style="text-align:justify;">对于@State和@Prop的同步场景：</p> 
<ul><li style="text-align:justify;">使用父组件中@State变量的值初始化子组件中的@Prop变量。当@State变量变化时，该变量值也会同步更新至@Prop变量。</li><li style="text-align:justify;">@Prop装饰的变量的修改不会影响其数据源@State装饰变量的值。</li><li style="text-align:justify;">除了@State，数据源也可以用@Link或@Prop装饰，对@Prop的同步机制是相同的。</li><li style="text-align:justify;">数据源和@Prop变量的类型需要相同。</li></ul> 
<h5 style="text-align:justify;"><strong><strong>（2）框架行为</strong></strong></h5> 
<p style="text-align:justify;">要理解@Prop变量值初始化和更新机制，有必要了解父组件和拥有@Prop变量的子组件初始渲染和更新流程。</p> 
<p style="text-align:justify;">        A.初始渲染</p> 
<ol><li style="text-align:justify;">执行父组件的build()函数将创建子组件的新实例，将数据源传递给子组件；</li><li style="text-align:justify;">初始化子组件@Prop装饰的变量。</li></ol> 
<p style="text-align:justify;">        B.更新：</p> 
<ol><li style="text-align:justify;">子组件@Prop更新时，更新仅停留在当前子组件，不会同步回父组件；</li><li style="text-align:justify;">当父组件的数据源更新时，子组件的@Prop装饰的变量将被来自父组件的数据源重置，所有@Prop装饰的本地的修改将被父组件的更新覆盖。</li></ol> 
<h4 style="text-align:justify;"><strong><strong>6.使用场景</strong></strong></h4> 
<h5 style="text-align:justify;"><strong><strong>A.父组件@State到子组件@Prop简单数据类型同步</strong></strong></h5> 
<p style="text-align:justify;">以下示例是@State到子组件@Prop简单数据同步，父组件ParentComponent的状态变量countDownStartValue初始化子组件CountDownComponent中@Prop装饰的count，点击“Try again”，count的修改仅保留在CountDownComponent，不会同步给父组件ParentComponent。</p> 
<p style="text-align:justify;">ParentComponent的状态变量countDownStartValue的变化将重置CountDownComponent的count。</p> 
<p style="text-align:justify;"></p> 
<pre><code class="language-TypeScript">@Component
struct CountDownComponent {
  @Prop count: number;
  costOfOneAttempt: number = 1;

  build() {
    Column() {
      if (this.count &gt; 0) {
        Text(`You have ${this.count} Nuggets left`).height(80)
      } else {
        Text('Game over!').height(80)
      }
      // @Prop装饰的变量不会同步给父组件
      Button(`Try again`).onClick(() =&gt; {
        this.count -= this.costOfOneAttempt;
      }).height(80)
        .width(250)
        .margin(5)
    }
  }
}

@Entry
@Component
struct ParentComponent {
  @State countDownStartValue: number = 10;

  build() {
    Column() {
      Text(`${this.countDownStartValue}`)
        .height(80)
      // 父组件的数据源的修改会同步给子组件
      Button(`+1`).onClick(() =&gt; {
        this.countDownStartValue += 1;
      }).height(80)
        .width(250)
        .margin(5)

      // 父组件的修改会同步给子组件
      Button(`-1 `).onClick(() =&gt; {
        this.countDownStartValue -= 1;
      }).height(80)
        .width(250)
        .margin(5)

      CountDownComponent({ count: this.countDownStartValue, costOfOneAttempt: 2 })
      Divider()
    }
  }
}</code></pre> 
<p>  </p> 
<ol><li style="text-align:justify;">CountDownComponent子组件首次创建时其@Prop装饰的count变量将从父组件@State装饰的countDownStartValue变量初始化；</li><li style="text-align:justify;">按“+1”或“-1”按钮时，父组件的@State装饰的countDownStartValue值会变化，这将触发父组件重新渲染，在父组件重新渲染过程中会刷新使用countDownStartValue状态变量的UI组件并单向同步更新CountDownComponent子组件中的count值；</li><li style="text-align:justify;">更新count状态变量值也会触发CountDownComponent的重新渲染，在重新渲染过程中，评估使用count状态变量的if语句条件（this.count &gt; 0），并执行true分支中的使用count状态变量的UI组件相关描述来更新Text组件的UI显示；</li><li style="text-align:justify;">当按下子组件CountDownComponent的“Try again”按钮时，其@Prop变量count将被更改，但是count值的更改不会影响父组件的countDownStartValue值；</li><li style="text-align:justify;">父组件的countDownStartValue值会变化时，父组件的修改将覆盖掉子组件CountDownComponent中count本地的修改。</li></ol> 
<h5 style="text-align:justify;"><strong><strong>B.父组件@State数组项到子组件@Prop简单数据类型同步</strong></strong></h5> 
<p style="text-align:justify;">父组件中@State如果装饰的数组，其数组项也可以初始化@Prop。以下示例中父组件Index中@State装饰的数组arr，将其数组项初始化子组件Child中@Prop装饰的value。</p> 
<pre><code class="language-TypeScript">@Component
struct Child {
  @Prop value: number;

  build() {
    Text(`${this.value}`)
      .fontSize(50)
      .onClick(()=&gt;{this.value++})
  }
}

@Entry
@Component
struct Index {
  @State arr: number[] = [1,2,3];

  build() {
    Row() {
      Column() {
        Child({value: this.arr[0]})
        Child({value: this.arr[1]})
        Child({value: this.arr[2]})

        Divider().height(5)

        ForEach(this.arr,
          item =&gt; {
            Child({value: item})
          },
          item =&gt; item.toString()
        )
        Text('replace entire arr')
          .fontSize(50)
          .onClick(()=&gt;{
            // 两个数组都包含项“3”。
            this.arr = this.arr[0] == 1 ? [3,4,5] : [1,2,3];
          })
      }
    }
  }
}</code></pre> 
<p>  </p> 
<p style="text-align:justify;">当点击“replace entire arr”文本时，会判断 数组第一位是否是1，同时给父组件中的arr赋值，并重新触发ForEach给子组件中的value赋值。父组件中的值传递给了子组件的@prop value。点击“replace entire arr”文本</p> 
<h5 style="text-align:justify;"><strong><strong>C.从父组件中的@State类对象属性到@Prop简单类型的同步</strong></strong></h5> 
<p style="text-align:justify;">如果图书馆有一本图书和两位用户，每位用户都可以将图书标记为已读，此标记行为不会影响其它读者用户。从代码角度讲，对@Prop图书对象的本地更改不会同步给图书馆组件中的@State图书对象。</p> 
<pre><code class="language-TypeScript">class Book {
  public title: string;
  public pages: number;
  public readIt: boolean = false;

  constructor(title: string, pages: number) {
    this.title = title;
    this.pages = pages;
  }
}

@Component
struct ReaderComp {
  @Prop title: string;
  @Prop readIt: boolean;

  build() {
    Row() {
      Text(this.title).margin(20)
      Text(`... ${this.readIt ? 'I have read' : 'I have not read it'}`)
        .margin(20)
        .onClick(() =&gt; this.readIt = true)
    }
  }
}

@Entry
@Component
struct Library {
  @State book: Book = new Book('100 secrets of C++', 765);

  build() {
    Column() {
      ReaderComp({ title: this.book.title, readIt: this.book.readIt })
      ReaderComp({ title: this.book.title, readIt: this.book.readIt })
    }
  }
}</code></pre> 
<p style="text-align:justify;">当点击“I have not read it”后，自动更改为“I have read”，完成了父组件和子组件简单类型同步并且每个子组件互不影响。</p> 
<h5 style="text-align:justify;"><strong><strong>D.@Prop本地初始化不和父组件同步</strong></strong></h5> 
<p style="text-align:justify;">为了支持@Component装饰的组件复用场景，@Prop支持本地初始化，这样可以让@Prop是否与父组件建立同步关系变得可选。当且仅当@Prop有本地初始化时，从父组件向子组件传递@Prop的数据源才是可选的。</p> 
<p style="text-align:justify;">下面的示例中，子组件包含两个@Prop变量：</p> 
<ol><li style="text-align:justify;">@Prop customCounter没有本地初始化，所以需要父组件提供数据源去初始化@Prop，并当父组件的数据源变化时，@Prop也将被更新；</li><li style="text-align:justify;">@Prop customCounter2有本地初始化，在这种情况下，@Prop依旧允许但非强制父组件同步数据源给@Prop。</li></ol> 
<p>  </p> 
<pre><code class="language-TypeScript">@Component
struct MyComponent {
  @Prop customCounter: number;
  @Prop customCounter2: number = 5;

  build() {
    Column() {
      Row() {
        Text(`From Main: ${this.customCounter}`).width(90).height(40).fontColor('#FF0010')
      }

      Row() {
        Button('Click to change locally !').width(180).height(60).margin({ top: 10 })
          .onClick(() =&gt; {
            this.customCounter2++
          })
      }.height(100).width(180)

      Row() {
        Text(`Custom Local: ${this.customCounter2}`).width(90).height(40).fontColor('#FF0010')
      }
    }
  }
}

@Entry
@Component
struct MainProgram {
  @State mainCounter: number = 10;

  build() {
    Column() {
      Row() {
        Column() {
          Button('Click to change number').width(480).height(60).margin({ top: 10, bottom: 10 })
            .onClick(() =&gt; {
              this.mainCounter++
            })
        }
      }

      Row() {
        // customCounter必须从父组件初始化，因为MyComponent的customCounter成员变量缺少本地初始化；此处，customCounter2可以不做初始化。
        MyComponent({ customCounter: this.mainCounter })
        // customCounter2也可以从父组件初始化，父组件初始化的值会覆盖子组件customCounter2的本地初始化的值
        MyComponent({ customCounter: this.mainCounter, customCounter2: this.mainCounter })

      }
    }
  }
}</code></pre> 
<p style="text-align:justify;">当点击第2行两个“Click to change locally !”时，“Custorm Local：x”都会自动加1。当点击“Click to change number”时，第2行中两个“From Main”和第2个“Click to change number”自动加1，第一个“Click to change number”保持不变，不和父组件同步。</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/a4f98e9499f93232a8bd2d4dcaf479d7/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">基于yolo进行目标检测的实验和研究</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/e752168f78c2c324a029133374a91e91/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">Mac&#43;Android Studio配置 Flutter环境</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>