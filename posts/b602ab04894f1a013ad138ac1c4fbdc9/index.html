<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>算法设计 排序算法实验 - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="算法设计 排序算法实验" />
<meta property="og:description" content="算法C&#43;&#43; 实验一 分治策略
一、实验目的和要求
理解分治法的算法思想，阅读实现书上已有的部分程序代码并完善程序，加深对分治法的算法原理及实现过程的理解
内容：
一、用分治法实现一组无序序列的两路合并排序和快速排序。要求清楚合并排序及快速排 序的基本原理，编程实现分别用这两种方法将输入的一组无序序列排序为有序序列后输出。
二、采用基于“五元中值组取中值分割法”(median-of-median-of-five partitioning)的线性 时间选择算法，找出 N 个元素集合 S 中的第 k 个最小的元素，使其在线性时间内解决。(参 考教材 5.5.3 节)
二、实验环境(实验设备)
硬件：微型计算机
软件：Windows 操作系统、Microsoft Visual C&#43;&#43;6.0
三、实验原理及内容
实验原理：
分治法得基本思想是将一个规模为n的问题分解为k个规模为m的相互独立且与原问题解法相同的子问题，然后将子问题的解合并得到原问题的解。由此可见，分治法设计出的程序一般是递归算法，设解决一个规模为1的问题需要1个单位时间，再设将k个子问题的解合并为原问题的解所需时间为f(n),则递归算法的时间复杂度为：
两路合并排序是一类时间复杂度为O(nlogn)的排序方法。基本思想为将有n个元素的序列看成是n个长度为1的有序序列，然后两两合并序列，得到 n/2个长度为2或1的有序序列，然后在进行两两合并，直到得到一个长度为n的有序序列。
先将无序序列利用二分法划分为子序列，直至每个子序列只有一个元素(单元素序列必有序)，然后再对有序子序列逐步(两两)进行合并排序。合并方法是循环的将两个有序子序列当前的首元素进行比较，较小的元素取出，置入合并序列的左边空置位，直至其中一个子序列的最后一个元素置入合并序列中。最后将另一个子序列的剩余元素按顺序逐个置入合并序列尾部即可完成排序。
快速排序使用分治的思想，通过一趟排序将待排序列分割成两部分，其中一部分记录的关键字均比另一部分记录的关键字小。之后分别对这两部分记录继续进行排序，以达到整个序列有序的目的。最好时间复杂度为：O(nlogn)，最坏时间复杂度为：O(n^2)，平均时间复杂度为O(nlogn)。
快速排序的三个步骤：
(1)选择基准：在待排序列中，按照某种方式挑出一个元素，作为 &#34;基准&#34;（pivot）
(2)分割操作：以该基准在序列中的实际位置，把序列分成两个子序列。此时，在基准左边的元素都比该基准小，在基准右边的元素都比基准大
(3)递归地对两个序列进行快速排序，直到序列为空或者只有一个元素。
实验内容：
排序是数据处理中常用手段，是指将一个元素序列调整为按一定顺序排列的有序序列，用分治策略解决排序问题的思想是将序列按照某方式分成数个子序列，再分别进行排序，再将已经排序的子序列合并成一个有序序列。两路合并排序和快速排序都是符合分治策略的。
两路合并排序： void mergeSort(int* arr, int lo, int hi) { //0 &lt;= lo &lt; hi &lt;= size
if (hi - lo &lt; 2) return;
//将数组分为两部分
int mid = (lo &#43; hi) / 2; //以中点为界限 mergeSort(arr, lo, mid); //左侧子数组" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/b602ab04894f1a013ad138ac1c4fbdc9/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-10-22T22:29:26+08:00" />
<meta property="article:modified_time" content="2022-10-22T22:29:26+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">算法设计 排序算法实验</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p>算法C++ 实验一 分治策略</p> 
<p></p> 
<p style="text-align:justify;"><strong><span style="color:#000000;">一、实验目的和要求</span></strong></p> 
<p style="margin-left:0;text-align:justify;"><span style="color:#000000;">理解分治法的算法思想，阅读实现书上已有的部分程序代码并完善程序，加深对分治法的算法原理及实现过程的理解</span></p> 
<p style="margin-left:0;text-align:justify;"><span style="color:#000000;">内容：</span></p> 
<p style="margin-left:0;text-align:justify;"><span style="color:#000000;">一、用分治法实现一组无序序列的两路合并排序和快速排序。要求清楚合并排序及快速排</span> <span style="color:#000000;">序的基本原理，编程实现分别用这两种方法将输入的一组无序序列排序为有序序列后输出。</span></p> 
<p><span style="color:#000000;">二、采用基于“五元中值组取中值分割法”</span><span style="color:#000000;">(median-of-median-of-five partitioning)</span><span style="color:#000000;">的线性</span> <span style="color:#000000;">时间选择算法，找出</span><span style="color:#000000;"> N </span><span style="color:#000000;">个元素集合</span><span style="color:#000000;"> S </span><span style="color:#000000;">中的第</span><span style="color:#000000;"> k </span><span style="color:#000000;">个最小的元素，使其在线性时间内解决。</span><span style="color:#000000;">(</span><span style="color:#000000;">参</span> <span style="color:#000000;">考教材</span><span style="color:#000000;"> 5.5.3 </span><span style="color:#000000;">节</span><span style="color:#000000;">)</span></p> 
<p style="margin-left:0;text-align:justify;"><span style="color:#000000;">二、</span><strong><span style="color:#000000;">实验环境</span></strong><strong><span style="color:#000000;">(</span></strong><strong><span style="color:#000000;">实验设备</span></strong><strong><span style="color:#000000;">)</span></strong></p> 
<p style="margin-left:0;text-align:justify;">硬件：微型计算机</p> 
<p style="margin-left:0;text-align:justify;">软件：Windows 操作系统、Microsoft Visual C++6.0</p> 
<p style="margin-left:0;text-align:justify;"><strong><span style="color:#000000;">三、实验原理及内容</span></strong></p> 
<p style="margin-left:0;text-align:justify;">实验原理：</p> 
<p style="margin-left:0;text-align:justify;">分治法得基本思想是将一个规模为n的问题分解为k个规模为m的相互独立且与原问题解法相同的子问题，然后将子问题的解合并得到原问题的解。由此可见，分治法设计出的程序一般是递归算法，设解决一个规模为1的问题需要1个单位时间，再设将k个子问题的解合并为原问题的解所需时间为f(n),则递归算法的时间复杂度为：</p> 
<p style="margin-left:0;text-align:center;"><img alt="" height="66" src="https://images2.imgbox.com/c1/96/XSs04VeJ_o.png" width="281"></p> 
<p style="margin-left:0;text-align:justify;"></p> 
<p style="margin-left:0;text-align:justify;">两路合并排序是一类时间复杂度为O(nlogn)的排序方法。基本思想为将有n个元素的序列看成是n个长度为1的有序序列，然后两两合并序列，得到 n/2个长度为2或1的有序序列，然后在进行两两合并，直到得到一个长度为n的有序序列。</p> 
<p style="margin-left:0;text-align:justify;">先将无序序列利用二分法划分为子序列，直至每个子序列只有一个元素(单元素序列必有序)，然后再对有序子序列逐步(两两)进行合并排序。合并方法是循环的将两个有序子序列当前的首元素进行比较，较小的元素取出，置入合并序列的左边空置位，直至其中一个子序列的最后一个元素置入合并序列中。最后将另一个子序列的剩余元素按顺序逐个置入合并序列尾部即可完成排序。</p> 
<p style="margin-left:0;text-align:justify;"></p> 
<p style="margin-left:0;text-align:justify;">快速排序使用分治的思想，通过一趟排序将待排序列分割成两部分，其中一部分记录的关键字均比另一部分记录的关键字小。之后分别对这两部分记录继续进行排序，以达到整个序列有序的目的。最好时间复杂度为：O(nlogn)，最坏时间复杂度为：O(n^2)，平均时间复杂度为O(nlogn)。</p> 
<p style="margin-left:0;text-align:justify;">快速排序的三个步骤：</p> 
<p style="margin-left:0;text-align:justify;">(1)选择基准：在待排序列中，按照某种方式挑出一个元素，作为 "基准"（pivot）</p> 
<p style="margin-left:0;text-align:justify;">(2)分割操作：以该基准在序列中的实际位置，把序列分成两个子序列。此时，在基准左边的元素都比该基准小，在基准右边的元素都比基准大</p> 
<p style="margin-left:0;text-align:justify;">(3)递归地对两个序列进行快速排序，直到序列为空或者只有一个元素。</p> 
<p style="margin-left:0;text-align:justify;">实验内容：</p> 
<p style="margin-left:0;text-align:justify;">排序是数据处理中常用手段，是指将一个元素序列调整为按一定顺序排列的有序序列，用分治策略解决排序问题的思想是将序列按照某方式分成数个子序列，再分别进行排序，再将已经排序的子序列合并成一个有序序列。两路合并排序和快速排序都是符合分治策略的。</p> 
<p></p> 
<ol><li style="text-align:justify;">两路合并排序：</li></ol> 
<p style="margin-left:0;text-align:left;"> void mergeSort(int* arr, int lo, int hi) {  //0 &lt;= lo &lt; hi &lt;= size</p> 
<p style="margin-left:0;text-align:left;">    if (hi - lo &lt; 2) return;</p> 
<p style="margin-left:0;text-align:left;">    //将数组分为两部分</p> 
<p style="margin-left:0;text-align:left;">    int mid = (lo + hi) / 2;   //以中点为界限 </p> 
<p style="margin-left:0;text-align:left;">    mergeSort(arr, lo, mid);   //左侧子数组</p> 
<p style="margin-left:0;text-align:left;">    mergeSort(arr, mid, hi);   //右侧子数组</p> 
<p style="margin-left:0;text-align:left;">    //按照组排序并连接</p> 
<p style="margin-left:0;text-align:left;">    merge(arr, lo, mid, hi);   //归并为有序数组</p> 
<p style="margin-left:0;text-align:left;">}</p> 
<p style="margin-left:0;text-align:left;">void merge(int* arr, int lo, int mid, int hi) {  //有序向量的合并</p> 
<p style="margin-left:0;text-align:left;">    int* temp = new int[hi - lo];   //汇总两个子向量的临时区域</p> 
<p style="margin-left:0;text-align:left;">    int left_idx = lo;</p> 
<p style="margin-left:0;text-align:left;">    int right_idx = mid;            //分别对应左侧和右侧的数组当前位置索引</p> 
<p style="margin-left:0;text-align:left;">    int temp_idx = 0;               //临时归并数组的区域索引</p> 
<p style="margin-left:0;text-align:left;"></p> 
<p style="margin-left:0;text-align:left;">    //数组长度：① left &lt; right  ②.right &lt; left ③.左右两数组所比较的元素都未耗尽，则直接比较两数组当前元素归入temp大数组（一般情况，蕴含了数组长度left = right的情况）：</p> 
<p style="margin-left:0;text-align:left;">    while (left_idx &lt; mid &amp;&amp; right_idx &lt; hi) {<!-- --></p> 
<p style="margin-left:0;text-align:left;">        if (arr[left_idx] &lt; arr[right_idx])</p> 
<p style="margin-left:0;text-align:left;">            temp[temp_idx++] = arr[left_idx++];//小的放前面，每次执行成功要让对应的指针后移一位</p> 
<p style="margin-left:0;text-align:left;">        else</p> 
<p style="margin-left:0;text-align:left;">            temp[temp_idx++] = arr[right_idx++];</p> 
<p style="margin-left:0;text-align:left;">    }</p> 
<p style="margin-left:0;text-align:left;">    //情况①：左侧数组比较元素已耗尽，直接复制</p> 
<p style="margin-left:0;text-align:left;">    while (left_idx &lt; mid) {<!-- --></p> 
<p style="margin-left:0;text-align:left;">        temp[temp_idx++] = arr[left_idx++];</p> 
<p style="margin-left:0;text-align:left;">    }</p> 
<p style="margin-left:0;text-align:left;">    //情况②：右侧数组比较情况已耗尽，直接复制</p> 
<p style="margin-left:0;text-align:left;">    while (right_idx &lt; hi) {<!-- --></p> 
<p style="margin-left:0;text-align:left;">temp[temp_idx++] = arr[right_idx++];</p> 
<p>}</p> 
<p style="margin-left:0;text-align:left;">for (int i = 0; i &lt; temp_idx; i++) {<!-- --></p> 
<p style="margin-left:0;text-align:left;">arr[lo + i] = temp[i];</p> 
<p style="margin-left:0;text-align:left;">}</p> 
<p style="margin-left:0;text-align:left;">    //所有操作完成后删除左端防止内存泄漏</p> 
<p style="margin-left:0;text-align:left;">    delete[] temp;</p> 
<p style="margin-left:0;text-align:justify;">}</p> 
<p style="margin-left:0;text-align:justify;">两路合并排序运行结果：</p> 
<p style="margin-left:0;text-align:center;"><img alt="" height="519" src="https://images2.imgbox.com/9f/59/ARBycvXv_o.png" width="993"></p> 
<p style="margin-left:0;text-align:justify;"></p> 
<ol><li style="text-align:justify;">快速排序</li></ol> 
<p style="margin-left:0;text-align:justify;">while (1)</p> 
<p style="margin-left:0;text-align:justify;">    {<!-- --></p> 
<p style="margin-left:0;text-align:justify;">        //lo从左往右遍历，直至找到一个不小于 pivot 的元素</p> 
<p style="margin-left:0;text-align:justify;">        while (arr[lo] &lt; pivot) {<!-- --></p> 
<p style="margin-left:0;text-align:justify;">            lo++;</p> 
<p style="margin-left:0;text-align:justify;">};</p> 
<p style="margin-left:0;text-align:justify;">        //hi从右往左遍历，直至找到一个不大于 pivot 的元素</p> 
<p style="margin-left:0;text-align:justify;">        while (hi &gt; 0 &amp;&amp; arr[hi] &gt; pivot) {<!-- --></p> 
<p style="margin-left:0;text-align:justify;">            hi--;</p> 
<p style="margin-left:0;text-align:justify;">        }</p> 
<p style="margin-left:0;text-align:justify;">//如果 lo≥hi，退出循环</p> 
<p style="margin-left:0;text-align:justify;">        if (lo &gt;= hi)</p> 
<p style="margin-left:0;text-align:justify;">{<!-- --></p> 
<p style="margin-left:0;text-align:justify;">break;</p> 
<p>}</p> 
<p style="margin-left:0;text-align:justify;">else {<!-- --></p> 
<p style="margin-left:0;text-align:justify;">            //交换 arr[lo] 和 arr[hi] 的值</p> 
<p style="margin-left:0;text-align:justify;">            temp = arr[lo];</p> 
<p style="margin-left:0;text-align:justify;">            arr[lo] = arr[hi];</p> 
<p style="margin-left:0;text-align:justify;">   arr[hi] = temp;</p> 
<p style="margin-left:0;text-align:justify;">            // lo 和 hi 都向前移动一个位置，准备继续遍历</p> 
<p style="margin-left:0;text-align:justify;">            lo++;</p> 
<p style="margin-left:0;text-align:justify;">            hi--;</p> 
<p style="margin-left:0;text-align:justify;">        }</p> 
<p style="margin-left:0;text-align:justify;">    }</p> 
<p style="margin-left:0;text-align:justify;">    //交换 arr[lo] 和 arr[q] 的值</p> 
<p style="margin-left:0;text-align:justify;">    temp = arr[lo];</p> 
<p style="margin-left:0;text-align:justify;">    arr[lo] = pivot;</p> 
<p style="margin-left:0;text-align:justify;">    arr[q] = temp;</p> 
<p style="margin-left:0;text-align:justify;">    //返回中间值所在序列中的位置</p> 
<p style="margin-left:0;text-align:justify;">    return lo;</p> 
<p style="margin-left:0;text-align:justify;"></p> 
<p style="margin-left:0;text-align:justify;">快速排序运行结果：</p> 
<p><img alt="" height="519" src="https://images2.imgbox.com/16/75/GrjGjOKP_o.png" width="993"></p> 
<p style="margin-left:0;text-align:justify;"><strong><span style="color:#000000;">四、实验小结</span></strong><span style="color:#000000;">（包括问题和解决方法</span><span style="color:#000000;">、心得体会、意见与</span><span style="color:#000000;">建议等）</span></p> 
<p style="margin-left:0;text-align:justify;"><span style="color:#000000;">(</span><span style="color:#000000;">一)实验中遇到的主要问题及解决方法</span></p> 
<p style="margin-left:0;text-align:justify;">两路合并排序：</p> 
<p style="margin-left:0;text-align:justify;">在排序时，将较小的数放在前面时，记得每次执行成功要让对应的指针后移一位。</p> 
<p style="margin-left:0;text-align:justify;">快速排序：</p> 
<p style="margin-left:0;text-align:justify;">交换枢纽元素与j元素：为什么不与i交换？</p> 
<p style="margin-left:0;text-align:justify;">i停下时，i元素总是大于或等于枢纽元素，j停下时，j元素总是小于或等于枢纽元素。与i还是j交换关键看枢纽元素的位置，这里是选第一个元素作为枢纽元素，由于此次排序完成后第一个元素的值应该小于或等于枢纽元素，所以要找一个小于或等于枢纽元素的元素放到start位置，也就是j所指向的元素。</p> 
<p style="margin-left:0;text-align:justify;">代码中j出现了越界的情况，原因是如果pivot是最小的，则j会一直减到小于0，出现了越界的情况，或者pivot最大，i会越界。于是修改代码，在while循环中，增加判断。最后发现在递归调用中出现了Left大于Right的情况。还是考虑pivot是最小值或最大值的情况，此时i和j同时指向了数组最后一个或第一个元素，i==j，于是跳出for循环。接着递归，此时就出现情况了。试想若i和j都指向第一个元素，则i-1出现了越界，若都指向了最后一个元素，则i+1出现了越界，这样程序就在这个地方出现问题了，解决方法是在前面加上Left&lt;Right的判断，这样就解决了越界的问题。</p> 
<p style="margin-left:0;text-align:justify;"><span style="color:#000000;">（二）实验心得</span></p> 
<p style="margin-left:0;text-align:justify;"><span style="color:#000000;">通过实验，不仅使白己更进一-步了解分治法的基本特点，同时也锻炼了白己的逻辑思维。</span></p> 
<p style="margin-left:0;text-align:justify;"><span style="color:#000000;">本实验还算可以，但是一些细节问题还有待解决，比较对二维指针数组的定义和删除还不是很</span></p> 
<p style="margin-left:0;text-align:justify;"><span style="color:#000000;">熟练，在以后会加强这方面的知识积累。</span></p> 
<p style="margin-left:0;text-align:justify;"><span style="color:#000000;">这一次的上机实操让我意识到，算法与软件编程之间有着千丝万缕的联系，使我对学习算法有了新的认知，这次上机实操不仅锻炼了我的思维方式，让我明白对待问题要多方面考虑，同时也让我意识到了对于算法和C、C++等编程语言掌握的不足，在这之后还要花更多的时间去练习学习。</span></p> 
<p style="margin-left:0;text-align:justify;"><span style="color:#000000;">（三）意见与建议</span></p> 
<p><span style="color:#000000;">无</span> </p> 
<p style="margin-left:0;text-align:justify;"></p> 
<p></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/669d39b646e8796e67355347091b83b2/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">mysql中autocommit，start transaction和begin/commit的异同</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/12b9da8a324a66f1f8afa1cc23fc1988/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">NextCloud 最新官方源代码安装包及客户端下载</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>