<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Java面试题大全~基础题(55题) - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Java面试题大全~基础题(55题)" />
<meta property="og:description" content="最近一段时间在准备面试，所以就整理了一下技术栈。在整理的过程中也能够沉淀一下学过的知识。本篇是Java面试题中的基础篇。总共55题，2万多字，以问答的形式呈现，这样也能更好的模拟面试的环节。本文的答案部分有图有代码，这样解释会更加详细和易懂。 1：final, finally, finalize 的区别是什么？ final 用于修饰属性,方法和类, 分别表示属性不能被重新赋值, 方法不可被覆盖, 类不可被继承。
finally 是异常处理语句结构的一部分，一般以 try-catch-finally 出现， finally代码块表示总是被执行。
finalize 是 Object 类的一个方法， 该方法一般由垃圾回收器来调用， 当我们调用 System.gc() 方法的时候， 由垃圾回收器调用finalize()方法，回收垃圾，JVM并不保证此方法总被调用。
2：equals 与==的有什么区别？ ==
==符号在八种基本类型的作用是比较对应基本类型的数值是否相等==符号在对象类型的作用是比较两个对象是否相等 需要注意几种特例：
在包装类型比较的时候，如果初始化的时候使用字面量进行初始化需要注意包装类对象是否是从缓存中获取，如果是缓存中获取则需注意==的结果在String中使用==的时候也需要注意，字符串是否在常量池中已经创建，是否有拼接的情况。具体可以参考我的这篇文章 equals
在Object中 equals 用来比较对象是否相等在其他对象中需要查看是否重写equals方法，以此判断equals方法的具体逻辑，比如String类重写了equals方法用来判断字符串的值是否相等 3：说一说Object中有哪些方法以及这些方法的功能？ registerNatives()：用户注册Object中native相关的方法（native 方法）getClass(): 返回对象的运行时类的引用，可以获取对象所属的具体类信息（native 方法）hashCode(): 返回对象的哈希码值，用于在哈希表等数据结构中快速定位对象。需要与equals()方法一起重写，以保证相等的对象具有相等的哈希码（native 方法）equals(Object obj): 用于比较两个对象是否相等。默认实现比较对象的内存地址，可以被子类重写以定义自定义的相等逻辑clone(): 创建并返回对象的副本。需要实现Cloneable接口才能调用此方法，否则会抛出CloneNotSupportedException异常（native 方法）toString(): 返回对象的字符串表示形式，常用于调试和日志记录。默认实现返回类名和对象的哈希码notify(): 唤醒等待在该对象上的一个线程。用于线程间的通信（native 方法）notifyAll(): 唤醒等待在该对象上的所有线程。用于线程间的通信（native 方法）wait(long timeout): 在对象上等待一段指定的时间，直到其他线程调用notify()或notifyAll()方法唤醒它，或者超时时间到达（native 方法）finalize(): 在对象被垃圾回收之前调用，用于执行对象的清理操作。已废弃，不推荐使用，应使用try-finally或try-with-resources来代替 4：两个对象的 hashCode()相同，则 equals()是否也一定为 true吗？ 如果两个对象的 hashCode()相同，则 equals()不一定为 true，两个对象equals 相等，则它们的hashcode 必须相等，
hashCode 的常规协定：
1： 在 Java 应用程序执行期间，在对同一对象多次调用 hashCode 方法时， 必须 一 致地返回相同的整数，前提是将对象进行 equals 比较时所用的信息没有被修改。 从某一应用程序的一次执行到同一应用程序的另一次执行， 该整数无需保持一致。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/dd87e13c60587a538a4b3eabe531061c/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-08-22T17:45:46+08:00" />
<meta property="article:modified_time" content="2023-08-22T17:45:46+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Java面试题大全~基础题(55题)</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <h6>        最近一段时间在准备面试，所以就整理了一下技术栈。在整理的过程中也能够沉淀一下学过的知识。本篇是Java面试题中的基础篇。总共55题，2万多字，以问答的形式呈现，这样也能更好的模拟面试的环节。本文的答案部分有图有代码，这样解释会更加详细和易懂。</h6> 
<p></p> 
<h2>1：final, finally, finalize 的区别是什么？</h2> 
<p><strong>final</strong> 用于修饰属性,方法和类, 分别表示属性不能被重新赋值, 方法不可被覆盖, 类不可被继承。</p> 
<p><strong>finally</strong> 是异常处理语句结构的一部分，一般以 try-catch-finally 出现， finally代码块表示总是被执行。</p> 
<p><strong>finalize</strong> 是 Object 类的一个方法， 该方法一般由垃圾回收器来调用， 当我们调用 System.gc() 方法的时候， 由垃圾回收器调用finalize()方法，回收垃圾，JVM并不保证此方法总被调用。</p> 
<p></p> 
<h3 id="2%EF%BC%9Aequals%20%E4%B8%8E%3D%3D%E7%9A%84%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F">2：equals 与==的有什么区别？</h3> 
<p>==</p> 
<ul><li>==符号在八种基本类型的作用是比较对应基本类型的数值是否相等</li><li>==符号在对象类型的作用是比较两个对象是否相等</li></ul> 
<p>需要注意几种特例：</p> 
<ul><li>在包装类型比较的时候，如果初始化的时候使用字面量进行初始化需要注意包装类对象是否是从缓存中获取，如果是缓存中获取则需注意==的结果</li><li>在String中使用==的时候也需要注意，字符串是否在常量池中已经创建，是否有拼接的情况。具体可以参考我的这篇<a class="link-info" href="https://blog.csdn.net/qq_31351071/article/details/129915866" title="文章">文章</a></li></ul> 
<p>equals</p> 
<ul><li>在Object中 equals 用来比较对象是否相等</li><li>在其他对象中需要查看是否重写equals方法，以此判断equals方法的具体逻辑，比如String类重写了equals方法用来判断字符串的值是否相等</li></ul> 
<p></p> 
<h3 id="%E8%AF%B4%E4%B8%80%E8%AF%B4Object%E4%B8%AD%E6%9C%89%E5%93%AA%E4%BA%9B%E6%96%B9%E6%B3%95%E4%BB%A5%E5%8F%8A%E8%BF%99%E4%BA%9B%E6%96%B9%E6%B3%95%E7%9A%84%E5%8A%9F%E8%83%BD%EF%BC%9F">3：说一说Object中有哪些方法以及这些方法的功能？</h3> 
<ul><li>registerNatives()：用户注册Object中native相关的方法（native 方法）</li><li>getClass(): 返回对象的运行时类的引用，可以获取对象所属的具体类信息（native 方法）</li><li>hashCode(): 返回对象的哈希码值，用于在哈希表等数据结构中快速定位对象。需要与equals()方法一起重写，以保证相等的对象具有相等的哈希码（native 方法）</li><li>equals(Object obj): 用于比较两个对象是否相等。默认实现比较对象的内存地址，可以被子类重写以定义自定义的相等逻辑</li><li>clone(): 创建并返回对象的副本。需要实现Cloneable接口才能调用此方法，否则会抛出CloneNotSupportedException异常（native 方法）</li><li>toString(): 返回对象的字符串表示形式，常用于调试和日志记录。默认实现返回类名和对象的哈希码</li><li>notify(): 唤醒等待在该对象上的一个线程。用于线程间的通信（native 方法）</li><li>notifyAll(): 唤醒等待在该对象上的所有线程。用于线程间的通信（native 方法）</li><li>wait(long timeout): 在对象上等待一段指定的时间，直到其他线程调用notify()或notifyAll()方法唤醒它，或者超时时间到达（native 方法）</li><li>finalize(): 在对象被垃圾回收之前调用，用于执行对象的清理操作。已废弃，不推荐使用，应使用try-finally或try-with-resources来代替</li></ul> 
<p></p> 
<h3 id="%E4%B8%A4%E4%B8%AA%E5%AF%B9%E8%B1%A1%E7%9A%84%20hashCode()%E7%9B%B8%E5%90%8C%EF%BC%8C%E5%88%99%20equals()%E6%98%AF%E5%90%A6%E4%B9%9F%E4%B8%80%E5%AE%9A%E4%B8%BA%20true%E5%90%97%EF%BC%9F">4：两个对象的 hashCode()相同，则 equals()是否也一定为 true吗？</h3> 
<p>        如果两个对象的 hashCode()相同，则 equals()不一定为 true，两个对象equals 相等，则它们的hashcode 必须相等，</p> 
<p>hashCode 的常规协定：</p> 
<p>1： 在 Java 应用程序执行期间，在对同一对象多次调用 hashCode 方法时， 必须 一 致地返回相同的整数，前提是将对象进行 equals 比较时所用的信息没有被修改。 从某一应用程序的一次执行到同一应用程序的另一次执行， 该整数无需保持一致。</p> 
<p>2：两个对象的equals()相等， 那么对这两个对象中的每个对象调用 hashCode 方法 都必须生成相同的整数结果。</p> 
<p>3：两个对象的equals()不相等， 那么对这两个对象中的任一对象上调用 hashCode 方法不要求一定生成不同的整数结果。但是，为不相等的对象生成不同整数结果可以提高哈希表的性能</p> 
<p></p> 
<h3 id="String%EF%BC%8CStringbuffer%EF%BC%8CStringBuilder%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F">5：String，Stringbuffer，StringBuilder有什么区别？</h3> 
<p><strong>String</strong>：是一个final修饰的不可变的类，一旦创建就不可以修改，并且不能被继承，String 实现了 equals()方法和 hashCode()方法。</p> 
<p><strong>Stringbuffer</strong>：继承自AbstractStringBuilder ，是可变类。StringBuffer内部的方法都是同步方法，是线程安全的。</p> 
<p><strong>StringBuilder</strong>：继承自AbstractStringBuilder ，是可变类。StringBuilder是非线程安全的，执行效率比 StringBuffer 高。</p> 
<h3></h3> 
<h3 id="%E4%B8%BA%E4%BB%80%E4%B9%88String%E4%B8%8D%E6%98%AF%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B%E4%B8%AD%E7%9A%84%E4%B8%80%E7%A7%8D%EF%BC%9F">6：为什么String不是基本类型中的一种？</h3> 
<p><strong>不可变性</strong>：String对象是不可变的，一旦创建就不能修改它的值。这与基本数据类型的可变性不同，基本数据类型的值可以随时被改变</p> 
<p><strong>方法和属性</strong>：String类提供了许多方法和属性，用于操作和处理字符串，如length()、charAt()、substring()等。这些方法和属性是对象特有的，基本数据类型没有这些操作和处理能力</p> 
<p><strong>继承关系</strong>：基本数据类型之间没有继承关系，而String类是Object类的子类，继承了Object类的方法和属性。这也是String类可以使用通用的方法，如equals()、hashCode()、toString()等的原</p> 
<p><strong>存储方式</strong>：基本数据类型的值直接存储在栈（Stack）中，而String对象存储在堆（Heap）中，并通过引用来访问</p> 
<p></p> 
<h3 id="String%20%E7%B1%BB%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%8D%E8%83%BD%E8%A2%AB%E7%BB%A7%E6%89%BF%EF%BC%9F">7：String 类为什么不能被继承？</h3> 
<p>根本原因：是String类被final类型修饰，导致无法被子类继承。这么做的原因如下：</p> 
<p><strong>不可变性</strong>：String类的设计目的是表示不可变的字符序列，即一旦创建了一个String对象，它的值就不能被修改。这种不可变性确保了字符串对象在多线程环境下的安全性和线程安全性。如果允许继承String类并修改其行为，就可能破坏字符串的不可变性特性</p> 
<p><strong>安全性</strong>：String类在Java中被广泛使用，如果它可以被继承并修改其行为，可能会引入一些安全隐患。例如，String类的某些方法用于处理敏感信息（如密码），如果允许继承并重写这些方法，就有可能破坏安全性</p> 
<p><strong>性能优化</strong>：由于String类的不可变性，它可以被缓存和重用，从而提高性能。如果允许继承String类并修改其值，那么缓存和重用的优化策略将会受到影响，可能会导致性能下降</p> 
<p></p> 
<h3 id="%E4%B8%BA%E4%BB%80%E4%B9%88%E8%AF%B4String%E6%98%AF%E4%B8%8D%E5%8F%AF%E5%8F%98%E7%9A%84%EF%BC%9F">8：为什么说String是不可变的？</h3> 
<p>根本原因：是String类中存储字符串的对象被修饰为private final 类型，这么做的原因如下：</p> 
<pre><code class="language-java">private final char value[];</code></pre> 
<p><strong>字符串常量池</strong>：在Java中，字符串常量池是一块特殊的内存区域，用于存储字符串常量。当创建一个字符串常量时，如果字符串常量池中已经存在相同内容的字符串，则返回该字符串的引用，而不会创建新的对象。这样可以节省内存空间并提高性能 </p> 
<p><strong>线程安全性</strong>：由于字符串是不可变的，多个线程可以同时访问和共享同一个字符串对象，而无需担心并发修改导致的数据不一致性或线程安全问题。这使得String对象在多线程环境下是安全的</p> 
<p><strong>不可修改性</strong>：一旦创建了String对象，其值就不能被修改。如果对字符串进行修改操作，比如连接、替换字符等，实际上是创建一个新的字符串对象，原始的字符串对象保持不变。这是因为String类中的方法都是基于不可变性设计的，它们返回的是一个新的字符串对象，而不会改变原始对象的值</p> 
<p></p> 
<h3 id="%E5%A6%82%E4%BD%95%E5%B0%86%20GB2312%20%E7%BC%96%E7%A0%81%E7%9A%84%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%BD%AC%E6%8D%A2%E4%B8%BA%20ISO-8859-1%20%E7%BC%96%20%E7%A0%81%E7%9A%84%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%91%A2%EF%BC%9F">9：如何将 GB2312 编码的字符串转换为 ISO-8859-1 编 码的字符串呢？</h3> 
<pre><code class="language-java">String str = "明天会更好";
String strIso = new String(str.getBytes("GB2312"), "ISO-8859-1");
System.out.println(strIso);</code></pre> 
<p></p> 
<h3 id="String%20str%20%3D%20%22abc%22%E5%92%8CString%20newStr%20%3D%20new%20String%20(%22abc%22)%E5%85%B1%E5%90%8C%E5%88%9B%E5%BB%BA%E4%BA%86%E5%87%A0%E4%B8%AA%E5%AF%B9%E8%B1%A1%EF%BC%9F">10：String str = "abc"和String newStr = new String ("abc")共同创建了几个对象？</h3> 
<p><strong>String str = "abc"情况</strong>：</p> 
<p>        如果在常量池中没有"abc"，则会在常量池中创建一个字符串常量对象"abc"，如果常量池中已经存在，则不会创建新的对象</p> 
<p><strong>String newStr = new String ("abc")情况</strong>：</p> 
<p>        如果在常量池中没有"abc"，则会在常量池中创建一个字符串常量对象"abc"，如果常量池中已经存在，则不会创建新的字符串常量对象。但不管常量池中是否存在"abc"。都会创建一个newStr的字符串对象。所以一般会问该表达式创建了几个对象，如果常量池中没有，则会创建两个对象。如果常量池已经存在，则只会创建一个对象。</p> 
<p></p> 
<h3 id="String%20%E7%B1%BB%E7%9A%84%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95%E9%83%BD%E6%9C%89%E9%82%A3%E4%BA%9B%EF%BC%9F">11：String 类的常用方法都有那些？</h3> 
<ul><li>indexOf()：返回指定字符的索引。</li><li>charAt()：返回指定索引处的字符。</li><li>replace()：字符串替换。</li><li>trim()：去除字符串两端空白。</li><li>split()：分割字符串，返回一个分割后的字符串数组。</li><li>getBytes()：返回字符串的 byte 类型数组。</li><li>length()：返回字符串长度。</li><li>toLowerCase()：将字符串转成小写字母。</li><li>toUpperCase()：将字符串转成大写字符。</li><li>substring()：截取字符串。</li><li>equals()：字符串比较。</li></ul> 
<p></p> 
<h3 id="%E5%A6%82%E4%BD%95%E5%B0%86%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%BF%9B%E8%A1%8C%E5%8F%8D%E8%BD%AC%EF%BC%9F">12：如何将字符串进行反转？</h3> 
<p>第一种方式：使用StringBuilder或StringBuffer的reverse()方法</p> 
<pre><code class="language-java">String str = "Hello, World!";
StringBuilder reversed = new StringBuilder(str).reverse();
String reversedStr = reversed.toString();
System.out.println(reversedStr);
</code></pre> 
<p>第二种方式：使用递归函数</p> 
<pre><code class="language-java">public static String reverseString(String str) {
    if (str.isEmpty()) {
        return str;
    }
    return reverseString(str.substring(1)) + str.charAt(0);
}

String str = "Hello, World!";
String reversedStr = reverseString(str);
System.out.println(reversedStr);
</code></pre> 
<p>第三中方式：使用字符数组</p> 
<pre><code class="language-java">public static String reverseString(String str) {
    char[] charArray = str.toCharArray();
    int start = 0;
    int end = charArray.length - 1;
    while (start &lt; end) {
        char temp = charArray[start];
        charArray[start] = charArray[end];
        charArray[end] = temp;
        start++;
        end--;
    }
    return new String(charArray);
}

String str = "Hello, World!";
String reversedStr = reverseString(str);
System.out.println(reversedStr);
</code></pre> 
<p></p> 
<h3 id="String%E5%AF%B9%E8%B1%A1%E4%B8%AD%E7%9A%84replace%E5%92%8CreplaceAll%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F">13：String对象中的replace和replaceAll有什么区别？</h3> 
<p>replace方法：支持字符和字符串的替换replace(char oldChar, char newChar)</p> 
<p>replaceAll方法：基于正则表达式的字符串替换replaceAll(String regex, String replacement)</p> 
<p></p> 
<h3 id="Java%E4%B8%AD%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F">14：Java中基本数据类型有哪些？</h3> 
<ul><li>byte：1个字节，用于表示整数值</li><li>short：2个字节，用于表示较小范围的整数值</li><li>int：4个字节，用于表示整数值</li><li>long：8个字节，用于表示较大范围的整数值</li><li>float：4个字节，用于表示单精度浮点数值</li><li>double：8个字节，用于表示双精度浮点数值</li><li>boolean：用于表示布尔值具体占用字节依据JVM厂商，只有两个取值：true和false</li><li>char：2个字节，用于表示单个字符</li></ul> 
<p></p> 
<h3 id="char%20%E5%9E%8B%E5%8F%98%E9%87%8F%E4%B8%AD%E8%83%BD%E4%B8%8D%E8%83%BD%E5%AD%98%E8%B4%AE%E4%B8%80%E4%B8%AA%E4%B8%AD%E6%96%87%E6%B1%89%E5%AD%97%EF%BC%9F">15：char 型变量中能不能存贮一个中文汉字？</h3> 
<p>        在 Java 中，char 类型占 2 个字节，而且 Java 默认采用 Unicode 编码，一个Unicode 码是 16 位，所以一个 Unicode 码占两个字节，Java 中无论汉子还是英文字母都是用 Unicode 编码来表示的。所以在Java中char类型变量可以存储一个中文汉字。</p> 
<p></p> 
<h3 id="%E9%87%8D%E8%BD%BD%E5%92%8C%E9%87%8D%E5%86%99%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F">16：重载和重写有什么区别？</h3> 
<p><strong>重载</strong>：指的是在同一个类中定义多个方法，它们具有相同的名称但具有不同的参数列表。重载是编译时多态，方法在编译时根据传入的参数类型和数量来确定调用哪个方法。重载方法可以有不同的返回类型，但不能仅仅依靠返回类型的不同来进行重载。重载方法主要用于提供多个具有相似功能但参数不同的方法，以增加代码的灵活性和可读性。</p> 
<p><strong>重写</strong>：指的是子类重新定义了父类继承的方法，使得子类可以提供自己的实现。重写方法具有相同的名称、参数列表和返回类型。重写是运行时多态，在运行时根据对象的实际类型来确定调用哪个方法。重写方法必须具有相同或更宽松的访问权限，不能具有比父类方法更严格的访问权限。</p> 
<p></p> 
<h3 id="%E6%8A%BD%E8%B1%A1%E7%B1%BB%E5%92%8C%E6%8E%A5%E5%8F%A3%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F">17：抽象类和接口有什么区别？</h3> 
<p><strong>抽象类</strong>：通过使用关键字abstract来定义，可以包含抽象方法和具体方法，可以有实例变量和构造方法用于创建对象和初始化实例变量，一个类只能继承一个抽象类，使用关键字extends，抽象类用于表示一种类型的基本概念，可以包含共享的状态和行为</p> 
<p><strong>接口</strong>：通过使用关键字interface来定义，只能包含抽象方法和常量，不能包含实例变量和构造方法，一个类可以实现多个接口，使用关键字implements，接口不能有构造方法，因为接口不能被实例化，接口可以包含默认方法（ jdk1.8之后 default方法），提供具体的实现，实现接口的类可以直接继承这些默认方法，也可以选择性地覆盖它们，接口用于定义一组行为，表示一种能力或者契约</p> 
<p></p> 
<h3 id="%E8%AF%B4%E8%AF%B4%20Java%20%E4%B8%AD%E5%A4%9A%E6%80%81%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F">18：说说 Java 中多态的实现原理是什么？</h3> 
<p>        Java多态机制包括静态多态 ( 编译时多态 )和动态多态 ( 运行时多态 )，静态多态比如说重载， 动态多态比如说重写，一般指在运行时才能确定调用哪个方法。通常说的多态是指动态多态。</p> 
<p>多态的实现原理主要依赖于以下两个核心概念：</p> 
<p><strong>继承</strong>：子类可以继承父类的属性和方法。当一个类继承另一个类时，子类将拥有父类的所有公共属性和方法，包括方法的签名（方法名称、参数列表和返回类型）。这使得子类可以覆盖（重写）父类的方法，并给出自己的实现。</p> 
<p><strong>方法重写</strong>：子类可以在继承的基础上对父类的方法进行重写。方法重写是指子类提供了与父类方法签名相同的方法，并且可以在子类中重新实现该方法。重写的方法可以提供新的实现，覆盖父类中的方法。在运行时，通过基类或接口类型引用子类对象时，将根据实际对象的类型来调用方法，而不是根据引用类型</p> 
<p></p> 
<h3 id="Java%E4%B8%AD%E4%BB%80%E4%B9%88%E6%98%AF%E6%B3%9B%E5%9E%8B%EF%BC%9F">19：Java中什么是泛型？</h3> 
<p>        是 JDK 1.5 中引入的一个新特性，其本质是参数化类型，解决不确定具体对象类型的问题。其所操作的数据类型被指定为一个参数（type parameter）这种参数类型可以用在类、接口和方法的创建中，分别称为泛型类、泛型接口、泛型方法。</p> 
<p>使用泛型的好处包括：</p> 
<p><strong>类型安全</strong>：泛型允许我们在编译时指定操作的数据类型，并进行类型检查。这减少了在运行时进行类型转换时出错的可能性，并提供了更强的类型安全性。</p> 
<p><strong>代码重用</strong>：泛型可以增加代码的可重用性。我们可以编写通用的泛型类或泛型方法，用于处理不同类型的数据，而无需为每种类型编写重复的代码。</p> 
<p><strong>避免强制类型转换</strong>：使用泛型可以避免在代码中频繁进行强制类型转换。泛型可以自动进行类型推断和类型转换，使代码更简洁和易读。</p> 
<p><strong>提高性能</strong>：由于泛型在编译时进行类型检查，而不是在运行时进行类型转换，可以提高程序的性能。</p> 
<p></p> 
<h3 id="Java%E4%B8%AD%E4%BB%80%E4%B9%88%E6%98%AF%E5%8F%8D%E5%B0%84%EF%BC%9F">20：Java中什么是反射？</h3> 
<p>        是指在运行状态中，对于任意一个类都能够知道这个类所有的属性和方法； 并且对于任意一个对象，都能够调用它的任意一个方法；这种动态获取信息以及动态调用对象方法的功能称为Java语言的反射机制。可以查看这篇<a class="link-info" href="https://juejin.cn/post/6844904025607897096" rel="nofollow" title="文章">文章</a></p> 
<p></p> 
<h3 id="Java%E4%B8%AD%E5%A6%82%E4%BD%95%E5%88%9B%E5%BB%BAClass%E5%AF%B9%E8%B1%A1%EF%BC%9F">21：Java中如何创建Class对象？</h3> 
<p>1：使用 Class.forName 静态方法</p> 
<pre><code class="language-java">Class class1 = Class.forName("xxx.xxx.TestReflection");</code></pre> 
<p>2：使用类的.class 方法</p> 
<pre><code class="language-java">Class class2 = TestReflection.class;</code></pre> 
<p>3：实例对象的 getClass() 方法</p> 
<pre><code class="language-java">TestReflection testReflection = new TestReflection();
Class class3 = testReflection.getClass();</code></pre> 
<p></p> 
<h3 id="%E5%88%9B%E5%BB%BA%E5%8F%8D%E5%B0%84%E5%AF%B9%E8%B1%A1%E7%9A%84%E6%96%B9%E5%BC%8F%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F">22：创建反射对象的方式有哪些？</h3> 
<p>1：通过Class对象获取</p> 
<pre><code class="language-java">Class class1 = Class.forName("reflection.Student");
Student student = (Student) class1.newInstance();</code></pre> 
<p>2：通过类对象获取</p> 
<pre><code class="language-java">Constructor constructor = class1.getConstructor();
Student student1 = (Student) constructor.newInstance();</code></pre> 
<p></p> 
<h3 id="%E5%8F%8D%E5%B0%84%E5%8F%AF%E4%BB%A5%E8%8E%B7%E5%8F%96%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%93%AA%E4%BA%9B%E4%BF%A1%E6%81%AF%EF%BC%9F">23：反射可以获取对象的哪些信息？</h3> 
<p>获取构造器：</p> 
<p><img alt="" height="511" src="https://images2.imgbox.com/6b/50/vFzO7Jxj_o.png" width="1012"></p> 
<p> 获取成员变量：<img alt="" height="515" src="https://images2.imgbox.com/3a/9d/H2zBUbgg_o.png" width="1005"></p> 
<p>获取方法：</p> 
<p><img alt="" height="482" src="https://images2.imgbox.com/84/08/3otoCp3H_o.png" width="1071"></p> 
<p></p> 
<h3 id="%E5%8F%8D%E5%B0%84%E6%9C%89%E5%93%AA%E4%BA%9B%E7%BC%BA%E9%99%B7%EF%BC%9F">24：反射有哪些缺陷？</h3> 
<p><strong>性能问题</strong>：java反射的性能并不好，原因主要是编译器没法对反射相关的代码做优化</p> 
<p><strong>安全问题</strong>：我们知道单例模式的设计过程中，会强调将构造器设计为私有，因为这样可以防止从外部构造对象。但是反射可以获取类中的域、方法、构造器，修改访问权限。所以这样并不一定是安全的</p> 
<p></p> 
<h3 id="%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%9A%84%E4%B8%89%E5%A4%A7%E7%89%B9%E5%BE%81%E6%98%AF%E5%93%AA%E4%BA%9B%EF%BC%9F">25：面向对象的三大特征是哪些？</h3> 
<p><strong>封装</strong>（Encapsulation）：封装是指将数据和对数据的操作封装在一个单元内，通过对外提供公共接口来控制对数据的访问。封装将数据和行为捆绑在一起，隐藏了对象的内部细节，只暴露必要的接口供外部使用。通过封装，可以实现数据的安全性、保护数据的完整性，并且简化了对数据的操作</p> 
<p><strong>继承</strong>（Inheritance）：继承是指通过一个类（称为子类或派生类）继承另一个类（称为父类或基类）的属性和方法。子类可以直接访问父类中的非私有成员，并且可以扩展和修改父类的行为。继承实现了代码的重用性和层次化的组织结构，可以减少代码的冗余，提高代码的可维护性和可扩展性</p> 
<p><strong>多态</strong>（Polymorphism）：多态是指同一个方法名可以在不同的对象上产生不同的行为。多态通过继承和方法重写实现，允许一个对象在不同的上下文中以不同的方式被使用。多态性可以提高代码的灵活性和可扩展性，允许以统一的方式操作不同类型的对象。多态包括编译时多态（静态多态）和运行时多态（动态多态）两种形式</p> 
<p></p> 
<h3 id="%E5%AE%88%E6%8A%A4%E7%BA%BF%E7%A8%8B%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%8C%E7%94%A8%E4%BB%80%E4%B9%88%E6%96%B9%E6%B3%95%E5%AE%9E%E7%8E%B0%E5%AE%88%E6%8A%A4%E7%BA%BF%E7%A8%8B%3F">26：守护线程是什么，用什么方法实现守护线程?</h3> 
<p>        守护线程（Daemon Thread）是在后台运行的线程，它的存在并不会阻止程序的终止。当所有的非守护线程结束时，守护线程会自动终止。守护线程通常用于执行一些后台任务或提供一些支持性的服务。例如，垃圾回收器（Garbage Collector）就是一个守护线程，它在程序运行时负责回收无用的对象</p> 
<p>可以通过设置线程对象的setDaemon(true)将线程设置为守护线程。</p> 
<p></p> 
<h3 id="JDK%20%E5%92%8C%20JRE%20%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F">27：JDK 和 JRE 有什么区别？</h3> 
<p>JDK：Java Development Kit 的简称，Java 开发工具包，提供了 Java 的开发环 境和运行环境</p> 
<p>JRE：Java Runtime Environment 的简称，Java 运行环境，为 Java 的运行提 供了所需环境</p> 
<p></p> 
<h3 id="%E6%B7%B1%E6%8B%B7%E8%B4%9D%E5%92%8C%E6%B5%85%E6%8B%B7%E8%B4%9D%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F">28：深拷贝和浅拷贝有什么区别？</h3> 
<p><strong>浅拷贝</strong>：复制了对象的引用地址，两个对象指向同一个内存地址，所以修改其中任意的值，另一个值都会随之变化</p> 
<p><img alt="" height="517" src="https://images2.imgbox.com/df/a6/LYH4Lbaj_o.png" width="1000"></p> 
<p><strong>深拷贝</strong>：将对象及值复制过来，两个对象修改其中任意的值另一个值不会改变</p> 
<p><img alt="" height="498" src="https://images2.imgbox.com/d5/92/lgSzBy4x_o.png" width="1039">总结：Java中的Cloneable接口提供了一种浅拷贝的方式，但如果需要实现深拷贝，我们需要在对象中重写clone()方法，并在其中对引用类型的属性进行深拷贝。需要注意的是，使用clone()方法进行深拷贝要求被拷贝的对象及其所有引用类型的属性都实现Cloneable接口。</p> 
<p></p> 
<h3 id="Java%E4%B8%AD%E6%98%AF%E5%80%BC%E4%BC%A0%E9%80%92%E8%BF%98%E6%98%AF%E5%BC%95%E7%94%A8%E4%BC%A0%E9%80%92%EF%BC%9F">29：Java中是值传递还是引用传递？</h3> 
<p>在Java中，参数传递是按值传递（Pass-by-Value）进行的。</p> 
<p>        无论是基本数据类型还是对象类型，实际参数的值都会被复制一份传递给方法中的形式参数。对于基本数据类型，传递的是值本身；对于对象类型，传递的是对象的引用（地址）。</p> 
<p>        当将一个基本数据类型作为参数传递给方法时，方法中对形式参数的修改不会影响到原始值，因为基本数据类型的值存储在栈内存中，每次传递都是将值复制一份。</p> 
<p>        当将一个对象作为参数传递给方法时，方法中对形式参数的修改会影响到原始对象，因为传递的是对象的引用（地址），指向的是同一个对象。</p> 
<p>        虽然在对象类型中传递的是对象的引用，看起来类似引用传递，但实际上仍然是值传递。这是因为对于对象的引用，传递的是引用的副本，而不是引用本身。对形式参数的修改只会影响到引用副本所指向的对象，但不会改变原始引用的指向。</p> 
<p>总结：Java中的参数传递是值传递的，无论是基本数据类型还是对象类型。这种值传递的方式使得方法中对参数的修改不会影响到原始值（对于基本数据类型）或原始对象的引用（对于对象类型）。</p> 
<p></p> 
<h3 id="%E6%9E%84%E9%80%A0%E5%99%A8%E6%98%AF%E5%90%A6%E5%8F%AF%E8%A2%AB%E9%87%8D%E5%86%99%EF%BC%9F">30：构造器是否可被重写？</h3> 
<p>        构造器不能被重写，因为构造器是不能被继承的，因为每个类的类名都不相同，而构造器名称与类名相同，所以谈不上继承。 又由于构造器不能被继承，所以相应的就不能被重写了。但是构造器可以被重载。</p> 
<p></p> 
<h3 id="Java%E4%B8%AD%E4%BB%80%E4%B9%88%E6%98%AF%E5%BA%8F%E5%88%97%E5%8C%96%2F%E5%8F%8D%E5%BA%8F%E5%88%97%EF%BC%9F">31：Java中什么是序列化/反序列？</h3> 
<p><strong>序列化</strong>（Serialization）是指将对象转换为字节序列的过程，以便将其存储到文件、传输到网络或在内存中保存。</p> 
<p><strong>反序列化</strong>（Deserialization）则是将字节序列重新转换为对象的过程，恢复对象的状态和数据。</p> 
<p>        Java提供了内置的序列化机制，可以通过实现java.io.Serializable接口来标记一个类可序列化。要进行序列化，可以使用ObjectOutputStream类将对象写入输出流；要进行反序列化，可以使用ObjectInputStream类从输入流中读取字节序列并还原为对象。</p> 
<p></p> 
<h3 id="java8%E7%9A%84%E6%96%B0%E7%89%B9%E6%80%A7%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F">32：java8的新特性有哪些？</h3> 
<ul><li>Lambda表达式：Lambda 允许把函数作为一个方法的参数</li><li>Stream API ：新添加的 Stream API（java.util.stream） 把真正的函数式编程 风格引入到 Java中</li><li>方法引用：方法引用提供了非常有用的语法，可以直接引用已有 Java 类或对象 （实例）的方法或构造器</li><li>默认方法：默认方法就是一个在接口里面有了一个实现的方法</li><li>Optional 类 ：Optional 类已经成为 Java 8 类库的一部分，用来解决空指针异常</li><li>Date Time API ：加强对日期与时间的处理</li></ul> 
<p></p> 
<h3 id="break%20%E5%92%8C%20continue%20%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F">33：break 和 continue 有什么区别？</h3> 
<p><strong>break：</strong>可以使流程跳出 switch 语句体，也可以在循环结构终止本层循环体，从而提前结束本层循环。</p> 
<p><strong>continue</strong>：的作用是跳过本次循环体中余下尚未执行的语句，立即进行下一次的循环条件判定，可以理解为仅结束本次循环。</p> 
<p></p> 
<h3 id="%E7%AE%80%E8%BF%B0%E4%B8%80%E4%B8%8B%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%85%AD%E5%A4%A7%E5%8E%9F%E5%88%99%EF%BC%9F">34：简述一下面向对象的六大原则？</h3> 
<p><strong>单一职责原则</strong>（Single Responsibility Principle，SRP）：一个类应该只有一个引起它变化的原因。换句话说，一个类应该只有一个职责，这样可以使类更加聚焦，降低耦合性，并提高代码的可维护性</p> 
<p><strong>开放封闭原则</strong>（Open-Closed Principle，OCP）：软件实体（类、模块、函数等）应该对扩展开放，对修改关闭。意思是当需求发生变化时，应该通过扩展现有代码来适应新的需求，而不是修改已有的代码。这样可以保持代码的稳定性和可维护性</p> 
<p><strong>里氏替换原则</strong>（Liskov Substitution Principle，LSP）：子类对象可以替换父类对象，而程序的行为不受影响。子类应该能够完全替代父类，并且在任何使用父类的地方都不会引起错误或异常</p> 
<p><strong>接口隔离原则</strong>（Interface Segregation Principle，ISP）：应该为客户端提供尽可能小、精确的接口，而不应该提供大而全的接口。避免客户端依赖它们不需要的接口，这样可以降低耦合性，并提高系统的灵活性和可维护性</p> 
<p><strong>依赖倒置原则</strong>（Dependency Inversion Principle，DIP）：高层模块不应该依赖于低层模块，它们都应该依赖于抽象。抽象不应该依赖于具体实现，而具体实现应该依赖于抽象。这样可以降低模块之间的直接依赖关系，提高代码的可扩展性和可维护性</p> 
<p><strong>迪米特法则</strong>（Law of Demeter，LoD）：一个对象应该尽量少地与其他对象发生相互作用。一个对象应该只与其直接的朋友进行通信，而不应该暴露太多的内部细节给外部。这样可以降低对象之间的耦合性，提高系统的可维护性和灵活性</p> 
<p></p> 
<h3 id="switch%E6%94%AF%E6%8C%81%E7%9A%84%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F">35：switch支持的数据类型有哪些？</h3> 
<p>byte、short、char 、int、String（String 需要Java 7 及更高版本）</p> 
<p></p> 
<h3 id="Java%E8%AE%BF%E9%97%AE%E4%BF%AE%E9%A5%B0%E7%AC%A6%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F">36：Java访问修饰符有哪些？</h3> 
<p><strong>public</strong>：最高级别的访问修饰符，表示对所有类可见。可以在任何地方访问该成员</p> 
<p><strong>protected</strong>：表示该成员对同一包内的类和该类的子类可见。在不同包内的子类中，可以通过继承关系来访问该成员</p> 
<p><strong>default</strong>（默认修饰符）：如果没有明确指定访问修饰符，则使用默认修饰符。在同一包内的类可以访问该成员，但在不同包内的类无法访问</p> 
<p><strong>private</strong>：最低级别的访问修饰符，表示该成员仅对所在类可见。无法在其他类中直接访问</p> 
<p></p> 
<h3 id="Comparator%E5%92%8CComparable%E6%9C%89%E4%BB%80%E4%B9%88%E4%B8%8D%E5%90%8C%EF%BC%9F">37：Comparator和Comparable有什么不同？</h3> 
<p><strong>Comparable</strong>：是java.lang包下的一个类，是在对象自身类中实现的，通过实现Comparable接口，重写compareTo()，对象定义了自己的比较规则。该接口比较规则是"自然排序"，即对象在集合中的排序顺序由对象的内在属性决定。适用于需要对对象进行自然排序的情况，例如使用Collections.sort()进行排序</p> 
<p><strong>Comparator</strong>：是在java.util包下的一个类，是一个独立的比较器，可以在对象外部单独定义比较规则，通过实现Comparator类，重写compare()方法，定义的比较规则是"定制排序"，即可以根据自定义的比较规则对对象进行排序，不依赖于对象的内在属性。适用于需要根据不同的比较规则进行排序的情况，可以在不修改对象类的情况下定义多个不同的比较器，并灵活地选择使用不同的比较器进行排序</p> 
<p>总结：Comparable接口是在对象自身类中实现的，用于定义对象的自然排序规则，适用于对象自身的比较。Comparator接口是独立的比较器，用于定义不同的比较规则，适用于对不同对象的比较和排序。使用Comparable接口可以使对象具备自然排序的能力，而使用Comparator接口可以根据不同的比较规则灵活地进行对象排序</p> 
<p></p> 
<h3 id="Unsafe%E7%B1%BB%E6%9C%89%E5%93%AA%E4%BA%9B%E5%8A%9F%E8%83%BD%EF%BC%9F">38：Unsafe类有哪些功能？</h3> 
<p><strong>内存操作</strong>：Unsafe类提供了直接操作内存的方法，如allocateMemory()用于分配内存、copyMemory()用于内存复制、putXXX()和getXXX()方法用于读写原始数据类型等</p> 
<p><strong>并发操作</strong>：Unsafe类提供了一些方法用于执行并发操作，如park()和unpark()用于线程的阻塞和解除阻塞、compareAndSwapXXX()用于原子性地更新变量值等</p> 
<p><strong>对象操作</strong>：Unsafe类提供了一些方法来直接操作对象，如objectFieldOffset()用于获取对象中某个字段的偏移量、getInt()和putInt()用于读写对象的字段值等</p> 
<p><strong>数组操作</strong>：Unsafe类提供了一些方法来直接操作数组，如arrayBaseOffset()用于获取数组第一个元素的偏移量、arrayIndexScale()用于获取数组中元素的大小、getInt()和putInt()用于读写数组元素的值等</p> 
<p><strong>类操作</strong>：Unsafe类提供了一些方法来操作类的加载和实例化，如allocateInstance()用于实例化一个类的对象、defineClass()用于定义类等</p> 
<p></p> 
<h3 id="%E7%B1%BB%E5%AE%9E%E4%BE%8B%E5%8C%96%E9%A1%BA%E5%BA%8F%E6%98%AF%E4%BB%80%E4%B9%88%E6%A0%B7%E7%9A%84%EF%BC%9F">39：类实例化顺序是什么样的？</h3> 
<p>        父类静态代码块/静态域-&gt;子类静态代码块/静态域 -&gt; 父类非静态代码块 -&gt; 父类构造器 -&gt; 子类非静态代码块 -&gt; 子类构造器</p> 
<p></p> 
<h3 id="Java%E4%B8%AD%E5%88%9B%E5%BB%BA%E5%AF%B9%E8%B1%A1%E7%9A%84%E6%96%B9%E5%BC%8F%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F">40：Java中创建对象的方式有哪些？</h3> 
<p><strong>关键字new</strong>：通过使用关键字new来创建对象，调用类的构造函数初始化对象 </p> 
<pre><code class="language-java">MyClass obj = new MyClass();</code></pre> 
<p><strong>反射</strong>（Reflection）：通过反射机制创建对象，可以在运行时动态地创建对象实例。需要使用Class类和Constructor类来实现 </p> 
<pre><code class="language-java">Class&lt;?&gt; clazz = MyClass.class; 
Constructor&lt;?&gt; constructor = clazz.getConstructor(); 
MyClass obj = (MyClass) constructor.newInstance();</code></pre> 
<p><strong>Unsafe类</strong>：提供了一种使用底层操作直接创建对象的机制，但需要注意的是，Unsafe类属于JDK内部类，它的使用并不推荐，因为直接使用它可能导致不安全和不稳定的代码</p> 
<pre><code class="language-java">// 获取Unsafe实例
Field field = Unsafe.class.getDeclaredField("theUnsafe");
field.setAccessible(true);
Unsafe unsafe = (Unsafe) field.get(null);
// 获取对象的Class对象
Class&lt;?&gt; clazz = MyClass.class;
// 创建对象实例
MyClass obj = (MyClass) unsafe.allocateInstance(clazz);
// 调用对象的方法
obj.sayHello();</code></pre> 
<p><strong>克隆（Clone</strong>）：如果一个类实现了Cloneable接口，就可以通过调用clone()方法创建对象的副本</p> 
<pre><code class="language-java">MyClass obj = new MyClass(); 
MyClass cloneObj = (MyClass) obj.clone();</code></pre> 
<p><strong>对象反序列化</strong>（Object Deserialization）：如果一个对象被序列化到文件或网络流中，可以通过反序列化操作将其还原成对象</p> 
<pre><code class="language-java">FileInputStream fileIn = new FileInputStream("object.ser");
ObjectInputStream in = new ObjectInputStream(fileIn); 
MyClass obj = (MyClass) in.readObject();</code></pre> 
<p></p> 
<h3 id="Java%E4%B8%AD%E4%BB%80%E4%B9%88%E6%98%AF%E5%86%85%E9%83%A8%E7%B1%BB%EF%BC%9F">41：Java中什么是内部类？</h3> 
<p>        在Java中，可以将一个类的定义放在另外一个类的内部，这就是内部类。内部类本身就是类的一个属性，与其他属性定义方式一致。</p> 
<p></p> 
<h3 id="%E5%86%85%E9%83%A8%E7%B1%BB%E6%9C%89%E5%93%AA%E4%BA%9B%E5%88%86%E7%B1%BB%EF%BC%9F">42：内部类有哪些分类？</h3> 
<p><strong>静态内部类</strong>：定义在类内部的静态类，就是静态内部类。静态内部类可以访问外部类所有的静态变量，而不可访问外部类的非静态变量；静态内部类的创建方式：new 外部类.静态内部类()</p> 
<pre><code class="language-java">public class Outer {

    private static int radius = 1;

    static class StaticInner {
        public void visit() {
            System.out.println("visit outer static  variable:" + radius);
        }
    }
}</code></pre> 
<p><strong>成员内部类</strong>：定义在类内部，成员位置上的非静态类，就是成员内部类。成员内部类可以访问外部类所有的变量和方法，包括静态和非静态，私有和公有。成员内部类依赖于外部类的实例，它的创建方式：外部类实例.new 内部类()</p> 
<pre><code class="language-java">public class Outer {

    private static  int radius = 1;
    private int count =2;
    
     class Inner {
        public void visit() {
            System.out.println("visit outer static  variable:" + radius);
            System.out.println("visit outer   variable:" + count);
        }
    }
}</code></pre> 
<p><strong>局部内部类</strong>：定义在方法中的内部类，就是局部内部类。定义在实例方法中的局部类可以访问外部类的所有变量和方法，定义在静态方法中的局部类只能访问外部类的静态变量和方法。局部内部类的创建方式，在对应方法内：new 内部类()</p> 
<pre><code class="language-java">public class Outer {

    private  int out_a = 1;
    private static int STATIC_b = 2;

    public void testFunctionClass(){
        int inner_c =3;
        class Inner {
            private void fun(){
                System.out.println(out_a);
                System.out.println(STATIC_b);
                System.out.println(inner_c);
            }
        }
        Inner  inner = new Inner();
        inner.fun();
    }
    public static void testStaticFunctionClass(){
        int d =3;
        class Inner {
            private void fun(){
                // System.out.println(out_a); 编译错误，定义在静态方法中的局部类不可以访问外部类的实例变量
                System.out.println(STATIC_b);
                System.out.println(d);
            }
        }
        Inner  inner = new Inner();
        inner.fun();
    }
}</code></pre> 
<p><strong>匿名内部类</strong>：匿名内部类就是没有名字的内部类，日常开发中使用的比较多。除了没有名字，匿名内部类还有以下特点： 匿名内部类必须继承一个抽象类或者实现一个接口。 匿名内部类不能定义任何静态成员和静态方法。 当所在的方法的形参需要被匿名内部类使用时，必须声明为 final。 匿名内部类不能是抽象的，它必须要实现继承的类或者实现的接口的所有抽象方法</p> 
<pre><code class="language-java">public class Outer {

    private void test(final int i) {
        new Service() {
            public void method() {
                for (int j = 0; j &lt; i; j++) {
                    System.out.println("匿名内部类" );
                }
            }
        }.method();
    }
 }
 //匿名内部类必须继承或实现一个已有的接口 
 interface Service{
    void method();
}</code></pre> 
<h3 id="%C2%A0"></h3> 
<h3 id="%C2%A0%E5%86%85%E9%83%A8%E7%B1%BB%E7%9A%84%E4%BC%98%E7%82%B9%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F"> 43：内部类的优点有哪些？</h3> 
<ul><li>一个内部类对象可以访问创建它的外部类对象的内容，包括私有数据</li><li>内部类不为同一包的其他类所见，具有很好的封装性。当内部类使用 private修饰时，这个类就对外隐藏了</li><li>内部类有效实现了“多重继承”，优化 java 单继承的缺陷</li><li>匿名内部类可以很方便的定义回调</li></ul> 
<p></p> 
<h3 id="%E5%8C%BF%E5%90%8D%E5%86%85%E9%83%A8%E7%B1%BB%E5%A6%82%E4%BD%95%E8%AE%BF%E9%97%AE%E5%9C%A8%E5%85%B6%E5%A4%96%E9%9D%A2%E5%AE%9A%E4%B9%89%E7%9A%84%E5%8F%98%E9%87%8F%E5%91%A2%EF%BC%9F">44：匿名内部类如何访问在其外面定义的变量呢？</h3> 
<p>        外部变量必须是 final 或者实质上是 final 的。这意味着变量要么被声明为 final，要么在匿名内部类中没有被重新赋值。原因是匿名内部类可以访问外部变量的值，但是不能修改外部变量的值。因为匿名内部类实例的生命周期可能超过外部方法的生命周期，所以在匿名内部类中修改外部变量的值可能会导致不可预测的结果</p> 
<p></p> 
<h3 id="%E4%BB%80%E4%B9%88%E6%98%AF%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6%EF%BC%9F">45：什么是类加载机制？</h3> 
<p>        类的加载（Class Loading）是指将类的字节码文件（.class文件）加载到内存中，并在内存中创建对应的类对象的过程。类的加载是Java虚拟机（JVM）执行的重要步骤之一，它是Java的核心特性之一，实现了Java的动态性和灵活性</p> 
<p></p> 
<h3 id="%E7%B1%BB%E5%8A%A0%E8%BD%BD%E7%9A%84%E6%AD%A5%E9%AA%A4%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F">46：类加载的步骤有哪些？</h3> 
<p><img alt="" height="440" src="https://images2.imgbox.com/bb/b0/VVNvO0kI_o.png" width="1173"></p> 
<p><strong>类加载的第一阶段：加载</strong></p> 
<p>        查找并加载类的字节码文件。字节码文件可以从本地文件系统、网络或其他来源获取。加载的过程包括查找类文件、读取类文件的二进制数据，并将其转换为内部数据结构。在加载阶段，虚拟机需要完成以下三件事情：</p> 
<p>1：通过一个类的全限定名来获取其定义的二进制字节流。</p> 
<p>2：将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构。</p> 
<p>3：在Java堆中生成一个代表这个类的 java.lang.Class对象，作为对方法区中这些数据的访问入口。</p> 
<p>        相对于类加载的其他阶段而言，加载阶段（准确地说，是加载阶段获取类的二进制字节流的动作）是可控性最强的阶段，因为开发人员既可以使用系统提供的类加载器来完成加载，也可以自定义自己的类加载器来完成加载。</p> 
<p><strong>类加载的第二阶段：连接</strong></p> 
<p>其中连接分为三步：</p> 
<p>验证（连接阶段的第一步）</p> 
<p>        这一阶段的目的是为了确保Class文件的字节流中包含的信息符合当前虚拟机的要求，并且不  会危害虚拟机自身的安全。验证阶段大致会完成4个阶段的检验动作：</p> 
<p>1：文件格式验证：*验证字节流是否符合Class文件格式的规范；*例如：是否以 0xCAFEBABE开头、主次版本号是否在当前虚拟机的处理范围之内、常量池中的常量是否有不被支持的类型。</p> 
<p>2：元数据验证：对字节码描述的信息进行语义分析（注意：对比javac编译阶段的语义分析），以保证其描述的信息符合Java语言规范的要求；例如：这个类是否有父类，除了 java.lang.Object之外。</p> 
<p>3：字节码验证：通过数据流和控制流分析，确定程序语义是合法的、符合逻辑的。</p> 
<p>4：符号引用验证：确保解析动作能正确执行</p> 
<p>准备（连接阶段的第二步）<br>         准备阶段是正式为类变量分配内存并设置类变量初始值的阶段，这些内存都将在方法区中分配。对于该阶段有以下几点需要注意：</p> 
<p>1：这时候进行内存分配的仅包括类变量（static），而不包括实例变量，实例变量会在对象实例化时随着对象一块分配在Java堆中。</p> 
<p>2：这里所设置的初始值通常情况下是数据类型默认的零值（如0、0L、null、false等），而不是被在Java代码中被显式地赋予的值。</p> 
<p>3：如果类字段的字段属性表中存在 ConstantValue属性，即同时被final和static修饰，那么在准备阶段变量value就会被初始化为ConstValue属性所指定的值。</p> 
<p>解析（连接阶段的第三步）<br>          解析阶段是虚拟机将常量池内的符号引用替换为直接引用的过程，解析动作主要针对类或接口、字段、类方法、接口方法、方法类型、方法句柄和调用点限定符这7类符号引用进行。符号引用就是一组符号来描述目标，可以是任何字面量。直接引用就是直接指向目标的指针、相对偏移量或一个间接定位到目标的句柄。</p> 
<p><strong>类加载的第三阶段：初始化</strong><br>          为类的静态变量赋予正确的初始值，主要对类变量进行初始化。在Java中对类变量进行初始值设定有两种方式：</p> 
<p>1：声明类变量是指定初始值</p> 
<p>2：使用静态代码块为类变量指定初始值</p> 
<p>JVM初始化步骤</p> 
<p>1、假如这个类还没有被加载和连接，则程序先加载并连接该类</p> 
<p>2、假如该类的直接父类还没有被初始化，则先初始化其直接父类</p> 
<p>3、假如类中有初始化语句，则系统依次执行这些初始化语句</p> 
<p>类初始化时机：只有当对类的主动使用的时候才会导致类的初始化，类的主动使用包括以下六种： 1：创建类的实例，也就是new的方式</p> 
<p>2：访问某个类或接口的静态变量，或者对该静态变量赋值</p> 
<p>3：调用类的静态方法</p> 
<p>4：反射（如 Class.forName(“com.shengsiyuan.Test”)）</p> 
<p>5：初始化某个类的子类，则其父类也会被初始化</p> 
<p>6：Java虚拟机启动时被标明为启动类的类（ JavaTest），直接使用 java.exe命令来运行某个主类</p> 
<p></p> 
<h3 id="%E4%BB%80%E4%B9%88%E6%98%AF%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8%EF%BC%9F">47：什么是类加载器？</h3> 
<p>        类加载器是负责将可能是网络上、也可能是磁盘上的class文件加载到内存中。并为其生成对应的java.lang.class对象。一旦一个类被载入JVM了，同一个类就不会被再次加载。那么怎样才算是同一个类？在JAVA中一个类用其全限定类名（包名和类名）作为其唯一标识，但是在JVM中，一个类用其全限定类名和其类加载器作为其唯一标识。也就是说，在JAVA中的同一个类，如果用不同的类加载器加载，则生成的class对象认为是不同的。</p> 
<p></p> 
<h3 id="%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8%E7%9A%84%E7%A7%8D%E7%B1%BB%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F">48：类加载器的种类有哪些？</h3> 
<p><img alt="" height="474" src="https://images2.imgbox.com/76/97/lLxDLXro_o.png" width="1091"></p> 
<p><strong>启动类加载器（</strong>BootstrapClassLoader<strong>）</strong>：是嵌在JVM内核中的加载器，该加载器是用C++语言写的，主要负载加载JAVA_HOME/lib下的类库，启动类加载器无法被应用程序直接使用</p> 
<p><strong>扩展类加载器（</strong>Extension ClassLoader<strong>）</strong>：该加载器器是用JAVA编写，且它的父类加载器是Bootstrap，是由sun.misc.Launcher$ExtClassLoader实现的，主要加载JAVA_HOME/lib/ext目录中的类库。开发者可以这几使用扩展类加载器</p> 
<p><strong>系统类加载器（</strong>App ClassLoader<strong>）</strong>：系统类加载器，也称为应用程序类加载器，负责加载应用程序classpath目录下的所有jar和class文件。它的父加载器为Ext ClassLoader</p> 
<p>总结：类加载器的体系并不是“继承”体系，而是委派体系，大多数类加载器首先会到自己的parent中查找类或者资源，如果找不到才会到自己本地查找。类加载器的委托行为动机是为了避免相同的类被加载多次。</p> 
<p></p> 
<h3 id="%E4%BB%80%E4%B9%88%E6%98%AF%E5%8F%8C%E4%BA%B2%E5%A7%94%E6%B4%BE%E6%A8%A1%E5%9E%8B%EF%BC%9F">49：什么是双亲委派模型？</h3> 
<p>        如果一个类加载器收到了一个类加载请求，它不会自己去尝试加载这个类，而是把这个请求转交给父类加载器去完成。每一个层次的类加载器都是如此。因此所有的类加载请求都应该传递到最顶层的启动类加载器中，只有到父类加载器反馈自己无法完成这个加载请求（在它的搜索范围没有找到这个类）时，子类加载器才会尝试自己去加载。委派的好处就是避免有些类被重复加载。</p> 
<p>优点：</p> 
<p><strong>避免类的重复加载</strong>：Java类随着它的类加载器一起具备了一种带有优先级的层次关系，通过这种层级关可以避免类的重复加载，当父亲已经加载了该类时，就没有必要子ClassLoader再加载一次</p> 
<p><strong>安全因素</strong>：java核心api中定义类型不会被随意替换，假设通过网络传递一个名为java.lang.Integer的类，通过双亲委托模式传递到启动类加载器，而启动类加载器在核心Java API发现这个名字的类，发现该类已被加载，并不会重新加载网络传递的过来的java.lang.Integer，而直接返回已加载过的Integer.class，这样便可以防止核心API库被随意篡改。</p> 
<p></p> 
<h3 id="%E5%A6%82%E4%BD%95%E6%89%93%E7%A0%B4%E5%8F%8C%E4%BA%B2%E5%A7%94%E6%B4%BE%E6%9C%BA%E5%88%B6%EF%BC%9F">50：如何打破双亲委派机制？</h3> 
<p><strong>自定义类加载器</strong>：可以通过自定义类加载器来加载类。自定义类加载器可以继承自ClassLoader类，并重写其中的加载类的方法，如findClass()方法。在自定义类加载器中，可以根据自己的需求来定义类加载逻辑，不受双亲委派机制的限制</p> 
<p><strong>破坏父类加载器委派机制</strong>：在默认的双亲委派机制中，父类加载器会先尝试加载类，只有在找不到类的情况下才会由子类加载器尝试加载。我们可以通过破坏父类加载器的加载顺序来打破双亲委派机制。具体做法是在自定义类加载器中重写loadClass()方法，在加载类之前先判断是否由父类加载器加载，如果不是，再由当前类加载器加载</p> 
<p><strong>使用线程上下文类加载器</strong>：Java中有一个特殊的类加载器称为线程上下文类加载器（Thread Context Class Loader），它可以破坏双亲委派机制。线程上下文类加载器可以通过Thread.currentThread().setContextClassLoader()方法设置，它会在类加载时优先使用线程上下文类加载器加载类，而不是采用双亲委派机制</p> 
<p></p> 
<h3 id="Java%E4%B8%AD%E5%AF%B9%E8%B1%A1%E5%88%9B%E5%BB%BA%E8%BF%87%E7%A8%8B%E6%98%AF%E4%BB%80%E4%B9%88%E6%A0%B7%EF%BC%9F">51：Java中对象创建过程是什么样？</h3> 
<p><strong>第一步：类加载检查</strong></p> 
<p>        当遇到new指令之后，首先会去到静态常量池中看看能否找到这个指令所对应的符号引用，然后会检查符号引用所对应的类是否被加载——连接——初始化，如果有的话就进行第二步，如果没有就要先进行类的加载。</p> 
<p><strong>第二步：分配内存</strong></p> 
<p>        当类加载检查通过后，对象的大小在类加载完成之后就可以确定，所以首先会为准备新创建的对象根据对象大小分配内存，这块内存就是在堆中划分。那么如何进行内存的分配呢，一般情况下会有两种情况：“指针碰撞” 和 “空闲列表” 两种，选择那种分配方式由 Java 堆是否规整决定，而 Java 堆是否规整又由所采用的垃圾收集器是否带有压缩整理功能决定。</p> 
<p>指针碰撞：假设Java堆的内存是绝对规整的，所有用过的内存都放一边，空闲的内存放在另一边，中间放着一个指针作为分界点的指示器，那所分配内存就仅仅把那个指针向空闲空间那边挪动一段与对象大小相等的距离。</p> 
<p>空闲列表：如果Java堆中的内存并不是规整的，已使用的内存和空间的内存是相互交错的，虚拟机必须维护一个空闲列表，记录上哪些内存块是可用的，在分配时候从列表中找到一块足够大的空间划分给对象使用。     </p> 
<p>        注意：在分配内存的时候存在并发问题， 在并发情况下划分不一定是线程安全的，有可能出现正在给A对象分配内存，指针还没有来得及修改，对象B又同时使用了原来的指针分配内存的情况，所以解决方法：</p> 
<p>1：CAS+失败重试：通过CAS乐观锁去尝试更新此次操作，如果CAS失败就去重试，直至成功为止。</p> 
<p>2：TLAB：预先在堆内存的Eden区为每一个线程分配一块名为TLAB的预存地址空间，当创建对象的时候就可以使用这块内存，当TLAB空间被占满时，再去采用CAS+失败重试的方法区分配内存。</p> 
<p><strong>第三步：初始化零值</strong></p> 
<p>        之前的类加载过程我们了解到：在准备过程中会将final修饰的静态变量直接赋初值，对static修饰的静态变量赋零值。但是对于普通的成员变量我们不清楚是何时初始化的，那么这个阶段就是给成员变量进行初始化。</p> 
<p>        虚拟机需要将分配到的内存空间中的数据类型都初始化为零值（不包括对象头），这一步操作保证了对象的实例字段在 Java 代码中可以不赋初始值就直接使用，程序能访问到这些字段的数据类型所对应的零值</p> 
<p><strong>第四步：设置对象头</strong></p> 
<p>        初始化零值完成之后，虚拟机要对对象进行必要的设置，例如这个对象是那个类的实例、如何才能找到类的元数据信息、对象的哈希码、对象的 GC 分代年龄等信息。 这些信息存放在对象头中。 另外，根据虚拟机当前运行状态的不同，如是否启用偏向锁等，对象头会有不同的设置方式</p> 
<p><strong>第五步：调用init方法</strong></p> 
<p>        在上面工作都完成之后，从虚拟机的视角来看，一个新的对象已经产生了，但从 Java 程序的视角来看，对象创建才刚开始，方法还没有执行，所有的字段都还为零。所以一般来说，执行 new 指令之后会接着执行方法，把对象按照程序员的意愿进行初始化，这样一个真正可用的对象才算完全产生出来</p> 
<p></p> 
<h3 id="%E4%BB%80%E4%B9%88%E6%98%AF%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%EF%BC%9F">52：什么是动态代理？</h3> 
<p>        动态代理是一种设计模式，它允许在运行时创建一个代理对象，该代理对象可以拦截并重定向对目标对象的方法调用。Java中的动态代理是通过反射机制实现的。动态代理的主要作用是在不修改目标对象的前提下，为其提供额外的功能或行为。它通过在运行时创建代理对象，并将目标对象的方法调用转发给代理对象来实现</p> 
<p></p> 
<h3 id="%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%E7%9A%84%E6%96%B9%E5%BC%8F%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F">53：动态代理的方式有哪些？</h3> 
<p><strong>基于接口的动态代理</strong>：代理对象实现了一个或多个接口，通过java.lang.reflect.Proxy类和java.lang.reflect.InvocationHandler接口实现。代理对象的方法调用会被转发给InvocationHandler对象处理</p> 
<p><strong>基于类的动态代理</strong>：代理对象是目标对象的子类，通过字节码生成库（如CGLIB、Byte Buddy等）动态生成代理类。代理对象继承了目标对象的行为，并可以重写或增加目标对象的方法</p> 
<p></p> 
<h3 id="Java%E4%B8%BA%E4%BB%80%E4%B9%88%E8%83%BD%E8%B7%A8%E5%B9%B3%E5%8F%B0%E8%BF%90%E8%A1%8C%EF%BC%9F">54：Java为什么能跨平台运行？</h3> 
<p><strong> Java虚拟机</strong>：Java程序在运行之前，会首先被编译成一种特殊的字节码（bytecode），而不是直接编译成特定平台的机器码。然后，这些字节码会被Java虚拟机执行。不同的平台上都有各自的Java虚拟机，它们负责将字节码转化为特定平台的机器码进行执行。这种中间层的存在使得Java程序能够在不同的平台上运行，只要有对应平台的Java虚拟机即可</p> 
<p><strong>平台无关的标准库</strong>：Java提供了一个平台无关的标准库（Java API），其中包含了大量的类和方法，可以用于开发各种应用程序。这些标准库中的类都是与具体平台无关的，因此可以在不同的操作系统和硬件上使用相同的代码。这样一来，开发人员可以编写一次Java代码，然后在不同平台上进行编译和运行，而无需针对每个平台进行额外的修改</p> 
<p><strong>严格的语言规范</strong>：Java语言具有严格的语法和规范，使得开发人员编写的Java代码在不同平台上的行为是一致的。这意味着无论在哪个平台上编写和编译Java代码，它们的行为和结果应该是相同的</p> 
<p></p> 
<h3 id="Java%E7%9A%84%E5%AE%89%E5%85%A8%E6%80%A7%E4%BD%93%E7%8E%B0%E5%9C%A8%E5%93%AA%E9%87%8C%EF%BC%9F">55：Java的安全性体现在哪里？</h3> 
<p><strong>字节码验证</strong>：Java程序在运行之前会先被编译成字节码，然后由Java虚拟机执行。在执行之前，Java虚拟机会对字节码进行验证，确保它符合Java语言规范和安全要求。这种验证过程可以防止恶意代码和非法操作的执行</p> 
<p><strong>内存管理</strong>：Java提供自动的内存管理机制，通过垃圾回收器来自动回收不再使用的内存。这减少了内存泄漏和悬挂指针等内存安全问题的风险</p> 
<p><strong>强类型检查</strong>：Java是一种强类型语言，对变量的类型进行严格检查。这种类型检查可以防止类型转换错误和潜在的内存损坏</p> 
<p><strong>数组越界检查</strong>：Java会对数组的访问进行边界检查，防止访问超出数组边界的位置。这可以避免数组越界访问导致的内存错误和安全漏洞</p> 
<p><strong>异常处理</strong>：Java提供了异常处理机制，使得开发人员可以捕获和处理程序中的异常情况。通过合理地处理异常，可以防止程序崩溃和数据损坏，并增强程序的安全性</p> 
<p><strong>安全管理器</strong>：Java提供了安全管理器（Security Manager）的机制，允许开发人员对程序的访问权限进行细粒度的控制。可以通过安全策略文件来配置和限制程序的访问权限，从而保护系统的安全性</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/65c234975549f9abc3d21f15aa76bbfe/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">vue使用indexDB判断数据库是否存在判断表是否存在</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/7b3416c974aa155faef7bc174c41e3cd/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">（嵌入式c语言）指针&#43;修饰符</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>