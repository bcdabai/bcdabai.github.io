<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>HTTP登录和授权 - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="HTTP登录和授权" />
<meta property="og:description" content="HTTP是无状态的协议，它不会记录和保存之前连接的状态。那么它进行登录验证和授予客户端权限的过程是怎样的？我们经常使用微信、QQ等进行第三方的授权登录。又是怎样实现的？本文将通过介绍HTTP登录和授权机制帮助大家理解这些问题。
一、Cookie Cookie在英语里是曲奇、小饼干的意思。它的作用是帮助服务器把用户数据存储在用户的客户端本地。通过它让HTTP无状态工作方式，变成“有状态“的方式。
1.1 Cookie起源 早期的浏览器公司会帮助用户进行网站的开发。当时的购物网站需要实现“购物车“的功能。盛极一时的Netscape（网景）公司的做法，是将购物数据存在客户端的本地，为此开发了一套完整的流程，就是Cookie。因此，Cookie开发出来就是用于实现”购物车“的功能。
后来我们知道，电商购物车功能都改为在服务器端实现。Cookie也失去它最初的作用，但是它完整的实现机制却被保留下来，用于用户登录状态管理、用户偏好管理、用户行为追踪等。
1.2 Cookie工作机制 看一下用Cooke早期用于实现“购物车“功能的工作过程：
1、用户发起请求在购物车增加一个“apple“；服务器收到并处理请求后，返回用户结果，并通过set-Cookie将“apple“加入”购物车“；用户将该Cookie存在用户本地，这里需要同时记录网站的信息和对应Cookie信息，避免访问多个网站发生错乱。
2、用户再次向服务器发起请求，这次将一个“banana“加入购物车。用户同时将当前记录该网站的Cookie同时发送过去；服务器收到请求并处理后，将新的带有一个”apple“和一个”banana“的Cookie通过”set-Coolie”返回给客户端；客户端收到返回后，更新本地的Cookie，即购物车。
3、用户向服务器发起结算请求，同时将本地的Cookie发送过去。服务器收到请求后，进行结算。完成后，服务器更新客户端Cookie，清空购物车。
以上购物车实现的简单流程，就是典型的Cookie工作机制。我们现在用的Cookie机制也是这样工作的。
1.3 Cookie作用 前面说到，Cookie已经失去了它最原始的作用。我们看一下现在Cookie在HTTP网络访问中的作用和实现原理。
1）、登录状态管理
它的原理就是利用Cooke保存登录数据在本地，每次客户端发起请求时，同时发送Cookie数据给服务器，服务器通过检查Cookie数据确认用户登录状态。将HTTP从无状态协议，改为有状态。
客户端向服务器发起登录请求，登录成功后，服务器将登录信息通过Cookie返回客户端，并在客户端保存起来。
客户端再次发起HTTP请求时，带入保存的该网站登录信息的Cookie数据。服务端收到请求后，解读Cookie，确认客户端是已经登录的状态。
2）、追踪用户行为
我们在使用HTTP网络访问，有时会看到类似下面的声明。会告诉我们网站使用Cookies不会进行用户行为追踪，侵犯用户隐私。
Cookie进行用户行为追踪的原理，就是当我们进行网络请求时，可能请求的内容，比如图片，还需要再向第三方网站进行请求。服务器发给我们资源地址时会带有“form=xxx“的信息，表示该请求的来源。这些信息被三方网站获取，就可以掌握用户访问过哪些网页。通过用户网络行为，对用户进行画像。
1.4 Cookie相关攻击 与Cookie有关的网络攻击，主要用XSS和XSRF两种。
XSS
Cross-site scripting的缩写，意思是“跨站脚本攻击“。攻击的原理是javaScrip可以在客户端本地拿到Cookies，并发送到自己的网站，进而盗用用户的身份信息。
针对这种攻击，服务器在发送“set-Cookie“时，对敏感的信息，增加”HttpOnly“修饰。它表示该Cookie只在进行HTTP请求时自动发送，不能被本地javaScrip调用。
它的报文格式：Set-Cookie: client_id=123;HttpOnly
XSRF
Cross-site request forgery的缩写，意思是“跨站请求伪造“。它是在用户不知情的情况下，访问恶意网站，该网站使用用户Cookie向目标服务器发起请求，以此来越权操作用户的账号。
比如，用户登录网银，首先进入恶意网站，恶意网站使用我的Cookie来登录网银。
针对这种攻击，在服务器端增加“Referer”校验。Referer机制，是浏览器每次跳转时会强制加上，用于标记转发的网站。如果直接访问目标网址Referer为空。
服务器端通过只处理没有跳转的（Referer为空）请求，或者来自白名单网站转发的请求，来防范XSRF攻击。
二、Authorization Authorization，即“许可、授权”的意思。它被设计出来就是用于登录鉴权。实际上它比Cookie更适合用于登录状态管理。它有两种主要的Token：Basic和Bearer。Basic用于登录授权，Bearer用于进行第三方登录。
在介绍Authorization之前，先看一个知识点Base64。
2.1 Base64 Base64是一种编码格式，它是将二进制数据转换成由64个字符组成的字符串。这64个字符是a~z、A~Z、0~9、“&#43;”和“\”，共64个字符。
转换的方式，是将原二进制串按照每六个字符进行分割，根据base64码表确定字符。（我们知道计算机字符是按照每八个字符分割）。
Base64码表如下：
看一下，下面的例子，原字符串“Man”，按照Base64重新编码成了”TWFu”。
码表中“=”的作用是当最后不够6个字符时，用来进行补位。
如下，“Ma”的Base64格式“TWE=”。“M”的base64格式是“TQ==”。
了解了Base64编码原理我们知道它是不安全的，因为编码后的数据，可以很容易反编码回去；同时也是低效的，经过Base64编码，原字符串会变得更长，传输的数据体积更大。
Base64的作用就是把普通的二进制数据，全部转为字符串的形式。同时当原数据是字符串时，经过编码可以起到防偷窥的作用。
扩展知识：Base58
Base58是Base64的变种，它在Base64码表的基础上去掉了容易混淆的O （大写的o）、0(零)、I(大写的i)、 l（小写的L），以及“&#43;”和“\”六个字符。它被设计出来用于比特币地址的存储，防止在进行手抄时抄错。
2.2 Basic 使用Basic形式的Token用于登录授权的HTTP报文形式如：
Base64数据是“zhangsan:1234567”。
这种方式会有Base64被破解和Token在本地被窃取风险。
针对Base64破解风险，可采用HTTPS进行数据传输，它会将请求数据全部加密，Base64值同样会被加密，就不会被破解了。
Token在本地被窃取，大多数情况是不需要担心的。Token虽然被保存到本地，手机端的安全机制下，这个数据是不会被其他应用获取的。少数情况，下用户刷机并给恶意三方程序root最高权限，而可以访问任何文件，token才可能被窃取。这种情形相当于用户主动放弃了安全机制，是用户自主行为。
2.3 Bearer 是“持票人”的意思。拿着有权限人给的“票据”，就可以被赋予相应的权限。
报文形式是：Authorization: Bearer &lt;bearer token&gt;" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/039d4030d63ba9c97f7c73e6c30b6560/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-03-04T14:10:07+08:00" />
<meta property="article:modified_time" content="2023-03-04T14:10:07+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">HTTP登录和授权</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p style="margin-left:0;">HTTP是无状态的协议，它不会记录和保存之前连接的状态。那么它进行登录验证和授予客户端权限的过程是怎样的？我们经常使用微信、QQ等进行第三方的授权登录。又是怎样实现的？本文将通过介绍HTTP登录和授权机制帮助大家理解这些问题。</p> 
<ul><li> <h2>一、Cookie</h2> </li></ul> 
<p style="margin-left:0;">Cookie在英语里是曲奇、小饼干的意思。它的作用是帮助服务器把用户数据存储在用户的客户端本地。通过它让HTTP无状态工作方式，变成“有状态“的方式。</p> 
<h4 style="margin-left:0;">1.1 Cookie起源</h4> 
<p style="margin-left:0;">早期的浏览器公司会帮助用户进行网站的开发。当时的购物网站需要实现“购物车“的功能。盛极一时的Netscape（网景）公司的做法，是将购物数据存在客户端的本地，为此开发了一套完整的流程，就是Cookie。因此，Cookie开发出来就是用于实现”购物车“的功能。</p> 
<p style="margin-left:0;">后来我们知道，电商购物车功能都改为在服务器端实现。Cookie也失去它最初的作用，但是它完整的实现机制却被保留下来，用于用户登录状态管理、用户偏好管理、用户行为追踪等。</p> 
<h4 style="margin-left:0;">1.2 Cookie工作机制</h4> 
<p style="margin-left:0;">看一下用Cooke早期用于实现“购物车“功能的工作过程：</p> 
<p style="margin-left:0;">1、用户发起请求在购物车增加一个“apple“；服务器收到并处理请求后，返回用户结果，并通过set-Cookie将“apple“加入”购物车“；用户将该Cookie存在用户本地，这里需要同时记录网站的信息和对应Cookie信息，避免访问多个网站发生错乱。</p> 
<p style="margin-left:0;text-align:center;"></p> 
<p style="margin-left:0;text-align:center;"><img alt="" height="193" src="https://images2.imgbox.com/15/50/hIslrh5J_o.png" width="831"></p> 
<p style="margin-left:0;">2、用户再次向服务器发起请求，这次将一个“banana“加入购物车。用户同时将当前记录该网站的Cookie同时发送过去；服务器收到请求并处理后，将新的带有一个”apple“和一个”banana“的Cookie通过”set-Coolie”返回给客户端；客户端收到返回后，更新本地的Cookie，即购物车。</p> 
<p><img alt="" height="219" src="https://images2.imgbox.com/e2/bd/JEDK2H1q_o.png" width="848">3、用户向服务器发起结算请求，同时将本地的Cookie发送过去。服务器收到请求后，进行结算。完成后，服务器更新客户端Cookie，清空购物车。</p> 
<p style="margin-left:0;text-align:center;"></p> 
<p style="margin-left:0;text-align:center;"><img alt="" height="190" src="https://images2.imgbox.com/11/ae/0vrvyNiV_o.png" width="865"></p> 
<p>以上购物车实现的简单流程，就是典型的Cookie工作机制。我们现在用的Cookie机制也是这样工作的。</p> 
<h4 style="margin-left:0;">1.3 Cookie作用</h4> 
<p style="margin-left:0;">前面说到，Cookie已经失去了它最原始的作用。我们看一下现在Cookie在HTTP网络访问中的作用和实现原理。</p> 
<p style="margin-left:0;"><strong>1）、登录状态管理</strong></p> 
<p style="margin-left:0;">它的原理就是利用Cooke保存登录数据在本地，每次客户端发起请求时，同时发送Cookie数据给服务器，服务器通过检查Cookie数据确认用户登录状态。将HTTP从无状态协议，改为有状态。</p> 
<p style="margin-left:0;">客户端向服务器发起登录请求，登录成功后，服务器将登录信息通过Cookie返回客户端，并在客户端保存起来。</p> 
<p style="margin-left:0;text-align:center;"></p> 
<p style="margin-left:0;text-align:center;"><img alt="" height="168" src="https://images2.imgbox.com/ab/18/0TKECEZD_o.png" width="865"></p> 
<p>客户端再次发起HTTP请求时，带入保存的该网站登录信息的Cookie数据。服务端收到请求后，解读Cookie，确认客户端是已经登录的状态。</p> 
<p style="margin-left:0;text-align:center;"></p> 
<p style="margin-left:0;text-align:center;"><img alt="" height="158" src="https://images2.imgbox.com/81/25/y3L2wtEw_o.png" width="865"></p> 
<p><strong>2）、追踪用户行为</strong></p> 
<p style="margin-left:0;">我们在使用HTTP网络访问，有时会看到类似下面的声明。会告诉我们网站使用Cookies不会进行用户行为追踪，侵犯用户隐私。</p> 
<p style="margin-left:0;text-align:center;"></p> 
<p style="margin-left:0;text-align:center;"><img alt="" height="193" src="https://images2.imgbox.com/80/aa/BQE2B4E5_o.png" width="865"></p> 
<p>Cookie进行用户行为追踪的原理，就是当我们进行网络请求时，可能请求的内容，比如图片，还需要再向第三方网站进行请求。服务器发给我们资源地址时会带有“form=xxx“的信息，表示该请求的来源。这些信息被三方网站获取，就可以掌握用户访问过哪些网页。通过用户网络行为，对用户进行画像。</p> 
<p style="margin-left:0;text-align:center;"></p> 
<p style="margin-left:0;text-align:center;"><img alt="" height="346" src="https://images2.imgbox.com/90/a8/BoJzVg7Z_o.png" width="865"></p> 
<h4 style="margin-left:0;">1.4 Cookie相关攻击</h4> 
<p style="margin-left:0;">与Cookie有关的网络攻击，主要用XSS和XSRF两种。</p> 
<p style="margin-left:0;"><strong>XSS</strong></p> 
<p style="margin-left:0;">Cross-site scripting的缩写，意思是“跨站脚本攻击“。攻击的原理是javaScrip可以在客户端本地拿到Cookies，并发送到自己的网站，进而盗用用户的身份信息。</p> 
<p style="margin-left:0;">针对这种攻击，服务器在发送“set-Cookie“时，对敏感的信息，增加”<strong>HttpOnly</strong>“修饰。它表示该Cookie只在进行HTTP请求时自动发送，不能被本地javaScrip调用。</p> 
<p style="margin-left:0;">它的报文格式：Set-Cookie: client_id=123;HttpOnly</p> 
<p style="margin-left:0;"><strong>XSRF</strong></p> 
<p style="margin-left:0;"><span style="color:#111111;">Cross-site request forgery</span><span style="color:#111111;">的缩写，意思是“跨站请求伪造“。它是在用户不知情的情况下，访问恶意网站，该网站使用用户</span><span style="color:#111111;">Cookie</span><span style="color:#111111;">向目标服务器发起请求，以此来越权操作用户的账号。</span></p> 
<p style="margin-left:0;"><span style="color:#111111;">比如，用户登录网银，首先进入恶意网站，恶意网站使用我的</span><span style="color:#111111;">Cookie</span><span style="color:#111111;">来登录网银。</span></p> 
<p style="margin-left:0;"><span style="color:#111111;">针对这种攻击，在服务器端增加“</span><strong><span style="color:#111111;">Referer</span></strong><span style="color:#111111;">”校验。</span><span style="color:#111111;">Referer</span><span style="color:#111111;">机制，是浏览器每次跳转时会强制加上，用于标记转发的网站。如果直接访问目标网址</span><span style="color:#111111;">Referer</span><span style="color:#111111;">为空。</span></p> 
<p style="margin-left:0;"><span style="color:#111111;">服务器端通过只处理没有跳转的（</span><span style="color:#111111;">Referer</span><span style="color:#111111;">为空）请求，或者来自白名单网站转发的请求，来防范</span><span style="color:#111111;">XSRF</span><span style="color:#111111;">攻击。</span></p> 
<ul><li> <h2>二、Authorization</h2> </li></ul> 
<p style="margin-left:0;">Authorization，即“许可、授权”的意思。它被设计出来就是用于登录鉴权。实际上它比Cookie更适合用于登录状态管理。它有两种主要的Token：Basic和Bearer。Basic用于登录授权，Bearer用于进行第三方登录。</p> 
<p style="margin-left:0;">在介绍Authorization之前，先看一个知识点Base64。</p> 
<h4 style="margin-left:0;">2.1 Base64</h4> 
<p style="margin-left:0;">Base64是一种编码格式，它是将二进制数据转换成由64个字符组成的字符串。这64个字符是a~z、A~Z、0~9、“+”和“\”，共64个字符。</p> 
<p style="margin-left:0;">转换的方式，是将原二进制串按照每六个字符进行分割，根据base64码表确定字符。（我们知道计算机字符是按照每八个字符分割）。</p> 
<p style="margin-left:0;">Base64码表如下：</p> 
<p style="margin-left:0;"><img alt="" height="683" src="https://images2.imgbox.com/f4/22/VGJvcMmy_o.png" width="865"></p> 
<p>看一下，下面的例子，原字符串“Man”，按照Base64重新编码成了”TWFu”。</p> 
<p style="margin-left:0;text-align:center;"></p> 
<p style="margin-left:0;text-align:center;"><img alt="" height="233" src="https://images2.imgbox.com/d0/8d/pQn8p7j8_o.png" width="865"></p> 
<p>码表中“=”的作用是当最后不够6个字符时，用来进行补位。</p> 
<p style="margin-left:0;">如下，“Ma”的Base64格式“TWE=”。“M”的base64格式是“TQ==”。</p> 
<p style="margin-left:0;text-align:center;"></p> 
<p style="margin-left:0;text-align:center;"><img alt="" height="249" src="https://images2.imgbox.com/a1/03/WRHQGEh9_o.png" width="865"></p> 
<p style="margin-left:0;text-align:center;"><img alt="" height="268" src="https://images2.imgbox.com/3f/4c/R26v7mDM_o.png" width="865"></p> 
<p style="margin-left:0;">了解了Base64编码原理我们知道它是<strong>不安全的</strong>，因为编码后的数据，可以很容易反编码回去；同时也是<strong>低效的</strong>，经过Base64编码，原字符串会变得更长，传输的数据体积更大。</p> 
<p style="margin-left:0;">Base64的作用就是把普通的二进制数据，全部转为字符串的形式。同时当原数据是字符串时，经过编码可以起到防偷窥的作用。</p> 
<p style="margin-left:0;"><strong>扩展知识：Base58</strong></p> 
<p style="margin-left:0;">Base58是Base64的变种，它在Base64码表的基础上去掉了容易混淆的O （大写的o）、0(零)、I(大写的i)、 l（小写的L），以及“+”和“\”六个字符。它被设计出来用于比特币地址的存储，防止在进行手抄时抄错。</p> 
<h4 style="margin-left:0;">2.2 Basic</h4> 
<p style="margin-left:0;">使用Basic形式的Token用于登录授权的HTTP报文形式如：</p> 
<p style="margin-left:0;text-align:center;"></p> 
<p style="margin-left:0;text-align:center;"><img alt="" height="95" src="https://images2.imgbox.com/77/14/HvrV0L3a_o.png" width="513"></p> 
<p>Base64数据是“zhangsan:1234567”。</p> 
<p style="margin-left:0;">这种方式会有Base64被破解和Token在本地被窃取风险。</p> 
<p style="margin-left:0;">针对Base64破解风险，可采用HTTPS进行数据传输，它会将请求数据全部加密，Base64值同样会被加密，就不会被破解了。</p> 
<p style="margin-left:0;">Token在本地被窃取，大多数情况是不需要担心的。Token虽然被保存到本地，手机端的安全机制下，这个数据是不会被其他应用获取的。少数情况，下用户刷机并给恶意三方程序root最高权限，而可以访问任何文件，token才可能被窃取。这种情形相当于用户主动放弃了安全机制，是用户自主行为。</p> 
<h4 style="margin-left:0;">2.3 Bearer</h4> 
<p style="margin-left:0;">是“持票人”的意思。拿着有权限人给的“票据”，就可以被赋予相应的权限。</p> 
<p style="margin-left:0;">报文形式是：Authorization: Bearer &lt;bearer token&gt;</p> 
<p style="margin-left:0;">这里的token就是授权发发来的“票据”。现在基本都是通过OAuth2的方式进行获取。后面结合三方登录授权的实现原理，理解Bearer的用法。</p> 
<h3 style="margin-left:0;">三、第三方登录实现原理</h3> 
<h4 style="margin-left:0;">3.1 第三方登录</h4> 
<p style="margin-left:0;">我们可能经常见到类似下图的登录界面，在“其他登录方式”中，可以选择用微信、QQ等知名应用进行授权登录。</p> 
<p style="margin-left:0;">比如选择微信，则跳转到微信界面，在微信界面点击“确认登录”。再次返回到该应用，则完成了登录。</p> 
<p style="margin-left:0;text-align:center;"><img alt="" height="376" src="https://images2.imgbox.com/43/b5/96fI3f3M_o.png" width="219"><strong>   </strong><img alt="" height="372" src="https://images2.imgbox.com/c6/34/noOWeLg4_o.png" width="217"></p> 
<p>这种登录方式就是“第三方登录”。</p> 
<p style="margin-left:0;">它早期是由美国人发明，像使用fecebook进行三方授权对用户来说就会很方便，当时叫做“社交网络登录”。后来这项技术传到中国，改叫“第三方登录”。</p> 
<h4 style="margin-left:0;">3.2 OAuth2授权流程</h4> 
<p style="margin-left:0;">第三方登录是通过OAuth2实现的。下面结合抖音使用微信进行登录的例子，看一下它的整个流程。</p> 
<p style="margin-left:0;">1、在抖音登录界面点击“使用微信登录”后，将跳转到微信界面，并将“client-id”发送给微信。“clent-id”是抖音在开发时，向微信申请的。相当于取得的授权资质。</p> 
<p style="margin-left:0;">2、在微信上根据client-id显示抖音软件的信息。同样这个信息，也是抖音在早期开发时给微信的。</p> 
<p style="margin-left:0;">3、用户在微信界面点击“确认登录”，微信向微信服务器请求“授权码”。然后将“授权码”发给抖音，微信客户端关闭。</p> 
<p style="margin-left:0;">4、抖音拿到“授权码”后，发给抖音服务器。抖音服务器使用“授权码”和“client_secret”向微信服务器申请bearer token。“client_secret”和上面的“client-id”，它是在抖音服务器开发时向微信服务器申请的。并且它是严格保密的信息，服务器与服务器之间的通讯都是采用HTTPS完成。抖音服务器获取到bearer token后，就相当于拥有了”票据”。</p> 
<p style="margin-left:0;">5、抖音服务器使用token向微信服务器请求用户头像、id、昵称等。像微信自己向服务器请求一样。用这些信息帮用户申请账号，然后帮用户进行登录。如果账号已存在则直接进行登录。</p> 
<p style="margin-left:0;">6、服务器端完成登录成功后，将登录状态发回给抖音客户端，进行显示。完成整个三方登录过程。</p> 
<p style="margin-left:0;text-align:center;"></p> 
<p style="margin-left:0;text-align:center;"><img alt="" height="338" src="https://images2.imgbox.com/14/5d/x99D0AWm_o.png" width="592"></p> 
<p>以上就是OAuth2授权的完整流程，也是第三方登录的完整过程。“第三方登录”是一个产品名称，使用的技术是“第三方授权”。</p> 
<h4 style="margin-left:0;">3.3 错误用法</h4> 
<p style="margin-left:0;">在实际的开发中，有一种错误的做法是登录服务器将“token”发给登录客户端，由客户端请求用户信息。</p> 
<p style="margin-left:0;">这样做会因减少交互的流程而减少用户登录时间。但是不建议这样做，因为不安全。攻击者会很容易获得token，造成token的泄漏。</p> 
<p class="img-center"><img alt="" height="250" src="https://images2.imgbox.com/5e/87/vfLmuRJk_o.png" width="398"></p> 
<p style="margin-left:0;text-align:center;"></p> 
<h4 style="margin-left:0;">3.4 Refresh Token</h4> 
<p style="margin-left:0;">下面简单介绍下有关token的操作。重点讲一下Refresh Token。</p> 
<p style="margin-left:0;">有关token的请求命令有四种：</p> 
<p style="margin-left:0;">token_type : 获取token的类型，如bearer、basic；</p> 
<p style="margin-left:0;">access_token: 请求token；</p> 
<p style="margin-left:0;">refresh_token: 刷新token；</p> 
<p style="margin-left:0;">expires_time: 获取token有效时间。</p> 
<p style="margin-left:0;">在很多情况下，为避免token泄漏，token会定期被废掉。三方授权登录后，如果token过期，则会导致登录失效，需要用户重新进行登录。而为了避免因此而打扰用户，通常三方服务器会定时进行Reresh token，在用户无感的情况下，帮用户完成定期登录。这就是Refresh Token的意义。</p> 
<p class="img-center"><img alt="" height="95" src="https://images2.imgbox.com/c0/47/WLW6jXDs_o.png" width="466"></p> 
<p style="margin-left:0;text-align:center;"></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/dbe8b3ba2369754623b552578f3e72fa/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">Java学习——lambda表达式</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/f3efc314524046e045c991941ed8ad87/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">lv1 Linux C语言基础</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>