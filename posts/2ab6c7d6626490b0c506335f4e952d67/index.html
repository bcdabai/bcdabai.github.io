<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>java 对象克隆 - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="java 对象克隆" />
<meta property="og:description" content="为什么需要克隆： 在实际编程过程中，我们常常要遇到这种情况：有一个对象A，在某一时刻A中已经包含了一些有效值，此时可能会需要一个和A完全相同新对象B，并且此后对B任何改动都不会影响到A中的值，也就是说，A与B是两个独立的对象，但B的初始值是由A对象确定的。在Java语言中，用简单的赋值语句是不能满足这种需求的，要满足这种需求有很多途径
克隆的实现方式 2.1. 浅度克隆，使用clone 对于要克隆的对象，对于其基本数据类型的属性，复制一份给新产生的对象，对于非基本数据类型的属性，仅仅复制一份引用给新产生的对象，即新产生的对象和原始对象中的非基本数据类型的属性都指向的是同一个对象。 1、实现java.lang.Cloneable接口 要clone的类为什么还要实现Cloneable接口呢？Cloneable接口是一个标识接口，不包含任何方法的！这个标识仅仅是针对Object类中clone()方法的，如果clone类没有实现Cloneable接口，并调用了Object的 clone()方法（也就是调用了super.Clone()方法），那么Object的clone()方法就会抛出 CloneNotSupportedException异常。 2、重载java.lang.Object.clone()方法 JDK API的说明文档解释这个方法将返回Object对象的一个拷贝。要说明的有两点：一是拷贝对象返回的是一个新对象，而不是一个引用。二是拷贝对象与用new操作符返回的新对象的区别就是这个拷贝已经包含了一些原来对象的信息，而不是对象的初始信息。
观察一下Object类的clone()方法是一个native方法，native方法的效率一般来说都是远高于java中的非native方法。这也解释了为什么要用Object中clone()方法而不是先new一个类，然后把原始对象中的信息赋到新对象中，虽然这也实现了clone功能。Object类中的clone()还是一个protected属性的方法，重载之后要把clone()方法的属性设置为public。
Object类中clone()方法产生的效果是：先在内存中开辟一块和原始对象一样的空间，然后原样拷贝原始对象中的内容。对基本数据类型，这样的操作是没有问题的，但对非基本类型变量，我们知道它们保存的仅仅是对象的引用，这也导致clone后的非基本类型变量和原始对象中相应的变量指向的是同一个对象。
class Teacher { public int age; public String name; public int getAge(){ return age; } public void setAge(int age){ this.age = age; } public String getName(){ return name; } public void setName(String name){ this.name = name; } @Override public String toString() { return &#34;Teacher [age= &#34; &#43; age &#43; &#34; , name= &#34; &#43; name &#43; &#34;" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/2ab6c7d6626490b0c506335f4e952d67/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2016-02-24T21:22:52+08:00" />
<meta property="article:modified_time" content="2016-02-24T21:22:52+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">java 对象克隆</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <ol><li><p>为什么需要克隆： <br> 在实际编程过程中，我们常常要遇到这种情况：有一个对象A，在某一时刻A中已经包含了一些有效值，此时可能会需要一个和A完全相同新对象B，并且此后对B任何改动都不会影响到A中的值，也就是说，A与B是两个独立的对象，但B的初始值是由A对象确定的。在Java语言中，用简单的赋值语句是不能满足这种需求的，要满足这种需求有很多途径</p></li><li><p>克隆的实现方式 <br> 2.1. 浅度克隆，使用clone <br> 对于要克隆的对象，对于其基本数据类型的属性，复制一份给新产生的对象，对于非基本数据类型的属性，仅仅复制一份引用给新产生的对象，即新产生的对象和原始对象中的非基本数据类型的属性都指向的是同一个对象。 <br> 1、实现java.lang.Cloneable接口 <br> 要clone的类为什么还要实现Cloneable接口呢？Cloneable接口是一个标识接口，不包含任何方法的！这个标识仅仅是针对Object类中clone()方法的，如果clone类没有实现Cloneable接口，并调用了Object的 clone()方法（也就是调用了super.Clone()方法），那么Object的clone()方法就会抛出 CloneNotSupportedException异常。 <br> 2、重载java.lang.Object.clone()方法 <br> JDK API的说明文档解释这个方法将返回Object对象的一个拷贝。要说明的有两点：一是拷贝对象返回的是一个新对象，而不是一个引用。二是拷贝对象与用new操作符返回的新对象的区别就是这个拷贝已经包含了一些原来对象的信息，而不是对象的初始信息。</p> <p>观察一下Object类的clone()方法是一个native方法，native方法的效率一般来说都是远高于java中的非native方法。这也解释了为什么要用Object中clone()方法而不是先new一个类，然后把原始对象中的信息赋到新对象中，虽然这也实现了clone功能。Object类中的clone()还是一个protected属性的方法，重载之后要把clone()方法的属性设置为public。</p> <p>Object类中clone()方法产生的效果是：先在内存中开辟一块和原始对象一样的空间，然后原样拷贝原始对象中的内容。对基本数据类型，这样的操作是没有问题的，但对非基本类型变量，我们知道它们保存的仅仅是对象的引用，这也导致clone后的非基本类型变量和原始对象中相应的变量指向的是同一个对象。</p> <pre class="prettyprint"><code class=" hljs cs">class Teacher {
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> age;
    <span class="hljs-keyword">public</span> String name;

    <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getAge</span>(){
        <span class="hljs-keyword">return</span> age;
    }

    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setAge</span>(<span class="hljs-keyword">int</span> age){
        <span class="hljs-keyword">this</span>.age = age;
    }

    <span class="hljs-keyword">public</span> String <span class="hljs-title">getName</span>(){
        <span class="hljs-keyword">return</span> name;
    }

    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setName</span>(String name){
        <span class="hljs-keyword">this</span>.name = name;
    }

    @Override
    <span class="hljs-keyword">public</span> String <span class="hljs-title">toString</span>() {
        <span class="hljs-keyword">return</span> <span class="hljs-string">"Teacher [age= "</span> + age + <span class="hljs-string">" , name= "</span> + name + <span class="hljs-string">"]"</span>;
    }
}

class Student implements Cloneable{
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> age;
    <span class="hljs-keyword">public</span> String name;
    <span class="hljs-keyword">public</span> Teacher teacher;

    <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getAge</span>(){
        <span class="hljs-keyword">return</span> age;
    }

    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setAge</span>(<span class="hljs-keyword">int</span> age){
        <span class="hljs-keyword">this</span>.age = age;
    }

    <span class="hljs-keyword">public</span> String <span class="hljs-title">getName</span>(){
        <span class="hljs-keyword">return</span> name;
    }

    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setName</span>(String name){
        <span class="hljs-keyword">this</span>.name = name;
    }

    <span class="hljs-keyword">public</span> Teacher <span class="hljs-title">getTeacher</span>(){
        <span class="hljs-keyword">return</span> teacher;
    }

    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setTeacher</span>(Teacher teacher){
        <span class="hljs-keyword">this</span>.teacher = teacher;
    }

    @Override
    <span class="hljs-keyword">public</span> Object <span class="hljs-title">clone</span>() throws CloneNotSupportedException {
        <span class="hljs-keyword">return</span> super.clone();
    }

    @Override
    <span class="hljs-keyword">public</span> String <span class="hljs-title">toString</span>() {
        <span class="hljs-keyword">return</span> <span class="hljs-string">"Student [age= "</span> + age + <span class="hljs-string">" , name= "</span> + name + <span class="hljs-string">" , teacher= "</span> + teacher + <span class="hljs-string">"]"</span>;
    }
}

<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> CloneTest{

    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span>(String[] args) throws Exception{
        <span class="hljs-comment">// teacher对象将被clone出来的Student对象共享.</span>
        Teacher teacher = <span class="hljs-keyword">new</span> Teacher();
        teacher.setAge(<span class="hljs-number">40</span>);
        teacher.setName(<span class="hljs-string">"Teacher zhang"</span>);

        Student student1 = <span class="hljs-keyword">new</span> Student();
        student1.setAge(<span class="hljs-number">20</span>);
        student1.setName(<span class="hljs-string">"zhangsan"</span>);
        student1.setTeacher(teacher);

        <span class="hljs-comment">// 复制出来一个对象student2</span>
        Student student2 = (Student) student1.clone();
        System.<span class="hljs-keyword">out</span>.println(student2);

        System.<span class="hljs-keyword">out</span>.println(<span class="hljs-string">"~~~~~~~~~~~~~~~~~~~~~~"</span>);
        System.<span class="hljs-keyword">out</span>.println(student1.getTeacher());

        <span class="hljs-comment">// 修改student2的引用对象</span>
        student2.getTeacher().setAge(<span class="hljs-number">50</span>);
        student2.getTeacher().setName(<span class="hljs-string">"Teacher Li"</span>);

        System.<span class="hljs-keyword">out</span>.println(<span class="hljs-string">"~~~~~~~~~~~~~~~~~~~~~~"</span>);
        System.<span class="hljs-keyword">out</span>.println(student1.getTeacher());
    }
}</code></pre> <p>输出结果为</p> <pre class="prettyprint"><code class=" hljs applescript">Student [age= <span class="hljs-number">20</span> , <span class="hljs-property">name</span>= zhangsan , teacher= Teacher [age= <span class="hljs-number">40</span> , <span class="hljs-property">name</span>= Teacher zhang]]
~~~~~~~~~~~~~~~~~~~~~~
Student [age= <span class="hljs-number">20</span> , <span class="hljs-property">name</span>= zhangsan , teacher= Teacher [age= <span class="hljs-number">40</span> , <span class="hljs-property">name</span>= Teacher zhang]]
~~~~~~~~~~~~~~~~~~~~~~
Student [age= <span class="hljs-number">20</span> , <span class="hljs-property">name</span>= zhangsan , teacher= Teacher [age= <span class="hljs-number">50</span> , <span class="hljs-property">name</span>= Teacher Li]]</code></pre> <p>2.2. 深度克隆，使用clone <br> 在浅度克隆的基础上，对于要克隆的对象中的非基本数据类型的属性对应的类，也实现克隆，这样对于非基本数据类型的属性，复制的不是一份引用，即新产生的对象和原始对象中的非基本数据类型的属性指向的不是同一个对象。</p> <p>要克隆的类和类中所有非基本数据类型的属性对应的类 <br> 1、都实现java.lang.Cloneable接口 <br> 2、都重载java.lang.Object.clone()方法</p> <pre class="prettyprint"><code class=" hljs java">class Teacher implements Cloneable{
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> age;
    <span class="hljs-keyword">public</span> String name;

    <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getAge</span>(){
        <span class="hljs-keyword">return</span> age;
    }

    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setAge</span>(<span class="hljs-keyword">int</span> age){
        <span class="hljs-keyword">this</span>.age = age;
    }

    <span class="hljs-keyword">public</span> String <span class="hljs-title">getName</span>(){
        <span class="hljs-keyword">return</span> name;
    }

    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setName</span>(String name){
        <span class="hljs-keyword">this</span>.name = name;
    }


    <span class="hljs-annotation">@Override</span>
    <span class="hljs-keyword">protected</span> Object <span class="hljs-title">clone</span>() <span class="hljs-keyword">throws</span> CloneNotSupportedException {
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">super</span>.clone();
    }

    <span class="hljs-annotation">@Override</span>
    <span class="hljs-keyword">public</span> String <span class="hljs-title">toString</span>() {
        <span class="hljs-keyword">return</span> <span class="hljs-string">"Teacher [age= "</span> + age + <span class="hljs-string">" , name= "</span> + name + <span class="hljs-string">"]"</span>;
    }
}

class Student implements Cloneable{
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> age;
    <span class="hljs-keyword">public</span> String name;
    <span class="hljs-keyword">public</span> Teacher teacher;

    <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getAge</span>(){
        <span class="hljs-keyword">return</span> age;
    }

    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setAge</span>(<span class="hljs-keyword">int</span> age){
        <span class="hljs-keyword">this</span>.age = age;
    }

    <span class="hljs-keyword">public</span> String <span class="hljs-title">getName</span>(){
        <span class="hljs-keyword">return</span> name;
    }

    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setName</span>(String name){
        <span class="hljs-keyword">this</span>.name = name;
    }

    <span class="hljs-keyword">public</span> Teacher <span class="hljs-title">getTeacher</span>(){
        <span class="hljs-keyword">return</span> teacher;
    }

    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setTeacher</span>(Teacher teacher){
        <span class="hljs-keyword">this</span>.teacher = teacher;
    }

    <span class="hljs-annotation">@Override</span>
    <span class="hljs-keyword">public</span> Object <span class="hljs-title">clone</span>() <span class="hljs-keyword">throws</span> CloneNotSupportedException {
        Student student = (Student) <span class="hljs-keyword">super</span>.clone();  
        <span class="hljs-comment">// 将引用的对象teacher也clone下  </span>
        student.setTeacher((Teacher) (student.getTeacher().clone()));  
        <span class="hljs-keyword">return</span> student;  
    }

    <span class="hljs-annotation">@Override</span>
    <span class="hljs-keyword">public</span> String <span class="hljs-title">toString</span>() {
        <span class="hljs-keyword">return</span> <span class="hljs-string">"Student [age= "</span> + age + <span class="hljs-string">" , name= "</span> + name + <span class="hljs-string">" , teacher= "</span> + teacher + <span class="hljs-string">"]"</span>;
    }
}

<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CloneTest</span>{<!-- --></span>

    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span>(String[] args) <span class="hljs-keyword">throws</span> Exception{
        <span class="hljs-comment">// teacher对象将不被clone出来的Student对象共享.</span>
        Teacher teacher = <span class="hljs-keyword">new</span> Teacher();
        teacher.setAge(<span class="hljs-number">40</span>);
        teacher.setName(<span class="hljs-string">"Teacher zhang"</span>);

        Student student1 = <span class="hljs-keyword">new</span> Student();
        student1.setAge(<span class="hljs-number">20</span>);
        student1.setName(<span class="hljs-string">"zhangsan"</span>);
        student1.setTeacher(teacher);

        <span class="hljs-comment">// 复制出来一个对象student2</span>
        Student student2 = (Student) student1.clone();
        System.out.println(student2);

        System.out.println(<span class="hljs-string">"~~~~~~~~~~~~~~~~~~~~~~"</span>);
        System.out.println(student1);

        <span class="hljs-comment">// 修改student2的引用对象</span>
        student2.getTeacher().setAge(<span class="hljs-number">50</span>);
        student2.getTeacher().setName(<span class="hljs-string">"Teacher Li"</span>);

        System.out.println(<span class="hljs-string">"~~~~~~~~~~~~~~~~~~~~~~"</span>);
        System.out.println(student1);
    }
}</code></pre> <p>输出结果为</p> <pre class="prettyprint"><code class=" hljs applescript">Student [age= <span class="hljs-number">20</span> , <span class="hljs-property">name</span>= zhangsan , teacher= Teacher [age= <span class="hljs-number">40</span> , <span class="hljs-property">name</span>= Teacher zhang]]
~~~~~~~~~~~~~~~~~~~~~~
Student [age= <span class="hljs-number">20</span> , <span class="hljs-property">name</span>= zhangsan , teacher= Teacher [age= <span class="hljs-number">40</span> , <span class="hljs-property">name</span>= Teacher zhang]]
~~~~~~~~~~~~~~~~~~~~~~
Student [age= <span class="hljs-number">20</span> , <span class="hljs-property">name</span>= zhangsan , teacher= Teacher [age= <span class="hljs-number">40</span> , <span class="hljs-property">name</span>= Teacher zhang]]
*/</code></pre> <p>2.3.深度克隆，使用对象序列化和反序列化实现 <br> 所谓对象序列化就是将对象的状态转换成字节流，以后可以通过这些值再生成相同状态的对象。</p> <p>对象的序列化还有另一个容易被大家忽略的功能就是对象复制（Clone），Java中通过Clone机制可以复制大部分的对象，但是众所周知，Clone有深度Clone和浅度Clone，如果你的对象非常非常复杂，并且想实现深层 Clone，如果使用序列化，不会超过10行代码就可以解决。</p> <p>虽然Java的序列化非常简单、强大，但是要用好，还有很多地方需要注意。比如曾经序列化了一个对象，可由于某种原因，该类做了一点点改动，然后重新被编译，那么这时反序列化刚才的对象，将会出现异常。 你可以通过添加serialVersionUID属性来解决这个问题。如果你的类是个单例（Singleton）类，是否允许用户通过序列化机制复制该类，如果不允许你需要谨慎对待该类的实现。</p> <p>先实现一个工具类：</p> <pre class="prettyprint"><code class=" hljs java"><span class="hljs-keyword">import</span> java.io.ByteArrayInputStream;
<span class="hljs-keyword">import</span> java.io.ByteArrayOutputStream;
<span class="hljs-keyword">import</span> java.io.ObjectInputStream;
<span class="hljs-keyword">import</span> java.io.ObjectOutputStream;

<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CloneUtil</span> {<!-- --></span>
    <span class="hljs-keyword">private</span> <span class="hljs-title">CloneUtil</span>() {
        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> AssertionError();
    }

    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> &lt;T&gt; T <span class="hljs-title">clone</span>(T obj) <span class="hljs-keyword">throws</span> Exception {
        <span class="hljs-comment">// 将该对象序列化成流,因为写在流里的是对象的一个拷贝，而原对象仍然存在于JVM里面。所以利用这个特性可以实现对象的深拷贝</span>
        ByteArrayOutputStream bout = <span class="hljs-keyword">new</span> ByteArrayOutputStream();
        ObjectOutputStream oos = <span class="hljs-keyword">new</span> ObjectOutputStream(bout);
        oos.writeObject(obj);

        <span class="hljs-comment">// 将流序列化成对象</span>
        ByteArrayInputStream bin = <span class="hljs-keyword">new</span> ByteArrayInputStream(bout.toByteArray());
        ObjectInputStream ois = <span class="hljs-keyword">new</span> ObjectInputStream(bin);
        <span class="hljs-keyword">return</span> (T) ois.readObject();

        <span class="hljs-comment">// 说明：调用ByteArrayInputStream或ByteArrayOutputStream对象的close方法没有任何意义</span>
        <span class="hljs-comment">// 这两个基于内存的流只要垃圾回收器清理对象就能够释放资源，这一点不同于对外部资源（如文件流）的释放</span>
    }
}</code></pre> <p>以下是测试代码：</p> <pre class="prettyprint"><code class=" hljs cs">import java.io.Serializable;
<span class="hljs-comment">//利用序列化来做深复制</span>
<span class="hljs-comment">//深度clone</span>

class Teacher implements Serializable{
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> final <span class="hljs-keyword">long</span> serialVersionUID = -<span class="hljs-number">8834559347461591191</span>L;

    <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> age;
    <span class="hljs-keyword">public</span> String name;

    <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getAge</span>(){
        <span class="hljs-keyword">return</span> age;
    }

    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setAge</span>(<span class="hljs-keyword">int</span> age){
        <span class="hljs-keyword">this</span>.age = age;
    }

    <span class="hljs-keyword">public</span> String <span class="hljs-title">getName</span>(){
        <span class="hljs-keyword">return</span> name;
    }

    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setName</span>(String name){
        <span class="hljs-keyword">this</span>.name = name;
    }

    @Override
    <span class="hljs-keyword">public</span> String <span class="hljs-title">toString</span>() {
        <span class="hljs-keyword">return</span> <span class="hljs-string">"Teacher [age= "</span> + age + <span class="hljs-string">" , name= "</span> + name + <span class="hljs-string">"]"</span>;
    }
}

class Student implements Serializable{
    <span class="hljs-comment">// serialVersionUID</span>
    <span class="hljs-comment">// 如果你的对象序列化后存到硬盘上面后，可是后来你却更改了类的field(增加或减少或改名)，当你反序列化时，就会出现Exception的，这样就会造成不兼容性的问题。</span>
    <span class="hljs-comment">// 但当serialVersionUID相同时，它就会将不一样的field以type的缺省值赋值(如int型的是0,String型的是null等)，这个可以避开不兼容性的问题。所以最好给serialVersionUID赋值</span>
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> final <span class="hljs-keyword">long</span> serialVersionUID = <span class="hljs-number">7991552226614088458</span>L;

    <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> age;
    <span class="hljs-keyword">public</span> String name;
    <span class="hljs-keyword">public</span> Teacher teacher;

    <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getAge</span>(){
        <span class="hljs-keyword">return</span> age;
    }

    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setAge</span>(<span class="hljs-keyword">int</span> age){
        <span class="hljs-keyword">this</span>.age = age;
    }

    <span class="hljs-keyword">public</span> String <span class="hljs-title">getName</span>(){
        <span class="hljs-keyword">return</span> name;
    }

    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setName</span>(String name){
        <span class="hljs-keyword">this</span>.name = name;
    }

    <span class="hljs-keyword">public</span> Teacher <span class="hljs-title">getTeacher</span>(){
        <span class="hljs-keyword">return</span> teacher;
    }

    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setTeacher</span>(Teacher teacher){
        <span class="hljs-keyword">this</span>.teacher = teacher;
    }

    @Override
    <span class="hljs-keyword">public</span> String <span class="hljs-title">toString</span>() {
        <span class="hljs-keyword">return</span> <span class="hljs-string">"Student [age= "</span> + age + <span class="hljs-string">" , name= "</span> + name + <span class="hljs-string">" , teacher= "</span> + teacher + <span class="hljs-string">"]"</span>;
    }
}

<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> CloneTest{

    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span>(String[] args) throws Exception{
        <span class="hljs-comment">// teacher对象将不被clone出来的Student对象共享.</span>
        Teacher teacher = <span class="hljs-keyword">new</span> Teacher();
        teacher.setAge(<span class="hljs-number">40</span>);
        teacher.setName(<span class="hljs-string">"Teacher zhang"</span>);

        Student student1 = <span class="hljs-keyword">new</span> Student();
        student1.setAge(<span class="hljs-number">20</span>);
        student1.setName(<span class="hljs-string">"zhangsan"</span>);
        student1.setTeacher(teacher);

        <span class="hljs-comment">// 复制出来一个对象student2</span>
        Student student2 = CloneUtil.clone(student1);
        System.<span class="hljs-keyword">out</span>.println(student2);

        System.<span class="hljs-keyword">out</span>.println(<span class="hljs-string">"~~~~~~~~~~~~~~~~~~~~~~"</span>);
        System.<span class="hljs-keyword">out</span>.println(student1);

        <span class="hljs-comment">// 修改student2的引用对象</span>
        student2.getTeacher().setAge(<span class="hljs-number">50</span>);
        student2.getTeacher().setName(<span class="hljs-string">"Teacher Li"</span>);

        System.<span class="hljs-keyword">out</span>.println(<span class="hljs-string">"~~~~~~~~~~~~~~~~~~~~~~"</span>);
        System.<span class="hljs-keyword">out</span>.println(student1);
    }
}</code></pre> <p>注：基于序列化和反序列化实现的克隆不仅仅是深度克隆，更重要的是通过泛型限定，可以检查出要克隆的对象是否支持序列化，这项检查是编译器完成的，不是在运行时抛出异常，这种是方案明显优于使用Object类的clone方法克隆对象。让问题在编译的时候暴露出来总是优于把问题留到运行时。</p></li><li><p>java 方法参数的理解 <br> 方法参数 可理解为： 对于输入的实参 进行了一份拷贝， （1） 若方法参数为基本类型，则在栈内存中开辟新的空间，所有的方法体内部的操作都是针对这个拷贝的操作，并不会影响原来输入实参的值 （2）若方法参数为引用类型，该拷贝与输入实参指向了同一个对象，方法体内部对于对象的操作，都是针对的同一个对象。 <br> 另外，除了在函数传值的时候是”引用传递”，在任何用”＝”向对象变量赋值的时候都是”引用传递”。</p> <p>举例说明：</p> <pre class="prettyprint"><code class=" hljs cs">import java.util.*;

<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> HashtableAdd {
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span>(String[] args) {
        Hashtable&lt;String, StringBuffer&gt; ht = <span class="hljs-keyword">new</span> Hashtable&lt;String, StringBuffer&gt;();
        StringBuffer sb = <span class="hljs-keyword">new</span> StringBuffer();
        sb.append(<span class="hljs-string">"abc,"</span>);
        ht.put(<span class="hljs-string">"1"</span>, sb);
        sb.append(<span class="hljs-string">"def,"</span>);
        ht.put(<span class="hljs-string">"2"</span>, sb);
        sb.append(<span class="hljs-string">"mno,"</span>);
        ht.put(<span class="hljs-string">"3"</span>, sb);
        sb.append(<span class="hljs-string">"xyz."</span>);
        ht.put(<span class="hljs-string">"4"</span>, sb);

        <span class="hljs-keyword">int</span> numObj = <span class="hljs-number">0</span>;
        Enumeration it = ht.elements();
        <span class="hljs-keyword">while</span> (it.hasMoreElements()) {
            System.<span class="hljs-keyword">out</span>.print(<span class="hljs-string">"get StringBufffer "</span> + (++numObj)
                    + <span class="hljs-string">" from Hashtable: "</span>);
            System.<span class="hljs-keyword">out</span>.println(it.nextElement());
        }
    }
}</code></pre> <p>输出结果：</p> <pre class="prettyprint"><code class=" hljs cs"><span class="hljs-keyword">get</span> StringBufffer <span class="hljs-number">1</span> <span class="hljs-keyword">from</span> Hashtable: abc,def,mno,xyz.
<span class="hljs-keyword">get</span> StringBufffer <span class="hljs-number">2</span> <span class="hljs-keyword">from</span> Hashtable: abc,def,mno,xyz.
<span class="hljs-keyword">get</span> StringBufffer <span class="hljs-number">3</span> <span class="hljs-keyword">from</span> Hashtable: abc,def,mno,xyz.
<span class="hljs-keyword">get</span> StringBufffer <span class="hljs-number">4</span> <span class="hljs-keyword">from</span> Hashtable: abc,def,mno,xyz.</code></pre> <p>分析：向Hashtable传递 StringBuffer对象是只传递了这个StringBuffer对象的引用！每一次向Hashtable表中put一次 StringBuffer，并没有生成新的StringBuffer对象，只是在Hashtable表中又放入了一个指向同一StringBuffer对象的引用而已。对Hashtable表存储的任何一个StringBuffer对象（更确切的说应该是对象的引用）的改动，实际上都是对同一个 “StringBuffer”的改动。所以Hashtable并不能真正存储能对象，而只能存储对象的引用。也应该知道这条原则对与Hashtable相似的Vector, List, Map, Set等都是一样的。</p></li><li><p>clone中String与StringBuffer区别 <br> Object类中clone()方法产生的过程是：先在内存中开辟一块和原始对象一样的空间，然后原样拷贝原始对象中的内容。对基本数据类型，这样的操作是没有问题的，但对非基本类型变量，我们知道它们保存的仅仅是对象的引用，若不使用深克隆，即不对引用类型的域进行克隆，会导致clone后的非基本类型变量和原始对象中相应的变量指向的是同一个对象。</p> <p>不是所有的类都能实现深度clone的，StringBuffer没有重载clone()方法，更为严重的是StringBuffer还是一个 final类，这也是说我们也不能用继承的办法间接实现StringBuffer的clone。如果一个类中包含有StringBuffer类型对象或和 StringBuffer相似类的对象，我们有两种选择：要么只能实现影子clone，要么就在类的clone()方法中加一句（假设是 SringBuffer对象，而且变量名仍是unCA）：</p> <pre class="prettyprint"><code class=" hljs cs">o.unCA = <span class="hljs-keyword">new</span> StringBuffer(unCA.toString()); <span class="hljs-comment">//原来的是：o.unCA = (UnCloneA)unCA.clone();</span></code></pre> <p>下面的例子中包括两个类，CloneC类包含一个String类型变量和一个StringBuffer类型变量，并且实现了clone()方法。在 StrClone类中声明了CloneC类型变量c1，然后调用c1的clone()方法生成c1的拷贝c2，在对c2中的String和 StringBuffer类型变量用相应的方法改动之后打印结果：</p> <pre class="prettyprint"><code class=" hljs axapta"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CloneC</span> <span class="hljs-inheritance"><span class="hljs-keyword">implements</span></span> <span class="hljs-title">Cloneable</span> {<!-- --></span>
    <span class="hljs-keyword">public</span> String <span class="hljs-keyword">str</span>;
    <span class="hljs-keyword">public</span> StringBuffer strBuff;

    <span class="hljs-keyword">public</span> Object clone() {
        CloneC o = <span class="hljs-keyword">null</span>;
        <span class="hljs-keyword">try</span> {
            o = (CloneC) <span class="hljs-keyword">super</span>.clone();
        } <span class="hljs-keyword">catch</span> (CloneNotSupportedException e) {
            e.printStackTrace();
        }
        <span class="hljs-keyword">return</span> o;
    }
}

<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CloneTest</span> {<!-- --></span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> main(String[] a) {
        CloneC c1 = <span class="hljs-keyword">new</span> CloneC();
        c1.<span class="hljs-keyword">str</span> = <span class="hljs-keyword">new</span> String(<span class="hljs-string">"initializeStr"</span>);
        c1.strBuff = <span class="hljs-keyword">new</span> StringBuffer(<span class="hljs-string">"initializeStrBuff"</span>);
        System.out.println(<span class="hljs-string">"before clone,c1.str = "</span> + c1.<span class="hljs-keyword">str</span>);
        System.out.println(<span class="hljs-string">"before clone,c1.strBuff = "</span> + c1.strBuff);

        CloneC c2 = (CloneC) c1.clone();
        c2.<span class="hljs-keyword">str</span> = c2.<span class="hljs-keyword">str</span>.substring(<span class="hljs-number">0</span>, <span class="hljs-number">5</span>);
        c2.strBuff = c2.strBuff.append(<span class="hljs-string">" change strBuff clone"</span>);
        System.out.println(<span class="hljs-string">"================================="</span>);
        System.out.println(<span class="hljs-string">"after clone,c1.str = "</span> + c1.<span class="hljs-keyword">str</span>);
        System.out.println(<span class="hljs-string">"after clone,c1.strBuff = "</span> + c1.strBuff);
        System.out.println(<span class="hljs-string">"================================="</span>);
        System.out.println(<span class="hljs-string">"after clone,c2.str = "</span> + c2.<span class="hljs-keyword">str</span>);
        System.out.println(<span class="hljs-string">"after clone,c2.strBuff = "</span> + c2.strBuff);
    }
}</code></pre> <p>运行结果</p> <pre class="prettyprint"><code class=" hljs asciidoc">before clone,c1.str = initializeStr

<span class="hljs-header">before clone,c1.strBuff = initializeStrBuff
=================================</span>

after clone,c1.str = initializeStr

<span class="hljs-header">after clone,c1.strBuff = initializeStrBuff change strBuff clone
=================================</span>

after clone,c2.str = initi
after clone,c2.strBuff = initializeStrBuff change strBuff clone</code></pre> <p>打印的结果可以看出，String类型的变量好象已经实现了深度clone，因为对c2.str的改动并没有影响到c1.str！难道Java把 Sring类看成了基本数据类型？其实不然，这里有一个小小的把戏，秘密就在于c2.str = c2.str.substring(0,5)这一语句！实质上，在clone的时候c1.str与c2.str仍然是引用，而且都指向了同一个 String对象。但在执行c2.str = c2.str.substring(0,5)的时候，它作用相当于生成了一个新的String类型，然后又赋回给c2.str。这是因为String被 Sun公司的工程师写成了一个不可更改的类（immutable class），在所有String类中的函数都不能更改自身的值。</p></li></ol>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/fb0646d98ab073ee4a9112e3213066d0/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">centos-系统语言检查设置安装</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/523b78b6a10573add8db5326ab20e171/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">Linux服务启动报：Address already in use 解决方法：预留端口避免占用ip_local_reserved_ports</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>