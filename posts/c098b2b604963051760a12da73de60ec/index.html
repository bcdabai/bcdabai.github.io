<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>NUC972触摸屏驱动移植过程分析（一） - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="NUC972触摸屏驱动移植过程分析（一）" />
<meta property="og:description" content="https://blog.csdn.net/b7376811/article/details/86514683
因为下一个项目可能会用到触摸屏，所以这段时间对触摸屏的驱动的移植进行了研究，今天正好有机会，谈谈移植过程。
其实基于开发板对触摸屏驱动进行移植，需要做的工作并不是太多，因为大部分工作开发板的供应商已经提供好了，但是用起来总是不尽人意，所以需要进一步优化，废话少说，步入正题。
首先看一下硬件电路，如下图所示：
开发板上使用的是TSC2007作为驱动触摸屏（电阻屏）的驱动芯片，没有使用nuc972内置的AD，这样做的原因首先是比较好移植，其次是外置专用的触摸屏芯片往往精度更高。咱们先看一下这个芯片的几个主要的引脚，X&#43;、Y&#43;、X-、Y- 是连接触摸屏的，一般情况下无需考虑，A0、A1、SCL、SDA 这四个引脚定义很容易识别出是和IIC通信有关，是的，一般外置的触摸屏控制芯片（包括电阻屏和电容屏）都是通过IIC接口与主机CPU进行通信的，A0、A1是设置地址的接口，SCL和SDA分别是IIC的时钟接口与数据接口，那么问题来了，IIC通信是主从模式，任何的通信都需要由主机发起，而主机不能判断什么时候触摸屏被按下，总不能CPU一直在轮询触摸屏吧，那还干不干其他事儿了？所以，就又增加了一个/PENIRQ引脚，这个引脚一般要与CPU的一个gpio连接，如果触摸屏被按下，这个引脚会有动作，从图上可以看出来当触摸屏被按下时，这个引脚会变低，松开会变高（CPU一般是使用中断进行处理），这样就可以通知CPU读取触摸屏数据了。
看完了硬件，我们再来看一下软件。大家知道，在linux内核中，设备数据和驱动原则上是分离的，这样可以增加驱动的可移植性。首先看一下device，在新唐提供的BSP中，nuc970系列的设备数据在/arch/arm/mach-nuc970 这个文件夹里面，我们需要的信息在dev.c这个文件里。还是从下晚上看的看代码原则，先看一下CPU启动时，设备初始化函数：
void __init nuc970_platform_init(struct platform_device **device, int size)
{
#if defined(CONFIG_LEDS_GPIO)
if (gpio_request(nuc970_ek_leds[0].gpio, &#34;led-ds2&#34;) &lt; 0) {
printk(&#34;can not request gpio[%d] for led-ds2\n&#34;, nuc970_ek_leds[0].gpio);
} else {
gpio_direction_output(nuc970_ek_leds[0].gpio, nuc970_ek_leds[0].active_low);
}
#endif
platform_add_devices(device, size);
platform_add_devices(nuc970_public_dev, ARRAY_SIZE(nuc970_public_dev));
mdk970ek_add_device_buttons();
#if defined(CONFIG_MTD_M25P80) || defined(CONFIG_SPI_SPIDEV)
/* register spi devices */
#ifdef CONFIG_SPI_NUC970_P0
spi_register_board_info(nuc970_spi0_board_info, ARRAY_SIZE(nuc970_spi0_board_info));
#endif
#ifdef CONFIG_SPI_NUC970_P1
spi_register_board_info(nuc970_spi1_board_info, ARRAY_SIZE(nuc970_spi1_board_info));
#endif
#endif
#ifdef CONFIG_I2C_BUS_NUC970_P0
i2c_register_board_info(0, nuc970_i2c_clients0, sizeof(nuc970_i2c_clients0)/sizeof(struct i2c_board_info));" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/c098b2b604963051760a12da73de60ec/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2020-08-04T15:43:36+08:00" />
<meta property="article:modified_time" content="2020-08-04T15:43:36+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">NUC972触摸屏驱动移植过程分析（一）</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p><a href="https://blog.csdn.net/b7376811/article/details/86514683">https://blog.csdn.net/b7376811/article/details/86514683</a></p> 
<p> 因为下一个项目可能会用到触摸屏，所以这段时间对触摸屏的驱动的移植进行了研究，今天正好有机会，谈谈移植过程。</p> 
<p>其实基于开发板对触摸屏驱动进行移植，需要做的工作并不是太多，因为大部分工作开发板的供应商已经提供好了，但是用起来总是不尽人意，所以需要进一步优化，废话少说，步入正题。</p> 
<p>首先看一下硬件电路，如下图所示：</p> 
<p><img alt="" height="306" src="https://images2.imgbox.com/38/87/YYMjLfLs_o.png" width="458"></p> 
<p>开发板上使用的是TSC2007作为驱动触摸屏（电阻屏）的驱动芯片，没有使用nuc972内置的AD，这样做的原因首先是比较好移植，其次是外置专用的触摸屏芯片往往精度更高。咱们先看一下这个芯片的几个主要的引脚，X+、Y+、X-、Y- 是连接触摸屏的，一般情况下无需考虑，A0、A1、SCL、SDA 这四个引脚定义很容易识别出是和IIC通信有关，是的，一般外置的触摸屏控制芯片（包括电阻屏和电容屏）都是通过IIC接口与主机CPU进行通信的，A0、A1是设置地址的接口，SCL和SDA分别是IIC的时钟接口与数据接口，那么问题来了，IIC通信是主从模式，任何的通信都需要由主机发起，而主机不能判断什么时候触摸屏被按下，总不能CPU一直在轮询触摸屏吧，那还干不干其他事儿了？所以，就又增加了一个/PENIRQ引脚，这个引脚一般要与CPU的一个gpio连接，如果触摸屏被按下，这个引脚会有动作，从图上可以看出来当触摸屏被按下时，这个引脚会变低，松开会变高（CPU一般是使用中断进行处理），这样就可以通知CPU读取触摸屏数据了。</p> 
<p>看完了硬件，我们再来看一下软件。大家知道，在linux内核中，设备数据和驱动原则上是分离的，这样可以增加驱动的可移植性。首先看一下device，在新唐提供的BSP中，nuc970系列的设备数据在/arch/arm/mach-nuc970 这个文件夹里面，我们需要的信息在dev.c这个文件里。还是从下晚上看的看代码原则，先看一下CPU启动时，设备初始化函数：</p> 
<pre> </pre> 
<ol><li> </li><li> </li><li> <p><code>void __init nuc970_platform_init(struct platform_device **device, int size)</code></p> </li><li> <p><code>{<!-- --></code></p> </li><li> <p><code>#if defined(CONFIG_LEDS_GPIO)</code></p> </li><li> <p><code>if (gpio_request(nuc970_ek_leds[0].gpio, "led-ds2") &lt; 0) {<!-- --></code></p> </li><li> <p><code>printk("can not request gpio[%d] for led-ds2\n", nuc970_ek_leds[0].gpio);</code></p> </li><li> <p><code>} else {<!-- --></code></p> </li><li> <p><code>gpio_direction_output(nuc970_ek_leds[0].gpio, nuc970_ek_leds[0].active_low);</code></p> </li><li> <p><code>}</code></p> </li><li> <p><code>#endif</code></p> </li><li> </li><li> <p><code>platform_add_devices(device, size);</code></p> </li><li> <p><code>platform_add_devices(nuc970_public_dev, ARRAY_SIZE(nuc970_public_dev));</code></p> </li><li> </li><li> <p><code>mdk970ek_add_device_buttons();</code></p> </li><li> </li><li> <p><code>#if defined(CONFIG_MTD_M25P80) || defined(CONFIG_SPI_SPIDEV)</code></p> </li><li> <p><code>/* register spi devices */</code></p> </li><li> <p><code>#ifdef CONFIG_SPI_NUC970_P0</code></p> </li><li> <p><code>spi_register_board_info(nuc970_spi0_board_info, ARRAY_SIZE(nuc970_spi0_board_info));</code></p> </li><li> <p><code>#endif</code></p> </li><li> <p><code>#ifdef CONFIG_SPI_NUC970_P1</code></p> </li><li> <p><code>spi_register_board_info(nuc970_spi1_board_info, ARRAY_SIZE(nuc970_spi1_board_info));</code></p> </li><li> <p><code>#endif</code></p> </li><li> <p><code>#endif</code></p> </li><li> </li><li> <p><code>#ifdef CONFIG_I2C_BUS_NUC970_P0</code></p> </li><li> <p><code>i2c_register_board_info(0, nuc970_i2c_clients0, sizeof(nuc970_i2c_clients0)/sizeof(struct i2c_board_info));</code></p> </li><li> <p><code>#endif</code></p> </li><li> </li><li> <p><code>#ifdef CONFIG_GPIO_NUC970</code></p> </li><li> <p><code>#ifdef CONFIG_I2C_ALGOBIT</code></p> </li><li> <p><code>{<!-- --></code></p> </li><li> <p><code>nuc970_i2c_clients2[0].irq = 399; /* tsc2007 */</code></p> </li><li> <p><code>}</code></p> </li><li> <p><code>i2c_register_board_info(2, nuc970_i2c_clients2, ARRAY_SIZE(nuc970_i2c_clients2));</code></p> </li><li> <p><code>// i2c_register_board_info(2, nuc970_i2c_clients2, sizeof(nuc970_i2c_clients2)/sizeof(struct i2c_board_info));</code></p> </li><li> <p><code>#endif</code></p> </li><li> <p><code>#endif</code></p> </li><li> </li><li> <p><code>#ifdef CONFIG_PWM_NUC970</code></p> </li><li> <p><code>pwm_add_table(board_pwm_lookup, ARRAY_SIZE(board_pwm_lookup));</code></p> </li><li> <p><code>#endif</code></p> </li><li> <p><code>}</code></p> </li></ol> 
<p>内核启动时，初始化设备就是调用的这个函数，我们使用的是使用GPIO模拟IIC通信的方式，所以需要选择CONFIG_GPIO_NUC970、CONFIG_I2C_ALGOBIT这两个宏定义，具体两个宏定义之间的代码先不考虑，下面会有介绍，只需要先注意一个字段：nuc970_i2c_clients2，这个是注册IIC设备的重中之重，而且肯定在上面的代码中有定义，网上翻代码，很容易找到它的定义：</p> 
<pre> </pre> 
<ol><li> <p><code>#ifdef CONFIG_GPIO_NUC970</code></p> </li><li> <p><code>#ifdef CONFIG_I2C_ALGOBIT</code></p> </li><li> <p><code>static struct i2c_board_info __initdata nuc970_i2c_clients2[] =</code></p> </li><li> <p><code>{<!-- --></code></p> </li><li> <p><code>{<!-- --></code></p> </li><li> <p><code>I2C_BOARD_INFO("tsc2007", 0x48),</code></p> </li><li> <p><code>.platform_data = &amp;tsc2007_info,</code></p> </li><li> <p><code>/* irq number is run-time assigned */</code></p> </li><li> <p><code>},</code></p> </li><li> <p><code>#ifdef CONFIG_SENSOR_OV7725</code></p> </li><li> <p><code>{I2C_BOARD_INFO("ov7725", 0x21),},</code></p> </li><li> <p><code>#endif</code></p> </li><li> <p><code>#ifdef CONFIG_SENSOR_OV5640</code></p> </li><li> <p><code>{I2C_BOARD_INFO("ov5640", 0x3c),},</code></p> </li><li> <p><code>#endif</code></p> </li><li> <p><code>#ifdef CONFIG_SENSOR_NT99141</code></p> </li><li> <p><code>{I2C_BOARD_INFO("nt99141", 0x2a),},</code></p> </li><li> <p><code>#endif</code></p> </li><li> <p><code>#ifdef CONFIG_SENSOR_NT99050</code></p> </li><li> <p><code>{I2C_BOARD_INFO("nt99050", 0x21),},</code></p> </li><li> <p><code>#endif</code></p> </li><li> <p><code>{I2C_BOARD_INFO("lm75a", 0x4e),},</code></p> </li><li> </li><li> <p><code>{I2C_BOARD_INFO("ds1307", 0x68),},</code></p> </li><li> <p><code>};</code></p> </li></ol> 
<p>可以很明显的看出来nuc970_i2c_clients2是一个i2c_board_info 类型的结构体数组，里面包含了好几个成员，大部分都是条件编译选项，咱们只考虑触摸屏，只看第一个元素，这个结构体里面一共有两个变量，第一个是一个宏，其实就是填充该结构体type,addr两个字段，type一般就是I2C设备的名字，addr是该设备在I2C总线上的地址（注意，这个地址需要查看技术手册，每种设备都有不同的定义地址的规则）。platform_data  字段填充的是需要传入驱动的私有数据。下面看一下这个私有数据，继续往上翻代码，很容易找到这个结构：</p> 
<pre> </pre> 
<ol><li> <p><code>static struct tsc2007_platform_data tsc2007_info = {<!-- --></code></p> </li><li> <p><code>.model = 2007,</code></p> </li><li> <p><code>.x_plate_ohms = 200,</code></p> </li><li> <p><code>.get_pendown_state = tsc2007_get_pendown_state,</code></p> </li><li> <p><code>.init_platform_hw = tsc2007_init_platform_hw,</code></p> </li><li> <p><code>.clear_penirq = tsc2007_clear_penirq,</code></p> </li><li> <p><code>};</code></p> </li></ol> 
<p>model和x_plate_ohms是触摸屏自己相关的参数，get_pendown_state是获取触摸屏有没有被按下的状态指示的函数指针，这个指针指向的函数其实就是判断触摸屏芯片TSC2007的/PENIRQ引脚是高电平还是低电平。init_platform_hw是对触摸屏硬件初始化的函数指针，其实指向的就是和/PENIRQ引脚相连的CPU的gpio相关的设置函数，同样的，clear_penirq指向的就是清除该gpio中断的函数。说到这里，大家其实就应该明白了，触摸屏驱动牵扯到两方面的知识，一方面是I2C接口通信，一方面是gpio输入中断处理。再往上追，就很容易看到这三个函数的内容：</p> 
<pre> </pre> 
<ol><li> <p><code>static int tsc2007_get_pendown_state(void)</code></p> </li><li> <p><code>{<!-- --></code></p> </li><li> <p><code>static int pre_val = 1;</code></p> </li><li> </li><li> <p><code>int gpio_1_val = gpio_get_value(NUC970_PE15);</code></p> </li><li> <p><code>if (pre_val != gpio_1_val) {<!-- --></code></p> </li><li> <p><code>mdelay(20);</code></p> </li><li> <p><code>gpio_1_val = gpio_get_value(NUC970_PE15);</code></p> </li><li> <p><code>if (pre_val != gpio_1_val) {<!-- --></code></p> </li><li> <p><code>pre_val = gpio_1_val;</code></p> </li><li> <p><code>}</code></p> </li><li> <p><code>}</code></p> </li><li> </li><li> <p><code>return !pre_val;</code></p> </li><li> <p><code>//return !gpio_get_value(NUC970_PE15);</code></p> </li><li> <p><code>}</code></p> </li><li> </li><li> <p><code>static void tsc2007_clear_penirq(void)</code></p> </li><li> <p><code>{<!-- --></code></p> </li><li> <p><code>__raw_writel(__raw_readl(REG_GPIOE_ISR) | 0x8000, REG_GPIOE_ISR);</code></p> </li><li> <p><code>//printk("clear irq for tsc2007\n");</code></p> </li><li> <p><code>}</code></p> </li><li> </li><li> <p><code>static int tsc2007_init_platform_hw(void)</code></p> </li><li> <p><code>{<!-- --></code></p> </li><li> <p><code>printk("REG_GPIOE_PUEN=%x\n", __raw_readl(REG_GPIOE_PUEN));</code></p> </li><li> <p><code>/* enable pull up on PE14, PE15 */</code></p> </li><li> <p><code>__raw_writel(__raw_readl(REG_GPIOE_PUEN) | 0xc000, REG_GPIOE_PUEN);</code></p> </li><li> <p><code>/* disable pull down on PE14, PE15 */</code></p> </li><li> <p><code>__raw_writel(__raw_readl(REG_GPIOE_PDEN) &amp; 0x3FFF, REG_GPIOE_PDEN);</code></p> </li><li> <p><code>/* enable debounce on PE14, PE15 */</code></p> </li><li> <p><code>__raw_writel(__raw_readl(REG_GPIOE_DBEN) | 0xc000, REG_GPIOE_DBEN);</code></p> </li><li> <p><code>printk("REG_GPIOE_PUEN=%x\n", __raw_readl(REG_GPIOE_PUEN));</code></p> </li><li> <p><code>gpio_request_one(NUC970_PE15, GPIOF_IN, "nuc970-ts2007");</code></p> </li><li> <p><code>gpio_direction_input(NUC970_PE15);</code></p> </li><li> <p><code>/* only enable fallen edge int on PE15 */</code></p> </li><li> <p><code>__raw_writel(__raw_readl(REG_GPIOE_IFEN) | 0x8000, REG_GPIOE_IFEN);</code></p> </li><li> <p><code>printk("gpio_to_irq(NUC970_PE15)=%d\n", gpio_to_irq(NUC970_PE15));</code></p> </li><li> <p><code>return 0;</code></p> </li><li> <p><code>}</code></p> </li></ol> 
<p>好了，分析到此，触摸屏注册需要的数据基本上已经全部包含了，这些数据会在内核启动时，初始化平台的设备时调用void __init nuc970_platform_init(struct platform_device **device, int size) 这个函数，在这个函数中，通过i2c_register_board_info(2, nuc970_i2c_clients2, ARRAY_SIZE(nuc970_i2c_clients2))这个函数对结构体数组nuc970_i2c_clients2中的内容进行注册，注意，这个函数的第一个参数在这里设置为2，这个参数代表的含义是i2c总线的编号，这里为什么要设置成2呢？因为nuc970平台上包含两个I2C硬件接口，咱们这里是使用内核中使用gpio模拟I2C通信时序来完成通信的，所以为了和硬件I2C接口不冲突，设置为2。</p> 
<p>分析到这里，基本上就把触摸屏驱动相关的device的数据搞清楚了，今天就写这么多吧，拜拜！</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/7bc59be9b8575c72c0609e10dc968e7c/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">Android audio介绍</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/39d3ca8c05fd23f565d80c9e1213145b/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">【转载】AUTODESK系列专用卸载工具软件推荐排行榜（CAD/3Dmax/Revit/Maya/Inventor）</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>