<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>扫雷游戏优化详解——c语言实现 - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="扫雷游戏优化详解——c语言实现" />
<meta property="og:description" content="文章目录
一、扫雷游戏的简单认识与解释 二、扫雷游戏的代码及思路实现
一、扫雷游戏的思路
1、菜单打印 2、创建扫雷区
3、初始化雷区
4、打印雷区
5、布置雷区
6、排雷
三、扫雷游戏代码的整合
game.h
game.c
test.c 标题：扫雷小游戏 作者：@Ggggggtm 寄语：与其忙着诉苦，不如低头赶路，奋路前行，终将遇到一番好风景 一、扫雷游戏的简单认识与解释 相信大家都玩过扫雷游戏吧。但是你真的会玩扫雷游戏吗？那就让我来给你具体讲一下扫雷游戏的玩法。规则如下：
首先是已经布置好雷区，第一次排雷全靠运气；当未踩中雷，会显示出以你排的位置为中心，9x9的范围内有多少颗雷；当未踩中雷，且9x9的范围内没有雷时，会直接拓展区域，直到周围有雷停止拓展；当你踩中雷时，游戏直接结束；直到你排完雷，才算游戏取得胜利。 既然我们熟悉了规则，那我们来看一下具体的代码及思路的实现吧。
二、扫雷游戏的代码及思路实现 一、扫雷游戏的思路 我们先来大概想一下整体的思路。简单的可分为以下步骤：
菜单打印创建扫雷区域初始化扫雷区域打印雷区布置雷区排雷 有了上面的整体的扫雷实现思路，我们就来一一展开实现。当然在不同板块实现中还有很多的小细节，具体的细节我们再实现中一一引出来分析。
1、菜单打印 菜单的打印需要简单明了即可。且实现比较简单。注意要单独放在一个自定义函数中，让主函数中的代码尽量减少，方便观察。
void meau() { printf(&#34;************************\n&#34;); printf(&#34;***** 1、play *****\n&#34;); printf(&#34;***** 0、exit *****\n&#34;); printf(&#34;************************\n&#34;); } 通过上面的菜单，我们可以很容易的看出选择 ‘ 1 ’ 开始游戏，选择 ‘ 0 ’ 退出游戏。
2、创建扫雷区 创建雷区需要注意的是，我们后期可能要改变雷区的大小。为了方便后期更改雷区大小，所以我们这里选择define定义常量。
我们在这里创建雷区时选择创建两个二位数组。一个数组放雷，另一个数组输出提示。这样会更加方便实现。假如我们这里只创建一个二维数组的话，在扫雷的同时还需要输出提示会很麻烦。
当我们选择9x9的雷区时，我们定义的雷区需要在上下左右各加一行，以便后面我们排雷时不会越界访问数组。代码如下：
#define ROW 9 #define COL 9 #define ROWS ROW&#43;2 #define COLS COL&#43;2 char mine[ROWS][COLS] = { 0 }; //放雷数组 char show[ROWS][COLS] = { 0 }; //输出数组 3、初始化雷区 我们先把两个数组初始化。在mine[ROWS][COLS]中，我们将整个数组初始化成 ’ 0 ’；将show[ROWS][COLS] 全部初始化成 ‘*’。把mine数组初始化成’ 0 ’，是因为我们要把雷设置成 ‘ 1 ’，以便我们后期统计雷的数量。把show数全部初始化成 ‘ * ’，是因为输出的时候可看性比较高。接下来我们看一下代码的实现：" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/4b6b516dd5d58078c2563f598dfd56fc/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-12-23T21:53:10+08:00" />
<meta property="article:modified_time" content="2022-12-23T21:53:10+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">扫雷游戏优化详解——c语言实现</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <blockquote> 
 <p id="main-toc"><strong>文章目录</strong></p> 
 <p id="%E4%B8%80%E3%80%81%E6%89%AB%E9%9B%B7%E6%B8%B8%E6%88%8F%E7%9A%84%E7%AE%80%E5%8D%95%E8%AE%A4%E8%AF%86%E4%B8%8E%E8%A7%A3%E9%87%8A%C2%A0-toc" style="margin-left:0px;"><a href="#%E4%B8%80%E3%80%81%E6%89%AB%E9%9B%B7%E6%B8%B8%E6%88%8F%E7%9A%84%E7%AE%80%E5%8D%95%E8%AE%A4%E8%AF%86%E4%B8%8E%E8%A7%A3%E9%87%8A%C2%A0" rel="nofollow">一、扫雷游戏的简单认识与解释 </a></p> 
 <p id="%E4%BA%8C%E3%80%81%E6%89%AB%E9%9B%B7%E6%B8%B8%E6%88%8F%E7%9A%84%E4%BB%A3%E7%A0%81%E5%8F%8A%E6%80%9D%E8%B7%AF%E5%AE%9E%E7%8E%B0-toc" style="margin-left:0px;"><a href="#%E4%BA%8C%E3%80%81%E6%89%AB%E9%9B%B7%E6%B8%B8%E6%88%8F%E7%9A%84%E4%BB%A3%E7%A0%81%E5%8F%8A%E6%80%9D%E8%B7%AF%E5%AE%9E%E7%8E%B0" rel="nofollow">二、扫雷游戏的代码及思路实现</a></p> 
 <p id="%E4%B8%80%E3%80%81%E6%89%AB%E9%9B%B7%E6%B8%B8%E6%88%8F%E7%9A%84%E6%80%9D%E8%B7%AF-toc" style="margin-left:40px;"><a href="#%E4%B8%80%E3%80%81%E6%89%AB%E9%9B%B7%E6%B8%B8%E6%88%8F%E7%9A%84%E6%80%9D%E8%B7%AF" rel="nofollow">一、扫雷游戏的思路</a></p> 
 <p id="1%E3%80%81%E8%8F%9C%E5%8D%95%E6%89%93%E5%8D%B0%C2%A0-toc" style="margin-left:80px;"><a href="#1%E3%80%81%E8%8F%9C%E5%8D%95%E6%89%93%E5%8D%B0%C2%A0" rel="nofollow">1、菜单打印 </a></p> 
 <p id="2%E3%80%81%E5%88%9B%E5%BB%BA%E6%89%AB%E9%9B%B7%E5%8C%BA-toc" style="margin-left:80px;"><a href="#2%E3%80%81%E5%88%9B%E5%BB%BA%E6%89%AB%E9%9B%B7%E5%8C%BA" rel="nofollow">2、创建扫雷区</a></p> 
 <p id="3%E3%80%81%E5%88%9D%E5%A7%8B%E5%8C%96%E9%9B%B7%E5%8C%BA-toc" style="margin-left:80px;"><a href="#3%E3%80%81%E5%88%9D%E5%A7%8B%E5%8C%96%E9%9B%B7%E5%8C%BA" rel="nofollow">3、初始化雷区</a></p> 
 <p id="4%E3%80%81%E6%89%93%E5%8D%B0%E9%9B%B7%E5%8C%BA-toc" style="margin-left:80px;"><a href="#4%E3%80%81%E6%89%93%E5%8D%B0%E9%9B%B7%E5%8C%BA" rel="nofollow">4、打印雷区</a></p> 
 <p id="5%E3%80%81%E5%B8%83%E7%BD%AE%E9%9B%B7%E5%8C%BA-toc" style="margin-left:80px;"><a href="#5%E3%80%81%E5%B8%83%E7%BD%AE%E9%9B%B7%E5%8C%BA" rel="nofollow">5、布置雷区</a></p> 
 <p id="%C2%A06%E3%80%81%E6%8E%92%E9%9B%B7-toc" style="margin-left:80px;"><a href="#%C2%A06%E3%80%81%E6%8E%92%E9%9B%B7" rel="nofollow">6、排雷</a></p> 
 <p id="%C2%A0%E4%B8%89%E3%80%81%E6%89%AB%E9%9B%B7%E6%B8%B8%E6%88%8F%E4%BB%A3%E7%A0%81%E7%9A%84%E6%95%B4%E5%90%88-toc" style="margin-left:0px;"><a href="#%C2%A0%E4%B8%89%E3%80%81%E6%89%AB%E9%9B%B7%E6%B8%B8%E6%88%8F%E4%BB%A3%E7%A0%81%E7%9A%84%E6%95%B4%E5%90%88" rel="nofollow"> 三、扫雷游戏代码的整合</a></p> 
 <p id="%C2%A0game.h-toc" style="margin-left:40px;"><a href="#%C2%A0game.h" rel="nofollow"> game.h</a></p> 
 <p id="%C2%A0game.c-toc" style="margin-left:40px;"><a href="#%C2%A0game.c" rel="nofollow"> game.c</a></p> 
 <p id="test.c%C2%A0-toc" style="margin-left:40px;"> <a href="#test.c%C2%A0" rel="nofollow">test.c </a></p> 
 <hr id="hr-toc"> 
 <h2 id="main-toc"><span style="color:#fe2c24;">标题：扫雷小游戏 </span></h2> 
 <h2 id="%E4%BD%9C%E8%80%85%EF%BC%9A%40Ggggggtm"><span style="color:#fe2c24;"><strong>作者：@Ggggggtm</strong></span></h2> 
 <h2 id="%E5%AF%84%E8%AF%AD%EF%BC%9A%E4%B8%8E%E5%85%B6%E5%BF%99%E7%9D%80%E8%AF%89%E8%8B%A6%EF%BC%8C%E4%B8%8D%E5%A6%82%E4%BD%8E%E5%A4%B4%E8%B5%B6%E8%B7%AF%EF%BC%8C%E5%A5%8B%E8%B7%AF%E5%89%8D%E8%A1%8C%EF%BC%8C%E4%B8%AD%E5%B0%86%E9%81%87%E5%88%B0%E4%B8%80%E7%95%AA%E5%A5%BD%E9%A3%8E%E6%99%AF"><span style="color:#fe2c24;">寄语：与其忙着诉苦，不如低头赶路，奋路前行，终将遇到一番好风景</span></h2> 
 <p><img alt="" height="838" src="https://images2.imgbox.com/5f/e8/iSFf07bZ_o.png" width="578"></p> 
 <p></p> 
</blockquote> 
<h2 id="%E4%B8%80%E3%80%81%E6%89%AB%E9%9B%B7%E6%B8%B8%E6%88%8F%E7%9A%84%E7%AE%80%E5%8D%95%E8%AE%A4%E8%AF%86%E4%B8%8E%E8%A7%A3%E9%87%8A%C2%A0">一、扫雷游戏的简单认识与解释 </h2> 
<blockquote> 
 <p>  相信大家都玩过扫雷游戏吧。但是你真的会玩扫雷游戏吗？那就让我来给你具体讲一下扫雷游戏的玩法。规则如下：</p> 
 <ol><li>首先是已经布置好雷区，第一次排雷全靠运气；</li><li>当未踩中雷，会显示出以你排的位置为中心，9x9的范围内有多少颗雷；</li><li>当未踩中雷，且9x9的范围内没有雷时，会直接拓展区域，直到周围有雷停止拓展；</li><li>当你踩中雷时，游戏直接结束；</li><li>直到你排完雷，才算游戏取得胜利。</li></ol> 
 <p>  既然我们熟悉了规则，那我们来看一下具体的代码及思路的实现吧。</p> 
</blockquote> 
<h2 id="%E4%BA%8C%E3%80%81%E6%89%AB%E9%9B%B7%E6%B8%B8%E6%88%8F%E7%9A%84%E4%BB%A3%E7%A0%81%E5%8F%8A%E6%80%9D%E8%B7%AF%E5%AE%9E%E7%8E%B0">二、扫雷游戏的代码及思路实现</h2> 
<h3 id="%E4%B8%80%E3%80%81%E6%89%AB%E9%9B%B7%E6%B8%B8%E6%88%8F%E7%9A%84%E6%80%9D%E8%B7%AF">一、扫雷游戏的思路</h3> 
<blockquote> 
 <p>   我们先来大概想一下整体的思路。简单的可分为以下步骤：</p> 
 <ol><li>菜单打印</li><li>创建扫雷区域</li><li>初始化扫雷区域</li><li>打印雷区</li><li>布置雷区</li><li>排雷</li></ol> 
 <p>  有了上面的整体的扫雷实现思路，我们就来一一展开实现。当然在不同板块实现中还有很多的小细节，具体的细节我们再实现中一一引出来分析。</p> 
</blockquote> 
<h4 id="1%E3%80%81%E8%8F%9C%E5%8D%95%E6%89%93%E5%8D%B0%C2%A0">1、菜单打印 </h4> 
<blockquote> 
 <p>  菜单的打印需要简单明了即可。且实现比较简单。注意要单独放在一个自定义函数中，让主函数中的代码尽量减少，方便观察。</p> 
</blockquote> 
<pre><code>void meau()
{
	printf("************************\n");
	printf("*****   1、play    *****\n");
	printf("*****   0、exit    *****\n");
	printf("************************\n");
}</code></pre> 
<blockquote> 
 <p>  通过上面的菜单，我们可以很容易的看出选择 ‘ 1 ’ 开始游戏，选择 ‘ 0 ’ 退出游戏。</p> 
</blockquote> 
<h4 id="2%E3%80%81%E5%88%9B%E5%BB%BA%E6%89%AB%E9%9B%B7%E5%8C%BA">2、创建扫雷区</h4> 
<blockquote> 
 <p>  创建雷区需要注意的是，我们后期可能要改变雷区的大小。为了方便后期更改雷区大小，所以我们这里选择define定义常量。</p> 
 <p>  我们在这里创建雷区时选择创建两个二位数组。一个数组放雷，另一个数组输出提示。这样会更加方便实现。假如我们这里只创建一个二维数组的话，在扫雷的同时还需要输出提示会很麻烦。</p> 
 <p>  当我们选择9x9的雷区时，我们定义的雷区需要在上下左右各加一行，以便后面我们排雷时不会越界访问数组。代码如下：</p> 
</blockquote> 
<pre><code class="language-cs">#define ROW 9
#define COL 9

#define ROWS ROW+2
#define COLS COL+2

char mine[ROWS][COLS] = { 0 };  //放雷数组
char show[ROWS][COLS] = { 0 };  //输出数组</code></pre> 
<h4 id="3%E3%80%81%E5%88%9D%E5%A7%8B%E5%8C%96%E9%9B%B7%E5%8C%BA"><strong>3、初始化雷区</strong></h4> 
<blockquote> 
 <p>  我们先把两个数组初始化。在mine[ROWS][COLS]中，我们将整个数组初始化成 ’ 0 ’；将show[ROWS][COLS] 全部初始化成 ‘*’。把mine数组初始化成’ 0 ’，是因为我们要把雷设置成 ‘ 1 ’，以便我们后期统计雷的数量。把show数全部初始化成 ‘ * ’，是因为输出的时候可看性比较高。接下来我们看一下代码的实现：</p> 
</blockquote> 
<pre><code class="language-cs">void init_board(char board[ROWS][COLS], int rows, int cols,char set)
{
	int i = 0;
	for (i = 0; i &lt; rows; i++)
	{
		int j = 0;
		for (j = 0; j &lt; cols; j++)
		{
			board[i][j] = set;
		}
	}
}


init_board(mine, ROWS, COLS, '0');
init_board(show, ROWS, COLS, '*');</code></pre> 
<h4 id="4%E3%80%81%E6%89%93%E5%8D%B0%E9%9B%B7%E5%8C%BA">4、打印雷区</h4> 
<blockquote> 
 <p>  打印雷区时，我们可以自己适当添加一些格式，以便后期玩家更加方便的玩游戏。这里我们添加了行和列标示，还有扫雷区的提示。代码的实现如下： </p> 
</blockquote> 
<pre><code class="language-cs">void print_board(char board[ROWS][COLS], int row, int col)
{
	int j = 0;
	int i = 0;
	printf("-------G扫雷-------\n");
	printf("\n");
	for (j = 0; j &lt;= col; j++)
	{
		printf("%d ", j);
	}
	printf("\n");
	for (i = 1; i &lt;= row; i++)
	{
		printf("%d ", i);
		for (j = 1; j &lt;= col; j++)
		{
			printf("%c ", board[i][j]);
		}
		printf("\n");
	}
	printf("\n");
	printf("-------G扫雷-------\n");
}


print_board(mine, ROW, COL);
print_board(show, ROW, COL);</code></pre> 
<p></p> 
<h4 id="5%E3%80%81%E5%B8%83%E7%BD%AE%E9%9B%B7%E5%8C%BA">5、布置雷区</h4> 
<blockquote> 
 <p>  布置雷区当然是要随机布置的。 提到随机，我们就因该联想到<strong>rand()函数</strong>和<strong>srand()函数</strong>，在这里我就不详细介绍这两个函数的使用方法了，在之前的<strong>猜数字小游戏</strong>中有详细的解释，可以去了解一下。需要注意的是，我们要把布置的雷区放在9x9的范围内，且已经布置过的地方不能重新布置。我们看一下代码的实现：</p> 
</blockquote> 
<pre><code class="language-cs">void set_mine(char mine[ROWS][COLS], int row, int col)
{
	int count = EASY_COUNT;
	while (count)
	{
		int x = rand() % row + 1;
		int y = rand() % col + 1;
		if (mine[x][y] == '0')
		{
			mine[x][y] = '1';
			count--;
		}
	}
}


set_mine(mine, ROW, COL);</code></pre> 
<h4 id="%C2%A06%E3%80%81%E6%8E%92%E9%9B%B7">6、排雷</h4> 
<blockquote> 
 <p>  排雷的时候需要我们注意以下几种情况：</p> 
 <ol><li>输入所要排雷的坐标需要合法，不合法时要给出相应的提示；</li><li>排查过的坐标不需要重复排查；</li><li>排查的坐标3x3的周围没有雷时要进行相应的展开；</li><li>踩中雷时，要给出相应的提示，并且同时打印书雷区数组。</li></ol> 
 <p>  上面的雷区展开，我们进行展开时需要用到递归。我们结合着代码综合理解一下，代码如下：</p> 
</blockquote> 
<pre><code class="language-cs">int sum_mine(char mine[ROWS][COLS], int x, int y)
{
	return (mine[x - 1][y - 1] + mine[x - 1][y] + mine[x - 1][y + 1] +
		mine[x][y - 1] + mine[x][y + 1] + mine[x + 1][y - 1] +
		mine[x + 1][y] + mine[x + 1][y+1] - 8 * '0');
}

void spread_mine(char mine[ROWS][COLS], char show[ROWS][COLS], int x, int y)
{

	int n = sum_mine(mine, x, y);
	if (x &gt;= 1 &amp;&amp; x &lt;= ROW &amp;&amp; y &gt;= 1 &amp;&amp; y &lt;= COL)
	{
		if (show[x][y] == '*')
		{
			if (n == 0)
			{
				show[x][y] = '0';
				spread_mine(mine, show, x - 1, y);
				spread_mine(mine, show, x - 1, y - 1);
				spread_mine(mine, show, x, y - 1);
				spread_mine(mine, show, x + 1, y - 1);
				spread_mine(mine, show, x + 1, y);
				spread_mine(mine, show, x + 1, y + 1);
				spread_mine(mine, show, x, y + 1);
				spread_mine(mine, show, x - 1, y + 1);
			}
			else
			{
				show[x][y] = n + '0';
			}
		}
	}

}

void find_mine(char mine[ROWS][COLS], char show[ROWS][COLS], int row, int col)
{
	int x = 0;
	int y = 0;
	int win = 0;
	while (win&lt;(row*col- EASY_COUNT))
	{
		printf("请输入你要排查的坐标：");
		scanf("%d %d", &amp;x, &amp;y);
		if (x &gt;= 1 &amp;&amp; x &lt;= row &amp;&amp; y &gt;= 1 &amp;&amp; y &lt;= col)
		{
			if (show[x][y] != '*')
			{
				printf("该坐标已经被排查过了哦。\n");
				continue;
			}
			if (mine[x][y] == '0')
			{
				spread_mine(mine, show, x, y);
				int n = sum_mine(mine, x, y);
				show[x][y] = n + '0';
				print_board(show, ROW, COL);
				win++;
			}
			else
			{
				printf("不好意思，你踩中雷了。雷区如下：\n");
				print_board(mine, ROW, COL);
				break;
			}
		}
		else
		{
			printf("你输入的坐标非法哦，请重新输入合法坐标。\n");
		}
	}
	if (win == (row * col - EASY_COUNT))
	{
		printf("恭喜你，排雷成功了ovo！\n");
	}
}


find_mine(mine,show, ROW, COL);</code></pre> 
<h2 id="%C2%A0%E4%B8%89%E3%80%81%E6%89%AB%E9%9B%B7%E6%B8%B8%E6%88%8F%E4%BB%A3%E7%A0%81%E7%9A%84%E6%95%B4%E5%90%88"> 三、扫雷游戏代码的整合</h2> 
<blockquote> 
 <p>  由于代码量相对来说有一点多，所以我们就将函数的声明的定义分开，这样有利于提高代码的可读性，同时会保持一个良好的思路，且方便编写代码。</p> 
 <p>  我们将函数的声明放在单独的一个game.h的头文件，函数的实现放在一个单独的game.c源文件，函数的主方法及调用放在另一个单独的test.c源文件。</p> 
</blockquote> 
<h3 id="%C2%A0game.h"> game.h</h3> 
<pre><code class="language-cs">#define _CRT_SECURE_NO_WARNINGS 1
#include&lt;stdio.h&gt;
#include&lt;stdlib.h&gt;
#include&lt;time.h&gt;


#define ROW 9
#define COL 9

#define ROWS ROW+2
#define COLS COL+2

#define EASY_COUNT 80 //雷的个数

//初始化扫雷界面
void init_board(char board[ROWS][COLS], int rows, int cols, char set);

//打印扫雷界面
void print_board(char board[ROWS][COLS], int row, int col);

//布置雷区
void set_mine(char mine[ROWS][COLS], int row, int col);

//排雷
void find_mine(char mine[ROWS][COLS], char show[ROWS][COLS], int row, int col);</code></pre> 
<h3 id="%C2%A0game.c"> game.c</h3> 
<pre><code class="language-cs">

#include "game.h"

void init_board(char board[ROWS][COLS], int rows, int cols,char set)
{
	int i = 0;
	for (i = 0; i &lt; rows; i++)
	{
		int j = 0;
		for (j = 0; j &lt; cols; j++)
		{
			board[i][j] = set;
		}
	}
}

void print_board(char board[ROWS][COLS], int row, int col)
{
	int j = 0;
	int i = 0;
	printf("-------G扫雷-------\n");
	printf("\n");
	for (j = 0; j &lt;= col; j++)
	{
		printf("%d ", j);
	}
	printf("\n");
	for (i = 1; i &lt;= row; i++)
	{
		printf("%d ", i);
		for (j = 1; j &lt;= col; j++)
		{
			printf("%c ", board[i][j]);
		}
		printf("\n");
	}
	printf("\n");
	printf("-------G扫雷-------\n");
}

void set_mine(char mine[ROWS][COLS], int row, int col)
{
	int count = EASY_COUNT;
	while (count)
	{
		int x = rand() % row + 1;
		int y = rand() % col + 1;
		if (mine[x][y] == '0')
		{
			mine[x][y] = '1';
			count--;
		}
	}
}
int sum_mine(char mine[ROWS][COLS], int x, int y)
{
	return (mine[x - 1][y - 1] + mine[x - 1][y] + mine[x - 1][y + 1] +
		mine[x][y - 1] + mine[x][y + 1] + mine[x + 1][y - 1] +
		mine[x + 1][y] + mine[x + 1][y+1] - 8 * '0');
}

void spread_mine(char mine[ROWS][COLS], char show[ROWS][COLS], int x, int y)
{

	int n = sum_mine(mine, x, y);
	if (x &gt;= 1 &amp;&amp; x &lt;= ROW &amp;&amp; y &gt;= 1 &amp;&amp; y &lt;= COL)
	{
		if (show[x][y] == '*')
		{
			if (n == 0)
			{
				show[x][y] = '0';
				spread_mine(mine, show, x - 1, y);
				spread_mine(mine, show, x - 1, y - 1);
				spread_mine(mine, show, x, y - 1);
				spread_mine(mine, show, x + 1, y - 1);
				spread_mine(mine, show, x + 1, y);
				spread_mine(mine, show, x + 1, y + 1);
				spread_mine(mine, show, x, y + 1);
				spread_mine(mine, show, x - 1, y + 1);
			}
			else
			{
				show[x][y] = n + '0';
			}
		}
	}

}

//void spread_mine(char mine[ROWS][COLS], char show[ROWS][COLS], int x, int y)
//{
//	判断坐标是否越界
//	if (x == 0 || y == 0 || x == ROWS - 1 || y == COLS - 1)
//		return;
//	判断是否已经被排除
//	if (show[x][y] != '*')
//	{
//		return;
//	}
//	int count = sum_mine(mine, x, y);
//	if (count &gt; 0)
//	{
//		show[x][y] = count + '0';
//		return;
//	}
//	递归拓展地图
//	else if (count == 0)
//	{
//		show[x][y] = '0';
//		spread_mine(mine, show, x - 1, y);
//		spread_mine(mine, show, x - 1, y - 1);
//		spread_mine(mine, show, x, y - 1);
//		spread_mine(mine, show, x + 1, y - 1);
//		spread_mine(mine, show, x + 1, y);
//		spread_mine(mine, show, x + 1, y + 1);
//		spread_mine(mine, show, x, y + 1);
//		spread_mine(mine, show, x - 1, y + 1);
//	}
//}
void find_mine(char mine[ROWS][COLS], char show[ROWS][COLS], int row, int col)
{
	int x = 0;
	int y = 0;
	int win = 0;
	while (win&lt;(row*col- EASY_COUNT))
	{
		printf("请输入你要排查的坐标：");
		scanf("%d %d", &amp;x, &amp;y);
		if (x &gt;= 1 &amp;&amp; x &lt;= row &amp;&amp; y &gt;= 1 &amp;&amp; y &lt;= col)
		{
			if (show[x][y] != '*')
			{
				printf("该坐标已经被排查过了哦。\n");
				continue;
			}
			if (mine[x][y] == '0')
			{
				spread_mine(mine, show, x, y);
				int n = sum_mine(mine, x, y);
				show[x][y] = n + '0';
				print_board(show, ROW, COL);
				win++;
			}
			else
			{
				printf("不好意思，你踩中雷了。雷区如下：\n");
				print_board(mine, ROW, COL);
				break;
			}
		}
		else
		{
			printf("你输入的坐标非法哦，请重新输入合法坐标。\n");
		}
	}
	if (win == (row * col - EASY_COUNT))
	{
		printf("恭喜你，排雷成功了ovo！\n");
	}
}</code></pre> 
<h3 id="test.c%C2%A0">test.c </h3> 
<pre><code class="language-cs">#include "game.h"
void game()
{
	srand((unsigned int)time(NULL));
	char mine[ROWS][COLS] = { 0 };
	char show[ROWS][COLS] = { 0 };
	//初始化扫雷界面
	init_board(mine, ROWS, COLS, '0');
	init_board(show, ROWS, COLS, '*');
	//打印扫雷界面
	//print_board(mine, ROW, COL);
	print_board(show, ROW, COL);
	//布置雷区
	set_mine(mine, ROW, COL);
	print_board(mine, ROW, COL);
	//排雷
	find_mine(mine,show, ROW, COL);
}
void meau()
{
	printf("************************\n");
	printf("*****   1、play    *****\n");
	printf("*****   0、exit    *****\n");
	printf("************************\n");
}
void test()
{
	int input = 0;
	do
	{
		meau();
		printf("请选择是否要开始游戏：");
		scanf("%d", &amp;input);
		switch (input)
		{
		case 1:
			game();
			break;
		case 0:
			printf("退出游戏。\n");
			break;
		default:
			printf("选择错误，请重新选择哦\n");
			break;
		}
	} while (input);
}
int main()
{
	test();
	return 0;
}</code></pre> 
<blockquote> 
 <p>  这里相对较难理解的是排雷时的展开，也是需要重点理解的地方。</p> 
 <p>  希望这篇文章能给你带来一个很好的理解，对你有所帮助，感谢阅读。</p> 
 <p>  后续会一直更新的哦ovo！</p> 
</blockquote>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/ae52a25e17452d5359c8ad2d31c1d1a8/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">PX4 磁罗盘干扰分析</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/f24313be203e530971f2148ed27e4a7a/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">Vue路由跳转的五种方式</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>