<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>C语言实现守护进程 - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="C语言实现守护进程" />
<meta property="og:description" content="C语言实现守护进程 守护进程（daemon）是在后台运行的一种特殊进程，它没有控制终端，通常用于在系统启动时启动一些需要常驻后台的服务程序。
Linux的大多数服务器就是用守护进程的方式实现的。如web服务器进程http等。守护进程在后台运行，类似于Windows中的系统服务。
查看系统中的进程：
ps axj 参数a表示不仅列当前用户的进程,也列出所有其他用户的进程,
参数x表示不仅列有控制终端的进程,也列出所无控制终端的进程,
参数j表示列出与作业控制相关的信息。
凡是TPGID一栏写着-1的都是没有控制终端的进程,也就是守护进程。在COMMAND一列用[]括起来的名字表示内核线程,这些线程在内核里创建,没有用户空间代码,
因此没有程序文件名和命令行, 通常采用以k开头的名字,表示Kernel。守护进程通 常采用以d结尾的名字,表示Daemon。
守护进程的原理是通过fork()创建一个子进程，让子进程脱离控制终端，设置新的会话组，关闭标准输入输出和错误输出，最后通过umask()函数来设置文件的权限掩码，使得守护进程在运行过程中不会被其他用户所访问。
daemon()守护进程函数
原型
int daemon(int nochdir,int noclose) 其中，nochdir参数用于指定是否改变工作目录，如果给它传递0，则工作目录将被设置为“/”（根目录），否则继续使用当前工作目录。
noclose参数为0时，标准输入、标准输出和标准错误输出都被重定向到/dev/null文件，否则依然使用原来的设备。
该函数成功时返回0，失败返回-1,并设置errno。
例如：
daemon(0,0)：nochdir为0 改为根目录，noclose为0 关闭所有文件描述符；
将当前工作目录更改为根目录的作用：
防止当前目录有一个目录被删除，导致守护进程无效。
使用fork（）创建的子进程是继承了父进程的当前工作目录，由于在进程运行中，当前目录所在的文件系统是不能卸载的，这对以后使用会造成很多的麻烦。
因此通常的做法是让“/”作为守护进程的当前目录，当然也可以指定其他的别的目录来作为守护进程的工作目录。
以下是用C语言实现守护进程的完整代码：
#include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; #include &lt;unistd.h&gt; #include &lt;signal.h&gt; #include &lt;sys/types.h&gt; #include &lt;sys/stat.h&gt; #include &lt;fcntl.h&gt; void daemonize() { pid_t pid; /* Step 1: Create a child process */ pid = fork(); if(pid &lt; 0) /* Error occurred */ { perror(&#34;" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/ebac461684478a407fe99cb5336f9c67/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-05-31T02:10:39+08:00" />
<meta property="article:modified_time" content="2023-05-31T02:10:39+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">C语言实现守护进程</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <h2><a id="C_0"></a>C语言实现守护进程</h2> 
<p>守护进程（daemon）是在后台运行的一种特殊进程，它没有控制终端，通常用于在系统启动时启动一些需要常驻后台的服务程序。</p> 
<p>Linux的大多数服务器就是用守护进程的方式实现的。如web服务器进程http等。守护进程在后台运行，类似于Windows中的系统服务。</p> 
<p><strong>查看系统中的进程：</strong></p> 
<pre><code>ps axj
</code></pre> 
<p>参数a表示不仅列当前用户的进程,也列出所有其他用户的进程,<br> 参数x表示不仅列有控制终端的进程,也列出所无控制终端的进程,<br> 参数j表示列出与作业控制相关的信息。</p> 
<p>凡是TPGID一栏写着-1的都是没有控制终端的进程,也就是守护进程。在COMMAND一列用[]括起来的名字表示内核线程,这些线程在内核里创建,没有用户空间代码,</p> 
<p>因此没有程序文件名和命令行, 通常采用以k开头的名字,表示Kernel。守护进程通 常采用以d结尾的名字,表示Daemon。</p> 
<p><strong>守护进程的原理</strong>是通过fork()创建一个子进程，让子进程脱离控制终端，设置新的会话组，关闭标准输入输出和错误输出，最后通过umask()函数来设置文件的权限掩码，使得守护进程在运行过程中不会被其他用户所访问。</p> 
<p><strong>daemon()守护进程函数</strong></p> 
<p>原型</p> 
<pre><code>int daemon(int nochdir,int noclose)
</code></pre> 
<p>其中，nochdir参数用于指定是否改变工作目录，如果给它传递0，则工作目录将被设置为“/”（根目录），否则继续使用当前工作目录。</p> 
<p>noclose参数为0时，标准输入、标准输出和标准错误输出都被重定向到/dev/null文件，否则依然使用原来的设备。</p> 
<p>该函数成功时返回0，失败返回-1,并设置errno。<br> 例如：<br> daemon(0,0)：nochdir为0 改为根目录，noclose为0 关闭所有文件描述符；</p> 
<p>将当前工作目录更改为根目录的作用：<br> 防止当前目录有一个目录被删除，导致守护进程无效。<br> 使用fork（）创建的子进程是继承了父进程的当前工作目录，由于在进程运行中，当前目录所在的文件系统是不能卸载的，这对以后使用会造成很多的麻烦。</p> 
<p>因此通常的做法是让“/”作为守护进程的当前目录，当然也可以指定其他的别的目录来作为守护进程的工作目录。</p> 
<p>以下是用C语言实现守护进程的完整代码：</p> 
<pre><code class="prism language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdlib.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;unistd.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;signal.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;sys/types.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;sys/stat.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;fcntl.h&gt;</span></span>

<span class="token keyword">void</span> <span class="token function">daemonize</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
  <span class="token class-name">pid_t</span> pid<span class="token punctuation">;</span>

  <span class="token comment">/* Step 1: Create a child process */</span>
  pid <span class="token operator">=</span> <span class="token function">fork</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

  <span class="token keyword">if</span><span class="token punctuation">(</span>pid <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token comment">/* Error occurred */</span>
  <span class="token punctuation">{<!-- --></span>
    <span class="token function">perror</span><span class="token punctuation">(</span><span class="token string">"fork"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">exit</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>

  <span class="token keyword">if</span><span class="token punctuation">(</span>pid <span class="token operator">&gt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token comment">/* Parent process, exit */</span>
  <span class="token punctuation">{<!-- --></span>
    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"Parent process: %d\n"</span><span class="token punctuation">,</span> pid<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">exit</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>

  <span class="token comment">/* Step 2: Create a new session */</span>
  <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token function">setsid</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span>
  <span class="token punctuation">{<!-- --></span>
    <span class="token function">perror</span><span class="token punctuation">(</span><span class="token string">"setsid"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">exit</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>

  <span class="token comment">/* Step 3: Change working directory */</span>
  <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token function">chdir</span><span class="token punctuation">(</span><span class="token string">"/"</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span>
  <span class="token punctuation">{<!-- --></span>
    <span class="token function">perror</span><span class="token punctuation">(</span><span class="token string">"chdir"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">exit</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>

  <span class="token comment">/* Step 4: Set file permissions */</span>
  <span class="token function">umask</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

  <span class="token comment">/* Step 5: Close all open file descriptors */</span>
  <span class="token function">close</span><span class="token punctuation">(</span>STDIN_FILENO<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token function">close</span><span class="token punctuation">(</span>STDOUT_FILENO<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token function">close</span><span class="token punctuation">(</span>STDERR_FILENO<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
  <span class="token function">daemonize</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

  <span class="token comment">/* Do daemon work here */</span>
  <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>
  <span class="token punctuation">{<!-- --></span>
    <span class="token comment">/* Do something */</span>
  <span class="token punctuation">}</span>

  <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>在上面的代码中，daemonize()函数用于创建守护进程。首先通过fork()函数创建一个子进程，然后让子进程调用setsid()函数创建一个新的会话组，使得守护进程与原来的终端完全隔离。接着调用chdir()函数将当前工作目录设置为根目录，防止守护进程占用当前工作目录的文件系统导致该文件系统无法卸载。调用umask()函数设置文件创建权限掩码，确保守护进程创建的文件权限不会被其他用户访问。最后，关闭所有的文件描述符，防止程序在后台运行时产生意料之外的输出。</p> 
<p>在调用了daemonize()函数之后，守护进程就开始后台运行了。通常情况下，守护进程会执行一些长期运行的任务，如网络连接、消息队列、数据备份等等。</p> 
<p>该文章会更新，欢迎大家批评指正。</p> 
<p>推荐一个零声学院免费公开课程，个人觉得老师讲得不错，<br> 分享给大家：[Linux，Nginx，ZeroMQ，MySQL，Redis，<br> fastdfs，MongoDB，ZK，流媒体，CDN，P2P，K8S，Docker，<br> TCP/IP，协程，DPDK等技术内容，点击立即学习:<br> 服务器课程：<a href="https://course.0voice.com/v1/course/intro?courseId=5&amp;agentId=0" rel="nofollow">C++服务器</a></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/330b1778dc96995e821d76ac8f521bc5/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">腾讯云 Finops Crane 集训营 &amp; 知识基础普及</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/566218e27efc1837e8e7689639e2b019/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">Linux命令(25)之more</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>