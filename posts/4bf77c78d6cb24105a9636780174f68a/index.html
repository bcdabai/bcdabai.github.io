<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>gitflow 是什么，有哪些优缺点？ - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="gitflow 是什么，有哪些优缺点？" />
<meta property="og:description" content="gitflow 是什么，有哪些优缺点？ 1. 什么是git2. git的优点3. GitFlow 协同工作流3.1 GitFlow的由来3.1 GitFlow中分支角色们3.2 GitFlow的优点3.3 GitFlow的缺点 总结 1. 什么是git Git是一个分布式的版本管理工具，它分为远程仓库（云端仓库，存在后端服务器中）（仓库：repository简写repo：）和本地仓库。本地和云端的仓库的维护机制是类似的，它们都是使用一个类似一个树形结构的数据结构来维护的。每次的文件内容的改变都是一个节点(blob节点)，每个commit都是一个tree节点，节点中附带代码的操作信息和节点类型。详见：传送门。
2. git的优点 git 是分布式的，有本地分支管理功能，所以，就算没有网络也可以进行本地的维护。git的每个变动都是一个节点因此，每次的文件内容的变动都可以单独保存并且可以逐个的进行应用管理。在所有代码合并后也可以看到所有变更内容，而其他的版本管理工具则不可以。由于git每次的变更都会生成一个完整的文件快照，所以它非常快。用空间来换取时间。由于git会面临内存问题，它有自己的内存维护机制比如：删掉无用的节点，压缩打包历史记录等…git有非常多的命令，可以灵活的使用。详见：传送门 3. GitFlow 协同工作流 其实GitFlow并非什么技术，而是一种代码开发合并管理流程的思维模式或者是管理方法。大家一起开发的一种软约定。
3.1 GitFlow的由来 我们为什么需要GitFlow这种git管理流程？原因有以下几点
有一个稳定版本的代码分支，可以安心的用在线上发布。在代码提测前或者说是代码达到预发状态时，在测试交付的过程中程序员们还可以继续进行下一个版本的开发工作（挤出每一秒去开发-_-’’）。有个一个分支可以让我们及时的对线上的bug进行修复，这个过程中我们不希望将正在开发中的代码提交到线上生产中去。 由于上述开发过程中面临的需求，GitFlow协同国祚流应运而生。对应的点就是
代码共享不同环境下代码互不干扰管理好代码与环境的一致性 3.1 GitFlow中分支角色们 Master 分支： 稳定版本代码分支，用作发布环境，上面的每次提交都是可以发布的。Feture 分支： 功能分支，用于开发功能（需求），用于开发环境Developer 分支: 开发分支， 一旦Feture分支内功能开发完成就将Feture中的代码合并到Developer分支中，合并完成后，删除该功能分支。这个分支对应的是集成测试环境。Release 分支：预发分支，做发布前的准备工作，对应的是预发环境。这个分支可以确保们开发继续向前，不会因为要发布不而被停滞住。一旦Release分支达到了可发布的状态，我们需要把Release分支同时向Master，Developer分支上合并，保持代码的一致性，然后把Release分支删除。Hotfix 分支： 线上bug修缮用的分支，每次修改线上代码的bug时都要用hotfix来维护，完成后向Developer和Master同时合并。完成后删除分支。 以上就是GitFlow中所有角色分支，从中我们可以看到以下几点：
Master和Developer需要我们长期维护，也是我们开发的主干线。其中relesase和hotfix两个分支的操作会很零碎，操作起来会比较麻烦，在这个过程中很容易产生失误，导致代码不一致。所以我们需要一个号的工具或者脚本来完成此步骤。这个套流程虽然麻烦，但是他可以应用到几乎所有的开发流程中：瀑布型，敏捷性（waterfall，agile） 3.2 GitFlow的优点 适应场景多不影响开发进度分支使用相对有条理确保线上的版本稳定 3.3 GitFlow的缺点 当然GitFlow并不是完美的，这只是种管理思维，一下是他的一些缺点：
因为分支态度，所以会出现git log混乱的局面：主要是因为git-flow使用git merge --no-ff来合并分支，在git-flow这种多分支的环境下会让整个项目的log变的非常混乱。 对于整个中情况我们可以：只有feature合并到developer分支时， 使用-no-ff参数，其他的合并都不使用–no-ff
** 什么是 git merge --no-ff：
--no-ff指的是强行关闭fast-forward方式。 fast-forward方式就是当条件允许的时候，git直接把HEAD指针指向合并分支的头，完成合并。属于“快进方式”， 不这种情况如果删除分支，则会丢失分支信息。因为在这个过程中没有创建commit git merge --squash 是用来把一些不必要commit进行压缩，比如说，你的feature在开发的时候写的commit很乱， 那么我们合并的时候不希望把这些历史commit带过来，于是使用--squash进行合并，此时文件已经同合并后一样了, 但不移动HEAD，不提交。需要进行一次额外的commit来“总结”一下，然后完成最终的合并。 总结： --no-ff：不使用fast-forward方式合并，保留分支的commit历史 --squash：使用squash方式合并，把多次分支commit历史压缩为一次 同时维护Master和Developer两个分支很多时候是没必要的，因为在很多场景下Master中的内容和Developer中的内容是差不多的。尤其当你想回滚某些人的提交时，你就会发现这事似乎有点儿不好干了。而且在工作过程中，你会来来回回地切换工作的分支，有时候一不小心没有切换，就提交到了不正确的分支上，你还要回滚和重新提交，等等。 总结 这么看下来GitFlow还是不错的，毕竟他的应用场景比较全面，确实解决了开发时分支混乱的问题，而且为我们提供了代码分支管理的策略和思维。但是它也并不是完美的。我感觉像这种分支管理的规范只是万千分支管理策略中的一种，我们完全可以自己去对它进行修改和调整找到适合自己团队的管理策略。在找寻自己策略时我们可以参考一下几点：" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/4bf77c78d6cb24105a9636780174f68a/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2021-04-02T18:06:40+08:00" />
<meta property="article:modified_time" content="2021-04-02T18:06:40+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">gitflow 是什么，有哪些优缺点？</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p></p> 
<div class="toc"> 
 <h4>gitflow 是什么，有哪些优缺点？</h4> 
 <ul><li><ul><li><a href="#1_git_4" rel="nofollow">1. 什么是git</a></li><li><a href="#2_git_8" rel="nofollow">2. git的优点</a></li><li><a href="#3_GitFlow__15" rel="nofollow">3. GitFlow 协同工作流</a></li><li><ul><li><a href="#31_GitFlow_17" rel="nofollow">3.1 GitFlow的由来</a></li><li><a href="#31_GitFlow_29" rel="nofollow">3.1 GitFlow中分支角色们</a></li><li><a href="#32_GitFlow_45" rel="nofollow">3.2 GitFlow的优点</a></li><li><a href="#33_GitFlow_52" rel="nofollow">3.3 GitFlow的缺点</a></li></ul> 
   </li><li><a href="#_77" rel="nofollow">总结</a></li></ul> 
 </li></ul> 
</div> 
<p></p> 
<h3><a id="1_git_4"></a>1. 什么是git</h3> 
<p>Git是一个分布式的版本管理工具，它分为远程仓库（云端仓库，存在后端服务器中）（仓库：repository简写repo：）和本地仓库。本地和云端的仓库的维护机制是类似的，它们都是使用一个类似一个树形结构的数据结构来维护的。每次的文件内容的改变都是一个节点(blob节点)，每个commit都是一个tree节点，节点中附带代码的操作信息和节点类型。详见：<a href="https://zhuanlan.zhihu.com/p/96631135" rel="nofollow">传送门</a>。</p> 
<h3><a id="2_git_8"></a>2. git的优点</h3> 
<ol><li>git 是分布式的，有本地分支管理功能，所以，就算没有网络也可以进行本地的维护。</li><li>git的每个变动都是一个节点因此，每次的文件内容的变动都可以单独保存并且可以逐个的进行应用管理。在所有代码合并后也可以看到所有变更内容，而其他的版本管理工具则不可以。</li><li>由于git每次的变更都会生成一个完整的文件快照，所以它非常快。用空间来换取时间。</li><li>由于git会面临内存问题，它有自己的内存维护机制比如：删掉无用的节点，压缩打包历史记录等…</li><li>git有非常多的命令，可以灵活的使用。详见：<a href="https://www.runoob.com/git/git-basic-operations.html" rel="nofollow">传送门</a></li></ol> 
<h3><a id="3_GitFlow__15"></a>3. GitFlow 协同工作流</h3> 
<p>其实GitFlow并非什么技术，而是一种代码开发合并管理流程的思维模式或者是管理方法。大家一起开发的一种软约定。</p> 
<h4><a id="31_GitFlow_17"></a>3.1 GitFlow的由来</h4> 
<p>我们为什么需要GitFlow这种git管理流程？原因有以下几点</p> 
<ol><li>有一个稳定版本的代码分支，可以安心的用在线上发布。</li><li>在代码提测前或者说是代码达到预发状态时，在测试交付的过程中程序员们还可以继续进行下一个版本的开发工作（挤出每一秒去开发-_-’’）。</li><li>有个一个分支可以让我们及时的对线上的bug进行修复，这个过程中我们不希望将正在开发中的代码提交到线上生产中去。</li></ol> 
<p>由于上述开发过程中面临的需求，GitFlow协同国祚流应运而生。对应的点就是</p> 
<ol><li>代码共享</li><li>不同环境下代码互不干扰</li><li>管理好代码与环境的一致性</li></ol> 
<h4><a id="31_GitFlow_29"></a>3.1 GitFlow中分支角色们</h4> 
<p><img src="https://images2.imgbox.com/6c/de/D8Eb0Q7h_o.png" alt="在这里插入图片描述"></p> 
<ol><li>Master 分支： 稳定版本代码分支，用作发布环境，上面的每次提交都是可以发布的。</li><li>Feture 分支： 功能分支，用于开发功能（需求），用于开发环境</li><li>Developer 分支: 开发分支， 一旦Feture分支内功能开发完成就将Feture中的代码合并到Developer分支中，合并完成后，删除该功能分支。这个分支对应的是集成测试环境。</li><li>Release 分支：预发分支，做发布前的准备工作，对应的是预发环境。这个分支可以确保们开发继续向前，不会因为要发布不而被停滞住。一旦Release分支达到了可发布的状态，我们需要把Release分支同时向Master，Developer分支上合并，保持代码的一致性，然后把Release分支删除。</li><li>Hotfix 分支： 线上bug修缮用的分支，每次修改线上代码的bug时都要用hotfix来维护，完成后向Developer和Master同时合并。完成后删除分支。</li></ol> 
<p>以上就是GitFlow中所有角色分支，从中我们可以看到以下几点：</p> 
<ol><li>Master和Developer需要我们长期维护，也是我们开发的主干线。</li><li>其中relesase和hotfix两个分支的操作会很零碎，操作起来会比较麻烦，在这个过程中很容易产生失误，导致代码不一致。所以我们需要一个号的工具或者脚本来完成此步骤。</li><li>这个套流程虽然麻烦，但是他可以应用到几乎所有的开发流程中：瀑布型，敏捷性（waterfall，agile）</li></ol> 
<h4><a id="32_GitFlow_45"></a>3.2 GitFlow的优点</h4> 
<ol><li>适应场景多</li><li>不影响开发进度</li><li>分支使用相对有条理</li><li>确保线上的版本稳定</li></ol> 
<h4><a id="33_GitFlow_52"></a>3.3 GitFlow的缺点</h4> 
<p>当然GitFlow并不是完美的，这只是种管理思维，一下是他的一些缺点：</p> 
<ol><li>因为分支态度，所以会出现git log混乱的局面：主要是因为git-flow使用git merge --no-ff来合并分支，在git-flow这种多分支的环境下会让整个项目的log变的非常混乱。</li></ol> 
<p><img src="https://images2.imgbox.com/37/29/l77ymJCS_o.png" alt="在这里插入图片描述"><br> 对于整个中情况我们可以：只有feature合并到developer分支时， 使用-no-ff参数，其他的合并都不使用–no-ff<br> ** <a href="https://segmentfault.com/q/1010000002477106" rel="nofollow">什么是 git merge --no-ff</a>：</p> 
<pre><code>	--no-ff指的是强行关闭fast-forward方式。
	fast-forward方式就是当条件允许的时候，git直接把HEAD指针指向合并分支的头，完成合并。属于“快进方式”，
	不这种情况如果删除分支，则会丢失分支信息。因为在这个过程中没有创建commit
	  
	git merge --squash 是用来把一些不必要commit进行压缩，比如说，你的feature在开发的时候写的commit很乱，
	那么我们合并的时候不希望把这些历史commit带过来，于是使用--squash进行合并，此时文件已经同合并后一样了,
	但不移动HEAD，不提交。需要进行一次额外的commit来“总结”一下，然后完成最终的合并。
	
	总结：
	--no-ff：不使用fast-forward方式合并，保留分支的commit历史
	--squash：使用squash方式合并，把多次分支commit历史压缩为一次
</code></pre> 
<ol start="2"><li>同时维护Master和Developer两个分支很多时候是没必要的，因为在很多场景下Master中的内容和Developer中的内容是差不多的。尤其当你想回滚某些人的提交时，你就会发现这事似乎有点儿不好干了。而且在工作过程中，你会来来回回地切换工作的分支，有时候一不小心没有切换，就提交到了不正确的分支上，你还要回滚和重新提交，等等。</li></ol> 
<h3><a id="_77"></a>总结</h3> 
<p>这么看下来GitFlow还是不错的，毕竟他的应用场景比较全面，确实解决了开发时分支混乱的问题，而且为我们提供了代码分支管理的策略和思维。但是它也并不是完美的。我感觉像这种分支管理的规范只是万千分支管理策略中的一种，我们完全可以自己去对它进行修改和调整找到适合自己团队的管理策略。在找寻自己策略时我们可以参考一下几点：</p> 
<ol><li>不同团队保持并行开发</li><li>软件版本和代码的一致性</li><li>环境和代码的一致性</li><li>保证线上有个稳定的代码源</li><li>结合DevOps为主的开发流程（这个才是根本，才是未来）</li></ol> 
<p>下面提供其他的一些策略，有兴趣的小伙伴可以自行查阅：<br> 6. GitHub Flow<br> 7. GitLab Flow</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/c7e96cd0c98bc13c7a96d5f66226eadd/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">清华裴丹：AIOps九大发展趋势</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/0a5ca60f2a586ba5e1a20b96ae8b085b/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">多角度对比数据中心常见的三种走线方式</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>