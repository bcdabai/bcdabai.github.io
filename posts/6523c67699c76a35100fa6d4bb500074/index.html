<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>单列的堆叠柱状图 - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="单列的堆叠柱状图" />
<meta property="og:description" content="目的 MSingleColumnStackBarChart类被设计用于创建只有单列的堆叠柱状图，用于血糖数据的统计。以下是封装这个类的目的的详细描述：
抽象复杂性： 通过创建MSingleColumnStackBarChart类，你将复杂的MPAndroidChart库的使用和配置封装在一个独立的类中。这有助于降低代码的复杂性，使得在其他部分的代码中更容易理解和维护。
提高可读性： 将与图表配置相关的代码集中在一个类中，使得主要的业务逻辑部分的代码更加清晰。其他开发者在查看代码时能够更轻松地理解图表的配置和使用方式。
重用性： 通过封装这个类，你可以在不同的部分或项目中重复使用相同的图表配置。这意味着，如果将来有其他地方需要显示类似的单列堆叠柱状图，你可以轻松地引入这个类，而无需重新实现相同的配置。
模块化： 类的封装使得代码更加模块化。这允许你将图表的配置和数据处理与其他功能分离，促使代码更易于组织和维护。
简化调用： 通过提供简单的接口，类的使用者只需几行代码就能创建和显示单列堆叠柱状图。这有助于降低使用图表功能时的学习曲线，并使代码更加整洁。
总体而言，MSingleColumnStackBarChart类的封装旨在提供一种简单、灵活且易于使用的方式，以满足特定场景下（如血糖数据统计）显示单列堆叠柱状图的需求。这样的封装是为了在开发中提高效率、降低出错概率，并促使代码更具可维护性。
示例 中间的就是柱状形，只要按百分比进行堆叠显示。
调用示例 List&lt;MSingleColumnStackBarChart.MBarData&gt; dataList = new ArrayList&lt;&gt;(); for (int x = 0; x &lt; 1; x&#43;&#43;) { MSingleColumnStackBarChart.MBarData data = new MSingleColumnStackBarChart.MBarData(15, getColor(R.color.colorHHigh), &#34;15% 很高 &gt; 13.0 mmol/L&#34;); dataList.add(data); data = new MSingleColumnStackBarChart.MBarData(10, getColor(R.color.colorHigh), &#34;10% 偏高 &gt; 10.0 mmol/L&#34;); dataList.add(data); data = new MSingleColumnStackBarChart.MBarData(60, getColor(R.color.colorNormal), &#34;60% 正常 3.9-10.0 mmol/L&#34;); dataList.add(data); data = new MSingleColumnStackBarChart.MBarData(10, getColor(R.color.colorLow), &#34;" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/6523c67699c76a35100fa6d4bb500074/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2024-01-15T15:22:09+08:00" />
<meta property="article:modified_time" content="2024-01-15T15:22:09+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">单列的堆叠柱状图</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <h5>目的</h5> 
<p><code>MSingleColumnStackBarChart</code>类被设计用于创建只有单列的堆叠柱状图，用于血糖数据的统计。以下是封装这个类的目的的详细描述：</p> 
<ol><li> <p><strong>抽象复杂性：</strong> 通过创建<code>MSingleColumnStackBarChart</code>类，你将复杂的MPAndroidChart库的使用和配置封装在一个独立的类中。这有助于降低代码的复杂性，使得在其他部分的代码中更容易理解和维护。</p> </li><li> <p><strong>提高可读性：</strong> 将与图表配置相关的代码集中在一个类中，使得主要的业务逻辑部分的代码更加清晰。其他开发者在查看代码时能够更轻松地理解图表的配置和使用方式。</p> </li><li> <p><strong>重用性：</strong> 通过封装这个类，你可以在不同的部分或项目中重复使用相同的图表配置。这意味着，如果将来有其他地方需要显示类似的单列堆叠柱状图，你可以轻松地引入这个类，而无需重新实现相同的配置。</p> </li><li> <p><strong>模块化：</strong> 类的封装使得代码更加模块化。这允许你将图表的配置和数据处理与其他功能分离，促使代码更易于组织和维护。</p> </li><li> <p><strong>简化调用：</strong> 通过提供简单的接口，类的使用者只需几行代码就能创建和显示单列堆叠柱状图。这有助于降低使用图表功能时的学习曲线，并使代码更加整洁。</p> </li></ol> 
<p>总体而言，<code>MSingleColumnStackBarChart</code>类的封装旨在提供一种简单、灵活且易于使用的方式，以满足特定场景下（如血糖数据统计）显示单列堆叠柱状图的需求。这样的封装是为了在开发中提高效率、降低出错概率，并促使代码更具可维护性。</p> 
<h5>示例 </h5> 
<p>中间的就是柱状形，只要按百分比进行堆叠显示。</p> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/0b/6e/ww1pV9qg_o.png"></p> 
<p style="text-align:center;"></p> 
<h5>调用示例</h5> 
<pre><code class="language-java">List&lt;MSingleColumnStackBarChart.MBarData&gt; dataList = new ArrayList&lt;&gt;();

for (int x = 0; x &lt; 1; x++) {
    MSingleColumnStackBarChart.MBarData data = new MSingleColumnStackBarChart.MBarData(15, getColor(R.color.colorHHigh), "15% 很高 &gt; 13.0 mmol/L");
    dataList.add(data);

    data = new MSingleColumnStackBarChart.MBarData(10, getColor(R.color.colorHigh), "10% 偏高 &gt; 10.0 mmol/L");
    dataList.add(data);

    data = new MSingleColumnStackBarChart.MBarData(60, getColor(R.color.colorNormal), "60% 正常 3.9-10.0 mmol/L");
    dataList.add(data);

    data = new MSingleColumnStackBarChart.MBarData(10, getColor(R.color.colorLow), "10% 偏低 &lt; 3.9 mmol/L");
    dataList.add(data);

    data = new MSingleColumnStackBarChart.MBarData(5, getColor(R.color.colorLLow), "5% 很低 &lt; 3.0 mmol/L ");
    dataList.add(data);
}

BarChart barChart = findViewById(R.id.bar_chart);
MSingleColumnStackBarChart barChartView = new MSingleColumnStackBarChart(barChart);
barChartView.setBarDataSets(dataList);
</code></pre> 
<h5>完整的代码实现类</h5> 
<pre><code class="language-java">package com.jaredrummler.compent;

import android.graphics.Color;
import android.graphics.PointF;

import com.github.mikephil.charting.charts.BarChart;
import com.github.mikephil.charting.components.Legend;
import com.github.mikephil.charting.components.LegendEntry;
import com.github.mikephil.charting.components.XAxis;
import com.github.mikephil.charting.components.YAxis;
import com.github.mikephil.charting.data.BarData;
import com.github.mikephil.charting.data.BarDataSet;
import com.github.mikephil.charting.data.BarEntry;
import com.github.mikephil.charting.data.Entry;
import com.github.mikephil.charting.formatter.ValueFormatter;
import com.github.mikephil.charting.highlight.Highlight;
import com.github.mikephil.charting.listener.OnChartValueSelectedListener;

import java.util.ArrayList;
import java.util.List;
import java.util.stream.Collectors;

/**
 * author ：hello
 * date : 2024/1/15 8:47
 * description : 只有一列数据的StackBarChart
 */
public class MSingleColumnStackBarChart {
    private BarChart barChart;
    private MLegend mLegend;
    public MSingleColumnStackBarChart(BarChart barChart) {
        this.barChart = barChart;
        this.mLegend = new MLegend();
        init();
    }

    public void setBarDataSets(List&lt;MBarData&gt; dataList) {
        MBarDataSet barDataSet = new MBarDataSet(0, dataList);
        BarData barData = new BarData(barDataSet.getBarDataSet());
        barData.setBarWidth(.8f);

        this.barChart.setData(barData);
        this.mLegend.setLegendConfig(barDataSet.getBarDataSetsColors(), barDataSet.getBarLegendLabels().toArray(new String[0]));
        this.barChart.invalidate();
    }

    public void init() {
        setXAxisConfig();
        setYAxisConfig();

        ///所有值均绘制在其条形顶部上方
        barChart.setDrawValueAboveBar(false);
        // 添加下面这行代码，关闭堆叠模式
        barChart.setDrawBarShadow(false);

        barChart.setFitBars(true);
        barChart.getDescription().setEnabled(false);
        barChart.animateXY(1000,1000);

        //选中高亮显示
        barChart.setHighlightFullBarEnabled(false);
        //双击缩放
        barChart.setDoubleTapToZoomEnabled(false);
        // 设置 是否可以缩放
        barChart.setScaleEnabled(false);
        barChart.setDrawGridBackground(false);

        barChart.setOnChartValueSelectedListener(new OnChartValueSelectedListener() {
            @Override
            public void onValueSelected(Entry e, Highlight h) {
                mLegend.showLegendSelected(h.getStackIndex());

            }



            @Override
            public void onNothingSelected() {
                mLegend.resetLegendDefault();
            }
        });

        barChart.invalidate(); // 刷新图表
    }
    private void setXAxisConfig() {
        // 使柱状图的中心与 X 轴标签对齐
        XAxis xAxis = barChart.getXAxis();
        xAxis.setEnabled(false);
        xAxis.setDrawLabels(false);
        //取消 垂直 网格线
        xAxis.setDrawGridLines(false);
    }

    private void setYAxisConfig() {
        YAxis yLeftAxis = barChart.getAxisLeft();
        yLeftAxis.setEnabled(false);
        yLeftAxis.setDrawLabels(false);
        yLeftAxis.setDrawGridLines(false);
        yLeftAxis.setAxisMinimum(0);
        yLeftAxis.setAxisMaximum(100);
        YAxis yRightAxis = barChart.getAxisRight();
        yRightAxis.setEnabled(false);
        yRightAxis.setDrawLabels(false);
        yRightAxis.setDrawGridLines(false);
    }

    private static class MBarDataSet {
        private BarDataSet barDataSet;
        private List&lt;BarEntry&gt; barEntries;
        private List&lt;MBarData&gt; dataList;
        public MBarDataSet(int index, List&lt;MBarData&gt; dataList) {
            this.dataList = dataList;
            barEntries = covertToBarEntry(index, dataList);
            barDataSet = new BarDataSet(barEntries, "");
            barDataSet.setColors(dataList.stream().map(MBarData::getColor).collect(Collectors.toList()));
//            barDataSet.setValueTextSize(10f);
            barDataSet.setDrawValues(false);
//            barDataSet.setValueTextColor(Color.WHITE);
//            barDataSet.setValueFormatter(new ValueFormatter() {
//                @Override
//                public String getFormattedValue(float value) {
//                    return String.format("%.1f", value) + "%";
//                }
//
//            }); // 设置值文本的位置为外部
            barDataSet.setBarShadowColor(Color.WHITE);
            barDataSet.setBarBorderWidth(2f);
            barDataSet.setBarBorderColor(Color.WHITE);
        }

        public BarDataSet getBarDataSet() {
            return barDataSet;
        }

        public List&lt;BarEntry&gt; getBarEntries() {
            return barEntries;
        }

        private List&lt;BarEntry&gt; covertToBarEntry(float index, List&lt;MBarData&gt; dataList) {
            // y 数据
            ArrayList&lt;BarEntry&gt; yValues = new ArrayList&lt;&gt;();

            float[] stackedValues = new float[dataList.size()];

            // 遍历 yourDataList，获取每个数据项的百分比值，构建堆叠数据
            for (int i = 0; i &lt; dataList.size(); i++) {
                float yValue = dataList.get(i).getYValue();
                stackedValues[i] = yValue;
            }

            BarEntry barEntry = new BarEntry(index, stackedValues);
            yValues.add(barEntry);

            return yValues;
        }

        private List&lt;Integer&gt; getBarDataSetsColors() {
            List&lt;Integer&gt; barColors = new ArrayList&lt;&gt;();

            for (MBarData data : this.dataList) {
                barColors.add(data.getColor());
            }

            return barColors;
        }

        private List&lt;String&gt; getBarLegendLabels() {
            List&lt;String&gt; legendLabels = new ArrayList&lt;&gt;();

            for (MBarData data : this.dataList) {
                legendLabels.add(data.getLabel());
            }

            return legendLabels;
        }
    }

    public static class MBarData {
        private float yValue;
        private int color;
        private String label;

        public MBarData(float percentage, int color, String label) {
            this.yValue = percentage;
            this.color = color;
            this.label = label;
        }

        public float getYValue() {
            return yValue;
        }

        public int getColor() {
            return color;
        }

        public String getLabel() {
            return label;
        }
    }

    private class MLegend {
        public static final float SELECTED_FORM_SIZE = 16f;
        public static final float DEFAULT_FORM_SIZE = 10f;
        public void showLegendSelected(int index) {
            // 选中时突出显示相应的 Legend 标签
            // 获取 Legend 对象
            Legend legend = barChart.getLegend();
            // 获取当前 Legend 的条目
            LegendEntry[] entries = legend.getEntries();

            for (int i = 0; i &lt; entries.length; i++) {
                if (i == index) {
                    entries[index].formSize = SELECTED_FORM_SIZE;
                } else {
                    entries[i].formSize = DEFAULT_FORM_SIZE;
                }
            }
            // 刷新图表
            barChart.invalidate();
        }

        public void resetLegendDefault() {
            // 获取当前 Legend 的条目
            // 获取 Legend 对象
            Legend legend = barChart.getLegend();
            LegendEntry[] entries = legend.getEntries();

            for (int i = 0; i &lt; entries.length; i++) {
                entries[i].formSize = DEFAULT_FORM_SIZE;
            }
            barChart.invalidate();
        }

        public void setLegendConfig(List&lt;Integer&gt; barColors, String[] legendLabels) {
            Legend legend = barChart.getLegend();
            legend.setFormToTextSpace(8f);
            legend.setStackSpace(16f);
            legend.setForm(Legend.LegendForm.CIRCLE);
            legend.setTextSize(14f);

            YAxis yAxis = barChart.getAxisLeft();
            float spaceTop = yAxis.getSpaceTop();
            float spaceBottom = yAxis.getSpaceBottom();
            float yAxisHeight = yAxis.getAxisMaximum() - spaceTop - spaceBottom;
            legend.setYEntrySpace(yAxisHeight / (legendLabels.length));
            legend.setYOffset(spaceTop);
            legend.setVerticalAlignment(Legend.LegendVerticalAlignment.TOP);
            legend.setHorizontalAlignment(Legend.LegendHorizontalAlignment.RIGHT);
            legend.setOrientation(Legend.LegendOrientation.VERTICAL);
            legend.setStackSpace(1f);
            legend.setDrawInside(false);

            if (legendLabels != null &amp;&amp; legendLabels.length &gt; 0) {
                List&lt;LegendEntry&gt; legendEntries = new ArrayList&lt;&gt;();
                for (int i = 0; i &lt; legendLabels.length; i++) {
                    LegendEntry entry = new LegendEntry();
                    entry.label = legendLabels[i];
                    entry.formColor = barColors.get(i);
                    entry.formSize = 10f;
                    legendEntries.add(entry);
                }
                legend.setCustom(legendEntries);
            }
        }
    }
}
</code></pre> 
<p></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/592b9541e668cd0a4abbdba7e510f0e1/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">redis7部署集群：包含主从模式、哨兵模式、Cluster集群模式等三种模式</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/258e70438e295727fad5407e1b777c5f/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">修改git代码提交路径</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>