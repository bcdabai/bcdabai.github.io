<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>C&#43;&#43; 重写关键字override(强制编译器检查该函数是否覆盖已存在的虚函数) - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="C&#43;&#43; 重写关键字override(强制编译器检查该函数是否覆盖已存在的虚函数)" />
<meta property="og:description" content="override关键字的作用：
从字面意思上，是覆盖的意思，实际上在C&#43;&#43;中它是覆盖了一个方法并且对其重写，从而达到不同的作用.
如果派生类在虚函数声明时使用了override描述符，那么该函数必须重载其基类中的同名函数，否则代码将无法通过编译。
C&#43;&#43;中的关键字override（重载）用于在派生类中声明一个函数与其基类中同名函数的关系。当派生类在虚函数声明时使用override描述符时，需要重载其基类中的同名函数，否则编译器将会提示错误。
这是因为在C&#43;&#43;中，虚函数的定义与函数重载非常相似。虚函数定义的方式是使用关键字virtual在函数声明中进行声明，同时可以通过重载来指定函数的行为。如果派生类重载了基类中的同名函数，则该函数将成为派生类中的虚函数，可以通过调用基类中的函数来实现该函数的功能。如果派生类未重载基类中的同名函数，则该函数将被认为是虚函数，并且无法直接访问。这样就保证了代码的灵活性和可维护性，同时也提高了代码的可读性和可理解性。因此，在C&#43;&#43;中，override关键字是非常重要的一个特性，对于实现灵活的类型重载和抽象函数的使用非常有帮助。
注意
在C&#43;&#43;中，override关键字是可选的，用于显式地指示编译器一个成员函数（通常是虚函数）是重写了基类中的同名函数。如果你不使用override关键字，编译器仍然会执行重写行为，只要函数的签名与基类中的虚函数相匹配。
override的使用条件：
基类成员函数为虚函数（virtual）
派生类中重写该成员函数
函数签名必须完全匹配：派生类中的函数必须与基类中被重写的虚函数在函数签名上完全匹配，包括函数名、参数类型、常量性（const）和引用修饰符（&amp;或&amp;&amp;）。否则，编译器将不会认为这是一个重写，而是一个新的函数。
返回类型可以协变：在C&#43;&#43;中，重写虚函数的返回类型可以是基类虚函数返回类型的子类。这被称为返回类型协变。例如，如果基类虚函数的返回类型是Base*或Base&amp;，那么派生类中重写的函数的返回类型可以是Derived*或Derived&amp;，其中Derived是Base的子类。
只能重写公有和保护的虚函数：你只能重写基类中的公有和保护的虚函数。私有虚函数不能在派生类中被重写，因为它们在派生类中不可见。
不能重写非虚函数：override关键字只能用于重写虚函数。如果你尝试使用override关键字重写一个非虚函数，编译器会报错。
不能改变虚函数的默认参数：虽然C&#43;&#43;允许你在派生类中为重写的虚函数提供不同的默认参数，但这通常是一个坏主意，因为它可能会导致意外的行为。当你通过基类指针或引用调用虚函数时，将使用基类版本的默认参数，而不是派生类版本的默认参数。
使用override 关键字的好处：
程序员的意图更清晰：通过在派生类中使用override关键字，可以清楚地表明该函数是对基类中的虚函数的重写。这使得代码更易读，更易理解。
让编译器发现一些错误：如果你标记了一个函数为override，但它并没有真正重写任何基类中的函数，编译器会报错。这可以帮助你捕获一些可能的错误，例如函数签名的误差。
提高代码的维护性：如果基类的虚函数在未来发生改变（例如参数类型或数量的改变），但是派生类中的重写函数没有相应地改变，那么使用了override关键字的函数会在编译时报错，这样可以及时发现并修复问题。
提高代码的稳定性：使用override关键字可以确保当基类的虚函数接口改变时，所有的派生类都会得到更新，否则编译器会报错。这可以防止因接口改变而导致的运行时错误。
提高代码的可读性和可理解性：override关键字明确地表明了函数是重写了基类中的函数，这对于阅读和理解代码非常有帮助。
C&#43;&#43; override 关键字的来源：
C&#43;&#43;的override关键字是在C&#43;&#43;11标准中引入的。在C&#43;&#43;11之前，C&#43;&#43;并没有提供一种明确的方式来表明一个函数是重写了基类中的虚函数。这可能会导致一些错误，例如如果派生类中的函数签名与基类中的虚函数不完全匹配，那么这个函数可能不会被视为重写，而编译器也不会报错。
为了解决这个问题，C&#43;&#43;11引入了override关键字。通过在派生类中使用override关键字，可以清楚地表明该函数是对基类中的虚函数的重写。如果这个函数并没有真正重写任何基类中的函数，编译器会报错。
这个特性使得C&#43;&#43;的代码更加安全，更易于维护。它可以帮助程序员避免一些常见的错误，例如误打误写导致的函数签名不匹配，以及在基类中添加或修改虚函数时忘记更新派生类中的函数等。
使用示例
#include&lt;iostream&gt; using namespace std; class Base { public: // 虚函数 virtual void statmem() { cout &lt;&lt; &#34;基类函数&#34; &lt;&lt; endl; } }; class Derived :public Base { public: // override 重写 // final 不允许后续其它类覆盖 void statmem() override final { cout &lt;&lt; &#34;" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/b07bca9b606642d2182c62aac7e561af/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-10-23T17:32:25+08:00" />
<meta property="article:modified_time" content="2023-10-23T17:32:25+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">C&#43;&#43; 重写关键字override(强制编译器检查该函数是否覆盖已存在的虚函数)</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p><strong>override关键字的作用：</strong></p> 
<p>从字面意思上，是覆盖的意思，实际上在C++中它是覆盖了一个方法并且对其重写，从而达到不同的作用.<br> 如果派生类在虚函数声明时使用了override描述符，那么该函数必须重载其基类中的同名函数，否则代码将无法通过编译。</p> 
<p>C++中的关键字override（重载）用于在派生类中声明一个函数与其基类中同名函数的关系。当派生类在虚函数声明时使用override描述符时，需要重载其基类中的同名函数，否则编译器将会提示错误。</p> 
<p>这是因为在C++中，虚函数的定义与函数重载非常相似。虚函数定义的方式是使用关键字virtual在函数声明中进行声明，同时可以通过重载来指定函数的行为。如果派生类重载了基类中的同名函数，则该函数将成为派生类中的虚函数，可以通过调用基类中的函数来实现该函数的功能。如果派生类未重载基类中的同名函数，则该函数将被认为是虚函数，并且无法直接访问。这样就保证了代码的灵活性和可维护性，同时也提高了代码的可读性和可理解性。因此，在C++中，override关键字是非常重要的一个特性，对于实现灵活的类型重载和抽象函数的使用非常有帮助。</p> 
<blockquote> 
 <p>注意<br> 在C++中，override关键字是可选的，用于显式地指示编译器一个成员函数（通常是虚函数）是重写了基类中的同名函数。如果你不使用override关键字，编译器仍然会执行重写行为，只要函数的签名与基类中的虚函数相匹配。</p> 
</blockquote> 
<p><strong>override的使用条件：</strong><br><strong>基类成员函数为虚函数（virtual）<br> 派生类中重写该成员函数</strong><br><strong>函数签名必须完全匹配</strong>：派生类中的函数必须与基类中被重写的虚函数在函数签名上完全匹配，包括函数名、参数类型、常量性（const）和引用修饰符（&amp;或&amp;&amp;）。否则，编译器将不会认为这是一个重写，而是一个新的函数。<br><strong>返回类型可以协变</strong>：在C++中，重写虚函数的返回类型可以是基类虚函数返回类型的子类。这被称为返回类型协变。例如，如果基类虚函数的返回类型是Base*或Base&amp;，那么派生类中重写的函数的返回类型可以是Derived*或Derived&amp;，其中Derived是Base的子类。<br><strong>只能重写公有和保护的虚函数</strong>：你只能重写基类中的公有和保护的虚函数。私有虚函数不能在派生类中被重写，因为它们在派生类中不可见。<br><strong>不能重写非虚函数</strong>：override关键字只能用于重写虚函数。如果你尝试使用override关键字重写一个非虚函数，编译器会报错。<br><strong>不能改变虚函数的默认参数</strong>：虽然C++允许你在派生类中为重写的虚函数提供不同的默认参数，但这通常是一个坏主意，因为它可能会导致意外的行为。当你通过基类指针或引用调用虚函数时，将使用基类版本的默认参数，而不是派生类版本的默认参数。<br><br><strong>使用override 关键字的好处：</strong><br><strong>程序员的意图更清晰</strong>：通过在派生类中使用override关键字，可以清楚地表明该函数是对基类中的虚函数的重写。这使得代码更易读，更易理解。<br><strong>让编译器发现一些错误</strong>：如果你标记了一个函数为override，但它并没有真正重写任何基类中的函数，编译器会报错。这可以帮助你捕获一些可能的错误，例如函数签名的误差。<br><strong>提高代码的维护性</strong>：如果基类的虚函数在未来发生改变（例如参数类型或数量的改变），但是派生类中的重写函数没有相应地改变，那么使用了override关键字的函数会在编译时报错，这样可以及时发现并修复问题。<br><strong>提高代码的稳定性</strong>：使用override关键字可以确保当基类的虚函数接口改变时，所有的派生类都会得到更新，否则编译器会报错。这可以防止因接口改变而导致的运行时错误。<br> 提高代码的可读性和可理解性：override关键字明确地表明了函数是重写了基类中的函数，这对于阅读和理解代码非常有帮助。<br><br><strong>C++ override 关键字的来源：</strong><br> C++的override关键字是在C++11标准中引入的。在C++11之前，C++并没有提供一种明确的方式来表明一个函数是重写了基类中的虚函数。这可能会导致一些错误，例如如果派生类中的函数签名与基类中的虚函数不完全匹配，那么这个函数可能不会被视为重写，而编译器也不会报错。</p> 
<p>为了解决这个问题，C++11引入了override关键字。通过在派生类中使用override关键字，可以清楚地表明该函数是对基类中的虚函数的重写。如果这个函数并没有真正重写任何基类中的函数，编译器会报错。</p> 
<p>这个特性使得C++的代码更加安全，更易于维护。它可以帮助程序员避免一些常见的错误，例如误打误写导致的函数签名不匹配，以及在基类中添加或修改虚函数时忘记更新派生类中的函数等。</p> 
<p>使用示例</p> 
<pre><code class="language-cpp">#include&lt;iostream&gt;

using namespace std;

class Base
{
public:
    // 虚函数
  virtual void statmem()
  {
    cout &lt;&lt; "基类函数" &lt;&lt; endl;
  }
};

class Derived :public Base
{
public:
  // override 重写
  // final 不允许后续其它类覆盖
  void statmem() override final
  {
    cout &lt;&lt; "派生类函数" &lt;&lt; endl;
  }
};

// 多态
int main()
{
  Base base;
  Derived derived;
  base.statmem(); // 基类函数
  derived.statmem(); // 派生类函数

  // 将derived的Base部分拷贝给base2
  Base base2(derived);
  base2.statmem(); // 基类函数
  
  // 动态绑定只有当我们通过指针或引用调用虚函数时才会发生
  // 基类调用它的派生类函数
  Base *base3 = &amp;derived; 
  base3-&gt;statmem(); // 派生类函数

  Base *base4(&amp;derived);
  base4-&gt;statmem(); // 派生类函数

  // 派生类调用它的基类函数
  Derived derived1;
  derived.Base::statmem(); // 基类函数

  Derived *derived2 = &amp;derived;
  derived2-&gt;Base::statmem(); // 基类函数

  return 0;
}</code></pre> 
<p><br> 原文链接：</p> 
<p><a href="https://liucjy.blog.csdn.net/article/details/131624785" rel="nofollow" title="【C++ 关键字 override】C++ 重写关键字override(强制编译器检查该函数是否覆盖已存在的虚函数)_c++ override_泡沫o0的博客-CSDN博客">【C++ 关键字 override】C++ 重写关键字override(强制编译器检查该函数是否覆盖已存在的虚函数)_c++ override_泡沫o0的博客-CSDN博客</a></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/d3cceebce3e4ecc82f232622bec014c3/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">java: 警告: 源发行版 8 需要目标发行版 1.8；(可我的项目是其他版本啊？)</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/529f973f7b7454591ffac82c6e8fd924/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">C&#43;&#43; mutable、 final及noexcept 关键字</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>