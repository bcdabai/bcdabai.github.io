<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>python 多线程请求带参数的多个接口 - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="python 多线程请求带参数的多个接口" />
<meta property="og:description" content="python 多线程请求带参数的多个接口 对于进程/线程/携程/异步的内容 有时间准备写写了 真的一直用for去循环慢到怀疑人生 需要运用的场景也会很多 所以分开一点点总结一下 先上代码看一下内容，多线程请求接口
imoprt threading # 首先运用到threading模块 class BrushGifts: # 以下是两个相同的接口 send_gift_room_one()是送礼的接口 # 也就是说我想完成的状态是A送B B送A 两个用户同时想对方赠送礼物 def giftt(self, uid, recvUid, giftId): &#34;&#34;&#34; 送礼接口 :param uid: 送礼用户 :param recvUid: 收礼用户 :param giftId: 礼物道具id :return: &#34;&#34;&#34; VoiceRoom().send_gift_room_one(uid, recvUid, giftId) def giftt_a(self, uid, recvUid, giftId): # 与上面的接口相同 不多做叙述 # 没什么区别 就是写着好理解俩接口的概念 VoiceRoom().send_gift_room_one(recvUid, uid, giftId) if __name__ == &#39;__main__&#39;: # 因为我的账号是储存在yaml文件内 所以需要先倒出需要用户的uid列表 # 送礼人与收礼人分别倒出 uid_list = YamlHandler(YamlThePath().voice_room_cpNew).get_uid_list(10) rUid_list = YamlHandler(YamlThePath()." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/e27b476ea43e62f0197be49d67a77dc2/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-03-14T14:51:18+08:00" />
<meta property="article:modified_time" content="2022-03-14T14:51:18+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">python 多线程请求带参数的多个接口</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p></p> 
<div class="toc"> 
 <h4>python 多线程请求带参数的多个接口</h4> 
 <br> 对于进程/线程/携程/异步的内容 有时间准备写写了 真的一直用for去循环慢到怀疑人生 需要运用的场景也会很多 所以分开一点点总结一下 
</div> 
<p></p> 
<p>先上代码看一下内容，多线程请求接口</p> 
<pre><code class="prism language-python">imoprt threading <span class="token comment"># 首先运用到threading模块</span>


<span class="token keyword">class</span> <span class="token class-name">BrushGifts</span><span class="token punctuation">:</span>
	<span class="token comment"># 以下是两个相同的接口 send_gift_room_one()是送礼的接口</span>
	<span class="token comment"># 也就是说我想完成的状态是A送B B送A 两个用户同时想对方赠送礼物</span>
    <span class="token keyword">def</span> <span class="token function">giftt</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> uid<span class="token punctuation">,</span> recvUid<span class="token punctuation">,</span> giftId<span class="token punctuation">)</span><span class="token punctuation">:</span>
    	<span class="token triple-quoted-string string">"""
        送礼接口
        :param uid: 送礼用户
        :param recvUid: 收礼用户
        :param giftId: 礼物道具id
        :return: 
        """</span>
        VoiceRoom<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>send_gift_room_one<span class="token punctuation">(</span>uid<span class="token punctuation">,</span> recvUid<span class="token punctuation">,</span> giftId<span class="token punctuation">)</span>

    <span class="token keyword">def</span> <span class="token function">giftt_a</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> uid<span class="token punctuation">,</span> recvUid<span class="token punctuation">,</span> giftId<span class="token punctuation">)</span><span class="token punctuation">:</span>
    	<span class="token comment"># 与上面的接口相同 不多做叙述</span>
    	<span class="token comment"># 没什么区别 就是写着好理解俩接口的概念</span>
        VoiceRoom<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>send_gift_room_one<span class="token punctuation">(</span>recvUid<span class="token punctuation">,</span> uid<span class="token punctuation">,</span> giftId<span class="token punctuation">)</span>


<span class="token keyword">if</span> __name__ <span class="token operator">==</span> <span class="token string">'__main__'</span><span class="token punctuation">:</span>
	<span class="token comment"># 因为我的账号是储存在yaml文件内 所以需要先倒出需要用户的uid列表</span>
	<span class="token comment"># 送礼人与收礼人分别倒出</span>
    uid_list <span class="token operator">=</span> YamlHandler<span class="token punctuation">(</span>YamlThePath<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>voice_room_cpNew<span class="token punctuation">)</span><span class="token punctuation">.</span>get_uid_list<span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span>
    rUid_list <span class="token operator">=</span> YamlHandler<span class="token punctuation">(</span>YamlThePath<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>number_old<span class="token punctuation">)</span><span class="token punctuation">.</span>get_scope_uid<span class="token punctuation">(</span><span class="token number">1500</span><span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">)</span>
    <span class="token comment"># 这里暂时先展示最简单的AB同时互送～</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span>i<span class="token punctuation">,</span> j<span class="token punctuation">)</span> <span class="token keyword">in</span> <span class="token builtin">zip</span><span class="token punctuation">(</span>uid_list<span class="token punctuation">,</span> rUid_list<span class="token punctuation">)</span><span class="token punctuation">:</span>
    	<span class="token comment"># target内需要传入方法名 不要带（）因为带括号就等于去调用了该方法 会直接开始执行</span>
    	<span class="token comment"># args内传入输入带入的参数 可以按顺序来 也可以整理成元组或字典接收</span>
        t1 <span class="token operator">=</span> threading<span class="token punctuation">.</span>Thread<span class="token punctuation">(</span>target<span class="token operator">=</span>BrushGifts<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>giftt<span class="token punctuation">,</span> args<span class="token operator">=</span><span class="token punctuation">(</span>i<span class="token punctuation">,</span> j<span class="token punctuation">,</span> <span class="token number">51620</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
        <span class="token comment"># 两个threading.Thread就是我请求并发两个接口</span>
        t2 <span class="token operator">=</span> threading<span class="token punctuation">.</span>Thread<span class="token punctuation">(</span>target<span class="token operator">=</span>BrushGifts<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>giftt<span class="token punctuation">,</span> args<span class="token operator">=</span><span class="token punctuation">(</span>j<span class="token punctuation">,</span> i<span class="token punctuation">,</span> <span class="token number">51620</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
        <span class="token comment"># t1.start()为执行</span>
        t1<span class="token punctuation">.</span>start<span class="token punctuation">(</span><span class="token punctuation">)</span>
        t2<span class="token punctuation">.</span>start<span class="token punctuation">(</span><span class="token punctuation">)</span>
</code></pre> 
<p>主线程：<br> 主线程的概念就是这个py文件内从头到位的执行 当我执行完最后一行代码t2.start()后 主线程会进入等待状态，等待子线程结束后主线程才会结束<br> 子线程：<br> 子线程的概念就是在主线程执行的过程中我执行到了这里 当然这里是通过t1.start()方法来进行调用的</p> 
<pre><code class="prism language-python">t1 <span class="token operator">=</span> threading<span class="token punctuation">.</span>Thread<span class="token punctuation">(</span>target<span class="token operator">=</span>BrushGifts<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>giftt<span class="token punctuation">,</span> args<span class="token operator">=</span><span class="token punctuation">(</span>i<span class="token punctuation">,</span> j<span class="token punctuation">,</span> <span class="token number">51620</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
</code></pre> 
<p>这时候系统会再开辟出一条子线程进行BrushGifts().giftt方法的执行与调用</p> 
<p>主线程在进行的时候会执行t1.start()与t2.start()但是他不会等待他们执行结束，主线程会继续往下，所以t1.start()与t2.start()是同时请求，当t1.start()与t2.start()两个子进程都结束时，主线程才会结束～</p> 
<p>因为主线程执行t1.start()与t2.start()是一行一行的执行 而且python无法做到准确意义上的并发 所以如果对数据速度要求很高的时候 此方法不适用</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/5a7b3e50e89ce87d3ef205f1eb2dbbf2/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">CSS 设置鼠标的样式</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/cabe27ec4d44ad7684ca497d8bbb5bad/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">UE4中实现PBKDF2加密验证</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>