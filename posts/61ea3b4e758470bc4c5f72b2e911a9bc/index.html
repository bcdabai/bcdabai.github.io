<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Java使用定时任务 - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Java使用定时任务" />
<meta property="og:description" content="前言：Java开发过程中经常会遇到使用定时任务的情况，比如在某个活动结束时，自动生成获奖名单，导出excel等。常见的有如下四种方式：Timer、ScheduledExecutorService、SpringTask、Quartz。
1、Java定时任务的四种实现方式 （1）JDK 自带的定时器实现
（2）Spring Task的@Scheduled注解任务调度
（3）Quartz 定时器实现 （4）Elastic-job分布式作业调度框架
JDK自带 ：JDK自带的Timer以及JDK1.5&#43; 新增的ScheduledExecutorService； Spring3.0以后自带的task调度工具 ：可以将它看成一个轻量级的Quartz，而且使用起来比Quartz简单许多，一般可以直接用@Scheduled注解&#43;corn表达式实现； Quartz ：简单却强大的JAVA作业调度框架；
Elastic-job分布式作业调度框架：是当当网架构师基于Zookepper、Quartz开发并开源的一个Java分布式定时任务，解决了Quartz不支持分布式的弊端。
2、JDK自带的java.util.Timer 来实现 import java.util.Calendar; import java.util.Date; import java.util.Timer; import java.util.TimerTask; public class Test { /** * 第一种方法：设定指定任务task在指定时间执行，只执行一次 * schedule(TimerTask task, Date time) */ public static void timer1() { Timer timer = new Timer(); timer.schedule(new TimerTask() { public void run() { System.out.println(new Date() &#43;&#34;\t&#34;&#43;&#34;---指定要执行任务---&#34;); } }, new Date(System.currentTimeMillis() &#43; 2000)); } /** * 第二种方法：设定指定任务task在延迟delay执行,只执行一次 * schedule(TimerTask task, long delay) * delay单位毫秒 */ public static void timer2(){ Timer timer = new Timer(); timer." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/61ea3b4e758470bc4c5f72b2e911a9bc/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2021-03-23T17:11:03+08:00" />
<meta property="article:modified_time" content="2021-03-23T17:11:03+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Java使用定时任务</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p><strong>前言：</strong>Java开发过程中经常会遇到使用定时任务的情况，比如在某个活动结束时，自动生成获奖名单，导出excel等。常见的有如下四种方式：Timer、ScheduledExecutorService、SpringTask、Quartz。</p> 
<hr> 
<h4>1、Java定时任务的四种实现方式</h4> 
<blockquote> 
 <p>（1）JDK 自带的定时器实现</p> 
 <p>（2）Spring Task的<strong>@Scheduled注解</strong>任务调度</p> 
 <p>（3）Quartz 定时器实现 </p> 
 <p>（4）Elastic-job分布式作业调度框架</p> 
</blockquote> 
<ul><li> <p>JDK自带 ：JDK自带的Timer以及JDK1.5+ 新增的ScheduledExecutorService； </p> </li><li> <p>Spring3.0以后自带的task调度工具 ：可以将它看成一个轻量级的Quartz，而且使用起来比Quartz简单许多，一般可以直接用@Scheduled注解+corn表达式实现； </p> </li><li> <p>Quartz ：简单却强大的JAVA作业调度框架；</p> </li><li> <p>Elastic-job分布式作业调度框架：是当当网架构师基于Zookepper、Quartz开发并开源的一个Java分布式定时任务，解决了Quartz不支持分布式的弊端。</p> </li></ul> 
<hr> 
<h4> 2、JDK自带的java.util.Timer 来实现</h4> 
<pre><code class="language-java">import java.util.Calendar;
import java.util.Date;
import java.util.Timer;
import java.util.TimerTask;
 
 
public class Test {
    /**
     *  第一种方法：设定指定任务task在指定时间执行，只执行一次  
     *  schedule(TimerTask task, Date time)  
     */
    public static void timer1() {  
        Timer timer = new Timer();  
        timer.schedule(new TimerTask() {  
            public void run() {  
                System.out.println(new Date() +"\t"+"---指定要执行任务---");  
            }  
        },  new Date(System.currentTimeMillis() + 2000)); 
    }  
    
    /**
     *  第二种方法：设定指定任务task在延迟delay执行,只执行一次    
     *  schedule(TimerTask task, long delay)   
     *  delay单位毫秒
     */
    public static void timer2(){
        Timer timer = new Timer();  
        timer.schedule(new TimerTask() {  
            public void run() {  
                System.out.println(new Date() +"\t"+"---指定要执行任务---");  
            }  
        }, 2000);  
    }
    
    /**
     *  第三种方法：设定指定任务task在指定延迟delay后进行周期性执行，周期时间为period  
     *  schedule(TimerTask task, long delay, long period) 
     *  scheduleAtFixedRate(TimerTask task, long delay, long period)  
     *  delay,period 单位为毫秒
     */
    public static void timer3() {  
        Timer timer = new Timer();  
        timer.schedule(new TimerTask() {  
            public void run() {  
                System.out.println(new Date() +"\t"+"---指定要执行任务---");  
            }  
        }, 1000, 1000);  
    }  
    /**
     *  第四种方法：设定指定的任务task在指定的时间firstTime开始进行重复的周期性执行，周期时间为period
     *  schedule(TimerTask task, Date firstTime, long period) 
     *  scheduleAtFixedRate(TimerTask task,Date firstTime,long period)
     *  period 单位为毫秒
     */
    public static void timer4() {  
        Calendar calendar = Calendar.getInstance();  
        calendar.set(Calendar.HOUR_OF_DAY, 12); // 控制时  
        calendar.set(Calendar.MINUTE, 0);       // 控制分  
        calendar.set(Calendar.SECOND, 0);       // 控制秒  
  
        Date time = calendar.getTime();         // 得出执行任务的时间,此处为今天的12：00：00  
        Timer timer = new Timer();  
        timer.schedule(new TimerTask() {  
            public void run() {  
                System.out.println(new Date() +"\t"+"---指定要执行任务---");  
            }  
        }, time, 1000);
    }  
    
    /**
     * schedule和scheduleAtFixedRate方法的区别：
     * （1）schedule方法：如果第一次执行时间被delay了，随后的执行时间按照上一次实际执行完成的时间点进行计算,即：下一次的执行时间点=上一次程序执行完成的时间点+间隔时间 
     * （2）scheduleAtFixedRate方法：如果第一次执行时间被delay了，随后的执行时间按照上一次开始的时间点进行计算，即：下一次的执行时间点=上一次程序开始执行的时间点+间隔时间，
     * 并且前一个任务的执行时间大于间隔时间，就会与当前任务重叠,TimerTask中的执行体需要考虑线程同步 
     */
    
}</code></pre> 
<p><strong>Timer的缺陷：</strong></p> 
<p>（1）由于执行任务的线程只有一个，所以如果某个任务的执行时间过长，那么将破坏其他任务的定时精确性。如一个任务每1秒执行一次，而另一个任务执行一次需要5秒，那么如果是固定速率的任务，那么会在5秒这个任务执行完成后连续执行5次，而固定延迟的任务将丢失4次执行。</p> 
<p>（2）如果执行某个任务过程中抛出了异常，那么执行线程将会终止，导致Timer中的其他任务也不能再执行。</p> 
<p>（3）Timer使用的是绝对时间，即是某个时间点，所以它执行依赖系统的时间，如果系统时间修改了的话，将导致任务可能不会被执行。</p> 
<p>由于Timer存在上面说的这些缺陷，在JDK1.5中，我们可以使用ScheduledThreadPoolExecutor来代替它，使用Executors.newScheduledThreadPool工厂方法或使用ScheduledThreadPoolExecutor的构造函数来创建定时任务，它是基于线程池的实现，不会存在Timer存在的上述问题，当线程数量为1时，它相当于Timer。</p> 
<hr> 
<h4>3、JDK自带的ScheduledThreadPoolExecutor来实现</h4> 
<pre><code class="language-java"> /**
     * ScheduledThreadPoolExecutor 有两种创建方式:第一种，通过Executors创建;第二种：通过构造方法
     * scheduleAtFixedRate(Runnable command, long initialDelay, long period,TimeUnit unit)
     * initialDelay 首次执行任务的延迟时间
     * period  每次执行任务的间隔时间
     * unit   执行的时间间隔数值单位
     * 间隔单位毫秒：TimeUnit.MILLISECONDS 
     * 间隔单位秒：TimeUnit.SECONDS 
     * 间隔单位分钟：TimeUnit.MINUTES 
     * 间隔单位小时：TimeUnit.HOURS 
     * 间隔单位天：TimeUnit.DAYS
     */
    public static void timer5(){
        ScheduledThreadPoolExecutor scheduled = (ScheduledThreadPoolExecutor)Executors.newScheduledThreadPool(10);
//        ScheduledThreadPoolExecutor  scheduled = new ScheduledThreadPoolExecutor(10);
        scheduled.scheduleAtFixedRate(new Runnable() {
             @Override
             public void run() {
                 System.out.println(new Date());
             }
         }, 0, 40, TimeUnit.MILLISECONDS);
    }</code></pre> 
<hr> 
<h4>4、Spring <strong>@Scheduled</strong>定时任务实现</h4> 
<p>案例：定期清理未激活用户，节省资源，方便用户再次注册。</p> 
<blockquote> 
 <p>Spring 3.0+ 自带的任务调度实现，主要依靠<code>TaskScheduler</code>接口的几个实现类实现。<span style="color:#0d0016;"><code>删除和修改任务比较麻烦。</code> </span><br> 主要用法有以下三种： </p> 
 <ul><li> <p>Spring配置文件实现</p> </li><li> <p>注解实现</p> </li><li> <p>代码动态添加</p> </li></ul> 
</blockquote> 
<p>Spring定时任务比较简单，只需要在maven依赖中引入相关jar包，这里使用注解进行配置。</p> 
<p>示例：</p> 
<p><strong>Spring @Scheduled</strong>注解执行定时任务</p> 
<pre><code class="language-java">package quartz;
 
import java.util.Date;
 
import javax.annotation.PostConstruct;
 
import org.springframework.scheduling.annotation.Scheduled;
import org.springframework.stereotype.Service;
 
@Service
public class ExpireJobTask {
    
    @PostConstruct
    public void reload() {
        load();
    }
    
    @Scheduled(cron = "0 0/1 0 * * ?")
    public void load(){
        System.out.println(new Date()+"\t"+"执行定时任务");
    }
 
}</code></pre> 
<hr> 
<h4>4、Quartz整合Spring实现</h4> 
<p>（1）增加maven依赖</p> 
<pre><code class="language-XML">&lt;dependency&gt;
   &lt;groupId&gt;org.springframework&lt;/groupId&gt;
   &lt;artifactId&gt;spring-web&lt;/artifactId&gt;
   &lt;version&gt;3.2.9.RELEASE&lt;/version&gt;    
&lt;/dependency&gt;
&lt;dependency&gt;
   &lt;groupId&gt;org.quartz-scheduler&lt;/groupId&gt;
   &lt;artifactId&gt;quartz&lt;/artifactId&gt;
   &lt;version&gt;1.8.5&lt;/version&gt;
&lt;/dependency&gt;</code></pre> 
<p>（2）增加定时业务类</p> 
<pre><code class="language-java">package quartz;
 
import java.util.Date;
 
import javax.annotation.PostConstruct;
 
import org.springframework.stereotype.Service;
 
@Service("ExpireJobTaskService")
public class ExpireJobTask {
    
    public void reload() {
        load();
    }
    
    @PostConstruct
    public void load(){
        System.out.println(new Date()+"\t"+"执行定时任务");
    }
 
}</code></pre> 
<p>（3）增加spring配置</p> 
<pre><code class="language-XML">&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;beans xmlns="http://www.springframework.org/schema/beans"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
    xmlns:aop="http://www.springframework.org/schema/aop"
    xmlns:context="http://www.springframework.org/schema/context"
    xmlns:task="http://www.springframework.org/schema/task"
    xsi:schemaLocation="
      http://www.springframework.org/schema/context classpath:org/springframework/context/config/spring-context-3.0.xsd
      http://www.springframework.org/schema/beans classpath:org/springframework/beans/factory/xml/spring-beans-3.0.xsd
      http://www.springframework.org/schema/aop classpath:org/springframework/aop/config/spring-aop-3.0.xsd"&gt;
 
    
    &lt;!-- 扫描指定package下所有组件注解并注册为Spring Beans --&gt;
    &lt;context:component-scan base-package="quartz" /&gt;
    
    
    &lt;!-- 调度业务 --&gt;
    &lt;bean id="ExpireJobTaskJobDetail" class="org.springframework.scheduling.quartz.MethodInvokingJobDetailFactoryBean"&gt;
        &lt;property name="targetObject" ref="ExpireJobTaskService" /&gt;
        &lt;property name="targetMethod" value="reload" /&gt;
    &lt;/bean&gt;
    &lt;!-- 调度触发器 --&gt;
    &lt;bean id="ExpireJobTaskJobTrigger" class="org.springframework.scheduling.quartz.CronTriggerBean"&gt;
        &lt;property name="jobDetail" ref="ExpireJobTaskJobDetail" /&gt;
        &lt;property name="cronExpression" value="0 0/1 * * * ?" /&gt;
    &lt;/bean&gt; 
    
    &lt;!-- 设置调度    triggers属性中，我们可以增加多个触发器。 --&gt;
    &lt;bean name="startQuertz"  class="org.springframework.scheduling.quartz.SchedulerFactoryBean"&gt;
        &lt;property name="triggers"&gt;
            &lt;list&gt;
                &lt;ref bean="ExpireJobTaskJobTrigger" /&gt;
            &lt;/list&gt;
        &lt;/property&gt;
    &lt;/bean&gt;
    
&lt;/beans&gt;</code></pre> 
<p><code>Quartz 主要包含以下几个部分:</code></p> 
<blockquote> 
 <p>Job：是一个接口，只有一个方法void execute(JobExecutionContext</p> 
 <p>context，开发者实现该接口定义运行任务，JobExecutionContext类提供了调度上下文的各种信息。Job运行时的信息保存在JobDataMap实例中；</p> 
 <p>JobDetail：Quartz在每次执行Job时，都重新创建一个Job实例，所以它不直接接受一个Job的实例，相反它接收一个Job实现类，以便运行时通过newInstance()的反射机制实例化Job。因此需要通过一个类来描述Job的实现类及其它相关的静态信息，如Job名字、描述、关联监听器等信息，JobDetail承担了这一角色。</p> 
 <p>Trigger：是一个类，描述触发Job执行的时间触发规则。主要有SimpleTrigger和CronTrigger这两个子类。当仅需触发一次或者以固定时间间隔周期执行，SimpleTrigger是最适合的选择；而CronTrigger则可以通过Cron表达式定义出各种复杂时间规则的调度方案：如每早晨9:00执行，周一、周三、周五下午5:00执行等；</p> 
 <p>Calendar：org.quartz.Calendar和java.util.Calendar不同，它是一些日历特定时间点的集合（可以简单地将org.quartz.Calendar看作java.util.Calendar的集合——java.util.Calendar代表一个日历时间点，无特殊说明后面的Calendar即指org.quartz.Calendar）。一个Trigger可以和多个Calendar关联，以便排除或包含某些时间点。假设，我们安排每周星期一早上10:00执行任务，但是如果碰到法定的节日，任务则不执行，这时就需要在Trigger触发机制的基础上使用Calendar进行定点排除。</p> 
 <p>Scheduler：代表一个Quartz的独立运行容器，Trigger和JobDetail可以注册到Scheduler中，两者在Scheduler中拥有各自的组及名称，组及名称是Scheduler查找定位容器中某一对象的依据，Trigger的组及名称必须唯一，JobDetail的组和名称也必须唯一（但可以和Trigger的组和名称相同，因为它们是不同类型的）。Scheduler定义了多个接口方法，允许外部通过组及名称访问和控制容器中Trigger和JobDetail。</p> 
 <p>Scheduler可以将Trigger绑定到某一JobDetail中，这样当Trigger触发时，对应的Job就被执行。一个Job可以对应多个Trigger，但一个Trigger只能对应一个Job。可以通过SchedulerFactory创建一个Scheduler实例。Scheduler拥有一个SchedulerContext，它类似于ServletContext，保存着Scheduler上下文信息，Job和Trigger都可以访问SchedulerContext内的信息。SchedulerContext内部通过一个Map，以键值对的方式维护这些上下文数据，SchedulerContext为保存和获取数据提供了多个put()和getXxx()的方法。可以通过Scheduler#</p> 
 <p>getContext()获取对应的SchedulerContext实例；</p> 
 <p>ThreadPool：Scheduler使用一个线程池作为任务运行的基础设施，任务通过共享线程池中的线程提高运行效率。</p> 
</blockquote> 
<hr> 
<h4>6、Elastic-job分布式作业调度框架</h4> 
<blockquote> 
 <p>Elastic-job是当当网架构师基于Zookepper、Quartz开发并开源的一个Java分布式定时任务，解决了Quartz不支持分布式的弊端。Elastic job主要的功能有支持弹性扩容，通过Zookepper集中管理和监控job，支持失效转移等，这些都是Quartz等其他定时任务无法比拟的。</p> 
</blockquote> 
<p>elastic-job是当当开源的一款非常好用的作业框架，在这之前，我们开发定时任务一般都是使用quartz或者spring-task（ScheduledExecutorService），无论是使用quartz还是spring-task，我们都会至少遇到两个痛点：</p> 
<ul><li> <p>不敢轻易跟着应用服务多节点部署，可能会重复多次执行而引发系统逻辑的错误。</p> </li><li> <p>quartz的集群仅仅只是用来HA，节点数量的增加并不能给我们的每次执行效率带来提升，即不能实现水平扩展。</p> </li></ul> 
<hr> 
<p>参考链接：</p> 
<p><strong><a href="https://www.cnblogs.com/zhangbin1989/p/9294114.html" rel="nofollow" title="Java定时任务">Java定时任务</a></strong></p> 
<p><strong><a href="https://blog.csdn.net/qq_39013701/article/details/90668813" title="SpringTask">SpringTask</a></strong></p> 
<p><strong><a href="https://www.cnblogs.com/dyppp/p/7498457.html" rel="nofollow" title="@Scheduled cron表达式">@Scheduled cron表达式</a></strong></p> 
<p><strong><a href="https://www.jianshu.com/p/c6f0f37fde31" rel="nofollow" title="@Schedule cron表达式 时彬斌 ​​​​​​​​​​​​​Elastic-job实战(分布式作业调度框架)">@Schedule cron表达式 时彬斌 ​​​​​​<br><br> Elastic-job实战(分布式作业调度框架)<br><br><br></a><a class="link-info" href="https://blog.csdn.net/fanfan_v5/article/details/61310045" title="elastic-job的原理简介和使用">elastic-job的原理简介和使用</a></strong></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/de4cfbb29b84d1cfd5af6903a3de2825/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">树莓派学习（二） 安装anaconda</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/147a91297a8aa23f5f4cc3b98a8600d4/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">Guacamole录屏配置</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>