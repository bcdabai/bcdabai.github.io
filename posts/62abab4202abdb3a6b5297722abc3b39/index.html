<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>RabbitMQ快速上手（包含秒杀案例） - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="RabbitMQ快速上手（包含秒杀案例）" />
<meta property="og:description" content="1、 MQ概念 1.1 MQ 介绍 MQ（Message Queue）消息队列，是基础数据结构中“先进先出”的一种数据结构。一般用来解决应用解耦，异步消息，流量削峰等问题，实现高性能，高可用，可伸缩和最终一致性架构。
1.2 MQ应用场景 MQ的优势
1.2.1异步解耦
以电商应用为例，应用中有订单系统、库存系统、物流系统、支付系统。用户创建订单后，如果耦合 调用库存系统、物流系统、支付系统，任何一个子系统出了故障，都会造成下单操作异常。当转变成基于消息队列的方式后，系统间调用的问题会减少很多，比如物流系统因为发生故障，需要几分钟来修复。在 这几分钟的时间里，物流系统要处理的内存被缓存在消息队列中，用户的下单操作可以正常完成。当物流 系统恢复后，继续处理订单信息即可，中单用户感受不到物流系统的故障，提升系统的可用性。
1.2.2 削峰填谷
举个例子，如果订单系统最多能处理一万次订单，这个处理能力应付正常时段的下单时绰绰有余，正 常时段我们下单一秒后就能返回结果。但是在高峰期，如果有两万次下单操作系统是处理不了的，只能限 制订单超过一万后不允许用户下单。使用消息队列做缓冲，我们可以取消这个限制，把一秒内下的订单分 散成一段时间来处理，这时有些用户可能在下单十几秒后才能收到下单成功的操作，但是比不能下单的体 验要好。
1.2.3 消息分发
在实际开发中一个系统的数据有的时候需要分发个不同的系统中， 拿电商举例在双11的时候有很多会场，每一个会场可能都需要用到一个商品的数据，那么我们需要把数据分发到不同的会场中，假设有加了一个会场我们还需要把数据分发给新的会场
常见消息中间件对比图
1.4 RabbitMQ简介 AMQP，即 Advanced Message Queuing Protocol（高级消息队列协议），是一个网络协议，是应用层协议 的一个开放标准，为面向消息的中间件设计。基于此协议的客户端与消息中间件可传递消息，并不受客户端/中 间件不同产品，不同的开发语言等条件的限制。2006年，AMQP 规范发布。类比HTTP。
2007年，Rabbit 技术公司基于 AMQP 标准开发的 RabbitMQ 1.0 发布。RabbitMQ 采用 Erlang 语言开发。 Erlang 语言由 Ericson 设计，专门为开发高并发和分布式系统的一种语言，在电信领域使用广泛。
1.5 RabbitMQ中的核心概念 Broker：接收和分发消息的应用，RabbitMQ Server就是 Message Broker
Virtual host：出于多租户和安全因素设计的，把 AMQP 的基本组件划分到一个虚拟的分组中，类似于网 络中的 namespace 概念。当多个不同的用户使用同一个 RabbitMQ server 提供的服务时，可以划分出多个vhost，每个用户在自己的 vhost 创建 exchange／queue 等" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/62abab4202abdb3a6b5297722abc3b39/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-05-06T19:38:45+08:00" />
<meta property="article:modified_time" content="2023-05-06T19:38:45+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">RabbitMQ快速上手（包含秒杀案例）</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <h3 id="1%E3%80%81%20MQ%E6%A6%82%E5%BF%B5">1、 MQ概念</h3> 
<h4 id="1.1%20MQ%20%E4%BB%8B%E7%BB%8D">1.1 MQ 介绍</h4> 
<p>MQ（Message Queue）消息队列，是基础数据结构中“先进先出”的一种数据结构。一般用来解决<strong>应用解耦，异步消息，流量削峰</strong>等问题，实现高性能，高可用，可伸缩和最终一致性架构。</p> 
<h4 id="1.2%20MQ%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF">1.2 MQ应用场景</h4> 
<p><strong>MQ的优势</strong></p> 
<p><strong>1.2.1异步解耦</strong></p> 
<p>以电商应用为例，应用中有订单系统、库存系统、物流系统、支付系统。用户创建订单后，如果耦合 调用库存系统、物流系统、支付系统，任何一个子系统出了故障，都会造成下单操作异常。当转变成基于消息队列的方式后，系统间调用的问题会减少很多，比如物流系统因为发生故障，需要几分钟来修复。在 这几分钟的时间里，物流系统要处理的内存被缓存在消息队列中，用户的下单操作可以正常完成。当物流 系统恢复后，继续处理订单信息即可，中单用户感受不到物流系统的故障，提升系统的可用性。</p> 
<p></p> 
<p><img alt="" height="509" src="https://images2.imgbox.com/33/6d/y4qPLjrX_o.png" width="1165"></p> 
<p></p> 
<p><strong>1.2.2 削峰填谷</strong></p> 
<p>举个例子，如果订单系统最多能处理一万次订单，这个处理能力应付正常时段的下单时绰绰有余，正 常时段我们下单一秒后就能返回结果。但是在高峰期，如果有两万次下单操作系统是处理不了的，只能限 制订单超过一万后不允许用户下单。使用消息队列做缓冲，我们可以取消这个限制，把一秒内下的订单分 散成一段时间来处理，这时有些用户可能在下单十几秒后才能收到下单成功的操作，但是比不能下单的体 验要好。</p> 
<p><img alt="" height="669" src="https://images2.imgbox.com/06/de/TUJePEH0_o.png" width="1184"></p> 
<p></p> 
<p></p> 
<p>1.2.3 消息分发</p> 
<p>在实际开发中一个系统的数据有的时候需要分发个不同的系统中， 拿电商举例在双11的时候有很多会场，每一个会场可能都需要用到一个商品的数据，那么我们需要把数据分发到不同的会场中，假设有加了一个会场我们还需要把数据分发给新的会场</p> 
<p><img alt="" height="703" src="https://images2.imgbox.com/da/27/1f5vn5ar_o.png" width="1136"></p> 
<p></p> 
<p></p> 
<p><strong>常见消息中间件对比图</strong></p> 
<p><img alt="" height="518" src="https://images2.imgbox.com/39/ba/BQN7kkAQ_o.png" width="1200"></p> 
<p></p> 
<h4 id="1.4%20RabbitMQ%E7%AE%80%E4%BB%8B">1.4 RabbitMQ简介</h4> 
<p>AMQP，即 Advanced Message Queuing Protocol（高级消息队列协议），是一个网络协议，是应用层协议 的一个开放标准，为面向消息的中间件设计。基于此协议的客户端与消息中间件可传递消息，并不受客户端/中 间件不同产品，不同的开发语言等条件的限制。2006年，AMQP 规范发布。类比HTTP。</p> 
<p>2007年，Rabbit 技术公司基于 AMQP 标准开发的 RabbitMQ 1.0 发布。RabbitMQ 采用 Erlang 语言开发。 Erlang 语言由 Ericson 设计，专门为开发高并发和分布式系统的一种语言，在电信领域使用广泛。</p> 
<h4 id="1.5%20RabbitMQ%E4%B8%AD%E7%9A%84%E6%A0%B8%E5%BF%83%E6%A6%82%E5%BF%B5">1.5 RabbitMQ中的核心概念</h4> 
<p><strong>Broker</strong>：接收和分发消息的应用，RabbitMQ Server就是 Message Broker</p> 
<p><strong>Virtual host</strong>：出于多租户和安全因素设计的，把 AMQP 的基本组件划分到一个虚拟的分组中，类似于网 络中的 namespace 概念。当多个不同的用户使用同一个 RabbitMQ server 提供的服务时，可以划分出多个vhost，每个用户在自己的 vhost 创建 exchange／queue 等</p> 
<p><strong>Connection</strong>：publisher／consumer 和 broker 之间的 TCP 连接</p> 
<p><strong>Channel</strong>：如果每一次访问 RabbitMQ 都建立一个 Connection，在消息量大的时候建立 TCP Connection 的开销将是巨大的，效率也较低。Channel 是在 connection 内部建立的逻辑连接，如果应用程序支持多线 程，通常每个thread创建单独的 channel 进行通讯，AMQP method 包含了channel id 帮助客户端和 message broker 识别 channel，所以 channel 之间是完全隔离的。Channel 作为轻量级的 Connection 极大减少了操作系统建立 TCP connection 的开销</p> 
<p><strong>Exchange</strong>：message 到达 broker 的第一站，根据分发规则，匹配查询表中的 routing key，分发消息到 queue 中去。常用的类型有：direct (point-to-point), topic (publish-subscribe) and fanout (multicast)</p> 
<p><strong>Queue</strong>：消息最终被送到这里等待 consumer 取走</p> 
<p><strong>Binding</strong>：exchange 和 queue 之间的虚拟连接，binding 中可以包含 routing key。Binding 信息被保存 到 exchange 中的查询表中，用于 message 的分发依据</p> 
<p><strong>RabbitMQ架构图</strong></p> 
<p><img alt="" height="373" src="https://images2.imgbox.com/f0/30/1J845gdw_o.png" width="1196"></p> 
<p></p> 
<h3 id="2%E3%80%81RabbitMQ%E7%9A%84%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8">2、RabbitMQ的快速入门</h3> 
<p>RabbitMQ 提供了 6 种工作模式：简单模式、work queues、Publish/Subscribe 发布与订阅模式、Routing 路由模式、Topics 主题模式、RPC 远程调用模式（远程调用，不太算 MQ；暂不作介绍）。</p> 
<p><strong>1、简单模式 HelloWorld</strong></p> 
<p>一个生产者、一个消费者，不需要设置交换机（使用默认的交换机）。</p> 
<p><strong>2、工作队列模式 Work Queue</strong></p> 
<p>一个生产者、多个消费者（竞争关系），不需要设置交换机（使用默认的交换机）。</p> 
<p><strong>3、发布订阅模式 Publish/subscribe</strong></p> 
<p>需要设置类型为 fanout 的交换机 ，并且交换机和队列进行绑定 ，当发送消息到交换机后，交换机会将消</p> 
<p>息发送到绑定的队列。</p> 
<p><strong>4、路由模式 Routing</strong></p> 
<p>需要设置类型为 direct 的交换机 ，交换机和队列进行绑定 ， 并且指定 routing key，当发送消息到交换机 后 ，交换机会根据 routing key 将消息发送到对应的队列。</p> 
<p><strong>5、通配符模式 Topic</strong></p> 
<p>需要设置类型为 topic 的交换机 ，交换机和队列进行绑定 ，并且指定通配符方式的 routing key ，当发送消息到交换机后 ，交换机会根据 routing key 将消息发送到对应的队列。</p> 
<p></p> 
<h3 id="3%E3%80%81%20Springboot%E7%8E%AF%E5%A2%83%E5%BF%AB%E9%80%9F%E9%9B%86%E6%88%90RabbitMQ">3、 Springboot环境快速集成RabbitMQ</h3> 
<h4 id="3.1%20%E5%85%A5%E9%97%A8%E6%A1%88%E4%BE%8B">3.1 入门案例</h4> 
<p><strong>生产端操作步骤：</strong></p> 
<ol><li> <p>创建生产者SpringBoot工程</p> </li><li> <p>引入start，依赖坐标</p> </li></ol> 
<pre><code class="language-XML">&lt;parent&gt;
        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
        &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt;
        &lt;version&gt;2.3.2.RELEASE&lt;/version&gt;
    &lt;/parent&gt;

    &lt;dependencies&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
            &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
            &lt;artifactId&gt;spring-boot-starter-amqp&lt;/artifactId&gt;
        &lt;/dependency&gt;
    &lt;/dependencies&gt;</code></pre> 
<ol><li> <p><span style="color:#ff9900;"><strong>编写yml配置，基本信息配置</strong></span></p> </li><li> <p><span style="color:#ff9900;"><strong>定义交换机，队列以及绑定关系的配置类</strong></span></p> </li><li> <p><span style="color:#ff9900;"><strong>注入RabbitTemplate，调用方法，完成消息发送</strong></span></p> </li></ol> 
<p><strong>生产者</strong></p> 
<pre><code class="language-java">package cn.wolfcode.java.rabbitmq._06boot_helloworld;
import org.springframework.amqp.rabbit.core.RabbitTemplate;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Controller;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.ResponseBody;


@Controller
public class QueueController {
    @Autowired
    private RabbitTemplate rabbitTemplate;
    
    @RequestMapping("/queue")
    @ResponseBody
    public String sendMsg(String msg){
        rabbitTemplate.convertAndSend("","boot_queue",msg);
        return "发送成功";
    }
}</code></pre> 
<p><strong>消费端操作步骤：</strong></p> 
<p><strong>消费端</strong></p> 
<ol><li> <p>创建消费者SpringBoot工程</p> </li><li> <p>引入start，依赖坐标</p> </li></ol> 
<pre><code class="language-XML">&lt;dependency&gt; 
  &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; 
  &lt;artifactId&gt;spring-boot-starter-amqp&lt;/artifactId&gt; 
&lt;/dependency&gt; </code></pre> 
<ol><li> <p>编写yml配置，基本信息配置</p> </li><li> <p>定义监听类，使用<strong>@RabbitListener</strong>注解完成队列监听。</p> </li></ol> 
<p><strong>消费者</strong></p> 
<pre><code class="language-java">package cn.wolfcode.java.rabbitmq._06boot_helloworld;

import com.rabbitmq.client.Channel;
import org.springframework.amqp.rabbit.annotation.Queue;

import org.springframework.amqp.rabbit.annotation.RabbitListener;
import org.springframework.amqp.support.AmqpHeaders;
import org.springframework.messaging.handler.annotation.Header;
import org.springframework.stereotype.Component;

@Component
public class QueueListener {

    @RabbitListener(queuesToDeclare = @Queue("boot_queue"))
    public void receiveMsg(String msg, @Header(AmqpHeaders.DELIVERY_TAG) long deliveryTag, Channel channel){
        System.out.println("收到消息:"+msg);
    }
}</code></pre> 
<h4 id="5.2%20Work%E6%A8%A1%E5%BC%8F">3.2 Work模式</h4> 
<p>配置项</p> 
<pre>#签收模式配置
spring.rabbitmq.listener.simple.acknowledge-mode=manual
spring.rabbitmq.listener.simple.prefetch=1</pre> 
<p><strong>生产者</strong></p> 
<pre><code class="language-java">package cn.wolfcode.java.rabbitmq._07boot_worker;

import org.springframework.amqp.rabbit.core.RabbitMessagingTemplate;
import org.springframework.amqp.rabbit.core.RabbitTemplate;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Controller;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.ResponseBody;


@Controller
public class WorkerController {
    @Autowired
    private RabbitTemplate rabbitTemplate;
    @RequestMapping("/worker")
    @ResponseBody
    public String sendMsg(){
        for(int i= 0;i&lt;20;i++){
            rabbitTemplate.convertAndSend("","boot_worker","msg:"+i);
        }
        return "发送成功";
    }
}</code></pre> 
<p><strong>消费者：</strong></p> 
<pre><code class="language-java">package cn.wolfcode.java.rabbitmq._07boot_worker;

import com.rabbitmq.client.Channel;
import org.springframework.amqp.rabbit.annotation.Queue;
import org.springframework.amqp.rabbit.annotation.RabbitListener;
import org.springframework.amqp.support.AmqpHeaders;
import org.springframework.messaging.handler.annotation.Header;
import org.springframework.stereotype.Component;
import java.io.IOException;

@Component
public class Worker {
    @RabbitListener(queuesToDeclare = @Queue("boot_worker"))
      public void receiveMsg(String msg, @Header(AmqpHeaders.DELIVERY_TAG) long deliveryTag, Channel channel) throws IOException {
        System.out.println("工作者1:"+msg);
        channel.basicAck(deliveryTag,false);
    }

}</code></pre> 
<h4 id="5.3%20Pub%2FSub%E6%A8%A1%E5%BC%8F"><strong>3.3 Pub/Sub模式</strong></h4> 
<p><strong>生产者：</strong></p> 
<pre><code class="language-java">package cn.wolfcode.java.rabbitmq._08boot_pubsub;

import com.rabbitmq.client.Channel;
import org.springframework.amqp.rabbit.core.RabbitTemplate;
import org.springframework.amqp.support.AmqpHeaders;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.messaging.handler.annotation.Header;
import org.springframework.stereotype.Controller;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.ResponseBody;

@Controller
public class PubSubController {
    @Autowired
    private RabbitTemplate rabbitTemplate;
    @RequestMapping("/pubsub")
    @ResponseBody
    public String sendMsg(String msg){
        rabbitTemplate.convertAndSend("boot_pubsub","","广播消息");
        return "发送成功";
    }
}</code></pre> 
<p><strong>消费者：</strong></p> 
<pre><code class="language-java">package cn.wolfcode.java.rabbitmq._08boot_pubsub;

import com.rabbitmq.client.BuiltinExchangeType;
import com.rabbitmq.client.Channel;
import org.springframework.amqp.rabbit.annotation.Exchange;
import org.springframework.amqp.rabbit.annotation.Queue;
import org.springframework.amqp.rabbit.annotation.QueueBinding;
import org.springframework.amqp.rabbit.annotation.RabbitListener;
import org.springframework.amqp.support.AmqpHeaders;
import org.springframework.messaging.handler.annotation.Header;
import org.springframework.stereotype.Component;
import java.io.IOException;

@Component
public class PubSubReceiver {
    @RabbitListener(bindings = @QueueBinding(value = @Queue,exchange = @Exchange(name = "boot_pubsub",type = "fanout")))
    
    public void receiveMsg(String msg, @Header(AmqpHeaders.DELIVERY_TAG)long deliveryTag, Channel channel) throws Exception {
        System.out.println("收到消息1:"+msg);
        channel.basicAck(deliveryTag,false);
    }
}</code></pre> 
<h4 id="5.4%20Routing%E6%A8%A1%E5%BC%8F">3.4 Routing模式</h4> 
<p><strong>生产者：</strong></p> 
<pre><code class="language-java">package cn.wolfcode.java.rabbitmq._09boot_rounting;

import org.springframework.amqp.rabbit.annotation.RabbitListener;
import org.springframework.amqp.rabbit.core.RabbitTemplate;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Controller;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.ResponseBody;


@Controller
public class RountingController {
    @Autowired
    private RabbitTemplate rabbitTemplate;
    @RequestMapping("/rounting")
    @ResponseBody
    public String sendMsg(String key){
      rabbitTemplate.convertAndSend("boot_rounting_exchange",key,"rounting消息");
        return "发送成功";
    }
}</code></pre> 
<p><strong>消费者：</strong></p> 
<pre><code class="language-java">package cn.wolfcode.java.rabbitmq._09boot_rounting;

import com.rabbitmq.client.Channel;
import org.springframework.amqp.rabbit.annotation.Exchange;
import org.springframework.amqp.rabbit.annotation.Queue;
import org.springframework.amqp.rabbit.annotation.QueueBinding;
import org.springframework.amqp.rabbit.annotation.RabbitListener;
import org.springframework.amqp.support.AmqpHeaders;
import org.springframework.messaging.handler.annotation.Header;
import org.springframework.stereotype.Component;
import java.io.IOException;


@Component

public class RountingReceiver {

    @RabbitListener(bindings = @QueueBinding(value = @Queue(name = "boot_rounting_queue01"),

            exchange = @Exchange(name = "boot_rounting_exchange",type = "direct"),

            key = {"error","info"}
    ))

    public void receiveMsg(String msg, @Header(AmqpHeaders.DELIVERY_TAG)long deliveryTag, Channel channel) throws Exception {
        System.out.println("error&amp;info 收到消息:"+msg);
        channel.basicAck(deliveryTag,false);
    }
}</code></pre> 
<h4 id="5.5%20Topic%E6%A8%A1%E5%BC%8F">3.5 Topic模式</h4> 
<p><strong>生产者</strong></p> 
<pre><code class="language-java">package cn.wolfcode.java.rabbitmq._10boot_topic;

import org.springframework.amqp.rabbit.core.RabbitTemplate;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Controller;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.ResponseBody;

@Controller
public class TopicController {
    @Autowired
    private RabbitTemplate rabbitTemplate;
    @RequestMapping("/topic")
    @ResponseBody
    public String sendMsg(String key){
        rabbitTemplate.convertAndSend("boot_topic_exchange",key,"topic消息");
        return "发送成功";

    }

}</code></pre> 
<p><strong>消费者：</strong></p> 
<pre><code class="language-java">package cn.wolfcode.java.rabbitmq._10boot_topic;

import com.rabbitmq.client.Channel;

import org.springframework.amqp.rabbit.annotation.Exchange;

import org.springframework.amqp.rabbit.annotation.Queue;

import org.springframework.amqp.rabbit.annotation.QueueBinding;

import org.springframework.amqp.rabbit.annotation.RabbitListener;

import org.springframework.amqp.support.AmqpHeaders;

import org.springframework.messaging.handler.annotation.Header;

import org.springframework.stereotype.Component;

import java.io.IOException;


@Component
public class TopicReceiver01 {
    @RabbitListener(bindings = @QueueBinding(
            value = @Queue("boot_topic_queue01"),
            exchange = @Exchange(name = "boot_topic_exchange",type = "topic"),
            key = "order.*"
    ))

    public void receiveMsg(String msg, @Header(AmqpHeaders.DELIVERY_TAG)long deliveryTag, Channel channel) throws Exception {
        System.out.println("topic收取消息:"+msg);
        channel.basicAck(deliveryTag,false);
    }
}</code></pre> 
<h3 id="6%20%E3%80%81%20RabbitMQ%E5%AE%9E%E6%88%98%E6%A1%88%E4%BE%8B">6 、 RabbitMQ实战案例</h3> 
<h4 id="6.1%20%E6%A1%88%E4%BE%8B%E4%B8%80%20-%20%E9%80%80%E6%AC%BE%E5%8A%A0%E7%A7%AF%E5%88%86">6.1 案例一 - 退款加积分</h4> 
<p>需求： 用户进行下单操作 ， 下完单以后要进行加积分操作， 要求下完单以后加积分采用RabbitMQ 进行加积分</p> 
<p><strong>案例分析：</strong></p> 
<p>1 : 下完单以后把数据封装成消息利用生产者发送消息到RabbitMQ中。</p> 
<p>2：在积分服务编写消费者实时监听RabbitMQ队列中消息，监听到取出消息消费加积分。</p> 
<p><strong>没有RabbitMQ之前</strong></p> 
<p><img alt="" height="552" src="https://images2.imgbox.com/c1/b1/hZKl7Rd0_o.png" width="1147"></p> 
<p></p> 
<p></p> 
<p><strong>有了RabbitMQ以后</strong></p> 
<p><img alt="" height="354" src="https://images2.imgbox.com/28/8d/6Ir7r9Wb_o.png" width="1156"></p> 
<p></p> 
<p></p> 
<p>代码实现</p> 
<h4 id="6.2%20%E6%A1%88%E4%BE%8B%E4%BA%8C%20-%20%E7%A7%92%E6%9D%80%E4%B8%8B%E5%8D%95%E6%93%8D%E4%BD%9C">6.2 案例二 - 秒杀下单操作</h4> 
<p>需求： 电商平台进行秒杀活动，用户点击下单秒杀商品进行下单，要求用RabbitMQ进行削峰填谷。</p> 
<p><img alt="" height="566" src="https://images2.imgbox.com/0d/a6/uka7nbfc_o.png" width="1188"></p> 
<p></p> 
<p></p> 
<p><strong>有了RabbitMQ以后</strong></p> 
<p><img alt="" height="328" src="https://images2.imgbox.com/38/a1/Xm60pHso_o.png" width="1163"></p> 
<p></p> 
<p><img alt="" height="762" src="https://images2.imgbox.com/b1/97/sWuXNPSG_o.png" width="1200"></p> 
<p> </p> 
<p>代码实现</p> 
<h3 id="7%E3%80%81%20RabbitMQ%E9%AB%98%E9%A2%91%E9%9D%A2%E8%AF%95%E9%A2%98">7、 RabbitMQ高频面试题</h3> 
<h4 id="7.1%20RabbitMQ%E5%A6%82%E6%9E%9C%E5%87%BA%E7%8E%B0%E6%B6%88%E6%81%AF%E9%87%8D%E5%A4%8D%E6%B6%88%E8%B4%B9%E6%80%8E%E4%B9%88%E8%A7%A3%E5%86%B3">7.1 RabbitMQ如果出现消息重复消费怎么解决</h4> 
<p>采用幂等性解决：幂等性指一次和多次请求某一个资源，对于资源本身应该具有同样的结果。也就是说，其任意多次执行对资源本身所产生的影响均与一次执行的影响相同。</p> 
<p>在MQ中指，消费多条相同的消息，得到与消费该消息一次相同的结果。</p> 
<h4 id="7.2%20RabbitMQ%E4%B8%AD%E7%9A%84%E6%AD%BB%E4%BF%A1%E9%98%9F%E5%88%97">7.2 RabbitMQ中的死信队列</h4> 
<p>死信队列，英文缩写：DLX 。Dead Letter Exchange（死信交换机），当消息成为Dead message后，可以被重新发送到另一个交换机，这个交换机就是DLX。</p> 
<p><img alt="" height="327" src="https://images2.imgbox.com/9b/ef/FrjqzgKi_o.png" width="1200"></p> 
<p></p> 
<p></p> 
<p><strong>消息成为死信的三种情况：</strong></p> 
<ol><li> <p>队列消息长度到达限制；</p> </li><li> <p>消费者拒接消费消息，basicNack/basicReject,并且不把消息重新放入原目标队列,requeue=false；</p> </li><li> <p>原队列存在消息过期设置，消息到达超时时间未被消费；</p> </li></ol> 
<h4 id="7.3%20RabbitMQ%20%E6%80%8E%E4%B9%88%E5%AE%9E%E7%8E%B0%E6%B6%88%E6%81%AF%E5%8F%AF%E9%9D%A0%E6%80%A7">7.3 RabbitMQ 怎么实现消息可靠性</h4> 
<p><strong>7.3.1 生产者投递可靠性</strong></p> 
<p>在使用 RabbitMQ 的时候，作为消息发送方希望杜绝任何消息丢失或者投递失败场景。RabbitMQ 为我们提供了两种方式用来控制消息的投递可靠性模式。</p> 
<p>confirm 确认模式</p> 
<p>return 退回模式</p> 
<p></p> 
<p>rabbitmq 整个消息投递的路径为：</p> 
<p>producer---&gt;rabbitmq broker---&gt;exchange---&gt;queue---&gt;consumer 消息从 producer 到 exchange 则会返回一个 confirmCallback 。 消息从 exchange--&gt;queue 投递失败则会返回一个 returnCallback 。</p> 
<p>我们将利用这两个 callback 控制消息的可靠性投递</p> 
<p></p> 
<p><strong>7.3.2 消费者投递可靠性</strong></p> 
<p>ack指Acknowledge，确认。 表示消费端收到消息后的确认方式。</p> 
<p><strong>有三种确认方式：</strong></p> 
<p>• 自动确认：acknowledge="none"</p> 
<p>• 手动确认：acknowledge="manual"</p> 
<p>• 根据异常情况确认：acknowledge="auto"，（这种方式使用麻烦，不作讲解）</p> 
<p></p> 
<p>其中自动确认是指，当消息一旦被Consumer接收到，则自动确认收到，并将相应 message 从 RabbitMQ 的消息缓存中移除。但是在实际业务处理中，很可能消息接收到，业务处理出现异常，那么该消息就会丢失。如果设置了手动确认方式，则需要在业务处理成功后，调用channel.basicAck()，手动签收，如果出现异常，则调用channel.basicNack()方法，让其自动重新发送消息。</p> 
<h4 id="7.4%20RabbitMQ%20%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E5%BB%B6%E8%BF%9F%E9%98%9F%E5%88%97">7.4 RabbitMQ 如何实现延迟队列</h4> 
<p>延迟队列，即消息进入队列后不会立即被消费，只有到达指定时间后，才会被消费</p> 
<p>需求：</p> 
<ol><li> <p>下单后，30分钟未支付，取消订单，回滚库存。</p> </li><li> <p>新用户注册成功7天后，发送短信问候。</p> </li></ol> 
<p>实现方式：</p> 
<ol><li> <p>定时器</p> </li><li> <p>延迟队列</p> </li></ol> 
<p></p> 
<p><strong>使用延时队列实现</strong></p> 
<p><img alt="" height="307" src="https://images2.imgbox.com/06/54/fKdnYVFY_o.png" width="1200"></p> 
<p></p> 
<p></p> 
<ol><li> <p>延迟队列 指消息进入队列后，可以被延迟一定时间，再进行消费。</p> </li><li> <p>RabbitMQ没有提供延迟队列功能，但是可以使用 ： TTL + DLX 来实现延迟队列效果。</p> </li></ol>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/e28645dd2df082220d22f9a5da5f2cce/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">SpringBoot 配置文件</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/f6df00a7b4b6d8a8f3db3d18f91a65cd/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">[NOIP2017 普及组] 棋盘(dfs记忆化搜索 | bfs优先队列双解法)</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>