<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Quartz-QuartzSchedulerThread详解 - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Quartz-QuartzSchedulerThread详解" />
<meta property="og:description" content="QuartzSchedulerThread详解 QuartzSchedulerThread是一个线程类，负责查询并触发Triggers。
public class QuartzSchedulerThread extends Thread { QuartzSchedulerThread(QuartzScheduler qs, QuartzSchedulerResources qsRsrcs, boolean setDaemon, int threadPrio) { super(qs.getSchedulerThreadGroup(), qsRsrcs.getThreadName()); ........ paused = true; halted = new AtomicBoolean(false); } } 该线程类的主要工作分为以下几个步骤：
等待QuartzScheduler启动查询待触发的Trigger等待Trigger触发时间到来触发Trigger循环上述步骤 /*-----------------run()方法有删减----------------------*/ public void run() { while (!halted.get()) { // ------------------------------- // 1 等待QuartzScheduler启动 // ------------------------------- synchronized (sigLock) { while (paused &amp;&amp; !halted.get()) { // wait until togglePause(false) is called... sigLock.wait(1000L); } } // ------------------------------- // 2 查询待触发的Trigger // ------------------------------- int availThreadCount = qsRsrcs." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/fc1118571d629e7c516555fe71d591ee/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2017-09-01T16:38:00+08:00" />
<meta property="article:modified_time" content="2017-09-01T16:38:00+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Quartz-QuartzSchedulerThread详解</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <div class="show-content-free"> 
 <h2>QuartzSchedulerThread详解</h2> 
 <p>QuartzSchedulerThread是一个线程类，负责查询并触发Triggers。</p> 
 <pre><code class="java">public class QuartzSchedulerThread extends Thread {
    QuartzSchedulerThread(QuartzScheduler qs, QuartzSchedulerResources qsRsrcs, boolean setDaemon, int threadPrio) {
        super(qs.getSchedulerThreadGroup(), qsRsrcs.getThreadName());
        ........
        paused = true;
        halted = new AtomicBoolean(false);
    }
}
</code></pre> 
 <p>该线程类的主要工作分为以下几个步骤：</p> 
 <ul><li>等待QuartzScheduler启动</li><li>查询待触发的Trigger</li><li>等待Trigger触发时间到来</li><li>触发Trigger</li><li>循环上述步骤</li></ul> 
 <pre><code class="java">/*-----------------run()方法有删减----------------------*/
public void run() {
    while (!halted.get()) {
        // -------------------------------
        // 1 等待QuartzScheduler启动
        // -------------------------------
        synchronized (sigLock) {
            while (paused &amp;&amp; !halted.get()) {
                // wait until togglePause(false) is called...
                sigLock.wait(1000L);
            }
        }

        // -------------------------------
        // 2 查询待触发的Trigger
        // -------------------------------
        int availThreadCount = qsRsrcs.getThreadPool().blockForAvailableThreads();
        if(availThreadCount &gt; 0) { // will always be true, due to semantics of blockForAvailableThreads...
            // 查询未来（now + idletime）时间内待触发的Triggers
            // triggers是按触发时间由近及远排序的集合
            List&lt;OperableTrigger&gt; triggers = qsRsrcs.getJobStore().acquireNextTriggers(
                    now + idleWaitTime, Math.min(availThreadCount, qsRsrcs.getMaxBatchSize()), qsRsrcs.getBatchTimeWindow());
            if (triggers != null &amp;&amp; !triggers.isEmpty()) {
                now = System.currentTimeMillis();
                long triggerTime = triggers.get(0).getNextFireTime().getTime();
                long timeUntilTrigger = triggerTime - now;
                // 通过循环阻塞，等待第一个Trigger触发时间
                while(timeUntilTrigger &gt; 2) {
                    synchronized (sigLock) {
                        if (halted.get()) {
                            break;
                        }
                    }
                    now = System.currentTimeMillis();
                    timeUntilTrigger = triggerTime - now;
                }
            // 通知JobStore，这些Triggers将要被触发
            List&lt;TriggerFiredResult&gt; res = qsRsrcs.getJobStore().triggersFired(triggers);
            if(res != null)
                bndles = res;
            }
            // -------------------------------
            // 3 触发Triggers
            // -------------------------------
            for (int i = 0; i &lt; bndles.size(); i++) {
                TriggerFiredResult result =  bndles.get(i);
                TriggerFiredBundle bndle =  result.getTriggerFiredBundle();
                JobRunShell shell = qsRsrcs.getJobRunShellFactory().createJobRunShell(bndle);
                shell.initialize(qs);
                qsRsrcs.getThreadPool().runInThread(shell);
            }
            continue; // while (!halted)
        } else { // if(availThreadCount &gt; 0)
            // should never happen, if threadPool.blockForAvailableThreads() follows contract
            continue; // while (!halted)
        }
    } // while (!halted)
}
</code></pre> 
 <h3>1 等待QuartzScheduler启动</h3> 
 <pre><code class="java">synchronized (sigLock) {
    while (paused &amp;&amp; !halted.get()) {
        // wait until togglePause(false) is called...
        sigLock.wait(1000L);
    }
}
</code></pre> 
 <p>循环检查<code>paused &amp;&amp; !halted.get()</code>条件是否满足，否则释放sigLock对象的锁，并等待，一秒后重试。<br> 当<code>QuartzScheduler</code>对象创建并调用<code>start()</code>方法时，将唤醒QuartzSchedulerThread线程，即可跳出阻塞块，继续执行。</p> 
 <pre><code class="java">/*QuartzScheduler*/
public void start() throws SchedulerException {
    ....
    schedThread.togglePause(false);
    ....
}

/*QuartzSchedulerThread*/
void togglePause(boolean pause) {
    synchronized (sigLock) {
        // 更改暂停状态
        paused = pause;
        if (paused) {
            signalSchedulingChange(0);
        } else {
            // 唤醒在sigLock上等待的所有线程
            sigLock.notifyAll();
        }
    }
}
</code></pre> 
 <h3>2 查询待触发的Trigger</h3> 
 <p>Quartz未雨绸缪，从JobStore中获取当前时间后移一段时间内（idle time + time window）将要触发的Triggers，以及在当前时间前移一段时间内（misfireThreshold）错过触发的Triggers(这里仅查询Trigger的主要信息)。被查询到的Trggers状态变化：STATE_WAITING--&gt;STATE_ACQUIRED。结果集是以触发时间升序、优先级降序的集合。</p> 
 <pre><code class="java">public List&lt;TriggerKey&gt; selectTriggerToAcquire(Connection conn, long noLaterThan, long noEarlierThan, int maxCount)
        throws SQLException {
}
</code></pre> 
 <pre><code class="sql">SELECT
    TRIGGER_NAME,
    TRIGGER_GROUP,
    NEXT_FIRE_TIME,
    PRIORITY
FROM
    QRTZ_TRIGGERS
WHERE
    SCHED_NAME = 'TestScheduler'
AND TRIGGER_STATE = ?
AND NEXT_FIRE_TIME &lt;= ?
AND (
    MISFIRE_INSTR = - 1
    OR (
        MISFIRE_INSTR != - 1
        AND NEXT_FIRE_TIME &gt;= ?
    )
)
ORDER BY
    NEXT_FIRE_TIME ASC,
    PRIORITY DESC
</code></pre> 
 <h3>3 等待Trigger触发时间到来</h3> 
 <p>因为上一步取得的Triggers是按时间排序的集合，所以取集合中的第一个，即触发时间最早的Trigger，等待其触发时间的到来。老套路while循环+wait实现。<br> 不过需要注意的是，在此期间，可能有一些新的情况发生，比如说，新增了一个Trigger，并且该新增的Trigger比前面获取的触发时间都早，那么就需要将上面获取的Trigger释放掉(状态变化:STATE_ACQUIRED--&gt;STATE_WAITING)，然后重新查询Trggers</p> 
 <pre><code class="java">now = System.currentTimeMillis();
long triggerTime = triggers.get(0).getNextFireTime().getTime();
long timeUntilTrigger = triggerTime - now;
// 当触发时间距当前时间&lt;=2 ms时，结束循环
while(timeUntilTrigger &gt; 2) {
    synchronized (sigLock) {
        if (halted.get()) {
            break;
        }
        // 判断在此过程中是否有新增的并且触发时间更早的Trigger
        // 但是此处有个权衡，为了一个新增的的Trigger而丢弃当前已获取的是否值得？
        // 丢弃当前获取的Trigger并重新获取需要花费一定的时间，时间的长短与JobStore的实现有关。
        // 所以此处做了主观判断，如果使用的是数据库存储，查询时间假定为70ms，内存存储假定为7ms
        // 如果当前时间距已获得的第一个Trigger触发时间小于查询时间，则认为丢弃是不合算的。
        if (!isCandidateNewTimeEarlierWithinReason(triggerTime, false)) {
            try {
                // we could have blocked a long while
                // on 'synchronize', so we must recompute
                now = System.currentTimeMillis();
                timeUntilTrigger = triggerTime - now;
                // 距触发时间太早，先休息会吧
                if(timeUntilTrigger &gt;= 1)
                    sigLock.wait(timeUntilTrigger);
            } catch (InterruptedException ignore) {
            }
        }
    }
    // 如果有新增的且触发时间更早的Trigger过来搅局，则释放上面已获取的Trigger，等待下一波查询
    if(releaseIfScheduleChangedSignificantly(triggers, triggerTime)) {
        break;
    }
    now = System.currentTimeMillis();
    timeUntilTrigger = triggerTime - now;
}
</code></pre> 
 <h3>4 触发Trigger</h3> 
 <p>前面提到过，先前只是获取Trigger的主要信息，其关联的Job、Calendar等信息是在触发前获取的。待Trigger所需信息验证、关联完成后，先行将Trigger的状态改为STATE_ACQUIRED--&gt;STATE_COMPLETE。而后将Trigger封装后的TriggerFiredResult对象交由JobRunShell执行。</p> 
 <pre><code class="java">List&lt;TriggerFiredResult&gt; res = qsRsrcs.getJobStore().triggersFired(triggers);
for (int i = 0; i &lt; bndles.size(); i++) {
    TriggerFiredResult result =  bndles.get(i);
    TriggerFiredBundle bndle =  result.getTriggerFiredBundle();
    JobRunShell shell = qsRsrcs.getJobRunShellFactory().createJobRunShell(bndle);
    shell.initialize(qs);
    qsRsrcs.getThreadPool().runInThread(shell);
}
</code></pre> 
</div>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/5283847c6157f8ad2e828c3dbbd77c91/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">AJAX 加载数据</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/f29c190ac0e190c93760b4be1f997112/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">VMware共享文件夹</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>