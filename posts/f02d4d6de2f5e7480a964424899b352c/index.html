<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>flutter学习笔记 - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="flutter学习笔记" />
<meta property="og:description" content="Flutter万物皆组件，dart万物皆对象
Flutter 工程目录结构 https://blog.csdn.net/u013491829/article/details/108624331
flutter介绍: 1.跨平台移动UI框架
2.与现有的代码一起工作(可以直接嵌入到原生代码中或直接把原生代码嵌入到自己的代码中运行)
3. 完全免费、开源
flutter优缺点 优点: 1.Flutter在Debug使用JIT编译，支持热重载，能够提高我们的开发效率，而Release中利用AOT直接编译成机器码，能够达到更好的性能,即时编译 (JIT) 或提前编译 (AOT)
2.跨多种平台，减少开发成本；支持插件，可以访问原生系统的调用。
3.有自己的engine引擎,渲染引擎skia和dartVM虚拟机
4.UI一致性 美观：可对 UI 实现像素级的控制，且内置 UI 库 ( Material、Cupertino )
快速：硬件加速图形引擎、代码被编译成机器码
高效：保持应用状态的热重载 ( hot reload )
开放：完全开源的项目 ( BSD 开源协议 )
Flutter之所以渲染效率高，是因为Flutter采用的是增量渲染的机制，判断一个Widget应该被更新重新渲染，是调用的 static bool canUpdate(Widget oldWidget, Widget newWidget) { return oldWidget.runtimeType == newWidget.runtimeType &amp;&amp; oldWidget.key == newWidget.key; } 缺点： 1.脱离不开原生，开发人员需要具备原生（Android、iOS）基础开发能力；
2.适配问题，开发工具版本升级后，修改量大；
3.原生集成第三方SDK后，兼容性适配是个令人头痛的问题；
4.代码可读性较差，对代码质量和管理要求较高；
5.打包后，apk/ipa要大很多;
6.Flutter packages和Dart packages上第三方sdk繁杂，适配性差，不可乱用；
7.目前几乎没有第三方开发者平台开发Flutter能力的SDK，需要原生去集成；
8.Widget的类型难以选择，糟糕的UI控件API
下列业务场景下，Flutter 明显不占据优势 1.如果你的业务场景是多框架混合开发，那 Flutter 明显不占据优势；" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/f02d4d6de2f5e7480a964424899b352c/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2024-01-18T17:27:39+08:00" />
<meta property="article:modified_time" content="2024-01-18T17:27:39+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">flutter学习笔记</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p></p> 
<p>Flutter万物皆组件，dart万物皆对象</p> 
<p>Flutter 工程目录结构 https://blog.csdn.net/u013491829/article/details/108624331</p> 
<h3>flutter介绍:</h3> 
<p>1.跨平台移动UI框架<br> 2.与现有的代码一起工作(可以直接嵌入到原生代码中或直接把原生代码嵌入到自己的代码中运行)<br> 3. 完全免费、开源</p> 
<h3><br> flutter优缺点</h3> 
<h4>优点:</h4> 
<p>1.Flutter在Debug使用JIT编译，支持热重载，能够提高我们的开发效率，而Release中利用AOT直接编译成机器码，能够达到更好的性能,即时编译 (JIT) 或提前编译 (AOT)<br> 2.跨多种平台，减少开发成本；支持插件，可以访问原生系统的调用。<br> 3.有自己的engine引擎,渲染引擎skia和dartVM虚拟机<br> 4.UI一致性  </p> 
<ol><li> <p>美观：可对 UI 实现像素级的控制，且内置 UI 库 ( Material、Cupertino )</p> </li><li> <p>快速：硬件加速图形引擎、代码被编译成机器码</p> </li><li> <p>高效：保持应用状态的热重载 ( hot reload )</p> </li><li> <p>开放：完全开源的项目 ( BSD 开源协议 )</p> </li><li><code>Flutter</code>之所以渲染效率高，是因为<code>Flutter</code>采用的是增量渲染的机制，判断一个<code>Widget</code>应该被更新重新渲染，是调用的 
  <div> 
   <pre><code>static bool canUpdate(Widget oldWidget, Widget newWidget) {
  return oldWidget.runtimeType == newWidget.runtimeType
      &amp;&amp; oldWidget.key == newWidget.key;
}</code></pre> 
  </div> </li></ol> 
<h4>缺点：</h4> 
<p>1.脱离不开原生，开发人员需要具备原生（Android、iOS）基础开发能力；<br> 2.适配问题，开发工具版本升级后，修改量大；<br> 3.原生集成第三方SDK后，兼容性适配是个令人头痛的问题；<br> 4.代码可读性较差，对代码质量和管理要求较高；<br> 5.打包后，apk/ipa要大很多;<br> 6.Flutter packages和Dart packages上第三方sdk繁杂，适配性差，不可乱用；<br> 7.目前几乎没有第三方开发者平台开发Flutter能力的SDK，需要原生去集成；<br> 8.Widget的类型难以选择，糟糕的UI控件API</p> 
<h4><strong>下列业务场景下，Flutter 明显不占据优势</strong></h4> 
<p>1.如果你的业务场景是多框架混合开发，那 Flutter 明显不占据优势；</p> 
<p>2.如果你的场景是需要很强的文本编辑和富文本场景，那 Flutter 明显不占据优势；</p> 
<p>3.如果你的 KPI 对内存占用特别敏感，那 Flutter 也不是特别占据优势；</p> 
<p>4.如果你需要热更新，那 Flutter 也并不占据优势；</p> 
<p>flutter声明式UI的好处：<a href="https://mp.weixin.qq.com/s/0iCkQiMwHek46sFjSNJnZA" rel="nofollow" title="从Flutter到Compose，为什么都在推崇声明式UI？">从Flutter到Compose，为什么都在推崇声明式UI？</a></p> 
<p style="text-align:center;"><br><img alt="" height="313" src="https://images2.imgbox.com/4e/4c/TyBvlBxH_o.png" width="570"></p> 
<p></p> 
<h4><span style="color:#4a4a4a;"><span style="background-color:#ffffff;">为现有的 Flutter 应用程序添加桌面支持</span></span></h4> 
<p><span style="color:#4a4a4a;"><span style="background-color:#ffffff;">官网链接：</span></span><a href="https://flutter.dev/desktop" rel="nofollow" title="Flutter | Desktop support for Flutter">Flutter | Desktop support for Flutter</a></p> 
<p style="text-align:left;"><span style="color:#4a4a4a;"><span style="background-color:#ffffff;">要将桌面支持添加到现有 Flutter 项目，请从项目根目录在终端中运行以下命令：</span></span></p> 
<div style="text-align:left;"> 
 <div> 
  <div> 
   <pre class="has"><code class="language-highlight">flutter create --platforms=windows,macos,linux .</code></pre> 
  </div> 
 </div> 
</div> 
<p style="text-align:left;"><span style="color:#4a4a4a;"><span style="background-color:#ffffff;">这会将必要的桌面文件和目录添加到您现有的 Flutter 项目中。要仅添加特定桌面平台，请将<code class="language-plaintext">platforms</code>列表更改为仅包含您要添加的平台</span></span></p> 
<h4 style="text-align:left;"><span style="color:#4a4a4a;"><span style="background-color:#ffffff;">macOS下配置网络支持</span></span></h4> 
<p>1.编辑DebugProfile.entitlements文件</p> 
<div> 
 <pre><code class="language-java">&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd"&gt;
&lt;plist version="1.0"&gt;
&lt;dict&gt;
	&lt;key&gt;com.apple.security.app-sandbox&lt;/key&gt;
	&lt;true/&gt;
	&lt;key&gt;com.apple.security.cs.allow-jit&lt;/key&gt;
	&lt;true/&gt;
	&lt;key&gt;com.apple.security.network.server&lt;/key&gt;
	&lt;true/&gt;
	&lt;key&gt;com.apple.security.network.client&lt;/key&gt;
	&lt;true/&gt;
&lt;/dict&gt;
&lt;/plist&gt;</code></pre> 
</div> 
<p>2.编辑release.entitlements文件</p> 
<div> 
 <pre><code class="language-java">&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd"&gt;
&lt;plist version="1.0"&gt;
&lt;dict&gt;
	&lt;key&gt;com.apple.security.app-sandbox&lt;/key&gt;
	&lt;true/&gt;
	&lt;key&gt;com.apple.security.network.server&lt;/key&gt;
    &lt;true/&gt;
    &lt;key&gt;com.apple.security.network.client&lt;/key&gt;
    &lt;true/&gt;
&lt;/dict&gt;
&lt;/plist&gt;</code></pre> 
</div> 
<p></p> 
<h3>基础</h3> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/0e/8c/PtVr6rAr_o.jpg"></p> 
<p></p> 
<h4>1.widget</h4> 
<p><a href="https://flutter.cn/docs/reference/widgets" rel="nofollow" title="Flutter Widget 目录 - Flutter 中文文档 - Flutter 中文开发者网站 - Flutter">Flutter Widget 目录 - Flutter 中文文档 - Flutter 中文开发者网站 - Flutter</a></p> 
<p><code>Widget</code> 下面有五个子类， <code>PreferredSizeWidget</code> 下面总共有6个组件， <code>ProxyWidget</code> 下面总共有47个组件， <code>RenderObjectWidget</code> 下面总共有94个组件， <code>StateFulWidget</code> 下面总共有167个组件， <code>StatelessWidget</code> 下面总共有108个组件，加上自身5个组件，所以总共的组件有高达427之多，这可能也是很多人觉得Flutter很难学的原因之一，其实我们只要掌握一些基本常用的可以了。参考：<a href="https://www.liujunmin.com/flutter/inheritanc_diagram.html" rel="nofollow" title="Flutter深入浅出组件篇---继承关系图 | Jimi">Flutter深入浅出组件篇---继承关系图 | Jimi</a></p> 
<ul><li><strong>PreferredSizeWidget</strong>：主要用于 <code>AppBar</code> 和 <code>TabBar</code> , 通过继承该类可实现自定义大小。</li><li><strong>ProxyWidget</strong>: 是一个抽象类，主要用于提供给子 <code>Widget</code> 的抽象 <code>Widget</code></li><li><strong>RenderObjectWidget</strong>：是一个抽象类， <code>RenderObjectWidgets</code> 为 <code>RenderObjectElements</code> 提供配置，它包装 <code>RenderObjects</code> ，提供应用程序的实际渲染。</li><li><strong>StateFulWidget</strong>：具有可变状态的 <code>Widget</code></li><li><strong>StatelessWidget</strong>：不需要可变状态的 <code>Widget</code></li></ul> 
<p></p> 
<p><strong>图片</strong></p> 
<p>参考另一片文章：<a href="http://t.csdn.cn/eDKvF" rel="nofollow" title="http://t.csdn.cn/eDKvF">http://t.csdn.cn/eDKvF</a></p> 
<p><strong>按钮  </strong><br> RaisedButton---被elevatedbutton替代 </p> 
<p>OutlineButton---被OutlinedButton替代  </p> 
<p>FlatButton---被textbutton替代</p> 
<p><strong>文字 </strong><br> Text。 overflow:（设置溢出显示方式）。  Maxlines(设置行数）</p> 
<p>strutStyle: const StrutStyle(forceStrutHeight: true)</p> 
<p><strong>输入框</strong> textfield。  Autofocus:false,(最好设置成false)<br> 参考：https://blog.csdn.net/zl18603543572/article/details/103772941</p> 
<p>Flutter TextField内容垂直居中<br>  decoration: InputDecoration(<br>         contentPadding: EdgeInsets.zero,<br>         border: OutlineInputBorder(borderSide: BorderSide.none),)</p> 
<p>参考另一篇文章“flutter开发错误积累”中的8.TextField相关的问题</p> 
<p><strong>点击事件</strong><br> 在flutter 开发中用InkWell或者GestureDetector将某个组件包起来，可添加点击事件。<br> GestureDetector 使用点击无水波纹出现，InkWell可以实现水波纹效果。</p> 
<p><strong>GestureDetector</strong></p> 
<p>behavior 手势检测器在触摸中应该如何工作</p> 
<pre><code class="language-Dart">
  /// How this gesture detector should behave during hit testing.
  ///
  /// This defaults to [HitTestBehavior.deferToChild] if [child] is not null and
  /// [HitTestBehavior.translucent] if child is null.
  final HitTestBehavior? behavior;


/// How to behave during hit tests.
enum HitTestBehavior {
  /// Targets that defer to their children receive events within their bounds
  /// only if one of their children is hit by the hit test.
  deferToChild,

  /// Opaque targets can be hit by hit tests, causing them to both receive
  /// events within their bounds and prevent targets visually behind them from
  /// also receiving events.
  opaque,

  /// Translucent targets both receive events within their bounds and permit
  /// targets visually behind them to also receive events.
  translucent,
}</code></pre> 
<p>HitTestBehavior.deferToChild:只有当前容器中的child被点击时才会响应点击事件<br> HitTestBehavior.opaque:点击整个区域都会响应点击事件，但是点击事件不可穿透向下传递，注释翻译：阻止视觉上位于其后方的目标接收事件。<br> HitTestBehavior.translucent:同样是点击整个区域都会响应点击事件，和opaque的区别是点击事件是否可以向下传递，注释翻译：半透明目标既可以在其范围内接受事件，也可以允许视觉上位于其后方的目标接收事件</p> 
<div></div> 
<p><strong>InkWell</strong></p> 
<p>inkwell去除水波纹效果添加属性</p> 
<div> 
 <pre><code class="language-java">splashFactory: NoSplash.splashFactory,</code></pre> 
</div> 
<p>InkWell 水波纹会超出 Container 的圆角,把 InkWell 与 Container 设置同样的圆角.<br> InkWell(<br>         onTap: (){<!-- --><br>           print("点击事件");<br>         },<br>         borderRadius: BorderRadius.circular(10),<br>         child: Container(<br>           decoration: BoxDecoration(<br>             borderRadius: BorderRadius.circular(10)<br>           ),<br>         ),<br>       )</p> 
<p>    <br><strong>日期</strong>。   flutter_cupertino_date_picker.第三方日期库    date_format日期格式化三方库.   flutter自带日期选择showdatepicker。 自带日期选择showtimepicker。</p> 
<p><strong>对话框。</strong> showmodalbottomsheet.底部弹出对话框。       alertdialog普通对话框。   simpledialog选择对话框 </p> 
<p> <strong>卡片</strong><br> card。   clipBehavior:  //对Widget截取的行为，比如这里 Clip.antiAlias 指抗锯齿</p> 
<p><strong>IntrinsicHeight</strong>：根据子元素的固定高度调整其子元素大小的组件，可以让其内部高度对齐，因为  <code>IntrinsicHeight</code> 在布局时会提前调用 child 的 <code>getMaxIntrinsicHeight</code> 获取 child 的高度，修改 parent 传递给 child 的约束信息。</p> 
<p>缺点：<code>IntrinsicHeight</code> 推算布局的过程会比较费时，可能会到 O（N²），虽然 Flutter 里针对这部分计算结果做了缓存，但是不妨碍它的耗时。</p> 
<p></p> 
<p>=========================<strong>滚动组件</strong>start======================================</p> 
<p>给滚动组件添加滚动条：<strong><code>Scrollbar</code></strong>是一个Material风格的滚动指示器（滚动条），如果要给可滚动组件添加滚动条，只需将<code>Scrollbar</code>作为可滚动组件的任意一个父级组件即可</p> 
<p><strong>SingleChildScrollView</strong>：类似于Android中的<code>ScrollView</code>，它只能接收一个子组件，没有“懒加载”模式，所以只在内容不会超过屏幕太多时使用,且内容没超过屏幕时不滑动</p> 
<p id="_6-3-listview"><strong>ListView</strong>:它可以沿一个方向线性排布所有子组件，并且它也支持基于Sliver的延迟构建模型(懒加载),listview()构造方法没有懒加载模式，listview.builder()构造函数有懒加载模式</p> 
<p>使用属性：cacheextent设置缓存的条目个数</p> 
<p>Listview 横向要设置宽高。   纵向的设置高<br> 跳转到指定的位置。  添加控制器。var scrollController=new ScrollController();    scrollController.jumpTo(0.0);<br> 移除 ListView，GridView 的间距，MediaQuery.removeViewPadding().<br> MediaQuery.removeViewPadding(<br>         context: context,<br>         child: ListView(),<br>         removeTop: true,<br>         removeBottom: true,<br>         removeLeft: true,<br>         removeRight: true,<br>       )</p> 
<p>优化点：itemextent固定主轴大小，能提高性能</p> 
<p><strong>Dismissible</strong>组件可通过左滑或者右滑清除列表项</p> 
<p><strong>GridView</strong>:主要关心SliverGridDelegate，他有两个字类</p> 
<ul><li><code>SliverGridDelegateWithFixedCrossAxisCount</code>该子类实现了一个横轴为固定数量子元素的layout算法</li><li><code>SliverGridDelegateWithMaxCrossAxisExtent</code>该子类实现了一个横轴子元素为固定最大长度的layout算法</li><li><strong>如果你的子元素宽高比例不为1，那么你一定要设置<code>childAspectRatio</code>属性</strong>。</li><li>下面是参考文章</li><li><a href="https://www.jianshu.com/p/d0171dbbcad5?utm_campaign=maleskine&amp;utm_content=note&amp;utm_medium=seo_notes&amp;utm_source=recommendation" rel="nofollow" title="Flutter网格型布局 - GridView篇 - 简书">Flutter网格型布局 - GridView篇 - 简书</a></li></ul> 
<p><strong>CustomScrollView</strong>：子组件必须都是sliver，使用场景：1.ListView和GridView相互嵌套场景，ListView嵌套GridView时，需要给GridView指定高度，但我们希望高度随内容而变化（不指定），ListView和GridView使用同一个滚动效果。<br> 2.一个页面顶部是AppBar，然后是GridView，最后是ListView，这3个区域以整体来滚动，AppBar具有吸顶效果。</p> 
<p></p> 
<p id="nestedscrollview"><strong>NestedScrollView</strong>:它是对<strong>CustomScrollView的封装，</strong>可以在其内部嵌套其他滚动视图的滚动视图，其滚动位置是固有链接的，有2个ScrollController：一个是inner，一个outer。 outer是负责headerSliverBuilder里面的滚动widgets inner是负责body里面的滚动widgets ，当outer滚动到底了之后，才会开始滚动inner</p> 
<p>系统<strong>NestedScrollView</strong>的有两个问题：ExtendedNestedScrollView三方库解决了</p> 
<p>相关文章链接：<a href="https://juejin.cn/post/6844903713887240206" rel="nofollow" title="Flutter 扩展NestedScrollView （一）Pinned头引起的bug解决 - 掘金">Flutter 扩展NestedScrollView （一）Pinned头引起的bug解决 - 掘金</a></p> 
<p>1.<a href="https://link.juejin.cn/?target=https%3A%2F%2Fgithub.com%2Fflutter%2Fflutter%2Fissues%2F22393" rel="nofollow" title="当中的Pinned为true的Sliver组件对body里面滚动组件的影响">当中的Pinned为true的Sliver组件对body里面滚动组件的影响</a></p> 
<p>解决：pinnedHeaderSliverHeightBuilder是我从最外层传递进来的用于获取当时Pinned 为true的全部Sliver header的高度.在这里把outer最大的滚动extent减去了Pinned 的总的高度，就完美解决了</p> 
<p>2.<a href="https://link.juejin.cn/?target=https%3A%2F%2Fgithub.com%2Fflutter%2Fflutter%2Fissues%2F21868" rel="nofollow" title="当在里面放上tabview，并且tab是缓存状态的时候，会出现滚动会互相影响的问题">当在里面放上tabview，并且tab是缓存状态的时候，会出现滚动会互相影响的问题</a>（列表滚动同步问题）</p> 
<p>解决：提供一个容器，把inner里面的滚动列表包裹起来，并且设置它的tab 的唯一key</p> 
<p></p> 
<p><strong>系统提供的ScrollPhysics有</strong>：</p> 
<ul><li>AlwaysScrollableScrollPhysics：总是可以滑动</li><li>NeverScrollableScrollPhysics：禁止滚动</li><li>BouncingScrollPhysics ：内容超过一屏 上拉有回弹效果</li><li>ClampingScrollPhysics ：包裹内容 不会有回弹</li></ul> 
<p></p> 
<p id="listwheelscrollview"><strong>ListWheelScrollView:</strong>它的渲染效果类似于车轮（或者滚筒）</p> 
<p><strong>ReorderableListView:</strong>是通过长按拖动某一项到另一个位置来重新排序的列表组件。</p> 
<p>参考：</p> 
<p><a href="https://blog.csdn.net/weixin_44486516/article/details/123354418" title="学习记录：Flutter中的滑动_flutter 滚动_田螺与呆瓜的博客-CSDN博客">学习记录：Flutter中的滑动_flutter 滚动_田螺与呆瓜的博客-CSDN博客</a></p> 
<p>=========================滚动组件end======================================</p> 
<p>=========================sliver系列start=====================================<br> 控件：<br> 1.SliverPersistentHeader：可以固定在顶部</p> 
<p>2.SliverList。 </p> 
<p>3.SliverFixedExtentList是sliver系列组件之一，和SliverList用法一样，唯一的区别就是SliverFixedExtentList是固定子控件的高度的，SliverFixedExtentList比SliverList更加高效，因为SliverFixedExtentList无需计算子控件的布局</p> 
<p>4.SliverFillRemaining是sliver系列组件之一，此组件充满视口剩余空间，通常用于最后一个sliver组件，以便于没有任何剩余控件。</p> 
<p>5.SliverPrototypeExtentList和SliverList用法一样，区别是SliverPrototypeExtentList的高度由prototypeItem控件决定。</p> 
<p>SliverPrototypeExtentList 比SliverList更加高效，因为SliverFixedExtentList无需计算子控件的布局。</p> 
<p>SliverPrototypeExtentList比SliverFixedExtentList更加灵活，因为SliverPrototypeExtentList不必指定像素高度。</p> 
<p>SliverPrototypeExtentList通常用于不确定item高度，随prototypeItem变化的场景,比如调整整个App字体的大小，字体越大，需要的高度越高，如果使用SliverFixedExtentList指定具体的高度，会出现字体显示不全的状况。</p> 
<p>6.SliverFillViewport生成的每一个item都占满全屏,viewportFraction表示比率，默认是1，表示占满全屏，如果设置0.8，则在开始和结尾处出现空白</p> 
<p>属性：<br> floating 设置为true时，向下滑动时，即使当前CustomScrollView不在顶部，SliverAppBar也会跟着一起向下出现</p> 
<p>pinned 设置为true时，当SliverAppBar内容滑出屏幕时，将始终渲染一个固定在顶部的收起状态</p> 
<pre><code class="language-Dart">const SliverAppBar({
    Key key,
    this.leading,         //在标题左侧显示的一个控件，在首页通常显示应用的 logo；在其他界面通常显示为返回按钮
    this.automaticallyImplyLeading = true,//? 控制是否应该尝试暗示前导小部件为null
    this.title,               //当前界面的标题文字
    this.actions,          //一个 Widget 列表，代表 Toolbar 中所显示的菜单，对于常用的菜单，通常使用 IconButton 来表示；对于不常用的菜单通常使用 PopupMenuButton 来显示为三个点，点击后弹出二级菜单
    this.flexibleSpace,        //一个显示在 AppBar 下方的控件，高度和 AppBar 高度一样， // 可以实现一些特殊的效果，该属性通常在 SliverAppBar 中使用
    this.bottom,         //一个 AppBarBottomWidget 对象，通常是 TabBar。用来在 Toolbar 标题下面显示一个 Tab 导航栏
    this.elevation,            //阴影
    this.forceElevated = false, 
    this.backgroundColor,       //APP bar 的颜色，默认值为 ThemeData.primaryColor。改值通常和下面的三个属性一起使用
    this.brightness,   //App bar 的亮度，有白色和黑色两种主题，默认值为 ThemeData.primaryColorBrightness
    this.iconTheme,  //App bar 上图标的颜色、透明度、和尺寸信息。默认值为 ThemeData().primaryIconTheme
    this.textTheme,    //App bar 上的文字主题。默认值为 ThemeData（）.primaryTextTheme
    this.primary = true,  //此应用栏是否显示在屏幕顶部
    this.centerTitle,     //标题是否居中显示，默认值根据不同的操作系统，显示方式不一样,true居中 false居左
    this.titleSpacing = NavigationToolbar.kMiddleSpacing,//横轴上标题内容 周围的间距
    this.expandedHeight,     //展开高度
    this.floating = false,       //是否随着滑动隐藏标题
    this.pinned = false,  //是否固定在顶部
    this.snap = false,   //与floating结合使用
  })
</code></pre> 
<p></p> 
<p>=========================sliver系列end=====================================</p> 
<p>=====================PageView和<code>TarBarView相关start======================</code></p> 
<p><strong>PageView</strong>控件可以实现一个“图片轮播”的效果，PageView不仅可以水平滑动也可以垂直滑动</p> 
<p>如果你在使用 <code>TarBarView</code> ，并且使用了 <code>KeepAlive</code> 的话，那么我推荐你直接使用 <code>PageView</code> 。因为目前到 1.2 的版本，在 <code>KeepAlive</code> 的 状态下，跨两个页面以上的 Tab 直接切换， <code>TarBarView</code> 会导致页面的 <code>dispose</code> 再重新 <code>initState</code>。尽管 <code>TarBarView</code> 内也是封装了 <code>PageView</code> + <code>TabBar</code> 。</p> 
<p>你可以直接使用 <code>PageView</code> + <code>TabBar</code> 去实现，然后 tab 切换时使用 <code>_pageController.jumpTo(MediaQuery.of(context).size.width * index);</code> 可以避免一些问题。当然，这时候损失的就是动画效果了。事实上 <code>TarBarView</code> 也只是针对 <code>PageView</code> + <code>TabBar</code> 做了一层封装。</p> 
<p>除了这个，其实还有第二种做法，使用如下方 <strong><code>PageStorageKey</code></strong> 保持页面数状态，但是因为它是 <em>save and restore values</em> ，所以的页面的 <code>dispose</code> 再重新 <code>initState</code> 方法，每次都会被调用。</p> 
<pre><code class="language-Dart"> return new Scaffold(
      key: new PageStorageKey&lt;your value type&gt;(your value)
    )</code></pre> 
<p><strong>关联TabBar和TabBarView这两个组件的桥梁：</strong></p> 
<p>TabController，与其并列的还有DefaultTabController，两者的区别是TabController一般放在有状态组件中使用，而DefaultTabController一般放在无状态组件中使用</p> 
<p id="articleContentId"><strong> 去掉 TabBar 点击时的阴影以及波纹效果</strong></p> 
<div> 
 <pre><code class="language-Dart">Theme(
  data: ThemeData(
    splashColor: Colors.transparent, // 点击时的水波纹颜色设置为透明
    highlightColor: Colors.transparent, // 点击时的背景高亮颜色设置为透明
  ),
  child: TabBar(
  	...
  ),
)
</code></pre> 
</div> 
<p></p> 
<p>=====================PageView和<code>TarBarView相关start======================</code></p> 
<h4>2.布局(向下传递约束，向上传递尺寸,上层决定下层的位置)         (快捷键Alt+enter)</h4> 
<p><a href="https://flutter.cn/docs/development/ui/layout/constraints" rel="nofollow" title="深入理解 Flutter 布局约束 | Flutter 中文文档 | Flutter 中文开发者网站">深入理解 Flutter 布局约束 | Flutter 中文文档 | Flutter 中文开发者网站</a></p> 
<h4><img alt="" height="159" src="https://images2.imgbox.com/ec/a9/RQEahbQR_o.jpg" width="344">​<img alt="" src="https://images2.imgbox.com/3c/72/786s4LTC_o.png"></h4> 
<div> 
 <p><strong>Stack</strong>：帧布局 ,Positioned用于定位Stack子组件，Positioned必须是Stack的子组件,只能用于stack中        </p> 
</div> 
<p><strong>Column:</strong>线性布局，垂直方向  </p> 
<p><strong>Row:</strong>线性布局，水平方向  mainAxisAlignment（主轴的排序方式）: MainAxisAlignment.spaceEvenly,（平分比较常用）   crossAxisAlignment（次轴的排序方式，这里是纵轴，用的比较少） </p> 
<p>Expanded、Flexible和Spacer都是具有权重属性的组件，可以控制Row、Column、Flex的子控件如何布局的控件。   </p> 
<p><code>Row</code> 和 <code>UnconstrainedBox</code> 一样， 不会对其子代施加任何约束，而是让它们成为所需的任意大小。</p> 
<p><code>Row</code> 要么使用子级的宽度，要么使用<code>Expanded</code> 和 <code>Flexible</code> 从而忽略子级的宽度</p> 
<p><strong>SizeBox</strong>(height:10)SizeBox(width:10)或可以使两个布局中间加10的间距</p> 
<p><strong>Divider</strong>()添加分割线</p> 
<p></p> 
<p>=========================<strong>尺寸限制类容器start================================</strong></p> 
<p><strong>尺寸限制类容器</strong>用于限制容器大小，Flutter中尺寸限制类容器组件包括ConstrainedBox、UnconstrainedBox、SizedBox、AspectRatio、FractionallySizedBox、LimitedBox、Container</p> 
<p><strong><code>ConstrainedBox</code></strong>有多级嵌套时，多级BoxConstraints嵌套约束最大值最终值等于多个BoxConstraints约束中的最小值，同理嵌套约束最小值等于多个BoxConstraints约束中的最大值；<strong>适用于需要设置最大/小宽高，组件大小依赖子组件大小，但不能超过设置的界限。</strong></p> 
<p><strong>如下代码：显示的是父布局的宽高</strong></p> 
<pre><code class="language-Dart">ConstrainedBox(
  constraints: const BoxConstraints(
    minWidth: 70,
    minHeight: 70,
    maxWidth: 150,
    maxHeight: 150),
  child: Container(color: red, width: 10, height: 10))</code></pre> 
<p>解释：你可能会猜想 <code>Container</code> 的尺寸会在 70 到 150 像素之间，但并不是这样。 <code>ConstrainedBox</code> 仅对其从其父级接收到的约束下施加其他约束。</p> 
<p>在这里，屏幕迫使 <code>ConstrainedBox</code> 与屏幕大小完全相同，因此它告诉其子 <code>Widget</code> 也以屏幕大小作为约束，从而忽略了其 <code>constraints</code> 参数带来的影响。</p> 
<p></p> 
<p><strong>UnconstrainedBox</strong>虽然不限制其子控件的大小，但仍然受父控件的约束，子控件的大小超出父控件的区域将会溢出。</p> 
<p><strong><code>OverflowBox</code></strong> 与 <code>UnconstrainedBox</code> 类似，但不同的是，如果其子级超出该空间，它将不会显示任何警告。</p> 
<p><strong>SizedBox</strong>是具有固定宽高的组件，直接指定具体的宽高；<strong>适用于固定宽高的情况，常用于当作2个组件之间间隙组件。</strong></p> 
<p><strong>AspectRatio</strong>组件是固定宽高比的组件，如果组件的宽度固定，希望高是宽的1/2，可以用AspectRatio实现此效果；<strong>适用于固定宽高比的情况。</strong></p> 
<p><strong>FractionallySizedBox</strong>当我们需要一个控件的尺寸是相对尺寸时，比如当前按钮的宽度占父组件的70%，可以使用FractionallySizedBox来实现此效果；<strong>适用于占父组件百分比的情况。</strong></p> 
<p><strong>LimitedBox</strong>：它受到父组件的约束，此时LimitedBox将会不做任何操作，我们可以认为没有这个组件；如：父组件宽度100，它的宽度50，最终显示的效果宽度是100；<strong>适用于没有父组件约束的情况。它限制仅在获得无限约束时才适用</strong></p> 
<p><strong><code>FittedBox</code></strong> :只能在有限制的宽高中对子 widget 进行缩放（宽度和高度不会变得无限大）。否则，它将无法渲染任何内容，并且你会在控制台中看到错误。<a href="https://flutter.cn/docs/development/ui/layout/constraints" rel="nofollow" title="深入理解 Flutter 布局约束 | Flutter 中文文档 | Flutter 中文开发者网站">深入理解 Flutter 布局约束 | Flutter 中文文档 | Flutter 中文开发者网站</a></p> 
<p><strong>Container</strong>：<strong>适用于不仅有尺寸的约束，还有装饰（颜色、边框、等）、内外边距等需求的情况</strong><a href="https://blog.csdn.net/mengks1987/article/details/104388393" title="Flutter Widgets 之 Container_老孟Flutter-CSDN博客">Flutter Widgets 之 Container_老孟Flutter-CSDN博客</a></p> 
<div> 
 <pre><code class="language-java">装饰器
BoxDecoration({
  Color color, //颜色
  DecorationImage image,//图片
  BoxBorder border, //边框
  BorderRadiusGeometry borderRadius, //圆角
  List&lt;BoxShadow&gt; boxShadow, //阴影,可以指定多个
  Gradient gradient, //渐变
  BlendMode backgroundBlendMode, //背景混合模式
  BoxShape shape = BoxShape.rectangle, //形状
})</code></pre> 
</div> 
<pre><code class="language-Dart">//容器左上角和右下角有弧度
borderRadius: BorderRadius.only(
            topLeft: Radius.circular(20.0),
            topRight: Radius.zero,
            bottomLeft: Radius.zero,
            bottomRight: Radius.circular(20.0)),
      )

//容器左右两边有弧度
borderRadius:BorderRadius.all(Radius.circular(Dimens.rgap_dp25))

//3像素圆角
borderRadius: BorderRadius.circular(3.0), 

//容器底部加根线
decoration: BoxDecoration(
         color:Colors.white,
         border: Border(
           bottom: BorderSide(width:0.5,color:Colors.black12)
         )
       )

//使用decoration实现颜色的渐变(左右渐变)
decoration: BoxDecoration(
          gradient: LinearGradient(
              begin: isOrientationLeftRight
                  ? Alignment.centerLeft
                  : Alignment.topCenter,
              end: isOrientationLeftRight
                  ? Alignment.centerRight
                  : Alignment.bottomCenter,
              colors: [gradientStart, gradientEnd]),
          /*阴影设置
              boxShadow: [
                new BoxShadow(
                  color: Colors.grey[500],
                  blurRadius: 20.0,
                  spreadRadius: 1.0,
                )
              ]*/
        ),</code></pre> 
<p>========================<strong>尺寸限制类容器end=================================</strong></p> 
<pre>========================高斯模糊的效果start<strong>=================================</strong>
1.BackdropFilter使用
///1。BackdropFilter是通过在背景上面盖上一个模糊层从而达到高斯模糊的效果，因此要做模糊的背景图必须在BackdropFilter底下，所以通常使用stack实现效果，
///2。BackdropFilter实现的模糊遮罩层是填充整个父组件的，需要使用ClipRect将其裁切
///3。BackdropFilter它的孩子没有模糊效果</pre> 
<div> 
 <pre><code class="language-Dart"> Stack(
          children: &lt;Widget&gt;[
            _buildImage(),
            Positioned.fill(
              child: ClipRect(
                child: BackdropFilter(
                  filter: ImageFilter.blur(sigmaX: _sigmaX, sigmaY: _sigmaY),
                  child: Container(
                    color: Colors.black.withAlpha(0),
                  ),
                ),
              ),
            )
</code></pre> 
</div> 
<pre>2.ImageFiltered：可以对任意组件进行特效处理，包括但不限于高斯模糊、颜色滤镜、变换等</pre> 
<p>========================高斯模糊的效果<strong>end=================================</strong></p> 
<p><strong>align </strong></p> 
<p><strong>center</strong></p> 
<p><strong>padding</strong>组件处理容器与子元素直接的间距</p> 
<p><strong>Wrap</strong>组件，可以实现流式布局，   direction，主轴的方向，默认水平。        Alignment：主轴的对齐方式       spacing：主轴方向上的间距。       Runspacing：子轴的间距。</p> 
<p>=======================显示隐藏start========================================</p> 
<p><strong>Offstage</strong>控制是否显示组件.   当offstage为true，控件隐藏；类似于Android中View的gone</p> 
<div> 
 <pre><code class="language-java">Offstage({ 
    Key key, 
    this.offstage = true, 
    Widget child 
  })</code></pre> 
</div> 
<p><br><br><strong>Visibility</strong>控制子组件隐藏/可见的组件</p> 
<div> 
 <pre><code>Visibility({
    Key key,
    @required this.child,
    this.replacement = const SizedBox.shrink(),//不可见时显示的组件（当maintainState=false）
    this.visible = true,//子组件是否可见，默认true（可见）
    this.maintainState = false,//不可见时是否维持状态，默认为false
    this.maintainAnimation = false,//不可见时，是否维持子组件中的动画
    this.maintainSize = false,//不可见时是否留有空间
    this.maintainSemantics = false,//不可见时是否维持它的语义
    this.maintainInteractivity = false,//不可见时是否具有交互性
  })</code></pre> 
</div> 
<p>Offstage与Visibility比较:<br> Offstage是控制组件隐藏/可见的组件，当Offstage不可见的时候，如果child有动画等，需要手动停掉，Offstage并不会停掉动画等操作,如果感觉有些单调功能不全，我们可以使用Visibility，<br> Visibility也是控制子组件隐藏/可见的组件。不同是的Visibility有隐藏状态是否留有空间、隐藏状态下是否可调用等功能。</p> 
<p><strong>Opacity</strong>移除控件同时它的位置依然保留，类似于Android中View的invisible</p> 
<p>========================显示隐藏end========================================</p> 
<h4>3.路由</h4> 
<p>普通路由：界面之间的跳转 Navigator.of(context)<br>                   .push(MaterialPageRoute(builder: (BuildContext context) {<!-- --><br>                 return SecondPage("第二页");<br>               }));   <br>         退出: Navigator.pop(context);</p> 
<p><br> 命名路由单独抽离到一个文件<br> final Map routes = { '/':(context,{arguments})=&gt;Tabs(), '/search':(context,{arguments}) =&gt;SearchPage(arguments: arguments), '/form': (context,{arguments}) =&gt;FormPage(arguments: arguments), };<br> var onGenerateRoute=(RouteSettings settings) { // 统一处理 final String name = settings.name; final Function pageContentBuilder = routes[name]; if (pageContentBuilder != null) { final Route route = MaterialPageRoute( builder: (context) =&gt; pageContentBuilder(context, arguments: settings.arguments)); return route; } };<br> 然后在根页面：MaterialApp( // home:Tabs(), initialRoute: '/', onGenerateRoute: onGenerateRoute );</p> 
<p>替换路由<br> Navigator.of(context).pushReplacementNamed('/registerSecond');</p> 
<p>返回到根路由<br> Navigator.of(context).pushAndRemoveUntil( new MaterialPageRoute(builder: (context) =&gt; new Tabs(index:1)), (route) =&gt; route == null );</p> 
<h4>double.infinity 和 double.maxFinite</h4> 
<p><code>double.infinity</code> 和<code>double.maxFinite</code>可以让当前元素的<code>width</code>或者<code>height</code>达到父元素的尺寸。</p> 
<pre><code>static const double nan = 0.0 / 0.0;
static const double infinity = 1.0 / 0.0;
static const double negativeInfinity = -infinity;
static const double minPositive = 5e-324;
static const double maxFinite = 1.7976931348623157e+308;</code></pre> 
<h3>积累</h3> 
<h4 style="background-color:transparent;">其它：</h4> 
<p><code><strong>flutter中的图片路径</strong>：Flutter</code>会打把<code>assets</code>下的文件打包到<code>Android</code>中的<code>assets</code>中，具体为<code>app/assets/flutter_assets/</code></p> 
<p>RestorationMixin   说明：<a href="https://zhuanlan.zhihu.com/p/263789302" rel="nofollow" title="Flutter 1.22 正式发布 - 知乎">Flutter 1.22 正式发布 - 知乎</a></p> 
<p>Android studio 右侧的Flutter Performance打开方法：<br> 在profile模式下不能用，在debug模式下可以<br> Flutter应用如何调试--DevTools介绍(下)参考链接 https://www.jianshu.com/p/0e53a168b367</p> 
<p>Flutter 的生命周期https://blog.csdn.net/sinat_17775997/article/details/94733411</p> 
<p>去掉右边debug图标：在根页面添加.    debugShowCheckedModeBanner: false,</p> 
<p>屏幕宽度MediaQuery.of(context).size.width,</p> 
<p>通过<code>Listener</code>直接识别原始指针事件来解决冲突</p> 
<p>接口调试可以创建假数据（动态）。  Easymock.    https://easy-mock.com/</p> 
<p><strong>mounted</strong> 是 bool 类型，表示当前 State 是否加载到树⾥。常用于判断页面是否释放。</p> 
<p>通过<strong>addPostFrameCallback</strong>可以做一些安全的操作，在有些时候是很有用的，它会在当前Frame绘制完后进行回调，并只会回调一次，如果要再次监听需要再设置<br>  WidgetsBinding.instance.addPostFrameCallback((callback) {<!-- --><br>       _showHint();<br>     });</p> 
<p><strong>解决滑动冲突</strong>：外层嵌套ScrollNotificationInterceptor（没验证过）</p> 
<p><strong>系统的AppBar中的控件宽高自己设置不起作用</strong></p> 
<h4 id="5、系统字体缩放">系统字体缩放</h4> 
<p>现在的手机一般都提供字体缩放，这给应用开发的适配上带来一定工作量，所以大多数时候我们会选择禁止应用跟随系统字体缩放。</p> 
<p>在 Flutter 中字体缩放也是和 <code>MediaQueryData</code> 的 <code>textScaleFactor</code> 有关。所以我们可以在需要的页面，通过最外层嵌套如下代码设置，将字体设置为默认不允许缩放。</p> 
<pre><code class="language-Dart"> MediaQuery(
      data: MediaQueryData.fromWindow(WidgetsBinding.instance.window).copyWith(textScaleFactor: 1),
      child: new Container(),
    );</code></pre> 
<h4 id="6、margin-和-padding">Margin 和 Padding如何设置负数</h4> 
<p>在使用 <code>Container</code> 的时候我们经常会使用到 <em>margin</em> 和 <em>padding</em> 参数，其实在上一篇我们已经说过， <code>Container</code> 其实只是对各种布局的封装，内部的 <em>margin</em> 和 <em>padding</em> 其实是通过 <code>Padding</code> 实现的，而 <code>Padding</code> 不支持负数，所以如果你需要用到负数的情况下，推荐使用 <code>Transform</code> 。</p> 
<pre><code class="language-Dart">  Transform(
      transform: Matrix4.translationValues(10, -10, 0),
      child: new Container(),
    );</code></pre> 
<h4>测量自己的尺寸、测量Parent的尺寸、测量Child的尺寸参考:<a href="https://www.yuque.com/xuyisheng/iwyyof/gf2nc6g2oafkf1zl?singleDoc=" rel="nofollow" title="FlutterComponent最佳实践之Widget尺寸 · 语雀">FlutterComponent最佳实践之Widget尺寸 · 语雀</a></h4> 
<h4><strong>小技巧</strong>：</h4> 
<p><strong>3.10 现在可以通过将  <code>MediaQuery.of</code> 获取参数的方式替换成  <code>MediaQuery.******Of(context);</code> 来减少不必要的 rebuild</strong></p> 
<p><strong>参考：</strong><a href="https://mp.weixin.qq.com/s/QLaN6Drd4SCdVJYTkIGCOg" rel="nofollow" title="Flutter 小技巧之 3.10 全新的 MediaQuery 优化与 InheritedModel">Flutter 小技巧之 3.10 全新的 MediaQuery 优化与 InheritedModel</a></p> 
<h4></h4> 
<h4>flutter事件分发机制</h4> 
<p><a href="https://mp.weixin.qq.com/s/wo7EP-1hGoonKFlKPy0Wkw" rel="nofollow" title="FlutterFlutter原理篇：事件机制传播与响应机制与HitTestBehavior的介绍">FlutterFlutter原理篇：事件机制传播与响应机制与HitTestBehavior的介绍</a></p> 
<h4></h4> 
<h4>注解：</h4> 
<p><a href="https://juejin.cn/post/6844903878392053774" rel="nofollow" title="Flutter 注解处理及代码生成 - 掘金">Flutter 注解处理及代码生成 - 掘金</a></p> 
<p></p> 
<h4><strong>flutter动态化相关</strong></h4> 
<p><a href="https://juejin.cn/post/7236168316238266429" rel="nofollow" title="Deferred Components-实现Flutter运行时动态下发Dart代码 | 京东云技术团队 - 掘金">Deferred Components-实现Flutter运行时动态下发Dart代码 | 京东云技术团队 - 掘金</a></p> 
<p id="articleContentId">58 开源 Flutter 终极动态化解决方案-Fair 框架介绍：</p> 
<p>Github地址：https://github.com/wuba/fair<br> Fair官网：https://fair.58.com/</p> 
<p></p> 
<h4><strong>flutter字体：</strong></h4> 
<ul><li>默认在 iOS 上： 
  <ul><li>中文字体：<code>PingFang SC</code> (繁体还有 <code>PingFang TC</code> 、 <code>PingFang HK</code> )</li><li>英文字体：<code>.SF UI Text</code> / <code>.SF UI Display</code></li></ul></li><li>默认在 Android 上： 
  <ul><li>中文字体：<code>Source Han Sans</code> / <code>Noto</code></li><li>英文字体：<code>Roboto</code></li></ul></li></ul> 
<p>参考：<a href="https://juejin.cn/post/7108463516952035365" rel="nofollow" title="Flutter 小技巧之玩转字体渲染和问题修复 - 掘金">Flutter 小技巧之玩转字体渲染和问题修复 - 掘金</a></p> 
<p></p> 
<h4>三方库依赖相关：</h4> 
<p>===================三方库依赖相关start===================================</p> 
<p><strong>依赖已发布的三方库的几种方式已url_launcher举例：</strong></p> 
<p>1.url_launcher: '5.4.2'   #指定版本号</p> 
<p>如果有两个依赖该库的三方库使用的版本号不一致，会出现版本冲突，可以通过下面方式制定版本号，但不推荐</p> 
<p>dependency_overrides: url_launcher: '5.4.2'</p> 
<p>2.url_launcher:             #不指定版本号</p> 
<p>如果不指定版本号，就表示项目可以使用url_launcher的任意版本，容易出现版本冲突</p> 
<p>3.url_launcher:  '&gt;=5.4.2&lt;6.0.0'     #指定最大和最小版本号的方式</p> 
<p>4.url_launcher:  ^5.4.2     # ^标签表示使用该库与当前接口兼容的最新版本，这里的^5.4.2等效于[5.4.2,6)    <strong>推荐使用</strong></p> 
<p>5.url_launcher:  any    #any会自动调用pub的版本分析器，寻找合适的能够避免冲突的依赖版本并下载,在实际项目开发中，拥有不确定性的版本号会成为未来应用崩溃的一个极大的隐患。这可能将会使您的应用难以调试。所以<strong>不要在你的项目中留下any关键字！</strong>，所以我们需要将正确的依赖版本把any关键字替换掉！</p> 
<p> any也有好处，当出现冲突后使用any，当系统查找到避免冲突的版本号后(在pubspec.lock文件查找)，在把any关键字替换掉</p> 
<p><strong>依赖未开源的三方库</strong></p> 
<p>1.如果要依赖的库还保存在本地的磁盘中，可以直接通过指定库的位置导入库。具体声明方法如下:</p> 
<p>dependencies:<br>    package1:<br>      path: ../package1<br> 这里的path属性就指定了package1相对于这个项目的根目录的路径</p> 
<p>2.如果要依赖的库还放在GitHub或者其他Git仓库上，可以直接通过下面指这种方式导入。这里通过指定package1的地址导入该库。<br>  dependencies:<br>     package1:<br>       git:<br>         url: git://github.com/flutter/package1.git<br> 这里的url就指定了Git仓库的地址。此时，项目中就会依赖这个Git仓库中根目录所对应的库了。</p> 
<p>3.如果要依赖的库在Git仓库中的子目录中，可以使用下面这种声明方式。<br> dependencies:<br>   package1:<br>     git:<br>       url: git://github.com/flutter/packages.git<br>       path: packages/package1</p> 
<p>这里通过path属性指定所要依赖的库相对于Git仓库根目录的路径，在终端执行flutter pub get后就能成功将该库安装到本地了。</p> 
<p>===================三方库依赖相关end===================================</p> 
<h4>去除 Flutter 中点击按钮、底部导航栏的水波纹效果：</h4> 
<p>===================去除 Flutter 中点击按钮、底部导航栏的水波纹效果start=============</p> 
<p id="articleContentId">如何全局去除 Flutter 中点击按钮、底部导航栏的水波纹效果</p> 
<div> 
 <pre><code class="language-Dart">@override
Widget build(BuildContext context) {
  return MaterialApp(
    theme: ThemeData(
      splashColor: Colors.transparent, // 点击时的高亮效果设置为透明
      highlightColor: Colors.transparent, // 长按时的扩散效果设置为透明
    ),
  );
}
</code></pre> 
</div> 
<p><strong>局部设置</strong>需要要求组件自带 splashColor 属性和 highlightColor 属性，比如 InkWell 、RaisedButton 等组件</p> 
<div> 
 <pre><code class="language-Dart">InkWell(
	onTap: () {},
	child: Text('InkWell 组件', style: TextStyle(fontSize: 25)),
    highlightColor: Colors.transparent, // 透明色
    splashColor: Colors.transparent, // 透明色
),
</code></pre> 
</div> 
<p>注意：像 RaisedButton 类型的组件比较特殊，即使你设置了 splashColor 属性和 highlightColor 属性，点击时看着好像还是有水波纹效果，那是因为点击 RaisedButton 时还有阴影效果的属性在控制着</p> 
<div> 
 <pre><code class="language-Dart">RaisedButton(
	onPressed: () {},
    child: Text('按钮'),
    splashColor: Colors.transparent,
    highlightColor: Colors.transparent,
    highlightElevation: 0, // 控制按钮下方阴影的大小，默认值为 8
    elevation: 0, // 凸起按钮下方阴影的大小，默认值为 2
),
</code></pre> 
</div> 
<p id="articleContentId">去掉 TabBar 点击时的阴影以及波纹效果</p> 
<div> 
 <pre><code class="language-Dart">Theme(
  data: ThemeData(
    splashColor: Colors.transparent, // 点击时的水波纹颜色设置为透明
    highlightColor: Colors.transparent, // 点击时的背景高亮颜色设置为透明
  ),
  child: TabBar(
  	...
  ),
)
</code></pre> 
</div> 
<p></p> 
<p>===================去除 Flutter 中点击按钮、底部导航栏的水波纹效果end=============</p> 
<h4><strong>json数据解析相关：</strong></h4> 
<p>在线json转dart实体类：<a href="https://www.bejson.com/jsontool/jsonzhuandart/" rel="nofollow" title="JSON转dart-BeJSON.com">JSON转dart-BeJSON.com</a></p> 
<p><strong>本地json数据解析：</strong></p> 
<div> 
 <pre><code>///本地json数据
{
 "categoryList": [
        {
            "id": 1,
            "categoryName": "翡翠",
 "childList": [
        {
            "id": 11,
            "categoryName": "翡翠"
        }
    ]
        }
         
    ]
}</code></pre> 
</div> 
<p>实体类：</p> 
<div> 
 <pre><code class="language-Dart">class SaleCategoryBean {
  List&lt;CategoryList&gt;? categoryList;

  SaleCategoryBean({this.categoryList});

  SaleCategoryBean.fromJson(Map&lt;String, dynamic&gt; json) {
    if (json['categoryList'] != null) {
      categoryList = [];
      json['categoryList'].forEach((v) {
        categoryList!.add(new CategoryList.fromJson(v));
      });
    }
  }

  Map&lt;String, dynamic&gt; toJson() {
    final Map&lt;String, dynamic&gt; data = new Map&lt;String, dynamic&gt;();
    if (this.categoryList != null) {
      data['categoryList'] = this.categoryList!.map((v) =&gt; v.toJson()).toList();
    }
    return data;
  }
}

class CategoryList {
  int? id;
  String? categoryName;
  List&lt;ChildList&gt;? childList;

  CategoryList({this.id, this.categoryName, this.childList});

  CategoryList.fromJson(Map&lt;String, dynamic&gt; json) {
    id = json['id'];
    categoryName = json['categoryName'];
    if (json['childList'] != null) {
      childList = [];
      json['childList'].forEach((v) {
        childList!.add(new ChildList.fromJson(v));
      });
    }
  }

  Map&lt;String, dynamic&gt; toJson() {
    final Map&lt;String, dynamic&gt; data = new Map&lt;String, dynamic&gt;();
    data['id'] = this.id;
    data['categoryName'] = this.categoryName;
    if (this.childList != null) {
      data['childList'] = this.childList!.map((v) =&gt; v.toJson()).toList();
    }
    return data;
  }
}

class ChildList {
  int? id;
  String? categoryName;

  ChildList({this.id, this.categoryName});

  ChildList.fromJson(Map&lt;String, dynamic&gt; json) {
    id = json['id'];
    categoryName = json['categoryName'];
  }

  Map&lt;String, dynamic&gt; toJson() {
    final Map&lt;String, dynamic&gt; data = new Map&lt;String, dynamic&gt;();
    data['id'] = this.id;
    data['categoryName'] = this.categoryName;
    return data;
  }
}</code></pre> 
</div> 
<p>解析：</p> 
<div> 
 <pre><code>import 'package:flutter/services.dart';
 
rootBundle.loadString('assets/json/category.json').then((String value) {
        SaleCategoryBean _bean = SaleCategoryBean.fromJson(json.decode(value));
       List&lt;CategoryList&gt; _list = _bean.categoryList ?? [];
        setState(() {});
      });</code></pre> 
</div> 
<p>/类型转换start</p> 
<p><strong>1.flutter中可以使用split() 把字符串转换成list</strong></p> 
<div> 
 <pre><code>var str='香蕉-苹果-西瓜';

var list=str.split('-');

print(list);    //['香蕉','苹果','西瓜']

print(list is List);   //true</code></pre> 
</div> 
<h4>2.Flutter中List转换成字符串</h4> 
<div> 
 <pre><code class="language-Dart">List myList = ['香蕉', '苹果', '西瓜'];

    var str = myList.join('-'); //list转换成字符串

    print(str); //香蕉-苹果-西瓜

    print(str is String); //true</code></pre> 
</div> 
<h4>3.json和map的转换。 导包。 import 'dart:convert';</h4> 
<p>Flutter 中一般 <strong>json</strong> 数据从 <code>String</code> 转为 <code>Object</code> 的过程中都需要先经过 <code>Map</code> 类型。<br> map转json。    Map userInfo = {"username":"zhangsan","age":20};     Var a = json.encode(userInfo);<br> json转map.   String userInfo = '{"username":"zhangsan","age":20}';  Map u = json.decode(userInfo);</p> 
<p><strong>4.json转数组</strong></p> 
<p>String info = "[\"嗯嗯嗯\",\"让我\",\"我无法答复\",\"问问\",\"我让人防\"]";<br> List&lt;dynamic&gt; list =(json.decode(info) as List&lt;dynamic&gt;) .cast&lt;String&gt;();</p> 
<p></p> 
<p>/类型转换end///</p> 
<h4>三方库</h4> 
<p>flutter_easyloading   常见的加载对话框</p> 
<p>convex_bottom_bar  底部导航栏</p> 
<p>flutter_staggered_animations 轻松地将交错动画添加到您的 ListView、GridView、Column 和 Row 子项</p> 
<p>wechat_assets_picker ：基于 <strong>微信 UI</strong> 的 Flutter 图片选择器（同时支持视频和音频）。 该插件基于 <a href="https://pub.flutter-io.cn/packages/photo_manager" rel="nofollow" title="photo_manager">photo_manager</a> 实现资源相关功能， <a href="https://pub.flutter-io.cn/packages/extended_image" rel="nofollow" title="extended_image">extended_image</a> 用于查看图片， <a href="https://pub.flutter-io.cn/packages/provider" rel="nofollow" title="provider">provider</a> 用于协助管理选择器的状态</p> 
<p>flutter_pickers：<a href="https://github.com/longer96/flutter_pickers" title="GitHub - longer96/flutter_pickers: flutter 选择器库，包括日期及时间选择器（可设置范围）、单项选择器（可用于性别、民族、学历、星座、年龄、身高、体重、温度等）、城市地址选择器（分省级、地级及县级）、多项选择器等…… 欢迎Fork &amp; pr贡献您的代码，大家共同学习">GitHub - longer96/flutter_pickers: flutter 选择器库，包括日期及时间选择器（可设置范围）、单项选择器（可用于性别、民族、学历、星座、年龄、身高、体重、温度等）、城市地址选择器（分省级、地级及县级）、多项选择器等…… 欢迎Fork &amp; pr贡献您的代码，大家共同学习</a></p> 
<p>connectivity：用于发现Android和iOS上的网络（WiFi和移动/蜂窝）连接状态。</p> 
<p>Flutter常用工具类库依赖于Dart常用工具类库common_utils,以及对其他第三方库封装，致力于为大家分享简单易用工具类。如果你有好的工具类欢迎PR.目前包含SharedPreferences Util, Screen Util, Directory Util, Widget Util, Image Util。     flustars<br> common_utils：Dart常用工具类库。包含日期，正则，倒计时，时间轴等工具类. <strong>flutter_screenutil：屏幕适配</strong></p> 
<h4><img alt="" height="728" src="https://images2.imgbox.com/4d/dd/kffB8USG_o.png" width="1080">​</h4> 
<h4><strong>实现局部刷新</strong>：</h4> 
<p>1.通过抽取widget为StateFulWidget包裹，使用setState刷新制定widget2.使用StreamBuilder实现局部刷新参考：<a href="https://guoshuyu.cn/home/wx/Flutter-11.html" rel="nofollow" title="十一、全面深入理解Stream · GitBook">十一、全面深入理解Stream · GitBook</a><a href="https://juejin.cn/post/6868104488109604871" rel="nofollow" title="告别setState()！ 优雅的UI与Model绑定 Flutter DataBus使用~ - 掘金">告别setState()！ 优雅的UI与Model绑定 Flutter DataBus使用~ - 掘金</a>3.Provide的解决方案设定顶级Widget，然后用consumer包裹子控件，调用更新，provider可以实现跨组件访问，（跨组件访问也可以通过context向上查询，这种方式没试过）4.ValueListenableBuilder组件：可以监听一个值，当其变化时通过builder回调能重建界面，避免使用<span style="color:#333333;"><strong>setState刷新 5.</strong></span>GlobalKey实现控件的局部刷新：将需要单独刷新的widget从复杂的布局中抽离出去，然后通过传GlobalKey引用，这样就可以通过GlobalKey实现跨组件的刷新了。</p> 
<p><strong>setState(() {});</strong>1.使用：把需要刷新的字段代码写到大括号里面(注：里面和外面都能刷新，写到里面的目的是为了判断字段代码多的情况下，辨别哪些字段需要刷新)</p> 
<p>2.内部原理：执行了方法： _element!.markNeedsBuild();<br> 可以通过下面方式实现刷新：（官方不推荐使用，查看BuildContext源码注释）<br> (context as Element).markNeedsBuild();</p> 
<p>3.连续setstate1万次，每次执行时都会触发重构吗：不是，通过看源码，标脏那里有个判断语句，为true时才标脏</p> 
<p>4.<code>setState</code> 其实是调用了 <code>markNeedsBuild</code> ，<code>markNeedsBuild</code> 内部标记 <code>element</code> 为 <code>diry</code> ，然后在下一帧 <code>WidgetsBinding.drawFrame</code> 才会被绘制，这可以看出 <code>setState</code> 并不是立即生效的哦。</p> 
<h4><strong>BuildContext：</strong></h4> 
<p><strong>只是抽象类接口，而  <code>Element</code> 实现了它</strong>,向上查找</p> 
<p>使用：获取页面宽高大小： print(((context as Element).findRenderObject() as RenderBox).size);</p> 
<div> 
 <pre><code class="language-Dart">  abstract class BuildContext {
  ///查找父节点中的T类型的State
  T? findAncestorStateOfType&lt;T extends State&gt;();
  ///查找父节点中的T类型的 InheritedWidget 例如 MediaQuery 等
  T? dependOnInheritedWidgetOfExactType&lt;T extends InheritedWidget&gt;({ Object? aspect });
  ///遍历子元素的element对象
  void visitChildElements(ElementVisitor visitor);
   
 
 RenderObject? findRenderObject();

  /// be called apply to this method as well.
  InheritedWidget dependOnInheritedElement(InheritedElement ancestor, { Object aspect });

  InheritedElement? getElementForInheritedWidgetOfExactType&lt;T extends InheritedWidget&gt;();
 
  /// a subtree.
  T? findRootAncestorStateOfType&lt;T extends State&gt;();

  T? findAncestorRenderObjectOfType&lt;T extends RenderObject&gt;();
  
  void visitAncestorElements(bool Function(Element element) visitor);
 
  void dispatchNotification(Notification notification);
 
  DiagnosticsNode describeElement(String name, {DiagnosticsTreeStyle style = DiagnosticsTreeStyle.errorProperty});
 
  DiagnosticsNode describeWidget(String name, {DiagnosticsTreeStyle style = DiagnosticsTreeStyle.errorProperty});
 
  List&lt;DiagnosticsNode&gt; describeMissingAncestor({ required Type expectedAncestorType });
  
  DiagnosticsNode describeOwnershipChain(String name);
}
</code></pre> 
</div> 
<p>flutter3.0新规则：await 后面不要用context，正确使用方法如：</p> 
<div> 
 <pre><code class="language-Dart">正确使用：

   final navigator = Navigator.of(context);
    await loadData();
    navigator.pop();


错误用法：

    await loadData();
    Navigator.of(context).pop();</code></pre> 
</div> 
<h4>flutter回调的几种写法：</h4> 
<p>=======flutter回调的几种写法start================</p> 
<p><span style="color:#fe2c24;">方法的使用 </span>    加括号：调用方法。 不加括号：把方法赋值给这个属性<br> 比如：  void _ab(){}   调用方法: child:_ab(),       方法赋值： child：_ab或child:()=&gt;_ab(),</p> 
<p>写button的回调方法时只能以"方法赋值"写，不要以"调用方法"写，因为以"调用方法"写第一次加载布局时会调用一次方法</p> 
<p><strong>函数回调的写法</strong><strong>1:Function</strong></p> 
<div> 
 <pre><code class="language-Dart">///定义
class CallbackExampleWidget extends StatelessWidget {
  final Function() onSelected;
  const CallbackExampleWidget({Key? key, required this.onSelected}) : super(key: key);

  @override
  Widget build(BuildContext context) {
    return Container(
      
    );
  }
}


///使用
 CallbackExampleWidget(onSelected: (){},);



///多个参数传值写法
final Function(int, String) onSelected;
///使用
CallbackExampleWidget(onSelected: (id, name) {},);</code></pre> 
</div> 
<p><strong>函数回调的写法</strong><strong>2:Function</strong></p> 
<p>通过方式1可以发现，函数回调无法限定参数和返回值，这样在编码中容易出现很多潜在的错误，因此可以使用<code>typedof</code>进行限制，代码如下:</p> 
<p>ps:<code>typedef</code>的含义是给某一种特定的函数类型起了一个名字，可以认为是一个类型的别名。这样在使用过程中就会进行类型检查</p> 
<div> 
 <pre><code class="language-Dart">

// typedef FunctionTest = Function();//定义成这样也是可以的
typedef Function2&lt;int, String&gt; = void Function(
    int result, String str); //限定参数和返回值

class CallbackExampleWidget extends StatelessWidget {
  final Function2&lt;int, String&gt; onSelected;
  const CallbackExampleWidget({Key? key, required this.onSelected})
      : super(key: key);

  @override
  Widget build(BuildContext context) {
    return Container();
  }
}


///使用
 CallbackExampleWidget(onSelected: (int result, String str) {});</code></pre> 
</div> 
<p><strong>函数回调的写法3</strong><strong>:系统默认</strong></p> 
<p><strong>VoidCallback</strong>无参回调</p> 
<div> 
 <pre><code class="language-Dart">class CallbackExampleWidget extends StatelessWidget {
  final VoidCallback onSelected;
  const CallbackExampleWidget({Key? key, required this.onSelected})
      : super(key: key);

  @override
  Widget build(BuildContext context) {
    return Container();
  }
}

///使用
 CallbackExampleWidget(onSelected: () {});</code></pre> 
</div> 
<p><strong>ValueChanged</strong>有参回调. 注：只能有一个参数</p> 
<div> 
 <pre><code class="language-Dart">class CallbackExampleWidget extends StatelessWidget {
  final ValueChanged&lt;int&gt; onSelected;
  const CallbackExampleWidget({Key? key, required this.onSelected})
      : super(key: key);

  @override
  Widget build(BuildContext context) {
    return Container();
  }
}


///使用
CallbackExampleWidget(onSelected: (int result) {});</code></pre> 
</div> 
<p></p> 
<p>总结：推荐使用方式3，当参数较多时推荐用方式2</p> 
<p>=======flutter回调的几种写法end================</p> 
<h4>键盘相关：</h4> 
<p>=======================键盘相关start=======================================<br> 解决弹出键盘时多条线的问题（或超过屏幕）：在最外层包裹一层SingleChildScrollView()，里面有list view时会有滑动冲突</p> 
<p> /// <strong>关闭输入法，避免弹出</strong>FocusManager.instance.primaryFocus?.unfocus();</p> 
<p><strong>防止空指针异常 ： </strong>List travelItems;   travelItems?.length ?? 0</p> 
<p><br>  // 防止键盘弹出，提交按钮升起。。。 resizeToAvoidBottomInset: false,</p> 
<p>隐藏软件盘<br> // 隐藏键盘<br> // 建议传入对应的 context，才能获取当前页面的键盘是否被拉起<br> hiddenKeyBoard({BuildContext context}) {<!-- --><br>   Future.delayed(Duration.zero).then((value) {<!-- --><br>     FocusScopeNode _node = FocusScope.of(context );<br>     print('_node.hasFocus: ${_node.hasFocus}');<br>     // 根据键盘是否被拉起，来决定是否收起键盘<br>     if (_node.hasFocus) _node.requestFocus(FocusNode());<br>   });<br> }</p> 
<p>获取键盘高度要放在build里面获取：</p> 
<pre><code class="language-Dart">  //键盘高度
  double? keyHeight;
  
  @override
  Widget build(BuildContext context) {
      //获取键盘高度
    if(MediaQuery.of(context).viewInsets.bottom!=0.0){
      //键盘高度是会变的，键盘隐藏的时候会返回0，所以为0是不赋值
      keyHeight = MediaQuery.of(context).viewInsets.bottom;
    }
  }
</code></pre> 
<p>=======================键盘相关end=======================================</p> 
<h4><strong>保持页面状态：</strong></h4> 
<p>=============================<strong>保持页面状态start</strong>==============================<br> 保持页面状态，如何让页面保持原来的状态，而不是每次都要重新加载刷新数据呢两种方式：</p> 
<p>第一种方式：采用IndexedStack<br> IndexdStack和Stack一样，都是层布局控件，可以在一个控件上面放置另一个控件，但唯一不同的是，IndexdStack在同一时刻只能显示子控件中的一个控件，通过index属性来设置显示的控件<br> 注意：</p> 
<ul><li> <p>IndexedStack会同时加载所有的子组件，所以如果子组件比较多或者占用内存较大，这种方式可能会对性能产生影响。</p> </li><li> <p>当需要动态切换子组件时，可以通过修改index来实现，比如将index设置为一个变量，然后在需要切换时，修改这个变量即可。</p> </li></ul> 
<p>代码如下：<br> body:  IndexedStack(<br>        index: currentIndex,<br>        children: tabBodies<br>      ),</p> 
<p>第二种方式：AutomaticKeepAliveClientMixin<br> 如果所有的页面都需要保持页面状态，那么就使用indexdStack；如果有些页面需要保持页面状态，有些页面需要进来就刷新，那么我们就需要使用AutomaticKeepAliveMixin这个类来单独控制某个页面的状态<br> 代码如下：<br> 1.     with AutomaticKeepAliveClientMixin</p> 
<p>2.@override<br> bool get wantKeepAlive =&gt;true;<br> ===========================<strong>保持页面状态end</strong>============================== </p> 
<h4>flutter改成如何更改包名和应用名：</h4> 
<p>===================flutter改成如何更改包名和应用名start==========================</p> 
<p><strong>android下修改应用名称</strong>：修改AndroidManifest.xml文件中的label属性。</p> 
<div> 
 <pre><code class="language-java">&lt;application
    android:name="io.flutter.app.FlutterApplication"
    android:label="NewName" ...</code></pre> 
</div> 
<p><strong>android下修改包名</strong>：修改app下的build.gradle</p> 
<div> 
 <pre><code class="language-java">defaultConfig {
    applicationId "your.package.name"
    minSdkVersion 16
    targetSdkVersion 27
    versionCode 1
    versionName "1.0"
    testInstrumentationRunner "android.support.test.runner.AndroidJUnitRunner"
}</code></pre> 
</div> 
<p></p> 
<p>ios下修改包名和应用名称</p> 
<p><img alt="" height="158" src="https://images2.imgbox.com/06/3a/DRaedw9z_o.jpg" width="542"></p> 
<p> <img alt="" height="126" src="https://images2.imgbox.com/55/c4/4gaYX3aE_o.jpg" width="539"></p> 
<p></p> 
<div></div> 
<p>===================flutter改成如何更改包名和应用名end==========================</p> 
<h4><strong>状态栏相关的</strong></h4> 
<p>1.状态栏字体颜色修改<br> 方法一：AppBar里面的Brightness 或者 <code>ThemeData</code> 去设置状态栏颜色<br> 方法二：AnnotatedRegion</p> 
<p>不想用 <code>AppBar</code> ，那么你可以嵌套 <code>AnnotatedRegion&lt;SystemUiOverlayStyle&gt;</code> 去设置状态栏样式，通过 <code>SystemUiOverlayStyle</code> 就可以快速设置状态栏和底部导航栏的样式。</p> 
<p>同时你还可以通过 <code>SystemChrome.setSystemUIOverlayStyle</code> 去设置，前提是你没有使用 <code>AppBar</code> 。<strong>需要注意的是，所有状态栏设置是全局的，</strong> 如果你在 A 页面设置后，B 页面没有手动设置或者使用 AppBar ，那么这个设置将直接呈现在 B 页面。</p> 
<pre><code class="language-Dart">AnnotatedRegion&lt;SystemUiOverlayStyle&gt;(
          value: SystemUiOverlayStyle.dark
              .copyWith(systemNavigationBarColor: Colors.white),
child:child)</code></pre> 
<p>方式三:设置Scaffold的extendBodyBehindAppBar属性</p> 
<pre><code class="language-Dart">return Scaffold(
  extendBodyBehindAppBar: true,
  appBar: AppBar(
    title: Text(widget.title),
    backgroundColor: Colors.transparent,
    elevation: 0,
  ),</code></pre> 
<p>2.可以用这种方式设置渐变的AppBar<br>             flexibleSpace: GradualChangeView(<br>                 rotation: Rotation.LR,<br>                 colors: [Colors.cyan, Colors.blue, Colors.blueAccent]),</p> 
<p>3.沉浸式状态栏SafeArea</p> 
<p>4.布局去掉沉浸式效果和布局设置占满全屏却无效的问题<br> 使用Scaffold的body的布局默认是沉浸式的,将状态栏一起包含了,可以通过在body后添加一层SafeArea即可.</p> 
<p>5.获取状态栏高度和安全布局</p> 
<p>如果你看过 <code>MaterialApp</code> 的源码，你应该会看到它的内部是一个 <code>WidgetsApp</code> ，而 <code>WidgetsApp</code> 内有一个 <code>MediaQuery</code>，熟悉它的朋友知道我们可以通过 <code>MediaQuery.of(context).size</code> 去获取屏幕大小。</p> 
<p>其实 <code>MediaQuery</code> 是一个 <code>InheritedWidget</code> ，它有一个叫 <code>MediaQueryData</code> 的参数，这个参数是通过如下图设置的，再通过源码我们知道，一般情况下 <code>MediaQueryData</code> 的 <code>padding</code> 的 <code>top</code> 就是状态栏的高度。</p> 
<p>所以我们可以通过 <code>MediaQueryData.fromWindow(WidgetsBinding.instance.window).padding.top</code> 获取到状态栏高度，当然有时候可能需要考虑 <code>viewInsets</code> 参数。</p> 
<p class="img-center"><img alt="" height="255" src="https://images2.imgbox.com/5a/ee/ywaFKPne_o.png" width="1200"></p> 
<p>至于 <code>AppBar</code> 的高度，默认是 <code>Size.fromHeight(kToolbarHeight + (bottom?.preferredSize?.height ?? 0.0)),</code>，<em>kToolbarHeight</em> 是一个固定数据，当然你可以通过实现 <code>PreferredSizeWidget</code> 去自定义 <code>AppBar</code>。</p> 
<p>同时你可能会发现，有时候在布局时发现布局位置不正常，居然是从状态栏开始计算，这时候你需要用 <code>SafeArea</code> 嵌套下，至于为什么，看源码你就会发现 <code>MediaQueryData</code> 的存在。</p> 
<p>参考：<a href="https://www.yuque.com/xuyisheng/iwyyof/mx6k7a" rel="nofollow" title="FlutterComponent最佳实践之沉浸式 · 语雀">FlutterComponent最佳实践之沉浸式 · 语雀</a></p> 
<h4>Isolate（参考：<a href="https://www.jianshu.com/p/3ed9df846534" rel="nofollow" title="Flutter关于Isolate的初步学习应用 - 简书">Flutter关于Isolate的初步学习应用 - 简书</a>）</h4> 
<p>在Dart中实现并发可以用Isolate，它是类似于线程(thread)但不共享内存的独立运行的worker，是一个独立的Dart程序执行环境。其实默认环境就是一个main isolate。</p> 
<p> <span style="color:#494949;">isolate线程管理使用</span>:在大批量调用渲染和网络请求等“高消耗”的操作下，Flutter Ui视图会造成卡顿现象，这时候要开启一个线程去跑这些操作。在使用isolate过程中注意使用完后关闭isolate并释放掉内存，否则会因内存占用大而导致应用奔溃。</p> 
<p>基本使用：</p> 
<div> 
 <pre><code>library flutter_flutterisolate2;
import 'dart:async';
import 'dart:isolate';

main() async{
  //1.创建一个和isoLate环境交流的Port
 var receivePort = new ReceivePort();
 //2.创建一个隔离isolate并且提供用于回执的sendPort,receivePort.sendPort是一个给当前receive发消息的sendPort
 await Isolate.spawn(speak, receivePort.sendPort);
 //5.现在需要一个sendPort给isolate发送消息
  SendPort sendPort = await receivePort.first;
  //6. 利用sendPort给isoLate发送一个消息
  var resultFromIsoLate = await sendMessage2IsoLate(sendPort, 'apple');
  //8.打印来自于isolate的执行结果
  print(resultFromIsoLate);
  resultFromIsoLate = await sendMessage2IsoLate(sendPort, 'banana');
  print(resultFromIsoLate);
}

//3.创建用于在新isolate执行的函数speak
speak(SendPort sendPort) async{
  //4.现在提供给主isolate一个用于给子isolate发消息的sendPort
  var receivePort = new ReceivePort();
  sendPort.send(receivePort.sendPort);

  //单次读取
  // var msgFromMainIsoLate = await receivePort.first;
  // var msg = msgFromMainIsoLate[0];
  // SendPort replyTo = msgFromMainIsoLate[1];
  // replyTo.send("i like eat "+ msg);

  //7. 读取receivePort并且回传消息, receivePort看起来是一个可迭代器
  await for (var r in receivePort){
    var msg = r[0];
    SendPort replyTo = r[1];
    replyTo.send("i like eat "+ msg);
  }
}
//如果需要关闭，使用receivePort.close

//发送一条消息给isolate
Future sendMessage2IsoLate(SendPort sendPort, String msg)  {
  ReceivePort receivePort = ReceivePort();
  sendPort.send([msg, receivePort.sendPort]);
  return  receivePort.first;
}</code></pre> 
</div> 
<h4>flutter常用命令</h4> 
<p>which flutter 查看flutter安装目录</p> 
<p>flutter upgrade 更新flutter到最新的兼容版本</p> 
<p>flutter upgrade v2.2.3 升级到指定版本</p> 
<p>flutter downgrade v2.2.3 回退到指定版本</p> 
<p>flutter pub upgrade 将pubspec.yaml文件里列出的所有依赖更新到最新的兼容版本</p> 
<p>flutter pub outdated 查询展示依赖包可更新的版本信息（判断哪些过时了的package依赖以及获取更新建议 ）</p> 
<p>flutter pub deps ：查看使用的第三方插件的依赖关系</p> 
<p>flutter run 运行项目<br> flutter clean 清空</p> 
<p>flutter pub cache clean 清空本地缓存(即清空.pub-cache文件)<br> flutter --version 查看flutter版本信息</p> 
<p>查看更详细的错误  flutter build apk  --release -vv </p> 
<p>android端打apk包  flutter build apk</p> 
<p>android端打aab包  flutter build appbundle</p> 
<p>新创建flutter项目如果想指定编程语言，比如iOS编程语言为Objective-C，Android的编程语言为Java<br> flutter create -i objc -a java 项目名</p> 
<p>创建指定平台项目(注意最后面有个点)  flutter create --platforms=windows,macos,linux .</p> 
<p></p> 
<p>创建flutter plugin项目flutter create --org com.example --template=plugin pluginname</p> 
<ul><li>--org后面为域名</li><li>--template后面设置成plugin表示为插件类型</li><li>最后为插件名</li><li>参考：<a href="https://blog.csdn.net/mqdxiaoxiao/article/details/102500159" title="一步步实现一个Flutter plugin插件_flutter 创建plugin_野猿新一的博客-CSDN博客">一步步实现一个Flutter plugin插件_flutter 创建plugin_野猿新一的博客-CSDN博客</a></li></ul> 
<p></p> 
<p>查看更详细信息 flutter doctor -v</p> 
<p>q退出</p> 
<p>r或R重新加载</p> 
<p>clean项目:1.在android目录下用命令行   gradlew  clean   2.在最外层目录下用命令行    flutter clean</p> 
<p id="applying-project-wide-fixes">dart fix 对整个工程应用修复此工具有两个可用选项：</p> 
<ul><li> <p>若要查看可用更改的完整列表，请执行以下命令:</p> <pre><code>dart fix --dry-run
</code></pre> </li><li> <p>若要批量应用所有更改，请执行以下命令:</p> <pre><code>dart fix --apply</code></pre> </li></ul> 
<p><code>flutter analyze --suggestions</code> 以验证是否由于 Java SDK 和 Gradle 版本之间的不兼容，要了解修复此错误的不同方法，请查看我们的迁移指南：https://docs.flutter.dev/go/android-java-gradle-error</p> 
<p><code>flutter build apk</code> 命令支持以下参数：</p> 
<ul><li>--target=&lt;path&gt;：指定应用程序的入口点。默认情况下，Flutter 会查找 lib/main.dart 文件作为应用程序的入口点。</li><li>--obfuscate --split-debug-info=/&lt;project-name&gt;/&lt;directory&gt;： 开启Dart混淆，并将符号表导出到指定目录</li></ul> 
<p>可以在命令行中使用 <code>flutter build apk --help</code> 命令来获取完整的参数列表和说明<br>  </p> 
<p>参考：<a href="https://www.cnblogs.com/lulushen/p/14150544.html" rel="nofollow" title="Flutter ——  Pub命令 - Belinda_sl - 博客园">Flutter —— Pub命令 - Belinda_sl - 博客园</a></p> 
<h3><a href="https://blog.csdn.net/wu996489865/article/details/130680390" title="日常笔记-Flutter build命令参数_吴唐人的博客-CSDN博客">日常笔记-Flutter build命令参数_吴唐人的博客-CSDN博客</a></h3> 
<h3>dart基础</h3> 
<p>字符串的定义方式三个双引号声明：大段落的字符串可以换行</p> 
<h4>1、常量和变量</h4> 
<p><strong>变量</strong>：可以用Object、var与dynamic声明的变量赋任何类型的值<br> Object声明的变量可以是任意类型<br> var：声明的变量在赋值的那一刻，决定了它是什么类型，是编译期的“语法糖”。<br> dynamic：被编译后，实际是一个 <code>object</code> 类型，在编译期间不进行任何的类型检查，而是在运行期进行类型检查，是运行期的“语法糖”。<br><strong>常量</strong>：final。const.   <br> final是运行时常量，<br> const是编译器常量，它的值在编译期就可以确定，编译时常量能够让代码运行的更高效。<br> 注：类的常量可以为 `final` 但是不能是 `const` 。如果 const 常量在类中，需要定义为`static const`静态常量<br> 例子//正确，已经确定的值<br> const a = 1;<br> const b = a + 1;<br> //错误,final不能在编译时确定值，因此const也不能确定值<br> final a = 1;<br> const c = a + 1;</p> 
<h4><strong><code>2、Dart</code> 中 <code>if</code> 等语句只支持 <code>bool</code> 类型，<code>switch</code> 支持 String 类型。</strong></h4> 
<h4><code>3、Dart</code> 中 number 类型分为 <strong>int 和 double ，没有 float 类型。</strong></h4> 
<p><strong>数据.clamp(num lowerLimit, num upperLimit)</strong>可以限制数据的取值区间</p> 
<div> 
 <pre><code class="language-Dart"> /// var result = 10.5.clamp(5, 10.0); // 10.0
  /// result = 0.75.clamp(5, 10.0); // 5
  /// result = (-10).clamp(-5, 5.0); // -5
  /// result = (-0.0).clamp(-5, 5.0); // -0.0
  num clamp(num lowerLimit, num upperLimit);</code></pre> 
</div> 
<h5>删除 Dart 中的小数点</h5> 
<pre><code class="language-Dart">方式一：
当您将 466.62 乘以 100 时，您的最终结果也将保持为两倍。这就是您看到 46662.0.0 的原因。所以你需要将它转换为 Int 值

double vDouble = 466.62 *100
String vString = vDouble.toInt().toString();

方式二：
String str = '466.62';

//split string
var arr = str.split('.');

print(arr[0]); //will print 466
print(are[1]); //will print 62

方式三：
参考链接：https://api.dart.dev/stable/2.8.4/dart-core/num/toStringAsFixed.html
1.toStringAsFixed(3);  // 1.000
(4321.12345678).toStringAsFixed(3);  // 4321.123
(4321.12345678).toStringAsFixed(5);  // 4321.12346
123456789012345.toStringAsFixed(3);  // 123456789012345.000
10000000000000000.toStringAsFixed(4); // 10000000000000000.0000
5.25.toStringAsFixed(0); // 5</code></pre> 
<h4><strong>4、运算符</strong></h4> 
<div> 
 <pre><code class="language-java"> print('=====取余操作${5 % 2}=====取整操作${5 ~/ 2}');
    //打印结果：=====取余操作1=====取整操作2</code></pre> 
</div> 
<p>#################<strong>(...)和(...?)使用start</strong>###################<br> Dart 2.3引入了散布运算符(...)和可识别null的散布运算符(...?)，它们提供了一种插入多个简明格式的简洁方法元素添加到集合中.<br> 例如，您可以使用传播运算符(...)将列表的所有元素插入另一个列表:</p> 
<p> var list = [1, 2, 3];<br> var list2 = [0, ...list];<br> assert(list2.length == 4);<br>  <br> 如果扩展运算符右边的表达式可能为null，则可以使用可识别null的扩展运算符(...?)来避免出现异常:</p> 
<p>var list;<br> var list2 = [0, ...?list];<br> assert(list2.length == 1);<br> #################<strong>(...)和(...?)使用end</strong>###################</p> 
<p><strong>### 类型判定操作符</strong><br> | `as`   | 类型转换                       |<br> | `is`   | 如果对象是指定的类型返回 True  |<br> | `is!`  | 如果对象是指定的类型返回 False |</p> 
<p></p> 
<p><strong>###赋值操作符</strong><br> `=`、`+=`、`\=`、`*=`这些不必多说，还有一个 `??=` 操作符用来指定 值为 null 的变量的值<br> 例子：</p> 
<pre><code>AA ?? "999"  ///表示如果 AA 为空，返回999</code><code>AA ??= "999" ///表示如果 AA 为空，给 AA 设置成 999</code><code>AA ~/999 ///AA 对于 999 整除</code></pre> 
<p><strong>### 条件表达式</strong><br> Dart 有两个特殊的操作符可以用来替代 [if-else](http://dart.goodev.org/guides/language/language-tour#if-and-else) 语句：</p> 
<p>- `condition ? expr1 : expr2`</p> 
<p>  如果 *condition* 是 true，执行 *expr1* (并返回执行的结果)； 否则执行 *expr2* 并返回其结果。</p> 
<p>- `expr1 ?? expr2`</p> 
<p>  如果 *expr1* 不为null，返回其值； 否则执行 *expr2* 并返回其结果。</p> 
<p><br> ?.和??的组合使用 String content = response.data?.toString() ?? '';</p> 
<p><br><strong>###级联操作符</strong>：级联操作符 (`..`) 可以在同一个对象上 连续调用多个函数以及访问成员变量。</p> 
<p><strong>###安全操作符</strong>：Dart提供了 `?.`操作符。左边的操作对象 如果 为 null 则返回 null</p> 
<h4>5、作用域：</h4> 
<p><strong><code>Dart</code> 没有关键词 <code>public</code> 、<code>private</code> 等修饰符，<code>_</code> 下横向直接代表 <code>private</code> ，但是有 <code>@protected</code> 注解 。</strong></p> 
<h4><strong>6、getter setter 重写</strong></h4> 
<p><code>Dart</code> 中所有的基础类型、类等都继承 <code>Object</code> ，默认值是 <code>NULL</code>， 自带 <code>getter</code> 和 <code>setter</code> ，而如果是 <code>final</code> 或者 <code>const</code> 的话，那么它只有一个 <code>getter</code> 方法，<code>Object</code> 都支持 getter、setter 重写：</p> 
<pre><code> @override</code><code>  Size get preferredSize {<!-- --></code><code>    return Size.fromHeight(kTabHeight + indicatorWeight);</code><code>  }</code></pre> 
<h4><strong>7、Assert(断言)</strong></h4> 
<p><code>assert</code> 是一种用于调试的语句，用于检查我们的代码是否符合预期。在Flutter语法中，经常使用assert进行断言，通常用于参数检查、测试代码、调试代码等场景。在使用时需要注意：</p> 
<ul><li>assert只在开发环境有效，在发布环境下将被忽略</li><li>assert的条件应该是纯函数，不应有任何副作用</li><li>assert的错误信息因该尽可能清晰明了，以便于定位问题</li><li>assert的条件不应该包含任何副作用，否则可能会影响程序的正确性</li></ul> 
<p>如下参数检查示例：</p> 
<p>说明：先使用assert检查a是否为null，如果为null，程序将终止执行，并输出错误信息“a不能为null”。如果a不为null，程序将继续执行，输出“a = $a"。</p> 
<pre><code class="language-Dart">void printInteger(int a){
    assert(a != null,'a不能为null');
    print('a=$a');
}</code></pre> 
<h4>8、关键字   </h4> 
<p><br> dart3.0新特性：类修饰符使 API 作者能够仅支持一些特定的功能，而默认值保持不变，例如：<code>abstract</code>、<code>base</code> 、<code>final</code>、<code>interface</code>、<code>sealed</code>、<code>mixin（参考：</code><a href="https://guoshuyu.cn/home/wx/Dart-300.html" rel="nofollow" title="Dart 3 发布，快来看看有什么更新吧 · GitBook">Dart 3 发布，快来看看有什么更新吧 · GitBook</a><code>）</code></p> 
<p><strong>mixins</strong>的中文意思是混入，就是在类中混入其他功能。mixins弥补了接口和继承的不足，继承只能单继承，而接口无法复用实现，mixins却可以多混入并且能利用到混入类的具体实现</p> 
<p>在Dart中可以使用mixins实现类似多继承的功能<br> 因为mixins使用的条件，随着Dart版本一直在变，这里讲的是Dart2.x中使用mixins的条件：<br>   1、作为mixins的类只能继承自Object，不能继承其他类<br>   2、作为mixins的类不能有构造函数<br>   3、一个类可以mixins多个mixins类<br>   4、mixins绝不是继承，也不是接口，而是一种全新的特性<br>   5.mixins的类型就是其超类的子类型</p> 
<p><strong>with</strong>关键字，后跟一个或多个mixin或者普通类。</p> 
<p><strong>on</strong>关键字：要指定只有某些特定类型可以使用mixin，使用on来指定所需的超类或者mixin，可以让你编写的mixin可以调用它未定义的方法，并且可以使用super像继承一样调用父类方法。<br>  <br><strong>extension</strong>关键字（扩展）：https://www.jianshu.com/p/f9d00020b3a5</p> 
<p>==================<strong>Dart中扩展extension关键字   start</strong>============================</p> 
<h4>Dart2.7 扩展对枚举的支持</h4> 
<div> 
 <pre><code class="language-java">例子：

enum Month { jan, feb, mar, apr, may, jun, jul, aug, sep, oct, nov, dec }

extension MonthExtension on Month {
  int get value =&gt; this.index + 1;
  String get cn =&gt;
      [
        "一",
        "二",
        "三",
        "四",
        "五",
        "六",
        "七",
        "八",
        "九",
        "十",
        "十一",
        "十二"
      ][this.index] +
      "月";

  String get eng =&gt; [
        "Jan",
        "Feb",
        "Mar",
        "Apr",
        "May",
        "Jun",
        "Jul",
        "Aug",
        "Sep",
        "Oct",
        "Nov",
        "Dec"
      ][this.index];
}

使用：
   final m = Month.jan;
    print('value: ${m.value},cn: ${m.cn},eng: ${m.eng}');
打印结果：value: 1,cn: 一月,eng: Jan


</code></pre> 
</div> 
<p></p> 
<p>==================<strong>Dart中扩展extension关键字   end</strong>============================</p> 
<p id="articleContentId"><strong>operator关键字：</strong>它和运算符（如=）一起使用，表示一个 运算符重载函数，在理解时可将operator和运算符（如operator=）视为一个函数名。</p> 
<h4>9、类、接口、继承</h4> 
<p><code>Dart</code> 中没有接口，类都可以作为接口，把某个类当做接口实现时，只需要使用 <code>implements</code>，然后复写父类方法即可。</p> 
<p>Dart中抽象类: Dart抽象类主要用于定义标准，子类可以继承抽象类，也可以实现抽象类接口。<br> 1、抽象类通过abstract 关键字来定义<br>  2、Dart中的抽象方法不能用abstract声明，Dart中没有方法体的方法我们称为抽象方法。<br>  3、如果子类继承抽象类必须得实现里面的抽象方法<br>  4、如果把抽象类当做接口实现的话必须得实现抽象类里面定义的所有属性和方法。<br>  5、抽象类不能被实例化，只有继承它的子类可以<br> extends抽象类 和 implements的区别：<br>  1、如果要复用抽象类里面的方法，并且要用抽象方法约束子类的话我们就用extends继承抽象类,子类里面不一定需要重写非抽象方法<br>  2、如果只是把抽象类当做标准的话我们就用implements实现抽象类,子类必须得实现类里面定义的所有属性和方法</p> 
<p>Datr中的多态：<br>     子类的实例赋值给父类的引用。 <br>     多态就是父类定义一个方法不去实现，让继承他的子类去实现，每个子类有不同的表现。</p> 
<p>dart中的接口:<br>      普通类或抽象类都可以作为接口被实现。建议使用抽象类定义接口。<br>      同样使用implements关键字进行实现。<br>      实现该接口,必须得实现类里面定义的所有属性和方法</p> 
<p>继承（关键字 extends）单继承<br> 混入 mixins （关键字 with）多混入<br> 接口实现（关键字 implements）<br> 这三种关系可以同时存在，但是有前后顺序：<br> extends -&gt; mixins -&gt; implements<br> extens在前，mixins在中间，implements最后，接下来看具体的例子。<br> 参考链接：https://www.jianshu.com/p/dd11429ba80e</p> 
<h4>10.Record 和 Patterns</h4> 
<p>Record：详细可以参考官方文档：<a href="https://link.juejin.cn/?target=https%3A%2F%2Fdart.dev%2Flanguage%2Frecords" rel="nofollow" title="dart.dev/language/re…">dart.dev/language/re…</a> 或者之前相关的中文资料： <a href="https://juejin.cn/post/7194741144482218045" rel="nofollow" title="juejin.cn/post/719474…">juejin.cn/post/719474…</a></p> 
<p>参考：<a href="https://juejin.cn/post/7231704360668839994" rel="nofollow" title="Google I/O 2023 - Dart 3 正式版发布，快来看看有什么更新吧 - 掘金">Google I/O 2023 - Dart 3 正式版发布，快来看看有什么更新吧 - 掘金</a></p> 
<p></p> 
<h3>flutter相关：</h3> 
<h4>1、Flutter 和 React Native 不同主要在于 <strong>Flutter UI是直接通过 skia 渲染的 ，而 React Native 是将 js 中的控件转化为原生控件，通过原生去渲染的</strong> 。</h4> 
<h4>2、Flutter 中存在 <code>Widget</code> 、 <code>Element</code> 、<code>RenderObject</code> 、<code>Layer</code> 四棵树。详情参考：<a href="https://blog.csdn.net/haoxuhong/article/details/118379092" title="Flutter的核心渲染模块三棵树_ailinghao的博客-CSDN博客_flutter 三棵树">Flutter的核心渲染模块三棵树_ailinghao的博客-CSDN博客_flutter 三棵树</a></h4> 
<h4>3、Flutter 中默认主要通过 <strong><code>runtimeType</code> 和 <code>key</code></strong> 判断更新：</h4> 
<div> 
 <pre><code class="language-java">static bool canUpdate(Widget oldWidget, Widget newWidget) {
    return oldWidget.runtimeType == newWidget.runtimeType
        &amp;&amp; oldWidget.key == newWidget.key;
  }
}</code></pre> 
</div> 
<h4>4、Flutter 中 <code>InheritedWidget</code> 一般用于<strong>状态共享</strong>，</h4> 
<p>如<code>Theme</code> 、<code>Localizations</code> 、 <code>MediaQuery</code> 等，都是通过它实现共享状态，这样我们可以通过 <code>context</code> 去获取共享的状态，比如 <code>ThemeData theme = Theme.of(context);</code></p> 
<blockquote> 
 <p>在 <code>Element</code> 的 <code>inheritFromWidgetOfExactType</code> 方法实现里，有一个 <code>Map&lt;Type, InheritedElement&gt; _inheritedWidgets</code> 的对象。</p> 
 <p><code>_inheritedWidgets</code> 一般情况下是空的，只有当父控件是 <code>InheritedWidget</code>或者本身是 <code>InheritedWidgets</code> 时才会有被初始化，而当父控件是 <code>InheritedWidget</code> 时，这个 <code>Map</code> 会被一级一级往下传递与合并 。</p> 
 <p>所以当我们通过 <code>context</code> 调用 <code>inheritFromWidgetOfExactType</code> 时，就可以往上查找到父控件的 <code>Widget</code> 。</p> 
</blockquote> 
<h4>5、flutter中的生命周期详情参考：<a href="https://blog.csdn.net/haoxuhong/article/details/119946374" title="flutter中state生命周期和app生命周期_ailinghao的博客-CSDN博客">flutter中state生命周期和app生命周期_ailinghao的博客-CSDN博客</a></h4> 
<h4>6、Flutter 中 <code>runApp</code> 启动入口：</h4> 
<p>其实是一个 <code>WidgetsFlutterBinding</code> ，它主要是通过 <code>BindingBase</code> 的子类 <code>GestureBinding</code> 、<code>ServicesBinding</code> 、 <code>SchedulerBinding</code> 、<code>PaintingBinding</code> 、<code>SemanticsBinding</code> 、 <code>RendererBinding</code> 、<code>WidgetsBinding</code> 等，通过 <code>mixins</code> 的组合而成的。</p> 
<h4>7、Flutter 中的 Dart 的线程：</h4> 
<p>是以<strong>事件循环和消息队列</strong>的形式存在，包含两个任务队列，<strong>一个是 microtask 内部队列，一个是 event 外部队列，而 microtask 的优先级又高于 event 。</strong></p> 
<p>默认的在 Dart 中，如 <em>点击、滑动、IO、绘制事件</em> 等事件都属于 <strong>event</strong> 外部队列，<strong>microtask</strong> 内部队列主要是由 Dart 内部产生，而 <code>Stream</code> 中的执行异步的模式是 <code>scheduleMicrotask</code> 了。</p> 
<blockquote> 
 <p>因为 microtask 的优先级又高于 event， 同时会阻塞event 队列，所以如果 microtask 太多就可能会对触摸、绘制等外部事件造成阻塞卡顿哦。</p> 
</blockquote> 
<p>Flutter 中存在<strong>四大线程，分别为 <code>UI Runner</code>、<code>GPU Runner</code>、<code>IO Runner</code>， <code>Platform Runner</code>（原生主线程）</strong> ，同时在 Flutter 中可以通过 <code>isolate</code> 或者 <code>compute</code> 执行真正的跨线程异步操作。</p> 
<h4><strong>8、Flutter 的 Debug 下是 JIT 模式，release下是AOT模式。</strong></h4> 
<h4><strong>9、PlatformView</strong></h4> 
<p>Flutter 中通过 <code>PlatformView</code> 可以嵌套原生 <code>View</code> 到 <code>Flutter</code> UI 中，这里面其实是使用了 <code>Presentation</code> + <code>VirtualDisplay</code> + <code>Surface</code> 等实现的，大致原理就是：</p> 
<p>使用了类似副屏显示的技术，<code>VirtualDisplay</code> 类代表一个虚拟显示器，调用 <code>DisplayManager</code> 的 <code>createVirtualDisplay()</code> 方法，将虚拟显示器的内容渲染在一个 <code>Surface</code> 控件上，然后将 <code>Surface</code> 的 id 通知给 Dart，让 engine 绘制时，在内存中找到对应的 <code>Surface</code> 画面内存数据，然后绘制出来。  <strong>实时控件截图渲染显示技术。</strong></p> 
<h4>10、Platform Channel</h4> 
<p>Flutter 中可以通过 <code>Platform Channel</code> 让 Dart 代码和原生代码通信的：</p> 
<blockquote> 
 <ul><li> <p><code>BasicMessageChannel</code> ：用于传递字符串和半结构化的信息。</p> </li><li> <p><code>MethodChannel</code> ：用于传递方法调用（method invocation）。</p> </li><li> <p><code>EventChanne</code> l: 用于数据流（event streams）的通信。</p> </li></ul> 
</blockquote> 
<p><strong>同时 <code>Platform Channel</code> 并非是线程安全的</strong> ，更多详细可查阅闲鱼技术的 《深入理解Flutter Platform Channel》</p> 
<p>其中基础数据类型映射如下：</p> 
<div> 
 <p><img alt="" src="https://images2.imgbox.com/ff/79/AVB2PFUg_o.png">​</p> 
</div> 
<h4>11、Android 启动页</h4> 
<p>Android 中 <code>Flutter</code> 默认启动时会在 <code>FlutterActivityDelegate.java</code> 中读取 AndroidManifset.xml 内 <code>meta-data</code> 标签，其中 <code>io.flutter.app.android.SplashScreenUntilFirstFrame</code> 标志位如果为 ture ，就会启动 Splash 画面效果（类似IOS的启动页面）。</p> 
<p>启动时原生代码会读取 <code>android.R.attr.windowBackground</code> 得到指定的 <code>Drawable</code> ， 用于显示启动闪屏效果，之后并且通过 <code>flutterView.addFirstFrameListener</code>，在<code>onFirstFrame</code>中移除闪屏。</p> 
<h4>12.flutter中key</h4> 
<p>直接子类主要有：<code>LocalKey</code> 跟 <code>GlobalKey</code>。</p> 
<p>LocalKey 是增量算法的核心，决定哪个Element要保留，哪个Element要删除。以下是LocalKey的三个子类。</p> 
<ul><li><code>ValueKey</code>：以值作为参数（数字、字符串）；</li><li>ObjectKey<code>：以对象作为参数</code>；</li><li>UniqueKey<code>：创建唯一标识</code>；通常用于动画的过渡当中</li></ul> 
<p>PageStorageKey</p> 
<p>当你有一个滑动列表，你通过某一个 Item 跳转到了一个新的页面，当你返回之前的列表页面时，你发现滑动的距离回到了顶部。这时候，给 Sliver 一个 PageStorageKey！它将能够保持 Sliver 的滚动状态。</p> 
<p><img alt="" height="696" src="https://images2.imgbox.com/71/0b/OsPkxiwL_o.jpg" width="1200">​</p> 
<p></p> 
<p><code>GlobalKey</code>：用来帮助我们确定某一个<code>Widget</code>、<code>Element</code>或者<code>State</code>，来访问其信息；它在整个程序中是<code>唯一的</code></p> 
<p><strong>用途1：获取配置、状态以及组件位置尺寸等信息</strong></p> 
<p>（1）_globalKey.currentWidget：<strong>获取当前组件的配置信息（存在widget树中）</strong></p> 
<p>（2）_globalKey.currentState：<strong>获取当前组件的状态信息（存在Element树中）</strong></p> 
<p>（3）_globalKey.currentContext：<strong>获取当前组件的大小以及位置信息</strong></p> 
<pre><code class="language-Dart">//获取控件的大小和位置
RenderBox renderBoxRed = _globalKey.currentContext.findRenderObject();
renderBoxRed.size;//大小
renderBoxRed.localToGlobal(Offset.zero);//位置
</code></pre> 
<p><strong>用途2：实现控件的局部刷新</strong></p> 
<p>将需要单独刷新的widget从复杂的布局中抽离出去，然后通过传GlobalKey引用，这样就可以通过GlobalKey实现跨组件的刷新了。</p> 
<p><strong>总结：</strong></p> 
<ul><li>Flutter里的key分为两类，一类是LocalKey，实现类有ValueKey、ObjectKey、UniqueKey；一类是GlobalKey，实现类有LabeledGlobalKey、GlobalObjectKey。</li><li>Key是所有keys类的基类，其默认实现是String类型的ValueKey。</li><li>相同parent下的key是不能一样的，比如不能再同一个page里使用VlaueKey(1)，但是不同parent下是可以存在一样的key的，比如在两个界面里都使用ValueKey(1)。</li><li>UniqueKey只和自己相等，其并没有重写==和hashCode方法，也没有const修饰的构造函数。当调用Element的updateChild方法时，Widget.canUpdate肯定返回false，所以如果你想让widget每次都去创建新的element而不复用old element，那么就给此widget使用UniqueKey。</li><li>GlobalKey的默认实现是LabeledGlobalKey，其没有实现==和hashCode方法，也没有const修饰的构造函数，所以肯定能保证其全局唯一性。</li><li>所有的GlobalKey都保存在BuildOwner类中，其内部维护了一个map用来保存GlobalKey与其对应的Element。</li><li>GlobalObjectKey是特殊的GlobalKey，内部维护了一个Object属性，并实现了==和hashCode方法，通过判断runtimeType以及Object属性是否一致来判断两个GlobalObjectKey是否相等。</li><li>使用GlobalObjectKey时，为了保证GlobalObjectKey的全局唯一性，最佳实践是继承自GlobalObjectKey实现一个private的内部类，可以有效避免多人开发时可能造成的GlobalObjectKey冲突的问题。</li></ul> 
<p>参考：<a href="https://mp.weixin.qq.com/s/EroE7NKBpyCRgEeNkW376g" rel="nofollow" title="Flutter(三十七)-GlobalKey的使用">Flutter(三十七)-GlobalKey的使用</a></p> 
<p><a href="https://blog.csdn.net/jdsjlzx/article/details/123511300" title="Flutter中的Key_flutter key_一叶飘舟的博客-CSDN博客">Flutter中的Key_flutter key_一叶飘舟的博客-CSDN博客</a></p> 
<p><a href="https://zhuanlan.zhihu.com/p/539390818?utm_id=0" rel="nofollow" title="Flutter中的Key详解 - 知乎">Flutter中的Key详解 - 知乎</a></p> 
<p>https://juejin.cn/post/7236413212094021690<br>  </p> 
<h3>ffi相关</h3> 
<p>ffi基础学习：<a href="https://blog.csdn.net/eieihihi/article/details/119601010" title="09、Flutter FFI Dart Native API_eieihihi的专栏-CSDN博客">09、Flutter FFI Dart Native API_eieihihi的专栏-CSDN博客</a></p> 
<p><a href="https://gitee.com/leixun/NativeDemo" rel="nofollow" title=" 代码例子：   NativeDemo: flutter ffi 调用demo"> 代码例子：   NativeDemo: flutter ffi 调用demo</a></p> 
<p><a href="https://blog.csdn.net/u010107153/article/details/116033340" title="Flutter FFI实践_落叶挽歌的博客-CSDN博客">Flutter FFI实践_落叶挽歌的博客-CSDN博客</a></p> 
<h3>网站链接</h3> 
<p>https://uutool.cn/id-photo/ 在线证件照换底色工具</p> 
<p>windows上搭建iOS开发环境：</p> 
<p><a href="http://t.csdn.cn/fukyL" rel="nofollow" title="http://t.csdn.cn/fukyL">http://t.csdn.cn/fukyL</a></p> 
<p><a href="https://blog.csdn.net/weixin_44259356/article/details/106075878" title="flutter windows搭建ios开发环境_年轻的古尔丹的博客-CSDN博客">flutter windows搭建ios开发环境_年轻的古尔丹的博客-CSDN博客</a></p> 
<p><a href="https://ducafecat.com/" rel="nofollow" title="首页 | 猫哥在线课堂">首页 | 猫哥在线课堂</a></p> 
<p>图片压缩<a href="https://tinypng.com/" rel="nofollow" title="  TinyPNG – Compress WebP, PNG and JPEG images intelligently">  TinyPNG – Compress WebP, PNG and JPEG images intelligently</a></p> 
<p>GSY的文章在线阅读地址：<a href="https://guoshuyu.cn/home/wx/" rel="nofollow" title="前言 · GitBook">前言 · GitBook</a></p> 
<p>Flutter 超完整的开源项目 https://github.com/CarGuo/gsy_github_app_flutter<br><br><br><a href="https://m.wannianli.tianqi.com/today/zhou/" rel="nofollow" title="今天是第几周,星期几,今天是2022年的第几周-万年历">今天是第几周,星期几,今天是2022年的第几周-万年历</a></p> 
<p>dart在线编辑器需要科学上网：<a href="https://dartpad.dev/" rel="nofollow" title="DartPad">DartPad</a></p> 
<p>不需要科学上网：<a href="https://dartpad.cn/" rel="nofollow" title="DartPad - 由郑州玩码科技有限公司维护">DartPad - 由郑州玩码科技有限公司维护</a></p> 
<p>dartpad使用：<a href="http://www.ppmy.cn/news/25100.html" rel="nofollow" title="【Flutter】DartPad 终极在线Dart编程环境">【Flutter】DartPad 终极在线Dart编程环境</a></p> 
<p>flutter与前端比较 ：<a href="https://mp.weixin.qq.com/s/mgSIu_xcHzU1-Ku218Pjmg" rel="nofollow" title="前端 Flutter 入门指南">前端 Flutter 入门指南</a></p> 
<p>flutter 例子：<a href="https://blog.csdn.net/zl18603543572/article/details/93532582" title="Flutter 项目开发指导 从基础入门到精通使用目录_早起的年轻人的博客-CSDN博客">Flutter 项目开发指导 从基础入门到精通使用目录_早起的年轻人的博客-CSDN博客</a></p> 
<p>慕课网写的比较好的文章  <a href="https://www.imooc.com/u/7650589/articles?page=2" rel="nofollow" title="老菜和尚的    文章">老菜和尚的 文章</a></p> 
<p>对应的列子代码：<a href="https://github.com/ACE-YANGCE/FlutterApp" title="https://github.com/ACE-YANGCE/FlutterApp">https://github.com/ACE-YANGCE/FlutterApp</a></p> 
<p>在线json转dart：<a href="https://devio.org/io/tools/json-to-dart/" rel="nofollow" title="JSON 转Dart - CrazyCodeBoy的技术博客官网|CrazyCodeBoy|Devio|专注移动技术开发(Android&amp;IOS)、Flutter开发、Flutter教程、React Native开发、React Native教程、React Native博客">JSON 转Dart - CrazyCodeBoy的技术博客官网|CrazyCodeBoy|Devio|专注移动技术开发(Android&amp;IOS)、Flutter开发、Flutter教程、React Native开发、React Native教程、React Native博客</a></p> 
<p><a href="https://www.devio.org/2020/10/11/Summary-of-flutter-learning-materials-in-October/" rel="nofollow" title="10月Flutter最新学习资料汇总 - 贾鹏辉的技术博客官网|CrazyCodeBoy|Devio|专注移动技术开发(Android&amp;IOS)、Flutter开发、Flutter教程、React Native开发、React Native教程、React Native博客">10月Flutter最新学习资料汇总 - 贾鹏辉的技术博客官网|CrazyCodeBoy|Devio|专注移动技术开发(Android&amp;IOS)、Flutter开发、Flutter教程、React Native开发、React Native教程、React Native博客</a></p> 
<p><a href="https://www.jianshu.com/p/9201977ed887" rel="nofollow" title="jFlutter 123: 图解简易 GroupList 二级分组列表 - 简书">jFlutter 123: 图解简易 GroupList 二级分组列表 - 简书</a></p> 
<p>flutter例子 </p> 
<p>一个大佬高度封装的抖音 Flutter 3可运行：https://github.com/mjl0602/flutter_tiktok.git</p> 
<p>比较全的ui框架及开源项目：<a href="https://flutterawesome.com/" rel="nofollow" title="Flutter Awesome">Flutter Awesome</a></p> 
<p>Flutter 集录指南FlutterUnit. <a href="https://github.com/toly1994328/FlutterUnit" title="https://github.com/toly1994328/FlutterUnit">https://github.com/toly1994328/FlutterUnit</a></p> 
<p><a href="https://github.com/syncfusion/flutter-examples" title="flutter例子  https://github.com/syncfusion/flutter-examples">flutter例子  https://github.com/syncfusion/flutter-examples</a></p> 
<p>飞猪团队 ：<a href="https://github.com/Fliggy-Mobile" title="https://github.com/Fliggy-Mobile">https://github.com/Fliggy-Mobile</a></p> 
<p>飞猪团队陈冰：<a href="https://github.com/chenBingX" title="https://github.com/chenBingX">https://github.com/chenBingX</a></p> 
<p>flutter个人技术文章    <a href="https://juejin.cn/user/4309694831660711/posts" rel="nofollow" title="Nayuta 的个人主页 - 文章 - 掘金">Nayuta 的个人主页 - 文章 - 掘金</a></p> 
<p> (Flutter Widgets 大全)老孟博客（在线阅读地址）：http://laomengit.com/flutter/widgets/widgets_structure.html</p> 
<p><a href="https://github.com/LaoMengFlutter/flutter-do" title="老孟  https://github.com/LaoMengFlutter/flutter-do">老孟  https://github.com/LaoMengFlutter/flutter-do</a></p> 
<p> <a href="http://laomengit.com/" rel="nofollow" title="Flutter | 老孟">Flutter | 老孟</a></p> 
<p><a href="https://github.com/smartbackme" title="https://github.com/smartbackme">https://github.com/smartbackme</a></p> 
<p>Flutter核心技术与实战电子书：<a href="https://www.kancloud.cn/alex_wsc/flutter_demo/1559549" rel="nofollow" title="前言 · Flutter核心技术与实战 · 看云">前言 · Flutter核心技术与实战 · 看云</a></p> 
<p>flutter实战电子书。 https://book.flutterchina.club/<br> flutter桌面支持官方网址：https://flutter.dev/desktop</p> 
<p>flutter中文开发者网站   flutter.cn</p> 
<p>flutter中文网:  https://flutterchina.club/flutter-for-android/</p> 
<p><a href="https://flutterchina.club/tutorials/internationalization/" rel="nofollow" title="国际化Flutter App  - Flutter中文网">国际化Flutter App - Flutter中文网</a><br> dart中文网:    https://www.dartcn.com/guides/language/language-tour<br> dart学习:http://dart.goodev.org/guides/language/language-tour<br> 技术胖的博客地址：https://jspang.com<br> flutter库：https://pub.dartlang.org/     https://pub.flutter-io.cn/<br> 将 Flutter 代码部署到 Web 端 https://blog.csdn.net/weixin_39901213/article/details/111213201<br> wanandroid：https://www.wanandroid.com/<br> codekk:http://p.codekk.com/<br> 技术周报:https://www.androidweekly.cn/<br> 在线作图:https://www.processon.com/</p> 
<p>前端vant控件  https://youzan.github.io/vant/#/zh-CN/skeleton</p> 
<p>接口测试：https://getman.cn/</p> 
<p>leancloud后端云支持  https://www.leancloud.cn<br> 咸鱼技术简书 https://www.jianshu.com/u/cf5c0e4b1111</p> 
<p>唯鹿github地址： https://github.com/simplezhli</p> 
<p>图片类<br> 阿里巴巴矢量图标库<br> materialdesign。  https://material.io/resources/icons/?style=sharp<br> AndroidAssetStudio    http://romannurik.github.io/AndroidAssetStudio/<br> 图标工厂   https://icon.wuruihong.com/ <br> hotpot    https://hotpot.ai/</p> 
<p>百度地图拾取坐标系统  http://api.map.baidu.com/lbsapi/getpoint/index.html</p> 
<p><br> 工具<br> typora    打开md格式的文件</p> 
<p>设计模式https://www.runoob.com/design-pattern/factory-pattern.html</p> 
<p><br> 开眼快创Flutter实践：http://w4lle.com/2021/04/12/kidea-flutter/</p> 
<p>开源项目<br> 停车场系统。https://github.com/981011512/--</p> 
<p>flutter项目</p> 
<p>仿小米商城项目：<a href="https://github.com/deepindo/DoXiaoMiMall" title="GitHub - deepindo/DoXiaoMiMall: 使用flutter编写的小米商城app项目">GitHub - deepindo/DoXiaoMiMall: 使用flutter编写的小米商城app项目</a></p> 
<p>wechat_flutter Flutter版本微信，一个优秀的Flutter即时通讯IM开源库   https://github.com/fluttercandies/wechat_flutter</p> 
<p><a href="https://github.com/fmtjava/Flutter_Eyepetizer" title="GitHub - fmtjava/Flutter_Eyepetizer: Flutter + 组件化实现的一款精美的仿开眼视频(Eyepetizer )跨平台App,适合入门,快速掌握Dart语言以及上手flutter开发(提供Kotlin、React Native、小程序版本 😁 ),希望和大家共同成长,喜欢的话，欢迎start或fork!">GitHub - fmtjava/Flutter_Eyepetizer: Flutter + 组件化实现的一款精美的仿开眼视频(Eyepetizer )跨平台App,适合入门,快速掌握Dart语言以及上手flutter开发(提供Kotlin、React Native、小程序版本 😁 ),希望和大家共同成长,喜欢的话，欢迎start或fork!</a></p> 
<p>一款开源习惯打卡APP,动画为主：<br> Flutter 开源项目 FlutterApp   https://github.com/shichunlei/flutter_app<br> Flutter 开源项目 https://github.com/iotjin/jh_flutter_demo<br> Flutter 练习项目(包括集成测试、可访问性测试)。内含完整UI设计图，更贴近真实项目的练习https://github.com/simplezhli/flutter_deer<br> flutter_deer 问题总结 https://segmentfault.com/a/1190000020329714?utm_source=tag-newest</p> 
<p>Flutter使用的一些骚操作。https://github.com/CNAD666/flutter_use</p> 
<p>Flutter 三方库使用和技术文章 https://github.com/jiang111/flutter_code</p> 
<p>基于Google Flutter的WanAndroid客户端https://github.com/Sky24n/flutter_wanandroid<br> flutter项目。 https://github.com/Sky24n/Moss</p> 
<p>仿阿里 Flutter-go v1.0 效果，并使用 玩Android 站点提供的 API 实现的 Flutter App<br> 博客说明：https://longyi.blog.csdn.net/article/details/107045022<br> 源码链接 https://github.com/YGragon/Flutter-WanAndroid</p> 
<p><br> flutter开源项目<br> https://mp.weixin.qq.com/s/fQNK_4Lm4_DcCueA8V01Ug<br> https://github.com/cnad666/flutter_use<br> git clone git@github.com:cnad666/flutter_use.git<br> git clone git@github.com:toly1994328/flutterunit.git<br> git clone https://github.com/sunyongsheng/Allpass.git<br> git clone https://gitee.com/shizidada/moose_app<br> git clone git@github.com:ertcs/smart_home.git</p> 
<p>Flutter仿京东客户端开源项目 https://www.jianshu.com/p/60588d6a076b<br> Flutter仿京东APP  https://github.com/DiscoverForever/learn_flutter<br> flutter工具类https://github.com/Cheney2006/flutter_utils/tree/master/lib (相关博客https://www.cnblogs.com/maqingyuan/p/13656283.html）<br> flutter项目 https://www.jianshu.com/p/56b9cccf29f0<br> Flutter 仿携程网App  https://github.com/wkl007/flutter_trip</p> 
<p>flutterapp开发常用的轮子分享 https://github.com/826327700/flutter_plugins_demo </p> 
<p>Flutter面试题汇总 <a href="https://www.jianshu.com/p/1e00b5aaf422" rel="nofollow" title="Flutter面试题汇总 - 简书">Flutter面试题汇总 - 简书</a></p> 
<h3>优质文章：</h3> 
<p>jimi的flutter优质博客：<a href="https://liujunmin.com/" rel="nofollow" title="Jimi">Jimi</a></p> 
<h3><a href="https://blog.csdn.net/lyabc123456/article/details/108523199" title="Flutter学习笔记&amp;学习资料推荐_pan.flutter实战第二版-CSDN博客">Flutter学习笔记&amp;学习资料推荐_pan.flutter实战第二版-CSDN博客</a></h3> 
<h4></h4> 
<p></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/b45e942a715af961d225a7848f83a412/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">安全狗荣获“厦门市专精特新中小企业”称号</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/383e08748fa33737048ee19ccd0b8715/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">三星Galaxy S24 系列了发布会预热新品：Galaxy Ring 智能戒指亮相</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>