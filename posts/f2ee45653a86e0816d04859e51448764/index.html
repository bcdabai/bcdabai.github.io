<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Python学习笔记--数值与字符串 - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Python学习笔记--数值与字符串" />
<meta property="og:description" content="本文内容摘自朱雷老师著《Python工匠》一书内容，为学习笔记摘录。
一、数值基础
在Python中，一共存在3种内置数值类型：整型（int）、浮点型（float）、复数类型（complex）。创建如下：
# 定义一个整型 score = 100 # 定义一个浮点型 temp = 37.2 # 定义一个复数 com = 3&#43;4j # 创建一个复数 z = complex(3, 4) # 创建一个复数，实部为3，虚部为4 print(z) # 输出：3&#43;4j 在大多数情况下，主要使用前两种类型：int和float。二者之间可以通过个值得内置方法进行转换：
&gt;&gt;&gt; i = 1_00_000_0000
&gt;&gt;&gt; i
1000000000
&gt;&gt;&gt; j = 2_345_5678
&gt;&gt;&gt; j
23455678
&gt;&gt;&gt; 在定义数字字面量时，如果数字特别长，可以通过插入下划线 _ 分隔符来让它变得更易读，如：
# 以“千”为单位分割数字
&gt;&gt;&gt; i = 1_000_000_000
&gt;&gt;&gt; i
1000000000
# 其实，可以随意位数间隔，比如
&gt;&gt;&gt; j = 2_345_5678
&gt;&gt;&gt; j
23455678
&gt;&gt;&gt; 一个问题：浮点数精度
如果在Python命令行输入0.1 &#43; 0." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/f2ee45653a86e0816d04859e51448764/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2024-01-22T17:36:38+08:00" />
<meta property="article:modified_time" content="2024-01-22T17:36:38+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Python学习笔记--数值与字符串</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p>本文内容摘自朱雷老师著《Python工匠》一书内容，为学习笔记摘录。</p> 
<p><strong>一、数值基础</strong></p> 
<p>在Python中，一共存在3种内置数值类型：整型（int）、浮点型（float）、复数类型（complex）。创建如下：</p> 
<pre><code class="language-python"># 定义一个整型
score = 100
# 定义一个浮点型
temp = 37.2
# 定义一个复数
com = 3+4j

# 创建一个复数  
z = complex(3, 4)  # 创建一个复数，实部为3，虚部为4  
print(z)  # 输出：3+4j</code></pre> 
<p>在大多数情况下，主要使用前两种类型：int和float。二者之间可以通过个值得内置方法进行转换：</p> 
<p>&gt;&gt;&gt; i = 1_00_000_0000<br> &gt;&gt;&gt; i<br> 1000000000<br> &gt;&gt;&gt; j = 2_345_5678<br> &gt;&gt;&gt; j<br> 23455678<br> &gt;&gt;&gt; </p> 
<p>在定义数字字面量时，如果数字特别长，可以通过插入下划线 _ 分隔符来让它变得更易读，如：</p> 
<p># 以“千”为单位分割数字</p> 
<p>&gt;&gt;&gt; i = 1_000_000_000<br> &gt;&gt;&gt; i<br> 1000000000</p> 
<p># 其实，可以随意位数间隔，比如<br> &gt;&gt;&gt; j = 2_345_5678<br> &gt;&gt;&gt; j<br> 23455678<br> &gt;&gt;&gt; </p> 
<p><br><strong>一个问题：浮点数精度</strong></p> 
<p>如果在Python命令行输入0.1 + 0.2 ，你会看到这样的奇景：</p> 
<p>&gt;&gt;&gt; 0.1+0.2<br> 0.30000000000000004<br> &gt;&gt;&gt; <br> 解决这样的问题，可以使用Python内置模块decimal。如果程序需要精确的浮点数计算，可以考虑使用decimal.Decimal对象来替代普通浮点数，它在做四则运算时候不会损失任何精度：</p> 
<p>&gt;&gt;&gt; from decimal import Decimal</p> 
<p># 注意：这里的“0.01”和“1.01”必须是字符串<br> &gt;&gt;&gt; Decimal("0.01") + Decimal("1.01")<br> Decimal('1.02')<br> &gt;&gt;&gt; <br>  </p> 
<p><strong>布尔值其实也是数字</strong></p> 
<p>布尔（bool）类型是Python里用来表示“真假”的数据类型，包括两个可选值：True和False。布尔值其实是整型的子类型，在绝大多数情况下，True和False可以当做1和0来使用。就像如下这样：</p> 
<p>&gt;&gt;&gt; int(True),int(False)<br> (1, 0)<br> &gt;&gt;&gt; True + 1<br> 2<br> &gt;&gt;&gt; False +1<br> 1<br> &gt;&gt;&gt; 1 /True<br> 1.0</p> 
<p># 把False当做除数，和0一样会抛出异常<br> &gt;&gt;&gt; 1 /False<br> Traceback (most recent call last):<br>   File "&lt;stdin&gt;", line 1, in &lt;module&gt;<br> ZeroDivisionError: division by zero<br> &gt;&gt;&gt; </p> 
<p>利用“布尔值可作为整型使用”的特性，用一个简单的表达式实现统计一个包含整数列表中的偶数的数量：</p> 
<p>&gt;&gt;&gt; numbers = [1,2,3,4,5,6,7,8,9,10,11,12]<br> &gt;&gt;&gt; count = sum(num % 2 == 0 for num in numbers)<br> &gt;&gt;&gt; count<br> 6<br> &gt;&gt;&gt; </p> 
<p><strong>特殊数字：“无穷大、无穷小”</strong></p> 
<p>Python中float("inf")和float("-inf")分别代表数学世界中的正负无穷大。</p> 
<p><strong>float("-inf")  &lt; 任意数值 &lt; float("inf")</strong></p> 
<p>比如有一个包含用户名和年龄的字典，我们需要把里面的用户名按照年龄升序排序，没有提供年龄的放在最后面。下面代码使用float("inf"),代码可以这么写：</p> 
<pre><code class="language-python">def sort_users_inf(users):

    def key_func(username):
        age = users[username]
        # 当年龄为空时，返回正无穷大作为key，因此会被排到最后
        return age if age is not None else float("inf")
    
    return sorted(users.keys(),key=key_func)

users = {"liuzx":19,"jenny":13,"jack":None,"liuyf":48}

print(sort_users_inf(users))   # 输出：['jenny', 'liuzx', 'liuyf', 'jack']</code></pre> 
<p><strong>二、字符串的格式化</strong></p> 
<p>当前主流Python版本中，有3种主要的字符串格式化方式。</p> 
<p>（1）C语言风格的基于百分号%的格式化语句：‘Hello, %s’  %  'World'.</p> 
<p>（2）新式字符串格式化（str.format）方式："Hello ，{}".format("World")</p> 
<p>（3）f-string字符串字面量格式化表达式（Python3.6新增）：如下：</p> 
<p>&gt;&gt;&gt; name = "World"<br> &gt;&gt;&gt; welcome_text = f"Hello,{name}"<br> &gt;&gt;&gt; welcome_text<br> 'Hello,World'<br> &gt;&gt;&gt;</p> 
<p>后两种方式越来越流行被采用，f-string格式化方式用起来最为方便，作者建议首选。</p> 
<p>str.format 与f-string共享同一种复杂的“字符串格式化微语言”。通过这种微语言，可以方便地对字符串进行二次加工，然后输出。比如：</p> 
<p># 将username靠右对齐，左侧补齐空格到一共20个字符</p> 
<p># 下面两种方式将输出同样的内容</p> 
<p>&gt;&gt;&gt; username = "liuyf"<br> &gt;&gt;&gt; print('{:&gt;20}'.format(username))<br>                liuyf<br> &gt;&gt;&gt; print(f'{username:&gt;20}')<br>                liuyf<br> &gt;&gt;&gt; </p> 
<p>一个应用案例：</p> 
<p><strong>字符串与字节串</strong></p> 
<p>（1）字符串：普通的字符串，也称为文本（text），是给人看的，对应Python中的字符串（str）类型。str使用Unicode标准，可以通过.encode()方法编码为字节串。</p> 
<p>（2）字节串：有时也称为“二进制字符串”（binary string），是给计算机看的，对应Python中的字节串（bytes）类型。bytes一定包含某种真正的字符串编码格式（默认为UTF-8），可通过.decode()方法解码为字符串。</p> 
<p>&gt;&gt;&gt; str_obj = 'Hello，火星'<br> &gt;&gt;&gt; str_obj<br> 'Hello，火星'<br> &gt;&gt;&gt; type(str_obj)<br> &lt;class 'str'&gt;<br> &gt;&gt;&gt; bin_str = str_obj.encode('UTF-8')<br> &gt;&gt;&gt; bin_str<br> b'Hello\xef\xbc\x8c\xe7\x81\xab\xe6\x98\x9f'<br> &gt;&gt;&gt; type(bin_str)<br> &lt;class 'bytes'&gt;<br> &gt;&gt;&gt;</p> 
<p>bytes和str是两种不同的数据类型，即使有时看上去“一样”，但是做比较时永不相等：</p> 
<p>&gt;&gt;&gt; "Hello" == b"Hello"<br> False<br> &gt;&gt;&gt;</p> 
<p>另外，不能使用bytes来调用任何内置方法，反之亦然：</p> 
<p>&gt;&gt;&gt; "Hello".split("e")<br> ['H', 'llo']<br> &gt;&gt;&gt; "Hello".split(b"e")<br> Traceback (most recent call last):<br>   File "&lt;stdin&gt;", line 1, in &lt;module&gt;<br> TypeError: must be str or None, not bytes<br> &gt;&gt;&gt; </p> 
<p>在程序中，尽量保证总是操作普通字符串，而非字节串。必须操作处理字节串的场景一般有两种：</p> 
<p>（1）程序从文件或其它外部存储读取字节串内容，将其解码为字符串，然后在内部使用。</p> 
<p>（2）程序完成处理，要把字符串写入文件或者其它外部存储，将其编码为字节串，然后继续执行其它操作。</p> 
<p>小知识：普通字符串采用的是文本格式，没法直接存放于外部存储，一定要将其编码为字节串——也就是“二进制字符串”。比如一些文本编辑器编辑文本，我们看到是文本（普通字符串），当编辑器把文本作为文件保存到硬盘等存储器时，会进行编码，把文本及格式转换为字节串，才能保存到存储设备中。</p> 
<p>改善代码的可读性案例</p> 
<p>Python中没有真正的常量类型，一般把大写字母全局变量当做“常量”来用。比如把积分数定义为常量：</p> 
<p># 用户每日登录奖励积分数量</p> 
<p>DAILY_POINTS_REWARDS = 100</p> 
<p># VIP用户每日登录，额外再奖励积分20</p> 
<p>VIP_EXTRA_POINTS = 20</p> 
<p>除了常量之外，Python3.4开始引入了专门用于表示枚举类型的内置模块，在程序中可以定义枚举类型（enum.Enum）作为常量：</p> 
<pre><code class="language-python">from enum import Enum

# 在定义枚举类型时，如果同时继承一些基础类型，比如int，str
# 枚举类型就能同时充当该基础类型使用，必须下面代码，使用UserType就可以充当int使用

DIALY_POLINTS_REWARDS = 100
VIP_EXTRA_POLINTS = 20

class UserType(int,Enum):
    # VIP 用户
    VIP = 3
    # 封禁的用户（黑名单用户）
    BANNED = 13

def add_daily_points(user):
    """用户每天完成第一次登录后，为其增加积分
    """
    # 用户为封禁用户
    if user.type == UserType.BANNED:
        return
    
    # 用户为VIP用户
    if user.type == UserType.VIP:
        user.points += DIALY_POLINTS_REWARDS + VIP_EXTRA_POLINTS
        return
    
    # 普通用户
    user.points = DIALY_POLINTS_REWARDS
    return</code></pre> 
<p>使用常量和枚举变量类型的好处：</p> 
<p>（1）代码更易读：所有人都不需要记忆某个数字代表什么。</p> 
<p>（2）代码更健壮：降低输错数字或者字母产生bug的可能性。</p> 
<p><strong>改善超长字符串的可读性</strong></p> 
<p>为了保证代码的可读性，单行代码的长度不易过长，比如PEP8规范建议每行字符数不超过79，大部分人遵循不超过119个字符。遇到超长的字符串怎么办？</p> 
<p>除了使用斜杠\和加号+将长字符串拆分为几段，还有一种更简单的方法，就是拿括号将长字符串包起来，之后就可以随意折行了。</p> 
<pre><code class="language-python">s = ("This is the first line of a long string,"
     "this is the second line."
     )
print(s)  # 输出："This is the first line of a long string,this is the second line."</code></pre> 
<p>如果字符串出现在函数参数等位置，可以省略一层括号，下面语句输出和上面是一样的。</p> 
<pre><code class="language-python">print("This is the first line of a long string,"
      "this is the second line."
      )</code></pre> 
<p></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/a201a1c7472dcb4e5771c0a6cad61ebf/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">android 导航app 稳定性问题总结</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/1d335774580050dde33586336da768d9/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">Java 设计者模式以及与Spring关系(四) 代理模式</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>