<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>tf.estimator.Estimator类的用法 - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="tf.estimator.Estimator类的用法" />
<meta property="og:description" content="https://blog.csdn.net/liushuikong/article/details/79223407
https://www.cnblogs.com/arkenstone/p/8448208.html
https://zhuanlan.zhihu.com/p/41473323
https://yinguobing.com/facial-landmark-localization-by-deep-learning-save-model-application/#fn3
https://www.cnblogs.com/YouXiangLiThon/p/7435825.html
https://guillaumegenthial.github.io/serving-tensorflow-estimator.html
1、estimator
estimator类是机器学习模型的抽象，estimator允许开发者自定义任意的结构模型、损失函数、优化函数以及如何对这个模型进行训练、导出、评估等内容，同时屏蔽了与底层硬件设备、分布式网络数据传输等相关细节
tf.eatimator.Estimator( model_fn=model_fn, params=params, config=run_config ) 一个estimator，需要传入模型函数，参数和配置
参数应该是模型超参数的一个集合，可以是一个字典
配置用于指定模型如何运行训练和评估，以及在哪里存储结果，该对象会把相关信息高速estimator
模型函数一个python函数，它根据给定的输入构建模型
2、estimator类主要有三个方法：train、evaluate、predict，分别表示模型的训练、评估和预测，三个方法都接受一个用户自定义的输入函数input_fn，执行input_fn获取输入数据，estimator的三个方法都会调用model_fn执行具体操作，不同mode传入，返回的也不同
def input_fn(dataset): *** return feature,label 类内方法，model_fn，train、evaluate、predict参考http://www.cnblogs.com/zongfa/p/10149483.html
3、
def my_model( features, #this is batch_features from input_fn labels, #this is batch_labels from input_fn mode, #an instance of tf.estimator.ModeKeys params #configuration ) 这是固定格式，利用estimator进行train、eval、predict，下面是train方法。train_input_fn()传入所需的features，labels
http://www.cnblogs.com/wdmx/p/10010433.html
classifier.train(input_fn=lambda: train_input_fn(FILE_TRAIN, True, 500)) 一个比较好的例子https://guillaumegenthial.github.io/serving-tensorflow-estimator.html https://github.com/tensorflow/models/blob/master/samples/outreach/blogs/blog_custom_estimators.py 4、保存模型 https://www.cnblogs.com/arkenstone/p/8448208.html
def serving_input_receiver_fn(): &#34;&#34;&#34; Build serving inputs &#34;&#34;&#34; inputs = tf.placeholder(dtype=tf.string, name=&#34;input_image&#34;) feature_config = {&#39;image/encoded&#39;: tf." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/f1fa71ac6fe4d73da4df3afd18a6be2e/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2019-04-17T17:46:43+08:00" />
<meta property="article:modified_time" content="2019-04-17T17:46:43+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">tf.estimator.Estimator类的用法</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p><a href="https://blog.csdn.net/liushuikong/article/details/79223407">https://blog.csdn.net/liushuikong/article/details/79223407</a></p> 
<p><a href="https://www.cnblogs.com/arkenstone/p/8448208.html" rel="nofollow">https://www.cnblogs.com/arkenstone/p/8448208.html</a></p> 
<p><a href="https://zhuanlan.zhihu.com/p/41473323" rel="nofollow">https://zhuanlan.zhihu.com/p/41473323</a></p> 
<p><a href="https://yinguobing.com/facial-landmark-localization-by-deep-learning-save-model-application/#fn3" rel="nofollow">https://yinguobing.com/facial-landmark-localization-by-deep-learning-save-model-application/#fn3</a></p> 
<p><a href="https://www.cnblogs.com/YouXiangLiThon/p/7435825.html" rel="nofollow">https://www.cnblogs.com/YouXiangLiThon/p/7435825.html</a></p> 
<p><a href="https://guillaumegenthial.github.io/serving-tensorflow-estimator.html" rel="nofollow">https://guillaumegenthial.github.io/serving-tensorflow-estimator.html</a></p> 
<p>1、estimator</p> 
<p>estimator类是机器学习模型的抽象，estimator允许开发者自定义任意的结构模型、损失函数、优化函数以及如何对这个模型进行训练、导出、评估等内容，同时屏蔽了与底层硬件设备、分布式网络数据传输等相关细节</p> 
<p><img alt="" class="has" height="272" src="https://images2.imgbox.com/fa/7a/sSIHOjwd_o.png" width="521"></p> 
<pre class="has"><code class="hljs">tf.eatimator.Estimator(
    model_fn=model_fn,
    params=params,
    config=run_config
)</code></pre> 
<p>一个estimator，需要传入模型函数，参数和配置</p> 
<p>参数应该是模型超参数的一个集合，可以是一个字典</p> 
<p>配置用于指定模型如何运行训练和评估，以及在哪里存储结果，该对象会把相关信息高速estimator</p> 
<p>模型函数一个python函数，它根据给定的输入构建模型</p> 
<p>2、estimator类主要有三个方法：train、evaluate、predict，分别表示模型的训练、评估和预测，三个方法都接受一个用户自定义的输入函数input_fn，执行input_fn获取输入数据，estimator的三个方法都会调用model_fn执行具体操作，不同mode传入，返回的也不同</p> 
<pre class="has"><code class="hljs">def input_fn(dataset):
    ***
    return feature,label</code></pre> 
<p>类内方法，model_fn，train、evaluate、predict参考<a href="http://www.cnblogs.com/zongfa/p/10149483.html" rel="nofollow">http://www.cnblogs.com/zongfa/p/10149483.html</a></p> 
<p>3、</p> 
<pre class="has"><code class="hljs">def my_model(
    features,     #this is batch_features from input_fn
    labels,       #this is batch_labels from input_fn
    mode,         #an instance of tf.estimator.ModeKeys
    params        #configuration
)</code></pre> 
<p>这是固定格式，利用estimator进行train、eval、predict，下面是train方法。train_input_fn()传入所需的features，labels</p> 
<p><a href="http://www.cnblogs.com/wdmx/p/10010433.html" rel="nofollow">http://www.cnblogs.com/wdmx/p/10010433.html</a></p> 
<pre class="has"><code class="hljs">classifier.train(input_fn=lambda: train_input_fn(FILE_TRAIN, True, 500))
</code></pre> 
<p>一个比较好的例子<a href="https://guillaumegenthial.github.io/serving-tensorflow-estimator.html" rel="nofollow">https://guillaumegenthial.github.io/serving-tensorflow-estimator.html</a>     </p> 
<p>                               <a href="https://github.com/tensorflow/models/blob/master/samples/outreach/blogs/blog_custom_estimators.py">https://github.com/tensorflow/models/blob/master/samples/outreach/blogs/blog_custom_estimators.py</a>                   </p> 
<p>4、保存模型    </p> 
<p> <a href="https://www.cnblogs.com/arkenstone/p/8448208.html" rel="nofollow">https://www.cnblogs.com/arkenstone/p/8448208.html</a></p> 
<pre class="has"><code class="hljs">def serving_input_receiver_fn():
    """
    Build serving inputs
    """
    inputs = tf.placeholder(dtype=tf.string, name="input_image")
    feature_config = {'image/encoded': tf.FixedLenFeature(shape=[], dtype=tf.string)}
    tf_example = tf.parse_example(inputs, feature_config)
    patch_images = tf.map_fn(_preprocess_image, tf_example["image/encoded"], dtype=tf.float32)
    patch_images = tf.squeeze(patch_images, axis=[0])
    receive_tensors = {'example': inputs}
    features = {"input": patch_images}
    return tf.estimator.export.ServingInputReceiver(features, receive_tensors)


def save_serving_model():
    session_config = tf.ConfigProto(gpu_options=tf.GPUOptions(allow_growth=True))
    config = tf.estimator.RunConfig(model_dir=MODEL_WEIGHTS_PATH, session_config=session_config)  # session_config is used for configuration of session
    model = get_estimator_model(config=config)
    model.export_savedmodel(export_dir_base=SERVING_MODEL_SAVE_PATH, serving_input_receiver_fn=serving_input_receiver_fn)</code></pre> 
<p> </p> 
<p>将训练好的ckpt模型freeze成pb模型文件，estimator提供export_savedmodel函数</p> 
<p>export_savedmodel(export_dir_base,serving_inpit_receiver_fn)</p> 
<p>该方法首先建立一个图，以获得输入法特征Tensors，，然后调用estimator的model_fn()，以基于这些特征的模型曲线图，开始session，将最新的还原到其中，在export_bir_base下（保存目录）创建一个带时间戳的导出目录，并将savedmodel写入包含mateGraphDefault，保存单个文件</p> 
<p>当自定义model_fn时，必须要填充export_output元素，<a href="https://www.tensorflow.org/api_docs/python/tf/estimator/EstimatorSpec?hl=zh-cn" rel="nofollow">https://www.tensorflow.org/api_docs/python/tf/estimator/EstimatorSpec?hl=zh-cn</a>，这是{name:output}描述在投放期间要导出进而使用的输出签名和命令</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/1f78476bf407dd6012070113570a0c50/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">angularJs 编译打包（ng build --prod）遇到的内存不足（js stack trace）问题及解决方法</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/af4c9057b01befafc0963654e8465479/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">超详细的MySQL高性能优化实战</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>