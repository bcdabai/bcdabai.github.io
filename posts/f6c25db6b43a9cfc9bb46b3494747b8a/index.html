<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>01-开始Rust之旅 - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="01-开始Rust之旅" />
<meta property="og:description" content="上一篇：00-Rust前言
1. 下载Rust 官方推荐使用 rustup 下载 Rust，这是一个管理 Rust 版本和相关工具的命令行工具。下载时需要连接互联网。
这边提供了离线安装版本。本人学习的机器环境为： ubuntu x86_64，因此选用第②个工具链；
1. rust-1.75.0-x86_64-pc-windows-gnu.msi
2. rust-1.75.0-x86_64-unknown-linux-gnu.tar.gz
$ rustc --version rustc 1.75.0 (82e1608df 2023-12-21) 2. 编写和运行 Rust 程序 Rust 对编辑、工具或代码的存放位置没有特别的要求，因此如果你喜欢使用集成开发环境（IDE）而不是命令行，请随意使用你喜欢的集成开发环境。许多集成开发环境现在都在一定程度上支持 Rust；Rust 团队一直致力于通过 rust-analyzer 实现对集成开发环境的强大支持。
vscode可直接安装rust-anslyzer插件；
创建一个新的源文件，并将其命名为 main.rs。Rust 文件总是以 .rs 扩展名结尾。如果你在文件名中使用了多个单词，惯例是使用下划线分隔它们。例如，使用 hello_world.rs 而不是 helloworld.rs。
fn main() { println!(&#34;Hello, Rust!&#34;); } 保存文件，在 Linux输入以下命令编译并运行文件：
$ rustc main.rs $ ./main Hello, Rust! 2.1 Rust 程序剖析 这几行定义了一个名为 main 的函数。 main 函数很特别：它总是每个可执行 Rust 程序中运行的第一段代码。这里，第一行声明了一个名为 main 的函数，该函数没有参数，也不返回任何内容。如果有参数，则会放在括号 () 中。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/f6c25db6b43a9cfc9bb46b3494747b8a/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2024-01-21T11:02:42+08:00" />
<meta property="article:modified_time" content="2024-01-21T11:02:42+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">01-开始Rust之旅</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p>上一篇：<a class="link-info" href="https://blog.csdn.net/eyatal/article/details/135672678" title="00-Rust前言">00-Rust前言</a></p> 
<hr> 
<h2>1. 下载Rust</h2> 
<p>        官方推荐使用 <span style="color:#fe2c24;"><u>rustup</u></span> 下载 Rust，这是一个管理 Rust 版本和相关工具的命令行工具。下载时需要连接互联网。</p> 
<p>        这边提供了离线安装版本。本人学习的机器环境为： ubuntu x86_64，因此选用第②个工具链；</p> 
<p>                1. <a class="link-info" href="https://download.csdn.net/download/eyatal/88757489" title="rust-1.75.0-x86_64-pc-windows-gnu.msi">rust-1.75.0-x86_64-pc-windows-gnu.msi</a></p> 
<p>                2. <span style="color:#fe2c24;"><a class="link-info" href="https://download.csdn.net/download/eyatal/88757501" title="rust-1.75.0-x86_64-unknown-linux-gnu.tar.gz">rust-1.75.0-x86_64-unknown-linux-gnu.tar.gz</a></span></p> 
<pre><code class="language-bash">$ rustc --version

rustc 1.75.0 (82e1608df 2023-12-21)</code></pre> 
<h2>2. 编写和运行 Rust 程序</h2> 
<blockquote> 
 <p>    Rust 对编辑、工具或代码的存放位置没有特别的要求，因此如果你喜欢使用集成开发环境（IDE）而不是命令行，请随意使用你喜欢的集成开发环境。许多集成开发环境现在都在一定程度上支持 Rust；Rust 团队一直致力于通过 <span style="color:#fe2c24;"><u>rust-analyzer</u></span> 实现对集成开发环境的强大支持。</p> 
 <p>    vscode可直接安装rust-anslyzer插件；</p> 
</blockquote> 
<p>        创建一个新的源文件，并将其命名为 main.rs。<u>Rust 文件总是以 .rs 扩展名结尾</u>。<u>如果你在文件名中使用了多个单词，惯例是<span style="color:#fe2c24;">使用下划线分隔它们</span></u>。例如，使用 hello_world.rs 而不是 helloworld.rs。</p> 
<pre><code class="language-rust">fn main() {
    println!("Hello, Rust!");
}</code></pre> 
<p>        保存文件，在 Linux输入以下命令编译并运行文件：</p> 
<pre><code class="language-rust">$ rustc main.rs
$ ./main
Hello, Rust!</code></pre> 
<h3>2.1 Rust 程序剖析</h3> 
<p>        这几行定义了一个名为 main 的函数。 main 函数很特别：它总是每个可执行 Rust 程序中运行的第一段代码。这里，第一行声明了一个名为 main 的函数，该函数没有参数，也不返回任何内容。如果有参数，则会放在括号 () 中。</p> 
<p>        函数体用 {} 封装。Rust 要求在所有函数体周围使用大括号。<span style="color:#fe2c24;"><u>好的做法是将开头的大括号与函数声明放在同一行，中间空一格</u></span>。</p> 
<blockquote> 
 <p>注意：如果你想在 Rust 项目中坚持使用一种标准样式，可以使用一个名为 <code>rustfmt</code> 的自动格式化工具，以特定样式格式化你的代码。Rust 团队已将该工具包含在标准 Rust 发行版中，就像 <code>rustc</code> 一样！</p> 
</blockquote> 
<p><img alt="" height="99" src="https://images2.imgbox.com/3a/03/KJGM04M1_o.png" width="798"></p> 
<p>        main 函数的主体包含以下代码：</p> 
<pre><code class="language-rust">    println!("Hello, Rust!");</code></pre> 
<p>        这一行完成了这个小程序的所有工作：将文本打印到屏幕上。这里有四个重要细节需要注意：</p> 
<p>        首先，Rust 风格是缩进四个空格，而不是制表符。</p> 
<p>        其次， println! 调用的是 Rust 宏。如果它调用的是一个函数，就会以 println 的形式输入（去掉 ! ）。<u><span style="color:#fe2c24;">使用 ! 意味着你调用的是宏而不是普通函数</span>，而且宏并不总是遵循与函数相同的规则</u>。</p> 
<p>        第三，您将看到 "Hello, world!" 字符串。我们将这个字符串作为参数传递给 println! ，然后字符串就会被打印到屏幕上。</p> 
<p>        第四，我们用分号 ( ; ) 结束这一行，表示这个表达式结束，下一个表达式准备开始。<u>Rust 代码的大多数行都以分号结束</u>。</p> 
<h3>2.2 编译和运行是不同的步骤</h3> 
<p>        在运行 Rust 程序之前，您必须使用 Rust 编译器对其进行编译，方法是输入 rustc 命令并将源文件的名称传给它，就像这样：</p> 
<pre><code class="language-rust">rustc main.rs</code></pre> 
<p>        如果你有 C 或 C++ 背景，就会发现这与 gcc 或 clang 类似。编译成功后，Rust 会输出一个二进制可执行文件。</p> 
<pre><code class="language-cpp">g++ -o demo demo.cpp</code></pre> 
<p>        接着，运行main可执行程序，在终端即可输出"Hello, Rust"文本。</p> 
<pre><code class="language-rust">./main</code></pre> 
<p>        对于简单的程序来说，只用 rustc 进行编译就可以了，但随着项目的发展，你会希望管理所有选项，并方便共享代码。接下来，我们将向你介绍 Cargo 工具，它将帮助你编写真实世界的 Rust 程序。</p> 
<h2>3. Cargo</h2> 
<p>        Cargo 是 Rust 的构建系统和软件包管理器。大多数 Rustaceans 都使用这个工具来管理他们的 Rust 项目，因为 Cargo 可以为你处理很多任务，例如构建代码、下载代码所依赖的库，以及构建这些库。(我们把代码需要依赖的库称为依赖库）。</p> 
<blockquote> 
 <p>从这一点上看，和Android中的Gradle很像；</p> 
</blockquote> 
<p>        最简单的 Rust 程序，比如我们目前编写的程序，不需要任何依赖库。如果我们用 Cargo 构建了 "Hello, Rust!"项目，它将只使用 Cargo 中负责构建代码的部分。当你编写更复杂的 Rust 程序时，你会添加依赖关系，如果你使用 Cargo 启动一个项目，添加依赖关系就会容易得多。</p> 
<p>        请在终端输入以下命令检查 Cargo 是否已安装：</p> 
<pre><code class="language-bash">$ cargo --version
cargo 1.75.0 (1d8b05cdd 2023-11-20)</code></pre> 
<h3>3.1 用Cargo创建项目</h3> 
<p>        让我们使用 Cargo 创建一个新项目，看看它与最初的 "Hello, Rust!"项目有何不同。回到你的项目目录（或你决定存储代码的地方）。然后，在任何操作系统上运行以下命令：</p> 
<pre><code class="language-bash">$ cargo new hello_cargo
$ cd hello_cargo</code></pre> 
<p>        第一条命令会创建一个名为 hello_cargo 的新目录和项目。我们将项目命名为 hello_cargo，Cargo 会在同名目录下创建文件。</p> 
<p>        进入 hello_cargo 目录并列出文件。你会看到 Cargo 为我们生成了两个文件和一个目录：一个 Cargo.toml 文件和一个包含 main.rs 文件的 src 目录。</p> 
<p class="img-center"><img alt="" height="110" src="https://images2.imgbox.com/20/80/Wvxkp7Cm_o.png" width="186"></p> 
<p>        它还初始化了一个新的 Git 仓库和一个 .gitignore 文件。如果在现有的 Git 仓库中运行 cargo new ，则不会生成 Git 文件；您可以使用 cargo new --vcs=git .</p> 
<blockquote> 
 <p>    注：Git 是一种常见的版本控制系统。您可以使用 --vcs 标志更改 cargo new 以使用其他版本控制系统或不使用版本控制系统。运行 cargo new --help 查看可用选项。</p> 
</blockquote> 
<p>        在文本编辑器中打开 Cargo.toml。它应该与下面代码相似。</p> 
<pre><code class="language-bash">[package]
name = "hell_cargo"
version = "0.1.0"
edition = "2021"

# See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html

[dependencies]
</code></pre> 
<p>        该文件采用 TOML（Tom's Obvious, Minimal Language）格式，是 Cargo 的配置格式。</p> 
<p>        第一行 [package] 是一个章节标题，表示下面的语句正在配置一个软件包。当我们向该文件添加更多信息时，我们将添加其他部分。</p> 
<p>        接下来的三行设置了 Cargo 编译程序所需的配置信息：名称、版本和要使用的 Rust 版本。</p> 
<p>        最后一行，<u> [dependencies] ，是列出项目依赖关系的开头部分</u>。在 Rust 中，代码包被称为 crates。在本项目中，我们不需要任何其他依赖部分。</p> 
<p>        现在打开 src/main.rs，看一看：</p> 
<pre><code class="language-rust">fn main() {
    println!("Hello, world!");
}
</code></pre> 
<p>        Cargo 已经为你生成了一个 "Hello, world!"程序，就像我们之前编写的程序一样！到目前为止，我们的项目与 Cargo 生成的项目之间的区别在于：Cargo 将代码放在了 src 目录中，在顶层目录中添加了一个 Cargo.toml 配置文件。</p> 
<p>        Cargo 希望你的源文件位于 src 目录中。<u>项目顶层目录只用于存放 README 文件、许可证信息、配置文件以及其他<span style="color:#fe2c24;">与代码无关的内容</span></u>。使用 Cargo 可以帮助你组织项目。每样东西都有自己的位置，每样东西都有自己的位置。</p> 
<p>        如果你启动了一个不使用 Cargo 的项目，就像我们的 "Hello, world!"项目一样，你可以将它转换成一个使用 Cargo 的项目。将项目代码移至 src 目录，并创建一个合适的 Cargo.toml 文件。</p> 
<h3>3.2 构建及运行Cargo项目</h3> 
<p>        现在，让我们看看使用 Cargo 构建并运行 "Hello, world!"程序时会有哪些不同！在 hello_cargo 目录下，输入 <span style="color:#ff9900;"><u>cargo build</u></span> 命令构建项目：</p> 
<pre><code class="language-bash">$ cargo build
   Compiling hell_cargo v0.1.0 (/home/username/rustProj/hell_cargo)
    Finished dev [unoptimized + debuginfo] target(s) in 0.14s</code></pre> 
<p>        <u>该命令会在 target/debug/hello_cargo 中创建一个可执行文件，而不是在当前目录下</u>。由于默认编译是调试编译，因此 Cargo 会将二进制文件放到名为 debug 的目录中。你可以用这条命令运行可执行文件：</p> 
<pre><code class="language-bash">$ ./target/debug/hell_cargo 
Hello, world!</code></pre> 
<p>        如果一切顺利， Hello, world! 将打印到终端。<u>首次运行 cargo build 还会导致 Cargo 在顶层创建一个新文件：<span style="color:#fe2c24;">Cargo.lock</span></u>。该文件记录了项目中依赖项的确切版本。本项目中没有依赖项，所以文件有点少。<u>你不需要手动修改这个文件，Cargo 会帮你管理它的内容</u>。</p> 
<blockquote> 
 <p># This file is automatically @generated by Cargo.<br> # It is not intended for manual editing.<br> version = 3</p> 
 <p>[[package]]<br> name = "hell_cargo"<br> version = "0.1.0"</p> 
</blockquote> 
<p>        我们刚用 cargo build 构建了一个项目，然后用 ./target/debug/hello_cargo 运行了它，但我们也可以用 <span style="color:#ff9900;"><u>cargo run</u></span> 编译代码，然后在一条命令中运行生成的可执行文件：</p> 
<pre><code class="language-bash">cargo run
   Compiling hell_cargo v0.1.0 (/home/username/rustProj/hell_cargo)
    Finished dev [unoptimized + debuginfo] target(s) in 0.14s
     Running `target/debug/hell_cargo`
Hello, world!</code></pre> 
<p>        使用 cargo run 比记住运行 cargo build 然后使用二进制文件的整个路径更方便，因此大多数开发人员使用 cargo run 。</p> 
<p>        请注意，当我们再次运行 cargo run 时，这次我们没有看到 Cargo 正在编译 hello_cargo 的输出。<u>Cargo 发现文件没有变化，所以没有重建，只是运行了二进制文件</u>。</p> 
<pre><code class="language-bash">cargo run
    Finished dev [unoptimized + debuginfo] target(s) in 0.00s
     Running `target/debug/hell_cargo`
Hello, world!</code></pre> 
<p>        如果你修改了源代码，Cargo 会在运行前重建项目。</p> 
<blockquote> 
 <p>和Makefile功能类似；</p> 
</blockquote> 
<p>        Cargo 还提供了一个名为 cargo check 的命令。该命令可快速检查您的代码，确保其可编译但不会生成可执行文件：</p> 
<pre><code class="language-bash">cargo check
    Checking hell_cargo v0.1.0 (/home/username/rustProj/hell_cargo)
    Finished dev [unoptimized + debuginfo] target(s) in 0.02s</code></pre> 
<p>        为什么不需要可执行文件？通常， cargo check 要比 cargo build 快得多，因为它跳过了生成可执行文件的步骤。如果你在编写代码的过程中不断检查你的工作，那么使用 cargo check 将加快让你知道你的项目是否仍在编译的过程！因此，<u>许多 Rustaceans 在编写程序时都会定期运行 cargo check ，以确保程序编译成功</u>。然后在准备使用可执行文件时运行 cargo build 。</p> 
<h3>3.3 发布release版本</h3> 
<p>        当项目最终准备发布时，可以使用 cargo build --release 对其进行优化编译。该命令将在 target/release 而不是 target/debug 下创建可执行文件。<u>优化会让 Rust 代码运行得更快，但开启优化会延长程序的编译时间</u>。</p> 
<p>        这就是为什么有两种不同的配置文件：一种用于开发，当你想快速、频繁地重建程序时；另一种用于编译最终的程序，你将把它交给用户，它不会被反复重建，而且会尽可能快地运行。</p> 
<p>        <u>如果要对代码运行时间进行基准测试，请确保运行 cargo build --release ，并使用 target/release 中的可执行文件进行基准测试</u>。</p> 
<pre><code class="language-bash">cargo build --release
   Compiling hell_cargo v0.1.0 (/home/username/rustProj/hell_cargo)
    Finished release [optimized] target(s) in 0.14s</code></pre> 
<h2>4. 将Cargo统一作为项目的编译工具</h2> 
<p>        对于简单的项目，Cargo 并不能提供比使用 rustc 更多的价值，但当你的程序变得越来越复杂时，它将证明自己的价值。一旦程序增加到多个文件或需要依赖关系，让 Cargo 来协调构建就容易多了。</p> 
<p>        尽管 hello_cargo 项目很简单，但它使用了你在 Rust 职业生涯中将会用到的许多真正的工具。事实上，要处理任何现有项目，你都可以使用以下命令使用 Git 查看代码，切换到项目目录并构建：</p> 
<pre><code class="language-bash">$ git clone example.org/someproject
$ cd someproject
$ cargo build</code></pre> 
<hr> 
<p>下一篇：<a class="link-info" href="https://blog.csdn.net/eyatal/article/details/135682247" title="02-编程猜谜游戏">02-编程猜谜游戏</a></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/a889630b93faad297ac9273b456ac92b/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">R语言【cli】——ansi_trimws()：从ANSI字符串中删除前导和/或尾随空格</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/21f6db6948e6f3db08e005536bb34ca7/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">51单片机串口通信</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>