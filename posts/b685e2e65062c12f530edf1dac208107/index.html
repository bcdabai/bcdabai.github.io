<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>算法__流水作业调度问题 - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="算法__流水作业调度问题" />
<meta property="og:description" content="1、问题描述： n个作业{1，2，…，n}要在由2台机器M1和M2组成的流水线上完成加工。每个作业加工的顺序都是先在M1上加工，然后在M2上加工。M1和M2加工作业i所需的时间分别为ai和bi。流水作业调度问题要求确定这n个作业的最优加工顺序，使得从第一个作业在机器M1上开始加工，到最后一个作业在机器M2上加工完成所需的时间最少。
2、问题分析
直观上，一个最优调度应使机器M1没有空闲时间，且机器M2的空闲时间最少。在一般情况下，机器M2上会有机器空闲和作业积压2种情况。设全部作业的集合为N={1，2，…，n}。S是N的作业子集。在一般情况下，机器M1开始加工S中作业时，机器M2还在加工其他作业，要等时间t后才可利用。将这种情况下完成S中作业所需的最短时间记为T(S,t)。流水作业调度问题的最优值为T(N,0)。 设π是所给n个流水作业的一个最优调度，它所需的加工时间为 aπ(1)&#43;T’。其中T’是在机器M2的等待时间为bπ(1)时，安排作业π(2)，…，π(n)所需的时间。
记S=N-{π(1)}，则有T’=T(S,bπ(1))。
证明：事实上，由T的定义知T’&gt;=T(S,bπ(1))。若T’&gt;T(S,bπ(1))，设π’是作业集S在机器M2的等待时间为bπ(1)情况下的一个最优调度。则π(1)，π&#39;(2)，…，π&#39;(n)是N的一个调度，且该调度所需的时间为aπ(1)&#43;T(S,bπ(1))&lt;aπ(1)&#43;T’。这与π是N的最优调度矛盾。故T’&lt;=T(S,bπ(1))。从而T’=T(S,bπ(1))。这就证明了流水作业调度问题具有最优子结构的性质。
由流水作业调度问题的最优子结构性质可知:
从公式（1）可以看出，该问题类似一个排列问题，求N个作业的最优调度问题，利用其子结构性质，对集合中的每一个作业进行试调度，在所有的试调度中，取其中加工时间最短的作业做为选择方案。将问题规模缩小。公式（2）说明一般情况下，对作业集S进行调度，在M2机器上的等待时间，除了需要等该部件在M1机器上完成时间，还要冲抵一部分原来的等待时间，如果冲抵已成负值，自然仍需等待M1将作业做完，所以公式取max{t-ai,0}。
3、动态规划法求解思路
假设有一组作业需要在M1和M2 两台机器上进行流水作业，他们在M1和M2上的作业时间如下表：
问题是如何安排他们的加工顺序，使得，到最后一个作业在机器M2上加工完成所需要的时间最少。也就是所有作业在两台机器全部加工完成所需的时间最少。
思路如下：考虑如果只有一个作业的情况，肯定所需时间就是它自身需要在M1和M2 上的加工时间总和；如果有两个作业就要考虑在两种不同的加工顺序下选取最优的一种作为候选，三个作业的时会出现三种组合情况(0,(1,2)); (1,(0,2)); (2,(0,1)),拿第一种为例,它表示先加工作业0,然后再按照作业1和作业2的优化顺序加工;将三种的作业时间计算出来,取最小值,即为三个作业的优化结果,同理可对更多的作业进行排序优化。具体做法是，用类似矩阵连乘的办法，自底向上将所有能的情况计算出来，并产生一个表，供后面的计算查用，减少重复计算的工作量。
对于j1 作业M2 的等待时间为b0,实际上在M2加工j0作业的同时，M1 并行加工j1,实际它需要等待b1-a0时间。
2&#43;4&#43;(5-4)&#43;2=9
从J0和J1两个作业的加工顺序，可以看出，先加工J0后J1，所用时间最短为9，将其填入表中，依此类推，即可得出最优解。
a4&#43;a0&#43;a2&#43;a1&#43;a3&#43;[(b4&#43;b0&#43;b1&#43;b2)-(a0&#43;a1&#43;a2&#43;a3)]&#43;b3
=1&#43;2&#43;3&#43;4&#43;6&#43;[(7&#43;5&#43;2&#43;3)-(2&#43;4&#43;3&#43;6)]&#43;1
=16&#43;[17-15]&#43;1=19
选其中加工时间短的作为候选方案；在具体计算时非最优子集不必考虑，这样可以减少计算次数。
4、流水作业调度的Johnson法则
设兀是作业集S在机器M2的等待时间为t时的任一最优调度。若在这个调度中，安排在最前面的两个作业分别是i 和j ，即π(1)=I,π(2)=j。则有动态规划递归式可得
其中
如果作业i和j满足min{bi,aj} ≥min{bj,ai},则称作业i和j满足Johnson不等式。如果作业i和j 不满足Johnson不等式，则交换作业i和j满足Johnson不等式。
证明 ：在作业集S中，对于机器M2 的等待时间为t的调度π，交换作业i和j 的加工顺序，得到作业集S 的另一个调度π’，它所需的加工时间为
当作业i和j 满足Johnson 不等式 min{bi,aj} ≥min{bj,ai}时，有
从而
由此可得
因此，对任意t 有
从而，tij≤tji,由此可见，换句话说，当作业i 和j不满足Johnson 不等式时，交换它们的加工顺序后，作业i和j满足Johnson 不等式，且不增加加工时间。由此可知，对于流水作业调度问题，必存在最优调度π，使得作业π(i)和π(i&#43;1)满足Johnson 不等式：
这样的调度π称为满足Johnson 法则的调度。进一步还可以证明，调度满足Johnson 法则当且仅当对任意i&lt;j 有：
由此可知，任意两个满足Johnson 法则的调度具有相同的加工时间，从而所有满足Johnson 法则的调度均为最优调度。
5、流水作业调度问题Johnson算法
从上面的分析可知，流水作业调度问题一定存在满足Johnson法则的最优调度，且容易由下面的算法确定：
流水作业调度问题的Johnson算法：
(1)令N1={i|ai&lt;bi},N2={i|ai&gt;=bi};
(2)将N1中作业按ai的非减序排序；将N2中作业按bi的非增序排序；
(3)N1中作业接N2中作业构成满足Johnson法则的最优调度。 Johnson算法中分类及排序的作用（验证不等式）设数组c[]为排序后的作业排列，排序结果如下：" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/b685e2e65062c12f530edf1dac208107/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2020-04-13T20:15:32+08:00" />
<meta property="article:modified_time" content="2020-04-13T20:15:32+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">算法__流水作业调度问题</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-light">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <div id="article_content" class="article_content clearfix"> 
 <div class="htmledit_views" id="content_views"> 
 </div> 
</div> 
<p>     <strong><em>1、问题描述： </em>   </strong></p> 
<p>     n个作业{1，2，…，n}要在由2台机器M1和M2组成的流水线上完成加工。每个作业加工的顺序都是先在M1上加工，然后在M2上加工。M1和M2加工作业i所需的时间分别为ai和bi。<em><strong>流水作业调度问题要求确定这n个作业的最优加工顺序，使得从第一个作业在机器M1上开始加工，到最后一个作业在机器M2上加工完成所需的时间最少</strong></em>。<br>     <strong><em>2、问题分析</em></strong></p> 
<p>     直观上，一个最优调度应使机器M1没有空闲时间，且机器M2的空闲时间最少。在一般情况下，机器M2上会有机器空闲和作业积压2种情况。设全部作业的集合为N={1，2，…，n}。S是N的作业子集。在一般情况下，机器M1开始加工S中作业时，机器M2还在加工其他作业，要等时间t后才可利用。将这种情况下完成S中作业所需的最短时间记为T(S,t)。流水作业调度问题的最优值为T(N,0)。    </p> 
<p>     设<em>π</em>是所给n个流水作业的一个最优调度，它所需的加工时间为 a<em>π(1)</em>+T’。其中T’是在机器M2的等待时间为b<em>π(1)</em>时，安排作业<em>π(2)</em>，…，<em>π(n)</em>所需的时间。</p> 
<p>      记S=N-{<!-- --><em>π(1)</em>}，则有T’=T(S,b<em>π(1)</em>)。</p> 
<p>      证明：事实上，由T的定义知T’&gt;=T(S,b<em>π(1)</em>)。若T’&gt;T(S,b<em>π(1)</em>)，设<em>π</em>’是作业集S在机器M2的等待时间为b<em>π(1)</em>情况下的一个最优调度。则<em>π(1)</em>，<em>π'(2)</em>，…，<em>π'(n)</em>是N的一个调度，且该调度所需的时间为a<em>π(1)</em>+T(S,b<em>π(1)</em>)&lt;a<em>π(1)</em>+T’。这与<em>π</em>是N的最优调度矛盾。故T’&lt;=T(S,b<em>π(1)</em>)。从而T’=T(S,b<em>π(1)</em>)。这就证明了流水作业调度问题具有最优子结构的性质。</p> 
<p>     由流水作业调度问题的最优子结构性质可知:</p> 
<p><img alt="" src="https://images2.imgbox.com/e6/63/Gtk8KUbl_o.jpg">    </p> 
<p>     从公式（1）可以看出，该问题类似一个排列问题，求N个作业的最优调度问题，利用其子结构性质，对集合中的每一个作业进行试调度，在所有的试调度中，取其中加工时间最短的作业做为选择方案。将问题规模缩小。公式（2）说明一般情况下，对作业集S进行调度，在M2机器上的等待时间，除了需要等该部件在M1机器上完成时间，还要冲抵一部分原来的等待时间，如果冲抵已成负值，自然仍需等待M1将作业做完，所以公式取max{t-ai,0}。</p> 
<p>     <strong><em>3、动态规划法求解思路</em></strong></p> 
<p><strong> </strong>    假设有一组作业需要在M1和M2 两台机器上进行流水作业，他们在M1和M2上的作业时间如下表：</p> 
<p align="center"><img alt="" src="https://images2.imgbox.com/c7/4a/f01anpEb_o.jpg"></p> 
<p>     问题是如何安排他们的加工顺序，使得，到最后一个作业在机器M2上加工完成所需要的时间最少。也就是所有作业在两台机器全部加工完成所需的时间最少。<br>     <strong><em>思路如下</em></strong>：考虑如果只有一个作业的情况，肯定所需时间就是它自身需要在M1和M2 上的加工时间总和；如果有两个作业就要考虑在两种不同的加工顺序下选取最优的一种作为候选，三个作业的时会出现三种组合情况(0,(1,2)); (1,(0,2)); (2,(0,1)),拿第一种为例,它表示先加工作业0,然后再按照作业1和作业2的优化顺序加工;将三种的作业时间计算出来,取最小值,即为三个作业的优化结果,同理可对更多的作业进行排序优化。具体做法是，用类似矩阵连乘的办法，自底向上将所有能的情况计算出来，并产生一个表，供后面的计算查用，减少重复计算的工作量。</p> 
<p align="center"><img alt="" src="https://images2.imgbox.com/7a/46/quPPPV1v_o.jpg"></p> 
<p align="left">     对于j1 作业M2 的等待时间为b0,实际上在M2加工j0作业的同时，M1 并行加工j1,实际它需要等待b1-a0时间。</p> 
<p align="left"><img alt="" src="https://images2.imgbox.com/a7/b1/QCuAPYFz_o.png" width="300" height="200"></p> 
<p>      2+4+(5-4)+2=9</p> 
<p align="left">     从J0和J1两个作业的加工顺序，可以看出，先加工J0后J1，所用时间最短为9，将其填入表中，依此类推，即可得出最优解。<br><img alt="" src="https://images2.imgbox.com/0b/41/mGC7xJcv_o.png" width="400" height="300"></p> 
<p>     a4+a0+a2+a1+a3+[(b4+b0+b1+b2)-(a0+a1+a2+a3)]+b3</p> 
<p>     =1+2+3+4+6+[(7+5+2+3)-(2+4+3+6)]+1</p> 
<p>     =16+[17-15]+1=19</p> 
<p>     选其中加工时间短的作为候选方案；在具体计算时非最优子集不必考虑，这样可以减少计算次数。</p> 
<p align="left">     4、流水作业调度的<em><strong>Johnson法则</strong></em></p> 
<p align="left">     设<em>兀</em>是作业集S在机器M2的等待时间为t时的任一最优调度。若在这个调度中，安排在最前面的两个作业分别是i 和j ，即<em>π</em>(1)=I,<em>π</em>(2)=j。则有动态规划递归式可得<br><img alt="" src="https://images2.imgbox.com/a4/f9/ouFjXg31_o.jpg"></p> 
<p align="left">     其中</p> 
<p align="left"><img alt="" src="https://images2.imgbox.com/89/18/N8MD01Mq_o.jpg"><br>      如果作业i和j满足min{bi,aj} ≥min{bj,ai},则称作业i和j满足Johnson不等式。如果作业i和j 不满足Johnson不等式，则交换作业i和j满足Johnson不等式。</p> 
<p align="left">     证明 ：在作业集S中，对于机器M2 的等待时间为t的调度<em>π</em>，交换作业i和j 的加工顺序，得到作业集S 的另一个调度<em>π</em>’，它所需的加工时间为</p> 
<p align="left"><img alt="" src="https://images2.imgbox.com/b3/f2/uiba3cU1_o.jpg"></p> 
<p align="left"><img alt="" src="https://images2.imgbox.com/97/d5/YHkGqgM0_o.jpg"><br>      当作业i和j 满足Johnson 不等式 min{bi,aj} ≥min{bj,ai}时，有</p> 
<p align="left"><img alt="" src="https://images2.imgbox.com/53/bf/pjN85S7q_o.jpg"></p> 
<p align="left">从而</p> 
<p align="left"><img alt="" src="https://images2.imgbox.com/62/92/8TAUwkF6_o.jpg"><br>由此可得</p> 
<p align="left"><img alt="" src="https://images2.imgbox.com/4e/1b/ydBlEJ6Q_o.jpg"><br>因此，对任意t 有</p> 
<p align="left"><img alt="" src="https://images2.imgbox.com/c1/b4/WdCCbwp5_o.jpg"></p> 
<p>从而，tij≤tji,由此可见<img alt="" src="https://images2.imgbox.com/e0/a4/QCWlkDi2_o.jpg">，换句话说，当作业i 和j不满足Johnson 不等式时，交换它们的加工顺序后，作业i和j满足Johnson 不等式，且不增加加工时间。由此可知，对于流水作业调度问题，必存在最优调度π，使得作业π(i)和π(i+1)满足Johnson 不等式：</p> 
<p><img alt="" src="https://images2.imgbox.com/15/00/Nsu39YmT_o.jpg"><br>这样的调度π称为满足Johnson 法则的调度。进一步还可以证明，调度满足Johnson 法则当且仅当对任意i&lt;j 有：</p> 
<p><img alt="" src="https://images2.imgbox.com/f2/c5/qreRXw4l_o.jpg"><br>     由此可知，任意两个满足Johnson 法则的调度具有相同的加工时间，从而所有满足Johnson 法则的调度均为最优调度。</p> 
<p>    5、流水作业调度问题<em><strong>Johnson算法</strong></em></p> 
<p><strong>    </strong>从上面的分析可知，流水作业调度问题一定存在满足Johnson法则的最优调度，且容易由下面的算法确定：</p> 
<p>    流水作业调度问题的Johnson算法：</p> 
<p>    (1)令N1={i|ai&lt;bi},N2={i|ai&gt;=bi};</p> 
<p>    (2)将N1中作业按ai的非减序排序；将N2中作业按bi的非增序排序；</p> 
<p>    (3)N1中作业接N2中作业构成满足Johnson法则的最优调度。   </p> 
<p>    Johnson算法中分类及排序的作用（验证不等式）设数组c[]为排序后的作业排列，排序结果如下：</p> 
<p> <img alt="" src="https://images2.imgbox.com/f2/83/BLmVvtis_o.jpg"></p> 
<p>     红线左侧满足 a[c[i]]&lt;=b[c[i]] 和 a[c[i]]&lt;=a[c[i+1]] 符合johnson 不等式，min(b[c[i]],a[c[i+1]])&gt;=min(b[c[i+1]],a[c[i]])其调度顺序最优；<br>      红线右侧满足 b[c[i]]&lt;=a[c[i]] 和 b[c[i]]&gt;=b[c[i+1]] 符合johnson 不等式，min(b[c[i]],a[c[i+1]])&gt;=min(b[c[i+1]],a[c[i]])其调度顺序最优；</p> 
<p>     中间过渡部分横向比较，左侧a[c[i]]&lt; b[c[i]] 右侧b[c[i+1]]&lt;=a[c[i+1] ]满足min(b[c[i]],a[c[i+1]])&gt;=min(b[c[i+1]],a[c[i]])其调度顺序也最优；</p> 
<p>     程序具体代码如下：<br></p> 
<pre><code class="prism language-cpp"><span class="token comment">//3d9 动态规划 流水作业调度问题</span>
<span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">"stdafx.h"</span></span>
<span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;iostream&gt;</span> </span>
<span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span> 
 
<span class="token keyword">const</span> <span class="token keyword">int</span> N <span class="token operator">=</span> <span class="token number">5</span><span class="token punctuation">;</span>
 
<span class="token keyword">class</span> <span class="token class-name">Jobtype</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token keyword">public</span><span class="token operator">:</span>
		<span class="token keyword">int</span> <span class="token keyword">operator</span> <span class="token operator">&lt;=</span><span class="token punctuation">(</span>Jobtype a<span class="token punctuation">)</span> <span class="token keyword">const</span>
		<span class="token punctuation">{<!-- --></span>
			<span class="token keyword">return</span><span class="token punctuation">(</span>key<span class="token operator">&lt;=</span>a<span class="token punctuation">.</span>key<span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
		<span class="token keyword">int</span> key<span class="token punctuation">,</span>index<span class="token punctuation">;</span>
		<span class="token keyword">bool</span> job<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
 
<span class="token keyword">int</span> <span class="token function">FlowShop</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">,</span><span class="token keyword">int</span> a<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token keyword">int</span> b<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token keyword">int</span> c<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">void</span> <span class="token function">BubbleSort</span><span class="token punctuation">(</span>Jobtype <span class="token operator">*</span>d<span class="token punctuation">,</span><span class="token keyword">int</span> n<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//本例采用冒泡排序</span>
 
<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token keyword">int</span> a<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{<!-- --></span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">6</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
	<span class="token keyword">int</span> b<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{<!-- --></span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">7</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
	<span class="token keyword">int</span> c<span class="token punctuation">[</span>N<span class="token punctuation">]</span><span class="token punctuation">;</span>
 
	<span class="token keyword">int</span> minTime <span class="token operator">=</span>  <span class="token function">FlowShop</span><span class="token punctuation">(</span>N<span class="token punctuation">,</span>a<span class="token punctuation">,</span>b<span class="token punctuation">,</span>c<span class="token punctuation">)</span><span class="token punctuation">;</span>
 
	cout<span class="token operator">&lt;&lt;</span><span class="token string">"作业在机器1上的运行时间为："</span><span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span>
	<span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span> i<span class="token operator">&lt;</span>N<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>
	<span class="token punctuation">{<!-- --></span>
		cout<span class="token operator">&lt;&lt;</span>a<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">&lt;&lt;</span><span class="token string">" "</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
	cout<span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span>
	cout<span class="token operator">&lt;&lt;</span><span class="token string">"作业在机器2上的运行时间为："</span><span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span>
	<span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span> i<span class="token operator">&lt;</span>N<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>
	<span class="token punctuation">{<!-- --></span>
		cout<span class="token operator">&lt;&lt;</span>b<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">&lt;&lt;</span><span class="token string">" "</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
	cout<span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span>
 
	cout<span class="token operator">&lt;&lt;</span><span class="token string">"完成作业的最短时间为："</span><span class="token operator">&lt;&lt;</span>minTime<span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span>
	cout<span class="token operator">&lt;&lt;</span><span class="token string">"编号从0开始，作业调度的顺序为："</span><span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span>
	<span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span> i<span class="token operator">&lt;</span>N<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>
	<span class="token punctuation">{<!-- --></span>
		cout<span class="token operator">&lt;&lt;</span>c<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">&lt;&lt;</span><span class="token string">" "</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
	cout<span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span>
	<span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
 
<span class="token keyword">int</span> <span class="token function">FlowShop</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">,</span><span class="token keyword">int</span> a<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token keyword">int</span> b<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token keyword">int</span> c<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	Jobtype <span class="token operator">*</span>d <span class="token operator">=</span> <span class="token keyword">new</span> Jobtype<span class="token punctuation">[</span>n<span class="token punctuation">]</span><span class="token punctuation">;</span>
	<span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span> i<span class="token operator">&lt;</span>n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>
	<span class="token punctuation">{<!-- --></span>
		d<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>key <span class="token operator">=</span> a<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">&gt;</span>b<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">?</span>b<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">:</span>a<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token comment">//按Johnson法则分别取对应的b[i]或a[i]值作为关键字</span>
		d<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>job <span class="token operator">=</span> a<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">&lt;=</span>b<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token comment">//给符合条件a[i]&lt;b[i]的放入到N1子集标记为true</span>
		d<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>index <span class="token operator">=</span> i<span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
 
	<span class="token function">BubbleSort</span><span class="token punctuation">(</span>d<span class="token punctuation">,</span>n<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//对数组d按关键字升序进行排序</span>
 
	<span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span>k <span class="token operator">=</span> n<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>
 
	<span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span> i<span class="token operator">&lt;</span>n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>
	<span class="token punctuation">{<!-- --></span>
		<span class="token keyword">if</span><span class="token punctuation">(</span>d<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>job<span class="token punctuation">)</span>
		<span class="token punctuation">{<!-- --></span>
			c<span class="token punctuation">[</span>j<span class="token operator">++</span><span class="token punctuation">]</span> <span class="token operator">=</span> d<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>index<span class="token punctuation">;</span><span class="token comment">//将排过序的数组d，取其中作业序号属于N1的从前面进入</span>
		<span class="token punctuation">}</span>
		<span class="token keyword">else</span>
		<span class="token punctuation">{<!-- --></span>
			c<span class="token punctuation">[</span>k<span class="token operator">--</span><span class="token punctuation">]</span> <span class="token operator">=</span> d<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>index<span class="token punctuation">;</span><span class="token comment">//属于N2的从后面进入，从而实现N1的非减序排序，N2的非增序排序</span>
		<span class="token punctuation">}</span>
	<span class="token punctuation">}</span>
 
	j <span class="token operator">=</span> a<span class="token punctuation">[</span>c<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
	k <span class="token operator">=</span> j<span class="token operator">+</span>b<span class="token punctuation">[</span>c<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
	<span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span> i<span class="token operator">&lt;</span>n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>
	<span class="token punctuation">{<!-- --></span>
		j <span class="token operator">+</span><span class="token operator">=</span> a<span class="token punctuation">[</span>c<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token comment">//M1在执行c[i]作业的同时，M2在执行c[i-1]号作业，最短执行时间取决于M1与M2谁后执行完</span>
		k <span class="token operator">=</span> j<span class="token operator">&lt;</span>k<span class="token operator">?</span>k<span class="token operator">+</span>b<span class="token punctuation">[</span>c<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token operator">:</span>j<span class="token operator">+</span>b<span class="token punctuation">[</span>c<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token comment">//计算最优加工时间</span>
	<span class="token punctuation">}</span>
 
	<span class="token keyword">delete</span> d<span class="token punctuation">;</span>
	<span class="token keyword">return</span> k<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
 
<span class="token comment">//冒泡排序</span>
<span class="token keyword">void</span> <span class="token function">BubbleSort</span><span class="token punctuation">(</span>Jobtype <span class="token operator">*</span>d<span class="token punctuation">,</span><span class="token keyword">int</span> n<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token keyword">int</span> i<span class="token punctuation">,</span>j<span class="token punctuation">,</span>flag<span class="token punctuation">;</span> 
	Jobtype temp<span class="token punctuation">;</span>
 
	<span class="token keyword">for</span><span class="token punctuation">(</span>i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>n<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>  
		flag <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>  
		<span class="token keyword">for</span><span class="token punctuation">(</span>j<span class="token operator">=</span>n<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>j<span class="token operator">&gt;</span>i<span class="token punctuation">;</span>j<span class="token operator">--</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>  
			<span class="token comment">//如果前一个数大于后一个数，则交换  </span>
			<span class="token keyword">if</span><span class="token punctuation">(</span>d<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">&lt;=</span>d<span class="token punctuation">[</span>j<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>  
				temp <span class="token operator">=</span> d<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>  
				d<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> d<span class="token punctuation">[</span>j<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>  
				d<span class="token punctuation">[</span>j<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> temp<span class="token punctuation">;</span>  
				flag <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>  
			<span class="token punctuation">}</span>  
		<span class="token punctuation">}</span>  
		<span class="token comment">//如果本次排序没有进行一次交换，则break，减少了执行之间。  </span>
		<span class="token keyword">if</span><span class="token punctuation">(</span>flag <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>  
			<span class="token keyword">break</span><span class="token punctuation">;</span>  
		<span class="token punctuation">}</span>  
	<span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>运行结果如下：<br> <img src="https://images2.imgbox.com/df/e0/L4eiQl29_o.png" alt="在这里插入图片描述"></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/0ec9df141b9168ce64afee4a127ec046/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">ubuntu18.04 设置状态栏时间显示</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/9f723ab44a70cf952f8efbbbaaf41c42/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">脉冲触发器(JK触发器)</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>