<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>图的MST（最小生成树算法）Kruskral&#43;Prim - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="图的MST（最小生成树算法）Kruskral&#43;Prim" />
<meta property="og:description" content="##前言
文章记录数据结构中求最小生成树的两种经典算法：Kruskal和Prim算法。
##Kruskal算法
算法的实现步骤：
个人理解:
将图中所有的带权边按照权值大小（从小到大的次序）依次排序；形如&lt;2,5&gt;:3；&lt;2,3&gt;:4等，表示结点2到结点5能够连通，路径长度为3。从上按照从小到大的‘顶点边权列表’中依次选择边权值最小且不构成环路的这些边形成最小生成树。 老师给的步骤：
将所有的边按权值排序；设每个顶点为一个独立的点集，生成树T为空集；依序扫描每一条边，直到已输出n-1条边： 若vi、vj均不在同一点集中，则将该边加入生成树T中，并合并这两个点集；否则舍弃该边； 图示辅助理解：
算法的代码实现：
#include&lt;iostream&gt; #include&lt;algorithm&gt; #define maxv 101 #define maxe 100 using namespace std; int r[maxe]; int p[maxv]; int u[maxv],v[maxv],w[maxv]; int n,m; int cmp(const int i,const int j) { return w[i]&lt;w[j]; } int find(int x) { return p[x]==x?x:p[x]=find(p[x]); } int Kruskal(int u[maxv],int v[maxv],int w[maxv],int n,int m) { int ans=0; //循环设置每一个顶点序号 for(int i=0;i&lt;n;i&#43;&#43;) p[i]=i; for(int i=0;i&lt;m;i&#43;&#43;) r[i]=i;	sort(r,r&#43;m,cmp); /* cmp 为sort函数中的排序规则 其中的常量 i j 表示待排序中的两个变量 return 后的内容表示排序的规则 w[i]&lt;w[j] 按照 w 权值的大小进行排序 比较结果为真返回 1 否则返回 0 */ //排序后 边权 //for(int i=0;i&lt;m;i&#43;&#43;) //	cout&lt;&lt;&#34;" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/4c593f0da46b8de9813986474d9ea45c/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2018-05-03T19:04:27+08:00" />
<meta property="article:modified_time" content="2018-05-03T19:04:27+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">图的MST（最小生成树算法）Kruskral&#43;Prim</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-light">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p>##前言</p> 
<hr> 
<blockquote> 
 <p>文章记录数据结构中求最小生成树的两种经典算法：Kruskal和Prim算法。</p> 
</blockquote> 
<p>##Kruskal算法</p> 
<hr> 
<p><strong>算法的实现步骤：</strong></p> 
<blockquote> 
 <p>个人理解:</p> 
</blockquote> 
<ol><li>将图中所有的带权边按照权值大小（从小到大的次序）依次排序；形如&lt;2,5&gt;:3；&lt;2,3&gt;:4等，表示结点2到结点5能够连通，路径长度为3。</li><li>从上按照从小到大的‘顶点边权列表’中依次选择边权值最小且不构成环路的这些边形成最小生成树。</li></ol> 
<blockquote> 
 <p>老师给的步骤：</p> 
</blockquote> 
<ol><li>将所有的边按权值排序；</li><li>设每个顶点为一个独立的点集，生成树T为空集；</li><li>依序扫描每一条边，直到已输出n-1条边： 若vi、vj均不在同一点集中，则将该边加入生成树T中，并合并这两个点集；否则舍弃该边；</li></ol> 
<blockquote> 
 <p>图示辅助理解：<br> <img src="https://images2.imgbox.com/7f/b6/aNrucmUc_o.png" alt="这里写图片描述"></p> 
</blockquote> 
<p><strong>算法的代码实现：</strong></p> 
<pre><code class="prism language-cpp"><span class="token macro property">#<span class="token directive keyword">include</span><span class="token string">&lt;iostream&gt;</span></span>
<span class="token macro property">#<span class="token directive keyword">include</span><span class="token string">&lt;algorithm&gt;</span></span>
<span class="token macro property">#<span class="token directive keyword">define</span> maxv 101</span>
<span class="token macro property">#<span class="token directive keyword">define</span> maxe 100</span>
<span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span>
<span class="token keyword">int</span> r<span class="token punctuation">[</span>maxe<span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token keyword">int</span> p<span class="token punctuation">[</span>maxv<span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token keyword">int</span> u<span class="token punctuation">[</span>maxv<span class="token punctuation">]</span><span class="token punctuation">,</span>v<span class="token punctuation">[</span>maxv<span class="token punctuation">]</span><span class="token punctuation">,</span>w<span class="token punctuation">[</span>maxv<span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token keyword">int</span> n<span class="token punctuation">,</span>m<span class="token punctuation">;</span>
<span class="token keyword">int</span> <span class="token function">cmp</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">int</span> i<span class="token punctuation">,</span><span class="token keyword">const</span> <span class="token keyword">int</span> j<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token keyword">return</span> w<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">&lt;</span>w<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">int</span> <span class="token function">find</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token keyword">return</span> p<span class="token punctuation">[</span>x<span class="token punctuation">]</span><span class="token operator">==</span>x<span class="token operator">?</span>x<span class="token operator">:</span>p<span class="token punctuation">[</span>x<span class="token punctuation">]</span><span class="token operator">=</span><span class="token function">find</span><span class="token punctuation">(</span>p<span class="token punctuation">[</span>x<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">int</span> <span class="token function">Kruskal</span><span class="token punctuation">(</span><span class="token keyword">int</span> u<span class="token punctuation">[</span>maxv<span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token keyword">int</span> v<span class="token punctuation">[</span>maxv<span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token keyword">int</span> w<span class="token punctuation">[</span>maxv<span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token keyword">int</span> n<span class="token punctuation">,</span><span class="token keyword">int</span> m<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token keyword">int</span> ans<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>
	<span class="token comment">//循环设置每一个顶点序号 </span>
	<span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>n<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span>
		p<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">=</span>i<span class="token punctuation">;</span>
	<span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>m<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span>
		r<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">=</span>i<span class="token punctuation">;</span>	
	<span class="token function">sort</span><span class="token punctuation">(</span>r<span class="token punctuation">,</span>r<span class="token operator">+</span>m<span class="token punctuation">,</span>cmp<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token comment">/*
	cmp 为sort函数中的排序规则
	其中的常量 i j 表示待排序中的两个变量
	return 后的内容表示排序的规则
	w[i]&lt;w[j] 按照 w 权值的大小进行排序
	比较结果为真返回 1 否则返回 0 
	*/</span>
	<span class="token comment">//排序后 边权 </span>
	<span class="token comment">//for(int i=0;i&lt;m;i++)</span>
	<span class="token comment">//	cout&lt;&lt;"第"&lt;&lt;r[i]&lt;&lt;"条边的权值为："&lt;&lt;w[r[i]]&lt;&lt;" "&lt;&lt;endl;</span>
	<span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>m<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span>
	<span class="token punctuation">{<!-- --></span>
		<span class="token keyword">int</span> e<span class="token operator">=</span>r<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>
		<span class="token comment">//x y 分别定义为  e 这条边的起点和终点</span>
		<span class="token comment">//利用递归来判定该边能达到联通终点是否与起点有环 </span>
		<span class="token keyword">int</span> x<span class="token operator">=</span><span class="token function">find</span><span class="token punctuation">(</span>u<span class="token punctuation">[</span>e<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token keyword">int</span> y<span class="token operator">=</span><span class="token function">find</span><span class="token punctuation">(</span>v<span class="token punctuation">[</span>e<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token keyword">if</span><span class="token punctuation">(</span>x<span class="token operator">!=</span>y<span class="token punctuation">)</span>
		<span class="token punctuation">{<!-- --></span>
			ans<span class="token operator">+</span><span class="token operator">=</span>w<span class="token punctuation">[</span>e<span class="token punctuation">]</span><span class="token punctuation">;</span>
			cout<span class="token operator">&lt;&lt;</span><span class="token string">"第"</span><span class="token operator">&lt;&lt;</span>e<span class="token operator">&lt;&lt;</span><span class="token string">"条边：权值为："</span><span class="token operator">&lt;&lt;</span>w<span class="token punctuation">[</span>e<span class="token punctuation">]</span><span class="token operator">&lt;&lt;</span><span class="token string">"; 从"</span> <span class="token operator">&lt;&lt;</span>u<span class="token punctuation">[</span>e<span class="token punctuation">]</span><span class="token operator">&lt;&lt;</span><span class="token string">"该起点到"</span><span class="token operator">&lt;&lt;</span>v<span class="token punctuation">[</span>e<span class="token punctuation">]</span><span class="token operator">&lt;&lt;</span><span class="token string">"该终点"</span><span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span> 
			p<span class="token punctuation">[</span>x<span class="token punctuation">]</span><span class="token operator">=</span>y<span class="token punctuation">;</span> 
		<span class="token punctuation">}</span>
	<span class="token punctuation">}</span>
	<span class="token keyword">return</span> ans<span class="token punctuation">;</span> 
<span class="token punctuation">}</span>
<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token keyword">int</span> n<span class="token punctuation">,</span>m<span class="token punctuation">,</span>ans<span class="token punctuation">;</span>
	<span class="token keyword">while</span><span class="token punctuation">(</span>cin<span class="token operator">&gt;&gt;</span>n<span class="token operator">&gt;&gt;</span>m<span class="token punctuation">)</span>
	<span class="token punctuation">{<!-- --></span>
		<span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>m<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span>
			cin<span class="token operator">&gt;&gt;</span>u<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">&gt;&gt;</span>v<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">&gt;&gt;</span>w<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>
		ans<span class="token operator">=</span><span class="token function">Kruskal</span><span class="token punctuation">(</span>u<span class="token punctuation">,</span>v<span class="token punctuation">,</span>w<span class="token punctuation">,</span>n<span class="token punctuation">,</span>m<span class="token punctuation">)</span><span class="token punctuation">;</span>
		cout<span class="token operator">&lt;&lt;</span><span class="token string">"最小生成树权值最小是："</span><span class="token operator">&lt;&lt;</span>ans<span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
	<span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token comment">/*测试数据
7 12
2 5 3
2 3 4
3 5 5
1 4 7
0 2 9
0 3 10
1 6 12
5 6 32
3 6 23
0 1 22
4 6 20
1 3 15
*/</span> 
</code></pre> 
<p>运行截图：</p> 
<p><img src="https://images2.imgbox.com/c3/8e/TioXdYIj_o.png" alt="这里写图片描述"></p> 
<p>##Prim算法</p> 
<hr> 
<p><strong>算法的实现步骤：</strong></p> 
<ol><li>E1：任取一个顶点构成U={v0}；构造向量cost[0…n-1]和adj[0…n-1]，cost[i]表示顶点vi到U的最短边的长度，adj[i]表示顶点vi到U的最短边在U中的邻接点的下标；其中，vi∈V-U。初始时，生成树T为空集。</li><li>E2：重复n-1次</li><li>E21：从V-U中选出cost值最小的顶点vk，将边（vk, vadj[k]）加入到生成树T中，然后将vk并入U中；</li><li>E22：修正V-U中各顶点的cost值和adj值；</li></ol> 
<blockquote> 
 <p>图示辅助理解<br> <img src="https://images2.imgbox.com/c4/f1/XX5GKwkK_o.png" alt="这里写图片描述"></p> 
</blockquote> 
<p><strong>算法的代码实现：</strong></p> 
<pre><code class="prism language-cpp"><span class="token macro property">#<span class="token directive keyword">include</span><span class="token string">&lt;iostream&gt;</span></span>
<span class="token macro property">#<span class="token directive keyword">define</span> maxv 101</span>
<span class="token macro property">#<span class="token directive keyword">define</span> maxe 100</span>
<span class="token macro property">#<span class="token directive keyword">define</span> INF 1000000</span>
<span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span>
<span class="token keyword">void</span> <span class="token function">Prim</span><span class="token punctuation">(</span><span class="token keyword">int</span> n <span class="token punctuation">,</span><span class="token keyword">int</span> arc<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">101</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token comment">//定义 ans 为最小生成树最小权值 </span>
	<span class="token keyword">int</span> cost<span class="token punctuation">[</span>maxv<span class="token punctuation">]</span><span class="token punctuation">,</span>closet<span class="token punctuation">[</span>maxv<span class="token punctuation">]</span><span class="token punctuation">,</span>ans<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>
	closet<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span><span class="token comment">//从 V-U 到 U 连接最短边对应的邻接点序号 </span>
	cost<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span><span class="token comment">//将 0元素加入到 U集合中 设置标志数组 </span>
	<span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>n<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span>
	<span class="token punctuation">{<!-- --></span>
		<span class="token comment">//初始仅有 0 加入 U cost和closet依次初始化 </span>
		cost<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">=</span>arc<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>
		closet<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
	<span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>n<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span>
	<span class="token punctuation">{<!-- --></span>
		<span class="token comment">//从V-U中取出一个元素加入到 U中 共执行 n-1次 </span>
		<span class="token keyword">int</span> min<span class="token operator">=</span>INF<span class="token punctuation">,</span>k<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>
		<span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> j<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>j<span class="token operator">&lt;</span>n<span class="token punctuation">;</span>j<span class="token operator">++</span><span class="token punctuation">)</span>
		<span class="token punctuation">{<!-- --></span>
			<span class="token comment">//if条件为判定该结点是否在 U中 且是否为连接 U的权值最小 </span>
			<span class="token keyword">if</span><span class="token punctuation">(</span>cost<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">&amp;&amp;</span>cost<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">&lt;</span>min<span class="token punctuation">)</span>
			<span class="token punctuation">{<!-- --></span>
				min<span class="token operator">=</span>cost<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token comment">//更新最小值 </span>
				k<span class="token operator">=</span>j<span class="token punctuation">;</span><span class="token comment">//记录连接 U和 V-U的接点</span>
			<span class="token punctuation">}</span>
		<span class="token punctuation">}</span>
		<span class="token comment">//更新 MST权值和 </span>
		ans<span class="token operator">+</span><span class="token operator">=</span>min<span class="token punctuation">;</span>
		<span class="token comment">//将该点加入U集合中 </span>
		cost<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>
		<span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> j<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>j<span class="token operator">&lt;</span>n<span class="token punctuation">;</span>j<span class="token operator">++</span><span class="token punctuation">)</span>
		<span class="token punctuation">{<!-- --></span>
			<span class="token comment">//更新cost 和closet值 </span>
			<span class="token keyword">if</span><span class="token punctuation">(</span>cost<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">&amp;&amp;</span>cost<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">&gt;</span>arc<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span>
			<span class="token punctuation">{<!-- --></span>
				cost<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">=</span>arc<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>
				closet<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">=</span>k<span class="token punctuation">;</span>
			<span class="token punctuation">}</span>
		<span class="token punctuation">}</span>
	<span class="token punctuation">}</span>
	<span class="token comment">//输出 最小生成树 权值最小的值 </span>
	cout<span class="token operator">&lt;&lt;</span>ans<span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token keyword">int</span> n<span class="token punctuation">,</span>arc<span class="token punctuation">[</span>maxv<span class="token punctuation">]</span><span class="token punctuation">[</span>maxv<span class="token punctuation">]</span><span class="token punctuation">;</span>
	cin<span class="token operator">&gt;&gt;</span>n<span class="token punctuation">;</span>
	<span class="token comment">//输入图邻接矩阵 </span>
	<span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>n<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span>
		<span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> j<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>j<span class="token operator">&lt;</span>n<span class="token punctuation">;</span>j<span class="token operator">++</span><span class="token punctuation">)</span>
			cin<span class="token operator">&gt;&gt;</span>arc<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>
	<span class="token comment">//调用Prim算法 </span>
	<span class="token function">Prim</span><span class="token punctuation">(</span>n<span class="token punctuation">,</span>arc<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>##Prim和Kruskal算法的区别和联系</p> 
<hr> 
<blockquote> 
 <p>Prim算法是加入一个顶点到集合U中比较与U中的点相连结点的边的长度，适合用于稠密图即顶点边比较多的情况。<br> Kruskla算法是将所有的边权和顶点依次罗列排序，进行依次比较，得出最小生成树，比较适合于稀疏图即顶点边比较少的情况。<br> Prim算法和Kruskal算法均属于贪心算法。贪心算法一般上是在当前情况下求取最优解，可能无法得出‘全局最优解’，会陷入‘局部最优解’的可能。但对于最小生成树来说，Prim和Kruskal算法均得到是最优解。有具体的数学论证。<br> Prim的算法效率E+VlogV，Kruskal的算法效率ElogE。</p> 
</blockquote>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/01d8b009665f22102cbca861475abcc4/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">条件变量(Condition Variable)详解</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/4227d966060842c6ce51b1c0f0254bba/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">关于vs2017中无法下载win10SDK</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>