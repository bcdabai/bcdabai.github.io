<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>秋招面试知识点----框架篇 - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="秋招面试知识点----框架篇" />
<meta property="og:description" content="IoC 控制反转IoC(Inversion of Control)，是一种设计思想，DI(依赖注入)是实现IoC的一种方法，也有人认为DI只是IoC的另一种说法。没有IoC的程序中 , 我们使用面向对象编程 , 对象的创建与对象间的依赖关系完全硬编码在程序中，就是new 对象，对象的创建由程序自己控制，直接写死的，但是这样的话框架的开发者不知道我们写的类名，没法写死在程序，所以就反射进行创建，放到bean工厂里面，就是ioc容器，用的时候就是@autowore，resoruse使用，默认是单例，个人认为所谓控制反转就是：获得依赖对象的方式反转了
就是为了解耦，减少对象之间的联系
依赖注入
：注入！(配置文件，注解)
依赖：bean对象的创建依赖于容器注入：bean对象的所有属性，由有容器注入 ioc业务层就是父容器，向ioc表现层子容器注入
要求被注入的属性 , 必须有set方法 ,
bean周期 1.扫描xml创建容器，根据bean的名字（注解名字首字母小写）和calss解析出全限定类名，反射newInstence获取实例，默认是单例2，DI注入属性或是其他bean的引用，就像service曾调用doa层的方法，引入dao的bean，就是配置的value3.在初始化前aop思想加入后置处理器，在初始刷前后分别进行操作，浙江继承了泛型的类，就是工厂模式这是需要加入ioc的，所有bean都会执行4.进行初始化，这函数在xml中，配置initMathod5.使用bean，初始化成了就能用了6.销毁，就是容器applicationContext或是BeanFactory销毁，就是也要配置销毁方法 aop 就是在不改变代码基础上，增强方法，比如日志，
使用注解实现
@Aspect加在类上配置文件配置可用注解方法加@Before，@After jdk，cglib
jdk就是实现 InvocationHandler 接口，用反射直接拿到反射机制获得动态代理类的构造函数，必须要有接口
为配置文件中所有的bean创建对象，都那个配置
cglib就是基于类的继承机制，对代理对象类的class文件加载，通过修改其字节码生成子类来处理。
jdk都有，就是默认java，没借口的话就是cglib，可以强制设制。
切面类：就是要执行的增强的方法所在的类，比如咱们例子里的MyTransaction类通知（执行方法）：切面类里的方法目标方法：要执行的目标方法织入：把通知和目标方法进行结合，形成代理对象的过程就叫织入 springAOP的具体加载步骤：
1、当spring容器启动的时候，加载了spring的配置文件
2、为配置文件中所有的bean创建对象
3、spring容器在创建对象的时候它会解析aop:config的配置
解析切入点表达式，用切入点表达式和纳入spring容器中的bean做匹配
如果匹配成功，则会为该bean创建代理对象，代理对象的方法=目标方法&#43;通知
如果匹配不成功，则为该bean创建正常的对象
其实就是你通过表达式告诉Spring哪些bean需要它帮你生成代理对象而不是生成原有的正常对象
理解这一点相当重要！
4、在客户端利用context.getBean获取对象时，如果该对象有代理对象则返回代理对象，如果没有代理对象，则返回目标对象
说明：如果目标类没有实现接口，spring容器会采用cglib的方式产生代理对象，如果实现了接口，则会采用jdk的动态代理产生代理对象
Springmvc流程 首先在web.xml中进行注册，实质上注册的时启动类。 springBoot在内置tomcat中默认的加入了这些配置。springBoot表面上不用注册，实质上内部已经完成了注册。
在tomcat启动之后，tomcat会通过dom操作读取xml配置文件，我在阅读源码时发现这个dom操作和HTML的dom操作基本相似。通过dom操作获取框架启动类的路径。通过反射拿到启动类的实例，然后通过代理调用主方法，由此触发框架自定义类的启动。当自定义类启动之后，会扫描根目录下的子文件，把java文件都会筛选出来，筛选之后通过路径进行反射，反射之后通过反射信息看哪些带有自定义的@controller注解。把这些带有注解的类挑选出来之后，再去挑选带有注解的方法。把带有@requestmapping的方法挑选出来。挑选出来之后挑选出来注解里面的路径值。把路径值作为Key，方法的实例作为value存到HashMap中。（启动完毕）
**等待前端请求。**当前端发送请求到端口之后，tomcat会把数据从端口中拿过来。Tomcat把数据拿过来之后，会把他封装成Httpresqest和httpresponse。然后把它交到DispatcherServlet（它就是普通的servlet）里面，（springmvc/boot里面有封装的servlet作为沟通）。当DispatcherServlet接收到这两个参数之后，会httpresquest里面读取url路径，{url组成：ip/域名&#43;端口号&#43;项目路径&#43;内部路径（静态资源路径/controller里定义的路径）}。在DispatcherServlet会把内部路径提取出来，这个内部路径就是controller里面resquesemapping里的路径，当拿到这个路径之后会从HashMap里匹配，拿到对应的方法实例，用java的代理去执行，就是invoke方法。invoke有三个参数（要执行的方法所属的对象实例，方法实例，入参（通过httpresquest里获得））。执行完invoke表明整个调用结束，然后可以给前端返回值。
tomcat流程 原来是servlet&#43;tomact，当时就觉得tomcat很神秘，想了解一下她的实现，喂什么要配合才能使用，为的是可以解析servlet，静态的界面浏览器就能搞定。dopost，doget，就是前台的不同请求，url，form表单提交，默认get。servlet没有主方法，tomcat 就是完全由java写的，这是合成的项目，不象springboot内置tomcat。
tomcat分成了两个阶段，分别是启动阶段和接收转发阶段。
启动阶段：
他会扫描webapp所有的子目录和文件，然后把目录下的.class跳出来，拿到Java全限定类名，用class.formname去获取class信息，遍历每一个类的信息，然后去类里面查@WebServlet注解，生new Instence（），就是tomcat的开发者不知道我们写的servlet的名字和包，又要所有开发者能用，就是反射，只要拿到全限定类名就能生成实例，属性，方法都可以用，就是privite要设置通行，用diclare获取。然后就是拿到实例的method，就是doget，还拿到了注解的路径值，key是路径，势力是value放到map
请求转发：
tomcat收到请求，监听socket端口，用的是natty的socket，借助natty拿到http请求后就会放到线程池中，避免同时来1很多请求撑爆内存，最好不用excuter，会导致请求拥塞，那麽就去自己建线程池七大参数，四种拒绝策略。
线程就开始把传过来http数据封装成httprequest，httpresponse，就是doget有的形参类型。url会被提取出来，IP：端口号：项目名，剩下的就是serverlet的地址，就是localhost：8080/login，或是前台资源就是去相应的目录下找资源，serverlet的话，就是前面注解map匹配对应的servlet实例和 method，invoke函数调用doget。
springboot流程 分为两步，创建application对象，执行run方法
原来的话，启动类就是两句话，new个对象，调run，现在成了静态方法，Springapplication。run（），内部就是new对象，点run（）
1.创建对象
就是一个构造，里面实现的是加载类路径下的上下文context的初始化，还有就是监听器的初始化
2.调那个run方法
有个监听器的start（），开始坚挺启动
再就是trycatch包着的加载springboot配置环境，放到监听器对象中
配置上下文创建，就是实例化上下文对象，就是像spring的context，创建bean工厂，读配置文件
把这监听器，上下文配置起来" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/c08d7c389b373bdfb6c582326c2e47af/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2020-12-10T22:44:35+08:00" />
<meta property="article:modified_time" content="2020-12-10T22:44:35+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">秋招面试知识点----框架篇</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <h2><a id="IoC_0"></a>IoC</h2> 
<p><strong>控制反转IoC(Inversion of Control)，是一种设计思想，DI(依赖注入)是实现IoC的一种方法</strong>，也有人认为DI只是IoC的另一种说法。没有IoC的程序中 , 我们使用面向对象编程 , 对象的创建与对象间的依赖关系完全<strong>硬编码在程序</strong>中，就是new 对象，<strong>对象的创建由程序自己控制</strong>，直接写死的，但是这样的话框架的开发者不知道我们写的类名，没法写死在程序，所以就反射进行创建，放到bean工厂里面，就是ioc容器，用的时候就是@autowore，resoruse使用，默认是单例，个人认为所谓控制反转就是：<strong>获得依赖对象的方式反转了</strong></p> 
<ul><li> <p><strong>就是为了解耦，减少对象之间的联系</strong></p> </li><li> <p>依赖注入</p> <p>：注入！(配置文件，注解)</p> 
  <ul><li><strong>依赖</strong>：<strong>bean对象</strong>的创建依赖于<strong>容器</strong></li><li><strong>注入</strong>：<strong>bean对象的所有属性</strong>，由有容器注入</li></ul> </li><li> <p><strong>ioc业务层</strong>就是父容器，向i<strong>oc表现层</strong>子容器注入</p> </li></ul> 
<p><strong>要求被注入的属性 , 必须有set方法 ,</strong></p> 
<h2><a id="bean_17"></a>bean周期</h2> 
<ul><li>1.<strong>扫描xml创建容器</strong>，根据bean的名字（注解名字首字母小写）和calss解析出全限定类名，反射newInstence获取实例，默认是单例</li><li>2，<strong>DI注入属性或是其他bean的引用</strong>，就像service曾调用doa层的方法，引入dao的bean，就是配置的value</li><li>3.<strong>在初始化前aop思想加入后置处理器</strong>，在初始刷前后分别进行操作，浙江继承了泛型的类，就是工厂模式这是需要加入ioc的，所有bean都会执行</li><li>4.<strong>进行初始化</strong>，这函数在xml中，配置initMathod</li><li>5.<strong>使用bean</strong>，初始化成了就能用了</li><li>6.<strong>销毁</strong>，就是容器applicationContext或是BeanFactory销毁，就是也要配置销毁方法</li></ul> 
<h2><a id="aop_26"></a>aop</h2> 
<p>就是在不改变代码基础上，增强方法，比如日志，</p> 
<p><strong>使用注解实现</strong></p> 
<ul><li><strong>@Aspect</strong>加在类上</li><li>配置文件配置可用注解</li><li><strong>方法加@Before，@After</strong></li></ul> 
<p><strong>jdk，cglib</strong></p> 
<p>jdk就是实现 InvocationHandler 接口，用反射直接拿到反射机制获得动态代理类的构造函数，必须要有接口</p> 
<p>为配置文件中所有的bean创建对象，都那个配置</p> 
<p>cglib就是基于类的继承机制，对代理对象类的class文件加载，通过修改其字节码生成子类来处理。</p> 
<p>jdk都有，就是默认java，没借口的话就是cglib，可以强制设制。</p> 
<ul><li><strong>切面类</strong>：就是<strong>要执行的增强的方法所在的类</strong>，比如咱们例子里的MyTransaction类</li><li><strong>通知（执行方法）</strong>：<strong>切面类里的方法</strong></li><li><strong>目标方法</strong>：要执行的目标方法</li><li><strong>织入</strong>：把通知和目标方法进行结合，形成代理对象的过程就叫织入</li></ul> 
<p><strong>springAOP的具体加载步骤：</strong><br> 1、当spring容器启动的时候，加载了spring的配置文件<br> 2、为配置文件中所有的bean创建对象<br> 3、spring容器在创建对象的时候它会解析aop:config的配置<br> 解析切入点表达式，用切入点表达式和纳入spring容器中的bean做匹配<br> 如果匹配成功，则会为该bean创建代理对象，<strong>代理对象的方法=目标方法+通知</strong><br> 如果匹配不成功，则为该bean创建正常的对象<br> 其实就是你通过表达式告诉Spring哪些bean需要它帮你生成代理对象而不是生成原有的正常对象<br> 理解这一点相当重要！<br> 4、在客户端利用context.getBean获取对象时，如果该对象有代理对象则返回代理对象，如果没有代理对象，则返回目标对象</p> 
<p>说明：如果目标类没有实现接口，spring容器会采用cglib的方式产生代理对象，如果实现了接口，则会采用jdk的动态代理产生代理对象</p> 
<h2><a id="Springmvc_64"></a>Springmvc流程</h2> 
<p>首先在web.xml中进行注册，实质上注册的时启动类。 springBoot在内置tomcat中默认的加入了这些配置。springBoot表面上不用注册，实质上内部已经完成了注册。<br> 在tomcat启动之后，tomcat会通过dom操作读取xml配置文件，我在阅读源码时发现这个dom操作和HTML的dom操作基本相似。通过dom操作获取框架启动类的路径。通过反射拿到启动类的实例，然后通过代理调用主方法，由此触发框架自定义类的启动。当自定义类启动之后，会扫描根目录下的子文件，把java文件都会筛选出来，筛选之后通过路径进行反射，反射之后通过反射信息看哪些带有自定义的@controller注解。把这些带有注解的类挑选出来之后，再去挑选带有注解的方法。把带有@requestmapping的方法挑选出来。挑选出来之后挑选出来注解里面的路径值。把路径值作为Key，方法的实例作为value存到HashMap中。（启动完毕）</p> 
<p>**等待前端请求。**当前端发送请求到端口之后，tomcat会把数据从端口中拿过来。Tomcat把数据拿过来之后，会把他封装成Httpresqest和httpresponse。然后把它交到DispatcherServlet（它就是普通的servlet）里面，（springmvc/boot里面有封装的servlet作为沟通）。当DispatcherServlet接收到这两个参数之后，会httpresquest里面读取url路径，{url组成：ip/域名+端口号+项目路径+内部路径（静态资源路径/controller里定义的路径）}。在DispatcherServlet会把内部路径提取出来，这个内部路径就是controller里面resquesemapping里的路径，当拿到这个路径之后会从HashMap里匹配，拿到对应的方法实例，用java的代理去执行，就是invoke方法。invoke有三个参数（要执行的方法所属的对象实例，方法实例，入参（通过httpresquest里获得））。执行完invoke表明整个调用结束，然后可以给前端返回值。</p> 
<h2><a id="tomcat_71"></a>tomcat流程</h2> 
<p>原来是servlet+tomact，当时就觉得tomcat很神秘，想了解一下她的实现，喂什么要配合才能使用，为的是可以解析servlet，静态的界面浏览器就能搞定。dopost，doget，就是前台的不同请求，url，form表单提交，默认get。servlet没有主方法，tomcat 就是完全由java写的，这是合成的项目，不象springboot内置tomcat。<br> tomcat分成了两个阶段，分别是启动阶段和接收转发阶段。<br> <strong>启动阶段：</strong><br> 他会扫描webapp所有的子目录和文件，然后把目录下的.class跳出来，拿到Java全限定类名，用class.formname去获取class信息，遍历每一个类的信息，然后去类里面查@WebServlet注解，生new Instence（），就是tomcat的开发者不知道我们写的servlet的名字和包，又要所有开发者能用，就是反射，只要拿到全限定类名就能生成实例，属性，方法都可以用，就是privite要设置通行，用diclare获取。然后就是拿到实例的method，就是doget，还拿到了注解的路径值，key是路径，势力是value放到map<br> <strong>请求转发：</strong><br> tomcat收到请求，监听socket端口，用的是natty的socket，借助natty拿到http请求后就会放到线程池中，避免同时来1很多请求撑爆内存，最好不用excuter，会导致请求拥塞，那麽就去自己建线程池七大参数，四种拒绝策略。<br> 线程就开始把传过来http数据封装成httprequest，httpresponse，就是doget有的形参类型。url会被提取出来，IP：端口号：项目名，剩下的就是serverlet的地址，就是localhost：8080/login，或是前台资源就是去相应的目录下找资源，serverlet的话，就是前面注解map匹配对应的servlet实例和 method，invoke函数调用doget。</p> 
<h2><a id="springboot_83"></a>springboot流程</h2> 
<p>分为两步，创建application对象，执行run方法</p> 
<p>原来的话，启动类就是两句话，new个对象，调run，现在成了静态方法，Springapplication。run（），内部就是new对象，点run（）</p> 
<p>1.创建对象</p> 
<p>就是一个构造，里面实现的是加载类路径下的上下文context的初始化，还有就是监听器的初始化</p> 
<p>2.调那个run方法</p> 
<p>有个监听器的start（），开始坚挺启动</p> 
<p>再就是trycatch包着的加载springboot配置环境，放到监听器对象中</p> 
<p>配置上下文创建，就是实例化上下文对象，就是像spring的context，创建bean工厂，读配置文件</p> 
<p>把这监听器，上下文配置起来</p> 
<p>refreshContext，最重要的，spring。factory加载，就是自动配置，bean实例化完成，就算是启动完成了。</p> 
<h2><a id="tomcat_105"></a>项目放到tomcat：</h2> 
<p>普通spring直接就是打war包放到tomcat的webapps下，再执行startup</p> 
<p>然后springbot就是war在放到tomcat</p> 
<p>1.dependence打war包，</p> 
<p>2.排除tomcat内置</p> 
<p>3.启动类</p> 
<p>4.clean，install</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/72bc527d625ce99aea86ebe53a8d4e5f/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">秋招面试知识点----JVM篇</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/4ffe9c04060b076797cb5c473aa283c7/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">神经网络 python 多类别_Keras入门（一）搭建深度神经网络（DNN）解决多分类问题...</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>