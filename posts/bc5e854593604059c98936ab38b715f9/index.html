<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>LeetCode 第382场周赛个人题解 - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="LeetCode 第382场周赛个人题解" />
<meta property="og:description" content="目录
100215. 按键变更的次数
原题链接
题目描述
接口描述
思路分析
AC代码
100195. Alice 和 Bob 玩鲜花游戏
原题链接
题目描述
接口描述
思路分析
AC代码
100206. 子集中元素的最大数量
原题链接
题目描述
接口描述
思路分析
AC代码
100179. 给定操作次数内使剩余元素的或值最小
原题链接
题目描述
接口描述
思路分析
AC代码
100215. 按键变更的次数
原题链接 100215. 按键变更的次数
题目描述 给你一个下标从 0 开始的字符串 s ，该字符串由用户输入。按键变更的定义是：使用与上次使用的按键不同的键。例如 s = &#34;ab&#34; 表示按键变更一次，而 s = &#34;bBBb&#34; 不存在按键变更。
返回用户输入过程中按键变更的次数。
注意：shift 或 caps lock 等修饰键不计入按键变更，也就是说，如果用户先输入字母 &#39;a&#39; 然后输入字母 &#39;A&#39; ，不算作按键变更。
接口描述 class Solution { public: int countKeyChanges(string s) { } }; 思路分析 一次遍历，直接模拟即可" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/bc5e854593604059c98936ab38b715f9/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2024-01-28T13:15:01+08:00" />
<meta property="article:modified_time" content="2024-01-28T13:15:01+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">LeetCode 第382场周赛个人题解</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p id="main-toc"><strong>目录</strong></p> 
<p id="-toc" style="margin-left:0px;"></p> 
<p id="100215.%20%E6%8C%89%E9%94%AE%E5%8F%98%E6%9B%B4%E7%9A%84%E6%AC%A1%E6%95%B0-toc" style="margin-left:0px;"><a href="#100215.%20%E6%8C%89%E9%94%AE%E5%8F%98%E6%9B%B4%E7%9A%84%E6%AC%A1%E6%95%B0" rel="nofollow">100215. 按键变更的次数</a></p> 
<p id="%E5%8E%9F%E9%A2%98%E9%93%BE%E6%8E%A5-toc" style="margin-left:40px;"><a href="#%E5%8E%9F%E9%A2%98%E9%93%BE%E6%8E%A5" rel="nofollow">原题链接</a></p> 
<p id="%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0-toc" style="margin-left:40px;"><a href="#%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0" rel="nofollow">题目描述</a></p> 
<p id="%E6%8E%A5%E5%8F%A3%E6%8F%8F%E8%BF%B0-toc" style="margin-left:40px;"><a href="#%E6%8E%A5%E5%8F%A3%E6%8F%8F%E8%BF%B0" rel="nofollow">接口描述</a></p> 
<p id="%E6%80%9D%E8%B7%AF%E5%88%86%E6%9E%90-toc" style="margin-left:40px;"><a href="#%E6%80%9D%E8%B7%AF%E5%88%86%E6%9E%90" rel="nofollow">思路分析</a></p> 
<p id="AC%E4%BB%A3%E7%A0%81-toc" style="margin-left:40px;"><a href="#AC%E4%BB%A3%E7%A0%81" rel="nofollow">AC代码</a></p> 
<p id="100195.%20Alice%20%E5%92%8C%20Bob%20%E7%8E%A9%E9%B2%9C%E8%8A%B1%E6%B8%B8%E6%88%8F-toc" style="margin-left:0px;"><a href="#100195.%20Alice%20%E5%92%8C%20Bob%20%E7%8E%A9%E9%B2%9C%E8%8A%B1%E6%B8%B8%E6%88%8F" rel="nofollow">100195. Alice 和 Bob 玩鲜花游戏</a></p> 
<p id="%E5%8E%9F%E9%A2%98%E9%93%BE%E6%8E%A5-toc" style="margin-left:40px;"><a href="#%E5%8E%9F%E9%A2%98%E9%93%BE%E6%8E%A5" rel="nofollow">原题链接</a></p> 
<p id="%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0-toc" style="margin-left:40px;"><a href="#%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0" rel="nofollow">题目描述</a></p> 
<p id="%E6%8E%A5%E5%8F%A3%E6%8F%8F%E8%BF%B0-toc" style="margin-left:40px;"><a href="#%E6%8E%A5%E5%8F%A3%E6%8F%8F%E8%BF%B0" rel="nofollow">接口描述</a></p> 
<p id="%E6%80%9D%E8%B7%AF%E5%88%86%E6%9E%90-toc" style="margin-left:40px;"><a href="#%E6%80%9D%E8%B7%AF%E5%88%86%E6%9E%90" rel="nofollow">思路分析</a></p> 
<p id="AC%E4%BB%A3%E7%A0%81-toc" style="margin-left:40px;"><a href="#AC%E4%BB%A3%E7%A0%81" rel="nofollow">AC代码</a></p> 
<p id="100206.%20%E5%AD%90%E9%9B%86%E4%B8%AD%E5%85%83%E7%B4%A0%E7%9A%84%E6%9C%80%E5%A4%A7%E6%95%B0%E9%87%8F-toc" style="margin-left:0px;"><a href="#100206.%20%E5%AD%90%E9%9B%86%E4%B8%AD%E5%85%83%E7%B4%A0%E7%9A%84%E6%9C%80%E5%A4%A7%E6%95%B0%E9%87%8F" rel="nofollow">100206. 子集中元素的最大数量</a></p> 
<p id="%E5%8E%9F%E9%A2%98%E9%93%BE%E6%8E%A5-toc" style="margin-left:40px;"><a href="#%E5%8E%9F%E9%A2%98%E9%93%BE%E6%8E%A5" rel="nofollow">原题链接</a></p> 
<p id="%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0-toc" style="margin-left:40px;"><a href="#%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0" rel="nofollow">题目描述</a></p> 
<p id="%E6%8E%A5%E5%8F%A3%E6%8F%8F%E8%BF%B0-toc" style="margin-left:40px;"><a href="#%E6%8E%A5%E5%8F%A3%E6%8F%8F%E8%BF%B0" rel="nofollow">接口描述</a></p> 
<p id="%E6%80%9D%E8%B7%AF%E5%88%86%E6%9E%90-toc" style="margin-left:40px;"><a href="#%E6%80%9D%E8%B7%AF%E5%88%86%E6%9E%90" rel="nofollow">思路分析</a></p> 
<p id="AC%E4%BB%A3%E7%A0%81-toc" style="margin-left:40px;"><a href="#AC%E4%BB%A3%E7%A0%81" rel="nofollow">AC代码</a></p> 
<p id="100179.%20%E7%BB%99%E5%AE%9A%E6%93%8D%E4%BD%9C%E6%AC%A1%E6%95%B0%E5%86%85%E4%BD%BF%E5%89%A9%E4%BD%99%E5%85%83%E7%B4%A0%E7%9A%84%E6%88%96%E5%80%BC%E6%9C%80%E5%B0%8F-toc" style="margin-left:0px;"><a href="#100179.%20%E7%BB%99%E5%AE%9A%E6%93%8D%E4%BD%9C%E6%AC%A1%E6%95%B0%E5%86%85%E4%BD%BF%E5%89%A9%E4%BD%99%E5%85%83%E7%B4%A0%E7%9A%84%E6%88%96%E5%80%BC%E6%9C%80%E5%B0%8F" rel="nofollow">100179. 给定操作次数内使剩余元素的或值最小</a></p> 
<p id="%E5%8E%9F%E9%A2%98%E9%93%BE%E6%8E%A5-toc" style="margin-left:40px;"><a href="#%E5%8E%9F%E9%A2%98%E9%93%BE%E6%8E%A5" rel="nofollow">原题链接</a></p> 
<p id="%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0-toc" style="margin-left:40px;"><a href="#%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0" rel="nofollow">题目描述</a></p> 
<p id="%E6%8E%A5%E5%8F%A3%E6%8F%8F%E8%BF%B0-toc" style="margin-left:40px;"><a href="#%E6%8E%A5%E5%8F%A3%E6%8F%8F%E8%BF%B0" rel="nofollow">接口描述</a></p> 
<p id="%E6%80%9D%E8%B7%AF%E5%88%86%E6%9E%90-toc" style="margin-left:40px;"><a href="#%E6%80%9D%E8%B7%AF%E5%88%86%E6%9E%90" rel="nofollow">思路分析</a></p> 
<p id="AC%E4%BB%A3%E7%A0%81-toc" style="margin-left:40px;"><a href="#AC%E4%BB%A3%E7%A0%81" rel="nofollow">AC代码</a></p> 
<hr id="hr-toc"> 
<p>100215. 按键变更的次数</p> 
<h3 id="%E5%8E%9F%E9%A2%98%E9%93%BE%E6%8E%A5" style="background-color:transparent;">原题链接</h3> 
<p><a href="https://leetcode.cn/problems/number-of-changing-keys/" rel="nofollow" title="100215. 按键变更的次数">100215. 按键变更的次数</a></p> 
<h3 id="%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0">题目描述</h3> 
<blockquote> 
 <p>给你一个下标从<strong> 0</strong> 开始的字符串 <code>s</code> ，该字符串由用户输入。按键变更的定义是：使用与上次使用的按键不同的键。例如 <code>s = "ab"</code> 表示按键变更一次，而 <code>s = "bBBb"</code> 不存在按键变更。</p> 
 <p>返回用户输入过程中按键变更的次数。</p> 
 <p><strong>注意：</strong><code>shift</code> 或 <code>caps lock</code> 等修饰键不计入按键变更，也就是说，如果用户先输入字母 <code>'a'</code> 然后输入字母 <code>'A'</code> ，不算作按键变更。</p> 
</blockquote> 
<h3 id="%E6%8E%A5%E5%8F%A3%E6%8F%8F%E8%BF%B0">接口描述</h3> 
<pre><code class="language-cpp">class Solution {
public:
    int countKeyChanges(string s) {
        
    }
};</code></pre> 
<h3 id="%E6%80%9D%E8%B7%AF%E5%88%86%E6%9E%90">思路分析</h3> 
<p>一次遍历，直接模拟即可</p> 
<h3 id="AC%E4%BB%A3%E7%A0%81">AC代码</h3> 
<pre><code class="language-cpp">class Solution {
public:
    int countKeyChanges(string s) {
        int ret = 0;
        char pre = s[0];
        for(auto x : s)
            ret += tolower(x) != tolower(pre) , pre = x;
        return ret;
    }
};</code></pre> 
<h2 id="100195.%20Alice%20%E5%92%8C%20Bob%20%E7%8E%A9%E9%B2%9C%E8%8A%B1%E6%B8%B8%E6%88%8F" style="background-color:transparent;">100195. Alice 和 Bob 玩鲜花游戏</h2> 
<h3>原题链接</h3> 
<p><a href="https://leetcode.cn/problems/alice-and-bob-playing-flower-game/" rel="nofollow" title="100195. Alice 和 Bob 玩鲜花游戏">100195. Alice 和 Bob 玩鲜花游戏</a></p> 
<p></p> 
<h3>题目描述</h3> 
<blockquote> 
 <p>Alice 和 Bob 在一个长满鲜花的环形草地玩一个回合制游戏。环形的草地上有一些鲜花，Alice 到 Bob 之间顺时针有 <code>x</code> 朵鲜花，逆时针有 <code>y</code> 朵鲜花。</p> 
 <p>游戏过程如下：</p> 
 <ol><li>Alice 先行动。</li><li>每一次行动中，当前玩家必须选择顺时针或者逆时针，然后在这个方向上摘一朵鲜花。</li><li>一次行动结束后，如果所有鲜花都被摘完了，那么 <strong>当前</strong> 玩家抓住对手并赢得游戏的胜利。</li></ol> 
 <p>给你两个整数 <code>n</code> 和 <code>m</code> ，你的任务是求出满足以下条件的所有 <code>(x, y)</code> 对：</p> 
 <ul><li>按照上述规则，Alice 必须赢得游戏。</li><li>Alice 顺时针方向上的鲜花数目 <code>x</code> 必须在区间 <code>[1,n]</code> 之间。</li><li>Alice 逆时针方向上的鲜花数目 <code>y</code> 必须在区间 <code>[1,m]</code> 之间。</li></ul> 
 <p>请你返回满足题目描述的数对 <code>(x, y)</code> 的数目。</p> 
</blockquote> 
<h3>接口描述</h3> 
<p>　</p> 
<pre><code class="language-cpp">class Solution {
public:
    long long flowerGame(int n, int m) {
        
    }
};</code></pre> 
<h3>思路分析</h3> 
<p>　只有鲜花总数目为奇数时，Alice才能赢，(n / 2) * (m - m / 2) + (n - n / 2) * (m / 2)即为所有x * y为奇数的数对数目，没什么好说的</p> 
<h3>AC代码</h3> 
<pre><code class="language-cpp">class Solution {
public:
    long long flowerGame(long long n, long long m) {
        return (n / 2) * (m - m / 2) + (n - n / 2) * (m / 2);
    }
};</code></pre> 
<p></p> 
<h2 id="100206.%20%E5%AD%90%E9%9B%86%E4%B8%AD%E5%85%83%E7%B4%A0%E7%9A%84%E6%9C%80%E5%A4%A7%E6%95%B0%E9%87%8F">100206. 子集中元素的最大数量</h2> 
<h3>原题链接</h3> 
<p><a href="https://leetcode.cn/problems/find-the-maximum-number-of-elements-in-subset/" rel="nofollow" title="100206. 子集中元素的最大数量">100206. 子集中元素的最大数量</a></p> 
<h3>题目描述</h3> 
<blockquote> 
 <p>　</p> 
 <p>给你一个<strong> 正整数 </strong>数组 <code>nums</code> 。</p> 
 <p>你需要从数组中选出一个满足下述条件的</p> 
 <p>子集</p> ： 
 <ul><li>你可以将选中的元素放置在一个下标从 <strong>0</strong> 开始的数组中，并使其遵循以下模式：<code>[x, x2, x4, ..., xk/2, xk, xk/2, ..., x4, x2, x]</code>（<strong>注意</strong>，<code>k</code> 可以是任何 <strong>非负</strong> 的 2 的幂）。例如，<code>[2, 4, 16, 4, 2]</code> 和 <code>[3, 9, 3]</code> 都符合这一模式，而 <code>[2, 4, 8, 4, 2]</code> 则不符合。</li></ul> 
 <p>返回满足这些条件的子集中，元素数量的 <strong>最大值 </strong><em>。</em></p> 
</blockquote> 
<h3>接口描述</h3> 
<pre><code class="language-cpp">class Solution {
public:
    int maximumLength(vector&lt;int&gt;&amp; nums) {
        
    }
};</code></pre> 
<h3>思路分析</h3> 
<p>　把原数组从小到大排序，哈希表存每个数字出现次数，然后遍历排序后的数组，枚举每个数字作为开头的目标子集，不断平方直到哈希表中这个值出现次数小于2，该数字作为开头的子集数目即为平方次数乘2-1</p> 
<p>也是模拟题</p> 
<p><strong>时间复杂度：O(nlogn)</strong></p> 
<h3>AC代码</h3> 
<pre><code class="language-cpp">class Solution {
public:
    int maximumLength(vector&lt;int&gt;&amp; nums) {
        unordered_map&lt;long long,int&gt; mp;
        for(auto x : nums) mp[x]++;
        sort(nums.begin() , nums.end());
        long long ret = max(1 , mp[1] &amp; 1 ? mp[1] : mp[1] - 1);
        for(auto x : nums)
        {
            if(x == 1) continue;
            long long y = x , s = 0;
            while(mp.count(y))
            {
                if(mp[y])
                    s += 2;
                if(mp[y] &lt; 2)
                    break;
                y *= y;
            }
            ret = max(ret , s - 1);
        }
        return ret;
    }
};</code></pre> 
<p></p> 
<h2 id="100179.%20%E7%BB%99%E5%AE%9A%E6%93%8D%E4%BD%9C%E6%AC%A1%E6%95%B0%E5%86%85%E4%BD%BF%E5%89%A9%E4%BD%99%E5%85%83%E7%B4%A0%E7%9A%84%E6%88%96%E5%80%BC%E6%9C%80%E5%B0%8F">100179. 给定操作次数内使剩余元素的或值最小</h2> 
<h3>原题链接</h3> 
<p><a href="https://leetcode.cn/problems/minimize-or-of-remaining-elements-using-operations/" rel="nofollow" title="100179. 给定操作次数内使剩余元素的或值最小">100179. 给定操作次数内使剩余元素的或值最小</a></p> 
<h3>题目描述</h3> 
<blockquote> 
 <p>　</p> 
 <p>给你一个下标从 <strong>0</strong> 开始的整数数组 <code>nums</code> 和一个整数 <code>k</code> 。</p> 
 <p>一次操作中，你可以选择 <code>nums</code> 中满足 <code>0 &lt;= i &lt; nums.length - 1</code> 的一个下标 <code>i</code> ，并将 <code>nums[i]</code> 和 <code>nums[i + 1]</code> 替换为数字 <code>nums[i] &amp; nums[i + 1]</code> ，其中 <code>&amp;</code> 表示按位 <code>AND</code> 操作。</p> 
 <p>请你返回 <strong>至多</strong> <code>k</code> 次操作以内，使 <code>nums</code> 中所有剩余元素按位 <code>OR</code> 结果的 <strong>最小值</strong> 。</p> 
</blockquote> 
<h3>接口描述</h3> 
<p>　</p> 
<pre><code class="language-cpp">class Solution {
public:
    int minOrAfterOperations(vector&lt;int&gt;&amp; nums, int k) {
        
    }
};</code></pre> 
<h3 style="background-color:transparent;">思路分析</h3> 
<p>显然是一道考察位运算tip的题，尝试从位运算角度去思考</p> 
<p>对于题目给的相与替换操作，可以使得最终相或的值相较于不操作原数组相或的值的某些二进制位由1变0</p> 
<p>我们设原数组相或值为num，最优操作后相或值为ans，那么ans在二进制下为num的子集，因为我们的操作不能使得1的位增加，只能使得1的位减少</p> 
<p>所以我们若干次操作后的或值最多只有log(num)种</p> 
<p>那对于每一种我们如果能通过遍历一次数组就能确定其是否存在，时间复杂度就为O(nlogn)，这题就能过了</p> 
<p>所以有了思路，从高位枚举，设当前能被干掉的所有位为1组成的数字为ret，那么我们现在如果要判断第i位是否能被干掉，就相当于判断ret | (1 &lt;&lt; i)是否能被干掉（因为为了最终的值尽可能小，我们优先干掉位高的）</p> 
<p>类似于最长递增子数组的思想，我们一次遍历数组，只要当前的相与值和ret | (1 &lt;&lt; i)相与为0，我们就计数加一，然后相与值再复位为二进制全1</p> 
<p>最终我们就得到了相与值和ret | (1 &lt;&lt; i)相与为0的子数组的最大数目，那么我们干掉ret | (1 &lt;&lt; i)的操作次数就是len(nums)  - 子数组数目，维护我们能够干掉的数字位即可</p> 
<p>最终返回没有被干掉的数字位组成的数字就是答案</p> 
<p><strong>时间复杂度O(nlogU)</strong></p> 
<h3>AC代码</h3> 
<pre><code class="language-cpp">class Solution
{
public:
    int minOrAfterOperations(vector&lt;int&gt; &amp;nums, int k)
    {
        int ret = 0 , n = nums.size();
        for(int i = 29 ; i &gt;= 0 ; i--)
        {
            int cur = ret | (1 &lt;&lt; i) , s = -1;
            int cnt = n;
            for(auto x : nums)
            {
                s &amp;= cur &amp; x;
                if(!s) cnt-- , s = -1;
            }
            if(cnt &lt;= k) ret = cur;
        }
        return (1 &lt;&lt; 30) - 1 - ret;
    }
};</code></pre> 
<p></p> 
<p></p> 
<p></p> 
<p></p> 
<p></p> 
<p></p> 
<p></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/c59fdb343fce1a811852bd2dfc450647/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">python使用activemq库ActiveMQClient类的连接activemq并订阅、发送和接收消息</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/230e5885bd87e7cf170deafd5cc5a4f2/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">QT&#43;opengl 创建一个六边形</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>