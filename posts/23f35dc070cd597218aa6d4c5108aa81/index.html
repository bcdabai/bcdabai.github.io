<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>【LeetCode】二分查找精选10题 - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="【LeetCode】二分查找精选10题" />
<meta property="og:description" content="目录
在排序数组中二分查找：
1. 二分查找（简单）
2. 搜索插入位置（简单）
3. 点名（简单）
4. 在排序数组中查找元素的第一个和最后一个位置（中等）
5. 山脉数组的峰顶索引（中等）
6. 寻找峰值（中等）
7. 寻找旋转排序数组中的最小值（中等）
8. 有序数组中的单一元素（中等）
在数值范围内二分查找：
1. x 的平方根（简单）
2. 爱吃香蕉的珂珂（中等）
第2题“搜索插入位置”必看，讲解了二段式二分查找循环条件为什么是left &lt; right和中点什么时候取靠左的什么时候取靠右的。
二分查找（Binary Search）也称折半查找，要求线性表必须采用顺序存储结构，而且表中元素按关键字有序排列。
首先，假设表中元素是按升序排列，将表中间位置记录的关键字与查找关键字比较，如果两者相等，则查找成功；否则利用中间位置记录将表分成前、后两个子表，如果中间位置记录的关键字大于查找关键字，则进一步查找前一子表，否则进一步查找后一子表。重复以上过程，直到找到满足条件的记录，使查找成功，或直到子表不存在为止，此时查找不成功。
二分查找算法每次将查找范围减少一半，因此对于一个长度为n的数组可能需要O(logn)次查找，每次查找只需要比较当前查找范围的中间数字和目标数字，在O(1)的时间可以完成，因此二分查找算法的时间复杂度是O(logn)。
在一个1~10的有序数组中查找数字7示意图：
二分查找法常用来在排序数组中查找和在一个数值范围内查找。
在排序数组中二分查找： 1. 二分查找（简单） 如果nums[mid] &lt; target，那么target一定在[mid &#43; 1, right]区间内如果nums[mid] &gt; target，那么target一定在[left, mid - 1]区间内如果nums[mid] = target，找到target class Solution { public: int search(vector&lt;int&gt;&amp; nums, int target) { int n = nums.size(); int left = 0; int right = n - 1; while (left &lt;= right) { int mid = (left &#43; right) / 2; // 如果left&#43;right太大可能会溢出，下面这种写法不会溢出 // int mid = left &#43; (right - left) / 2; if (nums[mid] &lt; target) { left = mid &#43; 1; } else if (nums[mid] &gt; target) { right = mid - 1; } else { return mid; } } return -1; } }; 2." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/23f35dc070cd597218aa6d4c5108aa81/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-12-16T15:39:49+08:00" />
<meta property="article:modified_time" content="2023-12-16T15:39:49+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">【LeetCode】二分查找精选10题</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p id="main-toc"><strong>目录</strong></p> 
<p id="%E5%9C%A8%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE%EF%BC%9A-toc" style="margin-left:0px;"><a href="#%E5%9C%A8%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE%EF%BC%9A" rel="nofollow"><span style="color:#faa572;">在排序数组中二分查找：</span></a></p> 
<p id="1.%20%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE%EF%BC%88%E7%AE%80%E5%8D%95%EF%BC%89-toc" style="margin-left:0px;"><a href="#1.%20%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE%EF%BC%88%E7%AE%80%E5%8D%95%EF%BC%89" rel="nofollow">1. 二分查找（简单）</a></p> 
<p id="2.%20%E6%90%9C%E7%B4%A2%E6%8F%92%E5%85%A5%E4%BD%8D%E7%BD%AE%EF%BC%88%E7%AE%80%E5%8D%95%EF%BC%89-toc" style="margin-left:0px;"><a href="#2.%20%E6%90%9C%E7%B4%A2%E6%8F%92%E5%85%A5%E4%BD%8D%E7%BD%AE%EF%BC%88%E7%AE%80%E5%8D%95%EF%BC%89" rel="nofollow">2. 搜索插入位置（简单）</a></p> 
<p id="3.%20%E7%82%B9%E5%90%8D%EF%BC%88%E7%AE%80%E5%8D%95%EF%BC%89-toc" style="margin-left:0px;"><a href="#3.%20%E7%82%B9%E5%90%8D%EF%BC%88%E7%AE%80%E5%8D%95%EF%BC%89" rel="nofollow">3. 点名（简单）</a></p> 
<p id="4.%20%E5%9C%A8%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E6%9F%A5%E6%89%BE%E5%85%83%E7%B4%A0%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%92%8C%E6%9C%80%E5%90%8E%E4%B8%80%E4%B8%AA%E4%BD%8D%E7%BD%AE%EF%BC%88%E4%B8%AD%E7%AD%89%EF%BC%89-toc" style="margin-left:0px;"><a href="#4.%20%E5%9C%A8%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E6%9F%A5%E6%89%BE%E5%85%83%E7%B4%A0%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%92%8C%E6%9C%80%E5%90%8E%E4%B8%80%E4%B8%AA%E4%BD%8D%E7%BD%AE%EF%BC%88%E4%B8%AD%E7%AD%89%EF%BC%89" rel="nofollow">4. 在排序数组中查找元素的第一个和最后一个位置（中等）</a></p> 
<p id="5.%20%E5%B1%B1%E8%84%89%E6%95%B0%E7%BB%84%E7%9A%84%E5%B3%B0%E9%A1%B6%E7%B4%A2%E5%BC%95%EF%BC%88%E4%B8%AD%E7%AD%89%EF%BC%89-toc" style="margin-left:0px;"><a href="#5.%20%E5%B1%B1%E8%84%89%E6%95%B0%E7%BB%84%E7%9A%84%E5%B3%B0%E9%A1%B6%E7%B4%A2%E5%BC%95%EF%BC%88%E4%B8%AD%E7%AD%89%EF%BC%89" rel="nofollow">5. 山脉数组的峰顶索引（中等）</a></p> 
<p id="6.%20%E5%AF%BB%E6%89%BE%E5%B3%B0%E5%80%BC%EF%BC%88%E4%B8%AD%E7%AD%89%EF%BC%89-toc" style="margin-left:0px;"><a href="#6.%20%E5%AF%BB%E6%89%BE%E5%B3%B0%E5%80%BC%EF%BC%88%E4%B8%AD%E7%AD%89%EF%BC%89" rel="nofollow">6. 寻找峰值（中等）</a></p> 
<p id="7.%20%E5%AF%BB%E6%89%BE%E6%97%8B%E8%BD%AC%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E6%9C%80%E5%B0%8F%E5%80%BC%EF%BC%88%E4%B8%AD%E7%AD%89%EF%BC%89-toc" style="margin-left:0px;"><a href="#7.%20%E5%AF%BB%E6%89%BE%E6%97%8B%E8%BD%AC%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E6%9C%80%E5%B0%8F%E5%80%BC%EF%BC%88%E4%B8%AD%E7%AD%89%EF%BC%89" rel="nofollow">7. 寻找旋转排序数组中的最小值（中等）</a></p> 
<p id="8.%20%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E5%8D%95%E4%B8%80%E5%85%83%E7%B4%A0%EF%BC%88%E4%B8%AD%E7%AD%89%EF%BC%89-toc" style="margin-left:0px;"><a href="#8.%20%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E5%8D%95%E4%B8%80%E5%85%83%E7%B4%A0%EF%BC%88%E4%B8%AD%E7%AD%89%EF%BC%89" rel="nofollow">8. 有序数组中的单一元素（中等）</a></p> 
<p id="%E5%9C%A8%E6%95%B0%E5%80%BC%E8%8C%83%E5%9B%B4%E5%86%85%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE%EF%BC%9A-toc" style="margin-left:0px;"><a href="#%E5%9C%A8%E6%95%B0%E5%80%BC%E8%8C%83%E5%9B%B4%E5%86%85%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE%EF%BC%9A" rel="nofollow"><span style="color:#faa572;">在数值范围内二分查找：</span></a></p> 
<p id="1.%20x%20%E7%9A%84%E5%B9%B3%E6%96%B9%E6%A0%B9%EF%BC%88%E7%AE%80%E5%8D%95%EF%BC%89-toc" style="margin-left:0px;"><a href="#1.%20x%20%E7%9A%84%E5%B9%B3%E6%96%B9%E6%A0%B9%EF%BC%88%E7%AE%80%E5%8D%95%EF%BC%89" rel="nofollow">1. x 的平方根（简单）</a></p> 
<p id="2.%20%E7%88%B1%E5%90%83%E9%A6%99%E8%95%89%E7%9A%84%E7%8F%82%E7%8F%82%EF%BC%88%E4%B8%AD%E7%AD%89%EF%BC%89-toc" style="margin-left:0px;"><a href="#2.%20%E7%88%B1%E5%90%83%E9%A6%99%E8%95%89%E7%9A%84%E7%8F%82%E7%8F%82%EF%BC%88%E4%B8%AD%E7%AD%89%EF%BC%89" rel="nofollow">2. 爱吃香蕉的珂珂（中等）</a></p> 
<p><span style="color:#be191c;"><span style="background-color:#fef2f0;">第2题“搜索插入位置”必看，讲解了二段式二分查找循环条件为什么是left &lt; right和中点什么时候取靠左的什么时候取靠右的。</span></span></p> 
<hr> 
<p><em>二分查找（Binary Search）</em>也称折半查找，要求线性表必须采用顺序存储结构，而且表中元素按关键字有序排列。</p> 
<p>首先，假设表中元素是按升序排列，将表中间位置记录的关键字与查找关键字比较，如果两者相等，则查找成功；否则利用中间位置记录将表分成前、后两个子表，如果中间位置记录的关键字大于查找关键字，则进一步查找前一子表，否则进一步查找后一子表。重复以上过程，直到找到满足条件的记录，使查找成功，或直到子表不存在为止，此时查找不成功。</p> 
<p>二分查找算法每次将查找范围减少一半，因此对于一个长度为n的数组可能需要O(logn)次查找，每次查找只需要比较当前查找范围的中间数字和目标数字，在O(1)的时间可以完成，因此二分查找算法的时间复杂度是O(logn)。</p> 
<p>在一个1~10的有序数组中查找数字7示意图：</p> 
<p><img alt="" height="646" src="https://images2.imgbox.com/95/61/RT9GNTVw_o.png" width="418"></p> 
<p>二分查找法常用来在排序数组中查找和在一个数值范围内查找。</p> 
<h2 id="%E5%9C%A8%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE%EF%BC%9A"><span style="color:#faa572;">在排序数组中二分查找：</span></h2> 
<h2 id="1.%20%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE%EF%BC%88%E7%AE%80%E5%8D%95%EF%BC%89"><a class="link-info" href="https://leetcode.cn/problems/binary-search/description/" rel="nofollow" title="1. 二分查找（简单）">1. 二分查找（简单）</a></h2> 
<p><img alt="" height="60" src="https://images2.imgbox.com/6c/98/GXKiY8Y4_o.png" width="526"></p> 
<ul><li>如果nums[mid] &lt; target，那么target一定在[mid + 1, right]区间内</li><li>如果nums[mid] &gt; target，那么target一定在[left, mid - 1]区间内</li><li>如果nums[mid] = target，找到target</li></ul> 
<pre><code class="language-cpp">class Solution {
public:
    int search(vector&lt;int&gt;&amp; nums, int target) {
        int n = nums.size();
        int left = 0;
        int right = n - 1;
        while (left &lt;= right)
        {
            int mid = (left + right) / 2;
            // 如果left+right太大可能会溢出，下面这种写法不会溢出
            // int mid = left + (right - left) / 2;

            if (nums[mid] &lt; target)
            {
                left = mid + 1;
            }
            else if (nums[mid] &gt; target)
            {
                right = mid - 1;
            }
            else
            {
                return mid;
            }
        }
        return -1;
    }
};</code></pre> 
<h2 id="2.%20%E6%90%9C%E7%B4%A2%E6%8F%92%E5%85%A5%E4%BD%8D%E7%BD%AE%EF%BC%88%E7%AE%80%E5%8D%95%EF%BC%89"><a class="link-info" href="https://leetcode.cn/problems/search-insert-position/description/" rel="nofollow" title="2. 搜索插入位置（简单）">2. 搜索插入位置（简单）</a></h2> 
<p><img alt="" height="258" src="https://images2.imgbox.com/93/4d/KRsDLwjx_o.png" width="173"></p> 
<ul><li>如果nums[mid] &lt; target，那么pos一定在[mid + 1, right]区间内</li><li>如果nums[mid] &gt;= target，那么pos一定在[left, mid]区间内</li></ul> 
<p><span style="color:#be191c;"><span style="background-color:#fef2f0;">二段式二分查找一定要注意细节：</span></span></p> 
<p><span style="color:#1a439c;"><span style="background-color:#eaf4fc;">细节1：循环条件为left &lt; right，不是left &lt;= right。</span></span></p> 
<p>right不管怎么移动都是在[pos, n - 1]区间内，当left == right时，left、right、mid都是同一位置。如果left == right时进入循环，nums[mid] 一定&gt;= target，执行right = mid，实际上right根本没动，整个区间都没动，进入下一次循环，还会执行相同的步骤，显然出现了死循环。</p> 
<p>其实left == right时就唯一确定了一个元素，如果== target，说明数组中存在target，left或right就是target的下标，如果!= target，说明数组中不存在target，left或right就是target的插入位置。</p> 
<p><span style="color:#1a439c;"><span style="background-color:#eaf4fc;">细节2：如果区间大小是偶数，中点取靠左的，即mid = left + (right - left) / 2。</span></span></p> 
<p><img alt="" height="660" src="https://images2.imgbox.com/29/af/4oygHv3q_o.png" width="849"></p> 
<p><span style="color:#1c7331;"><span style="background-color:#edf6e8;">规律：</span></span></p> 
<p><img alt="" height="187" src="https://images2.imgbox.com/8a/ee/v6fVOGiA_o.png" width="843"></p> 
<p><span style="color:#1a439c;"><span style="background-color:#eaf4fc;">细节3：如果数组所有元素全&gt; target，插入位置为0，这种情况不用特殊处理。如果数组所有元素全&lt; target，</span></span><span style="color:#1a439c;"><span style="background-color:#eaf4fc;">最后left == right时，定位的是数组最后一个元素（nums[n-1]），这时不能返回left或right，应该返回n。</span></span></p> 
<pre><code class="language-cpp">class Solution {
public:
    int searchInsert(vector&lt;int&gt;&amp; nums, int target) {
        int n = nums.size();
        int left = 0;
        int right = n - 1;
        while (left &lt; right)
        {
            int mid = left + (right - left) / 2; // 中点取靠左的
            if (nums[mid] &lt; target)
            {
                left = mid + 1;
            }
            else
            {
                right = mid;
            }
        }
        return nums[left] &lt; target ? n : left;
    }
};</code></pre> 
<h2 id="3.%20%E7%82%B9%E5%90%8D%EF%BC%88%E7%AE%80%E5%8D%95%EF%BC%89"><a class="link-info" href="https://leetcode.cn/problems/que-shi-de-shu-zi-lcof/description/" rel="nofollow" title="3. 点名（简单）">3. 点名（简单）</a></h2> 
<p><img alt="" height="158" src="https://images2.imgbox.com/23/3c/1qpx8SwT_o.png" width="440"></p> 
<ul><li>如果records[mid] == mid，那么pos一定在[mid + 1, right]区间内</li><li>如果nums[mid] &gt; mid，那么pos一定在[left, mid]区间内</li></ul> 
<p>细节1：循环条件为left &lt; right，不是left &lt;= right。</p> 
<p>细节2：如果区间大小是偶数，中点取靠左的，即mid = left + (right - left) / 2。</p> 
<p>细节3：如果所有元素都等于其下标，说明缺的是最后一个数，这时不能返回left或right，应该返回n - 1，这里n指的不是数组的大小，指的是一共有几个同学，n - 1是最后一个学号。</p> 
<pre><code class="language-cpp">class Solution {
public:
    int takeAttendance(vector&lt;int&gt;&amp; records) {
        int sz = records.size(); // 数组大小
        int n = sz + 1; // n位同学
        int left = 0;
        int right = sz - 1;
        while (left &lt; right)
        {
            int mid = left + (right - left) / 2;
            if (records[mid] == mid)
            {
                left = mid + 1;
            }
            else
            {
                right = mid;
            }
        }
        return records[left] == left ? n - 1 : left;
    }
};</code></pre> 
<h2 id="4.%20%E5%9C%A8%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E6%9F%A5%E6%89%BE%E5%85%83%E7%B4%A0%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%92%8C%E6%9C%80%E5%90%8E%E4%B8%80%E4%B8%AA%E4%BD%8D%E7%BD%AE%EF%BC%88%E4%B8%AD%E7%AD%89%EF%BC%89"><a class="link-info" href="https://leetcode.cn/problems/find-first-and-last-position-of-element-in-sorted-array/description/" rel="nofollow" title="4. 在排序数组中查找元素的第一个和最后一个位置（中等）">4. 在排序数组中查找元素的第一个和最后一个位置（中等）</a></h2> 
<p><span style="color:#be191c;"><span style="background-color:#fef2f0;">查找左边界lpos：</span></span></p> 
<p><img alt="" height="111" src="https://images2.imgbox.com/b9/da/oIp2YbIA_o.png" width="528"></p> 
<ul><li>如果nums[mid] &lt; target，那么lpos一定在[mid + 1, right]区间内</li><li>如果nums[mid] &gt;= target，那么lpos一定在[left, mid]区间内</li></ul> 
<p>细节1：循环条件为left &lt; right，不是left &lt;= right。</p> 
<p>细节2：如果区间大小是偶数，中点取靠左的，即mid = left + (right - left) / 2。</p> 
<p>细节3：left == right时定位的元素不一定是target，因为target可能不在数组中。</p> 
<p><span style="color:#be191c;"><span style="background-color:#fef2f0;">查找右边界lpos：</span></span></p> 
<p><img alt="" height="105" src="https://images2.imgbox.com/e3/70/5AGopaZp_o.png" width="529"></p> 
<ul><li>如果nums[mid] &lt;= target，那么lpos一定在[mid, right]区间内</li><li>如果nums[mid] &gt; target，那么rpos一定在[left, mid - 1]区间内</li></ul> 
<p>细节1：循环条件为left &lt; right，不是left &lt;= right。</p> 
<p>细节2：如果区间大小是偶数，中点取靠右的，即mid = left + (right - left + 1) / 2。</p> 
<p>细节3：这里不用判断left == right时定位的元素是不是target，因为既然执行到这里了，说明已经找到了左边界，那么target一定存在。</p> 
<pre><code class="language-cpp">class Solution {
public:
    vector&lt;int&gt; searchRange(vector&lt;int&gt;&amp; nums, int target) {
        int n = nums.size();
        if (n == 0)
            return { -1,-1 };

        // 查找左边界
        int left = 0;
        int right = n - 1;
        while (left &lt; right)
        {
            int mid = left + (right - left) / 2; // 中点取靠左的
            if (nums[mid] &lt; target)
            {
                left = mid + 1;
            }
            else
            {
                right = mid;
            }
        }
        // 判断确定出来的元素是不是target，如果不是，说明数组中不存在target
        if (nums[left] != target)
        {
            return { -1,-1 };
        }
        int lpos = left; // 标记左边界

        // 查找右边界
        left = 0;
        right = n - 1;
        while (left &lt; right)
        {
            int mid = left + (right - left + 1) / 2; // 中点取靠右的
            if (nums[mid] &gt; target)
            {
                right = mid - 1;
            }
            else
            {
                left = mid;
            }
        }
        int rpos = right; // 标记右边界

        return { lpos,rpos };
    }
};</code></pre> 
<h2 id="5.%20%E5%B1%B1%E8%84%89%E6%95%B0%E7%BB%84%E7%9A%84%E5%B3%B0%E9%A1%B6%E7%B4%A2%E5%BC%95%EF%BC%88%E4%B8%AD%E7%AD%89%EF%BC%89"><a class="link-info" href="https://leetcode.cn/problems/peak-index-in-a-mountain-array/description/" rel="nofollow" title="5. 山脉数组的峰顶索引（中等）">5. 山脉数组的峰顶索引（中等）</a></h2> 
<p><img alt="" height="110" src="https://images2.imgbox.com/c9/df/reJlNKnc_o.png" width="474"></p> 
<ul><li>如果arr[mid] &gt; arr[mid - 1]，即mid在递增区间内，那么pos一定在[mid, right]区间内</li><li>如果arr[mid] &lt; arr[mid - 1]，即mid在递减区间内，那么pos一定在[left, mid - 1]区间内</li></ul> 
<p>细节1：循环条件为left &lt; right，不是left &lt;= right。</p> 
<p>细节2：如果区间大小是偶数，中点取靠右的，即mid = left + (right - left + 1) / 2。</p> 
<p>细节3：第一个元素和最后一个元素都不可能是峰顶，查找范围为[1, n - 2]。</p> 
<pre><code class="language-cpp">class Solution {
public:
    int peakIndexInMountainArray(vector&lt;int&gt;&amp; arr) {
        int n = arr.size();
        int left = 1;
        int right = n - 2;
        while (left &lt; right)
        {
            int mid = left + (right - left + 1) / 2;
            if (arr[mid] &gt; arr[mid - 1])
            {
                left = mid;
            }
            else
            {
                right = mid - 1;
            }
        }
        return left;
    }
};</code></pre> 
<h2 id="6.%20%E5%AF%BB%E6%89%BE%E5%B3%B0%E5%80%BC%EF%BC%88%E4%B8%AD%E7%AD%89%EF%BC%89"><a class="link-info" href="https://leetcode.cn/problems/find-peak-element/description/" rel="nofollow" title="6. 寻找峰值（中等）">6. 寻找峰值（中等）</a></h2> 
<p><img alt="" height="386" src="https://images2.imgbox.com/c5/dd/OlMwp06a_o.png" width="643"></p> 
<p>和上一题“山脉数组的峰顶索引类似”。</p> 
<p><img alt="" height="110" src="https://images2.imgbox.com/c4/95/gHOObwUY_o.png" width="474"></p> 
<ul><li>如果nums[mid] &gt; nums[mid - 1]，即mid在递增区间内，那么pos一定在[mid, right]区间内</li><li>如果nums[mid] &lt; nums[mid - 1]，即mid在递减区间内，那么pos一定在[left, mid - 1]区间内</li></ul> 
<p>细节1：循环条件为left &lt; right，不是left &lt;= right。</p> 
<p>细节2：如果区间大小是偶数，中点取靠右的，即mid = left + (right - left + 1) / 2。</p> 
<pre><code class="language-cpp">class Solution {
public:
    int findPeakElement(vector&lt;int&gt;&amp; nums) {
        int n = nums.size();
        int left = 0;
        int right = n - 1;
        while (left &lt; right)
        {
            int mid = left + (right - left + 1) / 2;
            if (nums[mid] &gt; nums[mid - 1])
            {
                left = mid;
            }
            else
            {
                right = mid - 1;
            }
        }
        return left;
    }
};</code></pre> 
<h2 id="7.%20%E5%AF%BB%E6%89%BE%E6%97%8B%E8%BD%AC%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E6%9C%80%E5%B0%8F%E5%80%BC%EF%BC%88%E4%B8%AD%E7%AD%89%EF%BC%89"><a class="link-info" href="https://leetcode.cn/problems/find-minimum-in-rotated-sorted-array/description/" rel="nofollow" title="7. 寻找旋转排序数组中的最小值（中等）">7. 寻找旋转排序数组中的最小值（中等）</a></h2> 
<p><img alt="" height="314" src="https://images2.imgbox.com/ea/ac/R8LJHFhq_o.png" width="567"></p> 
<ul><li>如果nums[mid] &gt; nums[n - 1]，即mid在前半段区间内，那么pos一定在[mid + 1, right]区间内</li><li>如果nums[mid] &lt;= nums[n - 1]，即mid在后半段区间内，那么pos一定在[left, mid]区间内</li></ul> 
<p>细节1：循环条件为left &lt; right，不是left &lt;= right。</p> 
<p>细节2：如果区间大小是偶数，中点取靠左的，即mid = left + (right - left) / 2。</p> 
<pre><code class="language-cpp">class Solution {
public:
    int findMin(vector&lt;int&gt;&amp; nums) {
        int n = nums.size();
        int left = 0;
        int right = n - 1;
        while (left &lt; right)
        {
            int mid = left + (right - left) / 2;
            if (nums[mid] &gt; nums[n - 1])
            {
                left = mid + 1;
            }
            else
            {
                right = mid;
            }
        }
        return nums[left];
    }
};</code></pre> 
<h2 id="8.%20%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E5%8D%95%E4%B8%80%E5%85%83%E7%B4%A0%EF%BC%88%E4%B8%AD%E7%AD%89%EF%BC%89"><a class="link-info" href="https://leetcode.cn/problems/single-element-in-a-sorted-array/description/" rel="nofollow" title="8. 有序数组中的单一元素（中等）">8. 有序数组中的单一元素（中等）</a></h2> 
<p>异或解法仍然有效，时间复杂度O(n)。既然是数组是有序的，可以考虑二分查找法。</p> 
<p>将元素两两分为一组，只出现一次的元素是第一个两个元素不相同的组的第一个元素。</p> 
<p>n（n为奇数）个元素可以分为n / 2 + 1个组，编号为0 ~ n / 2。</p> 
<p><img alt="" height="218" src="https://images2.imgbox.com/79/57/dSpJmIcK_o.png" width="546"></p> 
<p>本题二分查找的单位是组，left、right、mid都指的是组的编号。</p> 
<p>mid组第一个元素的下标记为i，i = mid * 2。</p> 
<ul><li>如果nums[i] == nums[i + 1]，那么pos所在的组一定在[mid + 1, right]区间内</li><li>如果nums[i] != nums[i + 1]，那么pos所在的组一定在[left, mid]区间内</li></ul> 
<p>细节1：循环条件为left &lt; right，不是left &lt;= right。</p> 
<p>细节2：如果区间大小是偶数，中点取靠左的，即mid = left + (right - left) / 2。</p> 
<p>细节3：最后一个组没法比较两个元素，所以不参与查找，所以当数组只有1个元素时直接返回它。</p> 
<p>细节4：如果最后left == right时定位的组的两个元素相同，说明数组最后一个元素才是只出现一次的元素。</p> 
<pre><code class="language-cpp">class Solution {
public:
    int singleNonDuplicate(vector&lt;int&gt;&amp; nums) {
        int n = nums.size();
        if (n == 1)
            return nums[0];
            
        int left = 0; // 第一个组的编号
        int right = n / 2 - 1; // 倒数第二个组的编号
        while (left &lt; right)
        {
            int mid = left + (right - left) / 2;
            int i = mid * 2; // mid组第一个元素的下标
            if (nums[i] == nums[i + 1])
            {
                left = mid + 1;
            }
            else
            {
                right = mid;
            }
        }
        int i = left * 2; // 最后定位的组第一个元素的下标
        return nums[i] == nums[i + 1] ? nums[n - 1] : nums[i];
    }
};</code></pre> 
<h2 id="%E5%9C%A8%E6%95%B0%E5%80%BC%E8%8C%83%E5%9B%B4%E5%86%85%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE%EF%BC%9A"><span style="color:#faa572;">在数值范围内二分查找：</span></h2> 
<h2 id="1.%20x%20%E7%9A%84%E5%B9%B3%E6%96%B9%E6%A0%B9%EF%BC%88%E7%AE%80%E5%8D%95%EF%BC%89"><a class="link-info" href="https://leetcode.cn/problems/sqrtx/description/" rel="nofollow" title="1. x 的平方根（简单）">1. x 的平方根（简单）</a></h2> 
<p>假设x为正数，其平方根的范围为[1, x]。</p> 
<p><img alt="" height="65" src="https://images2.imgbox.com/60/f6/XqvCnZQ1_o.png" width="424">    root * root &lt;= x</p> 
<ul><li>如果mid * mid &lt;= x，那么root一定在[mid, right]区间内</li><li>如果mid * mid &gt; x，那么root一定在[left, mid - 1]区间内</li></ul> 
<p>细节1：循环条件为left &lt; right，不是left &lt;= right。</p> 
<p>细节2：如果区间大小是偶数，中点取靠右的，即mid = left + (right - left + 1) / 2。</p> 
<p>细节3：0的平方根是0。</p> 
<pre><code class="language-cpp">class Solution {
public:
    int mySqrt(int x) {
        if (x == 0)
            return 0;

        int left = 1;
        int right = x;
        while (left &lt; right)
        {
            int mid = left + (right - left + 1) / 2;
            if (mid &lt;= x / mid) // 数学上等价于mid*mid&lt;=x，但是写mid*mid可能会溢出
            {
                left = mid;
            }
            else
            {
                right = mid - 1;
            }
        }
        return left;
    }
};</code></pre> 
<h2 id="2.%20%E7%88%B1%E5%90%83%E9%A6%99%E8%95%89%E7%9A%84%E7%8F%82%E7%8F%82%EF%BC%88%E4%B8%AD%E7%AD%89%EF%BC%89"><a class="link-info" href="https://leetcode.cn/problems/koko-eating-bananas/description/" rel="nofollow" title="2. 爱吃香蕉的珂珂（中等）">2. 爱吃香蕉的珂珂（中等）</a></h2> 
<p>珂珂每小时至少吃1根香蕉。由于她每个小时只会选择1堆香蕉，所以她每小时吃香蕉的最大数目就是最大一堆香蕉的数目，记为high。</p> 
<p>k表示珂珂在h小时内吃掉所有香蕉的最小速度。</p> 
<p>设计一个函数getHours(vector&lt;int&gt;&amp; piles, int speed)，计算以speed速度吃香蕉，需要多少小时吃完。速度越快，时间越少。</p> 
<p><img alt="" height="60" src="https://images2.imgbox.com/bb/b8/bCQFE3GR_o.png" width="422"></p> 
<ul><li>如果getHours(piles, mid) &gt; h，k一定在[mid + 1, right]区间内</li><li>如果getHours(piles, mid) &lt;= h，k一定在[left, mid]区间内</li></ul> 
<p>细节1：循环条件为left &lt; right，不是left &lt;= right。</p> 
<p>细节2：如果区间大小是偶数，中点取靠左的，即mid = left + (right - left) / 2。</p> 
<pre><code class="language-cpp">class Solution {
public:
    int minEatingSpeed(vector&lt;int&gt;&amp; piles, int h) {
        int n = piles.size();
        int high = 0; // 表示吃香蕉的最快速度
        for (auto&amp; i : piles)
        {
            high = max(high, i);
        }

        int left = 1;
        int right = high;
        while (left &lt; right)
        {
            int mid = left + (right - left) / 2;
            if (getHours(piles, mid) &gt; h)
            {
                left = mid + 1;
            }
            else
            {
                right = mid;
            }
        }
        return left;
    }

private:
    int getHours(vector&lt;int&gt;&amp; piles, int speed)
    {
        int hours = 0;
        for (auto&amp; i : piles)
        {
            hours += i / speed;
            if (i % speed &gt; 0)
            {
                hours++;
            }
        }
        return hours;
    }
};</code></pre>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/df06fcdeb30611c8f83439463cc5e84a/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">如何查看KylinOS银河麒麟操作系统版本?</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/ce33b78afb8ddd5e78fca7152229b0a3/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">第三章 Linux的目录结构</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>