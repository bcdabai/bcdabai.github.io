<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>处理死锁和预防死锁的方法 - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="处理死锁和预防死锁的方法" />
<meta property="og:description" content=" 处理死锁的基本方法 目前，处理死锁的方法可归结为以下四种： 1）预防死锁。这是一种较为简单和直观的事先预防的方法。该方法是通过设置某些限制条件，去破坏产生死锁的四个必要条件中的一个或几个条件，来预防发生死锁。预防死锁是一种较易实现的方法，已被广泛使用。但由于所施加的限制条件往往太严格，因而可能导致系统资源利用率和系统吞吐量降低。 2）避免死锁。该方法同样是属于事先预防策略，但它并不需要事先采取各种限制措施去破坏产生死锁的四个必要条件，而是在资源的动态分配过程中，用某种方法去防止系统进入不安全状态，从而避免发生死锁。这种方法只需事先施加较弱的限制条件，便可获得较高的资源利用率及系统吞吐量，但在实现上有一定的难度。目前在较完善的系统中常用此方法来避免发生死锁。 3)检测死锁。这种方法并不需要事先采取任何限制性措施，也不必检查系统是否已经进入不安全区，而是允许系统在运行过程中发生死锁。但可通过系统所设置的检测机构，及时的检测出死锁的发生，并精确的确定与死锁有关的进程和资源；然后采取适当措施从系统中将已发生的死锁清除掉。 4）解除死锁。这是与检测死锁相配套的一种措施。当检测到系统中已经发生死锁时，将进程从死锁状态中解脱出来。常用的方法是撤销或挂起一些进程，以便回收一些资源，再将这些资源分配给已经处于阻塞状态的进程，使之转为就绪态，以继续运行。死锁的检测和解除措施有可能使系统获得较好的资源利用率和吞吐量，但是实现上难度也最大。
预防死锁的基本方法 预防死锁和避免死锁这两种方法实质上都是通过施加某些限制条件，来预防发生死锁。两者的主要差别在于：为预防死锁所施加的限制条件比较严格，这往往会影响进程的并发执行；而为避免死锁所加的限制条件则比较宽松，这给进程的运行提供了较宽松的环境，有利于进程的并发。
一、预防死锁 预防死锁的方法是使四个必要条件中的第2、3、4个条件之一不能成立，来避免发生死锁。至于必要条件1，因为它是由设备的固有特性所决定的，不仅不能改变，还应加以保证。 1）摒弃“请求和保持”条件 在采用这种方法时，系统规定所有进程在开始运行之前，都必须一次性的申请其在整个运行过程所需的全部资源。此时，若系统有足够的资源分配给某进程，便可把其需要的所有资源分配给进程，这样，该进程在整个运行期间便不会再提出资源要求，从而摒弃了请求条件。但在分配资源时，只要有一种资源不能满足某进程的要求，即使其它所需各资源都空闲，也不分配给该进程，而让该进程等待。由于在该进程的等待期间，它并未占用任何资源，因而也摒弃了保持条件，从而避免发生死锁。 这种方法的缺点是：首先表现为资源被严重浪费，因为一个进程是一次性地获得其整个运行过程中所需的全部资源的，且独占资源，其中可能有些资源很少用，甚至在整个运行期间都未使用，这就严重的恶化了系统资源的利用率；其次是使进程延迟运行，仅当进程在获得了其所需的全部资源后，才能开始运行，但可能因有些资源已长期被其它进程占用而使等待该资源的进程迟迟不能运行。 2）摒弃“不剥夺”条件 在采用这种方法时系统规定，进程是逐个地提出对资源的要求的。当一个已经保持了某些资源的进程，再提出新的资源请求而不能立即满足时，必须释放它已经保持了的所有资源，待以后需要时再重新申请。这意味着某一进程已经占有的资源，在运行过程中会被占时释放掉，也可认为是被剥夺了，从而摒弃了“不剥夺”条件。 3）摒弃“环路等待”条件 这种方法中规定，系统将所有资源按类型进行线性排队，并赋予不同的序号。例如，令输入机的序号为1，打印机的序号为2，磁带机为3，磁盘为4.所有进程对资源的请求必须严格按照资源序号递增的次序提出，这样，在所形成的资源分配图中，不可能再出现环路，因而摒弃了“环路等待”条件。
二、系统安全状态 在该方法中把系统的状态分为安全状态和不安全状态，只要能使系统始终处于安全状态，便可避免发生死锁。
1.安全状态 在避免死锁的方法中，允许进程动态的申请资源，但系统在进行资源分配之前，应先计算此次资源分配的安全性。若此次分配不会导致系统进入不安全状态，则将资源分配给进程，否则，令进程等待。 所谓安全状态，是指系统能按某种进程顺序（P1,P2,……,Pn）（称&lt;“P1,P2,…,Pn&gt;序列为安全序列），来为每个进程Pi分配其所需资源，直至满足每个进程对资源的最大需求，使每个进程都可以顺利完成。如果系统无法找到这样一个安全序列，则称系统处于不安全状态。 虽然并非所有的不安全状态都必然会转为死锁状态，但当系统进入不安全状态后，便有可能进而进入死锁状态；反之，只要系统处于安全状态，系统便可避免进入死锁状态。因此，避免死锁的实质在于：系统在进行资源分配时，如何使系统不进入不安全状态。
2.安全状态之例 假定系统中有三个进程P1、P2和P3，共有12台磁带机。进程P1总共要求10台磁带机，P2和P3分别要求4台和9台。假设在T0时刻，进程P1、P2和P3已分别获得5台、2台和2台磁带机，尚有3台空闲未分配，如下表所示： 经分析发现，在T0时刻系统是安全的，因为这时存在一个安全序列《P2,P1,P3》，即只要系统按此进程序列分配资源，就能使每个进程都顺利完成。例如，将剩余的磁带机取2台分配给P2，使之继续运行，待P2完成，便可释放出4台磁带机，于是可用资源增至5台；以后再将这些全部分配给进程P1，使之运行，待P1完成后，将释放出10台磁带机，P3便能获得足够的资源，从而使P1、P2、P3每个进程都能顺利完成。
3.由安全状态向不安全状态的转换。 如果不按照安全序列分配资源，则系统可能会由安全状态进入不安全状态。例如在T0时刻以后，P3又请求1台磁带机，若此时系统把剩余3台中的1台分配给P3，则系统便进入不安全状态。因为此时无法再找到一个安全序列，例如，把剩余的2台分配给P2，这样，在P2完成后只能释放出4台，既不能满足P1尚需5台的要求，也不能满足P3尚需6台的需求，致使它们都无法推进前行，彼此都在等待对方释放资源，即陷入僵局，结果导致死锁。类似地，如果我们将剩余的两台磁带机先分配给P1或P3，也同样都无法使它们推进完成，因此，从给P3分配了第三台磁带机开始，系统便又进入了不安全状态。由此可见，在P3请求资源时，尽管系统中尚有可用的磁带机，但却不能分配给它，必须让P3一直等待到P1和P2完成，释放出资源后再将足够的资源分配给P3，它才能顺利完成。
三、利用银行家算法避免死锁 " />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/89a9449b6e53395dec2be89ecd1947a4/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2017-06-26T16:07:44+08:00" />
<meta property="article:modified_time" content="2017-06-26T16:07:44+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">处理死锁和预防死锁的方法</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <h4 id="处理死锁的基本方法">处理死锁的基本方法</h4> 
<p>目前，处理死锁的方法可归结为以下四种： <br> 1）预防死锁。这是一种较为简单和直观的事先预防的方法。该方法是通过设置某些限制条件，去破坏产生死锁的四个必要条件中的一个或几个条件，来预防发生死锁。预防死锁是一种较易实现的方法，已被广泛使用。但由于所施加的限制条件往往太严格，因而可能导致系统资源利用率和系统吞吐量降低。 <br> 2）避免死锁。该方法同样是属于事先预防策略，但它并不需要事先采取各种限制措施去破坏产生死锁的四个必要条件，而是在资源的动态分配过程中，用某种方法去防止系统进入不安全状态，从而避免发生死锁。这种方法只需事先施加较弱的限制条件，便可获得较高的资源利用率及系统吞吐量，但在实现上有一定的难度。目前在较完善的系统中常用此方法来避免发生死锁。 <br> 3)检测死锁。这种方法并不需要事先采取任何限制性措施，也不必检查系统是否已经进入不安全区，而是允许系统在运行过程中发生死锁。但可通过系统所设置的检测机构，及时的检测出死锁的发生，并精确的确定与死锁有关的进程和资源；然后采取适当措施从系统中将已发生的死锁清除掉。 <br> 4）解除死锁。这是与检测死锁相配套的一种措施。当检测到系统中已经发生死锁时，将进程从死锁状态中解脱出来。常用的方法是撤销或挂起一些进程，以便回收一些资源，再将这些资源分配给已经处于阻塞状态的进程，使之转为就绪态，以继续运行。死锁的检测和解除措施有可能使系统获得较好的资源利用率和吞吐量，但是实现上难度也最大。</p> 
<h4 id="预防死锁的基本方法">预防死锁的基本方法</h4> 
<p>预防死锁和避免死锁这两种方法实质上都是通过施加某些限制条件，来预防发生死锁。两者的主要差别在于：为预防死锁所施加的限制条件比较严格，这往往会影响进程的并发执行；而为避免死锁所加的限制条件则比较宽松，这给进程的运行提供了较宽松的环境，有利于进程的并发。</p> 
<h5 id="一预防死锁">一、预防死锁</h5> 
<p>预防死锁的方法是使四个必要条件中的第2、3、4个条件之一不能成立，来避免发生死锁。至于必要条件1，因为它是由设备的固有特性所决定的，不仅不能改变，还应加以保证。 <br> 1）摒弃“请求和保持”条件 <br> 在采用这种方法时，系统规定所有进程在开始运行之前，都必须一次性的申请其在整个运行过程所需的全部资源。此时，若系统有足够的资源分配给某进程，便可把其需要的所有资源分配给进程，这样，该进程在整个运行期间便不会再提出资源要求，从而摒弃了请求条件。但在分配资源时，只要有一种资源不能满足某进程的要求，即使其它所需各资源都空闲，也不分配给该进程，而让该进程等待。由于在该进程的等待期间，它并未占用任何资源，因而也摒弃了保持条件，从而避免发生死锁。 <br> 这种方法的缺点是：首先表现为资源被严重浪费，因为一个进程是一次性地获得其整个运行过程中所需的全部资源的，且独占资源，其中可能有些资源很少用，甚至在整个运行期间都未使用，这就严重的恶化了系统资源的利用率；其次是使进程延迟运行，仅当进程在获得了其所需的全部资源后，才能开始运行，但可能因有些资源已长期被其它进程占用而使等待该资源的进程迟迟不能运行。 <br> 2）摒弃“不剥夺”条件 <br> 在采用这种方法时系统规定，进程是逐个地提出对资源的要求的。当一个已经保持了某些资源的进程，再提出新的资源请求而不能立即满足时，必须释放它已经保持了的所有资源，待以后需要时再重新申请。这意味着某一进程已经占有的资源，在运行过程中会被占时释放掉，也可认为是被剥夺了，从而摒弃了“不剥夺”条件。 <br> 3）摒弃“环路等待”条件 <br> 这种方法中规定，系统将所有资源按类型进行线性排队，并赋予不同的序号。例如，令输入机的序号为1，打印机的序号为2，磁带机为3，磁盘为4.所有进程对资源的请求必须严格按照资源序号递增的次序提出，这样，在所形成的资源分配图中，不可能再出现环路，因而摒弃了“环路等待”条件。</p> 
<h5 id="二系统安全状态">二、系统安全状态</h5> 
<p>在该方法中把系统的状态分为安全状态和不安全状态，只要能使系统始终处于安全状态，便可避免发生死锁。</p> 
<h6 id="1安全状态">1.安全状态</h6> 
<p>在避免死锁的方法中，允许进程动态的申请资源，但系统在进行资源分配之前，应先计算此次资源分配的安全性。若此次分配不会导致系统进入不安全状态，则将资源分配给进程，否则，令进程等待。 <br> 所谓安全状态，是指系统能按某种进程顺序（P1,P2,……,Pn）（称&lt;“P1,P2,…,Pn&gt;序列为安全序列），来为每个进程Pi分配其所需资源，直至满足每个进程对资源的最大需求，使每个进程都可以顺利完成。如果系统无法找到这样一个安全序列，则称系统处于不安全状态。 <br> 虽然并非所有的不安全状态都必然会转为死锁状态，但当系统进入不安全状态后，便有可能进而进入死锁状态；反之，只要系统处于安全状态，系统便可避免进入死锁状态。因此，避免死锁的实质在于：系统在进行资源分配时，如何使系统不进入不安全状态。</p> 
<h6 id="2安全状态之例">2.安全状态之例</h6> 
<p>假定系统中有三个进程P1、P2和P3，共有12台磁带机。进程P1总共要求10台磁带机，P2和P3分别要求4台和9台。假设在T0时刻，进程P1、P2和P3已分别获得5台、2台和2台磁带机，尚有3台空闲未分配，如下表所示： <br> <img src="https://images2.imgbox.com/8d/6d/Rr3KpHbw_o.png" alt="这里写图片描述" title=""> <br> 经分析发现，在T0时刻系统是安全的，因为这时存在一个安全序列《P2,P1,P3》，即只要系统按此进程序列分配资源，就能使每个进程都顺利完成。例如，将剩余的磁带机取2台分配给P2，使之继续运行，待P2完成，便可释放出4台磁带机，于是可用资源增至5台；以后再将这些全部分配给进程P1，使之运行，待P1完成后，将释放出10台磁带机，P3便能获得足够的资源，从而使P1、P2、P3每个进程都能顺利完成。</p> 
<h6 id="3由安全状态向不安全状态的转换">3.由安全状态向不安全状态的转换。</h6> 
<p>如果不按照安全序列分配资源，则系统可能会由安全状态进入不安全状态。例如在T0时刻以后，P3又请求1台磁带机，若此时系统把剩余3台中的1台分配给P3，则系统便进入不安全状态。因为此时无法再找到一个安全序列，例如，把剩余的2台分配给P2，这样，在P2完成后只能释放出4台，既不能满足P1尚需5台的要求，也不能满足P3尚需6台的需求，致使它们都无法推进前行，彼此都在等待对方释放资源，即陷入僵局，结果导致死锁。类似地，如果我们将剩余的两台磁带机先分配给P1或P3，也同样都无法使它们推进完成，因此，从给P3分配了第三台磁带机开始，系统便又进入了不安全状态。由此可见，在P3请求资源时，尽管系统中尚有可用的磁带机，但却不能分配给它，必须让P3一直等待到P1和P2完成，释放出资源后再将足够的资源分配给P3，它才能顺利完成。</p> 
<h5 id="三利用银行家算法避免死锁">三、利用银行家算法避免死锁</h5>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/1282b43352d42ff43304c3e6018c6861/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">com.microsoft.sqlserver.jdbc.SQLServerException: 将截断字符串或二进制数据。</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/429bfb4f056e66dfb2ebbe2931bf8166/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">codeforces round#420</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>