<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>zynq中三种GPIO的介绍和实现方式 - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="zynq中三种GPIO的介绍和实现方式" />
<meta property="og:description" content="转载链接:https://blog.csdn.net/husipeng86/article/details/52123465
三种GPIO的介绍 学了zynq一段时间，一上来的时候就被zynq的GPIO唬住了，实在没搞清楚zynq的GPIO怎么回事，一会这样，一会那样，最后才慢慢发现zynq至少有3种GPIO可以调用。难怪我觉得每篇介绍GPIO的博客说的有一些不一样呢。
我们先看有哪三种GPIO：MIO、EMIO、AXI_GPIO。其中MIO和EMIO是直接挂在PS上的GPIO。而AXI_GPIO是通过AXI总线挂在PS上的GPIO上。
我们先看一下MIO和EMIO：下图EMIO和MIO的结构。其中MIO分布在BANK0，BANK1，而EMIO则分布在BANK2、BANK3。注意一下几项：
首先、MIO在zynq上的管脚是固定的，而EMIO，是通过PL部分扩展的，所以使用EMIO时候需要在约束文件中分配管脚，所以设计EMIO的程序时，
需要生成PL部分的bit文件，烧写到FPGA中。
其次、由下图可以看出MIO共占54bit，而EMIO占64bit。其中MIO占用IO号为0-53。而EMIO占用IO号为54-117。
再者、无论是EMIO还是MIO都属于PS上的IO，直接由PS操作。在调用头文件，只调用#include &#34;xgpiops.h&#34;即可，而在调用AXI_GPIO时，则需要#include &#34;xgpio.h&#34;。
最后、在设计好bd文件后、系统会自动在路径：..\standalone_bsp_0\ps7_cortexa9_0\include生成 xparameters.h文件.我们可以在
xparameters.h文件中查看我们在bd设计时添加的外设ID。例如我们添加了EMIO，可以查到到该IO的地址和ID号。
[cpp] view plain copy #define XPAR_PS7_GPIO_0_DEVICE_ID 0 #define XPAR_PS7_GPIO_0_BASEADDR 0xE000A000 #define XPAR_PS7_GPIO_0_HIGHADDR 0xE000AFFF 再举例添加了两个AXI_GPIO，例化为BTNS_4BIT和SW_4BIT [cpp] view plain copy /* Definitions for driver GPIO */ #define XPAR_XGPIO_NUM_INSTANCES 2 /* Definitions for peripheral BTNS_4BIT */ #define XPAR_BTNS_4BIT_BASEADDR 0x41210000 #define XPAR_BTNS_4BIT_HIGHADDR 0x4121FFFF #define XPAR_BTNS_4BIT_DEVICE_ID 0 #define XPAR_BTNS_4BIT_INTERRUPT_PRESENT 0 #define XPAR_BTNS_4BIT_IS_DUAL 0 /* Definitions for peripheral SW_4BIT */ #define XPAR_SW_4BIT_BASEADDR 0x41200000 #define XPAR_SW_4BIT_HIGHADDR 0x4120FFFF #define XPAR_SW_4BIT_DEVICE_ID 1 #define XPAR_SW_4BIT_INTERRUPT_PRESENT 0 #define XPAR_SW_4BIT_IS_DUAL 0 再来看一下，AXI_GPIO相当于GPIO的IP核，我们调用时是占用相应AXI总线地址空间，如下图，占用地址为0x41200000和0x41210000" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/20d977dc1bb37d2076e3a7000b366623/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2018-05-14T11:45:33+08:00" />
<meta property="article:modified_time" content="2018-05-14T11:45:33+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">zynq中三种GPIO的介绍和实现方式</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p>转载链接:https://blog.csdn.net/husipeng86/article/details/52123465</p> 
<p></p> 
<h3>三种GPIO的介绍</h3> 
<p>学了zynq一段时间，一上来的时候就被zynq的GPIO唬住了，实在没搞清楚zynq的GPIO怎么回事，一会这样，一会那样，最后才慢慢发现zynq至少有3种GPIO可以调用。难怪我觉得每篇介绍GPIO的博客说的有一些不一样呢。</p> 
<p><span style="white-space:pre;"></span><span style="white-space:pre;"></span>我们先看有哪三种GPIO：MIO、EMIO、AXI_GPIO。其中MIO和EMIO是直接挂在PS上的GPIO。而AXI_GPIO是通过AXI总线挂在PS上的GPIO上。</p> 
<p><span style="white-space:pre;"></span>我们先看一下MIO和EMIO：下图EMIO和MIO的结构。其中MIO分布在BANK0，BANK1，而EMIO则分布在BANK2、BANK3。注意一下几项：</p> 
<p><span style="white-space:pre;"></span>首先、MIO在zynq上的管脚是固定的，而EMIO，是通过PL部分扩展的，<span style="color:#cc0000;">所以使用EMIO时候需要在约束文件中分配管脚，</span>所以设计EMIO的程序时，</p> 
<p>需要生成PL部分的bit文件，烧写到FPGA中。</p> 
<p><span style="white-space:pre;"></span>其次、由下图可以看出MIO共占54bit，而EMIO占64bit。其中MIO占用IO号为0-53。而EMIO占用IO号为54-117。</p> 
<p><span style="white-space:pre;"></span>再者、无论是EMIO还是MIO都属于PS上的IO，直接由PS操作。在调用头文件，只调用#include "xgpio<span style="color:#cc0000;">ps</span>.h"即可，而在调用AXI_GPIO时，则需要#include "xgpio.h"。</p> 
<p><span style="white-space:pre;"></span>最后、<span style="font-family:Helvetica;font-size:10pt;">在设计好bd文件后、系统会自动在路径：<strong>..</strong><span style="font-family:'Helvetica-Bold';font-size:13.3333330154419px;"><strong>\standalone_bsp_0\ps7_cortexa9_0</strong></span><span style="font-family:'Helvetica-Bold';font-size:10pt;"><strong>\include</strong></span>生成 <span style="font-family:'Helvetica-Bold';font-size:10pt;"><strong>xparameters.h</strong><span style="font-family:Helvetica;font-size:10pt;">文件.我们可以在</span></span></span></p> 
<div> 
 <span style="font-family:'Helvetica-Bold';"><span style="font-size:13.3333330154419px;"><span style="font-family:'Helvetica-Bold';font-size:13.3333330154419px;"><strong>xparameters.h</strong></span><span style="font-family:'Helvetica-Bold';font-size:13.3333330154419px;">文件中查看我们在bd设计时添加的外设ID。例如我们添加了EMIO，可以查到到该IO的地址和ID号。</span><br></span></span> 
</div> 
<div> 
 <span style="font-family:'Helvetica-Bold';"><span style="font-size:13.3333330154419px;"><span style="font-family:'Helvetica-Bold';font-size:13.3333330154419px;"></span></span></span> 
 <div class="dp-highlighter bg_cpp"> 
  <div class="bar"> 
   <div class="tools"> 
    <strong>[cpp]</strong> 
    <a href="https://blog.csdn.net/lg2lh/article/details/49499587#" class="ViewSource" title="view plain">view plain</a> 
     <a href="https://blog.csdn.net/lg2lh/article/details/49499587#" class="CopyToClipboard" title="copy">copy</a> 
      
   </div> 
  </div> 
  <ol start="1" class="dp-cpp"><li class="alt"><span class="preprocessor">#define XPAR_PS7_GPIO_0_DEVICE_ID 0</span>  </li><li><span class="preprocessor">#define XPAR_PS7_GPIO_0_BASEADDR 0xE000A000</span>  </li><li class="alt"><span class="preprocessor">#define XPAR_PS7_GPIO_0_HIGHADDR 0xE000AFFF</span>  </li></ol> 
 </div>再举例添加了两个AXI_GPIO，例化为BTNS_4BIT和SW_4BIT 
</div> 
<div> 
 <span style="font-family:'Helvetica-Bold';"><span style="font-size:13.3333330154419px;"><span style="font-family:'Helvetica-Bold';font-size:13.3333330154419px;"></span></span></span> 
 <div class="dp-highlighter bg_cpp"> 
  <div class="bar"> 
   <div class="tools"> 
    <strong>[cpp]</strong> 
    <a href="https://blog.csdn.net/lg2lh/article/details/49499587#" class="ViewSource" title="view plain">view plain</a> 
     <a href="https://blog.csdn.net/lg2lh/article/details/49499587#" class="CopyToClipboard" title="copy">copy</a> 
      
   </div> 
  </div> 
  <ol start="1" class="dp-cpp"><li class="alt"><span class="comment">/* Definitions for driver GPIO */</span>  </li><li><span class="preprocessor">#define XPAR_XGPIO_NUM_INSTANCES 2</span>  </li><li class="alt">  </li><li><span class="comment">/* Definitions for peripheral BTNS_4BIT */</span>  </li><li class="alt"><span class="preprocessor">#define XPAR_BTNS_4BIT_BASEADDR 0x41210000</span>  </li><li><span class="preprocessor">#define XPAR_BTNS_4BIT_HIGHADDR 0x4121FFFF</span>  </li><li class="alt"><span class="preprocessor">#define XPAR_BTNS_4BIT_DEVICE_ID 0</span>  </li><li><span class="preprocessor">#define XPAR_BTNS_4BIT_INTERRUPT_PRESENT 0</span>  </li><li class="alt"><span class="preprocessor">#define XPAR_BTNS_4BIT_IS_DUAL 0</span>  </li><li>  </li><li class="alt">  </li><li><span class="comment">/* Definitions for peripheral SW_4BIT */</span>  </li><li class="alt"><span class="preprocessor">#define XPAR_SW_4BIT_BASEADDR 0x41200000</span>  </li><li><span class="preprocessor">#define XPAR_SW_4BIT_HIGHADDR 0x4120FFFF</span>  </li><li class="alt"><span class="preprocessor">#define XPAR_SW_4BIT_DEVICE_ID 1</span>  </li><li><span class="preprocessor">#define XPAR_SW_4BIT_INTERRUPT_PRESENT 0</span>  </li><li class="alt"><span class="preprocessor">#define XPAR_SW_4BIT_IS_DUAL 0</span>  </li></ol> 
 </div> 
</div> 
<div> 
 <br> 
</div> 
<p><img src="https://images2.imgbox.com/0f/dc/cfGpESQI_o.jpg" alt=""><img src="https://images2.imgbox.com/d0/20/zgApjdjt_o.jpg" alt=""><br></p> 
<p><span style="white-space:pre;"></span>再来看一下，AXI_GPIO相当于GPIO的IP核，我们调用时是占用相应AXI总线地址空间，如下图，占用地址为0x41200000和0x41210000</p> 
<img src="https://images2.imgbox.com/ff/98/o7o4yyrC_o.png" alt=""> 
<br> 
<p><br></p> 
<p>MIO和EMIO方式是使用PS部分的GPIO模块来实现GPIO功能的，支持54个MIO（可输出三态）、64个输入和128个输出（64个输出和64个输出使能）EMIO</p> 
<p>而IP方式是在PL部分实现 GPIO功能，PS部分通过M_AXI_GP接口来控制该GPIO IP模块；另外EMIO模块虽然使用PS部分GPIO但也使用了PL部分的管脚资源。</p> 
<h3>MIO方式实现GPIO</h3> 
<p>vivado中zynq设置如下图</p> 
<p><img src="https://images2.imgbox.com/a9/d0/mxB1bqKb_o.jpg" alt="mio_vivado中配置" title=""></p> 
<p>由图中可见要选中打开GPIO，其下自动显示可用于GPIO的MIO（当MIO作为其他功能时就不能作为GPIO使用了），其中MIO 7、MIO 8只能作为输出使用，因为它们用于VMODE管脚（参考UG585第14章：14.2.3）</p> 
<p>软件部分如下</p> 
<pre class="prettyprint"><code class="language-c hljs has-numbering"><span class="hljs-preprocessor">#include &lt;stdio.h&gt;</span>
<span class="hljs-preprocessor">#include "platform.h"</span>
<span class="hljs-preprocessor">#include "xgpiops.h"</span>

<span class="hljs-preprocessor">#define LED1    0</span>
<span class="hljs-preprocessor">#define LED2    9</span>

<span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> delay(<span class="hljs-keyword">int</span> dly)
{
    <span class="hljs-keyword">int</span> i, j;
    <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; dly; i++) {
        <span class="hljs-keyword">for</span> (j = <span class="hljs-number">0</span>; j &lt; <span class="hljs-number">0xffff</span>; j++) {
            ;
        }
    }
}

<span class="hljs-keyword">int</span> main()
{
    <span class="hljs-keyword">int</span> Status;
    XGpioPs_Config *ConfigPtr;
    XGpioPs Gpio;

    init_platform();

    ConfigPtr = XGpioPs_LookupConfig(XPAR_PS7_GPIO_0_DEVICE_ID);
    Status = XGpioPs_CfgInitialize(&amp;Gpio, ConfigPtr,
                    ConfigPtr-&gt;BaseAddr);
    <span class="hljs-keyword">if</span> (Status != XST_SUCCESS){
        <span class="hljs-keyword">return</span> XST_FAILURE;
    }

    XGpioPs_SetDirectionPin(&amp;Gpio, LED1, <span class="hljs-number">1</span>);
    XGpioPs_SetDirectionPin(&amp;Gpio, LED2, <span class="hljs-number">1</span>);
    XGpioPs_SetOutputEnablePin(&amp;Gpio, LED1, <span class="hljs-number">1</span>);
    XGpioPs_SetOutputEnablePin(&amp;Gpio, LED2, <span class="hljs-number">1</span>);

    <span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>) {
        XGpioPs_WritePin(&amp;Gpio, LED1, <span class="hljs-number">0</span>);
        XGpioPs_WritePin(&amp;Gpio, LED2, <span class="hljs-number">1</span>);
        delay(<span class="hljs-number">1000</span>);
        XGpioPs_WritePin(&amp;Gpio, LED1, <span class="hljs-number">1</span>);
        XGpioPs_WritePin(&amp;Gpio, LED2, <span class="hljs-number">0</span>);
        delay(<span class="hljs-number">1000</span>);
    }
    cleanup_platform();
}</code></pre> 
<h3>EMIO方式实现GPIO</h3> 
<p>vivado中zynq设置如下图</p> 
<p><img src="https://images2.imgbox.com/fe/f2/oKHcRlLq_o.jpg" alt="emio_vivado中配置" title=""></p> 
<p>图中可知GPIO中选择使用EMIO，并选择位宽（这里例子中选择3）；其vivado中连接如下图</p> 
<p><img src="https://images2.imgbox.com/d8/18/tJSZJJUs_o.jpg" alt="emio_vivado中连接" title=""></p> 
<p>上图可知除了FIXED IO和DDR接口外，还多了3个3对（一个输入，一个输出和一个输出使能）GPIO管脚。</p> 
<p>不同于MIO，这里三个IO管脚（一个输入，一个输出和一个输出使能在自动生成的顶层模块中合并为一个IO）要绑定到芯片对应管脚上</p> 
<p>软件部分如下</p> 
<pre class="prettyprint"><code class="language-c hljs has-numbering"><span class="hljs-preprocessor">#include &lt;stdio.h&gt;</span>
<span class="hljs-preprocessor">#include "platform.h"</span>
<span class="hljs-preprocessor">#include "xgpiops.h"</span>

<span class="hljs-preprocessor">#define LED_R   54</span>
<span class="hljs-preprocessor">#define LED_G   55</span>
<span class="hljs-preprocessor">#define LED_B   56</span>
<span class="hljs-preprocessor">#define LED_ON  0</span>
<span class="hljs-preprocessor">#define LED_OFF 1</span>

<span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> delay(<span class="hljs-keyword">int</span> dly)
{
    <span class="hljs-keyword">int</span> i, j;
    <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; dly; i++) {
        <span class="hljs-keyword">for</span> (j = <span class="hljs-number">0</span>; j &lt; <span class="hljs-number">0xffff</span>; j++) {
            ;
        }
    }
}

<span class="hljs-keyword">int</span> main()
{
    <span class="hljs-keyword">int</span> Status;
    XGpioPs_Config *ConfigPtr;
    XGpioPs Gpio;

    init_platform();

    ConfigPtr = XGpioPs_LookupConfig(XPAR_PS7_GPIO_0_DEVICE_ID);
    Status = XGpioPs_CfgInitialize(&amp;Gpio, ConfigPtr,
                    ConfigPtr-&gt;BaseAddr);
    <span class="hljs-keyword">if</span> (Status != XST_SUCCESS) {
        print(<span class="hljs-string">"cfg init err\n"</span>);
        <span class="hljs-keyword">return</span> XST_FAILURE;
    }
    XGpioPs_SetDirectionPin(&amp;Gpio, LED_R, <span class="hljs-number">1</span>);
    XGpioPs_SetOutputEnablePin(&amp;Gpio, LED_R, <span class="hljs-number">1</span>);
    XGpioPs_SetDirectionPin(&amp;Gpio, LED_G, <span class="hljs-number">1</span>);
    XGpioPs_SetOutputEnablePin(&amp;Gpio, LED_G, <span class="hljs-number">1</span>);
    XGpioPs_SetDirectionPin(&amp;Gpio, LED_B, <span class="hljs-number">1</span>);
    XGpioPs_SetOutputEnablePin(&amp;Gpio, LED_B, <span class="hljs-number">1</span>);

    <span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>) {
        XGpioPs_WritePin(&amp;Gpio, LED_R, LED_ON);
        delay(<span class="hljs-number">1000</span>);
        XGpioPs_WritePin(&amp;Gpio, LED_G, LED_ON);
        delay(<span class="hljs-number">1000</span>);
        XGpioPs_WritePin(&amp;Gpio, LED_B, LED_ON);
        delay(<span class="hljs-number">1000</span>);
        XGpioPs_WritePin(&amp;Gpio, LED_R, LED_OFF);
        delay(<span class="hljs-number">1000</span>);
        XGpioPs_WritePin(&amp;Gpio, LED_G, LED_OFF);
        delay(<span class="hljs-number">1000</span>);
        XGpioPs_WritePin(&amp;Gpio, LED_B, LED_OFF);
        delay(<span class="hljs-number">1000</span>);
    }
    cleanup_platform();
}</code></pre> 
<p>类似MIO方式（都为PS部分GPIO操作），设置为输出并设置输出使能，但要注意这里的GPIO号是从54开始的3个。</p> 
<h3>IP方式实现GPIO</h3> 
<p>vivado中zynq设置如下图</p> 
<p><img src="https://images2.imgbox.com/81/04/fGOCB2z6_o.jpg" alt="axi_gpio_vivado中配置" title=""></p> 
<p>图中可知GPIO中MIO和EMIO都不选择，但要打开M_AXI_GP接口（这里选择M_AXI_GP0）和复位管脚，如下图</p> 
<p><img src="https://images2.imgbox.com/75/ed/OgUvYYA1_o.jpg" alt="axi_gpio_vivado中配置_GP和复位" title=""></p> 
<p>当然用到了PL部分逻辑则至少需要一个时钟输出到PL部分，这里选择FCLK_CLK0输出50MHz，如下图</p> 
<p><img src="https://images2.imgbox.com/67/ad/r0WF2PdP_o.jpg" alt="axi_gpio_vivado中配置_时钟" title=""></p> 
<p>推荐加入zynq后，不要自动连接，再加入gpio并位宽设置为3，具体设置如下图</p> 
<p><img src="https://images2.imgbox.com/0e/c7/93PE4GjO_o.jpg" alt="axi_gpio_ip设置" title=""></p> 
<p>GPIO设置好后，再点击上面的蓝色字体的自动连接，即可得到上面的连接，这样可以减少手动连接量。</p> 
<p>最后vivado中连接如下图</p> 
<p><img src="https://images2.imgbox.com/fc/cd/Nu7fUHXj_o.jpg" alt="axi_gpio_vivado中连接" title=""></p> 
<p>与EMIO类似需要将顶层三个GPIO管脚要绑定到芯片对应管脚上。</p> 
<p>软件部分如下</p> 
<pre class="prettyprint"><code class="language-c hljs has-numbering"><span class="hljs-preprocessor">#include &lt;stdio.h&gt;</span>
<span class="hljs-preprocessor">#include "platform.h"</span>
<span class="hljs-preprocessor">#include "xgpio.h"</span>

<span class="hljs-preprocessor">#define AXI_GPIO_DEVICE_ID  XPAR_GPIO_0_DEVICE_ID</span>
<span class="hljs-preprocessor">#define XGPIO_BANK1         1</span>
<span class="hljs-preprocessor">#define XGPIO_BANK2         2</span>

<span class="hljs-preprocessor">#define LED34_R_PIN         0x01</span>
<span class="hljs-preprocessor">#define LED34_G_PIN         0x02</span>
<span class="hljs-preprocessor">#define LED34_B_PIN         0x04</span>

<span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> delay(<span class="hljs-keyword">int</span> dly)
{
    <span class="hljs-keyword">int</span> i, j;
    <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; dly; i++) {
        <span class="hljs-keyword">for</span> (j = <span class="hljs-number">0</span>; j &lt; <span class="hljs-number">0xffff</span>; j++) {
            ;
        }
    }
}

<span class="hljs-keyword">int</span> main()
{
    XGpio_Config *XGpioCfg;
    XGpio XGpio;
    <span class="hljs-keyword">int</span> Status;

    init_platform();

    XGpioCfg = XGpio_LookupConfig(AXI_GPIO_DEVICE_ID);
    Status = XGpio_CfgInitialize(&amp;XGpio, XGpioCfg, XGpioCfg-&gt;BaseAddress);
    <span class="hljs-keyword">if</span> (Status != XST_SUCCESS) {
        <span class="hljs-keyword">return</span> XST_FAILURE;
    }

    XGpio_SetDataDirection(&amp;XGpio, XGPIO_BANK1, ~(LED34_R_PIN | LED34_G_PIN | LED34_B_PIN));
    XGpio_DiscreteWrite(&amp;XGpio, XGPIO_BANK1, LED34_R_PIN | LED34_G_PIN | LED34_B_PIN);
    <span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>) {
        XGpio_DiscreteWrite(&amp;XGpio, XGPIO_BANK1, ~LED34_R_PIN);
        delay(<span class="hljs-number">1000</span>);
        XGpio_DiscreteWrite(&amp;XGpio, XGPIO_BANK1, ~(LED34_R_PIN | LED34_G_PIN));
        delay(<span class="hljs-number">1000</span>);
        XGpio_DiscreteWrite(&amp;XGpio, XGPIO_BANK1, ~(LED34_R_PIN | LED34_G_PIN | LED34_B_PIN));
        delay(<span class="hljs-number">1000</span>);
        XGpio_DiscreteWrite(&amp;XGpio, XGPIO_BANK1, ~(LED34_G_PIN | LED34_B_PIN));
        delay(<span class="hljs-number">1000</span>);
        XGpio_DiscreteWrite(&amp;XGpio, XGPIO_BANK1, ~(LED34_B_PIN));
        delay(<span class="hljs-number">1000</span>);
        XGpio_DiscreteWrite(&amp;XGpio, XGPIO_BANK1, LED34_R_PIN | LED34_G_PIN | LED34_B_PIN);
        delay(<span class="hljs-number">1000</span>);
    }
    cleanup_platform();
    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}</code></pre> 
<p>这里实现的功能与EMIO方式中功能相同，当时IP方式中为PL部分实现的GPIO，所以调用的函数与前面两种GPIO实现函数不同，注意包含的GPIO头文件，前两种是<code>#include "xgpiops.h"</code>而这最后一种为<code>#include "xgpio.h"</code></p> 
<h3>总结</h3> 
<p>MIO和EMIO方式使用PS部分的GPIO模块，其中MIO方式不占用PL部分资源，其输出管脚只能为固定的54个（而且要在未被其它外设使用的情况下），EMIO方式会占用PL的管脚资源，其管脚可在PL部分任意选择（除特殊功能管脚），IP方式除了占用PL部分管脚资源外还会占用PL部分逻辑资源，所以其GPIO功能在PL部分实现其调用函数也和前两种不同，最后EMIO和IP方式在vivado都需要绑定管脚。</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/034c5cefa2042376c7e923708990bad0/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">#region</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/5471ce55a8665d20eb8bcf0587765f96/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">原excel有合并单元格这种格式，openpyxl打开然后保存边框消失的问题</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>