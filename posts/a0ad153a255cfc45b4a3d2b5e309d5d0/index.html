<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>JUnit与Spring的整合——JUnit的TestCase如何自动注入Spring容器托管的对象 - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="JUnit与Spring的整合——JUnit的TestCase如何自动注入Spring容器托管的对象" />
<meta property="og:description" content="问题 在Java中，一般使用JUnit作为单元测试框架，测试的对象一般是Service和DAO，也可能是RemoteService和Controller。所有这些测试对象基本都是Spring托管的，不会直接new出来。而每个TestCase类却是由JUnit创建的。如何在每个TestCase实例中注入这些依赖呢？
预期效果 我们希望能够达到这样的效果：
package me.arganzheng.study; import static org.junit.Assert.*; import org.junit.Test; import org.springframework.beans.factory.annotation.Autowired; /** * @author arganzheng */ public class FooServiceTest{ @Autowired private FooService fooService; @Test public void testSaveFoo() { Foo foo = new Foo(); // ... long id = fooService.saveFoo(foo); assertTrue(id &gt; 0); } } 解决思路 其实在我前面的文章：Quartz与Spring的整合-Quartz中的job如何自动注入spring容器托管的对象，已经详细的讨论过这个问题了。Quartz是一个框架，Junit同样是个框架，Spring对于接入外部框架，采用了非常一致的做法。对于依赖注入，不外乎就是这个步骤：
首先，找到外部框架创建实例的地方（类或者接口），比如Quartz的jobFactory，默认为org.quartz.simpl.SimpleJobFactory,也可以配置为org.quartz.simpl.PropertySettingJobFactory。这两个类都是实现了org.quartz.spi.JobFactory接口。对于JUnit4.5&#43;，则是org.junit.runners.BlockJUnit4ClassRunner类中的createTest方法。
/** * Returns a new fixture for running a test. Default implementation executes * the test class&#39;s no-argument constructor (validation should have ensured * one exists)." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/a0ad153a255cfc45b4a3d2b5e309d5d0/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2015-05-13T10:03:44+08:00" />
<meta property="article:modified_time" content="2015-05-13T10:03:44+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">JUnit与Spring的整合——JUnit的TestCase如何自动注入Spring容器托管的对象</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <h3>问题</h3> 
<p>在Java中，一般使用JUnit作为单元测试框架，测试的对象一般是Service和DAO，也可能是RemoteService和Controller。所有这些测试对象基本都是Spring托管的，不会直接new出来。而每个TestCase类却是由JUnit创建的。如何在每个TestCase实例中注入这些依赖呢？</p> 
<h3>预期效果</h3> 
<p>我们希望能够达到这样的效果：</p> 
<pre class="prettyprint prettyprinted" style=""><code class="prettyprint"><span class="kwd">package</span><span class="pln"> me</span><span class="pun">.</span><span class="pln">arganzheng</span><span class="pun">.</span><span class="pln">study</span><span class="pun">;</span><span class="pln">
</span><span class="kwd">import</span><span class="pln"> </span><span class="kwd">static</span><span class="pln"> org</span><span class="pun">.</span><span class="pln">junit</span><span class="pun">.</span><span class="typ">Assert</span><span class="pun">.*;</span><span class="pln">
</span><span class="kwd">import</span><span class="pln"> org</span><span class="pun">.</span><span class="pln">junit</span><span class="pun">.</span><span class="typ">Test</span><span class="pun">;</span><span class="pln">
</span><span class="kwd">import</span><span class="pln"> org</span><span class="pun">.</span><span class="pln">springframework</span><span class="pun">.</span><span class="pln">beans</span><span class="pun">.</span><span class="pln">factory</span><span class="pun">.</span><span class="pln">annotation</span><span class="pun">.</span><span class="typ">Autowired</span><span class="pun">;</span><span class="pln">
</span><span class="com">/**
 * @author arganzheng
 */</span><span class="pln">
</span><span class="kwd">public</span><span class="pln"> </span><span class="kwd">class</span><span class="pln"> </span><span class="typ">FooServiceTest</span><span class="pun">{<!-- --></span><span class="pln">
    </span><span class="lit">@Autowired</span><span class="pln">
    </span><span class="kwd">private</span><span class="pln"> </span><span class="typ">FooService</span><span class="pln"> fooService</span><span class="pun">;</span><span class="pln">
    </span><span class="lit">@Test</span><span class="pln">
    </span><span class="kwd">public</span><span class="pln"> </span><span class="kwd">void</span><span class="pln"> testSaveFoo</span><span class="pun">()</span><span class="pln"> </span><span class="pun">{<!-- --></span><span class="pln">
        </span><span class="typ">Foo</span><span class="pln"> foo </span><span class="pun">=</span><span class="pln"> </span><span class="kwd">new</span><span class="pln"> </span><span class="typ">Foo</span><span class="pun">();</span><span class="pln">
        </span><span class="com">// ...</span><span class="pln">
        </span><span class="kwd">long</span><span class="pln"> id </span><span class="pun">=</span><span class="pln"> fooService</span><span class="pun">.</span><span class="pln">saveFoo</span><span class="pun">(</span><span class="pln">foo</span><span class="pun">);</span><span class="pln">
        assertTrue</span><span class="pun">(</span><span class="pln">id </span><span class="pun">&gt;</span><span class="pln"> </span><span class="lit">0</span><span class="pun">);</span><span class="pln">
    </span><span class="pun">}</span><span class="pln">
</span><span class="pun">}</span></code></pre> 
<h3>解决思路</h3> 
<p>其实在我前面的文章：<a target="_blank" rel="nofollow noopener noreferrer" href="http://blog.arganzheng.me/posts/quartz-and-spring-integration-ioc-autowire.html">Quartz与Spring的整合-Quartz中的job如何自动注入spring容器托管的对象</a>，已经详细的讨论过这个问题了。Quartz是一个框架，Junit同样是个框架，Spring对于接入外部框架，采用了非常一致的做法。对于依赖注入，不外乎就是这个步骤：</p> 
<ol><li> <p>首先，找到外部框架创建实例的地方（类或者接口），比如Quartz的jobFactory，默认为<code class="prettyprint prettyprinted" style=""><span class="pln">org</span><span class="pun">.</span><span class="pln">quartz</span><span class="pun">.</span><span class="pln">simpl</span><span class="pun">.</span><span class="typ">SimpleJobFactory</span></code>,也可以配置为<code class="prettyprint prettyprinted" style=""><span class="pln">org</span><span class="pun">.</span><span class="pln">quartz</span><span class="pun">.</span><span class="pln">simpl</span><span class="pun">.</span><span class="typ">PropertySettingJobFactory</span></code>。这两个类都是实现了<code class="prettyprint prettyprinted" style=""><span class="pln">org</span><span class="pun">.</span><span class="pln">quartz</span><span class="pun">.</span><span class="pln">spi</span><span class="pun">.</span><span class="typ">JobFactory</span></code>接口。对于JUnit4.5+，则是<code class="prettyprint prettyprinted" style=""><span class="pln">org</span><span class="pun">.</span><span class="pln">junit</span><span class="pun">.</span><span class="pln">runners</span><span class="pun">.</span><span class="typ">BlockJUnit4ClassRunner</span></code>类中的<code class="prettyprint prettyprinted" style=""><span class="pln">createTest</span></code>方法。</p> <pre class="prettyprint prettyprinted" style=""><code class="prettyprint"><span class="pln"> </span><span class="com">/**
  * Returns a new fixture for running a test. Default implementation executes
  * the test class's no-argument constructor (validation should have ensured
  * one exists).
  */</span><span class="pln">
 </span><span class="kwd">protected</span><span class="pln"> </span><span class="typ">Object</span><span class="pln"> createTest</span><span class="pun">()</span><span class="pln"> </span><span class="kwd">throws</span><span class="pln"> </span><span class="typ">Exception</span><span class="pln"> </span><span class="pun">{<!-- --></span><span class="pln">
     </span><span class="kwd">return</span><span class="pln"> getTestClass</span><span class="pun">().</span><span class="pln">getOnlyConstructor</span><span class="pun">().</span><span class="pln">newInstance</span><span class="pun">();</span><span class="pln">
 </span><span class="pun">}</span></code></pre> </li><li> <p>继承或者组合这些框架类，如果需要使用他们封装的一些方法的话。如果这些类是有实现接口的，那么也可以直接实现接口，与他们并行。然后对创建出来的对象进行依赖注入。</p> </li></ol> 
<p>比如在Quartz中，Spring采用的是直接实现<code class="prettyprint prettyprinted" style=""><span class="pln">org</span><span class="pun">.</span><span class="pln">quartz</span><span class="pun">.</span><span class="pln">spi</span><span class="pun">.</span><span class="typ">JobFactory</span></code>接口的方式：</p> 
<pre class="prettyprint prettyprinted" style=""><code class="prettyprint"><span class="pln">    </span><span class="kwd">public</span><span class="pln"> </span><span class="kwd">class</span><span class="pln"> </span><span class="typ">SpringBeanJobFactory</span><span class="pln"> </span><span class="kwd">extends</span><span class="pln"> </span><span class="typ">AdaptableJobFactory</span><span class="pln"> </span><span class="kwd">implements</span><span class="pln"> </span><span class="typ">SchedulerContextAware</span><span class="pln"> </span><span class="pun">{<!-- --></span><span class="pln">
        </span><span class="pun">...</span><span class="pln">
    </span><span class="pun">}</span><span class="pln">
    </span><span class="kwd">public</span><span class="pln"> </span><span class="kwd">class</span><span class="pln"> </span><span class="typ">AdaptableJobFactory</span><span class="pln"> </span><span class="kwd">implements</span><span class="pln"> </span><span class="typ">JobFactory</span><span class="pln"> </span><span class="pun">{<!-- --></span><span class="pln">
        </span><span class="pun">...</span><span class="pln">
    </span><span class="pun">}</span></code></pre> 
<p>但是Spring提供的<code class="prettyprint prettyprinted" style=""><span class="pln">org</span><span class="pun">.</span><span class="pln">springframework</span><span class="pun">.</span><span class="pln">scheduling</span><span class="pun">.</span><span class="pln">quartz</span><span class="pun">.</span><span class="typ">SpringBeanJobFactory</span></code>并没有自动依赖注入，它其实也是简单的根据job类名直接创建类：</p> 
<pre class="prettyprint prettyprinted" style=""><code class="prettyprint"><span class="pln">    </span><span class="com">/**
     * Create an instance of the specified job class.
     * &lt;p&gt;Can be overridden to post-process the job instance.
     * @param bundle the TriggerFiredBundle from which the JobDetail
     * and other info relating to the trigger firing can be obtained
     * @return the job instance
     * @throws Exception if job instantiation failed
     */</span><span class="pln">
    </span><span class="kwd">protected</span><span class="pln"> </span><span class="typ">Object</span><span class="pln"> createJobInstance</span><span class="pun">(</span><span class="typ">TriggerFiredBundle</span><span class="pln"> bundle</span><span class="pun">)</span><span class="pln"> </span><span class="kwd">throws</span><span class="pln"> </span><span class="typ">Exception</span><span class="pln"> </span><span class="pun">{<!-- --></span><span class="pln">
        </span><span class="kwd">return</span><span class="pln"> bundle</span><span class="pun">.</span><span class="pln">getJobDetail</span><span class="pun">().</span><span class="pln">getJobClass</span><span class="pun">().</span><span class="pln">newInstance</span><span class="pun">();</span><span class="pln">
    </span><span class="pun">}</span></code></pre> 
<p>不过正如它注释所说的，<strong><code class="prettyprint prettyprinted" style=""><span class="typ">Can</span><span class="pln"> be overridden to post</span><span class="pun">-</span><span class="pln">process the job instance</span></code></strong>，我们的做法也正是继承了<code class="prettyprint prettyprinted" style=""><span class="pln">org</span><span class="pun">.</span><span class="pln">springframework</span><span class="pun">.</span><span class="pln">scheduling</span><span class="pun">.</span><span class="pln">quartz</span><span class="pun">.</span><span class="typ">SpringBeanJobFactory</span></code>，然后覆盖它的这个方法：</p> 
<pre class="prettyprint prettyprinted" style=""><code class="prettyprint"><span class="kwd">public</span><span class="pln"> </span><span class="kwd">class</span><span class="pln"> </span><span class="typ">OurSpringBeanJobFactory</span><span class="pln"> </span><span class="kwd">extends</span><span class="pln"> org</span><span class="pun">.</span><span class="pln">springframework</span><span class="pun">.</span><span class="pln">scheduling</span><span class="pun">.</span><span class="pln">quartz</span><span class="pun">.</span><span class="typ">SpringBeanJobFactory</span><span class="pun">{<!-- --></span><span class="pln">
    </span><span class="lit">@Autowire</span><span class="pln">
    </span><span class="kwd">private</span><span class="pln"> </span><span class="typ">AutowireCapableBeanFactory</span><span class="pln"> beanFactory</span><span class="pun">;</span><span class="pln">
    </span><span class="com">/**
     * 这里我们覆盖了super的createJobInstance方法，对其创建出来的类再进行autowire。
     */</span><span class="pln">
    </span><span class="lit">@Override</span><span class="pln">
    </span><span class="kwd">protected</span><span class="pln"> </span><span class="typ">Object</span><span class="pln"> createJobInstance</span><span class="pun">(</span><span class="typ">TriggerFiredBundle</span><span class="pln"> bundle</span><span class="pun">)</span><span class="pln"> </span><span class="kwd">throws</span><span class="pln"> </span><span class="typ">Exception</span><span class="pln"> </span><span class="pun">{<!-- --></span><span class="pln">
        </span><span class="typ">Object</span><span class="pln"> jobInstance </span><span class="pun">=</span><span class="pln"> </span><span class="kwd">super</span><span class="pun">.</span><span class="pln">createJobInstance</span><span class="pun">(</span><span class="pln">bundle</span><span class="pun">);</span><span class="pln">
        beanFactory</span><span class="pun">.</span><span class="pln">autowireBean</span><span class="pun">(</span><span class="pln">jobInstance</span><span class="pun">);</span><span class="pln">
        </span><span class="kwd">return</span><span class="pln"> jobInstance</span><span class="pun">;</span><span class="pln">
    </span><span class="pun">}</span><span class="pln">
</span><span class="pun">｝</span></code></pre> 
<p>由于<code class="prettyprint prettyprinted" style=""><span class="typ">OurSpringBeanJobFactory</span></code>是配置在Spring容器中，默认就具备拿到ApplicationContext的能力。当然就可以做ApplicationContext能够做的任何事情。</p> 
<h5>题外话</h5> 
<pre class="prettyprint prettyprinted" style=""><code class="prettyprint"><span class="pun">这里体现了框架设计一个很重要的原则：开闭原则——针对修改关闭，针对扩展开放。</span><span class="pln">
</span><span class="pun">除非是</span><span class="pln">bug</span><span class="pun">，否者框架的源码不会直接拿来修改，但是对于功能性的个性化需求，框架应该允许用户进行扩展。</span><span class="pln">
</span><span class="pun">这也是为什么所有的框架基本都是面向接口和多态实现的，并且支持应用通过配置项注册自定义实现类，</span><span class="pln">
</span><span class="pun">比如</span><span class="typ">Quartz</span><span class="pun">的</span><span class="str">`org.quartz.scheduler.jobFactory.class`</span><span class="pun">和</span><span class="str">`org.quartz.scheduler.instanceIdGenerator.class`</span><span class="pun">配置项。</span></code></pre> 
<h3>解决方案</h3> 
<p>回到JUnit，其实也是如此。</p> 
<p>Junit4.5+是通过<code class="prettyprint prettyprinted" style=""><span class="pln">org</span><span class="pun">.</span><span class="pln">junit</span><span class="pun">.</span><span class="pln">runners</span><span class="pun">.</span><span class="typ">BlockJUnit4ClassRunner</span></code>中的<code class="prettyprint prettyprinted" style=""><span class="pln">createTest</span></code>方法来创建单元测试类对象的。</p> 
<pre class="prettyprint prettyprinted" style=""><code class="prettyprint"><span class="com">/**
 * Returns a new fixture for running a test. Default implementation executes
 * the test class's no-argument constructor (validation should have ensured
 * one exists).
 */</span><span class="pln">
</span><span class="kwd">protected</span><span class="pln"> </span><span class="typ">Object</span><span class="pln"> createTest</span><span class="pun">()</span><span class="pln"> </span><span class="kwd">throws</span><span class="pln"> </span><span class="typ">Exception</span><span class="pln"> </span><span class="pun">{<!-- --></span><span class="pln">
   </span><span class="kwd">return</span><span class="pln"> getTestClass</span><span class="pun">().</span><span class="pln">getOnlyConstructor</span><span class="pun">().</span><span class="pln">newInstance</span><span class="pun">();</span><span class="pln">
</span><span class="pun">}</span></code></pre> 
<p>那么根据前面的讨论，我们只要extends<code class="prettyprint prettyprinted" style=""><span class="pln">org</span><span class="pun">.</span><span class="pln">junit</span><span class="pun">.</span><span class="pln">runners</span><span class="pun">.</span><span class="typ">BlockJUnit4ClassRunner</span></code>类，覆盖它的<code class="prettyprint prettyprinted" style=""><span class="pln">createTest</span></code>方法就可以了。如果我们的这个类能够方便的拿到ApplicationContext（这个其实很简单，比如使用<code class="prettyprint prettyprinted" style=""><span class="typ">ClassPathXmlApplicationContext</span></code>），那么就可以很方便的实现依赖注入功能了。JUnit没有专门定义创建UT实例的接口，但是它提供了<code class="prettyprint prettyprinted" style=""><span class="lit">@RunWith</span></code>的注解，可以让我们指定我们自定义的ClassRunner。于是，解决方案就出来了。</p> 
<h3>Spring内建的解决方案</h3> 
<p>Spring3提供了<code class="prettyprint prettyprinted" style=""><span class="typ">SpringJUnit4ClassRunner</span></code>基类让我们可以很方便的接入JUnit4。</p> 
<pre class="prettyprint prettyprinted" style=""><code class="prettyprint"><span class="kwd">public</span><span class="pln"> </span><span class="kwd">class</span><span class="pln"> org</span><span class="pun">.</span><span class="pln">springframework</span><span class="pun">.</span><span class="pln">test</span><span class="pun">.</span><span class="pln">context</span><span class="pun">.</span><span class="pln">junit4</span><span class="pun">.</span><span class="typ">SpringJUnit4ClassRunner</span><span class="pln"> </span><span class="kwd">extends</span><span class="pln"> org</span><span class="pun">.</span><span class="pln">junit</span><span class="pun">.</span><span class="pln">runners</span><span class="pun">.</span><span class="typ">BlockJUnit4ClassRunner</span><span class="pln"> </span><span class="pun">{<!-- --></span><span class="pln">
    </span><span class="pun">...</span><span class="pln">
</span><span class="pun">}</span></code></pre> 
<p>思路跟我们上面讨论的一样，不过它采用了更灵活的设计：</p> 
<ol><li>引入<a target="_blank" rel="nofollow noopener noreferrer" href="http://static.springsource.org/spring/docs/3.0.0.M3/reference/html/ch10s03.html#testcontext-framework">Spring TestContext Framework</a>，允许接入不同的UT框架（如JUnit3.8-，JUnit4.5+，TestNG，etc.）.</li><li>相对于ApplicationContextAware接口，它允许指定要加载的配置文件位置，实现更细粒度的控制，同时缓存application context per Test Feature。这个是通过<code class="prettyprint prettyprinted" style=""><span class="lit">@ContextConfiguration</span></code>注解暴露给用户的。（其实由于<code class="prettyprint prettyprinted" style=""><span class="typ">SpringJUnit4ClassRunner</span></code>是由JUnit创建而不是Spring创建的，所以这里ApplicationContextAware should not work。但是笔者发现<code class="prettyprint prettyprinted" style=""><span class="typ">AbstractJUnit38SpringContextTests</span></code>是实现<code class="prettyprint prettyprinted" style=""><span class="typ">ApplicationContextAware</span></code>接口的，但是其ApplicationContext又是通过<code class="prettyprint prettyprinted" style=""><span class="pln">org</span><span class="pun">.</span><span class="pln">springframework</span><span class="pun">.</span><span class="pln">test</span><span class="pun">.</span><span class="pln">context</span><span class="pun">.</span><span class="pln">support</span><span class="pun">.</span><span class="typ">DependencyInjectionTestExecutionListener</span></code>加载的。感觉实在没有必要实现<code class="prettyprint prettyprinted" style=""><span class="typ">ApplicationContextAware</span></code>接口。）</li><li>基于事件监听机制（the listener-based test context framework），并且允许用户自定义事件监听器，通过<code class="prettyprint prettyprinted" style=""><span class="lit">@TestExecutionListeners</span></code>注解注册。默认是<code class="prettyprint prettyprinted" style=""><span class="pln">org</span><span class="pun">.</span><span class="pln">springframework</span><span class="pun">.</span><span class="pln">test</span><span class="pun">.</span><span class="pln">context</span><span class="pun">.</span><span class="pln">support</span><span class="pun">.</span><span class="typ">DependencyInjectionTestExecutionListener</span></code>、<code class="prettyprint prettyprinted" style=""><span class="pln">org</span><span class="pun">.</span><span class="pln">springframework</span><span class="pun">.</span><span class="pln">test</span><span class="pun">.</span><span class="pln">context</span><span class="pun">.</span><span class="pln">support</span><span class="pun">.</span><span class="typ">DirtiesContextTestExecutionListener</span></code>和<code class="prettyprint prettyprinted" style=""><span class="pln">org</span><span class="pun">.</span><span class="pln">springframework</span><span class="pun">.</span><span class="pln">test</span><span class="pun">.</span><span class="pln">context</span><span class="pun">.</span><span class="pln">transaction</span><span class="pun">.</span><span class="typ">TransactionalTestExecutionListener</span></code>这三个事件监听器。</li></ol> 
<p>其中依赖注入就是在<code class="prettyprint prettyprinted" style=""><span class="pln">org</span><span class="pun">.</span><span class="pln">springframework</span><span class="pun">.</span><span class="pln">test</span><span class="pun">.</span><span class="pln">context</span><span class="pun">.</span><span class="pln">support</span><span class="pun">.</span><span class="typ">DependencyInjectionTestExecutionListener</span></code>完成的：</p> 
<pre class="prettyprint prettyprinted" style=""><code class="prettyprint"><span class="com">/**
 * Performs dependency injection and bean initialization for the supplied
 * {@link TestContext} as described in
 * {@link #prepareTestInstance(TestContext) prepareTestInstance()}.
 * &lt;p&gt;The {@link #REINJECT_DEPENDENCIES_ATTRIBUTE} will be subsequently removed
 * from the test context, regardless of its value.
 * @param testContext the test context for which dependency injection should
 * be performed (never &lt;code&gt;null&lt;/code&gt;)
 * @throws Exception allows any exception to propagate
 * @see #prepareTestInstance(TestContext)
 * @see #beforeTestMethod(TestContext)
 */</span><span class="pln">
</span><span class="kwd">protected</span><span class="pln"> </span><span class="kwd">void</span><span class="pln"> injectDependencies</span><span class="pun">(</span><span class="kwd">final</span><span class="pln"> </span><span class="typ">TestContext</span><span class="pln"> testContext</span><span class="pun">)</span><span class="pln"> </span><span class="kwd">throws</span><span class="pln"> </span><span class="typ">Exception</span><span class="pln"> </span><span class="pun">{<!-- --></span><span class="pln">
    </span><span class="typ">Object</span><span class="pln"> bean </span><span class="pun">=</span><span class="pln"> testContext</span><span class="pun">.</span><span class="pln">getTestInstance</span><span class="pun">();</span><span class="pln">
    </span><span class="typ">AutowireCapableBeanFactory</span><span class="pln"> beanFactory </span><span class="pun">=</span><span class="pln"> testContext</span><span class="pun">.</span><span class="pln">getApplicationContext</span><span class="pun">().</span><span class="pln">getAutowireCapableBeanFactory</span><span class="pun">();</span><span class="pln">
    beanFactory</span><span class="pun">.</span><span class="pln">autowireBeanProperties</span><span class="pun">(</span><span class="pln">bean</span><span class="pun">,</span><span class="pln"> </span><span class="typ">AutowireCapableBeanFactory</span><span class="pun">.</span><span class="pln">AUTOWIRE_NO</span><span class="pun">,</span><span class="pln"> </span><span class="kwd">false</span><span class="pun">);</span><span class="pln">
    beanFactory</span><span class="pun">.</span><span class="pln">initializeBean</span><span class="pun">(</span><span class="pln">bean</span><span class="pun">,</span><span class="pln"> testContext</span><span class="pun">.</span><span class="pln">getTestClass</span><span class="pun">().</span><span class="pln">getName</span><span class="pun">());</span><span class="pln">
    testContext</span><span class="pun">.</span><span class="pln">removeAttribute</span><span class="pun">(</span><span class="pln">REINJECT_DEPENDENCIES_ATTRIBUTE</span><span class="pun">);</span><span class="pln">
</span><span class="pun">}</span></code></pre> 
<p>这里面ApplicationContext在Test类创建的时候就已经根据@ContextLocation标注的位置加载存放到TestContext中了：</p> 
<pre class="prettyprint prettyprinted" style=""><code class="prettyprint"><span class="com">/**
 * TestContext encapsulates the context in which a test is executed, agnostic of
 * the actual testing framework in use.
 * 
 * @author Sam Brannen
 * @author Juergen Hoeller
 * @since 2.5
 */</span><span class="pln">
</span><span class="kwd">public</span><span class="pln"> </span><span class="kwd">class</span><span class="pln"> </span><span class="typ">TestContext</span><span class="pln"> </span><span class="kwd">extends</span><span class="pln"> </span><span class="typ">AttributeAccessorSupport</span><span class="pln"> </span><span class="pun">{<!-- --></span><span class="pln">
    </span><span class="typ">TestContext</span><span class="pun">(</span><span class="typ">Class</span><span class="pun">&lt;?&gt;</span><span class="pln"> testClass</span><span class="pun">,</span><span class="pln"> </span><span class="typ">ContextCache</span><span class="pln"> contextCache</span><span class="pun">,</span><span class="pln"> </span><span class="typ">String</span><span class="pln"> defaultContextLoaderClassName</span><span class="pun">)</span><span class="pln"> </span><span class="pun">{<!-- --></span><span class="pln">
        </span><span class="pun">...</span><span class="pln">
        </span><span class="kwd">if</span><span class="pln"> </span><span class="pun">(!</span><span class="typ">StringUtils</span><span class="pun">.</span><span class="pln">hasText</span><span class="pun">(</span><span class="pln">defaultContextLoaderClassName</span><span class="pun">))</span><span class="pln"> </span><span class="pun">{<!-- --></span><span class="pln">
            defaultContextLoaderClassName </span><span class="pun">=</span><span class="pln"> STANDARD_DEFAULT_CONTEXT_LOADER_CLASS_NAME</span><span class="pun">;</span><span class="pln">
        </span><span class="pun">}</span><span class="pln">
        </span><span class="typ">ContextConfiguration</span><span class="pln"> contextConfiguration </span><span class="pun">=</span><span class="pln"> testClass</span><span class="pun">.</span><span class="pln">getAnnotation</span><span class="pun">(</span><span class="typ">ContextConfiguration</span><span class="pun">.</span><span class="kwd">class</span><span class="pun">);</span><span class="pln">
        </span><span class="typ">String</span><span class="pun">[]</span><span class="pln"> locations </span><span class="pun">=</span><span class="pln"> </span><span class="kwd">null</span><span class="pun">;</span><span class="pln">
        </span><span class="typ">ContextLoader</span><span class="pln"> contextLoader </span><span class="pun">=</span><span class="pln"> </span><span class="kwd">null</span><span class="pun">;</span><span class="pln">
        </span><span class="pun">...</span><span class="pln">
        </span><span class="typ">Class</span><span class="pun">&lt;?</span><span class="pln"> </span><span class="kwd">extends</span><span class="pln"> </span><span class="typ">ContextLoader</span><span class="pun">&gt;</span><span class="pln"> contextLoaderClass </span><span class="pun">=</span><span class="pln"> retrieveContextLoaderClass</span><span class="pun">(</span><span class="pln">testClass</span><span class="pun">,</span><span class="pln">
            defaultContextLoaderClassName</span><span class="pun">);</span><span class="pln">
        contextLoader </span><span class="pun">=</span><span class="pln"> </span><span class="pun">(</span><span class="typ">ContextLoader</span><span class="pun">)</span><span class="pln"> </span><span class="typ">BeanUtils</span><span class="pun">.</span><span class="pln">instantiateClass</span><span class="pun">(</span><span class="pln">contextLoaderClass</span><span class="pun">);</span><span class="pln">
        locations </span><span class="pun">=</span><span class="pln"> retrieveContextLocations</span><span class="pun">(</span><span class="pln">contextLoader</span><span class="pun">,</span><span class="pln"> testClass</span><span class="pun">);</span><span class="pln">
        </span><span class="kwd">this</span><span class="pun">.</span><span class="pln">testClass </span><span class="pun">=</span><span class="pln"> testClass</span><span class="pun">;</span><span class="pln">
        </span><span class="kwd">this</span><span class="pun">.</span><span class="pln">contextCache </span><span class="pun">=</span><span class="pln"> contextCache</span><span class="pun">;</span><span class="pln">
        </span><span class="kwd">this</span><span class="pun">.</span><span class="pln">contextLoader </span><span class="pun">=</span><span class="pln"> contextLoader</span><span class="pun">;</span><span class="pln">
        </span><span class="kwd">this</span><span class="pun">.</span><span class="pln">locations </span><span class="pun">=</span><span class="pln"> locations</span><span class="pun">;</span><span class="pln">
    </span><span class="pun">}</span><span class="pln">
</span><span class="pun">}</span></code></pre> 
<h5><strong><em>说明</em> </strong>:</h5> 
<p>Spring3使用了<a target="_blank" rel="nofollow noopener noreferrer" href="http://static.springsource.org/spring/docs/3.0.0.M3/reference/html/ch10s03.html#testcontext-framework">Spring TestContext Framework</a>框架，支持多种接入方式：<a target="_blank" rel="nofollow noopener noreferrer" href="http://static.springsource.org/spring/docs/3.0.0.M3/reference/html/ch10s03.html#testcontext-support-classes">10.3.5.5 TestContext support classes</a>。非常不错的官方文档，强烈推荐阅读。简单概括如下：</p> 
<ul><li>JUnit3.8：package <code class="prettyprint prettyprinted" style=""><span class="pln">org</span><span class="pun">.</span><span class="pln">springframework</span><span class="pun">.</span><span class="pln">test</span><span class="pun">.</span><span class="pln">context</span><span class="pun">.</span><span class="pln">junit38</span></code> 
  <ul><li><code class="prettyprint prettyprinted" style=""><span class="typ">AbstractJUnit38SpringContextTests</span></code> 
    <ul><li>applicationContext</li></ul> </li><li><code class="prettyprint prettyprinted" style=""><span class="typ">AbstractTransactionalJUnit38SpringContextTests</span></code> 
    <ul><li>applicationContext</li><li>simpleJdbcTemplate</li></ul> </li></ul> </li><li>JUnit4.5：package <code class="prettyprint prettyprinted" style=""><span class="pln">org</span><span class="pun">.</span><span class="pln">springframework</span><span class="pun">.</span><span class="pln">test</span><span class="pun">.</span><span class="pln">context</span><span class="pun">.</span><span class="pln">junit4</span></code> 
  <ul><li><code class="prettyprint prettyprinted" style=""><span class="typ">AbstractJUnit4SpringContextTests</span></code> 
    <ul><li>applicationContext</li></ul> </li><li><code class="prettyprint prettyprinted" style=""><span class="typ">AbstractTransactionalJUnit4SpringContextTests</span></code> 
    <ul><li>applicationContext</li><li>simpleJdbcTemplate</li></ul> </li><li>Custom JUnit 4.5 Runner：<code class="prettyprint prettyprinted" style=""><span class="typ">SpringJUnit4ClassRunner</span></code> 
    <ul><li>@Runwith</li><li>@ContextConfiguration</li><li>@TestExecutionListeners</li></ul> </li></ul> </li><li>TestNG: package <code class="prettyprint prettyprinted" style=""><span class="pln">org</span><span class="pun">.</span><span class="pln">springframework</span><span class="pun">.</span><span class="pln">test</span><span class="pun">.</span><span class="pln">context</span><span class="pun">.</span><span class="pln">testng</span></code> 
  <ul><li><code class="prettyprint prettyprinted" style=""><span class="typ">AbstractTestNGSpringContextTests</span></code> 
    <ul><li>applicationContext</li></ul> </li><li><code class="prettyprint prettyprinted" style=""><span class="typ">AbstractTransactionalTestNGSpringContextTests</span></code> 
    <ul><li>applicationContext</li><li>simpleJdbcTemplate</li></ul> </li></ul> </li></ul> 
<p>补充：对于JUnit3，Spring2.x原来提供了三种接入方式：</p> 
<ul><li>AbstractDependencyInjectionSpringContextTests</li><li>AbstractTransactionalSpringContextTests</li><li>AbstractTransactionalDataSourceSpringContextTests</li></ul> 
<p>不过从Spring3.0开始，这些了类都被<code class="prettyprint prettyprinted" style=""><span class="pln">org</span><span class="pun">.</span><span class="pln">springframework</span><span class="pun">.</span><span class="pln">test</span><span class="pun">.</span><span class="pln">context</span><span class="pun">.</span><span class="pln">junit38</span><span class="pun">.</span><span class="typ">AbstractJUnit38SpringContextTests</span></code>和<code class="prettyprint prettyprinted" style=""><span class="typ">AbstractTransactionalJUnit38SpringContextTests</span></code>取代了:</p> 
<blockquote> 
 <p>@deprecated as of Spring 3.0, in favor of using the listener-based test context framework（不过由于JUnit3.x不支持<code class="prettyprint prettyprinted" style=""><span class="pln">beforeTestClass</span></code>和<code class="prettyprint prettyprinted" style=""><span class="pln">afterTestClass</span></code>，所以这两个事件是无法监听的。）</p> 
 <p>({@link org.springframework.test.context.junit38.AbstractJUnit38SpringContextTests})</p> 
</blockquote> 
<hr> 
<p>采用Spring3.x提供的SpringJUnit4ClassRunner接入方式，我们可以这样写我们的UT：</p> 
<pre class="prettyprint prettyprinted" style=""><code class="prettyprint"><span class="kwd">package</span><span class="pln"> me</span><span class="pun">.</span><span class="pln">arganzheng</span><span class="pun">.</span><span class="pln">study</span><span class="pun">;</span><span class="pln">
</span><span class="kwd">import</span><span class="pln"> </span><span class="kwd">static</span><span class="pln"> org</span><span class="pun">.</span><span class="pln">junit</span><span class="pun">.</span><span class="typ">Assert</span><span class="pun">.*;</span><span class="pln">
</span><span class="kwd">import</span><span class="pln"> org</span><span class="pun">.</span><span class="pln">junit</span><span class="pun">.</span><span class="typ">Test</span><span class="pun">;</span><span class="pln">
</span><span class="kwd">import</span><span class="pln"> org</span><span class="pun">.</span><span class="pln">springframework</span><span class="pun">.</span><span class="pln">beans</span><span class="pun">.</span><span class="pln">factory</span><span class="pun">.</span><span class="pln">annotation</span><span class="pun">.</span><span class="typ">Autowired</span><span class="pun">;</span><span class="pln">
</span><span class="kwd">import</span><span class="pln"> org</span><span class="pun">.</span><span class="pln">springframework</span><span class="pun">.</span><span class="pln">test</span><span class="pun">.</span><span class="pln">context</span><span class="pun">.</span><span class="typ">ContextConfiguration</span><span class="pun">;</span><span class="pln">
</span><span class="kwd">import</span><span class="pln"> org</span><span class="pun">.</span><span class="pln">springframework</span><span class="pun">.</span><span class="pln">test</span><span class="pun">.</span><span class="pln">context</span><span class="pun">.</span><span class="pln">junit4</span><span class="pun">.</span><span class="typ">SpringJUnit4ClassRunner</span><span class="pun">;</span><span class="pln">
</span><span class="com">/** 
 * @author arganzheng
 */</span><span class="pln">
</span><span class="lit">@RunWith</span><span class="pun">(</span><span class="typ">SpringJUnit4ClassRunner</span><span class="pun">.</span><span class="kwd">class</span><span class="pun">)</span><span class="pln">
</span><span class="lit">@ContextConfiguration</span><span class="pun">({<!-- --></span><span class="pln">
    </span><span class="str">"classpath:conf-spring/spring-dao.xml"</span><span class="pun">,</span><span class="pln">
    </span><span class="str">"classpath:conf-spring/spring-service.xml"</span><span class="pun">,</span><span class="pln">
    </span><span class="str">"classpath:conf-spring/spring-controller.xml"</span><span class="pln">
</span><span class="pun">})</span><span class="pln">
</span><span class="kwd">public</span><span class="pln"> </span><span class="kwd">class</span><span class="pln"> </span><span class="typ">FooServiceTest</span><span class="pun">{<!-- --></span><span class="pln">
    </span><span class="lit">@Autowired</span><span class="pln">
    </span><span class="kwd">private</span><span class="pln"> </span><span class="typ">FooService</span><span class="pln"> fooService</span><span class="pun">;</span><span class="pln">
    </span><span class="lit">@Test</span><span class="pln">
    </span><span class="kwd">public</span><span class="pln"> </span><span class="kwd">void</span><span class="pln"> testSaveFoo</span><span class="pun">()</span><span class="pln"> </span><span class="pun">{<!-- --></span><span class="pln">
        </span><span class="typ">Foo</span><span class="pln"> foo </span><span class="pun">=</span><span class="pln"> </span><span class="kwd">new</span><span class="pln"> </span><span class="typ">Foo</span><span class="pun">();</span><span class="pln">
        </span><span class="com">// ...</span><span class="pln">
        </span><span class="kwd">long</span><span class="pln"> id </span><span class="pun">=</span><span class="pln"> fooService</span><span class="pun">.</span><span class="pln">saveFoo</span><span class="pun">(</span><span class="pln">foo</span><span class="pun">);</span><span class="pln">
        assertTrue</span><span class="pun">(</span><span class="pln">id </span><span class="pun">&gt;</span><span class="pln"> </span><span class="lit">0</span><span class="pun">);</span><span class="pln">
    </span><span class="pun">}</span><span class="pln">
</span><span class="pun">}</span></code></pre> 
<p>当然，每个UT类都要配置这么多anotation配置是很不方便的，搞成一个基类会好很多：</p> 
<pre class="prettyprint prettyprinted" style=""><code class="prettyprint"><span class="pln">ackage me</span><span class="pun">.</span><span class="pln">arganzheng</span><span class="pun">.</span><span class="pln">study</span><span class="pun">;</span><span class="pln">
</span><span class="kwd">import</span><span class="pln"> org</span><span class="pun">.</span><span class="pln">junit</span><span class="pun">.</span><span class="pln">runner</span><span class="pun">.</span><span class="typ">RunWith</span><span class="pun">;</span><span class="pln">
</span><span class="kwd">import</span><span class="pln"> org</span><span class="pun">.</span><span class="pln">springframework</span><span class="pun">.</span><span class="pln">test</span><span class="pun">.</span><span class="pln">context</span><span class="pun">.</span><span class="typ">ContextConfiguration</span><span class="pun">;</span><span class="pln">
</span><span class="kwd">import</span><span class="pln"> org</span><span class="pun">.</span><span class="pln">springframework</span><span class="pun">.</span><span class="pln">test</span><span class="pun">.</span><span class="pln">context</span><span class="pun">.</span><span class="pln">junit4</span><span class="pun">.</span><span class="typ">SpringJUnit4ClassRunner</span><span class="pun">;</span><span class="pln">
</span><span class="kwd">import</span><span class="pln"> org</span><span class="pun">.</span><span class="pln">springframework</span><span class="pun">.</span><span class="pln">transaction</span><span class="pun">.</span><span class="pln">annotation</span><span class="pun">.</span><span class="typ">Transactional</span><span class="pun">;</span><span class="pln">    
</span><span class="com">/**  
 * @author arganzheng
 */</span><span class="pln">
</span><span class="lit">@RunWith</span><span class="pun">(</span><span class="typ">SpringJUnit4ClassRunner</span><span class="pun">.</span><span class="kwd">class</span><span class="pun">)</span><span class="pln">
</span><span class="lit">@ContextConfiguration</span><span class="pun">({<!-- --></span><span class="pln">
    </span><span class="str">"classpath:conf-spring/spring-dao.xml"</span><span class="pun">,</span><span class="pln">
    </span><span class="str">"classpath:conf-spring/spring-service.xml"</span><span class="pun">,</span><span class="pln">
    </span><span class="str">"classpath:conf-spring/spring-controller.xml"</span><span class="pln">
</span><span class="pun">})</span><span class="pln">
</span><span class="lit">@Transactional</span><span class="pln">
</span><span class="kwd">public</span><span class="pln"> </span><span class="kwd">class</span><span class="pln"> </span><span class="typ">BaseSpringTestCase</span><span class="pun">{<!-- --></span><span class="pln">
</span><span class="pun">}</span></code></pre> 
<p>然后我们的FooServiceTest就可以简化为：</p> 
<pre class="prettyprint prettyprinted" style=""><code class="prettyprint"><span class="kwd">package</span><span class="pln"> me</span><span class="pun">.</span><span class="pln">arganzheng</span><span class="pun">.</span><span class="pln">study</span><span class="pun">;</span><span class="pln">
</span><span class="kwd">import</span><span class="pln"> </span><span class="kwd">static</span><span class="pln"> org</span><span class="pun">.</span><span class="pln">junit</span><span class="pun">.</span><span class="typ">Assert</span><span class="pun">.*;</span><span class="pln">
</span><span class="kwd">import</span><span class="pln"> org</span><span class="pun">.</span><span class="pln">junit</span><span class="pun">.</span><span class="typ">Test</span><span class="pun">;</span><span class="pln">
</span><span class="kwd">import</span><span class="pln"> org</span><span class="pun">.</span><span class="pln">springframework</span><span class="pun">.</span><span class="pln">beans</span><span class="pun">.</span><span class="pln">factory</span><span class="pun">.</span><span class="pln">annotation</span><span class="pun">.</span><span class="typ">Autowired</span><span class="pun">;</span><span class="pln">
</span><span class="kwd">import</span><span class="pln"> org</span><span class="pun">.</span><span class="pln">springframework</span><span class="pun">.</span><span class="pln">test</span><span class="pun">.</span><span class="pln">annotation</span><span class="pun">.</span><span class="typ">Rollback</span><span class="pun">;</span><span class="pln">
</span><span class="com">/** 
 * @author arganzheng
 */</span><span class="pln">
</span><span class="kwd">public</span><span class="pln"> </span><span class="kwd">class</span><span class="pln"> </span><span class="typ">FooServiceTest</span><span class="pln"> </span><span class="kwd">extends</span><span class="pln"> </span><span class="typ">BaseSpringTestCase</span><span class="pun">{<!-- --></span><span class="pln">
    </span><span class="lit">@Autowired</span><span class="pln">
    </span><span class="kwd">private</span><span class="pln"> </span><span class="typ">FooService</span><span class="pln"> fooService</span><span class="pun">;</span><span class="pln">
    </span><span class="lit">@Test</span><span class="pln">
    </span><span class="com">// @Rollback(true) 默认就是true</span><span class="pln">
    </span><span class="kwd">public</span><span class="pln"> </span><span class="kwd">void</span><span class="pln"> testSaveFoo</span><span class="pun">()</span><span class="pln"> </span><span class="pun">{<!-- --></span><span class="pln">
        </span><span class="typ">Foo</span><span class="pln"> foo </span><span class="pun">=</span><span class="pln"> </span><span class="kwd">new</span><span class="pln"> </span><span class="typ">Foo</span><span class="pun">();</span><span class="pln">
        </span><span class="com">// ...</span><span class="pln">
        </span><span class="kwd">long</span><span class="pln"> id </span><span class="pun">=</span><span class="pln"> fooService</span><span class="pun">.</span><span class="pln">saveFoo</span><span class="pun">(</span><span class="pln">foo</span><span class="pun">);</span><span class="pln">
        assertTrue</span><span class="pun">(</span><span class="pln">id </span><span class="pun">&gt;</span><span class="pln"> </span><span class="lit">0</span><span class="pun">);</span><span class="pln">
    </span><span class="pun">}</span><span class="pln">
</span><span class="pun">}</span></code></pre> 
<h3>单元测试的其他问题</h3> 
<p>上面只是简单解决了依赖注入问题，其实单元测试还有很多。如</p> 
<ol><li>事务管理</li><li>Mock掉外界依赖</li><li>web层测试</li><li>接口测试</li><li>静态和私有方法测试</li><li>测试数据准备和结果验证</li></ol> 
<p>等等。</p> 
<p>--EOF--</p> 
<p><br> </p> 
<p><br> </p> 
<p>原文地址：http://ju.outofmemory.cn/entry/75778<br> </p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/481721eab79ce3157023d0223f9dd56b/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">protobuf 自定义描述消息的实现</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/e54d090197e518cfcb23113ec71a6e16/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">table的复制 SqlServer 数据库添加临时表（select  字段1，字段2，字段3 into）</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>