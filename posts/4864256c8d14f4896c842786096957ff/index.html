<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>2_计算机网络_数据链路层-交换机-以太网-vlan-trunk - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="2_计算机网络_数据链路层-交换机-以太网-vlan-trunk" />
<meta property="og:description" content="文章目录 1、数据链路层1.1 功能和协议1.2 Ethernet 以太网mac地址mac地址表帧格式 2、交换机3、ARP协议工作原理ARP缓存表广播风暴局域网扫描脚本 4、虚拟局域网VLAN广播域划分vlan的作用创建vlan 5、trunk中继链路trunk作用trunk模式 1、数据链路层 位于网络层与物理层之间
1.1 功能和协议 数据链路的建立，维护与拆除
帧包装，帧传输，帧同步
帧的差错恢复
流量控制
ppp协议：点到点协议（Point-to-Point Protocol）
PPPOE协议：是以太网上的点到点协议( Point-to-Point Protocol Over Ethernet )，是将点到点协议ppp封装在以太网框架中的一种网络隧道协议，
1.2 Ethernet 以太网 mac地址 mac地址是嵌入到网卡芯片里的，出产就配置好了，不需要我们去配置–》全球唯一，mac地址是可以改的。
以太网（ethernet）：就是我们平常的局域网
mac地址（硬件地址、物理地址）
mac地址是48位的；前24位代表厂商；后24位代表厂商生产的网卡的唯一标识，16进制是12位
linux里面查看：ip add ——00:0c:29:6b:da:85
windows里面查看：ipconfig -all ——物理地址 : 70-8B-CD-1F-A9-58 mac地址表 交换机里面有个mac地址表，记录所有连接到交换机的电脑mac地址和对应的接口；
mac地址表存放在内存里
mac地址表：mac地址&#43;对应的端口号&#43;vlan
mac地址表会更新吗？
会
· mac地址表里面的条目是有老化时间的，有自动刷新行为
· mac地址表只在局域网里面使用，广域网里面使用的是ip地址
帧格式 字段内容源mac6字节目的mac6字节数据46~1500字节 mtu最大传输单元帧校验序列校验数据真伪，防止数据丢失帧的范围64 ~1518 字节MTU最大传输单元，数据在帧里最大只能是1500 字节 2、交换机 交换机只做俩件事：学习和转发 1、学习：帧里面的mac地址，将其和对应接口号记录到mac地址表里面
2、转发：
不知道mac地址时，会广播——&gt;给每一个接口都复制一份数据，转发过去
知道mac地址，就单播
工作原理
假设一台新的交换机连了3台电脑，电脑向外发广播。
1、学习：学习帧里面的源mac地址写到mac地址表
2、转发：根据帧里的目的mac地址去转发.
先查询下mac地址表里面是否有对应的目的mac地址对应的接口，有就单播转发;
没有就广播（复制数据帧给除进来的接口以外的其他接口都发一份） 工作过程描述" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/4864256c8d14f4896c842786096957ff/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-12-08T17:44:23+08:00" />
<meta property="article:modified_time" content="2022-12-08T17:44:23+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">2_计算机网络_数据链路层-交换机-以太网-vlan-trunk</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-light">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p></p> 
<div class="toc"> 
 <h4>文章目录</h4> 
 <ul><li><a href="#1_1" rel="nofollow">1、数据链路层</a></li><li><ul><li><a href="#11__5" rel="nofollow">1.1 功能和协议</a></li><li><a href="#12_Ethernet__13" rel="nofollow">1.2 Ethernet 以太网</a></li><li><ul><li><a href="#mac_14" rel="nofollow">mac地址</a></li><li><a href="#mac_26" rel="nofollow">mac地址表</a></li><li><a href="#_36" rel="nofollow">帧格式</a></li></ul> 
  </li></ul> 
  </li><li><a href="#2_48" rel="nofollow">2、交换机</a></li><li><a href="#3ARP_88" rel="nofollow">3、ARP协议</a></li><li><ul><li><a href="#_93" rel="nofollow">工作原理</a></li><li><a href="#ARP_107" rel="nofollow">ARP缓存表</a></li><li><a href="#_117" rel="nofollow">广播风暴</a></li><li><a href="#_127" rel="nofollow">局域网扫描脚本</a></li></ul> 
  </li><li><a href="#4VLAN_154" rel="nofollow">4、虚拟局域网VLAN</a></li><li><ul><li><a href="#_161" rel="nofollow">广播域</a></li><li><a href="#vlan_166" rel="nofollow">划分vlan的作用</a></li><li><a href="#vlan_176" rel="nofollow">创建vlan</a></li></ul> 
  </li><li><a href="#5trunk_199" rel="nofollow">5、trunk中继链路</a></li><li><ul><li><a href="#trunk_200" rel="nofollow">trunk作用</a></li><li><a href="#trunk_211" rel="nofollow">trunk模式</a></li></ul> 
 </li></ul> 
</div> 
<p></p> 
<h2><a id="1_1"></a>1、数据链路层</h2> 
<p>位于网络层与物理层之间</p> 
<p><img src="https://images2.imgbox.com/ce/99/Mb85dB5N_o.png" alt="在这里插入图片描述"></p> 
<h3><a id="11__5"></a>1.1 功能和协议</h3> 
<p>数据链路的建立，维护与拆除<br> 帧包装，帧传输，帧同步<br> 帧的差错恢复<br> 流量控制</p> 
<p><strong>ppp协议</strong>：点到点协议（Point-to-Point Protocol）<br> <strong>PPPOE协议</strong>：是以太网上的点到点协议( Point-to-Point Protocol Over Ethernet )，是将点到点协议ppp封装在以太网框架中的一种网络隧道协议，</p> 
<h3><a id="12_Ethernet__13"></a>1.2 Ethernet 以太网</h3> 
<h4><a id="mac_14"></a>mac地址</h4> 
<p><img src="https://images2.imgbox.com/b9/a1/cRTreTLt_o.png" alt="在这里插入图片描述"><br> mac地址是嵌入到网卡芯片里的，出产就配置好了，不需要我们去配置–》全球唯一，mac地址是可以改的。<br> 以太网（ethernet）：就是我们平常的局域网</p> 
<p>mac地址（硬件地址、物理地址）<br> mac地址是48位的；前24位代表厂商；后24位代表厂商生产的网卡的唯一标识，16进制是12位</p> 
<p><font face="微软雅黑体" color="orange" size="3">linux里面查看：ip add ——00:0c:29:6b:da:85<br> windows里面查看：ipconfig -all ——物理地址 : 70-8B-CD-1F-A9-58 </font></p> 
<h4><a id="mac_26"></a>mac地址表</h4> 
<p>交换机里面有个mac地址表，记录所有连接到交换机的电脑mac地址和对应的接口；<br> <font face="微软雅黑体" color="red" size="3"> mac地址表存放在内存里</font><br> <strong>mac地址表</strong>：mac地址+对应的端口号+vlan</p> 
<blockquote> 
 <p><strong>mac地址表会更新吗？</strong><br> 会<br> · mac地址表里面的条目是有老化时间的，有自动刷新行为<br> · mac地址表只在局域网里面使用，广域网里面使用的是ip地址</p> 
</blockquote> 
<h4><a id="_36"></a>帧格式</h4> 
<p><img src="https://images2.imgbox.com/32/a4/Y3RORfb1_o.png" alt="在这里插入图片描述"></p> 
<table><thead><tr><th align="left">字段</th><th align="left">内容</th></tr></thead><tbody><tr><td align="left">源mac</td><td align="left">6字节</td></tr><tr><td align="left">目的mac</td><td align="left">6字节</td></tr><tr><td align="left">数据</td><td align="left">46~1500字节 mtu最大传输单元</td></tr><tr><td align="left">帧校验序列</td><td align="left">校验数据真伪，防止数据丢失</td></tr><tr><td align="left">帧的范围</td><td align="left">64 ~1518 字节</td></tr><tr><td align="left">MTU</td><td align="left">最大传输单元，数据在帧里最大只能是1500 字节</td></tr></tbody></table> 
<h2><a id="2_48"></a>2、交换机</h2> 
<p><font face="微软雅黑体" color="red" size="3">交换机只做俩件事：学习和转发 </font><br> <font face="微软雅黑体" color="green" size="3"> 1、学习：帧里面的mac地址，将其和对应接口号记录到mac地址表里面<br> 2、转发：<br> 不知道mac地址时，会广播——&gt;给每一个接口都复制一份数据，转发过去<br> 知道mac地址，就单播</font></p> 
<p><strong>工作原理</strong></p> 
<blockquote> 
 <p>假设一台新的交换机连了3台电脑，电脑向外发广播。<br> <font face="微软雅黑体" color="green" size="3">1、学习：学习帧里面的源mac地址写到mac地址表<br> 2、转发：根据帧里的目的mac地址去转发.<br> 先查询下mac地址表里面是否有对应的目的mac地址对应的接口，有就单播转发;<br> 没有就广播（复制数据帧给除进来的接口以外的其他接口都发一份） </font></p> 
</blockquote> 
<p><strong>工作过程描述</strong></p> 
<blockquote> 
 <p><font face="微软雅黑体" color="green" size="3">1、当数据包第一次封装好的时候，此时源mac地址是自己的，目的mac地址是对方的，封装好了就会发送到交换机来；<br> 2、 交换机收到数据包以后的第一件事就是学习，学习源mac地址和对应接口号，然后写到mac地址表里面。<br> · 如果mac地址表里面有目的mac地址的话，就会直接进行单播。<br> · 如果mac表里面没有这个目的mac地址，就会给每一个接口（除了这个源mac的机器）进行广播；<br> 3、收到的机器就会进行解封装，看这个目的mac地址是不是自己，如果是自己就回复，如果不是自己就会丢弃，不会响应。<br> 4、回复的数据包到了交换机，交换机也会先进行学习，然后再转发。<br> 转发的过程中如果mac地址表里面有对应目的mac地址的话就进行单播，如果mac地址表里面没有的话，就进行广播，通信过后如果再来的话，就可以直接进行单播。<br> </font></p> 
</blockquote> 
<p><strong>A电脑给B电脑发数据，最开始的时候是怎么知道B电脑的mac地址的？</strong><br> 数据封装的时候，并不是一来就封装mac地址的，自上而下是先封装ip地址的，再封装mac地址的。<br> ip与mac之间有一个arp协议。发arp广播获得对方的mac地址。<br> <strong>arp协议</strong>（Address Resolution Protocol 地址解析协议）：将ip地址解析到对应的mac地址<br> 帧里面若目的mac为ff:ff:ff:ff:ff:ff，这是帧里面的广播地址，交换机会广播到所有的接口。</p> 
<p><strong>交换机在俩种情况下会广播</strong>：</p> 
<pre><code>1.如果目的mac在mac地址表里没有，交换机就会广播转发；
2.目的mad地址是FF:FF:FF:FF:FF:FF ，交换机也会广播转发；
3.收到组播地址（mac地址的第8位为1的mac地址）的时候，也会广播的
</code></pre> 
<h2><a id="3ARP_88"></a>3、ARP协议</h2> 
<p><strong>Address Resolution Protocol 地址解析协议</strong><br> <font face="微软雅黑体" color="green" size="3"> 在局域网中，数据的传输是通过帧的，帧里面有目的主机的mac地址。这个mac地址是通过arp协议获得的。<br> “地址解析” 就是主机在发送帧之前将目的主机的ip地址转换为mac地址。<br> arp协议的基本功能就是通过目的主机的ip地址查询其mac地址，以保证通信的顺利进行。</font></p> 
<h3><a id="_93"></a>工作原理</h3> 
<p>在每台安装有TCP/IP协议的电脑里都有一个ARP缓存表，表里的IP地址与MAC地址是一一对应的.</p> 
<pre><code>A主机（192.168.1.5）
B主机（192.168.1.1）
1、A向B发送数据，A在自己的arp缓存表里面查询是否有B的ip地址。
     有，就知道了B的ip地址对应的mac地址，写入帧里面发送就可以了。
     没有，A就会在局域网中发送一个广播，目标mac地址为“FF.FF.FF.FF.FF.FF”。
     表示向所有局域网中的主机询问“B的mac地址是什么？”，只有B主机会给出回应“我是B，mac地址为00-aa-00-62-c6-09”
2、 这样A主机知道B的mac地址，就可以向B发信息了。
    同时A会更新自己的arp缓存表，下次向B发送信息时，直接查arp缓存表就行了。
</code></pre> 
<h3><a id="ARP_107"></a>ARP缓存表</h3> 
<p>ARP缓存表是可以查看的，也可以添加和修改。</p> 
<pre><code class="prism language-bash">arp <span class="token parameter variable">-a</span> <span class="token comment"># 查看ARP缓存表中的内容</span>
arp <span class="token parameter variable">-d</span> <span class="token comment"># 删除ARP表中某一行的内容</span>
arp <span class="token parameter variable">-s</span> <span class="token comment"># 手动在ARP表中指定IP地址与MAC地址的对应。</span>
</code></pre> 
<p><code>ARP缓存表采用了老化机制，在一段时间内如果表中的某一行没有使用就会被删除，这样大大的减少了ARP缓存表的长度，加快查询速度。</code></p> 
<h3><a id="_117"></a>广播风暴</h3> 
<p><strong>什么是广播风暴？</strong><br> 网络环路+交换机的工作原理转发广播包。<br> <strong>广播风暴有什么危害？</strong><br> 大量的广播在交换机之间传输，消耗了所有交换机的cpu和内存，带宽资源，导致正常的数据帧都不能转发了。<br> 后面网络越来越慢，最后数据发送不出去。</p> 
<p><strong>如何防范？</strong></p> 
<ol><li>物理上检查不要形成环路</li><li>交换机的系统里启用STP协议 生成树协议STP spanning-tree （ 路，如果形成了环路，会自动阻断其中一条路。一般交换机会自动开启）</li></ol> 
<h3><a id="_127"></a>局域网扫描脚本</h3> 
<pre><code class="prism language-bash"><span class="token punctuation">[</span>root@localhost lianxi<span class="token punctuation">]</span><span class="token comment"># cat scan_ip.sh </span>
<span class="token comment">#! /bin/bash</span>
 
<span class="token comment"># 初始化日志文件，第一次新建</span>
<span class="token operator">&gt;</span> used_ip.log
<span class="token operator">&gt;</span> unused_ip.log
<span class="token operator">&gt;</span> ip_mac.log
 
<span class="token keyword">for</span> <span class="token for-or-select variable">i</span> <span class="token keyword">in</span> <span class="token punctuation">{<!-- --></span><span class="token number">1</span><span class="token punctuation">..</span><span class="token number">40</span><span class="token punctuation">}</span>
<span class="token keyword">do</span>
	<span class="token punctuation">(</span> <span class="token keyword">if</span> <span class="token function">ping</span> <span class="token number">192.168</span>.0.<span class="token variable">$i</span> <span class="token parameter variable">-c</span> <span class="token number">1</span> <span class="token parameter variable">-w</span> <span class="token number">1</span>  <span class="token operator">&amp;&gt;</span>/dev/null <span class="token punctuation">;</span><span class="token keyword">then</span>
		<span class="token builtin class-name">echo</span> <span class="token string">"192.168.0.<span class="token variable">$i</span>"</span> <span class="token operator">&gt;&gt;</span>used_ip.log
	<span class="token keyword">else</span>
		<span class="token builtin class-name">echo</span> <span class="token string">"192.168.0.<span class="token variable">$i</span>"</span> <span class="token operator">&gt;&gt;</span>unused_ip.log	
	<span class="token keyword">fi</span> <span class="token punctuation">)</span><span class="token operator">&amp;</span>
<span class="token keyword">done</span>	
<span class="token function">wait</span>
<span class="token comment"># 统计没有使用过的ip地址的个数</span>
<span class="token assign-left variable">num</span><span class="token operator">=</span><span class="token variable"><span class="token variable">$(</span><span class="token function">cat</span> unused_ip.log <span class="token operator">|</span> <span class="token function">wc</span> <span class="token parameter variable">-l</span><span class="token variable">)</span></span>
<span class="token builtin class-name">echo</span> <span class="token string">"total ip: <span class="token variable">$num</span>"</span> <span class="token operator">&gt;&gt;</span>unused_ip.log
 
<span class="token comment"># 得到所有在使用的ip对应的mac地址</span>
arp <span class="token parameter variable">-a</span> <span class="token operator">|</span> <span class="token function">grep</span> <span class="token parameter variable">-V</span> <span class="token string">"incomplete"</span> <span class="token operator">|</span> <span class="token function">awk</span> <span class="token string">'{print $2,$4}'</span> <span class="token operator">|</span> <span class="token function">tr</span> <span class="token parameter variable">-d</span> <span class="token string">'()'</span> <span class="token operator">&gt;&gt;</span>ip_mac.log
</code></pre> 
<h2><a id="4VLAN_154"></a>4、虚拟局域网VLAN</h2> 
<p>LAN 局域网 local area network<br> vlan 虚拟局域网 virtual local area network<br> 广播域： 能够接受到同一个广播的区域<br> vlan 是逻辑分割局域网，很多电脑在同一个交换机上，我们人为的将它们分开，导致不能通信。<br> <img src="https://images2.imgbox.com/09/86/rQm7rqme_o.png" alt="在这里插入图片描述"></p> 
<h3><a id="_161"></a>广播域</h3> 
<p>能够接收到同一个广播的区域；<br> 分隔广播域：物理分隔、逻辑分隔<br> vlan是逻辑分隔局域网，很多电脑在同一个交换机上，我们人为将他分开，导致不能通信。</p> 
<h3><a id="vlan_166"></a>划分vlan的作用</h3> 
<p>隔离网络（隔离广播）；<br> 增强安全性，不同的vlan默认是不能通信的；</p> 
<p>默认情况下所有的接口都属于vlan1<br> 傻瓜交换机默认所有接口都属于vlan1,不管是什么品牌的交换机。</p> 
<pre><code>	xvlan： 对现有的vlan的扩展 --》可以有更加多的vlan
	vlan ： 2~1001  1025~4094 可以自定义的vlan的范围
</code></pre> 
<h3><a id="vlan_176"></a>创建vlan</h3> 
<p>验证：相同vlan的主机在相同网段内可以通信，不同vlan的主机在相同网段内不可以通信<br> <img src="https://images2.imgbox.com/a0/b9/8TnX5PWU_o.png" alt="在这里插入图片描述"></p> 
<p>不同网段的主机需要通信，默认是需要经过路由器的。<br> 使用Trunk解决不同交换机上的相同vlan的通信<br> 基本的原则： 一个vlan对应一个网段</p> 
<blockquote> 
 <p>相同vlan，相同的网段是否可以通行? 可以<br> 相同vlan，但是不同网段是否可以通信？ 不可以<br> 不同vlan，相同的网段是否可以通信？ 不可以<br> 不同vlan，不相同的网段是否可以通信？ 不可以</p> 
</blockquote> 
<p><strong>为什么不同vlan不可以通信？</strong><br> 编程角度：转发数据帧的时候，有if else语句判断。<br> 协议是通过编程语言去实现的，转发数据是编程语言在做，中间是有大量的if else判断。</p> 
<p>正常的数据帧到了交换机后，交换机会在里面插入一个vlan标签，这个修改的帧，只有交换机能识别。<br> <img src="https://images2.imgbox.com/6a/a1/4IAzcaWw_o.png" alt="在这里插入图片描述"><br> destination address 目的地址 --》DA<br> source address 源地址 --&gt;SA<br> <img src="https://images2.imgbox.com/69/e9/gUWB40Wl_o.png" alt="在这里插入图片描述"><br> <img src="https://images2.imgbox.com/5a/dd/kszZGcBX_o.png" alt="在这里插入图片描述"></p> 
<h2><a id="5trunk_199"></a>5、trunk中继链路</h2> 
<h3><a id="trunk_200"></a>trunk作用</h3> 
<ul><li>实现跨交换机的相同vlan之间的通信</li><li>不同的vlan都可以在trunk链路上传输</li></ul> 
<p><img src="https://images2.imgbox.com/c2/e1/qqJRkrba_o.png" alt="在这里插入图片描述"></p> 
<ul><li>vlan是虚拟局域网，用来隔离网络，隔离划分广播域，提高安全性。</li><li>trunk是中继链路，用来实现跨交换机的相同vlan之间的通信。</li></ul> 
<p>交换机给往其他交换机的数据帧打上VLAN标记。数据帧到了交换机后，交换机会在里面插入一个vlan标记，这个修改了的整只有交换机之间可以看懂。</p> 
<h3><a id="trunk_211"></a>trunk模式</h3> 
<p>auto 随便<br> desirable 盼望，渴望<br> trunk 非常主动<br> nonegotiation 看破红尘<br> <img src="https://images2.imgbox.com/11/d9/llPlmTur_o.png" alt="在这里插入图片描述"></p> 
<p><a href="https://blog.csdn.net/qq_20411471/article/details/101032861">中继链路trunk详解</a></p> 
<blockquote> 
 <p><strong><font face="微软雅黑体" color="green" size="3"> vlan——隔离广播域，划分不同的虚拟局域网<br> trunk——跨交换机的相同vlan之间的通信，它将数据从一个交换机到另外一个交换机的传输问题<br> 以太通道——聚合多条线路，增加带宽，提供高可用性 </font></strong></p> 
</blockquote>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/376885417eeab4fcc85f20a022a64184/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">nginx学习使用</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/00f8e848af427b00cb50d959a5a5e249/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">SQLyog —— 图形化工具使用</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>