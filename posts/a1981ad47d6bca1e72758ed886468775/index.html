<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>SPDK软件栈基础概念 - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="SPDK软件栈基础概念" />
<meta property="og:description" content="SPDK SPDK软件架构SSD和SPDK中controller和nsSPDK RPC （一）driverSPDK virtio-PCIe 和 vhost-user （二）Storage Services(存储设备)对象存储SPDK BlobStore&amp;BlobFS SPDK 块设备驱动块设备驱动层的其他模块 （三）存储协议(Storage Protocols)SPDK中的Target1、vhost-nvme target &amp; vhost-blk target2、Linux nbd 和 NVMeoF Target SPDK软件架构 SSD和SPDK中controller和ns 在 NVMe SSD 中，一个 Controller 和多个 Namespace 的概念与 SPDK 中的 Controller 和 Namespace 概念基本相同，但是在细节上有一些区别。
Namespace 的定义：在 NVMe SSD 中，Namespace 是一个虚拟的存储设备，由控制器（Controller）和对应的命名空间标识符（Namespace Identifier）组成。而在 SPDK 中，Namespace 也是一个虚拟的存储设备，但是它只由命名空间标识符（Namespace Identifier）表示，没有控制器的概念。
命名空间的数量：在 NVMe SSD 中，一个控制器（Controller）可以管理多个 Namespace。而在 SPDK 中，每个 Namespace 都是独立的，不会被分配到多个控制器中，每个命名空间只会被一个控制器管理。
接口实现：NVMe SSD 是一种硬件设备，因此其控制器（Controller）和命名空间（Namespace）都是由硬件实现的。而 SPDK 是一个软件库，其中的控制器（Controller）和命名空间（Namespace）都是由软件接口实现的，可以在任意支持 SPDK 的硬件平台上运行。
总之，在 NVMe SSD 和 SPDK 中，Controller 和 Namespace 这两个概念都是用来描述存储设备的逻辑组件，其中 Controller 负责管理 Namespace，并提供读写、擦除等操作。但是两者在实现方式和功能方面有所不同，需要根据具体的应用场景进行选择。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/a1981ad47d6bca1e72758ed886468775/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-04-21T13:40:08+08:00" />
<meta property="article:modified_time" content="2023-04-21T13:40:08+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">SPDK软件栈基础概念</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p></p> 
<div class="toc"> 
 <h4>SPDK</h4> 
 <ul><li><a href="#SPDK_2" rel="nofollow">SPDK软件架构</a></li><li><ul><li><a href="#SSDSPDKcontrollerns_6" rel="nofollow">SSD和SPDK中controller和ns</a></li><li><a href="#SPDK_RPC_16" rel="nofollow">SPDK RPC</a></li></ul> 
  </li><li><a href="#driver_41" rel="nofollow">（一）driver</a></li><li><ul><li><a href="#SPDK_virtioPCIe__vhostuser_42" rel="nofollow">SPDK virtio-PCIe 和 vhost-user</a></li></ul> 
  </li><li><a href="#Storage_Services_50" rel="nofollow">（二）Storage Services(存储设备)</a></li><li><ul><li><a href="#_51" rel="nofollow">对象存储</a></li><li><ul><li><a href="#SPDK_BlobStoreBlobFS_57" rel="nofollow">SPDK BlobStore&amp;BlobFS</a></li></ul> 
   </li><li><a href="#SPDK__65" rel="nofollow">SPDK 块设备驱动</a></li><li><ul><li><a href="#_84" rel="nofollow">块设备驱动层的其他模块</a></li></ul> 
  </li></ul> 
  </li><li><a href="#Storage_Protocols_99" rel="nofollow">（三）存储协议(Storage Protocols)</a></li><li><ul><li><a href="#SPDKTarget_100" rel="nofollow">SPDK中的Target</a></li><li><ul><li><a href="#1vhostnvme_target___vhostblk_target_102" rel="nofollow">1、vhost-nvme target &amp; vhost-blk target</a></li><li><a href="#2Linux_nbd__NVMeoF_Target_109" rel="nofollow">2、Linux nbd 和 NVMeoF Target</a></li></ul> 
  </li></ul> 
 </li></ul> 
</div> 
<p></p> 
<h2><a id="SPDK_2"></a>SPDK软件架构</h2> 
<p><img src="https://images2.imgbox.com/be/61/KpP3uUmZ_o.png" alt="在这里插入图片描述"></p> 
<h3><a id="SSDSPDKcontrollerns_6"></a>SSD和SPDK中controller和ns</h3> 
<p>在 NVMe SSD 中，一个 Controller 和多个 Namespace 的概念与 SPDK 中的 Controller 和 Namespace 概念基本相同，但是在细节上有一些区别。</p> 
<ol><li> <p>Namespace 的定义：在 NVMe SSD 中，Namespace 是一个虚拟的存储设备，由控制器（Controller）和对应的命名空间标识符（Namespace Identifier）组成。而在 SPDK 中，Namespace 也是一个虚拟的存储设备，但是它只由命名空间标识符（Namespace Identifier）表示，没有控制器的概念。</p> </li><li> <p>命名空间的数量：在 NVMe SSD 中，一个控制器（Controller）可以管理多个 Namespace。而在 SPDK 中，每个 Namespace 都是独立的，不会被分配到多个控制器中，每个命名空间只会被一个控制器管理。</p> </li><li> <p>接口实现：NVMe SSD 是一种硬件设备，因此其控制器（Controller）和命名空间（Namespace）都是由硬件实现的。而 SPDK 是一个软件库，其中的控制器（Controller）和命名空间（Namespace）都是由软件接口实现的，可以在任意支持 SPDK 的硬件平台上运行。</p> </li></ol> 
<p>总之，在 NVMe SSD 和 SPDK 中，Controller 和 Namespace 这两个概念都是用来描述存储设备的逻辑组件，其中 Controller 负责管理 Namespace，并提供读写、擦除等操作。但是两者在实现方式和功能方面有所不同，需要根据具体的应用场景进行选择。</p> 
<h3><a id="SPDK_RPC_16"></a>SPDK RPC</h3> 
<p>SPDK (Storage Performance Development Kit) 中的 RPC (Remote Procedure Call) 命令是用于远程管理 SPDK 的命令行工具。以下是一些常用的 SPDK RPC 命令：</p> 
<ol><li> <p><code>bdev_malloc_create</code>：创建一个基于 <code>malloc</code> 的块设备。</p> </li><li> <p><code>bdev_null_create</code>：创建一个基于 <code>null</code> 的块设备。</p> </li><li> <p><code>bdev_nvme_attach_controller</code>：将 NVMe SSD 控制器附加到 SPDK 上下文中。</p> </li><li> <p><code>bdev_nvme_detach_controller</code>：从 SPDK 上下文中分离 NVMe SSD 控制器。</p> </li><li> <p><code>bdev_nvme_attach_ns</code>：将 NVMe SSD 资源暴露为块设备。</p> </li><li> <p><code>bdev_nvme_detach_ns</code>：从 SPDK 上下文中分离 NVMe SSD 块设备。</p> </li><li> <p><code>nvmf_create_transport</code>：创建一个 NVMe over Fabrics 传输对象。</p> </li><li> <p><code>nvmf_create_subsystem</code>：创建一个 NVMe over Fabrics 的子系统，该子系统可以包含多个命名空间和控制器。</p> </li><li> <p><code>nvmf_subsystem_add_listener</code>：将 NVMe over Fabrics 子系统绑定到传输层监听地址。</p> </li><li> <p><code>nvmf_subsystem_remove_listener</code>：从 NVMe over Fabrics 子系统中移除传输层监听地址。</p> </li></ol> 
<p>这些 RPC 命令可以通过 SPDK 提供的 CLI 工具（如 <code>spdkcli</code>）或者 JSON-RPC API 进行调用。用户可以使用这些命令来管理 SPDK 中的各种资源，包括块设备、NVMe SSD 控制器和 NVMe over Fabrics 子系统等。</p> 
<h2><a id="driver_41"></a>（一）driver</h2> 
<h3><a id="SPDK_virtioPCIe__vhostuser_42"></a>SPDK virtio-PCIe 和 vhost-user</h3> 
<p>1、virtio-PCIe是一种基于PCI Express总线的虚拟化设备标准，并且是virtio的一个扩展。它通过在物理PCIe设备上实现虚拟化，使得虚拟机可以直接访问物理PCIe设备。SPDK在virtio-PCIe上实现了块设备、网络设备和其他类型的设备，从而提供更高效的I/O操作。</p> 
<p>2、 相比之下，vhost-user则是一种用户空间网络设备虚拟化技术，它允许用户空间应用程序直接管理虚拟机的网络设备。SPDK使用vhost-user来实现用户空间网络功能，这样可以避免虚拟机和主机之间的数据复制，从而提高网络性能并降低延迟。</p> 
<p>总体来说，SPDK使用virtio-PCIe和vhost-user等虚拟化技术来优化存储和网络性能，并提高整个系统的效率和吞吐量。<br> 3、Intel QuickData Technology：也称为Intel I/O Acceleration Technology（Inter IOAT，英特尔I/O加速技术），这是一种基于Xeon处理器平台上的copy offload引擎。通过提供用户空间访问，减少了DMA数据移动的阈值，允许对小尺寸I/O或NTB的更好利用。</p> 
<h2><a id="Storage_Services_50"></a>（二）Storage Services(存储设备)</h2> 
<h3><a id="_51"></a>对象存储</h3> 
<p>对象存储是一种数据存储技术，用于将数据以对象（Object）的形式进行管理和存储。与传统的文件系统不同，对象存储不使用层次目录结构来组织数据，而是将每个数据项都视为一个独立的对象，并为其分配唯一的标识符（或者称为键）。这些对象可以是任意大小的二进制数据，可以包含多种类型的元数据（例如创建时间、修改时间、拥有者等），并可以通过网络协议（如HTTP、S3）进行访问。</p> 
<p>由于对象存储不需要对数据进行分块或者组织成文件夹和文件等结构，它具有很强的可扩展性和灵活性。在大规模数据集的场景下，对象存储可以处理海量的数据，并提供高可靠性、高可用性和高性能的数据访问服务。同时，对象存储还支持复杂的数据管理功能，例如版本控制、数据备份、数据恢复、数据加密等。</p> 
<p>基于对象存储技术的应用非常广泛，例如云计算、物联网、大数据分析、视频监控等领域。常见的对象存储系统包括Amazon S3、OpenStack Swift、Ceph、Scality、Hadoop HDFS等。近年来，越来越多的企业和组织开始使用对象存储替代传统的文件系统和数据库，以应对大数据时代带来的挑战。</p> 
<h4><a id="SPDK_BlobStoreBlobFS_57"></a>SPDK BlobStore&amp;BlobFS</h4> 
<p>SPDK中的BlobFS和Blobstore是两个不同的库，但它们之间存在着一定的联系。</p> 
<p>Blobstore是一个基于SPDK的对象存储引擎，提供了高性能、低延迟的对象存储接口。它支持各种数据类型（包括二进制、文本、图像等），并可以处理大规模数据集的存储和访问。Blobstore使用了多线程和异步IO等技术来实现高性能和可扩展性，支持多种协议（如NVMe-oF、RDMA、TCP等）进行对象读写。</p> 
<p>而BlobFS则是在Blobstore的基础上开发的一个文件系统。它将Blobstore中的对象组织成类似于层次目录结构的文件和文件夹，并提供了标准的POSIX文件系统接口。这使得使用BlobFS的应用程序可以像使用传统文件系统一样访问和管理数据。BlobFS还提供了一些高级功能，例如快照管理、事务支持、压缩、加密等。与Blobstore不同，BlobFS支持多种文件系统分布式架构（如分布式元数据存储、多副本等）以及强一致性模型保证。</p> 
<p>因此，Blobstore主要是一个对象存储引擎，用于处理大规模数据集的存储和访问；而BlobFS则是一个基于Blobstore的文件系统，用于为应用程序提供标准的文件系统接口和高级功能。</p> 
<h3><a id="SPDK__65"></a>SPDK 块设备驱动</h3> 
<p>SPDK（Storage Performance Development Kit）提供了多个块设备驱动，用于支持不同类型的块设备接口。以下是SPDK中一些常用的块设备驱动：</p> 
<ol><li>bdev_aio：使用Linux AIO库进行异步文件IO操作。</li><li>bdev_uring：使用Linux io_uring库进行异步文件IO操作。</li><li>bdev_malloc：使用内存模拟块设备。</li><li>bdev_null：使用内存模拟空块设备。</li><li>bdev_nvme：使用NVMe SSD进行块设备IO操作。</li><li>bdev_rbd：使用Ceph RBD（Rados Block Device）进行分布式块设备IO操作。</li><li>bdev_virtio：在虚拟环境中使用virtio协议进行块设备IO操作。</li></ol> 
<p>此外，SPDK还提供了其他一些块设备驱动，如bdev_iscsi（使用iSCSI协议进行块设备IO操作）、bdev_pmem（使用持久内存进行块设备IO操作）等。用户可以根据实际需求选择合适的驱动程序。<br> SPDK（Storage Performance Development Kit）提供了多种方式将底层物理设备抽象成块设备，以下是其中一些常见的方法：</p> 
<ol><li>使用NVMe SSD进行块设备IO操作：SPDK提供了bdev_nvme驱动程序，将NVMe SSD设备暴露给SPDK框架，并将其抽象成块设备。用户可以通过配置文件或命令行参数等方式指定NVMe SSD设备的PCI地址、分区信息等，从而让SPDK能够正确地识别和管理该设备。</li><li>使用Linux AIO进行异步文件IO操作：SPDK提供了bdev_aio驱动程序，使用Linux AIO库进行异步文件IO操作。用户可以通过配置文件或命令行参数等方式指定要管理的文件路径等信息。</li><li>使用Ceph RBD进行分布式块设备IO操作：SPDK提供了bdev_rbd驱动程序，使用Ceph RBD（Rados Block Device）进行块设备IO操作。用户可以通过配置文件或命令行参数等方式指定Ceph集群的IP地址、端口号、认证信息等参数，从而实现对Ceph RBD的访问。</li><li>在虚拟化环境中使用virtio协议进行块设备IO操作：SPDK提供了bdev_virtio驱动程序，支持在虚拟环境中使用virtio协议进行块设备IO操作。用户可以通过配置文件或命令行参数等方式指定virtio-blk-pci设备的信息，从而让SPDK能够正确地识别和管理该设备。<br> 除了上述方法外，SPDK还提供了其他一些块设备驱动程序，如bdev_pmem（使用持久内存进行块设备IO操作）等。用户可以根据实际需求选择合适的方式，并使用SPDK提供的相应驱动程序进行配置和管理。</li></ol> 
<h4><a id="_84"></a>块设备驱动层的其他模块</h4> 
<ol><li> <p>Party：Party 是 SPDK 中的一个基础库，它为用户空间的异步事件驱动编程模型提供了支持。</p> </li><li> <p>Logical Volumes：Logical Volume 是逻辑卷的意思，SPDK 的逻辑卷管理器提供了一组 API，用于动态管理逻辑卷和卷组。</p> </li><li> <p>Crypto：Crypto 模块提供了加密和解密操作的支持。它可以通过多个后端实现，包括 Intel QAT 硬件加速、OpenSSL 和 AESNI 等。</p> </li><li> <p>Open Channel SSD FTL：Open Channel SSD FTL 是一种特殊类型的 SSD，它通过将控制器中的一些功能暴露给主机来提高性能。SPDK 提供了一组 API，允许用户直接在主机上使用 Open Channel SSD。</p> </li><li> <p>OCF Cache：OCF Cache 是 SPDK 的一个缓存管理框架，它将缓存数据存储在系统内存中以提高性能。</p> </li><li> <p>Compression：Compression 模块提供了压缩和解压缩数据的支持。 它可以通过多个后端实现，包括 zlib 和 Intel QuickAssist Technology (QAT)。</p> </li><li> <p>QoS（服务质量）框架：框架允许用户设置存储设备可以消耗的带宽、IOPS（每秒输入/输出操作次数）或延迟的限制。通过设置这些限制，用户可以确保他们的存储设备不会超过某些阈值，从而有助于预防性能问题并改善整个系统的稳定性。 SPDK中的QoS框架被设计为灵活且可扩展，可以用于各种应用程序。<br> SPDK QoS框架的一些关键特点包括支持多个QoS策略，动态调整QoS参数以及实时监测设备性能。</p> </li></ol> 
<h2><a id="Storage_Protocols_99"></a>（三）存储协议(Storage Protocols)</h2> 
<h3><a id="SPDKTarget_100"></a>SPDK中的Target</h3> 
<p>在SPDK中，Target是指向存储设备的逻辑地址空间，它可以是一个磁盘驱动器、SSD、NVMe设备或者任何其他类型的存储设备。Target通常由两个组件组成：<strong>前端和后端</strong>。前端负责处理来自应用程序的请求，将这些请求转换为SPDK所需的格式并将其发送到后端处理。后端负责实际的I/O操作，包括数据传输和数据处理。前端和后端之间通过SPDK框架提供的API进行通信。一个Target可能有多个前端和多个后端。例如，一个NVMe设备可以拥有多个命名空间，每个命名空间都可以看作是一个独立的Target，但是这些Target共享相同的后端。这种设计使得SPDK可以支持高并发的I/O操作，并提供更好的性能和可扩展性。</p> 
<h4><a id="1vhostnvme_target___vhostblk_target_102"></a>1、vhost-nvme target &amp; vhost-blk target</h4> 
<p>1、 <strong>vhost-blk targe</strong>t允许虚拟机通过网络连接访问主机上的块设备。它提供了一个轻量级的虚拟接口，将块设备公开给虚拟机，并支持多个虚拟机同时访问同一块设备。该技术通常用于构建基于共享存储的虚拟化环境，可以帮助提高资源利用率和管理效率。</p> 
<p>2、<strong>vhost-nvme target</strong>则是针对NVMe存储设备的虚拟化技术。它允许虚拟机通过vhost-nvme接口直接访问主机上的NVMe设备。与vhost-blk target不同的是，vhost-nvme target提供了更高的性能和更低的延迟，适用于需要超高性能的应用场景，例如人工智能、大数据分析等。</p> 
<p>总之，vhost-blk target和vhost-nvme target都是SPDK中提供的虚拟化块设备技术，但面向不同的应用场景和需求。vhost-blk target适用于一般虚拟化环境，而vhost-nvme target则适用于需要超高性能的应用场景。</p> 
<h4><a id="2Linux_nbd__NVMeoF_Target_109"></a>2、Linux nbd 和 NVMeoF Target</h4> 
<p>1、<strong>Linux nbd</strong>基于TCP/IP网络协议实现，允许客户端通过网络连接访问主机上的块设备。它通过将块设备封装在网络数据包中来实现块设备级别的网络传输。这种方法简单有效，因此nbd被广泛应用于云计算、虚拟化等场景，以提高资源利用率和管理效率。</p> 
<p>2、<strong>NVMe-oF target</strong>则是一种专门针对NVMe存储设备的远程访问协议，它允许远程客户端通过标准网络协议（如TCP/IP、InfiniBand）访问本地NVMe存储设备。NVMe-oF target比nbd更适合需要超高性能、低延迟的应用场景，例如分布式数据库、大规模机器学习等。</p> 
<p>总之，Linux nbd和NVMe-oF target都是实现块设备级别的远程访问的技术，但面向不同的应用场景和需求。nbd基于TCP/IP网络协议实现，适合于一般的云计算、虚拟化等场景，而NVMe-oF target则适合需要超高性能、低延迟的分布式存储、大规模机器学习等应用场景。</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/3b2f8b977b600a876507af817b5baa8e/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">解决Windows系统本地代理服务开启情况下创建Conda环境报错</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/e70996eb5005814db4016534da3b926d/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">Spring 面试题大全（持续更新中……）</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>