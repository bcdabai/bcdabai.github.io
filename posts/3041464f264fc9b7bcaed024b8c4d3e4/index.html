<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>nginx.conf中的fastcgi_pass - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="nginx.conf中的fastcgi_pass" />
<meta property="og:description" content="基本原理 nginx本身不能处理PHP，它只是个web服务器，当接收到请求后，如果是php请求，则发给php解释器处理，并把结果返回给客户端。
nginx一般是把请求发fastcgi管理进程处理，fascgi管理进程选择cgi子进程处理结果并返回被nginx。
2种连接方式
fastcgi_pass 127.0.0.1:9000;
fastcgi_pass unix:/var/run/php-fpm/php-fpm.sock;
为什么会有2种fastcgi_pass Nginx和PHP-FPM的进程间通信有两种方式,一种是TCP,一种是UNIX Domain Socket.
其中TCP是IP加端口,可以跨服务器.而UNIX Domain Socket不经过网络,只能用于Nginx跟PHP-FPM都在同一服务器的场景.用哪种取决于你的PHP-FPM配置:
方式1:
php-fpm.conf: listen = 127.0.0.1:9000
nginx.conf: fastcgi_pass 127.0.0.1:9000;
方式2:
php-fpm.conf: listen = /tmp/php-fpm.sock
nginx.conf: fastcgi_pass unix:/tmp/php-fpm.sock;
其中php-fpm.sock是一个文件,由php-fpm生成,类型是srw-rw----.
UNIX Domain Socket可用于两个没有亲缘关系的进程,是目前广泛使用的IPC机制,比如X Window服务器和GUI程序之间就是通过UNIX Domain Socket通讯的.这种通信方式是发生在系统内核里而不会在网络里传播.UNIX Domain Socket和长连接都能避免频繁创建TCP短连接而导致TIME_WAIT连接过多的问题.对于进程间通讯的两个程序,UNIX Domain Socket的流程不会走到TCP那层,直接以文件形式,以stream socket通讯.如果是TCP Socket,则需要走到IP层,对于非同一台服务器上,TCP Socket走的就更多了.
socket是神马？摘抄一段描述： Socket 可以被定义描述为两个应用通信通道的端点。一个 Socket 端点可以用 Socket 地址来描述， Socket 地址结构由 IP 地址，端口和使用协议组成（ TCP or UDP ）。http协议可以通过socket实现，socket在传输层上实现。从这个角度来说，socket介于应用层和传输层之间。但是socket作为一种进程通信机制，操作系统分配唯一一个socket号，是依赖于通信协议的，但是这个通信协议不仅仅是 tcp或udp，也可以是其它协议。
在同一台服务器上，用tcp socket与unix domain socket有什么区别？
如图所示，对于进程间通讯的两个程序，unix domain socket的流程不会走到TCP 那层，直接以文件形式，以stream socket通讯。如果是TCP socket,则需要走到IP层。对于非同一台服务器上，TCP socket走的就更多了。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/3041464f264fc9b7bcaed024b8c4d3e4/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2019-06-27T15:42:01+08:00" />
<meta property="article:modified_time" content="2019-06-27T15:42:01+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">nginx.conf中的fastcgi_pass</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <h3>基本原理</h3> 
<p>nginx本身不能处理PHP，它只是个web服务器，当接收到请求后，如果是php请求，则发给php解释器处理，并把结果返回给客户端。</p> 
<p>nginx一般是把请求发fastcgi管理进程处理，fascgi管理进程选择cgi子进程处理结果并返回被nginx。</p> 
<p> </p> 
<p>2种连接方式</p> 
<p>fastcgi_pass 127.0.0.1:9000;</p> 
<p>fastcgi_pass unix:/var/run/php-fpm/php-fpm.sock;</p> 
<p> </p> 
<h3>为什么会有2种fastcgi_pass</h3> 
<p>Nginx和PHP-FPM的进程间通信有两种方式,一种是TCP,一种是UNIX Domain Socket.</p> 
<p>其中TCP是IP加端口,可以跨服务器.而UNIX Domain Socket不经过网络,只能用于Nginx跟PHP-FPM都在同一服务器的场景.用哪种取决于你的PHP-FPM配置:</p> 
<p>方式1:</p> 
<p>php-fpm.conf: listen = 127.0.0.1:9000</p> 
<p>nginx.conf: fastcgi_pass 127.0.0.1:9000;</p> 
<p>方式2:</p> 
<p>php-fpm.conf: listen = /tmp/php-fpm.sock</p> 
<p>nginx.conf: fastcgi_pass unix:/tmp/php-fpm.sock;</p> 
<p>其中php-fpm.sock是一个文件,由php-fpm生成,类型是srw-rw----.</p> 
<p>UNIX Domain Socket可用于两个没有亲缘关系的进程,是目前广泛使用的IPC机制,比如X Window服务器和GUI程序之间就是通过UNIX Domain Socket通讯的.这种通信方式是发生在系统内核里而不会在网络里传播.UNIX Domain Socket和长连接都能避免频繁创建TCP短连接而导致TIME_WAIT连接过多的问题.对于进程间通讯的两个程序,UNIX Domain Socket的流程不会走到TCP那层,直接以文件形式,以stream socket通讯.如果是TCP Socket,则需要走到IP层,对于非同一台服务器上,TCP Socket走的就更多了.</p> 
<p> </p> 
<h4>socket是神马？摘抄一段描述：</h4> 
<p>Socket 可以被定义描述为两个应用通信通道的端点。一个 Socket 端点可以用 Socket 地址来描述， Socket 地址结构由 IP 地址，端口和使用协议组成（ TCP or UDP ）。http协议可以通过socket实现，socket在传输层上实现。从这个角度来说，socket介于应用层和传输层之间。但是socket作为一种进程通信机制，操作系统分配唯一一个socket号，是依赖于通信协议的，但是这个通信协议不仅仅是 tcp或udp，也可以是其它协议。</p> 
<p> </p> 
<p> </p> 
<p></p> 
<p></p> 
<p>在同一台服务器上，用tcp socket与unix domain socket有什么区别？</p> 
<p>如图所示，对于进程间通讯的两个程序，unix domain socket的流程不会走到TCP 那层，直接以文件形式，以stream socket通讯。如果是TCP socket,则需要走到IP层。对于非同一台服务器上，TCP socket走的就更多了。</p> 
<p><img alt="" class="has" src="https://images2.imgbox.com/30/18/8iWvXVE1_o.png"></p> 
<p> </p> 
<p> </p> 
<p> </p> 
<h4>例子:</h4> 
<p>UNIX Domain Socket:</p> 
<p>Nginx &lt;=&gt; socket &lt;=&gt; PHP-FPM</p> 
<p>TCP Socket(本地回环):</p> 
<p>Nginx &lt;=&gt; socket &lt;=&gt; TCP/IP &lt;=&gt; socket &lt;=&gt; PHP-FPM</p> 
<p>TCP Socket(Nginx和PHP-FPM位于不同服务器,不过也只能这样):</p> 
<p>Nginx &lt;=&gt; socket &lt;=&gt; TCP/IP &lt;=&gt; 物理层 &lt;=&gt; 路由器 &lt;=&gt; 物理层 &lt;=&gt; TCP/IP &lt;=&gt; socket &lt;=&gt; PHP-FPM</p> 
<p>像mysql命令行客户端连接mysqld服务也类似有这两种方式:</p> 
<p>使用Unix Socket连接(默认):</p> 
<p>mysql -uroot -p --protocol=socket --socket=/tmp/mysql.sock</p> 
<p>使用TCP连接:</p> 
<p>mysql -uroot -p --protocol=tcp --host=127.0.0.1 --port=3306</p> 
<p> </p> 
<p> </p> 
<h4>如何配置</h4> 
<p>php5.3之后的版本，php-fpm.conf里的listen的默认配置是127.0.0.1:9000，就不会生成php-fpm.sock，因此如果需要Nginx里的配置有链接tmp/php-fpm.sock的话，需要将listen的地址配置成和nginx的配置文件一致，同时保证这个路径已经存在，这样在启动./php-fpm的时候，会在对应路径上自动生成php-fpm.sock，例如：</p> 
<p>让PHP-FPM使用Unix套接字</p> 
<p>打开 /etc/php-fpm.d/www.conf</p> 
<p>vim /etc/php-fpm.d/www.conf</p> 
<p>修改后如下：</p> 
<p>;listen = 127.0.0.1:9000 listen = /var/run/php-fpm/php-fpm.sock</p> 
<p>修改www.conf配置文件里的listen.mode=0666就可以设置默认权限，不用手动修改了</p> 
<p>然后重新加载 PHP-FPM：</p> 
<p>systemctl restart php-fpm.</p> 
<p>接下修改nginx的配置和所有的虚拟主机</p> 
<p>fastcgi_pass 127.0.0.1:9000; ==&gt;fastcgi_pass unix:/tmp/php-fpm.sock;</p> 
<p> </p> 
<p>打开nginx.conf</p> 
<p>vim /etc/nginx/conf.d/default.conf</p> 
<p>fastcgi_pass unix:/tmp/php-fpm.sock;</p> 
<p>最后重新加载 nginx：</p> 
<p>systemctl restart nginx.</p> 
<p></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/566ea898af1740c2685ecd2582de2f45/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">vue-framework-wz关于not found: * vue-tinymce in ./~/babel-load、--save vue-tinymce\、Cannot GET /</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/847d95a015924b8f7012865b5ebdb99a/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">LinkedBlockingQueue的put，take方法</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>