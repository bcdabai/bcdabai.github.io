<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>12- OpenCV：算子(Sobel和Laplance) 和Canny边缘检测 详解 - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="12- OpenCV：算子(Sobel和Laplance) 和Canny边缘检测 详解" />
<meta property="og:description" content="目录
一、Sobel算子
1、卷积应用-图像边缘提取
2、Sobel算子（索贝尔算子）
3、相关的API（代码例子）
二、Laplance算子
1、理论
2、API使用（代码例子）
三、Canny边缘检测
1、Canny算法介绍
2、API使用（代码例子）
一、Sobel算子 1、卷积应用-图像边缘提取 在这个红点变化最大，变化率很高的，梯度也是最陡。变化率做成一根曲线，所以变化率最大的就在顶点。
（1）边缘是什么 ：是像素值发生跃迁的地方，是图像的显著特征之一，在图像特征提取、对象检测、模式识别等方面都有重要的作用。
（2）如何捕捉/提取边缘 – 对图像求它的一阶导数 delta = f(x) – f(x-1), delta越大，说明像素在X方向变化越大，边缘信号越强，
（3）用Sobel算子就好！卷积操作！
2、Sobel算子（索贝尔算子） （1）是离散微分算子（discrete differentiation operator），用来计算图像灰度的近似梯度；
（2）Soble算子功能集合高斯平滑和微分求导；
（3）又被称为一阶微分算子，求导算子，在水平和垂直两个方向上求导，得到图像X方法与Y方向梯度图像；
（4）求取导数的近似值，kernel=3时不是很准确，OpenCV使用改进版本Scharr函数，算子如下：放大了权重，差异性更加大了，不过也更加准确些。
3、相关的API（代码例子） （1）cv_Sobel函数原型
cv::Sobel (
InputArray Src // 输入图像
OutputArray dst// 输出图像，大小与输入图像一致
int depth // 输出图像深度.
int dx. // X方向，几阶导数
int dy // Y方向，几阶导数.
int ksize, SOBEL算子kernel大小，必须是奇数，1、3、5、7，一般是3
double scale = 1
double delta = 0
int borderType = BORDER_DEFAULT" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/aab24e868d07de7598c8ccd6e5ec6709/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2024-01-19T18:07:55+08:00" />
<meta property="article:modified_time" content="2024-01-19T18:07:55+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">12- OpenCV：算子(Sobel和Laplance) 和Canny边缘检测 详解</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p id="main-toc"><strong>目录</strong></p> 
<p id="%E4%B8%80%E3%80%81Sobel%E7%AE%97%E5%AD%90-toc" style="margin-left:80px;"><a href="#%E4%B8%80%E3%80%81Sobel%E7%AE%97%E5%AD%90" rel="nofollow">一、Sobel算子</a></p> 
<p id="1%E3%80%81%E5%8D%B7%E7%A7%AF%E5%BA%94%E7%94%A8-%E5%9B%BE%E5%83%8F%E8%BE%B9%E7%BC%98%E6%8F%90%E5%8F%96-toc" style="margin-left:120px;"><a href="#1%E3%80%81%E5%8D%B7%E7%A7%AF%E5%BA%94%E7%94%A8-%E5%9B%BE%E5%83%8F%E8%BE%B9%E7%BC%98%E6%8F%90%E5%8F%96" rel="nofollow">1、卷积应用-图像边缘提取</a></p> 
<p id="2%E3%80%81Sobel%E7%AE%97%E5%AD%90%EF%BC%88%E7%B4%A2%E8%B4%9D%E5%B0%94%E7%AE%97%E5%AD%90%EF%BC%89-toc" style="margin-left:120px;"><a href="#2%E3%80%81Sobel%E7%AE%97%E5%AD%90%EF%BC%88%E7%B4%A2%E8%B4%9D%E5%B0%94%E7%AE%97%E5%AD%90%EF%BC%89" rel="nofollow">2、Sobel算子（索贝尔算子）</a></p> 
<p id="3%E3%80%81%E7%9B%B8%E5%85%B3%E7%9A%84API%EF%BC%88%E4%BB%A3%E7%A0%81%E4%BE%8B%E5%AD%90%EF%BC%89-toc" style="margin-left:120px;"><a href="#3%E3%80%81%E7%9B%B8%E5%85%B3%E7%9A%84API%EF%BC%88%E4%BB%A3%E7%A0%81%E4%BE%8B%E5%AD%90%EF%BC%89" rel="nofollow">3、相关的API（代码例子）</a></p> 
<p id="%E4%BA%8C%E3%80%81Laplance%E7%AE%97%E5%AD%90-toc" style="margin-left:80px;"><a href="#%E4%BA%8C%E3%80%81Laplance%E7%AE%97%E5%AD%90" rel="nofollow">二、Laplance算子</a></p> 
<p id="1%E3%80%81%E7%90%86%E8%AE%BA-toc" style="margin-left:120px;"><a href="#1%E3%80%81%E7%90%86%E8%AE%BA" rel="nofollow">1、理论</a></p> 
<p id="2%E3%80%81API%E4%BD%BF%E7%94%A8%EF%BC%88%E4%BB%A3%E7%A0%81%E4%BE%8B%E5%AD%90%EF%BC%89-toc" style="margin-left:120px;"><a href="#2%E3%80%81API%E4%BD%BF%E7%94%A8%EF%BC%88%E4%BB%A3%E7%A0%81%E4%BE%8B%E5%AD%90%EF%BC%89" rel="nofollow">2、API使用（代码例子）</a></p> 
<p id="%E4%B8%89%E3%80%81Canny%E8%BE%B9%E7%BC%98%E6%A3%80%E6%B5%8B-toc" style="margin-left:80px;"><a href="#%E4%B8%89%E3%80%81Canny%E8%BE%B9%E7%BC%98%E6%A3%80%E6%B5%8B" rel="nofollow">三、Canny边缘检测</a></p> 
<p id="1%E3%80%81Canny%E7%AE%97%E6%B3%95%E4%BB%8B%E7%BB%8D-toc" style="margin-left:120px;"><a href="#1%E3%80%81Canny%E7%AE%97%E6%B3%95%E4%BB%8B%E7%BB%8D" rel="nofollow">1、Canny算法介绍</a></p> 
<p id="2%E3%80%81API%E4%BD%BF%E7%94%A8%EF%BC%88%E4%BB%A3%E7%A0%81%E4%BE%8B%E5%AD%90%EF%BC%89-toc" style="margin-left:120px;"><a href="#2%E3%80%81API%E4%BD%BF%E7%94%A8%EF%BC%88%E4%BB%A3%E7%A0%81%E4%BE%8B%E5%AD%90%EF%BC%89" rel="nofollow">2、API使用（代码例子）</a></p> 
<hr id="hr-toc"> 
<p></p> 
<h4 id="%E4%B8%80%E3%80%81Sobel%E7%AE%97%E5%AD%90"><strong>一、Sobel算子</strong></h4> 
<h5 id="1%E3%80%81%E5%8D%B7%E7%A7%AF%E5%BA%94%E7%94%A8-%E5%9B%BE%E5%83%8F%E8%BE%B9%E7%BC%98%E6%8F%90%E5%8F%96"><strong>1、卷积应用-图像边缘提取</strong></h5> 
<p>         在这个红点变化最大，变化率很高的，梯度也是最陡。变化率做成一根曲线，所以变化率最大的就在顶点。</p> 
<p><img alt="" height="234" src="https://images2.imgbox.com/1a/02/x5GJQEkZ_o.png" width="743"></p> 
<p>（1）边缘是什么 ：是像素值发生跃迁的地方，是图像的显著特征之一，在图像特征提取、对象检测、模式识别等方面都有重要的作用。</p> 
<p>（2）如何捕捉/提取边缘 – 对图像求它的一阶导数       </p> 
<p>                delta =  f(x) – f(x-1), delta越大，说明像素在X方向变化越大，边缘信号越强，</p> 
<p>（3）用Sobel算子就好！卷积操作！</p> 
<h5 id="2%E3%80%81Sobel%E7%AE%97%E5%AD%90%EF%BC%88%E7%B4%A2%E8%B4%9D%E5%B0%94%E7%AE%97%E5%AD%90%EF%BC%89"><strong>2、Sobel算子（索贝尔算子）</strong></h5> 
<p>（1）是离散微分算子（discrete differentiation operator），用来计算图像灰度的近似梯度；</p> 
<p>（2）Soble算子功能集合高斯平滑和微分求导；</p> 
<p>（3）又被称为一阶微分算子，求导算子，在水平和垂直两个方向上求导，得到图像X方法与Y方向梯度图像；</p> 
<p><img alt="" height="247" src="https://images2.imgbox.com/ff/ca/K3kJnGX7_o.png" width="696"></p> 
<p>（4）求取导数的近似值，kernel=3时不是很准确，OpenCV使用改进版本Scharr函数，算子如下：<strong>放大了权重，差异性更加大了，不过也更加准确些。</strong></p> 
<p><img alt="" height="216" src="https://images2.imgbox.com/dc/9d/yVgvnWa2_o.png" width="409"></p> 
<h5 id="3%E3%80%81%E7%9B%B8%E5%85%B3%E7%9A%84API%EF%BC%88%E4%BB%A3%E7%A0%81%E4%BE%8B%E5%AD%90%EF%BC%89"><strong>3、相关的API（代码例子）</strong></h5> 
<p><strong>（1）cv_Sobel函数原型</strong></p> 
<blockquote> 
 <p>cv::Sobel (</p> 
 <p>InputArray Src // 输入图像</p> 
 <p>OutputArray dst// 输出图像，大小与输入图像一致</p> 
 <p>int depth // 输出图像深度.</p> 
 <p>int dx.  // X方向，几阶导数</p> 
 <p>int dy // Y方向，几阶导数.</p> 
 <p>int ksize, SOBEL算子kernel大小，必须是奇数，1、3、5、7，一般是3</p> 
 <p>double scale  = 1</p> 
 <p>double delta = 0</p> 
 <p>int borderType = BORDER_DEFAULT</p> 
 <p>)</p> 
</blockquote> 
<p><img alt="" height="213" src="https://images2.imgbox.com/d1/b9/bQfm2jze_o.png" width="558"></p> 
<p><strong>（2）cv::Scharr</strong></p> 
<blockquote> 
 <p>cv::Scharr (</p> 
 <p>InputArray Src // 输入图像</p> 
 <p>OutputArray dst// 输出图像，大小与输入图像一致</p> 
 <p>int depth // 输出图像深度.</p> 
 <p>int dx.  // X方向，几阶导数</p> 
 <p>int dy // Y方向，几阶导数.</p> 
 <p>double scale  = 1</p> 
 <p>double delta = 0</p> 
 <p>int borderType = BORDER_DEFAULT</p> 
 <p>)</p> 
</blockquote> 
<p>（3）其他的API</p> 
<blockquote> 
 <p>— GaussianBlur( src, dst, Size(3,3), 0, 0, BORDER_DEFAULT );</p> 
 <p>— cvtColor( src,  gray, COLOR_RGB2GRAY );</p> 
 <p>— addWeighted( A, 0.5,B, 0.5, 0, AB); convertScaleAbs(A, B)// 计算图像A的像素绝对值，输出到图像B</p> 
</blockquote> 
<p><img alt="" height="52" src="https://images2.imgbox.com/cc/28/8fOgxHyQ_o.png" width="570"></p> 
<p>（4）代码演示</p> 
<blockquote> 
 <p>图像处理流程：</p> 
 <p>-高斯平滑（高斯模糊）GaussianBlur( )</p> 
 <p>-转灰度</p> 
 <p>-求梯度X和Y：做Sobel索贝尔计算</p> 
 <p>-得到振幅图像</p> 
</blockquote> 
<pre><code class="language-cpp">#include &lt;opencv2/opencv.hpp&gt;
#include &lt;iostream&gt;
#include &lt;math.h&gt;

using namespace cv;
int main(int argc, char** argv) {
	Mat src, dst;
	src = imread("test.jpg");
	if (!src.data) {
		printf("could not load image...\n");
		return -1;
	}

	char INPUT_TITLE[] = "input image";
	char OUTPUT_TITLE[] = "sobel-demo";
	namedWindow(INPUT_TITLE, CV_WINDOW_AUTOSIZE);
	namedWindow(OUTPUT_TITLE, CV_WINDOW_AUTOSIZE);
	imshow(INPUT_TITLE, src);

	Mat gray_src;
	GaussianBlur(src, dst, Size(3, 3), 0, 0);
	cvtColor(dst, gray_src, CV_BGR2GRAY);
	imshow("gray image", gray_src);

	Mat xgrad, ygrad;
	Scharr(gray_src, xgrad, CV_16S, 1, 0);
	Scharr(gray_src, ygrad, CV_16S, 0, 1);

	// Sobel(gray_src, xgrad, CV_16S, 1, 0, 3);
	// Sobel(gray_src, ygrad, CV_16S, 0, 1, 3);

    // 转为绝对值
	convertScaleAbs(xgrad, xgrad);
	convertScaleAbs(ygrad, ygrad);
	imshow("xgrad", xgrad);
	imshow("ygrad", ygrad);

	Mat xygrad = Mat(xgrad.size(), xgrad.type());
	printf("type : %d\n", xgrad.type());
	int width = xgrad.cols;
	int height = ygrad.rows;
	for (int row = 0; row &lt; height; row++) {
		for (int col = 0; col &lt; width; col++) {
			int xg = xgrad.at&lt;uchar&gt;(row, col);
			int yg = ygrad.at&lt;uchar&gt;(row, col);
			int xy = xg + yg;
			xygrad.at&lt;uchar&gt;(row, col) = saturate_cast&lt;uchar&gt;(xy);
		}
	}
	//addWeighted(xgrad, 0.5, ygrad, 0.5, 0, xygrad);
	imshow(OUTPUT_TITLE, xygrad);

	waitKey(0);
	return 0;
}</code></pre> 
<p>效果展示：</p> 
<p><img alt="" height="205" src="https://images2.imgbox.com/f8/eb/nqw2T4Fu_o.png" width="506"></p> 
<h4 id="%E4%BA%8C%E3%80%81Laplance%E7%AE%97%E5%AD%90"><strong>二、Laplance算子</strong></h4> 
<h5 id="1%E3%80%81%E7%90%86%E8%AE%BA"><strong>1、理论</strong></h5> 
<p><strong>解释：</strong>在二阶导数的时候，最大变化处的值为零即边缘是零值。通过二阶 导数计算，依据此理论我们可以计算图像二阶导数，提取边缘。</p> 
<p><img alt="" height="202" src="https://images2.imgbox.com/24/21/hSiGxud5_o.png" width="661"></p> 
<p>实际上就是：拉普拉斯算子操作（Laplance operator）-&gt; cv::Laplance</p> 
<h5 id="2%E3%80%81API%E4%BD%BF%E7%94%A8%EF%BC%88%E4%BB%A3%E7%A0%81%E4%BE%8B%E5%AD%90%EF%BC%89"><strong>2、API使用（代码例子）</strong></h5> 
<p>（1）cv::Laplacian原型：</p> 
<blockquote> 
 <p>Laplacian(</p> 
 <p>InputArray src,</p> 
 <p>OutputArray dst,</p> 
 <p>int depth, //深度CV_16S</p> 
 <p>int kisze, // 3</p> 
 <p>double scale = 1,</p> 
 <p>double delta =0.0,</p> 
 <p>int borderType = 4</p> 
 <p>)</p> 
</blockquote> 
<p>（2）代码演示</p> 
<blockquote> 
 <p>图像处理流程：</p> 
 <p>- 高斯模糊 – 去噪声GaussianBlur()</p> 
 <p>- 转换为灰度图像cvtColor()</p> 
 <p>- 拉普拉斯 – 二阶导数计算Laplacian()</p> 
 <p>-取绝对值convertScaleAbs()</p> 
 <p>-显示结果</p> 
</blockquote> 
<pre><code class="language-cpp">#include &lt;opencv2/opencv.hpp&gt;
#include &lt;iostream&gt;
#include &lt;math.h&gt;

using namespace cv;
int main(int argc, char** argv) {
	Mat src, dst;
	src = imread("test.jpg");
	if (!src.data) {
		printf("could not load image");
	}
	char input_title[] = "input image";
	char output_title[] = "Laplaiance Result";
	namedWindow(input_title, CV_WINDOW_AUTOSIZE);
	imshow(input_title, src);

	Mat gray_src, edge_image;
	GaussianBlur(src, dst, Size(3, 3), 0, 0);
	cvtColor(dst, gray_src, CV_BGR2GRAY);

	Laplacian(gray_src, edge_image, CV_16S, 3);
	convertScaleAbs(edge_image, edge_image);

    // 边缘处理
	threshold(edge_image, edge_image, 0, 255, THRESH_OTSU | THRESH_BINARY);
	namedWindow(output_title, CV_WINDOW_AUTOSIZE);
	imshow(output_title, edge_image);

	waitKey(0);
	return 0;
}</code></pre> 
<p>效果展示：</p> 
<p><img alt="" height="256" src="https://images2.imgbox.com/7e/87/yf7YWoZN_o.png" width="424"></p> 
<h4 id="%E4%B8%89%E3%80%81Canny%E8%BE%B9%E7%BC%98%E6%A3%80%E6%B5%8B"><strong>三、Canny边缘检测</strong></h4> 
<h5 id="1%E3%80%81Canny%E7%AE%97%E6%B3%95%E4%BB%8B%E7%BB%8D" style="background-color:transparent;"><strong>1、Canny算法介绍</strong></h5> 
<p>（1）简介：Canny算法是一种经典的边缘检测算法，常用于计算机视觉和图像处理领域。</p> 
<p>它由John F. Canny在1986年提出，并被广泛应用于图像分割、目标检测等任务中。</p> 
<p>（3）图像处理流程：</p> 
<blockquote> 
 <p>图像处理流程：</p> 
 <p>- 高斯模糊 - GaussianBlur，对图像进行降噪，避免影响最终的结果</p> 
 <p>- 灰度转换 - cvtColor，必须是8位的灰度图像</p> 
 <p>- 计算梯度 – Sobel/Scharr</p> 
 <p>- 非最大信号抑制</p> 
 <p>- 高低阈值</p> 
 <p>- 输出二值图像</p> 
</blockquote> 
<p>（3）非最大信号抑制：图表边缘的信号很强，边缘信号只有一个，要对非边缘信号进行抑制。要对法线或者切线方向的值去掉。</p> 
<p>        对梯度幅值图像进行非极大值抑制。这一步骤的目的是将边缘细化为单像素宽度，并抑制非最大值区域。具体来说，对于每个像素，只有在其梯度方向上具有最大幅值的像素才被保留。</p> 
<p><img alt="" height="387" src="https://images2.imgbox.com/1a/e3/lUYOjP8L_o.png" width="923"></p> 
<p>（4）高低阈值输出二值图像：</p> 
<p>        根据两个阈值（高阈值和低阈值）对非极大值抑制后的图像进行阈值处理。高阈值用于确定强边缘，而低阈值用于确定弱边缘。具体来说，如果某个像素的梯度幅值大于高阈值，则将其标记为强边缘；如果某个像素的梯度幅值介于低阈值和高阈值之间，则将其标记为弱边缘；如果某个像素的梯度幅值小于低阈值，则将其丢弃。</p> 
<p>一个为高阈值，一个为低阈值（T1和T2）；</p> 
<blockquote> 
 <p>— T1， T2为阈值，凡是高于T2的都保留（是很强的边缘像素 ），凡是小于T1都丢弃，从高于T2的像素出发，凡是大于T1而且相互连接的，都保留。最终得到一个输出二值图像。</p> 
 <p>— 推荐的高低阈值比值为 T2: T1 = 3:1/2:1，其中T2为高阈值，T1为低阈值。</p> 
</blockquote> 
<p>（5）边缘连接</p> 
<p>        通过连接强边缘和与之相连的弱边缘来形成完整的边缘。具体来说，如果某个弱边缘与某个强边缘在空间上相邻接，则将其标记为强边缘。</p> 
<h5><strong>2、API使用（代码例子）</strong></h5> 
<p>（1）cv::Canny原型</p> 
<blockquote> 
 <p>Canny（</p> 
 <p>InputArray src, // 8-bit的输入图像</p> 
 <p>OutputArray edges,// 输出边缘图像， 一般都是二值图像，背景是黑色</p> 
 <p>double threshold1,// 低阈值，常取高阈值的1/2或者1/3</p> 
 <p>double threshold2,// 高阈值</p> 
 <p>int aptertureSize,// Soble算子的size，通常3x3，取值3</p> 
 <p>bool L2gradient // 选择 true表示是L2来归一化，否则用L1归一化</p> 
 <p>）</p> 
</blockquote> 
<p>（2）代码演示</p> 
<pre><code class="language-cpp">#include &lt;opencv2/opencv.hpp&gt;
#include &lt;iostream&gt;
#include &lt;math.h&gt;

using namespace cv;
Mat src, gray_src, dst;
int t1_value = 50;
int max_value = 255;
const char* OUTPUT_TITLE = "Canny Result";
void Canny_Demo(int, void*);
int main(int argc, char** argv) {
	src = imread("test,jpg");
	if (!src.data) {
		printf("could not load image...\n");
		return -1;
	}

	char INPUT_TITLE[] = "input image";
	namedWindow(INPUT_TITLE, CV_WINDOW_AUTOSIZE);
	namedWindow(OUTPUT_TITLE, CV_WINDOW_AUTOSIZE);
	imshow(INPUT_TITLE, src);

	cvtColor(src, gray_src, CV_BGR2GRAY);
	createTrackbar("Threshold Value:", OUTPUT_TITLE, &amp;t1_value, max_value, Canny_Demo);
	Canny_Demo(0, 0);

	waitKey(0);
	return 0;
}

void Canny_Demo(int, void*) {
	Mat edge_output;
	blur(gray_src, gray_src, Size(3, 3), Point(-1, -1), BORDER_DEFAULT);
	Canny(gray_src, edge_output, t1_value, t1_value * 2, 3, false);

	//dst.create(src.size(), src.type());

    // 使用遮罩层，只有非零的元素才会被copy到模板中
	//src.copyTo(dst, edge_output);

    // ~取反输出
	imshow(OUTPUT_TITLE, ~edge_output);
}</code></pre> 
<p>效果展示：</p> 
<p><img alt="" height="216" src="https://images2.imgbox.com/6e/bc/Us055PrL_o.png" width="533"></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/5525fc4107219c6a56edd5036c2c2d05/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">Android_Error_AS启动失败_UI initialization failed</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/6cd37b460e0e90fe5cdbe775a343f67c/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">时间格式 yyyyMMdd</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>