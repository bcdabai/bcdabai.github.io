<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>python给子线程加参数_python中的线程threading.Thread()使用详解 - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="python给子线程加参数_python中的线程threading.Thread()使用详解" />
<meta property="og:description" content="1. 线程的概念：
线程，有时被称为轻量级进程(Lightweight Process，LWP)，是程序执行流的最小单元。一个标准的线程由线程ID，当前指令指针(PC)，寄存器集合和堆栈组成。另外，线程是进程中的一个实体，是被系统独立调度和分派的基本单位，线程自己不拥有系统资源，只拥有一点儿在运行中必不可少的资源，但它可与同属一个进程的其它线程共享进程所拥有的全部资源。
2. threading.thread()的简单使用
2.1 python的thread模块是比较底层的模块，python的threading模块是对thread做了一些包装的，可以更加方便的被使用
import threading
import time
def saySorry():
print(&#34;亲爱的，我错了，我能吃饭了吗？&#34;)
time.sleep(1)
if __name__ == &#34;__main__&#34;:
for i in range(5):
t = threading.Thread(target=saySorry)
t.start() #启动线程，即让线程开始执行
运行结果：
使用说明：
可以明显看出使用了多线程并发的操作，花费时间要短很多
当调用start()时，才会真正的创建线程，并且开始执行
每个线程都有一个唯一标示符，来区分线程中的主次关系
主线程:mainThread,Main函数或者程序主入口，都可以称为主线程
子线程:Thread-x 使用 threading.Thread() 创建出来的都是子线程
线程数量：主线程数 &#43; 子线程数
2.2 主线程会等待所有的子线程结束后才结束
import threading
from time import sleep,ctime
def sing():
for i in range(3):
print(&#34;正在唱歌...%d&#34;%i)
sleep(1)
def dance():
for i in range(3):
print(&#34;正在跳舞...%d&#34;%i)
sleep(1)
if __name__ == &#34;" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/cb1f8b2228ad7de700f569052315bc74/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2021-02-04T09:36:46+08:00" />
<meta property="article:modified_time" content="2021-02-04T09:36:46+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">python给子线程加参数_python中的线程threading.Thread()使用详解</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <div style="font-size:16px;"> 
 <p>1. 线程的概念：</p> 
 <p>线程，有时被称为轻量级进程(Lightweight Process，LWP)，是程序执行流的最小单元。一个标准的线程由线程ID，当前指令指针(PC)，寄存器集合和堆栈组成。另外，线程是进程中的一个实体，是被系统独立调度和分派的基本单位，线程自己不拥有系统资源，只拥有一点儿在运行中必不可少的资源，但它可与同属一个进程的其它线程共享进程所拥有的全部资源。</p> 
 <p>2. threading.thread()的简单使用</p> 
 <p>2.1 python的thread模块是比较底层的模块，python的threading模块是对thread做了一些包装的，可以更加方便的被使用</p> 
 <p>import threading</p> 
 <p>import time</p> 
 <p>def saySorry():</p> 
 <p>print("亲爱的，我错了，我能吃饭了吗？")</p> 
 <p>time.sleep(1)</p> 
 <p>if __name__ == "__main__":</p> 
 <p>for i in range(5):</p> 
 <p>t = threading.Thread(target=saySorry)</p> 
 <p>t.start() #启动线程，即让线程开始执行</p> 
 <p>运行结果：</p> 
 <p align="center"><img src="https://images2.imgbox.com/86/31/I1WOWMej_o.png" alt="08e688f26f1b27a94bcc42a5f945b56a.png"></p> 
 <p>使用说明：</p> 
 <p>可以明显看出使用了多线程并发的操作，花费时间要短很多</p> 
 <p>当调用start()时，才会真正的创建线程，并且开始执行</p> 
 <p>每个线程都有一个唯一标示符，来区分线程中的主次关系</p> 
 <p>主线程:mainThread,Main函数或者程序主入口，都可以称为主线程</p> 
 <p>子线程:Thread-x 使用 threading.Thread() 创建出来的都是子线程</p> 
 <p>线程数量：主线程数 + 子线程数</p> 
 <p>2.2 主线程会等待所有的子线程结束后才结束</p> 
 <p>import threading</p> 
 <p>from time import sleep,ctime</p> 
 <p>def sing():</p> 
 <p>for i in range(3):</p> 
 <p>print("正在唱歌...%d"%i)</p> 
 <p>sleep(1)</p> 
 <p>def dance():</p> 
 <p>for i in range(3):</p> 
 <p>print("正在跳舞...%d"%i)</p> 
 <p>sleep(1)</p> 
 <p>if __name__ == "__main__":</p> 
 <p>print("---开始---:%s"%ctime())</p> 
 <p>t1 = threading.Thread(target=sing)</p> 
 <p>t2 = threading.Thread(target=dance)</p> 
 <p>t1.start()</p> 
 <p>t2.start()</p> 
 <p>#sleep(5) # 屏蔽此行代码，试试看，程序是否会立马结束？</p> 
 <p>print("---结束---:%s"%ctime())</p> 
 <p align="center"><img src="https://images2.imgbox.com/72/1f/tXXCvqtN_o.png" alt="8b2c07d9cdee0b73739fc9169a68f2d5.png"></p> 
 <p>3.查看线程数量</p> 
 <p>import threading</p> 
 <p>from time import sleep,ctime</p> 
 <p>def sing():</p> 
 <p>for i in range(3):</p> 
 <p>print("正在唱歌...%d"%i)</p> 
 <p>sleep(1)</p> 
 <p>def dance():</p> 
 <p>for i in range(3):</p> 
 <p>print("正在跳舞...%d"%i)</p> 
 <p>sleep(1)</p> 
 <p>if __name__ == "__main__":</p> 
 <p>print("---开始---:%s"%ctime())</p> 
 <p>t1 = threading.Thread(target=sing)</p> 
 <p>t2 = threading.Thread(target=dance)</p> 
 <p>t1.start()</p> 
 <p>t2.start()</p> 
 <p>while True:</p> 
 <p>length = len(threading.enumerate())</p> 
 <p>print("当前运行的线程数为：%d"%length)</p> 
 <p>if length&lt;=1:</p> 
 <p>break</p> 
 <p>sleep(0.5)</p> 
 <p align="center"><img src="https://images2.imgbox.com/59/82/QysPWKgq_o.png" alt="80e19a79a9bd403bfb1710b11434406f.png"></p> 
 <p>4.线程参数及顺序</p> 
 <p>4.1 传递参数的方法：</p> 
 <p>使用args 传递参数 threading.Thread(target=sing, args=(10, 100, 100))</p> 
 <p>使用kwargs传递参数 threading.Thread(target=sing, kwargs={“a”: 10, “b”:100, “c”: 100})</p> 
 <p>同时使用 args 和 kwargs 传递参数 threading.Thread(target=sing, args=(10, ), kwargs={“b”: 100,“c”: 100})</p> 
 <p>4.2 线程的执行顺序</p> 
 <p>import socket</p> 
 <p>import threading</p> 
 <p>import time</p> 
 <p>def sing():</p> 
 <p>for i in range(10):</p> 
 <p>print("------------------------------")</p> 
 <p>time.sleep(0.5)</p> 
 <p>def dance():</p> 
 <p>for i in range(10):</p> 
 <p>print("-----")</p> 
 <p>time.sleep(0.5)</p> 
 <p>if __name__ == "__main__":</p> 
 <p># 创建两个子线程</p> 
 <p>t1 = threading.Thread(target=sing)</p> 
 <p>t2 = threading.Thread(target=dance)</p> 
 <p># 启动子线程</p> 
 <p>t1.start()</p> 
 <p>t2.start()</p> 
 <p>说明:</p> 
 <p>从代码和执行结果我们可以看出，多线程程序的执行顺序是不确定的。当执行到sleep语句时，线程将被阻塞(Blocked)，到sleep结束后，线程进入就绪(Runnable)状态，等待调度。而线程调度将自行选择一个线程执行。上面的代码中只能保证每个线程都运行完整个run函数，但是线程的启动顺序、run函数中每次循环的执行顺序都不能确定。</p> 
 <p>5. 守护线程</p> 
 <p>守护线程：如果在程序中将子线程设置为守护线程，则该子线程会在主线程结束时自动退出，设置方式为thread.setDaemon(True)，要在thread.start()之前设置，默认是false的，也就是主线程结束时，子线程依然在执行。</p> 
 <p>5.1 如下代码，主线程已经exit() 【其实并没有真正结束】，子线程还在继续执行</p> 
 <p>import threading</p> 
 <p>import time</p> 
 <p>def test():</p> 
 <p>for i in range(10):</p> 
 <p>print("test is run:", i)</p> 
 <p>time.sleep(1)</p> 
 <p>if __name__ == "__main__":</p> 
 <p># 创建子线程</p> 
 <p>t1 = threading.Thread(target=test)</p> 
 <p># 启动子线程</p> 
 <p>t1.start()</p> 
 <p># 休眠2秒</p> 
 <p>time.sleep(2)</p> 
 <p>print("我 OVER 了")</p> 
 <p># 退出</p> 
 <p>exit()</p> 
 <p align="center"><img src="https://images2.imgbox.com/a9/6a/etsgt828_o.png" alt="8121bcd747175333c38bd751fcabcef8.png"></p> 
 <p>5.2 设置守护线程</p> 
 <p>设置为守护线程(如果主线程结束了，也随之结束)</p> 
 <p>线程.setDaemon(True)</p> 
 <p align="center"><img src="https://images2.imgbox.com/65/59/nuLLbdtA_o.png" alt="9d416896019753db07ac14d2e3ad8c9d.png"></p> 
 <p>以上就是本文的全部内容，希望对大家的学习有所帮助，也希望大家多多支持云海天教程。</p> 
</div>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/9ac653b990465f5ca187f260f0364818/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">把Java程序的输出结果写入文件的方法</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/2dd4f4b84068344b72fae14b6c0d94b8/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">谷歌浏览器:检查更新时出错：无法启动更新检查（错误代码为 4: 0x80070005 -- system level）</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>