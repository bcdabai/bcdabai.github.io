<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>MySQL的分布式——flask-sqlalchemy实现读写分离 - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="MySQL的分布式——flask-sqlalchemy实现读写分离" />
<meta property="og:description" content="目录 1、复制1.1 主从架构（一主多从）1.2 主备架构1.3 高可用复合架构 2、flask-sqlalchemy实现读写分离3、分片3.1 垂直拆分3.1.1 垂直分表3.1.2 垂直分库 3.2 水平拆分3.2.1 水平分表 4、分布式的问题4.1 分布式事物问题解决方案4.2 解决跨节点 Join/排序/分页 1、复制 作用：
对数据进行备份，实现高可用HA通过读写分离，提高吞吐量，实现高性能 原理：
当主库中有数据更新时，主库会将该操作写入一个二进制日志文件中，从库中专门有一个io线程去读取主库的二进制文件的内容，但不会立即写入从库，而是将它写入一个延后中继日志文件，然后再通过SQL线程，重做中继日志文件中的数据修改的操作，保存到从库中去，从而完成主库和从库的数据同步。 1.1 主从架构（一主多从） 读写分离，提高吞吐量 主库只有一台，一旦挂了，无法写入，所以主库并没有实现高可用 从库实现了高可用 1.2 主备架构 单库读写，没有实现读写分离, 性能一般 高可用, 一旦主库挂了, 就启用备库 这种方案被阿里云、美团等企业广泛使用 问题: 既然主备互为备份, 为什么不采用双主方案, 提供两台主进行负载均衡?
原因是：为了避免数据的冲突，防止造成数据的不一致性。 虽然在两边执行的修改有先后顺序，但由于 Replication 是异步的实现机制，同样可能会导致 晚做的修改被早做的修改所覆盖
1.3 高可用复合架构 相当于优化前面两个方案
读写分离, 提高吞吐量 高可用, 一旦主库挂了, 就启用备库，主从库都实现了高可用 2、flask-sqlalchemy实现读写分离 sqlalchemy 并没有像 django-orm 一样内置完善的读写分离方案, 但是提供了可以自定义的接口: 官方文档, 我们可以借此对 flask-sqlalchemy 进行二次开发, 实现读写分离
基本实现思路:
实现自定义的 session类, 继承 SignallingSession类重写 get_bind方法, 根据读写需求选择对应的数据库地址实现自定义的 SQLAlchemy类, 继承 SQLAlchemy类重写 create_session方法, 在内部使用自定义的 Session类 环境准备：搭建好两台数据库，1个主、2个从数据库" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/f12d2a869a648744471053a5538535fd/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2020-11-12T18:37:01+08:00" />
<meta property="article:modified_time" content="2020-11-12T18:37:01+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">MySQL的分布式——flask-sqlalchemy实现读写分离</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p></p> 
<div class="toc"> 
 <h4>目录</h4> 
 <ul><li><ul><li><ul><li><a href="#1_3" rel="nofollow">1、复制</a></li><li><ul><li><a href="#11__12" rel="nofollow">1.1 主从架构（一主多从）</a></li><li><a href="#12__19" rel="nofollow">1.2 主备架构</a></li><li><a href="#13__27" rel="nofollow">1.3 高可用复合架构</a></li></ul> 
    </li><li><a href="#2flasksqlalchemy_35" rel="nofollow">2、flask-sqlalchemy实现读写分离</a></li><li><a href="#3_172" rel="nofollow">3、分片</a></li><li><ul><li><a href="#31__187" rel="nofollow">3.1 垂直拆分</a></li><li><ul><li><a href="#311__188" rel="nofollow">3.1.1 垂直分表</a></li><li><a href="#312__199" rel="nofollow">3.1.2 垂直分库</a></li></ul> 
     </li><li><a href="#32__216" rel="nofollow">3.2 水平拆分</a></li><li><ul><li><a href="#321__217" rel="nofollow">3.2.1 水平分表</a></li></ul> 
    </li></ul> 
    </li><li><a href="#4_224" rel="nofollow">4、分布式的问题</a></li><li><ul><li><a href="#41__229" rel="nofollow">4.1 分布式事物问题解决方案</a></li><li><a href="#42__Join_257" rel="nofollow">4.2 解决跨节点 Join/排序/分页</a></li></ul> 
   </li></ul> 
  </li></ul> 
 </li></ul> 
</div> 
<p></p> 
<h4><a id="1_3"></a>1、复制</h4> 
<p><strong>作用</strong>：</p> 
<ul><li>对数据进行备份，实现高可用HA</li><li>通过读写分离，提高吞吐量，实现高性能</li></ul> 
<p><strong>原理</strong>：</p> 
<ul><li>当主库中有数据更新时，<strong>主库</strong>会将该操作写入一个<strong>二进制日志文件</strong>中，从库中专门有一个<strong>io线程</strong>去读取主库的二进制文件的内容，但不会立即写入从库，而是将它<strong>写入一个延后中继日志文件</strong>，然后再通过<strong>SQL线程</strong>，<strong>重做</strong>中继日志文件中的数据修改的操作，保存到从库中去，从而完成主库和从库的数据同步。</li></ul> 
<p><img src="https://images2.imgbox.com/93/15/2mAIaPH5_o.png" alt="在这里插入图片描述"></p> 
<h5><a id="11__12"></a>1.1 主从架构（一主多从）</h5> 
<pre><code>读写分离，提高吞吐量
主库只有一台，一旦挂了，无法写入，所以主库并没有实现高可用
从库实现了高可用
</code></pre> 
<p><img src="https://images2.imgbox.com/b6/19/fAUBJ2Q3_o.png" alt="在这里插入图片描述"></p> 
<h5><a id="12__19"></a>1.2 主备架构</h5> 
<pre><code>单库读写，没有实现读写分离, 性能一般
高可用, 一旦主库挂了, 就启用备库
这种方案被阿里云、美团等企业广泛使用
</code></pre> 
<p><img src="https://images2.imgbox.com/bb/0f/kc9JuwnQ_o.png" alt="在这里插入图片描述"></p> 
<blockquote> 
 <p><strong>问题</strong>: 既然主备互为备份, 为什么不采用双主方案, 提供两台主进行负载均衡?<br> <strong>原因</strong>是：为了避免数据的冲突，防止造成数据的不一致性。 虽然在两边执行的修改有先后顺序，但由于 Replication 是异步的实现机制，同样可能会导致 晚做的修改被早做的修改所覆盖<br> <img src="https://images2.imgbox.com/ac/01/AA6L0djk_o.png" alt="在这里插入图片描述"></p> 
</blockquote> 
<h5><a id="13__27"></a>1.3 高可用复合架构</h5> 
<p>相当于优化前面两个方案</p> 
<pre><code>读写分离, 提高吞吐量
高可用, 一旦主库挂了, 就启用备库，主从库都实现了高可用
</code></pre> 
<p><img src="https://images2.imgbox.com/f9/32/BSp3vhfm_o.png" alt="在这里插入图片描述"></p> 
<h4><a id="2flasksqlalchemy_35"></a>2、flask-sqlalchemy实现读写分离</h4> 
<blockquote> 
 <p>sqlalchemy 并没有像 django-orm 一样内置完善的读写分离方案, 但是提供了可以自定义的接口: <a href="https://docs.sqlalchemy.org/en/13/orm/persistence_techniques.html#custom-vertical-partitioning" rel="nofollow">官方文档</a>, 我们可以借此对 flask-sqlalchemy 进行二次开发, 实现读写分离</p> 
</blockquote> 
<p><strong>基本实现思路</strong>:</p> 
<ul><li>实现自定义的 session类, 继承 SignallingSession类</li><li>重写 get_bind方法, 根据读写需求选择对应的数据库地址</li><li>实现自定义的 SQLAlchemy类, 继承 SQLAlchemy类</li><li>重写 create_session方法, 在内部使用自定义的 Session类</li></ul> 
<p><strong>环境准备</strong>：搭建好两台数据库，1个主、2个从数据库<br> 主数据库端口 3306<br> 从数据库端口 8306</p> 
<p><strong>二次开发代码实现</strong>：</p> 
<pre><code class="prism language-python"><span class="token keyword">import</span> random
<span class="token keyword">from</span> flask_sqlalchemy <span class="token keyword">import</span> SQLAlchemy<span class="token punctuation">,</span> SignallingSession<span class="token punctuation">,</span> get_state
<span class="token keyword">from</span> flask <span class="token keyword">import</span> Flask
<span class="token keyword">from</span> sqlalchemy <span class="token keyword">import</span> orm

<span class="token comment"># 1.创建app对象</span>
app <span class="token operator">=</span> Flask<span class="token punctuation">(</span>__name__<span class="token punctuation">)</span>

<span class="token comment"># 2.添加数据库配置信息</span>
<span class="token comment"># app.config["SQLALCHEMY_DATABASE_URI"] = "mysql://账号:密码@ip地址:端口/数据库名称"</span>
<span class="token comment"># 单库连接信息</span>
<span class="token comment"># app.config["SQLALCHEMY_DATABASE_URI"] = "mysql+pymysql://root:mysql@192.168.243.157:3306/test39"</span>
<span class="token comment"># 多库连接信息</span>
app<span class="token punctuation">.</span>config<span class="token punctuation">[</span><span class="token string">"SQLALCHEMY_BINDS"</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{<!-- --></span>
    <span class="token string">"master"</span><span class="token punctuation">:</span> <span class="token string">"mysql+pymysql://root:mysql@192.168.243.157:3306/test39"</span><span class="token punctuation">,</span>  <span class="token comment"># 主库</span>
    <span class="token string">"slave1"</span><span class="token punctuation">:</span> <span class="token string">"mysql+pymysql://root:mysql@192.168.243.157:8306/test39"</span><span class="token punctuation">,</span>  <span class="token comment"># 从库1</span>
    <span class="token string">"slave2"</span><span class="token punctuation">:</span> <span class="token string">"mysql+pymysql://root:mysql@192.168.243.157:3306/test39"</span><span class="token punctuation">,</span>  <span class="token comment"># 从库2</span>
<span class="token punctuation">}</span>
app<span class="token punctuation">.</span>config<span class="token punctuation">[</span><span class="token string">"SQLALCHEMY_TRACK_MODIFICATIONS"</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token boolean">False</span>
app<span class="token punctuation">.</span>config<span class="token punctuation">[</span><span class="token string">"SQLALCHEMY_ECHO"</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token boolean">True</span>


<span class="token comment"># 3.1 自定义session，继承于SignallingSession 重写get_bind方法，实现读写分离</span>
<span class="token keyword">class</span> <span class="token class-name">RoutingSession</span><span class="token punctuation">(</span>SignallingSession<span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> <span class="token operator">*</span>args<span class="token punctuation">,</span> <span class="token operator">**</span>kwargs<span class="token punctuation">)</span><span class="token punctuation">:</span>
        <span class="token builtin">super</span><span class="token punctuation">(</span>RoutingSession<span class="token punctuation">,</span> self<span class="token punctuation">)</span><span class="token punctuation">.</span>__init__<span class="token punctuation">(</span><span class="token operator">*</span>args<span class="token punctuation">,</span> <span class="token operator">**</span>kwargs<span class="token punctuation">)</span>

    <span class="token keyword">def</span> <span class="token function">get_bind</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> mapper<span class="token operator">=</span><span class="token boolean">None</span><span class="token punctuation">,</span> clause<span class="token operator">=</span><span class="token boolean">None</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
        <span class="token triple-quoted-string string">"""每次数据库操作(增删改查及事务操作)都会调用该方法, 来获取对应的数据库引擎(访问的数据库)"""</span>
        state <span class="token operator">=</span> get_state<span class="token punctuation">(</span>self<span class="token punctuation">.</span>app<span class="token punctuation">)</span>
        <span class="token keyword">if</span> mapper <span class="token keyword">is</span> <span class="token operator">not</span> <span class="token boolean">None</span><span class="token punctuation">:</span>
            <span class="token keyword">try</span><span class="token punctuation">:</span>
                <span class="token comment"># SA &gt;= 1.3</span>
                persist_selectable <span class="token operator">=</span> mapper<span class="token punctuation">.</span>persist_selectable
            <span class="token keyword">except</span> AttributeError<span class="token punctuation">:</span>
                <span class="token comment"># SA &lt; 1.3</span>
                persist_selectable <span class="token operator">=</span> mapper<span class="token punctuation">.</span>mapped_table
            <span class="token comment"># 如果项目中指明了特定数据库，就获取到bind_key指明的数据库，进行数据库绑定</span>
            info <span class="token operator">=</span> <span class="token builtin">getattr</span><span class="token punctuation">(</span>persist_selectable<span class="token punctuation">,</span> <span class="token string">'info'</span><span class="token punctuation">,</span> <span class="token punctuation">{<!-- --></span><span class="token punctuation">}</span><span class="token punctuation">)</span>
            bind_key <span class="token operator">=</span> info<span class="token punctuation">.</span>get<span class="token punctuation">(</span><span class="token string">'bind_key'</span><span class="token punctuation">)</span>
            <span class="token keyword">if</span> bind_key <span class="token keyword">is</span> <span class="token operator">not</span> <span class="token boolean">None</span><span class="token punctuation">:</span>
                <span class="token keyword">return</span> state<span class="token punctuation">.</span>db<span class="token punctuation">.</span>get_engine<span class="token punctuation">(</span>self<span class="token punctuation">.</span>app<span class="token punctuation">,</span> bind<span class="token operator">=</span>bind_key<span class="token punctuation">)</span>

                <span class="token comment"># 使用默认的主数据库</span>
                <span class="token comment"># SQLALCHEMY_DATABASE_URI 返回数据库引擎</span>
                <span class="token comment"># return SessionBase.get_bind(self, mapper, clause)</span>

        <span class="token keyword">from</span> sqlalchemy<span class="token punctuation">.</span>sql<span class="token punctuation">.</span>dml <span class="token keyword">import</span> UpdateBase
        <span class="token comment"># 写操作 或者 更新 删除操作 - 访问主库</span>
        <span class="token keyword">if</span> self<span class="token punctuation">.</span>_flushing <span class="token operator">or</span> <span class="token builtin">isinstance</span><span class="token punctuation">(</span>clause<span class="token punctuation">,</span> UpdateBase<span class="token punctuation">)</span><span class="token punctuation">:</span>
            <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"写更新删除 访问主库"</span><span class="token punctuation">)</span>
            <span class="token comment"># 返回主库的数据库引擎</span>
            <span class="token keyword">return</span> state<span class="token punctuation">.</span>db<span class="token punctuation">.</span>get_engine<span class="token punctuation">(</span>self<span class="token punctuation">.</span>app<span class="token punctuation">,</span> bind<span class="token operator">=</span><span class="token string">"master"</span><span class="token punctuation">)</span>
        <span class="token keyword">else</span><span class="token punctuation">:</span>
            <span class="token comment"># 读操作--访问从库</span>
            slave_key <span class="token operator">=</span> random<span class="token punctuation">.</span>choice<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token string">"slave1"</span><span class="token punctuation">,</span> <span class="token string">"slave2"</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
            <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"访问从库:{}"</span><span class="token punctuation">.</span><span class="token builtin">format</span><span class="token punctuation">(</span>slave_key<span class="token punctuation">)</span><span class="token punctuation">)</span>
            <span class="token comment"># 返回从库的数据库引擎</span>
            <span class="token keyword">return</span> state<span class="token punctuation">.</span>db<span class="token punctuation">.</span>get_engine<span class="token punctuation">(</span>self<span class="token punctuation">.</span>app<span class="token punctuation">,</span> bind<span class="token operator">=</span>slave_key<span class="token punctuation">)</span>


<span class="token comment"># 3.2 自定义RoutingSQLAlchemy，继承于SQLAlchemy，重写写create_session，替换底层的SignallingSession</span>
<span class="token keyword">class</span> <span class="token class-name">RoutingSQLAlchemy</span><span class="token punctuation">(</span>SQLAlchemy<span class="token punctuation">)</span><span class="token punctuation">:</span>

    <span class="token keyword">def</span> <span class="token function">create_session</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> options<span class="token punctuation">)</span><span class="token punctuation">:</span>
        <span class="token comment"># 使用自定义实现了读写分离的RoutingSession</span>
        <span class="token keyword">return</span> orm<span class="token punctuation">.</span>sessionmaker<span class="token punctuation">(</span>class_<span class="token operator">=</span>RoutingSession<span class="token punctuation">,</span> db<span class="token operator">=</span>self<span class="token punctuation">,</span> <span class="token operator">**</span>options<span class="token punctuation">)</span>


<span class="token comment"># 3.3根据RoutingSQLAlchemy创建数据库对象</span>
db <span class="token operator">=</span> RoutingSQLAlchemy<span class="token punctuation">(</span>app<span class="token punctuation">)</span>

<span class="token comment"># db数据库功能： 1.模型类指定数据库查询  2.读写分离  3.定向查询[想查那个数据库只需要将数据库名字传入即可]</span>


<span class="token comment"># 4.自定义模型类</span>
<span class="token comment"># 构建模型类</span>
<span class="token keyword">class</span> <span class="token class-name">User</span><span class="token punctuation">(</span>db<span class="token punctuation">.</span>Model<span class="token punctuation">)</span><span class="token punctuation">:</span>
    __tablename__ <span class="token operator">=</span> <span class="token string">'t_user'</span>
    <span class="token builtin">id</span> <span class="token operator">=</span> db<span class="token punctuation">.</span>Column<span class="token punctuation">(</span>db<span class="token punctuation">.</span>Integer<span class="token punctuation">,</span> primary_key<span class="token operator">=</span><span class="token boolean">True</span><span class="token punctuation">)</span>
    name <span class="token operator">=</span> db<span class="token punctuation">.</span>Column<span class="token punctuation">(</span>db<span class="token punctuation">.</span>String<span class="token punctuation">(</span><span class="token number">20</span><span class="token punctuation">)</span><span class="token punctuation">,</span> unique<span class="token operator">=</span><span class="token boolean">True</span><span class="token punctuation">)</span>
    age <span class="token operator">=</span> db<span class="token punctuation">.</span>Column<span class="token punctuation">(</span>db<span class="token punctuation">.</span>Integer<span class="token punctuation">,</span> default<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">,</span> index<span class="token operator">=</span><span class="token boolean">True</span><span class="token punctuation">)</span>


@app<span class="token punctuation">.</span>route<span class="token punctuation">(</span><span class="token string">'/'</span><span class="token punctuation">)</span>
<span class="token keyword">def</span> <span class="token function">hello_world</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token comment"># 写操作 -- 访问主库</span>
    <span class="token comment"># write_data()</span>
    <span class="token comment"># 读操作 -- 访问从库</span>
    <span class="token comment"># read_data()</span>
    <span class="token comment"># 更新操作 -- 访问主库</span>
    update_data<span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token keyword">return</span> <span class="token string">'Hello World!'</span>


<span class="token keyword">def</span> <span class="token function">write_data</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
    user1 <span class="token operator">=</span> User<span class="token punctuation">(</span>name<span class="token operator">=</span><span class="token string">"xiaoming"</span><span class="token punctuation">,</span> age<span class="token operator">=</span><span class="token number">18</span><span class="token punctuation">)</span>
    db<span class="token punctuation">.</span>session<span class="token punctuation">.</span>add<span class="token punctuation">(</span>user1<span class="token punctuation">)</span>
    db<span class="token punctuation">.</span>session<span class="token punctuation">.</span>commit<span class="token punctuation">(</span><span class="token punctuation">)</span>


<span class="token keyword">def</span> <span class="token function">read_data</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
    user1 <span class="token operator">=</span> User<span class="token punctuation">.</span>query<span class="token punctuation">.</span><span class="token builtin">filter</span><span class="token punctuation">(</span>User<span class="token punctuation">.</span>name <span class="token operator">==</span> <span class="token string">"xiaoming"</span><span class="token punctuation">)</span><span class="token punctuation">.</span>first<span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token keyword">print</span><span class="token punctuation">(</span>user1<span class="token punctuation">)</span>


<span class="token keyword">def</span> <span class="token function">update_data</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
    User<span class="token punctuation">.</span>query<span class="token punctuation">.</span><span class="token builtin">filter</span><span class="token punctuation">(</span>User<span class="token punctuation">.</span>age <span class="token operator">==</span> <span class="token number">18</span><span class="token punctuation">)</span><span class="token punctuation">.</span>update<span class="token punctuation">(</span><span class="token punctuation">{<!-- --></span><span class="token string">"name"</span><span class="token punctuation">:</span> <span class="token string">"curry"</span><span class="token punctuation">}</span><span class="token punctuation">)</span>
    db<span class="token punctuation">.</span>session<span class="token punctuation">.</span>commit<span class="token punctuation">(</span><span class="token punctuation">)</span>


<span class="token keyword">if</span> __name__ <span class="token operator">==</span> <span class="token string">'__main__'</span><span class="token punctuation">:</span>
    <span class="token comment"># 默认会根据SQLALCHEMY_DATABASE_URI的连接信息创建和删除表</span>
    <span class="token comment"># TODO:后续可以根据模型类中__bind_key__指定特定数据库创建和删除表</span>
    <span class="token comment"># 删除表</span>
    <span class="token comment"># db.drop_all()</span>
    <span class="token comment"># 创建表</span>
    <span class="token comment"># db.create_all()</span>
    app<span class="token punctuation">.</span>run<span class="token punctuation">(</span>debug<span class="token operator">=</span><span class="token boolean">True</span><span class="token punctuation">,</span> port<span class="token operator">=</span><span class="token number">8000</span><span class="token punctuation">)</span>
</code></pre> 
<h4><a id="3_172"></a>3、分片</h4> 
<p><strong>需求分析</strong>：</p> 
<blockquote> 
 <p>用户请求量太大, 会导致web应用无法及时响应 -&gt; 分布式服务器(分散请求到多个服务器上)<br> 单表太大, 会导致CRUD都成问题, 索引膨胀, 查询超时 -&gt; 拆分表<br> 单库太大, 会导致单库磁盘空间不足; 处理能力有限; 出现IO瓶颈 -&gt; 拆分库</p> 
</blockquote> 
<blockquote> 
 <p>1、<strong>分片</strong>也称为数据拆分 (Shareding), 其主要工作就是对单库单表进行拆分, 多库多表共同组成完整的数据集合。有<strong>垂直拆分</strong>和<strong>水平拆分</strong><br> 2、分片可以提高吞吐量, 同一时间数据的读写完成量更多, 扩充单机存储的容量/读写速度上限</p> 
</blockquote> 
<p><strong>注意</strong>：</p> 
<blockquote> 
 <p>不要轻易分库分表，因为分片会带来 诸多分布式问题, 让应用的复杂度大量增加<br> 应避免"过度设计"和"过早优化", 先尽力去做其他优化，例如：升级硬件、升级网络、读写分离、索引优化、缓存设计等等。<br> 当数据量达到单表瓶颈时候(参考值: 单表记录1000W+/硬盘100G+)，再考虑分库分表<br> 如果需要进行分库分表, 优先考虑垂直拆分</p> 
</blockquote> 
<h5><a id="31__187"></a>3.1 垂直拆分</h5> 
<h6><a id="311__188"></a>3.1.1 垂直分表</h6> 
<blockquote> 
 <p><strong>分析</strong>：<br> 1、对于<strong>字段较多</strong>的表, 每条记录占用的空间也会较多, 导致每次从硬盘中读取的记录以及查询缓存可缓存的记录数量较少, 影响查询查询效率<br> 2、针对字段多的表就可以采用垂直分表来进行拆分, 这样可以减少表体积, 提高查询效率</p> 
</blockquote> 
<p>拆分规则：</p> 
<ul><li> <p><strong>1、相关性</strong>：如: 用户名和密码经常配合使用, 将其分到<code>用户认证表</code>, 生日和邮箱等个人信息经常一起访问, 将其分到<code>用户信息表</code></p> </li><li> <p><strong>2、使用频率</strong>：可以将字段根据 常用 和 不常用 进行划分, 并进行分表处理</p> </li></ul> 
<h6><a id="312__199"></a>3.1.2 垂直分库</h6> 
<ul><li>分析：将一个数据库中的多张表拆分到多个数据库(服务器节点)中</li><li>注意点:<br> 由于 本地事务不支持跨库操作, 所以应该将 有相关联性的表放在同一个库中<br> 如: 如果后续头条项目垂直分库, 将用户相关的放在数据库1, 文章相关的放在数据库2</li></ul> 
<pre><code class="prism language-bash"><span class="token comment"># 默认</span>
数据库   t_user  t_article   

<span class="token comment"># 垂直分表</span>
数据库   t_user_basic    t_user_detail      t_article_basic    t_article_detail   

<span class="token comment"># 垂直分库</span>
数据库1   t_user_basic          t_user_detail  
数据库2   t_article_detail      t_article_basic
</code></pre> 
<h5><a id="32__216"></a>3.2 水平拆分</h5> 
<h6><a id="321__217"></a>3.2.1 水平分表</h6> 
<p>分析：<br> 1、将 一张表的记录 拆分到多张表中；<br> 2、对于记录较多的表（比如用户表，用户太多，全都记录在一张表）, 会出现索引膨胀, 查询超时等问题, 影响用户体验。<br> 3、水平分表后, 将分表分散放在多个数据库节点中（比如：将用户表分成表1、表2，分别存放在数据库1、2）</p> 
<h4><a id="4_224"></a>4、分布式的问题</h4> 
<p>一旦在数据库设计中引入了分布式, 则会带来诸多分布式问题, 这里介绍两个主要的问题:</p> 
<ul><li>1、分布式事务问题（本地事务不支持跨库操作）</li><li>2、跨节点 Join/排序/分页 的问题</li></ul> 
<h5><a id="41__229"></a>4.1 分布式事物问题解决方案</h5> 
<p><strong>方案1</strong>：将有关联的表放在一个数据库中</p> 
<p>同库操作可以使用一个事务<br> 如用户表&amp;用户频道表, 文章基本信息表&amp;文章内容表放在一起</p> 
<p><strong>方案2</strong>：开启二阶段提交协议(简称 2PC协议 / XA协议)</p> 
<p>Mysql从5.6开始支持分布式事务<br> 分布式事务会提供一个 <strong>事务管理器</strong> 来对 各数据库的本地事务进行统一管理, 只有各本地事务都向管理器 <strong>预提交</strong> 成功后, 事务管理器才会统一执行提交处理, 否则统一进行回滚处理</p> 
<p><img src="https://images2.imgbox.com/7e/2f/Sq4aft1c_o.png" alt="在这里插入图片描述"></p> 
<ul><li>sqlalchemy 也支持分布式事务</li></ul> 
<blockquote> 
 <p>只需要在创建 SQLAlchemy对象时, 设置参数 <code>session_options={'twophase': True}</code>即可<br> 设置后, 整个session的所有操作会被放入到一个分布式事务中, 并在整个分布式事务范围内保证原子性</p> 
</blockquote> 
<p><strong>方案3</strong>：基于状态/消息的最终一致性方案</p> 
<ul><li>对于 包含多个子系统的大型项目, 需要保证子系统之间的数据一致性</li><li>单个子系统往往不会操作所有数据库, 但是 每个子系统可以通过定义字段来记录操作的状态, 每完成一个阶段则更新相应的状态</li><li>如下单——付款流程中, 应用A的下单事务完成后更新订单状态为已下单, 应用B付款事务完成后, 再通过 支付回调接口 通知应用A 更新订单状态</li><li>应用B还需要提供一个 支付查询接口, 以便在用户查询或者订单超时的情况下, 让应用A可以查询订单的支付情况</li><li>ebay提出的方案, 理论叫做<strong>BASE</strong></li></ul> 
<p><img src="https://images2.imgbox.com/aa/74/rieo9hfI_o.png" alt="在这里插入图片描述"></p> 
<h5><a id="42__Join_257"></a>4.2 解决跨节点 Join/排序/分页</h5> 
<p><strong>方案1</strong>：分两次查询进行, 在应用端合并</p> 
<p><strong>方案2</strong>：</p> 
<ul><li>使用一些第三方方案(数据库中间件)</li><li>开源框架除了<strong>Mycat</strong>, 功能较少</li><li>需要一定学习成本, 二次开发需要公司具有一定技术实力</li></ul> 
<table><thead><tr><th>名称</th><th>公司</th><th>说明</th></tr></thead><tbody><tr><td><a href="https://github.com/mysql/mysql-router">MySQL Router</a></td><td>Mysql官方</td><td>更新中</td></tr><tr><td><a href="https://github.com/Qihoo360/Atlas">Atlas</a></td><td>360</td><td>读写分离、从库负载均衡、自动分表等</td></tr><tr><td><a href="https://github.com/MyCATApache/Mycat-Server">Mycat</a></td><td>阿里</td><td>读写分离、故障转移、分布式Join、分布式事务、全局唯一ID、分表等</td></tr><tr><td><a href="https://github.com/sysown/proxysql">proxySQL</a></td><td>sysown</td><td>读写分离、故障转移</td></tr></tbody></table>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/c6eb82be2fb762e6e3a1becc71ffe04d/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">statsmodels.tsa.arima.model.ARIMA用户手册（中文）（statsmodels包）</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/6e57bf833b9f05c6d572232e33e3df23/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">1.递归</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>