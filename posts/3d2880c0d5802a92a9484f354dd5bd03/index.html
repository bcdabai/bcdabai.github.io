<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>最大值_GEE上实现NDVI时间序列最大值合成 - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="最大值_GEE上实现NDVI时间序列最大值合成" />
<meta property="og:description" content="由于云雨等影响，使得遥感数据无法有效地观测地面，这种影响在NDVI上表现为低值噪声，为了降低这种影响，通常使用最大值合成的方法，得到相邻时间内最佳观测值作为填充值，从而消除低值噪声。这种方法简单实用，但是无法恢复地表真实情况，且会造成最大值对应的日期发生偏移，通常还要结合各种滤波算法对时间序列数据进行平滑，比如S-G滤波、谐波分析等。
为了实现最大值合成，需要将时间序列数据（ee.Image）转为更易处理的数组（ee.Array）。实现的过程比较简单，使用滑动窗口，在时间序列上取窗口内的最大值作为返回值，具体实现代码：
function MVC(inputNDVIcl , slideWindows) { var halfSize = (slideWindows-1)/2; var imageSize =inputNDVIcl.size(); var list = ee.List.sequence(halfSize, imageSize.subtract(halfSize&#43;1)); //将影像集转为arrayimage var imagesArray = inputNDVIcl.toArray().arrayProject([0]); var date_start =ee.Date(inputNDVIcl.first().get(&#39;system:time_start&#39;)); var slide =ee.ImageCollection( list.map(function(index){ var date = ee.Number(index).add(1).multiply(8); var time = date_start.advance(date, &#39;day&#39;); var slicedarray = imagesArray.arraySlice(0,ee.Number(index).subtract(halfSize).int(),ee.Number(index).add(halfSize&#43;1).int()); return slicedarray.arrayReduce(ee.Reducer.max(),[0]).arrayProject([0]).arrayGet([0][0]).rename(&#34;NDVI&#34;).set(&#34;system:time_start&#34;,time.millis()); }) ); return slide; } 返回值的这段代码我本身有点疑惑
return slicedarray.arrayReduce(ee.Reducer.max(),[0]).arrayGet([0][0]).rename(&#34;NDVI&#34;).set(&#34;system:time_start&#34;,time.millis()); 使用上面这段作为返回值时，在数据量小一点的时候可以正常运行（100景左右），在数据量比较大的时候就会报数组越界的错误。而加上arrayProject([0])之后，又可以正常运行了，不知道是为什么？
我做了几组对比实验，对比了原始数据（全年MODIS NDVI，364景）、八天最大值合成数据，还有这两组数据的sg滤波、谐波分析之后的效果。
原始NDVI时间序列 八天滑动最大值合成NDVI时间序列 原始数据SG滤波 合成数据SG滤波 原始数据谐波分析 合成数据谐波分析 可以看到，由于原始数据较多由云雨造成的低值噪声，未做合成的数据直接做滤波会拉低整体的值，而使用合成之后的时候再进行滤波会与真实情况更接近。即便做了最大值合成，也无法完全消除密集云雨的影响。使用SG滤波对数据的细节有较好的保留，而使用谐波分析则消除了大部分细节，但使数据变得更平滑。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/3d2880c0d5802a92a9484f354dd5bd03/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2021-01-12T02:04:08+08:00" />
<meta property="article:modified_time" content="2021-01-12T02:04:08+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">最大值_GEE上实现NDVI时间序列最大值合成</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <div> 
 <p>由于云雨等影响，使得遥感数据无法有效地观测地面，这种影响在NDVI上表现为低值噪声，为了降低这种影响，通常使用最大值合成的方法，得到相邻时间内最佳观测值作为填充值，从而消除低值噪声。这种方法简单实用，但是无法恢复地表真实情况，且会造成最大值对应的日期发生偏移，通常还要结合各种滤波算法对时间序列数据进行平滑，比如S-G滤波、谐波分析等。</p> 
 <p>为了实现最大值合成，需要将时间序列数据（ee.Image）转为更易处理的数组（ee.Array）。实现的过程比较简单，使用滑动窗口，在时间序列上取窗口内的最大值作为返回值，具体实现代码：</p> 
 <div class="has"> 
  <pre class="has"><code>function MVC(inputNDVIcl , slideWindows)
 {<!-- -->
  var halfSize = (slideWindows-1)/2;
  var imageSize =inputNDVIcl.size();
  var list = ee.List.sequence(halfSize, imageSize.subtract(halfSize+1));
    //将影像集转为arrayimage
  var imagesArray = inputNDVIcl.toArray().arrayProject([0]);
  var date_start =ee.Date(inputNDVIcl.first().get('system:time_start'));
  
  var slide =ee.ImageCollection( 
    list.map(function(index){<!-- -->
      var date = ee.Number(index).add(1).multiply(8);
      var time = date_start.advance(date, 'day');
      var slicedarray  = imagesArray.arraySlice(0,ee.Number(index).subtract(halfSize).int(),ee.Number(index).add(halfSize+1).int());
      return slicedarray.arrayReduce(ee.Reducer.max(),[0]).arrayProject([0]).arrayGet([0][0]).rename("NDVI").set("system:time_start",time.millis());
  })
  );
  return slide;
 }
</code></pre> 
 </div> 
 <p>返回值的这段代码我本身有点疑惑</p> 
 <div class="has"> 
  <pre class="has"><code>return slicedarray.arrayReduce(ee.Reducer.max(),[0]).arrayGet([0][0]).rename("NDVI").set("system:time_start",time.millis());</code></pre> 
 </div> 
 <p>使用上面这段作为返回值时，在数据量小一点的时候可以正常运行（100景左右），在数据量比较大的时候就会报数组越界的错误。而加上arrayProject([0])之后，又可以正常运行了，不知道是为什么？</p> 
 <p>我做了几组对比实验，对比了原始数据（全年MODIS NDVI，364景）、八天最大值合成数据，还有这两组数据的sg滤波、谐波分析之后的效果。</p> 
 <p></p> 
 <div style="text-align:center;"> 
  <img src="https://images2.imgbox.com/9f/2e/WPWa7aYS_o.png" alt="0439c146e4d1e73ccd7fb92f20186224.png"> 
 </div> 
 <figcaption>
   原始NDVI时间序列 
 </figcaption> 
 <p></p> 
 <div style="text-align:center;"> 
  <img src="https://images2.imgbox.com/b9/8b/IrysSKVB_o.png" alt="5b6424dc26da386d8a4fad0ed9f3c0c8.png"> 
 </div> 
 <figcaption>
   八天滑动最大值合成NDVI时间序列 
 </figcaption> 
 <p></p> 
 <div style="text-align:center;"> 
  <img src="https://images2.imgbox.com/8f/27/H1ZWt7Pb_o.png" alt="84e7f9219b86ca5a9e6a427645a9f903.png"> 
 </div> 
 <figcaption>
   原始数据SG滤波 
 </figcaption> 
 <p></p> 
 <div style="text-align:center;"> 
  <img src="https://images2.imgbox.com/26/77/SeHREqUX_o.png" alt="3096f98f4c999aef624e3404a9bed052.png"> 
 </div> 
 <figcaption>
   合成数据SG滤波 
 </figcaption> 
 <p></p> 
 <div style="text-align:center;"> 
  <img src="https://images2.imgbox.com/37/b3/x0CaJNFN_o.png" alt="d8c79d8a8461bce0509812b272b07c42.png"> 
 </div> 
 <figcaption>
   原始数据谐波分析 
 </figcaption> 
 <p></p> 
 <div style="text-align:center;"> 
  <img src="https://images2.imgbox.com/88/7c/FvJFE2hS_o.png" alt="bd3aad3e46b50a9255f122de480d725b.png"> 
 </div> 
 <figcaption>
   合成数据谐波分析 
 </figcaption> 
 <p>可以看到，由于原始数据较多由云雨造成的低值噪声，未做合成的数据直接做滤波会拉低整体的值，而使用合成之后的时候再进行滤波会与真实情况更接近。即便做了最大值合成，也无法完全消除密集云雨的影响。使用SG滤波对数据的细节有较好的保留，而使用谐波分析则消除了大部分细节，但使数据变得更平滑。</p> 
</div>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/5d201e27256a7c6ab457a46eece459b5/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">主角有智能芯片的种田小说_5本异兽流网络小说，脑洞大开有趣味，书虫熬夜看个饱...</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/885706e7e5a13c727dfe2c99ddb878eb/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">vue 字符存在_vue中如何渲染字符串，字符串是组件类型的</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>