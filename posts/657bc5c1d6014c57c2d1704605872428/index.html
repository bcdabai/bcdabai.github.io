<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>第十四章 count(*)这么慢，我该怎么办？ - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="第十四章 count(*)这么慢，我该怎么办？" />
<meta property="og:description" content="第十四章 count(*)这么慢，我该怎么办？ count(*) 的实现方式 在不同的 MySQL 引擎中，count(*) 有不同的实现方式：
MyISAM 引擎把一个表的总行数存在了磁盘上，因此执行 count(*) 的时候会直接返回这个数，效率很高而 InnoDB 引擎就麻烦了，它执行 count(*) 的时候，需要把数据一行一行地从引擎里面读出来，然后累积计数 为什么 InnoDB 不跟 MyISAM 一样，也把数字存起来呢 ?
和 InnoDB 的事务设计有关系，可重复读是它默认的隔离级别，在代码上就是通过多版本并发控制，也就是 MVCC 来实现的。每一行记录都要判断自己是否对这个会话可见，因此对于 count(*) 请求来说，InnoDB 只好把数据一行一行地读出依次判断，可见的行才能够用于计算“基于这个查询”的表的总行数。 MySQL 在查询总数的时候会找到最小的那棵树进行遍历，这也是优化的一部分
B&#43;树只有叶子结点上有数据，全部遍历其实就是对叶子结点的链表进行遍历。此时如果遍历主键索引树，由于其叶子结点上存放的是完整的行信息，对于一个数据页而言其行密度会比较小，最终导致要扫描的数据页较多，进而IO开销也比较大。如果遍历第二索引树，其叶子结点只存放主键信息，其数据页的行密度比较大，最终扫描的数据页较少，节省了IO开销。 show table status 命令中的 TABLE_ROWS 能代替 count(*) 吗 ?
不能实际上，TABLE_ROWS 是通过采样估算得来的，因此它也很不准。官方文档说误差可能达到 40% 到 50%。所以，show table status 命令显示的行数也不能直接使用。 总结 count(*)
MyISAM 表虽然 count(*) 很快，但是不支持事务；show table status 命令虽然返回很快，但是不准确；InnoDB 表直接 count(*) 会遍历全表，虽然结果准确，但会导致性能问题 用缓存系统保存计数 将计数保存在缓存系统中的方式，还不只是丢失更新的问题。即使 Redis 正常工作，这个值还是逻辑上不精确的。
这里主要原因是因为 “MySQL插入一行数据” 跟 “Redis计数加1” 这两个操作是分开的，不是原子性的，这就很可能在中间过程因为某些并发出现问题。更抽象一点：MySQL 和 Redis 是两个不同的载体，将关联数据记录到不同的载体，而不同载体要实现原子性很难，由于不是原子性很容易引起并发问题。如果能将数据统一在同个载体即 MySQL，并由其保证操作的原子性，即将插入一行数据和计数加1作为一个完整的事务，通过事务的隔离此时外界看到的就是要么全部执行完毕，要么全部都没执行，进而保持逻辑一致。 在数据库保存计数 在数据库中建表计数，可以得到精准的计数，方法是通过数据库中的事务来实现的。计数器的修改和数据的写入都在一个事务中。读取计数器和查询最近数据也在一个事务中。 不同的 count 用法 count(*)、count(主键 id)、count(字段) 和 count(1) 等不同用法的性能差别 ?" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/657bc5c1d6014c57c2d1704605872428/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-03-17T15:50:17+08:00" />
<meta property="article:modified_time" content="2022-03-17T15:50:17+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">第十四章 count(*)这么慢，我该怎么办？</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-github-gist">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <h2><a id="_count_0"></a>第十四章 count(*)这么慢，我该怎么办？</h2> 
<h2><a id="count__2"></a>count(*) 的实现方式</h2> 
<blockquote> 
 <p>在不同的 MySQL 引擎中，<code>count(*)</code> 有不同的实现方式：</p> 
</blockquote> 
<ul><li><code>MyISAM</code> 引擎把一个表的总行数存在了磁盘上，因此执行 <code>count(*)</code> 的时候会直接返回这个数，效率很高</li><li>而 <code>InnoDB</code> 引擎就麻烦了，它执行 <code>count(*)</code> 的时候，需要把数据一行一行地从引擎里面读出来，然后累积计数</li></ul> 
<blockquote> 
 <p>为什么 <code>InnoDB</code> 不跟 <code>MyISAM</code> 一样，也把数字存起来呢 ?</p> 
</blockquote> 
<ul><li>和 InnoDB 的事务设计有关系，可重复读是它默认的隔离级别，在代码上就是通过多版本并发控制，也就是 MVCC 来实现的。</li><li>每一行记录都要判断自己是否对这个会话可见，因此对于 count(*) 请求来说，InnoDB 只好把数据一行一行地读出依次判断，可见的行才能够用于计算“基于这个查询”的表的总行数。</li></ul> 
<blockquote> 
 <p>MySQL 在查询总数的时候会找到最小的那棵树进行遍历，这也是优化的一部分</p> 
</blockquote> 
<ul><li>B+树只有叶子结点上有数据，全部遍历其实就是对叶子结点的链表进行遍历。</li><li>此时如果遍历主键索引树，由于其叶子结点上存放的是完整的行信息，对于一个数据页而言其行密度会比较小，最终导致要扫描的数据页较多，进而IO开销也比较大。</li><li>如果遍历第二索引树，其叶子结点只存放主键信息，其数据页的行密度比较大，最终扫描的数据页较少，节省了IO开销。</li></ul> 
<blockquote> 
 <p><code>show table status</code> 命令中的 <code>TABLE_ROWS</code> 能代替 <code>count(*)</code> 吗 ?</p> 
</blockquote> 
<ul><li>不能</li><li>实际上，TABLE_ROWS 是通过采样估算得来的，因此它也很不准。官方文档说误差可能达到 40% 到 50%。</li><li>所以，show table status 命令显示的行数也不能直接使用。</li></ul> 
<blockquote> 
 <p>总结 count(*)</p> 
</blockquote> 
<ul><li>MyISAM 表虽然 count(*) <em>很快，但是不支持事务；</em></li><li><em><code>show table status</code> 命令虽然返回很快，但是不准确；</em></li><li><em>InnoDB 表直接</em> count(*) 会遍历全表，虽然结果准确，但会导致性能问题</li></ul> 
<h2><a id="_32"></a>用缓存系统保存计数</h2> 
<blockquote> 
 <p>将计数保存在缓存系统中的方式，还不只是丢失更新的问题。即使 Redis 正常工作，这个值还是逻辑上不精确的。</p> 
</blockquote> 
<ul><li>这里主要原因是因为 “MySQL插入一行数据” 跟 “Redis计数加1” 这两个操作是分开的，不是原子性的，这就很可能在中间过程因为某些并发出现问题。</li><li>更抽象一点：MySQL 和 Redis 是两个不同的载体，将关联数据记录到不同的载体，而不同载体要实现原子性很难，由于不是原子性很容易引起并发问题。</li><li>如果能将数据统一在同个载体即 MySQL，并由其保证操作的原子性，即将<code>插入一行数据</code>和<code>计数加1</code>作为一个<code>完整的事务</code>，通过事务的隔离此时外界看到的就是要么全部执行完毕，要么全部都没执行，进而保持逻辑一致。</li></ul> 
<h2><a id="_40"></a>在数据库保存计数</h2> 
<ul><li>在数据库中建表计数，可以得到精准的计数，方法是通过数据库中的事务来实现的。</li><li>计数器的修改和数据的写入都在一个事务中。</li><li>读取计数器和查询最近数据也在一个事务中。</li></ul> 
<h2><a id="_count__46"></a>不同的 count 用法</h2> 
<blockquote> 
 <p><code>count(*)</code>、<code>count(主键 id)</code>、<code>count(字段)</code> 和 <code>count(1)</code> 等不同用法的性能差别 ?</p> 
</blockquote> 
<ul><li><code>count(主键 id)</code>：InnoDB 引擎会遍历整张表，把每一行的 id 值都取出来，返回给 server 层。server 层拿到 id 后，判断是不为空的，就按行累加</li><li><code>count(1)</code>：InnoDB 引擎遍历整张表，但不取值。server 层对于返回的每一行，放一个数字“1”进去，判断是不为空的，按行累加</li><li><code>count(字段)</code>： 
  <ul><li>如果这个 “字段” 是定义为 not null 的话，一行行地从记录里面读出这个字段，判断不能为 null，按行累加</li><li>如果这个 “字段” 定义允许为 null，那么执行的时候，判断到有可能是 null，还要把值取出来再判断一下，不是 null 才累加</li></ul> </li><li><code>count(*)</code>：并不会把全部字段取出来，而是专门做了优化，不取值。count(*) 肯定不是 null，按行累加</li><li>按照效率排序的话：<code>count(字段) &lt; count(主键 id) &lt; count(1) ≈ count(*)</code></li><li>所以，尽量使用 <code>count(*)</code></li></ul>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/9d507e90bd83ca9d18945d6591267e56/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">Linux-MySQL主从复制</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/50ebc83593330200e2d58829cd7f66b2/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">同网段的VLAN隔离</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>