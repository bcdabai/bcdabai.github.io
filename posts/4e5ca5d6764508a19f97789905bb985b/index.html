<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Python开发之日志记录模块：logging - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Python开发之日志记录模块：logging" />
<meta property="og:description" content="1 引言 最近在开发一个应用软件，为方便调试和后期维护，在代码中添加了日志，用的是Python内置的logging模块，看了许多博主的博文，颇有所得。不得不说，有许多博主大牛总结得确实很好。似乎我再写关于logging的博文有些多余，但不写总结又总觉得没掌握。那就写写吧，也方便日后回顾。 开始总结之前，先感谢几位博主，他们的博客写得很是详尽： 云游道士的博文： https://www.cnblogs.com/yyds/p/6901864.html Nicholas的博文： https://www.cnblogs.com/Nicholas0707/p/9021672.html 说说为什么需要添加日志？ 就像上面说的，为了调试和后期维护方便。也许在开发中没有太大体会，但是如果将软件部署到了生产环境中，一旦出现bug，没有日志，就很难对当时的情况进行追踪，有了日志，就可以根据日志尽可能的对当时的数据环境进行还原，方便debug。甚至，只要日志设计得足够合理，还可以用于后续业务数据分析等。 2 日志等级 为什么需要对日志进行划分等级呢？ 当我们出于开发时debug的目的使用日志时，我们自然是想尽可能详尽得记录日志，但是如果部署到生产环境中，这样做就可能因为大量的IO占用服务器资源，所以在生产环境中就只需要记录异常信息、错误情况等就好了。 所以，给日志设置等级，可以方便得、因地制宜控制日志输出。 这里只介绍Python的logging模块的日志等级(当然，其他日志系统的日志等级划分事实上也基本相同)。logging的日志等级包括5个： 日志等级(level) 描述 DEBUG 最详细的日志信息，典型应用场景是 问题诊断 INFO 信息详细程度仅次于DEBUG，通常只记录关键节点信息，用于确认一切都是按照我们预期的那样进行工作 WARNING 当某些不期望的事情发生时记录的信息(如，磁盘可用空间较低)，但是此时应用程序还是正常运行的 ERROR 由于一个更严重的问题导致某些功能不能正常运行时记录的信息 CRITICAL 当发生严重错误，导致应用程序不能继续运行时记录的信息 日志等级从上到下依次提高，当在程序中设定某个日志等级之后，比设定的日志等级低的日志记录将会被忽略，即logging就只会输出大于和等于设定的等级的日志。我们将在下文中通过代码示例证明这一点。 3 记录日志 logging模块提供两种方法记录日志： (1)通过logging模块提供的模块级函数记录日志； (2)通过logging模块提供的4大组件记录日志。 3.1 记录日志之logging模块级函数 在logging模块中，分别给出一个模块级别函数与上面说到的日志级别相对应，用于输出对应级别日志记录： 函数 说明 logging.debug(msg, *args, **kwargs) 创建一条严重级别为DEBUG的日志记录 logging.info(msg, *args, **kwargs) 创建一条严重级别为INFO的日志记录 logging.warning(msg, *args, **kwargs) 创建一条严重级别为WARNING的日志记录 logging.error(msg, *args, **kwargs) 创建一条严重级别为ERROR的日志记录 logging.critical(msg, *args, **kwargs) 创建一条严重级别为CRITICAL的日志记录 也有一个函数汇总了上面5个函数的功能： 函数 说明 logging.log(level, *args, **kwargs) 创建一条严重级别为level的日志记录 现在可以来尝试使用一下上面的函数了： import logging logging." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/4e5ca5d6764508a19f97789905bb985b/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2019-03-31T22:32:00+08:00" />
<meta property="article:modified_time" content="2019-03-31T22:32:00+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Python开发之日志记录模块：logging</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <div id="cnblogs_post_body" class="blogpost-body" style="font-size: 16px;"> 
 <h2>1 引言</h2> 
 <div>
   最近在开发一个应用软件，为方便调试和后期维护，在代码中添加了日志，用的是Python内置的logging模块，看了许多博主的博文，颇有所得。不得不说，有许多博主大牛总结得确实很好。似乎我再写关于logging的博文有些多余，但不写总结又总觉得没掌握。那就写写吧，也方便日后回顾。 
 </div> 
 <div>
   开始总结之前，先感谢几位博主，他们的博客写得很是详尽： 
 </div> 
 <div>
   云游道士的博文： 
  <a href="https://www.cnblogs.com/yyds/p/6901864.html" rel="nofollow">https://www.cnblogs.com/yyds/p/6901864.html</a> 
 </div> 
 <div> 
  <a href="https://www.cnblogs.com/Nicholas0707/" rel="nofollow">Nicholas</a>的博文： 
  <a href="https://www.cnblogs.com/Nicholas0707/p/9021672.html" rel="nofollow">https://www.cnblogs.com/Nicholas0707/p/9021672.html</a> 
 </div> 
 <div> 
  说说为什么需要添加日志？ 
 </div> 
 <div> 
  就像上面说的，为了调试和后期维护方便。也许在开发中没有太大体会，但是如果将软件部署到了生产环境中，一旦出现bug，没有日志，就很难对当时的情况进行追踪，有了日志，就可以根据日志尽可能的对当时的数据环境进行还原，方便debug。甚至，只要日志设计得足够合理，还可以用于后续业务数据分析等。 
 </div> 
 <h2><span style="font-weight: bold;">2 日志等级</span></h2> 
 <div> 
  为什么需要对日志进行划分等级呢？ 
 </div> 
 <div>
   当我们出于开发时debug的目的使用日志时，我们自然是想尽可能详尽得记录日志，但是如果部署到生产环境中，这样做就可能因为大量的IO占用服务器资源，所以在生产环境中就只需要记录异常信息、错误情况等就好了。 
 </div> 
 <div>
   所以，给日志设置等级，可以方便得、因地制宜控制日志输出。 
 </div> 
 <div> 
  这里只介绍Python的logging模块的日志等级(当然，其他日志系统的日志等级划分事实上也基本相同)。logging的日志等级包括5个： 
 </div> 
 <div> 
  <table><colgroup><col><col></colgroup><tbody><tr><td> 
      <div class="table-cell-line"> 
       日志等级(level) 
      </div> </td><td> 
      <div class="table-cell-line"> 
       描述 
      </div> </td></tr><tr><td> 
      <div class="table-cell-line"> 
       DEBUG 
      </div> </td><td> 
      <div class="table-cell-line"> 
       最详细的日志信息，典型应用场景是 问题诊断 
      </div> </td></tr><tr><td> 
      <div class="table-cell-line"> 
       INFO 
      </div> </td><td> 
      <div class="table-cell-line"> 
       信息详细程度仅次于DEBUG，通常只记录关键节点信息，用于确认一切都是按照我们预期的那样进行工作 
      </div> </td></tr><tr><td> 
      <div class="table-cell-line"> 
       WARNING 
      </div> </td><td> 
      <div class="table-cell-line"> 
       当某些不期望的事情发生时记录的信息(如，磁盘可用空间较低)，但是此时应用程序还是正常运行的 
      </div> </td></tr><tr><td> 
      <div class="table-cell-line"> 
       ERROR 
      </div> </td><td> 
      <div class="table-cell-line"> 
       由于一个更严重的问题导致某些功能不能正常运行时记录的信息 
      </div> </td></tr><tr><td> 
      <div class="table-cell-line"> 
       CRITICAL 
      </div> </td><td> 
      <div class="table-cell-line"> 
       当发生严重错误，导致应用程序不能继续运行时记录的信息 
      </div> </td></tr></tbody></table> 
 </div> 
 <div>
   日志等级从上到下依次提高，当在程序中设定某个日志等级之后，比设定的日志等级低的日志记录将会被忽略，即logging就只会输出大于和等于设定的等级的日志。我们将在下文中通过代码示例证明这一点。 
 </div> 
 <h2>3 记录日志</h2> 
 <div>
   logging模块提供两种方法记录日志： 
 </div> 
 <div>
   (1)通过logging模块提供的模块级函数记录日志； 
 </div> 
 <div>
   (2)通过logging模块提供的4大组件记录日志。 
 </div> 
 <h3>3.1 记录日志之logging模块级函数</h3> 
 <div>
   在logging模块中，分别给出一个模块级别函数与上面说到的日志级别相对应，用于输出对应级别日志记录： 
 </div> 
 <div> 
  <table><colgroup><col><col></colgroup><tbody><tr><td> 
      <div class="table-cell-line"> 
       函数 
      </div> </td><td> 
      <div class="table-cell-line"> 
       说明 
      </div> </td></tr><tr><td> 
      <div class="table-cell-line"> 
       logging.debug(msg, *args, **kwargs) 
      </div> </td><td> 
      <div class="table-cell-line"> 
       创建一条严重级别为DEBUG的日志记录 
      </div> </td></tr><tr><td> 
      <div class="table-cell-line"> 
       logging.info(msg, *args, **kwargs) 
      </div> </td><td> 
      <div class="table-cell-line"> 
       创建一条严重级别为INFO的日志记录 
      </div> </td></tr><tr><td> 
      <div class="table-cell-line"> 
       logging.warning(msg, *args, **kwargs) 
      </div> </td><td> 
      <div class="table-cell-line"> 
       创建一条严重级别为WARNING的日志记录 
      </div> </td></tr><tr><td> 
      <div class="table-cell-line"> 
       logging.error(msg, *args, **kwargs) 
      </div> </td><td> 
      <div class="table-cell-line"> 
       创建一条严重级别为ERROR的日志记录 
      </div> </td></tr><tr><td> 
      <div class="table-cell-line"> 
       logging.critical(msg, *args, **kwargs) 
      </div> </td><td> 
      <div class="table-cell-line"> 
       创建一条严重级别为CRITICAL的日志记录 
      </div> </td></tr></tbody></table> 
 </div> 
 <div>
   也有一个函数汇总了上面5个函数的功能： 
 </div> 
 <div> 
  <table><colgroup><col><col></colgroup><tbody><tr><td> 
      <div class="table-cell-line"> 
       函数 
      </div> </td><td> 
      <div class="table-cell-line"> 
       说明 
      </div> </td></tr><tr><td> 
      <div class="table-cell-line"> 
       logging.log(level, *args, **kwargs) 
      </div> </td><td> 
      <div class="table-cell-line"> 
       创建一条严重级别为level的日志记录 
      </div> </td></tr></tbody></table> 
 </div> 
 <div>
   现在可以来尝试使用一下上面的函数了： 
 </div> 
 <div class="cnblogs_code"> 
  <pre><code class="has">import logging
 
logging.debug('debug')
logging.info('info')
logging.warn('warn')
logging.error('error')
logging.critical('critical')
logging.warn('Today is %s',datetime.date.today())</code>
</pre> 
 </div> 
 <div>
   运行结果如下： 
 </div> 
 <div> 
  <em>WARNING:root:warn</em> 
 </div> 
 <div> 
  <em>ERROR:root:error</em> 
 </div> 
 <div> 
  <em>CRITICAL:root:critical</em> 
 </div> 
 <div> 
  <em>WARNING:root:Today is 2019-03-28</em> 
 </div> 
 <div>
    上面的函数都有 
  *args, **kwargs这两个参数，所以这些函数可以接受任意位置参数和关键字参数，这些参数填充到第一个参数msg，最后一条日志输出中添加了当前日期就是利用了这个功能。 
 </div> 
 <div>
   那为什么会只输出后面3条日志记录呢？上面说到过，logging就只会输出大于和等于设定的等级的日志记录，而logging的默认日志等级是WARNING，所以日志等级为DEBUG和INFO的两条记录都没有被输出。 
 </div> 
 <div>
   如果想要输入日志等级为DEBUG和INFO的日志记录，就要对logging进行配置。logging也提供了一个模块级别的专用于配置logging的函数： 
 </div> 
 <div> 
  <table><colgroup><col><col></colgroup><tbody><tr><td> 
      <div class="table-cell-line"> 
       函数 
      </div> </td><td> 
      <div class="table-cell-line"> 
       说明 
      </div> </td></tr><tr><td> 
      <div class="table-cell-line"> 
       logging.basicConfig(**kwargs) 
      </div> </td><td> 
      <div class="table-cell-line"> 
       对root logger进行一次性配置 
      </div> </td></tr></tbody></table> 
 </div> 
 <div>
   尝试使用一下这个配置函数： 
 </div> 
 <div class="cnblogs_code"> 
  <pre><code class="has">import logging
logging.basicConfig(level=logging.DEBUG) # 设置日志等级
logging.debug('debug')
logging.info('info')
logging.warn('warn')
logging.error('error')
logging.critical('critical')</code>
</pre> 
 </div> 
 <div>
   运行结果如下： 
 </div> 
 <div> 
  <em>DEBUG:root:debug</em> 
 </div> 
 <div> 
  <em>INFO:root:info</em> 
 </div> 
 <div> 
  <em>WARNING:root:warn</em> 
 </div> 
 <div> 
  <em>ERROR:root:error</em> 
 </div> 
 <div> 
  <em>CRITICAL:root:critical</em> 
 </div> 
 <div>
   看，日志等级为DEBUG和INFO的两条记录也都得到了输出。 
 </div> 
 <div>
   上面表格对 
  logging.basicConfig函数的说明中指出，logging.basicConfig函数时一次性配置，什么意思呢？意思就是说，<strong>logging.basicConfig函数只在第一次运行(第一次对logging进行配置)时起作用，后面在此设置其他参数是不会生效的</strong>。通过代码证明一下： 
 </div> 
 <div class="cnblogs_code"> 
  <pre><code class="has">import logging
logging.basicConfig(level=logging.DEBUG) # 设置日志等级
logging.basicConfig(level=logging.INFO) # 重新设置日志等级
logging.debug('debug')
logging.info('info')
logging.warn('warn')
logging.error('error')
logging.critical('critical')</code>
</pre> 
 </div> 
 <div>
   运行结果： 
 </div> 
 <div> 
  <em>DEBUG:root:debug</em> 
 </div> 
 <div> 
  <em>INFO:root:info</em> 
 </div> 
 <div> 
  <em>WARNING:root:warn</em> 
 </div> 
 <div> 
  <em>ERROR:root:error</em> 
 </div> 
 <div> 
  <em>CRITICAL:root:critical</em> 
 </div> 
 <div>
   看到没，DEBUG级别日志记录还是输出了，证明重新运行 
  logging.basicConfig函数设置日志级别没有生效。 
 </div> 
 <div>
   另外需要注意的是， 
  <strong>一定要在使用logging记录日志之前使用logging.basicConfig进行配置，否则，不会有任何输出。</strong> 
 </div> 
 <div>
   我们再观察一下上面的程序输出，可以发现，每一条输出的结果里，不仅仅只有我们输出的字符串参数，还有其它的一些信息，例如日志等级，日志器名称(默认是root)，分隔符(这里是冒号)等，这些都是logging默认给我配置好的，当然，我们也可以通过 
  logging.basicConfig函数的各参数自定义logging的输出。 
 </div> 
 <div> 
  <table><colgroup><col><col></colgroup><tbody><tr><td> 
      <div class="table-cell-line"> 
       参数名称 
      </div> </td><td> 
      <div class="table-cell-line"> 
       描述 
      </div> </td></tr><tr><td> 
      <div class="table-cell-line"> 
       filename 
      </div> </td><td> 
      <div class="table-cell-line"> 
       指定日志输出目标文件的文件名，指定该设置项后日志信心就不会被输出到控制台了 
      </div> </td></tr><tr><td> 
      <div class="table-cell-line"> 
       filemode 
      </div> </td><td> 
      <div class="table-cell-line"> 
       指定日志文件的打开模式，默认为'a'。需要注意的是，该选项要在filename指定时才有效 
      </div> </td></tr><tr><td> 
      <div class="table-cell-line"> 
       format 
      </div> </td><td> 
      <div class="table-cell-line"> 
       指定日志格式字符串，即指定日志输出时所包含的字段信息以及它们的顺序。logging模块定义的格式字段下面会列出。 
      </div> </td></tr><tr><td> 
      <div class="table-cell-line"> 
       datefmt 
      </div> </td><td> 
      <div class="table-cell-line"> 
       指定日期/时间格式。需要注意的是，该选项要在format中包含时间字段%(asctime)s时才有效 
      </div> </td></tr><tr><td> 
      <div class="table-cell-line"> 
       level 
      </div> </td><td> 
      <div class="table-cell-line"> 
       指定日志器的日志级别 
      </div> </td></tr><tr><td> 
      <div class="table-cell-line"> 
       stream 
      </div> </td><td> 
      <div class="table-cell-line"> 
       指定日志输出目标stream，如sys.stdout、sys.stderr以及网络stream。需要说明的是，stream和filename不能同时提供，否则会引发 ValueError异常 
      </div> </td></tr><tr><td> 
      <div class="table-cell-line"> 
       style 
      </div> </td><td> 
      <div class="table-cell-line"> 
       Python 3.2中新添加的配置项。指定format格式字符串的风格，可取值为'%'、'{'和'$'，默认为'%' 
      </div> </td></tr><tr><td> 
      <div class="table-cell-line"> 
       handlers 
      </div> </td><td> 
      <div class="table-cell-line"> 
       Python 3.3中新添加的配置项。该选项如果被指定，它应该是一个创建了多个Handler的可迭代对象，这些handler将会被添加到root logger。需要说明的是：filename、stream和handlers这三个配置项只能有一个存在，不能同时出现2个或3个，否则会引发ValueError异常。 
      </div> </td></tr></tbody></table> 
 </div> 
 <div>
   上表中的参数format可以通过logging模块中定义好模式来设定值： 
 </div> 
 <div> 
  <table><colgroup><col><col><col></colgroup><tbody><tr><td> 
      <div class="table-cell-line"> 
       字段/属性名称 
      </div> </td><td> 
      <div class="table-cell-line"> 
       使用格式 
      </div> </td><td> 
      <div class="table-cell-line"> 
       描述 
      </div> </td></tr><tr><td> 
      <div class="table-cell-line"> 
       asctime 
      </div> </td><td> 
      <div class="table-cell-line"> 
       %(asctime)s 
      </div> </td><td> 
      <div class="table-cell-line"> 
       将日志的时间构造成可读的形式，默认情况下是‘2019-03-28 00:00:00,000’的形式，精确到毫秒 
      </div> </td></tr><tr><td> 
      <div class="table-cell-line"> 
       name 
      </div> </td><td> 
      <div class="table-cell-line"> 
       %(name)s 
      </div> </td><td> 
      <div class="table-cell-line"> 
       所使用的日志器名称，默认是'root'，因为默认使用的是 rootLogger 
      </div> </td></tr><tr><td> 
      <div class="table-cell-line"> 
       filename 
      </div> </td><td> 
      <div class="table-cell-line"> 
       %(filename)s 
      </div> </td><td> 
      <div class="table-cell-line"> 
       调用日志输出函数的模块的文件名； pathname的文件名部分，包含文件后缀 
      </div> </td></tr><tr><td> 
      <div class="table-cell-line"> 
       funcName 
      </div> </td><td> 
      <div class="table-cell-line"> 
       %(funcName)s 
      </div> </td><td> 
      <div class="table-cell-line"> 
       由哪个function发出的log， 调用日志输出函数的函数名 
      </div> </td></tr><tr><td> 
      <div class="table-cell-line"> 
       levelname 
      </div> </td><td> 
      <div class="table-cell-line"> 
       %(levelname)s 
      </div> </td><td> 
      <div class="table-cell-line"> 
       日志的最终等级(被filter修改后的) 
      </div> </td></tr><tr><td> 
      <div class="table-cell-line"> 
       message 
      </div> </td><td> 
      <div class="table-cell-line"> 
       %(message)s 
      </div> </td><td> 
      <div class="table-cell-line"> 
       日志信息， 日志记录的文本内容 
      </div> </td></tr><tr><td> 
      <div class="table-cell-line"> 
       lineno 
      </div> </td><td> 
      <div class="table-cell-line"> 
       %(lineno)d 
      </div> </td><td> 
      <div class="table-cell-line"> 
       当前日志的行号， 调用日志输出函数的语句所在的代码行 
      </div> </td></tr><tr><td> 
      <div class="table-cell-line"> 
       levelno 
      </div> </td><td> 
      <div class="table-cell-line"> 
       %(levelno)s 
      </div> </td><td> 
      <div class="table-cell-line"> 
       该日志记录的数字形式的日志级别(10, 20, 30, 40, 50) 
      </div> </td></tr><tr><td> 
      <div class="table-cell-line"> 
       pathname 
      </div> </td><td> 
      <div class="table-cell-line"> 
       %(pathname)s 
      </div> </td><td> 
      <div class="table-cell-line"> 
       完整路径 ，调用日志输出函数的模块的完整路径名，可能没有 
      </div> </td></tr><tr><td> 
      <div class="table-cell-line"> 
       process 
      </div> </td><td> 
      <div class="table-cell-line"> 
       %(process)s 
      </div> </td><td> 
      <div class="table-cell-line"> 
       当前进程， 进程ID。可能没有 
      </div> </td></tr><tr><td> 
      <div class="table-cell-line"> 
       processName 
      </div> </td><td> 
      <div class="table-cell-line"> 
       %(processName)s 
      </div> </td><td> 
      <div class="table-cell-line"> 
       进程名称，Python 3.1新增 
      </div> </td></tr><tr><td> 
      <div class="table-cell-line"> 
       thread 
      </div> </td><td> 
      <div class="table-cell-line"> 
       %(thread)s 
      </div> </td><td> 
      <div class="table-cell-line"> 
       当前线程， 线程ID。可能没有 
      </div> </td></tr><tr><td> 
      <div class="table-cell-line"> 
       threadName 
      </div> </td><td> 
      <div class="table-cell-line"> 
       %(thread)s 
      </div> </td><td> 
      <div class="table-cell-line"> 
       线程名称 
      </div> </td></tr><tr><td> 
      <div class="table-cell-line"> 
       module 
      </div> </td><td> 
      <div class="table-cell-line"> 
       %(module)s 
      </div> </td><td> 
      <div class="table-cell-line"> 
       调用日志输出函数的模块名， filename的名称部分，不包含后缀即不包含文件后缀的文件名 
      </div> </td></tr><tr><td> 
      <div class="table-cell-line"> 
       created 
      </div> </td><td> 
      <div class="table-cell-line"> 
       %(created)f 
      </div> </td><td> 
      <div class="table-cell-line"> 
       当前时间，用UNIX标准的表示时间的浮点数表示； 日志事件发生的时间--时间戳，就是当时调用time.time()函数返回的值 
      </div> </td></tr><tr><td> 
      <div class="table-cell-line"> 
       relativeCreated 
      </div> </td><td> 
      <div class="table-cell-line"> 
       %(relativeCreated)d 
      </div> </td><td> 
      <div class="table-cell-line"> 
       输出日志信息时的，自Logger创建以 来的毫秒数； 日志事件发生的时间相对于logging模块加载时间的相对毫秒数 
      </div> </td></tr><tr><td> 
      <div class="table-cell-line"> 
       msecs 
      </div> </td><td> 
      <div class="table-cell-line"> 
       %(msecs)d 
      </div> </td><td> 
      <div class="table-cell-line"> 
       日志事件发生事件的毫秒部分。logging.basicConfig()中用了参数datefmt，将会去掉asctime中产生的毫秒部分，可以用这个加上 
      </div> </td></tr></tbody></table> 
 </div> 
 <div>
   所以，结合上表中的内容，我们可以实现让每一条日志记录输出事件发生时间、事件发生位置、日志级别、事件内容等信息。 
 </div> 
 <div>
   现在，我们来给刚才的日志添加一些输出，例如每条日志输出日志时间、日志级别、所在模块名、函数名、行号等信息，并指定时间输出格式，最后把日志输出到当前目录下的.log文件中。代码如下： 
 </div> 
 <div class="cnblogs_code"> 
  <pre><code class="has">import logging
fmt = '%(asctime)s , %(levelname)s , %(filename)s %(funcName)s line %(lineno)s , %(message)s'
datefmt = '%Y-%m-%d %H:%M:%S %a'
logging.basicConfig(level=logging.DEBUG,
format=fmt,
datefmt=datefmt,
filename=".log")
logging.debug('debug')
logging.info('info')
logging.warn('warn')
logging.error('error')
logging.critical('critical')</code>
</pre> 
 </div> 
 <div>
   运行上述代码后，控制台不会再有输出了，但当前目录下的.log文件会写入一下内容： 
 </div> 
 <div> 
  <em>2019-03-28 16:34:08 Thu , DEBUG , log_test.py &lt;module&gt; line 8 , debug</em> 
 </div> 
 <div> 
  <em>2019-03-28 16:34:08 Thu , INFO , log_test.py &lt;module&gt; line 9 , info</em> 
 </div> 
 <div> 
  <em>2019-03-28 16:34:08 Thu , WARNING , log_test.py &lt;module&gt; line 10 , warn</em> 
 </div> 
 <div> 
  <em>2019-03-28 16:34:08 Thu , ERROR , log_test.py &lt;module&gt; line 11 , error</em> 
 </div> 
 <div> 
  <em>2019-03-28 16:34:08 Thu , CRITICAL , log_test.py &lt;module&gt; line 12 , critical</em> 
 </div> 
 <h3>3.2 记录日志之logging四大组件</h3> 
 <div>
   logging四大组件是logging日志记录的高级用法。四大组件包括Logger、Handelr、Filter、Formater，且都是以类的形式来使用。logging四大组件协同工作流如下如所示： 
 </div> 
 <div style="text-align: center;"> 
  <img src="https://images2.imgbox.com/d5/2a/LkmMWuPd_o.png" alt="" style="outline: none;"> 
 </div> 
 <div>
   各组件功能如下： 
 </div> 
 <div> 
  <table><colgroup><col><col><col></colgroup><tbody><tr><td> 
      <div class="table-cell-line"> 
       组件名称 
      </div> </td><td> 
      <div class="table-cell-line"> 
       对应类名 
      </div> </td><td> 
      <div class="table-cell-line"> 
       功能描述 
      </div> </td></tr><tr><td> 
      <div class="table-cell-line"> 
       日志器 
      </div> </td><td> 
      <div class="table-cell-line"> 
       Logger 
      </div> </td><td> 
      <div class="table-cell-line"> 
       用于提供日志接口，常用于配置和发送日志消息 
      </div> </td></tr><tr><td> 
      <div class="table-cell-line"> 
       处理器 
      </div> </td><td> 
      <div class="table-cell-line"> 
       Handler 
      </div> </td><td> 
      <div class="table-cell-line"> 
       用于写入日志并输出到指定位置，例如控制台、文件或网络位置等 
      </div> </td></tr><tr><td> 
      <div class="table-cell-line"> 
       过滤器 
      </div> </td><td> 
      <div class="table-cell-line"> 
       Filter 
      </div> </td><td> 
      <div class="table-cell-line"> 
       对日志记录进行进一步过滤，输出符合条件的日志记录 
      </div> </td></tr><tr><td> 
      <div class="table-cell-line"> 
       格式器 
      </div> </td><td> 
      <div class="table-cell-line"> 
       Formatter 
      </div> </td><td> 
      <div class="table-cell-line"> 
       配置日志记录的最终输出格式 
      </div> </td></tr></tbody></table> 
 </div> 
 <div> 
  <strong>(1)日志器：Logger</strong> 
 </div> 
 <div>
   日志器Logger以工厂化的形式返回一个Logger类实例。一般而言，大多使用下面的方法获得Logger类实例： 
 </div> 
 <div>
   logging.getLogger(name) 
 </div> 
 <div> 
  <strong>属性name是为Logger实例指定的名称，如果使用同一个名称进行实例化，则实际上只是将后面实例对象名指向前面的同名Logger实例。在使用logging模块时，系统会自动实例化一个名为root的日志器(根日志器)，当未指定name属性时，事实上就是将变量名指向跟日志器</strong> 
 </div> 
 <div>
   另外， 
  <strong>Logger实例具有层级继承的特点，层级之间已“.”连接，例如：“a.b”，“a.b.c”，a是父日志器，b是子日志器，在未对子日志器进行配置情况下，子日志器默认继承父日志器的配置，对子日志器重新配置不会影响父日志器</strong>。这一点很重要，在多模块中记录日子是可以使用这一特性，我们在下文代码中实践这一特性。根日志器是所有日志器的默认父日志器。 
 </div> 
 <div>
   Logger类还有以下的常用方法： 
 </div> 
 <div> 
  <ul><li><strong>logger.setLevel() :设置日志器处理日志信息的最低级别</strong></li><li><strong>logger.addHandler()：为该logger对象添加一个handler对象</strong></li><li><strong>logger.removeHandler()：为该logger对象添加移除一个handler对象</strong></li><li><strong>logger.addFilter()：为该logger对象添加一个filter对象</strong></li><li><strong>logger.removeFilter()：为该logger对象移除一个filter对象</strong></li><li><strong>logger.debug(),logger.info(),logger.warning(),logger.error(),logger.critical()：创建一个对应等级的日志记录</strong></li></ul> 
 </div> 
 <div> 
  <strong>(2)处理器：Handler</strong> 
 </div> 
 <div>
   Handler实例用于将日志记录发送到指定的位置进行输出。一个logger对象可以添加多个handler(例如既要在控制台输出日志，又要将日志写入到文件A，还要讲日志写入文件B，这就可以配置3个handler)，每个handler又可以定义不同日志级别，以实现日志分级过滤显示。常用的方法包括： 
 </div> 
 <div> 
  <ul><li><strong>handler.setLevel()：设置handler处理的日志信息最低级别</strong></li><li><strong>handler.setFormatter()：为handler设置一个格式器对象</strong></li><li><strong>handler.addFilter()：为handler添加一个过滤器对象</strong></li><li><strong>handler.removeFilter()：为handler删除一个过滤器对象</strong></li></ul> 
 </div> 
 <div>
   要注意的是，在实际开发中，最好不要直接使用Handler类，应根据实际的功能需要，实例化Handler类的子类。Handler类的之类包括： 
 </div> 
 <div> 
  <table><colgroup><col><col></colgroup><tbody><tr><td> 
      <div class="table-cell-line"> 
       Handler 
      </div> </td><td> 
      <div class="table-cell-line"> 
       描述 
      </div> </td></tr><tr><td> 
      <div class="table-cell-line"> 
       logging.StreamHandler 
      </div> </td><td> 
      <div class="table-cell-line"> 
       将日志消息发送到输出到Stream，如std.out, std.err或任何file-like对象。 
      </div> </td></tr><tr><td> 
      <div class="table-cell-line"> 
       logging.FileHandler 
      </div> </td><td> 
      <div class="table-cell-line"> 
       将日志消息发送到磁盘文件，默认情况下文件大小会无限增长 
      </div> </td></tr><tr><td> 
      <div class="table-cell-line"> 
       logging.handlers.RotatingFileHandler 
      </div> </td><td> 
      <div class="table-cell-line"> 
       将日志消息发送到磁盘文件，并支持日志文件按大小切割 
      </div> </td></tr><tr><td> 
      <div class="table-cell-line"> 
       logging.hanlders.TimedRotatingFileHandler 
      </div> </td><td> 
      <div class="table-cell-line"> 
       将日志消息发送到磁盘文件，并支持日志文件按时间切割 
      </div> </td></tr><tr><td> 
      <div class="table-cell-line"> 
       logging.handlers.HTTPHandler 
      </div> </td><td> 
      <div class="table-cell-line"> 
       将日志消息以GET或POST的方式发送给一个HTTP服务器 
      </div> </td></tr><tr><td> 
      <div class="table-cell-line"> 
       logging.handlers.SMTPHandler 
      </div> </td><td> 
      <div class="table-cell-line"> 
       将日志消息发送给一个指定的email地址 
      </div> </td></tr><tr><td> 
      <div class="table-cell-line"> 
       logging.NullHandler 
      </div> </td><td> 
      <div class="table-cell-line"> 
       该Handler实例会忽略error messages，通常被想使用logging的library开发者使用来避免'No handlers could be found for logger XXX'信息的出现。 
      </div> </td></tr></tbody></table> 
 </div> 
 <div>
   通过代码来演示一下，功能如下:在控制台输出日志(日志级别为debug)，同时将日志写入到文件a.log文件(日志级别为debug)，还要讲日志写入文件b.log文件(日志级别为warn)： 
 </div> 
 <div class="cnblogs_code"> 
  <pre><code class="has">import logging
 
logger = logging.getLogger()
logger.setLevel(logging.DEBUG)
 
# 控制台输出
con_handler = logging.StreamHandler()
con_handler.setLevel(logging.INFO)
logger.addHandler(con_handler)
 
# 输出到文件a.log
file_a_handler = logging.FileHandler('./a.log', encoding='UTF-8')
file_a_handler.setLevel(logging.DEBUG)
logger.addHandler(file_a_handler)
 
# 输出到文件b.log
file_b_handler = logging.FileHandler('./b.log', encoding='UTF-8')
file_b_handler.setLevel(logging.WARNING)
logger.addHandler(file_b_handler)
 
if __name__=='__main__':
logger.debug('debug msg')
logger.info('info msg')
logger.warning('warn msg')</code>
</pre> 
 </div> 
 <div>
   运行上面代码后，控制台输出如下： 
 </div> 
 <div> 
  info msg 
 </div> 
 <div> 
  warn msg 
 </div> 
 <div>
   文件a.log会写入一下内容： 
 </div> 
 <div> 
  <em>debug msg</em> 
 </div> 
 <div> 
  <em>info msg</em> 
 </div> 
 <div> 
  <em>warn msg</em> 
 </div> 
 <div>
   文件b.log会写入以下内容： 
 </div> 
 <div> 
  <em>warn msg</em> 
 </div> 
 <div>
   注意：在一个日志器中添加多个handler时要注意，最好通过logger.setLevel(logging.DEBUG)先设置一下logger本身的日志级别，如果某个handler的级别比logger的日志级别低，那么该handler的日志级别无效，handler会以logger的级别来处理。 
 </div> 
 <div> 
  <strong>(3)格式器：Formatter</strong> 
 </div> 
 <div>
   Formatter类实例用于配置日志记录的内容、结构等信息。可以通过以下三个参数进行配置： 
 </div> 
 <div> 
  <ul><li><strong>fmt：指定消息格式化字符串，如果不指定该参数则默认使用message的原始值</strong></li><li><strong>datefmt：指定日期格式字符串，如果不指定该参数则默认使用"%Y-%m-%d %H:%M:%S"</strong></li><li><strong>style：指定格式化占位符，可取值为 '%', '{'和 '$'，如果不指定该参数则默认使用'%'</strong></li></ul> 
 </div> 
 <div>
   fmt的使用方法可以参照上文中介绍过的 
  logging.basicConfig函数format参数的配制方法。 
 </div> 
 <div>
   例：每条日志输出日志时间、日制定及、所在模块名、函数名、行号等信息，并指定时间输出格式，最后把日志输出到控制台。代码如下： 
 </div> 
 <div class="cnblogs_code"> 
  <pre><code class="has">import logging
 
logger = logging.getLogger(__name__)
handler = logging.StreamHandler()
logger.setLevel(logging.DEBUG)
# 定义格式器,添加到处理器中
fmt = '%(asctime)s , %(levelname)s , %(filename)s %(funcName)s line %(lineno)s , %(message)s'
datefmt = '%Y-%m-%d %H:%M:%S %a'
log_fmt = logging.Formatter(fmt=fmt, datefmt=datefmt)
handler.setFormatter(log_fmt)
 
logger.addHandler(handler)
 
logger.debug('debug msg')
logger.info('info msg')</code>
</pre> 
 </div> 
 <div>
   控制台输出如下： 
 </div> 
 <div> 
  <em>2019-03-29 19:36:03 Fri , DEBUG , log_test2.py &lt;module&gt; line 14 , debug msg</em> 
 </div> 
 <div> 
  <em>2019-03-29 19:36:03 Fri , INFO , log_test2.py &lt;module&gt; line 15 , info msg</em> 
 </div> 
 <div> 
  <strong>(4)过滤器：Filter</strong> 
 </div> 
 <div> 
  在我们已经知道的logging使用方法中，都是通过日志级别来控制日志是否输出，Filter能够实现更加强大的过滤功能，控制日志输出。自定义的过滤器中必须覆写filter方法，当filter的返回值判断为True则允许输出，反之不允许输出。例如过滤包含敏感信息的日志，过滤器定义如下： 
 </div> 
 <div class="cnblogs_code"> 
  <pre><code class="has">import logging
 
class CountryFilter(logging.Filter):
def filter(self,record):
return "America" not in record.getMessage()
 
logger = logging.getLogger()
handler = logging.StreamHandler()
logger.addHandler(handler)
logger.setLevel(logging.DEBUG)
logger.addFilter(CountryFilter())
 
logger.critical('I love America')
logger.debug('I love China')</code>
</pre> 
 </div> 
 <div>
   输出结果： 
 </div> 
 <div> 
  <em>I love China</em> 
 </div> 
 <div>
   可以看到，虽然第一条日志记录的日志等级更高，但是因为包含了过滤器中包含的敏感信息，所以不被允许输出。 
 </div> 
 <h2> 4 logging奇淫巧技</h2> 
 <h3>4.1 记录异常信息：捕获traceback</h3> 
 <div>
   如果在日志中，只是记录发生了异常，那其实作用不大，如果traceback也记录到日志中，那就完美了。强大的logging确实也提供了这一功能，而且使用也很简单： 
 </div> 
 <div class="cnblogs_code"> 
  <pre><code class="has">import logging
 
logger = logging.getLogger(__name__)
handler = logging.FileHandler('./.log',encoding='utf-8')
logger.setLevel(logging.DEBUG)
# 定义格式器,添加到处理器中
fmt = '%(asctime)s , %(levelname)s , %(filename)s %(funcName)s line %(lineno)s , %(message)s'
datefmt = '%Y-%m-%d %H:%M:%S %a'
log_fmt = logging.Formatter(fmt=fmt, datefmt=datefmt)
handler.setFormatter(log_fmt)
 
logger.addHandler(handler)
 
try:
logger.info('Running …')
1/0
except Exception as e:
logger.error('Exception occurs!',exc_info = True)
# logger.exception(e) # 与上面这行效果一样</code>
</pre> 
 </div> 
 <div>
   运行后，文件.log会被写入以下内容： 
 </div> 
 <div> 
  <em>2019-03-29 19:53:14 Fri , INFO , log_test2.py &lt;module&gt; line 15 , Running …</em> 
 </div> 
 <div> 
  <em>2019-03-29 19:53:14 Fri , ERROR , log_test2.py &lt;module&gt; line 18 , Exception occurs!</em> 
 </div> 
 <div> 
  <em>Traceback (most recent call last):</em> 
 </div> 
 <div> 
  <em>File "E:/myCode/test1/log_test2.py", line 16, in &lt;module&gt;</em> 
 </div> 
 <div> 
  <em>1/0</em> 
 </div> 
 <div> 
  <em>ZeroDivisionError: division by zero</em> 
 </div> 
 <h3>4.2 多模块共享日志</h3> 
 <div>
   在开发过程中，经常出现多个模块都需要记录日志的情况，也许你想到的做法是在一个模块中配置好一个logger并实例化，在需要用到的模块中进行导入，但如果不同模块的日志器配置有区别时，这种方法就不适用了，若是为每个模块都定义一个logger，所有配置都需要重新写入，有些繁琐。还记得上文中提到logging的日志器可以通过name属性进行分层吗？子日志器可以继承父日志器的配置，也可以重新配置，这就是logging给我们提供的多模块共享日志的解决方案。看代码： 
 </div> 
 <div>
   模块main.py中的代码： 
 </div> 
 <div class="cnblogs_code"> 
  <pre><code class="has">import logging
import log_child
logger = logging.getLogger('main')
logger.setLevel(logging.DEBUG)
 
fmt = '%(name)s , %(asctime)s , %(levelname)s , %(filename)s %(funcName)s line %(lineno)s , %(message)s'
datefmt = '%Y-%m-%d %H:%M:%S %a'
log_fmt = logging.Formatter(fmt=fmt, datefmt=datefmt)
 
handler = logging.FileHandler('./.log',encoding='utf-8')
handler.setFormatter(log_fmt)
 
logger.addHandler(handler)
 
if __name__=='__main__':
logger.debug('Running …')
log_child.fun_child()</code>
</pre> 
 </div> 
 <div>
   模块child_log.py中的代码： 
 </div> 
 <div>
     
  <div class="cnblogs_code"> 
   <pre><code class="has">import logging
 
logger = logging.getLogger('main.child')
logger.setLevel(logging.DEBUG)
def fun_child():
try:
    logger.info('Running …')
    1 / 0
except Exception as e:
    logger.exception(e)</code>
</pre> 
  </div> 
 </div> 
 <div>
   运行main.py后，.log文件会被写入一下内容： 
 </div> 
 <div> 
  <em>main , 2019-03-29 20:23:32 Fri , DEBUG , main.py &lt;module&gt; line 16 , Running …</em> 
 </div> 
 <div> 
  <em>main.child , 2019-03-29 20:23:32 Fri , INFO , log_child.py fun_child line 7 , Running …</em> 
 </div> 
 <div> 
  <em>main.child , 2019-03-29 20:23:32 Fri , ERROR , log_child.py fun_child line 10 , division by zero</em> 
 </div> 
 <div> 
  <em>Traceback (most recent call last):</em> 
 </div> 
 <div> 
  <em>File "E:\myCode\test1\log_child.py", line 8, in fun_child</em> 
 </div> 
 <div> 
  <em>1 / 0</em> 
 </div> 
 <div> 
  <em>ZeroDivisionError: division by zero</em> 
 </div> 
 <h3>4.3 使用配置文件配置logger</h3> 
 <div>
   我们之前的程序中都是将对logger的配置一并写在程序中，但事实上，采用配置化编程的方式，将对logger的配置写在专门的配置文件中，例如写入json文件、conf文件、yaml文件等文件中，当需要实例化logger时，读取即可。下面以conf文件为例，通过代码注释的方式，介绍logging配置文件的书写方式。配置文件log.conf如下： 
 </div> 
 <div>
     
  <div class="cnblogs_code"> 
   <pre><code class="has">[loggers] #固定写法,定义logger的模块
keys=root,log_1,log_2 #创建三个logger,root是父类，必需存在的，其他两个logger的name分别为
 
[logger_root] # 定制上面的logger，严格要求格式为"logger_loggername"，必须通过loggername与上面的logger一一对应
level=DEBUG # 设置日志级别
qualname=root # 对于root，其实这里可以不填,默认就是root
handlers=debugs #设置指定处理器,如果有多个处理器，中间以逗号分隔,这个名字待会儿 我们会以固定格式"handler_(value)"创建
 
[logger_log_1]
level=INFO
qualname=log_1 #除了root以外，必须要设置这个属性，用于定义打印输出时候的logger名
handlers=infos
propagate=0 # 是否将消息想父日志传递，0表示不传递，1表示传递。如果向上传递，父日志器接收到消息后会以父日志器的配置再次处理该消息，所以可能所有多次输出
 
[logger_log_2]
level=WARNING
qualname=log_2
handlers=warns
 
[handlers] #固定格式， 开始定义处理器
keys=debugs,infos,warns#定义过滤器名称，与上面出现的handlers的值一一对应，下面定义以handler_handlername格式定义
 
[handler_debugs]
class=StreamHandler # 指定处理器的类名
level=DEBUG # 设置级别
formatter=form01 #定义格式器,名称为form01,下面会创建formatters，格式也是严格要求为formatter_formattername
args=(sys.stdout,) # 控制台输出
 
[handler_infos]
class=FileHandler
level=INFO
formatter=form02
args=('b.log','a')
 
[handler_warns]
class=FileHandler
level=WARNING
formatter=form02
args=('a.log','a')# 写入到文件，写入方式
 
[formatters] #固定格式
keys=form01,form02 #定义名称，下面会引用格式，与上面出现的formatter的值对应
 
[formatter_form01]
format=%(asctime)s %(message)s # 定义消息输出格式，内容
datefmt=%Y-%m-%d %H:%M:%S #日期输出格式
 
[formatter_form02]
format=%(asctime)s %(filename)s %(levelname)s %(message)s
datefmt=%Y-%m-%d %H:%M:%S</code>
</pre> 
  </div> 
 </div> 
 <div>
   实例化logger： 
 </div> 
 <div class="cnblogs_code"> 
  <pre><code class="has"># _*_coding:utf-8_*_
import logging
from logging.config import fileConfig
 
fileConfig('log.conf')
root= logging.getLogger(name="root")
log_1= logging.getLogger(name="log_1")
log_2= logging.getLogger(name="log_2")
 
root.debug('root_debug')
root.info('root_info')
root.warning('root_warning')
log_1.debug('log_1_debug')
log_1.info('log_1_info')
log_1.warning('log_1_warning')
log_2.debug('log_2_debug')
log_2.info('log_2_info')
log_2.warning('log_2_warning')</code>
</pre> 
 </div> 
 <div>
   程序运行后，控制台输出如下： 
 </div> 
 <div> 
  <em>2019-03-29 21:43:24 root_debug</em> 
 </div> 
 <div> 
  <em>2019-03-29 21:43:24 root_info</em> 
 </div> 
 <div> 
  <em>2019-03-29 21:43:24 root_warning</em> 
 </div> 
 <div>
   a.log文件将被写入以下内容： 
 </div> 
 <div> 
  <em>2019-03-29 21:43:24 main.py INFO log_1_info</em> 
 </div> 
 <div> 
  <em>2019-03-29 21:43:24 main.py WARNING log_1_warning</em> 
 </div> 
 <div>
   b.log文件将被写入以下内容： 
 </div> 
 <div> 
  <em>2019-03-29 21:43:24 main.py WARNING log_2_warning</em> 
 </div> 
 <h3>4.3 日志回滚</h3> 
 <div>
   什么是日志回滚呢？咋一听，好像不知道是什么东西。日志回滚就是按照日期或者时间(有时候甚至是日志和时间综合作用)，对日志进行分割或者删除。实际开发中经常需要用到，因为随着应用的持续运行，日志文件会越来越庞大，对系统的性能产生影响，所以有必要删除早起的日志。 
 </div> 
 <div>
   logging中提供了两个处理器用于日志回滚，一个是RotatingFileHandler，它主要是根据日志文件的大小进行滚动，另一个是TimeRotatingFileHandler，它主要是根据时间进行滚动。 
 </div> 
 <div> 
  <strong>(1)根据文件大小进行回滚</strong> 
 </div> 
 <div>
   按文件大小回滚的类是RotatingFileHandler： 
 </div> 
 <div>
     
  <div class="cnblogs_code"> 
   <pre><code class="has"># -*- coding:utf-8 -*-
import logging
from logging.handlers import RotatingFileHandler
 
logger = logging.getLogger('main')
logger.setLevel(level = logging.INFO)
# 定义一个RotatingFileHandler，最多备份三个日志文件, 每个日志文件最大1k
file_handler = RotatingFileHandler(".log",maxBytes = 1*1024,backupCount = 3)
 
file_handler.setLevel(logging.INFO)
formatter = logging.Formatter('%(asctime)s - %(name)s - %(levelname)s - %(message)s')
file_handler.setFormatter(formatter)
 
cons_handler = logging.StreamHandler()
cons_handler.setLevel(logging.DEBUG)
cons_handler.setFormatter(formatter)
 
logger.addHandler(file_handler)
logger.addHandler(cons_handler)
 
if __name__=='__main__':
    while True:
        logger.debug("debug")
        logger.info("info")
        logger.warning("warning")
        logger.critical("critical")</code>
</pre> 
  </div> 
 </div> 
 <div>
   上述程序执行后，将持续在控制台输出所有的日志记录，日志记录文件有三个，循环向日志文件中写入日志，当文件大小达到1kb时，开始在另一个文件删除日志记录，并写入新的日志记录。 
 </div> 
 <div> 
  <strong>(2)根据时间进行回滚。</strong> 
 </div> 
 <div> 
  <strong>按文件时间回滚的类时TimeRotatingFileHandler，这一个类包含以下参数：</strong> 
 </div> 
 <div> 
  <strong>filename ：输出日志文件名的前缀，比如main.log</strong> 
 </div> 
 <div> 
  <strong>when 是一个字符串的定义如下：</strong> 
 </div> 
 <div> 
  <strong>“S”: Seconds</strong> 
 </div> 
 <div> 
  <strong>“M”: Minutes</strong> 
 </div> 
 <div> 
  <strong>“H”: Hours</strong> 
 </div> 
 <div> 
  <strong>“D”: Days</strong> 
 </div> 
 <div> 
  <strong>“W”: Week day (0=Monday)</strong> 
 </div> 
 <div> 
  <strong>“midnight”: Roll over at midnight</strong> 
 </div> 
 <div> 
  <strong>interval 是指等待多少个单位when的时间后</strong> 
 </div> 
 <div>
     
  <div class="cnblogs_code"> 
   <pre><code class="has">import time
import logging
import logging.handlers
 
# logging初始化工作
logging.basicConfig()
 
# logger的初始化工作
logger = logging.getLogger('main')
logger.setLevel(logging.INFO)
 
# 添加TimedRotatingFileHandler
# 定义一个1秒换一次log文件的handler
# 保留3个旧log文件
timefilehandler = logging.handlers.TimedRotatingFileHandler(".log", when='S', interval=1, backupCount=3)
# 设置后缀名称，跟strftime的格式一样
timefilehandler.suffix = "%Y-%m-%d_%H-%M-%S.log"
 
formatter = logging.Formatter('%(asctime)s|%(name)-12s: %(levelname)-8s %(message)s')
timefilehandler.setFormatter(formatter)
logger.addHandler(timefilehandler)
 
while True:
    time.sleep(0.1)
    logger.debug("debug")
    logger.info("info")
    logger.warning("warning")
    logger.critical("critical")</code>
</pre> 
  </div> 
 </div> 
 <h2>5 总结</h2> 
 <div>
   本篇系统得总结了Python内容的日志记录模块logging的用法，囊括了logging的大部分内容。掌握本篇内容，感觉在开发中基本没有问题。 
 </div> 
 <div>
   参考： 
 </div> 
 <div> 
  <a href="https://www.cnblogs.com/yyds/p/6901864.html" rel="nofollow">https://www.cnblogs.com/yyds/p/6901864.html</a> 
 </div> 
 <div> 
  <a href="https://blog.csdn.net/leiwuhen92/article/details/87914449">https://blog.csdn.net/leiwuhen92/article/details/87914449</a> 
 </div> 
 <div> 
  <a href="http://www.cnblogs.com/andy9468/p/8378492.html" rel="nofollow">http://www.cnblogs.com/andy9468/p/8378492.html</a> 
 </div> 
</div>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/9e07cec384f844a5a604dfc1086b132f/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">Java基础之 三 方法的定义与参数</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/f161b072e0348ef1379ae6edf3a6c690/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">vue element 树形穿梭框 权限设置前端显示的好帮手</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>