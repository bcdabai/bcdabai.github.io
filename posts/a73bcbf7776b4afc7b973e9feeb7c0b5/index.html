<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>YoloV5 训练长方形图像 - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="YoloV5 训练长方形图像" />
<meta property="og:description" content="20230329更新 官方的源代码中，训练的时候将rect开启，即可进行长方形训练同时也会进一步降低训练时的显存。
Imagesz只需要设置图像最大尺寸即可，在dataload中，读取图像时候会进行判断处理，
在load_image过程中，会将图像等比例缩放
比如原图为1280*640。
输入的imagesize为1280的话，则读取的图像为1280*640，
输入的imagesize为640的话，则读取的图像为640*320
但是需要注意开始Rect后 不会再对图像进行mosaic的增强，如果实在需要的话可以参考原来的长方形训练（下面的文章进行更改）
长方形图像训练： Step1: 修改训练图片的尺寸，因为默认尺寸是是对训练集和验证集的。所以此处进行修改长方形时，需要分别赋值构建一个数组。 Step2:Train.py中修改对图像尺寸检查的功能。 Step3: Train.py中修改模型属性功能。原来640 是int类型，现在【640,320】是一个数组。所以需要进行修改。 Step4: 对LoadImageAndLabels中的代码进行修改 修改mosic功能 修改Load_image功能 修改load_mosaic功能 修改mosaic拼接功能以及label拼接的功能。 注意看if isinstance 做判断的位置，都会进行修改。 def load_mosaic(self, index): # YOLOv5 4-mosaic loader. Loads 1 image &#43; 3 random images into a 4-image mosaic labels4, segments4 = [], [] if isinstance(self.img_size, int): s = self.img_size yc, xc = (int(random.uniform(-x, 2 * s &#43; x)) for x in self.mosaic_border) # mosaic center x, y else: s_h, s_w = self." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/a73bcbf7776b4afc7b973e9feeb7c0b5/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-03-29T11:27:38+08:00" />
<meta property="article:modified_time" content="2023-03-29T11:27:38+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">YoloV5 训练长方形图像</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <h3>20230329更新</h3> 
<p>官方的源代码中，训练的时候将rect开启，即可进行长方形训练同时也会进一步降低训练时的显存。</p> 
<p><img alt="" height="28" src="https://images2.imgbox.com/9c/00/s7L87Drd_o.png" width="784"></p> 
<p><img alt="" height="28" src="https://images2.imgbox.com/4f/d3/akAvlML2_o.png" width="945"></p> 
<p> Imagesz只需要设置图像最大尺寸即可，在dataload中，读取图像时候会进行判断处理，</p> 
<p><img alt="" height="515" src="https://images2.imgbox.com/b4/34/2eseN7XF_o.png" width="796"></p> 
<p> 在load_image过程中，会将图像等比例缩放</p> 
<p>比如原图为1280*640。</p> 
<p>输入的imagesize为1280的话，则读取的图像为1280*640，</p> 
<p>输入的imagesize为640的话，则读取的图像为640*320</p> 
<p><img alt="" height="74" src="https://images2.imgbox.com/fd/88/kaYrVvF6_o.png" width="684"></p> 
<p><img alt="" height="697" src="https://images2.imgbox.com/55/e6/1PeFpRGE_o.png" width="965"></p> 
<p> </p> 
<p><span style="color:#fe2c24;"><strong>但是需要注意开始Rect后 不会再对图像进行mosaic的增强，如果实在需要的话可以参考原来的长方形训练（下面的文章进行更改）</strong></span></p> 
<p><img alt="" height="35" src="https://images2.imgbox.com/db/40/MsXqfLEY_o.png" width="891"></p> 
<p> </p> 
<p><img alt="" height="328" src="https://images2.imgbox.com/bc/7f/cqQfpMFU_o.png" width="772"></p> 
<p> </p> 
<p> </p> 
<h3></h3> 
<h3></h3> 
<h3>长方形图像训练：</h3> 
<h4>Step1: 修改训练图片的尺寸，因为默认尺寸是是对训练集和验证集的。所以此处进行修改长方形时，需要分别赋值构建一个数组。</h4> 
<p><img alt="" height="80" src="https://images2.imgbox.com/63/ac/R0JvfYO0_o.png" width="1064"></p> 
<p></p> 
<h4>Step2:Train.py中修改对图像尺寸检查的功能。</h4> 
<p><img alt="" height="140" src="https://images2.imgbox.com/42/bc/8i5WdNTh_o.png" width="869"></p> 
<h4>Step3: Train.py中修改模型属性功能。原来640 是int类型，现在【640,320】是一个数组。所以需要进行修改。</h4> 
<p><img alt="" height="313" src="https://images2.imgbox.com/5e/3f/NfYXeeCQ_o.png" width="1015"></p> 
<h4> Step4: 对LoadImageAndLabels中的代码进行修改</h4> 
<p> <img alt="" height="414" src="https://images2.imgbox.com/66/a4/biXyog0X_o.png" width="829"></p> 
<p></p> 
<p class="img-center"><img alt="" height="394" src="https://images2.imgbox.com/46/eb/r8KEheCb_o.png" width="488"></p> 
<p></p> 
<h4>修改mosic功能</h4> 
<p><img alt="" height="151" src="https://images2.imgbox.com/9b/86/vSkhJxzp_o.png" width="926"></p> 
<h4> 修改Load_image功能</h4> 
<p><img alt="" height="552" src="https://images2.imgbox.com/70/fd/K07ml3y2_o.png" width="918"></p> 
<h4> 修改load_mosaic功能</h4> 
<p> <img alt="" height="288" src="https://images2.imgbox.com/58/a0/pHfL4e9h_o.png" width="995"></p> 
<p></p> 
<h4 style="margin-left:0px;">修改mosaic拼接功能以及label拼接的功能。</h4> 
<h4 style="margin-left:0px;">注意看if isinstance 做判断的位置，都会进行修改。</h4> 
<pre><code class="language-python">    def load_mosaic(self, index):
        # YOLOv5 4-mosaic loader. Loads 1 image + 3 random images into a 4-image mosaic
        labels4, segments4 = [], []
        if isinstance(self.img_size, int):
            s = self.img_size
            yc, xc = (int(random.uniform(-x, 2 * s + x)) for x in self.mosaic_border)  # mosaic center x, y
        else:
            s_h, s_w = self.img_size  # (h,w)
            yc, xc = [int(random.uniform(-x, 2 * s + x)) for x, s in zip(self.mosaic_border, self.img_size)]
        indices = [index] + random.choices(self.indices, k=3)  # 3 additional image indices
        random.shuffle(indices)
        for i, index in enumerate(indices):
            # Load image
            img, _, (h, w) = self.load_image(index)
            if isinstance(self.img_size, int):
                # place img in img4
                if i == 0:  # top left
                    img4 = np.full((s * 2, s * 2, img.shape[2]), 114, dtype=np.uint8)  # base image with 4 tiles
                    x1a, y1a, x2a, y2a = max(xc - w, 0), max(yc - h, 0), xc, yc  # xmin, ymin, xmax, ymax (large image)
                    x1b, y1b, x2b, y2b = w - (x2a - x1a), h - (y2a - y1a), w, h  # xmin, ymin, xmax, ymax (small image)
                elif i == 1:  # top right
                    x1a, y1a, x2a, y2a = xc, max(yc - h, 0), min(xc + w, s * 2), yc
                    x1b, y1b, x2b, y2b = 0, h - (y2a - y1a), min(w, x2a - x1a), h
                elif i == 2:  # bottom left
                    x1a, y1a, x2a, y2a = max(xc - w, 0), yc, xc, min(s * 2, yc + h)
                    x1b, y1b, x2b, y2b = w - (x2a - x1a), 0, w, min(y2a - y1a, h)
                elif i == 3:  # bottom right
                    x1a, y1a, x2a, y2a = xc, yc, min(xc + w, s * 2), min(s * 2, yc + h)
                    x1b, y1b, x2b, y2b = 0, 0, min(w, x2a - x1a), min(y2a - y1a, h)
            else:
                if i == 0:  # top left
                    img4 = np.full((s_h * 2, s_w * 2, img.shape[2]), 114, dtype=np.uint8)  # base image with 4 tiles
                    x1a, y1a, x2a, y2a = max(xc - w, 0), max(yc - h, 0), xc, yc  # xmin, ymin, xmax, ymax (large image)
                    x1b, y1b, x2b, y2b = w - (x2a - x1a), h - (y2a - y1a), w, h  # xmin, ymin, xmax, ymax (small image)
                elif i == 1:  # top right
                    x1a, y1a, x2a, y2a = xc, max(yc - h, 0), min(xc + w, s_w * 2), yc
                    x1b, y1b, x2b, y2b = 0, h - (y2a - y1a), min(w, x2a - x1a), h
                elif i == 2:  # bottom left
                    x1a, y1a, x2a, y2a = max(xc - w, 0), yc, xc, min(s_h * 2, yc + h)
                    x1b, y1b, x2b, y2b = w - (x2a - x1a), 0, w, min(y2a - y1a, h)
                elif i == 3:  # bottom right
                    x1a, y1a, x2a, y2a = xc, yc, min(xc + w, s_w * 2), min(s_h * 2, yc + h)
                    x1b, y1b, x2b, y2b = 0, 0, min(w, x2a - x1a), min(y2a - y1a, h)

            img4[y1a:y2a, x1a:x2a] = img[y1b:y2b, x1b:x2b]  # img4[ymin:ymax, xmin:xmax]
            padw = x1a - x1b
            padh = y1a - y1b

            # Labels
            labels, segments = self.labels[index].copy(), self.segments[index].copy()
            if labels.size:
                labels[:, 1:] = xywhn2xyxy(labels[:, 1:], w, h, padw, padh)  # normalized xywh to pixel xyxy format
                segments = [xyn2xy(x, w, h, padw, padh) for x in segments]
            labels4.append(labels)
            segments4.extend(segments)</code></pre> 
<p>至此就完成了程序上的修改</p> 
<p>附mosaic增强</p> 
<p>        mosaic拼接并不是将图片进行4等份拼接。</p> 
<p style="margin-left:0;"> 1：会随机设定中心点，然后这个中心点将数据分为4份，然后将图片填充到每一份中。</p> 
<p style="margin-left:0;">马赛克的中心点值，随机从-x ---2*s+x 中随机抽选，一般X的值为-320，所以就变成 了  <span style="background-color:#ff0000;">320-        -960</span>中随机抽选中心值。</p> 
<p style="margin-left:0;"></p> 
<p style="margin-left:0;">Step0:   初始化整幅图，将图片的像素都填充为114</p> 
<p style="margin-left:0;">Step1：读取当前要填充的图片，并获取图片的长和宽</p> 
<p style="margin-left:0;">Step2:    计算当前图片在大图中的位置 ，如果当前图片超过大图界限，越界部分就取消掉。</p> 
<p style="margin-left:0;">同时如果当前图片过小，填充不了大图给定的区域位置。</p> 
<p style="margin-left:0;"><span style="color:#0d0016;">不管大图小图都要计算其在整幅图片中的位置</span>，计算差异值，因为接下来要取更新标签（label）</p> 
<p style="margin-left:0;">（标签是相对于图片的位置的，如果当前图片放入大图中，没有完全占据左上角，那么不就多余</p> 
<p style="margin-left:0;">了部分空的区域了吗直接计算标签的话肯定偏移，所以要去除掉这些空的区域再取加载原来的图片的标签并且更新）</p> 
<p style="margin-left:0;">如果有label正好在边界上，就要修正或者裁剪掉超过边界的框</p> 
<p style="margin-left:0;">Step3:    连续放入图片</p> 
<p style="margin-left:0;">Step4:  对放入的图片进行随机的旋转，翻转 ，平移 缩放等等操作。</p> 
<p style="margin-left:0;"></p> 
<p style="margin-left:0;"></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/4428436c80057ed1121db222a14e666e/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">ESP 保姆级教程 基础篇 —— 环境安装、NodeMcu引脚介绍</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/9ad3ec38ec23f1eb3fba5acaa6437427/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">Lua中字符串 指定位置切割</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>