<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>时间序列自监督学习综述 - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="时间序列自监督学习综述" />
<meta property="og:description" content="时间序列自监督学习综述 原创 泳鱼 算法进阶 2023-08-15 00:02 发表于福建
收录于合集#时间序列13个
自监督学习（SSL）是一种机器学习方法，最近在各种时间序列任务上取得了令人印象深刻的表现。SSL最显著的优点是它减少了对标记数据的依赖。基于预训练和微调策略，即使是少量的标记数据也能实现高性能。
今天分享一篇来自浙大和阿里等研究者们关于自监督学习用于时间序列的综述文章，文中回顾了现有的与SSL和时间序列相关的调查，为现有的时间序列SSL方法提供了一种新的分类法（图1）。他们将自监督学习时间序列分析归纳为三类：基于生成性的、基于对比性的和基于对抗性的。所有的方法进一步都可以分为十个子类。为了便于时间序列SSL方法的实验和验证，文中还总结了时间序列预测、分类、异常检测和聚类任务中常用的数据集。
图1：所提出的时间序列SSL分类法。
时间序列自监督学习（SSL）的方法通常可以分为三类，这些类别的模型架构如图2所示：
基于生成的方法：这种方法首先使用编码器将输入x映射到表示z，然后使用解码器从z中重构x。训练目标是最小化输入x和重构输入ˆx之间的重构误差。
基于对比的方法：这种方法是应用最广泛的SSL策略（自监督学习）之一，它通过数据增强或上下文抽样来构建正样本和负样本。然后，通过最大化两个正样本之间的互信息（MI）来训练该模型。基于对比的方法通常使用对比相似度度量，如InfoNCE loss。 基于对抗的方法：这种方法通常由一个生成器和一个判别器组成。生成器生成假样本，而判别器用来将它们与真实样本区分开来。
图2：SSL的学习范式。
1 基于生成的方法
在这个类别中，预文本任务是基于给定数据的视图生成预期数据。在时间序列建模的背景下，常用的预文本任务包括使用过去的序列来预测未来的时间窗口或特定的时间戳，使用编码器和解码器来重构输入，以及预测掩码时间序列的不可见部分。
本节从基于自回归的预测、基于自编码器的重构和基于扩散模型的生成3个角度整理了现有的时间序列建模中的自监督表示学习方法（图3）。需要注意的是，基于自编码器的重构任务也被视为一种无监督框架。在SSL的背景下，我们主要将重构任务用作预文本任务，最终目标是通过自编码器模型获得表示。
图3：基于生成的时间序列SSL的三个类别。
1.1 基于自回归的预测
ARF任务是一种基于时间序列的预测任务，其目标是使用时间戳t之前的序列来预测长度为K的窗口。在ARF任务中，预测模型f(·)通常采用自回归模型，即将当前时刻的输出作为下一时刻的输入，以此类推。当K=1时，ARF任务是单步预测模型，即预测下一个时间步的值；当K&gt;1时，ARF任务是多步预测模型，即预测未来多个时间步的值。 ARF任务的数学表达式为公式(1)，
其中X[1:t]表示时间戳t之前的序列，ˆX[t&#43;1:t&#43;K]表示预测的目标窗口。预测模型f(·)通常采用自回归模型，即将当前时刻的输出作为下一时刻的输入，以此类推。ARF任务的应用场景包括股票价格预测、气象预测、交通流量预测等。 ARF任务的相关研究和应用。ARF任务可以通过自编码器模型进行无监督学习，从而得到更好的时间序列表示。此外，ARF任务还可以与其他任务结合，例如异常检测、分类和聚类等。
1.2 基于自编码器的重构
自编码器是一种无监督学习的人工神经网络，由编码器和解码器两部分组成 [56]。编码器将输入数据X映射到一个低维表示Z，然后解码器将该低维表示Z映射回原始数据空间，得到重构数据˜X。解码器的输出被定义为重构输入˜X。该过程可以表示为：
自编码器的目标是最小化重构误差，即输入数据与重构数据之间的差异。在时间序列数据的应用中，自编码器可以用于时间序列数据的重构和表示学习，从而提高时间序列数据的表达能力和预测性能。
自编码器模型的变种。例如去噪自编码器、谱分析自编码器、时序聚类友好的表示学习模型等。这些变种模型可以通过引入额外的约束和损失函数来提高自编码器模型的性能和适用性。例如，去噪自编码器可以通过在输入数据中添加噪声来提高模型的鲁棒性和泛化能力；谱分析自编码器可以通过在损失函数中引入频谱约束来提高模型的频域表示能力；时序聚类友好的表示学习模型可以通过在损失函数中引入聚类约束来提高模型的聚类性能。
自编码器模型在时间序列数据的应用场景。例如信号处理、图像处理、语音识别、自然语言处理等。自编码器模型在这些领域中已经取得了一定的成功，并且在未来的研究中仍然具有广泛的应用前景。
1.3 基于扩散模型的生成
扩散模型是一种基于概率的生成模型，它的核心思想是通过两个逆向过程来实现样本生成。具体来说，扩散模型包含两个过程：正向过程和逆向过程。正向过程是将随机噪声注入到数据中，然后逐步完成转移，最终得到一个状态。逆向过程是从噪声分布中生成样本，它通过使用逆向状态转移操作来实现。逆向转移核是逆向过程的关键，但通常很难确定。因此，扩散模型通过深度神经网络来学习逼近逆向转移核，从而实现高效的样本生成。
目前，扩散模型主要有三种基本形式：去噪扩散概率模型（DDPMs）、分数匹配扩散模型和分数随机微分方程（SDEs）模型。DDPMs模型通过去噪来逼近逆向转移核，分数匹配扩散模型通过匹配梯度来逼近逆向转移核，而SDEs模型则通过随机微分方程来逼近逆向转移核。这些模型的设计都是为了解决逆向转移核的问题，从而实现高效的样本生成。
扩散模型在图像合成、视频生成、语音生成、生物信息学和自然语言处理等领域取得了很大的成功。它是一种强大的生成模型，可以用于各种领域的数据生成和建模。扩散模型的优点包括：生成效果好、生成速度快、可扩展性强、可解释性好等。因此，扩散模型在深度学习领域中备受关注，成为了一种重要的生成模型。
2 基于对比的方法
对比学习是一种自监督学习策略，在计算机视觉和自然语言处理中表现出强大的学习能力。与其他模型不同，对比学习方法通过对比正负样本来学习数据表示，其中正样本应该相似，负样本应该不同。因此，对正负样本的选择对于对比学习方法非常重要。图4展示了基于对比的时间序列自监督学习的五个类别。
图4：基于对比的时间序列自监督学习的五个类别
2.1 采样对比法
采样对比方法，将时间序列分成多个固定长度的子序列，然后从每个子序列中随机选择两个不同的采样点作为正样本，同时从其他子序列中随机选择一个采样点作为负样本。通过对比正负样本，采样对比方法可以学习到时间序列的表示。该方法遵循时间序列分析中广泛使用的假设，即相邻的时间窗口或时间戳具有高度相似性。因此正负样本直接从原始时间序列中采样。
采样对比方法遵循时间序列分析中最常用的假设。它具有简单的原则，并且可以很好地模拟局部相关性，对于一些时间序列数据集，采样对比方法可以获得很好的性能。然而，它的缺点在于，在分析长期依赖性时可能会引入虚假的负样本对，导致表示不够优化。因此，在处理长期依赖性时，采样对比方法可能不是最佳选择。此外，采样对比方法需要选择合适的子序列长度和采样点数量，这可能需要一些经验和调整。
2.2 预测对比法
预测对比法用于学习时间序列的表示。该方法通过预测时间序列中未来的信息来学习有意义和信息丰富的表示。具体来说，该方法将时间序列分成多个固定长度的子序列，然后将每个子序列的最后一个时间步作为目标，将其余时间步作为上下文。然后，模型被训练来预测目标时间步的值，同时使用其他子序列的目标时间步作为负样本。通过对比正样本和负样本，预测对比方法可以学习到时间序列的表示。
预测对比方法的优点在于，它可以学习到时间序列中的有意义和信息丰富的表示，捕捉数据中的重要特征和模式。该方法更加关注时间序列数据中的缓慢变化趋势，并且可以提取缓慢的特征。此外，预测对比方法的实现非常简单，易于理解和实现。然而，预测对比方法的缺点在于，它主要关注局部信息，可能无法准确地建模时间序列数据中的长期依赖性。此外，该方法对噪声和异常值比较敏感，这可能会影响模型的表示能力和泛化性能。因此，在处理具有复杂长期依赖性的时间序列数据时，预测对比方法可能不是最佳选择。
2.3 增强对比法
增强对比方法是一种常用的对比学习框架，它通过数据增强技术生成输入样本的不同视图，然后通过最大化来自相同样本的视图的相似性和最小化来自不同样本的视图的相似性来学习表示。具体来说，该方法将每个输入样本分成两个视图，然后使用一个神经网络来学习将这两个视图映射到相同的表示空间中。然后，通过最大化来自相同样本的视图的相似性和最小化来自不同样本的视图的相似性来训练网络。这可以通过使用对比损失函数来实现，其中对于每个样本，网络将学习将其与其他样本区分开来。
增强对比方法的优点在于易于实现和理解，适用于各种类型的时间序列建模任务。此外，该方法可以通过使用各种数据增强技术来增加数据的多样性，从而提高模型的泛化性能。然而，该方法的缺点在于处理时间依赖性是一个挑战，因为增强对比的本质在于区分正样本和负样本对的特征表示，而不是显式地捕捉时间依赖性。选择适当的时间序列数据增强方法也是一个具有挑战性的问题。此外，采样偏差是另一个问题，因为它可能导致生成虚假的负样本，从而影响模型的性能。
2.4 原型对比法
原型对比方法是一种基于聚类约束的对比学习框架，它通过将样本与聚类中心进行对比来学习时间序列数据的表示。该方法可以减少计算量，并鼓励样本在特征空间中呈现出友好的聚类分布。具体来说，原型对比方法将样本分为不同的聚类，将聚类中心作为原型，然后将样本与原型进行对比，以学习时间序列数据的表示。该方法可以通过使用对比损失函数来实现，其中对于每个样本，网络将学习将其与其他样本区分开来。
原型对比方法引入了原型的概念，使样本可以被分配到有限数量的类别中。该方法利用高级语义信息，鼓励样本在特征空间中呈现聚类分布，而不是均匀分布，这更符合真实数据分布。然而，该方法的主要问题是原型的数量需要预先确定，这仍然需要一些先验信息。
2.5 专家知识对比法
专家知识对比方法是一种相对较新的表示学习框架，它可以在对比学习框架中引入先验知识，以帮助模型选择正确的正负样本。例如，在训练过程中，可以选择一个锚点样本和一个正样本，以及一些负样本。然后，网络将学习将锚点样本与正样本相似，并将锚点样本与负样本区分开来。这可以通过使用对比损失函数来实现，其中对于每个样本，网络将学习将其与其他样本区分开来，并将其分配到正确的正负样本中。
专家知识对比方法的特点是可以将领域专家的先验知识或信息引入深度神经网络中，以指导正负样本的选择或相似度的测量。其主要优点在于能够准确选择正负样本。然而，其局限性在于需要提供可靠的先验知识。在大多数情况下，为时间序列数据获取可靠的先验知识并不容易。不正确或误导性的知识可能会导致偏见的表示。
3 基于对抗的方法
基于对抗的方法利用生成对抗网络（GAN）构建预文本任务。GAN包含一个生成器G和一个判别器D。生成器G负责生成类似于真实数据的合成数据，而判别器D负责确定生成的数据是真实数据还是合成数据。因此，生成器的目标是最大化判别器的决策失败率，而判别器的目标是最小化其失败率。生成器G和判别器D是一种相互博弈的关系，因此学习目标是通过最小化损失函数L来优化生成器和判别器的性能。
根据最终任务，现有的基于对抗性的表示学习方法可以分为时间序列生成和插补，以及辅助表示增强。图5展示了基于对抗性的时间序列自监督学习的示意图。
图5：基于对抗性的时间序列自监督学习的三个类别" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/cb730a44e27eb02ea0edd8876cedb82f/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-08-15T13:09:16+08:00" />
<meta property="article:modified_time" content="2023-08-15T13:09:16+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">时间序列自监督学习综述</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <h2 id="activity-name">时间序列自监督学习综述</h2> 
<p>原创 泳鱼 <a id="js_name">算法进阶</a> <em id="publish_time">2023-08-15 00:02</em> <em id="js_ip_wording_wrp">发表于福建</em></p> 
<p>收录于合集#时间序列13个</p> 
<p></p> 
<p><span style="background-color:#a2e043;">自监督学习（SSL）</span>是一种机器学习方法，最近在各种时间序列任务上取得了令人印象深刻的表现。SSL最显著的优点是它<span style="background-color:#a2e043;">减少了对标记数据的依赖</span>。基于<span style="background-color:#38d8f0;">预训练</span>和<span style="background-color:#ff9900;">微调策略</span>，即使是少量的标记数据也能实现高性能。</p> 
<p>今天分享一篇来自浙大和阿里等研究者们关于自监督学习用于时间序列的综述文章，文中回顾了现有的与SSL和时间序列相关的调查，为现有的时间序列SSL方法提供了一种新的分类法（图1）。他们将自监督学习时间序列分析归纳为三类：<strong>基于生成性的、基于对比性的和基于对抗性的。</strong>所有的方法进一步都可以分为十个子类。为了便于时间序列SSL方法的实验和验证，文中还总结了时间序列预测、分类、异常检测和聚类任务中常用的数据集。</p> 
<p></p> 
<p></p> 
<p class="img-center"><img alt="" height="364" src="https://images2.imgbox.com/ca/1c/3lC1qJCG_o.png" width="869"></p> 
<p>图1：所提出的时间序列SSL分类法。</p> 
<p>时间序列自监督学习（SSL）的方法通常可以分为三类，这些类别的模型架构如图2所示：</p> 
<ol><li> <p>基于生成的方法：这种方法首先使用编码器将输入x映射到表示z，然后使用解码器从z中重构x。训练目标是最小化输入x和重构输入ˆx之间的重构误差。</p> </li><li> <p>基于对比的方法：这种方法是应用最广泛的<span style="background-color:#ffd900;">SSL策略（</span><span style="background-color:#a2e043;">自监督学习</span><span style="background-color:#ffd900;">）</span>之一，它通过数据增强或上下文抽样来构建正样本和负样本。然后，通过最大化两个正样本之间的<span style="background-color:#a2e043;">互信息（MI）</span>来训练该模型。基于对比的方法通常使用对比相似度度量，如<span style="background-color:#38d8f0;">InfoNCE loss</span>。 </p> </li><li> <p>基于对抗的方法：这种方法通常由一个生成器和一个判别器组成。生成器生成假样本，而判别器用来将它们与真实样本区分开来。</p> </li></ol> 
<p></p> 
<p class="img-center"><img alt="" height="216" src="https://images2.imgbox.com/55/27/FpRkKncY_o.png" width="859"></p> 
<p>图2：SSL的学习范式。</p> 
<p>1  基于生成的方法</p> 
<p>在这个类别中，预文本任务是基于给定数据的视图生成预期数据。在时间序列建模的背景下，常用的预文本任务包括使用过去的序列来预测未来的时间窗口或特定的时间戳，使用编码器和解码器来重构输入，以及预测掩码时间序列的不可见部分。</p> 
<p>本节从基于自回归的预测、基于自编码器的重构和基于扩散模型的生成3个角度整理了现有的时间序列建模中的自监督表示学习方法（图3）。需要注意的是，基于自编码器的重构任务也被视为一种无监督框架。在SSL的背景下，我们主要将重构任务用作预文本任务，最终目标是通过自编码器模型获得表示。</p> 
<p></p> 
<p class="img-center"><img alt="图片" height="527" src="https://images2.imgbox.com/ea/c3/Cfmqbax4_o.png" width="509"></p> 
<p>图3：基于生成的时间序列SSL的三个类别。</p> 
<p>1.1  基于<span style="background-color:#a2e043;">自回归的预测</span></p> 
<p>ARF任务是一种基于时间序列的预测任务，其目标是使用时间戳t之前的序列来预测长度为K的窗口。在<span style="background-color:#faa572;">ARF任务</span>中，预测模型f(·)通常采用自回归模型，即将当前时刻的输出作为下一时刻的输入，以此类推。当K=1时，ARF任务是单步预测模型，即预测下一个时间步的值；当K&gt;1时，ARF任务是多步预测模型，即预测未来多个时间步的值。 </p> 
<p>ARF任务的数学表达式为公式(1)，</p> 
<p></p> 
<p class="img-center"><img alt="图片" height="43" src="https://images2.imgbox.com/bd/5c/bhw1XhVm_o.png" width="435"></p> 
<p>其中X[1:t]表示时间戳t之前的序列，ˆX[t+1:t+K]表示预测的目标窗口。预测模型f(·)通常采用自回归模型，即将当前时刻的输出作为下一时刻的输入，以此类推。ARF任务的应用场景包括股票价格预测、气象预测、交通流量预测等。 </p> 
<p>ARF任务的相关研究和应用。ARF任务可以通过自编码器模型进行无监督学习，从而得到更好的时间序列表示。此外，ARF任务还可以与其他任务结合，例如异常检测、分类和聚类等。</p> 
<p>1.2  基于自编码器的重构</p> 
<p>自编码器是一种无监督学习的人工神经网络，由编码器和解码器两部分组成 [56]。编码器将输入数据X映射到一个低维表示Z，然后解码器将该低维表示Z映射回原始数据空间，得到重构数据˜X。解码器的输出被定义为重构输入˜X。该过程可以表示为：</p> 
<p></p> 
<p class="img-center"><img alt="图片" height="33" src="https://images2.imgbox.com/39/e1/Nr6kMwdi_o.png" width="391"></p> 
<p>自编码器的目标是最小化重构误差，即输入数据与重构数据之间的差异。在时间序列数据的应用中，自编码器可以用于时间序列数据的重构和表示学习，从而提高时间序列数据的表达能力和预测性能。</p> 
<p><strong>自编码器模型的变种。</strong>例如去噪自编码器、谱分析自编码器、时序聚类友好的表示学习模型等。这些变种模型可以通过引入额外的约束和损失函数来提高自编码器模型的性能和适用性。例如，去噪自编码器可以通过在输入数据中添加噪声来提高模型的鲁棒性和泛化能力；谱分析自编码器可以通过在损失函数中引入频谱约束来提高模型的频域表示能力；时序聚类友好的表示学习模型可以通过在损失函数中引入聚类约束来提高模型的聚类性能。</p> 
<p><strong>自编码器模型在时间序列数据的应用场景。</strong>例如信号处理、图像处理、语音识别、自然语言处理等。自编码器模型在这些领域中已经取得了一定的成功，并且在未来的研究中仍然具有广泛的应用前景。</p> 
<p>1.3  基于<span style="background-color:#ff9900;">扩散模型的生成</span></p> 
<p>扩散模型是一种<span style="background-color:#ffd900;">基于概率的生成模型</span>，它的核心思想是<span style="background-color:#a2e043;">通过两个逆向过程</span>来<span style="background-color:#a2e043;">实现样本生成</span>。具体来说，扩散模型包含<span style="background-color:#ffd900;">两个过程</span>：正向过程和逆向过程。正向过程是将随机噪声注入到数据中，然后逐步完成转移，最终得到一个状态。逆向过程是从噪声分布中生成样本，它通过使用逆向状态转移操作来实现。逆向转移核是逆向过程的关键，但通常很难确定。因此，扩散模型通过深度神经网络来学习逼近逆向转移核，从而实现高效的样本生成。</p> 
<p>目前，扩散模型主要有三种基本形式：<span style="background-color:#ffd900;">去噪扩散概率模型（DDPM</span>s）、<span style="background-color:#a2e043;">分数匹配扩散模型</span>和分数随机微分方程（SDEs）模型。<strong><span style="background-color:#ff9900;">DDPMs模型</span></strong><span style="background-color:#ff9900;">通过去噪</span>来逼近逆向转移核，<strong>分数匹配扩散模型</strong>通过匹配梯度来逼近逆向转移核，而<strong>SDEs模型</strong>则通过随机微分方程来逼近逆向转移核。这些模型的设计都是为了解决逆向转移核的问题，从而实现高效的样本生成。</p> 
<p>扩散模型在图像合成、视频生成、语音生成、生物信息学和自然语言处理等领域取得了很大的成功。它是一种强大的生成模型，可以用于各种领域的数据生成和建模。扩散模型的优点包括：生成效果好、生成速度快、可扩展性强、可解释性好等。因此，扩散模型在深度学习领域中备受关注，成为了一种重要的生成模型。</p> 
<p>2  基于对比的方法</p> 
<p>对比学习是一种自监督学习策略，在计算机视觉和自然语言处理中表现出强大的学习能力。与其他模型不同，对比学习方法通过对比正负样本来学习数据表示，其中正样本应该相似，负样本应该不同。因此，对正负样本的选择对于对比学习方法非常重要。图4展示了基于对比的时间序列自监督学习的五个类别。</p> 
<p></p> 
<p class="img-center"><img alt="图片" height="344" src="https://images2.imgbox.com/d5/d0/GWdnbg7a_o.png" width="920"></p> 
<p>图4：基于对比的时间序列自监督学习的五个类别</p> 
<p>2.1  采样对比法</p> 
<p>采样对比方法，将时间序列分成多个固定长度的子序列，然后从每个子序列中随机选择两个不同的采样点作为正样本，同时从其他子序列中随机选择一个采样点作为负样本。通过对比正负样本，采样对比方法可以学习到时间序列的表示。该方法遵循时间序列分析中广泛使用的假设，即相邻的时间窗口或时间戳具有高度相似性。因此正负样本直接从原始时间序列中采样。</p> 
<p>采样对比方法遵循时间序列分析中最常用的假设。它具有简单的原则，并且可以很好地模拟局部相关性，对于一些时间序列数据集，采样对比方法可以获得很好的性能。然而，它的缺点在于，在分析长期依赖性时可能会引入虚假的负样本对，导致表示不够优化。因此，在处理长期依赖性时，采样对比方法可能不是最佳选择。此外，采样对比方法需要选择合适的子序列长度和采样点数量，这可能需要一些经验和调整。</p> 
<p>2.2  预测对比法</p> 
<p>预测对比法用于学习时间序列的表示。该方法通过预测时间序列中未来的信息来学习有意义和信息丰富的表示。具体来说，该方法将时间序列分成多个固定长度的子序列，然后将每个子序列的最后一个时间步作为目标，将其余时间步作为上下文。然后，模型被训练来预测目标时间步的值，同时使用其他子序列的目标时间步作为负样本。通过对比正样本和负样本，预测对比方法可以学习到时间序列的表示。</p> 
<p>预测对比方法的优点在于，它可以学习到时间序列中的有意义和信息丰富的表示，捕捉数据中的重要特征和模式。该方法更加关注时间序列数据中的缓慢变化趋势，并且可以提取缓慢的特征。此外，预测对比方法的实现非常简单，易于理解和实现。然而，预测对比方法的缺点在于，它主要关注局部信息，可能无法准确地建模时间序列数据中的长期依赖性。此外，该方法对噪声和异常值比较敏感，这可能会影响模型的表示能力和泛化性能。因此，在处理具有复杂长期依赖性的时间序列数据时，预测对比方法可能不是最佳选择。</p> 
<p>2.3  增强对比法</p> 
<p>增强对比方法是一种常用的对比学习框架，它通过数据增强技术生成输入样本的不同视图，然后通过最大化来自相同样本的视图的相似性和最小化来自不同样本的视图的相似性来学习表示。具体来说，该方法将每个输入样本分成两个视图，然后使用一个神经网络来学习将这两个视图映射到相同的表示空间中。然后，通过最大化来自相同样本的视图的相似性和最小化来自不同样本的视图的相似性来训练网络。这可以通过使用对比损失函数来实现，其中对于每个样本，网络将学习将其与其他样本区分开来。</p> 
<p>增强对比方法的优点在于易于实现和理解，适用于各种类型的时间序列建模任务。此外，该方法可以通过使用各种数据增强技术来增加数据的多样性，从而提高模型的泛化性能。然而，该方法的缺点在于处理时间依赖性是一个挑战，因为增强对比的本质在于区分正样本和负样本对的特征表示，而不是显式地捕捉时间依赖性。选择适当的时间序列数据增强方法也是一个具有挑战性的问题。此外，采样偏差是另一个问题，因为它可能导致生成虚假的负样本，从而影响模型的性能。</p> 
<p>2.4  原型对比法</p> 
<p>原型对比方法是一种基于聚类约束的对比学习框架，它通过将样本与聚类中心进行对比来学习时间序列数据的表示。该方法可以减少计算量，并鼓励样本在特征空间中呈现出友好的聚类分布。具体来说，原型对比方法将样本分为不同的聚类，将聚类中心作为原型，然后将样本与原型进行对比，以学习时间序列数据的表示。该方法可以通过使用对比损失函数来实现，其中对于每个样本，网络将学习将其与其他样本区分开来。</p> 
<p>原型对比方法引入了原型的概念，使样本可以被分配到有限数量的类别中。该方法利用高级语义信息，鼓励样本在特征空间中呈现聚类分布，而不是均匀分布，这更符合真实数据分布。然而，该方法的主要问题是原型的数量需要预先确定，这仍然需要一些先验信息。</p> 
<p>2.5  专家知识对比法</p> 
<p>专家知识对比方法是一种相对较新的表示学习框架，它可以在对比学习框架中引入先验知识，以帮助模型选择正确的正负样本。例如，在训练过程中，可以选择一个锚点样本和一个正样本，以及一些负样本。然后，网络将学习将锚点样本与正样本相似，并将锚点样本与负样本区分开来。这可以通过使用对比损失函数来实现，其中对于每个样本，网络将学习将其与其他样本区分开来，并将其分配到正确的正负样本中。</p> 
<p>专家知识对比方法的特点是可以将领域专家的先验知识或信息引入深度神经网络中，以指导正负样本的选择或相似度的测量。其主要优点在于能够准确选择正负样本。然而，其局限性在于需要提供可靠的先验知识。在大多数情况下，为时间序列数据获取可靠的先验知识并不容易。不正确或误导性的知识可能会导致偏见的表示。</p> 
<p>3  基于对抗的方法</p> 
<p>基于对抗的方法利用生成对抗网络（GAN）构建预文本任务。GAN包含一个生成器G和一个判别器D。生成器G负责生成类似于真实数据的合成数据，而判别器D负责确定生成的数据是真实数据还是合成数据。因此，生成器的目标是最大化判别器的决策失败率，而判别器的目标是最小化其失败率。生成器G和判别器D是一种相互博弈的关系，因此学习目标是通过最小化损失函数L来优化生成器和判别器的性能。</p> 
<p></p> 
<p class="img-center"><img alt="图片" height="46" src="https://images2.imgbox.com/e7/8b/0a2iOpLR_o.png" width="733"></p> 
<p>根据最终任务，现有的基于对抗性的表示学习方法可以分为<strong>时间序列生成和插补，</strong>以及<strong>辅助表示增强</strong>。图5展示了基于对抗性的时间序列自监督学习的示意图。</p> 
<p></p> 
<p class="img-center"><img alt="图片" height="611" src="https://images2.imgbox.com/ca/a4/LCqyUUdh_o.png" width="529"></p> 
<p>图5：基于对抗性的时间序列自监督学习的三个类别</p> 
<p>3.1  时间序列生成和插补</p> 
<p>在时间序列生成方面，使用Transformer代替RNN可以更好地处理长期依赖关系和提高效率。Li等人提出了Context-FID，这是一种新的评估生成序列质量的度量标准。Li等人还探索了具有不规则时空关系的时间序列数据的生成，并提出了TTS-GAN，该模型使用Transformer代替RNN来构建鉴别器和生成器，并将时间序列数据视为高度为1的图像数据。 </p> 
<p>在时间序列插补方面。Luo等人将缺失值填充视为数据生成任务，并使用GAN来学习训练数据集的分布。为了更好地捕捉时间序列的动态特征，他们提出了GRUI模块。此外，还介绍了辅助表示增强的方法，该方法可以提高模型的鲁棒性和泛化能力。</p> 
<p>基于对抗性的方法的优点是可以生成高质量的时间序列样本，并且可以根据不同时间序列数据的季节性和趋势执行填补或生成任务，从而提高结果的连贯性和合理性。此外，已经有许多高效的基于对抗性的方法在图像生成领域得到了应用，这些方法可以被转移和应用于时间序列数据的生成或填补任务。缺点是GAN的训练过程相对复杂，需要在生成器和判别器之间进行权衡，这可能需要更多的训练时间和计算资源，并且可能导致训练不稳定。</p> 
<p>3.2  辅助表示增强</p> 
<p>除了生成和插补任务之外，还可以将基于对抗性的表示学习策略作为额外的辅助学习模块添加到现有的学习框架中，我们将其称为基于对抗性的辅助表示增强。辅助表示增强旨在通过添加基于对抗性的学习策略，来促进模型为下游任务学习更多信息表示。通常定义为：</p> 
<p></p> 
<p class="img-center"><img alt="图片" height="41" src="https://images2.imgbox.com/0d/f0/OPJIQpda_o.png" width="523"></p> 
<p>其中 Lbase 是基本学习目标，Ladv 是附加的基于对抗性的学习目标。需要注意的是，当Ladv不可用时，模型仍然可以从数据中提取表示，因此Ladv被视为辅助学习目标。</p> 
<p>USAD[63]是一个时间序列异常检测框架，包含两个BAE模型，两个BAE分别定义为AE1和AE2。USAD 背后的核心思想是通过两个 BAE 之间的对抗训练来放大重建误差。在USAD中，AE1被视为生成器，AE2被视为判别器。辅助目标是利用AE2区分真实数据和AE1重构的数据，并训练AE1欺骗AE2，整个过程可以表示为：</p> 
<p></p> 
<p class="img-center"><img alt="图片" height="54" src="https://images2.imgbox.com/d6/ec/kjbEziZP_o.png" width="638"></p> 
<p>其中 W 是实际输入序列。与 USAD 类似，Anoma lyTrans [155] 也使用对抗策略来放大异常的异常分数。但与（30）使用重构误差不同的是，AnomalyTrans 定义了先验关联和级数关联，然后使用 Kulback-Leibler 散度来衡量两个关联的误差。</p> 
<p>DUBCN [156] 和 CRLI [157] 分别用于序列检索和聚类任务。两种方法均采用基于RNN的BAE作为模型，并在基本重建损失中添加基于聚类的损失和基于对抗的损失，即：</p> 
<p></p> 
<p class="img-center"><img alt="图片" height="43" src="https://images2.imgbox.com/e5/ff/zqg1GwyW_o.png" width="537"></p> 
<p>其中，λ1和λ2为辅助目标的权重系数。</p> 
<p>基于对抗性的方法在其他时间序列建模任务中也很有效。例如，在时间序列预测中引入对抗性训练可以提高准确性并捕获长期重复模式，例如 AST [158] 和 ACT [159]。BeatGAN [160]在心电图数据的异常心跳检测任务中引入了对抗性表示学习，并提供了一个可解释的检测框架。在行为数据建模中，Activity2vec[161]使用基于对抗性的训练来建模目标不变性，增强模型在不同行为阶段的表示能力。</p> 
<p>对抗方法可以帮助模型学习更鲁棒的表示，从而提高模型的泛化能力。通过引入对抗性信号，模型可以更好地适应训练数据并抵抗干扰或攻击。然而，在损失函数中引入对抗方法作为正则化项会增加训练过程的复杂性。训练生成器和鉴别器之间的竞争需要仔细平衡，这可能需要更多的训练时间和计算资源。这甚至可能导致训练不稳定。</p> 
<p>4  应用和数据集</p> 
<p>自监督学习（SSL）在各种时间序列任务中都有广泛的应用，例如异常检测、预测、分类和聚类。</p> 
<p>表2：时间序列应用程序和广泛使用的数据集的摘要</p> 
<p></p> 
<p class="img-center"><img alt="图片" height="313" src="https://images2.imgbox.com/20/64/aUcGcUV6_o.png" width="760"></p> 
<p><strong>异常检测。</strong>时间序列异常检测的主要任务是在给定的规范或常见信号的基础上，识别出异常的时间点或异常的时间序列。由于获取异常数据的标签具有挑战性，因此大多数时间序列异常检测方法采用无监督学习框架。在众多建模策略中，基于自回归的预测和基于自编码器的重构是最常用的方法。</p> 
<p><strong>预测</strong>。时间序列预测是一种统计和建模技术，用于对时间序列数据进行分析，以预测未来时间窗口或时间点的值。自回归预测任务也是一种时间序列预测任务。</p> 
<p><strong>分类和聚类。</strong>分类和聚类的任务目标是识别特定时间序列样本所属的真实类别。由于基于对比的自监督学习方法的核心是识别正样本和负样本，因此其是这两个任务的最佳选择。</p> 
<p><strong>综上，基于生成的方法更适合异常检测和预测任务，而基于对比的方法更适合分类和聚类任务。基于对抗性的方法可以在各种任务中发挥作用，但在大多数情况下，它被用作额外的正则化项，以确保模型提取的特征更加稳健且信息丰富。通常，多种自监督方法混合使用是更好的选择。</strong></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/99cb6f2532cdc6698decee3b1e09ab74/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">CSS3:图片边框</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/0cc3aa5023f2bfbdaca6852b15ad1b52/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">Docker搭建镜像仓库Harbor,并且登录使用</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>