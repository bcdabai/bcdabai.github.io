<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>iOS NSMachPort 线程与进程间的通信 - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="iOS NSMachPort 线程与进程间的通信" />
<meta property="og:description" content="原创：http://blog.csdn.net/yxh265/article/details/51483822
iOS线程间的通信 iOS中，两个线程之间要想互相通信，可以使用：NSMachPort 下面是例子
#define kMsg1 100 #define kMsg2 101 - (void)viewDidLoad { [super viewDidLoad]; //1. 创建主线程的port // 子线程通过此端口发送消息给主线程 NSPort *myPort = [NSMachPort port]; //2. 设置port的代理回调对象 myPort.delegate = self; //3. 把port加入runloop，接收port消息 [[NSRunLoop currentRunLoop] addPort:myPort forMode:NSDefaultRunLoopMode]; NSLog(@&#34;---myport %@&#34;, myPort); //4. 启动次线程,并传入主线程的port MyWorkerClass *work = [[MyWorkerClass alloc] init]; [NSThread detachNewThreadSelector:@selector(launchThreadWithPort:) toTarget:work withObject:myPort]; } - (void)handlePortMessage:(NSMessagePort*)message{ NSLog(@&#34;接到子线程传递的消息！%@&#34;,message); //1. 消息id NSUInteger msgId = [[message valueForKeyPath:@&#34;msgid&#34;] integerValue]; //2. 当前主线程的port NSPort *localPort = [message valueForKeyPath:@&#34;localPort&#34;]; //3." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/d0e4158e660f44ef4aed01195b0f8c81/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2018-07-25T11:20:22+08:00" />
<meta property="article:modified_time" content="2018-07-25T11:20:22+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">iOS NSMachPort 线程与进程间的通信</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p>原创：<a href="http://blog.csdn.net/yxh265/article/details/51483822">http://blog.csdn.net/yxh265/article/details/51483822</a></p> 
<h4 id="ios线程间的通信"><a name="t0"></a>iOS线程间的通信</h4> 
<p>iOS中，两个线程之间要想互相通信，可以使用：NSMachPort <br> 下面是例子</p> 
<pre class="has"><code>#define kMsg1 100
#define kMsg2 101

- (void)viewDidLoad {
    [super viewDidLoad];

    //1. 创建主线程的port
    // 子线程通过此端口发送消息给主线程
    NSPort *myPort = [NSMachPort port];

    //2. 设置port的代理回调对象
    myPort.delegate = self;

    //3. 把port加入runloop，接收port消息
    [[NSRunLoop currentRunLoop] addPort:myPort forMode:NSDefaultRunLoopMode];

    NSLog(@"---myport %@", myPort);
    //4. 启动次线程,并传入主线程的port
    MyWorkerClass *work = [[MyWorkerClass alloc] init];
    [NSThread detachNewThreadSelector:@selector(launchThreadWithPort:)
                             toTarget:work
                           withObject:myPort];
}
- (void)handlePortMessage:(NSMessagePort*)message{

    NSLog(@"接到子线程传递的消息！%@",message);

    //1. 消息id
    NSUInteger msgId = [[message valueForKeyPath:@"msgid"] integerValue];

    //2. 当前主线程的port
    NSPort *localPort = [message valueForKeyPath:@"localPort"];

    //3. 接收到消息的port（来自其他线程）
    NSPort *remotePort = [message valueForKeyPath:@"remotePort"];

    if (msgId == kMsg1)
    {
        //向子线的port发送消息
        [remotePort sendBeforeDate:[NSDate date]
                             msgid:kMsg2
                        components:nil
                              from:localPort
                          reserved:0];

    } else if (msgId == kMsg2){
        NSLog(@"操作2....\n");
    }
}</code></pre> 
<ul><li>MyWorkerClass</li></ul> 
<pre class="has"><code>#import "MyWorkerClass.h"

@interface MyWorkerClass() &lt;NSMachPortDelegate&gt; {
    NSPort *remotePort;
    NSPort *myPort;
}
@end

#define kMsg1 100
#define kMsg2 101

@implementation MyWorkerClass


- (void)launchThreadWithPort:(NSPort *)port {

    @autoreleasepool {

        //1. 保存主线程传入的port
        remotePort = port;

        //2. 设置子线程名字
        [[NSThread currentThread] setName:@"MyWorkerClassThread"];

        //3. 开启runloop
        [[NSRunLoop currentRunLoop] run];

        //4. 创建自己port
        myPort = [NSPort port];

        //5.
        myPort.delegate = self;

        //6. 将自己的port添加到runloop
        //作用1、防止runloop执行完毕之后推出
        //作用2、接收主线程发送过来的port消息
        [[NSRunLoop currentRunLoop] addPort:myPort forMode:NSDefaultRunLoopMode];



        //7. 完成向主线程port发送消息
        [self sendPortMessage];


    }
}

/**
 *   完成向主线程发送port消息
 */
- (void)sendPortMessage {

    NSMutableArray *array  =[[NSMutableArray alloc]initWithArray:@[@"1",@"2"]];
    //发送消息到主线程，操作1
    [remotePort sendBeforeDate:[NSDate date]
                         msgid:kMsg1
                    components:array
                          from:myPort
                      reserved:0];

    //发送消息到主线程，操作2
    //    [remotePort sendBeforeDate:[NSDate date]
    //                         msgid:kMsg2
    //                    components:nil
    //                          from:myPort
    //                      reserved:0];
}


#pragma mark - NSPortDelegate

/**
 *  接收到主线程port消息
 */
- (void)handlePortMessage:(NSPortMessage *)message
{
    NSLog(@"接收到父线程的消息...\n");

    //    unsigned int msgid = [message msgid];
    //    NSPort* distantPort = nil;
    //
    //    if (msgid == kCheckinMessage)
    //    {
    //        distantPort = [message sendPort];
    //
    //    }
    //    else if(msgid == kExitMessage)
    //    {
    //        CFRunLoopStop((__bridge CFRunLoopRef)[NSRunLoop currentRunLoop]);
    //    }
}

@end</code></pre> 
<ul><li>以上就可以完成一个线程间的数据通信。</li></ul> 
<h4 id="ios进程间的通信越狱时用到"><a name="t1"></a>iOS进程间的通信（越狱时用到）</h4> 
<p>先创建一个命令行工程，建一个简单的子项目。名为：taskchild</p> 
<pre class="has"><code>#import &lt;UIKit/UIKit.h&gt;
#import &lt;Foundation/Foundation.h&gt;
#include &lt;stdio.h&gt;


int main (int argc, const char * argv[])
{

    NSLog(@"receive value arg %d %s %s", argc, argv[0], argv[1]);

    sleep(10);

    // insert code here...
    printf("Hello, World!\n");
    NSLog(@"Hello, World");
    return 0;
}
</code></pre> 
<ul><li>再创建一个有界面的主项目。进程通信部分代码。需要引用头文件：NSTask.h见下面的引用</li></ul> 
<pre class="has"><code>    NSString* string = [[NSBundle mainBundle] pathForResource:@"taskchild" ofType:nil];//taskchild是所要启动的名字二进制文件名,上面建的子项目。
    NSLog(@"%@",string);

    NSTask *task;
    task = [[NSTask alloc ]init];
    [task setLaunchPath:string];

    NSLog(@"This is NSTask with ping command......\n");
    NSArray *arguments;
    arguments = [NSArray arrayWithObjects:@"22", nil];
    [task setArguments:arguments];

    NSPipe *pipe;
    pipe = [NSPipe pipe];
    [task setStandardOutput:pipe];

    NSFileHandle *file;
    file = [pipe fileHandleForReading];

    [task launch];

    NSData *data;
    data = [file readDataToEndOfFile];

    string = [[NSString alloc]initWithData:data encoding:NSUTF8StringEncoding];

    NSLog(@"get child value :%@",string);</code></pre> 
<h4 id="引用"><a name="t2"></a>引用</h4> 
<p><a href="https://github.com/sbxfc/RunLoops">RunLoops</a> <br><a href="https://github.com/obaby/NSTask-4-iOS">NSTask-4-iOS</a></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/2ed3c4dd819a87deeb49908598566f42/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">【Mybatis】开启自动驼峰命名规则映射</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/5fab8d2534f25930e4e3f03824e8aec2/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">leetcode 338. Counting Bits</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>