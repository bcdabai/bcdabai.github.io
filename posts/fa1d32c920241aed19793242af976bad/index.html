<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Python网络数据采集——正则表达式 - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Python网络数据采集——正则表达式" />
<meta property="og:description" content="计算机科学里曾经有个笑话：“如果你有一个问题打算用正则表达式（regular expression，通常简写regex）来解决，那么就是两个问题了。”
regex——你值得拥有！ 学正则表达式不一定只会用在爬虫，当然爬虫也未必会用到正则表达式（能找到捷径就不需要啊），学正则可以处理一些杂乱的文本，从杂乱的信息中找出些许规律性并批量过滤出自己想要的东东。可以这么说，regex——你值得拥有！之所以叫正则表达式，是因为它们可以识别正则字符串（regular string）；也就是说，它们可以这么定义：“如果你给我的字符串符合规则，我就返回它”，或者是“如果字符串不符合规则，我就忽略它”。这在要求快速浏览大文档，以查找像电话号码和邮箱地址之类的字符串时是非常方便的。 一句实话——正则表达式上手快，而且运行很快，通过一些简单的例子就可以轻松地学会。
1. 元字符
2. 正则表达式在实际中的一个经典应用
3. 正则表达式在线生成工具
4. Python的re模块
1. 元字符 普通字符只能匹配与自身相同的字符，而正则表达式中还规定了一系列的特殊字符，这些特殊字符具有特殊的语义，如下字符:
^ $ . * &#43; ? = ! : | \ / ( ) [ ] { }
如果要匹配这些具有特殊含义的字符是普通字符，需要在这些字符前面加反斜杠()进行转义（如匹配普通字符！，\！即可）。正是这些特殊字符的存在，才使正则表达式具有强大的功能。由于它们是构造各种匹配复杂文本的正则表达式的基本字符，所以被称作元字符。
1.1 单个字符匹配的元字符 常见的元字符,主要是针对单个字符匹配的：
字符说明.匹配除 \n 以外的任何字符（注意元字符是小数点）。[abcd]匹配 abcd 之中的任意一个字符[a-k]匹配 a 到 k 之间的任意一个字符[^abc]不与 abc之中的任意一个字符匹配\w匹配大小写英文字符及数字 0 到 9 之间的任意一个及下划线，相当于 [a-zA-Z0-9_]\W不匹配大小写英文字符及数字 0 到 9 之间的任意一个，相当于 [^a-zA-Z0-9_]\s匹配任何空白字符，相当于 [ \f\n\r\t\v]\S匹配任何非空白字符，相当于 [^\s]\d匹配任何 0 到 9 之间的单个数字，相当于 [0-9]\D不匹配任何 0 到 9 之间的单个数字，相当于 [^0-9][\u4e00-\u9fa5]匹配任意单个汉字（这里用的是 Unicode 编码表示汉字的 ) 1." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/fa1d32c920241aed19793242af976bad/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2017-08-23T11:58:44+08:00" />
<meta property="article:modified_time" content="2017-08-23T11:58:44+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Python网络数据采集——正则表达式</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-light">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p>计算机科学里曾经有个笑话：“如果你有一个问题打算用正则表达式（regular expression，通常简写regex）来解决，那么就是两个问题了。”</p> 
<hr> 
<pre><code>                        regex——你值得拥有！
</code></pre> 
<p>学正则表达式不一定只会用在爬虫，当然爬虫也未必会用到正则表达式（能找到捷径就不需要啊），学正则可以处理一些杂乱的文本，从杂乱的信息中找出些许规律性并批量过滤出自己想要的东东。可以这么说，regex——你值得拥有！之所以叫正则表达式，是因为它们可以识别正则字符串（regular string）；也就是说，它们可以这么定义：“如果你给我的字符串符合规则，我就返回它”，或者是“如果字符串不符合规则，我就忽略它”。这在要求快速浏览大文档，以查找像电话号码和邮箱地址之类的字符串时是非常方便的。 <br> 一句实话——正则表达式上手快，而且运行很快，通过一些简单的例子就可以轻松地学会。</p> 
<hr> 
<p><strong><em>1. 元字符</em></strong></p> 
<p><strong><em>2. 正则表达式在实际中的一个经典应用</em></strong></p> 
<p><strong><em>3. 正则表达式在线生成工具</em></strong></p> 
<p><strong><em>4. Python的re模块</em></strong></p> 
<hr> 
<h2 id="1-元字符">1. 元字符</h2> 
<p>普通字符只能匹配与自身相同的字符，而正则表达式中还规定了一系列的特殊字符，这些特殊字符具有特殊的语义，如下字符:</p> 
<p><code>^ $ . * + ? = ! : | \ / ( ) [ ] { }</code></p> 
<p>如果要匹配这些具有特殊含义的字符是普通字符，需要在这些字符前面加反斜杠()进行转义（如匹配普通字符！，\！即可）。正是这些特殊字符的存在，才使正则表达式具有强大的功能。由于它们是构造各种匹配复杂文本的正则表达式的基本字符，所以被称作元字符。</p> 
<h3 id="11-单个字符匹配的元字符">1.1 单个字符匹配的元字符</h3> 
<p>常见的元字符,主要是针对单个字符匹配的：</p> 
<hr> 
<table><thead><tr><th align="center">字符</th><th align="left">说明</th></tr></thead><tbody><tr><td align="center">.</td><td align="left">匹配除 \n 以外的任何字符（注意元字符是小数点）。</td></tr><tr><td align="center">[abcd]</td><td align="left">匹配 abcd 之中的任意一个字符</td></tr><tr><td align="center">[a-k]</td><td align="left">匹配 a 到 k 之间的任意一个字符</td></tr><tr><td align="center">[^abc]</td><td align="left">不与 abc之中的任意一个字符匹配</td></tr><tr><td align="center">\w</td><td align="left">匹配大小写英文字符及数字 0 到 9 之间的任意一个及下划线，相当于 [a-zA-Z0-9_]</td></tr><tr><td align="center">\W</td><td align="left">不匹配大小写英文字符及数字 0 到 9 之间的任意一个，相当于 [^a-zA-Z0-9_]</td></tr><tr><td align="center">\s</td><td align="left">匹配任何空白字符，相当于 [ \f\n\r\t\v]</td></tr><tr><td align="center">\S</td><td align="left">匹配任何非空白字符，相当于 [^\s]</td></tr><tr><td align="center">\d</td><td align="left">匹配任何 0 到 9 之间的单个数字，相当于 [0-9]</td></tr><tr><td align="center">\D</td><td align="left">不匹配任何 0 到 9 之间的单个数字，相当于 [^0-9]</td></tr><tr><td align="center">[\u4e00-\u9fa5]</td><td align="left">匹配任意单个汉字（这里用的是 Unicode 编码表示汉字的 )</td></tr></tbody></table> 
<h3 id="12-限定符">1.2 限定符</h3> 
<p>要想同时匹配多个字符，还需要借助限定符：</p> 
<hr> 
<table><thead><tr><th align="center">字符</th><th align="left">说明</th></tr></thead><tbody><tr><td align="center">*</td><td align="left">匹配 0 到多个元字符，相当于 {0,}</td></tr><tr><td align="center">?</td><td align="left">匹配 0 到 1 个元字符，相当于 {0,1}</td></tr><tr><td align="center">{n}</td><td align="left">匹配 n 个元字符</td></tr><tr><td align="center">{n,}</td><td align="left">匹配至少 n 个元字符</td></tr><tr><td align="center">{n,m}</td><td align="left">匹配 n 到 m 个元字符</td></tr><tr><td align="center">+</td><td align="left">匹配至少 1 个元字符，相当于 {1,}</td></tr><tr><td align="center">\b</td><td align="left">匹配单词边界</td></tr><tr><td align="center">^</td><td align="left">字符串必须以指定的字符开始</td></tr><tr><td align="center">$</td><td align="left">字符串必须以指定的字符结束</td></tr></tbody></table> 
<h3 id="13-元字符汇总">1.3 元字符汇总</h3> 
<table><thead><tr><th align="center">字符</th><th align="left">说明</th></tr></thead><tbody><tr><td align="center">\</td><td align="left">将下一字符标记为特殊字符、文本、反向引用或八进制转义符。例如，“n”匹配字符“n”。“\n”匹配换行符。序列“\\”匹配“\”，“\(”匹配“(”。</td></tr><tr><td align="center">^</td><td align="left">匹配输入字符串开始的位置。如果设置了 RegExp 对象的 Multiline 属性，^ 还会与“\n”或“\r”之后的位置匹配。</td></tr><tr><td align="center">$</td><td align="left">匹配输入字符串结尾的位置。如果设置了 RegExp 对象的 Multiline 属性，$ 还会与“\n”或“\r”之前的位置匹配。</td></tr><tr><td align="center">*</td><td align="left">零次或多次匹配前面的字符或子表达式。例如，zo* 匹配“z”和“zoo”。* 等效于 {0,}。</td></tr><tr><td align="center">+</td><td align="left">一次或多次匹配前面的字符或子表达式。例如，“zo+”与“zo”和“zoo”匹配，但与“z”不匹配。+ 等效于 {1,}。</td></tr><tr><td align="center">?</td><td align="left">零次或一次匹配前面的字符或子表达式。例如，“do(es)?”匹配“do”或“does”中的“do”。? 等效于 {0,1}。</td></tr><tr><td align="center">{n}</td><td align="left">n 是非负整数。正好匹配 n 次。例如，“o{2}”与“Bob”中的“o”不匹配，但与“food”中的两个“o”匹配。</td></tr><tr><td align="center">{n,}</td><td align="left">n 是非负整数。至少匹配 n 次。例如，“o{2,}”不匹配“Bob”中的“o”，而匹配“foooood”中的所有 o。“o{1,}”等效于“o+”。“o{0,}”等效于“o*”。</td></tr><tr><td align="center">{n,m}</td><td align="left">M 和 n 是非负整数，其中 n &lt;= m。匹配至少 n 次，至多 m 次。例如，“o{1,3}”匹配“fooooood”中的头三个 o。’o{0,1}’ 等效于 ‘o?’。注意：您不能将空格插入逗号和数字之间。</td></tr><tr><td align="center">?</td><td align="left">当此字符紧随任何其他限定符（*、+、?、{n}、{n,}、{n,m}）之后时，匹配模式是“非贪心的”。“非贪心的”模式匹配搜索到的、尽可能短的字符串，而默认的“贪心的”模式匹配搜索到的、尽可能长的字符串。例如，在字符串“oooo”中，“o+?”只匹配单个“o”，而“o+”匹配所有“o”。</td></tr><tr><td align="center">.</td><td align="left">匹配除“\n”之外的任何单个字符。若要匹配包括“\n”在内的任意字符，请使用诸如“[\s\S]”之类的模式。</td></tr><tr><td align="center">(pattern)</td><td align="left">匹配 pattern 并捕获该匹配的子表达式。可以使用 <span class="MathJax_Preview"></span><span class="MathJax" id="MathJax-Element-213-Frame" style=""> 
      
      <span class="math" id="MathJax-Span-5942" style="width: 2.217em; display: inline-block;"><span style="display: inline-block; position: relative; width: 1.789em; height: 0px; font-size: 123%;"><span style="position: absolute; clip: rect(1.448em, 1000em, 2.461em, -0.449em); top: -2.276em; left: 0em;"><span class="mrow" id="MathJax-Span-5943"><span class="mn" id="MathJax-Span-5944" style="font-family: MathJax_Main;">0</span><span class="mo" id="MathJax-Span-5945" style="font-family: MathJax_Main; padding-left: 0.167em;">…</span></span><span style="display: inline-block; width: 0px; height: 2.276em;"></span></span></span><span style="border-left: 0em solid; display: inline-block; overflow: hidden; width: 0px; height: 0.98em; vertical-align: -0.094em;"></span></span> 
     </span><script type="math/tex" id="MathJax-Element-213">0…</script>9 属性从结果“匹配”集合中检索捕获的匹配。若要匹配括号字符 ( )，请使用“(”或者“)”。</td></tr><tr><td align="center">(?:pattern)</td><td align="left">匹配 pattern 但不捕获该匹配的子表达式，即它是一个非捕获匹配，不存储供以后使用的匹配。这对于用“or”字符 (|) 组合模式部件的情况很有用。例如，’industr(?:y|ies) 是比 ‘industry|industries’ 更经济的表达式。</td></tr><tr><td align="center">(?=pattern)</td><td align="left">执行正向预测先行搜索的子表达式，该表达式匹配处于匹配 pattern 的字符串的起始点的字符串。它是一个非捕获匹配，即不能捕获供以后使用的匹配。例如，’Windows (?=95|98|NT|2000)’ 匹配“Windows 2000”中的“Windows”，但不匹配“Windows 3.1”中的“Windows”。预测先行不占用字符，即发生匹配后，下一匹配的搜索紧随上一匹配之后，而不是在组成预测先行的字符后。</td></tr><tr><td align="center">(?!pattern)</td><td align="left">执行反向预测先行搜索的子表达式，该表达式匹配不处于匹配 pattern 的字符串的起始点的搜索字符串。它是一个非捕获匹配，即不能捕获供以后使用的匹配。例如，’Windows (?!95|98|NT|2000)’ 匹配“Windows 3.1”中的 “Windows”，但不匹配“Windows 2000”中的“Windows”。预测先行不占用字符，即发生匹配后，下一匹配的搜索紧随上一匹配之后，而不是在组成预测先行的字符后。</td></tr><tr><td align="center">x|y</td><td align="left">匹配 x 或 y。例如，’z|food’ 匹配“z”或“food”。’(z|f)ood’ 匹配“zood”或“food”。</td></tr><tr><td align="center">[xyz]</td><td align="left">字符集。匹配包含的任一字符。例如，“[abc]”匹配“plain”中的“a”。</td></tr><tr><td align="center">[^xyz]</td><td align="left">反向字符集。匹配未包含的任何字符。例如，“[^abc]”匹配“plain”中的“p”。</td></tr><tr><td align="center">[a-z]</td><td align="left">字符范围。匹配指定范围内的任何字符。例如，“[a-z]”匹配“a”到“z”范围内的任何小写字母。</td></tr><tr><td align="center">[^a-z]</td><td align="left">反向范围字符。匹配不在指定的范围内的任何字符。例如，“[^a-z]”匹配任何不在“a”到“z”范围内的任何字符。</td></tr><tr><td align="center">\b</td><td align="left">匹配一个字边界，即字与空格间的位置。例如，“er\b”匹配“never”中的“er”，但不匹配“verb”中的“er”。</td></tr><tr><td align="center">\B</td><td align="left">非字边界匹配。“er\B”匹配“verb”中的“er”，但不匹配“never”中的“er”。</td></tr><tr><td align="center">\cx</td><td align="left">匹配 x 指示的控制字符。例如，\cM 匹配 Control-M 或回车符。x 的值必须在 A-Z 或 a-z 之间。如果不是这样，则假定 c 就是“c”字符本身。</td></tr><tr><td align="center">\d</td><td align="left">数字字符匹配。等效于 [0-9]。</td></tr><tr><td align="center">\D</td><td align="left">非数字字符匹配。等效于 [^0-9]。</td></tr><tr><td align="center">\f</td><td align="left">换页符匹配。等效于 \x0c 和 \cL。</td></tr><tr><td align="center">\n</td><td align="left">换行符匹配。等效于 \x0a 和 \cJ。</td></tr><tr><td align="center">\r</td><td align="left">匹配一个回车符。等效于 \x0d 和 \cM。</td></tr><tr><td align="center">\s</td><td align="left">匹配任何空白字符，包括空格、制表符、换页符等。与 [ \f\n\r\t\v] 等效。</td></tr><tr><td align="center">\S</td><td align="left">匹配任何非空白字符。与 [^ \f\n\r\t\v] 等效。</td></tr><tr><td align="center">\t</td><td align="left">制表符匹配。与 \x09 和 \cI 等效。</td></tr><tr><td align="center">\v</td><td align="left">垂直制表符匹配。与 \x0b 和 \cK 等效。</td></tr><tr><td align="center">\w</td><td align="left">匹配任何字类字符，包括下划线。与“[A-Za-z0-9_]”等效。</td></tr><tr><td align="center">\W</td><td align="left">与任何非单词字符匹配。与“[^A-Za-z0-9_]”等效。</td></tr><tr><td align="center">\xn</td><td align="left">匹配 n，此处的 n 是一个十六进制转义码。十六进制转义码必须正好是两位数长。例如，“\x41”匹配“A”。“\x041”与“\x04”&amp;“1”等效。允许在正则表达式中使用 ASCII 代码。</td></tr><tr><td align="center">\num</td><td align="left">匹配 num，此处的 num 是一个正整数。到捕获匹配的反向引用。例如，“(.)\1”匹配两个连续的相同字符。</td></tr><tr><td align="center">\n</td><td align="left">标识一个八进制转义码或反向引用。如果 \n 前面至少有 n 个捕获子表达式，那么 n 是反向引用。否则，如果 n 是八进制数 (0-7)，那么 n 是八进制转义码。</td></tr><tr><td align="center">\nm</td><td align="left">标识一个八进制转义码或反向引用。如果 \nm 前面至少有 nm 个捕获子表达式，那么 nm 是反向引用。如果 \nm 前面至少有 n 个捕获，则 n 是反向引用，后面跟有字符m。如果两种前面的情况都不存在，则 \nm 匹配八进制值 nm，其中 n 和 m 是八进制数字 (0-7)。</td></tr><tr><td align="center">\nml</td><td align="left">当 n 是八进制数 (0-3)，m 和 l 是八进制数 (0-7) 时，匹配八进制转义码 nml。</td></tr><tr><td align="center">\un</td><td align="left">匹配 n，其中 n 是以四位十六进制数表示的 Unicode 字符。例如，\u00A9 匹配版权符号 (©)。</td></tr></tbody></table> 
<h2 id="2-正则表达式在实际中的一个经典应用">2. 正则表达式在实际中的一个经典应用</h2> 
<p>正则表达式在实际中的一个经典应用是识别邮箱地址。虽然不同邮箱服务器的邮箱地址的具体规则不尽相同，但是我们还是可以创建几条通用规则。每条规则对应的正则表达式如下表：</p> 
<table><thead><tr><th align="left">规则</th><th align="left">正则表达式</th></tr></thead><tbody><tr><td align="left">1). 邮箱地址的第一部分至少包括一种内容：大写字母、小写字母、数字0~9、点号（.）、加号（+）或下划线（_）</td><td align="left">[A-Za-z0-9._+]+：这个正则表达式简写非常智慧。例如，它用“A-Z”表示“任意A~Z 的大写字母”。把所有可能的序列和符号放在中括号（不是小括号）里表示“括号中的符号里任何一个”。要注意后面的加号，它表示“这些符号都可以出现多次，且至少出现1 次”</td></tr><tr><td align="left">2). 之后，邮箱地址会包含一个@ 符号</td><td align="left">@：这个符号很直接。@ 符号必须出现在中间位置，有且仅有1 次</td></tr><tr><td align="left">3). 在符合@ 之后，邮箱地址还必须至少包含一个大写或小写字母</td><td align="left">[A-Za-z]+：可能只在域名的前半部分、符号@ 后面用字母。而且，至少有一个字母</td></tr><tr><td align="left">4). 之后跟一个点号（.）</td><td align="left">.：在域名前必须有一个点号（.）</td></tr><tr><td align="left">5). 最后邮箱地址用com、org、edu、net 结尾（实际上，顶级域名有很多种可能，但是作为示例演示这四个后缀够用了）。</td><td align="left">(com|org|edu|net)：这样列出了邮箱地址中可能出现在点号之后的字母序列</td></tr></tbody></table> 
<p>把上面的规则连接起来，就获得了完整的正则表达式：</p> 
<pre class="prettyprint"><code class=" hljs lasso"><span class="hljs-preprocessor">[</span>A<span class="hljs-attribute">-Za</span><span class="hljs-attribute">-z0</span><span class="hljs-subst">-</span><span class="hljs-number">9</span><span class="hljs-subst">\</span><span class="hljs-built_in">.</span>_<span class="hljs-subst">+</span><span class="hljs-preprocessor">]</span><span class="hljs-markup">+@</span><span class="hljs-preprocessor">[</span>A<span class="hljs-attribute">-Za</span><span class="hljs-attribute">-z</span><span class="hljs-preprocessor">]</span><span class="hljs-markup">+\.(com|org|edu|net)</span></code></pre> 
<p>其他匹配用户名、密码、IP 地址等也类似。</p> 
<h2 id="3-正则表达式在线工具">3. 正则表达式在线工具</h2> 
<p>有很多正则表达式在线工具，下面列举几个：</p> 
<p><a href="http://tool.oschina.net/regex/" rel="nofollow noopener noreferrer" target="_blank">http://tool.oschina.net/regex/</a></p> 
<p><a href="http://tool.chinaz.com/regex/" rel="nofollow noopener noreferrer" target="_blank">http://tool.chinaz.com/regex/</a></p> 
<p><a href="http://www.jb51.net/tools/zhengze.htm" rel="nofollow noopener noreferrer" target="_blank">http://www.jb51.net/tools/zhengze.htm</a></p> 
<p><a href="http://www.sojson.com/regex/generate" rel="nofollow noopener noreferrer" target="_blank">http://www.sojson.com/regex/generate</a></p> 
<h2 id="4-python的re模块">4. Python的re模块</h2> 
<p>限于篇幅，只简单讲一下Python中的re模块。</p> 
<pre class="prettyprint"><code class="language-python hljs "><span class="hljs-keyword">import</span> re

<span class="hljs-comment"># 将正则表达式编译成Pattern对象(这样做比不这么做效率高很多)，无法匹配时返回None</span>
<span class="hljs-comment">#pattern = r'hello'#直接这样也是可以的，就是效率太低了</span>
pattern = re.compile(pattern)
mat = pattern.match(world)

<span class="hljs-comment">#match函数</span>
mat = pattern.match(<span class="hljs-string">'hello BOBY!'</span>)</code></pre> 
<p><strong>4.1 match函数</strong>返回的是match对象</p> 
<p><img src="https://images2.imgbox.com/d3/2f/SHCeZlz7_o.jpg" alt="这里写图片描述" title=""></p> 
<p>用<strong>4.2 group函数</strong>得到匹配结果</p> 
<p><img src="https://images2.imgbox.com/ab/43/6ipm7UxL_o.jpg" alt="这里写图片描述" title=""></p> 
<p><strong>4.3 split函数</strong> <br> split(string[, maxsplit]) | re.split(pattern, string[, maxsplit]): <br> 按照能够匹配的子串将string分割后返回列表。maxsplit用于指定最大分割次数，不指定将全部分割。 </p> 
<p><img src="https://images2.imgbox.com/36/68/rYUfWppx_o.jpg" alt="这里写图片描述" title=""></p> 
<p><strong>4.4 indall函数</strong> <br> findall(string[, pos[, endpos]]) | re.findall(pattern, string[, flags]): <br> 搜索string，以列表形式返回全部能匹配的子串。 </p> 
<p><img src="https://images2.imgbox.com/7d/6d/e6rem2H4_o.jpg" alt="这里写图片描述" title=""></p> 
<p><strong>4.5 finditer函数</strong> <br> finditer(string[, pos[, endpos]]) | re.finditer(pattern, string[, flags]): <br> 搜索string，返回一个顺序访问每一个匹配结果（match对象）的迭代器。 </p> 
<p><img src="https://images2.imgbox.com/75/7e/4R4dpUeP_o.jpg" alt="这里写图片描述" title=""></p> 
<p><strong>4.6 sub函数</strong> <br> sub(repl, string[, count]) | re.sub(pattern, repl, string[, count]):使用repl替换string中每一个匹配的子串后返回替换后的字符串。当repl是一个字符串时，可以使用<code>\id</code>或<code>\g&lt;id&gt;</code>、<code>\g&lt;name&gt;</code>引用分组，但不能使用编号0。当repl是一个方法时，这个方法应当只接受一个参数（match对象），并返回一个字符串用于替换（返回的字符串中不能再引用分组）。count用于指定最多替换次数，不指定时全部替换。 </p> 
<p><img src="https://images2.imgbox.com/15/86/iIeBwxU9_o.jpg" alt="这里写图片描述" title=""></p> 
<p><strong>4.7 subn函数</strong> <br> subn(repl, string[, count]) |re.sub(pattern, repl, string[, count]): <br> 返回 (sub(repl, string[, count]), 替换次数)。 </p> 
<p><img src="https://images2.imgbox.com/2c/4f/ZeCjpxnm_o.jpg" alt="这里写图片描述" title=""></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/80336e84b6bc56476cafd8ebac465c46/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">ios禁止网页放大缩小</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/f90192f6d3f4673f4b2ad071832dad3f/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">关于使用Delphi XE10 进行android开发的一些总结</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>