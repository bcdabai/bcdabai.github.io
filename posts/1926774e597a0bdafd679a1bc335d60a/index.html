<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>用OpenSSL编写SSL,TLS程序（1） - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="用OpenSSL编写SSL,TLS程序（1）" />
<meta property="og:description" content="#include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; #include &lt;errno.h&gt; #include &lt;string.h&gt; #include &lt;sys/types.h&gt; #include &lt;netinet/in.h&gt; #include &lt;sys/socket.h&gt; #include &lt;sys/wait.h&gt; #include &lt;unistd.h&gt; #include &lt;arpa/inet.h&gt; #include &lt;openssl/ssl.h&gt; #include &lt;openssl/err.h&gt; #define MAXBUF 1024 /************关于本文档******************************************** *filename: ssl-server.c *purpose: 演示利用 OpenSSL 库进行基于 IP层的 SSL 加密通讯的方法，这是服务器端例子 *wrote by: zhoulifa(zhoulifa@163.com) 周立发(http://zhoulifa.bokee.com) Linux爱好者 Linux知识传播者 SOHO族 开发者 最擅长C语言 *date time:2007-02-02 19:40 *Note: 任何人可以任意复制代码并运用这些文档，当然包括你的商业用途 * 但请遵循GPL *Thanks to:Google *Hope:希望越来越多的人贡献自己的力量，为科学技术发展出力 * 科技站在巨人的肩膀上进步更快！感谢有开源前辈的贡献！ *********************************************************************/ int main(int argc, char **argv) { int sockfd, new_fd; socklen_t len; struct sockaddr_in my_addr, their_addr; unsigned int myport, lisnum; char buf[MAXBUF &#43; 1]; SSL_CTX *ctx; if (argv[1]) myport = atoi(argv[1]); else myport = 7838; if (argv[2]) lisnum = atoi(argv[2]); else lisnum = 2; /* SSL 库初始化 */ SSL_library_init(); /* 载入所有 SSL 算法 */ OpenSSL_add_all_algorithms(); /* 载入所有 SSL 错误消息 */ SSL_load_error_strings(); /* 以 SSL V2 和 V3 标准兼容方式产生一个 SSL_CTX ，即 SSL Content Text */ ctx = SSL_CTX_new(SSLv23_server_method()); /* 也可以用 SSLv2_server_method() 或 SSLv3_server_method() 单独表示 V2 或 V3标准 */ if (ctx == NULL) { ERR_print_errors_fp(stdout); exit(1); } /* 载入用户的数字证书， 此证书用来发送给客户端。 证书里包含有公钥 */ if (SSL_CTX_use_certificate_file(ctx, argv[4], SSL_FILETYPE_PEM) &lt;= 0) { ERR_print_errors_fp(stdout); exit(1); } /* 载入用户私钥 */ if (SSL_CTX_use_PrivateKey_file(ctx, argv[5], SSL_FILETYPE_PEM) &lt;= 0) { ERR_print_errors_fp(stdout); exit(1); } //载入私钥密码，否则终端提示用户手动输入密码 /*或者 #include &lt;openssl/ssl." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/1926774e597a0bdafd679a1bc335d60a/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2017-02-07T16:37:16+08:00" />
<meta property="article:modified_time" content="2017-02-07T16:37:16+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">用OpenSSL编写SSL,TLS程序（1）</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <pre class="prettyprint"><code class=" hljs cpp"><span class="hljs-preprocessor">#include &lt;stdio.h&gt;</span>
<span class="hljs-preprocessor">#include &lt;stdlib.h&gt;</span>
<span class="hljs-preprocessor">#include &lt;errno.h&gt;</span>
<span class="hljs-preprocessor">#include &lt;string.h&gt;</span>
<span class="hljs-preprocessor">#include &lt;sys/types.h&gt;</span>
<span class="hljs-preprocessor">#include &lt;netinet/in.h&gt;</span>
<span class="hljs-preprocessor">#include &lt;sys/socket.h&gt;</span>
<span class="hljs-preprocessor">#include &lt;sys/wait.h&gt;</span>
<span class="hljs-preprocessor">#include &lt;unistd.h&gt;</span>
<span class="hljs-preprocessor">#include &lt;arpa/inet.h&gt;</span>
<span class="hljs-preprocessor">#include &lt;openssl/ssl.h&gt;</span>
<span class="hljs-preprocessor">#include &lt;openssl/err.h&gt;</span>

<span class="hljs-preprocessor">#define MAXBUF 1024</span>
<span class="hljs-comment">/************关于本文档********************************************
*filename: ssl-server.c
*purpose: 演示利用 OpenSSL 库进行基于 IP层的 SSL 加密通讯的方法，这是服务器端例子
*wrote by: zhoulifa(zhoulifa@163.com) 周立发(http://zhoulifa.bokee.com)
Linux爱好者 Linux知识传播者 SOHO族 开发者 最擅长C语言
*date time:2007-02-02 19:40
*Note: 任何人可以任意复制代码并运用这些文档，当然包括你的商业用途
* 但请遵循GPL
*Thanks to:Google
*Hope:希望越来越多的人贡献自己的力量，为科学技术发展出力
* 科技站在巨人的肩膀上进步更快！感谢有开源前辈的贡献！
*********************************************************************/</span>
<span class="hljs-keyword">int</span> main(<span class="hljs-keyword">int</span> argc, <span class="hljs-keyword">char</span> **argv)
{
    <span class="hljs-keyword">int</span> sockfd, new_fd;
    socklen_t len;
    <span class="hljs-keyword">struct</span> sockaddr_in my_addr, their_addr;
    <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> myport, lisnum;
    <span class="hljs-keyword">char</span> buf[MAXBUF + <span class="hljs-number">1</span>];
    SSL_CTX *ctx;

    <span class="hljs-keyword">if</span> (argv[<span class="hljs-number">1</span>])
        myport = atoi(argv[<span class="hljs-number">1</span>]);
    <span class="hljs-keyword">else</span>
        myport = <span class="hljs-number">7838</span>;

    <span class="hljs-keyword">if</span> (argv[<span class="hljs-number">2</span>])
        lisnum = atoi(argv[<span class="hljs-number">2</span>]);
    <span class="hljs-keyword">else</span>
        lisnum = <span class="hljs-number">2</span>;

    <span class="hljs-comment">/* SSL 库初始化 */</span>
    SSL_library_init();
    <span class="hljs-comment">/* 载入所有 SSL 算法 */</span>
    OpenSSL_add_all_algorithms();
    <span class="hljs-comment">/* 载入所有 SSL 错误消息 */</span>
    SSL_load_error_strings();
    <span class="hljs-comment">/* 以 SSL V2 和 V3 标准兼容方式产生一个 SSL_CTX ，即 SSL Content Text */</span>
    ctx = SSL_CTX_new(SSLv23_server_method());
    <span class="hljs-comment">/* 也可以用 SSLv2_server_method() 或 SSLv3_server_method() 单独表示 V2 或 V3标准 */</span>
    <span class="hljs-keyword">if</span> (ctx == NULL) {
        ERR_print_errors_fp(stdout);
        <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);
    }
    <span class="hljs-comment">/* 载入用户的数字证书， 此证书用来发送给客户端。 证书里包含有公钥 */</span>
    <span class="hljs-keyword">if</span> (SSL_CTX_use_certificate_file(ctx, argv[<span class="hljs-number">4</span>], SSL_FILETYPE_PEM) &lt;= <span class="hljs-number">0</span>) {
        ERR_print_errors_fp(stdout);
        <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);
    }
    <span class="hljs-comment">/* 载入用户私钥 */</span>
    <span class="hljs-keyword">if</span> (SSL_CTX_use_PrivateKey_file(ctx, argv[<span class="hljs-number">5</span>], SSL_FILETYPE_PEM) &lt;= <span class="hljs-number">0</span>) {
        ERR_print_errors_fp(stdout);
        <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);
    }
    <span class="hljs-comment">//载入私钥密码，否则终端提示用户手动输入密码  </span>
    <span class="hljs-comment">/*或者
    #include &lt;openssl/ssl.h&gt;
    void SSL_CTX_set_default_passwd_cb(SSL_CTX *ctx, pem_password_cb *cb);
    void SSL_CTX_set_default_passwd_cb_userdata(SSL_CTX *ctx, void *u);
    int pem_passwd_cb(char *buf, int size, int rwflag, void *userdata);

    int pem_passwd_cb(char *buf, int size, int rwflag, void *password)
    {
        strncpy(buf, (char *)(password), size);
        buf[size - 1] = '\0';
        return(strlen(buf));
    }
    */</span>
    SSL_CTX_set_default_passwd_cb_userdata(ctx, “<span class="hljs-number">123456</span>”);



    <span class="hljs-comment">/* 检查用户私钥是否正确 */</span>
    <span class="hljs-keyword">if</span> (!SSL_CTX_check_private_key(ctx)) {
        ERR_print_errors_fp(stdout);
        <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);
    }

    <span class="hljs-comment">/* 开启一个 socket 监听 */</span>
    <span class="hljs-keyword">if</span> ((sockfd = socket(PF_INET, SOCK_STREAM, <span class="hljs-number">0</span>)) == -<span class="hljs-number">1</span>) {
        perror(<span class="hljs-string">"socket"</span>);
        <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);
    } <span class="hljs-keyword">else</span>
        <span class="hljs-built_in">printf</span>(<span class="hljs-string">"socket created\n"</span>);

    bzero(&amp;my_addr, <span class="hljs-keyword">sizeof</span>(my_addr));
    my_addr.sin_family = PF_INET;
    my_addr.sin_port = htons(myport);
    <span class="hljs-keyword">if</span> (argv[<span class="hljs-number">3</span>])
        my_addr.sin_addr.s_addr = inet_addr(argv[<span class="hljs-number">3</span>]);
    <span class="hljs-keyword">else</span>
        my_addr.sin_addr.s_addr = INADDR_ANY;

    <span class="hljs-keyword">if</span> (bind(sockfd, (<span class="hljs-keyword">struct</span> sockaddr *) &amp;my_addr, <span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">struct</span> sockaddr))
        == -<span class="hljs-number">1</span>) {
        perror(<span class="hljs-string">"bind"</span>);
        <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);
    } <span class="hljs-keyword">else</span>
        <span class="hljs-built_in">printf</span>(<span class="hljs-string">"binded\n"</span>);

    <span class="hljs-keyword">if</span> (listen(sockfd, lisnum) == -<span class="hljs-number">1</span>) {
        perror(<span class="hljs-string">"listen"</span>);
        <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);
    } <span class="hljs-keyword">else</span>
        <span class="hljs-built_in">printf</span>(<span class="hljs-string">"begin listen\n"</span>);

    <span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>) {
        SSL *ssl;
        len = <span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">struct</span> sockaddr);
        <span class="hljs-comment">/* 等待客户端连上来 */</span>
        <span class="hljs-keyword">if</span> ((new_fd =
             accept(sockfd, (<span class="hljs-keyword">struct</span> sockaddr *) &amp;their_addr,
                    &amp;len)) == -<span class="hljs-number">1</span>) {
            perror(<span class="hljs-string">"accept"</span>);
            <span class="hljs-built_in">exit</span>(errno);
        } <span class="hljs-keyword">else</span>
            <span class="hljs-built_in">printf</span>(<span class="hljs-string">"server: got connection from %s, port %d, socket %d\n"</span>,
                   inet_ntoa(their_addr.sin_addr),
                   ntohs(their_addr.sin_port), new_fd);

        <span class="hljs-comment">/* 基于 ctx 产生一个新的 SSL */</span>
        ssl = SSL_new(ctx);
        <span class="hljs-comment">/* 将连接用户的 socket 加入到 SSL */</span>
        SSL_set_fd(ssl, new_fd);
        <span class="hljs-comment">/* 建立 SSL 连接 */</span>
        <span class="hljs-keyword">if</span> (SSL_accept(ssl) == -<span class="hljs-number">1</span>) {
            perror(<span class="hljs-string">"accept"</span>);
            close(new_fd);
            <span class="hljs-keyword">break</span>;
        }

        <span class="hljs-comment">/* 开始处理每个新连接上的数据收发 */</span>
        bzero(buf, MAXBUF + <span class="hljs-number">1</span>);
        <span class="hljs-built_in">strcpy</span>(buf, <span class="hljs-string">"server-&gt;client"</span>);
        <span class="hljs-comment">/* 发消息给客户端 */</span>
        len = SSL_write(ssl, buf, <span class="hljs-built_in">strlen</span>(buf));

        <span class="hljs-keyword">if</span> (len &lt;= <span class="hljs-number">0</span>) {
            <span class="hljs-built_in">printf</span>
                (<span class="hljs-string">"消息'%s'发送失败！错误代码是%d，错误信息是'%s'\n"</span>,
                 buf, errno, strerror(errno));
            <span class="hljs-keyword">goto</span> finish;
        } <span class="hljs-keyword">else</span>
            <span class="hljs-built_in">printf</span>(<span class="hljs-string">"消息'%s'发送成功，共发送了%d个字节！\n"</span>,
                   buf, len);

        bzero(buf, MAXBUF + <span class="hljs-number">1</span>);
        <span class="hljs-comment">/* 接收客户端的消息 */</span>
        len = SSL_read(ssl, buf, MAXBUF);
        <span class="hljs-keyword">if</span> (len &gt; <span class="hljs-number">0</span>)
            <span class="hljs-built_in">printf</span>(<span class="hljs-string">"接收消息成功:'%s'，共%d个字节的数据\n"</span>,
                   buf, len);
        <span class="hljs-keyword">else</span>
            <span class="hljs-built_in">printf</span>
                (<span class="hljs-string">"消息接收失败！错误代码是%d，错误信息是'%s'\n"</span>,
                 errno, strerror(errno));
        <span class="hljs-comment">/* 处理每个新连接上的数据收发结束 */</span>
      finish:
        <span class="hljs-comment">/* 关闭 SSL 连接 */</span>
        SSL_shutdown(ssl);
        <span class="hljs-comment">/* 释放 SSL */</span>
        SSL_free(ssl);
        <span class="hljs-comment">/* 关闭 socket */</span>
        close(new_fd);
    }

    <span class="hljs-comment">/* 关闭监听的 socket */</span>
    close(sockfd);
    <span class="hljs-comment">/* 释放 CTX */</span>
    SSL_CTX_free(ctx);
    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}
</code></pre> 
<pre class="prettyprint"><code class=" hljs cpp"><span class="hljs-preprocessor">#include &lt;stdio.h&gt;</span>
<span class="hljs-preprocessor">#include &lt;string.h&gt;</span>
<span class="hljs-preprocessor">#include &lt;errno.h&gt;</span>
<span class="hljs-preprocessor">#include &lt;sys/socket.h&gt;</span>
<span class="hljs-preprocessor">#include &lt;resolv.h&gt;</span>
<span class="hljs-preprocessor">#include &lt;stdlib.h&gt;</span>
<span class="hljs-preprocessor">#include &lt;netinet/in.h&gt;</span>
<span class="hljs-preprocessor">#include &lt;arpa/inet.h&gt;</span>
<span class="hljs-preprocessor">#include &lt;unistd.h&gt;</span>
<span class="hljs-preprocessor">#include &lt;openssl/ssl.h&gt;</span>
<span class="hljs-preprocessor">#include &lt;openssl/err.h&gt;</span>

<span class="hljs-preprocessor">#define MAXBUF 1024</span>

<span class="hljs-keyword">void</span> ShowCerts(SSL * ssl)
{
    X509 *cert;
    <span class="hljs-keyword">char</span> *line;

    cert = SSL_get_peer_certificate(ssl);
    <span class="hljs-keyword">if</span> (cert != NULL) {
        <span class="hljs-built_in">printf</span>(<span class="hljs-string">"数字证书信息:\n"</span>);
        line = X509_NAME_oneline(X509_get_subject_name(cert), <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);
        <span class="hljs-built_in">printf</span>(<span class="hljs-string">"证书: %s\n"</span>, line);
        <span class="hljs-built_in">free</span>(line);
        line = X509_NAME_oneline(X509_get_issuer_name(cert), <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);
        <span class="hljs-built_in">printf</span>(<span class="hljs-string">"颁发者: %s\n"</span>, line);
        <span class="hljs-built_in">free</span>(line);
        X509_free(cert);
    } <span class="hljs-keyword">else</span>
        <span class="hljs-built_in">printf</span>(<span class="hljs-string">"无证书信息！\n"</span>);
}
<span class="hljs-comment">/************关于本文档********************************************
*filename: ssl-client.c
*purpose: 演示利用 OpenSSL 库进行基于 IP层的 SSL 加密通讯的方法，这是客户端例子
*wrote by: zhoulifa(zhoulifa@163.com) 周立发(http://zhoulifa.bokee.com)
Linux爱好者 Linux知识传播者 SOHO族 开发者 最擅长C语言
*date time:2007-02-02 20:10
*Note: 任何人可以任意复制代码并运用这些文档，当然包括你的商业用途
* 但请遵循GPL
*Thanks to:Google
*Hope:希望越来越多的人贡献自己的力量，为科学技术发展出力
* 科技站在巨人的肩膀上进步更快！感谢有开源前辈的贡献！
*********************************************************************/</span>
<span class="hljs-keyword">int</span> main(<span class="hljs-keyword">int</span> argc, <span class="hljs-keyword">char</span> **argv)
{
    <span class="hljs-keyword">int</span> sockfd, len;
    <span class="hljs-keyword">struct</span> sockaddr_in dest;
    <span class="hljs-keyword">char</span> buffer[MAXBUF + <span class="hljs-number">1</span>];
    SSL_CTX *ctx;
    SSL *ssl;

    <span class="hljs-keyword">if</span> (argc != <span class="hljs-number">3</span>) {
        <span class="hljs-built_in">printf</span>
            (<span class="hljs-string">"参数格式错误！正确用法如下：\n\t\t%s IP地址 端口\n\t比如:\t%s 127.0.0.1 80\n此程序用来从某个 IP 地址的服务器某个端口接收最多 MAXBUF 个字节的消息"</span>,
             argv[<span class="hljs-number">0</span>], argv[<span class="hljs-number">0</span>]);
        <span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);
    }

    <span class="hljs-comment">/* SSL 库初始化，参看 ssl-server.c 代码 */</span>
    SSL_library_init();
    OpenSSL_add_all_algorithms();
    SSL_load_error_strings();
    ctx = SSL_CTX_new(SSLv23_client_method());
    <span class="hljs-keyword">if</span> (ctx == NULL) {
        ERR_print_errors_fp(stdout);
        <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);
    }

    <span class="hljs-comment">/* 创建一个 socket 用于 tcp 通信 */</span>
    <span class="hljs-keyword">if</span> ((sockfd = socket(AF_INET, SOCK_STREAM, <span class="hljs-number">0</span>)) &lt; <span class="hljs-number">0</span>) {
        perror(<span class="hljs-string">"Socket"</span>);
        <span class="hljs-built_in">exit</span>(errno);
    }
    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"socket created\n"</span>);

    <span class="hljs-comment">/* 初始化服务器端（对方）的地址和端口信息 */</span>
    bzero(&amp;dest, <span class="hljs-keyword">sizeof</span>(dest));
    dest.sin_family = AF_INET;
    dest.sin_port = htons(atoi(argv[<span class="hljs-number">2</span>]));
    <span class="hljs-keyword">if</span> (inet_aton(argv[<span class="hljs-number">1</span>], (<span class="hljs-keyword">struct</span> in_addr *) &amp;dest.sin_addr.s_addr) == <span class="hljs-number">0</span>) {
        perror(argv[<span class="hljs-number">1</span>]);
        <span class="hljs-built_in">exit</span>(errno);
    }
    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"address created\n"</span>);

    <span class="hljs-comment">/* 连接服务器 */</span>
    <span class="hljs-keyword">if</span> (connect(sockfd, (<span class="hljs-keyword">struct</span> sockaddr *) &amp;dest, <span class="hljs-keyword">sizeof</span>(dest)) != <span class="hljs-number">0</span>) {
        perror(<span class="hljs-string">"Connect "</span>);
        <span class="hljs-built_in">exit</span>(errno);
    }
    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"server connected\n"</span>);

    <span class="hljs-comment">/* 基于 ctx 产生一个新的 SSL */</span>
    ssl = SSL_new(ctx);
    SSL_set_fd(ssl, sockfd);
    <span class="hljs-comment">/* 建立 SSL 连接 */</span>
    <span class="hljs-keyword">if</span> (SSL_connect(ssl) == -<span class="hljs-number">1</span>)
        ERR_print_errors_fp(stderr);
    <span class="hljs-keyword">else</span> {
        <span class="hljs-built_in">printf</span>(<span class="hljs-string">"Connected with %s encryption\n"</span>, SSL_get_cipher(ssl));
        ShowCerts(ssl);
    }

    <span class="hljs-comment">/* 接收对方发过来的消息，最多接收 MAXBUF 个字节 */</span>
    bzero(buffer, MAXBUF + <span class="hljs-number">1</span>);
    <span class="hljs-comment">/* 接收服务器来的消息 */</span>
    len = SSL_read(ssl, buffer, MAXBUF);
    <span class="hljs-keyword">if</span> (len &gt; <span class="hljs-number">0</span>)
        <span class="hljs-built_in">printf</span>(<span class="hljs-string">"接收消息成功:'%s'，共%d个字节的数据\n"</span>,
               buffer, len);
    <span class="hljs-keyword">else</span> {
        <span class="hljs-built_in">printf</span>
            (<span class="hljs-string">"消息接收失败！错误代码是%d，错误信息是'%s'\n"</span>,
             errno, strerror(errno));
        <span class="hljs-keyword">goto</span> finish;
    }
    bzero(buffer, MAXBUF + <span class="hljs-number">1</span>);
    <span class="hljs-built_in">strcpy</span>(buffer, <span class="hljs-string">"from client-&gt;server"</span>);
    <span class="hljs-comment">/* 发消息给服务器 */</span>
    len = SSL_write(ssl, buffer, <span class="hljs-built_in">strlen</span>(buffer));
    <span class="hljs-keyword">if</span> (len &lt; <span class="hljs-number">0</span>)
        <span class="hljs-built_in">printf</span>
            (<span class="hljs-string">"消息'%s'发送失败！错误代码是%d，错误信息是'%s'\n"</span>,
             buffer, errno, strerror(errno));
    <span class="hljs-keyword">else</span>
        <span class="hljs-built_in">printf</span>(<span class="hljs-string">"消息'%s'发送成功，共发送了%d个字节！\n"</span>,
               buffer, len);

  finish:
    <span class="hljs-comment">/* 关闭连接 */</span>
    SSL_shutdown(ssl);
    SSL_free(ssl);
    close(sockfd);
    SSL_CTX_free(ctx);
    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}
</code></pre>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/b9679b0cd558bf5826aa698cc9fe308e/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">用OpenSSL编写SSL,TLS程序（2）</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/07e3297a301d6c608cc7d4ef2c4cded1/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">KMP算法最浅显理解——一看就明白</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>