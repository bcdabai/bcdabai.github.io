<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>MethodHandle详解 - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="MethodHandle详解" />
<meta property="og:description" content="MethodHandle类的实质是将某个具体的方法映射到MethodHandle上，通过MethodHandle直接调用该句柄所引用的底层方法，实际就是对可执行方法的引用。接着我们对MethodHandle类中的方法进行详细解析。
1. asCollector方法 asCollector(Class
MethodHandles.Lookup publicLookup = MethodHandles.lookup(); MethodType mt = MethodType.methodType(String.class, int[].class); MethodHandle deepToString = publicLookup.findStatic(AsCollector.class, &#34;deepToString&#34;, mt); MethodHandle ts1 = deepToString.asCollector(int[].class, 3); System.out.println(ts1); 2. asFixedArity和asVarargsCollector方法 asFixedArity()方法，返回固定参数数量的方法句柄。 asVarargsCollector(Class
public static String deepToString(int a[]) { return (a[0]) &#43; &#34;&#34;;} public static String deepToString(int a) { return a &#43; &#34;&#34;;} public static void main(String[] args) throws Throwable { MethodHandles.Lookup publicLookup = MethodHandles.lookup(); MethodType mt = MethodType.methodType(String.class, int[].class); MethodHandle deepToString = publicLookup." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/390a9034f166605aa7e38b73c07aac6d/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2017-01-26T16:40:06+08:00" />
<meta property="article:modified_time" content="2017-01-26T16:40:06+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">MethodHandle详解</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p>MethodHandle类的实质是将某个具体的方法映射到MethodHandle上，通过MethodHandle直接调用该句柄所引用的底层方法，实际就是对可执行方法的引用。接着我们对MethodHandle类中的方法进行详细解析。</p> 
<h5 id="1-ascollector方法">1. asCollector方法</h5> 
<p>asCollector(Class</p> 
<pre class="prettyprint"><code class=" hljs avrasm">    MethodHandles<span class="hljs-preprocessor">.Lookup</span> publicLookup = MethodHandles<span class="hljs-preprocessor">.lookup</span>()<span class="hljs-comment">;</span>
    MethodType mt = MethodType<span class="hljs-preprocessor">.methodType</span>(String<span class="hljs-preprocessor">.class</span>, int[]<span class="hljs-preprocessor">.class</span>)<span class="hljs-comment">;</span>
    MethodHandle deepToString = publicLookup<span class="hljs-preprocessor">.findStatic</span>(AsCollector<span class="hljs-preprocessor">.class</span>, <span class="hljs-string">"deepToString"</span>, mt)<span class="hljs-comment">;</span>
    MethodHandle ts1 = deepToString<span class="hljs-preprocessor">.asCollector</span>(int[]<span class="hljs-preprocessor">.class</span>, <span class="hljs-number">3</span>)<span class="hljs-comment">;</span>
    System<span class="hljs-preprocessor">.out</span><span class="hljs-preprocessor">.println</span>(ts1)<span class="hljs-comment">;</span></code></pre> 
<h5 id="2-asfixedarity和asvarargscollector方法">2. asFixedArity和asVarargsCollector方法</h5> 
<p>asFixedArity()方法，返回固定参数数量的方法句柄。 <br> asVarargsCollector(Class</p> 
<pre class="prettyprint"><code class=" hljs cs">    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> String <span class="hljs-title">deepToString</span>(<span class="hljs-keyword">int</span> a[]) {
        <span class="hljs-keyword">return</span> (a[<span class="hljs-number">0</span>]) + <span class="hljs-string">""</span>;}
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> String <span class="hljs-title">deepToString</span>(<span class="hljs-keyword">int</span> a) {
        <span class="hljs-keyword">return</span> a + <span class="hljs-string">""</span>;}
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span>(String[] args) throws Throwable {
        MethodHandles.Lookup publicLookup = MethodHandles.lookup();
        MethodType mt = MethodType.methodType(String.class, <span class="hljs-keyword">int</span>[].class);
        MethodHandle deepToString = publicLookup.findStatic(AsFixedArity.class, <span class="hljs-string">"deepToString"</span>, mt);
        MethodHandle varargs = deepToString.asVarargsCollector(<span class="hljs-keyword">int</span>[].class);
        MethodHandle <span class="hljs-keyword">fixed</span> = deepToString.asFixedArity();
        System.<span class="hljs-keyword">out</span>.println(varargs);
        System.<span class="hljs-keyword">out</span>.println(<span class="hljs-keyword">fixed</span>);
        <span class="hljs-comment">//System.out.println(deepToString.invoke(1));报错</span>
        System.<span class="hljs-keyword">out</span>.println(varargs.invoke(<span class="hljs-number">1</span>));<span class="hljs-comment">//正常执行</span>
        <span class="hljs-comment">//System.out.println(fixed.invoke(1));报错 参数数量是固定的</span>
        System.<span class="hljs-keyword">out</span>.println(varargs.invoke(<span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[]{<!-- --><span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>}));
        System.<span class="hljs-keyword">out</span>.println(<span class="hljs-keyword">fixed</span>.invoke(<span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[]{<!-- --><span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>}));}
</code></pre> 
<h5 id="3-asspreader方法">3. asSpreader方法</h5> 
<p>按照参数的入参顺序，选择性的变换部分参数。</p> 
<p>示例代码：</p> 
<pre class="prettyprint"><code class=" hljs avrasm">        MethodHandles<span class="hljs-preprocessor">.Lookup</span> publicLookup = MethodHandles<span class="hljs-preprocessor">.lookup</span>()<span class="hljs-comment">;</span>
        MethodType mt = MethodType<span class="hljs-preprocessor">.methodType</span>(boolean<span class="hljs-preprocessor">.class</span>, Object<span class="hljs-preprocessor">.class</span>)<span class="hljs-comment">;</span>
        MethodHandle equals = publicLookup<span class="hljs-preprocessor">.findVirtual</span>(String<span class="hljs-preprocessor">.class</span>, <span class="hljs-string">"equals"</span>, mt)<span class="hljs-comment">;</span>
        MethodHandle eq2 = equals<span class="hljs-preprocessor">.asSpreader</span>(String[]<span class="hljs-preprocessor">.class</span>, <span class="hljs-number">0</span>)<span class="hljs-comment">;</span>
        //去掉一个参数，参数按入参顺序排列，Object类在第一，所以Object类被移除
        MethodHandle eq3 = equals<span class="hljs-preprocessor">.asSpreader</span>(String[]<span class="hljs-preprocessor">.class</span>, <span class="hljs-number">1</span>)<span class="hljs-comment">;</span>
        //去掉两个参数，参数按入参顺序排列，Object类在第一，String类在第二，所以Object、String类被移除
        MethodHandle eq4 = equals<span class="hljs-preprocessor">.asSpreader</span>(String[]<span class="hljs-preprocessor">.class</span>, <span class="hljs-number">2</span>)<span class="hljs-comment">;</span>
        System<span class="hljs-preprocessor">.out</span><span class="hljs-preprocessor">.println</span>(equals)<span class="hljs-comment">;</span>
        System<span class="hljs-preprocessor">.out</span><span class="hljs-preprocessor">.println</span>(eq2)<span class="hljs-comment">;</span>
        System<span class="hljs-preprocessor">.out</span><span class="hljs-preprocessor">.println</span>(eq3)<span class="hljs-comment">;</span>
        System<span class="hljs-preprocessor">.out</span><span class="hljs-preprocessor">.println</span>(eq4)<span class="hljs-comment">;</span></code></pre> 
<h5 id="4-astype方法">4. asType方法</h5> 
<p>asType方法的作用是把当前方法句柄适配到新的MethodType上面，并产生一个新的方法句柄，但是asType方法在方法句柄的切换上存在限制，并不是所有的切换都可以实现。</p> 
<p>示例代码：</p> 
<pre class="prettyprint"><code class=" hljs avrasm">        MethodHandles<span class="hljs-preprocessor">.Lookup</span> publicLookup = MethodHandles<span class="hljs-preprocessor">.lookup</span>()<span class="hljs-comment">;</span>
        MethodType mt = MethodType<span class="hljs-preprocessor">.methodType</span>(String<span class="hljs-preprocessor">.class</span>, int<span class="hljs-preprocessor">.class</span>)<span class="hljs-comment">;</span>
        MethodType mt1 = MethodType<span class="hljs-preprocessor">.methodType</span>(String<span class="hljs-preprocessor">.class</span>, Integer<span class="hljs-preprocessor">.class</span>)<span class="hljs-comment">;</span>
        MethodHandle deepToString = publicLookup<span class="hljs-preprocessor">.findStatic</span>(AsType<span class="hljs-preprocessor">.class</span>, <span class="hljs-string">"deepToString"</span>, mt)<span class="hljs-comment">;</span>
        System<span class="hljs-preprocessor">.out</span><span class="hljs-preprocessor">.println</span>(deepToString)<span class="hljs-comment">;</span>
        MethodHandle deepToString1 = deepToString<span class="hljs-preprocessor">.asType</span>(mt1)<span class="hljs-comment">;</span>
        System<span class="hljs-preprocessor">.out</span><span class="hljs-preprocessor">.println</span>(deepToString1)<span class="hljs-comment">;</span></code></pre> 
<h5 id="5-bindto方法">5. bindTo方法</h5> 
<p>将函数与对象捆绑在一起，把函数转变成了方法。</p> 
<p>示例代码：</p> 
<pre class="prettyprint"><code class=" hljs avrasm">        MethodHandles<span class="hljs-preprocessor">.Lookup</span> publicLookup = MethodHandles<span class="hljs-preprocessor">.lookup</span>()<span class="hljs-comment">;</span>
        MethodType mt = MethodType<span class="hljs-preprocessor">.methodType</span>(String<span class="hljs-preprocessor">.class</span>, int<span class="hljs-preprocessor">.class</span>)<span class="hljs-comment">;</span>
        MethodHandle deepToString = publicLookup<span class="hljs-preprocessor">.findStatic</span>(AsType<span class="hljs-preprocessor">.class</span>, <span class="hljs-string">"deepToString"</span>, mt)<span class="hljs-comment">;</span>
        int a = <span class="hljs-number">2</span><span class="hljs-comment">;</span>
        //绑定参数a
        MethodHandle deepToString1 = deepToString<span class="hljs-preprocessor">.bindTo</span>(a)<span class="hljs-comment">;</span>
        //不能再接收其他参数
        System<span class="hljs-preprocessor">.out</span><span class="hljs-preprocessor">.println</span>(deepToString1<span class="hljs-preprocessor">.invoke</span>())<span class="hljs-comment">;</span>
        System<span class="hljs-preprocessor">.out</span><span class="hljs-preprocessor">.println</span>(deepToString1)<span class="hljs-comment">;</span></code></pre> 
<p>####6. invoke、invokeExact、invokeWithArguments方法</p> 
<p>invoke()：参数类型松散匹配，通过asType自动适配。 <br> invokeExact()：调用此方法与调用底层方法一样，但必须做到参数严格匹配。 <br> invokeWithArguments(Object… arguments)：先通过genericMethodType方法得到MethodType，再通过MethodHandle的asType转换得到新的MethodHandle，最后通过新MethodHandle的invokeExact方法完成调用。</p> 
<p>示例代码：</p> 
<pre class="prettyprint"><code class=" hljs avrasm">        MethodHandles<span class="hljs-preprocessor">.Lookup</span> publicLookup = MethodHandles<span class="hljs-preprocessor">.lookup</span>()<span class="hljs-comment">;</span>
        MethodType mt = MethodType<span class="hljs-preprocessor">.methodType</span>(String<span class="hljs-preprocessor">.class</span>, int<span class="hljs-preprocessor">.class</span>)<span class="hljs-comment">;</span>
        MethodHandle deepToString = publicLookup<span class="hljs-preprocessor">.findStatic</span>(AsType<span class="hljs-preprocessor">.class</span>, <span class="hljs-string">"deepToString"</span>, mt)<span class="hljs-comment">;</span>
        System<span class="hljs-preprocessor">.out</span><span class="hljs-preprocessor">.println</span>(deepToString<span class="hljs-preprocessor">.invoke</span>(<span class="hljs-number">1</span>))<span class="hljs-comment">;</span>
        System<span class="hljs-preprocessor">.out</span><span class="hljs-preprocessor">.println</span>((String)deepToString<span class="hljs-preprocessor">.invokeExact</span>(<span class="hljs-number">1</span>))<span class="hljs-comment">;</span>
        System<span class="hljs-preprocessor">.out</span><span class="hljs-preprocessor">.println</span>(deepToString<span class="hljs-preprocessor">.invokeWithArguments</span>(<span class="hljs-number">1</span>))<span class="hljs-comment">;</span></code></pre>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/fe6817d0476025f5f237338b2d15c8d7/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">idea导入主题的方法</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/67e5edfbfa47d6dad60d59b541aa79b2/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">NOIP 复赛 NOI 上机 机试 评测系统 Arbiter</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>