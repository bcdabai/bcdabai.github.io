<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>防抖和节流应用以及lodash.js文件引入 - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="防抖和节流应用以及lodash.js文件引入" />
<meta property="og:description" content="首先下载lodash插件：里面封装函数的防抖与节流的业务【闭包&#43;延时器】
- 终端执行
npm i --save lodash 成功后可以在node_modules文件夹中找到lodash.js
如果你想在html中使用lodash，可以将lodash.js文件复制到指定路径下，就可以方便通过script标签引入了
&lt;script src=&#34;./lodash.js&#34;&gt;&lt;/script&gt; 防抖：前面所有的触发都被取消，最后一次执行在规定的时间之后才会触发，也就是说如果连续快速的触发只会执行一次。
比如防抖可以作用于用户在输入框中输入内容时，是边输入边发请求还是结束后才发请求。或者用户鼠标移到某个按钮上就发请求的情况，容易造成卡顿。如果设置为结束后再发请求则实现防抖。
以下实现防抖的例子：文本输入一秒后才执行
let input=document.querySelector(&#34;input&#34;) //绑定事件 文本发生变化立即执行 input.oninput=_.debounce(function(){ console.log(&#34;ajax发请求&#34;); },1000) 节流：在规定间隔时间范围内不会重复触发回调，只有大于这个时间间隔才会触发回调，只有大于这个时间间隔才会触发回调，把频繁触发变为少量触发。可以参考短信验证码，我们总是遇到要一分钟后才可以再次点击，这就避免了用户不断发请求的情况。
以下实现节流的例子：计数器，一秒内只能加一
button.onclick=_.throttle(function(){ //节流：目前的回调函数是五秒执行一次 //假如这里有很多业务代码，就可以给浏览器充裕的时间去解析 //比如短信验证码 count&#43;&#43; span.innerHTML=count console.log(&#34;执行啦&#34;); },5000) 总结一下区别：
防抖：用户操作很频繁，但是只执行一次
节流：用户操作很频繁，但是会把频繁操作转换为少量操作，可以给浏览器充裕的时间解析代码" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/7b0f7ff39c51c0dd277a296902fc3322/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-06-28T16:11:30+08:00" />
<meta property="article:modified_time" content="2022-06-28T16:11:30+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">防抖和节流应用以及lodash.js文件引入</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p><br> 首先下载lodash插件：里面封装函数的防抖与节流的业务【闭包+延时器】<br> - 终端执行</p> 
<pre><code class="language-bash">npm i --save lodash</code></pre> 
<p>成功后可以在<strong>node_modules</strong>文件夹中找到<strong>lodash.js</strong><br> 如果你想在html中使用lodash，可以将lodash.js文件复制到指定路径下，就可以方便通过script标签引入了</p> 
<pre><code class="language-html">&lt;script src="./lodash.js"&gt;&lt;/script&gt;</code></pre> 
<p><strong>防抖：</strong>前面所有的触发都被取消，最后一次执行在规定的时间之后才会触发，也就是说如果连续快速的触发只会执行一次。</p> 
<p>比如防抖可以作用于用户在输入框中输入内容时，是边输入边发请求还是结束后才发请求。或者用户鼠标移到某个按钮上就发请求的情况，容易造成卡顿。如果设置为结束后再发请求则实现防抖。</p> 
<p>以下实现防抖的例子：文本输入一秒后才执行</p> 
<pre><code class="language-javascript">    let input=document.querySelector("input")
    //绑定事件 文本发生变化立即执行
    input.oninput=_.debounce(function(){
        console.log("ajax发请求");
    },1000)</code></pre> 
<p><strong>节流</strong>：在规定间隔时间范围内不会重复触发回调，只有大于这个时间间隔才会触发回调，只有大于这个时间间隔才会触发回调，把频繁触发变为少量触发。可以参考短信验证码，我们总是遇到要一分钟后才可以再次点击，这就避免了用户不断发请求的情况。</p> 
<p>以下实现节流的例子：计数器，一秒内只能加一</p> 
<pre><code class="language-javascript">    button.onclick=_.throttle(function(){
        //节流：目前的回调函数是五秒执行一次
        //假如这里有很多业务代码，就可以给浏览器充裕的时间去解析
        //比如短信验证码
        count++
        span.innerHTML=count
        console.log("执行啦");
    },5000)</code></pre> 
<p>总结一下区别：<br> 防抖：用户操作很频繁，但是只执行一次<br> 节流：用户操作很频繁，但是会把频繁操作转换为少量操作，可以给浏览器充裕的时间解析代码</p> 
<p></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/6cd34db85155cc866c74da52d2eb424a/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">用Java实现0-100的随机数</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/7f87090505bc7c8cc742bc7c96c28116/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">[Unity转小游戏]微信开发者工具/微信小游戏中找不到unityInstance.(unityInstance is not defined)</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>