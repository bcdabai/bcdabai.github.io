<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>C&#43;&#43;11 random库 - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="C&#43;&#43;11 random库" />
<meta property="og:description" content="c&#43;&#43; 中的随机数 在 C&#43;&#43; 程序中，在新标准出现之前，C 和 C&#43;&#43; 都依赖一个简单的 C 库函数 rand 来生成随机数，但是，这个函数生成的是均匀分布的伪随机数，每个随机数的范围在 0 和一个系统相关的最大值（至少为 32767）之间。
rand 函数有一些问题：即使不是大多数，也有很多程序需要不通范围的随机数。一些应用需要随机浮点数。一些程序需要非均匀分布的随机数。而在编写程序为了解决这些通常会转换 rand 生成的随机数的范围、类型或者是分布时，常常会引入非随机性。
在 C&#43;&#43; 11 标准中，定义在头文件 random 中的随机数库通过一组协作的类来解决这些问题，主要用到的是两个类：
随机数引擎类（random-number engines）、随机数分布类（random-number distribution)。
其中，一个引擎类可以生成 unsigned 随机数列，一个分布使用一个引擎类生成指定类型的，在给定范围内的，服从指定概率分布的随机数。
随机数引擎和分布 随机数引擎是函数对象类，他们定义了一个调用运算符，该运算符不接受参数并返回一个随机的 unsigned 整数。我们可以通过调用一个随机数引擎对象来生成原始随机数。
default_random_engine e; // 生成随机无符号数 for(size_t i=0; i&lt;10; i&#43;&#43;) // e() “调用”对象来生成下一个随机数 cout &lt;&lt; e() &lt;&lt;endl; 在上面这几行的代码中，定义了一个名为 e 的 default_random_engine 的对象。在 for 循环内，我们调用对象 e 来获得下一个随机数。
分布类型和引擎 为了得到一个在指定范围内的数，我们一用一个分布类型的对象：
//生成 0 到 9 之间（包含）均匀分布的随机数 uniform_int_distribution&lt;unsigned&gt; u(0,9); default_random_engine e; // 生成无符号随机整数 for (size_t i =0;i&lt;10; i&#43;&#43;) // 将 u 作为随机数源 // 每个调用返回在指定范围内并服从均匀分布的值 cout&lt;&lt;u(e)&lt;&lt;&#34;" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/df753877f2650e3bfe9299b78cf6e750/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2020-03-11T11:23:15+08:00" />
<meta property="article:modified_time" content="2020-03-11T11:23:15+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">C&#43;&#43;11 random库</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <h3><a id="c__0"></a>c++ 中的随机数</h3> 
<p>在 C++ 程序中，在新标准出现之前，C 和 C++ 都依赖一个简单的 C 库函数 rand 来生成随机数，但是，这个函数生成的是均匀分布的伪随机数，每个随机数的范围在 0 和一个系统相关的最大值（至少为 32767）之间。</p> 
<p>rand 函数有一些问题：即使不是大多数，也有很多程序需要不通范围的随机数。一些应用需要随机浮点数。一些程序需要非均匀分布的随机数。而在编写程序为了解决这些通常会转换 rand 生成的随机数的范围、类型或者是分布时，常常会引入非随机性。</p> 
<p>在 C++ 11 标准中，定义在头文件 random 中的随机数库通过一组协作的类来解决这些问题，主要用到的是两个类：<br> <strong>随机数引擎类（random-number engines）</strong>、<strong>随机数分布类（random-number distribution)</strong>。<br> 其中，一个引擎类可以生成 unsigned 随机数列，一个分布使用一个引擎类生成指定类型的，在给定范围内的，服从指定概率分布的随机数。</p> 
<h3><a id="_9"></a>随机数引擎和分布</h3> 
<p>随机数引擎是函数对象类，他们定义了一个调用运算符，该运算符不接受参数并返回一个随机的 unsigned 整数。我们可以通过调用一个随机数引擎对象来生成原始随机数。</p> 
<pre><code class="prism language-cpp">default_random_engine e<span class="token punctuation">;</span>    <span class="token comment">// 生成随机无符号数</span>
<span class="token keyword">for</span><span class="token punctuation">(</span>size_t i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span> i<span class="token operator">&lt;</span><span class="token number">10</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>
    <span class="token comment">// e() “调用”对象来生成下一个随机数</span>
    cout <span class="token operator">&lt;&lt;</span> <span class="token function">e</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span>
</code></pre> 
<p>在上面这几行的代码中，定义了一个名为 e 的 default_random_engine 的对象。在 for 循环内，我们调用对象 e 来获得下一个随机数。</p> 
<h5><a id="_22"></a>分布类型和引擎</h5> 
<p>为了得到一个在指定范围内的数，我们一用一个分布类型的对象：</p> 
<pre><code class="prism language-cpp"><span class="token comment">//生成 0 到 9 之间（包含）均匀分布的随机数</span>
uniform_int_distribution<span class="token operator">&lt;</span><span class="token keyword">unsigned</span><span class="token operator">&gt;</span> <span class="token function">u</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">9</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
default_random_engine e<span class="token punctuation">;</span>    <span class="token comment">// 生成无符号随机整数</span>
<span class="token keyword">for</span> <span class="token punctuation">(</span>size_t i <span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span><span class="token number">10</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>
    <span class="token comment">// 将 u 作为随机数源</span>
    <span class="token comment">// 每个调用返回在指定范围内并服从均匀分布的值</span>
    cout<span class="token operator">&lt;&lt;</span><span class="token function">u</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span><span class="token operator">&lt;&lt;</span><span class="token string">" "</span><span class="token punctuation">;</span>
cout<span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
</code></pre> 
<p>上面的代码输入如下:<br> 0 1 7 4 5 2 0 6 6 9</p> 
<p>上面的程序中，我们将 u 定义为 uniform_int_distribution 。这种类型生成均匀分布的 unsigned 值。当我们定义一个这种类型的对象时，可以提供想要的最小值和最大值。在上面这段代码中，u(0,9) 表示我们希望得到 0 到 9 之间（包含）的数。随机数分布类会使用包含的范围，从而我们可以得到给定整形的每个可能值。</p> 
<p>类似引擎类型，分布类型也是函数对象类。分布类型定义了一个调用运算符，它接受一个随机数引擎作为参数。分布对象使用它的引擎参数生成随机数，并将其映射到指定的分布。</p> 
<p>传递给分布对象的是引擎对象本身，也就是 u(e)，如果我们将调用写为 u(e())，含义就变为将 e 生成的下一个值传递给 u，这会导致一个编译错误。我们传递的是引擎本身，而不是他生成的下一个值，原因是某些分布可能需要调用引擎多次才能得到一个值。</p> 
<h5><a id="_44"></a>使用引擎生成一个数值序列</h5> 
<p>随机数发生器有一个特性，也就是即使生成的树看起来是随机的，但是对于一个给定的发生器，每次运行程序它都会返回相同的数值序列。序列不变这一事实在 调试 的时候十分有用，但是另一方面，使用随机数发生器的程序也必须考虑到这一特性。</p> 
<p>下面介绍一个例子，需要一个函数生成一个 vector，包含 100 个均匀分布在 0 到 9 之间的随机数。一种错误的方法是使用下面的代码：</p> 
<pre><code class="prism language-cpp">vector<span class="token operator">&lt;</span><span class="token keyword">unsigned</span> <span class="token operator">&gt;</span><span class="token function">bad_randVec</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
    default_random_engine e<span class="token punctuation">;</span>
    uniform_int_distribution<span class="token operator">&lt;</span><span class="token keyword">unsigned</span> <span class="token operator">&gt;</span><span class="token function">u</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">9</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    vector<span class="token operator">&lt;</span><span class="token keyword">unsigned</span> <span class="token operator">&gt;</span>ret<span class="token punctuation">;</span>
    <span class="token keyword">for</span><span class="token punctuation">(</span>size_t i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span><span class="token number">100</span><span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span>
        ret<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span><span class="token function">u</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> ret<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token comment">// 但是 每次调用这个函数都会返回相同的 vector</span>
vector<span class="token operator">&lt;</span><span class="token keyword">unsigned</span> <span class="token operator">&gt;</span><span class="token function">v1</span><span class="token punctuation">(</span><span class="token function">bad_randVec</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
vector<span class="token operator">&lt;</span><span class="token keyword">unsigned</span> <span class="token operator">&gt;</span><span class="token function">v2</span><span class="token punctuation">(</span><span class="token function">bad_randVec</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// 将会打印输出 equal</span>
cout <span class="token operator">&lt;&lt;</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>v1<span class="token operator">==</span>v2<span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token string">"equal"</span> <span class="token operator">:</span> <span class="token string">"not equal"</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
</code></pre> 
<p>上面这段代码会输出 equal，因为 vector v1 和 v2 具有相同的值。</p> 
<p>正确的定义方法是 将引擎和关联的分布对象定义为 static 的：</p> 
<pre><code class="prism language-cpp">vector<span class="token operator">&lt;</span><span class="token keyword">unsigned</span> <span class="token operator">&gt;</span><span class="token function">good_randVec</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
    <span class="token comment">// 由于我们希望引擎和分布对象保持状态，因此应该将他们定义为</span>
    <span class="token comment">// static 的，从而每次调用都生成新的数</span>
    <span class="token keyword">static</span> default_random_engine e<span class="token punctuation">;</span>
    <span class="token keyword">static</span> uniform_int_distribution<span class="token operator">&lt;</span><span class="token keyword">unsigned</span> <span class="token operator">&gt;</span> <span class="token function">u</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">9</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    vector<span class="token operator">&lt;</span><span class="token keyword">unsigned</span> <span class="token operator">&gt;</span> ret<span class="token punctuation">;</span>
    <span class="token keyword">for</span><span class="token punctuation">(</span>size_t i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i<span class="token operator">&lt;</span><span class="token number">100</span><span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span>
        ret<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span><span class="token function">u</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> ret<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>由于 e 和 u 都是 static 的，因此它们在函数调用之间会保持住状态。第一次调用会使用 u(e) 生成的序列中的前 100 个随机数，第二次调用会获得接下来 100 个。以此类推。</p> 
<p>注意，一个给定的随机数发生器已知会生成相同的随机数序列。一个函数如果定义了局部的随机数发生器，应该将其（包括引擎和分布对象）定义为 static 的。否则，每次调用函数都会生成相同的序列。</p> 
<h5><a id="_88"></a>设置随机数发生器种子</h5> 
<p>随机数发生器会生成相同的随机数序列这一特性在调试中很有用。但是，一旦我们的程序调试完毕，我们通常希望每次运行程序都会生成不同的随机结果，可以通过提供一个种子(seed)来达到这个目的。种子就是一个数值，引擎可以利用它从序列中一个新位置重新开始生成随机数。</p> 
<p>为引擎设置种子有两种方式：<br> <strong>在创建引擎对象时提供种子</strong><br> <strong>调用引擎的 seed 成员</strong></p> 
<pre><code class="prism language-cpp"><span class="token comment">// 几乎肯定是生成随机整数 vector 的错误方法</span>
<span class="token comment">// 每次调用这个函数都会生成相同的 100 个数</span>
default_random_engine e1<span class="token punctuation">;</span>       <span class="token comment">// 使用默认种子</span>
default_random_engine <span class="token function">e2</span><span class="token punctuation">(</span><span class="token number">2147483646</span><span class="token punctuation">)</span><span class="token punctuation">;</span>       <span class="token comment">// 使用给定的种子值</span>
<span class="token comment">// e3 和 e4 将会生成相同的序列，因为他们使用了相同的种子</span>
default_random_engine e3<span class="token punctuation">;</span>
e3<span class="token punctuation">.</span><span class="token function">seed</span><span class="token punctuation">(</span><span class="token number">32767</span><span class="token punctuation">)</span><span class="token punctuation">;</span>             <span class="token comment">//调用 seed 设置为一个新种子值</span>
default_random_engine <span class="token function">e4</span><span class="token punctuation">(</span><span class="token number">32767</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 将种子值设置为 32767</span>
<span class="token keyword">for</span><span class="token punctuation">(</span>size_t i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>i <span class="token operator">!=</span> <span class="token number">10</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">e1</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token function">e2</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
        cout<span class="token operator">&lt;&lt;</span><span class="token string">"unseeded match at iteeration: "</span><span class="token operator">&lt;&lt;</span>i<span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">e3</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token function">e4</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
        cout<span class="token operator">&lt;&lt;</span><span class="token string">"seeded differs at itertion: "</span><span class="token operator">&lt;&lt;</span>i<span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>设置种子最常用的方法是调用系统函数 time ，这个函数定义再头文件 ctime 中，它返回一个特定时刻到当前经过了多少秒。函数 time 接受单个指针参数，它指向用于写入时间的数据结构。如果此指针为空，则函数简单的返回时间：</p> 
<pre><code class="prism language-cpp">default_random_engine <span class="token function">e1</span><span class="token punctuation">(</span><span class="token function">time</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 稍微随机些的种子</span>
</code></pre> 
<p><strong>但是，由于 time 返回以秒计的时间，因此这种方式只适用于生成种子的间隔为秒级或更长的应用。</strong></p> 
<h3><a id="_122"></a>其他随机数分布</h3> 
<h5><a id="_123"></a>生成随机实数</h5> 
<p>程序常常需要一个随机浮点数源。特别是程序经常需要 0 到 1 之间的随机数。</p> 
<p>可一定以一个 uniform_real_distribution 类型的对象，并让标准库来处理从随机整数到随机浮点数的映射。与处理 uniform_int_distribution 一样，在定义对象时，我们指定最小值和最大值。</p> 
<pre><code class="prism language-cpp">default_random_engine e<span class="token punctuation">;</span>        <span class="token comment">// 生成无符号随机整数</span>
    <span class="token comment">// 0 到 1 （包含）的均匀分布</span>
uniform_real_distribution<span class="token operator">&lt;</span><span class="token keyword">double</span> <span class="token operator">&gt;</span><span class="token function">u</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">for</span><span class="token punctuation">(</span>size_t i <span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span><span class="token number">10</span><span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span>
	cout<span class="token operator">&lt;&lt;</span><span class="token function">u</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span><span class="token operator">&lt;&lt;</span><span class="token string">" "</span><span class="token punctuation">;</span>
	
cout<span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span>
</code></pre> 
<p>此外，当我们对分布函数不指定默认生成的类型参数时，程序会自动赋予一个类型，生成浮点值得分布类型默认生成 double 类型，生成整型值的分布类型默认生成 int 类型，如下：</p> 
<pre><code class="prism language-cpp">uniform_real_distribution<span class="token operator">&lt;</span><span class="token operator">&gt;</span><span class="token function">u</span><span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 默认生成 double 值</span>
</code></pre> 
<h5><a id="_146"></a>生成非均匀分布的随机数</h5> 
<p>除了生成上面的均匀分布，C++ 11 还规定了可以生成 20 种不同的分布类型，比如 均匀分布uniform，正态分布normal，二项分布binomial，泊松分布poisson，学生分布 student 等等，相关函数可以查看相应的函数（具体可以参考 C++ Primer 781页）。</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/3a6f1ef9f437e890a84d4369087c3050/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">模n加法——元素阶的终极规律</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/c5094243fc6a4d7ab638bb399ea35072/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">iServer GP服务算子扩展</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>