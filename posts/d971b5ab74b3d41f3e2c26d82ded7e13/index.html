<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Compose - 布局组合项 - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Compose - 布局组合项" />
<meta property="og:description" content="组合函数不指定布局默认是Box堆叠。一些概念参考View版的ContraintLayout。
一、纵向 Colum inline fun Column(
modifier = Modifier,
verticalArrangement = Arrangement.Top, //子元素纵向排列规则
horizontalAlignment = Alignment.Start, //子元素横向排列规则
content: @Composable ColumnScope.() -&gt; Unit
)
1.1 使Column具备滑动能力 val scrollState = rememberScrollState() Column(Modifier.verticalScroll(scrollState)) { repeat(20) { Text(text = &#34;aaaaaaa&#34;) } } 二、横向 Row inline fun Row(
modifier: Modifier = Modifier,
horizontalArrangement: Arrangement.Horizontal = Arrangement.Start,
verticalAlignment: Alignment.Vertical = Alignment.Top,
content: @Composable RowScope.() -&gt; Unit
)
三、堆叠 Box inline fun Box(
modifier: Modifier = Modifier," />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/d971b5ab74b3d41f3e2c26d82ded7e13/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-08-31T02:19:36+08:00" />
<meta property="article:modified_time" content="2023-08-31T02:19:36+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Compose - 布局组合项</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <blockquote> 
 <p>组合函数不指定布局默认是Box堆叠。一些概念参考<a class="link-info" href="https://blog.csdn.net/HugMua/article/details/130517266?csdn_share_tail=%7B%22type%22%3A%22blog%22%2C%22rType%22%3A%22article%22%2C%22rId%22%3A%22130517266%22%2C%22source%22%3A%22HugMua%22%7D" title="View版的ContraintLayout">View版的ContraintLayout</a>。</p> 
</blockquote> 
<h2>一、纵向 Colum</h2> 
<table border="1"><tbody><tr><td colspan="1" rowspan="1" style="vertical-align:top;"> <p>inline fun Column(</p> <p>modifier = Modifier,</p> <p>verticalArrangement = Arrangement.Top,        //子元素纵向排列规则</p> <p>horizontalAlignment = Alignment.Start,        //子元素横向排列规则</p> <p>content: @Composable ColumnScope.() -&gt; Unit</p> <p>)</p> </td></tr></tbody></table> 
<h3>1.1 使Column具备滑动能力</h3> 
<pre><code class="language-Kotlin">val scrollState = rememberScrollState()
Column(Modifier.verticalScroll(scrollState)) {
    repeat(20) {
        Text(text = "aaaaaaa")
    }
}</code></pre> 
<h2>二、横向 Row</h2> 
<table border="1"><tbody><tr><td colspan="1" rowspan="1" style="vertical-align:top;"> <p>inline fun Row(</p> <p>modifier: Modifier = Modifier,</p> <p>horizontalArrangement: Arrangement.Horizontal = Arrangement.Start,</p> <p>verticalAlignment: Alignment.Vertical = Alignment.Top,</p> <p>content: @Composable RowScope.() -&gt; Unit</p> <p>)</p> </td></tr></tbody></table> 
<h2>三、堆叠 Box</h2> 
<table border="1"><tbody><tr><td colspan="1" rowspan="1" style="vertical-align:top;"> <p>inline fun Box(</p> <p>modifier: Modifier = Modifier,</p> <p>contentAlignment: Alignment = Alignment.TopStart,</p> <p>propagateMinConstraints: Boolean = false,</p> <p>content: @Composable BoxScope.() -&gt; Unit</p> <p>)</p> </td></tr><tr><td colspan="1" rowspan="1" style="vertical-align:top;"> <p>fun Box(modifier: Modifier)</p> </td></tr></tbody></table> 
<h2>四、约束布局 ConstraintLayout</h2> 
<p><a class="link-info" href="https://developer.android.google.cn/jetpack/compose/layouts/constraintlayout?hl=zh-cn" rel="nofollow" title="查看官方最新版本">查看官方最新版本</a></p> 
<pre><code class="language-Groovy">implementation "androidx.constraintlayout:constraintlayout-compose:1.0.1"</code></pre> 
<blockquote> 
 <p>各种对齐或嵌套过深的时候使用。需要注意以下几点：</p> 
 <ul><li>通过 createRefs( ) 或 createRefFor( ) 为子元素创建引用（相当于创建ID）。</li><li>通过 Modifier.constranAs( ) 将组合函数和引用绑定，在Lambda中指定约束条件。</li><li>约束条件通过 linkTo( ) 或其它有用的方法指定。</li><li>parent 是现有的引用，可用于指定对 ConstraintLayout 本身的约束条件。</li><li>默认尽可能小的容纳完子元素（wrap_content），设置子元素位置（gravity）依据的是内容宽高，若要相对于屏幕位置，需要对 ConstraintLayout 使用 Modifier.fillMaxWidth() 或 fillMaxHeight() 或fillMAxSize()。</li><li>默认允许子元素超出屏幕，宽度要设置Dimension.preferredWrapContent。</li></ul> 
</blockquote> 
<pre><code class="language-Kotlin">@Composable
inline fun ConstraintLayout(
    modifier: Modifier = Modifier,
    optimizationLevel: Int = Optimizer.OPTIMIZATION_STANDARD,
    crossinline content: @Composable ConstraintLayoutScope.() -&gt; Unit
)</code></pre> 
<pre><code class="language-Kotlin">fun Modifier.constrainAs(
    ref: ConstrainedLayoutReference,    //指定绑定的引用
    //提供现有参数start、top、end、bottom表示当前组合函数的上下左右四边，调用linkTo()指定该边的约束
    constrainBlock: ConstrainScope.() -&gt; Unit    //设置约束条件
)</code></pre> 
<pre><code class="language-Kotlin">fun linkTo(
    //指定连接到哪里，parent指ConstraintLayout（如）
    anchor: ConstraintLayoutBaseScope.***Anchor,
    margin: Dp = 0.dp,
    goneMargin: Dp = 0.dp
)</code></pre> 
<p> <img alt="" height="189" src="https://images2.imgbox.com/c4/ce/WsOfK88P_o.png" width="273"></p> 
<pre><code class="language-Kotlin">@Composable
fun MyConstraintLayout() {
    ConstraintLayout {
        //为每个子元素创建引用
        val (buttonRef, textRef) = createRefs()
        Button(
            onClick = { /* Do something */ },
            //将组合函数和引用关联
            modifier = Modifier.constrainAs(buttonRef) {
                //指定约束条件，现有引用parent是指ConstraintLayout
                top.linkTo(parent.top, margin = 16.dp)
            }
        ) {
            Text("Button")
        }
        Text(
            text = "Text",
            Modifier.constrainAs(textRef) {
                top.linkTo(buttonRef.bottom, margin = 16.dp)
                //centerAround(button1.end)    //自己中间对齐谁的哪边
                centerHorizontallyTo(parent)    //水平居中
            }
        )
    }
}</code></pre> 
<h3>4.1 栅栏 Barrier </h3> 
<p><img alt="" height="235" src="https://images2.imgbox.com/ad/ce/MQxNFoDH_o.png" width="383"></p> 
<pre><code class="language-Kotlin">@Composable
fun MyBarrier() {
    ConstraintLayout {
        val (button1, button2, text) = createRefs()
        Button(onClick = { }, modifier = Modifier.constrainAs(button1) {
            top.linkTo(parent.top, margin = 16.dp)
        }) {
            Text(text = "Button1")
        }
        Text(text = "Text", modifier = Modifier.constrainAs(text) {
            top.linkTo(button1.bottom, margin = 16.dp)
            centerAround(button1.end)    //自己中间对齐谁的哪边
        })
        val barrier = createEndBarrier(button1, text)   //将button1和text组合成一个Barrier
        Button(onClick = { }, modifier = Modifier.constrainAs(button2) {
            top.linkTo(parent.top, margin = 16.dp)
            start.linkTo(barrier)
        }) {
            Text(text = "Button2")
        }
    }
}</code></pre> 
<h3>4.2 基准线 Guideline</h3> 
<table border="1" cellpadding="1" cellspacing="1"><tbody><tr><td> <p>createGuidelineFromTop(offset: Dp)<br> createGuidelineFromBottom(offset: Dp)</p> <p>createGuidelineFromStart(offset: Dp)</p> <p>createGuidelineFromEnd(offset: Dp)</p> </td><td>上下左右基于父布局的偏移量</td></tr><tr><td> <p>createGuidelineFromTop(fraction: Float)<br> createGuidelineFromBottom(fraction: Float)</p> <p>createGuidelineFromStart(fraction: Float)</p> <p>createGuidelineFromEnd(fraction: Float)</p> </td><td>上下左右基于父布局的百分比</td></tr><tr><td>createGuidelineFromAbsoluteLeft(offset: Dp)<br> createGuidelineFromAbsoluteLeft(fraction: Float)<br> createGuidelineFromAbsoluteRight(offset: Dp)<br> createGuidelineFromAbsoluteRight(fraction: Float)</td><td>国际化</td></tr></tbody></table> 
<table border="1" cellpadding="1" cellspacing="1"><tbody><tr><td>Dimension.preferredWrapContent</td><td>布局大小根据内容设置，并受布局约束影响。</td></tr><tr><td>Dimension.wrapContent        默认值</td><td>布局大小只根据内容设置，不受布局约束影响。</td></tr><tr><td>Dimension.fillToConstraints</td><td>布局大小将展开填充由布局约束所限制的空间。</td></tr><tr><td>Dimension.preferredValue</td><td>布局大小是一个默认值，并受布局约束影响。</td></tr><tr><td>Dimension.value</td><td>布局大小是一个默认值，不受布局约束影响。</td></tr><tr><td colspan="1" rowspan="2">Dimension.preferredWrapContent.adLast(100.dp)<br> Dimension.preferredWrapContent.atMost(100.dp)</td><td colspan="1" rowspan="2">可组合设置布局大小，设置最大/最小布局大小。</td></tr></tbody></table> 
<p><img alt="" height="188" src="https://images2.imgbox.com/7b/5f/Z0TEbAUz_o.png" width="581"></p> 
<pre><code class="language-Kotlin">@Composable
fun MyGuideline() {
    ConstraintLayout {
        val text = createRef()
        val guideline = createGuidelineFromStart(fraction = 0.5f)
        Text(
            text = "Hellow Wodr!Hellow Wodr!Hellow Wodr!Hellow Wodr!Hellow Wodr!Hellow Wodr!Hellow Wodr!",
            modifier = Modifier.constrainAs(text) {
                linkTo(start = guideline, end = parent.end)
                //默认允许子元素超出屏幕，所以这里要设置一下
                width = Dimension.preferredWrapContent
            }
        )
    }
}</code></pre> 
<h3>4.3 链 Chain</h3> 
<table border="1" cellpadding="1" cellspacing="1"><tbody><tr><td> <p>fun createHorizontalChain(</p> <p>        vararg elements: ConstrainedLayoutReference,        //需要打包在一起的子元素引用<br>         chainStyle: ChainStyle = ChainStyle.Spread        //链的类型</p> <p>)</p> </td></tr><tr><td>fun createVerticalChain(<br>         vararg elements: ConstrainedLayoutReference,<br>         chainStyle: ChainStyle = ChainStyle.Spread<br> )</td></tr></tbody></table> 
<table border="1" cellpadding="1" cellspacing="1"><tbody><tr><td>ChainStyle.Spread        默认</td><td>所有子元素平均分布在父布局中</td></tr><tr><td>ChainStyle.SpreadInside</td><td>头尾子元素分布在两端，其余平均分布剩下空间。</td></tr><tr><td>ChainStyle.Packed</td><td>所有子元素打包在一起，放在链条中间。</td></tr></tbody></table> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/2f/c8/IYXHZ9DC_o.jpg"></p> 
<pre><code class="language-Kotlin">@Composable
fun MyChain() {
    ConstraintLayout(modifier = Modifier.fillMaxSize()) {
        val (box1, box2, box3) = createRefs()
        createHorizontalChain(box1, box2, box3, chainStyle = ChainStyle.Spread)
        Box(modifier = Modifier.size(100.dp).background(Color.Red).constrainAs(box1) {})
        Box(modifier = Modifier.size(100.dp).background(Color.Green).constrainAs(box2) {})
        Box(modifier = Modifier.size(100.dp).background(Color.Blue).constrainAs(box3) {})
    }
}</code></pre> 
<h3>4.4 约束集解耦 ConstraintSet</h3> 
<blockquote> 
 <p>上面约束都是写在子元素里的，可以抽取出来在外部定义，通过传参的方式解耦，即动态约束。</p> 
</blockquote> 
<ol><li>创建 ConstraintSet（定义引用和对应的约束条件）传给 ConstraintLayout。</li><li>子元素通过 Modifier.layourId() 设置为 ConstraintSet 中对应的引用。</li></ol> 
<p><img alt="" height="218" src="https://images2.imgbox.com/d1/12/1VCCDrnp_o.png" width="230"></p> 
<pre><code class="language-Kotlin">@Composable
fun Before() {
    val margin = 16.dp
    ConstraintLayout {
        val (button, text) = createRefs()
        Button(onClick = {}, modifier = Modifier.constrainAs(button) {
            top.linkTo(parent.top, margin = margin)
        }) {
            Text(text = "Button")
        }
        Text(text = "Text", modifier = Modifier.constrainAs(text) {
            top.linkTo(button.bottom, margin = margin)
        })
    }
}
//外部定义约束集
private fun myContraints(margin: Dp) = ConstraintSet {
    //创建引用
    val button = createRefFor(id = "button")
    val text = createRefFor(id = "text")
    //配置约束条件
    constrain(button) {
        top.linkTo(parent.top, margin)
    }
    constrain(text) {
        top.linkTo(button.bottom, margin)
    }
}
@Composable
fun after() {
    //该组合项提供的现有参数可用来根据可用空间调用不同的可组合项（屏幕适配）
    //单位dp的参数：minWidth、minHeight、maxWidth、maxHeight
    //单位px的参数：constraints.maxWidth
    BoxWithConstraints {
        //根据竖屏横屏返回不同的值
        val margin = if (maxWidth &lt; maxHeight) myContraints(16.dp) else myContraints(20.dp)
        //传入约束集使用
        ConstraintLayout(margin) {
            //子元素设置约束集中对应的引用
            Button(onClick = {}, modifier = Modifier.layoutId("button")) {
                Text(text = "Button")
            }
            Text(text = "Text", modifier = Modifier.layoutId("text"))
        }
    }
}</code></pre> 
<h2 style="background-color:transparent;">五、脚手架 Scaffold</h2> 
<blockquote> 
 <p>槽位（Slots API）会在界面中留出空位，让开发者自行填充使用。Scaffold可以为最常见的Material组件提供槽位（TopAppBar、BottomAppBar、FloatingActionBar、Drawer），使它们得到适当放置且正确的协同工作。</p> 
</blockquote> 
<h2><img alt="" height="313" src="https://images2.imgbox.com/32/1e/YnnkoWYn_o.png" width="1200"></h2> 
<pre><code class="language-Kotlin">fun Scaffold(
    modifier = Modifier,
    scaffoldState = rememberScaffoldState(),    //脚手架的状态（例如控件抽屉是否打开）
    topBar = {},        //顶部标题栏，通常是一个TopAppBar
    bottomBar = {},        //底部导航栏，通常是一个BottomNavigation
    snackbarHost: @Composable (SnackbarHostState) -&gt; Unit = { SnackbarHost(it) },    //用来展示SnackBar
    floatingActionButton = {},        //悬浮按钮
    floatingActionButtonPosition = FabPosition.End,        //悬浮按钮位置
    isFloatingActionButtonDocked = false,    //如果存在BottomBar，那么是否与BottomBar重叠一半的高度
    drawerContent = null,    //抽屉的内容
    drawerGesturesEnabled = true,    //否允许手势控制抽屉的打开和关闭
    drawerShape = MaterialTheme.shapes.large,    //抽屉的形状
    drawerElevation = DrawerDefaults.Elevation,    //抽屉的阴影高度
    drawerBackgroundColor = MaterialTheme.colors.surface,    //抽屉的背景色
    drawerContentColor = contentColorFor(drawerBackgroundColor),    //抽屉内容的背景色
    drawerScrimColor = DrawerDefaults.scrimColor,    //抽屉组件打开时屏幕剩余部分的遮盖颜色
    backgroundColor = MaterialTheme.colors.background,    //脚手架的背景色
    contentColor = contentColorFor(backgroundColor),        //脚手架内容背景色
    content: @Composable (PaddingValues) -&gt; Unit    //脚手架的内容
)</code></pre> 
<h3>5.1 标题栏 TopBar</h3> 
<pre><code class="language-Kotlin">fun TopAppBar(
    title: @Composable () -&gt; Unit,    //标题区域
    modifier: Modifier = Modifier,
    navigationIcon: @Composable () -&gt; Unit = {},    //左侧导航图标区域，一般为IconButton或IconToggleButton
    actions: @Composable RowScope.() -&gt; Unit = {},    //右侧菜单区域，默认布局是Row，一般为IconButton
    windowInsets: WindowInsets = TopAppBarDefaults.windowInsets,    //将尊重的窗口嵌入
    colors: TopAppBarColors = TopAppBarDefaults.smallTopAppBarColors(),    //用于不同状态下使用的颜色
    scrollBehavior: TopAppBarScrollBehavior? = null    //针对滚动的偏移设置
)</code></pre> 
<h3>5.2 导航栏 BottomBar</h3> 
<pre><code class="language-Kotlin">fun BottomNavigation(
    modifier: Modifier = Modifier,
    backgroundColor: Color = MaterialTheme.colors.primarySurface,    //背景色
    contentColor: Color = contentColorFor(backgroundColor),    //内容颜色
    elevation: Dp = BottomNavigationDefaults.Elevation,    //高度
    content: @Composable RowScope.() -&gt; Unit    //包裹的内容
)</code></pre> 
<pre><code class="language-Kotlin">fun RowScope.BottomNavigationItem(
    selected: Boolean,    //是否选中
    onClick: () -&gt; Unit,    //点击事件
    icon: @Composable () -&gt; Unit,    //图标
    modifier: Modifier = Modifier,
    enabled: Boolean = true,    //是否可点击
    label: @Composable (() -&gt; Unit)? = null,    //名称
    alwaysShowLabel: Boolean = true,    //名称是否一直显示
    interactionSource: MutableInteractionSource = remember { MutableInteractionSource() },
    selectedContentColor: Color = LocalContentColor.current,    //选中时文本标签和图标的颜色以及波纹的颜色
    unselectedContentColor: Color = selectedContentColor.copy(alpha = ContentAlpha.medium)    //未选中时文本标签和图标的颜色
)</code></pre> 
<h3>5.3 抽屉栏 Drawer</h3> 
<h3>5.4 悬浮按钮 FloatingActionBar</h3> 
<h3>5.5 SnackBar</h3> 
<pre><code class="language-Kotlin">Snackbar(
    modifier: Modifier = Modifier,//布局修饰
    action: @Composable (() -&gt; Unit)? = null,//动作
    actionOnNewLine: Boolean = false,//action是否应该放在单独的行上
    shape: Shape = MaterialTheme.shapes.small,//Snackbar的形状和阴影  
    backgroundColor: Color = SnackbarDefaults.backgroundColor,//背景颜色
    contentColor: Color = MaterialTheme.colors.surface,//内容颜色
    elevation: Dp = 6.dp,//阴影效果
    content: @Composable () -&gt; Unit//内容
)
Snackbar(
    snackbarData: SnackbarData,//通过SnackbarHostState显示的关于当前snackbar的数据
    modifier: Modifier = Modifier,//布局修饰
    actionOnNewLine: Boolean = false,//action是否应该放在单独的行上
    shape: Shape = MaterialTheme.shapes.small,//Snackbar的形状和阴影  
    backgroundColor: Color = SnackbarDefaults.backgroundColor,//背景颜色
    contentColor: Color = MaterialTheme.colors.surface,//内容颜色
    actionColor: Color = SnackbarDefaults.primaryActionColor,//动作颜色
    elevation: Dp = 6.dp//阴影效果
) </code></pre> 
<h3>5.6 内容</h3>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/261bedfa883baf5f66d9257fcb08b128/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">3_嵌入式Linux学习_入门_vim编辑器_三种模式及其常用命令&#43;配置文件.vimrc设置常用便捷功能（永久显示行数、快捷代码模板、设置缩进等）</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/e014836169573ebe3a4eb299622d0b33/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">（C语言）单链表基本操作</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>