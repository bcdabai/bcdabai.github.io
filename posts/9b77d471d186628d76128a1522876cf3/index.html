<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>内核调试器 - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="内核调试器" />
<meta property="og:description" content="Section #1. Kernel Debuggers
The instruction-level Kernel DeBugger (kdb) and the source-level Kernel GNU DeBugger (kgdb) are the two main Linux kernel debuggers. Whether to include a debugger as part of the stock kernel has been an oft-debated point in kernel mailing lists, but a lightweight version of kgdb has finally been integrated with the mainline kernel starting with the 2.6.26 release. Even if you prefer to stay away from the seemingly esoteric operation of kernel debuggers, you can glean information about kernel panics and peek at kernel variables via the plain GNU DeBugger (gdb)." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/9b77d471d186628d76128a1522876cf3/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2019-06-08T21:51:01+08:00" />
<meta property="article:modified_time" content="2019-06-08T21:51:01+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">内核调试器</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p style="margin-left:0cm;"><strong><span style="color:#404040;">Section #1. Kernel Debuggers</span></strong></p> 
<p style="margin-left:0cm;"><span style="color:#333333;">The instruction-level Kernel DeBugger (kdb) and the source-level Kernel GNU DeBugger (kgdb) are the two main Linux kernel debuggers. Whether to include a debugger as part of the stock kernel has been an oft-debated point in kernel mailing lists, but a lightweight version of kgdb has finally been integrated with the mainline kernel starting with the 2.6.26 release. Even if you prefer to stay away from the seemingly esoteric operation of kernel debuggers, you can glean information about kernel panics and peek at kernel variables via the plain GNU DeBugger (gdb). JTAG debuggers use hardware-assisted debugging and are powerful but expensive.</span></p> 
<p style="margin-left:0cm;"><span style="color:#333333;">Kernel debuggers make kernel internals more transparent. You can single-step through instructions, disassemble instructions, display and modify kernel variables, and look at stack traces. In this section, let’s learn the basics of kernel debuggers with the help of some examples.</span></p> 
<p style="margin-left:0cm;"><span style="color:#333333;">指令级内核</span><span style="color:#333333;">DeBugger</span><span style="color:#333333;">（</span><span style="color:#333333;">kdb</span><span style="color:#333333;">）和源代码级内核</span><span style="color:#333333;">GNU DeBugger</span><span style="color:#333333;">（</span><span style="color:#333333;">kgdb</span><span style="color:#333333;">）是两个主要的</span><span style="color:#333333;">Linux</span><span style="color:#333333;">内核调试器。是否将调试器作为内核的一部分，这是一个在内核邮件列表中经常被争论的问题，但是从</span><span style="color:#333333;">2.6.26</span><span style="color:#333333;">版本开始，</span><span style="color:#333333;">kgdb</span><span style="color:#333333;">的轻量级版本最终已经与主线内核集成在一起。即使您更喜欢远离看似神秘的内核调试器操作，您也可以通过</span><span style="color:#333333;">GNU DeBugger</span><span style="color:#333333;">（</span><span style="color:#333333;">gdb</span><span style="color:#333333;">）收集有关内核</span><span style="color:#333333;">panic</span><span style="color:#333333;">的信息并查看内核变量。</span><span style="color:#333333;"> JTAG</span><span style="color:#333333;">调试器使用硬件辅助调试，功能强大但价格昂贵。</span></p> 
<p style="margin-left:0cm;"><span style="color:#333333;">内核调试器使内核更加透明。您可以单步执行指令，反汇编指令，显示和修改内核变量，以及查看堆栈跟踪。在本节中，我们将借助一些示例了解内核调试器的基础知识。</span></p> 
<p style="margin-left:0cm;"><strong><span style="color:#404040;">Entering a Debugger</span></strong><strong><span style="color:#404040;">启动调试器</span></strong></p> 
<p style="margin-left:0cm;"><span style="color:#333333;">You can enter a kernel debugger in multiple ways. One way is to pass command-line arguments that ask the kernel to enter the debugger during boot. Another way is via software or hardware breakpoints. A <em>breakpoint</em> is an address where you want execution stopped and control transferred to the debugger. A software breakpoint replaces the instruction at that address with something else that causes an exception. You can set software breakpoints either using debugger commands or by inserting them into your code. For x86-based systems, you can set a software breakpoint in your kernel source code as follows:</span></p> 
<p style="margin-left:0cm;"><span style="color:#333333;">您可以通过多种方式启动内核调试程序。一种方法是通过命令行参数启动，要求内核在引导期间启动调试器。</span> <span style="color:#333333;">另一种方法是通过软件或硬件断点。</span> <span style="color:#333333;">断点是您希望执行停止并将控制权转移到调试器的地址。软件断点将该地址处的指令替换为导致异常的其他内容。您可以使用调试器命令或将它们插入代码来设置软件断点。对于基于</span><span style="color:#333333;">x86</span><span style="color:#333333;">的系统，您可以在内核源代码中设置软件断点，如下所示：</span></p> 
<p style="margin-left:0cm;"><span style="color:#333333;">asm(" int $3");</span></p> 
<p style="margin-left:0cm;"><span style="color:#333333;">Alternatively, you can invoke the </span><span style="color:#333333;">BREAKPOINT</span><span style="color:#333333;"> macro, which translates to the appropriate architecture-dependent instruction.</span></p> 
<p style="margin-left:0cm;"><span style="color:#333333;">或者，您可以调用</span><span style="color:#333333;">BREAKPOINT</span><span style="color:#333333;">宏，该宏转换为适当的体系结构相关指令。</span></p> 
<p style="margin-left:0cm;"><span style="color:#333333;">You can use hardware breakpoints in place of software breakpoints if the instruction where you need to stop is in flash memory, where it cannot be replaced by the debugger. A hardware breakpoint needs processor support. The corresponding address needs to be added to a debug register. You can only have as many hardware breakpoints as the number of debug registers supported by the processor.</span></p> 
<p style="margin-left:0cm;"><span style="color:#333333;">如果需要停止的指令位于闪存中，则可以使用硬件断点代替软件断点，调试器无法用软件断点取代硬件断点。硬件断点需要处理器支持。需要将相应的地址添加到调试寄存器中。</span> <span style="color:#333333;">您拥有的硬件断点的数量取决于处理器支持的调试寄存器的数量。</span></p> 
<p style="margin-left:0cm;"><span style="color:#333333;">You can also ask a debugger to set a <em>watchpoint</em> on a variable. The debugger stops execution whenever an instruction modifies data at the watchpoint address.</span></p> 
<p style="margin-left:0cm;"><span style="color:#333333;">您还可以要求调试器在变量上设置观察点。只要指令修改观察点地址处的数据，调试器就会停止执行。</span></p> 
<p style="margin-left:0cm;"><span style="color:#333333;">Yet another common method to enter a debugger is by pressing an attention key, but this won’t work in many instances. If your code is sitting in a tight loop after disabling interrupts, the kernel will not get a chance to process the attention key and enter the debugger. For example, you can’t enter the debugger via an attention key if your code does something like this:</span></p> 
<p style="margin-left:0cm;"><span style="color:#333333;">进入调试器的另一种常用方法是按下功能键，但这在许多情况下不起作用。如果在禁用中断后代码处于高速循环中，内核将无法响应功能键并进入调试器。例如，如果您的代码执行如下操作，则无法通过功能键进入调试器：</span></p> 
<p style="margin-left:0cm;"><span style="color:#333333;">unsigned long flags;<br><br> local_irq_save(flags);<br> while (1) continue;<br> local_irq_restore(flags);</span></p> 
<p style="margin-left:0cm;"><span style="color:#333333;">When control is transferred to the debugger, you can start your analysis using various debugger commands.</span></p> 
<p style="margin-left:0cm;"><span style="color:#333333;">当控制转移到调试器时，您可以使用各种调试器命令进行分析。</span></p> 
<p style="margin-left:0cm;"><strong><span style="color:#404040;">Kernel Debugger (kdb)</span></strong><strong><span style="color:#404040;">内核调试器</span></strong><strong><span style="color:#404040;">(KDB)</span></strong></p> 
<p style="margin-left:0cm;"><span style="color:#333333;">Kdb is an instruction-level debugger used for debugging kernel code and device drivers. Before you can use it, you need to patch your kernel sources with kdb support and recompile the kernel. (Refer to the section “</span><a href="https://learning.oreilly.com/library/view/debugging-linux-systems/9780137072446/ch01.html#ch01lev1sec6" rel="nofollow"><span style="color:#070707;">Downloads</span></a><span style="color:#333333;">” for information on downloading kdb patches.) The main advantage of kdb is that it’s easy to set up, because you don’t need an additional machine to do the debugging (unlike kgdb). The main disadvantage is that you need to correlate your sources with disassembled code (again, unlike kgdb).</span></p> 
<p style="margin-left:0cm;"><span style="color:#333333;">Kdb</span><span style="color:#333333;">是一个指令级调试器，用于调试内核代码和设备驱动程序。在使用</span><span style="color:#333333;">kdb</span><span style="color:#333333;">之前，需要把</span><span style="color:#333333;">kdb</span><span style="color:#333333;">的补丁打到内核源代码上并重新编译内核。（有关下载</span><span style="color:#333333;">kdb</span><span style="color:#333333;">补丁的信息，请参阅“下载”部分。）</span><span style="color:#333333;">kdb</span><span style="color:#333333;">的主要优点是它易于设置，因为您不需要额外的机器来进行调试（与</span><span style="color:#333333;">kgdb</span><span style="color:#333333;">不同）。主要缺点是您需要将源代码与反汇编代码关联起来（同样，与</span><span style="color:#333333;">kgdb</span><span style="color:#333333;">不同）。</span></p> 
<p style="margin-left:0cm;"><span style="color:#333333;">Let’s wet our toes in kdb with the help of an example. Here’s the crime scene: You have modified a kernel serial driver to work with your x86-based hardware, but the driver isn’t working, and you want kdb to help nab the culprit.</span></p> 
<p style="margin-left:0cm;"><span style="color:#333333;">让我们借助一个例子熟悉</span><span style="color:#333333;">kdb</span><span style="color:#333333;">。这是场景：您已经修改了内核串行驱动程序以使用基于</span><span style="color:#333333;">x86</span><span style="color:#333333;">的硬件，但驱动程序无法正常工作，您希望</span><span style="color:#333333;">kdb</span><span style="color:#333333;">帮助找到根本原因。</span></p> 
<p style="margin-left:0cm;"><span style="color:#333333;">Let’s start our search for fingerprints by setting a breakpoint at the serial driver </span><span style="color:#333333;">open()</span><span style="color:#333333;"> entry point. Remember, because kdb is not a source-level debugger, you need to open your sources and try to match the instructions with your C code. Let’s list the source snippet in question:</span></p> 
<p style="margin-left:0cm;"><span style="color:#333333;">让我们在串行驱动程序</span><span style="color:#333333;">open</span><span style="color:#333333;">（）入口点设置断点进行搜索。请记住，因为</span><span style="color:#333333;">kdb</span><span style="color:#333333;">不是源代码级调试器，所以您需要打开源代码并尝试将指令与</span><span style="color:#333333;">C</span><span style="color:#333333;">代码匹配。下面是有问题的源代码段：</span></p> 
<p style="margin-left:0cm;"><img alt="" class="has" height="277" src="https://images2.imgbox.com/bd/0e/YaD9zJS8_o.jpg" width="470"><span style="color:#333333;"> </span></p> 
<p style="margin-left:0cm;"><span style="color:#333333;">Press the Pause key and enter kdb. Let’s find out how the disassembled </span><span style="color:#333333;">rs_open()</span><span style="color:#333333;"> looks. The debug sessions shown here attach explanations using the → symbol.</span></p> 
<p style="margin-left:0cm;"><span style="color:#333333;">按“暂停”键并输入</span><span style="color:#333333;">kdb</span><span style="color:#333333;">。</span> <span style="color:#333333;">让我们看看</span><span style="color:#333333;">rs_open</span><span style="color:#333333;">（）反汇编代码。</span> <span style="color:#333333;">此处显示的反汇编代码使用→符号附加说明。</span></p> 
<p style="margin-left:0cm;"><img alt="" class="has" height="215" src="https://images2.imgbox.com/89/d3/Iu3U1Wme_o.jpg" width="442"><span style="color:#333333;"> </span></p> 
<p style="margin-left:0cm;"><span style="color:#333333;">Point A in the source code is a good place to attach a breakpoint because you can peek at both the </span><span style="color:#333333;">tty</span><span style="color:#333333;"> structure and the </span><span style="color:#333333;">info</span><span style="color:#333333;"> structure to see what’s going on.</span></p> 
<p style="margin-left:0cm;"><span style="color:#333333;">源代码中的</span><span style="color:#333333;">A</span><span style="color:#333333;">点是附加断点的好地方，因为您可以在此处查看</span><span style="color:#333333;">tty</span><span style="color:#333333;">结构体和</span><span style="color:#333333;">info</span><span style="color:#333333;">结构体的具体值，以查看发生了什么。</span></p> 
<p style="margin-left:0cm;"><span style="color:#333333;">Looking side by side at the source and the disassembly, </span><span style="color:#333333;">rs_open+0x5a</span><span style="color:#333333;"> corresponds to Point A. Note that correlation is easier if the kernel is compiled without optimization flags.</span></p> 
<p style="margin-left:0cm;"><span style="color:#333333;">并排查看源代码和反汇编，</span><span style="color:#333333;">rs_open + 0x5a</span><span style="color:#333333;">对应于</span><span style="color:#333333;">A</span><span style="color:#333333;">点。请注意，如果在没有优化标志的情况下编译内核，则源代码和反汇编代码更容易对应。</span></p> 
<p style="margin-left:0cm;"><span style="color:#333333;">Set a breakpoint at </span><span style="color:#333333;">rs_open+0x5a</span><span style="color:#333333;"> (which is address </span><span style="color:#333333;">0xc01cce5a</span><span style="color:#333333;">) and continue execution by exiting the debugger:</span></p> 
<p style="margin-left:0cm;"><span style="color:#333333;">在</span><span style="color:#333333;">rs_open + 0x5a</span><span style="color:#333333;">（地址</span><span style="color:#333333;">0xc01cce5a</span><span style="color:#333333;">）设置断点，然后退出调试器继续执行：</span></p> 
<p style="margin-left:0cm;"><img alt="" class="has" height="31" src="https://images2.imgbox.com/04/01/r5edlqiO_o.jpg" width="310"><span style="color:#333333;"> </span></p> 
<p style="margin-left:0cm;"><span style="color:#333333;">Now you need to get the kernel to call </span><span style="color:#333333;">rs_open()</span><span style="color:#333333;"> to hit the breakpoint. To trigger this, execute an appropriate user-space program. In this case, echo some characters to the corresponding serial port <em>(/dev/ttySX</em>):</span></p> 
<p style="margin-left:0cm;"><span style="color:#333333;">现在你需要让内核调用</span><span style="color:#333333;">rs_open</span><span style="color:#333333;">（）来命中断点。要触发此操作，请执行适当的用户空间程序。在这种情况下，将一些字符写入到相应的串口（</span><span style="color:#333333;">/ dev / ttySX</span><span style="color:#333333;">）：</span></p> 
<p style="margin-left:0cm;"><strong><span style="color:#333333;">bash&gt; echo "Anjali loves kerala monsoons" &gt; /dev/ttySX</span></strong></p> 
<p style="margin-left:0cm;"><span style="color:#333333;">This results in the invocation of </span><span style="color:#333333;">rs_open()</span><span style="color:#333333;">. The breakpoint gets hit, and kdb assumes control:</span></p> 
<p style="margin-left:0cm;"><span style="color:#333333;">这将调用</span><span style="color:#333333;">rs_open</span><span style="color:#333333;">（）。命中断点，</span><span style="color:#333333;">kdb</span><span style="color:#333333;">调试器控制内核：</span></p> 
<p style="margin-left:0cm;"><span style="color:#333333;">Entering kdb on processor 0 due to Breakpoint @ 0xc01cce5a kdb&gt;</span></p> 
<p style="margin-left:0cm;"><span style="color:#333333;">Let’s now find out the contents of the </span><span style="color:#333333;">info</span><span style="color:#333333;"> structure. If you look at the disassembly, one instruction before the breakpoint (</span><span style="color:#333333;">rs_open+0x56</span><span style="color:#333333;">), you see that the </span><span style="color:#333333;">EAX</span><span style="color:#333333;"> register contains the address of the </span><span style="color:#333333;">info</span><span style="color:#333333;"> structure. Let’s look at the register contents:</span></p> 
<p style="margin-left:0cm;"><span style="color:#333333;">现在让我们找出</span><span style="color:#333333;">info</span><span style="color:#333333;">结构体的内容。</span> <span style="color:#333333;">如果查看反汇编，从断点前的一条指令（</span><span style="color:#333333;">rs_open + 0x56</span><span style="color:#333333;">），您会看到</span><span style="color:#333333;">EAX</span><span style="color:#333333;">寄存器包含</span><span style="color:#333333;">info</span><span style="color:#333333;">结构体的地址。我们来看看寄存器内容：</span></p> 
<p style="margin-left:0cm;"><img alt="" class="has" height="47" src="https://images2.imgbox.com/68/15/2VFzu1e3_o.jpg" width="357"><span style="color:#333333;"> </span></p> 
<p style="margin-left:0cm;"><span style="color:#333333;">So, </span><span style="color:#333333;">0xcf1ae680</span><span style="color:#333333;"> is the address of the </span><span style="color:#333333;">info</span><span style="color:#333333;"> structure. Dump its contents using the </span><span style="color:#333333;">md</span><span style="color:#333333;"> command:</span></p> 
<p style="margin-left:0cm;"><span style="color:#333333;">所以，</span><span style="color:#333333;">0xcf1ae680</span><span style="color:#333333;">是</span><span style="color:#333333;">info</span><span style="color:#333333;">结构体的地址。使用</span><span style="color:#333333;">md</span><span style="color:#333333;">命令转储其内容：</span></p> 
<p style="margin-left:0cm;"><img alt="" class="has" height="56" src="https://images2.imgbox.com/d1/42/JPXi8w7a_o.jpg" width="384"><span style="color:#333333;"> </span></p> 
<p style="margin-left:0cm;"><span style="color:#333333;">To make sense of this dump, let’s look at the corresponding structure definition. </span><span style="color:#333333;">info</span><span style="color:#333333;"> is defined as </span><span style="color:#333333;">struct async_struct</span><span style="color:#333333;"> in <em>include/linux/serialP.h</em> as follows:</span></p> 
<p style="margin-left:0cm;"><span style="color:#333333;">为了理解这个转储，让我们看一下相应的结构体定义。</span><span style="color:#333333;">info</span><span style="color:#333333;">在</span><span style="color:#333333;">include / linux / serialP.h</span><span style="color:#333333;">中定义为</span><span style="color:#333333;">struct async_struct</span><span style="color:#333333;">，如下所示：</span></p> 
<p style="margin-left:0cm;"><img alt="" class="has" height="105" src="https://images2.imgbox.com/9a/99/xJqEBJs6_o.jpg" width="305"><span style="color:#333333;"> </span></p> 
<p style="margin-left:0cm;"><span style="color:#333333;">If you match the dump with the definition, </span><span style="color:#333333;">0x5301</span><span style="color:#333333;"> is the magic number and </span><span style="color:#333333;">0xABC</span><span style="color:#333333;"> is the I/O port. Well, isn’t this interesting! </span><span style="color:#333333;">0xABC</span><span style="color:#333333;"> doesn’t look like a valid port. If you have done enough serial port debugging, you know that the I/O port base addresses and IRQs are configured in <em>include/asmx86/serial.h</em> for x86-based hardware. Change the port definition to the correct value, recompile the kernel, and continue your testing!</span></p> 
<p style="margin-left:0cm;"><span style="color:#333333;">如果将转储与结构体定义匹配，则</span><span style="color:#333333;">0x5301</span><span style="color:#333333;">是幻数，</span><span style="color:#333333;">0xABC</span><span style="color:#333333;">是</span><span style="color:#333333;">I/O</span><span style="color:#333333;">端口。嗯，这是不是很有趣！</span><span style="color:#333333;">0xABC</span><span style="color:#333333;">看起来不像一个有效端口。如果您有足够的串口调试经验，您就会知道在基于</span><span style="color:#333333;">x86</span><span style="color:#333333;">硬件的</span><span style="color:#333333;">include/asmx86/serial.h</span><span style="color:#333333;">中配置了</span><span style="color:#333333;">I/O</span><span style="color:#333333;">端口基地址和</span><span style="color:#333333;">IRQ</span><span style="color:#333333;">。将端口定义更改为正确的值，重新编译内核，然后继续测试！</span></p> 
<p style="margin-left:0cm;"><strong><span style="color:#404040;">Kernel GNU Debugger (kgdb)</span></strong><strong><span style="color:#404040;">内核</span></strong><strong><span style="color:#404040;">GNU</span></strong><strong><span style="color:#404040;">调试器</span></strong></p> 
<p style="margin-left:0cm;"><span style="color:#333333;">Kgdb is a source-level debugger. It is easier to use than kdb because you don’t need to spend time correlating assembly code with your sources. However, it’s more difficult to set up because an additional machine is needed to front-end the debugging.</span></p> 
<p style="margin-left:0cm;"><span style="color:#333333;">Kgdb</span><span style="color:#333333;">是一个源代码级调试器。它比</span><span style="color:#333333;">kdb</span><span style="color:#333333;">更容易使用，因为您不需要花时间将汇编代码与源代码关联。但是，</span><span style="color:#333333;">Kgdb</span><span style="color:#333333;">设置起来比较困难，因为需要另外的机器来进行前端调试。</span></p> 
<p style="margin-left:0cm;"><span style="color:#333333;">You have to use gdb in tandem with kgdb to step through kernel code. gdb runs on the host machine, whereas the kgdb-enabled kernel runs on the target hardware. The host and the target are connected via a serial null-modem cable, as shown in </span><a href="https://learning.oreilly.com/library/view/debugging-linux-systems/9780137072446/ch01.html#ch01fig01" rel="nofollow"><span style="color:#070707;">Figure 1.1</span></a><span style="color:#333333;">.</span><span style="color:#666666;">[</span><a href="https://learning.oreilly.com/library/view/debugging-linux-systems/9780137072446/ch01.html#ftn.ch01fn01" rel="nofollow"><span style="color:#070707;">1</span></a><span style="color:#666666;">]</span></p> 
<p style="margin-left:0cm;"><span style="color:#666666;">[</span><a href="https://learning.oreilly.com/library/view/debugging-linux-systems/9780137072446/ch01.html#ch01fn01" rel="nofollow"><span style="color:#070707;">1</span></a><span style="color:#666666;">]</span><span style="color:#333333;"> <em>You can also launch kgdb debug sessions over Ethernet.</em></span></p> 
<p style="margin-left:0cm;"><strong><span style="color:#333333;">您必须把</span></strong><strong><span style="color:#333333;">kgdb</span></strong><strong><span style="color:#333333;">与</span></strong><strong><span style="color:#333333;">gdb</span></strong><strong><span style="color:#333333;">一起使用来单步执行内核代码。</span></strong><strong><span style="color:#333333;">gdb</span></strong><strong><span style="color:#333333;">在主机上运行，而启用</span></strong><strong><span style="color:#333333;">kgdb</span></strong><strong><span style="color:#333333;">的内核在目标硬件上运行。主机和目标硬件通过串行零调制解调器电缆连接，如图</span></strong><strong><span style="color:#333333;">1.1</span></strong><strong><span style="color:#333333;">所示。</span></strong></p> 
<p style="margin-left:0cm;"><strong><span style="color:#333333;">Figure 1.1. Kgdb setup</span></strong></p> 
<p style="margin-left:0cm;"><img alt="" class="has" height="180" src="https://images2.imgbox.com/52/e6/RLcYSOxi_o.jpg" width="500"><strong><span style="color:#333333;"> </span></strong></p> 
<p style="margin-left:0cm;"><span style="color:#333333;">You have to inform the kernel about the identity and baud rate of the serial port via command-line arguments. Depending on the bootloader used, add the following kernel arguments to either <em>syslinux.cfg, lilo.conf</em>, or <em>grub.conf</em>:</span></p> 
<p style="margin-left:0cm;"><span style="color:#333333;">您必须通过命令行参数通知内核有关串行端口的标识和波特率。根据所使用的引导加载程序，将以下内核参数添加到</span><span style="color:#333333;">syslinux.cfg</span><span style="color:#333333;">，</span><span style="color:#333333;">lilo.conf</span><span style="color:#333333;">或</span><span style="color:#333333;">grub.conf</span><span style="color:#333333;">：</span></p> 
<p style="margin-left:0cm;"><span style="color:#333333;">kgdbwait kgdb8250=X,115200</span></p> 
<p style="margin-left:0cm;"><span style="color:#333333;">kgdbwait</span><span style="color:#333333;"> asks the kernel to wait until a connection is established with the host-side gdb, </span><span style="color:#333333;">X</span><span style="color:#333333;"> is the serial port connected to the host, and </span><span style="color:#333333;">115200</span><span style="color:#333333;"> is the baud rate used for communication.</span></p> 
<p style="margin-left:0cm;"><span style="color:#333333;">kgdbwait</span><span style="color:#333333;">要求目标硬件内核等待与主机端</span><span style="color:#333333;">gdb</span><span style="color:#333333;">建立连接，</span><span style="color:#333333;">X</span><span style="color:#333333;">是连接到主机的串行端口，</span><span style="color:#333333;">115200</span><span style="color:#333333;">是用于通信的波特率。</span></p> 
<p style="margin-left:0cm;"><span style="color:#333333;">Now configure the same baud rate on the host side:</span></p> 
<p style="margin-left:0cm;"><span style="color:#333333;">在主机端配置相同的波特率：</span></p> 
<p style="margin-left:0cm;"><strong><span style="color:#333333;">bash&gt; stty speed 115200 &lt; /dev/ttySX</span></strong></p> 
<p style="margin-left:0cm;"><span style="color:#333333;">If your host computer is a laptop that does not have a serial port, you can use a USB-to-serial converter for the debug session. In that case, instead of <em>/dev/ttySX</em>, use the <em>/dev/ttyUSBX</em> node created by the usbserial driver.</span></p> 
<p style="margin-left:0cm;"><span style="color:#333333;">如果您的主机是没有串行端口的笔记本电脑，则可以使用</span><span style="color:#333333;">USB</span><span style="color:#333333;">转串口转换器进行调试。</span> <span style="color:#333333;">在这种情况下，使用</span><span style="color:#333333;">usbserial</span><span style="color:#333333;">驱动程序创建的</span><span style="color:#333333;">/dev/ttyUSBX</span><span style="color:#333333;">节点而不是</span><span style="color:#333333;">/dev/ttySX</span><span style="color:#333333;">。</span></p> 
<p style="margin-left:0cm;"><span style="color:#333333;">Let’s learn kgdb basics using the example of a buggy kernel module. Modules are easier to debug because the entire kernel need not be recompiled after making code changes, but remember to compile your module with the </span><span style="color:#333333;">-g</span><span style="color:#333333;"> option to generate symbolic information. Because modules are dynamically loaded, the debugger needs to be informed about the symbolic information that the module contains. </span><a href="https://learning.oreilly.com/library/view/debugging-linux-systems/9780137072446/ch01.html#ch01ex01" rel="nofollow"><span style="color:#070707;">Listing 1.1</span></a><span style="color:#333333;"> contains a buggy </span><span style="color:#333333;">trojan_function()</span><span style="color:#333333;">. Assume that it’s defined in <em>drivers/char/my_module.c</em>.</span></p> 
<p style="margin-left:0cm;"><span style="color:#333333;">让我们使用有</span><span style="color:#333333;">bug</span><span style="color:#333333;">的内核模块作为例子来学习</span><span style="color:#333333;">kgdb</span><span style="color:#333333;">基础知识。模块更容易调试，因为在更改代码后无需重新编译整个内核，但请记住使用</span><span style="color:#333333;">-g</span><span style="color:#333333;">选项编译模块以生成符号信息。由于模块是动态加载的，因此需要通知调试器模块包含的符号信息。</span> <span style="color:#333333;">清单</span><span style="color:#333333;">1.1</span><span style="color:#333333;">包含一个</span><span style="color:#333333;">buggy</span><span style="color:#333333;">函数</span><span style="color:#333333;"> trojan_function</span><span style="color:#333333;">（）。假设它在</span><span style="color:#333333;">drivers/char/my_module.c</span><span style="color:#333333;">中定义。</span></p> 
<p style="margin-left:0cm;"><strong><span style="color:#333333;">Listing 1.1. Buggy Function</span></strong></p> 
<p style="margin-left:0cm;"><img alt="" class="has" height="253" src="https://images2.imgbox.com/3d/9f/6q3wW3Ox_o.jpg" width="422"><span style="color:#333333;"> </span></p> 
<p style="margin-left:0cm;"><span style="color:#333333;">Insert <em>my_module.ko</em> on the target and look inside <em>/sys/module/my_module/sections/</em> to decipher ELF (<em>Executable and Linking Format</em>) section addresses.</span><span style="color:#666666;">[</span><a href="https://learning.oreilly.com/library/view/debugging-linux-systems/9780137072446/ch01.html#ftn.ch01fn02" rel="nofollow"><span style="color:#070707;">2</span></a><span style="color:#666666;">]</span><span style="color:#333333;"> The </span><span style="color:#333333;">.text</span><span style="color:#333333;"> section in ELF files contains code, </span><span style="color:#333333;">.data</span><span style="color:#333333;"> contains initialized variables, </span><span style="color:#333333;">.rodata</span><span style="color:#333333;"> contains initialized read-only variables such as strings, and </span><span style="color:#333333;">.bss</span><span style="color:#333333;"> contains variables that are not initialized during startup. The addresses of these sections are available in the form of the files <em>.text</em>, <em>.data</em>, <em>.rodata</em>, and <em>.bss</em> in <em>/sys/module/my_module/sections/</em> if you enable </span><span style="color:#333333;">CONFIG_KALLSYMS</span><span style="color:#333333;"> during kernel configuration. To obtain the code section address, for instance, do this:</span></p> 
<p style="margin-left:0cm;"><span style="color:#333333;">在目标机器上插入</span><span style="color:#333333;">my_module.ko</span><span style="color:#333333;">并查看</span><span style="color:#333333;">/sys/module/my_module/sections/</span><span style="color:#333333;">以解析</span><span style="color:#333333;">ELF</span><span style="color:#333333;">（可执行文件和链接格式）地址。</span><span style="color:#333333;">[2]</span><span style="color:#333333;"> ELF</span><span style="color:#333333;">文件中的</span><span style="color:#333333;">.text</span><span style="color:#333333;">部分包含代码，</span><span style="color:#333333;">.data</span><span style="color:#333333;">包含初始化变量，</span><span style="color:#333333;">.rodata</span><span style="color:#333333;">包含初始化的只读变量（如字符串），而</span><span style="color:#333333;">.bss</span><span style="color:#333333;">包含在启动期间未初始化的变量。如果在内核配置期间启用</span><span style="color:#333333;">CONFIG_KALLSYMS</span><span style="color:#333333;">，则可以在</span><span style="color:#333333;">/sys/module/my_module/sections/</span><span style="color:#333333;">中以文件</span><span style="color:#333333;">.text</span><span style="color:#333333;">，</span><span style="color:#333333;">.data</span><span style="color:#333333;">，</span><span style="color:#333333;">.rodata</span><span style="color:#333333;">和</span><span style="color:#333333;">.bss</span><span style="color:#333333;">的形式提供这些部分的地址。例如，要获取代码段地址，请执行以下操作：</span></p> 
<p style="margin-left:0cm;"><span style="color:#666666;">[</span><a href="https://learning.oreilly.com/library/view/debugging-linux-systems/9780137072446/ch01.html#ch01fn02" rel="nofollow"><span style="color:#070707;">2</span></a><span style="color:#666666;">]</span><span style="color:#333333;"> <em>If you still use a 2.4 kernel, get the section addresses using the –m option to insmod instead:</em></span></p> 
<p style="margin-left:0cm;"><img alt="" class="has" height="191" src="https://images2.imgbox.com/6d/34/QnOffRwq_o.jpg" width="472"><span style="color:#333333;"> </span></p> 
<p style="margin-left:0cm;"><strong><span style="color:#333333;">bash&gt; cat /sys/module/my_module/sections/.text</span></strong><br><span style="color:#333333;">0xe091a060</span></p> 
<p style="margin-left:0cm;"><span style="color:#333333;">More module load information is available from <em>/proc/modules</em> and <em>/proc/kallsyms</em>.</span></p> 
<p style="margin-left:0cm;"><span style="color:#333333;">After you have the section addresses, invoke gdb on the host-side machine:</span></p> 
<p style="margin-left:0cm;"><span style="color:#333333;">从</span><span style="color:#333333;">/proc/modules</span><span style="color:#333333;">和</span><span style="color:#333333;">/proc/kallsyms</span><span style="color:#333333;">获得更多模块加载信息。</span></p> 
<p style="margin-left:0cm;"><span style="color:#333333;">获得</span><span style="color:#333333;">section</span><span style="color:#333333;">地址后，在主机端计算机上调用</span><span style="color:#333333;">gdb</span><span style="color:#333333;">：</span></p> 
<p style="margin-left:0cm;"><strong><span style="color:#333333;">bash&gt; gdb vmlinux</span></strong><span style="color:#333333;">              → vmlinux is the uncompressed kernel vmlinux</span><span style="color:#333333;">是未压缩的内核</span><br><br><span style="color:#333333;">(gdb) target remote /dev/ttySX → Connect to the target</span></p> 
<p style="margin-left:0cm;"><span style="color:#333333;">Because you passed </span><span style="color:#333333;">kgdbwait</span><span style="color:#333333;"> as a kernel command-line argument, gdb gets control when the kernel boots on the target. Now inform gdb about the preceding section addresses using the </span><span style="color:#333333;">add-symbol-file</span><span style="color:#333333;"> command:</span></p> 
<p style="margin-left:0cm;"><span style="color:#333333;">因为您将</span><span style="color:#333333;">kgdbwait</span><span style="color:#333333;">作为内核命令行参数传递，所以当内核在目标机器上启动时，</span><span style="color:#333333;">gdb</span><span style="color:#333333;">会获得控制权。现在使用</span><span style="color:#333333;">add-symbol-file</span><span style="color:#333333;">命令通知</span><span style="color:#333333;">gdb</span><span style="color:#333333;">有关上一</span><span style="color:#333333;">section</span><span style="color:#333333;">的地址：</span></p> 
<p style="margin-left:0cm;"><img alt="" class="has" height="193" src="https://images2.imgbox.com/44/d2/88FS2gZJ_o.jpg" width="470"><span style="color:#333333;"> </span></p> 
<p style="margin-left:0cm;"><span style="color:#333333;">To debug the kernel panic, let’s set a breakpoint at </span><span style="color:#333333;">trojan_function()</span><span style="color:#333333;">:</span></p> 
<p style="margin-left:0cm;"><span style="color:#333333;">要调试内核</span><span style="color:#333333;">panic</span><span style="color:#333333;">，让我们在</span><span style="color:#333333;">trojan_function</span><span style="color:#333333;">（）中设置一个断点：</span></p> 
<p style="margin-left:0cm;"><img alt="" class="has" height="31" src="https://images2.imgbox.com/9d/3e/9h2p2wOK_o.jpg" width="381"><span style="color:#333333;"> </span></p> 
<p style="margin-left:0cm;"><span style="color:#333333;">When kgdb hits the breakpoint, let’s look at the stack trace, single-step until Point A, and display the value of </span><span style="color:#333333;">my_variable</span><span style="color:#333333;">:</span></p> 
<p style="margin-left:0cm;"><span style="color:#333333;">当</span><span style="color:#333333;">kgdb</span><span style="color:#333333;">到达断点时，让我们看一下堆栈跟踪，单步运行到</span><span style="color:#333333;">A</span><span style="color:#333333;">点，然后显示</span><span style="color:#333333;">my_variable</span><span style="color:#333333;">的值：</span></p> 
<p style="margin-left:0cm;"><img alt="" class="has" height="160" src="https://images2.imgbox.com/de/fc/QVansUlR_o.jpg" width="491"><span style="color:#333333;"> </span></p> 
<p style="margin-left:0cm;"><span style="color:#333333;">There is an obvious bug here. </span><span style="color:#333333;">my_variable</span><span style="color:#333333;"> points to </span><span style="color:#333333;">NULL</span><span style="color:#333333;"> because </span><span style="color:#333333;">trojan_function()</span><span style="color:#333333;"> forgot to allocate memory for it. Let’s just allocate the memory using kgdb, circumvent the kernel crash, and continue testing:</span></p> 
<p style="margin-left:0cm;"><span style="color:#333333;">这里有一个明显的错误。</span><span style="color:#333333;">my_variable</span><span style="color:#333333;">指向</span><span style="color:#333333;">NULL</span><span style="color:#333333;">，因为</span><span style="color:#333333;">trojan_function</span><span style="color:#333333;">（）忘记为它分配内存。让我们使用</span><span style="color:#333333;">kgdb</span><span style="color:#333333;">分配内存，避免内核崩溃，并继续测试：</span></p> 
<p style="margin-left:0cm;"><img alt="" class="has" height="69" src="https://images2.imgbox.com/34/1b/q22UG6U6_o.jpg" width="418"><span style="color:#333333;"> </span></p> 
<p style="margin-left:0cm;"><span style="color:#666666;">Note</span></p> 
<p style="margin-left:0cm;"><span style="color:#333333;">Kgdb ports are available for several architectures such as x86, ARM, and PowerPC. When you use kgdb to debug a target embedded device (instead of the PC shown in </span><a href="https://learning.oreilly.com/library/view/debugging-linux-systems/9780137072446/ch01.html#ch01fig01" rel="nofollow"><span style="color:#070707;">Figure 1.1</span></a><span style="color:#333333;">), the gdb front-end that you run on your host system needs to be compiled to work with your target platform. For example, to debug a device driver developed for an ARM-based embedded device from your x86-based host development system, you need to use the appropriately generated gdb, often named arm-linux-gdb. The exact name depends on the distribution you use.</span></p> 
<p style="margin-left:0cm;"><span style="color:#333333;">注意</span></p> 
<p style="margin-left:0cm;"><span style="color:#333333;">Kgdb</span><span style="color:#333333;">端口可用于多种体系结构，例如</span><span style="color:#333333;">x86</span><span style="color:#333333;">，</span><span style="color:#333333;">ARM</span><span style="color:#333333;">和</span><span style="color:#333333;">PowerPC</span><span style="color:#333333;">。使用</span><span style="color:#333333;">kgdb</span><span style="color:#333333;">调试嵌入式设备（而不是图</span><span style="color:#333333;">1.1</span><span style="color:#333333;">中所示的</span><span style="color:#333333;">PC</span><span style="color:#333333;">）时，需要编译在目标主机系统上运行的</span><span style="color:#333333;">gdb</span><span style="color:#333333;">前端以与目标平台一起使用。例如，从</span><span style="color:#333333;">x86</span><span style="color:#333333;">的主机开发系统调试为基于</span><span style="color:#333333;">ARM</span><span style="color:#333333;">的嵌入式设备开发的驱动程序，您需要使用基于</span><span style="color:#333333;">ARM</span><span style="color:#333333;">的</span><span style="color:#333333;">gdb</span><span style="color:#333333;">，通常名为</span><span style="color:#333333;">arm-linux-gdb</span><span style="color:#333333;">。</span> <span style="color:#333333;">确切的名称取决于您使用的</span><span style="color:#333333;">Linux</span><span style="color:#333333;">发行版。</span></p> 
<p style="margin-left:0cm;"><strong><span style="color:#404040;">GNU Debugger (gdb)</span></strong></p> 
<p style="margin-left:0cm;"><span style="color:#333333;">As previously mentioned, you can use plain gdb to gather some kernel debug information. However, you can’t step through kernel code, set breakpoints, or modify kernel variables. Let’s use gdb to debug the kernel panic caused by the buggy function in </span><a href="https://learning.oreilly.com/library/view/debugging-linux-systems/9780137072446/ch01.html#ch01ex01" rel="nofollow"><span style="color:#070707;">Listing 1.1</span></a><span style="color:#333333;">, but assume this time that </span><span style="color:#333333;">trojan_function()</span><span style="color:#333333;"> is compiled as part of the kernel and not as a module, because you can’t easily peek inside modules using gdb.</span></p> 
<p style="margin-left:0cm;"><span style="color:#333333;">如前所述，您可以使用</span><span style="color:#333333;">gdb</span><span style="color:#333333;">来收集一些内核调试信息。但是，您无法单步执行内核代码，设置断点或修改内核变量。</span> <span style="color:#333333;">让我们使用</span><span style="color:#333333;">gdb</span><span style="color:#333333;">来调试由清单</span><span style="color:#333333;">1.1</span><span style="color:#333333;">中的</span><span style="color:#333333;">buggy</span><span style="color:#333333;">函数引起的内核</span><span style="color:#333333;">panic</span><span style="color:#333333;">。假设这次</span><span style="color:#333333;">trojan_function</span><span style="color:#333333;">（）被编译为内核的一部分而不是模块，因为你不能轻易地使用</span><span style="color:#333333;">gdb</span><span style="color:#333333;">查看模块内部。</span></p> 
<p style="margin-left:0cm;"><span style="color:#333333;">This is part of the “oops” message generated when </span><span style="color:#333333;">trojan_function()</span><span style="color:#333333;"> is executed:</span></p> 
<p style="margin-left:0cm;"><span style="color:#333333;">这是执行</span><span style="color:#333333;">trojan_function</span><span style="color:#333333;">（）时生成的“</span><span style="color:#333333;">oops</span><span style="color:#333333;">”消息的一部分：</span></p> 
<p style="margin-left:0cm;"><img alt="" class="has" height="178" src="https://images2.imgbox.com/84/d7/O8AazbfU_o.jpg" width="443"><span style="color:#333333;"> </span></p> 
<p style="margin-left:0cm;"><span style="color:#333333;">Copy this cryptic “oops” message to <em>oops.txt</em> and use the <em>ksymoops</em> utility to obtain more verbose output. You might need to hand-copy the message if the system is hung:</span></p> 
<p style="margin-left:0cm;"><span style="color:#333333;">将这个神秘的“</span><span style="color:#333333;">oops</span><span style="color:#333333;">”消息复制到</span><span style="color:#333333;">oops.txt</span><span style="color:#333333;">并使用</span><span style="color:#333333;">ksymoops</span><span style="color:#333333;">应用程序获取更详细的输出。</span> <span style="color:#333333;">如果系统挂起，您可能需要手动复制消息：</span></p> 
<p style="margin-left:0cm;"><img alt="" class="has" height="123" src="https://images2.imgbox.com/54/39/4f76sJyL_o.jpg" width="421"><span style="color:#333333;"> </span></p> 
<p style="margin-left:0cm;"><span style="color:#333333;">2.6 kernels emit “oops” output that can be used as is without the need of decoding using <em>ksymoops</em> if you enable </span><span style="color:#333333;">CONFIG_KALLSYMS</span><span style="color:#333333;"> during kernel configuration.</span></p> 
<p style="margin-left:0cm;"><span style="color:#333333;">2.6</span><span style="color:#333333;">内核产生“</span><span style="color:#333333;">oops</span><span style="color:#333333;">”输出，如果在内核配置期间启用</span><span style="color:#333333;">CONFIG_KALLSYMS</span><span style="color:#333333;">，则可以按原样使用，而无需使用</span><span style="color:#333333;">ksymoops</span><span style="color:#333333;">进行解码。</span></p> 
<p style="margin-left:0cm;"><span style="color:#333333;">Looking at the preceding dump, the “oops” has occurred inside </span><span style="color:#333333;">trojan_-function()</span><span style="color:#333333;">. Let’s use gdb to obtain more information. In the following invocation, <em>vmlinux</em> is the uncompressed kernel image, and <em>/proc/kcore</em> is the kernel address space:</span></p> 
<p style="margin-left:0cm;"><span style="color:#333333;">查看前面的转储，“</span><span style="color:#333333;">oops</span><span style="color:#333333;">”发生在</span><span style="color:#333333;">trojan_-function</span><span style="color:#333333;">（）中。让我们使用</span><span style="color:#333333;">gdb</span><span style="color:#333333;">来获取更多信息。在下面的调用中，</span><span style="color:#333333;">vmlinux</span><span style="color:#333333;">是未压缩的内核，而</span><span style="color:#333333;">/proc/kcore</span><span style="color:#333333;">是内核地址空间：</span></p> 
<p style="margin-left:0cm;"><img alt="" class="has" height="66" src="https://images2.imgbox.com/95/db/EpihleHz_o.jpg" width="475"><span style="color:#333333;"> </span></p> 
<p style="margin-left:0cm;"><span style="color:#333333;">Repeated access to the same variable will not yield refreshed values due to gdb’s cached access. You can force a fresh access by rereading the core file using gdb’s </span><span style="color:#333333;">core-file</span><span style="color:#333333;"> command. Let’s now look at the disassembly of </span><span style="color:#333333;">trojan_function()</span><span style="color:#333333;">:</span></p> 
<p style="margin-left:0cm;"><span style="color:#333333;">由于</span><span style="color:#333333;">gdb</span><span style="color:#333333;">的缓存访问，重复访问同一变量不会刷新改变量。您可以使用</span><span style="color:#333333;">gdb</span><span style="color:#333333;">的</span><span style="color:#333333;">core-file</span><span style="color:#333333;">命令重新读取核心文件，从而强制进行刷新。现在让我们看一下</span><span style="color:#333333;">trojan_function</span><span style="color:#333333;">（）的反汇编代码：</span></p> 
<p style="margin-left:0cm;"><img alt="" class="has" height="49" src="https://images2.imgbox.com/fa/c7/ZCAbCOqI_o.jpg" width="463"><span style="color:#333333;"> </span></p> 
<p style="margin-left:0cm;"><span style="color:#333333;">trojan_function()</span><span style="color:#333333;"> looks laconic when seen in assembly due to compiler optimizations. It’s effectively copying the contents of address </span><span style="color:#333333;">0xab</span><span style="color:#333333;"> to the </span><span style="color:#333333;">EAX</span><span style="color:#333333;"> register, which holds the return value from functions on x86-based systems. But </span><span style="color:#333333;">0xab</span><span style="color:#333333;"> does not look like a valid kernel address! Fix the bug by allocating valid memory space to </span><span style="color:#333333;">my_-variable</span><span style="color:#333333;">, recompile, and continue your testing.</span></p> 
<p style="margin-left:0cm;"><span style="color:#333333;">由于编译器优化，</span><span style="color:#333333;">trojan_function</span><span style="color:#333333;">（）在汇编中看起来很简洁。它将地址</span><span style="color:#333333;">0xab</span><span style="color:#333333;">的内容复制到</span><span style="color:#333333;">EAX</span><span style="color:#333333;">寄存器，该寄存器保存来自基于</span><span style="color:#333333;">x86</span><span style="color:#333333;">的系统上的函数的返回值。但</span><span style="color:#333333;">0xab</span><span style="color:#333333;">看起来不像一个有效的内核地址！通过为</span><span style="color:#333333;">my_-variable</span><span style="color:#333333;">分配有效的内存空间，重新编译并继续测试来修复错误。</span></p> 
<p style="margin-left:0cm;"><strong><span style="color:#404040;">JTAG Debuggers</span></strong></p> 
<p style="margin-left:0cm;"><span style="color:#333333;">JTAG debuggers use hardware-assist to debug code. You need specialized monitor hardware</span><span style="color:#666666;">[</span><a href="https://learning.oreilly.com/library/view/debugging-linux-systems/9780137072446/ch01.html#ftn.ch01fn03" rel="nofollow"><span style="color:#070707;">3</span></a><span style="color:#666666;">]</span><span style="color:#333333;"> and a front-end user interface (some JTAG debuggers use gdb as the front-end) to step through code. JTAG can also be used for purposes other than debugging, such as burning code onto onboard flash memory. JTAG connectors are common on development boards but are usually not part of production units.</span></p> 
<p style="margin-left:0cm;"><span style="color:#333333;">JTAG</span><span style="color:#333333;">调试器使用硬件来辅助调试代码。您需要专门的监视器硬件</span><span style="color:#333333;">[3]</span><span style="color:#333333;">和前端用户界面（一些</span><span style="color:#333333;">JTAG</span><span style="color:#333333;">调试器使用</span><span style="color:#333333;">gdb</span><span style="color:#333333;">作为前端）来单步执行代码。</span><span style="color:#333333;">JTAG</span><span style="color:#333333;">还可用于调试以外的目的，例如将代码刻录到板载闪存上。</span><span style="color:#333333;">JTAG</span><span style="color:#333333;">连接器在开发板上很常见，但通常不是生产系统的一部分。</span></p> 
<p style="margin-left:0cm;"><span style="color:#666666;">[</span><a href="https://learning.oreilly.com/library/view/debugging-linux-systems/9780137072446/ch01.html#ch01fn03" rel="nofollow"><span style="color:#070707;">3</span></a><span style="color:#666666;">]</span><span style="color:#333333;"> <em>Some JTAG debuggers work with several processor architectures if you suitably replace the probe that connects the debugger to the target board.</em></span></p> 
<p style="margin-left:0cm;"><span style="color:#333333;">JTAG debuggers usually connect to target hardware via serial port, USB, or Ethernet. With Ethernet, you can remotely access the JTAG debugger, and therefore the target board, even if the board itself does not possess a network interface.</span></p> 
<p style="margin-left:0cm;"><span style="color:#333333;">JTAG</span><span style="color:#333333;">调试器通常通过串行端口，</span><span style="color:#333333;">USB</span><span style="color:#333333;">或以太网连接到目标硬件。使用以太网，即使电路板本身没有网络接口，您也可以通过远程访问</span><span style="color:#333333;">JTAG</span><span style="color:#333333;">调试器，从而远程访问目标板。</span></p> 
<p style="margin-left:0cm;"><a href="https://learning.oreilly.com/library/view/debugging-linux-systems/9780137072446/ch01.html#ch01fig02" rel="nofollow"><span style="color:#070707;">Figure 1.2</span></a><span style="color:#333333;"> shows a JTAG-based remote debugging session in action. The JTAG debugger used in this scenario supports a gdb front end. The development host and the JTAG hardware are connected to an Ethernet LAN. The debug serial port on the target hardware is connected to the serial port on the JTAG box. </span><a href="https://learning.oreilly.com/library/view/debugging-linux-systems/9780137072446/ch01.html#ch01fig02" rel="nofollow"><span style="color:#070707;">Figure 1.2</span></a><span style="color:#333333;"> achieves remote debugging on the Linux development host using five terminal sessions. Terminal 1 runs gdb, which connects to the JTAG box over the network using telnet:</span></p> 
<p style="margin-left:0cm;"><span style="color:#333333;">图</span><span style="color:#333333;">1.2</span><span style="color:#333333;">显示了一个基于</span><span style="color:#333333;">JTAG</span><span style="color:#333333;">的远程调试会话。此方案中使用的</span><span style="color:#333333;">JTAG</span><span style="color:#333333;">调试器支持</span><span style="color:#333333;">gdb</span><span style="color:#333333;">前端。开发主机和</span><span style="color:#333333;">JTAG</span><span style="color:#333333;">硬件连接到以太网</span><span style="color:#333333;">LAN</span><span style="color:#333333;">。目标硬件上的调试串行端口连接到</span><span style="color:#333333;">JTAG</span><span style="color:#333333;">盒上的串行端口。图</span><span style="color:#333333;">1.2</span><span style="color:#333333;">使用五个终端会话在</span><span style="color:#333333;">Linux</span><span style="color:#333333;">开发主机上实现远程调试。终端</span><span style="color:#333333;">1</span><span style="color:#333333;">运行</span><span style="color:#333333;">gdb</span><span style="color:#333333;">，它使用</span><span style="color:#333333;">telnet</span><span style="color:#333333;">通过网络连接到</span><span style="color:#333333;">JTAG</span><span style="color:#333333;">盒：</span></p> 
<p style="margin-left:0cm;"><img alt="" class="has" height="68" src="https://images2.imgbox.com/91/db/R0jzG97W_o.jpg" width="500"><span style="color:#333333;"> </span></p> 
<p style="margin-left:0cm;"><strong><span style="color:#333333;">Figure 1.2. An example JTAG-based remote debug setup</span></strong></p> 
<p style="margin-left:0cm;"><img alt="" class="has" height="481" src="https://images2.imgbox.com/bb/ad/ZsbQbcbZ_o.jpg" width="500"><strong><span style="color:#333333;"> </span></strong></p> 
<p style="margin-left:0cm;"><span style="color:#333333;">To debug boot portions of the kernel, for example, set a gdb breakpoint at </span><span style="color:#333333;">start_kernel()</span><span style="color:#333333;">. (You can find its address from <em>System.map</em>, which is generated in the root of your source tree when you build the kernel.)</span></p> 
<p style="margin-left:0cm;"><span style="color:#333333;">例如，要调试内核的引导部分，请在</span><span style="color:#333333;">start_kernel</span><span style="color:#333333;">（）中设置</span><span style="color:#333333;">gdb</span><span style="color:#333333;">断点。（您可以从</span><span style="color:#333333;">System.map</span><span style="color:#333333;">中找到它的地址，这是在构建内核时在源代码树的</span><span style="color:#333333;">root</span><span style="color:#333333;">目录中生成的。）</span></p> 
<p style="margin-left:0cm;"><span style="color:#333333;">Terminal 2 attaches a serial console to the target. A telnet client running on Terminal 2 connects to a prespecified TCP port on the JTAG box, which is configured (using Terminal 3) to tunnel data arriving via its serial port:</span></p> 
<p style="margin-left:0cm;"><span style="color:#333333;">终端</span><span style="color:#333333;">2</span><span style="color:#333333;">将串行控制台连接到目标机器。在终端</span><span style="color:#333333;">2</span><span style="color:#333333;">上运行的</span><span style="color:#333333;">telnet</span><span style="color:#333333;">客户端连接到</span><span style="color:#333333;">JTAG</span><span style="color:#333333;">盒上的预先指定的</span><span style="color:#333333;">TCP</span><span style="color:#333333;">端口，该端口被配置（使用终端</span><span style="color:#333333;">3</span><span style="color:#333333;">）为封装通过其串行端口到达的数据：</span></p> 
<p style="margin-left:0cm;"><img alt="" class="has" height="68" src="https://images2.imgbox.com/24/e2/0eQu2WAp_o.jpg" width="511"><span style="color:#333333;"> </span></p> 
<p style="margin-left:0cm;"><span style="color:#333333;">This is equivalent to running an emulator such as <em>minicom</em> after directly connecting the target’s debug serial port to the host (instead of to the JTAG box, as shown in </span><a href="https://learning.oreilly.com/library/view/debugging-linux-systems/9780137072446/ch01.html#ch01fig02" rel="nofollow"><span style="color:#070707;">Figure 1.2</span></a><span style="color:#333333;">), but that’ll constrain the host to be physically adjacent to the target.</span></p> 
<p style="margin-left:0cm;"><span style="color:#333333;">这相当于在将目标机器的串行端口直接连接到主机（而不是</span><span style="color:#333333;">JTAG</span><span style="color:#333333;">盒，如图</span><span style="color:#333333;">1.2</span><span style="color:#333333;">所示）之后运行模拟器（如</span><span style="color:#333333;">minicom</span><span style="color:#333333;">），但这种情况需要主机在物理上与目标机器相邻。</span></p> 
<p style="margin-left:0cm;"><span style="color:#333333;">Terminal 3 telnets to the JTAG box and offers debugger-specific semantics. You can use it, for example, to do the following:</span></p> 
<p style="margin-left:0cm;"><span style="color:#333333;">终端</span><span style="color:#333333;">3 telnet</span><span style="color:#333333;">到</span><span style="color:#333333;">JTAG</span><span style="color:#333333;">盒并提供调试器特定的语义。</span> <span style="color:#333333;">例如，您可以使用它来执行以下操作：</span></p> 
<p style="margin-left:0cm;"><span style="color:#333333;">• Pull a JTAG definition script over TFTP from the host and execute it during JTAG boot. A JTAG definition script usually initializes the processor, clock registers, chip select registers, and memory banks. After this is done, the JTAG hardware is ready to download code onto the target and execute it. The JTAG manufacturer usually provides definition files for all supported platforms, so you are likely to have a close starting point for your board.</span> <span style="color:#333333;">从主机上通过</span><span style="color:#333333;">TFTP</span><span style="color:#333333;">获得</span><span style="color:#333333;">JTAG</span><span style="color:#333333;">定义脚本，并在</span><span style="color:#333333;">JTAG</span><span style="color:#333333;">引导期间执行它。</span><span style="color:#333333;"> JTAG</span><span style="color:#333333;">定义脚本通常初始化处理器，时钟寄存器，芯片选择寄存器和存储体。完成此操作后，</span><span style="color:#333333;">JTAG</span><span style="color:#333333;">硬件就可以将代码下载到目标机器并执行它。</span><span style="color:#333333;">JTAG</span><span style="color:#333333;">制造商通常为所有支持的平台提供定义文件，因此您可能会为您的电路板提供一个紧密的起点。</span></p> 
<p style="margin-left:0cm;"><span style="color:#333333;">• Download your bootloader, kernel, or stand-alone code from the host over TFTP, to flash memory, or RAM on the target. File formats such as ELF and binary are usually supported by JTAG debuggers.</span> <span style="color:#333333;">通过</span><span style="color:#333333;">TFTP</span><span style="color:#333333;">从主机下载引导加载程序，内核或独立代码，到目标机器上的闪存或</span><span style="color:#333333;">RAM</span><span style="color:#333333;">。</span><span style="color:#333333;">JTAG</span><span style="color:#333333;">调试器通常支持</span><span style="color:#333333;">ELF</span><span style="color:#333333;">和二进制等文件格式。</span></p> 
<p style="margin-left:0cm;"><span style="color:#333333;">• Single-step code, set breakpoints, examine registers, and dump memory regions.</span> <span style="color:#333333;">单步执行代码，设置断点，检查寄存器和转储内存区域。</span></p> 
<p style="margin-left:0cm;"><span style="color:#333333;">• Reset the target.</span> <span style="color:#333333;">重置目标机器。</span></p> 
<p style="margin-left:0cm;"><span style="color:#333333;">JTAG debugging can be flaky at times, so if you are debugging remotely, it might be a good idea to power the target via a remote power control switch, as shown in </span><a href="https://learning.oreilly.com/library/view/debugging-linux-systems/9780137072446/ch01.html#ch01fig02" rel="nofollow"><span style="color:#070707;">Figure 1.2</span></a><span style="color:#333333;">. That way, you can hard-reset the target from the host using a web browser, as shown in Terminal 4. You can also choose to power the JTAG hardware via a remote power switch. That enables you to test run a bootloader directly from flash without the intervention of JTAG and its definition files.</span></p> 
<p style="margin-left:0cm;"><span style="color:#333333;">JTAG</span><span style="color:#333333;">调试有时可能不稳定，因此如果您进行远程调试，最好通过远程电源控制开关为目标机器供电，如图</span><span style="color:#333333;">1.2</span><span style="color:#333333;">所示。这样，您可以使用</span><span style="color:#333333;">Web</span><span style="color:#333333;">浏览器从主机硬重置目标机器，如终端</span><span style="color:#333333;">4</span><span style="color:#333333;">所示。您还可以选择通过远程电源开关为</span><span style="color:#333333;">JTAG</span><span style="color:#333333;">硬件供电。这使您可以直接从闪存测试运行引导加载程序，而无需</span><span style="color:#333333;">JTAG</span><span style="color:#333333;">及其定义文件的干预。</span></p> 
<p style="margin-left:0cm;"><span style="color:#333333;">If the target board possesses a network interface, it can mount its root filesystem over NFS from the development host. Terminal 5 on the host operates locally on the exported root filesystem.</span><span style="color:#666666;">[</span><a href="https://learning.oreilly.com/library/view/debugging-linux-systems/9780137072446/ch01.html#ftn.ch01fn04" rel="nofollow"><span style="color:#070707;">4</span></a><span style="color:#666666;">]</span></p> 
<p style="margin-left:0cm;"><span style="color:#666666;">[</span><a href="https://learning.oreilly.com/library/view/debugging-linux-systems/9780137072446/ch01.html#ch01fn04" rel="nofollow"><span style="color:#070707;">4</span></a><span style="color:#666666;">]</span><span style="color:#333333;"> <em>You might have more such terminals depending on your debug scenario. If you use an oscilloscope that has remote display capabilities, for example, you can operate it via a web browser on another terminal.</em></span></p> 
<p style="margin-left:0cm;"><span style="color:#333333;">如果目标板拥有网络接口，它可以从开发主机通过</span><span style="color:#333333;">NFS</span><span style="color:#333333;">挂载其</span><span style="color:#333333;">root</span><span style="color:#333333;">文件系统。主机上的终端</span><span style="color:#333333;">5</span><span style="color:#333333;">在导出的</span><span style="color:#333333;">root</span><span style="color:#333333;">文件系统上本地运行。</span><span style="color:#333333;">[4]</span></p> 
<p style="margin-left:0cm;"><span style="color:#333333;">If your team is scattered geographically, run Terminals 1 through 5 within an environment such as Virtual Network Computing (VNC). If VNC is not already part of your distribution, download it from </span><a href="http://www.realvnc.com/" rel="nofollow"><span style="color:#070707;">www.realvnc.com</span></a><span style="color:#333333;">. With such a setup, you can debug the electrons on your remote board from the comfort of your home! Some JTAG vendors provide a sophisticated integrated development environment</span><span style="color:#666666;">[</span><a href="https://learning.oreilly.com/library/view/debugging-linux-systems/9780137072446/ch01.html#ftn.ch01fn05" rel="nofollow"><span style="color:#070707;">5</span></a><span style="color:#666666;">]</span><span style="color:#333333;"> that encompasses all the functionalities previously detailed, so you don’t need to manage VNC terminal sessions if you’re using one of those.</span></p> 
<p style="margin-left:0cm;"><span style="color:#333333;">如果您的团队在地理位置上分散，请在虚拟网络计算（</span><span style="color:#333333;">VNC</span><span style="color:#333333;">）等环境中运行终端</span><span style="color:#333333;">1</span><span style="color:#333333;">到</span><span style="color:#333333;">5</span><span style="color:#333333;">。</span> <span style="color:#333333;">如果</span><span style="color:#333333;">VNC</span><span style="color:#333333;">尚未成为您的发行版的一部分，请从</span><span style="color:#333333;">www.realvnc.com</span><span style="color:#333333;">下载安装。通过这样的设置，您可以在舒适的家中远程调试电路板！一些</span><span style="color:#333333;">JTAG</span><span style="color:#333333;">供应商提供了一个复杂的集成开发环境</span><span style="color:#333333;">[5]</span><span style="color:#333333;">，它包含了之前详细介绍的所有功能，因此如果您使用其中一个，则无需管理</span><span style="color:#333333;">VNC</span><span style="color:#333333;">终端会话。</span></p> 
<p style="margin-left:0cm;"><span style="color:#666666;">[</span><a href="https://learning.oreilly.com/library/view/debugging-linux-systems/9780137072446/ch01.html#ch01fn05" rel="nofollow"><span style="color:#070707;">5</span></a><span style="color:#666666;">]</span><span style="color:#333333;"> <em>Although JTAG hardware is independent of the target operating system, the front-end interface is likely to have OS dependencies.</em></span></p> 
<p style="margin-left:0cm;"><span style="color:#333333;">During hardware bring up, when you are porting your bootloader or other stand-alone code to the target, it’s a good idea to first generate an ELF image and debug it from RAM before running it from flash. Remember, however, to eliminate bootloader initializations that duplicate the ones performed by the JTAG definition script.</span></p> 
<p style="margin-left:0cm;"><span style="color:#333333;">在硬件启动期间，当您移植</span><span style="color:#333333;">bootloader</span><span style="color:#333333;">或其他独立代码到目标机器时，最好首先生成</span><span style="color:#333333;">ELF</span><span style="color:#333333;">映像并从</span><span style="color:#333333;">RAM</span><span style="color:#333333;">调试它，在移植成功后，再从闪存运行它。但请记住，要消除重复执行</span><span style="color:#333333;">JTAG</span><span style="color:#333333;">定义脚本带来的</span><span style="color:#333333;">bootloader</span><span style="color:#333333;">多次初始化的影响。</span></p> 
<p style="margin-left:0cm;"><span style="color:#333333;">A key advantage of JTAG debuggers is that you can use a single tool to debug the different pieces that constitute your firmware solution. So, you can use the same debugger to debug the BIOS, bootloader, base kernel, device driver modules, and user-space applications, at source level.</span></p> 
<p style="margin-left:0cm;"><span style="color:#333333;">JTAG</span><span style="color:#333333;">调试器的一个关键优势是您可以使用单个工具来调试固件</span><span style="color:#333333;">(Firmware)</span><span style="color:#333333;">的不同部分。</span> <span style="color:#333333;">因此，您可以使用相同的调试器在源代码级别调试</span><span style="color:#333333;">BIOS</span><span style="color:#333333;">，</span><span style="color:#333333;">bootloader</span><span style="color:#333333;">，基本内核，设备驱动程序模块和用户空间应用程序。</span></p> 
<p style="margin-left:0cm;"><strong><span style="color:#404040;">Downloads</span></strong></p> 
<p style="margin-left:0cm;"><span style="color:#333333;">You can download kdb patches for the x86 and IA64 architectures from </span><a href="http://oss.sgi.com/projects/kdb" rel="nofollow"><span style="color:#070707;">http://oss.sgi.com/projects/kdb</span></a><span style="color:#333333;">. Each supported kernel version needs two patches: a common one and an architecture-dependent one.</span></p> 
<p style="margin-left:0cm;"><span style="color:#333333;">您可以从</span><span style="color:#333333;">http://oss.sgi.com/projects/kdb</span><span style="color:#333333;">下载</span><span style="color:#333333;">x86</span><span style="color:#333333;">和</span><span style="color:#333333;">IA64</span><span style="color:#333333;">体系结构的</span><span style="color:#333333;">kdb</span><span style="color:#333333;">补丁。每个被支持的内核版本都需要两个补丁：一个是普通的，另一个是与体系结构相关的。</span></p> 
<p style="margin-left:0cm;"><span style="color:#333333;">The home page for the kgdb project is </span><a href="http://kgdb.sourceforge.net/" rel="nofollow"><span style="color:#070707;">http://kgdb.sourceforge.net</span></a><span style="color:#333333;">. The website also has documentation on configuring and using kgdb.</span></p> 
<p style="margin-left:0cm;"><span style="color:#333333;">kgdb</span><span style="color:#333333;">项目的主页是</span><span style="color:#333333;">http://kgdb.sourceforge.net</span><span style="color:#333333;">。该网站还提供配置和使用</span><span style="color:#333333;">kgdb</span><span style="color:#333333;">的文档。</span></p> 
<p style="margin-left:0cm;"><span style="color:#333333;">If your Linux distribution does not already contain gdb, you can obtain it from </span><a href="http://www.gnu.org/software/gdb/gdb.html" rel="nofollow"><span style="color:#070707;">www.gnu.org/software/gdb/gdb.html</span></a><span style="color:#333333;">.</span></p> 
<p style="margin-left:0cm;"><span style="color:#333333;">如果您的</span><span style="color:#333333;">Linux</span><span style="color:#333333;">发行版尚未包含</span><span style="color:#333333;">gdb</span><span style="color:#333333;">，则可以从</span><span style="color:#333333;">www.gnu.org/software/gdb/gdb.html</span><span style="color:#333333;">获取。</span></p> 
<p style="margin-left:0cm;"> </p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/1405aa9ae7fb0c21c1b5d1f5a6a62582/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">SpringBoot 日志 Log4j比System.out.println的优势</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/80790ea30956d66620b5b98172f8aae9/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">产品经理的六大工作职责——最简洁</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>