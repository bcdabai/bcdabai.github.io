<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>嵌入式Linux开发工具 - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="嵌入式Linux开发工具" />
<meta property="og:description" content="一、文本编辑器 vi vim gedit gvim vim 可高度自定义，适合单个软件开发
二、编译器 gcc
三、库
四、调试器 gdb 资源占有少，免费开源，缺少图像显示，适合小程序开发
五、工程管理器 make（批量处理）自动化编译，提高开发效率
为什么使用要学Linux工具，它的优势和作用？
1、可定制 2、开源 3、便携 4、体积小 5、提高开发效率
其他开发环境和IDE
vs code 相对其他IDE（集成开发环境）小，便捷，功能没有VS 2019 Qt强大
vs 2019 功能强大，体积大，响应慢
Qt
1、文本编译器 vim（单体文件编辑，可高度定制）
三种模式 命令行模式 esc
插入模式 a或I
底行模式 命令行模式下 ”：“ wq 保存退出 q！不保存退出
2、编译器 gcc
编译过程:1、预处理 头文件展开，宏定义替换，条件编译 编译选项 -E
2、编译 检查错误，生成汇编文件后缀名.s 编译选项 -s
3.汇编 编译成二进制 后缀名.o 编译选项 -c
4、链接 编译成了执行文件 后缀名.elf .elf特点：
ELF：可执行连接文件格式。
ELF文件优点：
1. 支持不同平台上的交叉编译和交叉链接，可移植性性强
2. 在执行时支持动态链接共享库" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/083df3f56a8ef7195ced6cd0d11d2949/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2021-11-06T16:36:33+08:00" />
<meta property="article:modified_time" content="2021-11-06T16:36:33+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">嵌入式Linux开发工具</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p>一、文本编辑器    vi vim gedit gvim vim 可高度自定义，适合单个软件开发</p> 
<p>二、编译器           gcc</p> 
<p>三、库</p> 
<p>四、调试器           gdb   资源占有少，免费开源，缺少图像显示，适合小程序开发</p> 
<p>五、工程管理器    make（批量处理）自动化编译，提高开发效率<br>  </p> 
<p>为什么使用要学Linux工具，它的优势和作用？</p> 
<p>1、可定制  2、开源  3、便携  4、体积小  5、提高开发效率</p> 
<p>其他开发环境和IDE</p> 
<p> vs code           相对其他IDE（集成开发环境）小，便捷，功能没有VS 2019 Qt强大</p> 
<p>vs  2019           功能强大，体积大，响应慢</p> 
<p>Qt</p> 
<p></p> 
<p>1、文本编译器 vim（单体文件编辑，可高度定制）</p> 
<p> 三种模式 </p> 
<p>命令行模式   esc</p> 
<p>插入模式       a或I</p> 
<p>底行模式       命令行模式下 ”：“ wq 保存退出     q！不保存退出</p> 
<p>2、编译器 gcc</p> 
<p>编译过程:1、预处理  头文件展开，宏定义替换，条件编译 编译选项  -E</p> 
<p>                2、编译     检查错误，生成汇编文件后缀名.s      编译选项  -s</p> 
<p>                3.汇编       编译成二进制 后缀名.o                       编译选项   -c</p> 
<p>                4、链接    编译成了执行文件 后缀名.elf  </p> 
<p>                    </p> 
<p>.elf特点：</p> 
<p>ELF：可执行连接文件格式。</p> 
<p>ELF文件优点：</p> 
<p>1. 支持不同平台上的交叉编译和交叉链接，可移植性性强</p> 
<p>2. 在执行时支持动态链接共享库</p> 
<p>特点：</p> 
<p>1、包含多平台相关信息，信息编译时由编译器决定</p> 
<p>2、生成一种与位置无关的代码——地址无关码，这种代码可在任意位置正确运行，不受绝对地址影响</p> 
<p>3、有GNU协议下的大量工具支持</p> 
<p>三级优化</p> 
<p>               O0不优化</p> 
<p>               O1 优化代码</p> 
<p>               O2 优化算法</p> 
<p>               O3 抽象成数学模型和假象机器模型（支持函数集成化)  </p> 
<p>交叉编译器 ： 在一种计算机环境中运行的<a href="https://baike.baidu.com/item/%E7%BC%96%E8%AF%91%E7%A8%8B%E5%BA%8F/8290180" rel="nofollow" title="编译程序">编译程序</a>，能编译出在另外一种环境下运行的代码 ，本地编译产生的文件 ，不同内核环境无法执行，所以需要经过叫交叉编译器编译在其他平台执行的文件，提高可移植性。</p> 
<p>库</p> 
<p>根据链接编译生成可执行文件的链接方式分为静态库和动态库</p> 
<p>静态库执行时体积大，运行效率高，,因为编译时会整合到目标程序中，所以不方便修改，需要改整个可执行文件都需要重新编译，后缀.a</p> 
<p>        动态库体积小，运行效率慢，但方便修改，动态库是将符号链接写入目标文件，在程序中是一个指向符号，产品更新时只需替换对应函数库，不要重新编译整个可执行文件,后缀.so</p> 
<p>库的存放位置：</p> 
<p>lib          存放系统程序运行所需库文件</p> 
<p>user /lib或user/local/lib     存放用户程序的和第三方程序运行的库</p> 
<p>静态库制作</p> 
<p><img alt="" height="267" src="https://images2.imgbox.com/96/e9/H3GaKhm7_o.png" width="486"></p> 
<p> <img alt="" height="206" src="https://images2.imgbox.com/82/29/syAqoBp9_o.png" width="414"><img alt="" height="221" src="https://images2.imgbox.com/2e/37/vH6iXdiQ_o.png" width="455"></p> 
<p></p> 
<p> ar 压缩命令</p> 
<p>-r 将文件插入备份文件</p> 
<p>c  建立库文件</p> 
<p>s  创建目标文件索引，这在创建较大的库时能加快时间</p> 
<p>-shared  编译生成动态库</p> 
<p>-fPIC 生成地址无关码</p> 
<p>例：</p> 
<blockquote> 
 <p>1、gcc  -c add.c (执行到汇编生成.o文件，add是一个.c文件名)</p> 
 <p>2、ar  -rcs libadd.a add.o </p> 
 <p>3、链接编译</p> 
 <p>gcc main.c -o mian -ladd -L/user (main是需要编译的函数）</p> 
</blockquote> 
<p>-l 是用来链接编译时所编译程序所以用的库，相当于#include&lt;stdio.h&gt;</p> 
<p>-L 链接这个库所在的路径</p> 
<p>动态库和静态库的的引用</p> 
<p>4、动态库的引用</p> 
<blockquote> 
 <p>gcc -shared -fPIC -o  libcal.so add.c sub.c</p> 
 <p>将add.c sub.c 制作生成动态库 cal.so （lib是个库）</p> 
 <p>gcc main.c ./libcal.so -o main</p> 
</blockquote> 
<p>在main.c 中引用动态库，路径./ 不能少，不然找不到所要链接的库（add.c sub.c）</p> 
<p>不然将生成的动态库拷贝到   /usr/lib</p> 
<p>gcc main.c  -o main -lcal</p> 
<p><img alt="" height="251" src="https://images2.imgbox.com/21/f1/PEdNgqvw_o.png" width="552">两个库同时存在优先链接动态库</p> 
<p></p> 
<p>gdb</p> 
<p><img alt="" height="318" src="https://images2.imgbox.com/e5/3b/76Yls9Cj_o.png" width="271"></p> 
<p><img alt="" height="224" src="https://images2.imgbox.com/82/07/FQnSAVBz_o.png" width="370"></p> 
<p></p> 
<p></p> 
<p>make（工程管理器，批处理，实现自动编译）</p> 
<p>三要素</p> 
<p>目标       需要生成的目标文件</p> 
<p>依赖       生成目标文件需要的依赖文件</p> 
<p>命令       生成目标时，执行的命令行</p> 
<p>关系：根据依赖文件，执行命令生成目标文件</p> 
<p>$@:表示目标文件的名称，包含扩展名<br> $^:表示所有的依赖文件，以空格隔开，不重复<br> $&lt;:表示第一个依赖文件的名称<br> $+:表示所有的依赖文件，空格隔开，可以重复<br> $*:表示目标文件的名称，不包含扩展名<br> $?:依赖项中，所有比目标文件新的依赖文件</p> 
<p>@  取消回显</p> 
<p>echo 相当于printf，输出</p> 
<p>makefile用法</p> 
<p>目标：依赖</p> 
<p>        命令（命令前用tab键空出8个空格）</p> 
<p>编写多目录makefile</p> 
<p>目录划分</p> 
<p>有多少少功能就创建几个目录将实现相同功能的文件放在相同目录</p> 
<p>阅读多层次makefile顺序</p> 
<p>scripts ——总控makefile——功能makefile</p> 
<p></p> 
<p>1、总控makefile</p> 
<p>       进入各个功能子目录执行make命令（生成.o文件），返回各个总控makefile将各个生成的.o文件进行链接生成可执行文件</p> 
<p>2、功能目录子makefile</p> 
<p>    将当前子目录下的.c（生成.o文件）</p> 
<p>3、scripts         定义变量</p> 
<p style="text-align:center;"></p> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/e3/92/qm3SF8YF_o.png"></p> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/14/8d/BgcICsJI_o.png"></p> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/7a/e2/KG2uHwkf_o.png"></p> 
<p> 不用变量对比</p> 
<p></p> 
<p><img alt="" height="350" src="https://images2.imgbox.com/3b/c7/wqC4yLVU_o.png" width="674"></p> 
<p></p> 
<p>          <img alt="" height="228" src="https://images2.imgbox.com/30/37/LHojPDhj_o.png" width="648"></p> 
<p> make</p> 
<p>可以实现自动化编译，在升级或者修改时，可以节省改动，只改动部分变量即可</p> 
<p>个人笔记，欢迎您提出宝贵意见</p> 
<p></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/4a2554c5310ec26b7c9ff2fd42d7a2de/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">八年级上册历史知识点（第3课 太平天国运动）</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/68c776ea18ab0b8d905e30a0119ad075/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">k8s  hostNetwork 网络的 pod 无法解析 service 排查</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>