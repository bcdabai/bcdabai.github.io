<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>RabbitMQ实战教程 - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="RabbitMQ实战教程" />
<meta property="og:description" content="1.什么是MQ
消息队列（Message Queue，简称MQ），从字面意思上看，本质是个队列，FIFO先入先出，只不过队列中存放的内容是message而已。
其主要用途：不同进程Process/线程Thread之间通信。
为什么会产生消息队列？有几个原因：
不同进程（process）之间传递消息时，两个进程之间耦合程度过高，改动一个进程，引发必须修改另一个进程，为了隔离这两个进程，在两进程间抽离出一层（一个模块），所有两进程之间传递的消息，都必须通过消息队列来传递，单独修改某一个进程，不会影响另一个；
不同进程（process）之间传递消息时，为了实现标准化，将消息的格式规范化了，并且，某一个进程接受的消息太多，一下子无法处理完，并且也有先后顺序，必须对收到的消息进行排队，因此诞生了事实上的消息队列；
关于消息队列的详细介绍请参阅：
《Java帝国之消息队列》
《一个故事告诉你什么是消息队列》
《到底什么时候该使用MQ》
MQ框架非常之多，比较流行的有RabbitMq、ActiveMq、ZeroMq、kafka，以及阿里开源的RocketMQ。本文主要介绍RabbitMq。
2.RabbitMQ
2.1.RabbitMQ的简介
开发语言：Erlang – 面向并发的编程语言。
2.1.1.AMQP
AMQP是消息队列的一个协议。
2.2.官网
2.3.MQ的其他产品
2.4.学习5种队列
2.5.安装文档
3.搭建RabbitMQ环境
3.1.下载
下载地址：http://www.rabbitmq.com/download.html
3.2.windows下安装
3.2.1.安装Erlang
下载：http://www.erlang.org/download/otp_win64_17.3.exe
安装：
安装完成。
3.2.2.安装RabbitMQ
安装完成。
开始菜单里出现如下选项：
启动、停止、重新安装等。
3.2.3.启用管理工具
1、双击
2、进入C:\Program Files (x86)\RabbitMQ Server\rabbitmq_server-3.4.1\sbin输入命令：
rabbitmq-plugins enable rabbitmq_management
这样就启动了管理工具，可以试一下命令：
停止：net stop RabbitMQ
启动：net start RabbitMQ
3、在浏览器中输入地址查看：http://127.0.0.1:15672/
4、使用默认账号登录：guest/ guest
3.3.Linux下安装
3.3.1.安装Erlang
3.3.2.添加yum支持
cd /usr/local/src/
mkdir rabbitmq
cd rabbitmq
wget http://packages.erlang-solutions ... ns-1.0-1.noarch.rpm
rpm -Uvh erlang-solutions-1." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/1d803f2b5fbe668ff6541a1122fdf9a2/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2020-03-12T11:23:19+08:00" />
<meta property="article:modified_time" content="2020-03-12T11:23:19+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">RabbitMQ实战教程</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <table cellpadding="0" cellspacing="0" id="pid4288765"><tbody><tr><td> 
    <table cellpadding="0" cellspacing="0"><tbody><tr><td id="postmessage_4288765"><br><br> 1.什么是MQ<br> 消息队列（Message Queue，简称MQ），从字面意思上看，本质是个队列，FIFO先入先出，只不过队列中存放的内容是message而已。<br> 其主要用途：不同进程Process/线程Thread之间通信。<br> 为什么会产生消息队列？有几个原因：<br><br> 不同进程（process）之间传递消息时，两个进程之间耦合程度过高，改动一个进程，引发必须修改另一个进程，为了隔离这两个进程，在两进程间抽离出一层（一个模块），所有两进程之间传递的消息，都必须通过消息队列来传递，单独修改某一个进程，不会影响另一个；<br><br> 不同进程（process）之间传递消息时，为了实现标准化，将消息的格式规范化了，并且，某一个进程接受的消息太多，一下子无法处理完，并且也有先后顺序，必须对收到的消息进行排队，因此诞生了事实上的消息队列；<br><br> 关于消息队列的详细介绍请参阅：<br> 《Java帝国之消息队列》<br> 《一个故事告诉你什么是消息队列》<br> 《到底什么时候该使用MQ》<br><br> MQ框架非常之多，比较流行的有RabbitMq、ActiveMq、ZeroMq、kafka，以及阿里开源的RocketMQ。本文主要介绍RabbitMq。<br><br><br> 2.RabbitMQ<br> 2.1.RabbitMQ的简介<br><br> 开发语言：Erlang – 面向并发的编程语言。<br><br><br><br> 2.1.1.AMQP<br> AMQP是消息队列的一个协议。<br><br><br><br> 2.2.官网<br><br><br> 2.3.MQ的其他产品<br><br><br> 2.4.学习5种队列<br><br><br> 2.5.安装文档<br><br><br> 3.搭建RabbitMQ环境<br> 3.1.下载<br> 下载地址：<a href="http://www.rabbitmq.com/download.html" rel="nofollow">http://www.rabbitmq.com/download.html</a><br><br> 3.2.windows下安装<br> 3.2.1.安装Erlang<br> 下载：<a href="http://www.erlang.org/download/otp_win64_17.3.exe" rel="nofollow">http://www.erlang.org/download/otp_win64_17.3.exe</a><br> 安装：<br><br><br><br><br><br> 安装完成。<br><br> 3.2.2.安装RabbitMQ<br><br><br><br> 安装完成。<br><br> 开始菜单里出现如下选项：<br><br><br> 启动、停止、重新安装等。<br><br> 3.2.3.启用管理工具<br> 1、双击<br> 2、进入C:\Program Files (x86)\RabbitMQ Server\rabbitmq_server-3.4.1\sbin输入命令：<br> rabbitmq-plugins enable rabbitmq_management<br><br><br> 这样就启动了管理工具，可以试一下命令：<br> 停止：net stop RabbitMQ<br> 启动：net start RabbitMQ<br><br> 3、在浏览器中输入地址查看：<a href="http://127.0.0.1:15672/" rel="nofollow">http://127.0.0.1:15672/</a><br><br> 4、使用默认账号登录：guest/ guest<br><br> 3.3.Linux下安装<br> 3.3.1.安装Erlang<br> 3.3.2.添加yum支持<br> cd /usr/local/src/<br> mkdir rabbitmq<br> cd rabbitmq<br><br> wget <a href="http://packages.erlang-solutions.com/erlang-solutions-1.0-1.noarch.rpm" rel="nofollow">http://packages.erlang-solutions ... ns-1.0-1.noarch.rpm</a><br> rpm -Uvh erlang-solutions-1.0-1.noarch.rpm<br><br> rpm --import <a href="http://packages.erlang-solutions.com/rpm/erlang_solutions.asc" rel="nofollow">http://packages.erlang-solutions.com/rpm/erlang_solutions.asc</a><br><br> 使用yum安装：<br> sudo yum install erlang<br><br><br> 3.3.3.安装RabbitMQ<br> 上传rabbitmq-server-3.4.1-1.noarch.rpm文件到/usr/local/src/rabbitmq/<br> 安装：<br> rpm -ivh rabbitmq-server-3.4.1-1.noarch.rpm<br><br> 3.3.4.启动、停止<br> service rabbitmq-server start<br> service rabbitmq-server stop<br> service rabbitmq-server restart<br> 3.3.5.设置开机启动<br> chkconfig rabbitmq-server on<br> 3.3.6.设置配置文件<br> cd /etc/rabbitmq<br> cp /usr/share/doc/rabbitmq-server-3.4.1/rabbitmq.config.example /etc/rabbitmq/<br><br> mv rabbitmq.config.example rabbitmq.config<br> 3.3.7.开启用户远程访问<br> vi /etc/rabbitmq/rabbitmq.config<br><br> 注意要去掉后面的逗号。<br> 3.3.8.开启web界面管理工具<br> rabbitmq-plugins enable rabbitmq_management<br> service rabbitmq-server restart<br> 3.3.9.防火墙开放15672端口<br> /sbin/iptables -I INPUT -p tcp --dport 15672 -j ACCEPT<br> /etc/rc.d/init.d/iptables save<br><br> 3.4.安装的注意事项<br> 1、推荐使用默认的安装路径<br> 2、系统用户名必须是英文<br> Win10改名字非常麻烦，具体方法百度<br><br> 3、计算机名必须是英文<br><br> 4、系统的用户必须是管理员<br><br> 如果安装失败应该如何解决：<br> 1、重装系统 – 不推荐<br> 2、将RabbitMQ安装到linux虚拟机中<br> a)推荐<br> 3、使用别人安装好的RabbitMQ服务<br> a)只要给你开通一个账户即可。<br> b)使用公用的RabbitMQ服务，在192.168.50.22<br> c)推荐<br><br> 常见错误：<br><br><br> 3.5.安装完成后操作<br> 1、系统服务中有RabbitMQ服务，停止、启动、重启<br><br> 2、打开命令行工具<br><br> 如果找不到命令行工具,直接cd到相应目录：<br><br> 输入命令rabbitmq-plugins enable rabbitmq_management启用管理插件<br><br> 查看管理页面<br><br> 通过默认账户 guest/guest 登录<br> 如果能够登录，说明安装成功。<br><br><br> 4.添加用户<br> 4.1.添加admin用户<br><br><br> 4.2.用户角色<br> 1、超级管理员(administrator)<br> 可登陆管理控制台，可查看所有的信息，并且可以对用户，策略(policy)进行操作。<br> 2、监控者(monitoring)<br> 可登陆管理控制台，同时可以查看rabbitmq节点的相关信息(进程数，内存使用情况，磁盘使用情况等)<br> 3、策略制定者(policymaker)<br> 可登陆管理控制台, 同时可以对policy进行管理。但无法查看节点的相关信息(上图红框标识的部分)。<br> 4、普通管理者(management)<br> 仅可登陆管理控制台，无法看到节点信息，也无法对策略进行管理。<br> 5、其他<br> 无法登陆管理控制台，通常就是普通的生产者和消费者。<br><br> 4.3.创建Virtual Hosts<br><br><br> 选中Admin用户，设置权限：<br><br> 看到权限已加：<br><br><br> 4.4.管理界面中的功能<br><br><br><br><br> 5.学习五种队列<br><br><br> 5.1.导入my-rabbitmq项目<br> 项目下载地址：<br><a href="https://download.csdn.net/download/zpcandzhj/10585077">https://download.csdn.net/download/zpcandzhj/10585077</a><br><br><br> 5.2.简单队列<br> 5.2.1.图示<br><br><br> P：消息的生产者<br> C：消息的消费者<br> 红色：队列<br><br> 生产者将消息发送到队列，消费者从队列中获取消息。<br> 5.2.2.导入RabbitMQ的客户端依赖<br><br> &lt;dependency&gt;<br>    &lt;groupId&gt;com.rabbitmq&lt;/groupId&gt;<br>    &lt;artifactId&gt;amqp-client&lt;/artifactId&gt;<br>    &lt;version&gt;3.4.1&lt;/version&gt;<br> &lt;/dependency&gt;<br><br> 5.2.3.获取MQ的连接<br><br> package com.zpc.rabbitmq.util;<br> import com.rabbitmq.client.ConnectionFactory;<br> import com.rabbitmq.client.Connection;<br><br> public class ConnectionUtil {<!-- --><br><br>     public static Connection getConnection() throws Exception {<!-- --><br>         //定义连接工厂<br>         ConnectionFactory factory = new ConnectionFactory();<br>         //设置服务地址<br>         factory.setHost("localhost");<br>         //端口<br>         factory.setPort(5672);<br>         //设置账号信息，用户名、密码、vhost<br>         factory.setVirtualHost("testhost");<br>         factory.setUsername("admin");<br>         factory.setPassword("admin");<br>         // 通过工程获取连接<br>         Connection connection = factory.newConnection();<br>         return connection;<br>     }<br> }<br> 5.2.4.生产者发送消息到队列<br><br> package com.zpc.rabbitmq.simple;<br><br> import com.zpc.rabbitmq.util.ConnectionUtil;<br><br> import com.rabbitmq.client.Channel;<br> import com.rabbitmq.client.Connection;<br><br> public class Send {<!-- --><br><br>     private final static String QUEUE_NAME = "q_test_01";<br><br>     public static void main(String[] argv) throws Exception {<!-- --><br>         // 获取到连接以及mq通道<br>         Connection connection = ConnectionUtil.getConnection();<br>         // 从连接中创建通道<br>         Channel channel = connection.createChannel();<br><br>         // 声明（创建）队列<br>         channel.queueDeclare(QUEUE_NAME, false, false, false, null);<br><br>         // 消息内容<br>         String message = "Hello World!";<br>         channel.basicPublish("", QUEUE_NAME, null, message.getBytes());<br>         System.out.println(" [x] Sent '" + message + "'");<br>         //关闭通道和连接<br>         channel.close();<br>         connection.close();<br>     }<br> }<br> 5.2.5.管理工具中查看消息<br><br><br> 点击上面的队列名称，查询具体的队列中的信息：<br><br> 5.2.6.消费者从队列中获取消息<br><br> package com.zpc.rabbitmq.simple;<br><br> import com.zpc.rabbitmq.util.ConnectionUtil;<br><br> import com.rabbitmq.client.Channel;<br> import com.rabbitmq.client.Connection;<br> import com.rabbitmq.client.QueueingConsumer;<br><br> public class Recv {<!-- --><br><br>     private final static String QUEUE_NAME = "q_test_01";<br><br>     public static void main(String[] argv) throws Exception {<!-- --><br><br>         // 获取到连接以及mq通道<br>         Connection connection = ConnectionUtil.getConnection();<br>         // 从连接中创建通道<br>         Channel channel = connection.createChannel();<br>         // 声明队列<br>         channel.queueDeclare(QUEUE_NAME, false, false, false, null);<br><br>         // 定义队列的消费者<br>         QueueingConsumer consumer = new QueueingConsumer(channel);<br><br>         // 监听队列<br>         channel.basicConsume(QUEUE_NAME, true, consumer);<br><br>         // 获取消息<br>         while (true) {<!-- --><br>             QueueingConsumer.Delivery delivery = consumer.nextDelivery();<br>             String message = new String(delivery.getBody());<br>             System.out.println(" [x] Received '" + message + "'");<br>         }<br>     }<br> }<br><br> 5.3.Work模式<br><br><br> 5.3.1.图示<br><br><br> 一个生产者、2个消费者。<br><br> 一个消息只能被一个消费者获取。<br> 5.3.2.消费者1<br><br> package com.zpc.rabbitmq.work;<br><br> import com.rabbitmq.client.Channel;<br> import com.rabbitmq.client.Connection;<br> import com.rabbitmq.client.QueueingConsumer;<br> import com.zpc.rabbitmq.util.ConnectionUtil;<br><br> public class Recv {<!-- --><br><br>     private final static String QUEUE_NAME = "test_queue_work";<br><br>     public static void main(String[] argv) throws Exception {<!-- --><br><br>         // 获取到连接以及mq通道<br>         Connection connection = ConnectionUtil.getConnection();<br>         Channel channel = connection.createChannel();<br><br>         // 声明队列<br>         channel.queueDeclare(QUEUE_NAME, false, false, false, null);<br><br>         // 同一时刻服务器只会发一条消息给消费者<br>         //channel.basicQos(1);<br><br>         // 定义队列的消费者<br>         QueueingConsumer consumer = new QueueingConsumer(channel);<br>         // 监听队列，false表示手动返回完成状态，true表示自动<br>         channel.basicConsume(QUEUE_NAME, true, consumer);<br><br>         // 获取消息<br>         while (true) {<!-- --><br>             QueueingConsumer.Delivery delivery = consumer.nextDelivery();<br>             String message = new String(delivery.getBody());<br>             System.out.println(" [y] Received '" + message + "'");<br>             //休眠<br>             Thread.sleep(10);<br>             // 返回确认状态，注释掉表示使用自动确认模式<br>             //channel.basicAck(delivery.getEnvelope().getDeliveryTag(), false);<br>         }<br>     }<br> }<br> 5.3.3.消费者2<br><br> package com.zpc.rabbitmq.work;<br><br> import com.rabbitmq.client.Channel;<br> import com.rabbitmq.client.Connection;<br> import com.rabbitmq.client.QueueingConsumer;<br> import com.zpc.rabbitmq.util.ConnectionUtil;<br><br> public class Recv2 {<!-- --><br><br>     private final static String QUEUE_NAME = "test_queue_work";<br><br>     public static void main(String[] argv) throws Exception {<!-- --><br><br>         // 获取到连接以及mq通道<br>         Connection connection = ConnectionUtil.getConnection();<br>         Channel channel = connection.createChannel();<br><br>         // 声明队列<br>         channel.queueDeclare(QUEUE_NAME, false, false, false, null);<br><br>         // 同一时刻服务器只会发一条消息给消费者<br>         //channel.basicQos(1);<br><br>         // 定义队列的消费者<br>         QueueingConsumer consumer = new QueueingConsumer(channel);<br>         // 监听队列，false表示手动返回完成状态，true表示自动<br>         channel.basicConsume(QUEUE_NAME, true, consumer);<br><br>         // 获取消息<br>         while (true) {<!-- --><br>             QueueingConsumer.Delivery delivery = consumer.nextDelivery();<br>             String message = new String(delivery.getBody());<br>             System.out.println(" [x] Received '" + message + "'");<br>             // 休眠1秒<br>             Thread.sleep(1000);<br>             //下面这行注释掉表示使用自动确认模式<br>             //channel.basicAck(delivery.getEnvelope().getDeliveryTag(), false);<br>         }<br>     }<br> }<br> 5.3.4.生产者<br> 向队列中发送100条消息。<br><br> package com.zpc.rabbitmq.work;<br><br> import com.zpc.rabbitmq.util.ConnectionUtil;<br><br> import com.rabbitmq.client.Channel;<br> import com.rabbitmq.client.Connection;<br><br> public class Send {<!-- --><br><br>     private final static String QUEUE_NAME = "test_queue_work";<br><br>     public static void main(String[] argv) throws Exception {<!-- --><br>         // 获取到连接以及mq通道<br>         Connection connection = ConnectionUtil.getConnection();<br>         Channel channel = connection.createChannel();<br><br>         // 声明队列<br>         channel.queueDeclare(QUEUE_NAME, false, false, false, null);<br><br>         for (int i = 0; i &lt; 100; i++) {<!-- --><br>             // 消息内容<br>             String message = "" + i;<br>             channel.basicPublish("", QUEUE_NAME, null, message.getBytes());<br>             System.out.println(" [x] Sent '" + message + "'");<br><br>             Thread.sleep(i * 10);<br>         }<br><br>         channel.close();<br>         connection.close();<br>     }<br> }<br><br> 5.3.5.测试<br> 测试结果：<br> 1、消费者1和消费者2获取到的消息内容是不同的，同一个消息只能被一个消费者获取。<br> 2、消费者1和消费者2获取到的消息的数量是相同的，一个是消费奇数号消息，一个是偶数。<br><br> 其实，这样是不合理的，因为消费者1线程停顿的时间短。应该是消费者1要比消费者2获取到的消息多才对。<br> RabbitMQ 默认将消息顺序发送给下一个消费者，这样，每个消费者会得到相同数量的消息。即轮询（round-robin）分发消息。<br><br> 怎样才能做到按照每个消费者的能力分配消息呢？联合使用 Qos 和 Acknowledge 就可以做到。<br> basicQos 方法设置了当前信道最大预获取（prefetch）消息数量为1。消息从队列异步推送给消费者，消费者的 ack 也是异步发送给队列，从队列的视角去看，总是会有一批消息已推送但尚未获得 ack 确认，Qos 的 prefetchCount 参数就是用来限制这批未确认消息数量的。设为1时，队列只有在收到消费者发回的上一条消息 ack 确认后，才会向该消费者发送下一条消息。prefetchCount 的默认值为0，即没有限制，队列会将所有消息尽快发给消费者。<br><br> 2个概念<br><br> 轮询分发 ：使用任务队列的优点之一就是可以轻易的并行工作。如果我们积压了好多工作，我们可以通过增加工作者（消费者）来解决这一问题，使得系统的伸缩性更加容易。在默认情况下，RabbitMQ将逐个发送消息到在序列中的下一个消费者(而不考虑每个任务的时长等等，且是提前一次性分配，并非一个一个分配)。平均每个消费者获得相同数量的消息。这种方式分发消息机制称为Round-Robin（轮询）。<br><br> 公平分发 ：虽然上面的分配法方式也还行，但是有个问题就是：比如：现在有2个消费者，所有的奇数的消息都是繁忙的，而偶数则是轻松的。按照轮询的方式，奇数的任务交给了第一个消费者，所以一直在忙个不停。偶数的任务交给另一个消费者，则立即完成任务，然后闲得不行。而RabbitMQ则是不了解这些的。这是因为当消息进入队列，RabbitMQ就会分派消息。它不看消费者为应答的数目，只是盲目的将消息发给轮询指定的消费者。<br><br> 为了解决这个问题，我们使用basicQos( prefetchCount = 1)方法，来限制RabbitMQ只发不超过1条的消息给同一个消费者。当消息处理完毕后，有了反馈，才会进行第二次发送。<br> 还有一点需要注意，使用公平分发，必须关闭自动应答，改为手动应答。<br><br> 5.4.Work模式的“能者多劳”<br> 打开上述代码的注释：<br><br> // 同一时刻服务器只会发一条消息给消费者<br> channel.basicQos(1);<br><br> //开启这行 表示使用手动确认模式<br> channel.basicAck(delivery.getEnvelope().getDeliveryTag(), false);<br><br> 同时改为手动确认：<br><br> // 监听队列，false表示手动返回完成状态，true表示自动<br> channel.basicConsume(QUEUE_NAME, false, consumer);<br> 测试：<br> 消费者1比消费者2获取的消息更多。<br><br> 5.5.消息的确认模式<br> 消费者从队列中获取消息，服务端如何知道消息已经被消费呢？<br><br> 模式1：自动确认<br> 只要消息从队列中获取，无论消费者获取到消息后是否成功消息，都认为是消息已经成功消费。<br> 模式2：手动确认<br> 消费者从队列中获取消息后，服务器会将该消息标记为不可用状态，等待消费者的反馈，如果消费者一直没有反馈，那么该消息将一直处于不可用状态。<br><br> 手动模式：<br><br><br> 自动模式：<br><br><br> 5.6.订阅模式<br><br> 5.6.1.图示<br><br><br> 解读：<br> 1、1个生产者，多个消费者<br> 2、每一个消费者都有自己的一个队列<br> 3、生产者没有将消息直接发送到队列，而是发送到了交换机<br> 4、每个队列都要绑定到交换机<br> 5、生产者发送的消息，经过交换机，到达队列，实现，一个消息被多个消费者获取的目的<br> 注意：一个消费者队列可以有多个消费者实例，只有其中一个消费者实例会消费<br><br><br> 5.6.2.消息的生产者（看作是后台系统）<br> 向交换机中发送消息。<br><br> package com.zpc.rabbitmq.subscribe;<br><br> import com.zpc.rabbitmq.util.ConnectionUtil;<br><br> import com.rabbitmq.client.Channel;<br> import com.rabbitmq.client.Connection;<br><br> public class Send {<!-- --><br><br>     private final static String EXCHANGE_NAME = "test_exchange_fanout";<br><br>     public static void main(String[] argv) throws Exception {<!-- --><br>         // 获取到连接以及mq通道<br>         Connection connection = ConnectionUtil.getConnection();<br>         Channel channel = connection.createChannel();<br><br>         // 声明exchange<br>         channel.exchangeDeclare(EXCHANGE_NAME, "fanout");<br><br>         // 消息内容<br>         String message = "Hello World!";<br>         channel.basicPublish(EXCHANGE_NAME, "", null, message.getBytes());<br>         System.out.println(" [x] Sent '" + message + "'");<br><br>         channel.close();<br>         connection.close();<br>     }<br> }<br><br> 注意：消息发送到没有队列绑定的交换机时，消息将丢失，因为，交换机没有存储消息的能力，消息只能存在在队列中。<br> 5.6.3.消费者1（看作是前台系统）<br><br> package com.zpc.rabbitmq.subscribe;<br><br> import com.rabbitmq.client.Channel;<br> import com.rabbitmq.client.Connection;<br> import com.rabbitmq.client.QueueingConsumer;<br><br> import com.zpc.rabbitmq.util.ConnectionUtil;<br><br> public class Recv {<!-- --><br><br>     private final static String QUEUE_NAME = "test_queue_work1";<br><br>     private final static String EXCHANGE_NAME = "test_exchange_fanout";<br><br>     public static void main(String[] argv) throws Exception {<!-- --><br><br>         // 获取到连接以及mq通道<br>         Connection connection = ConnectionUtil.getConnection();<br>         Channel channel = connection.createChannel();<br><br>         // 声明队列<br>         channel.queueDeclare(QUEUE_NAME, false, false, false, null);<br><br>         // 绑定队列到交换机<br>         channel.queueBind(QUEUE_NAME, EXCHANGE_NAME, "");<br><br>         // 同一时刻服务器只会发一条消息给消费者<br>         channel.basicQos(1);<br><br>         // 定义队列的消费者<br>         QueueingConsumer consumer = new QueueingConsumer(channel);<br>         // 监听队列，手动返回完成<br>         channel.basicConsume(QUEUE_NAME, false, consumer);<br><br>         // 获取消息<br>         while (true) {<!-- --><br>             QueueingConsumer.Delivery delivery = consumer.nextDelivery();<br>             String message = new String(delivery.getBody());<br>             System.out.println(" [Recv] Received '" + message + "'");<br>             Thread.sleep(10);<br><br>             channel.basicAck(delivery.getEnvelope().getDeliveryTag(), false);<br>         }<br>     }<br> }<br><br> 5.6.4.消费者2（看作是搜索系统）<br><br> package com.zpc.rabbitmq.subscribe;<br><br> import com.rabbitmq.client.Channel;<br> import com.rabbitmq.client.Connection;<br> import com.rabbitmq.client.QueueingConsumer;<br><br> import com.zpc.rabbitmq.util.ConnectionUtil;<br><br> public class Recv2 {<!-- --><br><br>     private final static String QUEUE_NAME = "test_queue_work2";<br><br>     private final static String EXCHANGE_NAME = "test_exchange_fanout";<br><br>     public static void main(String[] argv) throws Exception {<!-- --><br><br>         // 获取到连接以及mq通道<br>         Connection connection = ConnectionUtil.getConnection();<br>         Channel channel = connection.createChannel();<br><br>         // 声明队列<br>         channel.queueDeclare(QUEUE_NAME, false, false, false, null);<br><br>         // 绑定队列到交换机<br>         channel.queueBind(QUEUE_NAME, EXCHANGE_NAME, "");<br><br>         // 同一时刻服务器只会发一条消息给消费者<br>         channel.basicQos(1);<br><br>         // 定义队列的消费者<br>         QueueingConsumer consumer = new QueueingConsumer(channel);<br>         // 监听队列，手动返回完成<br>         channel.basicConsume(QUEUE_NAME, false, consumer);<br><br>         // 获取消息<br>         while (true) {<!-- --><br>             QueueingConsumer.Delivery delivery = consumer.nextDelivery();<br>             String message = new String(delivery.getBody());<br>             System.out.println(" [Recv2] Received '" + message + "'");<br>             Thread.sleep(10);<br><br>             channel.basicAck(delivery.getEnvelope().getDeliveryTag(), false);<br>         }<br>     }<br> }<br><br> 5.6.5.测试<br> 测试结果：<br> 同一个消息被多个消费者获取。一个消费者队列可以有多个消费者实例，只有其中一个消费者实例会消费到消息。<br><br> 在管理工具中查看队列和交换机的绑定关系：<br><br><br><br> 5.7.路由模式<br><br> 5.7.1.图示<br><br><br> 5.7.2.生产者<br><br> 5.7.3.消费者1(假设是前台系统)<br><br> 5.7.4.消费2（假设是搜索系统）<br><br><br> 5.8.主题模式（通配符模式）<br><br><br><br><br> 5.8.1.图示<br><br> 同一个消息被多个消费者获取。一个消费者队列可以有多个消费者实例，只有其中一个消费者实例会消费到消息。<br><br> 5.8.2.生产者<br><br> package com.zpc.rabbitmq.topic;<br><br> import com.rabbitmq.client.Channel;<br> import com.rabbitmq.client.Connection;<br><br> import com.zpc.rabbitmq.util.ConnectionUtil;<br><br> public class Send {<!-- --><br><br>     private final static String EXCHANGE_NAME = "test_exchange_topic";<br><br>     public static void main(String[] argv) throws Exception {<!-- --><br>         // 获取到连接以及mq通道<br>         Connection connection = ConnectionUtil.getConnection();<br>         Channel channel = connection.createChannel();<br><br>         // 声明exchange<br>         channel.exchangeDeclare(EXCHANGE_NAME, "topic");<br><br>         // 消息内容<br>         String message = "Hello World!!";<br>         channel.basicPublish(EXCHANGE_NAME, "routekey.1", null, message.getBytes());<br>         System.out.println(" [x] Sent '" + message + "'");<br><br>         channel.close();<br>         connection.close();<br>     }<br> }<br> 5.8.3.消费者1（前台系统）<br><br> package com.zpc.rabbitmq.topic;<br><br> import com.rabbitmq.client.Channel;<br> import com.rabbitmq.client.Connection;<br> import com.rabbitmq.client.QueueingConsumer;<br><br> import com.zpc.rabbitmq.util.ConnectionUtil;<br><br> public class Recv {<!-- --><br><br>     private final static String QUEUE_NAME = "test_queue_topic_work_1";<br><br>     private final static String EXCHANGE_NAME = "test_exchange_topic";<br><br>     public static void main(String[] argv) throws Exception {<!-- --><br><br>         // 获取到连接以及mq通道<br>         Connection connection = ConnectionUtil.getConnection();<br>         Channel channel = connection.createChannel();<br><br>         // 声明队列<br>         channel.queueDeclare(QUEUE_NAME, false, false, false, null);<br><br>         // 绑定队列到交换机<br>         channel.queueBind(QUEUE_NAME, EXCHANGE_NAME, "routekey.*");<br><br>         // 同一时刻服务器只会发一条消息给消费者<br>         channel.basicQos(1);<br><br>         // 定义队列的消费者<br>         QueueingConsumer consumer = new QueueingConsumer(channel);<br>         // 监听队列，手动返回完成<br>         channel.basicConsume(QUEUE_NAME, false, consumer);<br><br>         // 获取消息<br>         while (true) {<!-- --><br>             QueueingConsumer.Delivery delivery = consumer.nextDelivery();<br>             String message = new String(delivery.getBody());<br>             System.out.println(" [Recv_x] Received '" + message + "'");<br>             Thread.sleep(10);<br><br>             channel.basicAck(delivery.getEnvelope().getDeliveryTag(), false);<br>         }<br>     }<br> }<br> 5.8.4.消费者2（搜索系统）<br><br> package com.zpc.rabbitmq.topic;<br><br> import com.zpc.rabbitmq.util.ConnectionUtil;<br><br> import com.rabbitmq.client.Channel;<br> import com.rabbitmq.client.Connection;<br> import com.rabbitmq.client.QueueingConsumer;<br><br> public class Recv2 {<!-- --><br><br>     private final static String QUEUE_NAME = "test_queue_topic_work_2";<br><br>     private final static String EXCHANGE_NAME = "test_exchange_topic";<br><br>     public static void main(String[] argv) throws Exception {<!-- --><br><br>         // 获取到连接以及mq通道<br>         Connection connection = ConnectionUtil.getConnection();<br>         Channel channel = connection.createChannel();<br><br>         // 声明队列<br>         channel.queueDeclare(QUEUE_NAME, false, false, false, null);<br><br>         // 绑定队列到交换机<br>         channel.queueBind(QUEUE_NAME, EXCHANGE_NAME, "*.*");<br><br>         // 同一时刻服务器只会发一条消息给消费者<br>         channel.basicQos(1);<br><br>         // 定义队列的消费者<br>         QueueingConsumer consumer = new QueueingConsumer(channel);<br>         // 监听队列，手动返回完成<br>         channel.basicConsume(QUEUE_NAME, false, consumer);<br><br>         // 获取消息<br>         while (true) {<!-- --><br>             QueueingConsumer.Delivery delivery = consumer.nextDelivery();<br>             String message = new String(delivery.getBody());<br>             System.out.println(" [Recv2_x] Received '" + message + "'");<br>             Thread.sleep(10);<br><br>             channel.basicAck(delivery.getEnvelope().getDeliveryTag(), false);<br>         }<br>     }<br> }<br><br> 6.Spring-Rabbit<br> 6.1.Spring项目<br><a href="http://spring.io/projects" rel="nofollow">http://spring.io/projects</a><br><br><br><br> 6.2.简介<br><br><br><br> 6.3.使用<br> 6.3.1.消费者<br><br> package com.zpc.rabbitmq.spring;<br><br> /**<br> * 消费者<br> *<br> * @author Evan<br> */<br> public class Foo {<!-- --><br><br>     //具体执行业务的方法<br>     public void listen(String foo) {<!-- --><br>         System.out.println("\n消费者： " + foo + "\n");<br>     }<br> }<br><br> 6.3.2.生产者<br><br> package com.zpc.rabbitmq.spring;<br><br> import org.springframework.amqp.rabbit.core.RabbitTemplate;<br> import org.springframework.context.support.AbstractApplicationContext;<br> import org.springframework.context.support.ClassPathXmlApplicationContext;<br><br> public class SpringMain {<!-- --><br>     public static void main(final String... args) throws Exception {<!-- --><br>         AbstractApplicationContext ctx = new ClassPathXmlApplicationContext(<br>                 "classpath:spring/rabbitmq-context.xml");<br>         //RabbitMQ模板<br>         RabbitTemplate template = ctx.getBean(RabbitTemplate.class);<br>         //发送消息<br>         template.convertAndSend("Hello, 鸟鹏!");<br>         Thread.sleep(1000);// 休眠1秒<br>         ctx.destroy(); //容器销毁<br>     }<br> }<br> 6.3.3.配置文件<br> 1、定义连接工厂<br><br> &lt;!-- 定义RabbitMQ的连接工厂 --&gt;<br> &lt;rabbit:connection-factory id="connectionFactory"<br>    host="127.0.0.1" port="5672" username="admin" password="admin"<br>    virtual-host="testhost" /&gt;<br><br> 2、定义模板（可以指定交换机或队列）<br><br> &lt;rabbit:template id="amqpTemplate" connection-factory="connectionFactory" exchange="fanoutExchange" /&gt;<br> 1<br> 3、定义队列、交换机、以及完成队列和交换机的绑定<br><br> &lt;!-- 定义队列，自动声明 --&gt;<br> &lt;rabbit:queue name="zpcQueue" auto-declare="true"/&gt;<br><br> &lt;!-- 定义交换器，把Q绑定到交换机，自动声明 --&gt;<br> &lt;rabbit:fanout-exchange name="fanoutExchange" auto-declare="true"&gt;<br>    &lt;rabbit:bindings&gt;<br>       &lt;rabbit:binding queue="zpcQueue"/&gt;<br>    &lt;/rabbit:bindings&gt;<br> &lt;/rabbit:fanout-exchange&gt;<br><br> 4、定义监听<br><br> &lt;rabbit:listener-container connection-factory="connectionFactory"&gt;<br>    &lt;rabbit:listener ref="foo" method="listen" queue-names="zpcQueue" /&gt;<br> &lt;/rabbit:listener-container&gt;<br><br> &lt;bean id="foo" class="com.zpc.rabbitmq.spring.Foo" /&gt;<br><br> 5、定义管理，用于管理队列、交换机等：<br><br> &lt;!-- MQ的管理，包括队列、交换器等 --&gt;<br> &lt;rabbit:admin connection-factory="connectionFactory" /&gt;<br><br> 完整配置文件rabbitmq-context.xml<br><br> &lt;beans xmlns="http://www.springframework.org/schema/beans"<br>    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:rabbit="http://www.springframework.org/schema/rabbit"<br>    xsi:schemaLocation="http://www.springframework.org/schema/rabbit<br>    <a href="http://www.springframework.org/schema/rabbit/spring-rabbit-1.4.xsd" rel="nofollow">http://www.springframework.org/s ... ring-rabbit-1.4.xsd</a><br>    <a href="http://www.springframework.org/schema/beans" rel="nofollow">http://www.springframework.org/schema/beans</a><br>    <a href="http://www.springframework.org/schema/beans/spring-beans-4.1.xsd" rel="nofollow">http://www.springframework.org/schema/beans/spring-beans-4.1.xsd</a>"&gt;<br><br>    &lt;!-- 定义RabbitMQ的连接工厂 --&gt;<br>    &lt;rabbit:connection-factory id="connectionFactory"<br>       host="127.0.0.1" port="5672" username="admin" password="admin"<br>       virtual-host="testhost" /&gt;<br><br>    &lt;!-- 定义Rabbit模板，指定连接工厂以及定义exchange --&gt;<br>    &lt;rabbit:template id="amqpTemplate" connection-factory="connectionFactory" exchange="fanoutExchange" /&gt;<br>    &lt;!-- &lt;rabbit:template id="amqpTemplate" connection-factory="connectionFactory"<br>       exchange="fanoutExchange" routing-key="foo.bar" /&gt; --&gt;<br><br>    &lt;!-- MQ的管理，包括队列、交换器等 --&gt;<br>    &lt;rabbit:admin connection-factory="connectionFactory" /&gt;<br><br>    &lt;!-- 定义队列，自动声明 --&gt;<br>    &lt;rabbit:queue name="zpcQueue" auto-declare="true"/&gt;<br><br>    &lt;!-- 定义交换器，把Q绑定到交换机，自动声明 --&gt;<br>    &lt;rabbit:fanout-exchange name="fanoutExchange" auto-declare="true"&gt;<br>       &lt;rabbit:bindings&gt;<br>          &lt;rabbit:binding queue="zpcQueue"/&gt;<br>       &lt;/rabbit:bindings&gt;<br>    &lt;/rabbit:fanout-exchange&gt;<br><br> &lt;!--   &lt;rabbit:topic-exchange name="myExchange"&gt;<br>       &lt;rabbit:bindings&gt;<br>          &lt;rabbit:binding queue="myQueue" pattern="foo.*" /&gt;<br>       &lt;/rabbit:bindings&gt;<br>    &lt;/rabbit:topic-exchange&gt; --&gt;<br><br>    &lt;!-- 队列监听 --&gt;<br>    &lt;rabbit:listener-container connection-factory="connectionFactory"&gt;<br>       &lt;rabbit:listener ref="foo" method="listen" queue-names="zpcQueue" /&gt;<br>    &lt;/rabbit:listener-container&gt;<br><br>    &lt;bean id="foo" class="com.zpc.rabbitmq.spring.Foo" /&gt;<br><br> &lt;/beans&gt;<br><br> 6.4.持久化交换机和队列<br><br><br> 持久化：将交换机或队列的数据保存到磁盘，服务器宕机或重启之后依然存在。<br> 非持久化：将交换机或队列的数据保存到内存，服务器宕机或重启之后将不存在。<br><br> 非持久化的性能高于持久化。<br><br> 如何选择持久化？非持久化？ – 看需求。<br><br> 7.Spring集成RabbitMQ一个完整案例<br> 创建三个系统A,B,C<br> A作为生产者，B、C作为消费者(B,C作为web项目启动)<br> 项目下载地址：<a href="https://download.csdn.net/download/zpcandzhj/10585077">https://download.csdn.net/download/zpcandzhj/10585077</a><br><br> 7.1.在A系统中发送消息到交换机<br> 7.1.1.导入依赖<br><br> &lt;?xml version="1.0" encoding="UTF-8"?&gt;<br> &lt;project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"<br>    xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 <a href="http://maven.apache.org/xsd/maven-4.0.0.xsd" rel="nofollow">http://maven.apache.org/xsd/maven-4.0.0.xsd</a>"&gt;<br>    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;<br><br>    &lt;groupId&gt;com.zpc&lt;/groupId&gt;<br>    &lt;artifactId&gt;myrabbitA&lt;/artifactId&gt;<br>    &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt;<br>    &lt;packaging&gt;jar&lt;/packaging&gt;<br>    &lt;name&gt;myrabbit&lt;/name&gt;<br><br>    &lt;dependencies&gt;<br>       &lt;dependency&gt;<br>          &lt;groupId&gt;org.springframework.amqp&lt;/groupId&gt;<br>          &lt;artifactId&gt;spring-rabbit&lt;/artifactId&gt;<br>          &lt;version&gt;1.4.0.RELEASE&lt;/version&gt;<br>       &lt;/dependency&gt;<br><br>       &lt;dependency&gt;<br>          &lt;groupId&gt;com.alibaba&lt;/groupId&gt;<br>          &lt;artifactId&gt;fastjson&lt;/artifactId&gt;<br>          &lt;version&gt;1.2.47&lt;/version&gt;<br>       &lt;/dependency&gt;<br>    &lt;/dependencies&gt;<br> &lt;/project&gt;<br><br> 7.1.2.队列和交换机的绑定关系<br> 实现：<br> 1、在配置文件中将队列和交换机完成绑定<br> 2、可以在管理界面中完成绑定<br> a)绑定关系如果发生变化，需要修改配置文件，并且服务需要重启<br> b)管理更加灵活<br> c)更容易对绑定关系的权限管理，流程管理<br> 本例选择第2种方式<br> 7.1.3.配置<br> rabbitmq-context.xml<br><br> &lt;beans xmlns="http://www.springframework.org/schema/beans"<br>    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:rabbit="http://www.springframework.org/schema/rabbit"<br>    xsi:schemaLocation="http://www.springframework.org/schema/rabbit<br>    <a href="http://www.springframework.org/schema/rabbit/spring-rabbit-1.4.xsd" rel="nofollow">http://www.springframework.org/s ... ring-rabbit-1.4.xsd</a><br>    <a href="http://www.springframework.org/schema/beans" rel="nofollow">http://www.springframework.org/schema/beans</a><br>    <a href="http://www.springframework.org/schema/beans/spring-beans-4.1.xsd" rel="nofollow">http://www.springframework.org/schema/beans/spring-beans-4.1.xsd</a>"&gt;<br><br>    &lt;!-- 定义RabbitMQ的连接工厂 --&gt;<br>    &lt;rabbit:connection-factory id="connectionFactory"<br>       host="127.0.0.1" port="5672" username="admin" password="admin"<br>       virtual-host="testhost" /&gt;<br><br>    &lt;!-- MQ的管理，包括队列、交换器等 --&gt;<br>    &lt;rabbit:admin connection-factory="connectionFactory" /&gt;<br><br>    &lt;!-- 定义交换器，暂时不把Q绑定到交换机，在管理界面去绑定 --&gt;<br>    &lt;!--&lt;rabbit:topic-exchange name="topicExchange" auto-declare="true" &gt;&lt;/rabbit:topic-exchange&gt;--&gt;<br>    &lt;rabbit:direct-exchange name="directExchange" auto-declare="true" &gt;&lt;/rabbit:direct-exchange&gt;<br>    &lt;!--&lt;rabbit:fanout-exchange name="fanoutExchange" auto-declare="true" &gt;&lt;/rabbit:fanout-exchange&gt;--&gt;<br><br>    &lt;!-- 定义Rabbit模板，指定连接工厂以及定义exchange(exchange要和上面的一致) --&gt;<br>    &lt;!--&lt;rabbit:template id="amqpTemplate" connection-factory="connectionFactory" exchange="topicExchange" /&gt;--&gt;<br>    &lt;rabbit:template id="amqpTemplate" connection-factory="connectionFactory" exchange="directExchange" /&gt;<br>    &lt;!--&lt;rabbit:template id="amqpTemplate" connection-factory="connectionFactory" exchange="fanoutExchange" /&gt;--&gt;<br> &lt;/beans&gt;<br><br> 7.1.4.消息内容<br> 方案：<br> 1、消息内容使用对象做json序列化发送<br> a)数据大<br> b)有些数据其他人是可能用不到的<br> 2、发送特定的业务字段，如id、操作类型<br><br> 7.1.5.实现<br> 生产者MsgSender.java：<br><br> package com.zpc.myrabbit;<br><br> import com.alibaba.fastjson.JSON;<br> import org.springframework.amqp.rabbit.core.RabbitTemplate;<br> import org.springframework.context.support.AbstractApplicationContext;<br> import org.springframework.context.support.ClassPathXmlApplicationContext;<br><br> import java.text.SimpleDateFormat;<br> import java.util.Date;<br> import java.util.HashMap;<br> import java.util.Map;<br><br><br> /**<br> * 消息生产者<br> */<br> public class MsgSender {<!-- --><br>     public static void main(String[] args) throws Exception {<!-- --><br>         AbstractApplicationContext ctx = new ClassPathXmlApplicationContext(<br>                 "classpath:spring/rabbitmq-context.xml");<br>         //RabbitMQ模板<br>         RabbitTemplate template = ctx.getBean(RabbitTemplate.class);<br><br>         String date = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss").format(new Date());//24小时制<br>         //发送消息<br>         Map&lt;String, Object&gt; msg = new HashMap&lt;String, Object&gt;();<br>         msg.put("type", "1");<br>         msg.put("date", date);<br>         template.convertAndSend("type2", JSON.toJSONString(msg));<br>         Thread.sleep(1000);// 休眠1秒<br>         ctx.destroy(); //容器销毁<br>     }<br> }<br> 7.2.在B系统接收消息<br> 7.2.1.导入依赖<br><br> &lt;?xml version="1.0" encoding="UTF-8"?&gt;<br> &lt;project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"<br>          xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 <a href="http://maven.apache.org/xsd/maven-4.0.0.xsd" rel="nofollow">http://maven.apache.org/xsd/maven-4.0.0.xsd</a>"&gt;<br>     &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;<br><br>     &lt;groupId&gt;com.zpc&lt;/groupId&gt;<br>     &lt;artifactId&gt;myrabbitB&lt;/artifactId&gt;<br>     &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt;<br>     &lt;packaging&gt;war&lt;/packaging&gt;<br><br>     &lt;name&gt;myrabbit&lt;/name&gt;<br>     &lt;properties&gt;<br>         &lt;spring.version&gt;4.1.3.RELEASE&lt;/spring.version&gt;<br>         &lt;fastjson.version&gt;1.2.46&lt;/fastjson.version&gt;<br>     &lt;/properties&gt;<br><br>     &lt;dependencies&gt;<br>         &lt;dependency&gt;<br>             &lt;groupId&gt;com.rabbitmq&lt;/groupId&gt;<br>             &lt;artifactId&gt;amqp-client&lt;/artifactId&gt;<br>             &lt;version&gt;3.4.1&lt;/version&gt;<br>         &lt;/dependency&gt;<br>         &lt;dependency&gt;<br>             &lt;groupId&gt;org.springframework.amqp&lt;/groupId&gt;<br>             &lt;artifactId&gt;spring-rabbit&lt;/artifactId&gt;<br>             &lt;version&gt;1.4.0.RELEASE&lt;/version&gt;<br>         &lt;/dependency&gt;<br>         &lt;dependency&gt;<br>             &lt;groupId&gt;org.springframework&lt;/groupId&gt;<br>             &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt;<br>             &lt;version&gt;${spring.version}&lt;/version&gt;<br>         &lt;/dependency&gt;<br>         &lt;dependency&gt;<br>             &lt;groupId&gt;com.alibaba&lt;/groupId&gt;<br>             &lt;artifactId&gt;fastjson&lt;/artifactId&gt;<br>             &lt;version&gt;1.2.47&lt;/version&gt;<br>         &lt;/dependency&gt;<br>     &lt;/dependencies&gt;<br><br>     &lt;build&gt;<br>         &lt;finalName&gt;${project.artifactId}&lt;/finalName&gt;<br>         &lt;plugins&gt;<br>             &lt;!-- web层需要配置Tomcat插件 --&gt;<br>             &lt;plugin&gt;<br>                 &lt;groupId&gt;org.apache.tomcat.maven&lt;/groupId&gt;<br>                 &lt;artifactId&gt;tomcat7-maven-plugin&lt;/artifactId&gt;<br>                 &lt;configuration&gt;<br>                     &lt;path&gt;/testRabbit&lt;/path&gt;<br>                     &lt;uriEncoding&gt;UTF-8&lt;/uriEncoding&gt;<br>                     &lt;port&gt;8081&lt;/port&gt;<br>                 &lt;/configuration&gt;<br>             &lt;/plugin&gt;<br>         &lt;/plugins&gt;<br>     &lt;/build&gt;<br> &lt;/project&gt;<br> 7.2.2.配置<br><br> &lt;beans xmlns="http://www.springframework.org/schema/beans"<br>    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:rabbit="http://www.springframework.org/schema/rabbit"<br>    xsi:schemaLocation="http://www.springframework.org/schema/rabbit<br>    <a href="http://www.springframework.org/schema/rabbit/spring-rabbit-1.4.xsd" rel="nofollow">http://www.springframework.org/s ... ring-rabbit-1.4.xsd</a><br>    <a href="http://www.springframework.org/schema/beans" rel="nofollow">http://www.springframework.org/schema/beans</a><br>    <a href="http://www.springframework.org/schema/beans/spring-beans-4.1.xsd" rel="nofollow">http://www.springframework.org/schema/beans/spring-beans-4.1.xsd</a>"&gt;<br><br>    &lt;!-- 定义RabbitMQ的连接工厂 --&gt;<br>    &lt;rabbit:connection-factory id="connectionFactory"<br>       host="127.0.0.1" port="5672" username="admin" password="admin"<br>       virtual-host="testhost" /&gt;<br><br>    &lt;!-- MQ的管理，包括队列、交换器等 --&gt;<br>    &lt;rabbit:admin connection-factory="connectionFactory" /&gt;<br><br>    &lt;!-- 定义B系统需要监听的队列，自动声明 --&gt;<br>    &lt;rabbit:queue name="q_topic_testB" auto-declare="true"/&gt;<br><br>    &lt;!-- 队列监听 --&gt;<br>    &lt;rabbit:listener-container connection-factory="connectionFactory"&gt;<br>       &lt;rabbit:listener ref="myMQlistener" method="listen" queue-names="q_topic_testB" /&gt;<br>    &lt;/rabbit:listener-container&gt;<br><br>    &lt;bean id="myMQlistener" class="com.zpc.myrabbit.listener.Listener" /&gt;<br> &lt;/beans&gt;<br> 7.2.3.具体处理逻辑<br><br> public class Listener {<!-- --><br>     //具体执行业务的方法<br>     public void listen(String msg) {<!-- --><br>         System.out.println("\n消费者B开始处理消息： " + msg + "\n");<br>     }<br> }<br> 7.2.4.在界面管理工具中完成绑定关系<br> 选中定义好的交换机(exchange)<br><br> 1）direct<br><br> 2）fanout<br><br> 3）topic<br><br><br> 7.3.在C系统中接收消息<br> （和B系统配置差不多，无非是Q名和Q对应的处理逻辑变了）<br><br> 7.3.1.配置<br><br> &lt;beans xmlns="http://www.springframework.org/schema/beans"<br>    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:rabbit="http://www.springframework.org/schema/rabbit"<br>    xsi:schemaLocation="http://www.springframework.org/schema/rabbit<br>    <a href="http://www.springframework.org/schema/rabbit/spring-rabbit-1.4.xsd" rel="nofollow">http://www.springframework.org/s ... ring-rabbit-1.4.xsd</a><br>    <a href="http://www.springframework.org/schema/beans" rel="nofollow">http://www.springframework.org/schema/beans</a><br>    <a href="http://www.springframework.org/schema/beans/spring-beans-4.1.xsd" rel="nofollow">http://www.springframework.org/schema/beans/spring-beans-4.1.xsd</a>"&gt;<br><br>    &lt;!-- 定义RabbitMQ的连接工厂 --&gt;<br>    &lt;rabbit:connection-factory id="connectionFactory"<br>       host="127.0.0.1" port="5672" username="admin" password="admin"<br>       virtual-host="testhost" /&gt;<br><br>    &lt;!-- MQ的管理，包括队列、交换器等 --&gt;<br>    &lt;rabbit:admin connection-factory="connectionFactory" /&gt;<br><br>    &lt;!-- 定义C系统需要监听的队列，自动声明 --&gt;<br>    &lt;rabbit:queue name="q_topic_testC" auto-declare="true"/&gt;<br><br>    &lt;!-- 队列监听 --&gt;<br>    &lt;rabbit:listener-container connection-factory="connectionFactory"&gt;<br>       &lt;rabbit:listener ref="myMQlistener" method="listen" queue-names="q_topic_testC" /&gt;<br>    &lt;/rabbit:listener-container&gt;<br><br>    &lt;bean id="myMQlistener" class="com.zpc.myrabbit.listener.Listener" /&gt;<br> &lt;/beans&gt;<br> 7.3.2.处理业务逻辑<br><br> public class Listener {<!-- --><br><br>     //具体执行业务的方法<br>     public void listen(String msg) {<!-- --><br>         System.out.println("\n消费者C开始处理消息： " + msg + "\n");<br>     }<br> }<br><br> 7.3.3.在管理工具中绑定队列和交换机<br> 见7.2.4<br><br> 7.3.4.测试<br> 分别启动B,C两个web应用，然后运行A的MsgSender主方法发送消息，分别测试fanout、direct、topic三种类型<br><br> 8.Springboot集成RabbitMQ<br> springboot集成RabbitMQ非常简单，如果只是简单的使用配置非常少，springboot提供了spring-boot-starter-amqp对消息各种支持。<br> 代码下载地址：<a href="https://download.csdn.net/download/zpcandzhj/10585077">https://download.csdn.net/download/zpcandzhj/10585077</a><br> 8.1.简单队列<br> 1、配置pom文件，主要是添加spring-boot-starter-amqp的支持<br><br> &lt;dependency&gt;<br>    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;<br>    &lt;artifactId&gt;spring-boot-starter-amqp&lt;/artifactId&gt;<br> &lt;/dependency&gt;<br> 2、配置application.properties文件<br> 配置rabbitmq的安装地址、端口以及账户信息<br><br> spring.application.name=spirng-boot-rabbitmq<br> spring.rabbitmq.host=127.0.0.1<br> spring.rabbitmq.port=5672<br> spring.rabbitmq.username=admin<br> spring.rabbitmq.password=admin<br> 3、配置队列<br><br> package com.zpc.rabbitmq;<br><br> import org.springframework.amqp.core.Queue;<br> import org.springframework.context.annotation.Bean;<br> import org.springframework.context.annotation.Configuration;<br><br> @Configuration<br> public class RabbitConfig {<!-- --><br>     @Bean<br>     public Queue queue() {<!-- --><br>         return new Queue("q_hello");<br>     }<br> }<br> 4、发送者<br><br> package com.zpc.rabbitmq;<br><br> import org.springframework.amqp.core.AmqpTemplate;<br> import org.springframework.beans.factory.annotation.Autowired;<br> import org.springframework.stereotype.Component;<br><br> import java.text.SimpleDateFormat;<br> import java.util.Date;<br><br> @Component<br> public class HelloSender {<!-- --><br>     @Autowired<br>     private AmqpTemplate rabbitTemplate;<br><br>     public void send() {<!-- --><br>         String date = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss").format(new Date());//24小时制<br>         String context = "hello " + date;<br>         System.out.println("Sender : " + context);<br>         //简单对列的情况下routingKey即为Q名<br>         this.rabbitTemplate.convertAndSend("q_hello", context);<br>     }<br> }<br> 5、接收者<br><br> package com.zpc.rabbitmq;<br><br> import org.springframework.amqp.rabbit.annotation.RabbitHandler;<br> import org.springframework.amqp.rabbit.annotation.RabbitListener;<br> import org.springframework.stereotype.Component;<br><br> @Component<br> @RabbitListener(queues = "q_hello")<br> public class HelloReceiver {<!-- --><br><br>     @RabbitHandler<br>     public void process(String hello) {<!-- --><br>         System.out.println("Receiver  : " + hello);<br>     }<br> }<br> 6、测试<br><br> package com.zpc.rabbitmq;<br><br> import org.junit.Test;<br> import org.junit.runner.RunWith;<br> import org.springframework.beans.factory.annotation.Autowired;<br> import org.springframework.boot.test.context.SpringBootTest;<br> import org.springframework.test.context.junit4.SpringRunner;<br><br> @RunWith(SpringRunner.class)<br> @SpringBootTest<br> public class RabbitMqHelloTest {<!-- --><br><br>     @Autowired<br>     private HelloSender helloSender;<br><br>     @Test<br>     public void hello() throws Exception {<!-- --><br>         helloSender.send();<br>     }<br> }<br> 8.2.多对多使用（Work模式）<br> 注册两个Receiver:<br><br> package com.zpc.rabbitmq;<br><br> import org.springframework.amqp.rabbit.annotation.RabbitHandler;<br> import org.springframework.amqp.rabbit.annotation.RabbitListener;<br> import org.springframework.stereotype.Component;<br><br> @Component<br> @RabbitListener(queues = "q_hello")<br> public class HelloReceiver2 {<!-- --><br><br>     @RabbitHandler<br>     public void process(String hello) {<!-- --><br>         System.out.println("Receiver2  : " + hello);<br>     }<br><br> }<br> @Test<br> public void oneToMany() throws Exception {<!-- --><br>     for (int i=0;i&lt;100;i++){<!-- --><br>         helloSender.send(i);<br>         Thread.sleep(300);<br>     }<br> }<br> public void send(int i) {<!-- --><br>     String date = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss").format(new Date());//24小时制<br>     String context = "hello " + i + " " + date;<br>     System.out.println("Sender : " + context);<br>     //简单对列的情况下routingKey即为Q名<br>     this.rabbitTemplate.convertAndSend("q_hello", context);<br> }<br> 8.3.Topic Exchange（主题模式）<br> topic 是RabbitMQ中最灵活的一种方式，可以根据routing_key自由的绑定不同的队列<br> 首先对topic规则配置，这里使用两个队列(消费者)来演示。<br> 1)配置队列，绑定交换机<br><br> package com.zpc.rabbitmq.topic;<br><br> import org.springframework.amqp.core.Binding;<br> import org.springframework.amqp.core.BindingBuilder;<br> import org.springframework.amqp.core.Queue;<br> import org.springframework.amqp.core.TopicExchange;<br> import org.springframework.context.annotation.Bean;<br> import org.springframework.context.annotation.Configuration;<br><br> @Configuration<br> public class TopicRabbitConfig {<!-- --><br><br>     final static String message = "q_topic_message";<br>     final static String messages = "q_topic_messages";<br><br>     @Bean<br>     public Queue queueMessage() {<!-- --><br>         return new Queue(TopicRabbitConfig.message);<br>     }<br><br>     @Bean<br>     public Queue queueMessages() {<!-- --><br>         return new Queue(TopicRabbitConfig.messages);<br>     }<br><br>     /**<br>      * 声明一个Topic类型的交换机<br>      * @return<br>      */<br>     @Bean<br>     TopicExchange exchange() {<!-- --><br>         return new TopicExchange("mybootexchange");<br>     }<br><br>     /**<br>      * 绑定Q到交换机,并且指定routingKey<br>      * @param queueMessage<br>      * @param exchange<br>      * @return<br>      */<br>     @Bean<br>     Binding bindingExchangeMessage(Queue queueMessage, TopicExchange exchange) {<!-- --><br>         return BindingBuilder.bind(queueMessage).to(exchange).with("topic.message");<br>     }<br><br>     @Bean<br>     Binding bindingExchangeMessages(Queue queueMessages, TopicExchange exchange) {<!-- --><br>         return BindingBuilder.bind(queueMessages).to(exchange).with("topic.#");<br>     }<br> }<br> 2)创建2个消费者<br> q_topic_message 和q_topic_messages<br><br> package com.zpc.rabbitmq.topic;<br><br> import org.springframework.amqp.rabbit.annotation.RabbitHandler;<br> import org.springframework.amqp.rabbit.annotation.RabbitListener;<br> import org.springframework.stereotype.Component;<br><br> @Component<br> @RabbitListener(queues = "q_topic_message")<br> public class Receiver1 {<!-- --><br><br>     @RabbitHandler<br>     public void process(String hello) {<!-- --><br>         System.out.println("Receiver1  : " + hello);<br>     }<br> }<br> package com.zpc.rabbitmq.topic;<br><br> import org.springframework.amqp.rabbit.annotation.RabbitHandler;<br> import org.springframework.amqp.rabbit.annotation.RabbitListener;<br> import org.springframework.stereotype.Component;<br><br> @Component<br> @RabbitListener(queues = "q_topic_messages")<br> public class Receiver2 {<!-- --><br><br>     @RabbitHandler<br>     public void process(String hello) {<!-- --><br>         System.out.println("Receiver2 : " + hello);<br>     }<br> }<br> 3)消息发送者（生产者）<br><br> package com.zpc.rabbitmq.topic;<br><br> import org.springframework.amqp.core.AmqpTemplate;<br> import org.springframework.beans.factory.annotation.Autowired;<br> import org.springframework.stereotype.Component;<br><br> @Component<br> public class MsgSender {<!-- --><br><br>     @Autowired<br>     private AmqpTemplate rabbitTemplate;<br><br>     public void send1() {<!-- --><br>         String context = "hi, i am message 1";<br>         System.out.println("Sender : " + context);<br>         this.rabbitTemplate.convertAndSend("mybootexchange", "topic.message", context);<br>     }<br><br><br>     public void send2() {<!-- --><br>         String context = "hi, i am messages 2";<br>         System.out.println("Sender : " + context);<br>         this.rabbitTemplate.convertAndSend("mybootexchange", "topic.messages", context);<br>     }<br> }<br> send1方法会匹配到topic.#和topic.message，两个Receiver都可以收到消息，发送send2只有topic.#可以匹配所有只有Receiver2监听到消息。<br> 4)测试<br><br> package com.zpc.rabbitmq.topic;<br><br> import org.junit.Test;<br> import org.junit.runner.RunWith;<br> import org.springframework.beans.factory.annotation.Autowired;<br> import org.springframework.boot.test.context.SpringBootTest;<br> import org.springframework.test.context.junit4.SpringRunner;<br><br> @RunWith(SpringRunner.class)<br> @SpringBootTest<br> public class RabbitTopicTest {<!-- --><br><br>     @Autowired<br>     private MsgSender msgSender;<br><br>     @Test<br>     public void send1() throws Exception {<!-- --><br>         msgSender.send1();<br>     }<br><br>     @Test<br>     public void send2() throws Exception {<!-- --><br>         msgSender.send2();<br>     }<br> }<br> 8.4.Fanout Exchange（订阅模式）<br> Fanout 就是我们熟悉的广播模式或者订阅模式，给Fanout交换机发送消息，绑定了这个交换机的所有队列都收到这个消息。<br> 1)配置队列，绑定交换机<br> package com.zpc.rabbitmq.fanout;<br><br> import org.springframework.amqp.core.Binding;<br> import org.springframework.amqp.core.BindingBuilder;<br> import org.springframework.amqp.core.FanoutExchange;<br> import org.springframework.amqp.core.Queue;<br> import org.springframework.context.annotation.Bean;<br> import org.springframework.context.annotation.Configuration;<br><br> @Configuration<br> public class FanoutRabbitConfig {<!-- --><br><br>     @Bean<br>     public Queue aMessage() {<!-- --><br>         return new Queue("q_fanout_A");<br>     }<br><br>     @Bean<br>     public Queue bMessage() {<!-- --><br>         return new Queue("q_fanout_B");<br>     }<br><br>     @Bean<br>     public Queue cMessage() {<!-- --><br>         return new Queue("q_fanout_C");<br>     }<br><br>     @Bean<br>     FanoutExchange fanoutExchange() {<!-- --><br>         return new FanoutExchange("mybootfanoutExchange");<br>     }<br><br>     @Bean<br>     Binding bindingExchangeA(Queue aMessage, FanoutExchange fanoutExchange) {<!-- --><br>         return BindingBuilder.bind(aMessage).to(fanoutExchange);<br>     }<br><br>     @Bean<br>     Binding bindingExchangeB(Queue bMessage, FanoutExchange fanoutExchange) {<!-- --><br>         return BindingBuilder.bind(bMessage).to(fanoutExchange);<br>     }<br><br>     @Bean<br>     Binding bindingExchangeC(Queue cMessage, FanoutExchange fanoutExchange) {<!-- --><br>         return BindingBuilder.bind(cMessage).to(fanoutExchange);<br>     }<br> }<br> 2）创建3个消费者<br><br> package com.zpc.rabbitmq.fanout;<br><br> import org.springframework.amqp.rabbit.annotation.RabbitHandler;<br> import org.springframework.amqp.rabbit.annotation.RabbitListener;<br> import org.springframework.stereotype.Component;<br><br> @Component<br> @RabbitListener(queues = "q_fanout_A")<br> public class ReceiverA {<!-- --><br><br>     @RabbitHandler<br>     public void process(String hello) {<!-- --><br>         System.out.println("AReceiver  : " + hello + "/n");<br>     }<br> }<br> package com.zpc.rabbitmq.fanout;<br><br> import org.springframework.amqp.rabbit.annotation.RabbitHandler;<br> import org.springframework.amqp.rabbit.annotation.RabbitListener;<br> import org.springframework.stereotype.Component;<br><br> @Component<br> @RabbitListener(queues = "q_fanout_B")<br> public class ReceiverB {<!-- --><br><br>     @RabbitHandler<br>     public void process(String hello) {<!-- --><br>         System.out.println("BReceiver  : " + hello + "/n");<br>     }<br> }<br> package com.zpc.rabbitmq.fanout;<br><br> import org.springframework.amqp.rabbit.annotation.RabbitHandler;<br> import org.springframework.amqp.rabbit.annotation.RabbitListener;<br> import org.springframework.stereotype.Component;<br><br> @Component<br> @RabbitListener(queues = "q_fanout_C")<br> public class ReceiverC {<!-- --><br><br>     @RabbitHandler<br>     public void process(String hello) {<!-- --><br>         System.out.println("CReceiver  : " + hello + "/n");<br>     }<br> }<br> 3）生产者<br><br> package com.zpc.rabbitmq.fanout;<br><br> import org.springframework.amqp.core.AmqpTemplate;<br> import org.springframework.beans.factory.annotation.Autowired;<br> import org.springframework.stereotype.Component;<br><br> @Component<br> public class MsgSenderFanout {<!-- --><br><br>     @Autowired<br>     private AmqpTemplate rabbitTemplate;<br><br>     public void send() {<!-- --><br>         String context = "hi, fanout msg ";<br>         System.out.println("Sender : " + context);<br>         this.rabbitTemplate.convertAndSend("mybootfanoutExchange","", context);<br>     }<br> }<br><br> 4）测试<br><br> package com.zpc.rabbitmq.fanout;<br><br> import org.junit.Test;<br> import org.junit.runner.RunWith;<br> import org.springframework.beans.factory.annotation.Autowired;<br> import org.springframework.boot.test.context.SpringBootTest;<br> import org.springframework.test.context.junit4.SpringRunner;<br><br> @RunWith(SpringRunner.class)<br> @SpringBootTest<br> public class RabbitFanoutTest {<!-- --><br><br>     @Autowired<br>     private MsgSenderFanout msgSender;<br><br>     @Test<br>     public void send1() throws Exception {<!-- --><br>         msgSender.send();<br>     }<br> }<br> 结果如下，三个消费者都收到消息：<br> AReceiver : hi, fanout msg<br> CReceiver : hi, fanout msg<br> BReceiver : hi, fanout msg<br><br> 9.总结<br> 使用MQ实现商品数据的同步优势：<br> 1、降低系统间耦合度<br> 2、便于管理数据的同步（数据一致性）</td></tr></tbody></table></td></tr></tbody></table>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/795d4071c884e4a6f765b8ce3cce12a8/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">confluence忘记密码</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/6a0d4250d3b2edc7e3a8f5b638a07010/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">Logstash-安装</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>