<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>LIS（最长上升子序列）nlogn求法 - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="LIS（最长上升子序列）nlogn求法" />
<meta property="og:description" content="思想：贪心&#43;二分 新建一个low数组，low[i]表示长度为i的LIS结尾元素的最小值。对于一个上升子序列，显然其结尾元素越小，越有利于在后面接其他的元素，也就越可能变得更长。因此，我们只需要维护low数组，对于每一个a[i]，如果a[i] &gt; low[当前最长的LIS长度]，就把a[i]接到当前最长的LIS后面，即low[&#43;&#43;当前最长的LIS长度]=a[i]。 那么，怎么维护low数组呢？ 对于每一个a[i]，如果a[i]能接到LIS后面，就接上去；否则，就用a[i]取更新low数组。具体方法是，在low数组中找到第一个大于等于a[i]的元素low[j]，用a[i]去更新low[j]。如果从头到尾扫一遍low数组的话，时间复杂度仍是O(n^2)。我们注意到low数组内部一定是单调不降的，所有我们可以二分low数组，找出第一个大于等于a[i]的元素。二分一次low数组的时间复杂度的O(lgn)，所以总的时间复杂度是O(nlogn)。
下面上LIS模板：
#include&lt;cstdio&gt; #include &lt;iostream&gt; #include&lt;cstring&gt; #include&lt;algorithm&gt; #define MAXN 100005 using namespace std; int arr[MAXN],ans[MAXN],len; int main(){ int p = 0; while(~scanf(&#34;%d&#34;,&amp;arr[&#43;&#43;p])); p--; memset(ans,0,sizeof ans); ans[1] = arr[1]; len=1; for(int i=2; i&lt;=p; &#43;&#43;i){ if(arr[i] &gt; ans[len]) ans[&#43;&#43;len]=arr[i];//如果大于末尾的数， 直接放在末尾，长度&#43;1 else{ int pos=lower_bound(ans&#43;1,ans&#43;len&#43;1,arr[i])-ans; //如果比末尾的数小，则找到数组中第一个比arr[i]大或相等的位置，并将该位置的值覆盖为arr[i] ans[pos] = arr[i]; } } printf(&#34;%d\n&#34;,len); return 0; } 这里有lower_bound()和upper_bound()的用法：lower_bound VS upper_bound(用法详解)
下面看一道例题，更深的理解下LIS思想
导弹拦截
题意很明确，求出所给序列的最大不上升子序列和最大上升子序列，
什么是最大不上升子序列呢？
举个栗子：90 103 99 83 102 70 86 70 99 71" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/dba0421f36db4db8f9f0703b435ce89a/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2018-11-18T20:02:24+08:00" />
<meta property="article:modified_time" content="2018-11-18T20:02:24+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">LIS（最长上升子序列）nlogn求法</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <h3>思想：贪心+二分</h3> 
<p>新建一个low数组，low[i]表示长度为i的LIS结尾元素的最小值。<strong>对于一个上升子序列，显然其结尾元素越小，越有利于在后面接其他的元素，也就越可能变得更长。</strong>因此，我们只需要维护low数组，对于每一个a[i]，如果a[i] &gt; low[当前最长的LIS长度]，就把a[i]接到当前最长的LIS后面，即low[++当前最长的LIS长度]=a[i]。 <br> 那么，怎么维护low数组呢？ <br> 对于每一个a[i]，如果a[i]能接到LIS后面，就接上去；否则，就用a[i]取更新low数组。具体方法是，在low数组中找到第一个大于等于a[i]的元素low[j]，用a[i]去更新low[j]。如果从头到尾扫一遍low数组的话，时间复杂度仍是O(n^2)。我们注意到low数组内部一定是单调不降的，所有我们可以二分low数组，找出第一个大于等于a[i]的元素。二分一次low数组的时间复杂度的O(lgn)，所以总的时间复杂度是<strong><em>O(nlogn)</em></strong>。</p> 
<p>下面上LIS模板：</p> 
<pre class="has"><code class="language-cpp">#include&lt;cstdio&gt;
#include &lt;iostream&gt;
#include&lt;cstring&gt;
#include&lt;algorithm&gt;
#define MAXN 100005
using namespace std;
int arr[MAXN],ans[MAXN],len; 
int main(){
	int p = 0;
	while(~scanf("%d",&amp;arr[++p]));
	p--;
	memset(ans,0,sizeof ans);
	ans[1] = arr[1];
	len=1;
	for(int i=2; i&lt;=p; ++i){
		if(arr[i] &gt; ans[len])
			ans[++len]=arr[i];//如果大于末尾的数， 直接放在末尾，长度+1 
		else{
			int pos=lower_bound(ans+1,ans+len+1,arr[i])-ans; //如果比末尾的数小，则找到数组中第一个比arr[i]大或相等的位置，并将该位置的值覆盖为arr[i] 
			ans[pos] = arr[i];
			}
	}
	printf("%d\n",len);
	return 0;
}</code></pre> 
<p>这里有lower_bound()和upper_bound()的用法：<a href="https://blog.csdn.net/qq_42321579/article/details/83115860">lower_bound VS upper_bound(用法详解)</a></p> 
<p>下面看一道例题，更深的理解下LIS思想</p> 
<p><a href="https://www.luogu.org/problemnew/show/P1020" rel="nofollow">导弹拦截</a></p> 
<p>题意很明确，求出所给序列的最大不上升子序列和最大上升子序列，</p> 
<p>什么是最大不上升子序列呢？</p> 
<p>举个栗子：90 103 99  83 102 70 86 70 99 71</p> 
<p>此序列的LIS是：83 86 99</p> 
<p>而此序列的最大不上升子序列是：103 99 83 70 70</p> 
<p>也就是说子序列中元素可以重复，首先我们可以求LIS，而求下降的子序列就可以将所给序列倒转过来，然后求一下LIS，</p> 
<p>可是这里需要注意，我们不仅要求下降的，如果两个元素相同也要算上，那么我们就要将LIS的代码稍作一下改动，</p> 
<p>首先看下序列倒过来后：71 99 70 86 70 102 83 99 103 90</p> 
<pre class="has"><code class="language-cpp">	for(int i=2; i&lt;=p; ++i){
		if(arr[i] &gt;= ans[len])
			ans[++len]=arr[i];//如果大于等于末尾的数， 直接放在末尾，长度+1 
		else{
			int pos = upper_bound(ans+1,ans+len+1,arr[i])-ans; //如果比末尾的数小，则找到数组中第一个比arr[i]大的位置，并将该位置的值改变为arr[i] 
			ans[pos] = arr[i];
			}
	}</code></pre> 
<p>这里要区分下upper_bound，还是看上面那个栗子，如果我们找到第二个70的时候，进入else,如果按照low_bound()的原理，会直接找到第一个大于或等于70的数，看下ans的目前状态：ans[] = 70,86;显然70会找到70并且覆盖掉它，这是我们不希望看到的，这会导致最后的结果长度少一，所以我们这里要用upper_bound找到第一个大于70的数，让等于的情况合法，这样70覆盖86，ans[] = 70,70; 这样一来我们就得到了最长不下降子序列的长度，是不是更深入地理解LIS的过程了呢？</p> 
<p>下面上本题代码：</p> 
<pre class="has"><code class="language-cpp">#include&lt;cstdio&gt;
#include &lt;iostream&gt;
#include&lt;cstring&gt;
#include&lt;algorithm&gt;
#define MAXN 100005
using namespace std;
int arr[MAXN],ans[MAXN],len; 
int main(){
    int p = 0;
    while(~scanf("%d",&amp;arr[++p]));
    p--;
    for(int i = 1; i &lt;= (p &gt;&gt; 1); i++) {
        swap(arr[i], arr[p - i + 1]);
    }
    memset(ans,0,sizeof ans);
    ans[1] = arr[1];
    len=1;
    for(int i=2; i&lt;=p; ++i){
        if(arr[i] &gt;= ans[len])
            ans[++len]=arr[i];//如果大于等于末尾的数， 直接放在末尾，长度+1 
        else{
            int pos = upper_bound(ans+1,ans+len+1,arr[i])-ans; //如果比末尾的数小，则找到数组中第一个比arr[i]大的位置，并将该位置的值改变为arr[i] 
            ans[pos] = arr[i];
            }
    }
    for(int i = 1; i &lt;= (p &gt;&gt; 1); i++) {
        swap(arr[i], arr[p - i + 1]);
    }
    printf("%d\n",len);
    memset(ans,0,sizeof ans);
    ans[1] = arr[1];
    len=1;
    for(int i=2; i&lt;=p; ++i){
        if(arr[i] &gt; ans[len])
            ans[++len]=arr[i];//如果大于末尾的数， 直接放在末尾，长度+1 
        else{
            int pos=lower_bound(ans+1,ans+len+1,arr[i])-ans; //如果比末尾的数小，则找到数组中第一个比arr[i]大或等于的位置，并将该位置的值改变为arr[i] 
            ans[pos] = arr[i];
            }
    }
    printf("%d\n",len);
    return 0;
}</code></pre> 
<p> </p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/aa9a64cb8cfbb4b4b25465723a22e230/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">Unity-Get/Set属性访问器详解</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/4954084e0cf92005805a4443b2184d9a/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">Google Kickstart round H 2018</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>