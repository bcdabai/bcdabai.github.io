<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>第五章 API 题库 - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="第五章 API 题库" />
<meta property="og:description" content="1、下列选项中，可以正确实现String初始化的是（） A、 String str = &#34;abc&#34;;
B、 String str = ‘abc’;
C、 String str = abc;
D、 String str = 0;
答案： A
2、下面哪个方法可以实现获取字符在某个字符串中第一次出现的索引？（） A、 char charAt(int index)；
B、 int indexOf(int ch);
C、 int lastIndexOf(int ch);
D、 boolean endsWith(String suffix);
E、 ：B
F、 解析：A答案返回字符串中index位置上的字符
G、 案返回指定字符在此字符串中最后一次出现处的索引
答案： D
3、阅读下面的程序：
class StringDemo{
public static void main(String[] args){
String s1 = “a”;
String s2 = “b”;
show(s1,s2);
System.out.println(s1&#43;s2);
}
public static void show(String s1,String s2){" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/d1af264661d71dbfccd9a24c01afd61e/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-05-29T16:00:36+08:00" />
<meta property="article:modified_time" content="2023-05-29T16:00:36+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">第五章 API 题库</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p style="margin-left:0;text-align:center;"></p> 
<p style="margin-left:0cm;"><strong>1</strong><strong>、下列选项中，可以正确实现String初始化的是（） </strong></p> 
<p style="margin-left:0;">A、 String str = "abc";</p> 
<p style="margin-left:0;">B、 String str = ‘abc’;</p> 
<p style="margin-left:0;">C、 String str = abc;</p> 
<p style="margin-left:0;">D、 String str = 0;</p> 
<p style="margin-left:0;">答案： A</p> 
<p style="margin-left:0cm;"><strong>2</strong><strong>、下面哪个方法可以实现获取字符在某个字符串中第一次出现的索引？（） </strong></p> 
<p style="margin-left:0;">A、 char charAt(int index)；</p> 
<p style="margin-left:0;">B、 int indexOf(int ch);</p> 
<p style="margin-left:0;">C、 int lastIndexOf(int ch);</p> 
<p style="margin-left:0;">D、 boolean endsWith(String suffix);</p> 
<p style="margin-left:0;">E、 ：B</p> 
<p style="margin-left:0;">F、 解析：A答案返回字符串中index位置上的字符</p> 
<p style="margin-left:0;">G、 案返回指定字符在此字符串中最后一次出现处的索引</p> 
<p style="margin-left:0;">答案： D</p> 
<p style="margin-left:0;"><strong>3、<span style="color:#303133;">阅读下面的程序：</span></strong></p> 
<p style="margin-left:0;"><strong><span style="color:#303133;">class StringDemo{<!-- --></span></strong></p> 
<p style="margin-left:0;"><strong><span style="color:#303133;">  public static void main(String[] args){<!-- --></span></strong></p> 
<p style="margin-left:0;"><strong><span style="color:#303133;">    String s1 = “a”;</span></strong></p> 
<p style="margin-left:0;"><strong><span style="color:#303133;">  String s2 = “b”;</span></strong></p> 
<p style="margin-left:0;"><strong><span style="color:#303133;">  show(s1,s2);</span></strong></p> 
<p style="margin-left:0;"><strong><span style="color:#303133;">  System.out.println(s1+s2);</span></strong></p> 
<p style="margin-left:0;"><strong><span style="color:#303133;">}</span></strong></p> 
<p style="margin-left:0;"><strong><span style="color:#303133;"> public static void show(String s1,String s2){<!-- --></span></strong></p> 
<p style="margin-left:0;"><strong><span style="color:#303133;">     s1 = s1 +”q”;</span></strong></p> 
<p style="margin-left:0;"><strong><span style="color:#303133;">     s2 = s2 + s1;</span></strong></p> 
<p style="margin-left:0;"><strong><span style="color:#303133;">}</span></strong></p> 
<p style="margin-left:0;"><strong><span style="color:#303133;">}</span></strong></p> 
<p style="margin-left:0;"><strong><span style="color:#303133;">上述程序的运行结果为（</span> <span style="color:#303133;">）</span></strong></p> 
<p style="margin-left:0;"></p> 
<p style="margin-left:0;">A、 ab</p> 
<p style="margin-left:0;">B、 aqb</p> 
<p style="margin-left:0;">C、</p> 
<p style="margin-left:0;">aqbaq</p> 
<p style="margin-left:0;"></p> 
<p style="margin-left:0;">D、 aqaqb</p> 
<p style="margin-left:0;">答案： A</p> 
<p style="margin-left:0cm;"><strong>4</strong><strong>、假如indexOf()方法未能找到所指定的子字符串，那么其返回值为（） </strong></p> 
<p style="margin-left:0;">A、 false</p> 
<p style="margin-left:0;">B、 0</p> 
<p style="margin-left:0;">C、 -1</p> 
<p style="margin-left:0;">D、 以上答案都不对</p> 
<p style="margin-left:0;">答案： C<br> 解析：indexOf()方法找不到指定的子字符串时，返回值为-1。</p> 
<p style="margin-left:0cm;"><strong>5</strong><strong>、已知 String 对象 s="abcdefg"，则 s.substring(2, 5)的返回值为（） </strong></p> 
<p style="margin-left:0;">A、 "bcde"</p> 
<p style="margin-left:0;">B、 "cde"</p> 
<p style="margin-left:0;">C、 "cdef"</p> 
<p style="margin-left:0;">D、 "def"</p> 
<p style="margin-left:0;">答案： B<br> 解析：字符串索引从0开始，substring()方法截取的字符串是包左不包右的。</p> 
<p style="margin-left:0cm;"><strong>6</strong><strong>、StringBuffer类的append()方法的返回值类型是（） </strong></p> 
<p style="margin-left:0;">A、 String</p> 
<p style="margin-left:0;">B、 void</p> 
<p style="margin-left:0;">C、 StringBuffer</p> 
<p style="margin-left:0;">D、 StringBuilder</p> 
<p style="margin-left:0;">答案： C<br> 解析：StringBuffer类似一个字符容器，当在其中添加或删除字符时，并不会产生新的StringBuffer对象返回值类型还是StringBuffer类型。</p> 
<p style="margin-left:0cm;"><strong>7</strong><strong>、String、StringBuffer和StringBuilder三个操作字符串的效率优先级顺序是（） </strong></p> 
<p style="margin-left:0;">A、 StringBuilder&gt;StringBuffer&gt;String</p> 
<p style="margin-left:0;">B、 StringBuffer &gt; StringBuilder &gt;String</p> 
<p style="margin-left:0;">C、 String&gt;StringBuffer&gt; StringBuilder</p> 
<p style="margin-left:0;">D、 三种字符串优先级一样</p> 
<p style="margin-left:0;">答案： C</p> 
<p style="margin-left:0cm;"><strong>8</strong><strong>、System类的getProperties()方法的作用是（） </strong></p> 
<p style="margin-left:0;">A、 获取当前的操作系统的属性</p> 
<p style="margin-left:0;">B、 获取当前JVM的属性</p> 
<p style="margin-left:0;">C、 获取指定键指示的操作系统属性</p> 
<p style="margin-left:0;">D、 获取指定键指示的JVM的属性</p> 
<p style="margin-left:0;">答案： A<br> 解析：System类的getProperties()方法的作用是确定当前系统的属性。</p> 
<p style="margin-left:0cm;"><strong>9</strong><strong>、下列关于System类的描述中，错误的是（） </strong></p> 
<p style="margin-left:0;">A、 System类是final关键字修饰的类，它不能被其他类所继承</p> 
<p style="margin-left:0;">B、 System类不能被实例化</p> 
<p style="margin-left:0;">C、 System类中定义了许多方法，但是没有定义字段</p> 
<p style="margin-left:0;">D、 System类中提供了获取当前系统属性的方法</p> 
<p style="margin-left:0;">答案： C<br> 解析：System类中定义了三个字段，err、out和in，分别表示“标准”错误输出流、“标准”输入流和“标准”输出流。</p> 
<p style="margin-left:0;"><strong>10、<span style="color:#303133;">阅读下列代码：</span></strong></p> 
<p style="margin-left:0;"><strong><span style="color:#303133;">public class Example {<!-- --></span></strong></p> 
<p style="margin-left:0;"><strong><span style="color:#303133;"> public static void main(String[] args) {<!-- --></span></strong></p> 
<p style="margin-left:0;"><strong><span style="color:#303133;">  int[] srcArray = { 11, 12, 13, 14 };</span></strong></p> 
<p style="margin-left:0;"><strong><span style="color:#303133;">  int[] destArray = { 21, 22, 23, 24 };</span></strong></p> 
<p style="margin-left:0;"><strong><span style="color:#303133;">  System.arraycopy(srcArray, 1, destArray, 2, 2);</span></strong></p> 
<p style="margin-left:0;"><strong><span style="color:#303133;">  for (int i = 0; i &lt; destArray.length; i++) {<!-- --></span></strong></p> 
<p style="margin-left:0;"><strong><span style="color:#303133;">   System.out.print(destArray[i] + " ");</span></strong></p> 
<p style="margin-left:0;"><strong><span style="color:#303133;">  }</span></strong></p> 
<p style="margin-left:0;"><strong><span style="color:#303133;"> }</span></strong></p> 
<p style="margin-left:0;"><strong><span style="color:#303133;">}</span></strong></p> 
<p style="margin-left:0;"><strong><span style="color:#303133;">程序的运行结果是（）</span></strong></p> 
<p style="margin-left:0;"></p> 
<p style="margin-left:0;">A、</p> 
<p style="margin-left:0;">21 22 12 13</p> 
<p style="margin-left:0;"></p> 
<p style="margin-left:0;">B、</p> 
<p style="margin-left:0;">21 22 11 12</p> 
<p style="margin-left:0;"></p> 
<p style="margin-left:0;">C、 21 11 12 24</p> 
<p style="margin-left:0;">D、 发生数组角标越界异常</p> 
<p style="margin-left:0;">答案： A<br> 解析：</p> 
<p style="margin-left:0;">上述程序中，arraycopy()方法从指定源数组srcArray角标为1处开始，复制2个长度的数组，复制的数组替换掉目标数组destArray从角标2开始的2个长度的子数组。也就是说，将srcArray中 的12, 13两个元素替换掉了destArray中的23, 24两个元素，最后得到的是{ 21, 22, 12, 13 }这样的数组。</p> 
<p style="margin-left:0;"></p> 
<p style="margin-left:0;"></p> 
<p style="margin-left:0cm;"><strong>11</strong><strong>、下面哪个选项可以获取Runtime类的实例？（） </strong></p> 
<p style="margin-left:0;">A、 Runtime r = new Runtime();</p> 
<p style="margin-left:0;">B、 Runtime r = Runtime.getRuntime();</p> 
<p style="margin-left:0;">C、 Runtime r = Runtime.getInstance();</p> 
<p style="margin-left:0;">D、 以上选项都不能获取Runtime实例</p> 
<p style="margin-left:0;">答案： B</p> 
<p style="margin-left:0cm;"><strong>12</strong><strong>、下列选项中，属于单例设计模式的类是（） </strong></p> 
<p style="margin-left:0;">A、 Math</p> 
<p style="margin-left:0;">B、 Calendar</p> 
<p style="margin-left:0;">C、 Runtime</p> 
<p style="margin-left:0;">D、 System</p> 
<p style="margin-left:0;">答案： C<br> 解析：Runtime类是单例设计模式的类</p> 
<p style="margin-left:0cm;"><strong>13</strong><strong>、下面关于 Math.random()方法生成的随机数，正确的是哪项（） </strong></p> 
<p style="margin-left:0;">A、 0.8652963898062596</p> 
<p style="margin-left:0;">B、 -0.2</p> 
<p style="margin-left:0;">C、 3.0</p> 
<p style="margin-left:0;">D、 1.2</p> 
<p style="margin-left:0;">答案： A<br> 解析：double random()方法返回带正号的 double 值，该值大于等于 0.0 且小于 1.0， 此值是一个伪随机选择的数。</p> 
<p style="margin-left:0cm;"><strong>14</strong><strong>、下列选项中，对Math.random()方法描述正确的是 ( ) </strong></p> 
<p style="margin-left:0;">A、 返回一个不确定的整数</p> 
<p style="margin-left:0;">B、 返回0或是1</p> 
<p style="margin-left:0;">C、 返回一个随机的double类型数，该数大于等于0.0小于1.0</p> 
<p style="margin-left:0;">D、 返回一个随机的int类型数，该数大于等于0.0小于1.0</p> 
<p style="margin-left:0;">答案： C<br> 解析：返回一个随机的double类型数，该数大于等于0.0小于1.0</p> 
<p style="margin-left:0cm;"><strong>15</strong><strong>、若double val = Math.ceil(-11.9);，则val的值是（） </strong></p> 
<p style="margin-left:0;">A、 11.9</p> 
<p style="margin-left:0;">B、 -11.0</p> 
<p style="margin-left:0;">C、 -11.5</p> 
<p style="margin-left:0;">D、 -12.0</p> 
<p style="margin-left:0;">答案： B<br> 解析：ceil是天花板的意思，表示向上取值，永远是得到大于参数的最小整数。</p> 
<p style="margin-left:0cm;"><strong>16</strong><strong>、下面关于java.util.Random类中方法，说法错误的是（ ） </strong></p> 
<p style="margin-left:0;">A、 nextDouble()方法返回的是0.0和1.0之间double类型的值</p> 
<p style="margin-left:0;">B、 nextFloat()方法返回的是0.0和1.0之间float类型的值</p> 
<p style="margin-left:0;">C、 nextInt(int n)返回的是0（包括）和指定值n（不包括）之间的值</p> 
<p style="margin-left:0;">D、 nextInt( )返回的是0（包括）和 2147483647 之间的值</p> 
<p style="margin-left:0;">答案： D<br> 解析：nextInt( ) 生成 2147483647 -2147483648之间的一个数字。</p> 
<p style="margin-left:0cm;"><strong>17</strong><strong>、在Integer类特有的方法中，可以将字符串参数作为有符号的十进制整数进行解析的方法是（） </strong></p> 
<p style="margin-left:0;">A、 Integer valueOf（）</p> 
<p style="margin-left:0;">B、 IntegervalueOf（）</p> 
<p style="margin-left:0;">C、 int parseInt（）</p> 
<p style="margin-left:0;">D、 intValue（）</p> 
<p style="margin-left:0;">答案： D</p> 
<p style="margin-left:0cm;"><strong>18</strong><strong>、String类对正则表达式的方法中可以将字符串拆分的方法是（） </strong></p> 
<p style="margin-left:0;">A、 boolean matches()</p> 
<p style="margin-left:0;">B、 String replaceAll()</p> 
<p style="margin-left:0;">C、 int parseInt（）</p> 
<p style="margin-left:0;">D、 String[] split()</p> 
<p style="margin-left:0;">答案： D</p> 
<p style="margin-left:0cm;"><strong>19</strong><strong>、下面哪些选项可以实现String的初始化？（） </strong></p> 
<p style="margin-left:0;">A、 String str = "abc";</p> 
<p style="margin-left:0;">B、 String str = new String();</p> 
<p style="margin-left:0;">C、 String str = new String(“abc”);</p> 
<p style="margin-left:0;">D、 char[] chs = {‘a’,’b’,’c’};String str = new String(chs);</p> 
<p style="margin-left:0;">答案： ABCD</p> 
<p style="margin-left:0cm;"><strong>20</strong><strong>、下列选项中，可以正确创建一个字符串的是？（） </strong></p> 
<p style="margin-left:0;">A、 String s = "itcast";</p> 
<p style="margin-left:0;">B、 String s = new String("itcast");</p> 
<p style="margin-left:0;">C、 String s = new String(new char[] {'i','t','c','a','s','t'});</p> 
<p style="margin-left:0;">D、 String s = new String(new int[]{1,2,3});</p> 
<p style="margin-left:0;">答案： ABC</p> 
<p style="margin-left:0cm;"><strong>21</strong><strong>、下面哪些方法是字符串中的判断方法？（） </strong></p> 
<p style="margin-left:0;">A、 boolean contains(CharSequence cs);</p> 
<p style="margin-left:0;">B、 String toLowerCase();</p> 
<p style="margin-left:0;">C、 boolean equals(Object anObject);</p> 
<p style="margin-left:0;">D、 boolean isEmpty();</p> 
<p style="margin-left:0;">答案： ACD<br> 解析：B答案使用默认语言环境的规则将String中的所有字符都转换为小写</p> 
<p style="margin-left:0cm;"><strong>22</strong><strong>、下列选项中，属于StringBuffer类特点的是（） </strong></p> 
<p style="margin-left:0;">A、 字符串缓冲区，提高字符串的操作效率</p> 
<p style="margin-left:0;">B、 StringBuffer类是线程安全的</p> 
<p style="margin-left:0;">C、 StringBuffer类的toString()方法，将缓冲区变成字符串</p> 
<p style="margin-left:0;">D、 StringBuffer是不可变的对象</p> 
<p style="margin-left:0;">答案： ABC</p> 
<p style="margin-left:0cm;"><strong>23</strong><strong>、下列关于Runtime的描述中，正确的是（） </strong></p> 
<p style="margin-left:0;">A、 每一个Java应用程序运行时都产生一个Runtime类实例</p> 
<p style="margin-left:0;">B、 Runtime实例可以将应用程序和运行环境相结合</p> 
<p style="margin-left:0;">C、 Runtime类没有构造函数</p> 
<p style="margin-left:0;">D、 Runtime实例不需要创建，直接通过getRuntime()方法获取</p> 
<p style="margin-left:0;">答案： ABCD<br> 解析：Runtime类用于表示虚拟机运行时的状态，它用于封装JVM虚拟机进程。每次使用java命令启动虚拟机都对应一个Runtime实例，并且只有一个实例，因此该类采用单例模式进行设计，可以通过getRuntime()方法获得一个Runtime实例。</p> 
<p style="margin-left:0cm;"><strong>24</strong><strong>、下面选项中，对Math类描述正确的是（） </strong></p> 
<p style="margin-left:0;">A、 Math类中所有的方法都是静态的,所以类名.调用即可</p> 
<p style="margin-left:0;">B、 Math类的构造函数是私有的,所以其他类不能用Math类创建对象</p> 
<p style="margin-left:0;">C、 Math类在java.math包中</p> 
<p style="margin-left:0;">D、 Math类可以创建对象</p> 
<p style="margin-left:0;">答案： AB<br> 解析：Math类在java.lang包中； Math类不可以创建对象,因为构造方法被私有了</p> 
<p style="margin-left:0cm;"><strong>25</strong><strong>、Java提供了一套专门用于处理日期时间的API，下列选项中属于处理时间API的是（） </strong></p> 
<p style="margin-left:0;">A、 LocalDate类</p> 
<p style="margin-left:0;">B、 LocalTime类</p> 
<p style="margin-left:0;">C、 Instant类</p> 
<p style="margin-left:0;">D、 Duration类</p> 
<p style="margin-left:0;">答案： ABCD</p> 
<p style="margin-left:0cm;"><strong>26</strong><strong>、使用字符串常量可以直接初始化一个String对象。 </strong></p> 
<p style="margin-left:0;">答案： 错误</p> 
<p style="margin-left:0cm;"><strong>27</strong><strong>、使用String类的toCharArray()方法可以将一个字符串转为一个字符数组。 </strong></p> 
<p style="margin-left:0;">答案： 正确<br> 解析：使用String类的toCharArray()方法可以将一个字符串转为一个字符数组。</p> 
<p style="margin-left:0cm;"><strong>28</strong><strong>、String类的equals()方法和“= =”的作用是一样的。 </strong></p> 
<p style="margin-left:0;">答案： 错误<br> 解析：String类的equals()方法比较的是两个字符串、“==”比较的是两个对象的地址值。</p> 
<p style="margin-left:0cm;"><strong>29</strong><strong>、StringBuffer类和String类一样，都是不可变对象。 </strong></p> 
<p style="margin-left:0;">答案： 错误<br> 解析：字符串是常量，因此一旦创建，其内容和长度是不可改变的，StringBuffer类长度是可以改变的。StringBuffer类似一个字符容器，当在其中添加或删除字符时，并不会产生新的StringBuffer对象。</p> 
<p style="margin-left:0cm;"><strong>30</strong><strong>、StringBuffer类似一个字符容器，当在其中添加或删除字符时，并不会产生新的StringBuffer对象。 </strong></p> 
<p style="margin-left:0;">答案： 正确</p> 
<p style="margin-left:0cm;"><strong>31</strong><strong>、System.getProperties()方法可以获取操作系统的属性。 </strong></p> 
<p style="margin-left:0;">答案： 正确<br> 解析：System类的getProperties()方法用于获取系统属性。</p> 
<p style="margin-left:0cm;"><strong>32</strong><strong>、System类中提供的属性和方法都是静态的。 </strong></p> 
<p style="margin-left:0;">答案： 正确</p> 
<p style="margin-left:0cm;"><strong>33</strong><strong>、Runtime类是用单例设计模式设计的,不能直接创建对象,可以通过Rutime类中的一个静态方法getRuntime()方法获取实例。 </strong></p> 
<p style="margin-left:0;">答案： 正确</p> 
<p style="margin-left:0cm;"><strong>34</strong><strong>、Runtime类用于表示虚拟机运行时的状态，它用于封装JVM虚拟机进程。 </strong></p> 
<p style="margin-left:0;">答案： 错误</p> 
<p style="margin-left:0cm;"><strong>35</strong><strong>、Math.round(double d)方法的作用是将一个数四舍五入,并返回一个double数。 </strong></p> 
<p style="margin-left:0;">答案： 错误<br> 解析：Math.round(double d)方法，返回的是一个long类型的整数。</p> 
<p style="margin-left:0cm;"><strong>36</strong><strong>、ceil()、floor()和round()方法返回的都是double类型的数。 </strong></p> 
<p style="margin-left:0;">答案： 错误<br> 解析：ceil()方法和floor()方法返回的都是double类型的值，而round()方法返回一个int值。</p> 
<p style="margin-left:0cm;"><strong>37</strong><strong>、java.util.Random的nextInt( )方法会生成一个正整数类型的伪随机数。 </strong></p> 
<p style="margin-left:0;">答案： 错误<br> 解析：java.util.Random 的 nextInt( ) 生成 2147483647 -2147483648之间的一个数字，也可能是负数。</p> 
<p style="margin-left:0cm;"><strong>38</strong><strong>、针对字符串的操作，Java提供了两个字符串类，分别是String和【】 </strong></p> 
<p style="margin-left:0;">答案： 字符串常量；</p> 
<p style="margin-left:0cm;"><strong>39</strong><strong>、在程序中，获取字符串长度的方法是【】。 </strong></p> 
<p style="margin-left:0;">答案： length()；</p> 
<p style="margin-left:0cm;"><strong>40</strong><strong>、StringBuffer类的默认容量是【】个字符。 </strong></p> 
<p style="margin-left:0;">答案： 16；</p> 
<p style="margin-left:0cm;"><strong>41</strong><strong>、当对字符串进行修改时，【】类和【】类的对象都可以被多次修改，并不产生新的未使用对象。 </strong></p> 
<p style="margin-left:0;">答案： StringBuffer；StringBuilder；</p> 
<p style="margin-left:0cm;"><strong>42</strong><strong>、System类的【】静态方法可以启动垃圾回收器。 </strong></p> 
<p style="margin-left:0;">答案： gc()；</p> 
<p style="margin-left:0cm;"><strong>43</strong><strong>、要编写一个程序打开记事本，在下列程序中填写适当的代码，Runtime r = Runtime.getRuntime();r.exec("【】"); </strong></p> 
<p style="margin-left:0;">答案： Notepad.exe；</p> 
<p style="margin-left:0cm;"><strong>44</strong><strong>、Math类中，用于获取一个数的绝对值的方法是【】 </strong></p> 
<p style="margin-left:0;">答案： Math.abs();；</p> 
<p style="margin-left:0cm;"><strong>45</strong><strong>、java.util包中的【】可以在指定的取值范围内随机产生数字。 </strong></p> 
<p style="margin-left:0;">答案： Random类；</p> 
<p style="margin-left:0;"><strong>46、<br> 下面哪个选项可以获取Runtime类的实例（）</strong></p> 
<p style="margin-left:0;">A、 Runtime r = new Runtime();</p> 
<p style="margin-left:0;">B、 Runtime r = Runtime.getRuntime();</p> 
<p style="margin-left:0;">C、 Runtime r = Runtime.getInstance();</p> 
<p style="margin-left:0;">D、 以上选项都不能获取Runtime实例</p> 
<p style="margin-left:0;">答案： B<br> 解析：Runtime类是单例设计模式类,获取实例的方法是getRuntime方法。</p> 
<p style="margin-left:0;"><strong>47、<br> 下列选项中，可以正确创建一个字符串的是（    ）</strong></p> 
<p style="margin-left:0;">A、 String s = "itcast";</p> 
<p style="margin-left:0;">B、 String s = new String("itcast");</p> 
<p style="margin-left:0;">C、 String s = new String(new char[] {'i','t','c','a','s','t'});</p> 
<p style="margin-left:0;">D、 String s = new String(new int[]{1,2,3});</p> 
<p style="margin-left:0;">答案： ABC<br> 解析：使用int类型数组创建字符串，需要初始偏移量和长度两个参数。</p> 
<p style="margin-left:0;"><strong>48、<br> 下列选项中，可以正确实现String初始化的是（）</strong></p> 
<p style="margin-left:0;">A、 String str = "abc";</p> 
<p style="margin-left:0;">B、</p> 
<ul><li><li>String str = 'abc';</li><li>C、</li><li></ul> 
<p style="margin-left:0;"></p> 
<p style="margin-left:0;">C、</p> 
<ul><li><li>String str = abc;</li><li>D、</li><li></ul> 
<p style="margin-left:0;"></p> 
<p style="margin-left:0;">D、 String str = 0;</p> 
<p style="margin-left:0;">答案： A<br> 解析：B答案错误，因为字符串必须使用双引号，C答案的abc不符合字符命名格式，D答案的0是整数的默认值。</p> 
<p style="margin-left:0;"><strong>49、下列是Random类的一些常用方法，其中能获得指定范围随机数的方法是（    ）</strong></p> 
<p style="margin-left:0;">A、 nextInt()</p> 
<p style="margin-left:0;">B、 nextLong()</p> 
<p style="margin-left:0;">C、 nextBoolean()</p> 
<p style="margin-left:0;">D、 nextInt(intn)</p> 
<p style="margin-left:0;">答案： D<br> 解析：nextInt(int n)方法能够随机生成0~n之间int类型的随机数。</p> 
<p style="margin-left:0;"><strong>50、<br> 下面选项中，属于java.util.Random类中的方法的是（  ）</strong></p> 
<p style="margin-left:0;">A、 next(intbits)</p> 
<p style="margin-left:0;">B、 nextInt()</p> 
<p style="margin-left:0;">C、 nextLong()</p> 
<p style="margin-left:0;">D、</p> 
<ul><li>random()</li><li></ul> 
<p style="margin-left:0;"></p> 
<p style="margin-left:0;">答案： ABC<br> 解析：random() 方法是 java.lang.Math类中的方法。</p> 
<p style="margin-left:0;"><strong>51、<br> JAVA中 int类型对应的包装类是【】（填英文表示）。</strong></p> 
<p style="margin-left:0;">答案：</p> 
<p style="margin-left:0;">Integer</p> 
<p style="margin-left:0;">；</p> 
<p style="margin-left:0;"><strong>52、<br> 下面关于java.util.Random类中方法，说明错误的是（ ）</strong></p> 
<p style="margin-left:0;">A、 nextDouble()方法返回的是0.0和1.0之间double类型的值</p> 
<p style="margin-left:0;">B、 nextFloat()方法返回的是0.0和1.0之间float类型的值</p> 
<p style="margin-left:0;">C、 nextInt(intn)返回的是0（包括）和指定值n（不包括）之间的值</p> 
<p style="margin-left:0;">D、 nextInt()返回的是0（包括）和2147483647之间的值</p> 
<p style="margin-left:0;">答案： D<br> 解析：nextInt( ) 生成 2147483647 -2147483648之间的一个数字。</p> 
<p style="margin-left:0;"><strong>53、<br> JAVA中拆箱是指将引用数据类型的对象转为基本数据类型。</strong></p> 
<p style="margin-left:0;">答案： 正确<br> 解析：拆箱是指将引用数据类型的对象转为基本数据类型。</p> 
<p style="margin-left:0;"><strong>54、<br> Random类的实例用于生成随机数。</strong></p> 
<p style="margin-left:0;">答案： 正确<br> 解析：Random类的实例用于生成随机数。</p> 
<p style="margin-left:0;"><strong>55、<br> 阅读下面一段代码，代码的输出结果是（）<br> Integer in1 = new Integer(10);<br>   Integer in2 = new Integer(10);<br><br>   Integer in3 = 10;<br>   Integer in4 = 10;<br><br>   System.out.println(in1 == in2); <br>   System.out.println(in1 == in3); <br>   System.out.println(in3 == in4);</strong></p> 
<p style="margin-left:0;">A、 true true true</p> 
<p style="margin-left:0;">B、 false false true</p> 
<p style="margin-left:0;">C、 false false false</p> 
<p style="margin-left:0;">D、 false true false</p> 
<p style="margin-left:0;">答案： B<br> 解析：in1和in2是new出来的，所以地址不一样，但是in3和in4的值是同一个常量10，所以相等。</p> 
<p style="margin-left:0;"><strong>56、<br> 包装类可以将基本数据类型的值包装为引用数据类型的对象。</strong></p> 
<p style="margin-left:0;">答案： 正确<br> 解析：包装类可以将基本数据类型的值包装为引用数据类型的对象。</p> 
<p style="margin-left:0;"><strong>57、<br> ceil()、floor()和round()方法返回的都是double类型的数。</strong></p> 
<p style="margin-left:0;">答案： 错误<br> 解析：ceil()方法和floor()方法返回的都是double类型的值，而round()方法返回一个int值。</p> 
<p style="margin-left:0;"><strong>58、<br> 下列是Math类中的一些常用方法，其中用于获取大于等于0.0且小于1.0的随机数的方法是（    ）</strong></p> 
<p style="margin-left:0;">A、 random()</p> 
<p style="margin-left:0;">B、 abs()</p> 
<p style="margin-left:0;">C、 sin()</p> 
<p style="margin-left:0;">D、 pow()</p> 
<p style="margin-left:0;">答案： A<br> 解析：abs()获取绝对值，sin()获取正弦值，pow()获取次幂值，选项A才是获得随机数的方法。</p> 
<p style="margin-left:0;"><strong>59、<br> 下列选项中，关于包装类描述错误的是（）</strong></p> 
<p style="margin-left:0;">A、 包装类的作用之一就是将基本类型包装成引用类型</p> 
<p style="margin-left:0;">B、 包装类它可以完成在基本类型与String类型之间的转换</p> 
<p style="margin-left:0;">C、 包装类一共有八个，对应的基本数据类型</p> 
<p style="margin-left:0;">D、 我们可以继承包装类，以完成自定义包装</p> 
<p style="margin-left:0;">答案： D<br> 解析：包装类都是final修饰的，不能被继承。</p> 
<p style="margin-left:0;"><strong>60、<br> 若double val = Math.ceil(-11.9);，则val的值是（    ）</strong></p> 
<p style="margin-left:0;">A、 11.9</p> 
<p style="margin-left:0;">B、 -11.0</p> 
<p style="margin-left:0;">C、 -11.5</p> 
<p style="margin-left:0;">D、 -12.0</p> 
<p style="margin-left:0;">答案： B<br> 解析：ceil是天花板的意思，表示向上取值，永远是得到大于参数的最小整数。</p> 
<p style="margin-left:0;"><strong>61、<br> java.util.Random的nextInt( )方法会生成一个正整数类型的伪随机数。</strong></p> 
<p style="margin-left:0;">答案： 错误<br> 解析：java.util.Random 的 nextInt( ) 生成 2147483647 -2147483648之间的一个数字，也可能是负数。</p> 
<p style="margin-left:0;"><strong>62、<br> java.util包中的Random类的作用是可以在指定的取值范围内【】。</strong></p> 
<p style="margin-left:0;">答案：</p> 
<p style="margin-left:0;">随机产生数字</p> 
<p style="margin-left:0;">；<br> 解析：在JDK的java.util包中有一个Random类，它可以在指定的取值范围内随机产生数字。</p> 
<p style="margin-left:0;"><strong>63、<br> 下面选项中，对Math类描述正确的是（）</strong></p> 
<p style="margin-left:0;">A、 Math类中所有的方法都是静态的,所以类名.调用即可</p> 
<p style="margin-left:0;">B、 Math类的构造函数是私有的,所以其他类不能用Math类创建对象</p> 
<p style="margin-left:0;">C、 Math类在java.math包中</p> 
<p style="margin-left:0;">D、 Math类可以创建对象</p> 
<p style="margin-left:0;">答案： AB</p> 
<p style="margin-left:0;"><strong>64、阅读下面的代码，输出结果是（）<br> public static void main(String[] args) {<!-- --><br>   Random random1 = new Random(10); <br>   Random random2 = new Random(10); <br>   for(int i=0;i&lt;5;i++){<!-- --><br>    System.out.print(random1.nextInt(5));<br>   }<br>   System.out.println();<br>   for(int i=0;i&lt;5;i++){<!-- --><br>    System.out.print(random2.nextInt(5));<br>   }<br> }</strong></p> 
<p style="margin-left:0;">A、 3030130301</p> 
<p style="margin-left:0;">B、 5048132680</p> 
<p style="margin-left:0;">C、 3268023579</p> 
<p style="margin-left:0;">D、 1111111111</p> 
<p style="margin-left:0;">答案： A<br> 解析：当创建Random类的实例对象时，如果指定了相同的种子，则每个实例对象产生的随机数具有相同的序列，调用nextInt(int in)方法时产生的随机数在(0 =&lt; 参数值)之间。</p> 
<p style="margin-left:0;"><strong>65、<br> 下列数据类型中，哪些类型的数据是Random对象能够随机生成的（    ）</strong></p> 
<p style="margin-left:0;">A、 int</p> 
<p style="margin-left:0;">B、 string</p> 
<p style="margin-left:0;">C、 double</p> 
<p style="margin-left:0;">D、 float</p> 
<p style="margin-left:0;">答案： ACD<br> 解析：Random实例对象，能够生成：boolean、double、float、int、long类型的随机数。</p> 
<p style="margin-left:0;"><strong>66、<br> 下列选项中，哪些是java 中的包装类（）</strong></p> 
<p style="margin-left:0;">A、 java.lang.Double</p> 
<p style="margin-left:0;">B、 java.lang.Char</p> 
<p style="margin-left:0;">C、 java.lang.Int</p> 
<p style="margin-left:0;">D、 java.lang.Byte</p> 
<p style="margin-left:0;">答案： AD<br> 解析：char类型包装类是Character，int类型包装类是Integer。</p> 
<p style="margin-left:0;"><strong>67、<br> 通过java中的包装类完成以下功能：<br> 1. 创建一个基本数据类型int i=10,将其转换成对应的包装类Integer in<br> 2. 通过创建的int类型包装类对象in来描述自动拆装箱<br> 2.1 将in拆箱，赋值给int a<br> 2.2 对in重新赋值，值为20</strong></p> 
<p style="margin-left:0;">答案：</p> 
<p style="margin-left:0;">public class Demo {<!-- --><br>  public static void main(String[] args) {<!-- --><br>   int i=10;<br>   Integer in=new Integer(i);  <br>   int a=in;<br>   in=20;<br>  }<br> }</p> 
<p style="margin-left:0;"><br> 解析：int a=in;表示将包装类对象转换成基本数据类型是拆箱过程；in=20;表示将基本数值转换成包装类对象，是装箱过程。</p> 
<p style="margin-left:0;"><strong>68、编写程序一个StringDemo类，在main方法中定义两个String字符串，使用String类equals方法，判断两个字符串是否相同，输出结果。</strong></p> 
<p style="margin-left:0;">答案：</p> 
<p style="margin-left:0;">class StringDemo{<!-- --><br>    public static void main(String[] args){<!-- --><br>         String s1 = “abc”;<br>         String s2 = “abc”;<br>         boolean b = s1.equals(s2);<br>         System.out.println(b);<br> }<br> }<br> 输出结果为：true</p> 
<p style="margin-left:0;"><br> 解析：使用String类equals方法比较两个字符串的值是否相等。</p> 
<p style="margin-left:0;"><strong>69、简要概述StringBuffer类的append方法的作用和特点。</strong></p> 
<p style="margin-left:0;">答案：</p> 
<p style="margin-left:0;">append()方法始终将数据添加到缓冲区的末尾","并返回本类的对象StringBuffer","无论append追加的数据是什么类型","最终都会变成字符串。</p> 
<p style="margin-left:0;"><br> 解析：append()方法始终将数据添加到缓冲区的末尾，并返回本类的对象StringBuffer，无论append追加的数据是什么类型，最终都会变成字符串。</p> 
<p style="margin-left:0;"><strong>70、<br> System类的【】静态方法可以启动垃圾回收器。</strong></p> 
<p style="margin-left:0;">答案：</p> 
<p style="margin-left:0;">gc()</p> 
<p style="margin-left:0;">；<br> 解析：System类的gc()方法可以启动垃圾回收器。</p> 
<p style="margin-left:0;"><strong>71、<br> 阅读下列代码<br> public class Example {<!-- --><br>  public static void main(String[] args) {<!-- --><br>   int[] srcArray = { 11, 12, 13, 14 };<br>   int[] destArray = { 21, 22, 23, 24 };<br>   System.arraycopy(srcArray, 1, destArray, 2, 2);<br>   for (int i = 0; i &lt; destArray.length; i++) {<!-- --><br>    System.out.print(destArray[i] + " ");<br>   }<br>  }<br> }<br> 下列选项中，程序的运行结果是（    ）</strong></p> 
<p style="margin-left:0;">A、 21 22 12 13</p> 
<p style="margin-left:0;">B、 21 22 11 12</p> 
<p style="margin-left:0;">C、 21 11 12 24</p> 
<p style="margin-left:0;">D、 发生数组角标越界异常</p> 
<p style="margin-left:0;">答案： A<br> 解析：上述程序中，arraycopy()方法从指定源数组srcArray角标为1处开始，复制2个长度的数组，复制的数组替换掉目标数组destArray从角标2开始的2个长度的子数组。也就是说，将srcArray中 的12, 13两个元素替换掉了destArray中的23, 24两个元素，最后得到的是{ 21, 22, 12, 13 }这样的数组。</p> 
<p style="margin-left:0;"><strong>72、<br> StringBuffer类的append()方法的返回值类型是（）</strong></p> 
<p style="margin-left:0;">A、 String</p> 
<p style="margin-left:0;">B、 void</p> 
<p style="margin-left:0;">C、 StringBuffer</p> 
<p style="margin-left:0;">D、 StringBuilder</p> 
<p style="margin-left:0;">答案： C<br> 解析：StringBuffer类似一个字符容器，当在其中添加或删除字符时，并不会产生新的StringBuffer对象返回值类型还是StringBuffer类型。</p> 
<p style="margin-left:0;"><strong>73、<br> 假如indexOf()方法未能找到所指定的子字符串，那么其返回值为（    ）</strong></p> 
<p style="margin-left:0;">A、 false</p> 
<p style="margin-left:0;">B、 0</p> 
<p style="margin-left:0;">C、 -1</p> 
<p style="margin-left:0;">D、 以上答案都不对</p> 
<p style="margin-left:0;">答案： C<br> 解析：indexOf()方法找不到指定的子字符串时，返回值为-1。</p> 
<p style="margin-left:0;"><strong>74、<br> 编写一个mathDemo类，定义变量double d1 = 15.6432241;和double d2 = 7.543453459;，使用java.lang.Math中的方法， 比较两个变量中较大的数，并将较大数的值舍入为整数。</strong></p> 
<p style="margin-left:0;">答案：</p> 
<p style="margin-left:0;">package cn.itcast;<br> class mathDemo {<!-- --><br>  public static void main(String[] args) {<!-- --><br>   double d1 = 15.6432241;<br>   double d2 = 7.543453459;<br>   double max = Math.max(d1"," d2);<br>   System.out.println(Math.round(max));<br>  }<br> }<br> 运行结果：16</p> 
<p style="margin-left:0;"><br> 解析：使用Math.max()方法比较d1，和d2的值，d1&gt;d2，然后调用Math.round()方法将d1的值四舍五入，所以结果为16。</p> 
<p style="margin-left:0;"><strong>75、<br> Math类中，用于获取一个数的绝对值的方法是【】。</strong></p> 
<p style="margin-left:0;">答案：</p> 
<p style="margin-left:0;">Math.abs();</p> 
<p style="margin-left:0;">；<br> 解析：Math.abs()方法用于获取一个数的绝对值。</p> 
<p style="margin-left:0;"><strong>76、<br> 下列选项中，属于StringBuffer类特点的是（）</strong></p> 
<p style="margin-left:0;">A、 字符串缓冲区，提高字符串的操作效率</p> 
<p style="margin-left:0;">B、 StringBuffer类是线程安全的</p> 
<p style="margin-left:0;">C、 StringBuffer类的toString()方法，将缓冲区变成字符串</p> 
<p style="margin-left:0;">D、 StringBuffer是不可变的对象</p> 
<p style="margin-left:0;">答案： ABC<br> 解析：StringBuffer类的特点。</p> 
<p style="margin-left:0;"><strong>77、<br> System类的getProperties()方法的作用是（）</strong></p> 
<p style="margin-left:0;">A、 获取当前的操作系统的属性</p> 
<p style="margin-left:0;">B、 获取当前JVM的属性</p> 
<p style="margin-left:0;">C、 获取指定键指示的操作系统属性</p> 
<p style="margin-left:0;">D、 获取指定键指示的JVM的属性</p> 
<p style="margin-left:0;">答案： A<br> 解析：System类的getProperties()方法的作用是确定当前系统的属性。</p> 
<p style="margin-left:0;"><strong>78、<br> Runtime r = Runtime.getRuntime();r.exec("【】");在横线处填写一个命令,使运行程序的时候会打开一个记事本。</strong></p> 
<p style="margin-left:0;">答案：</p> 
<p style="margin-left:0;">Notepad.exe</p> 
<p style="margin-left:0;">；<br> 解析：在exec()方法中传入一个dos命令,程序就会执行这个dos命令。</p> 
<p style="margin-left:0;"><strong>79、</strong></p> 
<p style="margin-left:0;"><strong>Math.round(double d)方法的作用是，将一个数四舍五入,并返回一个double数。</strong></p> 
<ul><li><strong>对</strong></li><li><strong>错</strong></li><li></ul> 
<p style="margin-left:0;"></p> 
<p style="margin-left:0;">答案： 错误<br> 解析：Math.round(double d)方法，返回的是一个long类型的整数。</p> 
<p style="margin-left:0;"><strong>80、建立一个Test类，通过使用System类中的一个方法，实现将int[] arr1 = {11,22,33,44,55}中的所有元素拷贝到目标数组int[] arr2 = new int[8]中。</strong></p> 
<p style="margin-left:0;">答案：</p> 
<p style="margin-left:0;">class Test {<!-- --><br>  public static void main(String[] args) {<!-- --><br>   int[] arr1 = {11","22","33","44","55};<br>   int[] arr2 = new int[8];<br>   System.arraycopy(arr1","0","arr2","0","arr1.length);<br>   for (int i = 0;i &lt; arr2.length ;i++ ) {<!-- --><br>    System.out.print(arr2[i] + " ");<br>   }<br>  }<br> }<br> 运行结果：11 22 33 44 55 0 0 0</p> 
<p style="margin-left:0;"><br> 解析：System类的arraycopy(Object src,int srcPos, Object dest, int destPos,int length) 方法是从指定源数组中复制一个数组，所以我们使用arraycopy()方法来完成这个题，我们看到数组arr1的所有元素都拷贝到了数组arr2中，arr2的长度是8，但arr1的长度是5，所以当我们遍历说组arr2时，最后三位没有值的位置用0补充。注意arraycopy()方法的copy首字母小写。</p> 
<p style="margin-left:0;"><strong>81、<br> 已知 String 对象 s="abcdefg"，则 s.substring(2, 5)的返回值为（    ）</strong></p> 
<p style="margin-left:0;">A、 "bcde"</p> 
<p style="margin-left:0;">B、 "cde"</p> 
<p style="margin-left:0;">C、 "cdef"</p> 
<p style="margin-left:0;">D、 "def"</p> 
<p style="margin-left:0;">答案： B<br> 解析：字符串索引从0开始，substring()方法截取的字符串是包左不包右的。</p> 
<p style="margin-left:0;"><strong>82、<br> 在Java中可以通过哪些方式对String进行初始化？</strong></p> 
<p style="margin-left:0;">答案：</p> 
<p style="margin-left:0;">在操作String类之前","首先需要对String类进行初始化","在Java中可以通过以下两种方式对String类进行初始化：  <br> 1、使用字符串常量直接初始化一个String对象。<br> 2、使用String的构造方法初始化字符串对象。</p> 
<p style="margin-left:0;"><br> 解析：在Java中可以通过以下两种方式对String类进行初始化：  <br> 1、使用字符串常量直接初始化一个String对象。<br> 2、使用String的构造方法初始化字符串对象。</p> 
<p style="margin-left:0;"><strong>83、<br> StringBuffer类的默认容量是【】个字符。</strong></p> 
<p style="margin-left:0;">答案：</p> 
<p style="margin-left:0;">16</p> 
<p style="margin-left:0;">；<br> 解析：默认16个字符。</p> 
<p style="margin-left:0;"><strong>84、</strong></p> 
<p style="margin-left:0;"><strong>Runtime类用于表示虚拟机运行时的状态，它用于封装JVM虚拟机进程。</strong></p> 
<p style="margin-left:0;"></p> 
<p style="margin-left:0;">答案： 正确<br> 解析：Runtime类用于表示虚拟机运行时的状态，它用于封装JVM虚拟机进程。<br> 每个java应用程序都有一个Runtime实例 ，当java应用程序运行时，都会封装成一个单独的运行时对象。</p> 
<p style="margin-left:0;"><strong>85、</strong></p> 
<p style="margin-left:0;"><strong>StringBuffer类似一个字符容器，当在其中添加或删除字符时，并不会产生新的StringBuffer对象。</strong></p> 
<ul><li><strong>对</strong></li><li><strong>错</strong></li><li></ul> 
<p style="margin-left:0;"></p> 
<p style="margin-left:0;">答案： 正确<br> 解析：StringBuffer类似一个字符容器，当在其中添加或删除字符时，并不会产生新的StringBuffer对象。</p> 
<p style="margin-left:0;"><strong>86、<br> 下列选项中，对Math.random()方法描述正确的是(     )</strong></p> 
<p style="margin-left:0;">A、 返回一个不确定的整数</p> 
<p style="margin-left:0;">B、 返回0或是1</p> 
<p style="margin-left:0;">C、 返回一个随机的double类型数，该数大于等于0.0小于1.0</p> 
<p style="margin-left:0;">D、 返回一个随机的int类型数，该数大于等于0.0小于1.0</p> 
<p style="margin-left:0;">答案： C<br> 解析：返回一个随机的double类型数，该数大于等于0.0小于1.0。</p> 
<p style="margin-left:0;"><strong>87、<br> String类的equals()方法和“= =”的作用是一样的。</strong></p> 
<p style="margin-left:0;">答案： 错误<br> 解析：String类的equals()方法比较的是两个字符串、“==”比较的是两个对象的地址值。</p> 
<p style="margin-left:0;"><strong>88、<br> 下列关于StringBuffer类的描述中，正确的是（    ）</strong></p> 
<p style="margin-left:0;">A、 append()方法可以接受任意类型的数据</p> 
<p style="margin-left:0;">B、 insert()方法可以接受任意类型的数据</p> 
<p style="margin-left:0;">C、 append()方法返回的是一个新的StringBuffer对象</p> 
<p style="margin-left:0;">D、 insert()方法返回的是一个新的StringBuffer对象</p> 
<p style="margin-left:0;">答案： AB<br> 解析：StringBuffer的apped()方法和insert()方法返回的都是原来的StringBuffer对象，并且他们都可以接受任意类型的数据。</p> 
<p style="margin-left:0;"><strong>89、<br> 下列选项中，属于单例设计模式的类是（    ）</strong></p> 
<p style="margin-left:0;">A、 Math</p> 
<p style="margin-left:0;">B、 Calendar</p> 
<p style="margin-left:0;">C、 Runtime</p> 
<p style="margin-left:0;">D、 System</p> 
<p style="margin-left:0;">答案： C<br> 解析：Runtime类是单例设计模式的类。</p> 
<p style="margin-left:0;"><strong>90、<br> 编写一个StringBufferDemo类，在主方法中，创建两个int值，和一个double值，建立一个StringBuffer对象，将上面三个值追加到缓冲区，并将缓冲区变成字符串，输出结果。</strong></p> 
<p style="margin-left:0;">答案：</p> 
<p style="margin-left:0;">class StringBufferDemo{<!-- --><br>    public static void main(String[] args){<!-- --><br>       int a = 2 ;<br>       int b = 3;<br>       double d = 4.5;<br>       StringBuffer buffer = new StringBuffer();<br>       buffer.append(a).append(b).append(d);<br>       StringBuffer buffer = new StringBuffer();<br>      StringBuffer s = buffer.append(a).append(b).append(d);<br>      System.out.println(s);<br> }<br> }<br> 输出结果：234.5</p> 
<p style="margin-left:0;"><br> 解析：从运行结果可以看出，append()方法将数据添加到缓冲区的末尾，并返回本类的对象StringBuffer，无论append追加的数据是什么类型，最终都会变成字符串。</p> 
<p style="margin-left:0;"><strong>91、<br> 下面哪个方法可以实现获取字符在某个字符串中第一次出现的索引（）</strong></p> 
<p style="margin-left:0;">A、 charcharAt(intindex)</p> 
<p style="margin-left:0;">B、 intindexOf(intch)</p> 
<p style="margin-left:0;">C、 intlastIndexOf(intch)</p> 
<p style="margin-left:0;">D、 booleanendsWith(Stringsuffix)</p> 
<p style="margin-left:0;">答案： B<br> 解析：A答案返回字符串中index位置上的字符<br> C答案返回指定字符在此字符串中最后一次出现处的索引<br> D答案判断此字符串是否以指定的字符串结尾</p> 
<p style="margin-left:0;"><strong>92、<br> 请编写一个StringDemo类，在主方法中实例化String类，初始化值为”itcast”，输出String初始化值。</strong></p> 
<p style="margin-left:0;">答案：</p> 
<p style="margin-left:0;">class StringDemo {<!-- --><br> public static void main(String[] args) {<!-- --><br>  String str = "itcast";<br>  System.out.println(str);<br> }<br> }</p> 
<p style="margin-left:0;"><br> 解析：对字符串类进行初始化的操作有很多种，任选一种即可。最后用输出语句输出结果即可。</p> 
<p style="margin-left:0;"><strong>93、<br> 下列关于String类和StringBuffer类的说法中，正确的是（    ）</strong></p> 
<p style="margin-left:0;">A、 String类表示的字符串是常量，一旦创建后，内容和长度都是无法改变的。而StringBuffer表示字符容器，其内容和长度都可以随时修改</p> 
<p style="margin-left:0;">B、 String类覆盖了Object类的equals()方法，而StringBuffer类没有覆盖Object类的equals()方法</p> 
<p style="margin-left:0;">C、 String类对象可以用操作符“+”进行连接，而StringBuffer类对象之间不能</p> 
<p style="margin-left:0;">D、 String类覆盖了Object类的toString()方法，而StringBuffer类没有覆盖Object类的toString()方法</p> 
<p style="margin-left:0;">答案： ABC<br> 解析：String和StringBuffer本身就是一个字符串都不需要覆盖toString()方法。</p> 
<p style="margin-left:0;"><strong>94、<br> System类中提供的属性和方法都是静态的。</strong></p> 
<p style="margin-left:0;">答案： 正确<br> 解析：System类中提供的属性和方法都是静态的。</p> 
<p style="margin-left:0;"><strong>95、<br> 使用字符串常量可以直接初始化一个String对象。</strong></p> 
<p style="margin-left:0;">答案： 正确<br> 解析：使用字符串常量直接初始化一个String对象，具体代码如下：<br> String str1 = "abc";</p> 
<p style="margin-left:0;"><strong>96、Runtime类是用单例设计模式设计的,不能直接创建对象,可以通过Rutime类中的一个静态方法getRuntime()方法获取实例。</strong></p> 
<p style="margin-left:0;">答案： 正确<br> 解析：Runtime类是用单例设计模式设计的。</p> 
<p style="margin-left:0;"><strong>97、<br> 字符串一旦初始化就不可以被改变。</strong></p> 
<p style="margin-left:0;">答案： 正确<br> 解析：字符串一旦初始化就不可以被改变。</p> 
<p style="margin-left:0;"><strong>98、<br> 下列关于System类的描述中，错误的是（    ）</strong></p> 
<p style="margin-left:0;">A、 System类是final关键字修饰的类，它不能被其他类所继承</p> 
<p style="margin-left:0;">B、 System类不能被实例化</p> 
<p style="margin-left:0;">C、 System类中定义了许多方法，但是没有定义字段</p> 
<p style="margin-left:0;">D、 System类中提供了获取当前系统属性的方法</p> 
<p style="margin-left:0;">答案： C<br> 解析：System类中定义了三个字段，err、out和in，分别表示“标准”错误输出流、“标准”输入流和“标准”输出流。</p> 
<p style="margin-left:0;"><strong>99、<br> 下面关于 Math.random()方法生成的随机数，正确的是哪项（  ）</strong></p> 
<p style="margin-left:0;">A、 0.8652963898062596</p> 
<p style="margin-left:0;">B、 -0.2</p> 
<p style="margin-left:0;">C、 3.0</p> 
<p style="margin-left:0;">D、 1.2</p> 
<p style="margin-left:0;">答案： A<br> 解析：double random()方法返回带正号的 double 值，该值大于等于 0.0 且小于 1.0， 此值是一个伪随机选择的数。</p> 
<p style="margin-left:0;"><strong>100、<br> StringBuffer类和String类一样，都是不可变对象。</strong></p> 
<p style="margin-left:0;">答案： 错误<br> 解析：字符串是常量，因此一旦创建，其内容和长度是不可改变的，StringBuffer类长度是可以改变的。StringBuffer类似一个字符容器，当在其中添加或删除字符时，并不会产生新的StringBuffer对象。</p> 
<p style="margin-left:0;"><strong>101、<br> 编写一个Test类，获取Runtime实例，使用exec()方法执行一个dos命令，用于打开一个windows自带的记事本程序。</strong></p> 
<p style="margin-left:0;">答案：</p> 
<p style="margin-left:0;">public class Test {<!-- --><br>  public static void main(String[] args) throws IOException {<!-- --><br>   Runtime r = Runtime.getRuntime();<br>   r.exec("notepad");<br>  }<br> }</p> 
<p style="margin-left:0;"><br> 解析：通过获取到的Runtime实例，利用exec()方法，在方法中传入notepad命令，打开记事本程序。</p> 
<p style="margin-left:0;"><strong>102、<br> 阅读下面的程序，选择正确的答案？（）<br> class StringDemo{<!-- --><br>   public static void main(String[] args){<!-- --><br>     String s1 = "a";<br>   String s2 = "b";<br>   show(s1,s2);<br>   System.out.println(s1+s2);<br> }<br>  public static void show(String s1,String s2){<!-- --><br>      s1 = s1 +"q";<br>      s2 = s2 + s1;<br> }<br> }</strong></p> 
<p style="margin-left:0;">A、 ab</p> 
<p style="margin-left:0;">B、 aqb</p> 
<p style="margin-left:0;">C、 aqbaq</p> 
<p style="margin-left:0;">D、 aqaqb</p> 
<p style="margin-left:0;">答案： A<br> 解析：字符串不变性。</p> 
<p style="margin-left:0;"><strong>103、<br> 在程序，获取字符串长度的方法是【】。</strong></p> 
<p style="margin-left:0;">答案：</p> 
<p style="margin-left:0;">length()</p> 
<p style="margin-left:0;">；<br> 解析：在程序，获取字符串长度的方法是：length()方法。</p> 
<p style="margin-left:0;"><strong>104、<br> 使用String类的toCharArray()方法可以将一个字符串转为一个字符数组。</strong></p> 
<p style="margin-left:0;">答案： 正确<br> 解析：使用String类的toCharArray()方法可以将一个字符串转为一个字符数组。</p> 
<p style="margin-left:0;"><strong>105、<br> 针对字符串的操作，Java提供了两个字符串类，分别是String和【】。</strong></p> 
<p style="margin-left:0;">答案：</p> 
<p style="margin-left:0;">StringBuffer</p> 
<p style="margin-left:0;">；</p> 
<p style="margin-left:0;"><strong>106、<br> System.getProperties()方法可以获取操作系统的属性。</strong></p> 
<p style="margin-left:0;">答案： 正确<br> 解析：System类的getProperties()方法用于获取系统属性。</p> 
<p style="margin-left:0;"><strong>107、<br> 下面哪些方法是字符串中的判断方法（）</strong></p> 
<p style="margin-left:0;">A、 booleancontains(CharSequencecs)</p> 
<p style="margin-left:0;">B、 StringtoLowerCase()</p> 
<p style="margin-left:0;">C、 booleanequals(ObjectanObject)</p> 
<p style="margin-left:0;">D、 booleanisEmpty()</p> 
<p style="margin-left:0;">答案： ACD<br> 解析：B答案使用默认语言环境的规则将String中的所有字符都转换为小写。</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/220cbfe9147ca04861e26f0eb9c4e1f1/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">Linux命令之ifconfig</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/33ccc5fb5c6d10d968adae8c876cbc89/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">@TableId(type = IdType.AUTO)不生效</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>