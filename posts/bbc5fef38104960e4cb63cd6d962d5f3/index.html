<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>2.多线程并发 - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="2.多线程并发" />
<meta property="og:description" content="1.说说你知道的创建线程的方式 1、继承Thread类，重写run方法。2、实现Runnable接口，重写run方法。3、实现Callable接口，重写call方法。4、通过线程池创建线程。
https://blog.csdn.net/u013541140/article/details/95225769
CachedThreadPool:可缓存的线程池，该线程池中没有核心线程，非核心线程的数量为Integer.max_value，就是无限大，当有需要时创建线程来执行任务，没有需要时回收线程，适用于耗时少，任务量大的情况。 SecudleThreadPool:周期性执行任务的线程池，按照某种特定的计划执行线程中的任务，有核心线程，但也有非核心线程，非核心线程的大小也为无限大。适用于执行周期性的任务。
SingleThreadPool:只有一条线程来执行任务，适用于有顺序的任务的应用场景。
FixedThreadPool:定长的线程池，有核心线程，核心线程的即为最大的线程数量，没有非核心线程
我们在用阿里巴巴代码检测工具检测时 “线程池不允许使用Executors去创建，而是通过ThreadPoolExecutor的方式，这样的处理方式让写的同学更加明确线程池的运行规则，规避资源耗尽的风险。
public ThreadPoolExecutor(int corePoolSize, int maximumPoolSize, long keepAliveTime, TimeUnit unit, BlockingQueue&lt;Runnable&gt; workQueue, ThreadFactory threadFactory, RejectedExecutionHandler handler) corePoolSize：线程池中的线程数量；
maximumPoolSize：线程池中的最大线程数量；
keepAliveTime：当线程池线程数量超过corePoolSize时，多余的空闲线程会在多长时间内被销毁；
unit：keepAliveTime的时间单位；
workQueue：任务队列，被提交但是尚未被执行的任务；
threadFactory：线程工厂，用于创建线程，一般情况下使用默认的，即Executors类的静态方法defaultThreadFactory()；handler：拒绝策略。当任务太多来不及处理时，如何拒绝任务
https://blog.csdn.net/bojikeqian/article/details/120946609
2.说说Callable Callable的call方法提供返回值，所以当你需要知道任务执行的结果时，Callable是个不错的选择。
Callable任务通过线程池的submit方法提交
class IntegerCallableTask implements Callable&lt;Integer&gt; { @Override public Integer call() throws Exception { int sum = 0; for (int i = 0; i &lt; 520; i&#43;&#43;) { sum &#43;= i; } return sum; } } Callable任务通过线程池的submit方法提交。且submit方法返回Future对象，通过Future的get方法可以获得具体的计算结果。而且get是个阻塞的方法，如果任务未执行完，则一直等待。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/bbc5fef38104960e4cb63cd6d962d5f3/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-03-14T13:45:59+08:00" />
<meta property="article:modified_time" content="2022-03-14T13:45:59+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">2.多线程并发</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <h2><a id="1_0"></a>1.说说你知道的创建线程的方式</h2> 
<ul><li>1、继承Thread类，重写run方法。</li><li>2、实现Runnable接口，重写run方法。</li><li>3、实现Callable接口，重写call方法。</li><li>4、通过线程池创建线程。<br> <a href="https://blog.csdn.net/u013541140/article/details/95225769">https://blog.csdn.net/u013541140/article/details/95225769</a><br> CachedThreadPool:可缓存的线程池，该线程池中没有核心线程，非核心线程的数量为Integer.max_value，就是无限大，当有需要时创建线程来执行任务，没有需要时回收线程，适用于耗时少，任务量大的情况。</li></ul> 
<p>SecudleThreadPool:周期性执行任务的线程池，按照某种特定的计划执行线程中的任务，有核心线程，但也有非核心线程，非核心线程的大小也为无限大。适用于执行周期性的任务。</p> 
<p>SingleThreadPool:只有一条线程来执行任务，适用于有顺序的任务的应用场景。</p> 
<p>FixedThreadPool:定长的线程池，有核心线程，核心线程的即为最大的线程数量，没有非核心线程</p> 
<p>我们在用阿里巴巴代码检测工具检测时 “线程池不允许使用Executors去创建，而是通过ThreadPoolExecutor的方式，这样的处理方式让写的同学更加明确线程池的运行规则，规避资源耗尽的风险。</p> 
<pre><code class="prism language-java"><span class="token keyword">public</span> <span class="token function">ThreadPoolExecutor</span><span class="token punctuation">(</span><span class="token keyword">int</span> corePoolSize<span class="token punctuation">,</span>
            <span class="token keyword">int</span> maximumPoolSize<span class="token punctuation">,</span>
            <span class="token keyword">long</span> keepAliveTime<span class="token punctuation">,</span>
            TimeUnit unit<span class="token punctuation">,</span>
            BlockingQueue<span class="token generics function"><span class="token punctuation">&lt;</span>Runnable<span class="token punctuation">&gt;</span></span> workQueue<span class="token punctuation">,</span>
            ThreadFactory threadFactory<span class="token punctuation">,</span>
            RejectedExecutionHandler handler<span class="token punctuation">)</span>

</code></pre> 
<p>corePoolSize：线程池中的线程数量；<br> maximumPoolSize：线程池中的最大线程数量；<br> keepAliveTime：当线程池线程数量超过corePoolSize时，多余的空闲线程会在多长时间内被销毁；<br> unit：keepAliveTime的时间单位；<br> workQueue：任务队列，被提交但是尚未被执行的任务；<br> threadFactory：线程工厂，用于创建线程，一般情况下使用默认的，即Executors类的静态方法defaultThreadFactory()；handler：拒绝策略。当任务太多来不及处理时，如何拒绝任务<br> <a href="https://blog.csdn.net/bojikeqian/article/details/120946609">https://blog.csdn.net/bojikeqian/article/details/120946609</a></p> 
<h2><a id="2Callable_34"></a>2.说说Callable</h2> 
<p>Callable的call方法提供返回值，所以当你需要知道任务执行的结果时，Callable是个不错的选择。<br> Callable任务通过线程池的submit方法提交</p> 
<pre><code class="prism language-java"><span class="token keyword">class</span> <span class="token class-name">IntegerCallableTask</span> <span class="token keyword">implements</span> <span class="token class-name">Callable</span><span class="token generics function"><span class="token punctuation">&lt;</span>Integer<span class="token punctuation">&gt;</span></span> <span class="token punctuation">{<!-- --></span>
    <span class="token annotation punctuation">@Override</span>
    <span class="token keyword">public</span> Integer <span class="token function">call</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> Exception <span class="token punctuation">{<!-- --></span>
        <span class="token keyword">int</span> sum <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">520</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
            sum <span class="token operator">+=</span> i<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">return</span> sum<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>Callable任务通过线程池的submit方法提交。且submit方法返回Future对象，通过Future的get方法可以获得具体的计算结果。而且get是个阻塞的方法，如果任务未执行完，则一直等待。</p> 
<pre><code class="prism language-java">        ExecutorService executor <span class="token operator">=</span> Executors<span class="token punctuation">.</span><span class="token function">newCachedThreadPool</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        IntegerCallableTask integerCallableTask <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">IntegerCallableTask</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        Future<span class="token generics function"><span class="token punctuation">&lt;</span>Integer<span class="token punctuation">&gt;</span></span> future <span class="token operator">=</span> executor<span class="token punctuation">.</span><span class="token function">submit</span><span class="token punctuation">(</span>integerCallableTask<span class="token punctuation">)</span><span class="token punctuation">;</span>
        executor<span class="token punctuation">.</span><span class="token function">shutdown</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">try</span> <span class="token punctuation">{<!-- --></span>
            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>future<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
            e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">ExecutionException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
            e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
</code></pre> 
<p>对于Calleble来说，Future和FutureTask均可以用来获取任务执行结果，不过Future是个接口，FutureTask是Future的具体实现，而且FutureTask还间接实现了Runnable接口，也就是说FutureTask可以作为Runnable任务提交给线程池。</p> 
<h2><a id="3__68"></a>3 如何控制线程执行的顺序？</h2> 
<h3><a id="31_join_69"></a>3.1 方法一：join</h3> 
<pre><code class="prism language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Test</span> <span class="token punctuation">{<!-- --></span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> InterruptedException <span class="token punctuation">{<!-- --></span>
        Thread t1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">MyThread1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        Thread t2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">MyThread2</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        Thread t3 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">MyThread3</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        t1<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        t1<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        t2<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        t2<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        t3<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">class</span> <span class="token class-name">MyThread1</span> <span class="token keyword">implements</span> <span class="token class-name">Runnable</span> <span class="token punctuation">{<!-- --></span>
    <span class="token annotation punctuation">@Override</span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"I am thread 1"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">class</span> <span class="token class-name">MyThread2</span> <span class="token keyword">implements</span> <span class="token class-name">Runnable</span> <span class="token punctuation">{<!-- --></span>
    <span class="token annotation punctuation">@Override</span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"I am thread 2"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">class</span> <span class="token class-name">MyThread3</span> <span class="token keyword">implements</span> <span class="token class-name">Runnable</span> <span class="token punctuation">{<!-- --></span>
    <span class="token annotation punctuation">@Override</span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"I am thread 3"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> 
<p><strong>join方法：让主线程等待子线程运行结束后再继续运行</strong></p> 
<p>有了join方法的帮忙，线程123就能按照指定的顺序执行了。</p> 
<p>我们来看看示例当中主线程与子线程的执行顺序。在main方法中，先是调用了t1.start方法，启动t1线程，随后调用t1的join方法，main所在的主线程就需要等待t1子线程中的run方法运行完成后才能继续运行，所以主线程卡在t2.start方法之前等待t1程序。等t1运行完后，主线程重新获得主动权，继续运行t2.start和t2.join方法，与t1子线程类似，main主线程等待t2完成后继续执行，如此执行下去，join方法就有效的解决了执行顺序问题。因为在同一个时间点，各个线程是同步状态。</p> 
<h2><a id="32_ExcutorsnewSingleThreadExecutor_113"></a>3.2 Excutors.newSingleThreadExecutor()</h2> 
<pre><code class="prism language-java"><span class="token keyword">import</span> java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>concurrent<span class="token punctuation">.</span>ExecutorService<span class="token punctuation">;</span>
<span class="token keyword">import</span> java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>concurrent<span class="token punctuation">.</span>Executors<span class="token punctuation">;</span>

<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Test</span> <span class="token punctuation">{<!-- --></span>
    <span class="token keyword">private</span> <span class="token keyword">static</span> ExecutorService executor <span class="token operator">=</span> Executors<span class="token punctuation">.</span><span class="token function">newSingleThreadExecutor</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> InterruptedException <span class="token punctuation">{<!-- --></span>
        Thread t1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">MyThread1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        Thread t2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">MyThread2</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        Thread t3 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">MyThread3</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        executor<span class="token punctuation">.</span><span class="token function">submit</span><span class="token punctuation">(</span>t1<span class="token punctuation">)</span><span class="token punctuation">;</span>
        executor<span class="token punctuation">.</span><span class="token function">submit</span><span class="token punctuation">(</span>t2<span class="token punctuation">)</span><span class="token punctuation">;</span>
        executor<span class="token punctuation">.</span><span class="token function">submit</span><span class="token punctuation">(</span>t3<span class="token punctuation">)</span><span class="token punctuation">;</span>
        executor<span class="token punctuation">.</span><span class="token function">shutdown</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">class</span> <span class="token class-name">MyThread1</span> <span class="token keyword">implements</span> <span class="token class-name">Runnable</span> <span class="token punctuation">{<!-- --></span>
    <span class="token annotation punctuation">@Override</span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"I am thread 1"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">class</span> <span class="token class-name">MyThread2</span> <span class="token keyword">implements</span> <span class="token class-name">Runnable</span> <span class="token punctuation">{<!-- --></span>
    <span class="token annotation punctuation">@Override</span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"I am thread 2"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">class</span> <span class="token class-name">MyThread3</span> <span class="token keyword">implements</span> <span class="token class-name">Runnable</span> <span class="token punctuation">{<!-- --></span>
    <span class="token annotation punctuation">@Override</span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"I am thread 3"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>利用并发包里的Excutors的newSingleThreadExecutor产生一个单线程的线程池，而这个线程池的底层原理就是一个先进先出（FIFO）的队列。代码中executor.submit依次添加了123线程，按照FIFO的特性，执行顺序也就是123的执行结果，从而保证了执行顺序。</p> 
<h2><a id="4_156"></a>4.用户线程与守护线程</h2> 
<p><strong>用户（User）线程</strong>：运行在前台，执行具体任务，如程序的主线程，连接网络的子线程都是用户线程。<br> <strong>守护（Daemon）线程</strong>：运行在后台，为其它前台线程服务，也可以说守护线程是JVM非守护线程的”佣人“，一旦所有线程都执行结束，守护线程会随着JVM一起结束运行。<br> main函数就是一个用户线程，main函数启动时，同时JVM还启动了好多的守护线程，如垃圾回收线程，比较明显的区别时，用户线程结束，JVM退出，不管这个时候有没有守护线程的运行，都不会影响JVM的退出。</p> 
<h2><a id="5_163"></a>5线程死锁</h2> 
<h3><a id="51_164"></a>5.1什么是线程死锁</h3> 
<p>死锁是指两个或两个以上进程(线程)在执行过程中，由于竞争资源或由于彼此通信造成的一种堵塞的现象，若无外力的作用下，都将无法推进，此时的系统处于死锁状态。<br> 如图，线程A拥有的资源2，线程B拥有的资源1，此时线程A和线程B都试图去拥有资源1和资源2，但是它们的🔒还在，因此就出现了死锁。<br> <img src="https://images2.imgbox.com/9d/2e/YKgby5jB_o.png" alt="在这里插入图片描述"></p> 
<h3><a id="52__169"></a>5.2 形成死锁的四个必要条件</h3> 
<ul><li>互斥条件：线程(进程)对所分配的资源具有排它性，即一个资源只能被一个进程占用，直到该进程被释放。</li><li>请求与保持条件：一个进程(线程)因请求被占有资源而发生堵塞时，对已获取的资源保持不放。</li><li>不剥夺条件：线程(进程)已获取的资源在未使用完之前不能被其他线程强行剥夺，只有等自己使用完才释放资源。</li><li>循环等待条件：当发生死锁时，所等待的线程(进程)必定形成一个环路，死循环造成永久堵塞。</li></ul> 
<h3><a id="53_174"></a>5.3如何避免死锁</h3> 
<ul><li>1、加锁顺序。<br> 当多个线程需要相同的一些锁，但是按照不同的顺序加锁，死锁就很容易发生。如果能确保所有的线程都是按照相同的顺序获得锁，那么死锁就不会发生</li><li>2、加锁时限<br> 另外一个可以避免死锁的方法是在尝试获取锁的时候加一个超时时间，这也就意味着在尝试获取锁的过程中若超过了这个时限该线程则放弃对该锁请求。若一个线程没有在给定的时限内成功获得所有需要的锁，则会进行回退并释放所有已经获得的锁，然后等待一段随机的时间再重试。<br> <strong>单体应用</strong>锁一般是用 <mark>synchronized</mark>和<mark>volatile</mark><br> <strong>分布式</strong>锁 redisson实现的redis锁</li></ul> 
<h2><a id="6ThreadLocal_181"></a>6.ThreadLocal</h2> 
<p><a href="https://blog.csdn.net/qq_35190492/article/details/107599875">https://blog.csdn.net/qq_35190492/article/details/107599875</a></p> 
<h2><a id="7_6_185"></a>7 线程声明周期的6种状态</h2> 
<p><img src="https://images2.imgbox.com/39/69/5ZkJS9YT_o.png" alt="在这里插入图片描述"></p> 
<h2><a id="8_Java_187"></a>8 阿里巴巴Java开发手册推荐线程池的创建方式你知道吗</h2> 
<p>之前在项目中做一些任务型的项目，采用多线程方式，笔者通常用ExecutorService cachedThreadPool=Executors.newFixedThreadPool();方式创建。但是后来看阿里巴巴的JAVA开发手册，上面有个建议：【强制】线程池不允许使用 Executors 去创建，而是通过 ThreadPoolExecutor 的方式，这样的处理方式让写的同学更加明确线程池的运行规则，规避资源耗尽的风险。那么线程池的原理是什么样的？创建方式是什么样的呢？接下来让我们看看。</p> 
<pre><code class="prism language-java"><span class="token keyword">public</span> <span class="token function">ThreadPoolExecutor</span><span class="token punctuation">(</span><span class="token keyword">int</span> corePoolSize<span class="token punctuation">,</span>
                          <span class="token keyword">int</span> maximumPoolSize<span class="token punctuation">,</span>
                          <span class="token keyword">long</span> keepAliveTime<span class="token punctuation">,</span>
                          TimeUnit unit<span class="token punctuation">,</span>
                          BlockingQueue<span class="token generics function"><span class="token punctuation">&lt;</span>Runnable<span class="token punctuation">&gt;</span></span> workQueue<span class="token punctuation">,</span>
                          ThreadFactory threadFactory<span class="token punctuation">,</span>
                          RejectedExecutionHandler handler<span class="token punctuation">)</span> 
</code></pre> 
<p>参数解释：</p> 
<p>corePoolSize ： 线程池核心池的大小。<br> maximumPoolSize ： 线程池的最大线程数。<br> keepAliveTime ： 当线程数大于核心时，此为终止前多余的空闲线程等待新任务的最长时间。<br> unit ： keepAliveTime 的时间单位。<br> workQueue ： 用来储存等待执行任务的队列。<br> threadFactory ： 线程工厂。<br> handler 拒绝策略。<br> <a href="https://blog.csdn.net/jek123456/article/details/90601351">https://blog.csdn.net/jek123456/article/details/90601351</a><br> <a href="https://blog.csdn.net/K_520_W/article/details/108992698">https://blog.csdn.net/K_520_W/article/details/108992698</a></p> 
<p>其他面试题<br> <a href="https://blog.csdn.net/JAYU_37/article/details/106321844">https://blog.csdn.net/JAYU_37/article/details/106321844</a></p> 
<p><a href="https://blog.csdn.net/m0_45270667/article/details/108598282">https://blog.csdn.net/m0_45270667/article/details/108598282</a></p> 
<h2><a id="JUC_218"></a>JUC面试题</h2> 
<p><a href="https://blog.csdn.net/Piratesa/article/details/102710342">https://blog.csdn.net/Piratesa/article/details/102710342</a><br> <a href="https://blog.csdn.net/weixin_44018338/article/details/105600264">https://blog.csdn.net/weixin_44018338/article/details/105600264</a></p> 
<h2><a id="_223"></a>锁机制</h2> 
<p><a href="https://blog.csdn.net/qq_41181619/article/details/81407289">https://blog.csdn.net/qq_41181619/article/details/81407289</a></p> 
<p><a href="https://developer.aliyun.com/article/607025" rel="nofollow">https://developer.aliyun.com/article/607025</a></p> 
<h2><a id="9_JMM_232"></a>9 JMM</h2> 
<p>java内存模型：为什么会有JMM呢<br> JVM实现不同会造成“翻译”的效果不同，不同CPU平台的机器指令有千差万别，无法保证同一份代码并发下的效果一致。所以需要一套统一的规范来约束JVM的翻译过程，保证并发效果一致性<br> <img src="https://images2.imgbox.com/3a/8b/YSNN6PXU_o.png" alt="在这里插入图片描述"><br> <strong>三个特性</strong></p> 
<ul><li>原子性</li><li>有序性</li><li>可见性</li></ul> 
<h3><a id="ReentrantLock_242"></a>ReentrantLock</h3> 
<p>是一个悲观锁 仔细看代码发现ReentrantLock使用了setExclusiveOwnerThread方法，<br> 这个方法是将某一个线程设置为独占线程。就是我们常说的互斥锁。</p> 
<p>AQS：也就是队列同步器，这是实现 ReentrantLock 的基础。</p> 
<p>AQS 有一个 state 标记位，值为1 时表示有线程占用，其他线程需要进入到同步队列等待，同步队列是一个双向链表。<br> <img src="https://images2.imgbox.com/13/e9/mu5Fz2zI_o.png" alt="在这里插入图片描述"><br> 当获得锁的线程需要等待某个条件时，会进入 condition 的等待队列，等待队列可以有多个。</p> 
<p>当 condition 条件满足时，线程会从等待队列重新进入同步队列进行获取锁的竞争。</p> 
<p>ReentrantLock 就是基于 AQS 实现的，如下图所示，ReentrantLock 内部有公平锁和非公平锁两种实现，差别就在于新来的线程是否比已经在同步队列中的等待线程更早获得锁。</p> 
<p>是针对获取锁而言的，如果一个锁是公平的，那么锁的获取顺序就应该符合请求上的绝对时间顺序，满足FIFO(First In First Out).公平锁每次都是从同步队列中的第一个节点获取到锁，而非公平性锁则不一定，有可能刚释放锁的线程能再次获取到锁。</p> 
<h3><a id="synchronized_257"></a>synchronized</h3> 
<p>1 . <strong>synchronized</strong>的特点<br> 一个线程执行互斥代码过程如下：</p> 
<ol><li>获得同步锁；</li><li>清空工作内存；</li><li>从主内存拷贝对象副本到工作内存；</li><li>执行代码(计算或者输出等)；</li><li>刷新主内存数据；</li><li>释放同步锁。<br> 所以，<strong>synchronized既保证了多线程的并发有序性，又保证了多线程的内存可见性</strong>。</li></ol> 
<h4><a id="_269"></a>同步代码原理：</h4> 
<p>当我们进入一个人方法的时候，执行monitorenter，就会获取当前对象的一个所有权，这个时候monitor进入数为1，当前的这个线程就是这个monitor的owner。</p> 
<p>如果你已经是这个monitor的owner了，你再次进入，就会把进入数+1.</p> 
<p>同理，当他执行完monitorexit，对应的进入数就-1，直到为0，才可以被其他线程持有。</p> 
<h4><a id="_275"></a>同步方法原理：</h4> 
<p>不知道大家注意到方法那的一个特殊标志位没，ACC_SYNCHRONIZED。</p> 
<p>同步方法的时候，一旦执行到这个方法，就会先判断是否有标志位，然后，ACC_SYNCHRONIZED会去隐式调用刚才的两个指令：monitorenter和monitorexit。</p> 
<p>所以归根究底，还是monitor对象的争夺。</p> 
<h3><a id="volatile_283"></a><strong>volatile</strong></h3> 
<p>volatile可以保证内存<strong>可见性</strong>，并发有序性(不具有原子性)。<br> volatile可以保证线程可见性且提供了一定的有序性，但是无法保证原子性。在JVM底层volatile是采用“内存屏障”来实现的。观察加入volatile关键字和没有加入volatile关键字时所生成的汇编代码发现，加入volatile关键字时，会多出一个lock前缀指令，lock前缀指令实际上相当于一个内存屏障（也成内存栅栏），内存屏障会提供3个功能：</p> 
<p>（1）它确保指令重排序时不会把其后面的指令排到内存屏障之前的位置，也不会把前面的指令排到内存屏障的后面；即在执行到内存屏障这句指令时，在它前面的操作已经全部完成；</p> 
<p>（2）它会强制将对缓存的修改操作立即写入主存；</p> 
<p>（3）如果是写操作，它会导致其他CPU中对应的缓存行无效</p> 
<h4><a id="_294"></a>锁的升级</h4> 
<p>方向是不可逆的<br> <img src="https://images2.imgbox.com/1e/4c/hAQaREjh_o.png" alt="在这里插入图片描述"></p> 
<h2><a id="11_298"></a>11扩展</h2> 
<ol><li>Synchronized 和 ReenTrantLock 的对比<br> ① 两者都是可重入锁</li></ol> 
<p>两者都是可重入锁。“可重入锁”概念是：自己可以再次获取自己的内部锁。比如一个线程获得了某个对象的锁，此时这个对象锁还没有释放，当其再次想要获取这个对象的锁的时候还是可以获取的，如果不可锁重入的话，就会造成死锁。同一个线程每次获取锁，锁的计数器都自增1，所以要等到锁的计数器下降为0时才能释放锁。</p> 
<p>② synchronized依赖于JVM而ReenTrantLock依赖于API</p> 
<p>synchronized是依赖于JVM实现的，前面我们也讲到了 虚拟机团队在JDK1.6为synchronized关键字进行了很多优化，但是这些优化都是在虚拟机层面实现的，并没有直接暴露给我们。ReenTrantLock是JDK层面实现的（也就是API层面，需要lock()和unlock()方法配合try/finally语句块来完成），所以我们可以通过查看它的源代码，来看它是如何实现的。</p> 
<p>③ ReenTrantLock比synchronized增加了一些高级功能</p> 
<p>相比synchronized，ReenTrantLock增加了一些高级功能。主要来说主要有三点：<strong>①等待可中断；②可实现公平锁；③可实现选择性通知</strong>（锁可以绑定多个条件）</p> 
<p>ReenTrantLock提供了一种能够中断等待锁的线程的机制，通过lock.lockInterruptibly()来实现这个机制。也就是说正在等待的线程可以选择放弃等待，改为处理其他事情。</p> 
<p>ReenTrantLock可以指定是公平锁还是非公平锁。而synchronized只能是非公平锁。所谓的公平锁就是先等待的线程先获得锁。ReenTrantLock默认情况是非公平的，可以通过ReenTrantLoc类的ReentrantLock(boolean fair)构造方法来制定是否是公平的。</p> 
<p>synchronized关键字与wait()和notify()/notifyAll()方法相结合可以实现等待/通知机制，ReentrantLock类当然也可以实现，但是需要借助于Condition接口与newCondition()方法。Condition是JDK1.5之后才有的，它具有很好的灵活性，比如可以实现多路通知功能也就是在一个Lock对象中可以创建多个Condition实例（即对象监视器），线程对象可以注册在指定的Condition中，从而可以有选择性的进行线程通知，在调度线程上更加灵活。 在使用notify/notifyAll()方法进行通知时，被通知的线程是由JVM选择的，用ReentrantLock类结合Condition实例可以实现“选择性通知” ，这个功能非常重要，而且是Condition接口默认提供的。而synchronized关键字就相当于整个Lock对象中只有一个Condition实例，所有的线程都注册在它一个身上。如果执行notifyAll()方法的话就会通知所有处于等待状态的线程这样会造成很大的效率问题，而Condition实例的signalAll()方法只会唤醒注册在该Condition实例中的所有等待线程。</p> 
<h2><a id="12__320"></a>12 多线程原理</h2> 
<p><a href="https://blog.csdn.net/v123411739/article/details/106609583">https://blog.csdn.net/v123411739/article/details/106609583</a></p> 
<h2><a id="13__323"></a>13 拒绝策略和阻塞队列</h2> 
<p><a href="https://blog.csdn.net/qq_35909080/article/details/87002367">https://blog.csdn.net/qq_35909080/article/details/87002367</a></p> 
<p>线程池与对策的选择<br> <a href="https://blog.csdn.net/qq_37334150/article/details/109559195">https://blog.csdn.net/qq_37334150/article/details/109559195</a></p> 
<h2><a id="14_Javasleepwait_328"></a>14 Java中sleep()与wait()区别</h2> 
<p>1、每个对象都有一个锁来控制同步访问，Synchronized关键字可以和对象的锁交互，来实现同步方法或同步块。<strong>sleep()方法</strong>正在执行的线程主动让出CPU（然后CPU就可以去执行其他任务），在sleep指定时间后CPU再回到该线程继续往下执行(注意：sleep方法只让出了CPU，而并不会释放同步资源锁！！！)；<strong>wait()方法</strong>则是指当前线程让自己暂时退让出同步资源锁，以便其他正在等待该资源的线程得到该资源进而运行，只有调用了notify()方法，之前调用wait()的线程才会解除wait状态，可以去参与竞争同步资源锁，进而得到执行。（注意：notify的作用相当于叫醒睡着的人，而并不会给他分配任务，就是说notify只是让之前调用wait的线程有权利重新参与线程的调度）；</p> 
<p>2、<strong>sleep()方法</strong>可以在任何地方使用；wait()方法则只能在同步方法或同步块中使用；</p> 
<p>3、<strong>sleep</strong>()是线程线程类（Thread）的方法，调用会暂停此线程指定的时间，但监控依然保持，不会释放对象锁，到时间自动恢复；wait()是Object的方法，调用会放弃对象锁，进入等待队列，待调用notify()/notifyAll()唤醒指定的线程或者所有线程，才会进入锁池，不再次获得对象锁才会进入运行状态；</p> 
<h2><a id="15__run__start__335"></a>15 线程的 run() 和 start() 有什么区别？</h2> 
<ul><li> <p>1、start方法启动了一个新的线程，而run方法不能启动一个新线程，还是在main线程下运行，程序依然是主线程一个线程在运行。</p> </li><li> <p>2、调用start方法可以启动线程，而run方法只是thread的一个普通方法还是在主线程中执行。</p> </li><li> <p>3、通过start()方法来启动的新线程，处于就绪（可运行）状态，并没有运行，一旦得到cpu时间片，就开始执行相应线程的run()方法，这里方法run()称为线程体，它包含了要执行的这个线程的内容，run方法运行结束，此线程随即终止。start()不能被重复调用。而run方法能被重复调用，因为它就是一个普通的成员方法。</p> </li><li> <p>4、start方法在执行线程体中代码时，在不执行完的情况下可以进行线程切换，而run方法不能，run方法只能进行顺序执行。</p> </li></ul>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/35a6a876de929e8aa8ce6982ac7f0769/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">低代码和无代码的注意事项</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/1c7b6d0c9535e792b9881f01331ffe24/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">环计数问题</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>