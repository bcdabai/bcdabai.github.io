<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>计算机网络学习 - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="计算机网络学习" />
<meta property="og:description" content="文章目录 一、HTTP学习1.1 HTTP 简介1.1.1 HTTP 工作原理1.1.2 HTTP 注意事项 1.2 HTTP 消息结构1.2.1 客户端请求消息1.2.1.1 请求行1.2.1.2 请求头1.2.1.3 请求数据 1.2.2 服务器响应消息 1.3 HTTP 请求方法1.3.1 POST 与 GET 的区别 1.3 HTTP 状态码 二、TCP/IP学习2.1 TCP/IP 简介2.2 TCP/IP 协议2.2.1 TCP - 传输控制协议2.2.2 IP - 网际协议（Internet Protocol）2.2.3 HTTP - 超文本传输协议(Hyper Text Transfer Protocol)2.2.4 HTTPS - 超文本传输安全协议（HTTP Secure）2.2.5 SSL - 安全套接字层（Secure Sockets Layer）2.2.6 SMTP - 简易邮件传输协议（Simple Mail Transfer Protocol）2.2.7 MIME - 多用途因特网邮件扩展（Multi-purpose Internet Mail Extensions）2.2.8 IMAP - 因特网消息访问协议（Internet Message Access Protocol）2." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/d2dfbbfb1b6e86a7a7f23dbb5bf55359/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-06-16T16:20:07+08:00" />
<meta property="article:modified_time" content="2022-06-16T16:20:07+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">计算机网络学习</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p></p> 
<div class="toc"> 
 <h4>文章目录</h4> 
 <ul><li><a href="#HTTP_1" rel="nofollow">一、HTTP学习</a></li><li><ul><li><a href="#11_HTTP__2" rel="nofollow">1.1 HTTP 简介</a></li><li><ul><li><a href="#111_HTTP__7" rel="nofollow">1.1.1 HTTP 工作原理</a></li><li><a href="#112_HTTP__16" rel="nofollow">1.1.2 HTTP 注意事项</a></li></ul> 
   </li><li><a href="#12_HTTP__25" rel="nofollow">1.2 HTTP 消息结构</a></li><li><ul><li><a href="#121__36" rel="nofollow">1.2.1 客户端请求消息</a></li><li><ul><li><a href="#1211__40" rel="nofollow">1.2.1.1 请求行</a></li><li><a href="#1212__43" rel="nofollow">1.2.1.2 请求头</a></li><li><a href="#1213__63" rel="nofollow">1.2.1.3 请求数据</a></li></ul> 
    </li><li><a href="#122__68" rel="nofollow">1.2.2 服务器响应消息</a></li></ul> 
   </li><li><a href="#13_HTTP__75" rel="nofollow">1.3 HTTP 请求方法</a></li><li><ul><li><a href="#131_POST__GET__82" rel="nofollow">1.3.1 POST 与 GET 的区别</a></li></ul> 
   </li><li><a href="#13_HTTP__88" rel="nofollow">1.3 HTTP 状态码</a></li></ul> 
  </li><li><a href="#TCPIP_99" rel="nofollow">二、TCP/IP学习</a></li><li><ul><li><a href="#21_TCPIP__100" rel="nofollow">2.1 TCP/IP 简介</a></li><li><a href="#22_TCPIP__109" rel="nofollow">2.2 TCP/IP 协议</a></li><li><ul><li><a href="#221_TCP___112" rel="nofollow">2.2.1 TCP - 传输控制协议</a></li><li><a href="#222_IP__Internet_Protocol_117" rel="nofollow">2.2.2 IP - 网际协议（Internet Protocol）</a></li><li><a href="#223_HTTP__Hyper_Text_Transfer_Protocol_122" rel="nofollow">2.2.3 HTTP - 超文本传输协议(Hyper Text Transfer Protocol)</a></li><li><a href="#224_HTTPS__HTTP_Secure_127" rel="nofollow">2.2.4 HTTPS - 超文本传输安全协议（HTTP Secure）</a></li><li><a href="#225_SSL__Secure_Sockets_Layer_132" rel="nofollow">2.2.5 SSL - 安全套接字层（Secure Sockets Layer）</a></li><li><a href="#226_SMTP__Simple_Mail_Transfer_Protocol_135" rel="nofollow">2.2.6 SMTP - 简易邮件传输协议（Simple Mail Transfer Protocol）</a></li><li><a href="#227_MIME__Multipurpose_Internet_Mail_Extensions_138" rel="nofollow">2.2.7 MIME - 多用途因特网邮件扩展（Multi-purpose Internet Mail Extensions）</a></li><li><a href="#228_IMAP__Internet_Message_Access_Protocol_141" rel="nofollow">2.2.8 IMAP - 因特网消息访问协议（Internet Message Access Protocol）</a></li><li><a href="#229_POP__Post_Office_Protocol_144" rel="nofollow">2.2.9 POP - 邮局协议（Post Office Protocol）</a></li><li><a href="#2210_FTP__File_Transfer_Protocol_147" rel="nofollow">2.2.10 FTP - 文件传输协议（File Transfer Protocol）</a></li><li><a href="#2211_DHCP__Dynamic_Host_Configuration_Protocol_150" rel="nofollow">2.2.11 DHCP - 动态主机配置协议（Dynamic Host Configuration Protocol）</a></li><li><a href="#2212_ARP__Address_Resolution_Protocol_153" rel="nofollow">2.2.12 ARP - 地址解析协议（Address Resolution Protocol）</a></li><li><a href="#2213_RARP__Reverse_Address_Resolution_Protocol_156" rel="nofollow">2.2.13 RARP - 反向地址转换协议（Reverse Address Resolution Protocol）</a></li></ul> 
   </li><li><a href="#23_TCPIP__159" rel="nofollow">2.3 TCP/IP 模型</a></li><li><a href="#24_TCP_161" rel="nofollow">2.4 TCP协议的三次握手和四次挥手</a></li><li><ul><li><a href="#241__180" rel="nofollow">2.4.1 为什么要三次握手？</a></li><li><a href="#242__183" rel="nofollow">2.4.2 为什么要四次挥手？</a></li></ul> 
  </li></ul> 
  </li><li><a href="#UDP_188" rel="nofollow">三、UDP协议</a></li><li><a href="#_197" rel="nofollow">四、其他网络知识</a></li><li><ul><li><a href="#41__199" rel="nofollow">4.1 在浏览器上输入网址后的全部过程</a></li><li><a href="#42_HTTP__HTTPS__208" rel="nofollow">4.2 HTTP 与 HTTPS 的区别</a></li><li><a href="#43__216" rel="nofollow">4.3 什么是跨域</a></li><li><ul><li><a href="#431__230" rel="nofollow">4.3.1 跨域解决方法</a></li><li><ul><li><a href="#4311_JSONP_231" rel="nofollow">4.3.1.1 JSONP</a></li><li><a href="#4312_CORS__279" rel="nofollow">4.3.1.2 CORS 跨域资源共享</a></li><li><ul><li><a href="#43121_CORS__293" rel="nofollow">4.3.1.2.1 CORS 简单请求</a></li><li><a href="#43122_CORS__321" rel="nofollow">4.3.1.2.2 CORS 非简单请求</a></li></ul> 
     </li><li><a href="#4313_node_405" rel="nofollow">4.3.1.3 node代理跨域</a></li><li><a href="#4314_nginx_433" rel="nofollow">4.3.1.4 nginx代理跨域</a></li><li><ul><li><a href="#43141_nginxiconfont_435" rel="nofollow">4.3.1.4.1 nginx配置解决iconfont跨域</a></li><li><a href="#43142_nginx_444" rel="nofollow">4.3.1.4.2 nginx反向代理接口跨域</a></li></ul> 
    </li></ul> 
   </li></ul> 
   </li><li><a href="#44_SessionStoragelocalStoragecookie_502" rel="nofollow">4.4 SessionStorage、localStorage和cookie的区别</a></li><li><a href="#45__509" rel="nofollow">4.5 前端性能优化方案</a></li></ul> 
  </li><li><a href="#OSI_533" rel="nofollow">五、OSI七层模型</a></li><li><ul><li><a href="#51__537" rel="nofollow">5.1 各层定义</a></li></ul> 
  </li><li><a href="#WebSocket_561" rel="nofollow">六、WebSocket</a></li><li><ul><li><a href="#61_WebSocket__HTTP__574" rel="nofollow">6.1 WebSocket 与 HTTP 的区别</a></li><li><a href="#62_WebSocket_580" rel="nofollow">6.2 WebSocket连接的过程</a></li><li><a href="#63_Websocket__604" rel="nofollow">6.3 Websocket 优缺点</a></li><li><a href="#64_Websocket__612" rel="nofollow">6.4 Websocket 断线重连</a></li><li><a href="#65_WebSocket_631" rel="nofollow">6.5 WebSocket应用场景</a></li><li><a href="#66_demo_640" rel="nofollow">6.6 demo实现</a></li></ul> 
 </li></ul> 
</div> 
<p></p> 
<h2><a id="HTTP_1"></a>一、HTTP学习</h2> 
<h3><a id="11_HTTP__2"></a>1.1 HTTP 简介</h3> 
<p><code>HTTP协议</code>（HyperText Transfer Protocol，<code>超文本传输协议</code>）是因特网上应用最为广泛的一种<code>网络传输协议</code>。是用于从万维网（WWW:World Wide Web ）服务器传输超文本到本地浏览器的传送协议。</p> 
<p><code>HTTP</code>是一个基于<code>TCP/IP</code>通信协议来传递数据（HTML 文件, 图片文件, 查询结果等）。是TCP/IP协议的一个<code>应用层</code>协议</p> 
<h4><a id="111_HTTP__7"></a>1.1.1 HTTP 工作原理</h4> 
<p><mark>HTTP协议工作于客户端-服务端架构上。浏览器作为HTTP客户端通过URL向HTTP服务端即WEB服务器发送所有请求。</mark></p> 
<p>Web服务器有：Apache服务器，IIS服务器（Internet Information Services）等。</p> 
<p>Web服务器根据接收到的请求后，向客户端发送响应信息。</p> 
<p>HTTP默认端口号为80，但是你也可以改为8080或者其他端口。</p> 
<h4><a id="112_HTTP__16"></a>1.1.2 HTTP 注意事项</h4> 
<p><mark>HTTP是无连接</mark>：无连接的含义是限制每次连接只处理一个请求。服务器处理完客户的请求，并收到客户的应答后，即断开连接。采用这种方式可以节省传输时间。</p> 
<p><mark>HTTP是媒体独立的</mark>：这意味着，只要客户端和服务器知道如何处理的数据内容，任何类型的数据都可以通过HTTP发送。客户端以及服务器指定使用适合的MIME-type内容类型。</p> 
<p><mark>HTTP是无状态</mark>：HTTP协议是无状态协议。无状态是指协议对于事务处理没有记忆能力。缺少状态意味着如果后续处理需要前面的信息，则它必须重传，这样可能导致每次连接传送的数据量增大。另一方面，在服务器不需要先前信息时它的应答就较快。</p> 
<p><img src="https://images2.imgbox.com/e7/8c/6T8VZByR_o.png" alt="在这里插入图片描述"></p> 
<h3><a id="12_HTTP__25"></a>1.2 HTTP 消息结构</h3> 
<p><mark>HTTP是基于客户端/服务端（C/S）的架构模型，通过一个可靠的链接来交换信息，是一个无状态的请求/响应协议。</mark></p> 
<p>一个HTTP"客户端"是一个应用程序（Web浏览器或其他任何客户端），通过连接到服务器达到向服务器发送一个或多个HTTP的请求的目的。</p> 
<p>一个HTTP"服务器"同样也是一个应用程序（通常是一个Web服务，如Apache Web服务器或IIS服务器等），通过接收客户端的请求并向客户端发送HTTP响应数据。</p> 
<p>HTTP使用统一资源标识符（Uniform Resource Identifiers, URI）来传输数据和建立连接。</p> 
<p>一旦建立连接后，数据消息就通过类似Internet邮件所使用的格式[RFC5322]和多用途Internet邮件扩展（MIME）[RFC2045]来传送。</p> 
<h4><a id="121__36"></a>1.2.1 客户端请求消息</h4> 
<p>客户端发送一个HTTP请求到服务器的请求消息包括以下格式：请求行（request line）、请求头部（header）、空行和请求数据四个部分组成，下图给出了请求报文的一般格式。</p> 
<p><img src="https://images2.imgbox.com/1e/f4/015HDauo_o.png" alt="在这里插入图片描述"></p> 
<h5><a id="1211__40"></a>1.2.1.1 请求行</h5> 
<p>请求行包括请求URL（Request URL）、请求方法（Request Method）、<br> <img src="https://images2.imgbox.com/57/d1/isY68ITB_o.png" alt="在这里插入图片描述"></p> 
<h5><a id="1212__43"></a>1.2.1.2 请求头</h5> 
<p>请求携带的一些规范要求信息，可以手动写入请求头</p> 
<pre><code class="prism language-javascript"><span class="token comment">// 请求拦截器中</span>
axios<span class="token punctuation">.</span>interceptors<span class="token punctuation">.</span>request<span class="token punctuation">.</span><span class="token function">use</span><span class="token punctuation">(</span><span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter">request</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    <span class="token comment">/**
     * desc: 携带请求头
     * language 中文，英文
     * @params
     **/</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>setting<span class="token punctuation">.</span>language <span class="token operator">===</span> <span class="token string">"zh-CN"</span> <span class="token operator">||</span> setting<span class="token punctuation">.</span>language <span class="token operator">===</span> <span class="token string">"zh"</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        request<span class="token punctuation">.</span>headers<span class="token punctuation">[</span><span class="token string">"language"</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">"zh_CN"</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>setting<span class="token punctuation">.</span>language <span class="token operator">===</span> <span class="token string">"en_US"</span> <span class="token operator">||</span> setting<span class="token punctuation">.</span>language <span class="token operator">===</span> <span class="token string">"en"</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        request<span class="token punctuation">.</span>headers<span class="token punctuation">[</span><span class="token string">"language"</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">"en_US"</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> 
<p><img src="https://images2.imgbox.com/28/5e/3Y0CQ6U6_o.png" alt="在这里插入图片描述"></p> 
<h5><a id="1213__63"></a>1.2.1.3 请求数据</h5> 
<p>接口请求的主要数据</p> 
<p><img src="https://images2.imgbox.com/e5/0f/Ig0YUdoY_o.png" alt=""></p> 
<h4><a id="122__68"></a>1.2.2 服务器响应消息</h4> 
<p><mark>HTTP响应也由四个部分组成，分别是：状态行、响应头、空行和响应正文。</mark></p> 
<p><img src="https://images2.imgbox.com/d8/7b/IMgyaZ8c_o.png" alt="在这里插入图片描述"></p> 
<h3><a id="13_HTTP__75"></a>1.3 HTTP 请求方法</h3> 
<p>根据 HTTP 标准，HTTP 请求可以使用多种请求方法。</p> 
<p>HTTP1.0 定义了三种请求方法： GET, POST 和 HEAD方法。</p> 
<p>HTTP1.1 新增了六种请求方法：OPTIONS、PUT、PATCH、DELETE、TRACE 和 CONNECT 方法。</p> 
<h4><a id="131_POST__GET__82"></a>1.3.1 POST 与 GET 的区别</h4> 
<ol><li>Get是从服务器上获取数据，Post是向服务器传送数据。</li><li>Get是把参数数据队列加到提交表单的Action属性所指向的URL中，值和表单内各个字段一一对应，在URL中可以看到。</li><li>Get传送的数据量小，不能大于2KB；Post传送的数据量较大，一般被默认为不受限制。</li><li>根据HTTP规范，GET用于信息获取，而且应该是安全的和幂等的。</li></ol> 
<h3><a id="13_HTTP__88"></a>1.3 HTTP 状态码</h3> 
<p>当浏览器接收并显示网页前，此网页所在的服务器会返回一个包含HTTP状态码的信息头（server header）用以响应浏览器的请求。</p> 
<p>下面是常见的HTTP状态码：</p> 
<ul><li>200 - 请求成功</li><li>301 - 资源（网页等）被永久转移到其它URL</li><li>400 客户端请求的语法错误，服务器无法理解</li><li>404 - 请求的资源（网页等）不存在</li><li>500 - 内部服务器错误</li><li>502 作为网关或者代理工作的服务器尝试执行请求时，从远程服务器接收到了一个无效的响应</li></ul> 
<h2><a id="TCPIP_99"></a>二、TCP/IP学习</h2> 
<h3><a id="21_TCPIP__100"></a>2.1 TCP/IP 简介</h3> 
<p><mark>TCP/IP 是供已连接因特网的计算机进行通信的通信协议。</mark></p> 
<p>TCP/IP 指传输控制协议/网际协议</p> 
<p>TCP/IP 定义了电子设备（比如计算机）如何连入因特网，以及数据如何在它们之间传输的标准。</p> 
<p>计算机通信协议是对那些计算机必须遵守以便彼此通信的的规则的描述。</p> 
<h3><a id="22_TCPIP__109"></a>2.2 TCP/IP 协议</h3> 
<p>TCP/IP 是基于 TCP 和 IP 这两个最初的协议之上的不同的通信协议的大集合。</p> 
<h4><a id="221_TCP___112"></a>2.2.1 TCP - 传输控制协议</h4> 
<p>TCP 用于从应用程序到网络的数据传输控制。</p> 
<p>TCP 负责在数据传送之前将它们分割为 IP 包，然后在它们到达的时候将它们重组。</p> 
<h4><a id="222_IP__Internet_Protocol_117"></a>2.2.2 IP - 网际协议（Internet Protocol）</h4> 
<p>IP 负责计算机之间的通信。</p> 
<p>IP 负责在因特网上发送和接收数据包。</p> 
<h4><a id="223_HTTP__Hyper_Text_Transfer_Protocol_122"></a>2.2.3 HTTP - 超文本传输协议(Hyper Text Transfer Protocol)</h4> 
<p>HTTP 负责 web 服务器与 web 浏览器之间的通信。</p> 
<p>HTTP 用于从 web 客户端（浏览器）向 web 服务器发送请求，并从 web 服务器向 web 客户端返回内容（网页）。</p> 
<h4><a id="224_HTTPS__HTTP_Secure_127"></a>2.2.4 HTTPS - 超文本传输安全协议（HTTP Secure）</h4> 
<p>HTTPS 负责在 web 服务器和 web 浏览器之间的安全通信。</p> 
<p>HTTPS 经由 HTTP 进行通信，但利用 SSL/TLS 来加密数据包。HTTPS 开发的主要目的，是提供对网站服务器的身份认证，保护交换数据的隐私与完整性。</p> 
<h4><a id="225_SSL__Secure_Sockets_Layer_132"></a>2.2.5 SSL - 安全套接字层（Secure Sockets Layer）</h4> 
<p>SSL 协议用于为安全数据传输加密数据。</p> 
<h4><a id="226_SMTP__Simple_Mail_Transfer_Protocol_135"></a>2.2.6 SMTP - 简易邮件传输协议（Simple Mail Transfer Protocol）</h4> 
<p>SMTP 用于电子邮件的传输。</p> 
<h4><a id="227_MIME__Multipurpose_Internet_Mail_Extensions_138"></a>2.2.7 MIME - 多用途因特网邮件扩展（Multi-purpose Internet Mail Extensions）</h4> 
<p>MIME 协议使 SMTP 有能力通过 TCP/IP 网络传输多媒体文件，包括声音、视频和二进制数据。</p> 
<h4><a id="228_IMAP__Internet_Message_Access_Protocol_141"></a>2.2.8 IMAP - 因特网消息访问协议（Internet Message Access Protocol）</h4> 
<p>IMAP 用于存储和取回电子邮件。</p> 
<h4><a id="229_POP__Post_Office_Protocol_144"></a>2.2.9 POP - 邮局协议（Post Office Protocol）</h4> 
<p>POP 用于从电子邮件服务器向个人电脑下载电子邮件。</p> 
<h4><a id="2210_FTP__File_Transfer_Protocol_147"></a>2.2.10 FTP - 文件传输协议（File Transfer Protocol）</h4> 
<p>FTP 负责计算机之间的文件传输。</p> 
<h4><a id="2211_DHCP__Dynamic_Host_Configuration_Protocol_150"></a>2.2.11 DHCP - 动态主机配置协议（Dynamic Host Configuration Protocol）</h4> 
<p>DHCP 用于向网络中的计算机分配动态 IP 地址。</p> 
<h4><a id="2212_ARP__Address_Resolution_Protocol_153"></a>2.2.12 ARP - 地址解析协议（Address Resolution Protocol）</h4> 
<p>ARP - 用于通过 IP 来查找基于 IP 地址的计算机网卡的硬件地址。</p> 
<h4><a id="2213_RARP__Reverse_Address_Resolution_Protocol_156"></a>2.2.13 RARP - 反向地址转换协议（Reverse Address Resolution Protocol）</h4> 
<p>RARP 用于通过 IP 查找基于硬件地址的计算机网卡的 IP 地址。</p> 
<h3><a id="23_TCPIP__159"></a>2.3 TCP/IP 模型</h3> 
<p><img src="https://images2.imgbox.com/55/15/2SougpEF_o.png" alt="在这里插入图片描述"></p> 
<h3><a id="24_TCP_161"></a>2.4 TCP协议的三次握手和四次挥手</h3> 
<p><img src="https://images2.imgbox.com/da/78/oOVwFpUE_o.png" alt="在这里插入图片描述"></p> 
<ul><li><code>SEQ</code>："sequance"序列号；</li><li><code>ACK</code>："acknowledge"确认号；</li><li><code>SYN</code>："synchronize"请求同步标志；</li><li><code>ACK</code>：“acknowledge"确认标志”；</li><li><code>FIN</code>："Finally"结束标志</li></ul> 
<p><strong>TCP连接建立过程</strong>：</p> 
<ol><li>首先Client端<code>发送连接请求报文</code>，</li><li>Server段接受连接后<code>回复ACK报文</code>，并为这次连接分配资源。</li><li>Client端接收到ACK报文后也向Server段<code>发送ACK报文</code>，并分配资源，这样TCP连接就建立了。</li></ol> 
<p><strong>TCP连接断开过程</strong>：</p> 
<ol><li>Client端发起中断连接请求，<code>发送FIN报文</code>。</li><li>Server端接到FIN报文后，意思是说"我Client端没有数据要发给你了"，但是如果你还有数据没有发送完成，则不必急着关闭Socket，可以继续发送数据。所以你先<code>发送ACK</code>，“告诉Client端，你的请求我收到了，但是我还没准备好，请继续你等我的消息”。这个时候Client端就<code>进入FIN_WAIT状态</code>，继续等待Server端的FIN报文。</li><li>当Server端确定数据已发送完成，则向Client端<code>发送FIN报文</code>，“告诉Client端，好了，我这边数据发完了，准备好关闭连接了”。</li><li>Client端收到FIN报文后，“就知道可以关闭连接了，但是他还是不相信网络，怕Server端不知道要关闭，所以<code>发送ACK</code>后进入TIME_WAIT状态，如果Server端没有收到ACK则可以重传。”，Server端收到ACK后，“就知道可以断开连接了”。Client端等待了2MSL后依然没有收到回复，则证明Server端已正常关闭，那好，我Client端也可以关闭连接了。Ok，TCP连接就这样关闭了！</li></ol> 
<h4><a id="241__180"></a>2.4.1 为什么要三次握手？</h4> 
<p>在只有两次"握手"的情形下，假设Client想跟Server建立连接，但是却因为中途连接请求的数据报丢失了，故Client端不得不重新发送一遍；这个时候Server端仅收到一个连接请求，因此可以正常的建立连接。但是，有时候Client端重新发送请求不是因为数据报丢失了，而是有可能数据传输过程因为网络并发量很大在某结点被阻塞了，这种情形下Server端将先后收到2次请求，并持续等待两个Client请求向他发送数据…问题就在这里，Cient端实际上只有一次请求，而Server端却有2个响应，极端的情况可能由于Client端多次重新发送请求数据而导致Server端最后建立了N多个响应在等待，因而造成极大的资源浪费！所以，"三次握手"很有必要！</p> 
<h4><a id="242__183"></a>2.4.2 为什么要四次挥手？</h4> 
<p>试想一下，假如现在你是客户端你想断开跟Server的所有连接该怎么做？第一步，你自己先停止向Server端发送数据，并等待Server的回复。但事情还没有完，虽然你自身不往Server发送数据了，但是因为你们之前已经建立好平等的连接了，所以此时他也有主动权向你发送数据；故Server端还得终止主动向你发送数据，并等待你的确认。其实，说白了就是保证双方的一个合约的完整执行！</p> 
<p>使用TCP的协议：FTP（文件传输协议）、Telnet（远程登录协议）、SMTP（简单邮件传输协议）、POP3（和SMTP相对，用于接收邮件）、HTTP协议等。</p> 
<h2><a id="UDP_188"></a>三、UDP协议</h2> 
<p><mark>UDP用户数据报协议，是面向无连接的通讯协议，UDP数据包括目的端口号和源端口号信息，由于通讯不需要连接，所以可以实现广播发送。</mark></p> 
<p>UDP与TCP位于同一层，但它不管数据包的顺序、错误或重发。</p> 
<p>使用UDP协议包括：TFTP（简单文件传输协议）、SNMP（简单网络管理协议）、DNS（域名解析协议）、NFS、BOOTP。</p> 
<p><mark>TCP 与 UDP 的区别：TCP是面向连接的，可靠的字节流服务；UDP是面向无连接的，不可靠的数据报服务。</mark></p> 
<h2><a id="_197"></a>四、其他网络知识</h2> 
<h3><a id="41__199"></a>4.1 在浏览器上输入网址后的全部过程</h3> 
<ol><li>读取缓存： 搜索自身的 DNS 缓存。</li><li>DNS解析：客户端浏览器通过DNS解析到www.baidu.com的IP地址220.181.27.48，通过这个IP地址找到客户端到服务器的路径。</li><li>TCP 连接：客户端浏览器发起一个HTTP会话到220.161.27.48，然后通过TCP进行封装数据包，输入到网络层。</li><li>在客户端的传输层，把HTTP会话请求分成报文段，添加源和目的端口，如服务器使用80端口监听客户端的请求，客户端由系统随机选择一个端口如5000，与服务器进行交换，服务器把相应的请求返回给客户端的5000端口。然后使用IP层的IP地址查找目的端。</li><li>客户端的链路层，包通过链路层发送到路由器，通过邻居协议查找给定IP地址的MAC地址，然后发送ARP请求查找目的地址，如果得到回应后就可以使用ARP的请求应答交换的IP数据包现在就可以传输了，然后发送IP数据包到达服务器的地址。</li><li>浏览器解析渲染页面：根据 HTML 解析出 DOM 树、根据 CSS 解析生成 CSS 规则树、结合 DOM 树和 CSS 规则树，生成渲染树、根据渲染树计算每一个节点的信息、根据计算好的信息绘制页面</li><li>断开连接：TCP 四次挥手</li></ol> 
<h3><a id="42_HTTP__HTTPS__208"></a>4.2 HTTP 与 HTTPS 的区别</h3> 
<ol><li>HTTP 明文传输，数据都是未加密的，安全性较差，HTTPS（SSL+HTTP） 数据传输过程是加密的，安全性较好。</li><li>使用 HTTPS 协议需要到 CA（Certificate Authority，数字证书认证机构） 申请证书，一般免费证书较少，因而需要一定费用。</li><li>HTTP 页面响应速度比 HTTPS 快，主要是因为 HTTP 使用 TCP 三次握手建立连接，客户端和服务器需要交换 3 个包，而 HTTPS除了 TCP 的三个包，还要加上 ssl 握手需要的 9 个包，所以一共是 12 个包。</li><li>http 和 https 使用的是完全不同的连接方式，用的端口也不一样，前者是 80，后者是 443。</li><li>HTTPS 其实就是建构在 SSL/TLS 之上的 HTTP 协议，所以，要比较 HTTPS 比 HTTP 要更耗费服务器资源。</li></ol> 
<h3><a id="43__216"></a>4.3 什么是跨域</h3> 
<p><mark>跨域的本质就是网页页面所存在的服务器中的前端代码想要访问其他的域名所存在的服务器。</mark></p> 
<p>同源策略：就是两个页面具有相同的协议（protocol），主机（host）和端口号（port）。</p> 
<p><img src="https://images2.imgbox.com/40/1a/8GXTxEq8_o.png" alt="在这里插入图片描述"></p> 
<p>因为浏览器出于安全考虑，有同源策略。如果协议、域名或者端口有一个不同就是跨域，异步请求会失败。</p> 
<p>同源策略是为了防止 CSRF（跨站请求伪造）</p> 
<p>CSRF 攻击通过在授权用户访问的页面中包含链接或者脚本的方式工作。</p> 
<h4><a id="431__230"></a>4.3.1 跨域解决方法</h4> 
<h5><a id="4311_JSONP_231"></a>4.3.1.1 JSONP</h5> 
<p><mark>JSONP（填充式JSON)，应用JSON的一种新方法</mark></p> 
<p>JSON、JSONP的区别：</p> 
<ul><li>JSON返回的是一串数据、JSONP返回的是脚本代码（包含一个函数调用）</li><li>JSONP 只支持get请求、不支持post请求（类似往页面添加一个script标签，通过src属性去触发对指定地址的请求，故只能是Get请求）</li></ul> 
<p>JSONP 是服务器与客户端跨源通信的常用方法。最大特点就是简单适用，兼容性好（兼容低版本IE），<mark>缺点是只支持get请求，不支持post请求</mark></p> 
<p>核心思想：网页通过添加一个<code>&lt;script&gt;</code>元素，向服务器请求 JSON 数据，服务器收到请求后，将数据放在一个指定名字的回调函数的参数位置传回来</p> 
<pre><code class="prism language-javascript"><span class="token operator">&lt;</span>script src<span class="token operator">=</span><span class="token string">"http://test.com/data.php?callback=dosomething"</span><span class="token operator">&gt;</span><span class="token operator">&lt;</span><span class="token operator">/</span>script<span class="token operator">&gt;</span>
<span class="token comment">// 向服务器test.com发出请求，该请求的查询字符串有一个callback参数，用来指定回调函数的名字</span>
 
<span class="token comment">// 处理服务器返回回调函数的数据</span>
<span class="token operator">&lt;</span>script type<span class="token operator">=</span><span class="token string">"text/javascript"</span><span class="token operator">&gt;</span>
    <span class="token keyword">function</span> <span class="token function">dosomething</span><span class="token punctuation">(</span><span class="token parameter">res</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
        <span class="token comment">// 处理获得的数据</span>
        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>res<span class="token punctuation">.</span>data<span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
<span class="token operator">&lt;</span><span class="token operator">/</span>script<span class="token operator">&gt;</span>
</code></pre> 
<p>或者</p> 
<pre><code class="prism language-javascript"><span class="token comment">//原生的实现方式</span>
<span class="token keyword">let</span> script <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">createElement</span><span class="token punctuation">(</span><span class="token string">'script'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

script<span class="token punctuation">.</span>src <span class="token operator">=</span> <span class="token string">'http://www.nealyang.cn/login?username=Nealyang&amp;callback=callback'</span><span class="token punctuation">;</span>

document<span class="token punctuation">.</span>body<span class="token punctuation">.</span><span class="token function">appendChild</span><span class="token punctuation">(</span>script<span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token keyword">function</span> <span class="token function">callback</span><span class="token punctuation">(</span><span class="token parameter">res</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>res<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p><mark>json文件中的格式</mark></p> 
<pre><code class="prism language-javascript"><span class="token comment">// 回调函数 名称要与  文件中的名称一致</span>
<span class="token function">indexDemo</span><span class="token punctuation">(</span><span class="token punctuation">{<!-- --></span>
    <span class="token string-property property">"a"</span><span class="token operator">:</span><span class="token string">"lllll"</span><span class="token punctuation">,</span>
    <span class="token string-property property">"b"</span><span class="token operator">:</span><span class="token string">"2222"</span> 
     <span class="token punctuation">}</span><span class="token punctuation">)</span>
</code></pre> 
<h5><a id="4312_CORS__279"></a>4.3.1.2 CORS 跨域资源共享</h5> 
<p>CORS 是跨域资源共享（Cross-Origin Resource Sharing）的缩写。它是 W3C 标准，属于跨源 AJAX 请求的根本解决方法。</p> 
<p>CORS背后的思想，就是使用自定义的HTTP头部让浏览器与服务器进行沟通，从而决定请求或响应是应该成功，还是应该失败</p> 
<p><mark>整个CORS通信过程，都是浏览器自动完成，不需要用户参与。对于开发者来说，CORS通信与同源的AJAX通信没有差别，代码完全一样。浏览器一旦发现AJAX请求跨源，就会自动添加一些附加的头信息，有时还会多出一次附加的请求，但用户不会有感觉。 因此，实现CORS通信的关键是服务器。只要服务器实现了CORS接口，就可以跨源通信。</mark></p> 
<p>CORS与JSONP的使用目的相同，但是比JSONP更强大。JSONP只支持GET请求，CORS支持所有类型的HTTP请求。JSONP的优势在于支持老式浏览器，以及可以向不支持CORS的网站请求数据。</p> 
<p>两种请求：</p> 
<p>CORS分为两种请求，一种是简单请求，另一种是非简单请求。</p> 
<h6><a id="43121_CORS__293"></a>4.3.1.2.1 CORS 简单请求</h6> 
<p><mark>对于简单请求，浏览器直接发出CORS请求。具体来说，就是在头信息之中，增加一个Origin字段。 下面是一个例子，浏览器发现这次跨源AJAX请求是简单请求，就自动在头信息之中，添加一个Origin字段。</mark></p> 
<pre><code class="prism language-javascript"><span class="token constant">GET</span> <span class="token operator">/</span>cors <span class="token constant">HTTP</span><span class="token operator">/</span><span class="token number">1.1</span>
<span class="token literal-property property">Origin</span><span class="token operator">:</span> http<span class="token operator">:</span><span class="token operator">/</span><span class="token operator">/</span>api<span class="token punctuation">.</span>bob<span class="token punctuation">.</span>com
<span class="token literal-property property">Host</span><span class="token operator">:</span> api<span class="token punctuation">.</span>alice<span class="token punctuation">.</span>com
Accept<span class="token operator">-</span>Language<span class="token operator">:</span> en<span class="token operator">-</span><span class="token constant">US</span>
<span class="token literal-property property">Connection</span><span class="token operator">:</span> keep<span class="token operator">-</span>alive
User<span class="token operator">-</span>Agent<span class="token operator">:</span> Mozilla<span class="token operator">/</span><span class="token number">5.0</span>
<span class="token operator">...</span>
</code></pre> 
<p>Origin字段用来说明，本次请求来自哪个源（协议 + 域名 + 端口）。服务器根据这个值，决定是否同意这次请求。</p> 
<p>如果Origin指定的源，不在许可范围内，服务器会返回一个正常的HTTP回应。 浏览器发现，这个回应的头信息没有包含Access-Control-Allow-Origin字段（详见下文），就知道出错了，从而抛出一个错误，被XMLHttpRequest的onerror回调函数捕获。</p> 
<p>如果Origin指定的域名在许可范围内，服务器返回的响应，会多出几个头信息字段。</p> 
<pre><code class="prism language-javascript"> Access<span class="token operator">-</span>Control<span class="token operator">-</span>Allow<span class="token operator">-</span>Origin<span class="token operator">:</span> http<span class="token operator">:</span><span class="token operator">/</span><span class="token operator">/</span>api<span class="token punctuation">.</span>bob<span class="token punctuation">.</span>com
   Access<span class="token operator">-</span>Control<span class="token operator">-</span>Allow<span class="token operator">-</span>Credentials<span class="token operator">:</span> <span class="token boolean">true</span>
   Access<span class="token operator">-</span>Control<span class="token operator">-</span>Expose<span class="token operator">-</span>Headers<span class="token operator">:</span> FooBar
   Content<span class="token operator">-</span>Type<span class="token operator">:</span> text<span class="token operator">/</span>html<span class="token punctuation">;</span> charset<span class="token operator">=</span>utf<span class="token operator">-</span><span class="token number">8</span>
</code></pre> 
<ul><li>Access-Control-Allow-Origin :该字段是必须的。它的值要么是请求时Origin字段的值，要么是一个*，表示接受任意域名的请求</li><li>Access-Control-Allow-Credentials: 该字段可选。它的值是一个布尔值，表示是否允许发送Cookie。默认情况下，Cookie不包括在CORS请求之中。设为true，即表示服务器明确许可，Cookie可以包含在请求中，一起发给服务器。这个值也只能设为true，如果服务器不要浏览器发送Cookie，删除该字段即可。</li><li>Access-Control-Expose-Headers:该字段可选。CORS请求时，XMLHttpRequest对象的getResponseHeader()方法只能拿到6个基本字段：Cache-Control、Content-Language、Content-Type、Expires、Last-Modified、Pragma。如果想拿到其他字段，就必须在Access-Control-Expose-Headers里面指定。</li></ul> 
<h6><a id="43122_CORS__321"></a>4.3.1.2.2 CORS 非简单请求</h6> 
<p><mark>非简单请求是那种对服务器有特殊要求的请求，比如请求方法是PUT或DELETE，或者Content-Type字段的类型是application/json。</mark></p> 
<p>非简单请求的CORS请求，会在正式通信之前，增加一次HTTP查询请求，称为"预检"请求（preflight）。</p> 
<p>浏览器先询问服务器，当前网页所在的域名是否在服务器的许可名单之中，以及可以使用哪些HTTP动词和头信息字段。只有得到肯定答复，浏览器才会发出正式的XMLHttpRequest请求，否则就报错。</p> 
<p>浏览器发现，这是一个非简单请求，就自动发出一个"预检"请求，要求服务器确认可以这样请求。下面是这个"预检"请求的HTTP头信息。</p> 
<pre><code class="prism language-javascript"><span class="token constant">OPTIONS</span> <span class="token operator">/</span>cors <span class="token constant">HTTP</span><span class="token operator">/</span><span class="token number">1.1</span>
   <span class="token literal-property property">Origin</span><span class="token operator">:</span> http<span class="token operator">:</span><span class="token operator">/</span><span class="token operator">/</span>api<span class="token punctuation">.</span>bob<span class="token punctuation">.</span>com
   Access<span class="token operator">-</span>Control<span class="token operator">-</span>Request<span class="token operator">-</span>Method<span class="token operator">:</span> <span class="token constant">PUT</span>
   Access<span class="token operator">-</span>Control<span class="token operator">-</span>Request<span class="token operator">-</span>Headers<span class="token operator">:</span> <span class="token constant">X</span><span class="token operator">-</span>Custom<span class="token operator">-</span>Header
   <span class="token literal-property property">Host</span><span class="token operator">:</span> api<span class="token punctuation">.</span>alice<span class="token punctuation">.</span>com
   Accept<span class="token operator">-</span>Language<span class="token operator">:</span> en<span class="token operator">-</span><span class="token constant">US</span>
   <span class="token literal-property property">Connection</span><span class="token operator">:</span> keep<span class="token operator">-</span>alive
   User<span class="token operator">-</span>Agent<span class="token operator">:</span> Mozilla<span class="token operator">/</span><span class="token number">5.0</span><span class="token operator">...</span>
</code></pre> 
<p>"预检"请求用的请求方法是OPTIONS，表示这个请求是用来询问的。头信息里面，关键字段是Origin，表示请求来自哪个源。</p> 
<p>除了Origin字段，"预检"请求的头信息包括两个特殊字段。</p> 
<ul><li>Access-Control-Request-Method：该字段是必须的，用来列出浏览器的CORS请求会用到哪些HTTP方法，上例是PUT。</li><li>Access-Control-Request-Headers：该字段是一个逗号分隔的字符串，指定浏览器CORS请求会额外发送的头信息字段，上例是X-Custom-Header</li></ul> 
<p>预检请求的回应</p> 
<p>服务器收到"预检"请求以后，检查了Origin、Access-Control-Request-Method和Access-Control-Request-Headers字段以后，确认允许跨源请求，就可以做出回应</p> 
<pre><code class="prism language-javascript"><span class="token constant">HTTP</span><span class="token operator">/</span><span class="token number">1.1</span> <span class="token number">200</span> <span class="token constant">OK</span>
<span class="token literal-property property">Date</span><span class="token operator">:</span> Mon<span class="token punctuation">,</span> <span class="token number">01</span> Dec <span class="token number">2008</span> <span class="token number">01</span><span class="token operator">:</span><span class="token number">15</span><span class="token operator">:</span><span class="token number">39</span> <span class="token constant">GMT</span>
<span class="token literal-property property">Server</span><span class="token operator">:</span> Apache<span class="token operator">/</span><span class="token number">2.0</span><span class="token number">.61</span> <span class="token punctuation">(</span>Unix<span class="token punctuation">)</span>
Access<span class="token operator">-</span>Control<span class="token operator">-</span>Allow<span class="token operator">-</span>Origin<span class="token operator">:</span> http<span class="token operator">:</span><span class="token operator">/</span><span class="token operator">/</span>api<span class="token punctuation">.</span>bob<span class="token punctuation">.</span>com
Access<span class="token operator">-</span>Control<span class="token operator">-</span>Allow<span class="token operator">-</span>Methods<span class="token operator">:</span> <span class="token constant">GET</span><span class="token punctuation">,</span> <span class="token constant">POST</span><span class="token punctuation">,</span> <span class="token constant">PUT</span>
Access<span class="token operator">-</span>Control<span class="token operator">-</span>Allow<span class="token operator">-</span>Headers<span class="token operator">:</span> <span class="token constant">X</span><span class="token operator">-</span>Custom<span class="token operator">-</span>Header
Content<span class="token operator">-</span>Type<span class="token operator">:</span> text<span class="token operator">/</span>html<span class="token punctuation">;</span> charset<span class="token operator">=</span>utf<span class="token operator">-</span><span class="token number">8</span>
Content<span class="token operator">-</span>Encoding<span class="token operator">:</span> gzip
Content<span class="token operator">-</span>Length<span class="token operator">:</span> <span class="token number">0</span>
Keep<span class="token operator">-</span>Alive<span class="token operator">:</span> timeout<span class="token operator">=</span><span class="token number">2</span><span class="token punctuation">,</span> max<span class="token operator">=</span><span class="token number">100</span>
<span class="token literal-property property">Connection</span><span class="token operator">:</span> Keep<span class="token operator">-</span>Alive
Content<span class="token operator">-</span>Type<span class="token operator">:</span> text<span class="token operator">/</span>plain
</code></pre> 
<p>上面的HTTP回应中，关键的是Access-Control-Allow-Origin字段，表示http://api.bob.com可以请求数据。该字段也可以设为星号，表示同意任意跨源请求。</p> 
<p>如果浏览器否定了"预检"请求，会返回一个正常的HTTP回应，但是没有任何CORS相关的头信息字段。这时，浏览器就会认定，服务器不同意预检请求，因此触发一个错误，被XMLHttpRequest对象的onerror回调函数捕获。控制台会打印出如下的报错信息。</p> 
<p>服务器回应的其他CORS相关字段如下：</p> 
<pre><code class="prism language-javascript">Access<span class="token operator">-</span>Control<span class="token operator">-</span>Allow<span class="token operator">-</span>Methods<span class="token operator">:</span> <span class="token constant">GET</span><span class="token punctuation">,</span> <span class="token constant">POST</span><span class="token punctuation">,</span> <span class="token constant">PUT</span>
Access<span class="token operator">-</span>Control<span class="token operator">-</span>Allow<span class="token operator">-</span>Headers<span class="token operator">:</span> <span class="token constant">X</span><span class="token operator">-</span>Custom<span class="token operator">-</span>Header
Access<span class="token operator">-</span>Control<span class="token operator">-</span>Allow<span class="token operator">-</span>Credentials<span class="token operator">:</span> <span class="token boolean">true</span>
Access<span class="token operator">-</span>Control<span class="token operator">-</span>Max<span class="token operator">-</span>Age<span class="token operator">:</span> <span class="token number">1728000</span>
</code></pre> 
<ul><li>Access-Control-Allow-Methods：该字段必需，它的值是逗号分隔的一个字符串，表明服务器支持的所有跨域请求的方法。注意，返回的是所有支持的方法，而不单是浏览器请求的那个方法。这是为了避免多次"预检"请求。</li><li>Access-Control-Allow-Headers：如果浏览器请求包括Access-Control-Request-Headers字段，则Access-Control-Allow-Headers字段是必需的。它也是一个逗号分隔的字符串，表明服务器支持的所有头信息字段，不限于浏览器在"预检"中请求的字段。</li><li>Access-Control-Allow-Credentials： 该字段与简单请求时的含义相同。</li><li>Access-Control-Max-Age： 该字段可选，用来指定本次预检请求的有效期，单位为秒。上面结果中，有效期是20天（1728000秒），即允许缓存该条回应1728000秒（即20天），在此期间，不用发出另一条预检请求。</li></ul> 
<p>浏览器正常请求回应</p> 
<p>一旦服务器通过了"预检"请求，以后每次浏览器正常的CORS请求，就都跟简单请求一样，会有一个Origin头信息字段。服务器的回应，也都会有一个Access-Control-Allow-Origin头信息字段。</p> 
<pre><code class="prism language-javascript"><span class="token constant">PUT</span> <span class="token operator">/</span>cors <span class="token constant">HTTP</span><span class="token operator">/</span><span class="token number">1.1</span>
<span class="token literal-property property">Origin</span><span class="token operator">:</span> http<span class="token operator">:</span><span class="token operator">/</span><span class="token operator">/</span>api<span class="token punctuation">.</span>bob<span class="token punctuation">.</span>com
<span class="token literal-property property">Host</span><span class="token operator">:</span> api<span class="token punctuation">.</span>alice<span class="token punctuation">.</span>com
<span class="token constant">X</span><span class="token operator">-</span>Custom<span class="token operator">-</span>Header<span class="token operator">:</span> value
Accept<span class="token operator">-</span>Language<span class="token operator">:</span> en<span class="token operator">-</span><span class="token constant">US</span>
<span class="token literal-property property">Connection</span><span class="token operator">:</span> keep<span class="token operator">-</span>alive
User<span class="token operator">-</span>Agent<span class="token operator">:</span> Mozilla<span class="token operator">/</span><span class="token number">5.0</span><span class="token operator">...</span>
</code></pre> 
<p>浏览器的正常CORS请求。上面头信息的Origin字段是浏览器自动添加的。下面是服务器正常的回应。</p> 
<pre><code class="prism language-javascript">Access<span class="token operator">-</span>Control<span class="token operator">-</span>Allow<span class="token operator">-</span>Origin<span class="token operator">:</span> http<span class="token operator">:</span><span class="token operator">/</span><span class="token operator">/</span>api<span class="token punctuation">.</span>bob<span class="token punctuation">.</span>com
Content<span class="token operator">-</span>Type<span class="token operator">:</span> text<span class="token operator">/</span>html<span class="token punctuation">;</span> charset<span class="token operator">=</span>utf<span class="token operator">-</span><span class="token number">8</span>
</code></pre> 
<p>Access-Control-Allow-Origin字段是每次回应都必定包含的</p> 
<h5><a id="4313_node_405"></a>4.3.1.3 node代理跨域</h5> 
<p><mark>node中间件实现跨域代理，是通过启一个代理服务器，实现数据的转发，也可以通过设置cookieDomainRewrite参数修改响应头中cookie中域名，实现当前域的cookie写入，方便接口登录认证。</mark></p> 
<pre><code class="prism language-javascript"><span class="token keyword">var</span> express <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'express'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">var</span> proxy <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'http-proxy-middleware'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">var</span> app <span class="token operator">=</span> <span class="token function">express</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

app<span class="token punctuation">.</span><span class="token function">use</span><span class="token punctuation">(</span><span class="token string">'/'</span><span class="token punctuation">,</span> <span class="token function">proxy</span><span class="token punctuation">(</span><span class="token punctuation">{<!-- --></span>
    <span class="token comment">// 代理跨域目标接口</span>
    <span class="token literal-property property">target</span><span class="token operator">:</span> <span class="token string">'http://www.domain2.com:8080'</span><span class="token punctuation">,</span>
    <span class="token literal-property property">changeOrigin</span><span class="token operator">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span>

    <span class="token comment">// 修改响应头信息，实现跨域并允许带cookie</span>
    <span class="token function-variable function">onProxyRes</span><span class="token operator">:</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">proxyRes<span class="token punctuation">,</span> req<span class="token punctuation">,</span> res</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        res<span class="token punctuation">.</span><span class="token function">header</span><span class="token punctuation">(</span><span class="token string">'Access-Control-Allow-Origin'</span><span class="token punctuation">,</span> <span class="token string">'http://www.domain1.com'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        res<span class="token punctuation">.</span><span class="token function">header</span><span class="token punctuation">(</span><span class="token string">'Access-Control-Allow-Credentials'</span><span class="token punctuation">,</span> <span class="token string">'true'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span><span class="token punctuation">,</span>

    <span class="token comment">// 修改响应信息中的cookie域名</span>
    <span class="token literal-property property">cookieDomainRewrite</span><span class="token operator">:</span> <span class="token string">'www.domain1.com'</span>  <span class="token comment">// 可以为false，表示不修改</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

app<span class="token punctuation">.</span><span class="token function">listen</span><span class="token punctuation">(</span><span class="token number">3000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'Proxy server is listen at port 3000...'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> 
<h5><a id="4314_nginx_433"></a>4.3.1.4 nginx代理跨域</h5> 
<h6><a id="43141_nginxiconfont_435"></a>4.3.1.4.1 nginx配置解决iconfont跨域</h6> 
<p>浏览器跨域访问js、css、img等常规静态资源被同源策略许可，但iconfont字体文件(eot|otf|ttf|woff|svg)例外，此时可在nginx的静态资源服务器中加入以下配置。</p> 
<pre><code class="prism language-javascript">location <span class="token operator">/</span> <span class="token punctuation">{<!-- --></span>
  add_header Access<span class="token operator">-</span>Control<span class="token operator">-</span>Allow<span class="token operator">-</span>Origin <span class="token operator">*</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<h6><a id="43142_nginx_444"></a>4.3.1.4.2 nginx反向代理接口跨域</h6> 
<p>跨域原理： 同源策略是浏览器的安全策略，不是HTTP协议的一部分。服务器端调用HTTP接口只是使用HTTP协议，不会执行JS脚本，不需要同源策略，也就不存在跨越问题。</p> 
<p>实现思路：通过nginx配置一个代理服务器（域名与domain1相同，端口不同）做跳板机，反向代理访问domain2接口，并且可以顺便修改cookie中domain信息，方便当前域cookie写入，实现跨域登录。</p> 
<p>nginx具体配置：</p> 
<pre><code class="prism language-javascript">#proxy服务器
server <span class="token punctuation">{<!-- --></span>
    listen       <span class="token number">81</span><span class="token punctuation">;</span>
    server_name  www<span class="token punctuation">.</span>domain1<span class="token punctuation">.</span>com<span class="token punctuation">;</span>

    location <span class="token operator">/</span> <span class="token punctuation">{<!-- --></span>
        proxy_pass   http<span class="token operator">:</span><span class="token operator">/</span><span class="token operator">/</span>www<span class="token punctuation">.</span>domain2<span class="token punctuation">.</span>com<span class="token operator">:</span><span class="token number">8080</span><span class="token punctuation">;</span>  #反向代理
        proxy_cookie_domain www<span class="token punctuation">.</span>domain2<span class="token punctuation">.</span>com www<span class="token punctuation">.</span>domain1<span class="token punctuation">.</span>com<span class="token punctuation">;</span> #修改cookie里域名
        index  index<span class="token punctuation">.</span>html index<span class="token punctuation">.</span>htm<span class="token punctuation">;</span>

        # 当用webpack<span class="token operator">-</span>dev<span class="token operator">-</span>server等中间件代理接口访问nignx时，此时无浏览器参与，故没有同源限制，下面的跨域配置可不启用
        add_header Access<span class="token operator">-</span>Control<span class="token operator">-</span>Allow<span class="token operator">-</span>Origin http<span class="token operator">:</span><span class="token operator">/</span><span class="token operator">/</span>www<span class="token punctuation">.</span>domain1<span class="token punctuation">.</span>com<span class="token punctuation">;</span>  #当前端只跨域不带cookie时，可为<span class="token operator">*</span>
        add_header Access<span class="token operator">-</span>Control<span class="token operator">-</span>Allow<span class="token operator">-</span>Credentials <span class="token boolean">true</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>1.) 前端代码示例：</p> 
<pre><code class="prism language-javascript"><span class="token keyword">var</span> xhr <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">XMLHttpRequest</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">// 前端开关：浏览器是否读写cookie</span>
xhr<span class="token punctuation">.</span>withCredentials <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>

<span class="token comment">// 访问nginx中的代理服务器</span>
xhr<span class="token punctuation">.</span><span class="token function">open</span><span class="token punctuation">(</span><span class="token string">'get'</span><span class="token punctuation">,</span> <span class="token string">'http://www.domain1.com:81/?user=admin'</span><span class="token punctuation">,</span> <span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
xhr<span class="token punctuation">.</span><span class="token function">send</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> 
<p>2.) Nodejs后台示例：</p> 
<pre><code class="prism language-javascript"><span class="token keyword">var</span> http <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'http'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">var</span> server <span class="token operator">=</span> http<span class="token punctuation">.</span><span class="token function">createServer</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">var</span> qs <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'querystring'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

server<span class="token punctuation">.</span><span class="token function">on</span><span class="token punctuation">(</span><span class="token string">'request'</span><span class="token punctuation">,</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">req<span class="token punctuation">,</span> res</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    <span class="token keyword">var</span> params <span class="token operator">=</span> qs<span class="token punctuation">.</span><span class="token function">parse</span><span class="token punctuation">(</span>req<span class="token punctuation">.</span>url<span class="token punctuation">.</span><span class="token function">substring</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token comment">// 向前台写cookie</span>
    res<span class="token punctuation">.</span><span class="token function">writeHead</span><span class="token punctuation">(</span><span class="token number">200</span><span class="token punctuation">,</span> <span class="token punctuation">{<!-- --></span>
        <span class="token string-property property">'Set-Cookie'</span><span class="token operator">:</span> <span class="token string">'l=a123456;Path=/;Domain=www.domain2.com;HttpOnly'</span>   <span class="token comment">// HttpOnly:脚本无法读取</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    res<span class="token punctuation">.</span><span class="token function">write</span><span class="token punctuation">(</span><span class="token constant">JSON</span><span class="token punctuation">.</span><span class="token function">stringify</span><span class="token punctuation">(</span>params<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    res<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

server<span class="token punctuation">.</span><span class="token function">listen</span><span class="token punctuation">(</span><span class="token string">'8080'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'Server is running at port 8080...'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> 
<h3><a id="44_SessionStoragelocalStoragecookie_502"></a>4.4 SessionStorage、localStorage和cookie的区别</h3> 
<ol><li>Cookie、localStorage、sessionStorage数据存放在客户端，Session数据放在服务器端</li><li>单个Cookie保存的数据不能超过4K，localStorage存放数据大小一般为5MB</li><li>HTTP请求时会携带cookie，localStorage和sessionStorage不会被携带</li><li>localStorage生命周期是永久的，除非被清除，否则永久保存，而sessionStorage仅在当前会话下有效，关闭页面或浏览器后被清除</li></ol> 
<h3><a id="45__509"></a>4.5 前端性能优化方案</h3> 
<p>从三个方面来说一下前端优化</p> 
<p>一、webapck优化与开启gzip压缩</p> 
<ol><li>babel-loader用 include 或 exclude 来帮我们避免不必要的转译，不转译node_moudules中的js文件。其次在缓存当前转译的js文件。</li><li>文件采用按需加载</li><li>gzip压缩</li><li>图片优化，采用svg图片或者字体图标</li><li>浏览器缓存机制</li></ol> 
<p>二、本地存储</p> 
<ol start="6"><li>SessionStorage</li><li>localStorage</li><li>cookie</li></ol> 
<p>三、代码优化</p> 
<ol><li>事件的节流和防抖</li><li>页面的回流和重绘</li><li>EventLoop事件循环机制</li><li>代码优化等等</li></ol> 
<h2><a id="OSI_533"></a>五、OSI七层模型</h2> 
<p>一般叫做<code>OSI(Open System Interconnection) 模型</code>或者叫<code>七层模型</code>.他是国际标准化(ISO)定的一个<code>用于计算机或通信系统间互联的标准体系.</code>协议将计算机网络体系结构划分为<code>7层</code>.</p> 
<p><img src="https://images2.imgbox.com/ff/1d/glO1dNB7_o.png" alt="在这里插入图片描述"></p> 
<h3><a id="51__537"></a>5.1 各层定义</h3> 
<ul><li> <p><code>应用层</code><br> OSI参考模型中最靠近用户的一层，是为计算机用户提供应用接口，也为用户直接提供各种网络服务。我们常见应用层的网络服务协议有：HTTP，HTTPS，FTP，POP3、SMTP等。</p> </li><li> <p><code>表示层</code><br> 表示层提供各种用于应用层数据的编码和转换功能,确保一个系统的应用层发送的数据能被另一个系统的应用层识别。如果必要，该层可提供一种标准表示形式，用于将计算机内部的多种数据格式转换成通信中采用的标准表示形式。数据压缩和加密也是表示层可提供的转换功能之一。</p> </li><li> <p><code>会话层</code><br> 会话层就是负责<code>建立、管理和终止表示层实体之间的通信会话</code>。该层的通信由不同设备中的应用程序之间的服务请求和响应组成。</p> </li><li> <p><code>传输层</code><br> 传输层<code>建立了主机端到端的链接</code>，传输层的作用是为上层协议提供端到端的可靠和透明的数据传输服务，包括处理差错控制和流量控制等问题。该层向高层屏蔽了下层数据通信的细节，使高层用户看到的只是在两个传输实体间的一条主机到主机的、可由用户控制和设定的、可靠的数据通路。我们通常说的，TCP UDP就是在这一层。端口号既是这里的“端”。</p> </li><li> <p><code>网络层</code><br> 本层<code>通过IP寻址来建立两个节点之间的连接，为源端的运输层送来的分组，选择合适的路由和交换节点</code>，正确无误地按照地址传送给目的端的运输层。就是通常说的IP层。这一层就是我们经常说的IP协议层。IP协议是Internet的基础。</p> </li><li> <p><code>数据链路层</code><br> 将比特组合成字节,再将字节组合成<code>帧</code>,使用链路层地址 (以太网使用MAC地址)来访问介质,并进行<code>差错检测</code>。<br> 数据链路层又分为2个子层：逻辑链路控制子层（LLC）和媒体访问控制子层（MAC）。<br> MAC子层处理CSMA/CD算法、数据出错校验、成帧等；LLC子层定义了一些字段使上次协议能共享数据链路层。 在实际使用中，LLC子层并非必需的。</p> </li><li> <p><code>物理层</code><br> 实际最终信号的传输是通过物理层实现的。<code>通过物理介质传输比特流</code>。规定了电平、速度和电缆针脚。常用设备有（各种物理设备）集线器、中继器、调制解调器、网线、双绞线、同轴电缆。这些都是物理层的传输介质。</p> </li></ul> 
<h2><a id="WebSocket_561"></a>六、WebSocket</h2> 
<p><code>WebSocket</code>是一种浏览器与服务器进行<code>全双工通讯</code>的网络技术，属于<code>应用层协议</code>。它基于TCP传输协议，并复用HTTP的握手通道。</p> 
<p>最大特点就是，服务器可以主动向客户端推送信息，客户端也可以主动向服务器发送信息</p> 
<ol><li>支持双向通信，实时性更强。</li><li>可以发送文本，也可以发送二进制数据。</li><li>数据格式比较轻量，性能开销小，通信高效。</li><li>没有同源限制，客户端可以与任意服务器通信。</li><li>建立在 TCP 协议之上，服务器端的实现比较容易。</li><li>与 HTTP 协议有着良好的兼容性。默认端口也是80和443，并且握手阶段采用 HTTP 协议，因此握手时不容易屏蔽，能通过各种 HTTP 代理服务器。</li><li>协议标识符是ws（如果加密，则为wss），服务器网址就是 URL。</li></ol> 
<h3><a id="61_WebSocket__HTTP__574"></a>6.1 WebSocket 与 HTTP 的区别</h3> 
<p>相同点： 都是一样基于TCP的，都是可靠性传输协议。都是应用层协议。</p> 
<p>联系： <code>WebSocket</code>在建立握手时，数据是通过<code>HTTP</code>传输的。但是建立之后，在真正传输时候是不需要HTTP协议的。</p> 
<p><img src="https://images2.imgbox.com/2e/d7/2Cnq97Io_o.png" alt="在这里插入图片描述"></p> 
<h3><a id="62_WebSocket_580"></a>6.2 WebSocket连接的过程</h3> 
<ol><li> <p>首先，客户端发起http请求，经过3次握手后，建立起TCP连接；http请求里存放WebSocket支持的版本号等信息，如：Upgrade、Connection、WebSocket-Version等；</p> <pre><code class="prism language-bash">GET /chat HTTP/1.1
Host: server.example.com
Upgrade: websocket
Connection: Upgrade
Sec-WebSocket-Key: <span class="token assign-left variable">x3JJHMbDL1EzLkh9GBhXDw</span><span class="token operator">==</span>
Sec-WebSocket-Protocol: chat, superchat
Sec-WebSocket-Version: <span class="token number">13</span>
Origin: http://example.com
</code></pre> </li><li> <p>然后，服务器收到客户端的握手请求后，同样采用HTTP协议回馈数据；</p> <pre><code class="prism language-bash">HTTP/1.1 <span class="token number">101</span> Switching Protocols
Upgrade: websocket
Connection: Upgrade
Sec-WebSocket-Accept: <span class="token assign-left variable">HSmrc0sMlYUkAGmm5OPpG2HaGWk</span><span class="token operator">=</span>
Sec-WebSocket-Protocol: chat
</code></pre> </li><li> <p>最后，客户端收到连接成功的消息后，开始借助于TCP传输信道进行全双工通信。</p> </li></ol> 
<h3><a id="63_Websocket__604"></a>6.3 Websocket 优缺点</h3> 
<p>优点：</p> 
<ul><li>WebSocket协议一旦建议后，互相沟通所消耗的请求头是很小的</li><li>服务器可以向客户端推送消息了</li></ul> 
<p>缺点：</p> 
<ul><li>少部分浏览器不支持，浏览器支持的程度与方式有区别（IE10）</li></ul> 
<h3><a id="64_Websocket__612"></a>6.4 Websocket 断线重连</h3> 
<p><code>心跳</code>就是客户端定时的给服务端发送消息，证明客户端是在线的， 如果超过一定的时间没有发送则就是离线了。</p> 
<p>1.判断是否离线</p> 
<ul><li>当客户端第一次发送请求至服务端时会携带唯一标识、以及时间戳，服务端到db或者缓存去查询改请求的唯一标识，如果不存在就存入db或者缓存中，</li><li>第二次客户端定时再次发送请求依旧携带唯一标识、以及时间戳，服务端到db或者缓存去查询改请求的唯一标识，如果存在就把上次的时间戳拿取出来，使用当前时间戳减去上次的时间，</li><li>得出的毫秒秒数判断是否大于指定的时间，若小于的话就是在线，否则就是离线；</li></ul> 
<p>2.解决断线问题</p> 
<ul><li>修改nginx配置信息</li><li>websocket发送心跳包</li></ul> 
<p>心跳检测步骤：</p> 
<ul><li>客户端每隔一个时间间隔发生一个探测包给服务器</li><li>客户端发包时启动一个超时定时器</li><li>服务器端接收到检测包，应该回应一个包</li><li>如果客户机收到服务器的应答包，则说明服务器正常，删除超时定时器</li><li>如果客户端的超时定时器超时，依然没有收到应答包，则说明服务器挂了</li></ul> 
<h3><a id="65_WebSocket_631"></a>6.5 WebSocket应用场景</h3> 
<ul><li>在线协同编辑/编辑</li><li>实时数据流的拉取与推送</li><li>体育/游戏实况</li><li>实时地图位置</li><li>即时Web应用程序： 例如在交易网站，它用于显示价格波动，数据被后端服务器使用Web套接字通道连续推送到客户端。</li><li>游戏应用程序：屏幕上的用户界面会自动刷新，而且不需要建立新的连接，因此在WebSocket游戏应用程序中非常有帮助。</li><li>聊天应用程序：聊天应用程序仅使用WebSocket建立一次连接，便能在订阅户之间交换，发布和广播消息。它重复使用相同的WebSocket连接，用于发送和接收消息以及一对一的消息传输。</li></ul> 
<h3><a id="66_demo_640"></a>6.6 demo实现</h3> 
<p>用 ws 搭建起来的服务端</p> 
<pre><code class="prism language-js"><span class="token keyword">const</span> <span class="token punctuation">{<!-- --></span> WebSocketServer <span class="token punctuation">}</span> <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'ws'</span><span class="token punctuation">)</span>
<span class="token keyword">const</span> wss <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">WebSocketServer</span><span class="token punctuation">(</span><span class="token punctuation">{<!-- --></span>
    <span class="token literal-property property">port</span><span class="token operator">:</span> <span class="token number">7070</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
wss<span class="token punctuation">.</span><span class="token function">on</span><span class="token punctuation">(</span><span class="token string">'connection'</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token parameter">ws<span class="token punctuation">,</span> req</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{<!-- --></span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'客户端已连接：'</span><span class="token punctuation">,</span> req<span class="token punctuation">.</span>socket<span class="token punctuation">.</span>remoteAddress<span class="token punctuation">)</span>
    ws<span class="token punctuation">.</span><span class="token function">on</span><span class="token punctuation">(</span><span class="token string">'message'</span><span class="token punctuation">,</span> <span class="token parameter">data</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{<!-- --></span>
        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'收到客户端发送的消息：'</span><span class="token punctuation">,</span> data<span class="token punctuation">)</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span>
    <span class="token function">setInterval</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">=&gt;</span><span class="token punctuation">{<!-- --></span>
        ws<span class="token punctuation">.</span><span class="token function">send</span><span class="token punctuation">(</span><span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">我是服务端</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${<!-- --></span>Math<span class="token punctuation">.</span><span class="token function">random</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token interpolation-punctuation punctuation">}</span></span><span class="token template-punctuation string">`</span></span><span class="token punctuation">)</span> <span class="token comment">// 向当前客户端发送消息</span>
    <span class="token punctuation">}</span><span class="token punctuation">,</span><span class="token number">1000</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
</code></pre> 
<p>react前端通过<code>new WebSocket('ws://localhost:7070')</code>开启连接</p> 
<ul><li>WebSocket.send() 发送会话</li><li>WebSocket.close() 关闭会话</li><li>WebSocket.onmessage() 接受会话</li></ul> 
<pre><code class="prism language-js">  <span class="token keyword">const</span> webSocketInit <span class="token operator">=</span> <span class="token function">useCallback</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{<!-- --></span>
    <span class="token keyword">const</span> stateArr <span class="token operator">=</span> <span class="token punctuation">[</span>
      <span class="token string">'正在链接中'</span><span class="token punctuation">,</span>
      <span class="token string">'已经链接并且可以通讯'</span><span class="token punctuation">,</span>
      <span class="token string">'连接正在关闭'</span><span class="token punctuation">,</span>
      <span class="token string">'连接已关闭或者没有链接成功'</span><span class="token punctuation">,</span>
    <span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>ws<span class="token punctuation">.</span>current <span class="token operator">||</span> ws<span class="token punctuation">.</span>current<span class="token punctuation">.</span>readyState <span class="token operator">===</span> <span class="token number">3</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
      ws<span class="token punctuation">.</span>current <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">WebSocket</span><span class="token punctuation">(</span><span class="token string">'ws://localhost:7070'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
      ws<span class="token punctuation">.</span>current<span class="token punctuation">.</span><span class="token function-variable function">onopen</span> <span class="token operator">=</span> <span class="token parameter">_e</span> <span class="token operator">=&gt;</span>
          <span class="token function">setReadyState</span><span class="token punctuation">(</span>stateArr<span class="token punctuation">[</span>ws<span class="token punctuation">.</span>current<span class="token operator">?.</span>readyState <span class="token operator">??</span> <span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
      ws<span class="token punctuation">.</span>current<span class="token punctuation">.</span><span class="token function-variable function">onclose</span> <span class="token operator">=</span> <span class="token parameter">_e</span> <span class="token operator">=&gt;</span>
          <span class="token function">setReadyState</span><span class="token punctuation">(</span>stateArr<span class="token punctuation">[</span>ws<span class="token punctuation">.</span>current<span class="token operator">?.</span>readyState <span class="token operator">??</span> <span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
      ws<span class="token punctuation">.</span>current<span class="token punctuation">.</span><span class="token function-variable function">onerror</span> <span class="token operator">=</span> <span class="token parameter">e</span> <span class="token operator">=&gt;</span>
          <span class="token function">setReadyState</span><span class="token punctuation">(</span>stateArr<span class="token punctuation">[</span>ws<span class="token punctuation">.</span>current<span class="token operator">?.</span>readyState <span class="token operator">??</span> <span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
      ws<span class="token punctuation">.</span>current<span class="token punctuation">.</span><span class="token function-variable function">onmessage</span> <span class="token operator">=</span> <span class="token parameter">e</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{<!-- --></span>
        <span class="token function">setMessage</span><span class="token punctuation">(</span>e<span class="token punctuation">.</span>data<span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token punctuation">}</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token punctuation">[</span>ws<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

  <span class="token comment">/**
   * 初始化 WebSocket
   * 且使用 WebSocket 原声方法获取信息
   *  */</span>
  <span class="token function">useLayoutEffect</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{<!-- --></span>
    <span class="token function">getRandomInt</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">webSocketInit</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{<!-- --></span>
      ws<span class="token punctuation">.</span>current<span class="token operator">?.</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token punctuation">[</span>ws<span class="token punctuation">,</span> getRandomInt<span class="token punctuation">,</span> webSocketInit<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/e9aca52b27ccb2d0b1f4e906524b1c24/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">Python求最大公约数与最小公倍数的方法</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/d4970b1724202db98b18fd062b98103d/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">java笔试常见判断题</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>