<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>最优化-黄金分割法 原理及代码实现 - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="最优化-黄金分割法 原理及代码实现" />
<meta property="og:description" content="1.黄金分割法介绍 黄金分割法，也叫0.618法，主要用于单峰函数，通过不断地分割迭代，从而找到近似于最小值的函数值。
1.1单峰函数： 如图所示，
设f(x)是定义在D上的实值函数，如果存在，使得对D中当任何时，，当时有,那么就说是定义在D上的单峰函数
1.2算法原理 为了找出最小点，我们通过不断试探的方法，首先我们需要给定区间，然受在给定区间内取两点
,
黄金分割的核心原理就是在于对点的选取：
对于x_1和x_2的选取分为以下两种情况：
通过两式的不断迭代，a，b在逐渐靠近，我们设置一个精度epi，当
停止迭代。
2.代码实现 2.1输入函数 我们自己定义区间a，b的值，并且输入所要求的方程形式如（x^2 &#43; 5*x &#43;2）
a = float(input(&#34;初始左端点&#34;)) b = float(input(&#34;初始右端点&#34;)) def function(a): fx = str_fx.replace(&#34;x&#34;, &#34;a&#34;) # 所有的&#34;x&#34;换为方法所输入的参数a return eval(fx) #eval类型用于对字符串公式进行转换 init_str = input(&#34;请输入一个函数，默认变量为x：\n&#34;) # 输入的最初字符串 str_fx = init_str.replace(&#34;^&#34;, &#34;**&#34;) # 将所有的“^&#34;替换为python的幂形式&#34;**&#34; 2.2画出函数并判断是否为单峰函数 通过定义drawf函数，并且传入参数a，b和间隔interp，来画出图像，通过图像判断是否可以使用黄金分割法进行一维线性搜索。
from pylab import * def drawf(a, b, interp): x = [a&#43;ele*interp for ele in range(0, int((b-a)/interp))] y = [function(ele) for ele in x] # y = [function(x)] plt." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/5ea20ec666ee98e1808b79db87388012/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-10-21T10:35:05+08:00" />
<meta property="article:modified_time" content="2023-10-21T10:35:05+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">最优化-黄金分割法 原理及代码实现</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <h3>1.黄金分割法介绍</h3> 
<p>黄金分割法，也叫0.618法，主要用于单峰函数，通过不断地分割迭代，从而找到近似于最小值的函数值。</p> 
<h4>1.1单峰函数：</h4> 
<p><img alt="" height="388" src="https://images2.imgbox.com/d7/8b/AfPYOUGR_o.png" width="388"></p> 
<p>如图所示，</p> 
<p>设f(x)是定义在D上的实值函数，如果存在<img alt="x_0\epsilon D" class="mathcode" src="https://images2.imgbox.com/cc/e1/1BADV3Pn_o.png">，使得对D中当任何<img alt="x_1&lt;x_2&lt;x_0" class="mathcode" src="https://images2.imgbox.com/99/c9/tjDCwJvn_o.png">时，<img alt="f(x_1)&lt;f(x_2)" class="mathcode" src="https://images2.imgbox.com/f1/0b/G6CBK9KB_o.png">，当<img alt="x_0&lt;x_3&lt;x_4" class="mathcode" src="https://images2.imgbox.com/cc/a2/Ew2mme8T_o.png">时有<img alt="f(x_3)&lt;f(x_4)" class="mathcode" src="https://images2.imgbox.com/8b/b1/wBYLW2qM_o.png">,那么就说是定义在D上的单峰函数</p> 
<h4>1.2算法原理</h4> 
<p>为了找出最小点，我们通过不断试探的方法，首先我们需要给定区间<img alt="[a,b]" class="mathcode" src="https://images2.imgbox.com/7c/0a/ItsFMN5l_o.png">，然受在给定区间内取两点</p> 
<p><img alt="x_1,x_2" class="mathcode" src="https://images2.imgbox.com/7d/35/dOF3flNk_o.png">,</p> 
<p> <img alt="x_1 = a + (1-\tau )(b-a)" class="mathcode" src="https://images2.imgbox.com/fd/38/Rngri1ei_o.png"></p> 
<p><img alt="x_2 = b - (1-\tau)(b-a)" class="mathcode" src="https://images2.imgbox.com/15/6d/6dsTIad3_o.png"></p> 
<p><img alt="\tau = \frac{\sqrt{5}-1}{2}\approx 0.618" class="mathcode" src="https://images2.imgbox.com/13/b3/kQS0RaiJ_o.png"></p> 
<p>黄金分割的核心原理就是在于对点的选取：</p> 
<p><img alt="" height="587" src="https://images2.imgbox.com/4e/1a/pTTUgS1l_o.png" width="587"></p> 
<p>对于x_1和x_2的选取分为以下两种情况：</p> 
<p><img alt="f(x_1) &lt; f(x_2) : b =x_2 ,x_2 = x_1,x_1= a+(b-a)*\tau" class="mathcode" src="https://images2.imgbox.com/e8/11/7beutlKL_o.png"></p> 
<p><img alt="f(x_1) \geq f(x_2): a= x_1,x_1 =x_2,x_2 = b - (b-a) * \tau" class="mathcode" src="https://images2.imgbox.com/ee/22/PGURyaF3_o.png"></p> 
<p>通过两式的不断迭代，a，b在逐渐靠近，我们设置一个精度epi，当</p> 
<p><img alt="a-b&lt;epi" class="mathcode" src="https://images2.imgbox.com/64/d1/0zyXwyoE_o.png"> 停止迭代。</p> 
<h2>2.代码实现</h2> 
<h3>2.1输入函数</h3> 
<p>我们自己定义区间a，b的值，并且输入所要求的方程形式如（x^2 + 5*x +2）</p> 
<pre><code>a = float(input("初始左端点"))
b = float(input("初始右端点"))
def function(a):
     fx = str_fx.replace("x", "a")  # 所有的"x"换为方法所输入的参数a
     return eval(fx)  #eval类型用于对字符串公式进行转换
init_str = input("请输入一个函数，默认变量为x：\n")  # 输入的最初字符串
str_fx = init_str.replace("^", "**")  # 将所有的“^"替换为python的幂形式"**"</code></pre> 
<h3>2.2画出函数并判断是否为单峰函数</h3> 
<p>通过定义drawf函数，并且传入参数a，b和间隔interp，来画出图像，通过图像判断是否可以使用黄金分割法进行一维线性搜索。</p> 
<pre><code>from pylab import *
def drawf(a, b, interp):
    x = [a+ele*interp for ele in range(0, int((b-a)/interp))]
    y = [function(ele) for ele in x]
    # y = [function(x)]
    plt.figure(1)
    plt.plot(x, y)
    xlim(a, b)
    #title(color="b")
    plt.show()
draw(a,b,0.05)</code></pre> 
<p style="text-align:center;"><img alt="" height="370" src="https://images2.imgbox.com/d0/48/2SiX4nJP_o.png" width="444"></p> 
<p style="text-align:center;">如图像所示，我们输入函数（x^2 + 5*x +2）在区间a，b上为凸函数</p> 
<h3>2.3不断迭代求出最小值和最小值点</h3> 
<pre><code>def golden_section_search(a, b, eps=1e-8):
    phi = (1 + 5 ** 0.5) / 2  # 黄金分割常数phi
    x1 = b - (b - a) / phi
    x2 = a + (b - a) / phi
    while abs(b - a) &gt; eps:  # 终止条件为区间长度小于给定的值
        if function(x1) &lt; function(x2):
            b = x2
            x2 = x1
            x1 = a + (b - a) / phi
            #plt.plot(x1, function(x1), 'y*')
        else:
            a = x1
            x1 = x2
            x2 = b - (b - a) / phi
            #plt.plot(x2, function(x2), 'y*')
    return (a + b) / 2  # 返回最小值所在的位置
#这里我们设置eps为1e-8
x_min = golden_section_search(a,b)
y_min = function(x_min)
print('输入函数最小值点为：{:.5f}\n最小值为{:.5f}'.format(x_min,y_min))</code></pre> 
<p>输出结果为</p> 
<p><img alt="" height="150" src="https://images2.imgbox.com/f6/c6/wuMVn30o_o.png" width="349"></p> 
<p></p> 
<p></p> 
<p></p> 
<p></p> 
<p></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/aafd389d9a7fcbc72d65a985c325c364/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">c语言实现：输入一个字符串,再输入一个字符，在字符串中删除输入的字符,形成新的字符串并输出</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/4f8ff405cf068adad2a0531f4c7f6155/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">施密特正交化</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>