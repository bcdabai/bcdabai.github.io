<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>使用懒加载 &#43; 零拷贝后，程序的秒开率提升至99.99% - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="使用懒加载 &#43; 零拷贝后，程序的秒开率提升至99.99%" />
<meta property="og:description" content="目录 一、5秒钟加载一个页面的真相二、优化四步走1、“懒加载”2、线上显示 = 就读取一个文件，为什么会慢呢？ 三、先从上帝视角，了解一下啥子是IO流四、写个栗子，测试一下1、通过字符输入流FileReader读取2、通过缓冲流BufferedReader读取3、再点进源码瞧瞧。（1）FileReader.read()源码很简单，就是直接读取（2）BufferedReader.read()的源码就较为复杂了，看一下它的核心方法fill()（3）buffer四大属性 4、缓冲流：4 次上下文切换 &#43; 4 次拷贝 五、NIO之FileChannel1、FileChannel 常见的方法有2、关于Buffer 和 Channel的注意事项和细节3、Selector(选择器)4、selector的相关方法 六、内存映射技术mmap1、文件映射2、Java中使用mmap3、内存映射技术mmap：4 次上下文切换 &#43; 3 次拷贝 七、sendFile零拷贝1、传统IO流2、sendFile零拷贝3、sendFile零拷贝：2 次上下文切换 &#43; 2次拷贝重置优化4：通过零拷贝读取文件 八、总结经过4次优化，将页面的加载时间控制在了1秒以内，实打实的提升了程序的秒开率。通过一次页面优化，收获颇丰： 大家好，我是哪吒。
一、5秒钟加载一个页面的真相 今天在修改前端页面的时候，发现程序中有一个页面的加载速度很慢，差不多需要5秒，这其实是难以接受的，我也不知道为什么上线这么长时间了，没人提过这个事儿。
我记得有一个词儿，叫秒开率。
秒开率是指能够在1秒内完成页面的加载。
查询的时候，会访问后台数据库，查询前20条数据，按道理来说，这应该很快才对。
追踪代码，看看啥问题，最后发现问题有三：
表中有一个BLOB大字段，存储着一个PDF模板，也就是上图中的运费模板；查询后会将这个PDF模板存储到本地磁盘点击线上显示，会读取本地的PDF模板，通过socket传到服务器。 大字段批量查询、批量文件落地、读取大文件并进行网络传输，不慢才怪，这一顿骚操作，5秒能加载完毕，已经烧高香了。
二、优化四步走 1、“懒加载” 经过调查发现，这个PDF模板只有在点击运费模板按钮时才会使用。
优化1： 在点查询按钮时，不查询PDF模板；优化2： 点击运费模板时，根据uuid去查询，这样既能触发索引，也不用按时间排序，只是查询单条，速度快了很多很多，我愿称你为“懒加载”。优化3： 通过异步，将文件保存到磁盘中。 2、线上显示 = 就读取一个文件，为什么会慢呢？ 打开代码一看，居然是通过FileReader读取的，我了个乖乖~
这有什么问题吗？都是从百度拷贝过来的，百度还会有错吗？而且也测试了，没问题啊。
嗯，对，是没问题，是可以实现需求，可是，为什么用这个？不知道。更别说效率问题了~
优化4：通过缓冲流读取文件
三、先从上帝视角，了解一下啥子是IO流 Java I/O (Input/Output) 是对传统 I/O 操作的封装，它是以流的形式来操作数据的。
InputStream 代表一个输入流，它是一个抽象类，不能被实例化。InputStream 定义了一些通用方法，如 read() 和 skip() 等，用于从输入流中读取数据；OutputStream 代表一个输出流，它也是一个抽象类，不能被实例化。OutputStream 定义了一些通用方法，如 write() 和 flush() 等，用于向输出流中写入数据；除了字节流，Java 还提供字符流，字符流类似于字节流，不同之处在于字符流是按字符读写数据，而不是按字节。Java 中最基本的字符流是 Reader 和 Writer，它们是基于 InputStream 和 OutputStream 的转换类，用于完成字节流与字符流之间的转换。BufferedInputStream 和 BufferedOutputStream 是 I/O 包中提供的缓冲输入输出流。它们可以提高 I/O 操作的效率，具有较好的缓存机制，能够减少磁盘操作，缩短文件传输时间。使用 BufferedInputStream 和 BufferedOutputStream 进行读取和写入时，Java 会自动调整缓冲区的大小，使其能够适应不同的数据传输速度。可以读取或写入 Java 对象的流，比较典型的对象流包括ObjectInputStream 和 ObjectOutputStream，将 Java 对象转换为字节流进行传输或存储； 在上一篇《增加索引 &#43; 异步 &#43; 不落地后，从 12h 优化到 15 min》中，提到了4种优化方式，数据库优化、复用优化、并行优化、算法优化。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/666a6e01b78b5a4f555a2fbc4627b28c/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2024-01-11T10:28:09+08:00" />
<meta property="article:modified_time" content="2024-01-11T10:28:09+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">使用懒加载 &#43; 零拷贝后，程序的秒开率提升至99.99%</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-light">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p><img src="https://images2.imgbox.com/0a/30/T7VmELxc_o.gif" alt="在这里插入图片描述"></p> 
<p></p> 
<div class="toc"> 
 <h4>目录</h4> 
 <ul><li><ul><li><a href="#5_7" rel="nofollow">一、5秒钟加载一个页面的真相</a></li><li><a href="#_29" rel="nofollow">二、优化四步走</a></li><li><ul><li><a href="#1_31" rel="nofollow">1、“懒加载”</a></li><li><a href="#2___41" rel="nofollow">2、线上显示 = 就读取一个文件，为什么会慢呢？</a></li></ul> 
   </li><li><a href="#IO_52" rel="nofollow">三、先从上帝视角，了解一下啥子是IO流</a></li><li><a href="#_68" rel="nofollow">四、写个栗子，测试一下</a></li><li><ul><li><a href="#1FileReader_70" rel="nofollow">1、通过字符输入流FileReader读取</a></li><li><a href="#2BufferedReader_88" rel="nofollow">2、通过缓冲流BufferedReader读取</a></li><li><a href="#3_119" rel="nofollow">3、再点进源码瞧瞧。</a></li><li><ul><li><a href="#1FileReaderread_121" rel="nofollow">（1）FileReader.read()源码很简单，就是直接读取</a></li><li><a href="#2BufferedReaderreadfill_129" rel="nofollow">（2）BufferedReader.read()的源码就较为复杂了，看一下它的核心方法fill()</a></li><li><a href="#3buffer_189" rel="nofollow">（3）buffer四大属性</a></li></ul> 
    </li><li><a href="#44___4__195" rel="nofollow">4、缓冲流：4 次上下文切换 + 4 次拷贝</a></li></ul> 
   </li><li><a href="#NIOFileChannel_205" rel="nofollow">五、NIO之FileChannel</a></li><li><ul><li><a href="#1FileChannel__208" rel="nofollow">1、FileChannel 常见的方法有</a></li><li><a href="#2Buffer__Channel_215" rel="nofollow">2、关于Buffer 和 Channel的注意事项和细节</a></li><li><a href="#3Selector_222" rel="nofollow">3、Selector(选择器)</a></li><li><a href="#4selector_228" rel="nofollow">4、selector的相关方法</a></li></ul> 
   </li><li><a href="#mmap_234" rel="nofollow">六、内存映射技术mmap</a></li><li><ul><li><a href="#1_236" rel="nofollow">1、文件映射</a></li><li><a href="#2Javammap_248" rel="nofollow">2、Java中使用mmap</a></li><li><a href="#3mmap4___3__285" rel="nofollow">3、内存映射技术mmap：4 次上下文切换 + 3 次拷贝</a></li></ul> 
   </li><li><a href="#sendFile_296" rel="nofollow">七、sendFile零拷贝</a></li><li><ul><li><a href="#1IO_300" rel="nofollow">1、传统IO流</a></li><li><a href="#2sendFile_308" rel="nofollow">2、sendFile零拷贝</a></li><li><a href="#3sendFile2___2_314" rel="nofollow">3、sendFile零拷贝：2 次上下文切换 + 2次拷贝</a></li><li><a href="#4_319" rel="nofollow">重置优化4：通过零拷贝读取文件</a></li></ul> 
   </li><li><a href="#_324" rel="nofollow">八、总结</a></li><li><ul><li><a href="#41_326" rel="nofollow">经过4次优化，将页面的加载时间控制在了1秒以内，实打实的提升了程序的秒开率。</a></li><li><a href="#_333" rel="nofollow">通过一次页面优化，收获颇丰：</a></li></ul> 
  </li></ul> 
 </li></ul> 
</div> 
<p></p> 
<p>大家好，我是哪吒。</p> 
<h3><a id="5_7"></a>一、5秒钟加载一个页面的真相</h3> 
<p>今天在修改前端页面的时候，发现程序中有一个页面的加载速度很慢，差不多需要<strong>5秒</strong>，这其实是难以接受的，我也不知道为什么上线这么长时间了，没人提过这个事儿。</p> 
<p>我记得有一个词儿，叫秒开率。</p> 
<blockquote> 
 <p>秒开率是指能够在1秒内完成页面的加载。</p> 
</blockquote> 
<p><img src="https://images2.imgbox.com/11/8f/S8YgCQR9_o.png" alt="在这里插入图片描述"></p> 
<p>查询的时候，会访问后台数据库，查询前20条数据，按道理来说，这应该很快才对。</p> 
<p>追踪代码，看看啥问题，最后发现问题有三：</p> 
<ol><li>表中有一个BLOB大字段，存储着一个PDF模板，也就是上图中的运费模板；</li><li>查询后会将这个PDF模板存储到本地磁盘</li><li>点击线上显示，会读取本地的PDF模板，通过socket传到服务器。</li></ol> 
<p><font face="楷体" size="5" color="#dd0000">大字段批量查询、批量文件落地、读取大文件并进行网络传输，不慢才怪，这一顿骚操作，5秒能加载完毕，已经烧高香了。</font></p> 
<p><img src="https://images2.imgbox.com/aa/56/FM56LV6c_o.png" alt="在这里插入图片描述"></p> 
<h3><a id="_29"></a>二、优化四步走</h3> 
<h4><a id="1_31"></a>1、“懒加载”</h4> 
<p>经过调查发现，这个PDF模板只有在点击运费模板按钮时才会使用。</p> 
<ul><li><strong>优化1：</strong> 在点查询按钮时，不查询PDF模板；</li><li><strong>优化2：</strong> 点击运费模板时，根据uuid去查询，这样既能触发索引，也不用按时间排序，只是查询单条，速度快了很多很多，<strong>我愿称你为“懒加载”。</strong></li><li><strong>优化3：</strong> 通过异步，将文件保存到磁盘中。</li></ul> 
<p><img src="https://images2.imgbox.com/dc/a4/3hnJSeQ1_o.png" alt="在这里插入图片描述"></p> 
<h4><a id="2___41"></a>2、线上显示 = 就读取一个文件，为什么会慢呢？</h4> 
<p>打开代码一看，居然是通过FileReader读取的，我了个乖乖~</p> 
<p>这有什么问题吗？都是从百度拷贝过来的，百度还会有错吗？而且也测试了，没问题啊。</p> 
<p>嗯，对，是没问题，是可以实现需求，可是，为什么用这个？不知道。更别说效率问题了~</p> 
<p><strong>优化4</strong>：通过缓冲流读取文件</p> 
<p><img src="https://images2.imgbox.com/9e/94/Fz0A2W7K_o.png" alt="在这里插入图片描述"></p> 
<h3><a id="IO_52"></a>三、先从上帝视角，了解一下啥子是IO流</h3> 
<p>Java I/O (Input/Output) 是对传统 I/O 操作的封装，它是以流的形式来操作数据的。</p> 
<ol><li>InputStream 代表一个<strong>输入流</strong>，它是一个抽象类，不能被实例化。InputStream 定义了一些通用方法，如 read() 和 skip() 等，用于从输入流中读取数据；</li><li>OutputStream 代表一个<strong>输出流</strong>，它也是一个抽象类，不能被实例化。OutputStream 定义了一些通用方法，如 write() 和 flush() 等，用于向输出流中写入数据；</li><li>除了字节流，Java 还提供<strong>字符流</strong>，字符流类似于字节流，不同之处在于字符流是按字符读写数据，而不是按字节。Java 中最基本的字符流是 Reader 和 Writer，它们是基于 InputStream 和 OutputStream 的转换类，用于完成字节流与字符流之间的转换。</li><li>BufferedInputStream 和 BufferedOutputStream 是 I/O 包中提供的<strong>缓冲输入输出流</strong>。它们可以提高 I/O 操作的效率，具有较好的缓存机制，能够减少磁盘操作，缩短文件传输时间。使用 BufferedInputStream 和 BufferedOutputStream 进行读取和写入时，Java 会自动调整缓冲区的大小，使其能够适应不同的数据传输速度。</li><li>可以读取或写入 Java <strong>对象的流</strong>，比较典型的对象流包括ObjectInputStream 和 ObjectOutputStream，将 Java 对象转换为字节流进行传输或存储；</li></ol> 
<p><img src="https://images2.imgbox.com/21/d7/bv8j9avQ_o.png" alt="在这里插入图片描述"></p> 
<p>在上一篇<a href="https://blog.csdn.net/guorui_java/article/details/135423211"><strong>《增加索引 + 异步 + 不落地后，从 12h 优化到 15 min》</strong></a>中，提到了4种优化方式，数据库优化、复用优化、并行优化、算法优化。</p> 
<p><font face="楷体" size="5" color="#dd0000">其中Buffered缓冲流就属于复用优化的一种，这个页面的查询完全可以通过<strong>复用优化</strong>优化一下。</font></p> 
<h3><a id="_68"></a>四、写个栗子，测试一下</h3> 
<h4><a id="1FileReader_70"></a>1、通过字符输入流FileReader读取</h4> 
<p>FileReader连readLine()方法都没有，我也是醉了~</p> 
<pre><code class="prism language-java"><span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">readFileByReader</span><span class="token punctuation">(</span><span class="token class-name">String</span> filePath<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    <span class="token keyword">int</span> result <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token keyword">try</span> <span class="token punctuation">(</span><span class="token class-name">Reader</span> reader <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">FileReader</span><span class="token punctuation">(</span>filePath<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token keyword">int</span> value<span class="token punctuation">;</span>
        <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>value <span class="token operator">=</span> reader<span class="token punctuation">.</span><span class="token function">read</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
            result <span class="token operator">+=</span> value<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Exception</span> e<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"readFileByReader异常："</span> <span class="token operator">+</span> e<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> result<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<h4><a id="2BufferedReader_88"></a>2、通过缓冲流BufferedReader读取</h4> 
<pre><code class="prism language-java"><span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token class-name">String</span> <span class="token function">readFileByBuffer</span><span class="token punctuation">(</span><span class="token class-name">String</span> filePath<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    <span class="token class-name">StringBuilder</span> builder <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">StringBuilder</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">try</span> <span class="token punctuation">(</span><span class="token class-name">BufferedReader</span> reader <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">BufferedReader</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">FileReader</span><span class="token punctuation">(</span>filePath<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token class-name">String</span> data <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
        <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>data <span class="token operator">=</span> reader<span class="token punctuation">.</span><span class="token function">readLine</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
            builder<span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span><span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Exception</span> e<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"readFileByReader异常："</span> <span class="token operator">+</span> e<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> builder<span class="token operator">+</span><span class="token string">""</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>通过循环模拟了150000个文件进行测试，FileReader耗时8136毫秒，BufferedReader耗时6718毫秒，差不多相差1秒半的时间，差距还是相当大的，俗话说得好，水滴石穿。</p> 
<p>同样是read方法，只不过是包了一层，有啥不同呢？</p> 
<p>BufferedReader 是一个缓冲字符输入流，可以对 FileRead 进行包装，提供了一个缓存数组，将数据按照一定规则读取到缓存区中，输入流每次读取文件数据时都需要将数据进行字符编码，而 BufferedReader 的出现，降低了输入流访问数据源的次数，将一定大小的数据一次读取到缓存区并进行字符编码，从而提高 IO 的效率。</p> 
<p>如果没有缓冲，每次调用 read() 或 readLine() 都可能导致从文件中读取字节，转换为字符，然后返回，这可能非常低效。</p> 
<p><font face="楷体" size="5" color="#dd0000">就像取快递一样，在取快递的时候，肯定是想一次性的取完，避免再来一趟。</font></p> 
<ul><li>FileReader就相当于一件一件的取，乐此不疲；</li><li>BufferedReader就相当于，你尽可能多的拿你的快递，可是这也有个极限，比如你一次只能拿5件快递，这个 5 就相当于缓冲区，效率上，提升数倍。</li></ul> 
<p>对 FileRead 进行包装变成了BufferedReader缓冲字符输入流，其实，Java IO流就是最典型的<strong>装饰器模式</strong>，装饰器模式通过组合替代继承的方式在不改变原始类的情况下添加增强功能，主要解决继承关系过于复杂的问题，之前整理过一篇装饰器模式，这里就不论述了。</p> 
<h4><a id="3_119"></a>3、再点进源码瞧瞧。</h4> 
<h5><a id="1FileReaderread_121"></a>（1）FileReader.read()源码很简单，就是直接读取</h5> 
<pre><code class="prism language-java"><span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">read</span><span class="token punctuation">(</span><span class="token keyword">char</span> cbuf<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token keyword">int</span> off<span class="token punctuation">,</span> <span class="token keyword">int</span> len<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">IOException</span> <span class="token punctuation">{<!-- --></span>
   <span class="token keyword">return</span> in<span class="token punctuation">.</span><span class="token function">read</span><span class="token punctuation">(</span>cbuf<span class="token punctuation">,</span> off<span class="token punctuation">,</span> len<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<h5><a id="2BufferedReaderreadfill_129"></a>（2）BufferedReader.read()的源码就较为复杂了，看一下它的核心方法fill()</h5> 
<pre><code class="prism language-java"><span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">fill</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">IOException</span> <span class="token punctuation">{<!-- --></span>
   <span class="token keyword">int</span> dst<span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>markedChar <span class="token operator">&lt;=</span> <span class="token constant">UNMARKED</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token comment">/* No mark */</span>
        dst <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{<!-- --></span>
        <span class="token comment">/* Marked */</span>
        <span class="token keyword">int</span> delta <span class="token operator">=</span> nextChar <span class="token operator">-</span> markedChar<span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>delta <span class="token operator">&gt;=</span> readAheadLimit<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
            <span class="token comment">/* Gone past read-ahead limit: Invalidate mark */</span>
            markedChar <span class="token operator">=</span> <span class="token constant">INVALIDATED</span><span class="token punctuation">;</span>
            readAheadLimit <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
            dst <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{<!-- --></span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>readAheadLimit <span class="token operator">&lt;=</span> cb<span class="token punctuation">.</span>length<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
                <span class="token comment">/* Shuffle in the current buffer */</span>
                <span class="token class-name">System</span><span class="token punctuation">.</span><span class="token function">arraycopy</span><span class="token punctuation">(</span>cb<span class="token punctuation">,</span> markedChar<span class="token punctuation">,</span> cb<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> delta<span class="token punctuation">)</span><span class="token punctuation">;</span>
                markedChar <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
                dst <span class="token operator">=</span> delta<span class="token punctuation">;</span>
            <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{<!-- --></span>
                <span class="token comment">/* Reallocate buffer to accommodate read-ahead limit */</span>
                <span class="token keyword">char</span> ncb<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">char</span><span class="token punctuation">[</span>readAheadLimit<span class="token punctuation">]</span><span class="token punctuation">;</span>
                <span class="token class-name">System</span><span class="token punctuation">.</span><span class="token function">arraycopy</span><span class="token punctuation">(</span>cb<span class="token punctuation">,</span> markedChar<span class="token punctuation">,</span> ncb<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> delta<span class="token punctuation">)</span><span class="token punctuation">;</span>
                cb <span class="token operator">=</span> ncb<span class="token punctuation">;</span>
                markedChar <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
                dst <span class="token operator">=</span> delta<span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
            nextChar <span class="token operator">=</span> nChars <span class="token operator">=</span> delta<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">int</span> n<span class="token punctuation">;</span>
    <span class="token keyword">do</span> <span class="token punctuation">{<!-- --></span>
        n <span class="token operator">=</span> in<span class="token punctuation">.</span><span class="token function">read</span><span class="token punctuation">(</span>cb<span class="token punctuation">,</span> dst<span class="token punctuation">,</span> cb<span class="token punctuation">.</span>length <span class="token operator">-</span> dst<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span> <span class="token keyword">while</span> <span class="token punctuation">(</span>n <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>n <span class="token operator">&gt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        nChars <span class="token operator">=</span> dst <span class="token operator">+</span> n<span class="token punctuation">;</span>
        nextChar <span class="token operator">=</span> dst<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> 
<p><strong>核心方法fill()：</strong></p> 
<ol><li>字符缓冲输入流，底层有一个8192个元素的缓冲字符数组，<strong>当缓冲区的内容读完时，将使用 fill() 方法从硬盘中读取数据填充缓冲数组</strong>；</li><li>字符缓冲输出流，底层有一个8192个元素的缓冲字符数组，使用flush方法将缓冲数组中的内容写入到硬盘当中；</li><li>使用缓冲数组之后，程序在运行的大部分时间内都是内存和内存直接的数据交互过程。内存直接的操作效率是比较高的。并且降低了CPU通过内存操作硬盘的次数；</li><li>关闭字符缓冲流，都会首先释放对应的缓冲数组空间，并且关闭创建对应的字符输入流和字符输出流。</li></ol> 
<p>既然缓冲这么好用，为啥jdk将缓冲字符数组设置的这么小，才8192个字节？</p> 
<p>这是一个比较折中的方案，如果缓冲区太大的话，就会增加单次读写的时间，同样内存的大小也是有限制的，不可能都让你来干这个一件事。</p> 
<p>很多小伙伴也肯定用过它的read(char[] cbuf)，它内部维护了一个char数组，每次写/读数据时，操作的是数组，这样可以减少IO次数。</p> 
<p><img src="https://images2.imgbox.com/38/e2/2dUcjciG_o.png" alt="在这里插入图片描述"></p> 
<h5><a id="3buffer_189"></a>（3）buffer四大属性</h5> 
<ol><li>mark：标记</li><li>position：位置，下一个要被读或写的元素的索引， 每次读写缓冲区数据时都会改变改值， 为下次读写作准备</li><li>limit：表示缓冲区的当前终点，不能对缓冲区 超过极限的位置进行读写操作。且极限 是可以修改的</li><li>capacity：容量，即可以容纳的最大数据量；在缓 冲区创建时被设定并且不能改变。</li></ol> 
<h4><a id="44___4__195"></a>4、缓冲流：4 次上下文切换 + 4 次拷贝</h4> 
<p>传统 IO 执行的话需要 4 次上下文切换（用户态 -&gt; 内核态 -&gt; 用户态 -&gt; 内核态 -&gt; 用户态）和 4 次拷贝。</p> 
<ol><li>磁盘文件 DMA 拷贝到内核缓冲区</li><li>内核缓冲区 CPU 拷贝到用户缓冲区</li><li>用户缓冲区 CPU 拷贝到 Socket 缓冲区</li><li>Socket 缓冲区 DMA 拷贝到协议引擎。</li></ol> 
<p><img src="https://images2.imgbox.com/b9/97/qnbMFwbF_o.png" alt="在这里插入图片描述"></p> 
<h3><a id="NIOFileChannel_205"></a>五、NIO之FileChannel</h3> 
<p>NIO中比较常用的是FileChannel，主要用来对本地文件进行 IO 操作。</p> 
<h4><a id="1FileChannel__208"></a>1、FileChannel 常见的方法有</h4> 
<ol><li>read，从通道读取数据并放到缓冲区中；</li><li>write，把缓冲区的数据写到通道中；</li><li>transferFrom，从目标通道 中复制数据到当前通道；</li><li>transferTo，把数据从当 前通道复制给目标通道。</li></ol> 
<h4><a id="2Buffer__Channel_215"></a>2、关于Buffer 和 Channel的注意事项和细节</h4> 
<ol><li>ByteBuffer 支持类型化的put 和 get, put 放入的是什么数据类型，get就应该使用 相应的数据类型来取出，否则可能有 BufferUnderflowException 异常；</li><li>可以将一个普通Buffer 转成只读Buffer；</li><li>NIO 还提供了 MappedByteBuffer， 可以让文件直接在内存（堆外的内存）中进 行修改， 而如何同步到文件由NIO 来完成；</li><li>NIO 还支持 通过多个 Buffer (即 Buffer 数组) 完成读写操作，即 Scattering 和 Gathering。</li></ol> 
<h4><a id="3Selector_222"></a>3、Selector(选择器)</h4> 
<ol><li>Java 的 NIO，用非阻塞的 IO 方式。可以用一个线程，处理多个的客户端连 接，就会使用到Selector(选择器)；</li><li>Selector 能够检测多个注册的通道上是否有事件发生，如果有事件发生，便获取事件然 后针对每个事件进行相应的处理。这样就可以只用一个单线程去管理多个 通道，也就是管理多个连接和请求。</li><li>只有在 连接/通道 真正有读写事件发生时，才会进行读写，就大大地减少了系统开销，并且不必为每个连接都创建一个线程，不用去维护多个线程。</li><li>避免了多线程之间的上下文切换导致的开销。</li></ol> 
<h4><a id="4selector_228"></a>4、selector的相关方法</h4> 
<ol><li>open();//得到一个选择器对象</li><li>select(long timeout);//监控所有注册的通道，当其 中有 IO 操作可以进行时，将 对应的 SelectionKey 加入到内部集合中并返回，参数用来 设置超时时间</li><li>selectedKeys();//从内部集合中得 到所有的 SelectionKey。</li></ol> 
<h3><a id="mmap_234"></a>六、内存映射技术mmap</h3> 
<h4><a id="1_236"></a>1、文件映射</h4> 
<p>传统的文件I/O操作可能会变得很慢，这时候mmap就闪亮登场了。mmap（Memory-mapped files）是一种在内存中创建映射文件的机制，它可以使我们像访问内存一样访问文件，从而避免频繁的文件I/O操作。</p> 
<p>使用mmap的方式是在内存中创建一个虚拟地址，然后将文件映射到这个虚拟地址上，这个映射的过程是由操作系统完成的。</p> 
<p>实现映射后，进程就可以采用指针的方式读写操作这一段内存，系统会自动回写到对应的文件磁盘上，这样就完成了对文件的读取操作，而不用调用 read、write 等系统函数。</p> 
<p>内核空间对这段区域的修改也会直接反映用户空间，从而可以实现不同进程间的文件共享。</p> 
<p><img src="https://images2.imgbox.com/ef/a0/SfC9f5ne_o.png" alt="在这里插入图片描述"></p> 
<h4><a id="2Javammap_248"></a>2、Java中使用mmap</h4> 
<p>在 Java 中，mmap 技术主要使用了 Java NIO （New IO）库中的 FileChannel 类，它提供了一种将文件映射到内存的方法，称为 MappedByteBuffer。MappedByteBuffer 是 ByteBuffer 的一个子类，它扩展了 ByteBuffer 的功能，可以直接将文件映射到内存中。</p> 
<p>根据文件地址创建了一层缓存当作索引，放在虚拟内存中，使用时会根据的地址，直接找到磁盘中文件的位置，把数据分段load到系统内存(pagecache)中。</p> 
<p><img src="https://images2.imgbox.com/33/5e/eC7hZpIZ_o.png" alt="在这里插入图片描述"></p> 
<pre><code class="prism language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token class-name">String</span> <span class="token function">readFileByMmap</span><span class="token punctuation">(</span><span class="token class-name">String</span> filePath<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    <span class="token class-name">File</span> file <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">File</span><span class="token punctuation">(</span>filePath<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token class-name">String</span> ret <span class="token operator">=</span> <span class="token string">""</span><span class="token punctuation">;</span>
    <span class="token class-name">StringBuilder</span> builder <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">StringBuilder</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">try</span> <span class="token punctuation">(</span><span class="token class-name">FileChannel</span> channel <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">RandomAccessFile</span><span class="token punctuation">(</span>file<span class="token punctuation">,</span> <span class="token string">"r"</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getChannel</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token keyword">long</span> size <span class="token operator">=</span> channel<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token comment">// 创建一个与文件大小相同的字节数组</span>
        <span class="token class-name">ByteBuffer</span> buffer <span class="token operator">=</span> <span class="token class-name">ByteBuffer</span><span class="token punctuation">.</span><span class="token function">allocate</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span> size<span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token comment">// 将通道上的所有数据都读入到buffer中</span>
        <span class="token keyword">while</span> <span class="token punctuation">(</span>channel<span class="token punctuation">.</span><span class="token function">read</span><span class="token punctuation">(</span>buffer<span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span><span class="token punctuation">}</span>

        <span class="token comment">// 切换为只读模式</span>
        buffer<span class="token punctuation">.</span><span class="token function">flip</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token comment">// 从buffer中获取数据并处理</span>
        <span class="token keyword">byte</span><span class="token punctuation">[</span><span class="token punctuation">]</span> data <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">byte</span><span class="token punctuation">[</span>buffer<span class="token punctuation">.</span><span class="token function">remaining</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
        buffer<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span><span class="token punctuation">;</span>

        ret <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">String</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">IOException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"readFileByMmap异常："</span> <span class="token operator">+</span> e<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> ret<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<h4><a id="3mmap4___3__285"></a>3、内存映射技术mmap：4 次上下文切换 + 3 次拷贝</h4> 
<p><font face="楷体" size="5" color="#dd0000">mmap 是一种内存映射技术，mmap 相比于传统的 缓冲流 来说，其实就是少了 1 次 CPU 拷贝，变成了数据共享。</font></p> 
<p>虽然减少了一次拷贝，但是上下文切换的次数还是没变。</p> 
<p>因为存在一次CPU拷贝，因此mmap并不是严格意义上的零拷贝。</p> 
<p>RocketMQ 中就是使用的 mmap 来提升磁盘文件的读写性能。</p> 
<p><img src="https://images2.imgbox.com/65/a5/K8TB8EzS_o.png" alt="在这里插入图片描述"></p> 
<h3><a id="sendFile_296"></a>七、sendFile零拷贝</h3> 
<p>零拷贝将上下文切换和拷贝的次数压缩到了极致。</p> 
<h4><a id="1IO_300"></a>1、传统IO流</h4> 
<ol><li>将磁盘中的文件拷贝到内核空间内存；</li><li>将内核空间的内容拷贝到用户空间内存；</li><li>用户空间将内容写入到内核空间内存；</li><li>socket读取内核空间内存，将内容发送给第三方服务器。</li></ol> 
<p><img src="https://images2.imgbox.com/46/d8/SXycyqxZ_o.png" alt="在这里插入图片描述"></p> 
<h4><a id="2sendFile_308"></a>2、sendFile零拷贝</h4> 
<p>在内核的支持下，零拷贝少了一个步骤，那就是内核缓存向用户空间的拷贝，这样既节省了内存，也节省了 CPU 的调度时间，让效率更高。</p> 
<p><img src="https://images2.imgbox.com/a6/08/q11De8Sz_o.png" alt="在这里插入图片描述"></p> 
<h4><a id="3sendFile2___2_314"></a>3、sendFile零拷贝：2 次上下文切换 + 2次拷贝</h4> 
<p><font face="楷体" size="5" color="#dd0000">直接将用户缓冲区干掉，而且没有CPU拷贝，故得名 <strong>零拷贝</strong>。</font><br> <img src="https://images2.imgbox.com/10/79/9fo3grNm_o.png" alt="在这里插入图片描述"></p> 
<h4><a id="4_319"></a>重置优化4：通过零拷贝读取文件</h4> 
<p><img src="https://images2.imgbox.com/c7/e8/H7IFePKL_o.png" alt="在这里插入图片描述"></p> 
<h3><a id="_324"></a>八、总结</h3> 
<h4><a id="41_326"></a>经过4次优化，将页面的加载时间控制在了1秒以内，实打实的提升了程序的秒开率。</h4> 
<ol><li>批量查询时，不查询BLOB大字段；</li><li>点击运费查询时，单独查询+触发索引，实现“懒加载”；</li><li>异步存储文件</li><li>通过 缓冲流 -&gt; 内存映射技术mmap -&gt; sendFile零拷贝 读取本地文件；</li></ol> 
<h4><a id="_333"></a>通过一次页面优化，收获颇丰：</h4> 
<ol><li>通过业务优化，将BLOB大字段进行“<strong>懒加载</strong>”；</li><li><strong>异步</strong>存储文件；</li><li>系统的学习了<strong>Java IO流</strong>，输入输出流、字符流、字符流、转换流；</li><li>通过<strong>NIO的FileChannel</strong>读取文件时，较于缓冲流性能上显著提升；</li><li><strong>内存映射技术mmap</strong> 相比于传统的 缓冲流 来说，其实就是少了 1 次 内核缓冲区到用户缓冲区的CPU 拷贝，将其变成了数据共享；</li><li><strong>sendFile零拷贝</strong>，舍弃了用户空间内存，舍弃了CUP拷贝，完美的零拷贝方案。</li><li>通过代码实例，横向对比了FileReader、BufferedReader、NIO之FileChannel、内存映射技术mmap、sendFile零拷贝之间的性能差距；</li></ol> 
<br> 
<p>🏆文章收录于：<a href="https://blog.csdn.net/guorui_java/category_12196381.html">100天精通Java从入门到就业</a></p> 
<p>全网最细Java零基础手把手入门教程，系列课程包括：Java基础、Java8新特性、Java集合、高并发、性能优化等，适合零基础和进阶提升的同学。</p> 
<p>🏆哪吒多年工作总结：<a href="https://blog.csdn.net/guorui_java/article/details/120098618"><strong>Java学习路线总结，搬砖工逆袭Java架构师</strong></a>。</p> 
<blockquote> 
 <p><font face="楷体" size="4">华为OD机试 2023B卷题库疯狂收录中，刷题<a href="https://blog.csdn.net/guorui_java/article/details/132683473"><font color="#dd0000"><u><strong>点这里</strong></u></font></a></font></p> 
</blockquote> 
<p><strong>刷的越多，抽中的概率越大</strong>，每一题都有详细的答题思路、详细的代码注释、样例测试，发现新题目，随时更新，全天CSDN在线答疑。</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/a530fdc444dbfeeffdccd6e3c34f2e83/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">Java Swing 机票预定管理系统 窗体项目 期末课程设计</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/b9409aa5b85465e7e535667bdc6f8818/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">银行的压力测试如何进行？</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>