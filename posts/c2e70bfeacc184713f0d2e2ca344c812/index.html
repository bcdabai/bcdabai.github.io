<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>递归算法题 - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="递归算法题" />
<meta property="og:description" content="1、
int fun(int n) { if (n &lt;= 1) { return 1; } else { return n * fun(n-1); } } int res = fun(5) 答案：120
2、
int search(int start, int end, int target, int *arr) { if(start &lt;= end) { int mid = start &#43; (end - start) / 2; if (arr[mid] == target) return mid; else if (target &gt; arr[mid]) return search(mid &#43; 1, end, target, arr); else if (target &lt; arr[mid]) return search(start, mid - 1, target, arr); } return -1; } 答案解析：代码为标准的二分查找，期望情况下，每次将范围n缩小一半，直到找到目标元素或者左右游标相遇，因此平均需要logN次搜索，所以时间复杂度为O(logN)" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/c2e70bfeacc184713f0d2e2ca344c812/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-08-01T09:16:39+08:00" />
<meta property="article:modified_time" content="2022-08-01T09:16:39+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">递归算法题</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p>1、</p> 
<pre><code>int fun(int n)
{
	if (n &lt;= 1)
	{
		return 1;
	}
	else
	{
		return n * fun(n-1);
	}
}
int res = fun(5)</code></pre> 
<p>答案：120</p> 
<p></p> 
<p></p> 
<p>2、</p> 
<pre><code>int search(int start, int end, int target, int *arr)
{
    if(start &lt;= end) {
        int mid = start + (end - start) / 2;
        if (arr[mid] == target)
            return mid;
        else if (target &gt; arr[mid])
            return search(mid + 1, end, target, arr);
        else if (target &lt; arr[mid])
            return search(start, mid - 1, target, arr);
    }
    return -1;
}</code></pre> 
<p>答案解析：代码为标准的二分查找，期望情况下，每次将范围n缩小一半，直到找到目标元素或者左右游标相遇，因此平均需要logN次搜索，所以时间复杂度为O(logN)</p> 
<p></p> 
<p>3、</p> 
<pre><code>int f(int x){ 
    return ((x&gt;0)?x*f(x-1):2) 
} 
int i; 
i=f(f(2));</code></pre> 
<p>答案解析：</p> 
<p>f(x) 当x大于0时，返回x*f(x-1)，否则返回2</p> 
<p>f(0) = 2</p> 
<p>f(1) = 1 * f(0) = 2</p> 
<p>f(2) = 2 * f(1) = 4</p> 
<p>f(3) = 3 * f(2) = 12</p> 
<p>f(4) = 4 * f(3) = 48</p> 
<p>f(4) = f(f(2))   = 48</p> 
<p></p> 
<p>4、</p> 
<pre><code>def reserve_str(s):
    if len(s) &lt; 1:
        return s
    return reserve_str(s[1:]) + s[0]
print(reserve_str('abc'))</code></pre> 
<p>答案解析：根据程序所示，当字符串s长度小于1时，直接返回字符串本身，否则返回 reserve_str(s[1:]) + s[0]，因此当输入 s='abc'时，返回 reserve_str('bc')+'a' = (reserve_str('c')+'b')+'a' = ((reserve_str('')+'c')+'b')+'a'='cba',此函数主要实现将字符串进行反转</p> 
<p></p> 
<p></p> 
<p>5、递归算法x(8)需要调用几次函数x(int n)</p> 
<pre><code>class program
 {
     static void Main(string[] args)
     {
         int i;
         i = x(8);
     }
     static int x(int n)
     {
         if (n &lt;= 3)
             return 1;
         else
             return x(n - 2) + x(n - 4) + 1;
     }
 }</code></pre> 
<p>答案：9</p> 
<p></p> 
<p></p> 
<p>6、</p> 
<pre><code>def max_common_divisor(x, y):
    if y == 0:
        return x
    return max_common_divisor(y, x % y)
print(max_common_divisor(10, 4))</code></pre> 
<p>答案解析:</p> 
<p>根据题意，y=4且不等于0，则max_common_divisor(10, 4)=max_common_divisor(4, 2)，此时 y=2且不等于0，则max_common_divisor(4, 2)=max_common_divisor(2,0)，此时y=0，则直接返回此时的 x = 2</p> 
<p></p> 
<p></p> 
<p>7、</p> 
<pre><code>int f(int x){
    return ((x&gt;2) ? x*f(x-1) : 3);
}
int i;
i=f(f(2));</code></pre> 
<p>答案解析：</p> 
<p>首先是将x=2传入，x&gt;2为假，返回值为3，因此f(f(2))的值为f(3)，</p> 
<p>将x=3传入，x&gt;3为真，f(3)的值为3*f(2)=9</p> 
<p></p> 
<p>8、给定下列递归算法的程序段，则f(15)的返回值为（）。</p> 
<pre><code>int f(int n)
{
	if(n &lt; 1)
		return 0;
	if(n &lt;= 4)
		return 1;
	return f(n - 1) + f(n - 2) + f(n - 3) + f(n - 4);	
} </code></pre> 
<p>答案解析：</p> 
<p>本题求解的算法背景为，总共有n节台阶，每次可以走1、2、3，4阶，总共有多少种走法。但本题修改了边界条件。</p> 
<p>即f(1)=f(2)=f(3)=f(4)=1,f(n)=f(n-1)+f(n-2)+f(n-3)+f(n-4),n&gt;=5</p> 
<p>递归式递推可以得到，答案为2500</p> 
<p></p> 
<p>9、</p> 
<p>给定一递归算法的程序段如下（r -l&gt;1），设n=r-l+1，则该算法的时间复杂度为（）</p> 
<pre><code>void f(int l, int r)
{
    for(int i = l; i &lt;= r; i ++ ) a[i] ++ ;
    if(l == r) return ;
    int mid = (l + r) / 2;
    f(l, mid);
    f(mid + 1, r);
    return ;
}
int main()
{
    n = r - l + 1;
    f(l, r);
}</code></pre> 
<p>答案解析：</p> 
<p>根据题意可知n为区间长度，递归树法得，递归树最多有log n层，每层的区间长度加起来都是n（除了未满的那层）。</p> 
<p>代码中内层for循环，每个位置 i 的贡献又都是1，深度乘以层数乘以单个位置的贡献得到时间复杂度为 O（n log n）</p> 
<p></p> 
<p>10、</p> 
<p>给定下面程序段，则执行一次函数f(n)(n&gt;0)的时间复杂度为（）</p> 
<pre><code>int f(int n){
    if(n &lt;= 1) return 2;
    else return f(n - 2) / 2;
}</code></pre> 
<p>答案解析：</p> 
<p>画出递归树进行分析，树高[n/2]+1层，每层O(1)，总时间复杂度为O(n)</p> 
<p></p> 
<p></p> 
<p>11、</p> 
<p></p> 
<p>在Python3中，执行以下函数运行结果为:</p> 
<pre><code class="language-python">def pow(n, k):
    if k == 0:
        return 1
    elif k == 1:
        return n
    else:
        return n * pow(n, k-1)
print(pow(2, 3))</code></pre> 
<p>答案解析：</p> 
<p>此题目 pow(n, k)函数表示计算 n^k，当 k==0 时表示 n^0=1，当 k==1 时表示 n^1=n，如果 k&gt;1时，则执行递归计算 n * pow(n, k-1)，当输入的 n ==2 ，k == 3，返回结果为 2 * pow(2, 2) = 2 * 2 * pow(2, 1) = 2 * 2 * 2 = 8</p> 
<p></p> 
<p>12、</p> 
<p>给定一递归算法的程序段如下（n&gt;2），则该算法的时间复杂度为（）</p> 
<pre><code>int f(int n)
{
    if(n == 2)
        return 3;
    else
        return f(n - 1) * 4;
}</code></pre> 
<p>答案解析：</p> 
<p>使用递归算法，总共调用了n-1次,规模为 O（n） 级别</p> 
<p></p> 
<p>13、以下程序是用来计算两个非负数之间的最大公约数：</p> 
<pre><code>long long gcd(long long x, long long y) { 
    if (y == 0) 
        return x; 
    else 
        return gcd(y, x % y); 
}</code></pre> 
<p>我们假设x,y中最大的那个数的长度为n，基本运算时间复杂度为O(1)，那么该程序的时间复杂度为()：</p> 
<p></p> 
<p>答案解析：对于gcd(a,b),假设a,b中最大的数为a,则若调用了k次，则a&gt;=F(k+2),b&gt;=F(k+1),F(x)为第x个斐波拉切数，而F(x)=m^x/sqrt(5),因此这题最坏时间复杂度应该为O(n)，与这个数的长度成正比</p> 
<p></p> 
<p></p> 
<p>14、</p> 
<pre><code>public class Test {

  public static int count = 0;

  public static void main(String[] args) {
    int i;
    i = x(8);
    System.out.println(count);
  }

  public static int x(int n) {
    count++;
    if (n &lt;= 3)
      return 1;
    else
      return x(n - 2) + x(n - 4) + 1;
  }
}


</code></pre> 
<p>该程序最后输出结果是多少?</p> 
<p></p> 
<p>答案解析：</p> 
<p>问题问的是x(8)调多少次x(n)，而不是x(x(8))，所以答案应该是9</p> 
<p></p> 
<p>15、</p> 
<p>给定下列递归算法的程序段，则输出结果为（）。</p> 
<pre><code>int f(int a, int b, int c) {
	if(c == 1) {
		if(b == 1) {
			if(a == 1)
				return 2;
			else
				return f(a - 1, a - 1, a - 1) + 1;
		} else
			return f(a, b - 1, b - 1) + 1;
	} else
		return f(a, b, c - 1) + 1;
}
int main() {
	int n = 50;
	printf("%d", f(n, n, n));
}</code></pre> 
<p></p> 
<p>答案解析：22101</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/baf4fc3ce1918c59fb1fab0696918dad/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">Gradle系列——常用指令，修改gradle源，Wrapper包装器（源于文档7.5版本，SpringBoot使用）day1-2</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/2fa98b7ac676596db866d2db4134f9a6/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">Altium Designer19 多层板设计教程</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>