<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>C&#43;&#43; memset详解 - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="C&#43;&#43; memset详解" />
<meta property="og:description" content="问题描述:
int * cow = new int[n&#43;1];
memset(cow,0,(n&#43;1)*4);
将N&#43;1个元素置成0,为什么不行
memset是对一个字节的int4个字节,因此*4
但是只能为0,其他例如1就不可以,详见最后一个例子
memest原型 (please type &#34;man memset&#34; in your shell) void *memset(void *s, int c, size_t n); memset:作用是在一段内存块中填充某个给定的值，它对较大的结构体或数组进行清零操作的一种最快方法。
常见的三种错误
第一: 搞反了c 和 n的位置. 一定要记住 如果要把一个char a[20]清零, 一定是 memset(a, 0, 20) 而不是 memset(a, 20, 0) 第二: 过度使用memset, 我想这些程序员可能有某种心理阴影, 他们惧怕未经初始化的内存, 所以他们会写出这样的代码: char buffer[20]; memset(buffer, 0, sizeof((char)*20)); strcpy(buffer, &#34;123&#34;); 这里的memset是多余的. 因为这块内存马上就被覆盖了, 清零没有意义. 第三: 其实这个错误严格来讲不能算用错memset, 但是它经常在使用memset的场合出现 int some_func(struct something *a){ … … memset(a, 0, sizeof(a)); … } 问:为何要用memset置零?" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/6a2e9c3e387b1accfe9f2a44fc01dadc/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2011-12-09T16:56:28+08:00" />
<meta property="article:modified_time" content="2011-12-09T16:56:28+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">C&#43;&#43; memset详解</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p>问题描述:</p> 
<p>int * cow = new int[n+1];</p> 
<p>memset(cow,0,(n+1)*4);</p> 
<p>将N+1个元素置成0,为什么不行</p> 
<p>memset是对一个字节的int4个字节,因此*4</p> 
<p>但是只能为0,其他例如1就不可以,详见最后一个例子</p> 
<p>memest原型 (please type "man memset" in your shell) </p> 
<p> void *memset(void *s,  int c, size_t n); </p> 
<p>memset:作用是在一段内存块中填充某个给定的值，它对较大的结构体或数组进行清零操作的一种最快方法。</p> 
<p>常见的三种错误</p> 
<p>第一: 搞反了c 和 n的位置. </p> 
<p>一定要记住 如果要把一个char a[20]清零, 一定是 memset(a, 0, 20) </p> 
<p>而不是 memset(a, 20,  0) </p> 
<p>第二: 过度使用memset, 我想这些程序员可能有某种心理阴影, 他们惧怕未经初始化的内存, 所以他们会写出这样的代码: </p> 
<p>char buffer[20]; </p> 
<p>memset(buffer, 0, sizeof((char)*20)); </p> 
<p>strcpy(buffer, "123"); </p> 
<p>这里的memset是多余的. 因为这块内存马上就被覆盖了, 清零没有意义. </p> 
<p>第三: 其实这个错误严格来讲不能算用错memset, 但是它经常在使用memset的场合出现 </p> 
<p>int some_func(struct something *a){ </p> 
<p> … </p> 
<p> … </p> 
<p> memset(a, 0, sizeof(a)); </p> 
<p> … </p> 
<p>} </p> 
<p>问:为何要用memset置零?memset( &amp;Address, 0, sizeof(Address))；经常看到这样的用法，其实不用的话，分配数据的时候，剩余的空间也会置零的。</p> 
<p>答:1.如果不清空，可能会在测试当中出现野值。 你做下面的试验看看结果() </p> 
<p>char buf[5]； </p> 
<p>CString str,str1； //memset(buf,0,sizeof(buf))； for(int i = 0；i&lt; 5；i++) { str.Format(“%d “,buf[i])； str1 +=str ； } TRACE(“%s/r/n“,str1)</p> 
<p>2.其实不然！特别是对于字符指针类型的，剩余的部分通常是不会为0的，不妨作一个试验，定义一个字符数组，并输入一串字符，如果不用memset实现清零，使用MessageBox显示出来就会有乱码（0表示NULL，如果有，就默认字符结束，不会输出后面的乱码）</p> 
<p>问:</p> 
<p>如下demo是可以的，能把数组中的元素值都设置成字符1，</p> 
<p>#include &lt;iostream&gt;</p> 
<p>#include &lt;cstring&gt;</p> 
<p>using namespace std;</p> 
<p>int main()</p> 
<p>{<!-- --></p> 
<p>    char a[5];</p> 
<p>    memset(a,'1',5);</p> 
<p>    for(int i = 0;i &lt; 5;i++)</p> 
<p>      cout&lt;&lt;a[i]&lt;&lt;"  ";</p> 
<p>    system("pause");</p> 
<p>    return 0;</p> 
<p>}</p> 
<p>而，如下程序想吧数组中的元素值设置成1，却是不可行的</p> 
<p>#include &lt;iostream&gt;</p> 
<p>#include &lt;cstring&gt;</p> 
<p>using namespace std;</p> 
<p>int main()</p> 
<p>{<!-- --></p> 
<p>    int a[5];</p> 
<p>    memset(a,1,5);//这里改成memset(a,1,5 *sizeof(int))也是不可以的</p> 
<p>    for(int i = 0;i &lt; 5;i++)</p> 
<p>      cout&lt;&lt;a[i]&lt;&lt;"  ";</p> 
<p>    system("pause");</p> 
<p>    return 0;</p> 
<p>}</p> 
<p>问题是：</p> 
<p>1，第一个程序为什么可以，而第二个不行，</p> 
<p>2，不想要用for，或是while循环来初始化int a[5];能做到吗？（有没有一个像memset（）这样的函数初始化）</p> 
<p>答:</p> 
<p>1.因为第一个程序的数组a是字符型的，字符型占据内存大小是1Byte，而memset函数也是以字节为单位进行赋值的，所以你输出没有问题。而第二个程序a是整型的，使用memset还是按字节赋值，这样赋值完以后，每个数组元素的值实际上是0x01010101即十进制的16843009。你看看你输出结果是否这样？ </p> 
<p>2.如果用memset(a,1,20);</p> 
<p>就是对a指向的内存的20个字节进行赋值，每个都用ASCII为1的字符去填充，转为二进制后，1就是00000001,占一个字节。一个INT元素是4字节，合一起就是1000000010000000100000001，就等于 16843009，就完成了对一个INT元素的赋值了。</p> 
<br>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/b7a0f65259dfcd7509dd9053319e8af5/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">HashMap与CorruntHashMap性能对比</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/a649861c6000d3e333747535419accc3/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">C&#43;&#43; rand,srand用法</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>