<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Java 监听器实现 - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Java 监听器实现" />
<meta property="og:description" content="Spring中的观察者模式
发布的事件，Event，ApplicationEvent是一个抽象类继承了EventObject，EventObject是JDK中的类，所有的事件类都建议继承自EventObject。 public abstract class ApplicationEvent extends EventObject{} 事件监听器，ApplicationListener是一个接口，该接口继承了EventListener接口。EventListener接口是JDK中的接口，所有的事件监听器都建议继承EventListener接口。 @FunctionalInterface public interface ApplicationListener&lt;E extends ApplicationEvent&gt; extends EventListener {} 事件发布，ApplicationEventPublisher，ApplicationContext继承该接口，并在抽象实现类AbstractApplicationContext中做了实现。 applicationContext.publishEvent(new FileParseEvent(this, streamBean)); AbstractApplicationContext类中publishEvent方法实现：
/** * Publish the given event to all listeners. * @param event the event to publish (may be an {@link ApplicationEvent} * or a payload object to be turned into a {@link PayloadApplicationEvent}) * @param eventType the resolved event type, if known * @since 4.2 */ protected void publishEvent(Object event, @Nullable ResolvableType eventType) { Assert." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/fd70ac7b50a1e410919fd4e8211fedc0/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-03-15T17:03:14+08:00" />
<meta property="article:modified_time" content="2023-03-15T17:03:14+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Java 监听器实现</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p><strong>Spring中的观察者模式</strong></p> 
<ul><li>发布的事件，Event，ApplicationEvent是一个抽象类继承了EventObject，EventObject是JDK中的类，所有的事件类都建议继承自EventObject。</li></ul> 
<pre><code>public abstract class ApplicationEvent extends EventObject{}
</code></pre> 
<ul><li>事件监听器，ApplicationListener是一个接口，该接口继承了EventListener接口。EventListener接口是JDK中的接口，所有的事件监听器都建议继承EventListener接口。</li></ul> 
<pre><code>@FunctionalInterface
public interface ApplicationListener&lt;E extends ApplicationEvent&gt; extends EventListener {}
</code></pre> 
<ul><li>事件发布，ApplicationEventPublisher，ApplicationContext继承该接口，并在抽象实现类AbstractApplicationContext中做了实现。</li></ul> 
<pre><code>applicationContext.publishEvent(new FileParseEvent(this, streamBean));
</code></pre> 
<p>AbstractApplicationContext类中publishEvent方法实现：</p> 
<pre><code>	/**
	 * Publish the given event to all listeners.
	 * @param event the event to publish (may be an {@link ApplicationEvent}
	 * or a payload object to be turned into a {@link PayloadApplicationEvent})
	 * @param eventType the resolved event type, if known
	 * @since 4.2
	 */
	protected void publishEvent(Object event, @Nullable ResolvableType eventType) {
		Assert.notNull(event, "Event must not be null");

		// Decorate event as an ApplicationEvent if necessary
		ApplicationEvent applicationEvent;
		if (event instanceof ApplicationEvent) {
			applicationEvent = (ApplicationEvent) event;
		}
		else {
			applicationEvent = new PayloadApplicationEvent&lt;&gt;(this, event);
			if (eventType == null) {
				eventType = ((PayloadApplicationEvent&lt;?&gt;) applicationEvent).getResolvableType();
			}
		}

		// Multicast right now if possible - or lazily once the multicaster is initialized
		if (this.earlyApplicationEvents != null) {
			this.earlyApplicationEvents.add(applicationEvent);
		}
		else {
		    // 事件发布委托getApplicationEventMulticaster来执行
			getApplicationEventMulticaster().multicastEvent(applicationEvent, eventType);
		}

		// Publish event via parent context as well...
		if (this.parent != null) {
			if (this.parent instanceof AbstractApplicationContext) {
				((AbstractApplicationContext) this.parent).publishEvent(event, eventType);
			}
			else {
				this.parent.publishEvent(event);
			}
		}
	}
</code></pre> 
<p>ApplicationEventMulticaster的multicastEvent方法的实现在SimpleApplicationEventMulticaster类中：</p> 
<pre><code>	@Override
	public void multicastEvent(final ApplicationEvent event, @Nullable ResolvableType eventType) {
		ResolvableType type = (eventType != null ? eventType : resolveDefaultEventType(event));
		Executor executor = getTaskExecutor();
		// 获得监听器集合，遍历监听器
		for (ApplicationListener&lt;?&gt; listener : getApplicationListeners(event, type)) {
			if (executor != null) {
				executor.execute(() -&gt; invokeListener(listener, event));
			}
			else {
				invokeListener(listener, event);
			}
		}
	}
</code></pre> 
<pre><code>	protected void invokeListener(ApplicationListener&lt;?&gt; listener, ApplicationEvent event) {
		ErrorHandler errorHandler = getErrorHandler();
		if (errorHandler != null) {
			try {
				doInvokeListener(listener, event);
			}
			catch (Throwable err) {
				errorHandler.handleError(err);
			}
		}
		else {
			doInvokeListener(listener, event);
		}
	}
</code></pre> 
<pre><code>	@SuppressWarnings({"rawtypes", "unchecked"})
	private void doInvokeListener(ApplicationListener listener, ApplicationEvent event) {
		try {
			listener.onApplicationEvent(event);
		}
		catch (ClassCastException ex) {
			String msg = ex.getMessage();
			if (msg == null || matchesClassCastMessage(msg, event.getClass()) ||
					(event instanceof PayloadApplicationEvent &amp;&amp;
							matchesClassCastMessage(msg, ((PayloadApplicationEvent) event).getPayload().getClass()))) {
				// Possibly a lambda-defined listener which we could not resolve the generic event type for
				// -&gt; let's suppress the exception.
				Log loggerToUse = this.lazyLogger;
				if (loggerToUse == null) {
					loggerToUse = LogFactory.getLog(getClass());
					this.lazyLogger = loggerToUse;
				}
				if (loggerToUse.isTraceEnabled()) {
					loggerToUse.trace("Non-matching event type for listener: " + listener, ex);
				}
			}
			else {
				throw ex;
			}
		}
	}
</code></pre> 
<p>这就执行了了onApplicationEvent方法，这里是事件发生的地方。</p> 
<h3><a id="spring_123"></a>spring如何根据事件找到对应的监听器</h3> 
<p>再spring容器初始化的时候，也就是refresh方法中</p> 
<pre><code>public void refresh() throws BeansException, IllegalStateException {
    synchronized (this.startupShutdownMonitor) {
        ......
        try {
            ......
            // Initialize event multicaster for this context.
            //初始化一个事件注册表
            initApplicationEventMulticaster();
            ......
            // Check for listener beans and register them.
            //注册事件监听器
            registerListeners();

            ......
        }
    }
}
</code></pre> 
<p>initApplicationEventMulticaster方法初始化事件注册表：</p> 
<pre><code>protected void initApplicationEventMulticaster() {
    //获得beanFactory
    ConfigurableListableBeanFactory beanFactory = getBeanFactory();
    //先查找BeanFactory中是否有ApplicationEventMulticaster
    if (beanFactory.containsLocalBean(APPLICATION_EVENT_MULTICASTER_BEAN_NAME)) {
        this.applicationEventMulticaster =
                beanFactory.getBean(APPLICATION_EVENT_MULTICASTER_BEAN_NAME, ApplicationEventMulticaster.class);
    }
    else {//如果BeanFactory中不存在，就创建一个SimpleApplicationEventMulticaster
        this.applicationEventMulticaster = new SimpleApplicationEventMulticaster(beanFactory);
        beanFactory.registerSingleton(APPLICATION_EVENT_MULTICASTER_BEAN_NAME, this.applicationEventMulticaster);
    }
}
</code></pre> 
<p>在AbstractApplicationEventMulticaster类中有如下属性：</p> 
<pre><code>public abstract class AbstractApplicationEventMulticaster
		implements ApplicationEventMulticaster, BeanClassLoaderAware, BeanFactoryAware {
	// 注册表
	private final DefaultListenerRetriever defaultRetriever = new DefaultListenerRetriever();
	// 注册表缓存
	final Map&lt;ListenerCacheKey, CachedListenerRetriever&gt; retrieverCache = new ConcurrentHashMap&lt;&gt;(64);

	@Nullable
	private ClassLoader beanClassLoader;

	@Nullable
	private ConfigurableBeanFactory beanFactory;
</code></pre> 
<p>DefaultListenerRetriever 的结构如下：</p> 
<pre><code>	private class DefaultListenerRetriever {
		// 用来存放监听事件
		public final Set&lt;ApplicationListener&lt;?&gt;&gt; applicationListeners = new LinkedHashSet&lt;&gt;();
		// 存放监听事件的类名称
		public final Set&lt;String&gt; applicationListenerBeans = new LinkedHashSet&lt;&gt;();
</code></pre> 
<p>初始化注册表之后，就会把事件注册到注册表中，registerListeners()：</p> 
<pre><code>protected void registerListeners() {
    //获取所有的Listener，把事件的bean放到ApplicationEventMulticaster中
    for (ApplicationListener&lt;?&gt; listener : getApplicationListeners()) {
        getApplicationEventMulticaster().addApplicationListener(listener);
    }
    // Do not initialize FactoryBeans here: We need to leave all regular beans
    // uninitialized to let post-processors apply to them!
    String[] listenerBeanNames = getBeanNamesForType(ApplicationListener.class, true, false);
    //把事件的名称放到ApplicationListenerBean里去。
    for (String lisName : listenerBeanNames) {
        getApplicationEventMulticaster().addApplicationListenerBean(lisName);
    }
}
</code></pre> 
<p>Spring使用反射机制，通过方法getBeansOfType获取所有继承了ApplicationListener接口的监听器，然后把监听器放到注册表中，所以我们可以在Spring配置文件中配置自定义监听器，在Spring初始化的时候，会把监听器自动注册到注册表中去。</p> 
<p>例：<br> 要发布的事件：</p> 
<pre><code>@Getter
@Setter
public class FileParseEvent extends ApplicationEvent {

    private StreamBean streamBean;
    
    /**
     * Create a new {@code ApplicationEvent}.
     *
     * @param source the object on which the event initially occurred or with
     *               which the event is associated (never {@code null})
     */
    public FileParseEvent(Object source, StreamBean streamBean) {
        super(source);
        this.streamBean = streamBean;
    }
}
</code></pre> 
<p>事件发布的动作</p> 
<pre><code> applicationContext.publishEvent(new FileParseEvent(this, streamBean));
</code></pre> 
<p>处理事件</p> 
<pre><code>@Slf4j
@Component
public class FileParseListener implements ApplicationListener&lt;FileParseEvent&gt; {
    @Async
    @Override
    public void onApplicationEvent(FileParseEvent event) {
      // 具体处理代码
    }
}
</code></pre>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/85a57bf53afdadea52f88c6fb5c81e89/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">使用jetson xavier 运行jetson-io.py闪退</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/6ab270b922ae59b9a6b8675f0e16821c/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">JSON.parse(JSON.stringify())实现深拷贝的缺点</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>