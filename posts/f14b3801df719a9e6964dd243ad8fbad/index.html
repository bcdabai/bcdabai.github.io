<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>K8S：pod资源限制及探针 - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="K8S：pod资源限制及探针" />
<meta property="og:description" content="文章目录 一.pod资源限制1.pod资源限制方式2.pod资源限制指定时指定的参数（1）request 资源（2） limit 资源（3）两种资源匹配方式 3.资源限制的示例（1）官网示例（2）Pod和容器的资源请求和限制格式（3）CPU 资源单位介绍（4）内存资源单位（5）资源限制示例1：（6）资源限制示例2： 二.健康检查：又称为探针（Probe）1. 探针的规则2.Probe支持三种检查方法3.探针三种方式示例（1）exec方式（2）httpGet方式（3）tcpSocket方式（4）就绪检测示例（5）示例5：就绪检测2（6）启动、退出动作 三.扩展1.pod的状态2.Container生命周期3.pod的生命周期 总：1.pod的资源限制2.pod容器探针3.三种探测方式：4.pod容器的启动动作和退出的动作 一.pod资源限制 对pod资源限制原因：高并发占用所有的cpu资源、内存资源、会造成雪崩，
方式：对pod做限制、对k8s做限制
1.pod资源限制方式 当定义 Pod 时可以选择性地为每个容器设定所需要的资源数量。
最常见的可设定资源是 CPU 和内存大小，以及其他类型的资源。
2.pod资源限制指定时指定的参数 （1）request 资源 当为 Pod 中的容器指定了 request 资源时，调度器就使用该信息来决定将 Pod 调度到哪个节点上。
（2） limit 资源 当还为容器指定了 limit 资源时，kubelet 就会确保运行的容器不会使用超出所设的 limit 资源量。kubelet 还会为容器预留所设的 request 资源量， 供该容器使用。
如果 Pod 运行所在的节点具有足够的可用资源，容器可以使用超出所设置的 request 资源量。不过，容器不可以使用超出所设置的 limit 资源量。
（3）两种资源匹配方式 如果给容器设置了内存的 limit 值，但未设置内存的 request 值，Kubernetes 会自动为其设置与内存 limit 相匹配的 request 值。 类似的，如果给容器设置了 CPU 的 limit 值但未设置 CPU 的 request 值，则 Kubernetes 自动为其设置 CPU 的 request 值 并使之与 CPU 的 limit 值匹配。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/f14b3801df719a9e6964dd243ad8fbad/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-09-20T17:05:42+08:00" />
<meta property="article:modified_time" content="2023-09-20T17:05:42+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">K8S：pod资源限制及探针</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-light">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p></p> 
<div class="toc"> 
 <h4>文章目录</h4> 
 <ul><li><a href="#pod_2" rel="nofollow">一.pod资源限制</a></li><li><ul><li><a href="#1pod_8" rel="nofollow">1.pod资源限制方式</a></li><li><a href="#2pod_14" rel="nofollow">2.pod资源限制指定时指定的参数</a></li><li><ul><li><a href="#1request__16" rel="nofollow">（1）request 资源</a></li><li><a href="#2_limit__20" rel="nofollow">（2） limit 资源</a></li><li><a href="#3_26" rel="nofollow">（3）两种资源匹配方式</a></li></ul> 
   </li><li><a href="#3_30" rel="nofollow">3.资源限制的示例</a></li><li><ul><li><a href="#1_32" rel="nofollow">（1）官网示例</a></li><li><a href="#2Pod_37" rel="nofollow">（2）Pod和容器的资源请求和限制格式</a></li><li><a href="#3CPU__47" rel="nofollow">（3）CPU 资源单位介绍</a></li><li><a href="#4_55" rel="nofollow">（4）内存资源单位</a></li><li><a href="#51_68" rel="nofollow">（5）资源限制示例1：</a></li><li><a href="#62_150" rel="nofollow">（6）资源限制示例2：</a></li></ul> 
  </li></ul> 
  </li><li><a href="#Probe_220" rel="nofollow">二.健康检查：又称为探针（Probe）</a></li><li><ul><li><a href="#1__222" rel="nofollow">1. 探针的规则</a></li><li><a href="#2Probe_232" rel="nofollow">2.Probe支持三种检查方法</a></li><li><a href="#3_248" rel="nofollow">3.探针三种方式示例</a></li><li><ul><li><a href="#1exec_250" rel="nofollow">（1）exec方式</a></li><li><a href="#2httpGet_327" rel="nofollow">（2）httpGet方式</a></li><li><a href="#3tcpSocket_431" rel="nofollow">（3）tcpSocket方式</a></li><li><a href="#4_509" rel="nofollow">（4）就绪检测示例</a></li><li><a href="#552_581" rel="nofollow">（5）示例5：就绪检测2</a></li><li><a href="#6_704" rel="nofollow">（6）启动、退出动作</a></li></ul> 
  </li></ul> 
  </li><li><a href="#_786" rel="nofollow">三.扩展</a></li><li><ul><li><a href="#1pod_788" rel="nofollow">1.pod的状态</a></li><li><a href="#2Container_800" rel="nofollow">2.Container生命周期</a></li><li><a href="#3pod_810" rel="nofollow">3.pod的生命周期</a></li></ul> 
  </li><li><a href="#_817" rel="nofollow">总：</a></li><li><ul><li><a href="#1pod_819" rel="nofollow">1.pod的资源限制</a></li><li><a href="#2pod_825" rel="nofollow">2.pod容器探针</a></li><li><a href="#3_833" rel="nofollow">3.三种探测方式：</a></li><li><a href="#4pod_840" rel="nofollow">4.pod容器的启动动作和退出的动作</a></li></ul> 
 </li></ul> 
</div> 
<p></p> 
<h2><a id="pod_2"></a>一.pod资源限制</h2> 
<p>对pod资源限制原因：高并发占用所有的cpu资源、内存资源、会造成雪崩，</p> 
<p>方式：对pod做限制、对k8s做限制</p> 
<h3><a id="1pod_8"></a>1.pod资源限制方式</h3> 
<p>当定义 Pod 时可以选择性地为每个容器设定所需要的资源数量。</p> 
<p>最常见的可设定资源是 <strong>CPU</strong> 和<strong>内存大小</strong>，以及其他类型的资源。</p> 
<h3><a id="2pod_14"></a>2.pod资源限制指定时指定的参数</h3> 
<h4><a id="1request__16"></a>（1）request 资源</h4> 
<p>当为 Pod 中的容器指定了 request 资源时，调度器就使用该信息来决定将 <strong>Pod 调度到哪个节点上</strong>。</p> 
<h4><a id="2_limit__20"></a>（2） limit 资源</h4> 
<p>当还为容器指定了 limit 资源时，kubelet 就会确保<strong>运行的容器不会使用超出所设的 limit 资</strong>源量。kubelet 还会为容器<strong>预留所设的 request 资源量</strong>， 供该容器使用。</p> 
<p>如果 Pod 运行所在的节点具有足够的可用资源，容器可以使用超出所设置的 request 资源量。不过，容器不可以使用超出所设置的 limit 资源量。</p> 
<h4><a id="3_26"></a>（3）两种资源匹配方式</h4> 
<p>如果给容器设置了内存的 limit 值，但未设置内存的 request 值，Kubernetes 会自动为其设置与内存 limit 相匹配的 request 值。 类似的，如果给容器设置了 CPU 的 limit 值但未设置 CPU 的 request 值，则 Kubernetes 自动为其设置 CPU 的 request 值 并使之与 CPU 的 limit 值匹配。</p> 
<h3><a id="3_30"></a>3.资源限制的示例</h3> 
<h4><a id="1_32"></a>（1）官网示例</h4> 
<p>官网示例：<br> https://kubernetes.io/docs/concepts/configuration/manage-compute-resources-container/</p> 
<h4><a id="2Pod_37"></a>（2）Pod和容器的资源请求和限制格式</h4> 
<pre><code>#Pod 和 容器 的资源请求和限制：
spec.containers[].resources.requests.cpu		//定义创建容器时预分配的CPU资源
spec.containers[].resources.requests.memory		//定义创建容器时预分配的内存资源
spec.containers[].resources.limits.cpu			//定义 cpu 的资源上限 
spec.containers[].resources.limits.memory		//定义内存的资源上限
</code></pre> 
<h4><a id="3CPU__47"></a>（3）CPU 资源单位介绍</h4> 
<ul><li>CPU 资源的 request 和 limit 以 cpu 为单位。</li><li>Kubernetes 中的一个 cpu 相当于1个 vCPU（1个超线程）。<br> Kubernetes 也支持带小数 CPU 的请求。</li><li>spec.containers[].resources.requests.cpu 为 0.5 的容器能够获得一个 cpu 的一半 CPU 资源（类似于Cgroup对CPU资源的时间分片）。表达式 0.1 等价于表达式 100m（毫核），表示每 1000 毫秒内容器可以使用的 CPU 时间总量为 0.1*1000 毫秒。</li><li>Kubernetes 不允许设置精度小于 1m 的 CPU 资源。</li></ul> 
<h4><a id="4_55"></a>（4）内存资源单位</h4> 
<ul><li>内存的 request 和 limit 以字节为单位。可以以整数表示，或者以10为底数的指数的单位（E、P、T、G、M、K）来表示， 或者以2为底数的指数的单位（Ei、Pi、Ti、Gi、Mi、Ki）来表示。<br> 如：1KB=10<sup>3=1000，1MB=10</sup>6=1000000=1000KB，1GB=10^9=1000000000=1000MB<br> 1KiB=2<sup>10=1024，1MiB=2</sup>20=1048576=1024KiB</li></ul> 
<p>PS：在买硬盘的时候，操作系统报的数量要比产品标出或商家号称的小一些，主要原因是标出的是以 MB、GB为单位的，1GB 就是1,000,000,000Byte，而操作系统是以2进制为处理单位的，因此检查硬盘容量时是以MiB、GiB为单位，1GiB=2^30=1,073,741,824，相比较而言，1GiB要比1GB多出1,073,741,824-1,000,000,000=73,741,824Byte，所以检测实际结果要比标出的少一些。</p> 
<blockquote> 
 <p>官方为 Pod 和容器管理资源介绍</p> 
 <p>https://kubernetes.io/zh-cn/docs/concepts/configuration/manage-resources-containers/</p> 
</blockquote> 
<h4><a id="51_68"></a>（5）资源限制示例1：</h4> 
<pre><code>#资源限制模板
apiVersion: v1
kind: Pod
metadata:
  name: frontend
spec:
  containers:
  - name: app
    image: images.my-company.example/app:v4
    env:
    - name: MYSQL_ROOT_PASSWORD
      value: "password"
    resources:
      requests:
        memory: "64Mi"
        cpu: "250m"   
      limits:
        memory: "128Mi"
        cpu: "500m"
  - name: log-aggregator
    image: images.my-company.example/log-aggregator:v6
    resources:
      requests:
        memory: "64Mi"
        cpu: "250m"
      limits:
        memory: "128Mi"
        cpu: "500m"
</code></pre> 
<pre><code>vim pod1.yaml 

apiVersion: v1
kind: Pod
metadata:
  name: frontend
spec:
  containers:
  - name: web
    image: nginx:latest
    imagePullPolicy: IfNotPresent
    resources:
      requests:
        memory: "64Mi"
        cpu: "250m"
      limits:
        memory: "128Mi"
        cpu: "500m"
  - name: db
    image: mysql
    env:
    - name: MYSQL_ROOT_PASSWORD
      value: "abc123"
    resources:
      requests:
        memory: "64Mi"
        cpu: "250m"
      limits:
        memory: "128Mi"
        cpu: "500m"
</code></pre> 
<p>此例子中的 Pod 有两个容器。每个容器的 request 值为 0.25 cpu 和 64MiB 内存，每个容器的 limit 值为 0.5 cpu 和 128MiB 内存。那么可以认为该 Pod 的总的资源 request 为 0.5 cpu 和 128 MiB 内存，总的资源 limit 为 1 cpu 和 256MiB 内存。</p> 
<pre><code>kubectl apply -f pod1.yaml
</code></pre> 
<pre><code>kubectl get pod
</code></pre> 
<p><img src="https://images2.imgbox.com/83/60/2XnfOzWK_o.png" alt="外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传"></p> 
<pre><code>kubectl describe pod frontend
</code></pre> 
<p><img src="https://images2.imgbox.com/a7/75/Zykt3dPF_o.png" alt="外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传"></p> 
<h4><a id="62_150"></a>（6）资源限制示例2：</h4> 
<p>前面对pod1的资源限制，这里将cpu的大小进行调整</p> 
<pre><code>vim pod1.yaml
![在这里插入图片描述](https://img-blog.csdnimg.cn/698cf63987e14ea081a9d31b80d540c6.png)

apiVersion: v1
kind: Pod
metadata:
  name: frontend
spec:
  containers:
  - name: web
    image: nginx
    env:
    - name: WEB_ROOT_PASSWORD
      value: "abc123"
      resources:
      requests:
        memory: "64Mi"
        cpu: "250m"
      limits:
        memory: "128Mi"
        cpu: "500m"
  - name: db
    image: mysql
    env:
    - name: MYSQL_ROOT_PASSWORD
      value: "abc123"
      resources:
      requests:
        memory: "512Mi"  
        cpu: "0.5"
      limits:
        memory: "1Gi"    
        cpu: "1"
</code></pre> 
<pre><code>kubectl apply -f pod1.yaml
kubectl describe pod frontend
</code></pre> 
<p><img src="https://images2.imgbox.com/ca/fa/sR7v6ffA_o.png" alt="外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传"></p> 
<p><img src="https://images2.imgbox.com/89/1a/mpwZPkkd_o.png" alt="外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传"></p> 
<pre><code> kubectl get pods -o wide
 
NAME       READY   STATUS    RESTARTS   AGE    IP            NODE     NOMINATED NODE   READINESS GATES
frontend   2/2     Running   0          100s   10.244.2.70   node01   &lt;none&gt;           &lt;none&gt;
</code></pre> 
<pre><code>kubectl describe nodes node02				
</code></pre> 
<p><img src="https://images2.imgbox.com/03/f3/IptYyKx5_o.png" alt="外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传"></p> 
<pre><code>#查看mysql创建的pod日志
kubectl logs frontend -c db
</code></pre> 
<p><img src="https://images2.imgbox.com/0e/84/BbziE1Fu_o.png" alt="在这里插入图片描述"></p> 
<h2><a id="Probe_220"></a>二.健康检查：又称为探针（Probe）</h2> 
<h3><a id="1__222"></a>1. 探针的规则</h3> 
<p>探针是由kubelet对容器执行的定期诊断。<br> （1）livenessProbe ：判断容器是否正在运行。如果探测失败，则kubelet会杀死容器，并且容器将根据 restartPolicy 来设置 Pod 状态。 如果容器不提供存活探针，则默认状态为Success。</p> 
<p>（2）readinessProbe ：判断容器是否准备好接受请求。如果探测失败，端点控制器将从与 Pod 匹配的所有 service 址endpoints 中剔除删除该Pod的IP地。 初始延迟之前的就绪状态默认为Failure。如果容器不提供就绪探针，则默认状态为Success。</p> 
<p>（3）startupProbe（这个1.17版本增加的）：判断容器内的应用程序是否已启动，主要针对于不能确定具体启动时间的应用。如果配置了 startupProbe 探测，在则在 startupProbe 状态为 Success 之前，其他所有探针都处于无效状态，直到它成功后其他探针才起作用。 如果 startupProbe 失败，kubelet 将杀死容器，容器将根据 restartPolicy 来重启。如果容器没有配置 startupProbe， 则默认状态为 Success。<br> #注：以上规则可以同时定义。在readinessProbe检测成功之前，Pod的running状态是不会变成ready状态的。</p> 
<h3><a id="2Probe_232"></a>2.Probe支持三种检查方法</h3> 
<p>（1）exec ：在容器内执行指定命令。如果命令退出时返回码为0则认为诊断成功。</p> 
<p>（2）tcpSocket ：对指定端口上的容器的IP地址进行TCP检查（三次握手）。如果端口打开，则诊断被认为是成功的。</p> 
<p>（3）httpGet ：对指定的端口和路径上的容器的IP地址执行HTTPGet请求。如果响应的状态码大于等于200且小于400，则诊断被认为是成功的</p> 
<p>每次探测都将获得以下三种结果之一：<br> ●成功：容器通过了诊断。<br> ●失败：容器未通过诊断。<br> ●未知：诊断失败，因此不会采取任何行动</p> 
<blockquote> 
 <p>官网示例：<br> https://kubernetes.io/docs/tasks/configure-pod-container/configure-liveness-readiness-startup-probes/</p> 
</blockquote> 
<h3><a id="3_248"></a>3.探针三种方式示例</h3> 
<h4><a id="1exec_250"></a>（1）exec方式</h4> 
<pre><code>#exec方式的模板
apiVersion: v1
kind: Pod
metadata:
  labels:
    test: liveness
  name: liveness-exec
spec:
  containers:
  - name: liveness
    image: k8s.gcr.io/busybox
    args:  
    - /bin/sh
    - -c
    - touch /tmp/healthy; sleep 30; rm -rf /tmp/healthy; sleep 60
    livenessProbe:
      exec:
        command:
        - cat
        - /tmp/healthy
      failureThreshold: 1
      initialDelaySeconds: 5
      periodSeconds: 5
</code></pre> 
<blockquote> 
 <p>#initialDelaySeconds：指定 kubelet 在执行第一次探测前应该等待5秒，即第一次探测是在容器启动后的第6秒才开始执行。默认是 0 秒，最小值是 0。<br> #periodSeconds：指定了 kubelet 应该每 5 秒执行一次存活探测。默认是 10 秒。最小值是 1。<br> #failureThreshold: 当探测失败时，Kubernetes 将在放弃之前重试的次数。 存活探测情况下的放弃就意味着重新启动容器。就绪探测情况下的放弃 Pod 会被打上未就绪的标签。默认值是 3。最小值是 1。<br> #timeoutSeconds：探测的超时后等待多少秒。默认值是 1 秒。最小值是 1。（在 Kubernetes 1.20 版本之前，exec 探针会忽略 timeoutSeconds 探针会无限期地 持续运行，甚至可能超过所配置的限期，直到返回结果为止。）</p> 
</blockquote> 
<p>可以看到 Pod 中只有一个容器。kubelet 在执行第一次探测前需要等待 5 秒，kubelet 会每 5 秒执行一次存活探测。kubelet 在容器内执行命令 cat /tmp/healthy 来进行探测。如果命令执行成功并且返回值为 0，kubelet 就会认为这个容器是健康存活的。 当到达第 31 秒时，这个命令返回非 0 值，kubelet 会杀死这个容器并重新启动它。</p> 
<pre><code>#示例：、
vim pod2.yaml

apiVersion: v1
kind: Pod
metadata:
  name: liveness-exec
  namespace: default
spec:
  containers:
  - name: liveness-exec-container
    image: busybox
    imagePullPolicy: IfNotPresent
    command: ["/bin/sh","-c","touch /tmp/live ; sleep 30; rm -rf /tmp/live; sleep 3600"]
    livenessProbe:
      exec:
        command: ["test","-e","/tmp/live"]
      initialDelaySeconds: 1
      periodSeconds: 3
</code></pre> 
<pre><code>kubectl create -f exec.yaml

kubectl describe pods liveness-exec
</code></pre> 
<p><img src="https://images2.imgbox.com/46/3e/xJL0GHqd_o.png" alt="外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传"></p> 
<p><img src="https://images2.imgbox.com/b9/c9/Y9zQdoEW_o.png" alt="外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传"></p> 
<pre><code>kubectl get pods -w
</code></pre> 
<p><img src="https://images2.imgbox.com/f5/0f/2D8JserA_o.png" alt="外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传"></p> 
<h4><a id="2httpGet_327"></a>（2）httpGet方式</h4> 
<pre><code>#模板
apiVersion: v1
kind: Pod
metadata:
  labels:
    test: liveness
  name: liveness-http
spec:
  containers:

  - name: liveness
    image: k8s.gcr.io/liveness
    args:
    - /server
      livenessProbe:
      httpGet:
        path: /healthz
        port: 8080
        httpHeaders:
        - name: Custom-Header
          value: Awesome
          initialDelaySeconds: 3
          periodSeconds: 3
</code></pre> 
<p>在这个配置文件中，可以看到 Pod 也只有一个容器。initialDelaySeconds 字段告诉 kubelet 在执行第一次探测前应该等待 3 秒。periodSeconds 字段指定了 kubelet 每隔 3 秒执行一次存活探测。kubelet 会向容器内运行的服务（服务会监听 8080 端口）发送一个 HTTP GET 请求来执行探测。如果服务器上 /healthz 路径下的处理程序返回成功代码，则 kubelet 认为容器是健康存活的。如果处理程序返回失败代码，则 kubelet 会杀死这个容器并且重新启动它。</p> 
<p>任何大于或等于 200 并且小于 400 的返回代码标示成功，其它返回代码都标示失败。</p> 
<pre><code>vim httpget.yaml
apiVersion: v1
kind: Pod
metadata:
  name: liveness-httpget
  namespace: default
spec:
  containers:
  - name: liveness-httpget-container
    image: soscscs/myapp:v1
    imagePullPolicy: IfNotPresent
    ports:
    - name: http
      containerPort: 80
    livenessProbe:
      httpGet:
        port: http
        path: /index.html
      initialDelaySeconds: 1
      periodSeconds: 3
      timeoutSeconds: 10
</code></pre> 
<p>liveness http-get http://IP:80/index.html 延迟1秒 timeout=1s period(频率)=3<br> success=1 failure（失败）=3 机器会杀死容器 重启</p> 
<pre><code>kubectl create -f httpget.yaml
kubectl get pod
</code></pre> 
<p><img src="https://images2.imgbox.com/38/56/iOVq62mx_o.png" alt="外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传"></p> 
<pre><code>#定义进入访问
kubectl exec -it liveness-httpget sh
#到nginx目录
cd /usr/share/nginx/
cd html/
</code></pre> 
<pre><code>#另开终端可以查看日志查看返回是否是正常的
kubectl logs liveness-httpget
</code></pre> 
<p><img src="https://images2.imgbox.com/31/d9/lm9AkNDL_o.png" alt="外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传"></p> 
<pre><code>#在原先的终端删除index.html探针会检测存活，如果再次进入查看存在就证明探针正常
rm -rf index.html
</code></pre> 
<p><img src="https://images2.imgbox.com/ce/4e/K1bVz5CG_o.png" alt="外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传"></p> 
<p><img src="https://images2.imgbox.com/fe/63/HE8O9qlV_o.png" alt="外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传"></p> 
<pre><code>kubectl exec -it liveness-httpget sh
</code></pre> 
<p><img src="https://images2.imgbox.com/66/f9/zWH9TPGs_o.png" alt="外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传"></p> 
<p><img src="https://images2.imgbox.com/fe/89/X5ptETxh_o.png" alt="外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传"></p> 
<h4><a id="3tcpSocket_431"></a>（3）tcpSocket方式</h4> 
<pre><code>#模板
apiVersion: v1
kind: Pod
metadata:
  name: goproxy
  labels:
    app: goproxy
spec:
  containers:

  - name: goproxy
    image: k8s.gcr.io/goproxy:0.1
    ports:
    - containerPort: 8080
      readinessProbe:
      tcpSocket:
        port: 8080
      initialDelaySeconds: 5
      periodSeconds: 10
      livenessProbe:
      tcpSocket:
        port: 8080
      initialDelaySeconds: 15
      periodSeconds: 20
</code></pre> 
<p>这个例子同时使用 readinessProbe 和 livenessProbe 探测。kubelet 会在容器启动 5 秒后发送第一个 readinessProbe 探测。这会尝试连接 goproxy 容器的 8080 端口。如果探测成功，kubelet 将继续每隔 10 秒运行一次检测。除了 readinessProbe 探测，这个配置包括了一个 livenessProbe 探测。kubelet 会在容器启动 15 秒后进行第一次 livenessProbe 探测。就像 readinessProbe 探测一样，会尝试连接 goproxy 容器的 8080 端口。如果 livenessProbe 探测失败，这个容器会被重新启动。</p> 
<pre><code>vim tcpsocket.yaml

apiVersion: v1
kind: Pod
metadata:
  name: probe-tcp
spec:
  containers:

  - name: nginx
    image: soscscs/myapp:v1
    livenessProbe:
      initialDelaySeconds: 5
      timeoutSeconds: 1
      tcpSocket:
        port: 8080
      periodSeconds: 10
      failureThreshold: 2
</code></pre> 
<pre><code>kubectl create -f tcpsocket.yaml

kubectl exec -it probe-tcp  -- netstat -natp
</code></pre> 
<p><img src="https://images2.imgbox.com/bb/d6/Xu8eTPTd_o.png" alt="外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传"></p> 
<pre><code>kubectl get pods -w

NAME        READY   STATUS    RESTARTS   AGE
probe-tcp          1/1     Running            1          88s

probe-tcp          1/1     Running            2          90s
       #第一次是 init(5秒) + period(10秒) * 2
probe-tcp          1/1     Running            3          110s
       #第二次是 period(10秒) + period(10秒)  重试了两次
probe-tcp          1/1     Running            4          2m10s
</code></pre> 
<p><img src="https://images2.imgbox.com/b1/c8/EXwmnhq9_o.png" alt="外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传"></p> 
<h4><a id="4_509"></a>（4）就绪检测示例</h4> 
<pre><code>vim readiness-httpget.yaml
apiVersion: v1
kind: Pod
metadata:
  name: readiness-httpget
  namespace: default
spec:
  containers:
  - name: readiness-httpget-container
    image: soscscs/myapp:v1                               #指定了容器使用的镜像
    imagePullPolicy: IfNotPresent                         #指定了镜像拉取策略为仅在本地不存在时才拉取
    ports:                                                              #定义了容器暴露的端口，这里使用的是 80 端口
    - name: http
      containerPort: 80
    readinessProbe:                                            #就绪探测配置，用于检查容器是否准备好接受请求
      httpGet:                                                      #指定了进行 HTTP GET 请求的方式进行探
        port: 80                                                    #探测请求将发送到容器的 80 端口
        path: /index1.html                                    #探测请求发送的路径为 "/index1.html"
      initialDelaySeconds: 1                               #容器启动后等待 1 秒后开始进行就绪探测
      periodSeconds: 3                                     #进行就绪探测的间隔为 3 秒
    livenessProbe:                                           #存活探测配置，用于检查容器是否存活
      httpGet:                                                   #指定了进行 HTTP GET 请求的方式进行探测
        port: http                                               #探测请求将发送到容器的 "http" 端口（实际上可能是 "http" 端口的映射，比如 8080）
        path: /index.html                                  #探测请求发送的路径为 "/index.html"
      initialDelaySeconds: 1                           #器启动后等待 1 秒后开始进行存活探测
      periodSeconds: 3                                  #进行存活探测的间隔为 3 秒
      timeoutSeconds: 10                              #探测请求的超时时间为 10 秒
</code></pre> 
<pre><code>kubectl create -f readiness-httpget.yaml
</code></pre> 
<pre><code>#readiness探测失败，无法进入READY状态
kubectl get pods 
</code></pre> 
<p><img src="https://images2.imgbox.com/bf/1d/p5KIfWnA_o.png" alt="外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传"></p> 
<pre><code>kubectl exec -it readiness-httpget sh
cd /usr/share/nginx/html/
ls
50x.html    index.html
echo 123 &gt; index1.html 
exit
</code></pre> 
<p><img src="https://images2.imgbox.com/ea/b3/KOHdlScT_o.png" alt="外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传"></p> 
<pre><code>kubectl get pods 
</code></pre> 
<p><img src="https://images2.imgbox.com/33/09/hnyTsN8w_o.png" alt="外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传"></p> 
<pre><code>kubectl exec -it readiness-httpget -- rm -rf /usr/share/nginx/html/index.html

kubectl get pods -w
</code></pre> 
<p><img src="https://images2.imgbox.com/1e/a9/DFUftRbC_o.png" alt="外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传"></p> 
<h4><a id="552_581"></a>（5）示例5：就绪检测2</h4> 
<pre><code>vim readiness-myapp.yaml
---
apiVersion: v1
kind: Pod
metadata:
apiVersion: v1
kind: Pod
metadata:
  name: myapp1
  labels:
    app: myapp
spec:
  containers:
  - name: myapp
    image: soscscs/myapp:v1
    ports:
    - name: http
      containerPort: 80
    readinessProbe:
      httpGet:
        port: 80
        path: /index.html
      initialDelaySeconds: 5
      periodSeconds: 5
      timeoutSeconds: 10
---
apiVersion: v1
kind: Pod
metadata:
  name: myapp2
  labels:
    app: myapp
spec:
  containers:
  - name: myapp
    image: soscscs/myapp:v1
    ports:
    - name: http
      containerPort: 80
    readinessProbe:
      httpGet:
        port: 80
        path: /index.html
      initialDelaySeconds: 5
      periodSeconds: 5
      timeoutSeconds: 10
---
apiVersion: v1
kind: Pod
metadata:
  name: myapp3
  labels:
    app: myapp
spec:
  containers:
  - name: myapp
    image: soscscs/myapp:v1
    ports:
    - name: http
      containerPort: 80
    readinessProbe:
      httpGet:
        port: 80
        path: /index.html
      initialDelaySeconds: 5
      periodSeconds: 5
      timeoutSeconds: 10
---
apiVersion: v1
kind: Service
metadata:
  name: myapp
spec:
  selector:
    app: myapp
  type: ClusterIP
  ports:
  - name: http
    port: 80
    targetPort: 80
</code></pre> 
<pre><code>kubectl create -f readiness-myapp.yaml
</code></pre> 
<pre><code>kubectl get pods,svc,endpoints -o wide
</code></pre> 
<p><img src="https://images2.imgbox.com/94/18/lHUNM7oB_o.png" alt="外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传"></p> 
<p><img src="https://images2.imgbox.com/f3/af/1KLA6ROR_o.png" alt="外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传"></p> 
<p><img src="https://images2.imgbox.com/11/5f/lKxK3U7N_o.png" alt="外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传"></p> 
<pre><code>kubectl exec -it pod/myapp1 -- rm -rf /usr/share/nginx/html/index.html
</code></pre> 
<p><img src="https://images2.imgbox.com/98/b4/vT8fhnoN_o.png" alt="在这里插入图片描述"></p> 
<pre><code>#readiness探测失败，Pod 无法进入READY状态，且端点控制器将从 endpoints 中剔除删除该 Pod 的 IP 地址
kubectl get pods,svc,endpoints -o wide
</code></pre> 
<p><img src="https://images2.imgbox.com/eb/db/UkRfmJnl_o.png" alt="外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传"></p> 
<p><img src="https://images2.imgbox.com/de/22/R3irsCmq_o.png" alt="外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传"></p> 
<p><img src="https://images2.imgbox.com/a4/4a/VCapF5cB_o.png" alt="外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传"></p> 
<h4><a id="6_704"></a>（6）启动、退出动作</h4> 
<pre><code>#启动、退出动作
vim post.yaml

apiVersion: v1
kind: Pod
metadata:
  name: lifecycle-demo
spec:
  containers:
  - name: lifecycle-demo-container
    image: soscscs/myapp:v1
    lifecycle:   #此为关键字段
      postStart:
        exec:
          command: ["/bin/sh", "-c", "echo Hello from the postStart handler &gt;&gt; /var/log/nginx/message"]      
      preStop:
        exec:
          command: ["/bin/sh", "-c", "echo Hello from the poststop handler &gt;&gt; /var/log/nginx/message"]
    volumeMounts:
    - name: message-log
      mountPath: /var/log/nginx/
      readOnly: false
  initContainers:
  - name: init-myservice
    image: soscscs/myapp:v1
    command: ["/bin/sh", "-c", "echo 'Hello initContainers'   &gt;&gt; /var/log/nginx/message"]
    volumeMounts:
    - name: message-log
      mountPath: /var/log/nginx/
      readOnly: false
  volumes:
  - name: message-log
    hostPath:
      path: /data/volumes/nginx/log/
      type: DirectoryOrCreate
</code></pre> 
<pre><code>kubectl create -f post.yaml
</code></pre> 
<pre><code>kubectl get pods -o wide
</code></pre> 
<p><img src="https://images2.imgbox.com/06/d8/CKhsyAE1_o.png" alt="外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传"></p> 
<pre><code>kubectl exec -it lifecycle-demo -- cat /var/log/nginx/message
</code></pre> 
<p><img src="https://images2.imgbox.com/d2/67/dqdwnY1u_o.png" alt="外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传"></p> 
<p><strong>先看分配在哪一个节点，此文node01 节点操作</strong></p> 
<pre><code>#在 node01 节点上查看
[root@node01 ~]# cd /data/volumes/nginx/log/
[root@node01 log]# ls
access.log  error.log  message
[root@node01 log]# cat message 
Hello initContainers
Hello from the postStart handler
#由上可知，init Container先执行，然后当一个主容器启动后，Kubernetes 将立即发送 postStart 事件。
</code></pre> 
<pre><code>#在master删除 pod 后，再在 node01 节点上查看
kubectl delete pod lifecycle-demo

[root@node01 log]# cat message 
Hello initContainers
Hello from the postStart handler
Hello from the poststop handler
#由上可知，当在容器被终结之前， Kubernetes 将发送一个 preStop 事件。
</code></pre> 
<h2><a id="_786"></a>三.扩展</h2> 
<h3><a id="1pod_788"></a>1.pod的状态</h3> 
<p>（1）pending：pod已经被系统认可了，但是内部的container还没有创建出来。这里包含调度到node上的时间以及下载镜像的时间，会持续一小段时间。</p> 
<p>（2）Running：pod已经与node绑定了（调度成功），而且pod中所有的container已经创建出来，至少有一个容器在运行中，或者容器的进程正在启动或者重启状态。–这里需要注意pod虽然已经Running了，但是内部的container不一定完全可用。因此需要进一步检测container的状态。</p> 
<p>（3）Succeeded：这个状态很少出现，表明pod中的所有container已经成功的terminated了，而且不会再被拉起了。</p> 
<p>（4）Failed：pod中的所有容器都被terminated，至少一个container是非正常终止的。（退出的时候返回了一个非0的值或者是被系统直接终止）</p> 
<p>（5）unknown：由于某些原因pod的状态获取不到，有可能是由于通信问题。 一般情况下pod最常见的就是前两种状态。而且当Running的时候，需要进一步关注container的状态</p> 
<h3><a id="2Container_800"></a>2.Container生命周期</h3> 
<p>（1）Waiting：启动到运行中间的一个等待状态。</p> 
<p>（2）Running：运行状态。</p> 
<p>（3）Terminated：终止状态。 如果没有任何异常的情况下，container应该会从Waiting状态变为Running状态，这时容器可用。</p> 
<p>但如果长时间处于Waiting状态，container会有一个字段reason表明它所处的状态和原因，如果这个原因很容易能标识这个容器再也无法启动起来时，例如ContainerCannotRun，整个服务启动就会迅速返回。（这里是一个失败状态返回的特性，不详细阐述）</p> 
<h3><a id="3pod_810"></a>3.pod的生命周期</h3> 
<p>一个pod的生命周期是从创建开始的<br> （1）生成pause容器:负责不同pod之间通信<br> （2）初始化init容器:由于应用需要有依赖环境才能正常启动，所以由init负责串行启动<br> （3）maincontainer应用容器启动<br> maincontainer启动的时候k8s还会生成三种探针存活（判断容器是否运行正常，如果探测失败则杀掉容器（不是pod），容器会根据容器策略决定是否重启）、就绪（判断pod是否能够进入ready状态，做好接受请求的准备，探测失败后进入notready状态并从service资源的endpoints中剔除，service将不会把访问请求转发给这个pod）、启动（判断容器内的应用是否成功，在探测成功状态为success之前，其他探针都会处于失效状态）可以通过编写yaml文件，对pod中容器启动状态进行监控(这样能通过echo输出内容知道是哪个环节出错方便排错。</p> 
<h2><a id="_817"></a>总：</h2> 
<h3><a id="1pod_819"></a>1.pod的资源限制</h3> 
<p>（1）spec、containers、resources、requests、cpu/memory创建pod容器时需要预留的资源量 （设置0.5 或者500M )</p> 
<p>（2）spec、containers、resources、limits、cpu/memory——pod容器能够使用的资源量的上线 MI Gi （2为底数） M G （19为底数）</p> 
<h3><a id="2pod_825"></a>2.pod容器探针</h3> 
<p>（1）存活探针：判断容器是否运行正常，如果探测失败则杀掉容器（不是pod），容器会根据容器策略决定是否重启</p> 
<p>（2）就绪探针：判断pod是否能够进入ready状态，做好接受请求的准备，探测失败后进入notready状态并从service资源的endpoints中剔除，service将不会把访问请求转发给这个pod（做实验证明）</p> 
<p>（3）启动探针：判断容器内的应用是否成功，在探测成功状态为success之前，其他探针都会处于失效状态</p> 
<h3><a id="3_833"></a>3.三种探测方式：</h3> 
<p>（1）exec：通过command设置执行在容器内执行的linux命令来探测，如果返回状态码为0，则认为探测成功</p> 
<p>（2）httpget：通过httpget请求访问指定容器的url路径，如果返回状态码&gt;=200且&lt;400（2xx、3xx），则为探测成功</p> 
<p>（3）tcpsocket：通过对指定的端口发送tcp连接，如果端口无误且三次握手（tcp连接成功），则为探测成功</p> 
<h3><a id="4pod_840"></a>4.pod容器的启动动作和退出的动作</h3> 
<p>（1）spec、containers、lifecycle、postStart配合exec，command字段，当应用容器启动时，会执行额外的操作<br> （2）spec、containers、lifecycle、postStart配合exec，command字段，当应用容器退出时，会执行perStart操作</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/7af2837d2bc6dfe5b1f383f4312accbe/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">使用OpenCV和ROS发布cv::Mat图像</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/d8526eccdeada98fc75d6430702ad396/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">K8S：pod集群调度及相关操作</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>