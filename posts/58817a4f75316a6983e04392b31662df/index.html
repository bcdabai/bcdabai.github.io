<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Oracle 分析函数使用介绍 - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Oracle 分析函数使用介绍" />
<meta property="og:description" content="分析函数是oracle816引入的一个全新的概念,为我们分析数据提供了一种简单高效的处理方式.在分析
函数出现以前,我们必须使用自联查询,子查询或者内联视图,甚至复杂的存储过程实现的语句,现在只要一
条简单的sql语句就可以实现了,而且在执行效率方面也有相当大的提高.下面我将针对分析函数做一些具
体的说明.
今天我主要给大家介绍一下以下几个函数的使用方法
1. 自动汇总函数rollup,cube,
2. rank 函数, rank,dense_rank,row_number
3. lag,lead函数
4. sum,avg,的移动增加,移动平均数
5. ratio_to_report报表处理函数
6. first,last取基数的分析函数
基础数据
create table t(BILL_MONTH varchar2(6),AREA_CODE varchar2(4),NET_TYPE char(1),LOCAL_FARE number(12,2));
Insert into t
(BILL_MONTH, AREA_CODE, NET_TYPE, LOCAL_FARE)
Values
(&#39;200405&#39;, &#39;5761&#39;, &#39;G&#39;, 7393344.04);
Insert into t
(BILL_MONTH, AREA_CODE, NET_TYPE, LOCAL_FARE)
Values
(&#39;200405&#39;, &#39;5761&#39;, &#39;J&#39;, 5667089.85);
Insert into t
(BILL_MONTH, AREA_CODE, NET_TYPE, LOCAL_FARE)
Values
(&#39;200405&#39;, &#39;5762&#39;, &#39;G&#39;, 6315075.96);
Insert into t
(BILL_MONTH, AREA_CODE, NET_TYPE, LOCAL_FARE)" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/58817a4f75316a6983e04392b31662df/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2006-02-23T16:24:00+08:00" />
<meta property="article:modified_time" content="2006-02-23T16:24:00+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Oracle 分析函数使用介绍</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p>分析函数是oracle816引入的一个全新的概念,为我们分析数据提供了一种简单高效的处理方式.在分析</p> 
<p>函数出现以前,我们必须使用自联查询,子查询或者内联视图,甚至复杂的存储过程实现的语句,现在只要一</p> 
<p>条简单的sql语句就可以实现了,而且在执行效率方面也有相当大的提高.下面我将针对分析函数做一些具</p> 
<p>体的说明.</p> 
<p>今天我主要给大家介绍一下以下几个函数的使用方法<br>1.  自动汇总函数rollup,cube,<br>2.  rank 函数, rank,dense_rank,row_number<br>3.        lag,lead函数<br>4.        sum,avg,的移动增加,移动平均数<br>5.        ratio_to_report报表处理函数<br>6.        first,last取基数的分析函数</p> 
<p><br>基础数据<br>create table t(BILL_MONTH varchar2(6),AREA_CODE varchar2(4),NET_TYPE char(1),LOCAL_FARE </p> 
<p>number(12,2));</p> 
<p>Insert into t<br>   (BILL_MONTH, AREA_CODE, NET_TYPE, LOCAL_FARE)<br> Values<br>   ('200405', '5761', 'G', 7393344.04);<br>Insert into t<br>   (BILL_MONTH, AREA_CODE, NET_TYPE, LOCAL_FARE)<br> Values<br>   ('200405', '5761', 'J', 5667089.85);<br>Insert into t<br>   (BILL_MONTH, AREA_CODE, NET_TYPE, LOCAL_FARE)<br> Values<br>   ('200405', '5762', 'G', 6315075.96);<br>Insert into t<br>   (BILL_MONTH, AREA_CODE, NET_TYPE, LOCAL_FARE)<br> Values<br>   ('200405', '5762', 'J', 6328716.15);<br>Insert into t<br>   (BILL_MONTH, AREA_CODE, NET_TYPE, LOCAL_FARE)<br> Values<br>   ('200405', '5763', 'G', 8861742.59);<br>Insert into t<br>   (BILL_MONTH, AREA_CODE, NET_TYPE, LOCAL_FARE)<br> Values<br>   ('200405', '5763', 'J', 7788036.32);<br>Insert into t<br>   (BILL_MONTH, AREA_CODE, NET_TYPE, LOCAL_FARE)<br> Values<br>   ('200405', '5764', 'G', 6028670.45);<br>Insert into t<br>   (BILL_MONTH, AREA_CODE, NET_TYPE, LOCAL_FARE)<br> Values<br>   ('200405', '5764', 'J', 6459121.49);<br>Insert into t<br>   (BILL_MONTH, AREA_CODE, NET_TYPE, LOCAL_FARE)<br> Values<br>   ('200405', '5765', 'G', 13156065.77);<br>Insert into t<br>   (BILL_MONTH, AREA_CODE, NET_TYPE, LOCAL_FARE)<br> Values<br>   ('200405', '5765', 'J', 11901671.7);<br>Insert into t<br>   (BILL_MONTH, AREA_CODE, NET_TYPE, LOCAL_FARE)<br> Values<br>   ('200406', '5761', 'G', 7614587.96);<br>Insert into t<br>   (BILL_MONTH, AREA_CODE, NET_TYPE, LOCAL_FARE)<br> Values<br>   ('200406', '5761', 'J', 5704343.05);<br>Insert into t<br>   (BILL_MONTH, AREA_CODE, NET_TYPE, LOCAL_FARE)<br> Values<br>   ('200406', '5762', 'G', 6556992.6);<br>Insert into t<br>   (BILL_MONTH, AREA_CODE, NET_TYPE, LOCAL_FARE)<br> Values<br>   ('200406', '5762', 'J', 6238068.05);<br>Insert into t<br>   (BILL_MONTH, AREA_CODE, NET_TYPE, LOCAL_FARE)<br> Values<br>   ('200406', '5763', 'G', 9130055.46);<br>Insert into t<br>   (BILL_MONTH, AREA_CODE, NET_TYPE, LOCAL_FARE)<br> Values<br>   ('200406', '5763', 'J', 7990460.25);<br>Insert into t<br>   (BILL_MONTH, AREA_CODE, NET_TYPE, LOCAL_FARE)<br> Values<br>   ('200406', '5764', 'G', 6387706.01);<br>Insert into t<br>   (BILL_MONTH, AREA_CODE, NET_TYPE, LOCAL_FARE)<br> Values<br>   ('200406', '5764', 'J', 6907481.66);<br>Insert into t<br>   (BILL_MONTH, AREA_CODE, NET_TYPE, LOCAL_FARE)<br> Values<br>   ('200406', '5765', 'G', 13562968.81);<br>Insert into t<br>   (BILL_MONTH, AREA_CODE, NET_TYPE, LOCAL_FARE)<br> Values<br>   ('200406', '5765', 'J', 12495492.5);<br>Insert into t<br>   (BILL_MONTH, AREA_CODE, NET_TYPE, LOCAL_FARE)<br> Values<br>   ('200407', '5761', 'G', 7987050.65);<br>Insert into t<br>   (BILL_MONTH, AREA_CODE, NET_TYPE, LOCAL_FARE)<br> Values<br>   ('200407', '5761', 'J', 5723215.28);<br>Insert into t<br>   (BILL_MONTH, AREA_CODE, NET_TYPE, LOCAL_FARE)<br> Values<br>   ('200407', '5762', 'G', 6833096.68);<br>Insert into t<br>   (BILL_MONTH, AREA_CODE, NET_TYPE, LOCAL_FARE)<br> Values<br>   ('200407', '5762', 'J', 6391201.44);<br>Insert into t<br>   (BILL_MONTH, AREA_CODE, NET_TYPE, LOCAL_FARE)<br> Values<br>   ('200407', '5763', 'G', 9410815.91);<br>Insert into t<br>   (BILL_MONTH, AREA_CODE, NET_TYPE, LOCAL_FARE)<br> Values<br>   ('200407', '5763', 'J', 8076677.41);<br>Insert into t<br>   (BILL_MONTH, AREA_CODE, NET_TYPE, LOCAL_FARE)<br> Values<br>   ('200407', '5764', 'G', 6456433.23);<br>Insert into t<br>   (BILL_MONTH, AREA_CODE, NET_TYPE, LOCAL_FARE)<br> Values<br>   ('200407', '5764', 'J', 6987660.53);<br>Insert into t<br>   (BILL_MONTH, AREA_CODE, NET_TYPE, LOCAL_FARE)<br> Values<br>   ('200407', '5765', 'G', 14000101.2);<br>Insert into t<br>   (BILL_MONTH, AREA_CODE, NET_TYPE, LOCAL_FARE)<br> Values<br>   ('200407', '5765', 'J', 12301780.2);<br>Insert into t<br>   (BILL_MONTH, AREA_CODE, NET_TYPE, LOCAL_FARE)<br> Values<br>   ('200408', '5761', 'G', 8085170.84);<br>Insert into t<br>   (BILL_MONTH, AREA_CODE, NET_TYPE, LOCAL_FARE)<br> Values<br>   ('200408', '5761', 'J', 6050611.37);<br>Insert into t<br>   (BILL_MONTH, AREA_CODE, NET_TYPE, LOCAL_FARE)<br> Values<br>   ('200408', '5762', 'G', 6854584.22);<br>Insert into t<br>   (BILL_MONTH, AREA_CODE, NET_TYPE, LOCAL_FARE)<br> Values<br>   ('200408', '5762', 'J', 6521884.5);<br>Insert into t<br>   (BILL_MONTH, AREA_CODE, NET_TYPE, LOCAL_FARE)<br> Values<br>   ('200408', '5763', 'G', 9468707.65);<br>Insert into t<br>   (BILL_MONTH, AREA_CODE, NET_TYPE, LOCAL_FARE)<br> Values<br>   ('200408', '5763', 'J', 8460049.43);<br>Insert into t<br>   (BILL_MONTH, AREA_CODE, NET_TYPE, LOCAL_FARE)<br> Values<br>   ('200408', '5764', 'G', 6587559.23);<br>Insert into t<br>   (BILL_MONTH, AREA_CODE, NET_TYPE, LOCAL_FARE)<br> Values<br>   ('200408', '5764', 'J', 7342135.86);<br>Insert into t<br>   (BILL_MONTH, AREA_CODE, NET_TYPE, LOCAL_FARE)<br> Values<br>   ('200408', '5765', 'G', 14450586.63);<br>Insert into t<br>   (BILL_MONTH, AREA_CODE, NET_TYPE, LOCAL_FARE)<br> Values<br>   ('200408', '5765', 'J', 12680052.38);<br>COMMIT;</p> 
<p><br>  Code: [Copy to clipboard]   <br>06:34:23 SQL&gt; select * from t;</p> 
<p>BILL_MONTH      AREA_CODE  NET_TYPE       LOCAL_FARE<br>--------------- ---------- ---------- --------------<br>200405          5761       G              7393344.04<br>200405          5761       J              5667089.85<br>200405          5762       G              6315075.96<br>200405          5762       J              6328716.15<br>200405          5763       G              8861742.59<br>200405          5763       J              7788036.32<br>200405          5764       G              6028670.45<br>200405          5764       J              6459121.49<br>200405          5765       G             13156065.77<br>200405          5765       J             11901671.70<br>200406          5761       G              7614587.96<br>200406          5761       J              5704343.05<br>200406          5762       G              6556992.60<br>200406          5762       J              6238068.05<br>200406          5763       G              9130055.46<br>200406          5763       J              7990460.25<br>200406          5764       G              6387706.01<br>200406          5764       J              6907481.66<br>200406          5765       G             13562968.81<br>200406          5765       J             12495492.50<br>200407          5761       G              7987050.65<br>200407          5761       J              5723215.28<br>200407          5762       G              6833096.68<br>200407          5762       J              6391201.44<br>200407          5763       G              9410815.91<br>200407          5763       J              8076677.41<br>200407          5764       G              6456433.23<br>200407          5764       J              6987660.53<br>200407          5765       G             14000101.20<br>200407          5765       J             12301780.20<br>200408          5761       G              8085170.84<br>200408          5761       J              6050611.37<br>200408          5762       G              6854584.22<br>200408          5762       J              6521884.50<br>200408          5763       G              9468707.65<br>200408          5763       J              8460049.43<br>200408          5764       G              6587559.23</p> 
<p>BILL_MONTH      AREA_CODE  NET_TYPE       LOCAL_FARE<br>--------------- ---------- ---------- --------------<br>200408          5764       J              7342135.86<br>200408          5765       G             14450586.63<br>200408          5765       J             12680052.38</p> 
<p>40 rows selected.</p> 
<p>Elapsed: 00:00:00.00 <br> </p> 
<p> </p> 
<p>1. 使用rollup函数的介绍</p> 
<p>select area_code,sum(local_fare) local_fare<br>from t<br>group by area_code<br>union all<br>select '合计' area_code,sum(local_fare) local_fare<br>from t</p> 
<p>下面是直接使用普通sql语句求出各地区的汇总数据的例子<br>06:41:36 SQL&gt; set autot on<br>06:43:36 SQL&gt; select area_code,sum(local_fare) local_fare<br>06:43:50   2  from t<br>06:43:51   3  group by area_code<br>06:43:57   4  union all<br>06:44:00   5  select '合计' area_code,sum(local_fare) local_fare<br>06:44:06   6  from t<br>06:44:08   7  /</p> 
<p>AREA_CODE      LOCAL_FARE<br>---------- --------------<br>5761          54225413.04<br>5762          52039619.60<br>5763          69186545.02<br>5764          53156768.46<br>5765         104548719.19<br>合计         333157065.31</p> 
<p>6 rows selected.</p> 
<p>Elapsed: 00:00:00.03</p> 
<p>Execution Plan<br>----------------------------------------------------------<br>   0      SELECT STATEMENT Optimizer=ALL_ROWS (Cost=7 Card=1310 Bytes=<br>          24884)</p> 
<p>   1    0   UNION-ALL<br>   2    1     SORT (GROUP BY) (Cost=5 Card=1309 Bytes=24871)<br>   3    2       TABLE ACCESS (FULL) OF 'T' (Cost=2 Card=1309 Bytes=248<br>          71)</p> 
<p>   4    1     SORT (AGGREGATE)<br>   5    4       TABLE ACCESS (FULL) OF 'T' (Cost=2 Card=1309 Bytes=170<br>          17)</p> 
<p> </p> 
<p> </p> 
<p>Statistics<br>----------------------------------------------------------<br>          0  recursive calls<br>          0  db block gets<br>          6  consistent gets<br>          0  physical reads<br>          0  redo size<br>        561  bytes sent via SQL*Net to client<br>        503  bytes received via SQL*Net from client<br>          2  SQL*Net roundtrips to/from client<br>          1  sorts (memory)<br>          0  sorts (disk)<br>          6  rows processed</p> 
<p><br>下面是使用分析函数rollup得出的汇总数据的例子<br>select nvl(area_code,'合计') area_code,sum(local_fare) local_fare<br>from t<br>group by rollup(nvl(area_code,'合计'))</p> 
<p><br>06:44:09 SQL&gt; select nvl(area_code,'合计') area_code,sum(local_fare) local_fare<br>06:45:26   2  from t<br>06:45:30   3  group by rollup(nvl(area_code,'合计'))<br>06:45:50   4  /</p> 
<p>AREA_CODE      LOCAL_FARE<br>---------- --------------<br>5761          54225413.04<br>5762          52039619.60<br>5763          69186545.02<br>5764          53156768.46<br>5765         104548719.19<br>             333157065.31</p> 
<p>6 rows selected.</p> 
<p>Elapsed: 00:00:00.00</p> 
<p>Execution Plan<br>----------------------------------------------------------<br>   0      SELECT STATEMENT Optimizer=ALL_ROWS (Cost=5 Card=1309 Bytes=<br>          24871)</p> 
<p>   1    0   SORT (GROUP BY ROLLUP) (Cost=5 Card=1309 Bytes=24871)<br>   2    1     TABLE ACCESS (FULL) OF 'T' (Cost=2 Card=1309 Bytes=24871<br>          )</p> 
<p> </p> 
<p> </p> 
<p>Statistics<br>----------------------------------------------------------<br>          0  recursive calls<br>          0  db block gets<br>          4  consistent gets<br>          0  physical reads<br>          0  redo size<br>        557  bytes sent via SQL*Net to client<br>        503  bytes received via SQL*Net from client<br>          2  SQL*Net roundtrips to/from client<br>          1  sorts (memory)<br>          0  sorts (disk)<br>          6  rows processed</p> 
<p><br>从上面的例子我们不难看出使用rollup函数,系统的sql语句更加简单,耗用的资源更少,从6个consistent </p> 
<p>gets降到4个consistent gets,如果基表很大的话,结果就可想而知了. <br> </p> 
<p> </p> 
<p>1. 使用cube函数的介绍</p> 
<p> </p> 
<p><br>  Quote: <br>为了介绍cube函数我们再来看看另外一个使用rollup的例子<br>06:53:00 SQL&gt; select area_code,bill_month,sum(local_fare) local_fare<br>06:53:37   2  from t<br>06:53:38   3  group by rollup(area_code,bill_month)<br>06:53:49   4  /</p> 
<p>AREA_CODE  BILL_MONTH          LOCAL_FARE<br>---------- --------------- --------------<br>5761       200405             13060433.89<br>5761       200406             13318931.01<br>5761       200407             13710265.93<br>5761       200408             14135782.21<br>5761                          54225413.04<br>5762       200405             12643792.11<br>5762       200406             12795060.65<br>5762       200407             13224298.12<br>5762       200408             13376468.72<br>5762                          52039619.60<br>5763       200405             16649778.91<br>5763       200406             17120515.71<br>5763       200407             17487493.32<br>5763       200408             17928757.08<br>5763                          69186545.02<br>5764       200405             12487791.94<br>5764       200406             13295187.67<br>5764       200407             13444093.76<br>5764       200408             13929695.09<br>5764                          53156768.46<br>5765       200405             25057737.47<br>5765       200406             26058461.31<br>5765       200407             26301881.40<br>5765       200408             27130639.01<br>5765                         104548719.19<br>                             333157065.31</p> 
<p>26 rows selected.</p> 
<p>Elapsed: 00:00:00.00</p> 
<p>系统只是根据rollup的第一个参数area_code对结果集的数据做了汇总处理,而没有对bill_month做汇总分</p> 
<p>析处理,cube函数就是为了这个而设计的.<br>下面,让我们看看使用cube函数的结果</p> 
<p>06:58:02 SQL&gt; select area_code,bill_month,sum(local_fare) local_fare<br>06:58:30   2  from t<br>06:58:32   3  group by cube(area_code,bill_month)<br>06:58:42   4  order by area_code,bill_month nulls last<br>06:58:57   5  /</p> 
<p>AREA_CODE  BILL_MONTH          LOCAL_FARE<br>---------- --------------- --------------<br>5761       200405                13060.43<br>5761       200406                13318.93<br>5761       200407                13710.27<br>5761       200408                14135.78<br>5761                             54225.41<br>5762       200405                12643.79<br>5762       200406                12795.06<br>5762       200407                13224.30<br>5762       200408                13376.47<br>5762                             52039.62<br>5763       200405                16649.78<br>5763       200406                17120.52<br>5763       200407                17487.49<br>5763       200408                17928.76<br>5763                             69186.54<br>5764       200405                12487.79<br>5764       200406                13295.19<br>5764       200407                13444.09<br>5764       200408                13929.69<br>5764                             53156.77<br>5765       200405                25057.74<br>5765       200406                26058.46<br>5765       200407                26301.88<br>5765       200408                27130.64<br>5765                            104548.72<br>           200405                79899.53<br>           200406                82588.15<br>           200407                84168.03<br>           200408                86501.34<br>                                333157.05</p> 
<p>30 rows selected.</p> 
<p>Elapsed: 00:00:00.01</p> 
<p>可以看到,在cube函数的输出结果比使用rollup多出了几行统计数据.这就是cube函数根据bill_month做的</p> 
<p>汇总统计结果 <br> </p> 
<p> <br>1 rollup 和 cube函数的再深入</p> 
<p> </p> 
<p><br>  Quote: <br>从上面的结果中我们很容易发现,每个统计数据所对应的行都会出现null,<br>我们如何来区分到底是根据那个字段做的汇总呢,<br>这时候,oracle的grouping函数就粉墨登场了.<br>如果当前的汇总记录是利用该字段得出的,grouping函数就会返回1,否则返回0</p> 
<p><br>  1  select decode(grouping(area_code),1,'all area',to_char(area_code)) area_code,<br>  2         decode(grouping(bill_month),1,'all month',bill_month) bill_month,<br>  3         sum(local_fare) local_fare<br>  4  from t<br>  5  group by cube(area_code,bill_month)<br>  6* order by area_code,bill_month nulls last<br>07:07:29 SQL&gt; /</p> 
<p>AREA_CODE  BILL_MONTH          LOCAL_FARE<br>---------- --------------- --------------<br>5761       200405                13060.43<br>5761       200406                13318.93<br>5761       200407                13710.27<br>5761       200408                14135.78<br>5761       all month             54225.41<br>5762       200405                12643.79<br>5762       200406                12795.06<br>5762       200407                13224.30<br>5762       200408                13376.47<br>5762       all month             52039.62<br>5763       200405                16649.78<br>5763       200406                17120.52<br>5763       200407                17487.49<br>5763       200408                17928.76<br>5763       all month             69186.54<br>5764       200405                12487.79<br>5764       200406                13295.19<br>5764       200407                13444.09<br>5764       200408                13929.69<br>5764       all month             53156.77<br>5765       200405                25057.74<br>5765       200406                26058.46<br>5765       200407                26301.88<br>5765       200408                27130.64<br>5765       all month            104548.72<br>all area   200405                79899.53<br>all area   200406                82588.15<br>all area   200407                84168.03<br>all area   200408                86501.34<br>all area   all month            333157.05</p> 
<p>30 rows selected.</p> 
<p>Elapsed: 00:00:00.01<br>07:07:31 SQL&gt;</p> 
<p><br>可以看到,所有的空值现在都根据grouping函数做出了很好的区分,这样利用rollup,cube和grouping函数,</p> 
<p>我们做数据统计的时候就可以轻松很多了. <br> </p> 
<p> </p> 
<p><br>2. rank函数的介绍</p> 
<p>介绍完rollup和cube函数的使用,下面我们来看看rank系列函数的使用方法.</p> 
<p>问题2.我想查出这几个月份中各个地区的总话费的排名.</p> 
<p><br>  Quote: <br>为了将rank,dense_rank,row_number函数的差别显示出来,我们对已有的基础数据做一些修改,将5763的数</p> 
<p>据改成与5761的数据相同.<br>  1  update t t1 set local_fare = (<br>  2    select local_fare from t t2<br>  3     where t1.bill_month = t2.bill_month<br>  4     and t1.net_type = t2.net_type<br>  5     and t2.area_code = '5761'<br>  6* ) where area_code = '5763'<br>07:19:18 SQL&gt; /</p> 
<p>8 rows updated.</p> 
<p>Elapsed: 00:00:00.01</p> 
<p>我们先使用rank函数来计算各个地区的话费排名.<br>07:34:19 SQL&gt; select area_code,sum(local_fare) local_fare,<br>07:35:25   2    rank() over (order by sum(local_fare) desc) fare_rank<br>07:35:44   3  from t<br>07:35:45   4  group by area_codee<br>07:35:50   5<br>07:35:52 SQL&gt; select area_code,sum(local_fare) local_fare,<br>07:36:02   2    rank() over (order by sum(local_fare) desc) fare_rank<br>07:36:20   3  from t<br>07:36:21   4  group by area_code<br>07:36:25   5  /</p> 
<p>AREA_CODE      LOCAL_FARE  FARE_RANK<br>---------- -------------- ----------<br>5765            104548.72          1<br>5761             54225.41          2<br>5763             54225.41          2 <br>5764             53156.77          4 <br>5762             52039.62          5</p> 
<p>Elapsed: 00:00:00.01</p> 
<p>我们可以看到红色标注的地方出现了,跳位,排名3没有出现<br>下面我们再看看dense_rank查询的结果.</p> 
<p><br>07:36:26 SQL&gt; select area_code,sum(local_fare) local_fare,<br>07:39:16   2    dense_rank() over (order by sum(local_fare) desc ) fare_rank<br>07:39:39   3  from t<br>07:39:42   4  group by area_code<br>07:39:46   5  /</p> 
<p>AREA_CODE      LOCAL_FARE  FARE_RANK<br>---------- -------------- ----------<br>5765            104548.72          1<br>5761             54225.41          2<br>5763             54225.41          2<br>5764             53156.77          3  这是这里出现了第三名<br>5762             52039.62          4</p> 
<p>Elapsed: 00:00:00.00</p> 
<p><br>在这个例子中,出现了一个第三名,这就是rank和dense_rank的差别,<br>rank如果出现两个相同的数据,那么后面的数据就会直接跳过这个排名,而dense_rank则不会,<br>差别更大的是,row_number哪怕是两个数据完全相同,排名也会不一样,这个特性在我们想找出对应没个条</p> 
<p>件的唯一记录的时候又很大用处</p> 
<p><br>  1  select area_code,sum(local_fare) local_fare,<br>  2     row_number() over (order by sum(local_fare) desc ) fare_rank<br>  3  from t<br>  4* group by area_code<br>07:44:50 SQL&gt; /</p> 
<p>AREA_CODE      LOCAL_FARE  FARE_RANK<br>---------- -------------- ----------<br>5765            104548.72          1<br>5761             54225.41          2<br>5763             54225.41          3<br>5764             53156.77          4<br>5762             52039.62          5</p> 
<p>在row_nubmer函数中,我们发现,哪怕sum(local_fare)完全相同,我们还是得到了不一样排名,我们可以利</p> 
<p>用这个特性剔除数据库中的重复记录.</p> 
<p>这个帖子中的几个例子是为了说明这三个函数的基本用法的. 下个帖子我们将详细介绍他们的一些用法.<br> <br> </p> 
<p> <br>2. rank函数的介绍</p> 
<p>a. 取出数据库中最后入网的n个用户<br>select user_id,tele_num,user_name,user_status,create_date <br>from (<br>   select user_id,tele_num,user_name,user_status,create_date,<br>      rank() over (order by create_date desc) add_rank<br>   from user_info<br>)<br>where add_rank &lt;= :n;</p> 
<p>b.根据object_name删除数据库中的重复记录<br>create table t as select obj#,name from sys.obj$;<br>再insert into t1 select * from t1 数次.<br>delete from t1 where rowid in (<br>   select row_id from (<br>      select rowid row_id,row_number() over (partition by obj# order by rowid ) rn<br>   ) where rn &lt;&gt; 1<br>);</p> 
<p>c. 取出各地区的话费收入在各个月份排名.<br>SQL&gt; select bill_month,area_code,sum(local_fare) local_fare,<br>  2     rank() over (partition by bill_month order by sum(local_fare) desc) area_rank<br>  3  from t<br>  4  group by bill_month,area_code<br>  5  /</p> 
<p>BILL_MONTH      AREA_CODE           LOCAL_FARE  AREA_RANK<br>--------------- --------------- -------------- ----------<br>200405          5765                  25057.74          1<br>200405          5761                  13060.43          2<br>200405          5763                  13060.43          2<br>200405          5762                  12643.79          4<br>200405          5764                  12487.79          5<br>200406          5765                  26058.46          1<br>200406          5761                  13318.93          2<br>200406          5763                  13318.93          2<br>200406          5764                  13295.19          4<br>200406          5762                  12795.06          5<br>200407          5765                  26301.88          1<br>200407          5761                  13710.27          2<br>200407          5763                  13710.27          2<br>200407          5764                  13444.09          4<br>200407          5762                  13224.30          5<br>200408          5765                  27130.64          1<br>200408          5761                  14135.78          2<br>200408          5763                  14135.78          2<br>200408          5764                  13929.69          4<br>200408          5762                  13376.47          5</p> 
<p>20 rows selected.<br>SQL&gt;</p> 
<p><br>3. lag和lead函数介绍</p> 
<p>select area_code,bill_month, local_fare cur_local_fare,<br>     lag(local_fare,2,0) over (partition by area_code order by bill_month ) </p> 
<p>pre_local_fare,<br>     lag(local_fare,1,0) over (partition by area_code order by bill_month ) </p> 
<p>last_local_fare,<br>     lead(local_fare,1,0) over (partition by area_code order by bill_month ) </p> 
<p>next_local_fare,<br>     lead(local_fare,2,0) over (partition by area_code order by bill_month ) </p> 
<p>post_local_fare<br>  from (<br>       select area_code,bill_month,sum(local_fare) local_fare<br>       from t<br>       group by area_code,bill_month)</p> 
<p>取出每个月的上个月和下个月的话费总额<br>  1  select area_code,bill_month, local_fare cur_local_fare,<br>  2     lag(local_fare,2,0) over (partition by area_code order by bill_month ) </p> 
<p>pre_local_fare,<br>  3     lag(local_fare,1,0) over (partition by area_code order by bill_month ) </p> 
<p>last_local_fare,<br>  4     lead(local_fare,1,0) over (partition by area_code order by bill_month ) </p> 
<p>next_local_fare,<br>  5     lead(local_fare,2,0) over (partition by area_code order by bill_month ) </p> 
<p>post_local_fare<br>  6  from (<br>  7     select area_code,bill_month,sum(local_fare) local_fare<br>  8     from t<br>  9     group by area_code,bill_month<br>10* )<br>SQL&gt; /<br>AREA_CODE BILL_MONTH CUR_LOCAL_FARE PRE_LOCAL_FARE LAST_LOCAL_FARE NEXT_LOCAL_FARE </p> 
<p>POST_LOCAL_FARE<br>--------- ---------- -------------- -------------- --------------- --------------- --------</p> 
<p>-------<br>5761      200405          13060.433              0               0        13318.93       </p> 
<p>13710.265<br>5761      200406           13318.93              0       13060.433       13710.265       </p> 
<p>14135.781<br>5761      200407          13710.265      13060.433        13318.93       14135.781           </p> 
<p>    0<br>5761      200408          14135.781       13318.93       13710.265               0           </p> 
<p>    0<br>5762      200405          12643.791              0               0        12795.06       </p> 
<p>13224.297<br>5762      200406           12795.06              0       12643.791       13224.297       </p> 
<p>13376.468<br>5762      200407          13224.297      12643.791        12795.06       13376.468           </p> 
<p>    0<br>5762      200408          13376.468       12795.06       13224.297               0           </p> 
<p>    0<br>5763      200405          13060.433              0               0        13318.93       </p> 
<p>13710.265<br>5763      200406           13318.93              0       13060.433       13710.265       </p> 
<p>14135.781<br>5763      200407          13710.265      13060.433        13318.93       14135.781           </p> 
<p>    0<br>5763      200408          14135.781       13318.93       13710.265               0           </p> 
<p>    0<br>5764      200405          12487.791              0               0       13295.187       </p> 
<p>13444.093<br>5764      200406          13295.187              0       12487.791       13444.093       </p> 
<p>13929.694<br>5764      200407          13444.093      12487.791       13295.187       13929.694           </p> 
<p>    0<br>5764      200408          13929.694      13295.187       13444.093               0           </p> 
<p>    0<br>5765      200405          25057.736              0               0        26058.46       </p> 
<p>26301.881<br>5765      200406           26058.46              0       25057.736       26301.881       </p> 
<p>27130.638<br>5765      200407          26301.881      25057.736        26058.46       27130.638           </p> 
<p>    0<br>5765      200408          27130.638       26058.46       26301.881               0           </p> 
<p>    0<br>20 rows selected.</p> 
<p>利用lag和lead函数,我们可以在同一行中显示前n行的数据,也可以显示后n行的数据.</p> 
<p><br>4. sum,avg,max,min移动计算数据介绍</p> 
<p>计算出各个连续3个月的通话费用的平均数<br>  1  select area_code,bill_month, local_fare,<br>  2     sum(local_fare)<br>  3             over (  partition by area_code<br>  4                     order by to_number(bill_month)<br>  5                     range between 1 preceding and 1 following ) "3month_sum",<br>  6     avg(local_fare)<br>  7             over (  partition by area_code<br>  8                     order by to_number(bill_month)<br>  9                     range between 1 preceding and 1 following ) "3month_avg",<br>10     max(local_fare)<br>11             over (  partition by area_code<br>12                     order by to_number(bill_month)<br>13                     range between 1 preceding and 1 following ) "3month_max",<br>14     min(local_fare)<br>15             over (  partition by area_code<br>16                     order by to_number(bill_month)<br>17                     range between 1 preceding and 1 following ) "3month_min"<br>18  from (<br>19     select area_code,bill_month,sum(local_fare) local_fare<br>20     from t<br>21     group by area_code,bill_month<br>22* )<br>SQL&gt; /</p> 
<p>AREA_CODE BILL_MONTH       LOCAL_FARE 3month_sum 3month_avg 3month_max 3month_min<br>--------- ---------- ---------------- ---------- ---------- ---------- ----------<br>5761      200405            13060.433  26379.363 13189.6815   13318.93  13060.433<br>5761      200406            13318.930  40089.628 13363.2093  13710.265  13060.433<br>5761      200407            13710.265  41164.976 13721.6587  14135.781   13318.93<br>40089.628 = 13060.433 + 13318.930 + 13710.265<br>13363.2093 = (13060.433 + 13318.930 + 13710.265) / 3<br>13710.265 = max(13060.433 + 13318.930 + 13710.265)<br>13060.433 = min(13060.433 + 13318.930 + 13710.265)<br>5761      200408            14135.781  27846.046  13923.023  14135.781  13710.265<br>5762      200405            12643.791  25438.851 12719.4255   12795.06  12643.791<br>5762      200406            12795.060  38663.148  12887.716  13224.297  12643.791<br>5762      200407            13224.297  39395.825 13131.9417  13376.468   12795.06<br>5762      200408            13376.468  26600.765 13300.3825  13376.468  13224.297<br>5763      200405            13060.433  26379.363 13189.6815   13318.93  13060.433<br>5763      200406            13318.930  40089.628 13363.2093  13710.265  13060.433<br>5763      200407            13710.265  41164.976 13721.6587  14135.781   13318.93<br>5763      200408            14135.781  27846.046  13923.023  14135.781  13710.265<br>5764      200405            12487.791  25782.978  12891.489  13295.187  12487.791<br>5764      200406            13295.187  39227.071 13075.6903  13444.093  12487.791<br>5764      200407            13444.093  40668.974 13556.3247  13929.694  13295.187<br>5764      200408            13929.694  27373.787 13686.8935  13929.694  13444.093<br>5765      200405            25057.736  51116.196  25558.098   26058.46  25057.736<br>5765      200406            26058.460  77418.077 25806.0257  26301.881  25057.736<br>5765      200407            26301.881  79490.979  26496.993  27130.638   26058.46<br>5765      200408            27130.638  53432.519 26716.2595  27130.638  26301.881</p> 
<p>20 rows selected.</p> 
<p>5. ratio_to_report函数的介绍</p> 
<p><br>select bill_month,area_code,sum(local_fare) local_fare,<br>     ratio_to_report(sum(local_fare)) over<br>       ( partition by bill_month ) area_pct<br>  from t<br> group by bill_month,area_code</p> 
<p>  Quote: <br>  1  select bill_month,area_code,sum(local_fare) local_fare,<br>  2     ratio_to_report(sum(local_fare)) over<br>  3       ( partition by bill_month ) area_pct<br>  4  from t<br>  5* group by bill_month,area_code<br>SQL&gt; break on bill_month skip 1<br>SQL&gt; compute sum of local_fare on bill_month<br>SQL&gt; compute sum of area_pct on bill_month<br>SQL&gt; /</p> 
<p>BILL_MONTH AREA_CODE       LOCAL_FARE   AREA_PCT<br>---------- --------- ---------------- ----------<br>200405     5761             13060.433 .171149279<br>           5762             12643.791 .165689431<br>           5763             13060.433 .171149279<br>           5764             12487.791 .163645143<br>           5765             25057.736 .328366866<br>**********           ---------------- ----------<br>sum                         76310.184          1</p> 
<p>200406     5761             13318.930 .169050772<br>           5762             12795.060 .162401542<br>           5763             13318.930 .169050772<br>           5764             13295.187 .168749414<br>           5765             26058.460 .330747499<br>**********           ---------------- ----------<br>sum                         78786.567          1</p> 
<p>200407     5761             13710.265 .170545197<br>           5762             13224.297 .164500127<br>           5763             13710.265 .170545197<br>           5764             13444.093 .167234221<br>           5765             26301.881 .327175257<br>**********           ---------------- ----------<br>sum                         80390.801          1</p> 
<p>200408     5761             14135.781 .170911147<br>           5762             13376.468 .161730539<br>           5763             14135.781 .170911147<br>           5764             13929.694 .168419416<br>           5765             27130.638 .328027751<br>**********           ---------------- ----------<br>sum                         82708.362          1</p> 
<p><br>20 rows selected. <br> </p> 
<p><br>6 first,last函数使用介绍</p> 
<p> </p> 
<p><br>  Quote: <br>取出每月通话费最高和最低的两个用户.<br>select bill_month,area_code,sum(local_fare) local_fare,<br>      first_value(area_code)<br>              over (order by sum(local_fare) desc<br>                      rows unbounded preceding) firstval,<br>      first_value(area_code)<br>              over (order by sum(local_fare) asc<br>                      rows unbounded preceding) lastval<br>   from t<br>   group by bill_month,area_code<br> order by bill_month</p> 
<p>1  select bill_month,area_code,sum(local_fare) local_fare,<br>  2     first_value(area_code)<br>  3             over (order by sum(local_fare) desc<br>  4                     rows unbounded preceding) firstval,<br>  5     first_value(area_code)<br>  6             over (order by sum(local_fare) asc<br>  7                     rows unbounded preceding) lastval<br>  8  from t<br>  9  group by bill_month,area_code<br>10* order by bill_month<br>SQL&gt; /</p> 
<p>BILL_MONTH AREA_CODE       LOCAL_FARE FIRSTVAL        LASTVAL<br>---------- --------- ---------------- --------------- ---------------<br>200405     5764             12487.791 5765            5764<br>200405     5762             12643.791 5765            5764<br>200405     5761             13060.433 5765            5764<br>200405     5765             25057.736 5765            5764<br>200405     5763             13060.433 5765            5764<br>200406     5762             12795.060 5765            5764<br>200406     5763             13318.930 5765            5764<br>200406     5764             13295.187 5765            5764<br>200406     5765             26058.460 5765            5764<br>200406     5761             13318.930 5765            5764<br>200407     5762             13224.297 5765            5764<br>200407     5765             26301.881 5765            5764<br>200407     5761             13710.265 5765            5764<br>200407     5763             13710.265 5765            5764<br>200407     5764             13444.093 5765            5764<br>200408     5762             13376.468 5765            5764<br>200408     5764             13929.694 5765            5764<br>200408     5761             14135.781 5765            5764<br>200408     5765             27130.638 5765            5764<br>200408     5763             14135.781 5765            5764</p> 
<p>20 rows selected. </p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/ed8190f56fab8d8ab7876824235e64b4/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">轻松为Windows配置多个网关</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/e4602906572bb013bfdba425d408f2ed/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">快速平方根（平方根倒数）算法</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>