<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>【笔记】折半插入排序 - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="【笔记】折半插入排序" />
<meta property="og:description" content="插入排序的算法思想：将待排序元素分为已排序子集和未排序子集，一次从未排序子集中的一个元素插入已排序子集中，使已排序自己仍然有序；重复执行以上过程，指导所有元素都有序为止。
折半插入排序：算法是直接插入排序的改进。它的主要改进在于在已经有序的集合中使用折半查找法确定待排序元素的插入位置， 找到要插入的位置后，将待排序元素插入相应的位置。
假设待排序的元素有7个，分别为67、53、73、21、34、98、12。使用折半插入排序对该元素序列第一堂排序的过程如下图所示。
第2趟折半插入排序过程如下图所示。
从以上两趟排序过程可以看出，折半插入排序与直接插入排序的区别仅仅在于查找插入的位置的方法不同。一般情况下，折半查找的效率要高于顺序查找的效率，因此折半插入排序算法可以减少比较的次数。 通过对直接插入排序算法的简单修改，得到如下折半插入排序的算法：
类型定义头文件 #define MAXSIZE 20 /* 一个用作示例的小顺序表的最大长度 */ typedef int InfoType; /* 定义其它数据项的类型 */ typedef int KeyType; /* 定义关键字类型为整型 */ typedef struct { KeyType key; /* 关键字项 */ InfoType otherinfo; /* 其它数据项，具体类型在主程中定义 */ }RedType; /* 记录类型 */ typedef struct { RedType r[MAXSIZE&#43;1]; /* r[0]闲置或用作哨兵单元 */ int length; /* 顺序表长度 */ }SqList; /* 顺序表类型 */ 函数文件 void BinInsertSort(SqList *L) /*折半插入排序*/ { int i,j,mid,low,high; DataType t; for(i=1;i&lt;L-&gt;length;i&#43;&#43;) /*前i个元素已经有序，从第i&#43;1个元素开始与前i个的有序的关键字比较*/ { t=L-&gt;data[i&#43;1]; /*取出第i&#43;1个元素，即待排序的元素*/ low=1,high=i; while(low&lt;=high) /*利用折半查找思想寻找当前元素的合适位置*/ { mid=(low&#43;high)/2; if(L-&gt;data[mid]." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/c36f02df648eab058fa14fe23c261b72/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2017-11-03T11:40:10+08:00" />
<meta property="article:modified_time" content="2017-11-03T11:40:10+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">【笔记】折半插入排序</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p>  插入排序的算法思想：将待排序元素分为已排序子集和未排序子集，一次从未排序子集中的一个元素插入已排序子集中，使已排序自己仍然有序；重复执行以上过程，指导所有元素都有序为止。</p> 
<p>  <strong>折半插入排序</strong>：算法是直接插入排序的改进。它的主要改进在于在已经有序的集合中使用折半查找法确定待排序元素的插入位置， 找到要插入的位置后，将待排序元素插入相应的位置。</p> 
<p>  假设待排序的元素有7个，分别为67、53、73、21、34、98、12。使用折半插入排序对该元素序列第一堂排序的过程如下图所示。</p> 
<p></p> 
<div align="center"> 
 <br> 
 <img src="https://images2.imgbox.com/7a/e0/7ZbwXnYX_o.jpg" alt="这里写图片描述" title=""> 
</div> 
<p></p> 
<p>  第2趟折半插入排序过程如下图所示。</p> 
<p></p> 
<div align="center"> 
 <br> 
 <img src="https://images2.imgbox.com/59/e2/2aj1zRwE_o.jpg" alt="这里写图片描述" title=""> 
</div> 
<p></p> 
<p>  从以上两趟排序过程可以看出，折半插入排序与直接插入排序的区别仅仅在于查找插入的位置的方法不同。一般情况下，折半查找的效率要高于顺序查找的效率，因此折半插入排序算法可以减少比较的次数。 <br>   通过对直接插入排序算法的简单修改，得到如下折半插入排序的算法：</p> 
<ul><li><strong>类型定义头文件</strong></li></ul> 
<pre class="prettyprint"><code class=" hljs d"> #define MAXSIZE <span class="hljs-number">20</span> <span class="hljs-comment">/* 一个用作示例的小顺序表的最大长度 */</span>
 <span class="hljs-keyword">typedef</span> <span class="hljs-keyword">int</span> InfoType; <span class="hljs-comment">/* 定义其它数据项的类型 */</span>
 <span class="hljs-keyword">typedef</span> <span class="hljs-keyword">int</span> KeyType; <span class="hljs-comment">/* 定义关键字类型为整型 */</span>
 <span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span>
 {
   KeyType key; <span class="hljs-comment">/* 关键字项 */</span>
   InfoType otherinfo; <span class="hljs-comment">/* 其它数据项，具体类型在主程中定义 */</span>
 }RedType; <span class="hljs-comment">/* 记录类型 */</span>

 <span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span>
 {
   RedType r[MAXSIZE+<span class="hljs-number">1</span>]; <span class="hljs-comment">/* r[0]闲置或用作哨兵单元 */</span>
   <span class="hljs-keyword">int</span> length; <span class="hljs-comment">/* 顺序表长度 */</span>
 }SqList; <span class="hljs-comment">/* 顺序表类型 */</span></code></pre> 
<ul><li><strong>函数文件</strong></li></ul> 
<pre class="prettyprint"><code class=" hljs haskell"><span class="hljs-title">void</span> <span class="hljs-type">BinInsertSort</span>(<span class="hljs-type">SqList</span> *<span class="hljs-type">L</span>)
/*折半插入排序*/
{
    int i,j,mid,low,high;
    <span class="hljs-type">DataType</span> t;
    for(i=<span class="hljs-number">1</span>;i&lt;<span class="hljs-type">L</span>-&gt;length;i++)        /*前i个元素已经有序，从第i+<span class="hljs-number">1</span>个元素开始与前i个的有序的关键字比较*/
    {
        t=<span class="hljs-type">L</span>-&gt;<span class="hljs-typedef"><span class="hljs-keyword">data</span>[i+1];             /*取出第i+1个元素，即待排序的元素*/</span>
        low=<span class="hljs-number">1</span>,high=i;
        while(low&lt;=high)            /*利用折半查找思想寻找当前元素的合适位置*/
        {
            mid=(low+high)/<span class="hljs-number">2</span>;
            <span class="hljs-keyword">if</span>(<span class="hljs-type">L</span>-&gt;<span class="hljs-typedef"><span class="hljs-keyword">data</span>[mid].key&gt;t.key)</span>
                high=mid-<span class="hljs-number">1</span>;
            <span class="hljs-keyword">else</span>
                low=mid+<span class="hljs-number">1</span>;
        }
        for(j=i;j&gt;=low;j<span class="hljs-comment">--)     /*移动元素，空出要插入的位置*/</span>
            <span class="hljs-type">L</span>-&gt;<span class="hljs-typedef"><span class="hljs-keyword">data</span>[j+1]=<span class="hljs-type">L</span>-&gt;<span class="hljs-keyword">data</span>[j];</span>
        <span class="hljs-type">L</span>-&gt;<span class="hljs-typedef"><span class="hljs-keyword">data</span>[low]=t;         /*将当前元素插入合适的位置*/    </span>
    }
}</code></pre> 
<ul><li><strong>主程序</strong></li></ul> 
<pre class="prettyprint"><code class=" hljs perl"> <span class="hljs-comment">#define LT(a,b) ((a)&lt;(b))</span>
 <span class="hljs-comment">#define N 8</span>
 void <span class="hljs-keyword">print</span>(SqList L)
 {
   <span class="hljs-keyword">int</span> i;
   <span class="hljs-keyword">for</span>(i=<span class="hljs-number">1</span>;i&lt;=L.<span class="hljs-keyword">length</span>;i++)
     <span class="hljs-keyword">printf</span>(<span class="hljs-string">"(<span class="hljs-variable">%d</span>,<span class="hljs-variable">%d</span>)"</span>,L.r[i].key,L.r[i].otherinfo);
   <span class="hljs-keyword">printf</span>(<span class="hljs-string">"\n"</span>);
 }

 void main()
 {
   RedType d[N]={<!-- -->{<!-- --><span class="hljs-number">49</span>,<span class="hljs-number">1</span>},{<!-- --><span class="hljs-number">38</span>,<span class="hljs-number">2</span>},{<!-- --><span class="hljs-number">65</span>,<span class="hljs-number">3</span>},{<!-- --><span class="hljs-number">97</span>,<span class="hljs-number">4</span>},{<!-- --><span class="hljs-number">76</span>,<span class="hljs-number">5</span>},{<!-- --><span class="hljs-number">13</span>,<span class="hljs-number">6</span>},{<!-- --><span class="hljs-number">27</span>,<span class="hljs-number">7</span>},{<!-- --><span class="hljs-number">49</span>,<span class="hljs-number">8</span>}};
   SqList l;
   <span class="hljs-keyword">int</span> i;
   <span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>;i&lt;N;i++) /* 给l1.r赋值 <span class="hljs-variable">*/</span>
     l1.r[i+<span class="hljs-number">1</span>]=d[i];
   l.<span class="hljs-keyword">length</span>=N;
   <span class="hljs-keyword">printf</span>(<span class="hljs-string">"排序前:\n"</span>);
   <span class="hljs-keyword">print</span>(l);
   BInsertSort(&amp;l);
   <span class="hljs-keyword">printf</span>(<span class="hljs-string">"折半插入排序后:\n"</span>);
   <span class="hljs-keyword">print</span>(l);
 }</code></pre>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/d54203785483ffecb6c1d9a36304150f/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">数据恢复原来是可以免费的！</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/29320b6bfd9d310340f0ac9cadd1741a/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">STM32F4 FLASH</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>