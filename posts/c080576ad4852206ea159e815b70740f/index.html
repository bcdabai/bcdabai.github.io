<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>VS2010  Windows   API  串口编程 - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="VS2010  Windows   API  串口编程" />
<meta property="og:description" content="注：在VS2010中没有编写串口的控件，因此，需要自己下载相关的文件并安装。操作比较麻烦。用Win32 API 编程，在VS2010中能够实现同样的功能。仅此，与大家共享一下。
可以使用两种编程方式实现串口通信，其一是使用ActiveX控件，这种方法程序简单，但欠灵活。其二是调用Windows的API函数，这种方法可以清楚地掌握串口通信的机制，并且自由灵活。本文我们只介绍API串口通信部分。
串口的操作可以有两种操作方式：同步操作方式和重叠操作方式（又称为异步操作方式）。同步操作时，API函数会阻塞直到操作完成以后才能返回（在多线程方式中，虽然不会阻塞主线程，但是仍然会阻塞监听线程）；而重叠操作方式，API函数会立即返回，操作在后台进行，避免线程的阻塞。
无论那种操作方式，一般都通过四个步骤来完成：
（1）打开串口
（2）配置串口
（3）读写串口
（4） 关闭串口
（1） 打开串口
Win32系统把文件的概念进行了扩展。无论是文件、通信设备、命名管道、邮件槽、磁盘、还是控制台，都是用API函数CreateFile来打开或创建的。该函数的原型为：
HANDLE CreateFile( LPCTSTR lpFileName,
DWORD dwDesiredAccess,
DWORD dwShareMode,
LPSECURITY_ATTRIBUTES lpSecurityAttributes,
DWORD dwCreationDistribution,
DWORD dwFlagsAndAttributes,
HANDLE hTemplateFile);
lpFileName：将要打开的串口逻辑名，如“COM1”； dwDesiredAccess：指定串口访问的类型，可以是读取、写入或二者并列； dwShareMode：指定共享属性，由于串口不能共享，该参数必须置为0； lpSecurityAttributes：引用安全性属性结构，缺省值为NULL； dwCreationDistribution：创建标志，对串口操作该参数必须置为OPEN_EXISTING；dwFlagsAndAttributes：属性描述，用于指定该串口是否进行异步操作，该值为FILE_FLAG_OVERLAPPED，表示使用异步的I/O；该值为0，表示同步I/O操作；hTemplateFile：对串口而言该参数必须置为NULL； 同步I/O方式打开串口的示例代码： HANDLE hCom; //全局变量，串口句柄
hCom=CreateFile(&#34;COM1&#34;,//COM1口
GENERIC_READ|GENERIC_WRITE, //允许读和写
0, //独占方式
NULL,
OPEN_EXISTING, //打开而不是创建
0, //同步方式
NULL);
if(hCom==(HANDLE)-1)
{
AfxMessageBox(&#34;打开COM失败!&#34;);
return FALSE;
}
return TRUE;
重叠I/O打开串口的示例代码： HANDLE hCom; //全局变量，串口句柄
hCom =CreateFile(&#34;COM1&#34;, //COM1口
GENERIC_READ|GENERIC_WRITE, //允许读和写
0, //独占方式" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/c080576ad4852206ea159e815b70740f/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2013-01-07T15:14:28+08:00" />
<meta property="article:modified_time" content="2013-01-07T15:14:28+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">VS2010  Windows   API  串口编程</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p align="left"><span style="color:#ff0000">注：在VS2010中没有编写串口的控件，因此，需要自己下载相关的文件并安装。操作比较麻烦。用Win32 API 编程，在VS2010中能够实现同样的功能。仅此，与大家共享一下。</span></p> 
<p align="left"><span style="font-size:14px">可以使用两种编程方式实现串口通信，其一是使用ActiveX控件，这种方法程序简单，但欠灵活。其二是调用Windows的API函数，这种方法可以清楚地掌握串口通信的机制，并且自由灵活。本文我们只介绍API串口通信部分。</span></p> 
<p align="left"><span style="font-size:14px">串口的操作可以有两种操作方式：同步操作方式和重叠操作方式（又称为异步操作方式）。同步操作时，API函数会阻塞直到操作完成以后才能返回（在多线程方式中，虽然不会阻塞主线程，但是仍然会阻塞监听线程）；而重叠操作方式，API函数会立即返回，操作在后台进行，避免线程的阻塞。</span></p> 
<p align="left"><span style="font-size:14px">无论那种操作方式，一般都通过四个步骤来完成：</span></p> 
<p align="left"><span style="font-size:14px">（1）</span><a href="http://www.vckbase.com/document/viewdoc/?id=1734#%E6%89%93%E5%BC%80%E4%B8%B2%E5%8F%A3" rel="nofollow"><span style="color:#000088"><span style="font-size:14px">打开串口</span></span></a><br> <span style="font-size:14px">（2）</span><a href="http://www.vckbase.com/document/viewdoc/?id=1734#%E9%85%8D%E7%BD%AE%E4%B8%B2%E5%8F%A3" rel="nofollow"><span style="color:#000088"><span style="font-size:14px">配置串口</span></span></a><br> <span style="font-size:14px">（3）</span><a href="http://www.vckbase.com/document/viewdoc/?id=1734#%E8%AF%BB%E5%86%99%E4%B8%B2%E5%8F%A3" rel="nofollow"><span style="color:#000088"><span style="font-size:14px">读写串口</span></span></a><br> <span style="font-size:14px">（4） <a href="http://www.vckbase.com/document/viewdoc/?id=1734#%E5%85%B3%E9%97%AD%E4%B8%B2%E5%8F%A3" rel="nofollow"> <span style="color:#000088">关闭串口</span></a></span></p> 
<p align="left"><span style="font-size:14px">（1） </span><a name="%E6%89%93%E5%BC%80%E4%B8%B2%E5%8F%A3"><span style="color:#000088">打开串口</span></a></p> 
<p align="left"><span style="font-size:14px">　　Win32系统把文件的概念进行了扩展。无论是文件、通信设备、命名管道、邮件槽、磁盘、还是控制台，都是用API函数CreateFile来打开或创建的。该函数的原型为：</span></p> 
<p align="left" style="background:#f5f5f0"><span style="color:#003399"><span style="font-size:14px">HANDLE CreateFile( LPCTSTR lpFileName,</span></span></p> 
<p align="left" style="background:#f5f5f0"><span style="color:#003399"><span style="font-size:14px">                 </span></span>DWORD dwDesiredAccess,</p> 
<p align="left" style="background:#f5f5f0"><span style="color:#003399"><span style="font-size:14px">                 </span></span>DWORD dwShareMode,</p> 
<p align="left" style="background:#f5f5f0"><span style="color:#003399"><span style="font-size:14px">                 </span></span>LPSECURITY_ATTRIBUTES lpSecurityAttributes,</p> 
<p align="left" style="background:#f5f5f0"><span style="color:#003399"><span style="font-size:14px">                 </span></span>DWORD dwCreationDistribution,</p> 
<p align="left" style="background:#f5f5f0"><span style="color:#003399"><span style="font-size:14px">DWORD dwFlagsAndAttributes,</span></span></p> 
<p align="left" style="background:#f5f5f0"><span style="color:#003399"><span style="font-size:14px">HANDLE hTemplateFile);</span></span></p> 
<ul type="disc"><li><span style="font-size:14px">lpFileName：将要打开的串口逻辑名，如“COM1”； </span></li><li><span style="font-size:14px">dwDesiredAccess：指定串口访问的类型，可以是读取、写入或二者并列； </span> </li><li><span style="font-size:14px">dwShareMode：指定共享属性，由于串口不能共享，该参数必须置为0； </span></li><li><span style="font-size:14px">lpSecurityAttributes：引用安全性属性结构，缺省值为NULL； </span> </li><li><span style="font-size:14px">dwCreationDistribution：创建标志，对串口操作该参数必须置为OPEN_EXISTING；</span></li><li><span style="font-size:14px">dwFlagsAndAttributes：属性描述，用于指定该串口是否进行异步操作，该值为FILE_FLAG_OVERLAPPED，表示使用异步的I/O；该值为0，表示同步I/O操作；</span></li><li><span style="font-size:14px">hTemplateFile：对串口而言该参数必须置为NULL； </span></li></ul> 
<p align="left"><span style="font-size:14px">同步I/O方式打开串口的示例代码： </span></p> 
<p align="left" style="background:#f5f5f0"><span style="font-size:14px"><span style="color:#003399">      </span>HANDLE hCom;  //<span style="color:#003399">全局变量，串口句柄</span></span></p> 
<p align="left" style="background:#f5f5f0"><span style="font-size:14px"><span style="color:#003399">      </span>hCom=CreateFile("COM1",//COM1<span style="color:#003399">口</span></span></p> 
<p align="left" style="background:#f5f5f0"><span style="font-size:14px"><span style="color:#003399">             </span>GENERIC_READ|GENERIC_WRITE, //<span style="color:#003399">允许读和写</span></span></p> 
<p align="left" style="background:#f5f5f0"><span style="font-size:14px"><span style="color:#003399">             </span>0, //<span style="color:#003399">独占方式</span></span></p> 
<p align="left" style="background:#f5f5f0"><span style="color:#003399"><span style="font-size:14px">             </span></span>NULL,</p> 
<p align="left" style="background:#f5f5f0"><span style="font-size:14px"><span style="color:#003399">             </span>OPEN_EXISTING, //<span style="color:#003399">打开而不是创建</span></span></p> 
<p align="left" style="background:#f5f5f0"><span style="font-size:14px"><span style="color:#003399">             </span>0, //<span style="color:#003399">同步方式</span></span></p> 
<p align="left" style="background:#f5f5f0"><span style="color:#003399"><span style="font-size:14px">             </span></span>NULL);</p> 
<p align="left" style="background:#f5f5f0"><span style="color:#003399"><span style="font-size:14px">      </span></span>if(hCom==(HANDLE)-1)</p> 
<p align="left" style="background:#f5f5f0"><span style="color:#003399"><span style="font-size:14px">      </span></span>{<!-- --></p> 
<p align="left" style="background:#f5f5f0"><span style="font-size:14px"><span style="color:#003399">             </span>AfxMessageBox("<span style="color:#003399">打开</span><span style="color:#003399">COM</span><span style="color:#003399">失败</span><span style="color:#003399">!");</span></span></p> 
<p align="left" style="background:#f5f5f0"><span style="color:#003399"><span style="font-size:14px">             </span></span>return FALSE;</p> 
<p align="left" style="background:#f5f5f0"><span style="color:#003399"><span style="font-size:14px">      </span></span>}</p> 
<p align="left" style="background:#f5f5f0"><span style="color:#003399"><span style="font-size:14px">      </span></span>return TRUE;</p> 
<p align="left" style="background:#f5f5f0"><span style="color:#003399"><span style="font-size:14px"> </span></span></p> 
<p align="left"><span style="font-size:14px">重叠I/O打开串口的示例代码： </span></p> 
<p align="left" style="background:#f5f5f0"><span style="font-size:14px"><span style="color:#003399">      </span>HANDLE hCom;  //<span style="color:#003399">全局变量，串口句柄</span></span></p> 
<p align="left" style="background:#f5f5f0"><span style="font-size:14px"><span style="color:#003399">      </span>hCom =CreateFile("COM1",  //COM1<span style="color:#003399">口</span></span></p> 
<p align="left" style="background:#f5f5f0"><span style="font-size:14px"><span style="color:#003399">            </span>GENERIC_READ|GENERIC_WRITE, //<span style="color:#003399">允许读和写</span></span></p> 
<p align="left" style="background:#f5f5f0"><span style="font-size:14px"><span style="color:#003399">            </span>0,  //<span style="color:#003399">独占方式</span></span></p> 
<p align="left" style="background:#f5f5f0"><span style="color:#003399"><span style="font-size:14px">            </span></span>NULL,</p> 
<p align="left" style="background:#f5f5f0"><span style="font-size:14px"><span style="color:#003399">            </span>OPEN_EXISTING,  //<span style="color:#003399">打开而不是创建</span></span></p> 
<p align="left" style="background:#f5f5f0"><span style="font-size:14px"><span style="color:#003399">            </span>FILE_ATTRIBUTE_NORMAL|FILE_FLAG_OVERLAPPED, //<span style="color:#003399">重叠方式</span></span></p> 
<p align="left" style="background:#f5f5f0"><span style="color:#003399"><span style="font-size:14px">            </span></span>NULL);</p> 
<p align="left" style="background:#f5f5f0"><span style="color:#003399"><span style="font-size:14px">      </span></span>if(hCom ==INVALID_HANDLE_VALUE)</p> 
<p align="left" style="background:#f5f5f0"><span style="color:#003399"><span style="font-size:14px">      </span></span>{<!-- --></p> 
<p align="left" style="background:#f5f5f0"><span style="font-size:14px"><span style="color:#003399">             </span>AfxMessageBox("<span style="color:#003399">打开</span><span style="color:#003399">COM</span><span style="color:#003399">失败</span><span style="color:#003399">!");</span></span></p> 
<p align="left" style="background:#f5f5f0"><span style="color:#003399"><span style="font-size:14px">             </span></span>return FALSE;</p> 
<p align="left" style="background:#f5f5f0"><span style="color:#003399"><span style="font-size:14px">      </span></span>}</p> 
<p align="left" style="background:#f5f5f0"><span style="color:#003399"><span style="font-size:14px">      </span></span>   return TRUE;</p> 
<p align="left"><span style="font-size:14px">（2）、</span><a name="%E9%85%8D%E7%BD%AE%E4%B8%B2%E5%8F%A3"><span style="color:#000088">配置串口</span></a></p> 
<p align="left"><span style="font-size:14px">在打开通讯设备句柄后，常常需要对串口进行一些初始化配置工作。这需要通过一个DCB结构来进行。DCB结构包含了诸如波特率、数据位数、奇偶校验和停止位数等信息。在查询或配置串口的属性时，都要用DCB结构来作为缓冲区。</span></p> 
<p align="left"><span style="font-size:14px">一般用CreateFile打开串口后，可以调用GetCommState函数来获取串口的初始配置。要修改串口的配置，应该先修改DCB结构，然后再调用SetCommState函数设置串口。</span></p> 
<p align="left"><span style="font-size:14px">DCB结构包含了串口的各项参数设置，下面仅介绍几个该结构常用的变量： </span> </p> 
<p align="left" style="background:#f5f5f0"><span style="color:#003399"><span style="font-size:14px">typedef struct _DCB{<!-- --></span></span></p> 
<p align="left" style="background:#f5f5f0"><span style="color:#003399"><span style="font-size:14px">  </span></span>………</p> 
<p align="left" style="background:#f5f5f0"><span style="font-size:14px"><span style="color:#003399">  </span>//<span style="color:#003399">波特率，指定通信设备的传输速率。这个成员可以是实际波特率值或者下面的常量值之一：</span></span></p> 
<p align="left" style="background:#f5f5f0"><span style="color:#003399"><span style="font-size:14px">  </span></span>DWORD BaudRate; </p> 
<p align="left" style="background:#f5f5f0"><span style="font-size:14px"><span style="color:#003399">CBR_110</span><span style="color:#003399">，</span><span style="color:#003399">CBR_300</span><span style="color:#003399">，</span><span style="color:#003399">CBR_600</span><span style="color:#003399">，</span><span style="color:#003399">CBR_1200</span><span style="color:#003399">，</span><span style="color:#003399">CBR_2400</span><span style="color:#003399">，</span><span style="color:#003399">CBR_4800</span><span style="color:#003399">，</span><span style="color:#003399">CBR_9600</span><span style="color:#003399">，</span><span style="color:#003399">CBR_19200</span><span style="color:#003399">，</span><span style="color:#003399"> CBR_38400</span><span style="color:#003399">，</span></span></p> 
<p align="left" style="background:#f5f5f0"><span style="font-size:14px"><span style="color:#003399">CBR_56000</span><span style="color:#003399">，</span><span style="color:#003399"> CBR_57600</span><span style="color:#003399">，</span><span style="color:#003399"> CBR_115200</span><span style="color:#003399">，</span><span style="color:#003399"> CBR_128000</span><span style="color:#003399">，</span><span style="color:#003399"> CBR_256000</span><span style="color:#003399">，</span><span style="color:#003399"> CBR_14400</span></span></p> 
<p align="left" style="background:#f5f5f0"><span style="color:#003399"><span style="font-size:14px"> </span></span></p> 
<p align="left" style="background:#f5f5f0"><span style="font-size:14px"><span style="color:#003399">DWORD fParity; //</span><span style="color:#003399">指定奇偶校验使能。若此成员为</span><span style="color:#003399">1</span><span style="color:#003399">，允许奇偶校验检查</span></span></p> 
<p align="left" style="background:#f5f5f0"><span style="color:#003399"><span style="font-size:14px">  </span></span>…</p> 
<p align="left" style="background:#f5f5f0"><span style="font-size:14px"><span style="color:#003399">BYTE ByteSize; //</span><span style="color:#003399">通信字节位数，</span><span style="color:#003399">4—8</span></span></p> 
<p align="left" style="background:#f5f5f0"><span style="font-size:14px"><span style="color:#003399">BYTE Parity; //</span><span style="color:#003399">指定奇偶校验方法。此成员可以有下列值：</span></span></p> 
<p align="left" style="background:#f5f5f0"><span style="font-size:14px"><span style="color:#003399">EVENPARITY</span><span style="color:#003399">偶校验</span><span style="color:#003399">  </span>   NOPARITY <span style="color:#003399">无校验</span></span></p> 
<p align="left" style="background:#f5f5f0"><span style="font-size:14px"><span style="color:#003399">MARKPARITY</span><span style="color:#003399">标记校验</span><span style="color:#003399">   </span>ODDPARITY <span style="color:#003399">奇校验</span></span></p> 
<p align="left" style="background:#f5f5f0"><span style="font-size:14px"><span style="color:#003399">BYTE StopBits; //</span><span style="color:#003399">指定停止位的位数。此成员可以有下列值：</span></span></p> 
<p align="left" style="background:#f5f5f0"><span style="font-size:14px"><span style="color:#003399">ONESTOPBIT 1</span><span style="color:#003399">位停止位</span><span style="color:#003399">  </span>TWOSTOPBITS 2<span style="color:#003399">位停止位</span></span></p> 
<p align="left" style="background:#f5f5f0"><span style="font-size:14px"><span style="color:#003399">ONE5STOPBITS  </span>1.5<span style="color:#003399">位停止位</span></span></p> 
<p align="left" style="background:#f5f5f0"><span style="color:#003399"><span style="font-size:14px">  </span></span>………</p> 
<p align="left" style="background:#f5f5f0"><span style="color:#003399"><span style="font-size:14px"> </span></span>} DCB;</p> 
<p align="left" style="background:#f5f5f0"><span style="font-size:14px"><span style="color:#003399">winbase.h</span><span style="color:#003399">文件中定义了以上用到的常量。如下：</span></span></p> 
<p align="left" style="background:#f5f5f0"><span style="color:#003399"><span style="font-size:14px">#define NOPARITY           </span></span>0</p> 
<p align="left" style="background:#f5f5f0"><span style="color:#003399"><span style="font-size:14px">#define ODDPARITY          </span></span>1</p> 
<p align="left" style="background:#f5f5f0"><span style="color:#003399"><span style="font-size:14px">#define EVENPARITY         </span></span>2</p> 
<p align="left" style="background:#f5f5f0"><span style="color:#003399"><span style="font-size:14px">#define ONESTOPBIT         </span></span>0</p> 
<p align="left" style="background:#f5f5f0"><span style="color:#003399"><span style="font-size:14px">#define ONE5STOPBITS       </span></span>1</p> 
<p align="left" style="background:#f5f5f0"><span style="color:#003399"><span style="font-size:14px">#define TWOSTOPBITS        </span></span>2</p> 
<p align="left" style="background:#f5f5f0"><span style="color:#003399"><span style="font-size:14px">#define CBR_110            </span></span>110</p> 
<p align="left" style="background:#f5f5f0"><span style="color:#003399"><span style="font-size:14px">#define CBR_300            </span></span>300</p> 
<p align="left" style="background:#f5f5f0"><span style="color:#003399"><span style="font-size:14px">#define CBR_600            </span></span>600</p> 
<p align="left" style="background:#f5f5f0"><span style="color:#003399"><span style="font-size:14px">#define CBR_1200           </span></span>1200</p> 
<p align="left" style="background:#f5f5f0"><span style="color:#003399"><span style="font-size:14px">#define CBR_2400           </span></span>2400</p> 
<p align="left" style="background:#f5f5f0"><span style="color:#003399"><span style="font-size:14px">#define CBR_4800           </span></span>4800</p> 
<p align="left" style="background:#f5f5f0"><span style="color:#003399"><span style="font-size:14px">#define CBR_9600           </span></span>9600</p> 
<p align="left" style="background:#f5f5f0"><span style="color:#003399"><span style="font-size:14px">#define CBR_14400          </span></span>14400</p> 
<p align="left" style="background:#f5f5f0"><span style="color:#003399"><span style="font-size:14px">#define CBR_19200          </span></span>19200</p> 
<p align="left" style="background:#f5f5f0"><span style="color:#003399"><span style="font-size:14px">#define CBR_38400          </span></span>38400</p> 
<p align="left" style="background:#f5f5f0"><span style="color:#003399"><span style="font-size:14px">#define CBR_56000          </span></span>56000</p> 
<p align="left" style="background:#f5f5f0"><span style="color:#003399"><span style="font-size:14px">#define CBR_57600          </span></span>57600</p> 
<p align="left" style="background:#f5f5f0"><span style="color:#003399"><span style="font-size:14px">#define CBR_115200         </span></span>115200</p> 
<p align="left" style="background:#f5f5f0"><span style="color:#003399"><span style="font-size:14px">#define CBR_128000         </span></span>128000</p> 
<p align="left" style="background:#f5f5f0"><span style="color:#003399"><span style="font-size:14px">#define CBR_256000         </span></span>256000</p> 
<p align="left"><span style="font-size:14px">GetCommState函数可以获得COM口的设备控制块，从而获得相关参数：</span></p> 
<p align="left" style="background:#f5f5f0"><span style="color:#003399"><span style="font-size:14px">BOOL GetCommState(</span></span></p> 
<p align="left" style="background:#f5f5f0"><span style="font-size:14px"><span style="color:#003399">  </span>HANDLE hFile, //<span style="color:#003399">标识通讯端口的句柄</span></span></p> 
<p align="left" style="background:#f5f5f0"><span style="font-size:14px"><span style="color:#003399">  </span>LPDCB lpDCB //<span style="color:#003399">指向一个设备控制块（</span><span style="color:#003399">DCB</span><span style="color:#003399">结构）的指针</span></span></p> 
<p align="left" style="background:#f5f5f0"><span style="color:#003399"><span style="font-size:14px"> </span></span>);</p> 
<p align="left" style="background:#f5f5f0"><span style="font-size:14px"><span style="color:#003399">SetCommState</span><span style="color:#003399">函数设置</span><span style="color:#003399">COM</span><span style="color:#003399">口的设备控制块：</span></span></p> 
<p align="left" style="background:#f5f5f0"><span style="color:#003399"><span style="font-size:14px">BOOL SetCommState(</span></span></p> 
<p align="left" style="background:#f5f5f0"><span style="color:#003399"><span style="font-size:14px">  </span></span>HANDLE hFile, </p> 
<p align="left" style="background:#f5f5f0"><span style="color:#003399"><span style="font-size:14px">  </span></span>LPDCB lpDCB </p> 
<p align="left" style="background:#f5f5f0"><span style="color:#003399"><span style="font-size:14px"> </span></span>);</p> 
<p align="left"><span style="font-size:14px">　　除了在BCD中的设置外，程序一般还需要设置I/O缓冲区的大小和超时。Windows用I/O缓冲区来暂存串口输入和输出的数据。如果通信的速率较高，则应该设置较大的缓冲区。调用SetupComm函数可以设置串行口的输入和输出缓冲区的大小。</span></p> 
<p align="left" style="background:#f5f5f0"><span style="color:#003399"><span style="font-size:14px">BOOL SetupComm(</span></span></p> 
<p align="left" style="background:#f5f5f0"><span style="color:#003399"><span style="font-size:14px"> </span></span></p> 
<p align="left" style="background:#f5f5f0"><span style="font-size:14px"><span style="color:#003399">   </span>HANDLE hFile,   // <span style="color:#003399">通信设备的句柄</span></span></p> 
<p align="left" style="background:#f5f5f0"><span style="font-size:14px"><span style="color:#003399">   </span>DWORD dwInQueue, // <span style="color:#003399">输入缓冲区的大小（字节数）</span></span></p> 
<p align="left" style="background:#f5f5f0"><span style="font-size:14px"><span style="color:#003399">   </span>DWORD dwOutQueue // <span style="color:#003399">输出缓冲区的大小（字节数）</span></span></p> 
<p align="left" style="background:#f5f5f0"><span style="color:#003399"><span style="font-size:14px">  </span></span>);</p> 
<p align="left"><span style="font-size:14px">在用ReadFile和WriteFile读写串行口时，需要考虑超时问题。超时的作用是在指定的时间内没有读入或发送指定数量的字符，ReadFile或WriteFile的操作仍然会结束。</span></p> 
<p align="left"><span style="font-size:14px">要查询当前的超时设置应调用GetCommTimeouts函数，该函数会填充一个COMMTIMEOUTS结构。调用SetCommTimeouts可以用某一个COMMTIMEOUTS结构的内容来设置超时。</span></p> 
<p align="left"><span style="font-size:14px">读写串口的超时有两种：间隔超时和总超时。间隔超时是指在接收时两个字符之间的最大时延。总超时是指读写操作总共花费的最大时间。写操作只支持总超时，而读操作两种超时均支持。用COMMTIMEOUTS结构可以规定读写操作的超时。</span></p> 
<p align="left"><span style="font-size:14px">COMMTIMEOUTS结构的定义为： </span></p> 
<p align="left" style="background:#f5f5f0"><span style="color:#003399"><span style="font-size:14px">typedef struct _COMMTIMEOUTS {  </span></span></p> 
<p align="left" style="background:#f5f5f0"><span style="font-size:14px"><span style="color:#003399">   </span>DWORD ReadIntervalTimeout; //<span style="color:#003399">读间隔超时</span></span></p> 
<p align="left" style="background:#f5f5f0"><span style="font-size:14px"><span style="color:#003399">   </span>DWORD ReadTotalTimeoutMultiplier; //<span style="color:#003399">读时间系数</span></span></p> 
<p align="left" style="background:#f5f5f0"><span style="font-size:14px"><span style="color:#003399">   </span>DWORD ReadTotalTimeoutConstant; //<span style="color:#003399">读时间常量</span></span></p> 
<p align="left" style="background:#f5f5f0"><span style="font-size:14px"><span style="color:#003399">   </span>DWORD WriteTotalTimeoutMultiplier; // <span style="color:#003399">写时间系数</span></span></p> 
<p align="left" style="background:#f5f5f0"><span style="font-size:14px"><span style="color:#003399">   </span>DWORD WriteTotalTimeoutConstant; //<span style="color:#003399">写时间常量</span></span></p> 
<p align="left" style="background:#f5f5f0"><span style="color:#003399"><span style="font-size:14px">} COMMTIMEOUTS,*LPCOMMTIMEOUTS;</span></span></p> 
<p align="left"><span style="font-size:14px">COMMTIMEOUTS结构的成员都以毫秒为单位。总超时的计算公式是：</span></p> 
<p align="left"><span style="font-size:14px">总超时＝时间系数×要求读/写的字符数＋时间常量 </span></p> 
<p align="left"><span style="font-size:14px">例如，要读入10个字符，那么读操作的总超时的计算公式为：</span></p> 
<p align="left"><span style="font-size:14px">读总超时＝ReadTotalTimeoutMultiplier×10＋</span><span style="font-size:14px">ReadTotalTimeoutConstant<br> 可以看出：间隔超时和总超时的设置是不相关的，这可以方便通信程序灵活地设置各种超时。 </span></p> 
<p align="left"><span style="font-size:14px">如果所有写超时参数均为0，那么就不使用写超时。如果ReadIntervalTimeout为0，那么就不使用读间隔超时。如果ReadTotalTimeoutMultiplier 和 ReadTotalTimeoutConstant 都为0，则不使用读总超时。如果读间隔超时被设置成MAXDWORD并且读时间系数和读时间常量都为0，那么在读一次输入缓冲区的内容后读操作就立即返回，而不管是否读入了要求的字符。</span></p> 
<p align="left"><span style="font-size:14px">在用重叠方式读写串口时，虽然ReadFile和WriteFile在完成操作以前就可能返回，但超时仍然是起作用的。在这种情况下，超时规定的是操作的完成时间，而不是ReadFile和WriteFile的返回时间。</span></p> 
<p align="left"><span style="font-size:14px">配置串口的示例代码： </span></p> 
<p align="left" style="background:#f5f5f0"><span style="font-size:14px"><span style="color:#003399">      </span>SetupComm(hCom,1024,1024); //<span style="color:#003399">输入缓冲区和输出缓冲区的大小都是</span><span style="color:#003399">1024</span></span></p> 
<p align="left" style="background:#f5f5f0"><span style="color:#003399"><span style="font-size:14px"> </span></span></p> 
<p align="left" style="background:#f5f5f0"><span style="color:#003399"><span style="font-size:14px">      </span></span>COMMTIMEOUTS TimeOuts;</p> 
<p align="left" style="background:#f5f5f0"><span style="font-size:14px"><span style="color:#003399">      </span>//<span style="color:#003399">设定读超时</span></span></p> 
<p align="left" style="background:#f5f5f0"><span style="color:#003399"><span style="font-size:14px">      </span></span>TimeOuts.ReadIntervalTimeout=1000;</p> 
<p align="left" style="background:#f5f5f0"><span style="color:#003399"><span style="font-size:14px">      </span></span>TimeOuts.ReadTotalTimeoutMultiplier=500;</p> 
<p align="left" style="background:#f5f5f0"><span style="color:#003399"><span style="font-size:14px">      </span></span>TimeOuts.ReadTotalTimeoutConstant=5000;</p> 
<p align="left" style="background:#f5f5f0"><span style="font-size:14px"><span style="color:#003399">      </span>//<span style="color:#003399">设定写超时</span></span></p> 
<p align="left" style="background:#f5f5f0"><span style="color:#003399"><span style="font-size:14px">      </span></span>TimeOuts.WriteTotalTimeoutMultiplier=500;</p> 
<p align="left" style="background:#f5f5f0"><span style="color:#003399"><span style="font-size:14px">      </span></span>TimeOuts.WriteTotalTimeoutConstant=2000;</p> 
<p align="left" style="background:#f5f5f0"><span style="font-size:14px"><span style="color:#003399">      </span>SetCommTimeouts(hCom,&amp;TimeOuts); //<span style="color:#003399">设置超时</span></span></p> 
<p align="left" style="background:#f5f5f0"><span style="color:#003399"><span style="font-size:14px"> </span></span></p> 
<p align="left" style="background:#f5f5f0"><span style="color:#003399"><span style="font-size:14px">      </span></span>DCB dcb;</p> 
<p align="left" style="background:#f5f5f0"><span style="color:#003399"><span style="font-size:14px">      </span></span>GetCommState(hCom,&amp;dcb);</p> 
<p align="left" style="background:#f5f5f0"><span style="font-size:14px"><span style="color:#003399">      </span>dcb.BaudRate=9600; //<span style="color:#003399">波特率为</span><span style="color:#003399">9600</span></span></p> 
<p align="left" style="background:#f5f5f0"><span style="font-size:14px"><span style="color:#003399">      </span>dcb.ByteSize=8; //<span style="color:#003399">每个字节有</span><span style="color:#003399">8</span><span style="color:#003399">位</span></span></p> 
<p align="left" style="background:#f5f5f0"><span style="font-size:14px"><span style="color:#003399">      </span>dcb.Parity=NOPARITY; //<span style="color:#003399">无奇偶校验位</span></span></p> 
<p align="left" style="background:#f5f5f0"><span style="font-size:14px"><span style="color:#003399">      </span>dcb.StopBits=TWOSTOPBITS; //<span style="color:#003399">两个停止位</span></span></p> 
<p align="left" style="background:#f5f5f0"><span style="color:#003399"><span style="font-size:14px">      </span></span>SetCommState(hCom,&amp;dcb);</p> 
<p align="left" style="background:#f5f5f0"><span style="color:#003399"><span style="font-size:14px"> </span></span></p> 
<p align="left" style="background:#f5f5f0"><span style="color:#003399"><span style="font-size:14px">      </span></span>PurgeComm(hCom,PURGE_TXCLEAR|PURGE_RXCLEAR);</p> 
<p align="left"><span style="font-size:14px">在读写串口之前，还要用PurgeComm()函数清空缓冲区，该函数原型：</span></p> 
<p align="left" style="background:#f5f5f0"><span style="color:#003399"><span style="font-size:14px">BOOL PurgeComm(</span></span></p> 
<p align="left" style="background:#f5f5f0"><span style="color:#003399"><span style="font-size:14px"> </span></span></p> 
<p align="left" style="background:#f5f5f0"><span style="font-size:14px"><span style="color:#003399">   </span>HANDLE hFile,   //<span style="color:#003399">串口句柄</span></span></p> 
<p align="left" style="background:#f5f5f0"><span style="font-size:14px"><span style="color:#003399">   </span>DWORD dwFlags   // <span style="color:#003399">需要完成的操作</span></span></p> 
<p align="left" style="background:#f5f5f0"><span style="color:#003399"><span style="font-size:14px">  </span></span>);  </p> 
<p align="left"><span style="font-size:14px">参数dwFlags指定要完成的操作，可以是下列值的组合： </span> </p> 
<p align="left" style="background:#f5f5f0"><span style="font-size:14px"><span style="color:#003399">PURGE_TXABORT</span>  <span style="color:#003399">中断所有写操作并立即返回，即使写操作还没有完成。</span></span></p> 
<p align="left" style="background:#f5f5f0"><span style="font-size:14px"><span style="color:#003399">PURGE_RXABORT</span>  <span style="color:#003399">中断所有读操作并立即返回，即使读操作还没有完成。</span></span></p> 
<p align="left" style="background:#f5f5f0"><span style="font-size:14px"><span style="color:#003399">PURGE_TXCLEAR</span>  <span style="color:#003399">清除输出缓冲区</span></span></p> 
<p align="left" style="background:#f5f5f0"><span style="font-size:14px"><span style="color:#003399">PURGE_RXCLEAR</span>  <span style="color:#003399">清除输入缓冲区</span></span></p> 
<p align="left"><span style="font-size:14px">（3）、</span><a name="%E8%AF%BB%E5%86%99%E4%B8%B2%E5%8F%A3"><span style="color:#000088">读写串口</span></a></p> 
<p align="left"><span style="font-size:14px">我们使用ReadFile和WriteFile读写串口，下面是两个函数的声明：</span></p> 
<p align="left" style="background:#f5f5f0"><span style="color:#003399"><span style="font-size:14px">BOOL ReadFile(</span></span></p> 
<p align="left" style="background:#f5f5f0"><span style="color:#003399"><span style="font-size:14px"> </span></span></p> 
<p align="left" style="background:#f5f5f0"><span style="font-size:14px"><span style="color:#003399">   </span>HANDLE hFile,   //<span style="color:#003399">串口的句柄</span></span></p> 
<p align="left" style="background:#f5f5f0"><span style="color:#003399"><span style="font-size:14px">   </span></span></p> 
<p align="left" style="background:#f5f5f0"><span style="font-size:14px"><span style="color:#003399">   </span>// <span style="color:#003399">读入的数据存储的地址，</span></span></p> 
<p align="left" style="background:#f5f5f0"><span style="font-size:14px"><span style="color:#003399">   </span>// <span style="color:#003399">即读入的数据将存储在以该指针的值为首地址的一片内存区</span></span></p> 
<p align="left" style="background:#f5f5f0"><span style="color:#003399"><span style="font-size:14px">   </span></span>LPVOID lpBuffer, </p> 
<p align="left" style="background:#f5f5f0"><span style="font-size:14px"><span style="color:#003399">   </span>DWORD nNumberOfBytesToRead,   // <span style="color:#003399">要读入的数据的字节数</span></span></p> 
<p align="left" style="background:#f5f5f0"><span style="color:#003399"><span style="font-size:14px">   </span></span></p> 
<p align="left" style="background:#f5f5f0"><span style="font-size:14px"><span style="color:#003399">   </span>// <span style="color:#003399">指向一个</span><span style="color:#003399">DWORD</span><span style="color:#003399">数值，该数值返回读操作实际读入的字节数</span></span></p> 
<p align="left" style="background:#f5f5f0"><span style="color:#003399"><span style="font-size:14px">   </span></span>LPDWORD lpNumberOfBytesRead,  </p> 
<p align="left" style="background:#f5f5f0"><span style="color:#003399"><span style="font-size:14px">   </span></span></p> 
<p align="left" style="background:#f5f5f0"><span style="font-size:14px"><span style="color:#003399">   </span>// <span style="color:#003399">重叠操作时，该参数指向一个</span><span style="color:#003399">OVERLAPPED</span><span style="color:#003399">结构，同步操作时，该参数为</span><span style="color:#003399">NULL</span><span style="color:#003399">。</span></span></p> 
<p align="left" style="background:#f5f5f0"><span style="color:#003399"><span style="font-size:14px">   </span></span>LPOVERLAPPED lpOverlapped     </p> 
<p align="left" style="background:#f5f5f0"><span style="color:#003399"><span style="font-size:14px">  </span></span>);  </p> 
<p align="left" style="background:#f5f5f0"><span style="color:#003399"><span style="font-size:14px">BOOL WriteFile(</span></span></p> 
<p align="left" style="background:#f5f5f0"><span style="color:#003399"><span style="font-size:14px"> </span></span></p> 
<p align="left" style="background:#f5f5f0"><span style="font-size:14px"><span style="color:#003399">   </span>HANDLE hFile,   //<span style="color:#003399">串口的句柄</span></span></p> 
<p align="left" style="background:#f5f5f0"><span style="color:#003399"><span style="font-size:14px">   </span></span></p> 
<p align="left" style="background:#f5f5f0"><span style="font-size:14px"><span style="color:#003399">   </span>// <span style="color:#003399">写入的数据存储的地址，</span></span></p> 
<p align="left" style="background:#f5f5f0"><span style="font-size:14px"><span style="color:#003399">   </span>// <span style="color:#003399">即以该指针的值为首地址的</span><span style="color:#003399">nNumberOfBytesToWrite</span></span></p> 
<p align="left" style="background:#f5f5f0"><span style="font-size:14px"><span style="color:#003399">   </span>// <span style="color:#003399">个字节的数据将要写入串口的发送数据缓冲区。</span></span></p> 
<p align="left" style="background:#f5f5f0"><span style="color:#003399"><span style="font-size:14px">  </span></span> LPCVOID lpBuffer,      </p> 
<p align="left" style="background:#f5f5f0"><span style="color:#003399"><span style="font-size:14px">   </span></span></p> 
<p align="left" style="background:#f5f5f0"><span style="font-size:14px"><span style="color:#003399">   </span>DWORD nNumberOfBytesToWrite,  //<span style="color:#003399">要写入的数据的字节数</span></span></p> 
<p align="left" style="background:#f5f5f0"><span style="color:#003399"><span style="font-size:14px">   </span></span></p> 
<p align="left" style="background:#f5f5f0"><span style="font-size:14px"><span style="color:#003399">   </span>// <span style="color:#003399">指向指向一个</span><span style="color:#003399">DWORD</span><span style="color:#003399">数值，该数值返回实际写入的字节数</span></span></p> 
<p align="left" style="background:#f5f5f0"><span style="color:#003399"><span style="font-size:14px">   </span></span>LPDWORD lpNumberOfBytesWritten,      </p> 
<p align="left" style="background:#f5f5f0"><span style="color:#003399"><span style="font-size:14px">   </span></span></p> 
<p align="left" style="background:#f5f5f0"><span style="font-size:14px"><span style="color:#003399">   </span>// <span style="color:#003399">重叠操作时，该参数指向一个</span><span style="color:#003399">OVERLAPPED</span><span style="color:#003399">结构，</span></span></p> 
<p align="left" style="background:#f5f5f0"><span style="font-size:14px"><span style="color:#003399">   </span>// <span style="color:#003399">同步操作时，该参数为</span><span style="color:#003399">NULL</span><span style="color:#003399">。</span></span></p> 
<p align="left" style="background:#f5f5f0"><span style="color:#003399"><span style="font-size:14px">   </span></span>LPOVERLAPPED lpOverlapped     </p> 
<p align="left" style="background:#f5f5f0"><span style="color:#003399"><span style="font-size:14px">  </span></span>);</p> 
<p align="left"><span style="font-size:14px">在用ReadFile和WriteFile读写串口时，既可以同步执行，也可以重叠执行。在同步执行时，函数直到操作完成后才返回。这意味着同步执行时线程会被阻塞，从而导致效率下降。在重叠执行时，即使操作还未完成，这两个函数也会立即返回，费时的I/O操作在后台进行。</span></p> 
<p align="left"><span style="font-size:14px">ReadFile和WriteFile函数是同步还是异步由CreateFile函数决定，如果在调用CreateFile创建句柄时指定了FILE_FLAG_OVERLAPPED标志，那么调用ReadFile和WriteFile对该句柄进行的操作就应该是重叠的；如果未指定重叠标志，则读写操作应该是同步的。ReadFile和WriteFile函数的同步或者异步应该和CreateFile函数相一致。</span></p> 
<p align="left"><span style="font-size:14px">ReadFile函数只要在串口输入缓冲区中读入指定数量的字符，就算完成操作。而WriteFile函数不但要把指定数量的字符拷入到输出缓冲区，而且要等这些字符从串行口送出去后才算完成操作。</span></p> 
<p align="left"><span style="font-size:14px">如果操作成功，这两个函数都返回TRUE。需要注意的是，当ReadFile和WriteFile返回FALSE时，不一定就是操作失败，线程应该调用GetLastError函数分析返回的结果。例如，在重叠操作时如果操作还未完成函数就返回，那么函数就返回FALSE，而且GetLastError函数返回ERROR_IO_PENDING。这说明重叠操作还未完成。</span></p> 
<p align="left"><span style="font-size:14px">同步方式读写串口比较简单，下面先例举同步方式读写串口的代码： </span> </p> 
<p align="left" style="background:#f5f5f0"><span style="font-size:14px"><span style="color:#003399">//</span><span style="color:#003399">同步读串口</span></span></p> 
<p align="left" style="background:#f5f5f0"><span style="color:#003399"><span style="font-size:14px">char str[100];</span></span></p> 
<p align="left" style="background:#f5f5f0"><span style="font-size:14px"><span style="color:#003399">DWORD wCount;//</span><span style="color:#003399">读取的字节数</span></span></p> 
<p align="left" style="background:#f5f5f0"><span style="color:#003399"><span style="font-size:14px">BOOL bReadStat;</span></span></p> 
<p align="left" style="background:#f5f5f0"><span style="color:#003399"><span style="font-size:14px">bReadStat=ReadFile(hCom,str,100,&amp;wCount,NULL);</span></span></p> 
<p align="left" style="background:#f5f5f0"><span style="color:#003399"><span style="font-size:14px">if(!bReadStat)</span></span></p> 
<p align="left" style="background:#f5f5f0"><span style="color:#003399"><span style="font-size:14px">{<!-- --></span></span></p> 
<p align="left" style="background:#f5f5f0"><span style="font-size:14px"><span style="color:#003399">      </span>AfxMessageBox("<span style="color:#003399">读串口失败</span><span style="color:#003399">!");</span></span></p> 
<p align="left" style="background:#f5f5f0"><span style="color:#003399"><span style="font-size:14px">      </span></span>return FALSE;</p> 
<p align="left" style="background:#f5f5f0"><span style="color:#003399"><span style="font-size:14px">}</span></span></p> 
<p align="left" style="background:#f5f5f0"><span style="color:#003399"><span style="font-size:14px">return TRUE;</span></span></p> 
<p align="left" style="background:#f5f5f0"><span style="color:#003399"><span style="font-size:14px"> </span></span></p> 
<p align="left" style="background:#f5f5f0"><span style="font-size:14px"><span style="color:#003399">//</span><span style="color:#003399">同步写串口</span></span></p> 
<p align="left" style="background:#f5f5f0"><span style="color:#003399"><span style="font-size:14px"> </span></span></p> 
<p align="left" style="background:#f5f5f0"><span style="color:#003399"><span style="font-size:14px">      </span></span>char lpOutBuffer[100];</p> 
<p align="left" style="background:#f5f5f0"><span style="color:#003399"><span style="font-size:14px">      </span></span>DWORD dwBytesWrite=100;</p> 
<p align="left" style="background:#f5f5f0"><span style="color:#003399"><span style="font-size:14px">      </span></span>COMSTAT ComStat;</p> 
<p align="left" style="background:#f5f5f0"><span style="color:#003399"><span style="font-size:14px">      </span></span>DWORD dwErrorFlags;</p> 
<p align="left" style="background:#f5f5f0"><span style="color:#003399"><span style="font-size:14px">      </span></span>BOOL bWriteStat;</p> 
<p align="left" style="background:#f5f5f0"><span style="color:#003399"><span style="font-size:14px">      </span></span>ClearCommError(hCom,&amp;dwErrorFlags,&amp;ComStat);</p> 
<p align="left" style="background:#f5f5f0"><span style="color:#003399"><span style="font-size:14px">      </span></span>bWriteStat=WriteFile(hCom,lpOutBuffer,dwBytesWrite,&amp; dwBytesWrite,NULL);</p> 
<p align="left" style="background:#f5f5f0"><span style="color:#003399"><span style="font-size:14px">      </span></span>if(!bWriteStat)</p> 
<p align="left" style="background:#f5f5f0"><span style="color:#003399"><span style="font-size:14px">      </span></span>{<!-- --></p> 
<p align="left" style="background:#f5f5f0"><span style="font-size:14px"><span style="color:#003399">             </span>AfxMessageBox("<span style="color:#003399">写串口失败</span><span style="color:#003399">!");</span></span></p> 
<p align="left" style="background:#f5f5f0"><span style="color:#003399"><span style="font-size:14px">      </span></span>}</p> 
<p align="left" style="background:#f5f5f0"><span style="color:#003399"><span style="font-size:14px">      </span></span>PurgeComm(hCom, PURGE_TXABORT|</p> 
<p align="left" style="background:#f5f5f0"><span style="color:#003399"><span style="font-size:14px">             </span></span>PURGE_RXABORT|PURGE_TXCLEAR|PURGE_RXCLEAR);</p> 
<p align="left"><span style="font-size:14px">在重叠操作时,操作还未完成函数就返回。</span></p> 
<p align="left"><span style="font-size:14px"> </span></p> 
<p align="left"><span style="font-size:14px">重叠I/O非常灵活，它也可以实现阻塞（例如我们可以设置一定要读取到一个数据才能进行到下一步操作）。有两种方法可以等待操作完成：一种方法是用象WaitForSingleObject这样的等待函数来等待OVERLAPPED结构的hEvent成员；另一种方法是调用GetOverlappedResult函数等待，后面将演示说明。</span><br> <span style="font-size:14px">下面我们先简单说一下OVERLAPPED结构和GetOverlappedResult函数：</span><br> <span style="font-size:14px">OVERLAPPED</span><span style="font-size:14px">结构</span></p> 
<p align="left"><span style="font-size:14px">OVERLAPPED结构包含了重叠I/O的一些信息，定义如下： </span> </p> 
<p align="left" style="background:#f5f5f0"><span style="color:#003399"><span style="font-size:14px">typedef struct _OVERLAPPED { // o </span></span></p> 
<p align="left" style="background:#f5f5f0"><span style="color:#003399"><span style="font-size:14px">   </span></span>DWORD  Internal; </p> 
<p align="left" style="background:#f5f5f0"><span style="color:#003399"><span style="font-size:14px">   </span></span>DWORD  InternalHigh; </p> 
<p align="left" style="background:#f5f5f0"><span style="color:#003399"><span style="font-size:14px">   </span></span>DWORD  Offset; </p> 
<p align="left" style="background:#f5f5f0"><span style="color:#003399"><span style="font-size:14px">   </span></span>DWORD  OffsetHigh; </p> 
<p align="left" style="background:#f5f5f0"><span style="color:#003399"><span style="font-size:14px">   </span></span>HANDLE hEvent; </p> 
<p align="left" style="background:#f5f5f0"><span style="color:#003399"><span style="font-size:14px">} OVERLAPPED;</span></span></p> 
<p align="left"><span style="font-size:14px">　　在使用ReadFile和WriteFile重叠操作时，线程需要创建OVERLAPPED结构以供这两个函数使用。线程通过OVERLAPPED结构获得当前的操作状态，该结构最重要的成员是hEvent。hEvent是读写事件。当串口使用异步通讯时，函数返回时操作可能还没有完成，程序可以通过检查该事件得知是否读写完毕。</span><br> <span style="font-size:14px">　　当调用ReadFile, WriteFile 函数的时候，该成员会自动被置为无信号状态；当重叠操作完成后，该成员变量会自动被置为有信号状态。</span></p> 
<p align="left" style="background:#f5f5f0"><span style="font-size:14px"><span style="color:#003399">GetOverlappedResult</span><span style="color:#003399">函数</span></span></p> 
<p align="left" style="background:#f5f5f0"><span style="color:#003399"><span style="font-size:14px">BOOL GetOverlappedResult(</span></span></p> 
<p align="left" style="background:#f5f5f0"><span style="font-size:14px"><span style="color:#003399">   </span>HANDLE hFile,   // <span style="color:#003399">串口的句柄</span><span style="color:#003399"> </span></span></p> 
<p align="left" style="background:#f5f5f0"><span style="color:#003399"><span style="font-size:14px">   </span></span></p> 
<p align="left" style="background:#f5f5f0"><span style="font-size:14px"><span style="color:#003399">   </span>// <span style="color:#003399">指向重叠操作开始时指定的</span><span style="color:#003399">OVERLAPPED</span><span style="color:#003399">结构</span></span></p> 
<p align="left" style="background:#f5f5f0"><span style="color:#003399"><span style="font-size:14px">   </span></span>LPOVERLAPPED lpOverlapped,    </p> 
<p align="left" style="background:#f5f5f0"><span style="color:#003399"><span style="font-size:14px">   </span></span></p> 
<p align="left" style="background:#f5f5f0"><span style="font-size:14px"><span style="color:#003399">   </span>// <span style="color:#003399">指向一个</span><span style="color:#003399">32</span><span style="color:#003399">位变量，该变量的值返回实际读写操作传输的字节数。</span></span></p> 
<p align="left" style="background:#f5f5f0"><span style="color:#003399"><span style="font-size:14px">   </span></span>LPDWORD lpNumberOfBytesTransferred,  </p> 
<p align="left" style="background:#f5f5f0"><span style="color:#003399"><span style="font-size:14px">   </span></span></p> 
<p align="left" style="background:#f5f5f0"><span style="font-size:14px"><span style="color:#003399">   </span>// <span style="color:#003399">该参数用于指定函数是否一直等到重叠操作结束。</span></span></p> 
<p align="left" style="background:#f5f5f0"><span style="font-size:14px"><span style="color:#003399">   </span>// <span style="color:#003399">如果该参数为</span><span style="color:#003399">TRUE</span><span style="color:#003399">，函数直到操作结束才返回。</span></span></p> 
<p align="left" style="background:#f5f5f0"><span style="font-size:14px"><span style="color:#003399">   </span>// <span style="color:#003399">如果该参数为</span><span style="color:#003399">FALSE</span><span style="color:#003399">，函数直接返回，这时如果操作没有完成，</span></span></p> 
<p align="left" style="background:#f5f5f0"><span style="font-size:14px"><span style="color:#003399">   </span>// <span style="color:#003399">通过调用</span><span style="color:#003399">GetLastError()</span><span style="color:#003399">函数会返回</span><span style="color:#003399">ERROR_IO_INCOMPLETE</span><span style="color:#003399">。</span></span></p> 
<p align="left" style="background:#f5f5f0"><span style="color:#003399"><span style="font-size:14px">   </span></span>BOOL bWait      </p> 
<p align="left" style="background:#f5f5f0"><span style="color:#003399"><span style="font-size:14px">  </span></span>);  </p> 
<p align="left"><span style="font-size:14px">该函数返回重叠操作的结果，用来判断异步操作是否完成，它是通过判断OVERLAPPED结构中的hEvent是否被置位来实现的。</span></p> 
<p align="left"><span style="font-size:14px"> </span></p> 
<p align="left"><span style="font-size:14px">异步读串口的示例代码： </span></p> 
<p align="left" style="background:#f5f5f0"><span style="color:#003399"><span style="font-size:14px">char lpInBuffer[1024];</span></span></p> 
<p align="left" style="background:#f5f5f0"><span style="color:#003399"><span style="font-size:14px">DWORD dwBytesRead=1024;</span></span></p> 
<p align="left" style="background:#f5f5f0"><span style="color:#003399"><span style="font-size:14px">COMSTAT ComStat;</span></span></p> 
<p align="left" style="background:#f5f5f0"><span style="color:#003399"><span style="font-size:14px">DWORD dwErrorFlags;</span></span></p> 
<p align="left" style="background:#f5f5f0"><span style="color:#003399"><span style="font-size:14px">OVERLAPPED m_osRead;</span></span></p> 
<p align="left" style="background:#f5f5f0"><span style="color:#003399"><span style="font-size:14px">memset(&amp;m_osRead,0,sizeof(OVERLAPPED));</span></span></p> 
<p align="left" style="background:#f5f5f0"><span style="color:#003399"><span style="font-size:14px">m_osRead.hEvent=CreateEvent(NULL,TRUE,FALSE,NULL);</span></span></p> 
<p align="left" style="background:#f5f5f0"><span style="color:#003399"><span style="font-size:14px"> </span></span></p> 
<p align="left" style="background:#f5f5f0"><span style="color:#003399"><span style="font-size:14px">ClearCommError(hCom,&amp;dwErrorFlags,&amp;ComStat);</span></span></p> 
<p align="left" style="background:#f5f5f0"><span style="color:#003399"><span style="font-size:14px">dwBytesRead=min(dwBytesRead,(DWORD)ComStat.cbInQue);</span></span></p> 
<p align="left" style="background:#f5f5f0"><span style="color:#003399"><span style="font-size:14px">if(!dwBytesRead)</span></span></p> 
<p align="left" style="background:#f5f5f0"><span style="color:#003399"><span style="font-size:14px">return FALSE;</span></span></p> 
<p align="left" style="background:#f5f5f0"><span style="color:#003399"><span style="font-size:14px">BOOL bReadStatus;</span></span></p> 
<p align="left" style="background:#f5f5f0"><span style="color:#003399"><span style="font-size:14px">bReadStatus=ReadFile(hCom,lpInBuffer,</span></span></p> 
<p align="left" style="background:#f5f5f0"><span style="color:#003399"><span style="font-size:14px">                                 </span></span> dwBytesRead,&amp;dwBytesRead,&amp;m_osRead);</p> 
<p align="left" style="background:#f5f5f0"><span style="color:#003399"><span style="font-size:14px"> </span></span></p> 
<p align="left" style="background:#f5f5f0"><span style="font-size:14px"><span style="color:#003399">if(!bReadStatus) //</span><span style="color:#003399">如果</span><span style="color:#003399">ReadFile</span><span style="color:#003399">函数返回</span><span style="color:#003399">FALSE</span></span></p> 
<p align="left" style="background:#f5f5f0"><span style="color:#003399"><span style="font-size:14px">{<!-- --></span></span></p> 
<p align="left" style="background:#f5f5f0"><span style="color:#003399"><span style="font-size:14px">      </span></span>if(GetLastError()==ERROR_IO_PENDING)</p> 
<p align="left" style="background:#f5f5f0"><span style="font-size:14px"><span style="color:#003399">      </span>//GetLastError()<span style="color:#003399">函数返回</span><span style="color:#003399">ERROR_IO_PENDING,</span><span style="color:#003399">表明串口正在进行读操作</span></span></p> 
<p align="left" style="background:#f5f5f0"><span style="color:#003399"><span style="font-size:14px">      </span></span>{<!-- --></p> 
<p align="left" style="background:#f5f5f0"><span style="color:#003399"><span style="font-size:14px">             </span></span>WaitForSingleObject(m_osRead.hEvent,2000);</p> 
<p align="left" style="background:#f5f5f0"><span style="font-size:14px"><span style="color:#003399">             </span>//<span style="color:#003399">使用</span><span style="color:#003399">WaitForSingleObject</span><span style="color:#003399">函数等待，直到读操作完成或延时已达到</span><span style="color:#003399">2</span><span style="color:#003399">秒钟</span></span></p> 
<p align="left" style="background:#f5f5f0"><span style="font-size:14px"><span style="color:#003399">             </span>//<span style="color:#003399">当串口读操作进行完毕后，</span><span style="color:#003399">m_osRead</span><span style="color:#003399">的</span><span style="color:#003399">hEvent</span><span style="color:#003399">事件会变为有信号</span></span></p> 
<p align="left" style="background:#f5f5f0"><span style="color:#003399"><span style="font-size:14px">             </span></span>PurgeComm(hCom, PURGE_TXABORT|</p> 
<p align="left" style="background:#f5f5f0"><span style="color:#003399"><span style="font-size:14px">                   </span></span>PURGE_RXABORT|PURGE_TXCLEAR|PURGE_RXCLEAR);</p> 
<p align="left" style="background:#f5f5f0"><span style="color:#003399"><span style="font-size:14px">             </span></span>return dwBytesRead;</p> 
<p align="left" style="background:#f5f5f0"><span style="color:#003399"><span style="font-size:14px">      </span></span>}</p> 
<p align="left" style="background:#f5f5f0"><span style="color:#003399"><span style="font-size:14px">      </span></span>return 0;</p> 
<p align="left" style="background:#f5f5f0"><span style="color:#003399"><span style="font-size:14px">}</span></span></p> 
<p align="left" style="background:#f5f5f0"><span style="color:#003399"><span style="font-size:14px">PurgeComm(hCom, PURGE_TXABORT|</span></span></p> 
<p align="left" style="background:#f5f5f0"><span style="color:#003399"><span style="font-size:14px">             </span></span>  PURGE_RXABORT|PURGE_TXCLEAR|PURGE_RXCLEAR);</p> 
<p align="left" style="background:#f5f5f0"><span style="color:#003399"><span style="font-size:14px">return dwBytesRead;</span></span></p> 
<p align="left"><span style="font-size:14px">　　对以上代码再作简要说明：在使用ReadFile 函数进行读操作前，应先使用ClearCommError函数清除错误。ClearCommError函数的原型如下：</span></p> 
<p align="left" style="background:#f5f5f0"><span style="color:#003399"><span style="font-size:14px">BOOL ClearCommError(</span></span></p> 
<p align="left" style="background:#f5f5f0"><span style="color:#003399"><span style="font-size:14px"> </span></span></p> 
<p align="left" style="background:#f5f5f0"><span style="font-size:14px"><span style="color:#003399">   </span>HANDLE hFile,   // <span style="color:#003399">串口句柄</span></span></p> 
<p align="left" style="background:#f5f5f0"><span style="font-size:14px"><span style="color:#003399">   </span>LPDWORD lpErrors,      // <span style="color:#003399">指向接收错误码的变量</span></span></p> 
<p align="left" style="background:#f5f5f0"><span style="font-size:14px"><span style="color:#003399">   </span>LPCOMSTAT lpStat // <span style="color:#003399">指向通讯状态缓冲区</span></span></p> 
<p align="left" style="background:#f5f5f0"><span style="color:#003399"><span style="font-size:14px">  </span></span>);  </p> 
<p align="left"><span style="font-size:14px">该函数获得通信错误并报告串口的当前状态，同时，该函数清除串口的错误标志以便继续输入、输出操作。</span></p> 
<p align="left"><span style="font-size:14px">参数lpStat指向一个COMSTAT结构，该结构返回串口状态信息。 COMSTAT结构 COMSTAT结构包含串口的信息，结构定义如下：</span></p> 
<p align="left" style="background:#f5f5f0"><span style="color:#003399"><span style="font-size:14px">typedef struct _COMSTAT { // cst </span></span></p> 
<p align="left" style="background:#f5f5f0"><span style="color:#003399"><span style="font-size:14px">   </span></span>DWORD fCtsHold : 1;   // Tx waiting for CTS signal </p> 
<p align="left" style="background:#f5f5f0"><span style="color:#003399"><span style="font-size:14px">   </span></span>DWORD fDsrHold : 1;   // Tx waiting for DSR signal </p> 
<p align="left" style="background:#f5f5f0"><span style="color:#003399"><span style="font-size:14px">   </span></span>DWORD fRlsdHold : 1;  // Tx waiting for RLSD signal </p> 
<p align="left" style="background:#f5f5f0"><span style="color:#003399"><span style="font-size:14px">   </span></span>DWORD fXoffHold : 1;  // Tx waiting, XOFF char rec''d </p> 
<p align="left" style="background:#f5f5f0"><span style="color:#003399"><span style="font-size:14px">   </span></span>DWORD fXoffSent : 1;  // Tx waiting, XOFF char sent </p> 
<p align="left" style="background:#f5f5f0"><span style="color:#003399"><span style="font-size:14px">   </span></span>DWORD fEof : 1;       // EOF character sent </p> 
<p align="left" style="background:#f5f5f0"><span style="color:#003399"><span style="font-size:14px">   </span></span>DWORD fTxim : 1;      // character waiting for Tx </p> 
<p align="left" style="background:#f5f5f0"><span style="color:#003399"><span style="font-size:14px">   </span></span>DWORD fReserved : 25; // reserved </p> 
<p align="left" style="background:#f5f5f0"><span style="color:#003399"><span style="font-size:14px">   </span></span>DWORD cbInQue;        // bytes in input buffer </p> 
<p align="left" style="background:#f5f5f0"><span style="color:#003399"><span style="font-size:14px">   </span></span>DWORD cbOutQue;       // bytes in output buffer </p> 
<p align="left" style="background:#f5f5f0"><span style="color:#003399"><span style="font-size:14px">} COMSTAT, *LPCOMSTAT;</span></span></p> 
<p align="left"><span style="font-size:14px">本文只用到了cbInQue成员变量，该成员变量的值代表输入缓冲区的字节数。</span></p> 
<p align="left"><span style="font-size:14px"> </span></p> 
<p align="left"><span style="font-size:14px">　　最后用PurgeComm函数清空串口的输入输出缓冲区。 </span> </p> 
<p align="left"><span style="font-size:14px">　　这段代码用WaitForSingleObject函数来等待OVERLAPPED结构的hEvent成员，下面我们再演示一段调用GetOverlappedResult函数等待的异步读串口示例代码：</span></p> 
<p align="left" style="background:#f5f5f0"><span style="color:#003399"><span style="font-size:14px">char lpInBuffer[1024];</span></span></p> 
<p align="left" style="background:#f5f5f0"><span style="color:#003399"><span style="font-size:14px">DWORD dwBytesRead=1024;</span></span></p> 
<p align="left" style="background:#f5f5f0"><span style="color:#003399"><span style="font-size:14px">      </span></span>BOOL bReadStatus;</p> 
<p align="left" style="background:#f5f5f0"><span style="color:#003399"><span style="font-size:14px">      </span></span>DWORD dwErrorFlags;</p> 
<p align="left" style="background:#f5f5f0"><span style="color:#003399"><span style="font-size:14px">      </span></span>COMSTAT ComStat;</p> 
<p align="left" style="background:#f5f5f0"><span style="color:#003399"><span style="font-size:14px">OVERLAPPED m_osRead;</span></span></p> 
<p align="left" style="background:#f5f5f0"><span style="color:#003399"><span style="font-size:14px"> </span></span></p> 
<p align="left" style="background:#f5f5f0"><span style="color:#003399"><span style="font-size:14px">      </span></span>ClearCommError(hCom,&amp;dwErrorFlags,&amp;ComStat);</p> 
<p align="left" style="background:#f5f5f0"><span style="color:#003399"><span style="font-size:14px">      </span></span>if(!ComStat.cbInQue)</p> 
<p align="left" style="background:#f5f5f0"><span style="color:#003399"><span style="font-size:14px">             </span></span>return 0;</p> 
<p align="left" style="background:#f5f5f0"><span style="color:#003399"><span style="font-size:14px">      </span></span>dwBytesRead=min(dwBytesRead,(DWORD)ComStat.cbInQue);</p> 
<p align="left" style="background:#f5f5f0"><span style="color:#003399"><span style="font-size:14px">      </span></span>bReadStatus=ReadFile(hCom, lpInBuffer,dwBytesRead,</p> 
<p align="left" style="background:#f5f5f0"><span style="color:#003399"><span style="font-size:14px">             </span></span>&amp;dwBytesRead,&amp;m_osRead);</p> 
<p align="left" style="background:#f5f5f0"><span style="font-size:14px"><span style="color:#003399">      </span>if(!bReadStatus) //<span style="color:#003399">如果</span><span style="color:#003399">ReadFile</span><span style="color:#003399">函数返回</span><span style="color:#003399">FALSE</span></span></p> 
<p align="left" style="background:#f5f5f0"><span style="color:#003399"><span style="font-size:14px">      </span></span>{<!-- --></p> 
<p align="left" style="background:#f5f5f0"><span style="color:#003399"><span style="font-size:14px">             </span></span>if(GetLastError()==ERROR_IO_PENDING)</p> 
<p align="left" style="background:#f5f5f0"><span style="color:#003399"><span style="font-size:14px">             </span></span>{<!-- --></p> 
<p align="left" style="background:#f5f5f0"><span style="color:#003399"><span style="font-size:14px">                   </span></span>GetOverlappedResult(hCom,</p> 
<p align="left" style="background:#f5f5f0"><span style="color:#003399"><span style="font-size:14px">                          </span></span>&amp;m_osRead,&amp;dwBytesRead,TRUE);</p> 
<p align="left" style="background:#f5f5f0"><span style="font-size:14px"><span style="color:#003399">          </span>// GetOverlappedResult<span style="color:#003399">函数的最后一个参数设为</span><span style="color:#003399">TRUE</span><span style="color:#003399">，</span></span></p> 
<p align="left" style="background:#f5f5f0"><span style="font-size:14px"><span style="color:#003399">   </span>       //<span style="color:#003399">函数会一直等待，直到读操作完成或由于错误而返回。</span></span></p> 
<p align="left" style="background:#f5f5f0"><span style="color:#003399"><span style="font-size:14px"> </span></span></p> 
<p align="left" style="background:#f5f5f0"><span style="color:#003399"><span style="font-size:14px">                   </span></span>return dwBytesRead;</p> 
<p align="left" style="background:#f5f5f0"><span style="color:#003399"><span style="font-size:14px">             </span></span>}</p> 
<p align="left" style="background:#f5f5f0"><span style="color:#003399"><span style="font-size:14px">             </span></span>return 0;</p> 
<p align="left" style="background:#f5f5f0"><span style="color:#003399"><span style="font-size:14px">      </span></span>}</p> 
<p align="left" style="background:#f5f5f0"><span style="color:#003399"><span style="font-size:14px">      </span></span>return dwBytesRead;</p> 
<p align="left"><span style="font-size:14px">异步写串口的示例代码： </span></p> 
<p align="left" style="background:#f5f5f0"><span style="color:#003399"><span style="font-size:14px">char buffer[1024];</span></span></p> 
<p align="left" style="background:#f5f5f0"><span style="color:#003399"><span style="font-size:14px">DWORD dwBytesWritten=1024;</span></span></p> 
<p align="left" style="background:#f5f5f0"><span style="color:#003399"><span style="font-size:14px">      </span></span>DWORD dwErrorFlags;</p> 
<p align="left" style="background:#f5f5f0"><span style="color:#003399"><span style="font-size:14px">      </span></span>COMSTAT ComStat;</p> 
<p align="left" style="background:#f5f5f0"><span style="color:#003399"><span style="font-size:14px">OVERLAPPED m_osWrite;</span></span></p> 
<p align="left" style="background:#f5f5f0"><span style="color:#003399"><span style="font-size:14px">      </span></span>BOOL bWriteStat;</p> 
<p align="left" style="background:#f5f5f0"><span style="color:#003399"><span style="font-size:14px"> </span></span></p> 
<p align="left" style="background:#f5f5f0"><span style="color:#003399"><span style="font-size:14px">      </span></span>bWriteStat=WriteFile(hCom,buffer,dwBytesWritten,</p> 
<p align="left" style="background:#f5f5f0"><span style="color:#003399"><span style="font-size:14px">             </span></span>&amp;dwBytesWritten,&amp;m_OsWrite);</p> 
<p align="left" style="background:#f5f5f0"><span style="color:#003399"><span style="font-size:14px">      </span></span>if(!bWriteStat)</p> 
<p align="left" style="background:#f5f5f0"><span style="color:#003399"><span style="font-size:14px">      </span></span>{<!-- --></p> 
<p align="left" style="background:#f5f5f0"><span style="color:#003399"><span style="font-size:14px">             </span></span>if(GetLastError()==ERROR_IO_PENDING)</p> 
<p align="left" style="background:#f5f5f0"><span style="color:#003399"><span style="font-size:14px">             </span></span>{<!-- --></p> 
<p align="left" style="background:#f5f5f0"><span style="color:#003399"><span style="font-size:14px">                   </span></span>WaitForSingleObject(m_osWrite.hEvent,1000);</p> 
<p align="left" style="background:#f5f5f0"><span style="color:#003399"><span style="font-size:14px">                   </span></span>return dwBytesWritten;</p> 
<p align="left" style="background:#f5f5f0"><span style="color:#003399"><span style="font-size:14px">             </span></span>}</p> 
<p align="left" style="background:#f5f5f0"><span style="color:#003399"><span style="font-size:14px">             </span></span>return 0;</p> 
<p align="left" style="background:#f5f5f0"><span style="color:#003399"><span style="font-size:14px">      </span></span>}</p> 
<p align="left" style="background:#f5f5f0"><span style="color:#003399"><span style="font-size:14px">      </span></span>return dwBytesWritten;</p> 
<p align="left"><span style="font-size:14px">（4）、</span><a name="%E5%85%B3%E9%97%AD%E4%B8%B2%E5%8F%A3"><span style="color:#000088">关闭串口</span></a></p> 
<p align="left"><span style="font-size:14px">　　利用API函数关闭串口非常简单，只需使用CreateFile函数返回的句柄作为参数调用CloseHandle即可：</span></p> 
<p align="left" style="background:#f5f5f0"><span style="color:#003399"><span style="font-size:14px">BOOL CloseHandle(</span></span></p> 
<p align="left" style="background:#f5f5f0"><span style="color:#003399"><span style="font-size:14px">   </span></span>HANDLE hObject; //handle to object to close </p> 
<p align="left" style="background:#f5f5f0"><span style="color:#003399"><span style="font-size:14px">);</span></span></p> 
<p> </p> 
<p> </p> 
<p> </p> 
<p> </p> 
<p> </p> 
<p> </p> 
<p> </p> 
<p><span style="font-family:Times New Roman; font-size:14px"> </span></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/fcea8d974bea25ca65403ffabd52f22d/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">WM 虚拟机下Ubuntu系统扩展硬盘容量教程</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/5e337d4f2471943ef1fa90df0a049096/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">java的模板类</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>