<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>使用 Yarp 做网关 - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="使用 Yarp 做网关" />
<meta property="og:description" content="资料 GitHub: https://github.com/microsoft/reverse-proxy
YARP 文档：https://microsoft.github.io/reverse-proxy/articles/getting-started.html
主动和被动健康检查 ： https://microsoft.github.io/reverse-proxy/articles/dests-health-checks.html#active-health-check
gRpc：https://microsoft.github.io/reverse-proxy/articles/grpc.html
实战项目概览 Yarp Gateway 示意图
共享类库 创建一个 .Net6.0 的类库，项目名称：Artisan.Shared.Hosting.AspNetCore， 其它项目公用方法放在这个项目。
Serilog 日志 需要的包：
&lt;PackageReference Include=&#34;Serilog.AspNetCore&#34; Version=&#34;5.0.0&#34; /&gt; &lt;PackageReference Include=&#34;Serilog.Sinks.Async&#34; Version=&#34;1.5.0&#34; /&gt; &lt;PackageReference Include=&#34;Serilog.Sinks.Console&#34; Version=&#34;4.0.1&#34; /&gt; &lt;PackageReference Include=&#34;Serilog.Sinks.File&#34; Version=&#34;5.0.0&#34; /&gt; 代码清单：Artisan.Shared.Hosting.AspNetCore/SerilogConfigurationHelper.cs
using Serilog; using Serilog.Events; namespace Artisan.Shared.Hosting.AspNetCore; public static class SerilogConfigurationHelper{ public static void Configure(string applicationName) { Log.Logger = new LoggerConfiguration()#if DEBUG .MinimumLevel.Debug()#else .MinimumLevel.Information()#endif .MinimumLevel.Override(&#34;Microsoft&#34;, LogEventLevel.Information) .MinimumLevel.Override(&#34;Microsoft.EntityFrameworkCore&#34;, LogEventLevel.Warning) .Enrich.FromLogContext() .Enrich.WithProperty(&#34;Application&#34;, $&#34;{applicationName}&#34;) .WriteTo.Async(c =&gt; c." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/1e7c1d0b0579d164eba7d3bae50f2244/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-06-06T08:00:07+08:00" />
<meta property="article:modified_time" content="2022-06-06T08:00:07+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">使用 Yarp 做网关</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <div id="js_content"> 
 <h2>资料</h2> 
 <p>GitHub: https://github.com/microsoft/reverse-proxy</p> 
 <p>YARP 文档：https://microsoft.github.io/reverse-proxy/articles/getting-started.html</p> 
 <p>主动和被动健康检查 ： https://microsoft.github.io/reverse-proxy/articles/dests-health-checks.html#active-health-check</p> 
 <p>gRpc：https://microsoft.github.io/reverse-proxy/articles/grpc.html</p> 
 <h2>实战项目概览</h2> 
 <p>Yarp Gateway 示意图<br><img src="https://images2.imgbox.com/a4/7f/Kx8rDsOg_o.png" alt="dd7cdbcb5100b28f86f61a4938dd8292.png"></p> 
 <h2>共享类库</h2> 
 <p>创建一个 .Net6.0 的类库，项目名称：Artisan.Shared.Hosting.AspNetCore， 其它项目公用方法放在这个项目。</p> 
 <h3>Serilog 日志</h3> 
 <p>需要的包：</p> 
 <pre class="has"><code class="language-go">&lt;PackageReference Include="Serilog.AspNetCore" Version="5.0.0" /&gt;
    &lt;PackageReference Include="Serilog.Sinks.Async" Version="1.5.0" /&gt;
    &lt;PackageReference Include="Serilog.Sinks.Console" Version="4.0.1" /&gt;
    &lt;PackageReference Include="Serilog.Sinks.File" Version="5.0.0" /&gt;</code></pre> 
 <p>代码清单：Artisan.Shared.Hosting.AspNetCore/SerilogConfigurationHelper.cs</p> 
 <pre class="has"><code class="language-go">using Serilog;
using Serilog.Events;

namespace Artisan.Shared.Hosting.AspNetCore;

public static class SerilogConfigurationHelper{
    public static void Configure(string applicationName)
    {
        Log.Logger = new LoggerConfiguration()#if DEBUG
            .MinimumLevel.Debug()#else
            .MinimumLevel.Information()#endif
            .MinimumLevel.Override("Microsoft", LogEventLevel.Information)
            .MinimumLevel.Override("Microsoft.EntityFrameworkCore", LogEventLevel.Warning)
            .Enrich.FromLogContext()
            .Enrich.WithProperty("Application", $"{applicationName}")
            .WriteTo.Async(c =&gt; c.File($"{AppDomain.CurrentDomain.BaseDirectory}/Logs/logs.txt"))
            .WriteTo.Async(c =&gt; c.Console())
            .CreateLogger();
    }
}</code></pre> 
 <h2>创建服务</h2> 
 <h4>IdentityService</h4> 
 <p>创建一个【AspNetCore Web Api】项目，项目名称为：IdentityService</p> 
 <h4>Program</h4> 
 <p>代码清单：IdentityService/Program.cs</p> 
 <pre class="has"><code class="language-go">using Artisan.Shared.Hosting.AspNetCore;
using Microsoft.OpenApi.Models;
using Serilog;

namespace IdentityService;

public class Program{
    public static int Main(string[] args)
    {
        var assemblyName = typeof(Program).Assembly.GetName().Name;

        SerilogConfigurationHelper.Configure(assemblyName);

        try
        {
            Log.Information($"Starting {assemblyName}.");

            var builder = WebApplication.CreateBuilder(args);
            builder.Host
                .UseSerilog();

            builder.Services.AddControllers(); //Web MVC
            builder.Services.AddSwaggerGen(options =&gt;
            {
                options.SwaggerDoc("v1", new OpenApiInfo { Title = "Identity Service", Version = "v1" });
                options.DocInclusionPredicate((docName, description) =&gt; true);
                options.CustomSchemaIds(type =&gt; type.FullName);
            });

            var app = builder.Build();            if (app.Environment.IsDevelopment())
            {
                app.UseDeveloperExceptionPage();
            }
            app.UseRouting();
            app.UseSwagger();
            app.UseSwaggerUI();
            app.UseEndpoints(endpoints =&gt;
            {
                endpoints.MapControllers(); //Web MVC
            });

            app.Run();            return 0;
        }
        catch (Exception ex)
        {
            Log.Fatal(ex, $"{assemblyName} terminated unexpectedly!");            return 1;
        }
        finally
        {
            Log.CloseAndFlush();
        }
    }
}</code></pre> 
 <p>其中：</p> 
 <pre class="has"><code class="language-go">SerilogConfigurationHelper.Configure(assemblyName);</code></pre> 
 <p>是配置 <strong>Serilog</strong> 日志：引用上面创建的共享项目：【Artisan.Shared.Hosting.AspNetCore】</p> 
 <h4>User 实体</h4> 
 <p>代码清单：IdentityService/Models/User.cs</p> 
 <pre class="has"><code class="language-go">public class User
    {
        public int Id { get; set; }
        public string Name { get; set; }
    }</code></pre> 
 <h4>UserController</h4> 
 <p>代码清单：IdentityService/Controlles/UserController.cs</p> 
 <pre class="has"><code class="language-go">using Microsoft.AspNetCore.Mvc;
using IdentityService.Models;
using System.Threading.Tasks;

namespace IdentityService.Controllers
{
    [ApiController]
    [Route("/api/identity/users")]
    public class UserController : Controller
    {
        private readonly ILogger&lt;UserController&gt; _logger;

        private static List&lt;User&gt; Users = new List&lt;User&gt;()
        {
            new User(){ Id = 1, Name = "Jack"},
            new User(){ Id = 2, Name = "Tom"},
            new User(){ Id = 3, Name = "Franck"},
            new User(){ Id = 4, Name = "Tony"},
        };

        public UserController(ILogger&lt;UserController&gt; logger)
        {
            _logger = logger;
        }

        [HttpGet]
        public async Task&lt;List&lt;User&gt;&gt;  GetAllAsync()
        {            return await Task.Run(() =&gt; 
            { 
                return Users; 
            });
        }


        [HttpGet]
        [Route("{id}")]
        public async Task&lt;User&gt; GetAsync(int id)
        {            return await Task.Run(() =&gt;
            {
                var entity = Users.FirstOrDefault(p =&gt; p.Id == id);                if (entity == null)
                {
                    throw new Exception($"未找到用户:{id}");
                }                return entity;
            });
        }

        [HttpPost]
        public async Task&lt;User&gt; CreateAsync(User user)
        {            return await Task.Run(() =&gt;
            {
                Users.Add(user);                return user;
            });
        }

        [HttpPut]
        [Route("{id}")]
        public async Task&lt;User&gt; UpdateAsync(int id, User user)
        {            return await Task.Run(() =&gt;
            {
                var entity = Users.FirstOrDefault(p =&gt; p.Id == id);                if(entity == null)
                {
                    throw new Exception($"未找到用户:{id}");
                }
                entity.Name = user.Name;                return entity;
            });
        }

        [HttpDelete]
        [Route("{id}")]
        public async Task&lt;User&gt; DeleteAsync(int id)
        {            return await Task.Run(() =&gt;
            {
                var entity = Users.FirstOrDefault(p =&gt; p.Id == id);                if (entity == null)
                {
                    throw new Exception($"未找到用户:{id}");
                }
                Users.Remove(entity);                return entity;
            });
        }
    }
}</code></pre> 
 <h4>OrderService</h4> 
 <p>创建一个【AspNetCore Web Api】项目，项目名称为：OrderService</p> 
 <h4>Program</h4> 
 <p>代码清单：OrderService/Program.cs</p> 
 <pre class="has"><code class="language-go">using Artisan.Shared.Hosting.AspNetCore;
using Microsoft.OpenApi.Models;
using Serilog;

namespace OrderService;
public class Program{
    public static int Main(string[] args)
    {
        var assemblyName = typeof(Program).Assembly.GetName().Name;

        SerilogConfigurationHelper.Configure(assemblyName);

        try
        {
            Log.Information($"Starting {assemblyName}.");

            var builder = WebApplication.CreateBuilder(args);
            builder.Host
                .UseSerilog();

            builder.Services.AddControllers(); //Web MVC
            builder.Services.AddSwaggerGen(options =&gt;
            {
                options.SwaggerDoc("v1", new OpenApiInfo { Title = "Order Service", Version = "v1" });
                options.DocInclusionPredicate((docName, description) =&gt; true);
                options.CustomSchemaIds(type =&gt; type.FullName);
            });

            var app = builder.Build();            if (app.Environment.IsDevelopment())
            {
                app.UseDeveloperExceptionPage();
            }
            app.UseRouting();
            app.UseSwagger();
            app.UseSwaggerUI();
            app.UseEndpoints(endpoints =&gt;
            {
                endpoints.MapControllers(); //Web MVC
            });

            app.Run();            return 0;
        }
        catch (Exception ex)
        {
            Log.Fatal(ex, $"{assemblyName} terminated unexpectedly!");            return 1;
        }
        finally
        {
            Log.CloseAndFlush();
        }
    }
}</code></pre> 
 <h4>Order 实体</h4> 
 <p>代码清单：OrderService/Models/Order.cs</p> 
 <pre class="has"><code class="language-go">public class Order
    {
        public string Id { get; set; }
        public string Name { get; set; }
    }</code></pre> 
 <h4>OrderController</h4> 
 <p>代码清单：OrderService/Controlles/OrderController.cs</p> 
 <pre class="has"><code class="language-go">using Microsoft.AspNetCore.Mvc;
using OrderService.Models;
using System.Diagnostics;

namespace OrderService.Controllers
{
    [ApiController]
    [Route("/api/ordering/orders")]
    public class OrderController : Controller
    {
        private readonly ILogger&lt;OrderController&gt; _logger;

        private static List&lt;Order&gt; Orders = new List&lt;Order&gt;()
        {
            new Order(){ Id = "1", Name = "Order #1"},
            new Order(){ Id = "2", Name = "Order #2"},
            new Order(){ Id = "3", Name = "Order #3"},
            new Order(){ Id = "4", Name = "Order #4"},
        };

        public OrderController(ILogger&lt;OrderController&gt; logger)
        {
            _logger = logger;
        }

        [HttpGet]
        public async Task&lt;List&lt;Order&gt;&gt; GetAllAsync()
        {            return await Task.Run(() =&gt;
            {                return Orders;
            });
        }


        [HttpGet]
        [Route("{id}")]
        public async Task&lt;Order&gt; GetAsync(string id)
        {            return await Task.Run(() =&gt;
            {
                var entity = Orders.FirstOrDefault(p =&gt; p.Id == id);                if (entity == null)
                {
                    throw new Exception($"未找到订单:{id}");
                }                return entity;
            });
        }

        [HttpPost]
        public async Task&lt;Order&gt; CreateAsync(Order order)
        {            return await Task.Run(() =&gt;
            {
                Orders.Add(order);                return order;
            });
        }

        [HttpPut]
        [Route("{id}")]
        public async Task&lt;Order&gt; UpdateAsync(string id, Order Order)
        {            return await Task.Run(() =&gt;
            {
                var entity = Orders.FirstOrDefault(p =&gt; p.Id == id);                if (entity == null)
                {
                    throw new Exception($"未找到订单:{id}");
                }
                entity.Name = Order.Name;                return entity;
            });
        }

        [HttpDelete]
        [Route("{id}")]
        public async Task&lt;Order&gt; DeleteAsync(string id)
        {            return await Task.Run(() =&gt;
            {
                var entity = Orders.FirstOrDefault(p =&gt; p.Id == id);                if (entity == null)
                {
                    throw new Exception($"未找到订单:{id}");
                }
                Orders.Remove(entity);                return entity;
            });
        }
    }
}</code></pre> 
 <h2>创建网关</h2> 
 <p>创建一个【AspNetCore 空】项目，项目名称为：YarpGateway</p> 
 <h3>引用包</h3> 
 <pre class="has"><code class="language-go">&lt;PackageReference Include="Yarp.ReverseProxy" Version="1.1.0" /&gt;</code></pre> 
 <h3>添加 Yarp</h3> 
 <p>代码清单：YarpGateway/Program.cs</p> 
 <pre class="has"><code class="language-go">using Artisan.Shared.Hosting.AspNetCore;
using Serilog;
using YarpGateway.Extensions;

namespace YarpGateway;

public class Program{
    public static  int Main(string[] args)
    {
        var assemblyName = typeof(Program).Assembly.GetName().Name;

        SerilogConfigurationHelper.Configure(assemblyName);

        try
        {
            Log.Information($"Starting {assemblyName}.");

            var builder = WebApplication.CreateBuilder(args);
            builder.Host
                .UseSerilog()
                .AddYarpJson(); // 添加Yarp的配置文件

            // 添加Yarp反向代理ReverseProxy
            builder.Services.AddReverseProxy()
                .LoadFromConfig(builder.Configuration.GetSection("ReverseProxy"));

            var app = builder.Build();

            app.UseRouting();
            app.UseEndpoints(endpoints =&gt;
            {                // 添加Yarp终端Endpoints
                endpoints.MapReverseProxy();
            });

            app.Run();            return 0;
        }
        catch (Exception ex)
        {
            Log.Fatal(ex, $"{assemblyName} terminated unexpectedly!");            return 1;
        }
        finally
        {
            Log.CloseAndFlush();
        }
    }
}</code></pre> 
 <p>其中：</p> 
 <p>方法<strong>AddYarpJson()</strong> 是为了把 Yarp 的有关配置从<code>appsetting.json</code>独立处理，避免配置文件很长很长，其代码如下：</p> 
 <p>代码清单：YarpGateway/Extensions/GatewayHostBuilderExtensions.cs</p> 
 <pre class="has"><code class="language-go">namespace YarpGateway.Extensions;

public static class GatewayHostBuilderExtensions{ 
    public const string AppYarpJsonPath = "yarp.json";

    public static IHostBuilder AddYarpJson(
        this IHostBuilder hostBuilder,        bool optional = true,        bool reloadOnChange = true,        string path = AppYarpJsonPath)
    {        return hostBuilder.ConfigureAppConfiguration((_, builder) =&gt;
        {
            builder.AddJsonFile(
                    path: AppYarpJsonPath,
                    optional: optional,
                    reloadOnChange: reloadOnChange
                )
                .AddEnvironmentVariables();
        });
    }
}</code></pre> 
 <p>其中：</p> 
 <p><code>reloadOnChange = true</code> 保证配置文件修改时， Yarp 能重新读取配置文件。</p> 
 <h3>添加 Yarp配置文件 : yarp.json</h3> 
 <p>记得保证文件的属性：</p> 
 <ul><li><p>复制到输出目录：如果内容较新则复制</p></li><li><p>生成操作：内容</p></li></ul> 
 <p>代码清单：YarpGateway/yarp.json</p> 
 <pre class="has"><code class="language-go">{  "ReverseProxy": {    "Routes": {      "Identity Service": {        "ClusterId": "identityCluster",        "Match": {          "Path": "/api/identity/{**everything}"
        }
      },      "Ordering Service": {        "ClusterId": "orderingCluster",        "Match": {          "Path": "/api/ordering/{**everything}"
        }
      }
    },    "Clusters": {      "identityCluster": {        "Destinations": {          "destination1": {            "Address": "http://localhost:7711"
          }
        }
      },      "orderingCluster": {        "Destinations": {          "destination1": {            "Address": "http://localhost:7721"
          }          "destination2": {            "Address": "http://localhost:7722"
          }
        }
      }
    }
  }
}</code></pre> 
 <h2>运行</h2> 
 <p>Yarp Gateway 示意图：</p> 
 <p><img src="https://images2.imgbox.com/25/9f/8fC4MCbV_o.png" alt="2f6202c368bc6cbb9831263288c2b6df.png"></p> 
 <h3>启动网关</h3> 
 <p>在项目的<code>bin/net6.0</code>目录下打开 CMD，执行如下命令启动网关:</p> 
 <pre class="has"><code class="language-go">dotnet YarpGateway.dll --urls "http://localhost:7700"</code></pre> 
 <p>监听端口：7700</p> 
 <h4>IdentityService</h4> 
 <p>在项目的<code>bin/net6.0</code>目录下打开 CMD，执行如下命令启动 Web API 服务:</p> 
 <pre class="has"><code class="language-go">dotnet IdentityService.dll --urls "http://localhost:7711"</code></pre> 
 <p>监听端口：7711</p> 
 <h4>OrderService</h4> 
 <p>开启两个 OrderServcie 的进程，</p> 
 <p>在 <code>bin/net6.0</code>目录下打开 CMD，执行如下命令启动 Web API 服务:</p> 
 <p>第一个监听端口：7721</p> 
 <pre class="has"><code class="language-go">dotnet OrderService.dll --urls "http://localhost:7721"</code></pre> 
 <p>第二个监听端口：7722</p> 
 <pre class="has"><code class="language-go">dotnet OrderService.dll --urls "http://localhost:7722"</code></pre> 
 <h2>测试</h2> 
 <h3>路由功能</h3> 
 <p>打开 PostMan，创建调用服务的各种请求。</p> 
 <h4>IdentityService</h4> 
 <p>创建 <strong>GET</strong> 请求<strong>调用网关</strong>： http://localhost:7700/api/identity/users</p> 
 <p>请求会被<strong>转发到 IdentityService</strong>的集群节点：http://localhost:7711/api/identity/users</p> 
 <h4>OrderService</h4> 
 <p>创建 <strong>GET</strong> 请求<strong>调用网关</strong>： http://localhost:7700/api/ordering/orders</p> 
 <p>请求会被<strong>转发到 OrderService</strong> 的集群中如下某个节点中的一个：</p> 
 <ol><li><p>http://localhost:7721/api/ordering/orders</p></li><li><p>http://localhost:7722/api/ordering/orders</p></li></ol> 
 <h3>支持请求类型</h3> 
 <blockquote> 
  <p>Tips:</p> 
  <p>由于是两个服务，每个服务的进程都是独立的，数据也是独立，数据并没有共享，故测试结果可能不是你所预期的，比如：</p> 
  <p>第一步：增加数据，这次是由第一个服务处理的；</p> 
  <p>第二步：查询数据，如果这次查询是由第二个服务器处理的话，就会找不到刚才新增的数据。</p> 
  <p>当然在实际开发中，我们的数据都是从同一个数据库中读取，不会出现数据不一致的情况。</p> 
 </blockquote> 
 <h4>HTTP 1.0 / 2.0</h4> 
 <p>创建 <strong>GET</strong> 请求： http://localhost:7700/api/ordering/orders/1</p> 
 <p>创建 <strong>POST</strong> 请求： http://localhost:7700/api/ordering/orders 参数：</p> 
 <pre class="has"><code class="language-go">{
    "id":"10",
    "name":"Order #100"}</code></pre> 
 <p>创建 <strong>PUT</strong> 请求： http://localhost:7700/api/ordering/orders/10 参数：</p> 
 <pre class="has"><code class="language-go">{
    "id":"10",
    "name":"Order #100-1"
}</code></pre> 
 <p>创建 <strong>DELETE</strong> 请求： http://localhost:7700/api/ordering/orders/10</p> 
 <h5>结论</h5> 
 <p>上述4种 HTTP 请求都支持。</p> 
 <h4>gRpc</h4> 
 <p>待测试...</p> 
 <h5>结论</h5> 
 <p>支持 gRpc</p> 
 <h3>新增集群服务节点</h3> 
 <p>Yarp 支持动态添加服务集群服务节点，只要在配置文件 <strong>yarp.json</strong>, 添加新的服务配置，Yarp会自动加载新的服务节点：</p> 
 <p>代码清单：yarp.json</p> 
 <pre class="has"><code class="language-go">{
  "ReverseProxy": {
    "Routes": {
      "Identity Service": {
        "ClusterId": "identityCluster",
        "Match": {
          "Path": "/api/identity/{**everything}"
        }
      },
       ...    },
     "Clusters": {
          "orderingCluster": {
            "Destinations": {
              "destination1": {
                "Address": "http://localhost:7721"
              },
    +          "destination2": {
    +            "Address": "http://localhost:7722"
    +          }
            }
      }
    }
  }}</code></pre> 
 <p>添加上述配置后，会看到如下日志信息：</p> 
 <pre class="has"><code class="language-go">14:51:11 DBG] Destination 'destination2' has been added.
[14:51:11 DBG] Existing client reused for cluster 'orderingCluster'.</code></pre> 
 <h4>结论</h4> 
 <p><strong>Yarp 会重新加载配置，使得新增的集群新服务节点生效。</strong></p> 
 <h3>删除集群服务节点</h3> 
 <p>删除集群下的某个服务节点</p> 
 <pre class="has"><code class="language-go">-          "destination2": {
-            "Address": "http://localhost:7722"-          }</code></pre> 
 <p>Yarp 会重新加载配置，该集群服务节点被删除。</p> 
 <pre class="has"><code class="language-go">[14:41:26 DBG] Destination 'destination2' has been removed.
[14:41:26 DBG] Existing client reused for cluster 'orderingCluster'.</code></pre> 
 <h4>结论</h4> 
 <p><strong>Yarp 会重新加载配置，使得被删除的集群服务节点配置失效。</strong></p> 
 <h3>某集群节点因故障离线</h3> 
 <p>把监听7722端口的服务终止，请求还是会发送到这个端口程序上！！！</p> 
 <h4>结论</h4> 
 <p>Yarp 默认不会做健康检查</p> 
 <p>相关：<br>主动和被动健康检查 ： https://microsoft.github.io/reverse-proxy/articles/dests-health-checks.html#active-health-check</p> 
 <p>完成上一节的练习后，还遗留了一个问题：<br><strong>如何通过 YarpGateway 访问内部服务的Swagger呢？</strong></p> 
 <h3>问题：无法访问内部服务 Swagger</h3> 
 <p>外部访问 IdentityService 和 OrderService 是通过 网关：YarpGateway 访问的，使用者这个并不知道这个两个服务的具体地址，也就是不知道如何访问它们的 Swagger，那么：</p> 
 <p>如何通过 YarpGateway 访问这两个服务的Swagger呢？</p> 
 <h3>实现原理</h3> 
 <p>使用网关内部服务的 Swagger 信息，其地址为：</p> 
 <pre class="has"><code class="language-go">http://ip:port/swagger/v1/swagger.json</code></pre> 
 <p>例如，OrderService 服务的 Swagger 信息为：</p> 
 <pre class="has"><code class="language-go">http://localhost:7721/swagger/v1/swagger.json</code></pre> 
 <p>在网关中使用内部服务的 Swagger 终点，再注册 Swagger 终点。</p> 
 <blockquote> 
  <p>访问 OrderService 服务的 Swagger 信息地址：http://localhost:7711/swagger/v1/swagger.json</p> 
  <p>返回如下信息：(只列举部分数据)</p> 
  <pre class="has"><code class="language-go">{
  "openapi": "3.0.1",
  "info": {
    "title": "Identity Service",
    "version": "v1"
  },
  "paths": {
    "/api/identity/users": {
      "get": {
        "tags": [
          "User"
        ],
        "responses": {
          "200": {
            "description": "Success",
            "content": {
              "text/plain": {
                "schema": {
                  "type": "array",
                  "items": {
                    "$ref": "#/components/schemas/IdentityService.Models.User"
                  }
                }
              },
              "application/json": {
                "schema": {
                  "type": "array",
                  "items": {
                    "$ref": "#/components/schemas/IdentityService.Models.User"
                  }
                }
              },
              "text/json": {
                "schema": {
                  "type": "array",
                  "items": {
                    "$ref": "#/components/schemas/IdentityService.Models.User"
                  }
                }
              }
            }
          }
        }
      },
        
     .....</code></pre> 
 </blockquote> 
 <h3>内部服务支持跨域</h3> 
 <p>网关要请求内部服务的Swagger 信息，这是跨域请求，所以要求两个服务支持对网关的跨域请求。</p> 
 <p>在<strong>IdentityService</strong> 和 <strong>OrderService</strong> 项目中都做如下修改：</p> 
 <h4>添加跨域配置</h4> 
 <p>在 <code>appsettins.json</code> 文件中添加跨域配置：</p> 
 <pre class="has"><code class="language-go">{
  "App": {
    "CorsOrigins": "http://localhost:7700"      // 网关地址，支持网关的Yarp gatewary跨域请求
  }}</code></pre> 
 <p>其中，这个地址<strong>http://localhost:7700</strong> 就是<strong>网关的地址</strong>。</p> 
 <h4>支持跨域</h4> 
 <p>修改 <code>Program.cs</code>文件：</p> 
 <ol><li><p>代码清单：IdentityService/Program.cs</p></li><li><p>代码清单：OrderService/Program.cs</p></li></ol> 
 <pre class="has"><code class="language-go">......
            IConfiguration configuration = builder.Configuration;

            builder.Services.AddCors(options =&gt;
            {
                options.AddDefaultPolicy(builder =&gt;
                {
                    builder
                        .WithOrigins(
                            configuration["App:CorsOrigins"]
                                .Split(",", StringSplitOptions.RemoveEmptyEntries)
                                .ToArray()
                        )
                        .SetIsOriginAllowedToAllowWildcardSubdomains()
                        .AllowAnyHeader()
                        .AllowAnyMethod()
                        .AllowCredentials();
                });
            });
......
    
            app.UseRouting();
 +          app.UseCors();  // 添加跨域支持
            app.UseSwagger();
            app.UseSwaggerUI();
.....</code></pre> 
 <h3>网关添加 Swagger</h3> 
 <p>在网关项目【YarpGateway】中做如下修改：</p> 
 <p>代码清单：YarpGateway/Program.cs</p> 
 <pre class="has"><code class="language-go">builder.Services.AddControllers(); //Web MVC
            ......
            builder.Services.AddSwaggerGen(options =&gt;
            {
                options.SwaggerDoc("v1", new OpenApiInfo 
                { 
                    Title = "Gateway", Version = "v1" 
                });
                options.DocInclusionPredicate((docName, description) =&gt; true);
                options.CustomSchemaIds(type =&gt; type.FullName);
            });

            ......            // 添加内部服务的Swagger终点
            app.UseSwaggerUIWithYarp();            //访问网关地址，自动跳转到 /swagger 的首页
            app.UseRewriter(new RewriteOptions() 
                // Regex for "", "/" and "" (whitespace)
                .AddRedirect("^(|\\|\\s+)$", "/swagger"));

            app.UseRouting();</code></pre> 
 <p>其中，调用方法 <strong>app.UseSwaggerUIWithYarp();</strong> 的目的是：添加内部服务的Swagger终点，其代码如下：</p> 
 <p>代码清单：YarpGateway/Extensions/YarpSwaggerUIBuilderExtensions.cs</p> 
 <pre class="has"><code class="language-go">using Yarp.ReverseProxy.Configuration;

namespace YarpGateway.Extensions;
public static class YarpSwaggerUIBuilderExtensions{
    public static IApplicationBuilder UseSwaggerUIWithYarp(this IApplicationBuilder app)
    {
        var serviceProvider = app.ApplicationServices;

        app.UseSwagger();
        app.UseSwaggerUI(options =&gt;
        {
            var configuration = serviceProvider.GetRequiredService&lt;IConfiguration&gt;();
            var logger = serviceProvider.GetRequiredService&lt;ILogger&lt;Program&gt;&gt;();
            var proxyConfigProvider = serviceProvider.GetRequiredService&lt;IProxyConfigProvider&gt;();
            var yarpConfig = proxyConfigProvider.GetConfig();

            var routedClusters = yarpConfig.Clusters
                .SelectMany(t =&gt; t.Destinations,
                    (clusterId, destination) =&gt; new { clusterId.ClusterId, destination.Value });

            var groupedClusters = routedClusters
                .GroupBy(q =&gt; q.Value.Address)
                .Select(t =&gt; t.First())
                .Distinct()
                .ToList();

            foreach (var clusterGroup in groupedClusters)
            {
                var routeConfig = yarpConfig.Routes.FirstOrDefault(q =&gt;
                    q.ClusterId == clusterGroup.ClusterId);                if (routeConfig == null)
                {
                    logger.LogWarning($"Swagger UI: Couldn't find route configuration for {clusterGroup.ClusterId}...");                    continue;
                }

                options.SwaggerEndpoint($"{clusterGroup.Value.Address}/swagger/v1/swagger.json", $"{routeConfig.RouteId} API");
                options.OAuthClientId(configuration["AuthServer:SwaggerClientId"]);
                options.OAuthClientSecret(configuration["AuthServer:SwaggerClientSecret"]);
            }
        });        return app;
    }
}</code></pre> 
 <p>关键代码：</p> 
 <pre class="has"><code class="language-go">options.SwaggerEndpoint($"{clusterGroup.Value.Address}/swagger/v1/swagger.json", $"{routeConfig.RouteId} API");</code></pre> 
 <p>通过 <strong>IProxyConfigProvider</strong> 得到内部服务的信息，如下图所示：</p> 
 <p style="text-align:center;"><img src="https://images2.imgbox.com/3b/71/YZVxxoWp_o.png" alt="80da4efdcf2580a7e5e5272d3597c064.png"></p> 
 <p>然后，拼接出内部服务的 Swagger 信息地址，</p> 
 <pre class="has"><code class="language-go">$"{clusterGroup.Value.Address}/swagger/v1/swagger.json"</code></pre> 
 <p>最终得到两个服务的Swagger信息地址：</p> 
 <ul><li><p>IdentityServer 的 Swagger 信息地址:</p></li></ul> 
 <pre class="has"><code class="language-go">http://localhost:7711/swagger/v1/swagger.json</code></pre> 
 <ul><li><p>OrderService 的 Swagger 信息地址:</p></li></ul> 
 <pre class="has"><code class="language-go">http://localhost:7721/swagger/v1/swagger.json</code></pre> 
 <p>最后,根据信息添加Swagger终点：</p> 
 <pre class="has"><code class="language-go">options.SwaggerEndpoint(
        $"{clusterGroup.Value.Address}/swagger/v1/swagger.json", 
        $"{routeConfig.RouteId} API");</code></pre> 
 <p>其中，</p> 
 <p><code>routeConfig.RouteId</code>: Identity Service 或 Ordering Service</p> 
 <h3>访问网关 Swagger</h3> 
 <p>访问网关地址：http://localhost:7700</p> 
 <p>自动跳转到其 Swagger首页：http://localhost:7700/swagger/index.html</p> 
 <p><img src="https://images2.imgbox.com/08/34/28VtLShB_o.png" alt="e4863c8cd1a7835c0aaed0cab86703b5.png"></p> 
 <p>右上角有个下拉框，可以选择不同的服务的Swagger，这里切换到 OrderService 的Swagger,如下图所示：</p> 
 <p><img src="https://images2.imgbox.com/6f/38/sfjCVgQf_o.png" alt="37846cad15782b43d65f40747dff9003.png"></p> 
 <h3>在网关 Swagger 调用服务接口</h3> 
 <p>可以在网关 Swagger 调用内部服务接口，如下图所示：</p> 
 <p><img src="https://images2.imgbox.com/83/72/HoWvzfPw_o.png" alt="c20eb021fe563cfcc76b16d4dbf8a2b2.png"></p> 
 <p>返回：</p> 
 <p><img src="https://images2.imgbox.com/21/eb/PtltwrFj_o.png" alt="21861baa09244daebe8bd405cfc373f1.png"></p> 
</div>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/68d25deccd578d811f73baaa371d63e6/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">redis实现二次检索</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/42e71199dc55e11111b1c87ed4f21125/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">【JavaScript 教程】浏览器模型—Cookie</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>