<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Day12 重写，构造器，及多态 - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Day12 重写，构造器，及多态" />
<meta property="og:description" content="Day12 方法的重写（override，overwrite） 在子类继承父类之后，可以对父类中的同名同参数的方法进行覆盖。
要求：方法名和形参列表都要一样，否则就是重载，而非重写
重写之后，当创建子类对象之后，通过子类对象调用子，父类中同名同参方法，世界上调用子类重写之后 的方法
重写的规定：
子类重写的方法名和形参列表和父类被重写的方法名和形参列表相同子类重写的方法的权限修饰符不小于父类被重写的方法的权限修饰符 子类不能重写父类中private的方法 返回值类型： 如果父类被重写的方法的返回值是void，则子类必须是void父类被重写的方法的返回值是A类，则子类重写的方法的返回值可以是A类或A类的子类父类被重写的方法的返回值为基本数据类型，则子类重写的方法的返回值必须是相同的基本数据类型 子类重写的方法抛出的异常的类型不大于父类被重写的方法抛出的异常的类型 子类和父类中同名同参的方法要么都为非static（考虑重写），要么都声明为static（不是重写）
super 理解为：父类的
可以用来调用：属性，方法，构造器
一般使用：
可以在子类的方法或构造器中，通过&#34;super.&#34;的方式调用父类的属性或方法，通常情况下省略（属性在内存中不会像方法一样被覆盖，有两个同名属性，默认调用子类，this调用子类，super调用父类）
this.data;// 子类中的data super.data;//父类中的data //考虑 ID 和 身份证号 和 学生证号 等的 关系 子类父类中定义同名的属性时，默认调用子类的，使用super可以调用父类中声明的属性
当子类重写父类中的方法后，我们想在子类的方法中调用父类中被重写方法，必须使用super
调用构造器
我们可以在子类的构造器中显式地使用”super（参数列表）“的方式，调用父类中声明的指定的构造器”super（形参列表）“的使用，必须声明在子类构造器的首行在类的构造器中”this（）”和“super（）”只能二选一，不能同时出现在构造器的首行没有显示地声明“this（）”或“super（）”，默认调用父类中无参构造器 子类对象实例化的过程 结果上看：（继承性）
子类继承父类后，自动获得父类定义的属性和方法
创建子类对象，在堆空间中就加载类父类定义的属性
从过程上看：
通过子类的构造器创建对象时，一定会直接或间接地调用其父类的构造器，从而调用父类的父类的构造器
直到调用java.lang.Object的无参构造器，因为加载过所有父类的结构，所以才可以看到内存中有父类中的结构，子类对象才可以调用
==虽然重建子类对象的时候调用过父类的构造器，但自始至终仅创建过一个对象，即为子类对象。
多态 理解：一个事物的多种形态。以下讲解什么时多态性。
对象的多态性 可以声明父类对象承载子类对象父类的引用指向子类的对象
Person p = new Man(); 通过这种形式调用子父类同名同参的方法时，实际调用的时子类重写的方法——————虚拟方法调用
在编译期，只能调用父类声明的方法，在运行的 时候，实际执行的是子类重写的方法
让秘书去叫一个人，秘书可以叫一个男人或者一个女人。
但是无法调用子类特有的方法和属性多态的使用前提 类的继承关系方法重写 多态不适用于属性 ###　虚拟方法调用
在子类中定义于父类同名同参的方法，在多态情况下，将此时父类的方法称为虚拟方法，父类根据赋给它　的不同子类对象动态地调用子类的方法。这样的方法调用在编译期间时无法确定的，而是在运行时确定。——动态绑定
多态是运行时行为
证明如下：
用随机数进行选择子类，然后调用，只有运行时才能确定调用的是哪个子类的方法
对于重载，他们的调用地址在编译期间就已经绑定了，在调用之前，编译器就知道要调用的方法。这称为“早绑定”或“静态绑定”
对于多态，只有等方法调用的那一刻，编译器（？）才确定所要调用的方法。这称为“晚绑定”或“动态绑定”
不要犯傻，如果他不是晚绑定，他就不是多态——Bruce Eckel" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/37bafbd4d132d8a2e4f70f20dbe99299/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2021-02-06T22:37:30+08:00" />
<meta property="article:modified_time" content="2021-02-06T22:37:30+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Day12 重写，构造器，及多态</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <h2><a id="Day12_0"></a>Day12</h2> 
<h3><a id="overrideoverwrite_2"></a>方法的重写（override，overwrite）</h3> 
<ol><li> <p>在子类继承父类之后，可以对父类中的同名同参数的方法进行覆盖。</p> <p>要求：方法名和形参列表都要一样，否则就是重载，而非重写</p> </li><li> <p>重写之后，当创建子类对象之后，通过子类对象调用子，父类中同名同参方法，世界上调用子类重写之后 的方法</p> </li><li> <p>重写的规定：</p> 
  <ul><li>子类重写的方法名和形参列表和父类被重写的方法名和形参列表相同</li><li>子类重写的方法的权限修饰符不小于父类被重写的方法的权限修饰符 
    <ul><li>子类不能重写父类中private的方法</li></ul> </li><li>返回值类型： 
    <ul><li>如果父类被重写的方法的返回值是void，则子类必须是void</li><li>父类被重写的方法的返回值是A类，则子类重写的方法的返回值可以是A类或A类的子类</li><li>父类被重写的方法的返回值为基本数据类型，则子类重写的方法的返回值必须是相同的基本数据类型</li></ul> </li><li>子类重写的方法抛出的异常的类型不大于父类被重写的方法抛出的异常的类型</li></ul> </li><li> <p><mark>子类和父类中同名同参的方法要么都为非static（考虑重写），要么都声明为static（不是重写）</mark></p> </li></ol> 
<h3><a id="super_23"></a>super</h3> 
<ol><li> <p>理解为：父类的</p> </li><li> <p>可以用来调用：属性，方法，构造器</p> </li><li> <p>一般使用：</p> 
  <ul><li> <p>可以在子类的方法或构造器中，通过"super."的方式调用父类的属性或方法，通常情况下省略（<mark>属性在内存中不会像方法一样被覆盖，有两个同名属性，默认调用子类，this调用子类，super调用父类</mark>）</p> <pre><code class="prism language-java"><span class="token keyword">this</span><span class="token punctuation">.</span>data<span class="token punctuation">;</span><span class="token comment">// 子类中的data</span>
<span class="token keyword">super</span><span class="token punctuation">.</span>data<span class="token punctuation">;</span><span class="token comment">//父类中的data</span>
<span class="token comment">//考虑 ID 和 身份证号 和 学生证号 等的 关系</span>
</code></pre> </li><li> <p>子类父类中定义同名的属性时，默认调用子类的，使用super可以调用父类中声明的属性</p> </li><li> <p>当子类重写父类中的方法后，我们想在子类的方法中调用父类中被重写方法，必须使用super</p> </li></ul> </li><li> <p>调用构造器</p> 
  <ul><li>我们可以在子类的构造器中显式地使用”super（参数列表）“的方式，调用父类中声明的指定的构造器</li><li>”super（形参列表）“的使用，必须声明在子类构造器的首行</li><li>在类的构造器中”this（）”和“super（）”只能二选一，不能同时出现</li><li>在构造器的首行没有显示地声明“this（）”或“super（）”，默认调用父类中无参构造器</li></ul> </li></ol> 
<h3><a id="_50"></a>子类对象实例化的过程</h3> 
<ol><li> <p>结果上看：（继承性）</p> <p>子类继承父类后，自动获得父类定义的属性和方法</p> <p>创建子类对象，在堆空间中就加载类父类定义的属性</p> </li><li> <p>从过程上看：</p> <p>通过子类的构造器创建对象时，一定会直接或间接地调用其父类的构造器，从而调用父类的父类的构造器</p> <p>直到调用java.lang.Object的无参构造器，因为加载过所有父类的结构，所以才可以看到内存中有父类中的结构，子类对象才可以调用</p> <p>==虽然重建子类对象的时候调用过父类的构造器，但自始至终仅创建过一个对象，即为子类对象。</p> </li></ol> 
<h3><a id="_66"></a>多态</h3> 
<p>理解：一个事物的多种形态。以下讲解什么时多态性。</p> 
<h4><a id="_70"></a>对象的多态性</h4> 
<p>可以声明父类对象承载子类对象<mark>父类的引用指向子类的对象</mark></p> 
<pre><code class="prism language-java">Person p <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Man</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> 
<ol><li> <p>通过这种形式调用子父类同名同参的方法时，实际调用的时子类重写的方法——————虚拟方法调用</p> <p><mark>在编译期，只能调用父类声明的方法，在运行的 时候，实际执行的是子类重写的方法</mark></p> </li></ol> 
<blockquote> 
 <p>让秘书去叫一个人，秘书可以叫一个男人或者一个女人。</p> 
</blockquote> 
<ol start="2"><li>但是无法调用子类特有的方法和属性</li><li>多态的使用前提 
  <ul><li>类的继承关系</li><li>方法重写</li></ul> </li></ol> 
<h4><a id="_89"></a>多态不适用于属性</h4> 
<p>###　虚拟方法调用</p> 
<p>在子类中定义于父类同名同参的方法，在多态情况下，将此时父类的方法称为<strong>虚拟方法</strong>，父类根据赋给它　的不同子类对象动态地调用子类的方法。这样的方法调用在编译期间时无法确定的，而是在运行时确定。——<mark>动态绑定</mark></p> 
<p><mark>多态是运行时行为</mark></p> 
<p>证明如下：</p> 
<p>用随机数进行选择子类，然后调用，只有运行时才能确定调用的是哪个子类的方法</p> 
<blockquote> 
 <p>对于重载，他们的调用地址在编译期间就已经绑定了，在调用之前，编译器就知道要调用的方法。这称为“早绑定”或“静态绑定”</p> 
 <p>对于多态，只有等方法调用的那一刻，编译器（？）才确定所要调用的方法。这称为“晚绑定”或“动态绑定”</p> 
 <blockquote> 
  <p>不要犯傻，如果他不是晚绑定，他就不是多态——Bruce Eckel</p> 
 </blockquote> 
</blockquote>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/da16310d27c0cb20b88a94c938e4b8d3/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">@RequestBody的使用</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/d719f5e62bceff68957753f2016a261a/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">【网络爬虫 08】解析链接</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>