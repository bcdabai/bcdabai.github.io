<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Unity开发笔记（五）—— 制作第四个小游戏《坦克大战》 - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Unity开发笔记（五）—— 制作第四个小游戏《坦克大战》" />
<meta property="og:description" content="目录
使用VS传统方法制作
使用Unity制作
使用VS传统方法制作 写在前面的话
C#可以干什么？
桌面应用开发（用的少，现在市面上的桌面应用大部分是C&#43;&#43;开发的）Unity游戏开发Web开发（用的少，现在市面上的网站是Java/PHP开发的） 开发工具：Unity、VS
注意：杀毒软件可能会把开发完成阶段生成的exe文件误当成病毒删除，所以使用时注意关闭
一、准备
进入项目后可以看到Form1.cs的设计模型框 鼠标右键选择查看代码，可查看Form1.cs的具体代码 选择视图-&gt;工具箱，在工具箱中有一些系统自带组件鼠标拖动到Form1.cs进行UI布局的设计
控制窗体显示的位置 居中显示
自定义位置显示 查看窗体事件有哪些
我们找到Paint（这个事件是用于更新画布的），然后在其后面的空格处双击，然后我们就会得到一个Form1_Paint方法
下面我们在此方法中编写代码去画一条线段
注意这里的坐标原点是表头以下部分的左上角 查看本机有哪些字体？新建一个txt文件打开，然后找到字体即可查看
绘制文字 绘制图片，双击打开Resources文件，选择图像，选择添加现有文件，选择导入即可
我们可以在Resources类下发现有自动生成的代码
同理，添加音频
编写代码 绘制图片成功
控制代码收缩，使用region和endregion 也可用Bitmap来获取图片对象且使用它可以对颜色进行透明处理
二、正式开始
1.创建画布窗口
创建窗体应用项目，设置窗口居中显示，设置标题（长宽均为15*30像素，为了对此取奇数）和游戏标题
新建一个线程 新建一个类（项目右键添加-&gt;类）
创建Start和Update方法，Start方法用于游戏启动时的初始化，Update用于游戏每帧画面的更新逻辑操作 为了优化性能，限制1s执行60次update方法
我们在调试时可以发现，当关闭窗口后主线程没有关闭，这是因为子线程没有关闭的情况下子线程是不会关闭的，我们添加一个FormClosed事件（方法见一）
修改Thread作用域，然后在FormClosed方法中调用中断线程的方法
创建画布并赋值 将画布置为黑色 (为什么要把置为黑色代码放到每一帧里面重复执行？我直接执行一次不就好了吗？答案是：因为我们在游戏中还有动态的坦克，如果只执行一次则在创建坦克时会有重复)
2.绘制地图
创建GameObject类
using System; using System.Collections.Generic; using System.Linq; using System.Text; using System.Threading.Tasks; namespace TankWar { class GameObject { public int X { get; set; } public int Y { get; set; } //上述等价于 //public int y; //public int Y { // get { // return y; // } // set { // value = y; // } //} } } 创建NotMovingThing类，继承GameObject，新建Image对象" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/71efe754eb32d10c67ef2602f86ddcd8/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-04-08T15:27:33+08:00" />
<meta property="article:modified_time" content="2022-04-08T15:27:33+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Unity开发笔记（五）—— 制作第四个小游戏《坦克大战》</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p id="main-toc"><strong>目录</strong></p> 
<p id="%E4%BD%BF%E7%94%A8VS%E4%BC%A0%E7%BB%9F%E6%96%B9%E6%B3%95%E5%88%B6%E4%BD%9C-toc" style="margin-left:80px;"><a href="#%E4%BD%BF%E7%94%A8VS%E4%BC%A0%E7%BB%9F%E6%96%B9%E6%B3%95%E5%88%B6%E4%BD%9C" rel="nofollow">使用VS传统方法制作</a></p> 
<p id="%E4%BD%BF%E7%94%A8Unity%E5%88%B6%E4%BD%9C-toc" style="margin-left:80px;"><a href="#%E4%BD%BF%E7%94%A8Unity%E5%88%B6%E4%BD%9C" rel="nofollow">使用Unity制作</a></p> 
<hr id="hr-toc"> 
<h4 id="%E4%BD%BF%E7%94%A8VS%E4%BC%A0%E7%BB%9F%E6%96%B9%E6%B3%95%E5%88%B6%E4%BD%9C">使用VS传统方法制作</h4> 
<p><strong><span style="color:#0d0016;">写在前面的话</span></strong></p> 
<p>C#可以干什么？</p> 
<ul><li>桌面应用开发（用的少，现在市面上的桌面应用大部分是C++开发的）</li><li>Unity游戏开发</li><li>Web开发（用的少，现在市面上的网站是Java/PHP开发的）</li></ul> 
<p>开发工具：Unity、VS</p> 
<p>注意：杀毒软件可能会把开发完成阶段生成的exe文件误当成病毒删除，所以使用时注意关闭</p> 
<p></p> 
<p>一、准备</p> 
<p><img alt="" height="788" src="https://images2.imgbox.com/ed/b2/hEmdXdF9_o.png" width="1191"></p> 
<p><img alt="" height="765" src="https://images2.imgbox.com/ea/a5/1vhg71dF_o.png" width="1189"> 进入项目后可以看到Form1.cs的设计模型框 </p> 
<p><img alt="" height="816" src="https://images2.imgbox.com/f4/9d/Y7svdZ5t_o.png" width="1200"></p> 
<p>鼠标右键选择查看代码，可查看Form1.cs的具体代码 </p> 
<p><img alt="" height="569" src="https://images2.imgbox.com/d2/5b/K7KjiCGH_o.png" width="1200"></p> 
<p>选择视图-&gt;工具箱，在工具箱中有一些系统自带组件鼠标拖动到Form1.cs进行UI布局的设计</p> 
<p><img alt="" height="604" src="https://images2.imgbox.com/1e/6e/xVUbhNYb_o.png" width="412"></p> 
<p><img alt="" height="501" src="https://images2.imgbox.com/04/57/oQFicji8_o.png" width="835"></p> 
<p>控制窗体显示的位置 </p> 
<p>居中显示</p> 
<p><img alt="" height="360" src="https://images2.imgbox.com/0c/73/Q05tasBe_o.png" width="1200"></p> 
<p>自定义位置显示 </p> 
<p><img alt="" height="333" src="https://images2.imgbox.com/05/62/CtjCWhb9_o.png" width="1200"> 查看窗体事件有哪些<img alt="" height="386" src="https://images2.imgbox.com/1f/c2/lqnC7LMk_o.png" width="843"></p> 
<p>我们找到Paint（这个事件是用于更新画布的），然后在其后面的空格处双击，然后我们就会得到一个Form1_Paint方法</p> 
<p> <img alt="" height="465" src="https://images2.imgbox.com/16/09/hRjdDLE6_o.png" width="431"></p> 
<p><img alt="" height="578" src="https://images2.imgbox.com/3a/2b/mRAPtS4V_o.png" width="964"></p> 
<p>下面我们在此方法中编写代码去画一条线段</p> 
<p><img alt="" height="200" src="https://images2.imgbox.com/8d/54/e4S54F6b_o.png" width="804">注意这里的坐标原点是表头以下部分的左上角 </p> 
<p><img alt="" height="492" src="https://images2.imgbox.com/d6/70/WoaZNccW_o.png" width="751"></p> 
<p> 查看本机有哪些字体？新建一个txt文件打开，然后找到字体即可查看</p> 
<p> <img alt="" height="158" src="https://images2.imgbox.com/d2/78/tSzhga5e_o.png" width="339"></p> 
<p><img alt="" height="223" src="https://images2.imgbox.com/b1/b9/LoVNF7M9_o.png" width="526"></p> 
<p>绘制文字 </p> 
<p><img alt="" height="347" src="https://images2.imgbox.com/f6/d3/cWQ1EcYO_o.png" width="1019"></p> 
<p>绘制图片，双击打开Resources文件，选择图像，选择添加现有文件，选择导入即可</p> 
<p><img alt="" height="359" src="https://images2.imgbox.com/55/4a/roPh4rDc_o.png" width="1200"></p> 
<p> <img alt="" height="272" src="https://images2.imgbox.com/88/44/lGVz4eE4_o.png" width="332"></p> 
<p><img alt="" height="270" src="https://images2.imgbox.com/d5/59/2PG09BLB_o.png" width="396"></p> 
<p><img alt="" height="550" src="https://images2.imgbox.com/63/2a/8wc40F5f_o.png" width="786"></p> 
<p><img alt="" height="463" src="https://images2.imgbox.com/0e/f3/wtQHmimv_o.png" width="1125"></p> 
<p>我们可以在Resources类下发现有自动生成的代码</p> 
<p><img alt="" height="335" src="https://images2.imgbox.com/3a/ff/BKxnpyAh_o.png" width="639"></p> 
<p></p> 
<p><img alt="" height="421" src="https://images2.imgbox.com/c3/86/d4xQme4c_o.png" width="1200"></p> 
<p>同理，添加音频</p> 
<p><img alt="" height="265" src="https://images2.imgbox.com/2d/50/PVijTcJQ_o.png" width="1034"></p> 
<p> <img alt="" height="372" src="https://images2.imgbox.com/f7/ea/Own8kPPi_o.png" width="336"></p> 
<p>编写代码 </p> 
<p><img alt="" height="421" src="https://images2.imgbox.com/18/8c/aDAPHsM9_o.png" width="776"></p> 
<p> 绘制图片成功</p> 
<p> <img alt="" height="361" src="https://images2.imgbox.com/ee/0c/xuXaxJm8_o.png" width="346"></p> 
<p>控制代码收缩，使用region和endregion </p> 
<p><img alt="" height="443" src="https://images2.imgbox.com/ed/1c/cOsNzr89_o.png" width="808"></p> 
<p><img alt="" height="300" src="https://images2.imgbox.com/ac/85/WhrCigt7_o.png" width="747"></p> 
<p>也可用Bitmap来获取图片对象且使用它可以对颜色进行透明处理</p> 
<p><img alt="" height="432" src="https://images2.imgbox.com/df/56/F05n20yN_o.png" width="1119"></p> 
<p><img alt="" height="156" src="https://images2.imgbox.com/50/b5/yU1hoeDi_o.png" width="982"></p> 
<p></p> 
<p></p> 
<p></p> 
<p>二、正式开始</p> 
<p>1.创建画布窗口</p> 
<p>创建窗体应用项目，设置窗口居中显示，设置标题（长宽均为15*30像素，为了对此取奇数）和游戏标题</p> 
<p><img alt="" height="521" src="https://images2.imgbox.com/b8/98/Ait0hlpF_o.png" width="1200"></p> 
<p>新建一个线程 </p> 
<p><img alt="" height="416" src="https://images2.imgbox.com/89/3a/PAgYsQCv_o.png" width="938"></p> 
<p>新建一个类（项目右键添加-&gt;类）<img alt="" height="799" src="https://images2.imgbox.com/94/8a/3AefWHSH_o.png" width="1150"></p> 
<p>创建Start和Update方法，Start方法用于游戏启动时的初始化，Update用于游戏每帧画面的更新逻辑操作 </p> 
<p><img alt="" height="369" src="https://images2.imgbox.com/7d/1c/qtdpFCXN_o.png" width="534"></p> 
<p><img alt="" height="441" src="https://images2.imgbox.com/20/cb/zG97zQCC_o.png" width="521"></p> 
<p>为了优化性能，限制1s执行60次update方法</p> 
<p><img alt="" height="255" src="https://images2.imgbox.com/05/b8/HO4GELA2_o.png" width="761"></p> 
<p>我们在调试时可以发现，当关闭窗口后主线程没有关闭，这是因为子线程没有关闭的情况下子线程是不会关闭的，我们添加一个FormClosed事件（方法见一）</p> 
<p><img alt="" height="349" src="https://images2.imgbox.com/c3/44/kmwaJf2E_o.png" width="442"></p> 
<p>修改Thread作用域，然后在FormClosed方法中调用中断线程的方法</p> 
<p><img alt="" height="721" src="https://images2.imgbox.com/a9/37/adIN7huf_o.png" width="906"></p> 
<p>创建画布并赋值 </p> 
<p><img alt="" height="453" src="https://images2.imgbox.com/bc/ed/zd1WfzY1_o.png" width="766"></p> 
<p>将画布置为黑色 (为什么要把置为黑色代码放到每一帧里面重复执行？我直接执行一次不就好了吗？答案是：因为我们在游戏中还有动态的坦克，如果只执行一次则在创建坦克时会有重复)</p> 
<p><img alt="" height="284" src="https://images2.imgbox.com/ea/19/1HWfDsWt_o.png" width="751"><img alt="" height="488" src="https://images2.imgbox.com/3f/e3/iP6fNq1m_o.png" width="422"> </p> 
<p></p> 
<p>2.绘制地图</p> 
<p>创建GameObject类</p> 
<pre><code class="language-cs">using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace TankWar
{
    class GameObject
    {
        public int X { get; set; }
        public int Y { get; set; }

        //上述等价于
        //public int y;
        //public int Y {
        //    get {
        //        return y;
        //    }
        //    set {
        //        value = y;
        //    }
        //}
    }
}
</code></pre> 
<p> 创建NotMovingThing类，继承GameObject，新建Image对象</p> 
<pre><code class="language-cs">using System;
using System.Collections.Generic;
using System.Drawing;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace TankWar
{
    class NotMoveThing:GameObject
    {
        public Image img { get; set; }
    }
}
</code></pre> 
<p> 创建MoveThing类</p> 
<pre><code class="language-cs">using System;
using System.Collections.Generic;
using System.Drawing;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace TankWar
{
    enum Direction{ 
        UP,
        DOWN,
        LEFT,
        RIGHT
    }
    class MoveThing:GameObject
    {
        public Bitmap BitmapUp { get; set; }
        public Bitmap BitmapDown { get; set; }
        public Bitmap BitmapLeft { get; set; }
        public Bitmap BitmapRight { get; set; }
        public int Speed { get; set; }
        public Direction direction { get; set; }
    }
}
</code></pre> 
<p>创建MyTank、EnemyTank、Bullet，分别继承MoveThing</p> 
<pre><code class="language-cs">using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace TankWar
{
    class MyTank:MoveThing
    {
    }
}
</code></pre> 
<pre><code class="language-cs">using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace TankWar
{
    class EnemyTank:MoveThing
    {
    }
}
</code></pre> 
<pre><code class="language-cs">using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace TankWar
{
    class Bullet:MoveThing
    {
    }
}
</code></pre> 
<p>为GameObject添加抽象方法以获取图片对象和在画布上画图片的公共方法 </p> 
<p><img alt="" height="558" src="https://images2.imgbox.com/ad/e0/0G3b0DY4_o.png" width="574"></p> 
<p>子类实现抽象方法，红线部分按下alt+enter选择实现抽象类，就会自动补充好实现方法，然后根据自己的逻辑需要修改即可 </p> 
<p><img alt="" height="367" src="https://images2.imgbox.com/f1/33/tXwKPKPl_o.png" width="876"></p> 
<p><img alt="" height="196" src="https://images2.imgbox.com/5a/0f/9GiCGKC1_o.png" width="292"></p> 
<pre><code class="language-cs">using System;
using System.Collections.Generic;
using System.Drawing;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace TankWar
{
    class NotMoveThing:GameObject
    {
        public Image img { get; set; }

        protected override Image GetImage()
        {
            return img;
        }
    }
}
</code></pre> 
<pre><code class="language-cs">using System;
using System.Collections.Generic;
using System.Drawing;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace TankWar
{
    enum Direction{ 
        UP,
        DOWN,
        LEFT,
        RIGHT
    }
    class MoveThing:GameObject
    {
        public Bitmap BitmapUp { get; set; }
        public Bitmap BitmapDown { get; set; }
        public Bitmap BitmapLeft { get; set; }
        public Bitmap BitmapRight { get; set; }
        public int Speed { get; set; }
        public Direction direction { get; set; }

        protected override Image GetImage()
        {
            switch (direction) {
                case Direction.UP:
                    return BitmapUp;
                case Direction.DOWN:
                    return BitmapDown;
                case Direction.LEFT:
                    return BitmapLeft;
                case Direction.RIGHT:
                    return BitmapRight;
                default:
                    return BitmapUp;
            }
        }
    }
}
</code></pre> 
<p>将黑底图片设为透明</p> 
<p><img alt="" height="606" src="https://images2.imgbox.com/97/0a/TWbvnXXK_o.png" width="654"></p> 
<p></p> 
<p>绘制墙，导入图片和音频资源（同上），创建GameObjectManager</p> 
<pre><code class="language-cs">using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using TankWar.Properties;

namespace TankWar
{
    class GamebjectManager
    {
        private static List&lt;NotMoveThing&gt; wallList = new List&lt;NotMoveThing&gt;();//保存所有墙对象

        public static void DrawMap() {
            foreach (NotMoveThing  wall in wallList) {
                wall.DrawSelf();//绘制墙
            }
        }
        public static void CreateMap() {
            CreateWall(1, 1, 5,wallList);//创建墙对象
        }

        /**
         * x,y代表一个30*30的方格的位置，如第一格是0，0，我们在绘画时从1，1位置开始画
         * count代表要创建的强对象个数
         */
        private static void CreateWall(int x,int y,int count,List&lt;NotMoveThing&gt; wallList) {
            int xPosition = x * 30;
            int yPosition = y * 30;
            for (int i=yPosition;i&lt;yPosition+count*30; i+=15) {
                NotMoveThing wall1 = new NotMoveThing(xPosition,i,Resources.wall);
                NotMoveThing wall2 = new NotMoveThing(xPosition+15, i, Resources.wall);
                wallList.Add(wall1);
                wallList.Add(wall2);
            }
        }
    }
}
</code></pre> 
<p>新增NotMoveThing构造f方法</p> 
<pre><code class="language-cs">​
新增NotMoveThing构造方法

using System;
using System.Collections.Generic;
using System.Drawing;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace TankWar
{
    class NotMoveThing:GameObject
    {
        public Image img { get; set; }

        protected override Image GetImage()
        {
            return img;
        }

        public NotMoveThing(int x,int y,Image img) {
            this.X = x;
            this.Y = y;
            this.img = img;
        }
    }
}</code></pre> 
<p>在GameFrameWork中调用</p> 
<pre><code class="language-cs">using System;
using System.Collections.Generic;
using System.Drawing;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace TankWar
{
    class GameFramework
    {
        public static Graphics g;
        public static void Start() {
            GamebjectManager.CreateMap();
        }

        public static void Update() {
            GamebjectManager.DrawMap();
        }
    }
}
</code></pre> 
<p>效果如下，但是会出现闪烁问题（这是因为每一帧都需要重新绘制） </p> 
<p><img alt="" height="338" src="https://images2.imgbox.com/36/84/HgLF2Hbb_o.png" width="318"><img alt="" height="338" src="https://images2.imgbox.com/37/08/QlBZ6UVg_o.png" width="320"></p> 
<p> 为了解决闪烁问题，我们可以采用把所有的图像绘制在一张图片上，然后再把图片绘制到画布上</p> 
<pre><code class="language-cs">using System;
using System.Collections.Generic;
using System.ComponentModel;
using System.Data;
using System.Drawing;
using System.Linq;
using System.Text;
using System.Threading;
using System.Threading.Tasks;
using System.Windows.Forms;

namespace TankWar
{
    public partial class Form1 : Form
    {
        private Thread thread;
        private static Graphics windowG;//窗口画布对象
        private static Bitmap tempBmp;//临时图片对象

        public Form1()
        {
            InitializeComponent();
            this.StartPosition = FormStartPosition.CenterScreen;//使窗口在屏幕居中显示

            windowG = this.CreateGraphics();//创建窗体画布

            tempBmp = new Bitmap(450,450);//创建临时图片
            Graphics bmpG = Graphics.FromImage(tempBmp);//根据图片对象创建临时画布对象
            GameFramework.g = bmpG;//赋值，以便在GameFramework中拿到此对象


            thread = new Thread(new ThreadStart(GameMainThread));
            thread.Start();
        }

        private static void GameMainThread() {
            GameFramework.Start();
            int sleepTime = 1000 / 60; //值为：1/60s
            while (true)
            {
                GameFramework.g.Clear(Color.Black);//将画布内容清空，并置为黑色
                GameFramework.Update();//画画
                windowG.DrawImage(tempBmp, 0, 0);
                Thread.Sleep(sleepTime);//每执行一次休息一段时间，保证1s执行60次
            }
        }

        private void Form1_FormClosed(object sender, FormClosedEventArgs e)
        {
            thread.Abort();
        }
    }
}
</code></pre> 
<p>这样图像就不再闪动了 </p> 
<p><img alt="" height="319" src="https://images2.imgbox.com/73/7e/XVJe2plT_o.png" width="302"></p> 
<p>继续创建其他墙，并添加图片参数</p> 
<p><img alt="" height="339" src="https://images2.imgbox.com/67/8e/3lm2wd8K_o.png" width="808"></p> 
<p><img alt="" height="383" src="https://images2.imgbox.com/1a/d5/5j22Cb3g_o.png" width="1046"></p> 
<p>继续添加墙和boss，最终代码和最终效果</p> 
<pre><code class="language-cs">using System;
using System.Collections.Generic;
using System.Drawing;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using TankWar.Properties;

namespace TankWar
{
    class GamebjectManager
    {
        private static List&lt;NotMoveThing&gt; wallList = new List&lt;NotMoveThing&gt;();//保存所有普通墙对象
        private static List&lt;NotMoveThing&gt; steelList = new List&lt;NotMoveThing&gt;();//保存所有钢铁墙对象
        private static NotMoveThing boss;//保存boss对象
        public static void DrawMap() {
            foreach (NotMoveThing  wall in wallList) {
                wall.DrawSelf();//绘制墙
            }
            foreach (NotMoveThing wall in steelList) {
                wall.DrawSelf();//绘制墙
            }
            boss.DrawSelf();
        }
        public static void CreateMap() {
            CreateWall(1, 1, 5,Resources.wall,wallList);//创建墙对象
            CreateWall(3, 1, 5, Resources.wall, wallList);//创建墙对象
            CreateWall(5, 1, 4, Resources.wall, wallList);//创建墙对象
            CreateWall(7, 1, 3, Resources.wall, wallList);//创建墙对象
            CreateWall(9, 1, 4, Resources.wall, wallList);//创建墙对象
            CreateWall(11, 1, 5, Resources.wall, wallList);//创建墙对象
            CreateWall(13, 1, 5, Resources.wall, wallList);//创建墙对象

            CreateWall(7, 5, 1, Resources.steel, steelList);//创建钢铁墙对象
            CreateWall(0, 7, 1, Resources.steel, steelList);//创建钢铁墙对象
            CreateWall(14, 7, 1, Resources.steel, steelList);//创建钢铁墙对象

            CreateWall(2, 7, 1, Resources.wall, wallList);
            CreateWall(3, 7, 1, Resources.wall, wallList);
            CreateWall(4, 7, 1, Resources.wall, wallList);
            CreateWall(6, 7, 1, Resources.wall, wallList);
            CreateWall(7, 6, 2, Resources.wall, wallList);
            CreateWall(8, 7, 1, Resources.wall, wallList);
            CreateWall(10, 7, 1, Resources.wall, wallList);
            CreateWall(11, 7, 1, Resources.wall, wallList);
            CreateWall(12, 7, 1, Resources.wall, wallList);

            CreateWall(1, 9, 5, Resources.wall, wallList);//创建墙对象
            CreateWall(3, 9, 5, Resources.wall, wallList);//创建墙对象
            CreateWall(5, 9, 3, Resources.wall, wallList);//创建墙对象
            CreateWall(6, 10, 1, Resources.wall, wallList);//创建墙对象
            CreateWall(7, 10, 1, Resources.wall, wallList);//创建墙对象
            CreateWall(8, 10, 1, Resources.wall, wallList);//创建墙对象
            CreateWall(9, 9, 3, Resources.wall, wallList);//创建墙对象

            CreateWall(11, 9, 5, Resources.wall, wallList);//创建墙对象
            CreateWall(13, 9, 5, Resources.wall, wallList);//创建墙对象

            CreateWall(6, 13, 2, Resources.wall, wallList);//创建墙对象
            CreateWall(7, 13, 1, Resources.wall, wallList);//创建墙对象
            CreateWall(8, 13, 2, Resources.wall, wallList);//创建墙对象

            CreateBoss(7, 14,Resources.Boss);
        }

        /**
         * x,y代表一个30*30的方格的位置，如第一格是0，0，我们在绘画时从1，1位置开始画
         * count代表要创建的强对象个数
         */
        private static void CreateWall(int x,int y,int count,Image img,List&lt;NotMoveThing&gt; wallList) {
            int xPosition = x * 30;
            int yPosition = y * 30;
            for (int i=yPosition;i&lt;yPosition+count*30; i+=15) {//例如从30到180(150+30),需执行10次
                NotMoveThing wall1 = new NotMoveThing(xPosition,i,img);
                NotMoveThing wall2 = new NotMoveThing(xPosition+15, i, img);
                wallList.Add(wall1);
                wallList.Add(wall2);
            }
        }

        private static void CreateBoss(int x,int y,Image img) {
            int xPosition = x * 30;
            int yPosition = y * 30;
            boss = new NotMoveThing(xPosition, yPosition,img);
        }
    }
}
</code></pre> 
<p><img alt="" height="310" src="https://images2.imgbox.com/54/3d/d6AuZgrX_o.png" width="287"></p> 
<p>修改窗体属性，使其不能用鼠标拖动改变窗体大小，但可以最大化和最小化</p> 
<p><img alt="" height="531" src="https://images2.imgbox.com/2f/f8/QnzJsDIY_o.png" width="721"></p> 
<p></p> 
<p>3.绘制主角（即自己的坦克）</p> 
<p>GameObjectManager类新增如下两个方法，并在GameFramework中添加调用</p> 
<p><img alt="" height="503" src="https://images2.imgbox.com/d6/c1/A3dQP7pl_o.png" width="615"></p> 
<p><img alt="" height="358" src="https://images2.imgbox.com/85/b2/5dLflQSW_o.png" width="548"></p> 
<p> 添加对应的构造方法</p> 
<p><img alt="" height="575" src="https://images2.imgbox.com/42/d5/NcfAOzzi_o.png" width="653"></p> 
<p>最终效果图：</p> 
<p><img alt="" height="595" src="https://images2.imgbox.com/c2/8a/ETy9tXSH_o.png" width="561"></p> 
<p></p> 
<p>4.控制坦克的移动</p> 
<p>添加键盘监听事件函数(同上，再Form的属性-&gt;事件下找到KeyDown和KeyUp)</p> 
<p><img alt="" height="472" src="https://images2.imgbox.com/f9/3f/sSXHzQOU_o.png" width="789"></p> 
<p>调用鼠标按下和起来的方法</p> 
<p><img alt="" height="310" src="https://images2.imgbox.com/14/63/AcMeleV9_o.png" width="659"></p> 
<p><img alt="" height="252" src="https://images2.imgbox.com/5b/df/6AsLjDam_o.png" width="565"></p> 
<p><img alt="" height="455" src="https://images2.imgbox.com/d8/86/D4LLdAnX_o.png" width="540"></p> 
<p>这样控制坦克移动随可以，但会有一个一开始的卡顿（按下后移动一下然后停顿一s再往前走）</p> 
<p><img alt="" height="221" src="https://images2.imgbox.com/32/5b/peUtmpRM_o.png" width="506"></p> 
<p>因此我们这样做，定义一个isMoving变量，当键盘按下后设置为true，当键盘起来时设置为false。然后根据isMoving来控制移动</p> 
<pre><code class="language-cs">using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using System.Windows.Forms;
using TankWar.Properties;

namespace TankWar
{
    class MyTank:MoveThing
    {
        public bool IsMoving { get; set; }
        public MyTank(int x,int y,int speed) {
            this.IsMoving = false;
            this.X = x;
            this.Y = y;
            this.Speed = speed;
            this.direction = Direction.UP;
            BitmapDown = Resources.MyTankDown;
            BitmapUp = Resources.MyTankUp;
            BitmapRight = Resources.MyTankRight;
            BitmapLeft = Resources.MyTankLeft;
        }

        public void KeyDown(KeyEventArgs args) {
            switch (args.KeyCode) {
                case Keys.W:
                    direction = Direction.UP;
                    IsMoving = true;
                    break;
                case Keys.S:
                    direction = Direction.DOWN;
                    IsMoving = true;
                    break;
                case Keys.A:
                    direction = Direction.LEFT;
                    IsMoving = true;
                    break;
                case Keys.D:
                    direction = Direction.RIGHT;
                    IsMoving = true;
                    break;
            }
        }

        public void KeyUp(KeyEventArgs args) {
            switch (args.KeyCode)
            {
                case Keys.W:
                    IsMoving = false;
                    break;
                case Keys.S:
                    IsMoving = false;
                    break;
                case Keys.A:
                    IsMoving = false;
                    break;
                case Keys.D:
                    IsMoving = false;
                    break;
            }
        }

        private void Move() {
            if (IsMoving==false) {
                return;
            }
            switch (direction) {
                case Direction.UP:
                    Y -= Speed;
                    break;
                case Direction.DOWN:
                    Y += Speed;
                    break;
                case Direction.LEFT:
                    X -= Speed;
                    break;
                case Direction.RIGHT:
                    X += Speed;
                    break;
            }
        } 

        public override void Update()
        {
            Move();
            base.Update();
        }
    }
}
</code></pre> 
<p><img alt="" height="453" src="https://images2.imgbox.com/70/57/aXE08dE4_o.png" width="508"></p> 
<p><img alt="" height="587" src="https://images2.imgbox.com/7e/99/mXasjjK6_o.png" width="750"></p> 
<p><img alt="" height="570" src="https://images2.imgbox.com/f4/05/lFh0JtJF_o.png" width="508"></p> 
<p>现在我们的坦克可以移动了，但是会穿过墙体和外边界 </p> 
<p><img alt="" height="417" src="https://images2.imgbox.com/31/fa/Z1nf5jZt_o.png" width="484"></p> 
<p>添加墙体检测，在MoveCheck方法添加墙体检测</p> 
<p><img alt="" height="853" src="https://images2.imgbox.com/c5/cc/bLdTB0ZQ_o.png" width="763"></p> 
<p><img alt="" height="818" src="https://images2.imgbox.com/80/15/NNMScrdS_o.png" width="997"></p> 
<p><img alt="" height="869" src="https://images2.imgbox.com/fd/0f/HEhqNGCE_o.png" width="735"></p> 
<p> 处理资源冲突异常：</p> 
<p><img alt="" height="248" src="https://images2.imgbox.com/40/f3/fPpU4T1O_o.png" width="885"></p> 
<p><img alt="" height="350" src="https://images2.imgbox.com/b7/14/r9cqLHsk_o.png" width="752"></p> 
<p><img alt="" height="495" src="https://images2.imgbox.com/c0/73/jdFJKR71_o.png" width="1032"></p> 
<p><img alt="" height="619" src="https://images2.imgbox.com/56/55/ABYwox8H_o.png" width="585"></p> 
<p>在MoveThing中重写此方法 </p> 
<p><img alt="" height="208" src="https://images2.imgbox.com/c1/7b/vegeCuaV_o.png" width="376"></p> 
<p><img alt="" height="522" src="https://images2.imgbox.com/b6/db/9wF4cbZ7_o.png" width="492"></p> 
<p></p> 
<p>5.添加敌人坦克</p> 
<p>添加EnemyTank生成方法</p> 
<pre><code class="language-cs">using System;
using System.Collections.Generic;
using System.Drawing;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using System.Windows.Forms;
using TankWar.Properties;

namespace TankWar
{
    class GamebjectManager
    {
        ...
        private static List&lt;EnemyTank&gt; tankList = new List&lt;EnemyTank&gt;();//保存敌人坦克对象
        private static int enemyBornSpeed = 60;//敌人坦克的生成速度
        private static int enemyBornCount = 60;//敌人坦克的生成数量
        private static Point[] points=new Point[3];

        public static void Start() {
            points[0].X = 0;
            points[0].Y = 0;
            points[1].X = 7*30;
            points[1].Y = 0;
            points[2].X = 14*30;
            points[2].Y = 0;
        }

        public static void Update() {
            ...
            foreach (EnemyTank tank in tankList) {
                tank.Update();
            }
            ...
            EnemyBorn();
        }

        public static void EnemyBorn() {
            enemyBornCount++;
            if (enemyBornCount&lt;enemyBornSpeed) {
                return;
            }
            Random rd = new Random();
            int index=rd.Next(0, 3);//生成0-3之间的随机整数，不包含3
            Point positon = points[index];
            int enemyType = rd.Next(1, 5);
            switch (enemyType) {
                case 1:
                    CreateEnemyTank1(positon.X,positon.Y);
                    break;
                case 2:
                    CreateEnemyTank2(positon.X, positon.Y);
                    break;
                case 3:
                    CreateEnemyTank3(positon.X, positon.Y);
                    break;
                case 4:
                    CreateEnemyTank4(positon.X, positon.Y);
                    break;
            }
            enemyBornCount = 0;
        }

        private static void CreateEnemyTank1(int x,int y) {
            EnemyTank tank = new EnemyTank(x, y, 2, Resources.GrayDown, Resources.GrayUp, Resources.GrayLeft, Resources.GrayRight);
            tankList.Add(tank);
        }
        private static void CreateEnemyTank2(int x, int y)
        {
            EnemyTank tank = new EnemyTank(x, y, 2, Resources.GreenDown, Resources.GreenUp, Resources.GreenLeft, Resources.GreenRight);
            tankList.Add(tank);
        }
        private static void CreateEnemyTank3(int x, int y)
        {
            EnemyTank tank = new EnemyTank(x, y, 4, Resources.QuickDown, Resources.QuickUp, Resources.QuickLeft, Resources.QuickRight);
            tankList.Add(tank);
        }
        private static void CreateEnemyTank4(int x, int y)
        {
            EnemyTank tank = new EnemyTank(x, y, 1, Resources.SlowDown, Resources.SlowUp, Resources.SlowLeft, Resources.SlowRight);
            tankList.Add(tank);
        }
    }
}
</code></pre> 
<p>创建EnemyTank构造函数及移动</p> 
<pre><code class="language-cs">using System;
using System.Collections.Generic;
using System.Drawing;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace TankWar
{
    class EnemyTank:MoveThing
    {
        private Random r = new Random();
        public EnemyTank(int x, int y, int speed,Bitmap bmpDown,Bitmap bmpUp,Bitmap bmpLeft,Bitmap bmpRight)
        {
            //this.IsMoving = true;
            this.X = x;
            this.Y = y;
            this.Speed = speed;
            BitmapDown = bmpDown;
            BitmapUp = bmpUp;
            BitmapRight = bmpRight;
            BitmapLeft = bmpLeft;
            this.Direction = Direction.DOWN;
        }

        public override void Update()
        {
            MoveCheck();//移动前检查
            Move();
            base.Update();
        }

        private void ChangeDirection() {
            while (true) {
                Direction dir = (Direction)r.Next(0, 4);
                if (Direction == dir)
                {
                    continue;
                } else {
                    Direction = dir;
                    break;
                }
            }
            MoveCheck();
        }

        private void Move()
        {
            switch (Direction)
            {
                case Direction.UP:
                    Y -= Speed;
                    break;
                case Direction.DOWN:
                    Y += Speed;
                    break;
                case Direction.LEFT:
                    X -= Speed;
                    break;
                case Direction.RIGHT:
                    X += Speed;
                    break;
            }
        }

        private void MoveCheck()
        {
            #region 检查是否超过窗体边界
            if (Direction == Direction.UP)
            {
                if (Y - Speed &lt; 0)
                {
                    ChangeDirection();
                    return;
                }
            }
            else if (Direction == Direction.DOWN)
            {
                if (Y + Speed + Height &gt; 450)
                {
                    ChangeDirection();
                    return;
                }
            }
            else if (Direction == Direction.LEFT)
            {
                if (X - Speed &lt; 0)
                {
                    ChangeDirection();
                    return;
                }
            }
            else if (Direction == Direction.RIGHT)
            {
                if (X + Speed + Width &gt; 450)
                {
                    ChangeDirection();
                    return;
                }
            }
            #endregion

            Rectangle rect = GetRectangle();
            switch (Direction)
            {
                case Direction.UP:
                    rect.Y -= Speed;
                    break;
                case Direction.DOWN:
                    rect.Y += Speed;
                    break;
                case Direction.LEFT:
                    rect.X -= Speed;
                    break;
                case Direction.RIGHT:
                    rect.X += Speed;
                    break;
            }
            if (GamebjectManager.isCollidedWall(rect) != null)
            {
                ChangeDirection();
                return;
            }
            if (GamebjectManager.isCollidedSteel(rect) != null)
            {
                ChangeDirection();
                return;
            }
            if (GamebjectManager.isCollidedBoss(rect))
            {
                ChangeDirection();
                return;
            }
        }
    }
}
</code></pre> 
<p><img alt="" height="617" src="https://images2.imgbox.com/fd/0e/0jdMwrMv_o.png" width="571"></p> 
<p></p> 
<p>6.发射子弹</p> 
<p>在MyTank中添加空格监听，当按下空格后发射子弹</p> 
<p><img alt="" height="626" src="https://images2.imgbox.com/d4/c8/7AybvCse_o.png" width="476"></p> 
<p><img alt="" height="584" src="https://images2.imgbox.com/aa/b9/x7FT3buw_o.png" width="795"></p> 
<p><img alt="" height="649" src="https://images2.imgbox.com/da/c8/YhIk7Tsy_o.png" width="903"></p> 
<pre><code class="language-cs">using System;
using System.Collections.Generic;
using System.Drawing;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using TankWar.Properties;

namespace TankWar
{
    enum Tag { 
        MyTank,
        EnemyTank
    }
    class Bullet:MoveThing
    {
        public Tag Tag { get; set; } //用于判断是自己的坦克发射的子弹还是敌人的坦克发射的子弹
        public bool isDestroy { get; set; }
        public Bullet(int x, int y, int speed,Direction dir,Tag tag)
        {
            isDestroy = false;
            this.X = x;
            this.Y = y;
            this.Speed = speed;
            BitmapDown = Resources.BulletDown;
            BitmapUp = Resources.BulletUp;
            BitmapRight = Resources.BulletRight;
            BitmapLeft = Resources.BulletLeft;
            this.Direction = dir;
            this.Tag = tag;
            this.X -= Width / 2;
            this.Y -= Height / 2;
        }

        public override void DrawSelf()
        {
            base.DrawSelf();
        }

        public override void Update()
        {
            MoveCheck();//移动前检查
            Move();
            base.Update();
        }

        private void Move()
        {
            switch (Direction)
            {
                case Direction.UP:
                    Y -= Speed;
                    break;
                case Direction.DOWN:
                    Y += Speed;
                    break;
                case Direction.LEFT:
                    X -= Speed;
                    break;
                case Direction.RIGHT:
                    X += Speed;
                    break;
            }
        }

        private void MoveCheck()
        {
            #region 检查是否超过窗体边界
            if (Direction == Direction.UP)
            {
                if (Y +Height/2+3&lt; 0)//子弹图片自身的高度/2和子弹本身的高度的一半(大约为3)
                {
                    isDestroy=true;
                    return;
                }
            }
            else if (Direction == Direction.DOWN)
            {
                if (Y + Height/2 -3 &gt; 450)
                {
                    isDestroy = true;
                    return;
                }
            }
            else if (Direction == Direction.LEFT)
            {
                if (X+Width/2-3 &lt; 0)
                {
                    isDestroy = true;
                    return;
                }
            }
            else if (Direction == Direction.RIGHT)
            {
                if (X+Width/2+3 &gt; 450)
                {
                    isDestroy = true;
                    return;
                }
            }
            #endregion

            ...
        }
    }
}
</code></pre> 
<p>当子弹超出边界时，判断isDestroy并销毁</p> 
<p><img alt="" height="720" src="https://images2.imgbox.com/b4/f4/7V0i6GUH_o.png" width="736"></p> 
<p><img alt="" height="328" src="https://images2.imgbox.com/00/42/tRPlglW1_o.png" width="653"></p> 
<p>当子弹遇到墙或者敌人后销毁它们</p> 
<pre><code class="language-cs">using System;
using System.Collections.Generic;
using System.Drawing;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using TankWar.Properties;

namespace TankWar
{
    enum Tag { 
        MyTank,
        EnemyTank
    }
    class Bullet:MoveThing
    {
        ...

        private void MoveCheck()
        {
            ...
            
            Rectangle rect = GetRectangle();
            rect.X = X + Width / 2 - 3;//取到子弹实际位置的左上角横坐标
            rect.Y = Y + Height / 2 - 3;
            rect.Height = 3;
            rect.Width = 3;
            NotMoveThing wall = null;
            if ((wall=GamebjectManager.isCollidedWall(rect)) != null)
            {
                isDestroy = true;
                GamebjectManager.DestoryWall(wall);
                return;
            }
            if (GamebjectManager.isCollidedSteel(rect) != null)
            {
                isDestroy = true;
                return;
            }
            if (GamebjectManager.isCollidedBoss(rect))
            {
                //ChangeDirection();
                return;
            }
            if (Tag==Tag.MyTank) {
                EnemyTank tank = null;
                if ((tank = GamebjectManager.isCollidedEnemyTank(rect))!=null)
                {
                    isDestroy = true;
                    GamebjectManager.DestoryTank(tank);
                    return;
                }
            }
            
        }
    }
}
</code></pre> 
<p><img alt="" height="557" src="https://images2.imgbox.com/33/fb/YaeZBSpH_o.png" width="846"></p> 
<p><img alt="" height="657" src="https://images2.imgbox.com/7b/68/EQM5lUJS_o.png" width="869"></p> 
<p>效果 </p> 
<p><img alt="" height="598" src="https://images2.imgbox.com/a0/da/MtI1Omve_o.png" width="561"></p> 
<p></p> 
<p></p> 
<p>7.添加爆炸效果</p> 
<p>创建爆炸效果类</p> 
<pre><code class="language-cs">using System;
using System.Collections.Generic;
using System.Drawing;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using TankWar.Properties;

namespace TankWar
{
    class Explosion : GameObject
    {
        public bool IsNeedDestory { get; set;}
        private int playSpeed = 1;
        private int playCount = 0;//0/2=0 1/2=0 2/2=1 3/2=1..每张图片停留2帧 
        private int index = 0;
        private Bitmap[] bmpArray = new Bitmap[] {
            Resources.EXP1,
            Resources.EXP2,
            Resources.EXP3,
            Resources.EXP4,
            Resources.EXP5
        };
        public Explosion(int x,int y) {
            foreach (Bitmap bmp in bmpArray) {
                bmp.MakeTransparent(Color.Black);
            }
            this.X = x - bmpArray[0].Width / 2;//得到左上角坐标
            this.Y = y - bmpArray[0].Height / 2;
            IsNeedDestory = false;
        }

        protected override Image GetImage()
        {
            if (index&gt;4) {
                return bmpArray[4];
            }
            return bmpArray[index];
        }

        public override void Update()
        {
            playCount++;
            index = (playCount - 1) / playSpeed;//获取播放图片的索引
            if (index&gt;4) {
                IsNeedDestory = true;
            }
            base.Update();
        }
    }
}
</code></pre> 
<p>添加生成爆炸效果的代码 </p> 
<p><img alt="" height="674" src="https://images2.imgbox.com/05/19/MgrSLvOI_o.png" width="570"></p> 
<p><img alt="" height="555" src="https://images2.imgbox.com/3f/6a/yKMMcJvA_o.png" width="790"></p> 
<p><img alt="" height="788" src="https://images2.imgbox.com/23/1a/b69bi3AV_o.png" width="886"></p> 
<p>8.优化敌人坦克</p> 
<p>敌人坦克可发射子弹 </p> 
<pre><code class="language-cs">using System;
using System.Collections.Generic;
using System.Drawing;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace TankWar
{
    class EnemyTank:MoveThing
    {
        public int AttackSpeed { get; set; }
        private int attackCount = 0;
        ...
        public EnemyTank(int x, int y, int speed,Bitmap bmpDown,Bitmap bmpUp,Bitmap bmpLeft,Bitmap bmpRight)
        {
            ...
            AttackSpeed = 60;
        }

        public override void Update()
        {
            ...
            AttackCheck();//是否需要攻击
            ...
        }

        ...
        private void AttackCheck() {
            attackCount++;
            if (attackCount &lt; AttackSpeed) return;
            Attack();
            attackCount = 0;
        }
        private void Attack()
        {
            int x = this.X;
            int y = this.Y;
            switch (Direction)
            {
                case Direction.UP:
                    x = x + Width / 2;
                    break;
                case Direction.DOWN:
                    x = x + Width / 2;
                    y += Height;
                    break;
                case Direction.LEFT:
                    y = y + Height / 2;
                    break;
                case Direction.RIGHT:
                    x += Width;
                    y = y + Height / 2;
                    break;
            }
            GamebjectManager.CreateBullet(x, y, Tag.EnemyTank, Direction);
        }
    }
}
</code></pre> 
<p> 敌人可随机转向，而不是遇到障碍我才转向</p> 
<p><img alt="" height="489" src="https://images2.imgbox.com/1f/b3/YgCZQD0x_o.png" width="614"></p> 
<p> <img alt="" height="385" src="https://images2.imgbox.com/98/dd/TvDgR8G8_o.png" width="548"></p> 
<p> <img alt="" height="457" src="https://images2.imgbox.com/9e/d2/BGLDDyad_o.png" width="569"></p> 
<p> 子弹可以攻击主角坦克，主角坦克可以被攻击4次，第4次主角坦克消失并回归起点</p> 
<p><img alt="" height="629" src="https://images2.imgbox.com/a6/eb/RkQcT5my_o.png" width="838"></p> 
<pre><code class="language-cs">using System;
using System.Collections.Generic;
using System.Drawing;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using System.Windows.Forms;
using TankWar.Properties;

namespace TankWar
{
    class MyTank:MoveThing
    {
        public int HP { get; set; }//血量
        ...
        private int originalX, originalY;
        public MyTank(int x,int y,int speed) {
            ...
            originalX = x;
            originalY = y;
            ...
            HP = 4;
        }

        ...

        public void TakeDamage() {
            HP--;
            if (HP&lt;=0) {
                X = originalX;
                Y = originalY;
                HP = 4;
            }
        }
    }
}
</code></pre> 
<p><img alt="" height="505" src="https://images2.imgbox.com/05/fa/DlkPdmrg_o.png" width="718"></p> 
<p> 子弹攻击boss时游戏结束</p> 
<p><img alt="" height="553" src="https://images2.imgbox.com/f4/c8/3zc9G1uZ_o.png" width="725"></p> 
<p><img alt="" height="751" src="https://images2.imgbox.com/42/e0/YAVV6ztU_o.png" width="1151"></p> 
<p>9.添加音效</p> 
<pre><code class="language-cs">using System;
using System.Collections.Generic;
using System.Linq;
using System.Media;
using System.Text;
using System.Threading;
using System.Threading.Tasks;
using TankWar.Properties;

namespace TankWar
{
    class SoundManager
    {

        private static SoundPlayer startPlayer = new SoundPlayer();
        private static SoundPlayer addPlayer = new SoundPlayer();
        private static SoundPlayer blastPlayer = new SoundPlayer();
        private static SoundPlayer firePlayer = new SoundPlayer();
        private static SoundPlayer hitPlayer = new SoundPlayer();

        public static void InitSound() {
            startPlayer.Stream = Resources.start;
            addPlayer.Stream = Resources.add;
            blastPlayer.Stream = Resources.blast;
            firePlayer.Stream = Resources.fire;
            hitPlayer.Stream = Resources.hit;
        }
        public static void PlayStart() {
            startPlayer.Play();
        }
        public static void PlayAdd()
        {
            addPlayer.Play();
        }
        public static void PlayBlast() {
            blastPlayer.Play();
        }
        public static void PlayFire()
        {
            firePlayer.Play();
        }
        public static void PlayHit()
        {
            hitPlayer.Play();
        }

    }
}
</code></pre> 
<p><img alt="" height="358" src="https://images2.imgbox.com/23/0b/2O2rm70J_o.png" width="718"></p> 
<p><img alt="" height="797" src="https://images2.imgbox.com/61/57/cr5QI03T_o.png" width="666"></p> 
<p><img alt="" height="540" src="https://images2.imgbox.com/c4/3c/3TCRnD0b_o.png" width="765"></p> 
<p><img alt="" height="610" src="https://images2.imgbox.com/86/bd/mI5hfQDe_o.png" width="592"></p> 
<p><img alt="" height="606" src="https://images2.imgbox.com/ce/92/b9roqug6_o.png" width="565"></p> 
<p><img alt="" height="600" src="https://images2.imgbox.com/50/55/OsEimnPc_o.png" width="563"></p> 
<p></p> 
<h4 id="%E4%BD%BF%E7%94%A8Unity%E5%88%B6%E4%BD%9C">使用Unity制作</h4> 
<p>1.创建工程</p> 
<p><img alt="" height="629" src="https://images2.imgbox.com/87/ef/0kgeOvCJ_o.png" width="1106"></p> 
<p>修改布局模式为2 by 3</p> 
<p><img alt="" height="183" src="https://images2.imgbox.com/d8/b6/RmeMSQA4_o.png" width="449"></p> 
<p>Project面板切换单行模式 </p> 
<p><img alt="" height="311" src="https://images2.imgbox.com/16/22/yvanp2Mn_o.png" width="519"></p> 
<p>导入资源（将unitypackage文件拖到Project面板，在弹出的弹窗点击Import即可）</p> 
<p><img alt="" height="719" src="https://images2.imgbox.com/73/01/GNy9M5RV_o.png" width="431"></p> 
<p>确保单张图片的SpriteMode选择为Single，多张小图片组成的图片选择为Multiple，TextureType选择为Sprite2D </p> 
<p><img alt="" height="819" src="https://images2.imgbox.com/7c/a0/iZc3IOZY_o.png" width="763"></p> 
<p><img alt="" height="732" src="https://images2.imgbox.com/b6/02/MBRYz0I4_o.png" width="728"></p> 
<p>切割图片（点击Sprite Editor-&gt;Slice-&gt;Gride By Cell Size，输入最小图片大小点击Slice即可，之后就可以展开看到切割后图片）</p> 
<p><img alt="" height="824" src="https://images2.imgbox.com/0b/c8/3uHBrEV7_o.png" width="1200"></p> 
<p><img alt="" height="596" src="https://images2.imgbox.com/5b/99/DnNFxKda_o.png" width="711"></p> 
<p>创建Player（将Player1拖到Hierarchy面板即可），创建其对应预制体，同理可创建Wall、Barrier、Grass、Heart</p> 
<p><img alt="" height="401" src="https://images2.imgbox.com/3c/90/o1xtcBJS_o.png" width="564"></p> 
<p>创建动画效果（出生动画、爆炸动画、护盾动画、河流动画），选择动画然后拖到Hierarchy面板，然后命名即可，然后创建其对于预制体，然后会自动产生俩个文件，将其放到新建文件夹Animator和AnimatorController中（适当改名以清晰结构）</p> 
<p><img alt="" height="352" src="https://images2.imgbox.com/dc/c1/xTOldrVA_o.png" width="588"></p> 
<p><img alt="" height="582" src="https://images2.imgbox.com/eb/34/QMQQW2vX_o.png" width="930"></p> 
<p><img alt="" height="445" src="https://images2.imgbox.com/71/c4/p1NgEVFd_o.png" width="552"></p> 
<p><img alt="" height="259" src="https://images2.imgbox.com/bf/49/R1pjL10Q_o.png" width="545"></p> 
<p></p> 
<p>2.控制Player移动</p> 
<p>新建脚本Player放在新建文件夹Scripts下，与Player对象关联，然后编辑内容</p> 
<p><img alt="" height="673" src="https://images2.imgbox.com/d4/f6/BD4biHi0_o.png" width="1068"></p> 
<pre><code class="language-cs">using System.Collections;
using System.Collections.Generic;
using UnityEngine;

public class Player : MonoBehaviour
{
    public float moveSpeed=3;
    // Start is called before the first frame update
    void Start()
    {
        
    }

    // Update is called once per frame
    void Update()
    {
        float h = Input.GetAxisRaw("Horizontal");
        transform.Translate(Vector3.right * h * moveSpeed * Time.deltaTime,Space.World);//乘以delTatime表示按每一秒移动,以世界坐标轴移动
        float v = Input.GetAxisRaw("Vertical");
        transform.Translate(Vector3.up * v * moveSpeed * Time.deltaTime, Space.World);
    }
}
</code></pre> 
<p>新建一个数组，用以存放4个方向的图片</p> 
<p><img alt="" height="230" src="https://images2.imgbox.com/10/6b/RbWLlTsC_o.png" width="487"></p> 
<p><img alt="" height="674" src="https://images2.imgbox.com/8a/fc/GZGO3pOI_o.png" width="765"></p> 
<p>获取SpriteRender对象控制图片的显示</p> 
<pre><code class="language-cs">using System.Collections;
using System.Collections.Generic;
using UnityEngine;

public class Player : MonoBehaviour
{
    public float moveSpeed=3;
    private SpriteRenderer sr;
    public Sprite[] tankSprite;
    private void Awake()
    {
        sr = GetComponent&lt;SpriteRenderer&gt;();//得到图片渲染组件
    }
    // Start is called before the first frame update
    void Start()
    {
        
    }

    // Update is called once per frame
    void Update()
    {
        float h = Input.GetAxisRaw("Horizontal");
        transform.Translate(Vector3.right * h * moveSpeed * Time.deltaTime,Space.World);//乘以delTatime表示按每一秒移动,以世界坐标轴移动
        if (h &lt; 0) {
            sr.sprite = tankSprite[3];//左
        } else if (h&gt;0) {
            sr.sprite = tankSprite[1];//右
        }
        float v = Input.GetAxisRaw("Vertical");
        transform.Translate(Vector3.up * v * moveSpeed * Time.deltaTime, Space.World);
        if (v &lt; 0)
        {
            sr.sprite = tankSprite[2];
        }
        else if (v &gt; 0)
        {
            sr.sprite = tankSprite[0];
        }
    }
}
</code></pre> 
<p><img alt="" height="856" src="https://images2.imgbox.com/74/7e/FZTxK2rr_o.png" width="894"></p> 
<p></p> 
<p>3.为Player添加碰撞效果</p> 
<p>添加碰撞器（点击Add Component后如图）</p> 
<p><img alt="" height="653" src="https://images2.imgbox.com/ca/e3/0TjoG1Si_o.png" width="1003"></p> 
<p>添加刚体组件</p> 
<p><img alt="" height="656" src="https://images2.imgbox.com/fc/4d/6gC3kXaO_o.png" width="1024"></p> 
<p>然后将Player的所有新加属性应用到其预制体上 </p> 
<p><img alt="" height="338" src="https://images2.imgbox.com/fc/43/rgume5dB_o.png" width="517"></p> 
<p>然后为剩余的Map预制体添加碰撞器（这里把River换到了Map文件中，Player放在了新文件夹下）</p> 
<p><img alt="" height="246" src="https://images2.imgbox.com/54/08/tSYNnMXu_o.png" width="685"></p> 
<p>然后在运行后发现坦克下落了（这是因为重力的原因，我们将其重力设为0即可） </p> 
<p><img alt="" height="729" src="https://images2.imgbox.com/59/00/cog0dLTT_o.png" width="695"></p> 
<p><img alt="" height="636" src="https://images2.imgbox.com/97/83/R4cNVryz_o.png" width="521"></p> 
<p>去掉Grass的碰撞器，因为逻辑上不需要碰撞</p> 
<p><img alt="" height="621" src="https://images2.imgbox.com/8c/bc/XBwQZg8z_o.png" width="475"></p> 
<p><img alt="" height="274" src="https://images2.imgbox.com/63/2d/JSt3x1fB_o.png" width="1072"></p> 
<p>当我们在运行时会发现坦克会在碰撞体边角处发生z轴的旋转，所以我们在这里勾选如图选项即可</p> 
<p><img alt="" height="266" src="https://images2.imgbox.com/11/64/umNYSrme_o.png" width="647"></p> 
<p>处理坦克遇到墙面时抖动滚动的情形（将所有代码放大FixedUpdate方法中并改Time.DeltaTime为Time.fixedDeltaTime，即固定每一帧执行的时间从而保证物理碰撞时相同的）</p> 
<pre><code class="language-cs">using System.Collections;
using System.Collections.Generic;
using UnityEngine;

public class Player : MonoBehaviour
{
    public float moveSpeed=3;
    private SpriteRenderer sr;
    public Sprite[] tankSprite;
    private void Awake()
    {
        sr = GetComponent&lt;SpriteRenderer&gt;();//得到图片渲染组件
    }
    // Start is called before the first frame update
    void Start()
    {
        
    }

    // Update is called once per frame
    void Update()
    {
        
    }

    private void FixedUpdate()
    {
        float h = Input.GetAxisRaw("Horizontal");
        transform.Translate(Vector3.right * h * moveSpeed * Time.deltaTime, Space.World);//乘以delTatime表示按每一秒移动,以世界坐标轴移动
        if (h &lt; 0)
        {
            sr.sprite = tankSprite[3];//左
        }
        else if (h &gt; 0)
        {
            sr.sprite = tankSprite[1];//右
        }
        float v = Input.GetAxisRaw("Vertical");
        transform.Translate(Vector3.up * v * moveSpeed * Time.deltaTime, Space.World);
        if (v &lt; 0)
        {
            sr.sprite = tankSprite[2];
        }
        else if (v &gt; 0)
        {
            sr.sprite = tankSprite[0];
        }
    }
}
</code></pre> 
<p><img alt="" height="698" src="https://images2.imgbox.com/3c/a5/Z3LepYev_o.png" width="540"></p> 
<p>在测试过程种，我们发现同时按下两个键（如左上、左下等）坦克会歇着走，这样是不好的用户体验，所以我们添加如下内容，同时为了代码简洁我们把它放到一个Move方法中调用</p> 
<pre><code class="language-cs">using System.Collections;
using System.Collections.Generic;
using UnityEngine;

public class Player : MonoBehaviour
{
    ...
    private void FixedUpdate()
    {
        Move();   
    }

    private void Move()
    {
        float h = Input.GetAxisRaw("Horizontal");
        transform.Translate(Vector3.right * h * moveSpeed * Time.fixedDeltaTime, Space.World);//乘以delTatime表示按每一秒移动,以世界坐标轴移动
        if (h &lt; 0)
        {
            sr.sprite = tankSprite[3];//左
        }
        else if (h &gt; 0)
        {
            sr.sprite = tankSprite[1];//右
        }

        if (h != 0)
        {
            return;//处理两键同时按下导致坦克斜着走问题
        }


        float v = Input.GetAxisRaw("Vertical");
        transform.Translate(Vector3.up * v * moveSpeed * Time.fixedDeltaTime, Space.World);
        if (v &lt; 0)
        {
            sr.sprite = tankSprite[2];
        }
        else if (v &gt; 0)
        {
            sr.sprite = tankSprite[0];
        }
    }
}
</code></pre> 
<p>设置层级显示（即多张图片叠在一起后优先显示那张图片），下图将出生动画层级设为1（默认为0）则坦克图片经过时就会被遮盖了，同理可设置Grass、Explosion等</p> 
<p><img alt="" height="544" src="https://images2.imgbox.com/12/98/CSovsE5p_o.png" width="514"></p> 
<p>然后我们添加Bullet（子弹），将图片拖入左侧面板即可，然后再创建其预制体（放在Tank下）</p> 
<p><img alt="" height="475" src="https://images2.imgbox.com/09/6d/3LocbofB_o.png" width="562"></p> 
<p> 添加发射子弹的函数Attack，并绑定预制体</p> 
<pre><code class="language-cs">using System.Collections;
using System.Collections.Generic;
using UnityEngine;

public class Player : MonoBehaviour
{
    ...
    public GameObject bulletPrefab;//子弹预制体
    private void Awake()
    {
        sr = GetComponent&lt;SpriteRenderer&gt;();//得到图片渲染组件
    }
    // Start is called before the first frame update
    void Start()
    {
        
    }

    // Update is called once per frame
    void Update()
    {
        Attack(); //发射子弹,一定要放在Update中，如果放在FixedUpdate会偶尔发出不出子弹
    }

    private void FixedUpdate()
    {
        Move(); //坦克移动  
        
    }

    private void Attack() {
        if (Input.GetKeyDown(KeyCode.Space)) {
            Instantiate(bulletPrefab, transform.position, transform.rotation);
        }
    }
    ...
}
</code></pre> 
<p><img alt="" height="329" src="https://images2.imgbox.com/59/3e/kTd4o9x5_o.png" width="516"></p> 
<p>控制子弹的角度（这里需要把欧拉角转换为四元数表示传入），然后再每次坦克变向时设置bulletAngle</p> 
<pre><code class="language-cs">using System.Collections;
using System.Collections.Generic;
using UnityEngine;

public class Player : MonoBehaviour
{
    ...
    private Vector3 bulletAngle;//子弹的发射角度
    ...

    // Update is called once per frame
    void Update()
    {
        Attack(); //发射子弹
    }

    private void FixedUpdate()
    {
        Move(); //坦克移动  
        
    }

    private void Attack() {
        if (Input.GetKeyDown(KeyCode.Space)) {
            Instantiate(bulletPrefab, transform.position, Quaternion.Euler(transform.eulerAngles+bulletAngle));
        }
    }

    private void Move()
    {
        float v = Input.GetAxisRaw("Vertical");
        transform.Translate(Vector3.up * v * moveSpeed * Time.fixedDeltaTime, Space.World);
        if (v &lt; 0)
        {
            sr.sprite = tankSprite[2];
            bulletAngle = new Vector3(0, 0, -180);
        }
        else if (v &gt; 0)
        {
            sr.sprite = tankSprite[0];
            bulletAngle = new Vector3(0, 0, 0);
        }

        if (v != 0)
        {
            return;//处理两键同时按下导致坦克斜着走问题
        }

        float h = Input.GetAxisRaw("Horizontal");
        transform.Translate(Vector3.right * h * moveSpeed * Time.fixedDeltaTime, Space.World);//乘以delTatime表示按每一秒移动,以世界坐标轴移动
        if (h &lt; 0)
        {
            sr.sprite = tankSprite[3];//左
            bulletAngle = new Vector3(0, 0, 90);//这里记住坐标是反着的，
        }
        else if (h &gt; 0)
        {
            sr.sprite = tankSprite[1];//右
            bulletAngle = new Vector3(0, 0, -90);
        }
    }
}
</code></pre> 
<p>欧拉角：欧拉角包括3个旋转，根据这3个旋转来指定一个刚体的朝向。这3个旋转分别绕x轴，y轴和z轴，分别称为Pitch，Yaw和Roll</p> 
<p><img alt="" height="216" src="https://images2.imgbox.com/33/99/EX6oJvtC_o.png" width="517"></p> 
<p><img alt="" height="322" src="https://images2.imgbox.com/2d/01/sf6PabII_o.png" width="675"></p> 
<p>绕X轴（红线旋转）</p> 
<p><img alt="" src="https://images2.imgbox.com/79/62/pCcjeZpr_o.gif"></p> 
<p>绕Y轴（绿线）旋转 </p> 
<p><img alt="" src="https://images2.imgbox.com/ae/33/aStz17Sq_o.gif"></p> 
<p>绕Z轴（蓝线）旋转 </p> 
<p><img alt="" src="https://images2.imgbox.com/9f/26/woEKZjXR_o.gif"></p> 
<p>与我们在Unity的坐标一一对应 </p> 
<p><img alt="" height="145" src="https://images2.imgbox.com/42/6b/3gPrQR9F_o.png" width="134"></p> 
<p>四元数</p> 
<p>这个四元数真的很难理解，我们先来看一个我们好理解的二元数（也即我们学过的复数），如图我们画一条线段AB（用3+4i表示从A点到B点的路程变化，而B的坐标为(3，4)），当我们想把这条线段旋转90度时，我们得到-6+4i，从而达到旋转后B点的坐标为(-6，4)，这并非巧合，而是可通过计算得到：(4+6i)*i=4i-6，即乘以i代表旋转90度。如果想旋转45度呢？乘以 <img alt="1/\sqrt{2}+1/\sqrt{2}i" class="mathcode" src="https://images2.imgbox.com/a8/be/tLINKbpg_o.png"> 就可以得到（即旋转度数为<img alt="\theta" class="mathcode" src="https://images2.imgbox.com/13/3b/AGWcvD9C_o.png">，乘以cos<img alt="\theta" class="mathcode" src="https://images2.imgbox.com/fb/8c/CHB13JhW_o.png">+sin<img alt="\theta" class="mathcode" src="https://images2.imgbox.com/b4/f4/2cWQsTJ1_o.png">i）  </p> 
<p><img alt="" height="174" src="https://images2.imgbox.com/46/89/LHTLq1oR_o.png" width="159"><img alt="" height="174" src="https://images2.imgbox.com/f1/43/xEHAEwy0_o.png" width="318"></p> 
<p>然后我们推广到三维空间，同样的几何意义，一个空间线段旋转指定度数得到新的坐标，虚四元数表示为：q=q0+q1i+q2j+q3k，其中<img alt="i^{2}+j^{2}+k^{2}=ijk=-1" class="mathcode" src="https://images2.imgbox.com/7b/11/PIY2eGyO_o.png">，则旋转后的四元数记为p=(q0+q1i+q2j+q3k)*(cos <img alt="\theta" class="mathcode" src="https://images2.imgbox.com/62/0f/Mlvky43A_o.png">+sin <img alt="\theta" class="mathcode" src="https://images2.imgbox.com/f4/b7/Nd9Y7o8w_o.png">i+sin <img alt="\theta" class="mathcode" src="https://images2.imgbox.com/7c/cc/y2jA5NwK_o.png">j+sin <img alt="\theta" class="mathcode" src="https://images2.imgbox.com/dd/4a/i3G9vLhn_o.png">k)即可得到了</p> 
<p><img alt="" height="281" src="https://images2.imgbox.com/08/e5/UUMuTHrE_o.png" width="761"></p> 
<p>控制子弹的移动，创建Bullet脚本，并放在Scripts下，并于Bullet预制体绑定</p> 
<pre><code class="language-cs">using System.Collections;
using System.Collections.Generic;
using UnityEngine;

public class Bullet : MonoBehaviour
{
    public float moveSpeed = 10;
    // Start is called before the first frame update
    void Start()
    {
        
    }

    // Update is called once per frame
    void Update()
    {
        transform.Translate(transform.up * moveSpeed * Time.deltaTime, Space.World);//世界坐标轴
    }
}
</code></pre> 
<p>为子弹添加CD（不添加会随这快速按键发射太快）</p> 
<pre><code class="language-cs">using System.Collections;
using System.Collections.Generic;
using UnityEngine;

public class Player : MonoBehaviour
{
    ...
    private float timeVal;//发射子弹CD


   
    // Update is called once per frame
    void Update()
    {
        Attack();
        if (timeVal &gt;= 0.4){
            Attack(); //发射子弹
        }else {
            timeVal += Time.deltaTime;
        }
    }

    private void FixedUpdate()
    {
        Move(); //坦克移动  
        
    }

    private void Attack() {
        if (Input.GetKeyDown(KeyCode.Space)) {
            Instantiate(bulletPrefab, transform.position, Quaternion.Euler(transform.eulerAngles+bulletAngle));
            timeVal = 0;
        }
    }
    ...
}
</code></pre> 
<p>为子弹添加触发器（记得勾选Is Trigger）和钢体组件（重力设为0）</p> 
<p><img alt="" height="645" src="https://images2.imgbox.com/3c/3e/ShdiKJo1_o.png" width="797"></p> 
<p> <img alt="" height="146" src="https://images2.imgbox.com/69/db/XKBbqNcM_o.png" width="278"></p> 
<p><img alt="" height="205" src="https://images2.imgbox.com/da/8e/aKonVviH_o.png" width="660"></p> 
<p><img alt="" height="255" src="https://images2.imgbox.com/58/63/GklR815y_o.png" width="355"></p> 
<p>为预制体添加Tag，并修改对应Player、Barrier、Wall的Tag</p> 
<p><img alt="" height="324" src="https://images2.imgbox.com/df/38/2xu50piH_o.png" width="595"></p> 
<p><img alt="" height="163" src="https://images2.imgbox.com/f5/3b/iChT4BxD_o.png" width="574"></p> 
<p><img alt="" height="220" src="https://images2.imgbox.com/4f/4e/mns7n7kf_o.png" width="509"></p> 
<p>创建空气墙（为了给四周做一个边界，从而判断子弹何时被销毁）复制一个Barrier取名为AirBarrier，删除其SpriteRenderer组件（这样它就变透明不会渲染样式了，即看不见的墙）然后创建其对应预制体 </p> 
<p><img alt="" height="279" src="https://images2.imgbox.com/14/53/ZpKAdVSC_o.png" width="1073"></p> 
<p> 添加坦克开始时的护盾效果，将护盾效果放在Player下面（这样就会随着坦克移动了），然后在Player脚本添加护盾效果预制体（记得绑定）、护盾效果时间和是否保护标志等逻辑代码（当护盾时间不大于0时隐藏护盾效果）最后将Player的属性Apply到预制体上</p> 
<p><img alt="" height="61" src="https://images2.imgbox.com/5d/e3/naytsrqD_o.png" width="256"><img alt="" height="472" src="https://images2.imgbox.com/b2/5f/tjj3X1e6_o.png" width="1044"></p> 
<pre><code class="language-cs">using System.Collections;
using System.Collections.Generic;
using UnityEngine;

public class Player : MonoBehaviour
{
    ...
    private float defendTimeVal=3;//保护时间
    private bool isDefended=true;//是否保护
    ...
    public GameObject defendEffectPrefab;//护盾特效预制体
    ...

    // Update is called once per frame
    void Update()
    {
        //是否处于无敌状态
        if (isDefended) {
            defendEffectPrefab.SetActive(true);
            defendTimeVal -= Time.deltaTime;
            if (defendTimeVal&lt;=0) {
                isDefended = false;
                defendEffectPrefab.SetActive(false);
            }
        }
        if (timeVal &gt;= 0.4)
        {
            Attack(); //发射子弹
        }
        else
        {
            timeVal += Time.deltaTime;
        }

    }
}
</code></pre> 
<p>添加Boos的破坏效果，新建Heart脚本，并于Heart预制体绑定，编码，然后绑定图片</p> 
<pre><code class="language-cs">using System.Collections;
using System.Collections.Generic;
using UnityEngine;

public class Heart : MonoBehaviour
{
    private SpriteRenderer sr;
    public Sprite BrokenSprite;
    // Start is called before the first frame update
    void Start()
    {
        sr= GetComponent&lt;SpriteRenderer&gt;();
    }

    // Update is called once per frame
    void Update()
    {
        
    }

    public void Die() {
        sr.sprite = BrokenSprite;
    }
}
</code></pre> 
<p><img alt="" height="172" src="https://images2.imgbox.com/23/c8/K8rhr0xa_o.png" width="731"></p> 
<p>为子弹创建触发方法（针对Wall、Heart、Barrier）（Barrier的IsPlayerBullet要勾选）</p> 
<pre><code class="language-cs">using System.Collections;
using System.Collections.Generic;
using UnityEngine;

public class Bullet : MonoBehaviour
{
    public float moveSpeed = 10;
    public bool isPlayerBullet;//是否为玩家子弹
    // Start is called before the first frame update
    void Start()
    {
        
    }

    // Update is called once per frame
    void Update()
    {
        transform.Translate(transform.up * moveSpeed * Time.deltaTime, Space.World);//世界坐标轴
    }

    private void OnTriggerEnter2D(Collider2D collision)
    {
        switch (collision.tag) {
            case "Tank":
                if (!isPlayerBullet) {
                    collision.SendMessage("Die");//执行碰撞到的物体的Die方法
                }
                break;
            case "Heart":
                collision.SendMessage("Die");//执行碰撞到的物体的Die方法
                Destroy(gameObject);//销毁子弹自身
                break;
            case "Enemy":
                break;
            case "Wall":
                Destroy(collision.gameObject);//销毁碰撞到的物体
                Destroy(gameObject);//销毁子弹自身
                break;
            case "Barrier":
                Destroy(gameObject);//销毁子弹自身
                break;
            default:
                break;
        }
    }
}
</code></pre> 
<p>重命名子弹名称，并新建一个EnemyBullet，然后其IsPlayerBullet取消勾选，PlayerBullet则勾选 </p> 
<p><img alt="" height="151" src="https://images2.imgbox.com/05/31/7Zqsd3Wb_o.png" width="554"></p> 
<p><img alt="" height="182" src="https://images2.imgbox.com/1b/4d/3jRs8rrH_o.png" width="573"></p> 
<p>创建爆炸特效脚本并与预制体绑定</p> 
<pre><code class="language-cs">using System.Collections;
using System.Collections.Generic;
using UnityEngine;

public class Explosion : MonoBehaviour
{
    // Start is called before the first frame update
    void Start()
    {
        Destroy(gameObject, 0.2f);
    }

    // Update is called once per frame
    void Update()
    {
        
    }
}
</code></pre> 
<p>创建出生效果，创建Born脚本(与Born预制体绑定)，然后将Player预制体与脚本绑定</p> 
<pre><code class="language-cs">using System.Collections;
using System.Collections.Generic;
using UnityEngine;

public class Born : MonoBehaviour
{
    public GameObject playerPrefab;
    // Start is called before the first frame update
    void Start()
    {
        Invoke("BornTank", 1f);//延时调用
        Destroy(gameObject, 1f);//延时销毁
    }

    // Update is called once per frame
    void Update()
    {
        
    }

    private void BornTank() {
        Instantiate(playerPrefab, transform.position, Quaternion.identity);
    }
}
</code></pre> 
<p><img alt="" height="342" src="https://images2.imgbox.com/c2/89/rqa0ml5p_o.png" width="742"></p> 
<p>创建敌人（设置钢体、碰撞器、重力为0，Z轴定向，设置4各方向图片、创建对应预制体，绑定爆炸效果预制体和子弹预制体）添加移动AI（每3秒进行一次攻击，每4秒进行一次转向），并添加敌人子弹的判定效果</p> 
<pre><code class="language-cs">using System.Collections;
using System.Collections.Generic;
using UnityEngine;

public class Enemy : MonoBehaviour
{
    public float moveSpeed = 3;
    private Vector3 bulletAngle;//子弹的发射角度
    private float v, h;
    private float timeVal;//发射子弹CD
    private float timeValChangeDirection=4;//改变方向的时间


    private SpriteRenderer sr;
    public Sprite[] tankSprite;
    public GameObject bulletPrefab;//子弹预制体
    public GameObject explosionPrefab;//爆炸效果预制体
    private void Awake()
    {
        sr = GetComponent&lt;SpriteRenderer&gt;();//得到图片渲染组件
    }
    // Start is called before the first frame update
    void Start()
    {

    }

    // Update is called once per frame
    void Update()
    {
        if (timeVal &gt;= 3)
        {
            Attack(); //发射子弹
        }
        else
        {
            timeVal += Time.deltaTime;
        }

    }

    private void FixedUpdate()
    {
        Move(); //坦克移动  

    }

    private void Attack()
    {
            Instantiate(bulletPrefab, transform.position, Quaternion.Euler(transform.eulerAngles + bulletAngle));
            timeVal = 0;
    }

    private void Move()
    {
        if (timeValChangeDirection &gt;= 4)
        {
            int num = Random.Range(0, 8);
            if (num &gt; 5)
            {
                v = -1;//向下走
                h = 0;
            }
            else if (num == 0)
            {
                v = 1;//向后走
                h = 0;
            }
            else if (num &gt; 0 &amp;&amp; num &lt;= 2)
            {
                h = -1;//向左走
                v = 0;
            }
            else if (num &gt; 2 &amp;&amp; num &lt;= 4)
            {
                h = 1;//向右走
                v = 0;
            }
            timeValChangeDirection = 0;
        } else {
            timeValChangeDirection += Time.fixedDeltaTime;
        }
        transform.Translate(Vector3.right * h * moveSpeed * Time.fixedDeltaTime, Space.World);//乘以delTatime表示按每一秒移动,以世界坐标轴移动
        if (h &lt; 0)
        {
            sr.sprite = tankSprite[3];//左
            bulletAngle = new Vector3(0, 0, 90);//这里记住坐标是反着的，
        }
        else if (h &gt; 0)
        {
            sr.sprite = tankSprite[1];//右
            bulletAngle = new Vector3(0, 0, -90);
        }

        if (h != 0)
        {
            return;//处理两键同时按下导致坦克斜着走问题
        }

        transform.Translate(Vector3.up * v * moveSpeed * Time.fixedDeltaTime, Space.World);
        if (v &lt; 0)
        {
            sr.sprite = tankSprite[2];
            bulletAngle = new Vector3(0, 0, -180);
        }
        else if (v &gt; 0)
        {
            sr.sprite = tankSprite[0];
            bulletAngle = new Vector3(0, 0, 0);
        }
    }

    private void Die()
    {
        Instantiate(explosionPrefab, transform.position, transform.rotation);//产生爆炸效果
        Destroy(gameObject);
    }
}
</code></pre> 
<pre><code class="language-cs">using System.Collections;
using System.Collections.Generic;
using UnityEngine;

public class Bullet : MonoBehaviour
{
    public float moveSpeed = 10;
    public bool isPlayerBullet;//是否为玩家子弹
    // Start is called before the first frame update
    void Start()
    {
        
    }

    // Update is called once per frame
    void Update()
    {
        transform.Translate(transform.up * moveSpeed * Time.deltaTime, Space.World);//世界坐标轴
    }

    private void OnTriggerEnter2D(Collider2D collision)
    {
        switch (collision.tag) {
            case "Tank":
                if (!isPlayerBullet) {
                    collision.SendMessage("Die");//执行碰撞到的物体的Die方法
                    Destroy(gameObject);//销毁子弹自身                
                }
                break;
            case "Heart":
                collision.SendMessage("Die");//执行碰撞到的物体的Die方法
                Destroy(gameObject);//销毁子弹自身
                break;
            case "Enemy":
                if (isPlayerBullet) {
                    collision.SendMessage("Die");
                    Destroy(gameObject);//销毁子弹自身
                }
                break;
            case "Wall":
                Destroy(collision.gameObject);//销毁碰撞到的物体
                Destroy(gameObject);//销毁子弹自身
                break;
            case "Barrier":
                Destroy(gameObject);//销毁子弹自身
                break;
            default:
                break;
        }
    }
}
</code></pre> 
<p>创建多个Born（绑定敌人坦克预制体，多个Born中有一个是用来生成Player的，所以需要勾选CreatePlayer）编写代码控制显示和销毁以及产生的坦克类型</p> 
<p><img alt="" height="548" src="https://images2.imgbox.com/1e/a3/oM4GWlR4_o.png" width="885"></p> 
<p><img alt="" height="533" src="https://images2.imgbox.com/04/e5/p13LYcXM_o.png" width="876"></p> 
<p><img alt="" height="260" src="https://images2.imgbox.com/36/47/lTdlCc9B_o.png" width="810"></p> 
<pre><code class="language-cs">using System.Collections;
using System.Collections.Generic;
using UnityEngine;

public class Born : MonoBehaviour
{
    public GameObject playerPrefab;
    public GameObject[] enemyPrefabList;
    public bool createPlayer;
    // Start is called before the first frame update
    void Start()
    {
        Invoke("BornTank", 1f);//延时调用
        Destroy(gameObject, 1f);//延时销毁
    }

    // Update is called once per frame
    void Update()
    {
        
    }

    private void BornTank() {
        if (createPlayer) {
            Instantiate(playerPrefab, transform.position, Quaternion.identity);
        }else {
            int num = Random.Range(0, 2);
            Instantiate(enemyPrefabList[num], transform.position, Quaternion.identity);
        }
    }
}
</code></pre> 
<p><img alt="" height="404" src="https://images2.imgbox.com/31/4e/PFgtK4Tx_o.png" width="598"></p> 
<p><img alt="" height="380" src="https://images2.imgbox.com/d4/55/ad21tPX2_o.png" width="618"></p> 
<p>创建空对象命名为MapCreation，创建MapCreation脚本，声明一个GameObject数组，将下图种相关预制体拖入（右上角的锁可以锁定该页面方便拖放预制体） </p> 
<p><img alt="" height="613" src="https://images2.imgbox.com/a5/49/kd6iDLxC_o.png" width="1132"></p> 
<p> 创建BOSS和BOSS周围的墙</p> 
<pre><code class="language-cs">using System.Collections;
using System.Collections.Generic;
using UnityEngine;

public class MapCreation : MonoBehaviour
{
    public GameObject[] item;//保存Boss、墙、障碍、出生效果、河流、草、空气墙
    private void Awake()
    {
        //在界面下边界中间位置，创建Boss
        CreateItem(item[0], new Vector3(0, -8, 0), Quaternion.identity);
        //Boss周围的墙
        CreateItem(item[1], new Vector3(-1,-8,0), Quaternion.identity);
        CreateItem(item[1], new Vector3(1, -8, 0), Quaternion.identity);
        for (int i=-1;i&lt;2;i++) {
            CreateItem(item[1], new Vector3(i, -7, 0), Quaternion.identity);
        }
    }

    private void CreateItem(GameObject createObject,Vector3 position,Quaternion rotation) {
        GameObject item = Instantiate(createObject, position, rotation);
        item.transform.SetParent(gameObject.transform);//将新建的对象放在MapCreation下使目录简洁
    }
}
</code></pre> 
<p><img alt="" height="832" src="https://images2.imgbox.com/b2/5b/XGeMht6P_o.png" width="760"></p> 
<p>创建外围空气墙，随机位置创建其他对象（墙、障碍、海、草等），拖入一个主角坦克生成点Born</p> 
<pre><code class="language-cs">using System.Collections;
using System.Collections.Generic;
using UnityEngine;

public class MapCreation : MonoBehaviour
{
    public GameObject[] item;//保存Boss、墙、障碍、出生效果、河流、草、空气墙
    private List&lt;Vector3&gt; itemPostionList=new List&lt;Vector3&gt;();//保存每个对象的位置，用于判断随机生成的位置是否已有对象
    private void Awake()
    {
        //在界面下边界中间位置，创建Boss
        CreateItem(item[0], new Vector3(0, -8, 0), Quaternion.identity);
        //Boss周围的墙
        CreateItem(item[1], new Vector3(-1,-8,0), Quaternion.identity);
        CreateItem(item[1], new Vector3(1, -8, 0), Quaternion.identity);
        for (int i=-1;i&lt;2;i++) {
            CreateItem(item[1], new Vector3(i, -7, 0), Quaternion.identity);
        }
        //创建外围空气墙
        for (int i=-11;i&lt;12;i++) {//上边界
            CreateItem(item[6], new Vector3(i, 9, 0), Quaternion.identity);
        }
        for (int i = -11; i &lt; 12; i++)//下边界
        {
            CreateItem(item[6], new Vector3(i, -9, 0), Quaternion.identity);
        }
        for (int i = -8; i &lt; 9; i++)//左边界
        {
            CreateItem(item[6], new Vector3(-11, i, 0), Quaternion.identity);
        }
        for (int i = -8; i &lt; 9; i++)//右边界
        {
            CreateItem(item[6], new Vector3(11, i, 0), Quaternion.identity);
        }

        //创建其他对象（墙、障碍、河流、草）
        for (int i=0;i&lt;20;i++) {
            CreateItem(item[1], createRandomPosition(), Quaternion.identity);
        }
        for (int i = 0; i &lt; 20; i++)
        {
            CreateItem(item[2], createRandomPosition(), Quaternion.identity);
        }
        for (int i = 0; i &lt; 20; i++)
        {
            CreateItem(item[4], createRandomPosition(), Quaternion.identity);
        }
        for (int i = 0; i &lt; 20; i++)
        {
            CreateItem(item[5], createRandomPosition(), Quaternion.identity);
        }


    }

    private void CreateItem(GameObject createObject,Vector3 position,Quaternion rotation) {
        GameObject item = Instantiate(createObject, position, rotation);
        item.transform.SetParent(gameObject.transform);//将新建的对象放在MapCreation、下
        itemPostionList.Add(position);//将新建的对象位置放入列表
    }

    private Vector3 createRandomPosition() {
        while (true) {
            Vector3 position = new Vector3(Random.Range(-9, 10), Random.Range(-7, 8), 0);//不在四个边界产生游戏物体
            if (!IsUsedPosition(position)) {
                return position;
            }
        }
    }

    private bool IsUsedPosition(Vector3 position) {
        for (int i=0;i&lt;itemPostionList.Count;i++) {
            if (position==itemPostionList[i]) {
                return true;
            }
        }
        return false;
    }
}
</code></pre> 
<p><img alt="" height="498" src="https://images2.imgbox.com/ab/85/3mP7gaxU_o.png" width="642"></p> 
<p></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/85ca471a288d706d9ac2a0816825d076/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">unity学习笔记（二）—— 制作第一个小游戏</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/3b97561d5513b9d334452f8ed2105667/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">C&#43;&#43;后续：QT学习（Qt概述，创建QT项目）</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>