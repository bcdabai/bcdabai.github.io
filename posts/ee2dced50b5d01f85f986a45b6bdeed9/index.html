<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>28nm Memory Compiler开发（一）OpenRAM论文阅读 - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="28nm Memory Compiler开发（一）OpenRAM论文阅读" />
<meta property="og:description" content="Abstract 内存设计的可用性常常抑制了计算机系统的研究。现有的流程设计套件（PDK）经常缺少存储器编译器，而昂贵的商业解决方案仅提供具有不变单元，有限配置和限制性许可证的存储器模型。手动创建内存可能既费时又乏味，而且设计通常不够灵活。本文介绍了OpenRAM，一种开放源代码的内存编译器，它提供了一个平台，用于跨各种技术，大小和配置生成，表征和验证可构造内存设计。它可以进行计算机体系结构，片上系统设计，存储器电路和器件研究以及计算机辅助设计的研究。
Introduction 静态随机存取存储器（SRAM）已成为嵌入在所有片上系统（SoC），专用集成电路（ASIC）和微处理器设计中的标准组件。它们的广泛应用导致对电路设计和存储器配置的各种要求。但是，手动设计非常耗时。内存的规则结构很好地导致了自动化，该自动化迅速产生了大小和配置变化，但是要使用多种技术和工具方法来开发这种结构则具有挑战性。此外，存储器设计在总体系统性能和成本中起着重要作用，因此优化很重要。因此，内存编译器是至关重要的工具。
大多数学术IC的设计方法受到存储器可用性的限制。代工厂和供应商可提供许​​多标准单元工艺设计套件（PDK），但这些PDK通常不随存储器阵列或存储器编译器一起提供。如果内存编译器是免费提供的，则它通常仅支持不可制造的通用处理技术。由于学术经费的限制，商业行业的解决方案通常对研究人员不可行。另外，这些商业解决方案在定制存储器大小和存储器的特定组件方面受到限制。 PDK可能具有请求“黑匣子”存储模型的选项，但它们也不可修改且可用配置有限。这些限制和许可问题使得无法对真实世界的记忆进行比较和试验。
学术研究人员能够设计自己的自定义存储器，但这可能是一项繁琐且耗时的任务，并且可能不是该研究的预期目的。通常，存储器设计是研究项目所需的最基本的要求，因此，存储器设计通常较差且未进行优化。在存储器研究中，比较存储器性能和密度时通常不考虑外围电路。缺少可定制的编译器，使得研究人员难以对单行或一列存储单元以外的电路和方法进行原型设计和验证。
OpenRAM项目旨在为内存提供一个开放源代码的内存编译器开发框架。它以通用的45nm技术和可制造的可扩展CMOS（SCMOS）提供参考电路和物理实现，但也已使用一个简单的技术文件将其移植到了多个商业技术节点上。 OpenRAM还包括一种特性分析方法，因此它不仅可以生成电路和布局，还可以生成时序和功率特性结果，而又与特定的商用工具无关。最重要的是，OpenRAM完全可以由用户修改，因为所有源代码都是开源的：
https://openram.soe.ucsc.edu/
本文的其余部分安排如下：第2节提供了有关先前内存编译器的背景知识。第3节介绍了OpenRAM中的参考存储器体系结构。第4节专门介绍了OpenRAM存储器编译器的实现和主要功能。在第5节中，显示了针对不同大小和技术的存储器的面积，时序和功耗的分析。最后，本文在第6节中进行了总结。
Background 存储器编译器已被用于电子设计自动化（EDA）设计流程中，以缩短设计时间，远远早于当代的编译器[2，9]。但是，这些编译器通常不可移植，因为它们不过是帮助设计人员的快速脚本。移植到新技术本质上需要重写脚本。但是，在不同技术之间移植设计时，设计生产率的提高导致了对内存阵列编译器的更多研究。
随着技术进入深亚微米（DSM）时代，由于降低了静态噪声裕量（SNM），增加了制造变异性并增加了泄漏功耗，存储器设计已成为电路设计中最具挑战性的部分之一。由于必须适应不断变化的技术，这极大地增加了内存编译器的复杂性。同时，设计方法从硅编译器转变为需要大型优化库的标准单元布局和布线方法。在这段时间内，工业界开始使用标准单元库和内存编译器的第三方供应商，这些供应商允许其重复使用以摊销开发成本。这些下一代存储器编译器提供了硅验证功能，使设计人员可以专注于他们的新设计，而不是诸如存储器生成之类的耗时任务。
现代内存编译器已被业界广泛使用，但是内部操作通常是隐藏的。几家著名的公司和代工厂都向其客户提供了内存编译器。这些存储器编译器通常允许客户在签署许可协议后查看前端仿真，时序/功率值和引脚位置。诸如布局之类的后端功能通常直接提供给晶圆厂，并且仅向用户收取许可费。
具体来说，Global Foundries免费提供前端PDK，但不提供后端详细视图[6]。 Faraday Technologies提供了一个“黑匣子”设计套件，使用户不知道内部存储器设计的详细信息[5]。 Dolphin Technology提供了可以为多种技术创建RAM，ROM和CAM的闭源编译器[4]。这些大多数商业编译器不允许客户更改基本设计，受公司许可的限制，并且通常需要付费。这使得它们实际上不可用，对于许多学术研究项目没有用处。
除了行业提供的内存编译器之外，各种研究小组还发布了用于生成内存的脚本。但是，这些设计未经硅验证，通常仅由简单的结构组成。例如，FabMem能够创建小型阵列，但高度依赖于Cadence设计工具[15]。脚本不提供任何表征功能，并且不能轻松地与商业布局和路线工具集成。
Synopsys通用内存编译器（GMC）是学术界最近另一个有希望的解决方案[7]。该软件提供了示例通用库，例如​​Synopsys的32 / 28nm和90nm抽象技术，并且可以为这些技术生成整个SRAM。 GMC生成GDSII布局数据，SPICE网表，Verilog和VHDL模型，时序/电源库以及DRC / LVS验证报告。但是，不建议将GMC用于制造，因为它支持的技术不是真实的。其唯一目的是帮助VLSI课程的学生学习在设计流程中使用内存的知识。
学术界已经进行了多种尝试来实现不受限制的存储器编译器：微电子研究所的SRAM IP编译器[22]，东南大学电子科学与工程学院的存储器IP编译器[11]和清华大学的低功耗SRAM编译器[21]。这些都是内存编译器的所有方法和设计流程，但没有公开发布。
Architecture OpenRAM SRAM体系结构基于一组带有外围电路和控制逻辑的存储单元，如图1所示。这些进一步细分为八个主要模块：位单元阵列，地址解码器，字线驱动器，列多路复用器，预充电电路，读出放大器，写驱动器和控制逻辑。
位单元阵列：在OpenRAM的初始版本中，6T单元是默认存储单元，因为它是SRAM器件中最常用的单元。 6T单元与相邻的字线和位线平铺在一起以构成存储阵列。使用多列数据字使位单元阵列的长宽比尽可能为正方形。存储单元是针对每种技术的定制设计的库单元。其他类型的存储单元（例如7T，8T和10T单元）可以用作6T单元的替代方案。
地址解码器：地址解码器将行地址位作为输入，并声明适当的字线，以便可以从中读取或写入正确的存储单元。地址解码器位于内存阵列的左侧，并横跨该阵列的垂直长度。可以使用不同类型的解码器，例如附带的动态NAND解码器，但OpenRAM的默认选项是分层CMOS解码器。
字线驱动器：字线驱动器作为缓冲区插入到地址解码器和内存阵列之间。字线驱动器的大小取决于存储器阵列的宽度，以便它们可以驱动位选择器阵列上的行选择信号。
列多路复用器：列多路复用器是一个可选块，使用低位地址位选择一行中的关联字。列复用器是动态生成的，可以省略，也可以有2或4个输入。较大的列复用器是可能的，但在存储器中并不经常使用。也有用于多级树复用器的选项。
位线预充电：该电路在时钟的第一阶段为读操作预充电位线。预充电电路位于存储阵列中每一列的顶部，并均衡位线电压，以便读出放大器可以感测两条位线之间的电压差。
读出放大器：差分读出放大器用于在执行读取操作时感测存储单元位线之间的电压差。读出放大器使用位线隔离技术来提高性能。如果不使用列多路复用器，则将读出放大器电路放置在列多路复用器或存储器阵列下方。每个输出位都有一个读出放大器。
写驱动器：写驱动器将输入数据信号发送到位线上以进行写操作。写驱动器为三态，因此可以将它们放置在列多路复用器/存储器阵列与读出放大器之间。每个输入数据位都有一个写驱动器。
控制逻辑：OpenRAM SRAM体系结构使用系统时钟（clk）合并了标准同步存储器接口。控制逻辑使用外部提供的低电平有效输出使能（OEb），芯片选择（CSb）和写使能（WEb）将多个SRAM组合为更大的结构。在内部，OpenRAM编译器可以具有1、2或4个存储库，以分摊控制逻辑和外围电路的面积/功耗。
所有输入控制信号均使用主从（MS）触发器（FF）存储，以确保信号在整个时钟周期内均有效。在读取操作期间，如图2（a）所示，在负时钟沿（周期的后半部分）之后可以使用数据。为了避免死循环而降低性能，在OpenRAM时序中使用了零总线周转（ZBT）技术。由于没有等待状态，因此ZBT可以实现更高的内存吞吐量。在ZBT写期间，数据在负时钟边沿之前设置，并在负边沿捕获。图2（b）显示了写操作期间输入信号的时序。
内部控制信号是使用复制位线（RBL）结构生成的，用于读出放大器使能和输出数据存储[1]的时序。在低于100nm的技术中，由于存在工艺可变性，RBL会在准确的时间打开检测放大器。
Implementation OpenRAM的方法是使用Python编程语言中的面向对象方法实现的。 Python是一种简单但功能强大的语言，易于学习且非常易读。而且，Python使得可移植到大多数操作系统。除DRC / LVS工具外，OpenRAM没有其他依赖项，但是如果工具不可用，则会禁用警告并被禁用。除了系统可移植性之外，OpenRAM还可以跨多种处理技术进行转换。这是通过使用通用例程基于所有技术的通用功能来生成内存来实现的。为了促进用户修改和技术互操作性，OpenRAM提供了45nm FreePDK45的参考实现[17]和使用MOSIS可扩展CMOS（SCMOS）设计规则的可制造选项[13]。 FreePDK45使用现代技术中存在的许多设计规则，但是不可制造，而SCMOS可以使用MOSIS铸造服务来制造设计。 SCMOS不是机密信息，并且包含使用它的实现，但是，它不包含许多高级DSM设计规则。
OpenRAM也已移植到其他商业技术，但是由于许可问题，这些技术未直接包含在内。 OpenRAM的框架分为“前端”和“后端”两种方法，如图3所示。前端具有编译器和特征描述器。编译器根据用户输入生成SPICE模型及其GDSII布局。表征器调用SPICE仿真器以产生时序和功率结果。后端使用从GDSII布局中提取的spice网表，用于生成带注释的时序和功率模型。
基本数据结构 OpenRAM中的设计模块是从设计类（design.py）派生的。design类具有名称，SPICE模型（网表）和layout。 SPICE模型和layout都从分层类继承其功能。design类还提供继承的功能，以对任何子设计执行DRC和LVS验证，以进行分层调试。
design类从spice类（hierarchy spice.py）派生而来，该类具有维护电路层次结构的数据结构。此类维护design实例，它们的引脚，它们的连接以及辅助功能，以维护电路层次结构的结构和连通性。
design类还派生自布局类（层次结构layout.py）。此类包含布局中子模块的物理实例的列表，以及用于简单对象（例如当前层次结构级别中的形状和标签）的结构。此外，还有一些辅助功能可以维护物理布局结构。 OpenRAM具有集成的自定义GDSII库，用于读取，写入和操作GDSII文件。该库最初称为GdsMill [20]，现已针对OpenRAM进行了修改，调试和扩展。授予了将GdsMill源包含在OpenRAM中的全部权利，但是为了使接口更容易并且可以移植到其他物理布局数据库，OpenRAM实现了抽象GdsMill库的几何包装类（geometry.py）。
工艺和工具的可移植性 通过使用包含工艺特定信息，规则和库单元的工艺目录，Open RAM可以做到独立于工艺。需要诸如设计规则检查（DRC）规则和GDS层映射之类的工艺参数，以确保动态生成的设计是DRC clean的。定制设计的库单元（例如存储单元和读出放大器）也放置在此目录中。一个非常简单的设计规则参数文件具有用于构造基本互连和晶体管器件的最重要的设计规则。提供了FreePDK45和SCMOS参考技术。
OpenRAM使用一些自定义设计的库原语作为工艺输入。由于密度非常重要，因此每种工艺都预先设计了以下单元：6T单元，读出放大器，主从触发器，三态门和写驱动器。所有其他单元都是使用可参数化的晶体管和栅极图元即时生成的。
OpenRAM可用于各种技术，因为它创建了这些技术通用的内存设计的基本组件。对于具有特定设计要求的技术，例如特殊的井接触，用户可以在工艺目录中include 回调函数。这样做是为了使主编译器不依赖于特定工艺。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/ee2dced50b5d01f85f986a45b6bdeed9/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-10-23T19:20:40+08:00" />
<meta property="article:modified_time" content="2022-10-23T19:20:40+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">28nm Memory Compiler开发（一）OpenRAM论文阅读</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <h4><a id="Abstract_0"></a>Abstract</h4> 
<p>内存设计的可用性常常抑制了计算机系统的研究。现有的流程设计套件（PDK）经常缺少存储器编译器，而昂贵的商业解决方案仅提供具有不变单元，有限配置和限制性许可证的存储器模型。手动创建内存可能既费时又乏味，而且设计通常不够灵活。本文介绍了OpenRAM，一种开放源代码的内存编译器，它提供了一个平台，用于跨各种技术，大小和配置生成，表征和验证可构造内存设计。它可以进行计算机体系结构，片上系统设计，存储器电路和器件研究以及计算机辅助设计的研究。</p> 
<h4><a id="Introduction_2"></a>Introduction</h4> 
<p>静态随机存取存储器（SRAM）已成为嵌入在所有片上系统（SoC），专用集成电路（ASIC）和微处理器设计中的标准组件。它们的广泛应用导致对电路设计和存储器配置的各种要求。但是，手动设计非常耗时。内存的规则结构很好地导致了自动化，该自动化迅速产生了大小和配置变化，但是要使用多种技术和工具方法来开发这种结构则具有挑战性。此外，存储器设计在总体系统性能和成本中起着重要作用，因此优化很重要。因此，内存编译器是至关重要的工具。</p> 
<p>大多数学术IC的设计方法受到存储器可用性的限制。代工厂和供应商可提供许​​多标准单元工艺设计套件（PDK），但这些PDK通常不随存储器阵列或存储器编译器一起提供。如果内存编译器是免费提供的，则它通常仅支持不可制造的通用处理技术。由于学术经费的限制，商业行业的解决方案通常对研究人员不可行。另外，这些商业解决方案在定制存储器大小和存储器的特定组件方面受到限制。 PDK可能具有请求“黑匣子”存储模型的选项，但它们也不可修改且可用配置有限。这些限制和许可问题使得无法对真实世界的记忆进行比较和试验。</p> 
<p>学术研究人员能够设计自己的自定义存储器，但这可能是一项繁琐且耗时的任务，并且可能不是该研究的预期目的。通常，存储器设计是研究项目所需的最基本的要求，因此，存储器设计通常较差且未进行优化。在存储器研究中，比较存储器性能和密度时通常不考虑外围电路。缺少可定制的编译器，使得研究人员难以对单行或一列存储单元以外的电路和方法进行原型设计和验证。</p> 
<p>OpenRAM项目旨在为内存提供一个开放源代码的内存编译器开发框架。它以通用的45nm技术和可制造的可扩展CMOS（SCMOS）提供参考电路和物理实现，但也已使用一个简单的技术文件将其移植到了多个商业技术节点上。 OpenRAM还包括一种特性分析方法，因此它不仅可以生成电路和布局，还可以生成时序和功率特性结果，而又与特定的商用工具无关。最重要的是，OpenRAM完全可以由用户修改，因为所有源代码都是开源的：</p> 
<p>https://openram.soe.ucsc.edu/</p> 
<p>本文的其余部分安排如下：第2节提供了有关先前内存编译器的背景知识。第3节介绍了OpenRAM中的参考存储器体系结构。第4节专门介绍了OpenRAM存储器编译器的实现和主要功能。在第5节中，显示了针对不同大小和技术的存储器的面积，时序和功耗的分析。最后，本文在第6节中进行了总结。</p> 
<h4><a id="Background_14"></a>Background</h4> 
<p>存储器编译器已被用于电子设计自动化（EDA）设计流程中，以缩短设计时间，远远早于当代的编译器[2，9]。但是，这些编译器通常不可移植，因为它们不过是帮助设计人员的快速脚本。移植到新技术本质上需要重写脚本。但是，在不同技术之间移植设计时，设计生产率的提高导致了对内存阵列编译器的更多研究。</p> 
<p>随着技术进入深亚微米（DSM）时代，由于降低了静态噪声裕量（SNM），增加了制造变异性并增加了泄漏功耗，存储器设计已成为电路设计中最具挑战性的部分之一。由于必须适应不断变化的技术，这极大地增加了内存编译器的复杂性。同时，设计方法从硅编译器转变为需要大型优化库的标准单元布局和布线方法。在这段时间内，工业界开始使用标准单元库和内存编译器的第三方供应商，这些供应商允许其重复使用以摊销开发成本。这些下一代存储器编译器提供了硅验证功能，使设计人员可以专注于他们的新设计，而不是诸如存储器生成之类的耗时任务。</p> 
<p>现代内存编译器已被业界广泛使用，但是内部操作通常是隐藏的。几家著名的公司和代工厂都向其客户提供了内存编译器。这些存储器编译器通常允许客户在签署许可协议后查看前端仿真，时序/功率值和引脚位置。诸如布局之类的后端功能通常直接提供给晶圆厂，并且仅向用户收取许可费。</p> 
<p>具体来说，Global Foundries免费提供前端PDK，但不提供后端详细视图[6]。 Faraday Technologies提供了一个“黑匣子”设计套件，使用户不知道内部存储器设计的详细信息[5]。 Dolphin Technology提供了可以为多种技术创建RAM，ROM和CAM的闭源编译器[4]。这些大多数商业编译器不允许客户更改基本设计，受公司许可的限制，并且通常需要付费。这使得它们实际上不可用，对于许多学术研究项目没有用处。</p> 
<p>除了行业提供的内存编译器之外，各种研究小组还发布了用于生成内存的脚本。但是，这些设计未经硅验证，通常仅由简单的结构组成。例如，FabMem能够创建小型阵列，但高度依赖于Cadence设计工具[15]。脚本不提供任何表征功能，并且不能轻松地与商业布局和路线工具集成。</p> 
<p>Synopsys通用内存编译器（GMC）是学术界最近另一个有希望的解决方案[7]。该软件提供了示例通用库，例如​​Synopsys的32 / 28nm和90nm抽象技术，并且可以为这些技术生成整个SRAM。 GMC生成GDSII布局数据，SPICE网表，Verilog和VHDL模型，时序/电源库以及DRC / LVS验证报告。但是，不建议将GMC用于制造，因为它支持的技术不是真实的。其唯一目的是帮助VLSI课程的学生学习在设计流程中使用内存的知识。</p> 
<p>学术界已经进行了多种尝试来实现不受限制的存储器编译器：微电子研究所的SRAM IP编译器[22]，东南大学电子科学与工程学院的存储器IP编译器[11]和清华大学的低功耗SRAM编译器[21]。这些都是内存编译器的所有方法和设计流程，但没有公开发布。</p> 
<h4><a id="Architecture_28"></a>Architecture</h4> 
<p>OpenRAM SRAM体系结构基于一组带有外围电路和控制逻辑的存储单元，如图1所示。这些进一步细分为八个主要模块：位单元阵列，地址解码器，字线驱动器，列多路复用器，预充电电路，读出放大器，写驱动器和控制逻辑。<br> <img src="https://images2.imgbox.com/d4/83/oXTvszam_o.png" alt="在这里插入图片描述"><br> <strong>位单元阵列</strong>：在OpenRAM的初始版本中，6T单元是默认存储单元，因为它是SRAM器件中最常用的单元。 6T单元与相邻的字线和位线平铺在一起以构成存储阵列。使用多列数据字使位单元阵列的长宽比尽可能为正方形。存储单元是针对每种技术的定制设计的库单元。其他类型的存储单元（例如7T，8T和10T单元）可以用作6T单元的替代方案。</p> 
<p><strong>地址解码器</strong>：地址解码器将行地址位作为输入，并声明适当的字线，以便可以从中读取或写入正确的存储单元。地址解码器位于内存阵列的左侧，并横跨该阵列的垂直长度。可以使用不同类型的解码器，例如附带的动态NAND解码器，但OpenRAM的默认选项是分层CMOS解码器。</p> 
<p><strong>字线驱动器</strong>：字线驱动器作为缓冲区插入到地址解码器和内存阵列之间。字线驱动器的大小取决于存储器阵列的宽度，以便它们可以驱动位选择器阵列上的行选择信号。</p> 
<p><strong>列多路复用器</strong>：列多路复用器是一个可选块，使用低位地址位选择一行中的关联字。列复用器是动态生成的，可以省略，也可以有2或4个输入。较大的列复用器是可能的，但在存储器中并不经常使用。也有用于多级树复用器的选项。</p> 
<p><strong>位线预充电</strong>：该电路在时钟的第一阶段为读操作预充电位线。预充电电路位于存储阵列中每一列的顶部，并均衡位线电压，以便读出放大器可以感测两条位线之间的电压差。</p> 
<p><strong>读出放大器</strong>：差分读出放大器用于在执行读取操作时感测存储单元位线之间的电压差。读出放大器使用位线隔离技术来提高性能。如果不使用列多路复用器，则将读出放大器电路放置在列多路复用器或存储器阵列下方。每个输出位都有一个读出放大器。</p> 
<p><strong>写驱动器</strong>：写驱动器将输入数据信号发送到位线上以进行写操作。写驱动器为三态，因此可以将它们放置在列多路复用器/存储器阵列与读出放大器之间。每个输入数据位都有一个写驱动器。</p> 
<p><strong>控制逻辑</strong>：OpenRAM SRAM体系结构使用系统时钟（clk）合并了标准同步存储器接口。控制逻辑使用外部提供的低电平有效输出使能（OEb），芯片选择（CSb）和写使能（WEb）将多个SRAM组合为更大的结构。在内部，OpenRAM编译器可以具有1、2或4个存储库，以分摊控制逻辑和外围电路的面积/功耗。</p> 
<p>所有输入控制信号均使用主从（MS）触发器（FF）存储，以确保信号在整个时钟周期内均有效。在读取操作期间，如图2（a）所示，在负时钟沿（周期的后半部分）之后可以使用数据。为了避免死循环而降低性能，在OpenRAM时序中使用了零总线周转（ZBT）技术。由于没有等待状态，因此ZBT可以实现更高的内存吞吐量。在ZBT写期间，数据在负时钟边沿之前设置，并在负边沿捕获。图2（b）显示了写操作期间输入信号的时序。</p> 
<p>内部控制信号是使用复制位线（RBL）结构生成的，用于读出放大器使能和输出数据存储[1]的时序。在低于100nm的技术中，由于存在工艺可变性，RBL会在准确的时间打开检测放大器。</p> 
<h4><a id="Implementation_50"></a>Implementation</h4> 
<p>OpenRAM的方法是使用Python编程语言中的面向对象方法实现的。 Python是一种简单但功能强大的语言，易于学习且非常易读。而且，Python使得可移植到大多数操作系统。除DRC / LVS工具外，OpenRAM没有其他依赖项，但是如果工具不可用，则会禁用警告并被禁用。除了系统可移植性之外，OpenRAM还可以跨多种处理技术进行转换。这是通过使用通用例程基于所有技术的通用功能来生成内存来实现的。为了促进用户修改和技术互操作性，OpenRAM提供了45nm FreePDK45的参考实现[17]和使用MOSIS可扩展CMOS（SCMOS）设计规则的可制造选项[13]。 FreePDK45使用现代技术中存在的许多设计规则，但是不可制造，而SCMOS可以使用MOSIS铸造服务来制造设计。 SCMOS不是机密信息，并且包含使用它的实现，但是，它不包含许多高级DSM设计规则。</p> 
<p>OpenRAM也已移植到其他商业技术，但是由于许可问题，这些技术未直接包含在内。 OpenRAM的框架分为“前端”和“后端”两种方法，如图3所示。前端具有编译器和特征描述器。编译器根据用户输入生成SPICE模型及其GDSII布局。表征器调用SPICE仿真器以产生时序和功率结果。后端使用从GDSII布局中提取的spice网表，用于生成带注释的时序和功率模型。</p> 
<h5><a id="_55"></a>基本数据结构</h5> 
<p>OpenRAM中的设计模块是从设计类（design.py）派生的。design类具有名称，SPICE模型（网表）和layout。 SPICE模型和layout都从分层类继承其功能。design类还提供继承的功能，以对任何子设计执行DRC和LVS验证，以进行分层调试。</p> 
<p>design类从spice类（hierarchy spice.py）派生而来，该类具有维护电路层次结构的数据结构。此类维护design实例，它们的引脚，它们的连接以及辅助功能，以维护电路层次结构的结构和连通性。</p> 
<p>design类还派生自布局类（层次结构layout.py）。此类包含布局中子模块的物理实例的列表，以及用于简单对象（例如当前层次结构级别中的形状和标签）的结构。此外，还有一些辅助功能可以维护物理布局结构。 OpenRAM具有集成的自定义GDSII库，用于读取，写入和操作GDSII文件。该库最初称为GdsMill [20]，现已针对OpenRAM进行了修改，调试和扩展。授予了将GdsMill源包含在OpenRAM中的全部权利，但是为了使接口更容易并且可以移植到其他物理布局数据库，OpenRAM实现了抽象GdsMill库的几何包装类（geometry.py）。</p> 
<h5><a id="_61"></a>工艺和工具的可移植性</h5> 
<p>通过使用包含工艺特定信息，规则和库单元的工艺目录，Open RAM可以做到独立于工艺。需要诸如设计规则检查（DRC）规则和GDS层映射之类的工艺参数，以确保动态生成的设计是DRC clean的。定制设计的库单元（例如存储单元和读出放大器）也放置在此目录中。一个非常简单的设计规则参数文件具有用于构造基本互连和晶体管器件的最重要的设计规则。提供了FreePDK45和SCMOS参考技术。</p> 
<p>OpenRAM使用一些自定义设计的库原语作为工艺输入。由于密度非常重要，因此每种工艺都预先设计了以下单元：6T单元，读出放大器，主从触发器，三态门和写驱动器。所有其他单元都是使用可参数化的晶体管和栅极图元即时生成的。</p> 
<p>OpenRAM可用于各种技术，因为它创建了这些技术通用的内存设计的基本组件。对于具有特定设计要求的技术，例如特殊的井接触，用户可以在工艺目录中include 回调函数。这样做是为了使主编译器不依赖于特定工艺。</p> 
<p>OpenRAM具有两个函数提供与DRC和LVS工具的包装器接口。这两个函数使用GDSII布局和SPICE网表文件执行DRC和LVS。由于每个DRC和LVS工具都有不同的输出，因此为每个工具自定义了此例程，以解析DRC / LVS报告并返回错误数，同时还输出调试信息。这些例程使任何DRC / LVS工具都具有灵活性，但是默认实现调用Calibre nmDRC和nmLVS。在OpenRAM中，DRC和LVS都在设计层次结构的所有级别上执行，以增强错误跟踪。可以禁用DRC和LVS以提高运行时间或如果没有工具许可证。</p> 
<h5><a id="_70"></a>类的层次结构</h5> 
<h6><a id="_71"></a>顶层类</h6> 
<p>openram类（openram.py）使用sram类组织执行并实例化单个内存设计。它接受用户提供的参数来生成设计，执行可选的提取，执行特征描述并保存生成的设计文件。</p> 
<p>sram类（sram.py）确定表1中所示的适当内部参数依赖性。它们取决于用户所需的数据字大小，字数和存储体数。它负责实例化控制SRAM组的单个控制逻辑模块。控制逻辑确保在给定的地址范围内只有一个存储体处于活动状态。</p> 
<p>bank类（bank.py）负责大部分非控制内存布局。它实例化1、2或4位单元阵列，并与行和列地址解码器及其预充电，读出放大器和输入/输出数据触发器配合使用。</p> 
<h6><a id="Block_77"></a>Block类</h6> 
<p>存储器设计中的每个其他块都有一个用于其基本单元的类（例如，sense_amplifier.py）和一个负责平铺基本单元的阵列类（例如，sense_amplifier_array.py）。每个类负责物理放置和逻辑上连接自己的子电路，同时将其尺寸和端口位置传递给更高级别的模块</p> 
<h6><a id="_80"></a>底层类</h6> 
<p>OpenRAM提供了参数化的晶体管和逻辑门类，有助于实现技术的可移植性。这些类生成特定于技术的晶体管和简单的逻辑门布局，因此许多模块不依赖库单元。当诸如写驱动器之类的模块需要调整晶体管尺寸以优化性能时，也可以使用该功能。参数化的晶体管（ptx.py）会生成指定类型和尺寸的基本晶体管。参数化晶体管类用于提供几个参数化门，包括pinv.py，nand2.py，nand3.py和nor2.py</p> 
<h5><a id="_83"></a>表征</h5> 
<p>OpenRAM包括一个存储器检定器，该存储器检定器通过SPICE仿真来测量时序和功率特性。表征器有四个主要阶段：生成SPICE激励，运行电路仿真，解析模拟器的输出以及在Liberty（.lib）文件中生成特征。</p> 
<p>该激励以标准SPICE格式编写，并且可以与支持此激励的任何模拟器一起使用。该刺激仅使用存储器的接口（例如，双向数据总线，地址总线和控制信号）来执行“黑匣子”定时测量。</p> 
<p>仿真结果用于得到存储器设计的平均功率，建立/保持时间和时序延迟。由于OpenRAM使用完全同步的输入接口，因此通过分析触发器库单元来获得建立和保持时间。设置时间，保持时间和延迟可通过快速二等分搜索找到。</p> 
<h5><a id="_90"></a>单元测试</h5> 
<p>OpenRAM的最重要的功能可能是使用Python单元测试框架实现的一组全面的回归测试。这些单元测试使用户可以添加功能并轻松验证功能是否损坏。这些测试还适用于多种技术，因此在移植到新技术时可以指导用户。每个模块都有自己的回归测试，并且还针对内存功能，验证库单元，时序特征和技术验证进行了回归测试。</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/7d28800a0cf72a594114e90323375bd3/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">达梦数据库to_date报错：“非法的时间日期类型数据”</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/af496090ed3e03397abdbc4e509b22a3/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">Java：Java中方法的定义和使用</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>