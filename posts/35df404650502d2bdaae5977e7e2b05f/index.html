<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>ES6—数组的扩展操作（扩展运算符） - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="ES6—数组的扩展操作（扩展运算符）" />
<meta property="og:description" content="一：扩展运算符 1：含义
扩展运算符（spread）是三个点（...）。它好比 rest 参数的逆运算，将一个数组转为用逗号分隔的参数序列。扩展运算符内部调用的是数据结构的 Iterator 接口
console.log(1, ...[2, 3, 4], 5)
// 1 2 3 4 5
[...document.querySelectorAll(&#39;div&#39;)]
// [&lt;div&gt;, &lt;div&gt;, &lt;div&gt;]
（1）该运算符主要用于函数调用
function push(array, ...items) {
array.push(...items);
}
上面代码中，array.push(...items)是函数的调用，它们的都使用了扩展运算符。该运算符将一个数组，变为参数序列。
（2）扩展运算符与正常的函数参数可以结合使用
function add(x, y) {
return x &#43; y; }
const numbers = [4, 38];
add(...numbers) // 42
（3）扩展运算符后面还可以放置表达式
const arr = [
...(x &gt; 0 ? [&#39;a&#39;] : []),
&#39;b&#39;,
];
如果扩展运算符后面是一个空数组，则不产生任何效果。
[...[], 1]
// [1]
二：扩展运算符的应用 （1）复制数组 数组是复合的数据类型，直接复制的话，只是复制了指向底层数据结构的指针，而不是克隆一个全新的数组。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/35df404650502d2bdaae5977e7e2b05f/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2018-01-31T16:01:54+08:00" />
<meta property="article:modified_time" content="2018-01-31T16:01:54+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">ES6—数组的扩展操作（扩展运算符）</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <h2><span style="font-size:18px">一：扩展运算符</span></h2> 
<p><span style="font-size:14px">1：含义</span></p> 
<p><span style="font-size:14px"><span style="color:#ff0000">扩展运算符（spread）是三个点（...）</span>。它好比 rest 参数的逆运算，将一个<span style="color:#ff0000">数组转为用逗号分隔的参数序列</span>。<span style="color:rgb(255,0,0); font-size:14px; text-align:justify">扩展运算符内部调用的是数据结构的 Iterator 接口</span></span></p> 
<span style="font-size:14px">console.log(1, ...[2, 3, 4], 5)<br> // 1 2 3 4 5<br> <br> [...document.querySelectorAll('div')]<br> // [&lt;div&gt;, &lt;div&gt;, &lt;div&gt;]<br> <br> <br> </span> 
<p><span style="font-size:14px"><span style="color:#ff0000">（1）该运算符主要用于函数调用</span></span></p> 
<span style="font-size:14px">function push(array, ...items) {<!-- --><br>   array.push(...items);<br> }<br> 上面代码中，array.push(...items)是函数的调用，它们的都使用了扩展运算符。该运算符将一个数组，变为参数序列。<br> <br> <br> </span> 
<p><span style="font-size:14px"><span style="color:#ff0000">（2）扩展运算符与正常的函数参数可以结合使用</span></span></p> 
<p><span style="font-size:14px">function add(x, y) {<!-- --></span></p> 
<span style="font-size:14px"><span style="font-size:14px">  return x + y;</span><br style="font-size:14px"> </span> 
<p><span style="font-size:14px"><span style="font-size:14px">}</span></span></p> 
<p><span style="font-size:14px"><span style="font-size:14px">const numbers = [4, 38];<br> add(...numbers) // 42<br> </span></span></p> 
<p><span style="font-size:14px"><span style="color:#ff0000">（3）扩展运算符后面还可以放置表达式</span></span></p> 
<span style="font-size:14px">const arr = [<br>   ...(x &gt; 0 ? ['a'] : []),<br>   'b',<br> ];<br> 如果扩展运算符后面是一个空数组，则不产生任何效果。<br> [...[], 1]<br> </span> 
<p><span style="font-size:14px">// [1]</span></p> 
<p><br> </p> 
<p></p> 
<h2><span style="font-size:18px">二：扩展运算符的应用</span></h2> 
<span style="font-size:14px"><span style="color:#ff0000">（1）复制数组</span></span> 
<p></p> 
<p><span style="font-size:14px">数组是复合的数据类型，<span style="color:#ff0000">直接复制的话，只是复制了指向底层数据结构的指针，而不是克隆一个全新的数组</span>。<br> const a1 = [1, 2];<br> const a2 = a1;<br> <br> a2[0] = 2;<br> a1 // [2, 2]<br> 上面代码中，a2并不是a1的克隆，而是指向同一份数据的另一个指针。修改a2，会直接导致a1的变化。<br> <br> ES5 只能用变通<span style="color:rgb(79,79,79); font-size:14px; text-align:justify">concat()</span>方法来复制数组。</span><br> <span style="font-size:14px">const a1 = [1, 2];</span><br> <span style="font-size:14px">const a2 = a1.concat();</span><br> <br> <span style="font-size:14px">a2[0] = 2;</span><br> <span style="font-size:14px">a1 // [1, 2]</span><br> <span style="font-size:14px">上面代码中，a1会返回原数组的克隆，再修改a2就不会对a1产生影响。</span><br> <br> <span style="font-size:14px">扩展运算符提供了复制数组的简便写法。</span><br> <span style="font-size:14px">const a1 = [1, 2];</span><br> <span style="font-size:14px">// 写法一</span><br> <span style="font-size:14px">const a2 = [...a1];</span><br> <span style="font-size:14px">// 写法二</span><br> <span style="font-size:14px">const [...a2] = a1;</span><br> <span style="font-size:14px">上面的两种写法，a2都是a1的克隆。</span><br> <br> <br> <span style="color:#ff0000"><span style="font-size:14px">（2）合并数组</span></span></p> 
<p><span style="font-size:14px">扩展运算符提供了数组合并的新写法。</span><br> </p> 
<p><span style="font-size:14px">var arr1 = ['a', 'b'];</span><br> <span style="font-size:14px">var arr2 = ['c'];</span><br> <span style="font-size:14px">var arr3 = ['d', 'e'];</span><br> <span style="font-size:14px">// ES5的合并数组</span><br> <span style="font-size:14px">arr1.concat(arr2, arr3);</span><br> <span style="font-size:14px">// [ 'a', 'b', 'c', 'd', 'e' ]</span><br> <br> <span style="font-size:14px">// ES6的合并数组</span><br> <span style="font-size:14px">[...arr1, ...arr2, ...arr3]</span><br> <span style="font-size:14px">// [ 'a', 'b', 'c', 'd', 'e' ]</span><br> <br> <br> <span style="font-size:14px; color:#ff0000">（3）与解构赋值结合</span></p> 
<p><span style="font-size:14px; color:#ff0000">扩展运算符可以与解构赋值结合起来，用于生成数组。</span></p> 
<p><span style="font-size:14px">const [first, ...rest] = [1, 2, 3, 4, 5];</span><br> <span style="font-size:14px">first // 1</span><br> <span style="font-size:14px">rest  // [2, 3, 4, 5]</span><br> <br> <span style="font-size:14px">const [first, ...rest] = [];</span><br> <span style="font-size:14px">first // undefined</span><br> <span style="font-size:14px">rest  // []</span><br> <br> <span style="font-size:14px; color:#ff0000">注：如果将扩展运算符用于数组赋值，只能放在参数的最后一位，否则会报错。</span><br> <span style="font-size:14px">const [...butLast, last] = [1, 2, 3, 4, 5];</span><br> <span style="font-size:14px">// 报错</span><br> <br> <br> <span style="font-size:14px; color:#ff0000">（4）字符串</span></p> 
<p><span style="font-size:14px"><span style="color:#ff0000">扩展运算符还可以将字符串转为真正的数组</span></span><br> <br> <span style="font-size:14px">[...'hello']</span><br> <span style="font-size:14px">// [ "h", "e", "l", "l", "o" ]</span><br> <span style="font-size:14px">上面的写法，有一个重要的好处，那就是能够正确识别四个字节的 Unicode 字符。</span><br> <br> <br> <span style="color:#ff0000"><span style="font-size:14px">（5）实现了 Iterator 接口的对象</span></span></p> 
<p><span style="color:#ff0000"><span style="font-size:14px">任何 Iterator 接口的对象，都可以用扩展运算符转为真正的数组</span></span></p> 
<p><span style="font-size:14px">let nodeList = document.querySelectorAll('div');</span><br> <span style="font-size:14px">let array = [...nodeList];</span><br> <span style="font-size:14px">上面代码中，querySelectorAll方法返回的是一个nodeList对象。它不是数组，而是一个类似数组的对象。这时，扩展运算符可以将其转为真正的数组，原因就在于NodeList对象实现了 Iterator 。</span><br> <br> <span style="font-size:14px">对于那些没有部署 Iterator 接口的类似数组的对象，扩展运算符就无法将其转为真正的数组。</span><br> <span style="font-size:14px">let arrayLike = {<!-- --></span><br> <span style="font-size:14px">  '0': 'a',</span><br> <span style="font-size:14px">  '1': 'b',</span><br> <span style="font-size:14px">  '2': 'c',</span><br> <span style="font-size:14px">  length: 3</span><br> <span style="font-size:14px">};</span><br> <span style="font-size:14px">// TypeError: Cannot spread non-iterable object.</span><br> <span style="font-size:14px">let arr = [...arrayLike];</span><br> <span style="font-size:14px">上面代码中，<span style="color:#ff0000">arrayLike是一个类似数组的对象，但是没有部署 Iterator 接口，扩展运算符就会报错。这时，可以改为使用Array.from方法将arrayLike转为真正的数组</span>。</span><br> <br> <br> <span style="font-size:14px; color:#ff0000">（6）Map 和 Set 结构，Generator 函数</span></p> 
<p><span style="font-size:14px"><span style="color:#ff0000">扩展运算符内部调用的是数据结构的 Iterator 接口</span>，因此只要具有 Iterator 接口的对象，都可以使用扩展运算符，比如 Map 结构。</span><br> <span style="font-size:14px">let map = new Map([</span><br> <span style="font-size:14px">  [1, 'one'],</span><br> <span style="font-size:14px">  [2, 'two'],</span><br> <span style="font-size:14px">  [3, 'three'],</span><br> <span style="font-size:14px">]);</span><br> <span style="font-size:14px">let arr = [...map.keys()]; // [1, 2, 3]</span></p> 
<p><span style="font-size:14px">Generator 函数运行后，返回一个遍历器对象，因此也可以使用扩展运算符。</span><br> <span style="font-size:14px">const go = function*(){<!-- --></span><br> <span style="font-size:14px">  yield 1;</span><br> <span style="font-size:14px">  yield 2;</span><br> <span style="font-size:14px">  yield 3;</span><br> <span style="font-size:14px">};</span><br> <span style="font-size:14px">[...go()] // [1, 2, 3]</span><br> <span style="font-size:14px">上面代码中，变量go是一个 Generator 函数，执行后返回的是一个遍历器对象，对这个遍历器对象执行扩展运算符，就会将内部遍历得到的值，转为一个数组。</span><br> <br> <br> </p> 
<p><span style="font-size:14px; color:#ff0000">（7）替代函数的 apply 方法</span></p> 
<p><span style="font-size:14px"><span style="color:#ff0000">由于扩展运算符可以展开数组，所以不再需要apply方法，将数组转为函数的参数</span></span></p> 
<p><span style="font-size:14px">// ES5 的写法<br> function f(x, y, z) {<!-- --><br>   // ...<br> }<br> var args = [0, 1, 2];<br> f.apply(null, args);<br> <br> // ES6的写法<br> function f(x, y, z) {<!-- --><br>   // ...<br> }<br> let args = [0, 1, 2];<br> f(...args);</span></p> 
<p><span style="font-size:14px">另一个例子是通过push函数，将一个数组添加到另一个数组的尾部。<br> // ES5的 写法<br> var arr1 = [0, 1, 2];<br> var arr2 = [3, 4, 5];<br> Array.prototype.push.apply(arr1, arr2);<br> <br> // ES6 的写法<br> let arr1 = [0, 1, 2];<br> let arr2 = [3, 4, 5];<br> arr1.push(...arr2);<br> 上面代码的 ES5 写法中，push方法的参数不能是数组，所以只好通过apply方法变通使用push方法。有了扩展运算符，就可以直接将数组传入push方法。<br> <br> <br> </span></p> 
<p></p> 
<h2><span style="font-size:18px">三：Array.from()</span></h2> 
<span style="color:#ff0000">Array.from方法用于将两类对象转为真正的数组：</span> 
<p></p> 
<p><span style="color:#ff0000">1：类似数组的对象（array-like object）；<span style="text-align:justify">所谓类似数组的对象，本质特征只有一点，即必须有length属性。</span></span></p> 
<p><span style="color:#ff0000">2：可遍历（iterable）的对象（包括 ES6 新增的数据结构 Set 和 Map）。</span></p> 
<p><span style="color:#ff0000">注：<span style="color:rgb(255,0,0); text-align:justify">只有当参数个数不少于 2 个时，Array()才会返回由参数组成的新数组。</span><span style="color:rgb(255,0,0); text-align:justify">参数个数只有一个时，实际上是指定数组的长度。</span><br> </span><br> （1）一个类似数组的对象，Array.from将它转为真正的数组。<br> let arrayLike = {<!-- --><br>     '0': 'a',<br>     '1': 'b',<br>     '2': 'c',<br>     length: 3<br> };<br> // ES5的写法<br> var arr1 = [].slice.call(arrayLike); // ['a', 'b', 'c']<br> <br> // ES6的写法<br> let arr2 = Array.from(arrayLike); // ['a', 'b', 'c']</p> 
<p><br> <span style="color:#ff0000">（2）常见的类似数组的对象是 DOM 操作返回的 NodeList 集合，以及函数内部的arguments对象。Array.from都可以将它们转为真正的数组。<br> </span>// NodeList对象<br> let ps = document.querySelectorAll('p');<br> Array.from(ps).filter(p =&gt; {<!-- --><br>   return p.textContent.length &gt; 100;<br> });<br> <br> // arguments对象<br> function foo() {<!-- --><br>   var args = Array.from(arguments);<br>   // ...<br> }<br> <br> <span style="color:#ff0000">（3）只要是部署了 Iterator 接口的数据结构，Array.from都能将其转为数组。<br> </span>Array.from('hello')<br> // ['h', 'e', 'l', 'l', 'o']<br> <br> let namesSet = new Set(['a', 'b'])<br> Array.from(namesSet) // ['a', 'b']<br> 上面代码中，字符串和 Set 结构都具有 Iterator 接口，因此可以被Array.from转为真正的数组。<br> <span style="font-size:14px"><br> <br> Array.from({ length: 3 });<br> // [ undefined, undefined, undefined ]<br> 上面代码中，Array.from返回了一个具有三个成员的数组，每个位置的值都是undefined。扩展运算符转换不了这个对象。<span style="color:#ff0000">参数个数只有一个时，实际上是指定数组的长度。</span></span></p> 
<p><span style="font-size:14px"><br> <br> <span style="color:#ff0000">（4）Array.from还可以接受第二个参数，作用类似于数组的map方法，用来对每个元素进行处理，将处理后的值放入返回的数组。</span><br> Array.from(arrayLike, x =&gt; x * x);<br> // 等同于<br> Array.from(arrayLike).map(x =&gt; x * x);<br> <br> Array.from([1, 2, 3], (x) =&gt; x * x)<br> // [1, 4, 9]<br> <br> </span><br> （5）如果map函数里面用到了this关键字，还可以传入Array.from的第三个参数，用来绑定this。<br> <br> <br> <span style="color:#ff0000">（6）将字符串转为数组，然后返回字符串的长度</span>。因为它能正确处理各种 Unicode 字符，可以避免 JavaScript 将大于\uFFFF的 Unicode 字符，算作两个字符的 bug。<br> function countSymbols(string) {<!-- --><br>   return Array.from(string).length;<br> }<br> </p> 
<p><br> </p> 
<p></p> 
<h2><span style="font-size:18px">四：Array.of()</span></h2> 
<span style="color:#ff0000">Array.of方法用于将一组值，转换为数组。<br> </span> 
<br> Array.of(3, 11, 8) // [3,11,8] 
<br> Array.of(3) // [3] 
<br> Array.of(3).length // 1 
<br> 这个方法的主要目的，是弥补数组构造函数Array()的不足。因为参数个数的不同，会导致Array()的行为有差异。 
<br> 
<br> 
<br> Array() // [] 
<br> Array(3) // [, , ,] 
<br> Array(3, 11, 8) // [3, 11, 8] 
<br> 上面代码中，Array方法没有参数、一个参数、三个参数时，返回结果都不一样。 
<span style="color:#ff0000">只有当参数个数不少于 2 个时，Array()才会返回由参数组成的新数组。参数个数只有一个时，实际上是指定数组的长度。</span> 
<br> 
<br> Array.of方法可以用下面的代码模拟实现。 
<br> function ArrayOf(){ 
<br>   return [].slice.call(arguments); 
<br> } 
<br> 
<p></p> 
<p><br> </p> 
<p><br> </p> 
<h2><span style="font-size:18px">五：数组方法</span></h2> 
<p></p> 
<h3><span style="font-size:14px">1：copyWithin()</span></h3> 数组实例的copyWithin方法，在当前数组内部，将指定位置的成员复制到其他位置（会覆盖原有成员），然后返回当前数组。也就是说，使用这个方法，会修改当前数组。 
<br> Array.prototype.copyWithin(target, start = 0, end = this.length) 
<br> 它接受三个参数。 
<br> target（必需）：从该位置开始替换数据。如果为负值，表示倒数。 
<br> start（可选）：从该位置开始读取数据，默认为 0。如果为负值，表示倒数。 
<br> end（可选）：到该位置前停止读取数据，默认等于数组长度。如果为负值，表示倒数。 
<br> 这三个参数都应该是数值，如果不是，会自动转为数值。 
<br> 
<br> // -2相当于3号位，-1相当于4号位 
<br> [1, 2, 3, 4, 5].copyWithin(0, -2, -1) 
<br> // [4, 2, 3, 4, 5] 
<br> 
<br> // 对于没有部署 TypedArray 的 copyWithin 方法的平台 
<br> // 需要采用下面的写法 
<br> [].copyWithin.call(new Int32Array([1, 2, 3, 4, 5]), 0, 3, 4); 
<br> // Int32Array [4, 2, 3, 4, 5] 
<br> 
<p></p> 
<p><br> </p> 
<h3><span style="font-size:14px">（2） find() 和 findIndex()</span></h3> 1： 
<span style="color:#ff0000">数组实例的find方法，用于找出第一个符合条件的数组成员</span>。它的参数是一个回调函数，所有数组成员依次执行该回调函数，直到找出第一个返回值为true的成员，然后返回该成员。如果没有符合条件的成员，则返回undefined。 
<br> 
<br> [1, 5, 10, 15].find(function(value, index, arr) { 
<br>   return value &gt; 9; 
<br> }) // 10 
<br> 上面代码中，f 
<span style="color:#ff0000">ind方法的回调函数可以接受三个参数，依次为当前的值、当前的位置和原数组。</span> 
<br> 
<br> 2：数组实例的findIndex方法的用法与find方法非常类似， 
<span style="color:#ff0000">返回第一个符合条件的数组成员的位置</span>，如果所有成员都不符合条件，则返回-1。 
<br> 
<br> [1, 5, 10, 15].findIndex(function(value, index, arr) { 
<br>   return value &gt; 9; 
<br> }) // 2 
<br> 这两个方法都可以接受第二个参数，用来绑定回调函数的this对象。 
<br> function f(v){ 
<br>   return v &gt; this.age; 
<br> } 
<br> 
<br> 另外，这两个方法都可以发现NaN，弥补了数组的indexOf方法的不足。 
<br> [NaN].indexOf(NaN) 
<br> // -1 
<br> [NaN].findIndex(y =&gt; Object.is(NaN, y)) 
<br> // 0 
<p></p> 
<p><br> </p> 
<p></p> 
<h3><span style="font-size:14px">(3) fill()</span></h3> 1：fill方法使用给定值，填充一个数组。 
<br> new Array(3).fill(7) 
<br> // [7, 7, 7] 
<br> 上面代码表明，fill方法用于空数组的初始化非常方便。数组中已有的元素，会被全部抹去。 
<br> 
<br> 2： 
<span style="color:#ff0000">fill方法还可以接受第二个和第三个参数，用于指定填充的起始位置和结束位置</span> 
<br> ['a', 'b', 'c'].fill(7, 1, 2) 
<br> // ['a', 7, 'c'] 
<br> 上面代码表示，fill方法从 1 号位开始，向原数组填充 7，到 2 号位之前结束。 
<br> 
<br> 
<span style="color:#ff0000">注意，如果填充的类型为对象，那么被赋值的是同一个内存地址的对象，而不是深拷贝对象。</span> 
<br> let arr = new Array(3).fill({name: "Mike"}); 
<br> arr[0].name = "Ben"; 
<br> arr 
<br> // [{name: "Ben"}, {name: "Ben"}, {name: "Ben"}] 
<br> 
<br> let arr = new Array(3).fill([]); 
<br> arr[0].push(5); 
<br> arr 
<br> // [[5], [5], [5]] 
<br> 
<p></p> 
<p><br> </p> 
<p></p> 
<h3><span style="font-size:14px">四：entries()，keys() 和 values()</span></h3> ES6 提供三个新的方法——entries()，keys()和values()——用于遍历数组。它们都返回一个遍历器对象，可以用for...of循环进行遍历，唯一的区别是keys()是对键名的遍历、values()是对键值的遍历，entries()是对键值对的遍历。 
<br> 
<br> for (let index of ['a', 'b'].keys()) { 
<br>   console.log(index); 
<br> } 
<br> // 0 
<br> // 1 
<br> 
<br> for (let elem of ['a', 'b'].values()) { 
<br>   console.log(elem); 
<br> } 
<br> // 'a' 
<br> // 'b' 
<br> 
<br> for (let [index, elem] of ['a', 'b'].entries()) { 
<br>   console.log(index, elem); 
<br> } 
<br> // 0 "a" 
<br> // 1 "b" 
<br> 
<br> 
<br> 
<br> 
<h3><span style="font-size:14px">五： includes()</span></h3> 1：Array.prototype.includes方法返回一个布尔值，表示某个数组是否包含给定的值，与字符串的includes方法类似。ES2016 引入了该方法。 
<br> 
<br> [1, 2, 3].includes(4)     // false 
<br> [1, 2, NaN].includes(NaN) // true 
<p></p> 
<p><br> </p> 
<p>2：该方法的第二个参数表示搜索的起始位置，默认为0。如果第二个参数为负数，则表示倒数的位置，如果这时它大于数组长度（比如第二个参数为-4，但数组长度为3），则会重置为从0开始。<br> [1, 2, 3].includes(3, 3);  // false<br> [1, 2, 3].includes(3, -1); // true</p> 
<p><br> 没有该方法之前，我们通常使用数组的indexOf方法，检查是否包含某个值。<br> if (arr.indexOf(el) !== -1) {<!-- --><br>   // ...<br> }<br> indexOf方法有两个缺点，一是不够语义化，它的含义是找到参数值的第一个出现位置，所以要去比较是否不等于-1，表达起来不够直观。二是，它内部使用严格相等运算符（===）进行判断，这会导致对NaN的误判。<br> <br> <br> 3：下面代码用来检查当前环境是否支持该方法，如果不支持，部署一个简易的替代版本。<br> :<br> const contains = (() =&gt;<br>   Array.prototype.includes<br>     ? (arr, value) =&gt; arr.includes(value)<br>     : (arr, value) =&gt; arr.some(el =&gt; el === value)<br> )();<br> contains(['foo', 'bar'], 'baz'); // =&gt; false</p> 
<p><br> <span style="color:#ff0000">另外，Map 和 Set 数据结构有一个has方法，需要注意与includes区分</span>。<br> Map 结构的has方法，是用来查找键名的，比如Map.prototype.has(key)、WeakMap.prototype.has(key)、Reflect.has(target, propertyKey)。<br> Set 结构的has方法，是用来查找值的，比如Set.prototype.has(value)、WeakSet.prototype.has(value)。<br> </p> 
<p><br> </p> 
<p></p> 
<h3><span style="font-size:14px">六：数组的空位</span></h3> 
<span style="color:#ff0000">数组的空位指，数组的某一个位置没有任何值</span>。比如，Array构造函数返回的数组都是空位。 
<br> 
<br> Array(3) // [, , ,] 
<br> 上面代码中，Array(3)返回一个具有 3 个空位的数组。 
<br> 
<br> 
<br> 
<span style="color:#ff0000">注意，空位不是undefined，一个位置的值等于undefined，依然是有值的。空位是没有任何值，in运算符可以说明这一点。</span> 
<br> 0 in [undefined, undefined, undefined] // true 
<br> 0 in [, , ,] // false 
<br> 上面代码说明，第一个数组的 0 号位置是有值的，第二个数组的 0 号位置没有值。 
<br> 
<br> 
<br> ES5 对空位的处理，已经很不一致了，大多数情况下会忽略空位。 
<p></p> 
<p>1：forEach(), filter(), reduce(), every() 和some()都会跳过空位。</p> 
<p>2：map()会跳过空位，但会保留这个值</p> 
<p>3：join()和toString()会将空位视为undefined，而undefined和null会被处理成空字符串。</p> 
<p>4：Array.from方法会将数组的空位，转为undefined，也就是说，这个方法不会忽略空位。<br> <br> 5：for...of循环也会遍历空位。<br> let arr = [, ,];<br> for (let i of arr) {<!-- --><br>   console.log(1);<br> }<br> // 1<br> // 1<br> 上面代码中，数组arr有两个空位，for...of并没有忽略它们。如果改成map方法遍历，空位是会跳过的。<br> <br> 6：entries()、keys()、values()、find()和findIndex()会将空位处理成undefined。<br> <br> 由于空位的处理规则非常不统一，所以建议避免出现空位。<br> </p> 
<p><br> </p> 
<p><br> </p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/8785ee82a57475bb323450bc13bc45cb/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">.dSYM文件的生成</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/d7955a6ae270f8b7cf881cfb4969ada2/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">react native 各种居中</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>