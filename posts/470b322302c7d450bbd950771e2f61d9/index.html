<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>百度地图API多个点聚合时，标注添加的标签label地图刷新就丢失的问题解决 - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="百度地图API多个点聚合时，标注添加的标签label地图刷新就丢失的问题解决" />
<meta property="og:description" content="当将自定义的Marker（含有Label）通过MarkerClusterer 管理的时候，当地图发生任何移动、缩放 的时候，Marker 的Label 就会自动消失。 这个问题主要是由于百度的点聚合API&lt;script type=&#34;text/javascript&#34; src=&#34;http://api.map.baidu.com/library/MarkerClusterer/1.2/src/MarkerClusterer_min.js&#34;&gt;&lt;/script&gt; 的bug造成的。其实诱发这个问题的原因是在于API代码中的map.removeOverlay(marker)，在这句话执行的时候，会自动将marker.label =null； 我们可以在Clusterer 处理的所有地方都先读出来Label，等remove完毕之后再将这个Maker.setLabel 过去就ok了 tmplabel = this._markers[i].getLabel(); this._markers[i].getMap() &amp;&amp; this._map.removeOverlay(this._markers[i]); this._markers[i].setLabel(tmplabel); 修改过的MakerClusterer.js代码： /**
* @fileoverview MarkerClusterer标记聚合器用来解决加载大量点要素到地图上产生覆盖现象的问题，并提高性能。
* 主入口类是&lt;a href=&#34;symbols/BMapLib.MarkerClusterer.html&#34;&gt;MarkerClusterer&lt;/a&gt;，
* 基于Baidu Map API 1.2。
*
* @author Baidu Map Api Group * @version 1.2
*/
/** * @namespace BMap的所有library类均放在BMapLib命名空间下
*/
var BMapLib = window.BMapLib = BMapLib || {};
(function(){
/**
* 获取一个扩展的视图范围，把上下左右都扩大一样的像素值。
* @param {Map} map BMap.Map的实例化对象
* @param {BMap.Bounds} bounds BMap." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/470b322302c7d450bbd950771e2f61d9/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2014-10-21T11:26:11+08:00" />
<meta property="article:modified_time" content="2014-10-21T11:26:11+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">百度地图API多个点聚合时，标注添加的标签label地图刷新就丢失的问题解决</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    当将自定义的Marker（含有Label）通过MarkerClusterer 管理的时候，当地图发生任何移动、缩放 的时候，Marker 的Label 就会自动消失。 
<br> 
<br>这个问题主要是由于百度的点聚合API&lt;script type="text/javascript" src="http://api.map.baidu.com/library/MarkerClusterer/1.2/src/MarkerClusterer_min.js"&gt;&lt;/script&gt; 
<br> 
<br>的bug造成的。其实诱发这个问题的原因是在于API代码中的map.removeOverlay(marker)，在这句话执行的时候，会自动将marker.label =null； 
<br> 
<br>我们可以在Clusterer 处理的所有地方都先读出来Label，等remove完毕之后再将这个Maker.setLabel 过去就ok了 
<br> 
<br>tmplabel = this._markers[i].getLabel(); 
<br> 
<br>this._markers[i].getMap() &amp;&amp; this._map.removeOverlay(this._markers[i]); 
<br> 
<br>this._markers[i].setLabel(tmplabel); 
<br> 
<br> 
<br> 
<br>修改过的MakerClusterer.js代码： 
<br> 
<br> 
<pre><code class="language-java"><br>/**<br><br> * @fileoverview MarkerClusterer标记聚合器用来解决加载大量点要素到地图上产生覆盖现象的问题，并提高性能。<br><br> * 主入口类是&lt;a href="symbols/BMapLib.MarkerClusterer.html"&gt;MarkerClusterer&lt;/a&gt;，<br><br> * 基于Baidu Map API 1.2。<br><br> *<br><br> * @author Baidu Map Api Group <br><br> * @version 1.2<br><br> */<br><br><br><br><br><br>/** <br><br> * @namespace BMap的所有library类均放在BMapLib命名空间下<br><br> */<br><br>var BMapLib = window.BMapLib = BMapLib || {};<br><br>(function(){<!-- --><br><br><br><br>    /**<br><br>     * 获取一个扩展的视图范围，把上下左右都扩大一样的像素值。<br><br>     * @param {Map} map BMap.Map的实例化对象<br><br>     * @param {BMap.Bounds} bounds BMap.Bounds的实例化对象<br><br>     * @param {Number} gridSize 要扩大的像素值<br><br>     *<br><br>     * @return {BMap.Bounds} 返回扩大后的视图范围。<br><br>     */<br><br>    var getExtendedBounds = function(map, bounds, gridSize){<!-- --><br><br>        bounds = cutBoundsInRange(bounds);<br><br>        var pixelNE = map.pointToPixel(bounds.getNorthEast());<br><br>        var pixelSW = map.pointToPixel(bounds.getSouthWest()); <br><br>        pixelNE.x += gridSize;<br><br>        pixelNE.y -= gridSize;<br><br>        pixelSW.x -= gridSize;<br><br>        pixelSW.y += gridSize;<br><br>        var newNE = map.pixelToPoint(pixelNE);<br><br>        var newSW = map.pixelToPoint(pixelSW);<br><br>        return new BMap.Bounds(newSW, newNE);<br><br>    };<br><br><br><br>    /**<br><br>     * 按照百度地图支持的世界范围对bounds进行边界处理<br><br>     * @param {BMap.Bounds} bounds BMap.Bounds的实例化对象<br><br>     *<br><br>     * @return {BMap.Bounds} 返回不越界的视图范围<br><br>     */<br><br>    var cutBoundsInRange = function (bounds) {<!-- --><br><br>        var maxX = getRange(bounds.getNorthEast().lng, -180, 180);<br><br>        var minX = getRange(bounds.getSouthWest().lng, -180, 180);<br><br>        var maxY = getRange(bounds.getNorthEast().lat, -74, 74);<br><br>        var minY = getRange(bounds.getSouthWest().lat, -74, 74);<br><br>        return new BMap.Bounds(new BMap.Point(minX, minY), new BMap.Point(maxX, maxY));<br><br>    }; <br><br><br><br>    /**<br><br>     * 对单个值进行边界处理。<br><br>     * @param {Number} i 要处理的数值<br><br>     * @param {Number} min 下边界值<br><br>     * @param {Number} max 上边界值<br><br>     * <br><br>     * @return {Number} 返回不越界的数值<br><br>     */<br><br>    var getRange = function (i, mix, max) {<!-- --><br><br>        mix &amp;&amp; (i = Math.max(i, mix));<br><br>        max &amp;&amp; (i = Math.min(i, max));<br><br>        return i;<br><br>    };<br><br><br><br>    /**<br><br>     * 判断给定的对象是否为数组<br><br>     * @param {Object} source 要测试的对象<br><br>     *<br><br>     * @return {Boolean} 如果是数组返回true，否则返回false<br><br>     */<br><br>    var isArray = function (source) {<!-- --><br><br>        return '[object Array]' === Object.prototype.toString.call(source);<br><br>    };<br><br><br><br>    /**<br><br>     * 返回item在source中的索引位置<br><br>     * @param {Object} item 要测试的对象<br><br>     * @param {Array} source 数组<br><br>     *<br><br>     * @return {Number} 如果在数组内，返回索引，否则返回-1<br><br>     */<br><br>    var indexOf = function(item, source){<!-- --><br><br>        var index = -1;<br><br>        if(isArray(source)){<!-- --><br><br>            if (source.indexOf) {<!-- --><br><br>                index = source.indexOf(item);<br><br>            } else {<!-- --><br><br>                for (var i = 0, m; m = source[i]; i++) {<!-- --><br><br>                    if (m === item) {<!-- --><br><br>                        index = i;<br><br>                        break;<br><br>                    }<br><br>                }<br><br>            }<br><br>        }        <br><br>        return index;<br><br>    };<br><br><br><br>    /**<br><br>     *@exports MarkerClusterer as BMapLib.MarkerClusterer<br><br>     */<br><br>    var MarkerClusterer =  <br><br>        /**<br><br>         * MarkerClusterer<br><br>         * @class 用来解决加载大量点要素到地图上产生覆盖现象的问题，并提高性能<br><br>         * @constructor<br><br>         * @param {Map} map 地图的一个实例。<br><br>         * @param {Json Object} options 可选参数，可选项包括：&lt;br /&gt;<br><br>         *    markers {Array&lt;Marker&gt;} 要聚合的标记数组&lt;br /&gt;<br><br>         *    girdSize {Number} 聚合计算时网格的像素大小，默认60&lt;br /&gt;<br><br>         *    maxZoom {Number} 最大的聚合级别，大于该级别就不进行相应的聚合&lt;br /&gt;<br><br>         *    minClusterSize {Number} 最小的聚合数量，小于该数量的不能成为一个聚合，默认为2&lt;br /&gt;<br><br>         *    isAverangeCenter {Boolean} 聚合点的落脚位置是否是所有聚合在内点的平均值，默认为否，落脚在聚合内的第一个点&lt;br /&gt;<br><br>         *    styles {Array&lt;IconStyle&gt;} 自定义聚合后的图标风格，请参考TextIconOverlay类&lt;br /&gt;<br><br>         */<br><br>        BMapLib.MarkerClusterer = function(map, options){<!-- --><br><br>            if (!map){<!-- --><br><br>                return;<br><br>            }<br><br>            this._map = map;<br><br>            this._markers = [];<br><br>            this._clusters = [];<br><br><br><br>            var opts = options || {};<br><br>            this._gridSize = opts["gridSize"] || 60;<br><br>            this._maxZoom = opts["maxZoom"] || 18;<br><br>            this._minClusterSize = opts["minClusterSize"] || 2;           <br><br>            this._isAverageCenter = false;<br><br>            if (opts['isAverageCenter'] != undefined) {<!-- --><br><br>                this._isAverageCenter = opts['isAverageCenter'];<br><br>            }    <br><br>            this._styles = opts["styles"] || [];<br><br><br><br>            var that = this;<br><br>            this._map.addEventListener("zoomend",function(){<!-- --><br><br>                that._redraw();     <br><br>            });<br><br><br><br>            this._map.addEventListener("moveend",function(){<!-- --><br><br>                 that._redraw();     <br><br>            });<br><br><br><br><br><br><br><br><br><br>            var mkrs = opts["markers"];<br><br>            isArray(mkrs) &amp;&amp; this.addMarkers(mkrs);<br><br>        };<br><br><br><br>    /**<br><br>     * 添加要聚合的标记数组。<br><br>     * @param {Array&lt;Marker&gt;} markers 要聚合的标记数组<br><br>     *<br><br>     * @return 无返回值。<br><br>     */<br><br>    MarkerClusterer.prototype.addMarkers = function(markers){<!-- --><br><br>        for(var i = 0, len = markers.length; i &lt;len ; i++){<!-- --><br><br>            this._pushMarkerTo(markers[i]);<br><br>        }<br><br>        this._createClusters();   <br><br>    };<br><br><br><br>    /**<br><br>     * 把一个标记添加到要聚合的标记数组中<br><br>     * @param {BMap.Marker} marker 要添加的标记<br><br>     *<br><br>     * @return 无返回值。<br><br>     */<br><br>    MarkerClusterer.prototype._pushMarkerTo = function(marker){<!-- --><br><br>        var index = indexOf(marker, this._markers);<br><br>        if(index === -1){<!-- --><br><br>            marker.isInCluster = false;<br><br>            this._markers.push(marker);//Marker拖放后enableDragging不做变化，忽略<br><br>        }<br><br>    };<br><br><br><br>    /**<br><br>     * 添加一个聚合的标记。<br><br>     * @param {BMap.Marker} marker 要聚合的单个标记。<br><br>     * @return 无返回值。<br><br>     */<br><br>    MarkerClusterer.prototype.addMarker = function(marker) {<!-- --><br><br>        this._pushMarkerTo(marker);<br><br>        this._createClusters();<br><br>    };<br><br><br><br>    /**<br><br>     * 根据所给定的标记，创建聚合点<br><br>     * @return 无返回值<br><br>     */<br><br>    MarkerClusterer.prototype._createClusters = function(){<!-- --><br><br>        var mapBounds = this._map.getBounds();<br><br>        var extendedBounds = getExtendedBounds(this._map, mapBounds, this._gridSize);<br><br>        for(var i = 0, marker; marker = this._markers[i]; i++){<!-- --><br><br>            if(!marker.isInCluster &amp;&amp; extendedBounds.containsPoint(marker.getPosition()) ){ <br><br>                this._addToClosestCluster(marker);<br><br>            }<br><br>        }   <br><br>    };<br><br><br><br>    /**<br><br>     * 根据标记的位置，把它添加到最近的聚合中<br><br>     * @param {BMap.Marker} marker 要进行聚合的单个标记<br><br>     *<br><br>     * @return 无返回值。<br><br>     */<br><br>    MarkerClusterer.prototype._addToClosestCluster = function (marker){<!-- --><br><br>        var distance = 4000000;<br><br>        var clusterToAddTo = null;<br><br>        var position = marker.getPosition();<br><br>        for(var i = 0, cluster; cluster = this._clusters[i]; i++){<!-- --><br><br>            var center = cluster.getCenter();<br><br>            if(center){<!-- --><br><br>                var d = this._map.getDistance(center, marker.getPosition());<br><br>                if(d &lt; distance){<!-- --><br><br>                    distance = d;<br><br>                    clusterToAddTo = cluster;<br><br>                }<br><br>            }<br><br>        }<br><br><br><br>        if (clusterToAddTo &amp;&amp; clusterToAddTo.isMarkerInClusterBounds(marker)){<!-- --><br><br>            clusterToAddTo.addMarker(marker);<br><br>        } else {<!-- --><br><br>            var cluster = new Cluster(this);<br><br>            cluster.addMarker(marker);            <br><br>            this._clusters.push(cluster);<br><br>        }    <br><br>    };<br><br><br><br>    /**<br><br>     * 清除上一次的聚合的结果<br><br>     * @return 无返回值。<br><br>     */<br><br>    MarkerClusterer.prototype._clearLastClusters = function(){<!-- --><br><br>        for(var i = 0, cluster; cluster = this._clusters[i]; i++){            <br><br>            cluster.remove();<br><br>        }<br><br>        this._clusters = [];//置空Cluster数组<br><br>        this._removeMarkersFromCluster();//把Marker的cluster标记设为false<br><br>    };<br><br><br><br>    /**<br><br>     * 清除某个聚合中的所有标记<br><br>     * @return 无返回值<br><br>     */<br><br>    MarkerClusterer.prototype._removeMarkersFromCluster = function(){<!-- --><br><br>        for(var i = 0, marker; marker = this._markers[i]; i++){<!-- --><br><br>            marker.isInCluster = false;<br><br>        }<br><br>    };<br><br><br><br>    /**<br><br>     * 把所有的标记从地图上清除<br><br>     * @return 无返回值<br><br>     */<br><br>    MarkerClusterer.prototype._removeMarkersFromMap = function(){<!-- --><br><br>        for(var i = 0, marker; marker = this._markers[i]; i++){<!-- --><br><br>            marker.isInCluster = false;<br><br>            tmplabel = marker.getLabel();<br><br>            this._map.removeOverlay(marker);       <br><br>            marker.setLabel(tmplabel);<br><br>        }<br><br>    };<br><br><br><br>    /**<br><br>     * 删除单个标记<br><br>     * @param {BMap.Marker} marker 需要被删除的marker<br><br>     *<br><br>     * @return {Boolean} 删除成功返回true，否则返回false<br><br>     */<br><br>    MarkerClusterer.prototype._removeMarker = function(marker) {<!-- --><br><br>        var index = indexOf(marker, this._markers);<br><br>        if (index === -1) {<!-- --><br><br>            return false;<br><br>        }<br><br>        tmplabel = marker.getLabel();<br><br>        this._map.removeOverlay(marker);<br><br>        marker.setLabel(tmplabel);<br><br>        this._markers.splice(index, 1);<br><br>        return true;<br><br>    };<br><br><br><br>    /**<br><br>     * 删除单个标记<br><br>     * @param {BMap.Marker} marker 需要被删除的marker<br><br>     *<br><br>     * @return {Boolean} 删除成功返回true，否则返回false<br><br>     */<br><br>    MarkerClusterer.prototype.removeMarker = function(marker) {<!-- --><br><br>        var success = this._removeMarker(marker);<br><br>        if (success) {<!-- --><br><br>            this._clearLastClusters();<br><br>            this._createClusters();<br><br>        }<br><br>        return success;<br><br>    };<br><br><br><br>    /**<br><br>     * 删除一组标记<br><br>     * @param {Array&lt;BMap.Marker&gt;} markers 需要被删除的marker数组<br><br>     *<br><br>     * @return {Boolean} 删除成功返回true，否则返回false<br><br>     */<br><br>    MarkerClusterer.prototype.removeMarkers = function(markers) {<!-- --><br><br>        var success = false;<br><br>        for (var i = 0; i &lt; markers.length; i++) {<!-- --><br><br>            var r = this._removeMarker(markers[i]);<br><br>            success = success || r; <br><br>        }<br><br><br><br>        if (success) {<!-- --><br><br>            this._clearLastClusters();<br><br>            this._createClusters();<br><br>        }<br><br>        return success;<br><br>    };<br><br><br><br>    /**<br><br>     * 从地图上彻底清除所有的标记<br><br>     * @return 无返回值<br><br>     */<br><br>    MarkerClusterer.prototype.clearMarkers = function() {<!-- --><br><br>        this._clearLastClusters();<br><br>        this._removeMarkersFromMap();<br><br>        this._markers = [];<br><br>    };<br><br><br><br>    /**<br><br>     * 重新生成，比如改变了属性等<br><br>     * @return 无返回值<br><br>     */<br><br>    MarkerClusterer.prototype._redraw = function () {<!-- --><br><br>        this._clearLastClusters();<br><br>        this._createClusters();<br><br>    };<br><br><br><br>    /**<br><br>     * 获取网格大小<br><br>     * @return {Number} 网格大小<br><br>     */<br><br>    MarkerClusterer.prototype.getGridSize = function() {<!-- --><br><br>        return this._gridSize;<br><br>    };<br><br><br><br>    /**<br><br>     * 设置网格大小<br><br>     * @param {Number} size 网格大小<br><br>     * @return 无返回值<br><br>     */<br><br>    MarkerClusterer.prototype.setGridSize = function(size) {<!-- --><br><br>        this._gridSize = size;<br><br>        this._redraw();<br><br>    };<br><br><br><br>    /**<br><br>     * 获取聚合的最大缩放级别。<br><br>     * @return {Number} 聚合的最大缩放级别。<br><br>     */<br><br>    MarkerClusterer.prototype.getMaxZoom = function() {<!-- --><br><br>        return this._maxZoom;       <br><br>    };<br><br><br><br>    /**<br><br>     * 设置聚合的最大缩放级别<br><br>     * @param {Number} maxZoom 聚合的最大缩放级别<br><br>     * @return 无返回值<br><br>     */<br><br>    MarkerClusterer.prototype.setMaxZoom = function(maxZoom) {<!-- --><br><br>        this._maxZoom = maxZoom;<br><br>        this._redraw();<br><br>    };<br><br><br><br>    /**<br><br>     * 获取聚合的样式风格集合<br><br>     * @return {Array&lt;IconStyle&gt;} 聚合的样式风格集合<br><br>     */<br><br>    MarkerClusterer.prototype.getStyles = function() {<!-- --><br><br>        return this._styles;<br><br>    };<br><br><br><br>    /**<br><br>     * 设置聚合的样式风格集合<br><br>     * @param {Array&lt;IconStyle&gt;} styles 样式风格数组<br><br>     * @return 无返回值<br><br>     */<br><br>    MarkerClusterer.prototype.setStyles = function(styles) {<!-- --><br><br>        this._styles = styles;<br><br>        this._redraw();<br><br>    };<br><br><br><br>    /**<br><br>     * 获取单个聚合的最小数量。<br><br>     * @return {Number} 单个聚合的最小数量。<br><br>     */<br><br>    MarkerClusterer.prototype.getMinClusterSize = function() {<!-- --><br><br>        return this._minClusterSize;<br><br>    };<br><br><br><br>    /**<br><br>     * 设置单个聚合的最小数量。<br><br>     * @param {Number} size 单个聚合的最小数量。<br><br>     * @return 无返回值。<br><br>     */<br><br>    MarkerClusterer.prototype.setMinClusterSize = function(size) {<!-- --><br><br>        this._minClusterSize = size;<br><br>        this._redraw();<br><br>    };<br><br><br><br>    /**<br><br>     * 获取单个聚合的落脚点是否是聚合内所有标记的平均中心。<br><br>     * @return {Boolean} true或false。<br><br>     */<br><br>    MarkerClusterer.prototype.isAverageCenter = function() {<!-- --><br><br>        return this._isAverageCenter;<br><br>    };<br><br><br><br>    /**<br><br>     * 获取聚合的Map实例。<br><br>     * @return {Map} Map的示例。<br><br>     */<br><br>    MarkerClusterer.prototype.getMap = function() {<!-- --><br><br>      return this._map;<br><br>    };<br><br><br><br>    /**<br><br>     * 获取所有的标记数组。<br><br>     * @return {Array&lt;Marker&gt;} 标记数组。<br><br>     */<br><br>    MarkerClusterer.prototype.getMarkers = function() {<!-- --><br><br>        return this._markers;<br><br>    };<br><br><br><br>    /**<br><br>     * 获取聚合的总数量。<br><br>     * @return {Number} 聚合的总数量。<br><br>     */<br><br>    MarkerClusterer.prototype.getClustersCount = function() {<!-- --><br><br>        var count = 0;<br><br>        for(var i = 0, cluster; cluster = this._clusters[i]; i++){<!-- --><br><br>            cluster.isReal() &amp;&amp; count++;     <br><br>        }<br><br>        return count;<br><br>    };<br><br><br><br>    /**<br><br>     * @ignore<br><br>     * Cluster<br><br>     * @class 表示一个聚合对象，该聚合，包含有N个标记，这N个标记组成的范围，并有予以显示在Map上的TextIconOverlay等。<br><br>     * @constructor<br><br>     * @param {MarkerClusterer} markerClusterer 一个标记聚合器示例。<br><br>     */<br><br>    function Cluster(markerClusterer){<!-- --><br><br>        this._markerClusterer = markerClusterer;<br><br>        this._map = markerClusterer.getMap();<br><br>        this._minClusterSize = markerClusterer.getMinClusterSize();<br><br>        this._isAverageCenter = markerClusterer.isAverageCenter();<br><br>        this._center = null;//落脚位置<br><br>        this._markers = [];//这个Cluster中所包含的markers<br><br>        this._gridBounds = null;//以中心点为准，向四边扩大gridSize个像素的范围，也即网格范围<br><br>        this._isReal = false; //真的是个聚合<br><br><br><br>        this._clusterMarker = new BMapLib.TextIconOverlay(this._center, this._markers.length, {"styles":this._markerClusterer.getStyles()});<br><br>        //this._map.addOverlay(this._clusterMarker);<br><br>    }<br><br><br><br>    /**<br><br>     * 向该聚合添加一个标记。<br><br>     * @param {Marker} marker 要添加的标记。<br><br>     * @return 无返回值。<br><br>     */<br><br>    Cluster.prototype.addMarker = function(marker){<!-- --><br><br>        if(this.isMarkerInCluster(marker)){<!-- --><br><br>            return false;<br><br>        }//也可用marker.isInCluster判断,外面判断OK，这里基本不会命中<br><br><br><br>        if (!this._center){<!-- --><br><br>            this._center = marker.getPosition();<br><br>            this.updateGridBounds();//<br><br>        } else {<!-- --><br><br>            if(this._isAverageCenter){<!-- --><br><br>                var l = this._markers.length + 1;<br><br>                var lat = (this._center.lat * (l - 1) + marker.getPosition().lat) / l;<br><br>                var lng = (this._center.lng * (l - 1) + marker.getPosition().lng) / l;<br><br>                this._center = new BMap.Point(lng, lat);<br><br>                this.updateGridBounds();<br><br>            }//计算新的Center<br><br>        }<br><br><br><br>        marker.isInCluster = true;<br><br>        this._markers.push(marker);<br><br><br><br>        var len = this._markers.length;<br><br>        if(len &lt; this._minClusterSize ){     <br><br>            this._map.addOverlay(marker);<br><br>            //this.updateClusterMarker();<br><br>            return true;<br><br>        } else if (len === this._minClusterSize) {<!-- --><br><br>            for (var i = 0; i &lt; len; i++) {<!-- --><br><br>                tmplabel = this._markers[i].getLabel();<br><br>                this._markers[i].getMap() &amp;&amp; this._map.removeOverlay(this._markers[i]);<br><br>                this._markers[i].setLabel(tmplabel);<br><br>            }<br><br><br><br>        } <br><br>        this._map.addOverlay(this._clusterMarker);<br><br>        this._isReal = true;<br><br>        this.updateClusterMarker();<br><br>        return true;<br><br>    };<br><br><br><br>    /**<br><br>     * 判断一个标记是否在该聚合中。<br><br>     * @param {Marker} marker 要判断的标记。<br><br>     * @return {Boolean} true或false。<br><br>     */<br><br>    Cluster.prototype.isMarkerInCluster= function(marker){<!-- --><br><br>        if (this._markers.indexOf) {<!-- --><br><br>            return this._markers.indexOf(marker) != -1;<br><br>        } else {<!-- --><br><br>            for (var i = 0, m; m = this._markers[i]; i++) {<!-- --><br><br>                if (m === marker) {<!-- --><br><br>                    return true;<br><br>                }<br><br>            }<br><br>        }<br><br>        return false;<br><br>    };<br><br><br><br>    /**<br><br>     * 判断一个标记是否在该聚合网格范围中。<br><br>     * @param {Marker} marker 要判断的标记。<br><br>     * @return {Boolean} true或false。<br><br>     */<br><br>    Cluster.prototype.isMarkerInClusterBounds = function(marker) {<!-- --><br><br>        return this._gridBounds.containsPoint(marker.getPosition());<br><br>    };<br><br><br><br>    Cluster.prototype.isReal = function(marker) {<!-- --><br><br>        return this._isReal;<br><br>    };<br><br><br><br>    /**<br><br>     * 更新该聚合的网格范围。<br><br>     * @return 无返回值。<br><br>     */<br><br>    Cluster.prototype.updateGridBounds = function() {<!-- --><br><br>        var bounds = new BMap.Bounds(this._center, this._center);<br><br>        this._gridBounds = getExtendedBounds(this._map, bounds, this._markerClusterer.getGridSize());<br><br>    };<br><br><br><br>    /**<br><br>     * 更新该聚合的显示样式，也即TextIconOverlay。<br><br>     * @return 无返回值。<br><br>     */<br><br>    Cluster.prototype.updateClusterMarker = function () {<!-- --><br><br>        if (this._map.getZoom() &gt; this._markerClusterer.getMaxZoom()) {<!-- --><br><br>            this._clusterMarker &amp;&amp; this._map.removeOverlay(this._clusterMarker);<br><br>            for (var i = 0, marker; marker = this._markers[i]; i++) {<!-- --><br><br>                this._map.addOverlay(marker);<br><br>            }<br><br>            return;<br><br>        }<br><br><br><br>        if (this._markers.length &lt; this._minClusterSize) {<!-- --><br><br>            this._clusterMarker.hide();<br><br>            return;<br><br>        }<br><br><br><br>        this._clusterMarker.setPosition(this._center);<br><br><br><br>        this._clusterMarker.setText(this._markers.length);<br><br><br><br>        var thatMap = this._map;<br><br>        var thatBounds = this.getBounds();<br><br>        this._clusterMarker.addEventListener("click", function(event){<!-- --><br><br>            thatMap.setViewport(thatBounds);<br><br>        });<br><br><br><br>    };<br><br><br><br>    /**<br><br>     * 删除该聚合。<br><br>     * @return 无返回值。<br><br>     */<br><br>    Cluster.prototype.remove = function(){<!-- --><br><br>        for (var i = 0, m; m = this._markers[i]; i++) {<!-- --><br><br>                var tmplabel = this._markers[i].getLabel();<br><br>                this._markers[i].getMap() &amp;&amp; this._map.removeOverlay(this._markers[i]);<br><br>                this._markers[i].setLabel(tmplabel);<br><br><br><br>        }//清除散的标记点<br><br>        this._map.removeOverlay(this._clusterMarker);<br><br>        this._markers.length = 0;<br><br>        delete this._markers;<br><br>    }<br><br><br><br>    /**<br><br>     * 获取该聚合所包含的所有标记的最小外接矩形的范围。<br><br>     * @return {BMap.Bounds} 计算出的范围。<br><br>     */<br><br>    Cluster.prototype.getBounds = function() {<!-- --><br><br>        var bounds = new BMap.Bounds(this._center,this._center);<br><br>        for (var i = 0, marker; marker = this._markers[i]; i++) {<!-- --><br><br>            bounds.extend(marker.getPosition());<br><br>        }<br><br>        return bounds;<br><br>    };<br><br><br><br>    /**<br><br>     * 获取该聚合的落脚点。<br><br>     * @return {BMap.Point} 该聚合的落脚点。<br><br>     */<br><br>    Cluster.prototype.getCenter = function() {<!-- --><br><br>        return this._center;<br><br>    };<br><br><br><br>})();<br></code></pre> 
<br> 
<br>转自：[url]http://www.cnblogs.com/chenjiahong/p/3917528.html[/url]
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/6e3dc34a5e37f5194700a2d3cbfec34c/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">MAC地址格式小结</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/fdf69f0a2ce9e935c6a61f6562584317/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">微博进化：内容至上到人本主义</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>