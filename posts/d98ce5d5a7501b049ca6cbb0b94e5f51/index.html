<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Kaggle Titanic 生存问题 - Java 机器学习实战 - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Kaggle Titanic 生存问题 - Java 机器学习实战" />
<meta property="og:description" content="Kaggle Titanic 生存问题 - Java 机器学习实战 Kaggle Titanic 生存问题 - Java 机器学习实战 1. Kaggle Titanic 介绍 1.1 Kaggle 竞赛1.2 Titanic 问题 2. 数据探索 2.1 数据初探2.2 特征分析 2.2.1 Pclass2.2.2 Sex2.2.3 Age2.2.4 SibSp2.2.5 Parch2.2.6 Embark2.2.7 Fare2.2.8 Cabin2.2.9 Name &amp; Ticket 3. 数据预处理 3.1 缺失值处理3.2 格式转换3.3 数据归一化 4. 逻辑回归、参数调优 4.1 基本的逻辑回归4.2 使用 CV 进行模型选择 5. 输出结果6. 参考资料 1. Kaggle Titanic 介绍 1.1 Kaggle 竞赛 Kaggle 是目前全球最有影响力的机器学习竞赛平台。
企业或者研究者可以将数据、问题描述、期望的指标发布到Kaggle上，以竞赛的形式向广大的数据科学家征集解决方案，类似于KDD-CUP（国际知识发现和数据挖掘竞赛）。Kaggle上的参赛者将数据下载下来，分析数据，然后运用机器学习、深度学习、数据挖掘等知识，建立算法模型，解决问题得出结果，最后将结果提交，如果提交的结果符合指标要求（比如logloss，mse等）并且在参赛者中排名第一，将获得比赛丰厚的奖金。
Titanic 竞赛是 Kaggle 提供的一个机器学习入门级比赛。主要是给新手练手用的（当然也没有奖金）。目前已经有将近1万只队伍参加过这个比赛了。
下面我们来具体看看 Titanic 问题。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/d98ce5d5a7501b049ca6cbb0b94e5f51/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2018-08-18T22:01:45+08:00" />
<meta property="article:modified_time" content="2018-08-18T22:01:45+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Kaggle Titanic 生存问题 - Java 机器学习实战</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <h2 id="kaggle-titanic-生存问题-java-机器学习实战">Kaggle Titanic 生存问题 - Java 机器学习实战</h2> 
<p></p> 
<div class="toc"> 
 <div class="toc"> 
  <ul><li><a href="#kaggle-titanic-%E7%94%9F%E5%AD%98%E9%97%AE%E9%A2%98-java-%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%AE%9E%E6%88%98" rel="nofollow">Kaggle Titanic 生存问题 - Java 机器学习实战</a> 
    <ul><li> 
      <ul><li><a href="#1-kaggle-titanic-%E4%BB%8B%E7%BB%8D" rel="nofollow">1. Kaggle Titanic 介绍</a> 
        <ul><li><a href="#11-kaggle-%E7%AB%9E%E8%B5%9B" rel="nofollow">1.1 Kaggle 竞赛</a></li><li><a href="#12-titanic-%E9%97%AE%E9%A2%98" rel="nofollow">1.2 Titanic 问题</a></li></ul> </li><li><a href="#2-%E6%95%B0%E6%8D%AE%E6%8E%A2%E7%B4%A2" rel="nofollow">2. 数据探索</a> 
        <ul><li><a href="#21-%E6%95%B0%E6%8D%AE%E5%88%9D%E6%8E%A2" rel="nofollow">2.1 数据初探</a></li><li><a href="#22-%E7%89%B9%E5%BE%81%E5%88%86%E6%9E%90" rel="nofollow">2.2 特征分析</a> 
          <ul><li><a href="#221-pclass" rel="nofollow">2.2.1 Pclass</a></li><li><a href="#222-sex" rel="nofollow">2.2.2 Sex</a></li><li><a href="#223-age" rel="nofollow">2.2.3 Age</a></li><li><a href="#224-sibsp" rel="nofollow">2.2.4 SibSp</a></li><li><a href="#225-parch" rel="nofollow">2.2.5 Parch</a></li><li><a href="#226-embark" rel="nofollow">2.2.6 Embark</a></li><li><a href="#227-fare" rel="nofollow">2.2.7 Fare</a></li><li><a href="#228-cabin" rel="nofollow">2.2.8 Cabin</a></li><li><a href="#229-name-ticket" rel="nofollow">2.2.9 Name &amp; Ticket</a></li></ul> </li></ul> </li><li><a href="#3-%E6%95%B0%E6%8D%AE%E9%A2%84%E5%A4%84%E7%90%86" rel="nofollow">3. 数据预处理</a> 
        <ul><li><a href="#31-%E7%BC%BA%E5%A4%B1%E5%80%BC%E5%A4%84%E7%90%86" rel="nofollow">3.1 缺失值处理</a></li><li><a href="#32-%E6%A0%BC%E5%BC%8F%E8%BD%AC%E6%8D%A2" rel="nofollow">3.2 格式转换</a></li><li><a href="#33-%E6%95%B0%E6%8D%AE%E5%BD%92%E4%B8%80%E5%8C%96" rel="nofollow">3.3 数据归一化</a></li></ul> </li><li><a href="#4-%E9%80%BB%E8%BE%91%E5%9B%9E%E5%BD%92%E5%8F%82%E6%95%B0%E8%B0%83%E4%BC%98" rel="nofollow">4. 逻辑回归、参数调优</a> 
        <ul><li><a href="#41-%E5%9F%BA%E6%9C%AC%E7%9A%84%E9%80%BB%E8%BE%91%E5%9B%9E%E5%BD%92" rel="nofollow">4.1 基本的逻辑回归</a></li><li><a href="#42-%E4%BD%BF%E7%94%A8-cv-%E8%BF%9B%E8%A1%8C%E6%A8%A1%E5%9E%8B%E9%80%89%E6%8B%A9" rel="nofollow">4.2 使用 CV 进行模型选择</a></li></ul> </li><li><a href="#5-%E8%BE%93%E5%87%BA%E7%BB%93%E6%9E%9C" rel="nofollow">5. 输出结果</a></li><li><a href="#6-%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99" rel="nofollow">6. 参考资料</a></li></ul> </li></ul> </li></ul> 
 </div> 
</div> 
<p></p> 
<h4 id="1-kaggle-titanic-介绍">1. Kaggle Titanic 介绍</h4> 
<h5 id="11-kaggle-竞赛">1.1 Kaggle 竞赛</h5> 
<p>Kaggle 是目前全球最有影响力的机器学习竞赛平台。</p> 
<p>企业或者研究者可以将数据、问题描述、期望的指标发布到Kaggle上，以竞赛的形式向广大的数据科学家征集解决方案，类似于KDD-CUP（国际知识发现和数据挖掘竞赛）。Kaggle上的参赛者将数据下载下来，分析数据，然后运用机器学习、深度学习、数据挖掘等知识，建立算法模型，解决问题得出结果，最后将结果提交，如果提交的结果符合指标要求（比如logloss，mse等）并且在参赛者中排名第一，将获得比赛丰厚的奖金。</p> 
<p>Titanic 竞赛是 Kaggle 提供的一个机器学习入门级比赛。主要是给新手练手用的（当然也没有奖金）。目前已经有将近1万只队伍参加过这个比赛了。</p> 
<p>下面我们来具体看看 Titanic 问题。</p> 
<h5 id="12-titanic-问题">1.2 Titanic 问题</h5> 
<p>我们首先看看 Competition Description：</p> 
<blockquote> 
 <p>The sinking of the RMS Titanic is one of the most infamous shipwrecks in history. On April 15, 1912, during her maiden voyage, the Titanic sank after colliding with an iceberg, killing 1502 out of 2224 passengers and crew. This sensational tragedy shocked the international community and led to better safety regulations for ships.</p> 
</blockquote> 
<p>One of the reasons that the shipwreck led to such loss of life was that there were not enough lifeboats for the passengers and crew. Although there was some element of luck involved in surviving the sinking, some groups of people were more likely to survive than others, such as women, children, and the upper-class.</p> 
<p>In this challenge, we ask you to complete the analysis of what sorts of people were likely to survive. In particular, we ask you to apply the tools of machine learning to predict which passengers survived the tragedy.</p> 
<p>1912 年4月15日的泰坦尼克沉船事件杀死了 2224 名船员和乘客中的 1502 人。很多人认为救生艇的缺乏是造成大量人员伤亡的一个重要原因。</p> 
<p>数据显示，一些群体在沉船事件中有更大的幸存可能。比如：妇女、儿童或者上层人士。</p> 
<p>这个比赛的目的就是根据乘客的特征来预测其是否能够幸存。</p> 
<p>kaggle 提供的数据主要分为两个文件： train.csv 和 test.csv。其中 train.csv 中的数据携带了是否幸存的信息，而 test.csv 则没有携带这一信息。我们将使用 train.csv 中的数据来训练模型，并在 test.csv 上执行预测。预测结果会提交给 kaggle 用于评价模型。</p> 
<h4 id="2-数据探索">2. 数据探索</h4> 
<h5 id="21-数据初探">2.1 数据初探</h5> 
<p>首先我们看看 train.csv 文件的内容：</p> 
<p><img src="https://images2.imgbox.com/b5/d7/ruwVZuhr_o.png" alt="这里写图片描述" title=""></p> 
<p>这里一共有 12 个字段。其中 PassengerId 仅仅是用作编号，没有其他用处。其他字段我们一一简要进行说明.</p> 
<ul><li><p>Survived：该乘客是否幸存. 1表示幸存，0表示未能幸存</p></li><li><p>Pclass： 表示该乘客的社会等级. 取值为1，2，3</p></li><li><p>Name：名字</p></li><li><p>Sex: 性别，分别取 male 或 female</p></li><li><p>Age: 年龄</p></li><li><p>SibSp: 船上有多少个兄弟姐妹</p></li><li><p>Parch： 船上有多少个长辈.</p></li><li><p>Ticket: 船票号码</p></li><li><p>Fare： 票价</p></li><li><p>Cabin： 客舱位置编号</p></li><li><p>Embarked: 登船的码头. 有S、Q 和 C</p></li></ul> 
<h5 id="22-特征分析">2.2 特征分析</h5> 
<p>在这一部分我们将逐一分析特征数据，并探索其同存活率之间的关系。</p> 
<p>由于笔者对 Java 更熟悉一些，因此将使用 Java 语言，用 Spark 进行分析。Spark 下的 SQL 可以将数据当做数据库表一样使用 sql 来进行处理。这对熟悉 sql 的人来说无疑是一种福利~~~</p> 
<p>首先进行初始化：</p> 
<pre class="prettyprint"><code class=" hljs avrasm">
SparkSession spark = SparkSession
        <span class="hljs-preprocessor">.builder</span>()
        <span class="hljs-preprocessor">.appName</span>(<span class="hljs-string">"Java Spark SQL basic example"</span>)
        <span class="hljs-preprocessor">.config</span>(<span class="hljs-string">"spark.some.config.option"</span>, <span class="hljs-string">"some-value"</span>)
        <span class="hljs-preprocessor">.getOrCreate</span>()<span class="hljs-comment">;</span>

Dataset&lt;Row&gt; titanicDFCsv = spark<span class="hljs-preprocessor">.read</span>()<span class="hljs-preprocessor">.format</span>(<span class="hljs-string">"csv"</span>)
        <span class="hljs-preprocessor">.option</span>(<span class="hljs-string">"sep"</span>, <span class="hljs-string">","</span>)
        <span class="hljs-preprocessor">.option</span>(<span class="hljs-string">"inferSchema"</span>, <span class="hljs-string">"true"</span>)
        <span class="hljs-preprocessor">.option</span>(<span class="hljs-string">"header"</span>, <span class="hljs-string">"true"</span>)
        <span class="hljs-preprocessor">.load</span>(<span class="hljs-string">"data/train.csv"</span>)<span class="hljs-comment">;  //数据保存在 data 文件夹下</span>

titanicDFCsv<span class="hljs-preprocessor">.createOrReplaceTempView</span>(<span class="hljs-string">"person"</span>)<span class="hljs-comment">; //这里创建 spark 的 person 表，方便后面用 spark sql 分析</span></code></pre> 
<p>初始化好了，我们就来看看具体的特征吧。</p> 
<h6 id="221-pclass">2.2.1 Pclass</h6> 
<p>首先看看阶层数据.</p> 
<pre class="prettyprint"><code class=" hljs avrasm">
Dataset&lt;Row&gt; s = spark<span class="hljs-preprocessor">.sql</span>(<span class="hljs-string">"select Pclass, Survived, count(*) from person group by Pclass, Survived order by Pclass asc, Survived asc"</span>)<span class="hljs-comment">;</span>
System<span class="hljs-preprocessor">.out</span><span class="hljs-preprocessor">.println</span>(<span class="hljs-string">"阶层存活统计"</span>)<span class="hljs-comment">;</span>
s<span class="hljs-preprocessor">.show</span>()<span class="hljs-comment">;</span>


ChartUtil<span class="hljs-preprocessor">.createStackedBarChart</span>(s, <span class="hljs-string">"pclass.jpg"</span>)<span class="hljs-comment">;</span></code></pre> 
<p>其中画图部分的代码如下：</p> 
<pre class="prettyprint"><code class=" hljs cs">
<span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">createStackedBarChart</span>(Dataset&lt;Row&gt; df, String path){
    final DefaultCategoryDataset dataset = <span class="hljs-keyword">new</span> DefaultCategoryDataset( );
    <span class="hljs-keyword">for</span>(Row row: df.collectAsList()){
        <span class="hljs-keyword">if</span>(row.<span class="hljs-keyword">get</span>(<span class="hljs-number">0</span>) instanceof Integer) {
            dataset.addValue((Long) row.<span class="hljs-keyword">get</span>(<span class="hljs-number">2</span>), (Integer) row.<span class="hljs-keyword">get</span>(<span class="hljs-number">1</span>), (Integer)row.<span class="hljs-keyword">get</span>(<span class="hljs-number">0</span>));
        } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(row.<span class="hljs-keyword">get</span>(<span class="hljs-number">0</span>) instanceof String){
            dataset.addValue((Long) row.<span class="hljs-keyword">get</span>(<span class="hljs-number">2</span>), (Integer) row.<span class="hljs-keyword">get</span>(<span class="hljs-number">1</span>), row.getString(<span class="hljs-number">0</span>));
        }
    }

    String[] columns = df.columns();

    StandardChartTheme standardChartTheme = <span class="hljs-keyword">new</span> StandardChartTheme(<span class="hljs-string">"CN"</span>);
    standardChartTheme.setExtraLargeFont(<span class="hljs-keyword">new</span> Font(<span class="hljs-string">"隶书"</span>, Font.BOLD, <span class="hljs-number">20</span>));
    standardChartTheme.setRegularFont(<span class="hljs-keyword">new</span> Font(<span class="hljs-string">"宋书"</span>, Font.PLAIN, <span class="hljs-number">15</span>));
    standardChartTheme.setLargeFont(<span class="hljs-keyword">new</span> Font(<span class="hljs-string">"宋书"</span>, Font.PLAIN, <span class="hljs-number">15</span>));
    ChartFactory.setChartTheme(standardChartTheme);

    JFreeChart barChart = ChartFactory.createStackedBarChart(
            <span class="hljs-string">"幸存关联分析"</span>,
            columns[<span class="hljs-number">0</span>], <span class="hljs-string">"人数"</span>,
            dataset,PlotOrientation.VERTICAL,
            <span class="hljs-keyword">true</span>, <span class="hljs-keyword">true</span>, <span class="hljs-keyword">false</span>);

    <span class="hljs-keyword">int</span> width = <span class="hljs-number">640</span>; <span class="hljs-comment">/* Width of the image */</span>
    <span class="hljs-keyword">int</span> height = <span class="hljs-number">480</span>; <span class="hljs-comment">/* Height of the image */</span>
    File BarChart = <span class="hljs-keyword">new</span> File(path);
    <span class="hljs-keyword">try</span> {
        ChartUtilities.saveChartAsJPEG( BarChart , barChart , width , height );
    } <span class="hljs-keyword">catch</span> (IOException e) {
        e.printStackTrace();
    }
}</code></pre> 
<p>得到如下结果：</p> 
<pre class="prettyprint"><code class=" hljs 1c">
阶层存活统计

+------+--------+--------+

<span class="hljs-string">|Pclass|Survived|count(1)|</span>

+------+--------+--------+

<span class="hljs-string">| 1| 0| 80|</span>

<span class="hljs-string">| 1| 1| 136|</span>

<span class="hljs-string">| 2| 0| 97|</span>

<span class="hljs-string">| 2| 1| 87|</span>

<span class="hljs-string">| 3| 0| 372|</span>

<span class="hljs-string">| 3| 1| 119|</span>

+------+--------+--------+
</code></pre> 
<p>很明显可以看出，第一阶层的人存活率最高。存活136个，占比 63%；第二阶层占比47%；第三阶层占比24%。</p> 
<p>更直观的用图表看看，结果更加明显：</p> 
<p><img src="https://images2.imgbox.com/61/bf/7tRRw5Mb_o.jpg" alt="这里写图片描述" title=""></p> 
<h6 id="222-sex">2.2.2 Sex</h6> 
<p>再看看性别的影响：</p> 
<pre class="prettyprint"><code class=" hljs sql">
s = spark.sql("<span class="hljs-operator"><span class="hljs-keyword">select</span> Sex, Survived, <span class="hljs-aggregate">count</span>(*) <span class="hljs-keyword">from</span> person <span class="hljs-keyword">group</span> <span class="hljs-keyword">by</span> Sex, Survived <span class="hljs-keyword">order</span> <span class="hljs-keyword">by</span> Sex <span class="hljs-keyword">asc</span>, Survived <span class="hljs-keyword">asc</span><span class="hljs-string">");
System.out.println("</span>性别存活统计<span class="hljs-string">");
s.show();
ChartUtil.createStackedBarChart(s, "</span>sex.jpg<span class="hljs-string">");</span></span></code></pre> 
<p>结果如下： <br> <img src="https://images2.imgbox.com/c0/79/cZ54rWcl_o.jpg" alt="这里写图片描述" title=""></p> 
<p>女性的存活率要比男性高得多。</p> 
<h6 id="223-age">2.2.3 Age</h6> 
<p>看看年龄的影响。由于年龄比较多，我们将其进行简单的分组。5岁以下，5-12岁，12-20岁，20-30岁，30-40岁，40-50岁，50-60岁，60岁以上分别分到一组。</p> 
<pre class="prettyprint"><code class=" hljs sql">
String sql = "<span class="hljs-operator"><span class="hljs-keyword">select</span> <span class="hljs-string">" +
        "</span><span class="hljs-keyword">case</span> <span class="hljs-string">" +
        "</span><span class="hljs-keyword">when</span> Age &lt;= <span class="hljs-number">5</span> <span class="hljs-keyword">then</span> <span class="hljs-number">1</span> <span class="hljs-string">" +
        "</span><span class="hljs-keyword">when</span> Age &gt;<span class="hljs-number">5</span> <span class="hljs-keyword">and</span> Age &lt;= <span class="hljs-number">12</span> <span class="hljs-keyword">then</span> <span class="hljs-number">2</span> <span class="hljs-string">" +
        "</span><span class="hljs-keyword">when</span> Age &gt; <span class="hljs-number">12</span> <span class="hljs-keyword">and</span> Age &lt;= <span class="hljs-number">20</span> <span class="hljs-keyword">then</span> <span class="hljs-number">3</span> <span class="hljs-string">" +
        "</span><span class="hljs-keyword">when</span> Age &gt; <span class="hljs-number">20</span> <span class="hljs-keyword">and</span> Age &lt;= <span class="hljs-number">30</span> <span class="hljs-keyword">then</span> <span class="hljs-number">4</span> <span class="hljs-string">" +
        "</span><span class="hljs-keyword">when</span> Age &gt; <span class="hljs-number">30</span> <span class="hljs-keyword">and</span> Age &lt;= <span class="hljs-number">40</span> <span class="hljs-keyword">then</span> <span class="hljs-number">5</span> <span class="hljs-string">" +
        "</span><span class="hljs-keyword">when</span> Age &gt; <span class="hljs-number">40</span> <span class="hljs-keyword">and</span> Age &lt;= <span class="hljs-number">50</span> <span class="hljs-keyword">then</span> <span class="hljs-number">6</span> <span class="hljs-string">" +
        "</span><span class="hljs-keyword">when</span> Age &gt; <span class="hljs-number">50</span> <span class="hljs-keyword">and</span> Age &lt;= <span class="hljs-number">60</span> <span class="hljs-keyword">then</span> <span class="hljs-number">7</span> <span class="hljs-string">" +
        "</span><span class="hljs-keyword">when</span> Age &gt; <span class="hljs-number">60</span> <span class="hljs-keyword">then</span> <span class="hljs-number">8</span> <span class="hljs-string">" +
        "</span><span class="hljs-keyword">end</span> <span class="hljs-string">" +
        "</span><span class="hljs-keyword">as</span> ageGroup, Survived, <span class="hljs-aggregate">count</span>(*) <span class="hljs-keyword">from</span> person <span class="hljs-keyword">group</span> <span class="hljs-keyword">by</span> ageGroup, Survived <span class="hljs-keyword">order</span> <span class="hljs-keyword">by</span> ageGroup, Survived<span class="hljs-string">";
s = spark.sql(sql);
System.out.println("</span>年龄分组存活统计<span class="hljs-string">");
s.show();
ChartUtil.createStackedBarChart(s, "</span>age.jpg<span class="hljs-string">");</span></span></code></pre> 
<p>得到结果如下：</p> 
<p><img src="https://images2.imgbox.com/fb/64/cgk91tTU_o.jpg" alt="这里写图片描述" title=""></p> 
<p>结果不是特别明显，能看出的是小孩子幸存率比较高，而老人低一些。</p> 
<h6 id="224-sibsp">2.2.4 SibSp</h6> 
<p>船上的兄弟数目有影响吗？我们来看看</p> 
<pre class="prettyprint"><code class=" hljs sql">
s = spark.sql("<span class="hljs-operator"><span class="hljs-keyword">select</span> SibSp, Survived, <span class="hljs-aggregate">count</span>(*) <span class="hljs-keyword">from</span> person <span class="hljs-keyword">group</span> <span class="hljs-keyword">by</span> SibSp, Survived <span class="hljs-keyword">order</span> <span class="hljs-keyword">by</span> SibSp <span class="hljs-keyword">asc</span>, Survived<span class="hljs-string">");
System.out.println("</span>兄弟数存活统计<span class="hljs-string">");
s.show();
ChartUtil.createStackedBarChart(s, "</span>sibsp.jpg<span class="hljs-string">");</span></span></code></pre> 
<p>结果如下： <br> <img src="https://images2.imgbox.com/bc/a1/C0DfJaNK_o.jpg" alt="这里写图片描述" title=""></p> 
<p>有兄弟在船上的人，幸存率币没有的稍微高一些。另外数据还可以看出，多于一个兄弟在船上的人并不多。</p> 
<h6 id="225-parch">2.2.5 Parch</h6> 
<p>是否有父母在船上会有影响吗？</p> 
<pre class="prettyprint"><code class=" hljs sql">
s = spark.sql("<span class="hljs-operator"><span class="hljs-keyword">select</span> Parch, Survived, <span class="hljs-aggregate">count</span>(*) <span class="hljs-keyword">from</span> person <span class="hljs-keyword">group</span> <span class="hljs-keyword">by</span> Parch, Survived <span class="hljs-keyword">order</span> <span class="hljs-keyword">by</span> Parch <span class="hljs-keyword">asc</span>, Survived<span class="hljs-string">");
System.out.println("</span>长辈数存活统计<span class="hljs-string">");
s.show();
ChartUtil.createStackedBarChart(s, "</span>parch.jpg<span class="hljs-string">");</span></span></code></pre> 
<p>结果如下： <br> <img src="https://images2.imgbox.com/68/74/1jLnxmwt_o.jpg" alt="这里写图片描述" title=""></p> 
<p>好像有父母在船上要高一些。</p> 
<h6 id="226-embark">2.2.6 Embark</h6> 
<p>出发站会有影响吗？</p> 
<pre class="prettyprint"><code class=" hljs sql">
s = spark.sql("<span class="hljs-operator"><span class="hljs-keyword">select</span> Embarked, Survived, <span class="hljs-aggregate">count</span>(*) <span class="hljs-keyword">from</span> person <span class="hljs-keyword">group</span> <span class="hljs-keyword">by</span> Embarked, Survived <span class="hljs-keyword">order</span> <span class="hljs-keyword">by</span> Embarked, Survived<span class="hljs-string">");
System.out.println("</span>出发站存活统计<span class="hljs-string">");
s.show();
ChartUtil.createStackedBarChart(s, "</span>embark.jpg<span class="hljs-string">");</span></span></code></pre> 
<p>看看结果：</p> 
<p><img src="https://images2.imgbox.com/7e/fe/MVy80cEH_o.jpg" alt="这里写图片描述" title=""></p> 
<p>貌似在 C 站上传的存活率高一些呢~~</p> 
<h6 id="227-fare">2.2.7 Fare</h6> 
<p>票价是否有影响呢？由于票价也比较分散，我们同样进行分组处理</p> 
<pre class="prettyprint"><code class=" hljs sql">
sql = "<span class="hljs-operator"><span class="hljs-keyword">select</span> <span class="hljs-string">" +
        "</span><span class="hljs-keyword">case</span> <span class="hljs-string">" +
        "</span><span class="hljs-keyword">when</span> Fare &lt;= <span class="hljs-number">10</span> <span class="hljs-keyword">then</span> <span class="hljs-number">1</span> <span class="hljs-string">" +
        "</span><span class="hljs-keyword">when</span> Fare &gt; <span class="hljs-number">10</span> <span class="hljs-keyword">and</span> Fare &lt;= <span class="hljs-number">20</span> <span class="hljs-keyword">then</span> <span class="hljs-number">2</span> <span class="hljs-string">" +
        "</span><span class="hljs-keyword">when</span> Fare &gt; <span class="hljs-number">20</span> <span class="hljs-keyword">and</span> Fare &lt;= <span class="hljs-number">30</span> <span class="hljs-keyword">then</span> <span class="hljs-number">3</span> <span class="hljs-string">" +
        "</span><span class="hljs-keyword">when</span> Fare &gt; <span class="hljs-number">30</span> <span class="hljs-keyword">and</span> Fare &lt;= <span class="hljs-number">60</span> <span class="hljs-keyword">then</span> <span class="hljs-number">4</span> <span class="hljs-string">" +
        "</span><span class="hljs-keyword">when</span> Fare &gt; <span class="hljs-number">60</span> <span class="hljs-keyword">and</span> Fare &lt;= <span class="hljs-number">100</span> <span class="hljs-keyword">then</span> <span class="hljs-number">5</span> <span class="hljs-string">" +
        "</span><span class="hljs-keyword">else</span> <span class="hljs-number">6</span> <span class="hljs-string">" +
        "</span><span class="hljs-keyword">end</span> <span class="hljs-string">" +
        "</span><span class="hljs-keyword">as</span> fareGroup, Survived, <span class="hljs-aggregate">count</span>(*) <span class="hljs-keyword">from</span> person <span class="hljs-keyword">group</span> <span class="hljs-keyword">by</span> fareGroup, Survived <span class="hljs-keyword">order</span> <span class="hljs-keyword">by</span> fareGroup <span class="hljs-keyword">asc</span>, Survived<span class="hljs-string">";
s = spark.sql(sql);
System.out.println("</span>船票存活统计<span class="hljs-string">");
s.show();
ChartUtil.createStackedBarChart(s, "</span>fare.jpg<span class="hljs-string">");</span></span></code></pre> 
<p>结果如下： <br> <img src="https://images2.imgbox.com/9c/7c/SQk1bPk7_o.jpg" alt="这里写图片描述" title=""></p> 
<p>这一组的结果也比较明显：票价越贵存活率越高！</p> 
<h6 id="228-cabin">2.2.8 Cabin</h6> 
<p>船舱是否有影响呢？</p> 
<pre class="prettyprint"><code class=" hljs sql">
s = spark.sql("<span class="hljs-operator"><span class="hljs-keyword">select</span> <span class="hljs-keyword">LEFT</span>(Cabin, <span class="hljs-number">1</span>) <span class="hljs-keyword">as</span> ca, Survived, <span class="hljs-aggregate">count</span>(*) <span class="hljs-keyword">from</span> person <span class="hljs-keyword">group</span> <span class="hljs-keyword">by</span> ca, Survived <span class="hljs-keyword">order</span> <span class="hljs-keyword">by</span> ca, Survived<span class="hljs-string">");
System.out.println("</span>cabin 存活统计<span class="hljs-string">");
s.show();
ChartUtil.createStackedBarChart(s, "</span>cabin.jpg<span class="hljs-string">");</span></span></code></pre> 
<p>看结果：</p> 
<p><img src="https://images2.imgbox.com/05/30/Hn3Hi6IS_o.jpg" alt="这里写图片描述" title=""></p> 
<h6 id="229-name-ticket">2.2.9 Name &amp; Ticket</h6> 
<p>名字和票号这两个字段看不出什么特征，第一感觉是暂时丢弃不做处理。</p> 
<p>当然，如果详细分析的话可能可以从名字提取出国籍或者性别之类的，我们暂时不作考虑。</p> 
<p>同样，票号也可以根据是否是纯数字、以及数字长度做一个简单的切分。不过暂时也不考虑。</p> 
<p>下面，我们将使用这些特征进行模型设计。首先看看数据预处理。</p> 
<h4 id="3-数据预处理">3. 数据预处理</h4> 
<h5 id="31-缺失值处理">3.1 缺失值处理</h5> 
<p>从数据可以看出，Age 和 Cabin 这两个字段有大量的缺失数据。我们分别需要对它们进行一定的处理。</p> 
<ul><li>Cabin</li></ul> 
<p>针对 Cabin，暂时只将其转换为表示存在的1 和表示不存在的0. 我们使用 spark 的 dataset api 直接进行转换</p> 
<pre class="prettyprint"><code class=" hljs avrasm">
titanicDFCsv = titanicDFCsv<span class="hljs-preprocessor">.withColumn</span>(<span class="hljs-string">"Cabin"</span>, 
        functions<span class="hljs-preprocessor">.when</span>(functions<span class="hljs-preprocessor">.col</span>(<span class="hljs-string">"Cabin"</span>)<span class="hljs-preprocessor">.isNull</span>(), <span class="hljs-number">0</span>)
                <span class="hljs-preprocessor">.otherwise</span>(<span class="hljs-number">1</span>))<span class="hljs-comment">;</span>
titanicDFCsv<span class="hljs-preprocessor">.show</span>()<span class="hljs-comment">;</span></code></pre> 
<ul><li>Age</li></ul> 
<p>针对年龄数据，可以使用简单的均值填充方案进行处理。我们将使用 spark 中的 Imputer 进行填充操作，转换器如下：</p> 
<pre class="prettyprint"><code class=" hljs javascript">
Imputer imputer = <span class="hljs-keyword">new</span> Imputer()
        .setInputCols(<span class="hljs-keyword">new</span> <span class="hljs-built_in">String</span>[]{<!-- --><span class="hljs-string">"Age"</span>})
        .setOutputCols(<span class="hljs-keyword">new</span> <span class="hljs-built_in">String</span>[]{<!-- --><span class="hljs-string">"ageNew"</span>});</code></pre> 
<h5 id="32-格式转换">3.2 格式转换</h5> 
<ul><li>Sex</li></ul> 
<p>性别是用字符串 ‘male’ 和 ‘female’ 表示的，无法直接输入模型。将其转换为数值类型：</p> 
<pre class="prettyprint"><code class=" hljs avrasm">
titanicDFCsv = titanicDFCsv<span class="hljs-preprocessor">.withColumn</span>(<span class="hljs-string">"Sex"</span>,
        functions<span class="hljs-preprocessor">.when</span>(functions<span class="hljs-preprocessor">.col</span>(<span class="hljs-string">"Sex"</span>)<span class="hljs-preprocessor">.equalTo</span>(<span class="hljs-string">"male"</span>), <span class="hljs-number">1</span>)
                <span class="hljs-preprocessor">.otherwise</span>(<span class="hljs-number">0</span>))<span class="hljs-comment">;</span></code></pre> 
<ul><li>Embark</li></ul> 
<p>登船站 Embark 是 category 类型的，因此可以转换为 one_hot 编码的格式。由于category 是用字符串表示的，因此需要先转换为数值类型，再转换为 one_hot 格式：</p> 
<pre class="prettyprint"><code class=" hljs javascript">
StringIndexer indexer = <span class="hljs-keyword">new</span> StringIndexer()
        .setInputCol(<span class="hljs-string">"Embarked"</span>)
        .setOutputCol(<span class="hljs-string">"EmbarkedIndex"</span>);
indexer.setHandleInvalid(<span class="hljs-string">"keep"</span>);

<span class="hljs-comment">// 转换成稀疏矩阵</span>
OneHotEncoderEstimator encoder = <span class="hljs-keyword">new</span> OneHotEncoderEstimator()
        .setInputCols(<span class="hljs-keyword">new</span> <span class="hljs-built_in">String</span>[] {<!-- --><span class="hljs-string">"EmbarkedIndex"</span>})
        .setOutputCols(<span class="hljs-keyword">new</span> <span class="hljs-built_in">String</span>[] {<!-- --><span class="hljs-string">"EmbarkedVec"</span>});

</code></pre> 
<h5 id="33-数据归一化">3.3 数据归一化</h5> 
<p>Age 和 Fare 这两个字段的取值范围比较大。我们知道，若使用梯度下降算法，未归一化的数据可能造成算法收敛困难。因此需要对这两个字段进行归一化。</p> 
<p>在归一化之前，需要先将所选字段组合成一个 Vector. 字段为 features</p> 
<pre class="prettyprint"><code class=" hljs javascript">
VectorAssembler assembler = <span class="hljs-keyword">new</span> VectorAssembler()
        .setInputCols(<span class="hljs-keyword">new</span> <span class="hljs-built_in">String</span>[]{<!-- --><span class="hljs-string">"Pclass"</span>, <span class="hljs-string">"Sex"</span>, <span class="hljs-string">"Age"</span>, <span class="hljs-string">"SibSp"</span>, <span class="hljs-string">"Parch"</span>, <span class="hljs-string">"Fare"</span>, <span class="hljs-string">"Cabin"</span>, <span class="hljs-string">"EmbarkedVec"</span>})
        .setOutputCol(<span class="hljs-string">"features"</span>);</code></pre> 
<p>spark 提供的归一化工具支持一个 Vector 上进行归一化，相当于对 Vector 上的所有字段归一化。将 features 转换为 scaledFeatures.</p> 
<pre class="prettyprint"><code class=" hljs http">

<span class="avrasm">
StandardScaler scaler = new StandardScaler()
<span class="hljs-preprocessor">.setInputCol</span>(<span class="hljs-string">"features"</span>)
<span class="hljs-preprocessor">.setOutputCol</span>(<span class="hljs-string">"scaledFeatures"</span>)
<span class="hljs-preprocessor">.setWithStd</span>(true)
<span class="hljs-preprocessor">.setWithMean</span>(false)<span class="hljs-comment">;</span></span></code></pre> 
<h4 id="4-逻辑回归参数调优">4. 逻辑回归、参数调优</h4> 
<h5 id="41-基本的逻辑回归">4.1 基本的逻辑回归</h5> 
<p>我们首先使用逻辑回归来训练模型</p> 
<pre class="prettyprint"><code class=" hljs avrasm">
LogisticRegression lr = new LogisticRegression()
        <span class="hljs-preprocessor">.setMaxIter</span>(<span class="hljs-number">100</span>)
        <span class="hljs-preprocessor">.setRegParam</span>(<span class="hljs-number">0.1</span>)
        <span class="hljs-preprocessor">.setFeaturesCol</span>(<span class="hljs-string">"scaledFeatures"</span>)
        <span class="hljs-preprocessor">.setLabelCol</span>(<span class="hljs-string">"Survived"</span>)
        <span class="hljs-preprocessor">.setElasticNetParam</span>(<span class="hljs-number">0</span>)<span class="hljs-comment">;</span></code></pre> 
<p>模型主要有以下参数：</p> 
<ul><li><p>maxIter 最大迭代次数</p></li><li><p>regParam 规范化项的权重</p></li><li><p>featuresCol 训练的特征列. 这一列本身又是个矩阵，所有训练模型需要的特征都在里面</p></li><li><p>labelCol 训练的预测列. 存放实际的 y 值. </p></li><li><p>elasticNetParam 这个是 elastic net 的参数，介于0-1之间. 表示 L1和L2正则之间的比例. 0 表示 L2 正则，1表示 L1 正则. 即下面公式中的 α 值:</p></li></ul> 
<p><span class="MathJax_Preview" style="color: inherit; display: none;"></span></p> 
<div class="MathJax_Display" style="text-align: center;"> 
 <span class="MathJax" id="MathJax-Element-1-Frame" tabindex="0" style="text-align: center; position: relative;"> 
   
   <span class="math" id="MathJax-Span-1" style="width: 12.138em; display: inline-block;"><span style="display: inline-block; position: relative; width: 10.107em; height: 0px; font-size: 120%;"><span style="position: absolute; clip: rect(0.68em, 1010.11em, 3.023em, -999.997em); top: -2.185em; left: 0em;"><span class="mrow" id="MathJax-Span-2"><span class="mi" id="MathJax-Span-3" style="font-family: MathJax_Math-italic;">α</span><span class="mo" id="MathJax-Span-4" style="font-family: MathJax_Main;">∥</span><span class="mi" id="MathJax-Span-5" style="font-family: MathJax_Math-italic;">w</span><span class="msubsup" id="MathJax-Span-6"><span style="display: inline-block; position: relative; width: 0.94em; height: 0px;"><span style="position: absolute; clip: rect(3.128em, 1000.37em, 4.43em, -999.997em); top: -4.008em; left: 0em;"><span class="mo" id="MathJax-Span-7" style="font-family: MathJax_Main;">∥</span><span style="display: inline-block; width: 0px; height: 4.013em;"></span></span><span style="position: absolute; top: -3.852em; left: 0.523em;"><span class="mn" id="MathJax-Span-8" style="font-size: 70.7%; font-family: MathJax_Main;">1</span><span style="display: inline-block; width: 0px; height: 4.013em;"></span></span></span></span><span class="mo" id="MathJax-Span-9" style="font-family: MathJax_Main; padding-left: 0.211em;">+</span><span class="mo" id="MathJax-Span-10" style="font-family: MathJax_Main; padding-left: 0.211em;">(</span><span class="mn" id="MathJax-Span-11" style="font-family: MathJax_Main;">1</span><span class="mo" id="MathJax-Span-12" style="font-family: MathJax_Main; padding-left: 0.211em;">−</span><span class="mi" id="MathJax-Span-13" style="font-family: MathJax_Math-italic; padding-left: 0.211em;">α</span><span class="mo" id="MathJax-Span-14" style="font-family: MathJax_Main;">)</span><span class="mfrac" id="MathJax-Span-15"><span style="display: inline-block; position: relative; width: 0.628em; height: 0px; margin-right: 0.107em; margin-left: 0.107em;"><span style="position: absolute; clip: rect(3.18em, 1000.42em, 4.169em, -999.997em); top: -4.685em; left: 50%; margin-left: -0.258em;"><span class="mn" id="MathJax-Span-16" style="font-family: MathJax_Main;">1</span><span style="display: inline-block; width: 0px; height: 4.013em;"></span></span><span style="position: absolute; clip: rect(3.18em, 1000.47em, 4.169em, -999.997em); top: -3.331em; left: 50%; margin-left: -0.258em;"><span class="mn" id="MathJax-Span-17" style="font-family: MathJax_Main;">2</span><span style="display: inline-block; width: 0px; height: 4.013em;"></span></span><span style="position: absolute; clip: rect(0.836em, 1000.63em, 1.201em, -999.997em); top: -1.247em; left: 0em;"><span style="display: inline-block; overflow: hidden; vertical-align: 0em; border-top: 1.3px solid; width: 0.628em; height: 0px;"></span><span style="display: inline-block; width: 0px; height: 1.044em;"></span></span></span></span><span class="mo" id="MathJax-Span-18" style="font-family: MathJax_Main;">∥</span><span class="mi" id="MathJax-Span-19" style="font-family: MathJax_Math-italic;">w</span><span class="msubsup" id="MathJax-Span-20"><span style="display: inline-block; position: relative; width: 0.94em; height: 0px;"><span style="position: absolute; clip: rect(3.128em, 1000.37em, 4.43em, -999.997em); top: -4.008em; left: 0em;"><span class="mo" id="MathJax-Span-21" style="font-family: MathJax_Main;">∥</span><span style="display: inline-block; width: 0px; height: 4.013em;"></span></span><span style="position: absolute; clip: rect(3.388em, 1000.42em, 4.169em, -999.997em); top: -4.372em; left: 0.523em;"><span class="mn" id="MathJax-Span-22" style="font-size: 70.7%; font-family: MathJax_Main;">2</span><span style="display: inline-block; width: 0px; height: 4.013em;"></span></span><span style="position: absolute; clip: rect(3.388em, 1000.42em, 4.169em, -999.997em); top: -3.695em; left: 0.523em;"><span class="mn" id="MathJax-Span-23" style="font-size: 70.7%; font-family: MathJax_Main;">2</span><span style="display: inline-block; width: 0px; height: 4.013em;"></span></span></span></span></span><span style="display: inline-block; width: 0px; height: 2.19em;"></span></span></span><span style="display: inline-block; overflow: hidden; vertical-align: -0.872em; border-left: 0px solid; width: 0px; height: 2.566em;"></span></span> 
  <span class="MJX_Assistive_MathML MJX_Assistive_MathML_Block"> 
    
    
      α 
     
    
      ‖ 
     
    
      w 
     
     
     
       ‖ 
      
     
       1 
      
     
    
      + 
     
    
      ( 
     
    
      1 
     
    
      − 
     
    
      α 
     
    
      ) 
     
     
     
       1 
      
     
       2 
      
     
    
      ‖ 
     
    
      w 
     
     
     
       ‖ 
      
     
       2 
      
     
       2 
      
     
   </span></span> 
</div><script type="math/tex; mode=display" id="MathJax-Element-1">\alpha \|w\|_1 + (1-\alpha)\frac{1}{2}\|w\|_2^2</script> 
<p></p> 
<h5 id="42-使用-cv-进行模型选择">4.2 使用 CV 进行模型选择</h5> 
<p>调参，每一组参数代表一个模型</p> 
<p>CV （Cross-Validation）即交叉验证。</p> 
<p>spark 提供了 CrossValidator 类来协助我们进行交叉验证，选择最合适的模型。其工作原理伪码如下：</p> 
<pre class="prettyprint"><code class=" hljs r">
将训练数据集划分为 k 份 [t1,t2,<span class="hljs-keyword">...</span>, tk]

对每个模型 m:

  在 k 份数据上训练模型 k 次，模型的评价指标 E(m) 为每次训练评价指标的均值

选择评价指标最高的 E(m) 对应的模型 m
</code></pre> 
<p>如果我们有 n 个模型，将数据切分成 k 分，则交叉验证需要训练模型 n*k 次。在实际使用中需要考虑到这一点。</p> 
<p>下面是我们的实现：</p> 
<pre class="prettyprint"><code class=" hljs http">

<span class="avrasm">
ParamMap[] paramGrid = new ParamGridBuilder()
<span class="hljs-preprocessor">.addGrid</span>(lr<span class="hljs-preprocessor">.regParam</span>(), new double[] {<!-- --><span class="hljs-number">0.3</span>, <span class="hljs-number">0.1</span>, <span class="hljs-number">0.03</span>, <span class="hljs-number">0.01</span>})
<span class="hljs-preprocessor">.addGrid</span>(lr<span class="hljs-preprocessor">.elasticNetParam</span>(), new double[] {<!-- --><span class="hljs-number">0</span>, <span class="hljs-number">0.3</span>, <span class="hljs-number">0.6</span>, <span class="hljs-number">1</span>})
<span class="hljs-preprocessor">.build</span>()<span class="hljs-comment">;</span>

CrossValidator cv = new CrossValidator()
<span class="hljs-preprocessor">.setEstimator</span>(pipeline)
<span class="hljs-preprocessor">.setEvaluator</span>(new BinaryClassificationEvaluator()
<span class="hljs-preprocessor">.setMetricName</span>(<span class="hljs-string">"areaUnderROC"</span>)
<span class="hljs-preprocessor">.setLabelCol</span>(<span class="hljs-string">"Survived"</span>)
<span class="hljs-preprocessor">.setRawPredictionCol</span>(<span class="hljs-string">"prediction"</span>)) //使用二分评价指标
<span class="hljs-preprocessor">.setEstimatorParamMaps</span>(paramGrid)
<span class="hljs-preprocessor">.setNumFolds</span>(<span class="hljs-number">3</span>)
<span class="hljs-preprocessor">.setParallelism</span>(<span class="hljs-number">2</span>)<span class="hljs-comment">; // Evaluate up to 2 parameter settings in parallel</span>

// Run cross-validation, <span class="hljs-keyword">and</span> choose the best <span class="hljs-keyword">set</span> of parameters.
CrossValidatorModel cvModel = cv<span class="hljs-preprocessor">.fit</span>(titanicDFCsv)<span class="hljs-comment">;</span>
PipelineModel bestPipelineMode = (PipelineModel)cvModel<span class="hljs-preprocessor">.bestModel</span>()<span class="hljs-comment">;</span>
LogisticRegressionModel bestLrModel = (LogisticRegressionModel)bestPipelineMode<span class="hljs-preprocessor">.stages</span>()[<span class="hljs-number">5</span>]<span class="hljs-comment">;</span>
double bestRegParam = bestLrModel<span class="hljs-preprocessor">.getRegParam</span>()<span class="hljs-comment">;</span>
double bestElasticNetParam = bestLrModel<span class="hljs-preprocessor">.getElasticNetParam</span>()<span class="hljs-comment">;</span>
System<span class="hljs-preprocessor">.out</span><span class="hljs-preprocessor">.println</span>(<span class="hljs-string">"bestRegParam : "</span> + bestRegParam)<span class="hljs-comment">;</span>
System<span class="hljs-preprocessor">.out</span><span class="hljs-preprocessor">.println</span>(<span class="hljs-string">"bestElasticNetParam："</span> + bestElasticNetParam)<span class="hljs-comment">;</span>

//LogisticRegressionModel lrModel = (LogisticRegressionModel)model<span class="hljs-preprocessor">.stages</span>()[<span class="hljs-number">5</span>]<span class="hljs-comment">;</span>
BinaryLogisticRegressionTrainingSummary summary = bestLrModel<span class="hljs-preprocessor">.binarySummary</span>()<span class="hljs-comment">;</span>
double precision = summary<span class="hljs-preprocessor">.weightedPrecision</span>()<span class="hljs-comment">;</span>
double recall = summary<span class="hljs-preprocessor">.weightedRecall</span>()<span class="hljs-comment">;</span>
double accuracy = summary<span class="hljs-preprocessor">.accuracy</span>()<span class="hljs-comment">;</span>

System<span class="hljs-preprocessor">.out</span><span class="hljs-preprocessor">.println</span>(<span class="hljs-string">"Precision: "</span> + precision)<span class="hljs-comment">;</span>
System<span class="hljs-preprocessor">.out</span><span class="hljs-preprocessor">.println</span>(<span class="hljs-string">"Recall: "</span> + recall)<span class="hljs-comment">;</span>
System<span class="hljs-preprocessor">.out</span><span class="hljs-preprocessor">.println</span>(<span class="hljs-string">"Accuracy: "</span> + accuracy)<span class="hljs-comment">;</span></span></code></pre> 
<p>得到如下结果：</p> 
<pre class="prettyprint"><code class=" hljs avrasm">
bestRegParam : <span class="hljs-number">0.01</span>

bestElasticNetParam：<span class="hljs-number">0.0</span>

<span class="hljs-label">Precision:</span> <span class="hljs-number">0.7975373034403689</span>

<span class="hljs-label">Recall:</span> <span class="hljs-number">0.7991021324354658</span>

<span class="hljs-label">Accuracy:</span> <span class="hljs-number">0.7991021324354658</span>
</code></pre> 
<p>结果显示，最好的 lr 模型 regParam 为0.01，elasticNetParam 为 0，即使用 L2 正则. 模型的准确率达到 79.9。</p> 
<h4 id="5-输出结果">5. 输出结果</h4> 
<p>输出结果代码如下：</p> 
<pre class="prettyprint"><code class=" hljs avrasm">
Dataset&lt;Row&gt; testDF = spark<span class="hljs-preprocessor">.read</span>()<span class="hljs-preprocessor">.format</span>(<span class="hljs-string">"csv"</span>)
        <span class="hljs-preprocessor">.option</span>(<span class="hljs-string">"sep"</span>, <span class="hljs-string">","</span>)
        <span class="hljs-preprocessor">.option</span>(<span class="hljs-string">"inferSchema"</span>, <span class="hljs-string">"true"</span>)
        <span class="hljs-preprocessor">.option</span>(<span class="hljs-string">"header"</span>, <span class="hljs-string">"true"</span>)
        <span class="hljs-preprocessor">.load</span>(<span class="hljs-string">"data/test.csv"</span>)<span class="hljs-comment">;</span>
testDF = testDF<span class="hljs-preprocessor">.withColumn</span>(<span class="hljs-string">"Cabin"</span>,
        functions<span class="hljs-preprocessor">.when</span>(functions<span class="hljs-preprocessor">.col</span>(<span class="hljs-string">"Cabin"</span>)<span class="hljs-preprocessor">.isNull</span>(), <span class="hljs-number">0</span>)
                <span class="hljs-preprocessor">.otherwise</span>(<span class="hljs-number">1</span>))<span class="hljs-comment">;</span>
testDF = testDF<span class="hljs-preprocessor">.withColumn</span>(<span class="hljs-string">"Sex"</span>,
        functions<span class="hljs-preprocessor">.when</span>(functions<span class="hljs-preprocessor">.col</span>(<span class="hljs-string">"Sex"</span>)<span class="hljs-preprocessor">.equalTo</span>(<span class="hljs-string">"male"</span>), <span class="hljs-number">1</span>)
                <span class="hljs-preprocessor">.otherwise</span>(<span class="hljs-number">0</span>))<span class="hljs-comment">;</span>
testDF = testDF<span class="hljs-preprocessor">.withColumn</span>(<span class="hljs-string">"Fare"</span>,
        functions<span class="hljs-preprocessor">.when</span>(functions<span class="hljs-preprocessor">.col</span>(<span class="hljs-string">"Fare"</span>)<span class="hljs-preprocessor">.isNull</span>(), <span class="hljs-number">0</span>)
                <span class="hljs-preprocessor">.otherwise</span>(functions<span class="hljs-preprocessor">.col</span>(<span class="hljs-string">"Fare"</span>)))<span class="hljs-comment">;</span>
testDF<span class="hljs-preprocessor">.show</span>()<span class="hljs-comment">;</span>

Dataset&lt;Row&gt; predictions = pipelineModel<span class="hljs-preprocessor">.transform</span>(testDF)<span class="hljs-comment">;</span>
for(String s: predictions<span class="hljs-preprocessor">.columns</span>()){
    System<span class="hljs-preprocessor">.out</span><span class="hljs-preprocessor">.println</span>(s)<span class="hljs-comment">;</span>
}

CsvWriter csvWriter = new CsvWriter(<span class="hljs-string">"data/submission.csv"</span>, <span class="hljs-string">','</span>, Charset<span class="hljs-preprocessor">.forName</span>(<span class="hljs-string">"UTF-8"</span>))<span class="hljs-comment">;</span>
String[] csvHeaders = { <span class="hljs-string">"PassengerId"</span>, <span class="hljs-string">"Survived"</span>}<span class="hljs-comment">;</span>
csvWriter<span class="hljs-preprocessor">.writeRecord</span>(csvHeaders)<span class="hljs-comment">;</span>
for (Row r : predictions<span class="hljs-preprocessor">.select</span>(<span class="hljs-string">"PassengerId"</span>, <span class="hljs-string">"prediction"</span>)<span class="hljs-preprocessor">.collectAsList</span>()) {
    System<span class="hljs-preprocessor">.out</span><span class="hljs-preprocessor">.println</span>(r<span class="hljs-preprocessor">.get</span>(<span class="hljs-number">0</span>) + <span class="hljs-string">"-&gt;"</span> + r<span class="hljs-preprocessor">.get</span>(<span class="hljs-number">1</span>))<span class="hljs-comment">;</span>
    String[] csvContent = {(r<span class="hljs-preprocessor">.get</span>(<span class="hljs-number">0</span>))<span class="hljs-preprocessor">.toString</span>(), String<span class="hljs-preprocessor">.valueOf</span>(((Double)r<span class="hljs-preprocessor">.get</span>(<span class="hljs-number">1</span>))<span class="hljs-preprocessor">.intValue</span>())}<span class="hljs-comment">;</span>
    csvWriter<span class="hljs-preprocessor">.writeRecord</span>(csvContent)<span class="hljs-comment">;</span>
}
csvWriter<span class="hljs-preprocessor">.close</span>()<span class="hljs-comment">;</span>

</code></pre> 
<p>我们将输出的 submission.csv 文件提交，得到如下结果：</p> 
<p><img src="https://images2.imgbox.com/60/f6/co1ADiZt_o.png" alt="这里写图片描述" title=""></p> 
<p>名次比较低啊~~。不过怎么也算首次提交，只使用了最基本的 LR 模型，还算不错了。后面可以慢慢优化。</p> 
<p>本来打算好好折腾一下 java 机器学习的。但是一遍流程走下来，后面不准备用 java spark 搞了，很多 python 里面现成的工具 java 里面都没有。后面切换 python~~~</p> 
<h4 id="6-参考资料">6. 参考资料</h4> 
<p><a href="https://blog.csdn.net/g11d111/article/details/77164074">https://blog.csdn.net/g11d111/article/details/77164074</a></p> 
<p><a href="https://www.kaggle.com/" rel="nofollow">https://www.kaggle.com/</a></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/b62f8a9e9bde36f9dd7eb2264f5d6c6d/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">mysql 中存储表情</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/03f19d2f0ed6e642129230a615a55114/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">关于多线程</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>