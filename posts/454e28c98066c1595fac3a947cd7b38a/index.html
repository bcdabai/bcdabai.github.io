<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>[转]autowire属性 - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="[转]autowire属性" />
<meta property="og:description" content=" http://zgzd13575java.iteye.com/blog/274547
采用的是Spring2.0的xml,在这里,IOC控制反转,我只探讨autowire的四个比较常用的属性 一:系统默认的autiwire=&#34;no&#34; &lt;bean id=&#34;show&#34; class=&#34;com.zgz008.web.ShowListBean&#34; autowire=&#34;no&#34; &gt; &lt;property name=&#34;showService&#34;&gt; &lt;ref bean=&#34;showService&#34;&gt;&lt;/ref&gt; &lt;/property&gt; &lt;/bean&gt; proprtty name属性指的是com.zgz008.web.ShowListBean内部反射成set方法生成的,并不是说一定是属性名showService ref bean指的就是我们的id号啦 二: autowire=&#34;byName&#34; &lt;bean id=&#34;show&#34; class=&#34;com.zgz008.web.ShowListBean&#34; autowire=&#34;byName&#34; /&gt; 自动根据applicationContext.xml里面的bean id属性反射成set方法,去查询com.zgz008.web.ShowListBean有没有拥有这个方法 有的话就自动依赖注入 三:autowire=&#34;byType&#34; &lt;bean id=&#34;show&#34; class=&#34;com.zgz008.web.ShowListBean&#34; autowire=&#34;byType&#34; /&gt; 只要com.zgz008.web.ShowListBean有一个属性与Spring容器中的属性相匹配,那么就会自动装载进来,调用的是set方法（不用管属性名） 四:autowire=&#34;constructor&#34; &lt;bean id=&#34;show&#34; class=&#34;com.zgz008.web.ShowListBean&#34; autowire=&#34;constructor&#34; &gt; &lt;constructor-arg index=&#34;0&#34; type=&#34;com.zgz008.service.IShowService&#34;&#34;&gt; &lt;ref bean=&#34;showServiceOK&#34; /&gt; &lt;/constructor-arg&gt; &lt;/bean&gt; 使用的是构造器注入,ref bean指的是id号,只要类型匹配就会自动注入,（不用管属性名） 总的来说，只要你命名规范符合标准,应该不会有什么大问题的 以下内容转载 no 不使用自动装配。必须通过ref元素指定依赖，这是默认设置。由于显式指定协作者可以使配置更灵活、更清晰，因此对于较大的部署配置，推荐采用该设置。而且在某种程度上，它也是系统架构的一种文档形式。 byName 根据属性名自动装配。此选项将检查容器并根据名字查找与属性完全一致的bean，并将其与属性自动装配。例如，在bean定义中将autowire设置为by name，而该bean包含master属性（同时提供setMaster(..)方法），Spring就会查找名为master的bean定义，并用它来装配给master属性。 byType 如果容器中存在一个与指定属性类型相同的bean，那么将与该属性自动装配。如果存在多个该类型的bean，那么将会抛出异常，并指出不能使用byType方式进行自动装配。若没有找到相匹配的bean，则什么事都不发生，属性也不会被设置。如果你不希望这样，那么可以通过设置dependency-check=&#34;objects&#34;让Spring抛出异常。 网管论坛bbs_bitsCN_com constructor 与byType的方式类似，不同之处在于它应用于构造器参数。如果在容器中没有找到与构造器参数类型一致的bean，那么将会抛出异常。 autodetect 通过bean类的自省机制（introspection）来决定是使用constructor还是byType方式进行自动装配。如果发现默认的构造器，那么将使用byType方式。 " />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/454e28c98066c1595fac3a947cd7b38a/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2013-04-01T10:20:15+08:00" />
<meta property="article:modified_time" content="2013-04-01T10:20:15+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">[转]autowire属性</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p><a href="http://zgzd13575java.iteye.com/blog/274547" rel="nofollow">http://zgzd13575java.iteye.com/blog/274547</a></p> 
<p> </p> 
<p>采用的是Spring2.0的xml,在这里,IOC控制反转,我只探讨autowire的四个比较常用的属性 <br> <br> 一:系统默认的autiwire="no" <br> <br> &lt;bean id="show" class="com.zgz008.web.ShowListBean" autowire="no" &gt;   <br> &lt;property name="showService"&gt; <br> &lt;ref bean="showService"&gt;&lt;/ref&gt; <br> &lt;/property&gt; <br> &lt;/bean&gt; <br> <br> proprtty name属性指的是com.zgz008.web.ShowListBean内部反射成set方法生成的,并不是说一定是属性名showService <br> ref bean指的就是我们的id号啦 <br> <br> 二: autowire="byName" <br> <br> <br> &lt;bean id="show" class="com.zgz008.web.ShowListBean" autowire="byName" /&gt; <br> <br> 自动根据applicationContext.xml里面的bean id属性反射成set方法,去查询com.zgz008.web.ShowListBean有没有拥有这个方法 <br> 有的话就自动依赖注入 <br> <br> 三:autowire="byType" <br> <br> <br> &lt;bean id="show" class="com.zgz008.web.ShowListBean" autowire="byType" /&gt; <br> <br> 只要com.zgz008.web.ShowListBean有一个属性与Spring容器中的属性相匹配,那么就会自动装载进来,调用的是set方法（不用管属性名） <br> <br> 四:autowire="constructor" <br> <br> <br> &lt;bean id="show" class="com.zgz008.web.ShowListBean" autowire="constructor" &gt; <br> &lt;constructor-arg index="0" type="com.zgz008.service.IShowService""&gt; <br>       &lt;ref bean="showServiceOK" /&gt; <br> &lt;/constructor-arg&gt; <br> &lt;/bean&gt; <br> <br> 使用的是构造器注入,ref bean指的是id号,只要类型匹配就会自动注入,（不用管属性名） <br> <br> <br> <br> 总的来说，只要你命名规范符合标准,应该不会有什么大问题的 <br> <br> 以下内容转载 <br> <br> no 不使用自动装配。必须通过ref元素指定依赖，这是默认设置。由于显式指定协作者可以使配置更灵活、更清晰，因此对于较大的部署配置，推荐采用该设置。而且在某种程度上，它也是系统架构的一种文档形式。 <br> <br> byName 根据属性名自动装配。此选项将检查容器并根据名字查找与属性完全一致的bean，并将其与属性自动装配。例如，在bean定义中将autowire设置为by name，而该bean包含master属性（同时提供setMaster(..)方法），Spring就会查找名为master的bean定义，并用它来装配给master属性。 <br> <br> byType 如果容器中存在一个与指定属性类型相同的bean，那么将与该属性自动装配。如果存在多个该类型的bean，那么将会抛出异常，并指出不能使用byType方式进行自动装配。若没有找到相匹配的bean，则什么事都不发生，属性也不会被设置。如果你不希望这样，那么可以通过设置dependency-check="objects"让Spring抛出异常。 网管论坛bbs_bitsCN_com <br> <br> constructor 与byType的方式类似，不同之处在于它应用于构造器参数。如果在容器中没有找到与构造器参数类型一致的bean，那么将会抛出异常。 <br> <br> autodetect 通过bean类的自省机制（introspection）来决定是使用constructor还是byType方式进行自动装配。如果发现默认的构造器，那么将使用byType方式。 <br> </p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/91607d1fc554e867ee820b7ed86574b2/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">gdb结合coredump定位崩溃进程</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/8a11f67e335061ca9d680a9178fcdeae/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">扩展OSGi控制台，通过web访问操作console，支持3.4、3.6</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>