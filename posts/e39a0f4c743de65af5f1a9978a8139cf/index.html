<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>数据结构实验--唯一的确定一棵二叉树 - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="数据结构实验--唯一的确定一棵二叉树" />
<meta property="og:description" content="一、问题描述 如果给出了遍历二叉树的前序序列和中序序列，则可以构造出唯一的一棵二叉树。试编写实现上述功能的程序。
【基本要求】
已知一棵二叉树的前序和中序序列，试设计完成下列任务的一个算法：
（1）构造一棵二叉树；
（2）证明构造正确（即分别以前序和中序遍历该树，将得到的结果与给出的序列进行比较）。
（3）对该二叉树进行后序遍历，输出后序遍历序列。
（4）用凹入法输出该二叉树。
【测试数据】
（1）前序序列为ABDEGCFHIJ，中序序列为DBGEAHFIJC。
（2）前序序列为-&#43;abc/de，中序序列为a&#43;bc-d/e 。
【拓展内容】
由原表达式构造二叉树。测试数据(a&#43;b) ×c-d/e
二、需求分析 需要设计有以下几个功能的程序：
1：由已知的前序和后续序列构建二叉树2：分别用三种序列（前中后）输出二叉树3：用凹入法输出二叉树 输入：分别输入前序序列和后序序列
输出：四种方法分别输出该二叉树
拓展功能：根据输入的中缀表达式(四则运算)，创建二叉树
三、设计 3.1 概要设计 （1）数据结构设计
根据题目要求易知本程序采用树结构作为基本结构，但在操作过程中也要用字符数组或者字符串类型储存计算过程中的表达式，考虑到需要多次使用截取部分字符串的
（2）算法设计
根据前序遍历的特点, 知前序序列(PreS)的首个元素(PreS[0])为二叉树的根(root), 然后在中序序列(InS)中查找此根(root), 根据中序遍历特点, 知在查找到的根(root) 前边的序列为根的左子树的中序遍历序列, 后边的序列为根的右子树的中序遍历序列。 设在中序遍历序列(InS)根前边有left个元素. 则在前序序列(PreS)中, 紧跟着根(root)的left个元素序列(即PreS[1…left]) 为根的左子树的前序遍历序列, 在后边的为根的右子树的前序遍历序列.而构造左子树问题其实跟构造整个二叉树问题一样，只是此时前序序列为PreS[1…left]), 中序序列为InS[0…left-1], 分别为原序列的子串, 构造右子树同样, 显然可以用递归方法解决。
建立完二叉树之后，很容易建立三个函数用递归的算法遍历输出已经建立的二叉树的前中后三种序列，对于凹入法，可以基于前序遍历输出，在输出的时候控制格式，即根据层高判断字符前面输出的空格数，在字符后输出与空格对应的点或其他字符，保持总的字符数不变。
3.2 详细设计 1.类的设计 由于本算法基于树来实现，首先要设计树的节点类，包括数据域和指针域，指针域包括左子树和右子树。树类包括一个指向树的节点类的指针和其他若干函数
2. 遍历函数设计 void PreOrderTraverse(BiNode* t) { if (t == NULL) return;	cout &lt;&lt; t-&gt;Data; PreOrderTraverse(t-&gt;L_Child); PreOrderTraverse(t-&gt;R_Child); }//前序遍历 遍历的算法如上，基于递归的思想，首先把t等于NULL作为递归出口
输出当前数据之后，依次递归访问左孩子和右孩子
对于中序和后续遍历仅需改变输出语句与访问左右孩子的顺序
3. 创建二叉树函数设计 void CreateBiTree(BiNode* t, string Pres, string Ins)//t为要建立的二叉树,pres和ins分别为前序和中序序列" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/e39a0f4c743de65af5f1a9978a8139cf/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2021-10-31T09:00:00+08:00" />
<meta property="article:modified_time" content="2021-10-31T09:00:00+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">数据结构实验--唯一的确定一棵二叉树</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <h2><a id="_0"></a>一、问题描述</h2> 
<p>如果给出了遍历二叉树的前序序列和中序序列，则可以构造出唯一的一棵二叉树。试编写实现上述功能的程序。</p> 
<p>【基本要求】<br> 已知一棵二叉树的前序和中序序列，试设计完成下列任务的一个算法：<br> （1）构造一棵二叉树；<br> （2）证明构造正确（即分别以前序和中序遍历该树，将得到的结果与给出的序列进行比较）。<br> （3）对该二叉树进行后序遍历，输出后序遍历序列。<br> （4）用凹入法输出该二叉树。</p> 
<p>【测试数据】<br> （1）前序序列为ABDEGCFHIJ，中序序列为DBGEAHFIJC。<br> （2）前序序列为-<em>+abc/de，中序序列为a+b</em>c-d/e 。</p> 
<p>【拓展内容】<br> 由原表达式构造二叉树。测试数据(a+b) ×c-d/e</p> 
<h2><a id="_17"></a>二、需求分析</h2> 
<p>需要设计有以下几个功能的程序：</p> 
<ul><li>1：由已知的前序和后续序列构建二叉树</li><li>2：分别用三种序列（前中后）输出二叉树</li><li>3：用凹入法输出二叉树</li></ul> 
<p>输入：分别输入前序序列和后序序列</p> 
<p>输出：四种方法分别输出该二叉树</p> 
<p>拓展功能：根据输入的中缀表达式(四则运算)，创建二叉树</p> 
<p></p> 
<h2><a id="_30"></a>三、设计</h2> 
<h3><a id="31__31"></a>3.1 概要设计</h3> 
<p>（1）数据结构设计<br> 根据题目要求易知本程序采用树结构作为基本结构，但在操作过程中也要用字符数组或者字符串类型储存计算过程中的表达式，考虑到需要多次使用截取部分字符串的</p> 
<p>（2）算法设计<br> 根据前序遍历的特点, 知前序序列(PreS)的首个元素(PreS[0])为二叉树的根(root), 然后在中序序列(InS)中查找此根(root), 根据中序遍历特点, 知在查找到的根(root) 前边的序列为根的左子树的中序遍历序列, 后边的序列为根的右子树的中序遍历序列。 设在中序遍历序列(InS)根前边有left个元素. 则在前序序列(PreS)中, 紧跟着根(root)的left个元素序列(即PreS[1…left]) 为根的左子树的前序遍历序列, 在后边的为根的右子树的前序遍历序列.而构造左子树问题其实跟构造整个二叉树问题一样，只是此时前序序列为PreS[1…left]), 中序序列为InS[0…left-1], 分别为原序列的子串, 构造右子树同样, 显然可以用递归方法解决。</p> 
<p>建立完二叉树之后，很容易建立三个函数用递归的算法遍历输出已经建立的二叉树的前中后三种序列，对于凹入法，可以基于前序遍历输出，在输出的时候控制格式，即根据层高判断字符前面输出的空格数，在字符后输出与空格对应的点或其他字符，保持总的字符数不变。<br> <img src="https://images2.imgbox.com/80/3a/IY7HSCku_o.png" alt="在这里插入图片描述"></p> 
<p></p> 
<h3><a id="32__43"></a>3.2 详细设计</h3> 
<h4><a id="1_44"></a>1.类的设计</h4> 
<p>由于本算法基于树来实现，首先要设计树的节点类，包括数据域和指针域，指针域包括左子树和右子树。树类包括一个指向树的节点类的指针和其他若干函数</p> 
<h4><a id="2%09_47"></a>2. 遍历函数设计</h4> 
<pre><code class="prism language-cpp"><span class="token keyword">void</span> <span class="token function">PreOrderTraverse</span><span class="token punctuation">(</span>BiNode<span class="token operator">*</span> t<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token keyword">if</span> <span class="token punctuation">(</span>t <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span> <span class="token keyword">return</span><span class="token punctuation">;</span>	
		cout <span class="token operator">&lt;&lt;</span> t<span class="token operator">-&gt;</span>Data<span class="token punctuation">;</span>
		<span class="token function">PreOrderTraverse</span><span class="token punctuation">(</span>t<span class="token operator">-&gt;</span>L_Child<span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token function">PreOrderTraverse</span><span class="token punctuation">(</span>t<span class="token operator">-&gt;</span>R_Child<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token comment">//前序遍历</span>
</code></pre> 
<p>遍历的算法如上，基于递归的思想，首先把t等于NULL作为递归出口<br> 输出当前数据之后，依次递归访问左孩子和右孩子<br> 对于中序和后续遍历仅需改变输出语句与访问左右孩子的顺序</p> 
<h4><a id="3%09_63"></a>3. 创建二叉树函数设计</h4> 
<p>void CreateBiTree(BiNode* t, string Pres, string Ins)//t为要建立的二叉树,pres和ins分别为前序和中序序列</p> 
<pre><code class="prism language-cpp"><span class="token punctuation">{<!-- --></span>
	<span class="token keyword">if</span> <span class="token punctuation">(</span>Pres<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span> t <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span> <span class="token keyword">return</span><span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token comment">//递归出口：当前前序序列长度为零</span>

	<span class="token comment">//前序序列的第一位Pres[0]即为根</span>
	<span class="token keyword">int</span> Location <span class="token operator">=</span> Ins<span class="token punctuation">.</span><span class="token function">find</span><span class="token punctuation">(</span>Pres<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//根在中序序列中的位置，以此位置把中序序列分开</span>
	string L_In <span class="token operator">=</span> Ins<span class="token punctuation">.</span><span class="token function">substr</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> Location<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//左孩子的中序序列</span>
	string R_In <span class="token operator">=</span> Ins<span class="token punctuation">.</span><span class="token function">substr</span><span class="token punctuation">(</span>Location <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//右孩子的中序序列</span>
	<span class="token keyword">int</span> L_length <span class="token operator">=</span> L_In<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//左孩子的长度即左子树节点个数</span>

	<span class="token comment">//在原前序序列中 按顺序 提取出子树节点个数个字符  当作对应子树新的前序序列</span>
	string L_Pre <span class="token operator">=</span> Pres<span class="token punctuation">.</span><span class="token function">substr</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> L_length<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//左孩子的前序序列</span>
	string R_Pre <span class="token operator">=</span> Pres<span class="token punctuation">.</span><span class="token function">substr</span><span class="token punctuation">(</span><span class="token number">1</span> <span class="token operator">+</span> L_length<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//右孩子的前序序列</span>

	t<span class="token operator">-&gt;</span>Data<span class="token operator">=</span>Pres<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token comment">//当前前序序列的首位赋给t的data</span>

	<span class="token keyword">if</span><span class="token punctuation">(</span>L_Pre<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
	t<span class="token operator">-&gt;</span>L_Child <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token function">BiNode</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token function">CreateBiTree</span><span class="token punctuation">(</span>t<span class="token operator">-&gt;</span>L_Child<span class="token punctuation">,</span> L_Pre<span class="token punctuation">,</span> L_In<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//递归创建左孩子</span>
	<span class="token punctuation">}</span>
	<span class="token keyword">if</span><span class="token punctuation">(</span>R_Pre<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
	t<span class="token operator">-&gt;</span>R_Child <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token function">BiNode</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token function">CreateBiTree</span><span class="token punctuation">(</span>t<span class="token operator">-&gt;</span>R_Child<span class="token punctuation">,</span> R_Pre<span class="token punctuation">,</span> R_In<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//递归创建右孩子</span>
	<span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>创建二叉树的算法如上，表示图如下： <img src="https://images2.imgbox.com/70/b8/qsnKkrb8_o.png" alt="在这里插入图片描述"></p> 
<h4><a id="4_95"></a>4.凹入法输出设计</h4> 
<pre><code class="prism language-cpp"><span class="token keyword">void</span> <span class="token function">Concave</span><span class="token punctuation">(</span>BiNode<span class="token operator">*</span> p<span class="token punctuation">,</span> string ss<span class="token punctuation">,</span> string RR<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token keyword">if</span> <span class="token punctuation">(</span>p <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span>   <span class="token keyword">return</span><span class="token punctuation">;</span> <span class="token comment">//递归出口</span>

	ss <span class="token operator">+=</span> <span class="token string">"   "</span><span class="token punctuation">;</span><span class="token comment">//用来控制格式，每次多输出三个空格</span>
	RR <span class="token operator">=</span> RR<span class="token punctuation">.</span><span class="token function">substr</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//用来控制格式,字符后输出特定的符号，并保证最后一位对齐</span>
	cout <span class="token operator">&lt;&lt;</span> ss <span class="token operator">&lt;&lt;</span> p<span class="token operator">-&gt;</span>Data <span class="token operator">&lt;&lt;</span> RR <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
	<span class="token function">Concave</span><span class="token punctuation">(</span>p<span class="token operator">-&gt;</span>L_Child<span class="token punctuation">,</span> ss<span class="token punctuation">,</span>RR<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token function">Concave</span><span class="token punctuation">(</span>p<span class="token operator">-&gt;</span>R_Child<span class="token punctuation">,</span> ss<span class="token punctuation">,</span>RR<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>凹入法打印二叉树的算法如上：主函数调用的语句如下<br> Concave(TreeRoot, “”, “…”);</p> 
<h2><a id="_115"></a>四、测试数据及测试结果：</h2> 
<p>测试输入：前序序列为<em>ab，中序序列为a</em>b 。<br> 测试目的：设计该输入的目的在于测试程序在哪方面可能存在漏洞；<br> 实际输出：经检验该输出符合预期的要求<img src="https://images2.imgbox.com/19/cf/hcvjgqor_o.png" alt="在这里插入图片描述"></p> 
<p>测试输入：前序序列为ABDEGCFHIJ，中序序列为DBGEAHFIJC。<br> 测试目的：设计该输入的目的在于测试程序在哪方面可能存在漏洞；<br> 实际输出：经检验该输出符合预期的要求<br> <img src="https://images2.imgbox.com/5f/e3/lxGG9J7c_o.png" alt="在这里插入图片描述"></p> 
<p>测试输入：前序序列为-<em>+abc/de，中序序列为a+b</em>c-d/e 。<br> 测试目的：设计该输入的目的在于测试程序在哪方面可能存在漏洞；<br> 实际输出：经检验该输出符合预期的要求<br> <img src="https://images2.imgbox.com/3e/1f/rjsn5guW_o.png" alt="在这里插入图片描述"></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/ad9c7d9af724b29c63039c873789c8ba/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">统一结果返回、请求</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/df55550effc65983feed45a29b072b07/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">4种JavaScript实现千位分隔符的方法</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>