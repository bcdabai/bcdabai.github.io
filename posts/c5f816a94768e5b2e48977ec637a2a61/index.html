<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>单缓冲区和双缓冲区 - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="单缓冲区和双缓冲区" />
<meta property="og:description" content="单缓冲区 在单缓冲情况下，每当用户进程发出一I/O请求时，OS便在主存中为之分配一缓冲区。在块设备输入时，假定从磁盘把一块数据输入到缓冲区的时间为T,OS将该缓冲区中的数据传送到用户区的时间为M，而CPU对这一块数据的处理时间为C，T和C是可以并行的，所以系统对每一块数据的处理时间为MAX（T,C）&#43;M
双缓冲区 由于缓冲区是共享资源，生产者与消费者在使用缓冲区时必须互斥。
如果消费者尚未取走缓冲区的数据，生产者又生产新的数据，也无法将它送入缓冲区，所以设置两个缓冲区。
双缓冲机制（缓冲对换）：在设备输入时，先将数据送入第一缓冲区，装满后转向第二缓冲区。在双缓冲时，系统处理一块数据的时间可以粗略地认为是MAX（C,T）
在两台机器中，都设置两个缓冲区，一个是发送缓冲区，一个是接收缓冲区
环形缓冲区 当输入与输出的速度基本相匹配时，采用双缓冲能获得较好的效果，可使生产者和消费者基本上能并行操作。但当两者的速度相差很远时，双缓冲的效果很不理想，所以引入环形缓冲区
环形缓冲区：
在环形缓冲区中包括多个缓冲区，每个缓冲区的大小相同，作为输入的多缓冲区可分为3类：用于装输入数据的空缓冲区，已装满数据的缓冲区G，计算进程正在使用的现行工作缓冲区C。
缓冲池 既可以用于输入也可以用于输出的公用缓冲池，在池中设置了多个可供若干个进程共享的缓冲区。
缓冲池和缓冲区的区别：缓冲区仅仅是一组内存块的链表，而缓冲池则是包含了一个管理的数据结构以及一组操作函数的管理机制，用于管理多个缓冲区" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/c5f816a94768e5b2e48977ec637a2a61/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2020-07-24T15:26:55+08:00" />
<meta property="article:modified_time" content="2020-07-24T15:26:55+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">单缓冲区和双缓冲区</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <h3><a id="_0"></a>单缓冲区</h3> 
<p>在单缓冲情况下，每当用户进程发出一I/O请求时，OS便在主存中为之分配一缓冲区。在块设备输入时，假定从磁盘把一块数据输入到缓冲区的时间为T,OS将该缓冲区中的数据传送到用户区的时间为M，而CPU对这一块数据的处理时间为C，<strong>T和C是可以并行的</strong>，所以系统对每一块数据的处理时间为MAX（T,C）+M</p> 
<h3><a id="_4"></a>双缓冲区</h3> 
<p>由于缓冲区是共享资源，生产者与消费者在使用缓冲区时必须互斥。<br> 如果消费者尚未取走缓冲区的数据，生产者又生产新的数据，也无法将它送入缓冲区，所以设置两个缓冲区。<br> 双缓冲机制（缓冲对换）：在设备输入时，先将数据送入第一缓冲区，装满后转向第二缓冲区。在双缓冲时，系统处理一块数据的时间可以粗略地认为是MAX（C,T）<br> 在两台机器中，都设置两个缓冲区，一个是发送缓冲区，一个是接收缓冲区</p> 
<h3><a id="_9"></a>环形缓冲区</h3> 
<p>当输入与输出的速度基本相匹配时，采用双缓冲能获得较好的效果，可使生产者和消费者基本上能并行操作。但当两者的速度相差很远时，双缓冲的效果很不理想，所以引入环形缓冲区</p> 
<p>环形缓冲区：<br> 在环形缓冲区中包括多个缓冲区，每个缓冲区的大小相同，作为输入的多缓冲区可分为3类：用于装输入数据的空缓冲区，已装满数据的缓冲区G，计算进程正在使用的现行工作缓冲区C。</p> 
<h3><a id="_15"></a>缓冲池</h3> 
<p>既可以用于输入也可以用于输出的公用缓冲池，在池中设置了多个可供若干个进程共享的缓冲区。</p> 
<p><strong>缓冲池和缓冲区的区别：缓冲区仅仅是一组内存块的链表，而缓冲池则是包含了一个管理的数据结构以及一组操作函数的管理机制，用于管理多个缓冲区</strong></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/382b6f1f898487bde510c009437756b4/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">sigmoid和softmax</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/114b54654848a8b7d4a8b53d50e9fc69/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">对CephFS进行性能测试</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>