<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Go七天实现RPC - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Go七天实现RPC" />
<meta property="og:description" content="0.前言 本文是学习自7天用Go从零实现RPC框架GeeRPC | 极客兔兔
在此基础上，加入自己的学习过程与理解。
1.RPC 框架 RPC(Remote Procedure Call，远程过程调用)是一种计算机通信协议，允许调用不同进程空间的程序。RPC 的客户端和服务器可以在一台机器上，也可以在不同的机器上。程序员使用时，就像调用本地程序一样，无需关注内部的实现细节。
简单点说，是两个 不同的进程 之间进行信息的交换, 而这两个进程有可能分布在 不同的机器 上。 那就需要进行网络通信，那常用的就有HTTP协议。
2.为什么需要RPC 怎么理解rpc，既然有http请求了为啥还要用rpc？ - 知乎
怎么理解rpc，既然有http请求了为啥还要用rpc？ - 知乎
知乎上的两个回答。
大多数人疑惑既然有HTTP请求可以解决系统间调用的问题了，为什么还会有人使用RPC调用？
而RPC是先于HTTP出现的。
这两个都有各自的用途。RPC更合适用在分布式中。一般来说，RPC的性能比HTTP会更强，大多数RPC框架也提供了很多功能，
在发起下游调用的时候，有时需要做一些功能。比如我们想统计一下下游每个接口调用的耗时、超时、异常情况，这个时候就使用rpc框架非常方便了，因为大多数的rpc框架都会提供一个事件或者钩子给我们，我们就能很方便的做这些事情。除此之外，很多rpc框架还提供了强大而精准的限流、熔断等能力。
而HTTP协议在1990年才开始作为主流协议出现，而且HTTP发明的场景是用于web架构。而现在大部分的系统都是给浏览器使用的，因此HTTP协议必不可少，一些小公司用HTTP也容易搭建自己的架构，成本也低，也好维护。
3.实现RPC Go 语言广泛地应用于云计算和微服务，成熟的 RPC 框架和微服务框架汗牛充栋。grpc、rpcx等都是非常成熟的框架。一般而言，RPC 是微服务框架的一个子集，微服务框架可以自己实现 RPC 部分，当然，也可以选择不同的 RPC 框架作为通信基座。
考虑性能和功能，上述成熟的框架代码量都比较庞大，而且通常和第三方库，例如 protobuf、etcd等有比较深的耦合，难以直观地窥视框架的本质。该RPC 的目的是以最少的代码，实现 RPC 框架中最为重要的部分，帮助大家理解 RPC 框架在设计时需要考虑什么。代码简洁是第一位的，功能是第二位的。
因此，我们选择从零实现 Go 语言官方的标准库 net/rpc，并在此基础上，新增了协议交换(protocol exchange)、注册中心(registry)、服务发现(service discovery)、负载均衡(load balance)、超时处理(timeout processing)等特性。
每个版本的讲解
PRC教程 1.服务端与消息编码
RPC教程 2.支持并发与异步的客户端
RPC教程 3.服务注册
RPC教程 4.超时处理机制
完整代码： https://github.com/liwook/Go-projects/tree/main/geerpc" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/af6afc010be2998820f6c1122ab01ae4/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2024-01-22T10:13:18+08:00" />
<meta property="article:modified_time" content="2024-01-22T10:13:18+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Go七天实现RPC</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <h3>0.前言</h3> 
<p>本文是学习自<a href="https://geektutu.com/post/geerpc.html" rel="nofollow" title="7天用Go从零实现RPC框架GeeRPC | 极客兔兔">7天用Go从零实现RPC框架GeeRPC | 极客兔兔</a></p> 
<p>在此基础上，加入自己的学习过程与理解。</p> 
<h3>1.RPC 框架</h3> 
<p>RPC(Remote Procedure Call，远程过程调用)是一种计算机通信协议，允许调用不同进程空间的程序。RPC 的客户端和服务器可以在一台机器上，也可以在不同的机器上。程序员使用时，就像调用本地程序一样，无需关注内部的实现细节。</p> 
<p>简单点说，是两个 <strong>不同的进程</strong> 之间进行信息的交换, 而这两个进程有可能分布在 <strong>不同的机器</strong> 上。 那就需要进行网络通信，那常用的就有HTTP协议。</p> 
<h3>2.为什么需要RPC</h3> 
<p><a href="https://www.zhihu.com/question/524580708/answer/2414340752" rel="nofollow" title="怎么理解rpc，既然有http请求了为啥还要用rpc？ - 知乎">怎么理解rpc，既然有http请求了为啥还要用rpc？ - 知乎</a></p> 
<p><a href="https://www.zhihu.com/question/524580708/answer/3009948794" rel="nofollow" title="怎么理解rpc，既然有http请求了为啥还要用rpc？ - 知乎">怎么理解rpc，既然有http请求了为啥还要用rpc？ - 知乎</a></p> 
<p> 知乎上的两个回答。</p> 
<p>大多数人疑惑既然有HTTP请求可以解决系统间调用的问题了，为什么还会有人使用RPC调用？</p> 
<p>而RPC是先于HTTP出现的。</p> 
<p>这两个都有各自的用途。RPC更合适用在分布式中。一般来说，RPC的性能比HTTP会更强，大多数RPC框架也提供了很多功能，</p> 
<p>在发起下游调用的时候，有时需要做一些功能。比如我们想统计一下下游每个接口调用的耗时、超时、异常情况，这个时候就使用rpc框架非常方便了，因为大多数的rpc框架都会提供一个事件或者钩子给我们，我们就能很方便的做这些事情。除此之外，很多rpc框架还提供了强大而精准的限流、熔断等能力。</p> 
<p>而HTTP协议在1990年才开始作为主流协议出现，而且HTTP发明的场景是用于web架构。而现在大部分的系统都是给浏览器使用的，因此HTTP协议必不可少，一些小公司用HTTP也容易搭建自己的架构，成本也低，也好维护。</p> 
<h3>3.实现RPC</h3> 
<p>Go 语言广泛地应用于云计算和微服务，成熟的 RPC 框架和微服务框架汗牛充栋。<code>grpc</code>、<code>rpcx</code>等都是非常成熟的框架。一般而言，RPC 是微服务框架的一个子集，微服务框架可以自己实现 RPC 部分，当然，也可以选择不同的 RPC 框架作为通信基座。</p> 
<p>考虑性能和功能，上述成熟的框架代码量都比较庞大，而且通常和第三方库，例如 <code>protobuf</code>、<code>etcd</code>等有比较深的耦合，难以直观地窥视框架的本质。该RPC 的目的是以最少的代码，实现 RPC 框架中最为重要的部分，帮助大家理解 RPC 框架在设计时需要考虑什么。<strong>代码简洁是第一位的</strong>，功能是第二位的。</p> 
<p>因此，我们选择<strong>从零实现 Go 语言官方的标准库 <code>net/rpc</code></strong>，并在此基础上，新增了<strong>协议交换(protocol exchange)</strong>、<strong>注册中心(registry)</strong>、<strong>服务发现(service discovery)</strong>、<strong>负载均衡(load balance)</strong>、<strong>超时处理(timeout processing)</strong>等特性。</p> 
<p></p> 
<p>每个版本的讲解</p> 
<p><a class="link-info" href="https://blog.csdn.net/m0_57408211/article/details/135015739?csdn_share_tail=%7B%22type%22%3A%22blog%22%2C%22rType%22%3A%22article%22%2C%22rId%22%3A%22135015739%22%2C%22source%22%3A%22m0_57408211%22%7D" title="PRC教程 1.服务端与消息编码">PRC教程 1.服务端与消息编码</a></p> 
<p><a class="link-info" href="https://blog.csdn.net/m0_57408211/article/details/135076881" title="RPC教程 2.支持并发与异步的客户端">RPC教程 2.支持并发与异步的客户端</a></p> 
<p><a class="link-info" href="https://blog.csdn.net/m0_57408211/article/details/135086501?csdn_share_tail=%7B%22type%22%3A%22blog%22%2C%22rType%22%3A%22article%22%2C%22rId%22%3A%22135086501%22%2C%22source%22%3A%22m0_57408211%22%7D" title="RPC教程 3.服务注册">RPC教程 3.服务注册</a></p> 
<p><a class="link-info" href="https://blog.csdn.net/m0_57408211/article/details/135386433?csdn_share_tail=%7B" title="RPC教程 4.超时处理机制">RPC教程 4.超时处理机制</a></p> 
<p></p> 
<p>完整代码： <a class="link-info" href="https://github.com/liwook/Go-projects/tree/main/geerpc" title="https://github.com/liwook/Go-projects/tree/main/geerpc">https://github.com/liwook/Go-projects/tree/main/geerpc</a></p> 
<p></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/a634f6c60d672f81c0d21c89ce59202f/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">RPC教程 4.超时处理机制</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/b448988d642495e6d47a21b7a0db7e4e/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">数据分析的理念、流程、方法、工具（上）</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>