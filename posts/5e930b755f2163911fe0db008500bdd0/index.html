<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>【ASP.NET】终于知道通过ajax异步为什么无法实现模型自动验证了，探索模型验证方法 - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="【ASP.NET】终于知道通过ajax异步为什么无法实现模型自动验证了，探索模型验证方法" />
<meta property="og:description" content="一般的，我们在添加信息时，可以通过ModelState快速实现模型验证
[HttpPost] [ValidateAntiForgeryToken] public ActionResult Create(UserInfo userInfo) { if (ModelState.IsValid) { db.UserInfo.Add(userInfo); db.SaveChanges(); return RedirectToAction(&#34;Index&#34;); } return View(userInfo); } 效果，自动验证
但是，改用ajax异步操作，就无法通过模型自动验证了
ASP.NET实现ajax异步，要添加jquery.unobtrusive-ajax.js文件，只需在NuGet搜索下载即可
添加引用
&lt;script src=&#34;~/Scripts/jquery.unobtrusive-ajax.js&#34;&gt;&lt;/script&gt; 在视图中，需要将@using (Html.BeginForm()) 改为 @using (Ajax.BeginForm())，
@using (Ajax.BeginForm(&#34;VerifyUser&#34;, &#34;UserInfo&#34;, new AjaxOptions() { OnSuccess = &#34;afterCreate&#34; }, new { @class = &#34;form-signin&#34; })) 然后点击确定按钮提交表单，却一直无反应，试过很多次还是无反应
分析 后面，想着想着才知道这是操作，就是视图局部更新，而上面同步的操作，当模型验证失败时通过在整个视图添加错误信息到达验证模型的效果，而异步操作就是局部更新，当然不会执行整个视图的更新，只能通过js代码执行更新操作
当执行后台方法VerifyUser后执行afterLogin方法
对Create方法进行改造
[HttpPost] [ValidateAntiForgeryToken] public ActionResult Create(UserInfo userInfo) { if (ModelState.IsValid) { db.UserInfo.Add(userInfo); db.SaveChanges(); return Content(&#34;ok&#34;); } return Content(&#34;添加失败&#34;); } 当后台只有返回ok时，才执行跳转，否则则弹框提示" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/5e930b755f2163911fe0db008500bdd0/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2020-02-28T23:52:09+08:00" />
<meta property="article:modified_time" content="2020-02-28T23:52:09+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">【ASP.NET】终于知道通过ajax异步为什么无法实现模型自动验证了，探索模型验证方法</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p>一般的，我们在添加信息时，可以通过ModelState快速实现模型验证</p> 
<pre><code class="language-cs">[HttpPost]
[ValidateAntiForgeryToken]
public ActionResult Create(UserInfo userInfo)
{
    if (ModelState.IsValid)
    {
        db.UserInfo.Add(userInfo);
        db.SaveChanges();
        return RedirectToAction("Index");
    }
 
    return View(userInfo);
}</code></pre> 
<p>效果，自动验证</p> 
<p><img alt="" height="75" src="https://images2.imgbox.com/43/f4/okHEfr9T_o.png" width="333"></p> 
<p>但是，改用ajax异步操作，就无法通过模型自动验证了</p> 
<p> </p> 
<p>ASP.NET实现ajax异步，要添加<span style="color:#f33b45;">jquery.unobtrusive-ajax.js</span>文件，只需在NuGet搜索下载即可</p> 
<p><img alt="" height="344" src="https://images2.imgbox.com/7e/9d/nm7XYzSg_o.png" width="298"></p> 
<p>添加引用</p> 
<pre><code class="language-html">&lt;script src="~/Scripts/jquery.unobtrusive-ajax.js"&gt;&lt;/script&gt;</code></pre> 
<p>在视图中，需要<strong><span style="color:#f33b45;">将@using (Html.BeginForm()) 改为 @using (Ajax.BeginForm())</span></strong>，</p> 
<pre><code class="language-cs"> @using (Ajax.BeginForm("VerifyUser", "UserInfo", new AjaxOptions() { OnSuccess = "afterCreate" }, new { @class = "form-signin" }))</code></pre> 
<p>然后点击确定按钮提交表单，却一直无反应，试过很多次还是无反应</p> 
<h4> </h4> 
<h4><span style="color:#f33b45;">分析</span></h4> 
<p><span style="color:#f33b45;">后面，想着想着才知道这是操作，就是视图局部更新，而上面同步的操作，当模型验证失败时通过在整个视图添加错误信息到达验证模型的效果，而异步操作就是局部更新，当然不会执行整个视图的更新，只能通过js代码执行更新操作</span></p> 
<p> </p> 
<p>当执行后台方法VerifyUser后执行afterLogin方法</p> 
<p>对Create方法进行改造</p> 
<pre><code class="language-cs">[HttpPost]
[ValidateAntiForgeryToken]
public ActionResult Create(UserInfo userInfo)
{
    if (ModelState.IsValid)
    {
        db.UserInfo.Add(userInfo);
        db.SaveChanges();
        return Content("ok");
    }
 
    return Content("添加失败");
}</code></pre> 
<p>当后台只有返回ok时，才执行跳转，否则则弹框提示</p> 
<pre><code class="language-cs">&lt;script type="text/javascript"&gt;
    function afterCreate(data) {
        if (data == "ok")
            window.location.href = "@Url.Action("Index","UserInfo")";
        else
            alert(data);
    }
&lt;/script&gt;
</code></pre> 
<p>完成<br>  </p> 
<hr> 
<p><span style="color:#f33b45;"><strong>2020-03-08</strong></span></p> 
<p>后面在B站看MVC博客项目实战时，学习到可以直接在后台添加异步操作，直接在Action改为异步操作即可</p> 
<pre><code class="language-cs">[HttpPost]
[ValidateAntiForgeryToken]
public async Task&lt;ActionResult&gt; Create(UserInfo userInfo)
{
    if (ModelState.IsValid)
    {
        db.UserInfo.Add(userInfo);
        await db.SaveChangesAsync();
        return RedirectToAction("Index");
    }
 
    return View(userInfo);
}</code></pre> 
<p>视图中的表单还是用@using (Html.BeginForm())即可</p> 
<p> </p> 
<hr> 
<p><span style="color:#f33b45;"><strong>2020-03-10</strong></span></p> 
<p>使用上面的方法，发现如果是自己添加的错误，即是</p> 
<pre><code class="language-cs">public  async Task&lt;ActionResult&gt; Create(UserInfo userInfo)
{
    if (ModelState.IsValid == true)
    {
        //是否存在相同用户名
        if (await UserInfoService.GetEntities(u =&gt; u.Name == userInfo.Name).FirstOrDefaultAsync() != null)
        {
            ModelState.AddModelError("Name", "存在相同用户名");
            ViewBag.Sexs = GetSexs();
            return View(userInfo);
        }

        UserInfoService.Add(userInfo);
        return RedirectToAction("Index");
    }

    ViewBag.Sexs = GetSexs();
    return View(userInfo);
}
</code></pre> 
<p>这样无法到达异步效果，提示“存在相同用户”时，界面还是会全部刷新</p> 
<p>还是将操作改为非异步</p> 
<pre><code class="language-cs">public   ActionResult Create(UserInfo userInfo)
{
    if (ModelState.IsValid == true)
    {
        //是否存在相同用户名
        if (UserInfoService.GetEntities(u =&gt; u.Name == userInfo.Name).FirstOrDefault() != null)
        {
            return Content("存在相同用户名");
        }

        UserInfoService.Add(userInfo);
        return Content("ok");
    }

    return Content(ModelState.GetErrorMessage());
}

</code></pre> 
<p>使用异步表单</p> 
<pre><code class="language-cs">@using (Ajax.BeginForm("Create", "UserInfo", new AjaxOptions() { OnSuccess = "afterCreate" }))</code></pre> 
<p>添加js脚本</p> 
<pre><code class="language-cs">&lt;script src="~/Scripts/jquery.unobtrusive-ajax.js"&gt;&lt;/script&gt;
&lt;script type="text/javascript"&gt;
    function afterCreate(data) {
        if (data == "ok") {
            $(location).attr('href', '/UserInfo/Index');
        }
        else {
            //弹框提示
            $("#MessageBox-info-text").text(data);
            $("#MessageBox-info").modal("show");
        }
    }
&lt;/script&gt;
</code></pre> 
<p>在这里注意去除@Scripts.Render("~/bundles/jqueryval")脚本，不然还是会使用上面的脚本验证</p> 
<p> </p> 
<p>@Scripts.Render("~/bundles/jqueryval")中，实际起作用的就是下面两个脚本</p> 
<pre><code class="language-javascript">&lt;script src="~/Scripts/jquery.validate.js"&gt;&lt;/script&gt;
&lt;script src="~/Scripts/jquery.validate.unobtrusive.js"&gt;&lt;/script&gt;</code></pre> 
<p><br> 其实可以将@Scripts.Render("~/bundles/jqueryval")和 &lt;script src="~/Scripts/jquery.unobtrusive-ajax.js"&gt;&lt;/script&gt;同时使用</p> 
<p>先验证模型自身的状态，在验证业务逻辑的正确性，一个是直接在页面显示，一个是弹框提示，当然也可以通过js统一提示</p> 
<p> </p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/86ee5eae8c7581e5756ae78cd669d6af/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">C#学习笔记： 学习资源分享</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/c56a9457e75f90920545c0fc17e693dd/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">Tensorflow2中load_weights的一些研究</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>