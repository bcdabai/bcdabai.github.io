<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Go项目配置管理神器之viper使用详解 - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Go项目配置管理神器之viper使用详解" />
<meta property="og:description" content="作者：程序员CKeen
博客：http://ckeen.cn​​​​​​​​​​​​​​​​​​​​​
长期坚持做有价值的事！积累沉淀，持续成长，升维思考！希望把编码作为长期兴趣爱好😄
目录
1. viper的介绍
2. viper的使用
2.1 Viper对象的创建
2.2 预设默认配置。 2.3 从命令行工具的选项参数Flags读取
2.4 从环境变量读取
2.5 从配置文件读取
2.6 从远程key/value存储读取
2.7 监听配置变化
2.8 写入配置到文件
3. 源码分析--配置读取的顺序
4. 参考资料​​​​​​​
1. viper的介绍 viper是go一个强大的流行的配置解决方案的库。viper是spf13的另外一个重量级库。有大量项目都使用该库，比如hugo, docker等。 它基本上可以处理所有类型的配置需求和格式, viper支持功能
设置默认配置支持各种配置文件，如JSON，TOML, YAML, HCL, envfile和Java属性配置文件支持监听文件变化以及重新读取配置支持从环境变量读取配置支持从远程配置系统(etcd或Consul)读取配置，并能监听远程配置修改支持从命令行标志Flag读取配置，比如搭配cobra使用支持读取缓冲区数据 Viper主要为我们做以下工作:
查找、加载和解组JSON、TOML、YAML、HCL、INI、envfile或Java属性格式的配置文件。提供一种机制来为不同的配置选项设置默认值。提供一种机制来为通过命令行标志指定的选项设置覆盖值。提供别名系统，以便在不破坏现有代码的情况下轻松重命名参数。当用户提供了与默认值相同的命令行或配置文件时，很容易区分它们。 viepr的安装很简单，直接再工程中使用go get命令安装即可
$ go get github.com/spf13/viper 2. viper的使用 2.1 Viper对象的创建 Viper的是viper库的主要实现对象, viper提供了下面的方法可以获取Viper实例：
func GetViper() *Viper func New() *Viper func NewWithOptions(opts ...Option) *Viper func Sub(key string) *Viper 使用viper.GetViper()获取的为全局的Viper实例对象,默认使用viper包使用也是该全局Viper实例。查看viper的源码，可以看到viper默认提供了一个全局的Viper实例： var v *Viper func init() { v = New() } // New returns an initialized Viper instance." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/823362637ee39e45d392f344950e97d9/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-06-27T13:54:55+08:00" />
<meta property="article:modified_time" content="2023-06-27T13:54:55+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Go项目配置管理神器之viper使用详解</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p>作者：程序员CKeen<br> 博客：<a href="http://www.ckeen.cn/" rel="nofollow" title="http://ckeen.cn​​​​​​​">http://ckeen.cn​​​​​​​</a>​​​​​​​​​​​​​​</p> 
<blockquote> 
 <p>长期坚持做有价值的事！积累沉淀，持续成长，升维思考！希望把编码作为长期兴趣爱好😄</p> 
</blockquote> 
<p id="main-toc"><strong>目录</strong></p> 
<p id="1.%20viper%E7%9A%84%E4%BB%8B%E7%BB%8D-toc" style="margin-left:40px;"><a href="#1.%20viper%E7%9A%84%E4%BB%8B%E7%BB%8D" rel="nofollow">1. viper的介绍</a></p> 
<p id="2.%20viper%E7%9A%84%E4%BD%BF%E7%94%A8-toc" style="margin-left:40px;"><a href="#2.%20viper%E7%9A%84%E4%BD%BF%E7%94%A8" rel="nofollow">2. viper的使用</a></p> 
<p id="2.1%20%C2%A0Viper%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%88%9B%E5%BB%BA-toc" style="margin-left:80px;"><a href="#2.1%20%C2%A0Viper%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%88%9B%E5%BB%BA" rel="nofollow">2.1  Viper对象的创建</a></p> 
<p id="2.2%C2%A0%E9%A2%84%E8%AE%BE%E4%B8%80%E4%BA%9B%E9%BB%98%E8%AE%A4%E9%85%8D%E7%BD%AE-toc" style="margin-left:80px;"><a href="#2.2%C2%A0%E9%A2%84%E8%AE%BE%E4%B8%80%E4%BA%9B%E9%BB%98%E8%AE%A4%E9%85%8D%E7%BD%AE" rel="nofollow">2.2 预设默认配置。 </a></p> 
<p id="2.3%C2%A0%E4%BB%8E%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%B7%A5%E5%85%B7%E7%9A%84%E9%80%89%E9%A1%B9%E5%8F%82%E6%95%B0Flags%E8%AF%BB%E5%8F%96-toc" style="margin-left:80px;"><a href="#2.3%C2%A0%E4%BB%8E%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%B7%A5%E5%85%B7%E7%9A%84%E9%80%89%E9%A1%B9%E5%8F%82%E6%95%B0Flags%E8%AF%BB%E5%8F%96" rel="nofollow">2.3 从命令行工具的选项参数Flags读取</a></p> 
<p id="2.4%C2%A0%E4%BB%8E%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F%E8%AF%BB%E5%8F%96-toc" style="margin-left:80px;"><a href="#2.4%C2%A0%E4%BB%8E%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F%E8%AF%BB%E5%8F%96" rel="nofollow">2.4 从环境变量读取</a></p> 
<p id="2.5%C2%A0%E4%BB%8E%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E8%AF%BB%E5%8F%96-toc" style="margin-left:80px;"><a href="#2.5%C2%A0%E4%BB%8E%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E8%AF%BB%E5%8F%96" rel="nofollow">2.5 从配置文件读取</a></p> 
<p id="2.6%C2%A0%E4%BB%8E%E8%BF%9C%E7%A8%8Bkey%2Fvalue%E5%AD%98%E5%82%A8%E8%AF%BB%E5%8F%96-toc" style="margin-left:80px;"><a href="#2.6%C2%A0%E4%BB%8E%E8%BF%9C%E7%A8%8Bkey%2Fvalue%E5%AD%98%E5%82%A8%E8%AF%BB%E5%8F%96" rel="nofollow">2.6 从远程key/value存储读取</a></p> 
<p id="2.7%C2%A0%E7%9B%91%E5%90%AC%E9%85%8D%E7%BD%AE%E5%8F%98%E5%8C%96-toc" style="margin-left:80px;"><a href="#2.7%C2%A0%E7%9B%91%E5%90%AC%E9%85%8D%E7%BD%AE%E5%8F%98%E5%8C%96" rel="nofollow">2.7 监听配置变化</a></p> 
<p id="2.8%20%E5%86%99%E5%85%A5%E9%85%8D%E7%BD%AE%E5%88%B0%E6%96%87%E4%BB%B6-toc" style="margin-left:80px;"><a href="#2.8%20%E5%86%99%E5%85%A5%E9%85%8D%E7%BD%AE%E5%88%B0%E6%96%87%E4%BB%B6" rel="nofollow">2.8 写入配置到文件</a></p> 
<p id="3.%C2%A0%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90--%E9%85%8D%E7%BD%AE%E8%AF%BB%E5%8F%96%E7%9A%84%E9%A1%BA%E5%BA%8F-toc" style="margin-left:40px;"><a href="#3.%C2%A0%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90--%E9%85%8D%E7%BD%AE%E8%AF%BB%E5%8F%96%E7%9A%84%E9%A1%BA%E5%BA%8F" rel="nofollow">3. 源码分析--配置读取的顺序</a></p> 
<p id="4.%20%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99-toc" style="margin-left:40px;"><a href="#4.%20%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99" rel="nofollow">4. 参考资料</a>​​​​​​​</p> 
<hr> 
<h3 id="1.%20viper%E7%9A%84%E4%BB%8B%E7%BB%8D"><strong>1. viper的介绍</strong></h3> 
<p>viper是go一个强大的流行的配置解决方案的库。viper是spf13的另外一个重量级库。有大量项目都使用该库，比如hugo, docker等。 它基本上可以处理所有类型的配置需求和格式, viper支持功能</p> 
<ul><li>设置默认配置</li><li>支持各种配置文件，如JSON，TOML, YAML, HCL, envfile和Java属性配置文件</li><li>支持监听文件变化以及重新读取配置</li><li>支持从环境变量读取配置</li><li>支持从远程配置系统(etcd或Consul)读取配置，并能监听远程配置修改</li><li>支持从命令行标志Flag读取配置，比如搭配cobra使用</li><li>支持读取缓冲区数据</li></ul> 
<p>Viper主要为我们做以下工作:</p> 
<ul><li>查找、加载和解组JSON、TOML、YAML、HCL、INI、envfile或Java属性格式的配置文件。</li><li>提供一种机制来为不同的配置选项设置默认值。</li><li>提供一种机制来为通过命令行标志指定的选项设置覆盖值。</li><li>提供别名系统，以便在不破坏现有代码的情况下轻松重命名参数。</li><li>当用户提供了与默认值相同的命令行或配置文件时，很容易区分它们。</li></ul> 
<p>viepr的安装很简单，直接再工程中使用go get命令安装即可</p> 
<div> 
 <pre><code>$ go get github.com/spf13/viper
</code></pre> 
</div> 
<h3 id="2.%20viper%E7%9A%84%E4%BD%BF%E7%94%A8"><a id="2_viper_37"></a>2. viper的使用</h3> 
<h4 id="2.1%20%C2%A0Viper%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%88%9B%E5%BB%BA">2.1  Viper对象的创建</h4> 
<p>Viper的是viper库的主要实现对象, viper提供了下面的方法可以获取Viper实例：</p> 
<div> 
 <pre><code class="language-Go">func GetViper() *Viper
func New() *Viper
func NewWithOptions(opts ...Option) *Viper
func Sub(key string) *Viper
</code></pre> 
</div> 
<ul><li>使用viper.GetViper()获取的为全局的Viper实例对象,默认使用viper包使用也是该全局Viper实例。查看viper的源码，可以看到viper默认提供了一个全局的Viper实例：</li></ul> 
<div> 
 <pre><code class="language-Go">var v *Viper

func init() {
	v = New()
}

// New returns an initialized Viper instance.
func New() *Viper {
	v := new(Viper)
	v.keyDelim = "."
	v.configName = "config"
	v.configPermissions = os.FileMode(0o644)
	v.fs = afero.NewOsFs()
	v.config = make(map[string]interface{})
	v.override = make(map[string]interface{})
	v.defaults = make(map[string]interface{})
	v.kvstore = make(map[string]interface{})
	v.pflags = make(map[string]FlagValue)
	v.env = make(map[string][]string)
	v.aliases = make(map[string]string)
	v.typeByDefValue = false
	v.logger = jwwLogger{}

	v.resetEncoding()

	return v
}
</code></pre> 
</div> 
<ul><li>New和NewWithOptions为我们提供了创建实例的方法。New是直接使用默认配置项进行创建，而NewWithOptions可以传入一些配置项。</li></ul> 
<div> 
 <pre><code class="language-Go">func New1() *viper.Viper {
	return viper.New()
}

func New2() *viper.Viper {
	return viper.NewWithOptions()
}
</code></pre> 
</div> 
<ul><li>Sub为我们读取子配置项提供了一个新的实例Viper，使用子配置项的Viper实例，我们可以限定他只读取该子配置项的配置。</li></ul> 
<div> 
 <pre><code class="language-Go">v := viper.Sub("db")
url := v.Get("url")
log.Printf("mysql url:%s\n", url)
</code></pre> 
</div> 
<h4 id="2.2%C2%A0%E9%A2%84%E8%AE%BE%E4%B8%80%E4%BA%9B%E9%BB%98%E8%AE%A4%E9%85%8D%E7%BD%AE">2.2 预设默认配置。 </h4> 
<div> 
 <pre><code class="language-Go">viper.SetDefault("ContentDir", "content")
viper.SetDefault("Taxonomies", map[string]string{"tag": "tags", "category": "categories"})

viper.SetDefault("redis.port", 6379)
viper.SetDefault("mysql.url", "root:root@tcp(127.0.0.1:3306)/stock?charset=utf8mb4&amp;parseTime=True&amp;loc=Local")
</code></pre> 
</div> 
<p> 我们可以将一些项目初始化的默认的配置项，直接使用默认配置。</p> 
<h4 id="2.3%C2%A0%E4%BB%8E%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%B7%A5%E5%85%B7%E7%9A%84%E9%80%89%E9%A1%B9%E5%8F%82%E6%95%B0Flags%E8%AF%BB%E5%8F%96">2.3 从命令行工具的选项参数Flags读取</h4> 
<p>viper主要提供了以下四个方法，可以绑定命令行参数的输入的选项值：</p> 
<div> 
 <pre><code class="language-Go">func (v *Viper) BindFlagValue(key string, flag FlagValue) error
func (v *Viper) BindFlagValues(flags FlagValueSet) (err error)
func (v *Viper) BindPFlag(key string, flag *pflag.Flag) error
func (v *Viper) BindPFlags(flags *pflag.FlagSet) error
</code></pre> 
</div> 
<p>这里我们主要结合之前讲的cobra库中的pflag来讲解一下viper对Flags选项参数的绑定。<br> 在cobra中，我们主要通过cobra.Command来组织不同的命令和子命令，这里我们我通过在root根命令来做测试。代码如下：</p> 
<div> 
 <pre><code class="language-Go">func init(){
	rootCmd.Flags().String("author", "YOUR NAME", "Author name for copyright attribution")
	rootCmd.Flags().String("email", "YOUR EMAIL", "Author email for contact")

	// 绑定多个key-value值
	viper.BindPFlags(rootCmd.Flags())

  // 单个绑定不同的key
	viper.BindPFlag("author", rootCmd.Flags().Lookup("author"))
	viper.BindPFlag("email", rootCmd.Flags().Lookup("email"))

	rootCmd.AddCommand(version.VersionCmd)
}
</code></pre> 
</div> 
<p>在cobra的命令的run回调方法中，我们通过viper的来获取输入的选项值</p> 
<div> 
 <pre><code class="language-Go">func run(){
	fmt.Println("go root cmd run")

	fmt.Println(viper.GetString("author"))

	fmt.Println(viper.GetString("email"))
}
</code></pre> 
</div> 
<p>启动应用，传入参数测试一下：</p> 
<div> 
 <pre><code class="language-Go">go run main.go --author ckeen --email ck@gmail.com
</code></pre> 
</div> 
<p>查看一下打印结果，可以看到从viper成功获取到以flag传入的参数值：</p> 
<div> 
 <pre><code class="language-bash">➜  cli git:(master) ✗ go run main.go --author keen --email ck@gmail.com
go root cmd run
ckeen
ck@gmail.com
</code></pre> 
</div> 
<h4 id="2.4%C2%A0%E4%BB%8E%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F%E8%AF%BB%E5%8F%96">2.4 从环境变量读取</h4> 
<p>viper支持绑定环境变量，以对环境变量进行操作。对环境变量的操作主要有以下的函数：</p> 
<div> 
 <pre><code class="language-Go">func (v *Viper) AutomaticEnv()			// 开启绑定环境变量
func (v *Viper) BindEnv(input ...string) error		// 绑定系统中某个环境变量
func (v *Viper) SetEnvKeyReplacer(r *strings.Replacer)
func (v *Viper) SetEnvPrefix(in string)
</code></pre> 
</div> 
<p>那我们是怎么对环境变量进行操作的呢？ 下面我们说一下主要的操作方法：</p> 
<ol><li>使用AutomaticEnv()开启绑定环境变量，没开启的时候不会从环境变量获取，开启后可以获取环境变量的值。如果不想开启所有环境变量值，可以使用BindEnv(input …string)方法绑定单个环境变量的绑定， 那么只有该绑定的环境变量的key才能获取到值</li><li>绑定环境变量后，可以使用正常的Get方法来获取变量值，示例代码如下： 
  <div> 
   <pre><code class="language-Go">func testEnv(){
	v := New1()

	os.Setenv("CK_HOME","123")
	os.Setenv("CK_NAME","ckeen")

	v.AutomaticEnv()
	//v.BindEnv("SHELL")
	v.AllowEmptyEnv(true)

	log.Printf("os env:%+v\n", os.Environ())

	log.Printf("env: %+v\n", v.Get("HOME"))
	log.Printf("env: %+v\n", v.Get("SHELL"))

	v.SetEnvPrefix("CK")

	log.Printf("ck-home: %+v\n", v.Get("HOME"))
	log.Printf("ck-email: %+v\n", v.Get("NAME"))

}</code></pre> 
  </div> </li><li>还可以通过SetEnvPrefix()方法设置环境变量前缀, 前缀和Key之间用下划线分割</li></ol> 
<h4 id="2.5%C2%A0%E4%BB%8E%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E8%AF%BB%E5%8F%96">2.5 从配置文件读取</h4> 
<p>我们重点讲一下操作实例的方法： </p> 
<p>先看下我们的配置文件app.yml文件：</p> 
<div> 
 <pre><code class="language-bash">app:
  name: viper-test
  mode: dev

db:
  mysql:
    url: "root:root@tcp(127.0.0.1:3306)/stock?charset=utf8mb4&amp;parseTime=True&amp;loc=Local"
  redis:
    host: 127.0.0.1
    port:  6067
    db: 0
    passwd: 123456</code></pre> 
</div> 
<p>然后我们具体来看下使用viper库实际的操作方法： </p> 
<ul><li>初始化配置 
  <div> 
   <pre><code class="language-Go">func InitConfig() (*viper.Viper, error) {
  v := viper.New()
  v.AddConfigPath(".")					// 添加配置文件搜索路径，点号为当前目录
  v.AddConfigPath("./configs")		// 添加多个搜索目录
  v.SetConfigType("yaml")				// 如果配置文件没有后缀，可以不用配置
  v.SetConfigName("app.yml")			// 文件名，没有后缀
	
	// v.SetConfigFile("configs/app.yml")
  
  // 读取配置文件
  if err := v.ReadInConfig(); err == nil {
		log.Printf("use config file -&gt; %s\n", v.ConfigFileUsed())
	} else {
		return nil,err
	}
  return v, nil
}
</code></pre> 
  </div> <p>首先这里我们添加一个配置文件搜索路径，点号表示当前路径，搜索路径可以添加多个然后设置了配置文件类型，这里我们设置文件类型为yaml，</p> <p>接着我们设置了配置文件名称，这个文件可以从配置的搜索路径从查找。</p> <p>最后我们通过提供的ReadInConfig()函数读取配置文件</p> </li><li>读取配置文件 
  <div> 
   <pre><code class="language-Go">// 通过.号来区分不同层级，来获取配置值
log.Printf("app.mode=%s\n", v.Get("app.mode"))
log.Printf("db.mysql.url=%s\n", v.Get("db.mysql.url"))
log.Printf("db.redis.host=%s\n", v.GetString("db.redis.host"))
log.Printf("db.redis.port=%d\n", v.GetInt("db.redis.port"))

// 使用Sub获取子配置，然后获取配置值
v2 := v.Sub("db")
log.Printf("db.mysql.url:%s\n", v2.Sub("mysql").GetString("url"))
log.Printf("db.redis.host:%s\n", v2.Sub("redis").GetString("host"))
log.Printf("db.redis.port:%s\n", v2.Sub("redis").GetInt("port"))</code></pre> 
  </div> <p>这里我们就可以使用viper提供的不同的方法来读取配置值，多层级的的配置项我们使用点号进行区分。除了上面这些方法，viper还提供了如下获取类型获取配置项值：<br><img alt="" height="503" src="https://images2.imgbox.com/08/b1/eUsUYZ1r_o.png" width="558">​</p> <p> <strong>注： 其中重要的一个函数IsSet可以用来判断某个key是否被设置</strong></p> </li></ul> 
<p> viper库提供了不同的类型的函数，来方便我们读取不同数据类型的配置。</p> 
<h4 id="2.6%C2%A0%E4%BB%8E%E8%BF%9C%E7%A8%8Bkey%2Fvalue%E5%AD%98%E5%82%A8%E8%AF%BB%E5%8F%96">2.6 从远程key/value存储读取</h4> 
<p>在Viper中启用远程支持，需要在代码中匿名导入<code>viper/remote</code>这个包。</p> 
<div> 
 <pre><code class="language-Go">_ "github.com/spf13/viper/remote"</code></pre> 
</div> 
<p>Viper将读取从Key/Value存储系统中的检索到的配置字符串（如<code>JSON</code>、<code>TOML</code>、<code>YAML</code>格式）。viper目前支持Consul/Etcd/firestore三种Key/Value的存储系统。下面我来演示从etcd读取配置：</p> 
<ul><li>首先我们安装crypt的工具 
  <div> 
   <pre><code class="language-Go">go get github.com/bketelsen/crypt/bin/crypt</code></pre> 
  </div> </li><li>使用crypt的命令，将app.yml的文件添加到detcd 
  <div> 
   <pre><code>crypt set --endpoint=http://127.0.0.1:2379 -plaintext /config/app.yml /Users/ckeen/Documents/code/gosource/go-awesome/go-samples/viper/configs/app.yml</code></pre> 
  </div> </li><li>添加viper的操作远程资源的配置 
  <div> 
   <pre><code class="language-Go">_ "github.com/spf13/viper/remote"</code></pre> 
  </div> </li><li>实现从远程读取配置 
  <div> 
   <pre><code class="language-Go">func InitConfigFromRemote() (*viper.Viper,error) {
	v := viper.New()
	// 远程配置
	v.AddRemoteProvider("etcd","http://127.0.0.1:2379","config/app.yml")
	//v.SetConfigType("json")
	v.SetConfigFile("app.yml")
	v.SetConfigType("yml")

	if err := v.ReadRemoteConfig(); err == nil {
		log.Printf("use config file -&gt; %s\n", v.ConfigFileUsed())
	} else {
		return nil, err
	}
	return v, nil
}

func main(){
  
  v, err := InitConfigFromRemote()
	if err != nil {
		log.Printf("read remote error:%+v\n")
	}

	log.Printf("remote read app.mode=%+v\n", v.GetString("app.mode"))
	log.Printf("remote read db.mysql.url=%+v\n", v.GetString("db.mysql.url"))
 
}</code></pre> 
  </div> </li><li>测试打印结果<br><img alt="" height="202" src="https://images2.imgbox.com/f3/78/lItX124z_o.png" width="1200">​</li></ul> 
<h4 id="2.7%C2%A0%E7%9B%91%E5%90%AC%E9%85%8D%E7%BD%AE%E5%8F%98%E5%8C%96">2.7 监听配置变化</h4> 
<p>viper提供如下两种监听配置的函数，一个是本地的监听和一个远程监听的：</p> 
<div> 
 <pre><code class="language-Go">func (v *Viper) WatchConfig()
func (v *Viper) WatchRemoteConfig() error
func (v *Viper) WatchRemoteConfigOnChannel() error
</code></pre> 
</div> 
<p>我们主要看一下监听本地文件变更的示例</p> 
<div> 
 <pre><code class="language-Go">v, err := InitConfig()
if err != nil {
log.Fatalf("viper读取失败, error:%+v\n",err)
}

// 监听到文件变化后的回调
v.OnConfigChange(func(e fsnotify.Event) {
  fmt.Println("Config file changed:", e.Name)
  fmt.Println(v.Get("db.redis.passwd"))
})

v.WatchConfig()

// 阻塞进程退出
time.Sleep(time.Duration(1000000) * time.Second)
</code></pre> 
</div> 
<p>我们使用前面的InitConfig()方法来初始化本地文件读取配置，然后设定了监听函数，最后使用WatchConfig()开启本地文件监听。</p> 
<p>当我们修改本地配置configs/app.yml的db.redis.passwd的值，然后保存后，我们可以看到控制台有打印最新修改后的值，不要我们重新去获取。</p> 
<h4 id="2.8%20%E5%86%99%E5%85%A5%E9%85%8D%E7%BD%AE%E5%88%B0%E6%96%87%E4%BB%B6">2.8 写入配置到文件</h4> 
<p>viper提供了如下四个写入配置文件发方法</p> 
<div> 
 <pre><code class="language-Go">func (v *Viper) SafeWriteConfig() error
func (v *Viper) SafeWriteConfigAs(filename string) error
func (v *Viper) WriteConfig() error
func (v *Viper) WriteConfigAs(filename string) error</code></pre> 
</div> 
<p>使用SafeWriteConfig()和WriteConfig()时，可以先设定SetConfigFile()设定配置文件的路径。配置写入示例：<br>  </p> 
<div> 
 <pre><code class="language-Go">v := New1()
v.SetConfigFile("./hello.yml")

log.Printf("config path:%+v\n", v.ConfigFileUsed())

v.SetDefault("author","CKeen")
v.SetDefault("email", "ck@gmail.com")

v.Set("hello", "foo")

v.Set("slice", []string {"slice1","slice2","slice3"})

v.SetDefault("test.web", "https://ckeen.cn")

v.WriteConfig()

//v.WriteConfigAs("./hello.yml")</code></pre> 
</div> 
<p>如果使用SafeWriteConfigAs()或者WriteConfigAs()方法，则直接传入配置文件路径即可。</p> 
<p></p> 
<h3 id="3.%C2%A0%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90--%E9%85%8D%E7%BD%AE%E8%AF%BB%E5%8F%96%E7%9A%84%E9%A1%BA%E5%BA%8F">3. 源码分析--配置读取的顺序</h3> 
<p>通过上面的示例我们知道，viper读取配置主要通过一系列Get方法来实现，我们从Get方法跳转到源码可以发现， 主要获取的配置值的为find方法， 方法实现如下：</p> 
<div> 
 <pre><code class="language-Go">func (v *Viper) find(lcaseKey string, flagDefault bool) interface{} {
	var (
		val    interface{}
		exists bool
		path   = strings.Split(lcaseKey, v.keyDelim)
		nested = len(path) &gt; 1
	)

	// compute the path through the nested maps to the nested value
	if nested &amp;&amp; v.isPathShadowedInDeepMap(path, castMapStringToMapInterface(v.aliases)) != "" {
		return nil
	}

	// if the requested key is an alias, then return the proper key
	lcaseKey = v.realKey(lcaseKey)
	path = strings.Split(lcaseKey, v.keyDelim)
	nested = len(path) &gt; 1

	// Set() override first
	val = v.searchMap(v.override, path)
	if val != nil {
		return val
	}
	if nested &amp;&amp; v.isPathShadowedInDeepMap(path, v.override) != "" {
		return nil
	}

	// PFlag override next
	flag, exists := v.pflags[lcaseKey]
	if exists &amp;&amp; flag.HasChanged() {
		switch flag.ValueType() {
		case "int", "int8", "int16", "int32", "int64":
			return cast.ToInt(flag.ValueString())
		case "bool":
			return cast.ToBool(flag.ValueString())
		case "stringSlice", "stringArray":
			s := strings.TrimPrefix(flag.ValueString(), "[")
			s = strings.TrimSuffix(s, "]")
			res, _ := readAsCSV(s)
			return res
		case "intSlice":
			s := strings.TrimPrefix(flag.ValueString(), "[")
			s = strings.TrimSuffix(s, "]")
			res, _ := readAsCSV(s)
			return cast.ToIntSlice(res)
		case "stringToString":
			return stringToStringConv(flag.ValueString())
		default:
			return flag.ValueString()
		}
	}
	if nested &amp;&amp; v.isPathShadowedInFlatMap(path, v.pflags) != "" {
		return nil
	}

	// Env override next
	if v.automaticEnvApplied {
		// even if it hasn't been registered, if automaticEnv is used,
		// check any Get request
		if val, ok := v.getEnv(v.mergeWithEnvPrefix(lcaseKey)); ok {
			return val
		}
		if nested &amp;&amp; v.isPathShadowedInAutoEnv(path) != "" {
			return nil
		}
	}
	envkeys, exists := v.env[lcaseKey]
	if exists {
		for _, envkey := range envkeys {
			if val, ok := v.getEnv(envkey); ok {
				return val
			}
		}
	}
	if nested &amp;&amp; v.isPathShadowedInFlatMap(path, v.env) != "" {
		return nil
	}

	// Config file next
	val = v.searchIndexableWithPathPrefixes(v.config, path)
	if val != nil {
		return val
	}
	if nested &amp;&amp; v.isPathShadowedInDeepMap(path, v.config) != "" {
		return nil
	}

	// K/V store next
	val = v.searchMap(v.kvstore, path)
	if val != nil {
		return val
	}
	if nested &amp;&amp; v.isPathShadowedInDeepMap(path, v.kvstore) != "" {
		return nil
	}

	// Default next
	val = v.searchMap(v.defaults, path)
	if val != nil {
		return val
	}
	if nested &amp;&amp; v.isPathShadowedInDeepMap(path, v.defaults) != "" {
		return nil
	}

	if flagDefault {
		// last chance: if no value is found and a flag does exist for the key,
		// get the flag's default value even if the flag's value has not been set.
		if flag, exists := v.pflags[lcaseKey]; exists {
			switch flag.ValueType() {
			case "int", "int8", "int16", "int32", "int64":
				return cast.ToInt(flag.ValueString())
			case "bool":
				return cast.ToBool(flag.ValueString())
			case "stringSlice", "stringArray":
				s := strings.TrimPrefix(flag.ValueString(), "[")
				s = strings.TrimSuffix(s, "]")
				res, _ := readAsCSV(s)
				return res
			case "intSlice":
				s := strings.TrimPrefix(flag.ValueString(), "[")
				s = strings.TrimSuffix(s, "]")
				res, _ := readAsCSV(s)
				return cast.ToIntSlice(res)
			case "stringToString":
				return stringToStringConv(flag.ValueString())
			default:
				return flag.ValueString()
			}
		}
		// last item, no need to check shadowing
	}

	return nil
}</code></pre> 
</div> 
<p>通过源码，我们可以知道viper读取配置的优先级顺序：<u><strong>alias别名 &gt; 调用Set设置 &gt; flag &gt; env &gt; config &gt; key/value store &gt; default</strong></u></p> 
<p>还有一个注意点<u><em><strong>:viper配置键不区分大小写，因为viper内部对key统一转为了小写。</strong></em></u></p> 
<h3 id="4.%20%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99">4. 参考资料</h3> 
<ol><li> <p>viper的包地址：<a href="https://pkg.go.dev/github.com/spf13/viper" rel="nofollow" title="viper package - github.com/spf13/viper - Go Packages">viper package - github.com/spf13/viper - Go Packages</a></p> </li><li> <p>viper的github地址： <a href="https://github.com/spf13/viper" title="GitHub - spf13/viper: Go configuration with fangs">GitHub - spf13/viper: Go configuration with fangs</a></p> </li></ol>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/36b52b736dd6e06160de9fba103b6216/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">HTTP、HTTPS、FTP 和 TCP 详细讲解：协议的功能和特点</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/4525912753728030c6f04b206753b073/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">【Android Framework系列】第2章 Binder机制大全</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>