<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Vuex详解，一文彻底搞懂Vuex - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Vuex详解，一文彻底搞懂Vuex" />
<meta property="og:description" content="一.Vuex是什么？为什么要用它？ vuex官方解释 Vuex 是一个专为 Vue.js 应用程序开发的状态管理模式 &#43; 库。它采用集中式存储管理应用的所有组件的状态，并以相应的规则保证状态以一种可预测的方式发生变化。
大家可以思考一下，组件之间的传值有哪些？有父子通讯，兄弟组件通讯…但是传参对于多层嵌套就显得非常繁琐，代码维护也会非常麻烦。因此vuex就是把组件共享状态抽取出来以一个全局单例模式管理，把共享的数据函数放进vuex中，任何组件都可以进行使用。 二.什么时候我们该使用它？ Vuex 可以帮助我们管理共享状态，并附带了更多的概念和框架。这需要对短期和长期效益进行权衡。
如果您不打算开发大型单页应用，使用 Vuex 可能是繁琐冗余的。确实是如此——如果您的应用够简单，您最好不要使用 Vuex。一个简单的store 模式就足够您所需了。但是，如果您需要构建一个中大型单页应用，您很可能会考虑如何更好地在组件外部管理状态，Vuex 将会成为自然而然的选择。
三.安装 方法一： 在脚手架 创建项目时勾选vuex的选项系统会自动创建
方法二：npm 或Yarn安装 npm install vuex@next --save yarn add vuex@next --save 四.配置 如果采用脚手架方式进行创建，无需任何操作，可以忽略此步骤
新建store文件-&gt;index.js，进行如下配置，在mian.js中进行引入
import Vue from &#39;vue&#39; import Vuex from &#39;vuex&#39; Vue.use(Vuex) export default new Vuex.Store({ //数据，相当于data state: { }, getters: { }, //里面定义方法，操作state方发 mutations: { }, // 操作异步操作mutation actions: { }, modules: { }, }) main.js中 五." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/4cb5e4c1c274b49cf8865c194c6714f6/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-07-28T19:43:26+08:00" />
<meta property="article:modified_time" content="2022-07-28T19:43:26+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Vuex详解，一文彻底搞懂Vuex</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <h2><a id="Vuex_2"></a>一.Vuex是什么？为什么要用它？</h2> 
<blockquote> 
 <h4><a id="vuex_5"></a>vuex官方解释</h4> 
 <p>Vuex 是一个专为 Vue.js 应用程序开发的<strong>状态管理模式 + 库</strong>。它采用集中式存储管理应用的所有组件的状态，并以相应的规则保证状态以一种可预测的方式发生变化。</p> 
</blockquote> 
<h4><a id="vuexvuex_9"></a>大家可以思考一下，组件之间的传值有哪些？有父子通讯，兄弟组件通讯…但是传参对于多层嵌套就显得非常繁琐，代码维护也会非常麻烦。因此vuex就是把组件共享状态抽取出来以一个全局单例模式管理，把共享的数据函数放进vuex中，任何组件都可以进行使用。</h4> 
<h2><a id="_11"></a>二.什么时候我们该使用它？</h2> 
<blockquote> 
 <p>Vuex 可以帮助我们管理共享状态，并附带了更多的概念和框架。这需要对短期和长期效益进行权衡。</p> 
 <p>如果您不打算开发大型单页应用，使用 Vuex 可能是繁琐冗余的。确实是如此——如果您的应用够简单，您最好不要使用 Vuex。一个简单的<a href="https://v3.cn.vuejs.org/guide/state-management.html#%E4%BB%8E%E9%9B%B6%E6%89%93%E9%80%A0%E7%AE%80%E5%8D%95%E7%8A%B6%E6%80%81%E7%AE%A1%E7%90%86" rel="nofollow" title="store 模式">store 模式</a>就足够您所需了。但是，如果您需要构建一个中大型单页应用，您很可能会考虑如何更好地在组件外部管理状态，Vuex 将会成为自然而然的选择。</p> 
</blockquote> 
<h2><a id="_18"></a>三.安装</h2> 
<h4><a id="_21"></a>方法一：</h4> 
<p>在脚手架 创建项目时勾选vuex的选项系统会自动创建</p> 
<p><img src="https://images2.imgbox.com/73/82/6dG8Iiad_o.png" alt=""></p> 
<h4><a id="npm_Yarn_27"></a>方法二：npm 或Yarn安装</h4> 
<pre><code>npm install vuex@next --save

yarn add vuex@next --save
</code></pre> 
<h2><a id="_33"></a>四.配置</h2> 
<p>如果采用脚手架方式进行创建，无需任何操作，可以忽略此步骤</p> 
<p>新建store文件-&gt;index.js，进行如下配置，在mian.js中进行引入</p> 
<pre><code>import Vue from 'vue'
import Vuex from 'vuex'

Vue.use(Vuex)

export default new Vuex.Store({
  //数据，相当于data
  state: {
    
  },
  getters: {
    
  },
  //里面定义方法，操作state方发
  mutations: {
    
  },
  // 操作异步操作mutation
  actions: {
    
  },
  modules: {
    
  },
})
</code></pre> 
<h2><a id="mainjs_66"></a>main.js中</h2> 
<h2><a id="httpsimgblogcsdnimgcne0cad56f88b7479da489f31f1819b7b4png_69"></a><img src="https://images2.imgbox.com/a0/99/l2t4eKg9_o.png" alt=""></h2> 
<h2><a id="_72"></a>五.核心概念</h2> 
<blockquote> 
 <p>vuex中一共有五个状态 State Getter Mutation Action Module 下面进行详细讲解</p> 
</blockquote> 
<h3><a id="51_State_77"></a>5.1 State</h3> 
<blockquote> 
 <p>提供唯一的公共数据源，所有共享的数据统一放到store的state进行储存，相似与data</p> 
</blockquote> 
<p>在vuex中state中定义数据，可以在任何组件中进行调用</p> 
<pre><code>import Vue from 'vue'
import Vuex from 'vuex'

Vue.use(Vuex)

export default new Vuex.Store({
  //数据，相当于data
  state: {
    name:"张三",
    age:12,
    count:0
  },
})
</code></pre> 
<p><strong>调用：</strong></p> 
<p>方法一：</p> 
<p>在标签中直接使用</p> 
<p><img src="https://images2.imgbox.com/dd/29/eUfXWkRu_o.png" alt=""></p> 
<p>方法二：</p> 
<pre><code>this.$store.state.全局数据名称
</code></pre> 
<p>方法三：</p> 
<p>从vuex中按需导入mapstate函数</p> 
<pre><code>import { mapState } from "vuex";
</code></pre> 
<h4><a id="computed_116"></a>注意：当前组件需要的全局数据，映射为当前组件computed属性</h4> 
<p><img src="https://images2.imgbox.com/c1/c0/16lnZlMB_o.png" alt=""></p> 
<p><img src="https://images2.imgbox.com/7c/c9/seIQNhNc_o.png" alt=""></p> 
<h3><a id="52_Mutation_122"></a>5.2 Mutation</h3> 
<blockquote> 
 <p>更改 Vuex 的 store 中的状态的唯一方法是提交 mutation。Vuex 中的 mutation 非常类似于事件：每个 mutation 都有一个字符串的<strong>事件类型 (type)<strong>和一个</strong>回调函数 (handler)</strong>。这个回调函数就是我们实际进行状态更改的地方，并且它会接受 state 作为第一个参数：</p> 
</blockquote> 
<p><strong>在vuex中定义：</strong></p> 
<p>其中参数state参数是必须的，也可以自己传递一个参数，如下代码，进行计数器的加减操作，加法操作时可以根据所传递参数大小进行相加，减法操作没有传参每次减一</p> 
<p><img src="https://images2.imgbox.com/68/99/GoZTpr9y_o.png" alt=""></p> 
<p><strong>在组件中使用：</strong></p> 
<p>定义两个按钮进行加减操作</p> 
<p><img src="https://images2.imgbox.com/01/0f/l2Wikp97_o.png" alt=""></p> 
<p>方法一：</p> 
<blockquote> 
 <p>注意：使用commit触发Mutation操作</p> 
</blockquote> 
<pre><code>methods:{
//加法
btn(){
this.$store.commit("addcount",10)     //每次加十
}
//减法
btn1(){
this.$store.commit("reduce") 
}
}
</code></pre> 
<p>方法二：</p> 
<p>使用辅助函数进行操作，具体方法同上</p> 
<p><img src="https://images2.imgbox.com/68/29/IoszmmgW_o.png" alt=""></p> 
<h3><a id="53_Action__160"></a>5.3 Action ——进行异步操作</h3> 
<blockquote> 
 <p>Action和Mutation相似，Mutation 不能进行异步操作，若要进行异步操作，就得使用Action</p> 
</blockquote> 
<p><strong>在vuex中定义：</strong></p> 
<p><strong>将上面的减法操作改为异步操作</strong></p> 
<p><img src="https://images2.imgbox.com/4d/f6/KSxyzAG2_o.png" alt=""></p> 
<p><strong>在组件中使用：</strong></p> 
<p>方法一：</p> 
<p>直接使用 dispatch触发Action函数</p> 
<pre><code>this.$store.dispatch("reduce")
</code></pre> 
<p>方法二：</p> 
<p>使用辅助函数</p> 
<p><img src="https://images2.imgbox.com/a4/19/kLQsJveb_o.png" alt=""></p> 
<h3><a id="54_Getter_185"></a>5.4 Getter</h3> 
<blockquote> 
 <p>类似于vue中的computed，进行缓存，对于Store中的数据进行加工处理形成新的数据</p> 
</blockquote> 
<p>具体操作类似于前几种，这里不做具体说明</p> 
<h3><a id="55_Modules_192"></a>5.5 Modules</h3> 
<blockquote> 
 <p>当遇见大型项目时，数据量大，store就会显得很臃肿</p> 
 <p>为了解决以上问题，Vuex 允许我们将 store 分割成<strong>模块（module）</strong>。每个模块拥有自己的 state、mutation、action、getter、甚至是嵌套子模块——从上至下进行同样方式的分割：</p> 
</blockquote> 
<p><img src="https://images2.imgbox.com/a3/fc/VtZMB3hz_o.png" alt=""></p> 
<p>默认情况下，模块内部的 action 和 mutation 仍然是注册在<strong>全局命名空间</strong>的——这样使得多个模块能够对同一个 action 或 mutation 作出响应。</p> 
<p>如果希望你的模块具有更高的封装度和复用性，你可以通过添加<code>namespaced: true</code>的方式使其成为带命名空间的模块。当模块被注册后，它的所有 getter、action 及 mutation 都会自动根据模块注册的路径调整命名。</p> 
<p><img src="https://images2.imgbox.com/90/84/L3TD24u6_o.png" alt=""></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/a9d15c43f1ef6bf4ec495dfbfda4249a/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">uni-app：uni-icons的使用及如何自定义图标</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/26db6b2e4335071cdd09f3a452b3f7ed/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">华清远见嵌入式学习每周汇总</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>