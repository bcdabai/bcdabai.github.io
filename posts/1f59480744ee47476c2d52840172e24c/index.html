<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>python二叉树 - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="python二叉树" />
<meta property="og:description" content=" 二叉树 树的定义基本术语性质二叉树的类型1、完全二叉树：2、满二叉树： 二叉树的遍历 树的定义 树（tree）是一种抽象数据类型(ADT)或是视作这个数据类型的数据结构，用来模拟拥有树状结构的数据集合
它是由n（n&gt;=1）个有限的结点组成的一个层次关系的集合。
把它叫做树是因为是看起来像树，根在上，而叶朝下的，它具有一下的特点：
1、每个节点都有零个或者多个子节点
2、没有父节点的节点叫做根节点
3、除了根节点之外，每个字节点可以分为多个不想交的子树
4、除了根节点之外，每个节点只有一个父节点
图一
在图1，该树一共有13个节点，其中A是根，其余节点分成3个互不相交的子集：
T1={B,E,F,K,L},T2={C,G},T3={D,H,I,J,M};T1,T2和T3都是根A的子树，且本身也是一棵树。
例如T1，其根为B，其余节点分为两个互不相交的子集；T11={E,K,L},T12={F}。
T11和T12都是B的子树。而在T11中E是根，{K}和{L}是E的两棵互不相交的子树，其本身又是只有一个根节点的树。
上述观察实际上给了我们一种严格的定义方法：
1、树是元素的集合
2、该集合可以为空，这时候树中没有元素，我们成它为空树（empty tree）
3、如果该集合不为空，那么该集合有一个根节点，以及0个或者多个子树，根节点和它的子节点用一条边（edge）连接
上面几点使用的递归定义的树，也就是在定义树的过程中使用了树（子树）本身，由于树的递归特征，许多树的相关操作也可以方便的实现递归实现
基本术语 1、节点的度：一个节点所含有的子树
2、树的度：一棵树的所有节点中最大的度
3、叶节点或终端节点：度为零的节点
4、父亲节点或者父节点：若一个节点含有子节点，就称这个节点为这些子节点的父节点（自身的上一级）
5、孩子节点或子节点：父亲节点的子节点（自身的下一级）
6、兄弟节点：同一个父节点
7、节点的层次：从根开始定义起，根为第一层，根的子节点为第二层，以此类推
8、树的高度或深度：树中节点的最大层次
9、堂兄弟节点：父节点在同一层次的节点
10、节点的祖先：从根节点到该节点分支上的所有节点
11、子孙：自身的所有下一级节点
12、森林：由m(m&gt;=0)棵互不相交的树的集合
性质 1、在二叉树的第i层上至多有2的（k-1） 个节点(i&gt;0)（也就是2的层数-1次方）
2、深度（高度）为k的二叉树至多有2的k次方 -1 个节点 (k &gt;0)（从第一层累加，加到k层）
3、对于任意一棵二叉树，如果其叶节点数位N0，而度数位2的结点总数为N2，则N0=N2&#43;1
4、具有n个结点的完全二叉树的深度必为log2(n&#43;1)
5、
二叉树的类型 1、完全二叉树： 2、满二叉树： ## 3、平衡二叉树
平衡二叉树又被称为AVL树（这里区别于AVL算法），他是一棵二叉排序树，且具有以下性质：他是一棵空树或他的左右两个的子树的绝对值不超过1，并且左右两个子树都是一棵平衡二叉树
二叉树的遍历 所谓二叉树的遍历，指的是如何按某种路径巡防树中的每次结点，使得每个结点均被访问一次，而且仅被访问一次。
介绍完了二叉树的定义及基本性质，接下来，我们需要了解二叉树的遍历。所谓二叉树的遍历，指的是如何按某种搜索路径巡防树中的每个结点，使得每个结点均被访问一次，而且仅被访问一次。对于二叉树，常见的遍历方法有：先序遍历，中序遍历，后序遍历，层序遍历。这些遍历方法一般使用递归算法实现。
先序遍历的操作定义为：若二叉树为空，为空操作；否则（1）访问根节点；（2）先序遍历左子树；（3）先序遍历右子树。
中序遍历的操作定义为：若二叉树为空，为空操作；否则（1）中序遍历左子树；（2）访问根结点；（3）中序遍历右子树。
后序遍历的操作定义为：若二叉树为空，为空操作；否则（1）后序遍历左子树；（2）后序遍历右子树；（3）访问根结点。
层序遍历的操作定义为：若二叉树为空，为空操作；否则从上到下、从左到右按层次进行访问。
如对于下图3
其先序遍历、中序遍历、后序遍历、层序遍历的结果为：
先序遍历为: 18 7 3 4 11 5 1 3 6 2 4 中序遍历为: 3 7 4 18 1 5 3 11 2 6 4 后序遍历为: 3 4 7 1 3 5 2 4 6 11 18 层序遍历为: [[18], [7, 11], [3, 4, 5, 6], [1, 3, 2, 4]] " />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/1f59480744ee47476c2d52840172e24c/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-03-16T15:45:09+08:00" />
<meta property="article:modified_time" content="2022-03-16T15:45:09+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">python二叉树</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p></p> 
<div class="toc"> 
 <h4>二叉树</h4> 
 <ul><li><a href="#_1" rel="nofollow">树的定义</a></li><li><a href="#_27" rel="nofollow">基本术语</a></li><li><a href="#_40" rel="nofollow">性质</a></li><li><a href="#_47" rel="nofollow">二叉树的类型</a></li><li><ul><li><a href="#1_48" rel="nofollow">1、完全二叉树：</a></li><li><a href="#2_50" rel="nofollow">2、满二叉树：</a></li></ul> 
  </li><li><a href="#_55" rel="nofollow">二叉树的遍历</a></li></ul> 
</div> 
<p></p> 
<h2><a id="_1"></a>树的定义</h2> 
<blockquote> 
 <p>树（tree）是一种抽象数据类型(ADT)或是视作这个数据类型的数据结构，用来模拟拥有树状结构的数据集合<br> 它是由n（n&gt;=1）个有限的结点组成的一个层次关系的集合。<br> 把它叫做树是因为是看起来像树，根在上，而叶朝下的，它具有一下的<code>特点</code>：<br> 1、每个节点都有零个或者多个子节点<br> 2、没有父节点的节点叫做根节点<br> 3、除了根节点之外，每个字节点可以分为多个不想交的子树<br> 4、除了根节点之外，每个节点只有一个父节点</p> 
</blockquote> 
<p><strong>图一</strong><br> <img src="https://images2.imgbox.com/d6/ad/cPL1bQWu_o.png" alt="二叉树演示"></p> 
<blockquote> 
 <p>在图1，该树一共有13个节点，其中A是根，其余节点分成3个互不相交的子集：<br> T1={B,E,F,K,L},T2={C,G},T3={D,H,I,J,M};T1,T2和T3都是根A的子树，且本身也是一棵树。<br> 例如T1，其根为B，其余节点分为两个互不相交的子集；T11={E,K,L},T12={F}。<br> T11和T12都是B的子树。而在T11中E是根，{K}和{L}是E的两棵互不相交的子树，其本身又是只有一个根节点的树。</p> 
</blockquote> 
<p><strong>上述观察实际上给了我们一种严格的定义方法：</strong></p> 
<blockquote> 
 <p>1、树是元素的集合<br> 2、该集合可以为空，这时候树中没有元素，我们成它为空树（empty tree）<br> 3、如果该集合不为空，那么该集合有一个根节点，以及0个或者多个子树，根节点和它的子节点用一条边（edge）连接</p> 
</blockquote> 
<p><em>上面几点使用的<code>递归定义</code>的树，也就是在定义树的过程中使用了树（子树）本身，由于树的递归特征，许多树的相关操作也可以方便的实现递归实现</em></p> 
<h2><a id="_27"></a>基本术语</h2> 
<blockquote> 
 <p>1、<code>节点的度</code>：一个节点所含有的子树<br> 2、<code>树的度</code>：一棵树的所有节点中最大的度<br> 3、<code>叶节点或终端节点</code>：度为零的节点<br> 4、<code>父亲节点或者父节点</code>：若一个节点含有子节点，就称这个节点为这些子节点的父节点（自身的上一级）<br> 5、<code>孩子节点或子节点</code>：父亲节点的子节点（自身的下一级）<br> 6、<code>兄弟节点</code>：同一个父节点<br> 7、<code>节点的层次</code>：从根开始定义起，根为第一层，根的子节点为第二层，以此类推<br> 8、<code>树的高度或深度</code>：树中节点的最大层次<br> 9、<code>堂兄弟节点</code>：父节点在同一层次的节点<br> 10、<code>节点的祖先</code>：从根节点到该节点分支上的所有节点<br> 11、<code>子孙</code>：自身的所有下一级节点<br> 12、<code>森林</code>：由m(m&gt;=0)棵互不相交的树的集合</p> 
</blockquote> 
<h2><a id="_40"></a>性质</h2> 
<blockquote> 
 <p>1、<code>在二叉树的第i层上至多有2的（k-1） 个节点(i&gt;0)（也就是2的层数-1次方）</code><br> 2、<code>深度（高度）为k的二叉树至多有2的k次方 -1 个节点 (k &gt;0)（从第一层累加，加到k层）</code><br> 3、<code>对于任意一棵二叉树，如果其叶节点数位N0，而度数位2的结点总数为N2，则N0=N2+1</code><br> 4、<code>具有n个结点的完全二叉树的深度必为log2(n+1)</code><br> 5、</p> 
</blockquote> 
<h2><a id="_47"></a>二叉树的类型</h2> 
<h3><a id="1_48"></a>1、完全二叉树：</h3> 
<p><img src="https://images2.imgbox.com/52/e4/Pa9Rq8Xf_o.png" alt="在这里插入图片描述"></p> 
<h3><a id="2_50"></a>2、满二叉树：</h3> 
<p><img src="https://images2.imgbox.com/02/1d/ojUbpZUn_o.png" alt="在这里插入图片描述">## 3、平衡二叉树<br> 平衡二叉树又被称为AVL树（这里区别于AVL算法），他是一棵二叉排序树，且具有以下性质：他是一棵空树或他的左右两个的子树的绝对值不超过1，并且左右两个子树都是一棵平衡二叉树</p> 
<h2><a id="_55"></a>二叉树的遍历</h2> 
<blockquote> 
 <p>所谓二叉树的遍历，指的是如何按某种路径巡防树中的每次结点，使得每个结点均被访问一次，而且仅被访问一次。<br> 介绍完了二叉树的定义及基本性质，接下来，我们需要了解二叉树的遍历。所谓二叉树的遍历，指的是如何按某种搜索路径巡防树中的每个结点，使得每个结点均被访问一次，而且仅被访问一次。对于二叉树，常见的遍历方法有：先序遍历，中序遍历，后序遍历，层序遍历。这些遍历方法一般使用递归算法实现。<br> 先序遍历的操作定义为：若二叉树为空，为空操作；否则（1）访问根节点；（2）先序遍历左子树；（3）先序遍历右子树。<br> 中序遍历的操作定义为：若二叉树为空，为空操作；否则（1）中序遍历左子树；（2）访问根结点；（3）中序遍历右子树。<br> 后序遍历的操作定义为：若二叉树为空，为空操作；否则（1）后序遍历左子树；（2）后序遍历右子树；（3）访问根结点。<br> 层序遍历的操作定义为：若二叉树为空，为空操作；否则从上到下、从左到右按层次进行访问。<br> 如对于下图3<br> <img src="https://images2.imgbox.com/af/22/HpImx0a5_o.png" alt="在这里插入图片描述"><br> 其先序遍历、中序遍历、后序遍历、层序遍历的结果为：</p> 
</blockquote> 
<pre><code class="prism language-python">先序遍历为<span class="token punctuation">:</span>
<span class="token number">18</span> <span class="token number">7</span> <span class="token number">3</span> <span class="token number">4</span> <span class="token number">11</span> <span class="token number">5</span> <span class="token number">1</span> <span class="token number">3</span> <span class="token number">6</span> <span class="token number">2</span> <span class="token number">4</span> 
中序遍历为<span class="token punctuation">:</span>
<span class="token number">3</span> <span class="token number">7</span> <span class="token number">4</span> <span class="token number">18</span> <span class="token number">1</span> <span class="token number">5</span> <span class="token number">3</span> <span class="token number">11</span> <span class="token number">2</span> <span class="token number">6</span> <span class="token number">4</span> 
后序遍历为<span class="token punctuation">:</span>
<span class="token number">3</span> <span class="token number">4</span> <span class="token number">7</span> <span class="token number">1</span> <span class="token number">3</span> <span class="token number">5</span> <span class="token number">2</span> <span class="token number">4</span> <span class="token number">6</span> <span class="token number">11</span> <span class="token number">18</span> 
层序遍历为<span class="token punctuation">:</span>
<span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token number">18</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token number">7</span><span class="token punctuation">,</span> <span class="token number">11</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">6</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">]</span><span class="token punctuation">]</span>
</code></pre>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/b3f450e44586241fd7412e0784281ca8/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">排查生产环境下CPU飙高的原因</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/4bf48151e6fad09982e4ed65c5e77f13/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">Mac环境变量配置（Java）</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>