<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>android查看线程信息,android线程消息机制之Handler详解 - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="android查看线程信息,android线程消息机制之Handler详解" />
<meta property="og:description" content="android线程消息机制主要由Handler,Looper,Message和MessageQuene四个部分组成。平常在开发中，我们常用来在子线程中通知主线程来更新，其实整个安卓生命周期的驱动都是通过Handler(ActivityThread.H)来实现的。
首先我们先介绍这四个类的作用：
Handler：消息的发送者。负责将Message消息发送到MessageQueue中。以及通过Runnable,Callback或者handleMessage()来实现消息的回调处理
Looper：是消息的循环处理器，它负责从MessageQueue中取出Message对象进行处理。(Looper含有MessageQueue的引用)
Message：是消息载体，通过target来指向handler的引用。通过object来包含业务逻辑数据。其中MessagePool为消息池，用于回收空闲的Message对象的。
MessageQueue：消息队列，负责维护待处理的消息对象。
通过上面的图，我们可以比较清楚地知道他们的作用以及关系。接下来，我们从源码角度来分析这种关系是如何建立的。
public Handler(Looper looper, Callback callback, boolean async) {
mLooper = looper;
mQueue = looper.mQueue;
mCallback = callback;
mAsynchronous = async;
}
hander的其它构造方法可以自己去查看，通过这个构造方法，我们知道，handler持有MessageQueue的引用。所以可以方便地将Message加入到队列中去。
通过源码我们发现，sendMessage-&gt;sendMessageDelayed-&gt;sendMessageAtTime-&gt;enqueueMessage
public boolean sendMessageAtTime(Message msg, long uptimeMillis) {
MessageQueue queue = mQueue;
if (queue == null) {
RuntimeException e = new RuntimeException(
this &#43; &#34; sendMessageAtTime() called with no mQueue&#34;);
Log.w(&#34;Looper&#34;, e.getMessage(), e);
return false;
}
return enqueueMessage(queue, msg, uptimeMillis);" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/84c0d2cb9f93a1f4b6d20ce3b434f8e4/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2021-05-29T05:10:35+08:00" />
<meta property="article:modified_time" content="2021-05-29T05:10:35+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">android查看线程信息,android线程消息机制之Handler详解</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <div style="font-size:16px;"> 
 <p>android线程消息机制主要由Handler,Looper,Message和MessageQuene四个部分组成。平常在开发中，我们常用来在子线程中通知主线程来更新，其实整个安卓生命周期的驱动都是通过Handler(ActivityThread.H)来实现的。</p> 
 <p>首先我们先介绍这四个类的作用：</p> 
 <p>Handler：消息的发送者。负责将Message消息发送到MessageQueue中。以及通过Runnable,Callback或者handleMessage()来实现消息的回调处理</p> 
 <p>Looper：是消息的循环处理器，它负责从MessageQueue中取出Message对象进行处理。(Looper含有MessageQueue的引用)</p> 
 <p>Message：是消息载体，通过target来指向handler的引用。通过object来包含业务逻辑数据。其中MessagePool为消息池，用于回收空闲的Message对象的。</p> 
 <p>MessageQueue：消息队列，负责维护待处理的消息对象。</p> 
 <p align="center"><img src="https://images2.imgbox.com/6f/19/AkQ185jR_o.png" alt="5ce50984d7c9f65f4f981d867a73e0ed.png"></p> 
 <p>通过上面的图，我们可以比较清楚地知道他们的作用以及关系。接下来，我们从源码角度来分析这种关系是如何建立的。</p> 
 <p>public Handler(Looper looper, Callback callback, boolean async) {<!-- --></p> 
 <p>mLooper = looper;</p> 
 <p>mQueue = looper.mQueue;</p> 
 <p>mCallback = callback;</p> 
 <p>mAsynchronous = async;</p> 
 <p>}</p> 
 <p>hander的其它构造方法可以自己去查看，通过这个构造方法，我们知道，handler持有MessageQueue的引用。所以可以方便地将Message加入到队列中去。</p> 
 <p>通过源码我们发现，sendMessage-&gt;sendMessageDelayed-&gt;sendMessageAtTime-&gt;enqueueMessage</p> 
 <p>public boolean sendMessageAtTime(Message msg, long uptimeMillis) {<!-- --></p> 
 <p>MessageQueue queue = mQueue;</p> 
 <p>if (queue == null) {<!-- --></p> 
 <p>RuntimeException e = new RuntimeException(</p> 
 <p>this + " sendMessageAtTime() called with no mQueue");</p> 
 <p>Log.w("Looper", e.getMessage(), e);</p> 
 <p>return false;</p> 
 <p>}</p> 
 <p>return enqueueMessage(queue, msg, uptimeMillis);</p> 
 <p>}</p> 
 <p>都是通过enqueueMessage将message将加入到MessageQueue中。</p> 
 <p>接下来，我们看Message是如何构造的。通过Message的构造方法。</p> 
 <p>public static Message obtain() {<!-- --></p> 
 <p>synchronized (sPoolSync) {<!-- --></p> 
 <p>if (sPool != null) {<!-- --></p> 
 <p>Message m = sPool;</p> 
 <p>sPool = m.next;</p> 
 <p>m.next = null;</p> 
 <p>m.flags = 0; // clear in-use flag</p> 
 <p>sPoolSize--;</p> 
 <p>return m;</p> 
 <p>}</p> 
 <p>}</p> 
 <p>return new Message();</p> 
 <p>}</p> 
 <p>我们看到，Message是通过obtain的静态方法从消息池sPool中拿到的。这样可以做到消息的复用。</p> 
 <p>public static Message obtain(Handler h) {<!-- --></p> 
 <p>Message m = obtain();</p> 
 <p>m.target = h;</p> 
 <p>return m;</p> 
 <p>}</p> 
 <p>其中有一个重载方法中m.target = h;这段代码非常重要，便于后面找到消息的目标handler进行处理。</p> 
 <p>接下来，我们来看Looper。我们知道Looper通过过Looper.loop来进入循环的，而循环是通过线程的run方法的驱动的。</p> 
 <p>首先我们知道，我们在创建Handler的时候，都没有去创建Looper，那么Looper哪里来的呢？</p> 
 <p>public Handler(Callback callback, boolean async) {<!-- --></p> 
 <p>...</p> 
 <p>mLooper = Looper.myLooper();</p> 
 <p>if (mLooper == null) {<!-- --></p> 
 <p>throw new RuntimeException(</p> 
 <p>"Can't create handler inside thread that has not called Looper.prepare()");</p> 
 <p>}</p> 
 <p>mQueue = mLooper.mQueue;</p> 
 <p>mCallback = callback;</p> 
 <p>mAsynchronous = async;</p> 
 <p>}</p> 
 <p>再看看Looper.myLooper()</p> 
 <p>public static @Nullable Looper myLooper() {<!-- --></p> 
 <p>return sThreadLocal.get();</p> 
 <p>}</p> 
 <p>ThreadLocal是线程创建线程局部变量的类。表示此变量只属于当前线程。</p> 
 <p>public T get() {<!-- --></p> 
 <p>Thread t = Thread.currentThread();</p> 
 <p>ThreadLocalMap map = getMap(t);</p> 
 <p>if (map != null) {<!-- --></p> 
 <p>ThreadLocalMap.Entry e = map.getEntry(this);</p> 
 <p>if (e != null) {<!-- --></p> 
 <p>@SuppressWarnings("unchecked")</p> 
 <p>T result = (T)e.value;</p> 
 <p>return result;</p> 
 <p>}</p> 
 <p>}</p> 
 <p>return setInitialValue();</p> 
 <p>}</p> 
 <p>我们看到了sThreadLocal.get()的方法实际是取当前线程中的Looper对象。</p> 
 <p>那么我们主线程的Looper到底在哪里创建的呢？</p> 
 <p>而我们清楚地知道，如果在子线程中创建handler调用，则需要使用Looper.prepare方法。</p> 
 <p>private static void prepare(boolean quitAllowed) {<!-- --></p> 
 <p>if (sThreadLocal.get() != null) {<!-- --></p> 
 <p>throw new RuntimeException("Only one Looper may be created per thread");</p> 
 <p>}</p> 
 <p>sThreadLocal.set(new Looper(quitAllowed));</p> 
 <p>}</p> 
 <p>我们看到此方法中，如果此线程中没有Looper对象，则创建一个Looper对象。接下来我们在源码中看到一个熟悉的方法。</p> 
 <p>public static void prepareMainLooper() {<!-- --></p> 
 <p>prepare(false);</p> 
 <p>synchronized (Looper.class) {<!-- --></p> 
 <p>if (sMainLooper != null) {<!-- --></p> 
 <p>throw new IllegalStateException("The main Looper has already been prepared.");</p> 
 <p>}</p> 
 <p>sMainLooper = myLooper();</p> 
 <p>}</p> 
 <p>}</p> 
 <p>此方法单独的创建了一个sMainLooper用于主线程的Looper。这个prepareMainLooper到底在哪里调用呢？</p> 
 <p>高过引用指向发现，我们在ActivityThread.main()方法中发现</p> 
 <p>public static void main(String[] args) {<!-- --></p> 
 <p>...</p> 
 <p>Looper.prepareMainLooper();</p> 
 <p>ActivityThread thread = new ActivityThread();</p> 
 <p>thread.attach(false);</p> 
 <p>if (sMainThreadHandler == null) {<!-- --></p> 
 <p>sMainThreadHandler = thread.getHandler();</p> 
 <p>}</p> 
 <p>if (false) {<!-- --></p> 
 <p>Looper.myLooper().setMessageLogging(new</p> 
 <p>LogPrinter(Log.DEBUG, "ActivityThread"));</p> 
 <p>}</p> 
 <p>// End of event ActivityThreadMain.</p> 
 <p>Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);</p> 
 <p>Looper.loop();</p> 
 <p>throw new RuntimeException("Main thread loop unexpectedly exited");</p> 
 <p>}</p> 
 <p>而ActivityThread.main()是程序的入口方法。这样我们就非常清楚了，主线程的Looper在程序的启动过程中就已经创建并循环。</p> 
 <p>那么如果在子线程中创建Looper该如何正确调用呢？</p> 
 <p>class LooperThread extends Thread {<!-- --></p> 
 <p>public Handler mHandler;</p> 
 <p>public void run() {<!-- --></p> 
 <p>Looper.prepare();</p> 
 <p>mHandler = new Handler() {<!-- --></p> 
 <p>public void handleMessage(Message msg) {<!-- --></p> 
 <p>// process incoming messages here</p> 
 <p>}</p> 
 <p>};</p> 
 <p>Looper.loop();</p> 
 <p>}</p> 
 <p>}</p> 
 <p>接下来，我们需要看下Looper.loop()的执行方法</p> 
 <p>public static void loop() {<!-- --></p> 
 <p>final Looper me = myLooper();//拿到当前线程的looper</p> 
 <p>if (me == null) {<!-- --></p> 
 <p>throw new RuntimeException("No Looper; Looper.prepare() wasn't called on this thread.");</p> 
 <p>}</p> 
 <p>final MessageQueue queue = me.mQueue;//拿到当前looper的消息队列</p> 
 <p>// Make sure the identity of this thread is that of the local process,</p> 
 <p>// and keep track of what that identity token actually is.</p> 
 <p>Binder.clearCallingIdentity();</p> 
 <p>final long ident = Binder.clearCallingIdentity();</p> 
 <p>for (;;) {//死循环遍历消息体。如果为null，则休眠。</p> 
 <p>Message msg = queue.next(); // might block</p> 
 <p>if (msg == null) {<!-- --></p> 
 <p>// No message indicates that the message queue is quitting.</p> 
 <p>return;</p> 
 <p>}</p> 
 <p>// This must be in a local variable, in case a UI event sets the logger</p> 
 <p>final Printer logging = me.mLogging;</p> 
 <p>if (logging != null) {<!-- --></p> 
 <p>logging.println("&gt;&gt;&gt;&gt;&gt; Dispatching to " + msg.target + " " +</p> 
 <p>msg.callback + ": " + msg.what);</p> 
 <p>}</p> 
 <p>final long slowDispatchThresholdMs = me.mSlowDispatchThresholdMs;</p> 
 <p>final long traceTag = me.mTraceTag;</p> 
 <p>if (traceTag != 0 &amp;&amp; Trace.isTagEnabled(traceTag)) {<!-- --></p> 
 <p>Trace.traceBegin(traceTag, msg.target.getTraceName(msg));</p> 
 <p>}</p> 
 <p>final long start = (slowDispatchThresholdMs == 0) ? 0 : SystemClock.uptimeMillis();</p> 
 <p>final long end;</p> 
 <p>try {<!-- --></p> 
 <p>msg.target.dispatchMessage(msg);//此处是真正的分发消息。此处的target即是handler对象</p> 
 <p>end = (slowDispatchThresholdMs == 0) ? 0 : SystemClock.uptimeMillis();</p> 
 <p>} finally {<!-- --></p> 
 <p>if (traceTag != 0) {<!-- --></p> 
 <p>Trace.traceEnd(traceTag);</p> 
 <p>}</p> 
 <p>}</p> 
 <p>if (slowDispatchThresholdMs &gt; 0) {<!-- --></p> 
 <p>final long time = end - start;</p> 
 <p>if (time &gt; slowDispatchThresholdMs) {<!-- --></p> 
 <p>Slog.w(TAG, "Dispatch took " + time + "ms on "</p> 
 <p>+ Thread.currentThread().getName() + ", h=" +</p> 
 <p>msg.target + " cb=" + msg.callback + " msg=" + msg.what);</p> 
 <p>}</p> 
 <p>}</p> 
 <p>if (logging != null) {<!-- --></p> 
 <p>logging.println("&lt;&lt;&lt;&lt;&lt; Finished to " + msg.target + " " + msg.callback);</p> 
 <p>}</p> 
 <p>// Make sure that during the course of dispatching the</p> 
 <p>// identity of the thread wasn't corrupted.</p> 
 <p>final long newIdent = Binder.clearCallingIdentity();</p> 
 <p>if (ident != newIdent) {<!-- --></p> 
 <p>Log.wtf(TAG, "Thread identity changed from 0x"</p> 
 <p>+ Long.toHexString(ident) + " to 0x"</p> 
 <p>+ Long.toHexString(newIdent) + " while dispatching to "</p> 
 <p>+ msg.target.getClass().getName() + " "</p> 
 <p>+ msg.callback + " what=" + msg.what);</p> 
 <p>}</p> 
 <p>msg.recycleUnchecked();</p> 
 <p>}</p> 
 <p>}</p> 
 <p>最后我们看下dispatchMessage的处理方法。</p> 
 <p>public void dispatchMessage(Message msg) {<!-- --></p> 
 <p>if (msg.callback != null) {<!-- --></p> 
 <p>handleCallback(msg);</p> 
 <p>} else {<!-- --></p> 
 <p>if (mCallback != null) {<!-- --></p> 
 <p>if (mCallback.handleMessage(msg)) {<!-- --></p> 
 <p>return;</p> 
 <p>}</p> 
 <p>}</p> 
 <p>handleMessage(msg);</p> 
 <p>}</p> 
 <p>}</p> 
 <p>我们看到，dispatchMessage是优化处理msg.callback,然后就是实现的Callback接口，最后才是handleMessage方法。</p> 
 <p>重点说明：</p> 
 <p>1、handler在实例化的时候，持有Looper的引用。是通过ThreadLocal与Handler进行关联的。</p> 
 <p>2、Message在实例化的过程中，通过target 持有Handler的引用。</p> 
 <p>3、通常一个线程对应一个Looper.一个Looper可以属于多个Handler。</p> 
 <p>以上就是本文的全部内容，希望对大家的学习有所帮助，也希望大家多多支持脚本之家。</p> 
</div>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/5673bdf2f113fffd3a106a96284a3a51/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">Android手机投屏后没有声音,乐播投屏电视没有声音怎么办_乐播投屏电视没有声音手机有声音解决办法_3DM手游...</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/b84e845627e6a66bedab877e998d13fc/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">signature=4663d2e4a53027c30ebb84732728e07e,vue-web3/yarn.lock at master · morrislaptop/vue-web3 · Gi...</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>