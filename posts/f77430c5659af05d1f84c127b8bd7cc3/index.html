<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Logback的核心API调用，动态输出日志 - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Logback的核心API调用，动态输出日志" />
<meta property="og:description" content="前言 项目碰到了不能读logback配置文件，因为配置文件是第一次启动读的，然后我程序运行时要动态写。
比如这种场景：根据不同的业务id，生成不同的日志文件。
因为动态场景，无法写配置文件，我们只能通过调用自己输出，然后自己输出还得写文件，为什么不借助logback的api去写文件呢？毕竟别人开源的代码比我们牛逼！
写代码之前，从官网看一下logback工作原理（为了让你们感觉我是看懂了原理图，手撸出来的代码），然后当然是看不懂的！233。
还是看我的代码实现吧！
实现 新建一个类LoggerBuilder.class
package com.hyperdai.DcServer.utils; import ch.qos.logback.classic.Logger; import ch.qos.logback.classic.LoggerContext; import ch.qos.logback.classic.encoder.PatternLayoutEncoder; import ch.qos.logback.core.ConsoleAppender; import ch.qos.logback.core.rolling.RollingFileAppender; import ch.qos.logback.core.rolling.SizeAndTimeBasedRollingPolicy; import ch.qos.logback.core.util.FileSize; import ch.qos.logback.core.util.OptionHelper; import org.slf4j.LoggerFactory; import java.text.DateFormat; import java.util.HashMap; import java.util.Locale; import java.util.Map; /** * author hyperdai * create 2019-04-08 17:10 */ public class LoggerBuilder { private static final Map&lt;String,Logger&gt; container = new HashMap&lt;&gt;(); private static final String LOG_PATH = &#34;/Users/hyperdai/Projects/java_dcserver/water/midas&#34;; public Logger getLogger(String name) { Logger logger = container." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/f77430c5659af05d1f84c127b8bd7cc3/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2019-05-09T01:06:55+08:00" />
<meta property="article:modified_time" content="2019-05-09T01:06:55+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Logback的核心API调用，动态输出日志</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-github-gist">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <h3><a id="_0"></a>前言</h3> 
<p>项目碰到了不能读logback配置文件，因为配置文件是第一次启动读的，然后我程序运行时要动态写。</p> 
<p>比如这种场景：根据不同的业务id，生成不同的日志文件。</p> 
<p>因为动态场景，无法写配置文件，我们只能通过调用自己输出，然后自己输出还得写文件，为什么不借助logback的api去写文件呢？毕竟别人开源的代码比我们牛逼！</p> 
<p>写代码之前，从官网看一下logback工作原理（为了让你们感觉我是看懂了原理图，手撸出来的代码），然后当然是看不懂的！233。<br> <img src="https://images2.imgbox.com/d3/bc/ioEBjkIh_o.png" alt="在这里插入图片描述"><br> 还是看我的代码实现吧！</p> 
<h3><a id="_10"></a>实现</h3> 
<p>新建一个类<code>LoggerBuilder.class</code></p> 
<pre><code>package com.hyperdai.DcServer.utils;

import ch.qos.logback.classic.Logger;
import ch.qos.logback.classic.LoggerContext;
import ch.qos.logback.classic.encoder.PatternLayoutEncoder;
import ch.qos.logback.core.ConsoleAppender;
import ch.qos.logback.core.rolling.RollingFileAppender;
import ch.qos.logback.core.rolling.SizeAndTimeBasedRollingPolicy;
import ch.qos.logback.core.util.FileSize;
import ch.qos.logback.core.util.OptionHelper;
import org.slf4j.LoggerFactory;

import java.text.DateFormat;
import java.util.HashMap;
import java.util.Locale;
import java.util.Map;

/**
 * author hyperdai
 * create 2019-04-08 17:10
 */
public class LoggerBuilder {

    private static final Map&lt;String,Logger&gt; container = new HashMap&lt;&gt;();
    private static final String LOG_PATH = "/Users/hyperdai/Projects/java_dcserver/water/midas";

    public Logger getLogger(String name) {
        Logger logger = container.get(name);
        if(logger != null) {
            return logger;
        }
        synchronized (LoggerBuilder.class) {
            logger = container.get(name);
            if(logger != null) {
                return logger;
            }
            logger = build(name);
            container.put(name,logger);
        }
        return logger;
    }




    private static Logger build(String name) {
        DateFormat format = DateFormat.getDateInstance(DateFormat.MEDIUM, Locale.SIMPLIFIED_CHINESE);
        LoggerContext context = (LoggerContext) LoggerFactory.getILoggerFactory();


        Logger logger = context.getLogger("FILE-" + name);
        logger.setAdditive(false);
        RollingFileAppender appender = new RollingFileAppender();

        appender.setContext(context);
//        appender.setFile(LoggerBuilder.LOG_PATH  + "/[" + name + "]midas.%d.%i.log");
        appender.setName("FILE-" + name);
        SizeAndTimeBasedRollingPolicy policy = new SizeAndTimeBasedRollingPolicy();

        String fp = OptionHelper.substVars(LoggerBuilder.LOG_PATH  + "/"+name+"/%d{yyyy-MM-dd}.%i.log", context);
        policy.setFileNamePattern(fp);
        policy.setMaxFileSize(FileSize.valueOf("128MB"));
        policy.setMaxHistory(15);
        policy.setTotalSizeCap(FileSize.valueOf("32GB"));
        policy.setParent(appender);
        policy.setContext(context);
        policy.start();

        PatternLayoutEncoder encoder = new PatternLayoutEncoder();
        encoder.setContext(context);
        encoder.setPattern("%d %p (%file:%line\\)- %msg%n");
        encoder.start();

        appender.setRollingPolicy(policy);
        appender.setEncoder(encoder);
        appender.start();
        logger.addAppender(appender);

        /*设置动态日志控制台输出*/
        PatternLayoutEncoder encoder1 = new PatternLayoutEncoder();
        encoder1.setContext(context);
        encoder1.setPattern("%d %p (%file:%line\\)- %msg%n");
        encoder1.start();

        ConsoleAppender consoleAppender = new ConsoleAppender();
        consoleAppender.setContext(context);
        consoleAppender.setEncoder(encoder1);
        consoleAppender.start();
        logger.addAppender(consoleAppender);


        return logger;
    }

    public static void main(String[] args) {
        System.out.println("hhhhh");
    }
}
</code></pre> 
<p>简单调用测试</p> 
<pre><code>LoggerBuilder loggerBuilder =new LoggerBuilder();
Logger logger = loggerBuilder.getLogger("1");
logger.info("123456");
</code></pre> 
<p>控制台ok啊：<br> <code>2019-05-09 00:58:46,482 INFO (DcServer.java:52)- 123456</code><br> 我也感觉ok！</p> 
<h3><a id="_121"></a>参考</h3> 
<p><a href="https://blog.csdn.net/weixin_42258128/article/details/81942796">https://blog.csdn.net/weixin_42258128/article/details/81942796</a><br> <a href="https://blog.csdn.net/jasonlibint/article/details/81942790">https://blog.csdn.net/jasonlibint/article/details/81942790</a><br> <a href="https://segmentfault.com/a/1190000008315137#articleHeader9" rel="nofollow">https://segmentfault.com/a/1190000008315137#articleHeader9</a></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/8cf92ab9a8b681766c45fc0b98c2428b/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">SqlServer语法（一）</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/b6cc319e6aea46740a0d719774177814/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">golang WebDav 多目录文件服务</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>