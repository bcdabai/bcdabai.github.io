<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>C&#43;&#43;力扣题目707--设计链表 - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="C&#43;&#43;力扣题目707--设计链表" />
<meta property="og:description" content="你可以选择使用单链表或者双链表，设计并实现自己的链表。
单链表中的节点应该具备两个属性：val 和 next 。val 是当前节点的值，next 是指向下一个节点的指针/引用。
如果是双向链表，则还需要属性 prev 以指示链表中的上一个节点。假设链表中的所有节点下标从 0 开始。
实现 MyLinkedList 类：
MyLinkedList() 初始化 MyLinkedList 对象。int get(int index) 获取链表中下标为 index 的节点的值。如果下标无效，则返回 -1 。void addAtHead(int val) 将一个值为 val 的节点插入到链表中第一个元素之前。在插入完成后，新节点会成为链表的第一个节点。void addAtTail(int val) 将一个值为 val 的节点追加到链表中作为链表的最后一个元素。void addAtIndex(int index, int val) 将一个值为 val 的节点插入到链表中下标为 index 的节点之前。如果 index 等于链表的长度，那么该节点会被追加到链表的末尾。如果 index 比长度更大，该节点将 不会插入 到链表中。void deleteAtIndex(int index) 如果下标有效，则删除链表中下标为 index 的节点。 思路：该题为链表的常见操作的设计，很考验基础，链表操作有两种方式，加虚拟头结点和不加虚拟头结点，本人使用的是加虚拟头结点的方式。代码书写时要注意表达句里的地址是否为空。
代码如下：
class MyLinkedList { public: struct linknode//自己定义一个单链表 { int val; linknode* next; linknode(int a) :val(a),next(nullptr){ } }; linknode* virhead;//链表指针域 int size;//链表长度 MyLinkedList() { virhead = new linknode(0);//初始化虚拟结点 size = 0; } int get(int index) { if (index&lt;0 || index&gt;(size-1)) { return -1; }//链表下标从0开始 linknode* p = virhead; while (index &gt;= 0) { p = p-&gt;next; index--; } return p-&gt;val; } void addAtHead(int val) { linknode* p = new linknode(val);//创建一个新结点,直接赋值 p-&gt;next = virhead-&gt;next;//让该空结点指向虚拟结点的下一个结点，即原链表的头结点 virhead-&gt;next = p;//将空结点的地址传递给虚拟结点 size&#43;&#43;;//不要忘了链表长度，长度加1 } void addAtTail(int val) { linknode* q = virhead; linknode* p = new linknode(val);//创建一个新结点,直接赋值 while (q-&gt;next !" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/f1747266870bd34e21bc2eaaf3f71236/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-12-13T08:47:15+08:00" />
<meta property="article:modified_time" content="2023-12-13T08:47:15+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">C&#43;&#43;力扣题目707--设计链表</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p>你可以选择使用单链表或者双链表，设计并实现自己的链表。</p> 
<p>单链表中的节点应该具备两个属性：<code>val</code> 和 <code>next</code> 。<code>val</code> 是当前节点的值，<code>next</code> 是指向下一个节点的指针/引用。</p> 
<p>如果是双向链表，则还需要属性 <code>prev</code> 以指示链表中的上一个节点。假设链表中的所有节点下标从 <strong>0</strong> 开始。</p> 
<p>实现 <code>MyLinkedList</code> 类：</p> 
<ul><li><code>MyLinkedList()</code> 初始化 <code>MyLinkedList</code> 对象。</li><li><code>int get(int index)</code> 获取链表中下标为 <code>index</code> 的节点的值。如果下标无效，则返回 <code>-1</code> 。</li><li><code>void addAtHead(int val)</code> 将一个值为 <code>val</code> 的节点插入到链表中第一个元素之前。在插入完成后，新节点会成为链表的第一个节点。</li><li><code>void addAtTail(int val)</code> 将一个值为 <code>val</code> 的节点追加到链表中作为链表的最后一个元素。</li><li><code>void addAtIndex(int index, int val)</code> 将一个值为 <code>val</code> 的节点插入到链表中下标为 <code>index</code> 的节点之前。如果 <code>index</code> 等于链表的长度，那么该节点会被追加到链表的末尾。如果 <code>index</code> 比长度更大，该节点将 <strong>不会插入</strong> 到链表中。</li><li><code>void deleteAtIndex(int index)</code> 如果下标有效，则删除链表中下标为 <code>index</code> 的节点。</li></ul> 
<p>思路：该题为链表的常见操作的设计，很考验基础，链表操作有两种方式，加虚拟头结点和不加虚拟头结点，本人使用的是加虚拟头结点的方式。代码书写时要注意表达句里的地址是否为空。</p> 
<p>代码如下：</p> 
<pre><code class="language-cpp">class MyLinkedList {
public:
    struct linknode//自己定义一个单链表
    {
          int val;
          linknode* next;
          linknode(int a) :val(a),next(nullptr){      
           }
    };
    linknode* virhead;//链表指针域
    int size;//链表长度
    MyLinkedList()
    {
        virhead = new linknode(0);//初始化虚拟结点
        size = 0;
    }
    int get(int index) {
        if (index&lt;0 || index&gt;(size-1)) { return -1; }//链表下标从0开始
        linknode* p = virhead;
        while (index &gt;= 0)
        {
            p = p-&gt;next;
            index--;
        }
        return p-&gt;val;
    }

    void addAtHead(int val) {
        linknode* p = new linknode(val);//创建一个新结点,直接赋值
        p-&gt;next = virhead-&gt;next;//让该空结点指向虚拟结点的下一个结点，即原链表的头结点
        virhead-&gt;next = p;//将空结点的地址传递给虚拟结点
        size++;//不要忘了链表长度，长度加1
    }

    void addAtTail(int val) {
        linknode* q = virhead;
        linknode* p = new linknode(val);//创建一个新结点,直接赋值
        while (q-&gt;next !=nullptr)//通过该循环将q遍历到最后一个结点，最后一个结点的指针域为nullptr
        {
            q = q-&gt;next;
        }
        q-&gt;next = p;
        size++;
    }

    void addAtIndex(int index, int val) {
        if (index == size) { addAtTail(val); return; }
        if (index &gt; size) { return; }
        if (index &lt;= 0) { addAtHead(val); return; }
        linknode* p = new linknode(val);
        linknode* prep = virhead;
        while (index--)
        {
            prep = prep-&gt;next;
        }
        p-&gt;next = prep-&gt;next;//将插入位置前的结点的指针域传递给要插入的结点的指针域，使插入节点指向插入位置后的结点
        prep-&gt;next = p;
        size++;
    }

    void deleteAtIndex(int index) {
        if (index&lt;0 || index&gt;(size - 1)) { return; }
        linknode* prep = virhead;
        while(index--)
        { 
            prep = prep-&gt;next;
        }
        linknode* p = prep-&gt;next;
        prep-&gt;next = prep-&gt;next-&gt;next;
        delete p;
        p = nullptr;//被delete后的指针tmp的值（地址）并非就是NULL，而是随机值。也就是被delete后，
        //如果不再加上一句tmp=nullptr,tmp会成为乱指的野指针
        //如果之后的程序不小心使用了tmp，会指向难以预想的内存空间
        size--;
    }
   
};</code></pre> 
<p></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/c31e8cfc36af93fd20dfc506b9d06cbd/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">关于如何在vuepress编辑文档</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/652be055093e3795522d4d4308226aa7/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">哪些数据适合放入缓存？</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>