<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>JAVA高级面试题汇总及答案 - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="JAVA高级面试题汇总及答案" />
<meta property="og:description" content="JAVA高级面试题汇总及答案 1.hashaMap原理源码2.synchronize关键字1.6之后的优化，（偏向轻量级锁，重量级锁）3.双亲委派是什么4.类加载过程中可以动态改字节码吗？5.如何定位线上问题，CPU100%6.redis线程模型，分布式锁，除了redis还有哪些可以用来分布式锁7.了解springboot吗？springboot自动装配是如何实现的？8.RPC框架用过哪些？谈一下内部实现原理。9.设计一个线程安全的队列，有哪些点需要去考虑10.spring ioc原理，bean初始化过程，bean的生命周期11.lock源码，aqs源码12.服务器如何去内部扩容，内部原理知不知道13.jsonp原理是什么？14.ibatis如何防止注入，#$的区别15.gc roots哪些可以作为root16.redis槽个数，扩容之后如何迁移，redis事物是怎么实现的，watch命令干吗用的17.谈谈mysql索引，（从文件结构，数据结构，应用层面去谈）datatime 和timestamp区别，间隙锁解决了什么问题18.springcloud全家桶中有个zuul为什么还要再做一个springgateway19.maven依赖的范围，如何解决循环依赖的20.设计一个流（控）程组件21.activemq，rabbitmq，kafka等消息中间件，如何去选型，依据是什么？22.spring如何解决bean的循环依赖23.redis集群简单描述一下，（槽，crc16算法）24.redis存储一个比如学生信息，1000万条，如何预估存储容量25.mysql主从同步原理，mysql有那些锁，update时什么时候用到行锁，什么时候用到表锁26.mysql索引原理，住建索引和普通索引的区别，（估计还要说个联合索引）27.kafka集群锁谈一下，如果一个consumer挂了会有什么后果？28.java隐式锁，显示锁，有什么区别，内部原理，aqs过程画一下。29.cap理论，zk，redis分别符合哪些，zk如何做到一致性的30.http协议简单说下，如何解决跨域访问问题，如何解决xss问题，如果在代码中调用http如何鉴权31.数据库SQL索引，索引失效条件，联合索引使用，聚集索引32.常用集合包括但不限于hashmap concurrentHashMap LinkedHashMap TreeMap数据结构，并发集合CopyOnWriteArrayList ConcurrentSkipListMap这些集合的内部结构33.多线程相关的，线程池ThreadPoolExecutor 工作机制，ThreadLocal ， synchronized ,ReentrantLock ,volatile 使用场景和内部实现机制34.动态代理的两种jdk cglib各自的实现方式和原理，自动生成的类结构是什么样的35.spring 容器启动顺序，扩展点BeanFactoryPostProcessor,BeanDefinitionRegistryPostProcessor,BeanPostProcessor 初始化顺序和使用场景，spring aop ，mvc的核心servlet 加载顺序，IOC相互依赖如何解决，（BeanFactoryAware方式获取bean ，打破，或者无参构造），spring事务如何实现， 哪些情况可能会失效，spring的缓存框架36.常用的设计模式，工厂，代理，模板方法，策略，装饰，观察者37.jvm内存结构，垃圾回收算法，垃圾回收器（特别是CMS）的工作机制38.classLoader 双亲委派机制 提高部分39.总结做的项目的技术选型依据，设计思路40.RPC框架设计，数据传输，序列化协议，注册中心（服务发现），熔断，限流降级，负载均衡，幂等41.MQ（最好是能够知道kafaka,rocketMq中的一种）42.临时设计一种场景，比如整点抢红包，秒杀，综合使用上面的一些43.高并发这个应用各个层次的处理， 补：缓存的使用和防缓存穿透措施 高并发应用各个层次的应对措施，数据库层面的乐观锁，应用层面的44.深入理解IO原理，bio,nio,aio相关原理特性以及应用场景45.深入理解cas原理，对cas应用场景有深刻理解46.深入理解java.concurrent包中各个常用类，对自旋锁，重入锁，读写锁的深入理解对sync相关的偏向锁，轻量级锁和锁升级相关场景深入理解47.深入理解volatile关键字以及缓存一致性协议，对使用场景有深入理解48.深入理解current包中，阻塞和非阻塞队列熟悉应用场景和特性49.熟悉线程池相关类，对线程池使用和拒绝策略比较熟悉50.熟悉java集合相关类对jdk1.8集合升级特性有一定了解51.深入理解，引用计数，标记清除，编辑整理相关GC算法特性以及应用场景52.深入理解jvm classloader类加载机制52.深入理解java反射机制和性能调优53.深入理解jvm栈与堆的结构，以及线程出栈入栈的相关原理，对jvm中逃逸分析、栈上替换、方法内联有深入理解54.深入理解jit动态编译原理，对解释执行、编译执行有深刻理解55.熟悉jvm调优，分代收集等56.深入理解tomcat启动原理以及相关的调优，对tomcat类加载机制有深入理解57.深入理解rpc动态代理&#43;zk&#43;netty相关中间件原理和应用场景，对消息队列acticvemq、rabbitmq、kafka有一定的了解58.熟悉redis使用，对高并发下的秒杀，分布式锁，防重等业务场景有深入理解，对缓存一致性，缓存击穿，缓存雪崩有深入理解59.熟悉nginux相关限流算法、规则、负载均衡原理及应用场景、对流行降级策略降级框架有一定的了解60.熟悉mybatis持久框架61.熟悉mycat适用、mysql主从、读写分离有深入理解。对mycat&#43;mysql的分库分表有深入理解62.熟悉zookeep特性，以及在整个架构中的应用场景。对zk脑列、故障修复有一定的了解 1.hashaMap原理源码 2.synchronize关键字1.6之后的优化，（偏向轻量级锁，重量级锁） synchronized是Java提供的一个并发控制的关键字，作用于对象上。主要有两种用法，分别是同步方法(访问对象和clss对象）和同步代码块（需要加入对象），保证了代码的原子性和可见性以及有序性，但是不会处理重排序以及代码优化的过程，但是在一个线程中执行肯定是有序的，因此是有序的。
原理：借用对象markword中的标记以及monitor监控器生成monitorEnter以及monitorExit指令以及对应的计数器。
在jdk1.6之前，synchronized是非常重量级的，因为它会无时无刻进行锁住对象，而不考虑到程序实际的竞争情况，大多数程序在都是进行交替执行，也就是说不存在资源的竞争，如果没有竞争，但是加锁，加锁和解锁是非常耗费性能的，（重量级)因为线程之间的切换以及线程从内核态到用户态的时间是耗费性能的。
在jdk1.6之后，sun公司对synchronized进行了大幅度的优化，现在采用偏向锁&#43;（轻量级锁&#43;cas)&#43;重量级，之间通过锁碰撞进行切换。
3.双亲委派是什么 什么是类加载器？
类加载器是jre的一部分，负责动态将类添加到Java虚拟机。
类加载分类
1、启动类加载器 bootstrap classloader ：加载jre/lib/rt.jar
2、扩展类加载器 extension classloader ：加载jre/lib/ext/*.jar
3、应用程序类加载器 application classloader：加载classpath上指定的类库
双亲委派机制
双亲委派机制是指当一个类加载器收到一个类加载请求时，该类加载器首先会把请求委派给父类加载器。每个类加载器都是如此，只有在父类加载器在自己的搜索范围内找不到指定类时，子类加载器才会尝试自己去加载。
双亲委派模型工作工程：
1.当Application ClassLoader 收到一个类加载请求时，他首先不会自己去尝试加载这个类，而是将这个请求委派给父类加载器Extension ClassLoader去完成。
2.当Extension ClassLoader收到一个类加载请求时，他首先也不会自己去尝试加载这个类，而是将请求委派给父类加载器Bootstrap ClassLoader去完成。
3.如果Bootstrap ClassLoader加载失败(在&lt;JAVA_HOME&gt;\lib中未找到所需类)，就会让Extension ClassLoader尝试加载。
4.如果Extension ClassLoader也加载失败，就会使用Application ClassLoader加载。
5.如果Application ClassLoader也加载失败，就会使用自定义加载器去尝试加载。
6.如果均加载失败，就会抛出ClassNotFoundException异常。
4.类加载过程中可以动态改字节码吗？ 是可以的，在动态代理中CGLIB动态代理采用的就是ASM字节码处理框架，动态修改字节码。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/a5bf9b5a1f8533bc8b92b9ebdaae4a2f/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2020-04-30T14:04:21+08:00" />
<meta property="article:modified_time" content="2020-04-30T14:04:21+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">JAVA高级面试题汇总及答案</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p></p> 
<div class="toc"> 
 <h4>JAVA高级面试题汇总及答案</h4> 
 <ul><li><ul><li><ul><li><ul><li><a href="#1hashaMap_1" rel="nofollow">1.hashaMap原理源码</a></li><li><a href="#2synchronize16_2" rel="nofollow">2.synchronize关键字1.6之后的优化，（偏向轻量级锁，重量级锁）</a></li><li><a href="#3_8" rel="nofollow">3.双亲委派是什么</a></li><li><a href="#4_24" rel="nofollow">4.类加载过程中可以动态改字节码吗？</a></li><li><a href="#5CPU100_29" rel="nofollow">5.如何定位线上问题，CPU100%</a></li><li><a href="#6redisredis_30" rel="nofollow">6.redis线程模型，分布式锁，除了redis还有哪些可以用来分布式锁</a></li><li><a href="#7springbootspringboot_31" rel="nofollow">7.了解springboot吗？springboot自动装配是如何实现的？</a></li><li><a href="#8RPC_32" rel="nofollow">8.RPC框架用过哪些？谈一下内部实现原理。</a></li><li><a href="#9_33" rel="nofollow">9.设计一个线程安全的队列，有哪些点需要去考虑</a></li><li><a href="#10spring_iocbeanbean_34" rel="nofollow">10.spring ioc原理，bean初始化过程，bean的生命周期</a></li><li><a href="#11lockaqs_35" rel="nofollow">11.lock源码，aqs源码</a></li><li><a href="#12_36" rel="nofollow">12.服务器如何去内部扩容，内部原理知不知道</a></li><li><a href="#13jsonp_37" rel="nofollow">13.jsonp原理是什么？</a></li><li><a href="#14ibatis_38" rel="nofollow">14.ibatis如何防止注入，#$的区别</a></li><li><a href="#15gc_rootsroot_39" rel="nofollow">15.gc roots哪些可以作为root</a></li><li><a href="#16redisrediswatch_40" rel="nofollow">16.redis槽个数，扩容之后如何迁移，redis事物是怎么实现的，watch命令干吗用的</a></li><li><a href="#17mysqldatatime_timestamp_41" rel="nofollow">17.谈谈mysql索引，（从文件结构，数据结构，应用层面去谈）datatime 和timestamp区别，间隙锁解决了什么问题</a></li><li><a href="#18springcloudzuulspringgateway_42" rel="nofollow">18.springcloud全家桶中有个zuul为什么还要再做一个springgateway</a></li><li><a href="#19maven_43" rel="nofollow">19.maven依赖的范围，如何解决循环依赖的</a></li><li><a href="#20_44" rel="nofollow">20.设计一个流（控）程组件</a></li><li><a href="#21activemqrabbitmqkafka_45" rel="nofollow">21.activemq，rabbitmq，kafka等消息中间件，如何去选型，依据是什么？</a></li><li><a href="#22springbean_46" rel="nofollow">22.spring如何解决bean的循环依赖</a></li><li><a href="#23rediscrc16_47" rel="nofollow">23.redis集群简单描述一下，（槽，crc16算法）</a></li><li><a href="#24redis1000_48" rel="nofollow">24.redis存储一个比如学生信息，1000万条，如何预估存储容量</a></li><li><a href="#25mysqlmysqlupdate_49" rel="nofollow">25.mysql主从同步原理，mysql有那些锁，update时什么时候用到行锁，什么时候用到表锁</a></li><li><a href="#26mysql_50" rel="nofollow">26.mysql索引原理，住建索引和普通索引的区别，（估计还要说个联合索引）</a></li><li><a href="#27kafkaconsumer_51" rel="nofollow">27.kafka集群锁谈一下，如果一个consumer挂了会有什么后果？</a></li><li><a href="#28javaaqs_52" rel="nofollow">28.java隐式锁，显示锁，有什么区别，内部原理，aqs过程画一下。</a></li><li><a href="#29capzkrediszk_53" rel="nofollow">29.cap理论，zk，redis分别符合哪些，zk如何做到一致性的</a></li><li><a href="#30httpxsshttp_54" rel="nofollow">30.http协议简单说下，如何解决跨域访问问题，如何解决xss问题，如果在代码中调用http如何鉴权</a></li><li><a href="#31SQL_55" rel="nofollow">31.数据库SQL索引，索引失效条件，联合索引使用，聚集索引</a></li><li><a href="#32hashmap_concurrentHashMap_LinkedHashMap_TreeMapCopyOnWriteArrayList_ConcurrentSkipListMap_56" rel="nofollow">32.常用集合包括但不限于hashmap concurrentHashMap LinkedHashMap TreeMap数据结构，并发集合CopyOnWriteArrayList ConcurrentSkipListMap这些集合的内部结构</a></li><li><a href="#33ThreadPoolExecutor_ThreadLocal__synchronized_ReentrantLock_volatile__57" rel="nofollow">33.多线程相关的，线程池ThreadPoolExecutor 工作机制，ThreadLocal ， synchronized ,ReentrantLock ,volatile 使用场景和内部实现机制</a></li><li><a href="#34jdk_cglib_58" rel="nofollow">34.动态代理的两种jdk cglib各自的实现方式和原理，自动生成的类结构是什么样的</a></li><li><a href="#35spring_BeanFactoryPostProcessorBeanDefinitionRegistryPostProcessorBeanPostProcessor_spring_aop_mvcservlet_IOCBeanFactoryAwarebean_spring_spring_59" rel="nofollow">35.spring 容器启动顺序，扩展点BeanFactoryPostProcessor,BeanDefinitionRegistryPostProcessor,BeanPostProcessor 初始化顺序和使用场景，spring aop ，mvc的核心servlet 加载顺序，IOC相互依赖如何解决，（BeanFactoryAware方式获取bean ，打破，或者无参构造），spring事务如何实现， 哪些情况可能会失效，spring的缓存框架</a></li><li><a href="#36_60" rel="nofollow">36.常用的设计模式，工厂，代理，模板方法，策略，装饰，观察者</a></li><li><a href="#37jvmCMS_61" rel="nofollow">37.jvm内存结构，垃圾回收算法，垃圾回收器（特别是CMS）的工作机制</a></li><li><a href="#38classLoader___62" rel="nofollow">38.classLoader 双亲委派机制 提高部分</a></li><li><a href="#3940RPC_63" rel="nofollow">39.总结做的项目的技术选型依据，设计思路40.RPC框架设计，数据传输，序列化协议，注册中心（服务发现），熔断，限流降级，负载均衡，幂等</a></li><li><a href="#41MQkafakarocketMq_64" rel="nofollow">41.MQ（最好是能够知道kafaka,rocketMq中的一种）</a></li><li><a href="#42_65" rel="nofollow">42.临时设计一种场景，比如整点抢红包，秒杀，综合使用上面的一些</a></li><li><a href="#43___66" rel="nofollow">43.高并发这个应用各个层次的处理， 补：缓存的使用和防缓存穿透措施 高并发应用各个层次的应对措施，数据库层面的乐观锁，应用层面的</a></li><li><a href="#44IObionioaio_67" rel="nofollow">44.深入理解IO原理，bio,nio,aio相关原理特性以及应用场景</a></li><li><a href="#45cascas_68" rel="nofollow">45.深入理解cas原理，对cas应用场景有深刻理解</a></li><li><a href="#46javaconcurrentsync_69" rel="nofollow">46.深入理解java.concurrent包中各个常用类，对自旋锁，重入锁，读写锁的深入理解对sync相关的偏向锁，轻量级锁和锁升级相关场景深入理解</a></li><li><a href="#47volatile_70" rel="nofollow">47.深入理解volatile关键字以及缓存一致性协议，对使用场景有深入理解</a></li><li><a href="#48current_71" rel="nofollow">48.深入理解current包中，阻塞和非阻塞队列熟悉应用场景和特性</a></li><li><a href="#49_72" rel="nofollow">49.熟悉线程池相关类，对线程池使用和拒绝策略比较熟悉</a></li><li><a href="#50javajdk18_73" rel="nofollow">50.熟悉java集合相关类对jdk1.8集合升级特性有一定了解</a></li><li><a href="#51GC_74" rel="nofollow">51.深入理解，引用计数，标记清除，编辑整理相关GC算法特性以及应用场景</a></li><li><a href="#52jvm_classloader_75" rel="nofollow">52.深入理解jvm classloader类加载机制</a></li><li><a href="#52java_76" rel="nofollow">52.深入理解java反射机制和性能调优</a></li><li><a href="#53jvmjvm_77" rel="nofollow">53.深入理解jvm栈与堆的结构，以及线程出栈入栈的相关原理，对jvm中逃逸分析、栈上替换、方法内联有深入理解</a></li><li><a href="#54jit_78" rel="nofollow">54.深入理解jit动态编译原理，对解释执行、编译执行有深刻理解</a></li><li><a href="#55jvm_79" rel="nofollow">55.熟悉jvm调优，分代收集等</a></li><li><a href="#56tomcattomcat_80" rel="nofollow">56.深入理解tomcat启动原理以及相关的调优，对tomcat类加载机制有深入理解</a></li><li><a href="#57rpczknettyacticvemqrabbitmqkafka_81" rel="nofollow">57.深入理解rpc动态代理+zk+netty相关中间件原理和应用场景，对消息队列acticvemq、rabbitmq、kafka有一定的了解</a></li><li><a href="#58redis_82" rel="nofollow">58.熟悉redis使用，对高并发下的秒杀，分布式锁，防重等业务场景有深入理解，对缓存一致性，缓存击穿，缓存雪崩有深入理解</a></li><li><a href="#59nginux_83" rel="nofollow">59.熟悉nginux相关限流算法、规则、负载均衡原理及应用场景、对流行降级策略降级框架有一定的了解</a></li><li><a href="#60mybatis_84" rel="nofollow">60.熟悉mybatis持久框架</a></li><li><a href="#61mycatmysqlmycatmysql_85" rel="nofollow">61.熟悉mycat适用、mysql主从、读写分离有深入理解。对mycat+mysql的分库分表有深入理解</a></li><li><a href="#62zookeepzk_86" rel="nofollow">62.熟悉zookeep特性，以及在整个架构中的应用场景。对zk脑列、故障修复有一定的了解</a></li></ul> 
   </li></ul> 
  </li></ul> 
 </li></ul> 
</div> 
<p></p> 
<h5><a id="1hashaMap_1"></a>1.hashaMap原理源码</h5> 
<h5><a id="2synchronize16_2"></a>2.synchronize关键字1.6之后的优化，（偏向轻量级锁，重量级锁）</h5> 
<p>synchronized是Java提供的一个并发控制的关键字，作用于对象上。主要有两种用法，分别是同步方法(访问对象和clss对象）和同步代码块（需要加入对象），保证了代码的原子性和可见性以及有序性，但是不会处理重排序以及代码优化的过程，但是在一个线程中执行肯定是有序的，因此是有序的。<br> 原理：借用对象markword中的标记以及monitor监控器生成monitorEnter以及monitorExit指令以及对应的计数器。<br> 在jdk1.6之前，synchronized是非常重量级的，因为它会无时无刻进行锁住对象，而不考虑到程序实际的竞争情况，大多数程序在都是进行交替执行，也就是说不存在资源的竞争，如果没有竞争，但是加锁，加锁和解锁是非常耗费性能的，（重量级)因为线程之间的切换以及线程从内核态到用户态的时间是耗费性能的。<br> 在jdk1.6之后，sun公司对synchronized进行了大幅度的优化，现在采用偏向锁+（轻量级锁+cas)+重量级，之间通过锁碰撞进行切换。</p> 
<h5><a id="3_8"></a>3.双亲委派是什么</h5> 
<p>什么是类加载器？<br> 类加载器是jre的一部分，负责动态将类添加到Java虚拟机。<br> 类加载分类<br> 1、启动类加载器 bootstrap classloader ：加载jre/lib/rt.jar<br> 2、扩展类加载器 extension classloader ：加载jre/lib/ext/*.jar<br> 3、应用程序类加载器 application classloader：加载classpath上指定的类库<br> 双亲委派机制<br> 　　双亲委派机制是指当一个类加载器收到一个类加载请求时，该类加载器首先会把请求委派给父类加载器。每个类加载器都是如此，只有在父类加载器在自己的搜索范围内找不到指定类时，子类加载器才会尝试自己去加载。<br> 双亲委派模型工作工程：<br> 　　1.当Application ClassLoader 收到一个类加载请求时，他首先不会自己去尝试加载这个类，而是将这个请求委派给父类加载器Extension ClassLoader去完成。<br> 　　2.当Extension ClassLoader收到一个类加载请求时，他首先也不会自己去尝试加载这个类，而是将请求委派给父类加载器Bootstrap ClassLoader去完成。<br> 　　3.如果Bootstrap ClassLoader加载失败(在&lt;JAVA_HOME&gt;\lib中未找到所需类)，就会让Extension ClassLoader尝试加载。<br> 　　4.如果Extension ClassLoader也加载失败，就会使用Application ClassLoader加载。<br> 　　5.如果Application ClassLoader也加载失败，就会使用自定义加载器去尝试加载。<br> 　　6.如果均加载失败，就会抛出ClassNotFoundException异常。</p> 
<h5><a id="4_24"></a>4.类加载过程中可以动态改字节码吗？</h5> 
<p>是可以的，在动态代理中CGLIB动态代理采用的就是ASM字节码处理框架，动态修改字节码。<br> 问题延伸：<br> JDK动态代理：<br> CGLIB动态代理：</p> 
<h5><a id="5CPU100_29"></a>5.如何定位线上问题，CPU100%</h5> 
<h5><a id="6redisredis_30"></a>6.redis线程模型，分布式锁，除了redis还有哪些可以用来分布式锁</h5> 
<h5><a id="7springbootspringboot_31"></a>7.了解springboot吗？springboot自动装配是如何实现的？</h5> 
<h5><a id="8RPC_32"></a>8.RPC框架用过哪些？谈一下内部实现原理。</h5> 
<h5><a id="9_33"></a>9.设计一个线程安全的队列，有哪些点需要去考虑</h5> 
<h5><a id="10spring_iocbeanbean_34"></a>10.spring ioc原理，bean初始化过程，bean的生命周期</h5> 
<h5><a id="11lockaqs_35"></a>11.lock源码，aqs源码</h5> 
<h5><a id="12_36"></a>12.服务器如何去内部扩容，内部原理知不知道</h5> 
<h5><a id="13jsonp_37"></a>13.jsonp原理是什么？</h5> 
<h5><a id="14ibatis_38"></a>14.ibatis如何防止注入，#$的区别</h5> 
<h5><a id="15gc_rootsroot_39"></a>15.gc roots哪些可以作为root</h5> 
<h5><a id="16redisrediswatch_40"></a>16.redis槽个数，扩容之后如何迁移，redis事物是怎么实现的，watch命令干吗用的</h5> 
<h5><a id="17mysqldatatime_timestamp_41"></a>17.谈谈mysql索引，（从文件结构，数据结构，应用层面去谈）datatime 和timestamp区别，间隙锁解决了什么问题</h5> 
<h5><a id="18springcloudzuulspringgateway_42"></a>18.springcloud全家桶中有个zuul为什么还要再做一个springgateway</h5> 
<h5><a id="19maven_43"></a>19.maven依赖的范围，如何解决循环依赖的</h5> 
<h5><a id="20_44"></a>20.设计一个流（控）程组件</h5> 
<h5><a id="21activemqrabbitmqkafka_45"></a>21.activemq，rabbitmq，kafka等消息中间件，如何去选型，依据是什么？</h5> 
<h5><a id="22springbean_46"></a>22.spring如何解决bean的循环依赖</h5> 
<h5><a id="23rediscrc16_47"></a>23.redis集群简单描述一下，（槽，crc16算法）</h5> 
<h5><a id="24redis1000_48"></a>24.redis存储一个比如学生信息，1000万条，如何预估存储容量</h5> 
<h5><a id="25mysqlmysqlupdate_49"></a>25.mysql主从同步原理，mysql有那些锁，update时什么时候用到行锁，什么时候用到表锁</h5> 
<h5><a id="26mysql_50"></a>26.mysql索引原理，住建索引和普通索引的区别，（估计还要说个联合索引）</h5> 
<h5><a id="27kafkaconsumer_51"></a>27.kafka集群锁谈一下，如果一个consumer挂了会有什么后果？</h5> 
<h5><a id="28javaaqs_52"></a>28.java隐式锁，显示锁，有什么区别，内部原理，aqs过程画一下。</h5> 
<h5><a id="29capzkrediszk_53"></a>29.cap理论，zk，redis分别符合哪些，zk如何做到一致性的</h5> 
<h5><a id="30httpxsshttp_54"></a>30.http协议简单说下，如何解决跨域访问问题，如何解决xss问题，如果在代码中调用http如何鉴权</h5> 
<h5><a id="31SQL_55"></a>31.数据库SQL索引，索引失效条件，联合索引使用，聚集索引</h5> 
<h5><a id="32hashmap_concurrentHashMap_LinkedHashMap_TreeMapCopyOnWriteArrayList_ConcurrentSkipListMap_56"></a>32.常用集合包括但不限于hashmap concurrentHashMap LinkedHashMap TreeMap数据结构，并发集合CopyOnWriteArrayList ConcurrentSkipListMap这些集合的内部结构</h5> 
<h5><a id="33ThreadPoolExecutor_ThreadLocal__synchronized_ReentrantLock_volatile__57"></a>33.多线程相关的，线程池ThreadPoolExecutor 工作机制，ThreadLocal ， synchronized ,ReentrantLock ,volatile 使用场景和内部实现机制</h5> 
<h5><a id="34jdk_cglib_58"></a>34.动态代理的两种jdk cglib各自的实现方式和原理，自动生成的类结构是什么样的</h5> 
<h5><a id="35spring_BeanFactoryPostProcessorBeanDefinitionRegistryPostProcessorBeanPostProcessor_spring_aop_mvcservlet_IOCBeanFactoryAwarebean_spring_spring_59"></a>35.spring 容器启动顺序，扩展点BeanFactoryPostProcessor,BeanDefinitionRegistryPostProcessor,BeanPostProcessor 初始化顺序和使用场景，spring aop ，mvc的核心servlet 加载顺序，IOC相互依赖如何解决，（BeanFactoryAware方式获取bean ，打破，或者无参构造），spring事务如何实现， 哪些情况可能会失效，spring的缓存框架</h5> 
<h5><a id="36_60"></a>36.常用的设计模式，工厂，代理，模板方法，策略，装饰，观察者</h5> 
<h5><a id="37jvmCMS_61"></a>37.jvm内存结构，垃圾回收算法，垃圾回收器（特别是CMS）的工作机制</h5> 
<h5><a id="38classLoader___62"></a>38.classLoader 双亲委派机制 提高部分</h5> 
<h5><a id="3940RPC_63"></a>39.总结做的项目的技术选型依据，设计思路40.RPC框架设计，数据传输，序列化协议，注册中心（服务发现），熔断，限流降级，负载均衡，幂等</h5> 
<h5><a id="41MQkafakarocketMq_64"></a>41.MQ（最好是能够知道kafaka,rocketMq中的一种）</h5> 
<h5><a id="42_65"></a>42.临时设计一种场景，比如整点抢红包，秒杀，综合使用上面的一些</h5> 
<h5><a id="43___66"></a>43.高并发这个应用各个层次的处理， 补：缓存的使用和防缓存穿透措施 高并发应用各个层次的应对措施，数据库层面的乐观锁，应用层面的</h5> 
<h5><a id="44IObionioaio_67"></a>44.深入理解IO原理，bio,nio,aio相关原理特性以及应用场景</h5> 
<h5><a id="45cascas_68"></a>45.深入理解cas原理，对cas应用场景有深刻理解</h5> 
<h5><a id="46javaconcurrentsync_69"></a>46.深入理解java.concurrent包中各个常用类，对自旋锁，重入锁，读写锁的深入理解对sync相关的偏向锁，轻量级锁和锁升级相关场景深入理解</h5> 
<h5><a id="47volatile_70"></a>47.深入理解volatile关键字以及缓存一致性协议，对使用场景有深入理解</h5> 
<h5><a id="48current_71"></a>48.深入理解current包中，阻塞和非阻塞队列熟悉应用场景和特性</h5> 
<h5><a id="49_72"></a>49.熟悉线程池相关类，对线程池使用和拒绝策略比较熟悉</h5> 
<h5><a id="50javajdk18_73"></a>50.熟悉java集合相关类对jdk1.8集合升级特性有一定了解</h5> 
<h5><a id="51GC_74"></a>51.深入理解，引用计数，标记清除，编辑整理相关GC算法特性以及应用场景</h5> 
<h5><a id="52jvm_classloader_75"></a>52.深入理解jvm classloader类加载机制</h5> 
<h5><a id="52java_76"></a>52.深入理解java反射机制和性能调优</h5> 
<h5><a id="53jvmjvm_77"></a>53.深入理解jvm栈与堆的结构，以及线程出栈入栈的相关原理，对jvm中逃逸分析、栈上替换、方法内联有深入理解</h5> 
<h5><a id="54jit_78"></a>54.深入理解jit动态编译原理，对解释执行、编译执行有深刻理解</h5> 
<h5><a id="55jvm_79"></a>55.熟悉jvm调优，分代收集等</h5> 
<h5><a id="56tomcattomcat_80"></a>56.深入理解tomcat启动原理以及相关的调优，对tomcat类加载机制有深入理解</h5> 
<h5><a id="57rpczknettyacticvemqrabbitmqkafka_81"></a>57.深入理解rpc动态代理+zk+netty相关中间件原理和应用场景，对消息队列acticvemq、rabbitmq、kafka有一定的了解</h5> 
<h5><a id="58redis_82"></a>58.熟悉redis使用，对高并发下的秒杀，分布式锁，防重等业务场景有深入理解，对缓存一致性，缓存击穿，缓存雪崩有深入理解</h5> 
<h5><a id="59nginux_83"></a>59.熟悉nginux相关限流算法、规则、负载均衡原理及应用场景、对流行降级策略降级框架有一定的了解</h5> 
<h5><a id="60mybatis_84"></a>60.熟悉mybatis持久框架</h5> 
<h5><a id="61mycatmysqlmycatmysql_85"></a>61.熟悉mycat适用、mysql主从、读写分离有深入理解。对mycat+mysql的分库分表有深入理解</h5> 
<h5><a id="62zookeepzk_86"></a>62.熟悉zookeep特性，以及在整个架构中的应用场景。对zk脑列、故障修复有一定的了解</h5>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/3b817bbc9b0c204370c05ef307a9d44a/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">【python】之tkinter模块之多组实验</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/8d9d464b62aa1638508b6f93ad459939/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">盘点那些优秀的C/C&#43;&#43;开源框架，程序员必备！</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>