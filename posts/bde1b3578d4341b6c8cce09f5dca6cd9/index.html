<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>c/c&#43;&#43;获取windows磁盘序列号 - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="c/c&#43;&#43;获取windows磁盘序列号" />
<meta property="og:description" content="最早用ReadDriverInfoNT，发现在特殊的笔记本上获取不到数据，一下的方法能解决这个问题。
试了很多台电脑，总是有一种方法是能获取到数据的
主函数部分：
unsigned char hdsn[41]; OSVERSIONINFO version; memset(&amp;version,0,sizeof(OSVERSIONINFO)); version.dwOSVersionInfoSize = sizeof(OSVERSIONINFO); GetVersionEx(&amp;version); if(version.dwPlatformId == VER_PLATFORM_WIN32_NT) { int ret= ReadDriverInfoNT(hdsn); if (ret ==FALSE) { ret =ReadPhysicalDriveInNTWithAdminRights(hdsn); } if (ret ==FALSE) { ret =ReadIdeDriveAsScsiDriveInNT(hdsn); } if (ret ==FALSE) { ReadPhysicalDriveInNTWithZeroRights(hdsn); } } else { MessageBox(NULL,&#34;ReadDriverInfoNT Failure!&#34;,&#34;LicenseApp&#34;,NULL); return 0; } ReadDriverInfoNT
int ReadDriverInfoNT(unsigned char *hdsn) { int iDone = FALSE; HANDLE hPhysicalDriverIOCTL = 0; char drivename[256]; sprintf(drivename,&#34;\\\\.\\PHYSICALDRIVE%d&#34;,0); hPhysicalDriverIOCTL = CreateFile(drivename,GENERIC_READ | GENERIC_WRITE,FILE_SHARE_READ | FILE_SHARE_WRITE,NULL,OPEN_EXISTING, 0, NULL); if(hPhysicalDriverIOCTL !" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/bde1b3578d4341b6c8cce09f5dca6cd9/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-03-18T18:39:03+08:00" />
<meta property="article:modified_time" content="2022-03-18T18:39:03+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">c/c&#43;&#43;获取windows磁盘序列号</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p>最早用ReadDriverInfoNT，发现在特殊的笔记本上获取不到数据，一下的方法能解决这个问题。</p> 
<p>试了很多台电脑，总是有一种方法是能获取到数据的</p> 
<p>主函数部分：</p> 
<pre><code>  
 unsigned char hdsn[41];
OSVERSIONINFO version;
    memset(&amp;version,0,sizeof(OSVERSIONINFO));
    version.dwOSVersionInfoSize = sizeof(OSVERSIONINFO);

    GetVersionEx(&amp;version);
	
	if(version.dwPlatformId == VER_PLATFORM_WIN32_NT)
	{
		int ret= ReadDriverInfoNT(hdsn);
		if (ret ==FALSE)
		{
			ret =ReadPhysicalDriveInNTWithAdminRights(hdsn);
		}
		if (ret ==FALSE)
		{
			ret =ReadIdeDriveAsScsiDriveInNT(hdsn);
		}
		if (ret ==FALSE)
		{
			ReadPhysicalDriveInNTWithZeroRights(hdsn);
		}
		
		
	}
	else
	{
		MessageBox(NULL,"ReadDriverInfoNT Failure!","LicenseApp",NULL);
		return 0;
	}</code></pre> 
<p></p> 
<p>ReadDriverInfoNT</p> 
<p></p> 
<p></p> 
<pre><code>int ReadDriverInfoNT(unsigned char *hdsn)
{
	int iDone = FALSE;
    HANDLE hPhysicalDriverIOCTL = 0;
    char drivename[256];
	sprintf(drivename,"\\\\.\\PHYSICALDRIVE%d",0);
	


    hPhysicalDriverIOCTL = CreateFile(drivename,GENERIC_READ | GENERIC_WRITE,FILE_SHARE_READ | FILE_SHARE_WRITE,NULL,OPEN_EXISTING, 0, NULL);
	
    if(hPhysicalDriverIOCTL != INVALID_HANDLE_VALUE)
    {
        GETVERSIONOUTPARAMS VersionParams;
        DWORD cbBytesReturned = 0;
        memset(&amp;VersionParams,0,sizeof(GETVERSIONOUTPARAMS));

        DeviceIoControl(hPhysicalDriverIOCTL,DFP_GET_VERSION,NULL,0,&amp;VersionParams,sizeof(VersionParams),&amp;cbBytesReturned,NULL);
		//printf(("\n44444 %d \n"),(int)VersionParams.bIDEDeviceMap);//
		//printf(("\n44444 %d \n"),(int)VersionParams.bVersion);//
        if(VersionParams.bIDEDeviceMap &gt; 0)
        {
            BYTE bIDCmd = 0;
            SENDCMDINPARAMS scip;
            BYTE IdOutCmd[sizeof(SENDCMDINPARAMS)+IDENTIFY_BUFFER_SIZE-1];

            bIDCmd = (VersionParams.bIDEDeviceMap &gt;&gt; 0 &amp; 0x10) ? 
                  IDE_ATAPI_IDENTIFY : IDE_ATA_IDENTIFY;

            memset(&amp;scip,0,sizeof(scip));
            memset(IdOutCmd,0,sizeof(IdOutCmd));

            if(DoIDENTIFY(hPhysicalDriverIOCTL, &amp;scip, (PSENDCMDOUTPARAMS)&amp;IdOutCmd,
                          bIDCmd, (BYTE)0, &amp;cbBytesReturned))
            {
				//printf(("\n 55555%d \n"),5555555555);//
                DWORD diskdata[256];
                USHORT *pIdSector = (USHORT *)((PSENDCMDOUTPARAMS) IdOutCmd) -&gt; bBuffer;
                for(int m=0;m&lt;256;m++)
                {
                    diskdata[m] = pIdSector[m];
                }
              // ConvertToString(diskdata, 27, 46,hdsn);
				 unsigned char cszSerialNumber [1024];

				ConvertToString (diskdata, 10, 19, cszSerialNumber);//这个参数可以
				printf(("\n ReadDriverInfoNT  %s \n"),cszSerialNumber);//z6emwars
			iDone=true;

			}
        }
    }
    CloseHandle(hPhysicalDriverIOCTL);
	return iDone;
}

</code></pre> 
<p>ReadPhysicalDriveInNTWithAdminRights</p> 
<pre><code>int ReadPhysicalDriveInNTWithAdminRights (unsigned char *hdsn)
{
	char m_cszErrorMessage[256];
	BYTE byIdOutCmd [sizeof (SENDCMDOUTPARAMS) + IDENTIFY_BUFFER_SIZE - 1];
	int iDone = FALSE;
	int iDrive = 0;

	for (iDrive = 0; iDrive &lt; 1; iDrive++)
	{
		HANDLE hPhysicalDriveIOCTL = 0;

		//  Try to get a handle to PhysicalDrive IOCTL, report failure
		//  and exit if can't.
		char cszDriveName [256];

		sprintf_s(cszDriveName, 256, "\\\\.\\PhysicalDrive%d", iDrive);

		//  Windows NT, Windows 2000, must have admin rights
		hPhysicalDriveIOCTL = CreateFileA (cszDriveName,
			GENERIC_READ | GENERIC_WRITE, 
			FILE_SHARE_READ | FILE_SHARE_WRITE , NULL,
			OPEN_EXISTING, 0, NULL);

		if (hPhysicalDriveIOCTL == INVALID_HANDLE_VALUE)
		{
			SecureZeroMemory(m_cszErrorMessage,sizeof(m_cszErrorMessage));
			sprintf_s(m_cszErrorMessage,256,"%d ReadPhysicalDriveInNTWithAdminRights ERROR ,CreateFileA(%s) returned INVALID_HANDLE_VALUE",__LINE__, cszDriveName);
			
		}
		else
		{
			
			GETVERSIONOUTPARAMS VersionParams;
			DWORD               dwBytesReturned = 0;

			// Get the version, etc of PhysicalDrive IOCTL
			memset ((void*) &amp;VersionParams, 0, sizeof(VersionParams));

			if ( ! DeviceIoControl (hPhysicalDriveIOCTL, DFP_GET_VERSION,
				NULL, 
				0,
				&amp;VersionParams,
				sizeof(VersionParams),
				&amp;dwBytesReturned, NULL) )
			{         

				DWORD dwErr = GetLastError ();
				SecureZeroMemory(m_cszErrorMessage,sizeof(m_cszErrorMessage));
				sprintf_s(m_cszErrorMessage,256,"%d ReadPhysicalDriveInNTWithAdminRights ERROR DeviceIoControl() %d, DFP_GET_VERSION) returned 0, error is %d\n",__LINE__, (int) hPhysicalDriveIOCTL, (int) dwErr);
			}

			// If there is a IDE device at number "iI" issue commands
			// to the device
			if (VersionParams.bIDEDeviceMap &lt;= 0)
			{
				
				SecureZeroMemory(m_cszErrorMessage,sizeof(m_cszErrorMessage));
				sprintf_s(m_cszErrorMessage,256,"%d ReadPhysicalDriveInNTWithAdminRights ERROR No device found at iPosition %d (%d)",__LINE__, (int) iDrive, (int) VersionParams.bIDEDeviceMap);
			}
			else
			{
				
				BYTE             bIDCmd = 0;   // IDE or ATAPI IDENTIFY cmd
				SENDCMDINPARAMS  scip;
				//SENDCMDOUTPARAMS OutCmd;

				// Now, get the ID sector for all IDE devices in the system.
				// If the device is ATAPI use the IDE_ATAPI_IDENTIFY command,
				// otherwise use the IDE_ATA_IDENTIFY command
				bIDCmd = (VersionParams.bIDEDeviceMap &gt;&gt; iDrive &amp; 0x10) ? \
IDE_ATAPI_IDENTIFY : IDE_ATA_IDENTIFY;

				memset (&amp;scip, 0, sizeof(scip));
				memset (byIdOutCmd, 0, sizeof(byIdOutCmd));

				if ( DoIDENTIFY (hPhysicalDriveIOCTL, 
					&amp;scip, 
					(PSENDCMDOUTPARAMS)&amp;byIdOutCmd, 
					(BYTE) bIDCmd,
					(BYTE) iDrive,
					&amp;dwBytesReturned))
				{
					DWORD dwDiskData [256];
					int iIjk = 0;
					USHORT *punIdSector = (USHORT *)
						((PSENDCMDOUTPARAMS) byIdOutCmd) -&gt; bBuffer;

					for (iIjk = 0; iIjk &lt; 256; iIjk++)
						dwDiskData [iIjk] = punIdSector [iIjk];

					//PrintIdeInfo (iDrive, dwDiskData);
					 unsigned char cszSerialNumber [1024];
					ConvertToString (dwDiskData, 10, 19, cszSerialNumber);

					printf(("\n ReadPhysicalDriveInNTWithAdminRights   %s \n"),cszSerialNumber);//

					iDone = TRUE;
				}
			}

			CloseHandle (hPhysicalDriveIOCTL);
		}
	}

	return iDone;
}
</code></pre> 
<p>ReadIdeDriveAsScsiDriveInNT</p> 
<pre><code>int ReadIdeDriveAsScsiDriveInNT (unsigned char *hdsn)
{
	int iDone = FALSE;
	int iController = 0;

	for (iController = 0; iController &lt; 1; iController++)
	{
		HANDLE hScsiDriveIOCTL = 0;
		char   cszDriveName [256];

		//  Try to get a handle to PhysicalDrive IOCTL, report failure
		//  and exit if can't.
		sprintf_s (cszDriveName, "\\\\.\\Scsi%d:", iController);

		//  Windows NT, Windows 2000, any rights should do
		hScsiDriveIOCTL = CreateFileA (cszDriveName,
			GENERIC_READ | GENERIC_WRITE, 
			FILE_SHARE_READ | FILE_SHARE_WRITE, NULL,
			OPEN_EXISTING, 0, NULL);


	
		if (hScsiDriveIOCTL != INVALID_HANDLE_VALUE)
		{
			int iDrive = 0;

			
			for (iDrive = 0; iDrive &lt; 2; iDrive++)
			{
				char cszBuffer [sizeof (SRB_IO_CONTROL) + SENDIDLENGTH];
				SRB_IO_CONTROL *cP = (SRB_IO_CONTROL *) cszBuffer;
				SENDCMDINPARAMS *pin =
					(SENDCMDINPARAMS *) (cszBuffer + sizeof (SRB_IO_CONTROL));
				DWORD dwDummy;

				memset (cszBuffer, 0, sizeof (cszBuffer));
				cP -&gt; HeaderLength = sizeof (SRB_IO_CONTROL);
				cP -&gt; Timeout = 10000;
				cP -&gt; Length = SENDIDLENGTH;
				cP -&gt; ControlCode = IOCTL_SCSI_MINIPORT_IDENTIFY;
				strncpy ((char *) cP -&gt; Signature, "SCSIDISK", 8);

				pin -&gt; irDriveRegs.bCommandReg = IDE_ATA_IDENTIFY;
				pin -&gt; bDriveNumber = iDrive;
				
			
				if (DeviceIoControl (hScsiDriveIOCTL, IOCTL_SCSI_MINIPORT, 
					cszBuffer,
					sizeof (SRB_IO_CONTROL) +
					sizeof (SENDCMDINPARAMS) - 1,
					cszBuffer,
					sizeof (SRB_IO_CONTROL) + SENDIDLENGTH,
					&amp;dwDummy, NULL))
				{
					SENDCMDOUTPARAMS *pOut =
						(SENDCMDOUTPARAMS *) (cszBuffer + sizeof (SRB_IO_CONTROL));
					IDSECTOR *pId = (IDSECTOR *) (pOut -&gt; bBuffer);
					
					if (pId -&gt; sModelNumber [0])
					{
					
						DWORD dwDiskData [256];
						int iIjk = 0;
						USHORT *punIdSector = (USHORT *) pId;

						for (iIjk = 0; iIjk &lt; 256; iIjk++)
							dwDiskData [iIjk] = punIdSector [iIjk];

						//PrintIdeInfo (iController * 2 + iDrive, dwDiskData);
						 unsigned char cszSerialNumber [1024];
						ConvertToString (dwDiskData, 10, 19, cszSerialNumber);

						printf(("\n ReadIdeDriveAsScsiDriveInNT   %s \n"),cszSerialNumber);//

						iDone = TRUE;
					}
				}
			}
			CloseHandle (hScsiDriveIOCTL);
		}
	}

	return iDone;
}
</code></pre> 
<p>ReadPhysicalDriveInNTWithZeroRights</p> 
<pre><code>int ReadPhysicalDriveInNTWithZeroRights (unsigned char *hdsn)
{
	int iDone = FALSE;
	int iDrive = 0;
	char m_cszErrorMessage[256];
	char HDSN_len = 0;

	for (iDrive = 0; iDrive &lt; 1; iDrive++)
	{
		HANDLE hPhysicalDriveIOCTL = 0;

		//  Try to get a handle to PhysicalDrive IOCTL, report failure
		//  and exit if can't.
		char cszDriveName [256];

		sprintf_s(cszDriveName,256,"\\\\.\\PhysicalDrive%d", iDrive);

		//  Windows NT, Windows 2000, Windows XP - admin rights not required
		hPhysicalDriveIOCTL = CreateFileA (cszDriveName, 0,
			FILE_SHARE_READ | FILE_SHARE_WRITE, NULL,
			OPEN_EXISTING, 0, NULL);
		if (hPhysicalDriveIOCTL == INVALID_HANDLE_VALUE)
		{
			SecureZeroMemory(m_cszErrorMessage,sizeof(m_cszErrorMessage));
			sprintf_s(m_cszErrorMessage,256,"%d ReadPhysicalDriveInNTWithZeroRights ERROR CreateFileA(%s) returned INVALID_HANDLE_VALUE",__LINE__, cszDriveName);
		}
		else
		{
			STORAGE_PROPERTY_QUERY query;
			DWORD dwBytesReturned = 0;
			char cszBuffer [10000];

			memset ((void *) &amp; query, 0, sizeof (query));
			query.PropertyId = StorageDeviceProperty;
			query.QueryType = PropertyStandardQuery;

			memset (cszBuffer, 0, sizeof (cszBuffer));

			if ( DeviceIoControl (hPhysicalDriveIOCTL, IOCTL_STORAGE_QUERY_PROPERTY,
				&amp; query,
				sizeof (query),
				&amp; cszBuffer,
				sizeof (cszBuffer),
				&amp; dwBytesReturned, NULL) )
			{         
				STORAGE_DEVICE_DESCRIPTOR * descrip = (STORAGE_DEVICE_DESCRIPTOR *) &amp; cszBuffer;
				char cszSerialNumber [1000];

				flipAndCodeBytes ( descrip -&gt; SerialNumberOffset,
					1,cszBuffer, cszSerialNumber );

				//printf(("\n ReadPhysicalDriveInNTWithZeroRights  SerialNumber \n"));//
				printf(("\n ReadPhysicalDriveInNTWithZeroRights %s \n"),cszSerialNumber);


				//printf("\n");
				HDSN_len = strlen(cszSerialNumber);
				
				HDInfoArray[139] = HDSN_len;
				if(HDSN_len &gt; 0)
				{
					MainKeyMode = MainKeyMode ^ 0X04;
				}

				memcpy(&amp;HDInfoArray[140],cszSerialNumber,HDSN_len);

				//ConvertToString (dwDiskData, 10, 19, cszSerialNumber);
				
				iDone = TRUE;
				
				// Get the disk iDrive geometry.
				memset (cszBuffer, 0, sizeof(cszBuffer));
				if ( ! DeviceIoControl (hPhysicalDriveIOCTL,
					IOCTL_DISK_GET_DRIVE_GEOMETRY_EX,
					NULL,
					0,
					&amp;cszBuffer,
					sizeof(cszBuffer),
					&amp;dwBytesReturned,
					NULL))
				{
					SecureZeroMemory(m_cszErrorMessage,sizeof(m_cszErrorMessage));
					sprintf_s(m_cszErrorMessage,"%s ReadPhysicalDriveInNTWithZeroRights ERROR DeviceIoControl(), IOCTL_DISK_GET_DRIVE_GEOMETRY_EX) returned 0", cszDriveName);
				}
				else
				{         
					DISK_GEOMETRY_EX* geom = (DISK_GEOMETRY_EX*) &amp;cszBuffer;
					int iFixed = (geom-&gt;Geometry.MediaType == FixedMedia);
					__int64 i64Size = geom-&gt;DiskSize.QuadPart;

				}
			}
			else
			{
				DWORD dwErr = GetLastError ();
				SecureZeroMemory(m_cszErrorMessage,sizeof(m_cszErrorMessage));
				sprintf_s (m_cszErrorMessage,"DeviceIOControl IOCTL_STORAGE_QUERY_PROPERTY error = %d\n", dwErr);

			}

			CloseHandle (hPhysicalDriveIOCTL);
		}
	}

	return iDone;
}
</code></pre> 
<p></p> 
<p>自己的两个资源，做个记录</p> 
<p><a href="https://download.csdn.net/download/Super_Jadroid/73804167?spm=1001.2014.3001.5503" title="vs2010，c++，license制作gatmacAndgetSerialNum.rar-桌面系统文档类资源-CSDN下载">vs2010，c++，license制作gatmacAndgetSerialNum.rar-桌面系统文档类资源-CSDN下载</a></p> 
<p><a href="https://download.csdn.net/download/Super_Jadroid/73801451?spm=1001.2014.3001.5503" title="获取计算机硬件信息的资源代码，GetHDSerialNumber_by_Michael_Haephrati.zip-桌面系统文档​​​​​​类资源-CSDN下载">获取计算机硬件信息的资源代码，GetHDSerialNumber_by_Michael_Haephrati.zip-桌面系统文档​​​​​​类资源-CSDN下载</a></p> 
<p></p> 
<p></p> 
<p></p> 
<p></p> 
<p></p> 
<p></p> 
<p></p> 
<p></p> 
<p></p> 
<p></p> 
<p></p> 
<p></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/89fbd959639fbac44703f14577f70999/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">什么是DHCP?有什么优缺点</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/5e03514c61aed67d042adff62c38c03c/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">hive 启动报错java.net.URISyntaxException: Relative path in absolute URI: ${system:java.io.tmpdir%7D/$%..</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>