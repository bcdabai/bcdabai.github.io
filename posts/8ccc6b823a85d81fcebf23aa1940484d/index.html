<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>用GDB调试程序（五） - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="用GDB调试程序（五）" />
<meta property="og:description" content="查看运行时数据
———————
在你调试程序时，当程序被停住时，你可以使用print命令（简写命令为p），或是同义命令inspect来查看当前程序的运行数据。print命令的格式是：
print &lt;expr&gt;
print /&lt;f&gt; &lt;expr&gt;
&lt;expr&gt;是表达式，是你所调试的程序的语言的表达式（GDB可以调试多种编程语言），&lt;f&gt;是输出的格式，比如，如果要把表达式按16进制的格式输出，那么就是/x。
一、表达式
print和许多GDB的命令一样，可以接受一个表达式，GDB会根据当前的程序运行的数据来计算这个表达式，既然是表达式，那么就可以是当前程序运行中的const常量、变量、函数等内容。可惜的是GDB不能使用你在程序中所定义的宏。
表达式的语法应该是当前所调试的语言的语法，由于C/C&#43;&#43;是一种大众型的语言，所以，本文中的例子都是关于C/C&#43;&#43;的。（而关于用GDB调试其它语言的章节，我将在后面介绍）
在表达式中，有几种GDB所支持的操作符，它们可以用在任何一种语言中。
@
是一个和数组有关的操作符，在后面会有更详细的说明。
::
指定一个在文件或是一个函数中的变量。
{&lt;type&gt;} &lt;addr&gt;
表示一个指向内存地址&lt;addr&gt;的类型为type的一个对象。
二、程序变量
在GDB中，你可以随时查看以下三种变量的值：
1、全局变量（所有文件可见的）
2、静态全局变量（当前文件可见的）
3、局部变量（当前Scope可见的）
如果你的局部变量和全局变量发生冲突（也就是重名），一般情况下是局部变量会隐藏全局变量，也就是说，如果一个全局变量和一个函数中的局部变量同名时，如果当前停止点在函数中，用print显示出的变量的值会是函数中的局部变量的值。如果此时你想查看全局变量的值时，你可以使用“::”操作符：
file::variable
function::variable
可以通过这种形式指定你所想查看的变量，是哪个文件中的或是哪个函数中的。例如，查看文件f2.c中的全局变量x的值：
gdb) p &#39;f2.c&#39;::x
当然，“::”操作符会和C&#43;&#43;中的发生冲突，GDB能自动识别“::” 是否C&#43;&#43;的操作符，所以你不必担心在调试C&#43;&#43;程序时会出现异常。
另外，需要注意的是，如果你的程序编译时开启了优化选项，那么在用GDB调试被优化过的程序时，可能会发生某些变量不能访问，或是取值错误码的情况。这个是很正常的，因为优化程序会删改你的程序，整理你程序的语句顺序，剔除一些无意义的变量等，所以在GDB调试这种程序时，运行时的指令和你所编写指令就有不一样，也就会出现你所想象不到的结果。对付这种情况时，需要在编译程序时关闭编译优化。一般来说，几乎所有的编译器都支持编译优化的开关，例如，GNU的C/C&#43;&#43;编译器GCC，你可以使用“-gstabs”选项来解决这个问题。关于编译器的参数，还请查看编译器的使用说明文档。
三、数组
有时候，你需要查看一段连续的内存空间的值。比如数组的一段，或是动态分配的数据的大小。你可以使用GDB的“@”操作符，“@”的左边是第一个内存的地址的值，“@”的右边则你你想查看内存的长度。例如，你的程序中有这样的语句：
int *array = (int *) malloc (len * sizeof (int));
于是，在GDB调试过程中，你可以以如下命令显示出这个动态数组的取值：
p *array@len
@的左边是数组的首地址的值，也就是变量array所指向的内容，右边则是数据的长度，其保存在变量len中，其输出结果，大约是下面这个样子的：
(gdb) p *array@len
$1 = {2, 4, 6, 8, 10, 12, 14, 16, 18, 20, 22, 24, 26, 28, 30, 32, 34, 36, 38, 40}" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/8ccc6b823a85d81fcebf23aa1940484d/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2003-07-09T08:30:00+08:00" />
<meta property="article:modified_time" content="2003-07-09T08:30:00+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">用GDB调试程序（五）</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p><font face="Courier New"><strong></strong></font> </p> 
<p><font face="Courier New"><strong>查看运行时数据<br>———————</strong><br>    <br>    在你调试程序时，当程序被停住时，你可以使用print命令（简写命令为p），或是同义命令inspect来查看当前程序的运行数据。print命令的格式是：<br>    <br>    print &lt;expr&gt;<br>    print /&lt;f&gt; &lt;expr&gt;<br>        &lt;expr&gt;是表达式，是你所调试的程序的语言的表达式（GDB可以调试多种编程语言），&lt;f&gt;是输出的格式，比如，如果要把表达式按16进制的格式输出，那么就是/x。<br>        <br>    <br><strong>一、表达式</strong></font></p> 
<p><font face="Courier New">    print和许多GDB的命令一样，可以接受一个表达式，GDB会根据当前的程序运行的数据来计算这个表达式，既然是表达式，那么就可以是当前程序运行中的const常量、变量、函数等内容。可惜的是GDB不能使用你在程序中所定义的宏。<br>    <br>    表达式的语法应该是当前所调试的语言的语法，由于C/C++是一种大众型的语言，所以，本文中的例子都是关于C/C++的。（而关于用GDB调试其它语言的章节，我将在后面介绍）<br>    <br>    在表达式中，有几种GDB所支持的操作符，它们可以用在任何一种语言中。<br>    <br>    @<br>        是一个和数组有关的操作符，在后面会有更详细的说明。<br>        <br>    ::<br>        指定一个在文件或是一个函数中的变量。<br>        <br>    {&lt;type&gt;} &lt;addr&gt;<br>        表示一个指向内存地址&lt;addr&gt;的类型为type的一个对象。<br>        <br>        <br><strong>二、程序变量</strong></font></p> 
<p><font face="Courier New">    在GDB中，你可以随时查看以下三种变量的值：<br>        1、全局变量（所有文件可见的）<br>        2、静态全局变量（当前文件可见的）<br>        3、局部变量（当前Scope可见的）<br>        <br>    如果你的局部变量和全局变量发生冲突（也就是重名），一般情况下是局部变量会隐藏全局变量，也就是说，如果一个全局变量和一个函数中的局部变量同名时，如果当前停止点在函数中，用print显示出的变量的值会是函数中的局部变量的值。如果此时你想查看全局变量的值时，你可以使用“::”操作符：<br>    <br>        file::variable<br>    function::variable<br>    可以通过这种形式指定你所想查看的变量，是哪个文件中的或是哪个函数中的。例如，查看文件f2.c中的全局变量x的值：<br>    <br>    gdb) p 'f2.c'::x<br>    <br>    当然，“::”操作符会和C++中的发生冲突，GDB能自动识别“::” 是否C++的操作符，所以你不必担心在调试C++程序时会出现异常。<br>    <br>    另外，需要注意的是，如果你的程序编译时开启了优化选项，那么在用GDB调试被优化过的程序时，可能会发生某些变量不能访问，或是取值错误码的情况。这个是很正常的，因为优化程序会删改你的程序，整理你程序的语句顺序，剔除一些无意义的变量等，所以在GDB调试这种程序时，运行时的指令和你所编写指令就有不一样，也就会出现你所想象不到的结果。对付这种情况时，需要在编译程序时关闭编译优化。一般来说，几乎所有的编译器都支持编译优化的开关，例如，GNU的C/C++编译器GCC，你可以使用“-gstabs”选项来解决这个问题。关于编译器的参数，还请查看编译器的使用说明文档。<br>    </font></p> 
<p><font face="Courier New"><strong>三、数组</strong></font></p> 
<p><font face="Courier New">    有时候，你需要查看一段连续的内存空间的值。比如数组的一段，或是动态分配的数据的大小。你可以使用GDB的“@”操作符，“@”的左边是第一个内存的地址的值，“@”的右边则你你想查看内存的长度。例如，你的程序中有这样的语句：<br>     <br>        int *array = (int *) malloc (len * sizeof (int));<br>        <br>    于是，在GDB调试过程中，你可以以如下命令显示出这个动态数组的取值：</font></p> 
<p><font face="Courier New">        p </font><font face="Courier New">*array@len</font></p> 
<p><font face="Courier New">    @的左边是数组的首地址的值，也就是变量array所指向的内容，右边则是数据的长度，其保存在变量len中，其输出结果，大约是下面这个样子的：<br>    <br>        (gdb) p </font><font face="Courier New">*array@len</font><br><font face="Courier New">        $1 = {2, 4, 6, 8, 10, 12, 14, 16, 18, 20, 22, 24, 26, 28, 30, 32, 34, 36, 38, 40}</font></p> 
<p><font face="Courier New">    如果是静态数组的话，可以直接用print数组名，就可以显示数组中所有数据的内容了。</font></p> 
<p><font face="Courier New">    <br><strong>四、输出格式</strong></font></p> 
<p><font face="Courier New">    一般来说，GDB会根据变量的类型输出变量的值。但你也可以自定义GDB的输出的格式。例如，你想输出一个整数的十六进制，或是二进制来查看这个整型变量的中的位的情况。要做到这样，你可以使用GDB的数据显示格式：<br>    <br>    x  按十六进制格式显示变量。<br>    d  按十进制格式显示变量。<br>    u  按十六进制格式显示无符号整型。<br>    o  按八进制格式显示变量。<br>    t  按二进制格式显示变量。 <br>    a  按十六进制格式显示变量。<br>    c  按字符格式显示变量。<br>    f  按浮点数格式显示变量。</font></p> 
<p><font face="Courier New">        (gdb) p i<br>        $21 = 101    <br>        <br>        (gdb) p/a i<br>        $22 = 0x65<br>        <br>        (gdb) p/c i<br>        $23 = 101 'e'<br>        <br>        (gdb) p/f i<br>        $24 = 1.41531145e-43<br>        <br>        (gdb) p/x i<br>        $25 = 0x65<br>        <br>        (gdb) p/t i<br>        $26 = 1100101</font></p> 
<p><br><font face="Courier New"><strong>五、查看内存</strong></font></p> 
<p><font face="Courier New">    你可以使用examine命令（简写是x）来查看内存地址中的值。x命令的语法如下所示：<br>    <br>    x/&lt;n/f/u&gt; &lt;addr&gt; <br>    <br>    n、f、u是可选的参数。<br>    <br>    n 是一个正整数，表示显示内存的长度，也就是说从当前地址向后显示几个地址的内容。<br>    f 表示显示的格式，参见上面。如果地址所指的是字符串，那么格式可以是s，如果地十是指令地址，那么格式可以是i。<br>    u 表示从当前地址往后请求的字节数，如果不指定的话，GDB默认是4个bytes。u参数可以用下面的字符来代替，b表示单字节，h表示双字节，w表示四字节，g表示八字节。当我们指定了字节长度后，GDB会从指内存定的内存地址开始，读写指定字节，并把其当作一个值取出来。<br>    <br>    &lt;addr&gt;表示一个内存地址。</font></p> 
<p><font face="Courier New">    n/f/u三个参数可以一起使用。例如：<br>    <br>    命令：x/3uh 0x54320 表示，从内存地址0x54320读取内容，h表示以双字节为一个单位，3表示三个单位，u表示按十六进制显示。<br>    <br>    <br><strong>六、自动显示</strong></font></p> 
<p><font face="Courier New">    你可以设置一些自动显示的变量，当程序停住时，或是在你单步跟踪时，这些变量会自动显示。相关的GDB命令是display。<br>    <br>    display &lt;expr&gt; <br>    display/&lt;fmt&gt; &lt;expr&gt; <br>    display/&lt;fmt&gt; &lt;addr&gt;<br>    <br>    expr是一个表达式，fmt表示显示的格式，addr表示内存地址，当你用display设定好了一个或多个表达式后，只要你的程序被停下来，GDB会自动显示你所设置的这些表达式的值。<br>    <br>    格式i和s同样被display支持，一个非常有用的命令是：<br>    <br>        display/i $pc<br>    <br>    $pc是GDB的环境变量，表示着指令的地址，/i则表示输出格式为机器指令码，也就是汇编。于是当程序停下后，就会出现源代码和机器指令码相对应的情形，这是一个很有意思的功能。<br>    <br>    下面是一些和display相关的GDB命令：<br>    <br>    undisplay &lt;dnums...&gt;<br>    delete display &lt;dnums...&gt;<br>    删除自动显示，dnums意为所设置好了的自动显式的编号。如果要同时删除几个，编号可以用空格分隔，如果要删除一个范围内的编号，可以用减号表示（如：2-5）<br>    <br>    disable display &lt;dnums...&gt;<br>    enable display &lt;dnums...&gt;<br>    disable和enalbe不删除自动显示的设置，而只是让其失效和恢复。<br>    <br>    info display<br>    查看display设置的自动显示的信息。GDB会打出一张表格，向你报告当然调试中设置了多少个自动显示设置，其中包括，设置的编号，表达式，是否enable。<br>    </font></p> 
<font face="Courier New"> <p align="right"><font face="MS Sans Serif">&lt;-<a href="http://www.csdn.net/Develop/read_article.asp?id=19447"><font color="#29098a">上一页</font></a>  <a href="http://www.csdn.net/develop/read_article.asp?id=19544">下一页</a>-&gt;</font></p> <p><font face="Courier New"><strong>（版权所有，转载时请注明作者和出处）</strong></font></p> <p><br> 
  <br></p></font>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/1cabbdd4cd80a971f86b1082191b7a53/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">Delphi中布尔类型辨析</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/1db841bcbec4e1a6af9fd0f232596e51/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">获取数据库表结构</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>