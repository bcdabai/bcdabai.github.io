<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>C#的接口 - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="C#的接口" />
<meta property="og:description" content="接口是指定一组函数成员而不实现他们的引用类型。所以只能类和结构来实现接口，在继承该接口的类里面要实现接口的所有方法。
一、在定义接口时候要注意如下几点：
接口声明不能包含以下成员：数据成员、静态成员。
接口声明只能包含如下类型的非静态成员函数的声明：方法、属性、事件、索引器。
这些函数成员的声明不能包含任何实现代码，而在每一个成员声明的主体后必须使用分。
按照惯例，接口名称必须从大写的I开始写起，
接口声明可以有任何的访问修饰符，public、protected、internal、private，例如
然而，接口的成员是隐式public的，不允许有任何的访问修饰符，包括public，例如：
C#中对于接口的实现方式有隐式接口和显式接口两种：
隐式地实现接口成员
创建一个接口，IChinese，包含一个成员 Speak;我们创建一个类Speaker，实现接口Chinese
//隐藏式实现例子 public interface IChinese { string Speak(); } public class Speaker : IChinese { public string Speak() { return &#34;中文&#34;; } } 这个就是隐式实现接口。 隐藏式实现例子 public interface IChinese { string Speak(); } public class Speaker : IChinese { public string Speak() { return &#34;中文&#34;; } } 隐式实现调用方法如下：
IChinese s = new Speaker(); s.Speak(); Speaker s = new Speaker(); s." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/9ee5cfefa855c38858b0886397b7d240/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2018-12-15T15:28:24+08:00" />
<meta property="article:modified_time" content="2018-12-15T15:28:24+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">C#的接口</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-tomorrow-night-eighties">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p>接口是指定一组函数成员而不实现他们的引用类型。所以只能类和结构来实现接口，在继承该接口的类里面要实现接口的所有方法。</p> 
<p><strong>一、在定义接口时候要注意如下几点：</strong></p> 
<ol><li> <p>接口声明不能包含以下成员：数据成员、静态成员。</p> </li><li> <p>接口声明只能包含如下类型的非静态成员函数的声明：方法、属性、事件、索引器。</p> </li><li> <p>这些函数成员的声明不能包含任何实现代码，而在每一个成员声明的主体后必须使用分。</p> </li><li> <p>按照惯例，接口名称必须从大写的I开始写起，</p> </li><li> <p>接口声明可以有任何的访问修饰符，public、protected、internal、private，例如<br> <img src="https://images2.imgbox.com/73/23/cWNRqQ8M_o.png" alt="在这里插入图片描述"></p> </li><li> <p>然而，接口的成员是隐式public的，不允许有任何的访问修饰符，包括public，例如：<br> <img src="https://images2.imgbox.com/25/b8/FYIL965N_o.png" alt="在这里插入图片描述"></p> </li></ol> 
<p>C#中对于接口的实现方式有隐式接口和显式接口两种：<br> <strong>隐式地实现接口成员</strong><br> 创建一个接口，IChinese，包含一个成员 Speak;我们创建一个类Speaker，实现接口Chinese</p> 
<pre><code>//隐藏式实现例子
public interface IChinese
{
    string Speak();
}
public class Speaker : IChinese
{
    public string Speak()
    {
        return "中文";
    }
}
这个就是隐式实现接口。
</code></pre> 
<pre><code>隐藏式实现例子
public interface IChinese
{
    string Speak();
}
public class Speaker : IChinese
{
    public string Speak()
    {
        return "中文";
    }
}
</code></pre> 
<p>隐式实现调用方法如下：</p> 
<pre><code>IChinese s = new Speaker();
s.Speak();

Speaker s = new Speaker();
s.Speak();
</code></pre> 
<p>都可以调用Speak这个方法。</p> 
<p>创建一个接口，IEnglish，包含一个成员 Speak;让我们的类Speaker来实现接口IEnglish</p> 
<pre><code>//显式实现例子
public interface IEnglish
{
    string Speak();
}
public class Speaker : IEnglish
{
     string English.Speak()
    {
        return "English";
    }
}

通过这种显示接口实现。Speak方法就只能通过接口来调用:

IEnglish s = new Speaker();
s.Speak(); 
下面的这种方式将会编译错误： 

Speaker s = new Speaker();
s.Speak(); 
隐式实现和显示实现的区别:
</code></pre> 
<p>** 一、语法的区别**</p> 
<p>1、隐式方式Speaker的成员（Speak）实现有而且必须有自己的访问修饰符（public），显示实现方式Speaker的成员（Speak）不能有任何的访问修饰符。<br> 2、显示实现方式Speaker使用接口名称和一个句点命名该类成员（Speak）来实现的：English.Speak();也就是</p> 
<p><strong>二、调用的区别</strong><br> 隐式接口实现的调用，注意类的声明，可以用接口声明，也可以用实现类 Speaker声明。调用者都可以得到调用实例化对象的行为Speak;</p> 
<pre><code>class Program
{
    static void Main(string[] args)
    {
        IChinese s = new Speaker();
        s.Speak();
        Speaker s = new Speaker();
        s.Speak();
    }
} 

显式接口实现调用，注意类的声明，只可以用接口声明，调用者才可以可以得到调用实例化对象的行为Speak;   


class Program
{
        static void Main(string[] args)
        {
            IEnglish s = new Speaker();
            s.Speak();
           //下面写法将引起编译错误错误“PetShop.Speaker”不包含“Speak”的定义；
           // Speaker s = new Speaker();
           // s.Speak();
        }
}
</code></pre> 
<p>结论：<br> 隐示实现对象声明为接口和类都可以访问到其行为，显示实现只有声明为接口可以访问。</p> 
<p>如果两个接口中有相同的方法名，那么同时实现这两个接口的类，就会出现不确定的情形，在编写方法时，也不知道实现哪个接口的方法了。为解决这一问题，C#提供了显示接口实现技术，就是在方法名前加接口名称，用接口名称来限定成员。用“接口名.方法名()”来区分实现的是哪一个接口。</p> 
<p>注意：显示接口实现时，在方法名前不能加任何访问修饰符。这种方式和普通方法不同，普通方法前不加访问修饰符，默认为私有的，而显式接口实现时方法前不加任何修饰符，默认为公有的，如果前面加上修饰符，会出现编译错误。</p> 
<p>调用显示接口实现的正确方式是通过接口引用，通过接口引用来确定要调用的版本。</p> 
<p>下面我们看一下完整实例：</p> 
<pre><code>using System;
public interface IPerson
{
　　string Name
　　{
    　　get;
    　　set;
　　}
　　void Show(string name);
}

public interface IStudent
{
　　string StudentId
　　{
    　　get;
    　　set;
　　}
　　void Show(string studentid);
}

public class Student: IPerson, IStudent
{
　　private string _name;
　　public string Name
　　{
    　　get
    　　{
      　　return _name;
    　　}
    　　set
    　　{
      　　_name = value;
    　　}
　　}

　　private string _studentid;
　　public string StudentId
　　{
    　　get
    　　{
      　　return _studentid;
    　　}
    　　set
    　　{
      　　_studentid = value;
    　　}
　　}

　　void IPerson.Show(string name)
　　{
    　　Console.WriteLine("姓名为{0}", name);
　　}

　　void IStudent.Show(string studentid)
　　{
    　　Console.WriteLine("学号为{0}", studentid);
　　}
}

class Program
{
　　static void Main()
　　{
    　　Student s = new Student();
    　　Console.WriteLine("输入姓名");
    　　s.Name = Console.ReadLine();
    　　Console.WriteLine("输入学号");
    　　s.StudentId = Console.ReadLine();
    　　IPerson per = s;
    　　per.Show(s.Name);
    　　IStudent stu = s;
    　　stu.Show(s.StudentId);
　　}
}
</code></pre>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/d618b9b2c064d97ba2280954eee86eee/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">Qt：Windows编程—Qt实现本地服务管理</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/65efec27696da0e1b426c81343cc11a0/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">tf.estimator.Estimator讲解</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>