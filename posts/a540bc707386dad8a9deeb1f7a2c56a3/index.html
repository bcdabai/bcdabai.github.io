<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>公共表表达式CTE递归查询学习篇1：WITH RECURSIVE关键字 - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="公共表表达式CTE递归查询学习篇1：WITH RECURSIVE关键字" />
<meta property="og:description" content="注：本文使用的是最新版的PgSQL(2023.06.07)
问题背景：在公司内的B2B电商系统中，下游交易环节，需要用户选择地址，而我采用了 省、市、区、街道 四级地址结构，例如：广东省→广州市→海珠区→江海街道。这是一条完整的地址层级关系。此时引入了Github中比较新(2023年6月4日更新)的地址关系csv。为了减少前端调用接口的次数，我选择在选择 xx市 之后使用递归查询将街道信息一并查出给前端。
地址表和转换SQL教程GitHub链接如下： GitHub - xiangyuecn/AreaCity-JsSpider-StatsGov: 省市区县乡镇三级或四级城市数据，带拼音标注、坐标、行政区域边界范围；2023年06月04日最新采集，提供csv格式文件，支持在线转成多级联动js代码、通用json格式，提供软件转成shp、geojson、sql、导入数据库；带浏览器里面运行的js采集源码，综合了中华人民共和国民政部、国家统计局、高德地图、腾讯地图行政区划数据https://github.com/xiangyuecn/AreaCity-JsSpider-StatsGov
Step1：了解表结构 直接上表结构：
表采用了四级地址结构：省、市、区(县)、街道。
Step2：了解需求：根据父级id递归查询所有子级目录。 熟悉表结构后，我们就可以开始递归查询实践了。
首先我们以广州市为例：id=4401。 需求：已知广州市主键id，我们要查出所有和广州市有关的子级数据。
那么，按照我们最简单、最常规的方法，就是通过parent_id去匹配后面两个子级的数据：
#查出三级(区)地址 SELECT * FROM b2b_area WHERE parent_id = 4401; #查出四级(街道)地址，其中l2.id是三级地址的id SELECT * FROM b2b_area WHERE parent_id = l3.id; 这里，我们使用了两个查询来完成广州市的子级地址查询。
1.问：但是，这不是也可以通过子查询的方法来完成吗？
1.答：是的，但这仅限于你在知道表中数据的层次情况下，才能通过子查询的方式完成，万一表的层次结构有10级怎么办？那就得写10个子查询。如果我压根不知道他到底有几层结构呢？很显然，用 子查询的方法 对于 多层级结构的数据 和 未知层级结构的数据表 来说，并不通用。
2.问：那对于这两种数据，该怎么解决？
2.答：用我们今天的主角 《CTE公共表拓展：递归表达式》。
Step3：使用CTE递归查出所有子级数据。 直接上代码：
WITH RECURSIVE addr_hierarchy(id, name, parent_id, level) AS ( -- 基本情况（市级地址） SELECT id, name, parent_id, area_level FROM b2b_area WHERE parent_id = 4401 UNION ALL -- 递归情况 SELECT ch." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/a540bc707386dad8a9deeb1f7a2c56a3/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-06-07T15:52:31+08:00" />
<meta property="article:modified_time" content="2023-06-07T15:52:31+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">公共表表达式CTE递归查询学习篇1：WITH RECURSIVE关键字</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p><u><em> 注：本文使用的是最新版的PgSQL(2023.06.07)</em></u></p> 
<blockquote> 
 <p><strong>问题背景：在公司内的B2B电商系统中，下游交易环节，需要用户选择地址，而我采用了 省、市、区、街道 四级地址结构，例如：广东省→广州市→海珠区→江海街道。这是一条完整的地址层级关系。此时引入了Github中比较新(2023年6月4日更新)的地址关系csv。为了减少前端调用接口的次数，我选择在选择 <em><u>xx市</u></em> 之后使用递归查询将街道信息一并查出给前端。</strong></p> 
</blockquote> 
<p><em><u>地址表和转换SQL教程GitHub链接如下：</u></em> </p> 
<p><a class="has-card" href="https://github.com/xiangyuecn/AreaCity-JsSpider-StatsGov" title="GitHub - xiangyuecn/AreaCity-JsSpider-StatsGov: 省市区县乡镇三级或四级城市数据，带拼音标注、坐标、行政区域边界范围；2023年06月04日最新采集，提供csv格式文件，支持在线转成多级联动js代码、通用json格式，提供软件转成shp、geojson、sql、导入数据库；带浏览器里面运行的js采集源码，综合了中华人民共和国民政部、国家统计局、高德地图、腾讯地图行政区划数据"><span class="link-card-box"><span class="link-title">GitHub - xiangyuecn/AreaCity-JsSpider-StatsGov: 省市区县乡镇三级或四级城市数据，带拼音标注、坐标、行政区域边界范围；2023年06月04日最新采集，提供csv格式文件，支持在线转成多级联动js代码、通用json格式，提供软件转成shp、geojson、sql、导入数据库；带浏览器里面运行的js采集源码，综合了中华人民共和国民政部、国家统计局、高德地图、腾讯地图行政区划数据</span><span class="link-link"><img alt="" class="link-link-icon" src="https://images2.imgbox.com/07/5b/KJP35dwN_o.png">https://github.com/xiangyuecn/AreaCity-JsSpider-StatsGov</span></span></a></p> 
<h3>Step1：了解表结构</h3> 
<p style="text-align:center;"><strong>直接上表结构：</strong><img alt="" height="1010" src="https://images2.imgbox.com/03/a3/5gIAxh7r_o.png" width="1200"></p> 
<blockquote> 
 <p> 表采用了四级地址结构：省、市、区(县)、街道。</p> 
</blockquote> 
<hr> 
<h3>Step2：了解需求：根据父级id递归查询所有子级目录。</h3> 
<blockquote> 
 <p>熟悉表结构后，我们就可以开始<u><strong><em>递归查询</em></strong></u>实践了。</p> 
 <p>首先我们以<strong>广州市</strong>为例：id=4401。 </p> 
 <p>需求：<strong>已知广州市主键id</strong>，我们要查出所有<strong>和广州市有关的子级数据。</strong></p> 
 <p></p> 
 <p>那么，按照我们<strong>最简单、最常规</strong>的方法，就是通过parent_id去匹配后面两个子级的数据：</p> 
 <pre><code class="language-sql">#查出三级(区)地址
SELECT * FROM b2b_area WHERE parent_id = 4401;</code></pre> 
 <pre><code class="language-sql">#查出四级(街道)地址，其中l2.id是三级地址的id
SELECT * FROM b2b_area WHERE parent_id = l3.id;</code></pre> 
 <p>这里，我们使用了两个查询来完成<strong>广州市的子级地址</strong>查询。</p> 
</blockquote> 
<p><strong>1.问：但是，这不是也可以通过子查询的方法来完成吗？</strong></p> 
<p><strong>1.答：是的，但这仅限于你在知道表中数据的层次情况下，才能通过子查询的方式完成，万一表的层次结构有10级怎么办？那就得写10个子查询。如果我压根不知道他到底有几层结构呢？很显然，用 <u><em>子查询的方法</em></u><u> </u>对于 <u><em>多层级结构的数据</em></u><strong> </strong>和 <em><u>未知层级结构的数据表</u></em> 来说，并不通用。</strong></p> 
<p><strong>2.问：那对于这两种数据，该怎么解决？</strong></p> 
<p><strong>2.答：用我们今天的主角 《CTE公共表拓展：递归表达式》。</strong></p> 
<hr> 
<h3><strong>Step3：使用CTE递归查出所有子级数据。</strong></h3> 
<p style="text-align:center;"><strong>直接上代码：</strong></p> 
<pre><code class="language-sql">WITH RECURSIVE addr_hierarchy(id, name, parent_id, level) AS (
    -- 基本情况（市级地址）
    SELECT id, name, parent_id, area_level
    FROM b2b_area
    WHERE parent_id = 4401
  UNION ALL
    -- 递归情况
    SELECT ch.id, ch.name, ch.parent_id, h.level + 1
    FROM b2b_area ch
    JOIN addr_hierarchy h ON ch.parent_id = h.id
)
SELECT * FROM addr_hierarchy ORDER BY level, id;</code></pre> 
<blockquote> 
 <p>上面这段SQL就是使用了CTE中的递归表达式。</p> 
 <p>那么接下来一一解释一下这几个名词：</p> 
 <p><strong>CTE：</strong>公共表表达式，简单的说它是一个 <strong>命名的临时结果集 </strong>，可以将它简单的理解为一个<strong>语句级的临时表。</strong></p> 
 <p><strong>但是它不等于临时表！不等于临时表！不等于临时表！</strong></p> 
 <p></p> 
 <p><strong>递归CTE：</strong>是一种CTE的拓展，可以理解为<strong>通过递归查询的形式生成一个临时表。</strong>如上面的<strong>SQL代码</strong>所示。</p> 
</blockquote> 
<p>接下来具体解释一下<strong>递归CTE</strong>：</p> 
<blockquote> 
 <p>递归CTE的基本写法格式如下：</p> 
 <pre><code class="language-sql">WITH RECURSIVE &lt;临时表名&gt;(&lt;自定义字段名1&gt;, &lt;自定义字段名2&gt;, ...) AS (
    -- 基本情况查询语句
    SELECT xxx 
    FROM xxx 
    WHERE xxx = xxx
  UNION ALL
    -- 递归情况
    SELECT xxx ,level + 1
    FROM xxx
    JOIN &lt;临时表名&gt; ON xxx = xxx
)
-- 查询出最终结果
SELECT * FROM &lt;临时表名&gt; ORDER BY xxx;</code></pre> 
 <p>这是一个最基本的递归CTE写法，其中：</p> 
 <p><strong>基本情况：一般是查询结构树的某个父节点的数据</strong></p> 
 <p><strong>递归情况：根据父节点的数据(比如id)，根据特定条件查询该父节点下的子节点和叶子节点(比如parent_id = 父节点.id)。</strong></p> 
</blockquote> 
<hr> 
<h3>Step4：表中实践。</h3> 
<p style="text-align:center;"><strong>接下来，我们直接在表中实践一下。</strong></p> 
<p style="text-align:center;"><strong>上图！</strong></p> 
<p style="text-align:center;"><img alt="" height="829" src="https://images2.imgbox.com/d2/c1/zWumc6GJ_o.png" width="1200"></p> 
<blockquote> 
 <p>可以看出，通过这个递归语句，直接将<strong>parent_id为4401(广州市)</strong>的子节点、叶子节点数据全部查出来了。</p> 
</blockquote> 
<hr> 
<p><strong>总结：</strong></p> 
<p><strong>1. 在已知级数切级数较少的多级子节点查询中，我们一般可以直接采用子查询的方式来完成多级树型结构的组装。</strong></p> 
<p><strong>2. 对于多级树型结构和未知级数的树形结构，我们可以使用递归CTE查询的方法来完成所有子节点的查询。</strong></p> 
<p><strong>3. （重要）CTE不等于临时表，具体的区别如下：</strong></p> 
<p><strong>    3.1. 生命周期不同：</strong><strong>CTE 的生命周期仅限于<u><em>当前 SQL 查询</em></u>，即一旦完成定义并在查询中使用，CTE 就会被自动销毁。</strong></p> 
<p><strong>而临时表在会话级别存在，这意味着在<u><em>当前会话 (SQL Server是全局) </em></u>中可以在多个查询间重复使用临时表。当会话结束时，临时表会被销毁。</strong></p> 
<p><strong>    3.2. 使用场景不同：</strong><strong>CTE 用于简化复杂的查询语句，提高可读性。CTE 的特点是<u><em>可以方便地创建递归查询，处理层次结构数据 </em></u>等。</strong></p> 
<p><strong>临时表主要用于在<em><u>多个查询之间存储和共享数据</u></em>。特别是当需要在存储过程、函数或触发器中重复使用这些数据时，临时表优势非常明显。</strong></p> 
<p><strong>    3.3. 性能：</strong><strong>CTE 的性能优势在于<u><em>处理子查询和递归查询</em></u>，因为它容易优化，减少了整体查询操作的复杂性。<u><em>对于递归查询、层次结构查询等场景，使用 CTE 可以提高查询的性能</em></u>。</strong></p> 
<p><strong>临时表的性能优点在于存储和重用中间结果。当数据量大时，临时表可能消耗更多资源，但在多个查询中重复使用时，它可以降低对数据的再次计算，提高性能。然而，在处理递归查询等场景时，临时表可能不如 CTE 高效。</strong></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/43523d58851afee10aabd8e7e043a970/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">自定义组件中，使用onLoad,onShow生命周期失效问题</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/d66013a550f1b20f61838a739018f826/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">Termius 最好用的SSH 连接工具</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>