<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>[swift实战入门]手把手教你编写2048(三) - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="[swift实战入门]手把手教你编写2048(三)" />
<meta property="og:description" content="上篇地址：swift实战入门之手把手教你编写2048(二) github地址：https://github.com/scarlettbai/2048.git。
今天给大家带来2048最后一篇，之前已经实现了向游戏区域中随机插入数字块，接下来要做的，就是当我们滑动屏幕时移动及合并数字块以及插入一个新的数字块。本篇的难点就是移动时的算法问题，首先来给大家讲一下算法。 2048的算法实现其实很简单，假如我们当前数字格的格式如下： | |4| | | | | |4| | |2| |2|2| |2| | | | 如果用户选择向上滑动，那么这里我们算法里要做的是，先取出第一列的4个格存为一个数组，对应坐标为[(0,1),(0,2),(0,3),(0,4)]，其中对应的值为| | |2|2|,首先对数组进行去除空操作，去除之后数据为：[(0,3),(0,4)]，对应值为|2|2|,之后再进行合并操作，合并时我们可以取到数组中原来两个2的坐标以及最终坐标，那么此时我们只要更新存储当前数字块状态的数组以及数字块视图，将之前两个2的地方置空，并在(0,1)处插入一个4即可，之后再继续遍历下一列做同样的操作即可。 这里用户一共有4个操作，上下左右，分别取出对应的行列一行(列)一行(列)的进行处理即可。那么接下来看代码： 首先我们定义几个枚举： //用户操作---上下左右 enum MoveDirection { case UP,DOWN,LEFT,RIGHT } //用于存放数字块的移动状态，是否需要移动以及两个一块合并并移动等，关键数据是数组中位置以及最新的数字块的值 enum TileAction{ case NOACTION(source : Int , value : Int) case MOVE(source : Int , value : Int) case SINGLECOMBINE(source : Int , value : Int) case DOUBLECOMBINE(firstSource : Int , secondSource : Int , value : Int) func getValue() -&gt; Int { switch self { case let ." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/4468c6c442e02833bb75823257956555/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2016-04-24T21:25:55+08:00" />
<meta property="article:modified_time" content="2016-04-24T21:25:55+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">[swift实战入门]手把手教你编写2048(三)</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-github-gist">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <blockquote> 
 <p>上篇地址：<a href="http://blog.scarlettbai.com/swift-2048-2-t1460210839/" rel="nofollow">swift实战入门之手把手教你编写2048(二)</a> <br> github地址：<a href="https://github.com/scarlettbai/2048.git">https://github.com/scarlettbai/2048.git</a>。</p> 
</blockquote> 
<p>今天给大家带来2048最后一篇，之前已经实现了向游戏区域中随机插入数字块，接下来要做的，就是当我们滑动屏幕时移动及合并数字块以及插入一个新的数字块。本篇的难点就是移动时的算法问题，首先来给大家讲一下算法。 </p> 
<p>2048的算法实现其实很简单，假如我们当前数字格的格式如下： </p> 
<pre class="prettyprint"><code class="language-java hljs ">| |<span class="hljs-number">4</span>| | |
| | |<span class="hljs-number">4</span>| |
|<span class="hljs-number">2</span>| |<span class="hljs-number">2</span>|<span class="hljs-number">2</span>|
|<span class="hljs-number">2</span>| | | |</code></pre> 
<p>如果用户选择向上滑动，那么这里我们算法里要做的是，<strong>先取出第一列的4个格存为一个数组，对应坐标为[(0,1),(0,2),(0,3),(0,4)]，其中对应的值为| | |2|2|,首先对数组进行去除空操作，去除之后数据为：[(0,3),(0,4)]，对应值为|2|2|,之后再进行合并操作</strong>，合并时我们可以取到数组中原来两个2的坐标以及最终坐标，那么此时我们只要更新存储当前数字块状态的数组以及数字块视图，将之前两个2的地方置空，并在(0,1)处插入一个4即可，之后再继续遍历下一列做同样的操作即可。 </p> 
<p>这里用户一共有4个操作，上下左右，分别取出对应的行列一行(列)一行(列)的进行处理即可。那么接下来看代码： </p> 
<p>首先我们定义几个枚举： </p> 
<pre class="prettyprint"><code class="language-java hljs "><span class="hljs-comment">//用户操作---上下左右</span>
<span class="hljs-keyword">enum</span> MoveDirection {
    <span class="hljs-keyword">case</span> UP,DOWN,LEFT,RIGHT
}
<span class="hljs-comment">//用于存放数字块的移动状态，是否需要移动以及两个一块合并并移动等，关键数据是数组中位置以及最新的数字块的值</span>
<span class="hljs-keyword">enum</span> TileAction{
    <span class="hljs-keyword">case</span> NOACTION(source : Int , value : Int)
    <span class="hljs-keyword">case</span> MOVE(source : Int , value : Int)
    <span class="hljs-keyword">case</span> SINGLECOMBINE(source : Int , value : Int)
    <span class="hljs-keyword">case</span> DOUBLECOMBINE(firstSource : Int , secondSource : Int , value : Int)

    func getValue() -&gt; Int {
        <span class="hljs-keyword">switch</span> self {
        <span class="hljs-keyword">case</span> let .NOACTION(_, value) : <span class="hljs-keyword">return</span> value
        <span class="hljs-keyword">case</span> let .MOVE(_, value) : <span class="hljs-keyword">return</span> value
        <span class="hljs-keyword">case</span> let .SINGLECOMBINE(_, value) : <span class="hljs-keyword">return</span> value
        <span class="hljs-keyword">case</span> let .DOUBLECOMBINE(_, _, value) : <span class="hljs-keyword">return</span> value
        }
    }

    func getSource() -&gt; Int {
        <span class="hljs-keyword">switch</span> self {
        <span class="hljs-keyword">case</span> let .NOACTION(source , _) : <span class="hljs-keyword">return</span> source
        <span class="hljs-keyword">case</span> let .MOVE(source , _) : <span class="hljs-keyword">return</span> source
        <span class="hljs-keyword">case</span> let .SINGLECOMBINE(source , _) : <span class="hljs-keyword">return</span> source
        <span class="hljs-keyword">case</span> let .DOUBLECOMBINE(source , _ , _) : <span class="hljs-keyword">return</span> source
        }
    }
}
<span class="hljs-comment">//最终的移动数据封装，标注了所有需移动的块的原位置及新位置，以及块的最新值</span>
<span class="hljs-keyword">enum</span> MoveOrder{
    <span class="hljs-keyword">case</span> SINGLEMOVEORDER(source : Int , destination : Int , value : Int , merged : Bool)
    <span class="hljs-keyword">case</span> DOUBLEMOVEORDER(firstSource : Int , secondSource : Int , destination : Int , value : Int)
}</code></pre> 
<p>接下来就看具体算法： </p> 
<pre class="prettyprint"><code class="language-java hljs ">func merge(group : [TileEnum]) -&gt; [MoveOrder] {
    <span class="hljs-keyword">return</span> convert(collapse(condense(group)))
}

<span class="hljs-comment">//去除空   如：| | |2|2|去掉空为：|2|2| | |</span>
func condense(group : [TileEnum]) -&gt; [TileAction] {
    var buffer = [TileAction]()
    <span class="hljs-keyword">for</span> (index , tile) in group.enumerate(){
        <span class="hljs-keyword">switch</span> tile {
        <span class="hljs-comment">//如果buffer的大小和当前group的下标一致，则表示当前数字块不需要移动</span>
        <span class="hljs-comment">//如|2| |2| |,第一次时buffer大小和index都是0，不需要移动</span>
        <span class="hljs-comment">//下一个2时，buffer大小为1，groupindex为2，则需要移动了</span>
        <span class="hljs-keyword">case</span> let .Tile(value) where buffer.count == index :
            buffer.append(TileAction.NOACTION(source: index, value: value))
        <span class="hljs-keyword">case</span> let .Tile(value) :
            buffer.append(TileAction.MOVE(source: index, value: value))
        <span class="hljs-keyword">default</span>:
            <span class="hljs-keyword">break</span>
        }
    }
    <span class="hljs-keyword">return</span> buffer
}

<span class="hljs-comment">//合并相同的    如：|2| | 2|2|合并为：|4|2| | |</span>
func collapse(group : [TileAction]) -&gt; [TileAction] {

    var tokenBuffer = [TileAction]()
    <span class="hljs-comment">//是否跳过下一个，如果把下一个块合并过来，则下一个数字块应该跳过</span>
    var skipNext = <span class="hljs-keyword">false</span>
    <span class="hljs-keyword">for</span> (idx, token) in group.enumerate() {
        <span class="hljs-keyword">if</span> skipNext {
            skipNext = <span class="hljs-keyword">false</span>
            <span class="hljs-keyword">continue</span>
        }
        <span class="hljs-keyword">switch</span> token {
        <span class="hljs-comment">//当前块和下一个块的值相同且当前块不需要移动，那么需要将下一个块合并到当前块来</span>
        <span class="hljs-keyword">case</span> let .NOACTION(s, v)
            where (idx &lt; group.count-<span class="hljs-number">1</span>
                &amp;&amp; v == group[idx+<span class="hljs-number">1</span>].getValue()
                &amp;&amp; GameModle.quiescentTileStillQuiescent(idx, outputLength: tokenBuffer.count, originalPosition: s)):
            let next = group[idx+<span class="hljs-number">1</span>]
            let nv = v + group[idx+<span class="hljs-number">1</span>].getValue()
            skipNext = <span class="hljs-keyword">true</span>
            tokenBuffer.append(TileAction.SINGLECOMBINE(source: next.getSource(), value: nv))
        <span class="hljs-comment">//当前块和下一个块的值相同，且两个块都需要移动，则将两个块移动到新的位置</span>
        <span class="hljs-keyword">case</span> let t where (idx &lt; group.count-<span class="hljs-number">1</span> &amp;&amp; t.getValue() == group[idx+<span class="hljs-number">1</span>].getValue()):
            let next = group[idx+<span class="hljs-number">1</span>]
            let nv = t.getValue() + group[idx+<span class="hljs-number">1</span>].getValue()
            skipNext = <span class="hljs-keyword">true</span>
            tokenBuffer.append(TileAction.DOUBLECOMBINE(firstSource: t.getSource(), secondSource: next.getSource(), value: nv))
        <span class="hljs-comment">//上一步判定不需要移动，但是之前的块有合并过，所以需要移动</span>
        <span class="hljs-keyword">case</span> let .NOACTION(s, v) where !GameModle.quiescentTileStillQuiescent(idx, outputLength: tokenBuffer.count, originalPosition: s):
            tokenBuffer.append(TileAction.MOVE(source: s, value: v))
        <span class="hljs-comment">//上一步判定不需要移动，且之前的块也没有合并，则不需要移动</span>
        <span class="hljs-keyword">case</span> let .NOACTION(s, v):
            tokenBuffer.append(TileAction.NOACTION(source: s, value: v))
        <span class="hljs-comment">//上一步判定需要移动且不符合上面的条件的，则继续保持移动</span>
        <span class="hljs-keyword">case</span> let .MOVE(s, v):
            tokenBuffer.append(TileAction.MOVE(source: s, value: v))
        <span class="hljs-keyword">default</span>:
            <span class="hljs-keyword">break</span>
        }
    }
    <span class="hljs-keyword">return</span> tokenBuffer
}

class func quiescentTileStillQuiescent(inputPosition: Int, outputLength: Int, originalPosition: Int) -&gt; Bool {
    <span class="hljs-keyword">return</span> (inputPosition == outputLength) &amp;&amp; (originalPosition == inputPosition)
}

<span class="hljs-comment">//转换为MOVEORDER便于后续处理</span>
func convert(group : [TileAction]) -&gt; [MoveOrder] {
    var buffer = [MoveOrder]()
    <span class="hljs-keyword">for</span> (idx , tileAction) in group.enumerate() {
        <span class="hljs-keyword">switch</span> tileAction {
        <span class="hljs-keyword">case</span> let .MOVE(s, v) :
            <span class="hljs-comment">//单纯的将一个块由s位置移动到idx位置，新值为v</span>
            buffer.append(MoveOrder.SINGLEMOVEORDER(source: s, destination: idx, value: v, merged: <span class="hljs-keyword">false</span>))
        <span class="hljs-keyword">case</span> let .SINGLECOMBINE(s, v) :
            <span class="hljs-comment">//将一个块由s位置移动到idx位置，且idx位置有数字块，俩数字块进行合并，新值为v</span>
            buffer.append(MoveOrder.SINGLEMOVEORDER(source: s, destination: idx, value: v, merged: <span class="hljs-keyword">true</span>))
        <span class="hljs-keyword">case</span> let .DOUBLECOMBINE(s, d, v) :
            <span class="hljs-comment">//将s和d两个数字块移动到idx位置并进行合并，新值为v</span>
            buffer.append(MoveOrder.DOUBLEMOVEORDER(firstSource: s, secondSource: d, destination: idx, value: v))
        <span class="hljs-keyword">default</span>:
            <span class="hljs-keyword">break</span>
        }
    }
    <span class="hljs-keyword">return</span> buffer
}</code></pre> 
<p>上面代码里注释已经很详细了，这里再简单说下，<code>**condense</code>方法的作用就是去除空的数字块<strong>，入参就是一列的四个数字块，里面是定义了一个<code>TileAction</code>数组buffer，之后判断入参中不为空的则加入buffer中，其中只是做了判断数字块是否需要移动。</strong><code>collapse</code>方法就是合并操作**，其实只是记录一个合并状态，如果不需要合并的就还是只判断是否需要移动，<code>convert</code>中则将<code>collapse</code>中返回的结果进行包装，表明具体的移动前和移动后的位置，以及新的值和是否需要合并。 </p> 
<p>这里算法的具体实现就做完了，下面来看下具体调用： </p> 
<pre class="prettyprint"><code class="language-java hljs "><span class="hljs-comment">//提供给主控制器调用，入参为移动方向和一个需要一个是否移动过的Bool值为入参的闭包    </span>
func queenMove(direction : MoveDirection , completion : (Bool) -&gt; ()){
    let changed = performMove(direction)
    completion(changed)

}
<span class="hljs-comment">//移动实现</span>
func performMove(direction : MoveDirection) -&gt; Bool {
    <span class="hljs-comment">//根据上下左右返回每列(行)的四个块的坐标</span>
    let getMoveQueen : (Int) -&gt; [(Int , Int)] = { (idx : Int) -&gt; [(Int , Int)] in
        var buffer = Array&lt;(Int , Int)&gt;(count : self.dimension , repeatedValue : (<span class="hljs-number">0</span>, <span class="hljs-number">0</span>))
        <span class="hljs-keyword">for</span> i in <span class="hljs-number">0.</span>.&lt;self.dimension {
            <span class="hljs-keyword">switch</span> direction {
            <span class="hljs-keyword">case</span> .UP : buffer[i] = (idx, i)
            <span class="hljs-keyword">case</span> .DOWN : buffer[i] = (idx, self.dimension - i - <span class="hljs-number">1</span>)
            <span class="hljs-keyword">case</span> .LEFT : buffer[i] = (i, idx)
            <span class="hljs-keyword">case</span> .RIGHT : buffer[i] = (self.dimension - i - <span class="hljs-number">1</span>, idx)
            }
        }
        <span class="hljs-keyword">return</span> buffer
    }
    var movedFlag = <span class="hljs-keyword">false</span>
    <span class="hljs-comment">//逐列(行)进行处理</span>
    <span class="hljs-keyword">for</span> i in <span class="hljs-number">0.</span>.&lt;self.dimension {
        <span class="hljs-comment">//获取当前列(行)的4个坐标</span>
        let moveQueen = getMoveQueen(i)
        <span class="hljs-comment">//从gamebord中取出当前4个坐标中的值存为数组</span>
        let tiles = moveQueen.map({ (c : (Int, Int)) -&gt; TileEnum in
            let (source , value) = c
            <span class="hljs-keyword">return</span> self.gamebord[source , value]
        })
        <span class="hljs-comment">//调用算法</span>
        let moveOrders = merge(tiles)
        movedFlag = moveOrders.count &gt; <span class="hljs-number">0</span> ? <span class="hljs-keyword">true</span> : movedFlag
        <span class="hljs-comment">//对算法返回结果进行具体处理.1:更新gamebord中的数据，2:更新视图中的数字块</span>
        <span class="hljs-keyword">for</span> order in moveOrders {
            <span class="hljs-keyword">switch</span> order {
            <span class="hljs-comment">//单个移动或合并的</span>
            <span class="hljs-keyword">case</span> let .SINGLEMOVEORDER(s, d, v, m):
                let (sx, sy) = moveQueen[s]
                let (dx, dy) = moveQueen[d]
                <span class="hljs-keyword">if</span> m {
                    self.score += v
                }
                <span class="hljs-comment">//将原位置置空，新位置设置为新的值</span>
                gamebord[sx , sy] = TileEnum.Empty
                gamebord[dx , dy] = TileEnum.Tile(v)
                <span class="hljs-comment">//TODO 调用游戏视图更新视图中的数字块   </span>
                delegate.moveOneTile((sx, sy), to: (dx, dy), value: v)
            <span class="hljs-comment">//两个进行合并的</span>
            <span class="hljs-keyword">case</span> let .DOUBLEMOVEORDER(fs , ts , d , v):
                let (fsx , fsy) = moveQueen[fs]
                let (tsx , tsy) = moveQueen[ts]
                let (dx , dy) = moveQueen[d]
                self.score += v
                <span class="hljs-comment">//将原位置置空，新位置设置为新的值</span>
                gamebord[fsx , fsy] = TileEnum.Empty
                gamebord[tsx , tsy] = TileEnum.Empty
                gamebord[dx , dy] = TileEnum.Tile(v)
                <span class="hljs-comment">//TODO 调用游戏视图更新视图中的数字块   </span>
                delegate.moveTwoTiles((moveQueen[fs], moveQueen[ts]), to: moveQueen[d], value: v)

            }
        }
    }
    <span class="hljs-keyword">return</span> movedFlag
}</code></pre> 
<p>可以看到，上面调用我们之前写的算法，以及将gamebord中存储内容更新了(gamebord存储的是当前各个位置的数字块状态，前两篇有介绍)，接下来需要更新游戏视图中的数字块，接下来在GamebordView.swift中添加如下代码： </p> 
<pre class="prettyprint"><code class="language-java hljs "><span class="hljs-comment">//从from位置移动一个块到to位置，并赋予新的值value</span>
func moveOneTiles(from : (Int , Int)  , to : (Int , Int) , value : Int) {
    let (fx , fy) = from
    let (tx , ty) = to
    let fromKey = NSIndexPath(forRow: fx , inSection: fy)
    let toKey = NSIndexPath(forRow: tx, inSection: ty)
    <span class="hljs-comment">//取出from位置和to位置的数字块</span>
    guard let tile = tiles[fromKey] <span class="hljs-keyword">else</span>{
        <span class="hljs-keyword">assert</span>(<span class="hljs-keyword">false</span>, <span class="hljs-string">"not exists tile"</span>)
    }
    let endTile = tiles[toKey]
    <span class="hljs-comment">//将from位置的数字块的位置定到to位置</span>
    var changeFrame = tile.frame
    changeFrame.origin.x = tilePadding + CGFloat(tx)*(tilePadding + tileWidth)
    changeFrame.origin.y = tilePadding + CGFloat(ty)*(tilePadding + tileWidth)

    tiles.removeValueForKey(fromKey)
    tiles[toKey] = tile

    <span class="hljs-comment">// 动画以及给新位置的数字块赋值</span>
    let shouldPop = endTile != nil
    UIView.animateWithDuration(perSquareSlideDuration,
                               delay: <span class="hljs-number">0.0</span>,
                               options: UIViewAnimationOptions.BeginFromCurrentState,
                               animations: {
                                tile.frame = changeFrame
        },
                               completion: { (finished: Bool) -&gt; Void in
                                <span class="hljs-comment">//对新位置的数字块赋值</span>
                                tile.value = value
                                endTile?.removeFromSuperview()
                                <span class="hljs-keyword">if</span> !shouldPop || !finished {
                                    <span class="hljs-keyword">return</span>
                                }
                                tile.layer.setAffineTransform(CGAffineTransformMakeScale(self.tileMergeStartScale, self.tileMergeStartScale))
                                UIView.animateWithDuration(self.tileMergeExpandTime,
                                    animations: {
                                        tile.layer.setAffineTransform(CGAffineTransformMakeScale(self.tilePopMaxScale, self.tilePopMaxScale))
                                    },
                                    completion: { finished in
                                        UIView.animateWithDuration(self.tileMergeContractTime) {
                                            tile.layer.setAffineTransform(CGAffineTransformIdentity)
                                        }
                                })
    })
}
<span class="hljs-comment">//将from里两个位置的数字块移动到to位置，并赋予新的值，原理同上</span>
func moveTwoTiles(from: ((Int, Int), (Int, Int)), to: (Int, Int), value: Int) {
    <span class="hljs-keyword">assert</span>(positionIsValid(from<span class="hljs-number">.0</span>) &amp;&amp; positionIsValid(from<span class="hljs-number">.1</span>) &amp;&amp; positionIsValid(to))
    let (fromRowA, fromColA) = from<span class="hljs-number">.0</span>
    let (fromRowB, fromColB) = from<span class="hljs-number">.1</span>
    let (toRow, toCol) = to
    let fromKeyA = NSIndexPath(forRow: fromRowA, inSection: fromColA)
    let fromKeyB = NSIndexPath(forRow: fromRowB, inSection: fromColB)
    let toKey = NSIndexPath(forRow: toRow, inSection: toCol)

    guard let tileA = tiles[fromKeyA] <span class="hljs-keyword">else</span> {
        <span class="hljs-keyword">assert</span>(<span class="hljs-keyword">false</span>, <span class="hljs-string">"placeholder error"</span>)
    }
    guard let tileB = tiles[fromKeyB] <span class="hljs-keyword">else</span> {
        <span class="hljs-keyword">assert</span>(<span class="hljs-keyword">false</span>, <span class="hljs-string">"placeholder error"</span>)
    }

    var finalFrame = tileA.frame
    finalFrame.origin.x = tilePadding + CGFloat(toRow)*(tileWidth + tilePadding)
    finalFrame.origin.y = tilePadding + CGFloat(toCol)*(tileWidth + tilePadding)

    let oldTile = tiles[toKey]  
    oldTile?.removeFromSuperview()
    tiles.removeValueForKey(fromKeyA)
    tiles.removeValueForKey(fromKeyB)
    tiles[toKey] = tileA

    UIView.animateWithDuration(perSquareSlideDuration,
                               delay: <span class="hljs-number">0.0</span>,
                               options: UIViewAnimationOptions.BeginFromCurrentState,
                               animations: {
                                tileA.frame = finalFrame
                                tileB.frame = finalFrame
        },
                               completion: { finished in
                                <span class="hljs-comment">//赋值</span>
                                tileA.value = value
                                tileB.removeFromSuperview()
                                <span class="hljs-keyword">if</span> !finished {
                                    <span class="hljs-keyword">return</span>
                                }
                                tileA.layer.setAffineTransform(CGAffineTransformMakeScale(self.tileMergeStartScale, self.tileMergeStartScale))
                                UIView.animateWithDuration(self.tileMergeExpandTime,
                                    animations: {
                                        tileA.layer.setAffineTransform(CGAffineTransformMakeScale(self.tilePopMaxScale, self.tilePopMaxScale))
                                    },
                                    completion: { finished in
                                        UIView.animateWithDuration(self.tileMergeContractTime) {
                                            tileA.layer.setAffineTransform(CGAffineTransformIdentity)
                                        }
                                })
    })
}

func positionIsValid(pos: (Int, Int)) -&gt; Bool {
    let (x, y) = pos
    <span class="hljs-keyword">return</span> (x &gt;= <span class="hljs-number">0</span> &amp;&amp; x &lt; dimension &amp;&amp; y &gt;= <span class="hljs-number">0</span> &amp;&amp; y &lt; dimension)
}</code></pre> 
<p>上面方法更新了游戏视图中的数字块状态。那么接下来我们在主控制器中调用queenMove就可以运行游戏看移动效果了，在NumbertailGameController.swift的NumbertailGameController类中添加如下代码： </p> 
<pre class="prettyprint"><code class="language-java hljs "><span class="hljs-comment">//注册监听器，监听当前视图里的手指滑动操作，上下左右分别对应下面的四个方法</span>
func setupSwipeConttoller() {
    let upSwipe = UISwipeGestureRecognizer(target: self , action: #selector(NumbertailGameController.upCommand(_:)))
    upSwipe.numberOfTouchesRequired = <span class="hljs-number">1</span>
    upSwipe.direction = UISwipeGestureRecognizerDirection.Up
    view.addGestureRecognizer(upSwipe)

    let downSwipe = UISwipeGestureRecognizer(target: self , action: #selector(NumbertailGameController.downCommand(_:)))
    downSwipe.numberOfTouchesRequired = <span class="hljs-number">1</span>
    downSwipe.direction = UISwipeGestureRecognizerDirection.Down
    view.addGestureRecognizer(downSwipe)

    let leftSwipe = UISwipeGestureRecognizer(target: self , action: #selector(NumbertailGameController.leftCommand(_:)))
    leftSwipe.numberOfTouchesRequired = <span class="hljs-number">1</span>
    leftSwipe.direction = UISwipeGestureRecognizerDirection.Left
    view.addGestureRecognizer(leftSwipe)

    let rightSwipe = UISwipeGestureRecognizer(target: self , action: #selector(NumbertailGameController.rightCommand(_:)))
    rightSwipe.numberOfTouchesRequired = <span class="hljs-number">1</span>
    rightSwipe.direction = UISwipeGestureRecognizerDirection.Right
    view.addGestureRecognizer(rightSwipe)
}
<span class="hljs-comment">//向上滑动的方法，调用queenMove，传入MoveDirection.UP</span>
func upCommand(r : UIGestureRecognizer) {
    let m = gameModle!
    m.queenMove(MoveDirection.UP , completion: { (changed : Bool) -&gt; () in
        <span class="hljs-keyword">if</span>  changed {
            self.followUp()
        }
    })
}
<span class="hljs-comment">//向下滑动的方法，调用queenMove，传入MoveDirection.DOWN</span>
func downCommand(r : UIGestureRecognizer) {
    let m = gameModle!
    m.queenMove(MoveDirection.DOWN , completion: { (changed : Bool) -&gt; () in
        <span class="hljs-keyword">if</span>  changed {
            self.followUp()
        }
    })
}
<span class="hljs-comment">//向左滑动的方法，调用queenMove，传入MoveDirection.LEFT</span>
func leftCommand(r : UIGestureRecognizer) {
    let m = gameModle!
    m.queenMove(MoveDirection.LEFT , completion: { (changed : Bool) -&gt; () in
        <span class="hljs-keyword">if</span>  changed {
            self.followUp()
        }
    })
}
<span class="hljs-comment">//向右滑动的方法，调用queenMove，传入MoveDirection.RIGHT</span>
func rightCommand(r : UIGestureRecognizer) {
    let m = gameModle!
    m.queenMove(MoveDirection.RIGHT , completion: { (changed : Bool) -&gt; () in
        <span class="hljs-keyword">if</span>  changed {
            self.followUp()
        }
    })
}
<span class="hljs-comment">//移动之后需要判断用户的输赢情况，如果赢了则弹框提示，给一个重玩和取消按钮</span>
func followUp() {
    <span class="hljs-keyword">assert</span>(gameModle != nil)
    let m = gameModle!
    let (userWon, _) = m.userHasWon()
    <span class="hljs-keyword">if</span> userWon {
        let winAlertView = UIAlertController(title: <span class="hljs-string">"結果"</span>, message: <span class="hljs-string">"你贏了"</span>, preferredStyle: UIAlertControllerStyle.Alert)
        let resetAction = UIAlertAction(title: <span class="hljs-string">"重置"</span>, style: UIAlertActionStyle.Default, handler: {(u : UIAlertAction) -&gt; () in
            self.reset()
        })
        winAlertView.addAction(resetAction)
        let cancleAction = UIAlertAction(title: <span class="hljs-string">"取消"</span>, style: UIAlertActionStyle.Default, handler: nil)
        winAlertView.addAction(cancleAction)
        self.presentViewController(winAlertView, animated: <span class="hljs-keyword">true</span>, completion: nil)
        <span class="hljs-keyword">return</span>
    }
    <span class="hljs-comment">//如果没有赢则需要插入一个新的数字块</span>
    let randomVal = Int(arc4random_uniform(<span class="hljs-number">10</span>))
    m.insertRandomPositoinTile(randomVal == <span class="hljs-number">1</span> ? <span class="hljs-number">4</span> : <span class="hljs-number">2</span>)
    <span class="hljs-comment">//插入数字块后判断是否输了，输了则弹框提示</span>
    <span class="hljs-keyword">if</span> m.userHasLost() {
        NSLog(<span class="hljs-string">"You lost..."</span>)
        let lostAlertView = UIAlertController(title: <span class="hljs-string">"結果"</span>, message: <span class="hljs-string">"你輸了"</span>, preferredStyle: UIAlertControllerStyle.Alert)
        let resetAction = UIAlertAction(title: <span class="hljs-string">"重置"</span>, style: UIAlertActionStyle.Default, handler: {(u : UIAlertAction) -&gt; () in
            self.reset()
        })
        lostAlertView.addAction(resetAction)
        let cancleAction = UIAlertAction(title: <span class="hljs-string">"取消"</span>, style: UIAlertActionStyle.Default, handler: nil)
        lostAlertView.addAction(cancleAction)
        self.presentViewController(lostAlertView, animated: <span class="hljs-keyword">true</span>, completion: nil)
    }
}</code></pre> 
<p>上面代码中的userHasLost和userHasWon方法需要在GameModel中进行判断，这里是通过gameModle进行调用的，接下来看下具体的判断代码： </p> 
<pre class="prettyprint"><code class="language-java hljs "><span class="hljs-comment">//如果gamebord中有超过我们定的最大分数threshold的，则用户赢了</span>
func userHasWon() -&gt; (Bool, (Int, Int)?) {
    <span class="hljs-keyword">for</span> i in <span class="hljs-number">0.</span>.&lt;dimension {
        <span class="hljs-keyword">for</span> j in <span class="hljs-number">0.</span>.&lt;dimension {
            <span class="hljs-keyword">if</span> <span class="hljs-keyword">case</span> let .Tile(v) = gamebord[i, j] where v &gt;= threshold {
                <span class="hljs-keyword">return</span> (<span class="hljs-keyword">true</span>, (i, j))
            }
        }
    }
    <span class="hljs-keyword">return</span> (<span class="hljs-keyword">false</span>, nil)
}
<span class="hljs-comment">//当前gamebord已经满了且两两间的值都不同，则用户输了    </span>
func userHasLost() -&gt; Bool {
    guard getEmptyPosition().isEmpty <span class="hljs-keyword">else</span> {
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>
    }
    <span class="hljs-keyword">for</span> i in <span class="hljs-number">0.</span>.&lt;dimension {
        <span class="hljs-keyword">for</span> j in <span class="hljs-number">0.</span>.&lt;dimension {
            <span class="hljs-keyword">switch</span> gamebord[i, j] {
            <span class="hljs-keyword">case</span> .Empty:
                <span class="hljs-keyword">assert</span>(<span class="hljs-keyword">false</span>, <span class="hljs-string">"Gameboard reported itself as full, but we still found an empty tile. This is a logic error."</span>)
            <span class="hljs-keyword">case</span> let .Tile(v):
                <span class="hljs-keyword">if</span> tileBelowHasSameValue((i, j), v) || tileToRightHasSameValue((i, j), v) {
                    <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>
                }
            }
        }
    }
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>
}

func tileBelowHasSameValue(location: (Int, Int), _ value: Int) -&gt; Bool {
    let (x, y) = location
    guard y != dimension - <span class="hljs-number">1</span> <span class="hljs-keyword">else</span> {
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>
    }
    <span class="hljs-keyword">if</span> <span class="hljs-keyword">case</span> let .Tile(v) = gamebord[x, y+<span class="hljs-number">1</span>] {
        <span class="hljs-keyword">return</span> v == value
    }
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>
}

func tileToRightHasSameValue(location: (Int, Int), _ value: Int) -&gt; Bool {
    let (x, y) = location
    guard x != dimension - <span class="hljs-number">1</span> <span class="hljs-keyword">else</span> {
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>
    }
    <span class="hljs-keyword">if</span> <span class="hljs-keyword">case</span> let .Tile(v) = gamebord[x+<span class="hljs-number">1</span>, y] {
        <span class="hljs-keyword">return</span> v == value
    }
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>
}</code></pre> 
<p>接下来将之前的setupSwipeConttoller方法放入游戏初始化代码中则可以运行游戏了，在NumbertailGameController类的init方法中添加调用： </p> 
<pre class="prettyprint"><code class="language-java hljs ">init(dimension d : Int , threshold t : Int) {
    <span class="hljs-comment">//此处省略之前代码</span>
    setupSwipeConttoller()
}</code></pre> 
<p>接下来就可以运行游戏了，其他的都是些边边角角的优化了，reset方法什么的，大家可以在github中把代码下下来看就行，这里就不多做介绍了。 </p> 
<p>这里再讲一点就是之前说的将面板中的数字换成文字，其实很简单，就在TileView中定义一个字典<code>Dictionary&lt;Int,String&gt;</code>，放如值如[2:”我”,4:”的”]，在给数字块赋值的时候根据原本的值取出对应的文字赋到数字块上即可。 </p> 
<hr> 
<p>我的博客：blog.scarlettbai.com <br> 我的微信公众号：读书健身编程 <br> <img src="https://images2.imgbox.com/30/c1/Ealktvm0_o.jpg" alt="" title=""></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/ac3601d4a95ee0afb75b431f5f9c6704/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">Ubuntu 14.04 配置 Nginx &#43; uWSGI 托管 virtualenv 下 Flask 应用的一点注意事项</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/7f9a0ad8ffa34ed956de8e41962f97bb/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">jquery.fn jquery.extend jquery.fn.extend</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>