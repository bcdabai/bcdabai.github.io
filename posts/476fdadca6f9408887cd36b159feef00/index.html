<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>cmake简单使用及编译项目打包成so文件 - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="cmake简单使用及编译项目打包成so文件" />
<meta property="og:description" content="简介 CMake是一个跨平台的编译自动配置工具，它使用一个名为CMakeLists.txt的文件来描述构建过程，可以产生标准的构建文件。它可以用简单的语句来描述所有平台的安装(编译过程)。它能够输出各种各样的makefile或者project文件，能测试编译器所支持的C&#43;&#43;特性，类似UNIX下的automake。CMake并不直接建构出最终的软件，而是产生标准的建构档(如Unix的Makefile或Windows Visual C&#43;&#43;的projects/workspaces)，然后再依一般的建构方式使用。
CMake可以编译源代码、制作程式库、产生适配器(wrapper)、还可以用任意的顺序建构执行档。CMake支持in-place建构(二进档和源代码在同一个目录树中)和out-of-place建构(二进档在别的目录里)，因此可以很容易从同一个源代码目录树中建构出多个二进档。CMake也支持静态与动态程式库的建构。CMake是一个比make更高级的编译配置工具。
CMake的组态档取名为CMakeLists.txt。组态档是用一种建构软件专用的特殊编程语言写的CMake脚本。文件CMakeLists.txt需要手工编写，也可以通过编写脚本进行半自动的生成。通过编写CMakeLists.txt，可以控制生成的Makefile，从而控制编译过程。
CMake主要特点： (1)、开放源代码，使用类BSD许可发布；
(2)、跨平台，并可生成native编译配置文件，在Linux/Unix平台，生成makefile；在苹果平台，可以生成xcode；在windows平台，可以生成msvc的工程文件；
(3)、能够管理大型项目；
(4)、简化编译构建过程和编译过程，CMake的工具链非常简单：cmake&#43;make；
(5)、高效率；
(6)、可扩展，可以为cmake编写特定功能的模块，扩充cmake功能。
查看Ubuntu14.0464位机上是否安装了CMake及版本号，可通过执行一下语句来验证：
cmake --version Linux下安装cmake 1、从官网下载cmake安装包，输入指令解压缩
sudo tar -zxvf cmake-3.8.2.tar.gz 2、进入解压缩后的文件夹中，依次输入
sudo ./bootstrapsudo makesudo make install 或者直接命令安装：
apt-get install cmake 3、安装检查：输入命令，
cmake --version
若出现对应cmake的版本，则说明安装成功，一般默认安装在 /usr/local/bin 目录下。
简单使用 a、新建目录hello, 依次创建文件main.c, CMakeLists.txt, build目录
b、main.c 文件代码如下
#include &lt;stdio.h&gt; int main(void) { printf(&#34;Hello\n&#34;); return 0; } c、CMakeLists.txt 文件代码如下
CMAKE_MINIMUM_REQUIRED(VERSION 3.8) #cmake最低版本需求，不加入此行会受到警告信息 PROJECT(HELLO) #项目名称　AUX_SOURCE_DIRECTORY(. SRC_LIST) #把当前目录(.)下所有源代码文件和头文件加入变量SRC_LIST ADD_EXECUTABLE(hello ${SRC_LIST}) #生成应用程序 hello (在windows下会自动生成hello.exe) d、进入build 目录，依次输入" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/476fdadca6f9408887cd36b159feef00/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2018-11-21T14:26:10+08:00" />
<meta property="article:modified_time" content="2018-11-21T14:26:10+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">cmake简单使用及编译项目打包成so文件</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <h2>简介</h2> 
<p>CMake是一个跨平台的编译自动配置工具，它使用一个名为CMakeLists.txt的文件来描述构建过程，可以产生标准的构建文件。它可以用简单的语句来描述所有平台的安装(编译过程)。它能够输出各种各样的makefile或者project文件，能测试编译器所支持的C++特性，类似UNIX下的automake。CMake并不直接建构出最终的软件，而是产生标准的建构档(如Unix的Makefile或Windows Visual C++的projects/workspaces)，然后再依一般的建构方式使用。</p> 
<p>CMake可以编译源代码、制作程式库、产生适配器(wrapper)、还可以用任意的顺序建构执行档。CMake支持in-place建构(二进档和源代码在同一个目录树中)和out-of-place建构(二进档在别的目录里)，因此可以很容易从同一个源代码目录树中建构出多个二进档。CMake也支持静态与动态程式库的建构。CMake是一个比make更高级的编译配置工具。</p> 
<p>         CMake的组态档取名为CMakeLists.txt。组态档是用一种建构软件专用的特殊编程语言写的CMake脚本。文件CMakeLists.txt需要手工编写，也可以通过编写脚本进行半自动的生成。通过编写CMakeLists.txt，可以控制生成的Makefile，从而控制编译过程。</p> 
<h3>CMake主要特点：</h3> 
<p>(1)、开放源代码，使用类BSD许可发布；</p> 
<p>(2)、跨平台，并可生成native编译配置文件，<strong>在Linux/Unix平台，生成makefile；在苹果平台，可以生成xcode；在windows平台，可以生成msvc的工程文件</strong>；</p> 
<p>(3)、能够管理大型项目；</p> 
<p>(4)、简化编译构建过程和编译过程，CMake的工具链非常简单：<strong>cmake+make</strong>；</p> 
<p>(5)、高效率；</p> 
<p>(6)、可扩展，可以为cmake编写特定功能的模块，扩充cmake功能。</p> 
<p>查看Ubuntu14.0464位机上是否安装了CMake及版本号，可通过执行一下语句来验证：</p> 
<pre class="has"><code class="language-bash">cmake --version  </code></pre> 
<p> </p> 
<h2>Linux下安装cmake</h2> 
<p>1、从官网下载cmake安装包，输入指令解压缩</p> 
<p>sudo tar -zxvf cmake-3.8.2.tar.gz <br> 2、进入解压缩后的文件夹中，依次输入</p> 
<ol><li><code>sudo ./bootstrap</code></li><li><code>sudo make</code></li><li><code>sudo make install</code></li></ol> 
<p>或者直接命令安装：</p> 
<pre class="has"><code class="language-bash">apt-get install cmake</code></pre> 
<p>3、安装检查：输入命令，</p> 
<p>cmake --version</p> 
<p>若出现对应cmake的版本，则说明安装成功，一般默认安装在 /usr/local/bin 目录下。</p> 
<h2>简单使用</h2> 
<p>a、新建目录hello, 依次创建文件main.c, CMakeLists.txt, build目录</p> 
<p>b、main.c 文件代码如下</p> 
<pre class="has"><code class="language-cpp">#include &lt;stdio.h&gt;
int main(void)
{
    printf("Hello\n");
	return 0;
}</code></pre> 
<p>c、CMakeLists.txt 文件代码如下</p> 
<pre class="has"><code class="language-cpp">CMAKE_MINIMUM_REQUIRED(VERSION 3.8) #cmake最低版本需求，不加入此行会受到警告信息
PROJECT(HELLO) #项目名称　　
AUX_SOURCE_DIRECTORY(. SRC_LIST) #把当前目录(.)下所有源代码文件和头文件加入变量SRC_LIST
ADD_EXECUTABLE(hello ${SRC_LIST}) #生成应用程序 hello (在windows下会自动生成hello.exe)
</code></pre> 
<p>d、进入build 目录，依次输入</p> 
<pre class="has"><code class="language-bash">cmake ..
make
./hello</code></pre> 
<p>没错，就这么简单。</p> 
<p>过程如下：</p> 
<p><img alt="" class="has" height="307" src="https://images2.imgbox.com/f8/0c/TOx3EVIt_o.png" width="1003"></p> 
<p> </p> 
<h2>常用命令介绍</h2> 
<p>CMakeLists.txt的语法比较简单，由<strong>命令</strong>、<strong>注释</strong>和<strong>空格</strong>组成，其中命令是不区分大小写的，参数和变量是大小写相关的，但，推荐全部使用大写指令。符号”#”后面的内容被认为是注释。命令由命令名称、小括号和参数组成，参数之间使用<strong>空格或分号</strong>进行间隔。变量使用<strong>${xxx}</strong>引用。</p> 
<p> </p> 
<p>1）project 命令</p> 
<p>命令语法：project(&lt;projectname&gt; [languageName1 languageName2 … ] )</p> 
<p>命令简述：用于指定项目的名称</p> 
<p>使用范例：<strong>project(Main)</strong></p> 
<p>2）cmake_minimum_required命令</p> 
<p>命令语法：cmake_minimum_required(VERSION major[.minor[.patch[.tweak]]][FATAL_ERROR])</p> 
<p>命令简述：用于指定需要的 CMake 的最低版本</p> 
<p>使用范例：<strong>cmake_minimum_required(VERSION 2.8)</strong></p> 
<p>3）aux_source_directory命令</p> 
<p>命令语法：aux_source_directory(&lt;dir&gt; &lt;variable&gt;)</p> 
<p>命令简述：用于将 dir 目录下的所有源文件的名字保存在变量 variable 中,该命令会把参数&lt;dir&gt;中所有的源文件(不包括头文件)名称赋值给参数&lt;variable&gt;；</p> 
<p>使用范例：<strong>aux_source_directory(.  DIR_SRCS)</strong></p> 
<p>4）add_executable 命令</p> 
<p>命令语法：add_executable(&lt;name&gt; [WIN32] [MACOSX_BUNDLE][EXCLUDE_FROM_ALL] source1 source2 … sourceN)</p> 
<p>命令简述：用于指定从一组源文件 source1 source2 … sourceN 编译出一个可执行文件且命名为 name</p> 
<p>使用范例：<strong>add_executable(Main ${DIR_SRCS})</strong></p> 
<p>5）<strong>add_library</strong> 命令</p> 
<p>命令语法：add_library([STATIC | SHARED | MODULE] [EXCLUDE_FROM_ALL] source1source2 … sourceN)</p> 
<p>命令简述：用于指定从一组源文件 source1 source2 … sourceN 编译出一个库文件且命名为 name</p> 
<p>可以设置要生成的链接库为SHARED或者STATIC，还可以设置MODULE(插件，可动态调用，但不作为其它工程的依赖)；</p> 
<p>使用范例：<strong>add_library(Lib ${DIR_SRCS}) ;</strong>add_library(utils SHARED ${utils_dir}) </p> 
<p>6）add_dependencies 命令</p> 
<p>命令语法：add_dependencies(target-name depend-target1 depend-target2 …)</p> 
<p>命令简述：用于指定某个目标（可执行文件或者库文件）依赖于其他的目标。这里的目标必须是 add_executable、add_library、add_custom_target 命令创建的目标</p> 
<p>7）add_subdirectory 命令</p> 
<p>命令语法：add_subdirectory(source_dir [binary_dir] [EXCLUDE_FROM_ALL])</p> 
<p>命令简述：用于添加一个需要进行构建的子目录</p> 
<p>使用范例：<strong>add_subdirectory(Lib)</strong></p> 
<p>8）<strong>target_link_libraries</strong>命令</p> 
<p>命令语法：target_link_libraries(&lt;target&gt; [item1 [item2 […]]][[debug|optimized|general] ] …)</p> 
<p>命令简述：用于指定 target 需要链接 item1 item2 …。这里 target 必须已经被创建，链接的 item 可以是已经存在的 target（依赖关系会自动添加）</p> 
<p>使用范例：target_link_libraries(Main Lib) ； target_link_libraries(myproj ${OpenCV_LIBS} utils facedetect)</p> 
<p>9）set 命令</p> 
<p>命令语法：set(&lt;variable&gt; &lt;value&gt; [[CACHE &lt;type&gt;&lt;docstring&gt; [FORCE]] | PARENT_SCOPE])</p> 
<p>命令简述：用于设定变量 variable 的值为 value。如果指定了 CACHE 变量将被放入 Cache（缓存）中。</p> 
<p>使用范例：<strong>set(ProjectName Main)</strong></p> 
<p>10）unset 命令</p> 
<p>命令语法：unset(&lt;variable&gt; [CACHE])</p> 
<p>命令简述：用于移除变量 variable。如果指定了 CACHE 变量将被从 Cache 中移除。</p> 
<p>使用范例：<strong>unset(VAR CACHE)</strong></p> 
<p>11）message 命令</p> 
<p>命令语法：message([STATUS|WARNING|AUTHOR_WARNING|FATAL_ERROR|SEND_ERROR] “message todisplay”…)</p> 
<p>命令简述：用于输出信息</p> 
<p>使用范例：<strong>message(“Hello World”)</strong></p> 
<p>12）include_directories 命令</p> 
<p>命令语法：include_directories([AFTER|BEFORE] [SYSTEM] dir1 dir2 …)</p> 
<p>命令简述：用于设定目录，这些设定的目录将被编译器用来查找 include 文件</p> 
<p>                 指定头文件的搜索路径，用来向工程添加多个特定的头文件搜索路径，可以多次调用以设置多个路径，相当于指定gcc的-I参数；</p> 
<p>使用范例：<strong>include_directories(${PROJECT_SOURCE_DIR}/lib)，</strong>include_directories(facedetect utils)</p> 
<p>13）<strong>find_path</strong> 命令</p> 
<p>命令语法：find_path(&lt;VAR&gt; name1 [path1 path2 …])</p> 
<p>命令简述：用于查找包含文件 name1 的路径，如果找到则将路径保存在 VAR 中（此路径为一个绝对路径），如果没有找到则结果为 &lt;VAR&gt;-NOTFOUND。默认的情况下，VAR 会被保存在 Cache 中，这时候我们需要清除 VAR 才可以进行下一次查询（使用 unset 命令）。</p> 
<p>使用范例：</p> 
<p>find_path(LUA_INCLUDE_PATH lua.h${LUA_INCLUDE_FIND_PATH})</p> 
<p>if(NOT LUA_INCLUDE_PATH)</p> 
<p>   message(SEND_ERROR "Header file lua.h not found")</p> 
<p>endif()</p> 
<p>14）<strong>find_library</strong> 命令</p> 
<p>命令语法：find_library(&lt;VAR&gt; name1 [path1 path2 …])</p> 
<p>命令简述：用于查找库文件 name1 的路径，如果找到则将路径保存在 VAR 中（此路径为一个绝对路径），如果没有找到则结果为 &lt;VAR&gt;-NOTFOUND。一个类似的命令 link_directories 已经不太建议使用了</p> 
<p>15）add_definitions 命令</p> 
<p>命令语法：add_definitions(-DFOO -DBAR …)</p> 
<p>命令简述：用于添加编译器命令行标志（选项），通常的情况下我们使用其来添加预处理器定义</p> 
<p>使用范例：<strong>add_definitions(-D_UNICODE -DUNICODE)</strong></p> 
<p>16）execute_process 命令</p> 
<p>命令语法：</p> 
<p>execute_process(COMMAND &lt;cmd1&gt;[args1...]]</p> 
<p>                  [COMMAND &lt;cmd2&gt;[args2...] [...]]</p> 
<p>                  [WORKING_DIRECTORY&lt;directory&gt;]</p> 
<p>                  [TIMEOUT &lt;seconds&gt;]</p> 
<p>                  [RESULT_VARIABLE&lt;variable&gt;]</p> 
<p>                  [OUTPUT_VARIABLE&lt;variable&gt;]</p> 
<p>                  [ERROR_VARIABLE&lt;variable&gt;]</p> 
<p>                  [INPUT_FILE &lt;file&gt;]</p> 
<p>                  [OUTPUT_FILE &lt;file&gt;]</p> 
<p>                  [ERROR_FILE &lt;file&gt;]</p> 
<p>                  [OUTPUT_QUIET]</p> 
<p>                  [ERROR_QUIET]</p> 
<p>                 [OUTPUT_STRIP_TRAILING_WHITESPACE]</p> 
<p>                 [ERROR_STRIP_TRAILING_WHITESPACE])</p> 
<p>命令简述：用于执行一个或者多个外部命令。每一个命令的标准输出通过管道转为下一个命令的标准输入。WORKING_DIRECTORY 用于指定外部命令的工作目录，RESULT_VARIABLE 用于指定一个变量保存外部命令执行的结果，这个结果可能是最后一个执行的外部命令的退出码或者是一个描述错误条件的字符串，OUTPUT_VARIABLE 或者 ERROR_VARIABLE 用于指定一个变量保存标准输出或者标准错误，OUTPUT_QUIET 或者 ERROR_QUIET 用于忽略标准输出和标准错误。</p> 
<p>使用范例：execute_process(COMMAND ls)</p> 
<p>18）<strong>file </strong>命令</p> 
<p>命令简述：此命令提供了丰富的文件和目录的相关操作（这里仅说一下比较常用的）</p> 
<p>使用范例：</p> 
<p># 目录的遍历</p> 
<p># GLOB 用于产生一个文件（目录）路径列表并保存在variable 中</p> 
<p># 文件路径列表中的每个文件的文件名都能匹配globbing expressions（非正则表达式，但是类似）</p> 
<p># 如果指定了 RELATIVE 路径，那么返回的文件路径列表中的路径为相对于 RELATIVE 的路径</p> 
<p># file(GLOB variable [RELATIVE path][globbing expressions]...)</p> 
<p> </p> 
<p># 获取当前目录下的所有的文件（目录）的路径并保存到 ALL_FILE_PATH 变量中</p> 
<p>file(GLOB ALL_FILE_PATH ./*)</p> 
<p># 获取当前目录下的 .h 文件的文件名并保存到ALL_H_FILE 变量中</p> 
<p># 这里的变量CMAKE_CURRENT_LIST_DIR 表示正在处理的 CMakeLists.txt 文件的所在的目录的绝对路径（2.8.3 以及以后版本才支持）</p> 
<p>file(GLOB ALL_H_FILE RELATIVE${CMAKE_CURRENT_LIST_DIR} ${CMAKE_CURRENT_LIST_DIR}/*.h)</p> 
<p>19)<strong>find_package(name)</strong></p> 
<p>在指定的模块目录中搜索一个名为Find&lt;name&gt;.cmake(例如，FindOSG.cmake)的CMake脚本模块文件，执行其中的内容，意图搜索到指定的外部依赖库头文件和库文件位置；</p> 
<p>20) <strong>include(file)</strong>:</p> 
<p>在当前文件中包含另一个CMake脚本文件的内容,用来载入CMakeLists.txt文件，也用于载入预定义的cmake模块</p> 
<p>21)<strong>set_target_properties</strong>:</p> 
<p>用来设置输出的名称，对于动态库，还可以用来指定动态库版本和API版本</p> 
<p>set_target_properties(utils PROPERTIES output_name "utils")</p> 
<h2>编译项目打包成so文件</h2> 
<h3><strong>1. 借助CMake打.so包</strong></h3> 
<p>把目录hello_make下的文件打出.so包。</p> 
<p>在上述文件里，我将build删除，然后新加了两个文件，so_test.h,so_test.c，内容很简单就是输出一个test，这里不贴代码了。另外main里调用了下test_so函数。</p> 
<h3><img alt="" class="has" height="106" src="https://images2.imgbox.com/01/ee/SV0l2dwg_o.png" width="258"></h3> 
<p>重新编辑CMakeLists.txt</p> 
<pre class="has"><code class="language-bash">CMAKE_MINIMUM_REQUIRED(VERSION 3.5)
PROJECT(HELLO) #项目名称　　
AUX_SOURCE_DIRECTORY(. SRC_LIST) #把当前目录(.)下所有源代码文件和头文件加入变量SRC_LIST
ADD_EXECUTABLE(hello ${SRC_LIST}) #生成应用程序 hello (在windows下会自动生成hello.exe)

add_library(utils SHARED ${SRC_LIST})

set_target_properties(utils PROPERTIES output_name "utils")
</code></pre> 
<p>注意：前面的关键字可以大写也可以小写，括号内的关键字必须大写。</p> 
<p>然后建立build文件目录，进去编译，生成了共享库libutils.so</p> 
<p>当然也可以不建立build直接 cmake . 当前目录下生成，但是不建议这样，太乱了。</p> 
<p>如下，生成的所有文件</p> 
<p><img alt="" class="has" height="43" src="https://images2.imgbox.com/4e/58/tKxuSa9P_o.png" width="614"></p> 
<p> </p> 
<p><img alt="" class="has" height="790" src="https://images2.imgbox.com/e5/e4/qruWXVFo_o.png" width="548"></p> 
<p> </p> 
<h3><strong>2. 利用</strong>Cython打包整个项目</h3> 
<p>这里过程很简单，</p> 
<p>1.首先安装gcc ：<code>sudo apt-get install <a href="https://www.baidu.com/s?wd=build&amp;tn=24004469_oem_dg&amp;rsv_dl=gh_pl_sl_csd" rel="nofollow">build</a>-dev gcc</code> <br> 安装cython :<code>pip3 install Cython</code></p> 
<p><font face="monospace">环境部署。</font></p> 
<p>2.编译整个目录: <br> 将需要编译的目录和setup.py放在同一目录下,执行python3 setup.py</p> 
<pre class="has"><code class="language-python">'''
# 打包单个.py文件
from distutils.core import setup
from Cython.Build import cythonize
 
setup(
  name = 'Derain',
  ext_modules = cythonize("derain.py"),
)
'''

#-* -coding: UTF-8 -* -

"""
执行前提：
    系统安装python-devel 和 gcc
    Python安装cython

编译整个当前目录：
    python py-setup.py
编译某个文件夹：
    python py-setup.py BigoModel

生成结果：
    目录 build 下

生成完成后：
    启动文件还需要py/pyc担当，须将启动的py/pyc拷贝到编译目录并删除so文件

"""

import sys, os, shutil, time
from distutils.core import setup
from Cython.Build import cythonize

starttime = time.time()
currdir = os.path.abspath('.')
parentpath = sys.argv[1] if len(sys.argv)&gt;1 else ""
setupfile= os.path.join(os.path.abspath('.'), __file__)
build_dir = "build"
build_tmp_dir = build_dir + "/temp"

def getpy(basepath=os.path.abspath('.'), parentpath='', name='', excepts=(), copyOther=False,delC=False):
    """
    获取py文件的路径
    :param basepath: 根路径
    :param parentpath: 父路径
    :param name: 文件/夹
    :param excepts: 排除文件
    :param copy: 是否copy其他文件
    :return: py文件的迭代器
    """
    fullpath = os.path.join(basepath, parentpath, name)
    for fname in os.listdir(fullpath):
        ffile = os.path.join(fullpath, fname)
        #print basepath, parentpath, name,file
        if os.path.isdir(ffile) and fname != build_dir and not fname.startswith('.'):
            for f in getpy(basepath, os.path.join(parentpath, name), fname, excepts, copyOther, delC):
                yield f
        elif os.path.isfile(ffile):
            ext = os.path.splitext(fname)[1]
            if ext == ".c":
                if delC and os.stat(ffile).st_mtime &gt; starttime:
                    os.remove(ffile)
            elif ffile not in excepts and os.path.splitext(fname)[1] not in('.pyc', '.pyx'):
                if os.path.splitext(fname)[1] in('.py', '.pyx') and not fname.startswith('__'):
                    yield os.path.join(parentpath, name, fname)
                elif copyOther:
                        dstdir = os.path.join(basepath, build_dir, parentpath, name)
                        if not os.path.isdir(dstdir): os.makedirs(dstdir)
                        shutil.copyfile(ffile, os.path.join(dstdir, fname))
        else:
            pass

#获取py列表
module_list = list(getpy(basepath=currdir,parentpath=parentpath, excepts=(setupfile)))
try:
    setup(ext_modules = cythonize(module_list),script_args=["build_ext", "-b", build_dir, "-t", build_tmp_dir])
except Exception as e:
    print (e)
else:
    module_list = list(getpy(basepath=currdir, parentpath=parentpath, excepts=(setupfile), copyOther=True))
module_list = list(getpy(basepath=currdir, parentpath=parentpath, excepts=(setupfile), delC=True))
if os.path.exists(build_tmp_dir): shutil.rmtree(build_tmp_dir)
print ("complete! time:", time.time()-starttime, 's')



</code></pre> 
<p>上述代码在linux下执行得到.so，在windows下则为pyd文件。</p> 
<p> </p> 
<p>其他参考：</p> 
<h3><a href="https://blog.csdn.net/nvliba/article/details/80022832?utm_source=blogxgwz7">cython将py文件编译成so文件</a></h3> 
<p> </p> 
<p> </p> 
<p> </p> 
<p>参考文献：</p> 
<p>1.<a href="https://www.cnblogs.com/AbnerShen/p/7399010.html" rel="nofollow">https://www.cnblogs.com/AbnerShen/p/7399010.html</a></p> 
<p>2.<a href="https://blog.csdn.net/wang4959520/article/details/73550923">https://blog.csdn.net/wang4959520/article/details/73550923</a></p> 
<p>3.<a href="https://blog.csdn.net/flyztek/article/details/73612469">https://blog.csdn.net/flyztek/article/details/73612469</a></p> 
<p>4.<a href="http://www.cnblogs.com/zhongjiangfeng/p/7478243.html" rel="nofollow">http://www.cnblogs.com/zhongjiangfeng/p/7478243.html</a></p> 
<p> </p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/1180da420b3a50c71219e3fb93c3181b/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">chain33 区块链开发框架诞生记</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/bc7daec142f8869d4a9620bcf6f57312/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">js中如何优雅的判断</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>