<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>【精读笔记】深入解析CSS 第一部分：基础回顾 - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="【精读笔记】深入解析CSS 第一部分：基础回顾" />
<meta property="og:description" content="第1章 层叠、优先级和继承 1.1 层叠 层叠规则
1.1.1 样式表的来源 用户代理样式表：浏览器默认样式。
作者样式表：自己设置的样式。
作者样式覆盖用户代理样式，因为作者样式的优先级更高
!important声明 在声明的后面、分号的前面加上!important，该声明就会被标记为重要的声明
color: red !important; 总体的优先级
作者的!important作者用户代理 1.1.2 理解优先级 浏览器将优先级分为两部分：HTML的行内样式和选择器的样式
行内样式 如果用HTML的style属性写样式，这个声明智慧作用于当前元素。实际上行内元素属于“带作用域的”声明，它会覆盖任何来自样式表或者&lt;style&gt;标签的样式
选择器优先级 不同类型的选择器有不同的优先级。优先级的准确规则如下：
如果选择器的ID数量更多，则它会胜出（即它更明确）。如果ID数量一致，那么拥有最多类的选择器胜出。如果以上两次比较都一致，那么拥有最多标签名的选择器胜出。 Attention! 伪类选择器和属性选择器与一个类选择器的优先级相同
​ 通用选择器（*）和组合器（&gt;、&lt;、~）对优先级没有影响
优先级标记 常用的表示优先级的方式
​ 用数值形式来标记，通常用逗号隔开每个数。比如，“1,2,2”表示选择器由1个ID、2个类、2个标签组成。优先级最高的ID列为第一位，紧接着是类，最后是标签。
​ 有时，还会用4个数的标记，其中将最重要的位置用0或1来表示，代表一个声明是否是用行内样式添加的。此时，行内样式的优先级为“1,0,0,0”。它会覆盖通过选择器添加的样式，比如优先级为“0,1,2,0”（1个ID和2个类）的选择器。
1.1.3 源码顺序 ​ 如果两个声明的来源和优先级相同，其中一个声明在样式表中出现较晚，或者位于页面较晚引入的样式表中，则该声明胜出。
链接样式和源码顺序 //顺序不可改变 a:link { color: blue; text-decoration: none; } a:visited { color: purple; } a:hover { text-decoration: underline; } a:active { color: red; } ​ 书写顺序之所以很重要，就是因为层叠。像上述的代码如果顺序发生变化，这个效果就会遭到破坏。
层叠值 ​ 如果一个声明在层叠中“胜出”，它就被称作一个层叠值。元素的每个属性最多只有一个层叠值。
1.1.4 两条经验法则 （1）在选择器中不要使用ID。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/782e916e75eec6be3da1b0829f917727/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-04-01T11:14:19+08:00" />
<meta property="article:modified_time" content="2022-04-01T11:14:19+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">【精读笔记】深入解析CSS 第一部分：基础回顾</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <h2><a id="1__0"></a>第1章 层叠、优先级和继承</h2> 
<h3><a id="11__2"></a>1.1 层叠</h3> 
<blockquote> 
 <p>层叠规则</p> 
</blockquote> 
<p><img src="https://images2.imgbox.com/1b/6d/j0JmafdD_o.png" alt="[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-yP358arK-1648781887720)(C:\Users\浅夏、\AppData\Roaming\Typora\typora-user-images\image-20220331113054614.png)]"></p> 
<h4><a id="111__8"></a>1.1.1 样式表的来源</h4> 
<p>用户代理样式表：浏览器默认样式。</p> 
<p>作者样式表：自己设置的样式。</p> 
<p><mark><strong>作者样式覆盖用户代理样式，因为作者样式的优先级更高</strong></mark></p> 
<h5><a id="important_16"></a>!important声明</h5> 
<p>在声明的后面、分号的前面加上<code>!important</code>，该声明就会被标记为重要的声明</p> 
<pre><code class="prism language-html">color: red !important;
</code></pre> 
<p><strong>总体的优先级</strong></p> 
<ol><li>作者的<code>!important</code></li><li>作者</li><li>用户代理</li></ol> 
<h4><a id="112__36"></a>1.1.2 理解优先级</h4> 
<p>浏览器将优先级分为两部分：HTML的行内样式和选择器的样式</p> 
<h5><a id="_40"></a>行内样式</h5> 
<p>如果用HTML的style属性写样式，这个声明智慧作用于当前元素。实际上行内元素属于“带作用域的”声明，<strong>它会覆盖任何来自样式表或者&lt;style&gt;标签的样式</strong></p> 
<h5><a id="_46"></a>选择器优先级</h5> 
<p>不同类型的选择器有不同的优先级。优先级的准确规则如下：</p> 
<ul><li>如果选择器的<strong>ID数量更多</strong>，则它会胜出（即它更明确）。</li><li>如果ID数量一致，那么<strong>拥有最多类的选择器胜出</strong>。</li><li>如果以上两次比较都一致，那么<strong>拥有最多标签名的选择器胜出</strong>。</li></ul> 
<p><mark>Attention!</mark> 伪类选择器和属性选择器与一个类选择器的优先级相同</p> 
<p>​ 通用选择器（*）和组合器（&gt;、&lt;、~）对优先级没有影响</p> 
<h5><a id="_62"></a>优先级标记</h5> 
<blockquote> 
 <p>常用的表示优先级的方式</p> 
</blockquote> 
<p>​ 用数值形式来标记，通常用逗号隔开每个数。比如，“1,2,2”表示选择器由1个ID、2个类、2个标签组成。优先级最高的ID列为第一位，紧接着是类，最后是标签。<br> <img src="https://images2.imgbox.com/1d/f1/KedzGqTl_o.png" alt="在这里插入图片描述"></p> 
<p>​ 有时，还会用4个数的标记，其中将最重要的位置用0或1来表示，代表一个声明是否是用行内样式添加的。此时，行内样式的优先级为“1,0,0,0”。它会覆盖通过选择器添加的样式，比如优先级为“0,1,2,0”（1个ID和2个类）的选择器。</p> 
<h4><a id="113__75"></a>1.1.3 源码顺序</h4> 
<p>​ 如果两个声明的来源和优先级相同，其中一个声明在样式表中出现较晚，或者位于页面较晚引入的样式表中，则该声明胜出。</p> 
<h5><a id="_79"></a>链接样式和源码顺序</h5> 
<pre><code>//顺序不可改变
a:link {
  color: blue;
  text-decoration: none;
}

a:visited {
  color: purple;
}

a:hover {
  text-decoration: underline;
}

a:active {
  color: red;
}
</code></pre> 
<p>​ 书写顺序之所以很重要，就是因为层叠。像上述的代码如果顺序发生变化，这个效果就会遭到破坏。</p> 
<h5><a id="_105"></a>层叠值</h5> 
<p>​ 如果一个声明在层叠中“胜出”，它就被称作一个<strong>层叠值</strong>。元素的每个属性最多只有一个层叠值。</p> 
<h4><a id="114__111"></a>1.1.4 两条经验法则</h4> 
<p>（1）<mark><strong>在选择器中不要使用ID</strong>。</mark></p> 
<p>​ 就算只用一个ID，也会大幅提升优先级。当需要覆盖这个选择器时，通常找不到另一个有意义的ID，于是就会复制原来的选择器，然后加上另一个类，让它区别于想要覆盖的选择器。</p> 
<p>（2）<mark><strong>不要使用<code>!important</code></strong>。</mark></p> 
<p>​ 它比ID更难覆盖，一旦用了它，想要覆盖原先的声明，就需要再加上一个<code>!important</code>，而且依然要处理优先级的问题。</p> 
<h3><a id="12__125"></a>1.2 继承</h3> 
<p>如果一个元素的某个属性没有层叠值，则可能会继承某个祖先元素的值。<strong>但不是所有的属性都能被继承。</strong></p> 
<blockquote> 
 <p>能继承的属性通常是我们希望被继承的那些。它们主要是跟文本相关的属性：<code>color</code>、<code>font</code>、<code>font-family</code>、<code>font-size</code>、<code>font-weight</code>、<code>font-variant</code>、<code>font-style</code>、<code>line-height</code>、<code>letter-spacing</code>、<code>text-align</code>、<code>text-indent</code>、<code>text-transform</code>、<code>white-space</code>以及<code>word-spacing</code>。</p> 
 <p>还有一些属性也可以被继承，比如列表属性：<code>list-style</code>、<code>list-style-type</code>、<code>list-style-position</code>以及<code>list-style-image</code>。表格的边框属性<code>border-collapse</code>和<code>border-spacing</code>也能被继承。</p> 
</blockquote> 
<h3><a id="13__135"></a>1.3 特殊值</h3> 
<p>有两个特殊值可以赋给任意属性，用于控制层叠：<strong><code>inherit</code>和<code>initial</code></strong>。</p> 
<h4><a id="131_inherit_141"></a>1.3.1 使用inherit关键字</h4> 
<p>​ 我们想<strong>用继承代替一个层叠值</strong>。这时候可以用<code>inherit</code>关键字。可以<strong>用它来覆盖另一个值，这样该元素就会继承其父元素的值</strong>。还可以使用<code>inherit</code>关键字强制继承一个通常不会被继承的属性。</p> 
<h4><a id="132_initial_147"></a>1.3.2 使用initial关键字</h4> 
<p>​ <strong>撤销作用于某个元素的样式</strong>可以用<code>initial</code>关键字来实现。如果将<code>initial</code>值赋给某个属性，那么就会<mark>有效地将其重置为默认值</mark>，这种操作相当于硬复位了该值。</p> 
<h3><a id="14__153"></a>1.4 简写属性</h3> 
<p>​ <strong>简写属性</strong>是用于同时给多个属性赋值的属性。例如font</p> 
<pre><code>//用font简写属性来指定font-style、font-weight、font-size、font-height以及font-family。
font: italic bold 18px/1.2 "Helvetica", "Arial", sans-serif;
</code></pre> 
<h4><a id="141__164"></a>1.4.1 简写属性会默默覆盖其他样式</h4> 
<p>​ 大多数简写属性可以省略一些值，只指定我们关注的值。但是要知道，这样做仍然会设置省略的值，即它们会被隐式地设置为初始值。</p> 
<h4><a id="142__170"></a>1.4.2 理解简写值的顺序</h4> 
<p>​ 简写属性会尽量包容指定的属性值的顺序。</p> 
<h5><a id="_176"></a>上、右、下、左</h5> 
<p>​ 当遇到像**<code>margin</code>、<code>padding</code><strong>这样的属性，还有</strong>为元素的四条边分别指定值的边框属性时**，开发者容易弄错这些简写属性的顺序。这些属性的值是<mark>按顺时针方向，从上边开始的</mark>。</p> 
<p>​</p> 
<h2><a id="2__182"></a>第2章 相对单位</h2> 
<p>绝对单位：像素单位(px)</p> 
<p>相对单位：em rem</p> 
<h3><a id="21__190"></a>2.1 相对值的好处</h3> 
<p>​ 相对单位就是CSS用来解决抽象的一种工具。我们可以基于窗口大小来等比例地缩放字号，而不是固定为14px，或者将网页上的任何元素的大小都相对于基础字号来设置，然后只用改一行代码就能缩放整个网页。</p> 
<h3><a id="21_emrem_194"></a>2.1 em和rem</h3> 
<blockquote> 
 <p>em</p> 
</blockquote> 
<p>​ em是最常见的相对长度单位，适合基于特定的字号进行排版。在CSS中，<strong>1em等于当前元素的字号</strong>，其准确值取决于作用的元素。</p> 
<pre><code class="prism language-css"><span class="token selector">.padded</span> <span class="token punctuation">{<!-- --></span>
  <span class="token property">font-size</span><span class="token punctuation">:</span> 16px<span class="token punctuation">;</span>         
  <span class="token property">padding</span><span class="token punctuation">:</span> 1em<span class="token punctuation">;</span>    ←---- 设置四个内边距为font-size
<span class="token punctuation">}</span>

//内边距为1em，浏览器将其乘以字号，最终渲染为16px
</code></pre> 
<p>浏览器会根据相对单位的值计算出绝对值，称作<strong>计算值</strong></p> 
<h4><a id="221_em_213"></a>2.2.1 使用em定义字号</h4> 
<pre><code class="prism language-css"><span class="token property">font-size</span><span class="token punctuation">:</span> 1.2em   //这个font-size是根据继承的字号来计算的
</code></pre> 
<p>例：</p> 
<pre><code>body {
  font-size: 16px;
}

.slogan {       （以下3行）计算结果为元素继承的字号的1.2倍
  font-size: 1.2em;    
}
</code></pre> 
<pre><code>&lt;body&gt;
  We love coffee                             
  &lt;p class="slogan"&gt;We love coffee&lt;/p&gt;   ←---- slogan继承了&lt;body&gt;的字号
&lt;/body&gt;
</code></pre> 
<p><img src="https://images2.imgbox.com/5c/fc/J3Jingkc_o.png" alt="[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-JvaesSYG-1648781887721)(D:\大学\学习资料\前端学习笔记\CSS\深入解析CSS.assets\image-20220331154046875.png)]"></p> 
<h5><a id="em_243"></a>em同时用于字号和其他属性</h5> 
<p>​ 同时用它指定一个元素的字号和其他属性时，<mark>浏览器必须先计算字号</mark>，<strong>然后使用这个计算值去算出其余的属性值</strong>。</p> 
<pre><code>body {
  font-size: 16px;
}

.slogan {                   
  font-size: 1.2em;      ←---- 计算值为19.2px       
  padding: 1.2em;        ←---- 计算值为23.04px
  background-color: #ccc;
}
//padding值为1.2em乘以19.2px，得到23.04px
</code></pre> 
<h5><a id="_262"></a>字体缩小的问题</h5> 
<p>当用em来指定多层嵌套元素的字号时，为了算出每个元素的准确值，需要知道继承的字号，如果这个值是在父元素上用em定义的，就要知道父元素的继承值。</p> 
<pre><code>body {
  font-size: 16px;
}

ul {
  font-size: .8em;
}
</code></pre> 
<pre><code>&lt;ul&gt;
  &lt;li&gt;Top level
    &lt;ul&gt;           （以下2行）这个列表嵌套在第一个列表中，继承它的字号
      &lt;li&gt;Second level     
        &lt;ul&gt;          （以下2行）这个嵌套在上一个列表中，继承第二个列表的字号
          &lt;li&gt;Third level      
            &lt;ul&gt;       （以下2行）以此类推
              &lt;li&gt;Fourth level    
                &lt;ul&gt;
                  &lt;li&gt;Fifth level&lt;/li&gt;
                &lt;/ul&gt;
              &lt;/li&gt;
            &lt;/ul&gt;
          &lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;
</code></pre> 
<p><img src="https://images2.imgbox.com/7b/24/vxCXr6Ma_o.png" alt="[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-Kguvs9Td-1648781887722)(D:\大学\学习资料\前端学习笔记\CSS\深入解析CSS.assets\image-20220331163402931.png)]"></p> 
<p>纠正文字缩小的问题</p> 
<pre><code>ul {
  font-size: .8em;
}

ul ul {         （以下3行）嵌套的列表应当跟其父级的字号一致
  font-size: 1em;     
}
</code></pre> 
<p><img src="https://images2.imgbox.com/5d/78/Qovuw12c_o.png" alt="[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-i8JZe7ma-1648781887723)(D:\大学\学习资料\前端学习笔记\CSS\深入解析CSS.assets\image-20220331163440282.png)]"></p> 
<p>2.2.2 使用rem设置字号</p> 
<p>根节点是所有其他元素的祖先节点，根节点有一个伪类选择器（:root)，可以用它来选中自己。</p> 
<p>rem是root em的缩写，<strong>rem是相对于根元素的单位</strong>。<mark>不管在文档的什么位置使用rem，1.2rem都会有相同的计算值：1.2乘以根元素的字号。</mark></p> 
<p>推荐使用rem设置字号，用px设置边框，用em设置其他大部分属性（尤其内边距、外边距和圆角）</p> 
<h4><a id="231__332"></a>2.3.1 设置一个合理的默认字号</h4> 
<p>将默认字号设置为14px:</p> 
<pre><code>:root {        ←----  使用HTML选择器
  font-size: 0.875em;     ←---- 14/16（理想的px/继承的px）=0.875
}
</code></pre> 
<h4><a id="232__344"></a>2.3.2 构造响应式面板</h4> 
<p>我们可以根据屏幕尺寸，用媒体查询改变根元素的字号。这样就能够基于不同用户的屏幕尺寸，渲染出不同大小的面板。</p> 
<pre><code>:root {          （以下3行）作用到所有的屏幕，但是在大屏上会被覆盖
  font-size: 0.75em;   
}                      

@media (min-width: 800px) {   （以下5行）仅作用到宽度800px及其以上的屏幕，覆盖之前的值
  :root {                     
    font-size: 0.875em;       
  }                           
}                             

@media (min-width: 1200px) {  （以下5行）仅作用到宽度1200px及其以上的屏幕，覆盖前面两个值
  :root {                      
    font-size: 1em;           
  }                            
}
</code></pre> 
<h4><a id="233__370"></a>2.3.3 缩放单个组件</h4> 
<p>需要让同一个组件在页面的某些部分显示不同的大小，可以通em来单独缩放一个组件</p> 
<h3><a id="24__376"></a>2.4 视窗的相对窗口</h3> 
<p>em和rem都是相对font-size定义的，CSS里还有相对于浏览器视口定义长度的视口的相对单位的。</p> 
<blockquote> 
 <ul><li><strong>vh</strong>：视口高度的1/100。</li><li><strong>vw</strong>：视口宽度的1/100。</li><li><strong>vmin</strong>：视口宽、高中较小的一方的1/100（IE9中叫vm，而不是vmin）。</li><li><strong>vmax</strong>：视口宽、高中较大的一方的1/100（本书写作时IE和Edge均不支持vmax）<strong>2</strong>。</li></ul> 
</blockquote> 
<h4><a id="241_vw_387"></a>2.4.1 使用vw定义字号</h4> 
<p>使用vh和vw设置字号非常实用，但优势在大屏上字还是太大了</p> 
<h4><a id="242_calc_393"></a>2.4.2 使用calc()定义字号</h4> 
<p><code>calc()</code>函数内可以对两个及其以上的值进行基本运算。注意<mark>加号和减号两边必须有空白</mark>。</p> 
<pre><code>:root {
  font-size: calc(0.5em + 1vw);
}
</code></pre> 
<p><strong>0.5保证了最小字号，1vw则确保了字体会随视口缩放。</strong></p> 
<h3><a id="25__407"></a>2.5 无单位的数值和行高</h3> 
<p>有些属性允许无单位的值：<code>line-height</code>、<code>z-index</code>、<code>font-weight</code>（700等于bold，400等于normal，等等）</p> 
<p>任何长度单位（如px、em、rem）都可以用无单位的值0，因为这些情况下单位不影响计算值，即0px、0%、0em均相等。</p> 
<h3><a id="26_CSS_415"></a>2.6 自定义属性（即CSS变量）</h3> 
<p><strong>层叠变量的自定义属性</strong></p> 
<p>给CSS引进了变量的概念，开启了一种全新的基于上下文的动态样式。可以声明一个变量，为它赋值，然后再样式表的其他的地方引用这个值。</p> 
<pre><code class="prism language-CSS">:root {
  --main-font: Helvetica, Arial, sans-serif;  //
}
</code></pre> 
<p><mark>变量名前面必须有两个连字符（<code>--</code>）</mark>，用于跟CSS属性区分，剩下的部分可以随便命名。</p> 
<p>变量必须在一个声明块内声明。这里是用了:root选择器，所以变量可以在整个网页使用。</p> 
<p>使用：</p> 
<pre><code>:root {
  --main-font: Helvetica, Arial, sans-serif;
}

p {                （以下3行）将段落的字体设置为Helvetica、Arial、sans-serif
  font-family: var(--main-font);   
}
</code></pre> 
<pre><code>:root {
  --main-font: Helvetica, Arial, sans-serif;     
  --brand-color: #369;         ←---- 定义一个蓝色的brand-color变量
}

p {
  font-family: var(--main-font);
  color: var(--brand-color);
}
</code></pre> 
<pre><code>:root {
  --main-font: Helvetica, Arial, sans-serif;
  --brand-color: #369;
}

p {                                              
  font-family: var(--main-font, sans-serif);  ←---- 指定备用值为sans-serif       
  color: var(--secondary-color, blue);        ←---- secondary-color变量没有定义，因此会使用备用值blue
}
</code></pre> 
<p><mark>var（）函数接受第二个参数，它指定了备用值。如果第一个参数指定的变量未定义，就会使用第二个值）</mark></p> 
<h4><a id="261__471"></a>2.6.1 动态改变自定义属性</h4> 
<p>自定义属性真正的意义在于，<strong>自定义属性的声明能够层叠和继承：可以在多个选择器中定义相同的变量，这个变量在网页的不同地方有不同的值。</strong></p> 
<p>例：</p> 
<p><img src="https://images2.imgbox.com/e3/4c/pq7ciAvZ_o.png" alt="[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-RZ07S54E-1648781887724)(D:\大学\学习资料\前端学习笔记\CSS\深入解析CSS.assets\image-20220331173247371.png)]"></p> 
<pre><code>&lt;body&gt;
  &lt;div class="panel"&gt;         ←-- 网页中的一个普通面板
    &lt;h2&gt;Single-origin&lt;/h2&gt;
    &lt;div class="body"&gt;
      We have built partnerships with small farms
      around the world to hand-select beans at the
      peak of season. We then careful roast in
      small batches to maximize their potential.
    &lt;/div&gt;
  &lt;/div&gt;

  &lt;aside class="dark"&gt;    （以下2行）深色容器内的另一个面板
    &lt;div class="panel"&gt;   
      &lt;h2&gt;Single-origin&lt;/h2&gt;
      &lt;div class="body"&gt;
        We have built partnerships with small farms
        around the world to hand-select beans at the
        peak of season. We then careful roast in
        small batches to maximize their potential.
      &lt;/div&gt;
    &lt;/div&gt;
  &lt;/aside&gt;
&lt;/body&gt;
</code></pre> 
<pre><code>//在:root选择器的规则中定义变量，这样的话这些值就可以提供给根元素（整个网页）下的任何元素。
:root {
  --main-bg: #fff;      （以下2行）分别将背景色和文字颜色变量定义为白色和黑色
  --main-color: #000;   
}

.panel {
  font-size: 1rem;
  padding: 1em;
  border: 1px solid #999;
  border-radius: 0.5em;
  background-color: var(--main-bg);    （以下2行）在面板样式中使用变量
  color: var(--main-color);             
}

.panel &gt; h2 {
  margin-top: 0;
  font-size: 0.8em;
  font-weight: bold;
  text-transform: uppercase;
}
.dark {
  margin-top: 2em;  //给深色容器和前面的面板之间加上外边距
  padding: 1em;         

  background-color: #999;  //给深色容器加上深灰色背景
  --main-bg: #333;  //在容器内重定义--main-bg和--main-color变量
  --main-color: #fff;    
}
</code></pre> 
<h4><a id="262_JavaScript_542"></a>2.6.2 使用JavaScript改变自定义属性</h4> 
<pre><code>&lt;script type="text/javascript"&gt;
  var rootElement = document.documentElement;
  var styles = getComputedStyle(rootElement);    ←-- 获取一个元素的styles对象
  var mainColor = styles.getPropertyValue('--main-bg');   ←-- 获取styles对象的--main-bg值
  console.log(String(mainColor).trim());   ←---- 确保mainColor是一个字符串，并去掉前后空格；打印结果为“#fff”
&lt;/script&gt;
</code></pre> 
<p>​ <strong>在不支持自定义属性的浏览器上，任何使用<code>var()</code>的声明都会被忽略。请尽量为这些浏览器提供回退方案</strong></p> 
<h2><a id="3__557"></a>第3章 盒模型</h2> 
<h3><a id="31__559"></a>3.1 元素宽度的问题</h3> 
<p>案例</p> 
<p><img src="https://images2.imgbox.com/5d/c0/nopKlbnV_o.png" alt="[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-kv8Tn1nz-1648781887725)(D:\大学\学习资料\前端学习笔记\CSS\深入解析CSS.assets\image-20220331191841266.png)]"></p> 
<pre><code>&lt;body&gt;
  &lt;header&gt;
    &lt;h1&gt;Franklin Running Club&lt;/h1&gt;
  &lt;/header&gt;
  &lt;div class="container"&gt;
    &lt;main class="main"&gt;
      &lt;h2&gt;Come join us!&lt;/h2&gt;
      &lt;p&gt;
        The Franklin Running club meets at 6:00pm every Thursday
        at the town square. Runs are three to five miles, at your
        own pace.
      &lt;/p&gt;
    &lt;/main&gt;
    &lt;aside class="sidebar"&gt;
      &lt;div class="widget"&gt;&lt;/div&gt;
      &lt;div class="widget"&gt;&lt;/div&gt;
    &lt;/aside&gt;
  &lt;/div&gt;
&lt;/body&gt;
</code></pre> 
<pre><code>body {
  background-color: #eee;
  font-family: Helvetica, Arial, sans-serif;
}

header {
  color: #fff;
  background-color: #0072b0;
  border-radius: .5em;
}

main {
  display: block;   ←-- 修复IE的bug
}

.main {
  background-color: #fff;
  border-radius: .5em;
}

.sidebar {
  padding: 1.5em;     ←-- 给侧边栏加上内边距
  background-color: #fff;
  border-radius: .5em;
}
</code></pre> 
<p>此时效果<br> <img src="https://images2.imgbox.com/d7/44/AGOr2gXE_o.png" alt="[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-snfNPsti-1648782066574)(D:\大学\学习资料\前端学习笔记\CSS\深入解析CSS.assets\image-20220331191954725.png)]"></p> 
<p>想要做出主栏和侧栏的效果，我们首先使用浮动布局，将<code>main</code>和<code>sidebar</code>向左浮动，分别设置70%和30%的宽度</p> 
<pre><code>.main {
  float: left;
  width: 70%;            ←---- 将main列向左浮动，设置宽度为70%
  background-color: #fff;   
  border-radius: .5em;
}

.sidebar {
  float: left;
  width: 30%;       ←---- 将sidebar向左浮动，设置宽度为30%
  padding: 1.5em;       
  background-color: #fff;
  border-radius: .5em;
}
</code></pre> 
<p>但是效果却是这样</p> 
<p><img src="https://images2.imgbox.com/f9/e4/6enRZXCZ_o.png" alt="[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-mCUXi4gu-1648781887726)(D:\大学\学习资料\前端学习笔记\CSS\深入解析CSS.assets\image-20220331192058612.png)]"></p> 
<p>因为虽然将两列宽度设置为70%和30%，但是这是指定的<mark>内容的宽和高</mark>，注意，<strong>当给一个元素设置宽或高的时候，指定的是内容的宽和高。</strong></p> 
<p><img src="https://images2.imgbox.com/96/ee/ZHzmKa0T_o.png" alt="[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-7soaDfRq-1648781887727)(D:\大学\学习资料\前端学习笔记\CSS\深入解析CSS.assets\image-20220331192407839.png)]"></p> 
<p>在本例中，侧边栏的宽度等于30%宽度再加上各边1.5em左右的内边距</p> 
<h4><a id="311__653"></a>3.1.1 避免魔术数值</h4> 
<p>最笨的方法就是减少其中一列的宽度。替代魔术数值的一个方法就是让浏览器帮忙计算。</p> 
<p>在本例中，因为加了内边距，两列的宽度总和超出了3em。<strong>所以我们可以使用calc()函数减去这个值，得到刚好100%的总和</strong>。比如设置侧边栏宽度为calc(30%-3em)。但是还有更好的解决办法</p> 
<h4><a id="312__661"></a>3.1.2 调整盒模型</h4> 
<p><mark>使用box-sizing属性调整盒模型的行为</mark>，我们让指定的宽度包含内边距和边框</p> 
<blockquote> 
 <p>box-sizing的默认值为content-box，这意味着任何指定的宽或高都只会设置内容盒子的大小。<strong>把box-sizing设置为border-box后，height和width属性会设置内容、内边距以及边框的大小总和。</strong></p> 
</blockquote> 
<p><img src="https://images2.imgbox.com/1f/5f/1QTszRvQ_o.png" alt="[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-0peNm1F8-1648781887727)(D:\大学\学习资料\前端学习笔记\CSS\深入解析CSS.assets\image-20220331193044419.png)]"></p> 
<p>所以我们相对应的修改代码，给两个盒子加上box-sizing:border-box;属性</p> 
<pre><code>.main {
  box-sizing: border-box;     （以下9行）将盒模型改为border-box
  float: left;                   
  width: 70%;                    
  background-color: #fff;        
  border-radius: .5em;            
}                                 

.sidebar {                       
  box-sizing: border-box;    
  float: left;
  width: 30%;
  padding: 1.5em;
  background-color: #fff;
  border-radius: .5em;
}
</code></pre> 
<h4><a id="313_borderbox_693"></a>3.1.3 全局设置border-box</h4> 
<p>可以利用通用选择器，一劳永逸，再也不用想着调整盒模型</p> 
<pre><code>*,
::before,
::after{
	box-sizing:border-box;//给页面上所有的元素和伪元素设置border-box
}
</code></pre> 
<p>但是用第三方组件的时候要小心，因为三方组件在开发CSS的过程中没有考虑到使用者会修改盒模型时。因为全局设置<code>border-box</code>时使用的通用选择器会选中第三方组件内的每个元素，修改盒模型可能会有问题，所以最终需要写另外的样式将组件内的元素恢复为<code>content-box</code>。</p> 
<p>也可以利用继承改一下修改盒模型的方式</p> 
<pre><code>:root{
	box-sizing:border-box;
}
*,
::before,
::after {
  box-sizing: inherit;    ←---- 告诉其他所有元素和伪元素继承其盒模型
}
</code></pre> 
<p>用inherit强制继承border-box。在必要时选中第三方组件的顶级容器，将其恢复为content-box</p> 
<pre><code>.third-party-component {
  box-sizing: content-box;
}
</code></pre> 
<h4><a id="314__730"></a>3.1.4 给列之间加上间隔</h4> 
<p><img src="https://images2.imgbox.com/16/59/7YgWWpz9_o.png" alt="[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-n3y0WgAX-1648781887728)(D:\大学\学习资料\前端学习笔记\CSS\深入解析CSS.assets\image-20220331193933825.png)]"></p> 
<p>从宽度中减掉1.5em分给外边距</p> 
<pre><code>.main {
  float: left;
  width: 70%;
  background-color: #fff;
  border-radius: .5em;
}

.sidebar {
  float: left;                   
  width: calc(30% - 1.5em);   ←---- 从宽度中减去1.5em
  margin-left: 1.5em;      ←---- ……将其添加到外边距
  padding: 1.5em;             
  background-color: #fff;
  border-radius: .5em;
}
</code></pre> 
<p>这种方式不仅能够使用em指定间距，而且能让代码意图更明显。之后再看代码，从代码清单3-7中可能看不出为什么使用29%，但是代码清单3-8中的<code>30% - 1.5em</code>则能提供线索，知道它是基于30%算出来的。</p> 
<h3><a id="32__759"></a>3.2 元素高度的问题</h3> 
<p>对border-box的修改适用于高度，但是通常最好避免给元素指定明确的高度。<strong>容器的高度应该由内容决定，而不是由容器自己决定</strong>。</p> 
<h4><a id="321__765"></a>3.2.1 控制溢出行为</h4> 
<p>当明确设置一个元素的高度时，内容可能会溢出容器。</p> 
<p><img src="https://images2.imgbox.com/16/0b/rFSLaHoc_o.png" alt="[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-9QzT8xcR-1648781887728)(D:\大学\学习资料\前端学习笔记\CSS\深入解析CSS.assets\image-20220331195442019.png)]"></p> 
<h5><a id="overflow_772"></a>overflow属性</h5> 
<p>用overflow属性可以控制溢出内容的行为，该属性支持下面四个值</p> 
<ul><li>visible(默认值) 所有内容可见，即使溢出</li><li>hidden 溢出容器内边距边缘的内容被裁剪，无法看见</li><li>scroll 容器会一直出现滚动条，用户可以通过滚动查看剩余内容</li><li><strong>auto</strong> 只有内容溢出时容器才会出现滚动条</li></ul> 
<p><img src="https://images2.imgbox.com/75/41/SgVCyjBh_o.png" alt="[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-rzanqYKS-1648781887729)(D:\大学\学习资料\前端学习笔记\CSS\深入解析CSS.assets\image-20220331195716458.png)]"></p> 
<h4><a id="322__786"></a>3.2.2 百分比高度的备选方案</h4> 
<p>要想让百分比高度生效，必须给父元素明确定义一个高度。（因为容器的高度一般由子元素决定，不设定的话会造成死循环，浏览器无法处理，会忽略）</p> 
<h5><a id="_790"></a>等高列</h5> 
<p>现代浏览器支持了CSS表格，可以轻松实现等高列。比如IE8+支持<code>display: table</code>，IE10+支持弹性盒子或者Flexbox，都默认支持等高列。</p> 
<p>我现在想要将上面的例子主列和侧边栏高度对齐，看起来更好看。想要任意一列的内容增加，两列的高度都会增加的效果，同时要保持底部对齐</p> 
<p><img src="https://images2.imgbox.com/92/63/qsQhuc9i_o.png" alt="[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-sRbOo79W-1648782151465)(D:\大学\学习资料\前端学习笔记\CSS\深入解析CSS.assets\image-20220331200304717.png)]"></p> 
<p>下面演示通过CSS表格和Flexbox两种方式实现这种效果。</p> 
<h5><a id="CSS_803"></a>CSS表格布局</h5> 
<p><mark>用CSS表格布局替代浮动布局。给容器设置<code>display: table</code>，给每一列设置<code>display: table-cell</code></mark></p> 
<pre><code>.container {               
  display: table;      ←---- 让容器布局像表格一样
  width: 100%;      ←---- ❶让表格填充容器的宽度
}                      

.main {
  display: table-cell;
  width: 70%;              （以下7行）让列布局像表格的单元格一样
  background-color: #fff;      
  border-radius: .5em;         
}                              

.sidebar {                     
  display: table-cell;      
  width: 30%;
  margin-left: 1.5em;       ←---- ❷外边距不再生效
  padding: 1.5em;              
  background-color: #fff;      
  border-radius: .5em;
}
</code></pre> 
<p><img src="https://images2.imgbox.com/6d/4f/hWmT32Wi_o.png" alt="[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-vjjoQwBP-1648782167172)(D:\大学\学习资料\前端学习笔记\CSS\深入解析CSS.assets\image-20220331200723216.png)]"></p> 
<p>默认情况下，display:table的元素不会扩展到100%，所以需要明确指定宽度，下图是没有指定宽度的情况</p> 
<p><img src="https://images2.imgbox.com/88/e1/teaZU6Yx_o.png" alt="[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-OONCsl8i-1648782182166)(D:\大学\学习资料\前端学习笔记\CSS\深入解析CSS.assets\image-20220331200914101.png)]"></p> 
<blockquote> 
 <p><mark>border-spacing</mark> 定义单元格的间距。该属性接受两个长度值：水平间距和垂直间距</p> 
</blockquote> 
<p><img src="https://images2.imgbox.com/44/28/I7jjY9at_o.png" alt="[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-ctgz9fj3-1648781887732)(D:\大学\学习资料\前端学习笔记\CSS\深入解析CSS.assets\image-20220331201138728.png)]"></p> 
<p><img src="https://images2.imgbox.com/dc/00/bkLRVvG9_o.png" alt="[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-Z02pbxbk-1648782203257)(D:\大学\学习资料\前端学习笔记\CSS\深入解析CSS.assets\image-20220331201117533.png)]"></p> 
<p>但是会产生副作用，这个值也会作用于表格的外边缘。这样两列就无法跟头部左右对齐了</p> 
<blockquote> 
 <p>负外边距</p> 
</blockquote> 
<p>需要给整个表格包裹一层新的容器</p> 
<p>在表格容器外面包一个元素<code>&lt;div class="wrapper"&gt;</code>，将其左右外边距设置为-1.5em，从而抵消表格容器外侧1.5em的<code>border-spacing</code>。</p> 
<p>正的外边距会将容器的边缘往里推，而负的外边距则会将边缘往外拉。结合<code>border-spacing</code>，两列靠近外侧的边缘跟<code>&lt;body&gt;</code>（包裹元素所在的容器盒子）的边缘对齐了。现在的布局满足了需求：两列等高，1.5em的间距，外边缘跟头部对齐<br> <img src="https://images2.imgbox.com/56/c1/rDUpk1Zs_o.png" alt="[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-nZeAIxF1-1648782249060)(D:\大学\学习资料\前端学习笔记\CSS\深入解析CSS.assets\image-20220331201808357.png)]"></p> 
<p><img src="https://images2.imgbox.com/1c/74/bFPg3nne_o.png" alt="在这里插入图片描述"></p> 
<p><img src="https://images2.imgbox.com/27/d6/zAxq0Hp3_o.png" alt="在这里插入图片描述"></p> 
<h5><a id="Flexbox_867"></a>Flexbox</h5> 
<p>可以利用Flexbox实现两列等高布局。Flexbox不需要一个额外的<code>div</code>包裹元素，它默认会产生等高的元素。此外也不需要使用负外边距。</p> 
<pre><code>.container {
  display: flex;   ←---- 将容器的display属性设置为flex
}                       

.main {  （以下7行）弹性容器内的元素不需要指定display或者float属性
  width: 70%;                   
  background-color: #fff;     
  border-radius: 0.5em;         
}                              

.sidebar {                   
  width: 30%;
  padding: 1.5em;
  margin-left: 1.5em;     ←---- 跟浮动布局一样，外边距可以生效
  background-color: #fff;        
  border-radius: .5em;
}
</code></pre> 
<p>给容器设置<code>display: flex</code>，它就变成了一个<strong>弹性容器</strong>，<mark>子元素默认等高</mark>。</p> 
<p><img src="https://images2.imgbox.com/1e/8d/IHaflyI9_o.png" alt="[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-jieRMCE2-1648782376008)(D:\大学\学习资料\前端学习笔记\CSS\深入解析CSS.assets\image-20220331202406049.png)]"></p> 
<h4><a id="323_minheightmaxheight_898"></a>3.2.3 使用min-height和max-height</h4> 
<p>可以用这俩属性指定最小或最大值，而不是明确定义高度，这样元素就可以在这些界限内自动决定高度</p> 
<p>有三个元素。左边的元素没有<code>min-height</code>，因此它的高度由自身决定，另外两个元素都设置了<code>min-height</code>为3em。中间的元素如果自己决定高度的话应该比现在矮，但是<code>min-height</code>值让它的高度为3em。右边的元素内容多到已经超过3em，容器自然地扩展高度，以容纳内容。</p> 
<p><img src="https://images2.imgbox.com/49/10/KYg7y29Z_o.png" alt="[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-3c6yHZnd-1648781887735)(D:\大学\学习资料\前端学习笔记\CSS\深入解析CSS.assets\image-20220331202837172.png)]"></p> 
<p>用人话讲就是，只要我设定了min-heigth，就算内容没有这么高也要设这么高，如果内容高于这个就自然扩容</p> 
<p>同理，<code>max-height</code>允许元素自然地增高到一个特定界限。如果到达这个界限，元素就不再增高，内容会溢出。还有类似的属性是<code>min-width</code>和<code>max-width</code>，用于限制元素的宽度。</p> 
<h4><a id="324__913"></a>3.2.4 垂直居中的内容</h4> 
<p>最简单的垂直居中方法：给容器相等的上下内边距</p> 
<p><img src="https://images2.imgbox.com/30/d8/X2pslsCf_o.png" alt="[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-vGWXHD5G-1648782405477)(D:\大学\学习资料\前端学习笔记\CSS\深入解析CSS.assets\image-20220331203250359.png)]"></p> 
<h3><a id="33__922"></a>3.3 负外边距</h3> 
<p>负外边距有一些特殊用途，比如让元素重叠或者拉伸到比容器还宽。</p> 
<p><mark>负外边距的具体行为取决于设置在元素的哪边</mark></p> 
<p><strong>如果设置左边或顶部的负外边距，元素就会相应地向左或向上移动，导致元素与它前面的元素重叠，如果设置右边或者底部的负外边距，并不会移动元素，而是将它后面的元素拉过来</strong></p> 
<p><img src="https://images2.imgbox.com/9b/64/8k8xaAgx_o.png" alt="[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-SBmFzoxX-1648782435369)(D:\大学\学习资料\前端学习笔记\CSS\深入解析CSS.assets\image-20220331203526762.png)]"></p> 
<p>​ <strong>在margin属性中一共有两类参考线，top和left的参考线属于一类，right和bottom的参考线属于另一类。top和left是以外元素为参考，right和bottom是以元素本身为参考</strong></p> 
<p>如果不给一个块级元素指定宽度，它会自然地填充容器的宽度。但如果在右边加上负外边距，则会把它拉出容器。如果在左边再加上相等的负外边距，元素的两边都会扩展到容器外面。这就是为什么可以拉宽图3-12里的表格容器布局，让它填满<code>&lt;body&gt;</code>的宽度，忽略border-spacing的影响。</p> 
<h3><a id="34__941"></a>3.4 外边距折叠</h3> 
<p><img src="https://images2.imgbox.com/1b/10/c1qdXJ5Y_o.png" alt="[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-GnuVFGnt-1648781887737)(D:\大学\学习资料\前端学习笔记\CSS\深入解析CSS.assets\image-20220331210839894.png)]"></p> 
<h4><a id="341__950"></a>3.4.1 文字折叠</h4> 
<p>段落（<code>&lt;p&gt;</code>）默认有1em的上外边距和1em的下外边距。这是用户代理的样式表添加的，<strong>但当前后叠放两个段落时，它们的外边距不会相加产生一个2em的间距，而会折叠，只产生1em的间隔</strong>。</p> 
<p><img src="https://images2.imgbox.com/b3/4c/o4LMED3v_o.png" alt="[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-H5uK34pa-1648781887738)(D:\大学\学习资料\前端学习笔记\CSS\深入解析CSS.assets\image-20220331211927688.png)]"></p> 
<p>折叠外边距大小等于相邻外边距中的最大值</p> 
<h4><a id="342__961"></a>3.4.2 多个外边距折叠</h4> 
<p>即使两个元素不是相邻的兄弟节点也会产生外边距折叠。在没有其他CSS的影响下，所有相邻的顶部和底部外边距都会折叠。</p> 
<p>也就是说可以给任何元素加上外边距，而不必担心它们前后的元素是什么。</p> 
<h4><a id="343__969"></a>3.4.3 容器外部折叠</h4> 
<p><img src="https://images2.imgbox.com/19/58/r8Xiod36_o.png" alt="[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-DzWWvONH-1648781887738)(D:\大学\学习资料\前端学习笔记\CSS\深入解析CSS.assets\image-20220331212428381.png)]"></p> 
<p>网页标题是</p> 
<h2>，用户代理样式给他底部设置的外边距0.67em</h2> 
<p></p> 
<p><img src="https://images2.imgbox.com/8e/67/JYSayRfq_o.png" alt="[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-XczeuM6k-1648781887739)(D:\大学\学习资料\前端学习笔记\CSS\深入解析CSS.assets\image-20220331212531732.png)]"></p> 
<p>它的父元素是</p> 
<header>
  ，没有设置任何外边距。因为它们底部外边距相邻，所以会真的，导致 
 <header>
   下方出现了0.67em的外边距。 
 </header> 
</header> 
<p></p> 
<p>但是"Come join us"上方的外边距没有在容器外面折叠。这是因为<strong>弹性子元素的外边距不会折叠</strong>。利用Flexbox布局。</p> 
<p><strong>给头部添加上下内边距，外边距就不会在容器外部折叠</strong>。</p> 
<p>现在更新CSS:</p> 
<pre><code>header {
  padding: 1em 1.5em;
  color: #fff;
  background-color: #0072b0;
  border-radius: .5em;
}
</code></pre> 
<p><img src="https://images2.imgbox.com/73/86/yGJua8NF_o.png" alt="[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-F2t77ZHS-1648781887740)(D:\大学\学习资料\前端学习笔记\CSS\深入解析CSS.assets\image-20220331213030065.png)]"></p> 
<p><img src="https://images2.imgbox.com/5e/1d/fBFHHqBW_o.png" alt="[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-aD0hs7O7-1648781887740)(D:\大学\学习资料\前端学习笔记\CSS\深入解析CSS.assets\image-20220331213056476.png)]"></p> 
<p>看看变化！</p> 
<blockquote> 
 <p>防止外边距折叠的方法</p> 
</blockquote> 
<ul><li>对容器使用overflow:auto(或者非visible的值)，防止内部元素的外边距跟容器外部的外边距折叠，此方法副作用小</li><li>在两个外边距之间加上边框或者内边距，防止它们折叠（两个都要加！！）</li><li>如果容器为浮动元素、内敛块、绝对定位或固定定位时，外边距不会在它外面折叠</li><li>当使用flexbox布局时，弹性布局内的元素之间不会发生外边距折叠</li><li>当元素显示为table-cell时不具备外边距属性，因此不会折叠</li></ul> 
<h3><a id="35__1018"></a>3.5 容器内的元素边距</h3> 
<p>想要的效果：加上两个按钮和一个链接</p> 
<p><img src="https://images2.imgbox.com/95/8d/4ZK1TBmG_o.png" alt="[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-AMUE803K-1648781887741)(D:\大学\学习资料\前端学习笔记\CSS\深入解析CSS.assets\image-20220401101243549.png)]"></p> 
<pre><code>&lt;aside class="sidebar"&gt;
  &lt;a href="/twitter" class="button-link"&gt;
    follow us on Twitter
  &lt;/a&gt;
  &lt;a href="/facebook" class="button-link"&gt;
    like us on Facebook
  &lt;/a&gt;
&lt;/aside&gt;
</code></pre> 
<pre><code>.button-link {
  display: block;            ←---- 块级元素填满了可用宽度，同时让每个链接单独一行
  padding: 0.5em;                
  color: #fff;
  background-color: #0090C9;
  text-align: center;
  text-decoration: none;
  text-transform: uppercase;
}
</code></pre> 
<p>此时的效果</p> 
<p><img src="https://images2.imgbox.com/f5/3e/CtBv87s1_o.png" alt="[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-LBlTwqoN-1648781887741)(D:\大学\学习资料\前端学习笔记\CSS\深入解析CSS.assets\image-20220401101751704.png)]"></p> 
<p>需要给两个按钮之间加间距</p> 
<p>如果直接加上margin-top:1.5rem，效果如图</p> 
<p><img src="https://images2.imgbox.com/8c/1c/xoLt29TL_o.png" alt="在这里插入图片描述"></p> 
<p><img src="https://images2.imgbox.com/19/5a/RodOSWQj_o.png" alt="[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-tmoKqfrz-1648781887743)(D:\大学\学习资料\前端学习笔记\CSS\深入解析CSS.assets\image-20220401102022951.png)]"></p> 
<p>侧边栏的内部边距padding和按钮的外边距接触了，按钮的上外边距使得容器的内边距看起来更大了</p> 
<p>解决办法：使用相邻的兄弟组合器（+）选中同一个父元素下紧跟在其他button-link后面的button-link元素。</p> 
<pre><code>.button-link {
  display: block;
  padding: .5em;
  color: #fff;
  background-color: #0090C9;
  text-align: center;
  text-decoration: none;
  text-transform: uppercase;
}

.button-link + .button-link {  
  //只给紧跟在其他button-link后面的button-link加上顶部外边距
  margin-top: 1.5em;             
}
</code></pre> 
<p><img src="https://images2.imgbox.com/f2/37/vrf6gQsi_o.png" alt="[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-7X584Qha-1648781887744)(D:\大学\学习资料\前端学习笔记\CSS\深入解析CSS.assets\image-20220401102534702.png)]"></p> 
<p>只有第二个按钮有margin-top，这样显示就正常了</p> 
<p>但是，当我们再往侧边栏加点内容</p> 
<pre><code>&lt;a href="/sponsors" class="sponsor-link"&gt;   （以下3行）给侧边栏加上另一种链接
    become a sponsor                          
  &lt;/a&gt;                
</code></pre> 
<p><img src="https://images2.imgbox.com/54/33/BKQsK7ZQ_o.png" alt="[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-fWeeKnRI-1648781887745)(D:\大学\学习资料\前端学习笔记\CSS\深入解析CSS.assets\image-20220401102739174.png)]"></p> 
<p>加上样式</p> 
<pre><code>.sponsor-link {
  display: block;
  color: #0072b0;
  font-weight: bold;
  text-decoration: none;
}
</code></pre> 
<p><img src="https://images2.imgbox.com/e1/3a/Wj7dJpdN_o.png" alt="[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-VOAG7Oec-1648781887745)(D:\大学\学习资料\前端学习笔记\CSS\深入解析CSS.assets\image-20220401102906153.png)]"></p> 
<p>可以给这个链接增加顶部外边距以实现效果，但是每次增加内容、修改HTML都要改动，每次都要考虑这些外边距问题。</p> 
<h4><a id="352__1122"></a>3.5.2 更通用的解决方案：猫头鹰选择器</h4> 
<p>Web设计师Heydon Pickering曾表示外边距“就像是给一个物体的一侧涂了胶水，而你还没有决定是否要将它贴到某处，或者还没想好要贴到什么东西上”。不要给网页当前的内容固定外边距，而是应该采取更通用的方式，不管网页结构如何变化都能够生效。这就是Heydon Pickering所说的<strong>迟钝的猫头鹰选择器</strong>（以下简称猫头鹰选择器），因为它长这样：<code>* + *</code>。</p> 
<p>该选择器开头是一个通用选择器（*），可以选中所有元素，后面是一个相邻兄弟组合器（+），最后是另一个通用选择器 。<mark>它会选中页面上有着相同父级的<strong>非第一个子元素</strong></mark></p> 
<pre><code>body * + * {
  margin-top: 1.5em;
}
</code></pre> 
<p>我们将body放选择器的前面，这样该选择器就只能选中body内的元素。</p> 
<p><img src="https://images2.imgbox.com/76/be/lXEgdEo8_o.png" alt="[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-3kADws99-1648781887746)(D:\大学\学习资料\前端学习笔记\CSS\深入解析CSS.assets\image-20220401104254375.png)]"></p> 
<p>效果如图。此时sidebar上面也会有顶部外边距，header和container是兄弟，所以container被选中，然后container中main和siderbar是兄弟，所以siderbar被选中，所以siderbar上面有外间距</p> 
<p><img src="https://images2.imgbox.com/07/e7/P5l3fd9f_o.png" alt="[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-16RF5vHS-1648781887746)(D:\大学\学习资料\前端学习笔记\CSS\深入解析CSS.assets\image-20220401104445467.png)]"></p> 
<p>要修正此错误，可以给主列补上内边距</p> 
<pre><code>.main {
  width: 70%;
  padding: 1em 1.5em;    ←----给主列加上内边距
  background-color: #fff;       
  border-radius: .5em;
}

.sidebar {
  width: 30%;
  padding: 1.5em;
  margin-top: 0;          ←---- 移除猫头鹰选择器设置的顶部外边距
  margin-left: 1.5em;         
  background-color: #fff;
  border-radius: .5em;
}
</code></pre> 
<p>margin-top=0;修正顶部外边距</p> 
<p><img src="https://images2.imgbox.com/60/42/0J8CUeo4_o.png" alt="[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-yDoXr6QG-1648781887747)(D:\大学\学习资料\前端学习笔记\CSS\深入解析CSS.assets\image-20220401104801109.png)]"></p> 
<p><img src="https://images2.imgbox.com/a9/0f/jpvU7oxh_o.png" alt="[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-trIN0oMY-1648781887748)(D:\大学\学习资料\前端学习笔记\CSS\深入解析CSS.assets\image-20220401104830713.png)]"></p> 
<p>给main栏补上内边距</p> 
<p><img src="https://images2.imgbox.com/43/a6/OTvqsIYj_o.png" alt="[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-rXyZcuLP-1648781887748)(D:\大学\学习资料\前端学习笔记\CSS\深入解析CSS.assets\image-20220401105640430.png)]"></p> 
<p>考虑这些外边距问题。</p> 
<h4><a id="352__1183"></a>3.5.2 更通用的解决方案：猫头鹰选择器</h4> 
<p>Web设计师Heydon Pickering曾表示外边距“就像是给一个物体的一侧涂了胶水，而你还没有决定是否要将它贴到某处，或者还没想好要贴到什么东西上”。不要给网页当前的内容固定外边距，而是应该采取更通用的方式，不管网页结构如何变化都能够生效。这就是Heydon Pickering所说的<strong>迟钝的猫头鹰选择器</strong>（以下简称猫头鹰选择器），因为它长这样：<code>* + *</code>。</p> 
<p>该选择器开头是一个通用选择器（*），可以选中所有元素，后面是一个相邻兄弟组合器（+），最后是另一个通用选择器 。<mark>它会选中页面上有着相同父级的<strong>非第一个子元素</strong></mark></p> 
<pre><code>body * + * {
  margin-top: 1.5em;
}
</code></pre> 
<p>我们将body放选择器的前面，这样该选择器就只能选中body内的元素。</p> 
<p><img src="https://images2.imgbox.com/c9/5c/xq5pK7Te_o.png" alt="[外链图片转存中...(img-3kADws99-1648781887746)]"></p> 
<p>效果如图。此时sidebar上面也会有顶部外边距，header和container是兄弟，所以container被选中，然后container中main和siderbar是兄弟，所以siderbar被选中，所以siderbar上面有外间距</p> 
<p><img src="https://images2.imgbox.com/ab/da/SAhg1PtW_o.png" alt="[外链图片转存中...(img-16RF5vHS-1648781887746)]"></p> 
<p>要修正此错误，可以给主列补上内边距</p> 
<pre><code>.main {
  width: 70%;
  padding: 1em 1.5em;    ←----给主列加上内边距
  background-color: #fff;       
  border-radius: .5em;
}

.sidebar {
  width: 30%;
  padding: 1.5em;
  margin-top: 0;          ←---- 移除猫头鹰选择器设置的顶部外边距
  margin-left: 1.5em;         
  background-color: #fff;
  border-radius: .5em;
}
</code></pre> 
<p>margin-top=0;修正顶部外边距</p> 
<p><img src="https://images2.imgbox.com/50/09/8tfaPB08_o.png" alt="[外链图片转存中...(img-yDoXr6QG-1648781887747)]"></p> 
<p><img src="https://images2.imgbox.com/86/0f/lwns2vCp_o.png" alt="[外链图片转存中...(img-trIN0oMY-1648781887748)]"></p> 
<p>给main栏补上内边距</p> 
<p><img src="https://images2.imgbox.com/0c/d7/YxzpWYXI_o.png" alt="[外链图片转存中...(img-rXyZcuLP-1648781887748)]"></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/b3ebc1edd23adf3386b1bb168519f1d3/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">Hive运行语句报错： Execution Error, return code 1 from org.apache.hadoop.hive.ql.exec.DDLTask. Me</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/53d14ad1d50d06ab43a1df8f52a271b2/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">Python中多进程</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>