<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>set&#43; vector的详解及用法 - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="set&#43; vector的详解及用法" />
<meta property="og:description" content="Set 的用法总结： //====================== /*C&#43;&#43;STL之set的基本操作 //2015-04-1321:05 by itwolf, 1943 阅读, 0 评论, 收藏, 编辑 set是集合，虽然也存在键值和实值，不过两者根本就是同一个值，键值的设置完全就是为了满足红黑树的底层结构，set操作与map很像不过也有些不同。 1、set迭代器与map的不同： (1)set使用接引用运算符*取值，而map使用first和second取值。 (2)set的迭代器都是常量迭代器，不能用来修改所指向的元素，而map的迭代器是可以修改所指向元素的。 2、set没有重载[]运算符，而map中重载了，因为直接使用[]改变元素值会打乱原本正确的顺序，要改变元素值必须先删除旧元素，则插入新元素 3、构造的类型不一样，如同样实值为int类型分别为set&lt;int&gt;和map&lt;type,int&gt;(其中type可以为任意类型) 其他如插入、删除、查找等操作与map几乎一样 */ #include&lt;iostream&gt; #include&lt;set&gt; using namespace std; voidprint(set&lt;int&gt;set_int) { set&lt;int&gt;::iteratorit=set_int.begin(); for(;it!=set_int.end();it&#43;&#43;) cout&lt;&lt;*it&lt;&lt;&#34; &#34;; //循环输出 set容器里面的元素是被排好序之后进行的输出！！！！！重要！！！！ cout&lt;&lt;endl; } int main() { intnum[4]={1,2,3,4}; set&lt;int&gt;set_int(num,num&#43;4); set_int.insert(5); //代表了插入一个元素 并且输出set集合里面的值 2,在pos位置之前插入value，返回新元素位置，但不一定能插入成功 //iterator insert(&amp;pos, value) print(set_int); set_int.insert(5); print(set_int); //元素删除 set_int.erase(3);//1. 移除set容器中的所有为3的元素值 并返回元素的个数 //2.voiderase(&amp;pos) //移除pos位置上的元素 无返回值 //3.void erase（&amp;first，&amp;last） 移除迭代区间【&amp;first,last)内的元素无返回值 //4.void clear(); 移除set容器中的所有元素 print(set_int); //元素查找 //count(value)返回set对象内元素之为value的元素个数 //iterator find(value)返回value所在位置，找不到value将返回end（）； //lower_bound(value)表示返回大于等于value的第一个元素的下标 upper_bound(value),qual_range(value); int a[5]={8,4,5,5,5}; // 当你的数组中有重复的元素时放入set容器输出直接将重复的删除 set&lt;int&gt;v4(a,a&#43;5); print(v4); //--------------以下查找函数 返回的值的下标是不对的！！！！！！！！ 建议先不使用该函数------------- set&lt;int&gt;::iteratorit; it=v4." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/db7ad391d660fc3ccf879c73463d32a2/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2017-08-11T11:35:03+08:00" />
<meta property="article:modified_time" content="2017-08-11T11:35:03+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">set&#43; vector的详解及用法</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <div> 
 <br> Set 的用法总结： 
 <br>   
 <br> //====================== 
 <br> /*C++STL之set的基本操作 
 <br> //2015-04-1321:05 by itwolf, 1943 阅读, 0 评论, 收藏, 编辑 
 <br> set是集合，虽然也存在键值和实值，不过两者根本就是同一个值，键值的设置完全就是为了满足红黑树的底层结构，set操作与map很像不过也有些不同。 
 <br> 1、set迭代器与map的不同： 
 <br> (1)set使用接引用运算符*取值，而map使用first和second取值。 
 <br> (2)set的迭代器都是常量迭代器，不能用来修改所指向的元素，而map的迭代器是可以修改所指向元素的。 
 <br> 2、set没有重载[]运算符，而map中重载了，因为直接使用[]改变元素值会打乱原本正确的顺序，要改变元素值必须先删除旧元素，则插入新元素 
 <br> 3、构造的类型不一样，如同样实值为int类型分别为set&lt;int&gt;和map&lt;type,int&gt;(其中type可以为任意类型) 
 <br> 其他如插入、删除、查找等操作与map几乎一样 
 <br> */ 
 <br>   
</div> 
<div> 
 <br> 
</div> 
<pre><code class="language-cpp">#include&lt;iostream&gt;
#include&lt;set&gt;
using namespace std;
voidprint(set&lt;int&gt;set_int)
{
set&lt;int&gt;::iteratorit=set_int.begin();
for(;it!=set_int.end();it++)
cout&lt;&lt;*it&lt;&lt;" ";           //循环输出  set容器里面的元素是被排好序之后进行的输出！！！！！重要！！！！
 
cout&lt;&lt;endl;
}
int main()
{
intnum[4]={1,2,3,4};
set&lt;int&gt;set_int(num,num+4);
 
set_int.insert(5); //代表了插入一个元素 并且输出set集合里面的值
                2,在pos位置之前插入value，返回新元素位置，但不一定能插入成功
    //iterator insert(&amp;pos, value)
 
print(set_int);
 
set_int.insert(5);
print(set_int);
 
//元素删除
 
set_int.erase(3);//1. 移除set容器中的所有为3的元素值 并返回元素的个数
                     //2.voiderase(&amp;pos)   //移除pos位置上的元素 无返回值
                     //3.void erase（&amp;first，&amp;last） 移除迭代区间【&amp;first,last)内的元素无返回值
//4.void clear();  移除set容器中的所有元素
print(set_int);
 
//元素查找
//count(value)返回set对象内元素之为value的元素个数
//iterator find(value)返回value所在位置，找不到value将返回end（）；
//lower_bound(value)表示返回大于等于value的第一个元素的下标   upper_bound(value),qual_range(value);
 
int a[5]={8,4,5,5,5};       // 当你的数组中有重复的元素时放入set容器输出直接将重复的删除
set&lt;int&gt;v4(a,a+5);
print(v4);
//--------------以下查找函数  返回的值的下标是不对的！！！！！！！！ 建议先不使用该函数-------------
set&lt;int&gt;::iteratorit;   
it=v4.find(5);   //it为5所在下标的位置
cout&lt;&lt;*it&lt;&lt;endl;         //因为it是一个迭代器（指针） 所以需要加一个  *   表示该指针指向变量的值
 
set&lt;int&gt;::iteratorq;
q=set_int.find(2);      //搞不懂输出的是麻子
cout&lt;&lt;*q&lt;&lt;endl;
q=set_int.find(8);       // 同上
cout&lt;&lt;*q&lt;&lt;endl;
    //------------- 截至到以上是查找函数  ------------
 
 
         return0;
}
 </code></pre> 
<div> 
 <br> 
</div> 
<div> 
 <br> 
</div> 
<div>
  以下给予的是C++stl容器set成员函数： 
 <br> begin()--返回指向第一个元素的迭代器 
 <br> clear()--清除所有元素 
 <br> count()--返回某个值元素的个数 
 <br>          empty()--如果集合为空，返回true 
 <br> end()--返回指向最后一个元素的迭代器 
 <br> equal_range()--返回集合中与给定值相等的上下限的两个迭代器 
 <br> erase()--删除集合中的元素 
 <br> find()--返回一个指向被查找到元素的迭代器 
 <br> get_allocator()--返回集合的分配器 
 <br> insert()--在集合中插入元素 
 <br> lower_bound()--返回指向大于（或等于）某值的第一个元素的迭代器 
 <br> key_comp()--返回一个用于元素间值比较的函数 
 <br> max_size()--返回集合能容纳的元素的最大限值 
 <br> rbegin()--返回指向集合中最后一个元素的反向迭代器 
 <br> rend()--返回指向集合中第一个元素的反向迭代器 
 <br> size()--集合中元素的数目 
 <br> swap()--交换两个集合变量 
 <br> upper_bound()--返回大于某个值元素的迭代器 
 <br> value_comp()--返回一个用于比较元素间的值的函数 
 <br> lower_bound(key_value)?，返回第一个大于等于key_value的定位器 
 <br> upper_bound(key_value)，返回最后一个大于等于key_value的定位器 
</div> 
<div> 
 <br> 
</div> 
<div> 
 <br> 
</div> 
<div>
  三.自定义比较函数 
 <br> 1.元素不是是结构体 
 <br>   
 <br>   
 <br>         struct myComp 
 <br>         { 
 <br>             bool operator()(const your_type&amp;a,const your_type &amp;b) 
 <br>             [ 
 <br>                 return a.data-b.data&gt;0; 
 <br>             } 
 <br>         } 
 <br>         set&lt;int,myComp&gt;s; 
 <br>         ...... 
 <br>         set&lt;int,myComp&gt;::iterator it; 
 <br>         
 <br>         
 <br> 如果元素是结构体，可以直接将比较函数写在结构体内 
 <br>         struct Info 
 <br>         { 
 <br>             string name; 
 <br>             float score; 
 <br>             //重载“&lt;”操作符，自定义排序规则 
 <br>             bool operator &lt; (const Info&amp;a) const 
 <br>             { 
 <br>                 //按score从大到小排列 
 <br>                 return a.score&lt;score; 
 <br>             } 
 <br>         } 
 <br>         set&lt;Info&gt; s; 
 <br>         ...... 
 <br>         set&lt;Info&gt;::iterator it; 
 <br>   
 <br>   
 <br>   
 <br> Vector 的用法总结： 
</div> 
<div> 
 <br> 
</div> 
<div> 
 <pre><code class="language-cpp">#include&lt;iostream&gt;
using namespace std;
#include&lt;vector&gt;
#include&lt;string&gt;
#include&lt;algorithm&gt;
 
int main()
{
stringstr[]={"Alex","John","Robert"};
vector&lt;int&gt; v1;//   创建一个空vector容器
vector&lt;int&gt; v2(10);  //创建一个有10个空元素的vector容器
vector&lt;int&gt; v3(10,0); //创建一个有10个元素的vector容器，并赋值为0；
vector&lt;string&gt; v4(str,str+3);  //根据字符串数组创建vector容器
 
 
vector&lt;string&gt;::iterator e = v4.begin();   //迭代器法遍历
while(e!=v4.end())
{
cout&lt;&lt;*e++&lt;&lt;"";
}
cout&lt;&lt;endl;
 
vector&lt;string&gt; v5(v4);  //拷贝构造
 
for(int i=0;i&lt;3;i++) //下标遍历
cout&lt;&lt;v5[i]&lt;&lt;"";
cout&lt;&lt;endl;
 
return0;
}</code></pre> 
 <br> 
</div> 
<div> 
 <br>  [STL]vector基本用法 
 <br>   
 <br> vector的数据安排以及操作方式，与array非常相似。两者的唯一区别在于空间的运用的灵活性。array是静态空间，一旦配置了就不能改变。vector是动态空间，随着元素的加入，它的内部机制会自行扩充空间以容纳新元素。因此，vector的运用对于内存的合理利用与运用的灵活性有很大的帮助，我们再也不必因为害怕空间不足而一开始要求一个大块的array。 
 <br>   
 <br> vector动态增加大小，并不是在原空间之后持续新空间（因为无法保证原空间之后尚有可供配置的空间），而是以原大小的两倍另外配置一块较大的空间，然后将原内容拷贝过来，然后才开始在原内容之后构造新元素，并释放原空间。因此，对vector的任何操作，一旦引起空间重新配置，指向原vector的所有迭代器就都失效了。 
</div> 
<div> 
 <br> 
</div> 
<div> 
 <br> 
</div> 
<pre><code class="language-cpp">int main()
{
inti=0;
for(;i&lt;25;i++)   //向容器中填充数据
{
v4.push_back(1);
}
 
v4.resize(400);   // 将容器的大小改为400  可以存放400个数据
 
 
class act   //定义一个存放class的容器
{
};
vector&lt;act&gt;v4;
 
vector&lt;int&gt; v4(100,0)   //定义100个int型数据并都给赋值为0
 
vector&lt;int&gt; v4(100,0); //将v4的内容全部赋值给v3；
vector&lt;int&gt;v3(v4); </code></pre> 
<div> 
 <br> 
</div> 
<div> 
 <br> 
</div> 
<div>
  #include&lt;vector&gt;        //头文件应该定义为 
 <br>   
 <br> using std::vector或者using namespacestd或者不用定义，直接在使用vector的代码前使用std::加vector&lt;int&gt;v4;           //vector属于std命名域的，因此需要通过命名限定，可以在文件开头加上 
</div> 
<div> 
 <br> 
</div> 
<div>
  std::vector&lt;int&gt; v4;//定义一个vector 
 <br>   
 <br> //以下为vector可以使用的功能 
 <br> v4.clear()  // 移除容器中所有数据。 
 <br> v4.empty()   //判断容器是否为空 
 <br> v4.erase(pos) //删除pos位置的数据 
 <br> v4.erase(beg,end) //删除【beg，end）区间的数据 
 <br> v4.front()    //传回第一个数据 
 <br> v4.insert(pos,elem) //在pos位置插入一个elem拷贝 
 <br> v4.pop_back()  //删除最后一个数据 
 <br> v4.push_back(elem)  //在尾部加入一个数据 
 <br> v4.resize(num)  //改容器的大小 
 <br> v4.size()  //返回容器中实际数据的个数 
 <br> v4.begin() //返回指向容器第一个元素的迭代器 
 <br> v4.end()  //返回指向容器最后一个元素的迭代器 
 <br>   
 <br>   
 <br>  下面介绍什么事迭代器 
 <br>         //迭代器相当于指针 
 <br> int a=10;//对于变量而言  使用指针指向对应的变量 
 <br> int *p;  //以后就可以使用 * 加指针操作该变量了 
 <br> p=&amp;a; 
 <br>   
 <br> //使用指针操作该变量 
 <br> *p=11；   //操作后a变为11 
 <br> //对于容器使用迭代器操作容器中对应位置的值 
 <br> //当迭代器指向了容器中的某位置，则可以使用 *加迭代器操作该位置了 
</div> 
<div>
  std::vector&lt;int&gt; v4;   //定义一个vector 
 <br> for(i=0;i&lt;10;i++) 
 <br> v4.push_back(j);  //添加10个变量  填入值随变量j的变化而变化 
 <br>   
 <br> std::vector&lt;int&gt;::iterator p; //定义一个迭代器  相当于定义一个指针 
 <br>   
 <br> p=v4.begin(); //该（指针）迭代器指向容器的第一个元素 
 <br> p++;  //  （指针) 迭代器移动至下一个元素（指向下一个元素） 
 <br>   
 <br> *p=20;    //修改指向该元素的值   意味着容器中第二个值被修改为20 
 <br>   
 <br> p=v4.begin(); //循环扫描迭代器，改变所有值 
 <br> for(;p!=v4.end();p++) 
 <br> *p=50; 
 <br>         以上为vector的用法仅供入门只用 许多看多练习 
</div> 
<div> 
 <br> 
</div> 
<div> 
 <br> 
</div> 
<div>
  #include&lt;iostream&gt; 
 <br> #include&lt;string&gt; 
 <br> #include&lt;vector&gt; 
 <br> using namespace std; 
 <br> void main() 
 <br> { 
 <br> inti=0; 
 <br> vector&lt;int&gt; v;  //定义一个vector容器 v 
 <br>   
 <br> for(i=0;i&lt;10;i++) 
 <br> v.push_back(i); // 元素放进vector中 
 <br>   
 <br>     for(i=0;i&lt;v.size();i++) 
 <br> cout&lt;&lt;v[i]&lt;&lt;" ";  //输出每个元素 
 <br> cout&lt;&lt;endl; 
 <br> } 
 <br>   
 <br> /// 你也可以用v.begin()与v.end()来得到vector开始的和结束的元素地址的指针位置 
 <br>   
 <br> vector&lt;int&gt;::iteratoriter; 
 <br> for(iter=v.begin();iter!=v.end();iter++) 
 <br> cout&lt;&lt;*iter&lt;&lt;endl; 
 <br>   
 <br> //对于二维vector的定义 
 <br>  定义一个10个vector元素，并对每个vector赋值1-10 
 <br>   
 <br>   
 <pre><code class="language-cpp">#include&lt;iostream&gt;
#include&lt;string&gt;
#include&lt;vector&gt;
using namespace std;
void main()
{
inti=0;
vector&lt;int&gt; v;  //定义一个vector容器 v
 
for(i=0;i&lt;10;i++)
v.push_back(i); // 元素放进vector中
 
    for(i=0;i&lt;v.size();i++)
cout&lt;&lt;v[i]&lt;&lt;" ";  //输出每个元素
cout&lt;&lt;endl;
}
 
/// 你也可以用v.begin()与v.end()来得到vector开始的和结束的元素地址的指针位置
 
vector&lt;int&gt;::iteratoriter;
for(iter=v.begin();iter!=v.end();iter++)
cout&lt;&lt;*iter&lt;&lt;endl;
 
//对于二维vector的定义
 定义一个10个vector元素，并对每个vector赋值1-10
 
 #include&lt;vector&gt;
 using namespace std;
 void main()
 {
         inti=0,j=0;
         vector&lt;vector&lt;int&gt;&gt;array(10,vetcor&lt;int&gt;(0));  //定义一个二维动态数组，有10行每一行使用一个vector储存这一行数据
       //所以每一行的长度是可以变化的，之所以用到vector&lt;int&gt;(0)是对vector的初始化 否则不能对vector存入元素
       
       for(j=0;j&lt;10;j++)
for(i=0;i&lt;9;i++)
{
array[j].push_back(i);   //意思应该为对与array【i（相当于有几个vector元素）】同时一个vector含有10个元素
}
for(j=0;j&lt;10;j++)
for(i=0;i&lt;array[j].size();i++)
cout&lt;&lt;array[j][i]&lt;&lt;"";
cout&lt;&lt;endl;
}</code></pre> 
 <br> 
 <br> 
 <br> 
</div> 
<div> 
 <br> 
</div> 
<div> 
 <br> 
</div> 
<div> 
 <pre><code class="language-cpp">// 定义一个行列都是变化的数组
 
#include&lt;iostream&gt;
#include&lt;vector&gt;
using namespace std;
int main()
{
inti=0,j=0;
vector&lt;vector&lt;int&gt;&gt;array;
 
vector&lt;int&gt;line;
 
for(j=0;j&lt;10;j++)
{
array.push_back(line); //只有初始化之后才能存入元素
for(i=0;i&lt;array[j].size();i++)
cout&lt;&lt;array[j][i]&lt;&lt;"";
}
cout&lt;&lt;endl;
}
 
#include&lt;vector&gt;
using namespace std;
int main()
{
vector&lt;int&gt;arr;
arr.push_back(6);
arr.push_back(8);
arr.push_back(3);
arr.push_back(8);
for(vector&lt;int&gt;::iteratorit=arr.begin();it!=arr.end();)
{
if(*it==8)
it=arr.erase(it); //删除当前为8的元素
else
++it;   //不为8的化迭代器指向下一个地址
cout&lt;&lt;"AFTERremove 8:\n";
for(vector&lt;int&gt;::iteratorit=arr.begin();it&lt;arr.end();++it)
cout&lt;&lt;*it&lt;&lt;"";
cout&lt;&lt;endl;
}







Upper_bound(p+1,p+1+n,n)（大于该元素的第一个元素的坐标）  找到的东西是n元素所在的下标 概念表示为（p+l）
要转换为该元素的下标应该减去 p+1 即为为该元素所在的下标

</code></pre> 
 <br> 
 <br> 
</div> 
<div> 
 <br> 
</div> 
<div> 
 <br> 
</div> 
<div>
  程序总结： 
</div> 
<div> 
 <pre><code class="language-cpp">#include&lt;iostream&gt;
#include&lt;set&gt;
using namespace std;
void print(set&lt;int&gt;set_int)
{
	set&lt;int&gt;::iterator it=set_int.begin();
	for(;it!=set_int.end();it++)
		cout&lt;&lt;*it&lt;&lt;" ";           //循环输出  set容器里面的元素是被排好序之后进行的输出 ！！！！！重要！！！！

	cout&lt;&lt;endl;
}
int main()
{
	int num[4]={1,2,3,4};
	set&lt;int&gt;set_int(num,num+4);

	set_int.insert(5);  //代表了插入一个元素 并且输出set集合里面的值
                2,在pos位置之前插入value，返回新元素位置，但不一定能插入成功
			    //iterator insert(&amp;pos, value)

	print(set_int);

	set_int.insert(5);
	print(set_int);

	//元素删除

	set_int.erase(3);//1. 移除set容器中的所有为3的元素值 并返回元素的个数
                     //2.void erase(&amp;pos)   //移除pos位置上的元素 无返回值
                     //3.void erase（&amp;first，&amp;last） 移除迭代区间【&amp;first,last) 内的元素 无返回值
					//4.void clear();   移除set容器中的所有元素
	print(set_int);

	//元素查找
			//count(value)返回set对象内元素之为value的元素个数
			//iterator find(value)返回value所在位置，找不到value将返回end（）；
			//lower_bound(value)表示返回大于等于value的第一个元素的下标    upper_bound(value), qual_range(value);

	int a[5]={8,4,5,5,5};       //  当你的数组中有重复的元素时放入set容器输出 直接将重复的删除
	set&lt;int&gt;v4(a,a+5);
	print(v4);
	//--------------以下查找函数  返回的值的下标 是不对的！！！！！！！！ 建议先不使用该函数-------------
	set&lt;int&gt;::iterator it;
	it=v4.find(5);    //it为5所在下标的位置
	cout&lt;&lt;*it&lt;&lt;endl;         //因为it是一个迭代器（指针） 所以需要加一个  *   表示该指针指向变量的值

	set&lt;int&gt;::iterator q;
	q=set_int.find(2);      //搞不懂输出的是麻子
		cout&lt;&lt;*q&lt;&lt;endl;
	q=set_int.find(8);       // 同上
		cout&lt;&lt;*q&lt;&lt;endl;
    //------------- 截至到以上是查找函数  ------------


 	return 0;
}</code></pre> 
 <br> 
 <br> 
</div> 
<div> 
 <br> 
</div> 
<div> 
 <br> 
</div>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/56cf972b93c3794454b02f172621e667/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">信息论实验-信源编码算法 (Huffman and Shannonn Fano编码C&#43;&#43;实现)</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/efaf880ff24a94e25787a66d83e3a904/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">sql语句表关联</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>