<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>ioctl函数详细说明 - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="ioctl函数详细说明" />
<meta property="og:description" content="本函数影响由fd 参数引用的一个打开的文件。
#include&lt;unistd.h&gt;
int ioctl( int fd, int request, .../* void *arg */ );
返回0 ：成功 -1 ：出错
第三个参数总是一个指针，但指针的类型依赖于request 参数。
我们可以把和网络相关的请求划分为6 类：
套接口操作
文件操作
接口操作
ARP 高速缓存操作
路由表操作
流系统
下表列出了网络相关ioctl 请求的request 参数以及arg 地址必须指向的数据类型：
类别
Request
说明
数据类型
套
接
口
SIOCATMARK
SIOCSPGRP
SIOCGPGRP
是否位于带外标记
设置套接口的进程ID 或进程组ID
获取套接口的进程ID 或进程组ID
int
int
int
文
件
FIONBIN
FIOASYNC
FIONREAD
FIOSETOWN
FIOGETOWN
设置/ 清除非阻塞I/O 标志
设置/ 清除信号驱动异步I/O 标志
获取接收缓存区中的字节数
设置文件的进程ID 或进程组ID
获取文件的进程ID 或进程组ID" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/18984f59b145a3f288c6c1d1553661ec/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-03-24T16:50:18+08:00" />
<meta property="article:modified_time" content="2022-03-24T16:50:18+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">ioctl函数详细说明</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p>本函数影响由fd 参数引用的一个打开的文件。</p> 
<p></p> 
<p>#include&lt;unistd.h&gt;</p> 
<p>int ioctl( int fd, int request, .../* void *arg */ );</p> 
<p>返回0 ：成功    -1 ：出错</p> 
<p></p> 
<p>第三个参数总是一个指针，但指针的类型依赖于request 参数。</p> 
<p>我们可以把和网络相关的请求划分为6 类：</p> 
<p>套接口操作</p> 
<p>文件操作</p> 
<p>接口操作</p> 
<p>ARP 高速缓存操作</p> 
<p>路由表操作</p> 
<p>流系统</p> 
<p>下表列出了网络相关ioctl 请求的request 参数以及arg 地址必须指向的数据类型：</p> 
<p></p> 
<table border="0" cellpadding="0" cellspacing="0" style="width:576px;"><tbody><tr><td style="vertical-align:top;"> <p>类别</p> </td><td style="vertical-align:top;"> <p>Request</p> </td><td style="vertical-align:top;"> <p>说明</p> </td><td style="vertical-align:top;"> <p>数据类型</p> </td></tr><tr><td style="vertical-align:top;"> <p><strong>套</strong></p> <p><strong>接</strong></p> <p><strong>口</strong></p> </td><td style="vertical-align:top;"> <p>SIOCATMARK</p> <p>SIOCSPGRP</p> <p>SIOCGPGRP</p> </td><td style="vertical-align:top;"> <p>是否位于带外标记</p> <p>设置套接口的进程ID 或进程组ID</p> <p>获取套接口的进程ID 或进程组ID</p> </td><td style="vertical-align:top;"> <p>int</p> <p>int</p> <p>int</p> </td></tr><tr><td style="vertical-align:top;"> <p></p> <p><strong>文</strong></p> <p><strong> </strong></p> <p><strong>件</strong></p> <p></p> <p></p> </td><td style="vertical-align:top;"> <p>FIONBIN</p> <p>FIOASYNC</p> <p>FIONREAD</p> <p>FIOSETOWN</p> <p>FIOGETOWN</p> <p></p> </td><td style="vertical-align:top;"> <p>设置/ 清除非阻塞I/O 标志</p> <p>设置/ 清除信号驱动异步I/O 标志</p> <p>获取接收缓存区中的字节数</p> <p>设置文件的进程ID 或进程组ID</p> <p>获取文件的进程ID 或进程组ID</p> </td><td style="vertical-align:top;"> <p>int</p> <p>int</p> <p>int</p> <p>int</p> <p>int</p> </td></tr><tr><td style="vertical-align:top;"> <p></p> <p></p> <p></p> <p></p> <p><strong>接</strong></p> <p><strong>口</strong></p> <p><strong> </strong></p> <p><strong> </strong></p> <p><strong> </strong></p> <p><strong> </strong></p> <p><strong> </strong></p> <p><strong> </strong></p> <p><strong> </strong></p> <p><strong> </strong></p> <p><strong> </strong></p> <p></p> </td><td style="vertical-align:top;"> <p>SIOCGIFCONF</p> <p>SIOCSIFADDR</p> <p>SIOCGIFADDR</p> <p>SIOCSIFFLAGS</p> <p>SIOCGIFFLAGS</p> <p>SIOCSIFDSTADDR</p> <p>SIOCGIFDSTADDR</p> <p>SIOCGIFBRDADDR</p> <p>SIOCSIFBRDADDR</p> <p>SIOCGIFNETMASK</p> <p>SIOCSIFNETMASK</p> <p>SIOCGIFMETRIC</p> <p>SIOCSIFMETRIC</p> <p>SIOCGIFMTU</p> <p>SIOCxxx</p> </td><td style="vertical-align:top;"> <p>获取所有接口的清单</p> <p>设置接口地址</p> <p>获取接口地址</p> <p>设置接口标志</p> <p>获取接口标志</p> <p>设置点到点地址</p> <p>获取点到点地址</p> <p>获取广播地址</p> <p>设置广播地址</p> <p>获取子网掩码</p> <p>设置子网掩码</p> <p>获取接口的测度</p> <p>设置接口的测度</p> <p>获取接口MTU</p> <p>（还有很多取决于系统的实现）</p> </td><td style="vertical-align:top;"> <p>struct ifconf</p> <p>struct ifreq</p> <p>struct ifreq</p> <p>struct ifreq</p> <p>struct ifreq</p> <p>struct ifreq</p> <p>struct ifreq</p> <p>struct ifreq</p> <p>struct ifreq</p> <p>struct ifreq</p> <p>struct ifreq</p> <p>struct ifreq</p> <p>struct ifreq</p> <p>struct ifreq</p> </td></tr><tr><td style="vertical-align:top;"> <p></p> <p><strong>ARP</strong></p> </td><td style="vertical-align:top;"> <p>SIOCSARP</p> <p>SIOCGARP</p> <p>SIOCDARP</p> </td><td style="vertical-align:top;"> <p>创建/ 修改ARP 表项</p> <p>获取ARP 表项</p> <p>删除ARP 表项</p> </td><td style="vertical-align:top;"> <p>struct arpreq</p> <p>struct arpreq</p> <p>struct arpreq</p> </td></tr><tr><td style="vertical-align:top;"> <p><strong>路</strong></p> <p><strong>由</strong></p> </td><td style="vertical-align:top;"> <p>SIOCADDRT</p> <p>SIOCDELRT</p> </td><td style="vertical-align:top;"> <p>增加路径</p> <p>删除路径</p> </td><td style="vertical-align:top;"> <p>struct rtentry</p> <p>struct rtentry</p> </td></tr><tr><td style="vertical-align:top;"> <p><strong>流</strong></p> </td><td style="vertical-align:top;"> <p>I_xxx</p> </td><td style="vertical-align:top;"> <p></p> </td><td style="vertical-align:top;"> <p></p> </td></tr></tbody></table> 
<p></p> 
<p></p> 
<p><strong>套接口操作：</strong></p> 
<p>明确用于套接口操作的ioctl 请求有三个, 它们都要求ioctl 的第三个参数是指向某个整数的一个指针。</p> 
<p></p> 
<p>SIOCATMARK:    如果本套接口的的度指针当前位于带外标记，那就通过由第三个参数指向的整数返回一个非0 值；否则返回一个0 值。POSIX 以函数sockatmark 替换本请求。</p> 
<p>SIOCGPGRP ：       通过第三个参数指向的整数返回本套接口的进程ID 或进程组ID ，该ID 指定针对本套接口的SIGIO 或SIGURG 信号的接收进程。本请求和fcntl 的F_GETOWN 命令等效，POSIX 标准化的是fcntl 函数。</p> 
<p>SIOCSPGRP ：     把本套接口的进程ID 或者进程组ID 设置成第三个参数指向的整数，该ID 指定针对本套接口的SIGIO 或SIGURG 信号的接收进程，本请求和fcntl 的F_SETOWN 命令等效，POSIX 标准化的是fcntl 操作。</p> 
<p></p> 
<p><strong>文件操作：</strong></p> 
<p>以下5 个请求都要求ioctl 的第三个参数指向一个整数。</p> 
<p></p> 
<p>FIONBIO ：        根据ioctl 的第三个参数指向一个0 或非0 值分别清除或设置本套接口的非阻塞标志。本请求和O_NONBLOCK 文件状态标志等效，而该标志通过fcntl 的F_SETFL 命令清除或设置。</p> 
<p></p> 
<p>FIOASYNC ：      根据iocl 的第三个参数指向一个0 值或非0 值分别清除或设置针对本套接口的信号驱动异步I/O 标志，它决定是否收取针对本套接口的异步I/O 信号（SIGIO ）。本请求和O_ASYNC 文件状态标志等效，而该标志可以通过fcntl 的F_SETFL 命令清除或设置。</p> 
<p></p> 
<p>FIONREAD ：     通过由ioctl 的第三个参数指向的整数返回当前在本套接口接收缓冲区中的字节数。本特性同样适用于文件，管道和终端。</p> 
<p></p> 
<p>FIOSETOWN ：    对于套接口和SIOCSPGRP 等效。</p> 
<p>FIOGETOWN ：    对于套接口和SIOCGPGRP 等效。</p> 
<p></p> 
<p>接口配置：</p> 
<p>得到系统中所有接口由SIOCGIFCONF 请求完成，该请求使用ifconf 结构，ifconf 又使用ifreq</p> 
<p>结构，如下所示：</p> 
<p></p> 
<p>Struct ifconf{<!-- --></p> 
<p>    int ifc_len;                 // 缓冲区的大小</p> 
<p>    union{<!-- --></p> 
<p>        caddr_t ifcu_buf;        // input from user-&gt;kernel</p> 
<p>        struct ifreq *ifcu_req;    // return of structures returned</p> 
<p>    }ifc_ifcu;</p> 
<p>};</p> 
<p></p> 
<p>#define  ifc_buf  ifc_ifcu.ifcu_buf    //buffer address</p> 
<p>#define  ifc_req  ifc_ifcu.ifcu_req    //array of structures returned</p> 
<p></p> 
<p>#define  IFNAMSIZ  16</p> 
<p></p> 
<p>struct ifreq{<!-- --></p> 
<p>    char ifr_name[IFNAMSIZ];           // interface name, e.g., “le0”</p> 
<p>    union{<!-- --></p> 
<p>        struct sockaddr ifru_addr;</p> 
<p>        struct sockaddr ifru_dstaddr;</p> 
<p>        struct sockaddr ifru_broadaddr;</p> 
<p>        short ifru_flags;</p> 
<p>        int ifru_metric;</p> 
<p>        caddr_t ifru_data;</p> 
<p>    }ifr_ifru;</p> 
<p>};</p> 
<p></p> 
<p>#define ifr_addr     ifr_ifru.ifru_addr            // address</p> 
<p>#define ifr_dstaddr   ifr_ifru.ifru_dstaddr         // otner end of p-to-p link</p> 
<p>#define ifr_broadaddr ifr_ifru.ifru_broadaddr    // broadcast address</p> 
<p>#define ifr_flags     ifr_ifru.ifru_flags        // flags</p> 
<p>#define ifr_metric    ifr_ifru.ifru_metric      // metric</p> 
<p>#define ifr_data      ifr_ifru.ifru_data        // for use by interface</p> 
<p></p> 
<p>再调用ioctl 前我们必须先分撇一个缓冲区和一个ifconf 结构，然后才初始化后者。如下图</p> 
<p>展示了一个ifconf 结构的初始化结构，其中缓冲区的大小为1024 ，ioctl 的第三个参数指向</p> 
<p>这样一个ifconf 结构。</p> 
<table align="left" border="0" cellpadding="0" cellspacing="0"><tbody><tr><td style="vertical-align:top;"> <p>ifc_len</p> </td></tr><tr><td style="vertical-align:top;"> <p> Ifc_buf</p> </td></tr></tbody></table> 
<p>1024</p> 
<p>---------------------&gt; 缓存</p> 
<p></p> 
<p></p> 
<p>假设内核返回2 个ifreq 结构，ioctl 返回时通过同一个ifconf 结构缓冲区填入了那2 个ifreq 结构，ifconf 结构的ifc_len 成员也被更新，以反映存放在缓冲区中的信息量</p> 
<p>一般来讲ioctl在用户程序中的调用是：</p> 
<p>ioctl(int fd,int command, (char*)argstruct)</p> 
<p>ioctl调用与网络编程有关（本文只讨论这一点），文件描述符fd实际上是由socket()系统调用返回的。参数command的取值由/usr/include/linux/sockios.h 所规定。这些command的由于功能的不同，可分为以下几个小类：<br> • 改变路由表 (例如 SIOCADDRT, SIOCDELRT), <br> • 读/更新 ARP/RARP 缓存(如：SIOCDARP, SIOCSRARP), <br> • 一般的与网络接口有关的(例如 SIOCGIFNAME, SIOCSIFADDR 等等) <br> 在 Gooodies目录下有很多样例程序展示了如何使用ioctl。当你看这些程序时，注意参数argstruct是与参数command相关的。例如，与 路由表相关的ioctl使用rtentry这种结构，rtentry定义在/usr/include/linux/route.h（参见例子 adddefault.c）。与ARP有关的ioctl调用使用arpreq结构，arpreq定义在/usr/include/linux /if_arp.h（参见例子arpread.c）</p> 
<p>与网络接口有关的ioctl调 用使用的command参数通常看起来像SIOCxIFyyyy的形式，这里x要 么是S（设定set，写write），要么是G（得到get，读read）。在getifinfo.c程序中就使用了这种形式的command参数来读 IP地址，硬件地址，广播地址和得到与网络接口有关的一些标志（flag）。在这些ioctl调用中，第三个参数是ifreq结构，它在/usr /include/linux/if.h中定义。在某些情况下， ioctrl调用可能会使用到在sockios.h之外的新的定义，例如，WaveLAN无线网络卡会保</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/78a933e1275431dd69ce86c6e9e28585/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">SpringBoot &#43; MabitsPlus &#43; 枚举配置</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/a61285064eef18ca8846d019f3d6045e/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">软考种类有哪些？</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>