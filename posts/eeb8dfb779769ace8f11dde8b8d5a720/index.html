<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>typescript从0到1全过程总结&#43;vue整合typescript - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="typescript从0到1全过程总结&#43;vue整合typescript" />
<meta property="og:description" content="TypeScript 是 JavaScript的一个超集 1. 下载：
npm install typescript -g 2. 生成配置文件（tsconfig.json）： 解决VsCode 红色下滑线警告
tsc --init
3. 运行：
tsc ts文件名.ts
可通过 -w 实时监听ts文件的改变 ，执行tsc ： tsc ts文件名.ts -w
注意事项：
TS 需要编译成 JS 才能被浏览器所解析即使typescript编译报错，也可以生成js文件 数据类型： 字符串类型：
数字类型：
布尔类型：
数组类型：
元祖类型：
枚举类型：
any类型：（任何类型）
void类型：（空类型：用于函数是否有返回值）
undefined 和 null 类型：
联合类型：（可以是指定中的任何一种类型）
类型推论：（定义变量时没有赋值则推论为any类型，赋值则为初始时的类型）
类型断言：（当值的类型不确定时，手动指定一个值的类型）
函数 函数的参数
可选参数： （？）
剩余参数：（...）
函数的重载：
接口：（行为的抽象，对数据的约束） 接口的定义： interface 接口名 {} 规范的接口名： I接口名首字母大写 （I：interface）
实现接口： implements 接口名
定义接口时，只需要声明即可，不包含具体的实现实现接口时，必须实现接口中的内容 应用场景：当一个东西，必须有一个或多个功能时，即可定义为一个接口。
例如：打印机（每台打印机都有一个打印功能）
/** 定义一个打印机接口 * 内部存在一个打印功能（函数） 只需要声明，不包含具体实现 */ interface Iprint { printing(mes: string): string } // 对接口的继承 interface Ipeintmes extends Iprint { getMes(mes: string): void } // 实现 Ipeintmes 接口 ，必须实现 Ipeintmes接口中的方法和继承至 Iprint接口中的方法 class Printe implements Ipeintmes { printing(mes: string): string { return mes } getMes(mes: string) { console." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/eeb8dfb779769ace8f11dde8b8d5a720/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2019-12-03T17:57:00+08:00" />
<meta property="article:modified_time" content="2019-12-03T17:57:00+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">typescript从0到1全过程总结&#43;vue整合typescript</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <h2>TypeScript 是 JavaScript的一个超集</h2> 
<p>1. 下载：</p> 
<blockquote> 
 <p><strong>npm install typescript -g  </strong></p> 
</blockquote> 
<p>2. 生成配置文件（tsconfig.json）：<span style="color:#f33b45;"> <strong>解决VsCode 红色下滑线警告</strong></span></p> 
<blockquote> 
 <p><strong>tsc --init</strong></p> 
</blockquote> 
<p>3. 运行：</p> 
<blockquote> 
 <p><strong>tsc ts文件名.ts</strong></p> 
</blockquote> 
<p><span style="color:#f33b45;">可通过 -w 实时监听ts文件的改变 ，执行tsc ： <strong>tsc ts文件名.ts -w</strong></span></p> 
<p> </p> 
<p><strong><span style="color:#f33b45;">注意事项：</span></strong></p> 
<ol><li><strong><span style="color:#f33b45;">TS 需要编译成 JS 才能被浏览器所解析</span></strong></li><li><span style="color:#f33b45;"><strong>即使typescript编译报错，也可以生成js文件</strong></span></li></ol> 
<p> </p> 
<hr> 
<h3>数据类型：</h3> 
<p> </p> 
<p><strong>字符串类型：</strong></p> 
<p><strong><img alt="" class="has" height="105" src="https://images2.imgbox.com/50/92/obCcqJRL_o.png" width="605"></strong></p> 
<p><strong>数字类型：</strong></p> 
<p><strong><img alt="" class="has" height="70" src="https://images2.imgbox.com/14/6c/itS2Wv3p_o.png" width="308"></strong></p> 
<p><strong>布尔类型：</strong></p> 
<p><strong><img alt="" class="has" height="69" src="https://images2.imgbox.com/18/b8/BZimBlRb_o.png" width="358"></strong></p> 
<p><strong>数组类型：</strong></p> 
<p><strong><img alt="" class="has" src="https://images2.imgbox.com/95/c5/lBMTAtwe_o.png"></strong></p> 
<p><strong>元祖类型：</strong></p> 
<p><strong><img alt="" class="has" height="139" src="https://images2.imgbox.com/f7/4f/7MIbeNNY_o.png" width="637"></strong></p> 
<p> <strong>枚举类型：</strong></p> 
<p><strong><img alt="" class="has" src="https://images2.imgbox.com/df/ad/I9cLYYyb_o.png"></strong></p> 
<p><strong>any类型：（任何类型）</strong></p> 
<p><img alt="" class="has" height="130" src="https://images2.imgbox.com/2e/67/uHmbSFxi_o.png" width="405"></p> 
<p> <strong>void类型：（空类型：用于函数是否有返回值）</strong></p> 
<p><img alt="" class="has" height="323" src="https://images2.imgbox.com/97/8b/dmChoJVe_o.png" width="465"></p> 
<p><strong>undefined 和 null 类型：</strong></p> 
<p><img alt="" class="has" height="71" src="https://images2.imgbox.com/34/7d/430Vx8Xd_o.png" width="801"></p> 
<p><strong>联合类型：（可以是指定中的任何一种类型）</strong></p> 
<p><img alt="" class="has" height="163" src="https://images2.imgbox.com/57/47/BKxGBEUT_o.png" width="479"></p> 
<p><strong>类型推论：（定义变量时没有赋值则推论为any类型，赋值则为初始时的类型）</strong></p> 
<p><img alt="" class="has" height="266" src="https://images2.imgbox.com/3f/31/BJ0CoG1F_o.png" width="770"></p> 
<p><strong>类型断言：（当值的类型不确定时，手动指定一个值的类型）</strong></p> 
<p><img alt="" class="has" height="667" src="https://images2.imgbox.com/d3/93/EpDCZHQD_o.png" width="613"></p> 
<hr> 
<h3>函数</h3> 
<p> </p> 
<p><strong>函数的参数</strong></p> 
<p><img alt="" class="has" height="157" src="https://images2.imgbox.com/59/35/lICuY8Nd_o.png" width="539"></p> 
<p><strong>可选参数： （？）</strong></p> 
<p><img alt="" class="has" height="319" src="https://images2.imgbox.com/5c/43/mKJaT6zg_o.png" width="693"></p> 
<p><strong>剩余参数：（...）</strong></p> 
<p><img alt="" class="has" height="275" src="https://images2.imgbox.com/1c/23/oaJpfyMq_o.png" width="790"></p> 
<p><strong>函数的重载：</strong></p> 
<p><img alt="" class="has" height="362" src="https://images2.imgbox.com/3a/57/yi0fyNif_o.png" width="628"></p> 
<hr> 
<h3>接口：（行为的抽象，对数据的约束）</h3> 
<p><span style="color:#f33b45;">接口的定义： interface 接口名 {}           <strong>规范的接口名： I接口名首字母大写 （I：interface）</strong></span></p> 
<p><span style="color:#f33b45;">实现接口： implements 接口名</span></p> 
<ol><li>定义接口时，只需要声明即可，不包含具体的实现</li><li>实现接口时，必须实现接口中的内容</li></ol> 
<p><strong><span style="color:#f33b45;">应用场景：当一个东西，必须有一个或多个功能时，即可定义为一个接口。</span></strong></p> 
<p><strong><span style="color:#f33b45;">例如：打印机（每台打印机都有一个打印功能）</span></strong></p> 
<pre class="has"><code class="language-java">/** 定义一个打印机接口
 * 内部存在一个打印功能（函数） 只需要声明，不包含具体实现
 */
interface Iprint {
  printing(mes: string): string
}

// 对接口的继承
interface Ipeintmes extends Iprint {
  getMes(mes: string): void
}
// 实现 Ipeintmes 接口 ，必须实现 Ipeintmes接口中的方法和继承至 Iprint接口中的方法
class Printe implements Ipeintmes {
  printing(mes: string): string {
    return mes
  }
  getMes(mes: string) {
    console.log(mes)
  }
}
var printe = new Printe()
printe.getMes('HP1001-1')

// ----------------------- 对类的约束------------------------------
/**实现接口 : implements 接口名
 * 必须实现接口中的内容
 * (如果要实现多个接口，在接口名称后面逗号分隔即可)
 */
class Printer implements Iprint {
  printing(mes: string): string {
    return '打印了' + mes
  }
}

var pri = new Printer()
var value = pri.printing('简历')
console.log(value)

// ---------------------- 对函数的约束 ---------------------------
/** function 两个参数，第一个参数是字符串类型，第二个参数是数字类型，返回值是布尔类型 */
interface Ifunc {
  (a: string, b: number): boolean
}
var fun1: Ifunc
fun1 = (a: string, b: number) =&gt; {
  return false
}
// 函数 fun1 参数不能改变类型
// fun1 = (a: number, b: number) =&gt; {   无法编译
//   return false
// }

// -------------------- 对数组的约束 ---------------------------
interface Iarr {
  [index: number]: string
}
var array: Iarr
array = ['12', '2', '3']
// array = ['12', '2', '3', 1]  数组只能是字符串类型  无法编译

// ------------------- 对json 的约束 --------------------------
interface Ijson {
  name: string
  readonly age: number // 只读属性 readonly
  email?: string // 可选属性 ?
}
function showJson(data: Ijson) {
  // data.age = 16   age 为只读属性，不可被更改   无法编译
  console.log(JSON.stringify(data))
}
showJson({ name: 'vs', age: 18 })
showJson({ name: 'vs', age: 18, email: '110' })
// showJson({ name: 'vs', age: '18' })  age为number类型 无法编译
</code></pre> 
<hr> 
<h3>类</h3> 
<p> </p> 
<p><strong>类的定义： （class）</strong></p> 
<p><img alt="" class="has" height="323" src="https://images2.imgbox.com/95/ee/cwzydwDg_o.png" width="767"></p> 
<p><strong>类的继承：（extend） 继承与上面的Person类</strong></p> 
<p><img alt="" class="has" height="355" src="https://images2.imgbox.com/ee/d4/Rse7yVpu_o.png" width="961"></p> 
<p>使用：</p> 
<pre class="has"><code class="language-javascript">var stu1 = new Student(1)
console.log(stu1.getMes())</code></pre> 
<p> </p> 
<p><strong>访问修饰符：</strong></p> 
<ul><li><strong>public（共有的/默认） 可以在任意范围内使用</strong></li><li><strong>private（私有的）只能在当前类内部使用</strong></li><li><strong>protected（受保护的）只能在父类或继承父类的子类内部使用</strong></li></ul> 
<pre class="has"><code class="language-java">class Father {
  public name: string
  private age: number
  protected email: string
  constructor(name: string, age: number, email: string) {
    this.name = name
    this.age = age
    this.email = email
  }
  getMyMes() {
    console.log(
      'name:' + this.name + ',age:' + this.age + ',email:' + this.email
    )
  }
}
class Child extends Father {
  getMes() {
    console
      .log
      //   'name:' + this.name + ',age:' + this.age + ',email:' + this.email
      // this.age 无法编译
      ()
  }
}
var child = new Child('吕布', 18, '123456@qq.com')
console.log(child)
console.log(child.name)
// console.log(child.age) // age 为 私有属性，无法在Father类外部访问
// console.log(child.email) // email 为 受保护属性，无法在Father类与Child类外部访问</code></pre> 
<p> </p> 
<p><strong>静态属性和静态方法（当一个属性或方法不依赖与实例化出来的一个实例，即可使用静态）</strong></p> 
<p><img alt="" class="has" height="565" src="https://images2.imgbox.com/42/f5/LByPV2du_o.png" width="765"></p> 
<p> </p> 
<p><strong>多态：（同一个父类中的方法，不同子类有不同的实现）</strong></p> 
<pre class="has"><code class="language-java">class Animal {
  eat() {
    console.log('animal eat')
  }
}
class Cat extends Animal {
  eat() {
    console.log('猫吃鱼')
  }
}
class Dog extends Animal {
  eat() {
    console.log('狗吃骨头')
  }
}
var dog = new Dog()
dog.eat()
</code></pre> 
<p> </p> 
<p><strong>抽象类和抽象方法：</strong></p> 
<ol><li><strong>抽象类是提供其他类继承的基类（父类），不能直接被实例化</strong></li><li><strong>抽象方法只能包含在抽象类中，但是抽象类中可以包含抽象方法和非抽象方法</strong></li><li><strong>子类继承抽象类时，必须实现抽象类中的抽象方法（除非子类自身也是一个抽象类）</strong></li><li><strong>抽象方法只提供一个方法，没有具体的实现，如同接口一般</strong></li></ol> 
<p><strong><span style="color:#f33b45;">抽象类的定义 ： abstract class { }</span></strong></p> 
<pre class="has"><code class="language-java">abstract class Animal0 {
  abstract eat(): void // 抽象方法，只提供了一个方法，并没有具体实现
  run() {
    console.log('run run run ')
  }
}
class Rabbit extends Animal0 {
  eat() {
    console.log('兔子吃草')
  }
}
class Cattle extends Animal0 {
  eat() {
    console.log('牛吃草')
  }
}
var rabbit = new Rabbit()
rabbit.eat()
var cattle = new Cattle()
cattle.eat()</code></pre> 
<hr> 
<h3>内置对象</h3> 
<pre class="has"><code class="language-javascript">/** JS的内置对象
 * Boolean
 * Number
 * String
 * Date
 * RegExp
 * Error
 */
// 大写的声明类型 是 需要 new 的一个对象
let b: Boolean = new Boolean(1)
// let b1:boolean = new Boolean(0) // 编译失败
let n: Number = new Number(3)
let s: String = new String('111')
let d: Date = new Date()
let r: RegExp = /^1/
let e: Error = new Error('error message')

/**DOM 和 BOM 的内置对象*/
const div: HTMLElement = document.getElementById('test')
const divs: NodeList = document.querySelectorAll('p')
document.addEventListener(
  'click',
  (event: MouseEvent) =&gt; {
    console.log(event.target)
  },
  false
)
const fragment: DocumentFragment = document.createDocumentFragment()
</code></pre> 
<hr> 
<h3>声明文件</h3> 
<ul><li><span style="color:#f33b45;"> 当使用第三方库时，需要引用它的声明文件，才能获得对应的代码补全、接口提示等功能</span></li><li><span style="color:#f33b45;"> 声明语句：如果需要ts对新的语法进行检查，需要加载对应的类型说明代码</span></li><li><span style="color:#f33b45;"> declare var jQuery:(selector:string) =&gt; any</span></li><li><span style="color:#f33b45;"> 声明文件：把声明语句放到一个单独的文件(jQuery.d.ts)中，ts会自动解析到项目中所有的声明文件</span></li><li><span style="color:#f33b45;">下载声明文件 npm install @types/jquery(第三方库名) --save-dev</span></li></ul> 
<p><img alt="" class="has" height="166" src="https://images2.imgbox.com/4d/48/6tlJ3VZG_o.png" width="819"></p> 
<p><img alt="" class="has" height="187" src="https://images2.imgbox.com/9d/0c/gAHacw0C_o.png" width="400"></p> 
<hr> 
<h3>泛型</h3> 
<p><strong><span style="color:#f33b45;">泛型是指 在定义函数、接口或类的时候，不预先指定具体的类型，而在使用的使用再指定类型中的一种特性</span></strong></p> 
<p><span style="color:#f33b45;"><strong>定义泛型 ：  &lt; T &gt; </strong>                T(泛型名称，默认统一为T)</span></p> 
<p><span style="color:#f33b45;"><strong>使用泛型</strong></span></p> 
<p> </p> 
<p><strong>泛型函数：</strong></p> 
<pre class="has"><code class="language-javascript">function itemValue&lt;T&gt;(arr: T[]): void {
  for (var item of arr) {
    console.log(item)
  }
}
itemValue&lt;number&gt;([11, 22, 33])  // 指定泛型为number ；函数中的参数，数组中的每一个元素必须是数字类型
itemValue(['aa', 'bb', 'cc'])</code></pre> 
<p> </p> 
<p><strong>泛型类：</strong></p> 
<pre class="has"><code class="language-javascript">class ArrList&lt;T&gt; {
  list: T[] = []
  add(val: T): void {
    this.list.push(val)
  }
}
var arrlist = new ArrList()
arrlist.add(1)
arrlist.add(23)
console.log(arrlist)</code></pre> 
<p> </p> 
<p><strong>泛型接口：</strong></p> 
<pre class="has"><code class="language-javascript">interface Iport&lt;T&gt; {
  (x: T, y: T): T
}
var iport1: Iport&lt;number&gt;
iport1 = function(x: number, y: number) {
  return x + y
}
console.log(iport1(6, 1))
// console.log(iport1())
</code></pre> 
<hr> 
<h3>命名空间：</h3> 
<ol><li>为了避免各种变量命名冲突，可将相似功能的函数、类、接口等放置到命名空间</li><li>定义命名空间 <span style="color:#f33b45;">namespace </span>名称 { }</li><li>访问命名空间内部的成员，需要 export 将其导出</li></ol> 
<p><strong>模块定义：</strong></p> 
<pre class="has"><code class="language-javascript">export namespace A {
  interface IAnimal {
    name: string
    eat(): void
  }
  export class Dog implements IAnimal {
    name: string
    constructor(name: string) {
      this.name = name
    }
    eat() {
      console.log(`${this.name}啃骨头`)
    }
  }
  export class Cat implements IAnimal {
    name: string
    constructor(name: string) {
      this.name = name
    }
    eat() {
      console.log(`${this.name}吃鱼`)
    }
  }
}
export namespace B {
  interface IAnimal {
    name: string
    eat(): void
  }
  export class Dog implements IAnimal {
    name: string
    constructor(name: string) {
      this.name = name
    }
    eat() {
      console.log(`${this.name}吃肉`)
    }
  }
  export class Cat implements IAnimal {
    name: string
    constructor(name: string) {
      this.name = name
    }
    eat() {
      console.log(`${this.name}吃老鼠`)
    }
  }
}
</code></pre> 
<p><strong>使用模块：</strong></p> 
<p><img alt="" class="has" height="256" src="https://images2.imgbox.com/c2/46/oY7d1AuP_o.png" width="516"></p> 
<p> </p> 
<hr> 
<h3>Vue-Cli3创建typescript项目：</h3> 
<p><strong><span style="color:#f33b45;">Vue-cli3创建的TypeScript 项目 针对于 vue-property-decorator（非Vue官方）搭建</span></strong></p> 
<p><strong><span style="color:#f33b45;">而 vue-property-decorator 完全依赖于 vue-class-component（Vue官方）搭建。</span></strong></p> 
<p><strong><span style="color:#f33b45;"><a href="https://github.com/vuejs/vue-class-component">vue-class-component</a>        </span></strong></p> 
<p><strong><span style="color:#f33b45;"><a href="https://github.com/kaorun343/vue-property-decorator">vue-property-decorator</a></span></strong></p> 
<p><img alt="" class="has" height="699" src="https://images2.imgbox.com/96/2b/k4YBbpHP_o.png" width="899"></p> 
<p> </p> 
<p><strong><span style="color:#f33b45;">vue-property-decorator在原基础上新增了十多个装饰器，具体可以看文档，已在上面贴出了文档地址链接</span></strong></p> 
<p><strong><span style="color:#f33b45;">这里只对个别经常用的做演示</span></strong></p> 
<p> </p> 
<p> </p> 
<p><strong>@Component  子组件的改变 （完全继承于vue-class-component的方式实现）</strong></p> 
<p><img alt="" class="has" height="307" src="https://images2.imgbox.com/3b/ba/rfTHCK3v_o.png" width="1134"></p> 
<p><strong>@Prop 父组件向子组件传值</strong></p> 
<p> <img alt="" class="has" height="531" src="https://images2.imgbox.com/78/41/8V2NbGau_o.png" width="1014"></p> 
<p><strong>@Watch  监听组件中的改变</strong></p> 
<p><img alt="" class="has" height="284" src="https://images2.imgbox.com/70/59/d8Q53dCx_o.png" width="1162"></p> 
<p><strong>@Emit  子组件向父组件传递事件，进行通信</strong></p> 
<p><img alt="" class="has" height="560" src="https://images2.imgbox.com/dc/3f/fGso4BEh_o.png" width="1131"></p> 
<p> </p> 
<p> </p> 
<p> </p> 
<p><a href="https://gitee.com/weiZhiXiang1219/typescriptDemo" rel="nofollow">代码源地址</a></p> 
<p> </p> 
<p> </p> 
<p> </p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/92ebce95f70547b9be4e193e9b336af2/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">【Android】蓝牙开发——经典蓝牙：配对与解除配对 &amp; 实现配对或连接时不弹出配对框</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/1193ec35f704a36da222b5d94a7fe21a/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">合天ctf类型做题规范（下）</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>