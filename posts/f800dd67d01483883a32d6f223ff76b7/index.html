<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Spring Boot优雅地处理404异常 - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Spring Boot优雅地处理404异常" />
<meta property="og:description" content="背景 在使用SpringBoot的过程中，你肯定遇到过404错误。比如下面的代码：
@RestController @RequestMapping(value = &#34;/hello&#34;) public class HelloWorldController { @RequestMapping(&#34;/test&#34;) public Object getObject1(HttpServletRequest request){ Response response = new Response(); response.success(&#34;请求成功...&#34;); response.setResponseTime(); return response; } } 当我们使用错误的请求地址（POST http://127.0.0.1:8888/hello/test1?id=98）进行请求时，会报下面的错误：
{ &#34;timestamp&#34;: &#34;2020-11-19T08:30:48.844&#43;0000&#34;, &#34;status&#34;: 404, &#34;error&#34;: &#34;Not Found&#34;, &#34;message&#34;: &#34;No message available&#34;, &#34;path&#34;: &#34;/hello/test1&#34; } 虽然上面的返回很清楚，但是我们的接口需要返回统一的格式，比如：
{ &#34;rtnCode&#34;:&#34;9999&#34;, &#34;rtnMsg&#34;:&#34;404 /hello/test1 Not Found&#34; } 这时候你可能会想有Spring的统一异常处理，在Controller类上加@RestControllerAdvice注解。但是这种做法并不能统一处理404错误。
404错误产生的原因 产生404的原因是我们调了一个不存在的接口，但是为什么会返回下面的json报错呢？我们先从Spring的源代码分析下。
{ &#34;timestamp&#34;: &#34;2020-11-19T08:30:48.844&#43;0000&#34;, &#34;status&#34;: 404, &#34;error&#34;: &#34;Not Found&#34;, &#34;message&#34;: &#34;No message available&#34;, &#34;path&#34;: &#34;/hello/test1&#34; } 为了代码简单起见，这边直接从DispatcherServlet的doDispatch方法开始分析。（如果不知道为什么要从这边开始，你还要熟悉下SpringMVC的源代码）。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/f800dd67d01483883a32d6f223ff76b7/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2021-05-06T17:38:03+08:00" />
<meta property="article:modified_time" content="2021-05-06T17:38:03+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Spring Boot优雅地处理404异常</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <h3 id="背景">背景</h3> 
<p>在使用SpringBoot的过程中，你肯定遇到过404错误。比如下面的代码：</p> 
<pre><code class="language-java">@RestController
@RequestMapping(value = "/hello")
public class HelloWorldController {
    @RequestMapping("/test")
    public Object getObject1(HttpServletRequest request){
        Response response = new Response();
        response.success("请求成功...");
        response.setResponseTime();
        return response;
    }
}</code></pre> 
<p>当我们使用错误的请求地址（POST <a href="http://127.0.0.1:8888/hello/test1?id=98%EF%BC%89%E8%BF%9B%E8%A1%8C%E8%AF%B7%E6%B1%82%E6%97%B6%EF%BC%8C%E4%BC%9A%E6%8A%A5%E4%B8%8B%E9%9D%A2%E7%9A%84%E9%94%99%E8%AF%AF%EF%BC%9A" rel="nofollow">http://127.0.0.1:8888/hello/test1?id=98）进行请求时，会报下面的错误：</a></p> 
<pre><code class="language-java">{
  "timestamp": "2020-11-19T08:30:48.844+0000",
  "status": 404,
  "error": "Not Found",
  "message": "No message available",
  "path": "/hello/test1"
}</code></pre> 
<p>虽然上面的返回很清楚，但是我们的接口需要返回统一的格式，比如：</p> 
<pre><code class="language-java">{
    "rtnCode":"9999",
    "rtnMsg":"404 /hello/test1 Not Found"
}</code></pre> 
<p>这时候你可能会想有Spring的统一异常处理，在Controller类上加@RestControllerAdvice注解。但是这种做法并不能统一处理404错误。</p> 
<h3 id="404错误产生的原因">404错误产生的原因</h3> 
<p>产生404的原因是我们调了一个不存在的接口，但是为什么会返回下面的json报错呢？我们先从Spring的源代码分析下。</p> 
<pre><code class="language-java">{
  "timestamp": "2020-11-19T08:30:48.844+0000",
  "status": 404,
  "error": "Not Found",
  "message": "No message available",
  "path": "/hello/test1"
}</code></pre> 
<p>为了代码简单起见，这边直接从DispatcherServlet的doDispatch方法开始分析。（如果不知道为什么要从这边开始，你还要熟悉下SpringMVC的源代码）。</p> 
<pre><code class="language-java">... 省略部分代码....
// Actually invoke the handler.
mv = ha.handle(processedRequest, response, mappedHandler.getHandler());
... 省略部分代码</code></pre> 
<p>Spring MVC会根据请求URL的不同，配置的RequestMapping的不同，为请求匹配不同的HandlerAdapter。</p> 
<p>对于上面的请求地址：<a href="http://127.0.0.1:8888/hello/test1?id=98" rel="nofollow">http://127.0.0.1:8888/hello/test1?id=98</a>匹配到的HandlerAdapter是HttpRequestHandlerAdapter。</p> 
<p>我们直接进入到HttpRequestHandlerAdapter中看下这个类的handle方法。</p> 
<pre><code class="language-java">@Override
@Nullable
public ModelAndView handle(HttpServletRequest request, HttpServletResponse response, Object handler)
    throws Exception {
    ((HttpRequestHandler) handler).handleRequest(request, response);
    return null;
}</code></pre> 
<p>这个方法没什么内容，直接是调用了HttpRequestHandler类的handleRequest(request, response)方法。所以直接进入这个方法看下吧。</p> 
<pre><code class="language-java">@Override
public void handleRequest(HttpServletRequest request, HttpServletResponse response)
    throws ServletException, IOException {

    // For very general mappings (e.g. "/") we need to check 404 first
    Resource resource = getResource(request);
    if (resource == null) {
        logger.trace("No matching resource found - returning 404");
        // 这个方法很简单，就是设置404响应码，然后将Response的errorState状态从0设置成1
        response.sendError(HttpServletResponse.SC_NOT_FOUND);
        // 直接返回
        return;
    }
    ... 省略部分方法
}</code></pre> 
<p>这个方法很简单，就是设置404响应码，将Response的errorState状态从0设置成1，然后就返回响应了。<strong>整个过程并没有发生任何异常，所以不能触发Spring的全局异常处理机制</strong>。</p> 
<p>到这边还有一个问题没有解决：就是下面的404提示信息是怎么返回的。</p> 
<pre><code class="language-java">{
  "timestamp": "2020-11-19T08:30:48.844+0000",
  "status": 404,
  "error": "Not Found",
  "message": "No message available",
  "path": "/hello/test1"
}</code></pre> 
<p>我们继续往下看。Response响应被返回，进入org.apache.catalina.core.StandardHostValve类的invoke方法进行处理。（不要问我为什么知道是在这里？Debug的能力是需要自己摸索出来的，自己调试多了，你也就会了）</p> 
<pre><code class="language-java">@Override
public final void invoke(Request request, Response response)
    throws IOException, ServletException {
    
    Context context = request.getContext();
    if (context == null) {
        response.sendError(HttpServletResponse.SC_INTERNAL_SERVER_ERROR,
                           sm.getString("standardHost.noContext"));
        return;
    }

    if (request.isAsyncSupported()) {
        request.setAsyncSupported(context.getPipeline().isAsyncSupported());
    }

    boolean asyncAtStart = request.isAsync();
    boolean asyncDispatching = request.isAsyncDispatching();

    try {
        context.bind(Globals.IS_SECURITY_ENABLED, MY_CLASSLOADER);
        if (!asyncAtStart &amp;&amp; !context.fireRequestInitEvent(request.getRequest())) {
            return;
        }
        try {
            if (!asyncAtStart || asyncDispatching) {
                context.getPipeline().getFirst().invoke(request, response);
            } else {
                if (!response.isErrorReportRequired()) {
                    throw new IllegalStateException(sm.getString("standardHost.asyncStateError"));
                }
            }
        } catch (Throwable t) {
            ExceptionUtils.handleThrowable(t);
            container.getLogger().error("Exception Processing " + request.getRequestURI(), t);
            if (!response.isErrorReportRequired()) {
                request.setAttribute(RequestDispatcher.ERROR_EXCEPTION, t);
                throwable(request, response, t);
            }
        }
        response.setSuspended(false);

        Throwable t = (Throwable) request.getAttribute(RequestDispatcher.ERROR_EXCEPTION);
        if (!context.getState().isAvailable()) {
            return;
        }
        // 在这里判断请求是不是发生了错误，错误的话就进入StandardHostValve的status(Request request, Response response)方法。
        // Look for (and render if found) an application level error page
        if (response.isErrorReportRequired()) {
            if (t != null) {
                throwable(request, response, t);
            } else {
                status(request, response);
            }
        }

        if (!request.isAsync() &amp;&amp; !asyncAtStart) {
            context.fireRequestDestroyEvent(request.getRequest());
        }
    } finally {
        // Access a session (if present) to update last accessed time, based
        // on a strict interpretation of the specification
        if (ACCESS_SESSION) {
            request.getSession(false);
        }
        context.unbind(Globals.IS_SECURITY_ENABLED, MY_CLASSLOADER);
    }
  }</code></pre> 
<p>这个方法会根据返回的响应判断是不是发生了错了，如果发生了error，则进入StandardHostValve的status(Request request, Response response)方法。这个方法“兜兜转转”又进入了StandardHostValve的custom(Request request, Response response,ErrorPage errorPage)方法。这个方法中将请求重新forward到了"/error"接口。</p> 
<pre><code class="language-java">private boolean custom(Request request, Response response,
                             ErrorPage errorPage) {

        if (container.getLogger().isDebugEnabled()) {
            container.getLogger().debug("Processing " + errorPage);
        }
        try {
            // Forward control to the specified location
            ServletContext servletContext =
                request.getContext().getServletContext();
            RequestDispatcher rd =
                servletContext.getRequestDispatcher(errorPage.getLocation());
            if (rd == null) {
                container.getLogger().error(
                    sm.getString("standardHostValue.customStatusFailed", errorPage.getLocation()));
                return false;
            }
            if (response.isCommitted()) {
                rd.include(request.getRequest(), response.getResponse());
            } else {
                // Reset the response (keeping the real error code and message)
                response.resetBuffer(true);
                response.setContentLength(-1);
                // 1: 重新forward请求到/error接口
                rd.forward(request.getRequest(), response.getResponse());
                response.setSuspended(false);
            }
            return true;
        } catch (Throwable t) {
            ExceptionUtils.handleThrowable(t);
            container.getLogger().error("Exception Processing " + errorPage, t);
            return false;
        }
    }</code></pre> 
<p>上面标号1处的代码重新将请求forward到了/error接口。所以如果我们开着Debug日志的话，你会在后台看到下面的日志。</p> 
<pre><code class="language-java">[http-nio-8888-exec-7] DEBUG org.springframework.web.servlet.DispatcherServlet:891 - DispatcherServlet with name 'dispatcherServlet' processing POST request for [/error]
2020-11-19 19:04:04.280 [http-nio-8888-exec-7] DEBUG org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerMapping:313 - Looking up handler method for path /error
2020-11-19 19:04:04.281 [http-nio-8888-exec-7] DEBUG org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerMapping:320 - Returning handler method [public org.springframework.http.ResponseEntity&lt;java.util.Map&lt;java.lang.String, java.lang.Object&gt;&gt; org.springframework.boot.autoconfigure.web.servlet.error.BasicErrorController.error(javax.servlet.http.HttpServletRequest)]
2020-11-19 19:04:04.281 [http-nio-8888-exec-7] DEBUG org.springframework.beans.factory.support.DefaultListableBeanFactory:255 - Returning cached instance of singleton bean 'basicErrorController'</code></pre> 
<p>上面是/error的请求日志。到这边还是没说明为什么能返回json格式的404返回格式。我们继续往下看。</p> 
<p>到这边为止，我们好像没有任何线索了。但是如果仔细看上面日志的话，你会发现这个接口的处理方法是：</p> 
<pre><code class="language-java">org.springframework.boot.autoconfigure.web.servlet.error.BasicErrorController.error(javax.servlet.http.HttpServletRequest)]
</code></pre> 
<p>我们打开BasicErrorController这个类的源代码，一切豁然开朗。</p> 
<pre><code class="language-java">@Controller
@RequestMapping("${server.error.path:${error.path:/error}}")
public class BasicErrorController extends AbstractErrorController {
    @RequestMapping(produces = "text/html")
    public ModelAndView errorHtml(HttpServletRequest request,
            HttpServletResponse response) {
        HttpStatus status = getStatus(request);
        Map&lt;String, Object&gt; model = Collections.unmodifiableMap(getErrorAttributes(
                request, isIncludeStackTrace(request, MediaType.TEXT_HTML)));
        response.setStatus(status.value());
        ModelAndView modelAndView = resolveErrorView(request, response, status, model);
        return (modelAndView == null ? new ModelAndView("error", model) : modelAndView);
    }

    @RequestMapping
    @ResponseBody
    public ResponseEntity&lt;Map&lt;String, Object&gt;&gt; error(HttpServletRequest request) {
        Map&lt;String, Object&gt; body = getErrorAttributes(request,
                isIncludeStackTrace(request, MediaType.ALL));
        HttpStatus status = getStatus(request);
        return new ResponseEntity&lt;Map&lt;String, Object&gt;&gt;(body, status);
    }
    ... 省略部分方法
}</code></pre> 
<p>BasicErrorController是Spring默认配置的一个Controller，默认处理/error请求。BasicErrorController提供两种返回错误一种是页面返回、当你是页面请求的时候就会返回页面，另外一种是json请求的时候就会返回json错误。</p> 
<h3 id="自定义404错误处理类">自定义404错误处理类</h3> 
<p>我们先看下BasicErrorController是在哪里进行配置的。</p> 
<p>在IDEA中，查看BasicErrorController的usage，我们发现这个类是在ErrorMvcAutoConfiguration中自动配置的。</p> 
<pre><code class="language-java">@Configuration
@ConditionalOnWebApplication(type = Type.SERVLET)
@ConditionalOnClass({ Servlet.class, DispatcherServlet.class })
// Load before the main WebMvcAutoConfiguration so that the error View is available
@AutoConfigureBefore(WebMvcAutoConfiguration.class)
@EnableConfigurationProperties({ ServerProperties.class, ResourceProperties.class })
public class ErrorMvcAutoConfiguration {
    
    @Bean
	@ConditionalOnMissingBean(value = ErrorController.class, search = SearchStrategy.CURRENT)
	public BasicErrorController basicErrorController(ErrorAttributes errorAttributes) {
		return new BasicErrorController(errorAttributes, this.serverProperties.getError(),
				this.errorViewResolvers);
	}
	... 省略部分代码
}</code></pre> 
<p>从上面的配置中可以看出来，只要我们自己配置一个ErrorController，就可以覆盖掉BasicErrorController的行为。</p> 
<pre><code class="language-java">@Controller
@RequestMapping("${server.error.path:${error.path:/error}}")
public class CustomErrorController extends BasicErrorController {

    @Value("${server.error.path:${error.path:/error}}")
    private String path;

    public CustomErrorController(ServerProperties serverProperties) {
        super(new DefaultErrorAttributes(), serverProperties.getError());
    }

    /**
     * 覆盖默认的JSON响应
     */
    @Override
    public ResponseEntity&lt;Map&lt;String, Object&gt;&gt; error(HttpServletRequest request) {

        HttpStatus status = getStatus(request);
        Map&lt;String, Object&gt; map = new HashMap&lt;String, Object&gt;(16);
        Map&lt;String, Object&gt; originalMsgMap = getErrorAttributes(request, isIncludeStackTrace(request, MediaType.ALL));
        String path = (String)originalMsgMap.get("path");
        String error = (String)originalMsgMap.get("error");
        String message = (String)originalMsgMap.get("message");
        StringJoiner joiner = new StringJoiner(",","[","]");
        joiner.add(path).add(error).add(message);
        map.put("rtnCode", "9999");
        map.put("rtnMsg", joiner.toString());
        return new ResponseEntity&lt;Map&lt;String, Object&gt;&gt;(map, status);
    }

    /**
     * 覆盖默认的HTML响应
     */
    @Override
    public ModelAndView errorHtml(HttpServletRequest request, HttpServletResponse response) {
        //请求的状态
        HttpStatus status = getStatus(request);
        response.setStatus(getStatus(request).value());
        Map&lt;String, Object&gt; model = getErrorAttributes(request,
                isIncludeStackTrace(request, MediaType.TEXT_HTML));
        ModelAndView modelAndView = resolveErrorView(request, response, status, model);
        //指定自定义的视图
        return (modelAndView == null ? new ModelAndView("error", model) : modelAndView);
    }
}</code></pre> 
<p>默认的错误路径是/error，我们可以通过以下配置进行覆盖：</p> 
<pre><code class="language-java">server:
  error:
    path: /xxx</code></pre> 
<p>详细的内容请参考Spring Boot的章节。</p> 
<h3 id="简单总结">简单总结</h3> 
<ul><li>如果在过滤器（Filter）中发生异常，或者调用的接口不存在，Spring会直接将Response的errorStatus状态设置成1，将http响应码设置为500或者404，Tomcat检测到errorStatus为1时，会将请求重现forward到/error接口；</li><li>如果请求已经进入了Controller的处理方法，这时发生了异常，如果没有配置Spring的全局异常机制，那么请求还是会被forward到/error接口，如果配置了全局异常处理，Controller中的异常会被捕获；</li><li>继承BasicErrorController就可以覆盖原有的错误处理方式。</li></ul> 
<p> </p> 
<blockquote> 
 <p>作者：程序员自由之路</p> 
 <p>出处：<a href="https://www.cnblogs.com/54chensongxia/p/14007696.html" rel="nofollow">https://www.cnblogs.com/54chensongxia/p/14007696.html</a></p> 
 <p>版权：本作品采用「<a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" rel="nofollow">署名-非商业性使用-相同方式共享 4.0 国际</a>」许可协议进行许可。</p> 
</blockquote> 
<p> </p> 
<p> </p> 
<p> </p> 
<p> </p> 
<p> </p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/757f1b71e9cf4386cb0360731575f4ed/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">卡巴斯基免费版安装教程</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/c54b0f3d19ee08b097b4a5ff0148e358/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">python数据可视化——画图基础1（figure 、坐标轴和图例设置）</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>