<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>《程序员面试金典（第6版）》面试题 16.25. LRU 缓存（自定义双向链表，list库函数，哈希映射） - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="《程序员面试金典（第6版）》面试题 16.25. LRU 缓存（自定义双向链表，list库函数，哈希映射）" />
<meta property="og:description" content="题目描述 设计和构建一个“最近最少使用”缓存，该缓存会删除最近最少使用的项目。缓存应该从键映射到值(允许你插入和检索特定键对应的值)，并在初始化时指定最大容量。当缓存被填满时，它应该删除最近最少使用的项目。
题目传送门：面试题 16.25. LRU 缓存
它应该支持以下操作： 获取数据 get 和 写入数据 put 。
获取数据 get(key) - 如果密钥 (key) 存在于缓存中，则获取密钥的值（总是正数），否则返回 -1。
写入数据 put(key, value) - 如果密钥不存在，则写入其数据值。当缓存容量达到上限时，它应该在写入新数据之前删除最近最少使用的数据值，从而为新的数据值留出空间。
示例:
LRUCache cache = new LRUCache( 2 /* 缓存容量 */ ); cache.put(1, 1); cache.put(2, 2); cache.get(1); // 返回 1 cache.put(3, 3); // 该操作会使得密钥 2 作废 cache.get(2); // 返回 -1 (未找到) cache.put(4, 4); // 该操作会使得密钥 1 作废 cache.get(1); // 返回 -1 (未找到) cache.get(3); // 返回 3 cache." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/9f808ba5583c940f3838a98775532bef/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-05-30T21:00:55+08:00" />
<meta property="article:modified_time" content="2023-05-30T21:00:55+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">《程序员面试金典（第6版）》面试题 16.25. LRU 缓存（自定义双向链表，list库函数，哈希映射）</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-dracula">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <h2><a id="_0"></a>题目描述</h2> 
<blockquote> 
 <p>设计和构建一个“最近最少使用”缓存，该缓存会删除最近最少使用的项目。缓存应该从键映射到值(允许你插入和检索特定键对应的值)，并在初始化时指定最大容量。当缓存被填满时，它应该删除最近最少使用的项目。<br> 题目传送门：<a href="https://leetcode.cn/problems/lru-cache-lcci/" rel="nofollow">面试题 16.25. LRU 缓存</a></p> 
</blockquote> 
<ul><li> <p>它应该支持以下操作： 获取数据 get 和 写入数据 put 。</p> </li><li> <p>获取数据 get(key) - 如果密钥 (key) 存在于缓存中，则获取密钥的值（总是正数），否则返回 -1。</p> </li><li> <p>写入数据 put(key, value) - 如果密钥不存在，则写入其数据值。当缓存容量达到上限时，它应该在写入新数据之前删除最近最少使用的数据值，从而为新的数据值留出空间。</p> </li></ul> 
<p><strong>示例:</strong></p> 
<pre><code class="prism language-cpp">LRUCache cache <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token function">LRUCache</span><span class="token punctuation">(</span> <span class="token number">2</span> <span class="token comment">/* 缓存容量 */</span> <span class="token punctuation">)</span><span class="token punctuation">;</span>

cache<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
cache<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
cache<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>       <span class="token comment">// 返回  1</span>
cache<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 该操作会使得密钥 2 作废</span>
cache<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>       <span class="token comment">// 返回 -1 (未找到)</span>
cache<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 该操作会使得密钥 1 作废</span>
cache<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>       <span class="token comment">// 返回 -1 (未找到)</span>
cache<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span>       <span class="token comment">// 返回  3</span>
cache<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">;</span>       <span class="token comment">// 返回  4</span>
</code></pre> 
<h3><a id="_27"></a>解题思路与代码</h3> 
<ul><li> <p>这道题我觉得还是有点迷惑性的，假如说不了解什么是LRU缓存，可能会被“删除最近最少使用”这句话给蒙蔽了双眼，而给出了错误的答案。</p> </li><li> <p>你可能以为，我需要删除的是访问次数相同的，最近的那个内存，其实不是的。</p> </li><li> <p><code>LRU的原理是，如果数据最近被访问过，那么将来被访问的几率也更高。因此，我们在缓存满的时候，会淘汰最长时间未被访问的数据。</code></p> </li><li> <p>所以说，做这道题的时候，被误导了一下有点难受的。不过知道了原理，其实这道题也没有那么的困难。这道题的核心是<code>删除最长时间未被访问过的内存</code>，也就是说，想办法解决了这个问题，这道题也就迎刃而解了。</p> </li><li> <p>我们可以考虑用<code>双向链表 + unordered_map</code> 去解决这个问题，我们每次添加元素，都从头开始添加。内存满了，删除元素都从队列尾部删除，是不是完美的符合了删除最长时间不访问这个元素的需求。</p> </li><li> <p>最后，我们访问一个链表内的元素，我们就把这个元素，先从链表中删除，把它从新添加到链表头部，是不是也完美符合题意？</p> </li><li> <p>那unordered_map的作用是什么呢？它的作用就是让你快速知道你的这查找的这个元素是否在链表内，它的查找复杂度是O(1)的。</p> </li><li> <p>而双向链表的添加和删除节点的操作本身的时间复杂度也是O(1)的。所以用这两种数据结构，可以完美的去均摊这个时间复杂度。</p> </li></ul> 
<p>那又因为面试官考你这道题，肯定是想要考你自定义双向链表的，而不是想看你用库函数。所以我们要自己掌握，如何创建并使用一个自定义的双向链表。</p> 
<p>其次，这就意味着库函数的双向链表不重要了吗？恰恰相反，它也十分重要，真正的工作中，肯定也是不可能让你自己创建链表的。所以，矛盾又不矛盾。</p> 
<p>那接下来，就看我给大家展现这两种解法的代码都是如何写的吧~</p> 
<h4><a id="__unordered_map_45"></a>方案一：自定义双向链表 + unordered_map</h4> 
<ul><li>在这道题当中，我们需要实现两个函数，<code>get 和 put</code>。</li><li>get函数就是查找缓存中对应key的value。put函数就是把元素放到容器内，如果容器满了，就挑一个删除了，再添加。</li><li>根据题意，当容器满了时，<code>我们要删除的元素是，最长时间未被使用的元素</code>，这里我们使用的容器是双向链表，我们每次都从链表的头部开始添加元素，如果容器满了，需要删除的元素就一定是容器尾部的元素。</li><li>再者，我们如果查询了这个元素，而这个元素又在容器内的话，我们就要把它重新移动到头部，那如何移动呢？自然是删除后再添加啦，从当前位置删除，从链表头部添加。</li><li>这个自定义双向链表，我设置两个哨兵节点，分别是<code>head</code>与<code>tail</code>，这会使等会的链表操作变得非常的简单。具体的双向链表的其他实现，就请大家来看看代码啦~</li></ul> 
<p><strong>具体的代码如下：</strong></p> 
<pre><code class="prism language-cpp"><span class="token keyword">class</span> <span class="token class-name">LRUCache</span> <span class="token punctuation">{<!-- --></span>
<span class="token keyword">public</span><span class="token operator">:</span>
    <span class="token keyword">struct</span> <span class="token class-name">Node</span><span class="token punctuation">{<!-- --></span>
        <span class="token keyword">int</span> key<span class="token punctuation">;</span>
        <span class="token keyword">int</span> val<span class="token punctuation">;</span>
        Node <span class="token operator">*</span> prev<span class="token punctuation">;</span>
        Node <span class="token operator">*</span> next<span class="token punctuation">;</span>
        <span class="token function">Node</span><span class="token punctuation">(</span><span class="token keyword">int</span> k<span class="token punctuation">,</span> <span class="token keyword">int</span> v<span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token function">key</span><span class="token punctuation">(</span>k<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">val</span><span class="token punctuation">(</span>v<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">prev</span><span class="token punctuation">(</span><span class="token keyword">nullptr</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">next</span><span class="token punctuation">(</span><span class="token keyword">nullptr</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span><span class="token punctuation">}</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span><span class="token punctuation">;</span>
    <span class="token function">LRUCache</span><span class="token punctuation">(</span><span class="token keyword">int</span> capacity<span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token function">cap</span><span class="token punctuation">(</span>capacity<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">size</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">head</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token function">Node</span><span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">tail</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token function">Node</span><span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        head<span class="token operator">-&gt;</span>next <span class="token operator">=</span> tail<span class="token punctuation">;</span>
        tail<span class="token operator">-&gt;</span>prev <span class="token operator">=</span> head<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">int</span> <span class="token function">get</span><span class="token punctuation">(</span><span class="token keyword">int</span> key<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token keyword">if</span><span class="token punctuation">(</span>map<span class="token punctuation">.</span><span class="token function">find</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span> <span class="token operator">==</span> map<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>
        <span class="token function">moveNode</span><span class="token punctuation">(</span>map<span class="token punctuation">[</span>key<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span> map<span class="token punctuation">[</span>key<span class="token punctuation">]</span><span class="token operator">-&gt;</span>val<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    
    <span class="token keyword">void</span> <span class="token function">put</span><span class="token punctuation">(</span><span class="token keyword">int</span> key<span class="token punctuation">,</span> <span class="token keyword">int</span> value<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token keyword">if</span><span class="token punctuation">(</span>map<span class="token punctuation">.</span><span class="token function">find</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span> <span class="token operator">!=</span> map<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
            map<span class="token punctuation">[</span>key<span class="token punctuation">]</span><span class="token operator">-&gt;</span>val <span class="token operator">=</span> value<span class="token punctuation">;</span>
            <span class="token function">moveNode</span><span class="token punctuation">(</span>map<span class="token punctuation">[</span>key<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span><span class="token keyword">else</span><span class="token punctuation">{<!-- --></span>
            <span class="token keyword">if</span><span class="token punctuation">(</span>size <span class="token operator">==</span> cap<span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
                map<span class="token punctuation">.</span><span class="token function">erase</span><span class="token punctuation">(</span>tail<span class="token operator">-&gt;</span>prev<span class="token operator">-&gt;</span>key<span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token function">removeFromList</span><span class="token punctuation">(</span>tail<span class="token operator">-&gt;</span>prev<span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token operator">--</span>size<span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
            Node <span class="token operator">*</span> node <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token function">Node</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span>value<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token function">addToHead</span><span class="token punctuation">(</span>node<span class="token punctuation">)</span><span class="token punctuation">;</span>
            map<span class="token punctuation">[</span>key<span class="token punctuation">]</span> <span class="token operator">=</span> node<span class="token punctuation">;</span>
            <span class="token operator">++</span>size<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token keyword">private</span><span class="token operator">:</span>
    <span class="token keyword">int</span> cap<span class="token punctuation">;</span>
    <span class="token keyword">int</span> size<span class="token punctuation">;</span>
    Node <span class="token operator">*</span> head<span class="token punctuation">;</span>
    Node <span class="token operator">*</span> tail<span class="token punctuation">;</span>
    unordered_map<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token punctuation">,</span>Node<span class="token operator">*</span><span class="token operator">&gt;</span> map<span class="token punctuation">;</span>

    <span class="token keyword">void</span> <span class="token function">addToHead</span><span class="token punctuation">(</span>Node <span class="token operator">*</span> node<span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
        node<span class="token operator">-&gt;</span>next <span class="token operator">=</span> head<span class="token operator">-&gt;</span>next<span class="token punctuation">;</span>
        node<span class="token operator">-&gt;</span>prev <span class="token operator">=</span> head<span class="token punctuation">;</span>
        head<span class="token operator">-&gt;</span>next<span class="token operator">-&gt;</span>prev <span class="token operator">=</span> node<span class="token punctuation">;</span>
        head<span class="token operator">-&gt;</span>next <span class="token operator">=</span> node<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">void</span> <span class="token function">removeFromList</span><span class="token punctuation">(</span>Node <span class="token operator">*</span> node<span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
        node<span class="token operator">-&gt;</span>next<span class="token operator">-&gt;</span>prev <span class="token operator">=</span> node<span class="token operator">-&gt;</span>prev<span class="token punctuation">;</span>
        node<span class="token operator">-&gt;</span>prev<span class="token operator">-&gt;</span>next <span class="token operator">=</span> node<span class="token operator">-&gt;</span>next<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">void</span> <span class="token function">moveNode</span><span class="token punctuation">(</span>Node <span class="token operator">*</span> node<span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
        <span class="token function">removeFromList</span><span class="token punctuation">(</span>node<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">addToHead</span><span class="token punctuation">(</span>node<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre> 
<p><img src="https://images2.imgbox.com/68/d1/HJXOROk3_o.png" alt="在这里插入图片描述"></p> 
<h5><a id="_117"></a>复杂度分析：</h5> 
<blockquote> 
 <p>这个 LRU 缓存的实现，无论是 get 还是 put 操作，都可以在常数时间内完成，因此时间复杂度是 O(1)。</p> 
</blockquote> 
<ul><li> <p>这是因为,我们通过哈希表实现了对任意键值的快速查询，查询的时间复杂度是 O(1)。</p> 
  <ul><li>对于哈希表中存储的每个键值对，我们都有一个对应的链表节点。当需要将某个键值对提到最近使用的位置时，我们可以直接通过哈希表找到对应的链表节点，然后在 O(1) 时间内将其移动到链表的头部。同样，当缓存容量已满，需要淘汰最久未使用的键值对时，我们也可以在 O(1) 时间内从链表尾部删除一个节点。</li></ul> </li><li> <p>对于空间复杂度，因为哈希表和链表都存储了整个数据，所以空间复杂度是 O(capacity)，其中 capacity 是缓存的最大容量。</p> </li></ul> 
<h4><a id="list__unordered_map_127"></a>方案二：使用list + unordered_map</h4> 
<ul><li>这种做法，最大的好处就是带你重新复习了一遍list容器中，各种函数的操作。如果你对list函数的操作不太熟悉的话，你可以看下我写的这篇文章：<a href="https://blog.csdn.net/weixin_49503250/article/details/130955658?csdn_share_tail=%7B%22type%22:%22blog%22,%22rType%22:%22article%22,%22rId%22:%22130955658%22,%22source%22:%22weixin_49503250%22%7D">全面理解：C++中list（双向链表）容器的基础概念与函数解析</a></li></ul> 
<p>其他没什么了，代码的逻辑和上一种一模一样。</p> 
<p><strong>具体的代码如下：</strong></p> 
<pre><code class="prism language-cpp"><span class="token keyword">class</span> <span class="token class-name">LRUCache</span> <span class="token punctuation">{<!-- --></span>
<span class="token keyword">public</span><span class="token operator">:</span>
    <span class="token function">LRUCache</span><span class="token punctuation">(</span><span class="token keyword">int</span> capacity<span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token function">cap</span><span class="token punctuation">(</span>capacity<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span><span class="token punctuation">}</span>
    <span class="token keyword">int</span> <span class="token function">get</span><span class="token punctuation">(</span><span class="token keyword">int</span> key<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token keyword">if</span><span class="token punctuation">(</span>map<span class="token punctuation">.</span><span class="token function">find</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span> <span class="token operator">==</span> map<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>
        cache<span class="token punctuation">.</span><span class="token function">splice</span><span class="token punctuation">(</span>cache<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>cache<span class="token punctuation">,</span>map<span class="token punctuation">[</span>key<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span> map<span class="token punctuation">[</span>key<span class="token punctuation">]</span><span class="token operator">-&gt;</span>second<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">void</span> <span class="token function">put</span><span class="token punctuation">(</span><span class="token keyword">int</span> key<span class="token punctuation">,</span> <span class="token keyword">int</span> value<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token keyword">if</span><span class="token punctuation">(</span>map<span class="token punctuation">.</span><span class="token function">find</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span> <span class="token operator">!=</span> map<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
            cache<span class="token punctuation">.</span><span class="token function">splice</span><span class="token punctuation">(</span>cache<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>cache<span class="token punctuation">,</span>map<span class="token punctuation">[</span>key<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            map<span class="token punctuation">[</span>key<span class="token punctuation">]</span><span class="token operator">-&gt;</span>second <span class="token operator">=</span> value<span class="token punctuation">;</span>
        <span class="token punctuation">}</span><span class="token keyword">else</span><span class="token punctuation">{<!-- --></span>
            <span class="token keyword">if</span><span class="token punctuation">(</span>cache<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> cap<span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
                map<span class="token punctuation">.</span><span class="token function">erase</span><span class="token punctuation">(</span>cache<span class="token punctuation">.</span><span class="token function">back</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>first<span class="token punctuation">)</span><span class="token punctuation">;</span>
                cache<span class="token punctuation">.</span><span class="token function">pop_back</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> 
            <span class="token punctuation">}</span>
            cache<span class="token punctuation">.</span><span class="token function">push_front</span><span class="token punctuation">(</span><span class="token punctuation">{<!-- --></span>key<span class="token punctuation">,</span>value<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            map<span class="token punctuation">[</span>key<span class="token punctuation">]</span> <span class="token operator">=</span> cache<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token keyword">private</span><span class="token operator">:</span>
    <span class="token keyword">int</span> cap<span class="token punctuation">;</span>
    list<span class="token operator">&lt;</span>pair<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token punctuation">,</span><span class="token keyword">int</span><span class="token operator">&gt;&gt;</span> cache<span class="token punctuation">;</span>
    unordered_map<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token punctuation">,</span>list<span class="token operator">&lt;</span>pair<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token punctuation">,</span><span class="token keyword">int</span><span class="token operator">&gt;&gt;</span><span class="token double-colon punctuation">::</span>iterator<span class="token operator">&gt;</span> map<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token comment">/**
 * Your LRUCache object will be instantiated and called as such:
 * LRUCache* obj = new LRUCache(capacity);
 * int param_1 = obj-&gt;get(key);
 * obj-&gt;put(key,value);
 */</span>
</code></pre> 
<h5><a id="_171"></a>复杂度分析：</h5> 
<p><strong>时间复杂度：</strong></p> 
<ul><li>get 方法：O(1)。unordered_map 用哈希实现，所以查找的平均时间复杂度是O(1)，list::splice方法的时间复杂度也是O(1)。</li><li>put 方法：O(1)。unordered_map的插入和删除操作的平均时间复杂度都是O(1)，list::push_front和list::pop_back也都是O(1)。</li></ul> 
<p><strong>空间复杂度：</strong></p> 
<ul><li>O(capacity)。list和unordered_map都存储了缓存中的所有元素，所以空间复杂度与缓存的容量成正比。</li></ul> 
<p>这就是为什么我们使用 list 和 unordered_map 结构来实现 LRU 缓存的原因，它们可以确保所有操作都在常数时间复杂度内完成，而且空间复杂度与缓存的容量成正比。</p> 
<h3><a id="_184"></a>总结</h3> 
<blockquote> 
 <p>这道题主要是为了测试你对LRU（Least Recently Used）缓存淘汰策略的理解和实现能力，同时也在考察你的数据结构设计能力。</p> 
</blockquote> 
<ul><li> <p>LRU缓存淘汰策略在实际中广泛应用，例如在数据库缓存、浏览器缓存等场景中，都会有其身影。其核心思想是“如果一个数据在最近一段时间没有被访问到，那么在将来它被访问的可能性也很小”。因此，这种算法可以用于预测哪些数据应该被替换出去，从而使缓存的命中率最大。</p> </li><li> <p>实现这个策略需要用到的数据结构包括哈希表（HashMap）和双向链表（Doubly LinkedList）。其中，哈希表提供了快速查找，而双向链表则可以用来调整数据的优先级。</p> </li></ul> 
<p>通过这道题，你可以锻炼并展示出你对以上各种技术和数据结构的掌握程度。同时，这也是一种非常实用的技能，可以直接应用于你未来的项目和工作中。</p> 
<p><code>最后的最后，如果你觉得我的这篇文章写的不错的话，请给我一个赞与收藏，关注我，我会继续给大家带来更多更优质的干货内容</code>。</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/5f8f2e8a3ba76831574336c0a3665138/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">全面理解：C&#43;&#43;中list（双向链表）容器的基础概念与函数解析</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/a96a872b094a38c6915e5ef9ff019e9b/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">Skywalking9.4.0部署监控项目</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>