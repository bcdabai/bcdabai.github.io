<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Flink中的窗口函数 - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Flink中的窗口函数" />
<meta property="og:description" content="目录
1. 增量聚合函数（incremental aggregation functions）
（1）归约函数（ReduceFunction）
（2）聚合函数（AggregateFunction）
2. 全窗口函数（full window functions）
（1）窗口函数（WindowFunction）
（2）处理窗口函数（ProcessWindowFunction）
3. 增量聚合和全窗口函数的结合使用
4、窗口的生命周期
1. 窗口的创建
2. 窗口计算的触发
3. 窗口的销毁
4. 窗口 API 调用总结
经窗口分配器处理之后，数据可以分配到对应的窗口中，而数据流经过转换得到的数据类 型是 WindowedStream 。这个类型并不是 DataStream ，所以并不能直接进行其他转换，而必须 进一步调用窗口函数，对收集到的数据进行处理计算之后，才能最终再次得到 DataStream ，如 图 6-21 所示。 窗口函数定义了要对窗口中收集的数据做的计算操作，根据处理的方式可以分为两类：增 量聚合函数和全窗口函数。下面我们来进行分别讲解。 1. 增量聚合函数（incremental aggregation functions） 为了提高实时性，我们可以再次将流处理的思路发扬光大：就像 DataStream 的简单聚合 一样，每来一条数据就立即进行计算，中间只要保持一个简单的聚合状态就可以了；区别只是 在于不立即输出结果，而是要等到窗口结束时间。等到窗口到了结束时间需要输出计算结果的 时候，我们只需要拿出之前聚合的状态直接输出，这无疑就大大提高了程序运行的效率和实时 性。 典型的增量聚合函数有两个： ReduceFunction 和 AggregateFunction。 （1）归约函数（ReduceFunction） 最基本的聚合方式就是归约（reduce）。 窗口函数中也提供了 ReduceFunction ：只要基于 WindowedStream 调用 .reduce() 方法，然 后传入 ReduceFunction 作为参数，就可以指定以归约两个元素的方式去对窗口中数据进行聚 合了。这里的 ReduceFunction 其实与简单聚合时用到的 ReduceFunction 是同一个函数类接口， 所以使用方式也是完全一样的。 ReduceFunction 中需要重写一个 reduce 方法，它的两个参数代表输入的两 个元素，而归约最终输出结果的数据类型，与输入的数据类型必须保持一致。也就是说，中间 聚合的状态和输出的结果，都和输入的数据类型是一样的。 下面是使用 ReduceFunction 进行增量聚合的代码示例 import org." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/beaf73055073af50b774c829ba7f1485/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-11-10T13:43:56+08:00" />
<meta property="article:modified_time" content="2022-11-10T13:43:56+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Flink中的窗口函数</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p id="main-toc"><strong>目录</strong></p> 
<p id="1.%20%E5%A2%9E%E9%87%8F%E8%81%9A%E5%90%88%E5%87%BD%E6%95%B0%EF%BC%88incremental%20aggregation%20functions%EF%BC%89-toc" style="margin-left:0px;"><a href="#1.%20%E5%A2%9E%E9%87%8F%E8%81%9A%E5%90%88%E5%87%BD%E6%95%B0%EF%BC%88incremental%20aggregation%20functions%EF%BC%89" rel="nofollow">1. 增量聚合函数（incremental aggregation functions）</a></p> 
<p id="%EF%BC%881%EF%BC%89%E5%BD%92%E7%BA%A6%E5%87%BD%E6%95%B0%EF%BC%88ReduceFunction%EF%BC%89-toc" style="margin-left:40px;"><a href="#%EF%BC%881%EF%BC%89%E5%BD%92%E7%BA%A6%E5%87%BD%E6%95%B0%EF%BC%88ReduceFunction%EF%BC%89" rel="nofollow">（1）归约函数（ReduceFunction）</a></p> 
<p id="%EF%BC%882%EF%BC%89%E8%81%9A%E5%90%88%E5%87%BD%E6%95%B0%EF%BC%88AggregateFunction%EF%BC%89-toc" style="margin-left:40px;"><a href="#%EF%BC%882%EF%BC%89%E8%81%9A%E5%90%88%E5%87%BD%E6%95%B0%EF%BC%88AggregateFunction%EF%BC%89" rel="nofollow">（2）聚合函数（AggregateFunction）</a></p> 
<p id="2.%20%E5%85%A8%E7%AA%97%E5%8F%A3%E5%87%BD%E6%95%B0%EF%BC%88full%20window%20functions%EF%BC%89-toc" style="margin-left:0px;"><a href="#2.%20%E5%85%A8%E7%AA%97%E5%8F%A3%E5%87%BD%E6%95%B0%EF%BC%88full%20window%20functions%EF%BC%89" rel="nofollow">2. 全窗口函数（full window functions）</a></p> 
<p id="%EF%BC%881%EF%BC%89%E7%AA%97%E5%8F%A3%E5%87%BD%E6%95%B0%EF%BC%88WindowFunction%EF%BC%89-toc" style="margin-left:40px;"><a href="#%EF%BC%881%EF%BC%89%E7%AA%97%E5%8F%A3%E5%87%BD%E6%95%B0%EF%BC%88WindowFunction%EF%BC%89" rel="nofollow">（1）窗口函数（WindowFunction）</a></p> 
<p id="%EF%BC%882%EF%BC%89%E5%A4%84%E7%90%86%E7%AA%97%E5%8F%A3%E5%87%BD%E6%95%B0%EF%BC%88ProcessWindowFunction%EF%BC%89-toc" style="margin-left:40px;"><a href="#%EF%BC%882%EF%BC%89%E5%A4%84%E7%90%86%E7%AA%97%E5%8F%A3%E5%87%BD%E6%95%B0%EF%BC%88ProcessWindowFunction%EF%BC%89" rel="nofollow">（2）处理窗口函数（ProcessWindowFunction）</a></p> 
<p id="3.%20%E5%A2%9E%E9%87%8F%E8%81%9A%E5%90%88%E5%92%8C%E5%85%A8%E7%AA%97%E5%8F%A3%E5%87%BD%E6%95%B0%E7%9A%84%E7%BB%93%E5%90%88%E4%BD%BF%E7%94%A8-toc" style="margin-left:0px;"><a href="#3.%20%E5%A2%9E%E9%87%8F%E8%81%9A%E5%90%88%E5%92%8C%E5%85%A8%E7%AA%97%E5%8F%A3%E5%87%BD%E6%95%B0%E7%9A%84%E7%BB%93%E5%90%88%E4%BD%BF%E7%94%A8" rel="nofollow">3. 增量聚合和全窗口函数的结合使用</a></p> 
<p id="4%E3%80%81%E7%AA%97%E5%8F%A3%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F-toc" style="margin-left:0px;"><a href="#4%E3%80%81%E7%AA%97%E5%8F%A3%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F" rel="nofollow">4、窗口的生命周期</a></p> 
<p id="1.%20%E7%AA%97%E5%8F%A3%E7%9A%84%E5%88%9B%E5%BB%BA-toc" style="margin-left:40px;"><a href="#1.%20%E7%AA%97%E5%8F%A3%E7%9A%84%E5%88%9B%E5%BB%BA" rel="nofollow">1. 窗口的创建</a></p> 
<p id="2.%20%E7%AA%97%E5%8F%A3%E8%AE%A1%E7%AE%97%E7%9A%84%E8%A7%A6%E5%8F%91-toc" style="margin-left:40px;"><a href="#2.%20%E7%AA%97%E5%8F%A3%E8%AE%A1%E7%AE%97%E7%9A%84%E8%A7%A6%E5%8F%91" rel="nofollow">2. 窗口计算的触发</a></p> 
<p id="3.%20%E7%AA%97%E5%8F%A3%E7%9A%84%E9%94%80%E6%AF%81-toc" style="margin-left:40px;"><a href="#3.%20%E7%AA%97%E5%8F%A3%E7%9A%84%E9%94%80%E6%AF%81" rel="nofollow">3. 窗口的销毁</a></p> 
<p id="4.%20%E7%AA%97%E5%8F%A3%20API%20%E8%B0%83%E7%94%A8%E6%80%BB%E7%BB%93-toc" style="margin-left:40px;"><a href="#4.%20%E7%AA%97%E5%8F%A3%20API%20%E8%B0%83%E7%94%A8%E6%80%BB%E7%BB%93" rel="nofollow">4. 窗口 API 调用总结</a></p> 
<hr id="hr-toc"> 
<p></p> 
<hr> 
<p></p> 
<p class="img-center"><img alt="" height="321" src="https://images2.imgbox.com/8e/fe/w49wYtia_o.png" width="385"></p> 
<p></p> 
<div> 
 <span style="color:#000000;">        经窗口分配器处理之后，数据可以分配到对应的窗口中，而数据流经过转换得到的数据类 </span> 
</div> 
<div> 
 <span style="color:#000000;">型是 </span> 
 <span style="color:#000000;">WindowedStream</span> 
 <span style="color:#000000;">。这个类型并不是 </span> 
 <span style="color:#000000;">DataStream</span> 
 <span style="color:#000000;">，所以并不能直接进行其他转换，而必须 </span> 
</div> 
<div> 
 <span style="color:#000000;">进一步调用窗口函数，对收集到的数据进行处理计算之后，才能最终再次得到 </span> 
 <span style="color:#000000;">DataStream</span> 
 <span style="color:#000000;">，如 </span> 
</div> 
<div> 
 <span style="color:#000000;">图 </span> 
 <span style="color:#000000;">6-21 </span> 
 <span style="color:#000000;">所示。</span> 
</div> 
<div></div> 
<div> 
 <div> 
  <span style="color:#000000;">        窗口函数定义了要对窗口中收集的数据做的计算操作，根据处理的方式可以分为两类：增 </span> 
 </div> 
 <div> 
  <span style="color:#000000;">量聚合函数和全窗口函数。下面我们来进行分别讲解。 </span> 
 </div> 
 <div></div> 
 <div> 
  <h2 id="1.%20%E5%A2%9E%E9%87%8F%E8%81%9A%E5%90%88%E5%87%BD%E6%95%B0%EF%BC%88incremental%20aggregation%20functions%EF%BC%89"><strong><span style="color:#000000;">1. </span><span style="color:#000000;">增量聚合函数（</span><span style="color:#000000;">incremental aggregation functions</span><span style="color:#000000;">） </span></strong></h2> 
  <div></div> 
  <div> 
   <span style="color:#000000;">        为了提高实时性，我们可以再次将流处理的思路发扬光大：就像 DataStream </span> 
   <span style="color:#000000;">的简单聚合 </span> 
  </div> 
  <div> 
   <span style="color:#000000;">一样，每来一条数据就立即进行计算，中间只要保持一个简单的聚合状态就可以了；区别只是 </span> 
  </div> 
  <div> 
   <span style="color:#000000;">在于不立即输出结果，而是要等到窗口结束时间。等到窗口到了结束时间需要输出计算结果的 </span> 
  </div> 
  <div> 
   <span style="color:#000000;">时候，我们只需要拿出之前聚合的状态直接输出，这无疑就大大提高了程序运行的效率和实时 </span> 
  </div> 
  <div> 
   <span style="color:#000000;">性。 </span> 
  </div> 
  <div></div> 
  <div> 
   <span style="color:#000000;">典型的增量聚合函数有两个：</span> 
   <strong><span style="color:#000000;">ReduceFunction </span><span style="color:#000000;">和 </span><span style="color:#000000;">AggregateFunction</span><span style="color:#000000;">。 </span></strong> 
  </div> 
  <div></div> 
  <div> 
   <h3 id="%EF%BC%881%EF%BC%89%E5%BD%92%E7%BA%A6%E5%87%BD%E6%95%B0%EF%BC%88ReduceFunction%EF%BC%89"><span style="color:#000000;"><strong>（</strong></span><span style="color:#000000;"><strong>1</strong></span><span style="color:#000000;"><strong>）归约函数（</strong></span><span style="color:#000000;"><strong>ReduceFunction</strong></span><span style="color:#000000;"><strong>） </strong></span></h3> 
   <div></div> 
   <div> 
    <span style="color:#000000;">        最基本的聚合方式就是归约（reduce）。</span> 
   </div> 
   <div></div> 
   <div> 
    <span style="color:#000000;">        窗口函数中也提供了 ReduceFunction</span> 
    <span style="color:#000000;">：只要基于 </span> 
    <span style="color:#000000;">WindowedStream </span> 
    <span style="color:#000000;">调用</span> 
    <span style="color:#000000;">.reduce()</span> 
    <span style="color:#000000;">方法，然 </span> 
   </div> 
   <div> 
    <span style="color:#000000;">后传入 </span> 
    <span style="color:#000000;">ReduceFunction </span> 
    <span style="color:#000000;">作为参数，就可以指定以归约两个元素的方式去对窗口中数据进行聚 </span> 
   </div> 
   <div> 
    <span style="color:#000000;">合了。这里的 </span> 
    <span style="color:#000000;">ReduceFunction </span> 
    <span style="color:#000000;">其实与简单聚合时用到的 </span> 
    <span style="color:#000000;">ReduceFunction </span> 
    <span style="color:#000000;">是同一个函数类接口， </span> 
   </div> 
   <div> 
    <span style="color:#000000;">所以使用方式也是完全一样的。 </span> 
   </div> 
   <div></div> 
   <div> 
    <span style="color:#000000;">        ReduceFunction 中需要重写一个 </span> 
    <span style="color:#000000;">reduce </span> 
    <span style="color:#000000;">方法，它的两个参数代表输入的两 个元素，而归约最终输出结果的数据类型，与输入的数据类型必须保持一致。也就是说，中间 聚合的状态和输出的结果，都和输入的数据类型是一样的。 </span> 
   </div> 
   <div></div> 
   <div> 
    <span style="color:#000000;">下面是使用 </span> 
    <span style="color:#000000;">ReduceFunction </span> 
    <span style="color:#000000;">进行增量聚合的代码示例</span> 
   </div> 
   <div> 
    <pre><code class="language-java">import org.apache.flink.api.common.eventtime.SerializableTimestampAssigner;
import org.apache.flink.api.common.eventtime.WatermarkStrategy;
import org.apache.flink.api.common.functions.MapFunction;
import org.apache.flink.api.common.functions.ReduceFunction;
import org.apache.flink.api.java.tuple.Tuple2;
import org.apache.flink.streaming.api.datastream.SingleOutputStreamOperator;
import org.apache.flink.streaming.api.environment.StreamExecutionEnvironment;
import 
org.apache.flink.streaming.api.windowing.assigners.TumblingProcessingTimeWindo
ws;
import org.apache.flink.streaming.api.windowing.time.Time;
import java.time.Duration;
public class WindowReduceExample {
 public static void main(String[] args) throws Exception {
 StreamExecutionEnvironment env = 
StreamExecutionEnvironment.getExecutionEnvironment();
 env.setParallelism(1);
 // 从自定义数据源读取数据，并提取时间戳、生成水位线
 SingleOutputStreamOperator&lt;Event&gt; stream = env.addSource(new 
ClickSource())
 .assignTimestampsAndWatermarks(WatermarkStrategy.&lt;Event&gt;forBoun
dedOutOfOrderness(Duration.ZERO)
 .withTimestampAssigner(new SerializableTimestampAssigner&lt;Event&gt;() 
{
 @Override
 public long extractTimestamp(Event element, long recordTimestamp) 
{
 return element.timestamp;
 }
 })); stream.map(new MapFunction&lt;Event, Tuple2&lt;String, 
Long&gt;&gt;() {
 @Override
 public Tuple2&lt;String, Long&gt; map(Event value) throws Exception { 
 // 将数据转换成二元组，方便计算
 return Tuple2.of(value.user, 1L);
 }
 })
 .keyBy(r -&gt; r.f0)
 // 设置滚动事件时间窗口
 .window(TumblingEventTimeWindows.of(Time.seconds(5)))
 .reduce(new ReduceFunction&lt;Tuple2&lt;String, Long&gt;&gt;() {
 @Override
 public Tuple2&lt;String, Long&gt; reduce(Tuple2&lt;String, Long&gt; value1, 
Tuple2&lt;String, Long&gt; value2) throws Exception {
 // 定义累加规则，窗口闭合时，向下游发送累加结果
 return Tuple2.of(value1.f0, value1.f1 + value2.f1);
 }
 })
 .print();
 env.execute();
 }
}</code></pre> 
    <div> 
     <span style="color:#000000;">        代码中我们对每个用户的行为数据进行了开窗统计。与 word count </span> 
     <span style="color:#000000;">逻辑类似，首先将数 </span> 
    </div> 
    <div> 
     <span style="color:#000000;">据转换成</span> 
     <span style="color:#000000;">(user, count)</span> 
     <span style="color:#000000;">的二元组形式（类型为 </span> 
     <span style="color:#000000;">Tuple2&lt;String, Long&gt;</span> 
     <span style="color:#000000;">），每条数据对应的初始 </span> 
     <span style="color:#000000;">count 值都是 1</span> 
     <span style="color:#000000;">；然后按照用户 </span> 
     <span style="color:#000000;">id </span> 
     <span style="color:#000000;">分组，在处理时间下开滚动窗口，统计每 </span> 
     <span style="color:#000000;">5 </span> 
     <span style="color:#000000;">秒内的用户行为数量。 对于窗口的计算，我们用 ReduceFunction </span> 
     <span style="color:#000000;">对 </span> 
     <span style="color:#000000;">count </span> 
     <span style="color:#000000;">值做了增量聚合：窗口中会将当前的总 </span> 
     <span style="color:#000000;">count 值保存成一个归约状态，每来一条数据，就会调用内部的 reduce </span> 
     <span style="color:#000000;">方法，将新数据中的 </span> 
     <span style="color:#000000;">count </span> 
    </div> 
    <div> 
     <span style="color:#000000;">值叠加到状态上，并得到新的状态保存起来。等到了 </span> 
     <span style="color:#000000;">5 </span> 
     <span style="color:#000000;">秒窗口的结束时间，就把归约好的状态 </span> 
    </div> 
    <div> 
     <span style="color:#000000;">直接输出。 </span> 
    </div> 
    <div></div> 
    <div> 
     <span style="color:#000000;">        这里需要注意，我们经过窗口聚合转换输出的数据，数据类型依然是二元组 Tuple2&lt;String, </span> 
    </div> 
    <div> 
     <span style="color:#000000;">Long&gt;</span> 
     <span style="color:#000000;">。 </span> 
    </div> 
    <div></div> 
    <div> 
     <h3 id="%EF%BC%882%EF%BC%89%E8%81%9A%E5%90%88%E5%87%BD%E6%95%B0%EF%BC%88AggregateFunction%EF%BC%89"><span style="color:#000000;"><strong>（</strong></span><span style="color:#000000;"><strong>2</strong></span><span style="color:#000000;"><strong>）聚合函数（</strong></span><span style="color:#000000;"><strong>AggregateFunction</strong></span><span style="color:#000000;"><strong>） </strong></span></h3> 
     <div></div> 
     <div> 
      <span style="color:#000000;">        ReduceFunction 可以解决大多数归约聚合的问题，但是这个接口有一个限制，就是聚合状 </span> 
     </div> 
     <div> 
      <span style="color:#000000;">态的类型、输出结果的类型都必须和输入数据类型一样。这就迫使我们必须在聚合前，先将数 </span> 
     </div> 
     <div> 
      <span style="color:#000000;">据转换（</span> 
      <span style="color:#000000;">map</span> 
      <span style="color:#000000;">）成预期结果类型；而在有些情况下，还需要对状态进行进一步处理才能得到输 </span> 
     </div> 
     <div> 
      <span style="color:#000000;">出结果，这时它们的类型可能不同，使用 </span> 
      <span style="color:#000000;">ReduceFunction </span> 
      <span style="color:#000000;">就会非常麻烦。 </span> 
     </div> 
     <div></div> 
     <div> 
      <span style="color:#000000;">        例如，如果我们希望计算一组数据的平均值，应该怎样做聚合呢？很明显，这时我们需要 </span> 
     </div> 
     <div> 
      <span style="color:#000000;">计算两个状态量：数据的总和（</span> 
      <span style="color:#000000;">sum</span> 
      <span style="color:#000000;">），以及数据的个数（</span> 
      <span style="color:#000000;">count</span> 
      <span style="color:#000000;">），而最终输出结果是两者的商 </span> 
     </div> 
     <div> 
      <span style="color:#000000;">（</span> 
      <span style="color:#000000;">sum/count</span> 
      <span style="color:#000000;">）。如果用 </span> 
      <span style="color:#000000;">ReduceFunction</span> 
      <span style="color:#000000;">，那么我们应该先把数据转换成二元组</span> 
      <span style="color:#000000;">(sum, count)</span> 
      <span style="color:#000000;">的形 </span> 
     </div> 
     <div> 
      <span style="color:#000000;">式，然后进行归约聚合，最后再将元组的两个元素相除转换得到最后的平均值。本来应该只是 </span> 
     </div> 
     <div> 
      <span style="color:#000000;">一个任务，可我们却需要 </span> 
      <span style="color:#000000;">map-reduce-map </span> 
      <span style="color:#000000;">三步操作，这显然不够高效。 </span> 
     </div> 
     <div></div> 
     <div> 
      <span style="color:#000000;">        于是自然可以想到，如果取消类型一致的限制，让输入数据、中间状态、输出结果三者类 </span> 
     </div> 
     <div> 
      <span style="color:#000000;">型都可以不同，不就可以一步直接搞定了吗？ </span> 
     </div> 
     <div></div> 
     <div> 
      <span style="color:#000000;">        Flink 的 </span> 
      <span style="color:#000000;">Window API </span> 
      <span style="color:#000000;">中的 </span> 
      <span style="color:#000000;">aggregate </span> 
      <span style="color:#000000;">就提供了这样的操作。直接基于 </span> 
      <span style="color:#000000;">WindowedStream </span> 
      <span style="color:#000000;">调 </span> 
     </div> 
     <div> 
      <span style="color:#000000;">用</span> 
      <span style="color:#000000;">.aggregate()</span> 
      <span style="color:#000000;">方法，就可以定义更加灵活的窗口聚合操作。这个方法需要传入一个 </span> 
     </div> 
     <div> 
      <span style="color:#000000;">AggregateFunction </span> 
      <span style="color:#000000;">的实现类作为参数。</span> 
      <span style="color:#000000;">AggregateFunction </span> 
      <span style="color:#000000;">在源码中的定义如下： </span> 
     </div> 
     <div> 
      <pre><code class="language-java">public interface AggregateFunction&lt;IN, ACC, OUT&gt; extends Function, Serializable 
{
 ACC createAccumulator();
 ACC add(IN value, ACC accumulator);
 OUT getResult(ACC accumulator);
155
 ACC merge(ACC a, ACC b);
}</code></pre> 
      <div> 
       <span style="color:#000000;">        AggregateFunction 可以看作是 </span> 
       <span style="color:#000000;">ReduceFunction </span> 
       <span style="color:#000000;">的通用版本，这里有三种类型：输入类型 </span> 
      </div> 
      <div> 
       <span style="color:#000000;">（</span> 
       <span style="color:#000000;">IN</span> 
       <span style="color:#000000;">）、累加器类型（</span> 
       <span style="color:#000000;">ACC</span> 
       <span style="color:#000000;">）和输出类型（</span> 
       <span style="color:#000000;">OUT</span> 
       <span style="color:#000000;">）。输入类型 </span> 
       <span style="color:#000000;">IN </span> 
       <span style="color:#000000;">就是输入流中元素的数据类型； </span> 
      </div> 
      <div> 
       <span style="color:#000000;">累加器类型 </span> 
       <span style="color:#000000;">ACC </span> 
       <span style="color:#000000;">则是我们进行聚合的中间状态类型；而输出类型当然就是最终计算结果的类 </span> 
      </div> 
      <div> 
       <span style="color:#000000;">型了。 </span> 
      </div> 
      <div></div> 
      <div> 
       <span style="color:#000000;">接口中有四个方法： </span> 
      </div> 
      <div> 
       <span style="color:#000000;">⚫ </span> 
       <span style="color:#000000;">createAccumulator()</span> 
       <span style="color:#000000;">：创建一个累加器，这就是为聚合创建了一个初始状态，每个聚 </span> 
      </div> 
      <div> 
       <span style="color:#000000;">合任务只会调用一次。 </span> 
      </div> 
      <div> 
       <span style="color:#000000;">⚫ </span> 
       <span style="color:#000000;">add()</span> 
       <span style="color:#000000;">：将输入的元素添加到累加器中。这就是基于聚合状态，对新来的数据进行进 </span> 
      </div> 
      <div> 
       <span style="color:#000000;">一步聚合的过程。方法传入两个参数：当前新到的数据 </span> 
       <span style="color:#000000;">value</span> 
       <span style="color:#000000;">，和当前的累加器 </span> 
      </div> 
      <div> 
       <span style="color:#000000;">accumulator</span> 
       <span style="color:#000000;">；返回一个新的累加器值，也就是对聚合状态进行更新。每条数据到来之 </span> 
      </div> 
      <div> 
       <span style="color:#000000;">后都会调用这个方法。 </span> 
      </div> 
      <div> 
       <span style="color:#000000;">⚫ </span> 
       <span style="color:#000000;">getResult()</span> 
       <span style="color:#000000;">：从累加器中提取聚合的输出结果。也就是说，我们可以定义多个状态， </span> 
      </div> 
      <div> 
       <span style="color:#000000;">然后再基于这些聚合的状态计算出一个结果进行输出。比如之前我们提到的计算平均 </span> 
      </div> 
      <div> 
       <span style="color:#000000;">值，就可以把 </span> 
       <span style="color:#000000;">sum </span> 
       <span style="color:#000000;">和 </span> 
       <span style="color:#000000;">count </span> 
       <span style="color:#000000;">作为状态放入累加器，而在调用这个方法时相除得到最终 </span> 
      </div> 
      <div> 
       <span style="color:#000000;">结果。这个方法只在窗口要输出结果时调用。 </span> 
      </div> 
      <div> 
       <span style="color:#000000;">⚫ </span> 
       <span style="color:#000000;">merge()</span> 
       <span style="color:#000000;">：合并两个累加器，并将合并后的状态作为一个累加器返回。这个方法只在 </span> 
      </div> 
      <div> 
       <span style="color:#000000;">需要合并窗口的场景下才会被调用；最常见的合并窗口（</span> 
       <span style="color:#000000;">Merging Window</span> 
       <span style="color:#000000;">）的场景 </span> 
      </div> 
      <div> 
       <span style="color:#000000;">就是会话窗口（</span> 
       <span style="color:#000000;">Session Windows</span> 
       <span style="color:#000000;">）。 </span> 
      </div> 
      <div></div> 
      <div> 
       <span style="color:#000000;">        所以可以看到，AggregateFunction </span> 
       <span style="color:#000000;">的工作原理是：首先调用 </span> 
       <span style="color:#000000;">createAccumulator()</span> 
       <span style="color:#000000;">为任务初 </span> 
      </div> 
      <div> 
       <span style="color:#000000;">始化一个状态</span> 
       <span style="color:#000000;">(</span> 
       <span style="color:#000000;">累加器</span> 
       <span style="color:#000000;">)</span> 
       <span style="color:#000000;">；而后每来一个数据就调用一次 </span> 
       <span style="color:#000000;">add()</span> 
       <span style="color:#000000;">方法，对数据进行聚合，得到的 </span> 
      </div> 
      <div> 
       <span style="color:#000000;">结果保存在状态中；等到了窗口需要输出时，再调用 </span> 
       <span style="color:#000000;">getResult()</span> 
       <span style="color:#000000;">方法得到计算结果。很明显， </span> 
      </div> 
      <div> 
       <span style="color:#000000;">与 </span> 
       <span style="color:#000000;">ReduceFunction </span> 
       <span style="color:#000000;">相同，</span> 
       <span style="color:#000000;">AggregateFunction </span> 
       <span style="color:#000000;">也是增量式的聚合；而由于输入、中间状态、输 </span> 
      </div> 
      <div> 
       <span style="color:#000000;">出的类型可以不同，使得应用更加灵活方便。 </span> 
      </div> 
      <div></div> 
      <div> 
       <span style="color:#000000;">        下面来看一个具体例子。我们知道，在电商网站中，PV</span> 
       <span style="color:#000000;">（页面浏览量）和 </span> 
       <span style="color:#000000;">UV</span> 
       <span style="color:#000000;">（独立访客 </span> 
      </div> 
      <div> 
       <span style="color:#000000;">数）是非常重要的两个流量指标。一般来说，</span> 
       <span style="color:#000000;">PV </span> 
       <span style="color:#000000;">统计的是所有的点击量；而对用户 </span> 
       <span style="color:#000000;">id </span> 
       <span style="color:#000000;">进行去 </span> 
      </div> 
      <div> 
       <span style="color:#000000;">重之后，得到的就是 </span> 
       <span style="color:#000000;">UV</span> 
       <span style="color:#000000;">。所以有时我们会用 </span> 
       <span style="color:#000000;">PV/UV </span> 
       <span style="color:#000000;">这个比值，来表示“人均重复访问量”， </span> 
      </div> 
      <div> 
       <span style="color:#000000;">也就是平均每个用户会访问多少次页面，这在一定程度上代表了用户的粘度。 </span> 
      </div> 
      <div></div> 
      <div> 
       <span style="color:#000000;">代码实现如下：</span> 
      </div> 
      <div> 
       <pre><code class="language-java">import org.apache.flink.api.common.eventtime.SerializableTimestampAssigner;
import org.apache.flink.api.common.eventtime.WatermarkStrategy;
import org.apache.flink.api.common.functions.AggregateFunction;
import org.apache.flink.api.java.tuple.Tuple2;
import org.apache.flink.streaming.api.datastream.SingleOutputStreamOperator;
import org.apache.flink.streaming.api.environment.StreamExecutionEnvironment;
import 
org.apache.flink.streaming.api.windowing.assigners.SlidingEventTimeWindows;
import org.apache.flink.streaming.api.windowing.time.Time;
import java.util.HashSet;
public class WindowAggregateFunctionExample {
 public static void main(String[] args) throws Exception {
 StreamExecutionEnvironment env = 
StreamExecutionEnvironment.getExecutionEnvironment();
 env.setParallelism(1);
 SingleOutputStreamOperator&lt;Event&gt; stream = env.addSource(new 
ClickSource())
 .assignTimestampsAndWatermarks(WatermarkStrategy.&lt;Event&gt;forMono
tonousTimestamps()
 .withTimestampAssigner(new SerializableTimestampAssigner&lt;Event&gt;() 
{
 @Override
 public long extractTimestamp(Event element, long recordTimestamp) 
{
 return element.timestamp;
 }
 }));
 // 所有数据设置相同的 key，发送到同一个分区统计 PV 和 UV，再相除
 stream.keyBy(data -&gt; true)
 .window(SlidingEventTimeWindows.of(Time.seconds(10), 
Time.seconds(2)))
 .aggregate(new AvgPv())
 .print();
 env.execute();
 }
 public static class AvgPv implements AggregateFunction&lt;Event, 
Tuple2&lt;HashSet&lt;String&gt;, Long&gt;, Double&gt; {
 @Override
 public Tuple2&lt;HashSet&lt;String&gt;, Long&gt; createAccumulator() {

 // 创建累加器
 return Tuple2.of(new HashSet&lt;String&gt;(), 0L);
 }
 @Override
 public Tuple2&lt;HashSet&lt;String&gt;, Long&gt; add(Event value, 
Tuple2&lt;HashSet&lt;String&gt;, Long&gt; accumulator) {
 // 属于本窗口的数据来一条累加一次，并返回累加器
 accumulator.f0.add(value.user);
 return Tuple2.of(accumulator.f0, accumulator.f1 + 1L);
 }
 @Override
 public Double getResult(Tuple2&lt;HashSet&lt;String&gt;, Long&gt; accumulator) {
 // 窗口闭合时，增量聚合结束，将计算结果发送到下游
 return (double) accumulator.f1 / accumulator.f0.size();
 }
 @Override
 public Tuple2&lt;HashSet&lt;String&gt;, Long&gt; merge(Tuple2&lt;HashSet&lt;String&gt;, Long&gt; 
a, Tuple2&lt;HashSet&lt;String&gt;, Long&gt; b) {
 return null;
 }
 }
}</code></pre> 
       <div> 
        <span style="color:#000000;">·        代码中我们创建了事件时间滑动窗口，统计 10 </span> 
        <span style="color:#000000;">秒钟的“人均 </span> 
        <span style="color:#000000;">PV</span> 
        <span style="color:#000000;">”，每 </span> 
        <span style="color:#000000;">2 </span> 
        <span style="color:#000000;">秒统计一次。由 </span> 
       </div> 
       <div> 
        <span style="color:#000000;">于聚合的状态还需要做处理计算，因此窗口聚合时使用了更加灵活的 </span> 
        <span style="color:#000000;">AggregateFunction</span> 
        <span style="color:#000000;">。为了 </span> 
       </div> 
       <div> 
        <span style="color:#000000;">统计 </span> 
        <span style="color:#000000;">UV</span> 
        <span style="color:#000000;">，我们用一个 </span> 
        <span style="color:#000000;">HashSet </span> 
        <span style="color:#000000;">保存所有出现过的用户 </span> 
        <span style="color:#000000;">id</span> 
        <span style="color:#000000;">，实现自动去重；而 </span> 
        <span style="color:#000000;">PV </span> 
        <span style="color:#000000;">的统计则类 </span> 
       </div> 
       <div> 
        <span style="color:#000000;">似一个计数器，每来一个数据加一就可以了。所以这里的状态，定义为包含一个 </span> 
        <span style="color:#000000;">HashSet </span> 
        <span style="color:#000000;">和一 </span> 
       </div> 
       <div> 
        <span style="color:#000000;">个 </span> 
        <span style="color:#000000;">count </span> 
        <span style="color:#000000;">值的二元组（</span> 
        <span style="color:#000000;">Tuple2&lt;HashSet&lt;String&gt;, Long&gt;</span> 
        <span style="color:#000000;">），每来一条数据，就将 </span> 
        <span style="color:#000000;">user </span> 
        <span style="color:#000000;">存入 </span> 
        <span style="color:#000000;">HashSet</span> 
        <span style="color:#000000;">， 同时 count </span> 
        <span style="color:#000000;">加 </span> 
        <span style="color:#000000;">1</span> 
        <span style="color:#000000;">。这里的 </span> 
        <span style="color:#000000;">count </span> 
        <span style="color:#000000;">就是 </span> 
        <span style="color:#000000;">PV</span> 
        <span style="color:#000000;">，而 </span> 
        <span style="color:#000000;">HashSet </span> 
        <span style="color:#000000;">中元素的个数（</span> 
        <span style="color:#000000;">size</span> 
        <span style="color:#000000;">）就是 </span> 
        <span style="color:#000000;">UV</span> 
        <span style="color:#000000;">；所以最终 窗口的输出结果，就是它们的比值。 </span> 
       </div> 
       <div></div> 
       <div> 
        <span style="color:#000000;">        这里没有涉及会话窗口，所以 merge()</span> 
        <span style="color:#000000;">方法可以不做任何操作。 </span> 
       </div> 
       <div></div> 
       <div> 
        <span style="color:#000000;">        另外，Flink </span> 
        <span style="color:#000000;">也为窗口的聚合提供了一系列预定义的简单聚合方法，可以直接基于 </span> 
       </div> 
       <div> 
        <span style="color:#000000;">WindowedStream </span> 
        <span style="color:#000000;">调用。主要包括</span> 
        <span style="color:#000000;">.sum()/max()/maxBy()/min()/minBy()</span> 
        <span style="color:#000000;">，与 </span> 
        <span style="color:#000000;">KeyedStream </span> 
        <span style="color:#000000;">的简单 </span> 
       </div> 
       <div> 
        <span style="color:#000000;">聚合非常相似。它们的底层，其实都是通过 </span> 
        <span style="color:#000000;">AggregateFunction </span> 
        <span style="color:#000000;">来实现的。 </span> 
       </div> 
       <div></div> 
       <div> 
        <span style="color:#000000;">        通过 ReduceFunction </span> 
        <span style="color:#000000;">和 </span> 
        <span style="color:#000000;">AggregateFunction </span> 
        <span style="color:#000000;">我们可以发现，增量聚合函数其实就是在用流 </span> 
       </div> 
       <div> 
        <span style="color:#000000;">处理的思路来处理有界数据集，核心是保持一个聚合状态，当数据到来时不停地更新状态。这 </span> 
       </div> 
       <div> 
        <span style="color:#000000;">就是 Flink </span> 
        <span style="color:#000000;">所谓的“有状态的流处理”，通过这种方式可以极大地提高程序运行的效率，所以 </span> 
       </div> 
       <div> 
        <span style="color:#000000;">在实际应用中最为常见。 </span> 
       </div> 
       <div></div> 
       <div> 
        <h2 id="2.%20%E5%85%A8%E7%AA%97%E5%8F%A3%E5%87%BD%E6%95%B0%EF%BC%88full%20window%20functions%EF%BC%89"><span style="color:#000000;">2. </span><span style="color:#000000;">全窗口函数（</span><span style="color:#000000;">full window functions</span><span style="color:#000000;">） </span></h2> 
        <div></div> 
        <div> 
         <span style="color:#000000;">        窗口操作中的另一大类就是全窗口函数。与增量聚合函数不同，全窗口函数需要先收集窗 </span> 
        </div> 
        <div> 
         <span style="color:#000000;">口中的数据，并在内部缓存起来，等到窗口要输出结果的时候再取出数据进行计算。 </span> 
        </div> 
        <div></div> 
        <div> 
         <span style="color:#000000;">        很明显，这就是典型的批处理思路了——先攒数据，等一批都到齐了再正式启动处理流程。 </span> 
        </div> 
        <div> 
         <span style="color:#000000;">这样做毫无疑问是低效的：因为窗口全部的计算任务都积压在了要输出结果的那一瞬间，而在 </span> 
        </div> 
        <div> 
         <span style="color:#000000;">之前收集数据的漫长过程中却无所事事。这就好比平时不用功，到考试之前通宵抱佛脚，肯定 </span> 
        </div> 
        <div> 
         <span style="color:#000000;">不如把工夫花在日常积累上。 </span> 
        </div> 
        <div></div> 
        <div> 
         <span style="color:#000000;">        那为什么还需要有全窗口函数呢？这是因为有些场景下，我们要做的计算必须基于全部的 </span> 
        </div> 
        <div> 
         <span style="color:#000000;">数据才有效，这时做增量聚合就没什么意义了；另外，输出的结果有可能要包含上下文中的一 </span> 
        </div> 
        <div> 
         <span style="color:#000000;">些信息（比如窗口的起始时间），这是增量聚合函数做不到的。所以，我们还需要有更丰富的 </span> 
        </div> 
        <div> 
         <span style="color:#000000;">窗口计算方式，这就可以用全窗口函数来实现。 </span> 
        </div> 
        <div></div> 
        <div> 
         <span style="color:#000000;">在 </span> 
         <span style="color:#000000;">Flink </span> 
         <span style="color:#000000;">中，全窗口函数也有两种：</span> 
         <strong><span style="color:#000000;">WindowFunction </span><span style="color:#000000;">和 </span><span style="color:#000000;">ProcessWindowFunction</span><span style="color:#000000;">。 </span></strong> 
        </div> 
        <div></div> 
        <h3 id="%EF%BC%881%EF%BC%89%E7%AA%97%E5%8F%A3%E5%87%BD%E6%95%B0%EF%BC%88WindowFunction%EF%BC%89"><span style="color:#000000;"><strong>（</strong></span><span style="color:#000000;"><strong>1</strong></span><span style="color:#000000;"><strong>）窗口函数（</strong></span><span style="color:#000000;"><strong>WindowFunction</strong></span><span style="color:#000000;"><strong>） </strong></span></h3> 
        <div></div> 
        <div> 
         <span style="color:#000000;">        WindowFunction 字面上就是“窗口函数”，它其实是老版本的通用窗口函数接口。我们可 </span> 
        </div> 
        <div> 
         <span style="color:#000000;">以基于 </span> 
         <span style="color:#000000;">WindowedStream </span> 
         <span style="color:#000000;">调用</span> 
         <span style="color:#000000;">.apply()</span> 
         <span style="color:#000000;">方法，传入一个 </span> 
         <span style="color:#000000;">WindowFunction </span> 
         <span style="color:#000000;">的实现类。 </span> 
        </div> 
        <div> 
         <pre><code class="language-java">stream
 .keyBy(&lt;key selector&gt;)
 .window(&lt;window assigner&gt;)
 .apply(new MyWindowFunction());</code></pre> 
         <div> 
          <span style="color:#000000;">        这个类中可以获取到包含窗口所有数据的可迭代集合（Iterable</span> 
          <span style="color:#000000;">），还可以拿到窗口 </span> 
         </div> 
         <div> 
          <span style="color:#000000;">（</span> 
          <span style="color:#000000;">Window</span> 
          <span style="color:#000000;">）本身的信息。</span> 
          <span style="color:#000000;">WindowFunction </span> 
          <span style="color:#000000;">接口在源码中实现如下：</span> 
         </div> 
         <div> 
          <pre><code class="language-java">public interface WindowFunction&lt;IN, OUT, KEY, W extends Window&gt; extends Function, 
Serializable {
void apply(KEY key, W window, Iterable&lt;IN&gt; input, Collector&lt;OUT&gt; out) throws 
Exception;
}</code></pre> 
          <div> 
           <span style="color:#000000;">        当窗口到达结束时间需要触发计算时，就会调用这里的 apply </span> 
           <span style="color:#000000;">方法。我们可以从 </span> 
           <span style="color:#000000;">input </span> 
           <span style="color:#000000;">集 </span> 
          </div> 
          <div> 
           <span style="color:#000000;">合中取出窗口收集的数据，结合 </span> 
           <span style="color:#000000;">key </span> 
           <span style="color:#000000;">和 </span> 
           <span style="color:#000000;">window </span> 
           <span style="color:#000000;">信息，通过收集器（</span> 
           <span style="color:#000000;">Collector</span> 
           <span style="color:#000000;">）输出结果。这 </span> 
          </div> 
          <div> 
           <span style="color:#000000;">里 </span> 
           <span style="color:#000000;">Collector </span> 
           <span style="color:#000000;">的用法，与 </span> 
           <span style="color:#000000;">FlatMapFunction </span> 
           <span style="color:#000000;">中相同。 </span> 
          </div> 
          <div></div> 
          <div> 
           <span style="color:#000000;">        不过我们也看到了，WindowFunction </span> 
           <span style="color:#000000;">能提供的上下文信息较少，也没有更高级的功能。 </span> 
          </div> 
          <div></div> 
          <div> 
           <span style="color:#000000;">        事实上，它的作用可以被 ProcessWindowFunction </span> 
           <span style="color:#000000;">全覆盖，所以之后可能会逐渐弃用。一般在 </span> 
          </div> 
          <div> 
           <span style="color:#000000;">实际应用，直接使用 </span> 
           <span style="color:#000000;">ProcessWindowFunction </span> 
           <span style="color:#000000;">就可以了。 </span> 
          </div> 
          <div></div> 
          <h3 id="%EF%BC%882%EF%BC%89%E5%A4%84%E7%90%86%E7%AA%97%E5%8F%A3%E5%87%BD%E6%95%B0%EF%BC%88ProcessWindowFunction%EF%BC%89"><span style="color:#000000;"><strong>（</strong></span><span style="color:#000000;"><strong>2</strong></span><span style="color:#000000;"><strong>）处理窗口函数（</strong></span><span style="color:#000000;"><strong>ProcessWindowFunction</strong></span><span style="color:#000000;"><strong>） </strong></span></h3> 
          <div></div> 
          <div> 
           <span style="color:#000000;">        ProcessWindowFunction 是 </span> 
           <span style="color:#000000;">Window API </span> 
           <span style="color:#000000;">中最底层的通用窗口函数接口。之所以说它“最底 </span> 
          </div> 
          <div> 
           <span style="color:#000000;">层”，是因为除了可以拿到窗口中的所有数据之外，</span> 
           <span style="color:#000000;">ProcessWindowFunction </span> 
           <span style="color:#000000;">还可以获取到一个</span> 
          </div> 
          <div> 
           <div> 
            <span style="color:#000000;">“上下文对象”（</span> 
            <span style="color:#000000;">Context</span> 
            <span style="color:#000000;">）。这个上下文对象非常强大，不仅能够获取窗口信息，还可以访问当 </span> 
           </div> 
           <div> 
            <span style="color:#000000;">前的时间和状态信息。这里的时间就包括了处理时间（</span> 
            <span style="color:#000000;">processing time</span> 
            <span style="color:#000000;">）和事件时间水位线（</span> 
            <span style="color:#000000;">eventtime watermark）。这就使得 </span> 
            <span style="color:#000000;">ProcessWindowFunction </span> 
            <span style="color:#000000;">更加灵活、功能更加丰富。事实上， ProcessWindowFunction 是 </span> 
            <span style="color:#000000;">Flink </span> 
            <span style="color:#000000;">底层 </span> 
            <span style="color:#000000;">API</span> 
            <span style="color:#000000;">——处理函数（</span> 
            <span style="color:#000000;">process function</span> 
            <span style="color:#000000;">）中的一员，关于处 理函数我们会在后续章节展开讲解。 </span> 
           </div> 
           <div></div> 
           <div> 
            <span style="color:#000000;">        当 然 ， 这 些 好 处 是 以 牺 牲 性 能 和 资 源 为 代 价 的 。 作 为 一 个 全 窗 口 函 数 ， </span> 
           </div> 
           <div> 
            <span style="color:#000000;">ProcessWindowFunction </span> 
            <span style="color:#000000;">同样需要将所有数据缓存下来、等到窗口触发计算时才使用。它其实 </span> 
           </div> 
           <div> 
            <span style="color:#000000;">就是一个增强版的 </span> 
            <span style="color:#000000;">WindowFunction</span> 
            <span style="color:#000000;">。</span> 
           </div> 
           <div></div> 
           <div> 
            <span style="color:#000000;">        具体使用跟 WindowFunction 非常类似，我们可以基于 </span> 
            <span style="color:#000000;">WindowedStream </span> 
            <span style="color:#000000;">调用</span> 
            <span style="color:#000000;">.process()</span> 
            <span style="color:#000000;">方 法，传入一个 ProcessWindowFunction </span> 
            <span style="color:#000000;">的实现类。</span> 
           </div> 
           <div></div> 
           <div> 
            <span style="color:#000000;">下面是一个电商网站统计每小时 </span> 
            <span style="color:#000000;">UV </span> 
            <span style="color:#000000;">的例子：</span> 
           </div> 
           <div> 
            <pre><code class="language-java">import org.apache.flink.api.common.eventtime.SerializableTimestampAssigner;
import org.apache.flink.api.common.eventtime.WatermarkStrategy;
import org.apache.flink.streaming.api.datastream.SingleOutputStreamOperator;
import org.apache.flink.streaming.api.environment.StreamExecutionEnvironment;
import
org.apache.flink.streaming.api.functions.windowing.ProcessWindowFunction;
import 
org.apache.flink.streaming.api.windowing.assigners.TumblingEventTimeWindows;
import org.apache.flink.streaming.api.windowing.time.Time;
import org.apache.flink.streaming.api.windowing.windows.TimeWindow;
import org.apache.flink.util.Collector;
import java.sql.Timestamp;
import java.util.HashSet;
public class UvCountByWindowExample {
 public static void main(String[] args) throws Exception {
 StreamExecutionEnvironment env = 
StreamExecutionEnvironment.getExecutionEnvironment();
 env.setParallelism(1);
 SingleOutputStreamOperator&lt;Event&gt; stream = env.addSource(new 
ClickSource())
 .assignTimestampsAndWatermarks(WatermarkStrategy.&lt;Event&gt;forBound
edOutOfOrderness(Duration.ZERO)
 .withTimestampAssigner(new 
SerializableTimestampAssigner&lt;Event&gt;() {
 @Override
 public long extractTimestamp(Event element, long 
recordTimestamp) {
 return element.timestamp;
 }
 }));
 // 将数据全部发往同一分区，按窗口统计 UV
 stream.keyBy(data -&gt; true)
 .window(TumblingEventTimeWindows.of(Time.seconds(10)))
 .process(new UvCountByWindow())
 .print();
 env.execute();
 }
 // 自定义窗口处理函数
 public static class UvCountByWindow extends ProcessWindowFunction&lt;Event, 
String, Boolean, TimeWindow&gt;{
 @Override
 public void process(Boolean aBoolean, Context context, Iterable&lt;Event&gt; 
elements, Collector&lt;String&gt; out) throws Exception {
 HashSet&lt;String&gt; userSet = new HashSet&lt;&gt;();
 // 遍历所有数据，放到 Set 里去重
 for (Event event: elements){
 userSet.add(event.user);
 }
 // 结合窗口信息，包装输出内容
 Long start = context.window().getStart();
 Long end = context.window().getEnd();
 out.collect(" 窗 口 : " + new Timestamp(start) + " ~ " + new 
Timestamp(end)
 + " 的独立访客数量是：" + userSet.size());
 }
 }
}</code></pre> 
            <div> 
             <span style="color:#000000;">        这里我们使用的是事件时间语义。定义 10 </span> 
             <span style="color:#000000;">秒钟的滚动事件窗口后，直接使用 </span> 
            </div> 
            <div> 
             <span style="color:#000000;">ProcessWindowFunction </span> 
             <span style="color:#000000;">来定义处理的逻辑。我们可以创建一个 </span> 
             <span style="color:#000000;">HashSet</span> 
             <span style="color:#000000;">，将窗口所有数据的 </span> 
            </div> 
            <div> 
             <span style="color:#000000;">userId </span> 
             <span style="color:#000000;">写入实现去重，最终得到 </span> 
             <span style="color:#000000;">HashSet </span> 
             <span style="color:#000000;">的元素个数就是 </span> 
             <span style="color:#000000;">UV </span> 
             <span style="color:#000000;">值。 </span> 
            </div> 
            <div></div> 
            <div> 
             <span style="color:#000000;">        当 然 ， 这 里 我 们 并 没 有 用 到 上 下 文 中 其 他 信 息 ， 所 以 其 实 没 有 必 要 使 用 </span> 
            </div> 
            <div> 
             <span style="color:#000000;">ProcessWindowFunction</span> 
             <span style="color:#000000;">。全窗口函数因为运行效率较低，很少直接单独使用，往往会和增量 </span> 
            </div> 
            <div> 
             <span style="color:#000000;">聚合函数结合在一起，共同实现窗口的处理计算。 </span> 
            </div> 
            <div></div> 
            <div> 
             <h2 id="3.%20%E5%A2%9E%E9%87%8F%E8%81%9A%E5%90%88%E5%92%8C%E5%85%A8%E7%AA%97%E5%8F%A3%E5%87%BD%E6%95%B0%E7%9A%84%E7%BB%93%E5%90%88%E4%BD%BF%E7%94%A8"><span style="color:#000000;">3. </span><span style="color:#000000;">增量聚合和全窗口函数的结合使用 </span></h2> 
             <div></div> 
             <div> 
              <span style="color:#000000;">        我们已经了解了 Window API </span> 
              <span style="color:#000000;">中两类窗口函数的用法，下面我们先来做个简单的总结。 </span> 
             </div> 
             <div> 
              <span style="color:#000000;">增量聚合函数处理计算会更高效。举一个最简单的例子，对一组数据求和。大量的数据连 </span> 
             </div> 
             <div> 
              <span style="color:#000000;">续不断到来，全窗口函数只是把它们收集缓存起来，并没有处理；到了窗口要关闭、输出结果 </span> 
             </div> 
             <div> 
              <span style="color:#000000;">的时候，再遍历所有数据依次叠加，得到最终结果。而如果我们采用增量聚合的方式，那么只 </span> 
             </div> 
             <div> 
              <span style="color:#000000;">需要保存一个当前和的状态，每个数据到来时就会做一次加法，更新状态；到了要输出结果的 </span> 
             </div> 
             <div> 
              <span style="color:#000000;">时候，只要将当前状态直接拿出来就可以了。增量聚合相当于把计算量“均摊”到了窗口收集 </span> 
             </div> 
             <div> 
              <span style="color:#000000;">数据的过程中，自然就会比全窗口聚合更加高效、输出更加实时。 </span> 
             </div> 
             <div></div> 
             <div> 
              <span style="color:#000000;">        而全窗口函数的优势在于提供了更多的信息，可以认为是更加“通用”的窗口操作。它只 </span> 
             </div> 
             <div> 
              <span style="color:#000000;">负责收集数据、提供上下文相关信息，把所有的原材料都准备好，至于拿来做什么我们完全可 </span> 
             </div> 
             <div> 
              <span style="color:#000000;">以任意发挥。这就使得窗口计算更加灵活，功能更加强大。 </span> 
             </div> 
             <div></div> 
             <div> 
              <span style="color:#000000;">        所以在实际应用中，我们往往希望兼具这两者的优点，把它们结合在一起使用。Flink </span> 
              <span style="color:#000000;">的 </span> 
             </div> 
             <div> 
              <span style="color:#000000;">Window API </span> 
              <span style="color:#000000;">就给我们实现了这样的用法。 </span> 
             </div> 
             <div></div> 
             <div> 
              <span style="color:#000000;">        我们之前在调用 WindowedStream </span> 
              <span style="color:#000000;">的</span> 
              <span style="color:#000000;">.reduce()</span> 
              <span style="color:#000000;">和</span> 
              <span style="color:#000000;">.aggregate()</span> 
              <span style="color:#000000;">方法时，只是简单地直接传入 </span> 
             </div> 
             <div> 
              <span style="color:#000000;">了一个 </span> 
              <span style="color:#000000;">ReduceFunction </span> 
              <span style="color:#000000;">或 </span> 
              <span style="color:#000000;">AggregateFunction </span> 
              <span style="color:#000000;">进行增量聚合。除此之外，其实还可以传入第二 </span> 
             </div> 
             <div> 
              <span style="color:#000000;">个参数：一个全窗口函数，可以是 </span> 
              <span style="color:#000000;">WindowFunction </span> 
              <span style="color:#000000;">或者 </span> 
              <span style="color:#000000;">ProcessWindowFunction</span> 
              <span style="color:#000000;">。</span> 
             </div> 
             <div></div> 
             <div> 
              <pre><code class="language-java">// ReduceFunction 与 WindowFunction 结合
public &lt;R&gt; SingleOutputStreamOperator&lt;R&gt; reduce(
 ReduceFunction&lt;T&gt; reduceFunction, WindowFunction&lt;T, R, K, W&gt; function) 
// ReduceFunction 与 ProcessWindowFunction 结合
public &lt;R&gt; SingleOutputStreamOperator&lt;R&gt; reduce(
 ReduceFunction&lt;T&gt; reduceFunction, ProcessWindowFunction&lt;T, R, K, W&gt; 
function)
// AggregateFunction 与 WindowFunction 结合
public &lt;ACC, V, R&gt; SingleOutputStreamOperator&lt;R&gt; aggregate(
 AggregateFunction&lt;T, ACC, V&gt; aggFunction, WindowFunction&lt;V, R, K, W&gt; 
windowFunction)
// AggregateFunction 与 ProcessWindowFunction 结合
public &lt;ACC, V, R&gt; SingleOutputStreamOperator&lt;R&gt; aggregate(
 AggregateFunction&lt;T, ACC, V&gt; aggFunction,
 ProcessWindowFunction&lt;V, R, K, W&gt; windowFunction)</code></pre> 
              <div> 
               <span style="color:#000000;">        </span> 
               <span style="color:#fe2c24;">这样调用的处理机制是：基于第一个参数（增量聚合函数）来处理窗口数据，每来一个数 </span> 
              </div> 
              <div> 
               <span style="color:#fe2c24;">据就做一次聚合；等到窗口需要触发计算时，则调用第二个参数（全窗口函数）的处理逻辑输 </span> 
              </div> 
              <div> 
               <span style="color:#fe2c24;">出结果。需要注意的是，这里的全窗口函数就不再缓存所有数据了，而是直接将增量聚合函数 </span> 
              </div> 
              <div> 
               <span style="color:#fe2c24;">的结果拿来当作了 Iterable 类型的输入。一般情况下，这时的可迭代集合中就只有一个元素了。 </span> 
              </div> 
              <div></div> 
              <div> 
               <span style="color:#000000;">        下面我们举一个具体的实例来说明。在网站的各种统计指标中，一个很重要的统计指标就 </span> 
              </div> 
              <div> 
               <span style="color:#000000;">是热门的链接；想要得到热门的 </span> 
               <span style="color:#000000;">url</span> 
               <span style="color:#000000;">，前提是得到每个链接的“热门度”。一般情况下，可以用 </span> 
              </div> 
              <div> 
               <span style="color:#000000;">url </span> 
               <span style="color:#000000;">的浏览量（点击量）表示热门度。我们这里统计 </span> 
               <span style="color:#000000;">10 </span> 
               <span style="color:#000000;">秒钟的 </span> 
               <span style="color:#000000;">url </span> 
               <span style="color:#000000;">浏览量，每 </span> 
               <span style="color:#000000;">5 </span> 
               <span style="color:#000000;">秒钟更新一次； </span> 
              </div> 
              <div> 
               <span style="color:#000000;">另外为了更加清晰地展示，还应该把窗口的起始结束时间一起输出。我们可以定义滑动窗口， </span> 
              </div> 
              <div> 
               <span style="color:#000000;">并结合增量聚合函数和全窗口函数来得到统计结果。 </span> 
              </div> 
              <div></div> 
              <div> 
               <span style="color:#000000;">        具体实现代码如下：</span> 
              </div> 
              <div> 
               <pre><code class="language-java">import org.apache.flink.api.common.eventtime.SerializableTimestampAssigner;
import org.apache.flink.api.common.eventtime.WatermarkStrategy;
import org.apache.flink.api.common.functions.AggregateFunction;
import org.apache.flink.streaming.api.datastream.SingleOutputStreamOperator;
import org.apache.flink.streaming.api.environment.StreamExecutionEnvironment;
import 
org.apache.flink.streaming.api.functions.windowing.ProcessWindowFunction;
import 
org.apache.flink.streaming.api.windowing.assigners.SlidingEventTimeWindows;
import org.apache.flink.streaming.api.windowing.time.Time;
import org.apache.flink.streaming.api.windowing.windows.TimeWindow;
import org.apache.flink.util.Collector;
public class UrlViewCountExample {
 public static void main(String[] args) throws Exception {
 StreamExecutionEnvironment env = 
StreamExecutionEnvironment.getExecutionEnvironment();
 env.setParallelism(1);
 SingleOutputStreamOperator&lt;Event&gt; stream = env.addSource(new 
ClickSource())
 .assignTimestampsAndWatermarks(WatermarkStrategy.&lt;Event&gt;forMonot
onousTimestamps()
 .withTimestampAssigner(new 
SerializableTimestampAssigner&lt;Event&gt;() {
 @Override
 public long extractTimestamp(Event element, long 
recordTimestamp) {
 return element.timestamp;
 }
 }));
 // 需要按照 url 分组，开滑动窗口统计
 stream.keyBy(data -&gt; data.url)
 .window(SlidingEventTimeWindows.of(Time.seconds(10), 
Time.seconds(5)))
 // 同时传入增量聚合函数和全窗口函数
 .aggregate(new UrlViewCountAgg(), new UrlViewCountResult())
 .print();
 env.execute();
 }
 // 自定义增量聚合函数，来一条数据就加一
 public static class UrlViewCountAgg implements AggregateFunction&lt;Event, Long, 
Long&gt; {
 @Override
 public Long createAccumulator() {
 return 0L;
 }
 @Override
 public Long add(Event value, Long accumulator) {
 return accumulator + 1;
 }
 @Override
 public Long getResult(Long accumulator) {
 return accumulator;
 }
 @Override
 public Long merge(Long a, Long b) {
 return null;
 }
 }
 // 自定义窗口处理函数，只需要包装窗口信息
 public static class UrlViewCountResult extends ProcessWindowFunction&lt;Long, 
UrlViewCount, String, TimeWindow&gt; {
 @Override
 public void process(String url, Context context, Iterable&lt;Long&gt; elements, 
Collector&lt;UrlViewCount&gt; out) throws Exception {
 // 结合窗口信息，包装输出内容
 Long start = context.window().getStart();
 Long end = context.window().getEnd();
 // 迭代器中只有一个元素，就是增量聚合函数的计算结果
 out.collect(new UrlViewCount(url, elements.iterator().next(), start, 
end));
 }
 }
}</code></pre> 
               <div> 
                <span style="color:#000000;">        这里我们为了方便处理，单独定义了一个 POJO </span> 
                <span style="color:#000000;">类 </span> 
                <span style="color:#000000;">UrlViewCount </span> 
                <span style="color:#000000;">来表示聚合输出结果的 </span> 
               </div> 
               <div> 
                <span style="color:#000000;">数据类型，包含了 </span> 
                <span style="color:#000000;">url</span> 
                <span style="color:#000000;">、浏览量以及窗口的起始结束时间。 </span> 
               </div> 
               <div> 
                <pre><code class="language-java">import java.sql.Timestamp;
public class UrlViewCount {
 public String url;
 public Long count;
 public Long windowStart;
 public Long windowEnd;
 public UrlViewCount() {
 }
 public UrlViewCount(String url, Long count, Long windowStart, Long windowEnd) 
{
 this.url = url;
 this.count = count;
 this.windowStart = windowStart;
 this.windowEnd = windowEnd;
 }
 @Override
 public String toString() {
 return "UrlViewCount{" +
 "url='" + url + '\'' +
 ", count=" + count +
 ", windowStart=" + new Timestamp(windowStart) +
 ", windowEnd=" + new Timestamp(windowEnd) +
 '}';
 }
}</code></pre> 
                <div> 
                 <span style="color:#000000;">        代码中用一个 AggregateFunction </span> 
                 <span style="color:#000000;">来实现增量聚合，每来一个数据就计数加一；得到的结 </span> 
                </div> 
                <div> 
                 <span style="color:#000000;">果交给 </span> 
                 <span style="color:#000000;">ProcessWindowFunction</span> 
                 <span style="color:#000000;">，结合窗口信息包装成我们想要的 </span> 
                 <span style="color:#000000;">UrlViewCount</span> 
                 <span style="color:#000000;">，最终输出统 </span> 
                </div> 
                <div> 
                 <span style="color:#000000;">计结果。 </span> 
                </div> 
                <div> 
                 <span style="color:#000000;">        注：ProcessWindowFunction </span> 
                 <span style="color:#000000;">是处理函数中的一种，后面我们会详细讲解。这里只用它来 </span> 
                </div> 
                <div> 
                 <span style="color:#000000;">将增量聚合函数的输出结果包裹一层窗口信息。 </span> 
                </div> 
                <div></div> 
                <div> 
                 <span style="color:#000000;">        窗口处理的主体还是增量聚合，而引入全窗口函数又可以获取到更多的信息包装输出，这 </span> 
                </div> 
                <div> 
                 <span style="color:#000000;">样的结合兼具了两种窗口函数的优势，在保证处理性能和实时性的同时支持了更加丰富的应用 </span> 
                </div> 
                <div> 
                 <span style="color:#000000;">场景。 </span> 
                </div> 
                <div></div> 
                <h2 id="4%E3%80%81%E7%AA%97%E5%8F%A3%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F"><span style="color:#000000;">4、窗口的生命周期</span></h2> 
                <h3 id="1.%20%E7%AA%97%E5%8F%A3%E7%9A%84%E5%88%9B%E5%BB%BA"><span style="color:#000000;">1. </span><span style="color:#000000;">窗口的创建 </span></h3> 
                <div></div> 
                <div> 
                 <span style="color:#000000;">        窗口的类型和基本信息由窗口分配器（window assigners</span> 
                 <span style="color:#000000;">）指定，但窗口不会预先创建好， </span> 
                </div> 
                <div> 
                 <span style="color:#000000;">而是由数据驱动创建。当第一个应该属于这个窗口的数据元素到达时，就会创建对应的窗口。 </span> 
                </div> 
                <div></div> 
                <h3 id="2.%20%E7%AA%97%E5%8F%A3%E8%AE%A1%E7%AE%97%E7%9A%84%E8%A7%A6%E5%8F%91"><span style="color:#000000;">2. </span><span style="color:#000000;">窗口计算的触发 </span></h3> 
                <div></div> 
                <div> 
                 <span style="color:#000000;">        除了窗口分配器，每个窗口还会有自己的窗口函数（window functions</span> 
                 <span style="color:#000000;">）和触发器（</span> 
                 <span style="color:#000000;">trigger</span> 
                 <span style="color:#000000;">）。 窗口函数可以分为增量聚合函数和全窗口函数，主要定义了窗口中计算的逻辑；而触发器则是指定调用窗口函数的条件。 </span> 
                </div> 
                <div></div> 
                <div> 
                 <span style="color:#000000;">        对于不同的窗口类型，触发计算的条件也会不同。例如，一个滚动事件时间窗口，应该在 </span> 
                </div> 
                <div> 
                 <span style="color:#000000;">水位线到达窗口结束时间的时候触发计算，属于“定点发车”；而一个计数窗口，会在窗口中 </span> 
                </div> 
                <div> 
                 <span style="color:#000000;">元素数量达到定义大小时触发计算，属于“人满就发车”。所以 </span> 
                 <span style="color:#000000;">Flink </span> 
                 <span style="color:#000000;">预定义的窗口类型都有 </span> 
                </div> 
                <div> 
                 <span style="color:#000000;">对应内置的触发器。 </span> 
                </div> 
                <div></div> 
                <div> 
                 <span style="color:#000000;">        对于事件时间窗口而言，除去到达结束时间的“定点发车”，还有另一种情形。当我们设 </span> 
                </div> 
                <div> 
                 <span style="color:#000000;">置了允许延迟，那么如果水位线超过了窗口结束时间、但还没有到达设定的最大延迟时间，这 </span> 
                </div> 
                <div> 
                 <span style="color:#000000;">期间内到达的迟到数据也会触发窗口计算。这类似于没有准时赶上班车的人又追上了车，这时 </span> 
                </div> 
                <div> 
                 <span style="color:#000000;">车要再次停靠、开门，将新的数据整合统计进来。 </span> 
                </div> 
                <div></div> 
                <h3 id="3.%20%E7%AA%97%E5%8F%A3%E7%9A%84%E9%94%80%E6%AF%81"><span style="color:#000000;">3. </span><span style="color:#000000;">窗口的销毁 </span></h3> 
                <div></div> 
                <div> 
                 <span style="color:#000000;">        一般情况下，当时间达到了结束点，就会直接触发计算输出结果、进而清除状态销毁窗口。 </span> 
                </div> 
                <div> 
                 <span style="color:#000000;">这时窗口的销毁可以认为和触发计算是同一时刻。这里需要注意，</span> 
                 <span style="color:#000000;">Flink </span> 
                 <span style="color:#000000;">中只对时间窗口 </span> 
                </div> 
                <div> 
                 <span style="color:#000000;">（</span> 
                 <span style="color:#000000;">TimeWindow</span> 
                 <span style="color:#000000;">）有销毁机制；由于计数窗口（</span> 
                 <span style="color:#000000;">CountWindow</span> 
                 <span style="color:#000000;">）是基于全局窗口（</span> 
                 <span style="color:#000000;">GlobalWindw</span> 
                 <span style="color:#000000;">） </span> 
                </div> 
                <div> 
                 <span style="color:#000000;">实现的，而全局窗口不会清除状态，所以就不会被销毁。 </span> 
                </div> 
                <div></div> 
                <div> 
                 <span style="color:#000000;">        在特殊的场景下，窗口的销毁和触发计算会有所不同。事件时间语义下，如果设置了允许 </span> 
                </div> 
                <div> 
                 <span style="color:#000000;">延迟，那么在水位线到达窗口结束时间时，仍然不会销毁窗口；窗口真正被完全删除的时间点， </span> 
                </div> 
                <div> 
                 <span style="color:#000000;">是窗口的结束时间加上用户指定的允许延迟时间。 </span> 
                </div> 
                <div></div> 
                <h3 id="4.%20%E7%AA%97%E5%8F%A3%20API%20%E8%B0%83%E7%94%A8%E6%80%BB%E7%BB%93"><span style="color:#000000;">4. </span><span style="color:#000000;">窗口 </span><span style="color:#000000;">API </span><span style="color:#000000;">调用总结 </span></h3> 
                <div></div> 
                <div> 
                 <span style="color:#000000;">        到目前为止，我们已经彻底明白了 Flink </span> 
                 <span style="color:#000000;">中窗口的概念和 </span> 
                 <span style="color:#000000;">Window API </span> 
                 <span style="color:#000000;">的调用，我们再用 </span> 
                </div> 
                <div> 
                 <span style="color:#000000;">一张图做一个完整总结，如图 </span> 
                 <span style="color:#000000;">6-22 </span> 
                 <span style="color:#000000;">所示。</span> 
                </div> 
                <div> 
                 <p class="img-center"><img alt="" height="356" src="https://images2.imgbox.com/74/1c/5p95F7T6_o.png" width="631"></p> 
                </div> 
                <p> </p> 
                <div> 
                 <span style="color:#000000;">        Window API 首先按照时候按键分区分成两类。</span> 
                 <span style="color:#000000;">keyBy </span> 
                 <span style="color:#000000;">之后的 </span> 
                 <span style="color:#000000;">KeyedStream</span> 
                 <span style="color:#000000;">，可以调 </span> 
                </div> 
                <div> 
                 <span style="color:#000000;">用</span> 
                 <span style="color:#000000;">.window()</span> 
                 <span style="color:#000000;">方法声明按键分区窗口（</span> 
                 <span style="color:#000000;">Keyed Windows</span> 
                 <span style="color:#000000;">）；而如果不做 </span> 
                 <span style="color:#000000;">keyBy</span> 
                 <span style="color:#000000;">，</span> 
                 <span style="color:#000000;">DataStream </span> 
                 <span style="color:#000000;">也可 </span> 
                </div> 
                <div> 
                 <span style="color:#000000;">以直接调用</span> 
                 <span style="color:#000000;">.windowAll()</span> 
                 <span style="color:#000000;">声明非按键分区窗口。之后的方法调用就完全一样了。 </span> 
                </div> 
                <div></div> 
                <div> 
                 <span style="color:#000000;">        接下来首先是通过.window()/.windowAll()</span> 
                 <span style="color:#000000;">方法定义窗口分配器，得到 </span> 
                 <span style="color:#000000;">WindowedStream</span> 
                 <span style="color:#000000;">； </span> 
                </div> 
                <div> 
                 <span style="color:#000000;">然 后 通 过 各 种 转 换 方 法 （ </span> 
                 <span style="color:#000000;">reduce/aggregate/apply/process </span> 
                 <span style="color:#000000;">） 给 出 窗 口 函 数 </span> 
                </div> 
                <div> 
                 <span style="color:#000000;">(ReduceFunction/AggregateFunction/ProcessWindowFunction)</span> 
                 <span style="color:#000000;">，定义窗口的具体计算处理逻辑， </span> 
                </div> 
                <div> 
                 <span style="color:#000000;">转换之后重新得到 </span> 
                 <span style="color:#000000;">DataStream</span> 
                 <span style="color:#000000;">。这两者必不可少，是窗口算子（</span> 
                 <span style="color:#000000;">WindowOperator</span> 
                 <span style="color:#000000;">）最重要的组 </span> 
                </div> 
                <div> 
                 <span style="color:#000000;">成部分。 </span> 
                </div> 
                <div></div> 
                <div> 
                 <span style="color:#000000;">        此外，在这两者之间，还可以基于 WindowedStream </span> 
                 <span style="color:#000000;">调用</span> 
                 <span style="color:#000000;">.trigger()</span> 
                 <span style="color:#000000;">自定义触发器、调 </span> 
                </div> 
                <div> 
                 <span style="color:#000000;">用</span> 
                 <span style="color:#000000;">.evictor()</span> 
                 <span style="color:#000000;">定义移除器、调用</span> 
                 <span style="color:#000000;">.allowedLateness()</span> 
                 <span style="color:#000000;">指定允许延迟时间、调用</span> 
                 <span style="color:#000000;">.sideOutputLateData() </span> 
                </div> 
                <div> 
                 <span style="color:#000000;">将迟到数据写入侧输出流，这些都是可选的 </span> 
                 <span style="color:#000000;">API</span> 
                 <span style="color:#000000;">，一般不需要实现。而如果定义了侧输出流， </span> 
                </div> 
                <div> 
                 <span style="color:#000000;">可以基于窗口聚合之后的 </span> 
                 <span style="color:#000000;">DataStream </span> 
                 <span style="color:#000000;">调用</span> 
                 <span style="color:#000000;">.getSideOutput()</span> 
                 <span style="color:#000000;">获取侧输出流。 </span> 
                </div> 
               </div> 
              </div> 
             </div> 
            </div> 
           </div> 
           <div></div> 
          </div> 
         </div> 
        </div> 
       </div> 
      </div> 
     </div> 
    </div> 
   </div> 
  </div> 
 </div> 
</div>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/22b7f1487b0e6c819381a29701f1ac05/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">智慧监狱UWB定位系统解决方案</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/7203fa6fd74b1da33c20220b4b944567/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">盘点一下PostgreSQL和MySQL的区别点</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>