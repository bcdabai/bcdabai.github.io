<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>C#泛型的理解 - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="C#泛型的理解" />
<meta property="og:description" content="一.为什么要使用泛型 1.比如我们又如下三个方法：
/// &lt;summary&gt; /// 打印个int值 /// &lt;/summary&gt; /// &lt;param name=&#34;parameter&#34;&gt;&lt;/param&gt; public static void ShowInt(int parameter) { Console.WriteLine(&#34;This is {0},parameter={1},type={2}&#34;, typeof(CommonMethod).Name, parameter.GetType().Name, parameter); } /// &lt;summary&gt; /// 打印个string值 /// &lt;/summary&gt; /// &lt;param name=&#34;parameter&#34;&gt;&lt;/param&gt; public static void ShowString(string parameter) { Console.WriteLine(&#34;This is {0},parameter={1},type={2}&#34;, typeof(CommonMethod).Name, parameter.GetType().Name, parameter); } /// &lt;summary&gt; /// 打印个DateTime值 /// &lt;/summary&gt; /// &lt;param name=&#34;parameter&#34;&gt;&lt;/param&gt; public static void ShowDateTime(DateTime parameter) { Console.WriteLine(&#34;This is {0},parameter={1},type={2}&#34;, typeof(CommonMethod).Name, parameter.GetType().Name, parameter); } 调用：" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/ae0c994d421ed6d04b438b0d67853530/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-05-09T14:46:14+08:00" />
<meta property="article:modified_time" content="2022-05-09T14:46:14+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">C#泛型的理解</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <h3>一.为什么要使用泛型</h3> 
<p>1.比如我们又如下三个方法：</p> 
<pre><code>        /// &lt;summary&gt;
        /// 打印个int值 
        /// &lt;/summary&gt;
        /// &lt;param name="parameter"&gt;&lt;/param&gt;
        public static void ShowInt(int parameter)
        {
            Console.WriteLine("This is {0},parameter={1},type={2}",
                typeof(CommonMethod).Name, parameter.GetType().Name, parameter);
        }

        /// &lt;summary&gt;
        /// 打印个string值
        /// &lt;/summary&gt;
        /// &lt;param name="parameter"&gt;&lt;/param&gt;
        public static void ShowString(string parameter)
        {
            Console.WriteLine("This is {0},parameter={1},type={2}",
                typeof(CommonMethod).Name, parameter.GetType().Name, parameter);
        }
        /// &lt;summary&gt;
        /// 打印个DateTime值
        /// &lt;/summary&gt;
        /// &lt;param name="parameter"&gt;&lt;/param&gt; 
        public static void ShowDateTime(DateTime parameter)
        {
            Console.WriteLine("This is {0},parameter={1},type={2}",
                typeof(CommonMethod).Name, parameter.GetType().Name, parameter);
        }</code></pre> 
<p>调用：</p> 
<pre><code>                int iValue = 123;
                string sValue = "456";
                DateTime dtValue = DateTime.Now;
                CommonMethod.ShowInt(iValue);
                CommonMethod.ShowString(sValue);
                CommonMethod.ShowDateTime(dtValue);</code></pre> 
<p></p> 
<p>        思考：我们可以看到这三个方法基本相同只是参数类型不同，那么我们怎么同一个方法来写呢？</p> 
<p>        可能大家首先考虑的是object。</p> 
<p>        那么我们先用object实现</p> 
<pre><code>        /// &lt;summary&gt;
        /// 打印个object值   
        /// &lt;/summary&gt;
        /// &lt;param name="oParameter"&gt;&lt;/param&gt;
        public static void ShowObject(object oParameter)
        {
            Console.WriteLine("This is {0},parameter={1},type={2}",
                typeof(CommonMethod), oParameter.GetType().Name, oParameter);
        }




        //调用
                object oValue = "678";
                CommonMethod.ShowObject(iValue);
                CommonMethod.ShowObject(sValue);
                CommonMethod.ShowObject(dtValue);
                CommonMethod.ShowObject(oValue);</code></pre> 
<p>1.但是我们都知道object是引用类型，存在堆内存中。值类型存在栈内存中。所以上面存在装箱和拆箱。首先值类型先要变成引用类型装箱过程，后面方法执行又要变成值类型拆箱过程。还是一个很消耗资源的过程。这就是性能消耗问题</p> 
<p>2.同时存在类型安全问题。比如我再showObject写int a= Convert.ToInt32(oParameter);他在编译的时候不会报错，但是在执行的时候传入不能转成int类型的就会出错。这就是类型安全问题</p> 
<pre><code>        /// &lt;summary&gt;
        /// 打印个object值   
        /// &lt;/summary&gt;
        /// &lt;param name="oParameter"&gt;&lt;/param&gt;
        public static void ShowObject(object oParameter)
        {
            Console.WriteLine("This is {0},parameter={1},type={2}",
                typeof(CommonMethod), oParameter.GetType().Name, oParameter);
            int a= Convert.ToInt32(oParameter);//添加
        }
</code></pre> 
<p>为了解决这两个问题同时又支持一个方法可以传不同的参数类型，所以就出现了泛型.</p> 
<p>泛型的优势：比object的性能又快，同时不会出现类型安全问题。（因为在编译时有类型问题就会直接报错）</p> 
<p>一、泛型原理：泛型在经过编译以后没有确定类型，它是在运行时CLR 中的及时编译器（jit），确定是某一个具体的类型； </p> 
<p>二、泛型的设计<br>                 1.声明的时候有一个占位符----不确定他的类型<br>                 2.运行的时候确定类型---延迟声明； </p> 
<p>泛型有：泛型方法，泛型类(比如List类)，泛型委托，泛型接口等。</p> 
<pre><code>        /// &lt;summary&gt;
        /// 泛型方法：不同类型
        /// &lt;/summary&gt;
        /// &lt;typeparam name="T"&gt;&lt;/typeparam&gt;
        /// &lt;param name="tPrarameter"&gt;&lt;/param&gt;
        public static void ShowGeneric&lt;T&gt;(T tPrarameter)
        {
            Console.WriteLine("This is {0},parameter={1},type={2}",
               typeof(CommonMethod), tPrarameter.GetType().Name, tPrarameter);
        }


        //调用
                int iValue = 123;
                string sValue = "456";
                DateTime dtValue = DateTime.Now;
                CommonMethod.ShowGeneric&lt;int&gt;(iValue); //
                CommonMethod.ShowGeneric&lt;string&gt;(sValue);
                CommonMethod.ShowGeneric&lt;DateTime&gt;(dtValue);
                CommonMethod.ShowGeneric(oValue);</code></pre> 
<p>泛型方法的特点：</p> 
<p>                1.调用的时候---指定类型<br>                 2.指定的类型必须和参数类型一致<br>                 3.在调用的时候，如果可以根据参数推导出类型，尖括号中的类型声明可以省略不写；</p> 
<p>泛型是如何解决类型安全问题的呢？答案是通过泛型约束</p> 
<p>比如我用这些基础类.</p> 
<pre><code class="language-cs">using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace AspNetCore.Generic
{
    public interface ISports
    {
        void Pingpang();
    }

    public interface IWork
    {
        void Work();
    }


    public class People
    {
        public People()
        {

        }
         
        public int Id { get; set; }
        public string Name { get; set; }

        public void Hi()
        { }

    }

    public class Chinese : People, ISports, IWork
    {
         
        public void Tradition()
        {
            Console.WriteLine("仁义礼智信，温良恭俭让");
        }
        public void SayHi()
        {
            Console.WriteLine("吃了么？");
        }

        public void Pingpang()
        {
            Console.WriteLine("打乒乓球...");
        }

        public void Work()
        {
            throw new NotImplementedException();
        }
    }

    public class Hubei : Chinese
    { 
        public string Changjiang { get; set; }
        public void Majiang()
        {
            Console.WriteLine("打麻将啦。。");
        }
    }


    public class Japanese : ISports
    {
        public int Id { get; set; }
        public string Name { get; set; }


        public void Pingpang()
        {
            Console.WriteLine("打乒乓球...");
        }
    }
}
</code></pre> 
<p>类型约束：</p> 
<pre><code class="language-cs">        /// &lt;summary&gt;  
        /// 基类约束，限定必须是People类
        /// &lt;/summary&gt;
        /// &lt;typeparam name="T"&gt;&lt;/typeparam&gt;
        /// &lt;param name="oParameter"&gt;&lt;/param&gt;
        public static void Show&lt;T&gt;(T tParameter)   where T:People
        {
            Console.WriteLine("This is {0},parameter={1},type={2}",
                typeof(CommonMethod), tParameter.GetType().Name, tParameter); 
            Console.WriteLine($"People.Id={tParameter.Id}");
            Console.WriteLine($"People.Id={tParameter.Name}");
        }


        /// &lt;summary&gt;
        /// 接口约束：限定T 是ISports接口或者是ISports实现类；
        /// &lt;/summary&gt;
        /// &lt;typeparam name="T"&gt;&lt;/typeparam&gt;
        /// &lt;param name="tParameter"&gt;&lt;/param&gt;
        public static void ShowInterface&lt;T&gt;(T tParameter) where T : ISports
        {
            Console.WriteLine("This is {0},parameter={1},type={2}",
                typeof(CommonMethod), tParameter.GetType().Name, tParameter);
            //Console.WriteLine($"People.Id={tParameter.Id}");
            //Console.WriteLine($"People.Id={tParameter.Name}");
            tParameter.Pingpang();
        }

        /// &lt;summary&gt;
        /// 引用类型约束 约束T 必须是引用类型
        /// &lt;/summary&gt;
        /// &lt;typeparam name="T"&gt;&lt;/typeparam&gt;
        /// &lt;param name="tParameter"&gt;&lt;/param&gt;
        public static void ShowClass&lt;T&gt;(T tParameter) where T : class
        {
            Console.WriteLine("This is {0},parameter={1},type={2}",
                typeof(CommonMethod), tParameter.GetType().Name, tParameter); 
        }

        /// &lt;summary&gt;
        ///值类型约束： 约束T 必须是值类型
        /// &lt;/summary&gt;
        /// &lt;typeparam name="T"&gt;&lt;/typeparam&gt;
        /// &lt;param name="tParameter"&gt;&lt;/param&gt;
        public static void ShowStruct&lt;T&gt;(T tParameter) where T : struct
        {
            Console.WriteLine("This is {0},parameter={1},type={2}",
                typeof(CommonMethod), tParameter.GetType().Name, tParameter);
        }


        /// &lt;summary&gt;
        ///无参数构造函数约束： 约束T 必须有一个无参数构造函数  也就是可以直接New
        /// &lt;/summary&gt;
        /// &lt;typeparam name="T"&gt;&lt;/typeparam&gt;
        /// &lt;param name="tParameter"&gt;&lt;/param&gt;
        public static void ShowNew&lt;T&gt;(T tParameter) where T : new()
        {
            Console.WriteLine("This is {0},parameter={1},type={2}",
                typeof(CommonMethod), tParameter.GetType().Name, tParameter);
        }</code></pre> 
<p> 调用：</p> 
<pre><code class="language-cs">                    {
                        Console.WriteLine("***********************基类约束**************************");
                        GenericConstraint.Show(people);
                        GenericConstraint.Show(chinese);
                        GenericConstraint.Show(hubei);
                        //GenericConstraint.Show(japanese); //不是这个类型 编译器就直接报错；开发者就明确了错误；
                    }

                    {
                        //Console.WriteLine("***********************接口约束**************************");
                        GenericConstraint.ShowInterface(people);
                        //GenericConstraint.ShowInterface(chinese);
                        //GenericConstraint.ShowInterface(hubei);
                        //GenericConstraint.ShowInterface(japanese); //不是这个类型 编译器就直接报错；开发者就明确了错误；
                    }


                    {
                        Console.WriteLine("***********************引用类型约束**************************");
                        GenericConstraint.ShowClass(people);
                        GenericConstraint.ShowClass(chinese);
                        GenericConstraint.ShowClass(hubei);
                        GenericConstraint.ShowClass(japanese); 
                        //GenericConstraint.ShowClass(iValue);
                        //GenericConstraint.ShowClass(sValue);
                        //GenericConstraint.ShowClass(dtValue);


                    }

                    {
                        //Console.WriteLine("***********************值类型约束**************************");
                        //GenericConstraint.ShowStruct(people);
                        //GenericConstraint.ShowStruct(chinese);
                        //GenericConstraint.ShowStruct(hubei);
                        //GenericConstraint.ShowStruct(japanese); //不是这个类型 编译器就直接报错；开发者就明确了错误； 
                        //GenericConstraint.ShowStruct(iValue);
                        //GenericConstraint.ShowStruct(sValue);
                        //GenericConstraint.ShowStruct(dtValue);
                    }
                    {
                        Console.WriteLine("***********************无参数构造函数约束**************************");
                        //People people1 = new People(); 
                        //GenericConstraint.ShowNew(people);
                        GenericConstraint.ShowNew(chinese);
                        GenericConstraint.ShowNew(hubei);
                        GenericConstraint.ShowNew(japanese); //不是这个类型 编译器就直接报错；开发者就明确了错误； 
                        GenericConstraint.ShowNew(iValue);
                        //GenericConstraint.ShowNew(sValue);
                        GenericConstraint.ShowNew(dtValue);
                    }</code></pre> 
<p></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/10c46d431cafa6e48240221bb97a8560/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">mysql5.7忘记root密码如何处理</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/60dd347bc6dc952ff62d7248587bda3d/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">hexo&#43;gitee搭建个人博客，手把手教学包括报错解决</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>