<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>STL容器大总结区分(上) - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="STL容器大总结区分(上)" />
<meta property="og:description" content="如图所示 ,按大小说明其重要性
那就先说两个最重要的:
vector---数组 list-----链表
vector 基本概念 功能： vector 数据结构和 数组非常 相似 ，也称为 单端数组 vector 与普通数组区别： 不同之处在于数组是静态空间，而 vector 可以 动态扩展 动态扩展： 并不是在原空间之后续接新空间，而是找更大的内存空间 ，然后将原数据 拷贝 新空间，释放原空间 vector 容器的迭代器是支持 随机访问 的迭代器 list 链表 有数据域和指针域
优点 1可以对任意位置进行快速插入和删除元素 2动态分配存储 缺点 容器遍历速度慢，因为要通过指针域来找元素,比数组慢。占用的空间也比数组大,因为有数据域和指针域。
STL中的链表是一个双向循环链表
支持头部和尾部的插入删除 链表的存储方式不是连续的内存空间,因此链表list中的迭代器只支持前移和后移,属于双向迭代器 list有一个重要的性质,插入操作和删除操作都不会造成原有list迭代器的失效,这在vector是不成立的
因为,vector如果满了,就会开辟新内存空间,原有迭代器会失效 可以想象vector是一排连接起来的箱子,list是独立的箱子,放哪都不会影响内存
说到这,插入一个知识点 vector 随机访问迭代器deque 随机访问迭代器list 双向迭代器set/multiset 双向迭代器map/multimap 双向迭代器stack 不支持迭代器queue 不支持 好，言归正传
先从构造函数开始讲,这几类的方式都大差不差,包括构造时候和赋值和删除插入时
先从构造时候说 在list和vector都有四种方式构造函数
默认构造 无参构造 还可通过区间的方式进行构造
n个elem方式构造
拷贝构造
实例说明
vector的
void test01(){ vector&lt;int&gt; v1;//默认构造 无参构造 for(int i=0;i&lt;=10;i&#43;&#43;){ v1." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/84a80a52bb38969d8ae3b183db8edb8b/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2024-01-27T00:34:06+08:00" />
<meta property="article:modified_time" content="2024-01-27T00:34:06+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">STL容器大总结区分(上)</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p><img alt="" height="545" src="https://images2.imgbox.com/f1/5a/PQfl6V7T_o.png" width="1098"></p> 
<p>如图所示 ,按大小说明其重要性</p> 
<p>那就先说两个最重要的:</p> 
<p><span style="color:#fe2c24;">vector---数组              list-----链表</span></p> 
<div> 
 <span style="color:#333333;"><strong>vector</strong></span> 
 <span style="color:#333333;"><strong>基本概念 </strong></span> 
</div> 
<div> 
 <span style="color:#333333;"><strong>功能： </strong></span> 
</div> 
<div> 
 <span style="color:#333333;">vector</span> 
 <span style="color:#333333;">数据结构和</span> 
 <span style="color:#333333;"><strong>数组非常</strong></span> 
 <span style="color:#fe2c24;"><strong>相似</strong></span> 
 <span style="color:#333333;">，也称为</span> 
 <span style="color:#333333;"><strong>单端数组 </strong></span> 
</div> 
<div> 
 <span style="color:#333333;"><strong>vector</strong></span> 
 <span style="color:#333333;"><strong>与普通数组区别： </strong></span> 
</div> 
<div> 
 <span style="color:#333333;">不同之处在于数组是静态空间，而</span> 
 <span style="color:#333333;">vector</span> 
 <span style="color:#333333;">可以</span> 
 <span style="color:#fe2c24;"><strong>动态扩展 </strong></span> 
</div> 
<div> 
 <span style="color:#333333;"><strong>动态扩展： </strong></span> 
</div> 
<div> 
 <span style="color:#fe2c24;">并不是在原空间之后续接新空间，而是找更大的内存空间</span> 
 <span style="color:#333333;">，然后将原数据</span> 
 <span style="color:#fe2c24;">拷贝</span> 
 <span style="color:#333333;">新空间，释放原空间 </span> 
</div> 
<div> 
 <div> 
  <span style="color:#333333;">vector</span> 
  <span style="color:#333333;">容器的迭代器是支持</span> 
  <span style="color:#fe2c24;">随机访问</span> 
  <span style="color:#333333;">的迭代器 </span> 
 </div> 
 <div></div> 
 <div></div> 
 <div></div> 
 <div> 
  <blockquote> 
   <p>list 链表  <br><span style="color:#fe2c24;">有数据域和指针域</span><br> 优点 1可以对<span style="color:#fe2c24;">任意</span>位置进行快速插入和删除元素    <span style="color:#fe2c24;">2动态分配存储 </span><br> 缺点 容器遍历速度慢，因为要<span style="color:#fe2c24;">通过指针域来找元素,</span>比数组慢。占用的空间也<span style="color:#fe2c24;">比数组大</span>,因为有数据域和指针域。<br> STL中的链表是一个<span style="color:#fe2c24;">双向循环链表</span><br><span style="color:#fe2c24;">支持</span>头部和尾部的插入删除 <br> 链表的存储方式不是连续的内存空间,因此链表list中的迭代器只支持前移和后移,属于双向迭代器 </p> 
   <p><br> list有一个重要的性质,<span style="color:#fe2c24;">插入操作和删除操作都不会造成原有list迭代器的失效</span>,这在vector是<span style="color:#fe2c24;">不成立的</span><br> 因为,vector如果<span style="color:#fe2c24;">满了</span>,就会开辟新内存空间,<span style="color:#fe2c24;">原有迭代器会失效</span> <br> 可以想象vector是一排连接起来的箱子,list是独立的箱子,放哪都不会影响内存</p> 
  </blockquote> 
 </div> 
 <div></div> 
 <div></div> 
 <div></div> 
 <div></div> 
 <div></div> 
 <div>
   说到这,插入一个知识点 
 </div> 
 <div> 
  <img alt="" height="270" src="https://images2.imgbox.com/99/f4/BLDD5Fzs_o.png" width="807"> 
 </div> 
 <div> 
  <table align="center" border="1" cellpadding="1" cellspacing="1" style="width:700px;"><tbody><tr><td style="width:155px;">vector</td><td style="width:543px;">                                                随机访问迭代器</td></tr><tr><td style="width:155px;">deque</td><td style="width:543px;">                                                随机访问迭代器</td></tr><tr><td style="width:155px;">list</td><td style="width:543px;">                                                    双向迭代器</td></tr><tr><td style="width:155px;">set/multiset</td><td style="width:543px;">                                                    双向迭代器</td></tr><tr><td style="width:155px;">map/multimap</td><td style="width:543px;">                                                      双向迭代器</td></tr><tr><td style="width:155px;">stack</td><td style="width:543px;">                                                不支持迭代器</td></tr><tr><td style="width:155px;">queue</td><td style="width:543px;">                                                        不支持</td></tr></tbody></table> 
  <p>好，言归正传</p> 
  <p>先从构造函数开始讲,这几类的方式都大差不差,包括构造时候和赋值和删除插入时</p> 
  <h3 style="background-color:transparent;">先从构造时候说</h3> 
  <p>在list和vector都有四种方式构造函数</p> 
  <blockquote> 
   <p>默认构造 无参构造 </p> 
   <p>还可通过区间的方式进行构造</p> 
   <p>n个elem方式构造</p> 
   <p>拷贝构造</p> 
  </blockquote> 
  <p>实例说明</p> 
  <p>vector的</p> 
  <pre><code class="language-cpp">void test01(){
	vector&lt;int&gt; v1;//默认构造 无参构造     
	for(int i=0;i&lt;=10;i++){
		v1.push_back(i);
	} 						//掌握好第一个和第四个  构造完后面赋值就好 
	printVector(v1);
	
	//还可通过区间的方式进行构造
	vector&lt;int&gt; v2(v1.begin(),v1.end()) ;
	printVector(v2);
	
	//n个elem方式构造
	vector&lt;int&gt; v3(10,100);//十个100 
	printVector(v3);
	
	//拷贝构造
	vector&lt;int&gt; v4(v3);
	printVector(v4); 
}</code></pre> 
  <p>list的</p> 
  <pre><code class="language-cpp">void test01(){
	list&lt;int&gt; l1;
	//添加数据 
	l1.push_back(10);
	l1.push_back(20);
	l1.push_back(30);
	l1.push_back(40);
	//遍历容器
	printList(l1); 
	//区间方式构造
	list&lt;int&gt;L2(l1.begin(),l1.end());
	printList(L2); 
	//拷贝构造
	list&lt;int&gt;L3(L2);
	printList(L3);
	//n个elem
	list&lt;int&gt;l4(10,1000);
	printList(l4); 
} </code></pre> 
  <p>不一样的只是容器名,其他几个也大差不差,一会也一并说了其相似和差异</p> 
  <h3>继续说  <span style="color:#fe2c24;">赋值方式   </span><span style="color:#0d0016;">两个一样，都是四种</span></h3> 
  <blockquote> 
   <p><span style="color:#0d0016;">默认赋值</span></p> 
   <p><span style="color:#0d0016;">赋值    operator=</span></p> 
   <p><span style="color:#0d0016;">assign</span></p> 
   <p><span style="color:#0d0016;">assign    n个elem方式赋值</span></p> 
  </blockquote> 
  <pre><code class="language-cpp">//vector赋值
void test01(){
	vector&lt;int&gt; v1;//默认赋值 
	for(int i=0;i&lt;10;i++){
		v1.push_back(i);
	}
	printVector(v1);
	
	//赋值	operator=
	vector&lt;int&gt; v2; 
	v2=v1;
	printVector(v2);
	
	//assign
	vector&lt;int&gt; v3;
	v3.assign(v1.begin(),v1.end());
	printVector(v3);
	
	//assign	n个elem方式赋值
	vector&lt;int&gt; v4;
	v4.assign(10,100);
	printVector(v4); 
	
} </code></pre> 
  <p>list赋值</p> 
  <pre><code class="language-cpp">void test01(){
	list&lt;int&gt;L1;
	L1.push_back(10);
	L1.push_back(20);
	L1.push_back(30);
	L1.push_back(40);
	
	printList(L1);
	
	list&lt;int&gt;L2;
	L2=L1;//operator=赋值
	printList(L2);
	
	list&lt;int&gt;L3;
	L3.assign(L2.begin(),L2.end()) ;
	printList(L3);
	
	list&lt;int&gt;L4;
	L4.assign(10,100);
	printList(L4);
} </code></pre> 
  <p>vector和list容器(只有vec)大小</p> 
  <p><span style="color:#fe2c24;">vector和list大小操作</span></p> 
  <h3><span style="color:#ff9900;">这几个接口</span></h3> 
  <p>empty size <span style="color:#fe2c24;">capacity</span> resize</p> 
  <p>capacity        list么有</p> 
  <p>vector</p> 
  <pre><code class="language-cpp">void test01(){
	vector&lt;int&gt; v1;
	for(int i=0;i&lt;10;i++){
		v1.push_back(i);
	}
	printVector(v1);
	
	if(v1.empty())//为真 为空
	{
		cout&lt;&lt;"v1为空"&lt;&lt;endl;
	 } else{
	 	cout&lt;&lt;"v1不为空"&lt;&lt;endl;
	 	cout&lt;&lt;"v1的容量为: "&lt;&lt;v1.capacity()&lt;&lt;endl;
	 	cout&lt;&lt;"v1的大小为"&lt;&lt;v1.size()&lt;&lt;endl;//容量永远大于大小 
	 }
	 
	 //重新指定大小
	 v1.resize(15,100);//利用重载版本，可以指定默认填充值，参数2 
	 
	 printVector(v1);//如果重新指定的比原来长了,默认用0来填充
	 
	 v1.resize(5);//重新指定的比原来短了，超出的部分会删除掉 
	 printVector(v1); 
	  cout&lt;&lt;"v1的容量为: "&lt;&lt;v1.capacity()&lt;&lt;endl;//容量还是没变 
}</code></pre> 
  <p>list</p> 
  <pre><code class="language-cpp">void test01(){
	list&lt;int&gt;L1;
	L1.push_back(10);
	L1.push_back(20);
	L1.push_back(30);
	L1.push_back(40);
	
	printList(L1);
	
	if(L1.empty()){
		cout&lt;&lt;"L1为空"&lt;&lt;endl;
	}
	else{
		cout&lt;&lt;"L1不为空"&lt;&lt;endl;
		cout&lt;&lt;"L1元素个数"&lt;&lt;L1.size()&lt;&lt;endl;
	}
	
	//重新指定大小
	L1.resize(10,10000);
//	L1.resize(10);//后面默认用0填充 
	printList(L1);
	L1.resize(2);
	
	printList(L1);//其他删除 
	 
} </code></pre> 
  <h3><strong><span style="color:#fe2c24;">插入和删除</span></strong></h3> 
  <p><span style="color:#0d0016;">尾删和尾插两个都有        因为在随机访问迭代器中在头部上处理的是下一个容器deque,这里暂且不表   要分清front和x.begin()所表示什么</span></p> 
  <blockquote> 
   <p><span style="color:#0d0016;">尾插    v1.push_back(40);     L.push_back(10);</span></p> 
   <p><span style="color:#0d0016;">尾删  v1.pop_back();                    L.pop_back();</span></p> 
  </blockquote> 
  <p>insert一样</p> 
  <p>vector</p> 
  <pre><code class="language-cpp">	//插入	第一个参数是 迭代器 
	v1.insert(v1.begin(),100);
	printVector(v1); 
	
	v1.insert(v1.end(),200);
	printVector(v1);
	
	v1.insert(v1.begin(),2,1000);
	printVector(v1);//加了两个1000</code></pre> 
  <p>list</p> 
  <pre><code class="language-cpp">//insert插入
	list&lt;int&gt;::iterator it=L.begin();
	L.insert(++L.begin(),1000);//it灵活运用 
	printList(L);
	L.insert(L.end(),2,9);
	printList(L);</code></pre> 
  <p>接下来说删除,删除这稍微不一样</p> 
  <p>通常就是erase()和clear()   list加了一个remove()</p> 
  <pre><code class="language-cpp">	//删除	参数也是 迭代器 
	v1.erase(v1.begin()) ;
	printVector(v1);
	
//	v1.erase(v1.begin(),v1.end());//清除区间		删除第三个2到4 
	v1.clear() ;//也是清除区间 
	printVector(v1);</code></pre> 
  <p>list</p> 
  <pre><code class="language-cpp">	//删除
	it=L.begin();
	L.erase(it);
	printList(L);//删了200
	
	//移除
	L.push_back(10000);
	L.push_back(10000);
	L.push_back(10000);
	printList(L);
	
	L.remove(10000);//删除所有匹配的值 
	printList(L);//删掉了 
	
	
	//清空
	L.clear();
	printList(L);//多了一个空行 </code></pre> 
  <p>    L.remove(10000);//删除所有匹配的值 <br>     printList(L);//删掉了 </p> 
  <p>删除的是所有remove里面的数（1000）</p> 
  <p><img alt="" height="36" src="https://images2.imgbox.com/ad/82/aXjdU4FF_o.png" width="301"></p> 
  <h3 style="background-color:transparent;">数据存储</h3> 
  <p>vector可以用[]和at()访问        和获取第一个元素v1.front()    获取最后一个v1.back()</p> 
  <pre><code class="language-cpp">void test01(){
	vector&lt;int&gt; v1;
	for(int i=0;i&lt;10;i++){
		v1.push_back(i);
	}
	//利用中括号方式来访问数组中的元素 
	for(int i=0;i&lt;v1.size();i++){
		cout&lt;&lt;v1[i]&lt;&lt;" ";
	}
	cout&lt;&lt;endl;
	
//	和string同理 利用at方式访问元素
	for(int i=0;i&lt;v1.size();i++){
		cout&lt;&lt;v1.at(i)&lt;&lt;"  ";
	} 
	cout&lt;&lt;endl;
	
	//获取第一个元素
	cout&lt;&lt;"第一个元素为:"&lt;&lt;v1.front()&lt;&lt;endl;
	//获取最后一个
	cout&lt;&lt;"最后一个元素"&lt;&lt;v1.back()&lt;&lt;endl; 
} </code></pre> 
  <p><strong>list不支持at()和[],因为链表不是连续空间    而且链表也不支持随机访问,双向迭代器只能前移和后移              这句说的太好了           防止忘记,让我们再次回顾list优点缺点</strong></p> 
  <p>优点 1可以对<span style="color:#fe2c24;">任意</span>位置进行快速插入和删除元素    <span style="color:#fe2c24;">2动态分配存储 </span><br> 缺点 容器遍历速度慢，因为要<span style="color:#fe2c24;">通过指针域来找元素,</span>比数组慢。占用的空间也<span style="color:#fe2c24;">比数组大</span>,因为有数据域和指针域。</p> 
  <pre><code class="language-cpp">void test01(){
	list&lt;int&gt;L1;
	L1.push_back(10);
	L1.push_back(20);
	L1.push_back(30);
	L1.push_back(40);
	
//	L1[0]是错误的L.at(0)错误
	
	cout&lt;&lt;"第一个元素为"&lt;&lt;L1.front()&lt;&lt;endl;
	cout&lt;&lt;"最后一个元素为"&lt;&lt;L1.back()&lt;&lt;endl;
	
	//验证迭代器是不支持随机访问的
	list&lt;int&gt;::iterator it=L1.begin();
	it++;//正确	支持双向
	it--; 
//	it+=1;报错  其不支持随机访问  可以用加法来判断是否支持随机访问
//或者写it--看其是否为单向 
	cout&lt;&lt;*it; 
	
} </code></pre> 
  <blockquote> 
   <p><span style="color:#fe2c24;"><strong>这一段着重看,学思想  </strong></span></p> 
   <p> //验证迭代器是不支持随机访问的<br>     list&lt;int&gt;::iterator it=L1.begin();<br>     it++;//正确    支持双向<br>     it--; <br> //    it+=1;报错  其不支持随机访问  可以用加法来判断是否支持随机访问<br> //或者写it--看其是否为单向 <br>     cout&lt;&lt;*it;</p> 
  </blockquote> 
 </div> 
</div> 
<h3>  swap()</h3> 
<p>两个都有swap()属性,但这里list用reverse来表示<br> vector</p> 
<pre><code class="language-cpp">void test01(){
	vector&lt;int&gt; v1;
	for(int i=0;i&lt;10;i++){
		v1.push_back(i);
	}
	cout&lt;&lt;"交换前"&lt;&lt;endl; 
	printVector(v1);
	
	vector&lt;int&gt; v2;
	for(int i=10;i&gt;0;i--){
		v2.push_back(i);
	}
	printVector(v2);
	
	cout&lt;&lt;"交换后"&lt;&lt;endl;
	v1.swap(v2);
	printVector(v1);
	printVector(v2);
}</code></pre> 
<p>vector        swap()实际用途</p> 
<pre><code class="language-cpp">//巧用swap()可以收缩内存空间
void test02(){
	vector&lt;int&gt; v;
	for(int i=0;i&lt;100000;i++){
		v.push_back(i);
	}
	cout&lt;&lt;"v的容量为:"&lt;&lt;v.capacity()&lt;&lt;endl;
	cout&lt;&lt;"v的大小为"&lt;&lt;v.size()&lt;&lt;endl;
	
	v.resize(3);//大小变小 
	cout&lt;&lt;"v的容量为:"&lt;&lt;v.capacity()&lt;&lt;endl;
	cout&lt;&lt;"v的大小为"&lt;&lt;v.size()&lt;&lt;endl;//内存变小了 但是容量没变
	
	//巧用swap收缩内存
	vector&lt;int&gt;(v).swap(v);
	cout&lt;&lt;"v的容量为:"&lt;&lt;v.capacity()&lt;&lt;endl;
	cout&lt;&lt;"v的大小为"&lt;&lt;v.size()&lt;&lt;endl; //容量和内存都小了
	
	//解析  其先初用 v创建了一个匿名对象vector&lt;int&gt;(v) 其内存和大小都是3 
	//然后swap 指针方向交换 所以v内存和大小都为3
	//匿名对象指向的大空间 当前行执行完立即回收,所以不存在占空间 
} </code></pre> 
<p> </p> 
<p>list</p> 
<pre><code class="language-cpp">void test01(){
	//反转 
	list&lt;int&gt;L1;
	
	L1.push_back(20);
	L1.push_back(10);
	L1.push_back(50);
	L1.push_back(40);
	L1.push_back(30);
	
	printList(L1);
	
	cout&lt;&lt;"反转后"&lt;&lt;endl;
	L1.reverse();
	printList(L1);
} </code></pre> 
<p> </p> 
<p>接下来是两个独有属性</p> 
<h3> list排序</h3> 
<pre><code class="language-cpp">//排序
void test02(){
	list&lt;int&gt;L1;
	L1.push_back(20);
	L1.push_back(10);
	L1.push_back(50);
	L1.push_back(40);
	L1.push_back(30);
	cout&lt;&lt;"排序前"&lt;&lt;endl;
		printList(L1);
//	sort(L1.begin(),L1.end());报错
//原因所有不支持随机访问迭代器的容器,不可以用标准算法
//不支持随机访问的迭代器,内部会提供对应的一些算法
	cout&lt;&lt;"升序排列"&lt;&lt;endl;
	L1.sort();//运行成功     默认从小到大 
		printList(L1);
		
	cout&lt;&lt;"降序排列"&lt;&lt;endl;	
	L1.sort(myCompare);//提供函数改变sort顺序 
	printList(L1);
}</code></pre> 
<blockquote> 
 <p>重点是</p> 
 <p><span style="color:#a2e043;">    sort(L1.begin(),L1.end());报错<br>      原因所有不支持随机访问迭代器的容器,不可以用标准算法<br>      不支持随机访问的迭代器,内部会提供对应的一些算法</span></p> 
 <p><span style="color:#0d0016;">所以    L1.sort();//运行成功     默认从小到大 </span></p> 
</blockquote> 
<h3>vector预留空间</h3> 
<p>统计开辟内存次数                        用reserve先开辟内存就不用后面再开辟了</p> 
<pre><code class="language-cpp">#include &lt;iostream&gt;
#include &lt;vector&gt;
#include&lt;string&gt;
using namespace std;
//reserve(int len)//容器预留len个元素长度,预留位置不初始化,元素不可访问

void test01(){
	vector&lt;int&gt; v;
	
	//利用reserve预留空间
	v.reserve(100000); //这回运行结果为0 
	int num=0;//统计开辟内存次数
	int*p=NULL; 
	for(int i=0;i&lt;100000;i++){
		v.push_back(i);
		if(p!=&amp;v[0]){
			p=&amp;v[0];//循环找第一个内存  
			num++;
		}
	}	
	//vector可动态拓展 是找一块更大的空间 把原有的数据拷贝新空间,释放原空间
	cout&lt;&lt;num;
} 
int main()
{
	test01();
	system("pause");
}</code></pre> 
<h3>两个print函数</h3> 
<blockquote> 
 <p>void printVector(vector&lt;int&gt; &amp;v){<!-- --><br>     for(vector&lt;int&gt;::iterator it=v.begin();it!=v.end();it++){<!-- --><br>         cout&lt;&lt;*it&lt;&lt;" ";<br>     }<br>     cout&lt;&lt;endl;<br> }</p> 
</blockquote> 
<p>如此看来两个除了容器名不同,输出其他都相同</p> 
<blockquote> 
 <p>void printList(list&lt;int&gt; &amp;L){<!-- --><br>     for(list&lt;int&gt;::iterator it=L.begin();it!=L.end();it++){<!-- --><br>         cout&lt;&lt;*it&lt;&lt;" ";<br>     }<br>     cout&lt;&lt;endl;<br> }</p> 
</blockquote>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/4fa22ab1fd93ad914357d22b93a9c25c/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">FTP主被动模式详解、FTP服务器的搭建及FileZilla的安装使用</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/26d7de8d413c21d84f5ec43ee03c479b/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">深度学习-搭建Colab环境</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>