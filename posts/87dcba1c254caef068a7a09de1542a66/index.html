<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>树形DP总结，持续更新 - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="树形DP总结，持续更新" />
<meta property="og:description" content="自己做了动态规划的题目已经有了一个月，但是成效甚微，所以来总结一下动态规划，希望自己能够温故知新。这个博客是关于树形dp的，动态规划的一类题目。 首先从最简单的树形DP入手，树形DP顾名思义就是一棵树和动态规划结合起来，我做了7，8题树形DP，目前为止发现树形DP的代码样式都是差不多，都在dfs树的过程中进行DP。 首先看一道简单的入门题目 题意就是在一棵树中，选取一些结点每个结点都可以监管者连接自己的一条边，问最少选取多少个结点可以让所有边都被监管起来。 思路：1：结点状态可以分为取和不取，所以用二维数组表示结点的状态。2：如果当前结点选取了，子结点可以选取也可以不选取，但是如果当前结点没有选取，那么子节点必须选取。 状态转移方程见代码里
#include &lt;iostream&gt; #include &lt;algorithm&gt; #include &lt;string.h&gt; #include &lt;math.h&gt; #include &lt;stdlib.h&gt; using namespace std; #define MAX 1500 int n; int root; int tot; struct Node { int value; int next; }edge[MAX*2&#43;5]; int head[MAX&#43;5]; int dp[MAX&#43;5][2]; int vis[MAX&#43;5]; void add(int x,int y) { edge[tot].value=y; edge[tot].next=head[x]; head[x]=tot&#43;&#43;; } void dfs(int root) { dp[root][0]=0; dp[root][1]=1; vis[root]=1; for(int i=head[root];i!=-1;i=edge[i].next) { int k=edge[i].value; if(!vis[k]) { dfs(k); //状态转移方程 dp[root][0]&#43;=dp[k][1]; dp[root][1]&#43;=min(dp[k][0],dp[k][1])； } } } int main() { int a,b; int m; while(scanf(&#34;" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/87dcba1c254caef068a7a09de1542a66/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2016-01-03T18:09:00+08:00" />
<meta property="article:modified_time" content="2016-01-03T18:09:00+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">树形DP总结，持续更新</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <div id="cnblogs_post_body" class="blogpost-body"> 
 <div class="markdown_views"> 
  <p>自己做了动态规划的题目已经有了一个月，但是成效甚微，所以来总结一下动态规划，希望自己能够温故知新。这个博客是关于树形dp的，动态规划的一类题目。 <br> 首先从最简单的树形DP入手，树形DP顾名思义就是一棵树和动态规划结合起来，我做了7，8题树形DP，目前为止发现树形DP的代码样式都是差不多，都在dfs树的过程中进行DP。 <br><a href="http://acm.hdu.edu.cn/showproblem.php?pid=1054" rel="nofollow">首先看一道简单的入门题目</a> <br> 题意就是在一棵树中，选取一些结点每个结点都可以监管者连接自己的一条边，问最少选取多少个结点可以让所有边都被监管起来。 <br> 思路：1：结点状态可以分为取和不取，所以用二维数组表示结点的状态。2：如果当前结点选取了，子结点可以选取也可以不选取，但是如果当前结点没有选取，那么子节点必须选取。 <br> 状态转移方程见代码里</p> 
  <pre class="prettyprint"><code class="hljs cpp"><span class="hljs-preprocessor">#include &lt;iostream&gt;</span>
<span class="hljs-preprocessor">#include &lt;algorithm&gt;</span>
<span class="hljs-preprocessor">#include &lt;string.h&gt;</span>
<span class="hljs-preprocessor">#include &lt;math.h&gt;</span>
<span class="hljs-preprocessor">#include &lt;stdlib.h&gt;</span>

<span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;
<span class="hljs-preprocessor">#define MAX 1500</span>
<span class="hljs-keyword">int</span> n;
<span class="hljs-keyword">int</span> root;
<span class="hljs-keyword">int</span> tot;
<span class="hljs-keyword">struct</span> Node
{
    <span class="hljs-keyword">int</span> value;
    <span class="hljs-keyword">int</span> next;
}edge[MAX*<span class="hljs-number">2</span>+<span class="hljs-number">5</span>];
<span class="hljs-keyword">int</span> head[MAX+<span class="hljs-number">5</span>];
<span class="hljs-keyword">int</span> dp[MAX+<span class="hljs-number">5</span>][<span class="hljs-number">2</span>];
<span class="hljs-keyword">int</span> vis[MAX+<span class="hljs-number">5</span>];
<span class="hljs-keyword">void</span> add(<span class="hljs-keyword">int</span> x,<span class="hljs-keyword">int</span> y)
{
    edge[tot].value=y;
    edge[tot].next=head[x];
    head[x]=tot++;
}
<span class="hljs-keyword">void</span> dfs(<span class="hljs-keyword">int</span> root)
{
    dp[root][<span class="hljs-number">0</span>]=<span class="hljs-number">0</span>;
    dp[root][<span class="hljs-number">1</span>]=<span class="hljs-number">1</span>;
    vis[root]=<span class="hljs-number">1</span>;
    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=head[root];i!=-<span class="hljs-number">1</span>;i=edge[i].next)
    {
        <span class="hljs-keyword">int</span> k=edge[i].value;
        <span class="hljs-keyword">if</span>(!vis[k])
        {
            dfs(k);
            <span class="hljs-comment">//状态转移方程</span>
            dp[root][<span class="hljs-number">0</span>]+=dp[k][<span class="hljs-number">1</span>];
            dp[root][<span class="hljs-number">1</span>]+=min(dp[k][<span class="hljs-number">0</span>],dp[k][<span class="hljs-number">1</span>])；
        }
    }
}
<span class="hljs-keyword">int</span> main()
{

    <span class="hljs-keyword">int</span> a,b;
    <span class="hljs-keyword">int</span> m;
    <span class="hljs-keyword">while</span>(<span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d"</span>,&amp;n)!=EOF)
    {
        tot=<span class="hljs-number">0</span>;
        <span class="hljs-built_in">memset</span>(vis,<span class="hljs-number">0</span>,<span class="hljs-keyword">sizeof</span>(vis));
        <span class="hljs-built_in">memset</span>(head,-<span class="hljs-number">1</span>,<span class="hljs-keyword">sizeof</span>(head));
        <span class="hljs-built_in">memset</span>(dp,<span class="hljs-number">0</span>,<span class="hljs-keyword">sizeof</span>(dp));
        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)
        {
            <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d:(%d)"</span>,&amp;a,&amp;m);
            <span class="hljs-keyword">if</span>(i==<span class="hljs-number">0</span>) root=a;
            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=<span class="hljs-number">0</span>;j&lt;m;j++)
            {
                <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d"</span>,&amp;b);
                add(a,b);
                add(b,a);
            }
        }
        dfs(root);
        <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d\n"</span>,min(dp[root][<span class="hljs-number">0</span>],dp[root][<span class="hljs-number">1</span>]));
    }
    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}

</code></pre> 
  <p>这是一道入门题目，那么再看一到和它非常类似的题目，只是稍微变了一下 <br> 状态转移方程见代码里 <br> (<a href="http://acm.hdu.edu.cn/showproblem.php?pid=1520" rel="nofollow">http://acm.hdu.edu.cn/showproblem.php?pid=1520</a>)</p> 
  <pre class="prettyprint"><code class="hljs cpp"><span class="hljs-preprocessor">#include &lt;iostream&gt;</span>
<span class="hljs-preprocessor">#include &lt;string.h&gt;</span>
<span class="hljs-preprocessor">#include &lt;algorithm&gt;</span>
<span class="hljs-preprocessor">#include &lt;math.h&gt;</span>
<span class="hljs-preprocessor">#include &lt;stdlib.h&gt;</span>

<span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;
<span class="hljs-preprocessor">#define MAX 6000</span>
<span class="hljs-keyword">struct</span> Node
{
    <span class="hljs-keyword">int</span> value;
    <span class="hljs-keyword">int</span> next;
}edge[MAX*<span class="hljs-number">2</span>+<span class="hljs-number">5</span>];
<span class="hljs-keyword">int</span> tag[MAX+<span class="hljs-number">5</span>];
<span class="hljs-keyword">int</span> dp[MAX+<span class="hljs-number">5</span>][<span class="hljs-number">2</span>];
<span class="hljs-keyword">int</span> n;
<span class="hljs-keyword">int</span> root;
<span class="hljs-keyword">int</span> tot;
<span class="hljs-keyword">int</span> rat[MAX+<span class="hljs-number">5</span>];
<span class="hljs-keyword">int</span> head[MAX+<span class="hljs-number">5</span>];
<span class="hljs-keyword">int</span> vis[MAX+<span class="hljs-number">5</span>];
<span class="hljs-keyword">void</span> add(<span class="hljs-keyword">int</span> x,<span class="hljs-keyword">int</span> y)
{
    edge[tot].value=y;
    edge[tot].next=head[x];
    head[x]=tot++;
}
<span class="hljs-keyword">void</span> dfs(<span class="hljs-keyword">int</span> root)
{
    dp[root][<span class="hljs-number">1</span>]=rat[root];
    dp[root][<span class="hljs-number">0</span>]=<span class="hljs-number">0</span>;
    vis[root]=<span class="hljs-number">1</span>;
    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=head[root];i!=-<span class="hljs-number">1</span>;i=edge[i].next)
    {
        <span class="hljs-keyword">int</span> k=edge[i].value;
        <span class="hljs-keyword">if</span>(!vis[k])
        {
            dfs(k);
            <span class="hljs-comment">//状态转移方程</span>
            dp[root][<span class="hljs-number">1</span>]+=dp[k][<span class="hljs-number">0</span>];
            dp[root][<span class="hljs-number">0</span>]+=max(dp[k][<span class="hljs-number">0</span>],dp[k][<span class="hljs-number">1</span>]);
        }
    }

}
<span class="hljs-keyword">int</span> main()
{
    <span class="hljs-keyword">int</span> a,b;
    <span class="hljs-keyword">while</span>(<span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d"</span>,&amp;n)!=EOF)
    {
        tot=<span class="hljs-number">0</span>;
        <span class="hljs-built_in">memset</span>(head,-<span class="hljs-number">1</span>,<span class="hljs-keyword">sizeof</span>(head));
        <span class="hljs-built_in">memset</span>(dp,<span class="hljs-number">0</span>,<span class="hljs-keyword">sizeof</span>(dp));
        <span class="hljs-built_in">memset</span>(vis,<span class="hljs-number">0</span>,<span class="hljs-keyword">sizeof</span>(vis));
        <span class="hljs-built_in">memset</span>(tag,<span class="hljs-number">0</span>,<span class="hljs-keyword">sizeof</span>(tag));
        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)
        {
            <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d"</span>,&amp;rat[i]);
        }
        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d%d"</span>,&amp;a,&amp;b);
        <span class="hljs-keyword">while</span>(a!=<span class="hljs-number">0</span>&amp;&amp;b!=<span class="hljs-number">0</span>)
        {
            tag[a]=<span class="hljs-number">1</span>;
            add(b,a);
            add(a,b);
            <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d%d"</span>,&amp;a,&amp;b);
        }
        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)
        {
            <span class="hljs-keyword">if</span>(tag[i]==<span class="hljs-number">0</span>)
            {
              root=i;
              <span class="hljs-keyword">break</span>;
            }
        }
        dfs(<span class="hljs-number">1</span>);
        <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d\n"</span>,max(dp[<span class="hljs-number">1</span>][<span class="hljs-number">0</span>],dp[<span class="hljs-number">1</span>][<span class="hljs-number">1</span>]));
    }
    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}

</code></pre> 
  <p>这两道题目可以说一个类型的，都是在树上选取一些结点，以获得最优值，限制条件就是子节点和父节点的关系，二者不可以都选取，或者不可以都不选取，所以代码几乎都一样。 <br> 接下来看一道比前面难一点的题目 <br> (<a href="http://acm.hdu.edu.cn/showproblem.php?pid=1561" rel="nofollow">http://acm.hdu.edu.cn/showproblem.php?pid=1561</a>) <br> 题意：有n个城堡形成一棵树，你只能攻打m个城堡，每个城堡里都有相应的宝物，要攻克这些城堡必须先攻克其他某一个特定的城堡，就是先攻克根，才可以往下攻击子树，问可以获得最大的宝物。 <br> 思路：这道题目和前面不同的是，有两个限制条件，一个是必学攻克父节点才能去攻打子节点，另一个是只能攻克m个城堡。这里可以看出树形dp和依赖背包是不是有一点差不多。其实解决依赖背包问题，就是用树形dp的思路，先解决子树的最优解，然后才能得到根的最优解。过程是从下往上的，而树的DFS就是先搜索到叶子节点，然后逐层往上，不断更新结点的最优值，最终保证根节点的值是最优的。状态转移方程见代码里</p> 
  <pre class="prettyprint"><code class="hljs cpp"><span class="hljs-preprocessor">#include &lt;iostream&gt;</span>
<span class="hljs-preprocessor">#include &lt;string.h&gt;</span>
<span class="hljs-preprocessor">#include &lt;algorithm&gt;</span>
<span class="hljs-preprocessor">#include &lt;stdlib.h&gt;</span>
<span class="hljs-preprocessor">#include &lt;math.h&gt;</span>

<span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;
<span class="hljs-preprocessor">#define MAX 200</span>
<span class="hljs-keyword">struct</span> Node
{
    <span class="hljs-keyword">int</span> value;
    <span class="hljs-keyword">int</span> next;
}edge[MAX+<span class="hljs-number">5</span>];
<span class="hljs-keyword">int</span> tot;
<span class="hljs-keyword">int</span> head[MAX+<span class="hljs-number">5</span>];
<span class="hljs-keyword">int</span> n,m;
<span class="hljs-keyword">int</span> num[MAX+<span class="hljs-number">5</span>];
<span class="hljs-keyword">int</span> dp[MAX+<span class="hljs-number">5</span>][MAX+<span class="hljs-number">5</span>];
<span class="hljs-keyword">int</span> vis[MAX+<span class="hljs-number">5</span>];
<span class="hljs-keyword">void</span> add(<span class="hljs-keyword">int</span> x,<span class="hljs-keyword">int</span> y)
{
     edge[tot].value=y;
     edge[tot].next=head[x];
     head[x]=tot++;
}
<span class="hljs-keyword">void</span> dfs(<span class="hljs-keyword">int</span> root,<span class="hljs-keyword">int</span> tag)
{
    vis[root]=<span class="hljs-number">1</span>;
    dp[root][<span class="hljs-number">1</span>]=num[root];
    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=head[root];i!=-<span class="hljs-number">1</span>;i=edge[i].next)
    {
        <span class="hljs-keyword">int</span> t=edge[i].value;
        <span class="hljs-keyword">if</span>(!vis[t])
        {
            dfs(t,tag-<span class="hljs-number">1</span>);
        }
        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=tag;j&gt;=<span class="hljs-number">1</span>;j--)
        {
             <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> k=<span class="hljs-number">1</span>;k&lt;j;k++ )
             {
             <span class="hljs-comment">//状态转移方程</span>
                 dp[root][j]=max(dp[root][j],dp[root][j-k]+dp[t][k]);
             }
        }
    }
}
 <span class="hljs-keyword">int</span> main()
{
    <span class="hljs-keyword">int</span> a;
    <span class="hljs-keyword">while</span>(<span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d%d"</span>,&amp;n,&amp;m)!=EOF)
    {
        <span class="hljs-keyword">if</span>(n==<span class="hljs-number">0</span>&amp;&amp;m==<span class="hljs-number">0</span>)
            <span class="hljs-keyword">break</span>;
        tot=<span class="hljs-number">0</span>;
        <span class="hljs-built_in">memset</span>(head,-<span class="hljs-number">1</span>,<span class="hljs-keyword">sizeof</span>(head));
        <span class="hljs-built_in">memset</span>(dp,<span class="hljs-number">0</span>,<span class="hljs-keyword">sizeof</span>(dp));
        <span class="hljs-built_in">memset</span>(vis,<span class="hljs-number">0</span>,<span class="hljs-keyword">sizeof</span>(vis));
        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)
        {
            <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d%d"</span>,&amp;a,&amp;num[i]);
            add(a,i);
        }
        dfs(<span class="hljs-number">0</span>,m+<span class="hljs-number">1</span>);
        <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d\n"</span>,dp[<span class="hljs-number">0</span>][m+<span class="hljs-number">1</span>]);
    }
    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}</code></pre> 
  <p>代码看懂了也很好理解，接下来看这个问题的升级版(<a href="http://acm.hdu.edu.cn/showproblem.php?pid=1011" rel="nofollow">http://acm.hdu.edu.cn/showproblem.php?pid=1011</a>) <br> 题意：和上面一提差不多，变的是每个结点被攻克要求不同士兵数量</p> 
  <pre class="prettyprint"><code class="hljs cpp"><span class="hljs-comment">//</span>
<span class="hljs-comment">//  main.cpp</span>
<span class="hljs-comment">//  树形DP2</span>
<span class="hljs-comment">//</span>
<span class="hljs-comment">//  Created by 陈永康 on 16/1/3.</span>
<span class="hljs-comment">//  Copyright (c) 2016年 陈永康. All rights reserved.</span>
<span class="hljs-comment">//</span>

<span class="hljs-preprocessor">#include &lt;iostream&gt;</span>
<span class="hljs-preprocessor">#include &lt;string.h&gt;</span>
<span class="hljs-preprocessor">#include &lt;algorithm&gt;</span>
<span class="hljs-preprocessor">#include &lt;math.h&gt;</span>
<span class="hljs-preprocessor">#include &lt;stdlib.h&gt;</span>

<span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;
<span class="hljs-keyword">int</span> dp[<span class="hljs-number">105</span>][<span class="hljs-number">105</span>];<span class="hljs-comment">//当前节点为i，小兵数为j得到的最大能量值</span>
<span class="hljs-keyword">int</span> n,m;
<span class="hljs-keyword">int</span> bug[<span class="hljs-number">105</span>];
<span class="hljs-keyword">int</span> brain[<span class="hljs-number">105</span>];
<span class="hljs-keyword">int</span> head[<span class="hljs-number">105</span>];
<span class="hljs-keyword">int</span> tot;
<span class="hljs-keyword">int</span> vis[<span class="hljs-number">105</span>];
<span class="hljs-keyword">struct</span> Node
{
    <span class="hljs-keyword">int</span> value;
    <span class="hljs-keyword">int</span> next;
}edge[<span class="hljs-number">105</span>*<span class="hljs-number">2</span>];
<span class="hljs-keyword">void</span> add(<span class="hljs-keyword">int</span> x,<span class="hljs-keyword">int</span> y)
{
    edge[tot].value=y;
    edge[tot].next=head[x];
    head[x]=tot++;
}
<span class="hljs-keyword">void</span> dfs(<span class="hljs-keyword">int</span> root,<span class="hljs-keyword">int</span> tag)
{
    vis[root]=<span class="hljs-number">1</span>;
    <span class="hljs-keyword">int</span> term=(bug[root]+<span class="hljs-number">19</span>)/<span class="hljs-number">20</span>;

        dp[root][term]=brain[root];
    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=head[root];i!=-<span class="hljs-number">1</span>;i=edge[i].next)
    {
        <span class="hljs-keyword">int</span> u=edge[i].value;
        <span class="hljs-keyword">if</span>(!vis[u])
        {
            dfs(u,tag-term);

            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=tag;j&gt;=term;j--)
            {
                <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> k=<span class="hljs-number">1</span>;j+k&lt;=m;k++)
                {
                    <span class="hljs-keyword">if</span>(dp[u][k])
                        dp[root][j+k]=max(dp[root][j+k],dp[root][j]+dp[u][k]);
                }
            }
        }
    }
}
<span class="hljs-keyword">int</span> main()
{
    <span class="hljs-keyword">int</span> x,y;
    <span class="hljs-keyword">while</span>(<span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d%d"</span>,&amp;n,&amp;m)!=EOF)
    {
        <span class="hljs-keyword">if</span>(n==-<span class="hljs-number">1</span>&amp;&amp;m==-<span class="hljs-number">1</span>)
            <span class="hljs-keyword">break</span>;
        <span class="hljs-built_in">memset</span>(vis,<span class="hljs-number">0</span>,<span class="hljs-keyword">sizeof</span>(vis));
        <span class="hljs-built_in">memset</span>(head,-<span class="hljs-number">1</span>,<span class="hljs-keyword">sizeof</span>(head));
        tot=<span class="hljs-number">0</span>;
        <span class="hljs-built_in">memset</span>(dp,<span class="hljs-number">0</span>,<span class="hljs-keyword">sizeof</span>(dp));
        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)
        {
            <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d%d"</span>,&amp;bug[i],&amp;brain[i]);
        }
        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;n;i++)
        {
            <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d%d"</span>,&amp;x,&amp;y);
            add(x,y);
            add(y,x);
        }
        dfs(<span class="hljs-number">1</span>,m);
        <span class="hljs-keyword">if</span>(m==<span class="hljs-number">0</span>)
            <span class="hljs-built_in">printf</span>(<span class="hljs-string">"0\n"</span>);
        <span class="hljs-keyword">else</span>
            <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d\n"</span>,dp[<span class="hljs-number">1</span>][m]);
    }
}</code></pre> 
  <pre><code>值得注意的是还有另外一个ac代码，它和上面有一点不同
</code></pre> 
  <pre class="prettyprint"><code class="hljs cpp"><span class="hljs-preprocessor">#include &lt;iostream&gt;</span>
<span class="hljs-preprocessor">#include &lt;string.h&gt;</span>
<span class="hljs-preprocessor">#include &lt;algorithm&gt;</span>
<span class="hljs-preprocessor">#include &lt;math.h&gt;</span>
<span class="hljs-preprocessor">#include &lt;stdlib.h&gt;</span>

<span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;
<span class="hljs-keyword">int</span> dp[<span class="hljs-number">105</span>][<span class="hljs-number">105</span>];<span class="hljs-comment">//当前节点为i，小兵数为j得到的最大能量值</span>
<span class="hljs-keyword">int</span> n,m;
<span class="hljs-keyword">int</span> bug[<span class="hljs-number">105</span>];
<span class="hljs-keyword">int</span> brain[<span class="hljs-number">105</span>];
<span class="hljs-keyword">int</span> head[<span class="hljs-number">105</span>];
<span class="hljs-keyword">int</span> tot;
<span class="hljs-keyword">int</span> vis[<span class="hljs-number">105</span>];
<span class="hljs-keyword">struct</span> Node
{
    <span class="hljs-keyword">int</span> value;
    <span class="hljs-keyword">int</span> next;
}edge[<span class="hljs-number">105</span>*<span class="hljs-number">2</span>];
<span class="hljs-keyword">void</span> add(<span class="hljs-keyword">int</span> x,<span class="hljs-keyword">int</span> y)
{
    edge[tot].value=y;
    edge[tot].next=head[x];
    head[x]=tot++;
}
<span class="hljs-keyword">void</span> dfs(<span class="hljs-keyword">int</span> root)
{
    vis[root]=<span class="hljs-number">1</span>;
    <span class="hljs-keyword">int</span> term=(bug[root]+<span class="hljs-number">19</span>)/<span class="hljs-number">20</span>;
    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=term;i&lt;=m;i++)
        dp[root][i]=brain[root];
    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=head[root];i!=-<span class="hljs-number">1</span>;i=edge[i].next)
    {
        <span class="hljs-keyword">int</span> u=edge[i].value;
        <span class="hljs-keyword">if</span>(!vis[u])
        {
            dfs(u);

            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=m;j&gt;=term;j--)
            {
                 <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> k=<span class="hljs-number">1</span>;j+k&lt;=m;k++)
                 {
                     <span class="hljs-keyword">if</span>(dp[u][k])
                      dp[root][j+k]=max(dp[root][j+k],dp[root][j]+dp[u][k]);
                 }
            }
        }
    }
}
<span class="hljs-keyword">int</span> main()
{
    <span class="hljs-keyword">int</span> x,y;
   <span class="hljs-keyword">while</span>(<span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d%d"</span>,&amp;n,&amp;m)!=EOF)
   {
       <span class="hljs-keyword">if</span>(n==-<span class="hljs-number">1</span>&amp;&amp;m==-<span class="hljs-number">1</span>)
           <span class="hljs-keyword">break</span>;
       <span class="hljs-built_in">memset</span>(vis,<span class="hljs-number">0</span>,<span class="hljs-keyword">sizeof</span>(vis));
       <span class="hljs-built_in">memset</span>(head,-<span class="hljs-number">1</span>,<span class="hljs-keyword">sizeof</span>(head));
       tot=<span class="hljs-number">0</span>;
       <span class="hljs-built_in">memset</span>(dp,<span class="hljs-number">0</span>,<span class="hljs-keyword">sizeof</span>(dp));
       <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)
       {
           <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d%d"</span>,&amp;bug[i],&amp;brain[i]);
       }
       <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;n;i++)
       {
           <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d%d"</span>,&amp;x,&amp;y);
           add(x,y);
           add(y,x);
       }
       dfs(<span class="hljs-number">1</span>);
       <span class="hljs-keyword">if</span>(m==<span class="hljs-number">0</span>)
           <span class="hljs-built_in">printf</span>(<span class="hljs-string">"0\n"</span>);
       <span class="hljs-keyword">else</span>
           <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d\n"</span>,dp[<span class="hljs-number">1</span>][m]);
   }
}</code></pre> 
  <p>这段代码并没有像前面那样，dfs的时候加上当前结点可以使用的小兵数量，似乎这样写下去并没有体现要攻打子节点必须攻克父节点这个限制条件啊，但这的确是对的。我的猜想是，这是两个不同的规划方式，第一个规划方式，你可以打一个dp二维数组的表，发现它是一个严格的从根节点往下，必须满足父节点被攻克，子节点才可以有最优值。而第二种方式，你可以发现，它的dp二维数组表，是以每一个结点为根节点得到这个结点的最优值。也就是说当我规划到这个节点，不用管它的父节点他就是根。所以回朔到根节点的时候，依然可以保证要攻打子节点必须攻克父节点这个限制条件，最终的值也是正确的。如果问题变成这样，你可以事先挑选某个结点作为根节点，往下去攻打。那么第二种解法就满足了 <br> 接下来，还是这个类型的题目但是又要更难一些， <br> (<a href="http://acm.hdu.edu.cn/showproblem.php?pid=4169" rel="nofollow">http://acm.hdu.edu.cn/showproblem.php?pid=4169</a>) <br> 题意：这个题目和前面的题目的区别就是，把要攻打子节点必须攻克父节点这个限制条件去掉了。加上一个，子节点和父节点不能共存。而且结点有1500000，所以你用dp数组表示结点的状态是肯定炸的。关键在于怎么设定dp数组，我感觉要不看博客accept这一题，是要对动态规划十分熟悉的。状态转移方程见代码，我把我的理解都写在注释里了</p> 
  <pre class="prettyprint"><code class="hljs cpp"><span class="hljs-preprocessor">#include &lt;iostream&gt;</span>
<span class="hljs-preprocessor">#include &lt;string.h&gt;</span>
<span class="hljs-preprocessor">#include &lt;algorithm&gt;</span>
<span class="hljs-preprocessor">#include &lt;math.h&gt;</span>
<span class="hljs-preprocessor">#include &lt;stdlib.h&gt;</span>

<span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;
<span class="hljs-preprocessor">#define MAX 1500000</span>
<span class="hljs-keyword">int</span> v[MAX+<span class="hljs-number">5</span>];
<span class="hljs-keyword">int</span> head[MAX+<span class="hljs-number">5</span>];
<span class="hljs-keyword">int</span> dp[<span class="hljs-number">305</span>];
<span class="hljs-keyword">int</span> n;
<span class="hljs-keyword">int</span> tot;
<span class="hljs-keyword">int</span> m;
<span class="hljs-keyword">struct</span> Node
{
    <span class="hljs-keyword">int</span> value;
    <span class="hljs-keyword">int</span> next;
}edge[MAX+<span class="hljs-number">5</span>];
<span class="hljs-keyword">void</span> add(<span class="hljs-keyword">int</span> x,<span class="hljs-keyword">int</span> y)
{
    edge[tot].value=y;
    edge[tot].next=head[x];
    head[x]=tot++;
}
<span class="hljs-keyword">int</span> dfs(<span class="hljs-keyword">int</span> root)
{
    <span class="hljs-keyword">int</span> t=<span class="hljs-number">0</span>;
    <span class="hljs-keyword">int</span> tag=<span class="hljs-number">0</span>;
    <span class="hljs-keyword">int</span> cur[<span class="hljs-number">305</span>];<span class="hljs-comment">//这个数组是不断替换的</span>
    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;=m;i++)
        dp[i]=cur[i]=-<span class="hljs-number">1</span>;
    dp[<span class="hljs-number">0</span>]=cur[<span class="hljs-number">0</span>]=<span class="hljs-number">0</span>;
    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=head[root];i!=-<span class="hljs-number">1</span>;i=edge[i].next)
    {
        tag=<span class="hljs-number">1</span>;
        <span class="hljs-keyword">int</span> k=edge[i].value;
        <span class="hljs-comment">//得到子树的状态数</span>
        <span class="hljs-keyword">int</span> state=dfs(k);
        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=t;j&gt;=<span class="hljs-number">0</span>;j--)
        {
            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> p=<span class="hljs-number">1</span>;p&lt;=state;p++)
            {
                <span class="hljs-keyword">if</span>(p+j&gt;m)
                    <span class="hljs-keyword">break</span>;
                cur[p+j]=max(cur[p+j],dp[p]+cur[j]);
            }
        }
        t+=state;
    }
    <span class="hljs-keyword">if</span>(!tag) t++;
    cur[<span class="hljs-number">1</span>]=max(cur[<span class="hljs-number">1</span>],v[root]);
    <span class="hljs-comment">//把当前子树的状态保存到dp数组里，这里的dp数组表示当前这颗树的最优值，cur数组也是</span>
    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;=m;i++)
        dp[i]=cur[i];
    <span class="hljs-keyword">return</span> t;
}
<span class="hljs-keyword">int</span> main()
{
    <span class="hljs-keyword">int</span> a;
    <span class="hljs-keyword">int</span> root;
    <span class="hljs-keyword">while</span>(<span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d%d"</span>,&amp;n,&amp;m)!=EOF)
    {
        <span class="hljs-built_in">memset</span>(head,-<span class="hljs-number">1</span>,<span class="hljs-keyword">sizeof</span>(head));
        tot=<span class="hljs-number">0</span>;
        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)
        {
            <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d%d"</span>,&amp;a,&amp;v[i]);
            <span class="hljs-keyword">if</span>(a==<span class="hljs-number">0</span>)
                root=i;
            add(a,i);
        }
        dfs(root);
        <span class="hljs-keyword">if</span>(dp[m]==-<span class="hljs-number">1</span>)
            <span class="hljs-built_in">printf</span>(<span class="hljs-string">"impossible\n"</span>);
        <span class="hljs-keyword">else</span>
            <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d\n"</span>,dp[m]);

    }
    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}</code></pre> 
  <p>这道题目定义了两个状态数组，cur[],dp[]。dp[]里面保存的是最终的答案，cur[]是一个临时的数组表示子树的状态。 <br> 看另一道不同风格的题目吧 <br> (<a href="http://acm.hdu.edu.cn/showproblem.php?pid=2412" rel="nofollow">http://acm.hdu.edu.cn/showproblem.php?pid=2412</a>) <br> 这道题目和前面一道非常相似，但是有一点不同，它要询问这个最优值是不是只有一种组合方式。这道题目的解决方法是，再开一个状态数组，表示当前的最优值是不是唯一，如果能想到这里，问题就好解决了</p> 
  <pre class="prettyprint"><code class="hljs cpp"><span class="hljs-preprocessor">#include &lt;iostream&gt;</span>
<span class="hljs-preprocessor">#include &lt;string.h&gt;</span>
<span class="hljs-preprocessor">#include &lt;math.h&gt;</span>
<span class="hljs-preprocessor">#include &lt;stdlib.h&gt;</span>
<span class="hljs-preprocessor">#include &lt;algorithm&gt;</span>
<span class="hljs-preprocessor">#include &lt;map&gt;</span>
<span class="hljs-preprocessor">#include &lt;string&gt;</span>

<span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;
<span class="hljs-preprocessor">#define MAX 200</span>
<span class="hljs-stl_container"><span class="hljs-built_in">map</span>&lt;<span class="hljs-built_in">string</span>,<span class="hljs-keyword">int</span>&gt;</span>m;
<span class="hljs-keyword">int</span> n;
<span class="hljs-built_in">string</span> a,b;
<span class="hljs-keyword">int</span> tot;
<span class="hljs-keyword">int</span> head[MAX+<span class="hljs-number">5</span>];
<span class="hljs-keyword">int</span> dp[MAX+<span class="hljs-number">5</span>][<span class="hljs-number">2</span>];
<span class="hljs-keyword">int</span> dup[MAX+<span class="hljs-number">5</span>][<span class="hljs-number">2</span>];
<span class="hljs-keyword">bool</span> tag;
<span class="hljs-keyword">struct</span> Node
{
    <span class="hljs-keyword">int</span> value;
    <span class="hljs-keyword">int</span> next;
}edge[MAX*<span class="hljs-number">2</span>+<span class="hljs-number">5</span>];
<span class="hljs-keyword">void</span> add(<span class="hljs-keyword">int</span> x,<span class="hljs-keyword">int</span> y)
{
    edge[tot].value=y;
    edge[tot].next=head[x];
    head[x]=tot++;
}
<span class="hljs-keyword">void</span> dfs(<span class="hljs-keyword">int</span> root)
{
      dp[root][<span class="hljs-number">1</span>]=<span class="hljs-number">1</span>;
      dp[root][<span class="hljs-number">0</span>]=<span class="hljs-number">0</span>;
      dup[root][<span class="hljs-number">1</span>]=<span class="hljs-number">1</span>;
      dup[root][<span class="hljs-number">0</span>]=<span class="hljs-number">1</span>;
      <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=head[root];i!=-<span class="hljs-number">1</span>;i=edge[i].next)
      {
          <span class="hljs-keyword">int</span> k=edge[i].value;
          dfs(k);
          dp[root][<span class="hljs-number">1</span>]+=dp[k][<span class="hljs-number">0</span>];
          dp[root][<span class="hljs-number">0</span>]+=max(dp[k][<span class="hljs-number">0</span>],dp[k][<span class="hljs-number">1</span>]);
          <span class="hljs-keyword">if</span>(dp[k][<span class="hljs-number">1</span>]&lt;dp[k][<span class="hljs-number">0</span>]&amp;&amp;dup[k][<span class="hljs-number">0</span>]==<span class="hljs-number">0</span>)
              dup[root][<span class="hljs-number">0</span>]=<span class="hljs-number">0</span>;
          <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(dp[k][<span class="hljs-number">1</span>]&gt;dp[k][<span class="hljs-number">0</span>]&amp;&amp;dup[k][<span class="hljs-number">1</span>]==<span class="hljs-number">0</span>)
              dup[root][<span class="hljs-number">0</span>]=<span class="hljs-number">0</span>;
          <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(dp[k][<span class="hljs-number">1</span>]==dp[k][<span class="hljs-number">0</span>])
              dup[root][<span class="hljs-number">0</span>]=<span class="hljs-number">0</span>;
          <span class="hljs-keyword">if</span>(dup[k][<span class="hljs-number">0</span>]==<span class="hljs-number">0</span>)
              dup[root][<span class="hljs-number">1</span>]=<span class="hljs-number">0</span>;


      }
}
<span class="hljs-keyword">int</span> main()
{
    <span class="hljs-keyword">while</span>(<span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d"</span>,&amp;n)!=EOF)
    {
        <span class="hljs-keyword">if</span>(n==<span class="hljs-number">0</span>)
            <span class="hljs-keyword">break</span>;
        <span class="hljs-built_in">memset</span>(head,-<span class="hljs-number">1</span>,<span class="hljs-keyword">sizeof</span>(head));
        m.clear();
        <span class="hljs-built_in">cin</span>&gt;&gt;a;
        m[a]=<span class="hljs-number">1</span>;
        <span class="hljs-keyword">int</span> cnt=<span class="hljs-number">1</span>;
        tot=<span class="hljs-number">0</span>;
        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;n;i++)
        {
            <span class="hljs-built_in">cin</span>&gt;&gt;a&gt;&gt;b;
            <span class="hljs-keyword">if</span>(!m.count(a))
                m[a]=++cnt;
            <span class="hljs-keyword">if</span>(!m.count(b))
                m[b]=++cnt;
            add(m[b],m[a]);
        }
        <span class="hljs-built_in">memset</span>(dp,<span class="hljs-number">0</span>,<span class="hljs-keyword">sizeof</span>(dp));
        <span class="hljs-built_in">memset</span>(dup,<span class="hljs-number">0</span>,<span class="hljs-keyword">sizeof</span>(dup));
        dfs(<span class="hljs-number">1</span>);
        <span class="hljs-keyword">if</span>(dp[<span class="hljs-number">1</span>][<span class="hljs-number">1</span>]&gt;dp[<span class="hljs-number">1</span>][<span class="hljs-number">0</span>]&amp;&amp;dup[<span class="hljs-number">1</span>][<span class="hljs-number">1</span>]==<span class="hljs-number">1</span>)
            <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d Yes\n"</span>,dp[<span class="hljs-number">1</span>][<span class="hljs-number">1</span>]);
        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(dp[<span class="hljs-number">1</span>][<span class="hljs-number">0</span>]&gt;dp[<span class="hljs-number">1</span>][<span class="hljs-number">1</span>]&amp;&amp;dup[<span class="hljs-number">1</span>][<span class="hljs-number">0</span>]==<span class="hljs-number">1</span>)
            <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d Yes\n"</span>,dp[<span class="hljs-number">1</span>][<span class="hljs-number">0</span>]);
        <span class="hljs-keyword">else</span> 
            <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d No\n"</span>,max(dp[<span class="hljs-number">1</span>][<span class="hljs-number">1</span>],dp[<span class="hljs-number">1</span>][<span class="hljs-number">0</span>]));
    }
    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;

}</code></pre> 
  <p>前面说的都是在节点的值上面进行动态规划，下面看如果要在边上吗进行规划呢？ <br><a href="http://acm.hdu.edu.cn/showproblem.php?pid=3452" rel="nofollow">HDU-3452 Bonsai</a> <br> 题意就是给你一棵树，每个边都有权值，问你剪去那些边，可以让叶子节点不能达到根节点，且剪去边的权值和最小 <br> 思路：为了达到让叶子节点不能达到根节点的目的，你有两种选择要么剪去根节点和下一个子节点的边，要么不剪这条边，直接到子树里面取剪。状态转移方程也就清晰了，见代码里</p> 
  <pre class="prettyprint"><code class="hljs cpp"><span class="hljs-preprocessor">#include &lt;iostream&gt;</span>
<span class="hljs-preprocessor">#include &lt;string.h&gt;</span>
<span class="hljs-preprocessor">#include &lt;algorithm&gt;</span>
<span class="hljs-preprocessor">#include &lt;math.h&gt;</span>
<span class="hljs-preprocessor">#include &lt;stdlib.h&gt;</span>

<span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;
<span class="hljs-preprocessor">#define MAX 1000</span>
<span class="hljs-keyword">struct</span> Node
{
    <span class="hljs-keyword">int</span> value;
    <span class="hljs-keyword">int</span> next;
    <span class="hljs-keyword">int</span> weight;
}edge[MAX*<span class="hljs-number">2</span>+<span class="hljs-number">5</span>];
<span class="hljs-keyword">int</span> tot;
<span class="hljs-keyword">int</span> n,r;
<span class="hljs-keyword">int</span> a,b,c;
<span class="hljs-keyword">int</span> head[MAX+<span class="hljs-number">5</span>];
<span class="hljs-keyword">int</span> vis[MAX+<span class="hljs-number">5</span>];
<span class="hljs-keyword">int</span> dp[MAX+<span class="hljs-number">5</span>];
<span class="hljs-keyword">void</span> add(<span class="hljs-keyword">int</span> x,<span class="hljs-keyword">int</span> y,<span class="hljs-keyword">int</span> w)
{
    edge[tot].weight=w;
    edge[tot].value=y;
    edge[tot].next=head[x];
    head[x]=tot++;
}
<span class="hljs-keyword">void</span> dfs(<span class="hljs-keyword">int</span> root)
{


     vis[root]=<span class="hljs-number">1</span>;
     <span class="hljs-keyword">int</span> tag=<span class="hljs-number">0</span>;
     <span class="hljs-keyword">int</span> sum;
     <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=head[root];i!=-<span class="hljs-number">1</span>;i=edge[i].next)
     {
         <span class="hljs-keyword">int</span> k=edge[i].value;
         sum=edge[i].weight;
         <span class="hljs-keyword">if</span>(!vis[k])
         {
              tag=<span class="hljs-number">1</span>;
              dfs(k);
              dp[root]+=min(sum,dp[k]);
         }


     }
      <span class="hljs-keyword">if</span>(tag==<span class="hljs-number">0</span>)
            dp[root]=sum;
}
<span class="hljs-keyword">int</span> main()
{

    <span class="hljs-keyword">while</span>(<span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d%d"</span>,&amp;n,&amp;r)!=EOF)
    {

        <span class="hljs-keyword">if</span>(n==<span class="hljs-number">0</span>&amp;&amp;r==<span class="hljs-number">0</span>)
            <span class="hljs-keyword">break</span>;
        tot=<span class="hljs-number">0</span>;
        <span class="hljs-built_in">memset</span>(head,-<span class="hljs-number">1</span>,<span class="hljs-keyword">sizeof</span>(head));
        <span class="hljs-built_in">memset</span>(dp,<span class="hljs-number">0</span>,<span class="hljs-keyword">sizeof</span>(dp));
        <span class="hljs-built_in">memset</span>(vis,<span class="hljs-number">0</span>,<span class="hljs-keyword">sizeof</span>(vis));
        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;n-<span class="hljs-number">1</span>;i++)
        {
            <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d%d%d"</span>,&amp;a,&amp;b,&amp;c);
            add(a,b,c);
            add(b,a,c);
        }
        <span class="hljs-keyword">if</span>(n==<span class="hljs-number">1</span>)
            <span class="hljs-built_in">printf</span>(<span class="hljs-string">"0\n"</span>);
        <span class="hljs-keyword">else</span>
        {
          dfs(r);
          <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d\n"</span>,dp[r]);
        }

    }
    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}</code></pre> 
  <p>再看一道这道题目的升级版，题意一样，不同的就是问你的是最小限制，就是你选取剪去的边里面权值最大的。这道题目的思路就是树形dp加二分，状态转移方程稍微变一下，加上一个限制。二分其实就是枚举这个限制，二分更快一点而已。 <br> 题目要问的是最小的最大限制，必然二分答案。 <br><a href="http://acm.hdu.edu.cn/showproblem.php?pid=3586" rel="nofollow">HDU-3586 Information Disturbing</a></p> 
  <pre class="prettyprint"><code class="hljs cpp"><span class="hljs-preprocessor">#include &lt;iostream&gt;</span>
<span class="hljs-preprocessor">#include &lt;string.h&gt;</span>
<span class="hljs-preprocessor">#include &lt;algorithm&gt;</span>
<span class="hljs-preprocessor">#include &lt;stdlib.h&gt;</span>
<span class="hljs-preprocessor">#include &lt;math.h&gt;</span>

<span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;
<span class="hljs-preprocessor">#define MAX 1000</span>
<span class="hljs-keyword">int</span> dp[MAX+<span class="hljs-number">5</span>];
<span class="hljs-keyword">int</span> head[MAX+<span class="hljs-number">5</span>];
<span class="hljs-keyword">int</span> vis[MAX+<span class="hljs-number">5</span>];
<span class="hljs-keyword">int</span> n,m;
<span class="hljs-keyword">int</span> tot;
<span class="hljs-keyword">int</span> maxin;
<span class="hljs-keyword">struct</span> Node
{
    <span class="hljs-keyword">int</span> value;
    <span class="hljs-keyword">int</span> weight;
    <span class="hljs-keyword">int</span> next;
}edge[MAX*<span class="hljs-number">2</span>+<span class="hljs-number">5</span>];
<span class="hljs-keyword">void</span> add(<span class="hljs-keyword">int</span> x,<span class="hljs-keyword">int</span> y,<span class="hljs-keyword">int</span> weight)
{
    edge[tot].weight=weight;
    edge[tot].value=y;
    edge[tot].next=head[x];
    head[x]=tot++;
}
<span class="hljs-keyword">void</span> dfs(<span class="hljs-keyword">int</span> root,<span class="hljs-keyword">int</span> limit)
{

    vis[root]=<span class="hljs-number">1</span>;
    <span class="hljs-keyword">bool</span> tag=<span class="hljs-keyword">false</span>;
    <span class="hljs-keyword">int</span> sum=<span class="hljs-number">0</span>;
    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=head[root];i!=-<span class="hljs-number">1</span>;i=edge[i].next)
    {

        <span class="hljs-keyword">int</span> k=edge[i].value;
        sum=edge[i].weight;
        <span class="hljs-keyword">if</span>(!vis[k])
        {
            tag=<span class="hljs-keyword">true</span>;
            dfs(k,limit);
            <span class="hljs-keyword">if</span>(sum&gt;limit)
                dp[root]+=dp[k];
            <span class="hljs-keyword">else</span>
                dp[root]+=min(dp[k],sum);

        }
    }
    <span class="hljs-keyword">if</span>(!tag)
        dp[root]=<span class="hljs-number">1000010</span>;
}
<span class="hljs-keyword">int</span> main()
{
    <span class="hljs-keyword">int</span> x,y,z;
    <span class="hljs-keyword">while</span>(<span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d%d"</span>,&amp;n,&amp;m)!=EOF)
    {
        <span class="hljs-keyword">if</span>(n==<span class="hljs-number">0</span>&amp;&amp;m==<span class="hljs-number">0</span>)
            <span class="hljs-keyword">break</span>;
        <span class="hljs-built_in">memset</span>(head,-<span class="hljs-number">1</span>,<span class="hljs-keyword">sizeof</span>(head));
        tot=<span class="hljs-number">0</span>;maxin=<span class="hljs-number">0</span>;
        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;n;i++)
        {
            <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d%d%d"</span>,&amp;x,&amp;y,&amp;z);
            maxin=max(maxin,z);
            add(x,y,z);
            add(y,x,z);
        }
        <span class="hljs-keyword">int</span> l=<span class="hljs-number">1</span>;<span class="hljs-keyword">int</span> r=maxin;<span class="hljs-keyword">int</span> ans=-<span class="hljs-number">1</span>;
        <span class="hljs-keyword">while</span>(l&lt;=r)
        {
            <span class="hljs-keyword">int</span> mid=(l+r)/<span class="hljs-number">2</span>;
            <span class="hljs-built_in">memset</span>(vis,<span class="hljs-number">0</span>,<span class="hljs-keyword">sizeof</span>(vis));
            <span class="hljs-built_in">memset</span>(dp,<span class="hljs-number">0</span>,<span class="hljs-keyword">sizeof</span>(dp));
            dfs(<span class="hljs-number">1</span>,mid);
            <span class="hljs-keyword">if</span>(dp[<span class="hljs-number">1</span>]&lt;=m)
            {
                ans=mid;
                r=mid-<span class="hljs-number">1</span>;
            }
            <span class="hljs-keyword">else</span>
                l=mid+<span class="hljs-number">1</span>;
        }
         <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d\n"</span>,ans);

    }
    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}</code></pre> 
 </div> 
</div> 
<p>转载于:https://www.cnblogs.com/dacc123/p/8228832.html</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/c275fad8c0a6dffd843f5181f038b193/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">C语言劫持</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/a85e23cb2f7ddde6c9ae7026fb7e0348/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">利用ajax向控制器中传二维数组</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>