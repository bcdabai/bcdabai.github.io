<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>设置请求头信息的不同方式 - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="设置请求头信息的不同方式" />
<meta property="og:description" content="原文：http://blog.csdn.net/magiclr/article/details/49643277
在AngularJs中有三种方式可以设置请求头信息：
1、在http服务的服务端发送请求时，也就是调用http()方法时，在config对象中设置请求头信息：
$http.post(&#39;/somePath&#39; , someData , { headers : {&#39;Authorization&#39; : authToken} }).success(function(data, status, headers, config) { //... }).error(function(data, status, headers, config ) { //... }); 这种方法的好处是针对不同路径的请求，可以个性化配置请求头部；
缺点就是，不同路径请求都需要单独配置。
2、第二种设置请求头信息的方式就是在$httpProvider.defaults.headers属性上直接配置。
angular.module(&#39;app&#39;, []) .config(function($httpProvider) { $httpProvider.defaults.headers.common = { &#39;My-Header&#39; : &#39;value&#39; } }) $httpProvider.defaults.headers有不同的属性，如common、get、post、put等。因此可以在不同的http请求上面添加不同的头信息，common是指所有的请求方式。
这种方式添加请求头信息的优势就是可以给不同请求方式添加相同的请求头信息；
缺点就是不能够为某些请求path添加个性化头信息。
3、第三种设置请求头信息的地方是$httpProvider.interceptors。也就是为请求或响应注册一个拦截器。使用这种方式首先需要定义一个服务。
myModule.factory(&#39;authInterceptor&#39;, function($rootScope, $cookies){ return { request: function(config){ config.headers = config.headers || {}; if($cookies.get(&#39;token&#39;)){ config.headers.authorization = &#39;Bearer &#39; &#43; $cookies.get(&#39;token&#39;); } return config; }, responseError: function(response){ // ." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/7ad02959ef58343054eaa406f5b7e115/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2016-08-03T11:14:00+08:00" />
<meta property="article:modified_time" content="2016-08-03T11:14:00+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">设置请求头信息的不同方式</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <div id="cnblogs_post_body" class="blogpost-body"> 
 <p>原文：<a href="http://blog.csdn.net/magiclr/article/details/49643277">http://blog.csdn.net/magiclr/article/details/49643277</a></p> 
 <p>在AngularJs中有三种方式可以设置请求头信息：</p> 
 <p>1、在<span class="MathJax_Preview"><span id="MathJax-Element-2-Frame" class="MathJax"><span id="MathJax-Span-1" class="math"><span id="MathJax-Span-2" class="mrow"><span id="MathJax-Span-3" class="mi">h<span id="MathJax-Span-4" class="mi">t<span id="MathJax-Span-5" class="mi">t<span id="MathJax-Span-6" class="mi">p<span id="MathJax-Span-7" class="texatom"><span id="MathJax-Span-8" class="mrow"><span id="MathJax-Span-9" class="mo">服<span id="MathJax-Span-10" class="texatom"><span id="MathJax-Span-11" class="mrow"><span id="MathJax-Span-12" class="mo">务<span id="MathJax-Span-13" class="texatom"><span id="MathJax-Span-14" class="mrow"><span id="MathJax-Span-15" class="mo">的<span id="MathJax-Span-16" class="texatom"><span id="MathJax-Span-17" class="mrow"><span id="MathJax-Span-18" class="mo"><span id="MathJax-Span-19" class="texatom"><span id="MathJax-Span-20" class="mrow"><span id="MathJax-Span-21" class="mo">服<span id="MathJax-Span-22" class="texatom"><span id="MathJax-Span-23" class="mrow"><span id="MathJax-Span-24" class="mo">务<span id="MathJax-Span-25" class="texatom"><span id="MathJax-Span-26" class="mrow"><span id="MathJax-Span-27" class="mo">端<span id="MathJax-Span-28" class="texatom"><span id="MathJax-Span-29" class="mrow"><span id="MathJax-Span-30" class="mo">发<span id="MathJax-Span-31" class="texatom"><span id="MathJax-Span-32" class="mrow"><span id="MathJax-Span-33" class="mo">送<span id="MathJax-Span-34" class="texatom"><span id="MathJax-Span-35" class="mrow"><span id="MathJax-Span-36" class="mo">请<span id="MathJax-Span-37" class="texatom"><span id="MathJax-Span-38" class="mrow"><span id="MathJax-Span-39" class="mo">求<span id="MathJax-Span-40" class="texatom"><span id="MathJax-Span-41" class="mrow"><span id="MathJax-Span-42" class="mo">时<span id="MathJax-Span-43" class="texatom"><span id="MathJax-Span-44" class="mrow"><span id="MathJax-Span-45" class="mo">，<span id="MathJax-Span-46" class="texatom"><span id="MathJax-Span-47" class="mrow"><span id="MathJax-Span-48" class="mo">也<span id="MathJax-Span-49" class="texatom"><span id="MathJax-Span-50" class="mrow"><span id="MathJax-Span-51" class="mo">就<span id="MathJax-Span-52" class="texatom"><span id="MathJax-Span-53" class="mrow"><span id="MathJax-Span-54" class="mo">是<span id="MathJax-Span-55" class="texatom"><span id="MathJax-Span-56" class="mrow"><span id="MathJax-Span-57" class="mo">调<span id="MathJax-Span-58" class="texatom"><span id="MathJax-Span-59" class="mrow"><span id="MathJax-Span-60" class="mo">用</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span>http()方法时，在config对象中设置请求头信息：</span></span></p> 
 <div class="cnblogs_code"> 
  <pre> $http.post('/somePath'<span style="color:#000000;"> , someData , {
        headers : {<!-- --></span>'Authorization'<span style="color:#000000;"> : authToken}
    }).success(</span><span style="color:#0000ff;">function</span><span style="color:#000000;">(data, status, headers, config) {
        </span><span style="color:#008000;">//</span><span style="color:#008000;">...</span>
    }).error(<span style="color:#0000ff;">function</span><span style="color:#000000;">(data, status, headers, config ) {
        </span><span style="color:#008000;">//</span><span style="color:#008000;">...</span>
    });</pre> 
 </div> 
 <p> </p> 
 <p>这种方法的好处是针对不同路径的请求，可以个性化配置请求头部；</p> 
 <p>缺点就是，不同路径请求都需要单独配置。</p> 
 <p>2、第二种设置请求头信息的方式就是在$httpProvider.defaults.headers属性上直接配置。</p> 
 <div class="cnblogs_code"> 
  <pre>angular.module('app'<span style="color:#000000;">, [])
.config(</span><span style="color:#0000ff;">function</span><span style="color:#000000;">($httpProvider) {
    $httpProvider.defaults.headers.common </span>= { 'My-Header' : 'value'<span style="color:#000000;"> }
})</span></pre> 
 </div> 
 <p> </p> 
 <p>$httpProvider.defaults.headers有不同的属性，如common、get、post、put等。因此可以在不同的http请求上面添加不同的头信息，common是指所有的请求方式。</p> 
 <p>这种方式添加请求头信息的优势就是可以给不同请求方式添加相同的请求头信息；</p> 
 <p>缺点就是不能够为某些请求path添加个性化头信息。</p> 
 <p>3、第三种设置请求头信息的地方是$httpProvider.interceptors。也就是为请求或响应注册一个拦截器。使用这种方式首先需要定义一个服务。</p> 
 <div class="cnblogs_code"> 
  <pre>myModule.factory('authInterceptor', <span style="color:#0000ff;">function</span><span style="color:#000000;">($rootScope,  $cookies){
    </span><span style="color:#0000ff;">return</span><span style="color:#000000;"> {
        request: </span><span style="color:#0000ff;">function</span><span style="color:#000000;">(config){
            config.headers </span>= config.headers ||<span style="color:#000000;"> {};
            </span><span style="color:#0000ff;">if</span>($cookies.get('token'<span style="color:#000000;">)){
                config.headers.authorization </span>= 'Bearer ' + $cookies.get('token'<span style="color:#000000;">);
            }
            </span><span style="color:#0000ff;">return</span><span style="color:#000000;"> config;
        },
        responseError: </span><span style="color:#0000ff;">function</span><span style="color:#000000;">(response){
            </span><span style="color:#008000;">//</span><span style="color:#008000;"> ...</span>
<span style="color:#000000;">        }
    };
})</span></pre> 
 </div> 
 <p> </p> 
 <p>然后把上面定义的服务注册到$httpProvider.interceptors中。</p> 
 <div class="cnblogs_code"> 
  <pre>.config(<span style="color:#0000ff;">function</span><span style="color:#000000;">($httpProvider){
    $httpProvider.interceptors.push(</span>'authInterceptor'<span style="color:#000000;">);
})</span></pre> 
 </div> 
 <p> </p> 
 <p>这样，对于每次请求，不论是get还是post、put。我们都会在请求头信息中加入authorization属性。这种方式在处理验权、授权方面很有用的。缺点就是不能够为特定的请求方式添加请求头信息。</p> 
 <p> </p> 
 <p>下面详细介绍下第三种方法：</p> 
 <p>AngularJS 提供了 <a href="https://docs.angularjs.org/api/ng/service/%24http#Interceptors" rel="nofollow">Interceptors</a> ——拦截战斗机——来对应用内所有的 XHR 请求进行统一处理。</p> 
 <p><strong>主要功能</strong></p> 
 <p>Interceptors 有两个处理时机，分别是：</p> 
 <ul><li>其它程序代码执行 HTTP 请求之后，在实际从浏览器发出请求之前，即处理请求</li><li>得到请求的响应之后，在交给其它程序代码处理之前，即处理请求的响应</li></ul> 
 <p>所以，不难理解它可以用于如下几个方面：</p> 
 <ul><li>全局处理错误</li><li>统一进行身份验证一类的处理</li><li>对所有发出去的请求进行预处理</li><li>对所有收到的响应进行预处理</li><li>做一些增强用户体验的操作，例如显示一个进度条</li></ul> 
 <div class="cnblogs_code"> 
  <pre><span style="color:#0000ff;">var</span> app = angular.module('app'<span style="color:#000000;">, []);

</span><span style="color:#008000;">//</span><span style="color:#008000;"> 定义一个 Service ，稍等将会把它作为 Interceptors 的处理函数</span>
app.factory('HttpInterceptor', ['$q'<span style="color:#000000;">, HttpInterceptor]);

</span><span style="color:#0000ff;">function</span><span style="color:#000000;"> HttpInterceptor($q) {
  </span><span style="color:#0000ff;">return</span><span style="color:#000000;"> {
    request: </span><span style="color:#0000ff;">function</span><span style="color:#000000;">(config){
      </span><span style="color:#0000ff;">return</span><span style="color:#000000;"> config;
    },
    requestError: </span><span style="color:#0000ff;">function</span><span style="color:#000000;">(err){
      </span><span style="color:#0000ff;">return</span><span style="color:#000000;"> $q.reject(err);
    },
    response: </span><span style="color:#0000ff;">function</span><span style="color:#000000;">(res){
      </span><span style="color:#0000ff;">return</span><span style="color:#000000;"> res;
    },
    responseError: </span><span style="color:#0000ff;">function</span><span style="color:#000000;">(err){
      </span><span style="color:#0000ff;">if</span>(-1 ===<span style="color:#000000;"> err.status) {
        </span><span style="color:#008000;">//</span><span style="color:#008000;"> 远程服务器无响应</span>
      } <span style="color:#0000ff;">else</span> <span style="color:#0000ff;">if</span>(500 ===<span style="color:#000000;"> err.status) {
        </span><span style="color:#008000;">//</span><span style="color:#008000;"> 处理各类自定义错误</span>
      } <span style="color:#0000ff;">else</span> <span style="color:#0000ff;">if</span>(501 ===<span style="color:#000000;"> err.status) {
        </span><span style="color:#008000;">//</span><span style="color:#008000;"> ...</span>
<span style="color:#000000;">      }
      </span><span style="color:#0000ff;">return</span><span style="color:#000000;"> $q.reject(err);
    }
  };
}

</span><span style="color:#008000;">//</span><span style="color:#008000;"> 添加对应的 Interceptors</span>
app.config(['$httpProvider', <span style="color:#0000ff;">function</span><span style="color:#000000;">($httpProvider){
  $httpProvider.interceptors.push(HttpInterceptor);
}]);</span></pre> 
 </div> 
 <p>实际的 Interceptor 处理函数中， <code>return</code> 了一个包含四个成员的对象，这四个成员都 <strong>不是必须</strong> 的，可以按实际情况指定一二，分别如下：</p> 
 <ul><li><strong><code>request</code> </strong>：接收一个参数，它是 <code>$http</code> 中的标准 <a href="https://docs.angularjs.org/api/ng/service/%24http#usage" rel="nofollow">config</a> 对象，同时也需要返回一个标准 <code>config</code> ，此时可以添加各类身份验证信息，同时也可在此启动进度条，config.headers是一个标准的头部，可以获取config.headers设置其头部，然后返回这个config。</li><li><strong><code>requestError</code> </strong>：当有多个 Interceptor 的时候， <code>requestError</code> 会在前一个 Interceptor 抛出错误或者执行 <code>$q.reject()</code> 时执行，接收的参数就对应的错误</li><li><strong><code>response</code> </strong>：接受一个请求对象参数，可以不处理就直接返回，此时也可以将进度条显示为成功完成，当然，如果后端 API 返回自定义错误时，HTTP 的状态码仍然是 200 得话，便在这里处理自定义错误，也可以对返回数据做一些处理，注意要将进度条置为完成</li><li><strong><code>responseError</code> </strong>：这个是重头戏，即可以处理标准的 Http 错误，如服务器没有响应时，或者 PHP 之类的 CGI 经常出现的 502 一类，还可以处理 HTTP 状态码不是 200 的各类自定义错误</li></ul> 
 <p>上面四个中，前两个是请求的前置处理，后两个是针对请求的响应的处理。</p> 
 <p>转自：<a href="http://www.tuicool.com/articles/eMZBN3" rel="nofollow">http://www.tuicool.com/articles/eMZBN3</a></p> 
 <p> </p> 
</div> 
<p>转载于:https://www.cnblogs.com/YangqinCao/p/5732082.html</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/14cc95d00030b8f83dbea725b1461077/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">android--登录例子，保存用户名和密码到这个应用所在文件中，从文件中读取用户名和密码</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/7831fda15d7331a949efd3b052429ac1/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">js各类验证和数据处理</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>