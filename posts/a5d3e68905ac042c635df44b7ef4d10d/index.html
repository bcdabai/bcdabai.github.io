<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>UNIX环境高级编程笔记 - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="UNIX环境高级编程笔记" />
<meta property="og:description" content="UNIX环境编程 一、UNIX基础知识1.1 Linux 主要特性1.2 Linux 内核1.3 Linux 目录结构1.4 登录1 登录名2.shell 1.5 输入和输出1. 文件描述符2. 标准输入、标准输出、标准错误3. 不带缓冲的IO4. 标准I/O 1.6 程序和进程1. 程序2. 进程和进程ID3. 进程控制4. 线程和线程ID 1.7 出错处理1.8 用户标识1.9 信号1.10 时间值1.11 系统调用和库函数 二、UNIX标准及实现2.1 ISO C2.2 函数sysconf、pathconf、和fpathconf2.3 ISO C和IEEE POSIX 三、文件I/O3.1 文件描述符3.2 函数open和openat3.3 函数creat3.4 函数close3.5 函数lseek3.6 函数read/write3.7 I/O的效率3.8 文件共享3.9 原子操作3.10 函数dup和dup23.11 函数sync、fsync和fdatasync3.12 函数fcntl3.13 函数ioctl3.14 /dev/fd 四、文件和目录4.1 函数stat、fstat、fstatat和lstat4.2 文件类型4.3 设置用户ID和设置组ID4.4 新文件和目录的所有权4.7 函数access和faccessat4.8 函数umask4.9 函数chmod、fchmod和fchmodat4.10 函数chown、fchown、fchownat和lchown4.11 文件长度4.12 文件截断4.13 文件系统4.14 函数link、linkat、unlink、unlinkat和remove4.15 函数rename和renameat4.16 符号链接4.17 创建和读取符号链接4.18 文件时间4.19 函数futimens、utimensat和utimes4.20 函数mkdir、mkdirat和rmdir4.21 读目录4." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/a5d3e68905ac042c635df44b7ef4d10d/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-04-28T20:14:25+08:00" />
<meta property="article:modified_time" content="2023-04-28T20:14:25+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">UNIX环境高级编程笔记</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-light">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p></p> 
<div class="toc"> 
 <h4>UNIX环境编程</h4> 
 <ul><li><a href="#UNIX_1" rel="nofollow">一、UNIX基础知识</a></li><li><ul><li><a href="#11_Linux__3" rel="nofollow">1.1 Linux 主要特性</a></li><li><a href="#12_Linux__27" rel="nofollow">1.2 Linux 内核</a></li><li><a href="#13__Linux__59" rel="nofollow">1.3 Linux 目录结构</a></li><li><a href="#14__86" rel="nofollow">1.4 登录</a></li><li><ul><li><a href="#1__88" rel="nofollow">1 登录名</a></li><li><a href="#2shell_95" rel="nofollow">2.shell</a></li></ul> 
   </li><li><a href="#15__99" rel="nofollow">1.5 输入和输出</a></li><li><ul><li><a href="#1__101" rel="nofollow">1. 文件描述符</a></li><li><a href="#2__105" rel="nofollow">2. 标准输入、标准输出、标准错误</a></li><li><a href="#3_IO_115" rel="nofollow">3. 不带缓冲的IO</a></li><li><a href="#4_IO_119" rel="nofollow">4. 标准I/O</a></li></ul> 
   </li><li><a href="#16__123" rel="nofollow">1.6 程序和进程</a></li><li><ul><li><a href="#1__125" rel="nofollow">1. 程序</a></li><li><a href="#2_ID_129" rel="nofollow">2. 进程和进程ID</a></li><li><a href="#3__133" rel="nofollow">3. 进程控制</a></li><li><a href="#4_ID_137" rel="nofollow">4. 线程和线程ID</a></li></ul> 
   </li><li><a href="#17__141" rel="nofollow">1.7 出错处理</a></li><li><a href="#18__172" rel="nofollow">1.8 用户标识</a></li><li><a href="#19__176" rel="nofollow">1.9 信号</a></li><li><a href="#110__188" rel="nofollow">1.10 时间值</a></li><li><a href="#111__201" rel="nofollow">1.11 系统调用和库函数</a></li></ul> 
  </li><li><a href="#UNIX_205" rel="nofollow">二、UNIX标准及实现</a></li><li><ul><li><a href="#21_ISO_C_207" rel="nofollow">2.1 ISO C</a></li><li><a href="#22_sysconfpathconffpathconf_231" rel="nofollow">2.2 函数sysconf、pathconf、和fpathconf</a></li><li><a href="#23_ISO_CIEEE_POSIX_242" rel="nofollow">2.3 ISO C和IEEE POSIX</a></li></ul> 
  </li><li><a href="#IO_246" rel="nofollow">三、文件I/O</a></li><li><ul><li><a href="#31__248" rel="nofollow">3.1 文件描述符</a></li><li><a href="#32_openopenat_254" rel="nofollow">3.2 函数open和openat</a></li><li><a href="#33_creat_278" rel="nofollow">3.3 函数creat</a></li><li><a href="#34_close_287" rel="nofollow">3.4 函数close</a></li><li><a href="#35_lseek_296" rel="nofollow">3.5 函数lseek</a></li><li><a href="#36_readwrite_316" rel="nofollow">3.6 函数read/write</a></li><li><a href="#37_IO_326" rel="nofollow">3.7 I/O的效率</a></li><li><a href="#38__330" rel="nofollow">3.8 文件共享</a></li><li><a href="#39__356" rel="nofollow">3.9 原子操作</a></li><li><a href="#310_dupdup2_375" rel="nofollow">3.10 函数dup和dup2</a></li><li><a href="#311_syncfsyncfdatasync_386" rel="nofollow">3.11 函数sync、fsync和fdatasync</a></li><li><a href="#312_fcntl_406" rel="nofollow">3.12 函数fcntl</a></li><li><a href="#313_ioctl_419" rel="nofollow">3.13 函数ioctl</a></li><li><a href="#314_devfd_431" rel="nofollow">3.14 /dev/fd</a></li></ul> 
  </li><li><a href="#_441" rel="nofollow">四、文件和目录</a></li><li><ul><li><a href="#41_statfstatfstatatlstat_443" rel="nofollow">4.1 函数stat、fstat、fstatat和lstat</a></li><li><a href="#42__454" rel="nofollow">4.2 文件类型</a></li><li><a href="#43_IDID_466" rel="nofollow">4.3 设置用户ID和设置组ID</a></li><li><a href="#44__468" rel="nofollow">4.4 新文件和目录的所有权</a></li><li><a href="#47_accessfaccessat_472" rel="nofollow">4.7 函数access和faccessat</a></li><li><a href="#48_umask_482" rel="nofollow">4.8 函数umask</a></li><li><a href="#49_chmodfchmodfchmodat_517" rel="nofollow">4.9 函数chmod、fchmod和fchmodat</a></li><li><a href="#410_chownfchownfchownatlchown_532" rel="nofollow">4.10 函数chown、fchown、fchownat和lchown</a></li><li><a href="#411__545" rel="nofollow">4.11 文件长度</a></li><li><a href="#412__555" rel="nofollow">4.12 文件截断</a></li><li><a href="#413__567" rel="nofollow">4.13 文件系统</a></li><li><a href="#414_linklinkatunlinkunlinkatremove_579" rel="nofollow">4.14 函数link、linkat、unlink、unlinkat和remove</a></li><li><a href="#415_renamerenameat_607" rel="nofollow">4.15 函数rename和renameat</a></li><li><a href="#416__618" rel="nofollow">4.16 符号链接</a></li><li><a href="#417__620" rel="nofollow">4.17 创建和读取符号链接</a></li><li><a href="#418__622" rel="nofollow">4.18 文件时间</a></li><li><a href="#419_futimensutimensatutimes_624" rel="nofollow">4.19 函数futimens、utimensat和utimes</a></li><li><a href="#420_mkdirmkdiratrmdir_626" rel="nofollow">4.20 函数mkdir、mkdirat和rmdir</a></li><li><a href="#421__645" rel="nofollow">4.21 读目录</a></li><li><a href="#422_chdirfchdirgetcwd_647" rel="nofollow">4.22 函数chdir、fchdir、getcwd</a></li><li><a href="#423__649" rel="nofollow">4.23 设备特殊文件</a></li></ul> 
  </li><li><a href="#IO_653" rel="nofollow">五、标准I/O库</a></li><li><ul><li><a href="#51_FILE_655" rel="nofollow">5.1 流和FILE对象</a></li><li><a href="#52__683" rel="nofollow">5.2 标准输入、标准输出和标准错误</a></li><li><a href="#53__687" rel="nofollow">5.3 缓冲</a></li><li><a href="#54__697" rel="nofollow">5.4 打开流</a></li><li><a href="#55__717" rel="nofollow">5.5 读和写流</a></li><li><a href="#56_IO_739" rel="nofollow">5.6 每次一行I/O</a></li><li><a href="#57_IO_757" rel="nofollow">5.7 二进制I/O</a></li><li><a href="#58__796" rel="nofollow">5.8 定位流</a></li><li><a href="#59_IO_798" rel="nofollow">5.9 格式化I/O</a></li><li><a href="#510__831" rel="nofollow">5.10 实现细节</a></li><li><a href="#511__840" rel="nofollow">5.11 临时文件</a></li><li><a href="#512__842" rel="nofollow">5.12 内存流</a></li><li><a href="#513_IO_844" rel="nofollow">5.13 标准I/O的替代软件</a></li></ul> 
  </li><li><a href="#_846" rel="nofollow">六、系统数据文件和信息</a></li><li><ul><li><a href="#61__848" rel="nofollow">6.1 口令文件</a></li><li><a href="#62__850" rel="nofollow">6.2 阴影文件</a></li><li><a href="#63__852" rel="nofollow">6.3 组文件</a></li><li><a href="#64_ID_854" rel="nofollow">6.4 附属组ID</a></li><li><a href="#65__856" rel="nofollow">6.5 实现区别</a></li><li><a href="#66__858" rel="nofollow">6.6 其他数据文件</a></li><li><a href="#67__860" rel="nofollow">6.7 登陆账户记录</a></li><li><a href="#68__862" rel="nofollow">6.8 系统标识</a></li><li><a href="#69__864" rel="nofollow">6.9 时间和日期例程</a></li></ul> 
  </li><li><a href="#_896" rel="nofollow">七、进程环境</a></li><li><ul><li><a href="#71_main_897" rel="nofollow">7.1 main函数</a></li><li><a href="#72__909" rel="nofollow">7.2 进程终止</a></li><li><a href="#73__953" rel="nofollow">7.3 命令行参数</a></li><li><a href="#74__961" rel="nofollow">7.4 环境表</a></li><li><a href="#75_C_967" rel="nofollow">7.5 C程序的存储空间布局</a></li><li><a href="#76__992" rel="nofollow">7.6 共享库</a></li><li><a href="#77__1006" rel="nofollow">7.7 存储空间分配</a></li><li><a href="#78__1029" rel="nofollow">7.8 环境变量</a></li><li><a href="#79_setjmolongjmp_1048" rel="nofollow">7.9 函数setjmo和longjmp</a></li><li><a href="#710__getrlimitsetrlimit_1058" rel="nofollow">7.10 函数getrlimit和setrlimit</a></li></ul> 
  </li><li><a href="#_1068" rel="nofollow">八、进程控制</a></li><li><ul><li><a href="#82__1070" rel="nofollow">8.2 进程标识</a></li></ul> 
 </li></ul> 
</div> 
<p></p> 
<h2><a id="UNIX_1"></a>一、UNIX基础知识</h2> 
<h3><a id="11_Linux__3"></a>1.1 Linux 主要特性</h3> 
<p>Linux 是一个基于文件的操作系统</p> 
<p>操作系统需要和硬件进行交互，对应 Linux 来说这些硬件都是文件，比如：操作系统会将 硬盘 , 鼠标 , 键盘 , 显示屏等抽象成一个设备文件来进行管理。</p> 
<p>Linux 操作系统是一种自由软件，是免费的，并且公开源代码。</p> 
<p>可以同时登陆多个用户，并且每个用户可以同时运行多个应用程序。</p> 
<p>提供了友好的图形用户界面，操作简单， 易于快速上手。</p> 
<p>支持多平台（这里指的是基于不同 CPU 架构的平台，比如国产 Linux 使用的龙芯等）</p> 
<p>UNIX体系结构<br> <img src="https://images2.imgbox.com/9a/0b/qHQHag4p_o.png" alt="在这里插入图片描述"><br> 内核：控制计算机运行资源，提供程序运行环境</p> 
<p>系统调用：内核的接口</p> 
<p>共用库函数：共用库函数构建在系统调用的接口上</p> 
<p>shell：shell是一个特殊的应用程序，为运行其他的应用程序提供接口</p> 
<h3><a id="12_Linux__27"></a>1.2 Linux 内核</h3> 
<p>Linux 系统从应用角度来看，分为内核空间和用户空间两个部分。内核空间是 Linux 操作系统的主要部分，但是仅有内核的操作系统是不能完成用户任务的。丰富并且功能强大的应用程序包是一个操作系统成功的必要件。这个和武林秘籍一样，不仅得有招式还得有内功心法。</p> 
<p>Linux 的内核主要由 5 个子系统组成：进程调度、内存管理、虚拟文件系统、网络接口、进程间通信。下面将依次讲解这 5 个子系统。</p> 
<ol><li>进程调度 SCHED</li></ol> 
<ul><li> <p>SCHED_OTHER：分时调度策略（默认），是用于针对普通进程的时间片轮转调度策略。</p> </li><li> <p>SCHED_FIFO：实时调度策略，是针对运行的实时性要求比较高、运行时间短的进程调度策略</p> </li><li> <p>SCHED_RR：实时调度策略，是针对实时性要求比较高、运行时间比较长的进程调度策略。</p> </li></ul> 
<ol start="2"><li>内存管理 MMU</li></ol> 
<ul><li> <p>内存管理是多个进程间的内存共享策略。在 Linux 中，内存管理主要说的是虚拟内存。</p> </li><li> <p>虚拟内存可以让进程拥有比实际物理内存更大的内存，可以是实际内存的很多倍。</p> </li><li> <p>每个进程的虚拟内存有不同的地址空间，多个进程的虚拟内存不会冲突。</p> </li></ul> 
<ol start="3"><li>虚拟文件系统 VFS</li></ol> 
<ul><li>在 Linux 下支持多种文件系统，如 ext、ext2、minix、umsdos、msdos、vfat、ntfs、proc、smb、ncp、iso9660、sysv、hpfs、affs 等。目前 Linux 下最常用的文件格式是 ext2 和 ext3。</li></ul> 
<ol start="4"><li>网络接口</li></ol> 
<ul><li>Linux 是在 Internet 飞速发展的时期成长起来的，所以 Linux 支持多种网络接口和协议。网络接口分为网络协议和驱动程序，网络协议是一种网络传输的通信标准，而网络驱动则是对硬件设备的驱动程序。Linux 支持的网络设备多种多样，几乎目前所有网络设备都有驱动程序。</li></ul> 
<ol start="5"><li>进程间通信</li></ol> 
<ul><li>Linux 操作系统支持多进程，进程之间需要进行数据的交流才能完成控制、协同工作等功能，Linux 的进程间通信是从 UNIX 系统继承过来的。Linux 下的进程间的通信方式主要有管道、信号、消息队列、共享内存和套接字等方法。</li></ul> 
<h3><a id="13__Linux__59"></a>1.3 Linux 目录结构</h3> 
<p><img src="https://images2.imgbox.com/aa/bf/SGPRkRaD_o.png" alt="在这里插入图片描述"></p> 
<pre><code class="prism language-cpp">在 linux 中根目录的子目录结构相对是固定的 <span class="token punctuation">(</span>名字固定<span class="token punctuation">)</span><span class="token punctuation">,</span> 不同的目录功能是也是固定的
bin<span class="token operator">:</span> binary<span class="token punctuation">,</span> 二进制文件目录，存储了可执行程序，今天要将的命令对应的可执行程序都在这个目录中
sbin<span class="token operator">:</span> super binary<span class="token punctuation">,</span> root 用户使用的一些二进制可执行程序
etc<span class="token operator">:</span> 配置文件目录，系统的或者用户自己安装的应用程序的配置文件都存储在这个目录中
lib<span class="token operator">:</span> library<span class="token punctuation">,</span> 存储了一些动态库和静态库，给系统或者安装的软件使用
media<span class="token operator">:</span> 挂载目录，挂载外部设备，比如：光驱，扫描仪
mnt<span class="token operator">:</span> 临时挂载目录，比如我们可以将 U 盘临时挂载到这个目录下
proc<span class="token operator">:</span> 内存使用的一个映射目录，给操作系统使用的
tmp<span class="token operator">:</span> 临时目录，存放临时数据，重启电脑数据就被自动删除了
boot<span class="token operator">:</span> 存储了开机相关的设置
home<span class="token operator">:</span> 存储了普通用户的家目录，家目录名和用户名相同
root<span class="token operator">:</span> root 用户的家目录
dev<span class="token operator">:</span> device <span class="token punctuation">,</span> 设备目录，Linux 中一切皆文件，所有的硬件会抽象成文件存储起来，比如：键盘， 鼠标
lost<span class="token operator">+</span>found<span class="token operator">:</span> 一般时候是空的，电脑异常关闭 <span class="token operator">/</span> 崩溃时用来存储这些无家可归的文件，用于用户系统恢复
opt<span class="token operator">:</span> 第三方软件的安装目录
var<span class="token operator">:</span> 存储了系统使用的一些经常会发生变化的文件， 比如：日志文件
usr<span class="token operator">:</span> unix system resource<span class="token punctuation">,</span> 系统的资源目录
<span class="token operator">/</span>usr<span class="token operator">/</span>bin<span class="token operator">:</span> 可执行的二进制应用程序
<span class="token operator">/</span>usr<span class="token operator">/</span>games<span class="token operator">:</span> 游戏目录
<span class="token operator">/</span>usr<span class="token operator">/</span>include<span class="token operator">:</span> 包含的标准头文件目录
<span class="token operator">/</span>usr<span class="token operator">/</span>local<span class="token operator">:</span> 和 opt 目录作用相同，安装第三方软件
环境变量表：PATH<span class="token operator">=</span><span class="token operator">/</span>bin<span class="token operator">:</span><span class="token operator">/</span>usr<span class="token operator">/</span>bin<span class="token operator">:</span><span class="token operator">/</span>usr<span class="token operator">/</span>local<span class="token operator">/</span>bin<span class="token operator">:</span><span class="token punctuation">.</span>    PATH 变量包含了一张目录表<span class="token punctuation">(</span>称为路径前缀<span class="token punctuation">)</span>，目录之间用冒号<span class="token punctuation">(</span><span class="token operator">:</span><span class="token punctuation">)</span>分隔。
</code></pre> 
<h3><a id="14__86"></a>1.4 登录</h3> 
<h4><a id="1__88"></a>1 登录名</h4> 
<pre><code>登录名、加密口令、数字用户ID、数字组、注释字段、起始目录、shell程序
dyc:x:205:105:trdycdyc:/home/dyc:/bin/dsh
</code></pre> 
<h4><a id="2shell_95"></a>2.shell</h4> 
<p>分为两种： 1、和用户交互的交互式shell。 2、 文件类型的shell脚本</p> 
<h3><a id="15__99"></a>1.5 输入和输出</h3> 
<h4><a id="1__101"></a>1. 文件描述符</h4> 
<p>文件描述符(fledescriptor)通常是一个小的非负整数，内核用以标识一个特定进程正在访问的文件。当内核打开一个现有文件或创建一个新文件时，它都返回一个文件描述符。在读、写文件时，可以使用这个文件描述符。</p> 
<h4><a id="2__105"></a>2. 标准输入、标准输出、标准错误</h4> 
<p>每当运行一个新程序时，所有的shell都为其打开3个文件描述符，标准输入、输出、错误，默认情况下这三个文件描述符都会链接向终端，shell也提供了一种方法（重定向符”&gt;“），是这三个文件描述符重新定向到某个文件，当重定向的文件不存在时，shell会创建它。</p> 
<p>编写代码可实现文件的复制</p> 
<pre><code class="prism language-cpp"><span class="token punctuation">.</span><span class="token operator">/</span>a<span class="token punctuation">.</span>out <span class="token operator">&lt;</span> infile <span class="token operator">&gt;</span> outfile
</code></pre> 
<h4><a id="3_IO_115"></a>3. 不带缓冲的IO</h4> 
<p>函数open、read、write、lseek以及close提供了不带缓冲的IO</p> 
<h4><a id="4_IO_119"></a>4. 标准I/O</h4> 
<p>标准IO为那些不带缓冲的IO提供了一个带缓冲的接口，这样就无需选择最佳的缓冲区大小</p> 
<h3><a id="16__123"></a>1.6 程序和进程</h3> 
<h4><a id="1__125"></a>1. 程序</h4> 
<p>程序是一个存储在磁盘上某个目录中的可执行文件，内核使用exec函数将程序读入内存，并执行</p> 
<h4><a id="2_ID_129"></a>2. 进程和进程ID</h4> 
<p>程序的执行实例叫进程，进程ID唯一标识了每个进程</p> 
<h4><a id="3__133"></a>3. 进程控制</h4> 
<p>主要用到三个函数：fork、exec、waitpid</p> 
<h4><a id="4_ID_137"></a>4. 线程和线程ID</h4> 
<p>一个进程内的所有线程共享同一地址空间、文件描述符、栈、以及与进程相关的属性</p> 
<h3><a id="17__141"></a>1.7 出错处理</h3> 
<p>在&lt;errno.h&gt;中定义了errno以及可以赋予它的各种常量，这些常量都是以字符E开头的</p> 
<p>errno并不是简单的一个数据结构，也不是一个int类型的变量，而是一个宏，下面是其实现</p> 
<pre><code class="prism language-c"><span class="token keyword">extern</span> <span class="token keyword">int</span> <span class="token operator">*</span><span class="token function">__errno_location</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">errno</span> <span class="token expression"><span class="token punctuation">(</span><span class="token operator">*</span><span class="token function">__errno_location</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span></span></span>
</code></pre> 
<p>c标准提供了两个函数，用于打印出错消息</p> 
<ul><li>strerror函数将errnum（即errno）的值映射为一个出错的消息字符串，并返回该字符串的指针</li></ul> 
<pre><code class="prism language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;string.h&gt;</span></span>

<span class="token keyword">char</span> <span class="token operator">*</span><span class="token function">strerror</span><span class="token punctuation">(</span><span class="token keyword">int</span> errnum<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> 
<p>perror函数基于errno当前值，在标准错误上产生一条出错消息字符串，并返回此字符串的指针</p> 
<pre><code class="prism language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;stdio.h&gt;</span></span>

<span class="token keyword">void</span> <span class="token function">perror</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>msg<span class="token punctuation">)</span>
</code></pre> 
<p>**注意：**只有当一个库函数失败时，errno才会被设置。当函数成功运行时，errno的值不会被修改。这意味着我们不能通过测试errno的值来判断是否有错误存在。反之，只有当被调用的函数提示有错误发生时检查errno的值才有意义。</p> 
<h3><a id="18__172"></a>1.8 用户标识</h3> 
<p>用户ID、组ID、附属组ID</p> 
<h3><a id="19__176"></a>1.9 信号</h3> 
<p>信号用于通知进程发生了某种情况，常见的信号处理方式有以下三种</p> 
<ol><li>忽略信号</li><li>按系统默认方式处理</li><li>提供一个函数。即信号发生时，调用该函数，这个过程也叫做捕捉该信号</li></ol> 
<p>终端键盘提供了产生两种信号的方法：中断键（ctrl + c）和退出键（ctrl + \）</p> 
<p>另一种时调用kill产生信号，例如在一个进程中调用此函数就可以向另一个进程发送信号</p> 
<h3><a id="110__188"></a>1.10 时间值</h3> 
<p>历史上，共有两种时间：</p> 
<ol><li>日历时间 ：保存在time_t中</li><li>进程时间 ：保存在clock_t中</li></ol> 
<p>度量一个进程的执行时间，用三个时间值：</p> 
<ul><li>时钟时间 进程运行的时间总量</li><li>用户CPU时间 执行用户指令的时间</li><li>系统CPU时间 执行系统调用的时间</li></ul> 
<h3><a id="111__201"></a>1.11 系统调用和库函数</h3> 
<h2><a id="UNIX_205"></a>二、UNIX标准及实现</h2> 
<h3><a id="21_ISO_C_207"></a>2.1 ISO C</h3> 
<pre><code class="prism language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;assert.h&gt;</span>                         <span class="token comment">//验证程序断言</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;errno.h&gt;</span>						   <span class="token comment">//出错码</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;stdio.h&gt;</span>                          <span class="token comment">//标准I/O库</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;stdlib.h&gt;</span>                         <span class="token comment">//使用函数</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;string.h&gt;</span>						   <span class="token comment">//字符串操作</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;time.h&gt;</span>                           <span class="token comment">//时间和日期</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;wchar.h&gt;</span>                          <span class="token comment">//宽字符类型</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;dirent.h&gt;</span>                         <span class="token comment">//目录项</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;fcntl.h&gt;</span>                          <span class="token comment">//文件控制</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;netdb.h&gt;</span>						   <span class="token comment">//网络数据库操作</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;pthread.h&gt;</span> 					   <span class="token comment">//线程</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;unistd.h&gt;</span>						   <span class="token comment">//符号常量</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;arpa/inet.h&gt;</span>	                   <span class="token comment">//因特网定义</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;net/if.h&gt;</span> 						   <span class="token comment">//套接字本地接口</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;sys/select.h&gt;</span>					   <span class="token comment">//select函数</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;sys/socket.h&gt;</span>					   <span class="token comment">//套接字接口</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;sys/stat.h&gt;</span>					   <span class="token comment">//文件状态</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;sys/types.h&gt;</span>					   <span class="token comment">//基本系统数据类型</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;sys/un.h&gt;</span> 						   <span class="token comment">//UNIX域套接字定义</span></span>
</code></pre> 
<h3><a id="22_sysconfpathconffpathconf_231"></a>2.2 函数sysconf、pathconf、和fpathconf</h3> 
<pre><code class="prism language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;unistd.h&gt;</span></span>
<span class="token keyword">long</span> <span class="token function">sysconf</span><span class="token punctuation">(</span><span class="token keyword">int</span> name<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">long</span> <span class="token function">pathconf</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>pathname<span class="token punctuation">,</span> <span class="token keyword">int</span> name<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">long</span> <span class="token function">fpathconf</span><span class="token punctuation">(</span><span class="token keyword">int</span> fd<span class="token punctuation">,</span> <span class="token keyword">int</span> name<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> 
<p>这些函数用来修改一些系统配置，例如进程最大打开文件数、进程最大信号量等</p> 
<h3><a id="23_ISO_CIEEE_POSIX_242"></a>2.3 ISO C和IEEE POSIX</h3> 
<p>POSIX是一个最初由IEEE制定的标准族，指的是可以指操作系统接口（Portable Operating System Interface），该标准以UNIX为基础，但是并不限于UNIX类系统。</p> 
<h2><a id="IO_246"></a>三、文件I/O</h2> 
<h3><a id="31__248"></a>3.1 文件描述符</h3> 
<p>对于内核而言，所有打开的文件都用文件描述符引用。文件描述符是一个非负整数。</p> 
<p>按照习惯，UNIX系统shell把文件描述符0与进程的标准输入关联，文件描述符1与进程的标输出关联，文件描述符2与进程的标准错误关联，在哟应用程序中，我们应该将他们替换为STDIN_FILENO、STDOUT_FILENO、STDERR_FILENO以提高程序可读性。这些常量定义在&lt;unistd.h&gt;中，文件描述符，最多打开63个。</p> 
<h3><a id="32_openopenat_254"></a>3.2 函数open和openat</h3> 
<pre><code class="prism language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;fcntl.h&gt;</span></span>
<span class="token keyword">int</span> <span class="token function">open</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>path<span class="token punctuation">,</span> <span class="token keyword">int</span> oflag<span class="token punctuation">,</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span>
<span class="token keyword">int</span> <span class="token function">openat</span><span class="token punctuation">(</span><span class="token keyword">int</span> fd<span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>path<span class="token punctuation">,</span> <span class="token keyword">int</span> oflag<span class="token punctuation">,</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span>
													两个函数的返回值：若成功，返回文件描述符<span class="token punctuation">;</span>若出错，返回<span class="token operator">-</span><span class="token number">1</span>
</code></pre> 
<ul><li>path参数是要打开或创建文件的名字。</li><li>oflag参数可用来说明此函数的多个选项，该参数包括： 
  <ul><li>O_RDONLY 只读打开</li><li>O_WRONLY 只写打开</li><li>O_RDWR 读、写打开</li><li>O_EXEC 只执行打开</li><li>O_SEARCH 只搜索打开（应用于目录）</li><li>O_APPEND 写时追加到文件的尾端</li><li>O_CREAT 文件不存在时创建它，使用此选项还需要指定第三个参数mode，来指定其权限。</li><li>O_TRUNC 如果此文件存在，而且为只写或读-写成功打开，则其长度截断为0。</li><li>O_NOFOLLOW 若path引用的是一个符号链接，则出错</li></ul> </li><li>如果path指定绝对路径，则两个函数完全相同。</li></ul> 
<p>由open和openat函数返回的文件描述符一定是最小的未用的描述符，</p> 
<h3><a id="33_creat_278"></a>3.3 函数creat</h3> 
<pre><code class="prism language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;fcntl.h&gt;</span></span>
<span class="token keyword">int</span> <span class="token function">creat</span><span class="token punctuation">(</span><span class="token keyword">const</span> car <span class="token operator">*</span>path<span class="token punctuation">,</span> mode_t mode<span class="token punctuation">)</span>
</code></pre> 
<p>此函数可以被open函数完全替代，这里不作介绍。</p> 
<h3><a id="34_close_287"></a>3.4 函数close</h3> 
<pre><code class="prism language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;ubnnistd.h&gt;</span></span>
<span class="token keyword">int</span> <span class="token function">close</span><span class="token punctuation">(</span><span class="token keyword">int</span> fd<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> 
<p>当一个进程终止时，内核自动关闭它所有打开的文件，关闭文件时还会释放该进程加上去的所有记录锁。</p> 
<h3><a id="35_lseek_296"></a>3.5 函数lseek</h3> 
<p>每打开文件，内核都会维护一个与其相关联的“当前文件偏移量”，通常读、写操作都是从当前文件偏移量处开始，并使偏移量增加所读写的字节数。可以调用lseek显示地为一个文件设置偏移量。</p> 
<pre><code class="prism language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;unistd.h&gt;</span></span>
off_t <span class="token function">lseek</span><span class="token punctuation">(</span><span class="token keyword">int</span> fd<span class="token punctuation">,</span> off_t offset<span class="token punctuation">,</span> <span class="token keyword">int</span> whence<span class="token punctuation">)</span><span class="token punctuation">;</span>
			<span class="token comment">//返回值：若成功，返回新的文件偏移量，若出错，返回-1		</span>
</code></pre> 
<p>参数whence：</p> 
<ul><li>若whence是SEEK_SET,则将该文件的偏移量设置为据文件开始处offset个字节。</li><li>若whence是SEEK_CUR,则将该文件的偏移量设置为当前值加offset个字节，offset可正可负。</li><li>若whence是SEEK_END,则将该文件的偏移量设置为文件长度加offset个字节。</li></ul> 
<p>通常文件的当前偏移量应该是一个非负整数，但是某些设备也允许福德偏移量，因此，在比较lseek的返回值时应该谨慎，不要测试它是否小于0，而要测试是否等于-1。</p> 
<p>文件偏移量可以大于文件的当前长度，在这种情况下，对该文件的下一次写将加长该文件，并在文件中构成一个空洞，这一点是允许的，在文件中但没有被写过的字节都被读为0. 空洞并不要求在磁盘上占用存储区。</p> 
<h3><a id="36_readwrite_316"></a>3.6 函数read/write</h3> 
<pre><code class="prism language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;unistd.h&gt;</span></span>
<span class="token comment">/*不带缓冲的IO*/</span>
ssoze_t <span class="token function">read</span><span class="token punctuation">(</span><span class="token keyword">int</span> fd<span class="token punctuation">,</span> <span class="token keyword">void</span> <span class="token operator">*</span>buf<span class="token punctuation">,</span> size_t nbytes<span class="token punctuation">)</span><span class="token punctuation">;</span>
ssize_t <span class="token function">write</span><span class="token punctuation">(</span><span class="token keyword">int</span> fd<span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">void</span> <span class="token operator">*</span>buf<span class="token punctuation">,</span> size_t nbytes<span class="token punctuation">)</span><span class="token punctuation">;</span>	
			<span class="token comment">//返回值：读到的字节数，若以到文件尾，返回0；若出错，返回-1</span>
</code></pre> 
<h3><a id="37_IO_326"></a>3.7 I/O的效率</h3> 
<p>系统CPU时间的几个最小值差不多出现在BUFFSIZE为4096以后，继续增加缓冲区长度对长度几乎没有效应影响。</p> 
<h3><a id="38__330"></a>3.8 文件共享</h3> 
<p>内核使用三种数据结构表示打开的文件，</p> 
<ol><li>每个进程在进程表中都有一个记录项，记录项中包含一张打开的文件描述符表，可将其视为一个矢量，每个描述符占用一项。与每个文件描述符相关联的是：</li></ol> 
<p>​ a. 文件描述符标志（close_on_exec）</p> 
<p>​ b.指向一个文件表项的指针。</p> 
<ol start="2"><li>内核为所有打开的文件维持一张文件表，每个文件表包含：</li></ol> 
<p>​ a. 文件状态标志（读、写、添加、同步和非阻塞等）</p> 
<p>​ b.当前文件偏移量；</p> 
<p>​ c.指向该文件v结点表项的指针</p> 
<ol start="3"><li> <p>每个打开文件都有一个v节点结构。v节点包含了文件类型和对文件进行各种操作函数的指针。对于大多数文件，v节点还包含了该文件的i节点。<br> <img src="https://images2.imgbox.com/14/8c/uVFUZDNN_o.png" alt="在这里插入图片描述"></p> </li><li> <p>对于多个打开的文件</p> 
  <ul><li> <p>在每次完成write操作后，当前表项的中当前文件的文件偏移量即增加的字节数，如果超出了当前文件长度，则i节点中的当前文件长度也会同步更新。</p> </li><li> <p>lseek函数只修改文件表项中的当前文件偏移量，不进行任何I/O操作</p> </li></ul> </li></ol> 
<h3><a id="39__356"></a>3.9 原子操作</h3> 
<p>当多个进程同时写一个文件时，逻辑操作“先定位到文件尾端，然后写”的逻辑操作会使后一个写的覆盖掉前一个写的内容，解决问题的方法就是将<code>定位到文件尾端+写操作</code> 对于其他进程来说为一个<strong>原子操作</strong>。在打开文件时设置O_APPEND标志，在每次写时，内核都会先将当前文件偏移量设置到该文件的尾端，这样就不用调用lseek函数了。</p> 
<ul><li><strong>函数pread和pwrite</strong></li></ul> 
<pre><code class="prism language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;unistd.h&gt;</span></span>
ssize_t <span class="token function">pread</span><span class="token punctuation">(</span><span class="token keyword">int</span> fd<span class="token punctuation">,</span> <span class="token keyword">void</span> <span class="token operator">*</span>buf<span class="token punctuation">,</span> size_t nbytes<span class="token punctuation">,</span> off_t offset<span class="token punctuation">)</span><span class="token punctuation">;</span>
											返回值：读到的字节数，若已到文件尾，返回<span class="token number">0</span>；若出错，返回<span class="token operator">-</span><span class="token number">1</span>
ssize_t <span class="token function">pwrite</span><span class="token punctuation">(</span><span class="token keyword">int</span> fd<span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">void</span> <span class="token operator">*</span>buf<span class="token punctuation">,</span> size_t nbytes<span class="token punctuation">,</span> off_t offset<span class="token punctuation">)</span><span class="token punctuation">;</span>
返回值：若成功，返回已写的字节数；若出错，返回<span class="token operator">-</span><span class="token number">1</span>
</code></pre> 
<p>针对这两个函数，需要注意的是：</p> 
<ul><li>调用pread时，无法中断其定位和读操作</li><li>不更新当前文件偏移量。（read/write函数都会更改当前文件偏移量）</li><li>pwrite也有类似的区别</li></ul> 
<h3><a id="310_dupdup2_375"></a>3.10 函数dup和dup2</h3> 
<pre><code class="prism language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;unistd.h&gt;</span></span>
<span class="token keyword">int</span> <span class="token function">dup</span><span class="token punctuation">(</span><span class="token keyword">int</span> fd<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">int</span> <span class="token function">dup2</span><span class="token punctuation">(</span><span class="token keyword">int</span> fd<span class="token punctuation">,</span> <span class="token keyword">int</span> fd2<span class="token punctuation">)</span><span class="token punctuation">;</span>   
			<span class="token comment">//两个函数的返回值：若成功，返回新的文件描述符；若出错，返回-1</span>
</code></pre> 
<p>​ dup和dup2函数都用来复制一个指定的文件描述符，dup2函数可以指定返回的文件描述符fd2，如果fd2已经打开，则要想将其关闭。复制文件描述符的另一种方法是使用fcntl函数，这个将在后面介绍。</p> 
<h3><a id="311_syncfsyncfdatasync_386"></a>3.11 函数sync、fsync和fdatasync</h3> 
<p>传统的UNIX系统实现在内核中设有缓冲区高速缓存或页高速缓存，大多数磁盘I/O都通过缓冲区进行。当我们像文件写入数据时，通常都先写入高速缓存（为了效率），然后再排队，晚些再写入磁盘。这种方式称为延迟写。</p> 
<p>内核需要重用缓存区时，他会把所有延迟写 数据块写入磁盘。为了保证磁盘实际数据和缓存区的内容一致性，UNIX系统提供了sync、fsync和fdatasync三个函数</p> 
<pre><code class="prism language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;unistd.h&gt;</span></span>
<span class="token keyword">int</span> <span class="token function">fsync</span><span class="token punctuation">(</span><span class="token keyword">int</span> fd<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">int</span> <span class="token function">fdatasync</span><span class="token punctuation">(</span><span class="token keyword">int</span> fd<span class="token punctuation">)</span><span class="token punctuation">;</span>
																返回值：若成功，返回<span class="token number">0</span>；若失败，返回<span class="token operator">-</span><span class="token number">1</span>
<span class="token keyword">void</span> <span class="token function">sync</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span>
</code></pre> 
<p>sync只是将所有修改过的块缓冲区排入写队列，然后就返回，并不等待实际写磁盘结束。</p> 
<p>通常，称为update的守护进程周期性的调用sync函数，这就保证了可以定时冲洗内核的块缓冲区。</p> 
<p>fsync函数只对文件描述符fd指定的一个文件起作用，并等待写磁盘结束才返回，比如数据库操作需要调用此函数。</p> 
<h3><a id="312_fcntl_406"></a>3.12 函数fcntl</h3> 
<p>fcntl函数可以改变已经打开文件的属性</p> 
<pre><code class="prism language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;fcntl.h&gt;</span></span>

<span class="token keyword">int</span> <span class="token function">fcntl</span><span class="token punctuation">(</span><span class="token keyword">int</span> fd<span class="token punctuation">,</span> <span class="token keyword">int</span> cmd<span class="token punctuation">,</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token comment">/*int arg*/</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		      <span class="token comment">//返回值：若成功，则依赖于cmd；若出错，返回-1</span>
</code></pre> 
<p>fcntl的返回值与命令有关。如果出错，所有命令有返回-1，成功则返回值其他值。</p> 
<h3><a id="313_ioctl_419"></a>3.13 函数ioctl</h3> 
<p>ioctl函数是I/O操作的杂物箱。</p> 
<pre><code class="prism language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;unistd.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;sys/ioctl.h&gt;</span></span>

<span class="token keyword">int</span> <span class="token function">ioctl</span><span class="token punctuation">(</span><span class="token keyword">int</span> fd<span class="token punctuation">,</span> <span class="token keyword">int</span> request<span class="token punctuation">,</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
						<span class="token comment">//返回值：若出错，返回-1；若成功，返回其他值</span>
</code></pre> 
<h3><a id="314_devfd_431"></a>3.14 /dev/fd</h3> 
<p>系统都会提供/dev/fd的目录，打开文件dev/fd/n等效于复制文件描述符n</p> 
<p>例如<code>fd = open("dev/fd/0"</code>,等效于<code>fd = dup(0)</code>;值得注意的是/dev/fd在linux中是指向底层物理文件的，操作不当可能会造成底层截断。</p> 
<p>例如，命令<code>filter file2 | cat file1 - file3 | lpr</code>与<code>filter file2 | cat file1 /deb/fd/0 file3 | lpr</code>相比，缺少了文件名参数的一致性。</p> 
<p>该命令的解释：<code>cat读file1，接着读其标准输入（也就是filter file2命令的输出），然后读file3文件</code></p> 
<h2><a id="_441"></a>四、文件和目录</h2> 
<h3><a id="41_statfstatfstatatlstat_443"></a>4.1 函数stat、fstat、fstatat和lstat</h3> 
<pre><code class="prism language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;sys/stat.h&gt;</span></span>

<span class="token keyword">int</span> <span class="token function">stat</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>restrict pathname<span class="token punctuation">,</span> <span class="token keyword">struct</span> <span class="token class-name">stat</span> <span class="token operator">*</span>restrict buf<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">int</span> <span class="token function">fstat</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">,</span> <span class="token keyword">struct</span> <span class="token class-name">stat</span> <span class="token operator">*</span>buf<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">int</span> <span class="token function">lstat</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>restrict pathname<span class="token punctuation">,</span> <span class="token keyword">struct</span> <span class="token class-name">stat</span> <span class="token operator">*</span>restrict buf<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">int</span> <span class="token function">fstat</span><span class="token punctuation">(</span><span class="token keyword">int</span> fd<span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>restrict pathname<span class="token punctuation">,</span> <span class="token keyword">struct</span> <span class="token class-name">sat</span> <span class="token operator">*</span>restrict buf<span class="token punctuation">,</span> <span class="token keyword">int</span> flag<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> 
<h3><a id="42__454"></a>4.2 文件类型</h3> 
<p>文件类型包括以下几种：</p> 
<ol><li>普通文件</li><li>目录文件</li><li>块特殊文件</li><li>字符特殊文件</li><li>FIFO</li><li>套接字</li><li>符号链接</li></ol> 
<h3><a id="43_IDID_466"></a>4.3 设置用户ID和设置组ID</h3> 
<h3><a id="44__468"></a>4.4 新文件和目录的所有权</h3> 
<p>新文件的用户ID设置为进程的有效用户ID。关于组ID，用户可以选择：1. 新文件的组ID可以是进程的有效组ID.2.新文件的组ID可以是他所在的目录的组ID。</p> 
<h3><a id="47_accessfaccessat_472"></a>4.7 函数access和faccessat</h3> 
<pre><code class="prism language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;unistd.h&gt;</span></span>

<span class="token keyword">int</span> <span class="token function">access</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>pathname<span class="token punctuation">,</span> <span class="token keyword">int</span> mode<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">int</span> <span class="token function">faccessat</span><span class="token punctuation">(</span><span class="token keyword">int</span> fd<span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>pathname<span class="token punctuation">,</span> <span class="token keyword">int</span> mode<span class="token punctuation">,</span> <span class="token keyword">int</span> flag<span class="token punctuation">)</span><span class="token punctuation">;</span>
				<span class="token comment">//两个函数返回值：若成功，返回0；若出错，返回-1</span>
</code></pre> 
<h3><a id="48_umask_482"></a>4.8 函数umask</h3> 
<pre><code class="prism language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;sys/stat.h&gt;</span> </span>

mode_t <span class="token function">umask</span><span class="token punctuation">(</span>mode_t cmask<span class="token punctuation">)</span><span class="token punctuation">;</span>
							<span class="token comment">//返回值：之前的文件模式创建屏蔽字</span>
</code></pre> 
<p><img src="https://images2.imgbox.com/12/02/yKxRutHK_o.png" alt="在这里插入图片描述"></p> 
<p>参数cmask是由图4-6中列出的9个常量中的若干位按照“或”构成的</p> 
<p>在进程创建一个新文件或新目录时，就一定会使用文件模式创建屏蔽字，</p> 
<p>下面程序创建两个文件，创建第一个时，umask为0.创建第二个时，umask值禁止所有组合和其他用户的访问权限。</p> 
<pre><code class="prism language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;unistd.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;stdio.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;fcntl.h&gt;</span></span>

<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">RWRWRW</span> <span class="token expression"><span class="token punctuation">(</span>S_IRUSR<span class="token operator">|</span>S_IWUSR<span class="token operator">|</span>S_IWGRP<span class="token operator">|</span>S_IRGRP<span class="token operator">|</span>S_IROTH<span class="token operator">|</span>S_IWOTH<span class="token punctuation">)</span></span></span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
    <span class="token function">umask</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token function">creat</span><span class="token punctuation">(</span><span class="token string">"foo"</span><span class="token punctuation">,</span>RWRWRW<span class="token punctuation">)</span> <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span>
        <span class="token function">err_sys</span><span class="token punctuation">(</span><span class="token string">"creat error for foo"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">uamsk</span><span class="token punctuation">(</span>S_IWGRP<span class="token operator">|</span>S_IRGRP<span class="token operator">|</span>S_IROTH<span class="token operator">|</span>S_IWOTH<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token function">creat</span><span class="token punctuation">(</span><span class="token string">"bar"</span><span class="token punctuation">,</span>RWRWRW<span class="token punctuation">)</span> <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span>
        <span class="token function">err_sys</span><span class="token punctuation">(</span><span class="token string">"creat error for bar"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">exit</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<h3><a id="49_chmodfchmodfchmodat_517"></a>4.9 函数chmod、fchmod和fchmodat</h3> 
<p>这三个函数是我们可以更改现有文件的访问权限</p> 
<pre><code class="prism language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;sys/stat.h&gt;</span></span>

<span class="token keyword">int</span> <span class="token function">chmod</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>pathname<span class="token punctuation">,</span> mode_t mode<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">int</span> <span class="token function">fchmod</span><span class="token punctuation">(</span><span class="token keyword">int</span> fd<span class="token punctuation">,</span> mode_t mode<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">int</span> <span class="token function">fchmodat</span><span class="token punctuation">(</span><span class="token keyword">int</span> fd<span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>pathname<span class="token punctuation">,</span> mode_t mode<span class="token punctuation">,</span> <span class="token keyword">int</span> flag<span class="token punctuation">)</span><span class="token punctuation">;</span>
							<span class="token comment">//	成功返回0；出错，返回-1</span>
</code></pre> 
<p>chmod函数在指定文件上进行操作，而fchmod函数则是对已经打开的文件进行操作。</p> 
<h3><a id="410_chownfchownfchownatlchown_532"></a>4.10 函数chown、fchown、fchownat和lchown</h3> 
<p>下面这几个chown函数可用于更改文件的用户ID和组ID。</p> 
<pre><code class="prism language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;unistd.h&gt;</span></span>
<span class="token keyword">int</span> <span class="token function">chown</span> <span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>pathname<span class="token punctuation">,</span> uid_t owner<span class="token punctuation">,</span> gid_t group<span class="token punctuation">)</span> <span class="token punctuation">;</span>
<span class="token keyword">int</span> <span class="token function">fchown</span><span class="token punctuation">(</span><span class="token keyword">int</span> fd<span class="token punctuation">,</span> uid_t owner<span class="token punctuation">,</span> gid_t group<span class="token punctuation">)</span> <span class="token punctuation">;</span>
<span class="token keyword">int</span> <span class="token function">fchownat</span><span class="token punctuation">(</span><span class="token keyword">int</span> fd<span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>pathname<span class="token punctuation">,</span> uid_t owner<span class="token punctuation">,</span> gid_t group<span class="token punctuation">,</span> <span class="token keyword">int</span> flag<span class="token punctuation">)</span> <span class="token punctuation">;</span>
<span class="token keyword">int</span> <span class="token function">lchown</span> <span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>pathname<span class="token punctuation">,</span> uid_t owner<span class="token punctuation">,</span> gid_t group<span class="token punctuation">)</span> <span class="token punctuation">;</span>
			<span class="token comment">//4个函数的返回值：成功，返回0；失败，返回-1</span>
</code></pre> 
<h3><a id="411__545"></a>4.11 文件长度</h3> 
<p>stat结构成员st_size表示亿字节为单位的文件长度。此字段只对普通文件、目录文件和符号链接有意义。</p> 
<ul><li>对于普通文件，得到的是文件的实际长度</li><li>对于目录文件，得到的是一个数（16或者512）的整数倍.</li><li>对于符号链接，文件长度是文件名中的实际字节数</li></ul> 
<p>当文件中存在空洞时，实际长度可能和<code>ls -l</code>所得到的不相同，这是正常现象，当复制一个文件时，所有的空洞都会按实际字节被填充为0</p> 
<h3><a id="412__555"></a>4.12 文件截断</h3> 
<p>有时我们需要在文件尾端出截取一些数据以缩短数据。将一个文件的长度截断为0是一个特例，再打开文件使用O_TRUNC标志可以做到这一点，为了截断文件可以调用函数truncate和ftruncate。</p> 
<pre><code class="prism language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;unistd.h&gt;</span></span>

<span class="token keyword">int</span> <span class="token function">truncate</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>pathname<span class="token punctuation">,</span> off_t length<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">int</span> <span class="token function">ftruncate</span><span class="token punctuation">(</span><span class="token keyword">int</span> fd<span class="token punctuation">,</span> off_t length<span class="token punctuation">)</span><span class="token punctuation">;</span>
				<span class="token comment">//两个函数返回值：若成功，返回0；若出错，返回-1</span>
</code></pre> 
<h3><a id="413__567"></a>4.13 文件系统</h3> 
<p>磁盘、分区和文件系统</p> 
<p>[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-uNmKp1dS-1668346492367)(D:\file\课程\md\image-20221106172800189.png)]</p> 
<p>如果更仔细的观察一个柱面组的i节点和数据块部分，则可以看出如下图所示情况。</p> 
<p><img src="https://images2.imgbox.com/a6/e5/Pqs2N4Z9_o.png" alt="在这里插入图片描述"></p> 
<ul><li>在图中有两个目录项指向同一个i节点。每个i节点都有一个链接计数，其值时指向该i节点的目录项数。只有当链接计数减至0时，才可以删除文件。这也是为什么删除一个目录项的函数称之为unlink的而不是delete的原因，该链接称为硬链接。</li><li>另外一种链接类型称为符号链接。任何一个叶目录的链接计数总是2，数值2来源于命名该目录的目录项<code>..</code>以及在该目录中的<code>.</code>项。如果文件有一个子目录，则数值应该为3，另一个为其子目录中的<code>..</code>。注意，每个子目录又会使父目录的引用计数增加1。</li></ul> 
<h3><a id="414_linklinkatunlinkunlinkatremove_579"></a>4.14 函数link、linkat、unlink、unlinkat和remove</h3> 
<pre><code class="prism language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;unistd.h&gt;</span></span>
<span class="token keyword">int</span> <span class="token function">link</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>existingpath<span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>newpath<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">int</span> <span class="token function">linkat</span><span class="token punctuation">(</span><span class="token keyword">int</span> efd<span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>existingpath<span class="token punctuation">,</span> <span class="token keyword">int</span> nfd<span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>newpath<span class="token punctuation">,</span> <span class="token keyword">int</span> flag<span class="token punctuation">)</span><span class="token punctuation">;</span>
				<span class="token comment">//两个函数的返回值：若成功，返回0；若出错，返回-1</span>
</code></pre> 
<p>这两个函数都用来创建一个新目录想newpath，他引用现有文件existingpath。</p> 
<p>为了删除一个现有的目录项，可以调用unlink函数</p> 
<pre><code class="prism language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;unistd.h&gt;</span></span>
<span class="token keyword">int</span> <span class="token function">link</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>pathname<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">int</span> <span class="token function">linkat</span><span class="token punctuation">(</span><span class="token keyword">int</span> efd<span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>pathname<span class="token punctuation">,</span> <span class="token keyword">int</span> flag<span class="token punctuation">)</span><span class="token punctuation">;</span>
			<span class="token comment">//两个函数的返回值：若成功，返回0；若出错，返回-1</span>
</code></pre> 
<p>unlink的这种特性经常被程序用来确保即使在程序崩溃时，她所创建的临时文件也不会遗留下来。进程用open或creat创建一个文件，然后立即调用unlink，引文该文件仍然是打开的，所以不会将其删除，只有当进程终止时（内核会关闭打开的所有文件描述符），该文件才会删除。</p> 
<pre><code class="prism language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;stdio.h&gt;</span></span>

<span class="token keyword">int</span> <span class="token function">remove</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>pathname<span class="token punctuation">)</span><span class="token punctuation">;</span>
							<span class="token comment">//返回值：若成功，返回0；出错，返回-1</span>
</code></pre> 
<h3><a id="415_renamerenameat_607"></a>4.15 函数rename和renameat</h3> 
<p>文件或者目录可以用rename函数或者renameat函数重命名</p> 
<pre><code class="prism language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;stdio.h&gt;</span></span>
<span class="token keyword">int</span> <span class="token function">rename</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>pathname<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">int</span> <span class="token function">renameat</span><span class="token punctuation">(</span><span class="token keyword">int</span> oldfd<span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>oldname<span class="token punctuation">,</span> <span class="token keyword">int</span> newflag，<span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>newname<span class="token punctuation">)</span><span class="token punctuation">;</span>
					<span class="token comment">//两个函数的返回值：若成功，返回0；若出错，返回-1</span>
</code></pre> 
<h3><a id="416__618"></a>4.16 符号链接</h3> 
<h3><a id="417__620"></a>4.17 创建和读取符号链接</h3> 
<h3><a id="418__622"></a>4.18 文件时间</h3> 
<h3><a id="419_futimensutimensatutimes_624"></a>4.19 函数futimens、utimensat和utimes</h3> 
<h3><a id="420_mkdirmkdiratrmdir_626"></a>4.20 函数mkdir、mkdirat和rmdir</h3> 
<p>用mkdir和mkdirat函数创建目录，用rmdir函数删除目录</p> 
<pre><code class="prism language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;sys/stat.h&gt;</span></span>
<span class="token keyword">int</span> <span class="token function">mkdir</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>pathname<span class="token punctuation">,</span> mode_t mode<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">int</span> <span class="token function">mkdirat</span><span class="token punctuation">(</span><span class="token keyword">int</span> fd<span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>pathname<span class="token punctuation">,</span> mode_t mode<span class="token punctuation">)</span><span class="token punctuation">;</span>
					<span class="token comment">//	两个函数的返回值：若成功，返回0；若出错，返回-1</span>
</code></pre> 
<p>两个函数创建一个新的空目录。其中<code>.</code>和 <code>..</code>自动创建。访问权限由mode指定，对于牡蛎，通常至少要设置一个执行权限位，以允许访问该目录中的文件。</p> 
<pre><code class="prism language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;unistd.h&gt;</span></span>
<span class="token keyword">int</span> <span class="token function">rmdir</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>pathname<span class="token punctuation">)</span><span class="token punctuation">;</span>
						<span class="token comment">//函数的返回值：若成功，返回0；若出错，返回-1</span>
</code></pre> 
<h3><a id="421__645"></a>4.21 读目录</h3> 
<h3><a id="422_chdirfchdirgetcwd_647"></a>4.22 函数chdir、fchdir、getcwd</h3> 
<h3><a id="423__649"></a>4.23 设备特殊文件</h3> 
<p>st_dev和st__rdev这两个字段经常引起混淆。</p> 
<h2><a id="IO_653"></a>五、标准I/O库</h2> 
<h3><a id="51_FILE_655"></a>5.1 流和FILE对象</h3> 
<p>在第三章，所有I/O函数都围绕文件描述符的，而对于标准I/O库，他们操作都是围绕<strong>流</strong>进行的，当标准I/O库打开或创建一个文件时，我们已使一个流与一个文件相关联。</p> 
<p>我们称指向FILE对象的指针（FILE *）为文件指针。</p> 
<p>这里有必要科普一下<strong>流和文件描述符</strong>的区别：</p> 
<ul><li> <p>任何操作系统，在程序访问（读写）时，都需要建立程序与文件之间的通道，这一过程称之为打开文件。UNIX提供了两种机制，分别为：（1）文件描述符。（2）流。</p> </li><li> <p>两者的相同点：</p> 
  <ul><li>都是作为程序与文件之间的通道。</li><li>都包含了一大类的I/O库函数</li></ul> </li><li> <p>两者不同点：</p> 
  <ul><li>文件描述符使用int类型的变量来表示打开的文件，而流使用FILE*文件指针来进行标识</li><li>如果需要对特定设备进行控制操作，必须使用文件描述符。</li><li>如果需要使用特殊的方式进行I/O操作（例如非阻塞等），必须使用文件描述符的方式。</li><li>在执行实际的输入输出时，流提供操作接口更加灵活、强大。</li><li>文件描述符只提供简答的穿过送字符块的函数，而流函数提供格式化I/O，字符I/O，面向行的I/O的大量函数。</li><li>流函数更利于程序的移植，任何基于ANSI C的系统都支持流。</li></ul> </li><li> <p>两者的关系：</p> <p>流为用户提供了一些更高一级的I/O接口，它处在文件描述符的上层，也就是说流是通过文件描述符来实现的。</p> </li></ul> 
<h3><a id="52__683"></a>5.2 标准输入、标准输出和标准错误</h3> 
<p>对一个进程预定义了3个流，并且这3个流可以自动被进程使用。这3个标准I/O流通过预定义文件指针stdin、stdout和stderr加以引用，这三个文件指针定义在头文件&lt;stdio.h&gt;中。</p> 
<h3><a id="53__687"></a>5.3 缓冲</h3> 
<p>标准I/O库提供缓冲的目的是尽可能减少使用read和write调用的次数。他也对每个I/O流自动地进行缓冲管理，从而避免不必要的麻烦。遗憾的是，标准I/O库最令人迷惑的也是他的缓冲。</p> 
<p>标准I/O提供了以下3种类型的缓冲。</p> 
<ul><li>全缓冲。在填满标准I/O缓冲区后才进行实际I/O操作。对于驻留在磁盘上的文件通常是由I/O库实施全缓冲的。术语<strong>冲洗</strong>说明标准I/O缓冲区的写操作，缓冲区也可由标准i/o例程子自动冲洗，或者可以调用函数fflush冲洗一个流。</li><li>行缓冲。这种情况下，当输入和输出中遇到换行符时，才会执行I/O操作。这允许我们一次输入一个字符（啊函数fputc），但只有在写了一行之后，才会进行实际的I/O操作。</li><li>不带缓冲。标准I/O库不对字符进行缓冲存储。</li></ul> 
<h3><a id="54__697"></a>5.4 打开流</h3> 
<pre><code class="prism language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;stdio.h&gt;</span></span>
FILE <span class="token operator">*</span><span class="token function">fopen</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>restrict pathname<span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>restrict type<span class="token punctuation">)</span><span class="token punctuation">;</span>
FILE <span class="token operator">*</span><span class="token function">freopen</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>restrict pathname<span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>restrict type<span class="token punctuation">,</span> FILE <span class="token operator">*</span>restrict fp<span class="token punctuation">)</span><span class="token punctuation">;</span>
FILE <span class="token operator">*</span><span class="token function">fdopen</span><span class="token punctuation">(</span>in<span class="token comment">//三个函数的返回值：若成功，则返回0；若出错，则返回-1</span>
</code></pre> 
<p>调用fclose函数关闭流</p> 
<pre><code class="prism language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;stdio.h&gt;</span></span>

<span class="token keyword">int</span> <span class="token function">fclose</span><span class="token punctuation">(</span>FILE <span class="token operator">*</span>fp<span class="token punctuation">)</span><span class="token punctuation">;</span>
					<span class="token comment">//返回值：若成功，则返回0；若出错，则返回-1</span>
</code></pre> 
<p>再关闭文件之前，冲洗缓冲中的输出数据。缓冲区中的任何输入数据则被丢弃。如果标准I/O库以为该流自动分配了一个缓冲区，则释放此缓冲区。当一个程序正常终止时，所有的流都会被正确关闭。</p> 
<h3><a id="55__717"></a>5.5 读和写流</h3> 
<ol><li>输入函数</li></ol> 
<pre><code class="prism language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;stdio.h&gt;</span></span>
<span class="token keyword">int</span> <span class="token function">getc</span><span class="token punctuation">(</span>FILE <span class="token operator">*</span>fp<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">int</span> <span class="token function">fgetc</span><span class="token punctuation">(</span>FILE <span class="token operator">*</span>fp<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">int</span> <span class="token function">getchar</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
								<span class="token comment">//若成功，返回c；若出错，返回EOF</span>
</code></pre> 
<ol start="2"><li>输出函数</li></ol> 
<pre><code class="prism language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;stdio.h&gt;</span></span>
<span class="token keyword">int</span> <span class="token function">putc</span><span class="token punctuation">(</span><span class="token keyword">int</span> c<span class="token punctuation">,</span> FILE <span class="token operator">*</span>fp<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">int</span> <span class="token function">fputc</span><span class="token punctuation">(</span><span class="token keyword">int</span> c<span class="token punctuation">,</span> FILE <span class="token operator">*</span>fp<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">int</span> <span class="token function">putchar</span><span class="token punctuation">(</span><span class="token keyword">int</span> c<span class="token punctuation">)</span><span class="token punctuation">;</span>
					       	<span class="token comment">//若成功，返回c；若出错，返回EOF</span>
</code></pre> 
<h3><a id="56_IO_739"></a>5.6 每次一行I/O</h3> 
<pre><code class="prism language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;stdio.h&gt;</span></span>
<span class="token keyword">char</span> <span class="token operator">*</span><span class="token function">fgets</span><span class="token punctuation">(</span><span class="token keyword">char</span> <span class="token operator">*</span>restrict buf<span class="token punctuation">,</span> <span class="token keyword">int</span> n<span class="token punctuation">,</span> FILE <span class="token operator">*</span>restrict fp<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">char</span> <span class="token operator">*</span><span class="token function">gets</span><span class="token punctuation">(</span><span class="token keyword">char</span> <span class="token operator">*</span>buf<span class="token punctuation">)</span><span class="token punctuation">;</span>
		    <span class="token comment">//若成功，返回buf;若已到达文件尾端或者出错，返回NULL</span>
</code></pre> 
<p>gets函数从标准输入读，而fgets函数从指定的流读。gets有些不安全，是不建议使用的</p> 
<pre><code class="prism language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;stdio.h&gt;</span></span>
<span class="token keyword">int</span> <span class="token operator">*</span><span class="token function">fputs</span><span class="token punctuation">(</span><span class="token keyword">char</span> <span class="token operator">*</span>restrict str<span class="token punctuation">,</span> FILE <span class="token operator">*</span>restrict fp<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">int</span> <span class="token operator">*</span><span class="token function">puts</span><span class="token punctuation">(</span><span class="token keyword">char</span> <span class="token operator">*</span>str<span class="token punctuation">)</span><span class="token punctuation">;</span>
				<span class="token comment">//若成功，返回buf;若已到达文件尾端或者出错，返回NULL</span>
</code></pre> 
<h3><a id="57_IO_757"></a>5.7 二进制I/O</h3> 
<p>5.6和5.7节中的函数，因为各自的特点均不适合读写二进制I/O函数，因此特地提供以下两个函数进行二进制I/O</p> 
<pre><code class="prism language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;stdio.h&gt;</span></span>

size_t <span class="token function">fread</span><span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token operator">*</span>restrict ptr<span class="token punctuation">,</span> size_t size<span class="token punctuation">,</span> size_t nobj<span class="token punctuation">,</span> FILE <span class="token operator">*</span>restrict fp<span class="token punctuation">)</span><span class="token punctuation">;</span>
size_t <span class="token function">fwrite</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">void</span> <span class="token operator">*</span>restrict ptr<span class="token punctuation">,</span> size_t size<span class="token punctuation">,</span> size_t nobj<span class="token punctuation">,</span> FILE <span class="token operator">*</span>restrict fp<span class="token punctuation">)</span><span class="token punctuation">;</span>
							           <span class="token comment">//返回值：读写的对象数</span>
</code></pre> 
<p>此函数常见的两种用法。</p> 
<ol><li>读或者写一个二进制数组。下面例程将数组中2~5个元素写至一文件中。</li></ol> 
<pre><code class="prism language-cpp"><span class="token keyword">float</span> data<span class="token punctuation">[</span><span class="token number">10</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token keyword">if</span><span class="token punctuation">(</span><span class="token function">fwrite</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>data<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">float</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> fp<span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token number">4</span><span class="token punctuation">)</span>
	<span class="token function">perror</span><span class="token punctuation">(</span><span class="token string">"fwrite error"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> 
<ol start="2"><li>读写一个结构。</li></ol> 
<pre><code class="prism language-cpp"><span class="token keyword">struct</span> <span class="token punctuation">{<!-- --></span>
	<span class="token keyword">short</span> count<span class="token punctuation">;</span>
	<span class="token keyword">long</span> total<span class="token punctuation">;</span>
	<span class="token keyword">char</span> name<span class="token punctuation">[</span>NAMESIZE<span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>item<span class="token punctuation">;</span>
<span class="token keyword">if</span><span class="token punctuation">(</span><span class="token function">fwrite</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>item<span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>item<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> fp<span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token number">1</span><span class="token punctuation">)</span>
    <span class="token function">perror</span><span class="token punctuation">(</span><span class="token string">"fwrite error"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> 
<p>使用二进制I/O的基本问题是，它只能用于都在同一系统上已写的数据。具体表现为，在一个系统上写的数据，在另一个系统上进行处理，此时会出问题，不能正常工作，其原因包括：</p> 
<ol><li>在一个结构中，同一个成员的偏移量可以随编译程序和系统的不同而不同（由于不同的对要求）</li><li>用来存储多字节整数和浮点值的二进制格式在不同的系统结构间也可能不同。</li></ol> 
<h3><a id="58__796"></a>5.8 定位流</h3> 
<h3><a id="59_IO_798"></a>5.9 格式化I/O</h3> 
<ol><li><strong>格式化输出</strong></li></ol> 
<p>格式化输出由5个printf函数来处理的。</p> 
<pre><code class="prism language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;stdio.h&gt;</span></span>

<span class="token keyword">int</span> <span class="token function">printf</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>restrict format<span class="token punctuation">,</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">int</span> <span class="token function">fprintf</span><span class="token punctuation">(</span>FILE <span class="token operator">*</span>restrict fd<span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>restrict format<span class="token punctuation">,</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">int</span> <span class="token function">dprintf</span><span class="token punctuation">(</span><span class="token keyword">int</span> fd<span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>restrict format<span class="token punctuation">,</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
									<span class="token comment">//3个函数的返回值：成功，返回输出字符数，若输出错误，返回负值</span>
<span class="token keyword">int</span> <span class="token function">sprintf</span><span class="token punctuation">(</span><span class="token keyword">char</span> <span class="token operator">*</span>restrict buf<span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>restrict format<span class="token punctuation">,</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
								   <span class="token comment">//返回值：成功，返回存入数组的字符数，若编码错误，返回负值</span>
<span class="token keyword">int</span> <span class="token function">snprintf</span><span class="token punctuation">(</span><span class="token keyword">char</span> <span class="token operator">*</span>restrict buf<span class="token punctuation">,</span> size_t n<span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>restrict format<span class="token punctuation">,</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
								   <span class="token comment">//返回值：若缓冲区足够大，返回将要存入数组的字符数，若编码错误，返回负值</span>
</code></pre> 
<p>printf函数将格式化数据写到标准输出，fprintf写至指定的流，dprintf写至指定的文件描述符，sprintf将格式化的数据写入数组，同时在该数组的尾端自动加一个null字节，但该字符不包括到返回值中。snprintf函数显式的提供了缓冲区的长度，以防止缓冲区溢出的隐患，但是此函数不会再数组最后加NULL字节。</p> 
<p>格式说明控制其余参数如何编写，以后如何显示，转换说明是以<code>%</code>开始的。一个转换说明有4个可选择的部分。具体说明和示例见来链接：<a href="https://blog.csdn.net/weixin_44567318/article/details/115441167">https://blog.csdn.net/weixin_44567318/article/details/115441167</a>。</p> 
<ol start="2"><li>格式化输入</li></ol> 
<pre><code class="prism language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;stdio.h&gt;</span></span>

<span class="token keyword">int</span> <span class="token function">scanf</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>restrict format<span class="token punctuation">,</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">int</span> <span class="token function">fscanf</span><span class="token punctuation">(</span>FILE <span class="token operator">*</span>restrict fp<span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>restrict format<span class="token punctuation">,</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">int</span> <span class="token function">sscanf</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>restrict buf<span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">char</span>  <span class="token operator">*</span>restrict format<span class="token punctuation">,</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> 
<h3><a id="510__831"></a>5.10 实现细节</h3> 
<pre><code class="prism language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;stdio.h&gt;</span></span>

<span class="token keyword">int</span> <span class="token function">fileno</span><span class="token punctuation">(</span>FILE <span class="token operator">*</span>fp<span class="token punctuation">)</span><span class="token punctuation">;</span>
										<span class="token comment">//返回值：与文件相关联的文件描述符</span>
</code></pre> 
<h3><a id="511__840"></a>5.11 临时文件</h3> 
<h3><a id="512__842"></a>5.12 内存流</h3> 
<h3><a id="513_IO_844"></a>5.13 标准I/O的替代软件</h3> 
<h2><a id="_846"></a>六、系统数据文件和信息</h2> 
<h3><a id="61__848"></a>6.1 口令文件</h3> 
<h3><a id="62__850"></a>6.2 阴影文件</h3> 
<h3><a id="63__852"></a>6.3 组文件</h3> 
<h3><a id="64_ID_854"></a>6.4 附属组ID</h3> 
<h3><a id="65__856"></a>6.5 实现区别</h3> 
<h3><a id="66__858"></a>6.6 其他数据文件</h3> 
<h3><a id="67__860"></a>6.7 登陆账户记录</h3> 
<h3><a id="68__862"></a>6.8 系统标识</h3> 
<h3><a id="69__864"></a>6.9 时间和日期例程</h3> 
<p>有UNIX提供的基本时间服务是自1970年00：00：00这一特定时间以来提供的秒数。</p> 
<p>time函数返回当前的时间和日期</p> 
<pre><code class="prism language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;time.h&gt;</span></span>
time_t <span class="token function">time</span><span class="token punctuation">(</span>time_t <span class="token operator">*</span>calptr<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">//返回值：成功，返回时间数，若参数列表非空，返回值也会保存到参数列表的指针中；失败，返回-1</span>
</code></pre> 
<p>两个函数localtime和gmtime将日历时间转换为分解后的时间，并将其存放在一个tm的时间结构中。</p> 
<pre><code class="prism language-cpp"><span class="token keyword">struct</span> <span class="token class-name">tm</span><span class="token punctuation">{<!-- --></span>
<span class="token keyword">int</span> tm_sec<span class="token punctuation">;</span>
<span class="token keyword">int</span> tm_min<span class="token punctuation">;</span>
<span class="token keyword">int</span> tm_hour<span class="token punctuation">;</span>
<span class="token keyword">int</span> tm_mday<span class="token punctuation">;</span>
<span class="token keyword">int</span> tm_mon<span class="token punctuation">;</span>
<span class="token keyword">int</span> tm_year
<span class="token comment">/**还包括夏令时间**/</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre> 
<pre><code class="prism language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;time.h&gt;</span></span>
<span class="token keyword">struct</span> <span class="token class-name">tm</span> <span class="token operator">*</span><span class="token function">gmtime</span><span class="token punctuation">(</span><span class="token keyword">const</span> time_t <span class="token operator">*</span>calptr<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">struct</span> <span class="token class-name">tm</span> <span class="token operator">*</span><span class="token function">localtime</span><span class="token punctuation">(</span><span class="token keyword">const</span> time_t <span class="token operator">*</span>calptr<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> 
<h2><a id="_896"></a>七、进程环境</h2> 
<h3><a id="71_main_897"></a>7.1 main函数</h3> 
<p>C程序总是从main函数开始的。main函数的原型是:</p> 
<pre><code class="prism language-cpp"><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">int</span> argc<span class="token punctuation">,</span> <span class="token keyword">char</span> <span class="token operator">*</span>argv<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> 
<p>argc 是命令行的参数，argv是指向参数的哥哥指针多构成的数组。</p> 
<p>当内核执行一个C程序时（使用exec函数），调用main前先调用一个特殊的启动例程。可执行文件将此启动例程指定为程序的起始地址。启动例程从内核取得命令行参数和环境变量值，然后为按照上述方式调用main函数做好安排。</p> 
<h3><a id="72__909"></a>7.2 进程终止</h3> 
<p>有8种方式是进程终止，其中5种为正常终止，他们是：</p> 
<ul><li>从main返回、调用exit、调用 _exit 或 _Exit、最后一个线程从启动例程中返回、从最后一个线程调用pthread_exit。</li></ul> 
<p>异常终止方式包括三种：</p> 
<ul><li>调用abort、接到一个信号、最后一个线程对取消请求做出响应。</li></ul> 
<p>启动例程是这样编写的：使得从main函数返回后立即调用exit函数。该例程通常使用汇编语言编写的</p> 
<ol><li> <p><strong>退出函数</strong></p> <p>3个函数用于正常终止一个程序：_exit和 _Exit立即进入内核，exit则先执行一些清理处理，然后返回内核。</p> <pre><code class="prism language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;stdlib.h&gt;</span></span>
<span class="token keyword">void</span> <span class="token function">exit</span><span class="token punctuation">(</span><span class="token keyword">int</span> status<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">void</span> <span class="token function">_Exit</span><span class="token punctuation">(</span><span class="token keyword">int</span> status<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;uistd.h&gt;</span></span>
<span class="token keyword">void</span> <span class="token function">_exit</span><span class="token punctuation">(</span><span class="token keyword">int</span> status<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> <p>exit函数总是会先执行一个标准I/O库的清理关闭操作。</p> <p>3个退出函数都会带一个整形参数，称为终止状态。大多数UNIX系统都提供了检查进程终止状态的方法。</p> </li><li> <p><strong>函数atexit</strong></p> </li></ol> 
<p>按照ISO C一个程序最多可以登记32个函数，这些函数有exit自动调用，我们称这些函数为终止处理函数。并调用atexit来登记这些函数。</p> 
<pre><code class="prism language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;stdlib.h&gt;</span></span>
<span class="token keyword">int</span> <span class="token function">atexit</span><span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token punctuation">(</span><span class="token operator">*</span>func<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
						<span class="token comment">//返回值：成功，返回0，若出错，返回-1</span>
</code></pre> 
<p>其中，atexit函数的参数是一个函数地址，exit函数调用这些函数的顺序预登记时顺序相反，同意函数如果登记多次，那么也会调用多次。</p> 
<p>根据ISO C和POSIX.1，exit首先谁调用各种终止处理程序，然后关闭所有打开流，此外若程序调用exec函数族，则将清除所有已安装的终止处理函数。</p> 
<p>注意，内核使程序执行的唯一方法是调用exec函数。进程终止的唯一方法是显式或隐式的调用_exit或 _Exi。进程也可以通过信号的方式非自愿终止。</p> 
<h3><a id="73__953"></a>7.3 命令行参数</h3> 
<p>当执行一个程序时，调用exec的进程可将命令行参数传递给新程序。</p> 
<p>ISO C和POSIC.1 都要求argv[argc]是一个空指针。这就使得我们可以将参数处理循环写为：</p> 
<p><code> for(i = 0; argv[i] != NULL; i++)</code></p> 
<h3><a id="74__961"></a>7.4 环境表</h3> 
<p>每个程序都接收到一张<strong>环境表</strong>，环境表也是一个字符指针数组，全局变量environ则包含了该指针数组的地址：<code>extern char **environ;</code>每个指针包含了一个以null结尾的C字符串的地址。<br> <img src="https://images2.imgbox.com/50/b3/wybJzeSK_o.png" alt="在这里插入图片描述"><br> 通常用getenv和putenv来访问指定的环境变量。</p> 
<h3><a id="75_C_967"></a>7.5 C程序的存储空间布局</h3> 
<p>C程序一直由以下几部分组成：</p> 
<ul><li>正文段。这是由CPU执行的机器指令部分。通常正文段是可共享的，所以即使是频繁执行的程序（如文本编辑器、C编译器和shell等）在存储其中也只需要一个副本，另外正文段常常是只读。</li><li>初始化数据段。通常将此段称为数据段（data段），他包含了程序中需明确地赋初值的变量。</li><li>未初始化数据段。通常将此段称为bss段，在程序开始 执行前，内核将此段中的数据初始化为0或者空指针。</li><li>栈。自动变量以及每次函数调用时所保存的信息都存放在此段中。</li><li>堆。通常在堆中进行动态存储分配。</li><li>命令行参数和环境变量</li></ul> 
<p>[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-3oRsQuIS-1668346492369)(D:\file\课程\md\3.png)]</p> 
<p>size命令报告了正文段、数据段和bss段的长度（以字节为短）。</p> 
<p>这里需要补充几点：</p> 
<ul><li>程序是由进程使用exec函数执行的，而进程号是由内核指定的。C程序在编译过后，就会将正文段（txt段）和初始化的数据data段的数据写入到可执行文件中，有进程加载磁盘来读取这些数据。</li><li>bss和data段的区别： 
  <ul><li>bss段存放全局变量和静态变量（声明但未初始化），具体表现为一个占位符；data段存放：全局变量、静态变量（声明且初始化）、常量。</li><li>bss段不占用磁盘的存储空间，其内容由操作系统初始化（清零）。而data段则占用存储空间。</li><li>bss段和data段在c语言程序内存分区模型中对应为全局/静态变量区，事实上常量也存放在data区。</li><li>进程中堆栈的大小：linux中栈区默认为10M，而在Windows中默认为1M，默认一个线程的栈大小为1M；linux中堆区默认大小为3G(假设内存共4G)，而在windows中为2G，高位空间留给内核。</li><li>如果函数中存在未释放的内存，则可能会使得进程分配的堆区空间不断增大，最终导致过度得换页开销，造成性能下降甚至程序崩溃。</li></ul> </li></ul> 
<h3><a id="76__992"></a>7.6 共享库</h3> 
<p>共享库使得可执行文件不再需要包含公共的库函数，而只需要在所有进程都可引用的存储区中保持这种库例程的一个副本。程序第一次执行或者调用某个库函数时，用动态链接方法将程序与共享 库函数相链接。这减少每个可执行文件的长度，但增加了一些运行时间开销。例如编译如下程序：</p> 
<p><code>$ gcc -static hello1.c 阻止gcc使用共享库</code></p> 
<p><code>a.out -&gt; 979443</code></p> 
<p><code>$ gcc hello1.c gcc使用共享库</code></p> 
<p><code>a.out -&gt; 8378</code></p> 
<p>可以看出，使用共享库编译此程序，可执行文件的正文和数据段的长度都显著减小；</p> 
<h3><a id="77__1006"></a>7.7 存储空间分配</h3> 
<p>ISO C说明了三个用于存储空间动态分配的函数</p> 
<ol><li>malloc，分配指定字节数的存储区，此存储区中的初始值不缺定。</li><li>calloc，为指定数量指定长度的对象分配存储空间，每一位bit都初始化为0.</li><li>realloc，增加或者减少以前分配区的长度</li></ol> 
<pre><code class="prism language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;stdlib.h&gt;</span></span>
<span class="token keyword">void</span> <span class="token operator">*</span><span class="token function">malloc</span><span class="token punctuation">(</span>size_t size<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">void</span> <span class="token operator">*</span><span class="token function">calloc</span><span class="token punctuation">(</span>size_t nobj<span class="token punctuation">,</span> size_t size<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">void</span> <span class="token operator">*</span><span class="token function">realloc</span><span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token operator">*</span>ptr<span class="token punctuation">,</span> size_t newsize<span class="token punctuation">)</span><span class="token punctuation">;</span>
										<span class="token comment">//成功返回非空指针，若出错，返回NULL</span>
<span class="token keyword">void</span> <span class="token function">free</span><span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token operator">*</span>ptr<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> 
<p>因为这三个alloc函数都返回void*， 所以若果程序中包含了<code>#include&lt;stdlib.h&gt;</code>，那么当我们i将这些返回赋予一些其他类型时，就不需要显式的强制类型转换了。</p> 
<p>大多数实现所分配的存储空间比所要求的要稍大一些，额外的空间用来记录管理信息——分配块的长度、指向下一个分配块的指针等，这就意味着，如果超过一个已分配区的尾端或者起始位置首端，则会造成在灾难性问题。</p> 
<p>其他可能产生致命性错误的是：释放一个已经释放的块；调用free时使用的指针不是alloc函数返回值等。弱国一个进程调用malloc函数，但是忘了调用free函数，那么该进程占用的存储空间就会连续增大，这被称为<strong>泄露</strong>。</p> 
<h3><a id="78__1029"></a>7.8 环境变量</h3> 
<p>ISO C定义使用getenc函数来获取环境变量得值，注意，此函数返回一个指针，指向<code>name=value</code>中得value，而且获取得是一个副本，而不是直接访问environ的。</p> 
<pre><code class="prism language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;stdlib.h&gt;</span></span>
<span class="token keyword">char</span> <span class="token operator">*</span><span class="token function">getenv</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span>
								<span class="token comment">//返回值：指向name对应value的指针，若未找到，返回NULL</span>
</code></pre> 
<p>此外，还可以修改环境变量的值：</p> 
<pre><code class="prism language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;stdlib.h&gt;</span></span>
<span class="token keyword">int</span> <span class="token function">putenv</span><span class="token punctuation">(</span><span class="token keyword">char</span> <span class="token operator">*</span>str<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">int</span> <span class="token function">setenv</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>name<span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>value<span class="token punctuation">,</span> <span class="token keyword">int</span> rewrite<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">int</span> <span class="token function">unsetenv</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> 
<h3><a id="79_setjmolongjmp_1048"></a>7.9 函数setjmo和longjmp</h3> 
<p>在C中，goto语句不能跨越函数的，而执行这种跳转功能的函数时setjmp和longjmp。</p> 
<pre><code class="prism language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;setjmp.h&gt;</span></span>
<span class="token keyword">int</span> <span class="token function">setjmp</span><span class="token punctuation">(</span>jmp_buf env<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">void</span> <span class="token function">longjmp</span><span class="token punctuation">(</span>jmp_buf env<span class="token punctuation">,</span> <span class="token keyword">int</span> val<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> 
<h3><a id="710__getrlimitsetrlimit_1058"></a>7.10 函数getrlimit和setrlimit</h3> 
<p>每个进程都有一组资源限制，其中一些可用以下两个函数执行</p> 
<pre><code class="prism language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;sys/resource.h&gt;</span></span>
<span class="token keyword">int</span> <span class="token function">getgetrlimit</span><span class="token punctuation">(</span><span class="token keyword">int</span> resource<span class="token punctuation">,</span> <span class="token keyword">struct</span> <span class="token class-name">rlimit</span> <span class="token operator">*</span>rlptr<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">int</span> <span class="token function">setrlimit</span><span class="token punctuation">(</span><span class="token keyword">int</span> resource<span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">struct</span> <span class="token class-name">rlimit</span> <span class="token operator">*</span>rlptr<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> 
<h2><a id="_1068"></a>八、进程控制</h2> 
<h3><a id="82__1070"></a>8.2 进程标识</h3>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/a1e543892621c062baa228db7c1a452e/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">[!] Gradle threw an error while downloading artifacts from the network. Retrying to download... Runn</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/a614413686fa3834a9980c1f1de9aa28/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">小车沿着黑线行走</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>