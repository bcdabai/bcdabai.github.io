<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Java集合（一） - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Java集合（一）" />
<meta property="og:description" content="目录
Java集合框架概述
Collection接口
Collection接口方法
Iterator迭代器接口
使用 Iterator 接口遍历集合元素
Iterator接口的方法
Iterator接口remove()方法
使用 foreach 循环遍历集合元素
Java集合框架概述 一方面， 面向对象语言对事物的体现都是以对象的形式，为了方便对多个对象的操作，就要对对象进行存储。另一方面，使用Array存储对象方面具有一些弊端，而Java 集合就像一种容器，可以动态地把多个对象的引用放入容器中。
集合、数组都是对多个数据进行存储操作的，简称java容器，此时的存储均为内存层面的存储，不涉及持久化存储。
数组在内存存储方面的特点：
1.数组初始化以后，长度就确定了。
2.数组声明的类型，就决定了进行元素初始化时的类型
数组在存储数据上的弊端：
1.数组初始化以后，长度就不可变了，不便于扩展
2.数组中提供的属性和方法少，不便于进行添加、删除、插入等操作，且效率不高。 同时无法直接获取存储元素的个数
3.数组存储的数据是有序的、可以重复的。----&gt;存储数据的特点单一
java集合类可以用于存储数量不等的多个对象，还可用于存储具有影射关系的关联数组。
Java集合可以分为两种体系：Collection和Map
Collcetion接口：单列数据，定义了存取一组对象的方法的集合
List：元素有序，可重复的集合
Set：元素无序、不可重复的集合
Map接口：双列数据，保存具有映射关系“Key-value对”的集合
Collection接口 Collection 接口是 List、Set 和 Queue 接口的父接口，该接口里定义的方法既可用于操作 Set 集合，也可用于操作 List 和 Queue 集合。
JDK不提供此接口的任何直接实现，而是提供更具体的子接口(如：Set和List) 实现。
在 Java5 之前，Java 集合会丢失容器中所有对象的数据类型，把所有对象都当成 Object 类型处理；从 JDK 5.0 增加了泛型以后，Java 集合可以记住容器中对象的数据类型。
Collection接口方法 1、添加
 add(Object obj)
 addAll(Collection coll)
2、获取有效元素的个数
 int size()" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/47d870a263b3a15c0c683f0c261b47b0/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-03-02T16:25:14+08:00" />
<meta property="article:modified_time" content="2023-03-02T16:25:14+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Java集合（一）</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p id="main-toc"><strong>目录</strong></p> 
<p id="-toc" style="margin-left:0px;"><a href="#Java%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6%E6%A6%82%E8%BF%B0" rel="nofollow">Java集合框架概述</a></p> 
<p id="Collection%E6%8E%A5%E5%8F%A3-toc" style="margin-left:0px;"><a href="#Collection%E6%8E%A5%E5%8F%A3" rel="nofollow">Collection接口</a></p> 
<p id="Collection%E6%8E%A5%E5%8F%A3%E6%96%B9%E6%B3%95-toc" style="margin-left:40px;"><a href="#Collection%E6%8E%A5%E5%8F%A3%E6%96%B9%E6%B3%95" rel="nofollow">Collection接口方法</a></p> 
<p id="Iterator%E8%BF%AD%E4%BB%A3%E5%99%A8%E6%8E%A5%E5%8F%A3-toc" style="margin-left:0px;"><a href="#Iterator%E8%BF%AD%E4%BB%A3%E5%99%A8%E6%8E%A5%E5%8F%A3" rel="nofollow">Iterator迭代器接口</a></p> 
<p id="%E4%BD%BF%E7%94%A8%20Iterator%20%E6%8E%A5%E5%8F%A3%E9%81%8D%E5%8E%86%E9%9B%86%E5%90%88%E5%85%83%E7%B4%A0-toc" style="margin-left:40px;"><a href="#%E4%BD%BF%E7%94%A8%20Iterator%20%E6%8E%A5%E5%8F%A3%E9%81%8D%E5%8E%86%E9%9B%86%E5%90%88%E5%85%83%E7%B4%A0" rel="nofollow">使用 Iterator 接口遍历集合元素</a></p> 
<p id="Iterator%E6%8E%A5%E5%8F%A3%E7%9A%84%E6%96%B9%E6%B3%95-toc" style="margin-left:40px;"><a href="#Iterator%E6%8E%A5%E5%8F%A3%E7%9A%84%E6%96%B9%E6%B3%95" rel="nofollow">Iterator接口的方法</a></p> 
<p id="Iterator%E6%8E%A5%E5%8F%A3remove()%E6%96%B9%E6%B3%95-toc" style="margin-left:40px;"><a href="#Iterator%E6%8E%A5%E5%8F%A3remove%28%29%E6%96%B9%E6%B3%95" rel="nofollow">Iterator接口remove()方法</a></p> 
<p id="%E4%BD%BF%E7%94%A8%20foreach%20%E5%BE%AA%E7%8E%AF%E9%81%8D%E5%8E%86%E9%9B%86%E5%90%88%E5%85%83%E7%B4%A0-toc" style="margin-left:40px;"><a href="#%E4%BD%BF%E7%94%A8%20foreach%20%E5%BE%AA%E7%8E%AF%E9%81%8D%E5%8E%86%E9%9B%86%E5%90%88%E5%85%83%E7%B4%A0" rel="nofollow">使用 foreach 循环遍历集合元素</a></p> 
<hr id="hr-toc"> 
<p></p> 
<h2 id="Java%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6%E6%A6%82%E8%BF%B0">Java集合框架概述</h2> 
<p style="text-align:justify;">一方面， 面向对象语言对事物的体现都是以<span style="color:#fe2c24;">对象</span>的形式，为了方便对多个对象的操作，就要对对象进行存储。另一方面，使用Array存储对象方面具有一些弊端，而Java 集合就像一种容器，可以动态地把多个对象的引用放入容器中。</p> 
<p style="text-align:justify;">集合、数组都是对多个数据进行存储操作的，简称java容器，此时的存储均为内存层面的存储，不涉及持久化存储。</p> 
<p style="text-align:justify;"><strong>数组在内存存储方面的特点：</strong></p> 
<p style="text-align:justify;">1.数组初始化以后，长度就确定了。</p> 
<p style="text-align:justify;">2.数组声明的类型，就决定了进行元素初始化时的类型</p> 
<p style="text-align:justify;"><strong>数组在存储数据上的弊端：</strong></p> 
<p>1.数组初始化以后，长度就不可变了，不便于扩展</p> 
<p>2.数组中提供的属性和方法少，不便于进行添加、删除、插入等操作，且效率不高。 同时无法直接获取存储元素的个数</p> 
<p>3.数组存储的数据是有序的、可以重复的。----&gt;存储数据的特点单一</p> 
<p>java集合类可以用于存储数量不等的多个对象，还可用于存储具有影射关系的关联数组。</p> 
<p><strong>Java集合可以分为两种体系：<span style="color:#fe2c24;">Collection</span>和<span style="color:#fe2c24;">Map</span></strong></p> 
<p><span style="color:#fe2c24;">Collcetion接口</span>：单列数据，定义了存取一组对象的方法的集合</p> 
<p>        List：元素有序，可重复的集合</p> 
<p>        Set：元素无序、不可重复的集合</p> 
<p><span style="color:#fe2c24;">Map接口</span>：双列数据，保存具有映射关系“Key-value对”的集合</p> 
<h2 id="Collection%E6%8E%A5%E5%8F%A3">Collection接口</h2> 
<p><img alt="" height="559" src="https://images2.imgbox.com/df/dc/chsBkFYW_o.png" width="1062"></p> 
<p style="text-align:justify;"><span style="color:#fe2c24;">Collection 接口是 List、Set 和 Queue 接口的父接口，该接口里定义的方法既可用于操作 Set 集合，也可用于操作 List 和 Queue 集合。</span></p> 
<p style="text-align:justify;">JDK不提供此接口的任何直接实现，而是提供更具体的子接口(如：Set和List) 实现。</p> 
<p style="text-align:justify;">在 Java5 之前，Java 集合会丢失容器中所有对象的数据类型，把所有对象都当成 Object 类型处理；从 JDK 5.0 增加了泛型以后，Java 集合可以记住容器中对象的数据类型。</p> 
<h3 id="Collection%E6%8E%A5%E5%8F%A3%E6%96%B9%E6%B3%95" style="text-align:justify;">Collection接口方法</h3> 
<p>1、添加</p> 
<blockquote> 
 <p> add(Object obj)</p> 
 <p> addAll(Collection coll)</p> 
</blockquote> 
<p>2、获取有效元素的个数</p> 
<blockquote> 
 <p> int size()</p> 
</blockquote> 
<p>3、清空集合（只清空内容）</p> 
<blockquote> 
 <p> void clear()</p> 
</blockquote> 
<p>4、是否是空集合</p> 
<blockquote> 
 <p> boolean isEmpty()</p> 
</blockquote> 
<p>5、是否包含某个元素</p> 
<blockquote> 
 <p> boolean contains(Object obj)：是通过元素的equals方法来判断是否是同一个对象（<span style="color:#fe2c24;">要求所在obj类重写equals()方法</span>）</p> 
 <p> boolean containsAll(Collection c)：也是调用元素的equals方法来比较的。拿两个集合的元素挨个比较。</p> 
 <p style="text-align:justify;"> </p> 
</blockquote> 
<p>6、删除</p> 
<blockquote> 
 <p> boolean remove(Object obj) ：通过元素的equals方法判断是否是要删除的那个元素。<strong>只会删除找到的第一个元素</strong></p> 
 <p> boolean removeAll(Collection coll)：取当前集合的差集</p> 
 <p><span style="color:#fe2c24;"><strong>均需要重写equals()方法</strong></span></p> 
</blockquote> 
<p>7、取两个集合的交集<span style="color:#fe2c24;">（会修改当前集合）</span></p> 
<blockquote> 
 <p> boolean retainAll(Collection c)：把交集的结果存在当前集合中，不影响c<br>  </p> 
</blockquote> 
<p>8、集合是否相等</p> 
<blockquote> 
 <p> boolean equals(Object obj)：当前集合元素和形参集合元素都相等（是否有序看具体对象）</p> 
</blockquote> 
<p>9、转成对象数组</p> 
<blockquote> 
 <p> Object[] toArray()</p> 
</blockquote> 
<p>10、转换成集合：调用Arrays类的静态方法asList（）</p> 
<p>11、获取集合对象的哈希值</p> 
<blockquote> 
 <p> hashCode()</p> 
</blockquote> 
<p>12、遍历</p> 
<blockquote> 
 <p> iterator()：返回迭代器对象，用于集合遍历 </p> 
</blockquote> 
<pre><code class="language-java">import org.junit.Test;
import java.util.Date;
import java.util.ArrayList;
import java.util.Collection;

/**
 * @author  light
 * @Description  集合
 * @create 2022-11-29 15:15
 */
public class CollectionTest {
    /**
     * Collection接口中声明的常用方法
     */
    @Test
    public void test1(){
        Collection coll=new ArrayList();//arrayList是collection子接口List的实现

        //add(Object e)：将元素e添加到集合中去
        coll.add("AA");
        coll.add("BB");
        coll.add(123);//自动装箱
        coll.add(new Date());

        //size：获取添加元素的个数
        System.out.println(coll.size());//4

        //addAll(Collection coll1)：将coll1中集合的元素添加到当前集合中去
        Collection coll1 = new ArrayList();
        coll1.add(456);
        coll1.add("CC");
        coll.addAll(coll1);
        System.out.println(coll.size());//6

        //clear()：清空集合内的元素
        coll.clear();


        //boolean  isEmpty()：判断当前集合是否为空
        System.out.println(coll.isEmpty());


        coll.add(123);
        coll.add(345);
        coll.add(new String("Tom"));
        coll.add(false);

        //boolean  contains(Object obj)：判断集合中是否包含Obj在判断是回去调用
        boolean contains = coll.contains(1236);
        System.out.println(contains);


        //boolean  remove(Object obj):从当前集合中删除obj元素
        System.out.println(coll.remove(123));
        System.out.println(coll);

        //removeAll(Collection c):从当前集合中移除c中的所有元素：将当前集合进行修改

        //retainAll:相当于求交集；将当前集合进行修改

        //equals（Object obj)：当前集合和形参集合的元素是否相同

        //hashCode():返回当前对象的哈希值

        //集合可以转换为数组：toArray()

        //数组---&gt;集合：调用Arrays类的静态方法asList()

        //iterator():返回Iterator接口的实例，用于遍历集合元素


    }

}
</code></pre> 
<h2 id="Iterator%E8%BF%AD%E4%BB%A3%E5%99%A8%E6%8E%A5%E5%8F%A3">Iterator迭代器接口</h2> 
<h3 id="%E4%BD%BF%E7%94%A8%20Iterator%20%E6%8E%A5%E5%8F%A3%E9%81%8D%E5%8E%86%E9%9B%86%E5%90%88%E5%85%83%E7%B4%A0">使用 Iterator 接口遍历集合元素</h3> 
<p style="text-align:justify;">Iterator对象称为迭代器(设计模式的一种)，主要<strong>用于遍历 Collection 集合中的元素</strong>。</p> 
<p style="text-align:justify;"><strong>GOF给迭代器模式的定义为：提供一种方法访问一个容器(container)对象中各个元素，而又不需暴露该对象的内部细节。迭代器模式，就是为容器而生。</strong></p> 
<p style="text-align:justify;">Collection接口继承了java.lang.Iterable接口，该接口有一个iterator()方法，那么所有实现了Collection接口的集合类都有一个iterator()方法，用以返回一个实现了 Iterator接口的对象。</p> 
<p style="text-align:justify;"><strong>Iterator 仅用于遍历集合，Iterator 本身并不提供承装对象的能力</strong>。如果需要创建 Iterator 对象，则必须有一个被迭代的集合。</p> 
<p style="text-align:justify;">集合对象每次调用iterator()方法都得到一个全新的迭代器对象，默认游标都在集合 的第一个元素之前。 </p> 
<h3 id="Iterator%E6%8E%A5%E5%8F%A3%E7%9A%84%E6%96%B9%E6%B3%95" style="text-align:justify;">Iterator接口的方法</h3> 
<p><img alt="" height="200" src="https://images2.imgbox.com/70/28/sZYCTNW7_o.png" width="826"></p> 
<p><span style="color:#fe2c24;">在调用it.next()方法之前必须要调用it.hasNext()进行检测。若不调用，且 下一条记录无效，直接调用it.next()会抛出NoSuchElementException异常。 </span></p> 
<p><img alt="" height="532" src="https://images2.imgbox.com/6b/08/2k7D3Jms_o.png" width="1052"></p> 
<pre><code class="language-java">import org.junit.Test;

import java.util.ArrayList;
import java.util.Collection;
import java.util.Iterator;

/**
 * @auther light
 * @Description  集合元素的遍历：使用迭代器iterator()
 * @create 2022-11-30 21:25
 */
public class IteratorTest {

    @Test
    public void test1(){
        Collection coll = new ArrayList();
        coll.add(123);
        coll.add(345);
        coll.add(new String("Tom"));
        coll.add(false);

        Iterator iterator = coll.iterator();//只是迭代器


//        System.out.println(coll.iterator().next());


        //遍历
        while(iterator.hasNext()){
            System.out.println(iterator.next());
        }
    }
}</code></pre> 
<p> 运行结果：</p> 
<p><img alt="" height="336" src="https://images2.imgbox.com/1d/6f/NXyRZwz5_o.png" width="856"></p> 
<h3 id="Iterator%E6%8E%A5%E5%8F%A3remove()%E6%96%B9%E6%B3%95">Iterator接口remove()方法</h3> 
<p>Iterator可以删除集合的元素，但是是遍历过程中通过迭代器对象的remove方法，不是集合对象的remove方法。 </p> 
<p>如果还未调用next()或在上一次调用 next 方法之后已经调用了 remove 方法， 再调用remove都会报IllegalStateException。 </p> 
<pre><code class="language-java">import org.junit.Test;

import java.util.ArrayList;
import java.util.Collection;
import java.util.Iterator;

/**
 * @auther light
 * @Description  集合元素的遍历：使用迭代器iterator()
 * @create 2022-11-30 21:25
 */
public class IteratorTest {
    /**
     * Iterator中的remove()方法
     *
     */
    @Test
    public void test2(){

        Collection coll = new ArrayList();
        coll.add(123);
        coll.add(345);
        coll.add(new String("Tom"));
        coll.add(false);

        Iterator iterator = coll.iterator();
//      删除集合中"Tom"数据
        while(iterator.hasNext()){
            Object next = iterator.next();
            if("Tom".equals(next)){
                iterator.remove();//只能调用迭代器的remove()方法
            }
        }

        Iterator iterator1 = coll.iterator();
        while(iterator1.hasNext()){
            System.out.println(iterator1.next());
        }

    }

}

</code></pre> 
<p>运行结果：<img alt="" height="311" src="https://images2.imgbox.com/f3/34/qOFptDMV_o.png" width="914"></p> 
<h3 id="%E4%BD%BF%E7%94%A8%20foreach%20%E5%BE%AA%E7%8E%AF%E9%81%8D%E5%8E%86%E9%9B%86%E5%90%88%E5%85%83%E7%B4%A0">使用 foreach 循环遍历集合元素</h3> 
<p style="text-align:justify;">Java 5.0 提供了 foreach 循环（增强for循环）迭代访问 Collection和数组。</p> 
<p style="text-align:justify;">遍历操作不需获取Collection或数组的长度，无需使用索引访问元素。</p> 
<p style="text-align:justify;">遍历集合的底层调用Iterator完成操作。</p> 
<p style="text-align:justify;">foreach还可以用来遍历数组。 </p> 
<p style="text-align:justify;"><img alt="" height="260" src="https://images2.imgbox.com/76/c9/ZqjAJ1Ov_o.png" width="625"></p> 
<pre><code class="language-java">import org.junit.Test;

import java.util.ArrayList;
import java.util.Collection;

/**
 * @auther light
 * @Description 增强型for循环
 * @create 2022-11-30 21:56
 */
public class ForTest {

    @Test
    public  void test1(){
        Collection coll = new ArrayList();
        coll.add(123);
        coll.add(345);
        coll.add(new String("Tom"));
        coll.add(false);
        //for(集合中元素的类型 局部变量：集合对象)
        //内部仍然调用迭代器
        for(Object obj:coll){
            System.out.println(obj);

        }
    }
}
</code></pre> 
<p> 运行结果：</p> 
<p><img alt="" height="363" src="https://images2.imgbox.com/82/60/izOf0O6X_o.png" width="939"></p> 
<p> </p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/610ec59f210b45168c9d6c096b29b33e/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">【C语言进阶】详解C语言动态内存管理</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/94a89c8009c84720f83015ea1377bfc2/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">Metasploit渗透测试框架基础</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>