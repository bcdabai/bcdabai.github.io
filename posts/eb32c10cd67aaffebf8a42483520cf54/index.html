<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>java ftp服务器 多用户、 多文件夹监听文件上传 spring boot整合Ftp - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="java ftp服务器 多用户、 多文件夹监听文件上传 spring boot整合Ftp" />
<meta property="og:description" content="引言 这里介绍 java创建 Ftp服务器, 并且监测客户端上传文件后，读取文件的操作。使用 hutool 创建Ftp客户端，使用 ftplet-api 下的 DefaultFtplet 进行文件监听。上传的文件夹通过不同用户添加，设置不同的用户名、密码、上传文件夹，测试时通过连接不同的用户，上传文件到指定文件夹。这里有个小小的问题 DefaultFtplet 监听器是 ftp 依赖下的类，测试使用 Hutool 下的 Ftp 类，所以无法通过 hutool的 Ftp类 测试指定文件夹上传，只能上传 创建 Ftp 服务器 时 指定的文件夹，即创建 Ftp服务器时 添加 不同用户 的文件夹 sql 数据表
CREATE TABLE `ftp_info` ( `id` int(11) NOT NULL AUTO_INCREMENT, `ftp_code` varchar(255) NOT NULL COMMENT &#39;ftp编码&#39;, `username` varchar(255) NOT NULL COMMENT &#39;用户名&#39;, `password` varchar(255) NOT NULL COMMENT &#39;密码&#39;, `upload_folder` varchar(255) NOT NULL COMMENT &#39;上传文件夹&#39;, `status` int(11) NOT NULL DEFAULT &#39;0&#39; COMMENT &#39;是否使用 1使用 0 未用&#39;, PRIMARY KEY (`id`), UNIQUE KEY `user` (`username`,`password`) ) ENGINE=InnoDB AUTO_INCREMENT=4 DEFAULT CHARSET=utf8mb4; 数据表实体类" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/eb32c10cd67aaffebf8a42483520cf54/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-08-22T11:18:26+08:00" />
<meta property="article:modified_time" content="2023-08-22T11:18:26+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">java ftp服务器 多用户、 多文件夹监听文件上传 spring boot整合Ftp</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <h2><a id="_1"></a>引言</h2> 
<blockquote> 
 <ol><li>这里介绍 <code>java</code>创建 <code>Ftp服务器</code>, 并且监测客户端上传文件后，读取文件的操作。使用 <code>hutool</code> 创建Ftp客户端，使用 <code>ftplet-api</code> 下的 <code>DefaultFtplet</code> 进行文件监听。</li><li>上传的文件夹通过不同用户添加，设置不同的用户名、密码、上传文件夹，测试时通过连接不同的用户，上传文件到指定文件夹。</li><li>这里有个小小的问题 <code>DefaultFtplet</code> 监听器是 <code>ftp</code> 依赖下的类，测试使用 <code>Hutool</code> 下的 <code>Ftp</code> 类，所以无法通过 <code>hutool</code>的 <code>Ftp</code>类 测试指定文件夹上传，只能上传 创建 <code>Ftp 服务器</code> 时 指定的文件夹，即创建 <code>Ftp服务器</code>时 添加 <code>不同用户</code> 的文件夹</li></ol> 
</blockquote> 
<p>sql 数据表</p> 
<pre><code>CREATE TABLE `ftp_info` (
  `id` int(11) NOT NULL AUTO_INCREMENT,
  `ftp_code` varchar(255) NOT NULL COMMENT 'ftp编码',
  `username` varchar(255) NOT NULL COMMENT '用户名',
  `password` varchar(255) NOT NULL COMMENT '密码',
  `upload_folder` varchar(255) NOT NULL COMMENT '上传文件夹',
  `status` int(11) NOT NULL DEFAULT '0' COMMENT '是否使用 1使用 0 未用',
  PRIMARY KEY (`id`),
  UNIQUE KEY `user` (`username`,`password`)
) ENGINE=InnoDB AUTO_INCREMENT=4 DEFAULT CHARSET=utf8mb4;
</code></pre> 
<p>数据表实体类</p> 
<pre><code>@Data
@Builder
@AllArgsConstructor
@NoArgsConstructor
public class FtpInfo {

    private Integer id;

    private String ftpCode;

    private String username;

    private String password;

    private String uploadFolder;

    private Integer status;
}

</code></pre> 
<h3><a id="_43"></a>添加依赖</h3> 
<pre><code>
&lt;dependency&gt;
   &lt;groupId&gt;org.projectlombok&lt;/groupId&gt;
   &lt;artifactId&gt;lombok&lt;/artifactId&gt;
&lt;/dependency&gt;

&lt;dependency&gt;
    &lt;groupId&gt;org.apache.ftpserver&lt;/groupId&gt;
    &lt;artifactId&gt;ftpserver-core&lt;/artifactId&gt;
    &lt;version&gt;1.2.0&lt;/version&gt;
&lt;/dependency&gt;

&lt;dependency&gt;
    &lt;groupId&gt;org.apache.ftpserver&lt;/groupId&gt;
    &lt;artifactId&gt;ftplet-api&lt;/artifactId&gt;
    &lt;version&gt;1.2.0&lt;/version&gt;
&lt;/dependency&gt;

&lt;dependency&gt;
    &lt;groupId&gt;org.apache.mina&lt;/groupId&gt;
    &lt;artifactId&gt;mina-core&lt;/artifactId&gt;
    &lt;version&gt;2.0.16&lt;/version&gt;
&lt;/dependency&gt;

&lt;dependency&gt;
    &lt;groupId&gt;cn.hutool&lt;/groupId&gt;
    &lt;artifactId&gt;hutool-all&lt;/artifactId&gt;
    &lt;version&gt;5.8.18&lt;/version&gt;
&lt;/dependency&gt;

&lt;dependency&gt;
	&lt;groupId&gt;commons-net&lt;/groupId&gt;
	&lt;artifactId&gt;commons-net&lt;/artifactId&gt;
	&lt;version&gt;3.6&lt;/version&gt;
&lt;/dependency&gt;
</code></pre> 
<h3><a id="yml__84"></a>yml配置文件 及配置类</h3> 
<blockquote> 
 <p>这里提供一种，引入 <code>ftp服务器</code> 端口的方式，也可以通过方式引入</p> 
</blockquote> 
<p>yml配置文件 定义账号 密码 端口号</p> 
<pre><code>ftp-server:
  port: 27    # 端口号
</code></pre> 
<p>配置类</p> 
<pre><code>package com.esframework.project.kdzt.ftp.properties;

import lombok.Data;
import org.springframework.boot.context.properties.ConfigurationProperties;
import org.springframework.context.annotation.Configuration;
import org.springframework.stereotype.Component;

/**
 * @author Administrator
 */
@Data
@Component
@Configuration
@ConfigurationProperties(prefix = "ftp-server")
public class FtpProperties {

    private Integer port;
}

</code></pre> 
<h3><a id="hutool_spring_boot__ftp_115"></a>利用hutool代码 整合spring boot 创建 ftp服务端</h3> 
<p>配置监听器</p> 
<pre><code>package com.example.ftp.ftp2;

import org.apache.ftpserver.ftplet.*;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import java.io.File;
import java.io.IOException;
import java.util.UUID;

/**
 * ftp服务器侦听器
 *
 * @date 2023/06/29
 */
public class FtpServerListener extends DefaultFtplet {
    public static final Logger log = LoggerFactory.getLogger(FtpServerListener.class);


    /**
     * 在连接* 开始连接@param session 会话
     *
     * @return {@link FtpletResult}
     * @throws FtpException ftp例外
     * @throws IOException  ioexception
     */
    @Override
    public FtpletResult onConnect(FtpSession session) throws FtpException, IOException {
        UUID sessionId = session.getSessionId();
        if (sessionId != null) {
            log.info("{}尝试登录ftpserver", sessionId);
        }
        User user = session.getUser();
        if (user != null &amp;&amp; user.getName() != null) {
            assert sessionId != null;
            log.info("{}尝试使用用户名:{}，密码:{}登录ftpserver.", sessionId, user.getName(), user.getPassword());
        }
        return super.onConnect(session);
    }

    /**
     * 在断开* 关闭连接@param session 会话
     *
     * @return {@link FtpletResult}
     * @throws FtpException ftp例外
     * @throws IOException  ioexception
     */
    @Override
    public FtpletResult onDisconnect(FtpSession session) throws FtpException, IOException {
        UUID sessionId = session.getSessionId();
        User user = session.getUser();
        if (sessionId != null) {
            log.info("{}关闭ftpserver连接", sessionId);
        }
        if (user != null &amp;&amp; user.getName() != null) {
            assert sessionId != null;
            log.info("{}用户名:{}关闭ftpserver连接.", sessionId, user.getName());
        }
        return super.onDisconnect(session);
    }

    /**
     * 上传开始* 开始上传@param session 会话
     *
     * @param request 请求
     * @return {@link FtpletResult}
     * @throws FtpException ftp例外
     * @throws IOException  ioexception
     */
    @Override
    public FtpletResult onUploadStart(FtpSession session, FtpRequest request) throws FtpException, IOException {
        //获取上传文件的上传路径
        String path = session.getUser().getHomeDirectory();
        //自动创建上传路径
        File file = new File(path);
        if (!file.exists()) {
            file.mkdirs();
        }
        //获取上传用户
        String name = session.getUser().getName();
        // 获取上传文件名
        String filename = request.getArgument();
        log.info("用户:'{}'，上传文件到目录：'{}'，文件名称为：'{}'，状态：开始上传~", name, path, filename);

        return super.onUploadEnd(session, request);
    }

    /**
     * 在上传* 上传完成@param session 会话
     *
     * @param request 请求
     * @return {@link FtpletResult}
     * @throws FtpException ftp例外
     * @throws IOException  ioexception
     */
    @Override
    public FtpletResult onUploadEnd(FtpSession session, FtpRequest request) throws FtpException, IOException {
        //获取上传文件的上传路径
         String path = session.getUser().getHomeDirectory();
        // 获取上传用户
        String name = session.getUser().getName();
        // 获取上传文件名
        String fileName = request.getArgument();
        File file = new File(path + "/" + fileName);
        if (file.exists()) {
            // 读取文件
            String filePath = String.format("%s\\%s", path, fileName);
            log.info("用户:'{}'，上传文件到目录：'{}'，文件名称为：'{}，状态：成功！'", name, path, fileName);
        }
        return super.onUploadStart(session, request);
    }

    @Override
    public FtpletResult onDownloadStart(FtpSession session, FtpRequest request) throws FtpException, IOException {
        return super.onDownloadStart(session, request);
    }

    @Override
    public FtpletResult onDownloadEnd(FtpSession session, FtpRequest request) throws FtpException, IOException {
        return super.onDownloadEnd(session, request);
    }
}

</code></pre> 
<p>使用 <code>ApplicationRunner</code> 启动服务时，创建 <code>ftp</code>服务</p> 
<pre><code>package com.example.ftp.ftp2;

import cn.hutool.core.io.FileUtil;
import cn.hutool.extra.ftp.SimpleFtpServer;
import com.google.common.collect.Lists;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.apache.ftpserver.ftplet.Authority;
import org.apache.ftpserver.usermanager.impl.BaseUser;
import org.apache.ftpserver.usermanager.impl.WritePermission;
import org.springframework.boot.ApplicationArguments;
import org.springframework.boot.ApplicationRunner;
import org.springframework.stereotype.Component;

import java.io.File;
import java.util.List;

/**
 * ftp服务器
 *
 * @author Administrator
 * @date 2023/06/30
 */
@Slf4j
@Component
@RequiredArgsConstructor
public class FtpServer implements ApplicationRunner {

    private final FtpProperties ftpProperties;

    @Override
    public void run(ApplicationArguments args) throws Exception {
		// 这里演示写了两个用户  实际业务中 可以查询数据库添加
        BaseUser user = new BaseUser();
        user.setName("user1");
        user.setPassword("user1");
        // 配置上传的文件夹 没有就新建
        File folder = FileUtil.file("D:\\ftp1\\user1");
        if(!folder.exists()) {
            boolean mkdir = folder.mkdir();
        }
        user.setHomeDirectory("D:\\ftp1\\user1");
        user.setMaxIdleTime(0);
        user.setEnabled(true);
        //设置用户权限 不设置权限 上传文件会被拒绝 导致上传失败
        List&lt;Authority&gt; authorities = Lists.newArrayList();
        authorities.add(new WritePermission());
        user.setAuthorities(authorities);


        BaseUser user1 = new BaseUser();
        user1.setName("user2");
        user1.setPassword("user2");
        // 配置上传的文件夹 没有就新建
        File folder1 = FileUtil.file("D:\\ftp1\\user2");
        if(!folder.exists()) {
            boolean mkdir = folder1.mkdir();
        }
        user1.setHomeDirectory("D:\\ftp1\\user2");
        user1.setMaxIdleTime(0);
        user1.setEnabled(true);
        //设置用户权限
        List&lt;Authority&gt; authorities1 = Lists.newArrayList();
        authorities1.add(new WritePermission());
        user1.setAuthorities(authorities1);

        SimpleFtpServer simpleFtpServer = SimpleFtpServer.create()
        // 添加用户
        .addUser(user).addUser(user1)
        .setPort(ftpProperties.getPort());
        // 配置监听器
        simpleFtpServer.addFtplet("folder", new FtpServerListener());
        simpleFtpServer.start();
        log.info("Ftp 开启=====》");
    }
}

</code></pre> 
<h3><a id="_329"></a>测试</h3> 
<p>使用 <code>hutool</code> 进行测试</p> 
<p><strong>注意</strong><br> 下面使用 <code>public boolean upload(String destPath, File file)</code> 这个方法时 <code>destPath</code> 会根据 <code>Ftp Server</code> 创建时 user的 <code>setHomeDirectory</code> 参数变化，</p> 
<ol><li>不设置 <code>setHomeDirectory</code> 参数时，<code>destPath</code> 写全部路径，但是监听器无法获取 上传文件的全路径。</li><li>设置 <code>setHomeDirectory</code> 参数时， <code>destPath</code> 填写 <code>/</code> 就是 <code>setHomeDirectory</code> 定义的文件夹</li></ol> 
<pre><code>package com.example.ftp.ftp;

import cn.hutool.core.io.FileUtil;
import cn.hutool.extra.ftp.Ftp;

import java.io.IOException;

public class FtpTest {

    public static void main(String[] args) {
       // 输入不同的用户名、密码 测试上传不通的文件夹
        Ftp ftp1 = new Ftp("ip", port, "username", "password");
        try {
            ftp1.upload("/", FileUtil.file("D:\\FlFile\\1234.txt"));
        } catch (Exception e) {
            e.printStackTrace();
        } finally {
            try {
               ftp1.close();
            } catch (IOException e) {
                e.printStackTrace();
            }
        }

    }
}

</code></pre> 
<hr> 
<h2><a id="_371"></a>总结</h2> 
<ol><li>最近遇到了上传Ftp到服务器后，读取文件保存到数据库的功能，然后查找相关代码，最初查到了，使用<code>hutool</code> 工具类创建<code>ftp服务器</code>, 使用 <code>hutool</code> 的 文件监听器 <a href="https://doc.hutool.cn/pages/WatchMonitor/" rel="nofollow">WatchMonitor</a> 然后监听 指定目录，监听到新建文件，然后开始读取文件，但是如果项目中发生异常，监听会出问题。</li><li>然后又找到了Ftp 自己带的文件监听 <code>DefaultFtplet</code>, 可以监听到文件上传成功，然后操作。</li><li>最后就是如何多用户多文件夹上传的问题，测试了几遍，发现在创建Ftp服务的时候，可以添加多个用户，每个用户不同的用户名、密码、指定的上传文件夹，在客户端上传时，可以准确监听到文件上传，这样 多用户 多文件夹上传功能终于实现了。</li></ol> 
<h3><a id="_376"></a>几个要点</h3> 
<h4><a id="_378"></a>用户指定用户名、密码、文件夹</h4> 
<pre><code>  BaseUser user1 = new BaseUser();
  user1.setName("user2");
  user1.setPassword("user2");
  // 配置上传的文件夹 没有就新建
  File folder1 = FileUtil.file("D:\\ftp1\\user2");
  if(!folder.exists()) {
      boolean mkdir = folder1.mkdir();
  }
  user1.setHomeDirectory("D:\\ftp1\\user2");
  user1.setMaxIdleTime(0);
  user1.setEnabled(true);

</code></pre> 
<h4><a id="__393"></a>设置用户权限、不设置用户权限 上传文件会被拒绝，导致上传失败</h4> 
<pre><code>  //设置用户权限
  List&lt;Authority&gt; authorities1 = Lists.newArrayList();
  authorities1.add(new WritePermission());
  user1.setAuthorities(authorities1);
</code></pre> 
<h4><a id="hutool__402"></a>hutool 文件监听示例</h4> 
<p>ftp 文件监听，失败的迭代示例</p> 
<pre><code>package com.example.ftp.ftp;

import cn.hutool.core.io.FileUtil;
import cn.hutool.core.io.watch.WatchMonitor;
import cn.hutool.core.io.watch.Watcher;
import cn.hutool.core.lang.Console;
import cn.hutool.core.util.CharsetUtil;
import org.springframework.boot.ApplicationArguments;
import org.springframework.boot.ApplicationRunner;
import org.springframework.stereotype.Component;

import java.io.File;
import java.nio.file.Path;
import java.nio.file.WatchEvent;
import java.util.List;

@Component
public class FtpUpdate implements ApplicationRunner {


    public void update() {
        File file = FileUtil.file("D:\\ftp");
        //这里只监听文件或目录的修改事件
        WatchMonitor watchMonitor = WatchMonitor.create(file, WatchMonitor.ENTRY_CREATE);
        watchMonitor.setWatcher(new Watcher() {
            @Override
            public void onCreate(WatchEvent&lt;?&gt; event, Path currentPath) {
                Object obj = event.context();
                Console.log("创建：{}-&gt; {}", currentPath, obj);
                String filePath = String.format("%s\\%s", currentPath, obj.toString());
                String destPath = String.format("%s\\%s", "D:\\OfFile", obj);

                // 读取文件
                List&lt;String&gt; readLines = FileUtil.readLines(destPath, CharsetUtil.UTF_8);
                readLines.forEach(System.out::println);
            }

            @Override
            public void onModify(WatchEvent&lt;?&gt; event, Path currentPath) {
                Object obj = event.context();
                Console.log("修改：{}-&gt; {}", currentPath, obj);
            }

            @Override
            public void onDelete(WatchEvent&lt;?&gt; event, Path currentPath) {
                Object obj = event.context();
                Console.log("删除：{}-&gt; {}", currentPath, obj);
            }

            @Override
            public void onOverflow(WatchEvent&lt;?&gt; event, Path currentPath) {
                Object obj = event.context();
                Console.log("Overflow：{}-&gt; {}", currentPath, obj);
            }
        });
        watchMonitor.setMaxDepth(3);

        //设置监听目录的最大深入，目录层级大于制定层级的变更将不被监听，默认只监听当前层级目录
        //启动监听
        watchMonitor.start();
    }

    @Override
    public void run(ApplicationArguments args) throws Exception {
        update();
    }
}

</code></pre>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/ce3a2712567bf6d59aaf5cde46e71aca/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">ResizeObserver监听元素大小的变化</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/64ebe70b7ba262dbe097cf09005b66cf/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">git 创建远程仓库并且本地代码提交到远程仓库</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>