<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>C语言八股（自用） - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="C语言八股（自用）" />
<meta property="og:description" content="目录
一、主要知识点
二、指针
1.定义
2.指针的初始化
3.指针的赋值
4.指针的运算
5.指针与一维数组
6.指针与二维数组
7.字符指针与字符串
8.指针数组
9.多级指针
10.void指针
11.面试题
1.野指针是什么？成因以及解决方法？
2. 悬空指针和野指针有什么区别？
三、数组和字符串
1.一维数组
2.二维数组
3.字符数组与字符串
4.字符串函数
5.面试题
1.sizeof关键字与strlen函数的区别
2.strcpy和memcpy区别
四、关键字
1.常量
1.#define
2.运算符
3.变量
1.auto
2.register
3.static
4.extern
4.常见关键字
1.assert
2.const
3.volatile
4.sizeof
5.typedef
5.面试题
1.extern与static区别
2.C 语言的关键字 static 和 C&#43;&#43; 的关键字 static 有什么区别
2.const和define的区别
3.#define和别名typedef的区别
4.#include 的顺序以及尖括号和双引号的区别
cout是有缓冲输出，输出过程会首先将输出字符放入缓冲区，然后输出到屏幕。 printf是无缓冲输出，有输出时立即输出。
5. strcpy函数和strncpy函数的区别？哪个函数更安全？
五、内存
1.内存分区
2.面试题
1. 深拷贝与浅拷贝？
2.. c和c&#43;&#43;的区别？
3.堆与栈的区别？
4. new和malloc的区别？
5.讲讲大端小端" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/91e31c78b43a2d35619ae9fb9d4c562b/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-10-12T16:48:51+08:00" />
<meta property="article:modified_time" content="2023-10-12T16:48:51+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">C语言八股（自用）</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p id="main-toc"><strong>目录</strong></p> 
<p id="%E4%B8%80%E3%80%81%E4%B8%BB%E8%A6%81%E7%9F%A5%E8%AF%86%E7%82%B9-toc" style="margin-left:0px;"><a href="#%E4%B8%80%E3%80%81%E4%B8%BB%E8%A6%81%E7%9F%A5%E8%AF%86%E7%82%B9" rel="nofollow">一、主要知识点</a></p> 
<p id="%C2%A0%E4%BA%8C%E3%80%81%E6%8C%87%E9%92%88-toc" style="margin-left:0px;"><a href="#%C2%A0%E4%BA%8C%E3%80%81%E6%8C%87%E9%92%88" rel="nofollow"> 二、指针</a></p> 
<p id="1.%E5%AE%9A%E4%B9%89-toc" style="margin-left:40px;"><a href="#1.%E5%AE%9A%E4%B9%89" rel="nofollow">1.定义</a></p> 
<p id="2.%E6%8C%87%E9%92%88%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96-toc" style="margin-left:40px;"><a href="#2.%E6%8C%87%E9%92%88%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96" rel="nofollow">2.指针的初始化</a></p> 
<p id="3.%E6%8C%87%E9%92%88%E7%9A%84%E8%B5%8B%E5%80%BC-toc" style="margin-left:40px;"><a href="#3.%E6%8C%87%E9%92%88%E7%9A%84%E8%B5%8B%E5%80%BC" rel="nofollow">3.指针的赋值</a></p> 
<p id="4.%E6%8C%87%E9%92%88%E7%9A%84%E8%BF%90%E7%AE%97-toc" style="margin-left:40px;"><a href="#4.%E6%8C%87%E9%92%88%E7%9A%84%E8%BF%90%E7%AE%97" rel="nofollow">4.指针的运算</a></p> 
<p id="5.%E6%8C%87%E9%92%88%E4%B8%8E%E4%B8%80%E7%BB%B4%E6%95%B0%E7%BB%84-toc" style="margin-left:40px;"><a href="#5.%E6%8C%87%E9%92%88%E4%B8%8E%E4%B8%80%E7%BB%B4%E6%95%B0%E7%BB%84" rel="nofollow">5.指针与一维数组</a></p> 
<p id="6.%E6%8C%87%E9%92%88%E4%B8%8E%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84-toc" style="margin-left:40px;"><a href="#6.%E6%8C%87%E9%92%88%E4%B8%8E%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84" rel="nofollow">6.指针与二维数组</a></p> 
<p id="7.%E5%AD%97%E7%AC%A6%E6%8C%87%E9%92%88%E4%B8%8E%E5%AD%97%E7%AC%A6%E4%B8%B2-toc" style="margin-left:40px;"><a href="#7.%E5%AD%97%E7%AC%A6%E6%8C%87%E9%92%88%E4%B8%8E%E5%AD%97%E7%AC%A6%E4%B8%B2" rel="nofollow">7.字符指针与字符串</a></p> 
<p id="8.%E6%8C%87%E9%92%88%E6%95%B0%E7%BB%84-toc" style="margin-left:40px;"><a href="#8.%E6%8C%87%E9%92%88%E6%95%B0%E7%BB%84" rel="nofollow">8.指针数组</a></p> 
<p id="9.%E5%A4%9A%E7%BA%A7%E6%8C%87%E9%92%88-toc" style="margin-left:40px;"><a href="#9.%E5%A4%9A%E7%BA%A7%E6%8C%87%E9%92%88" rel="nofollow">9.多级指针</a></p> 
<p id="10.void%E6%8C%87%E9%92%88-toc" style="margin-left:40px;"><a href="#10.void%E6%8C%87%E9%92%88" rel="nofollow">10.void指针</a></p> 
<p id="11.%E9%9D%A2%E8%AF%95%E9%A2%98-toc" style="margin-left:40px;"><a href="#11.%E9%9D%A2%E8%AF%95%E9%A2%98" rel="nofollow">11.面试题</a></p> 
<p id="1.%E9%87%8E%E6%8C%87%E9%92%88%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F%E6%88%90%E5%9B%A0%E4%BB%A5%E5%8F%8A%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95%EF%BC%9F-toc" style="margin-left:80px;"><a href="#1.%E9%87%8E%E6%8C%87%E9%92%88%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F%E6%88%90%E5%9B%A0%E4%BB%A5%E5%8F%8A%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95%EF%BC%9F" rel="nofollow">1.野指针是什么？成因以及解决方法？</a></p> 
<p id="2.%C2%A0%E6%82%AC%E7%A9%BA%E6%8C%87%E9%92%88%E5%92%8C%E9%87%8E%E6%8C%87%E9%92%88%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F-toc" style="margin-left:80px;"><a href="#2.%C2%A0%E6%82%AC%E7%A9%BA%E6%8C%87%E9%92%88%E5%92%8C%E9%87%8E%E6%8C%87%E9%92%88%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F" rel="nofollow">2. 悬空指针和野指针有什么区别？</a></p> 
<p id="%E4%B8%89%E3%80%81%E6%95%B0%E7%BB%84%E5%92%8C%E5%AD%97%E7%AC%A6%E4%B8%B2-toc" style="margin-left:0px;"><a href="#%E4%B8%89%E3%80%81%E6%95%B0%E7%BB%84%E5%92%8C%E5%AD%97%E7%AC%A6%E4%B8%B2" rel="nofollow">三、数组和字符串</a></p> 
<p id="1.%E4%B8%80%E7%BB%B4%E6%95%B0%E7%BB%84-toc" style="margin-left:40px;"><a href="#1.%E4%B8%80%E7%BB%B4%E6%95%B0%E7%BB%84" rel="nofollow">1.一维数组</a></p> 
<p id="2.%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84-toc" style="margin-left:40px;"><a href="#2.%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84" rel="nofollow">2.二维数组</a></p> 
<p id="3.%E5%AD%97%E7%AC%A6%E6%95%B0%E7%BB%84%E4%B8%8E%E5%AD%97%E7%AC%A6%E4%B8%B2-toc" style="margin-left:40px;"><a href="#3.%E5%AD%97%E7%AC%A6%E6%95%B0%E7%BB%84%E4%B8%8E%E5%AD%97%E7%AC%A6%E4%B8%B2" rel="nofollow">3.字符数组与字符串</a></p> 
<p id="4.%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%87%BD%E6%95%B0-toc" style="margin-left:40px;"><a href="#4.%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%87%BD%E6%95%B0" rel="nofollow">4.字符串函数</a></p> 
<p id="5.%E9%9D%A2%E8%AF%95%E9%A2%98-toc" style="margin-left:40px;"><a href="#5.%E9%9D%A2%E8%AF%95%E9%A2%98" rel="nofollow">5.面试题</a></p> 
<p id="1.sizeof%E5%85%B3%E9%94%AE%E5%AD%97%E4%B8%8Estrlen%E5%87%BD%E6%95%B0%E7%9A%84%E5%8C%BA%E5%88%AB-toc" style="margin-left:80px;"><a href="#1.sizeof%E5%85%B3%E9%94%AE%E5%AD%97%E4%B8%8Estrlen%E5%87%BD%E6%95%B0%E7%9A%84%E5%8C%BA%E5%88%AB" rel="nofollow">1.sizeof关键字与strlen函数的区别</a></p> 
<p id="2.strcpy%E5%92%8Cmemcpy%E5%8C%BA%E5%88%AB-toc" style="margin-left:80px;"><a href="#2.strcpy%E5%92%8Cmemcpy%E5%8C%BA%E5%88%AB" rel="nofollow">2.strcpy和memcpy区别</a></p> 
<p id="%E5%9B%9B%E3%80%81%E5%85%B3%E9%94%AE%E5%AD%97-toc" style="margin-left:0px;"><a href="#%E5%9B%9B%E3%80%81%E5%85%B3%E9%94%AE%E5%AD%97" rel="nofollow">四、关键字</a></p> 
<p id="1.%E5%B8%B8%E9%87%8F-toc" style="margin-left:40px;"><a href="#1.%E5%B8%B8%E9%87%8F" rel="nofollow">1.常量</a></p> 
<p id="1.%23define-toc" style="margin-left:80px;"><a href="#1.%23define" rel="nofollow">1.#define</a></p> 
<p id="2.%E8%BF%90%E7%AE%97%E7%AC%A6-toc" style="margin-left:40px;"><a href="#2.%E8%BF%90%E7%AE%97%E7%AC%A6" rel="nofollow">2.运算符</a></p> 
<p id="3.%E5%8F%98%E9%87%8F-toc" style="margin-left:40px;"><a href="#3.%E5%8F%98%E9%87%8F" rel="nofollow">3.变量</a></p> 
<p id="1.auto-toc" style="margin-left:80px;"><a href="#1.auto" rel="nofollow">1.auto</a></p> 
<p id="2.register-toc" style="margin-left:80px;"><a href="#2.register" rel="nofollow">2.register</a></p> 
<p id="3.static-toc" style="margin-left:80px;"><a href="#3.static" rel="nofollow">3.static</a></p> 
<p id="4.extern-toc" style="margin-left:80px;"><a href="#4.extern" rel="nofollow">4.extern</a></p> 
<p id="4.%E5%B8%B8%E8%A7%81%E5%85%B3%E9%94%AE%E5%AD%97-toc" style="margin-left:40px;"><a href="#4.%E5%B8%B8%E8%A7%81%E5%85%B3%E9%94%AE%E5%AD%97" rel="nofollow">4.常见关键字</a></p> 
<p id="1.assert-toc" style="margin-left:80px;"><a href="#1.assert" rel="nofollow">1.assert</a></p> 
<p id="2.const-toc" style="margin-left:80px;"><a href="#2.const" rel="nofollow">2.const</a></p> 
<p id="3.volatile-toc" style="margin-left:80px;"><a href="#3.volatile" rel="nofollow">3.volatile</a></p> 
<p id="4.sizeof-toc" style="margin-left:80px;"><a href="#4.sizeof" rel="nofollow">4.sizeof</a></p> 
<p id="5.typedef-toc" style="margin-left:80px;"><a href="#5.typedef" rel="nofollow">5.typedef</a></p> 
<p id="5.%E9%9D%A2%E8%AF%95%E9%A2%98-toc" style="margin-left:40px;"><a href="#5.%E9%9D%A2%E8%AF%95%E9%A2%98" rel="nofollow">5.面试题</a></p> 
<p id="1.extern%E4%B8%8Estatic%E5%8C%BA%E5%88%AB-toc" style="margin-left:80px;"><a href="#1.extern%E4%B8%8Estatic%E5%8C%BA%E5%88%AB" rel="nofollow">1.extern与static区别</a></p> 
<p id="2.C%20%E8%AF%AD%E8%A8%80%E7%9A%84%E5%85%B3%E9%94%AE%E5%AD%97%20static%20%E5%92%8C%20C%2B%2B%20%E7%9A%84%E5%85%B3%E9%94%AE%E5%AD%97%20static%20%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB-toc" style="margin-left:80px;"><a href="#2.C%20%E8%AF%AD%E8%A8%80%E7%9A%84%E5%85%B3%E9%94%AE%E5%AD%97%20static%20%E5%92%8C%20C%2B%2B%20%E7%9A%84%E5%85%B3%E9%94%AE%E5%AD%97%20static%20%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB" rel="nofollow">2.C 语言的关键字 static 和 C++ 的关键字 static 有什么区别</a></p> 
<p id="2.const%E5%92%8Cdefine%E7%9A%84%E5%8C%BA%E5%88%AB-toc" style="margin-left:80px;"><a href="#2.const%E5%92%8Cdefine%E7%9A%84%E5%8C%BA%E5%88%AB" rel="nofollow">2.const和define的区别</a></p> 
<p id="3.%23define%E5%92%8C%E5%88%AB%E5%90%8Dtypedef%E7%9A%84%E5%8C%BA%E5%88%AB-toc" style="margin-left:80px;"><a href="#3.%23define%E5%92%8C%E5%88%AB%E5%90%8Dtypedef%E7%9A%84%E5%8C%BA%E5%88%AB" rel="nofollow">3.#define和别名typedef的区别</a></p> 
<p id="4.%23include%20%E7%9A%84%E9%A1%BA%E5%BA%8F%E4%BB%A5%E5%8F%8A%E5%B0%96%E6%8B%AC%E5%8F%B7%E5%92%8C%E5%8F%8C%E5%BC%95%E5%8F%B7%E7%9A%84%E5%8C%BA%E5%88%AB-toc" style="margin-left:80px;"><a href="#4.%23include%20%E7%9A%84%E9%A1%BA%E5%BA%8F%E4%BB%A5%E5%8F%8A%E5%B0%96%E6%8B%AC%E5%8F%B7%E5%92%8C%E5%8F%8C%E5%BC%95%E5%8F%B7%E7%9A%84%E5%8C%BA%E5%88%AB" rel="nofollow">4.#include 的顺序以及尖括号和双引号的区别</a></p> 
<p id="cout%E6%98%AF%E6%9C%89%E7%BC%93%E5%86%B2%E8%BE%93%E5%87%BA%EF%BC%8C%E8%BE%93%E5%87%BA%E8%BF%87%E7%A8%8B%E4%BC%9A%E9%A6%96%E5%85%88%E5%B0%86%E8%BE%93%E5%87%BA%E5%AD%97%E7%AC%A6%E6%94%BE%E5%85%A5%E7%BC%93%E5%86%B2%E5%8C%BA%EF%BC%8C%E7%84%B6%E5%90%8E%E8%BE%93%E5%87%BA%E5%88%B0%E5%B1%8F%E5%B9%95%E3%80%82%20printf%E6%98%AF%E6%97%A0%E7%BC%93%E5%86%B2%E8%BE%93%E5%87%BA%EF%BC%8C%E6%9C%89%E8%BE%93%E5%87%BA%E6%97%B6%E7%AB%8B%E5%8D%B3%E8%BE%93%E5%87%BA%E3%80%82-toc" style="margin-left:80px;"><a href="#cout%E6%98%AF%E6%9C%89%E7%BC%93%E5%86%B2%E8%BE%93%E5%87%BA%EF%BC%8C%E8%BE%93%E5%87%BA%E8%BF%87%E7%A8%8B%E4%BC%9A%E9%A6%96%E5%85%88%E5%B0%86%E8%BE%93%E5%87%BA%E5%AD%97%E7%AC%A6%E6%94%BE%E5%85%A5%E7%BC%93%E5%86%B2%E5%8C%BA%EF%BC%8C%E7%84%B6%E5%90%8E%E8%BE%93%E5%87%BA%E5%88%B0%E5%B1%8F%E5%B9%95%E3%80%82%20printf%E6%98%AF%E6%97%A0%E7%BC%93%E5%86%B2%E8%BE%93%E5%87%BA%EF%BC%8C%E6%9C%89%E8%BE%93%E5%87%BA%E6%97%B6%E7%AB%8B%E5%8D%B3%E8%BE%93%E5%87%BA%E3%80%82" rel="nofollow">cout是有缓冲输出，输出过程会首先将输出字符放入缓冲区，然后输出到屏幕。 printf是无缓冲输出，有输出时立即输出。</a></p> 
<p id="5.%C2%A0strcpy%E5%87%BD%E6%95%B0%E5%92%8Cstrncpy%E5%87%BD%E6%95%B0%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F%E5%93%AA%E4%B8%AA%E5%87%BD%E6%95%B0%E6%9B%B4%E5%AE%89%E5%85%A8%EF%BC%9F-toc" style="margin-left:80px;"><a href="#5.%C2%A0strcpy%E5%87%BD%E6%95%B0%E5%92%8Cstrncpy%E5%87%BD%E6%95%B0%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F%E5%93%AA%E4%B8%AA%E5%87%BD%E6%95%B0%E6%9B%B4%E5%AE%89%E5%85%A8%EF%BC%9F" rel="nofollow">5. strcpy函数和strncpy函数的区别？哪个函数更安全？</a></p> 
<p id="%E4%BA%94%E3%80%81%E5%86%85%E5%AD%98-toc" style="margin-left:0px;"><a href="#%E4%BA%94%E3%80%81%E5%86%85%E5%AD%98" rel="nofollow">五、内存</a></p> 
<p id="1.%E5%86%85%E5%AD%98%E5%88%86%E5%8C%BA-toc" style="margin-left:40px;"><a href="#1.%E5%86%85%E5%AD%98%E5%88%86%E5%8C%BA" rel="nofollow">1.内存分区</a></p> 
<p id="2.%E9%9D%A2%E8%AF%95%E9%A2%98-toc" style="margin-left:40px;"><a href="#2.%E9%9D%A2%E8%AF%95%E9%A2%98" rel="nofollow">2.面试题</a></p> 
<p id="1.%20%E6%B7%B1%E6%8B%B7%E8%B4%9D%E4%B8%8E%E6%B5%85%E6%8B%B7%E8%B4%9D%EF%BC%9F-toc" style="margin-left:80px;"><a href="#1.%20%E6%B7%B1%E6%8B%B7%E8%B4%9D%E4%B8%8E%E6%B5%85%E6%8B%B7%E8%B4%9D%EF%BC%9F" rel="nofollow">1. 深拷贝与浅拷贝？</a></p> 
<p id="2..%20c%E5%92%8Cc%2B%2B%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F-toc" style="margin-left:80px;"><a href="#2..%20c%E5%92%8Cc%2B%2B%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F" rel="nofollow">2.. c和c++的区别？</a></p> 
<p id="3.%E5%A0%86%E4%B8%8E%E6%A0%88%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F-toc" style="margin-left:80px;"><a href="#3.%E5%A0%86%E4%B8%8E%E6%A0%88%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F" rel="nofollow">3.堆与栈的区别？</a></p> 
<p id="4.%C2%A0new%E5%92%8Cmalloc%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F-toc" style="margin-left:80px;"><a href="#4.%C2%A0new%E5%92%8Cmalloc%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F" rel="nofollow">4. new和malloc的区别？</a></p> 
<p id="5.%E8%AE%B2%E8%AE%B2%E5%A4%A7%E7%AB%AF%E5%B0%8F%E7%AB%AF-toc" style="margin-left:80px;"><a href="#5.%E8%AE%B2%E8%AE%B2%E5%A4%A7%E7%AB%AF%E5%B0%8F%E7%AB%AF" rel="nofollow">5.讲讲大端小端</a></p> 
<hr> 
<h2 id="%E4%B8%80%E3%80%81%E4%B8%BB%E8%A6%81%E7%9F%A5%E8%AF%86%E7%82%B9"><span style="color:#0d0016;">一、主要知识点</span></h2> 
<ul><li><span style="color:#0d0016;">指针：一级/二级指针，指针数组，数组指针，指针函数，函数指针</span></li><li><span style="color:#0d0016;">数组：一维/二维数组 排序等</span></li><li><span style="color:#0d0016;">字符串</span></li><li><span style="color:#0d0016;">关键字：#define assert const const static volatile extern sizeof typedef等</span></li><li><span style="color:#0d0016;">函数：strlen strcmp strstr memcpy sprintf等</span></li><li><span style="color:#0d0016;">内存：堆栈，内存分配 malloc/free 大小端</span></li><li><span style="color:#0d0016;">变量：变量类型/占用字节数，局部/全局/静态变量，形参/实参</span></li><li><span style="color:#0d0016;">结构：结构体，联合体，枚举类</span></li></ul> 
<h2 id="%C2%A0%E4%BA%8C%E3%80%81%E6%8C%87%E9%92%88"><span style="color:#0d0016;"> 二、指针</span></h2> 
<h3 id="1.%E5%AE%9A%E4%B9%89"><span style="color:#0d0016;">1.定义</span></h3> 
<p><span style="color:#0d0016;">在 C 语言中，<strong>内存单元的地址称为指针</strong>，专门用来存放地址的变量，称为指针变量，在不影响理解的情况中，有时对地址、指针和指针变量不区分，通称指针。</span></p> 
<p><span style="color:#0d0016;">一个指针在32位的计算机上，占4个字节；<br> 一个指针在64位的计算机上，占8个字节；</span></p> 
<p><span style="color:#0d0016;">一般形式如下：&lt; 存储类型 &gt; &lt; 数据类型 &gt; * &lt; 指针变量名 &gt; ; 例如， char *pName ;</span></p> 
<p><span style="color:#0d0016;">指针的存储类型是指针变量本身的存储类型。（32位系统为例，地址是32位的，并且地址是正整数，所以指针变量的数据类型是确定的，即unsigned int，无符号整形。因此在指针变量定义时，无需指出指针变量的数据类型。）<br> 指针说明时指定的数据类型不是指针变量本身的数据类型，而是<strong>指针目标的数据类型。简称为指针的数据类型。</strong></span></p> 
<h3 id="2.%E6%8C%87%E9%92%88%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96"><span style="color:#0d0016;">2.指针的初始化</span></h3> 
<p><span style="color:#0d0016;">指针在说明的同时， 也可以被赋予初值，称为指针的初始化。</span></p> 
<p><span style="color:#0d0016;">一般形式是：&lt; 存储类型 &gt; &lt; 数据类型 &gt; *&lt; 指针变量名 &gt; = &lt; 地址量 &gt; ;  例如： int a，*pa=&amp;a;</span></p> 
<p><span style="color:#0d0016;">设 px 为一个指针，则 :<br> px — 指针变量， 它的内容是<strong>地址量</strong><br> *px — 指针所指向的对象， 它的内容是<strong>数据</strong><br> &amp;px — 指针变量占用的存储区域的地址，是个<strong>常量</strong></span></p> 
<h3 id="3.%E6%8C%87%E9%92%88%E7%9A%84%E8%B5%8B%E5%80%BC"><span style="color:#0d0016;"><strong>3.指针的赋值</strong></span></h3> 
<p><span style="color:#0d0016;">指针的赋值运算指的是通过赋值运算符向指针变量送一个地址值，<strong>向一个指针变量赋值时，送的值必须是地址常量或指针变量</strong>，不能是普通的整数 ( 除了赋零以外 )。</span></p> 
<p><span style="color:#0d0016;">指针赋值运算常见的有以下几种形式 :<br> 1.把一个普通变量的地址赋给一个具有相同数据类型的指针 double x=15, *px;  px=&amp;x;</span></p> 
<p><span style="color:#0d0016;">2.把一个已有地址值的指针变量赋给具有相同数据类型的另一个指针变量 例如 :<br> float a, *px, *py;<br> px = &amp;a;<br> py = px;</span></p> 
<p><span style="color:#0d0016;">3.把一个数组的地址赋给具有相同数据类型的指针。例如 :<br> int a[20], *pa;<br> pa = a; // 等价 pa = &amp;a[0]</span></p> 
<h3 id="4.%E6%8C%87%E9%92%88%E7%9A%84%E8%BF%90%E7%AE%97"><span style="color:#0d0016;">4.指针的运算</span></h3> 
<p><span style="color:#0d0016;">指针运算是以指针变量所存放的地址量作为运算量而进行的运算，指针运算的实质就是<strong>地址的计算，</strong>指针运算的种类是有限的，它只能进行<strong>赋值运算、算术运算和关系运算</strong>。</span></p> 
<p><span style="color:#0d0016;">         <img alt="" height="179" src="https://images2.imgbox.com/26/65/RX7r8jd2_o.png" width="381"></span></p> 
<p><span style="color:#0d0016;">不同数据类型的两个指针实行加减整数运算是无意义的<br> px + n 表示的实际位置的地址量是：<strong>(px) + sizeof(px 的类型 ) * n</strong></span></p> 
<p><span style="color:#0d0016;">px-py 运算的结果值不是地址量，而是一个整数值，表示两指针之间相隔数据的个数。针相减</span></p> 
<p><span style="color:#0d0016;"><img alt="" height="227" src="https://images2.imgbox.com/5d/07/L1t7IMjz_o.png" width="471"></span></p> 
<h3 id="5.%E6%8C%87%E9%92%88%E4%B8%8E%E4%B8%80%E7%BB%B4%E6%95%B0%E7%BB%84"><span style="color:#0d0016;">5.指针与一维数组</span></h3> 
<p><span style="color:#0d0016;">在 C 语言中，数组的指针是指数组在内存中的起始地址，数组元素的地址是指数组元素在内存中的起始地址，<strong>一维数组的数组名为一维数组的指针（起始地址）</strong>。</span></p> 
<p><span style="color:#0d0016;">x[i] 、 *(px+i) 、 *(x+i) 和 px[i] 具有完全相同的功能：访问数组第 i+1 个数组元素。但指针变量和数组的指针（或叫数组名）在本质上不同，<strong>指针变量是地址变量，而数组的指针是地址常量</strong>。</span></p> 
<p><span style="color:#0d0016;">p++,p-- ( 对 )  <strong>a++,a-- ( 错 )</strong>  a+1, *(a+2) ( 对 )</span></p> 
<h3 id="6.%E6%8C%87%E9%92%88%E4%B8%8E%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84"><span style="color:#0d0016;">6.指针与二维数组</span></h3> 
<p><span style="color:#0d0016;">可把二维数组看作<strong>由多个一维数组组成</strong>。比如 int a[3][3] ，含有三个元素：a[0]、a[1] 、a[2]元素 a[0] 、a[1] 、a[2] 都是一维数组名。</span></p> 
<p><span style="color:#0d0016;">二维数组名代表数组的起始地址，数组名加1，是移动一行元素。因此，二维数组名常被称为行地址。a+1 等效于 a[1]，a+2 等效于 a[2]</span></p> 
<p><span style="color:#0d0016;">存储行地址的指针变量，叫做<strong>行指针变量</strong>。形式如下：<br> &lt; 存储类型 &gt; &lt; 数据类型 &gt; (*&lt; 指针变量名&gt;)[ 表达式 ] ;  例如，int a[2][3]; int (*p)[3];<br> 方括号中的常量表达式<strong>表示指针加 1 ，移动几个数据</strong>。(p+1 移动 3 个元素)</span></p> 
<h3 id="7.%E5%AD%97%E7%AC%A6%E6%8C%87%E9%92%88%E4%B8%8E%E5%AD%97%E7%AC%A6%E4%B8%B2"><span style="color:#0d0016;">7.字符指针与字符串</span></h3> 
<p><span style="color:#0d0016;">C语言通过使用字符数组来处理字符串，通常我们把<strong>char数据类型的指针变量称为字符指针变量</strong>。</span></p> 
<p><span style="color:#0d0016;">初始化字符指针是把内存中字符串的首地址赋予指针，并不是把该字符串复制到指针中<br> char str[] = “Hello World”;<br> char *p = str;<br> 在 C 编程中，当一个字符指针指向一个字符串常量时，不能修改指针指向的对象的值<br> char * p = “Hello World”;<br> *p = ‘h’; // 错误， 字符串常量不能修改</span></p> 
<h3 id="8.%E6%8C%87%E9%92%88%E6%95%B0%E7%BB%84"><span style="color:#0d0016;">8.指针数组</span></h3> 
<p><span style="color:#0d0016;">指针数组是指由若<strong>干个具有相同存储类型和数据类型的指针变量</strong>构成的集合<br> 指针数组的一般说明形式：&lt; 存储类型 &gt; &lt; 数据类型 &gt; *&lt; 指针数组名 &gt;[&lt; 大小 &gt;] ；<br> 指针数组名表示该指针数组的起始地址</span></p> 
<p><span style="color:#0d0016;">声明一个指针数组：double * pa[2] ，a[2][3];</span></p> 
<p><span style="color:#0d0016;">把一维数组 a[0] 和 a[1] 的首地址分别赋予指针变量，数组的数组元数 pa[0] 和 pa[1] ：<br> pa[0]=a[0] ; // 等价 pa[0] = &amp;a[0][0];<br> pa[1]=a[1]; // 等价 pa[1] = &amp;a[1][0];</span></p> 
<p><span style="color:#0d0016;"><img alt="" height="248" src="https://images2.imgbox.com/92/7b/CvXNExG2_o.png" width="341"></span></p> 
<h3 id="9.%E5%A4%9A%E7%BA%A7%E6%8C%87%E9%92%88"><span style="color:#0d0016;">9.多级指针</span></h3> 
<p><span style="color:#0d0016;">把一个指向指针变量的指针变量，称为多级指针变量，对于指向处理数据的指针变量称为一级指针变量，简称一级指针，而把指向一级指针变量的指针变量称为二级指针变量，简称二级指针<br> 二级指针变量的说明形式如下： &lt; 存储类型 &gt; &lt; 数据类型 &gt; ** &lt; 指针名 &gt;；</span></p> 
<p><span style="color:#0d0016;">多级指针变量加 1 ，是向地址大的方向移动一个目标数据。类似的道理，多级指针运算也是以其目标变量为单位进行偏移。比如， int **p ； p+1 移动一个 int * 变量所占的内存空间。再比如 int ***p ， p+1 移动一个 int ** 所占的内存空间。</span></p> 
<p><span style="color:#0d0016;">指针数组也可以用另外一个指针来处理。例如：有一个一维字符指针数组 ps[5] ，char *ps[5]= { "Beijing city" ,......, "London city" } ; char ** pps = ps;</span></p> 
<h3 id="10.void%E6%8C%87%E9%92%88"><span style="color:#0d0016;">10.void指针</span></h3> 
<p><span style="color:#0d0016;">void指针是一种不确定数据类型的指针变量，它可以通过<strong>强制类型转换让该变量指向任何数据类型的变量</strong>一般形式为： void * &lt; 指针变量名称 &gt; ;<br> 对于 void 指针，在没有强制类型转换之前，不能进行任何指针的算术运算</span></p> 
<h3 id="11.%E9%9D%A2%E8%AF%95%E9%A2%98"><span style="color:#0d0016;">11.面试题</span></h3> 
<h4 id="1.%E9%87%8E%E6%8C%87%E9%92%88%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F%E6%88%90%E5%9B%A0%E4%BB%A5%E5%8F%8A%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95%EF%BC%9F">1.野指针是什么？成因以及解决方法？</h4> 
<p>“野指针”的成因主要有3种：</p> 
<p>① 指针变量<strong>没有被初始化</strong>。任何指针变量刚被创建时不会自动成为NULL指针，它的缺省值是随机的，它会乱指一气。所以，指针变量在创建的同时应当被初始化，<strong>要么将指针设置为NULL，要么让它指向合法的内存</strong>。例如</p> 
<p>② 指针p被<strong>free或者delete之后，没有置为NULL</strong>；</p> 
<p>③ 指针操作<strong>超越了变量的作用范围</strong>：不要返回指向栈内存的指针或引用，因为栈内存在函数结束时会被释放。</p> 
<p>如何避免野指针：</p> 
<p>①将指针初始化为NULL。</p> 
<p>②用malloc分配内存 ：char * p = (char * )malloc(sizeof(char));</p> 
<p>③用已有合法的可访问的内存地址对指针初始化，指针用完后释放内存，将指针赋NULL。</p> 
<h4 id="2.%C2%A0%E6%82%AC%E7%A9%BA%E6%8C%87%E9%92%88%E5%92%8C%E9%87%8E%E6%8C%87%E9%92%88%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F">2. 悬空指针和野指针有什么区别？</h4> 
<ol><li> <p><strong>野指针</strong>：野指针是不确定其具体指向的指针，一般指那些未初始化的指针。</p> </li><li> <p><strong>悬空指针</strong>：一个指针的指向对象已经被删除，那么就成了悬空指针。</p> </li></ol> 
<h2 id="%E4%B8%89%E3%80%81%E6%95%B0%E7%BB%84%E5%92%8C%E5%AD%97%E7%AC%A6%E4%B8%B2"><span style="color:#0d0016;">三、数组和字符串</span></h2> 
<h3 id="1.%E4%B8%80%E7%BB%B4%E6%95%B0%E7%BB%84"><span style="color:#0d0016;">1.一维数组</span></h3> 
<p><span style="color:#0d0016;">所谓一维数组是指只有一个下标的数组。它在计算机的内存中是连续存储的。<br> C 语言中，一维数组的说明一般形式如下：&lt; 存储类型 &gt; &lt; 数据类型 &gt; &lt; 数组名 &gt;[&lt; 表达式 &gt;] ；</span></p> 
<p><span style="color:#0d0016;">注意事项：</span></p> 
<ol><li><span style="color:#0d0016;">C 语言对数组不作越界检查，使用时要注意 int a[5]; a[5] = 10</span></li><li><span style="color:#0d0016;">关于用变量定义数组维数 int i = 15; int a[i]；</span></li><li><span style="color:#0d0016;">数组必须先定义，后使用只能逐个引用数组元素，不能一次引用整个数组 int a[10] printf("%d", a); (X)</span></li><li><span style="color:#0d0016;">数组元素表示形式：数组名 [ 下标 ] 其中：下标可以是常量或整型表达式,</span></li><li><span style="color:#0d0016;">初始化方式：在定义数组时，为数组元素赋初值,数组不初始化，其元素值为随机数,对 static 数组元素不赋初值，系统会自动赋以 0 值, 只给部分数组元素赋初值，其余为0。<img alt="" height="252" src="https://images2.imgbox.com/3f/22/RF21FCuh_o.png" width="409"></span></li></ol> 
<h3 id="2.%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84"><span style="color:#0d0016;">2.二维数组</span></h3> 
<p><span style="color:#0d0016;">定义方式：（<strong>声明时列数不能省略，行数可以</strong>）<br> 数据类型 数组名 [ 常量表达式 ][ 常量表达式 ] ；</span></p> 
<p><span style="color:#0d0016;">内存是一维的-二维数组:按行序优先<br><img alt="" height="228" src="https://images2.imgbox.com/ad/b0/5elGAiNy_o.png" width="219"><img alt="" height="226" src="https://images2.imgbox.com/53/8f/pcW8HGih_o.png" width="425"><img alt="" height="237" src="https://images2.imgbox.com/d8/54/umbwwdDp_o.png" width="593"></span></p> 
<h3 id="3.%E5%AD%97%E7%AC%A6%E6%95%B0%E7%BB%84%E4%B8%8E%E5%AD%97%E7%AC%A6%E4%B8%B2"><span style="color:#0d0016;">3.字符数组与字符串</span></h3> 
<p><span style="color:#0d0016;">字符数组是元素的数据类型为字符类型的数组 char c[10], ch[3][4];<br> 字符数组的初始化<br> – 逐个字符赋值<br> – 用字符串常量</span></p> 
<p><span style="color:#0d0016;">C语言中无字符串变量，用字符数组处理字符串字符串结束标志:‘'\0’</span></p> 
<p><span style="color:#0d0016;"><img alt="" height="168" src="https://images2.imgbox.com/cd/7e/xPOwSzuI_o.png" width="427"></span></p> 
<p><span style="color:#0d0016;"><img alt="" height="246" src="https://images2.imgbox.com/d0/1e/MTZAQCEh_o.png" width="428"></span></p> 
<h3 id="4.%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%87%BD%E6%95%B0"><span style="color:#0d0016;">4.字符串函数</span></h3> 
<p><span style="color:#0d0016;">C 库中实现了很多字符串处理函数<br>  #include &lt;string.h&gt;<br> 几个常见的字符串处理函数<br> ① 求字符串长度的函数 strlen</span></p> 
<p><span style="color:#0d0016;">格式： strlen( 字符数组 )<br> 功能：计算字符串长度<br> 返值：<strong>返回字符串实际长度，不包括‘ \0’ 在内</strong><br> \xhh 表示十六进制数代表的符号<br> \ddd 表示 8 进制的<br> – 例：对于以下字符串， strlen(s) 的值为：<br> char s[10]={‘A’,‘\0’,‘B’,‘C’,‘\0’,‘D’};<br> char s[ ]=“\t\v\\\0will\n”;<br> char s[ ]=“\x69\141\n”;<br> 答案： 1 3 3</span></p> 
<p><br><span style="color:#0d0016;">② 字符串拷贝函数 strcpy</span></p> 
<p><span style="color:#0d0016;">格式： strcpy( 字符数组 1, 字符串 2)<br> 功能：将字符串 2 ，拷贝到字符数组 1 中去<br> 返值：返回字符数组 1 的首地址<br> 说明：字符数组 1 <strong>必须足够大，拷贝时‘ \0’ 一同拷贝</strong></span></p> 
<p><br><span style="color:#0d0016;">③ 字符串连接函数 strcat</span></p> 
<p><span style="color:#0d0016;">格式： strcat( 字符数组 1, 字符数组 2)<br> 功能：把字符数组 2 连到字符数组 1 后面<br> 返值：返回字符数组 1 的首地址<br> 说明：字符数组 1 必须足够大，连接前 , 两串均以‘ \0’ 结束 ; 连接后 , 串1 的 ‘ \0’ 取消 , 新串最后加‘ \0</span></p> 
<p><br><span style="color:#0d0016;">④ 字符串比较函数 strcmp</span></p> 
<p><span style="color:#0d0016;">格 式： strcmp( 字符串 1, 字符串 2)<br> 功 能：比较两个字符串<br> 比较规则：对两串从左向右逐个字符比较（ ASCII 码），直到遇到不同字符或‘ \0’ 为止<br> 返 值：返回 int 型整数<br> a. 若字符串 1&lt; 字符串 2 ， 返回负整数<br> b. 若字符串 1&gt; 字符串 2 ， 返回正整数<br> c. 若字符串 1== 字符串 2 ， 返回零</span></p> 
<p><span style="color:#0d0016;">字符串函数<br> strncpy(p, p1, n) 复制指定长度字符串<br> strncat(p, p1, n) 附加指定长度字符串<br> strcasecmp 忽略大小写比较字符串<br> strncmp(p, p1, n) 比较指定长度字符串<br> strchr(p, c) 在字符串中查找指定字符<br> strstr(p, p1) 查找字符串</span></p> 
<p><span style="color:#0d0016;">字符串函数<br> isalpha() 检查是否为字母字符<br> isupper() 检查是否为大写字母字符<br> islower() 检查是否为小写字母字符<br> isdigit() 检查是否为数字</span></p> 
<h3 id="5.%E9%9D%A2%E8%AF%95%E9%A2%98"><span style="color:#0d0016;">5.面试题</span></h3> 
<p></p> 
<h4 id="1.sizeof%E5%85%B3%E9%94%AE%E5%AD%97%E4%B8%8Estrlen%E5%87%BD%E6%95%B0%E7%9A%84%E5%8C%BA%E5%88%AB"><span style="color:#0d0016;">1.sizeof关键字与strlen函数的区别</span></h4> 
<p><span style="color:#0d0016;">Sizeof:编译器在<strong>编译时</strong>就计算出了sizeof的结果，而<strong>strlen函数必须在运行时</strong>才能计算出来。并且sizeof计算的是数据类型占内存的大小，而strlen计算的是字符串实际的长度<br> strlen只能测量字符串<strong>计算字符串 str 的长度，直到空结束字符</strong>，但不包括空结束字符</span></p> 
<h4 id="2.strcpy%E5%92%8Cmemcpy%E5%8C%BA%E5%88%AB"><span style="color:#0d0016;">2.strcpy和memcpy区别</span></h4> 
<p><span style="color:#0d0016;">1.复制的内容不同。<br> strcpy只能复制字符串，<br><strong>memcpy可以复制任意内容</strong>，例如字符数组、整型、结构体、类等。</span></p> 
<p><span style="color:#0d0016;">2.复制的方法不同。<br> strcpy不需要指定长度，遇到<strong>结束符"\0"才结束</strong>，如果空间不够，就会引起踩内存。<br> memcpy则是<strong>根据其第3个参数</strong>决定复制的长度。</span></p> 
<p><span style="color:#0d0016;">3.用途不同。<br> 通常在复制字符串时用strcpy，而需要复制其他类型数据时则一般用memcpy，由于字符串是以“\0”结尾的，所以<strong>对于在数据中包含“\0”的数据只能用memcpy</strong>。</span></p> 
<h2 id="%E5%9B%9B%E3%80%81%E5%85%B3%E9%94%AE%E5%AD%97"><span style="color:#0d0016;">四、关键字</span></h2> 
<h3 id="1.%E5%B8%B8%E9%87%8F" style="background-color:transparent;"><span style="color:#0d0016;">1.常量</span></h3> 
<p><span style="color:#0d0016;">常量是指在程序运行期间其数值不发生变化的数据。</span></p> 
<p><span style="color:#0d0016;">整型常量通常简称为整数。</span></p> 
<p><span style="color:#0d0016;">浮点常量又称为实数，一般含有小数部分。在 C 语言中，实数只有十进制的实数，分为单精度和<br> 双精度。实数有两种表示方法， 即一般形式和指数形式。指数形式的实数一般是由尾数部分、字母 e 或 E 和指数部分组成。 当一个实数的符号为正号时，可以省略不写，其表示的一般形式如下：– 1.176e+10 表示 1.176×1010  - 3.5789e-8 表示 -3.5789×10-8</span></p> 
<p><span style="color:#0d0016;">字符常量是指一个单一字符， 其表示形式是由两个单引号包括的一个字符。‘A’, ‘a’, ‘Q’, ‘0’, ‘9’, ‘+’,<br> ‘:’, ‘?’, ‘$’ 都是字符常量。在 C 语言中， 字符常量具有数值。字符常量的值就是该字符的 ASCII 码值。可以把字符常量看做一个字节的正整数。</span></p> 
<p><span style="color:#0d0016;">所谓字符串常量是指用双引号括起来的一串字符来表示的数据。(字符串以\0结尾）“9” ——'9'，'0'</span></p> 
<h4 id="1.%23define"><span style="color:#0d0016;">1.#define</span></h4> 
<p><span style="color:#0d0016;">所谓标识常量是指用标识符代替常量使用的一种常量 ，其名称通常是一个标识符。标识常量也叫符号常量，<strong>一般用大写英文字母</strong>的标识符。<br> 在使用之前必须预先定义。说明形式为：#define &lt; 标识常量名称 &gt; &lt; 常量 &gt;</span></p> 
<p><span style="color:#0d0016;">一个宏名字之后，可以在其他宏定义中使用 , 例如：<br> #define ONE 1<br> #define TWO ONE+ONE<br> #define THREE ONE+TWO (<strong>完全替换，不会计算出来为3</strong>，c = THREE * b + a —— c = ONE + TWO * b + a)<br> 如果一个串长于一行，可在行尾用反斜线” \” 续行</span></p> 
<h3 id="2.%E8%BF%90%E7%AE%97%E7%AC%A6" style="background-color:transparent;"><span style="color:#0d0016;">2.运算符</span></h3> 
<p><span style="color:#0d0016;"><img alt="" height="179" src="https://images2.imgbox.com/13/39/r26bd910_o.png" width="306"><img alt="" height="178" src="https://images2.imgbox.com/e8/14/xk9woCZo_o.png" width="345"></span></p> 
<p><span style="color:#0d0016;"><img alt="" height="126" src="https://images2.imgbox.com/1a/15/JrIxwPWi_o.png" width="308"><img alt="" height="177" src="https://images2.imgbox.com/46/d1/LYM2hx8x_o.png" width="322"></span></p> 
<p><span style="color:#0d0016;"><img alt="" height="191" src="https://images2.imgbox.com/57/8e/A9MJCusP_o.png" width="315"><img alt="" height="232" src="https://images2.imgbox.com/63/1f/boYcYRNo_o.png" width="342"></span></p> 
<h3 id="3.%E5%8F%98%E9%87%8F"><span style="color:#0d0016;">3.变量</span></h3> 
<p><span style="color:#0d0016;"><img alt="" height="272" src="https://images2.imgbox.com/69/28/OnQNd7C7_o.png" width="347"></span></p> 
<p></p> 
<ul><li><strong>char存储大小1字节</strong>，值范围-128~127；</li><li><strong>unsigned char存储大小1字节</strong>，值范围0~255；</li><li>short存储大小2字节，值范围-32768~32767；</li><li>unsigned short存储大小2字节，值范围0~65535；</li><li>int——</li></ul> 
<blockquote>
  16位系统存储大小2字节，值范围-32768~32767， 
 <br> 32、64位系统存储大小4字节，值范围-2147483648~2147483647； 
</blockquote> 
<ul><li>unsigned int——</li></ul> 
<blockquote>
  16位系统存储大小2字节，值范围0~65535， 
 <br> 32、64位系统存储大小4字节，值范围0~4294967295； 
</blockquote> 
<ul><li>long——</li></ul> 
<blockquote>
  16、32位系统存储大小4字节，值范围-2147483648~2147483647， 
 <br> 64位系统存储大小8字节，值范围-9223372036854775808~9223372036854775807； 
</blockquote> 
<ul><li>unsigned long——</li></ul> 
<blockquote>
  16、32位系统存储大小4字节，值范围0~4294967295， 
 <br> 64位系统存储大小8字节，值范围0~18446744073709551615； 
</blockquote> 
<ul><li>float存储大小4字节，值范围1.175494351*10^-38~3.402823466*10^38；</li><li>double存储大小8字节，值范围2.2250738585072014*10^-308~1.7976931348623158*10^308；</li><li>long long存储大小8字节，值范围-9223372036854775808~9223372036854775807；</li><li>unsigned long long存储大小8字节，值范围0~18446744073709551615；</li><li>long double——</li></ul> 
<blockquote>
  16位系统存储大小8字节，值范围2.22507*10^-308~1.79769*10^308， 
 <br> 32位系统存储大小12字节（有效位10字节，为了对齐实际分配12字节），值范围3.4*10^-4932 到 1.1*10^4932， 
 <br> 64位系统存储大小16字节（有效位10字节，为了对齐实际分配16字节），值范围3.4*10^-4932 到 1.1*10^4932； 
</blockquote> 
<ul><li>指针——</li></ul> 
<blockquote>
  16位系统存储大小2字节， 
 <br> 32位系统存储大小4字节， 
 <br> 64位系统存储大小8字节。 
</blockquote> 
<ol><li><span style="color:#0d0016;">变量在程序中用变量名表示。</span></li><li><span style="color:#0d0016;">变量名由字母、数字、下划线组成，不能以数字开头，不能和 C 的关键字重名。</span></li><li><span style="color:#0d0016;">在程序运行时，变量占据存储空间的大小由其数据类型决定。</span></li><li><span style="color:#0d0016;">变量在内存空间中的首地址，称为变量的地址。</span></li><li><span style="color:#0d0016;">变量说明的一般形式是：&lt; 存储类型 &gt; &lt; 数据类型 &gt; &lt; 变量名 &gt; ；<br> &lt; 存储类型 &gt; 是关键词 auto 、 register 、 static 和 extern</span></li></ol> 
<p>1.结构体</p> 
<p></p> 
<h4 id="1.auto"><span style="color:#0d0016;">1.auto </span></h4> 
<p><span style="color:#0d0016;">说明的变量只能在<strong>某个程序范围内使用</strong>，通常在<strong>函数体内或函数中的复合语句</strong>里。（默认是随机值）在函数体的某程序段内说明 auto 存储类型的变量时可以省略关键字 auto ，如下：<br> auto int k ; int j ; double x;</span></p> 
<h4 id="2.register"><span style="color:#0d0016;">2.register</span></h4> 
<p><span style="color:#0d0016;">称为寄存器型，register变量是<strong>想将变量放入CPU的寄存器中</strong>，这样可以<strong>加快程序的运行速度</strong>。如申请不到就使用一般内存，同auto ; register变量必须是<strong>能被CPU所接受的类型</strong>。这通常意味着register变量必须是一个单个的值，并且长度应该小于或者等于整型的长度。<strong>不能用“&amp;”来获取</strong>register变量的地址。由于寄存器的数量有限，真正起作用的register修饰符的数目和类型都依赖于运行程序的机器。<br> 在某些情况下，<strong>把变量保存在寄存器中反而会降低程序的运行速度</strong>。因为被占用的寄存器<strong>不能再用于其它目的</strong>；或者变量<strong>被使用的次数不够多</strong>，不足以装入和存储变量所带来的额外开销。</span></p> 
<h4 id="3.static" style="background-color:transparent;"><span style="color:#0d0016;">3.static</span></h4> 
<p><span style="color:#0d0016;">变量称为静态存储类型的变量，既可以在函数体内，也可在函数体外说明 ( 默认是 0 ）。<strong>局部变量使用 static 修饰</strong> , 有以下特点 ：<strong>在内存中以固定地址存放的，而不是以堆栈方式存放</strong>，只要程序没结束，就不会随着说明它的程序段的结束而消失，它下次再调用该函数，该存储类型的变量<strong>不再重新说明，而且还保留上次调用存入的数值</strong>。<br> static 修饰的全部变量，其它文件无法使用。</span></p> 
<h4 id="4.extern"><span style="color:#0d0016;">4.extern</span></h4> 
<p><span style="color:#0d0016;">当变量在一个文件中的函数体外说明，<strong>所有其他文件中</strong>的函数或程序段都可引用这个变量。extern 称为外部参照引用型，使用 extern 说明的变量是<strong>想引用在其它文件中函数体外部说明的变量</strong>。</span></p> 
<p><span style="color:#0d0016;">extern修饰变量的声明：<br> 如果文件a.c需要引用b.c中变量int v，就可以在a.c中声明extern int v，然后就可以引用变量v。</span></p> 
<p><span style="color:#0d0016;">extern修饰函数的声明：<br> 如果文件a.c需要引用b.c中的函数，比如在b.c中原型是int fun(int mu)，那么就可以在a.c中声明extern int fun（int mu），然后就能使用fun来做任何事情。就像变量的声明一样，<strong>extern int fun（int mu）可以放在a.c中任何地方</strong>，而不一定非要放在a.c的文件作用域的范围中。</span></p> 
<p><span style="color:#0d0016;">extern修饰符可用于指示C或者C＋＋函数的调用规范：<br> 比如在C＋＋中调用C库函数，就需要<strong>在C＋＋程序中用extern “C”声明要引用的函数</strong>。这是给链接器用的，告诉链接器在链接的时候用C函数规范来链接。主要原因是C＋＋和C程序编译完成后在目标代码中命名规则不同。</span><br>  </p> 
<h3 id="4.%E5%B8%B8%E8%A7%81%E5%85%B3%E9%94%AE%E5%AD%97"><span style="color:#0d0016;">4.常见关键字</span></h3> 
<h4 id="1.assert"><span style="color:#0d0016;">1.assert </span></h4> 
<p><span style="color:#0d0016;">assert宏的原型定义在&lt;assert.h&gt;中，其作用是如果它的条件返回错误，则终止程序执行，原型定义：</span></p> 
<pre><span style="color:#0d0016;">#include &lt;assert.h&gt;
void assert( int expression );</span></pre> 
<p><span style="color:#0d0016;">assert的作用是现计算表达式 <strong>expression ，如果其值为假（即为0），那么它先向stderr打印一条出错信息，然后通过调用 abort 来终止程序运行</strong>。</span></p> 
<p><span style="color:#0d0016;">C 语言库函数 abort 函数的作用是异常终止一个进程，意味着 abort 后面的代码将不再执行。<br> abort 函数是一个比较严重的函数，当调用它时，会导致程序异常终止，而不会进行一些常规的清除工作，比如释放内存等。</span></p> 
<p><span style="color:#0d0016;">例如参数传入一个指针为NULL时，程序就会奔溃时，我们可以增加assert来防御这种问题。</span></p> 
<h4 id="2.const"><span style="color:#0d0016;">2.const</span></h4> 
<p><span style="color:#0d0016;">阻止一个变量被改变，可以使用const关键字。</span></p> 
<p><span style="color:#0d0016;">1.const变量 （常量化变量）</span></p> 
<p><span style="color:#0d0016;">一般说明形式如下：const &lt; 数据类型 &gt; 变量名 = [&lt; 表达式 &gt;] ;<br> 常量化变量是为了使得变量的值不能修改，变量有 const 修饰时，若想用<strong>指针间接访问变量，指针也要有 const 修饰</strong>。</span></p> 
<hr> 
<p><span style="color:#0d0016;">2.const修饰指针</span></p> 
<p><span style="color:#0d0016;">（常量化指针目标表达式）</span></p> 
<p><span style="color:#0d0016;">一般说明形式如下：const &lt; 数据类型 &gt; * &lt; 指针变量名称 &gt; = [&lt; 指针运算表达式&gt;] ;<br> 常量化指针目标是<strong>限制通过指针改变其目标的数值</strong> ，但 &lt; 指针变量 &gt; 存储的地址值可以修改。</span></p> 
<p><span style="color:#0d0016;">（常量化指针变量）</span></p> 
<p><span style="color:#0d0016;">一般说明形式如下： &lt; 数据类型 &gt; * const &lt; 指针变量名称 &gt; = [&lt; 指针运算表达式&gt;] ;<br> 使得 <strong>&lt; 指针变量 &gt; 存储的地址值不能修改</strong>。但可以通过 *&lt; 指针变量名称 &gt; 可以修改指针所指向变量的数值。</span></p> 
<p><span style="color:#0d0016;">（常量化指针变量及其目标表达式）</span></p> 
<p><span style="color:#0d0016;">一般说明形式如下：<br> const &lt; 数据类型 &gt; * const &lt; 指针变量名 &gt; = &lt;指针运算表达式 &gt; ;<br> 常量化指针变量及其目标表达式，使得既不可以修改 &lt;指针变量 &gt; 的地址，也不可以通过 *&lt; 指针变量名称 &gt;修改指针所指向变量的值。</span></p> 
<p><span style="color:#0d0016;"><strong>const修饰谁 谁不能修改。</strong></span></p> 
<hr> 
<p><span style="color:#0d0016;">3.const修饰形参</span></p> 
<p><span style="color:#0d0016;">表明它是一个输入参数，在函数内部不能改变其值</span></p> 
<p><span style="color:#0d0016;">在引用或指针传递函数调用中，const 保护了实参所指向的变量。因为在编译阶段编译器对调用函数的选择是根据实参进行的，所以，只有<strong>引用传递和指针传递可以用是否加const来重载</strong>。</span></p> 
<h4 id="3.volatile"><span style="color:#0d0016;">3.volatile</span></h4> 
<p><span style="color:#0d0016;"><strong>volatile 关键字是一种类型修饰符</strong>，用它声明的类型变量表示可以被某些编译器未知的因素更改。volatile 提醒编译器它后面所定义的变量随时都有可能改变，因此编译后的程序每次需要存储或读取这个变量的时候，都会<strong>直接从变量地址中读取数据</strong>。如果没有 volatile 关键字，则编译器可能优化读取和存储，可能暂时使用寄存器中的值，如果这个变量由别的程序更新了的话，将出现不一致的现象。所以<strong>遇到这个关键字声明的变量，编译器对访问该变量的代码就不再进行优化，从而可以提供对特殊地址的稳定访问</strong>。</span></p> 
<h4 id="4.sizeof"><span style="color:#0d0016;">4.sizeof</span></h4> 
<p><span style="color:#0d0016;">sizeof运算符，运算的一般形式:sizeof(&lt;类型或变量名&gt;) 注意∶它只针对数据类型，而不针对变量!</span></p> 
<p><span style="color:#0d0016;">C/C++中，sizeof()只是运算符号，<strong>是编译的时候确定大小的</strong>。动态分配是运行过程中得到大小的，也就是说C++中new出来的内存，sizeof都无法统计的，退一步说，即使是new出来的空间也有可能失败，所以<strong>sizeof无法统计动态分配的内存大小</strong>。</span></p> 
<h4 id="5.typedef"><span style="color:#0d0016;">5.typedef</span></h4> 
<p><span style="color:#0d0016;">C 语言提供了 <strong>typedef</strong> 关键字，您可以使用它来为类型取一个新的名字。下面的实例为单字节数字定义了一个术语 <strong>BYTE</strong>：</span></p> 
<pre><span style="color:#0d0016;">typedef unsigned char BYTE;</span></pre> 
<p><span style="color:#0d0016;">在这个类型定义之后，标识符 BYTE 可作为类型 <strong>unsigned char</strong> 的缩写，例如：</span></p> 
<pre><span style="color:#0d0016;">BYTE  b1, b2;</span></pre> 
<h3><span style="color:#0d0016;">5.面试题</span></h3> 
<h4 id="1.extern%E4%B8%8Estatic%E5%8C%BA%E5%88%AB" style="background-color:transparent;"><span style="color:#0d0016;">1.extern与static区别</span></h4> 
<p><span style="color:#0d0016;">static：<br> 作用于局部变量时：叫静态局部变量，在函数调用时，只有在该<strong>函数第一次调用时才对其分配空间和初始化</strong>。在函数<strong>调用结束时</strong>，不对该变量的内存进行释放，<strong>值仍然保留</strong>。这也是于auto自动变量的区别。<br> 作用于全局变量时： 叫静态全局变量。表示<strong>该变量是私有的，只能在该文件使用</strong>。不能通过extern关键字对其引用。<br> 作用于函数时： 叫静态函数，表示<strong>该函数是私有的，只能在本文件中使用</strong>，不能通过extern关键字对其引用</span></p> 
<p><span style="color:#0d0016;">extern：<br> 本文件： 定义在本文件<strong>下面的全局变量</strong>，<strong>想要在上面使用</strong>时需要使用extern关键字对其声明<br> 其他文件：定义在<strong>其他文件</strong>的全局变量<strong>想要在本文件使用</strong>时，若该变量未被static修饰时可通过extern关键字<strong>在本文件对其声明</strong>。即可使用</span></p> 
<h4 id="2.C%20%E8%AF%AD%E8%A8%80%E7%9A%84%E5%85%B3%E9%94%AE%E5%AD%97%20static%20%E5%92%8C%20C%2B%2B%20%E7%9A%84%E5%85%B3%E9%94%AE%E5%AD%97%20static%20%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB"><span style="color:#0d0016;">2.C 语言的关键字 static 和 C++ 的关键字 static 有什么区别</span></h4> 
<p><span style="color:#0d0016;">在C中static用来修饰局部静态变量和外部静态变量、函数。而C++中除了上述功能外,还用来<strong>定义类的成员变量和函数</strong>。即静态成员和静态成员函数。</span></p> 
<p><span style="color:#0d0016;">注意:编程时static的记忆性,和全局性的特点可以让在<strong>不同时期调用的函数进行通信</strong>,传递信息,而C++的<strong>静态成员则可以在多个对象实例间</strong>进行通信,传递信息。</span></p> 
<h4 id="2.const%E5%92%8Cdefine%E7%9A%84%E5%8C%BA%E5%88%AB"><span style="color:#0d0016;">2.const和define的区别</span></h4> 
<p><span style="color:#0d0016;">1.编译器处理方式<br> define – 在<strong>预处理阶段</strong>进行替换<br> const – 在<strong>编译时</strong>确定其值</span></p> 
<p><span style="color:#0d0016;">2.类型检查<br> define – 无类型，<strong>不进行类型安全检查，可能会产生意想不到的错误</strong><br> const – 有数据类型，编译时会进行类型检查</span></p> 
<p><span style="color:#0d0016;">3.内存空间<br> define – 不分配内存，给出的是立即数，有多少次使用就进行多少次替换，<strong>在内存中会有多个拷贝，消耗内存大</strong><br> const – 在静态存储区中分配空间，在程序运行过程中内存中<strong>只有一个拷贝</strong></span></p> 
<p><span style="color:#0d0016;">4.其他<br> 宏只作替换，不做计算，不做表达式求解。</span></p> 
<p>5.const不能重定义，而define可以通过<code>#undef</code>取消某个符号的定义，<strong>进行重定义</strong>；</p> 
<p><span style="color:#0d0016;">总结<br><strong>const比define安全</strong></span></p> 
<h4 id="3.%23define%E5%92%8C%E5%88%AB%E5%90%8Dtypedef%E7%9A%84%E5%8C%BA%E5%88%AB">3.#define和别名typedef的区别</h4> 
<p>执行时间不同，typedef在编译阶段有效，typedef有<strong>类型检查</strong>的功能；#define是宏定义，发生在预处理阶段，<strong>不进行类型检查</strong>；</p> 
<p>功能差异，typedef用来定义一种数据类型的<strong>别名</strong>，定义与平台无关的数据类型，与struct的结合使用等。#define不只是可以为类型取别名，<strong>还可以定义常量、变量</strong>、编译开关等。</p> 
<p>作用域不同，<strong>#define没有作用域的限制</strong>，只要是之前预定义过的宏，在以后的程序中都可以使用。而typedef有自己的作用域。</p> 
<h4 id="4.%23include%20%E7%9A%84%E9%A1%BA%E5%BA%8F%E4%BB%A5%E5%8F%8A%E5%B0%96%E6%8B%AC%E5%8F%B7%E5%92%8C%E5%8F%8C%E5%BC%95%E5%8F%B7%E7%9A%84%E5%8C%BA%E5%88%AB">4.#include 的顺序以及尖括号和双引号的区别</h4> 
<p>尖括号表示编译器只在<strong>系统默认目录</strong>或尖括号内的工作目录下搜索头文件，并不去用户的工作目录下寻找，所以一般尖括号用于包含<strong>标准库文件</strong>；</p> 
<p>双引号表示编译器先在<strong>用户的工作目录</strong>下搜索头文件，如果搜索不到则到系统默认目录下去寻找，所以双引号一般用于包含<strong>用户自己编写的头文件</strong>。</p> 
<p>5.cout和printf有什么区别？</p> 
<p>cout&lt;&lt;是一个<strong>函数</strong>，cout&lt;&lt;后可以跟不同的类型是因为cout&lt;&lt;已存在针对各种类型数据的重载，所以会<strong>自动识别数据的类型</strong>。</p> 
<p>printf没有类型检查，不安全。cout是通过<strong>运算符重载实现的，安全</strong>。</p> 
<p>printf是函数。cout是ostream对象，和&lt;&lt;配合使用。</p> 
<h4 id="cout%E6%98%AF%E6%9C%89%E7%BC%93%E5%86%B2%E8%BE%93%E5%87%BA%EF%BC%8C%E8%BE%93%E5%87%BA%E8%BF%87%E7%A8%8B%E4%BC%9A%E9%A6%96%E5%85%88%E5%B0%86%E8%BE%93%E5%87%BA%E5%AD%97%E7%AC%A6%E6%94%BE%E5%85%A5%E7%BC%93%E5%86%B2%E5%8C%BA%EF%BC%8C%E7%84%B6%E5%90%8E%E8%BE%93%E5%87%BA%E5%88%B0%E5%B1%8F%E5%B9%95%E3%80%82%20printf%E6%98%AF%E6%97%A0%E7%BC%93%E5%86%B2%E8%BE%93%E5%87%BA%EF%BC%8C%E6%9C%89%E8%BE%93%E5%87%BA%E6%97%B6%E7%AB%8B%E5%8D%B3%E8%BE%93%E5%87%BA%E3%80%82">cout是<strong>有缓冲输出</strong>，输出过程会首先将输出字符放入缓冲区，然后输出到屏幕。 printf是<strong>无缓冲输出，有输出时立即输出</strong>。<br>  </h4> 
<h4 id="5.%C2%A0strcpy%E5%87%BD%E6%95%B0%E5%92%8Cstrncpy%E5%87%BD%E6%95%B0%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F%E5%93%AA%E4%B8%AA%E5%87%BD%E6%95%B0%E6%9B%B4%E5%AE%89%E5%85%A8%EF%BC%9F">5. strcpy函数和strncpy函数的区别？哪个函数更安全？</h4> 
<p>char* strcpy(char* strDest, const char* strSrc)<br> char* strncpy(char* strDest, const char* strSrc, int pos)</p> 
<p>strcpy函数: 如果参数 dest 所指的内存空间不够大，<strong>可能会造成缓冲溢出</strong>(buffer Overflow)的错误情况，在编写程序时请特别留意，或者用strncpy()来取代。</p> 
<p>strncpy函数：用来复制源字符串的前n个字符，src 和 dest 所指的内存区域不能重叠，且 dest 必须有足够的空间放置n个字符</p> 
<h2 id="%E4%BA%94%E3%80%81%E5%86%85%E5%AD%98"><span style="color:#0d0016;">五、内存</span></h2> 
<h3 id="1.%E5%86%85%E5%AD%98%E5%88%86%E5%8C%BA"><span style="color:#0d0016;">1.内存分区</span></h3> 
<p><span style="color:#0d0016;"><img alt="" height="419" src="https://images2.imgbox.com/4a/c7/A2PH2Hu4_o.png" width="842"></span></p> 
<p><span style="color:#0d0016;">内存总共分为五大分区：栈区（</span>函数的参数值，局部变量<span style="color:#0d0016;">），堆区（</span><code>new</code>或<code>malloc</code>出来的对象<span style="color:#0d0016;">），全局静态区（全局、静态变量），常量文本区，程序代码区（存放程序体的二进制代码）。</span></p> 
<p><span style="color:#0d0016;">从生存周期来说：</span></p> 
<ol><li><span style="color:#0d0016;">栈区是<strong>运行时分配，结束就释放</strong>。（类似数据结构中的栈）</span></li><li><span style="color:#0d0016;">堆区是程序员<strong>主动分配和释放</strong>。（类似数据结构中的链表）</span></li><li><span style="color:#0d0016;">全局静态区是<strong>程序运行前分配，程序结束释放</strong>。</span>初始化的全局变量和静态变量在一块区域，未初始化的全局变量和未初始化的静态变量在相邻的另一块区域。</li><li><span style="color:#0d0016;">常量文本区也是<strong>程序运行前分配，程序结束释放</strong></span></li></ol> 
<p><span style="color:#0d0016;">从管理角度来说：只有堆区是由程序员自己来管理，其他四个区都是由系统来管理的。<br> 从可能产生的问题来说：</span></p> 
<ol><li><span style="color:#0d0016;">栈区可能会造成<strong>栈溢出</strong>(1、<strong>深度递归</strong>，栈帧太多 2、<strong>只分配不释放</strong>，栈耗尽)。</span></li><li><span style="color:#0d0016;">堆区可能造成<strong>内存泄漏</strong>(就是申请空间，然后<strong>忘记释放</strong>了)，<strong>野指针</strong>（指向了一块已经被释放的空间），内存碎片。</span></li></ol> 
<p><span style="color:#0d0016;">从效率来说：<strong>栈区比堆区效率高</strong></span></p> 
<p><span style="color:#0d0016;">从内存大小来说：栈区大小m，堆区大小和内存有关。最大可1G。其他三个区都很小</span><br>  </p> 
<h3 id="2.%E9%9D%A2%E8%AF%95%E9%A2%98">2.面试题</h3> 
<h4 id="1.%20%E6%B7%B1%E6%8B%B7%E8%B4%9D%E4%B8%8E%E6%B5%85%E6%8B%B7%E8%B4%9D%EF%BC%9F">1. 深拷贝与浅拷贝？</h4> 
<p>浅拷贝 —<strong>仅仅是指向被复制的内存地址</strong>，如果原地址中对象被改变了，那么浅复制出来的对象也会相应改变。</p> 
<p>深拷贝 —-在计算机中<strong>开辟了一块新的内存地址</strong>用于存放复制的对象。</p> 
<p>浅拷贝在多个对象指向一块空间的时候，释放一个空间会导致其他对象所使用的空间也被释放了，再次释放便会出现错误。</p> 
<h4 id="2..%20c%E5%92%8Cc%2B%2B%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F">2.. c和c++的区别？</h4> 
<ol><li>C是面向过程，C++是面向对象的。</li><li>C通过malloc和free来进行堆内存的分配和释放，而C++除此之外<strong>还有new/delete</strong>关键字；</li><li>C++的类是C所没有的，但是C中的struct是可以在C++中正常使用的，并且<strong>C++对struct进行了进一步的扩展，使struct在C++中可以和class一样当做类</strong>使用，而唯一和class不同的地方在于<strong>struct的成员默认访问修饰符是public,而class默认的是private</strong>;</li><li><strong>C++支持函数重载，而C不支持函数重载</strong>，而C++支持重载的依仗就在于C++的名字修饰与C不同，例如在C++中函数int fun(int ,int)经过名字修饰之后变为<strong> _fun_int_int</strong> ,而C是 <strong>_fun（与参数无关）</strong>，所以C++才会支持不同的参数调用不同的函数；</li><li><strong>C++中有引用，而C没有</strong>；</li><li>当然还有C++全部变量的默认链接属性是<strong>外链接</strong>，而C是内连接；</li><li>C 中用const修饰的变量不可以用在定义数组时的大小，但是C++用const修饰的变量可以（如果不进行&amp;,解引用的操作的话，是存放在符号表的，不开辟内存）；</li><li>强制类型转换上也不一样，<strong>C的强制类型转换使用()小括号里面加类型进行类型强转的</strong>，而C++有四种自己的类型强转方式，分别是const_cast，static_cast，reinterpret_cast和dynamic_cast；</li><li>由于C++多了一个类，因此和C语言的作用域比起来，就多了一个类作用域，此外，C++还支持<strong>namespace名字空间</strong>，可以让用户自己定义新的名字空间作用域出来，<strong>避免全局的名字冲突问题</strong>。</li></ol> 
<h4 id="3.%E5%A0%86%E4%B8%8E%E6%A0%88%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F">3.堆与栈的区别？</h4> 
<p>管理方式：对于栈来讲，是由编译器自动管理，无需我们手工控制；对于堆来说，释放工作由程序员控制，<strong>容易产生内存泄漏</strong>。</p> 
<p>空间大小：一般来讲在32位系统下，堆内存可以达到4G的空间，从这个角度来看堆内存几乎是没有什么限制的。但是对于<strong>栈来讲，一般都是有一定的空间大小的</strong>。</p> 
<p>碎片问题：对于堆来讲，频繁的new/delete势必会造成内存<strong>空间的不连续，从而造成大量的碎片，使程序效率降低</strong>。对于栈来讲，则不会存在这个问题，因为<strong>栈是先进后出的队列</strong>，不可能有一个内存块从栈中间弹出，在他弹出之前，在他上面的后进的栈内容已经被弹出。</p> 
<p>生长方向：对于堆来讲，生长方向是向上的，也就是向着<strong>内存地址增加</strong>的方向；对于栈来讲，它的生长方向是向下的，是向着<strong>内存地址减小</strong>的方向增长。</p> 
<p>分配方式：堆都是动态分配的，没有静态分配的堆。<strong>栈有2种分配方式：静态分配和动态分配</strong>。静态分配是编译器完成的，比如局部变量的分配。动态分配由<strong>alloca()函数</strong>进行分配，但是<strong>栈的动态分配和堆是不同的，它的动态分配是由编译器进行释放</strong>，无需我们手工实现。</p> 
<p>分配效率：<br> 栈是<strong>机器系统</strong>提供的数据结构，计算机会在底层对栈提供支持：分配专门的寄存器存放栈的地址，压栈出栈都有专门的指令执行，这就决定了<strong>栈的效率比较高</strong>。<br> 堆则是<strong>C/C++函数库</strong>提供的，它的机制是很复杂的，例如为了分配一块内存，库函数会按照一定的算法在堆内存中搜索可用的足够大小的空间，如果没有足够大小的空间（可能是由于内存碎片太多），就有可能调用系统功能去增加程序数据段的内存空间，这样就有机会分到足够大小的内存，然后进行返回。显然，堆的效率比栈要低得多。</p> 
<h4 id="4.%C2%A0new%E5%92%8Cmalloc%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F"><br> 4. new和malloc的区别？</h4> 
<ol><li>new/delete是<strong>C++关键字，需要编译器</strong>支持。malloc/free是库函数，需要<strong>头文件支持</strong>；</li><li>使用<strong>new</strong>操作符申请内存分配时无须指定内存块的大小，编译器会根据类型信息自行计算。而<strong>malloc则需要显式地指出</strong>所需内存的大小。</li><li>new操作符内存分配成功时，返回的是对象类型的<strong>指针</strong>，类型严格与对象匹配，无须进行类型转换，故new是<strong>符合类型安全性</strong>的操作符。而malloc内存分配成功则是返回void * ，需要<strong>通过强制类型转换将void*指针转换成我们需要的类型</strong>。</li><li>在使用new分配内存空间时，内存空间不够时会抛出bac_alloc异常。malloc分配内存失败时返回NULL。</li><li>new会先调用operator new函数，申请足够的内存（通常底层使用malloc实现），然后调用类型的构造函数，初始化成员变量，最后返回自定义类型指针。<strong>delete先调用析构函数</strong>，然后调用operator delete函数释放内存（通常底层使用free实现）。</li><li>malloc/free是库函数，<strong>只能动态的申请和释放</strong>内存，无法强制要求其<strong>做自定义类型对象</strong>构造和析构工作。</li></ol> 
<h4 id="5.%E8%AE%B2%E8%AE%B2%E5%A4%A7%E7%AB%AF%E5%B0%8F%E7%AB%AF">5.讲讲大端小端</h4> 
<p>大端模式：是指数据的<strong>高字节保存在内存的低地址</strong>中，⽽数据的低字节保存在内存的高地址端。</p> 
<p>小端模式，是指数据的高字节保存在内存的高地址中，低位字节保存在在内存的低地址端。</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/8cde55f6a3b7e9bc7c93313a9b7e8594/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">深信服安全服务认证（SCSA-S）学习笔记：第一章 网络安全基础</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/7d32e09f46b399f549db100356a2abd4/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">【PX4】解决Resource not found: px4问题【踩坑实录】</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>