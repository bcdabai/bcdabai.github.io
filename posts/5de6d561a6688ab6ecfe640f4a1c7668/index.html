<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Dijkstra算法求无向带权图最短路径——Java - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Dijkstra算法求无向带权图最短路径——Java" />
<meta property="og:description" content="Dijkstra(迪杰斯特拉)算法是典型的最短路径路由算法，用于计算一个节点到其他所有节点的最短路径。主要特点是以起始点为中心向外层层扩展，直到扩展到终点为止。 Dijkstra算法采用的是贪心算法的策略，在整个算法过程中一直要维护两个表，这两个表分别表示尚未遍历的结点和已遍历的结点。大概过程如下：
声明两个集合，open和close，open用于存储未遍历的节点，close用来存储已遍历的节点；初始阶段，将初始节点放入close，其他所有节点放入open；以初始节点为中心向外一层层遍历，获取离指定节点最近的子节点放入close并从新计算路径，直至close包含所有子节点。 我在Intellij IDEA中实现了此算法，与BFS算法一样，首先我们需要构建一个图进行测试。在这里，我构建如下图：
以下为构建代码，首先创建Node对象用于封装图中的vertex结点信息，它包括结点的名字和子结点，子结点就是与之相邻的所有结点。
public class Node { private String name; private Map&lt;Node,Integer&gt; child=new HashMap&lt;&gt;(); public Node(String name){ this.name=name; } public String getName() { return name; } public void setName(String name) { this.name = name; } public Map&lt;Node, Integer&gt; getChild() { return child; } public void setChild(Map&lt;Node, Integer&gt; child) { this.child = child; } } 其中自动生成了constructor、getter和setter方法，方便进行结点操作。
MapBuilder用于初始化数据源，返回图的起始节点。
public class MapBuilder { public Node build(Set&lt;Node&gt; open, Set&lt;Node&gt; close){ Node nodeA=new Node(&#34;" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/5de6d561a6688ab6ecfe640f4a1c7668/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2018-04-23T14:04:01+08:00" />
<meta property="article:modified_time" content="2018-04-23T14:04:01+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Dijkstra算法求无向带权图最短路径——Java</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p>Dijkstra(迪杰斯特拉)算法是典型的最短路径路由算法，用于计算一个节点到其他所有节点的最短路径。主要特点是以起始点为中心向外层层扩展，直到扩展到终点为止。 <br> 
 </p> 
<p>Dijkstra算法采用的是贪心算法的策略，在整个算法过程中一直要维护两个表，这两个表分别表示尚未遍历的结点和已遍历的结点。大概过程如下：</p> 
<ol><li>声明两个集合，open和close，open用于存储未遍历的节点，close用来存储已遍历的节点；</li><li>初始阶段，将初始节点放入close，其他所有节点放入open；</li><li>以初始节点为中心向外一层层遍历，获取离指定节点最近的子节点放入close并从新计算路径，直至close包含所有子节点。</li></ol> 
<p>我在Intellij IDEA中实现了此算法，与BFS算法一样，首先我们需要构建一个图进行测试。在这里，我构建如下图：</p> 
<p><img src="https://images2.imgbox.com/7f/46/zbjGEeBc_o.jpg" alt="这里写图片描述" title=""> <br> 以下为构建代码，首先创建Node对象用于封装图中的vertex结点信息，它包括结点的名字和子结点，子结点就是与之相邻的所有结点。</p> 
<pre class="prettyprint"><code class="language-java hljs "><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Node</span> {<!-- --></span>
    <span class="hljs-keyword">private</span> String name;
    <span class="hljs-keyword">private</span> Map&lt;Node,Integer&gt; child=<span class="hljs-keyword">new</span> HashMap&lt;&gt;();
    <span class="hljs-keyword">public</span> <span class="hljs-title">Node</span>(String name){
        <span class="hljs-keyword">this</span>.name=name;
    }
    <span class="hljs-keyword">public</span> String <span class="hljs-title">getName</span>() {
        <span class="hljs-keyword">return</span> name;
    }
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setName</span>(String name) {
        <span class="hljs-keyword">this</span>.name = name;
    }
    <span class="hljs-keyword">public</span> Map&lt;Node, Integer&gt; <span class="hljs-title">getChild</span>() {
        <span class="hljs-keyword">return</span> child;
    }
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setChild</span>(Map&lt;Node, Integer&gt; child) {
        <span class="hljs-keyword">this</span>.child = child;
    }
}</code></pre> 
<p>其中自动生成了constructor、getter和setter方法，方便进行结点操作。</p> 
<p>MapBuilder用于初始化数据源，返回图的起始节点。</p> 
<pre class="prettyprint"><code class="language-java hljs "><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MapBuilder</span> {<!-- --></span>
    <span class="hljs-keyword">public</span> Node <span class="hljs-title">build</span>(Set&lt;Node&gt; open, Set&lt;Node&gt; close){
        Node nodeA=<span class="hljs-keyword">new</span> Node(<span class="hljs-string">"A"</span>);
        Node nodeB=<span class="hljs-keyword">new</span> Node(<span class="hljs-string">"B"</span>);
        Node nodeC=<span class="hljs-keyword">new</span> Node(<span class="hljs-string">"C"</span>);
        Node nodeD=<span class="hljs-keyword">new</span> Node(<span class="hljs-string">"D"</span>);
        Node nodeE=<span class="hljs-keyword">new</span> Node(<span class="hljs-string">"E"</span>);
        Node nodeF=<span class="hljs-keyword">new</span> Node(<span class="hljs-string">"F"</span>);
        Node nodeG=<span class="hljs-keyword">new</span> Node(<span class="hljs-string">"G"</span>);
        Node nodeH=<span class="hljs-keyword">new</span> Node(<span class="hljs-string">"H"</span>);
        nodeA.getChild().put(nodeB, <span class="hljs-number">1</span>);
        nodeA.getChild().put(nodeC, <span class="hljs-number">1</span>);
        nodeA.getChild().put(nodeD, <span class="hljs-number">4</span>);
        nodeA.getChild().put(nodeG, <span class="hljs-number">5</span>);
        nodeA.getChild().put(nodeF, <span class="hljs-number">2</span>);
        nodeB.getChild().put(nodeA, <span class="hljs-number">1</span>);
        nodeB.getChild().put(nodeF, <span class="hljs-number">2</span>);
        nodeB.getChild().put(nodeH, <span class="hljs-number">4</span>);
        nodeC.getChild().put(nodeA, <span class="hljs-number">1</span>);
        nodeC.getChild().put(nodeG, <span class="hljs-number">3</span>);
        nodeD.getChild().put(nodeA, <span class="hljs-number">4</span>);
        nodeD.getChild().put(nodeE, <span class="hljs-number">1</span>);
        nodeE.getChild().put(nodeD, <span class="hljs-number">1</span>);
        nodeE.getChild().put(nodeF, <span class="hljs-number">1</span>);
        nodeF.getChild().put(nodeE, <span class="hljs-number">1</span>);
        nodeF.getChild().put(nodeB, <span class="hljs-number">2</span>);
        nodeF.getChild().put(nodeA, <span class="hljs-number">2</span>);
        nodeG.getChild().put(nodeC, <span class="hljs-number">3</span>);
        nodeG.getChild().put(nodeA, <span class="hljs-number">5</span>);
        nodeG.getChild().put(nodeH, <span class="hljs-number">1</span>);
        nodeH.getChild().put(nodeB, <span class="hljs-number">4</span>);
        nodeH.getChild().put(nodeG, <span class="hljs-number">1</span>);
        open.add(nodeB);
        open.add(nodeC);
        open.add(nodeD);
        open.add(nodeE);
        open.add(nodeF);
        open.add(nodeG);
        open.add(nodeH);
        close.add(nodeA);
        <span class="hljs-keyword">return</span> nodeA;
    }
}</code></pre> 
<p>接下来是算法部分，Dijkstra类用于计算起始结点到所有其他结点的最短路径：</p> 
<pre class="prettyprint"><code class="language-java hljs "><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Dijkstra</span> {<!-- --></span>
    Set&lt;Node&gt; open = <span class="hljs-keyword">new</span> HashSet&lt;Node&gt;();
    Set&lt;Node&gt; close = <span class="hljs-keyword">new</span> HashSet&lt;Node&gt;();
    Map&lt;String, Integer&gt; path = <span class="hljs-keyword">new</span> HashMap&lt;String, Integer&gt;();<span class="hljs-comment">//封装路径距离</span>
    Map&lt;String, String&gt; pathInfo = <span class="hljs-keyword">new</span> HashMap&lt;String, String&gt;();<span class="hljs-comment">//封装路径信息</span>

    <span class="hljs-keyword">public</span> Node <span class="hljs-title">init</span>() {
        <span class="hljs-comment">//初始路径,因没有A-&gt;E这条路径,所以path(E)设置为Integer.MAX_VALUE</span>
        path.put(<span class="hljs-string">"B"</span>, <span class="hljs-number">1</span>);
        pathInfo.put(<span class="hljs-string">"B"</span>, <span class="hljs-string">"A-&gt;B"</span>);
        path.put(<span class="hljs-string">"C"</span>, <span class="hljs-number">1</span>);
        pathInfo.put(<span class="hljs-string">"C"</span>, <span class="hljs-string">"A-&gt;C"</span>);
        path.put(<span class="hljs-string">"D"</span>, <span class="hljs-number">4</span>);
        pathInfo.put(<span class="hljs-string">"D"</span>, <span class="hljs-string">"A-&gt;D"</span>);
        path.put(<span class="hljs-string">"E"</span>, Integer.MAX_VALUE);
        pathInfo.put(<span class="hljs-string">"E"</span>, <span class="hljs-string">"A"</span>);
        path.put(<span class="hljs-string">"F"</span>, <span class="hljs-number">2</span>);
        pathInfo.put(<span class="hljs-string">"F"</span>, <span class="hljs-string">"A-&gt;F"</span>);
        path.put(<span class="hljs-string">"G"</span>, <span class="hljs-number">5</span>);
        pathInfo.put(<span class="hljs-string">"G"</span>, <span class="hljs-string">"A-&gt;G"</span>);
        path.put(<span class="hljs-string">"H"</span>, Integer.MAX_VALUE);
        pathInfo.put(<span class="hljs-string">"H"</span>, <span class="hljs-string">"A"</span>);
        <span class="hljs-comment">//将初始节点放入close,其他节点放入open</span>
        Node start = <span class="hljs-keyword">new</span> MapBuilder().build(open, close);
        <span class="hljs-keyword">return</span> start;
    }

    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">computePath</span>(Node start) {
        <span class="hljs-comment">//取距离start节点最近的子节点,放入close</span>
        Node nearest = getShortestPath(start);
        <span class="hljs-keyword">if</span> (nearest == <span class="hljs-keyword">null</span>) {
            <span class="hljs-keyword">return</span>;
        }
        close.add(nearest);     <span class="hljs-comment">//已遍历的</span>
        open.remove(nearest);   <span class="hljs-comment">//未遍历的</span>

        Map&lt;Node, Integer&gt; childs = nearest.getChild();
        <span class="hljs-keyword">for</span> (Node child : childs.keySet()) {
            <span class="hljs-keyword">if</span> (open.contains(child)) {<!-- --><span class="hljs-comment">//如果子节点在open中</span>
                Integer newCompute = path.get(nearest.getName()) + childs.get(child);
                <span class="hljs-keyword">if</span> (newCompute &lt; path.get(child.getName())) {<!-- --><span class="hljs-comment">//新计算出来的距离小于之前设置的距离</span>
                    path.put(child.getName(), newCompute);
                    pathInfo.put(child.getName(), pathInfo.get(nearest.getName()) + <span class="hljs-string">"-&gt;"</span> + child.getName());
                }
            }
        }
        computePath(start);<span class="hljs-comment">//重复执行自己,确保所有子节点被遍历</span>
        computePath(nearest);<span class="hljs-comment">//向外一层层递归,直至所有顶点被遍历</span>
    }

    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">printPathInfo</span>() {
        Set&lt;Map.Entry&lt;String, String&gt;&gt; pathInfos = pathInfo.entrySet();
        <span class="hljs-keyword">for</span> (Map.Entry&lt;String, String&gt; pathInfo : pathInfos) {
            System.out.println(pathInfo.getKey() + <span class="hljs-string">":"</span> + pathInfo.getValue());
        }
    }

    <span class="hljs-javadoc">/**
     * 获取与node最近的子节点
     */</span>
    <span class="hljs-keyword">private</span> Node <span class="hljs-title">getShortestPath</span>(Node node) {
        Node res = <span class="hljs-keyword">null</span>;
        <span class="hljs-keyword">int</span> minDis = Integer.MAX_VALUE;
        Map&lt;Node, Integer&gt; childs = node.getChild();
        <span class="hljs-comment">// 遍历与Node相连接的所有节点，选取其中距离最短的节点</span>
        <span class="hljs-keyword">for</span> (Node child : childs.keySet()) {
            <span class="hljs-keyword">if</span> (open.contains(child)) {
                <span class="hljs-keyword">int</span> distance = childs.get(child);
                <span class="hljs-keyword">if</span> (distance &lt; minDis) {
                    minDis = distance;
                    res = child;
                }
            }
        }
        <span class="hljs-keyword">return</span> res;
    }
}</code></pre> 
<p>然后我们构建了测试用例，如下：</p> 
<pre class="prettyprint"><code class="language-java hljs "><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DijkstraTest</span> {<!-- --></span> 
    <span class="hljs-javadoc">/**
    *
    * Method: getShortestPath(Node node)
    *
    */</span>
    <span class="hljs-annotation">@Test</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">testGetShortestPath</span>() <span class="hljs-keyword">throws</span> Exception {
        <span class="hljs-comment">//TODO: Test goes here...</span>
        Dijkstra test=<span class="hljs-keyword">new</span> Dijkstra();
        Node start=test.init();
        test.computePath(start);
        test.printPathInfo();
    }
} </code></pre> 
<p>运行结果如下：</p> 
<pre class="prettyprint"><code class="language-java hljs ">D:A-&gt;D
E:A-&gt;F-&gt;E
F:A-&gt;F
G:A-&gt;C-&gt;G
B:A-&gt;B
C:A-&gt;C
H:A-&gt;B-&gt;H</code></pre>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/4c932bc48261d2f54874112f00b9d28e/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">【Python】【numpy-汇总3】所有排序函数的示例代码</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/c9c20c1bb18b176dcf0ffd941725cebd/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">SX1278与STM8L的精美结合。</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>