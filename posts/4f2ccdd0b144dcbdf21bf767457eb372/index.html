<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>集合 框架 - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="集合 框架" />
<meta property="og:description" content="集合的概述 集合（容器）
程序存储数据方式 ：
变量：单一的数据
数组：一组具有相同数据类型的数据
问题1：元素的数据类型相同
问题2：长度定义后，不可更改
对象：一组具有关联性的数据(变向解决了数组的问题1)
存储学生(Student)数据：创建学生对象，存储学生姓名、年龄、身高、体重
存储多个学生数据：Student[]
集合：
丰富且强大的数据存储（Java 提供的很多 API ）
集合体系结构 在 java.utll 包（工具）。
Collection：存储的是可重复（不唯一）、无序的数据
接口List ：存储的是可重复（不唯一），有序的数据
使用接口需要找其的实现类
ArrayList
LinkedList
.....
接口Set ： 存储的是不可重复（唯一），无序的数据
HashSet
TreeSet
.....
接口 Map ：存储的是键值对（key键-value键，键和值一一对应）数据
HashMap
HashTable
Properties
TreeMap
......
list集合 ArrayList（动态数组） 需求：存储3个新闻数据，新闻数据包含：标题、作者、时间、内容、阅读数。
构造方法：
ArrayList &lt;泛型/E&gt; ()
常用方法：
add(E e) : boolean 存储指定类型（E：泛型类型）的元素
add(int index, E element) : void 在指定下标位置存储指定类型的元素，原有位置的元素会依次后移
remove(int index) : E 删除指定下标位置的元素，返回被删除的元素
remove(Object obj) : boolean 删除指定的元素（如果有重复的，只会删除第一个找到的元素）" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/4f2ccdd0b144dcbdf21bf767457eb372/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2021-09-02T14:07:54+08:00" />
<meta property="article:modified_time" content="2021-09-02T14:07:54+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">集合 框架</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <h2>集合的概述</h2> 
<p>集合（容器）</p> 
<p>程序存储数据方式 ：</p> 
<ul><li> <p>变量：<strong>单一</strong>的数据</p> </li><li> <p>数组：<strong>一组</strong>具有<strong>相同数据类型</strong>的数据</p> 
  <ul><li> <p><strong>问题1</strong>：元素的数据类型相同</p> </li><li> <p><strong>问题2</strong>：长度定义后，不可更改</p> </li></ul></li><li> <p>对象：<strong>一组</strong>具有<strong>关联性</strong>的数据(变向解决了数组的<strong>问题1</strong>)</p> <p>存储学生(Student)数据：创建学生对象，存储学生姓名、年龄、身高、体重</p> <p>存储多个学生数据：Student[]</p> </li><li> <p>集合：</p> 
  <ul><li> <p>丰富且强大的数据存储（Java 提供的很多 API ）</p> </li></ul></li></ul> 
<p></p> 
<h3>集合体系结构</h3> 
<p>在 java.utll 包（工具）。</p> 
<p>Collection：存储的是<strong>可重复（不唯一）、无序</strong>的数据</p> 
<ul><li> <p>接口List ：存储的是可重复（不唯一），有序的数据</p> <p>使用接口需要找其的实现类</p> 
  <ul><li> <p><strong>ArrayList</strong></p> </li><li> <p>LinkedList</p> </li><li> <p>.....</p> </li></ul></li><li> <p>接口Set ： 存储的是不可重复（唯一），无序的数据</p> 
  <ul><li> <p><strong>HashSet</strong></p> </li><li> <p>TreeSet</p> </li><li> <p>.....</p> </li></ul></li></ul> 
<p>接口 Map ：存储的是键值对（key键-value键，键和值一一对应）数据</p> 
<ul><li> <p>HashMap</p> </li><li> <p>HashTable</p> 
  <ul><li> <p>Properties</p> </li></ul></li><li> <p>TreeMap</p> </li><li> <p>......</p> </li></ul> 
<p></p> 
<h3>list集合</h3> 
<h4>ArrayList（动态数组）</h4> 
<p><strong>需求：存储3个新闻数据，新闻数据包含：标题、作者、时间、内容、阅读数。</strong></p> 
<p><strong>构造方法</strong>：</p> 
<ul><li> <p>ArrayList &lt;泛型/E&gt; ()</p> </li><li> <p><strong>常用方法：</strong></p> 
  <ul><li> <p>add(E e) : boolean 存储指定类型（E：泛型类型）的元素</p> </li><li> <p>add(int index, E element) : void 在指定下标位置存储指定类型的元素，原有位置的元素会依次后移</p> </li><li> <p>remove(int index) : E 删除指定下标位置的元素，返回被删除的元素</p> </li><li> <p>remove(Object obj) : boolean 删除指定的元素（如果有重复的，只会删除第一个找到的元素）</p> </li><li> <p>set(int index, E element) : E 修改指定下标位置的元素，返回被替换的元素</p> </li><li> <p>get(int index) : E 根据下标查询元素</p> </li><li> <p>size() : int 查询集合中存储的元素数量</p> </li><li> <p>contains(Object o) : boolean 判断集合中是否存在指定的元素</p> </li><li> <p>indexOf(Object o) : int 查询指定元素在集合中的下标，找不到会返回 -1</p> </li><li> <p>lastIndexOf(Object o) : int 从后往前查找指定元素在集合中的下标，找不到会返回-1</p> <p>注意：从后往前查找，只不过是方向变化，下标还是正向的下标（不会变！）</p> </li><li> <p>clear() : void 清空集合</p> </li><li> <p>isEmpty() : boolean 判断集合是否是空的（没有一个元素）</p> </li></ul></li></ul> 
<h4>LinkedList</h4> 
<p><strong>构造方法：</strong></p> 
<ul><li> <p>LinkedList&lt;E&gt;()</p> </li></ul> 
<p><strong>常用方法：</strong></p> 
<ul><li> <p>addFirst(E e) : void 向前追加元素</p> </li><li> <p>addLast(E e) : void 向后追加元素</p> </li><li> <p>removeFirst() : E 删除第一个元素</p> </li><li> <p>removeLast() : E 删除最后一个元素</p> </li><li> <p>getFirst() : E 查询第一个元素</p> </li><li> <p>getLast() : E 查询最后一个元素</p> </li><li> <p>....</p> </li></ul> 
<blockquote> 
 <p>其他方法略，大多和 ArrayList 一致，因为这些方法都是定义在 List 接口中，所以同为 List 接口实现类，当然都会重写相应的方法。</p> 
 <p><strong>注意：方法名虽然相同，代表的只是方法功能一致，但不代表实现一致！</strong></p> 
 <p>例如：add()、remove() ....</p> 
</blockquote> 
<h4>ArrayList和LinkedList的区别(面试题)</h4> 
<p><strong>相同点：</strong></p> 
<ul><li> <p>都是 List 接口的实现类，可以存储可重复的，有序的数据</p> </li></ul> 
<p><strong>不同点：</strong></p> 
<ul><li> <p>ArrayList 底层数据结构是数组结构，在实现数据的查询时，因为数组结构有下标，所以效率较高。但是，在增加或删除数据时，因为数组结构长度不可变，所以会创建一个新的数组，导致效率较低。</p> <p>它适合于查询较多，增删较少的情况。</p> </li><li> <p>LinkedList 底层数据结构是链表结构，在增加或删除数据时，尤其是首尾的增删，因为链表结构增加节点或删除节点，只需要修改下一个连接的地址即可，效率较高。但是，在实现数据的查询时，没有下标，只能从首节点依次进行查询，效率较低。</p> <p>它适合于增删较多，查询较少的情况。</p> </li></ul> 
<h3>Set集合</h3> 
<h4>HashSet</h4> 
<p><strong>构造方法：</strong></p> 
<ul><li> <p>HashSet&lt;E&gt;()</p> </li></ul> 
<p><strong>常用方法：</strong></p> 
<ul><li> <p>add(E e) : boolean 存储元素（去重数据）</p> </li><li> <p>remove(E e) : E 删除数据</p> </li><li> <p>size() : int 获取集合的元素数量</p> </li><li> <p>contains(Object o) : boolean 判断是否包含指定的元素</p> </li><li> <p>...</p> </li></ul> 
<blockquote> 
 <p>因为 Set 和 List 都是继承自 Collection 接口，所以很多方法也是相同的。</p> 
</blockquote> 
<blockquote> 
 <p><strong>注意：</strong> 如果用 Set 存储引用数据类型数据，需要重写相应类的 equals 和 hashCode 方法。不然，不认为是重复数据，不会去重。</p> 
</blockquote> 
<h3>集合的遍历</h3> 
<h4>List集合遍历</h4> 
<ol><li> <p><strong>循环下标实现</strong></p> <p>例如：遍历新闻数据</p> <pre><code class="language-java">for (int i = 0; i &lt; list.size(); i++) {
    News news = list.get(i);
    System.out.println(news);
}</code></pre> <p></p> </li><li> <p><strong>增强 for 实现</strong></p> <p>例如：遍历新闻数据</p> <pre><code class="language-java">for (News news : list) {
    System.out.println(news);
}</code></pre> <p></p> </li><li> <p><strong>迭代器</strong></p> <pre><code class="language-java">// 迭代器：Iterator
// iterator() : Iterator&lt;E&gt;
Iterator&lt;News&gt; iterator = list.iterator();
// hasNext() : boolean 判断是否还有下一个元素
// next() : E 取出下一个元素
//      if (iterator.hasNext()) {
//          News next = iterator.next();
//          System.out.println(next);
//      }
​
while (iterator.hasNext()) {
    News next = iterator.next();
    System.out.println(next);
}</code></pre> <p></p> </li></ol> 
<h4>Set集合遍历</h4> 
<ol><li> <p><strong>增强 for 实现</strong></p> <pre><code class="language-java">for (News news : newsSet) {
    System.out.println(news);
}</code></pre> <p></p> </li><li> <p><strong>迭代器</strong></p> <pre><code class="language-java">Iterator&lt;News&gt; iterator = newsSet.iterator();
while (iterator.hasNext()) {
    News next = iterator.next();
    System.out.println(next);
}</code></pre> <p></p> </li></ol> 
<h3>泛型</h3> 
<p><strong>泛型：给集合限制元素的类型。</strong></p> 
<blockquote> 
 <p>泛型是在 JDK 1.5 出现的特性。</p> 
</blockquote> 
<p>它可以有效解决类型转换问题。</p> 
<p><strong>泛型都可以用在：</strong></p> 
<ul><li> <p><strong>类上</strong></p> <pre><code class="language-java">// 集合
public class ArrayList&lt;E&gt; {
    
}
// 在创建集合对象时，只要指定了 E 的具体类型，那么 add 方法的参数或返回值也就指定了对应的类型
​
public boolean add(E e) {
    ensureCapacityInternal(size + 1);  // Increments modCount!!
    elementData[size++] = e;
    return true;
}
​
public E remove(int index) {
    
}</code></pre> <p></p> </li><li> <p><strong>方法上</strong></p> <pre><code class="language-java">// Arrays类的方法
// 在调用该方法时，传入什么类型数据，返回的就是什么类型的数据
public static &lt;T&gt; List&lt;T&gt; asList(T... a) {
    return new ArrayList&lt;&gt;(a);
}</code></pre> 
  <blockquote> 
   <p>在方法参数中出现了 <code>...</code> ，它被称为可变参数，比较灵活。</p> 
   <p>它意味着，你传递多少个指定类型的参数都可以，0个，1个，2个....</p> 
   <p>可以把它在处理时看作是一个数组来处理。</p> 
   <pre><code class="language-java">public class Demo03 {
​
public static void main(String[] args) {
  //        printNames();
  printNames("张三", "李四", "王五");
}
​
public static void printNames(String... names) {
  for (String name : names) {
      System.out.println(name);
  }
}
​
}</code></pre> 
   <p></p> 
  </blockquote> </li><li> <p>泛型还可以限制类型必须是某个类型的子类</p> <p><code>&lt;? extends 类型&gt;</code></p> </li></ul> 
<blockquote> 
 <p>泛型使用任何符号代表都可以。这些符号就是一个某种类型的表示。</p> 
 <p><strong>常见的符号：</strong></p> 
 <ul><li> <p>E（Element，元素）</p> </li><li> <p>T（Type，类型）</p> </li><li> <p>K（Key，键）</p> </li><li> <p>V（Value，值）</p> </li><li> <p>....</p> </li></ul> 
</blockquote> 
<hr> 
<p>泛型在指定具体类型时，必须是引用数据类型。</p> 
<ul><li> <p>String</p> </li></ul> 
<p><strong>Java给基本类型都准备了相应的引用类型（基本类型相应的包装类型）</strong></p> 
<ul><li> <p>byte -&gt; Byte</p> </li><li> <p>short -&gt; Short</p> </li><li> <p>int -&gt; <strong>Integer</strong></p> </li><li> <p>long -&gt; Long</p> </li><li> <p>float -&gt; Float</p> </li><li> <p>double -&gt; Double</p> </li><li> <p>char -&gt; <strong>Character</strong></p> </li><li> <p>boolean -&gt; Boolean</p> </li></ul> 
<h3><strong>Map集合概述</strong></h3> 
<p>Map 集合是一种键值对数据的存储方案。</p> 
<p>key-value，其中 <strong>key 是唯一的</strong> ，而 value 是可以重复的。</p> 
<p>Map 是无序存储（Hash）。</p> 
<h3>Map集合使用</h3> 
<ul><li> <p><strong>HashMap</strong></p> </li><li> <p>HashTable</p> 
  <ul><li> <p>Properties</p> </li></ul></li><li> <p>TreeMap</p> </li></ul> 
<hr> 
<p><strong>构造方法：</strong></p> 
<ul><li> <p>HashMap&lt;K, V&gt;()</p> </li></ul> 
<p><strong>常用方法：</strong></p> 
<ul><li> <p>put(K key, V value) : V 存储/更新（相同键再次调用该方法）键值对数据，返回被替换的值（如果是存储，那么返回的是 null）</p> </li><li> <p>get(Object key) : V 根据键获取值</p> </li><li> <p>size() : int 获取集合中存储的键值对数量</p> </li><li> <p>containsKey(Object key) : boolean 判断集合中是否包含指定的键</p> </li><li> <p>containsValue(Object value) : boolean 判断集合中是否包含指定的值</p> </li><li> <p>remove(Object key) : V 根据键删除，返回的是被删除的值</p> </li><li> <p>keySet() : Set&lt;K&gt; 获取所有键的集合（键是唯一的，所以是Set集合）</p> </li><li> <p>entrySet() : Set&lt;Entry&lt;K, V&gt;&gt; 获取所有键值对的集合</p> 
  <ul><li> <p>Entry：</p> 
    <ul><li> <p>getKey() : K 获取 Entry 中的键</p> </li><li> <p>getValue() : V 获取 Entry 中的值</p> </li></ul></li></ul></li><li> <p>values() : Collection&lt;V&gt; 获取所有值的集合（Map存储，值是无序的，但是可重复，所以是Collection集合）</p> </li><li> <p>clear() : void 清空集合中的键值对</p> </li><li> <p>...</p> </li></ul> 
<h3>Map集合的遍历</h3> 
<ol><li> <p><strong>获取所有的键，遍历键根据键获取值</strong></p> <pre><code class="language-java">Set&lt;String&gt; keySet = map.keySet();
for (String key : keySet) {
    String value = map.get(key);
    System.out.println(key + "=" + value);
}</code></pre> <p></p> </li><li> <p><strong>获取所有键值对，遍历键值对，从中获取键和值</strong></p> <pre><code class="language-java">Set&lt;Entry&lt;String,String&gt;&gt; entrySet = map.entrySet();
for (Entry&lt;String, String&gt; entry : entrySet) {
    String key = entry.getKey();
    String value = entry.getValue();
    System.out.println(key + "=" + value);
}</code></pre> <p></p> </li><li> <p><strong>forEach方法（1.8）</strong></p> <pre><code class="language-java">map.forEach((key, value) -&gt; {
    System.out.println(key + "=" + value);
});</code></pre> <p></p> </li></ol> 
<h3>Collections工具类</h3> 
<p>Arrays。</p> 
<p><strong>Collection 和 Collections 的区别？（面试题）</strong></p> 
<ul><li> <p>Collection 是一个集合的顶级接口，用于存储可重复的，无序的数据</p> </li><li> <p>Collections 是一个集合的工具类，里面定义了大量的静态方法，用于更为便捷的操作集合</p> </li></ul> 
<p><strong>常用方法：</strong></p> 
<ul><li> <p>sort(List&lt;T&gt; list) : void 可以实现对集合的升序排序</p> </li><li> <p>min(Collection&lt;? extends T&gt; coll) : T 获取集合中的最小值</p> </li><li> <p>max(Collection&lt;? extends T&gt; coll) : T 获取集合中的最大值</p> </li><li> <p>reverse(List&lt;?&gt; list) : void 反转集合元素</p> </li><li> <p>shuffle(List&lt;?&gt; list) : void 打乱集合元素</p> </li></ul> 
<h3>ArrayList的扩容原理(面试题)</h3> 
<blockquote> 
 <p>定义时，首先进行定义一个空数组 Object[] elementDate = {}; ，在存储数据时，首先进行数据存储 <strong>elementDate[0] = "xx"</strong>，再进行<strong>size</strong>的增加</p> 
</blockquote> 
<blockquote> 
 <p>默认初始化容量为：<strong>10</strong>（数组）</p> 
 <p>扩容时，会扩容为原来的<strong>1.5</strong>倍。</p> 
</blockquote> 
<p><strong>默认仅仅创建集合对象，不存储：</strong> 内部的数组会初始化为一个静态常量（空数组）</p> 
<p><strong>默认的初始化容量：</strong> 10（长度为10的数组）</p> 
<p><strong>进行扩容时，每次扩容：</strong> 1.5 倍</p> 
<hr> 
<p><strong>集合初始化时， 指定集合初始值大小：</strong></p> 
<p>如果确定集合要存储的元素个数，那么 ArrayList 在创建对象时，建议指定 initialCapacity 为你要存储的元素个数。</p> 
<pre>ArrayList&lt;Integer&gt; list = new ArrayList&lt;&gt;(3);</pre> 
<p>HashMap 使用 HashMap(int initialCapacity) 初始化，如果暂时无法确定集合大小， 那么指定默认值（ 16） 即可。 <strong>正例：</strong> <strong>initialCapacity = (需要存储的元素个数 / 负载因子) + 1</strong> 。 注意负载因子（即 loader factor） 默认 为 0.75，如果暂时无法确定初始值大小，请设置为 16（即默认值） 。</p> 
<pre>HashMap&lt;String, String&gt; map = new HashMap&lt;&gt;(16);</pre> 
<blockquote> 
 <p>参见阿里巴巴开发手册要求。</p> 
</blockquote> 
<h3>第三方的工具：Hutool</h3> 
<h4>概述</h4> 
<blockquote> 
 <p>Hutool是一个小而全的Java工具类库，通过静态方法封装，降低相关API的学习成本，提高工作效率，使Java拥有函数式语言般的优雅，让Java语言也可以“甜甜的”。</p> 
 <p>Hutool中的工具方法来自每个用户的精雕细琢，它涵盖了Java开发底层代码中的方方面面，它既是大型项目开发中解决小问题的利器，也是小型项目中的效率担当；</p> 
 <p>Hutool的设计思想是尽量减少重复的定义，让项目中的util这个package尽量少，总的来说有如下的几个思想：</p> 
 <ul><li> <p>方法优先于对象</p> </li><li> <p>自动识别优于用户定义</p> </li><li> <p>便捷性与灵活性并存</p> </li><li> <p>适配与兼容</p> </li><li> <p>可选依赖原则</p> </li><li> <p>无侵入原则</p> </li></ul> 
 <p>官网：<a href="https://www.hutool.cn/" rel="nofollow">https://www.hutool.cn/</a></p> 
</blockquote> 
<h4>安装(导入jar包)</h4> 
<ol><li> <p>下载 jar 包 <code>hutool-all</code></p> </li><li> <p>在项目中新建一个目录：lib</p> </li><li> <p>拷贝 jar 包到 lib 目录</p> </li><li> <p>右键 jar 包 -&gt; Build Path -&gt; add to build path</p> </li><li> <p>在项目中会出现一个 Referenced Libraries 关联库</p> </li><li> <p><strong>然后按照 Hutool 官方的<a href="https://www.hutool.cn/docs/#/" rel="nofollow">入门</a>和 <a href="https://apidoc.gitee.com/dromara/hutool/" rel="nofollow">API 文档</a>使用即可</strong></p> </li></ol> 
<h4>使用</h4> 
<p><strong>集合工具类：</strong></p> 
<ul><li> <p>CollectionUtil</p> 
  <ul><li> <p>newArrayList(T... values) : ArrayList&lt;T&gt; 快速创建一个指定容量的集合</p> </li><li> <p>join(Iterable&lt;T&gt; iterable, CharSequence conjunction) : String 将集合中的元素通过指定字符拼接为字符串</p> </li><li> <p>union(Collection&lt;T&gt; coll1, Collection&lt;T&gt; coll2) : Collection&lt;T&gt; 取两个集合的并集</p> </li><li> <p>....</p> </li></ul></li><li> <p>MapUtil</p> 
  <ul><li> <p>newHashMap(int size) : HashMap&lt;K, V&gt; 快速创建一个指定容量的Map集合（它会自动帮我们算好初始化容量）</p> </li><li> <p>...</p> </li></ul></li></ul> 
<p><strong>随机数工具类：</strong></p> 
<ul><li> <p>RandomUtil</p> 
  <ul><li> <p>randomInt(int min, int max) : int 生成 [min, max) 范围的随机整数</p> </li><li> <p>randomNumbers(int length) : String 生成指定长度的随机字符串（整数）</p> </li><li> <p>...</p> </li></ul></li></ul> 
<p><strong>字符串工具类：</strong></p> 
<ul><li> <p>StrUtil</p> 
  <ul><li> <p>format(CharSequence template, Object... params) : String</p> <pre><code class="language-java">String format2 = StrUtil.format("我的姓名：{}，我的年龄：{}，我的余额：{}", name, age, money);
System.out.println(format2);</code></pre> <p></p> </li><li> <p>isNotEmpty(CharSequence str) : boolean 判断字符串是否不为空（null、""空字符串）</p> </li><li> <p>....</p> </li></ul></li></ul> 
<p>....</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/c8dd7d8c92dbdada6d98ddd5a55dbc7b/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">浅析iOS中的贝塞尔(Bézier curve)曲线</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/6077caca77ec716a3cb14e067798e05d/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">2021年秋招面经分享·华为【海思·芯片与器件工程师】</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>