<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>【教3妹学编程-算法题】3008. 找出数组中的美丽下标 II - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="【教3妹学编程-算法题】3008. 找出数组中的美丽下标 II" />
<meta property="og:description" content="3妹：呜呜，烦死了， 脸上长了一个痘
2哥 : 不要在意这些细节嘛，不用管它，过两天自然不就好了。
3妹：切，你不懂，影响这两天的心情哇。
2哥 : 我看你是不急着找工作了啊， 工作那么辛苦，哪还有时间想这些啊。
3妹：说到找工作，我又要去刷题了。
2哥：我给你出一道关于美丽的题吧，让你的心情美丽美丽~
题目： 给你一个下标从 0 开始的字符串 s 、字符串 a 、字符串 b 和一个整数 k 。
如果下标 i 满足以下条件，则认为它是一个 美丽下标 ：
0 &lt;= i &lt;= s.length - a.length
s[i…(i &#43; a.length - 1)] == a
存在下标 j 使得：
0 &lt;= j &lt;= s.length - b.length
s[j…(j &#43; b.length - 1)] == b
|j - i| &lt;= k
以数组形式按 从小到大排序 返回美丽下标。
示例 1：" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/fdaaf6a3398ea3ba756d7ed3140053ab/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2024-01-16T07:56:21+08:00" />
<meta property="article:modified_time" content="2024-01-16T07:56:21+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">【教3妹学编程-算法题】3008. 找出数组中的美丽下标 II</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-light">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p><img src="https://images2.imgbox.com/ea/fb/kDBxZqa4_o.png" alt="烦死了"><br> <em><strong>3妹</strong></em>：呜呜，烦死了， 脸上长了一个痘<br> <em><strong>2哥</strong></em> : 不要在意这些细节嘛，不用管它，过两天自然不就好了。<br> <em><strong>3妹</strong></em>：切，你不懂，影响这两天的心情哇。<br> <em><strong>2哥</strong></em> : 我看你是不急着找工作了啊， 工作那么辛苦，哪还有时间想这些啊。<br> <em><strong>3妹</strong></em>：说到找工作，我又要去刷题了。<br> <em><strong>2哥</strong></em>：我给你出一道关于美丽的题吧，让你的心情美丽美丽~</p> 
<h2><a id="_8"></a>题目：</h2> 
<p>给你一个下标从 0 开始的字符串 s 、字符串 a 、字符串 b 和一个整数 k 。</p> 
<p>如果下标 i 满足以下条件，则认为它是一个 美丽下标 ：</p> 
<p>0 &lt;= i &lt;= s.length - a.length<br> s[i…(i + a.length - 1)] == a<br> 存在下标 j 使得：<br> 0 &lt;= j &lt;= s.length - b.length<br> s[j…(j + b.length - 1)] == b<br> |j - i| &lt;= k<br> 以数组形式按 从小到大排序 返回美丽下标。</p> 
<p>示例 1：</p> 
<p>输入：s = “isawsquirrelnearmysquirrelhouseohmy”, a = “my”, b = “squirrel”, k = 15<br> 输出：[16,33]<br> 解释：存在 2 个美丽下标：[16,33]。</p> 
<ul><li>下标 16 是美丽下标，因为 s[16…17] == “my” ，且存在下标 4 ，满足 s[4…11] == “squirrel” 且 |16 - 4| &lt;= 15 。</li><li>下标 33 是美丽下标，因为 s[33…34] == “my” ，且存在下标 18 ，满足 s[18…25] == “squirrel” 且 |33 - 18| &lt;= 15 。<br> 因此返回 [16,33] 作为结果。<br> 示例 2：</li></ul> 
<p>输入：s = “abcd”, a = “a”, b = “a”, k = 4<br> 输出：[0]<br> 解释：存在 1 个美丽下标：[0]。</p> 
<ul><li>下标 0 是美丽下标，因为 s[0…0] == “a” ，且存在下标 0 ，满足 s[0…0] == “a” 且 |0 - 0| &lt;= 4 。<br> 因此返回 [0] 作为结果。</li></ul> 
<p>提示：</p> 
<p>1 &lt;= k &lt;= s.length &lt;= 5 * 10^5<br> 1 &lt;= a.length, b.length &lt;= 5 * 10^5<br> s、a、和 b 只包含小写英文字母。</p> 
<h2><a id="_46"></a>思路：</h2> 
<p><img src="https://images2.imgbox.com/df/11/Yhcjk4GW_o.png" alt="思考"></p> 
<p>KMP+二分查找，<br> 用 KMP 求出 a 在 s 中的所有出现位置，记作 posA。<br> 用 KMP 求出 b 在 s 中的所有出现位置，记作 posB。<br> 遍历 posA中的下标 i，在 posB中二分查找离 iii 最近的 j。如果 ∣i−j∣≤k，则把 i 加入答案。</p> 
<h2><a id="java_55"></a>java代码：</h2> 
<pre><code>class Solution {
    public List&lt;Integer&gt; beautifulIndices(String s, String a, String b, int k) {
        char[] text = s.toCharArray();
        List&lt;Integer&gt; posA = kmp(text, a.toCharArray());
        List&lt;Integer&gt; posB = kmp(text, b.toCharArray());

        List&lt;Integer&gt; ans = new ArrayList&lt;&gt;();
        for (int i : posA) {
            int bi = lowerBound(posB, i);
            if (bi &lt; posB.size() &amp;&amp; posB.get(bi) - i &lt;= k ||
                bi &gt; 0 &amp;&amp; i - posB.get(bi - 1) &lt;= k) {
                ans.add(i);
            }
        }
        return ans;
    }

    private List&lt;Integer&gt; kmp(char[] text, char[] pattern) {
        int m = pattern.length;
        int[] pi = new int[m];
        int c = 0;
        for (int i = 1; i &lt; m; i++) {
            char v = pattern[i];
            while (c &gt; 0 &amp;&amp; pattern[c] != v) {
                c = pi[c - 1];
            }
            if (pattern[c] == v) {
                c++;
            }
            pi[i] = c;
        }

        List&lt;Integer&gt; res = new ArrayList&lt;&gt;();
        c = 0;
        for (int i = 0; i &lt; text.length; i++) {
            char v = text[i];
            while (c &gt; 0 &amp;&amp; pattern[c] != v) {
                c = pi[c - 1];
            }
            if (pattern[c] == v) {
                c++;
            }
            if (c == m) {
                res.add(i - m + 1);
                c = pi[c - 1];
            }
        }
        return res;
    }

    // 开区间写法
    // 请看 https://www.bilibili.com/video/BV1AP41137w7/
    private int lowerBound(List&lt;Integer&gt; nums, int target) {
        int left = -1, right = nums.size(); // 开区间 (left, right)
        while (left + 1 &lt; right) { // 区间不为空
            // 循环不变量：
            // nums[left] &lt; target
            // nums[right] &gt;= target
            int mid = (left + right) &gt;&gt;&gt; 1;
            if (nums.get(mid) &lt; target) {
                left = mid; // 范围缩小到 (mid, right)
            } else {
                right = mid; // 范围缩小到 (left, mid)
            }
        }
        return right;
    }
}

</code></pre>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/ae920f5d7ef1c11dc89f484c57a7e884/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">【教3妹学编程-算法题】3006. 找出数组中的美丽下标 I</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/1e5faf78a285e74784ab1f0ec22efb8b/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">网络安全中的人工智能</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>