<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Android SurfaceFlinger导读（10）理解DisplayDevice - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Android SurfaceFlinger导读（10）理解DisplayDevice" />
<meta property="og:description" content="该系列文章总纲链接：Android GUI系统之SurfaceFlinger 系列文章目录
本章关键点总结 &amp; 说明： 本章节思维导图如上。主要讲述了DisplayDevice的概念，这里 主要DisplayDevice的创建流程和 两个关键方法makeCurrent 和swapBuffer。
在之前的分析中，我们知道 每个应用端对应一个SurfaceControl，每个SurfaceControl都对应多个Surface，即 应用端使用Surface来管理Buffer。实际上在SurfaceFlinger中 DisplayDevice也是通过Surface来管理Buffer。这里简单说明下两者的异同：
应用端的Buffer是向Ashmem申请的；DisplayDevice端的Buffer是向FrameBuffer申请的应用端的Buffer是用来填充的；DisplayDevice端的Buffer是用来推给Framebuffer 渲染的 了解了这些后，我们开始从DisplayDevice创建流程开始分析。
1 DisplayDevice创建流程开始分析
DisplayDevice是在SurfaceFlinger的init中创建的，代码实现如下：
void SurfaceFlinger::init() { //... // initialize our non-virtual displays for (size_t i=0 ; i&lt;DisplayDevice::NUM_BUILTIN_DISPLAY_TYPES ; i&#43;&#43;) { DisplayDevice::DisplayType type((DisplayDevice::DisplayType)i); // set-up the displays that are already connected if (mHwc-&gt;isConnected(i) || type==DisplayDevice::DISPLAY_PRIMARY) { // All non-virtual displays are currently considered secure. bool isSecure = true; createBuiltinDisplayLocked(type); wp&lt;IBinder&gt; token = mBuiltinDisplays[i]; //BufferQueue相关 sp&lt;IGraphicBufferProducer&gt; producer; sp&lt;IGraphicBufferConsumer&gt; consumer; BufferQueue::createBufferQueue(&amp;producer, &amp;consumer, new GraphicBufferAlloc()); //关键点1：FramebufferSurface创建，定位为 消费者身份 sp&lt;FramebufferSurface&gt; fbs = new FramebufferSurface(*mHwc, i, consumer); int32_t hwcId = allocateHwcDisplayId(type); //关键点2：DisplayDevice创建，定位为 生产者身份 sp&lt;DisplayDevice&gt; hw = new DisplayDevice(this, type, hwcId, mHwc-&gt;getFormat(hwcId), isSecure, token, fbs, producer, mRenderEngine-&gt;getEGLConfig()); if (i &gt; DisplayDevice::DISPLAY_PRIMARY) { hw-&gt;setPowerMode(HWC_POWER_MODE_NORMAL); } mDisplays." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/3159ed72643b234cb3d411cabe99af45/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-10-07T15:38:26+08:00" />
<meta property="article:modified_time" content="2023-10-07T15:38:26+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Android SurfaceFlinger导读（10）理解DisplayDevice</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p>该系列文章总纲链接：<a href="https://blog.csdn.net/vviccc/article/details/104860616" title="Android GUI系统之SurfaceFlinger 系列文章目录">Android GUI系统之SurfaceFlinger 系列文章目录</a></p> 
<hr> 
<h3>本章关键点总结 &amp; 说明：</h3> 
<p style="text-align:center;"><img alt="" height="291" src="https://images2.imgbox.com/b5/25/rFg8cf9P_o.png" width="600"></p> 
<p>本章节思维导图如上。主要讲述了DisplayDevice的概念，这里 主要DisplayDevice的创建流程和 两个关键方法makeCurrent  和swapBuffer。</p> 
<hr> 
<p>在之前的分析中，我们知道 每个应用端对应一个SurfaceControl，每个SurfaceControl都对应多个Surface，即 应用端使用Surface来管理Buffer。实际上在SurfaceFlinger中 DisplayDevice也是通过Surface来管理Buffer。这里简单说明下两者的异同：</p> 
<ol><li>应用端的Buffer是向Ashmem申请的；DisplayDevice端的Buffer是向FrameBuffer申请的</li><li>应用端的Buffer是用来填充的；DisplayDevice端的Buffer是用来推给Framebuffer 渲染的</li></ol> 
<p>了解了这些后，我们开始从DisplayDevice创建流程开始分析。</p> 
<p><strong>1 DisplayDevice创建流程开始分析</strong></p> 
<p>DisplayDevice是在SurfaceFlinger的init中创建的，代码实现如下：</p> 
<pre><code class="language-java">void SurfaceFlinger::init() {
    //...
    // initialize our non-virtual displays
    for (size_t i=0 ; i&lt;DisplayDevice::NUM_BUILTIN_DISPLAY_TYPES ; i++) {
        DisplayDevice::DisplayType type((DisplayDevice::DisplayType)i);
        // set-up the displays that are already connected
        if (mHwc-&gt;isConnected(i) || type==DisplayDevice::DISPLAY_PRIMARY) {
            // All non-virtual displays are currently considered secure.
            bool isSecure = true;
            createBuiltinDisplayLocked(type);
            wp&lt;IBinder&gt; token = mBuiltinDisplays[i];
            //BufferQueue相关
            sp&lt;IGraphicBufferProducer&gt; producer;
            sp&lt;IGraphicBufferConsumer&gt; consumer;
            BufferQueue::createBufferQueue(&amp;producer, &amp;consumer,
                    new GraphicBufferAlloc());
            //关键点1：FramebufferSurface创建，定位为 消费者身份
            sp&lt;FramebufferSurface&gt; fbs = new FramebufferSurface(*mHwc, i,
                    consumer);
            int32_t hwcId = allocateHwcDisplayId(type);
            //关键点2：DisplayDevice创建，定位为 生产者身份
            sp&lt;DisplayDevice&gt; hw = new DisplayDevice(this,
                    type, hwcId, mHwc-&gt;getFormat(hwcId), isSecure, token,
                    fbs, producer,
                    mRenderEngine-&gt;getEGLConfig());
            if (i &gt; DisplayDevice::DISPLAY_PRIMARY) {
                hw-&gt;setPowerMode(HWC_POWER_MODE_NORMAL);
            }
            mDisplays.add(token, hw);
        }
    }
    //...
    // start boot animation
    startBootAnim();
}</code></pre> 
<p><strong>1.1 FramebufferSurface创建流程分析</strong></p> 
<p>FramebufferSurface构造函数实现如下：</p> 
<pre><code class="language-cpp">FramebufferSurface::FramebufferSurface(HWComposer&amp; hwc, int disp,
        const sp&lt;IGraphicBufferConsumer&gt;&amp; consumer) :
    ConsumerBase(consumer),
    mDisplayType(disp),
    mCurrentBufferSlot(-1),
    mCurrentBuffer(0),
    mHwc(hwc)
{
    mName = "FramebufferSurface";
    mConsumer-&gt;setConsumerName(mName);
    /*这里设置了标志位GRALLOC_USAGE_HW_FB，借此参数分辨
    向Ashmem申请-&gt;APP;向Framebuffer申请-&gt;DisplayDevice
    */
    mConsumer-&gt;setConsumerUsageBits(GRALLOC_USAGE_HW_FB |
                                       GRALLOC_USAGE_HW_RENDER |
                                       GRALLOC_USAGE_HW_COMPOSER);
    mConsumer-&gt;setDefaultBufferFormat(mHwc.getFormat(disp));
    mConsumer-&gt;setDefaultBufferSize(mHwc.getWidth(disp),  mHwc.getHeight(disp));
    mConsumer-&gt;setDefaultMaxBufferCount(NUM_FRAMEBUFFER_SURFACE_BUFFERS);
}</code></pre> 
<p>专注分析setConsumerUsageBits，属于BufferQueueConsumer类型，因此代码实现如下：</p> 
<pre><code class="language-cpp">
status_t BufferQueueConsumer::setConsumerUsageBits(uint32_t usage) {
    ATRACE_CALL();
    BQ_LOGV("setConsumerUsageBits: %#x", usage);
    Mutex::Autolock lock(mCore-&gt;mMutex);
    mCore-&gt;mConsumerUsageBits = usage;
    return NO_ERROR;
}
</code></pre> 
<p>这里将 参数usgae 传递给 mCore-&gt;mConsumerUsageBits。</p> 
<p><strong>1.2 DisplayDevice构造函数分析</strong></p> 
<p>DisplayDevice的构造函数实现如下：</p> 
<pre><code class="language-cpp">DisplayDevice::DisplayDevice(
        const sp&lt;SurfaceFlinger&gt;&amp; flinger,
        DisplayType type,
        //...各种初始化
{
    //创建surface对象
    mNativeWindow = new Surface(producer, false);
    ANativeWindow* const window = mNativeWindow.get();

    //创建OpenGLES 使用的surface对象
    EGLSurface surface;
    EGLint w, h;
    EGLDisplay display = eglGetDisplay(EGL_DEFAULT_DISPLAY);
    if (config == EGL_NO_CONFIG) {
        config = RenderEngine::chooseEglConfig(display, format);
    }
    surface = eglCreateWindowSurface(display, config, window, NULL);
    eglQuerySurface(display, surface, EGL_WIDTH,  &amp;mDisplayWidth);
    eglQuerySurface(display, surface, EGL_HEIGHT, &amp;mDisplayHeight);

    if (mType &gt;= DisplayDevice::DISPLAY_VIRTUAL)
        window-&gt;setSwapInterval(window, 0);//虚拟设备不支持 图像合成

    mConfig = config;
    mDisplay = display;
    mSurface = surface;
    mFormat  = format;
    mPageFlipCount = 0;
    mViewport.makeInvalid();
    mFrame.makeInvalid();

    //虚拟设备的屏幕 默认不关闭
    mPowerMode = (mType &gt;= DisplayDevice::DISPLAY_VIRTUAL) ?
                  HWC_POWER_MODE_NORMAL : HWC_POWER_MODE_OFF;

    // Name the display.  The name will be replaced shortly if the display
    // was created with createDisplay().
    switch (mType) {
        case DISPLAY_PRIMARY:
            mDisplayName = "Built-in Screen";
            break;
        case DISPLAY_EXTERNAL:
            mDisplayName = "HDMI Screen";
            break;
        default:
            mDisplayName = "Virtual Screen";    // e.g. Overlay #n
            break;
    }

    // initialize the display orientation transform.
    setProjection(DisplayState::eOrientationDefault, mViewport, mFrame);
}
</code></pre> 
<p>该构造函数主要是 创建了Surface，也就是一个NativeWindow。</p> 
<p><strong>1.2.1 surface构造函数分析</strong></p> 
<p>这里看下 surface的构造函数，代码如下：</p> 
<pre><code class="language-cpp">Surface::Surface(
        const sp&lt;IGraphicBufferProducer&gt;&amp; bufferProducer,
        bool controlledByApp)
    : mGraphicBufferProducer(bufferProducer)
{
    // Initialize the ANativeWindow function pointers.
    ANativeWindow::setSwapInterval  = hook_setSwapInterval;
    ANativeWindow::dequeueBuffer    = hook_dequeueBuffer;
    ANativeWindow::cancelBuffer     = hook_cancelBuffer;
    ANativeWindow::queueBuffer      = hook_queueBuffer;
    ANativeWindow::query            = hook_query;
    ANativeWindow::perform          = hook_perform;
    //...
}</code></pre> 
<p>这里对其中的一个hook_queueBuffer进行分析，代码如下：</p> 
<pre><code class="language-cpp">int Surface::hook_queueBuffer(ANativeWindow* window,
        ANativeWindowBuffer* buffer, int fenceFd) {
    Surface* c = getSelf(window);
    return c-&gt;queueBuffer(buffer, fenceFd);
}</code></pre> 
<p>最后是调用回了Surface的queueBuffer方法，其他几个hook方法也是类似的。即NativeWindow 和Surface访问的方法是一样的。</p> 
<p>同时通过上面的分析得出Buffer的流程：Surface-&gt;BufferQueue-&gt;FramebufferSurface-&gt;HWComposer-&gt;Gralloc-&gt;显示设备Framebuffer</p> 
<p><strong>1.2.2 eglCreateWindowSurface分析</strong></p> 
<p>eglCreateWindowSurface的代码实现如下：</p> 
<pre><code class="language-cpp">EGLSurface eglCreateWindowSurface(  EGLDisplay dpy, EGLConfig config,
                                    NativeWindowType window,
                                    const EGLint *attrib_list)
{
    return createWindowSurface(dpy, config, window, attrib_list);
}</code></pre> 
<p>继续分析createWindowSurface，代码实现如下：</p> 
<pre><code class="language-cpp">static EGLSurface createWindowSurface(EGLDisplay dpy, EGLConfig config,
        NativeWindowType window, const EGLint* /*attrib_list*/)
{
    if (egl_display_t::is_valid(dpy) == EGL_FALSE)
        return setError(EGL_BAD_DISPLAY, EGL_NO_SURFACE);
    if (window == 0)
        return setError(EGL_BAD_MATCH, EGL_NO_SURFACE);

    EGLint surfaceType;
    if (getConfigAttrib(dpy, config, EGL_SURFACE_TYPE, &amp;surfaceType) == EGL_FALSE)
        return EGL_FALSE;

    if (!(surfaceType &amp; EGL_WINDOW_BIT))
        return setError(EGL_BAD_MATCH, EGL_NO_SURFACE);

    if (static_cast&lt;ANativeWindow*&gt;(window)-&gt;common.magic !=
            ANDROID_NATIVE_WINDOW_MAGIC) {
        return setError(EGL_BAD_NATIVE_WINDOW, EGL_NO_SURFACE);
    }
        
    EGLint configID;
    if (getConfigAttrib(dpy, config, EGL_CONFIG_ID, &amp;configID) == EGL_FALSE)
        return EGL_FALSE;

    int32_t depthFormat;
    int32_t pixelFormat;
    if (getConfigFormatInfo(configID, pixelFormat, depthFormat) != NO_ERROR) {
        return setError(EGL_BAD_MATCH, EGL_NO_SURFACE);
    }
	
    egl_surface_t* surface;
    //创建egl_window_surface_v2_t对象
    surface = new egl_window_surface_v2_t(dpy, config, depthFormat,
            static_cast&lt;ANativeWindow*&gt;(window));

    if (!surface-&gt;initCheck()) {
        delete surface;
        surface = 0;
    }
    return surface;
}</code></pre> 
<p>这里专注分析egl_window_surface_v2_t，构造函数代码实现如下：</p> 
<pre><code class="language-cpp">egl_window_surface_v2_t::egl_window_surface_v2_t(EGLDisplay dpy,
        EGLConfig config,
        int32_t depthFormat,
        ANativeWindow* window)
    : egl_surface_t(dpy, config, depthFormat), 
    nativeWindow(window), buffer(0), previousBuffer(0), module(0),
    bits(NULL)
{
    hw_module_t const* pModule;
    hw_get_module(GRALLOC_HARDWARE_MODULE_ID, &amp;pModule);
    module = reinterpret_cast&lt;gralloc_module_t const*&gt;(pModule);

    pixelFormatTable = gglGetPixelFormatTable();
    
    // keep a reference on the window
    nativeWindow-&gt;common.incRef(&amp;nativeWindow-&gt;common);
    nativeWindow-&gt;query(nativeWindow, NATIVE_WINDOW_WIDTH, &amp;width);
    nativeWindow-&gt;query(nativeWindow, NATIVE_WINDOW_HEIGHT, &amp;height);
}</code></pre> 
<p>这里主要是一些初始化操作，从nativeWindow看出跟surface有关，从GRALLOC_HARDWARE_MODULE_ID来看也和 gralloc模块有关。会涉及 BufferQueue的一些操作。</p> 
<p><strong>2 DisplayDevice的两个关键方法</strong></p> 
<p>之所以分析这两个关键方法是因为 后面的章节 服务端分析4-handleMessageRefresh处理中 会有所涉及。</p> 
<p><strong>2.1 DisplayDevice的makeCurrent方法分析</strong></p> 
<p>makeCurrent代码实现如下：</p> 
<pre><code class="language-cpp">EGLBoolean DisplayDevice::makeCurrent(EGLDisplay dpy, EGLContext ctx) const {
    EGLBoolean result = EGL_TRUE;
    EGLSurface sur = eglGetCurrentSurface(EGL_DRAW);
    if (sur != mSurface) {
        result = eglMakeCurrent(dpy, mSurface, mSurface, ctx);
        //...
    }
    setViewportAndProjection();
    return result;
}</code></pre> 
<p>这里关注eglMakeCurrent的实现，代码如下：</p> 
<pre><code class="language-cpp">EGLBoolean eglMakeCurrent(  EGLDisplay dpy, EGLSurface draw,
                            EGLSurface read, EGLContext ctx)
{
    if (egl_display_t::is_valid(dpy) == EGL_FALSE)
        return setError(EGL_BAD_DISPLAY, EGL_FALSE);
    if (draw) {
        egl_surface_t* s = (egl_surface_t*)draw;// 1
        //...
    }
    //...
    ogles_context_t* gl = (ogles_context_t*)ctx;
    if (makeCurrent(gl) == 0) {
        if (ctx) {
            //...
            if (d) {
                if (d-&gt;connect() == EGL_FALSE) {
                    return EGL_FALSE;
                }
                d-&gt;ctx = ctx;
                d-&gt;bindDrawSurface(gl);
            }
            //...
        } else {
            //...
        }
        return EGL_TRUE;
    }
    return setError(EGL_BAD_ACCESS, EGL_FALSE);
}</code></pre> 
<p>这里主要关注一个connect方法，这个所谓的d类型是 egl_window_surface_v2_t，是egl_surface_t的子类，对应的connect代码实现如下：</p> 
<pre><code class="language-cpp">EGLBoolean egl_window_surface_v2_t::connect() 
{
    // we're intending to do software rendering
    native_window_set_usage(nativeWindow, 
            GRALLOC_USAGE_SW_READ_OFTEN | GRALLOC_USAGE_SW_WRITE_OFTEN);

    // dequeue a buffer
    int fenceFd = -1;
    if (nativeWindow-&gt;dequeueBuffer(nativeWindow, &amp;buffer,
            &amp;fenceFd) != NO_ERROR) {
        return setError(EGL_BAD_ALLOC, EGL_FALSE);
    }

    // wait for the buffer
    sp&lt;Fence&gt; fence(new Fence(fenceFd));
    if (fence-&gt;wait(Fence::TIMEOUT_NEVER) != NO_ERROR) {
        nativeWindow-&gt;cancelBuffer(nativeWindow, buffer, fenceFd);
        return setError(EGL_BAD_ALLOC, EGL_FALSE);
    }

    // allocate a corresponding depth-buffer
    width = buffer-&gt;width;
    height = buffer-&gt;height;
    if (depth.format) {
        depth.width   = width;
        depth.height  = height;
        depth.stride  = depth.width; // use the width here
        depth.data    = (GGLubyte*)malloc(depth.stride*depth.height*2);
        if (depth.data == 0) {
            return setError(EGL_BAD_ALLOC, EGL_FALSE);
        }
    }

    // keep a reference on the buffer
    buffer-&gt;common.incRef(&amp;buffer-&gt;common);

    // pin the buffer down
    if (lock(buffer, GRALLOC_USAGE_SW_READ_OFTEN | 
            GRALLOC_USAGE_SW_WRITE_OFTEN, &amp;bits) != NO_ERROR) {
        ALOGE("connect() failed to lock buffer %p (%ux%u)",
                buffer, buffer-&gt;width, buffer-&gt;height);
        return setError(EGL_BAD_ACCESS, EGL_FALSE);
        // FIXME: we should make sure we're not accessing the buffer anymore
    }
    return EGL_TRUE;
}</code></pre> 
<p>这里会发现，调用了nativeWindow的dequeueBuffer操作，在之前的分析中我们知道这个dequeuBuffer实际上是Surface的dequeuBuffer方法（通过hook方式）。最后会进入到 BufferQueueproducer相关的操作。</p> 
<p><strong>2.2 DisplayDevice的swapbuffer方法分析</strong></p> 
<p>swapbuffer代码实现如下：</p> 
<pre><code class="language-cpp">void DisplayDevice::swapBuffers(HWComposer&amp; hwc) const {
    if (hwc.initCheck() != NO_ERROR ||
            (hwc.hasGlesComposition(mHwcDisplayId) &amp;&amp;
             (hwc.supportsFramebufferTarget() || mType &gt;= DISPLAY_VIRTUAL))) {
        EGLBoolean success = eglSwapBuffers(mDisplay, mSurface);
        //...错误处理
    }

    status_t result = mDisplaySurface-&gt;advanceFrame();
	//...错误处理
}</code></pre> 
<p>这里专注分析eglSwapBuffers，代码实现如下：</p> 
<pre><code class="language-cpp">EGLBoolean eglSwapBuffers(EGLDisplay dpy, EGLSurface draw)
{
    if (egl_display_t::is_valid(dpy) == EGL_FALSE)
        return setError(EGL_BAD_DISPLAY, EGL_FALSE);

    egl_surface_t* d = static_cast&lt;egl_surface_t*&gt;(draw);
    if (!d-&gt;isValid())
        return setError(EGL_BAD_SURFACE, EGL_FALSE);
    if (d-&gt;dpy != dpy)
        return setError(EGL_BAD_DISPLAY, EGL_FALSE);

    // post the surface
    d-&gt;swapBuffers();

    // if it's bound to a context, update the buffer
    if (d-&gt;ctx != EGL_NO_CONTEXT) {
        d-&gt;bindDrawSurface((ogles_context_t*)d-&gt;ctx);
        egl_context_t* c = egl_context_t::context(d-&gt;ctx);
        if (c-&gt;read == draw) {
            d-&gt;bindReadSurface((ogles_context_t*)d-&gt;ctx);
        }
    }

    return EGL_TRUE;
}</code></pre> 
<p>这里专注分析d-&gt;swapBuffers()，而这个d类型是 egl_window_surface_v2_t，是egl_surface_t的子类，对应的swapBuffers代码实现如下：</p> 
<pre><code class="language-java">EGLBoolean egl_window_surface_v2_t::swapBuffers()
{
    if (!buffer) {
        return setError(EGL_BAD_ACCESS, EGL_FALSE);
    }

    if (!dirtyRegion.isEmpty()) {
        dirtyRegion.andSelf(Rect(buffer-&gt;width, buffer-&gt;height));
        if (previousBuffer) {
            // This was const Region copyBack, but that causes an
            // internal compile error on simulator builds
            /*const*/ Region copyBack(Region::subtract(oldDirtyRegion, dirtyRegion));
            if (!copyBack.isEmpty()) {
                void* prevBits;
                if (lock(previousBuffer, 
                        GRALLOC_USAGE_SW_READ_OFTEN, &amp;prevBits) == NO_ERROR) {
                    // copy from previousBuffer to buffer
                    copyBlt(buffer, bits, previousBuffer, prevBits, copyBack);
                    unlock(previousBuffer);
                }
            }
        }
        oldDirtyRegion = dirtyRegion;
    }

    if (previousBuffer) {
        previousBuffer-&gt;common.decRef(&amp;previousBuffer-&gt;common); 
        previousBuffer = 0;
    }
    
    unlock(buffer);
    previousBuffer = buffer;
    nativeWindow-&gt;queueBuffer(nativeWindow, buffer, -1);
    buffer = 0;

    // dequeue a new buffer
    int fenceFd = -1;
    if (nativeWindow-&gt;dequeueBuffer(nativeWindow, &amp;buffer, &amp;fenceFd) == NO_ERROR) {
        sp&lt;Fence&gt; fence(new Fence(fenceFd));
        if (fence-&gt;wait(Fence::TIMEOUT_NEVER)) {
            nativeWindow-&gt;cancelBuffer(nativeWindow, buffer, fenceFd);
            return setError(EGL_BAD_ALLOC, EGL_FALSE);
        }

        // reallocate the depth-buffer if needed
        if ((width != buffer-&gt;width) || (height != buffer-&gt;height)) {
            // TODO: we probably should reset the swap rect here
            // if the window size has changed
            width = buffer-&gt;width;
            height = buffer-&gt;height;
            if (depth.data) {
                free(depth.data);
                depth.width   = width;
                depth.height  = height;
                depth.stride  = buffer-&gt;stride;
                depth.data    = (GGLubyte*)malloc(depth.stride*depth.height*2);
                if (depth.data == 0) {
                    setError(EGL_BAD_ALLOC, EGL_FALSE);
                    return EGL_FALSE;
                }
            }
        }

        // keep a reference on the buffer
        buffer-&gt;common.incRef(&amp;buffer-&gt;common);

        // finally pin the buffer down
        if (lock(buffer, GRALLOC_USAGE_SW_READ_OFTEN |
                GRALLOC_USAGE_SW_WRITE_OFTEN, &amp;bits) != NO_ERROR) {
            ALOGE("eglSwapBuffers() failed to lock buffer %p (%ux%u)",
                    buffer, buffer-&gt;width, buffer-&gt;height);
            return setError(EGL_BAD_ACCESS, EGL_FALSE);
            // FIXME: we should make sure we're not accessing the buffer anymore
        }
    } else {
        return setError(EGL_BAD_CURRENT_SURFACE, EGL_FALSE);
    }

    return EGL_TRUE;
}</code></pre> 
<p>接下来主要对旧Buffer 和新Buffer 进行分析：</p> 
<p><strong>2.2.1 旧Buffer操作</strong></p> 
<p>这里对于旧Buffer，调用了nativeWindow的queueBuffer操作，在之前的分析中我们知道这个queuBuffer实际上是Surface的queueBuffer方法（通过hook方式），最后会进入到 BufferQueueProducer相关的操作。在执行了queueBuffer操作后，通过BufferQueue的接口最后会调用一个 onFrameAvailable的回调函数，代码如下：</p> 
<pre><code class="language-cpp">void FramebufferSurface::onFrameAvailable(const BufferItem&amp; /* item */) {
    sp&lt;GraphicBuffer&gt; buf;
    sp&lt;Fence&gt; acquireFence;
    status_t err = nextBuffer(buf, acquireFence);
    //...错误处理
    err = mHwc.fbPost(mDisplayType, acquireFence, buf);
    //...错误处理
}
</code></pre> 
<p>这里关注 nextBuffer 和后面fbPost方法。</p> 
<p>@1 nextBuffer代码实现如下：</p> 
<pre><code class="language-cpp">status_t FramebufferSurface::nextBuffer(sp&lt;GraphicBuffer&gt;&amp; outBuffer, sp&lt;Fence&gt;&amp; outFence) {
    Mutex::Autolock lock(mMutex);

    BufferQueue::BufferItem item;
    status_t err = acquireBufferLocked(&amp;item, 0);
    if (err == BufferQueue::NO_BUFFER_AVAILABLE) {
        outBuffer = mCurrentBuffer;
        return NO_ERROR;
    } 
	//...
    if (mCurrentBufferSlot != BufferQueue::INVALID_BUFFER_SLOT &amp;&amp;
        item.mBuf != mCurrentBufferSlot) {
        // Release the previous buffer.
        err = releaseBufferLocked(mCurrentBufferSlot, mCurrentBuffer,
                EGL_NO_DISPLAY, EGL_NO_SYNC_KHR);
        if (err &lt; NO_ERROR) {
            ALOGE("error releasing buffer: %s (%d)", strerror(-err), err);
            return err;
        }
    }
    mCurrentBufferSlot = item.mBuf;
    mCurrentBuffer = mSlots[mCurrentBufferSlot].mGraphicBuffer;
    outFence = item.mFence;
    outBuffer = mCurrentBuffer;
    return NO_ERROR;
}</code></pre> 
<p>这里最主要的是 执行了Acquire操作，取出Buffer</p> 
<p>@2 fbPost代码实现如下：</p> 
<pre><code class="language-cpp">int HWComposer::fbPost(int32_t id,
        const sp&lt;Fence&gt;&amp; acquireFence, const sp&lt;GraphicBuffer&gt;&amp; buffer) {
    if (mHwc &amp;&amp; hwcHasApiVersion(mHwc, HWC_DEVICE_API_VERSION_1_1)) {
        return setFramebufferTarget(id, acquireFence, buffer);
    } else {
        acquireFence-&gt;waitForever("HWComposer::fbPost");
        return mFbDev-&gt;post(mFbDev, buffer-&gt;handle);
    }
}</code></pre> 
<p>这里调用了mFbDev-&gt;post，和这个设备就是FrameBuffer的HAL层接口post方法（注册时被赋值为fb_post），因此最后会调用到FrameBuffer HAL层的方法fb_post，代码如下：</p> 
<pre><code class="language-cpp">
static int fb_post(struct framebuffer_device_t* dev, buffer_handle_t buffer)
{
    if (private_handle_t::validate(buffer) &lt; 0)
        return -EINVAL;

    fb_context_t* ctx = (fb_context_t*)dev;

    private_handle_t const* hnd = reinterpret_cast&lt;private_handle_t const*&gt;(buffer);
    private_module_t* m = reinterpret_cast&lt;private_module_t*&gt;(
            dev-&gt;common.module);

    if (hnd-&gt;flags &amp; private_handle_t::PRIV_FLAGS_FRAMEBUFFER) {
        const size_t offset = hnd-&gt;base - m-&gt;framebuffer-&gt;base;
        m-&gt;info.activate = FB_ACTIVATE_VBL;
        m-&gt;info.yoffset = offset / m-&gt;finfo.line_length;
        if (ioctl(m-&gt;framebuffer-&gt;fd, FBIOPUT_VSCREENINFO, &amp;m-&gt;info) == -1) {
            ALOGE("FBIOPUT_VSCREENINFO failed");
            m-&gt;base.unlock(&amp;m-&gt;base, buffer); 
            return -errno;
        }
        m-&gt;currentBuffer = buffer;
        
    } else {
        // If we can't do the page_flip, just copy the buffer to the front 
        // FIXME: use copybit HAL instead of memcpy
        
        void* fb_vaddr;
        void* buffer_vaddr;
        
        m-&gt;base.lock(&amp;m-&gt;base, m-&gt;framebuffer, 
                GRALLOC_USAGE_SW_WRITE_RARELY, 
                0, 0, m-&gt;info.xres, m-&gt;info.yres,
                &amp;fb_vaddr);

        m-&gt;base.lock(&amp;m-&gt;base, buffer, 
                GRALLOC_USAGE_SW_READ_RARELY, 
                0, 0, m-&gt;info.xres, m-&gt;info.yres,
                &amp;buffer_vaddr);

        memcpy(fb_vaddr, buffer_vaddr, m-&gt;finfo.line_length * m-&gt;info.yres);
        
        m-&gt;base.unlock(&amp;m-&gt;base, buffer); 
        m-&gt;base.unlock(&amp;m-&gt;base, m-&gt;framebuffer); 
    }
    
    return 0;
}
</code></pre> 
<p>这里最主要的是 消费Buffer，执行Post操作将Buffer推给Framebuffer来显示了。</p> 
<p><strong>2.2.2 新Buffer操作</strong></p> 
<p>对于新Buffer，又重现调用了dequeueBuffer的操作，进入下一次的 处理。</p> 
<p><strong>2.3 两个关键方法的总结</strong></p> 
<ol><li>这里makeCurrent 是对应dequeueBuffer操作。</li><li>SwapBuffer对应旧Buffer的queueBuffer操作，新Buffer的dequeueBuffer操作。</li></ol> 
<p></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/f5e384c24a7a07aeec5ea6e33d6b9e48/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">工具使用【PDManer】</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/fd9e074be43c792d4ff1b7e2a6fc0c26/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">Java中23种经典设计模式详解</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>