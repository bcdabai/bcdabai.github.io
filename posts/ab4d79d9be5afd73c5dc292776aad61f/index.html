<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>memory1 - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="memory1" />
<meta property="og:description" content="Memory day1 [root@zxd ~]# timedatectl Local time: 六 2023-08-26 14:11:06 CST#当地时间 Universal time: 六 2023-08-26 06:11:06 UTC#世界时间 RTC time: 六 2023-08-26 06:11:05#实时时钟时间 Time zone: Asia/Shanghai (CST, &#43;0800)#时区，CST即东八区时间 NTP enabled: no#NTP未开启，NTP是国家时间规划 NTP synchronized: no#NTP同步未开启 RTC in local TZ: no#实是时钟不是当地时钟 DST active: n/a#夏令时有效 不适用 #主要是看时区用的命令 ​
[root@zxd ~]# date 2023年 08月 26日 星期六 14:39:02 CST #查看系统时间 [root@zxd ~]# date -R Sat, 26 Aug 2023 14:39:50 &#43;0800 #查看时区(数字形式) [root@zxd ~]# date -s &#39;2077-12-12 11:11:11&#39; 2077年 12月 12日 星期日 11:11:11 CST #&#39;年-月-日 中间至少有一个空格 时：分：秒&#39; #修改系统时间的命令 [root@zxd ~]# date &#34;" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/ab4d79d9be5afd73c5dc292776aad61f/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-11-30T13:46:34+08:00" />
<meta property="article:modified_time" content="2023-11-30T13:46:34+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">memory1</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <h2><a id="Memory_0"></a><strong>Memory</strong></h2> 
<h3><a id="day1_2"></a><strong>day1</strong></h3> 
<pre><code class="prism language-ini">[root@zxd ~]# timedatectl 
 Local time: 六 2023-08-26 14:11:06 CST#当地时间
  Universal time: 六 2023-08-26 06:11:06 UTC#世界时间
        RTC time: 六 2023-08-26 06:11:05#实时时钟时间
       Time zone: Asia/Shanghai (CST, +0800)#时区，CST即东八区时间
     NTP enabled: no#NTP未开启，NTP是国家时间规划
NTP synchronized: no#NTP同步未开启
 RTC in local TZ: no#实是时钟不是当地时钟
      DST active: n/a#夏令时有效 不适用
      #主要是看时区用的命令
</code></pre> 
<p>​</p> 
<pre><code class="prism language-ini">[root@zxd ~]# date
2023年 08月 26日 星期六 14:39:02 CST
#查看系统时间


[root@zxd ~]# date -R
Sat, 26 Aug 2023 14:39:50 +0800
#查看时区(数字形式)


[root@zxd ~]# date -s '2077-12-12    11:11:11'
2077年 12月 12日 星期日 11:11:11 CST
#'年-月-日   中间至少有一个空格  时：分：秒'
#修改系统时间的命令


[root@zxd ~]# date "+%F %@$&amp;（！ +%T"
2077-12-12 %@$&amp;（！ +11:15:06
[root@zxd ~]# date +%F
2077-12-12
[root@zxd ~]# date +%X
11时17分02秒
[root@zxd ~]# date +%T
11:17:11


[root@zxd ~]# hwclock
2023年08月26日 星期六 14时54分05秒  -0.897403 秒
[root@zxd ~]# hwclock -r
2023年08月26日 星期六 14时54分37秒  -0.541367 秒
#hwclock 或hwclock -r ----查询硬件时间


[root@zxd ~]# hwclock --set --date '2050-12-12 12:12:12' 
[root@zxd ~]# hwclock
2050年12月12日 星期一 12时12分24秒  -0.548090 秒
#修改硬件时间的命令


[root@zxd ~]# hwclock --hctosys#硬件时间与系统时间同步
[root@zxd ~]# hwclock --systohc#系统时间与硬件时间同步
#两个时间同步的命令


[root@zxd ~]# yum install -y ntpdate

[root@zxd ~]# ping baidu.com    #验证是否联网
PING baidu.com (39.156.66.10) 56(84) bytes of data.
64 bytes from 39.156.66.10 (39.156.66.10): icmp_seq=2 ttl=49 time=49.7 ms

[root@zxd ~]# ntpdate ntp.aliyun.com	 #阿里云的授时中心
[root@zxd ~]# ntpdate time.windows.com    #win的授时中心
#将系统时间、硬件时间和世界时间同步

</code></pre> 
<pre><code class="prism language-ini">[root@zxd ~]# init 0
[root@zxd ~]# poweroff
#关机的两个命令，等价

[root@zxd ~]# init 6
[root@zxd ~]# reboot
#开机的两个命令，等价

init 3是GUI界面转换成mini界面
</code></pre> 
<pre><code class="prism language-ini">常用的路径
#   /etc/sysconfig/network-scripts/ifcfg-ens33  ---网卡路径
#   /etc/passwd ---系统用户密码存储路径
#   /etc/group  ---系统组存储路径
#   /home	    ---默认的用户都在这里产生自己的家目录	
#   /etc/fstab  ---系统自动挂载磁盘分区的文件
#	/etc/selinux/config  ---selinux的配置文件
#	/etc/sysconfig/selinux  ---selinux的软链接路径，一样到配置文件那
#	/etc/httpd/conf/httpd.conf ---httpd的配置文件
#	/etc/nginx/nginx.conf ---nginx的配置文件
#	/etc/ssh/sshd.conf
#	/etc/
</code></pre> 
<pre><code class="prism language-ini">Tips
# find 如果没有加参数，默认在选定范围内查找出所有文件，包含隐藏文件
[root@lbj ~]# find /root 
/root
/root/.bash_logout
/root/.bash_profile
/root/.bashrc
/root/.cshrc
/root/.tcshrc
/root/anaconda-ks.cfg
/root/.bash_history
/root/.viminfo

#ls 的a参数，可以显示隐藏文件，这个. 和..两个目录先不用管
[root@lbj ~]# ls -a /root
.  ..  anaconda-ks.cfg  .bash_history  .bash_logout  .bash_profile  .bashrc  .cshrc  .tcshrc  .viminfo

#find 也可以直接只查隐藏文件
[root@lbj ~]# find /etc -name ".*"
/etc/skel/.bash_logout
/etc/skel/.bash_profile
/etc/skel/.bashrc
/etc/selinux/targeted/.policy.sha512
/etc/.pwd.lock
/etc/.updated

#不知道路径了，可以用find查路径
find / -name "文件名或目录名"
</code></pre> 
<pre><code class="prism language-ini">Tips

\t 制表符，自动补齐，相互保持8个长度

\a 蜂鸣器，可以当作程序运行完的提示音

\n 换行

\r ：1）右边为主。右边有多少内容就在结果上有多少内容
	2）自动补齐。“\r”的左边和右边，谁长度最大，结果的长度就是最长的长度；如果		右边内容全部长度小于最终长度，就在左边补齐长度，截取的内容以"\r"为结束点。
	# \r的示例
[root@zxd /]# echo -e "abcd\rr"
rbcd
[root@zxd /]# echo -e "abcd\rrmff"
rmff
[root@zxd /]# echo -e "abcd\rrmf"
rmfd
[root@zxd /]# echo -e "abcd\rrm"
rmcd
[root@zxd /]# echo -e "abcde\rrm"
rmcde
[root@zxd /]# echo -e "abcde\rrmcvd"
rmcvd
</code></pre> 
<pre><code class="prism language-ini">Tips
/ 下的所有目录：

bin -&gt;usr/bin  可执行的二进制文件、普通命令

sbin -&gt;usr/sbin  可执行的二进制文件、超级命令

boot     		系统启动的相关文件

dev  			像USB、硬盘这种的文件

etc 			默认的配置文件存放目录

home  			默认的用户家目录存放处

lib -&gt; usr/lib 	library32，库文件

lib65 -&gt; usr/lib64 	library64，库文件

mnt 			系统预设的磁盘分区挂载点区域

proc  			虚拟内核映射目录，看系统运行情况的

root 			超级用户的家目录

run				存放像pid这种和进程相关的文件区域

srv				服务启动产生的数据存放区域

sys 			系统相关文件区域

tmp				系统临时文件区域，类似回收站

usr				服务相关文件、文档、程序

var				存放可变数据的目录

media     		用于挂载u盘，光驱等自动识别的设备
</code></pre> 
<pre><code class="prism language-ini">Tips
ctr+a 光标回到命令的开头处
ctr+e 光标回到命令的结尾处
</code></pre> 
<pre><code class="prism language-ini">#更改系统语言
[root@zxd /]# export LANG='en_US.UTF-8'  #美式英语
[root@zxd /]# export LANG='zh_CN.UTF-8'  #简体中文
</code></pre> 
<pre><code class="prism language-ini">#调用历史命令的三种途径
history ，找到想要的历史命令直接复制然后粘贴来调用
history ，然后找到相应的历史命令的编号，然后 '!+编号'来调用
ctr+r+关键词 ，reverse---r，调用最近含关键词的历史命令 
</code></pre> 
<h3><a id="day2_220"></a><strong>day2</strong></h3> 
<pre><code class="prism language-ini">[root@qfedu ~]# touch 文件名称.后缀
[root@qfedu ~]# touch file1.txt  #无则创建，如果存在修改时间
[root@qfedu ~]# touch /home/file10.txt
[root@qfedu ~]# touch /home/{zhuzhu,gougou} #{}集合
[root@qfedu ~]# touch /home/file{1..20}  #批量创建
</code></pre> 
<pre><code class="prism language-ini">echo  加内容   &gt;  加文件名    
#'&gt;'是覆盖:把之前的内容替换掉。
#可以加空内容来重置文件内容，常用以清理各种不需要的日志文件内容
#还可以直接创建新文件并加上内容
#这里说一下''和""的区别，如果内容含有如( )这种特殊的符号，只能用''


echo  加内容  &gt;&gt; 加文件名     
#'&gt;&gt;'是追加:保留之前的内容,在后面添加新内容
# echo 345345 &gt;&gt; a.txt
#当使用echo 123 &gt;&gt; a.txt 这个命令的时候在文件不存在的时候会创建该文件并将内容追加到改文件中
</code></pre> 
<pre><code class="prism language-ini"># mkdir dir1
创建两个目录：
# mkdir /home/dir2 /home/dir3
# mkdir /home/{dir4,dir5} 
# mkdir -v /home/{dir6,dir7}   #-v ：verbose 冗长的。显示创建时的详细信息
# mkdir -p /home/dir8/111/222  #-p 创建连级目录，一级一级的创建。如果确保了路径的目录都存在也可以不加p
</code></pre> 
<pre><code class="prism language-ini"># mkdir /home/dir{1,2}  #创建目录
# cp -v anaconda-ks.cfg /home/dir1/  #-v 显示详细信息
# cp anaconda-ks.cfg /home/dir1/test.txt  #复制并改文件名，会改变文件的mtime
# cp -r /etc /home/dir1             #-r 拷贝目录使用，连同目录里面的文件一块拷贝
# cp -r /etc /tmp					#拷贝目录
#\cp 强制复制

语法: cp  -r  源文件1 源文件2 源文件N  目标目录    #将多个文件拷贝到同一个目录
# cp  /etc/sysconfig/network-scripts/ifcfg-ens33 /etc/passwd /etc/hosts

#拷贝中有目录，必须加r参数
</code></pre> 
<pre><code class="prism language-ini">1.创建一个新文件file1
[root@qfedu ~]# touch /root/file1
2.把file1文件移动到/tmp目录中。
[root@qfedu ~]# mv /root/file1 /tmp/
[root@qfedu ~]# ls /tmp/file1 
/tmp/file1
3.把file1文件更名为file2，但不会改变文件的mtime
[root@qfedu ~]# mv /tmp/file1 /tmp/file2
4.观察file1文件已经更名为file2
[root@qfedu ~]# cd /tmp/
[root@qfedu tmp]# ls
file2

#mv 可以移动目录，也能移动文件，也可以在移动时改名目录或文件

#mv 移动目录并改名的案例，mv移动目录是不用加r参数
[root@lbj ~]# mkdir /root/dir1
[root@lbj ~]# mv   /root/dir1 /tmp/dir2
[root@lbj ~]# echo $?            #常用命令，返回值是0代表上步代码执行成功，非0就是执行错误
0
[root@lbj ~]# ls /root
anaconda-ks.cfg
[root@lbj ~]# ls /tmp/
dir2  
</code></pre> 
<pre><code class="prism language-ini"># cd /home/
# rm -rf dir1/

-r 递归，删除目录时
-f force强制
-v 详细过程

[root@qfedu ~]# mkdir /home/dir10
[root@qfedu ~]# touch /home/dir10/{file2,file3,.file4}
[root@qfedu ~]# rm -rf /home/dir10/*  //不包括隐藏文件 #细节，删除不了隐藏文件，*并不能代表隐藏文件
[root@qfedu ~]# ls /home/dir10/ -a 
.  ..  .file4

[root@qfedu ~]# touch {1..10}.txt
[root@qfedu ~]# touch file{1..20}.txt  #创建file1-10的txt文件
[root@qfedu ~]# rm -rf file1*

</code></pre> 
<pre><code class="prism language-ini">[root@qfedu ~]# cat /etc/passwd
root:x:0:0:root:/root:/bin/bash
bin:x:1:1:bin:/bin:/sbin/nologin
daemon:x:2:2:daemon:/sbin:/sbin/nologin
adm:x:3:4:adm:/var/adm:/sbin/nologin
...

参数：
-n 显示行号
-A 包括控制字符（换行符/制表符）
</code></pre> 
<pre><code class="prism language-ini">[root@qfedu ~]# head /etc/passwd     #默查看前十行
[root@qfedu ~]# head -2 /etc/passwd  #默认查看前两行
</code></pre> 
<pre><code class="prism language-ini">[root@qfedu ~]# tail /etc/passwd         #默认查看文件的后十行
[root@qfedu ~]# tail -1 /etc/passwd      #查看文件最后一行
[root@qfedu ~]# tail /var/log/messages
[root@qfedu ~]# tail -f /var/log/secure  #-f 动态查看文件的尾部
[root@qfedu ~]# tailf /var/log/secure    #功能同上
[root@qfedu ~]# tail -F /root/file  #-F  #生成不存在的文件 “file已被建立，正在跟随新文件的末尾”
</code></pre> 
<pre><code class="prism language-ini">过滤文件中带有root的内容：
[root@qfedu ~]# grep 'root' /etc/passwd
过滤以root开头的行：^ --以什么开头
[root@qfedu ~]# grep '^root' /etc/passwd
过滤以bash结尾的行：$ --以什么结尾
[root@qfedu ~]# grep 'bash$' /etc/passwd
</code></pre> 
<pre><code class="prism language-ini">[root@qfedu ~]# less /etc/makedumpfile.conf.sample（终端使用的，因为终端不能往上翻）
1.空格键是翻页  回车键是翻行
2.上下箭头可以来回翻
3. /关键字     #搜索 (n按关键字往下翻   N按关键字往上翻)
4.快捷键:q -quit 退出
</code></pre> 
<pre><code class="prism language-ini">[root@qfedu.com ~]# more  文件名    				（终端使用的，因为终端不能往上翻）	   
空格键是向下翻页  回车键是翻行
Ctrl+B 向上翻页
</code></pre> 
<h3><a id="day3_364"></a><strong>day3</strong></h3> 
<pre><code class="prism language-ini">[root@qfedu.com ~]# vim   文件名
正常模式是使用vim打开文件时的默认模式
无论在哪种模式下，按下Esc键就会进入正常模式。

#正常模式
在这个模式下：
    可以移动光标
    选中行，复制
    可以增、删
         yy      #复制 
         3yy     #从光标开始复制3行。
         yy3     #复制光标所在行3次
         ygg     #从当前光标复制到页首
         yG      #从光标开始复制到页尾
         dd      #剪切一行
         3dd     #从光标开始删除3行
         dgg     #从光标开始删除到s页首 
         dG      #从光标开始删除到页尾
         d^    	 #删除当前光标之前的内容,不删除光标本身字符，只删除光标所在行
         p       #粘贴到本行的下一行
         大P     #粘贴到本行的上一行
         x       #删除光标所在的字符
         u       #undo撤销
         r  	 #可以用来修改一个字符
         (D)shift +d或d$	#删除本行的光标及以后的内容,只是删光标所在行
         gg      #回到页首
         G       #回到页尾
</code></pre> 
<pre><code class="prism language-ini">#命令模式
在正常模式下输入:或/进入命令行模式
在该模式下可以进行保存，搜索，替换，退出，显示行号等。
/string     #查找字符，从前往后找，n下一个，N上一个    (n N 可以循环的)
?string     #查找字符，从后往前找，n下一个，N上一个    (n N 可以循环的)

语法----&gt; :范围 s/old/new/选项 
: s/world/nice/         #替换当前光标所在行
:3 s/sbin/nice/         #替换指定行
:1,5 s/nologin/soso/   #从1－5行的nologin 替换为soso
:% s/bin/soso/          #替换所有行
:% s/sbin/nice/g        #替换行内所有关键字
#上面的search命令中，三个'/'可以写成其他字符，只要保持一样就行
#注释：%表示替换所有行  g表示行内所有关键字，global

#将文件另存(另存为)
语法----&gt; :w 存储到当前文件
:w /tmp/aaa.txt    #另存为/tmp/aaa.txt 
:1,3 w /tmp/2.txt  #从1-3行的内容另存为/tmp/2.txt

:set nu    #设置行号 number
:set list  #显示控制字符 看有没有隐藏字符，如结尾有空格没
:set nonu  #取消设置行号 no number
:set ts=4  #设置制表符为4，一下tab就移动四个空格

#给文件设密码或取消密码
vim /etc/passwd 
:set key=
#不写就没密码，写的话就是统一设密码
</code></pre> 
<pre><code class="prism language-ini">#编辑模式
i		#在光标所在处进入编辑模式
a		#在当前光标后面进入编辑模式
o		#在光标的下一行进入编辑模式
I		#在光标所在处行首进入编辑模式
A		#在光标所在处行尾进入编辑模式
O		#在光标的上一行进入编辑模式
</code></pre> 
<pre><code class="prism language-ini">#可视块模式
ctrl+v     #进入可视块模式  批量加注释---&gt; ctr+v 、shift+i、 #、 esc  ;  											ctr+v 、 可以使用正常模式下的命令   、 d（删除）
		  #可视块下可以使用编辑命令和命令行模式下的命令，但是用不了尾行模式的命令
		  #比如，问你怎么把5到2888行的内容给注释掉（目前未完美解决）
		  #由于不能在可视块的状态下使用尾行模式跳转行，所以你应该先进入尾行模式跳转到2888行，然进入可视块，然后I插		   入#，然后esc

shift+v    #进入可视行模式 ，用处不大
</code></pre> 
<pre><code class="prism language-ini">#Tips
vim +number 文件名  #在进入文件后，光标直接可以跳到对应行号数字的那行
：number #在进入命令模式后，直接输数字可以跳到该行
ZZ    #可以不用进入命令模式，直接保存退出文件
</code></pre> 
<h3><a id="day4_455"></a><strong>day4</strong></h3> 
<pre><code class="prism language-ini">- rw- r-- r--. 1 root root 2103  5月  5 15:10 /etc/passwd
   u   g   o
权限对象：
属主-------&gt;u
属组-------&gt;g
其他人------&gt;o

基本权限类型：
读(read)：r   ----&gt;4
写(write)：w  ----&gt;2
执行(exec)：x ----&gt;1
</code></pre> 
<h4><a id="_471"></a><strong>目录自带的".“和”…"两个目录的案例（相对路径，绝对路径的例子）</strong></h4> 
<pre><code class="prism language-ini">[root@lbj tmpt]# stat .
  文件："."
  大小：6               块：0          IO 块：4096   目录
设备：fd00h/64768d      Inode：51111849    硬链接：2
权限：(0644/drw-r--r--)  Uid：(    0/    root)   Gid：(    0/    root)
最近访问：2023-08-30 23:19:17.414181163 -0400
最近更改：2023-08-30 23:17:52.389179669 -0400
最近改动：2023-08-30 23:19:00.898180873 -0400
创建时间：-
[root@lbj tmpt]# stat ../tmpt
  文件："../tmpt"
  大小：6               块：0          IO 块：4096   目录
设备：fd00h/64768d      Inode：51111849    硬链接：2
权限：(0644/drw-r--r--)  Uid：(    0/    root)   Gid：(    0/    root)
最近访问：2023-08-30 23:19:17.414181163 -0400
最近更改：2023-08-30 23:17:52.389179669 -0400
最近改动：2023-08-30 23:19:00.898180873 -0400
创建时间：-
[root@lbj tmpt]# stat /tmp/tmpt
  文件："/tmp/tmpt"
  大小：6               块：0          IO 块：4096   目录
设备：fd00h/64768d      Inode：51111849    硬链接：2
权限：(0644/drw-r--r--)  Uid：(    0/    root)   Gid：(    0/    root)
最近访问：2023-08-30 23:19:17.414181163 -0400
最近更改：2023-08-30 23:17:52.389179669 -0400
最近改动：2023-08-30 23:19:00.898180873 -0400
创建时间：-
#可以发现 			  /tmp/tmpt 与../tmpt 和 . 是同一个目录，默认的"."和 ".."目录没有其他的实际意义，大概相当于					 路标一样的作用
#stat 文件名     	   可以详细查看文件信息，比ll还详细
</code></pre> 
<pre><code class="prism language-ini">chown:改变文件或目录的所属主以及所属组
chmod:为文件或目录设置访问权限
</code></pre> 
<pre><code class="prism language-ini">#chown   -R(加R针对一堆，就是连目录和目录下的文件和目录一起改)
[root@linux-server ~]# chown 用户.组 文件或目录
[root@linux-server ~]# chown alice.hr file1.txt  #修改属主、属组
[root@linux-server ~]# chown tom  file1.txt  #修改属主
[root@linux-server ~]# chown .it file1.txt   #只改属组
[root@linux-server ~]# chown -R alice.hr dir1 #递归修改---针对目录
</code></pre> 
<pre><code class="prism language-ini">#chmod   -R(加R针对一堆，就是连目录和目录下的文件和目录一起改)
[root@linux-server ~]# chmod u+x file1.txt     #属主增加执行
[root@linux-server ~]# chmod a=rwx file1.txt   #所有人等于读写执行
[root@linux-server ~]# chmod a=- file1.txt     #所有人都没有权限
[root@linux-server ~]# chmod ug=rw,o=r file1.txt  #属主属组等于读写，其他人只读
[root@linux-server ~]# ll
-rw-rw-r--. 1 tom   it      0 Nov  1 15:30 file1.txt
</code></pre> 
<pre><code class="prism language-ini">#chmod    -R(加R针对一堆，就是连目录和目录下的文件和目录一起改)
[root@linux-server ~]# chmod 644 file1.txt 
[root@linux-server ~]# ll file1.txt 
-rw-r--r--. 1 tom it 0 Nov  1 15:30 file1.txt

[root@linux-server ~]# chmod 755 file1.txt
[root@linux-server ~]# ll
-rwxr-xr-x  1 root root    0 Jul 23 22:40 file1.txt

[root@linux-server ~]# chmod 521 file1.txt
[root@linux-server ~]# ll
-r-x-w---x  1 root root    0 Jul 23 22:40 file1.txt
</code></pre> 
<h4><a id="rwx_544"></a><strong>观察目录的r、w、x对于其他用户的影响</strong></h4> 
<h5><a id="x_546"></a><strong>x的影响</strong></h5> 
<pre><code class="prism language-ini">#1	其他人、属组成员都没有x而有其他权限，结果不能访问目录
[root@lbj tmpt]# ll -d .
drw-r--r-- 2 root root 45 Aug 30 23:32 .
[jack@lbj ~]$ cd /tmp/tmpt/
-bash: cd: /tmp/tmpt/: Permission denied
#2	其他人、属组成员都只有x
[root@lbj tmpt]# chmod -R  611 .
[root@lbj tmpt]# ll -d .
drw---x--x 2 root root 45 Aug 30 23:32 .  			    #其他人和组员只有x权限
[root@lbj tmpt]# su - jack
Last login: Wed Aug 30 23:32:38 EDT 2023 on pts/0
[jack@lbj ~]$ cd /tmp/tmpt
[jack@lbj tmpt]$ vim file1
~                                                                                                        
"file1" [Permission Denied]  						   #表示不能读，有东西也看不到，没有读权限
i进入编辑模式就会出现警告
~                                                                                                        
-- INSERT -- W10: Warning: Changing a readonly file      #表示不能写权限，没有写权限
[root@lbj tmpt]# ll									  
总用量 4
-rw---x--x 1 root root 8 8月  30 23:32 file1
-rw---x--x 1 root root 0 8月  30 23:31 file2
-rw---x--x 1 root root 0 8月  30 23:31 file3
[root@lbj tmpt]# ll -d .
drw---x--x 2 root root 45 8月  30 23:32 .
[root@lbj tmpt]# su - jack
上一次登录：三 8月 30 23:42:44 EDT 2023pts/0 上
[jack@lbj ~]$ ./file1
bash: ./file1: Permission denied 						#其他人和组员光有x的目录权限，依旧不能执行文件
#3	在2的条件下只加上w权限
[jack@lbj ~]$ ./file1								   #rx或wx或rwx时，其他人和组员才能执行文件
#4	在2的条件下只加上r权限							  
[jack@lbj ~]$ ./file1

#	x的权限影响的是文件能不能被执行，可以进入文件内但是看不到内容也编辑不了内容，“.sh”结尾的文件是脚本文件；		对于目录来说，x权限可以控制其他人进入目录的自由，有x才能cd进去，才是执行目录中脚本文件或其他可执行文件的前 	    提之一；																						一每个文件能否被执行，不仅要看目录是否有x权限，还要看目录是否给了r或w或rw权限，否正也不能以“./”的方式执行文件。
</code></pre> 
<h5><a id="w_586"></a><strong>w的影响</strong></h5> 
<pre><code class="prism language-ini">#其他人和组员只有w权限，无法进入目录，但是他们可以随意在该目录下删除创建文件。
可以把目录下的东西理解为它的内容，有w写入权限那就可以任意对内容进行改动，比如删除内容添加内容。
#w权限影响的是vi、vim、echo这类能改变文件内容的命令，对于目录来说就是rm、cp、mv、mkdir、touch这种创建改变目录下的内容的命令
</code></pre> 
<h5><a id="r_594"></a>r的影响</h5> 
<pre><code class="prism language-ini">#只有r权限，其他人和组员是无法正常使用读权限的，必须获得目录的x权限的前提下才可以
root@lbj tmpt]# chmod 644 .
[root@lbj tmpt]# ll -d .
drw-r--r-- 2 root root 45 Aug 30 23:32 .
[root@lbj tmpt]# su jack
[jack@lbj tmpt]$ cd ..
[jack@lbj tmp]$ cd tmpt/
bash: cd: tmpt/: Permission denied
[jack@lbj tmp]$ cat tmpt/file1
cat: tmpt/file1: Permission denied
#r权限影响的是各类的获取文件内容的命令，对于目录来说是ll、ls这类展示目录下面的内容的命令
</code></pre> 
<h5><a id="sum_610"></a><strong>sum</strong></h5> 
<pre><code class="prism language-ini">#其他人在有目录x权限的前提下，能不能看目录下面文件的内容，取决于目录的权限和文件本身的权限，缺一不可。
	对于其他人，目录有wx或rx或rwx权限时，文件有r权限就能看内容，文件有w权限就能编辑内容，文件有x权限就能以"./文件名"的形式执行该文件；
	其他人想要删除复制移动目录下的目录和文件，只需要有目录的w权限即可。
</code></pre> 
<h5><a id="_618"></a>一些小命令</h5> 
<pre><code class="prism language-ini">#stat 文件名  比ls、ll更详细的展示文件信息
[root@lbj ~]# stat /root/file1
  File: ‘/root/file1’
  Size: 0               Blocks: 0          IO Block: 4096   regular empty file
Device: fd00h/64768d    Inode: 33622198    Links: 1
Access: (0644/-rw-r--r--)  Uid: (    0/    root)   Gid: (    0/    root)
Access: 2023-08-31 06:48:53.654065275 -0400
Modify: 2023-08-31 06:40:24.405056328 -0400
Change: 2023-08-31 06:46:48.764063081 -0400
 Birth: -

#which 查二进制命令文件好用（如ls、cat、mv、cp这类的命令），只会在下面绿色的范围内找，但是名字不完整就不行（如只写ens33）
[root@lbj tmpt]# which nginx
/usr/sbin/nginx
[root@lbj tmpt]# cd
[root@lbj ~]# which ens33
/usr/bin/which: no ens33 in (/usr/local/bin:/bin:/usr/bin:/usr/local/sbin:/usr/sbin:/home/jack/.local/bin:/home/jack/bin)
[root@lbj ~]# which  mysql
/usr/bin/which: no mysql in (/usr/local/bin:/bin:/usr/bin:/usr/local/sbin:/usr/sbin:/home/jack/.local/bin:/home/jack/bin)
[root@lbj ~]# which cat
/bin/cat

#whereis 查二进制命令文件好用，查完整的名字可以查，但是名字不完整就不行（如只写ens33）
[root@lbj ~]# whereis cat
cat: /usr/bin/cat /usr/share/man/man1/cat.1.gz
[root@lbj ~]# whereis mysql
mysql: /usr/lib64/mysql /usr/share/mysql
[root@lbj ~]# whereis ens33
ens33:[root@lbj ~]# 

#功能强大的还是find，按大小、时间和名字的部分特征就可以查找，可以自定义查找范围
语法：find 范围 -size或-name或-atime（access，最近访问时间）或-mtime（modify，最后修改时间）或-ctime（change，最后改变世界） "文件或目录的部分特征"

#wc -l,统计数目,很好用
[root@qfedu.com ~]# du -h /etc/   #查看目录及目录中的文件大小
[root@qfedu.com ~]# du -sh /etc/  #查看目录的总大小
[root@qfedu.com ~]# ls /etc/ | wc -l #查看目录中有多少个文件
</code></pre> 
<h4><a id="_660"></a>权限掩码</h4> 
<h5><a id="umask_662"></a>umask用户掩码</h5> 
<pre><code class="prism language-ini">控制用户创建文件和目录的默认权限
</code></pre> 
<pre><code class="prism language-ini">#root用户默认最高权限
目录---777 文件---666

#查看umask
[root@qfedu.com ~]# umask
0022 root账户默认
0002 普通用户默认

#通过计算得出root用户创建目录和文件的权限为:
也是现在root用户创建完目录和文件的默认权限:
目录:755
文件:644

#修改umask（临时的）
[root@qfedu.com ~]# umask 0111
#要开机就自动改的，写在一个隐藏文件中，是控制开机启动的文件
</code></pre> 
<h5><a id="_687"></a>高级权限</h5> 
<pre><code class="prism language-ini">高级权限 suid 二进制命令文件（如ls、cat、mv、cp、rm等）
sgid,sticky 目录
这三个权限不能给到同一个文件

suid ==== 4 提权 （只对二进制命令文件生效，其他不管用）
sgid ==== 2 继承属组权限    （只能对目录设置）
sticky == 1 (t权限)  权限控制

a、字符---语法：
chmod u+s file	提权
chmod g+s dir 	只能对目录设置，继承目录的权限
chmod o+t dir   只能对目录设置，即使有删除权限，也不能删除（除了自己和root用户可以删除其他人都不行）

b、数字
chmod 4777 file 	
chmod 2770 dir 		
chmod 1770 dir

#suid的实例，目标是二进制命令文件，获得和root一样的使用该命令的待遇
[root@linux-server ~]# chmod u+s /usr/bin/rm  #给予提权，普通用户使用rm命令时和root一样的待遇
[root@linux-server ~]# chmod u-s /usr/bin/rm  #取消提权
#u+s，有时候会原来x的位置显示s或S：如果属主权限不为7，那么最后就会显示为S，如果为7就会显示s

#sgid的实例，使用对象目录，如果用户在此目录下具有w权限的话，使用者在此目录下建立新文件，则创建的这个文件的群组与此目录的群组相同。
[root@linux-server ~]# chown .hr /opt/dir1/  #设置属组
[root@linux-server ~]# chmod g+s /opt/dir1/  #设置sgid
确保其他人在这个目录dir1中有w权限，然后其他人在这个dir1的目录中创建的文件都会是hr组
[root@lbj tmp]# chmod o+t passwd
[root@lbj tmp]# chmod o+t passwd2
#g+s，有时候会原来x的位置显示s或S：如果属组权限不为7，那么最后就会显示为S，为7就会显示s

#sticky的实例，使用对象是目录，对于目录的作用是：当用户在该目录下建立文件或目录时，仅有自己与root才有权力删除。
[root@linux-server home]# chmod o+t dir2/
[root@linux-server home]# su - alice 
[alice@linux-server ~]$ touch /home/dir2/alice.txt
[root@linux-server home]# su - jack
[jack@linux-server ~]$ rm -rf /home/dir2/alice.txt 
rm: cannot remove ‘/home/dir2/alice.txt’: Operation not permitted
测试jack删除alice创建的文件，无法删除
#o+t，有时候会原来x的位置显示t或T：如果其他人权限不为7，那么最后就会显示为T，如果为7，那么就会显示t
</code></pre> 
<h5><a id="ACL_732"></a>访问控制权限（特殊权限ACL，权限符+）</h5> 
<pre><code class="prism language-ini">#ACL：access control list，ACL可以针对单一用户、单一文件、单一目录或某一个组，来进行r、w、x的权限控制。应用场景如某一个文件，不让某个特定的用户访问。

setfacl的参数：
			-b：删除全部的acl参数
			-m：设置后续的acl参数
			-x：删除后续的acl参数
			-k：删除默认的acl参数
			-R：递归设置acl，把目录和它下面一堆子目录一起改
			-d：设置默认acl参数
			

setfacl 针对个人设置权限  一个人查看一个文件的权限
getfacl 查看权限
已知文件：
[root@xiaoming tmp]# ll
-rw-r--r-- 1 root root    0 11月 26 11:25 a.txt
如果希望只有xiaoming用户可以rwx操作/tmp/a.txt文件
那么我们可以这样做
setfacl -m u:xiaoming:rwx /tmp/a.txt
-m 设置facl权限
u:  用户，也可以指定组 
xiaoming: 需要指定的用户
rwx: 权限

让我们来看下现在xiaoming是否拥有这个权限：
1、尝试对该文件进行操作
2、getfacl /tmp/a.txt
[root@xiaoming /tmp]# getfacl a.txt 
# file: a.txt
# owner: root
# group: root
user::rw-
user:xiaoming:rwx
group::r--
mask::rwx
other::r--
我们可以看到 xiaoming 拥有了对该文件的rwx权限

#那么如何收回权限呢（有+表示acl权限还在）
方法1、本质上是重新赋予一次000权限，+肯定还在
setfacl -m u:xiaoming:--- a.txt
方法2、部分删除acl权限，+还会在
setfacl -x u:xiaoming a.txt
方法3、完全删除acl权限
setfacl -b a.txt  

我们也可以设置该文件为所有人所有组访问
setfacl -m ::rwx a.txt

#只要使用了setfacl权限，就会开启ACL权限，权限最后面有+
d---------+ 2 root it   19 Aug 31 05:21 test
想去掉+，只要用setfacl -Rb 文件名 或 setfacl -b 文件名  即可关闭ACL权限，去掉+
[root@lbj opt]# setfacl -Rb test
[root@lbj opt]# ll
d--------- 2 root it   19 Aug 31 05:21 test

#setfacl的应用场景是针对一个用户（谁都可以，包括root用户），让他可以不受文件或目录的基本权限ugo的限制
[root@lbj ~]# mkdir dir1
[root@lbj ~]# chmod 000 /usr/bin/chmod
[root@lbj ~]# chmod 666 dir1
-bash: /usr/bin/chmod: 权限不够
[root@lbj ~]# setfacl -m u:root:rwx /usr/bin/chmod
[root@lbj ~]# chmod 755 /usr/bin/chmod
[root@lbj ~]# ll -d /usr/bin/chmod
-rwxr-xr-x+ 1 root root 58592 8月  20 2019 /usr/bin/chmod
[root@lbj ~]# setfacl -b /usr/bin/chmod
[root@lbj ~]# ll -d /usr/bin/chmod
-rwx---r-x. 1 root root 58592 8月  20 2019 /usr/bin/chmod

#setfacl有缺陷，即使赋予了其他某人rwx权限，他依旧不能访问/root目录下面的内容，目前猜测是root家目录有其他特殊底层设置。
[root@lbj ~]# mkdir /root/tmpt
[root@lbj ~]# ll
总用量 0
drwxr-xr-x 2 root root 6 8月  31 22:20 tmpt
[root@lbj ~]# setfacl -m u:jack:rwx /root/tmpt
[root@lbj ~]# su jack
[jack@lbj root]$ cat /root/tmpt
cat: /root/tmpt: 权限不够

#之前猜测是root目录设有隐藏权限i，但是不是的。这个原因目前不清楚
[root@lbj ~]# lsattr /root
---------------- /root/dir1
---------------- /root/tmpt
</code></pre> 
<h5><a id="_820"></a>隐藏权限</h5> 
<pre><code class="prism language-ini">1.看隐藏权限---lsattr
[root@linux-server ~]# touch file1 file2 file3
1.查看文件属性
[root@linux-server ~]# lsattr file1 file2 file3 
---------------- file1
---------------- file2
---------------- file3
2.设置权限---chattr
[root@linux-server ~]# chattr +a file1  #不允许修改，只允许追加
[root@linux-server ~]# chattr +i file2  #不允许做任何操作  #取消就-i，其他高级权限和隐藏权限同理
[root@linux-server ~]# chattr +A file3
[root@linux-server ~]# lsattr file1 file2 file3
-----a---------- file1
----i----------- file2
-------A-------- file3
i:即Immutable，系统不允许对这个文件进行任何的修改
a：即Append Only，系统只允许在这个文件之后追加数据，不允许任何覆盖这个文件
A：即Atime，告诉系统不要修改对这个文件的最后访问时间

#案例
[root@linux-server ~]# echo 111 &gt; file1  #覆盖，只允许追加
-bash: file1: Operation not permitted
[root@linux-server ~]# rm -rf file1     #不能删除
rm: cannot remove ‘file1’: Operation not permitted
[root@linux-server ~]# echo 111 &gt;&gt; file1 #追加

[root@linux-server ~]# echo 111 &gt; file2
-bash: file2: Permission denied
[root@linux-server ~]# echo 111 &gt;&gt; file2
-bash: file2: Permission denied
[root@linux-server ~]# rm -rf file2
rm: cannot remove ‘file2’: Operation not permitted
[root@linux-server ~]# mv file2 file4
mv: cannot move ‘file2’ to ‘file4’: Operation not permitted

取消权限
[root@linux-server ~]# chattr -a file1 
[root@linux-server ~]# chattr -i file2 
</code></pre> 
<h5><a id="_865"></a>创建用户、组的联动</h5> 
<pre><code class="prism language-ini">#useradd、groupadd创建用户、创建组
useradd name(目前只发现一个个的创建，没有发现一下子批量操作的参数)
useradd name -p code(指定用户的密码，在创建时，但是不知道为什么最后切换的用户登录时发现密码不对，还不是没有密码)
useradd name -g group1 -G group2
groupadd group -g gid
groupadd group

#usermod用来编辑用户的主属组、次属组：
usermod  name -G groupname（指定附加组）
usermod name -aG groupname（追加附加组，不会覆盖原来用户的附加组，附加组可以有很多个）
usermod name -g groupname（指定用户的主组）
usermod name -s /sbin/nologin
usermod name -s /bin/bash

#usermod、groupmod改变uid、gid
用来改变用户的用户id（uid）、组id（gid）
usermod -g newgid name
usermod -u newuid name
groupmod -g newgid group

#gpasswd，人员调动
gpasswd -M u1,u2,u3,...,un newgroup
gpasswd -d u1 group
gpasswd -a u1 group

#查看用户的信息（uid、gid、主组、所有附加组）
id name (目前也没发现怎么能一下子查看多个用户的信息)

#修改或设置用户登录密码
passwd u1
passwd   (如果不写用户名，默认修改当前登录在终端的用户的密码)
</code></pre> 
<pre><code class="prism language-ini">sh注意事项
文件： x 权限小心给予
目录： w 权限小心给予

x:决定了 ./的执行权
执行脚本文件(后缀必须是sh）的方法：
1）./文件名，回车
2）绝对路径，回车
3)sh 文件名(执行当前目录下的脚本)，回车，不受基本权限x的现在

scp 本机文件名 目的机ip:目标路径
scp 目标ip:目标文件  本机路径（everything is file）
scp -r 本机文件目录和文件 目的机ip:目标路径
ssh 目标机ip ---连接目标虚拟机  ctr+d：中断连接
ssh  -p 端口 用户名@ip （通过特定端口以用户名的身份，登录ip的服务器，前提是用户是该服务器已经有的）
</code></pre> 
<h3><a id="day5_921"></a><strong>day5</strong></h3> 
<pre><code class="prism language-ini">#两种给普通用户提权的手段
suid: 基本针对所有用户，任何用户在执行有suid权限的程序时（例如/usr/bin/rm），都是以root身份在执行。
sudo: 有针对性，例如针对某个用户以能够以root的身份执行某些命令。
</code></pre> 
<pre><code class="prism language-ini">#赋予sudo权限（一）---&gt;赋予单个用户时，直接在visudo文件中添加该用户。可以像root一样使用命令，前面加sudo
1. 编辑/etc/sudoers配置文件
[root@server-1 ~]# vim /etc/sudoers  或 visudo
跳到第100行,将要赋予sudo权限的用户按照root ALL=(ALL) ALL 的格式写在下一行，然后强制保存退出

检查语法是否正确，一定要执行，否则出现问题很麻烦
[root@server-1 ~]# visudo -c
/etc/sudoers: parsed OK
</code></pre> 
<pre><code class="prism language-ini">切换到user01用户
[root@server-1 ~]# su - user01
第一次执行sudo时需要user01用户的密码
[user01@server-1 ~]$ sudo mkdir /home/dir1

We trust you have received the usual lecture from the local System
Administrator. It usually boils down to these three things:

    #1) Respect the privacy of others.
    #2) Think before you type.
    #3) With great power comes great responsibility.

[sudo] password for user01:

如果想要免除每次使用sudo命令输入密码，则修改为
user01  ALL      NOPASSWD: ALL
再次切换到user01用户后，使用sudo命令则不需要输入密码
</code></pre> 
<pre><code class="prism language-ini">#赋予sudo权限（二）---&gt;添加多个普通用户，可以统统把他们添加到wheel组中，这个组是系统自有的组，。可以像root一样使用命令，前面加sudo
若多个用户都需要sudo权限的话，一个一个添加不方便，这样的话需要实现批量添加 即可以将用户加到用户组wheel下
创建用户时指定在wheel组内，wheel组内的用户拥有sudo权限，并且wheel组在系统内部已存在的
[root@server-1 ~]# useradd user01 -G wheel
添加已存在的用户到wheel组
[root@server-1 ~]# usermod -aG wheel user01
使用sudo命令时需要输入用户的密码，如不想输入用户密码则修改/etc/sudoers文件第110行，将行首的'#'删除 
</code></pre> 
<pre><code class="prism language-ini">允许“wheel”用户组的成员运行所有命令
%wheel  ALL=(ALL)     ALL
允许“wheel”用户组的成员运行所有命令，且运行时不需要输入密码
%wheel  ALL=(ALL)              NOPASSWD: ALL
允许“user01”用户运行所有命令
user01    ALL=(ALL)       ALL
允许“user01”用户运行所有命令，且运行时不需要输入密码
user01  ALL=(ALL)       NOPASSWD: ALL

visudo -c 检查修改是否正确
</code></pre> 
<pre><code class="prism language-ini">#拓展：在服务器中切换用户
su - 用户名
su 用户名
切换用户时加 - 与不加 - 的区别： 加 -时，会进入用户的家目录，不加-时，切换完用户还在当前目录
</code></pre> 
<pre><code class="prism language-ini">#拓展：远程拷贝文件
从本地拷贝文件到远程服务器
将当前目录下file1文件拷贝到服务器ip为'192.168.31.99'的root目录下
[root@server-1 ~]# scp file1 192.168.31.99:/root/
从远程服务器'192.168.31.99'拷贝/etc/passwd文件到当前目录
[root@server-1 ~]# scp 192.168.31.99:/etc/passwd ./
将/opt/dir1目录拷贝到服务器ip为'192.168.31.99'的/opt/目录下
[root@server-1 ~]# scp -r /opt/dir1 192.168.31.99:/opt/
将远程服务器'192.168.31.99'内的/opt/dir1目录拷贝到本服务器的/opt/目录下
[root@server-1 ~]# scp -r 192.168.31.99:/opt/dir1 /opt

				ssh 目的ip（远程连接）
				输密码
				md5sum 文件名 可以校验文件是否传输的完整
				（在自己和目的机的文件都校验一下，返回值一样就完整）
				ctr+d：断开登录状态或关机
				一般用exit断开虚拟机连接，这样不是系统异常
</code></pre> 
<h3><a id="day6_1010"></a><strong>day6</strong></h3> 
<pre><code class="prism language-ini">#1.1. 什么是进程？什么是线程？他们的关系又是什么？
程序的加载---就是把程序从硬盘放到内存的过程，一个程序运行起来就会有至少1个进程（它就是这个程序的主进程），而一个进程就会有至少一个线程（它就是主线程）。

进程是内存控制的最小单位。
线程是内存执行的最小单位。

进程不影响程序的运行，线程决定了程序的运行。每个进程的空间是相互独立的，每个线程都是共用同一片内存空间资源的（线程之间的一些数据是共享的，进程里的数据是独立的。就比如微信的数据不会和wegame的数据共享，他们运行起来就是两个进程群体，他们之间部分线程的数据是互通的，比如账号登录。

#pid是一个大致的范围，别人想要准确找到你还需要具体的门牌号---端口。实际上只有ip和端口同时有了，你才能与互联网其他网址进行“通信、送快递这种联动”。一般的域名都是把各自的端口隐藏了，比如百度的域名应该是“ip：端口”这种形式，他用拼音把ip等价，把端口隐藏了。
</code></pre> 
<pre><code class="prism language-ini">程序： 二进制文件，静态 /bin/date, /usr/sbin/httpd，/usr/sbin/sshd, /usr/sbin/nginx
</code></pre> 
<pre><code class="prism language-ini">#1.2 .查看进程 process

#静态查看进程（一）
[root@linux-server ~]# ps aux | less
参数解释：
ps :process nsapashot
a 只能查看系统里面运行的所有终端进程（给用户看的）
u 显示进程拥有者
x 显示系统内所有进程(完整的所有的进程,aux的范围最广，比ux大)
f 显示进程之间的父子关系
</code></pre> 
<pre><code class="prism language-ini">[root@linux-server ~]# ps aux 
USER        PID %CPU %MEM    VSZ   RSS TTY      STAT START   TIME COMMAND
============================================================================
USER: 	#运行进程的用户
PID：   #进程ID
%CPU:   #CPU占用率
%MEM:   #内存占用率
VSZ	    进程占用的虚拟内存大小
RSS     占用的物理内存大小
STAT：  #进程状态  ---了解
?    表示没有占用终端
R 	运行
S 	可中断睡眠 Sleep
D	不可中断睡眠
T 	停止的进程 
Z 	僵尸进程
X    死掉的进程
START:	#进程的启动时间
TIME：	#进程占用CPU的总时间
COMMAND： #进程文件，进程名

进程状态--了解
Sl	以线程的方式运行
Ss  s进程的领导者，父进程
R+	+表示是前台的进程组
S&lt; &lt;优先级较高的进程 	
SN  N优先级较低的进程
</code></pre> 
<pre><code class="prism language-ini">#静态查看进程（二）

[root@linux-server ~]# ps -ef
参数解释：-e 显示所有进程
		-l 长格式显示
		-f 完整格式
		UID       用户ID
		PID       进程ID
		PPID      父进程ID
		C         CPU占用率
		STIME     开始时间
		TTY       开始此进程的TTY----终端设备
		TIME      此进程运行的总时间
		CMD       命令名
</code></pre> 
<pre><code class="prism language-ini">查看单个PID

[root@linux-server ~]# yum install -y httpd  #安装apache软件
[root@linux-server ~]# systemctl start httpd #启动
[root@linux-server ~]# cat /var/run/httpd/httpd.pid1043
</code></pre> 
<pre><code class="prism language-ini">查看指定PID

[root@linux-server ~]# ps aux | grep sshd
root       1043  0.0  0.2 105996  4120 ?        Ss   01:32   0:00 /usr/sbin/sshd -D
grep：过滤
[root@linux-server ~]#pidof sshd      (第一个数字是主进程pid,第二个是副进程pid)
[root@linux-server ~]#pgrep sshd      (第一个数字是主进程pid,第二个是副进程pid)

</code></pre> 
<pre><code class="prism language-ini">查看端口（查到了pid，利用pid可以查看相应程序的端口）

[root@linux-server ~]# yum install lsof  #安装软件包
[root@linux-server ~]# lsof -i:80   #端口号，这能查看带端口的进程（查端口的命令，需要下载软件包）
COMMAND   PID   USER   FD   TYPE  DEVICE SIZE/OFF NODE NAME
httpd   64249   root    4u  IPv6 1373628      0t0  TCP *:http (LISTEN)
[root@lbj ~]# ss -lntp | grep 999																
					（999是pid，查999的端口的命令。系统自带的，还可以顺便看到端口有没有被监听，监听的话就是程序运行了）
[root@lbj ~]# netstat -lntp | grep 999

#3种查ip的方式
[root@lbj ~]# ip addr (查看ip)
[root@lbj ~]# ifconfig(要有netstat)    #在cmd命令窗口输入ipconfig，可以查个人电脑ip信息   
[root@lbj ~]# ip a(查看ip)

#注意：端口号只有整数，范围是从0 到65535
参数解释：
FD：文件描述符，应用程序通过文件描述符识别该文件。
DEVICE：指定磁盘的名称
SIZE：文件的大小
</code></pre> 
<pre><code class="prism language-ini">#查网络进程和正在监听的端口
[root@linux-server ~]# netstat -lntp 

参数详解：
-a  显示全部的进程
-u  显示udp
-n  以数字的新式显示协议名称
-t   tcp
-p：显示进程的名称和pid
-l :只显示正在被监听的端口

参数解释：
recv-Q:网络接收队列
send-Q:网路发送队列
Foreign Address:与本机端口通信的外部请求
</code></pre> 
<pre><code class="prism language-ini">#动态查看进程

# top  #动态显示信息，三秒刷新一次

在工作中必须监控的东西 load average(平均负载)等待cpu处理的队列长度 也是个数。
1分钟   第一个数字
5分钟   第二个数字
15分钟  第三个数字
======================
#查看cpu个数
在top动态页面下，输入1可看到
也可以在非top动态页面下，使用lscpu查看

计算cpu负载：load average的三个值: 0.10, 0.16, 0.12，分别除cpu的个数，得出的值，如果值大于1那么那时候的负载高。
shift+P,CPU那一列按降序排列
</code></pre> 
<p><img src="https://images2.imgbox.com/16/bc/4Jf3KXEZ_o.png" alt="外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传"></p> 
<pre><code class="prism language-ini">#进程控制
按pid杀死进程
kill,pkill
语法： kill 信号 PID   #信号也是进程间通信的一种方式

# kill -l   #查看所有信号。这是英文字母l，不是1
-1   HUP  重新加载进程或者重新加载配置文件,PID不变 #基本用不到
-9   KILL 强制杀死		#重点
-15  TERM 正常杀死(这个'15'可以默认不写)     #重点
-18  CONT 激活进程		#重点
-19  STOP 挂起进程		#重点
</code></pre> 
<pre><code class="prism language-ini">案例一

[root@linux-server ~]# yum install -y vsftpd  #安装vsftpd
[root@linux-server ~]# systemctl start vsftpd  #启动
[root@linux-server ~]# ps aux | grep vsftpd
root      59363  0.0  0.0  53212   576 ?        Ss   16:47   0:00 /usr/sbin/vsftpd /etc/vsftpd/vsftpd.conf

[root@linux-server ~]# kill -1 59363  #发送重启信号，例如vsftpd的配置文件发生改变，希望重新加载
</code></pre> 
<pre><code class="prism language-ini">[root@linux-server ~]# ps aux | grep vsftpd
root      59363  0.0  0.0  53212   748 ?        Ss   16:47   0:00 /usr/sbin/vsftpd /etc/vsftpd/vsftpd.conf
[root@linux-server ~]# kill 59363 #正常杀死进程，信号为-15可以默认不写。我们可以使用systemctl stop vsftpd 停止服务。
[root@linux-server ~]# ps aux | grep vsftpd
root      62493  0.0  0.0 112660   968 pts/0    S+   16:51   0:00 grep --color=auto vsftpd

进程状态解释--了解：
+：表示运行在前台的进程
S+：休眠状态
T+：暂停，挂起状态
s：父进程
</code></pre> 
<pre><code class="prism language-ini">案例二

[root@linux-server ~]# systemctl start vsftpd
[root@linux-server ~]# ps aux | grep vsftpd
root      67003  0.0  0.0  53212   572 ?        Ss   16:57   0:00 /usr/sbin/vsftpd /etc/vsftpd/vsftpd.conf
root      67089  0.0  0.0 112660   972 pts/0    S+   16:57   0:00 grep --color=auto vsftpd
[root@linux-server ~]# kill -9 67003  #强制杀死，一般用于不能正常停止的情况下
[root@linux-server ~]# ps aux | grep vsftpd
root      67190  0.0  0.0 112660   972 pts/0    S+   16:57   0:00 grep --color=auto vsftpd
</code></pre> 
<pre><code class="prism language-ini">案例三

[root@linux-server ~]# systemctl start vsftpd
[root@linux-server ~]# ps -aux | grep vsftpd
root      73399  0.0  0.0  53212   572 ?        Ss   17:05   0:00 /usr/sbin/vsftpd /etc/vsftpd/vsftpd.conf
root      73499  0.0  0.0 112660   968 pts/0    S+   17:05   0:00 grep --color=auto vsftpd
[root@linux-server ~]# pkill -9 vsftpd  #使用pkill可以指定进程名字
[root@linux-server ~]# ps -aux | grep vsftpd
root      73643  0.0  0.0 112660   968 pts/0    S+   17:05   0:00 grep --color=auto vsftpd
</code></pre> 
<pre><code class="prism language-ini">#一、管道

实战案例一
[root@qfedu.com ~]# rpm -qa  |grep 'httpd'  #查询所有已安装的软件包，过滤包含httpd的包
httpd-tools-2.4.6-90.el7.centos.x86_64
httpd-2.4.6-90.el7.centos.x86_64

[root@qfedu.com ~]# ps aux | grep 'sshd'

实战案例二
将/etc/passwd中的用户按UID大小排序

[root@qfedu.com ~]# sort -t":" -k3 -n /etc/passwd  #以: 分隔，将第三列按字数升序
[root@qfedu.com ~]# sort -t":" -k3 -n /etc/passwd -r #以: 分隔，将第三列按字数降序
[root@qfedu.com ~]# sort -t":" -k3 -n /etc/passwd |head #以: 分隔，将第三列按字数升序看前十行
[root@qfedu.com ~]# sort -t":" -k3 -n /etc/passwd |tail #以: 分隔，将第三列按字数升序看后十行
参数详解：
sort 排序，默认升序
-t 指定分隔符
-k 指定列
-n 按数值
-r 降序
head 默认输出前十行
tail 默认输出后十行

实战案例三
[root@qfedu.com ~]# netstat -lntp | awk 'NR==3 {print $4}' | awk -F':' '{print $2}'
22

//如果服务器没有netstat命令，执行以下命令进行安装
[root@qfedu.com ~]# yum install -y net-tools

#常用小命令
[root@qfedu.com ~]# du -h /etc/   #查看目录及目录中的文件大小
[root@qfedu.com ~]# du -sh /etc/  #查看目录的总大小
[root@qfedu.com ~]# ls /etc/ | wc -l #查看目录中有多少个文件
</code></pre> 
<pre><code class="prism language-ini">#二、文件查找

语法：
# find 路径 条件 跟条件相关的操作符   [-exec 动作]
路径:
1.默认不写路径时查找的是当前路径.
2.加路径。
条件：
1.指定的名称  -name
2.文件类型  -type
3.权限
4.时间
</code></pre> 
<pre><code class="prism language-ini">1.1 按文件名

从根开始找文件
[root@qfedu.com ~]# find / -name “file2” #从根开始找文件
/root/file2
/var/tmp/file2
[root@qfedu.com ~]# find /etc -name "ifcfg-ens33" #以名字的方式查找 
[root@qfedu.com ~]# find /etc -iname "Ifcfg-ens33" #-i忽略大小写
</code></pre> 
<pre><code class="prism language-ini">查找/etc/目录下以 .txt 结尾的文件
[root@qfedu.com ~]# find /etc -iname "*.txt"
参数解释：
*：表示所有字符
</code></pre> 
<pre><code class="prism language-ini">1.2 按文件大小    -size

[root@qfedu.com ~]# find /etc -size +5M		#大于5M
[root@qfedu.com ~]# find /etc -size 5M		#等于5M
[root@qfedu.com ~]# find /etc -size -5M      #小于5M
[root@qfedu.com ~]# find / -size +3M -a -size -5M  #查找/下面大于3M而且小于5M的文件
-a：and
[root@qfedu.com ~]# find / -size -1M -o -size +80M #查找/下面小于1M或者大于80M的文件
-o：or
[root@qfedu.com ~]# find / -size -3M -a -name "*.txt" #查找/ 下面小于3M而且名字是.txt的文件
</code></pre> 
<pre><code class="prism language-ini">1.3 按时间查找

按时间找(atime,mtime,ctime)
-atime = access访问时间	 如果多次使用cat、head、tail、vim、vi等命令看文件而不改变内容，那么atime只会改变一次，是最早的那次看的时间
-mtime = modify改变时间  内容修改时间会改变
-ctime = change修改时间   属性修改时间会改变，这里的属性包含文件的属主、属组以及文件的内容改动，只看的话ctime不会变

-amin  #分钟
-mmin
-cmin
</code></pre> 
<pre><code class="prism language-ini">[root@qfedu.com ~]# find /opt -mtime +5		#修改时间5天之前
[root@qfedu.com ~]# find /opt -atime +1     #访问时间1天之前
[root@qfedu.com ~]# find . -mtime -2		#修改时间2天之内

[root@qfedu.com ~]# find . -amin +1         #访问时间在1分钟之前
[root@qfedu.com ~]# find /opt -amin -4      #访问时间在4分钟之内
[root@qfedu.com ~]# find /opt -mmin -2      #修改时间在2分钟之内
</code></pre> 
<pre><code class="prism language-ini">#三、打包压缩

window打包压缩工具：

结尾：.rar     .zip
打包工具：winrar zip 7zip 好压 、Bandizip（好用）
</code></pre> 
<pre><code class="prism language-ini">linux打包压缩工具：

结尾：.tar.gz      .tar.bz2     .zip
</code></pre> 
<pre><code class="prism language-ini">工具：gzip和tar(打包)

bzip2（只压缩）
</code></pre> 
<pre><code class="prism language-ini">打包（细节，这里的参数顺序是不能打乱的，先c再f---创建包然后放文件---&gt;打包）

语法:
#tar cf xxxx.tar   xxxx----&gt;filename   被打包的文件 ...
c ：create  创建
v ：verbose 详细信息
f ：file  文件
</code></pre> 
<pre><code class="prism language-ini">解包（-C 指定解压路径，需要特别关注的是参数顺序不能乱，先x再f---先解压压缩包再拿文件）

#tar xf filename.tar.gz [-C /root/Desktop]
x： extract  解压缩  解包
-C： 指定解包路径
</code></pre> 
<pre><code class="prism language-ini">案例

[root@qfedu.com ~]# tar cvf dir1.tar /home/dir10/ #打包目录dir10，将包命名为dir1.tar
[root@qfedu.com ~]# tar xf dir1.tar -C /usr/local/ #将dir1包解压到指定目录
</code></pre> 
<pre><code class="prism language-ini">打包压缩一起:先c再z最后f

语法:
#tar czf xxxx.tar.gz  
z：表示gz压缩

解压解包一起:先x再z最后f

语法:
#tar xzf 压缩文件 [-C 解压路径]
</code></pre> 
<pre><code class="prism language-ini">案例

[root@qfedu.com ~]# tar czf dir1.tar.gz dir1              #打包并压缩
[root@qfedu.com ~]# tar xzf dir1.tar.gz -C /usr/local/    #解压到指定位置
</code></pre> 
<pre><code class="prism language-ini">打包到指定路径
[root@qfedu.com ~]# tar czf /tmp/`date +%F-%T`-etc.tar.gz /etc/  
#将打包的文件放到/tmp目录下，并以当前时间开头命名
</code></pre> 
<pre><code class="prism language-ini">扩展--按时间创建目录或者文件

# mkdir `date +%F`-upload
# touch file-`date +%F`.txt
</code></pre> 
<h3><a id="day7_1420"></a><strong>day7</strong></h3> 
<pre><code class="prism language-ini">#一 .存储管理
主要知识点: 基本分区、逻辑卷LVM、EXT3/4/XFS文件系统、RAID
</code></pre> 
<pre><code class="prism language-ini">#1.1.初识硬盘
机械 HDD
固态 SSD
</code></pre> 
<pre><code class="prism language-ini">SSD的优势
SSD采用电子存储介质进行数据存储和读取的一种技术，拥有极高的存储性能，被认为是存储技术发展的未来新星。
</code></pre> 
<pre><code class="prism language-ini">与传统硬盘相比，SSD固态电子盘具有以下优点：

第一，SSD完全的半导体化，不存在数据查找时间、延迟时间，数据存取速度快。
第二，SSD全部采用闪存芯片，经久耐用，防震抗摔，即使发生与硬物碰撞，数据丢失的可能性也能够降到最小。　　
第三，得益于无机械部件及闪存芯片，SSD没有任何噪音，功耗低。　
第四，质量轻，比常规1.8英寸硬盘重量轻20-30克，使得便携设备搭载多块SSD成为可能。
</code></pre> 
<pre><code class="prism language-ini">硬盘尺寸
3.5寸  2.5寸 1.8寸
</code></pre> 
<pre><code class="prism language-ini">从插拔方式
热插拔
非热插拔
</code></pre> 
<pre><code class="prism language-ini">从硬盘接口
IDE(已经淘汰---也叫ATA)
SATA (Serial ATA)，是当前主流的一种硬盘接口  
SCSI（小型计算机的接口--很少了） 
SAS代替了scsi (Serial Attached SCSI)，当前SAS接口居多
</code></pre> 
<pre><code class="prism language-ini">IDE和SATA的区别：
1、接口不同，传输的速率不同。IDE根据规范，最高到133MB/s， 而SATA3.0，可达6Gb/S，速度差距巨大。
2、SATA支持热插拔。
</code></pre> 
<pre><code class="prism language-ini">SAS与SCSI的区别
1、接口不同；
2、SAS兼容SATA，SCSI不兼容SATA；
</code></pre> 
<pre><code class="prism language-ini">硬盘设备命名
物理硬盘：    /dev/sd[a-z]

KVM虚拟化:
/dev/vd[a-z]（半虚拟化驱动）
/dev/sd[a-z]（全虚拟化驱动）
</code></pre> 
<pre><code class="prism language-ini">#1.2从磁盘分区方式区分
MBR格式
分区命令：fdisk  
一共可以分14个分区（4个主分区，扩展分区，逻辑分区） 例如: 3主 + 1扩展（n逻辑）
MBR 小于2TB的硬盘。
一块硬盘最多分4个主分区。
</code></pre> 
<pre><code class="prism language-ini">GPT格式
分区命令：gdisk(parted---rhel6)
一共可以分128个主分区
GPT大于小于2TB都可以。
#注意：从MBR转到GPT，或从GPT转换到MBR会导致数据全部丢失！
</code></pre> 
<pre><code class="prism language-ini">#二.基本分区
首先需要先给虚拟机添加磁盘
[root@qfedu.com ~]# ll /dev/sd*
brw-rw----. 1 root disk 8,  0 Nov  7 23:15 /dev/sda
brw-rw----. 1 root disk 8,  1 Nov  7 23:15 /dev/sda1
brw-rw----. 1 root disk 8,  2 Nov  7 23:15 /dev/sda2
brw-rw----. 1 root disk 8, 16 Nov  7 23:15 /dev/sdb
brw-rw----. 1 root disk 8, 32 Nov  7 23:15 /dev/sdc
[root@qfedu.com ~]# lsblk  #查看磁盘设备
NAME            MAJ:MIN RM  SIZE RO TYPE MOUNTPOINT
sda               8:0    0   20G  0 disk 
├─sda1            8:1    0    1G  0 part /boot
└─sda2            8:2    0   19G  0 part 
  ├─centos-root 253:0    0   17G  0 lvm  /
  └─centos-swap 253:1    0    2G  0 lvm  [SWAP]
sdb               8:16   0   10G  0 disk 
sdc               8:32   0   10G  0 disk 
</code></pre> 
<pre><code class="prism language-ini">#2.1.fdisk
MBR 14个分区（4个主分区，扩展分区，逻辑分区）

[root@qfedu.com ~]# fdisk -l /dev/sdb #查看磁盘分区信息
[root@qfedu.com ~]# fdisk /dev/sdb  #针对MBR格式，创建分区
m  查看帮助
n  新建分区
Partition type: p  新建主分区
   p   primary (0 primary, 0 extended, 4 free)
   e   extended
默认回车
设置主分区大小创建主分区，然后
Command (m for help): p  ---打印分区信息
创建扩展分区
Command (m for help): n
Partition type:
   p   primary (1 primary, 0 extended, 3 free)
   e   extended
Select (default p): e
#注意：扩展分区将剩下的空间全部给了。一路回车即可
创建逻辑分区
Command (m for help): n
Partition type:
   p   primary (1 primary, 1 extended, 2 free)
   l   logical (numbered from 5)
Select (default p): l   创建逻辑分区
Adding logical partition 5 
First sector (208896-20971519, default 208896): 
Using default value 208896
Last sector, +sectors or +size{K,M,G} (208896-20971519, default 20971519): +5G #指定大小
Partition 5 of type Linux and of size 5 GiB is set
Command (m for help): w   --保存退出
[root@qfedu.com ~]# partprobe /dev/sdb   #更新磁盘分区表，手动让内核更新分区表。不需要重启
[root@qfedu.com ~]# lsblk #查看磁盘设备
</code></pre> 
<pre><code class="prism language-ini">#2.2 gdisk
GPT 128个主分区
转格式的时候保证此分区，没有被系统占用。
[root@qfedu.com ~]# parted -s /dev/sdc mklabel gpt   #将/dev/sdc(MBR格式)转换成(GPT格式)
[root@qfedu.com ~]# parted -s /dev/sdc mklabel msdos  #将/dev/sda(GPT格式)转换成(MBR格式)
</code></pre> 
<pre><code class="prism language-ini">1\.创建分区

[root@qfedu.com ~]# yum -y install gdisk  #安装分区工具
[root@qfedu.com ~]# gdisk -l /dev/sdc
[root@qfedu.com ~]# gdisk /dev/sdc
Command (? for help): n  --创建分区
Partition number (1-128, default 1): 
First sector (34-16777182, default = 2048) or {+-}size{KMGTP}:
Last sector (2048-16777182, default = 16777182) or {+-}size{KMGTP}: +100M
Current type is 'Linux filesystem'
Hex code or GUID (L to show codes, Enter = 8300):      ---直接回车
Command (? for help): p   --打印分区信息
Command (? for help): w    ---保存
Final checks complete. About to write GPT data. THIS WILL OVERWRITE EXISTING
PARTITIONS!!
Do you want to proceed? (Y/N): y   是否覆盖是
OK; writing new GUID partition table (GPT) to /dev/sdc.
The operation has completed successfully.
[root@qfedu.com ~]# partprobe /dev/sdc  #刷新分区表
[root@qfedu.com ~]# gdisk -l /dev/sdc
[root@qfedu.com ~]# lsblk
</code></pre> 
<pre><code class="prism language-ini">2.创建文件系统（格式化）centos7默认使用xfs

[root@qfedu.com ~]# mkfs.ext4 /dev/sdb1   #格式化成ext4格式的文件系统
[root@qfedu.com ~]# mkfs.xfs /dev/sdc2   #格式化成xfs格式的文件系统
</code></pre> 
<pre><code class="prism language-ini">3.挂载mount使用

[root@qfedu.com ~]# mkdir /mnt/disk1   #创建挂载目录
[root@qfedu.com ~]# mkdir /mnt/disks   #创建挂载目录
[root@qfedu.com ~]# mount  /dev/sdb1 /mnt/disk1/
[root@qfedu.com ~]# mount /dev/sdc2 /mnt/disks/
</code></pre> 
<pre><code class="prism language-ini">4查看磁盘挂载与磁盘使用空间

[root@qfedu.com ~]# df -Th
Filesystem              Type      Size  Used Avail Use% Mounted on
/dev/mapper/centos-root xfs        17G  1.2G   16G   7% /
devtmpfs                devtmpfs  982M     0  982M   0% /dev
tmpfs                   tmpfs     993M     0  993M   0% /dev/shm
tmpfs                   tmpfs     993M  8.7M  984M   1% /run
tmpfs                   tmpfs     993M     0  993M   0% /sys/fs/cgroup
/dev/sda1               xfs      1014M  125M  890M  13% /boot
tmpfs                   tmpfs     199M     0  199M   0% /run/user/0
/dev/sdb1               ext4      283M  2.1M  262M   1% /mnt/disk1
/dev/sdc2               xfs       197M   11M  187M   6% /mnt/disks
参数解释：
-T  打印文件系统类型
-h 人性化显示，磁盘空间大小


取消挂载

[root@qfedu.com ~]# umount /mnt/disks/
[root@qfedu.com ~]# umount -l /mnt/disk1/ #强行卸载，即使目录有资源被进程占用，也可以卸载
</code></pre> 
<pre><code class="prism language-ini">#三、fstab开机自动挂载
#3.1./etc/fstab文件实现开机的时候自动挂载

[root@qfedu.com ~]# blkid /dev/sdb1  #查看uuid和文件系统类型
/dev/sdb1: UUID="d1916638-bd0a-4474-8051-f788116a3a92" TYPE="ext4"
[root@qfedu.com ~]# vim /etc/fstab
参数解释：
第1列:挂载设备
(1)/dev/sda5  
(2)UUID=设备的uuid   rhel6/7的默认写法   同一台机器内唯一的一个设备标识
第2列:挂载点
第3列:文件系统类型
第4列:文件系统属性	
第5列:是否对文件系统进行磁带备份：0 不备份
第6列:是否检查文件系统：0 不检查

[root@qfedu.com ~]# mount -a #自动挂载
</code></pre> 
<pre><code class="prism language-ini">实战二

[root@qfedu.com ~]# vim /etc/fstab
/dev/sdc2       /mnt/disks      xfs     defaults        0 0
[root@qfedu.com ~]# mount -a
</code></pre> 
<pre><code class="prism language-ini">#3.2/etc/rc.d/rc.local开机自动挂载

这个配置文件会在用户登陆之前读取，这个文件中写入了什么命令，在每次系统启动时都会执行一次。也就是说，如果有任何需要在系统启动时运行的工作，则只需写入 /etc/rc.d/rc.local 配置文件即可
</code></pre> 
<pre><code class="prism language-ini">[root@qfedu.com ~]# vim /etc/rc.d/rc.local #将挂载命令直接写到文件中
mount /dev/sdb1 /mnt/disk1/
mount /dev/sdc1 /mnt/disk2/
[root@qfedu.com ~]# chmod +x /etc/rc.d/rc.local #添加执行权限
[root@qfedu.com ~]# reboot
</code></pre> 
<pre><code class="prism language-ini">#一、文件系统分类
1.1分类

分类：
本地文件系统，不能在网络上用。
ntfs  xfs  ext2，ext3，ext4
网络文件系统，也可以在本地用。
nfs   glusterfs   hdfs   ceph
</code></pre> 
<pre><code class="prism language-ini">1.2概念

作用：
管理文件的一套系统。
文件的编辑，拷贝，粘贴，移动。

#理解inode:
inode ：inoed块、i节点--索引节点。专门存储inode信息。也就是是文件的属性-(也叫元信息).它是文件或目录在磁盘里的唯一标识，linux读取文件首先要读取到这个索引节点,每一个文件都有对应的inode，里面包含了与该文件有关的一些信息。
</code></pre> 
<pre><code class="prism language-ini">inode的内容

文件的字节数
文件拥有者的User ID
文件的Group ID
文件的读、写、执行权限
文件的时间戳，共有三个：ctime，mtime，atime。
链接数，即有多少文件名指向这个inode
</code></pre> 
<pre><code class="prism language-ini">查看inode信息

[root@qfedu.com ~]# stat /etc/hosts
  File: ‘/etc/hosts’
  Size: 158             Blocks: 8          IO Block: 4096   regular file
Device: fd00h/64768d    Inode: 16778306    Links: 1
Access: (0644/-rw-r--r--)  Uid: (    0/    root)   Gid: (    0/    root)
Access: 2020-07-28 19:11:48.781000069 +0800
Modify: 2013-06-07 22:31:32.000000000 +0800
Change: 2020-07-18 15:37:52.353025437 +0800
 Birth: -
 
[root@qfedu.com ~]# ls -i /etc/hosts  #-i：查看inode号
16778306 /etc/hosts
</code></pre> 
<pre><code class="prism language-ini">1.3.EXT

EXT 家族支持度最广：
但创建文件系统（格式化）慢！
修复慢！
文件系统存储容量有限！
</code></pre> 
<pre><code class="prism language-ini">1.4.XFS

XFS 同样是一种日志式文件系統：
高容量，支持大存储
高性能，创建/修复文件系统快
格式化快
</code></pre> 
<p>文件系统属性 <br> 第5列:是否对文件系统进行磁带备份：0 不备份<br> 第6列:是否检查文件系统：0 不检查</p> 
<p>[root@qfedu.com ~]# mount -a #自动挂载</p> 
<pre><code>
```ini
实战二

[root@qfedu.com ~]# vim /etc/fstab
/dev/sdc2       /mnt/disks      xfs     defaults        0 0
[root@qfedu.com ~]# mount -a
</code></pre> 
<pre><code class="prism language-ini">#3.2/etc/rc.d/rc.local开机自动挂载

这个配置文件会在用户登陆之前读取，这个文件中写入了什么命令，在每次系统启动时都会执行一次。也就是说，如果有任何需要在系统启动时运行的工作，则只需写入 /etc/rc.d/rc.local 配置文件即可
</code></pre> 
<pre><code class="prism language-ini">[root@qfedu.com ~]# vim /etc/rc.d/rc.local #将挂载命令直接写到文件中
mount /dev/sdb1 /mnt/disk1/
mount /dev/sdc1 /mnt/disk2/
[root@qfedu.com ~]# chmod +x /etc/rc.d/rc.local #添加执行权限
[root@qfedu.com ~]# reboot
</code></pre> 
<pre><code class="prism language-ini">#一、文件系统分类
1.1分类

分类：
本地文件系统，不能在网络上用。
ntfs  xfs  ext2，ext3，ext4
网络文件系统，也可以在本地用。
nfs   glusterfs   hdfs   ceph
</code></pre> 
<pre><code class="prism language-ini">1.2概念

作用：
管理文件的一套系统。
文件的编辑，拷贝，粘贴，移动。

#理解inode:
inode ：inoed块、i节点--索引节点。专门存储inode信息。也就是是文件的属性-(也叫元信息).它是文件或目录在磁盘里的唯一标识，linux读取文件首先要读取到这个索引节点,每一个文件都有对应的inode，里面包含了与该文件有关的一些信息。
</code></pre> 
<pre><code class="prism language-ini">inode的内容

文件的字节数
文件拥有者的User ID
文件的Group ID
文件的读、写、执行权限
文件的时间戳，共有三个：ctime，mtime，atime。
链接数，即有多少文件名指向这个inode
</code></pre> 
<pre><code class="prism language-ini">查看inode信息

[root@qfedu.com ~]# stat /etc/hosts
  File: ‘/etc/hosts’
  Size: 158             Blocks: 8          IO Block: 4096   regular file
Device: fd00h/64768d    Inode: 16778306    Links: 1
Access: (0644/-rw-r--r--)  Uid: (    0/    root)   Gid: (    0/    root)
Access: 2020-07-28 19:11:48.781000069 +0800
Modify: 2013-06-07 22:31:32.000000000 +0800
Change: 2020-07-18 15:37:52.353025437 +0800
 Birth: -
 
[root@qfedu.com ~]# ls -i /etc/hosts  #-i：查看inode号
16778306 /etc/hosts
</code></pre> 
<pre><code class="prism language-ini">1.3.EXT

EXT 家族支持度最广：
但创建文件系统（格式化）慢！
修复慢！
文件系统存储容量有限！
</code></pre> 
<pre><code class="prism language-ini">1.4.XFS

XFS 同样是一种日志式文件系統：
高容量，支持大存储
高性能，创建/修复文件系统快
格式化快
</code></pre>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/a434f9d7287180d78f34af4d348d3445/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">linux定时任务crontab设置每分钟、每小时、每天、每周、每月、每年定时执行</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/690373f013d364874e3b43398409c7bd/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">git报错invalid object xxx和unable to read tree xxxxxx</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>