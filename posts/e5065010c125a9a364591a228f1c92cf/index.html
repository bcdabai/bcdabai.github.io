<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>在C语言中内嵌汇编 - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="在C语言中内嵌汇编" />
<meta property="og:description" content="1． 在C语言中内嵌汇编 在C中内嵌的汇编指令包含大部分的ARM和Thumb指令，不过其使用与汇编文件中的指令有些不同，存在一些限制，主要有下面几个方面：
a. 不能直接向PC寄存器赋值，程序跳转要使用B或者BL指令 b. 在使用物理寄存器时，不要使用过于复杂的C表达式，避免物理寄存器冲突 c. R12和R13可能被编译器用来存放中间编译结果，计算表达式值时可能将R0到R3、R12及R14用于子程序调用，因此要避免直接使用这些物理寄存器 d. 一般不要直接指定物理寄存器，而让编译器进行分配 内嵌汇编使用的标记是 __asm或者asm关键字，用法如下：
__asm { instruction [; instruction] ... [instruction] } 上个demo
#include &lt;stdio.h&gt; void my_strcpy(const char *src, char *dest) { char ch; __asm { loop: ldrb ch, [src], #1 strb ch, [dest], #1 cmp ch, #0 bne loop } } int main() { char *a = &#34;forget it and move on!&#34;; char b[64]; my_strcpy(a, b); printf(&#34;original: %s&#34;, a); printf(&#34;" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/e5065010c125a9a364591a228f1c92cf/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2012-03-26T22:16:36+08:00" />
<meta property="article:modified_time" content="2012-03-26T22:16:36+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">在C语言中内嵌汇编</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p>1． 在C语言中内嵌汇编 </p> 
<p>在C中内嵌的汇编指令包含大部分的ARM和Thumb指令，不过其使用与汇编文件中的指令有些不同，存在一些限制，主要有下面几个方面：</p> 
<p> </p> 
<p>a. 不能直接向PC寄存器赋值，程序跳转要使用B或者BL指令 </p> 
<p>b. 在使用物理寄存器时，不要使用过于复杂的C表达式，避免物理寄存器冲突 </p> 
<p>c. R12和R13可能被编译器用来存放中间编译结果，计算表达式值时可能将R0到R3、R12及R14用于子程序调用，因此要避免直接使用这些物理寄存器 </p> 
<p>d. 一般不要直接指定物理寄存器，而让编译器进行分配 </p> 
<p>内嵌汇编使用的标记是 __asm或者asm关键字，用法如下：</p> 
<p> </p> 
<pre><code class="language-cpp">__asm
{
instruction [; instruction]
...
[instruction]
}</code></pre> 
<p><br> </p> 
<p>上个demo</p> 
<pre><code class="language-cpp">#include &lt;stdio.h&gt;
void my_strcpy(const char *src, char *dest)
{
    char ch;

    __asm
    {
    loop:
        ldrb ch, [src], #1
        strb ch, [dest], #1
        cmp ch, #0
        bne loop
    }
}

int main()
{
    char *a = "forget it and move on!";
    char b[64];
    my_strcpy(a, b);
    printf("original: %s", a);
    printf("copyed: %s", b); 
    return 0;
}</code></pre> 
<p> </p> 
<span style="font-size:12px"></span> 
<p><br> <span id="newsticky"><em>在这里C和汇编之间的值传递是用C的指针来实现的，因为指针对应的是地址，所以汇编中也可以访问。<strong>在这里C和汇编之间的值传递是用C的指针来实现的，因为指针对应的是地址，所以汇编中也可以访问。</strong></em></span></p> 
<p><strong><em></em></strong> </p> 
<p class="MsoNormal" style="margin:0cm 0cm 0pt"><span lang="EN-US">2</span><span style="font-family:宋体">．</span><span style="font-family:宋体">在汇编中使用</span><span lang="EN-US">C</span><span style="font-family:宋体">定义的全局变量</span><span lang="EN-US"></span></p> 
<p></p> 
<p class="MsoNormal" style="margin:0cm 0cm 0pt"><span style="font-family:宋体">内嵌汇编不用单独编辑汇编语言文件，比较简洁，但是有诸多限制，当汇编的代码较多时一般放在单独的汇编文件中。这时就需要在汇编和</span><span lang="EN-US">C</span><span style="font-family:宋体">之间进行一些数据的传递，最简便的办法就是使用全局变量。</span></p> 
<pre><code class="language-cpp">/* cfile.c
*  定义全局变量，并作为主调程序
*/
#include &lt;stdio.h&gt;
int gVar_1 = 12;
extern asmDouble(void);
int main()
{
    printf("original value of gVar_1 is: %d", gVar_1);
    asmDouble();
    printf(" modified value of gVar_1 is: %d", gVar_1);
    return 0;
}</code></pre> 
<p><br>  </p> 
<pre><code class="language-cpp">;对应的汇编语言文件

;called by main(in C),to double an integer, a global var defined in C is used.
    AREA asmfile, CODE, READONLY
    EXPORT asmDouble
    IMPORT gVar_1
asmDouble
    ldr r0, =gVar_1
    ldr r1, [r0]
    mov r2, #2 
    mul r3, r1, r2
    str r3, [r0]
    mov pc, lr
END
</code></pre> 
<p><br>  </p> 
<p class="MsoNormal" style="margin:0cm 0cm 0pt"><span lang="EN-US">3</span><span style="font-family:宋体">．</span><span style="font-family:宋体">在</span><span lang="EN-US">C</span><span style="font-family:宋体">中调用汇编的函数</span><span lang="EN-US"></span></p> 
<p></p> 
<p class="MsoNormal" style="margin:0cm 0cm 0pt"><span style="font-family:宋体">在</span><span lang="EN-US">C</span><span style="font-family:宋体">中调用汇编文件中的函数，要做的主要工作有两个，一是在</span><span lang="EN-US">C</span><span style="font-family:宋体">中声明函数原型，并加</span><span lang="EN-US">extern</span><span style="font-family:宋体">关键字；二是在汇编中用</span><span lang="EN-US">EXPORT</span><span style="font-family:宋体">导出函数名，并用该函数名作为汇编代码段的标识，最后用</span><span lang="EN-US">mov pc, lr</span><span style="font-family:宋体">返回。然后，就可以在</span><span lang="EN-US">C</span><span style="font-family:宋体">中使用该函数了。从</span><span lang="EN-US">C</span><span style="font-family:宋体">的角度，并不知道该函数的实现是用</span><span lang="EN-US">C</span><span style="font-family:宋体">还是汇编。更深的原因是因为</span><span lang="EN-US">C</span><span style="font-family:宋体">的函数名起到表明函数代码起始地址的左右，这个和汇编的</span><span lang="EN-US">label</span><span style="font-family:宋体">是一致的。</span></p> 
<p class="MsoNormal" style="margin:0cm 0cm 0pt"><span style="font-family:宋体"></span> </p> 
<pre><code class="language-cpp">/* cfile.c
*  定义全局变量，并作为主调程序
*/
#include &lt;stdio.h&gt;
int gVar_1 = 12;
extern asmDouble(void);
int main()
{
    printf("original value of gVar_1 is: %d", gVar_1);
    asmDouble();
    printf(" modified value of gVar_1 is: %d", gVar_1);
    return 0;
}</code></pre> 
<p class="MsoNormal" style="margin:0cm 0cm 0pt"><br> </p> 
<p class="MsoNormal" style="margin:0cm 0cm 0pt"><span style="font-family:宋体"></span></p> 
<pre><code class="language-cpp">;对应的汇编语言文件

;called by main(in C),to double an integer, a global var defined in C is used.
    AREA asmfile, CODE, READONLY
    EXPORT asmDouble
    IMPORT gVar_1
asmDouble
    ldr r0, =gVar_1
    ldr r1, [r0]
    mov r2, #2 
    mul r3, r1, r2
    str r3, [r0]
    mov pc, lr
END</code></pre> 
<p class="MsoNormal" style="margin:0cm 0cm 0pt"><br>  </p> 
<p class="MsoNormal" style="margin:0cm 0cm 0pt">2． 在汇编中使用C定义的全局变量 <br> 内嵌汇编不用单独编辑汇编语言文件，比较简洁，但是有诸多限制，当汇编的代码较多时一般放在单独的汇编文件中。这时就需要在汇编和C之间进行一些数据的传递，最简便的办法就是使用全局变量。<br> </p> 
<pre><code class="language-cpp">/* cfile.c
* 定义全局变量，并作为主调程序
*/
#include &lt;stdio.h&gt;
int gVar_1 = 12;
extern asmDouble(void);
int main()
{
    printf("original value of gVar_1 is: %d", gVar_1);
    asmDouble();
    printf(" modified value of gVar_1 is: %d", gVar_1);
    return 0;
}</code></pre> 
<p class="MsoNormal" style="margin:0cm 0cm 0pt"><br>  </p> 
<pre><code class="language-cpp">//对应的汇编语言文件
;called by main(in C),to double an integer, a global var defined in C is used.
    AREA asmfile, CODE, READONLY
    EXPORT asmDouble
    IMPORT gVar_1

asmDouble
    ldr r0, =gVar_1
    ldr r1, [r0]
    mov r2, #2 
    mul r3, r1, r2
    str r3, [r0]
    mov pc, lr
END</code></pre> 
<p class="MsoNormal" style="margin:0cm 0cm 0pt"><br>  </p> 
<p>3． 在C中调用汇编的函数 </p> 
<p>在C中调用汇编文件中的函数，要做的主要工作有两个，一是在C中声明函数原型，<br> 并加extern关键字；二是在汇编中用EXPORT导出函数名，并用该函数名作为汇编代码段的标识，最后用mov pc, lr返回。然后，就可以在C中使用该函数了。从C的角度，并不知道该函数的实现是用C还是汇编。更深的原因是因为C的函数名起到表明函数代码起始地址的左右，这个和汇编的label是一致的。</p> 
<pre><code class="language-cpp">/* cfile.c
* in C,call an asm function, asm_strcpy
* Sep 9, 2004
*/
#include &lt;stdio.h&gt;
extern void asm_strcpy(const char *src, char *dest);
int main()
{
    const char *s = "seasons in the sun";
    char d[32];
    asm_strcpy(s, d);
    printf("source: %s", s);
    printf(" destination: %s",d);
    return 0;
}</code></pre> 
<p><br>  </p> 
<pre><code class="language-cpp">;asm function implementation
    AREA asmfile, CODE, READONLY
    EXPORT asm_strcpy

asm_strcpy

loop

    ldrb r4, [r0], #1 ;address increment after read
    cmp r4, #0
    beq over
    strb r4, [r1], #1
    b loop
    over
    mov pc, lr
END</code></pre> 
<p><br> 在这里，C和汇编之间的参数传递是通过ATPCS（ARM Thumb Procedure Call Standard）的规定来进行的。简单的说就是如果函数有不多于四个参数，对应的用R0-R3来进行传递，多于4个时借助栈，函数的返回值通过R0来返回。</p> 
<p> </p> 
<p>4． 在汇编中调用C的函数 </p> 
<p>在汇编中调用C的函数，需要在汇编中IMPORT 对应的C函数名，然后将C的代码放在一个独立的C文件中进行编译，剩下的工作由连接器来处理。<br> </p> 
<pre><code class="language-cpp">;the details of parameters transfer comes from ATPCS
;if there are more than 4 args, stack will be used

    EXPORT asmfile
    AREA asmfile, CODE, READONLY
    IMPORT cFun
ENTRY
    mov r0, #11
    mov r1, #22
    mov r2, #33
    BL cFun
END</code></pre> 
<p><br>  </p> 
<pre><code class="language-cpp">/*C file, called by asmfile */
int cFun(int a, int b, int c)
{
    return a + b + c;
}</code></pre> 
<p> </p> 
<p>在汇编中调用C的函数，参数的传递也是通过ATPCS来实现的。<br> 需要指出的是当函数的参数个数大于4时，要借助stack，具体见ATPCS规范。</p> 
<p>小结</p> 
<p>以上通过几个简单的例子演示了嵌入式开发中常用的C和汇编混合编程的一些方法和基本的思路，<br> 其实最核心的问题就是如何在C和汇编之间传值，剩下的问题就是各自用自己的方式来进行处理。<br> 以上只是抛砖引玉，更详细和复杂的使用方法要结合实际应用并参考相关的资料。</p> 
<p><br> <br>  </p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/77306e935738e2e9d28bf0343573d8ae/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">使用SC创建和删除windows服务</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/11f6d22598f98637728303efd95d8c0a/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">ThinkPHP图片上传的使用</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>