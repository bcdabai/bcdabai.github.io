<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>雪花Id(snowflake)主键(Long) ，前端丢失精度原理及解决之道 - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="雪花Id(snowflake)主键(Long) ，前端丢失精度原理及解决之道" />
<meta property="og:description" content="目录
1、案例场景
2、雪花(snowflake)Id,Long id前端精度损失原因
3、解决JavaScript Number长整型精度丢失问题
4、成果展现 ​
5、总结
6、参考文章
1、案例场景 我们项目之中可能大多数都使用自增长id作为主键id，这样对于中小型系统来说一般没有啥问题。但是随着各种业务发展以及后续可能分库分表情况；我们有些项目或者项目之中的独立微服务可能使用的是雪花算法生成的主键id(19位)长整型的。于是最近我们在项目对接其他微服务(使用的雪花主键id)之后，在前端调用接口之后发现返回结果id被裁减了。经过组内同事定位📌Long型精度损失。具体原因下面原理部分分析。
2、雪花(snowflake)Id,Long id前端精度损失原因 本人试验以及结合网上的文章，发现一个问题，在PostMan里面请求接口能够完全正确的返回雪花算法生成的主键id，但是在Swagger或者前端接口请求 浏览器之中就会出现雪花算法精度损失问题。于是查找原因如下：
JavaScript 不支持后台返回的 Long 类型，JavaScript 的 number 类型的数值范围是 -2^53~2^53（不包含边界） 所以大于 9007199254740991 的数，进制转换会存在精度问题，而雪花ID生成的数值过大，导致 JavaScript 不能正常存储导致。
同时注意：建议雪花ID在数据库中使用 bigint 来存储，而不是使用 varchar；这样可以提高这样数据库的速度，使用索引的时候少一步字符串转换成数字的操作。
于是我的实际项目之中返回的雪花算法的主键id JavaScript的Number最大id9007199254740991项目主键id1511972392982179840浏览器或者swagger返回1511972392982179800 于是就出现了 前端传递的id，找寻不到对应的记录问题。 3、解决JavaScript Number长整型精度丢失问题 解决方案1 使用Jackson注解，我们也可以用@JsonFormat做类型转换 在VO类中，id上添加注释 @ApiModelProperty(name = &#34;id&#34;, value = &#34;消息id&#34;) @JsonProperty(&#34;id&#34;) //此句为问题关键 相当于吧Long转换为String @JsonFormat(shape = JsonFormat.Shape.STRING) @JSONField(serializeUsing = ToStringSerializer.class) //此处标识得在序列化的时候转换为字符串 private Long id; 其他相关：
@JSONField(serializeUsing= ToStringSerializer.class) 这个注解是Fastjson的，旨在让系统系列化时，保留相关精度。 解决方案2
写一个 JSON 配置类，将 Long 类型序列化成 JSON 的时候自动转为 String 类型" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/208fbbe56248db134998a78fd3f73167/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-04-19T09:06:34+08:00" />
<meta property="article:modified_time" content="2022-04-19T09:06:34+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">雪花Id(snowflake)主键(Long) ，前端丢失精度原理及解决之道</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p id="main-toc"><strong>目录</strong></p> 
<p id="1%E3%80%81%E6%A1%88%E4%BE%8B%E5%9C%BA%E6%99%AF-toc" style="margin-left:0px;"><a href="#1%E3%80%81%E6%A1%88%E4%BE%8B%E5%9C%BA%E6%99%AF" rel="nofollow">1、案例场景</a></p> 
<p id="2%E3%80%81%E9%9B%AA%E8%8A%B1(snowflake)Id%2CLong%20id%E5%89%8D%E7%AB%AF%E7%B2%BE%E5%BA%A6%E6%8D%9F%E5%A4%B1%E5%8E%9F%E5%9B%A0-toc" style="margin-left:40px;"><a href="#2%E3%80%81%E9%9B%AA%E8%8A%B1%28snowflake%29Id%2CLong%20id%E5%89%8D%E7%AB%AF%E7%B2%BE%E5%BA%A6%E6%8D%9F%E5%A4%B1%E5%8E%9F%E5%9B%A0" rel="nofollow">2、雪花(snowflake)Id,Long id前端精度损失原因</a></p> 
<p id="3%E3%80%81%E8%A7%A3%E5%86%B3JavaScript%20Number%E9%95%BF%E6%95%B4%E5%9E%8B%E7%B2%BE%E5%BA%A6%E4%B8%A2%E5%A4%B1%E9%97%AE%E9%A2%98-toc" style="margin-left:40px;"><a href="#3%E3%80%81%E8%A7%A3%E5%86%B3JavaScript%20Number%E9%95%BF%E6%95%B4%E5%9E%8B%E7%B2%BE%E5%BA%A6%E4%B8%A2%E5%A4%B1%E9%97%AE%E9%A2%98" rel="nofollow">3、解决JavaScript Number长整型精度丢失问题</a></p> 
<p id="4%E3%80%81%E6%88%90%E6%9E%9C%E5%B1%95%E7%8E%B0%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%E2%80%8B-toc" style="margin-left:40px;"><a href="#4%E3%80%81%E6%88%90%E6%9E%9C%E5%B1%95%E7%8E%B0%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%E2%80%8B" rel="nofollow">4、成果展现       ​</a></p> 
<p id="4%E3%80%81%E6%80%BB%E7%BB%93-toc" style="margin-left:40px;"><a href="#4%E3%80%81%E6%80%BB%E7%BB%93" rel="nofollow">5、总结</a></p> 
<p id="5%E3%80%81%E5%8F%82%E8%80%83%E6%96%87%E7%AB%A0-toc" style="margin-left:40px;"><a href="#5%E3%80%81%E5%8F%82%E8%80%83%E6%96%87%E7%AB%A0" rel="nofollow">6、参考文章</a></p> 
<p></p> 
<h2 id="1%E3%80%81%E6%A1%88%E4%BE%8B%E5%9C%BA%E6%99%AF">1、案例场景</h2> 
<p>我们项目之中可能大多数都使用自增长id作为主键id，这样对于中小型系统来说一般没有啥问题。但是随着各种业务发展以及后续可能分库分表情况；我们有些项目或者项目之中的独立微服务可能使用的是雪花算法生成的主键id(19位)长整型的。于是最近我们在项目对接其他微服务(使用的雪花主键id)之后，在前端调用接口之后发现返回结果id被裁减了。经过组内同事定位📌Long型精度损失。具体原因下面原理部分分析。</p> 
<h3 id="2%E3%80%81%E9%9B%AA%E8%8A%B1(snowflake)Id%2CLong%20id%E5%89%8D%E7%AB%AF%E7%B2%BE%E5%BA%A6%E6%8D%9F%E5%A4%B1%E5%8E%9F%E5%9B%A0">2、雪花(snowflake)Id,Long id前端精度损失原因</h3> 
<p>本人试验以及结合网上的文章，发现一个问题，在PostMan里面请求接口能够完全正确的返回雪花算法生成的主键id，但是在Swagger或者前端接口请求 浏览器之中就会出现雪花算法精度损失问题。于是查找原因如下：</p> 
<p>        <strong><span style="color:#4da8ee;">JavaScript 不支持后台返回的 Long 类型，JavaScript 的 number 类型的数值范围是 -2^53~2^53（不包含边界） 所以大于 9007199254740991 的数</span></strong>，进制转换会存在精度问题，而雪花ID生成的数值过大，导致 JavaScript 不能正常存储导致。</p> 
<p>       <span style="color:#4da8ee;"><strong>同时注意：</strong></span>建议雪花ID在数据库中使用 bigint 来存储，而不是使用 varchar；这样可以提高这样数据库的速度，使用索引的时候少一步<span style="color:#fe2c24;"><strong>字符串</strong></span>转换成数字的操作。</p> 
<p>       于是我的实际项目之中返回的雪花算法的主键id  </p> 
<table border="1" cellpadding="1" cellspacing="1" style="width:500px;"><tbody><tr><td style="width:189px;">JavaScript的Number最大id</td><td style="width:309px;"><strong><span style="color:#4da8ee;">9007199254740991</span></strong></td></tr><tr><td style="width:189px;">项目主键id</td><td style="width:309px;"><span style="color:#fe2c24;">1511972392982179840</span></td></tr><tr><td style="width:189px;">浏览器或者swagger返回</td><td style="width:309px;"><span style="color:#4da8ee;">1511972392982179800</span></td></tr></tbody></table> 
<p>          <strong> 于是就出现了 前端传递的id，找寻不到对应的记录问题。</strong>         </p> 
<h3 id="3%E3%80%81%E8%A7%A3%E5%86%B3JavaScript%20Number%E9%95%BF%E6%95%B4%E5%9E%8B%E7%B2%BE%E5%BA%A6%E4%B8%A2%E5%A4%B1%E9%97%AE%E9%A2%98">3、解决JavaScript Number长整型精度丢失问题</h3> 
<p>       <strong>解决方案1 </strong></p> 
<p><strong>     </strong>使用Jackson注解，我们也可以用@JsonFormat做类型转换<strong>  </strong></p> 
<p><strong>     </strong>在VO类中，id上添加注释      </p> 
<pre><code>@ApiModelProperty(name = "id", value = "消息id")
@JsonProperty("id")
//此句为问题关键 相当于吧Long转换为String
@JsonFormat(shape = JsonFormat.Shape.STRING)
@JSONField(serializeUsing = ToStringSerializer.class)
//此处标识得在序列化的时候转换为字符串
private Long id;</code></pre> 
<p>     其他相关：</p> 
<pre><code>@JSONField(serializeUsing= ToStringSerializer.class)</code></pre> 
<p>     这个注解是Fastjson的，旨在让系统系列化时，保留相关精度。    </p> 
<p><strong>   解决方案2</strong></p> 
<p>          写一个 JSON 配置类，将 Long 类型序列化成 JSON 的时候自动转为 String 类型</p> 
<pre><code>@Configuration
public class JacksonConfiguration {
 
    @Value("${spring.jackson.date-format:yyyy-MM-dd HH:mm:ss}")
    private String pattern;
 
    @Bean
    public Jackson2ObjectMapperBuilderCustomizer jackson2ObjectMapperBuilderCustomizer() {
        return builder -&gt; {
            // Long 会自定转换成 String
            builder.serializerByType(Long.class, ToStringSerializer.instance);
        };
    }
}</code></pre> 
<h3 id="4%E3%80%81%E6%88%90%E6%9E%9C%E5%B1%95%E7%8E%B0%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%E2%80%8B">4、成果展现       <img alt="" height="547" src="https://images2.imgbox.com/8c/ca/bsgeRGgO_o.png" width="1033"></h3> 
<h3 id="4%E3%80%81%E6%80%BB%E7%BB%93">5、总结</h3> 
<p>        在解决的问题的过程之中一定要细致分析两者的之间不同的细小差异，这样才能发现问题得蛛丝马迹。比如本问题之中发现最后Id最后两位的id字段丢失。这样才能作为解决问题得突破口。</p> 
<h3 id="5%E3%80%81%E5%8F%82%E8%80%83%E6%96%87%E7%AB%A0">6、参考文章</h3> 
<p>      <a class="link-info" href="https://blog.csdn.net/u012337114/article/details/80240385" title="后端传Long类型至前端js会出现精度丢失问题">后端传Long类型至前端js会出现精度丢失问题</a></p> 
<p>     <a class="link-info" href="https://blog.csdn.net/peng2hui1314/article/details/104610819" title="优雅解决后台返回 Long 类型，前台精度丢失导致数据不一致的问题">优雅解决后台返回 Long 类型，前台精度丢失导致数据不一致的问题</a></p> 
<p>    <a class="link-info" href="https://zhuanlan.zhihu.com/p/415027189" rel="nofollow" title="后端Issue-01-Swagger中Long类型精度丢失问题">后端Issue-01-Swagger中Long类型精度丢失问题</a></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/498255674688927a4495d8188fe99663/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">Oracle Data Guard和金仓KingbaseES集群的数据保护模式对比</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/1d775772fcea9a4b5aa8ce4846723908/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">本地启动mysql,redis,oracle的window10脚本</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>