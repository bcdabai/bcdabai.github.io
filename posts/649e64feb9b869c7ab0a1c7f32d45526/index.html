<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>C语言【隐式类型转换】和【显式类型转换】的详解 - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="C语言【隐式类型转换】和【显式类型转换】的详解" />
<meta property="og:description" content="本期介绍🍖
主要介绍：那些不被轻易发现的类型转换，隐式类型转换和显示类型转换👀。
文章目录 一、前言🍖二、隐式类型转换🍖2.1 整形提升🍖2.1.1 例题1🍖2.1.2 例题2🍖2.1.3 例题3🍖 2.2 算数转换🍖 三、显式类型转换🍖 一、前言🍖 C语言是一种强类型语言，当使用一种类型代替另外一种类型进行操作时或者存在两个不同类型的对象进行操作时，首先就得进行类型的转换然后再说其他。而类型转换的方式一般可分为隐式类型转换（也称：自动类型转换）和显示类型转换（也称：强制类型转换），两者有着本质上的区别。
隐式类型转换是由编译器自动进行的，不需要人为的干预，而且我们也观察不到类型是如何进行转换的，所以被称为：“ 隐式 ”。而显式类型转换是由程序员明确指定的，所以才被称为：“ 强制类型转换 ”。
二、隐式类型转换🍖 有些表达式的操作数在求值的过程中可能需要转换为其他的类型，而这种你不知晓的类型上的转换通常分为两种情况：整形提升和运算转换。
在讲整形提升和算数转换之前，还得再补充一个知识点：截断操作。何为截断操作呢？下面举个例子：char a = 3;。大家有没有想过字面常量3是如何存储到char变量a中去的呀？注意这里的字面常量3本质上是一个整数，而一个整数所占的内存空间是32个二进制位，所以这时的3在内存存放的补码如下图所示。但是你想啊，字符变量a只能存放1个字节（即：8个二进制位），怎么可能放得3呢。所以这个时候就要发生截断了，截断的规则：挑低位的字节数，放置到需要截断存储的变量中去，如下图所示。
2.1 整形提升🍖 C语言的整形算数运算总是至少以默认的整形类型（int型）的精度来进行，也就是说参与运算的操作数最小也不能小于4个字节的精度，如若精度小于4个字节该操作数就必须提升成整形的精度。所以为了获得这个精度，表达式中字符型（char）和短整型（short）操作数在使用之前就应该被转换为普通整形，这种转换被称为：整形提升。
那大家有没有想过为什么最小是以整形的精度来进行运算呢？其实表达式的整形运算是在CPU内的整形运算器（ALU）执行，而该运算器操作对象的字节长度一般就是int型的字节长度。因此CPU是无法实现直接对2个char类型的操作数的运算，而是通过先转换为CPU内整形操作数的标准长度然后再进行加法运算的。
整形提升前提条件：只有当表达式中出现长度可能小于int型的整形值时，才须要对该值进行整形提升转换为int或unsigned int型，然后再送入CPU去执行运算。
整形提升的规则：对于有符号的整形变量来说，整型提升是在高位补变量的符号位；而对于无符号的整形变量来说，整形提升是直接高位补0来实现的。
2.1.1 例题1🍖 问上面这个程序最终打印结果为什么是-126，是怎么算出来的呢？下面我们来细致的分析一下，如下图所示。首先char型变量a和b中分别放入截断后的3和127，然后将a&#43;b整形提升运算后的结果进行截断操作放入char型变量c中，最后printf打印%d整形值时对变量c中的值进行按符号位的整形提升，得出的结果当然是-126啦。
2.1.2 例题2🍖 程序如上图所示，问为什么只有c是成功打印的，而a和b却是不行的呢？先拿char型变量a来说吧，首先我们知道a截断存储了十六进制数0xb6，内存补码为：10110110。但当执行到if语句的时候，a需要进行关系运算时需要进行有符号的整形提升，所以整型提升时应该在高位补符号位，结果为：11111111111111111111111110110110，与0xb6的二进制序列：00000000000000000000000010110110当然不一样呀，所以if(a == 0xb6)判断的结果自然为假并不会打印a了呀。同理于short类型的变量b也是如此并不会被打印，而int类型的变量c由于其并不用进行整形提升，所以判断结果为真打印了c。
2.1.3 例题3🍖 很多人会觉得这道题的结果是两个1，但值得注意的是上面这个例子中sizeof（&#43;a）计算的是&#43;a这个表达式值的类型所占的内存空间的大小，而&#43;a表达式的值是a进行整形提升后的结果，所以sizeof的结果为4个字节。
2.2 算数转换🍖 我们刚刚讨论的是类型小于整形的情况，而算数转换是用来处理这些大于等于整形的情况。如果某个操作符的各个操作数属于不同的类型，那么计算是无法进行下去的，除非将这些操作数全都转化为同一类型。寻常算数转换的方向：int→unsigned int→long int→unsigned long int→float→double→long double。
举个易错的例子：
肯定有人会说打印结果必然是hehe，因为sizeof（i）的结果是4嘛，必然大于-1的。可真的是这样吗？
为什么会这样呢？ 这是因为在执行if(i &lt; sizeof(i))判断的时候隐蔽的发生了算数转换，将i的类型从int型转换成了unsigned int型，我们知道int型-1的补码在unsigned int下是一个非常大的整数必然远大于sizeof（i）计算出来的4，所以打印结果为haha。那为什么i会发生算数转换呢？ 这是因为sizeof（）表达式的返回值的类型其实是unsigned int型的。
三、显式类型转换🍖 显示类型转换又被称为强制类型转换，是由我们所决定该转换成什么样的类型，通常在转换时会存在存储精度的损失，所以在使用时需要谨慎。强制类型转换规则：(强制转换的类型)表达式。
举个列子：
你会发现强制类型转换(char)a;其实就像之前的截断操作一样，取后面的低8位然后存储到char类型的b中去，然后在printf打印的时候再按位整形提升，结果自然为-46。
这份博客👍如果对你有帮助，给博主一个免费的点赞以示鼓励欢迎各位🔎点赞👍评论收藏⭐️，谢谢！！！
如果有什么疑问或不同的见解，欢迎评论区留言欧👀。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/649e64feb9b869c7ab0a1c7f32d45526/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-07-09T09:21:05+08:00" />
<meta property="article:modified_time" content="2022-07-09T09:21:05+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">C语言【隐式类型转换】和【显式类型转换】的详解</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-tomorrow-night">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p><img src="https://images2.imgbox.com/73/d0/VLy7Yphu_o.jpg" alt="在这里插入图片描述"></p> 
<p><strong>本期介绍</strong>🍖<br> 主要介绍：那些不被轻易发现的类型转换，隐式类型转换和显示类型转换👀。</p> 
<hr> 
<p></p> 
<div class="toc"> 
 <h4>文章目录</h4> 
 <ul><li><ul><li><a href="#_9" rel="nofollow">一、前言🍖</a></li><li><a href="#_14" rel="nofollow">二、隐式类型转换🍖</a></li><li><ul><li><a href="#21__23" rel="nofollow">2.1 整形提升🍖</a></li><li><ul><li><ul><li><a href="#211_1_33" rel="nofollow">2.1.1 例题1🍖</a></li><li><a href="#212_2_40" rel="nofollow">2.1.2 例题2🍖</a></li><li><a href="#213_3_44" rel="nofollow">2.1.3 例题3🍖</a></li></ul> 
    </li></ul> 
    </li><li><a href="#22__49" rel="nofollow">2.2 算数转换🍖</a></li></ul> 
   </li><li><a href="#_61" rel="nofollow">三、显式类型转换🍖</a></li></ul> 
 </li></ul> 
</div> 
<p></p> 
<hr> 
<h3><a id="_9"></a>一、前言🍖</h3> 
<p>  C语言是一种强类型语言，当使用一种类型代替另外一种类型进行操作时或者存在两个不同类型的对象进行操作时，首先就得进行类型的转换然后再说其他。而类型转换的方式一般可分为<font color="dddd00">隐式类型转换</font>（也称：自动类型转换）和<font color="dddd00">显示类型转换</font>（也称：强制类型转换），两者有着本质上的区别。</p> 
<p>  <strong>隐式类型转换</strong>是由编译器自动进行的，不需要人为的干预，而且我们也观察不到类型是如何进行转换的，所以被称为：“ 隐式 ”。而<strong>显式类型转换</strong>是由程序员明确指定的，所以才被称为：“ 强制类型转换 ”。</p> 
<hr> 
<h3><a id="_14"></a>二、隐式类型转换🍖</h3> 
<p>  有些表达式的操作数在求值的过程中可能需要转换为其他的类型，而这种你不知晓的类型上的转换通常分为两种情况：<strong>整形提升</strong>和<strong>运算转换</strong>。</p> 
<p>  在讲<strong>整形提升</strong>和<strong>算数转换</strong>之前，还得再补充一个知识点：<strong>截断操作</strong>。何为截断操作呢？下面举个例子：<code>char a = 3;</code>。大家有没有想过<strong>字面常量3</strong>是如何存储到<strong>char变量a</strong>中去的呀？注意这里的字面常量3本质上是一个整数，而一个整数所占的内存空间是32个二进制位，所以这时的3在内存存放的补码如下图所示。但是你想啊，字符变量a只能存放1个字节（即：8个二进制位），怎么可能放得3呢。所以这个时候就要发生截断了，<strong>截断的规则</strong>：<font color="dddd00">挑低位的字节数，放置到需要截断存储的变量中去</font>，如下图所示。<br> <img src="https://images2.imgbox.com/ad/e9/h83u25il_o.png" alt="在这里插入图片描述"></p> 
<hr> 
<h4><a id="21__23"></a>2.1 整形提升🍖</h4> 
<p>  <font color="dddd00">C语言的整形算数运算总是至少以默认的整形类型（int型）的精度来进行</font>，也就是说参与运算的操作数最小也不能小于4个字节的精度，如若精度小于4个字节该操作数就必须提升成整形的精度。所以为了获得这个精度，表达式中<strong>字符型</strong>（char）和<strong>短整型</strong>（short）操作数在使用之前就应该被转换为普通整形，这种转换被称为：<font color="dddd00">整形提升</font>。</p> 
<p>  <strong>那大家有没有想过为什么最小是以整形的精度来进行运算呢</strong>？其实表达式的整形运算是在CPU内的整形运算器（ALU）执行，而该运算器操作对象的字节长度一般就是int型的字节长度。因此CPU是无法实现直接对2个char类型的操作数的运算，而是通过先转换为CPU内整形操作数的标准长度然后再进行加法运算的。</p> 
<p>  <strong>整形提升前提条件</strong>：<u>只有当表达式中出现长度可能小于int型的整形值时，才须要对该值进行整形提升转换为int或unsigned int型，然后再送入CPU去执行运算</u>。</p> 
<p>  <strong>整形提升的规则</strong>：<u>对于有符号的整形变量来说，整型提升是在高位补变量的符号位；而对于无符号的整形变量来说，整形提升是直接高位补0来实现的</u>。</p> 
<hr> 
<h6><a id="211_1_33"></a>2.1.1 例题1🍖</h6> 
<p><img src="https://images2.imgbox.com/00/40/DDmCSCoF_o.png" alt="在这里插入图片描述"><br>   问上面这个程序最终打印结果为什么是-126，是怎么算出来的呢？下面我们来细致的分析一下，如下图所示。首先char型变量a和b中分别放入截断后的3和127，然后将a+b整形提升运算后的结果进行截断操作放入char型变量c中，最后printf打印%d整形值时对变量c中的值进行按符号位的整形提升，得出的结果当然是-126啦。</p> 
<p><img src="https://images2.imgbox.com/69/8d/zKHXC070_o.png" alt="在这里插入图片描述"></p> 
<hr> 
<h6><a id="212_2_40"></a>2.1.2 例题2🍖</h6> 
<p><img src="https://images2.imgbox.com/ba/d0/R5fVuRr4_o.png" alt="在这里插入图片描述"><br>   程序如上图所示，问为什么只有c是成功打印的，而a和b却是不行的呢？先拿char型变量a来说吧，首先我们知道a截断存储了十六进制数0xb6，内存补码为：<font color="dddd00">10110110</font>。但当执行到if语句的时候，a需要进行关系运算时需要进行有符号的整形提升，所以整型提升时应该在高位补符号位，结果为：<font color="dddd00">11111111111111111111111110110110</font>，与0xb6的二进制序列：<font color="dddd00">00000000000000000000000010110110</font>当然不一样呀，所以<code>if(a == 0xb6)</code>判断的结果自然为假并不会打印a了呀。同理于short类型的变量b也是如此并不会被打印，而int类型的变量c由于其并不用进行整形提升，所以判断结果为真打印了c。</p> 
<hr> 
<h6><a id="213_3_44"></a>2.1.3 例题3🍖</h6> 
<p><img src="https://images2.imgbox.com/71/54/BByS66YD_o.png" alt="在这里插入图片描述"><br>   很多人会觉得这道题的结果是两个1，但值得注意的是上面这个例子中sizeof（+a）计算的是+a这个<strong>表达式值</strong>的类型所占的内存空间的大小，而+a表达式的值是a进行整形提升后的结果，所以sizeof的结果为4个字节。</p> 
<hr> 
<h4><a id="22__49"></a>2.2 算数转换🍖</h4> 
<p>  我们刚刚讨论的是类型小于整形的情况，而<strong>算数转换</strong>是用来处理这些大于等于整形的情况。如果某个操作符的各个操作数属于不同的类型，那么计算是无法进行下去的，除非将这些操作数全都转化为同一类型。<strong>寻常算数转换的方向</strong>：int→unsigned int→long int→unsigned long int→float→double→long double。</p> 
<blockquote> 
 <p>  举个易错的例子：<br> <img src="https://images2.imgbox.com/27/79/26nMOkDO_o.png" alt="在这里插入图片描述"><br>   肯定有人会说打印结果必然是hehe，因为sizeof（i）的结果是4嘛，必然大于-1的。可真的是这样吗？<br> <img src="https://images2.imgbox.com/66/da/oFNo1NFU_o.png" alt="在这里插入图片描述"><br>   <strong>为什么会这样呢？</strong> 这是因为在执行<code>if(i &lt; sizeof(i))</code>判断的时候隐蔽的发生了算数转换，将i的类型从int型转换成了unsigned int型，我们知道int型-1的补码在unsigned int下是一个非常大的整数必然远大于sizeof（i）计算出来的4，所以打印结果为haha。<strong>那为什么i会发生算数转换呢？</strong> 这是因为sizeof（）表达式的返回值的类型其实是unsigned int型的。</p> 
</blockquote> 
<hr> 
<h3><a id="_61"></a>三、显式类型转换🍖</h3> 
<p>  显示类型转换又被称为<strong>强制类型转换</strong>，是由我们所决定该转换成什么样的类型，通常在转换时会存在存储精度的损失，所以在使用时需要谨慎。强制类型转换<strong>规则</strong>：<code>(强制转换的类型)表达式</code>。</p> 
<blockquote> 
 <p>举个列子：<br> <img src="https://images2.imgbox.com/40/a5/f30cMzm0_o.png" alt="在这里插入图片描述"><br>   你会发现强制类型转换<code>(char)a;</code>其实就像之前的截断操作一样，取后面的低8位然后存储到char类型的b中去，然后在printf打印的时候再按位整形提升，结果自然为-46。</p> 
</blockquote> 
<hr> 
<p><img src="https://images2.imgbox.com/a8/fa/VgSwS9jQ_o.gif" alt="在这里插入图片描述"></p> 
<p>这份博客👍如果对你有帮助，给博主一个免费的点赞以示鼓励欢迎各位🔎点赞👍评论收藏⭐️，谢谢！！！<br> 如果有什么疑问或不同的见解，欢迎评论区留言欧👀。</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/1a999de1b1f6e59b009291d6dcd56122/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">微信背后的产品观，确实厉害！</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/9d3c3961bb235b4b252987ed8b180b0e/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">Python中append()函数和extend()函数区别详解</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>