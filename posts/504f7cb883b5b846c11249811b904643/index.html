<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>数据结构笔记整理(严蔚敏版) 更新中... - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="数据结构笔记整理(严蔚敏版) 更新中..." />
<meta property="og:description" content="文章目录 数据结构笔记整理绪论基本概念和术语算法的定义及特性定义特性 评价算法优劣的标准算法的时间复杂度算法的空间复杂度 线性表线性表的定义和特点线性表的顺序存储表示顺序表中基本操作的实现 线性表的链式存储表示单链表中基本操作的实现 栈和队列栈的定义和特点栈的表示和操作实现顺序栈链栈栈与递归 队列的定义和特点循环队列的操作队列的链式表示和实现 串、数组、和广义表串的定义串的存储结构串的模式匹配算法1.BF算法2.KMP算法 数组数组的顺序存储特殊矩阵的压缩存储1.对称矩阵2.三角矩阵3.对角矩阵4.稀疏矩阵 数据结构笔记整理 绪论 基本概念和术语 数据：能输入到计算机中并被计算机处理的符号的总称；
数据元素：数据的基本单位；
数据项：组成数据元素的、有独立含义的、不可分割的最小单位；
数据对象：性质相同的数据元素的集合；
数据结构：相互之间存在一种或多种特定关系的数据元素的集合；
数据类型：是一个值的集合和定义在这个值集上的一组操作的总称；
抽象数据类型：一般指由用户定义、表示应用问题的数据模型，以及定义在这个模型上的一组操作的总称；
（具体包括三部分：数据对象、数据对象上关系的集合以及对数据对象的基本操作的集合）
算法的定义及特性 定义 为了解决某类问题而规定的一个有限长的操作序列；
特性 1.有穷性
2.确定性
3.可行性
4.输入
5.输出；
评价算法优劣的标准 1.正确性
2.可读性
3.健壮性
4.高效性（包括时间和空间两个方面）
算法的时间复杂度 一个算法的执行时间大致上等于其所有语句执行时间总和，而语句的执行时间则为该条语句的重复执行次数和执行一次所需要时间的乘积；
问题规模是算法求解问题输入量的多少，一般用整数n表示；
语句频度一条语句重复执行的次数；
时间复杂度定义：随问题规模n的增大，算法执行时间的增长率称为时间复杂度；
最好时间复杂度：算法计算量可能达到的最小值；
最坏时间复杂度：算法计算量可能达到的最大值；
平均时间复杂度：算法在所有可能的情况下，按照输入实例以等概率出现时，算法计算量的加权平均值；
1.常量阶O(1)
int i=0,s=0; for(i=0;i&lt;100;i&#43;&#43;){ s&#43;&#43;;	//语句频度为常数，无论怎么大，仍然是常数 } 2.线性阶O(n)
for(i=0;i&lt;n;i&#43;&#43;){ s&#43;&#43;;	//语句频度为n } 3.对数阶O(log(2)n)
for(int i=1;i&lt;n;i&#43;&#43;){ i=i*2; } //2^n=x //x=log(2)n 算法的空间复杂度 分析算法在实现是所需要的辅助空间；
int fac(int n){	if (n == 1) return 1; else return n * fac(n - 1); } 线性表 线性表的定义和特点 定义：由n个数据特性相同的元素构成的有限序列称为线性表；" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/504f7cb883b5b846c11249811b904643/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-05-30T16:57:59+08:00" />
<meta property="article:modified_time" content="2022-05-30T16:57:59+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">数据结构笔记整理(严蔚敏版) 更新中...</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p></p> 
<div class="toc"> 
 <h4>文章目录</h4> 
 <ul><li><a href="#_1" rel="nofollow">数据结构笔记整理</a></li><li><ul><li><a href="#_3" rel="nofollow">绪论</a></li><li><ul><li><a href="#_5" rel="nofollow">基本概念和术语</a></li><li><a href="#_26" rel="nofollow">算法的定义及特性</a></li><li><ul><li><a href="#_28" rel="nofollow">定义</a></li><li><a href="#_32" rel="nofollow">特性</a></li></ul> 
    </li><li><a href="#_44" rel="nofollow">评价算法优劣的标准</a></li><li><ul><li><a href="#_54" rel="nofollow">算法的时间复杂度</a></li><li><a href="#_97" rel="nofollow">算法的空间复杂度</a></li></ul> 
   </li></ul> 
   </li><li><a href="#_112" rel="nofollow">线性表</a></li><li><ul><li><a href="#_114" rel="nofollow">线性表的定义和特点</a></li><li><a href="#_122" rel="nofollow">线性表的顺序存储表示</a></li><li><ul><li><a href="#_127" rel="nofollow">顺序表中基本操作的实现</a></li></ul> 
    </li><li><a href="#_210" rel="nofollow">线性表的链式存储表示</a></li><li><ul><li><a href="#_215" rel="nofollow">单链表中基本操作的实现</a></li></ul> 
   </li></ul> 
   </li><li><a href="#_340" rel="nofollow">栈和队列</a></li><li><ul><li><a href="#_344" rel="nofollow">栈的定义和特点</a></li><li><a href="#_357" rel="nofollow">栈的表示和操作实现</a></li><li><ul><li><a href="#_361" rel="nofollow">顺序栈</a></li><li><a href="#_420" rel="nofollow">链栈</a></li><li><a href="#_485" rel="nofollow">栈与递归</a></li></ul> 
    </li><li><a href="#_501" rel="nofollow">队列的定义和特点</a></li><li><ul><li><a href="#_548" rel="nofollow">循环队列的操作</a></li><li><a href="#_589" rel="nofollow">队列的链式表示和实现</a></li></ul> 
   </li></ul> 
   </li><li><a href="#_650" rel="nofollow">串、数组、和广义表</a></li><li><ul><li><a href="#_652" rel="nofollow">串的定义</a></li><li><a href="#_668" rel="nofollow">串的存储结构</a></li><li><a href="#_695" rel="nofollow">串的模式匹配算法</a></li><li><ul><li><a href="#1BF_703" rel="nofollow">1.BF算法</a></li><li><a href="#2KMP_722" rel="nofollow">2.KMP算法</a></li></ul> 
    </li><li><a href="#_747" rel="nofollow">数组</a></li><li><ul><li><a href="#_755" rel="nofollow">数组的顺序存储</a></li><li><a href="#_768" rel="nofollow">特殊矩阵的压缩存储</a></li><li><ul><li><a href="#1_772" rel="nofollow">1.对称矩阵</a></li><li><a href="#2_776" rel="nofollow">2.三角矩阵</a></li><li><a href="#3_786" rel="nofollow">3.对角矩阵</a></li><li><a href="#4_796" rel="nofollow">4.稀疏矩阵</a></li></ul> 
    </li></ul> 
   </li></ul> 
  </li></ul> 
 </li></ul> 
</div> 
<p></p> 
<h2><a id="_1"></a>数据结构笔记整理</h2> 
<h3><a id="_3"></a>绪论</h3> 
<h4><a id="_5"></a>基本概念和术语</h4> 
<p><strong>数据</strong>：能输入到计算机中并被计算机处理的符号的总称；</p> 
<p><strong>数据元素</strong>：数据的基本单位；</p> 
<p><strong>数据项</strong>：组成数据元素的、有独立含义的、不可分割的最小单位；</p> 
<p><strong>数据对象</strong>：性质相同的数据元素的集合；</p> 
<p><strong>数据结构</strong>：相互之间存在一种或多种特定关系的数据元素的集合；</p> 
<p><img src="https://images2.imgbox.com/c8/25/Vdkzok2e_o.png" alt="在这里插入图片描述"></p> 
<p><strong>数据类型</strong>：是一个值的集合和定义在这个值集上的一组操作的总称；</p> 
<p><strong>抽象数据类型</strong>：一般指由用户定义、表示应用问题的数据模型，以及定义在这个模型上的一组操作的总称；</p> 
<p><em><strong>（具体包括三部分：数据对象、数据对象上关系的集合以及对数据对象的基本操作的集合）</strong></em></p> 
<h4><a id="_26"></a>算法的定义及特性</h4> 
<h5><a id="_28"></a>定义</h5> 
<p>为了解决某类问题而规定的一个有限长的操作序列；</p> 
<h5><a id="_32"></a>特性</h5> 
<p>1.有穷性</p> 
<p>2.确定性</p> 
<p>3.可行性</p> 
<p>4.输入</p> 
<p>5.输出；</p> 
<h4><a id="_44"></a>评价算法优劣的标准</h4> 
<p>1.正确性</p> 
<p>2.可读性</p> 
<p>3.健壮性</p> 
<p><strong>4.高效性</strong>（包括时间和空间两个方面）</p> 
<h5><a id="_54"></a>算法的时间复杂度</h5> 
<p>一个算法的执行时间大致上等于其所有语句执行时间总和，而语句的执行时间则为该条语句的重复执行次数和执行一次所需要时间的乘积；</p> 
<p><strong>问题规模</strong>是算法求解问题输入量的多少，一般用整数n表示；</p> 
<p><strong>语句频度</strong>一条语句重复执行的次数；</p> 
<p><strong>时间复杂度定义</strong>：随问题规模n的增大，算法执行时间的增长率称为时间复杂度；</p> 
<p>最好时间复杂度：算法计算量可能达到的最小值；</p> 
<p>最坏时间复杂度：算法计算量可能达到的最大值；</p> 
<p>平均时间复杂度：算法在所有可能的情况下，按照输入实例以等概率出现时，算法计算量的加权平均值；</p> 
<p><strong>1.常量阶O(1)</strong></p> 
<pre><code class="prism language-c++">int i=0,s=0;
for(i=0;i&lt;100;i++){
    s++;	//语句频度为常数，无论怎么大，仍然是常数
}
</code></pre> 
<p><strong>2.线性阶O(n)</strong></p> 
<pre><code class="prism language-c++">for(i=0;i&lt;n;i++){
    s++;	//语句频度为n
}
</code></pre> 
<p><strong>3.对数阶O(log(2)n)</strong></p> 
<pre><code class="prism language-C++">for(int i=1;i&lt;n;i++){
	i=i*2;
}
//2^n=x
//x=log(2)n
</code></pre> 
<h5><a id="_97"></a>算法的空间复杂度</h5> 
<p>分析算法在实现是所需要的辅助空间；</p> 
<pre><code class="prism language-c++">int fac(int n){	
	if (n == 1)
		return 1;
	else
		return n * fac(n - 1);
}
</code></pre> 
<h3><a id="_112"></a>线性表</h3> 
<h4><a id="_114"></a>线性表的定义和特点</h4> 
<p>定义：由n个数据特性相同的元素构成的有限序列称为线性表；<br> 特点：&gt;存在唯一一个“第一个”数据元素；</p> 
<blockquote> 
 <p>存在唯一一个“最后一个”数据元素；<br> 除上面两个外，每个元素有且只有一个前驱和一个后继；</p> 
</blockquote> 
<h4><a id="_122"></a>线性表的顺序存储表示</h4> 
<p><strong>定义</strong>：用一组地址连续的存储单元依次存储线性表的数据元素，这种存储结构的线性表称为顺序表；<br> <strong>特点</strong>：逻辑上相邻，物理次序也相邻；</p> 
<h5><a id="_127"></a>顺序表中基本操作的实现</h5> 
<p><strong>1.数据类型定义</strong></p> 
<pre><code class="prism language-C++">#define MAXSIZE 100

typedef int ElemType;       //定义数据元素的类型
typedef struct{
    ElemType *elem; //存储空间基址
    int length;
}Sqlist;

</code></pre> 
<p><strong>2.初始化</strong></p> 
<pre><code class="prism language-C++">void InitList(SqList &amp;L){
    L.elem=new ElemType[MAXSIZE];
    if(!L.elem) exit(0);//分配失败，退出
    L.length=0;
}
</code></pre> 
<p><strong>3.取值</strong></p> 
<pre><code class="prism language-c++">void GetElem(SqList L,int i,ElemType &amp;e){
	if(i&lt;1||i&gt;L.length) printf("Position Error!");
    e=L.elem[i-1];
}
</code></pre> 
<p><strong>4.查找</strong></p> 
<pre><code class="prism language-c++">int LocateElem(SqList L,Elemtype e){
	for(i=0;i&lt;L.length;i++){
		if(L.elem[i]==e) return i+1;
	}
	return 0;
}
</code></pre> 
<p><strong>5.插入</strong></p> 
<pre><code class="prism language-c++">void InsertList(Sqlist *L,int i,ElemType x){
    int j;
    if(i&lt;1||i&gt;L.length+1) printf("Position Error!");
    if(L.length==MAXSIZE) printf("Position FULL！");
    for(j=L-&gt;length-1;j&gt;i-1;--j){
        L-&gt;elem[j+1]=L-&gt;elem[j];
    }
    L-&gt;elem[i-1]=x;
    ++L-&gt;length;
}
</code></pre> 
<p><strong>6.删除</strong></p> 
<pre><code class="prism language-c++">void DeleteList(Sqlist *L,int i){
    int j;
    if(i&lt;=1||i&gt;L-&gt;length){
        printf("Position Error!");
    }
    for(j=L-&gt;length-1;j&gt;i-1;--j){
        L-&gt;elem[j-1]=L-&gt;elem[j];
    }
    --L-&gt;length;
}
</code></pre> 
<p><strong>性能分析:</strong></p> 
<p>1.预先分配空间；<br> 2.存储密度=数据元素本身占用的存储量/结点结构占用的存储量；<br> 3.查找效率高O(1);<br> 4.插入删除效率低O(n);<br> PS.存储了第一个元素的位置通常称为线性表的起始位置或基地址，由此，知道了第一个元素的位置，任－数据元素都可随机存取，所以线性表的顺序存储结构是一种随机存取的数据结构；</p> 
<h4><a id="_210"></a>线性表的链式存储表示</h4> 
<p><strong>定义</strong>：用任意的存储单元存储线性表的数据元素，除了存储其本身的信息，还存储一个指示其后继的信息；<br> 数据元素包括数据域和指针域；</p> 
<h5><a id="_215"></a>单链表中基本操作的实现</h5> 
<p><strong>1.数据类型定义</strong></p> 
<pre><code class="prism language-C++">typedef  int ElemType;
//定义链表类型
typedef struct LNode{
    ElemType data;
    struct LNode *next;
}LNode,*List;
</code></pre> 
<p><strong>2.初始化</strong></p> 
<pre><code class="prism language-C++">void InitList(List &amp;L){
    L=new LNode;//生成新结点作为头结点，头指针L指向头结点
    L-&gt;next=NULL;
}
</code></pre> 
<p><strong>3.输入、输出</strong></p> 
<pre><code class="prism language-c++">void ListInput(List &amp;L, int n) //链表数据的输入
{
    int i=1;
    List p, r;
    r = L;
    while (i&lt;=n) {
        p = new LNode;
        cin &gt;&gt; p-&gt;data;
        p-&gt;next = NULL;
        r-&gt;next = p;
        r = p;
        i++;
	}
}

void ListOutput(List L) //输出List
{
    List p;
    p = L-&gt;next;
    cout &lt;&lt; "The List is:"&lt;&lt;endl;
    while (p != NULL) {
    cout &lt;&lt; p-&gt;data &lt;&lt; " ";
    p = p-&gt;next;
    }
    cout &lt;&lt; endl;
}
</code></pre> 
<p><strong>4.查找</strong></p> 
<pre><code class="prism language-c++">bool LocateElem(List L, int e){
	List p;
	p=L;
	while(p){
		if(p-&gt;data==e)
		return true;
		p=p-&gt;next;
	}
	return false;
}
</code></pre> 
<p><strong>5.插入</strong></p> 
<pre><code class="prism language-c++">void InsertList(List &amp;L,int i,ElemType e){
    List p;
    p=L;
    int j;
    while(p&amp;&amp;j&lt;i-1){
        p=p-&gt;next;
        ++j;
    }
    if(!p||j&gt;i-1){
        return ;
    }
    s=new LNode;
    s-&gt;data=e;
    s-&gt;next=p-&gt;next;
    p-&gt;next=s;
}
</code></pre> 
<p><strong>6.删除</strong></p> 
<pre><code class="prism language-c++">void DeleteList(List &amp;L,int i,ElemType e){
    List p;
    p=L;
    int j=0;
    while(p-&gt;next&amp;&amp;j&lt;i-1){
        p=p-&gt;next;
        ++j;
    }
    if(!p||j&gt;i-1){
        return ;
    }
    q=new LNode;//临时保存地址结点，以备释放
    q=p-&gt;next;
    delete q;
}
</code></pre> 
<p><strong>性能分析:</strong></p> 
<p>1.元素个数没有限制；<br> 2.存储密度=数据元素本身占用的存储量/结点结构占用的存储量；<br> 3.查找效率低O(n);<br> 4.插入删除效率高O(1);</p> 
<p><strong>PS.链表是非随机存取的存储结构，也称为顺序存取的存储结构；</strong></p> 
<p>首元结点、头结点、头指针概念说明；<br> <strong>首元结点</strong>：存储第一个数据元素的结点；<br> <strong>头结点</strong>：设在首元结点之前的一个结点，指针域指向首元结点；<br> <strong>头指针</strong>：指向链表中第一个结点的指针，有头结点指头结点，没有头结点，指首元结点；<br> <strong>PS.头结点作用：&gt;便于首元结点的操作；</strong></p> 
<h3><a id="_340"></a>栈和队列</h3> 
<p>栈和队列是两种操作受限的线性表，可称为限定性的数据结构；</p> 
<h4><a id="_344"></a>栈的定义和特点</h4> 
<p><strong>栈</strong>是限定仅<strong>在表尾进行插入删除</strong>的线性表；</p> 
<p>对栈来说，表尾端有其特殊含义，称为“栈顶（top）”，相应的，表头端为栈底（bottom）；</p> 
<p>不含任何元素的空表，称为“空栈”；</p> 
<p><img src="https://images2.imgbox.com/96/4c/8vi9hIfG_o.png" alt="在这里插入图片描述"></p> 
<p>因此，栈又称为“<strong>后进先出</strong>”（Last In First Out）；</p> 
<h4><a id="_357"></a>栈的表示和操作实现</h4> 
<p>和线性表类似，栈有两种存储方法，分别称为<strong>顺序栈</strong>和<strong>链栈</strong>；</p> 
<h5><a id="_361"></a>顺序栈</h5> 
<p><strong>1.顺序栈的存储结构</strong></p> 
<pre><code class="prism language-C++">#define MAXSIZE 100
typedef struct{
    SElemType *base;//栈底指针
    SElemType *top;//栈顶指针
    int stacksize;//栈可用最大容量
}SqStack;

</code></pre> 
<p><strong>2.初始化</strong></p> 
<pre><code class="prism language-c++">Status InitStack(SqStack &amp;S){
    S.base=new SElemType[MAXSIZE];//分配一个最大容量空间
    if(!S.base) exit(OVERFLOW);//存储分配失败
    S.top=S.base;
    S.stacksize=MAXSIZE;
    return OK;
}
</code></pre> 
<p><strong>3.入栈</strong></p> 
<pre><code class="prism language-C++">Status Push(SqStack &amp;S,SElemType e){
	if(S.top-S.base==S.stacksize) return ERROR;//栈满
    //*S.top++=e
	*S.top=e;
	S.top++;
	return OK;
}
</code></pre> 
<p><strong>4.出栈</strong></p> 
<pre><code class="prism language-C++">Status Pop(SqStack &amp;S,SElemType &amp;e){
	if(S.top==S.base) return ERROR;//栈满
    //e=*--S.top
	--(S.top);
    e=*S.top;
	return OK;
}
</code></pre> 
<p><strong>5.取栈顶元素</strong></p> 
<pre><code class="prism language-C++">SElemType GetTop(SqStack S){
    if(S.top!=S.base)
        return *(S.top-1);
}
</code></pre> 
<h5><a id="_420"></a>链栈</h5> 
<p>通常链栈用单链表表示，只在链表头部进行操作；</p> 
<p>以链表的头部作为栈顶较为方便，不需要附加一个头结点；</p> 
<p><img src="https://images2.imgbox.com/4e/9e/hJTVgqtD_o.png" alt="在这里插入图片描述"></p> 
<p><strong>1.链栈的存储结构</strong></p> 
<pre><code class="prism language-C++">typedef struct{
    SElemType data;
    struct StackNode *next;
}StackNode,*LinkStack;
</code></pre> 
<p><strong>2.初始化</strong></p> 
<pre><code class="prism language-c++">Status InitStack(LinkStack &amp;S){
    S=NULL;
    return OK;
}
</code></pre> 
<p><strong>3.入栈</strong></p> 
<pre><code class="prism language-C++">Status Push(LinkStack &amp;S,SElemType e){
	StackNode *p;
    p=new StackNode;  // 生成新节点
    p-&gt;data=e;        // 将新节点数据域置为e
    p-&gt;next=S;        // 将新节点插入栈顶
    S=p;              // 修改栈顶指针
    return OK;
}
</code></pre> 
<p><strong>4.出栈</strong></p> 
<pre><code class="prism language-C++">Status Pop(LinkStack &amp;S,SElemType &amp;e){
	if(S==NULL) return ERROR;
    e=S-&gt;data;
    StackNode *p; 
    p=S;	//临时保存栈顶元素空间，以备释放
    S=S-&gt;next;	//修改栈顶指针
    delete p;
    return OK;
}
</code></pre> 
<p><strong>5.取栈顶元素</strong></p> 
<pre><code class="prism language-C++">SElemType GetTop(LinkStack S){
    if(S!=NULL){
        return S-&gt;data;
    }

}
</code></pre> 
<h5><a id="_485"></a>栈与递归</h5> 
<p>栈有一个重要的应用就是在程序设计语言中实现递归；</p> 
<p><strong>遍历输出链表各个结点的递归算法</strong></p> 
<pre><code class="prism language-C++">void TraverseList(LinkList p){
	if(p==NULL) return ;
	else{
		cout&lt;&lt;p-&gt;data&lt;&lt;endl;
		TraverseList(p-&gt;next);
	}
}
</code></pre> 
<h4><a id="_501"></a>队列的定义和特点</h4> 
<p>和栈相反，<strong>队列</strong>是一种先进先出（First In First Out）的线性表；</p> 
<p>允许<strong>插入</strong>的一头称<strong>队尾</strong>，允许<strong>删除</strong>的称<strong>队头</strong>；</p> 
<p>在队列的顺序存储结构中，除了用一组地址连续的存储单元依次存放从队列头到队列尾的元素之外，还设置两个指针，分别指向队列头元素以及队列尾元素，称为<strong>头指针</strong>（front）和<strong>尾指针</strong>（rear）；</p> 
<pre><code class="prism language-c++">#define MAXQSIZE
typedef struct
{
    QElemType *base;//存储空间的基地址
    int front;
    int rear;
}SqQueue;
</code></pre> 
<blockquote> 
 <p><em>在C语言中约定，初始化创建空队列时，令front=rear=0；</em></p> 
 <p><em>每当插入新的队列尾元素时，尾指针rear+1；</em></p> 
 <p><em>每当删除队列头元素时，头指针front+1；；</em></p> 
 <p><em>在非空队列中，头指针始终指向队头元素，尾指针始终指向队尾元素的下一个位置；</em></p> 
</blockquote> 
<p>但这种受限制的操作，往往会造成空间没有占满，指针溢出的“<strong>假溢出</strong>”现象；</p> 
<p>为了解决这种假溢出问题，将顺序队列变成一个环状的空间，称为<strong>循环队列</strong>；</p> 
<p>头指针、尾指针以及队列元素之间的关系不变，只是在循环队列中，头指针尾指针的操作用“模”运算实现；</p> 
<p><img src="https://images2.imgbox.com/ca/56/k08Y962r_o.png" alt="在这里插入图片描述"></p> 
<p>对于循环队列，不能以头指针、尾指针的值是否相同来判断队满还是队空，通常有两种处理方法：</p> 
<p><strong>1.少用一个元素空间；</strong></p> 
<p><code>队空：Q.front==Q.rear;</code></p> 
<p><code>队满：（Q.rear+1）%MAXQSIZE==Q.front;</code></p> 
<p><strong>2.另设一个标识以区分队满、队空；</strong></p> 
<h5><a id="_548"></a>循环队列的操作</h5> 
<pre><code class="prism language-C++">//1.初始化
Status InitQueue(SqQueue &amp;Q){
    Q.base=new QElemType[MAXQSIZE];
    if(!Q.base) exit(OVERFLOW);
    Q.front=Q.rear=0;
    return OK;
}

//2.求队列长度
int QueueLength(SqQueue Q){
    return (Q.rear-Q.front+MAXQSIZE)%MAXQSIZE;
}

//3.入队
Status InsertQueue(SqQueue &amp;Q,QElemType e)
{
	if ((Q.rear + 1) % MAXQSIZE == Q.front) return ERROR; //队列已满时，不执行入队操作
	Q.base[Q.rear] = e;  //将元素放入队列尾部
	Q.rear = (Q.rear + 1) % MAXQSIZE; //尾部元素指向下一个空间位置,取模运算保证了索引不越界（余数一定小于除数）
    return OK;
}

//4.出队
Status DeleteQueue(SqQueue &amp;Q,QElemType &amp;e)
{
	if (Q.front == Q.rear)  return ERROR;  //空队列，直接返回
	e = Q.base[Q.front];            //头部元素出队
	Q.front = (Q.front + 1) % MAXSIZE;
    return OK;
}

//5.取队头元素
QElemType GetHead(SqQueue Q){
    if(Q.front!=Q.rear)
        return Q.base[Q.front];
}
</code></pre> 
<h5><a id="_589"></a>队列的链式表示和实现</h5> 
<p><strong>队列的链式存储结构</strong></p> 
<pre><code class="prism language-c++">typedef struct QNode
{
    QElemType data;
    struct QNode *next;    
}QNode,*QueuePtr;
typedef struct
{
    QueuePtr front;//队头指针
    struct rear;//队尾指针
}LinkQueue;
</code></pre> 
<p><img src="https://images2.imgbox.com/ce/dd/EJpsiVPv_o.png" alt="在这里插入图片描述"></p> 
<pre><code class="prism language-C++">//1.初始化
Status InitQueue(LinkQueue &amp;Q){
    Q.front=Q.rear=new QNode;
    Q.front-&gt;next=NULL;
    return OK;
}


//3.入队
Status InsertQueue(LinkQueue &amp;Q,QElemType e)
{
    p=new QNode;
    p-&gt;data=e;
    p-&gt;next=NULL;
    Q.rear-&gt;next=p;  
	return OK;
}

//4.出队
Status DeleteQueue(LinkQueue &amp;Q,QElemType &amp;e)
{
	if (Q.front == Q.rear)  return ERROR;  //空队列，直接返回
	p=new QNode;
    p=Q.front-&gt;next;
    e=p-&gt;data;
    Q.front-&gt;next=p-&gt;next;
    if(Q.rear==p)
        Q.rear=Q.front;
    delete p;
    return OK;
}

//5.取队头元素
QElemType GetHead(LinkQueue Q){
    if(Q.front!=Q.rear)
        return Q.front-&gt;next-&gt;data;
}
</code></pre> 
<h3><a id="_650"></a>串、数组、和广义表</h3> 
<h4><a id="_652"></a>串的定义</h4> 
<p><strong>串（string）<strong>是由零个或多个字符构成的</strong>有限序列</strong>，一般记为s=“a1 a2 a3…an”；</p> 
<p>其中，s是<strong>串名</strong>，a1 a2 …an是串的值；</p> 
<p>串中字符的数目n，称为串的<strong>长度</strong>；</p> 
<p>零个字符的串称为<strong>空串</strong>，其长度为0；</p> 
<p>串中任意个连续的字符组成的子序列称为该串的<strong>子串</strong>，包含子串的串相应的称为主串；</p> 
<p>通常，称字符在序列中的序号为该字符在串中的位置；</p> 
<p>称两个串是相等的，也就是说两个串长度相等，并且各个对应位置的字符都相等；</p> 
<h4><a id="_668"></a>串的存储结构</h4> 
<p>与线性表类似，串也有两种基本存储结构：顺序存储和链式存储；</p> 
<p>但考虑到存储效率和算法的方便性，串多采用<strong>顺序存储结构</strong>；</p> 
<pre><code class="prism language-C++">//-----串的定长顺序存储-----
#define MAXLINE 255	//串的最大长度
typedef struct{
    char ch[MAXLEN+1];	//存储串的一维数组
    int length;	//串当前的长度
}SString;
</code></pre> 
<p>这是一种静态的定义方式，在编译时刻就确定了串空间的大小；</p> 
<p>在C语言中，存在一个称之为“堆”的自由存储区域，可以为每个新产生的串动态分配一块实际串长所需的存储空间，若分配成功，返回一个指向起始地址的指针，作为串的基址；</p> 
<pre><code class="prism language-C++">//-----串的堆式顺序存储-----
typedef struct{
    char *ch;	//非空串，按串长分配存储区，否则ch为NULL
    int length;	//串当前的长度
}HString;
</code></pre> 
<h4><a id="_695"></a>串的模式匹配算法</h4> 
<p>子串的定位运算通常称为串的<strong>模式匹配</strong>或<strong>串匹配</strong>；</p> 
<p>串的模式匹配设有两个字符串S和T，S为主串，T为子串；</p> 
<p>著名的模式匹配算法是BF算法和KMP算法；</p> 
<h5><a id="1BF_703"></a>1.BF算法</h5> 
<p>BF算法，即暴力(Brute Force)算法；</p> 
<p><strong>BF算法的思想</strong>是：</p> 
<p>1.将目标串S的第一个字符与模式串T的第一个字符进行匹配；</p> 
<p>2.若相等，则继续比较S的第二个字符和 T的第二个字符；若不相等，则比较S的第二个字符和T的第一个字符；</p> 
<p>3.依次比较下去，直到得出最后的匹配结果；</p> 
<p><strong>算法效率：</strong></p> 
<p><strong>若主串长度位m，子串长度位n，则：</strong></p> 
<p>最好情况平均时间复杂度：O(m+n)<br> 最坏情况平均时间复杂度：O(m*n）</p> 
<h5><a id="2KMP_722"></a>2.KMP算法</h5> 
<p>KMP算法的改进在于：每当一次匹配过程出现字符比较不相等时，不需要回溯指针到i-j+2的位置，而是利用已经得到的部分匹配的结果，将模式串尽可能地向右滑动一段距离，继续进行比较；</p> 
<p>什么是前缀，<strong>除了最后一个字符</strong>的所有子串。</p> 
<p>什么是后缀，<strong>除了第一个字符</strong>的所有子串。</p> 
<p>然后我们给出一个<strong>公共前后缀</strong>的概念：<strong>就是指长度最大且相等的前缀和后缀</strong>；</p> 
<p><img src="https://images2.imgbox.com/76/2d/n4DH8rHK_o.png" alt="在这里插入图片描述"></p> 
<p>假设模式串中绿色的地方是j前面的子串的公共前后缀，当在j位置出现不匹配时，将前缀移动到后缀的位置，继续进行匹配；</p> 
<p><img src="https://images2.imgbox.com/84/9e/8u7UcWry_o.png" alt="在这里插入图片描述"></p> 
<hr> 
<p><img src="https://images2.imgbox.com/eb/6c/Ab8GE42T_o.png" alt="在这里插入图片描述"></p> 
<p>而这个滑动的过程，需要依赖模式串的next[j]函数，由此来引出模式串的next函数的赋值规则：</p> 
<p><img src="https://images2.imgbox.com/2c/65/16lcfBMY_o.png" alt="在这里插入图片描述"></p> 
<h4><a id="_747"></a>数组</h4> 
<p>数组是由类型相同的数据元素构成的有序集合，每个元素称为数组元素，每个元素受n(n&gt;=1)个线性关系的约束，每个元素在n个线性关系中的序号称为该元素的下标，可以通过下标访问数据元素；</p> 
<p>因为数组中每个元素处于n个关系中，故称该数组为n维数组；</p> 
<p>数组可以看作是线性表的推广，其特点是结构中元素本身可以说具有某种结构的数据，但属于同一数据类型；</p> 
<h5><a id="_755"></a>数组的顺序存储</h5> 
<p>数组一般不做插入删除操作，一旦建立数组，则结构中的数据元素个数和元素之间的关系不再发生变动；</p> 
<p>由于存储单元是一维的结构，而数组可能是多维的结构，则用一组连续存储单元存放数组的数据元素就有次序约定问题；</p> 
<p>对应的二维数组有两种存储方式：一种是以列序列为主序列的存储方式，一种是行序列为主序列的存储方式；</p> 
<p>假设每个数据元素占L个存储单元，则二维数组中任一元素a(ij)的存储位置可由下式确定：<br> <span class="katex--display"><span class="katex-display"><span class="katex"><span class="katex-mathml"> 
      
       
        
        
          L 
         
        
          O 
         
        
          C 
         
        
          （ 
         
        
          i 
         
        
          ， 
         
        
          j 
         
        
          ） 
         
        
          = 
         
        
          L 
         
        
          O 
         
        
          C 
         
        
          （ 
         
        
          0 
         
        
          ， 
         
        
          0 
         
        
          ） 
         
        
          + 
         
        
          （ 
         
        
          n 
         
        
          ∗ 
         
        
          i 
         
        
          + 
         
        
          j 
         
        
          ） 
         
        
          L 
         
        
       
         LOC（i，j）=LOC（0，0）+（n*i+j）L 
        
       
     </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.87777em; vertical-align: -0.19444em;"></span><span class="mord mathdefault">L</span><span class="mord mathdefault" style="margin-right: 0.02778em;">O</span><span class="mord mathdefault" style="margin-right: 0.07153em;">C</span><span class="mord cjk_fallback">（</span><span class="mord mathdefault">i</span><span class="mord cjk_fallback">，</span><span class="mord mathdefault" style="margin-right: 0.05724em;">j</span><span class="mord cjk_fallback">）</span><span class="mspace" style="margin-right: 0.277778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right: 0.277778em;"></span></span><span class="base"><span class="strut" style="height: 0.76666em; vertical-align: -0.08333em;"></span><span class="mord mathdefault">L</span><span class="mord mathdefault" style="margin-right: 0.02778em;">O</span><span class="mord mathdefault" style="margin-right: 0.07153em;">C</span><span class="mord cjk_fallback">（</span><span class="mord">0</span><span class="mord cjk_fallback">，</span><span class="mord">0</span><span class="mord cjk_fallback">）</span><span class="mspace" style="margin-right: 0.222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right: 0.222222em;"></span></span><span class="base"><span class="strut" style="height: 0.46528em; vertical-align: 0em;"></span><span class="mord cjk_fallback">（</span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right: 0.222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right: 0.222222em;"></span></span><span class="base"><span class="strut" style="height: 0.74285em; vertical-align: -0.08333em;"></span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right: 0.222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right: 0.222222em;"></span></span><span class="base"><span class="strut" style="height: 0.87777em; vertical-align: -0.19444em;"></span><span class="mord mathdefault" style="margin-right: 0.05724em;">j</span><span class="mord cjk_fallback">）</span><span class="mord mathdefault">L</span></span></span></span></span></span></p> 
<h5><a id="_768"></a>特殊矩阵的压缩存储</h5> 
<p>所谓压缩存储，是指为多个值相同的元只分配一个存储空间，对零元不分配空间；</p> 
<h6><a id="1_772"></a>1.对称矩阵</h6> 
<p>对于对称矩阵，可为每一对对称元分配一个存储空间，则可将n*n个元素压缩到n(n+1)/2个元的空间中；</p> 
<h6><a id="2_776"></a>2.三角矩阵</h6> 
<p>只存储下或（上）三角包括主对角线的数据元素；</p> 
<p>下标：0…n*(n+1)/2-1;</p> 
<p>如果是下三角矩阵，A[i] [j]在B中位置k=(i+1)*i/2+j;</p> 
<p>反之，A[i] [j]在B中位置k=(j+1)*j/2+i;</p> 
<h6><a id="3_786"></a>3.对角矩阵</h6> 
<p>矩阵半带宽：主对角线上下方各有b条对角线；</p> 
<p>矩阵带宽：2*b+1；</p> 
<blockquote> 
 <p>只存储带状区内的元素；</p> 
</blockquote> 
<p>除了第一行和最后一行各有b+1个元素，其余各行均有2*b+1个元素；</p> 
<h6><a id="4_796"></a>4.稀疏矩阵</h6> 
<p>矩阵A中有s个非零元素，稀疏因子e=S/m*n《=0.05，则为稀疏矩阵；</p> 
<p><strong>存储方式</strong>：只记录非0元素（节约空间，丧失随机存取功能）；</p> 
<p><strong>顺序存储：三元表</strong></p> 
<p><img src="https://images2.imgbox.com/22/7e/yGJZ7q77_o.png" alt="在这里插入图片描述"></p> 
<p>稀疏矩阵的转置转换为对应三元表的转置；</p> 
<p><img src="https://images2.imgbox.com/6d/a3/vIciJkA2_o.png" alt="在这里插入图片描述"></p> 
<p>快速转置算法：</p> 
<p><img src="https://images2.imgbox.com/04/56/mvenvFO0_o.png" alt="在这里插入图片描述"></p> 
<p><strong>链式存储：十字链表</strong></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/d9263d4803148327c8a64d4df73f2209/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">STM32G0系列的启动配置与程序下载说明</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/58e225ec5c22761c279c891dd7b35c1b/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">Source Insight 3.5 插件支持utf8</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>