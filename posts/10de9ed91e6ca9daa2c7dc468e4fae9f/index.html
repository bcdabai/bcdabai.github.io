<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>C语言二叉树建立与遍历—实验报告 - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="C语言二叉树建立与遍历—实验报告" />
<meta property="og:description" content="目录 二叉树建立与遍历实验报告
源码 二叉树建立与遍历实验报告 系别
计算机学院
班级
学号
姓名
课程名称
数据结构
实验日期
实验名称
二叉树的建立与遍历算法应用
成绩
实验目的：
熟悉掌握二叉链表存储结构及基本算法，并能应用二叉树的基本算法解决与之有关的简单问题，训练和提高结构化程序设计能力及程序调试能力。
实验条件：
计算机一台，Visual C&#43;&#43;6.0或DEV C&#43;&#43;
实验内容：
问题描述判断一棵二叉树是否为满二叉树。要求二叉树用二叉链表存储,用先序、中序、后序递归遍历算法的任意两种输出二叉树中所有结点，编写程序判断该树是否为满二叉树。
数据结构类型定义typedef struct node {
int val; // 结点的值
struct node *left; // 左子树指针
struct node *right; // 右子树指针
} TreeNode, *Tree;
模块划分
建立二叉树：void createTree(Tree *t)判断一棵二叉树是否为满二叉树：int isFullTree(Tree t)中序遍历：void inOrder(Tree t)后序遍历：void postOrder(Tree t)二叉树高度：int height(Tree t)主函数：int main()
详细设计#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
// 定义二叉树的结点结构
typedef struct node {
int val; // 结点的值" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/10de9ed91e6ca9daa2c7dc468e4fae9f/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-12-06T11:20:43+08:00" />
<meta property="article:modified_time" content="2023-12-06T11:20:43+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">C语言二叉树建立与遍历—实验报告</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <h2><strong>目录</strong></h2> 
<p id="%E4%BA%8C%E5%8F%89%E6%A0%91%E5%BB%BA%E7%AB%8B%E4%B8%8E%E9%81%8D%E5%8E%86%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A-toc" style="margin-left:0px;"><a href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E5%BB%BA%E7%AB%8B%E4%B8%8E%E9%81%8D%E5%8E%86%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A" rel="nofollow">二叉树建立与遍历实验报告</a></p> 
<p id="%E6%BA%90%E7%A0%81%C2%A0-toc" style="margin-left:0px;"><a href="#%E6%BA%90%E7%A0%81%C2%A0" rel="nofollow">源码 </a></p> 
<hr> 
<h2 id="%E4%BA%8C%E5%8F%89%E6%A0%91%E5%BB%BA%E7%AB%8B%E4%B8%8E%E9%81%8D%E5%8E%86%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A" style="margin-left:0px;text-align:center;"><strong>二叉树建立与遍历实验报告</strong></h2> 
<table cellspacing="0" style="margin-left:5.4pt;width:459pt;"><tbody><tr><td style="border-color:#000000;vertical-align:top;width:44.35pt;"> <p style="margin-left:0;text-align:justify;">系别</p> </td><td colspan="2" style="border-color:#000000;vertical-align:top;width:79.2pt;"> <p style="margin-left:0;text-align:justify;">计算机学院</p> </td><td style="border-color:#000000;vertical-align:top;width:45.2pt;"> <p style="margin-left:0;text-align:justify;">班级</p> </td><td style="border-color:#000000;vertical-align:top;width:52.05pt;"> <p style="margin-left:0;text-align:justify;"></p> </td><td style="border-color:#000000;vertical-align:top;width:40.2pt;"> <p style="margin-left:0;text-align:justify;">学号</p> </td><td colspan="2" style="border-color:#000000;vertical-align:top;width:74.9pt;"> <p style="margin-left:0;text-align:justify;"></p> </td><td style="border-color:#000000;vertical-align:top;width:44.4pt;"> <p style="margin-left:0;text-align:justify;">姓名</p> </td><td style="border-color:#000000;vertical-align:top;width:78.7pt;"> <p style="margin-left:0;text-align:justify;"></p> </td></tr><tr><td colspan="2" style="border-color:#000000;vertical-align:top;width:70.45pt;"> <p style="margin-left:0;text-align:justify;">课程名称</p> </td><td colspan="5" style="vertical-align:top;width:235.35pt;"> <p style="margin-left:0;text-align:justify;">数据结构</p> </td><td colspan="2" style="vertical-align:top;width:74.5pt;"> <p style="margin-left:0;text-align:justify;">实验日期</p> </td><td style="vertical-align:top;width:78.7pt;"> <p style="margin-left:0;text-align:justify;"></p> </td></tr><tr><td colspan="2" style="border-color:#000000;vertical-align:top;width:70.45pt;"> <p style="margin-left:0;text-align:justify;">实验名称</p> </td><td colspan="6" style="vertical-align:top;width:265.45pt;"> <p style="margin-left:0;text-align:justify;">二叉树的建立与遍历算法应用</p> </td><td style="vertical-align:top;width:44.4pt;"> <p style="margin-left:0;text-align:justify;">成绩</p> </td><td style="vertical-align:top;width:78.7pt;"> <p style="margin-left:0;text-align:justify;"></p> </td></tr><tr><td colspan="10" style="border-color:#000000;vertical-align:top;width:459pt;"> <p style="margin-left:0;text-align:justify;">实验目的：</p> <p style="margin-left:0;text-align:justify;">熟悉掌握二叉链表存储结构及基本算法，并能应用二叉树的基本算法解决与之有关的简单问题，训练和提高结构化程序设计能力及程序调试能力。</p> </td></tr><tr><td colspan="10" style="border-color:#000000;vertical-align:top;width:459pt;"> <p style="margin-left:0;text-align:justify;">实验条件：</p> <p style="margin-left:0;text-align:justify;">计算机一台，Visual C++6.0或DEV C++</p> </td></tr><tr><td colspan="10" style="border-color:#000000;vertical-align:top;width:459pt;"> <p style="margin-left:0;text-align:justify;">实验内容：</p> 
    <ol><li style="text-align:justify;">问题描述</li></ol><p style="margin-left:0;text-align:justify;">判断一棵二叉树是否为满二叉树。要求二叉树用二叉链表存储,用先序、中序、后序递归遍历算法的任意两种输出二叉树中所有结点，编写程序判断该树是否为满二叉树。</p> 
    <ol><li style="text-align:justify;">数据结构类型定义</li></ol><p style="margin-left:0;text-align:justify;">typedef struct node {<!-- --></p> <p style="margin-left:0;text-align:justify;">    int val; // 结点的值</p> <p style="margin-left:0;text-align:justify;">    struct node *left; // 左子树指针</p> <p style="margin-left:0;text-align:justify;">    struct node *right; // 右子树指针</p> <p style="margin-left:0;text-align:justify;">} TreeNode, *Tree;</p> <p style="margin-left:0;text-align:justify;"></p> 
    <ol><li style="text-align:justify;">模块划分</li></ol><p style="margin-left:0;text-align:justify;"></p> 
    <ol><li style="text-align:justify;">建立二叉树：void createTree(Tree *t)</li><li style="text-align:justify;">判断一棵二叉树是否为满二叉树：int isFullTree(Tree t)</li><li style="text-align:justify;">中序遍历：void inOrder(Tree t)</li><li style="text-align:justify;">后序遍历：void postOrder(Tree t)</li><li style="text-align:justify;">二叉树高度：int height(Tree t)</li><li style="text-align:justify;">主函数：int main()</li></ol><p style="margin-left:0;text-align:justify;"></p> 
    <ol><li style="text-align:justify;">详细设计</li></ol><p style="margin-left:0;text-align:justify;">#include &lt;stdio.h&gt;</p> <p style="margin-left:0;text-align:justify;">#include &lt;stdlib.h&gt;</p> <p style="margin-left:0;text-align:justify;">// 定义二叉树的结点结构</p> <p style="margin-left:0;text-align:justify;">typedef struct node {<!-- --></p> <p style="margin-left:0;text-align:justify;">    int val; // 结点的值</p> <p style="margin-left:0;text-align:justify;">    struct node *left;</p> <p style="margin-left:0;text-align:justify;">    struct node *right;</p> <p style="margin-left:0;text-align:justify;">} TreeNode, *Tree;</p> <p style="margin-left:0;text-align:justify;">// 创建一棵二叉树，用先序遍历的方式输入结点的值，用#表示空结点</p> <p style="margin-left:0;text-align:justify;">void createTree(Tree *t) {<!-- --></p> <p style="margin-left:0;text-align:justify;">    char x;</p> <p style="margin-left:0;text-align:justify;">    scanf("%c ", &amp;x);</p> <p style="margin-left:0;text-align:justify;">    if (x == '#') {<!-- --></p> <p style="margin-left:0;text-align:justify;">        *t = NULL; // 空结点</p> <p style="margin-left:0;text-align:justify;">    }</p> <p style="margin-left:0;text-align:justify;">    else {<!-- --></p> <p style="margin-left:0;text-align:justify;">        *t = (TreeNode *)malloc(sizeof(TreeNode));</p> <p style="margin-left:0;text-align:justify;">        (*t)-&gt;val = x - '0';</p> <p style="margin-left:0;text-align:justify;">        createTree(&amp;(*t)-&gt;left);</p> <p style="margin-left:0;text-align:justify;">        createTree(&amp;(*t)-&gt;right);   </p> <p style="margin-left:0;text-align:justify;">    }</p> <p style="margin-left:0;text-align:justify;">   </p> <p style="margin-left:0;text-align:justify;">}</p> <p style="margin-left:0;text-align:justify;"></p> <p style="margin-left:0;text-align:justify;">// 计算二叉树的高度</p> <p style="margin-left:0;text-align:justify;">int height(Tree t) {<!-- --></p> <p style="margin-left:0;text-align:justify;">    if (t == NULL) {<!-- --></p> <p style="margin-left:0;text-align:justify;">        return 0;</p> <p style="margin-left:0;text-align:justify;">    } else {<!-- --></p> <p style="margin-left:0;text-align:justify;">        int leftHeight = height(t-&gt;left);</p> <p style="margin-left:0;text-align:justify;">        int rightHeight = height(t-&gt;right);</p> <p style="margin-left:0;text-align:justify;">        return leftHeight &gt; rightHeight ? leftHeight + 1 : rightHeight + 1;</p> <p style="margin-left:0;text-align:justify;">    }</p> <p style="margin-left:0;text-align:justify;">}</p> <p style="margin-left:0;text-align:justify;"></p> <p style="margin-left:0;text-align:justify;">// 判断一棵二叉树是否为满二叉树</p> <p style="margin-left:0;text-align:justify;">int isFullTree(Tree t) {<!-- --></p> <p style="margin-left:0;text-align:justify;">    if (t == NULL) {<!-- --></p> <p style="margin-left:0;text-align:justify;">        return 1; // 空树是满二叉树</p> <p style="margin-left:0;text-align:justify;">    } else {<!-- --></p> <p style="margin-left:0;text-align:justify;">        return isFullTree(t-&gt;left) &amp;&amp; isFullTree(t-&gt;right) &amp;&amp; height(t-&gt;left) == height(t-&gt;right);    }</p> <p style="margin-left:0;text-align:justify;">}</p> <p style="margin-left:0;text-align:justify;"></p> <p style="margin-left:0;text-align:justify;">void preorder(Tree t) {<!-- --></p> <p style="margin-left:0;text-align:justify;">    if (t != NULL) {<!-- --></p> <p style="margin-left:0;text-align:justify;">        printf("%d ", t-&gt;val);</p> <p style="margin-left:0;text-align:justify;">        preorder(t-&gt;left);</p> <p style="margin-left:0;text-align:justify;">        preorder(t-&gt;right);</p> <p style="margin-left:0;text-align:justify;">    }</p> <p style="margin-left:0;text-align:justify;">}</p> <p style="margin-left:0;text-align:justify;"></p> <p style="margin-left:0;text-align:justify;">// 中序遍历二叉树</p> <p style="margin-left:0;text-align:justify;">void inOrder(Tree t) {<!-- --></p> <p style="margin-left:0;text-align:justify;">    if (t != NULL) {<!-- --></p> <p style="margin-left:0;text-align:justify;">        inOrder(t-&gt;left);</p> <p style="margin-left:0;text-align:justify;">        printf("%d ", t-&gt;val);</p> <p style="margin-left:0;text-align:justify;">        inOrder(t-&gt;right);</p> <p style="margin-left:0;text-align:justify;">    }</p> <p style="margin-left:0;text-align:justify;">}</p> <p style="margin-left:0;text-align:justify;"></p> <p style="margin-left:0;text-align:justify;">// 后序遍历二叉树</p> <p style="margin-left:0;text-align:justify;">void postOrder(Tree t) {<!-- --></p> <p style="margin-left:0;text-align:justify;">    if (t != NULL) {<!-- --></p> <p style="margin-left:0;text-align:justify;">        postOrder(t-&gt;left);</p> <p style="margin-left:0;text-align:justify;">        postOrder(t-&gt;right);</p> <p style="margin-left:0;text-align:justify;">        printf("%d ", t-&gt;val);</p> <p style="margin-left:0;text-align:justify;">    }</p> <p style="margin-left:0;text-align:justify;">}</p> <p style="margin-left:0;text-align:justify;"></p> <p style="margin-left:0;text-align:justify;">int main() {<!-- --></p> <p style="margin-left:0;text-align:justify;">    Tree t;</p> <p style="margin-left:0;text-align:justify;">    printf("输入二叉树结点，用先序遍历的方式，用#表示空结点：\n");</p> <p style="margin-left:0;text-align:justify;">    createTree(&amp;t); // 创建一棵二叉树</p> <p style="margin-left:0;text-align:justify;">    printf("先序遍历二叉树：\n");</p> <p style="margin-left:0;text-align:justify;">    preorder(t); // 先序遍历二叉树</p> <p style="margin-left:0;text-align:justify;">    printf("\n");</p> <p style="margin-left:0;text-align:justify;">    printf("中序遍历二叉树：\n");</p> <p style="margin-left:0;text-align:justify;">    inOrder(t); // 中序遍历二叉树</p> <p style="margin-left:0;text-align:justify;">    printf("\n");</p> <p style="margin-left:0;text-align:justify;">    printf("后序遍历二叉树：\n");</p> <p style="margin-left:0;text-align:justify;">    postOrder(t); // 后序遍历二叉树</p> <p style="margin-left:0;text-align:justify;">    printf("\n");</p> <p style="margin-left:0;text-align:justify;">    if (isFullTree(t)) { // 判断是否为满二叉树</p> <p style="margin-left:0;text-align:justify;">        printf("是满二叉树\n");</p> <p style="margin-left:0;text-align:justify;">    } else {<!-- --></p> <p style="margin-left:0;text-align:justify;">        printf("不是满二叉树\n");</p> <p style="margin-left:0;text-align:justify;">    }</p> <p style="margin-left:0;text-align:justify;">    system("pause");</p> <p style="margin-left:0;text-align:justify;">    return 0;</p> <p style="margin-left:0;text-align:justify;">}</p> <p style="margin-left:0;text-align:justify;"></p> 
    <ol><li style="text-align:justify;">测试数据及结果</li></ol><p style="margin-left:0;text-align:justify;"></p> </td></tr><tr><td colspan="10" style="border-color:#000000;vertical-align:top;width:459pt;"> <p style="margin-left:0;text-align:justify;"></p> <p style="margin-left:0;text-align:justify;"><img alt="" height="243" src="https://images2.imgbox.com/04/bf/v54PRXOb_o.png" width="465"></p> <p style="margin-left:0;text-align:justify;"></p> <p style="margin-left:0;text-align:justify;"><img alt="" height="212" src="https://images2.imgbox.com/63/83/2rE3vGat_o.png" width="393"></p> <p style="margin-left:0;text-align:justify;"></p> <p style="margin-left:0;text-align:justify;"></p> <p style="margin-left:0;text-align:justify;"></p> <p style="margin-left:0;text-align:justify;"></p> </td></tr><tr><td colspan="10" style="border-color:#000000;vertical-align:top;width:459pt;"> <p style="margin-left:0;text-align:justify;">实验总结：</p> <p style="margin-left:0;text-align:justify;"></p> <p style="margin-left:0;text-align:justify;">无</p> </td></tr><tr><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr></tbody></table> 
<h2 id="%E6%BA%90%E7%A0%81%C2%A0">源码 </h2> 
<pre><code class="language-cpp">#include &lt;stdio.h&gt;

#include &lt;stdlib.h&gt;

// 定义二叉树的结点结构

typedef struct node {

    int val; // 结点的值

    struct node *left;

    struct node *right;

} TreeNode, *Tree;

// 创建一棵二叉树，用先序遍历的方式输入结点的值，用#表示空结点

void createTree(Tree *t) {

    char x;

    scanf("%c ", &amp;x);

    if (x == '#') {

        *t = NULL; // 空结点

    }

    else {

        *t = (TreeNode *)malloc(sizeof(TreeNode));

        (*t)-&gt;val = x - '0';

        createTree(&amp;(*t)-&gt;left);

        createTree(&amp;(*t)-&gt;right);   

    }

   

}



// 计算二叉树的高度

int height(Tree t) {

    if (t == NULL) {

        return 0;

    } else {

        int leftHeight = height(t-&gt;left);

        int rightHeight = height(t-&gt;right);

        return leftHeight &gt; rightHeight ? leftHeight + 1 : rightHeight + 1;

    }

}



// 判断一棵二叉树是否为满二叉树

int isFullTree(Tree t) {

    if (t == NULL) {

        return 1; // 空树是满二叉树

    } else {

        return isFullTree(t-&gt;left) &amp;&amp; isFullTree(t-&gt;right) &amp;&amp; height(t-&gt;left) == height(t-&gt;right);    }

}



void preorder(Tree t) {

    if (t != NULL) {

        printf("%d ", t-&gt;val);

        preorder(t-&gt;left);

        preorder(t-&gt;right);

    }

}



// 中序遍历二叉树

void inOrder(Tree t) {

    if (t != NULL) {

        inOrder(t-&gt;left);

        printf("%d ", t-&gt;val);

        inOrder(t-&gt;right);

    }

}



// 后序遍历二叉树

void postOrder(Tree t) {

    if (t != NULL) {

        postOrder(t-&gt;left);

        postOrder(t-&gt;right);

        printf("%d ", t-&gt;val);

    }

}



int main() {

    Tree t;

    printf("输入二叉树结点，用先序遍历的方式，用#表示空结点：\n");

    createTree(&amp;t); // 创建一棵二叉树

    printf("先序遍历二叉树：\n");

    preorder(t); // 先序遍历二叉树

    printf("\n");

    printf("中序遍历二叉树：\n");

    inOrder(t); // 中序遍历二叉树

    printf("\n");

    printf("后序遍历二叉树：\n");

    postOrder(t); // 后序遍历二叉树

    printf("\n");

    if (isFullTree(t)) { // 判断是否为满二叉树

        printf("是满二叉树\n");

    } else {

        printf("不是满二叉树\n");

    }

    system("pause");

    return 0;

}</code></pre> 
<p> </p> 
<p style="margin-left:0;text-align:justify;"></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/5db75d8812d43efe0dbc3025bf548b1c/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">tg - 3541 cea (TCXO)简单封装晶体振荡器（KHZ范围）</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/c1f099e37897b54e6512fd4309505b48/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">H5: div与textarea输入框的交互（聚焦、失去焦点、键盘收起）</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>