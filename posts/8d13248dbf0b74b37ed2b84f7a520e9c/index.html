<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>ROS Navigation导航包介绍 - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="ROS Navigation导航包介绍" />
<meta property="og:description" content="Navigation功能包集概述 这是2D的导航功能包集，通过接收里程计数据、tf坐标变换树以及传感器数据，为移动机器人输出目标位置以及安全速度。概念层面上讲，导航功能包集是相当简单的。 它从里程计和传感器数据流获取信息，并将速度命令发送给移动基站（比如你的机器人）。但是，想要在任意机器人上使用导航功能包集可能有点复杂。使用导航功能包集的先决条件是，机器人必须运行ROS，有一个tf变换树，使用正确的ROS Message types发布传感器数据。而且，我们需要在高层为一个具有一定形状和动力学特点的机器人配置导航功能包集。
acml：是一个针对在二维移动的机器人的基于概率定位系统。它实现了自适应蒙特卡罗滤波的定位方法，并使用粒子滤波器去跟踪在已知地图中机器人的位置。
base_local_planner：这个包提供了Trajectory Rollout以及Dynamic Window两种在2D平面局部导航的方法。通过提供一个跟随的规划路径和一个代价地图，控制器生成速度指令并发送至机器人。它支持全向和非全向机器人，以及任何可以用多边形或圆描述的机器人轮廓，并且可以在launch文件中设置这些参数。这个包已经被封装好，可以通过nav_core包的BaseLocolPlanner接口来调用。
carrot_planner：这个规划器是一个简单的全局规划器，可以通过nav_core::BaseGlobalPlanner 来进行调用，并且被move_base节点用作一个全局规划的插件。这个规划器从用户处采集到一个目标点，之后检查用户指定的目标点是否是障碍物，如果是的话沿着robot与目标点构成的向量向后退，直到找到一点没有障碍物位置。之后它会将此目标点作为目标发送给局部规划器和控制器。这个规划器允许机器人尽可能到达离用户指定的目标点最近的位置。
clear_costmap_recovery：为导航包提供了一种自救行为，试图通过将代价地图还原成已知区域外的静态地图从而清除出空间。
costmap_2d：通过激光或点云的数据，投影到2D平面上，创建代价地图，并可以设置膨胀半径。
dwa_local_planner：局部规划器，提供动态窗口方法（ Dynamic Window Approach）在平面上局部导航。与base_local_planner类似。
fake_localization：提供了一个简单节点fake_localization node，可以代替一个定位系统，并提供了acml包的ROS API的子集。由于较低的计算量，这个节点非常频繁的用于在仿真环境中提供完美的定位。这个节点将里程计数据转换为位置、粒子云，并以acml发布的数据格式发布。
global_planner：全局路径规划节点。
map_server：将代价地图作为ROS Service发布，提供了map_saver节点，可以通过命令行存储地图。
move_base：提供了action动作的实现（actionlib包），即给定一个世界系下的目标位置，机器人会试图移动到该位置。另外，move_base节点中包含了两个代价地图（全局、局部），以及一个全局规划器和一个局部规划器，以便实现导航任务。
move_base_msgs： 通过MoveBase.action文件定义产生的消息文件，用于actionlib与move_base的通信。
move_slow_and_clear：为robot提供一种自救行为，即清除代价地图的信息并限制机器人速度，但这不绝对安全，robot可能会撞到某些障碍。但这是唯一一种可以与允许最大速度动态设置的局部规划器兼容的自救行为。
nav_core：为robot实现导航任务提供了通用的接口，包括BaseGlobalPlanner，BaseLocalPlanner,， RecoveryBehavior interfaces等，这有利于方便的更新规划器或者自救行为的版本。
navfn：全局规划器，提供了一个快速插值的函数，可以在起始点到目标点之间快速插值，并找到代价最小的一条路径。
robot_pose_ekf：这个包用于估计robot的三维位置，利用扩展卡尔曼滤波的方法，建立了一个六维模型，联合了轮子里程计、IMU、视觉里程计的数据。
rotate_recovery：提供了一种自救行为，通过旋转360度来清除空间。
voxel_grid：提供一个有效的三维体素网格的实现
导航框架
这幅图描述了使用Navigation导航包的一个整体框架，其核心是move_base节点，包含了global_planner、local_planner、global_costmap、local_costmap、recovery_behaviors五个模块，move_base节点订阅tf（坐标系转换）、odom（里程计数据）、map（地图）、sensor datas（激光数据或点云）以及goal等话题，之后发布cmd_vel话题。
tf：利用ROS的tf工具发布坐标系之间的转换关系，包括：/map-&gt;/odom，/odom-&gt;/base_link，/base_link-&gt;/sensor等 odom：导航包需要用到里程计的数据，故需将其用tf工具和nav_msgs/Odometry消息发布出来 map：在导航前，最好可以提供一张全局的地图，因此需要我们提前创建（但这不是必须的） sensor data：用于避障，建图等等，可以是激光雷达的平面数据或者是点云数据（sensor_msgs/LaserScan or sensor_msgs/PointCloud ） goal：目标在全局地图中的坐标，用geometry_msgs/PoseStamped消息格式发布 此外，move_base节点还提供了action动作的接口（即SimpleActionServer的实现，详细可见actionlib包），包括订阅了move_base/goal (move_base_msgs/MoveBaseActionGoal)，move_base/cancel (actionlib_msgs/GoalID)两个话题，并发布了move_base/feedback (move_base_msgs/MoveBaseActionFeedback)、move_base/status (actionlib_msgs/GoalStatusArray)、move_base/result (move_base_msgs/MoveBaseActionResult)等三个话题。因此用户可以自己写一个利用actionlib库写一个发布目标位置的节点。
在熟悉完整个导航框架后，我们就可以开始依次做好相应的准备工作了。需要的步骤如下：
1、搭建一个移动平台，使其订阅/cmd_vel话题，并发布odom里程计数据以及/odom-&gt;/base_link的tf数据？？
2、将传感器数据（激光数据或RGB-D点云数据）发布出来
3、创建地图，利用slam_gmapping或hector_slam的方法
4、配置Navigation包，进行导航
参考链接：https://www.cnblogs.com/flyinggod/p/9081046.html" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/8d13248dbf0b74b37ed2b84f7a520e9c/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2020-02-21T10:11:37+08:00" />
<meta property="article:modified_time" content="2020-02-21T10:11:37+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">ROS Navigation导航包介绍</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-light">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <h3><a id="Navigation_0"></a>Navigation功能包集概述</h3> 
<p>这是2D的导航功能包集，通过接收里程计数据、tf坐标变换树以及传感器数据，为移动机器人输出目标位置以及安全速度。概念层面上讲，导航功能包集是相当简单的。 它从里程计和传感器数据流获取信息，并将速度命令发送给移动基站（比如你的机器人）。但是，想要在任意机器人上使用导航功能包集可能有点复杂。使用导航功能包集的先决条件是，机器人必须运行ROS，有一个tf变换树，使用正确的ROS Message types发布传感器数据。而且，我们需要在高层为一个具有一定形状和动力学特点的机器人配置导航功能包集。</p> 
<p><strong>acml</strong>：是一个针对在二维移动的机器人的基于概率定位系统。它实现了自适应蒙特卡罗滤波的定位方法，并使用粒子滤波器去跟踪在已知地图中机器人的位置。</p> 
<p><strong>base_local_planner</strong>：这个包提供了Trajectory Rollout以及Dynamic Window两种在2D平面局部导航的方法。通过提供一个跟随的规划路径和一个代价地图，控制器生成速度指令并发送至机器人。它支持全向和非全向机器人，以及任何可以用多边形或圆描述的机器人轮廓，并且可以在launch文件中设置这些参数。这个包已经被封装好，可以通过nav_core包的BaseLocolPlanner接口来调用。</p> 
<p><strong>carrot_planner</strong>：这个规划器是一个简单的全局规划器，可以通过nav_core::BaseGlobalPlanner 来进行调用，并且被move_base节点用作一个全局规划的插件。这个规划器从用户处采集到一个目标点，之后检查用户指定的目标点是否是障碍物，如果是的话沿着robot与目标点构成的向量向后退，直到找到一点没有障碍物位置。之后它会将此目标点作为目标发送给局部规划器和控制器。这个规划器允许机器人尽可能到达离用户指定的目标点最近的位置。</p> 
<p><strong>clear_costmap_recovery</strong>：为导航包提供了一种自救行为，试图通过将代价地图还原成已知区域外的静态地图从而清除出空间。</p> 
<p><strong>costmap_2d</strong>：通过激光或点云的数据，投影到2D平面上，创建代价地图，并可以设置膨胀半径。</p> 
<p><strong>dwa_local_planner</strong>：局部规划器，提供动态窗口方法（ Dynamic Window Approach）在平面上局部导航。与base_local_planner类似。</p> 
<p><strong>fake_localization</strong>：提供了一个简单节点fake_localization node，可以代替一个定位系统，并提供了acml包的ROS API的子集。由于较低的计算量，这个节点非常频繁的用于在仿真环境中提供完美的定位。这个节点将里程计数据转换为位置、粒子云，并以acml发布的数据格式发布。</p> 
<p><strong>global_planner</strong>：全局路径规划节点。</p> 
<p><strong>map_server</strong>：将代价地图作为ROS Service发布，提供了map_saver节点，可以通过命令行存储地图。</p> 
<p><strong>move_base</strong>：提供了action动作的实现（actionlib包），即给定一个世界系下的目标位置，机器人会试图移动到该位置。另外，move_base节点中包含了两个代价地图（全局、局部），以及一个全局规划器和一个局部规划器，以便实现导航任务。</p> 
<p><strong>move_base_msgs</strong>： 通过MoveBase.action文件定义产生的消息文件，用于actionlib与move_base的通信。</p> 
<p><strong>move_slow_and_clear</strong>：为robot提供一种自救行为，即清除代价地图的信息并限制机器人速度，但这不绝对安全，robot可能会撞到某些障碍。但这是唯一一种可以与允许最大速度动态设置的局部规划器兼容的自救行为。</p> 
<p><strong>nav_core</strong>：为robot实现导航任务提供了通用的接口，包括BaseGlobalPlanner，BaseLocalPlanner,， RecoveryBehavior interfaces等，这有利于方便的更新规划器或者自救行为的版本。</p> 
<p><strong>navfn</strong>：全局规划器，提供了一个快速插值的函数，可以在起始点到目标点之间快速插值，并找到代价最小的一条路径。</p> 
<p><strong>robot_pose_ekf</strong>：这个包用于估计robot的三维位置，利用扩展卡尔曼滤波的方法，建立了一个六维模型，联合了轮子里程计、IMU、视觉里程计的数据。</p> 
<p><strong>rotate_recovery</strong>：提供了一种自救行为，通过旋转360度来清除空间。</p> 
<p><strong>voxel_grid</strong>：提供一个有效的三维体素网格的实现</p> 
<p><strong>导航框架</strong></p> 
<p><img src="https://images2.imgbox.com/47/7b/Q3RW6BLg_o.png" alt="在这里插入图片描述"><br> 这幅图描述了使用Navigation导航包的一个整体框架，其核心是move_base节点，包含了global_planner、local_planner、global_costmap、local_costmap、recovery_behaviors五个模块，move_base节点订阅tf（坐标系转换）、odom（里程计数据）、map（地图）、sensor datas（激光数据或点云）以及goal等话题，之后发布cmd_vel话题。</p> 
<pre><code class="prism language-c">tf：利用ROS的tf工具发布坐标系之间的转换关系，包括：<span class="token operator">/</span>map<span class="token operator">-&gt;</span><span class="token operator">/</span>odom，<span class="token operator">/</span>odom<span class="token operator">-&gt;</span><span class="token operator">/</span>base_link，<span class="token operator">/</span>base_link<span class="token operator">-&gt;</span><span class="token operator">/</span>sensor等
odom：导航包需要用到里程计的数据，故需将其用tf工具和nav_msgs<span class="token operator">/</span>Odometry消息发布出来
map：在导航前，最好可以提供一张全局的地图，因此需要我们提前创建（但这不是必须的）
sensor data：用于避障，建图等等，可以是激光雷达的平面数据或者是点云数据（sensor_msgs<span class="token operator">/</span>LaserScan or sensor_msgs<span class="token operator">/</span>PointCloud ）
goal：目标在全局地图中的坐标，用geometry_msgs<span class="token operator">/</span>PoseStamped消息格式发布
</code></pre> 
<p>此外，move_base节点还提供了action动作的接口（即SimpleActionServer的实现，详细可见actionlib包），包括订阅了move_base/goal (move_base_msgs/MoveBaseActionGoal)，move_base/cancel (actionlib_msgs/GoalID)两个话题，并发布了move_base/feedback (move_base_msgs/MoveBaseActionFeedback)、move_base/status (actionlib_msgs/GoalStatusArray)、move_base/result (move_base_msgs/MoveBaseActionResult)等三个话题。因此用户可以自己写一个利用actionlib库写一个发布目标位置的节点。</p> 
<p>在熟悉完整个导航框架后，我们就可以开始依次做好相应的准备工作了。需要的步骤如下：<br> 1、搭建一个移动平台，使其订阅/cmd_vel话题，并发布odom里程计数据以及/odom-&gt;/base_link的tf数据？？<br> 2、将传感器数据（激光数据或RGB-D点云数据）发布出来<br> 3、创建地图，利用slam_gmapping或hector_slam的方法<br> 4、配置Navigation包，进行导航</p> 
<p>参考链接：<a href="https://www.cnblogs.com/flyinggod/p/9081046.html" rel="nofollow">https://www.cnblogs.com/flyinggod/p/9081046.html</a></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/a54dc8f7b6b09fd38b1840d8d3d0d354/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">ORACLE_SID, SID, INSTANCE_NAME, SERVICE_NAME, SERVICES_NAMES, DB_NAME, GLOBAL_DBNAME, SID_NAME，以及网络服</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/cfdb3f542b44a5a30310f74e3b89450d/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">STM32——TIM1的TIM1_CH1N通道PWM初始化</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>