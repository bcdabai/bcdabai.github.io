<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>QT 自定义渲染与OBS中的实现 - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="QT 自定义渲染与OBS中的实现" />
<meta property="og:description" content="QPaintEngine *QWidget::paintEngine 的实现：
/*! \fn QPaintEngine *QWidget::paintEngine() const Returns the widget&#39;s paint engine. Note that this function should not be called explicitly by the user, since it&#39;s meant for reimplementation purposes only. The function is called by Qt internally, and the default implementation may not always return a valid pointer. */ QPaintEngine *QWidget::paintEngine() const { qWarning(&#34;QWidget::paintEngine: Should no longer be called&#34;); #ifdef Q_OS_WIN // We set this bit which is checked in setAttribute for // Qt::WA_PaintOnScreen." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/f0cf817b6f8f6ed1ce35fa22c427f3e5/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2024-01-18T09:52:13+08:00" />
<meta property="article:modified_time" content="2024-01-18T09:52:13+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">QT 自定义渲染与OBS中的实现</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p>QPaintEngine *QWidget::paintEngine 的实现：</p> 
<pre><code>/*!
    \fn QPaintEngine *QWidget::paintEngine() const

    Returns the widget's paint engine.

    Note that this function should not be called explicitly by the
    user, since it's meant for reimplementation purposes only. The
    function is called by Qt internally, and the default
    implementation may not always return a valid pointer.
*/
QPaintEngine *QWidget::paintEngine() const
{
    qWarning("QWidget::paintEngine: Should no longer be called");

#ifdef Q_OS_WIN
    // We set this bit which is checked in setAttribute for
    // Qt::WA_PaintOnScreen. We do this to allow these two scenarios:
    //
    // 1. Users accidentally set Qt::WA_PaintOnScreen on X and port to
    // Windows which would mean suddenly their widgets stop working.
    //
    // 2. Users set paint on screen and subclass paintEngine() to
    // return 0, in which case we have a "hole" in the backingstore
    // allowing use of GDI or DirectX directly.
    //
    // 1 is WRONG, but to minimize silent failures, we have set this
    // bit to ignore the setAttribute call. 2. needs to be
    // supported because its our only means of embedding native
    // graphics stuff.
    const_cast&lt;QWidgetPrivate *&gt;(d_func())-&gt;noPaintOnScreen = 1;
#endif

    return nullptr; //##### @@@
}</code></pre> 
<p>如果想不走qt 的渲染逻辑，那么需要做：</p> 
<pre><code>创建一个继承QWidget的类，重写paintEvent，resizeEvent
但是仅仅这样还不够，画面会一直闪烁，需要重写以下函数
virtual QPaintEngine paintEngine() const { return NULL; }*
并设置窗口属性
this-&gt;setAttribute(Qt::WA_PaintOnScreen, true);
this-&gt;setAttribute(Qt::WA_NativeWindow, true);
</code></pre> 
<p></p> 
<h2 id="articleContentId">关于QT nativeWindow</h2> 
<p><strong>1.系统级别 QApplication::setAttribute(Qt::AA_NativeWindows)</strong><br> (1)设置Qt::AA_NativeWindows<br> 所有控件均视为window，可通过QGuiApplication::allWindows()获取所有控件，然后获取窗口id和大小，并且，观察每个子widget大小(通过widget-&gt;geometry()获取)，可发现均集中在屏幕左上角，并且在显示上，屏幕左上角均是矩形空白，并且随着缩放，矩形空白也在变化，widget大小也在变化，即整个widget是多个子widget的合并，每个widget在底层均有一个窗口系统的句柄和内存空间，对刷新会有一定影响。<br> 对于依托父widget建立的widget，也有自己的窗口句柄，并且依然依附于父widget。<br> 对于没有依托父widget建立的widget，有自己的窗口句柄，并且作为独立窗口，默认显示在屏幕左上角。</p> 
<p>(2)不设置 Qt::AA_NativeWindows<br> 只有toplevelWidget有本地窗口系统句柄，屏幕没有矩形空白，按照QT文档所述，非native_window由QT自己绘制。<br> 对于依托父widget建立的widget，没有自己的窗口句柄，依附于父widget。<br> 对于没有依托父widget建立的widget，有自己的窗口句柄，并且作为独立窗口，默认显示在屏幕左上角。</p> 
<p><strong>2.widget级别 setAttribute(Qt::WA_NativeWindow)</strong><br> 这个widget以及其祖先都会设置成native_window,并且父widget的所有子widget也都会变(enforceNativeChildren()函数)，所以发现allWindows变多了,如果不需要所有祖先都变，需要加 setAttribute(<strong>Qt::WA_DontCreateNativeAncestors</strong>),如果不需要所有兄弟都变，需要加系统级参数QApplication::setAttribute(Qt::AA_DontCreateNativeWidgetSiblings);</p> 
<p>3.widget的winId()函数和setAttribute(Qt::WA_NativeWindow)类似，并且返回widget的句柄id<br>  </p> 
<p>如下面的qt-display中，设置了</p> 
<pre><code>	setAttribute(Qt::WA_DontCreateNativeAncestors);
	setAttribute(Qt::WA_NativeWindow);   
让自己的窗口成为native 同时禁止父窗口成为native窗口</code></pre> 
<p>同时设置了Qt::WA_PaintOnScreen属性：<a href="https://doc.qt.io/qt-6/qt.html#WidgetAttribute-enum" rel="nofollow" title="Qt Namespace | Qt Core 6.6.1">Qt Namespace | Qt Core 6.6.1</a></p> 
<pre><code>指示小部件想要直接绘制到屏幕上。具有此属性集的小部件不参与组合管理，
即它们不能是半透明的或通过半透明重叠小部件发光。注意：此标志仅在 X11
 上受支持，并且它禁用双缓冲。在 Qt for Embedded Linux 上，该标志
仅在顶级小部件上设置时才起作用，并且它依赖于活动屏幕驱动程序的支持。
该标志由小部件的作者设置或清除。要在 Qt 的绘画系统之外进行渲染，
例如，如果您需要本机绘画基元，则需要重新实现QWidget::paintEngine()
 返回 0 并设置此标志。</code></pre> 
<p>    setAttribute(Qt::WA_NoSystemBackground);<br>     setAttribute(Qt::WA_OpaquePaintEvent);</p> 
<p></p> 
<p><a href="https://github.com/alibaba/tblive/blob/master/obs/qt-display.cpp" title="https://github.com/alibaba/tblive/blob/master/obs/qt-display.cpp">https://github.com/alibaba/tblive/blob/master/obs/qt-display.cpp</a></p> 
<p></p> 
<pre><code>#pragma once

#include &lt;QWidget&gt;
#include &lt;obs.hpp&gt;

class OBSQTDisplay : public QWidget {
	Q_OBJECT

	OBSDisplay display;

	void CreateDisplay();

	void resizeEvent(QResizeEvent *event) override;
	void paintEvent(QPaintEvent *event) override;

signals:
	void DisplayCreated(OBSQTDisplay *window);
	void DisplayResized();

public:
	OBSQTDisplay(QWidget *parent = 0, Qt::WindowFlags flags = 0);

	virtual QPaintEngine *paintEngine() const override;

	inline obs_display_t *GetDisplay() const {return display;}
};</code></pre> 
<pre><code>#include "qt-display.hpp"
#include "qt-wrappers.hpp"
#include "display-helpers.hpp"
#include &lt;QWindow&gt;
#include &lt;QScreen&gt;
#include &lt;QResizeEvent&gt;
#include &lt;QShowEvent&gt;

OBSQTDisplay::OBSQTDisplay(QWidget *parent, Qt::WindowFlags flags)
	: QWidget(parent, flags)
{
	setAttribute(Qt::WA_PaintOnScreen);
	setAttribute(Qt::WA_StaticContents);
	setAttribute(Qt::WA_NoSystemBackground);
	setAttribute(Qt::WA_OpaquePaintEvent);
	setAttribute(Qt::WA_DontCreateNativeAncestors);
	setAttribute(Qt::WA_NativeWindow);

	auto windowVisible = [this] (bool visible)
	{
		if (!visible)
			return;

		if (!display) {
			CreateDisplay();
		} else {
			QSize size = GetPixelSize(this);
			obs_display_resize(display, size.width(), size.height());
		}
	};

	auto sizeChanged = [this] (QScreen*)
	{
		CreateDisplay();

		QSize size = GetPixelSize(this);
		obs_display_resize(display, size.width(), size.height());
	};

	connect(windowHandle(), &amp;QWindow::visibleChanged, windowVisible);
	connect(windowHandle(), &amp;QWindow::screenChanged, sizeChanged);
}

void OBSQTDisplay::CreateDisplay()
{
	if (display || !windowHandle()-&gt;isExposed())
		return;

	QSize size = GetPixelSize(this);

	gs_init_data info      = {};
	info.cx                = size.width();
	info.cy                = size.height();
	info.format            = GS_RGBA;
	info.zsformat          = GS_ZS_NONE;

    //将qt的创建句柄
	QTToGSWindow(winId(), info.window);

	display = obs_display_create(&amp;info);

	emit DisplayCreated(this);
}

void OBSQTDisplay::resizeEvent(QResizeEvent *event)
{
	QWidget::resizeEvent(event);

	CreateDisplay();

	if (isVisible() &amp;&amp; display) {
		QSize size = GetPixelSize(this);
		obs_display_resize(display, size.width(), size.height());
	}

	emit DisplayResized();
}

void OBSQTDisplay::paintEvent(QPaintEvent *event)
{
	CreateDisplay();

	QWidget::paintEvent(event);
}

QPaintEngine *OBSQTDisplay::paintEngine() const
{
	return nullptr;
}</code></pre> 
<p>如obs中使用opengl在qwidget上绘制如上,使用如下</p> 
<p><a href="https://blog.csdn.net/weixin_44838243/article/details/127692757" title="OBS源码使用学习（二）之预览框显示_obsqtdisplay-CSDN博客">OBS源码使用学习（二）之预览框显示_obsqtdisplay-CSDN博客</a></p> 
<p>OBS中的预览框：</p> 
<p><a href="https://codeleading.com/article/47146271547/" rel="nofollow" title="【obs-studio开源项目从入门到放弃】预览窗口中source的UI操作绘制处理 - 代码先锋网">【obs-studio开源项目从入门到放弃】预览窗口中source的UI操作绘制处理 - 代码先锋网</a></p> 
<p></p> 
<p></p> 
<p>其他：</p> 
<p><a href="https://blog.csdn.net/shujianlove0/article/details/84142396" title="从零开始开发3D游戏引擎 - 在QtWidget中进行Direct3D11渲染，并捕捉Windows消息_qt5窗口显示d3d11-CSDN博客">从零开始开发3D游戏引擎 - 在QtWidget中进行Direct3D11渲染，并捕捉Windows消息_qt5窗口显示d3d11-CSDN博客</a></p> 
<p><a href="https://blog.csdn.net/qq_16628589/article/details/88567997" title="QT调用GDI绘图-CSDN博客">QT调用GDI绘图-CSDN博客</a></p> 
<p></p> 
<p></p> 
<p>OBS:</p> 
<p> 主界面：OBSBasic::OBSBasic</p> 
<p>预览界面：OBSBasicPreview</p> 
<p></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/72f98909cdd23a543888c25af1064dd6/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">echarts X轴数据过多导致重叠展示不全问题（已解决）</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/ec550b15ba96aaac77586fce35908c37/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">数据结构之dict类</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>