<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>CommandLineRunner、ApplicationRunner、ApplicationListener、@PostConstruct对比 - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="CommandLineRunner、ApplicationRunner、ApplicationListener、@PostConstruct对比" />
<meta property="og:description" content="Springboot启动时执行：
CommandLineRunner、ApplicationRunner、ApplicationListener @PostConstruct 对比
使用场景:
我们在开发过程中会有这样的场景：需要在项目启动后执行一些操作，比如：读取配置文件信息，数据库连接，,删除临时文件，清除缓存信息，工厂类初始化，加载活动数据，或者缓存的同步等。我们会用多种实现方式，例如@PostConstruct、CommandLineRunner、ApplicationRunner、ApplicationListener都可以实现在springboot启动后执行我们特定的逻辑，接下来对比他们的区别
1、@PostConstruct 该注解被用来修饰一个非静态的void方法，被@PostConstruct修饰的方法会在服务器加载Servlet的时候运行，并且只会被服务区执行一次
触发时机：
SpringBoot会把标记了Bean相关的注解（例如@Component、@Service、@Repository等）的类或接口自动初始化全局的单一实例，如果标记了初始化顺序会按照用户标记的顺序，否则按照默认顺序初始化。在初始化的过程中，执行完一个Bean。
spring中bean的创建过程
配置Bean（@Component、@Service、@Controller等注解配置）--&gt;解析为Bean的元数据（Bean容器中的BeanDefinition对象）--&gt;根据Bean的元数据生成Bean（创建Bean） 创建Bean的时候执行顺序
Constructor（构造方法）–&gt;@Autowired（依赖注入）–&gt;@PostConstruct（注释的方法）
实例：
@PostConstruct public void dispatcher() throws Exception { // 逻辑代码 } 优点：
使用简单，在spring容器管理的类中添加此注解即可
缺点：
1.在spring创建Bean的时候触发，此时容器还未完全初始化完毕，如果逻辑中引用了还未完成初始化的bean会导致异常，所以需要考虑加载顺序。
2.如果@PostConstruct方法内的逻辑处理时间较长，就会增加SpringBoot应用初始化Bean的时间，进而增加应用启动的时间。因为只有在Bean初始化完成后，SpringBoot应用才会打开端口提供服务，所以在此之前，应用不可访问。
3.一句话，会影响你程序启动的时间。
2、CommandLineRunner、ApplicationRunner 使用起来很简单，只需要实现CommandLineRunner或者ApplicationRunner接口，重写run方法就行。
触发时机：
通过springboot启动源码：
启动后会执行callRunner方法：
public ConfigurableApplicationContext run(String... args) { StopWatch stopWatch = new StopWatch(); //设置线程启动计时器 stopWatch.start(); ConfigurableApplicationContext context = null; Collection&lt;SpringBootExceptionReporter&gt; exceptionReporters = new ArrayList&lt;&gt;(); //配置系统属性：默认缺失外部显示屏等允许启动 configureHeadlessProperty(); //获取并启动事件监听器，如果项目中没有其他监听器，则默认只有EventPublishingRunListener SpringApplicationRunListeners listeners = getRunListeners(args); //将事件广播给listeners listeners.starting(); try { //对于实现ApplicationRunner接口，用户设置ApplicationArguments参数进行封装 ApplicationArguments applicationArguments = new DefaultApplicationArguments( args); //配置运行环境：例如激活应用***." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/1cdf4741f8bde67153c0dc0dad84e56a/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-12-29T17:22:04+08:00" />
<meta property="article:modified_time" content="2023-12-29T17:22:04+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">CommandLineRunner、ApplicationRunner、ApplicationListener、@PostConstruct对比</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p><strong>Springboot启动时执行：</strong></p> 
<p><strong><a href="https://so.csdn.net/so/search?q=CommandLineRunner&amp;spm=1001.2101.3001.7020" title="CommandLineRunner">CommandLineRunner</a></strong><strong>、ApplicationRunner、ApplicationListener @PostConstruct 对比</strong></p> 
<p><strong>使用场景:</strong><br> 我们在开发过程中会有这样的场景：需要在项目启动后执行一些操作，比如：读取配置文件信息，数据库连接，,删除临时文件，清除缓存信息，工厂类初始化，加载活动数据，或者缓存的同步等。我们会用多种实现方式，例如@<a href="https://so.csdn.net/so/search?q=PostConstruct&amp;spm=1001.2101.3001.7020" title="PostConstruct">PostConstruct</a>、CommandLineRunner、ApplicationRunner、ApplicationListener都可以实现在springboot启动后执行我们特定的逻辑，接下来对比他们的区别</p> 
<h4><a name="t1"></a><a id="1PostConstruct_4"></a>1、@PostConstruct</h4> 
<p>该注解被用来修饰一个非静态的void方法，被@PostConstruct修饰的方法会在服务器加载Servlet的时候运行，并且只会被服务区执行一次<br><strong>触发时机：</strong><br> SpringBoot会把标记了Bean相关的注解（例如@Component、@Service、@Repository等）的类或接口自动初始化全局的单一实例，如果标记了初始化顺序会按照用户标记的顺序，否则按照默认顺序初始化。在初始化的过程中，执行完一个Bean。<br> spring中bean的创建过程</p> 
<pre><code>配置Bean（@Component、@Service、@Controller等注解配置）--&gt;解析为Bean的元数据（Bean容器中的BeanDefinition对象）--&gt;根据Bean的元数据生成Bean（创建Bean）
</code></pre> 
<p>创建Bean的时候执行顺序<br> Constructor（构造方法）–&gt;@Autowired（依赖注入）–&gt;@PostConstruct（注释的方法）<br><strong>实例：</strong></p> 
<pre><code>@PostConstruct
public void dispatcher() throws Exception {
    // 逻辑代码
}
</code></pre> 
<p><strong>优点：</strong><br> 使用简单，在spring容器管理的类中添加此注解即可</p> 
<p><strong>缺点：</strong><br> 1.在spring创建Bean的时候触发，此时容器还未完全初始化完毕，如果逻辑中引用了还未完成初始化的bean会导致异常，所以需要考虑加载顺序。<br> 2.如果@PostConstruct方法内的逻辑处理时间较长，就会增加SpringBoot应用初始化Bean的时间，进而增加应用启动的时间。因为只有在Bean初始化完成后，SpringBoot应用才会打开端口提供服务，所以在此之前，应用不可访问。<br> 3.一句话，<span style="color:#fe2c24;"><strong>会影响你程序启动的时间</strong></span>。</p> 
<h4><a name="t2"></a><a id="2CommandLineRunnerApplicationRunner_31"></a>2、CommandLineRunner、<a href="https://so.csdn.net/so/search?q=ApplicationRunner&amp;spm=1001.2101.3001.7020" title="ApplicationRunner">ApplicationRunner</a></h4> 
<p>使用起来很简单，只需要实现CommandLineRunner或者ApplicationRunner接口，重写run方法就行。<br><strong>触发时机：</strong><br> 通过springboot启动源码：<br> 启动后会执行callRunner方法：</p> 
<pre><code>public ConfigurableApplicationContext run(String... args) {
   StopWatch stopWatch = new StopWatch();
   //设置线程启动计时器
   stopWatch.start();
   ConfigurableApplicationContext context = null;
   Collection&lt;SpringBootExceptionReporter&gt; exceptionReporters = new ArrayList&lt;&gt;();
   //配置系统属性：默认缺失外部显示屏等允许启动
   configureHeadlessProperty();
   //获取并启动事件监听器，如果项目中没有其他监听器，则默认只有EventPublishingRunListener
   SpringApplicationRunListeners listeners = getRunListeners(args);
   //将事件广播给listeners
   listeners.starting();
   try {
       //对于实现ApplicationRunner接口，用户设置ApplicationArguments参数进行封装
      ApplicationArguments applicationArguments = new DefaultApplicationArguments(
            args);
      //配置运行环境：例如激活应用***.yml配置文件      
      ConfigurableEnvironment environment = prepareEnvironment(listeners,
            applicationArguments);
      configureIgnoreBeanInfo(environment);
      //加载配置的banner(gif,txt...)，即控制台图样
      Banner printedBanner = printBanner(environment);
      //创建上下文对象，并实例化
      context = createApplicationContext();
      exceptionReporters = getSpringFactoriesInstances(
            SpringBootExceptionReporter.class,
            new Class[] { ConfigurableApplicationContext.class }, context);
      //配置SPring容器      
      prepareContext(context, environment, listeners, applicationArguments,
            printedBanner);
      //刷新Spring上下文，创建bean过程中      
      refreshContext(context);
      //空方法，子类实现
      afterRefresh(context, applicationArguments);
      //停止计时器：计算线程启动共用时间
      stopWatch.stop();
      if (this.logStartupInfo) {
         new StartupInfoLogger(this.mainApplicationClass)
               .logStarted(getApplicationLog(), stopWatch);
      }
      //停止事件监听器
      listeners.started(context);
      //开始加载资源
      callRunners(context, applicationArguments);
   }
   catch (Throwable ex) {
      handleRunFailure(context, listeners, exceptionReporters, ex);
      throw new IllegalStateException(ex);
   }
   listeners.running(context);
   return context;
}

</code></pre> 
<p>callRunner方法：</p> 
<pre><code>private void callRunners(ApplicationContext context, ApplicationArguments args) {
    //将实现ApplicationRunner和CommandLineRunner接口的类，存储到集合中
   List&lt;Object&gt; runners = new ArrayList&lt;&gt;();
   runners.addAll(context.getBeansOfType(ApplicationRunner.class).values());
   runners.addAll(context.getBeansOfType(CommandLineRunner.class).values());
   //按照加载先后顺序排序
   AnnotationAwareOrderComparator.sort(runners);
   for (Object runner : new LinkedHashSet&lt;&gt;(runners)) {
      if (runner instanceof ApplicationRunner) {
         callRunner((ApplicationRunner) runner, args);
      }
      if (runner instanceof CommandLineRunner) {
         callRunner((CommandLineRunner) runner, args);
      }
   }
}

</code></pre> 
<p></p> 
<p>从上面源码可以看到，在springboot完全初始化完毕后，会执行CommandLineRunner和ApplicationRunner，两者唯一的区别是参数不同，但是不会影响，都可以获取到执行参数。<br><strong>示例</strong></p> 
<pre><code>/**
 * @author
 * @date 2021-08-23 16:19
 */
@Component
public class ServerDispatcher implements CommandLineRunner {
    @Override
    public void run(String... args){
        // 逻辑代码
    }
}

</code></pre> 
<pre><code>/**
 * @author
 * @date 2021-08-23 16:19
 */
@Component
public class ServerDispatcher2 implements ApplicationRunner {
    @Override
    public void run(ApplicationArguments args){
        // 逻辑代码
    }
}

</code></pre> 
<h4><a name="t3"></a><a id="3ApplicationListener_145"></a>3、ApplicationListener</h4> 
<p>通过事件监听我们也可以实现springboot启动执行方法，实现ApplicationListener，重写onApplicationEvent方法，便可在所有的bean加载完毕后执行。<br><strong>触发时机：</strong><br> 在IOC容器的启动过程，当所有的Bean都已经处理完成之后，springIOC容器会有一个发布ContextRefreshedEvent事件的动作。<br><strong>示例</strong></p> 
<pre><code>/**
 * @author
 * @date 2021-08-23 16:19
 */
@Component
public class ServerDispatcher3 implements ApplicationListener&lt;ContextRefreshedEvent&gt; {
    
    @Override
    public void onApplicationEvent(ContextRefreshedEvent contextRefreshedEvent) {
        // 逻辑代码
    }
}

</code></pre> 
<p><strong>注意：</strong><br> 系统会存在两个容器，一个是root application context，另一个就是我们自己的projectName-servlet context（作为root application context的子容器）<br> ApplicationContext<br> context.pushevent()<br> WebtapplicationContext<br> context.pushevent()<br> 这种情况下，就会造成onApplicationEvent方法被执行两次。为了避免上面提到的问题，我们可以只在root application context初始化完成后调用逻辑代码，其他的容器的初始化完成，则不做任务处理。</p> 
<pre><code>  //root application context 没有parent
 if (event.getApplicationContext().getParent() == null) { 
    //逻辑代码
  }

</code></pre> 
<h4><a name="t4"></a><a id="_181"></a>总结</h4> 
<p>1、一些比较独立，内容小巧的初始化逻辑，不影响springboot启动速度的使用@postConstruct注解<br> 2、若想通过ApplicationListener事件监听的方式，则需要处理好指定的容器、<br> 3、<strong>在数据初始化层面，不推荐@PostConstruct和ApplicationListener，原因是两者都会影响程序的启动，如果执行逻辑耗时很长，启动服务时间就很长。</strong><br> 4、建议使用CommandLintRunner、ApplicationRunner的方式，不会影响服务的启动速度，处理起来也比较简单。</p> 
<h4>区别：</h4> 
<p>1. 如果需要在容器启动后进行一些初始化操作，可以使用由SpringBoot提供的<a href="https://so.csdn.net/so/search?q=ApplicationRunner&amp;spm=1001.2101.3001.7020" title="ApplicationRunner">ApplicationRunner</a>/CommandLineRunner；<br> 2. 如果需要在一个类加载的时候进行一个初始化的操作，可以选择由JDK提供的@PostConstruct注解进行一个初始化的操作。另：@PostConstruct可以在容器没有完全启动的情况下能够进行初始化操作，而ApplicationRunner/CommandLineRunner的初始化一定是在容器完全启动之后执行的。@PostConstruct这个注解是针对BEAN的初始化完成之后再做一些事情，比如注册一些监听器、配置文件的初始化等等;<br> 3. 由Spring提供的InitializingBean用法与@PostConstruct基本一致，但是相应的BEAN需要实现afterPropertiesSet()方法;</p> 
<h5>定义来源</h5> 
<table align="center"><thead><tr><th>名称</th><th>来源</th></tr></thead><tbody><tr><td>ApplicationRunner</td><td>Spring Boot</td></tr><tr><td>CommandLineRunner</td><td>Spring Boot</td></tr><tr><td>InitializingBean</td><td>Spring</td></tr><tr><td>@PostConstruct</td><td>JDK</td></tr></tbody></table> 
<h4></h4> 
<h4></h4> 
<h4></h4> 
<h4>启动时执行顺序：</h4> 
<p><strong> @PostConstruct&gt;InitializingBean&gt;ApplicationRunner&gt;CommandLineRunner，当然如果涉及到类中的static代码块，则是：<br> static&gt;@PostConstruct&gt;InitializingBean&gt;ApplicationRunner&gt;CommandLineRunner</strong><br>  </p> 
<p><a href="https://blog.csdn.net/u014644574/article/details/128725876" title="@PostConstruct、InitializingBean、 ApplicationRunner 和 CommandLineRunner的执行顺序_commandlinerunner 顺序-CSDN博客">@PostConstruct、InitializingBean、 ApplicationRunner 和 CommandLineRunner的执行顺序_commandlinerunner 顺序-CSDN博客</a></p> 
<p><a href="https://blog.csdn.net/w3634839644/article/details/126035000" title="CommandLineRunner、ApplicationRunner、InitializingBean、@PostConstruct 执行顺序_commandlinerunner 启动顺序-CSDN博客">CommandLineRunner、ApplicationRunner、InitializingBean、@PostConstruct 执行顺序_commandlinerunner 启动顺序-CSDN博客</a></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/ae3842068babbaf94237b95133a219c2/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">三张表看懂POE POE&#43; POE&#43;&#43; 三个协议的相关参数</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/03af0b805488a54b8b93e6a8edff1b44/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">分享72个Python爬虫源码总有一个是你想要的</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>