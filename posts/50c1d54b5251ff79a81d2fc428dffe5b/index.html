<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>redis java 封装类_GitHub - wjy060708/RedisUtil: 最全的Java操作Redis的工具类，使用StringRedisTemplate实现，封装了对Redis五种基... - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="redis java 封装类_GitHub - wjy060708/RedisUtil: 最全的Java操作Redis的工具类，使用StringRedisTemplate实现，封装了对Redis五种基..." />
<meta property="og:description" content="RedisUtil
介绍
最全的Java操作Redis的工具类，封装了对Redis五种基本类型的各种操作，力求符合Redis的原生操作，使用StringRedisTemplate实现！
解惑
很多人提出疑问“为什么没有操作Object的方法？”，请看这里介绍redistemplate和stringredistemplate。
用法
一、keys相关命令
NO
方法
描述
1
void delete(String key)
key存在时删除key
2
void delete(Collection keys)
批量删除key
3
byte[] dump(String key)
序列化key，返回被序列化的值
4
Boolean hasKey(String key)
检查key是否存在
5
Boolean expire(String key, long timeout, TimeUnit unit)
设置过期时间
6
Boolean expireAt(String key, Date date)
设置过期时间
7
Set keys(String pattern)
查找所有符合给定模式(pattern)的key
8
Boolean move(String key, int dbIndex)
将当前数据库的key移动到给定的数据库db当中
9
Boolean persist(String key)
移除key的过期时间，key将持久保持
10
Long getExpire(String key, TimeUnit unit)" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/50c1d54b5251ff79a81d2fc428dffe5b/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2021-02-12T20:02:21+08:00" />
<meta property="article:modified_time" content="2021-02-12T20:02:21+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">redis java 封装类_GitHub - wjy060708/RedisUtil: 最全的Java操作Redis的工具类，使用StringRedisTemplate实现，封装了对Redis五种基...</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <div style="font-size:16px;"> 
 <p>RedisUtil</p> 
 <p>介绍</p> 
 <p>最全的Java操作Redis的工具类，封装了对Redis五种基本类型的各种操作，力求符合Redis的原生操作，使用StringRedisTemplate实现！</p> 
 <p>解惑</p> 
 <p>很多人提出疑问“为什么没有操作Object的方法？”，请看这里介绍redistemplate和stringredistemplate。</p> 
 <p>用法</p> 
 <p>一、keys相关命令</p> 
 <p>NO</p> 
 <p>方法</p> 
 <p>描述</p> 
 <p>1</p> 
 <p>void delete(String key)</p> 
 <p>key存在时删除key</p> 
 <p>2</p> 
 <p>void delete(Collection keys)</p> 
 <p>批量删除key</p> 
 <p>3</p> 
 <p>byte[] dump(String key)</p> 
 <p>序列化key，返回被序列化的值</p> 
 <p>4</p> 
 <p>Boolean hasKey(String key)</p> 
 <p>检查key是否存在</p> 
 <p>5</p> 
 <p>Boolean expire(String key, long timeout, TimeUnit unit)</p> 
 <p>设置过期时间</p> 
 <p>6</p> 
 <p>Boolean expireAt(String key, Date date)</p> 
 <p>设置过期时间</p> 
 <p>7</p> 
 <p>Set keys(String pattern)</p> 
 <p>查找所有符合给定模式(pattern)的key</p> 
 <p>8</p> 
 <p>Boolean move(String key, int dbIndex)</p> 
 <p>将当前数据库的key移动到给定的数据库db当中</p> 
 <p>9</p> 
 <p>Boolean persist(String key)</p> 
 <p>移除key的过期时间，key将持久保持</p> 
 <p>10</p> 
 <p>Long getExpire(String key, TimeUnit unit)</p> 
 <p>返回key的剩余的过期时间</p> 
 <p>11</p> 
 <p>Long getExpire(String key)</p> 
 <p>返回key的剩余的过期时间</p> 
 <p>12</p> 
 <p>String randomKey()</p> 
 <p>从当前数据库中随机返回一个key</p> 
 <p>13</p> 
 <p>void rename(String oldKey, String newKey)</p> 
 <p>修改key的名称</p> 
 <p>14</p> 
 <p>Boolean renameIfAbsent(String oldKey, String newKey)</p> 
 <p>仅当newkey不存在时，将oldKey改名为 newkey</p> 
 <p>15</p> 
 <p>DataType type(String key)</p> 
 <p>返回key所储存的值的类型</p> 
 <p>TimeUnit是时间单位，可选值有：</p> 
 <p>天:TimeUnit.DAYS、小时:TimeUnit.HOURS、分钟:TimeUnit.MINUTES、秒:TimeUnit.SECONDS、毫秒:TimeUnit.MILLISECONDS。</p> 
 <p>二、String数据类型操作</p> 
 <p>NO</p> 
 <p>方法</p> 
 <p>描述</p> 
 <p>1</p> 
 <p>String get(String key)</p> 
 <p>获取指定key的值</p> 
 <p>2</p> 
 <p>String getRange(String key, long start, long end)</p> 
 <p>返回key中字符串值的子字符</p> 
 <p>3</p> 
 <p>String getAndSet(String key, String value)</p> 
 <p>将key的值设为value，并返回key旧值</p> 
 <p>4</p> 
 <p>Boolean getBit(String key, long offset)</p> 
 <p>对key所储存的值，获取指定位置上的bit</p> 
 <p>5</p> 
 <p>List multiGet(Collection keys)</p> 
 <p>批量获取</p> 
 <p>添加相关</p> 
 <p>6</p> 
 <p>void set(String key, String value)</p> 
 <p>设置指定key的值</p> 
 <p>7</p> 
 <p>boolean setBit(String key, long offset, boolean value)</p> 
 <p>设置指定位置上的ASCII码</p> 
 <p>8</p> 
 <p>void setEx(String key,String value,long timeout,TimeUnit unit)</p> 
 <p>将值value关联到key，并设置key过期时间</p> 
 <p>9</p> 
 <p>boolean setIfAbsent(String key, String value)</p> 
 <p>只有在 key 不存在时设置 key 的值</p> 
 <p>10</p> 
 <p>void setRange(String key, String value, long offset)</p> 
 <p>用value覆写key的值，从偏移量offset开始</p> 
 <p>11</p> 
 <p>void multiSet(Map maps)</p> 
 <p>批量添加</p> 
 <p>12</p> 
 <p>boolean multiSetIfAbsent(Map maps)</p> 
 <p>批量添加，仅当所有key都不存在</p> 
 <p>其他方法</p> 
 <p>13</p> 
 <p>Integer append(String key, String value)</p> 
 <p>追加到末尾</p> 
 <p>14</p> 
 <p>Long incrBy(String key, long increment)</p> 
 <p>增加(自增长), 负数则为自减</p> 
 <p>15</p> 
 <p>Double incrByFloat(String key, double increment)</p> 
 <p>增加(自增长), 负数则为自减</p> 
 <p>16</p> 
 <p>Long size(String key)</p> 
 <p>获取字符串的长度</p> 
 <p>关于上面xxBit方法的使用：</p> 
 <p>例如字符'a'的ASCII码是97，转为二进制是'01100001'，setBit方法就是把第offset位置上变成0或者1，true是1，false是0。</p> 
 <p>三、Hash相关的操作</p> 
 <p>NO</p> 
 <p>方法</p> 
 <p>描述</p> 
 <p>1</p> 
 <p>Object hGet(String key, String field)</p> 
 <p>获取存储在哈希表中指定字段的值</p> 
 <p>2</p> 
 <p>Map hGetAll(String key)</p> 
 <p>获取所有给定字段的值</p> 
 <p>3</p> 
 <p>List hMultiGet(String key, Collection fields)</p> 
 <p>获取所有给定字段的值</p> 
 <p>添加相关</p> 
 <p>4</p> 
 <p>void hPut(String key, String hashKey, String value)</p> 
 <p>添加字段</p> 
 <p>5</p> 
 <p>void hPutAll(String key, Map maps)</p> 
 <p>添加多个字段</p> 
 <p>6</p> 
 <p>Boolean hPutIfAbsent(String key,String hashKey,String value)</p> 
 <p>仅当hashKey不存在时才设置</p> 
 <p>其他方法</p> 
 <p>7</p> 
 <p>Long hDelete(String key, Object... fields)</p> 
 <p>删除一个或多个哈希表字段</p> 
 <p>8</p> 
 <p>boolean hExists(String key, String field)</p> 
 <p>查看哈希表key中指定的字段是否存在</p> 
 <p>9</p> 
 <p>Long hIncrBy(String key, Object field, long increment)</p> 
 <p>为哈希表key中指定字段的值增加increment</p> 
 <p>10</p> 
 <p>Double hIncrByFloat(String key, Object field, double delta)</p> 
 <p>为哈希表key中指定字段的值增加increment</p> 
 <p>11</p> 
 <p>Set hKeys(String key)</p> 
 <p>获取所有哈希表中的字段</p> 
 <p>12</p> 
 <p>Long hSize(String key)</p> 
 <p>获取哈希表中字段的数量</p> 
 <p>13</p> 
 <p>List hValues(String key)</p> 
 <p>获取哈希表中所有值</p> 
 <p>14</p> 
 <p>Cursor hScan(String key, ScanOptions options)</p> 
 <p>迭代哈希表中的键值对</p> 
 <p>引入序列化依赖</p> 
 <p>com.dyuproject.protostuff protostuff-core 1.0.8 com.dyuproject.protostuff protostuff-runtime 1.0.8</p> 
 <p>15</p> 
 <p>getListCache(final String key, Class targetClass)</p> 
 <p>获取缓存中的List，targetClass是序列化的类</p> 
 <p>16</p> 
 <p>putListCacheWithExpireTime(String key, List objList, final long expireTime)</p> 
 <p>把List放到缓存，expireTime是过期策略</p> 
 <p>四、List相关的操作</p> 
 <p>NO</p> 
 <p>方法</p> 
 <p>描述</p> 
 <p>1</p> 
 <p>String lIndex(String key, long index)</p> 
 <p>通过索引获取列表中的元素</p> 
 <p>2</p> 
 <p>List lRange(String key, long start, long end)</p> 
 <p>获取列表指定范围内的元素</p> 
 <p>添加相关</p> 
 <p>3</p> 
 <p>Long lLeftPush(String key, String value)</p> 
 <p>存储在list头部</p> 
 <p>4</p> 
 <p>Long lLeftPushAll(String key, String... value)</p> 
 <p>存储在list头部</p> 
 <p>5</p> 
 <p>Long lLeftPushAll(String key, Collection value)</p> 
 <p>存储在list头部</p> 
 <p>6</p> 
 <p>Long lLeftPushIfPresent(String key, String value)</p> 
 <p>当list存在的时候才加入</p> 
 <p>7</p> 
 <p>lLeftPush(String key, String pivot, String value)</p> 
 <p>如果pivot存在,再pivot前面添加</p> 
 <p>8</p> 
 <p>Long lRightPush(String key, String value)</p> 
 <p>存储在list尾部</p> 
 <p>9</p> 
 <p>Long lRightPushAll(String key, String... value)</p> 
 <p>存储在list尾部</p> 
 <p>10</p> 
 <p>Long lRightPushAll(String key, Collection value)</p> 
 <p>存储在list尾部</p> 
 <p>11</p> 
 <p>Long lRightPushIfPresent(String key, String value)</p> 
 <p>当list存在的时候才加入</p> 
 <p>12</p> 
 <p>lRightPush(String key, String pivot, String value)</p> 
 <p>在pivot元素的右边添加值</p> 
 <p>13</p> 
 <p>void lSet(String key, long index, String value)</p> 
 <p>通过索引设置列表元素的值</p> 
 <p>删除相关</p> 
 <p>14</p> 
 <p>String lLeftPop(String key)</p> 
 <p>移出并获取列表的第一个元素</p> 
 <p>15</p> 
 <p>String lBLeftPop(String key,long timeout,TimeUnit unit)</p> 
 <p>移出并获取第一个元素,没有则阻塞直到超时或有为止</p> 
 <p>16</p> 
 <p>String lRightPop(String key)</p> 
 <p>移除并获取列表最后一个元素</p> 
 <p>17</p> 
 <p>String lBRightPop(String key,long timeout,TimeUnit unit)</p> 
 <p>移出并获取最后个元素,没有则阻塞直到超时或有为止</p> 
 <p>18</p> 
 <p>String lRightPopAndLeftPush(String sKey,String dKey)</p> 
 <p>移除最后一个元素并加到另一个列表并返回</p> 
 <p>19</p> 
 <p>String lBRightPopAndLeftPush(sKey,dKey,timeout,unit)</p> 
 <p>移除最后个元素并加到另个列表并返回,阻塞超时或有</p> 
 <p>20</p> 
 <p>Long lRemove(String key, long index, String value)</p> 
 <p>删除集合中值等于value得元素</p> 
 <p>21</p> 
 <p>void lTrim(String key, long start, long end)</p> 
 <p>裁剪list</p> 
 <p>其他方法</p> 
 <p>22</p> 
 <p>Long lLen(String key)</p> 
 <p>获取列表长度</p> 
 <p>五、Set相关的操作</p> 
 <p>NO</p> 
 <p>方法</p> 
 <p>描述</p> 
 <p>1</p> 
 <p>Set sMembers(String key)</p> 
 <p>获取集合所有元素</p> 
 <p>2</p> 
 <p>Long sSize(String key)</p> 
 <p>获取集合大小</p> 
 <p>3</p> 
 <p>Boolean sIsMember(String key, Object value)</p> 
 <p>判断集合是否包含value</p> 
 <p>4</p> 
 <p>String sRandomMember(String key)</p> 
 <p>随机获取集合中的一个元素</p> 
 <p>5</p> 
 <p>List sRandomMembers(String key, long count)</p> 
 <p>随机获取集合count个元素</p> 
 <p>6</p> 
 <p>Set sDistinctRandomMembers(String key, long count)</p> 
 <p>随机获取count个元素并去除重复的</p> 
 <p>7</p> 
 <p>Cursor sScan(String key, ScanOptions options)</p> 
 <p>使用迭代器获取元素</p> 
 <p>8</p> 
 <p>Set sIntersect(String key, String otherKey)</p> 
 <p>获取两个集合的交集</p> 
 <p>9</p> 
 <p>Set sIntersect(String key, Collection otherKeys)</p> 
 <p>获取key集合与多个集合的交集</p> 
 <p>10</p> 
 <p>Long sIntersectAndStore(String key, String oKey, String dKey)</p> 
 <p>key集合与oKey的交集存储到dKey中</p> 
 <p>11</p> 
 <p>Long sIntersectAndStore(String key,Collection oKeys,String dKey)</p> 
 <p>key与多个集合的交集存储到dKey中</p> 
 <p>12</p> 
 <p>Set sUnion(String key, String otherKeys)</p> 
 <p>获取两个集合的并集</p> 
 <p>13</p> 
 <p>Set sUnion(String key, Collection otherKeys)</p> 
 <p>获取key集合与多个集合的并集</p> 
 <p>14</p> 
 <p>Long sUnionAndStore(String key, String otherKey, String destKey)</p> 
 <p>key集合与oKey的并集存储到dKey中</p> 
 <p>15</p> 
 <p>Long sUnionAndStore(String key,Collection oKeys,String dKey)</p> 
 <p>key与多个集合的并集存储到dKey中</p> 
 <p>16</p> 
 <p>Set sDifference(String key, String otherKey)</p> 
 <p>获取两个集合的差集</p> 
 <p>17</p> 
 <p>Set sDifference(String key, Collection otherKeys)</p> 
 <p>获取key集合与多个集合的差集</p> 
 <p>18</p> 
 <p>Long sDifference(String key, String otherKey, String destKey)</p> 
 <p>key与oKey集合的差集存储到dKey中</p> 
 <p>19</p> 
 <p>Long sDifference(String key,Collection otherKeys,String dKey)</p> 
 <p>key与多个集合的差集存储到dKey中</p> 
 <p>添加相关</p> 
 <p>20</p> 
 <p>Long sAdd(String key, String... values)</p> 
 <p>添加</p> 
 <p>删除相关</p> 
 <p>21</p> 
 <p>Long sRemove(String key, Object... values)</p> 
 <p>移除</p> 
 <p>22</p> 
 <p>String sPop(String key)</p> 
 <p>随机移除一个元素</p> 
 <p>23</p> 
 <p>Boolean sMove(String key, String value, String destKey)</p> 
 <p>将key集合中value移到destKey中</p> 
 <p>六、zset数据类型操作</p> 
 <p>NO</p> 
 <p>方法</p> 
 <p>描述</p> 
 <p>1</p> 
 <p>Set zRange(String key, long start, long end)</p> 
 <p>获取元素,小到大排序,s开始e结束位置</p> 
 <p>2</p> 
 <p>Set zRangeWithScores(String key, long start, long end)</p> 
 <p>获取集合元素, 并且把score值也获取</p> 
 <p>3</p> 
 <p>Set zRangeByScore(String key, double min, double max)</p> 
 <p>根据score范围查询元素,从小到大排序</p> 
 <p>4</p> 
 <p>Set zRangeByScoreWithScores(key,double min,double max)</p> 
 <p>根据score范围查询元素,并返回score</p> 
 <p>5</p> 
 <p>Set zRangeByScoreWithScores(key,double min,max,long start,end)</p> 
 <p>根据score查询元素,s开始e结束位置</p> 
 <p>6</p> 
 <p>Set zReverseRange(String key, long start, long end)</p> 
 <p>获取集合元素, 从大到小排序</p> 
 <p>7</p> 
 <p>Set zReverseRangeWithScores(key, long start, long end)</p> 
 <p>获取元素,从大到小排序,并返回score</p> 
 <p>8</p> 
 <p>Set zReverseRangeByScore(String key, double min, double max)</p> 
 <p>根据score范围查询元素,从大到小排序</p> 
 <p>9</p> 
 <p>Set zReverseRangeByScoreWithScores(key,double min,double max)</p> 
 <p>根据score查询,大到小排序返回score</p> 
 <p>10</p> 
 <p>Set zReverseRangeByScore(key, double min, max, long start, end)</p> 
 <p>根据score查询,大到小,s开始e结束</p> 
 <p>11</p> 
 <p>Long zRank(String key, Object value)</p> 
 <p>返回元素在集合的排名,score由小到大</p> 
 <p>12</p> 
 <p>Long zReverseRank(String key, Object value)</p> 
 <p>返回元素在集合的排名,score由大到小</p> 
 <p>13</p> 
 <p>Long zCount(String key, double min, double max)</p> 
 <p>根据score值范围获取集合元素的数量</p> 
 <p>14</p> 
 <p>Long zSize(String key)</p> 
 <p>获取集合大小</p> 
 <p>15</p> 
 <p>Long zZCard(String key)</p> 
 <p>获取集合大小</p> 
 <p>16</p> 
 <p>Double zScore(String key, Object value)</p> 
 <p>获取集合中value元素的score值</p> 
 <p>17</p> 
 <p>Long zUnionAndStore(String key, String otherKey, String destKey)</p> 
 <p>获取key和oKey的并集并存储在dKey中</p> 
 <p>18</p> 
 <p>Long zUnionAndStore(String key,Collection otherKeys,String dKey)</p> 
 <p>获取key和多个集合并集并存在dKey中</p> 
 <p>19</p> 
 <p>Long zIntersectAndStore(String key, String otherKey, String destKey)</p> 
 <p>获取key和oKey交集并存在destKey中</p> 
 <p>20</p> 
 <p>Long zIntersectAndStore(String key,Collection oKeys,String dKey)</p> 
 <p>获取key和多个集合交集并存在dKey中</p> 
 <p>21</p> 
 <p>Cursor zScan(String key, ScanOptions options)</p> 
 <p>使用迭代器获取</p> 
 <p>添加相关</p> 
 <p>22</p> 
 <p>Boolean zAdd(String key, String value, double score)</p> 
 <p>添加元素,zSet按score由小到大排列</p> 
 <p>23</p> 
 <p>Long zAdd(String key, Set values)</p> 
 <p>批量添加,TypedTuple使用见下面介绍</p> 
 <p>删除相关</p> 
 <p>24</p> 
 <p>Long zRemove(String key, Object... values)</p> 
 <p>移除</p> 
 <p>25</p> 
 <p>Double zIncrementScore(String key, String value, double delta)</p> 
 <p>增加元素的score值,并返回增加后的值</p> 
 <p>26</p> 
 <p>Long zRemoveRange(String key, long start, long end)</p> 
 <p>移除指定索引位置的成员</p> 
 <p>27</p> 
 <p>Long zRemoveRangeByScore(String key, double min, double max)</p> 
 <p>根据指定的score值的范围来移除成员</p> 
 <p>批量添加时TypedTuple的使用：</p> 
 <p>TypedTuple typedTuple = new DefaultTypedTuple(value,score)</p> 
 <p>知识补充</p> 
 <p>一、Redis知识补充</p> 
 <p>Redis 可以存储键与5种不同数据结构类型之间的映射，这5种数据结构类型分别为：String(字符串)、List(列表)、Set(集合)、Hash(散列)和 zSet(有序集合)。</p> 
 <p>1.String(字符串)</p> 
 <p>结构存储的值：</p> 
 <p>可以是字符串、整数或者浮点数。</p> 
 <p>结构的读写能力：</p> 
 <p>对整个字符串或者字符串的其中一部分执行操作，对象和浮点数执行自增(increment)或者自减(decrement)。</p> 
 <p>2. List(列表)</p> 
 <p>结构存储的值：</p> 
 <p>一个链表，链表上的每个节点都包含了一个字符串。</p> 
 <p>结构的读写能力：</p> 
 <p>从链表的两端推入或者弹出元素，根据偏移量(offset)对链表进行修剪(trim)，读取单个或者多个元素，根据值来查找或者移除元素。</p> 
 <p>3. Set(集合)</p> 
 <p>结构存储的值：</p> 
 <p>包含字符串的无序收集器(unOrderedCollection)，并且被包含的每个字符串都是独一无二的、各不相同。</p> 
 <p>结构的读写能力：</p> 
 <p>添加、获取、移除单个元素，检查一个元素是否存在于某个集合中，计算交集、并集、差集，从集合里面随机获取元素。</p> 
 <p>4. Hash(散列)</p> 
 <p>结构存储的值：</p> 
 <p>包含键值对的无序散列表。</p> 
 <p>结构的读写能力：</p> 
 <p>添加、获取、移除单个键值对，获取所有键值对。</p> 
 <p>5. zSet(有序集合)</p> 
 <p>结构存储的值：</p> 
 <p>字符串成员(member)与浮点数分值(score)之间的有序映射，元素的排列顺序由分值(score)的大小决定。</p> 
 <p>结构的读写能力：</p> 
 <p>添加、获取、删除单个元素，根据分值(score)范围(range)或者成员来获取元素。</p> 
 <p>二、RedisTemplate和StringRedisTemplate</p> 
 <p>二者主要区别是他们使用的序列化类不一样，RedisTemplate使用的是JdkSerializationRedisSerializer，</p> 
 <p>StringRedisTemplate使用的是StringRedisSerializer，两者的数据是不共通的。</p> 
 <p>1. RedisTemplate：</p> 
 <p>RedisTemplate使用的是JDK的序列化策略，向Redis存入数据会将数据先序列化成字节数组然后在存入Redis数据库，</p> 
 <p>这个时候打开Redis查看的时候，你会看到你的数据不是以可读的形式展现的，而是以字节数组显示，类似下面：\xAC\xED\x00\x05t\x05sr\x00。</p> 
 <p>所以使用RedisTemplate可以把一个Java对象直接存储在Redis里面，但是存进去的数据是不易直观读的，不通用的，</p> 
 <p>建议不要直接存一个Object对象，可以变成Hash来存储，也可以转成json格式的数据来存储，在实际应用中也是很多都采用json格式来存储的。</p> 
 <p>2. StringRedisTemplate:</p> 
 <p>StringRedisTemplate默认采用的是String的序列化策略，保存的key和value都是采用此策略序列化保存的，</p> 
 <p>StringRedisTemplate是继承RedisTemplate的，这种对redis的操方式更优雅，任何Redis连接工具，都可以读出直观的数据，便于数据的维护。</p> 
 <p>三、Redis与Spring的集成</p> 
 <p>1.集成配置</p> 
 <p>2.使用RedisUtil工具类方法如下：</p> 
 <p>@Autowired</p> 
 <p>private RedisUtil redisUtil;</p> 
 <p>四、SpringBoot中如何使用</p> 
 <p>修改你的RedisUtil代码：</p> 
 <p>@Component</p> 
 <p>public class RedisUtil {<!-- --></p> 
 <p>@Autowired</p> 
 <p>private StringRedisTemplate redisTemplate;</p> 
 <p>......</p> 
 <p>}</p> 
 <p>使用@Autowired自动注入redisTemplate。</p> 
 <p>推荐</p> 
</div>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/bfa83980fb10790a99d0148616e36963/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">java 当月最后一天_java中取得当月最后一天的四种方法</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/ac52301ce16cbfd364567cd0e13b9c0a/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">Ubuntu 20.10安装完成后，启动后无法进入桌面，黑屏光标闪烁</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>