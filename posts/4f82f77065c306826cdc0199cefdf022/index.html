<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>C&#43;&#43;移位运算符 - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="C&#43;&#43;移位运算符" />
<meta property="og:description" content="关于逻辑移位、算术移位可参见迅雷深大笔试题部分。的一道题。
以前看到C&#43;&#43;标准上说，移位运算符（&lt;&lt;、&gt;&gt;）出界时的行为并不确定：
The behavior is undefined if the right operand is negative, orgreater than or equal to the length in bits of the promoted left operand.
我当时也没有深究过这个问题。前几天有个网友来信问起这件事，我才发现，这和IntelCPU的移位运算有关。下面是那位网友的来信以及我的回复：
您好！运算符&lt;&lt;作为位操作中的高效的操作，但我遇到一个问题：下面在VC环境下发现一个很不明白的地方，下面标注。
#include &lt;stdio.h&gt;
void main()
{
unsigned int i,j;
i=35;
//为什么下面两个左移操作结果不一样？
j=1&lt;&lt;i; // j为8
j=1&lt;&lt;35; // j为0
}
不知是哪里没有理解对。
原因是这样的：i=35;j=1&lt;&lt;i;这两句在VC没有做优化的情况下，将被编译成下面的机器指令：
mov dword ptr [i],23h
mov eax,1
mov ecx,dword ptr [i]
shl eax,cl
mov dword ptr [j],eax
在shl一句中，eax=1，cl=35。而IntelCPU执行shl指令时，会先将cl与31进行and操作，以限制左移的次数小于等于31。因为35 &amp; 31 =3，所以这样的指令相当于将1左移3位，结果是8。
而j=1&lt;&lt;35;一句是常数运算，VC即使不做优化，编译器也会直接计算1&lt;&lt;35的结果。VC编译器发现35大于31时，就会直接将结果设置为0。这行代码编译产生的机器指令是：
mov dword ptr [j],0" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/4f82f77065c306826cdc0199cefdf022/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2011-12-10T07:43:31+08:00" />
<meta property="article:modified_time" content="2011-12-10T07:43:31+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">C&#43;&#43;移位运算符</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p>关于逻辑移位、算术移位可参见迅雷深大笔试题部分。的一道题。</p> 
<p>以前看到C++标准上说，移位运算符（&lt;&lt;、&gt;&gt;）出界时的行为并不确定：</p> 
<p>The behavior is undefined if the right operand is negative, orgreater than or equal to the length in bits of the promoted left operand.</p> 
<p>我当时也没有深究过这个问题。前几天有个网友来信问起这件事，我才发现，这和IntelCPU的移位运算有关。下面是那位网友的来信以及我的回复：</p> 
<p> </p> 
<p>您好！运算符&lt;&lt;作为位操作中的高效的操作，但我遇到一个问题：下面在VC环境下发现一个很不明白的地方，下面标注。</p> 
<p>#include &lt;stdio.h&gt;</p> 
<p>void main()</p> 
<p>{<!-- --></p> 
<p>   unsigned int i,j;</p> 
<p>   i=35;</p> 
<p> </p> 
<p>   //为什么下面两个左移操作结果不一样？</p> 
<p>   j=1&lt;&lt;i;  // j为8</p> 
<p>   j=1&lt;&lt;35; // j为0</p> 
<p>}</p> 
<p>不知是哪里没有理解对。</p> 
<p> </p> 
<p>原因是这样的：i=35;j=1&lt;&lt;i;这两句在VC没有做优化的情况下，将被编译成下面的机器指令：</p> 
<p>mov dword ptr [i],23h</p> 
<p>mov eax,1</p> 
<p>mov ecx,dword ptr [i]</p> 
<p>shl eax,cl</p> 
<p>mov dword ptr [j],eax</p> 
<p>在shl一句中，eax=1，cl=35。而IntelCPU执行shl指令时，会先将cl与31进行and操作，以限制左移的次数小于等于31。因为35 &amp; 31 =3，所以这样的指令相当于将1左移3位，结果是8。</p> 
<p>而j=1&lt;&lt;35;一句是常数运算，VC即使不做优化，编译器也会直接计算1&lt;&lt;35的结果。VC编译器发现35大于31时，就会直接将结果设置为0。这行代码编译产生的机器指令是：</p> 
<p>mov dword ptr [j],0</p> 
<p>对上面这两种情况，如果把VC编译器的优化开关打开（比如编译成Release版本），编译器都会直接将结果设置为0。</p> 
<p>所以，在C/C++语言中，移位操作不要超过界限，否则，结果是不可预期的。</p> 
<p>下面是Intel文档中关于shl指令限制移位次数的说明：</p> 
<p>The destination operand can be a register or a memory location.The count operand can be an immediate value or register CL. The count is maskedto 5 bits, which limits the count range to 0 to 31. A special opcode encodingis provided for a count of 1.</p> 
<p><br> </p> 
<p></p> 
<p>1.掩码</p> 
<p>就是一串2进制 对目标字段进行位与运算，屏蔽当前的输入位。</p> 
<p>将源码与掩码经过逻辑运算得出新的操作数。其中要用到逻辑运算如OR运算。AND运算。用于如将ASCLL码中大写字母改作小写字母。 </p> 
<p>2.与 或 异或 转换成补码运算</p> 
<p>3.  用法：掩码 （&amp;）</p> 
<p>4. 用法：打开位 （|）</p> 
<p>5.用法：关闭位 （&amp;~）</p> 
<p>6. 用法：转置位 （^）</p> 
<p>7. 将Value的第bit_number位置1       Value |= 1 &lt;&lt; bit_number;</p> 
<p>8. 将Value的第bit_number位置0       Value &amp;= ~( 1 &lt;&lt; bit_number );</p> 
<p>9.value &amp; 1 &lt;&lt; bit_number 如果该位置已被置为1，则表达式的结果为非零值</p> 
<p> </p> 
<p>C/C ++提供位逻辑运算符和移位运算符。二者只能用于整形和字符型。位运算符是对每位进行操作而不影响左右两位，这有别于常规运算符（&amp;&amp;|| !）是将整个数进行操作的。</p> 
<p>一．    位逻辑运算符</p> 
<p>1．    ~ 按位取反</p> 
<p>将1变为0，将0变为1</p> 
<p>EG：</p> 
<p>~(10011010)</p> 
<p>(01100101)</p> 
<p>注：</p> 
<p>VC++编译器，计算～10，得出的结果是－11。为什么不是5呢</p> 
<p>10的二进制表示为1010，按位取反应该为0101，也就是十进制的5，为什么会得出－11？</p> 
<p>VC是32位编译器，所以</p> 
<p>10 = 00000000 00000000 00000000   00001010</p> 
<p>~10 = 11111111 11111111   11111111   11110101 =   -11</p> 
<p>可以通过掩码（位与） 与15位与</p> 
<p>   15 = 00000000 00000000 00000000   00001111</p> 
<p>~10 = 00000000 00000000 00000000   00000101   =   -11</p> 
<p>2．    &amp; 按位取与</p> 
<p>只有两个操作数都是1结果才是1，否则为0</p> 
<p>10 = 00000000 00000000 00000000   00001010</p> 
<p>12 = 00000000 00000000 00000000   00001100</p> 
<p>&amp;</p> 
<p>8 = 00000000 00000000 00000000   00001000</p> 
<p>3．    | 按位取或</p> 
<p>两个操作数任意一位为1结果就是1</p> 
<p>10 = 00000000 00000000 00000000   00001010</p> 
<p>12 = 00000000 00000000 00000000   00001100</p> 
<p>|</p> 
<p>14 = 00000000 00000000 00000000   00001110</p> 
<p>      </p> 
<p>4．    ^ 按位异或</p> 
<p>两个操作数不同为1，相同为0</p> 
<p>10 = 00000000 00000000 00000000   00001010</p> 
<p>12 = 00000000 00000000 00000000   00001100</p> 
<p>^</p> 
<p>14 = 00000000 00000000 00000000   00000110</p> 
<p>       </p> 
<p>5．    用法：掩码</p> 
<p>掩码是通过&amp;（位与）将某些位设置为开（1），将某些位设置为关（0）。将掩码0看做不透明，将1看着透明。</p> 
<p>EG：</p> 
<p>如只显示第二、三位</p> 
<p>107 = 0110 1011</p> 
<p>6            = 0000 0110</p> 
<p>&amp;</p> 
<p>2   = 0000 0010</p> 
<p>       </p> 
<p>6．    用法：打开位</p> 
<p>打开位是通过 |（位或）打开一个值的特定位，同时保持其他位的不变。这是因为和0位或都为0，和1位或都为1。</p> 
<p>EG：</p> 
<p>如只打开第二、三位</p> 
<p>107 = 0110 1011</p> 
<p>6   = 0000 0110</p> 
<p>|</p> 
<p>111 = 0110 1111</p> 
<p>7．    用法：关闭位</p> 
<p>关闭某些位</p> 
<p>EG：</p> 
<p>如关闭第二、三位</p> 
<p>107 = 0110 1011</p> 
<p>6    = 0000 0110</p> 
<p>&amp; ~</p> 
<p>105 = 0110 1001</p> 
<p>8．    用法：转置位</p> 
<p>如果一位为1则转置为0，如果一位为1则转置为0</p> 
<p>EG：</p> 
<p>如转置第二、三位</p> 
<p>107 = 0110 1011</p> 
<p>6    = 0000 0110</p> 
<p>^</p> 
<p>105 = 0110 1101</p> 
<p>       </p> 
<p>二．    移位运算符</p> 
<ol type="1"><li>&lt;&lt; 左移</li></ol> 
<p>左移运算符是把操作数的值的每一位向左移动，移动的位数有右边的操作数决定，右侧空出的位数用0填充</p> 
<p>EG：</p> 
<p>如转置第二、三位</p> 
<p>107 = 0110 1011 &lt;&lt;2</p> 
<p>&lt;&lt;</p> 
<p>172 = 1010 1100</p> 
<p>      </p> 
<p>       在计算机中由于是32位的</p> 
<p>107 = 0000 0000   0000 0000   0000 0000   0110 1011 &lt;&lt;2</p> 
<p>&lt;&lt;</p> 
<p>428 = 0000 0000   0000 0000   0000 0001   1010 1100</p> 
<ol type="1"><li>&gt;&gt; 右移</li></ol> 
<p>右移运算符是把操作数的值的每一位向右移动，移动的位数有右边的操作数决定，左边丢弃的位数用0填充</p> 
<p>EG：</p> 
<p>如转置第二、三位</p> 
<p>107 = 0110 1011 &gt;&gt;2</p> 
<p>&gt;&gt;</p> 
<p>26 = 0001 1010</p> 
<p> </p> 
<p> </p> 
<p> </p> 
<ul><li><p>一、传统的C方式位操作：</p> 
 <p>1.基本操作：</p> 
 <p>   使用一个unsigned int变量来作为位容器。</p> 
 <p>2.操作符：</p> 
 <p>|   按位或操作符：result=exp1|exp2;当exp1和exp2中对应位中至少有一个为1时，result中对应位为1，否则为0。</p> 
 <p>&amp;  按位与操作符：：result=exp1&amp;exp2;当exp1和exp2中对应位全为1时，result中对应位为1，否则为0。</p> 
 <p>^  按位异或或操作符：result=exp1^exp2;当exp1和exp2中对应位不相同时，result中对应位为1，否则为0。</p> 
 <p>~  反转操作符：将位容器中的所有位都反转，1变为0，0变为1。</p> 
 <p>&lt;&lt; 按位左移操作符：exp&lt;&lt;n，将容器中所有的位向左移n位，空出的位用0填充。</p> 
 <p>&gt;&gt; 按位右移操作符：exp&gt;&gt;n，将容器中所有的位向右移n位，空出的位用0填充。</p> 
 <p>|=,&amp;=,^= 分别对应|&amp;^三种操作符的复合操作符。</p> 
 <p>3.常用操作</p> 
 <p>   这里我们假设有一个result的unsigned int变量用来储存32个学生的成绩（通过和不通过分别用0和1），这样result就有33位（result从右至左，从0开始计算位数，在这个例子中0位被浪费）。</p> 
 <p>(a) 将第27位设置为及格（设作1）其他位不变：</p> 
 <p>   result|＝(1&lt;&lt;27) //任意的位值与1作按位或操作其值为1，而与0作按位与操作其值不变</p> 
 <p>(b) 将第27位设置成不及格（设为0）。</p> 
 <p>   result&amp;=~(1&lt;&lt;27) //任意的位值与0作按位与操作其值为0，而与1作按位与操作其值不变</p> 
 <p>(c) 反转第27位的值。</p> 
 <p>   result^=(1&lt;&lt;27) //任意的位值与1作按位异或操作其值为1，而与0作按位异与操作其值不变</p> 
 <p> </p> 
 <p>二、C++中的bitset容器</p> 
 <p>1.头文件：</p> 
 <p>  #include &lt;bitset&gt;</p> 
 <p>2.声明一个容器：</p> 
 <p> (a)声明一个指定位数的空容器（所有位设为0）: bitset&lt;int&gt; bits;</p> 
 <p> (b)声明一个指定位数并将指定的几个位初始化为相应值的容器： bitset&lt;n&gt; bits(int);</p> 
 <p>     bitdet&lt;int&gt; bits(string&amp;)</p> 
 <p>总结：bitset模板类中类型参数传递容器的位数，而构造函数参数通过一个int或一个string&amp;值来从右至左初始化容器中的相应值。</p> 
 <p>3.bitset的基本用法：</p> 
 <div> 
  <table border="1" cellpadding="0" cellspacing="0"><tbody><tr><td> <p>操作</p> </td><td> <p>功能</p> </td><td> <p>用法</p> </td></tr><tr><td> <p>test(pos)</p> </td><td> <p>pos位是否为1?</p> </td><td> <p>a.test(4)</p> </td></tr><tr><td> <p>any()</p> </td><td> <p>任意位是否为1?</p> </td><td> <p>a.any()</p> </td></tr><tr><td> <p>none()</p> </td><td> <p>是否没有位为1?</p> </td><td> <p>a.none()</p> </td></tr><tr><td> <p>count()</p> </td><td> <p>值是1的位的小数</p> </td><td> <p>count()</p> </td></tr><tr><td> <p>size()</p> </td><td> <p>位元素的个数</p> </td><td> <p>size()</p> </td></tr><tr><td> <p>[pos]</p> </td><td> <p>访问pos位</p> </td><td> <p>a[4]</p> </td></tr><tr><td> <p>flip()</p> </td><td> <p>翻转所有位</p> </td><td> <p>a.flip()</p> </td></tr><tr><td> <p>flip(pos)</p> </td><td> <p>翻转pos位</p> </td><td> <p>a.flip(4)</p> </td></tr><tr><td> <p>set()</p> </td><td> <p>将所有位置1</p> </td><td> <p>a.set()</p> </td></tr><tr><td> <p>set(pos)</p> </td><td> <p>将pos位置1</p> </td><td> <p>a.set(4)</p> </td></tr><tr><td> <p>reset()</p> </td><td> <p>将所有位置0</p> </td><td> <p>a.reset()</p> </td></tr><tr><td> <p>reset(pos)</p> </td><td> <p>将pos位置0</p> </td><td> <p>a.reset(4)</p> </td></tr></tbody></table> 
 </div> 
 <p>4.bitset与传统C位操作及字符串的转换</p> 
 <p>   可以通过to_string()成员将容器转输出为一个string字符串，另外还可以用to_long()成员将容器输出到传统的用于C风格的位容器中。如：</p> 
 <p>  unsigned long bits = bits.to_long();</p> 
 <p>  sting str(bits.to_string());</p> 
</li></ul> 
<br> 
<p><br> </p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/a649861c6000d3e333747535419accc3/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">C&#43;&#43; rand,srand用法</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/2097b10e6c4d52d1b77370fc2b931c16/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">错误：没有注册类别 (异常来自 HRESULT:0x80040154 (REGDB_E_CLASSNOTREG))</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>