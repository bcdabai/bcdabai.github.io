<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Android 经典蓝牙用法 - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Android 经典蓝牙用法" />
<meta property="og:description" content="概述: Android平台包括了对蓝牙网络协议栈的支持, 它让设备可以跟其它蓝牙设备实现无线数据交换. 应用框架通过Android Bluetooth API提供了访问蓝牙的功能. 这些API可以让APP无线连接到其它的蓝牙设备, 可以使用点对点和多点无线功能. 通过使用蓝牙API, 一个Android APP可以实现这些功能:
l 扫描其它的蓝牙设备
l 为配对的蓝牙设备查询本地蓝牙适配器
l 建立RFCOMM通道
l 通过”服务发现”连接到其它设备
l 与其它设备交换数据
l 管理多连接
本文描述了如何使用经典蓝牙. 经典蓝牙是电池密集型操作的正确选择, 比如流和Android设备之间通信. 为了实现蓝牙设备低耗电的需求, Android4.3引入了支持Bluetooth Low Energy的API. 该功能可以参考这里. 将在下一篇blog中介绍. 基础: 该文档描述了如何使用Android Bluetooth API来完成四种使用蓝牙通信的主要任务: 设置蓝牙, 在本地区域搜索配对或者可用的设备, 连接设备, 和设备间交换数据. 所有Bluetooth API都在android.bluetooth包中. 这里列举了包中我们需要用到的类和接口的总览:
1. BluetoothAdapter: 代表本地蓝牙适配器(蓝牙无线电(radio)).BluetoothAdapter是蓝牙交互的入口. 通过它我们可以发现其它的蓝牙设备, 查询配对设备的列表, 使用一个已知的MAC地址实例化一个BluetoothDevice, 还可以创建一个BluetoothServerSocket来监听其它设备发来的通信.
2. BluetoothDevice: 表示一个远程的蓝牙设备. 使用它可以请求一个与远程设备通过BluetoothSocket建立的链接, 或者用来查询设备的相关信息, 比如名字, 地址, 类, 和配对状态.
3. BluetoothSocket: 表示为蓝牙socket的接口(类似于TCPSocket). 它是一个连接点, 允许一个APP跟其它的蓝牙设备通过InputStream和OutputStream来交换数据.
4. BluetoothServerSocket: 代表一个开放的服务器socket,它持续的监听连接进来的需求(类似于一个TCP ServerSocket). 为了连接两个Android设备, 一个设备必须用该类开启一个服务器socket." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/d7b90b2e51c09de58910a612bfa4149e/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2016-01-08T14:58:44+08:00" />
<meta property="article:modified_time" content="2016-01-08T14:58:44+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Android 经典蓝牙用法</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <h2><strong><span style="font-size:18px">概述:</span></strong></h2> 
<p><span style="font-size:18px">Android平台包括了对蓝牙网络协议栈的支持, 它让设备可以跟其它蓝牙设备实现无线数据交换. 应用框架通过Android Bluetooth API提供了访问蓝牙的功能. 这些API可以让APP无线连接到其它的蓝牙设备, 可以使用点对点和多点无线功能. 通过使用蓝牙API, 一个Android APP可以实现这些功能:</span></p> 
<p><span style="font-size:18px">l  扫描其它的蓝牙设备</span></p> 
<p><span style="font-size:18px">l  为配对的蓝牙设备查询本地蓝牙适配器</span></p> 
<p><span style="font-size:18px">l  建立RFCOMM通道</span></p> 
<p><span style="font-size:18px">l  通过”服务发现”连接到其它设备</span></p> 
<p><span style="font-size:18px">l  与其它设备交换数据</span></p> 
<p><span style="font-size:18px">l  管理多连接</span></p> 
<p><span style="font-size:18px">本文描述了如何使用经典蓝牙. 经典蓝牙是电池密集型操作的正确选择, 比如流和Android设备之间通信. 为了实现蓝牙设备低耗电的需求, Android4.3引入了支持Bluetooth Low Energy的API. 该功能可以参考<a target="_blank" href="https://developer.android.com/guide/topics/connectivity/bluetooth-le.html" rel="nofollow noopener noreferrer">这里</a>. 将在下一篇blog中介绍. </span></p> 
<h2><strong><span style="font-size:18px">基础:</span></strong></h2> 
<p><span style="font-size:18px">该文档描述了如何使用Android Bluetooth API来完成四种使用蓝牙通信的主要任务: 设置蓝牙, 在本地区域搜索配对或者可用的设备, 连接设备, 和设备间交换数据. 所有Bluetooth API都在android.bluetooth包中. 这里列举了包中我们需要用到的类和接口的总览:</span></p> 
<p><span style="font-size:18px">1.      BluetoothAdapter: 代表本地蓝牙适配器(蓝牙无线电(radio)).BluetoothAdapter是蓝牙交互的入口. 通过它我们可以发现其它的蓝牙设备, 查询配对设备的列表, 使用一个已知的MAC地址实例化一个BluetoothDevice, 还可以创建一个BluetoothServerSocket来监听其它设备发来的通信.</span></p> 
<p><span style="font-size:18px">2.      BluetoothDevice: 表示一个远程的蓝牙设备. 使用它可以请求一个与远程设备通过BluetoothSocket建立的链接, 或者用来查询设备的相关信息, 比如名字, 地址, 类, 和配对状态.</span></p> 
<p><span style="font-size:18px">3.      BluetoothSocket: 表示为蓝牙socket的接口(类似于TCPSocket). 它是一个连接点, 允许一个APP跟其它的蓝牙设备通过InputStream和OutputStream来交换数据.</span></p> 
<p><span style="font-size:18px">4.      BluetoothServerSocket: 代表一个开放的服务器socket,它持续的监听连接进来的需求(类似于一个TCP ServerSocket). 为了连接两个Android设备, 一个设备必须用该类开启一个服务器socket. 当一个远程蓝牙设备请求连接该设备的时候, BluetoothServerSocket将会在连接建立后返回一个连接了的BluetoothSocket.</span></p> 
<p><span style="font-size:18px">5.      BluetoothClass: 描述蓝牙设备的一般特征和能力. 这是一组只读的属性, 定义了设备的主要和次要设备类和它的服务. 然而它对所有蓝牙配置文件和服务的描述并不是很牢靠, 但作为设备类型的参考还是有用的.</span></p> 
<p><span style="font-size:18px">6.      BluetoothProfile: 一个代表蓝牙配置文件(Bluetoothprofile)的接口. 蓝牙配置文件是一个设备间基于蓝牙通信的无线接口规范. 有一个栗子是Hands-Free(免提)配置文件. 更多信息可以参考”通过配置文件工作”小节.</span></p> 
<p><span style="font-size:18px">7.      BluetoothHeadset: 为移动电话的耳机提供支持.包括蓝牙耳机和Hands-Free(v1.5)配置文件.</span></p> 
<p><span style="font-size:18px">8.      BluetoothA2dp: 定义高质量音频如何从一个设备流传输到另一个设备. “A2DP”代表Advanced Audio Distribution Profile.</span></p> 
<p><span style="font-size:18px">9.      BluetoothHealth: 代表一个控制蓝牙服务的健康设备配置文件代理. </span> </p> 
<p><span style="font-size:18px">10.  BluetoothHealthCallback: 一个抽象类, 我们可以用它来实现BluetoothHealth的回调. 要使用它则必须要继承该类并实现回调方法来接收关于APP注册状态和蓝牙通道状态的更新.</span></p> 
<p><span style="font-size:18px">11.  BluetoothHealthAppConfiguration:代表一个蓝牙健康第三方应用注册到了一个远程蓝牙健康设备的应用配置.</span></p> 
<p><span style="font-size:18px">12.  BluetoothProfile.ServiceListener:一个接口, 用于BluetoothProfile IPC客户端与服务连接或者断开连接的时候发出提醒.</span></p> 
<h2><strong><span style="font-size:18px">蓝牙权限:</span></strong></h2> 
<p><span style="font-size:18px">为了在APP中使用蓝牙功能, 我们必须声明蓝牙权限:BLUETOOTH. 执行任何的蓝牙通信, 比如请求连接, 接收连接, 数据交换, 都需要该权限. 如果想要我们的APP要启动设备发现或者操作蓝牙设置, 就必须声明BLUETOOTH_ADMIN权限. 大多数APP需要这个权限仅仅是为了发现本地蓝牙设备. 其它被该权限授权的能力不该被使用, 除非APP是”电源管理器”类的, 会根据用户的需求修改蓝牙设置. 注意: 如果使用了BLUETOOTH_ADMIN权限, 那么比需也声明BLUETOOTH权限. 栗子:</span></p> 
<div style="background:#F7F7F7"> 
 <p align="left"><span style="font-size:18px"><span style="color:#000088">&lt;manifest</span> ...<span style="color:#000088">&gt;</span><br>   <span style="color:#000088">&lt;uses-permission</span> <span style="color:#882288"> android:name</span><span style="color:#666600">=</span><span style="color:#880000">"android.permission.BLUETOOTH"</span><span style="color:#000088">/&gt;</span><br>   ...<br> <span style="color:#000088">&lt;/manifest&gt;</span></span></p> 
</div> 
<h2><strong><span style="font-size:18px">设置蓝牙:</span></strong></h2> 
<p><span style="font-size:18px">在使用蓝牙连接和通信之前, 我们必须确认设备可以支持蓝牙, 如果支持的话, 还要确认是否目前是启用的. 如果不支持蓝牙, 那么应该合理的关闭任何蓝牙相关的功能. 如果支持蓝牙, 但是目前蓝牙处于关闭状态, 那么我么你可以在不离开APP的情况下请求用户启动蓝牙. 这个操作需要个步骤, 并且使用BluetoothAdapter类:</span></p> 
<p><span style="font-size:18px">1.      得到BluetoothAdapter: 所有的蓝牙activity都需要BluetoothAdapter. 想要得到它需要调用getDefaultAdapter()方法. 该方法返回一个BluetoothAdapter, 代表设备本身的蓝牙适配器(蓝牙无线电). 整个系统有一个蓝牙适配器, 并且APP可以使用该对象跟它通信. 如果getDefaultAdapter()方法返回了null, 那么代表设备不支持蓝牙, 接下来也就没啥事可做了. 栗子:</span></p> 
<div style="background:#F7F7F7"> 
 <pre style="background:#F7F7F7"><span style="font-size:18px"><span style="color:#660066">BluetoothAdapter</span> mBluetoothAdapter <span style="color:#666600">=</span> <span style="color:#660066">BluetoothAdapter</span><span style="color:#666600">.</span>getDefaultAdapter<span style="color:#666600">();</span>
<span style="color:#000088">if</span> <span style="color:#666600">(</span>mBluetoothAdapter <span style="color:#666600">==</span> <span style="color:#000088">null</span><span style="color:#666600">)</span> <span style="color:#666600">{<!-- --></span>
    <span style="color:#006600">// Device does not support Bluetooth</span>
<span style="color:#666600">}</span></span></pre> 
</div> 
<p><span style="font-size:18px">2.      启动蓝牙: 下一步我们就该启动蓝牙了. 调用isEnabled()方法来查看蓝牙当前是否在启动着. 如果返回false, 那么表示蓝牙关闭. 这时候如果想要启动蓝牙, 调用startActivityForResult()方法, 并传给它ACTION_REQUEST_ENABLEaction intent. 这将会通过系统设置发出一个请求启动蓝牙的操作. 栗子:</span></p> 
<div style="background:#F7F7F7"> 
 <pre style="background:#F7F7F7"><span style="font-size:18px"><span style="color:#000088">if</span> <span style="color:#666600">(!</span>mBluetoothAdapter<span style="color:#666600">.</span>isEnabled<span style="color:#666600">())</span> <span style="color:#666600">{<!-- --></span>
    <span style="color:#660066">Intent</span> enableBtIntent <span style="color:#666600">=</span> <span style="color:#000088">new</span> <span style="color:#660066">Intent</span><span style="color:#666600">(</span><span style="color:#660066">BluetoothAdapter</span><span style="color:#666600">.</span>ACTION_REQUEST_ENABLE<span style="color:#666600">);</span>
    startActivityForResult<span style="color:#666600">(</span>enableBtIntent<span style="color:#666600">,</span> REQUEST_ENABLE_BT<span style="color:#666600">);</span>
<span style="color:#666600">}</span></span></pre> 
</div> 
<p><span style="font-size:18px">这时候将会弹出一个对话框让用户选择是否启动蓝牙. 如果用户选择了”是”, 系统将会开启蓝牙, 成功(或者失败)后会将焦点返回给APP. 栗子中的REQUEST_ENABLE_BT常量是一个大于0的数字, 它将在onActivityResult()中作为requestCode返回给我们作为参数. 如果成功启动了蓝牙, activity将会在onActivityResult()中收到一个RESULT_OK的结果. 如果失败了, 将会收到RESULT_CANCELED.</span></p> 
<p><span style="font-size:18px">还有一个可选项我们可以做的, APP可以监听ACTION_STATE_CHANGED广播intent, 当蓝牙状态改变的时候, 系统将会广播它. 该广播包含额外的域EXTRA_STATE和EXTRA_PREVIOUS_STATE, 分别包含新老蓝牙状态. 这些额外的域可能包含以下值: STATE_TURNING_ON, STATE_ON, STATE_TURNING_OFF, 和STATE_OFF. 如果关注蓝牙状态的话, 监听该广播会很有用.</span></p> 
<p><span style="font-size:18px">启动”可以被发现”功能会自动开启蓝牙. 如果我们打算在执行蓝牙activity前持续的启动设备发现功能, 可以跳过上面的两步. 后文详述.</span></p> 
<p><strong><span style="font-size:18px">查找设备: </span></strong></p> 
<p><span style="font-size:18px">通过BluetoothAdapter, 我们可以通过设备发现和查询配对列表找到远程蓝牙设备. </span> </p> 
<p><span style="font-size:18px">设备发现是一个扫描程序, 可以搜索附近区域启动了蓝牙的设备并获取各个设备的信息. 但是只有当该远程设备启动了”被发现”功能的时候才有可能被发现. 如果一个设备是可发现的, 那么它将会通过共享信息来回应发现需求, 比如设备的名字, 类, 和MAC地址. 使用这些信息, 就可以选择启动与该设备的连接了.</span></p> 
<p><span style="font-size:18px">一旦首次建立了跟远程设备的连接, 一个配对需求会自动展现给用户. 当设备配对了之后, 关于该基础信息就会被保存并可以使用蓝牙API读取到. 使用其中的MAC地址就可以启动一个与它的连接而不用再次处理发现了(假如设备是在范围内的).</span></p> 
<p><span style="font-size:18px">配对和连接之间有一个不同. 配对意味着两个设备都知道对方的存在, 有一个共享的link-key在认证的时候可以用, 并可以建立彼此的加密连接. 而”连接上”则意味着设备当前共享一个RFCOMM通道并可以交换数据. 当前Android Bluetooth API要求设备进行RFCOMM连接建立之前需要先进行配对(当通过Bluetooth API启用一个加密连接的时候, 配对将会被自动执行).</span></p> 
<p><span style="font-size:18px">下面的小节将会介绍如何找到已经配对的设备以及如何用设备发现功能发现新的设备. </span></p> 
<p><span style="font-size:18px">注意: Android设备默认情况下是不可发现的. 用户可以通过系统设置让设备可以被发现一段时间, 或者APP可以请求用户开启发现功能.</span></p> 
<h3><strong><span style="font-size:18px">查询配对设备:</span></strong></h3> 
<p><span style="font-size:18px">在执行设备发现之前, 查询一下要连接的设备是否在已经配对的设备列表中是有必要的. 想要实现这个操作, 调用getBonderDevices()方法. 该方法会返回一组BluetoothDevice来描述配对设备. 栗如, 我们可以查询所有的配对设备, 然后用一个列表展示给用户, 用一个ArrayAdapter:</span></p> 
<div style="background:#F7F7F7"> 
 <pre style="background:#F7F7F7"><span style="font-size:18px"><span style="color:#660066">Set</span><span style="color:#666600">&lt;</span><span style="color:#660066">BluetoothDevice</span><span style="color:#666600">&gt;</span> pairedDevices <span style="color:#666600">=</span> mBluetoothAdapter<span style="color:#666600">.</span>getBondedDevices<span style="color:#666600">();</span>
<span style="color:#006600">// If there are paired devices</span>
<span style="color:#000088">if</span> <span style="color:#666600">(</span>pairedDevices<span style="color:#666600">.</span>size<span style="color:#666600">()</span> <span style="color:#666600">&gt;</span> <span style="color:#006666">0</span><span style="color:#666600">)</span> <span style="color:#666600">{<!-- --></span>
    <span style="color:#006600">// Loop through paired devices</span>
    <span style="color:#000088">for</span> <span style="color:#666600">(</span><span style="color:#660066">BluetoothDevice</span> device <span style="color:#666600">:</span> pairedDevices<span style="color:#666600">)</span> <span style="color:#666600">{<!-- --></span>
        <span style="color:#006600">// Add the name and address to an array adapter to show in a ListView</span>
        mArrayAdapter<span style="color:#666600">.</span>add<span style="color:#666600">(</span>device<span style="color:#666600">.</span>getName<span style="color:#666600">()</span> <span style="color:#666600">+</span> <span style="color:#880000">"\n"</span> <span style="color:#666600">+</span> device<span style="color:#666600">.</span>getAddress<span style="color:#666600">());</span>
    <span style="color:#666600">}</span>
<span style="color:#666600">}</span></span></pre> 
</div> 
<p><span style="font-size:18px">为了启动一个连接而从BluetoothDevice对象中获得的所有东西就是一样: MAC地址. 在该栗子中, 它被保存在一个ArrayAdapter中以便用来展示给用户看. MAC地址可以稍后被提取出来用于启动连接.</span></p> 
<h3><strong><span style="font-size:18px">发现设备: </span></strong></h3> 
<p><span style="font-size:18px">想要启动发现设备功能, 只要调用startDiscovery()就可以了. 该过程是同步的, 它会直接返回一个boolean值来表示发现功能是否成功启用. 发现过程通常需要12秒钟来查询扫描, 然后每个发现的设备会用发现的设备名列出来. 我们的APP必须为ACTION_FOUND intent注册一个BroadcastReceiver, 这样可以接收关于每个设备发现的数据. 对于每个设备, 系统都会广播一个ACTION_FOUND的Intent. 这个intent会携带额外的数据域EXTRA_DEVICE和EXTRA_CLASS, 分别包括一个BluetoothDevice和一个BluetoothClass. 栗如, 这是一段关于如何注册处理设备发现的broadcast的代码:</span></p> 
<div style="background:#F7F7F7"> 
 <pre style="background:#F7F7F7"><span style="font-size:18px"><span style="color:#006600">// Create a BroadcastReceiver for ACTION_FOUND</span>
<span style="color:#000088">private</span> <span style="color:#000088">final</span> <span style="color:#660066">BroadcastReceiver</span> mReceiver <span style="color:#666600">=</span> <span style="color:#000088">new</span> <span style="color:#660066">BroadcastReceiver</span><span style="color:#666600">()</span> <span style="color:#666600">{<!-- --></span>
    <span style="color:#000088">public</span> <span style="color:#000088">void</span> onReceive<span style="color:#666600">(</span><span style="color:#660066">Context</span> context<span style="color:#666600">,</span> <span style="color:#660066">Intent</span> intent<span style="color:#666600">)</span> <span style="color:#666600">{<!-- --></span>
        <span style="color:#660066">String</span> action <span style="color:#666600">=</span> intent<span style="color:#666600">.</span>getAction<span style="color:#666600">();</span>
        <span style="color:#006600">// When discovery finds a device</span>
        <span style="color:#000088">if</span> <span style="color:#666600">(</span><span style="color:#660066">BluetoothDevice</span><span style="color:#666600">.</span>ACTION_FOUND<span style="color:#666600">.</span>equals<span style="color:#666600">(</span>action<span style="color:#666600">))</span> <span style="color:#666600">{<!-- --></span>
            <span style="color:#006600">// Get the BluetoothDevice object from the Intent</span>
            <span style="color:#660066">BluetoothDevice</span> device <span style="color:#666600">=</span> intent<span style="color:#666600">.</span>getParcelableExtra<span style="color:#666600">(</span><span style="color:#660066">BluetoothDevice</span><span style="color:#666600">.</span>EXTRA_DEVICE<span style="color:#666600">);</span>
            <span style="color:#006600">// Add the name and address to an array adapter to show in a ListView</span>
            mArrayAdapter<span style="color:#666600">.</span>add<span style="color:#666600">(</span>device<span style="color:#666600">.</span>getName<span style="color:#666600">()</span> <span style="color:#666600">+</span> <span style="color:#880000">"\n"</span> <span style="color:#666600">+</span> device<span style="color:#666600">.</span>getAddress<span style="color:#666600">());</span>
        <span style="color:#666600">}</span>
    <span style="color:#666600">}</span>
<span style="color:#666600">};</span>
<span style="color:#006600">// Register the BroadcastReceiver</span>
<span style="color:#660066">IntentFilter</span> filter <span style="color:#666600">=</span> <span style="color:#000088">new</span> <span style="color:#660066">IntentFilter</span><span style="color:#666600">(</span><span style="color:#660066">BluetoothDevice</span><span style="color:#666600">.</span>ACTION_FOUND<span style="color:#666600">);</span>
registerReceiver<span style="color:#666600">(</span>mReceiver<span style="color:#666600">,</span> filter<span style="color:#666600">);</span> <span style="color:#006600">// Don't forget to unregister during onDestroy</span></span></pre> 
</div> 
<p><span style="font-size:18px">跟之前的栗子一样, 我们得到了MAC地址并将其保存起来. 注意, 处理设备发现是一个繁重的任务将会消耗很多资源. 一旦发现了要连接的设备, 请确保尝试连接之前用cancelDiscovery()方法停止发现. 另外, 如果已经与一个设备连接上了, 这时候执行发现动作将会显著降低连接的可用带宽, 所以我们应该在连接的时候不执行发现操作.</span></p> 
<h3><strong><span style="font-size:18px">启用发现: </span></strong></h3> 
<p><span style="font-size:18px">如果想要开启本地设备的被发现功能, 调用startActivityForResult(Intent, int)方法并传入ACTION_REQUEST_DISCOVERABLEaction intent. 这将会通过系统设置发出一个需求来启动可发现模式(而不必停止我们自己的APP). 默认情况下, 设备将会开启可发现功能120s. 我们可以通过EXTRA_DISCOVERABLE_DURATION intent extra来定义一个延时时间长度. 最大的开启被发现功能的时间长度是3600秒, 如果设置为0, 则表示永远开启. 任何不在这个范围内的值会被设置为120秒. 栗如, 这是设置为300秒的栗子:</span></p> 
<div style="background:#F7F7F7"> 
 <pre style="background:#F7F7F7"><span style="font-size:18px"><span style="color:#660066">Intent</span> discoverableIntent <span style="color:#666600">=</span> <span style="color:#000088">new</span>
<span style="color:#660066">Intent</span><span style="color:#666600">(</span><span style="color:#660066">BluetoothAdapter</span><span style="color:#666600">.</span>ACTION_REQUEST_DISCOVERABLE<span style="color:#666600">);</span>
discoverableIntent<span style="color:#666600">.</span>putExtra<span style="color:#666600">(</span><span style="color:#660066">BluetoothAdapter</span><span style="color:#666600">.</span>EXTRA_DISCOVERABLE_DURATION<span style="color:#666600">,</span> <span style="color:#006666">300</span><span style="color:#666600">);</span>
startActivity<span style="color:#666600">(</span>discoverableIntent<span style="color:#666600">);</span></span></pre> 
</div> 
<p><span style="font-size:18px">这时将会显示一个对话框请求用户权限来使设备可发现. 如果用户点击了”是”, 那么设备将会被发现指定时长. 然后我们的activity将会在onActivityResult()中收到结果, 返回的result code等于延时时长. 如果用户点击了”否”或者这中间发生了错误, result code将会是RESULT_CANCELED. 如果蓝牙没有开启的话, 启动蓝牙发现功能会自动开启蓝牙.</span></p> 
<p><span style="font-size:18px">设备将会默默的在指定时间内保持在可发现模式. 如果我们想要在发现模式发生变化的时候收到提醒, 则需要注册一个广播用来接收ACTION_SCAN_MODE_CHANGED intent. 这将会包含额外数据域EXTRA_SCAN_MODE和EXTRA_PREVIOUS_SCAN_MODE,它们将分别告知我们新老扫描模式. 可能的取值是SCAN_MODE_CONNECTABLE_DISCOVERABLE, SCAN_MODE_CONNECTABLE, 或者SCAN_MODE_NONE,它们分别表示设备时处于可发现模式, 不在可发现模式但是依然可以收到连接, 或者不可发现模式并不能收到连接. </span></p> 
<p><span style="font-size:18px">如果我们想要对一个远程设备发起连接, 我们并不需要启用设备发现. 只有在APP要打开一个server socket并接受连接的时候, 我们才有必要启动设备发现功能. 因为只有这样才能被远程设备发现并连接到我们.</span></p> 
<h2><strong><span style="font-size:18px">连接设备: </span></strong></h2> 
<p><span style="font-size:18px">为了创建APP在两台设备之间的连接, 我们必须要实现服务器端和客户端机制, 因为一个设备必须打开server socket, 另一个设备必须启动连接(使用server的MAC地址来发起连接). 当客户端和服务端拥有一个通过相同RFCOMM通道连接的BluetoothSocket的时候就可以连接了!(大概是这么个意思. . .). 在此刻, 每个设备可以获取输入和输出流, 可以开始交换数据, 这些将在后面的小节讲到, 本节介绍如何连接两个设备.</span></p> 
<p><span style="font-size:18px">服务器设备和客户端设备都会用不同的方法取得BluetoothSocket. 服务器将会在接受请求连接的时候收到BluetoothSocket. 客户端则会在向服务器打开一个RFCOMM通道的时候收到.</span></p> 
<p><span style="font-size:18px">一种实现的方法是自动准备每个设备为服务器端, 这样每个设备都有一个服务器socket开启并监听连接. 然后每个设备都可以发起连接成为客户端. 另外还有就是一台设备明确的做主机并在需要的时候打开一个server socket, 然后另一台设备只需要连接就可以了.</span></p> 
<p><span style="font-size:18px">注意: 如果两台设备之前不是配对设备, 那么Android framework将会自动的在连接过程中展示一个配对需求提示或者对话框给用户. 所以当尝试连接到设备的时候, 我们的APP不需要确认是否已经配对. RFCOMM连接尝试将会在用户选择成功配对之前阻塞, 或者用户选择不配对的时候失败.</span></p> 
<h3><strong><span style="font-size:18px">作为服务器连接: </span></strong></h3> 
<p><span style="font-size:18px">当我们想要连接两个设备, 其中一个必须扮演服务器角色, 并持有一个打开的BluetoothServerSocket. 它的用途是监听接入的连接需求, 当有一个被接受的时候, 提供一个连接的BluetoothSocket.当从BluetoothServerSocket中得到BluetoothSocket后, BluetoothServerSocket可以(应该)被释放, 除非我们想要接受更多的连接.下面是设置server socket和接受连接的基本步骤:</span></p> 
<p><span style="font-size:18px">1.      通过listenUsingRfcommWithServiceRecord(String, UUID)得到一个BluetoothServerSocket.方法中的string是一个服务的识别名字, 系统将会自动写入一个Service Discovery Protocol(SDP)数据库(这个名字是随意的, 可以简单的使用APP的名字). UUID也是包含在SDP中的, 并且是连接客户端设备协议的基础. 就是说, 当客户端尝试连接该设备的时候, 它将会携带一个UUID, 这个UUID用来识别唯一的它想要连接的服务. UUID必须匹配才能建立连接. </span></p> 
<p><span style="font-size:18px">2.      通过accept()方法启动监听. 这是一个阻塞方法. 它不管连接已经被接受或者是有异常, 都会直接返回. 只有远程设备发起连接请求并且携带一个匹配的UUID的时候连接才会被接受. 当成功之后, accept()将会返回一个连接的BluetoothSocket.</span></p> 
<p><span style="font-size:18px">3.      除非我们还需要接受更多的连接, 否则调用close(). 该方法将会释放sever socket和它的所有资源, 但是不会关闭accept()返回的已经连接的BluetoothSocket. 不像TCP/IP, RFCOMM每个通道一次只允许一个客户端连接, 所以大多数情况下都应该在连接建立之后对BluetoothServerSocket直接调用close()方法.</span></p> 
<p><span style="font-size:18px">accept()方法不应该在主activity UI线程中调用, 因为它是一个阻塞方法, 会阻止任何其它的app交互. 它通常应该在一个新的线程中跟一个BluetoothServerSocket或者BluetoothSocket合作工作. 想要终止这个阻塞方法的话, 需要从另一个线程调用BluetoothServerSocket(或者BluetoothSocket)的close()方法, 这样所有的阻塞方法就会直接返回了. 注意所有的BluetoothServerSocket和BluetoothSocket方法都是线程安全的.</span></p> 
<p><span style="font-size:18px">这里是一个简单的server组件接收连接的栗子: </span></p> 
<div style="background:#F7F7F7"> 
 <p align="left"><span style="font-size:18px"><span style="color:#000088">private</span><span style="color:#000088">class</span> <span style="color:#660066">AcceptThread</span><span style="color:#000088">extends</span> <span style="color:#660066">Thread</span><span style="color:#666600">{<!-- --></span><br>     <span style="color:#000088">private</span> <span style="color:#000088">final</span><span style="color:#660066">BluetoothServerSocket</span> mmServerSocket<span style="color:#666600">;</span><br>  <br>     <span style="color:#000088">public</span> <span style="color:#660066">AcceptThread</span><span style="color:#666600">()</span><span style="color:#666600">{<!-- --></span><br>         <span style="color:#006600">// Use a temporary object that is later assigned to mmServerSocket,</span><br>         <span style="color:#006600">// because mmServerSocket is final</span><br>         <span style="color:#660066">BluetoothServerSocket</span> tmp <span style="color:#666600"> =</span> <span style="color:#000088">null</span><span style="color:#666600">;</span><br>         <span style="color:#000088">try</span> <span style="color:#666600">{<!-- --></span><br>             <span style="color:#006600">// MY_UUID is the app's UUID string, alsoused by the client code</span><br>             tmp <span style="color:#666600">=</span> mBluetoothAdapter<span style="color:#666600">.</span>listenUsingRfcommWithServiceRecord<span style="color:#666600">(</span>NAME<span style="color:#666600">,</span> MY_UUID<span style="color:#666600">);</span><br>         <span style="color:#666600">}</span> <span style="color:#000088">catch</span><span style="color:#666600">(</span><span style="color:#660066">IOException</span> e<span style="color:#666600">)</span><span style="color:#666600">{<!-- --></span> <span style="color:#666600">}</span><br>         mmServerSocket <span style="color:#666600">=</span> tmp<span style="color:#666600">;</span><br>     <span style="color:#666600">}</span><br>  <br>     <span style="color:#000088">public</span> <span style="color:#000088">void</span> run<span style="color:#666600">()</span><span style="color:#666600">{<!-- --></span><br>         <span style="color:#660066">BluetoothSocket</span> socket <span style="color:#666600"> =</span> <span style="color:#000088">null</span><span style="color:#666600">;</span><br>         <span style="color:#006600">// Keep listening until exception occurs or a socket is returned</span><br>         <span style="color:#000088">while</span> <span style="color:#666600">(</span><span style="color:#000088">true</span><span style="color:#666600">)</span><span style="color:#666600">{<!-- --></span><br>             <span style="color:#000088">try</span> <span style="color:#666600">{<!-- --></span><br>                 socket <span style="color:#666600">=</span> mmServerSocket<span style="color:#666600">.</span>accept<span style="color:#666600">();</span><br>             <span style="color:#666600">}</span> <span style="color:#000088">catch</span><span style="color:#666600">(</span><span style="color:#660066">IOException</span> e<span style="color:#666600">)</span><span style="color:#666600">{<!-- --></span><br>                 <span style="color:#000088">break</span><span style="color:#666600">;</span><br>             <span style="color:#666600">}</span><br>             <span style="color:#006600">// If a connection was accepted</span><br>             <span style="color:#000088">if</span> <span style="color:#666600">(</span>socket<span style="color:#666600">!=</span> <span style="color:#000088">null</span><span style="color:#666600">)</span><span style="color:#666600">{<!-- --></span><br>                 <span style="color:#006600">// Do work to manage the connection (ina separate thread)</span><br>                 manageConnectedSocket<span style="color:#666600">(</span>socket<span style="color:#666600">);</span><br>                 mmServerSocket<span style="color:#666600">.</span>close<span style="color:#666600">();</span><br>                 <span style="color:#000088">break</span><span style="color:#666600">;</span><br>             <span style="color:#666600">}</span><br>         <span style="color:#666600">}</span><br>     <span style="color:#666600">}</span><br>  <br>     <span style="color:#006600">/** Will cancelthe listening socket, and cause the thread to finish */</span><br>     <span style="color:#000088">public</span> <span style="color:#000088">void</span> cancel<span style="color:#666600">()</span><span style="color:#666600">{<!-- --></span><br>         <span style="color:#000088">try</span> <span style="color:#666600">{<!-- --></span><br>             mmServerSocket<span style="color:#666600">.</span>close<span style="color:#666600">();</span><br>         <span style="color:#666600">}</span> <span style="color:#000088">catch</span><span style="color:#666600">(</span><span style="color:#660066">IOException</span> e<span style="color:#666600">)</span><span style="color:#666600">{<!-- --></span> <span style="color:#666600">}</span><br>     <span style="color:#666600">}</span><br> <span style="color:#666600">}</span></span></p> 
</div> 
<p><span style="font-size:18px">在该栗子中, 只期望一个接入连接, 所以一旦有一个连接接入了并得到了BluetoothSocket, APP就会发送这个BluetoothSocket到一个独立的线程, 关闭BluetoothServerSocket并停止循环. 注意当accept()返回BluetoothSocket, socket已经连接, 所以我们不应该调用connect()方法. ManageConnectedSocket()是一个虚构的方法, 它将会实例化一个线程用于交换数据. 将在下面的小节讨论它. </span></p> 
<p><span style="font-size:18px">我们应该保持在结束监听接入连接后立刻关闭BluetoothServerSocket. 在该栗子中, close()在BluetoothSocket获取到之后立刻就被执行了.我们可能需要在线程中提供一个公共方法来关闭私有的BluetoothSocket.</span></p> 
<h3><strong><span style="font-size:18px">作为客户端连接:</span></strong></h3> 
<p><span style="font-size:18px">为了启动一个跟远程设备的连接(一个开启服务端监听的设备), 我们必须先取得一个BluetoothDevice对象来表示远程设备. (获取BluetoothDevice的内容在上面的”查找设备”小节). 然后必须使用BluetoothDevice来获得一个BluetoothSocket并启动连接. 下面是一个基本的步骤:</span></p> 
<p><span style="font-size:18px">1.      使用BluetoothDevice, 通过createRfcommSocketToServiceRecord(UUID)得到一个BluetoothSocket.这将初始化一个BluetoothSocket, 它会连接到一个BluetoothDevice. 这里使用的UUID必须匹配服务端设备使用的UUID. 使用相同的UUID很简单只需要在APP中生成硬编码UUID, 然后关联到客户端和服务端代码中.</span></p> 
<p><span style="font-size:18px">2.      用connect()方法初始化连接. 一旦调用了该方法, 系统将会在远程设备上执行一个SDP查询来匹配UUID. 如果查询成功并且远程设备接受了连接, 它将会在连接期间共享RFCOMM通道, connect()方法将会返回. 该方法是一个阻塞方法. 如果, 不管啥原因连接失败了或者connect()方法超时(大概12秒), 那么它将会抛出一个异常. 所以它应该在一个独立的线程中运行.</span></p> 
<p><span style="font-size:18px">注意, 我们应该总是保证在调用connect()的时候设备没有执行”设备发现”功能. 如果设备发现正在执行, 那么连接尝试将会显著减慢速度并看起来好像失败了.</span></p> 
<p><span style="font-size:18px">栗子: 下面的代码展示了一个初始化连接的线程: </span></p> 
<div style="background:#F7F7F7"> 
 <p align="left"><span style="font-size:18px"><span style="color:#000088">private</span><span style="color:#000088">class</span> <span style="color:#660066">ConnectThread</span><span style="color:#000088">extends</span> <span style="color:#660066">Thread</span><span style="color:#666600">{<!-- --></span><br>     <span style="color:#000088">private</span> <span style="color:#000088">final</span><span style="color:#660066">BluetoothSocket</span> mmSocket<span style="color:#666600">;</span><br>     <span style="color:#000088">private</span> <span style="color:#000088">final</span><span style="color:#660066">BluetoothDevice</span> mmDevice<span style="color:#666600">;</span><br>  <br>     <span style="color:#000088">public</span> <span style="color:#660066">ConnectThread</span><span style="color:#666600">(</span><span style="color:#660066">BluetoothDevice</span> device<span style="color:#666600">)</span><span style="color:#666600">{<!-- --></span><br>         <span style="color:#006600">// Use a temporary object that is later assigned to mmSocket,</span><br>         <span style="color:#006600">// because mmSocket is final</span><br>         <span style="color:#660066">BluetoothSocket</span> tmp <span style="color:#666600"> =</span> <span style="color:#000088">null</span><span style="color:#666600">;</span><br>         mmDevice <span style="color:#666600">=</span> device<span style="color:#666600">;</span><br>  <br>         <span style="color:#006600">// Get a BluetoothSocket to connect with the given BluetoothDevice</span><br>         <span style="color:#000088">try</span> <span style="color:#666600">{<!-- --></span><br>             <span style="color:#006600">// MY_UUID is the app's UUID string, alsoused by the server code</span><br>             tmp <span style="color:#666600">=</span> device<span style="color:#666600">.</span>createRfcommSocketToServiceRecord<span style="color:#666600">(</span>MY_UUID<span style="color:#666600">);</span><br>         <span style="color:#666600">}</span> <span style="color:#000088">catch</span><span style="color:#666600">(</span><span style="color:#660066">IOException</span> e<span style="color:#666600">)</span><span style="color:#666600">{<!-- --></span> <span style="color:#666600">}</span><br>         mmSocket <span style="color:#666600">=</span> tmp<span style="color:#666600">;</span><br>     <span style="color:#666600">}</span><br>  <br>     <span style="color:#000088">public</span> <span style="color:#000088">void</span> run<span style="color:#666600">()</span><span style="color:#666600">{<!-- --></span><br>         <span style="color:#006600">// Cancel discovery because it will slow down the connection</span><br>         mBluetoothAdapter<span style="color:#666600">.</span>cancelDiscovery<span style="color:#666600">();</span><br>  <br>         <span style="color:#000088">try</span> <span style="color:#666600">{<!-- --></span><br>             <span style="color:#006600">// Connect the device through the socket.This will block</span><br>             <span style="color:#006600">// until it succeeds or throws an exception</span><br>             mmSocket<span style="color:#666600">.</span>connect<span style="color:#666600">();</span><br>         <span style="color:#666600">}</span> <span style="color:#000088">catch</span><span style="color:#666600">(</span><span style="color:#660066">IOException</span>connectException<span style="color:#666600">)</span><span style="color:#666600">{<!-- --></span><br>             <span style="color:#006600">// Unable to connect; close the socket andget out</span><br>             <span style="color:#000088">try</span> <span style="color:#666600">{<!-- --></span><br>                 mmSocket<span style="color:#666600">.</span>close<span style="color:#666600">();</span><br>             <span style="color:#666600">}</span> <span style="color:#000088">catch</span><span style="color:#666600">(</span><span style="color:#660066">IOException</span>closeException<span style="color:#666600">)</span><span style="color:#666600">{<!-- --></span> <span style="color:#666600">}</span><br>             <span style="color:#000088">return</span><span style="color:#666600">;</span><br>         <span style="color:#666600">}</span><br>  <br>         <span style="color:#006600">// Do work to manage the connection (in a separate thread)</span><br>         manageConnectedSocket<span style="color:#666600">(</span>mmSocket<span style="color:#666600">);</span><br>     <span style="color:#666600">}</span><br>  <br>     <span style="color:#006600">/** Will cancelan in-progress connection, and close the socket */</span><br>     <span style="color:#000088">public</span> <span style="color:#000088">void</span> cancel<span style="color:#666600">()</span><span style="color:#666600">{<!-- --></span><br>         <span style="color:#000088">try</span> <span style="color:#666600">{<!-- --></span><br>             mmSocket<span style="color:#666600">.</span>close<span style="color:#666600">();</span><br>         <span style="color:#666600">}</span> <span style="color:#000088">catch</span><span style="color:#666600">(</span><span style="color:#660066">IOException</span> e<span style="color:#666600">)</span><span style="color:#666600">{<!-- --></span> <span style="color:#666600">}</span><br>     <span style="color:#666600">}</span><br> <span style="color:#666600">}</span></span></p> 
</div> 
<p><span style="font-size:18px">注意栗子中的cancelDiscovery()方法在连接建立之前被调用了. 我们应该总是在连接之前这样做, 不管它是不是在运行, 调用该方法都是安全的(但是如果想要检查一下的话, 应该调用isDiscovering()方法). ManageConnectedSocket()是一个虚构的方法, 它将会实例化一个线程用于交换数据. 将在下面的小节讨论它.</span></p> 
<p><span style="font-size:18px">当我们处理完了BluetoothSocket, 应该记得调用close()方法来清理. 这样做将会直接关闭连接的socket并清除所有的内部资源.</span></p> 
<h2><strong><span style="font-size:18px">管理一个连接: </span></strong></h2> 
<p><span style="font-size:18px">当我们成功的连接了两个(或者更多的)设备, 每个设备都会拥有一个连接着的BluetoothSocket. 这里开始就比较有意思了, 因为我们可以在设备间分享数据了. 使用BluetoothSocket交换数据的一般步骤是这样的:</span></p> 
<p><span style="font-size:18px">1.      从socket获取传输的InputStream和OutputStream, 分别使用getInputStream()和getOutputStream()方法.</span></p> 
<p><span style="font-size:18px">2.      用read(byte[])和write(byte[])方法读写数据. </span> </p> 
<p><span style="font-size:18px">完事儿. </span></p> 
<p><span style="font-size:18px">当然还有一些实现的细节需要考虑. 首先也是最重要的, 我们应该使用一个专有线程来执行所有的数据读写操作. 这很有必要, 因为read(byte[])和write(byte[])方法都是阻塞方法. Write(byte[])不经常阻塞, 但是可以如果远程设备调用read(byte[])不够快的话会导致中间缓冲区堆满, 并使流控制阻塞. 所以我们的线程主循环应该专门用来从InputStream中读取数据. 线程中可以有一个独立的公共方法来执行OutputStream的写操作.</span></p> 
<p><span style="font-size:18px">栗子, 这里是它们实现的样子:</span></p> 
<div style="background:#F7F7F7"> 
 <p align="left"><span style="font-size:18px"><span style="color:#000088">private</span><span style="color:#000088">class</span> <span style="color:#660066">ConnectedThread</span><span style="color:#000088">extends</span> <span style="color:#660066">Thread</span><span style="color:#666600">{<!-- --></span><br>     <span style="color:#000088">private</span> <span style="color:#000088">final</span><span style="color:#660066">BluetoothSocket</span> mmSocket<span style="color:#666600">;</span><br>     <span style="color:#000088">private</span> <span style="color:#000088">final</span><span style="color:#660066">InputStream</span> mmInStream<span style="color:#666600">;</span><br>     <span style="color:#000088">private</span> <span style="color:#000088">final</span><span style="color:#660066">OutputStream</span> mmOutStream<span style="color:#666600">;</span><br>  <br>     <span style="color:#000088">public</span> <span style="color:#660066">ConnectedThread</span><span style="color:#666600">(</span><span style="color:#660066">BluetoothSocket</span> socket<span style="color:#666600">)</span><span style="color:#666600">{<!-- --></span><br>         mmSocket <span style="color:#666600">=</span> socket<span style="color:#666600">;</span><br>         <span style="color:#660066">InputStream</span> tmpIn <span style="color:#666600"> =</span> <span style="color:#000088">null</span><span style="color:#666600">;</span><br>         <span style="color:#660066">OutputStream</span> tmpOut <span style="color:#666600"> =</span> <span style="color:#000088">null</span><span style="color:#666600">;</span><br>  <br>         <span style="color:#006600">// Get the input and output streams, using temp objects because</span><br>         <span style="color:#006600">// member streams are final</span><br>         <span style="color:#000088">try</span> <span style="color:#666600">{<!-- --></span><br>             tmpIn <span style="color:#666600">=</span> socket<span style="color:#666600">.</span>getInputStream<span style="color:#666600">();</span><br>             tmpOut <span style="color:#666600">=</span> socket<span style="color:#666600">.</span>getOutputStream<span style="color:#666600">();</span><br>         <span style="color:#666600">}</span> <span style="color:#000088">catch</span><span style="color:#666600">(</span><span style="color:#660066">IOException</span> e<span style="color:#666600">)</span><span style="color:#666600">{<!-- --></span> <span style="color:#666600">}</span><br>  <br>         mmInStream <span style="color:#666600">=</span> tmpIn<span style="color:#666600">;</span><br>         mmOutStream <span style="color:#666600">=</span> tmpOut<span style="color:#666600">;</span><br>     <span style="color:#666600">}</span><br>  <br>     <span style="color:#000088">public</span> <span style="color:#000088">void</span> run<span style="color:#666600">()</span><span style="color:#666600">{<!-- --></span><br>         <span style="color:#000088">byte</span><span style="color:#666600">[]</span> buffer<span style="color:#666600">=</span> <span style="color:#000088">new</span> <span style="color:#000088">byte</span><span style="color:#666600">[</span><span style="color:#006666">1024</span><span style="color:#666600">];</span>  <span style="color:#006600">// buffer store for the stream</span><br>         <span style="color:#000088">int</span> bytes<span style="color:#666600">;</span><span style="color:#006600">// bytes returned from read()</span><br>  <br>         <span style="color:#006600">// Keep listening to the InputStream until an exception occurs</span><br>         <span style="color:#000088">while</span> <span style="color:#666600">(</span><span style="color:#000088">true</span><span style="color:#666600">)</span><span style="color:#666600">{<!-- --></span><br>             <span style="color:#000088">try</span> <span style="color:#666600">{<!-- --></span><br>                 <span style="color:#006600">// Read from the InputStream</span><br>                 bytes <span style="color:#666600">=</span> mmInStream<span style="color:#666600">.</span>read<span style="color:#666600">(</span>buffer<span style="color:#666600">);</span><br>                 <span style="color:#006600">// Send the obtained bytes to the UIactivity</span><br>                 mHandler<span style="color:#666600">.</span>obtainMessage<span style="color:#666600">(</span>MESSAGE_READ<span style="color:#666600">,</span> bytes<span style="color:#666600">,</span><span style="color:#666600">-</span><span style="color:#006666">1</span><span style="color:#666600">,</span> buffer<span style="color:#666600">)</span><br>                        <span style="color:#666600">.</span>sendToTarget<span style="color:#666600">();</span><br>             <span style="color:#666600">}</span> <span style="color:#000088">catch</span><span style="color:#666600">(</span><span style="color:#660066">IOException</span> e<span style="color:#666600">)</span><span style="color:#666600">{<!-- --></span><br>                 <span style="color:#000088">break</span><span style="color:#666600">;</span><br>             <span style="color:#666600">}</span><br>         <span style="color:#666600">}</span><br>     <span style="color:#666600">}</span><br>  <br>     <span style="color:#006600">/* Call thisfrom the main activity to send data to the remote device */</span><br>     <span style="color:#000088">public</span> <span style="color:#000088">void</span> write<span style="color:#666600">(</span><span style="color:#000088">byte</span><span style="color:#666600">[]</span> bytes<span style="color:#666600">)</span><span style="color:#666600">{<!-- --></span><br>         <span style="color:#000088">try</span> <span style="color:#666600">{<!-- --></span><br>             mmOutStream<span style="color:#666600">.</span>write<span style="color:#666600">(</span>bytes<span style="color:#666600">);</span><br>         <span style="color:#666600">}</span> <span style="color:#000088">catch</span><span style="color:#666600">(</span><span style="color:#660066">IOException</span> e<span style="color:#666600">)</span><span style="color:#666600">{<!-- --></span> <span style="color:#666600">}</span><br>     <span style="color:#666600">}</span><br>  <br>     <span style="color:#006600">/* Call thisfrom the main activity to shutdown the connection */</span><br>     <span style="color:#000088">public</span> <span style="color:#000088">void</span> cancel<span style="color:#666600">()</span><span style="color:#666600">{<!-- --></span><br>         <span style="color:#000088">try</span> <span style="color:#666600">{<!-- --></span><br>             mmSocket<span style="color:#666600">.</span>close<span style="color:#666600">();</span><br>         <span style="color:#666600">}</span> <span style="color:#000088">catch</span><span style="color:#666600">(</span><span style="color:#660066">IOException</span> e<span style="color:#666600">)</span><span style="color:#666600">{<!-- --></span> <span style="color:#666600">}</span><br>     <span style="color:#666600">}</span><br> <span style="color:#666600">}</span></span></p> 
</div> 
<p><span style="font-size:18px">构造方法取得需要的流, 并只执行一次, 线程将会通过InputStream等待数据到来. 当read(byte[])从流中返回数据的时候, 数据将会被通过成员handler发送给主activity. 然后返回再次等待更多的数据.</span></p> 
<p><span style="font-size:18px">发送要输出的数据跟在主activity中调用write()方法无异, 只需要传给它要发送的数据就行了. 该方法然后调用write(byte[])来发送数据到远程设备.</span></p> 
<p><span style="font-size:18px">线程的cancel()方法很重要, 这样就可以在任何时间都能关闭BluetoothSocket了. 完成蓝牙通信之后应该记得调用该方法.</span></p> 
<h2><strong><span style="font-size:18px">使用配置文件(BluetoothProfile): </span></strong></h2> 
<p><span style="font-size:18px">从Android3.0开始, Bluetooth API开始提供对使用配置文件的支持. 蓝牙配置文件是一个基于蓝牙通信的设备间的无线接口规范. 其中一个栗子是免提(Hands-Free)配置文件. 如果一个手机想要连接到无线耳机, 那么两个设备必须都支持免提配置文件.</span></p> 
<p><span style="font-size:18px">我们可以通过实现BluetoothProfile接口来实现自己的类, 这样就可以支持一个特有的蓝牙配置文件了. Android Bluetooth API提供了这些蓝牙配置文件的实现:</span></p> 
<p><span style="font-size:18px">1.      耳机(Headset): 耳机配置文件提供了手机使用蓝牙耳机的支持. Android为我们提供了BluetoothHeadset类, 它是一个通过IPC(inter process communication)控制蓝牙耳机服务的代理. BluetoothHeadset类包括了对AT命令的支持(文后介绍).</span></p> 
<p><span style="font-size:18px">2.      A2DP: A2DP是AdvancedAudio Distribution Profile. 它定义了高质量音频如何通过蓝牙实现流传输. Android提供了BluetoothA2dp类, 它是一个通过IPC来控制蓝牙A2DP服务的代理.</span></p> 
<p><span style="font-size:18px">3.      健康设备(Health Device): Android4.0引入了对蓝牙健康设备配置文件(BluetoothHealth Device Profile(HDP))的支持. 这让我们可以创建使用蓝牙与支持蓝牙的健康设备通信的APP. 比如心率监测器, 血压计, 温度计等. 想要了解更多相应设备的专业实现代码, 可以到<a target="_blank" rel="nofollow">www.bluetooth.org</a> 中的BluetoothAssigned numbers中查找. 还有 ISO/IEEE 11073-20601 [7]中也有.</span></p> 
<p><span style="font-size:18px">这里是使用配置文件的基本步骤: </span></p> 
<p><span style="font-size:18px">1.      获取默认的adapter, 在前文”设置蓝牙”中有描述. </span></p> 
<p><span style="font-size:18px">2.      使用getProfileProxy()来建立一个配置文件到配置文件代理对象的连接. 在下面的栗子中, 配置文件代理对象是一个BluetoothHeadset实例.</span></p> 
<p><span style="font-size:18px">3.      设置一个BluetoothProfile.ServiceListener. 当它们从服务器连接或者断开连接的时候该监听器提醒BluetoothProfile IPC客户端.</span></p> 
<p><span style="font-size:18px">4.      在onServiceConnected()方法中取得一个配置文件代理对象的句柄. </span> </p> 
<p><span style="font-size:18px">5.      一旦得到了这个配置文件句柄, 我们就可以用它来监测连接状态和处理其他相应的操作了.</span></p> 
<p><span style="font-size:18px">下面的代码片段展示了如何连接到一个BluetoothHeadset代理对象, 以便控制headset配置文件:</span></p> 
<div style="background:#F7F7F7"> 
 <p align="left"><span style="font-size:18px"><span style="color:#660066">BluetoothHeadset</span> mBluetoothHeadset<span style="color:#666600">;</span><br>  <br> <span style="color:#006600">// Get thedefault adapter</span><br> <span style="color:#660066">BluetoothAdapter</span> mBluetoothAdapter <span style="color:#666600"> =</span> <span style="color:#660066">BluetoothAdapter</span><span style="color:#666600">.</span>getDefaultAdapter<span style="color:#666600">();</span><br>  <br> <span style="color:#006600">// Establishconnection to the proxy.</span><br> mBluetoothAdapter<span style="color:#666600">.</span>getProfileProxy<span style="color:#666600">(</span>context<span style="color:#666600">,</span> mProfileListener<span style="color:#666600">,</span><span style="color:#660066">BluetoothProfile</span><span style="color:#666600">.</span>HEADSET<span style="color:#666600">);</span><br>  <br> <span style="color:#000088">private</span> <span style="color:#660066">BluetoothProfile</span><span style="color:#666600">.</span><span style="color:#660066">ServiceListener</span>mProfileListener<span style="color:#666600">=</span> <span style="color:#000088">new</span> <span style="color:#660066">BluetoothProfile</span><span style="color:#666600">.</span><span style="color:#660066">ServiceListener</span><span style="color:#666600">()</span><span style="color:#666600">{<!-- --></span><br>     <span style="color:#000088">public</span> <span style="color:#000088">void</span> onServiceConnected<span style="color:#666600">(</span><span style="color:#000088">int</span> profile<span style="color:#666600">,</span><span style="color:#660066">BluetoothProfile</span> proxy<span style="color:#666600">)</span><span style="color:#666600">{<!-- --></span><br>         <span style="color:#000088">if</span> <span style="color:#666600">(</span>profile<span style="color:#666600">==</span> <span style="color:#660066">BluetoothProfile</span><span style="color:#666600">.</span>HEADSET<span style="color:#666600">)</span><span style="color:#666600">{<!-- --></span><br>             mBluetoothHeadset <span style="color:#666600">=</span> <span style="color:#666600"> (</span><span style="color:#660066">BluetoothHeadset</span><span style="color:#666600">)</span> proxy<span style="color:#666600">;</span><br>         <span style="color:#666600">}</span><br>     <span style="color:#666600">}</span><br>     <span style="color:#000088">public</span> <span style="color:#000088">void</span> onServiceDisconnected<span style="color:#666600">(</span><span style="color:#000088">int</span> profile<span style="color:#666600">)</span><span style="color:#666600">{<!-- --></span><br>         <span style="color:#000088">if</span> <span style="color:#666600">(</span>profile<span style="color:#666600">==</span> <span style="color:#660066">BluetoothProfile</span><span style="color:#666600">.</span>HEADSET<span style="color:#666600">)</span><span style="color:#666600">{<!-- --></span><br>             mBluetoothHeadset <span style="color:#666600">=</span> <span style="color:#000088"> null</span><span style="color:#666600">;</span><br>         <span style="color:#666600">}</span><br>     <span style="color:#666600">}</span><br> <span style="color:#666600">};</span><br>  <br> <span style="color:#006600">// ... callfunctions on mBluetoothHeadset</span><br>  <br> <span style="color:#006600">// Close proxyconnection after use.</span><br> mBluetoothAdapter<span style="color:#666600">.</span>closeProfileProxy<span style="color:#666600">(</span>mBluetoothHeadset<span style="color:#666600">);</span></span></p> 
</div> 
<h3><strong><span style="font-size:18px">厂商指定的AT命令:</span></strong></h3> 
<p><span style="font-size:18px">从Android3.0开始, APP可以注册接收预定义的厂商指定的AT由耳机发送的系统广播命令(比如一个Plantronics +XEVENT命令). 栗如, 一个APP可以接收一个连接设备电量等级的广播, 然后提醒用户或者采取需要的措施. 为ACTION_VENDOR_SPECIFIC_HEADSET_EVENT intent创建一个broadcastreceiver就可以处理耳机厂商指定的AT命令了.</span></p> 
<h3><strong><span style="font-size:18px">健康设备配置文件:</span></strong></h3> 
<p><span style="font-size:18px">从Android4.0开始, 引入了对蓝牙健康设备配置文件(HDP)的支持. 这让我们可以创建使用蓝牙跟健康设备(需要支持蓝牙)通信的APP, 比如心率监测器, 血压计, 体温计等. 蓝牙健康API包括BluetoothHealth, BluetoothHealthCallback和BluetoothHealthAppConfiguration类. 要使用蓝牙健康API, 懂得这些关键的HDP概念很重要:</span></p> 
<table border="1" cellspacing="0" cellpadding="0"><tbody><tr><td> <p><span style="font-size:18px">概念</span></p> </td><td> <p><span style="font-size:18px">描述</span></p> </td></tr><tr><td> <p><span style="font-size:18px">Source</span></p> </td><td> <p><span style="font-size:18px">HDP中定义的一个规则. Source是一个健康设备, 该设备必须可以传输医疗数据(体重, 心率等)给一个只能设备, 比如Android手机.</span></p> </td></tr><tr><td> <p><span style="font-size:18px">Sink</span></p> </td><td> <p><span style="font-size:18px">HDP中定义的一个规则. 在HDP中, 一个sink是一个智能设备, 该设备必须可以接受健康数据. 在Android HDP APP中, sink通过BluetoothHealthAppConfiguration对象表达.</span></p> </td></tr><tr><td> <p><span style="font-size:18px">Registration</span></p> </td><td> <p><span style="font-size:18px">指为一个指定的健康设备注册一个sink. </span></p> </td></tr><tr><td> <p><span style="font-size:18px">Connection</span></p> </td><td> <p><span style="font-size:18px">是指在一个健康设备和一个智能设备(比如手机)之间打开一个通道.</span></p> </td></tr></tbody></table> 
<h3><strong><span style="font-size:18px">创建一个HDP APP: </span></strong></h3> 
<p><span style="font-size:18px">这是创建一个Android HDP APP 的基本步骤: </span></p> 
<p><span style="font-size:18px">1.      获取一个相关的BluetoothHealth代理对象. 就想headset和A2DP配置文件设备一样, 我们必须在BluetoothProfile.ServiceListener中调用getProfileProxy()方法并指定HEALTH配置文件类型来建立一个跟配置文件代理对象的连接.</span></p> 
<p><span style="font-size:18px">2.      创建一个BluetoothHealthCallback并注册一个APP配置(BluetoothHealthAppConfiguration)作为健康”sink”.</span></p> 
<p><span style="font-size:18px">3.      创建一个连接到健康设备. 一些设备将会启动连接, 这个步骤对于那些设备是不必要的.</span></p> 
<p><span style="font-size:18px">4.      当成功连接到一个健康设备, 使用文件描述符读写健康设备. 收到的数据需要使用在IEEE 11073-xxxxx中定义的健康管理规范来解读.</span></p> 
<p><span style="font-size:18px">5.      结束之后, 关闭健康通道, 注销APP. </span></p> 
<p><span style="font-size:18px"> </span></p> 
<h2><strong><span style="font-size:18px">总结: </span></strong></h2> 
<p><span style="font-size:18px">根据类来分析: 一共12个类, 分两组:</span></p> 
<p><span style="font-size:18px">BluetoothAdapter</span></p> 
<p><span style="font-size:18px">BluetoothDevice</span></p> 
<p><span style="font-size:18px">BluetoothSocket</span></p> 
<p><span style="font-size:18px">BluetoothServerSocket</span></p> 
<p><span style="font-size:18px">BluetoothClass</span></p> 
<p><span style="font-size:18px">上面这组是蓝牙的基本类, 会在使用蓝牙发现, 查询和连接中用到. </span></p> 
<p><span style="font-size:18px">BluetoothProfile</span></p> 
<p><span style="font-size:18px">BluetoothProfile.ServiceListener</span></p> 
<p><span style="font-size:18px">BluetoothHeadset</span></p> 
<p><span style="font-size:18px">BluetoothA2dp</span></p> 
<p><span style="font-size:18px">BluetoothHealth</span></p> 
<p><span style="font-size:18px">BluetoothHealthCallback</span></p> 
<p><span style="font-size:18px">BluetoothHealthAppConfiguration</span></p> 
<p><span style="font-size:18px">这些则相当于扩展类, 用于实现特定功能. 相当于为更丰富的蓝牙功能提供了接口, 而且还对连接等操作做了封装, 使其用法更加简单.</span></p> 
<p><span style="font-size:18px"> </span></p> 
<p><span style="font-size:18px">参考: <a target="_blank" href="https://developer.android.com/guide/topics/connectivity/bluetooth.html" rel="nofollow noopener noreferrer"> https://developer.android.com/guide/topics/connectivity/bluetooth.html</a></span></p> 
<p><span style="font-size:18px"> </span></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/6dd4a8de06f87a41159127a4fa62168b/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">不显示 Flask Server 的输出信息</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/a0a9c65844c9a83a05458345b85f7ee2/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">Javascript判断一个数字是否在一个区间内</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>