<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>用OpenSSL编写SSL,TLS程序（2） - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="用OpenSSL编写SSL,TLS程序（2）" />
<meta property="og:description" content="一、简介 SSL(Secure Socket Layer)是netscape公司提出的主要用于web的安全通信标准,分为2.0版和3.0版.TLS(Transport Layer Security)是IETF的TLS 工作组在SSL3.0基础之上提出的安全通信标准,目前版本是1.0,即RFC2246.SSL/TLS提供的安全机制可以保证应用层数据在互联网络传输 不 被监听,伪造和窜改.
openssl(www.openssl.org) 是sslv2,sslv3,tlsv1的一份完整实现,内部包含了大量加密算法程序.其命令行提供了丰富的加密,验证,证书生成等功能,甚至可以用其建立 一个完整的CA.与其同时,它也提供了一套完整的库函数,可用开发用SSL/TLS的通信程序. Apache的https两种版本 mod_ssl和apachessl均基于它实现的.openssl继承于ssleay,并做了一定的扩展,当前的版本是0.9.5a.
openssl 的缺点是文档太少,连一份完整的函数说明都没有,man page也至今没做完整:-(,如果想用它编程序,除了熟悉已有的文档(包括 ssleay,mod_ssl,apachessl的文档)外,可以到它的maillist上找相关的帖子,许多问题可以在以前的文章中找到答案.
编程: 程序分为两部分,客户端和服务器端,我们的目的是利用SSL/TLS的特性保证通信双方能够互相验证对方身份(真实性),并保证数据的完整性, 私密性.
对程序来说,openssl将整个握手过程用一对函数体现,即客户端的SSL_connect和服务端的SSL_accept.而后的应用层数据交换则用SSL_read和 SSL_write来完成.
二、证书文件生成 除将程序编译成功外,还需生成必要的证书和私钥文件使双方能够成功验证对方,步骤如下:
1.首先要生成服务器端的私钥(key文件): openssl genrsa -des3 -out server.key 1024 运行时会提示输入密码,此密码用于加密key文件(参数des3便是指加密算法,当然也可以选用其他你认为安全的算法.),以后每当需读取此文 件(通过openssl提供的命令或API)都需输入口令.如果觉得不方便,也可以去除这个口令,但一定要采取其他的保护措施! 去除key文件口令的命令: openssl rsa -in server.key -out server.key
2.openssl req -new -key server.key -out server.csr 生成Certificate Signing Request（CSR）,生成的csr文件交给CA签名后形成服务端自己的证书.屏幕上将有提示,依照其指示一步一步输入要 求的个人信息即可.
3.对客户端也作同样的命令生成key及csr文件: openssl genrsa -des3 -out client.key 1024 openssl req -new -key client.key -out client.csr
4.CSR文件必须有CA的签名才可形成证书.可将此文件发送到verisign等地方由它验证,要交一大笔钱,何不自己做CA呢. 首先生成CA的key文件: openssl -des3 -out ca." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/b9679b0cd558bf5826aa698cc9fe308e/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2017-02-07T16:14:52+08:00" />
<meta property="article:modified_time" content="2017-02-07T16:14:52+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">用OpenSSL编写SSL,TLS程序（2）</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <h5 id="一简介"><strong>一、简介</strong></h5> 
<p>SSL(Secure Socket Layer)是netscape公司提出的主要用于web的安全通信标准,分为2.0版和3.0版.TLS(Transport Layer Security)是IETF的TLS 工作组在SSL3.0基础之上提出的安全通信标准,目前版本是1.0,即RFC2246.SSL/TLS提供的安全机制可以保证应用层数据在互联网络传输 不 被监听,伪造和窜改.</p> 
<p>openssl(www.openssl.org) 是sslv2,sslv3,tlsv1的一份完整实现,内部包含了大量加密算法程序.其命令行提供了丰富的加密,验证,证书生成等功能,甚至可以用其建立 一个完整的CA.与其同时,它也提供了一套完整的库函数,可用开发用SSL/TLS的通信程序. Apache的https两种版本 mod_ssl和apachessl均基于它实现的.openssl继承于ssleay,并做了一定的扩展,当前的版本是0.9.5a.</p> 
<p>openssl 的缺点是文档太少,连一份完整的函数说明都没有,man page也至今没做完整:-(,如果想用它编程序,除了熟悉已有的文档(包括 ssleay,mod_ssl,apachessl的文档)外,可以到它的maillist上找相关的帖子,许多问题可以在以前的文章中找到答案.</p> 
<p>编程: 程序分为两部分,客户端和服务器端,我们的目的是利用SSL/TLS的特性保证通信双方能够互相验证对方身份(真实性),并保证数据的完整性, 私密性.</p> 
<p>对程序来说,openssl将整个握手过程用一对函数体现,即客户端的<strong>SSL_connect</strong>和服务端的<strong>SSL_accept</strong>.而后的应用层数据交换则用SSL_read和 SSL_write来完成.</p> 
<h5 id="二证书文件生成"><strong>二、证书文件生成</strong></h5> 
<p>除将程序编译成功外,还需生成必要的证书和私钥文件使双方能够成功验证对方,步骤如下:</p> 
<p>1.首先要生成服务器端的私钥(key文件): <br> <strong>openssl genrsa -des3 -out server.key 1024</strong> <br> 运行时会提示输入密码,此密码用于加密key文件(参数des3便是指加密算法,当然也可以选用其他你认为安全的算法.),以后每当需读取此文 件(通过openssl提供的命令或API)都需输入口令.如果觉得不方便,也可以去除这个口令,但一定要采取其他的保护措施! <br> 去除key文件口令的命令: <br> <strong>openssl rsa -in server.key -out server.key</strong></p> 
<p>2.<strong>openssl req -new -key server.key -out server.csr</strong> <br> 生成Certificate Signing Request（CSR）,生成的csr文件交给CA签名后形成服务端自己的证书.屏幕上将有提示,依照其指示一步一步输入要 求的个人信息即可.</p> 
<p>3.对客户端也作同样的命令生成key及csr文件: <br> <strong>openssl genrsa -des3 -out client.key 1024</strong> <br> <strong>openssl req -new -key client.key -out client.csr</strong></p> 
<p>4.CSR文件必须有CA的签名才可形成证书.可将此文件发送到verisign等地方由它验证,要交一大笔钱,何不自己做CA呢. <br> 首先生成CA的key文件: <br> <strong>openssl -des3 -out ca.key 1024</strong> <br> 在生成CA自签名的证书: <br> <strong>openssl req -new -x509 -key ca.key -out ca.crt</strong> <br> 如果想让此证书有个期限,如一年,则加上”-days 365”. <br> (“如果非要为这个证书加上一个期限,我情愿是..一万年”)</p> 
<p>5.用生成的CA的证书为刚才生成的server.csr,client.csr文件签名: <br> 可以用openssl中CA系列命令,但不是很好用(也不是多难,唉,一言难尽),一篇文章中推荐用mod_ssl中的sign.sh脚本,试了一下,确实方便了不 少,如果ca.csr存在的话,只需: <br> ./sigh.sh server.csr <br> ./sign.sh client.csr <br> 相应的证书便生成了(后缀.crt).</p> 
<p>现在我们所需的全部文件便生成了.</p> 
<p>其实openssl中还附带了一个叫CA.pl的文件(在安装目录中的misc子目录下),可用其生成以上的文件,使用也比较方便,但此处就不作介绍了.</p> 
<h5 id="三需要了解的一些函数"><strong>三、需要了解的一些函数</strong></h5> 
<p><strong>1.int SSL_CTX_set_cipher_list(SSL_CTX *,const char *str);</strong> <br> 根据SSL/TLS规范,在ClientHello中,客户端会提交一份自己能够支持的加密方法的列表,由服务端选择一种方法后在ServerHello中通知服务端, 从而完成加密算法的协商.</p> 
<p>可用的算法为: <br> EDH-RSA-DES-CBC3-SHA <br> EDH-DSS-DES-CBC3-SHA <br> DES-CBC3-SHA <br> DHE-DSS-RC4-SHA <br> IDEA-CBC-SHA <br> RC4-SHA <br> RC4-MD5 <br> EXP1024-DHE-DSS-RC4-SHA <br> EXP1024-RC4-SHA <br> EXP1024-DHE-DSS-DES-CBC-SHA <br> EXP1024-DES-CBC-SHA <br> EXP1024-RC2-CBC-MD5 <br> EXP1024-RC4-MD5 <br> EDH-RSA-DES-CBC-SHA <br> EDH-DSS-DES-CBC-SHA <br> DES-CBC-SHA <br> EXP-EDH-RSA-DES-CBC-SHA <br> EXP-EDH-DSS-DES-CBC-SHA <br> EXP-DES-CBC-SHA <br> EXP-RC2-CBC-MD5 <br> EXP-RC4-MD5 <br> 这些算法按一定优先级排列,如果不作任何指定,将选用DES-CBC3-SHA.用SSL_CTX_set_cipher_list可以指定自己希望用的算法(实际上只是 提高其优先级,是否能使用还要看对方是否支持).</p> 
<p>我们在程序中选用了RC4做加密,MD5做消息摘要(先进行MD5运算,后进行RC4加密).即 <br> SSL_CTX_set_cipher_list(ctx,”RC4-MD5”);</p> 
<p>在消息传输过程中采用对称加密(比公钥加密在速度上有极大的提高),其所用秘钥(shared secret)在握手过程中中协商(每次对话过程均不同, 在一次对话中都有可能有几次改变),并通过公钥加密的手段由客户端提交服务端.</p> 
<p><strong>2.void SSL_CTX_set_verify(SSL_CTX <em>ctx,int mode,int (*callback)(int, X509_STORE_CTX </em>));</strong> <br> 缺省mode是SSL_VERIFY_NONE,如果想要验证对方的话,便要将此项变成SSL_VERIFY_PEER.SSL/TLS中缺省只验证server,如果没有设置 SSL_VERIFY_PEER的话,客户端连证书都不会发过来.</p> 
<p><strong>3.int SSL_CTX_load_verify_locations(SSL_CTX *ctx, const char *CAfile,const char *CApath);</strong> <br> 要验证对方的话,当然装要有CA的证书了,此函数用来便是加载CA的证书文件的.</p> 
<p><strong>4.int SSL_CTX_use_certificate_file(SSL_CTX *ctx, const char *file, int type);</strong> <br> 加载自己的证书文件.</p> 
<p><strong>5.int SSL_CTX_use_PrivateKey_file(SSL_CTX *ctx, const char *file, int type);</strong> <br> 加载自己的私钥,以用于签名.</p> 
<p><strong>6.int SSL_CTX_check_private_key(SSL_CTX *ctx);</strong> <br> 调用了以上两个函数后,自己检验一下证书与私钥是否配对.</p> 
<p><strong>7.void RAND_seed(const void *buf,int num);</strong> <br> 在win32 的环境中client程序运行时出错(SSL_connect返回-1)的一个主要机制便是与UNIX平台下的随机数生成机制不同(握手的时候用的到). 具体描述可见mod_ssl的FAQ.解决办法就是调用此函数,其中buf应该为一随机的字符串,作为”seed”. <br> 还可以采用一下两个函数: <br> void RAND_screen(void); <br> int RAND_event(UINT, WPARAM, LPARAM); <br> 其中RAND_screen()以屏幕内容作为”seed”产生随机数,RAND_event可以捕获windows中的事件(event),以此为基础 产生随机数.如果一直有 用户干预的话,用这种办法产生的随机数能够”更加随机”,但如果机器一直没人理(如总停在登录画面),则每次都将产生同样的数字.</p> 
<p>这几个函数都只在WIN32环境下编译时有用,各种UNIX下就不必调了. <br> 大量其他的相关函数原型,见crypto/rand/rand.h.</p> 
<p><strong>8.OpenSSL_add_ssl_algorithms()或SSLeay_add_ssl_algorithms()</strong> <br> 其实都是调用int SSL_library_init(void) <br> 进行一些必要的初始化工作,用openssl编写SSL/TLS程序的话第一句便应是它.</p> 
<p><strong>9.void SSL_load_error_strings(void );</strong> <br> 如果想打印出一些方便阅读的调试信息的话,便要在一开始调用此函数.</p> 
<p><strong>10.void ERR_print_errors_fp(FILE *fp);</strong> <br> 如果调用了SSL_load_error_strings()后,便可以随时用ERR_print_errors_fp()来打印错误信息了.</p> 
<p><strong>11.X509 *SSL_get_peer_certificate(SSL *s);</strong> <br> 握手完成后,便可以用此函数从SSL结构中提取出对方的证书(此时证书得到且已经验证过了)整理成X509结构.</p> 
<p><strong>12.X509_NAME *X509_get_subject_name(X509 *a);</strong> <br> 得到证书所有者的名字,参数可用通过SSL_get_peer_certificate()得到的X509对象.</p> 
<p><strong>13.X509_NAME *X509_get_issuer_name(X509 *a)</strong> <br> 得到证书签署者(往往是CA)的名字,参数可用通过SSL_get_peer_certificate()得到的X509对象.</p> 
<p><strong>14.char *X509_NAME_oneline(X509_NAME *a,char *buf,int size);</strong> <br> 将以上两个函数得到的对象变成字符型,以便打印出来.</p> 
<p><strong>15.SSL_METHOD的构造函数</strong> <br> 包括： <br> SSL_METHOD <em>TLSv1_server_method(void); /</em> TLSv1.0 */ <br> SSL_METHOD <em>TLSv1_client_method(void); /</em> TLSv1.0 */</p> 
<p>SSL_METHOD <em>SSLv2_server_method(void); /</em> SSLv2 */ <br> SSL_METHOD <em>SSLv2_client_method(void); /</em> SSLv2 */</p> 
<p>SSL_METHOD <em>SSLv3_server_method(void); /</em> SSLv3 */ <br> SSL_METHOD <em>SSLv3_client_method(void); /</em> SSLv3 */</p> 
<p>SSL_METHOD <em>SSLv23_server_method(void); /</em> SSLv3 but can rollback to v2 */ <br> SSL_METHOD <em>SSLv23_client_method(void); /</em> SSLv3 but can rollback to v2 */ <br> 在程序中究竟采用哪一种协议(TLSv1/SSLv2/SSLv3),就看调哪一组构造函数了.</p> 
<h5 id="四程序源代码win32版本"><strong>四、程序源代码(WIN32版本)</strong></h5> 
<p>基本上是改造的openssl自带的demos目录下的cli.cpp,serv.cpp文件,做了一些修改,并增加了一些功能.</p> 
<pre class="prettyprint"><code class=" hljs vala"><span class="hljs-comment">/*****************************************************************
*SSL/TLS客户端程序WIN32版(以demos/cli.cpp为基础)
*需要用到动态连接库libeay32.dll,ssleay.dll,
*同时在setting中加入ws2_32.lib libeay32.lib ssleay32.lib,
*以上库文件在编译openssl后可在out32dll目录下找到,
*所需证书文件请参照文章自行生成*/</span>
*****************************************************************/
<span class="hljs-preprocessor">#include &lt;stdio.h&gt;</span>
<span class="hljs-preprocessor">#include &lt;stdlib.h&gt;</span>
<span class="hljs-preprocessor">#include &lt;memory.h&gt;</span>
<span class="hljs-preprocessor">#include &lt;errno.h&gt;</span>
<span class="hljs-preprocessor">#include &lt;sys/types.h&gt;</span>

<span class="hljs-preprocessor">#include &lt;winsock2.h&gt;</span>

<span class="hljs-preprocessor">#include "openssl/rsa.h"      </span>
<span class="hljs-preprocessor">#include "openssl/crypto.h"</span>
<span class="hljs-preprocessor">#include "openssl/x509.h"</span>
<span class="hljs-preprocessor">#include "openssl/pem.h"</span>
<span class="hljs-preprocessor">#include "openssl/ssl.h"</span>
<span class="hljs-preprocessor">#include "openssl/err.h"</span>
<span class="hljs-preprocessor">#include "openssl/rand.h"</span>

<span class="hljs-comment">/*所有需要的参数信息都在此处以#define的形式提供*/</span>
<span class="hljs-preprocessor">#define CERTF  "client.crt"  /*客户端的证书(需经CA签名)*/</span>
<span class="hljs-preprocessor">#define KEYF  "client.key"   /*客户端的私钥(建议加密存储)*/</span>
<span class="hljs-preprocessor">#define CACERT "ca.crt"      /*CA 的证书*/</span>
<span class="hljs-preprocessor">#define PORT   1111          /*服务端的端口*/</span>
<span class="hljs-preprocessor">#define SERVER_ADDR "127.0.0.1"  /*服务段的IP地址*/</span>

<span class="hljs-preprocessor">#define CHK_NULL(x) if ((x)==NULL) exit (-1)</span>
<span class="hljs-preprocessor">#define CHK_ERR(err,s) if ((err)==-1) { perror(s); exit(-2); }</span>
<span class="hljs-preprocessor">#define CHK_SSL(err) if ((err)==-1) { ERR_print_errors_fp(stderr); exit(-3); }</span>

<span class="hljs-keyword">int</span> main ()
{
  <span class="hljs-keyword">int</span> err;
  <span class="hljs-keyword">int</span> sd;
  <span class="hljs-keyword">struct</span> sockaddr_in sa;
  SSL_CTX* ctx;
  SSL*     ssl;
  X509*    server_cert;
  <span class="hljs-keyword">char</span>*    str;
  <span class="hljs-keyword">char</span>     buf [<span class="hljs-number">4096</span>];
 <span class="hljs-constant"> SSL_METHOD </span>*meth;
  <span class="hljs-keyword">int</span>       seed_int[<span class="hljs-number">100</span>]; <span class="hljs-comment">/*存放随机序列*/</span>

 <span class="hljs-constant"> WSADATA </span>wsaData;

  if(WSAStartup(MAKEWORD(<span class="hljs-number">2</span>,<span class="hljs-number">2</span>),&amp;wsaData) != <span class="hljs-number">0</span>){
    printf(<span class="hljs-string">"WSAStartup()fail:%d/n"</span>,GetLastError());
    <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;
  } 

  OpenSSL_add_ssl_algorithms(); <span class="hljs-comment">/*初始化*/</span>
  SSL_load_error_strings();     <span class="hljs-comment">/*为打印调试信息作准备*/</span>

  meth = TLSv1_client_method(); <span class="hljs-comment">/*采用什么协议(SSLv2/SSLv3/TLSv1)在此指定*/</span>
  ctx = SSL_CTX_new (meth);                       
  CHK_NULL(ctx);

  SSL_CTX_set_verify(ctx,SSL_VERIFY_PEER,NULL);   <span class="hljs-comment">/*验证与否*/</span>
  SSL_CTX_load_verify_locations(ctx,CACERT,NULL); <span class="hljs-comment">/*若验证,则放置CA证书*/</span>


  if (SSL_CTX_use_certificate_file(ctx, CERTF, SSL_FILETYPE_PEM) &lt;= <span class="hljs-number">0</span>) {
    ERR_print_errors_fp(<span class="hljs-keyword">stderr</span>);
    exit(-<span class="hljs-number">2</span>);
  }
  if (SSL_CTX_use_PrivateKey_file(ctx, KEYF, SSL_FILETYPE_PEM) &lt;= <span class="hljs-number">0</span>) {
    ERR_print_errors_fp(<span class="hljs-keyword">stderr</span>);
    exit(-<span class="hljs-number">3</span>);
  }

  if (!SSL_CTX_check_private_key(ctx)) {
    printf(<span class="hljs-string">"Private key does not match the certificate public key/n"</span>);
    exit(-<span class="hljs-number">4</span>);
  } 

  <span class="hljs-comment">/*构建随机数生成机制,WIN32平台必需*/</span>
  srand( (unsigned)time(<span class="hljs-constant"> NULL </span>) );
  <span class="hljs-keyword">for</span>( <span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;   i &lt; <span class="hljs-number">100</span>;i++ )
        seed_int = rand();
  RAND_seed(seed_int, sizeof(seed_int));

  <span class="hljs-comment">/*以下是正常的TCP socket建立过程 .............................. */</span>
  printf(<span class="hljs-string">"Begin tcp socket.../n"</span>);

  sd = socket (AF_INET, SOCK_STREAM, <span class="hljs-number">0</span>);       CHK_ERR(sd, <span class="hljs-string">"socket"</span>);

  memset (&amp;sa, <span class="hljs-string">'/0'</span>, sizeof(sa));
  sa.sin_family      = AF_INET;
  sa.sin_addr.s_addr = inet_addr (SERVER_ADDR);   <span class="hljs-comment">/* Server IP */</span>
  sa.sin_port        = htons     (PORT);          <span class="hljs-comment">/* Server Port number */</span>

  err = connect(sd, (<span class="hljs-keyword">struct</span> sockaddr*) &amp;sa,
        sizeof(sa)); 
  CHK_ERR(err, <span class="hljs-string">"connect"</span>);

  <span class="hljs-comment">/* TCP 链接已建立.开始 SSL 握手过程.......................... */</span>
  printf(<span class="hljs-string">"Begin SSL negotiation /n"</span>);

  ssl = SSL_new (ctx);                        
  CHK_NULL(ssl);

  SSL_set_fd (ssl, sd);
  err = SSL_connect (ssl);
  CHK_SSL(err);

  <span class="hljs-comment">/*打印所有加密算法的信息(可选)*/</span>
  printf (<span class="hljs-string">"SSL connection using %s/n"</span>, SSL_get_cipher (ssl));

  <span class="hljs-comment">/*得到服务端的证书并打印些信息(可选) */</span>
  server_cert = SSL_get_peer_certificate (ssl);      
  CHK_NULL(server_cert);
  printf (<span class="hljs-string">"Server certificate:/n"</span>);

  str = X509_NAME_oneline (X509_get_subject_name (server_cert),<span class="hljs-number">0</span>,<span class="hljs-number">0</span>);
  CHK_NULL(str);
  printf (<span class="hljs-string">"/t subject: %s/n"</span>, str);
  Free (str);

  str = X509_NAME_oneline (X509_get_issuer_name  (server_cert),<span class="hljs-number">0</span>,<span class="hljs-number">0</span>);
  CHK_NULL(str);
  printf (<span class="hljs-string">"/t issuer: %s/n"</span>, str);
  Free (str);

  X509_free (server_cert);  <span class="hljs-comment">/*如不再需要,需将证书释放 */</span>

  <span class="hljs-comment">/* 数据交换开始,用SSL_write,SSL_read代替write,read */</span>
  printf(<span class="hljs-string">"Begin SSL data exchange/n"</span>);

  err = SSL_write (ssl, <span class="hljs-string">"Hello World!"</span>, strlen(<span class="hljs-string">"Hello World!"</span>)); 
  CHK_SSL(err);

  err = SSL_read (ssl, buf, sizeof(buf) - <span class="hljs-number">1</span>); 
  CHK_SSL(err);

  buf[err] = <span class="hljs-string">'/0'</span>;
  printf (<span class="hljs-string">"Got %d chars:'%s'/n"</span>, err, buf);
  SSL_shutdown (ssl);  <span class="hljs-comment">/* send SSL/TLS close_notify */</span>

  <span class="hljs-comment">/* 收尾工作 */</span>
  shutdown (sd,<span class="hljs-number">2</span>);
  SSL_free (ssl);
  SSL_CTX_free (ctx);

  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}
<span class="hljs-comment">/*****************************************************************
* EOF - cli.cpp
*****************************************************************/</span>


<span class="hljs-comment">/*****************************************************************
*SSL/TLS服务端程序WIN32版(以demos/server.cpp为基础)
*需要用到动态连接库libeay32.dll,ssleay.dll,
*同时在setting中加入ws2_32.lib libeay32.lib ssleay32.lib,
*以上库文件在编译openssl后可在out32dll目录下找到,
*所需证书文件请参照文章自行生成.
*****************************************************************/</span>

<span class="hljs-preprocessor">#include &lt;stdio.h&gt;</span>
<span class="hljs-preprocessor">#include &lt;stdlib.h&gt;</span>
<span class="hljs-preprocessor">#include &lt;memory.h&gt;</span>
<span class="hljs-preprocessor">#include &lt;errno.h&gt;</span>
<span class="hljs-preprocessor">#include &lt;sys/types.h&gt;</span>

<span class="hljs-preprocessor">#include &lt;winsock2.h&gt;</span>

<span class="hljs-preprocessor">#include "openssl/rsa.h"      </span>
<span class="hljs-preprocessor">#include "openssl/crypto.h"</span>
<span class="hljs-preprocessor">#include "openssl/x509.h"</span>
<span class="hljs-preprocessor">#include "openssl/pem.h"</span>
<span class="hljs-preprocessor">#include "openssl/ssl.h"</span>
<span class="hljs-preprocessor">#include "openssl/err.h"</span>

<span class="hljs-comment">/*所有需要的参数信息都在此处以#define的形式提供*/</span>
<span class="hljs-preprocessor">#define CERTF   "server.crt" /*服务端的证书(需经CA签名)*/</span>
<span class="hljs-preprocessor">#define KEYF   "server.key"  /*服务端的私钥(建议加密存储)*/</span>
<span class="hljs-preprocessor">#define CACERT "ca.crt" /*CA 的证书*/</span>
<span class="hljs-preprocessor">#define PORT   1111   /*准备绑定的端口*/</span>

<span class="hljs-preprocessor">#define CHK_NULL(x) if ((x)==NULL) exit (1)</span>
<span class="hljs-preprocessor">#define CHK_ERR(err,s) if ((err)==-1) { perror(s); exit(1); }</span>
<span class="hljs-preprocessor">#define CHK_SSL(err) if ((err)==-1) { ERR_print_errors_fp(stderr); exit(2); }</span>

<span class="hljs-keyword">int</span> main ()
{
  <span class="hljs-keyword">int</span> err;
  <span class="hljs-keyword">int</span> listen_sd;
  <span class="hljs-keyword">int</span> sd;
  <span class="hljs-keyword">struct</span> sockaddr_in sa_serv;
  <span class="hljs-keyword">struct</span> sockaddr_in sa_cli;
  <span class="hljs-keyword">int</span> client_len;
  SSL_CTX* ctx;
  SSL*     ssl;
  X509*    client_cert;
  <span class="hljs-keyword">char</span>*    str;
  <span class="hljs-keyword">char</span>     buf [<span class="hljs-number">4096</span>];
 <span class="hljs-constant"> SSL_METHOD </span>*meth;
 <span class="hljs-constant"> WSADATA </span>wsaData;

  if(WSAStartup(MAKEWORD(<span class="hljs-number">2</span>,<span class="hljs-number">2</span>),&amp;wsaData) != <span class="hljs-number">0</span>){
    printf(<span class="hljs-string">"WSAStartup()fail:%d/n"</span>,GetLastError());
    <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;
  }

  SSL_load_error_strings();            <span class="hljs-comment">/*为打印调试信息作准备*/</span>
  OpenSSL_add_ssl_algorithms();        <span class="hljs-comment">/*初始化*/</span>
  meth = TLSv1_server_method();  <span class="hljs-comment">/*采用什么协议(SSLv2/SSLv3/TLSv1)在此指定*/</span>

  ctx = SSL_CTX_new (meth);
  CHK_NULL(ctx);

  SSL_CTX_set_verify(ctx,SSL_VERIFY_PEER,NULL);   <span class="hljs-comment">/*验证与否*/</span>
  SSL_CTX_load_verify_locations(ctx,CACERT,NULL); <span class="hljs-comment">/*若验证,则放置CA证书*/</span>

  if (SSL_CTX_use_certificate_file(ctx, CERTF, SSL_FILETYPE_PEM) &lt;= <span class="hljs-number">0</span>) {
    ERR_print_errors_fp(<span class="hljs-keyword">stderr</span>);
    exit(<span class="hljs-number">3</span>);
  }
  if (SSL_CTX_use_PrivateKey_file(ctx, KEYF, SSL_FILETYPE_PEM) &lt;= <span class="hljs-number">0</span>) {
    ERR_print_errors_fp(<span class="hljs-keyword">stderr</span>);
    exit(<span class="hljs-number">4</span>);
  }

  if (!SSL_CTX_check_private_key(ctx)) {
    printf(<span class="hljs-string">"Private key does not match the certificate public key/n"</span>);
    exit(<span class="hljs-number">5</span>);
  }

  SSL_CTX_set_cipher_list(ctx,<span class="hljs-string">"RC4-MD5"</span>); 

  <span class="hljs-comment">/*开始正常的TCP socket过程.................................*/</span>
  printf(<span class="hljs-string">"Begin TCP socket.../n"</span>);

  listen_sd = socket (AF_INET, SOCK_STREAM, <span class="hljs-number">0</span>);  
  CHK_ERR(listen_sd, <span class="hljs-string">"socket"</span>);

  memset (&amp;sa_serv, <span class="hljs-string">'/0'</span>, sizeof(sa_serv));
  sa_serv.sin_family      = AF_INET;
  sa_serv.sin_addr.s_addr = INADDR_ANY;
  sa_serv.sin_port        = htons (PORT);         

  err = bind(listen_sd, (<span class="hljs-keyword">struct</span> sockaddr*) &amp;sa_serv,

  sizeof (sa_serv));

  CHK_ERR(err, <span class="hljs-string">"bind"</span>);

  <span class="hljs-comment">/*接受TCP链接*/</span>
  err = listen (listen_sd, <span class="hljs-number">5</span>);                   
  CHK_ERR(err, <span class="hljs-string">"listen"</span>);

  client_len = sizeof(sa_cli);
  sd = accept (listen_sd, (<span class="hljs-keyword">struct</span> sockaddr*) &amp;sa_cli, &amp;client_len);
  CHK_ERR(sd, <span class="hljs-string">"accept"</span>);
  closesocket (listen_sd);

  printf (<span class="hljs-string">"Connection from %lx, port %x/n"</span>,
      sa_cli.sin_addr.s_addr, sa_cli.sin_port);

  <span class="hljs-comment">/*TCP连接已建立,进行服务端的SSL过程. */</span>
  printf(<span class="hljs-string">"Begin server side SSL/n"</span>);

  ssl = SSL_new (ctx);                          
  CHK_NULL(ssl);
  SSL_set_fd (ssl, sd);
  err = SSL_accept (ssl);
  printf(<span class="hljs-string">"SSL_accept finished/n"</span>);
  CHK_SSL(err);

  <span class="hljs-comment">/*打印所有加密算法的信息(可选)*/</span>
  printf (<span class="hljs-string">"SSL connection using %s/n"</span>, SSL_get_cipher (ssl));

  <span class="hljs-comment">/*得到服务端的证书并打印些信息(可选) */</span>
  client_cert = SSL_get_peer_certificate (ssl);
  if (client_cert != NULL) {
    printf (<span class="hljs-string">"Client certificate:/n"</span>);

    str = X509_NAME_oneline (X509_get_subject_name (client_cert), <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);
    CHK_NULL(str);
    printf (<span class="hljs-string">"/t subject: %s/n"</span>, str);
    Free (str);

    str = X509_NAME_oneline (X509_get_issuer_name  (client_cert), <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);
    CHK_NULL(str);
    printf (<span class="hljs-string">"/t issuer: %s/n"</span>, str);
    Free (str);

    X509_free (client_cert);<span class="hljs-comment">/*如不再需要,需将证书释放 */</span>
  }
  <span class="hljs-keyword">else</span>
    printf (<span class="hljs-string">"Client does not have certificate./n"</span>);

  <span class="hljs-comment">/* 数据交换开始,用SSL_write,SSL_read代替write,read */</span>
  err = SSL_read (ssl, buf, sizeof(buf) - <span class="hljs-number">1</span>);                  
  CHK_SSL(err);
  buf[err] = <span class="hljs-string">'/0'</span>;
  printf (<span class="hljs-string">"Got %d chars:'%s'/n"</span>, err, buf);

  err = SSL_write (ssl, <span class="hljs-string">"I hear you."</span>, strlen(<span class="hljs-string">"I hear you."</span>)); 
  CHK_SSL(err);

  <span class="hljs-comment">/* 收尾工作*/</span>
  shutdown (sd,<span class="hljs-number">2</span>);
  SSL_free (ssl);
  SSL_CTX_free (ctx);

  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}
<span class="hljs-comment">/*****************************************************************
* EOF - serv.cpp
*****************************************************************/</span></code></pre> 
<h5 id="五https-http-兼容客户端的c语言实现"><strong>五、https / http 兼容客户端的c语言实现</strong></h5> 
<pre class="prettyprint"><code class=" hljs cs"><span class="hljs-comment">/*
* OpenSSL SSL/TLS Https Client example
* Only for Unix/Linux:
*    cc -c https.c
*    cc -o https https.c -lssl
* OpenSSL library needed.
*
* 同时支持普通的socket连接以及基于普通socket基础之上的ssl
* 连接。这对于已有的socket程序修改来说会比较方便，不至于
* 和原来的结构发生太大的冲突.
* 要注意的一点，似乎当使用socket套接字来创建ssl连接的时候,
* 如果套接字是采用非阻塞方式建立的话，会导致ssl会话失败，不
* 知道为什么。所以这里对于提供给https的套接字采用了普通的
* connect方法创建。
*
*/</span>

<span class="hljs-preprocessor">#include &lt;stdio.h&gt;</span>
<span class="hljs-preprocessor">#include &lt;stdlib.h&gt;</span>
<span class="hljs-preprocessor">#include &lt;string.h&gt;</span>
<span class="hljs-preprocessor">#include &lt;stdarg.h&gt;</span>
<span class="hljs-preprocessor">#include &lt;errno.h&gt;</span>
<span class="hljs-preprocessor">#include &lt;fcntl.h&gt;</span>
<span class="hljs-preprocessor">#include &lt;unistd.h&gt;</span>
<span class="hljs-preprocessor">#include &lt;sys/types.h&gt;</span>
<span class="hljs-preprocessor">#include &lt;sys/socket.h&gt;</span>
<span class="hljs-preprocessor">#include &lt;netinet/in.h&gt;</span>
<span class="hljs-preprocessor">#include &lt;arpa/inet.h&gt;</span>
<span class="hljs-preprocessor">#include &lt;netdb.h&gt;</span>
<span class="hljs-preprocessor">#include &lt;openssl/crypto.h&gt;</span>
<span class="hljs-preprocessor">#include &lt;openssl/ssl.h&gt;</span>
<span class="hljs-preprocessor">#include &lt;openssl/err.h&gt;</span>
<span class="hljs-preprocessor">#include &lt;openssl/rand.h&gt;</span>


<span class="hljs-preprocessor">#<span class="hljs-keyword">define</span> BUF_LEN 1024</span>
<span class="hljs-preprocessor">#<span class="hljs-keyword">define</span> MAX_STRING_LEN  2048</span>

<span class="hljs-comment">//xnet_select x defines</span>
<span class="hljs-preprocessor">#<span class="hljs-keyword">define</span> READ_STATUS     0</span>
<span class="hljs-preprocessor">#<span class="hljs-keyword">define</span> WRITE_STATUS    1</span>
<span class="hljs-preprocessor">#<span class="hljs-keyword">define</span> EXCPT_STATUS    2</span>

<span class="hljs-comment">/* flag to set request with ssl or not. */</span>
<span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> bIsHttps = <span class="hljs-number">1</span>;
<span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> timeout_sec = <span class="hljs-number">10</span>;
<span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> timeout_microsec = <span class="hljs-number">0</span>;

<span class="hljs-keyword">void</span> err_doit(<span class="hljs-keyword">int</span> errnoflag, <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *fmt, va_list ap);
<span class="hljs-keyword">void</span> err_quit(<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *fmt, ...);
<span class="hljs-keyword">int</span> create_tcpsocket(<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *host, <span class="hljs-keyword">const</span> unsigned <span class="hljs-keyword">short</span> port);
<span class="hljs-keyword">int</span> xnet_select(<span class="hljs-keyword">int</span> s, <span class="hljs-keyword">int</span> sec, <span class="hljs-keyword">int</span> usec, <span class="hljs-keyword">short</span> x);

<span class="hljs-keyword">int</span> main(<span class="hljs-keyword">int</span> argc, <span class="hljs-keyword">char</span>* argv[]){
    <span class="hljs-keyword">char</span>* host = <span class="hljs-string">"127.0.0.1"</span>;
    unsigned <span class="hljs-keyword">short</span> port = <span class="hljs-number">80</span>;
    <span class="hljs-keyword">int</span> fd;

    SSL *ssl;
    SSL_CTX *ctx;

    <span class="hljs-keyword">int</span> n,ret;
    <span class="hljs-keyword">char</span> buf[BUF_LEN];
    <span class="hljs-keyword">char</span>* requestpath = <span class="hljs-string">"/"</span>;

    <span class="hljs-keyword">if</span>( argc == <span class="hljs-number">5</span> ){
        host = argv[<span class="hljs-number">1</span>];
        port = atoi(argv[<span class="hljs-number">2</span>]);
        requestpath = argv[<span class="hljs-number">3</span>];
        bIsHttps = atoi(argv[<span class="hljs-number">4</span>]);
    }

    <span class="hljs-comment">/* make connection to the cache server */</span>
    fd = create_tcpsocket(host, port);

    <span class="hljs-comment">/* http request. */</span>
    sprintf(buf, <span class="hljs-string">"GET %s HTTP/1.0/r/nHost: %s/r/n/r/n"</span>, requestpath, host);

    <span class="hljs-keyword">if</span>(bIsHttps != <span class="hljs-number">1</span>){
        <span class="hljs-keyword">if</span>(xnet_select(fd, timeout_sec, timeout_microsec, WRITE_STATUS)&gt;<span class="hljs-number">0</span>){
            <span class="hljs-comment">/* send off the message */</span>
            write(fd, buf, strlen(buf));
        }
        <span class="hljs-keyword">else</span>{
            err_quit(<span class="hljs-string">"Socket I/O Write Timeout %s:%d/n"</span>, host, port);
        }
        printf(<span class="hljs-string">"Server response:/n"</span>);
        <span class="hljs-keyword">while</span> (xnet_select(fd, timeout_sec, timeout_microsec, READ_STATUS)&gt;<span class="hljs-number">0</span>){
            <span class="hljs-keyword">if</span> ((n = read(fd, buf, BUF_LEN-<span class="hljs-number">1</span>)) &gt; <span class="hljs-number">0</span>) {
                buf[n] = <span class="hljs-string">'/0'</span>;
                printf(<span class="hljs-string">"%s"</span>, buf);
            }
            <span class="hljs-keyword">else</span>{
                <span class="hljs-keyword">break</span>;
            }
        }
        <span class="hljs-comment">// close the plain socket handler.</span>
        close(fd);
    }
    <span class="hljs-keyword">else</span>{
        SSL_load_error_strings();
        SSL_library_init();
        ctx = SSL_CTX_new(SSLv23_client_method());
        <span class="hljs-keyword">if</span> ( ctx == NULL ){
            err_quit(<span class="hljs-string">"init SSL CTX failed:%s/n"</span>,
                        ERR_reason_error_string(ERR_get_error()));
        }

        ssl = SSL_new(ctx);
        <span class="hljs-keyword">if</span> ( ssl == NULL ){
            err_quit(<span class="hljs-string">"new SSL with created CTX failed:%s/n"</span>,
                        ERR_reason_error_string(ERR_get_error()));
        }

        ret = SSL_set_fd(ssl, fd);
        <span class="hljs-keyword">if</span> ( ret == <span class="hljs-number">0</span> ){
            err_quit(<span class="hljs-string">"add SSL to tcp socket failed:%s/n"</span>,
                        ERR_reason_error_string(ERR_get_error()));
        }

        <span class="hljs-comment">/* PRNG */</span>
        RAND_poll();
        <span class="hljs-keyword">while</span> ( RAND_status() == <span class="hljs-number">0</span> ){
            unsigned <span class="hljs-keyword">short</span> rand_ret = rand() % <span class="hljs-number">65536</span>;
            RAND_seed(&amp;rand_ret, <span class="hljs-keyword">sizeof</span>(rand_ret));
        }

        <span class="hljs-comment">/* SSL Connect */</span>
        ret = SSL_connect(ssl);
        <span class="hljs-keyword">if</span>( ret != <span class="hljs-number">1</span> ){
            err_quit(<span class="hljs-string">"SSL connection failed:%s/n"</span>,
                        ERR_reason_error_string(ERR_get_error()));
        }

        <span class="hljs-comment">// https socket write.</span>
        SSL_write(ssl, buf, strlen(buf));
        <span class="hljs-keyword">while</span>((n = SSL_read(ssl, buf, BUF_LEN-<span class="hljs-number">1</span>)) &gt; <span class="hljs-number">0</span>){
            buf[n] = <span class="hljs-string">'/0'</span>;
            write(<span class="hljs-number">1</span>, buf, n); 
        }
        <span class="hljs-keyword">if</span>(n != <span class="hljs-number">0</span>){
            err_quit(<span class="hljs-string">"SSL read failed:%s/n"</span>,
                        ERR_reason_error_string(ERR_get_error()));
        }
        <span class="hljs-comment">// close ssl tunnel.</span>
        ret = SSL_shutdown(ssl); 
        <span class="hljs-keyword">if</span>( ret != <span class="hljs-number">1</span> ){
            close(fd);
            err_quit(<span class="hljs-string">"SSL shutdown failed:%s/n"</span>,
                        ERR_reason_error_string(ERR_get_error()));
        }

        <span class="hljs-comment">// close the plain socket handler.</span>
        close(fd);

        <span class="hljs-comment">// clear ssl resource.</span>
        SSL_free(ssl); 
        SSL_CTX_free(ctx);
        ERR_free_strings();
    }
}

<span class="hljs-comment">/* create common tcp socket connection */</span>

<span class="hljs-keyword">int</span> create_tcpsocket(<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *host, <span class="hljs-keyword">const</span> unsigned <span class="hljs-keyword">short</span> port){
    <span class="hljs-keyword">int</span> ret;


    <span class="hljs-keyword">char</span> * transport = <span class="hljs-string">"tcp"</span>;
    <span class="hljs-keyword">struct</span> hostent *phe; <span class="hljs-comment">/* pointer to host information entry */</span>
    <span class="hljs-keyword">struct</span> protoent *ppe; <span class="hljs-comment">/* pointer to protocol information entry */</span>
    <span class="hljs-keyword">struct</span> sockaddr_in sin; <span class="hljs-comment">/* an Internet endpoint address */</span>
    <span class="hljs-keyword">int</span> s; <span class="hljs-comment">/* socket descriptor and socket type */</span>

    memset(&amp;sin, <span class="hljs-number">0</span>, <span class="hljs-keyword">sizeof</span>(sin));
    sin.sin_family = AF_INET;

    <span class="hljs-keyword">if</span> ((sin.sin_port = htons(port)) == <span class="hljs-number">0</span>)
        err_quit(<span class="hljs-string">"invalid port /"</span>%d/<span class="hljs-string">"/n"</span>, port);

    <span class="hljs-comment">/* Map host name to IP address, allowing for dotted decimal */</span>
    <span class="hljs-keyword">if</span>( phe = gethostbyname(host) )
        memcpy(&amp;sin.sin_addr, phe-&gt;h_addr, phe-&gt;h_length);
    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>( (sin.sin_addr.s_addr = inet_addr(host)) == INADDR_NONE )
        err_quit(<span class="hljs-string">"can't get /"</span>%s/<span class="hljs-string">" host entry/n"</span>, host);

    <span class="hljs-comment">/* Map transport protocol name to protocol number */</span>
    <span class="hljs-keyword">if</span> ( (ppe = getprotobyname(transport)) == <span class="hljs-number">0</span>)
        err_quit(<span class="hljs-string">"can't get /"</span>%s/<span class="hljs-string">" protocol entry/n"</span>, transport);

    <span class="hljs-comment">/* Allocate a common TCP socket */</span>
    s = socket(PF_INET, SOCK_STREAM, ppe-&gt;p_proto);
    <span class="hljs-keyword">if</span> (s &lt; <span class="hljs-number">0</span>)
        err_quit(<span class="hljs-string">"can't create socket: %s/n"</span>, strerror(errno));

    <span class="hljs-keyword">if</span>(bIsHttps != <span class="hljs-number">1</span>){
        <span class="hljs-comment">/* Connect the socket with timeout */</span>
        fcntl(s,F_SETFL, O_NONBLOCK);
        <span class="hljs-keyword">if</span> (connect(s, (<span class="hljs-keyword">struct</span> sockaddr *)&amp;sin, <span class="hljs-keyword">sizeof</span>(sin)) == -<span class="hljs-number">1</span>){
            <span class="hljs-keyword">if</span> (errno == EINPROGRESS){<!-- --><span class="hljs-comment">// it is in the connect process </span>
                <span class="hljs-keyword">struct</span> timeval tv; 
                fd_set writefds; 
                tv.tv_sec = timeout_sec; 
                tv.tv_usec = timeout_microsec; 
                FD_ZERO(&amp;writefds); 
                FD_SET(s, &amp;writefds); 
                <span class="hljs-keyword">if</span>(<span class="hljs-keyword">select</span>(s+<span class="hljs-number">1</span>,NULL,&amp;writefds,NULL,&amp;tv)&gt;<span class="hljs-number">0</span>){ 
                    <span class="hljs-keyword">int</span> len=<span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">int</span>); 
                    <span class="hljs-comment">//下面的一句一定要，主要针对防火墙 </span>
                    getsockopt(s, SOL_SOCKET, SO_ERROR, &amp;errno, &amp;len); 
                    <span class="hljs-keyword">if</span>(errno != <span class="hljs-number">0</span>) 
                        ret = <span class="hljs-number">1</span>;
                    <span class="hljs-keyword">else</span>
                        ret = <span class="hljs-number">0</span>;
                }
                <span class="hljs-keyword">else</span>
                    ret = <span class="hljs-number">2</span>;<span class="hljs-comment">//timeout or error happen </span>
            }
            <span class="hljs-keyword">else</span> ret = <span class="hljs-number">1</span>; 
        }
        <span class="hljs-keyword">else</span>{
            ret = <span class="hljs-number">1</span>;
        }
    }
    <span class="hljs-keyword">else</span>{
        <span class="hljs-comment">/* create common tcp socket.seems non-block type is not supported by ssl. */</span>
        ret = connect(s, (<span class="hljs-keyword">struct</span> sockaddr *)&amp;sin, <span class="hljs-keyword">sizeof</span>(sin));
    }

    <span class="hljs-keyword">if</span>(ret != <span class="hljs-number">0</span>){
        close(s);
        err_quit(<span class="hljs-string">"can't connect to %s:%d/n"</span>, host, port);
    }

    <span class="hljs-keyword">return</span> s;
}

<span class="hljs-comment">/*
s    - SOCKET
sec  - timeout seconds
usec - timeout microseconds
x    - select status
*/</span>
<span class="hljs-keyword">int</span> xnet_select(<span class="hljs-keyword">int</span> s, <span class="hljs-keyword">int</span> sec, <span class="hljs-keyword">int</span> usec, <span class="hljs-keyword">short</span> x){
    <span class="hljs-keyword">int</span> st = errno;
    <span class="hljs-keyword">struct</span> timeval to;
    fd_set fs;
    to.tv_sec = sec;
    to.tv_usec = usec;
    FD_ZERO(&amp;fs);
    FD_SET(s, &amp;fs);
    <span class="hljs-keyword">switch</span>(x){
        <span class="hljs-keyword">case</span> READ_STATUS:
        st = <span class="hljs-keyword">select</span>(s+<span class="hljs-number">1</span>, &amp;fs, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, &amp;to);
        <span class="hljs-keyword">break</span>;
        <span class="hljs-keyword">case</span> WRITE_STATUS:
        st = <span class="hljs-keyword">select</span>(s+<span class="hljs-number">1</span>, <span class="hljs-number">0</span>, &amp;fs, <span class="hljs-number">0</span>, &amp;to);
        <span class="hljs-keyword">break</span>;
        <span class="hljs-keyword">case</span> EXCPT_STATUS:
        st = <span class="hljs-keyword">select</span>(s+<span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, &amp;fs, &amp;to);
        <span class="hljs-keyword">break</span>;
    }
    <span class="hljs-keyword">return</span>(st);
}

<span class="hljs-keyword">void</span> err_doit(<span class="hljs-keyword">int</span> errnoflag, <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *fmt, va_list ap){
    <span class="hljs-keyword">int</span> errno_save;
    <span class="hljs-keyword">char</span> buf[MAX_STRING_LEN];

    errno_save = errno; 
    vsprintf(buf, fmt, ap);
    <span class="hljs-keyword">if</span> (errnoflag)
        sprintf(buf + strlen(buf), <span class="hljs-string">": %s"</span>, strerror(errno_save));
    strcat(buf, <span class="hljs-string">"/n"</span>);
    fflush(stdout);
    fputs(buf, stderr);
    fflush(NULL);
    <span class="hljs-keyword">return</span>;
}

<span class="hljs-comment">/* Print a message and terminate. */</span>
<span class="hljs-keyword">void</span> err_quit(<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *fmt, ...){
    va_list ap;
    va_start(ap, fmt);
    err_doit(<span class="hljs-number">0</span>, fmt, ap);
    va_end(ap);
    exit(<span class="hljs-number">1</span>);
}</code></pre>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/d6097fdf064210ed3f3528cb15dd6d6a/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">直播App测试重点问题 - 服务器压力</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/1926774e597a0bdafd679a1bc335d60a/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">用OpenSSL编写SSL,TLS程序（1）</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>