<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Java集合（五）LinkedHashMap、TreeMap - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Java集合（五）LinkedHashMap、TreeMap" />
<meta property="og:description" content="文章目录 【LinkedHashMap】一、LinkedHashMap介绍1.1 LinkedHashMap特点*1.2 LinkedHashMap的使用 二、从源码理解LinkedHashMap2.1 Entry*2.2 创建LinkedHashMap对象2.3 是否包含某个value2.4 获取元素2.5 清空LinkedHashMap2.6 遍历2.7 添加元素2.8 删除元素 【TreeMap】一、TreeMap介绍1.2 TreeMap的特点*1.2TreeMap的使用 二、从源码理解TreeMap2.1 Entry2.2 创建TreeMap对象2.3 查询数据2.4 添加数据2.5 删除数据 Java集合（一）集合框架概述
Java集合（二）List、ArrayList、LinkedList
Java集合（三）CopyOnWriteArrayList、Vector、Stack
Java集合（四）Map、HashMap
Java集合（五）LinkedHashMap、TreeMap
Java集合（六）Hashtable、ConcurrentHashMap
Java集合（七）Set、HashSet、LinkedHashSet、TreeSet
Java集合（八）BlockingQueue、ArrayBlockingQueue、LinkedBlockingQueue、PriorityBlockingQueue、DelayQueue
【LinkedHashMap】 一、LinkedHashMap介绍 LinkedHashMap是有序版本的HashMap。LinkedHashMap是HashMap的子类，所以LinkedHashMap自然会拥有HashMap的所有特性。同时，HashMap是无序的，即迭代HashMap所得到的元素顺序并不是它们最初添加到HashMap的顺序。而LinkedHashMap可以保证迭代元素的顺序与存入容器的顺序一致。
本质上，HashMap和双向链表合二为一就是LinkedHashMap。更准确地说，它是一个将所有Entry节点链入一个双向链表双向链表的HashMap。
一般来说，如果需要使用的Map中的key无序，选择HashMap；如果要求key有序，则选择TreeMap。但是选择TreeMap会有性能问题，因为TreeMap的get操作的时间复杂度是O(log(n))的，相比于HashMap的O(1)还是差不少的，LinkedHashMap的出现就是为了平衡这些因素，使得能够以 O(1)时间复杂度增加查找元素，又能够保证key的有序性。
在HashMap有一些空方法，比如：
void afterNodeAccess(Node&lt;K,V&gt; p) { } void afterNodeInsertion(boolean evict) { } void afterNodeRemoval(Node&lt;K,V&gt; p) { } LinkedHashMap重写了这些方法，用来保持列表的有序。
关于LinkedHashMap和HashMap结构上的差异，如下图所示。
HashMap的结构
LinkedHashMap的结构
LinkedHashMap的底层实现：将所有Entry节点链入一个双向链表的HashMap。在LinkedHashMap中，所有put进来的Entry都保存在哈希表中，但由于它又额外定义了一个以head为头结点的双向链表，因此对于每次put进来Entry，除了将其保存到哈希表上外，还会将其插入到双向链表的尾部。 1.1 LinkedHashMap特点* 1、由于继承HashMap类，所以默认初始容量是16，加载因子是0.75。2、线程不安全。3、具有fail-fast的特征。4、底层使用双向链表，可以保存元素的插入顺序，顺序有两种方式：一种是按照插入顺序排序，一种按照访问顺序做排序(可以做LRU策略的实现类)。默认以插入顺序排序。5、key和value允许为null，key重复时，新value覆盖旧value，即：最多只允许一条Entry的键为null。6、可以用来实现LRU算法。7、LinkedHashMap与HashMap的存取数据操作基本是一致的，只是增加了双向链表保证数据的有序性。8、LinkedHashMap继承HashMap，基于HashMap&#43;双向链表实现。（HashMap是数组&#43;链表&#43;红黑树实现的）。 1.2 LinkedHashMap的使用 由于LinkedHashMap继承自HashMap，所以HashMap有的方法LinkedHashMap也有，特殊的在于LinkedHashMap中有序性的选择。
因为LinkedHashMap元素的有序性可分为插入顺序性和访问顺序性，所以可以在创建对象时，指定选择哪种顺序。accessOrder为false时，基于插入顺序；accessOrder为true时，基于访问顺序。
public LinkedHashMap(int initialCapacity, float loadFactor, boolean accessOrder) 二、从源码理解LinkedHashMap 2." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/776029c5d7d2773438f1c322b2fa29ef/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2024-01-26T20:26:06+08:00" />
<meta property="article:modified_time" content="2024-01-26T20:26:06+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Java集合（五）LinkedHashMap、TreeMap</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p></p> 
<div class="toc"> 
 <h4>文章目录</h4> 
 <ul><li><a href="#LinkedHashMap_13" rel="nofollow">【LinkedHashMap】</a></li><li><ul><li><a href="#LinkedHashMap_14" rel="nofollow">一、LinkedHashMap介绍</a></li><li><ul><li><a href="#11_LinkedHashMap_33" rel="nofollow">1.1 LinkedHashMap特点*</a></li><li><a href="#12_LinkedHashMap_42" rel="nofollow">1.2 LinkedHashMap的使用</a></li></ul> 
   </li><li><a href="#LinkedHashMap_48" rel="nofollow">二、从源码理解LinkedHashMap</a></li><li><ul><li><a href="#21_Entry_49" rel="nofollow">2.1 Entry*</a></li><li><a href="#22_LinkedHashMap_74" rel="nofollow">2.2 创建LinkedHashMap对象</a></li><li><a href="#23_value_93" rel="nofollow">2.3 是否包含某个value</a></li><li><a href="#24__106" rel="nofollow">2.4 获取元素</a></li><li><a href="#25_LinkedHashMap_163" rel="nofollow">2.5 清空LinkedHashMap</a></li><li><a href="#26__171" rel="nofollow">2.6 遍历</a></li><li><a href="#27__236" rel="nofollow">2.7 添加元素</a></li><li><a href="#28__295" rel="nofollow">2.8 删除元素</a></li></ul> 
  </li></ul> 
  </li><li><a href="#TreeMap_316" rel="nofollow">【TreeMap】</a></li><li><ul><li><a href="#TreeMap_317" rel="nofollow">一、TreeMap介绍</a></li><li><ul><li><a href="#12_TreeMap_361" rel="nofollow">1.2 TreeMap的特点*</a></li><li><a href="#12TreeMap_368" rel="nofollow">1.2TreeMap的使用</a></li></ul> 
   </li><li><a href="#TreeMap_441" rel="nofollow">二、从源码理解TreeMap</a></li><li><ul><li><a href="#21_Entry_453" rel="nofollow">2.1 Entry</a></li><li><a href="#22_TreeMap_476" rel="nofollow">2.2 创建TreeMap对象</a></li><li><a href="#23__485" rel="nofollow">2.3 查询数据</a></li><li><a href="#24__551" rel="nofollow">2.4 添加数据</a></li><li><a href="#25__802" rel="nofollow">2.5 删除数据</a></li></ul> 
  </li></ul> 
 </li></ul> 
</div> 
<p></p> 
<p>    <a href="https://blog.csdn.net/m0_37741420/article/details/106884159" title="With a Title">Java集合（一）集合框架概述</a><br>     <a href="https://blog.csdn.net/m0_37741420/article/details/107013695" title="With a Title">Java集合（二）List、ArrayList、LinkedList</a><br>     <a href="https://blog.csdn.net/m0_37741420/article/details/107032686" title="With a Title">Java集合（三）CopyOnWriteArrayList、Vector、Stack</a><br>     <a href="https://blog.csdn.net/m0_37741420/article/details/112424663" title="With a Title">Java集合（四）Map、HashMap</a><br>     Java集合（五）LinkedHashMap、TreeMap<br>     <a href="https://blog.csdn.net/m0_37741420/article/details/135028798" title="With a Title">Java集合（六）Hashtable、ConcurrentHashMap</a><br>     <a href="https://blog.csdn.net/m0_37741420/article/details/112407684" title="With a Title">Java集合（七）Set、HashSet、LinkedHashSet、TreeSet</a><br>     <a href="https://blog.csdn.net/m0_37741420/article/details/120335698" title="With a Title">Java集合（八）BlockingQueue、ArrayBlockingQueue、LinkedBlockingQueue、PriorityBlockingQueue、DelayQueue</a></p> 
<h2><a id="LinkedHashMap_13"></a>【LinkedHashMap】</h2> 
<h3><a id="LinkedHashMap_14"></a>一、LinkedHashMap介绍</h3> 
<p>  LinkedHashMap是有序版本的HashMap。LinkedHashMap是HashMap的子类，所以LinkedHashMap自然会拥有HashMap的所有特性。同时，HashMap是无序的，即迭代HashMap所得到的元素顺序并不是它们最初添加到HashMap的顺序。而<code>LinkedHashMap可以保证迭代元素的顺序与存入容器的顺序一致</code>。<br>   本质上，HashMap和双向链表合二为一就是LinkedHashMap。更准确地说，它是一个将所有Entry节点链入一个双向链表双向链表的HashMap。</p> 
<p>  一般来说，如果需要使用的Map中的key无序，选择HashMap；如果要求key有序，则选择TreeMap。但是选择TreeMap会有性能问题，因为TreeMap的get操作的时间复杂度是O(log(n))的，相比于HashMap的O(1)还是差不少的，LinkedHashMap的出现就是为了平衡这些因素，使得能够以 O(1)时间复杂度增加查找元素，又能够保证key的有序性。</p> 
<p>  在HashMap有一些空方法，比如：</p> 
<pre><code class="prism language-java">    <span class="token keyword">void</span> <span class="token function">afterNodeAccess</span><span class="token punctuation">(</span><span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span> p<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span> <span class="token punctuation">}</span>
    <span class="token keyword">void</span> <span class="token function">afterNodeInsertion</span><span class="token punctuation">(</span><span class="token keyword">boolean</span> evict<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span> <span class="token punctuation">}</span>
    <span class="token keyword">void</span> <span class="token function">afterNodeRemoval</span><span class="token punctuation">(</span><span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span> p<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span> <span class="token punctuation">}</span>
</code></pre> 
<p>  LinkedHashMap重写了这些方法，用来保持列表的有序。<br>   关于LinkedHashMap和HashMap结构上的差异，如下图所示。</p> 
<ul><li><strong>HashMap的结构</strong><br> <img src="https://images2.imgbox.com/0d/c6/i2WDnYcT_o.png" alt=""></li><li><strong>LinkedHashMap的结构</strong><br> <img src="https://images2.imgbox.com/21/9b/HKBVKHNM_o.png" alt=""><br>   LinkedHashMap的底层实现：将所有Entry节点链入一个双向链表的HashMap。在LinkedHashMap中，所有put进来的Entry都保存在哈希表中，但由于它又额外定义了一个以head为头结点的双向链表，因此对于每次put进来Entry，除了将其保存到哈希表上外，还会将其插入到双向链表的尾部。</li></ul> 
<h4><a id="11_LinkedHashMap_33"></a>1.1 LinkedHashMap特点*</h4> 
<ul><li>1、由于继承HashMap类，所以默认初始容量是16，加载因子是0.75。</li><li>2、线程不安全。</li><li>3、具有fail-fast的特征。</li><li>4、底层使用双向链表，可以保存元素的插入顺序，顺序有两种方式：一种是按照插入顺序排序，一种按照访问顺序做排序(可以做LRU策略的实现类)。默认以插入顺序排序。</li><li>5、key和value允许为null，key重复时，新value覆盖旧value，即：最多只允许一条Entry的键为null。</li><li>6、可以用来实现LRU算法。</li><li>7、LinkedHashMap与HashMap的存取数据操作基本是一致的，只是增加了双向链表保证数据的有序性。</li><li>8、LinkedHashMap继承HashMap，基于HashMap+双向链表实现。（HashMap是数组+链表+红黑树实现的）。</li></ul> 
<h4><a id="12_LinkedHashMap_42"></a>1.2 LinkedHashMap的使用</h4> 
<p>  由于LinkedHashMap继承自HashMap，所以HashMap有的方法LinkedHashMap也有，特殊的在于LinkedHashMap中有序性的选择。<br>   因为LinkedHashMap元素的有序性可分为插入顺序性和访问顺序性，所以可以在创建对象时，指定选择哪种顺序。accessOrder为false时，基于插入顺序；accessOrder为true时，基于访问顺序。</p> 
<pre><code class="prism language-java">	<span class="token keyword">public</span> <span class="token class-name">LinkedHashMap</span><span class="token punctuation">(</span><span class="token keyword">int</span> initialCapacity<span class="token punctuation">,</span> <span class="token keyword">float</span> loadFactor<span class="token punctuation">,</span> <span class="token keyword">boolean</span> accessOrder<span class="token punctuation">)</span>
</code></pre> 
<h3><a id="LinkedHashMap_48"></a>二、从源码理解LinkedHashMap</h3> 
<h4><a id="21_Entry_49"></a>2.1 Entry*</h4> 
<p>  LinkedHashMap中存储的节点：</p> 
<pre><code class="prism language-java">    <span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">Entry</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span> <span class="token keyword">extends</span> <span class="token class-name">HashMap<span class="token punctuation">.</span>Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span> <span class="token punctuation">{<!-- --></span>
        <span class="token class-name">Entry</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span> before<span class="token punctuation">,</span> after<span class="token punctuation">;</span>
        <span class="token class-name">Entry</span><span class="token punctuation">(</span><span class="token keyword">int</span> hash<span class="token punctuation">,</span> <span class="token class-name">K</span> key<span class="token punctuation">,</span> <span class="token class-name">V</span> value<span class="token punctuation">,</span> <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span> next<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
            <span class="token keyword">super</span><span class="token punctuation">(</span>hash<span class="token punctuation">,</span> key<span class="token punctuation">,</span> value<span class="token punctuation">,</span> next<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
</code></pre> 
<p>  LinkedHashMap中的节点Entry，相比于HashMap中的节点Node，多了指向前后位置的节点before和after，用于维护双向链表。<br>   HashMap与LinkedHashMap的Entry结构示意图：<br> <img src="https://images2.imgbox.com/b2/af/bBXVHdrT_o.png" alt=""><br>   LinkedHashMap中的变量：</p> 
<pre><code class="prism language-java">	<span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">long</span> serialVersionUID <span class="token operator">=</span> <span class="token number">3801124242820219131L</span><span class="token punctuation">;</span>
	<span class="token comment">//头结点</span>
	<span class="token keyword">transient</span> <span class="token class-name">LinkedHashMap<span class="token punctuation">.</span>Entry</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span> head<span class="token punctuation">;</span>
	<span class="token comment">//尾节点</span>
	<span class="token keyword">transient</span> <span class="token class-name">LinkedHashMap<span class="token punctuation">.</span>Entry</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span> tail<span class="token punctuation">;</span>
	<span class="token comment">//这个变量决定链表元素的存储方式，false按照存储顺序存储，true表示按照访问顺序</span>
	<span class="token comment">//存储（将最近访问的元素移动到尾部），该变量和LRU算法相关 </span>
	<span class="token keyword">final</span> <span class="token keyword">boolean</span> accessOrder<span class="token punctuation">;</span>
</code></pre> 
<p>  accessOrder默认为false，表示按照插入顺序访问。</p> 
<h4><a id="22_LinkedHashMap_74"></a>2.2 创建LinkedHashMap对象</h4> 
<p>  LinkedHashMap和HashMap的构造方法类似，不过多了accessOrder属性，默认为false，该属性可以手动指定。</p> 
<pre><code class="prism language-java">	<span class="token comment">//指定初始容量与负载因子</span>
	<span class="token comment">//默认访问顺序标识为false，表示按照插入顺序存储</span>
    <span class="token keyword">public</span> <span class="token class-name">LinkedHashMap</span><span class="token punctuation">(</span><span class="token keyword">int</span> initialCapacity<span class="token punctuation">,</span> <span class="token keyword">float</span> loadFactor<span class="token punctuation">)</span> 

	<span class="token comment">//指定初始容量，负载因子为0.75</span>
	<span class="token comment">//默认访问顺序标识为false，表示按照插入顺序存储</span>
    <span class="token keyword">public</span> <span class="token class-name">LinkedHashMap</span><span class="token punctuation">(</span><span class="token keyword">int</span> initialCapacity<span class="token punctuation">)</span> 

	<span class="token comment">//默认初始容量(16)和负载因子(0.75)</span>
	<span class="token comment">//默认访问顺序标识为false，表示按照存储顺序存储</span>
    <span class="token keyword">public</span> <span class="token class-name">LinkedHashMap</span><span class="token punctuation">(</span><span class="token punctuation">)</span> 

	<span class="token comment">//指定初始容量与负载因子</span>
	<span class="token comment">//指定默认访问顺序标识</span>
    <span class="token keyword">public</span> <span class="token class-name">LinkedHashMap</span><span class="token punctuation">(</span><span class="token keyword">int</span> initialCapacity<span class="token punctuation">,</span> <span class="token keyword">float</span> loadFactor<span class="token punctuation">,</span> <span class="token keyword">boolean</span> accessOrder<span class="token punctuation">)</span>
</code></pre> 
<h4><a id="23_value_93"></a>2.3 是否包含某个value</h4> 
<p>  在HashMap中，判断一个value是否在容易中，是按数组的方式从头到尾遍历的。LinkedHashMap实现了链表的顺序结构，就用了链表的方式从头到尾遍历</p> 
<pre><code class="prism language-java">    <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">containsValue</span><span class="token punctuation">(</span><span class="token class-name">Object</span> value<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    	<span class="token comment">//从向前后进行遍历</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token class-name">LinkedHashMap<span class="token punctuation">.</span>Entry</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span> e <span class="token operator">=</span> head<span class="token punctuation">;</span> e <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">;</span> e <span class="token operator">=</span> e<span class="token punctuation">.</span>after<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
            <span class="token class-name">V</span> v <span class="token operator">=</span> e<span class="token punctuation">.</span>value<span class="token punctuation">;</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>v <span class="token operator">==</span> value <span class="token operator">||</span> <span class="token punctuation">(</span>value <span class="token operator">!=</span> <span class="token keyword">null</span> <span class="token operator">&amp;&amp;</span> value<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>v<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
                <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
</code></pre> 
<h4><a id="24__106"></a>2.4 获取元素</h4> 
<p>和HashMap类似，获取容器中一个元素的方式有get、getOrDefault两种，获取元素的方式也一致。不同的是，如果LinkedHashMap指定了访问顺序的话，就要将获取的元素放在链表尾部。</p> 
<pre><code class="prism language-java">    <span class="token keyword">public</span> <span class="token class-name">V</span> <span class="token function">get</span><span class="token punctuation">(</span><span class="token class-name">Object</span> key<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span> e<span class="token punctuation">;</span>
        <span class="token comment">//第一步是直接使用HashMap中的函数getNode方法，获取value，如果为null，返回null</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>e <span class="token operator">=</span> <span class="token function">getNode</span><span class="token punctuation">(</span><span class="token function">hash</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">,</span> key<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span>
            <span class="token keyword">return</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>accessOrder<span class="token punctuation">)</span>
        	<span class="token comment">//将添加的元素移动到链表的尾端</span>
            <span class="token function">afterNodeAccess</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span> e<span class="token punctuation">.</span>value<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

	<span class="token comment">//将访问的这个元素移动到双向链表的尾端，并且将他的后面的元素向前移动</span>
	<span class="token keyword">void</span> <span class="token function">afterNodeAccess</span><span class="token punctuation">(</span><span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span> e<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token comment">//last为原链表的尾节点</span>
        <span class="token class-name">LinkedHashMapEntry</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span> last<span class="token punctuation">;</span>
        <span class="token comment">//如果accessOrder为true，并且尾端元素不是需要访问的元素</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>accessOrder <span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span>last <span class="token operator">=</span> tail<span class="token punctuation">)</span> <span class="token operator">!=</span> e<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
            <span class="token comment">//将节点e强制转换成linkedHashMapEntry,b为这个节点的前一个</span>
            <span class="token comment">//节点，a为它的后一个节点</span>
            <span class="token class-name">LinkedHashMapEntry</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span> p <span class="token operator">=</span>
                <span class="token punctuation">(</span><span class="token class-name">LinkedHashMapEntry</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">)</span>e<span class="token punctuation">,</span> b <span class="token operator">=</span> p<span class="token punctuation">.</span>before<span class="token punctuation">,</span> a <span class="token operator">=</span> p<span class="token punctuation">.</span>after<span class="token punctuation">;</span>
            
            <span class="token comment">//p为最后一个元素，那么他的后置节点必定是空</span>
            p<span class="token punctuation">.</span>after <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
            <span class="token comment">//b为e的前置元素，如果b为空，说明此元素必定是链表的第一个元素，更新之后</span>
            <span class="token comment">//链表的头结点已经变成尾节点，那么原链表的第二个节点就要变为头结点</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>b <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span>
                head <span class="token operator">=</span> a<span class="token punctuation">;</span>
            <span class="token keyword">else</span>
                <span class="token comment">//如果b不是空，那么b的后置节点就由p变为p的后置节点</span>
                b<span class="token punctuation">.</span>after <span class="token operator">=</span> a<span class="token punctuation">;</span>
 
            <span class="token comment">//如果p的后置节点不为空，那么更新后置节点a的前置节点为b</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>a <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span>
                a<span class="token punctuation">.</span>before <span class="token operator">=</span> b<span class="token punctuation">;</span>
            <span class="token keyword">else</span>
            <span class="token comment">//如果p的后置节点为空，那么p就是尾节点，那么更新last的节点为p的前置节点</span>
                last <span class="token operator">=</span> b<span class="token punctuation">;</span>
            <span class="token comment">//如果原来的尾节点为空，那么原链表就只有一个元素</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>last <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span>
                head <span class="token operator">=</span> p<span class="token punctuation">;</span>
            <span class="token keyword">else</span> <span class="token punctuation">{<!-- --></span>
            <span class="token comment">//更新当前节点p的前置节点为 原尾节点last， last的后置节点是p</span>
                p<span class="token punctuation">.</span>before <span class="token operator">=</span> last<span class="token punctuation">;</span>
                last<span class="token punctuation">.</span>after <span class="token operator">=</span> p<span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
 
            <span class="token comment">//p为最新的尾节点</span>
            tail <span class="token operator">=</span> p<span class="token punctuation">;</span>
            <span class="token operator">++</span>modCount<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
</code></pre> 
<p>  这里需要注意两点：一是调用次函数之后，访问的这个元素会移动到双向链表的尾端，二是在accessOrder=true的模式下，迭代LinkedHashMap时，如果同时查询（get）访问数据，也会导致fail-fast，因为迭代的顺序已经改变。</p> 
<h4><a id="25_LinkedHashMap_163"></a>2.5 清空LinkedHashMap</h4> 
<p>  调用了父类HashMap的clear方法（作用是：把数组中所有元素都置为null），并将头尾节点都置为null。</p> 
<pre><code class="prism language-java">    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">clear</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token keyword">super</span><span class="token punctuation">.</span><span class="token function">clear</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        head <span class="token operator">=</span> tail <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
</code></pre> 
<h4><a id="26__171"></a>2.6 遍历</h4> 
<p>  因为LinkedHashMap中的Entry节点和父类HashMap中的Node节点不同，所以重写了遍历容器中元素的相关方法。在这些方法里都用到了自己实现的迭代器LinkedHashIterator。</p> 
<pre><code class="prism language-java">	<span class="token comment">//获取key集合</span>
	<span class="token keyword">public</span> <span class="token class-name">Set</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">&gt;</span></span> <span class="token function">keySet</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
	<span class="token comment">//获取value集合</span>
	<span class="token keyword">public</span> <span class="token class-name">Collection</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span> <span class="token function">values</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
	<span class="token comment">//获取Entry集合</span>
	<span class="token keyword">public</span> <span class="token class-name">Set</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Map<span class="token punctuation">.</span>Entry</span><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span><span class="token punctuation">&gt;</span></span> <span class="token function">entrySet</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
</code></pre> 
<p>  LinkedHashMap中的核心迭代器就是LinkedHashIterator，也实现了fail-fast机制。</p> 
<pre><code class="prism language-java"> <span class="token keyword">abstract</span> <span class="token keyword">class</span> <span class="token class-name">LinkedHashIterator</span> <span class="token punctuation">{<!-- --></span>
        <span class="token comment">//下一个节点</span>
        <span class="token class-name">LinkedHashMapEntry</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span> next<span class="token punctuation">;</span>
        <span class="token comment">//当前节点</span>
        <span class="token class-name">LinkedHashMapEntry</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span> current<span class="token punctuation">;</span>
        <span class="token keyword">int</span> expectedModCount<span class="token punctuation">;</span>
 
        <span class="token class-name">LinkedHashIterator</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
            <span class="token comment">//初始化的时候将next指向双向链表的头结点</span>
            next <span class="token operator">=</span> head<span class="token punctuation">;</span>
            expectedModCount <span class="token operator">=</span> modCount<span class="token punctuation">;</span>
            <span class="token comment">//current为空</span>
            current <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
 
        <span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">boolean</span> <span class="token function">hasNext</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
            <span class="token keyword">return</span> next <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
 
        <span class="token comment">//nextNode方法就是我们用到的next方法，</span>
        <span class="token comment">//迭代LinkedHashMap，就是从内部维护的双链表的表头开始循环输出</span>
        <span class="token keyword">final</span> <span class="token class-name">LinkedHashMapEntry</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span> <span class="token function">nextNode</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        	<span class="token comment">//记录要返回的e</span>
            <span class="token class-name">LinkedHashMapEntry</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span> e <span class="token operator">=</span> next<span class="token punctuation">;</span>
            <span class="token comment">//fail-fast判断</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>modCount <span class="token operator">!=</span> expectedModCount<span class="token punctuation">)</span>
                <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">ConcurrentModificationException</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token comment">//如果返回的是空，则抛出异常</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>e <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span>
                <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">NoSuchElementException</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token comment">//更新当前节点为e</span>
            current <span class="token operator">=</span> e<span class="token punctuation">;</span>
            <span class="token comment">//更新下一个节点是e的后置节点</span>
            next <span class="token operator">=</span> e<span class="token punctuation">.</span>after<span class="token punctuation">;</span>
            <span class="token keyword">return</span> e<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
 
        <span class="token comment">//删除方法，就直接使用了hashmap的remove</span>
        <span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">void</span> <span class="token function">remove</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
            <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span> p <span class="token operator">=</span> current<span class="token punctuation">;</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>p <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span>
                <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">IllegalStateException</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>modCount <span class="token operator">!=</span> expectedModCount<span class="token punctuation">)</span>
                <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">ConcurrentModificationException</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            current <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
            <span class="token class-name">K</span> key <span class="token operator">=</span> p<span class="token punctuation">.</span>key<span class="token punctuation">;</span>
            <span class="token function">removeNode</span><span class="token punctuation">(</span><span class="token function">hash</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">,</span> key<span class="token punctuation">,</span> <span class="token keyword">null</span><span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            expectedModCount <span class="token operator">=</span> modCount<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
</code></pre> 
<p>  LinkedHashMap的迭代器遍历只提供了单向访问，即按照插入的顺序从头到尾进行访问，不能像LinkedList那样进行双向访问。<br>   在新增节点时，已经维护了元素之间的插入顺序了，所以在迭代访问时只需要不断的访问当前节点的下一个节点即可。</p> 
<h4><a id="27__236"></a>2.7 添加元素</h4> 
<p>  由于LinkedHashMap是HashMap的子类，添加元素是通过调用父类的putVal来完成的。在HashMap的putVal方法中，有调用<code>newNode(hash, key, value, null)</code>方法来创建节点的操作。</p> 
<blockquote> 
 <p>LinkedHashMap通过newNode/newTreeNode方法进行节点新增。</p> 
</blockquote> 
<p>  LinkedHashMap重写的newNode方法：</p> 
<pre><code class="prism language-java">	 <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span> <span class="token function">newNode</span><span class="token punctuation">(</span><span class="token keyword">int</span> hash<span class="token punctuation">,</span> <span class="token class-name">K</span> key<span class="token punctuation">,</span> <span class="token class-name">V</span> value<span class="token punctuation">,</span> <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span> e<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token class-name">LinkedHashMap<span class="token punctuation">.</span>Entry</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span> p <span class="token operator">=</span>
            <span class="token keyword">new</span> <span class="token class-name">LinkedHashMap<span class="token punctuation">.</span>Entry</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span>hash<span class="token punctuation">,</span> key<span class="token punctuation">,</span> value<span class="token punctuation">,</span> e<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">// 将新建的节点添加到双向链表的尾部</span>
        <span class="token function">linkNodeLast</span><span class="token punctuation">(</span>p<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span> p<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token comment">//在双向链表的尾部添加新建的节点</span>
    <span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">linkNodeLast</span><span class="token punctuation">(</span><span class="token class-name">LinkedHashMap<span class="token punctuation">.</span>Entry</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span> p<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token class-name">LinkedHashMap<span class="token punctuation">.</span>Entry</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span> last <span class="token operator">=</span> tail<span class="token punctuation">;</span>
       <span class="token comment">// p为新的需要追加的结点</span>
        tail <span class="token operator">=</span> p<span class="token punctuation">;</span>
        <span class="token comment">// 如果last为null.则表示现在链表为空。新new出来的p元素就是链表的头结点</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>last <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span>
            head <span class="token operator">=</span> p<span class="token punctuation">;</span>
        <span class="token comment">// 否则就是链表中已存在结点的情况：往尾部添加即可</span>
        <span class="token keyword">else</span> <span class="token punctuation">{<!-- --></span>
        	<span class="token comment">// 把新追加p的结点的前驱结点设置之前的尾部结点</span>
        	<span class="token comment">// 把之前的尾部结点的后驱结点设为新追加的p结点</span>
            p<span class="token punctuation">.</span>before <span class="token operator">=</span> last<span class="token punctuation">;</span>
            last<span class="token punctuation">.</span>after <span class="token operator">=</span> p<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
	<span class="token punctuation">}</span>
</code></pre> 
<p>  可以看出LinkedHashMap的在新建一个结点的时候，做了两件事：<br>    1）新建结点，并放入到对应的hash桶位置。<br>    2）将新建的结点追加到双向链表的尾部。</p> 
<p>  结合构造方法来看的话：LinkedHashMap初始化时，accessOrder为false，就会按照插入顺序提供访问，插入方法使用的是父类HashMap的put方法，不过覆写了put方法，执行中调用的是newNode/newTreeNode和afterNodeAccess 方法。<br>   LinkedHashMap通过新增头节点、尾节点，给每个节点增加before、after 属性。每次新增时，都把节点追加到尾节点，这样就可以保证新增节点是按照顺序插入到链表中的。</p> 
<p>  LinkedHashMap的没有自己的put方法的实现,而是使用父类HashMap的put方法:在正常新增之后,调用afterNodeAccess(e)和 afterNodeInsertion(evict)让LinkedHashMap自己做后续处理：</p> 
<pre><code class="prism language-java">	<span class="token comment">//回调函数，新节点插入之后回调 ， 根据evict判断是否需要删除最老插入的节点。</span>
    <span class="token keyword">void</span> <span class="token function">afterNodeInsertion</span><span class="token punctuation">(</span><span class="token keyword">boolean</span> evict<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token class-name">LinkedHashMap<span class="token punctuation">.</span>Entry</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span> first<span class="token punctuation">;</span>
        <span class="token comment">//LinkedHashMap 默认返回false 则不删除节点</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>evict <span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span>first <span class="token operator">=</span> head<span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token keyword">null</span> <span class="token operator">&amp;&amp;</span> <span class="token function">removeEldestEntry</span><span class="token punctuation">(</span>first<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
            <span class="token class-name">K</span> key <span class="token operator">=</span> first<span class="token punctuation">.</span>key<span class="token punctuation">;</span>
            <span class="token function">removeNode</span><span class="token punctuation">(</span><span class="token function">hash</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">,</span> key<span class="token punctuation">,</span> <span class="token keyword">null</span><span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">,</span> <span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
    <span class="token comment">//移动访问的节点到链表末端（该方法在get小节已详细介绍过）</span>
	<span class="token keyword">void</span> <span class="token function">afterNodeAccess</span><span class="token punctuation">(</span><span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span> e<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
		<span class="token comment">//省略代码....</span>
    <span class="token punctuation">}</span>

    <span class="token comment">//LinkedHashMap 默认返回false 则不删除节点。 返回true 代表要删除最早的节点。通常构建一个LruCache会在达到Cache的上限是返回true</span>
    <span class="token keyword">protected</span> <span class="token keyword">boolean</span> <span class="token function">removeEldestEntry</span><span class="token punctuation">(</span><span class="token class-name">Map<span class="token punctuation">.</span>Entry</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span> eldest<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
</code></pre> 
<h4><a id="28__295"></a>2.8 删除元素</h4> 
<p>  LinkedHashMap删除元素时，也是通过调用父类的方法来实现的。LinkedHashMap在删除元素时，会调用到自己重写的afterNodeRemoval方法：</p> 
<pre><code class="prism language-java"> 	<span class="token comment">//在删除节点e时，同步将e从双向链表上删除</span>
    <span class="token keyword">void</span> <span class="token function">afterNodeRemoval</span><span class="token punctuation">(</span><span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span> e<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span> <span class="token comment">// unlink</span>
        <span class="token class-name">LinkedHashMap<span class="token punctuation">.</span>Entry</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span> p <span class="token operator">=</span>
            <span class="token punctuation">(</span><span class="token class-name">LinkedHashMap<span class="token punctuation">.</span>Entry</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">)</span>e<span class="token punctuation">,</span> b <span class="token operator">=</span> p<span class="token punctuation">.</span>before<span class="token punctuation">,</span> a <span class="token operator">=</span> p<span class="token punctuation">.</span>after<span class="token punctuation">;</span>
        <span class="token comment">//待删除节点 p 的前置后置节点都置空</span>
        p<span class="token punctuation">.</span>before <span class="token operator">=</span> p<span class="token punctuation">.</span>after <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
        <span class="token comment">//如果前置节点是null，则现在的头结点应该是后置节点a</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>b <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span>
            head <span class="token operator">=</span> a<span class="token punctuation">;</span>
        <span class="token keyword">else</span><span class="token comment">//否则将前置节点b的后置节点指向a</span>
            b<span class="token punctuation">.</span>after <span class="token operator">=</span> a<span class="token punctuation">;</span>
        <span class="token comment">//同理如果后置节点时null ，则尾节点应是b</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>a <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span>
            tail <span class="token operator">=</span> b<span class="token punctuation">;</span>
        <span class="token keyword">else</span><span class="token comment">//否则更新后置节点a的前置节点为b</span>
            a<span class="token punctuation">.</span>before <span class="token operator">=</span> b<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
</code></pre> 
<h2><a id="TreeMap_316"></a>【TreeMap】</h2> 
<h3><a id="TreeMap_317"></a>一、TreeMap介绍</h3> 
<p>  TreeMap是一个能比较元素大小的Map容器，会对传入的key进行了大小排序。可以使用元素的自然顺序，也可以使用集合中自定义的比较器来进行排序。TreeMap是一个通过红黑树实现有序的K-V集合。<br>   对于TreeMap而言，由于它底层采用一棵”红黑树”来保存集合中的Entry，这意味这TreeMap添加元素、取出元素的性能都比HashMap低。当向TreeMap中添加元素时，需要通过循环找到新增Entry的插入位置，因此比较耗性能；当从TreeMap中取出元素时，需要通过循环才能找到合适的Entry，也比较耗性能。<br>   TreeMap比HashMap的优势在于：TreeSet 中所有元素总是根据key的某种指定排序规则保持有序状态。<br>   TreeMap底层基于红黑树实现，可保证在log(n)时间复杂度内完成containsKey、get、put 和 remove 操作，<code>效率很高</code>。<br>   TreeMap的核心是红黑树，其很多方法也是对红黑树增删查基础操作的一个包装。</p> 
<p>  为了理解TreeMap的底层实现，需要先了解排序二叉树和红黑树这两种数据结构。其中红黑树又是一种特殊的排序二叉树。排序二叉树是一种特殊结构的二叉树，可以非常方便地对树中所有节点进行排序和检索。</p> 
<ul><li><strong>排序二叉树/二叉查找树</strong><br>   排序二叉树要么是一棵空二叉树，要么是具有下列性质的二叉树：</li></ul> 
<blockquote> 
 <ol><li>若它的左子树不空，则左子树上所有节点的值均小于它的根节点的值；</li><li>若它的右子树不空，则右子树上所有节点的值均大于它的根节点的值；</li><li>它的左、右子树也分别为排序二叉树。</li></ol> 
</blockquote> 
<p><img src="https://images2.imgbox.com/3b/1b/Qxi0TCRu_o.png" alt=""><br>   对排序二叉树，若按中序遍历就可以得到由小到大的有序序列。如上图所示二叉树，中序遍历得：<code>{2，3，4，8，9，9，10，13，15，18}</code>。<br>   创建排序二叉树的步骤，也就是不断地向排序二叉树添加节点的过程，向排序二叉树添加节点的步骤：</p> 
<blockquote> 
 <ol><li>以根节点当前节点开始搜索。</li><li>拿新节点的值和当前节点的值比较。</li><li>如果新节点的值更大，则以当前节点的右子节点作为新的当前节点；如果新节点的值更小，则以当前节点的左子节点作为新的当前节点。</li><li>重复 2、3 两个步骤，直到搜索到合适的叶子节点为止。</li><li>将新节点添加为第 4 步找到的叶子节点的子节点；如果新节点更大，则添加为右子节点；否则添加为左子节点。</li></ol> 
</blockquote> 
<ul><li><strong>红黑树</strong><br>   红黑树是一种自平衡二叉查找树。所谓的平衡树是指一种改进的二叉查找树，顾名思义平衡树就是将二叉查找树平衡均匀地分布，这样的好处就是可以减少二叉查找树的深度。<br>   一般情况下二叉查找树的查询复杂度取决于目标节点到树根的距离（即深度），当节点的深度普遍较大时，查询的平均复杂度就会上升，因此为了实现更高效的查询就有了平衡树。<br>   非平衡二叉树：<br> <img src="https://images2.imgbox.com/0b/4e/V64hSjrK_o.png" alt=""><br>   平衡二叉树：<br> <img src="https://images2.imgbox.com/87/56/zXAf3Obz_o.png" alt=""><br>   可以看出使用平衡二叉树可以有效的减少二叉树的深度，从而提高了查询的效率。<br>   红黑树除了具备二叉查找树的基本特性之外，还具备以下特性：</li></ul> 
<blockquote> 
 <ol><li>节点是红色或黑色；</li><li>根节点是黑色；</li><li>所有叶子都是黑色的空节点（NIL 节点）；</li><li>每个红色节点必须有两个黑色的子节点，也就是说从每个叶子到根的所有路径上，不能有两个连续的红色节点；</li><li>从一个节点到该节点的子孙节点的所有路径上包含相同数目的黑色节点。</li></ol> 
</blockquote> 
<p>  红黑树结构：<br> <img src="https://images2.imgbox.com/16/08/FlbGQ2xm_o.png" alt=""><br>   红黑树的优势在于它是一个平衡二叉查找树，对于普通的二叉查找树（非平衡二叉查找树）在极端情况下可能会退化为链表的结构，例如，当我们依次插入 3、4、5、6、7、8 这些数据时，二叉树会退化为如下链表结构：<br> <img src="https://images2.imgbox.com/0a/79/or1d21aJ_o.png" alt=""><br>   当二叉查找树退化为链表数据结构后，再进行元素的添加、删除以及查询时，它的时间复杂度就会退化为 O(n)；而如果使用红黑树的话，它就会将以上数据转化为平衡二叉查找树，这样就可以更加高效的添加、删除以及查询数据了，这就是红黑树的优势。<br>   红黑树高度依然是平均log(n)，且最坏情况高度不会超过2log(n)。它的添加、删除以及查询数据的时间复杂度为O(logn)。</p> 
<h4><a id="12_TreeMap_361"></a>1.2 TreeMap的特点*</h4> 
<ul><li>1、TreeMap默认会对键进行排序，根据键的自然顺序进行（升序）排序或根据提供的Comparator进行排序。</li><li>2、TreeMap底层使用的数据结构是二叉树。</li><li>3、TreeMap是线程不安全的。</li><li>4、 TreeMap的key不能为null。</li><li>5、TreeMap的查询、插入、删除效率均没有HashMap高，一般只有要对key排序时才使用TreeMap。</li><li>6、迭代器是fail-fast的。</li></ul> 
<h4><a id="12TreeMap_368"></a>1.2TreeMap的使用</h4> 
<ul><li><strong>1、创建TreeMap对象</strong></li></ul> 
<pre><code class="prism language-java">	<span class="token comment">//使用key的自然排序</span>
	<span class="token keyword">public</span> <span class="token class-name">TreeMap</span><span class="token punctuation">(</span><span class="token punctuation">)</span> 
	<span class="token comment">//指定的比较器</span>
	<span class="token keyword">public</span> <span class="token class-name">TreeMap</span><span class="token punctuation">(</span><span class="token class-name">Comparator</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span> <span class="token keyword">super</span> <span class="token class-name">K</span><span class="token punctuation">&gt;</span></span> comparator<span class="token punctuation">)</span>
</code></pre> 
<ul><li><strong>2、遍历</strong></li></ul> 
<pre><code class="prism language-java">	<span class="token comment">//返回key集合</span>
	<span class="token keyword">public</span> <span class="token class-name">Set</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">&gt;</span></span> <span class="token function">keySet</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
	<span class="token comment">//返回value集合</span>
	<span class="token keyword">public</span> <span class="token class-name">Collection</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span> <span class="token function">values</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
	<span class="token comment">//返回键值对形成的集合</span>
	<span class="token keyword">public</span> <span class="token class-name">Set</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Map<span class="token punctuation">.</span>Entry</span><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span><span class="token punctuation">&gt;</span></span> <span class="token function">entrySet</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
</code></pre> 
<ul><li><strong>3、判断是否包含指定key/value</strong></li></ul> 
<pre><code class="prism language-java">	<span class="token comment">//判断是否包含指定key</span>
	<span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">containsKey</span><span class="token punctuation">(</span><span class="token class-name">Object</span> key<span class="token punctuation">)</span>
	<span class="token comment">//判断是否包含指定value</span>
	<span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">containsValue</span><span class="token punctuation">(</span><span class="token class-name">Object</span> value<span class="token punctuation">)</span>
</code></pre> 
<ul><li><strong>4、获取特定key</strong></li></ul> 
<pre><code class="prism language-java">	<span class="token comment">//返回大于等于给定键的最小键</span>
	<span class="token keyword">public</span> <span class="token class-name">K</span> <span class="token function">ceilingKey</span><span class="token punctuation">(</span><span class="token class-name">K</span> key<span class="token punctuation">)</span>
	<span class="token comment">//返回小于等于给定key的最大key对应的键</span>
	<span class="token keyword">public</span> <span class="token class-name">K</span> <span class="token function">floorKey</span><span class="token punctuation">(</span><span class="token class-name">K</span> key<span class="token punctuation">)</span>
	<span class="token comment">//返回大于指定key的最小key对应的键</span>
	<span class="token keyword">public</span> <span class="token class-name">K</span> <span class="token function">higherKey</span><span class="token punctuation">(</span><span class="token class-name">K</span> key<span class="token punctuation">)</span>	
	<span class="token comment">//返回最大key对应的键</span>
	<span class="token keyword">public</span> <span class="token class-name">K</span> <span class="token function">lastKey</span><span class="token punctuation">(</span><span class="token punctuation">)</span>	
	<span class="token comment">//返回小于指定key的最大key对应的键</span>
	<span class="token keyword">public</span> <span class="token class-name">K</span> <span class="token function">lowerKey</span><span class="token punctuation">(</span><span class="token class-name">K</span> key<span class="token punctuation">)</span>
	<span class="token comment">//返回最小key</span>
	<span class="token keyword">public</span> <span class="token class-name">K</span> <span class="token function">firstKey</span><span class="token punctuation">(</span><span class="token punctuation">)</span>		
</code></pre> 
<p><strong>5、获取特定K-V</strong></p> 
<pre><code class="prism language-java">	<span class="token comment">//返回大于等于给定键的最小键对应的键值对</span>
	<span class="token keyword">public</span> <span class="token class-name">Map<span class="token punctuation">.</span>Entry</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span> <span class="token function">ceilingEntry</span><span class="token punctuation">(</span><span class="token class-name">K</span> key<span class="token punctuation">)</span>
	<span class="token comment">//返回小于等于给定key的最大key对应的键值对</span>
	<span class="token keyword">public</span> <span class="token class-name">Map<span class="token punctuation">.</span>Entry</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span> <span class="token function">floorEntry</span><span class="token punctuation">(</span><span class="token class-name">K</span> key<span class="token punctuation">)</span>
	<span class="token comment">//返回大于指定key的最小key对应的键值对</span>
	<span class="token keyword">public</span> <span class="token class-name">Map<span class="token punctuation">.</span>Entry</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span> <span class="token function">higherEntry</span><span class="token punctuation">(</span><span class="token class-name">K</span> key<span class="token punctuation">)</span>	
	<span class="token comment">//返回最大key对应的键值对</span>
	<span class="token keyword">public</span> <span class="token class-name">Map<span class="token punctuation">.</span>Entry</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span> <span class="token function">lastEntry</span><span class="token punctuation">(</span><span class="token punctuation">)</span>	
	<span class="token comment">//返回小于指定key的最大key对应的键值对</span>
	<span class="token keyword">public</span> <span class="token class-name">Map<span class="token punctuation">.</span>Entry</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span> <span class="token function">lowerEntry</span><span class="token punctuation">(</span><span class="token class-name">K</span> key<span class="token punctuation">)</span>	
	<span class="token comment">//返回最小key对应的键值对</span>
	<span class="token keyword">public</span> <span class="token class-name">Map<span class="token punctuation">.</span>Entry</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span> <span class="token function">pollFirstEntry</span><span class="token punctuation">(</span><span class="token punctuation">)</span>	
</code></pre> 
<ul><li><strong>6、添加键值对</strong></li></ul> 
<pre><code class="prism language-java">	<span class="token keyword">public</span> <span class="token class-name">V</span> <span class="token function">put</span><span class="token punctuation">(</span><span class="token class-name">K</span> key<span class="token punctuation">,</span> <span class="token class-name">V</span> value<span class="token punctuation">)</span>
</code></pre> 
<ul><li><strong>7、删除指定key对应的键值对</strong></li></ul> 
<pre><code class="prism language-java">	<span class="token keyword">public</span> <span class="token class-name">V</span> <span class="token function">remove</span><span class="token punctuation">(</span><span class="token class-name">Object</span> key<span class="token punctuation">)</span>
</code></pre> 
<ul><li><strong>8、替换K-V</strong></li></ul> 
<pre><code class="prism language-java">	<span class="token comment">//替换指定key对应的value</span>
	<span class="token keyword">public</span> <span class="token class-name">V</span> <span class="token function">replace</span><span class="token punctuation">(</span><span class="token class-name">K</span> key<span class="token punctuation">,</span> <span class="token class-name">V</span> value<span class="token punctuation">)</span>
	<span class="token comment">//当键值对都相同时，替换value</span>
	<span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">replace</span><span class="token punctuation">(</span><span class="token class-name">K</span> key<span class="token punctuation">,</span> <span class="token class-name">V</span> oldValue<span class="token punctuation">,</span> <span class="token class-name">V</span> newValue<span class="token punctuation">)</span>
</code></pre> 
<ul><li><strong>9、返回比较器</strong></li></ul> 
<pre><code class="prism language-java">	<span class="token keyword">public</span> <span class="token class-name">Comparator</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span> <span class="token keyword">super</span> <span class="token class-name">K</span><span class="token punctuation">&gt;</span></span> <span class="token function">comparator</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
</code></pre> 
<h3><a id="TreeMap_441"></a>二、从源码理解TreeMap</h3> 
<p>  TreeMap的成员变量：</p> 
<pre><code class="prism language-java">	<span class="token comment">//key的比较器</span>
    <span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token class-name">Comparator</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span> <span class="token keyword">super</span> <span class="token class-name">K</span><span class="token punctuation">&gt;</span></span> comparator<span class="token punctuation">;</span>
	<span class="token comment">//根节点</span>
    <span class="token keyword">private</span> <span class="token keyword">transient</span> <span class="token class-name">Entry</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span> root<span class="token punctuation">;</span>
    <span class="token comment">//节点的数量</span>
    <span class="token keyword">private</span> <span class="token keyword">transient</span> <span class="token keyword">int</span> size <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
	<span class="token comment">//修改的次数</span>
    <span class="token keyword">private</span> <span class="token keyword">transient</span> <span class="token keyword">int</span> modCount <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
</code></pre> 
<h4><a id="21_Entry_453"></a>2.1 Entry</h4> 
<p>  TreeMap中的节点Entry，包含6种元素：key、value、left、right、parent和color。</p> 
<pre><code class="prism language-java">    <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">class</span> <span class="token class-name">Entry</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span> <span class="token keyword">implements</span> <span class="token class-name">Map<span class="token punctuation">.</span>Entry</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span> <span class="token punctuation">{<!-- --></span>
        <span class="token class-name">K</span> key<span class="token punctuation">;</span>
        <span class="token class-name">V</span> value<span class="token punctuation">;</span>
        <span class="token comment">//左孩子节点</span>
        <span class="token class-name">Entry</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span> left<span class="token punctuation">;</span>
        <span class="token comment">//右孩子节点</span>
        <span class="token class-name">Entry</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span> right<span class="token punctuation">;</span>
        <span class="token comment">//父节点</span>
        <span class="token class-name">Entry</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span> parent<span class="token punctuation">;</span>
        <span class="token comment">//红黑树用来表示节点颜色的属性，默认为黑色</span>
        <span class="token keyword">boolean</span> color <span class="token operator">=</span> BLACK<span class="token punctuation">;</span>
		<span class="token comment">//用key，value和父节点构造一个Entry，默认为黑色</span>
        <span class="token class-name">Entry</span><span class="token punctuation">(</span><span class="token class-name">K</span> key<span class="token punctuation">,</span> <span class="token class-name">V</span> value<span class="token punctuation">,</span> <span class="token class-name">Entry</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span> parent<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
            <span class="token keyword">this</span><span class="token punctuation">.</span>key <span class="token operator">=</span> key<span class="token punctuation">;</span>
            <span class="token keyword">this</span><span class="token punctuation">.</span>value <span class="token operator">=</span> value<span class="token punctuation">;</span>
            <span class="token keyword">this</span><span class="token punctuation">.</span>parent <span class="token operator">=</span> parent<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token comment">//...</span>
    <span class="token punctuation">}</span>
</code></pre> 
<h4><a id="22_TreeMap_476"></a>2.2 创建TreeMap对象</h4> 
<pre><code class="prism language-java">	<span class="token comment">//默认构造方法，comparator为空，代表使用key的自然顺序来维持TreeMap的顺序，</span>
	<span class="token comment">//这里要求key必须实现Comparable接口</span>
	<span class="token keyword">public</span> <span class="token class-name">TreeMap</span><span class="token punctuation">(</span><span class="token punctuation">)</span>

	<span class="token comment">//用指定的比较器构造一个TreeMap</span>
	<span class="token keyword">public</span> <span class="token class-name">TreeMap</span><span class="token punctuation">(</span><span class="token class-name">Comparator</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span> <span class="token keyword">super</span> <span class="token class-name">K</span><span class="token punctuation">&gt;</span></span> comparator<span class="token punctuation">)</span>
</code></pre> 
<h4><a id="23__485"></a>2.3 查询数据</h4> 
<pre><code class="prism language-java">	<span class="token comment">// 根据指定 key 取出对应的 Entry</span>
	<span class="token keyword">public</span> <span class="token class-name">V</span> <span class="token function">get</span><span class="token punctuation">(</span><span class="token class-name">Object</span> key<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
	    <span class="token class-name">Entry</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span> p <span class="token operator">=</span> <span class="token function">getEntry</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">;</span>
	    <span class="token comment">// 返回该 Entry 所包含的 value</span>
	    <span class="token keyword">return</span> <span class="token punctuation">(</span>p<span class="token operator">==</span><span class="token keyword">null</span> <span class="token operator">?</span> <span class="token keyword">null</span> <span class="token operator">:</span> p<span class="token punctuation">.</span> value<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
	
	<span class="token keyword">final</span> <span class="token class-name">Entry</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span> <span class="token function">getEntry</span><span class="token punctuation">(</span><span class="token class-name">Object</span> key<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
	     <span class="token comment">// 如果 comparator 不为 null，表明程序采用定制排序</span>
	    <span class="token keyword">if</span> <span class="token punctuation">(</span>comparator <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span>
	        <span class="token comment">// 如果比较器为空，只是用key作为比较器查询</span>
	        <span class="token keyword">return</span> <span class="token function">getEntryUsingComparator</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">;</span>
	    <span class="token keyword">if</span> <span class="token punctuation">(</span>key <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span>
	        <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">NullPointerException</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	   <span class="token comment">// 将 key 强制类型转换为 Comparable 实例     </span>
	   <span class="token class-name">Comparable</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span> <span class="token keyword">super</span> <span class="token class-name">K</span><span class="token punctuation">&gt;</span></span> k <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name">Comparable</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span> <span class="token keyword">super</span> <span class="token class-name">K</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">)</span> key<span class="token punctuation">;</span>
	    <span class="token comment">// 从树的根节点开始</span>
	    <span class="token class-name">Entry</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span> p <span class="token operator">=</span> root<span class="token punctuation">;</span>
	    <span class="token comment">// 从root节点开始查找，根据比较器判断是在左子树还是右子树</span>
	    <span class="token keyword">while</span> <span class="token punctuation">(</span>p <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
	         <span class="token comment">// 拿 key 与当前节点的 key 进行比较</span>
	        <span class="token keyword">int</span> cmp <span class="token operator">=</span> k<span class="token punctuation">.</span><span class="token function">compareTo</span><span class="token punctuation">(</span>p<span class="token punctuation">.</span>key <span class="token punctuation">)</span><span class="token punctuation">;</span>
	        <span class="token comment">// 如果 key 小于当前节点的 key，向"左子树”搜索</span>
	        <span class="token keyword">if</span> <span class="token punctuation">(</span>cmp <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span>
	            p <span class="token operator">=</span> p<span class="token punctuation">.</span> left<span class="token punctuation">;</span>
	        <span class="token comment">// 如果 key 大于当前节点的 key，向"右子树”搜索    </span>
	        <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>cmp <span class="token operator">&gt;</span> <span class="token number">0</span><span class="token punctuation">)</span>
	            p <span class="token operator">=</span> p<span class="token punctuation">.</span> right<span class="token punctuation">;</span>
	        <span class="token comment">// 不大于、不小于，就是找到了目标 Entry    </span>
	        <span class="token keyword">else</span>
	            <span class="token keyword">return</span> p<span class="token punctuation">;</span>
	    <span class="token punctuation">}</span>
	    <span class="token keyword">return</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
	
	<span class="token keyword">final</span> <span class="token class-name">Entry</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span> <span class="token function">getEntryUsingComparator</span><span class="token punctuation">(</span><span class="token class-name">Object</span> key<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
	    <span class="token class-name">K</span> k <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name">K</span><span class="token punctuation">)</span> key<span class="token punctuation">;</span>
	    <span class="token comment">// 获取该 TreeMap 的 comparator</span>
	    <span class="token class-name">Comparator</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span> <span class="token keyword">super</span> <span class="token class-name">K</span><span class="token punctuation">&gt;</span></span> cpr <span class="token operator">=</span> comparator <span class="token punctuation">;</span>
	    <span class="token keyword">if</span> <span class="token punctuation">(</span>cpr <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
	         <span class="token comment">// 从根节点开始</span>
	        <span class="token class-name">Entry</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span> p <span class="token operator">=</span> root<span class="token punctuation">;</span>
	        <span class="token keyword">while</span> <span class="token punctuation">(</span>p <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
	            <span class="token comment">// 拿 key 与当前节点的 key 进行比较</span>
	            <span class="token keyword">int</span> cmp <span class="token operator">=</span> cpr<span class="token punctuation">.</span><span class="token function">compare</span><span class="token punctuation">(</span>k<span class="token punctuation">,</span> p<span class="token punctuation">.</span>key <span class="token punctuation">)</span><span class="token punctuation">;</span>
	            <span class="token comment">// 如果 key 小于当前节点的 key，向"左子树”搜索</span>
	            <span class="token keyword">if</span> <span class="token punctuation">(</span>cmp <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span>
	                p <span class="token operator">=</span> p<span class="token punctuation">.</span> left<span class="token punctuation">;</span>
	            <span class="token comment">// 如果 key 大于当前节点的 key，向"右子树”搜索    </span>
	            <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>cmp <span class="token operator">&gt;</span> <span class="token number">0</span><span class="token punctuation">)</span>
	                p <span class="token operator">=</span> p<span class="token punctuation">.</span> right<span class="token punctuation">;</span>
	            <span class="token comment">// 不大于、不小于，就是找到了目标 Entry    </span>
	            <span class="token keyword">else</span>
	                <span class="token keyword">return</span> p<span class="token punctuation">;</span>
	        <span class="token punctuation">}</span>
	    <span class="token punctuation">}</span>
	    <span class="token keyword">return</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
</code></pre> 
<p>  上面的 getEntry(Object obj) 方法也是充分利用排序二叉树的特征来搜索目标 Entry。从二叉树的根节点开始，如果被搜索节点大于当前节点，向”右子树”搜索；如果被搜索节点小于当前节点，向”左子树”搜索；如果相等，那就是找到了指定节点。</p> 
<p>  当TreeMap里的comparator != null，表明该TreeMap采用了定制排序，在采用定制排序的方式下，TreeMap采用getEntryUsingComparator(key)方法来根据key获取Entry。<br>   其实getEntry、getEntryUsingComparator 两个方法的实现思路完全类似，只是前者对自然排序的TreeMap获取有效，后者对定制排序的TreeMap有效。<br>   ：从内部结构来看，TreeMap本质上就是一棵”红黑树”，TreeMap的每个Entry就是该红黑树的一个节点。</p> 
<h4><a id="24__551"></a>2.4 添加数据</h4> 
<pre><code class="prism language-java">	<span class="token keyword">public</span> <span class="token class-name">V</span> <span class="token function">put</span><span class="token punctuation">(</span><span class="token class-name">K</span> key<span class="token punctuation">,</span> <span class="token class-name">V</span> value<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
	    <span class="token comment">// 先以 t 保存链表的 root 节点</span>
	    <span class="token class-name">Entry</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span> t <span class="token operator">=</span> root<span class="token punctuation">;</span>
	    <span class="token comment">// 如果 t==null，表明是一个空链表，即该 TreeMap 里没有任何 Entry</span>
	    <span class="token keyword">if</span> <span class="token punctuation">(</span>t <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
	        <span class="token function">compare</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span> key<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// type check</span>
	        <span class="token comment">// 将新的 key-value 创建一个 Entry，并将该 Entry 作为 root</span>
	        root <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Entry</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span>key<span class="token punctuation">,</span> value<span class="token punctuation">,</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	        <span class="token comment">// 设置该 Map 集合的 size 为 1，代表包含一个 Entry</span>
	        size <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
	        <span class="token comment">// 记录修改次数为 1</span>
	        modCount<span class="token operator">++</span><span class="token punctuation">;</span>
	        <span class="token keyword">return</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
	    <span class="token punctuation">}</span>
	    <span class="token comment">// 记录比较结果</span>
	    <span class="token keyword">int</span> cmp<span class="token punctuation">;</span>
	    <span class="token class-name">Entry</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span> parent<span class="token punctuation">;</span>
	    <span class="token comment">// 当前使用的比较器</span>
	    <span class="token class-name">Comparator</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span> <span class="token keyword">super</span> <span class="token class-name">K</span><span class="token punctuation">&gt;</span></span> cpr <span class="token operator">=</span> comparator <span class="token punctuation">;</span>
	    <span class="token comment">// 如果比较器不为空，就是用指定的比较器来维护TreeMap的元素顺序</span>
	    <span class="token keyword">if</span> <span class="token punctuation">(</span>cpr <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
	         <span class="token comment">// do while循环，查找key要插入的位置（也就是新节点的父节点是谁）</span>
	        <span class="token keyword">do</span> <span class="token punctuation">{<!-- --></span>
	            <span class="token comment">// 使用 parent 上次循环后的 t 所引用的 Entry</span>
	            parent <span class="token operator">=</span> t<span class="token punctuation">;</span>
	            <span class="token comment">// 拿新插入 key 和 t 的 key 进行比较</span>
	            cmp <span class="token operator">=</span> cpr<span class="token punctuation">.</span><span class="token function">compare</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span> t<span class="token punctuation">.</span> key<span class="token punctuation">)</span><span class="token punctuation">;</span>
	             <span class="token comment">// 如果新插入的 key 小于 t 的 key，t 等于 t 的左边节点</span>
	            <span class="token keyword">if</span> <span class="token punctuation">(</span>cmp <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span>
	                t <span class="token operator">=</span> t<span class="token punctuation">.</span> left<span class="token punctuation">;</span>
	            <span class="token comment">// 如果新插入的 key 大于 t 的 key，t 等于 t 的右边节点</span>
	            <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>cmp <span class="token operator">&gt;</span> <span class="token number">0</span><span class="token punctuation">)</span>
	                t <span class="token operator">=</span> t<span class="token punctuation">.</span> right<span class="token punctuation">;</span>
	            <span class="token comment">// 如果当前节点的key和新插入的key相等的话，则覆盖map的value，返回</span>
	            <span class="token keyword">else</span>
	                <span class="token keyword">return</span> t<span class="token punctuation">.</span><span class="token function">setValue</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span><span class="token punctuation">;</span>
	        <span class="token comment">// 只有当t为null，也就是没有要比较节点的时候，代表已经找到新节点要插入的位置</span>
	        <span class="token punctuation">}</span> <span class="token keyword">while</span> <span class="token punctuation">(</span>t <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	    <span class="token punctuation">}</span>
	    <span class="token keyword">else</span> <span class="token punctuation">{<!-- --></span>
	        <span class="token comment">// 如果比较器为空，则使用key作为比较器进行比较</span>
	        <span class="token comment">// 这里要求key不能为空，并且必须实现Comparable接口</span>
	        <span class="token keyword">if</span> <span class="token punctuation">(</span>key <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span>
	            <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">NullPointerException</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	        <span class="token class-name">Comparable</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span> <span class="token keyword">super</span> <span class="token class-name">K</span><span class="token punctuation">&gt;</span></span> k <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name">Comparable</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span> <span class="token keyword">super</span> <span class="token class-name">K</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">)</span> key<span class="token punctuation">;</span>
	        <span class="token keyword">do</span> <span class="token punctuation">{<!-- --></span>
	            <span class="token comment">// 使用 parent 上次循环后的 t 所引用的 Entry</span>
	            parent <span class="token operator">=</span> t<span class="token punctuation">;</span>
	            <span class="token comment">// 拿新插入 key 和 t 的 key 进行比较</span>
	            cmp <span class="token operator">=</span> k<span class="token punctuation">.</span><span class="token function">compareTo</span><span class="token punctuation">(</span>t<span class="token punctuation">.</span> key<span class="token punctuation">)</span><span class="token punctuation">;</span>
	            <span class="token comment">// 如果新插入的 key 小于 t 的 key，t 等于 t 的左边节点</span>
	            <span class="token keyword">if</span> <span class="token punctuation">(</span>cmp <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span>
	                t <span class="token operator">=</span> t<span class="token punctuation">.</span> left<span class="token punctuation">;</span>
	            <span class="token comment">// 如果新插入的 key 大于 t 的 key，t 等于 t 的右边节点    </span>
	            <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>cmp <span class="token operator">&gt;</span> <span class="token number">0</span><span class="token punctuation">)</span>
	                t <span class="token operator">=</span> t<span class="token punctuation">.</span> right<span class="token punctuation">;</span>
	            <span class="token comment">// 如果两个 key 相等，新的 value 覆盖原有的 value,并返回原有的 value</span>
	            <span class="token keyword">else</span>
	                <span class="token keyword">return</span> t<span class="token punctuation">.</span><span class="token function">setValue</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span><span class="token punctuation">;</span>
	        <span class="token punctuation">}</span> <span class="token keyword">while</span> <span class="token punctuation">(</span>t <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	    <span class="token punctuation">}</span>
	    <span class="token comment">// 将新插入的节点作为 parent 节点的子节点</span>
	    <span class="token class-name">Entry</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span> e <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Entry</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span>key<span class="token punctuation">,</span> value<span class="token punctuation">,</span> parent<span class="token punctuation">)</span><span class="token punctuation">;</span>
	    <span class="token comment">// 如果新插入 key 小于 parent 的 key，则 e 作为 parent 的左子节点</span>
	    <span class="token keyword">if</span> <span class="token punctuation">(</span>cmp <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span>
	        parent<span class="token punctuation">.</span> left <span class="token operator">=</span> e<span class="token punctuation">;</span>
	    <span class="token comment">// 如果新插入 key 小于 parent 的 key，则 e 作为 parent 的右子节点</span>
	    <span class="token keyword">else</span>
	        parent<span class="token punctuation">.</span> right <span class="token operator">=</span> e<span class="token punctuation">;</span>
	    <span class="token comment">// 插入新的节点后，为了保持红黑树平衡，对红黑树进行调整</span>
	    <span class="token function">fixAfterInsertion</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span><span class="token punctuation">;</span>
	    <span class="token comment">// map元素个数+1</span>
	    size<span class="token operator">++</span><span class="token punctuation">;</span>
	    modCount<span class="token operator">++</span><span class="token punctuation">;</span>
	    <span class="token keyword">return</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>

	<span class="token comment">/** 新增节点后对红黑树的调整方法 */</span>
	<span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">fixAfterInsertion</span><span class="token punctuation">(</span><span class="token class-name">Entry</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span> x<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
	    <span class="token comment">// 将新插入节点的颜色设置为红色</span>
	    x<span class="token punctuation">.</span> color <span class="token operator">=</span> RED<span class="token punctuation">;</span>
	
	    <span class="token comment">// while循环，直到 x 节点的父节点不是根，且 x 的父节点不是红色</span>
	    <span class="token keyword">while</span> <span class="token punctuation">(</span>x <span class="token operator">!=</span> <span class="token keyword">null</span> <span class="token operator">&amp;&amp;</span> x <span class="token operator">!=</span> root <span class="token operator">&amp;&amp;</span> x<span class="token punctuation">.</span> parent<span class="token punctuation">.</span>color <span class="token operator">==</span> RED<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
	        <span class="token comment">// 如果 x 的父节点是其父节点的左子节点</span>
	        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">parentOf</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token function">leftOf</span><span class="token punctuation">(</span>parentOf <span class="token punctuation">(</span><span class="token function">parentOf</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
	            <span class="token comment">// 获取 x 的父节点的兄弟节点</span>
	            <span class="token class-name">Entry</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span> y <span class="token operator">=</span> <span class="token function">rightOf</span><span class="token punctuation">(</span>parentOf <span class="token punctuation">(</span><span class="token function">parentOf</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	            <span class="token comment">// 如果 x 的父节点的兄弟节点是红色</span>
	            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">colorOf</span><span class="token punctuation">(</span>y<span class="token punctuation">)</span> <span class="token operator">==</span> RED<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
	                <span class="token comment">// 将x的父节点设置为黑色</span>
	                <span class="token function">setColor</span><span class="token punctuation">(</span>parentOf <span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">,</span> BLACK<span class="token punctuation">)</span><span class="token punctuation">;</span>
	                <span class="token comment">// 将 x 的父节点的兄弟节点设为黑色</span>
	                <span class="token function">setColor</span><span class="token punctuation">(</span>y<span class="token punctuation">,</span> BLACK<span class="token punctuation">)</span><span class="token punctuation">;</span>
	                <span class="token comment">// 将 x 的父节点的父节点设为红色</span>
	                <span class="token function">setColor</span><span class="token punctuation">(</span>parentOf <span class="token punctuation">(</span><span class="token function">parentOf</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">,</span> RED<span class="token punctuation">)</span><span class="token punctuation">;</span>
	                <span class="token comment">// 将x指向祖父节点，如果x的祖父节点的父节点是红色，按照上面的步骤继续循环</span>
	                x <span class="token operator">=</span> <span class="token function">parentOf</span><span class="token punctuation">(</span>parentOf <span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	            <span class="token comment">//如果 x 的父节点的兄弟节点是黑色    </span>
	            <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{<!-- --></span>
	                <span class="token comment">// 如果 x 是其父节点的右子节点</span>
	                <span class="token keyword">if</span> <span class="token punctuation">(</span>x <span class="token operator">==</span> <span class="token function">rightOf</span><span class="token punctuation">(</span> <span class="token function">parentOf</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
	                    <span class="token comment">// 将 x 的父节点设为 x</span>
	                    x <span class="token operator">=</span> <span class="token function">parentOf</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span>
	                    <span class="token function">rotateLeft</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span>
	                <span class="token punctuation">}</span>
	                <span class="token comment">//把 x 的父节点设为黑色</span>
	                <span class="token function">setColor</span><span class="token punctuation">(</span>parentOf <span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">,</span> BLACK<span class="token punctuation">)</span><span class="token punctuation">;</span>
	                <span class="token comment">// 把 x 的父节点的父节点设为红色</span>
	                <span class="token function">setColor</span><span class="token punctuation">(</span>parentOf <span class="token punctuation">(</span><span class="token function">parentOf</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">,</span> RED<span class="token punctuation">)</span><span class="token punctuation">;</span>
	                <span class="token comment">// 右旋x的祖父节点</span>
	                <span class="token function">rotateRight</span><span class="token punctuation">(</span> <span class="token function">parentOf</span><span class="token punctuation">(</span>parentOf <span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	            <span class="token punctuation">}</span>
	        <span class="token comment">// 如果 x 的父节点是其父节点的右子节点   </span>
	        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{<!-- --></span> 
	            <span class="token comment">//获取 x 的父节点的兄弟节点</span>
	            <span class="token class-name">Entry</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span> y <span class="token operator">=</span> <span class="token function">leftOf</span><span class="token punctuation">(</span>parentOf <span class="token punctuation">(</span><span class="token function">parentOf</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	            <span class="token comment">// 如果 x 的父节点的兄弟节点是红色</span>
	            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">colorOf</span><span class="token punctuation">(</span>y<span class="token punctuation">)</span> <span class="token operator">==</span> RED<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
	                 <span class="token comment">// 将 x 的父节点设为黑色</span>
	                <span class="token function">setColor</span><span class="token punctuation">(</span>parentOf <span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">,</span> BLACK<span class="token punctuation">)</span><span class="token punctuation">;</span>
	                <span class="token comment">// 将 x 的父节点的兄弟节点设为黑色</span>
	                <span class="token function">setColor</span><span class="token punctuation">(</span>y<span class="token punctuation">,</span> BLACK<span class="token punctuation">)</span><span class="token punctuation">;</span>
	                <span class="token comment">// 将 x 的父节点的父节点设为红色</span>
	                <span class="token function">setColor</span><span class="token punctuation">(</span>parentOf <span class="token punctuation">(</span><span class="token function">parentOf</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">,</span> RED<span class="token punctuation">)</span><span class="token punctuation">;</span>
	                <span class="token comment">// 将 x 设为 x 的父节点的节点</span>
	                x <span class="token operator">=</span> <span class="token function">parentOf</span><span class="token punctuation">(</span>parentOf <span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	            <span class="token comment">// 如果 x 的父节点的兄弟节点是黑色    </span>
	            <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{<!-- --></span>
	                <span class="token comment">// 如果 x 是其父节点的左子节点</span>
	                <span class="token keyword">if</span> <span class="token punctuation">(</span>x <span class="token operator">==</span> <span class="token function">leftOf</span><span class="token punctuation">(</span> <span class="token function">parentOf</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
	                     <span class="token comment">// 将 x 的父节点设为 x</span>
	                    x <span class="token operator">=</span> <span class="token function">parentOf</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span>
	                    <span class="token function">rotateRight</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span>
	                <span class="token punctuation">}</span>
	                <span class="token comment">// 把 x 的父节点设为黑色</span>
	                <span class="token function">setColor</span><span class="token punctuation">(</span>parentOf <span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">,</span> BLACK<span class="token punctuation">)</span><span class="token punctuation">;</span>
	                <span class="token comment">// 把 x 的父节点的父节点设为红色</span>
	                <span class="token function">setColor</span><span class="token punctuation">(</span>parentOf <span class="token punctuation">(</span><span class="token function">parentOf</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">,</span> RED<span class="token punctuation">)</span><span class="token punctuation">;</span>
	                <span class="token function">rotateLeft</span><span class="token punctuation">(</span> <span class="token function">parentOf</span><span class="token punctuation">(</span>parentOf <span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	            <span class="token punctuation">}</span>
	        <span class="token punctuation">}</span>
	    <span class="token punctuation">}</span>
	    <span class="token comment">// 最后将根节点设置为黑色，不管当前是不是红色，反正根节点必须是黑色</span>
	    root<span class="token punctuation">.</span>color <span class="token operator">=</span> BLACK<span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
	
	<span class="token comment">/**
	 * 对红黑树的节点(x)进行左旋转
	 * 左旋示意图(对节点x进行左旋)：
	 *      px                              px
	 *     /                               /
	 *    x                               y               
	 *   /  \      --(左旋)--           / \                
	 *  lx   y                          x  ry    
	 *     /   \                       /  \
	 *    ly   ry                     lx  ly 
	 *
	 */</span>
	<span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">rotateLeft</span><span class="token punctuation">(</span><span class="token class-name">Entry</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span> p<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
	    <span class="token keyword">if</span> <span class="token punctuation">(</span>p <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
	        <span class="token comment">// 取得要选择节点p的右孩子</span>
	        <span class="token class-name">Entry</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span> r <span class="token operator">=</span> p<span class="token punctuation">.</span> right<span class="token punctuation">;</span>
	        <span class="token comment">// "p"和"r的左孩子"的相互指向...</span>
	        <span class="token comment">// 将"r的左孩子"设为"p的右孩子"</span>
	        p<span class="token punctuation">.</span> right <span class="token operator">=</span> r<span class="token punctuation">.</span>left <span class="token punctuation">;</span>
	        <span class="token comment">// 如果r的左孩子非空，将"p"设为"r的左孩子的父亲"</span>
	        <span class="token keyword">if</span> <span class="token punctuation">(</span>r<span class="token punctuation">.</span>left <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span>
	            r<span class="token punctuation">.</span> left<span class="token punctuation">.</span>parent <span class="token operator">=</span> p<span class="token punctuation">;</span>
	
	        <span class="token comment">// "p的父亲"和"r"的相互指向...</span>
	        <span class="token comment">// 将"p的父亲"设为"y的父亲"</span>
	        r<span class="token punctuation">.</span> parent <span class="token operator">=</span> p<span class="token punctuation">.</span>parent <span class="token punctuation">;</span>
	        <span class="token comment">// 如果"p的父亲"是空节点，则将r设为根节点</span>
	        <span class="token keyword">if</span> <span class="token punctuation">(</span>p<span class="token punctuation">.</span>parent <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span>
	            root <span class="token operator">=</span> r<span class="token punctuation">;</span>
	        <span class="token comment">// 如果p是它父节点的左孩子，则将r设为"p的父节点的左孩子"</span>
	        <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>p<span class="token punctuation">.</span>parent<span class="token punctuation">.</span> left <span class="token operator">==</span> p<span class="token punctuation">)</span>
	            p<span class="token punctuation">.</span> parent<span class="token punctuation">.</span>left <span class="token operator">=</span> r<span class="token punctuation">;</span>
	        <span class="token keyword">else</span>             
	            <span class="token comment">// 如果p是它父节点的左孩子，则将r设为"p的父节点的左孩子"</span>
	            p<span class="token punctuation">.</span> parent<span class="token punctuation">.</span>right <span class="token operator">=</span> r<span class="token punctuation">;</span>
	        <span class="token comment">// "p"和"r"的相互指向...</span>
	        <span class="token comment">// 将"p"设为"r的左孩子"</span>
	        r<span class="token punctuation">.</span> left <span class="token operator">=</span> p<span class="token punctuation">;</span>
	        <span class="token comment">// 将"p的父节点"设为"r"</span>
	        p<span class="token punctuation">.</span> parent <span class="token operator">=</span> r<span class="token punctuation">;</span>
	    <span class="token punctuation">}</span>
	<span class="token punctuation">}</span>
	
	
	<span class="token comment">/**
	 * 对红黑树的节点进行右旋转
	 * 右旋示意图(对节点y进行右旋)：
	 *            py                               py
	 *           /                                /
	 *          y                                x                 
	 *         /  \      --(右旋)--            /  \                     
	 *        x   ry                           lx   y 
	 *       / \                                   / \                   
	 *      lx  rx                                rx  ry
	 */</span>
	<span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">rotateRight</span><span class="token punctuation">(</span><span class="token class-name">Entry</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span> p<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
	    <span class="token keyword">if</span> <span class="token punctuation">(</span>p <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
	        <span class="token comment">// 取得要选择节点p的左孩子</span>
	        <span class="token class-name">Entry</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span> l <span class="token operator">=</span> p<span class="token punctuation">.</span> left<span class="token punctuation">;</span>           
	        <span class="token comment">// 将"l的右孩子"设为"p的左孩子"</span>
	        p<span class="token punctuation">.</span> left <span class="token operator">=</span> l<span class="token punctuation">.</span>right <span class="token punctuation">;</span>
	        <span class="token comment">// 如果"l的右孩子"不为空的话，将"p"设为"l的右孩子的父亲"</span>
	        <span class="token keyword">if</span> <span class="token punctuation">(</span>l<span class="token punctuation">.</span>right <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> l<span class="token punctuation">.</span> right<span class="token punctuation">.</span>parent <span class="token operator">=</span> p<span class="token punctuation">;</span>
	        <span class="token comment">// 将"p的父亲"设为"l的父亲"</span>
	        l<span class="token punctuation">.</span> parent <span class="token operator">=</span> p<span class="token punctuation">.</span>parent <span class="token punctuation">;</span>
	        <span class="token comment">// 如果"p的父亲"是空节点，则将l设为根节点</span>
	        <span class="token keyword">if</span> <span class="token punctuation">(</span>p<span class="token punctuation">.</span>parent <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span>
	            root <span class="token operator">=</span> l<span class="token punctuation">;</span>      
	        <span class="token comment">// 如果p是它父节点的右孩子，则将l设为"p的父节点的右孩子"</span>
	        <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>p<span class="token punctuation">.</span>parent<span class="token punctuation">.</span> right <span class="token operator">==</span> p<span class="token punctuation">)</span>
	            p<span class="token punctuation">.</span> parent<span class="token punctuation">.</span>right <span class="token operator">=</span> l<span class="token punctuation">;</span>
	        <span class="token comment">//如果p是它父节点的左孩子，将l设为"p的父节点的左孩子"</span>
	        <span class="token keyword">else</span> p<span class="token punctuation">.</span>parent <span class="token punctuation">.</span>left <span class="token operator">=</span> l<span class="token punctuation">;</span>
	        <span class="token comment">// 将"p"设为"l的右孩子"</span>
	        l<span class="token punctuation">.</span> right <span class="token operator">=</span> p<span class="token punctuation">;</span>
	        <span class="token comment">// 将"l"设为"p父节点"</span>
	        p<span class="token punctuation">.</span> parent <span class="token operator">=</span> l<span class="token punctuation">;</span>
	    <span class="token punctuation">}</span>
	<span class="token punctuation">}</span>
</code></pre> 
<p>  每当程序希望添加新节点时：系统总是从树的根节点开始比较 —— 即将根节点当成当前节点，如果新增节点大于当前节点、并且当前节点的右子节点存在，则以右子节点作为当前节点；如果新增节点小于当前节点、并且当前节点的左子节点存在，则以左子节点作为当前节点；如果新增节点等于当前节点，则用新增节点覆盖当前节点，并结束循环 ——直到找到某个节点的左、右子节点不存在，将新节点添加该节点的子节点 —— 如果新节点比该节点大，则添加为右子节点；如果新节点比该节点小，则添加为左子节点。</p> 
<ul><li><strong>添加节点后的红黑树调整</strong><br>   每次插入节点后必须进行简单修复，使该排序二叉树满足红黑树的要求。<br>   在插入操作中，红黑树的性质 1 和性质 3 两个永远不会发生改变，因此无需考虑红黑树的这两个特性。<br>   插入操作按如下步骤进行：1.）以排序二叉树的方法插入新节点，并将它设为红色。2）进行颜色调换和树旋转。<br>   假设把新插入的节点定义为N 节点，N 节点的父节点定义为 P 节点，P 节点的兄弟节点定义为 U 节点，P 节点父节点定义为 G 节点。</li><li><strong>情形 1：新节点 N 是树的根节点，没有父节点</strong><br>   在这种情形下，直接将它设置为黑色以满足性质 2。</li><li><strong>情形 2：新节点的父节点 P 是黑色</strong><br>   在这种情况下，新插入的节点是红色的，因此依然满足性质 4。而且因为新节点 N 有两个黑色叶子节点；但是由于新节点 N 是红色，通过它的每个子节点的路径依然保持相同的黑色节点数，因此依然满足性质 5。</li><li><strong>情形 3：如果父节点 P 和父节点的兄弟节点 U 都是红色</strong><br>   在这种情况下，程序应该将 P 节点、U 节点都设置为黑色，并将 P 节点的父节点设为红色（用来保持性质 5）。现在新节点 N 有了一个黑色的父节点 P。由于从 P 节点、U 节点到根节点的任何路径都必须通过 G 节点，在这些路径上的黑节点数目没有改变（原来有叶子和 G 节点两个黑色节点，现在有叶子和 P两个黑色节点）。<br>   经过上面处理后，红色的 G 节点的父节点也有可能是红色的，这就违反了性质 4，因此还需要对 G 节点递归地进行整个过程（把 G 当成是新插入的节点进行处理即可）。示例：<br> <img src="https://images2.imgbox.com/f1/a0/KqEXjBwr_o.png" alt=""></li><li><strong>情形 4：父节点 P 是红色、而其兄弟节点 U 是黑色或缺少；且新节点 N 是父节点 P 的右子节点，而父节点 P 又是其父节点 G 的左子节点</strong><br>   在这种情形下，我们进行一次左旋转对新节点和其父节点进行，接着按情形 5 处理以前的父节点 P（也就是把 P 当成新插入的节点即可）。这导致某些路径通过它们以前不通过的新节点 N 或父节点 P 的其中之一，但是这两个节点都是红色的，因此不会影响性质 5。示例：<br> <img src="https://images2.imgbox.com/9d/75/cfFwGdhp_o.png" alt=""></li><li><strong>情形 5：父节点 P 是红色、而其兄弟节点 U 是黑色或缺少；且新节点 N 是其父节点的左子节点，而父节点 P 又是其父节点 G 的左子节点</strong><br>   在这种情形下，需要对节点 G 的一次右旋转，在旋转产生的树中，以前的父节点 P 现在是新节点 N 和节点 G 的父节点。由于以前的节点 G 是黑色，否则父节点 P 就不可能是红色，我们切换以前的父节点 P和节点 G 的颜色，使之满足性质 4，性质 5 也仍然保持满足，因为通过这三个节点中任何一个的所有路径以前都通过节点 G，现在它们都通过以前的父节点 P。在各自的情形下，这都是三个节点中唯一的黑色节点。示例：<br> <img src="https://images2.imgbox.com/76/a1/OG6KTe1C_o.png" alt=""></li></ul> 
<h4><a id="25__802"></a>2.5 删除数据</h4> 
<p>  当程序从排序二叉树中删除一个节点之后，为了让它依然保持为排序二叉树，程序必须对该排序二叉树进行维护。维护可分为如下几种情况：<br>   1）被删除的节点是叶子节点，则只需将它从其父节点中删除即可。<br>   2）被删除节点 p 只有左子树，将 p 的左子树 pL 添加成 p 的父节点的左子树即可；被删除节点 p 只有右子树，将 p 的右子树 pR 添加成 p 的父节点的右子树即可。<br>   3）若被删除节点 p 的左、右子树均非空，有两种做法：</p> 
<blockquote> 
 <ol><li>将 pL 设为 p 的父节点 q 的左或右子节点（取决于 p 是其父节点 q 的左、右子节点），将 pR 设为p 节点的中序前趋节点 s 的右子节点（s 是 pL 最右下的节点，也就是 pL 子树中最大的节点）。</li><li>以 p 节点的中序前趋或后继替代 p 所指节点，然后再从原排序二叉树中删去中序前趋或后继节点即可。（也就是用大于 p 的最小节点或小于 p 的最大节点代替 p 节点即可）。</li></ol> 
</blockquote> 
<p>  被删除节点只有右子树的示意图：<br> <img src="https://images2.imgbox.com/5c/e7/GeiXoCSP_o.png" alt=""><br>   被删除节点既有左子节点，又有右子节点的情形，此时我们采用到是第一种方式进行维护：<br> <img src="https://images2.imgbox.com/ea/0e/DLpNPCfA_o.png" alt=""><br>   被删除节点既有左子树，又有右子树的情形，此时我们采用到是第二种方式进行维护：<br> <img src="https://images2.imgbox.com/b2/03/gcC9HVPL_o.png" alt=""><br>   TreeMap 删除节点采用最后一张图所示右边的情形进行维护——也就是用被删除节点的右子树中最小节点与被删节点交换的方式进行维护。</p> 
<pre><code class="prism language-java">	<span class="token keyword">public</span> <span class="token class-name">V</span> <span class="token function">remove</span><span class="token punctuation">(</span><span class="token class-name">Object</span> key<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
	    <span class="token comment">// 根据key查找到对应的节点对象</span>
	    <span class="token class-name">Entry</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span> p <span class="token operator">=</span> <span class="token function">getEntry</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">;</span>
	    <span class="token keyword">if</span> <span class="token punctuation">(</span>p <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span>
	        <span class="token keyword">return</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
	
	    <span class="token comment">// 记录key对应的value，供返回使用</span>
	    <span class="token class-name">V</span> oldValue <span class="token operator">=</span> p<span class="token punctuation">.</span>value<span class="token punctuation">;</span>
	    <span class="token comment">// 删除节点</span>
	    <span class="token function">deleteEntry</span><span class="token punctuation">(</span>p<span class="token punctuation">)</span><span class="token punctuation">;</span>
	    <span class="token keyword">return</span> oldValue<span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
	
	
	<span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">deleteEntry</span><span class="token punctuation">(</span><span class="token class-name">Entry</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span> p<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
	    modCount<span class="token operator">++</span><span class="token punctuation">;</span>
	    <span class="token comment">// map容器的元素个数减一</span>
	    size<span class="token operator">--</span><span class="token punctuation">;</span>
	
	    <span class="token comment">// // 如果被删除节点的左子树、右子树都不为空</span>
	    <span class="token keyword">if</span> <span class="token punctuation">(</span>p<span class="token punctuation">.</span>left <span class="token operator">!=</span> <span class="token keyword">null</span> <span class="token operator">&amp;&amp;</span> p<span class="token punctuation">.</span> right <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
	        <span class="token comment">// 用 p 节点的中序后继节点代替 p 节点</span>
	        <span class="token class-name">Entry</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span> s <span class="token operator">=</span> successor <span class="token punctuation">(</span>p<span class="token punctuation">)</span><span class="token punctuation">;</span>
	        p<span class="token punctuation">.</span> key <span class="token operator">=</span> s<span class="token punctuation">.</span>key <span class="token punctuation">;</span>
	        p<span class="token punctuation">.</span> value <span class="token operator">=</span> s<span class="token punctuation">.</span>value <span class="token punctuation">;</span>
	        <span class="token comment">// 将p指向替代节点，从此之后的p不再是原先要删除的节点p，而是替代者p</span>
	        p <span class="token operator">=</span> s<span class="token punctuation">;</span>
	    <span class="token punctuation">}</span> <span class="token comment">// p has 2 children</span>
	
	    <span class="token comment">// 如果 p 节点的左节点存在，replacement 代表左节点；否则代表右节点</span>
	    <span class="token class-name">Entry</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span> replacement <span class="token operator">=</span> <span class="token punctuation">(</span>p<span class="token punctuation">.</span> left <span class="token operator">!=</span> <span class="token keyword">null</span> <span class="token operator">?</span> p<span class="token punctuation">.</span>left <span class="token operator">:</span> p<span class="token punctuation">.</span> right<span class="token punctuation">)</span><span class="token punctuation">;</span>
	
	    <span class="token keyword">if</span> <span class="token punctuation">(</span>replacement <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span> <span class="token comment">// 如果上面的if有两个孩子不通过--------------这里表示要删除的节点只有一个孩子（2）</span>
	        <span class="token comment">// Link replacement to parent</span>
	        <span class="token comment">// 将p的父节点拷贝给替代节点</span>
	        replacement<span class="token punctuation">.</span> parent <span class="token operator">=</span> p<span class="token punctuation">.</span>parent <span class="token punctuation">;</span>
	        <span class="token comment">// 如果 p 没有父节点，则 replacemment 变成父节点</span>
	        <span class="token keyword">if</span> <span class="token punctuation">(</span>p<span class="token punctuation">.</span>parent <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span>
	            root <span class="token operator">=</span> replacement<span class="token punctuation">;</span>
	        <span class="token comment">// 如果 p 节点是其父节点的左子节点</span>
	        <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>p <span class="token operator">==</span> p<span class="token punctuation">.</span>parent<span class="token punctuation">.</span> left<span class="token punctuation">)</span>
	            p<span class="token punctuation">.</span> parent<span class="token punctuation">.</span>left   <span class="token operator">=</span> replacement<span class="token punctuation">;</span>
	        <span class="token comment">// 如果 p 节点是其父节点的右子节点</span>
	        <span class="token keyword">else</span>
	            p<span class="token punctuation">.</span> parent<span class="token punctuation">.</span>right <span class="token operator">=</span> replacement<span class="token punctuation">;</span>
	
	        <span class="token comment">// 将替代节点p的left、right、parent的指针都指向空，即解除前后引用关系（相当于将p从树种摘除），使得gc可以回收</span>
	        p<span class="token punctuation">.</span> left <span class="token operator">=</span> p<span class="token punctuation">.</span>right <span class="token operator">=</span> p<span class="token punctuation">.</span>parent <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
	
	        <span class="token comment">// Fix replacement</span>
	        <span class="token comment">// 如果替代节点p的颜色是黑色，则需要调整红黑树以保持其平衡</span>
	        <span class="token keyword">if</span> <span class="token punctuation">(</span>p<span class="token punctuation">.</span>color <span class="token operator">==</span> BLACK<span class="token punctuation">)</span>
	            <span class="token function">fixAfterDeletion</span><span class="token punctuation">(</span>replacement<span class="token punctuation">)</span><span class="token punctuation">;</span>
	    <span class="token comment">//如果 p 节点没有父节点        </span>
	    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>p<span class="token punctuation">.</span>parent <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span> <span class="token comment">// return if we are the only node.</span>
	        <span class="token comment">// 如果要替代节点p没有父节点，代表p为根节点，直接删除即可</span>
	        root <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
	    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{<!-- --></span> <span class="token comment">//  No children. Use self as phantom replacement and unlink.</span>
	        <span class="token comment">// 判断进入这里说明替代节点p没有孩子--------------这里表示没有孩子则直接删除（1）</span>
	        <span class="token comment">// 如果p的颜色是黑色，则调整红黑树</span>
	        <span class="token keyword">if</span> <span class="token punctuation">(</span>p<span class="token punctuation">.</span>color <span class="token operator">==</span> BLACK<span class="token punctuation">)</span>
	            <span class="token function">fixAfterDeletion</span><span class="token punctuation">(</span>p<span class="token punctuation">)</span><span class="token punctuation">;</span>
	        <span class="token comment">// 下面删除替代节点p</span>
	        <span class="token keyword">if</span> <span class="token punctuation">(</span>p<span class="token punctuation">.</span>parent <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
	            <span class="token comment">// 如果 p 是其父节点的左子节点</span>
	            <span class="token keyword">if</span> <span class="token punctuation">(</span>p <span class="token operator">==</span> p<span class="token punctuation">.</span>parent <span class="token punctuation">.</span>left<span class="token punctuation">)</span>
	                p<span class="token punctuation">.</span> parent<span class="token punctuation">.</span>left <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
	            <span class="token comment">//如果 p 是其父节点的右子节点    </span>
	            <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>p <span class="token operator">==</span> p<span class="token punctuation">.</span>parent<span class="token punctuation">.</span> right<span class="token punctuation">)</span>
	                p<span class="token punctuation">.</span> parent<span class="token punctuation">.</span>right <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
	            <span class="token comment">// 解除p对p父节点的引用</span>
	            p<span class="token punctuation">.</span> parent <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
	        <span class="token punctuation">}</span>
	    <span class="token punctuation">}</span>
	<span class="token punctuation">}</span>
	
	<span class="token comment">/**
	 * 查找要删除节点的替代节点
	 */</span>
	<span class="token keyword">static</span> <span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span> <span class="token class-name">TreeMap<span class="token punctuation">.</span>Entry</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span> <span class="token function">successor</span><span class="token punctuation">(</span><span class="token class-name">Entry</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span> t<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
	    <span class="token keyword">if</span> <span class="token punctuation">(</span>t <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span>
	        <span class="token keyword">return</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
	    <span class="token comment">// 查找右子树的最左孩子</span>
	    <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>t<span class="token punctuation">.</span>right <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
	        <span class="token class-name">Entry</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span> p <span class="token operator">=</span> t<span class="token punctuation">.</span> right<span class="token punctuation">;</span>
	        <span class="token keyword">while</span> <span class="token punctuation">(</span>p<span class="token punctuation">.</span>left <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span>
	            p <span class="token operator">=</span> p<span class="token punctuation">.</span> left<span class="token punctuation">;</span>
	        <span class="token keyword">return</span> p<span class="token punctuation">;</span>
	    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{<!-- --></span> <span class="token comment">// 查找左子树的最右孩子</span>
	        <span class="token class-name">Entry</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span> p <span class="token operator">=</span> t<span class="token punctuation">.</span> parent<span class="token punctuation">;</span>
	        <span class="token class-name">Entry</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span> ch <span class="token operator">=</span> t<span class="token punctuation">;</span>
	        <span class="token keyword">while</span> <span class="token punctuation">(</span>p <span class="token operator">!=</span> <span class="token keyword">null</span> <span class="token operator">&amp;&amp;</span> ch <span class="token operator">==</span> p<span class="token punctuation">.</span> right<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
	            ch <span class="token operator">=</span> p<span class="token punctuation">;</span>
	            p <span class="token operator">=</span> p<span class="token punctuation">.</span> parent<span class="token punctuation">;</span>
	        <span class="token punctuation">}</span>
	        <span class="token keyword">return</span> p<span class="token punctuation">;</span>
	    <span class="token punctuation">}</span>
	<span class="token punctuation">}</span>
	
	<span class="token comment">/**删除节点后修复红黑树 */</span>
	<span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">fixAfterDeletion</span><span class="token punctuation">(</span><span class="token class-name">Entry</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span> x<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
	    <span class="token comment">// 直到 x 不是根节点，且 x 的颜色是黑色</span>
	    <span class="token keyword">while</span> <span class="token punctuation">(</span>x <span class="token operator">!=</span> root <span class="token operator">&amp;&amp;</span> colorOf <span class="token punctuation">(</span>x<span class="token punctuation">)</span> <span class="token operator">==</span> BLACK<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
	        <span class="token comment">// 如果 x 是其父节点的左子节点</span>
	        <span class="token keyword">if</span> <span class="token punctuation">(</span>x <span class="token operator">==</span> <span class="token function">leftOf</span><span class="token punctuation">(</span> <span class="token function">parentOf</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
	            <span class="token comment">// 获取 x 节点的兄弟节点</span>
	            <span class="token class-name">Entry</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span> sib <span class="token operator">=</span> <span class="token function">rightOf</span><span class="token punctuation">(</span>parentOf <span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	
	            <span class="token comment">// 如果 sib 节点是红色</span>
	            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">colorOf</span><span class="token punctuation">(</span>sib<span class="token punctuation">)</span> <span class="token operator">==</span> RED<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
	                <span class="token comment">// 将 sib 节点设为黑色</span>
	                <span class="token function">setColor</span><span class="token punctuation">(</span>sib<span class="token punctuation">,</span> BLACK<span class="token punctuation">)</span><span class="token punctuation">;</span>
	                <span class="token comment">// 将 x 的父节点设为红色</span>
	                <span class="token function">setColor</span><span class="token punctuation">(</span>parentOf <span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">,</span> RED<span class="token punctuation">)</span><span class="token punctuation">;</span>
	                <span class="token comment">// 左旋x的父节点</span>
	                <span class="token function">rotateLeft</span><span class="token punctuation">(</span> <span class="token function">parentOf</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	                <span class="token comment">// 再次将 sib 设为 x 的父节点的右子节点</span>
	                sib <span class="token operator">=</span> <span class="token function">rightOf</span><span class="token punctuation">(</span>parentOf <span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	            <span class="token punctuation">}</span>
	
	            <span class="token comment">// 如果 sib 的两个子节点都是黑色</span>
	            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">colorOf</span><span class="token punctuation">(</span><span class="token function">leftOf</span><span class="token punctuation">(</span>sib<span class="token punctuation">)</span><span class="token punctuation">)</span>  <span class="token operator">==</span> BLACK <span class="token operator">&amp;&amp;</span>
	                <span class="token function">colorOf</span><span class="token punctuation">(</span>rightOf <span class="token punctuation">(</span>sib<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">==</span> BLACK<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
	                <span class="token comment">// 将 sib 设为红色</span>
	                <span class="token function">setColor</span><span class="token punctuation">(</span>sib<span class="token punctuation">,</span> RED<span class="token punctuation">)</span><span class="token punctuation">;</span>
	                <span class="token comment">// 让 x 等于 x 的父节点</span>
	                x <span class="token operator">=</span> <span class="token function">parentOf</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span>
	            <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{<!-- --></span>
	                <span class="token comment">// 如果 sib 的只有右子节点是黑色</span>
	                <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">colorOf</span><span class="token punctuation">(</span><span class="token function">rightOf</span><span class="token punctuation">(</span>sib<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">==</span> BLACK<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
	                    <span class="token comment">// 将 sib 的左子节点也设为黑色</span>
	                    <span class="token function">setColor</span><span class="token punctuation">(</span>leftOf <span class="token punctuation">(</span>sib<span class="token punctuation">)</span><span class="token punctuation">,</span> BLACK<span class="token punctuation">)</span><span class="token punctuation">;</span>
	                    <span class="token comment">// 将 sib 设为红色</span>
	                    <span class="token function">setColor</span><span class="token punctuation">(</span>sib<span class="token punctuation">,</span> RED<span class="token punctuation">)</span><span class="token punctuation">;</span>
	                    <span class="token comment">// 右旋x的兄弟节点</span>
	                    <span class="token function">rotateRight</span><span class="token punctuation">(</span>sib<span class="token punctuation">)</span><span class="token punctuation">;</span>
	                    <span class="token comment">// 将sib重新指向旋转后x的兄弟节点，进入步奏⑤</span>
	                    sib <span class="token operator">=</span> <span class="token function">rightOf</span><span class="token punctuation">(</span>parentOf <span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	                <span class="token punctuation">}</span>
	                <span class="token comment">// 设置 sib 的颜色与 x 的父节点的颜色相同</span>
	                <span class="token function">setColor</span><span class="token punctuation">(</span>sib<span class="token punctuation">,</span> colorOf <span class="token punctuation">(</span><span class="token function">parentOf</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	                <span class="token comment">// 将 x 的父节点设为黑色</span>
	                <span class="token function">setColor</span><span class="token punctuation">(</span>parentOf <span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">,</span> BLACK<span class="token punctuation">)</span><span class="token punctuation">;</span>
	                <span class="token comment">// 将 sib 的右子节点设为黑色</span>
	                <span class="token function">setColor</span><span class="token punctuation">(</span>rightOf <span class="token punctuation">(</span>sib<span class="token punctuation">)</span><span class="token punctuation">,</span> BLACK<span class="token punctuation">)</span><span class="token punctuation">;</span>
	                <span class="token comment">// 左旋x的父节点</span>
	                <span class="token function">rotateLeft</span><span class="token punctuation">(</span> <span class="token function">parentOf</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	                <span class="token comment">// 达到平衡，将x指向root，退出循环</span>
	                x <span class="token operator">=</span> root<span class="token punctuation">;</span>
	            <span class="token punctuation">}</span>
	        <span class="token comment">// 如果 x 是其父节点的右子节点    </span>
	        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{<!-- --></span>
	            <span class="token comment">// 获取 x 节点的兄弟节点</span>
	            <span class="token class-name">Entry</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span> sib <span class="token operator">=</span> <span class="token function">leftOf</span><span class="token punctuation">(</span>parentOf <span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	            <span class="token comment">// 如果 sib 的颜色是红色</span>
	            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">colorOf</span><span class="token punctuation">(</span>sib<span class="token punctuation">)</span> <span class="token operator">==</span> RED<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
	                <span class="token comment">// 将 sib 的颜色设为黑色</span>
	                <span class="token function">setColor</span><span class="token punctuation">(</span>sib<span class="token punctuation">,</span> BLACK<span class="token punctuation">)</span><span class="token punctuation">;</span>
	                <span class="token comment">// 将 sib 的父节点设为红色</span>
	                <span class="token function">setColor</span><span class="token punctuation">(</span>parentOf <span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">,</span> RED<span class="token punctuation">)</span><span class="token punctuation">;</span>
	                <span class="token function">rotateRight</span><span class="token punctuation">(</span> <span class="token function">parentOf</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	                sib <span class="token operator">=</span> <span class="token function">leftOf</span><span class="token punctuation">(</span>parentOf <span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	            <span class="token punctuation">}</span>
	            <span class="token comment">// 如果 sib 的两个子节点都是黑色</span>
	            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">colorOf</span><span class="token punctuation">(</span><span class="token function">rightOf</span><span class="token punctuation">(</span>sib<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">==</span> BLACK <span class="token operator">&amp;&amp;</span>
	                <span class="token function">colorOf</span><span class="token punctuation">(</span>leftOf <span class="token punctuation">(</span>sib<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">==</span> BLACK<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
	                <span class="token comment">// 将 sib 设为红色</span>
	                <span class="token function">setColor</span><span class="token punctuation">(</span>sib<span class="token punctuation">,</span> RED<span class="token punctuation">)</span><span class="token punctuation">;</span>
	                <span class="token comment">// 让 x 等于 x 的父节点</span>
	                x <span class="token operator">=</span> <span class="token function">parentOf</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span>
	            <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{<!-- --></span>
	                <span class="token comment">// 如果 sib 只有左子节点是黑色</span>
	                <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">colorOf</span><span class="token punctuation">(</span><span class="token function">leftOf</span><span class="token punctuation">(</span>sib<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">==</span> BLACK<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
	                    <span class="token comment">// 将 sib 的右子节点也设为黑色</span>
	                    <span class="token function">setColor</span><span class="token punctuation">(</span>rightOf <span class="token punctuation">(</span>sib<span class="token punctuation">)</span><span class="token punctuation">,</span> BLACK<span class="token punctuation">)</span><span class="token punctuation">;</span>
	                    <span class="token comment">// 将 sib 设为红色</span>
	                    <span class="token function">setColor</span><span class="token punctuation">(</span>sib<span class="token punctuation">,</span> RED<span class="token punctuation">)</span><span class="token punctuation">;</span>
	                    <span class="token function">rotateLeft</span><span class="token punctuation">(</span>sib<span class="token punctuation">)</span><span class="token punctuation">;</span>
	                    sib <span class="token operator">=</span> <span class="token function">leftOf</span><span class="token punctuation">(</span>parentOf <span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	                <span class="token punctuation">}</span>
	                <span class="token comment">// 将 sib 的颜色设为与 x 的父节点颜色相同</span>
	                <span class="token function">setColor</span><span class="token punctuation">(</span>sib<span class="token punctuation">,</span> colorOf <span class="token punctuation">(</span><span class="token function">parentOf</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	                <span class="token comment">// 将 x 的父节点设为黑色</span>
	                <span class="token function">setColor</span><span class="token punctuation">(</span>parentOf <span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">,</span> BLACK<span class="token punctuation">)</span><span class="token punctuation">;</span>
	                <span class="token comment">// 将 sib 的左子节点设为黑色</span>
	                <span class="token function">setColor</span><span class="token punctuation">(</span>leftOf <span class="token punctuation">(</span>sib<span class="token punctuation">)</span><span class="token punctuation">,</span> BLACK<span class="token punctuation">)</span><span class="token punctuation">;</span>
	                <span class="token function">rotateRight</span><span class="token punctuation">(</span> <span class="token function">parentOf</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	                x <span class="token operator">=</span> root<span class="token punctuation">;</span>
	            <span class="token punctuation">}</span>
	        <span class="token punctuation">}</span>
	    <span class="token punctuation">}</span>
	
	    <span class="token function">setColor</span><span class="token punctuation">(</span>x<span class="token punctuation">,</span> BLACK<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
</code></pre> 
<p>  与添加节点之后的修复类似的是，TreeMap删除节点之后也需要进行类似的修复操作，通过这种修复来保证该排序二叉树依然满足红黑树特征。可以参考插入节点之后的修复来分析删除之后的修复。</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/f2939ec9a51a850b55da91051bf06405/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">机器学习-案例：流行电影统计</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/a64f4bdebdb3ba0bcc15a8a11a553076/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">MySQL十部曲之四：MySQL中的数据类型</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>