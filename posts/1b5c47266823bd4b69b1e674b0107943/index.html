<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>vue rules 表单验证_Vue 面向对象编程 —— 领域驱动 表单 - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="vue rules 表单验证_Vue 面向对象编程 —— 领域驱动 表单" />
<meta property="og:description" content="前文说到用抽象类做自顶向下的开发，稍稍有些复杂，现在的新思潮其实已经不推荐采用抽象类，继承等概念了
为什么呢？
因为组合优于继承
因为继承一定程度打破了类的封装性，而且还由于一系列的复杂的用法——抽象方法，多继承，钻石继承等——导致维护成本上升
但这并不意味着继承是无用的，继承最主要作用在架构上
继承可以作为架构师发力的工具，比如 enterprise-architecture 自动生成抽象类等用法 总结一句话：
继承是用来限制人用的
而现在，第三方库很丰富，普通人不考虑架构也可以做出功能多样的应用，再加上云服务等新型开发模式出现
按照功能领域划分代码结构比按照观念划分结构更适合
比如之前的表单，我们不需要考虑一个表单真的有那些功能，只需要实现最核心的功能即可，利用类的极强扩展性，将其它功能附加进来即可
这实际上是自顶向下和自底向上的思维方式区别，二者没有优劣之分，一般来说，分析问题时自顶向下，解决问题时自底向上，同时也分别是面向对象和函数式发力的地方 一个表单，最重要的就是 表单项 到 数据模型 的绑定和同步
还是用表单做例子哈，因为一个 UI 框架，最重要的就只有三个： 表单，表格，浮动层 我们希望实现的目标是（再重温一遍哈）：
整个表单只有一个输入 initialValue，和一个输出 handleChange，包含数据模型结构，表单项绑定，都自动完成，并且要考虑表单嵌套的情况
之所以这么封装，目的是保证
所见即所得 使得使用者的负担降到最低
这次按照领域来开发，FormService 和 FormItemService 只包含最小功能集合：
每个表单有个独立的注入口令，也有一个公共的注入口令
Form 组件在注入相关服务时，需要注入两遍实体：
为什么要注入两遍呢？
静态属性的注入口令是特定的，只要是 Form 都是如此，保证每个 FormItem 拿到的都是离他最近的父组件 Form
但是如果我想要指定某个 FormItem 是特定 Form 的项目怎么办？
很简单，传入相关令牌即可：
const 第一个 FormItem 属于表单 form1，第二个 FormItem 属于表单 form2，相关结构绑定也是如此
因此，FormItemService 实现如下：
注意 data 绑定 的 toRef 方法
按照官方的说法：
相当于它是 form.model 的一个代理对象，通过设置其 value 就可以做到更改 form." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/1b5c47266823bd4b69b1e674b0107943/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2020-11-22T02:31:35+08:00" />
<meta property="article:modified_time" content="2020-11-22T02:31:35+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">vue rules 表单验证_Vue 面向对象编程 —— 领域驱动 表单</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <div> 
 <p></p> 
 <div style="text-align:center;"> 
  <img src="https://images2.imgbox.com/3f/15/3CRyDKh2_o.png" alt="2f55e2eb10342a3802322493a77614c2.png"> 
 </div> 
 <p>前文说到用抽象类做自顶向下的开发，稍稍有些复杂，现在的新思潮其实已经不推荐采用抽象类，继承等概念了</p> 
 <p>为什么呢？</p> 
 <p>因为组合优于继承</p> 
 <p>因为<b>继承一定程度打破了类的封装性</b>，而且还由于一系列的复杂的用法——抽象方法，多继承，钻石继承等——导致维护成本上升</p> 
 <p>但这并不意味着继承是无用的，继承最主要作用在架构上</p> 
 <blockquote>
   继承可以作为架构师发力的工具，比如 enterprise-architecture 自动生成抽象类等用法 
 </blockquote> 
 <p>总结一句话：</p> 
 <p><b>继承是用来限制人用的</b></p> 
 <p>而现在，第三方库很丰富，普通人不考虑架构也可以做出功能多样的应用，再加上云服务等新型开发模式出现</p> 
 <p>按照<b>功能领域</b>划分代码结构比按照观念划分结构更适合</p> 
 <p>比如之前的表单，我们不需要考虑一个表单真的有那些功能，只需要实现最核心的功能即可，利用类的极强扩展性，将其它功能附加进来即可</p> 
 <blockquote>
   这实际上是自顶向下和自底向上的思维方式区别，二者没有优劣之分，一般来说，分析问题时自顶向下，解决问题时自底向上，同时也分别是面向对象和函数式发力的地方 
 </blockquote> 
 <p>一个表单，最重要的就是 <b>表单项 到 数据模型 的绑定和同步</b></p> 
 <blockquote>
   还是用表单做例子哈，因为一个 UI 框架，最重要的就只有三个： 
  <br>表单，表格，浮动层 
 </blockquote> 
 <p>我们希望实现的目标是（再重温一遍哈）：</p> 
 <p></p> 
 <div style="text-align:center;"> 
  <img src="https://images2.imgbox.com/00/4f/EGQ5GBD7_o.png" alt="84422114662355e6e262a07ad95c3613.png"> 
 </div> 
 <p>整个表单只有一个输入 initialValue，和一个输出 handleChange，包含数据模型结构，表单项绑定，都自动完成，并且要考虑表单嵌套的情况</p> 
 <p>之所以这么封装，目的是保证</p> 
 <h3>所见即所得</h3> 
 <p>使得使用者的负担降到最低</p> 
 <p>这次按照领域来开发，FormService 和 FormItemService 只包含最小功能集合：</p> 
 <p></p> 
 <div style="text-align:center;"> 
  <img src="https://images2.imgbox.com/b6/5a/84yAvomp_o.png" alt="1cd07d91ab135a2c12ebb8b9ab07e375.png"> 
 </div> 
 <p>每个表单有个独立的注入口令，也有一个公共的注入口令</p> 
 <p>Form 组件在注入相关服务时，需要注入两遍实体：</p> 
 <p></p> 
 <div style="text-align:center;"> 
  <img src="https://images2.imgbox.com/e3/74/gYHKVTEs_o.png" alt="45c16516cae129d8db782c7f5ce4f256.png"> 
 </div> 
 <p>为什么要注入两遍呢？</p> 
 <p>静态属性的注入口令是特定的，只要是 Form 都是如此，保证每个 FormItem 拿到的都是离他最近的父组件 Form</p> 
 <p>但是如果我想要指定某个 FormItem 是特定 Form 的项目怎么办？</p> 
 <p>很简单，传入相关令牌即可：</p> 
 <div class="has"> 
  <pre class="has"><code>const </code></pre> 
 </div> 
 <p>第一个 FormItem 属于表单 form1，第二个 FormItem 属于表单 form2，相关结构绑定也是如此</p> 
 <p>因此，FormItemService 实现如下：</p> 
 <p></p> 
 <div style="text-align:center;"> 
  <img src="https://images2.imgbox.com/02/8c/vhkXQNoI_o.png" alt="213bcfeb593cb3b0e103446ff7ffff13.png"> 
 </div> 
 <p>注意 data 绑定 的 <b>toRef 方法</b></p> 
 <p>按照官方的说法：</p> 
 <p></p> 
 <div style="text-align:center;"> 
  <img src="https://images2.imgbox.com/6c/88/ym9Kfgjn_o.png" alt="e12523e7d3bf955f76478fa582cfd997.png"> 
 </div> 
 <p>相当于它是 form.model 的一个代理对象，通过设置其 value 就可以做到更改 form.model 某个字段的目的</p> 
 <hr> 
 <p>接下来是重头戏了，如何做到不对表单项进行 v-model 绑定就可以实现表单项和 model 的绑定呢？</p> 
 <p></p> 
 <div style="text-align:center;"> 
  <img src="https://images2.imgbox.com/ca/ba/zPmbJ2nS_o.png" alt="78d6ebc0951333abbac78694cc4d8bf5.png"> 
 </div> 
 <p>这里<b>必须使用 render</b>，单纯用模板无法实现相关功能需求</p> 
 <p>因为 Vue 3 的 this.$slots 拿到的不是vnode数据，而是vnode函数，需要运行之后才能获取数据，而运行时机由 Vue 控制</p> 
 <p>将 formItemService 的 data 绑定进 slot 的参数，注意，data 是个 Ref</p> 
 <p>这里涉及一个重要概念 ——</p> 
 <h3>ref 的 props 传递</h3> 
 <p>由于 Vue 模板的自动 value 绑定，这里可以肯定将成为 vue3 的一个难点</p> 
 <p>ref 是个代理对象，你在子组件 ref.value = xxx ，其实和 在父组件 ref.value = xxx 并没有任何区别</p> 
 <p><b>因为 ref 是脱离组件响应式单独存在的</b></p> 
 <p>是的，之前要你牢记单向数据流，而现在要求你一定程度地忘记它，双向绑定因此也有两种方式：</p> 
 <ul><li>v-model 针对具体数据和操作方法的双向绑定</li><li>props 传递 ref 的针对 Proxy 的双向绑定</li></ul> 
 <p>采用后者，一定要<b>保证这个 ref 不要与任何其它组件数据产生依赖</b></p> 
 <p>因为绑定表单项的方式是用 $slots 的 default vnode，传入 props ，你并不知道 render 会运行多少次，无法采用第一种传递事件的方式，只能采用 ref 传递</p> 
 <p>所以，需要表单项也采用这个方式——props传递ref——实现双向绑定：</p> 
 <p></p> 
 <div style="text-align:center;"> 
  <img src="https://images2.imgbox.com/e7/12/U2yaBKW5_o.png" alt="8cdab8e9e8bbea53d13515b0938ce9f4.png"> 
 </div> 
 <p>注意那个 ctx.attrs ,这个涉及 vnode 的参数问题，请自信查阅新版差异：</p> 
 <p></p> 
 <div style="text-align:center;"> 
  <img src="https://images2.imgbox.com/2e/4b/rAWaL2tm_o.png" alt="f40b245c3f2e194e7cbe15c11c6745f3.png"> 
 </div> 
 <p>当然，这种方式也可以与 v-model 共存</p> 
 <p>之后再实现 FormItemRulesService，只要保证依赖于 FormItemService 就可以实现 rules 功能了</p> 
 <p>大家可以思考以下，props 传递 ref 和 v-model 到底哪个好？</p> 
 <p>我是认为 props 更好，响应式编程会稍微难点，但是更直观，少写好多代码，你认为呢？</p> 
 <p>以上</p> 
 https://codesandbox.io/s/boring-bose-3frgd?file=/src/App.vue​codesandbox.io 
</div>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/b9b38b63d89e18bb0108dbd96a1a757d/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">arcgis字段计算器赋值_ARCGIS操作技巧总结</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/a4f96eb1904f924c7bdea00315850d6e/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">python 占位符_详解Python操作PPT的各种骚操作！</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>