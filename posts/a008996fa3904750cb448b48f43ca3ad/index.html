<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>C&#43;&#43; stl -- stack / queue / priority_queue - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="C&#43;&#43; stl -- stack / queue / priority_queue" />
<meta property="og:description" content="目录
前言
一、stack
1.1 stack的使用
1.2stack的模拟实现
二、queue
2.1queue的使用
2.2queue的模拟实现
2.3容器适配器
三、deque
3.1vector ， list的优缺点
3.2deque的原理介绍
3.3deque--插入
3.4deque的接口
四、priority_queue
4.1priority_queue的使用
4.2模拟实现
五、仿函数/函数对象
5.1仿函数的实现
5.2仿函数的使用
前言 C语言学习阶段中学习过栈和队列两大基础数据结构 ，只不过C语言中需要自己造轮子 ， c&#43;&#43;的stl不仅给我们提供了stack和queue，还提供了一种基于堆的优先级队列--priority_queue ，通过对于这三个序列式容器的学习可以对于适配器和仿函数有更好的理解。
一、stack 1.1 stack的使用 stack的常用接口如下
functionexplanationstack()constructorempty()判断是否空size()返回栈中元素个数top()返回栈顶元素push()压栈pop()弹栈 1.2stack的模拟实现 这里我们使用vector作为我们的适配器，我们阅览源码会发现用的是deque ， deque是一种既能满足任意位置0(1)插入又能随机访问的一种数据结构 ，后续详解
template&lt;class T, class Container = vector&lt;T&gt;&gt;
class stack
{
public:
void push(const T&amp; val)
{
_con.push_back(val);
}
void pop()
{
_con.pop_back();
}
bool empty()
{
return _con.empty();
}
T&amp; top()" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/a008996fa3904750cb448b48f43ca3ad/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-10-14T17:07:24+08:00" />
<meta property="article:modified_time" content="2023-10-14T17:07:24+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">C&#43;&#43; stl -- stack / queue / priority_queue</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p id="main-toc"><strong>目录</strong></p> 
<p id="-toc" style="margin-left:0px;"></p> 
<p id="%E5%89%8D%E8%A8%80-toc" style="margin-left:0px;"><a href="#%E5%89%8D%E8%A8%80" rel="nofollow">前言</a></p> 
<p id="%E4%B8%80%E3%80%81stack-toc" style="margin-left:40px;"><a href="#%E4%B8%80%E3%80%81stack" rel="nofollow">一、stack</a></p> 
<p id="1.1%20stack%E7%9A%84%E4%BD%BF%E7%94%A8-toc" style="margin-left:80px;"><a href="#1.1%20stack%E7%9A%84%E4%BD%BF%E7%94%A8" rel="nofollow">1.1 stack的使用</a></p> 
<p id="%C2%A01.2stack%E7%9A%84%E6%A8%A1%E6%8B%9F%E5%AE%9E%E7%8E%B0-toc" style="margin-left:80px;"><a href="#%C2%A01.2stack%E7%9A%84%E6%A8%A1%E6%8B%9F%E5%AE%9E%E7%8E%B0" rel="nofollow"> 1.2stack的模拟实现</a></p> 
<p id="%E4%BA%8C%E3%80%81queue-toc" style="margin-left:40px;"><a href="#%E4%BA%8C%E3%80%81queue" rel="nofollow">二、queue</a></p> 
<p id="2.1queue%E7%9A%84%E4%BD%BF%E7%94%A8-toc" style="margin-left:80px;"><a href="#2.1queue%E7%9A%84%E4%BD%BF%E7%94%A8" rel="nofollow">2.1queue的使用</a></p> 
<p id="2.2queue%E7%9A%84%E6%A8%A1%E6%8B%9F%E5%AE%9E%E7%8E%B0-toc" style="margin-left:80px;"><a href="#2.2queue%E7%9A%84%E6%A8%A1%E6%8B%9F%E5%AE%9E%E7%8E%B0" rel="nofollow">2.2queue的模拟实现</a></p> 
<p id="2.3%E5%AE%B9%E5%99%A8%E9%80%82%E9%85%8D%E5%99%A8-toc" style="margin-left:80px;"><a href="#2.3%E5%AE%B9%E5%99%A8%E9%80%82%E9%85%8D%E5%99%A8" rel="nofollow">2.3容器适配器</a></p> 
<p id="%E4%B8%89%E3%80%81deque-toc" style="margin-left:40px;"><a href="#%E4%B8%89%E3%80%81deque" rel="nofollow">三、deque</a></p> 
<p id="3.1vector%20%EF%BC%8C%20list%E7%9A%84%E4%BC%98%E7%BC%BA%E7%82%B9-toc" style="margin-left:80px;"><a href="#3.1vector%20%EF%BC%8C%20list%E7%9A%84%E4%BC%98%E7%BC%BA%E7%82%B9" rel="nofollow">3.1vector ， list的优缺点</a></p> 
<p id="3.2deque%E7%9A%84%E5%8E%9F%E7%90%86%E4%BB%8B%E7%BB%8D-toc" style="margin-left:80px;"><a href="#3.2deque%E7%9A%84%E5%8E%9F%E7%90%86%E4%BB%8B%E7%BB%8D" rel="nofollow">3.2deque的原理介绍</a></p> 
<p id="3.3deque--%E6%8F%92%E5%85%A5-toc" style="margin-left:80px;"><a href="#3.3deque--%E6%8F%92%E5%85%A5" rel="nofollow">3.3deque--插入</a></p> 
<p id="3.4deque%E7%9A%84%E6%8E%A5%E5%8F%A3-toc" style="margin-left:80px;"><a href="#3.4deque%E7%9A%84%E6%8E%A5%E5%8F%A3" rel="nofollow">3.4deque的接口</a></p> 
<p id="%E5%9B%9B%E3%80%81priority_queue-toc" style="margin-left:40px;"><a href="#%E5%9B%9B%E3%80%81priority_queue" rel="nofollow">四、priority_queue</a></p> 
<p id="4.1priority_queue%E7%9A%84%E4%BD%BF%E7%94%A8-toc" style="margin-left:80px;"><a href="#4.1priority_queue%E7%9A%84%E4%BD%BF%E7%94%A8" rel="nofollow">4.1priority_queue的使用</a></p> 
<p id="4.2%E6%A8%A1%E6%8B%9F%E5%AE%9E%E7%8E%B0-toc" style="margin-left:80px;"><a href="#4.2%E6%A8%A1%E6%8B%9F%E5%AE%9E%E7%8E%B0" rel="nofollow">4.2模拟实现</a></p> 
<p id="%E4%BA%94%E3%80%81%E4%BB%BF%E5%87%BD%E6%95%B0%2F%E5%87%BD%E6%95%B0%E5%AF%B9%E8%B1%A1-toc" style="margin-left:40px;"><a href="#%E4%BA%94%E3%80%81%E4%BB%BF%E5%87%BD%E6%95%B0%2F%E5%87%BD%E6%95%B0%E5%AF%B9%E8%B1%A1" rel="nofollow">五、仿函数/函数对象</a></p> 
<p id="5.1%E4%BB%BF%E5%87%BD%E6%95%B0%E7%9A%84%E5%AE%9E%E7%8E%B0-toc" style="margin-left:80px;"><a href="#5.1%E4%BB%BF%E5%87%BD%E6%95%B0%E7%9A%84%E5%AE%9E%E7%8E%B0" rel="nofollow">5.1仿函数的实现</a></p> 
<p id="5.2%E4%BB%BF%E5%87%BD%E6%95%B0%E7%9A%84%E4%BD%BF%E7%94%A8-toc" style="margin-left:80px;"><a href="#5.2%E4%BB%BF%E5%87%BD%E6%95%B0%E7%9A%84%E4%BD%BF%E7%94%A8" rel="nofollow">5.2仿函数的使用</a></p> 
<hr id="hr-toc"> 
<p></p> 
<h2 id="%E5%89%8D%E8%A8%80">前言</h2> 
<p>C语言学习阶段中学习过栈和队列两大基础数据结构 ，只不过C语言中需要自己造轮子 ， c++的stl不仅给我们提供了stack和queue，还提供了一种基于堆的优先级队列--priority_queue ，通过对于这三个序列式容器的学习可以对于适配器和仿函数有更好的理解。</p> 
<hr> 
<h3 id="%E4%B8%80%E3%80%81stack">一、stack</h3> 
<p><img alt="" height="244" src="https://images2.imgbox.com/58/c1/Nw607yTW_o.png" width="813"></p> 
<p></p> 
<h4 id="1.1%20stack%E7%9A%84%E4%BD%BF%E7%94%A8">1.1 stack的使用</h4> 
<p>stack的常用接口如下</p> 
<table border="1" cellpadding="1" cellspacing="1" style="width:500px;"><tbody><tr><td>function</td><td>explanation</td></tr><tr><td>stack()</td><td>constructor</td></tr><tr><td>empty()</td><td>判断是否空</td></tr><tr><td>size()</td><td>返回栈中元素个数</td></tr><tr><td>top()</td><td>返回栈顶元素</td></tr><tr><td>push()</td><td>压栈</td></tr><tr><td>pop()</td><td>弹栈</td></tr></tbody></table> 
<h4 id="%C2%A01.2stack%E7%9A%84%E6%A8%A1%E6%8B%9F%E5%AE%9E%E7%8E%B0"> 1.2stack的模拟实现</h4> 
<p>这里我们使用vector作为我们的适配器，我们阅览源码会发现用的是deque ， deque是一种既能满足任意位置0(1)插入又能随机访问的一种数据结构 ，后续详解</p> 
<blockquote> 
 <p>    template&lt;class T, class Container = vector&lt;T&gt;&gt;<br>     class stack<br>     {<!-- --><br>     public:<br>         void push(const T&amp; val)<br>         {<!-- --><br>             _con.push_back(val);<br>         }<br>         void pop()<br>         {<!-- --><br>             _con.pop_back();<br>         }<br>         bool empty()<br>         {<!-- --><br>             return _con.empty();<br>         }<br>         T&amp; top()<br>         {<!-- --><br>             return _con.back();<br>         }<br>         size_t size()<br>         {<!-- --><br>             return _con.size();<br>         }<br>     private:<br>         Container _con;<br>     }<br>     ;</p> 
</blockquote> 
<h3 id="%E4%BA%8C%E3%80%81queue">二、queue</h3> 
<p>队列专门用于在FIFO上下文(先进先出)中操作，其中从容器一端插入元素，另一端提取元素。</p> 
<p><img alt="" height="270" src="https://images2.imgbox.com/96/6c/kHSAifoE_o.png" width="1091"></p> 
<h4 id="2.1queue%E7%9A%84%E4%BD%BF%E7%94%A8">2.1queue的使用</h4> 
<table border="1" cellpadding="1" cellspacing="1" style="width:500px;"><tbody><tr><td>function</td><td>explanation</td></tr><tr><td>queue()</td><td>constructor</td></tr><tr><td>empty()</td><td>检验是否为空</td></tr><tr><td>size()</td><td>返回有效元素个数</td></tr><tr><td>front()</td><td>返回队头元素引用</td></tr><tr><td>back()</td><td>返回队尾元素引用</td></tr><tr><td>push()</td><td>入队</td></tr><tr><td>pop()</td><td>出队</td></tr></tbody></table> 
<h4 id="2.2queue%E7%9A%84%E6%A8%A1%E6%8B%9F%E5%AE%9E%E7%8E%B0">2.2queue的模拟实现</h4> 
<blockquote> 
 <p>template&lt;class T, class Container = list&lt;T&gt;&gt;<br>     class queue<br>     {<!-- --><br>     public:<br>         void push(const T&amp; val)<br>         {<!-- --><br>             _con.push_back(val);<br>         }<br>         void pop()<br>         {<!-- --><br>             _con.pop_front();<br>         }<br>         size_t size()<br>         {<!-- --><br>             return _con.size();<br>         }<br>         T&amp; front()<br>         {<!-- --><br>             return _con.front();<br>         }<br>         T&amp; back()<br>         {<!-- --><br>             return _con.back();<br>         }<br>         bool empty()<br>         {<!-- --><br>             return _con.empty();<br>         }<br>     private:<br>         Container _con;<br>     }<br>     ;</p> 
</blockquote> 
<h4 id="2.3%E5%AE%B9%E5%99%A8%E9%80%82%E9%85%8D%E5%99%A8">2.3容器适配器</h4> 
<p>适配器是一种<strong>设计模式</strong>(设计模式是一套被反复使用的、多数人知晓的、经过分类编目的、代码设计经验的总结)，该种模式是<strong>将一个类的接口转换成客户希望的另外一个接口。</strong></p> 
<p>设计模式的使用将提高软件系统的开发效率和软件质量，节省开发成本。有助于初学者深入理解面向对象思想，设计模式使设计方案更加灵活，方便后期维护修改。</p> 
<p>在stack，queue中 deque&lt;T&gt;接口转换到Container中。deque是什么呢？我们不是说stack可以用vector，queue用list吗，怎么这里用的deque。<br>  </p> 
<h3 id="%E4%B8%89%E3%80%81deque">三、deque</h3> 
<p>在容器适配器为什么会选择deque，那么就必须得从vector，list的优缺点说起</p> 
<hr> 
<h4 id="3.1vector%20%EF%BC%8C%20list%E7%9A%84%E4%BC%98%E7%BC%BA%E7%82%B9">3.1vector ， list的优缺点</h4> 
<p><strong>vector:</strong></p> 
<blockquote> 
 <p>stack可以随机访问，但是头部中部插入删除效率低，并且还需要扩容</p> 
</blockquote> 
<p><strong>list:</strong></p> 
<blockquote> 
 <p>虽然queue在任何地方插入删除效率高，但是不支持随机访问，CPU高速缓存命中率低</p> 
</blockquote> 
<p>对于deque就完美兼容vector，list的优点。所以对于接口选择就是deque。</p> 
<h4 id="3.2deque%E7%9A%84%E5%8E%9F%E7%90%86%E4%BB%8B%E7%BB%8D">3.2deque的原理介绍</h4> 
<p>deque(双端队列)：是一种双开口的"连续"空间的数据结构，双开口的含义是：可以在头尾两端进行插入和 删除操作，且时间复杂度为O(1)，与vector比较，头插效率高，不需要搬移元素；与list比较，空间利用率比较高。</p> 
<p><img alt="" height="319" src="https://images2.imgbox.com/a7/95/W7UdPpKH_o.png" width="980"></p> 
<p>这个是deque一段的buffer数组，所以deque并不是真正连续的空间，它是由一段一段这样的buffer数组链接而成，一段一段的buffer数组被放在<strong>中控</strong>，这个中控就是一个指针数组，实际上deque类似于一个动态的二维数组， 如图：</p> 
<p><img alt="" height="606" src="https://images2.imgbox.com/7f/00/29ilFCdQ_o.png" width="729"></p> 
<p>这里的缓冲区就是buffer数组，用于存放数据。map就是中控器，就是存放指针。当map空间不够后，会再开辟一个中控-map。</p> 
<h4 id="3.3deque--%E6%8F%92%E5%85%A5">3.3deque--插入</h4> 
<p><strong>头插</strong></p> 
<p><img alt="" height="432" src="https://images2.imgbox.com/0a/58/WDKizdKR_o.png" width="968"></p> 
<p><strong> 尾插</strong></p> 
<p><img alt="" height="400" src="https://images2.imgbox.com/c2/ed/Uw1bXtyU_o.png" width="1112"></p> 
<p></p> 
<p><strong>查找：</strong></p> 
<p><strong>即相当于二维数组一样，先找map中的地址（第一层），然后在找buffer（第二层）</strong></p> 
<p><strong>缺点：</strong></p> 
<p>那么我们发现它下标访问有一定的消耗，没有vector快。当我们中间插入时候，它的中间插入的时候需要挪动数据，与list相比也是有消耗的。</p> 
<p>deque不适合遍历，因为在遍历时，deque的迭代器要频繁的去检测其是否移动到 某段小空间的边界，导致效率低下，而序列式场景中，可能需要经常遍历，因此在实际中，需要线性结构时，大多数情况下优先考虑vector和list，deque的应用并不多，而目前能看到的一个应用就是，STL用其作 为stack和queue的底层数据结构。</p> 
<p>我们通过发现deque其实是没有想象中那样完美的，它与<strong>vector和list相比是不够极致的</strong>。vector是吕布，list是诸葛亮，那么deque就是魏延。所以更多的时候我们更需要极致。</p> 
<p>deque的底层实现是比较复杂的，不仅仅是上诉简单两句的问题。<br><img alt="" height="422" src="https://images2.imgbox.com/59/a1/jFc7eIOJ_o.png" width="640"></p> 
<p> 根据上图，对于deque的维护是通过两个迭代器，start和finsh。因为deque是作为stack和queue的底层默认容器，一般来说deque是不需要进行中间插入的，那么start和finsh就很好的处理头插和尾插。它通过frist和last指向头尾，头插通过start的frist，如果满了node链接map新开辟buffer的指针位置。尾插通过finish的last控制。如果top()和back(),即通过start的cur和finish的cur控制。</p> 
<h4 id="3.4deque%E7%9A%84%E6%8E%A5%E5%8F%A3">3.4deque的接口</h4> 
<p><img alt="" height="128" src="https://images2.imgbox.com/6f/33/fPTRztza_o.png" width="1056"></p> 
<p><img alt="" height="270" src="https://images2.imgbox.com/66/95/lQqE2lny_o.png" width="1019"></p> 
<p><img alt="" height="181" src="https://images2.imgbox.com/6f/fd/BuDtQs49_o.png" width="1023"></p> 
<p><img alt="" height="149" src="https://images2.imgbox.com/36/05/7yjQVmE3_o.png" width="1018"></p> 
<p><img alt="" height="388" src="https://images2.imgbox.com/f9/9b/Eo4Oka1V_o.png" width="1016"></p> 
<p> 通过stack，queue的接口与deque的接口对比，发现直接调用deque是非常适合充当stack，queue的默认容器。stack，queue就是直接调用deque的接口。 </p> 
<h3 id="%E5%9B%9B%E3%80%81priority_queue">四、priority_queue</h3> 
<p>优先队列是一种容器适配器，而它实质就是堆。是否还记得堆是完全二叉树中用数组实现的，因为数组正好满足堆下标随机存取的需求，标准容器类vector和deque满足这些需求。默认情况下，如果没有为特定的priority_queue类实例化指定容器类，则使用vector。相对deque，vector更加极致。priority_queue是默认大根堆。</p> 
<h4 id="4.1priority_queue%E7%9A%84%E4%BD%BF%E7%94%A8" style="background-color:transparent;">4.1priority_queue的使用</h4> 
<p>priority_queue的使用来说也是比较简单的，接口也比较少。</p> 
<table border="1" cellpadding="1" cellspacing="1" style="width:500px;"><tbody><tr><td>函数声明</td><td>接口说明</td></tr><tr><td>priority_queue()/priority_queue(ﬁrst, last)</td><td>构造一个空的优先级队列</td></tr><tr><td>empty( )</td><td> <p>检测优先级队列是否为空，是返回true，否则返回</p> <p>false</p> </td></tr><tr><td>top( )</td><td>返回优先级队列中最大(最小元素)，即堆顶元素</td></tr><tr><td>push(x)</td><td>在优先级队列中插入元素</td></tr><tr><td>pop()</td><td>删除优先级队列中最大(最小)元素，即堆顶元素</td></tr></tbody></table> 
<p></p> 
<p>priority_queue与queue都是一个<a href="https://cplusplus.com/reference/queue/" rel="nofollow" title="头文件">头文件</a>。</p> 
<pre><code>priority_queue&lt;int, vector&lt;int&gt;, less&lt;int&gt;&gt; pq1;
    pq1.push(4);
    pq1.push(2);
    pq1.push(1);
    pq1.push(3);
    while (!pq1.empty())
    {
        cout &lt;&lt; pq1.top() &lt;&lt; " ";
        pq1.pop();
    }</code></pre> 
<blockquote> 
 <p>输出：4 3 2 1</p> 
</blockquote> 
<pre><code>    priority_queue&lt;int, vector&lt;int&gt;, greater&lt;int&gt;&gt; pq2;
    pq2.push(4);
    pq2.push(2);
    pq2.push(1);
    pq2.push(3);
    while (!pq2.empty())
    {
        cout &lt;&lt; pq2.top() &lt;&lt; " ";
        pq2.pop();
    }</code></pre> 
<blockquote> 
 <p>输出： 1 2 3 4</p> 
</blockquote> 
<h4 id="4.2%E6%A8%A1%E6%8B%9F%E5%AE%9E%E7%8E%B0" style="background-color:transparent;">4.2模拟实现</h4> 
<pre><code>    template&lt;class T&gt;
    struct less
    {
        bool operator()(const T&amp; x, const T&amp; y)
        {
            return x &lt; y;
        }
    };
    template&lt;class T, class Container = vector&lt;T&gt;, class cmp = less&lt;T&gt;&gt;
    class priority_queue
    {
    public:
        void push(const T&amp; x) {
            _con.push_back(x);
            AdjustUp(_con.size() - 1);
        }
        void pop() {
            swap(_con[0], _con[_con.size() - 1]);
            _con.pop_back();
            AdjustDown(0);
        }
        T&amp; top() {
            return _con[0];
        }
        size_t size()
        {
            return _con.size();
        }
        bool empty() {
            return _con.size() == 0;
        }
    private:
        void AdjustDown(int parent)
        {
            int child = parent * 2 + 1;
            while (child &lt; _con.size())
            {

                if (child + 1 &lt; _con.size() &amp;&amp; cmp()(_con[child], _con[child + 1]))
                {
                    ++child;
                }
                //if(_con[child] &lt; _con[parent])
                if (cmp()(_con[parent], _con[child]))
                {
                    swap(_con[child], _con[parent]);
                    parent = child;
                    child = parent * 2 + 1;
                }
                else
                {
                    break;
                }
            }
        }
        void AdjustUp(int child)
        {
            int parent = (child - 1) / 2;
            while (parent &gt;= 0)
            {
                //if(_con[parent] &gt; _con[child])
                if (cmp()(_con[parent], _con[child]))
                {
                    swap(_con[parent], _con[child]);
                    child = parent;
                    parent = (parent - 1) / 2;
                }
                else
                {
                    break;
                }
            }
        }
        Container _con;
    }
    ;</code></pre> 
<p>如果入队我们就向上调整，出队就向下调整</p> 
<p>整体的思想还是比较简单的</p> 
<h3 id="%E4%BA%94%E3%80%81%E4%BB%BF%E5%87%BD%E6%95%B0%2F%E5%87%BD%E6%95%B0%E5%AF%B9%E8%B1%A1">五、仿函数/函数对象</h3> 
<h4 id="5.1%E4%BB%BF%E5%87%BD%E6%95%B0%E7%9A%84%E5%AE%9E%E7%8E%B0">5.1仿函数的实现</h4> 
<p>其实就是struct重载了()</p> 
<pre><code>    template&lt;class T&gt;
    struct less
    {
        bool operator()(const T&amp; x, const T&amp; y)
        {
            return x &lt; y;
        }
    };
    template&lt;class T&gt;
    struct greater
    {
        bool operator()(const T&amp; x, const T&amp; y)
        {
            return x &gt; y;
        }
    };</code></pre> 
<h4 id="5.2%E4%BB%BF%E5%87%BD%E6%95%B0%E7%9A%84%E4%BD%BF%E7%94%A8">5.2仿函数的使用</h4> 
<p>冒泡排序</p> 
<pre><code>template &lt;class T&gt;
 
void BubbleSort(T* a, int n)
{
	for (int i = 0; i &lt; n; i++)
	{
		int flag = 0;
		for (int j = 1; j &lt; n - i; j++)
		{
			if (a[j - 1] &gt; a[j])
				swap(&amp;a[j - 1], &amp;a[j]);
			flag = 1;
		}
		if (flag == 0)
			break;
	}
}</code></pre> 
<p>在C语言时期，冒泡函数进行比较的时候，是需要进入冒泡函数内部改变"&gt;","&lt;"。或者是通过函数指针的方式，在多增加一个函数参数。</p> 
<p>方法一：</p> 
<blockquote> 
 <p>if (a[j - 1] &gt; a[j])        //改变其大与小</p> 
</blockquote> 
<p>对于封装的好的函数来说，这样对使用者是非常不友好的，那么就可以通过接口的方式，增加函数指针。</p> 
<p>方法二：</p> 
<blockquote> 
 <p>void BubbleSort(T* a, int n，bool（*pcom）(int,int))</p> 
</blockquote> 
<p>方法二的话，这个方法是比较搓的，使用的函数时需要传太多变量，阅读性也不够强。那么c++中函数模板就起到了重要的作用了。我们可以增加一个模板参数，再增加给函数的参数，通过类型的对象去比较，可以想函数一样去是使用。</p> 
<pre><code>template &lt;class T,class compaer&gt;
// 冒泡排序
void BubbleSort(T* a, int n,compaer com)
{
	for (int i = 0; i &lt; n; i++)
	{
		int flag = 0;
		for (int j = 1; j &lt; n - i; j++)
		{
			//if (a[j - 1] &gt; a[j])
			if (com(a[j - 1] , a[j]))
				swap(a[j - 1], a[j]);
			flag = 1;
		}
		if (flag == 0)
			break;
	}
}
 
void test_less()
{
	qhx::less&lt;int&gt; lessFunc;
 
	if (lessFunc(3, 2))
		cout &lt;&lt; "yes" &lt;&lt; endl;
	else
		cout &lt;&lt; "no" &lt;&lt; endl;
}
 
void test_BubbleSort()
{
	qhx::less&lt;int&gt; lessFunc;
 
	int arr[] = { 1, 2, 4, 9, 8, 3, 6, 7 };
 
	//BubbleSort(arr, sizeof(arr) / sizeof(arr[0]),lessFunc);
	BubbleSort(arr, sizeof(arr) / sizeof(arr[0]), lessFunc);
 
	for (auto e : arr)
	{
		cout &lt;&lt; e &lt;&lt; " ";
	}
}
 
int main()
{
	test_BubbleSort();
 
	return 0;
}</code></pre> 
<blockquote> 
 <p> 运行结果：9 8 7 6 4 3 2 1</p> 
</blockquote> 
<p>这里的less是根据优先级队列来定义的，这里是降序，greater就是升序。</p> 
<p><strong>注意：</strong>这里模板参数是类，函数调用类模板增加的代码内存时不多的。例如上述只增加1个字节。</p> 
<p></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/25c53cc829e79f269ac947ac489fc430/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">Android Studio 插件（自用）</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/cef56fc7bea8a44cb11f398166ccbaa1/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">Python线上兼职，游戏宅也能接单啦！</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>