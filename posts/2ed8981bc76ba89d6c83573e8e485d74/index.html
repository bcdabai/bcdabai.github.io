<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>[AcWing算法刷题]之DFS&#43;BFS迷宫模板（简单） - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="[AcWing算法刷题]之DFS&#43;BFS迷宫模板（简单）" />
<meta property="og:description" content="题目来源：
题库 - AcWing
目录
DFS和BFS模板题目：迷宫类
机器人的运动范围​
字母
迷宫
红与黑
棋盘问题
马走日
全球变暖
DFS综合类
乘积最大（提高课）
单词接龙（提高课）
取石子游戏（dfs数学推理）
机器人的运动范围
BFS：
class Solution { public: int get_sum(pair&lt;int, int&gt; p) { int s = 0; while (p.first) { s &#43;= p.first % 10; p.first /= 10; } while (p.second) { s &#43;= p.second % 10; p.second /= 10; } return s; } int movingCount(int threshold, int rows, int cols) { if (!rows || !" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/2ed8981bc76ba89d6c83573e8e485d74/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-03-26T16:44:04+08:00" />
<meta property="article:modified_time" content="2022-03-26T16:44:04+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">[AcWing算法刷题]之DFS&#43;BFS迷宫模板（简单）</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p><strong><span style="background-color:#fef2f0;">题目来源：</span></strong></p> 
<blockquote> 
 <p><a href="https://www.acwing.com/problem/search/1/?csrfmiddlewaretoken=eoqyYgvM5hESE68TdYg5vKGjAqbfsDANM7XsuV4evMddmauzKm6uwIf0E9pKiZVc&amp;search_content=dfs" rel="nofollow" title="题库 - AcWing">题库 - AcWing</a></p> 
</blockquote> 
<p id="main-toc"><strong>目录</strong></p> 
<p><strong><span style="background-color:#fbd4d0;">DFS和BFS模板题目：迷宫类</span></strong></p> 
<p id="%E6%9C%BA%E5%99%A8%E4%BA%BA%E7%9A%84%E8%BF%90%E5%8A%A8%E8%8C%83%E5%9B%B4%E2%80%8B-toc" style="margin-left:0px;"><a href="#%E6%9C%BA%E5%99%A8%E4%BA%BA%E7%9A%84%E8%BF%90%E5%8A%A8%E8%8C%83%E5%9B%B4%E2%80%8B" rel="nofollow">        </a><a href="#%E6%9C%BA%E5%99%A8%E4%BA%BA%E7%9A%84%E8%BF%90%E5%8A%A8%E8%8C%83%E5%9B%B4%E2%80%8B" rel="nofollow">机器人的运动范围​</a></p> 
<p id="%E5%AD%97%E6%AF%8D-toc" style="margin-left:0px;"><a href="#%E5%AD%97%E6%AF%8D" rel="nofollow">        </a><a href="#%E5%AD%97%E6%AF%8D" rel="nofollow">字母</a></p> 
<p id="%E8%BF%B7%E5%AE%AB-toc" style="margin-left:0px;"><a href="#%E8%BF%B7%E5%AE%AB" rel="nofollow">        </a><a href="#%E8%BF%B7%E5%AE%AB" rel="nofollow">迷宫</a></p> 
<p id="%E7%BA%A2%E4%B8%8E%E9%BB%91-toc" style="margin-left:0px;"><a href="#%E7%BA%A2%E4%B8%8E%E9%BB%91" rel="nofollow">        </a><a href="#%E7%BA%A2%E4%B8%8E%E9%BB%91" rel="nofollow">红与黑</a></p> 
<p id="%E6%A3%8B%E7%9B%98%E9%97%AE%E9%A2%98-toc" style="margin-left:0px;"><a href="#%E6%A3%8B%E7%9B%98%E9%97%AE%E9%A2%98" rel="nofollow">        </a><a href="#%E6%A3%8B%E7%9B%98%E9%97%AE%E9%A2%98" rel="nofollow">棋盘问题</a></p> 
<p id="%E9%A9%AC%E8%B5%B0%E6%97%A5-toc" style="margin-left:0px;"><a href="#%E9%A9%AC%E8%B5%B0%E6%97%A5" rel="nofollow">        </a><a href="#%E9%A9%AC%E8%B5%B0%E6%97%A5" rel="nofollow">马走日</a></p> 
<p id="%E5%8D%95%E8%AF%8D%E6%8E%A5%E9%BE%99%EF%BC%88%E6%8F%90%E9%AB%98%E8%AF%BE%EF%BC%89-toc" style="margin-left:0px;"><a href="#%E5%85%A8%E7%90%83%E5%8F%98%E6%9A%96" rel="nofollow">        全球变暖</a></p> 
<p style="margin-left:0px;"><strong><span style="background-color:#fbd4d0;">DFS综合类</span></strong></p> 
<p style="margin-left:0px;"><a href="#%E4%B9%98%E7%A7%AF%E6%9C%80%E5%A4%A7%EF%BC%88%E8%BE%83%E9%9A%BE%EF%BC%89" rel="nofollow">        乘积最大（提高课）</a></p> 
<p style="margin-left:0px;"><a href="#%E5%8D%95%E8%AF%8D%E6%8E%A5%E9%BE%99%EF%BC%88%E6%8F%90%E9%AB%98%E8%AF%BE%EF%BC%89" rel="nofollow">        单词接龙（提高课）</a></p> 
<p style="margin-left:0px;"><a href="#%E5%8F%96%E7%9F%B3%E5%AD%90%E6%B8%B8%E6%88%8F" rel="nofollow">        取石子</a>游戏（dfs数学推理）</p> 
<hr> 
<h2 id="%E6%9C%BA%E5%99%A8%E4%BA%BA%E7%9A%84%E8%BF%90%E5%8A%A8%E8%8C%83%E5%9B%B4%E2%80%8B">机器人的运动范围<br><img alt="" height="640" src="https://images2.imgbox.com/6a/31/Z6RMHegu_o.png" width="880"></h2> 
<p><strong><span style="background-color:#fbd4d0;"> BFS：</span></strong></p> 
<pre><code class="language-cpp">class Solution {
public:

    int get_sum(pair&lt;int, int&gt; p) {
        int s = 0;
        while (p.first) {
            s += p.first % 10;
            p.first /= 10;
        }
        while (p.second) {
            s += p.second % 10;
            p.second /= 10;
        }
        return s;
    }

    int movingCount(int threshold, int rows, int cols)
    {
        if (!rows || !cols) return 0;
        queue&lt;pair&lt;int,int&gt;&gt; q;
        vector&lt;vector&lt;bool&gt;&gt; st(rows, vector&lt;bool&gt;(cols, false));

        int dx[4] = {-1, 0, 1, 0}, dy[4] = {0, 1, 0, -1};

        int res = 0;
        q.push({0, 0});
        while (q.size()) {
            auto t = q.front();
            q.pop();
            if (st[t.first][t.second] || get_sum(t) &gt; threshold) continue;
            res ++ ;
            st[t.first][t.second] = true;
            for (int i = 0; i &lt; 4; i ++ ) {
                int x = t.first + dx[i], y = t.second + dy[i];
                if (x &gt;= 0 &amp;&amp; x &lt; rows &amp;&amp; y &gt;= 0 &amp;&amp; y &lt; cols) q.push({x, y});
            }
        }

        return res;
    }
};</code></pre> 
<hr> 
<p><strong><span style="background-color:#fbd4d0;">DFS：</span></strong></p> 
<pre><code class="language-cpp">class Solution {
public:
int k;
int b,a;
int f[52][52];
int dx[4]={1,0,-1,0},dy[4]={0,1,0,-1};
    int movingCount(int threshold, int rows, int cols)
    {
        memset(f,false,sizeof f);
        b=cols,a=rows;

         int res=0;

        k=threshold;

        return    dfs(0,0);
    }
    int dfs(int y,int x)
    {
        if(x&lt;0||x&gt;=a||y&lt;0||y&gt;=b||f[y][x]) return 0;

         f[y][x]=true;
        int res=0;
        int x1=x,y1=y;
        while(x1)
        {
            res+=(x1%10);
            x1/=10;
        }
         while(y1)
        {
            res+=(y1%10);
            y1/=10;
        }

        if(res&gt;k) return 0;
        int sum=0;

        for(int i=0;i&lt;4;i++)
        {
            int q=x+dx[i],p=y+dy[i];
            sum+=dfs(p,q);
        }


         return sum+1;
    }
};

作者：dfbdberberb
链接：https://www.acwing.com/solution/content/11722/
来源：AcWing
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</code></pre> 
<hr> 
<h2 id="%E4%B9%98%E7%A7%AF%E6%9C%80%E5%A4%A7%EF%BC%88%E8%BE%83%E9%9A%BE%EF%BC%89">乘积最大（较难）</h2> 
<p><img alt="" height="550" src="https://images2.imgbox.com/42/44/jXpbx43o_o.png" width="970"></p> 
<p> <img alt="" height="568" src="https://images2.imgbox.com/9b/a3/AxgVUY2m_o.png" width="757"></p> 
<p></p> 
<pre><code class="language-cpp">#include&lt;iostream&gt;
#include&lt;vector&gt;
#include&lt;algorithm&gt;
using namespace std;

int n, k, ans;
string str;
bool st[20];//标记数字是否出现过
vector&lt;int&gt;num;//存放分割的数字

int number(int l, int r)//求区间[l,r]的数字
{
    int res = 0;
    for (int i = l; i &lt;= r; i++)
        res = res * 10 + str[i] - '0';
    return res;
}

void dfs(int pos, int cnt)//枚举到的第几个空位，乘号的当前个数
{
    if (cnt == k)//如果乘号个数==题目所给的乘号个数
    {
        int y = number(pos, n - 1);//求出分割k次以后，第k+1个数的大小
        num.push_back(y);//放入分割的数字中
        int tmp = 1;
        for (int i = 0; i &lt; num.size(); i++)//求乘积
            tmp *= num[i];
        //          cout&lt;&lt;num[i]&lt;&lt;" ";
        //      cout&lt;&lt;endl;
        ans = max(ans, tmp);//更新最大值
        num.pop_back();
        return;
    }
    for (int i = 0; i &lt; n - 1; i++)//枚举分割位置
    {
        if (!st[i] &amp;&amp; pos &lt;= i)//如果分割位置未出现过，向下搜索
        {
            int x = number(pos, i);
            num.push_back(x);
            st[i] = true;
            dfs(i + 1, cnt + 1);
            st[i] = false;
            num.pop_back();
        }
    }
}

int main()
{
    cin &gt;&gt; n &gt;&gt; k;
    cin &gt;&gt; str;
    dfs(0, 0);
    cout &lt;&lt; ans &lt;&lt; endl;
    return 0;
}</code></pre> 
<hr> 
<h2 id="%E5%AD%97%E6%AF%8D">字母</h2> 
<p><img alt="" height="490" src="https://images2.imgbox.com/ca/73/nqtf7ko4_o.png" width="1105"></p> 
<p> <img alt="" height="379" src="https://images2.imgbox.com/72/8f/fQpDdKfR_o.png" width="576"></p> 
<p><strong><span style="background-color:#fbd4d0;"> BFS：</span></strong></p> 
<blockquote> 
 <p><strong><span style="background-color:#fbd4d0;">需要额外开一个字母数组来哈希快速找到该字母是否之前已经走过</span></strong></p> 
</blockquote> 
<pre><code class="language-cpp">#include&lt;iostream&gt;
#include&lt;string&gt;
#include&lt;vector&gt;
#include&lt;queue&gt;
#include&lt;algorithm&gt;
#include&lt;memory.h&gt;
#include&lt;cstring&gt;
using namespace std;

int n, m;
const int N = 50;
vector&lt;string&gt; V;
int mp[26];

struct STATE {
	int x, y;
	int mp[26];
	int step;
};

int ans = -1;
int addx[4] = { 1,-1,0,0 };
int addy[4] = { 0,0,-1,1 };

void bfs()
{
	queue&lt;struct STATE&gt; q;
	struct STATE s;
	memset(s.mp, 0, sizeof s.mp);
	s.mp[V[0][0] - 'A'] = 1;//标记
	s.step = 1;
	s.x = 0, s.y = 0;

	q.push(s);
	while (q.size())
	{
		auto t = q.front();
		q.pop();
		ans = max(ans, t.step);
		
		for (int i = 0; i &lt; 4; i++)
		{
			int newx = t.x + addx[i];
			int newy = t.y + addy[i];
			
			if (newx &gt;= 0 &amp;&amp; newx &lt; n &amp;&amp; newy &gt;= 0 &amp;&amp; newy &lt; m)
			{
				int idx = V[newx][newy] - 'A';
				if (t.mp[idx] == 1) continue;
				struct STATE next;
				next.x = newx;
				next.y = newy;
				next.step = t.step + 1;
				memcpy(next.mp, t.mp, sizeof t.mp);
				next.mp[idx] = 1;

				q.push(next);
			}
		}
	}
}

int main()
{
	cin &gt;&gt; n &gt;&gt; m;

	for (int i = 0; i &lt; n; i++)
	{
		string s;
		cin &gt;&gt; s;
		V.push_back(s);
	}

	bfs();
	cout &lt;&lt; ans &lt;&lt; endl;

	return 0;
}</code></pre> 
<hr> 
<p><strong><span style="background-color:#fbd4d0;">DFS：</span></strong></p> 
<blockquote> 
 <p><strong>同样需要开一个字母数组，来判断该字母是否出现过</strong></p> 
 <p><strong>不同的地方在与DFS搜索迷宫具有对称性：标记（   ）搜索下一层（  ）取消标记</strong></p> 
</blockquote> 
<pre><code class="language-cpp">#include&lt;iostream&gt;
#include&lt;string&gt;
#include&lt;vector&gt;
#include&lt;algorithm&gt;
using namespace std;

int n, m;
const int N = 50;
vector&lt;string&gt; V;
int mp[26];
int ans = -1;

int addx[] = { 1,-1,0,0 };
int addy[] = { 0,0,-1,1 };

void dfs(int x, int y, int step)
{
	int idx = V[0][0] - 'A';
	mp[idx] = 1;

	for (int i = 0; i &lt; 4; i++)
	{
		int newx = x + addx[i];
		int newy = y + addy[i];

		if (newx &gt;= 0 &amp;&amp; newx &lt; n &amp;&amp; newy &gt;= 0 &amp;&amp; newy &lt; m)
		{
			int idx = V[newx][newy] - 'A';
			if (mp[idx] == 1) continue;
			mp[idx] = 1;
			dfs(newx, newy, step + 1);
			mp[idx] = 0;
		}
	}
	ans=max(ans,step);
}

int main()
{
	cin &gt;&gt; n &gt;&gt; m;

	for (int i = 0; i &lt; n; i++)
	{
		string s;
		cin &gt;&gt; s;
		V.push_back(s);
	}

	dfs(0, 0, 1);
	cout &lt;&lt; ans &lt;&lt; endl;

	return 0;
}</code></pre> 
<hr> 
<h2 id="%E8%BF%B7%E5%AE%AB">迷宫</h2> 
<p><img alt="" height="607" src="https://images2.imgbox.com/18/4d/rAbN4Jzo_o.png" width="1132"></p> 
<p> <img alt="" height="724" src="https://images2.imgbox.com/36/04/hrEAlCOO_o.png" width="664"></p> 
<p><strong><span style="background-color:#fbd4d0;"> BFS：</span></strong></p> 
<pre><code class="language-cpp">#include&lt;iostream&gt;
#include&lt;queue&gt;
#include&lt;cstring&gt;
using namespace std;

typedef pair&lt;int, int&gt; PII;
const int N = 110;
int n;
char g[N][N];
bool st[N][N];
queue&lt;PII&gt; q;
int startx, starty;
int endx, endy;

int dx[4] = { -1,0,1,0 };
int dy[4] = { 0,1,0,-1 };

void bfs()
{
	q.push({ startx,starty });
	st[startx][starty]=true;
	while (q.size())
	{
		auto t = q.front();
		q.pop();
		
		for (int i = 0; i &lt; 4; i++)
		{
			int x = t.first + dx[i];
			int y = t.second + dy[i];
			if (x &gt;= 0 &amp;&amp; x &lt; n &amp;&amp; y&gt;=0 &amp;&amp; y &lt; n &amp;&amp; !st[x][y] &amp;&amp; g[x][y] == '.')
			{
				st[x][y] = true;
				q.push({ x,y });
			}
			else continue;
		}
	}
}

int main()
{
	int T;
	cin &gt;&gt; T;
	while (T--)
	{
		cin &gt;&gt; n;
		for (int i = 0; i &lt; n; i++) cin &gt;&gt; g[i];

		cin &gt;&gt; startx &gt;&gt; starty;
		cin &gt;&gt; endx &gt;&gt; endy;

		bfs();
		
        if(g[startx][starty]=='#' || g[endx][endy]=='#' || !st[endx][endy])cout &lt;&lt; "NO" &lt;&lt; endl;
		else if (st[endx][endy]) cout &lt;&lt; "YES" &lt;&lt; endl;
		

		memset(st, false, sizeof st);
	}

	return 0;
}</code></pre> 
<p><strong><span style="background-color:#fbd4d0;">DFS：</span></strong></p> 
<pre><code class="language-cpp">#include &lt;cstring&gt;
#include &lt;iostream&gt;
#include &lt;algorithm&gt;

using namespace std;

const int N = 110;

char g[N][N];
bool st[N][N];
int n;
int l1, r1, l2, r2;
int dx[] = {0, -1, 0, 1}, dy[] = {-1, 0, 1, 0};
bool dfs(int x, int y)
{
    if(x == l2 &amp;&amp; y == r2)return true;
    st[x][y] = true;
    for(int i = 0; i &lt; 4; i ++)
    {
        int a = x + dx[i], b = y + dy[i];
        if(a &lt; 0 || a &gt;= n || b &lt; 0 || b &gt;= n)continue;
        if(g[a][b] == '#')continue;
        if(st[a][b])continue;
        if(dfs(a, b))return true;
    }
    return false;
}

int main()
{
    int T;
    cin &gt;&gt; T;
    while(T --)
    {
        memset(st, false, sizeof st);
        cin &gt;&gt; n;
        for(int i = 0; i &lt; n; i ++) cin &gt;&gt; g[i];
        cin &gt;&gt; l1 &gt;&gt; r1 &gt;&gt; l2 &gt;&gt; r2;
        if(g[l1][r1] == '#' || g[l2][r2] == '#')
        {
            puts("NO");
            continue;
        }
        if(dfs(l1, r1))puts("YES");
        else puts("NO");
    }
    return 0;
}</code></pre> 
<hr> 
<h2 id="%E7%BA%A2%E4%B8%8E%E9%BB%91">红与黑</h2> 
<p><img alt="" height="592" src="https://images2.imgbox.com/aa/e5/NcLPrQJw_o.png" width="904"></p> 
<p> <img alt="" height="522" src="https://images2.imgbox.com/d0/78/7RIxD6b5_o.png" width="883"></p> 
<p><strong><span style="background-color:#fbd4d0;"> DFS：</span></strong></p> 
<pre><code class="language-cpp">#include&lt;iostream&gt;
#include&lt;cstring&gt;
using namespace std;
const int N=25;
char g[N][N];
bool st[N][N];
int n,m;
int dx[4]={-1,0,1,0};
int dy[4]={0,1,0,-1};

int dfs(int x,int y)
{
    int cnt=1;
    st[x][y]=true;
    
    for(int i=0;i&lt;4;i++)
    {
        int a=x+dx[i];
        int b=y+dy[i];
        if(a&lt;0 || a&gt;=n || b&lt;0 || b&gt;=m) continue;
        if(g[a][b]!='.') continue;
        if(st[a][b]) continue;
        
        cnt+=dfs(a,b);
    }
    return cnt;
}

int main()
{
	while (cin &gt;&gt; m &gt;&gt; n, n || m)
	{
		for (int i = 0; i &lt; n; i++) cin &gt;&gt; g[i];

		int x, y;
		for(int i=0;i&lt;n;i++)
			for (int j = 0; j &lt; m; j++)
			{
				if (g[i][j] == '@')
				{
					x = i;
					y = j;
				}
			}
		memset(st, 0, sizeof st);
		cout &lt;&lt; dfs(x, y) &lt;&lt; endl;
	}

	return 0;
}</code></pre> 
<hr> 
<h2 id="%E6%A3%8B%E7%9B%98%E9%97%AE%E9%A2%98">棋盘问题</h2> 
<p><img alt="" height="553" src="https://images2.imgbox.com/6a/16/etgj0iOL_o.png" width="1006"></p> 
<p> <img alt="" height="397" src="https://images2.imgbox.com/5c/c7/4gZPcRrp_o.png" width="462"></p> 
<p></p> 
<pre><code class="language-cpp">//DFS
//类似于八皇后的一道多了一些限制的题

#include &lt;cstdio&gt;
#include &lt;iostream&gt;
#include &lt;cstring&gt;

using namespace std;

const int N = 20;

char g[N][N];                                       //存储输入棋盘 
int ans;                                            //存储答案 
int n, k;
int m;                                              //存储已近放入棋盘的棋子数 
bool line[N];                                       //存储当前列上有没有其他棋子 

void dfs(int x)
{
    if(m == k)                                      //当棋子放光的时候 
    {
        ans++;
        return;
    }

    if(x == n)                                      //防止越界 
        return;
    
    dfs(x + 1);     //这个是关键，因为 k &lt;= m，因此可能有行不用放棋子，所以我们要手动舍弃行，直接进入下一行 
    for(int i = 0; i &lt; n; i++)                      //爆搜 
        if(!line[i] &amp;&amp; g[x][i] == '#')
        {
            line[i] = true;
            m++;                                    //记录放入的棋子数 
            dfs(x + 1);
            line[i] = false;                        //还原初始状态 
            m--;
        }

    
}

int main()
{
    while(scanf("%d%d", &amp;n, &amp;k) &amp;&amp; n != -1 &amp;&amp; k != -1)
    {
        ans = m = 0;
        for(int i = 0; i &lt; n; i++)
            for(int j = 0; j &lt; n; j++)
                cin &gt;&gt; g[i][j];

        dfs(0);
        cout &lt;&lt; ans &lt;&lt; endl;
    }

    return 0;
}
</code></pre> 
<hr> 
<h2 id="%E5%8F%96%E7%9F%B3%E5%AD%90%E6%B8%B8%E6%88%8F">取石子游戏</h2> 
<p><img alt="" height="505" src="https://images2.imgbox.com/59/4a/eB8LtgZG_o.png" width="1003"></p> 
<p> <img alt="" height="538" src="https://images2.imgbox.com/92/0f/X7PSrJpU_o.png" width="981"></p> 
<p></p> 
<pre><code class="language-cpp">#include&lt;iostream&gt;
#include&lt;algorithm&gt;
using namespace std;

int n, m;

void dfs(int a, int b, int step)
{
	if (a % b == 0 || a / b &gt;= 2)
	{
		if (step &amp; 1)
		{
			cout &lt;&lt; "win" &lt;&lt; endl;
			return;
		}
		else
		{
			cout &lt;&lt; "lose" &lt;&lt; endl;
			return;
		}
	}
	dfs(b, a % b, step + 1);
}

int main()
{
	while (cin &gt;&gt; n &gt;&gt; m, n || m)
	{
		if (n &lt; m) swap(n, m);
		if (n / m &gt;= 2) cout &lt;&lt; "win" &lt;&lt; endl;
		else dfs(n, m, 1);
	}

	return 0;
}</code></pre> 
<hr> 
<h2 id="%E9%A9%AC%E8%B5%B0%E6%97%A5">马走日</h2> 
<p><img alt="" height="690" src="https://images2.imgbox.com/90/4b/3vxgVs36_o.png" width="919"></p> 
<p></p> 
<pre><code class="language-cpp">#include&lt;bits/stdc++.h&gt;
using namespace std;
int T,n,m,a,b,ans;
int vis[20][20];
int dx[8]={2,1,-1,-2,-2,-1,1,2};//方向数组
int dy[8]={1,2,2,1,-1,-2,-2,-1};//方向数组
void dfs(int x,int y,int step)//step记录当前走了几个格子
{
    if(step==n*m){//已遍历完所有的格子
        ans++;//答案加一
        return;
    }
    for(int i=0;i&lt;8;i++){
        int kx=x+dx[i];
        int ky=y+dy[i];
        if(kx&gt;=0&amp;&amp;kx&lt;n&amp;&amp;ky&gt;=0&amp;&amp;ky&lt;m&amp;&amp;vis[kx][ky]==0){//判断
            vis[kx][ky]=1;//标记
            dfs(kx,ky,step+1);
            vis[kx][ky]=0;//回溯
        }
    }
}
int main()
{
    scanf("%d",&amp;T);
    while(T--){//多组测试数据
        ans=0;//一定要记得清空数据
        memset(vis,0,sizeof(vis));
        scanf("%d %d %d %d",&amp;n,&amp;m,&amp;a,&amp;b);
        vis[a][b]=1;//标记起点
        dfs(a,b,1);
        printf("%d\n",ans);
    }
    return 0;
}</code></pre> 
<hr> 
<h2 id="%E5%8D%95%E8%AF%8D%E6%8E%A5%E9%BE%99%EF%BC%88%E6%8F%90%E9%AB%98%E8%AF%BE%EF%BC%89">单词接龙（提高课）</h2> 
<p><img alt="" height="466" src="https://images2.imgbox.com/d8/cf/1jEtiZCv_o.png" width="925"></p> 
<p> <img alt="" height="568" src="https://images2.imgbox.com/00/96/yWLuVHx8_o.png" width="670"></p> 
<p></p> 
<pre><code class="language-cpp">#include &lt;cstring&gt;
#include &lt;iostream&gt;
#include &lt;algorithm&gt;

using namespace std;

const int N = 21;

int n;
string word[N];
int g[N][N];//代表编号i的可以被j拼接  如i：asd，j：sdf，拼接长度为最小值g[i][j] = 2，i从0开始记位
int used[N];//编号为i的单词使用次数
int ans;

void dfs(string dragon, int last)
{
    ans = max((int)dragon.size(), ans);//取最大值，dragon.size()为当前合并的长度

    used[last]++;//编号为last的单词被用次数++；

    for (int i = 0; i &lt; n; i++)
        if (g[last][i] &amp;&amp; used[i] &lt; 2)//used[i]&lt;2代表单词用次数不超过2
            dfs(dragon + word[i].substr(g[last][i]), i); //编号为last的可以被i拼接现在尾巴为i号

    used[last]--;//恢复现场
}

int main() {
    cin &gt;&gt; n;
    for (int i = 0; i &lt; n; i++) cin &gt;&gt; word[i];
    char start;
    cin &gt;&gt; start;//首字母

    for (int i = 0; i &lt; n; i++)//遍历得到各个g[i][j]
        for (int j = 0; j &lt; n; j++) {
            string a = word[i], b = word[j];
            for (int k = 1; k &lt; min(a.size(), b.size()); k++)
                if (a.substr(a.size() - k, k) == b.substr(0, k)) {
                    g[i][j] = k;
                    break;
                }
        }

    for (int i = 0; i &lt; n; i++)//找到首字母为strat的单词开始做dfs，dfs中会自动找到最大值
        if (word[i][0] == start)
            dfs(word[i], i);//从word[i]开始遍历，i代表现在是第几个单词

    cout &lt;&lt; ans &lt;&lt; endl;

    return 0;
}</code></pre> 
<hr> 
<h2 id="%E5%85%A8%E7%90%83%E5%8F%98%E6%9A%96">全球变暖</h2> 
<p><img alt="" height="646" src="https://images2.imgbox.com/24/84/ZWoyePvd_o.png" width="933"></p> 
<p> <img alt="" height="634" src="https://images2.imgbox.com/97/c9/8vnRsmfH_o.png" width="988"></p> 
<p> <img alt="" height="364" src="https://images2.imgbox.com/d8/a0/h7cwtTrV_o.png" width="603"></p> 
<p></p> 
<pre><code class="language-cpp">#include&lt;iostream&gt;
#include&lt;cstdio&gt;
#include&lt;cstring&gt;
#include&lt;algorithm&gt;
#define x first
#define y second
using namespace std;
typedef pair&lt;int, int&gt; PII;
const int N = 1010;
int n;
char g[N][N];
bool st[N][N];
PII q[N * N];
int dx[4] = { -1,0,1,0 };
int dy[4] = { 0,1,0,-1 };
// total : 岛屿的板块的数量  bound：邻接海洋的岛屿板块的数量
void bfs(int sx, int sy, int&amp; total, int&amp; bound)
{
	int hh = 0;
	int tt = 0;
	q[0] = { sx,sy };
	st[sx][sy] = true;

	while (hh &lt;= tt)
	{
		PII t = q[hh++];

		total++;
		bool is_bound = false;
		for (int i = 0; i &lt; 4; i++)
		{
			int x = t.x + dx[i];
			int y = t.y + dy[i];
			if (x &lt; 0 || x &gt;= n || y &lt; 0 || y &gt;= n) continue;
			if (st[x][y]) continue;//如果已经走过了
			if (g[x][y] == '.')//上下左右之中有一个为海
			{
				is_bound = true;
				continue;
			}
			q[++tt] = { x,y };
			st[x][y] = true;
		}
		if (is_bound) bound++;//只要上下左右之中有一个为海，那么它就是边界
	}
}

int main()
{
	cin &gt;&gt; n;

	for (int i = 0; i &lt; n; i++) cin &gt;&gt; g[i];

	int cnt = 0;
	for(int i=0;i&lt;n;i++)
		for(int j=0;j&lt;n;j++)
			if (!st[i][j] &amp;&amp; g[i][j] == '#')
			{
				int total = 0;
				int bound = 0;
				bfs(i, j, total, bound);
				if (total == bound) cnt++;
			}
	cout &lt;&lt; cnt &lt;&lt; endl;

	return 0;
}</code></pre> 
<hr> 
<p></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/99f7bf03fb0bcc5b6a7573829e0d5903/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">nginx系列之健康检查模块配置安装（nginx_upstream_check_module）</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/f7f9c97d543f674b24bcbe13916855b1/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">电脑添加打印机方法/步骤</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>