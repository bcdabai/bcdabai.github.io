<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>mysql 备份表_做好mysql运维，必须熟练掌握备份和恢复，实战一次不行多来几次 - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="mysql 备份表_做好mysql运维，必须熟练掌握备份和恢复，实战一次不行多来几次" />
<meta property="og:description" content="一、 备份恢复策略 进行备份或恢复操作时需要考虑一些因素：
1、确定要备份的表的存储引擎是事务型还是非事务型，两种不同的存储引擎备份方式在处理数据一致性方面是不太一样的。
2、确定使用全备份还是增量备份。全备份的优点是备份保持最新备份，恢复的时候可以花费更少的时间；缺点是如果数据量大，将会花费很多的时间，并对系统造成较长时间的压力。增量备份相反，只需要备份每天的增量日志，备份时间少，对负载压力也小；缺点就是恢复的时候需要全备份加上次备份到故障前的所有日志，恢复时间长一些。
3、可以考虑采用复制的方法来做异地备份，但不能代替备份，它对数据库的误操作也无能为力。
4、要定期做备份，备份的周期要充分考虑系统可以承受的恢复时间。备份要在系统负载较小的时候进行
5、确保 MySQL 打开 log-bin 选项，有了 binlog，MySQL 才可以在必要的时候做完整恢复，或基于时间点的恢复，或基于位置的恢复。
6、经常做备份恢复测试，确保备份是有效的，是可以恢复的。
二、 逻辑备份和恢复 在 MySQL 中，逻辑备份的最大优点是对于各种存储引擎都可以用同样的方法来备份；而物理备份则不同，不同的存储引擎有着不同的备份方法，因此，对于不同存储引擎混合的数据库，逻辑备份会简单一点。
1. 备份 MySQL 中的逻辑备份是将数据库中的数据备份为一个文本文件，备份的文件可以被查看和编辑。在 MySQL 中，可以使用 mysqldump 工具来完成逻辑备份：
// 备份指定的数据库或者数据库中的某些表 shell&gt; mysqldump [options] db_name [tables] // 备份指定的一个或多个数据库 shell&gt; mysqldump [options] --database DB1 [DB2,DB3...] // 备份所有数据库 shell&gt; mysqldump [options] --all-database 如果没有指定数据库中的任何表，默认导出所有数据库中的所有表。
示例： 1. 备份所有数据库：
shell&gt;mysqldump -uroot -p --all-database &gt; all.sql 2. 备份数据库 test
shell&gt;mysqldump -uroot -p test &gt; test.sql 3. 备份数据库 test 下的表 emp" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/266931a9eb8ffc5e6a18901bbc27c3bf/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2020-11-20T10:43:26+08:00" />
<meta property="article:modified_time" content="2020-11-20T10:43:26+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">mysql 备份表_做好mysql运维，必须熟练掌握备份和恢复，实战一次不行多来几次</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <div style="font-size:16px;"> 
 <div class="pgc-img"> 
  <img src="https://images2.imgbox.com/23/49/3XwQ8CVo_o.png" alt="8e3e40fb49aea14df81249502e066034.png"> 
 </div> 
 <h2 class="pgc-h-arrow-right"><strong>一、 备份恢复策略</strong></h2> 
 <p>进行备份或恢复操作时需要考虑一些因素：</p> 
 <p>1、确定要备份的表的存储引擎是事务型还是非事务型，两种不同的存储引擎备份方式在处理数据一致性方面是不太一样的。</p> 
 <p>2、确定使用全备份还是增量备份。全备份的优点是备份保持最新备份，恢复的时候可以花费更少的时间；缺点是如果数据量大，将会花费很多的时间，并对系统造成较长时间的压力。增量备份相反，只需要备份每天的增量日志，备份时间少，对负载压力也小；缺点就是恢复的时候需要全备份加上次备份到故障前的所有日志，恢复时间长一些。</p> 
 <p>3、可以考虑采用复制的方法来做异地备份，但不能代替备份，它对数据库的误操作也无能为力。</p> 
 <p>4、要定期做备份，备份的周期要充分考虑系统可以承受的恢复时间。备份要在系统负载较小的时候进行</p> 
 <p>5、确保 MySQL 打开 log-bin 选项，有了 binlog，MySQL 才可以在必要的时候做完整恢复，或基于时间点的恢复，或基于位置的恢复。</p> 
 <p>6、经常做备份恢复测试，确保备份是有效的，是可以恢复的。</p> 
 <h2 class="pgc-h-arrow-right"><strong>二、 逻辑备份和恢复</strong></h2> 
 <p>在 MySQL 中，逻辑备份的最大优点是对于各种存储引擎都可以用同样的方法来备份；而物理备份则不同，不同的存储引擎有着不同的备份方法，因此，对于不同存储引擎混合的数据库，逻辑备份会简单一点。</p> 
 <h2 class="pgc-h-arrow-right"><strong>1. 备份</strong></h2> 
 <p>MySQL 中的逻辑备份是将数据库中的数据备份为一个文本文件，备份的文件可以被查看和编辑。在 MySQL 中，可以使用 mysqldump 工具来完成逻辑备份：</p> 
 <pre class="has"><code>// 备份指定的数据库或者数据库中的某些表  shell&gt; mysqldump [options] db_name [tables]  // 备份指定的一个或多个数据库  shell&gt; mysqldump [options] --database DB1 [DB2,DB3...]  // 备份所有数据库  shell&gt; mysqldump [options] --all-database</code></pre> 
 <p>如果没有指定数据库中的任何表，默认导出所有数据库中的所有表。</p> 
 <h2 class="pgc-h-arrow-right"><strong>示例：</strong></h2> 
 <p>1. 备份所有数据库：</p> 
 <pre class="has"><code>shell&gt;mysqldump -uroot -p --all-database &gt; all.sql</code></pre> 
 <p>2. 备份数据库 test</p> 
 <pre class="has"><code>shell&gt;mysqldump -uroot -p test &gt; test.sql</code></pre> 
 <p>3. 备份数据库 test 下的表 emp</p> 
 <pre class="has"><code>shell&gt; mysqldump -uroot -p test emp &gt; emp.sql</code></pre> 
 <p>4. 备份数据库 test 下的表 emp 和 dept</p> 
 <pre class="has"><code>shell&gt; mysqldump -uroot -p test emp dept &gt; emp_dept.sql</code></pre> 
 <p>5. 备份数据库test 下的所有表为逗号分割的文本，备份到 /tmp:</p> 
 <pre class="has"><code>shell&gt; mysqlddump -uroot -p -T /tmp test emp --fields-terminated-by ','shell&gt; more emp.txt  1,z12,z23,z34,z4</code></pre> 
 <p>注意：为了保证数据备份的一致性， myisam存储引擎在备份时需要加上-l参数,表示将所有表加上读锁，在备份期间，所有表将只能读而不能进行数据更新。但是对于事务存储引擎来说，可以采用更好的选项 --single-transaction，此选项使得 innodb 存储引擎得到一个快照(snapshot)，使得备份的数据能够保证一致性。</p> 
 <h2 class="pgc-h-arrow-right"><strong>2. 完全恢复</strong></h2> 
 <p>mysqldump 的恢复也很简单，将备份作为输入执行即可：</p> 
 <pre class="has"><code>mysql -uroot -p db_name &lt; backfile</code></pre> 
 <p><strong>注意</strong>，将备份恢复后数据并不完整，还需要将备份后执行的日志进行重做：</p> 
 <pre class="has"><code>mysqlbinlog binlog-file | mysql -uroot -p</code></pre> 
 <h2 class="pgc-h-arrow-right"><strong>完整的 mysqldump 备份与恢复示例：</strong></h2> 
 <p>1. 凌晨 2:00，备份数据库：</p> 
 <pre class="has"><code>root@bogon:/usr/local/mysql/bin$ ./mysqldump -uroot -p -l -F t2 &gt; t2.dmpEnter password:</code></pre> 
 <p>其中 -l参数表示给所有表加读锁，-F表示生成一个新的日志文件，此时，t2 中 emp 表的数据如下：</p> 
 <pre class="has"><code># 为了便于测试，执行 reset master 删除所有 binlog。MySQL [(none)]&gt; reset master;Query OK, 0 rows affected (0.00 sec)# 此时只有一个 binlog 日志文件   mysql-bin.000001MySQL [t2]&gt; select * from test;+------+------+| id   | name |+------+------+|    1 | a    ||    2 | b    |+------+------+2 rows in set (0.00 sec)</code></pre> 
 <p>2. 备份完毕后，插入新的数据：</p> 
 <pre class="has"><code># 因为上一步执行是加入了 -F 选项, 所以接下来的操作会被记录到新的二进制文件，即名为 mysql-bin.000002 的文件MySQL [t2]&gt; insert into test values (3,'c');Query OK, 1 row affected (0.00 sec)MySQL [t2]&gt; insert into test values (4,'d');Query OK, 1 row affected (0.00 sec)</code></pre> 
 <p>3. 数据库突然故障(其实是小伙伴没事儿删库练手玩儿)，数据无法访问。需要恢复备份：</p> 
 <p>删库跑路：</p> 
 <pre class="has"><code># 这里为了便于测试，不把删库操作记入日志，当前 session 设置 sql_log_bin 为 off。# 删库后，执行 flush logs，让后续的 binlog 到新的文件中，即名为 mysql-bin.000003中MySQL [t2]&gt; set sql_log_bin = 0;Query OK, 0 rows affected (0.00 sec)MySQL [t2]&gt; show variables like "%sql_log_bin%";+---------------+-------+| Variable_name | Value |+---------------+-------+| sql_log_bin   | OFF   |+---------------+-------+1 row in set (0.00 sec)MySQL [t2]&gt; drop database t2;Query OK, 1 row affected (0.01 sec)MySQL [(none)]&gt; flush logs;Query OK, 0 rows affected (0.22 sec)MySQL [t2]&gt; drop database t2;Query OK, 3 rows affected (0.23 sec)MySQL [(none)]&gt; exit;Bye</code></pre> 
 <p><strong>数据恢复：</strong></p> 
 <pre class="has"><code>root@bogon:/usr/local/mysql/bin# ./mysql -e "create database t2"  root@bogon:/usr/local/mysql/bin# ./mysql t2 &lt; t2.dmp*******************************************************************MySQL [t2]&gt; select * from test;+------+------+| id   | name |+------+------+|    1 | a    ||    2 | b    |+------+------+2 rows in set (0.00 sec)</code></pre> 
 <p>4. 使用 mysqlbinlog 恢复自 mysqldump 备份以来的 binglog</p> 
 <p>根据前面操作的内容，可知从备份的时间点到删库的时间点之间的操作被记录到了 mysql-bin.000002 文件中</p> 
 <pre class="has"><code>root@bogon:/usr/local/mysql/bin# ./mysqlbinlog --no-defaults /data/mysql/mysql-bin.000002 | ./mysql t2*******************************************************MySQL [t2]&gt; select * from test;+------+------+| id   | name |+------+------+|    1 | a    ||    2 | b    ||    3 | c    ||    4 | d    |+------+------+4 rows in set (0.00 sec)</code></pre> 
 <p>至此，数据恢复成功。</p> 
 <h2 class="pgc-h-arrow-right"><strong>3. 基于时间点恢复</strong></h2> 
 <p>由于误操作，比如误删除了一张表，这时使用完全恢复时没有用的，因为日志里面还存在误操作的语句，我们需要的是恢复到误操作之前的状态，然后跳过误操作语句，再恢复后面执行的语句，完成恢复。这种恢复叫不完全恢复，在 MySQL 中，不完全恢复分为 基于时间点的恢复和基于位置的恢复。基于时间点恢复的操作步骤：</p> 
 <p>(1) 如果是上午 10 点发生了误操作，可以用以下语句用备份和 binlog 将数据恢复到故障前：</p> 
 <pre class="has"><code>shell&gt;mysqlbinlog --stop-date="2017-09-30 9:59:59" /data/mysql/mysql-bin.123456 | mysql -uroot -ppassword</code></pre> 
 <p>(2) 跳过故障时的时间点，继续执行后面的 binlog，完成恢复。</p> 
 <pre class="has"><code>shell&gt;mysqlbinlog --start-date="2017-09-30 10:01:00" /data/mysql/mysql-bin.123456 | mysql -uroot -ppassword</code></pre> 
 <h2 class="pgc-h-arrow-right"><strong>4. 基于位置恢复</strong></h2> 
 <p>和基于时间点的恢复类似，但是更精确，因为同一个时间点可能有很多条 sql 语句同时执行。恢复的操作步骤如下：</p> 
 <p>(1) 在 shell 下执行命令：</p> 
 <pre class="has"><code>shell&gt;mysqlbinlog --start-date="2019-09-30 9:59:59" --stop-date="2019-09-30 10:01:00"/data/mysql/mysql-bin.123456 &gt; /tmp/mysql_restore.sql</code></pre> 
 <p>该命令将在 /tmp 目录创建小的文本文件，编辑此文件，知道出错语句前后的位置号，例如前后位置号分别为 368312 和 368315。</p> 
 <p>(2) 恢复了以前的备份文件后，应从命令行输入下面的内容：</p> 
 <pre class="has"><code>shell&gt;mysqlbinlog --stop-position="368312" /data/mysql/mysql-bin.123456 | mysql -uroot -ppassword  shell&gt;mysqlbinlog --start-position="368315" /data/mysql/mysql-bin.123456 | mysql -uroot -ppassword</code></pre> 
 <p>上面的第一行将恢复到停止位置为止的所有事务。下一行将恢复从给定的起始位置直到二进制日志结束的所有事务。因为 mysqlbinlog 的输出包括每个 sql 语句记录之前的 set timestamp 语句，因此恢复的数据和相关的 mysql 日志将反映事务执行的 原时间。</p> 
 <h2 class="pgc-h-arrow-right"><strong>三、 表的导入导出</strong></h2> 
 <p>在数据库的日常维护中，表的导入导出时很频繁的一类操作。</p> 
 <p><strong>1. 导出</strong></p> 
 <p>在某些情况下，为了一些特定的目的，经常需要将表里的数据导出为某些符号分割的纯数据文本，而不是 sql 语句：</p> 
 <p>1、用来作为 Excel 显示；2、单纯为了节省备份空间；3、为了快速的加载数据，load data 的加载速度比普通 sql 加载要快 20 倍以上。</p> 
 <p><strong>使用 select ...into outfile ... 命令来导出数据，具体语法如下：</strong></p> 
 <pre class="has"><code>mysql&gt; select * from tablename into outfile 'target_file' [option];</code></pre> 
 <p>其中 option 参数可以是以下选项：</p> 
 <pre class="has"><code>fields terminated by 'string'                   // 字段分隔符，默认为制表符''fields [optionally] enclosed by 'char'          // 字段引用符，如果加 optionally 选项则只用在 char、varchar 和 text 等字符型字段上，默认不使用引用符  fields escaped by ‘char’                        // 转移字符、默认为 ''  lines starting by 'string'                      // 每行前都加此字符串，默认''  lines terminated by 'string'                    // 行结束符，默认为''  # char 表示此符号只能是单个字符，string表示可以是字符串。</code></pre> 
 <p>例如，将 test 表中数据导出为数据文本，其中，字段分隔符为“,”,字段引用符为“"”,记录结束符为回车符：</p> 
 <pre class="has"><code>MySQL [t2]&gt; select * from test into outfile '/data/mysql/outfile.txt' fields terminated by "," enclosed by '"';Query OK, 4 rows affected (0.02 sec)</code></pre> 
 <pre class="has"><code>zj@bogon:/data/mysql$ more outfile.txt"1","a","helloworld""2","b","helloworld""3","c","helloworld""4","d","helloworld"</code></pre> 
 <p>发现第一列是数值型，如果不希望字段两边用引号引起，则语句改为：</p> 
 <pre class="has"><code>MySQL [t2]&gt; select * from test into outfile '/data/mysql/outfile2.txt' fields terminated by "," optionally  enclosed by '"';Query OK, 4 rows affected (0.03 sec)zj@bogon:/data/mysql$ more outfile2.txt1,"a","helloworld"2,"b","helloworld"3,"c","helloworld"4,"d","helloworld"</code></pre> 
 <p><strong>测试转义字符，MySQL 导出数据中需要转义的字符主要包括以下 3 类：</strong></p> 
 <p>1、转义字符本身 2、字段分隔符 3、记录分隔符</p> 
 <pre class="has"><code>MySQL [t2]&gt; update test set content = '"##!aa' where  id=1;Query OK, 1 row affected (0.05 sec)Rows matched: 1  Changed: 1  Warnings: 0MySQL [t2]&gt; select * from test into outfile '/data/mysql/outfile3.txt' fields terminated by "," optionally enclosed by '"';Query OK, 4 rows affected (0.03 sec)*******************************************zj@bogon:/data/mysql$ more outfile3.txt1,"a",""##!aa"2,"b","helloworld"3,"c","helloworld"4,"d","helloworld"</code></pre> 
 <p>1、当导出命令中包含字段引用符时，数据中含有转义字符本身和字段引用符的字符需要被转义；</p> 
 <p>2、当导出命令中不包含字段引用符时，数据中含有转义字符本身和字段分割符的字符需要被转义。</p> 
 <p><em>注意：</em>select ... into outfile ... 产生的输出文件如果在目标目录下有重名文件，将不会被创建成功，源文件不会被自动覆盖。</p> 
 <p><strong>使用 mysqldump 导出数据为文本的具体语法如下：</strong></p> 
 <p>mysqldump -u username -T target_dir dbname tablename [option]</p> 
 <p>其中，option 参数可以是以下选项：</p> 
 <p>1、--fields-terminated-by=name (字段分隔符)；</p> 
 <p>2、--fields-enclosed-by=name (字段引用符)；</p> 
 <p>3、--fields-optionally-enclosed-by=name (字段引用符，只用在 char、varchar 和 test 等字符型字段上)；</p> 
 <p>4、--fields-escaped-by=name (转义字符);</p> 
 <p>5、--lines-terminated-by=name (记录结束符);</p> 
 <p>例子：</p> 
 <pre class="has"><code>root@bogon:/usr/local/mysql/bin# ./mysqldump -uroot -p -T /data/mysql/dump t2 test --fields-terminated-by ',' --fields-optionally-enclosed-by '"'**************** test.txt **********************zj@bogon:/data/mysql/dump$ more test.txt1,"a",""##!aa"2,"b","helloworld"3,"c","helloworld"4,"d","helloworld"***************** test.sql *********************zj@bogon:/data/mysql/dump$ more test.sql-- MySQL dump 10.13  Distrib 5.7.18, for Linux (x86_64)---- Host: localhost    Database: t2-- -------------------------------------------------------- Server version    5.7.18-log/*!40101 SET @OLD_CHARACTER_SET_CLIENT=@@CHARACTER_SET_CLIENT */;/*!40101 SET @OLD_CHARACTER_SET_RESULTS=@@CHARACTER_SET_RESULTS */;/*!40101 SET @OLD_COLLATION_CONNECTION=@@COLLATION_CONNECTION */;/*!40101 SET NAMES utf8mb4 */;/*!40103 SET @OLD_TIME_ZONE=@@TIME_ZONE */;/*!40103 SET TIME_ZONE='+00:00' */;/*!40101 SET @OLD_SQL_MODE=@@SQL_MODE, SQL_MODE='' */;/*!40111 SET @OLD_SQL_NOTES=@@SQL_NOTES, SQL_NOTES=0 */;---- Table structure for table `test`--DROP TABLE IF EXISTS `test`;/*!40101 SET @saved_cs_client     = @@character_set_client */;/*!40101 SET character_set_client = utf8 */;CREATE TABLE `test` (  `id` int(11) DEFAULT NULL,  `name` varchar(10) DEFAULT NULL,  `content` varchar(100) DEFAULT NULL) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;/*!40101 SET character_set_client = @saved_cs_client */;/*!40103 SET TIME_ZONE=@OLD_TIME_ZONE */;/*!40101 SET SQL_MODE=@OLD_SQL_MODE */;/*!40101 SET CHARACTER_SET_CLIENT=@OLD_CHARACTER_SET_CLIENT */;/*!40101 SET CHARACTER_SET_RESULTS=@OLD_CHARACTER_SET_RESULTS */;/*!40101 SET COLLATION_CONNECTION=@OLD_COLLATION_CONNECTION */;/*!40111 SET SQL_NOTES=@OLD_SQL_NOTES */;-- Dump completed on 2017-09-25 11:14:06</code></pre> 
 <p>可以发现，除多了一个表的创建脚本文件，mysqldump 和 select ... into outfile ... 的选项和语法非常相似。其实 mysqldump 实际调用的就是后者提供的接口，并在其上面添加了一些新的功能而已。</p> 
 <h2 class="pgc-h-arrow-right"><strong>2. 导入</strong></h2> 
 <p>导入用 select ... into outfile 或者 mysqldump 导出的纯数据文本</p> 
 <p>和导出类似，导入也有两种不同的方法，分别是 load data infile... 和 mysqlimport，它们的本质是一样的，区别只是在于一个在 MySQL 内部执行，另一个在 MySQL 外部执行。</p> 
 <p><strong>使用 “load data infile...” 命令，具体语法如下</strong></p> 
 <pre class="has"><code>mysql&gt; load data [local]infile 'filename' into table tablename [option]  </code></pre> 
 <p>option 可以是以下选项：</p> 
 <p>1、fields terminated by 'string' (字段分割符，默认为制表符't');</p> 
 <p>2、fields [optionally] enclosed by 'char' (字段引用符，如果加 optionally 选项则只用在 char varchar text 等字符型字段上。默认不使用引用符)；</p> 
 <p>3、fields escaped by 'char' (转义字符，默认为'')</p> 
 <p>4、lines starting by 'string' (每行前都加此字符串，默认为'')</p> 
 <p>5、lines terminated by 'string' (行结束符，默认为'n')</p> 
 <p>6、ignore number lines (忽略输入文件中的前几行数据)</p> 
 <p>7、(col<em>name</em>or<em>user</em>var,...) (按照列出的字段顺序和字段数量加载数据)；8、set col_name = expr,...将列做一定的数值转换后再加载。</p> 
 <p>fields 、lines 和前面 select...into outfile...的含义完全相同，不同的是多了几个不同的选项，下面的例子将文件'test.txt'中的数据加载到表 test 中:</p> 
 <pre class="has"><code>// 清空表 test  MySQL [t2]&gt; truncate table test;Query OK, 0 rows affected (0.07 sec)MySQL [t2]&gt; load data infile '/data/mysql/outfile.txt' into table test fields terminated by ',' enclosed by '"';Query OK, 4 rows affected (0.10 sec)Records: 4  Deleted: 0  Skipped: 0  Warnings: 0MySQL [t2]&gt; select * from test;+------+------+------------+| id   | name | content    |+------+------+------------+|    1 | a    | helloworld ||    2 | b    | helloworld ||    3 | c    | helloworld ||    4 | d    | helloworld |+------+------+------------+4 rows in set (0.00 sec)</code></pre> 
 <p>如果不希望加载文件中的前两行，可以进行如下操作：</p> 
 <pre class="has"><code>MySQL [t2]&gt; truncate table test;Query OK, 0 rows affected (0.02 sec)MySQL [t2]&gt; load data infile '/data/mysql/outfile.txt' into table test fields terminated by ',' enclosed by '"' ignore 2 lines;Query OK, 2 rows affected (0.00 sec)Records: 2  Deleted: 0  Skipped: 0  Warnings: 0MySQL [t2]&gt; select * from test;+------+------+------------+| id   | name | content    |+------+------+------------+|    3 | c    | helloworld ||    4 | d    | helloworld |+------+------+------------+2 rows in set (0.02 sec)</code></pre> 
 <h2 class="pgc-h-arrow-right"><strong>使用 mysqldump 实现</strong></h2> 
 <p>语法：</p> 
 <pre class="has"><code>shell&gt; mysqlimport -uroot -p [--local] dbname order_tab.txt [option]</code></pre> 
 <p>其中，option 参数可以是以下选项：</p> 
 <p>1、fields-terminated-by=name (字段分隔符) 2、fields-enclosed-by=name (字段引用符) 3、fields-optionally-enclosed-by=name (字段引用符，只用在 char、varchar、text等字符型字段上) 4、fields-escaped-by=name (转义字符) 5、lines-terminated-by=name (记录结束符) 6、ignore-lines=number (忽略前几行)</p> 
 <p><strong>注意：</strong>如果导入和导出是跨平台操作的(windows 和 linux)，那么要注意设置参数 line-terminated-by，windows 上设置为 line-terminated-by='rn', linux 上设置为 line-terminated-by='n'。</p> 
</div>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/96669b46e6d286e39146b5f109c03a99/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">Docker运行Rocket MQ</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/65513de4c67bccc6985b5e37c449a14d/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">python list元素换位置_Python的数据类型概述</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>