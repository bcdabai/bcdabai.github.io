<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>IO进程笔记（一） - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="IO进程笔记（一）" />
<meta property="og:description" content="目录
一、IO知识
1.IO种类
2.系统调用
3.库函数
4.常见的标准IO和文件IO的函数接口
二、标准IO
1.FILE指针
2.man手册使用说明
3.fopen函数
4.fclose函数
5.内核中错误码的问题
5.2将错误码转换成错误信息的描述的函数
5.3 perror直接打印错误信息(重置错误码才可以用)
6.fgetc/fputc
7.fgets/fputs
8.标准IO的缓冲区
8.1 缓冲区的类型
8.2 缓冲区的大小
​编辑
8.3缓冲区刷新的时机
9.获取系统时间
获取实际时间
10.sprintf/snprintf
sprintf
snprintf
11.fread/fwrite
fread
fwrite
12.fseek/rewind/ftell
fseek
13.标准IO操作图片文件
三、文件IO
1.概念
2.文件操作
2.1open
2.2close
2.3read
2.4write
2.5lseek
2.目录操作
2.1stat
​编辑
2.2getpwuid和getgrgid
2.2opendir
2.3readdir
2.4closedir
四、库的制作
1.概念
2.静态库
2.1制作静态库
2.2静态库的使用
3.动态库
3.1制作动态库
3.2动态库的使用
一、IO知识 1.IO种类 标准IO：库函数
文件IO：系统调用
2.系统调用 概念：从用户空间到内核空间的过程(内核给用户留了接口，系统调用就是用户调用接口函数的过程，最后由内核把数据写到硬件中)
用户空间每个进程是独立的
内核空间每个进程是共享的(内核空间物理映射映射到同一块空间)
可移植性差，没缓冲区，效率低(由于没有缓冲区，写入一次数据就要进行一次系统调 用，频繁的系统调用是很浪费时间的)
因为每个系统都有自己的函数接口，函数接口不同，就会导致不同系统上的程序运行不了" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/35495d5ef27822aff0b5be2d0393c6b1/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-05-27T17:46:07+08:00" />
<meta property="article:modified_time" content="2023-05-27T17:46:07+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">IO进程笔记（一）</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p id="main-toc"><strong>目录</strong></p> 
<p id="%E4%B8%80%E3%80%81IO%E7%9F%A5%E8%AF%86-toc" style="margin-left:0px;"><a href="#%E4%B8%80%E3%80%81IO%E7%9F%A5%E8%AF%86" rel="nofollow">一、IO知识</a></p> 
<p id="1.IO%E7%A7%8D%E7%B1%BB-toc" style="margin-left:0px;"><a href="#1.IO%E7%A7%8D%E7%B1%BB" rel="nofollow">          1.IO种类</a></p> 
<p id="%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%202.%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8-toc" style="margin-left:40px;"><a href="#%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%202.%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8" rel="nofollow">           2.系统调用</a></p> 
<p id="%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%203.%E5%BA%93%E5%87%BD%E6%95%B0-toc" style="margin-left:40px;"><a href="#%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%203.%E5%BA%93%E5%87%BD%E6%95%B0" rel="nofollow">        3.库函数</a></p> 
<p id="%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%204.%E5%B8%B8%E8%A7%81%E7%9A%84%E6%A0%87%E5%87%86IO%E5%92%8C%E6%96%87%E4%BB%B6IO%E7%9A%84%E5%87%BD%E6%95%B0%E6%8E%A5%E5%8F%A3-toc" style="margin-left:40px;"><a href="#%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%204.%E5%B8%B8%E8%A7%81%E7%9A%84%E6%A0%87%E5%87%86IO%E5%92%8C%E6%96%87%E4%BB%B6IO%E7%9A%84%E5%87%BD%E6%95%B0%E6%8E%A5%E5%8F%A3" rel="nofollow">        4.常见的标准IO和文件IO的函数接口</a></p> 
<p id="%E4%BA%8C%E3%80%81%E6%A0%87%E5%87%86IO-toc" style="margin-left:0px;"><a href="#%E4%BA%8C%E3%80%81%E6%A0%87%E5%87%86IO" rel="nofollow">二、标准IO</a></p> 
<p id="1.FILE%E6%8C%87%E9%92%88-toc" style="margin-left:0px;"><a href="#1.FILE%E6%8C%87%E9%92%88" rel="nofollow">1.FILE指针</a></p> 
<p id="%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A02.man%E6%89%8B%E5%86%8C%E4%BD%BF%E7%94%A8%E8%AF%B4%E6%98%8E-toc" style="margin-left:40px;"><a href="#%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A02.man%E6%89%8B%E5%86%8C%E4%BD%BF%E7%94%A8%E8%AF%B4%E6%98%8E" rel="nofollow">2.man手册使用说明</a></p> 
<p id="3.fopen%E5%87%BD%E6%95%B0-toc" style="margin-left:40px;"><a href="#3.fopen%E5%87%BD%E6%95%B0" rel="nofollow">3.fopen函数</a></p> 
<p id="4.fclose%E5%87%BD%E6%95%B0-toc" style="margin-left:40px;"><a href="#4.fclose%E5%87%BD%E6%95%B0" rel="nofollow">4.fclose函数</a></p> 
<p id="5.%E5%86%85%E6%A0%B8%E4%B8%AD%E9%94%99%E8%AF%AF%E7%A0%81%E7%9A%84%E9%97%AE%E9%A2%98-toc" style="margin-left:40px;"><a href="#5.%E5%86%85%E6%A0%B8%E4%B8%AD%E9%94%99%E8%AF%AF%E7%A0%81%E7%9A%84%E9%97%AE%E9%A2%98" rel="nofollow">5.内核中错误码的问题</a></p> 
<p id="5.2%E5%B0%86%E9%94%99%E8%AF%AF%E7%A0%81%E8%BD%AC%E6%8D%A2%E6%88%90%E9%94%99%E8%AF%AF%E4%BF%A1%E6%81%AF%E7%9A%84%E6%8F%8F%E8%BF%B0%E7%9A%84%E5%87%BD%E6%95%B0-toc" style="margin-left:80px;"><a href="#5.2%E5%B0%86%E9%94%99%E8%AF%AF%E7%A0%81%E8%BD%AC%E6%8D%A2%E6%88%90%E9%94%99%E8%AF%AF%E4%BF%A1%E6%81%AF%E7%9A%84%E6%8F%8F%E8%BF%B0%E7%9A%84%E5%87%BD%E6%95%B0" rel="nofollow">5.2将错误码转换成错误信息的描述的函数</a></p> 
<p id="%C2%A05.3%20perror%E7%9B%B4%E6%8E%A5%E6%89%93%E5%8D%B0%E9%94%99%E8%AF%AF%E4%BF%A1%E6%81%AF(%E9%87%8D%E7%BD%AE%E9%94%99%E8%AF%AF%E7%A0%81%E6%89%8D%E5%8F%AF%E4%BB%A5%E7%94%A8)-toc" style="margin-left:80px;"><a href="#%C2%A05.3%20perror%E7%9B%B4%E6%8E%A5%E6%89%93%E5%8D%B0%E9%94%99%E8%AF%AF%E4%BF%A1%E6%81%AF%28%E9%87%8D%E7%BD%AE%E9%94%99%E8%AF%AF%E7%A0%81%E6%89%8D%E5%8F%AF%E4%BB%A5%E7%94%A8%29" rel="nofollow"> 5.3 perror直接打印错误信息(重置错误码才可以用)</a></p> 
<p id="6.fgetc%2Ffputc-toc" style="margin-left:40px;"><a href="#6.fgetc%2Ffputc" rel="nofollow">6.fgetc/fputc</a></p> 
<p id="7.fgets%2Ffputs-toc" style="margin-left:40px;"><a href="#7.fgets%2Ffputs" rel="nofollow">7.fgets/fputs</a></p> 
<p id="8.%E6%A0%87%E5%87%86IO%E7%9A%84%E7%BC%93%E5%86%B2%E5%8C%BA-toc" style="margin-left:40px;"><a href="#8.%E6%A0%87%E5%87%86IO%E7%9A%84%E7%BC%93%E5%86%B2%E5%8C%BA" rel="nofollow">8.标准IO的缓冲区</a></p> 
<p id="8.1%20%E7%BC%93%E5%86%B2%E5%8C%BA%E7%9A%84%E7%B1%BB%E5%9E%8B-toc" style="margin-left:80px;"><a href="#8.1%20%E7%BC%93%E5%86%B2%E5%8C%BA%E7%9A%84%E7%B1%BB%E5%9E%8B" rel="nofollow">8.1 缓冲区的类型</a></p> 
<p id="8.2%20%E7%BC%93%E5%86%B2%E5%8C%BA%E7%9A%84%E5%A4%A7%E5%B0%8F-toc" style="margin-left:80px;"><a href="#8.2%20%E7%BC%93%E5%86%B2%E5%8C%BA%E7%9A%84%E5%A4%A7%E5%B0%8F" rel="nofollow">8.2 缓冲区的大小</a></p> 
<p id="%E2%80%8B%E7%BC%96%E8%BE%91-toc" style="margin-left:80px;"><a href="#%E2%80%8B%E7%BC%96%E8%BE%91" rel="nofollow">​编辑</a></p> 
<p id="8.3%E7%BC%93%E5%86%B2%E5%8C%BA%E5%88%B7%E6%96%B0%E7%9A%84%E6%97%B6%E6%9C%BA-toc" style="margin-left:80px;"><a href="#8.3%E7%BC%93%E5%86%B2%E5%8C%BA%E5%88%B7%E6%96%B0%E7%9A%84%E6%97%B6%E6%9C%BA" rel="nofollow">8.3缓冲区刷新的时机</a></p> 
<p id="9.%E8%8E%B7%E5%8F%96%E7%B3%BB%E7%BB%9F%E6%97%B6%E9%97%B4-toc" style="margin-left:40px;"><a href="#9.%E8%8E%B7%E5%8F%96%E7%B3%BB%E7%BB%9F%E6%97%B6%E9%97%B4" rel="nofollow">9.获取系统时间</a></p> 
<p id="6.sprintf-toc" style="margin-left:40px;"><a href="#6.sprintf" rel="nofollow">获取实际时间</a></p> 
<p id="10.sprintf%2Fsnprintf-toc" style="margin-left:40px;"><a href="#10.sprintf%2Fsnprintf" rel="nofollow">10.sprintf/snprintf</a></p> 
<p id="sprintf-toc" style="margin-left:80px;"><a href="#sprintf" rel="nofollow">sprintf</a></p> 
<p id="snprintf-toc" style="margin-left:80px;"><a href="#snprintf" rel="nofollow">snprintf</a></p> 
<p id="%C2%A011.fread%2Ffwrite-toc" style="margin-left:40px;"><a href="#%C2%A011.fread%2Ffwrite" rel="nofollow"> 11.fread/fwrite</a></p> 
<p id="fread-toc" style="margin-left:80px;"><a href="#fread" rel="nofollow">fread</a></p> 
<p id="fwrite-toc" style="margin-left:80px;"><a href="#fwrite" rel="nofollow">fwrite</a></p> 
<p id="12.fseek%2Frewind%2Fftell-toc" style="margin-left:40px;"><a href="#12.fseek%2Frewind%2Fftell" rel="nofollow">12.fseek/rewind/ftell</a></p> 
<p id="fseek-toc" style="margin-left:80px;"><a href="#fseek" rel="nofollow">fseek</a></p> 
<p id="%C2%A013.%E6%A0%87%E5%87%86IO%E6%93%8D%E4%BD%9C%E5%9B%BE%E7%89%87%E6%96%87%E4%BB%B6-toc" style="margin-left:40px;"><a href="#%C2%A013.%E6%A0%87%E5%87%86IO%E6%93%8D%E4%BD%9C%E5%9B%BE%E7%89%87%E6%96%87%E4%BB%B6" rel="nofollow"> 13.标准IO操作图片文件</a></p> 
<p id="%E4%B8%89%E3%80%81%E6%96%87%E4%BB%B6IO-toc" style="margin-left:0px;"><a href="#%E4%B8%89%E3%80%81%E6%96%87%E4%BB%B6IO" rel="nofollow">三、文件IO</a></p> 
<p id="1.%E6%A6%82%E5%BF%B5-toc" style="margin-left:40px;"><a href="#1.%E6%A6%82%E5%BF%B5" rel="nofollow">1.概念</a></p> 
<p id="1.%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C-toc" style="margin-left:40px;"><a href="#1.%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C" rel="nofollow">2.文件操作</a></p> 
<p id="1.1open-toc" style="margin-left:40px;"><a href="#1.1open" rel="nofollow">2.1open</a></p> 
<p id="1.2close-toc" style="margin-left:40px;"><a href="#1.2close" rel="nofollow">2.2close</a></p> 
<p id="1.3read-toc" style="margin-left:40px;"><a href="#1.3read" rel="nofollow">2.3read</a></p> 
<p id="1.4write-toc" style="margin-left:40px;"><a href="#1.4write" rel="nofollow">2.4write</a></p> 
<p id="1.5lseek-toc" style="margin-left:40px;"><a href="#1.5lseek" rel="nofollow">2.5lseek</a></p> 
<p id="2.%E7%9B%AE%E5%BD%95%E6%93%8D%E4%BD%9C-toc" style="margin-left:40px;"><a href="#2.%E7%9B%AE%E5%BD%95%E6%93%8D%E4%BD%9C" rel="nofollow">2.目录操作</a></p> 
<p id="2.1stat-toc" style="margin-left:40px;"><a href="#2.1stat" rel="nofollow">2.1stat</a></p> 
<p id="%E2%80%8B%E7%BC%96%E8%BE%91-toc" style="margin-left:40px;"><a href="#%E2%80%8B%E7%BC%96%E8%BE%91" rel="nofollow">​编辑</a></p> 
<p id="2.2getpwuid%E5%92%8Cgetgrgid-toc" style="margin-left:40px;"><a href="#2.2getpwuid%E5%92%8Cgetgrgid" rel="nofollow">2.2getpwuid和getgrgid</a></p> 
<p id="2.2opendir-toc" style="margin-left:40px;"><a href="#2.2opendir" rel="nofollow">2.2opendir</a></p> 
<p id="2.3readdir-toc" style="margin-left:40px;"><a href="#2.3readdir" rel="nofollow">2.3readdir</a></p> 
<p id="2.4closedir-toc" style="margin-left:40px;"><a href="#2.4closedir" rel="nofollow">2.4closedir</a></p> 
<p id="%E5%9B%9B%E3%80%81%E5%BA%93%E7%9A%84%E5%88%B6%E4%BD%9C-toc" style="margin-left:0px;"><a href="#%E5%9B%9B%E3%80%81%E5%BA%93%E7%9A%84%E5%88%B6%E4%BD%9C" rel="nofollow">四、库的制作</a></p> 
<p id="1.%E6%A6%82%E5%BF%B5-toc" style="margin-left:40px;"><a href="#1.%E6%A6%82%E5%BF%B5" rel="nofollow">1.概念</a></p> 
<p id="2.%E9%9D%99%E6%80%81%E5%BA%93-toc" style="margin-left:40px;"><a href="#2.%E9%9D%99%E6%80%81%E5%BA%93" rel="nofollow">2.静态库</a></p> 
<p id="2.1%E5%88%B6%E4%BD%9C%E9%9D%99%E6%80%81%E5%BA%93-toc" style="margin-left:80px;"><a href="#2.1%E5%88%B6%E4%BD%9C%E9%9D%99%E6%80%81%E5%BA%93" rel="nofollow">2.1制作静态库</a></p> 
<p id="2.2%E9%9D%99%E6%80%81%E5%BA%93%E7%9A%84%E4%BD%BF%E7%94%A8-toc" style="margin-left:80px;"><a href="#2.2%E9%9D%99%E6%80%81%E5%BA%93%E7%9A%84%E4%BD%BF%E7%94%A8" rel="nofollow">2.2静态库的使用</a></p> 
<p id="%C2%A03.%E5%8A%A8%E6%80%81%E5%BA%93-toc" style="margin-left:40px;"><a href="#%C2%A03.%E5%8A%A8%E6%80%81%E5%BA%93" rel="nofollow"> 3.动态库</a></p> 
<p id="3.1%E5%88%B6%E4%BD%9C%E5%8A%A8%E6%80%81%E5%BA%93-toc" style="margin-left:80px;"><a href="#3.1%E5%88%B6%E4%BD%9C%E5%8A%A8%E6%80%81%E5%BA%93" rel="nofollow">3.1制作动态库</a></p> 
<p id="3.2%E5%8A%A8%E6%80%81%E5%BA%93%E7%9A%84%E4%BD%BF%E7%94%A8-toc" style="margin-left:80px;"><a href="#3.2%E5%8A%A8%E6%80%81%E5%BA%93%E7%9A%84%E4%BD%BF%E7%94%A8" rel="nofollow">3.2动态库的使用</a></p> 
<hr id="hr-toc"> 
<p></p> 
<h2 id="%E4%B8%80%E3%80%81IO%E7%9F%A5%E8%AF%86">一、IO知识</h2> 
<h2 id="1.IO%E7%A7%8D%E7%B1%BB">          1.IO种类</h2> 
<p>                        标准IO：库函数</p> 
<p>                        文件IO：系统调用</p> 
<h3 id="%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%202.%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8">           2.系统调用</h3> 
<p>                概念：从用户空间到内核空间的过程(内核给用户留了接口，系统调用就是用户调用接口函数的过程，最后由内核把数据写到硬件中)</p> 
<p>                用户空间每个进程是独立的</p> 
<p>                内核空间每个进程是共享的(内核空间物理映射映射到同一块空间)</p> 
<p>                可移植性差，没缓冲区，效率低(由于没有缓冲区，写入一次数据就要进行一次系统调   用，频繁的系统调用是很浪费时间的)</p> 
<p>                因为每个系统都有自己的函数接口，函数接口不同，就会导致不同系统上的程序运行不了</p> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/fc/d0/bWqSu8cV_o.png"></p> 
<h3 id="%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%203.%E5%BA%93%E5%87%BD%E6%95%B0">        3.库函数</h3> 
<p>                系统调用+缓冲区，可移植性强，效率高(不用频繁的)</p> 
<p>                先缓存数据，刷新以后写入硬盘</p> 
<p><img alt="" height="874" src="https://images2.imgbox.com/5f/29/dK1i1vnt_o.png" width="1200"></p> 
<p></p> 
<h3 id="%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%204.%E5%B8%B8%E8%A7%81%E7%9A%84%E6%A0%87%E5%87%86IO%E5%92%8C%E6%96%87%E4%BB%B6IO%E7%9A%84%E5%87%BD%E6%95%B0%E6%8E%A5%E5%8F%A3">        4.常见的标准IO和文件IO的函数接口</h3> 
<p>                标准IO：printf  scanf  fopen  fwrite  fclose  fgets  fputs  fgetc  fputc.... </p> 
<p>                文件IO：open read write close</p> 
<h2 id="%E4%BA%8C%E3%80%81%E6%A0%87%E5%87%86IO">二、标准IO</h2> 
<h2 id="1.FILE%E6%8C%87%E9%92%88">1.FILE指针</h2> 
<p>               FILE是_IO_FILE的别名</p> 
<p><img alt="" height="217" src="https://images2.imgbox.com/19/73/Cb20Qv2c_o.png" width="784"></p> 
<p> 那么_IO_FILE是啥呢？</p> 
<p>_IO_FILE是一个结构体，当使用 fopen 函数打开一个文件的时候，就会产生一个FILE结构体，该结构体中保存着所有和当前文件相关的信息，后面再对文件进行IO操作的时候，使用的就是这个结构体。每个进程维护自己的FILE指针，即使多个进程打开了同一个文件，他们的FILE指针也不一样。</p> 
<p><img alt="" height="571" src="https://images2.imgbox.com/9d/86/LaR5tzhN_o.png" width="822"></p> 
<p></p> 
<p>               每个FILE指针里都有文件描述符。</p> 
<p>每一个正在运行的程序都有三个已经打开且可以直接使用的FILE指针：</p> 
<p>                        stdin  stdout  stderr(程序本身就是文件.c文件)</p> 
<h3 id="%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A02.man%E6%89%8B%E5%86%8C%E4%BD%BF%E7%94%A8%E8%AF%B4%E6%98%8E">2.man手册使用说明</h3> 
<blockquote> 
 <p>        命令           man  1   ls</p> 
 <p>        系统调用    man  2   open</p> 
 <p>        库函数       man  3    sleep</p> 
</blockquote> 
<h3 id="3.fopen%E5%87%BD%E6%95%B0">3.fopen函数</h3> 
<blockquote> 
 <p>        函数原型：FILE *fopen(const char *pathname, const char *mode);       </p> 
 <p></p> 
 <p>        功能：以不同模式打开此路径下的文件</p> 
 <p></p> 
 <p>        参数：带路径的文件名     模式</p> 
 <p>                r：读方式打开，光标在文件开头。没有文件报错</p> 
 <p>                r+：读写方式打开，光标在文件开头。没有文件报错</p> 
 <p>                w：写方式打开，如果没有则创建，如果文件存在则清空。光标在文件开头</p> 
 <p>                w+：读写方式打开，如果没有则创建，如果文件存在则清空，光标在文件开头</p> 
 <p>                a：追加写方式打开，如果没有则创建，如果文件存在光标在文件末尾</p> 
 <p>                a+：读写方式打开，读光标在文件开头，写光标在文件末尾</p> 
 <p></p> 
 <p>        返回值：成功：文件指针(FILE指针)</p> 
 <p>                      失败： NULL 重置错误码</p> 
</blockquote> 
<h3 id="4.fclose%E5%87%BD%E6%95%B0">4.fclose函数</h3> 
<blockquote> 
 <p>        函数原型：int fclose(FILE *stream);</p> 
 <p></p> 
 <p>        功能：关闭FILE指针指向的文件</p> 
 <p></p> 
 <p>        参数：fopen产生的文件的FILE指针</p> 
 <p></p> 
 <p>        返回值：成功：0</p> 
 <p>                      失败：EOF  重置错误码</p> 
</blockquote> 
<pre><code class="language-cpp">#include &lt;stdio.h&gt;
#include &lt;unistd.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;
#include &lt;time.h&gt;

int main(int argc, const char *argv[])
{
    FILE *fp=NULL;
    fp=fopen("test.c","r");//以读的方式打开文件
    //FILE *fp=fopen("test.c","w");//以写的方式打开文件
    f(NULL == fp){
		printf("fopen error\n");
		return -1;
	}
    fclose(fp);
    
    printf("1111\n"); //有显示
	fclose(stdin);
	fclose(stdout);
	fclose(stderr);
	printf("2222\n"); //没有显示了 因为 stdout 标准输出已经被关闭了


    return 0;
}</code></pre> 
<h3 id="5.%E5%86%85%E6%A0%B8%E4%B8%AD%E9%94%99%E8%AF%AF%E7%A0%81%E7%9A%84%E9%97%AE%E9%A2%98">5.内核中错误码的问题</h3> 
<p>当用户调用系统接口调用失败的时候，内核会给调用者返回错误码，</p> 
<p>调用者需要在自己程序中包含#include &lt;errno.h&gt;头文件，在这个头</p> 
<p>文件中有一个errno的变量，这个变量就可以接到错误的数值。用户</p> 
<p>就可以根据这个数据判断出来程序是因为什么原因失败的。</p> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/3c/03/plcWo3Io_o.png"></p> 
<p>重置的是errno，调用函数出错时，会用宏定义里的错误信息重置errno，这样就可以知道出什么错误了        </p> 
<pre><code class="language-cpp">#include &lt;stdio.h&gt;
#include &lt;unistd.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;
#include &lt;errno.h&gt;

int main(int argc, const char *argv[])
{

    fp=fopen("test.c","r");//以读的方式打开一个不存在的文件
    f(NULL == fp){
		printf("error:%d"，errno);
		return -1;
	}
	return 0;
}</code></pre> 
<h4 id="5.2%E5%B0%86%E9%94%99%E8%AF%AF%E7%A0%81%E8%BD%AC%E6%8D%A2%E6%88%90%E9%94%99%E8%AF%AF%E4%BF%A1%E6%81%AF%E7%9A%84%E6%8F%8F%E8%BF%B0%E7%9A%84%E5%87%BD%E6%95%B0">5.2将错误码转换成错误信息的描述的函数</h4> 
<p>   </p> 
<blockquote> 
 <p>        函数原型：char *strerror(int errnum);</p> 
 <p>        功能：将错误码转换成错误信息的描述</p> 
 <p></p> 
 <p>        参数：errnum：错误码</p> 
 <p></p> 
 <p>        返回值：错误信息描述的字符串</p> 
</blockquote> 
<pre><code class="language-cpp">#include &lt;stdio.h&gt;
#include &lt;unistd.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;
#include &lt;errno.h&gt;

int main(int argc, const char *argv[])
{

    fp=fopen("test.c","r");//以读的方式打开一个不存在的文件
    f(NULL == fp){
		printf("error:%d"，strerror(errno));
		return -1;
	}
	return 0;
}</code></pre> 
<h4 id="%C2%A05.3%20perror%E7%9B%B4%E6%8E%A5%E6%89%93%E5%8D%B0%E9%94%99%E8%AF%AF%E4%BF%A1%E6%81%AF(%E9%87%8D%E7%BD%AE%E9%94%99%E8%AF%AF%E7%A0%81%E6%89%8D%E5%8F%AF%E4%BB%A5%E7%94%A8)"> 5.3 perror直接打印错误信息(重置错误码才可以用)</h4> 
<blockquote> 
 <p>        函数原型：void perror(const char *s);</p> 
 <p>        功能： 重置错误码之后 可以使用perror直接输出错误信息</p> 
 <p></p> 
 <p>        出错后 应该立即输出错误信息 否则后面可能就被覆盖了</p> 
 <p></p> 
 <p>        参数： s：用户附加的错误信息</p> 
 <p></p> 
 <p>        返回值：void</p> 
</blockquote> 
<pre><code class="language-cpp">#include &lt;stdio.h&gt;
#include &lt;unistd.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;
#include &lt;errno.h&gt;

int main(int argc, const char *argv[])
{

    fp=fopen("test.c","r");//以读的方式打开一个不存在的文件
    f(NULL == fp){
		perror("fopen error");//perror会自动加冒号且自动换行
        //printf("fopen error : %s\n", strerror(errno));相当于这一行
		return -1;
	}
	return 0;
}</code></pre> 
<p> 自定义头文件</p> 
<pre><code class="language-cpp">#ifndef __HEAD_H__
#define __HEAD_H__

#include &lt;stdio.h&gt;
#include &lt;unistd.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;
#define ERRLOG(msg) do{\
        printf("%s %s %d\n", __FILE__, __func__, __LINE__);\
        perror(msg);\
        exit(-1);\
    }while(0)

#endif</code></pre> 
<p> 需要将头文件放到  /usr/include 下 sudo mv head.h /usr/include</p> 
<h3 id="6.fgetc%2Ffputc">6.fgetc/fputc</h3> 
<p><strong>fgetc</strong></p> 
<blockquote> 
 <p>        函数原型：int fgetc(FILE *stream);</p> 
 <p>        功能：从文件获取一个字符</p> 
 <p></p> 
 <p>        参数：文件的FILE指针</p> 
 <p></p> 
 <p>        返回值：成功 读取的字符</p> 
 <p>                      失败或者文件结束 -1(EOF)</p> 
</blockquote> 
<p><strong>fputc</strong></p> 
<blockquote> 
 <p>        函数原型：int fputc(int c, FILE *stream);</p> 
 <p>        功能：向文件中写入一个字符</p> 
 <p></p> 
 <p>        参数：c：要写入的字符</p> 
 <p>                   stream：文件指针</p> 
 <p></p> 
 <p>        返回值：成功 写入的字符</p> 
 <p>                      失败或者文件结束 -1(EOF)</p> 
 <p></p> 
</blockquote> 
<p>练习：</p> 
<p>使用 fgetc 统计文件有多少行</p> 
<p>要求 ./a.out 文件名</p> 
<pre><code class="language-cpp">    int count=0;
	FILE *fp=NULL;
	fp=fopen(argv[1],"r");
	if(NULL==fp){
        printf("%s %s %d\n", __FILE__, __func__, __LINE__);
    	perror("fopen error");
    	exit(-1);
	}
	char c=0;
	while((c=(fgetc(fp)))!=EOF){
		if(c=='\n'){
			count++;
		}
	}
	//不接不行
	/*while(fgetc(fp)!=EOF){
		if(fgetc(fp)=='\n'){//这一步的fgetc(fp)和上一步的已经不一样了，光标又向后移了一个
			count++;
		}
	}*/
	printf("LINE=%d\n",count);
	fclose(fp);</code></pre> 
<p>练习：</p> 
<p>使用 fgetc/fputc 实现文件拷贝的功能</p> 
<p>要求 ./a.out src_file dest_file</p> 
<pre><code class="language-cpp">    FILE *fp1=fopen(argv[1],"r");
	if(NULL==fp1){
        printf("%s %s %d\n", __FILE__, __func__, __LINE__);
    	perror("fopen error");
    	exit(-1);
	}
	FILE *fp2=fopen(argv[2],"w");
	if(NULL==fp2){
        printf("%s %s %d\n", __FILE__, __func__, __LINE__);
    	perror("fopen error");
    	exit(-1);
	}
	char c=0;
	while((c=(fgetc(fp1)))!=EOF){
		fputc(c,fp2);
	}
	fclose(fp1);
	fclose(fp2);</code></pre> 
<h3 id="7.fgets%2Ffputs">7.fgets/fputs</h3> 
<p><strong>fgets</strong></p> 
<blockquote> 
 <p>        函数原型：char *fgets(char *s, int size, FILE *stream);</p> 
 <p>        功能：从文件获取一个字符串</p> 
 <p>                   最多读取size-1个字符放到s指向的缓冲区中</p> 
 <p>                   缓冲区满之前遇到换行符或者EOF停止获取，并在获取的字符串后面加一个'\0'</p> 
 <p>                   或者缓冲区满结束，读到size-1个字符结束，后面有一个'\0'</p> 
 <p>       </p> 
 <p>        参数： s：缓冲区首地址</p> 
 <p>                   size：缓冲区大小</p> 
 <p>                   stream：文件的FILE指针</p> 
 <p></p> 
 <p>        返回值：成功 s</p> 
 <p>                      失败或者文件结束 NULL</p> 
</blockquote> 
<pre><code class="language-cpp">#include &lt;stdio.h&gt;
#include &lt;unistd.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;
#include &lt;errno.h&gt;

int main(int argc,const char * argv[])
{
    //在终端获取字符串
    char buff[6]={0};
    fgets(buff,sizeof(buff),stdin);
    //清理终端每次输入的\n,数组从零开始计数，所以在长度-1的位置换
    buff[strlen(buff)-1]='\0';
    printf("[%s]",buff);
    

    //在文件获取字符串
    FILE *fp=("test.c","r");
    fgets(buff,sizeof(buff),fp);//一行没读完，就到size了，就只能读size-1个
                                //如果遇到\n了,就从上一次的size开始读，读到\n为止
    printf("[%s]",buff);
    
    return 0;
}
</code></pre> 
<p>文件内容：</p> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/39/c5/F8YJbPqy_o.png"></p> 
<p>第一次读到hello+space(空格)，第二次读到world</p> 
<p><strong>fputs</strong></p> 
<blockquote> 
 <p>        函数原型：int fputs(const char *s, FILE *stream);</p> 
 <p>        功能：向文件中写入一个字符串</p> 
 <p></p> 
 <p>        参数：s：要写入的字符串的首地址</p> 
 <p>                   stream：文件指针</p> 
 <p></p> 
 <p>        返回值：成功 大于等于0的数</p> 
 <p>                      失败 EOF</p> 
</blockquote> 
<pre><code class="language-cpp">int main(int argc,const char * argv[])
{
    FILE *fp = fopen("hello.txt", "w");
    if(NULL == fp){
        perror("fopen error");
        exit(-1);
    }
    //将内容写入文件
    fputs("HELLO", fp);
    char buff[32] = "aabbccdd";
    fputs(buff, fp);

    //将内容写入终端
    fputs("HELLO", stdout);
    fputs(buff, stderr);

    fclose(fp);

    return 0;
}</code></pre> 
<p>练习：</p> 
<p>1.使用 fgets 判断文件有多少行；</p> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/b2/ef/lHDwXMh2_o.png"></p> 
<p></p> 
<pre><code class="language-cpp">int main(int argc, const char *argv[])
{
    FILE *fp=fopen(argv[1],"r");
	char buff[8]={0};
	int count=0;
	//char *p=NULL;
	//while(fgets(buff,sizeof(buff),fp)!=NULL)
	while(NULL != fgets(buff, sizeof(buff), fp)){
		if(strlen(buff)&lt;(sizeof(buff)-1)){//fgets读到八个，但是第八个是'\0',strlen不计入长度,所以要判断strlen(buff)是否小于8-1
			count++;
			printf("11111\n");
		}
		else if(strlen(buff)==(sizeof(buff)-1)){
			if(strcmp(&amp;(buff[strlen(buff)-1]),"\n")){
				count++;
				printf("2222\n");
			}
		}
		printf("3333\n");
	}
	printf("%d\n",count);
	fclose(fp);
	return 0;

}</code></pre> 
<p> 简单思路：</p> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/ca/85/t7xHZnv4_o.png"></p> 
<p><span style="color:#fe2c24;"><em>只要'\0'前一个字符是'\n'就让行号自加1。</em></span></p> 
<pre><code class="language-cpp">int main(int argc, const char *argv[])
{
    FILE *fp=fopen(argv[1],"r");
	char buff[8]={0};
	int count=0;
	//char *p=NULL;
	//while(fgets(buff,sizeof(buff),fp)!=NULL)
	while(NULL != fgets(buff, sizeof(buff), fp)){
		if(buff[strlen(buff)-1])){
		    count++;
	}
	printf("%d\n",count);
	fclose(fp);
	return 0;

}</code></pre> 
<p>2.使用 fgets/fputs 实现文件的拷贝</p> 
<pre><code class="language-cpp">int main(int argc,const char * argv[])
{
    if(3 != argc){
        printf("Usage : %s src_file dest_file\n", argv[0]);
        exit(-1);
    }
    FILE *fp_src = fopen(argv[1], "r");
    if(NULL == fp_src)
        ERRLOG("fopen error");
    FILE *fp_dest = fopen(argv[2], "w");
    if(NULL == fp_dest)
        ERRLOG("fopen error");
    char buff[64] = {0};
    
    while(NULL != fgets(buff, sizeof(buff), fp_src)){
        fputs(buff, fp_dest);
    }
    fclose(fp_src);
    fclose(fp_dest);

    return 0;
}</code></pre> 
<h3 id="8.%E6%A0%87%E5%87%86IO%E7%9A%84%E7%BC%93%E5%86%B2%E5%8C%BA">8.标准IO的缓冲区</h3> 
<h4 id="8.1%20%E7%BC%93%E5%86%B2%E5%8C%BA%E7%9A%84%E7%B1%BB%E5%9E%8B">8.1 缓冲区的类型</h4> 
<p>行缓冲：1024  和终端相关的stdin stdout printf</p> 
<p>全缓冲：4096  和文件相关的</p> 
<p>无缓冲：stderr  缓冲区大小是 0</p> 
<h4 id="8.2%20%E7%BC%93%E5%86%B2%E5%8C%BA%E7%9A%84%E5%A4%A7%E5%B0%8F">8.2 缓冲区的大小</h4> 
<p>        (1)行缓冲</p> 
<pre><code class="language-cpp">nt main(int argc,const char * argv[])
{
    printf("hello\n");//需要先使用一下 才能看到现象
    printf("stdout buff size = [%ld]\n",
        stdout-&gt;_IO_buf_end - stdout-&gt;_IO_buf_base);//1024
    
    int a = 0;
    scanf("%d", &amp;a);
    printf("stdin buff size = [%ld]\n",
        stdin-&gt;_IO_buf_end - stdin-&gt;_IO_buf_base);//1024
    
    perror("test:");
    printf("stderr buff size = [%ld]\n",
        stderr-&gt;_IO_buf_end - stderr-&gt;_IO_buf_base);//0
    
    return 0;
}</code></pre> 
<p>        (2)全缓冲</p> 
<pre><code class="language-cpp">FILE *fp=fopen("t.c","w");
	fputs("hello",fp);//需要使用一下，用fputs
	printf("全缓冲：%ld\n",fp-&gt;_IO_buf_end-fp-&gt;_IO_buf_base);	
	fclose(fp);
</code></pre> 
<h4 id="%E2%80%8B%E7%BC%96%E8%BE%91"><img alt="" height="143" src="https://images2.imgbox.com/2e/15/NgSgmV3F_o.png" width="253"></h4> 
<p>(3)无缓冲 </p> 
<p>        标准出错,测试出来的结果是1，但是向标准出错中写1字节，<br>         这个字节的数据会立马写到终端上，所以认为标准出错没有缓冲</p> 
<pre><code class="language-cpp">    fputs("test stderr buffer size\n", stderr);
    printf("stderr size = %ld\n", stderr-&gt;_IO_buf_end - stderr-&gt;_IO_buf_base);</code></pre> 
<p>(4)全缓冲</p> 
<p> 文件相关缓冲区，大小是4K</p> 
<pre><code class="language-cpp">FILE* fp;
    if ((fp = fopen("./hello.txt", "w+")) == NULL)
        PRINT_ERR("fopen error");
    fputc('t',fp);
    printf("fp size = %ld\n", fp-&gt;_IO_buf_end - fp-&gt;_IO_buf_base);
    fclose(fp);</code></pre> 
<h4 id="8.3%E7%BC%93%E5%86%B2%E5%8C%BA%E5%88%B7%E6%96%B0%E7%9A%84%E6%97%B6%E6%9C%BA">8.3缓冲区刷新的时机</h4> 
<p>行缓冲</p> 
<blockquote> 
 <p>1.程序结束</p> 
 <pre><code class="language-cpp">    //程序结束 会刷新
    printf("hello");</code></pre> 
 <p>2."\n"</p> 
 <pre><code class="language-cpp">    //遇到换行符 \n 会刷新
    printf("hello\n");
    while(1);</code></pre> 
 <p>3.输入输出切换</p> 
 <pre><code class="language-cpp">    //输入(scanf)和输出(printf)切换时会刷新
    printf("hello");
    int a = 0;
    scanf("%d", &amp;a);</code></pre> 
 <p>4.fflush</p> 
 <pre><code class="language-cpp">    //手动调用fflush函数刷新
    printf("hello");
    fflush(stdout);
    while(1);</code></pre> 
 <p>5.关闭文件</p> 
 <pre><code class="language-cpp">    //关闭文件时也会刷新
    printf("hello");
    fclose(stdout);
    while(1);</code></pre> 
 <p>6.缓冲区满</p> 
 <pre><code class="language-cpp">    //缓冲区满的时候会刷新
    int i = 0;
    for(i = 0; i &lt; 1025; i++){
        fputc('H', stdout);
    }
    while(1);</code></pre> 
 <p></p> 
</blockquote> 
<p>全缓冲</p> 
<blockquote> 
 <p>1.程序结束</p> 
 <pre><code class="language-cpp">    //程序结束会刷新
    ctrl+c 结束 不会刷新
    fputs("hello\n", fp);</code></pre> 
 <p>2.关闭文件</p> 
 <pre><code class="language-cpp">
    //关闭文件会刷新
    fputs("hello\n", fp);
    fclose(fp);
    while(1);</code></pre> 
 <p>3.fflush</p> 
 <pre><code class="language-cpp">  //手动调用fflush函数刷新
  fputs("hello\n", fp);
  fflush(fp);
  while(1);
</code></pre> 
 <p>4.输入输出切换</p> 
 <pre><code class="language-cpp">    //输入输出切换会刷新
    fputs("hello\n", fp);
    char buff[10];
    fgets(buff, 10, fp);
    while(1);</code></pre> 
 <p>5.缓冲区满</p> 
 <pre><code class="language-cpp">    int i = 0;
    for(i = 0; i &lt; 4097; i++){
        fputc('H', fp);
    }
    while(1);</code></pre> 
</blockquote> 
<p>几种等价写法</p> 
<pre><code class="language-cpp">    //几种等价写法
	printf("hi\n");
	fprintf(stdout,"hi");

    int num = 10;
    printf("num = %d\n", num);
    fprintf(stdout, "num = %d\n", num);
    
	
    fprintf(stderr, "num = %d\n", num);

    
    //向文件输出格式化的字符串：
    FILE *fp = fopen("filename", "a");
    fprintf(fp, "num = %d\n", num);
  
    </code></pre> 
<h3 id="9.%E8%8E%B7%E5%8F%96%E7%B3%BB%E7%BB%9F%E6%97%B6%E9%97%B4">9.获取系统时间</h3> 
<blockquote> 
 <p>函数原型：time_t time(time_t *tloc);</p> 
 <p>功能：获取 1970-01-01 00:00:00 距今的秒数</p> 
 <p></p> 
 <p>参数和返回值都是获取的结果</p> 
 <p><img alt="" height="254" src="https://images2.imgbox.com/f1/d8/ylUiYUPf_o.png" width="971"></p> 
 <p> 两种方式均可</p> 
 <pre><code class="language-cpp">	time_t tm=0;
	//time(&amp;tm);
	tm=time(NULL);
	printf("time:%ld\n",tm);</code></pre> 
 <p><img alt="" height="98" src="https://images2.imgbox.com/d9/5a/4bUy2fgL_o.png" width="382"></p> 
</blockquote> 
<h3 id="6.sprintf">获取实际时间</h3> 
<blockquote> 
 <p>函数原型：struct tm *localtime(const time_t *timep);</p> 
 <p>功能：将time() 获取的时间转换为现在实际时间</p> 
 <p></p> 
 <p>参数：time() 获取的秒数</p> 
 <p></p> 
 <p>返回值：时间结构体首地址</p> 
 <p>               重置错误码</p> 
 <p>     struct tm {<!-- --></p> 
 <p>                int tm_sec; /* 秒 (0-60) */</p> 
 <p>                int tm_min; /* 分钟 (0-59) */</p> 
 <p>                int tm_hour; /* 小时 (0-23) */</p> 
 <p>                int tm_mday; /* 一个月中的第几天 (1-31) */</p> 
 <p>                int tm_mon; /* 月 (0-11) */ +1</p> 
 <p>                int tm_year; /* 年 - 1900 */ 使用时得 + 1900</p> 
 <p>                int tm_wday; /* 周几 (0-6, Sunday = 0) */</p> 
 <p>                int tm_yday; /* 一年中的第几天 (0-365, 1 Jan = 0) */</p> 
 <p>                nt tm_isdst; /* 夏令时 */ </p> 
 <p>        }       </p> 
 <p>     </p> 
 <pre><code class="language-cpp">int main(int argc, char const *argv[])
{
	time_t tm=0;
	//time(&amp;tm);
	tm=time(NULL);
	printf("time:%ld\n",tm);
	
    //有返回值，用指针接
	struct tm *t=localtime(tm);
	
	printf("%d年%d月%d日 %2d:%2d:%2d",t-&gt;tm_year+1900,t-&gt;tm_mon+1,
	t-&gt;tm_mday+1,t-&gt;tm_hour,t-&gt;tm_min,t-&gt;tm_sec);
    return 0;
}</code></pre> 
</blockquote> 
<p>作业：</p> 
<p>把系统时间写入文件中</p> 
<p>要求：支持断点续写</p> 
<p>用sleep没问题</p> 
<pre><code class="language-cpp">#include &lt;stdio.h&gt;
#include &lt;unistd.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;
#include &lt;time.h&gt;
#include &lt;errno.h&gt;

int main(int argc, const char *argv[])
{
    //把系统时间写入文件中
	//要求：支持断点续写
	/*if(argc!=2){
		printf("Usage : %s src_file dest_file\n", argv[0]);
        exit(-1);
	}*/
	FILE *fp=fopen("DateLOG.txt","a+");
	if(NULL == fp){
        printf("%s %s %d\n", __FILE__, __func__, __LINE__); 
        perror("open error");  
        exit(-1); 
    }
	time_t tmold=0;
	time_t tnew=0;
	struct tm *t=NULL;
	char buff[10]={0};
	char c=0;
	int count=0;
		while(NULL!=fgets(buff,sizeof(buff),fp)){
			if(strlen(buff)&lt;(sizeof(buff)-1)){//fgets读到八个，但是第八个是'\0',strlen不计入长度,所以要判断strlen(buff)是否小于8-1
				count++;
			}
			else if(strlen(buff)==(sizeof(buff)-1)){
				if(strcmp(&amp;(buff[strlen(buff)-1]),"\n")){//如果相等strcmp返回值为0，那么不进if语句，如果没遇到\n,则跳过
					continue;
				}
		}
	}
	/*while((c=fgetc(fp))!=EOF){
		if(c=='\n'){
			count++;
		}
    }/**/
	while(1){
		//sleep(1);
		//count++;没想等之前一直在自增
		//printf("1:%d\n",count);
		if(-1==(tnew=time(&amp;tnew))){
			perror("time error");
		}
		if(tnew!=tmold){
			t=localtime((&amp;tnew));
			if(t==NULL){
				perror("localtime error");
			}
			count++;//时间不一样的时候++
			//printf("3:%d\n",count);	
			fprintf(fp,"%d.%d年%d月%d日 %02d:%0d:%02d\n",count,t-&gt;tm_year+1900,t-&gt;tm_mon+1,
			t-&gt;tm_mday+1,t-&gt;tm_hour,t-&gt;tm_min,t-&gt;tm_sec);
			fflush(fp);//忘刷新文件了，一直在缓冲区
			tmold=tnew;
		}
		/*struct tm *t=localtime((&amp;tnew));
		if(tnew==NULL){
			perror("time error");
		}
		fprintf(fp,"%d.%d年%d月%d日 %02d:%0d:%02d\n",count,t-&gt;tm_year+1900,t-&gt;tm_mon+1,
		t-&gt;tm_mday+1,t-&gt;tm_hour,t-&gt;tm_min,t-&gt;tm_sec);
		fflush(fp);//忘刷新文件了，一直在缓冲区
		sleep(1);*/
	}
	fclose(fp);
}  </code></pre> 
<p> <strong>格式化控制参数函数</strong></p> 
<blockquote> 
 <p>#include &lt;stdarg.h&gt;<br> void va_start(va_list ap, last);<br> 功能：根据最后一个成员构造ap<br> type va_arg(va_list ap, type);<br> 功能：根据ap,向后取type类型的数据<br> void va_end(va_list ap);<br> 功能：销毁ap成员</p> 
 <p></p> 
 <pre><code class="language-cpp">#include &lt;head.h&gt;
#include &lt;stdarg.h&gt;

int add(int n, ...)
{
    int sum = 0;
    va_list ap;
    va_start(ap, n);
    for (int i = 0; i &lt; n; i++) {
        sum += va_arg(ap, int);
    }
    va_end(ap);

    return sum;
}

int main(int argc, const char* argv[])
{
    printf("sum = %d\n", add(2, 100, 200));
    printf("sum = %d\n", add(4, 100, 200, 300, 400));
    return 0;
}</code></pre> 
 <p></p> 
</blockquote> 
<h3 id="10.sprintf%2Fsnprintf">10.sprintf/snprintf</h3> 
<h4 id="sprintf"><strong>sprintf</strong></h4> 
<blockquote> 
 <p>函数原型：int sprintf(char *str, const char *format, ...);</p> 
 <p>头文件：#include &lt;stdio.h&gt;</p> 
 <p>功能：格式化的字符串写到str指向的地址中</p> 
 <p></p> 
 <p>参数：str：字符串首地址</p> 
 <p>          format：格式</p> 
 <p>           ...：可变参</p> 
 <p></p> 
 <p>返回值：成功 格式化的字符串的长度</p> 
 <p>              失败 返回一个负数</p> 
</blockquote> 
<p>例：</p> 
<blockquote> 
 <p>基础用法</p> 
 <pre><code class="language-cpp">char str[10]={0};
    sprintf(str,"hello");
    printf("%s\n",str);
    return 0;</code></pre> 
 <p><img alt="" height="83" src="https://images2.imgbox.com/9e/4b/QDyCnUoa_o.png" width="537"></p> 
 <p></p> 
 <p></p> 
 <p>还可以写入数字</p> 
 <pre><code class="language-cpp">char str[10]={0};
    int num=10;
    sprintf(str,"hello");
    sprintf(str,"%d",num);
    printf("%s\n",str);
    return 0;</code></pre> 
 <p><img alt="" height="86" src="https://images2.imgbox.com/59/84/aEd5kkpJ_o.png" width="541"></p> 
 <p></p> 
 <p></p> 
 <p> hello被新写入的num覆盖了，如果不想覆盖，需要手动计算位置，如下</p> 
 <pre><code class="language-cpp">char str[10]={0};
    int num=10;
    sprintf(str,"hello");
    sprintf(str+5,"%d",num);
    printf("%s\n",str);
    return 0;</code></pre> 
 <p><img alt="" height="85" src="https://images2.imgbox.com/2b/7c/yUTVwNpI_o.png" width="528"></p> 
 <p></p> 
 <p></p> 
 <p>sprintf写入的内容不限数据类型，什么类型都可以写，如下</p> 
 <pre><code class="language-cpp">char buff[128] = {0};
    int num = 10;
    sprintf(buff, "num = %d\n", num);
    printf("buff=[%s]\n", buff);</code></pre> 
 <p><img alt="" height="79" src="https://images2.imgbox.com/6e/53/aHH5VFJw_o.png" width="547"></p> 
 <pre><code class="language-cpp">char buff[128]={0};
    time_t tm=0;
    time(&amp;tm);
    struct tm *t=localtime(&amp;tm);
    sprintf(buff, "%d年%d月%d日  %02d:%02d:%02d", t-&gt;tm_year+1900,t-&gt;tm_mon+1,t-&gt;tm_mday+1,
    t-&gt;tm_hour,t-&gt;tm_min,t-&gt;tm_sec);
    printf("%s",buff);</code></pre> 
 <p><img alt="" height="82" src="https://images2.imgbox.com/8d/a5/dDN8ly0f_o.png" width="711"></p> 
 <p></p> 
 <p><span style="color:#fe2c24;"><strong>//注意 sprintf不会对数组的大小做检查(会报警告，运行出错)</strong></span></p> 
 <p><span style="color:#fe2c24;"><strong> //有可能出现越界访问的问题</strong></span></p> 
 <pre><code class="language-cpp">    char str[10]={0};
    int num=10;
    sprintf(str, "hello worldasdfasdf%d", num);
    printf("%s\n",str);</code></pre> 
 <p>编译虽然会报警告，警告不是错，但是可以运行，会出现越界访问的问题，错误未知<img alt="" height="365" src="https://images2.imgbox.com/87/d8/0zrTXHIa_o.png" width="1028"></p> 
 <p></p> 
</blockquote> 
<h4 id="snprintf">snprintf</h4> 
<blockquote> 
 <p>函数原型：int snprintf(char *str, size_t size, const char *format, ...);</p> 
 <p>头文件：#include &lt;stdio.h&gt;</p> 
 <p>功能：格式化的字符串写到str指向的地址中</p> 
 <p></p> 
 <p>参数：str：字符串首地址</p> 
 <p>           size：最多只能将 size-1 个字符写入str指向的地址 最后一个位置是'\0'</p> 
 <p>           format：格式</p> 
 <p>           ...：可变参</p> 
 <p></p> 
 <p>返回值：成功 格式化的字符串的长度</p> 
 <p>              失败 返回一个负数</p> 
</blockquote> 
<p> 例：</p> 
<p>都传sizeof(buff)个</p> 
<pre><code class="language-cpp">int main(int argc,const char * argv[])
{
    char buff[128] = {0};
    int num = 10;
    snprintf(buff, sizeof(buff), "num = %d\n", num);
    printf("buff=[%s]\n", buff);

    memset(buff, 0, 128);
    time_t tm = time(NULL);
    struct tm *p = localtime(&amp;tm);
    snprintf(buff, sizeof(buff), "%04d-%02d-%02d %02d:%02d:%02d\n",
            p-&gt;tm_year+1900, p-&gt;tm_mon+1, p-&gt;tm_mday,
            p-&gt;tm_hour, p-&gt;tm_min, p-&gt;tm_sec);
    printf("%s\n", buff);

    //注意 snprintf会对数组的大小做检查
    //不会出现越界访问的问题
    char str[8] = {0};
    snprintf(str, sizeof(str),"hello worldasdfasdf%d", num);
    printf("%s\n", str);//hello w只能到w，w后还有'\0'

    return 0;
}</code></pre> 
<h3 id="%C2%A011.fread%2Ffwrite"> 11.fread/fwrite</h3> 
<h4 id="fread">fread</h4> 
<blockquote> 
 <p>函数原型：size_t fread(void *ptr, size_t size, size_t nmemb, FILE *stream);</p> 
 <p>头文件：#include &lt;stdio.h&gt;</p> 
 <p>功能：在文件中读取 nmemb 个 size 大小的项目到ptr指向的地址中</p> 
 <p></p> 
 <p>参数：ptr：用来保存读取内容的空间的首地址</p> 
 <p>           size：每个项目的大小</p> 
 <p>           nmemb：项目数</p> 
 <p>           stream：文件指针</p> 
 <p></p> 
 <p>返回值：成功 返回实际读取的项目数</p> 
 <p>              失败或者文件结束 小于项目数的数或者0</p> 
 <p>              feof(fp) 返回值为真 说明是文件结束了</p> 
 <p>              ferror(fp) 返回值为真 说明是发生错误了</p> 
</blockquote> 
<p><span style="color:#ff9900;"> 一般写的时候让size=1，返回值变成实际想获取的字节数</span></p> 
<p><span style="color:#0d0016;">例：</span></p> 
<pre><code class="language-cpp">    FILE *fp=fopen("test.c","r");
    char buff[128]={0};
    fread(buff,1,sizeof(buff),fp);
    printf("%s\n",buff);</code></pre> 
<p><img alt="" height="214" src="https://images2.imgbox.com/67/38/XyoobpU5_o.png" width="527"></p> 
<p></p> 
<h4 id="fwrite">fwrite</h4> 
<blockquote> 
 <p>函数原型：size_t fwrite(const void *ptr, size_t size, size_t nmemb, FILE *stream);</p> 
 <p>头文件：#include &lt;stdio.h&gt;</p> 
 <p>功能：向文件中写入 nmemb 个 size 大小的项目 数据来自ptr指向的地址</p> 
 <p></p> 
 <p>参数：ptr：要写入的数据的首地址</p> 
 <p>           size：每个项目的大小</p> 
 <p>           nmemb：项目数</p> 
 <p>           stream：文件指针</p> 
 <p></p> 
 <p>返回值：成功 返回实际写入的项目数</p> 
 <p>              失败 小于项目数的数</p> 
</blockquote> 
<p>例：</p> 
<p>不要写sizeoff(buff),这样写数据后面的'\0'也会被算进去，'\0'无法以字符串显示，会造成文件与我想要写入的不一样</p> 
<p><img alt="" height="90" src="https://images2.imgbox.com/e4/03/t3O9KWMl_o.png" width="195"></p> 
<p>size是多少 写入文件的内容就是多少，数据有几个字节 就写几个字节 </p> 
<pre><code class="language-cpp">FILE *fp=fopen("t.c","w");
    char buff[8]="hello";
    //fwrite(buff,1,sizeof(buff),fp);
    fwrite(buff,1,5,fp);
    int ret=fread(buff,1,sizeof(buff),fp);
    if(ret!=0){
        if(feof(fp)){
            fprintf(stderr, "end of file\n");
        }
    }
    printf("%s\n",buff);
    return 0;</code></pre> 
<p><img alt="" height="237" src="https://images2.imgbox.com/e8/eb/Ork4nXB4_o.png" width="760"></p> 
<p><strong> 文件读写实例：</strong></p> 
<p>向文件中写入指定字符串，并读取出来</p> 
<pre><code class="language-cpp">int main(int argc, char const *argv[])
{
    FILE *fp=fopen("t.txt","w");
    char buff[10]="hello";
    //fwrite(buff,1,sizeof(buff),fp);
    fwrite(buff,1,5,fp);
    //写完以后需要关闭文件，后面要以读的方式打开，否则会报错
    fclose(fp);
    FILE *fp2=fopen("t.txt","r");
    memset(buff,0,10);//buff里有东西，读的时候需清空
    int ret=fread(buff,1,sizeof(buff),fp2);
    if(ret&lt;sizeof(buff)){
        if(feof(fp2)){
            fprintf(stderr,"文件结束\n");
        }
        if(ferror(fp2)){
            fprintf(stderr,"文件出错\n");
            exit(-1);
        }
    }
    printf("buff = [%s]\n", buff);
    fclose(fp2);
    return 0;
}</code></pre> 
<p><img alt="" height="141" src="https://images2.imgbox.com/cb/dc/2vODDxn6_o.png" width="944"></p> 
<p><strong> 向文件中写入整数</strong></p> 
<pre><code class="language-cpp">int main(int argc, char const *argv[])
{
    FILE *fp=fopen("t.txt","w");
    int num=10;
    fwrite(&amp;num,1,4,fp);
    fclose(fp);
    FILE *fpr=fopen("t.txt","r");
    int readnum=0;
    fread(&amp;readnum,1,sizeof(num),fpr);
    fclose(fpr);
    printf("%d\n",readnum);
    return 0;
}</code></pre> 
<p><img alt="" height="284" src="https://images2.imgbox.com/0d/d7/2d5b9K9K_o.png" width="540"></p> 
<p> 可以读出来，但是文件里是以字符显示的，所以文件里的内容显示的是对应的ASCII码</p> 
<p>10在内存中以二进制的形式存储，因为是小端存储，所以是0x0A  0x00 0x00 0x00</p> 
<p>0x0A对应的ASCII码正好是回车键，所以文件里是空了一行，然后3个'\0'</p> 
<p><strong>向文件中写入结构体</strong></p> 
<pre><code class="language-cpp">int main(int argc, char const *argv[])
{
    FILE *fp=fopen("t.txt","w");
    struct student st={"zhangsan",20,80,"male"};
    fwrite(&amp;st,1,sizeof(st),fp);
    fclose(fp);
    struct student st2;
    FILE *fpr=fopen("t.txt","r");
    fread(&amp;st2,1,sizeof(st),fpr);
    printf("%s %d %d %s\n",st2.name,st2.age,st2.score,st2.sex);//按结构体读没问题
    printf("%d\n",sizeof(st));//52
    /*可以看到后面全是'\0'，以字符串的形式输出遇到'\0'就停止了，所以只能读到zhangsan
    char buff[128]={0};
    int ret=fread(buff,1,sizeof(st),fpr);
    printf("%s\n",buff);*/
    fclose(fpr);
    //写入字符串里，可以读出来
    /*sprintf(buff,"%s %d %d %s",st.name,st.age,st.score,st.sex);
    printf("%s\n",buff);*/
    return 0;
}</code></pre> 
<p>注：1.可以看到male已经是最后一个元素了，但后面仍有东西，因为涉及到结构体对齐的问题，所以后面还有<img alt="" height="119" src="https://images2.imgbox.com/07/e5/EC9O2L0I_o.png" width="978"></p> 
<p>2.为社么不能放到数组里输出</p> 
<p>练习：</p> 
<p>使用fread和fwrite实现文件的拷贝</p> 
<p>./a.out src_file dest_file</p> 
<p>feof(fp) ferror(fp)</p> 
<pre><code class="language-cpp">int main(int argc, char const *argv[])
{
    FILE *fp1=fopen(argv[1],"r");
    FILE *fp2=fopen(argv[2],"w");
    char buff[10]={0};
    int ret=0;
    while((ret=fread(buff,1,sizeof(buff),fp1))&gt;=sizeof(buff)){
            fwrite(buff,1,ret,fp2);
    }
    //这种方法需要在if判断一下，最后一次读的在缓冲区里，需要通过判断将缓冲区里的写入文件
    if(feof(fp1)){
        fwrite(buff,1,ret,fp2);
    }
    if(ferror(fp2)){
            fprintf(stderr,"文件出错\n");
            exit(-1);
    }
    /*while(!feof(fp1) &amp;&amp; !ferror(fp1)){
        ret = fread(buff, 1, sizeof(buff), fp1);
        fwrite(buff, 1, ret, fp2);
    }*/
    fclose(fp1);
    fclose(fp2);
    return 0;
}</code></pre> 
<p></p> 
<h3 id="12.fseek%2Frewind%2Fftell">12.fseek/rewind/ftell</h3> 
<h4 id="fseek">fseek</h4> 
<blockquote> 
 <p>函数原型：int fseek(FILE *stream, long offset, int whence);</p> 
 <p>功能：更改光标的位置</p> 
 <p></p> 
 <p>参数：stream：文件指针</p> 
 <p>           offset：偏移量</p> 
 <p>                        &gt;0 向后偏移</p> 
 <p>                        0 不偏移</p> 
 <p>                        &lt;0 向前偏移</p> 
 <p>          whence：相对位置</p> 
 <p>                          SEEK_SET 相对于文件开头</p> 
 <p>                          SEEK_CUR 相对于当前位置</p> 
 <p>                          SEEK_END 相对于文件结尾</p> 
 <p></p> 
 <p>返回值：成功 0</p> 
 <p>              失败 -1 重置错误码</p> 
 <p><img alt="" height="213" src="https://images2.imgbox.com/3a/91/LVo0NBaa_o.png" width="620"></p> 
 <p></p> 
</blockquote> 
<p>rewind</p> 
<blockquote> 
 <p>void rewind(FILE *stream);</p> 
 <p>功能：将光标重新定位到文件开头</p> 
 <p>参数：文件指针</p> 
 <p>用法等价于： fseek(fp, 0, SEEK_SET);</p> 
</blockquote> 
<p>ftell</p> 
<blockquote> 
 <p>long ftell(FILE *stream);</p> 
 <p>功能：返回文件光标距离文件开头的偏移量</p> 
 <p>参数：文件指针</p> 
 <p>返回值： 成功 当前的偏移量</p> 
 <p>               失败 -1 重置错误码</p> 
</blockquote> 
<p>fseek 和 rewind使用实例</p> 
<p>fseek对a方式的写光标修改无效</p> 
<p>// 如果文件是以a+的方式打开，<br> // 可以使用fseek修改读光标位置，但是对写光标位置无效，写总是在结尾</p> 
<pre><code class="language-cpp">#include &lt;head.h&gt;

struct Test{
    int id;
    char name[32];
    char sex;
};

int main(int argc,const char * argv[])
{
    FILE *fp = fopen("hello.txt", "w+");
    if(NULL == fp)
        ERRLOG("fopen error");
    struct Test t1 = {.id = 1001, .name = "zhangsan", .sex = 'w'};
    fwrite(&amp;t1, 1, sizeof(t1), fp);
    struct Test t2;
    memset(&amp;t2, 0, sizeof(t2));
    //如果写完数据后 不重置光标位置 直接读 是读不到的
    if(-1 == fseek(fp, 0, SEEK_SET))
        ERRLOG("fseek error");
    //rewind(fp); //这种写法 也可以将光标重置到文件开头
    fread(&amp;t2, 1, sizeof(t2), fp);
    printf("%d-%s-%c\n", t2.id, t2.name, t2.sex);

    //读取文件中间部分的内容
    fseek(fp, 4, SEEK_SET);
    fseek(fp, 32, SEEK_CUR);
    char read_sex = 0;
    fread(&amp;read_sex, 1, 1, fp);
    printf("read_sex = %c\n", read_sex);
    
    fseek(fp, -4, SEEK_END);
    read_sex = 0;
    fread(&amp;read_sex, 1, 1, fp);
    printf("read_sex = %c\n", read_sex);

    fclose(fp);

    return 0;
}</code></pre> 
<p> ftell使用实例</p> 
<p>可以用来求文件大小</p> 
<pre><code class="language-cpp"> int main(int argc,const char * argv[])
{
    FILE *fp=fopen("test.c","r");
    fseek(fp,0,SEEK_END);
    printf("%ld\n",ftell(fp));
    return 0;
}</code></pre> 
<p><img alt="" height="370" src="https://images2.imgbox.com/65/a8/rHDpeoEs_o.png" width="834"></p> 
<h3 id="%C2%A013.%E6%A0%87%E5%87%86IO%E6%93%8D%E4%BD%9C%E5%9B%BE%E7%89%87%E6%96%87%E4%BB%B6"> 13.标准IO操作图片文件</h3> 
<p>BMP格式图片头说明：</p> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/2c/62/LDECsOKA_o.png"></p> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/73/1f/D1i5wc9F_o.png"></p> 
<pre><code class="language-cpp">/*FILE *fp=fopen("test.c","r");
    fseek(fp,0,SEEK_END);
    printf("%ld\n",ftell(fp));*/

    FILE *fp=fopen("ddm.bmp","r+");
    int boffbits=0;
    int width=0;
    /*fseek(fp,10,SEEK_SET);
    fread(&amp;boffbits,1,4,fp);
    printf("%d\n",boffbits);//138

    fseek(fp,18,SEEK_SET);
    fread(&amp;width,1,4,fp);
    printf("%d\n",width);//1574*/
    fseek(fp,138,SEEK_SET);
    struct color c={0,0,0,0};//通过改变中成员的值，找到对应的颜色
    for(int i=0;i&lt;30;i++){
        for(int j;j&lt;1574;j++){
            fwrite(&amp;c,1,sizeof(c),fp);
        }
    }
    fclose(fp);</code></pre> 
<p>作业：</p> 
<p>给叮当猫的鼻子换个颜色。换成方的就行。鼻子坐标：</p> 
<p>左上角 "597 320"</p> 
<p>右下角 "695 420"</p> 
<p>（换成方的就行 不需要换成圆的）。</p> 
<pre><code class="language-cpp">//作业
    FILE *fp =fopen("ddm.bmp","r+");
    struct color c={255,255,0,0};
    fseek(fp,1574*320*4+597*4,SEEK_SET);
    for(int i=0;i&lt;100;i++){//100行
        for(int j=0;j&lt;100;j++){
            fwrite(&amp;c,1,sizeof(c),fp);//100列
        }
        fseek(fp,-100,SEEK_CUR);//还需将光标偏移回去
    }
    fclose(fp);</code></pre> 
<h2 id="%E4%B8%89%E3%80%81%E6%96%87%E4%BB%B6IO">三、文件IO</h2> 
<h3 id="1.%E6%A6%82%E5%BF%B5">1.概念</h3> 
<p>1.1什么是文件IO</p> 
<p>        文件IO就是系统调用，</p> 
<p>        无缓冲机制，效率低，可移植性差</p> 
<p>1.2什么是文件描述符</p> 
<p>        文件描述符是 open 函数打开文件时的返回值，叫fd，这个fd就代表打开的文件。</p> 
<p>        以后对文件的读写操作就是对该fd的操作。fd是一个非负整数，在一个进程中，</p> 
<p>        文件描述符的范围是[0,1023] ,使用 ulimit -a 可以查看， open files 后面的值就是</p> 
<p>        每一个运行起来的进程都会有三个默认打开的文件描述符，</p> 
<p>        分别是 0(stdin) 1(stdout) 2(stderr)，我们再打开文件，fd一般都是从3开始的</p> 
<p>        这个值可以修改 ulimit -n 2048</p> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/46/51/cHsD4Gro_o.png"></p> 
<table border="1" cellpadding="1" cellspacing="1" style="width:600px;"><tbody><tr><td>FILE指针</td><td>标准</td><td>文件描述符</td></tr><tr><td>stdin(stdin-&gt;filno)</td><td>标准输入</td><td>0</td></tr><tr><td>stdout(stdout-&gt;filno)</td><td>标准输出</td><td>1</td></tr><tr><td>stderr(stdinerror-&gt;filno)</td><td>标准出错</td><td>2</td></tr></tbody></table> 
<h3 id="1.%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C">2.文件操作</h3> 
<h3 id="1.1open">2.1open</h3> 
<blockquote> 
 <p>头文件：#include &lt;sys/types.h&gt;<br>               #include &lt;sys/stat.h&gt;<br>               #include &lt;fcntl.h&gt;</p> 
 <p>函数原型：int open(const char *pathname, int flags, mode_t mode);</p> 
 <p>功能：打开文件</p> 
 <p></p> 
 <p>参数：pathname：带路径的文件名</p> 
 <p>           flags：标志位</p> 
 <p>                        O_RDONLY 只读</p> 
 <p>                        O_WRONLY 只写</p> 
 <p>                        O_RDWR 读写</p> 
 <p>                        O_CREAT 如果文件不存在 会新建普通文件</p> 
 <p>                        O_APPEND 追加写5</p> 
 <p>                        O_EXCL 需要和O_CREAT结合使用 如果文件不存在会创建文件，如果文件                                           存在会报错,错误码：EEXIST</p> 
 <p>                        O_TRUNC 如果文件存在，会被清空</p> 
 <p>            mode：如果第二个参数有 O_CREAT 则必须指定 mode</p> 
 <p>                        如果第二个参数没有 O_CREAT 则不用指定 mode</p> 
 <p>                        mode 是文件的权限 使用 3位八进制来表示</p> 
 <p>                        例如：0666 0664 0444</p> 
 <p>                        注意：指定的mode不完全是新建文件的权限</p> 
 <p>                        还要考虑 umask umask一般为 0002</p> 
 <p>                        实际权限 = (mode &amp; ~umask)</p> 
 <p>                        也就是说 --》传参 0666</p> 
 <p>                        110110110 111111101 &amp; ----------- 110110100 --》</p> 
 <p>                        最终实际的权限是 0664 --》rw-rw-r--</p> 
 <p>             返回值：成功 返回文件描述符 返回的是当前进程中未被打开的编号最小的<br>                            失败 -1 重置错误码</p> 
</blockquote> 
<p></p> 
<table border="1" cellpadding="1" cellspacing="1" style="width:600px;"><tbody><tr><td>标准IO</td><td>文件IO</td><td>功能</td></tr><tr><td>r</td><td>O_RDONLY</td><td>以只读方式打开文件，如果文件不存在会报错</td></tr><tr><td>r+</td><td>O_RDWR</td><td>以读写的方式打开文件，如果文件不存在会报错</td></tr><tr><td>w</td><td>O_CREAT | O_WRONLY | O_TRUNC，0666</td><td>以只写的方式打开文件，如果文件不存在会创建文件，如果文件存在，会清空再写</td></tr><tr><td>w+</td><td>O_CREAT | O_RDWR | O_TRUNC，0666</td><td>以读写的方式打开文件，如果文件不存在会创建文件，如果文件存在，会清空再写</td></tr><tr><td>a</td><td>O_CREAT |O_WRONLY| O_APPEND，0666</td><td>以追加写的方式打开文件，如果不存在会新建文件</td></tr><tr><td>a+</td><td>O_CREAT | O_APPEND | O_RDWR ，0666</td><td>以读和追加写的方式打开文件，如果不村子会新建</td></tr></tbody></table> 
<p></p> 
<pre><code class="language-cpp">int main(int argc,const char * argv[])
{
    int fd;
    fd = open("hello.txt", O_WRONLY|O_CREAT|O_TRUNC, 0666);
    if(-1 == fd){
        ERRLOG("open error");
    }
    printf("fd = %d\n", fd);
    return 0;
}</code></pre> 
<pre><code class="language-cpp">int main(int argc,const char * argv[])
{
    int fd;
    //如果文件不存在 就新建 如果存在 就报错
    fd = open("hello.txt", O_WRONLY|O_CREAT|O_EXCL, 0666);
    if(-1 == fd){
        if(EEXIST == errno){
            fd = open("hello.txt", O_WRONLY);
            printf("1111\n");
        }else{
            ERRLOG("open error");
        }
    }
    printf("fd = %d\n", fd);
    printf("stdin_no = %d\n", stdin-&gt;_fileno);//0
    printf("stdout_no = %d\n", stdout-&gt;_fileno);//1
    printf("stderr_no = %d\n", stderr-&gt;_fileno);//2

    return 0;
}</code></pre> 
<h3 id="1.2close">2.2close</h3> 
<blockquote> 
 <p>#include &lt;unistd.h&gt;</p> 
 <p>函数原型：int close(int fd);</p> 
 <p>功能：关闭open打开的文件</p> 
 <p></p> 
 <p>参数：fd:文件描述符</p> 
 <p></p> 
 <p>返回值：成功 0</p> 
 <p>               失败 -1，重置错误码</p> 
</blockquote> 
<pre><code class="language-cpp">int main(int argc,const char * argv[])
{
    int fd = 0;
    if(-1 == (fd = open("hello.txt", O_WRONLY|O_CREAT, 0666)))
        ERRLOG("open error");
    printf("fd = %d\n", fd);//3
    printf("stdin_no = %d\n", stdin-&gt;_fileno);//0
    printf("stdout_no = %d\n", stdout-&gt;_fileno);//1
    printf("stderr_no = %d\n", stderr-&gt;_fileno);//2
    if(-1 == close(fd))
        ERRLOG("close error");
    printf("111\n");
    //close(1);//如果把 1 号文件描述符关了 那么就没法向终端输出内容了
    printf("222\n");
    close(0);
    close(2);
    if(-1 == (fd = open("hello.txt", O_WRONLY|O_CREAT, 0666)))
        ERRLOG("open error");
    printf("fd = %d\n", fd);//0

    return 0;
}</code></pre> 
<p> 文件描述符的重定向</p> 
<pre><code class="language-cpp">#include &lt;head.h&gt;

int main(int argc,const char * argv[])
{
    // stdout-&gt;_fileno=1--&gt;终端
    printf("hello open/read/write/close...\n"); //会在终端显示
    close(1); //关闭标准输出
    printf("%s:%s:%d\n",__FILE__,__func__,__LINE__); //不会在终端显示
    int fd;
    if((fd = open("./hello.txt",O_WRONLY|O_TRUNC|O_CREAT,0666))==-1)
        PRINT_ERR("open error");
    // 打开文件得到的fd=1，最小未使用原则

     // stdout-&gt;_fileno=1--&gt;文件
    printf("fd = %d\n",fd);  //文件描述符重定向
    return 0;
}</code></pre> 
<h3 id="1.3read">2.3read</h3> 
<blockquote> 
 <p>#include &lt;unistd.h&gt;</p> 
 <p>函数原型：ssize_t read(int fd, void *buf, size_t count);</p> 
 <p>功能：从文件读取内容到buf中</p> 
 <p></p> 
 <p>参数：fd:文件描述符</p> 
 <p>           buf：存放读取内容的缓冲区首地址</p> 
 <p>           count:想要读取的个数</p> 
 <p></p> 
 <p>返回值：成功 读取的字节数(0表示文件结束)，且光标移动到字节数位置</p> 
 <p>               失败 -1，重置错误码</p> 
</blockquote> 
<h3 id="1.4write">2.4write</h3> 
<blockquote> 
 <p>#include &lt;unistd.h&gt;</p> 
 <p>函数原型：ssize_t  write(int fd, const void *buf, size_t count);</p> 
 <p>功能：将buf数据写到文件中</p> 
 <p></p> 
 <p>参数：fd:文件描述符</p> 
 <p>           buf：存放写入内容的缓冲区首地址</p> 
 <p>           count:想要写入的个数</p> 
 <p></p> 
 <p>返回值：成功 写入的字节数(0表示没有写入内容)</p> 
 <p>                      失败 -1，重置错误码</p> 
</blockquote> 
<pre><code class="language-cpp">int main(int argc,const char * argv[])
{
    int fd = 0;
    int ret = 0;
    if(-1 == (fd = open("hello.txt", O_RDWR|O_CREAT|O_TRUNC, 0666)))
        ERRLOG("open error");
    //写入字符串
    char buff[32] = "hello world";
    if(-1 == write(fd, buff, strlen(buff)))//字符串可以使用 strlen 其他内容最好自己控制大小
        ERRLOG("write error");
    memset(buff, 0, 32);
    close(fd);//重新将光标定位到文件开头
    if(-1 == (fd = open("hello.txt", O_RDONLY)))
        ERRLOG("open error");
    //文件中只有11个字节 第一次想读32个字节 但是实际只读到11个字节
    if(-1 == (ret = read(fd, buff, sizeof(buff))))
        ERRLOG("read error");
    printf("ret = %d  buff = [%s]\n", ret, buff);//11 hello world
    //第二次再读的时候 文件中已经没有内容了 read会返回 0
    memset(buff, 0, 32);
    if(-1 == (ret = read(fd, buff, sizeof(buff))))
        ERRLOG("read error");
    printf("ret = %d  buff = [%s]\n", ret, buff);//11 hello world
    close(fd);

    if(-1 == (fd = open("hello.txt", O_RDWR|O_CREAT|O_TRUNC, 0666)))
        ERRLOG("open error");
    //写入整数
    int num = 1314;
    if(-1 == write(fd, &amp;num, 4))
        ERRLOG("write error");
    close(fd);//重新将光标定位到文件开头
    if(-1 == (fd = open("hello.txt", O_RDONLY)))
        ERRLOG("open error");
    int ret_num = 0;
    if(-1 == (ret = read(fd, &amp;ret_num, 4)))
        ERRLOG("read error");
    printf("ret = %d  ret_num = %d\n", ret, ret_num);//4 1314
    close(fd);
    return 0;
}</code></pre> 
<p>思考：</p> 
<p>hello.txt里写的是1234 ，num是多少？</p> 
<p><img alt="" height="301" src="https://images2.imgbox.com/a7/43/A0Fuptid_o.png" width="520"></p> 
<p>答案：</p> 
<p><img alt="" height="167" src="https://images2.imgbox.com/b3/3e/pOucXo2N_o.png" width="396"></p> 
<p> 数字在文件里也是以字符串形式存储的，那“1234”在计算中是以ASCII码存储的，又是小端存储，数据低位在地址地位，就是“4321” 00110100    00110011    00110010     00110001</p> 
<p>练习：</p> 
<p>使用read/write实现文件的拷贝。</p> 
<p>./a.out src_file dest_file</p> 
<pre><code class="language-cpp">    int fd1=open(argv[1],O_RDONLY);
    if(fd1==-1){
        perror("open error");
    }
    int fd2=open(argv[2],O_CREAT|O_WRONLY|O_TRUNC,0664);
    if(fd2==-1){
        perror("open error");
    }
    int ret=0;
    char buff[32]={0};
    //while(0&lt;(ret=read(fd1,buff,32))){
    while(ret=read(fd1,buff,32)){
        write(fd2,buff,ret);
    }
    close(fd1);
    close(fd2);
</code></pre> 
<h3 id="1.5lseek">2.5lseek</h3> 
<blockquote> 
 <p>#include &lt;sys/types.h&gt;</p> 
 <p>#include &lt;unistd.h&gt;</p> 
 <p>函数原型：off_t lseek(int fd, off_t offset, int whence);</p> 
 <p>功能：修改光标的位置</p> 
 <p></p> 
 <p>参数：fd：文件描述符</p> 
 <p>           offset：偏移量</p> 
 <p>                        &gt;0 向后偏移</p> 
 <p>                        0 不偏移</p> 
 <p>                        &lt;0 向前偏移</p> 
 <p>           whence：相对位置</p> 
 <p>                        SEEK_SET 文件开头</p> 
 <p>                        SEEK_CUR 当前位置</p> 
 <p>                        SEEK_END 文件结尾</p> 
 <p></p> 
 <p>返回值：成功 返回当前光标相对于文件开头的偏移量</p> 
 <p>               失败 -1，重置错误码</p> 
</blockquote> 
<p>例：</p> 
<pre><code class="language-cpp">int main(int argc,const char * argv[])
{
    int fd = open("hello.txt", O_WRONLY);
    if(-1 == fd)
        ERRLOG("open error");
    int ret = lseek(fd, 2, SEEK_SET);
    printf("ret = %d\n", ret);//2
    write(fd, "H", 1);
    //相当与将文件扩大100字节 但是如果没有写操作不会扩大
    ret = lseek(fd, 100, SEEK_END);
    printf("ret = %d\n", ret);//105
    write(fd, "Q", 1);

    return 0;
}</code></pre> 
<h3 id="2.%E7%9B%AE%E5%BD%95%E6%93%8D%E4%BD%9C">2.目录操作</h3> 
<h3 id="2.1stat">2.1stat</h3> 
<blockquote> 
 <p>头文件：#include &lt;sys/types.h&gt;</p> 
 <p>               #include &lt;sys/stat.h&gt;</p> 
 <p>               #include &lt;unistd.h&gt;</p> 
 <p>int stat(const char *pathname, struct stat *statbuf);</p> 
 <p>功能：将文件的属性信息放到保存文件属性的结构体的首地址里</p> 
 <p></p> 
 <p>参数：带路径的文件名</p> 
 <p>           自己创建的用来存放文件信息的struct  stat*类型的指针</p> 
 <p>                     struct stat {<!-- --><br>                                dev_t     st_dev;         /*文件所在磁盘设备号*/<br>                                ino_t     st_ino;         /* Inode number */<br>                                mode_t    st_mode;        /* File type and mode */</p> 
 <p>                                        文件权限 ：st_mode  &amp; 0777</p> 
 <p>                                        文件类型：</p> 
 <p>                                        The following mask values are defined for the file type:</p> 
 <p>                                                   S_IFMT        0170000   bit mask for the file type bit field</p> 
 <p></p> 
 <p>                                                   S_IFSOCK   0140000   socket<br>                                                    S_IFLNK       0120000   symbolic link<br>                                                    S_IFREG      0100000   regular file<br>                                                    S_IFBLK       0060000   block device<br>                                                    S_IFDIR        0040000   directory<br>                                                    S_IFCHR       0020000   character device<br>                                                    S_IFIFO         0010000   FIFO</p> 
 <p>                                                        <br>                                nlink_t   st_nlink;       /* Number of hard links */<br>                                uid_t     st_uid;         /* User ID of owner */<br>                                 gid_t     st_gid;         /* Group ID of owner */<br>                                dev_t     st_rdev;        /* 文件的设备号()字符或块 */<br>                                off_t     st_size;        /* Total size, in bytes */<br>                                blksize_t st_blksize;     /* Block size for filesystem I/O */<br>                                blkcnt_t  st_blocks;      /* Number of 512B blocks allocated */  </p> 
 <p>                               struct timespec st_atim;  /* 最后一次被访问的时间 */<br>                                struct timespec st_mtim;  /* Time of last modification */<br>                                struct timespec st_ctim;  /* 最后一次改变状态的时间*/</p> 
 <p>                           #define st_atime st_atim.tv_sec      /* Backward compatibility */<br>                            #define st_mtime st_mtim.tv_sec<br>                            #define st_ctime st_ctim.tv_sec<br>                     };</p> 
 <p>   </p> 
 <p> 自己用if判断</p> 
 <p>if((st_mode &amp; S_IFMT) == S_IFREG){<!-- --></p> 
 <p>        普通文件 }</p> 
 <p></p> 
 <p>或者用宏函数都行</p> 
 <p>if(S_ISREG(st_mode)){<!-- --></p> 
 <p>         普通文件 }</p> 
 <p>           struct stat  *stabuf=NULL;</p> 
 <p></p> 
 <p>返回值：成功：0</p> 
 <p>              失败：-1，重置错误码</p> 
 <p>注意： stat不能获取软连接文件的信息，如果想获取，可以使用lstat</p> 
</blockquote> 
<blockquote> 
 <p><strong> struct stat结构体（man 2 stat）</strong></p> 
 <p><img alt="" height="634" src="https://images2.imgbox.com/33/d5/o80OvkkM_o.png" width="1024"></p> 
</blockquote> 
<blockquote> 
 <p><strong>文件的权限(man 7 inode)</strong></p> 
 <p><img alt="" height="230" src="https://images2.imgbox.com/76/e1/jRTOP59B_o.png" width="1084"></p> 
 <p> st_mode &amp; 0777，与出的结果就是三位八进制的数</p> 
</blockquote> 
<blockquote> 
 <p> 文件类型</p> 
 <p><img alt="" height="660" src="https://images2.imgbox.com/b9/55/9IIoBm4i_o.png" width="599"></p> 
</blockquote> 
<p> 例：</p> 
<pre><code class="language-cpp">
int main(int argc, char const *argv[])
{if(2 != argc){
        printf("Usage : %s pathname\n", argv[0]);
        exit(-1);
    }
    //struct stat *p=NULL;不需要指针
    struct stat p;//创建存放文件信息的结构体
    //stat(argv[1],&amp;p);//传参的时候传结构体的地址
    if(stat(argv[1],&amp;p)==-1){
        perror("stat error");
    }
    printf("%ld\n",p.st_dev);
    printf("%ld\n",p.st_ino);
    if((p.st_mode &amp; __S_IFMT)){
        printf("普通文件\n");
    }
    if(S_ISDIR(p.st_mode)){
        printf("目录文件\n");
    }
    printf("%d\n",p.st_mode);
    printf("%d\n",(p.st_mode &amp; 0777));
    printf("%d\n",(p.st_nlink &amp; 0777));
    printf("st_uid = %d\n", p.st_uid);
    printf("st_gid = %d\n", p.st_gid);
    printf("st_rdev = %ld\n", p.st_rdev);
    printf("st_size = %ld\n", p.st_size);
    printf("st_blksize = %ld\n", p.st_blksize);
    printf("st_blocks = %ld\n", p.st_blocks);
    struct tm *t=localtime(&amp;(p.st_atime));
     printf("%04d-%02d-%02d %02d:%02d:%02d\n", 
            t-&gt;tm_year+1900, t-&gt;tm_mon+1, t-&gt;tm_mday,
            t-&gt;tm_hour, t-&gt;tm_min, t-&gt;tm_sec);
    return 0;
}</code></pre> 
<h3><img alt="" height="162" src="https://images2.imgbox.com/53/64/W56tSPyo_o.png" width="569"></h3> 
<p></p> 
<h3 id="2.2getpwuid%E5%92%8Cgetgrgid">2.2getpwuid和getgrgid</h3> 
<blockquote> 
 <p><strong>getpwuid</strong></p> 
 <p>头文件：#include &lt;sys/types.h&gt;</p> 
 <p>               #include &lt;pwd.h&gt;</p> 
 <p>struct passwd *getpwuid(uid_t uid);//struct passwd *getpwuid(p.st_uid);</p> 
 <p>                                                        //就是上一个例子里的p.st_uid</p> 
 <p>功能：根据uid获取用户的信息</p> 
 <p></p> 
 <p>参数：uid号</p> 
 <p></p> 
 <p>返回值：成功：用户信息的结构体指针</p> 
 <p><img alt="" height="311" src="https://images2.imgbox.com/bc/fa/kGp6K7RI_o.png" width="743"></p> 
 <p></p> 
 <p>              失败：NULL   重置错误码</p> 
</blockquote> 
<blockquote> 
 <p><strong>getgrgid</strong></p> 
 <p>头文件：#include &lt;sys/types.h&gt;</p> 
 <p>               #include &lt;grp.h&gt;</p> 
 <p>struct group *getgrgid(gid_t gid);</p> 
 <p>功能：获取组信息</p> 
 <p></p> 
 <p>参数：gid</p> 
 <p></p> 
 <p>返回值：成功：组信息结构体指针</p> 
 <p><img alt="" height="265" src="https://images2.imgbox.com/44/58/w4cupFEp_o.png" width="965"></p> 
 <p></p> 
 <p>              失败：MULL</p> 
</blockquote> 
<p>例</p> 
<pre><code class="language-cpp">int main(int argc, char const *argv[])
{
    if(2 != argc){
        printf("Usage : %s pathname\n", argv[0]);
        exit(-1);
    }
    struct stat p;
    if((stat(argv[1],&amp;p))==-1){
        perror("stat error");
    }
    //虽然getpwuid的参数有了是p.st_uid，但还是需要创建struct passwd结构体来接getpwuid(p.st_uid)的值
    //注意，这两个函数的返回值不是常数，是指针类型，所以要定义指针类型的变量来接
    struct passwd *puser;
    if((puser=getpwuid(p.st_uid))==NULL){
        perror("getpwuid error");
    }  
    //printf("%s ",(&amp;(p.st_uid))-&gt;pw_name);
    printf("%s %s\n",puser-&gt;pw_name,puser-&gt;pw_passwd);
    struct group *g;
    if((g=getgrgid(p.st_gid))==NULL){
        perror("getgrgid error");
    }
    printf("%s %s\n",g-&gt;gr_name,g-&gt;gr_passwd);

    return 0;
}</code></pre> 
<p><img alt="" height="102" src="https://images2.imgbox.com/bb/0d/Ke9g71Ux_o.png" width="546"></p> 
<p></p> 
<p> 练习：</p> 
<p>使用 stat 配合 getpwsuid 和 getgrgid 实现 ls -l 查看单个文件详细信息的功能：</p> 
<p>要求 ./a.out filename 显示如下信息</p> 
<p>-rw-rw-r-- 1 yangfs yangfs 1433 4月 10 10:37 filename</p> 
<pre><code class="language-cpp">#include &lt;stdio.h&gt;
#include &lt;unistd.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;
#include &lt;errno.h&gt;
#include &lt;time.h&gt;
#include &lt;sys/types.h&gt;
#include &lt;sys/stat.h&gt;
#include &lt;fcntl.h&gt;
#include &lt;pwd.h&gt;
#include &lt;grp.h&gt;
#include &lt;dirent.h&gt;

#define U_R 0400
#define U_W 0200
#define U_X 0100
#define G_R 0040
#define G_W 0020
#define G_X 0010
#define O_R 0004
#define O_W 0002
#define O_X 0001
char FILEtype(struct stat st){
    if(S_ISREG(st.st_mode)){
        return '-';
    }else if(S_ISDIR(st.st_mode)){
        return 'd';
    }else if(S_ISCHR(st.st_mode)){
        return 'c';
    }else if(S_ISBLK(st.st_mode)){
        return 'b';
    }else if(S_ISFIFO(st.st_mode)){
        return 'p';
    }else if(S_ISLNK(st.st_mode)){
        return 'l';
    }else if(S_ISSOCK(st.st_mode)){
        return 's';
    }
}

int main(int argc, char const *argv[])
{
        if(argc!=2){
        printf("Usage :%s &lt;filename&gt;\n",argv[0]);
        exit(-1);
    }
    struct stat st;
    if(-1==stat(argv[1],&amp;st)){
        perror("stat error");
    }
    char type='-';
    char u_r='-';
    char u_w='-';
    char u_x='-';
    char g_r='-';
    char g_w='-';
    char g_x='-';
    char o_r='-';
    char o_w='-';
    char o_x='-';
    //文件类型
    if(S_ISREG(st.st_mode)){
        type='-';
    }
    if(S_ISCHR(st.st_mode)){
        type='c';
    }
    if(S_ISFIFO(st.st_mode)){
        type='p';
    }
    if(S_ISBLK(st.st_mode)){
        type='b';
    } 
    if(S_ISDIR(st.st_mode)){
        type='d';
    }
    if(S_ISSOCK(st.st_mode)){
        type='s';
    }   
    if(S_ISLNK(st.st_mode)){
        type='l';
    }   
    //文件权限 st_mode &amp; 0777
    if(st.st_mode &amp; U_R){
        u_r='r';
    }
    if((st.st_mode &amp; U_W) != 0){
        u_w='w';
    }
    if((st.st_mode &amp; U_W) != 0){
        u_x='x';
    }    
    if(st.st_mode &amp; G_R){
        g_r='r';
    }
    if(st.st_mode &amp; G_W){
        g_w='w';
    }
    if(st.st_mode &amp; G_X){
        g_x='x';
    }
    if(st.st_mode &amp; O_R){
        o_r='r';
    }
    if(st.st_mode &amp; O_W){
        o_w='w';
    }
    if(st.st_mode &amp; O_X){
        o_x='x';
    }      
    struct passwd *pw=getpwuid(st.st_uid);
    struct group *g=getgrgid(st.st_gid);
    struct tm *t=localtime(&amp;(st.st_atime));
    printf("%c%c%c%c%c%c%c%c%c%c %ld %s %s %6ld %02d月 %2d %02d:%02d %s\n",type,u_r,u_w,u_x,g_r,g_w,g_x,o_r,o_w,o_x,
    st.st_nlink,g-&gt;gr_name,pw-&gt;pw_name,
    st.st_size,t-&gt;tm_mon+1,t-&gt;tm_mday+1,t-&gt;tm_hour,t-&gt;tm_min,argv[1]);
    return 0;
}</code></pre> 
<h3 id="2.2opendir">2.2opendir</h3> 
<blockquote> 
 <p>头文件：#include &lt;sys/types.h&gt;</p> 
 <p>              #include &lt;dirent.h&gt;</p> 
 <p>DIR *opendir(const char *name);</p> 
 <p>功能：打开一个目录文件</p> 
 <p></p> 
 <p>参数：目录文件的路径和名字</p> 
 <p></p> 
 <p>返回值：成功：目录流指针 DIR *</p> 
 <p>              失败：NULL  重置错误码</p> 
</blockquote> 
<h3 id="2.3readdir">2.3readdir</h3> 
<blockquote> 
 <p>头文件：#include &lt;dirent.h&gt;</p> 
 <p>struct dirent *readdir(DIR *dirp);</p> 
 <p>功能：读取目录文件下的内容</p> 
 <p></p> 
 <p>参数：目录指针</p> 
 <p></p> 
 <p>返回值：成功：目录信息结构体指针</p> 
 <p><img alt="" height="228" src="https://images2.imgbox.com/6e/5f/hyGUu7JD_o.png" width="847"></p> 
 <p>struct dirent</p> 
 <p>  {<!-- --></p> 
 <p>            ino_t                             d_ino;/* 读到的文件的inode号 */</p> 
 <p>            off_t                              d_off;/* 不是给应用程序用的 */</p> 
 <p>            unsigned short int         d_reclen;/* 这个结构体的大小 不是文件的大小 */</p> 
 <p>            unsigned char               d_type;/* 文件的类型 */</p> 
 <p>                        DT_BLK This is a block device. 块设备</p> 
 <p>                        DT_CHR This is a character device.字符设备文件</p> 
 <p>                        DT_DIR This is a directory.目录文件</p> 
 <p>                        DT_FIFO This is a named pipe (FIFO).管道文件</p> 
 <p>                        DT_LNK This is a symbolic link.链接文件</p> 
 <p>                        DT_REG This is a regular file.普通文件</p> 
 <p>                        DT_SOCK This is a UNIX domain socket.套接字文件</p> 
 <p>            char                               d_name[256];   /*文件名*/</p> 
 <p>  };</p> 
 <p>              失败：NULL  重置错误码</p> 
 <p>文件类型：</p> 
 <p><img alt="" height="576" src="https://images2.imgbox.com/c3/36/YmULhBbL_o.png" width="800"></p> 
 <p></p> 
</blockquote> 
<h3 id="2.4closedir">2.4closedir</h3> 
<blockquote> 
 <p>头文件：</p> 
 <p>              #include &lt;sys/types.h&gt;</p> 
 <p>              #include &lt;dirent.h&gt;</p> 
 <p>int closedir(DIR *dirp);</p> 
 <p>功能：关闭opendir打开的目录文件</p> 
 <p></p> 
 <p>参数：目录流指针 DIR *</p> 
 <p></p> 
 <p>返回值：成功：0</p> 
 <p>              失败：-1，重置错误码</p> 
</blockquote> 
<p>例：</p> 
<pre><code class="language-cpp">int main(int argc, char const *argv[])
{
    if(argc!=2){
        printf("Usage : %s pathname\n", argv[0]);
        exit(-1);
    }
    DIR *dir=opendir("argv[1]");
    //if (!opendir("argv[1]")){
    if (!dir){
        perror("opendir error");
    }
    struct dirent *p=readdir(dir);
    /*printf("filename = %s ", p-&gt;d_name);
    printf("%ld",p-&gt;d_ino);  
    printf("%d",(p-&gt;d_type &amp; DT_REG));*/
    while(NULL !=p){
        printf("filename = %s ", p-&gt;d_name);
        printf(" inode = %ld ", p-&gt;d_ino);
        switch(p-&gt;d_type){
            case DT_BLK:
                printf(" 块设备文件 ");
                break;
            case DT_CHR:
                printf(" 字符设备文件 ");
                break;
            case DT_DIR:
                printf(" 目录文件 ");
                break;
            case DT_FIFO:
                printf(" 管道文件 ");
                break;
            case DT_LNK:
                printf(" 链接文件 ");
                break;
            case DT_REG:
                printf(" 普通文件 ");
                break;
            case DT_SOCK:
                printf("套接字文件");
                break;
        }
        printf("\n");
    }
    return 0;
}</code></pre> 
<blockquote> 
 <p>VScode里有警告，但编译运行没问题，以编译器为准</p> 
 <p><img alt="" height="638" src="https://images2.imgbox.com/bb/f4/FddJADw2_o.png" width="1200"></p> 
 <p></p> 
 <p></p> 
</blockquote> 
<p>练习：</p> 
<p>结合目录操作：输入一个目录名和一个文件名，判断该目录下是否存在该文件</p> 
<p>./a.out dir_name file_name</p> 
<pre><code class="language-cpp">    if(argc!=3){
        printf("Usage :%s dirname filename\n",argv[0]);
    }
    DIR *dir=NULL;
    if(NULL==(dir=opendir(argv[1]))){
        perror("opendir error");
    }
    struct dirent *d;
    while(NULL!=(d=readdir(dir))){
        if(!strcmp(d-&gt;d_name,argv[2])){
            printf("文件存在\n");
            //break;这里不用break，用return 0
            return 0;
        }
    }
    printf("文件不存在\n");
    closedir(dir);</code></pre> 
<blockquote> 
 <p>用return 0而不是break，避免以下问题</p> 
 <p><img alt="" height="85" src="https://images2.imgbox.com/d3/a9/GvSdpnN5_o.png" width="500"></p> 
</blockquote> 
<p>作业：实现 ls -l 功能;</p> 
<pre><code class="language-cpp">#include &lt;stdio.h&gt;
#include &lt;unistd.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;
#include &lt;errno.h&gt;
#include &lt;time.h&gt;
#include &lt;sys/types.h&gt;
#include &lt;sys/stat.h&gt;
#include &lt;fcntl.h&gt;
#include &lt;pwd.h&gt;
#include &lt;grp.h&gt;
#include &lt;dirent.h&gt;

#define U_R 0400
#define U_W 0200
#define U_X 0100
#define G_R 0040
#define G_W 0020
#define G_X 0010
#define O_R 0004
#define O_W 0002
#define O_X 0001
char FILEtype(struct stat st){
    if(S_ISREG(st.st_mode)){
        return '-';
    }else if(S_ISDIR(st.st_mode)){
        return 'd';
    }else if(S_ISCHR(st.st_mode)){
        return 'c';
    }else if(S_ISBLK(st.st_mode)){
        return 'b';
    }else if(S_ISFIFO(st.st_mode)){
        return 'p';
    }else if(S_ISLNK(st.st_mode)){
        return 'l';
    }else if(S_ISSOCK(st.st_mode)){
        return 's';
    }
}

int main(int argc, char const *argv[])
{
    if(argc !=2){
        printf("Usage : %s pathname\n", argv[0]);
        exit(-1);
    }
    DIR *dir=opendir(argv[1]);
    if (NULL==dir){
        perror("opendir error");
    }
    struct dirent *p_dir=NULL;
    struct stat st;
    char c[256]={0};
    char file_type='-';
    char u_r='-';
    char u_w='-';
    char u_x='-';
    char g_r='-';
    char g_w='-';
    char g_x='-';
    char o_r='-';
    char o_w='-';
    char o_x='-';
    struct passwd *puser=NULL;
    struct group *g=NULL;
    struct tm *t=NULL;
    char buff[256]={0};
    char a[]=".";
    while((p_dir=readdir(dir))!=NULL){
        //stat(buff,&amp;st);
        snprintf(buff,strlen(argv[1])+strlen(p_dir-&gt;d_name)+2,"%s/%s",argv[1],p_dir-&gt;d_name);
        stat(buff,&amp;st);
        file_type=FILEtype(st);
        if((st.st_mode &amp; U_R)!=0){
        u_r='r';
        }
        if((st.st_mode &amp; U_W) != 0)
        u_w = 'w';
        if((st.st_mode &amp; U_X) != 0)
            u_x = 'x';
        if((st.st_mode &amp; G_R) != 0)
            g_r = 'r';
        if((st.st_mode &amp; G_W) != 0)
            g_w = 'w';
        if((st.st_mode &amp; G_X) != 0)
            g_x = 'x';
        if((st.st_mode &amp; O_R) != 0)
            o_r = 'r';
        if((st.st_mode &amp; O_W) != 0)
            o_w = 'w';
        if((st.st_mode &amp; O_X) != 0)
            o_x = 'x';
        puser=getpwuid(st.st_uid);
        g=getgrgid(st.st_gid);
        t=localtime(&amp;(st.st_atime));
        
        if((strncmp(p_dir-&gt;d_name,a,1))==0){
            continue;
        }else{
            printf("%c%c%c%c%c%c%c%c%c%c %ld %s %s %6ld %d月  %02d %02d:%02d %s\n",
        file_type,u_r,u_w,u_x,g_r,g_w,g_x,o_r,o_w,o_x,st.st_nlink,
        puser-&gt;pw_name,g-&gt;gr_name,st.st_size,t-&gt;tm_mon+1,t-&gt;tm_mday,
        t-&gt;tm_hour,t-&gt;tm_min,p_dir-&gt;d_name);
        }

    }
    closedir(dir);
    return 0;
}</code></pre> 
<h2 id="%E5%9B%9B%E3%80%81%E5%BA%93%E7%9A%84%E5%88%B6%E4%BD%9C">四、库的制作</h2> 
<h3>1.概念</h3> 
<p>库是一个二进制文件，是将xx.c 文件编译生成二进制的文件，库分为 静态库 和 动态库</p> 
<p>windows：</p> 
<p>                 静态库 xxx.lib</p> 
<p>                 动态库 xxx.dll</p> 
<p>linux:</p> 
<p>        静态库 libxxx.a</p> 
<p>        动态库 libxxx.so</p> 
<h3 id="2.%E9%9D%99%E6%80%81%E5%BA%93">2.静态库</h3> 
<p>静态库是 lib库名.a 格式的文件，如果在编译的时候使用了静态库</p> 
<p>会将静态库中的函数对应的机器指令编译到可执行程序中，可执行程序的体积相对来说会较大</p> 
<p>执行效率相对较高。静态库的内容更新后，需要重新编译生成新的可执行文件，</p> 
<p>更新操做相对麻烦。</p> 
<h4 id="2.1%E5%88%B6%E4%BD%9C%E9%9D%99%E6%80%81%E5%BA%93">2.1制作静态库</h4> 
<p>        <span style="background-color:#ffd900;">gcc -c xx1.c -o xx1.o</span> //只编译 不链接</p> 
<p>        <span style="background-color:#ffd900;">gcc -c xx2.c -o xx2.o</span> //只编译 不链接</p> 
<p>        <span style="background-color:#ffd900;">ar -cr libhqyj.a xx1.o xx2.o</span> //ar是制作静态库的命令 hqyj是库名前缀lib和后缀.a 都是格式要求</p> 
<h4 id="2.2%E9%9D%99%E6%80%81%E5%BA%93%E7%9A%84%E4%BD%BF%E7%94%A8">2.2静态库的使用</h4> 
<blockquote> 
 <p>构建场景：</p> 
 <p>t.h</p> 
 <pre><code class="language-cpp">#ifndef __HQYJ_H__
#define __HQYJ_H__
int my_add(int, int);
#endif</code></pre> 
 <p>t.c</p> 
 <pre><code class="language-cpp">int my_add(int x, int y){
    return x+y;
}</code></pre> 
 <p>main.c</p> 
 <pre><code class="language-cpp">#include &lt;stdio.h&gt;
#include "hqyj.h"

int main(int argc, const char *argv[])
{
    int a = 10;
    int b = 20;
    printf("%d\n", my_add(a, b));//30
    return 0;
}</code></pre> 
 <p>直接编译不认识，需要指定头文件的路径、库的路径和库</p> 
 <p><img alt="" height="337" src="https://images2.imgbox.com/be/ce/K1dXTEPe_o.png" width="838"></p> 
 <p></p> 
 <p> 可以利用tree查看当前目录的文件情况，如果没有tree，sudo apt-get install tree安装一下</p> 
 <p><img alt="" height="394" src="https://images2.imgbox.com/a1/66/RzGgmtEH_o.png" width="560"></p> 
 <p></p> 
</blockquote> 
<p></p> 
<h3 id="%C2%A03.%E5%8A%A8%E6%80%81%E5%BA%93"> 3.动态库</h3> 
<p>静态库是以 lib库名.so 格式的文件，如果在编译的时候使用了动态库</p> 
<p>不会将动态库中的函数对应的机器指令编译到可执行程序中，</p> 
<p>只是将库中的函数符号表放在了可执行文件中，所以可执行程序的体积相对来说会较小，</p> 
<p>执行效率相对较低，</p> 
<p>因为每次执行到调用库函数的时候都需要去对应的库里面查找对应的机器指令。</p> 
<p>动态库的内容更新后，不需要重新编译生成新的可执行文件，更新操做相对简单。</p> 
<h4 id="3.1%E5%88%B6%E4%BD%9C%E5%8A%A8%E6%80%81%E5%BA%93">3.1制作动态库</h4> 
<p><span style="background-color:#ffd900;">gcc -c -fPIC xx.c -o xx.o</span> 将.c只编译不链接生成 .o f小写 PIC大写 -fPIC忽略相对位置</p> 
<p><span style="background-color:#ffd900;">gcc -shared xx.o -o libhqyj.so</span> 将.o编译生成动态库 hqyj是库名</p> 
<p>或者</p> 
<p><span style="background-color:#ffd900;">gcc -fPIC -shared xx.c -o libhqyj.so</span> 直接将 .c 编译生成动态库</p> 
<h4 id="3.2%E5%8A%A8%E6%80%81%E5%BA%93%E7%9A%84%E4%BD%BF%E7%94%A8">3.2动态库的使用</h4> 
<blockquote> 
 <p>-I 指定头文件的路径</p> 
 <p>-L 指定库文件的路径</p> 
 <p>-l (小写的l)指定要连接的库</p> 
 <p></p> 
 <p><img alt="" height="349" src="https://images2.imgbox.com/ee/c3/cVMMSiYv_o.png" width="700"></p> 
 <p> 编译</p> 
 <p><img alt="" height="36" src="https://images2.imgbox.com/dc/e3/PpSxPSm8_o.png" width="1097"></p> 
 <p> 基于动态库的可执行程序的执行过程</p> 
 <p><img alt="" height="114" src="https://images2.imgbox.com/38/ab/hMcrxgPd_o.png" width="1114"></p> 
 <p></p> 
 <p>指定库的路径</p> 
 <p>方式1：修改环境变量 LD_LIBRARY_PATH</p> 
 <p><img alt="" height="107" src="https://images2.imgbox.com/22/92/ygcOzL2S_o.png" width="1116"></p> 
 <p> 一般不用后两种</p> 
 <p>方式2：将自己的 libhqyj.so 库放在系统库的路径下 (/user/lib)----<span style="color:#fe2c24;">需要 root 权限</span></p> 
 <p class="img-center"><img alt="" src="https://images2.imgbox.com/68/1e/wLiH26WV_o.png"></p> 
 <p>方式3：通过修改系统库路径的配置文件来解决 ----<span style="color:#fe2c24;">需要 root 权限</span></p> 
 <p><span style="color:#0d0016;">sudo vi /etc/ld.so.conf.d/libc.conf</span></p> 
 <p class="img-center"><img alt="" src="https://images2.imgbox.com/e4/f5/criNArLk_o.png"></p> 
 <p>将自己的库文件的绝对路径添加到libc.conf中</p> 
 <p><span style="background-color:#ffd900;">sudo ldconfig</span> 立即生效，否则需要重启终端才能生效</p> 
</blockquote> 
<p></p> 
<p></p> 
<p></p> 
<p></p> 
<p></p> 
<p></p> 
<p></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/50cc2f8e20fa6d57c722ba75869c2fb7/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">c&#43;&#43; 错误集</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/b8de6aeb45f12457af88e260a0b13de5/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">前端常用的富文本编辑组件</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>