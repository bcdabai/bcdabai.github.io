<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>java基础-双指针算法 - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="java基础-双指针算法" />
<meta property="og:description" content="小伙伴们，你们好呀！我是老寇！
双指针算法是基于暴力解法的优化，将时间复杂度降低到线性。
双指针算法与其说是一种算法，不如说是一种技巧，它能够缩短循环遍历的时间，提高程序的运行速度！
双指针分为两类，快慢指针和左右指针：
1.快慢指针（弗洛伊德循环查找算法），类似龟兔赛跑。
2.左右指针又称指针碰撞，就是一左一右遍历。
注：多练习，印象才更深刻
快慢指针
快乐数
class Solution { public boolean isHappy(int n) { int slow = n,fast = n; do{ slow = bitSquareSum(slow); fast = bitSquareSum(fast); fast = bitSquareSum(fast); } while(slow != fast); return (slow == 1); } private int bitSquareSum(int x) { int sum = 0,cur; while(x &gt; 0) { cur = x % 10; x = x / 10; sum &#43;= cur * cur; } return sum; } } 结论：较哈希集，指针只需要常数的额外空间 删除有序数组中的重复项" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/814787c5d0b648dc2933d3dcea62631f/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-02-25T11:19:00+08:00" />
<meta property="article:modified_time" content="2022-02-25T11:19:00+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">java基础-双指针算法</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p>小伙伴们，你们好呀！我是老寇！</p> 
<p>双指针算法是基于暴力解法的优化，将时间复杂度降低到线性。</p> 
<p>双指针算法与其说是一种算法，不如说是一种技巧，它能够缩短循环遍历的时间，提高程序的运行速度！</p> 
<p>双指针分为两类，快慢指针和左右指针：</p> 
<p>1.快慢指针（弗洛伊德循环查找算法），类似龟兔赛跑。</p> 
<p>2.左右指针又称指针碰撞，就是一左一右遍历。</p> 
<p>注：<span style="color:#fe2c24;">多练习，印象才更深刻</span></p> 
<p><strong>快慢指针</strong></p> 
<p><a href="https://leetcode-cn.com/problems/happy-number/" rel="nofollow" title="快乐数">快乐数</a></p> 
<p><img alt="" height="523" src="https://images2.imgbox.com/e2/39/EMi5D0Jm_o.png" width="780"></p> 
<pre><code class="language-java">class Solution {
    public boolean isHappy(int n) {
      int slow = n,fast = n;
      do{
        slow = bitSquareSum(slow);
        fast = bitSquareSum(fast);
        fast = bitSquareSum(fast);
      }
      while(slow != fast);
      return (slow == 1);
    }

    private int bitSquareSum(int x) {
      int sum = 0,cur;
      while(x &gt; 0) {
        cur = x % 10;
        x = x / 10;
        sum += cur * cur;
      }
      return sum;
    }
}</code></pre> 
<p><img alt="" height="118" src="https://images2.imgbox.com/45/82/R7A3B4Fz_o.png" width="481"></p> 
<p>结论：较哈希集，指针只需要常数的额外空间 </p> 
<p></p> 
<p><a class="link-info" href="https://leetcode-cn.com/problems/remove-duplicates-from-sorted-array/" rel="nofollow" title="删除有序数组中的重复项">删除有序数组中的重复项</a></p> 
<p><img alt="" height="776" src="https://images2.imgbox.com/a4/d1/3WkFjdne_o.png" width="445"></p> 
<pre><code class="language-java">class Solution {
    public int removeDuplicates(int[] nums) {
      int len = nums.length;
      if(len &lt; 2) {
        return len;
      }
      int j = 0;
      for(int i = 0; i &lt; len; i++) {
        if(nums[j] != nums[i]) {
          nums[++j] = nums[i];
        }
      }
      return j + 1;
    }
}</code></pre> 
<p> <img alt="" height="120" src="https://images2.imgbox.com/a0/c3/cXFU7UNG_o.png" width="475"></p> 
<p>结论：找对「循环不变量」是做题的关键，我理解的循环遍历是一个if条件，在本题中nums[j]是慢指针，负责数据的替换，nums[i]是快指针，负责数据的遍历。</p> 
<p><strong>左右指针</strong></p> 
<p><a href="https://leetcode-cn.com/problems/reverse-string/" rel="nofollow" title="反转字符串">反转字符串</a></p> 
<p><img alt="" height="405" src="https://images2.imgbox.com/f5/09/m78IE6d3_o.png" width="459"></p> 
<pre><code class="language-java">class Solution {
    public void reverseString(char[] s) {
      int left = 0,right = s.length - 1;
      char c;
      while(left &lt; right) {
        c = s[left];
        s[left] = s[right];
        s[right] = c;
        left++;right--;
      }
    }
}</code></pre> 
<p><img alt="" height="120" src="https://images2.imgbox.com/e8/27/0catMNtM_o.png" width="365"></p> 
<p>结论：较套用两层for循环，所要的时间快一点</p> 
<p><strong>双指针范式（作者总结）</strong></p> 
<pre><code class="language-java">//举栗子 数组n1,n2
//1.排序
Arrays.sort(n1);
Arrays.sort(n2);
//数组索引从0开始
int index = 0,index1 = 0,index2 = 0;
//开辟数组
int len1 = n1.length,len2 = n2.length;
int[] arr = new int[Math.min(n1,n2)];
//指针动起来
while(index1 &lt; len1 &amp;&amp; index2 &lt; len2) {
   if(两个值相等) {
      index1++;
      index2++;
      arr[index++] = 其中一个值
   } else if (第一个值大) {
     index2++;
   } else {
     //第二个值大
     index1++;
    }
}

//谁小谁加+1
</code></pre>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/0bb12fe00d010861928fdf289619a6ef/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">ubuntu 安装网卡驱动</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/f3793cd881d8a49e35e57e046a633275/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">【ocr 文字检测】DocSegTr: An Instance-Level End-to-End Document Image Segmentation Transformer</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>