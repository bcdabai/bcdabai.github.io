<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Oracle Data Guard和金仓KingbaseES集群的数据保护模式对比 - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Oracle Data Guard和金仓KingbaseES集群的数据保护模式对比" />
<meta property="og:description" content="Oracle Data Guard的三种数据保护模式 根据不同的场景需求，Oracle Data Guard 提供三种数据保护模式（Data Protection Mode ）：最大可用性、最大性能和最大保护。
Maximum Availability（最大可用性） 这种保护模式可提供最高级别的数据保护，而不会影响主数据库的可用性。最大可用性模式下，事物提交需要等到恢复这些事务所需的所有重做数据都已写入在线重做日志并且完成如下步骤之一（基于用户配置）：
备库已收到redo日志，备库redo日志的刷盘I/O 已启动，并将确认信息发送回主
备库已接收并在磁盘写入redo日志，并将确认信息发送回主
如果主数据库没有收到来自至少一个同步备用数据库的确认，那么它就像处于最高性能模式一样运行以保持主数据库的可用性，直到它再次能够将其重做流写入同步备用数据库。
如果主数据库出现故障，则此模式可确保不会发生数据丢失，前提是 Oracle Data Guard 配置中至少有一个同步备用数据库。
一旦 Oracle Data Guard 将重做数据写入备用重做日志文件中的持久存储，主数据库上的事务就被视为受到保护。一旦完成，确认会迅速返回到主数据库，以便它可以继续进行下一个事务。这最大限度地减少了同步传输对主数据库吞吐量和响应时间的影响。要充分受益于备用数据库上完整的 Oracle Data Guard 验证，请确保在实时应用模式下运行，以便在收到重做更改后尽快将其应用到备用数据库。Oracle Data Guard 会向检测到的任何损坏发出信号，以便立即采取纠正措施。
最大可用性模式下的性能与保护
使用最大可用性模式时，需要了解LOG_ARCHIVE_DEST_n属性的SYNC/AFFIRM与SYNC/ NOAFFIRM(FastSync) 两种模式。
当使用SYNC/AFFIRM执行传输时，主数据库执行写操作并等待确认redo日志已同步传输到物理备用数据库并写入磁盘。性能代价为需要完成redo日志的I/O。
当使用SYNC/NOAFFIRM执行传输时，主节点执行写操作并仅等待确认数据已在备用节点上接收到，而不是已写入磁盘。
举个栗子：
假定主节点遇到灾难性故障，同时备用站点断电，在这种情况下：
SYNC/AFFIRM，数据已经写入备库磁盘，不会丢失数据，在系统恢复时，数据将在备库磁盘上可用。
在SYNC/NOAFFIRM，没有检查数据已写入备库磁盘的情况下，可能会丢失一些数据。
Maximum Performance（最大性能） 这种保护模式可提供最高级别的数据保护，而不会影响主数据库的性能。这是通过允许事务redo日志在写入在线日志后立即提交来实现的。redo日志也会写入一个或多个备用数据库，但这与事务提交是异步完成的，因此主数据库性能不受传输redo日志和从备用数据库接收确认消息所需时间的影响。
此保护模式提供的数据保护比最大可用性模式略少，并且对主数据库性能的影响最小。
这是Oracle默认的保护模式。
Maximum Protection（最大保护） 最大保护类似于最大可用性，但在发生多个故障事件时提供额外级别的数据保护。与允许主数据库在无法从备用数据库接收确认时继续处理的最大可用性不同，最大保护会关闭主数据库而不是允许它继续处理不受保护的事务。
由于这种数据保护模式将数据保护优先于主库可用性，因此Oracle建议至少使用两个备库来保护以最大保护模式运行的主库，以防止单个备库故障导致主库关闭。
Oracle如何配置数据保护模式
执行以下步骤设置主数据库的数据保护模式：
1、选择满足您的可用性、性能和数据保护要求的数据保护模式。
2、验证至少一个备用数据库满足所需数据保护模式的redo日志传输要求。
3、验证DB_UNIQUE_NAME数据库初始化参数是否已在主数据库和每个备用数据库上设置为唯一值。
4、验证是否LOG_ARCHIVE_CONFIG已在主数据库和每个备用数据库上定义了数据库初始化参数，并且其值包括一个包含主数据库和每个备用数据库的DB_UNIQUE_NAME的DG_CONFIG列表。
以下示例 SQL 语句配置LOG_ARCHIVE_CONFIG参数：
SQL&gt; ALTER SYSTEM SET LOG_ARCHIVE_CONFIG=‘DG_CONFIG=(CHICAGO,BOSTON)’;
5、通过在主数据库上执行以下 SQL 语句来设置数据保护模式：" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/498255674688927a4495d8188fe99663/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-04-18T23:11:28+08:00" />
<meta property="article:modified_time" content="2022-04-18T23:11:28+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Oracle Data Guard和金仓KingbaseES集群的数据保护模式对比</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-tomorrow-night-eighties">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <h3><a id="Oracle_Data_Guard_0"></a>Oracle Data Guard的三种数据保护模式</h3> 
<p>根据不同的场景需求，Oracle Data Guard 提供三种数据保护模式（Data Protection Mode ）：最大可用性、最大性能和最大保护。</p> 
<h4><a id="Maximum_Availability_3"></a>Maximum Availability（最大可用性）</h4> 
<p>这种保护模式可提供最高级别的数据保护，而不会影响主数据库的可用性。最大可用性模式下，事物提交需要等到恢复这些事务所需的所有重做数据都已写入在线重做日志并且完成如下步骤之一（基于用户配置）：</p> 
<p>备库已收到redo日志，备库redo日志的刷盘I/O 已启动，并将确认信息发送回主</p> 
<p>备库已接收并在磁盘写入redo日志，并将确认信息发送回主</p> 
<p>如果主数据库没有收到来自至少一个同步备用数据库的确认，那么它就像处于最高性能模式一样运行以保持主数据库的可用性，直到它再次能够将其重做流写入同步备用数据库。</p> 
<p>如果主数据库出现故障，则此模式可确保不会发生数据丢失，前提是 Oracle Data Guard 配置中至少有一个同步备用数据库。</p> 
<p>一旦 Oracle Data Guard 将重做数据写入备用重做日志文件中的持久存储，主数据库上的事务就被视为受到保护。一旦完成，确认会迅速返回到主数据库，以便它可以继续进行下一个事务。这最大限度地减少了同步传输对主数据库吞吐量和响应时间的影响。要充分受益于备用数据库上完整的 Oracle Data Guard 验证，请确保在实时应用模式下运行，以便在收到重做更改后尽快将其应用到备用数据库。Oracle Data Guard 会向检测到的任何损坏发出信号，以便立即采取纠正措施。</p> 
<p>最大可用性模式下的性能与保护<br> 使用最大可用性模式时，需要了解LOG_ARCHIVE_DEST_n属性的SYNC/AFFIRM与SYNC/ NOAFFIRM(FastSync) 两种模式。</p> 
<p>当使用SYNC/AFFIRM执行传输时，主数据库执行写操作并等待确认redo日志已同步传输到物理备用数据库并写入磁盘。性能代价为需要完成redo日志的I/O。</p> 
<p>当使用SYNC/NOAFFIRM执行传输时，主节点执行写操作并仅等待确认数据已在备用节点上接收到，而不是已写入磁盘。</p> 
<p>举个栗子：</p> 
<p>假定主节点遇到灾难性故障，同时备用站点断电，在这种情况下：</p> 
<p>SYNC/AFFIRM，数据已经写入备库磁盘，不会丢失数据，在系统恢复时，数据将在备库磁盘上可用。</p> 
<p>在SYNC/NOAFFIRM，没有检查数据已写入备库磁盘的情况下，可能会丢失一些数据。</p> 
<h4><a id="Maximum_Performance_31"></a>Maximum Performance（最大性能）</h4> 
<p>这种保护模式可提供最高级别的数据保护，而不会影响主数据库的性能。这是通过允许事务redo日志在写入在线日志后立即提交来实现的。redo日志也会写入一个或多个备用数据库，但这与事务提交是异步完成的，因此主数据库性能不受传输redo日志和从备用数据库接收确认消息所需时间的影响。</p> 
<p>此保护模式提供的数据保护比最大可用性模式略少，并且对主数据库性能的影响最小。</p> 
<p>这是Oracle默认的保护模式。</p> 
<h4><a id="Maximum_Protection_38"></a>Maximum Protection（最大保护）</h4> 
<p>最大保护类似于最大可用性，但在发生多个故障事件时提供额外级别的数据保护。与允许主数据库在无法从备用数据库接收确认时继续处理的最大可用性不同，最大保护会关闭主数据库而不是允许它继续处理不受保护的事务。</p> 
<p>由于这种数据保护模式将数据保护优先于主库可用性，因此Oracle建议至少使用两个备库来保护以最大保护模式运行的主库，以防止单个备库故障导致主库关闭。</p> 
<p>Oracle如何配置数据保护模式<br> 执行以下步骤设置主数据库的数据保护模式：</p> 
<p>1、选择满足您的可用性、性能和数据保护要求的数据保护模式。</p> 
<p>2、验证至少一个备用数据库满足所需数据保护模式的redo日志传输要求。</p> 
<p>3、验证DB_UNIQUE_NAME数据库初始化参数是否已在主数据库和每个备用数据库上设置为唯一值。</p> 
<p>4、验证是否LOG_ARCHIVE_CONFIG已在主数据库和每个备用数据库上定义了数据库初始化参数，并且其值包括一个包含主数据库和每个备用数据库的DB_UNIQUE_NAME的DG_CONFIG列表。</p> 
<p>以下示例 SQL 语句配置LOG_ARCHIVE_CONFIG参数：</p> 
<p>SQL&gt; ALTER SYSTEM SET LOG_ARCHIVE_CONFIG=‘DG_CONFIG=(CHICAGO,BOSTON)’;<br> 5、通过在主数据库上执行以下 SQL 语句来设置数据保护模式：</p> 
<p>SQL&gt; ALTER DATABASE -</p> 
<blockquote> 
 <p>SET STANDBY DATABASE TO MAXIMIZE {AVAILABILITY | PERFORMANCE | PROTECTION};<br> 注意：MAXIMUM PROTECTION只有在当前数据保护模式为MAXIMUM AVAILABILITY并且至少有一个同步的备库时才能设置。</p> 
</blockquote> 
<p>6、对主数据库执行以下查询以确认它在新的保护模式下运行：</p> 
<p>SQL&gt; SELECT PROTECTION_MODE FROM V$DATABASE;</p> 
<h3><a id="KingbaseES_68"></a>KingbaseES集群的两种数据保护模式</h3> 
<p>KingbaseES集群在部署的时候提供两种保护模式<br> 根据选项不同，reconnect_attempts， reconnect_interval，recovery，synchronous_commit 四个参数的默认值不同。 默认选项为数据保护优先<br> <img src="https://images2.imgbox.com/66/c7/ZTB0Jquk_o.png" alt="在这里插入图片描述"></p> 
<h4><a id="_72"></a>数据保护优先</h4> 
<p><strong>reconnect_attempts</strong><br> 集群中连接的重试次数，数据保护优先默认值为10。</p> 
<p><strong>reconnect_interval</strong><br> 集群中连接的重试间隔。 数据保护优先默认值为6。</p> 
<p><strong>recovery</strong><br> 节点故障自动恢复，可选值为automatic、standby、manual。<br> manual，关闭自动恢复，故障节点无论是主机还是备机， 都不进行自动恢复；<br> standby，故障节点是备机才自动恢复；<br> automatic，所有故障节点都自动恢复。<br> — 数据保护优先默认值为standby。</p> 
<p><strong>synchronous_commit</strong><br> 指定在命令返回"success"指示给客户端之前， 一个事务是否需要等待WAL记录被写入磁盘。 可选值为on、off、local、remote_write、remote_apply。<br> 数据保护优先默认值为remote_apply</p> 
<h4><a id="_90"></a>服务可用优先</h4> 
<p><strong>reconnect_attempts</strong><br> 集群中连接的重试次数，服务可用优先默认值为3。</p> 
<p><strong>reconnect_interval</strong><br> 集群中连接的重试间隔。 服务可用优先默认值为5。</p> 
<p><strong>recovery</strong><br> 节点故障自动恢复，可选值为automatic、standby、manual。<br> manual，关闭自动恢复，故障节点无论是主机还是备机， 都不进行自动恢复；<br> standby，故障节点是备机才自动恢复；<br> automatic，所有故障节点都自动恢复。<br> — 服务可用优先默认值为automatic。</p> 
<p><strong>synchronous_commit</strong><br> 指定在命令返回"success"指示给客户端之前， 一个事务是否需要等待WAL记录被写入磁盘。 可选值为on、off、local、remote_write、remote_apply。<br> 服务可用优先默认值为on</p> 
<hr> 
<h5><a id="synchronous_commit_109"></a>关于synchronous_commit参数</h5> 
<p><strong>synchronous_commit=off</strong><br> 表示提交事务时不需等待本地相应WAL数据写入本地WAL日志文件即可向客户端返回成功。<br> <strong>synchronous_commit=local</strong><br> 表示提交事务时需等待相应WAL数据写入本地WAL日志文件后才向客户端返回成功。<br> <strong>synchronous_commit=remote_write</strong><br> 当流复制主库提交事务时，需等待备库接收主库发送的WAL日志流并写入备节点操作系统缓存中，才向客户端返回成功。<br> <strong>synchronous_commit=on</strong><br> on跟单实例下含义不同，表示流复制主库提交事务时，需等待备库接收主库发送的WAL日志流并写入WAL文件，之后才向客户端返回成功。<br> <strong>synchronous_commit=remote_apply</strong><br> 表示流复制主库提交事务时 ，需等待备库完成相应部分apply才向客户端返回成功。</p> 
<p>对比可知，Oracle同KingbaseES数据库的数据保护模式维度不同</p> 
<ol><li>从数据保护维度来看，KingbaseES的两种保护模式下都需要确保备机上日志完成写入并落盘，对比Oracle，这均属于oracle的Maximum Availability（最大可用性）范畴。</li><li>集群的切换时长以及故障主库是否恢复，在Oracle的保护模式下并未详细说明。</li></ol> 
<p>【更多人大金仓数据库信息， 详见 <a href="https://help.kingbase.com.cn" rel="nofollow">金仓文档管理系统</a> 】</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/2a95ce573343c0d4c3a0d75b75ed16cd/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">51单片机（入门保姆级教程）——点亮一个LED灯</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/208fbbe56248db134998a78fd3f73167/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">雪花Id(snowflake)主键(Long) ，前端丢失精度原理及解决之道</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>