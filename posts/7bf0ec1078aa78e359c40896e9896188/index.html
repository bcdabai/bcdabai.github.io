<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>【Java】编码规范 - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="【Java】编码规范" />
<meta property="og:description" content="Java编程入门 回顾 什么是Java语言 一种面向对象的语言 编写程序的开始就是编写类的开始 class 用于定义类 一种平台无关的语言，必须程序运行的解释环境 真正的运行步骤为 javac编译–java解释执行 一种健壮【鲁棒性】的语言，吸收了C/C&#43;&#43;语言的优点，但是去掉了影响程序健壮性的部分，例如指针、内存的申请与释放等。
典型的应用场景：互联网环境 常见错误 1、使用临时变量，Java要求必须是先定义后使用，必须是先赋初值后使用
int k; Systm.out.println(k); 2、目前的要求：将所有的程序都必须写在方法内部，不能写在方法外
public class ForTest{ int res=0; for(int k=1;k&lt;101;k&#43;&#43;){ res&#43;=k; } System.out.println(&#34;1&#43;2&#43;3&#43;...&#43;100=&#34;&#43;res); } Java的三种核心机制 Java语言包含三种核心机制：Java 虚拟机、垃圾收集机制和代码安全检测。 Java虚拟机 JVM Java虚拟机可以理解成一个以字节码为机器指令的CPU对于不同的运行平台，有不同的虚拟机Java虚拟机机制屏蔽了底层运行平台的差别，实现了“一次编译，到处运行”
垃圾收集机制 gc 不再使用内存空间回收——垃圾回收在C/C&#43;&#43;等语言中，由程序员负责回收无用内存 Java语消除了程序员回收无用内存空间的责任，它提供了一种系统级线程跟踪存储空间的分配情况，并在JVM的空闲时检查并释放哪些可被释放的存储空间 垃圾收集在Java程序原型过程中自动运行，程序员无法精确控制和干预 代码安全性检查 Java代码的目标运行环境在于网络，Java以牺牲执行性能为代价换取了高安全性
首先由类加载器classLoader负责将类文件.class加载到Java虚拟机中。通过区分本地文件系统的类和网络系统导入的类增加安全性，可以限制任何木马程序，因为本机类总是有限被加载，一旦所有的类都被加载完毕，直线文件的内存就固定了。其次字节码校验器进行校验。字节码校验器不检查那些可信任的编译器生成的类文件，而是对违背 命名空间规定和java语言规则的类进行检查，并且关闭具有安全性漏洞的类文件最后字节码校验通过后，才由Java解释器负责将类文件解释成为机器码进行执行 Java中标识符 字母（Unicode编码字符集）、数字、下划线和$符构成，不允许数字打头严格区分大小写ISO8859-1GB2312和GBK【GB8030】Unicode统一编码字符集 由于_和$有特殊含义，一般不建议用户直接使用不建议使用中文命名 不允许使用保留字(goto const)和关键字(public class static…)长度没有限制 public class ForTest{ int res=0; for(int k=1;k&lt;101;k&#43;&#43;){ res&#43;=k; } System.out.println(&#34;1&#43;2&#43;3&#43;...&#43;100=&#34;&#43;res); } 编码规范 类名首字母大写，大写字母分词 建议名词。例如UserName或者MingZi方法名称首字母小写，大写字母分词变量名称首字母小写，大写字母分词包名称全小写，使用域名反转的方式定义
平常练习中遵循SUN的基础规范；项目开发中要求遵循ali发布的规范。进入公司首先考察公司的编码规
范 Java是一种先编译后解释执行型语言 javac Hello." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/7bf0ec1078aa78e359c40896e9896188/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-07-07T16:49:36+08:00" />
<meta property="article:modified_time" content="2022-07-07T16:49:36+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">【Java】编码规范</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <h2><a id="Java_1"></a>Java编程入门</h2> 
<h3><a id="_2"></a>回顾</h3> 
<h4><a id="Java_3"></a>什么是Java语言</h4> 
<ul><li>一种面向对象的语言 
  <ul><li>编写程序的开始就是编写类的开始 class 用于定义类</li></ul> </li><li>一种平台无关的语言，必须程序运行的解释环境 
  <ul><li>真正的运行步骤为 javac编译–java解释执行</li></ul> </li><li>一种健壮【鲁棒性】的语言，吸收了C/C++语言的优点，但是去掉了影响程序健壮性的部分，例如指针、内存的申请与释放等。<br> 典型的应用场景：互联网环境</li></ul> 
<h4><a id="_10"></a>常见错误</h4> 
<p>1、使用临时变量，Java要求必须是先定义后使用，必须是先赋初值后使用</p> 
<pre><code>int k;
Systm.out.println(k);
</code></pre> 
<p>2、目前的要求：将所有的程序都必须写在方法内部，不能写在方法外</p> 
<pre><code>public class ForTest{
int res=0;
for(int k=1;k&lt;101;k++){
res+=k;
}
System.out.println("1+2+3+...+100="+res);
}
</code></pre> 
<h4><a id="Java_26"></a>Java的三种核心机制</h4> 
<ul><li>Java语言包含三种核心机制：Java 虚拟机、垃圾收集机制和代码安全检测。</li></ul> 
<h4><a id="Java_JVM_28"></a>Java虚拟机 JVM</h4> 
<ul><li>Java虚拟机可以理解成一个以字节码为机器指令的CPU</li><li>对于不同的运行平台，有不同的虚拟机</li><li>Java虚拟机机制屏蔽了底层运行平台的差别，实现了“一次编译，到处运行”<br> <img src="https://images2.imgbox.com/2b/fd/p5PHK9tL_o.png" alt="在这里插入图片描述"></li></ul> 
<h4><a id="_gc_34"></a>垃圾收集机制 gc</h4> 
<ul><li>不再使用内存空间回收——垃圾回收</li><li>在C/C++等语言中，由程序员负责回收无用内存 
  <ul><li>Java语消除了程序员回收无用内存空间的责任，它提供了一种系统级线程跟踪存储空间的分配情况，并在JVM的空闲时检查并释放哪些可被释放的存储空间</li></ul> </li><li>垃圾收集在Java程序原型过程中自动运行，程序员无法精确控制和干预</li></ul> 
<h4><a id="_39"></a>代码安全性检查</h4> 
<p>Java代码的目标运行环境在于网络，Java以牺牲执行性能为代价换取了高安全性</p> 
<ul><li>首先由类加载器classLoader负责将类文件.class加载到Java虚拟机中。通过区分本地文件系统的类和网络系统导入的类增加安全性，可以限制任何木马程序，因为本机类总是有限被加载，一旦所有的类都被加载完毕，直线文件的内存就固定了。</li><li>其次字节码校验器进行校验。字节码校验器不检查那些可信任的编译器生成的类文件，而是对违背 命名空间规定和java语言规则的类进行检查，并且关闭具有安全性漏洞的类文件</li><li>最后字节码校验通过后，才由Java解释器负责将类文件解释成为机器码进行执行</li></ul> 
<h3><a id="Java_44"></a>Java中标识符</h3> 
<ul><li>字母（Unicode编码字符集）、数字、下划线和$符构成，不允许数字打头</li><li>严格区分大小写</li><li>ISO8859-1</li><li>GB2312和GBK【GB8030】</li><li>Unicode统一编码字符集 
  <ul><li>由于_和$有特殊含义，一般不建议用户直接使用</li><li>不建议使用中文命名</li></ul> </li><li>不允许使用保留字(goto const)和关键字(public class static…)</li><li>长度没有限制</li></ul> 
<pre><code>public class ForTest{
int res=0;
for(int k=1;k&lt;101;k++){
res+=k;
}
System.out.println("1+2+3+...+100="+res);
}
</code></pre> 
<h4><a id="_63"></a>编码规范</h4> 
<ul><li>类名首字母大写，大写字母分词 建议名词。例如UserName或者MingZi</li><li>方法名称首字母小写，大写字母分词</li><li>变量名称首字母小写，大写字母分词</li><li>包名称全小写，使用域名反转的方式定义<br> 平常练习中遵循SUN的基础规范；项目开发中要求遵循ali发布的规范。进入公司首先考察公司的编码规<br> 范</li></ul> 
<h4><a id="Java_70"></a>Java是一种先编译后解释执行型语言</h4> 
<ul><li>javac Hello.java【源代码文件名称】编译，将源代码转换为虚拟机可以识别的中间性质语言，一般生成一个同名的后缀为class的文件【二进制文件，字节码文件】,这里就是跨平台的原理</li><li>java Hello[类名称，就是源代码中class关键字后面所跟的名称]一般是解释执行字节码文件</li></ul> 
<h4><a id="Java_73"></a>Java语法基础</h4> 
<ul><li>Java大小写敏感。比如HelloWorld和Helloworld是不一样的</li><li>包名Package是公司、组织、个人的域名的反转，一般是英文字母。英文字母必须是小写 
  <ul><li>包名称可以认为是一个名空间</li><li>例如蓝鸥的网址为lanou3g.com，定义包名称为com.lanou3g</li></ul> </li><li>类名ClassName和方法名称采用驼峰命名法，例如StudentName</li><li>Java源文件的文件名必须和文件中公共public类名称一样</li></ul> 
<pre><code>public class Hello { //公共类名称为Hello,则对应的文件名称必须为Hello.java
}
</code></pre> 
<ul><li>关键字中所有字母都为小写。关键字不能用作变量名，方法名，类名，包名和参数。</li></ul> 
<h5><a id="Java_85"></a>Java是一种自由格式的语言，可用任意个空格、制表符、换行符隔开每个词</h5> 
<p>System.<br> out.<br> println<br> ( “Counted " + count + " chars.” );<br> 同时也允许将多行代码写在一行上,注意使用分号隔开。所有的语句末尾以分号;收尾</p> 
<pre><code>for(int i=0;i&lt;10;i++)cc++; dd++;
</code></pre> 
<p>java中空语句</p> 
<pre><code>;
</code></pre> 
<h4><a id="_98"></a>常见的编程错误</h4> 
<p>目前的要求：将所有的程序都必须写在方法内部，不能写在方法外<br> 使用临时变量，Java要求必须是先定义后使用，必须是先赋初值后使用</p> 
<h4><a id="Java_101"></a>Java标识符</h4> 
<ul><li>标识符可从一个字母(Unicode编码字符集)、下划线_或美元符号$开始，随后也可跟数字、字母、下划线或美元符号。</li><li>标识符是区分大小写，没有长度限制，可以为标识符取任意长度的名字</li><li>标识符不允许使用保留字。关键字对Java编译器有特殊的含义，它们可标识数据类型名或程序构造construct名， java语言中的保留字均用小写字母表示</li></ul> 
<h4><a id="_105"></a>变量</h4> 
<ul><li>变量是Java程序中的基本存储单元，它的定义包括变量名、变量类型和作用域几个部分</li><li>例如int k=100; 其中int是数据类型，k是变量名 m</li><li>变量名称：在一个方法内部不允许出现多个同名称的变量 
  <ul><li>java要求见名知意，例如username。但是xm则不建议使用变量类型：</li><li>Java属于强类型编程语言，变量类型一旦声明，则不能进行修改</li><li>数据类型可以决定变量所需要的存储空间大小和对应的处理逻辑</li></ul> </li></ul> 
<pre><code>int k; 声明一个变量，类型为整形，变量名称为k
int k=100; 声明变量的同时进行初始化
k=12.345; 语法错误，因为已经声明了类型为整形，但是12.345不是整数
d=123; 语法错误，因为Java语法要求对于变量必须是先定义后使用
</code></pre> 
<p>作用域是指变量的有效范围，一般是在所在花括号范围内</p> 
<pre><code>public static void main(String[] args){
{
System.out.println(k);//错误1：要求临时变量必须是先定义后使用，必须是先赋初值后使
用
int k=100;
System.out.println(k);
}
System.out.println(k);//错误2：因为k定义在{}内部，所以k只在上面的{}分为内有效，离开了
{}则失效，{}外引用k则报错
}
</code></pre> 
<pre><code>public static void main(String[] args){
int k=99;
{
System.out.println(k);
int k=100; //错误：因为Java是强类型编程语言，所以在{}外已经声明了k的类型，在k的有效
范围内不允许重新声明。这里可以修改为k=100;
System.out.println(k);
}
System.out.println(k);
}
</code></pre> 
<h4><a id="JAVA_143"></a>JAVA是强类型语言</h4> 
<p>每个变量有类型，每个表达式有类型，而且每种类型都是严格定义的<br> Java编译器对所有的表达式和参数都要进行类型相容性的检查，以保证类型是兼容的</p> 
<pre><code>short k1=123;
int k2=k1;//没有错误
</code></pre> 
<p>任何类型的不匹配都将被报告为错误而不是警告。在编译器完成编译以前，错误必须被改正过来</p> 
<pre><code>String s1="123";//字符串类型
int k1=s1;//语法报错
</code></pre> 
<p>在Java语言数据类型可以分为两大类：基本类型和引用类型</p> 
<h4><a id="_156"></a>基本类型(原生类型)</h4> 
<p>基本类型是指不能再分解的数据类型，其数据在函数的调用中是以传值方式工作的。<br> 简单数据类型代表单值，而不是复杂的对象<br> Java是完全面向对象的，但简单数据类型却不是，它们类似于其他大多数非面向对象语言中的简单数据类型。这样做的原因是出于效率方面的考虑。在面向对象中引入简单数据类型不会对执行效率产生太多的影响。<br> Java针对基本类型同时提供了对应的引用类型：包装类<br> Java编程语言有八个原始数据类型，可分为4种整型、浮点数、字符型数据和布尔型数据，不会随着计算机类型而变化的，注意Java具有平台无关性，所以不论硬件平台是什么，1B都是8位</p> 
<h4><a id="4byteshortintlong_162"></a>整型有4种：byte字节整、short短整、int整、long长整</h4> 
<ul><li>java中的数据采用的是补码的存储方式<br> 计算机中存储数据有3种不同的方式，分别是原码、反码和补码<br> byte：1B(8b)，-128到127</li></ul> 
<pre><code>byte k = 100;//语法正确100在指定范围内
byte kk = 130;//语法报错，因为130超出byte的存储范围限制
//这里的面试点在常量池
</code></pre> 
<p>short：2B，-32768到32767<br> int：4B，-2147483648到2147483647<br> long：8B，-9223372036854775808到9223372036854775807<br> 如果需要使用具体的上下限取值，可以通过包装类中的常量进行使用</p> 
<pre><code>System.out.println(Integer.MAX_VALUE);
System.out.println(Integer.MIN_VALUE);
</code></pre> 
<p>十进制整数。如123，－456，0<br> 八进制整数。以0开头，如0123表示十进制数83，－011表示十进制数－9。<br> 十六进制整数。以0x或0X开头，如0x123表示十进制数291，－0X12表示十进制数－18</p> 
<pre><code>a--&gt;10 b--&gt;11 c--&gt;12 d--&gt;13 e--&gt;14 f--&gt;15
</code></pre> 
<p>二进制整数，以0b或0B开头，例如0b10110010</p> 
<pre><code>int k1=123;
int k2=0123;
int k3=0x123;
int k4=0b100101;
System.out.println(k1+"\t"+k2+"\t"+k3+"\t"+k4);//具体输出时，系统会自动将k2转换为10进
制输出
</code></pre> 
<p>可以通过包装类中提供的方法将十进制数转换为2、8和16进制</p> 
<pre><code>int k = 123;
String ob=Integer.toBinaryString(k);//将十进制数转换为2进制的字符串
System.out.println(ob); //1111011
String oo=Integer.toOctalString(k);
System.out.println(oo); //173
String oh=Integer.toHexString(k);
System.out.println(oh);//7b
</code></pre> 
<p>整数类缺省为int类型，如在其后有一个字母“l或者L”表示一个long值</p> 
<pre><code>123系统会自动识别为int类型
123L或者123l系统自动识别为long
</code></pre> 
<h4><a id="_210"></a>浮点数类型</h4> 
<p>float单精度、double双精度</p> 
<ul><li>float是4B，可以保证小数点后6位有效精度和第7位的部分精度 e38</li><li>double是8B，可以保证小数点后15位有效精度和第16位的部分精度。e308</li><li>浮点数是无法精确存放的，原因在于将浮点数转换为补码时的限制</li></ul> 
<pre><code>double res = 0;
for (int i = 0; i &lt; 10; i++)
res += 0.1;
System.out.println(res); //0.9999999999999999
</code></pre> 
<ul><li>针对浮点数则不能使用等值判断<br> Java浮点数都是用科学计数法来存储数据的，无论是单精度还是双精度在存储中都分为三个部分：</li><li>符号位Sign : 0代表正，1代表为负，是第一位</li><li>指数位Exponent：用于存储科学计数法中的指数数据，单精度为8位，双精度11位。用指数部分的值（8位/11位unsigned）的值减去偏移附加值得到该数实际的指数。例如值200，实际指数为73=200-127，对于双精度的double来说常量1023</li><li>尾数部分Mantissa</li></ul> 
<pre><code>double d = 0.1d;
long l = Double.doubleToLongBits(d); //long类型和double类型都是64位的,他们的内存大小一
样,这个函数的做法就是把double对应的内存结构复制到同样大小的long类型变量的内存结构中.返回这个
long值
System.out.println(t.getLongBits(l));
</code></pre> 
<p>样例17.625在内存中的存储为：</p> 
<ul><li>首先要把17.625换算成二进制：10001.101 
  <ul><li>整数部分：除以2，直到商为0，余数反转</li><li>小数部分：乘以2，直到乘位为0，进位顺序取。(即：乘2取整法)</li></ul> </li><li>再将10001.101右移，直到小数点前只剩1位，1.0001101*2^4 ，右移动了四位。</li></ul> 
<pre><code>底数：因为小数点前必为1，所以IEEE规定只记录小数点后的就好。所以，此处的底数为
0001101
指数：实际为4，必须加上127（转出的时候，减去127/1023），所以为131。也就是
10000011
</code></pre> 
<ul><li>符号：因为是正数，所以是0</li><li>综上所述，17.625在内存中的存储格式是：01000001 10001101 00000000 00000000<br> 在Java中浮点数无法精确存放，除非使用BigDecimal<br> float:4B:1.4E-45到3.4028235E38 保存7-8位有效数据<br> double:8B:4.9E-324到1.7976931348623157E308 保存15-16位有效数据<br> <strong>注意：浮点数无法精确存放</strong><br> <strong>表示方法：</strong></li><li>十进制数形式。由数字和小数点组成，且必须有小数点，如0.123, 1.23, 123.0</li><li>科学计数法形式。如：123e3或123E-3，其中e或E之前必须有数字，且e或E后面的指数必须为整数</li><li>f或者F表示float，而d或者D代表double。例如123f或者123.45D，系统默认为double类型</li></ul> 
<h5><a id="Java_257"></a>Java精确计算问题</h5> 
<p>关键字strictfp是strict float point的缩写，指的是精确浮点，它是用来确保浮点数运算的准确性。</p> 
<ul><li>JVM在执行浮点数运算时，如果没有指定strictfp关键字，此时计算结果可能会不精确，而且计算结果在不同平台或厂商的虚拟机上会有不同的结果，导致意想不到的错误。而一旦使用了strictfp来声明一个类、接口或者方法，那么在所声明的范围内，Java编译器以及运行环境会完全依照IEEE二进制浮点数算术标准来执行，在这个关键字声明的范围内所有浮点数的计算都是精确的。</li><li>需要注意的是，当一个类被strictfp修饰时，所有方法都会自动被strictfp修饰。因此，strictfp可以保证浮点数运算的精确性，而且在不同的硬件平台会有一致的运行结果。但是精确计算事实上还是没有得到保障，这是受到存储方式的限制。需要精确计算还是以来BigDecimal实现的。</li></ul> 
<h5><a id="_261"></a>常见数学计算</h5> 
<p>Java的Math类中包含了用于执行基本数学运算的属性和方法，如初等指数、对数、平方根和三角函数。Math的方法都被定义为static 形式，通过Math类可以在主函数中直接调用。</p> 
<ul><li>Math.sqrt()计算平方根</li></ul> 
<pre><code>int k=16; //如果不能执行计算，则返回NaN
double res=Math.sqrt(k);
System.out.println(res);
</code></pre> 
<ul><li>Math.pow(a, b)计算a的b次方</li><li>Math.max(a,b)计算最大值</li><li>Math.min(a,b)计算最小值</li><li>Math.abs()求绝对值</li><li>Math.ceil天花板的意思，就是返回大的值；floor地板的意思，就是返回小的值；round 四舍五入，float时返回int值，double时返回long值</li></ul> 
<pre><code>double d1=-1234.567;
System.out.println(Math.ceil(d1));//-1234.0
System.out.println(Math.floor(d1));//-1235.0
System.out.println(Math.round(d1)); //-1235 容易出错的位置
d1=1234.567;
System.out.println(Math.ceil(d1)); //1235.0
System.out.println(Math.floor(d1));//1234.0
System.out.println(Math.round(d1)); //1235
</code></pre> 
<ul><li>random 取得一个大于或者等于0.0小于不等于1.0的随机数</li></ul> 
<h5><a id="_char_285"></a>字符类型 char</h5> 
<p>Java中存放字符采用的是Unicode编码字符集，2B，0-65535</p> 
<ul><li>字符类型的变量可以当作整数使用</li><li>char c=‘a’; 注意：这里使用的是单引号，不是双引号，单引号中只能包含一个字符 
  <ul><li>需要记忆： ‘0’ &lt; ‘A’ &lt;‘a’</li></ul> </li><li>Java也提供转义字符，以反斜杠（\）开头，将其后的字符转变为另外的含义</li></ul> 
<pre><code>\ddd 1到3位8进制数所表示的字符(ddd) 例如'\110'实际就是字符H
\uxxxx 1到4位16进制数所表示的字符(xxxx)，例如'\u9110'表示字符'鄐'
\’ 单引号字符,例如'\''
\" 双引号字符,例如'"'实际上是可以的，但是这样写可读性非常差，所以建议使用'\"'
\\ 反斜杠字符
</code></pre> 
<h6><a id="_299"></a>基本使用</h6> 
<pre><code>char c='h';
System.out.println((int)c); //获取'h'字符对应的unicode编码值 104
//GB2312
System.out.println(c);
// c='ab' 语法报错，因为只能对应一个字符
//引入转移字符
c='\'';
c='\110';
System.out.println(c);//H
System.out.println((int)c);//72
c='\u0050';
System.out.println(c); //P
System.out.println((int)c);//80
</code></pre> 
<h4><a id="__boolean_315"></a>布尔类型 boolean</h4> 
<p>boolean数据类型有两种文字值：true真和false假<br> 在Java编程语言中boolean类型只允许使用boolean值，在整数类型和boolean类型之间无转换计算</p> 
<pre><code>boolean类型被编译为int类型，等于是说JVM里占用字节和int完全一样，int是4个字节，于是
boolean也是4字节
boolean数组在Oracle的JVM中，编码为byte数组，每个boolean元素占用8位=1字节
</code></pre> 
<h5><a id="_323"></a>基本数据类型转换</h5> 
<p>小转大自动转换</p> 
<pre><code>byte b1=123;
long k1=b1;
double kk=k1;
System.out.println(kk);
long kk = 123456L;
float ff=kk; //没有错误。float 4B long 8B
</code></pre> 
<p>大转小需要强制转换</p> 
<pre><code>double dd=123.567;
long kk=(long)dd;
System.out.println(kk);
</code></pre> 
<h5><a id="_339"></a>类型转换的语法：</h5> 
<pre><code>int k=100;
char cc=(char)k; //强制类型转换：窄化操作
char k='d';
System.out.println((int)k);
boolean bb=true;
System.out.println((int)bb);//因为boolean类型和数值类型之间没有任何对应关系，所以这里的强转会报语法错误
</code></pre> 
<p>double</p> 
<pre><code>float f1=123.456;//语法报错，因为系统默认带小数点的数据为double类型，所以123.456是double
类型的数据，而声明f1为float，所以这里需要进行数据类型转换或者进行特殊声明。如果浮点数转换为整数
是直接截断小数部分。
float f1=(float)123.456;
float f1=123.456f; //数字末尾的f类似于数字末尾的L，用于进行数据类型的说明，f/F表示这是一个
float类型的数据 d/D表示是一个double类型的数据
</code></pre> 
<h5><a id="_357"></a>复合数据类型</h5> 
<p>复合数据类型包括：class类、interface接口、数组。<br> null 索引在运行时并没有对应的类型，但它可以被转换为任何类型（不能是简单类型）。<br> 索引类型的默认值就是null</p> 
<h5><a id="_361"></a>常量</h5> 
<p>常量就是指在程序执行期间其值不能发生变化的数据，常量是固定的。如整型常量123，实型常量1.23，字符常量’A’，布尔常量true等<br> 需求：要求用户键盘输入一个整数的半径值，计算园的面积</p> 
<pre><code>Scanner sc = new Scanner(System.in);
System.out.println("请输入半径值：要求整数");
int r=0;//定义一个变量
r=sc.nextInt();//会等待用户输入整数值，如果不正确则会有红色报错信息
//计算园的面积
double res=3.14*r*r; //Math.pow(r, 2)
//输出计算结果
System.out.println("半径值为"+r+"的圆形面积为"+res);
</code></pre> 
<p><img src="https://images2.imgbox.com/45/f1/rZsldoWD_o.png" alt="在这里插入图片描述"><br> 还需要计算周长</p> 
<pre><code>Scanner sc = new Scanner(System.in);
System.out.println("请输入半径值：要求整数");
int r=0;//定义一个变量
r=sc.nextInt();//会等待用户输入整数值，如果不正确则会有红色报错信息
//计算园的面积
double res=3.14*r*r; //Math.pow(r, 2)
//计算圆的周长
double dd=3.14*2*r;
//输出计算结果
System.out.println("半径值为"+r+"的圆形面积为"+res+",对应周长为"+dd);
</code></pre> 
<p>但是客户提出需求变动，认为2位小数精度不足，需要进一步提升精度<br> 解决方案就是将2处的3.14修改为3.1415926<br> 新问题是：如果修改时漏改一处，则是一个隐藏的bug。引入常量以避免出现这样的问题。</p> 
<pre><code>public class Test1 {
static final double PI=3.14159267989;//定义一个常量，这个值一旦赋值则不允许修改。常
量的命名规则全大写，使用_分词
public static void main(String[] args) {
Scanner sc = new Scanner(System.in);
System.out.println("请输入半径值：要求整数");
int r=0;//定义一个变量
r=sc.nextInt();//会等待用户输入整数值，如果不正确则会有红色报错信息
//计算园的面积
double res=PI*r*r; //Math.pow(r, 2)
//计算圆的周长
double dd=PI*2*r;
//输出计算结果
System.out.println("半径值为"+r+"的圆形面积为"+res+",对应周长为"+dd);
}
}
</code></pre> 
<h6><a id="_410"></a>如何接收键盘录入数据</h6> 
<p>java.util.Scanner类常用于控制台的输入,当需要使用控制台输入时即可调用这个类。</p> 
<h6><a id="_412"></a>使用方法</h6> 
<ul><li>首先需要构造一个Scanner类的对象，并且与标准输入流System.in关联 Scanner sc = new<br> Scanner(System.in);</li><li>调用Scanner类对象sc的方法从输入流中获取你需要的输入<br> 说明：<br> 当创建了一个Scanner类对象之后，控制台会一直等待输入，直到敲回车键结束，把所输入的内容<br> 传给对象sc，若要获取需要的内容，调用sc的方法即可</li></ul> 
<pre><code>Scanner sc=new Scanner(System.in);
System.out.println("请输入园的半径值:"); //用于提示用户录入数据
int r=sc.nextInt(); //要求用户输入数据，否则阻塞等待用户输入
System.out.println("接受到的数据为"+r);
</code></pre> 
<p>每次可以只输入一个数字，回车确认，例如123，只能被一个nextInt读取。<br> 也可以输入一组数字，例如123 456 789，每个数字之间用空格（一个或多个空格）隔开，可被多<br> 个nextInt()读取，空格及回车不会被读取。（注：输入数字中不能夹杂除数字、空格、回车之外的<br> 其他字符，否则会报错）</p> 
<h6><a id="_429"></a>如何在控制台输出数据</h6> 
<pre><code>System.out.println(数据);
System.out.println("请输入园的半径值:");
int kk=100;
double res=3.14*kk*kk;
System.out.println("园的半径值为"+kk+",对应面积为"+res);
</code></pre> 
<h4><a id="_437"></a>表达式</h4> 
<p>表达式就是运算符、操作数以及方法调用的序列，用来说明某个计算过程并返回计算结果. 按照运算符功能来分，基本的运算符分包括算术运算符、关系运算符、位运算符、条件运算符等</p> 
<ul><li>算术运算符 +、-、*、/、%、++、–</li><li>关系运算符 &gt;、&lt;、&gt;=、&lt;=、==、!=</li><li>逻辑运算符 &amp;&amp;、 ||、 !。注意：逻辑计算支持短路操作</li><li>位运算符 &amp;、|、^、~、&lt;&lt; 、 &gt;&gt;、&gt;&gt;&gt;。注意：为运算符不支持短路操作[考点]</li><li>赋值运算符 =，+=，―=，*=，/=</li><li>三目条件运算符（？：）规则是完全一致的，使用的形式是： x ? y：z;</li></ul> 
<h5><a id="__445"></a>算术运算符 +、-、*、/、%、++、–</h5> 
<pre><code>+-*/
整除：参与运算的双方都是整数 10/3=3而不是3.33333
如果是10./3=3.333...这里由于10.是浮点数，则3会自动转换为大类型并参与计算，所以最终是10.0/3.0
的计算结果
计算次序为先乘除后加减，如果优先级一致，则自动从左向右进行计算 10+2*5=20
/除法分母不能为0，否则出错
% 求余（取模） 10%3=1实际就是10除以3求余数
double k=10.12;
System.out.println(k%3);
输出：1.1199999999999992 应该返回值为1.12，由于浮点数不能精确存放，所以返回值是一个类似值
double d1=-10.12;
double res=d1%3;
System.out.println(res);
输出值为-1.1199999999999992 求余计算中符号位不参与计算
++和--是单目运算符
i++等价于i=i+1,i--等价于i=i-1
以++为例写法有2个：i++或者++i
i++是先获取i的值，然后再对i加1
int age=100;
System.out.println(age++);输出为100
System.out.println(age); 输出为101,因为上面进行加1
++i是先对i加1，然后再获取i的值
int age=100;
System.out.println(++age);输出101,先加1然后获取值
System.out.println(age); 输出101
</code></pre> 
<p><strong>考核题目</strong></p> 
<pre><code>public class Oper11 {
public static void main(String[] args) {
int k = 0;
int res = k++ + k++ + k;
System.out.println(res); //3
int m = 0;
res = ++m + m++ + m;
System.out.println(res); //4
}
}
</code></pre> 
<h4><a id="__486"></a>关系运算符 &gt;、&lt;、&gt;=、&lt;=、==、!=</h4> 
<p>用于判断两个数据之间的大小关系，计算结果为boolean，如果成立返回为true，否则为false</p> 
<pre><code>double d1=10;
System.out.println(d1&gt;3); 返回true
==和=的区别:
k=100;这是赋值运算符，意思是将=右边的计算结果储存在=左边的变量中
k==100这是比较计算符，意思是判断k是否值为100；如果是则返回true，否则false
!=意思是判断是否不等于，表示如果相等时返回false，否则返回true
k!=100不等于判定，如果k值为100则返回false，如果k值不是100则返回true
由于浮点数无法精确存放，所以判断k==1.0这个写法是错误的
正确写法： a-b的绝对值小于1e-6
Java提供了一个工具类Math，其中包含一个abs()的方法实现求绝对值
Math.abs(d1-1)&lt;1e-6 判断浮点类型的变量d1的值是否为1
</code></pre> 
<p>浮点数的比较</p> 
<pre><code>double res = 0;
for(int i=0;i&lt;10;i++)
res=res+0.1;
if(Math.abs(res-1)&lt;1e-6) //|res-1|判断是否小于10的-6次方
System.out.println("计算结果为1");
else
System.out.println("计算结果不为1");
</code></pre> 
<p>需求：<br> 用户输入身高和体重，计算对应的BMI指数值<br> BMI指数（英文为Body Mass Index，简称BMI），是用体重千克数除以身高米数的平方得出的数字，是国际上常用的衡量人体胖瘦程度以及是否健康的一个标准</p> 
<pre><code>按照我国标准，18.5-24.9kg/m^2为正常，24-27.9kg/m^2为超重，≥28kg/m^2为肥胖，而BMI＜
18.5kg/m^2为消瘦
</code></pre> 
<pre><code>需求：
用户输入身高和体重，计算对应的BMI指数值
BMI指数（英文为Body Mass Index，简称BMI），是用体重千克数除以身高米数的平方得出的数字，是
国际上常用的衡量人体胖瘦程度以及是否健康的一个标准
按照我国标准，18.5-24.9kg/m^2为正常，24-27.9kg/m^2为超重，≥28kg/m^2为肥胖，而BMI＜
18.5kg/m^2为消瘦
</code></pre> 
<pre><code>System.out.print("请输入身高:");
Scanner sc = new Scanner(System.in);
double height = sc.nextDouble();
System.out.println("请输入体重：");
double weight = sc.nextDouble();
//算法的问题 BMI指数
double bmi = weight / height / height;
System.out.println("您的bmi指数为:" + bmi);
</code></pre> 
<p>如何实现接受用户的键盘录入数据</p> 
<pre><code>//建立一个变量指向键盘录入
Scanner sc = new Scanner(System.in);
//通过这个变量读取用户键盘录入的数据，如果用户不输入则一直等待,如果输入的数据不是浮点数，则报错
double height=sc.nextDouble();
变量sc中是Java提供的具体实现方法nextDouble实现从键盘读取一个浮点数，如果要求用户输入int，则方
法为nextInt，。。。
</code></pre> 
<p>如何实现屏幕输出</p> 
<pre><code>System.out.println("具体需要输出的内容");输出内容后会自动换行，如果不需要换行，则使用方法
System.out.print("")
System.out.println("num:"+num);意思是输出【num：123】
System.out.println("num:num")意思是输出【num:num】
</code></pre>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/c84c3bba0f39641691bc824e34ab3011/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">JeecgBoot jeecg redis多数据源配置</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/3c81d2139d1d5e1117b9438780ddc6bf/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">ADC采样率（HZ）是什么怎么计算</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>