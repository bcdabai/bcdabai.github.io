<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>秋招面试知识点----机网，linux等其他篇 - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="秋招面试知识点----机网，linux等其他篇" />
<meta property="og:description" content="rpc 远程过程调用，主要是
1、服务消费者（client客户端）通过本地调用的方式调用服务
2、客户端存根（client stub）接收到调用请求后负责将方法、入参等信息
**序列化（**组装）成能够进行网络传输的消息体
3、客户端存根（client stub）找到远程的服务地址，并且将消息通过网络发送给服务端
4、服务端存根（server stub）收到消息后进行解码（反序列化操作）
5、服务端存根（server stub）根据解码结果调用本地的服务进行相关处理
6、本地服务执行具体业务逻辑并将处理结果返回给服务端存根（server stub）
7、服务端存根（server stub）将返回结果重新打包成消息（序列化）并通过网络发送至消费方
8、客户端存根（client stub）接收到消息，并进行解码（反序列化）
9、服务消费方得到最终结果
linux 查看端口占用
netstat -pan | grep 5623
然后查看进程那个程序的
ps -aux | grep pid
停止进程，-9强制停止
kill -9 pid
telnet ip 端口号
杀死进程
ps -ef | grep 进程名
kill pid
cat 由第一行开始显示文件内容tac 从最后一行开始显示，可以看出 tac 是 cat 的倒着写！nl 显示的时候，顺道输出行号！more 一页一页的显示文件内容less 与 more 类似，但是比 more 更好的是，他可以往前翻页！head 只看头几行tail 只看尾巴几行rz上传sz下载scp跨主机传文件 grep - A 5 ‘a’ 文件 #查找" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/8675fd740ae98b7ac4d960314a2ee1d8/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2020-12-10T22:51:31+08:00" />
<meta property="article:modified_time" content="2020-12-10T22:51:31+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">秋招面试知识点----机网，linux等其他篇</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <h2><a id="rpc_0"></a>rpc</h2> 
<p>远程过程调用，主要是</p> 
<p>1、服务消费者（client客户端）通过本地调用的方式调用服务</p> 
<p>2、客户端存根（client stub）接收到调用请求后负责将方法、入参等信息</p> 
<p>**序列化（**组装）成能够进行网络传输的消息体</p> 
<p>3、客户端存根（client stub）找到远程的服务地址，并且将消息通过网络发送给服务端</p> 
<p>4、服务端存根（server stub）收到消息后进行解码（<strong>反序列化操作</strong>）</p> 
<p>5、服务端存根（server stub）根据解码结果<strong>调用本地的服务</strong>进行相关处理</p> 
<p>6、本地服务执行具体业务逻辑并将处理结果返回给服务端存根（server stub）</p> 
<p>7、服务端存根（server stub）将返回结果重新打包成消息（序列化）并通过网络发送至消费方</p> 
<p>8、客户端存根（client stub）接收到消息，并进行解码（反序列化）</p> 
<p>9、服务消费方得到最终结果</p> 
<h2><a id="linux_26"></a>linux</h2> 
<p><strong>查看端口占用</strong></p> 
<p>netstat -pan | grep 5623</p> 
<p>然后查看进程那个程序的</p> 
<p>ps -aux | grep pid</p> 
<p>停止进程，-9强制停止</p> 
<p>kill -9 pid</p> 
<p>telnet ip 端口号</p> 
<p><strong>杀死进程</strong></p> 
<p>ps -ef | grep 进程名</p> 
<p>kill pid</p> 
<ul><li><strong>cat 由第一行开始显示文件内容</strong></li><li><strong>tac 从最后一行开始显示，可以看出 tac 是 cat 的倒着写！</strong></li><li><strong>nl 显示的时候，顺道输出行号！</strong></li><li><strong>more 一页一页的显示文件内容</strong></li><li><strong>less 与 more 类似，但是比 more 更好的是，他可以往前翻页！</strong></li><li><strong>head 只看头几行</strong></li><li><strong>tail 只看尾巴几行</strong></li><li><strong>rz上传</strong></li><li><strong>sz下载</strong></li><li><strong>scp跨主机传文件</strong></li></ul> 
<p>grep - A 5 ‘a’ 文件 #查找</p> 
<p>top 类似于Windows的任务管理器</p> 
<p>–help 一些参数解释</p> 
<p>man，有例子详细描述</p> 
<p><strong>CPU占用特别高</strong></p> 
<p><strong>top -H -p</strong> #找到占用CPU最高的</p> 
<p>发现九十以上</p> 
<p>ps -ef|grep 18092|grep -v grep</p> 
<p><strong>jstat -gc 18092 3000</strong> #利用上面的命令输出18092进程对应的GC情况，每隔3S采样一次</p> 
<p>新生代不变，老年代gc</p> 
<p><strong>jmap -heap 18092</strong></p> 
<p>老年带使用特高</p> 
<p>登录**</p> 
<p>默认端口号为22，ssh root@ip地址<br> 若改变了端口号，则为：ssh 登录名@IP地址 -p 端口号</p> 
<p><strong>删除九十行到一百；</strong></p> 
<p>转到第200行</p> 
<pre><code>200G
</code></pre> 
<pre><code>:9,.d 
</code></pre> 
<p><strong>linux查看文件20到30行的三种方法</strong></p> 
<p>head -30 ett.txt | tail -11</p> 
<p><strong>复制</strong></p> 
<p>cp 路径* 路径</p> 
<h2><a id="hashcode_110"></a>重写hashcode</h2> 
<p>1.用hashcode()<strong>提前校验</strong>，避免和原来数据逐次equals<br> 2.避免重写了equals而未重写hashcode方法，equals相同的，可是存的时候是两个，因为equals比的是<strong>特征</strong>，hashcode拿的是<strong>引用</strong>。**</p> 
<p>3.<strong>equals()相等的两个对象，hashcode()一定相等</strong>；因为equals()是true就认为是同一对象了，姑且认为引用什么的全不关，就是一样。<br> 4.反过来：<strong>hashcode()不等，equals()一定也不等</strong>； 就不是存在一个链表下的，肯定没关系<br> 5.<strong>hashcode()相等，equals()可能相等，也可能不等</strong>。hashcode相等，现在是还没装入呢，还要判地址为空，不空就逐个equals()当前地址对应的链表。</p> 
<h2><a id="_123"></a>快速排序</h2> 
<pre><code>public static int[] sort(int[] arr,int start,int end){
    int tmp=arr[start];
    int i=start;
    int j=end;
    while(i&lt;j){
        while ((i&lt;j) &amp;&amp; arr[j]&gt;tmp){
            j--;
        }
        while ((i&lt;j) &amp;&amp; (arr[i]&lt;tmp)){
            i++;
        }
        if(arr[i]==arr[j]&amp;&amp;(i&lt;j)){
            i++;
        }else{
            int temp=arr[i];
            arr[i]=arr[j];
            arr[j]=temp;
        }
    }
    if(j-1&gt;start) arr= sort(arr,start,j-1);
    if(i+1&lt;end) arr= sort(arr,i+1,end);
    return (arr);
}
</code></pre> 
<h2><a id="GETPOST_151"></a>GET和POST两种基本请求方法的区别</h2> 
<p>https://www.cnblogs.com/logsharing/p/8448446.html</p> 
<p><strong>最直观的区别</strong>就是GET把参数包含在URL中，不能用来传递敏感信息，POST通过request body传递参数</p> 
<p>HTTP给汽车运输设定了好几个服务类别，有GET, POST, PUT, DELETE等等，HTTP规定，当执行GET请求的时候，要给汽车贴上<strong>GET的标签</strong>（设置method为GET），而且要求把传送的数据放在<strong>车顶上</strong>（url中）以方便记录。如果是POST请求，就要在车上贴上<strong>POST的标签</strong>，并把货物放在<strong>车厢里</strong>。当然，你也可以在GET的时候往车厢内偷偷藏点货物，<strong>在request body安东西</strong>，但是这是很不光彩；也可以在POST的时候在车顶上也放一些数据**（url放）**，让人觉得傻乎乎的。HTTP只是个行为准则，而TCP才是GET和POST怎么实现的基本。</p> 
<p><strong>GET产生一个TCP数据包；POST产生两个TCP数据包。</strong></p> 
<p>长的说：</p> 
<p>对于GET方式的请求，浏览器会把http header和data一并发送出去，服务器响应200（返回数据）；</p> 
<p>而对于POST，浏览器先发送header，服务器响应100 continue，浏览器再发送data，服务器响应200 ok（返回数据）。</p> 
<p>也就是说，GET只需要汽车跑一趟就把货送到了，而POST得跑两趟，第一趟，先去和服务器打个招呼“嗨，我等下要送一批货来，你们打开门迎接我”，然后再回头把货送过去。</p> 
<p>因为POST需要两步，时间上消耗的要多一点，看起来GET比POST更有效。因此Yahoo团队有推荐用GET替换POST来优化网站性能。但这是一个坑！跳入需谨慎。为什么？</p> 
<p>\1. GET与POST都有自己的语义，不能</p> 
<p>随便混用。</p> 
<p>\2. 据研究，在网络环境好的情况下，发一次包的时间和发两次包的时间差别基本可以无视。而在网络环境差的情况下，两次包的TCP在验证数据包完整性上，有非常大的优点。</p> 
<p>\3. 并不是所有浏览器都会在POST中发送两次包，Firefox就只发送一次。</p> 
<h2><a id="httphttps_185"></a>http和https</h2> 
<p>HTTPS和HTTP的区别主要如下：</p> 
<p>1、https协议需要到ca申请证书，一般免费证书较少，因而需要一定费用。</p> 
<p>2、http是超文本传输协议，信息是明文传输，https则是具有安全性的ssl加密传输协议。</p> 
<p>3、http和https使用的是完全不同的连接方式，用的端口也不一样，前者是80，后者是443。</p> 
<p>4、http的连接很简单，是无状态的；HTTPS协议是由SSL+HTTP协议构建的可进行加密传输、身份认证的网络协议，比http协议安全。</p> 
<p>ssl</p> 
<p><strong>混合加密</strong>的方式实现信息的机密性，解决了窃听的风险。</p> 
<p><strong>摘要算法</strong>的方式来实现完整性，它能够为数据生成独一无二的「指纹」，指纹用于校验数据的完 整性，解决了篡改的风险。</p> 
<p><strong>服务器公钥放入到数字证书中</strong>，解决了冒充的风险。</p> 
<h2><a id="url_205"></a>url输入</h2> 
<p>1、输入网址<br> 2、DNS解析<br> 3、建立tcp连接<br> 4、客户端发送HTPP请求<br> 5、服务器处理请求　<br> 6、服务器响应请求<br> 7、浏览器展示HTML<br> 8、浏览器发送请求获取其他在HTML中的资源。</p> 
<p>https：</p> 
<p>1.客户使用https的URL访问Web服务器，要求与Web服务器建立SSL连接。</p> 
<p>2.Web服务器收到客户端请求后，会将网站的证书信息（证书中包含公钥）传送一份给客户端。</p> 
<ol start="3"><li>客户端的浏览器与Web服务器开始协商SSL连接的安全等级，也就是信息加密的等级。</li></ol> 
<p>4.客户端的浏览器根据双方同意的安全等级，建立会话密钥，然后利用网站的公钥将会话密钥加密，并传送给网站。</p> 
<p>5.Web服务器利用自己的私钥解密出会话密钥。</p> 
<p>6.Web服务器利用会话密钥加密与客户端之间的通信。</p> 
<h2><a id="Java_230"></a>学Java的理由</h2> 
<ul><li>简单易学，就是面向对象，</li><li>没有指针，不会内存泄漏</li><li>jvm跨平台</li><li>社区生态好，有很多集成框架，简化代码开发</li></ul> 
<h2><a id="_237"></a>反射速度</h2> 
<ol><li> <p>通过new对象实现反射机制（ 对象.getClass() ）</p> </li><li> <p>通过路径实现反射机制（ Class.forName(“包名.类名”) ）</p> </li><li> <p>通过类名实现反射机制 （ 类名.Class ）</p> </li></ol> 
<ul><li>不做安全检查，setAccess（true）</li><li>class.forname()耗时不要循环写，要在外面定义</li></ul> 
<h2><a id="_248"></a>布隆过滤器</h2> 
<p><strong>添加元素</strong></p> 
<ul><li>将要添加的元素给k个哈希函数</li><li>得到对应于位数组上的k个位置</li><li>将这k个位置设为1</li></ul> 
<p><strong>查询元素</strong></p> 
<ul><li>将要查询的元素给k个哈希函数</li><li>得到对应于位数组上的k个位置</li><li>如果k个位置有一个为0，则肯定不在集合中</li><li>如果k个位置全部为1，则可能在集合中</li></ul> 
<h2><a id="TCP__UDP__263"></a>TCP 和 UDP 区别：</h2> 
<ul><li>1.连接 TCP 是<strong>面向连接</strong>的传输层协议，传输数据前先要建立连接。 UDP 是<strong>不需要连接</strong>，即刻传输数据。</li><li>服务对象 TCP 是<strong>一对一</strong>的两点服务，即一条连接只有两个端点。 UDP 支持<strong>一对一、一对多、多对多</strong>的交互通信</li><li><strong>3.可靠性</strong> TCP 是可靠交付数据的，数据可以无差错、不丢失、不重复、按需到达。 UDP 是尽最大努力交付，不保证可靠交付数据。</li><li>拥塞控制、流量控制 TCP 有拥塞控制和流量控制机制，保证数据传输的安全性。 UDP 则没有，即使网络非常拥堵了，也不会影响 UDP 的发送速率。</li><li>首部开销 TCP 首部长度较长，会有一定的开销，首部在没有使用「选项」字段时是 20 个字节，如果使 用了「选项」字段则会变长的。 UDP 首部只有 8 个字节，并且是固定不变的，开销较小</li><li>传输方式 TCP 是<strong>流式传输</strong>，没有边界，但保证顺序和可靠。 UDP 是<strong>一个包一个包</strong>的发送，是有边界的，但可能会丢包和乱序。</li><li>分片不同 TCP 的数据大小如果大于 MSS 大小，则会在传输层进行分片，目标主机收到后，也同样在传输 层组装 TCP 数据包，如果中途丢失了一个分片，只需要传输丢失的这个分片。 UDP 的数据大小如果大于 MTU 大小，则会在 IP 层进行分片，目标主机收到后，在 IP 层组装完 数据，接着再传给传输层，但是如果中途丢了一个分片，则就需要重传所有的数据包，这样传输 效率非常差，所以通常 UDP 的报文应该小于 MTU。</li></ul> 
<h2><a id="_273"></a>三次握手</h2> 
<p><img src="https://images2.imgbox.com/29/2c/0mtM74CJ_o.png" alt="在这里插入图片描述"></p> 
<h2><a id="_277"></a>四次挥手</h2> 
<p><img src="https://images2.imgbox.com/54/06/jR96AxP2_o.png" alt="在这里插入图片描述"></p> 
<p><strong>为啥四次挥手</strong></p> 
<p>建立连接时，被动方服务器端结束CLOSED阶段进入“握手”阶段并不需要任何准备，可以直接返回SYN和ACK报文，开始建立连接。</p> 
<p>释放连接时，被动方服务器，突然收到主动方客户端释放连接的请求时并不能立即释放连接，<strong>因为还有必要的数据需要处理，就是客户端不能发信息，服务端能发信息，所以服务器先返回ACK确认收到报文</strong>，经过CLOSE-WAIT阶段准备好释放连接之后，才能返回FIN释放连接报文。</p> 
<p><strong>为啥timewait 2msl 60s</strong></p> 
<ul><li> <p>防止具有相同「四元组」的「旧」数据包被收到；</p> <p>原来有发的数据延迟了</p> </li><li> <p>保证「被动关闭连接」的一方能被正确的关闭，即保证最后的 ACK 能让被动关闭方接收，从而帮 助其正常关闭；</p> 
  <ul><li>就是服务端没有正确关闭</li></ul> </li></ul> 
<h2><a id="_297"></a>拥塞控制(正在完善…)</h2> 
<p>前面的流量控制是避免「发送方」的数据填满「接收方」的缓存，但是并不知道网络的中发生了什么。</p> 
<p>一般来说，计算机网络都处在一个共享的环境。因此也有可能会因为其他主机之间的通信使得网络拥 堵。 <strong>在网络出现拥堵时</strong>，<strong>如果继续发送大量数据包</strong>，可能会导致<strong>数据包时延、丢失等</strong>，这时 TCP 就会重传 数据，但是<strong>一重传就会导致网络的负担</strong>更重，于是会导致<strong>更大的延迟以及更多的丢包</strong>，这个情况就会进 入恶性循环被不断地放大…</p> 
<p><strong>步骤：</strong></p> 
<p><strong>慢启动 拥塞避免 拥塞发生 快速恢复</strong></p> 
<p><strong>满启动</strong>就是窗口两倍的增长，</p> 
<p><strong>拥塞避免</strong>就是一个一个长</p> 
<p>当网络出现拥塞，也就是会发生数据包重传，重传机制主要有两种： 超时重传 快速重传</p> 
<p><strong>超时重传：<strong>就</strong>重新开始慢启动</strong>，慢启动是会突然减少数据流的。这真是一旦「超时重传」，马上回到解放 前。但是这种方式太激进了，反应也很强烈，会造成网络卡顿。</p> 
<p><strong>快速重传</strong>：</p> 
<p>拥塞窗口 cwnd = ssthresh + 3 （ 3 的意思是确认有 3 个数据包被收到了）；重传丢失的数据包；</p> 
<p><strong>快速恢复</strong>：</p> 
<p>cwnd = cwnd/2 ，<strong>也就是设置为原来的一半</strong>; ssthresh = cwnd ;</p> 
<p><strong>快速重传和快速恢复算法一般同时使用</strong>，快速恢复算法是认为，<strong>你还能收到 3 个重复 ACK 说明网络也 不那么糟糕</strong>，所以没有必要像 RTO 超时那么强烈。</p> 
<p>如果再收到重复的 ACK，那么 cwnd 增加 1；</p> 
<p>如果收到新数据的 ACK 后，把 cwnd 设置为第一步中的 ssthresh 的值，原因是该 ACK 确认了新 的数据，说明从 duplicated ACK 时的数据都已收到，该恢复过程已经结束，可以回到恢复之前的 状态了，也即再次进入拥塞避免状态；</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/4ffe9c04060b076797cb5c473aa283c7/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">神经网络 python 多类别_Keras入门（一）搭建深度神经网络（DNN）解决多分类问题...</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/9a414a6be67f442cfe2067baf103a966/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">python脚本开头怎么写_浅谈Python脚本开头及导包注释自动添加方法</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>