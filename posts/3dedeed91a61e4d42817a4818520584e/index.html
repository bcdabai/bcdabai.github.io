<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Java基础 : CompletableFuture② 代码浅析 - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Java基础 : CompletableFuture② 代码浅析" />
<meta property="og:description" content="文章目录 一、前言1. 基础介绍1.1 基础属性1.2 CAS 操作1.3 Completion 二、代码分析1. CompletableFuture#supplyAsync1.1 CompletableFuture.AsyncSupply1.2 CompletableFuture#postComplete1.2.1 代码分析1.2.2 举例说明1.2.3 总结 2. CompletableFuture#thenApply2.1 CompletableFuture#uniApply2.2 CompletableFuture#push2.3 CompletableFuture.UniApply#tryFire2.3.1 CompletableFuture#postFire 3. CompletableFuture#join3.1 CompletableFuture#waitingGet3.1.1 CompletableFuture.Signaller 的作用 一、前言 在Java基础：CompletableFuture① 基础使用中我们介绍了CompletableFuture 的基础使用，本文来对其代码进行分析，由于个人能力所限并且文章编写时间太长（写了三四个月总被各种事情打断 ），文中所述可能存在理解不到位或者理解错误的情况，如有感谢指正。
1. 基础介绍 CompletableFuture 代表一个执行阶段，一个阶段的执行可能是被单个阶段的完成触发，也可能是由多个阶段一起触发。
以下面的代码为例（为例方便讲解，这里把代码写的比较复杂）
public static void main(String[] args) { final Supplier&lt;String&gt; startSupplier = () -&gt; &#34;start&#34;; final Function&lt;String, String&gt; thenApplyFunction = s -&gt; s &#43; &#34; -&gt; thenApply&#34;; final CompletableFuture&lt;String&gt; supplyAsync = CompletableFuture.supplyAsync(startSupplier); final CompletableFuture&lt;String&gt; thenApply = supplyAsync." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/3dedeed91a61e4d42817a4818520584e/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-07-16T10:58:42+08:00" />
<meta property="article:modified_time" content="2022-07-16T10:58:42+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Java基础 : CompletableFuture② 代码浅析</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p></p> 
<div class="toc"> 
 <h4>文章目录</h4> 
 <ul><li><a href="#_2" rel="nofollow">一、前言</a></li><li><ul><li><a href="#1__13" rel="nofollow">1. 基础介绍</a></li><li><ul><li><a href="#11__42" rel="nofollow">1.1 基础属性</a></li><li><a href="#12_CAS__64" rel="nofollow">1.2 CAS 操作</a></li><li><a href="#13_Completion_137" rel="nofollow">1.3 Completion</a></li></ul> 
  </li></ul> 
  </li><li><a href="#_248" rel="nofollow">二、代码分析</a></li><li><ul><li><a href="#1_CompletableFuturesupplyAsync_272" rel="nofollow">1. CompletableFuture#supplyAsync</a></li><li><ul><li><a href="#11_CompletableFutureAsyncSupply_305" rel="nofollow">1.1 CompletableFuture.AsyncSupply</a></li><li><a href="#12_CompletableFuturepostComplete_386" rel="nofollow">1.2 CompletableFuture#postComplete</a></li><li><ul><li><a href="#121__395" rel="nofollow">1.2.1 代码分析</a></li><li><a href="#122__494" rel="nofollow">1.2.2 举例说明</a></li><li><a href="#123__558" rel="nofollow">1.2.3 总结</a></li></ul> 
   </li></ul> 
   </li><li><a href="#2_CompletableFuturethenApply_566" rel="nofollow">2. CompletableFuture#thenApply</a></li><li><ul><li><a href="#21_CompletableFutureuniApply_662" rel="nofollow">2.1 CompletableFuture#uniApply</a></li><li><a href="#22_CompletableFuturepush_763" rel="nofollow">2.2 CompletableFuture#push</a></li><li><a href="#23_CompletableFutureUniApplytryFire_793" rel="nofollow">2.3 CompletableFuture.UniApply#tryFire</a></li><li><ul><li><a href="#231_CompletableFuturepostFire_856" rel="nofollow">2.3.1 CompletableFuture#postFire</a></li></ul> 
   </li></ul> 
   </li><li><a href="#3_CompletableFuturejoin_967" rel="nofollow">3. CompletableFuture#join</a></li><li><ul><li><a href="#31__CompletableFuturewaitingGet_1004" rel="nofollow">3.1 CompletableFuture#waitingGet</a></li><li><ul><li><a href="#311_CompletableFutureSignaller___1167" rel="nofollow">3.1.1 CompletableFuture.Signaller 的作用</a></li></ul> 
   </li></ul> 
  </li></ul> 
 </li></ul> 
</div> 
<p></p> 
<h2><a id="_2"></a>一、前言</h2> 
<p>在<a href="https://blog.csdn.net/qq_36882793/article/details/125256302">Java基础：CompletableFuture① 基础使用</a>中我们介绍了CompletableFuture 的基础使用，本文来对其代码进行分析，由于个人能力所限并且文章编写时间太长（<s>写了三四个月总被各种事情打断</s> ），文中所述可能存在理解不到位或者理解错误的情况，如有感谢指正。</p> 
<h3><a id="1__13"></a>1. 基础介绍</h3> 
<p>CompletableFuture 代表一个执行阶段，一个阶段的执行可能是被单个阶段的完成触发，也可能是由多个阶段一起触发。</p> 
<hr> 
<p>以下面的代码为例（为例方便讲解，这里把代码写的比较复杂）</p> 
<pre><code class="prism language-java">    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token keyword">final</span> <span class="token class-name">Supplier</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">&gt;</span></span> startSupplier <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token string">"start"</span><span class="token punctuation">;</span>
        <span class="token keyword">final</span> <span class="token class-name">Function</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">,</span> <span class="token class-name">String</span><span class="token punctuation">&gt;</span></span> thenApplyFunction <span class="token operator">=</span> s <span class="token operator">-&gt;</span> s <span class="token operator">+</span> <span class="token string">" -&gt; thenApply"</span><span class="token punctuation">;</span>

        <span class="token keyword">final</span> <span class="token class-name">CompletableFuture</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">&gt;</span></span> supplyAsync <span class="token operator">=</span> <span class="token class-name">CompletableFuture</span><span class="token punctuation">.</span><span class="token function">supplyAsync</span><span class="token punctuation">(</span>startSupplier<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">final</span> <span class="token class-name">CompletableFuture</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">&gt;</span></span> thenApply <span class="token operator">=</span> supplyAsync<span class="token punctuation">.</span><span class="token function">thenApply</span><span class="token punctuation">(</span>thenApplyFunction<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">// 输出 ： start -&gt; thenApply</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>thenApply<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
</code></pre> 
<p>这段代码的实现很简单，如下：</p> 
<ol><li>提交一个异步任务 startSupplier, 并开始返回一个 CompletableFuture</li><li>提交一个同步任务 thenApplyFunction。（startSupplier 是异步执行不会阻塞主线程） 
  <ol><li>此时如果 startSupplier 已经执行结束则会直接执行 thenApplyFunction。</li><li>此时如果 startSupplier 尚未执行结束则会将 thenApplyFunction 包装成 CompletableFuture#Completion 保存到 supplyAsync 的堆栈中（CompletableFuture#stack）. 当 supplyAsync 执行结束后会执行 thenApplyFunction。（需要注意堆栈的结构是先入后出）</li></ol> </li><li>当 startSupplier 执行结束后将执行结果作为 thenApplyFunction 的入参执行。</li></ol> 
<hr> 
<p>我们下面来介绍一些 CompletableFuture 功能实现的一些关键类、属性， 方便我们下面展开代码分析时的理解。</p> 
<h4><a id="11__42"></a>1.1 基础属性</h4> 
<p>想要知道 CompletableFuture 的具体实现原理，那么有两个属性我们绕不过去：</p> 
<pre><code class="prism language-java">	<span class="token comment">// 保存当前 CompletableFuture  的执行结果。CompletableFuture 通过 result 是否为空 判断当前 CompletableFuture 的操作有没有完成。</span>
	<span class="token comment">// 当 执行结果是 null 或者异常时，CompletableFuture 会将其包装成 AltResult 类型。</span>
    <span class="token keyword">volatile</span> <span class="token class-name">Object</span> result<span class="token punctuation">;</span>       <span class="token comment">// Either the result or boxed AltResult</span>
    <span class="token comment">// Completion 类型（Completion 是 CompletableFuture 的内部类），是当前 CompletableFuture 完成后要执行的操作堆栈。</span>
    <span class="token keyword">volatile</span> <span class="token class-name">Completion</span> stack<span class="token punctuation">;</span>    <span class="token comment">// Top of Treiber stack of dependent actions</span>
</code></pre> 
<p>除此之外 CompletableFuture 还存在一些枚举用来记录操作模式，如下：</p> 
<pre><code class="prism language-java">	<span class="token comment">// 同步模式 : 以同步模式来执行操作，表明调用线程来执行具体操作</span>
    <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> SYNC   <span class="token operator">=</span>  <span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token comment">// 异步模式 : 以异步模式来执行操作，表明当前操作已经交由线程池执行</span>
    <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> ASYNC  <span class="token operator">=</span>  <span class="token number">1</span><span class="token punctuation">;</span>
    <span class="token comment">// 嵌套模式 ：以嵌套模式来执行操作，将堆栈中的操作执行完。</span>
    <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> NESTED <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>
</code></pre> 
<h4><a id="12_CAS__64"></a>1.2 CAS 操作</h4> 
<p>CompletableFuture 为了保证操作的原子性，对于其中的属性都是通过 CAS 操作完成的。对于 CompletableFuture#result 和 CompletableFuture#stack，以及对 CompletableFuture.Completion#next 属性进行 CAS 操作。如下：</p> 
<pre><code class="prism language-java">	<span class="token comment">// CAS 准备操作</span>
    <span class="token comment">// Unsafe mechanics</span>
    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token class-name"><span class="token namespace">sun<span class="token punctuation">.</span>misc<span class="token punctuation">.</span></span>Unsafe</span> UNSAFE<span class="token punctuation">;</span>
    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">long</span> RESULT<span class="token punctuation">;</span>
    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">long</span> STACK<span class="token punctuation">;</span>
    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">long</span> NEXT<span class="token punctuation">;</span>
    <span class="token keyword">static</span> <span class="token punctuation">{<!-- --></span>
        <span class="token keyword">try</span> <span class="token punctuation">{<!-- --></span>
            <span class="token keyword">final</span> <span class="token class-name"><span class="token namespace">sun<span class="token punctuation">.</span>misc<span class="token punctuation">.</span></span>Unsafe</span> u<span class="token punctuation">;</span>
            UNSAFE <span class="token operator">=</span> u <span class="token operator">=</span> <span class="token class-name"><span class="token namespace">sun<span class="token punctuation">.</span>misc<span class="token punctuation">.</span></span>Unsafe</span><span class="token punctuation">.</span><span class="token function">getUnsafe</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token class-name">Class</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span><span class="token punctuation">&gt;</span></span> k <span class="token operator">=</span> <span class="token class-name">CompletableFuture</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">;</span>
            <span class="token comment">// 获取 CompletableFuture#result 地址</span>
            RESULT <span class="token operator">=</span> u<span class="token punctuation">.</span><span class="token function">objectFieldOffset</span><span class="token punctuation">(</span>k<span class="token punctuation">.</span><span class="token function">getDeclaredField</span><span class="token punctuation">(</span><span class="token string">"result"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token comment">// 获取 CompletableFuture#stack地址</span>
            STACK <span class="token operator">=</span> u<span class="token punctuation">.</span><span class="token function">objectFieldOffset</span><span class="token punctuation">(</span>k<span class="token punctuation">.</span><span class="token function">getDeclaredField</span><span class="token punctuation">(</span><span class="token string">"stack"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token comment">// 获取 Completion#next地址</span>
            NEXT <span class="token operator">=</span> u<span class="token punctuation">.</span>objectFieldOffset
                <span class="token punctuation">(</span><span class="token class-name">Completion</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">.</span><span class="token function">getDeclaredField</span><span class="token punctuation">(</span><span class="token string">"next"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Exception</span> x<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
            <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">Error</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>


    <span class="token comment">/** Completes with a non-exceptional result, unless already completed. */</span>
    <span class="token comment">// 通过 CAS 将 当前CompletableFuture 的result 属性设置为 t</span>
    <span class="token keyword">final</span> <span class="token keyword">boolean</span> <span class="token function">completeValue</span><span class="token punctuation">(</span><span class="token class-name">T</span> t<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token keyword">return</span> UNSAFE<span class="token punctuation">.</span><span class="token function">compareAndSwapObject</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> RESULT<span class="token punctuation">,</span> <span class="token keyword">null</span><span class="token punctuation">,</span>
                                           <span class="token punctuation">(</span>t <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token operator">?</span> NIL <span class="token operator">:</span> t<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token comment">/** Completes with an exceptional result, unless already completed. */</span>
    <span class="token comment">// 通过 CAS 将 当前CompletableFuture 的result 属性设置为 AltResult</span>
    <span class="token keyword">final</span> <span class="token keyword">boolean</span> <span class="token function">completeThrowable</span><span class="token punctuation">(</span><span class="token class-name">Throwable</span> x<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token keyword">return</span> UNSAFE<span class="token punctuation">.</span><span class="token function">compareAndSwapObject</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> RESULT<span class="token punctuation">,</span> <span class="token keyword">null</span><span class="token punctuation">,</span>
                                           <span class="token function">encodeThrowable</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    
    <span class="token comment">/**
     * Returns the encoding of the given (non-null) exception as a
     * wrapped CompletionException unless it is one already.
     */</span>
     <span class="token comment">// 对异常进行包装</span>
    <span class="token keyword">static</span> <span class="token class-name">AltResult</span> <span class="token function">encodeThrowable</span><span class="token punctuation">(</span><span class="token class-name">Throwable</span> x<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">AltResult</span><span class="token punctuation">(</span><span class="token punctuation">(</span>x <span class="token keyword">instanceof</span> <span class="token class-name">CompletionException</span><span class="token punctuation">)</span> <span class="token operator">?</span> x <span class="token operator">:</span>
                             <span class="token keyword">new</span> <span class="token class-name">CompletionException</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

	<span class="token comment">// 通过 CAS 更新 stack 的值，从 cmp 更新为 val</span>
    <span class="token keyword">final</span> <span class="token keyword">boolean</span> <span class="token function">casStack</span><span class="token punctuation">(</span><span class="token class-name">Completion</span> cmp<span class="token punctuation">,</span> <span class="token class-name">Completion</span> val<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token keyword">return</span> UNSAFE<span class="token punctuation">.</span><span class="token function">compareAndSwapObject</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> STACK<span class="token punctuation">,</span> cmp<span class="token punctuation">,</span> val<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token comment">/** Returns true if successfully pushed c onto stack. */</span>
    <span class="token comment">// 将 c 压入堆栈 </span>
    <span class="token keyword">final</span> <span class="token keyword">boolean</span> <span class="token function">tryPushStack</span><span class="token punctuation">(</span><span class="token class-name">Completion</span> c<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token class-name">Completion</span> h <span class="token operator">=</span> stack<span class="token punctuation">;</span>
        <span class="token function">lazySetNext</span><span class="token punctuation">(</span>c<span class="token punctuation">,</span> h<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">// 将 c 压入 栈中，替换 h</span>
        <span class="token keyword">return</span> UNSAFE<span class="token punctuation">.</span><span class="token function">compareAndSwapObject</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> STACK<span class="token punctuation">,</span> h<span class="token punctuation">,</span> c<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
	<span class="token comment">// 赋值 c.next = next</span>
    <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">lazySetNext</span><span class="token punctuation">(</span><span class="token class-name">Completion</span> c<span class="token punctuation">,</span> <span class="token class-name">Completion</span> next<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        UNSAFE<span class="token punctuation">.</span><span class="token function">putOrderedObject</span><span class="token punctuation">(</span>c<span class="token punctuation">,</span> NEXT<span class="token punctuation">,</span> next<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
</code></pre> 
<h4><a id="13_Completion_137"></a>1.3 Completion</h4> 
<p>CompletableFuture 完成操作依赖的关键类即 Completion。Completion 是 CompletableFuture 的内部类，也是执行具体操作的类，每个操作方法都具有一个实现类且都是 CompletableFuture 内部类，如 BiAccept、BiApply、UniAccept等。</p> 
<hr> 
<p>对于一个 CompletableFuture 来说，CompletableFuture 内部的 Completion 是 当前环节要进行的操作。当 CompletableFuture 环节完成时（CompletableFuture#result !=null）并且后续操作不为空（Completion != null ）时会对 CompletableFuture#result 进行对应的 Completion 处理。</p> 
<hr> 
<p>这里我们直接来看 Completion 的实现， 其继承结构如下图：<br> <img src="https://images2.imgbox.com/cd/ee/nTScEA6F_o.png" alt="在这里插入图片描述"></p> 
<p>可以看到 Completion 实现了 Runnable 接口，同时继承了 ForkJoinTask，那么对于 Runnable#run 和 ForkJoinTask#exec 方法也是有具体的实现的，如下：</p> 
<pre><code class="prism language-java">    <span class="token keyword">abstract</span> <span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">Completion</span> <span class="token keyword">extends</span> <span class="token class-name">ForkJoinTask</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Void</span><span class="token punctuation">&gt;</span></span>
        <span class="token keyword">implements</span> <span class="token class-name">Runnable</span><span class="token punctuation">,</span> <span class="token class-name">AsynchronousCompletionTask</span> <span class="token punctuation">{<!-- --></span>
        <span class="token comment">// 记录下一步需要执行的操作</span>
        <span class="token keyword">volatile</span> <span class="token class-name">Completion</span> next<span class="token punctuation">;</span>      <span class="token comment">// Treiber stack link</span>

        <span class="token comment">// 如果触发，则执行完成操作，返回可能需要传播的依赖项（如果存在）。</span>
        <span class="token keyword">abstract</span> <span class="token class-name">CompletableFuture</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span><span class="token punctuation">&gt;</span></span> <span class="token function">tryFire</span><span class="token punctuation">(</span><span class="token keyword">int</span> mode<span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token comment">/** Returns true if possibly still triggerable. Used by cleanStack. */</span>
        <span class="token comment">// 如果可能仍然可以触发，则返回 true。由 cleanStack 使用</span>
        <span class="token keyword">abstract</span> <span class="token keyword">boolean</span> <span class="token function">isLive</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token comment">// 异步模式执行 tryFire ，这里使用了final 修饰，表明该方法是终态的</span>
        <span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span>                <span class="token punctuation">{<!-- --></span> <span class="token function">tryFire</span><span class="token punctuation">(</span>ASYNC<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>
        <span class="token comment">// 异步模式执行 tryFire ，这里使用了final 修饰，表明该方法是终态的</span>
        <span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">boolean</span> <span class="token function">exec</span><span class="token punctuation">(</span><span class="token punctuation">)</span>            <span class="token punctuation">{<!-- --></span> <span class="token function">tryFire</span><span class="token punctuation">(</span>ASYNC<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>
        <span class="token comment">// 获取和设置结果值</span>
        <span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token class-name">Void</span> <span class="token function">getRawResult</span><span class="token punctuation">(</span><span class="token punctuation">)</span>       <span class="token punctuation">{<!-- --></span> <span class="token keyword">return</span> <span class="token keyword">null</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>
        <span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">void</span> <span class="token function">setRawResult</span><span class="token punctuation">(</span><span class="token class-name">Void</span> v<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span><span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
</code></pre> 
<p>下面我们来对上面的方法做进一步的解释：</p> 
<ul><li> <p><strong>Completion#next</strong> ： Completion 具有一个属性值 <code>volatile Completion next</code>，由于 Completion 是堆栈结构，所以自然有一个 next 属性指向下一步的操作，如果有没有下一步操作，则为空。</p> </li><li> <p><strong>Completion#tryFire</strong> ：尝试完成当前操作，可能返回新的环节（CompletableFuture），根据调用场景的不同，分为同步、异步和嵌套模式执行， 同步调用并不代表一定是调用线程来执行操作，当发现操作需要异步执行时则会将操作丢入线程池中执行，线程池中会以异步模式执行操作。嵌套模式则会将当前环节的所有操作堆栈执行结束（清栈操作）。</p> </li><li> <p><strong>Completion#isLive</strong> ：代表当前Completion是否存活，在CompletableFuture#cleanStack 中会判断 Completion 是否存活，并清除死亡的 Completion。</p> </li><li> <p><strong>Completion#run 和 Completion#exec</strong> ： 实现都是直接调用 CompletableFuture.Completion#tryFire方法，参数为 CompletableFuture#ASYNC， 代表当前方法是异步执行。</p> </li></ul> 
<hr> 
<p>Completion 有三个直接子类，分别为 CoCompletion、Signaller、UniCompletion。</p> 
<ul><li> <p><strong>CoCompletion</strong> ：作为 BiCompletion 的静态代理，其内部并没有做什么逻辑，仅仅加了判空操作，具体处理都委托给了 BiCompletion 完成。</p> </li><li> <p><strong>Signaller</strong> ：作为一个信号量的存在，在CompletableFuture#join、CompletableFuture#get 方法中完成记录和释放等待线程。此类实现 ManagedBlocker 以避免在 ForkJoinPools 中堆积的阻塞操作时出现饥饿。</p> </li><li> <p><strong>UniCompletion</strong> ：我们使用的各种操作的父类，在Completion 基础上做了一定的扩展，是本文需要介绍的重点，如下：</p> <pre><code class="prism language-java">    <span class="token comment">/** A Completion with a source, dependent, and executor. */</span>
    <span class="token annotation punctuation">@SuppressWarnings</span><span class="token punctuation">(</span><span class="token string">"serial"</span><span class="token punctuation">)</span>
    <span class="token keyword">abstract</span> <span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">UniCompletion</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span> <span class="token keyword">extends</span> <span class="token class-name">Completion</span> <span class="token punctuation">{<!-- --></span>
        <span class="token class-name">Executor</span> executor<span class="token punctuation">;</span>                 <span class="token comment">// executor to use (null if none)</span>
        <span class="token class-name">CompletableFuture</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span> dep<span class="token punctuation">;</span>          <span class="token comment">// the dependent to complete</span>
        <span class="token class-name">CompletableFuture</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">&gt;</span></span> src<span class="token punctuation">;</span>          <span class="token comment">// source for action</span>

        <span class="token class-name">UniCompletion</span><span class="token punctuation">(</span><span class="token class-name">Executor</span> executor<span class="token punctuation">,</span> <span class="token class-name">CompletableFuture</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span> dep<span class="token punctuation">,</span>
                      <span class="token class-name">CompletableFuture</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">&gt;</span></span> src<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
            <span class="token keyword">this</span><span class="token punctuation">.</span>executor <span class="token operator">=</span> executor<span class="token punctuation">;</span> <span class="token keyword">this</span><span class="token punctuation">.</span>dep <span class="token operator">=</span> dep<span class="token punctuation">;</span> <span class="token keyword">this</span><span class="token punctuation">.</span>src <span class="token operator">=</span> src<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>

         <span class="token comment">// 如果可以运行操作，则返回 true。仅在已知可触发时调用。使用 FJ 标记位来确保只有一个线程声明所有权。如果是异步的，则作为任务启动——稍后调用 tryFire 将运行操作。</span>
        <span class="token keyword">final</span> <span class="token keyword">boolean</span> <span class="token function">claim</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
            <span class="token class-name">Executor</span> e <span class="token operator">=</span> executor<span class="token punctuation">;</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">compareAndSetForkJoinTaskTag</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">short</span><span class="token punctuation">)</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token keyword">short</span><span class="token punctuation">)</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
                <span class="token keyword">if</span> <span class="token punctuation">(</span>e <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span>
                    <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
                executor <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span> <span class="token comment">// disable</span>
                e<span class="token punctuation">.</span><span class="token function">execute</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
            <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>

        <span class="token keyword">final</span> <span class="token keyword">boolean</span> <span class="token function">isLive</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span> <span class="token keyword">return</span> dep <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
</code></pre> <p>可以看到相较于 Completion 类，UniCompletion 多了一些参数，如下：</p> 
  <ul><li><strong>UniCompletion#executor</strong> ： 执行该操作所使用的线程池，如果没有则为空，我们可以通过重载方法指定线程池，如果没指定则默认使用 ForkJoinPool 作为线程池。</li><li><strong>UniCompletion#dep</strong> ：当前操作依赖的 CompletableFuture，即当前操作完成后会将结果写入到 dep.result 中，代表 dep 环节执行完成。</li><li><strong>UniCompletion#src</strong> ：引发当前操作的源 CompletableFuture，即 UniCompletion#dep 的前置阶段。当 src.result 不为空（即 src 环节执行结束）时才会执行当前操作。</li><li><strong>UniCompletion#claim</strong> ：当前操作的声明，通过 CAS 保证当前操作的原子性执行。只有当操作是由当前线程执行时才会 返回true。</li><li><strong>UniCompletion#isLive</strong> ：当前操作是否存活，判断依据是 dep 是否为 null （个别子类有重写）。UniCompletion 的子类在完成操作后会将 dep 置空，因此 UniCompletion#isLive 可以通过dep是否为空判断当前操作是否还存活（未执行）。</li></ul> </li></ul> 
<hr> 
<p>额外需要注意的是 ：UniCompletion 还有一个 重要的子类 BiCompletion，如下，与UniCompletion 相比，BiCompletion 多了一个来源。BiCompletion 是用于 CompletableFuture#applyToEither、CompletableFuture#runAfterBothAsync 这种函数聚合的操作，这种操作一般需要判断两个 CompletableFuture 的信息才能执行， 因此这里BiCompletion 相较于UniCompletion 多了一个第二来源。如下：</p> 
<pre><code class="prism language-java">    <span class="token comment">/** A Completion for an action with two sources */</span>
    <span class="token annotation punctuation">@SuppressWarnings</span><span class="token punctuation">(</span><span class="token string">"serial"</span><span class="token punctuation">)</span>
    <span class="token keyword">abstract</span> <span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">BiCompletion</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">,</span><span class="token class-name">U</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span> <span class="token keyword">extends</span> <span class="token class-name">UniCompletion</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span> <span class="token punctuation">{<!-- --></span>
        <span class="token class-name">CompletableFuture</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">U</span><span class="token punctuation">&gt;</span></span> snd<span class="token punctuation">;</span> <span class="token comment">// second source for action</span>
        <span class="token class-name">BiCompletion</span><span class="token punctuation">(</span><span class="token class-name">Executor</span> executor<span class="token punctuation">,</span> <span class="token class-name">CompletableFuture</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span> dep<span class="token punctuation">,</span>
                     <span class="token class-name">CompletableFuture</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">&gt;</span></span> src<span class="token punctuation">,</span> <span class="token class-name">CompletableFuture</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">U</span><span class="token punctuation">&gt;</span></span> snd<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
            <span class="token keyword">super</span><span class="token punctuation">(</span>executor<span class="token punctuation">,</span> dep<span class="token punctuation">,</span> src<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token keyword">this</span><span class="token punctuation">.</span>snd <span class="token operator">=</span> snd<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
</code></pre> 
<hr> 
<h2><a id="_248"></a>二、代码分析</h2> 
<p>下面我们开始对 CompletableFuture 的代码进行分析，以下面的例子为例，我们来看具体的实现：</p> 
<pre><code class="prism language-java">    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token keyword">final</span> <span class="token class-name">Supplier</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">&gt;</span></span> startSupplier <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token string">"start"</span><span class="token punctuation">;</span>
        <span class="token keyword">final</span> <span class="token class-name">Function</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">,</span> <span class="token class-name">String</span><span class="token punctuation">&gt;</span></span> thenApplyFunction <span class="token operator">=</span> s <span class="token operator">-&gt;</span> s <span class="token operator">+</span> <span class="token string">" -&gt; thenApply"</span><span class="token punctuation">;</span>

        <span class="token keyword">final</span> <span class="token class-name">CompletableFuture</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">&gt;</span></span> supplyAsync <span class="token operator">=</span> <span class="token class-name">CompletableFuture</span><span class="token punctuation">.</span><span class="token function">supplyAsync</span><span class="token punctuation">(</span>startSupplier<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">final</span> <span class="token class-name">CompletableFuture</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">&gt;</span></span> thenApply <span class="token operator">=</span> supplyAsync<span class="token punctuation">.</span><span class="token function">thenApply</span><span class="token punctuation">(</span>thenApplyFunction<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">// 输出 ： start -&gt; thenApply</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>thenApply<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
</code></pre> 
<p>这里很显然有三个方法需要我们来看：</p> 
<ol><li><strong>CompletableFuture#supplyAsync</strong> ： 提交一个异步任务并执行。当当前环节执行结束后会触发后置环节的操作。</li><li><strong>CompletableFuture#thenApply</strong> ： 提交一个同步任务，并在 CompletableFuture#supplyAsync 执行结束后触发。</li><li><strong>CompletableFuture#join</strong> ： 获取执行结果值，如果前面的操作尚未执行结束，则阻塞等待。</li></ol> 
<hr> 
<p>下面我们来看具体的方法实现：</p> 
<h3><a id="1_CompletableFuturesupplyAsync_272"></a>1. CompletableFuture#supplyAsync</h3> 
<p>CompletableFuture#supplyAsync 按照注释的说法为 ：【返回一个新的 CompletableFuture，它由在给定执行程序中运行的任务异步完成，其值通过调用给定供应商获得。】</p> 
<p>简单来说：就是我们可以通过 CompletableFuture#supplyAsync 创建一个有入参有返回值的异步任务，我们也可用过 CompletableFuture#runAsync 创建一个无入参无返回值的异步任务。当这个任务完成时会判断是否有后置操作，如果有则处理后置操作。</p> 
<hr> 
<p>下面我们具体来看其实现：</p> 
<pre><code class="prism language-java">	<span class="token comment">// 不指定线程池则使用默认的线程池</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">U</span><span class="token punctuation">&gt;</span></span> <span class="token class-name">CompletableFuture</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">U</span><span class="token punctuation">&gt;</span></span> <span class="token function">supplyAsync</span><span class="token punctuation">(</span><span class="token class-name">Supplier</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">U</span><span class="token punctuation">&gt;</span></span> supplier<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token keyword">return</span> <span class="token function">asyncSupplyStage</span><span class="token punctuation">(</span>asyncPool<span class="token punctuation">,</span> supplier<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token comment">// CompletableFuture#supplyAsync 的重载方法，可以指定使用的线程池</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">U</span><span class="token punctuation">&gt;</span></span> <span class="token class-name">CompletableFuture</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">U</span><span class="token punctuation">&gt;</span></span> <span class="token function">supplyAsync</span><span class="token punctuation">(</span><span class="token class-name">Supplier</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">U</span><span class="token punctuation">&gt;</span></span> supplier<span class="token punctuation">,</span>
                                                       <span class="token class-name">Executor</span> executor<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token keyword">return</span> <span class="token function">asyncSupplyStage</span><span class="token punctuation">(</span><span class="token function">screenExecutor</span><span class="token punctuation">(</span>executor<span class="token punctuation">)</span><span class="token punctuation">,</span> supplier<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    
    <span class="token keyword">static</span> <span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">U</span><span class="token punctuation">&gt;</span></span> <span class="token class-name">CompletableFuture</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">U</span><span class="token punctuation">&gt;</span></span> <span class="token function">asyncSupplyStage</span><span class="token punctuation">(</span><span class="token class-name">Executor</span> e<span class="token punctuation">,</span>
                                                     <span class="token class-name">Supplier</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">U</span><span class="token punctuation">&gt;</span></span> f<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>f <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">NullPointerException</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">// 创建一个 CompletableFuture，即演示代码中的 supplyAsync </span>
        <span class="token class-name">CompletableFuture</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">U</span><span class="token punctuation">&gt;</span></span> d <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">CompletableFuture</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">U</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">// 异步执行 AsyncSupply#run 方法</span>
        e<span class="token punctuation">.</span><span class="token function">execute</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">AsyncSupply</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">U</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span>d<span class="token punctuation">,</span> f<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span> d<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
</code></pre> 
<p>我们这里可以看到 CompletableFuture#supplyAsync 的逻辑就是向线程池中丢入一个 AsyncSupply 任务（AsyncSupply 是 CompletableFuture 的内部类），而 AsyncSupply 的实际作用就是执行 f 函数。下面我们来看CompletableFuture.AsyncSupply 的实现</p> 
<hr> 
<h4><a id="11_CompletableFutureAsyncSupply_305"></a>1.1 CompletableFuture.AsyncSupply</h4> 
<p>由于我们将 AsyncSupply 交由线程池执行，所以这里会调用 AsyncSupply#run 来执行具体逻辑，如下：</p> 
<pre><code class="prism language-java">    <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">class</span> <span class="token class-name">AsyncSupply</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">&gt;</span></span> <span class="token keyword">extends</span> <span class="token class-name">ForkJoinTask</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Void</span><span class="token punctuation">&gt;</span></span>
            <span class="token keyword">implements</span> <span class="token class-name">Runnable</span><span class="token punctuation">,</span> <span class="token class-name">AsynchronousCompletionTask</span> <span class="token punctuation">{<!-- --></span>
        <span class="token class-name">CompletableFuture</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">&gt;</span></span> dep<span class="token punctuation">;</span> <span class="token class-name">Supplier</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">&gt;</span></span> fn<span class="token punctuation">;</span>
        <span class="token comment">// dep ： 新创建的 CompletableFuture，用作承载此次计算，作为返回值返回。演示代码中的 supplyAsync </span>
        <span class="token comment">// fn : 需要执行的具体操作</span>
        <span class="token class-name">AsyncSupply</span><span class="token punctuation">(</span><span class="token class-name">CompletableFuture</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">&gt;</span></span> dep<span class="token punctuation">,</span> <span class="token class-name">Supplier</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">&gt;</span></span> fn<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
            <span class="token keyword">this</span><span class="token punctuation">.</span>dep <span class="token operator">=</span> dep<span class="token punctuation">;</span> <span class="token keyword">this</span><span class="token punctuation">.</span>fn <span class="token operator">=</span> fn<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>

        <span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token class-name">Void</span> <span class="token function">getRawResult</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span> <span class="token keyword">return</span> <span class="token keyword">null</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>
        <span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">void</span> <span class="token function">setRawResult</span><span class="token punctuation">(</span><span class="token class-name">Void</span> v<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span><span class="token punctuation">}</span>
        <span class="token comment">// 调用 run 方法</span>
        <span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">boolean</span> <span class="token function">exec</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>

		<span class="token comment">// AsyncSupply#run 会判 d 环节是否已经结束（d.result 是否为空）</span>
		<span class="token comment">// 如果 d 环节尚未执行（d.result == null） 则执行 f.get() 并将结果通过 CAS赋值给 d.result</span>
        <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
            <span class="token class-name">CompletableFuture</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">&gt;</span></span> d<span class="token punctuation">;</span> <span class="token class-name">Supplier</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">&gt;</span></span> f<span class="token punctuation">;</span>
            <span class="token comment">// 必要的参数校验 ： dep 不为空 &amp;&amp; fn 不为空才执行 </span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>d <span class="token operator">=</span> dep<span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token keyword">null</span> <span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span>f <span class="token operator">=</span> fn<span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
            	<span class="token comment">// 将 dep 和 fn 置为空</span>
                dep <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span> fn <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
                <span class="token comment">// 【注解1】d.result == null 说明 d 环节尚未被执行</span>
                <span class="token keyword">if</span> <span class="token punctuation">(</span>d<span class="token punctuation">.</span>result <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
                    <span class="token keyword">try</span> <span class="token punctuation">{<!-- --></span>
                    	<span class="token comment">// 【注解2】通过 cas 将 f.get() 获取的值赋值给 d.result </span>
                        d<span class="token punctuation">.</span><span class="token function">completeValue</span><span class="token punctuation">(</span>f<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                    <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Throwable</span> ex<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
                    	<span class="token comment">// 【注解2】若执行出现异常，将异常结果封装成 AltResult 赋值给 d.result </span>
                        d<span class="token punctuation">.</span><span class="token function">completeThrowable</span><span class="token punctuation">(</span>ex<span class="token punctuation">)</span><span class="token punctuation">;</span>
                    <span class="token punctuation">}</span>
                <span class="token punctuation">}</span>
                <span class="token comment">// 【注解3】执行后置操作：如果还存在后置的操作，则触发并执行</span>
                d<span class="token punctuation">.</span><span class="token function">postComplete</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
</code></pre> 
<p>我们按照注解顺序解释一下：</p> 
<p><strong>1. 【注解1】判断 d.result == null 才执行下面的逻辑，即 判断d 环节是否已经执行，如果尚未执行才会执行下面的逻辑。</strong></p> 
<p><strong>2. 【注解2】执行供应商 f 的方法，并将结果赋值给新创建的 CompletableFuture#result，如果结果为 null，则包装成一个AltResult 赋值给新创建的 CompletableFuture#result，如果出现异常则将异常包装成 AltResult 赋值给新创建的 CompletableFuture#result。</strong></p> 
<pre><code class="prism language-java">	    <span class="token comment">/** The encoding of the null value. */</span>
    <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token class-name">AltResult</span> NIL <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">AltResult</span><span class="token punctuation">(</span><span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    
    <span class="token comment">/** Completes with a non-exceptional result, unless already completed. */</span>
    <span class="token keyword">final</span> <span class="token keyword">boolean</span> <span class="token function">completeValue</span><span class="token punctuation">(</span><span class="token class-name">T</span> t<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    	<span class="token comment">// CAS 替换 this.result 属性从 null 变为 t </span>
    	<span class="token comment">// 这里需要注意，如果 t == null 则会被替换为 NIL， </span>
        <span class="token keyword">return</span> UNSAFE<span class="token punctuation">.</span><span class="token function">compareAndSwapObject</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> RESULT<span class="token punctuation">,</span> <span class="token keyword">null</span><span class="token punctuation">,</span>
                                           <span class="token punctuation">(</span>t <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token operator">?</span> NIL <span class="token operator">:</span> t<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    
    <span class="token comment">/** Completes with an exceptional result, unless already completed. */</span>
    <span class="token keyword">final</span> <span class="token keyword">boolean</span> <span class="token function">completeThrowable</span><span class="token punctuation">(</span><span class="token class-name">Throwable</span> x<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    	<span class="token comment">// 这里会将异常包装成 AltResult 	</span>
        <span class="token keyword">return</span> UNSAFE<span class="token punctuation">.</span><span class="token function">compareAndSwapObject</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> RESULT<span class="token punctuation">,</span> <span class="token keyword">null</span><span class="token punctuation">,</span>
                                           <span class="token function">encodeThrowable</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

	    <span class="token comment">/**
     * Returns the encoding of the given (non-null) exception as a
     * wrapped CompletionException unless it is one already.
     */</span>
    <span class="token keyword">static</span> <span class="token class-name">AltResult</span> <span class="token function">encodeThrowable</span><span class="token punctuation">(</span><span class="token class-name">Throwable</span> x<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">AltResult</span><span class="token punctuation">(</span><span class="token punctuation">(</span>x <span class="token keyword">instanceof</span> <span class="token class-name">CompletionException</span><span class="token punctuation">)</span> <span class="token operator">?</span> x <span class="token operator">:</span>
                             <span class="token keyword">new</span> <span class="token class-name">CompletionException</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
</code></pre> 
<p><strong>3. 【注解3】当 d 环节执行结束后，执行 CompletableFuture#postComplete触发后置操作，CompletableFuture#postComplete 的作用触发当前栈中的所有操作， 该方法会使用嵌套模式将栈中所有等待的操作依次出栈执行（即清栈操作）。该方法的实现过程较为复杂，我们下面来详细分析。</strong></p> 
<hr> 
<h4><a id="12_CompletableFuturepostComplete_386"></a>1.2 CompletableFuture#postComplete</h4> 
<p><strong>CompletableFuture#postComplete 方法官方的解释是 【弹出并尝试触发所有可到达的依赖项。仅在已知完成时调用】。</strong></p> 
<p><strong>个人理解</strong>：当前环节完成后会判断 当前环节是否是否还存在后置操作（通过 CompletableFuture 的stack 属性是否为空），如果存在后置操作，则将后置操作出栈执行，根据具体的情况操作可能选择同步执行或者异步执行，直至将当前环节的操作栈清空为止。CompletableFuture#postComplete 的目的就是执行并清除当前 CompletableFuture 的所有操作栈。</p> 
<hr> 
<h5><a id="121__395"></a>1.2.1 代码分析</h5> 
<p>该方法的实现比较复杂，具体实现如下：</p> 
<pre><code class="prism language-java">
    <span class="token comment">// 弹出并尝试触发所有可到达的依赖项。仅在已知完成时调用</span>
    <span class="token keyword">final</span> <span class="token keyword">void</span> <span class="token function">postComplete</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
         <span class="token comment">// 在每一步，变量 f 都会保存当前依赖项以弹出和运行。它一次只沿着一条路径扩展，推动其他路径避免无限递归。</span>
         <span class="token comment">// 【注解1】初始化属性 f 记录当前环节 CompletableFuture</span>
        <span class="token class-name">CompletableFuture</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span><span class="token punctuation">&gt;</span></span> f <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">;</span> <span class="token class-name">Completion</span> h<span class="token punctuation">;</span>
         <span class="token comment">// 【注解2】 循环判断</span>
        <span class="token comment">//  如果f.stack 不为空（即对于 f 来说还有未完成的操作，f 可能是当前 CompletableFuture ，也可能是 子操作返回的 CompletableFuture ） </span>
        <span class="token comment">//  f != this 并且 this.stack 不为空( 即 f != this 即代表 f 可能是其子操作返回的新的CompletableFuture 已经完成了所有操作  但是 当前 CompletableFuture 还有 操作未完成)</span>
        <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>h <span class="token operator">=</span> f<span class="token punctuation">.</span>stack<span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token keyword">null</span> <span class="token operator">||</span>
               <span class="token punctuation">(</span>f <span class="token operator">!=</span> <span class="token keyword">this</span> <span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span>h <span class="token operator">=</span> <span class="token punctuation">(</span>f <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">.</span>stack<span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
            <span class="token comment">// d 作为 临时变量，临时过渡使用，t 会赋值为 h.next ，也是一个过渡属性</span>
            <span class="token class-name">CompletableFuture</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span><span class="token punctuation">&gt;</span></span> d<span class="token punctuation">;</span> <span class="token class-name">Completion</span> t<span class="token punctuation">;</span>
            <span class="token comment">// 【注解3】h 出栈，将 h.stack 的值替换为 t</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>f<span class="token punctuation">.</span><span class="token function">casStack</span><span class="token punctuation">(</span>h<span class="token punctuation">,</span> t <span class="token operator">=</span> h<span class="token punctuation">.</span>next<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
            	<span class="token comment">// 如果 t 不为空 （则说明 除了 h 还有后置操作）</span>
            	<span class="token comment">// 【注解 4】h 出栈后执行前的的一些操作</span>
                <span class="token keyword">if</span> <span class="token punctuation">(</span>t <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
                    <span class="token keyword">if</span> <span class="token punctuation">(</span>f <span class="token operator">!=</span> <span class="token keyword">this</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
                        <span class="token function">pushStack</span><span class="token punctuation">(</span>h<span class="token punctuation">)</span><span class="token punctuation">;</span>
                        <span class="token keyword">continue</span><span class="token punctuation">;</span>
                    <span class="token punctuation">}</span>
                    h<span class="token punctuation">.</span>next <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>    <span class="token comment">// detach</span>
                <span class="token punctuation">}</span>
                <span class="token comment">// 【注解5】触发 h 的操作，这里指定是嵌套模式。实际上在 CompletableFuture 中嵌套模式只会在这里调用</span>
                <span class="token comment">// 如果 tryFire 返回是空，则h 操作不需要返回新的 CompletableFuture，后续操作依旧依赖于 this	</span>
                <span class="token comment">// 如果 tryFire  返回不为空，则 h 操作返回了新的 CompletableFuture，后续的操作则依赖于新的 CompletableFuture 执行，因为新的 CompletableFuture  可能还存在后置操作。</span>
                f <span class="token operator">=</span> <span class="token punctuation">(</span>d <span class="token operator">=</span> h<span class="token punctuation">.</span><span class="token function">tryFire</span><span class="token punctuation">(</span>NESTED<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token keyword">null</span> <span class="token operator">?</span> <span class="token keyword">this</span> <span class="token operator">:</span> d<span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
</code></pre> 
<hr> 
<p>这里的整个逻辑比较绕，我们按照注释顺序来一步一步分析：</p> 
<p><strong>1. 【注解1】：这一步声明了两个属性 ，f 初始化为 this，h初始化为 null 。</strong></p> 
<pre><code class="prism language-java">	 <span class="token class-name">CompletableFuture</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span><span class="token punctuation">&gt;</span></span> f <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">;</span> <span class="token class-name">Completion</span> h<span class="token punctuation">;</span>
</code></pre> 
<p>实际上在后面的循环中 f 表示的是当前 CompletableFuture ，这个可能是其子操作返回的CompletableFuture，不一定是 this。h 后面会赋值为 f.stack， 即 基于 f 的子操作。h 的操作可能会返回一个新的 CompletableFuture。</p> 
<hr> 
<p><strong>2. 【注解2】：这里来说明一下 while 循环进入条件 ： f 具有子操作未处理 || f = this 并且 f 还具有子操作</strong>:</p> 
<pre><code class="prism language-java"><span class="token comment">// 1. 条件1 ：(h = f.stack) != null ： f.stack 不为空说明 f 还有未完成的操作</span>
<span class="token comment">// 2. 条件2 ：(f != this &amp;&amp; (h = (f = this).stack) != null)</span>
<span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>h <span class="token operator">=</span> f<span class="token punctuation">.</span>stack<span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token keyword">null</span> <span class="token operator">||</span>
               <span class="token punctuation">(</span>f <span class="token operator">!=</span> <span class="token keyword">this</span> <span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span>h <span class="token operator">=</span> <span class="token punctuation">(</span>f <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">.</span>stack<span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
</code></pre> 
<ul><li> <p><strong>条件1</strong> ： 将 h 赋值为 f.stack， 并且 如果 h != null 即可满足，所以条件1 的判定条件是 f.stack != null 即 f 后续存在子操作，这里的 f 可能是 this 也可能是 <code>h.tryFire(NESTED)</code> 返回的新的 CompletableFuture。</p> </li><li> <p><strong>条件2</strong> ：当到达这一步的判断，说明 f.stack = null，即对于 f 来说已经没有子操作了，这里也分为两个 且 的判断</p> 
  <ul><li>判断 <code>f != this</code> ： 即当前的 f 不是 当前 CompletableFuture 类，而是其子操作的 CompletableFuture 。如果 f.stack = null 并且 f = this 则说明当前环境的所有操作都执行结束了就没必要再执行了。所以这里首先要判断 f != this</li><li>判断 <code>(h = (f = this).stack) != null)</code>：即 this.stack 不为空，到达这一步说明 f.stack = null 并且 f != this 则需要判断对于 this 来说是否还具有未执行的操作才有必要继续下去。</li></ul> </li></ul> 
<hr> 
<p><strong>3. 【注解3】：这里通过 CAS 操作将 f.stack 的栈顶元素（h）出栈。后面准备执行h操作</strong></p> 
<hr> 
<p><strong>4. 【注解4】：这里是将 h出栈后还需要对一些元素做一些特殊处理，这里的目的是为了保证栈中每个操作都能执行，我们在后面的具体举例中可以看到其作用如下：</strong></p> 
<pre><code class="prism language-java">		<span class="token comment">// h 出栈， t = h.next</span>
		<span class="token comment">// t != null 说明对于 f 来说，其子操作不止 h 一个 </span>
          <span class="token keyword">if</span> <span class="token punctuation">(</span>t <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
          		<span class="token comment">// f 不是this 时，将 h入栈到this 中，即将 h 的执行顺序提前</span>
              <span class="token keyword">if</span> <span class="token punctuation">(</span>f <span class="token operator">!=</span> <span class="token keyword">this</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
                  <span class="token function">pushStack</span><span class="token punctuation">(</span>h<span class="token punctuation">)</span><span class="token punctuation">;</span>
                  <span class="token comment">// 跳过本次循环</span>
                  <span class="token keyword">continue</span><span class="token punctuation">;</span>
              <span class="token punctuation">}</span>
              <span class="token comment">// h已经出栈，将 h.next 清空</span>
              h<span class="token punctuation">.</span>next <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>    <span class="token comment">// detach</span>
          <span class="token punctuation">}</span>
</code></pre> 
<hr> 
<p><strong>5. 【注解5】：这一步是直接执行 h 操作，注意这里使用的是嵌套模式执行，只有在这里才会使用嵌套模式调用，可以简单理解当 CompletableFuture.Completion#tryFire 是嵌套模式中时一定是被 CompletableFuture#postComplete 调用，即一定处于清栈操作过程中。如下：</strong></p> 
<pre><code class="prism language-java">		<span class="token comment">// h 执行 CompletableFuture.Completion#tryFire 方法，即尝试完成 h 操作</span>
		<span class="token comment">// 对于嵌套模式来说其返回值可能是 null 也可能为新的 CompletableFuture ，这里如果为空则将h 赋值为 this。否则f 赋值为新的 CompletableFuture 。</span>
          f <span class="token operator">=</span> <span class="token punctuation">(</span>d <span class="token operator">=</span> h<span class="token punctuation">.</span><span class="token function">tryFire</span><span class="token punctuation">(</span>NESTED<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token keyword">null</span> <span class="token operator">?</span> <span class="token keyword">this</span> <span class="token operator">:</span> d<span class="token punctuation">;</span>
</code></pre> 
<p>下面我们会具体分析 CompletableFuture.Completion#tryFire 的实现，这里我们先简单分析两个情况：</p> 
<ol><li><code>h.tryFire(NESTED) 返回 null</code> ：当前线程未获取到 h 操作的执行权 || h操作未执行结束 || h.dep 没有后置操作</li><li><code>h.tryFire(NESTED) 返回不为null</code> ：当前线程获取到了操作 h 的执行权，并且 h操作执行结束 且 h.dep 存在操作需要执行。</li></ol> 
<hr> 
<h5><a id="122__494"></a>1.2.2 举例说明</h5> 
<p>上面的代码分析我都不知道怎么描述才能更好的理解，因此下面举一个简单的例子来理解CompletableFuture#postComplete 方法的整个执行过程：</p> 
<p>我们用下面的代码来进行分析（我们的例子中并未使用其他操作，如 CompletableFuture#thenApply 等，因为其实现逻辑和 CompletableFuture#whenComplete 如出一辙，所以这里全部使用了CompletableFuture#whenComplete演示 ）：</p> 
<pre><code class="prism language-java">    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">InterruptedException</span> <span class="token punctuation">{<!-- --></span>
        <span class="token class-name">CompletableFuture</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">&gt;</span></span> startCF <span class="token operator">=</span> <span class="token class-name">CompletableFuture</span><span class="token punctuation">.</span><span class="token function">supplyAsync</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token punctuation">{<!-- --></span>
            <span class="token comment">// 注解1 ： 睡眠 2s，默认任务耗时， 让后置操作都入栈执行，用于演示</span>
            <span class="token keyword">try</span> <span class="token punctuation">{<!-- --></span>
                <span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">2000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
                e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
            <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"START"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword">return</span> <span class="token string">"start"</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">// 异步执行，保证操作入栈</span>
        <span class="token class-name">CompletableFuture</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">&gt;</span></span> a1 <span class="token operator">=</span> startCF<span class="token punctuation">.</span><span class="token function">whenCompleteAsync</span><span class="token punctuation">(</span><span class="token punctuation">(</span>s<span class="token punctuation">,</span> t<span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"A1"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">CompletableFuture</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">&gt;</span></span> b1 <span class="token operator">=</span> startCF<span class="token punctuation">.</span><span class="token function">whenCompleteAsync</span><span class="token punctuation">(</span><span class="token punctuation">(</span>s<span class="token punctuation">,</span> t<span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"B1"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">CompletableFuture</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">&gt;</span></span> bb1 <span class="token operator">=</span> b1<span class="token punctuation">.</span><span class="token function">whenCompleteAsync</span><span class="token punctuation">(</span><span class="token punctuation">(</span>s<span class="token punctuation">,</span> t<span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"BB1"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">CompletableFuture</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">&gt;</span></span> bb2 <span class="token operator">=</span> b1<span class="token punctuation">.</span><span class="token function">whenCompleteAsync</span><span class="token punctuation">(</span><span class="token punctuation">(</span>s<span class="token punctuation">,</span> t<span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"BB2"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">// 睡眠 5s， 让所有的 CompletableFuture 执行结束</span>
        <span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">5000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
</code></pre> 
<hr> 
<p>输出结果如下图：</p> 
<p><img src="https://images2.imgbox.com/d0/7c/IrWVEhgF_o.png" alt="在这里插入图片描述"></p> 
<hr> 
<p>下面我们来分析一下 CompletableFuture#supplyAsync 执行结束时（此时控制台输出了 START），CompletableFuture#supplyAsync 会调用 CompletableFuture.AsyncSupply#run 执行操作，当操作执行结束会调用 CompletableFuture#postComplete 方法，：</p> 
<ol><li> <p>此时的startCF结构如下图, 此时 f = this = startCF，h = f.stack = B1<br> <img src="https://images2.imgbox.com/9d/33/DzdA6tDj_o.png" alt="在这里插入图片描述"></p> </li><li> <p>进入第一次循环，如下图<br> <img src="https://images2.imgbox.com/16/8d/NU0WdLaT_o.png" alt="在这里插入图片描述"></p> </li><li> <p>进入第二次循环，如下图<br> <img src="https://images2.imgbox.com/a7/7b/er1fUXf6_o.png" alt="在这里插入图片描述"></p> </li><li> <p>进入第三次循环，如下图<br> <img src="https://images2.imgbox.com/8a/dc/g3M20KuY_o.png" alt="在这里插入图片描述"></p> </li><li> <p>进入第四次循环，如下图</p> <p><img src="https://images2.imgbox.com/15/06/gI3RWpC8_o.png" alt="在这里插入图片描述"></p> </li><li> <p>进入第五次循环，如下图<br> <img src="https://images2.imgbox.com/88/4a/EuKzCBrP_o.png" alt="在这里插入图片描述"></p> </li><li> <p>不满足循环条件，跳出循环，至此，示例代码中的所有操作都执行结束。如下图<br> <img src="https://images2.imgbox.com/f0/d8/l0R40dAV_o.png" alt="在这里插入图片描述"></p> </li></ol> 
<hr> 
<p>需要注意的是，这里的代码通过 Thread.sleep 模拟了 startCF 的执行过程睡眠了2s，从而导致 a1,b1，bb1，bb2 等环节需要等待 startCF 环节执行结束才能执行，所以 a1,b1，bb1，bb2 都会入栈等待后出栈执行，并且由于栈先入后出的特性导致执行顺序有些差异（我们下面会分析，入栈逻辑在下面，这段话要不要放下面）如果不入栈，则会按照顺序执行输出 如下</p> 
<p><img src="https://images2.imgbox.com/38/d8/O6o52Rvj_o.png" alt="在这里插入图片描述"></p> 
<h5><a id="123__558"></a>1.2.3 总结</h5> 
<p>CompletableFuture#postComplete 会执行清栈操作。这里会在 while 循环中以嵌套模式 调用 CompletableFuture.Completion#tryFire 方法（实际上，也只有 在 CompletableFuture#postComplete 中会以嵌套模式调用 CompletableFuture.Completion#tryFire ）。也就是说当 CompletableFuture.Completion#tryFire 的 mode = -1 （嵌套模式时）则说明其是在 CompletableFuture#postComplete 中被调用，即还处于 CompletableFuture#postComplete方法的堆栈执行环节。</p> 
<hr> 
<h3><a id="2_CompletableFuturethenApply_566"></a>2. CompletableFuture#thenApply</h3> 
<p>这里还是以一开始的例子做解释，为了方便解释，这里我们还是把代码贴出来。</p> 
<pre><code class="prism language-java">```java
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token keyword">final</span> <span class="token class-name">Supplier</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">&gt;</span></span> startSupplier <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token string">"start"</span><span class="token punctuation">;</span>
        <span class="token keyword">final</span> <span class="token class-name">Function</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">,</span> <span class="token class-name">String</span><span class="token punctuation">&gt;</span></span> thenApplyFunction <span class="token operator">=</span> s <span class="token operator">-&gt;</span> s <span class="token operator">+</span> <span class="token string">" -&gt; thenApply"</span><span class="token punctuation">;</span>

        <span class="token keyword">final</span> <span class="token class-name">CompletableFuture</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">&gt;</span></span> supplyAsync <span class="token operator">=</span> <span class="token class-name">CompletableFuture</span><span class="token punctuation">.</span><span class="token function">supplyAsync</span><span class="token punctuation">(</span>startSupplier<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">final</span> <span class="token class-name">CompletableFuture</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">&gt;</span></span> thenApply <span class="token operator">=</span> supplyAsync<span class="token punctuation">.</span><span class="token function">thenApply</span><span class="token punctuation">(</span>thenApplyFunction<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">// 输出 ： start -&gt; thenApply</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>thenApply<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
</code></pre> 
<p>可以知道 <code>supplyAsync.thenApply(thenApplyFunction);</code> 表示当 supplyAsync 执行结束后执行操作thenApplyFunction。这里就需要考虑 ：当代码执行到 <code>supplyAsync.thenApply(thenApplyFunction);</code> 时， supplyAsync 是否执行结束（由于 supplyAsync 是异步执行，所以存在未执行结束的可能），如果supplyAsync 执行结束，则CompletableFuture会尝试执行直接执行thenApplyFunction 操作，否则则将 thenApplyFunction封装成 CompletableFuture.Completion，等待 supplyAsync 执行结束后再将操作出栈执行操作。</p> 
<hr> 
<p>下面我们具体来看整个方法的实现：</p> 
<pre><code class="prism language-java">    <span class="token keyword">public</span> <span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">U</span><span class="token punctuation">&gt;</span></span> <span class="token class-name">CompletableFuture</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">U</span><span class="token punctuation">&gt;</span></span> <span class="token function">thenApply</span><span class="token punctuation">(</span>
        <span class="token class-name">Function</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span> <span class="token keyword">super</span> <span class="token class-name">T</span><span class="token punctuation">,</span><span class="token operator">?</span> <span class="token keyword">extends</span> <span class="token class-name">U</span><span class="token punctuation">&gt;</span></span> fn<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token comment">// 调用 uniApplyStage 方法</span>
        <span class="token keyword">return</span> <span class="token function">uniApplyStage</span><span class="token punctuation">(</span><span class="token keyword">null</span><span class="token punctuation">,</span> fn<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">private</span> <span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span> <span class="token class-name">CompletableFuture</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span> <span class="token function">uniApplyStage</span><span class="token punctuation">(</span>
        <span class="token class-name">Executor</span> e<span class="token punctuation">,</span> <span class="token class-name">Function</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span> <span class="token keyword">super</span> <span class="token class-name">T</span><span class="token punctuation">,</span><span class="token operator">?</span> <span class="token keyword">extends</span> <span class="token class-name">V</span><span class="token punctuation">&gt;</span></span> f<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>f <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">NullPointerException</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">// CompletableFuture#thenApply 执行后要返回的 CompletableFuture，即演示代码中的 thenApply</span>
        <span class="token class-name">CompletableFuture</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span> d <span class="token operator">=</span>  <span class="token keyword">new</span> <span class="token class-name">CompletableFuture</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">// 【注解1】这里的this 是演示代码中的 supplyAsync ，是当前操作的前置环节，判断当前是否可以需要入栈</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>e <span class="token operator">!=</span> <span class="token keyword">null</span> <span class="token operator">||</span> <span class="token operator">!</span>d<span class="token punctuation">.</span><span class="token function">uniApply</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> f<span class="token punctuation">,</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
             <span class="token comment">// 【注解2】 创建 UniApply 实例 并入栈等待执行</span>
            <span class="token class-name">UniApply</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span> c <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">UniApply</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span>e<span class="token punctuation">,</span> d<span class="token punctuation">,</span> <span class="token keyword">this</span><span class="token punctuation">,</span> f<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token comment">// 【注解3】将 c压入栈 （不一定会入栈）</span>
            <span class="token function">push</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token comment">// 【注解4】 同步触发一次操作</span>
            c<span class="token punctuation">.</span><span class="token function">tryFire</span><span class="token punctuation">(</span>SYNC<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">return</span> d<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
</code></pre> 
<p>我们按照代码注解顺序解析：</p> 
<p><strong>1. 【注解1】 判断 thenApply 操作是否需要入栈，这里的条件有两条：</strong></p> 
<ul><li><code>e != null</code> ： e 不为空，说明当前任务需要交由线程池异步执行，当前线程不允许执行该操作。 可以通过 thenApplyAsync 方式执行异步执行。</li><li><code>!d.uniApply(this, f, null)</code> ： 到了这一步说明e 为空，则说明当前操作可以同步执行，尝试是否可以执行成功，如果成功则不需要再入栈。<code>d.uniApply(this, f, null)</code> 返回 false的场景有两个 ：<code>this 环节 尚未执行结束</code> || <code>当前线程未获取到执行权</code>。而这里只可能是 <code>this 环节尚未执行结束</code>， 因为这里的调用 <code>!d.uniApply(this, f, null)</code> 的第三个参数为null。（关于 CompletableFuture#uniApply 方法我们在下面详细介绍。）</li></ul> 
<p><strong>2. 【注解2】将 UniApply 实例压入栈。进入这里有两种情况：</strong></p> 
<ul><li><code>e != null</code> : 即当前操作需要异步执行，则通过 UniApply 异步执行。需要注意异步执行也需要前置环节执行结束。</li><li><code>e = null &amp;&amp; !d.uniApply(this, f, null)</code> ：即 e 为空 但是<code>d.uniApply(this, f, null)</code> 返回 false，即当前操作可以同步执行，但是 this 环节尚未执行结束，所以当前操作只能入栈等待前置环节结束后再执行。（关于 CompletableFuture#uniApply 方法我们在下面详细介绍。）</li></ul> 
<p><strong>3. 【注解3】：将操作c 压入栈。</strong></p> 
<pre><code class="prism language-java">	<span class="token comment">// 将c压入栈</span>
    <span class="token comment">/** Pushes the given completion (if it exists) unless done. */</span>
    <span class="token keyword">final</span> <span class="token keyword">void</span> <span class="token function">push</span><span class="token punctuation">(</span><span class="token class-name">UniCompletion</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span><span class="token punctuation">,</span><span class="token operator">?</span><span class="token punctuation">&gt;</span></span> c<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    	<span class="token comment">// 非空判断</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>c <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        	<span class="token comment">// 如果 当前 CompletableFuture 尚未执行结束 （result == null），则尝试入栈</span>
        	<span class="token comment">// 如果 入栈失败 !tryPushStack(c) = true， 则进入循环，一直到 c 成功入栈。</span>
            <span class="token keyword">while</span> <span class="token punctuation">(</span>result <span class="token operator">==</span> <span class="token keyword">null</span> <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span><span class="token function">tryPushStack</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span><span class="token punctuation">)</span>
                <span class="token function">lazySetNext</span><span class="token punctuation">(</span>c<span class="token punctuation">,</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// clear on failure</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
</code></pre> 
<p><strong>这里需要注意</strong></p> 
<ol><li> <p><strong>执行完push 方式，操作 c 并不一定会入栈</strong>。如果 this 环节执行结束 (this.result != null)，则 c 不会再入栈。我们在上面已经知道在这里入栈的条件是 <code>当前操作需要异步执行 || 当前操作可以同步执行但this 环节尚未执行结束</code> ，并且即使是异步执行，也需要等待this 环节执行结束才能继续执行，那么我们可以知道操作 c 执行的必要条件就是this环节执行结束。而如果 result != null 时 则说明 this 环节已经结束，所以操作执行的前提其条件已经满足，就不必再强制入栈等待，直接通过 <code>c.tryFire(SYNC)</code> 触发当前操作就可以。</p> </li><li> <p><strong>这两个入栈操作 （<code>result == null</code> 和 <code>!tryPushStack(c)</code>）的判断过程并非是原子性的</strong>，在并发情况下可能会出现如下情况：</p> <pre><code class="prism language-java">线程 <span class="token class-name">A</span> ：判断 result <span class="token operator">==</span> <span class="token keyword">null</span>
线程 <span class="token class-name">B</span> ：完成 当前环节 <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span> 的操作，赋值 result 并执行<span class="token class-name">CompletableFuture</span>#postFire 完成环节后置处理<span class="token punctuation">(</span>检查当前环节未执行的堆栈执行等<span class="token punctuation">)</span><span class="token punctuation">,</span> 此时 result <span class="token operator">!=</span> <span class="token keyword">null</span>。
线程 <span class="token class-name">A</span> ：执行 <span class="token operator">!</span><span class="token function">tryPushStack</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span> 将 c 入栈到<span class="token keyword">this</span><span class="token punctuation">.</span>stack 中
</code></pre> <p>这里可以发现，如果按照上面的执行步骤，那么 c 操作将永远无法触发，因为 this 环节的清栈检查操作在线程B已经完成了。这里就会认为 this 的所有操作都已经完成，而不会再进行出栈执行操作。所以在后面会使用同步模式尝试触发一下操作（注解4的内容）</p> </li></ol> 
<p><strong>4. 【注解4】以同步模式尝试触发一次当前操作，因为入栈结束后，前置操作可能已经执行结束了，所以这里再一次尝试触发操作。除此之外还有上面说的特殊情况原因，防止c操作由于并发原因永远无法执行</strong></p> 
<ul><li>这里需要注意的是：在 <strong>614行</strong> 当我们发现当前操作需要异步执行或者前置操作尚未执行结束时会将操作入栈。当前置操作执行结束后会通过 <code>CompletableFuture#postComplete</code> 方法判断是否还有后置操作（通过 栈是否为空判断），而当我们执行到 <strong>615 或者 616 行</strong>，还未入栈时，此时前置操作执行结束，发现没有后置操作（栈为空）则会完成整个调用过程，从而可能错过执行当前操作。而在 <strong>617 行</strong>，即入栈成功后，再尝试触发当前操作，可以避免该情况的产生。<br> <img src="https://images2.imgbox.com/32/7e/yNqsBr11_o.png" alt="在这里插入图片描述"></li></ul> 
<hr> 
<p>下面我们来看一看 CompletableFuture#thenApply 方法中具体的几个方法，如下：</p> 
<h4><a id="21_CompletableFutureuniApply_662"></a>2.1 CompletableFuture#uniApply</h4> 
<p><strong>CompletableFuture#uniApply 的调用场景只有两处：</strong></p> 
<ol><li><strong>CompletableFuture#uniApplyStage 中 调用</strong> ：即我们上述场景中，在操作入栈前，如果操作不需要异执行会尝试同步支持一次， 因为当前操作刚开始执行，也尚未入栈，并不会有其他的线程来争夺执行权，所以此时参数中的 UniApply 为 空。</li><li><strong>CompletableFuture.UniApply#tryFire 中调用</strong> ： 如果是嵌套模式或者同步模式调用，参数中的 UniApply 则不为空。这两种情况下都可能出现线程竞争。</li></ol> 
<p>注 ：CompletableFuture#uniApply 的第三个入参 <code>UniApply&lt;S,T&gt; c</code> 的作用的目的是为了保证操作执行的原子性，因为在某些场景下不需要线程竞争的情况下就为 null。</p> 
<hr> 
<p>下面我们来看具体的 CompletableFuture#uniApply 实现：</p> 
<pre><code class="prism language-java">	<span class="token comment">// a ：当前的 CompletableFuture 实例，当 a 执行结束后才能执行本次操作。这里是演示代码中的 supplyAsync。即 ： 当 supplyAsync 执行结束后才能执行 thenApplyFunction</span>
	<span class="token comment">// f ：本次将要执行的操作，即 thenApplyFunction</span>
	<span class="token comment">// c ：UniApply 实例，当当前操作尚未入栈时为空，如果操作是从栈中弹出执行,则不为空</span>
    <span class="token keyword">final</span> <span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">S</span><span class="token punctuation">&gt;</span></span> <span class="token keyword">boolean</span> <span class="token function">uniApply</span><span class="token punctuation">(</span><span class="token class-name">CompletableFuture</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">S</span><span class="token punctuation">&gt;</span></span> a<span class="token punctuation">,</span>
                               <span class="token class-name">Function</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span> <span class="token keyword">super</span> <span class="token class-name">S</span><span class="token punctuation">,</span><span class="token operator">?</span> <span class="token keyword">extends</span> <span class="token class-name">T</span><span class="token punctuation">&gt;</span></span> f<span class="token punctuation">,</span>
                               <span class="token class-name">UniApply</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">S</span><span class="token punctuation">,</span><span class="token class-name">T</span><span class="token punctuation">&gt;</span></span> c<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token class-name">Object</span> r<span class="token punctuation">;</span> <span class="token class-name">Throwable</span> x<span class="token punctuation">;</span>
        <span class="token comment">// 【注解1】通过 a.result 是否为空判断前一个环节是否已经执行结束</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>a <span class="token operator">==</span> <span class="token keyword">null</span> <span class="token operator">||</span> <span class="token punctuation">(</span>r <span class="token operator">=</span> a<span class="token punctuation">.</span>result<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token keyword">null</span> <span class="token operator">||</span> f <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span>
            <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
        tryComplete<span class="token operator">:</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>result <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        	<span class="token comment">// 【注解2】 如果上游执行出现了异常则对异常处理</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>r <span class="token keyword">instanceof</span> <span class="token class-name">AltResult</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
            	<span class="token comment">// 如果上游执行出现了异常（出现异常会包装成 AltResult）</span>
            	<span class="token comment">// ex 不为空说明上游出现了异常</span>
                <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>x <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token class-name">AltResult</span><span class="token punctuation">)</span>r<span class="token punctuation">)</span><span class="token punctuation">.</span>ex<span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
                	<span class="token comment">// 将异常信息包装成 result</span>
                    <span class="token function">completeThrowable</span><span class="token punctuation">(</span>x<span class="token punctuation">,</span> r<span class="token punctuation">)</span><span class="token punctuation">;</span>
                    <span class="token keyword">break</span> tryComplete<span class="token punctuation">;</span>
                <span class="token punctuation">}</span>
                r <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
            <span class="token keyword">try</span> <span class="token punctuation">{<!-- --></span>
            	<span class="token comment">// 【注解3】 c 不为空 &amp;&amp; 通过 CAS 没有到了任务执行所有权，直接返回false， 代表当前任务当前无法执行</span>
                <span class="token keyword">if</span> <span class="token punctuation">(</span>c <span class="token operator">!=</span> <span class="token keyword">null</span> <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span>c<span class="token punctuation">.</span><span class="token function">claim</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
                    <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
                <span class="token annotation punctuation">@SuppressWarnings</span><span class="token punctuation">(</span><span class="token string">"unchecked"</span><span class="token punctuation">)</span> <span class="token class-name">S</span> s <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name">S</span><span class="token punctuation">)</span> r<span class="token punctuation">;</span>
                <span class="token comment">// 【注解4】执行当前任务，将结果赋值给 result</span>
                <span class="token function">completeValue</span><span class="token punctuation">(</span>f<span class="token punctuation">.</span><span class="token function">apply</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Throwable</span> ex<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
            	<span class="token comment">// 执行出现异常，包装异常信息</span>
                <span class="token function">completeThrowable</span><span class="token punctuation">(</span>ex<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
        <span class="token comment">// 当前任务执行成功</span>
        <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
</code></pre> 
<p>CompletableFuture#uniApply 的简单来说：</p> 
<ol><li>判断前置环节 a 是否执行结束，没执行结束直接返回 false</li><li>判断前置环节 a 是否抛出异常，如果抛出则传递异常</li><li>判断当前线程是否有资格执行当前操作，同步执行但没有获取到执行权 或者 异步执行 直接返回false( 异步执行交由线程池来执行，所以当前线程一定获取不到执行权，所以返回false)</li><li>同步执行操作，并返回true</li></ol> 
<hr> 
<p>我们按照注解顺序解析：</p> 
<p><strong>1. 【注解1】条件校验，如果前一个环节已经完成(a.result != null) 才会往下执行，否则直接返回false（前一个环节都未执行结束，自然无法执行当前环节）</strong></p> 
<p><strong>2. 【注解2】如果上游的结果类型是 AltResult，那么要么是上游执行抛出了异常，要么是上游结果为 null ，这两种情况都会将reuslt 封装成 AltResult 类型，这里对异常结果进行处理，传递异常结果</strong></p> 
<p><strong>3. 【注解3】<code>c != null &amp;&amp; !c.claim()</code> 的判断条件要成立需要 ：当前操作是从栈中弹出或者执行过入栈操作（否则c 应该为空） &amp;&amp; （ 当前线程没有获取到执行资格 || 当前操作需要异步执行），具体如下：</strong></p> 
<ul><li> <p><code>c != null</code> ：上面我们说了 c != null 是在同步模式或者嵌套模式调用时才会成立。当 c != null 则说明 c 是执行过入栈的操作（但并非一定入栈了），则可能会存在多个线程竞争执行的情况。</p> 
  <ul><li>同步模式下：在 CompletableFuture#uniApplyStage 中当操作入栈后会以同步模式调用UniApply#tryFire方法，此时还可能存在其他线程将在执行当前环节的清栈操作，然后会将当前操作出栈执行，此时对于当前操作则可能会出现线程竞争执行。</li><li>嵌套模式下：嵌套模式的调用只会在 CompletableFuture#postComplete 方法中调用，如果有多个线程同时调用某一个环节 CompletableFuture#postComplete 方法则会出现竞争（这种场景在 CompletableFuture#postFire 方法里里介绍了）。</li></ul> </li><li> <p><code>!c.claim()</code> ：代码走到这一步则说明 c != null，该方法的作用是判断当前线程是否有资格执行当前操作：首先通过 CAS确定当前操作由当前线程锁定处理（并非是当前线程执行），随后判断当前操作是异步执行还是同步执行，如果是同步执行，则返回true（因为CAS 操作已经确保当前操作由当前线程处理，而操作如果是同步执行，则由当前线程执行），如果是异步执行，则交由线程池执行，并返回false （因为c.claim() 方法 返回值是当前线程是否可以执行操作，如果是异步执行，则是交由线程池执行，所以这里判断如果是异步执行则直接交由线程池执行后直接返回false）。其实现具体如下：</p> <pre><code class="prism language-java">		<span class="token comment">// 返回 true的条件有下面两条：</span>
		<span class="token comment">// 	  1. ompareAndSetForkJoinTaskTag((short)0, (short)1) = true : 当前线程获取到了处理当前操作的资格（并非执行资格，如果是异步执行，则交由线程池执行）</span>
		<span class="token comment">//	  2. e == null : 任务可以同步执行</span>
        <span class="token keyword">final</span> <span class="token keyword">boolean</span> <span class="token function">claim</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
            <span class="token class-name">Executor</span> e <span class="token operator">=</span> executor<span class="token punctuation">;</span>
            <span class="token comment">// CAS  标志 当前操作由当前线程来处理（并非一定由由当前线程执行）</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">compareAndSetForkJoinTaskTag</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">short</span><span class="token punctuation">)</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token keyword">short</span><span class="token punctuation">)</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
            	<span class="token comment">// e = null 说明任务可以同步执行，并且当前线程已经通过 CAS 占据了该任务，所以直接返回ture， 表明当前线程可以执行当前操作</span>
                <span class="token keyword">if</span> <span class="token punctuation">(</span>e <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span>
                    <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
                <span class="token comment">// 走到这里说明线程池不为空，则当前任务需要异步执行（通过指定的线程池执行）</span>
                executor <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span> <span class="token comment">// disable</span>
               	<span class="token comment">// 交由线程池执行</span>
                e<span class="token punctuation">.</span><span class="token function">execute</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
            <span class="token comment">// 走到这里说明任务交由了线程池执行，当前线程并未获取执行任务的权限，返回false</span>
            <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
</code></pre> </li></ul> 
<p><strong>4. 【注解4】走到这里说明了当前任务是可以同步执行的，，并且要么当前操作未入栈（无线程争夺） || 当前操作入栈（可能存在线程争夺）但当前线程获取到了执行的资格。执行当前操作，并将结果通过 CAS 保存到 this.result 中</strong></p> 
<hr> 
<h4><a id="22_CompletableFuturepush_763"></a>2.2 CompletableFuture#push</h4> 
<p>CompletableFuture#push 操作是将 CompletableFuture.UniApply 入栈，其关键逻辑我们在上面已经解释过了，这里不再赘述：</p> 
<pre><code class="prism language-java">	<span class="token comment">// 将c压入栈，直到成功为止</span>
    <span class="token comment">/** Pushes the given completion (if it exists) unless done. */</span>
    <span class="token keyword">final</span> <span class="token keyword">void</span> <span class="token function">push</span><span class="token punctuation">(</span><span class="token class-name">UniCompletion</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span><span class="token punctuation">,</span><span class="token operator">?</span><span class="token punctuation">&gt;</span></span> c<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    	<span class="token comment">// 非空判断</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>c <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        	<span class="token comment">// 如果 当前 CompletableFuture 尚未执行结束 （result == null），则尝试入栈</span>
        	<span class="token comment">// 如果 入栈失败 !tryPushStack(c) = true， 则进入循环，一直到 c 成功入栈。</span>
            <span class="token keyword">while</span> <span class="token punctuation">(</span>result <span class="token operator">==</span> <span class="token keyword">null</span> <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span><span class="token function">tryPushStack</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span><span class="token punctuation">)</span>
                <span class="token function">lazySetNext</span><span class="token punctuation">(</span>c<span class="token punctuation">,</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// clear on failure</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>

    <span class="token comment">/** 如果成功将 c 压入堆栈，则返回 true。 */</span>
    <span class="token keyword">final</span> <span class="token keyword">boolean</span> <span class="token function">tryPushStack</span><span class="token punctuation">(</span><span class="token class-name">Completion</span> c<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token class-name">Completion</span> h <span class="token operator">=</span> stack<span class="token punctuation">;</span>
        <span class="token comment">// CAS 使得 c.next = h = stack</span>
        <span class="token function">lazySetNext</span><span class="token punctuation">(</span>c<span class="token punctuation">,</span> h<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">// 将 this.stack 从 h 替换为 c, 完成 c 操作入栈</span>
        <span class="token keyword">return</span> UNSAFE<span class="token punctuation">.</span><span class="token function">compareAndSwapObject</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> STACK<span class="token punctuation">,</span> h<span class="token punctuation">,</span> c<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    
    <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">lazySetNext</span><span class="token punctuation">(</span><span class="token class-name">Completion</span> c<span class="token punctuation">,</span> <span class="token class-name">Completion</span> next<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    	<span class="token comment">// CAS 使得 c.next = h </span>
        UNSAFE<span class="token punctuation">.</span><span class="token function">putOrderedObject</span><span class="token punctuation">(</span>c<span class="token punctuation">,</span> NEXT<span class="token punctuation">,</span> next<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
</code></pre> 
<h4><a id="23_CompletableFutureUniApplytryFire_793"></a>2.3 CompletableFuture.UniApply#tryFire</h4> 
<p>CompletableFuture.UniApply#tryFire 的实现如下，目的是尝试执行当前操作。：</p> 
<pre><code class="prism language-java">    <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">class</span> <span class="token class-name">UniApply</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span> <span class="token keyword">extends</span> <span class="token class-name">UniCompletion</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span> <span class="token punctuation">{<!-- --></span>
        <span class="token class-name">Function</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span> <span class="token keyword">super</span> <span class="token class-name">T</span><span class="token punctuation">,</span><span class="token operator">?</span> <span class="token keyword">extends</span> <span class="token class-name">V</span><span class="token punctuation">&gt;</span></span> fn<span class="token punctuation">;</span>
        <span class="token comment">// executor : 指定的线程池</span>
        <span class="token comment">// dep ： 承载本次执行的 CompletableFuture，是演示代码中的 thenApply</span>
        <span class="token comment">// src : 本次执行的上游操作, 演示代码中的 supplyAsync</span>
        <span class="token comment">// fn : 要执行的具体操作</span>
        <span class="token class-name">UniApply</span><span class="token punctuation">(</span><span class="token class-name">Executor</span> executor<span class="token punctuation">,</span> <span class="token class-name">CompletableFuture</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span> dep<span class="token punctuation">,</span>
                 <span class="token class-name">CompletableFuture</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">&gt;</span></span> src<span class="token punctuation">,</span>
                 <span class="token class-name">Function</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span> <span class="token keyword">super</span> <span class="token class-name">T</span><span class="token punctuation">,</span><span class="token operator">?</span> <span class="token keyword">extends</span> <span class="token class-name">V</span><span class="token punctuation">&gt;</span></span> fn<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
            <span class="token keyword">super</span><span class="token punctuation">(</span>executor<span class="token punctuation">,</span> dep<span class="token punctuation">,</span> src<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token keyword">this</span><span class="token punctuation">.</span>fn <span class="token operator">=</span> fn<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token comment">// mode ：执行模式 同步(0)、异步(1)、嵌套(-1)。当前调用场景传入的是 0</span>
        <span class="token keyword">final</span> <span class="token class-name">CompletableFuture</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span> <span class="token function">tryFire</span><span class="token punctuation">(</span><span class="token keyword">int</span> mode<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
            <span class="token class-name">CompletableFuture</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span> d<span class="token punctuation">;</span> <span class="token class-name">CompletableFuture</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">&gt;</span></span> a<span class="token punctuation">;</span>
            <span class="token comment">// 【注解1】尝试再次执行是否可以成功，执行失败直接返回 null</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>d <span class="token operator">=</span> dep<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token keyword">null</span> <span class="token operator">||</span>
                <span class="token operator">!</span>d<span class="token punctuation">.</span><span class="token function">uniApply</span><span class="token punctuation">(</span>a <span class="token operator">=</span> src<span class="token punctuation">,</span> fn<span class="token punctuation">,</span> mode <span class="token operator">&gt;</span> <span class="token number">0</span> <span class="token operator">?</span> <span class="token keyword">null</span> <span class="token operator">:</span> <span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
                <span class="token keyword">return</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
            <span class="token comment">// 【注解2】</span>
            dep <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span> src <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span> fn <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
            <span class="token comment">// 【注解3】操作执行成功才会调用到这里 ，a 为上游的 CompletableFuture ，演示代码中的 supplyAsync</span>
            <span class="token keyword">return</span> d<span class="token punctuation">.</span><span class="token function">postFire</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> mode<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
</code></pre> 
<p>下面我们按照注解顺序解释：</p> 
<p><strong>1. 【注解1】：判断如果当前操作是否被执行过了(dep == null) || 当前线程无法处理该操作</strong></p> 
<ul><li><code>(d = dep) == null</code> ：这个判断的作用是判断当前操作是否已经被执行过，如果执行过， dep 会被置为null ，但这个过程并非是原子性的，所以并不能保证线程安全。（注解2的部分）</li><li><code>!d.uniApply(a = src, fn, mode &gt; 0 ? null : this)</code> ： 该方法我们在上面解析过了，如果当前线程获得了执行当前操作的资格则返回 true。这里需要注意的是 当 mode &gt; 0 时 会传入 null ，否则传入this。 关于CompletableFuture 的执行模式，我们本文开始提到过，如下：<pre><code class="prism language-java">	<span class="token comment">// 同步模式 </span>
    <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> SYNC   <span class="token operator">=</span>  <span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token comment">// 异步模式</span>
    <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> ASYNC  <span class="token operator">=</span>  <span class="token number">1</span><span class="token punctuation">;</span>
    <span class="token comment">// 嵌套模式</span>
    <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> NESTED <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>
</code></pre> 当 mode = 0 或 1 时都需要传入 this，因为无论是同步还是嵌套模式都需要保证自己的线程能获取处理当前操作的资格，因为同步和嵌套模式下的调用都可能出现多线程的并发问题。而如果当前操作是同步执行，则当前线程获取到处理权后直接处理，如果当前操作需要异步执行，则将其投递到线程池中支持。而当线程池中的线程触发当前操作时是通过 CompletableFuture.Completion#run 或 CompletableFuture.Completion#exec 方法执行，这两个方法传入的mode = 1， 所以这里实际上只有 ( 异步执行) 时mode = 1 才会传入null。而如果是异步执行 则说明当前操作交由线程池执行，则说明在此之前已经有一个线程获取到了处理该操作的资格并把该操作交由线程池执行，因此已经不存在其他线程与当前线程竞争，也没必要去争取执行权了。</li></ul> 
<p>这里也需要注意：<code>(d = dep) == null</code> 和 <code>!d.uniApply(a = src, fn, mode &gt; 0 ? null : this)</code> 的判断也并非是原子性的，可能存在多个线程同时执行这个操作，真正原子性的保证是在 <code>d.uniApply(a = src, fn, mode &gt; 0 ? null : this)</code> 中的 <code>(c != null &amp;&amp; !c.claim()</code>。</p> 
<hr> 
<p><strong>2. 【注解2】走到这一步说明当前操作已经被当前线程执行结束，所以清空一些属性值，表明当前操作已经死亡（执行结束）。需要注意 CompletableFuture.UniCompletion#isLive 判断操作是否存活的依据就是 dep != null 。CompletableFuture.UniCompletion#isLive 方法会在 CompletableFuture#cleanStack 中用于判断 操作是否存活，不再存活的操作将会被移出栈。</strong></p> 
<hr> 
<p><strong>3. 【注解3】当前操作执行结束后需要一些后置操作，根据模式的不同执行不同的逻辑。下面我们详细来看。</strong></p> 
<hr> 
<h5><a id="231_CompletableFuturepostFire_856"></a>2.3.1 CompletableFuture#postFire</h5> 
<p>CompletableFuture#postFire 是操作执行结束的后置处理，根据模式的不同会执行不同的逻辑，如下：</p> 
<ol><li>如果 前置环节 a 还有操作未完成 ： 
  <ul><li>嵌套模式执行 a.cleanStack();</li><li>同步或异步模式 执行 a.postComplete();，唤醒嵌套调用，执行 a.stack 的操作 。</li></ul> </li><li>如果当前环节尚已经结束 但存在未完成操作： 
  <ul><li>嵌套模式直接返回 this，交由 CompletableFuture#postComplete 的 while 循环来处理（上面我们提到过 CompletableFuture#postComplete 会将当前环节和子环栈清空）</li><li>同步或异步模式调用 postComplete() 执行 this.stack 中操作，因为同步或异步模式则说明当前操作不是清栈行为，则通过 调用 CompletableFuture#postComplete 执行 当前环节的清栈处理。</li></ul> </li></ol> 
<hr> 
<p>下面我们来看具体代码：</p> 
<pre><code class="prism language-java">	<span class="token comment">// tryFire成功后由依赖进行后处理。尝试清理源 a 的堆栈，然后运行 ​​postComplete 或将其返回给调用者，具体取决于模式</span>
    <span class="token keyword">final</span> <span class="token class-name">CompletableFuture</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">&gt;</span></span> <span class="token function">postFire</span><span class="token punctuation">(</span><span class="token class-name">CompletableFuture</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span><span class="token punctuation">&gt;</span></span> a<span class="token punctuation">,</span> <span class="token keyword">int</span> mode<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    	<span class="token comment">// 【注解1】前置环节还有操作未完成，特殊的场景会出现下面细说</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>a <span class="token operator">!=</span> <span class="token keyword">null</span> <span class="token operator">&amp;&amp;</span> a<span class="token punctuation">.</span>stack <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        	<span class="token comment">// 【注解2】根据模式不同选择不同的处理方式 （a.result 必不为空，前面已经判断不为空才会执行当前操作之后才会执行到此）</span>
        	<span class="token comment">// 如果是嵌套模式调用，则清除已完成的栈</span>
        	<span class="token comment">// 如果是同步或异步模式则触发</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>mode <span class="token operator">&lt;</span> <span class="token number">0</span> <span class="token operator">||</span> a<span class="token punctuation">.</span>result <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span>
            	<span class="token comment">// 清除已经完成的栈任务</span>
                a<span class="token punctuation">.</span><span class="token function">cleanStack</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword">else</span>
            	<span class="token comment">// 尝试再次触发a.stack 任务</span>
                a<span class="token punctuation">.</span><span class="token function">postComplete</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token comment">// 【注解3】</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>result <span class="token operator">!=</span> <span class="token keyword">null</span> <span class="token operator">&amp;&amp;</span> stack <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        	<span class="token comment">// 【注解4】 根据模式不同选择不同的处理方式</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>mode <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span>
                <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">;</span>
            <span class="token keyword">else</span>
            	<span class="token comment">// 尝试触发this.stack 任务</span>
                <span class="token function">postComplete</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">return</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
</code></pre> 
<p>我们在上面已经介绍过 CompletableFuture#postComplete 方法的作用：CompletableFuture#postComplete 会将 CompletableFuture 的所有操作出栈执行结束。</p> 
<p>我们按照代码注解顺序来分析：</p> 
<p><strong>1. 【注解1】当前置环节的前置环节还有操作未完成时会进入该分支，在并发的情况下会触发。</strong></p> 
<p><strong>个人理解是通过多线程执行来加快栈处理的过程</strong>，我们用这个简单的例子来解释：</p> 
<pre><code class="prism language-java">    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">InterruptedException</span> <span class="token punctuation">{<!-- --></span>
        <span class="token comment">// 第1行</span>
        <span class="token class-name">CompletableFuture</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">&gt;</span></span> startCF <span class="token operator">=</span> <span class="token class-name">CompletableFuture</span><span class="token punctuation">.</span><span class="token function">supplyAsync</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token string">"start"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">// 第2行</span>
        <span class="token class-name">CompletableFuture</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">&gt;</span></span> a1 <span class="token operator">=</span> startCF<span class="token punctuation">.</span><span class="token function">whenCompleteAsync</span><span class="token punctuation">(</span><span class="token punctuation">(</span>s<span class="token punctuation">,</span> t<span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"A1"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">// 第3行</span>
        <span class="token class-name">CompletableFuture</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">&gt;</span></span> b1 <span class="token operator">=</span> startCF<span class="token punctuation">.</span><span class="token function">whenCompleteAsync</span><span class="token punctuation">(</span><span class="token punctuation">(</span>s<span class="token punctuation">,</span> t<span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"B1"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">// 第4行</span>
        <span class="token class-name">CompletableFuture</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">&gt;</span></span> c1 <span class="token operator">=</span> startCF<span class="token punctuation">.</span><span class="token function">whenCompleteAsync</span><span class="token punctuation">(</span><span class="token punctuation">(</span>s<span class="token punctuation">,</span> t<span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"C1"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">// 第5行</span>
        <span class="token class-name">CompletableFuture</span><span class="token punctuation">.</span><span class="token function">allOf</span><span class="token punctuation">(</span>a1<span class="token punctuation">,</span> b1<span class="token punctuation">,</span> c1<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
</code></pre> 
<ol><li>我们在startCF 后提交了三个异步操作 a1，b1, c1。假设 执行到 第五行时 ，startCF 环节还没有执行结束，那么 startCF 的堆栈中会存在 a1, b1,c1 三个操作待执行，其栈顺序是 c1 -&gt; a1 -&gt; b1。</li><li>当 startCF 执行结束时 ，主线程会执行 CompletableFuture#postComplete 进入清栈操作，此时 c1 出栈（栈先入后出）执行，由于 c1 是异步操作并不会阻塞主线程，主线程继续执行出栈 b1 的过程，此时 c1 操作执行结束，通过 CompletableFuture#postFire 触发后置操作（并且由于是异步操作，这里的mode = 1）</li><li>此时会判断 <code>a != null &amp;&amp; a.stack != null</code> 成立，因为 a 栈中还有一个 a1 未执行，则当前线程也会执行 a.postComplete() 协助清栈操作。</li></ol> 
<p>这样就会存在主线程和 执行 c1 操作的线程同时执行 a.postComplete() 来完成清栈操作，加快清栈效率。</p> 
<p><strong>注： 上面的代码是为了方便解释，下面的代码可以确实复现这种情况：</strong></p> 
<pre><code class="prism language-java">    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">InterruptedException</span> <span class="token punctuation">{<!-- --></span>
        <span class="token class-name">CompletableFuture</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">&gt;</span></span> startCF <span class="token operator">=</span> <span class="token class-name">CompletableFuture</span><span class="token punctuation">.</span><span class="token function">supplyAsync</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token punctuation">{<!-- --></span>
            <span class="token keyword">try</span> <span class="token punctuation">{<!-- --></span>
            	<span class="token comment">// 睡眠2s确保有足够的操作入栈，以进入并发情况</span>
                <span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">2000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
                e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
            <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"START"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword">return</span> <span class="token string">"start"</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">// 模拟高并发，多个操作一直入栈</span>
        <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
            <span class="token class-name">CompletableFuture</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">&gt;</span></span> a1 <span class="token operator">=</span> startCF<span class="token punctuation">.</span><span class="token function">whenCompleteAsync</span><span class="token punctuation">(</span><span class="token punctuation">(</span>s<span class="token punctuation">,</span> t<span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"A1"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
	<span class="token punctuation">}</span>
</code></pre> 
<p><strong>2. 【注解2】这里会根据模式的不同执行不同的逻辑，嵌套模式清理一下无用堆栈即可，异步或同步模式则需要执行CompletableFuture#postComplete 唤醒嵌套模式，为了避免前置环节还有未执行的操作。</strong></p> 
<p>前面我们提到这里可能会有多个线程同时执行，</p> 
<ul><li><strong>嵌套模式 （NESTED）</strong>：执行 <code>a.cleanStack();</code>。我们上面提到过如果 CompletableFuture.Completion#tryFire 处于嵌套模式，则必定是被CompletableFuture#postComplete 调用执行，那么当前仍处于执行 CompletableFuture 堆栈执行过程，那么即是 <code>a.stack != null</code> （a 的存在未执行的操作）之后也会被执行，并且由于可能有多个线程同时执行，所以这里清理下堆栈，以保证多线程执行时不会执行到已经处理过的操作。</li><li><strong>同步或异步模式 （ASYNC 或 SYNC）</strong>：执行 a.postComplete 。上面我们已经举例了什么情况会进入该情况，这里的目的就是为了加快清栈效率。 CompletableFuture#cleanStack 的目的就是清除死亡的堆栈。其逻辑并不复杂，我们只需要知道其判断堆栈是否死亡的依据是 CompletableFuture.Completion#isLive。</li></ul> 
<p><strong>3. 【注解3】是判断当前环节是否执行结束（ result != null ）但存在未执行操作(stack != null)</strong></p> 
<p><strong>4. 【注解4】在满足注解3 的要求下，如果是嵌套模式则直接返回 this（嵌套模式只会在 CompletableFuture#postComplete 中调用，这里返回this 是为了执行 this 的堆栈操作，完成子环节的清栈），同步或者异步模式则调用CompletableFuture#postComplete来执行堆栈中的操作。这里要结合 CompletableFuture#postComplete 方法一起看，是执行清栈操作。</strong></p> 
<hr> 
<h3><a id="3_CompletableFuturejoin_967"></a>3. CompletableFuture#join</h3> 
<p>CompletableFuture#join 和 CompletableFuture#get 的作用相同，都是阻塞获取 CompletableFuture 的执行结果，基本实现和调用方法也类似，不同的是 CompletableFuture#get 会抛出编译时异常，而 CompletableFuture#join 会将异常封装成运行时异常，因此下面我们只看 CompletableFuture#join 的实现 ：</p> 
<pre><code class="prism language-java">	<span class="token comment">// 完成时返回结果值，如果异常完成则抛出（未经检查的）异常。为了更好地符合通用函数形式的使用，如果完成此 CompletableFuture 所涉及的计算引发异常，则此方法将引发（未经检查的） CompletionException ，并将底层异常作为其原因。</span>
    <span class="token keyword">public</span> <span class="token class-name">T</span> <span class="token function">join</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token class-name">Object</span> r<span class="token punctuation">;</span>
        <span class="token comment">// 如果 result  不为空直接返回，为空则调用 waitingGet(false) 等待</span>
        <span class="token keyword">return</span> <span class="token function">reportJoin</span><span class="token punctuation">(</span><span class="token punctuation">(</span>r <span class="token operator">=</span> result<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token keyword">null</span> <span class="token operator">?</span> <span class="token function">waitingGet</span><span class="token punctuation">(</span><span class="token boolean">false</span><span class="token punctuation">)</span> <span class="token operator">:</span> r<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token comment">// 解码结果以返回结果或抛出未经检查的异常</span>
    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">&gt;</span></span> <span class="token class-name">T</span> <span class="token function">reportJoin</span><span class="token punctuation">(</span><span class="token class-name">Object</span> r<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    	<span class="token comment">// 如果结果类型AltResult，则要么执行结果是 null，要么执行过程出现异常</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>r <span class="token keyword">instanceof</span> <span class="token class-name">AltResult</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
            <span class="token class-name">Throwable</span> x<span class="token punctuation">;</span>
            <span class="token comment">// 没出现异常，则返回null</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>x <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token class-name">AltResult</span><span class="token punctuation">)</span>r<span class="token punctuation">)</span><span class="token punctuation">.</span>ex<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span>
                <span class="token keyword">return</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
            <span class="token comment">// 抛出异常</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>x <span class="token keyword">instanceof</span> <span class="token class-name">CancellationException</span><span class="token punctuation">)</span>
                <span class="token keyword">throw</span> <span class="token punctuation">(</span><span class="token class-name">CancellationException</span><span class="token punctuation">)</span>x<span class="token punctuation">;</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>x <span class="token keyword">instanceof</span> <span class="token class-name">CompletionException</span><span class="token punctuation">)</span>
                <span class="token keyword">throw</span> <span class="token punctuation">(</span><span class="token class-name">CompletionException</span><span class="token punctuation">)</span>x<span class="token punctuation">;</span>
            <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">CompletionException</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token annotation punctuation">@SuppressWarnings</span><span class="token punctuation">(</span><span class="token string">"unchecked"</span><span class="token punctuation">)</span> <span class="token class-name">T</span> t <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name">T</span><span class="token punctuation">)</span> r<span class="token punctuation">;</span>
        <span class="token keyword">return</span> t<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>


</code></pre> 
<p>可以看到具体的实现逻辑都在 CompletableFuture#waitingGet 中。</p> 
<h4><a id="31__CompletableFuturewaitingGet_1004"></a>3.1 CompletableFuture#waitingGet</h4> 
<p>CompletableFuture#waitingGet 实现如下：</p> 
<pre><code class="prism language-java">	<span class="token comment">// 等待后返回原始结果，如果可中断且被中断，则返回 null。</span>
    <span class="token keyword">private</span> <span class="token class-name">Object</span> <span class="token function">waitingGet</span><span class="token punctuation">(</span><span class="token keyword">boolean</span> interruptible<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token class-name">Signaller</span> q <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
        <span class="token keyword">boolean</span> queued <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
        <span class="token keyword">int</span> spins <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>
        <span class="token class-name">Object</span> r<span class="token punctuation">;</span>
        <span class="token comment">// 【注解1】当前环节未完成(result = null ) 则一直 while</span>
        <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>r <span class="token operator">=</span> result<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        	<span class="token comment">// 【注解2】 ： 自旋等待</span>
        	<span class="token comment">//spins  默认 -1： 所以这里必然进入，判断是否是多核</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>spins <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span>
            	<span class="token comment">// 给 spins  赋值。 spins = 多核 ? 256 : 0 </span>
            	<span class="token comment">// 在多处理器上使用短暂的自旋等待</span>
                spins <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name">Runtime</span><span class="token punctuation">.</span><span class="token function">getRuntime</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">availableProcessors</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&gt;</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">?</span>
                    <span class="token number">1</span> <span class="token operator">&lt;&lt;</span> <span class="token number">8</span> <span class="token operator">:</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token comment">// Use brief spin-wait on multiprocessors</span>
             <span class="token comment">// 当 spins &gt; 0 (多核场景) 进入</span>
            <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>spins <span class="token operator">&gt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
            	<span class="token comment">// 自旋等待</span>
                <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token class-name">ThreadLocalRandom</span><span class="token punctuation">.</span><span class="token function">nextSecondarySeed</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&gt;=</span> <span class="token number">0</span><span class="token punctuation">)</span>
                    <span class="token operator">--</span>spins<span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
            <span class="token comment">// 【注解3】 q 初始化并且将q 入栈到 this </span>
            <span class="token comment">// 对 q 进行初始化</span>
            <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>q <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span>
            	<span class="token comment">// q 默认为空 所以这里会初始化 </span>
                q <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Signaller</span><span class="token punctuation">(</span>interruptible<span class="token punctuation">,</span> <span class="token number">0L</span><span class="token punctuation">,</span> <span class="token number">0L</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token comment">// 如果 q 没入栈，则入栈</span>
            <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>queued<span class="token punctuation">)</span>
            	<span class="token comment">//  尝试将q 入栈</span>
                queued <span class="token operator">=</span> <span class="token function">tryPushStack</span><span class="token punctuation">(</span>q<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token comment">// 【注解4】如果当前任务可终止 &amp;&amp; 当前线程已经被终止</span>
            <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>interruptible <span class="token operator">&amp;&amp;</span> q<span class="token punctuation">.</span>interruptControl <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
            	<span class="token comment">// 清理线程，方便gc，同时宣告 q 操作已经死亡</span>
                q<span class="token punctuation">.</span>thread <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
                <span class="token comment">// 清理堆栈</span>
                <span class="token function">cleanStack</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token comment">// 返回 null</span>
                <span class="token keyword">return</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
            <span class="token comment">// 【注解5】当前线程未被终止 &amp;&amp; 当前环节还未结束</span>
            <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>q<span class="token punctuation">.</span>thread <span class="token operator">!=</span> <span class="token keyword">null</span> <span class="token operator">&amp;&amp;</span> result <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
                <span class="token keyword">try</span> <span class="token punctuation">{<!-- --></span>
                	<span class="token comment">// 通过   ForkJoinPool.managedBlock 来确保线程没有被阻塞</span>
                    <span class="token class-name">ForkJoinPool</span><span class="token punctuation">.</span><span class="token function">managedBlock</span><span class="token punctuation">(</span>q<span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> ie<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
                	<span class="token comment">// 出现异常,置为 false</span>
                    q<span class="token punctuation">.</span>interruptControl <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>
                <span class="token punctuation">}</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
        <span class="token comment">// 【注解6】 this 环节结束，执行收尾工作</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>q <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
            q<span class="token punctuation">.</span>thread <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>q<span class="token punctuation">.</span>interruptControl <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
                <span class="token keyword">if</span> <span class="token punctuation">(</span>interruptible<span class="token punctuation">)</span>
                    r <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span> <span class="token comment">// report interruption</span>
                <span class="token keyword">else</span>
                    <span class="token comment">// 修改当前线程中断标志位，告知线程被终止</span>
                	<span class="token comment">// 如果当前线程处于阻塞状态则退出阻塞状态并抛出  InterruptedException 异常</span>
                	<span class="token comment">// 如果当前线程非阻塞状态，则修改当前线程中断标志位为 true，线程会继续执行</span>
                    <span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">interrupt</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
        <span class="token comment">// 进行一次清栈操作</span>
        <span class="token function">postComplete</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">// 返回结果值</span>
        <span class="token keyword">return</span> r<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
</code></pre> 
<hr> 
<p><strong>1.【注解1】：进入 while 循环的条件是 result = null。即当前环节尚未执行结束。同时我们可以知道，执行具体的线程和调用 CompletableFuture#join 必然不是一个线程。</strong></p> 
<p>如下：</p> 
<ul><li>对于a1来说，由于其操作是同步执行(whenComplete)，所以当执行到 <code>a1.join();</code> 时，a1 环节已经执行结束 ，result != null。</li><li>对于b1 来说,其操作未异步操作（whenCompleteAsync），所以当执行到 <code>b1.join();</code> 时，b1 环境不一定已经结束，所以 reuslt 存在为空的可能。</li></ul> 
<pre><code class="prism language-java">    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token class-name">CompletableFuture</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">&gt;</span></span> startCF <span class="token operator">=</span> <span class="token class-name">CompletableFuture</span><span class="token punctuation">.</span><span class="token function">supplyAsync</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token string">"start"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        
        <span class="token class-name">CompletableFuture</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">&gt;</span></span> a1 <span class="token operator">=</span> startCF<span class="token punctuation">.</span><span class="token function">whenComplete</span><span class="token punctuation">(</span><span class="token punctuation">(</span>s<span class="token punctuation">,</span> t<span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"A1"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        a1<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token class-name">CompletableFuture</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">&gt;</span></span> b1 <span class="token operator">=</span> startCF<span class="token punctuation">.</span><span class="token function">whenCompleteAsync</span><span class="token punctuation">(</span><span class="token punctuation">(</span>s<span class="token punctuation">,</span> t<span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"B1"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        b1<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
</code></pre> 
<p><strong>2.【注解2】：如果是多核，则进行自旋等待。加入这个自旋，是为了稍晚一点执行后续逻辑中的 park 代码，这个稍重一点的操作。</strong></p> 
<p><strong>2.【注解3】：初始化 q， 并将 q 入栈到 this中。这里 q 的类型是 CompletableFuture.Signaller，关于这个类我们在下面会详细介绍，Signaller 的作用是和 <code>ForkJoinPool.managedBlock(q);</code> 联合起来判断执行操作的线程是否被阻塞，以及是否需要创建补偿线程。</strong></p> 
<p><strong>4.【注解4】：想要进入这个分支有满足 <code>interruptible &amp;&amp; q.interruptControl &lt; 0</code> 条件，进入这个分支说明当前任务允许终止并且当前线程的任务被终止了。</strong></p> 
<ol><li><code>interruptible = true</code> ：说明当前任务允许被终止，该值是 CompletableFuture#waitingGet 的入参，在CompletableFuture#join 中默认传入 false， 在 CompletableFuture#join 中传入 true</li><li><code>q.interruptControl &lt; 0</code> ：当前线程已经被执行过终止操作。</li></ol> 
<p>而进入此分支后会执行如下代码来完善终止操作：</p> 
<pre><code class="prism language-java">		<span class="token comment">// 清空线程，q 是否存活的判断依据就是 q.thread 是否为 null</span>
        q<span class="token punctuation">.</span>thread <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
        <span class="token comment">// 清除 this 中的死亡堆栈，这里一定会把 q 清除掉，因为 q 已经死亡</span>
        <span class="token function">cleanStack</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">// 返回null，，因为任务被终止</span>
        <span class="token keyword">return</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
</code></pre> 
<p><strong>5.【注解5】：当 <code>q.thread != null &amp;&amp; result == null</code> （q操作未死亡 &amp;&amp; this 环节还未执行结束）时进入此分支，到这里才真正算是对正常场景的处理：通过 ForkJoinPool#managedBlock 来保证 cpu 吞吐量。</strong></p> 
<p>这部分代码如下：</p> 
<pre><code class="prism language-java">         <span class="token keyword">try</span> <span class="token punctuation">{<!-- --></span>
             <span class="token class-name">ForkJoinPool</span><span class="token punctuation">.</span><span class="token function">managedBlock</span><span class="token punctuation">(</span>q<span class="token punctuation">)</span><span class="token punctuation">;</span>
         <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> ie<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
             q<span class="token punctuation">.</span>interruptControl <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>
         <span class="token punctuation">}</span>
</code></pre> 
<p>ForkJoinPool#managedBlock 会判断当前线程是否被阻塞，如果被阻塞并且线程类型是 ForkJoinWorkerThread 则会尝试创建补偿线程，否则等待阻塞结束。</p> 
<p><strong>5.【注解5】：到达这一步说明 this 已经直接结束，真正的收尾工作</strong></p> 
<pre><code class="prism language-java">        <span class="token keyword">if</span> <span class="token punctuation">(</span>q <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        	<span class="token comment">// q.thread 置为空，表示q 死亡</span>
            q<span class="token punctuation">.</span>thread <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
            <span class="token comment">// 如果 q 被中断了</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>q<span class="token punctuation">.</span>interruptControl <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
            	<span class="token comment">// 如果当前是可中断的返回 null</span>
                <span class="token keyword">if</span> <span class="token punctuation">(</span>interruptible<span class="token punctuation">)</span>
                    r <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span> <span class="token comment">// report interruption</span>
                <span class="token keyword">else</span>
                	<span class="token comment">// 修改当前线程中断标志位，告知线程被终止，交由调用者来处理具体的情况</span>
                	<span class="token comment">// 如果当前线程处于阻塞状态则退出阻塞状态并抛出  InterruptedException 异常</span>
                	<span class="token comment">// 如果当前线程非阻塞状态，则修改当前线程中断标志位为 true，线程会继续执行</span>
                    <span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">interrupt</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
</code></pre> 
<h5><a id="311_CompletableFutureSignaller___1167"></a>3.1.1 CompletableFuture.Signaller 的作用</h5> 
<p><strong>以下，是个人的理解和推测，可能会出现错误，感谢指正。</strong></p> 
<p>CompletableFuture.Signaller 实现如下：</p> 
<pre><code class="prism language-java">	<span class="token comment">// 完成记录和释放等待线程。此类实现 ManagedBlocker 以避免在 ForkJoinPools 中堆积的阻塞操作时出现饥饿。</span>
    <span class="token annotation punctuation">@SuppressWarnings</span><span class="token punctuation">(</span><span class="token string">"serial"</span><span class="token punctuation">)</span>
    <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">class</span> <span class="token class-name">Signaller</span> <span class="token keyword">extends</span> <span class="token class-name">Completion</span>
        <span class="token keyword">implements</span> <span class="token class-name">ForkJoinPool<span class="token punctuation">.</span>ManagedBlocker</span> <span class="token punctuation">{<!-- --></span>
        <span class="token keyword">long</span> nanos<span class="token punctuation">;</span>                    <span class="token comment">// wait time if timed</span>
        <span class="token keyword">final</span> <span class="token keyword">long</span> deadline<span class="token punctuation">;</span>           <span class="token comment">// non-zero if timed</span>
        <span class="token keyword">volatile</span> <span class="token keyword">int</span> interruptControl<span class="token punctuation">;</span> <span class="token comment">// &gt; 0: interruptible, &lt; 0: interrupted</span>
        <span class="token keyword">volatile</span> <span class="token class-name">Thread</span> thread<span class="token punctuation">;</span>
		<span class="token comment">// interruptible ： 任务是否可终止</span>
		<span class="token comment">// nanos : 阻塞等待时间（0一直等待）</span>
		<span class="token comment">// deadline : 死亡时间，到达这个时间不再等待</span>
        <span class="token class-name">Signaller</span><span class="token punctuation">(</span><span class="token keyword">boolean</span> interruptible<span class="token punctuation">,</span> <span class="token keyword">long</span> nanos<span class="token punctuation">,</span> <span class="token keyword">long</span> deadline<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        	<span class="token comment">// 缓存当前线程，该线程是调用 join 方法的线程</span>
            <span class="token keyword">this</span><span class="token punctuation">.</span>thread <span class="token operator">=</span> <span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token comment">// 1 : 任务可终止，0 任务不可终止，-1 任务需要终止</span>
            <span class="token keyword">this</span><span class="token punctuation">.</span>interruptControl <span class="token operator">=</span> interruptible <span class="token operator">?</span> <span class="token number">1</span> <span class="token operator">:</span> <span class="token number">0</span><span class="token punctuation">;</span>
            <span class="token keyword">this</span><span class="token punctuation">.</span>nanos <span class="token operator">=</span> nanos<span class="token punctuation">;</span>
            <span class="token keyword">this</span><span class="token punctuation">.</span>deadline <span class="token operator">=</span> deadline<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token comment">// 触发操作，这里的操作即是通过 LockSupport.unpark(w); 唤醒 w 线程。</span>
        <span class="token comment">// 调用该方法的线程一定不是w 线程</span>
        <span class="token keyword">final</span> <span class="token class-name">CompletableFuture</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span><span class="token punctuation">&gt;</span></span> <span class="token function">tryFire</span><span class="token punctuation">(</span><span class="token keyword">int</span> ignore<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
            <span class="token class-name">Thread</span> w<span class="token punctuation">;</span> <span class="token comment">// no need to atomically claim</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>w <span class="token operator">=</span> thread<span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
                thread <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
                <span class="token comment">// 唤醒 w 线程</span>
                <span class="token class-name">LockSupport</span><span class="token punctuation">.</span><span class="token function">unpark</span><span class="token punctuation">(</span>w<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
            <span class="token keyword">return</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token comment">// 判断当前线程是否需要阻塞， true 表示不需要阻塞</span>
        <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">isReleasable</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        	<span class="token comment">// 线程为空，表明当前  Signaller  已经死亡（执行结束），所以未阻塞</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>thread <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span>
                <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
           	<span class="token comment">// 判断当前线程是否被标记了中断，如果中断并且允许中断则表明未阻塞</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">interrupted</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
                <span class="token keyword">int</span> i <span class="token operator">=</span> interruptControl<span class="token punctuation">;</span>
                <span class="token comment">// 标志位 -1，表示任务已经被终止</span>
                interruptControl <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>
                <span class="token comment">// i &gt; 0  表示当前任务允许被终止，返回 true</span>
                <span class="token keyword">if</span> <span class="token punctuation">(</span>i <span class="token operator">&gt;</span> <span class="token number">0</span><span class="token punctuation">)</span>
                    <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
            <span class="token comment">// 判断是否已经到达死亡时间(设置的最大等待时间), 达到时间说明</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>deadline <span class="token operator">!=</span> <span class="token number">0L</span> <span class="token operator">&amp;&amp;</span>
                <span class="token punctuation">(</span>nanos <span class="token operator">&lt;=</span> <span class="token number">0L</span> <span class="token operator">||</span> <span class="token punctuation">(</span>nanos <span class="token operator">=</span> deadline <span class="token operator">-</span> <span class="token class-name">System</span><span class="token punctuation">.</span><span class="token function">nanoTime</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">&lt;=</span> <span class="token number">0L</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
                <span class="token comment">// 线程置为空</span>
                thread <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
                
                <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
            <span class="token comment">// 返回 false</span>
            <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        
        <span class="token comment">// 判读当前线程是否需要额外阻塞，true表示不需要，false 表示需要,</span>
        <span class="token comment">// 如果返回false在 ForkJoinPool#managedBlock 中会通过while 阻塞</span>
        <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">block</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        	<span class="token comment">// 当前线程不需要阻塞</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">isReleasable</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
                <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
             <span class="token comment">// deadline  = 0 表明没有设置超时时间，通过 LockSupport.park(this);阻塞当前线程</span>
            <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>deadline <span class="token operator">==</span> <span class="token number">0L</span><span class="token punctuation">)</span>
            	<span class="token comment">// 阻塞当前线程</span>
                <span class="token class-name">LockSupport</span><span class="token punctuation">.</span><span class="token function">park</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>nanos <span class="token operator">&gt;</span> <span class="token number">0L</span><span class="token punctuation">)</span>
            	<span class="token comment">// nanos  表示阻塞剩余时间，通过 LockSupport.parkNanos(this, nanos); 阻塞当前线程 </span>
                <span class="token class-name">LockSupport</span><span class="token punctuation">.</span><span class="token function">parkNanos</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> nanos<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token comment">// 再次判断当前线程是否需要阻塞</span>
            <span class="token keyword">return</span> <span class="token function">isReleasable</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        
        <span class="token comment">// 判断当前操作是否还存货</span>
        <span class="token keyword">final</span> <span class="token keyword">boolean</span> <span class="token function">isLive</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span> <span class="token keyword">return</span> thread <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>

</code></pre> 
<p>这里我们来看 Signaller 的三个方法</p> 
<ol><li><strong>CompletableFuture.Signaller#tryFire</strong> ：Signaller 对 CompletableFuture#tryFire 方法的具体实现，其实现是通过 LockSupport.unpark(w); 来唤醒 线程w，这里的w 是 Signaller 初始化时的线程，是调用 CompletableFuture#join 的方法的线程。需要注意我们上面提到过，如果能进入CompletableFuture#waitingGet 的while 循环则说明 当前操作的调用是异步的，即 调用 CompletableFuture.Signaller#tryFire 方法的线程必定不是 w 线程。</li><li><strong>CompletableFuture.Signaller#isReleasable</strong> ：判断当前线程是否可释放，如果不可释放则认为需要返回 false。Signaller 操作已经结束 || 线程被终止并且允许终止 || Signaller 操作已经超时 都认为当前线程未被阻塞，返回 true。</li><li><strong>CompletableFuture.Signaller#block</strong> ：判读当前线程是否需要额外的阻塞，如果返回 true，则表明不需要额外阻塞，如果返回 false 在 ForkJoinPool#managedBlock 会通过while 循环进行阻塞。</li></ol> 
<hr> 
<p>我们结合 ForkJoinPool#managedBlock来看下</p> 
<pre><code class="prism language-java">    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">managedBlock</span><span class="token punctuation">(</span><span class="token class-name">ManagedBlocker</span> blocker<span class="token punctuation">)</span>
        <span class="token keyword">throws</span> <span class="token class-name">InterruptedException</span> <span class="token punctuation">{<!-- --></span>
        <span class="token class-name">ForkJoinPool</span> p<span class="token punctuation">;</span>
        <span class="token class-name">ForkJoinWorkerThread</span> wt<span class="token punctuation">;</span>
        <span class="token class-name">Thread</span> t <span class="token operator">=</span> <span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">// 判断当前线程类型，如果是 ForkJoinWorkerThread 线程 并且线程池不为空</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>t <span class="token keyword">instanceof</span> <span class="token class-name">ForkJoinWorkerThread</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span>
            <span class="token punctuation">(</span>p <span class="token operator">=</span> <span class="token punctuation">(</span>wt <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name">ForkJoinWorkerThread</span><span class="token punctuation">)</span>t<span class="token punctuation">)</span><span class="token punctuation">.</span>pool<span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
            <span class="token class-name">WorkQueue</span> w <span class="token operator">=</span> wt<span class="token punctuation">.</span>workQueue<span class="token punctuation">;</span>
            <span class="token comment">// 判断当前线程是否阻塞，返回false则说明需要阻塞进入while 循环</span>
            <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">!</span>blocker<span class="token punctuation">.</span><span class="token function">isReleasable</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
            	<span class="token comment">// 进入这里说明线程阻塞了，尝试创建补偿线程</span>
                <span class="token keyword">if</span> <span class="token punctuation">(</span>p<span class="token punctuation">.</span><span class="token function">tryCompensate</span><span class="token punctuation">(</span>w<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
                    <span class="token keyword">try</span> <span class="token punctuation">{<!-- --></span>
                    	<span class="token comment">// 当 线程处于需要阻塞 &amp;&amp;  当前线程需要额外阻塞，通过while 循环阻塞线程</span>
                        <span class="token keyword">do</span> <span class="token punctuation">{<!-- --></span><span class="token punctuation">}</span> <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">!</span>blocker<span class="token punctuation">.</span><span class="token function">isReleasable</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span>
                                     <span class="token operator">!</span>blocker<span class="token punctuation">.</span><span class="token function">block</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                    <span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{<!-- --></span>
                    	<span class="token comment">// //线程池的活动线程数+1</span>
                        <span class="token class-name">U</span><span class="token punctuation">.</span><span class="token function">getAndAddLong</span><span class="token punctuation">(</span>p<span class="token punctuation">,</span> CTL<span class="token punctuation">,</span> AC_UNIT<span class="token punctuation">)</span><span class="token punctuation">;</span>
                    <span class="token punctuation">}</span>
                    <span class="token keyword">break</span><span class="token punctuation">;</span>
                <span class="token punctuation">}</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">else</span> <span class="token punctuation">{<!-- --></span>
        	<span class="token comment">// 线程类型不是 ForkJoinWorkerThread 则不能创建补偿线程只能阻塞。</span>
            <span class="token keyword">do</span> <span class="token punctuation">{<!-- --></span><span class="token punctuation">}</span> <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">!</span>blocker<span class="token punctuation">.</span><span class="token function">isReleasable</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span>
                         <span class="token operator">!</span>blocker<span class="token punctuation">.</span><span class="token function">block</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
</code></pre> 
<hr> 
<p>这里来总结下 CompletableFuture.Signaller 使用的目的：为了确保调用线程没有阻塞以及挂起线程等待任务结束，如果阻塞在允许的情况下创建补偿线程以保证效率。</p> 
<ol><li>当我们通过主线程（我们假设是 A 线程） 调用 CompletableFuture#join 方法时，会执行以下逻辑</li><li>当我们进入到CompletableFuture#waitingGet 的 while循环时则说明调用 CompletableFuture#join 的线程（ A 线程 ）和 调用 CompletableFuture.Signaller#tryFire 方法的线程（我们假设是 B 线程）不是一个线程。因为如果是同一个线程则 调用到 CompletableFuture#join 时 环节已经执行结束，reuslt 不会为空。</li><li>随后会初始化 CompletableFuture.Signaller 并入栈到当前 CompletableFuture中。当 this 环节直接结束时( this.result != null) 会执行清栈操作，即倒是会将 Signaller 出栈处理，换句话说，如果 Signaller 出栈执行时，就说明 this 环节已经结束了。</li><li>当 CompletableFuture#join 执行到 ForkJoinPool#managedBlock时， ForkJoinPool#managedBlock 会调用 CompletableFuture.Signaller#isReleasable 和 CompletableFuture.Signaller#block 方法，其中 CompletableFuture.Signaller#block 方法会通过 LockSupport#park 阻塞当前调用线程 （即线程A），此时线程A 会一直阻塞挂起。当 CompletableFuture.Signaller#tryFire 方法被调用时（线程B调用）会通过LockSupport#unpark 唤醒线程A。而 Signaller#tryFire 被调用则说明 this 环节已经结束， 线程A 继续执行会跳出 ForkJoinPool#managedBlock 中的阻塞循环，从而顺利的完成后续操作。</li><li>至此，通过 ForkJoinPool#managedBlock 和 CompletableFuture.Signaller 完成了自身的任务：挂起调用线程等待任务结束，并且在满足条件的场景下会创建补偿线程。</li></ol> 
<p>ForkJoinPool#managedBlock 针对 ForkJoinWorkerThread 线程会创建补偿线程，关于 ForkJoinPool#managedBlock 补偿线程的具体描述详参 <a href="https://blog.csdn.net/heng_zou/article/details/118193846">关于ForkJoinPool使用ManagedBlocker防线程阻塞而降低吞吐量的说明</a>，本文篇幅所限，不再赘述。</p> 
<hr> 
<p><strong>以上：内容部分参考<br> <a href="https://blog.csdn.net/PNGYUL/article/details/119838961">https://blog.csdn.net/PNGYUL/article/details/119838961</a><br> <a href="https://blog.csdn.net/wenhonglian/article/details/119962525">https://blog.csdn.net/wenhonglian/article/details/119962525</a><br> <a href="https://blog.csdn.net/MSSPLANET/article/details/121487012">https://blog.csdn.net/MSSPLANET/article/details/121487012</a><br> <a href="https://blog.csdn.net/java_xiaoo/article/details/120668986">https://blog.csdn.net/java_xiaoo/article/details/120668986</a><br> 如有侵扰，联系删除。 内容仅用于自我记录学习使用。如有错误，欢迎指正</strong></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/93987a0ec7992f723a1c4d1ab6b3dc00/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">JAVA编译出现 错误: 非法字符: ‘\uff1b‘</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/2e798a70349225405353d8066a01fc99/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">Java基础 : CompletableFuture① 基础使用</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>