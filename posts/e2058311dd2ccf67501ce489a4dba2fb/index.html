<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>C语言浮点数的精度丢失 - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="C语言浮点数的精度丢失" />
<meta property="og:description" content="一-----先来看一段代码 #include&lt;stdio.h&gt; int main() { double test=0.1; printf(&#34;%.100lf&#34;,test); return 0; } 运行结果：
直接从现象说结果：精度丢失由于计算机二进制转化过程中因为比特位过多发生数据的截断导致的，这个结果是可以偏大也可以偏小的。
解释一下：首先要知道二进制转换为十进制的基本方法（除二取余法，乘五取余法等等），最好再了解一下浮点数的存储，这里的0.1就是一个典型的例子，对0.1乘五取余是乘不尽的，那么数据转化成的二进制序列的长度就会超出double的范围。那么多出的数据就会被截断。
二-----如何解决 如果你想的是彻底让屏幕显示出来的是0.1，那么，你不孤单，我一开始也是这样想的，但是这是不可能的。但是这个对我们的实际意义不大，毕竟有效的区段还是够的。
我在这里具体要解决的是两个问题
（1）浮点数的大小比较 #include&lt;stdio.h&gt; int main() { double test=0.1; if(test==(1-0.9)) { printf(&#34;正常&#34;); } else { printf(&#34;what!!!&#34;); } return 0; } 这段代码会输出“what!”。为什么上面已经说了0.1乘不尽，这里换成0.5是OK的，因为0.5D用二进制表示就是0.1B。每次都考虑乘不尽不烦吗？
解决方案 引入库函数&lt;float.h&gt;里定义的宏DBL_EPSILON。
这里后面的一段英文是他是导致x&#43;n!=x的最小值 （n代表EPSILON伊普西隆，x是任意值）
也就是说，任意一个比EPSILON小的值，你给一个数加上，都不会改变它的值。
那么，比EPSILON小的值引起的精度丢失都是在我们的允许范围内的
#include&lt;stdio.h&gt; #include&lt;float.h&gt; #include&lt;math.h&gt; int main() { double test = 0.1; if (fabs(test - (1 - 0.9)) &lt; DBL_EPSILON) { printf(&#34;正常&#34;); } else { printf(&#34;what!!!&#34;); } return 0; } 上图有两个点" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/e2058311dd2ccf67501ce489a4dba2fb/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-01-11T20:00:01+08:00" />
<meta property="article:modified_time" content="2022-01-11T20:00:01+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">C语言浮点数的精度丢失</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <h2><span style="color:#a2e043;">一-----先来看一段代码</span></h2> 
<pre><code>#include&lt;stdio.h&gt;
int main()
{
    double test=0.1;
    printf("%.100lf",test);
    return 0;
}</code></pre> 
<p>运行结果：<img alt="" height="27" src="https://images2.imgbox.com/70/7c/zCM5xMWK_o.png" width="639"></p> 
<p> 直接从现象说结果：精度丢失由于计算机二进制转化过程中因为比特位过多发生<span style="color:#ff9900;">数据的截断</span>导致的，这个结果是<span style="color:#ff9900;">可以偏大也可以偏小</span>的。</p> 
<p>解释一下：首先要知道二进制转换为十进制的基本方法（除二取余法，乘五取余法等等），最好再了解一下浮点数的存储，这里的0.1就是一个典型的例子，对0.1乘五取余是乘不尽的，那么数据转化成的二进制序列的长度就会超出double的范围。那么多出的数据就会被截断。</p> 
<hr> 
<h2><span style="color:#a2e043;">二-----如何解决</span></h2> 
<p><span style="color:#0d0016;">如果你想的是彻底让屏幕显示出来的是0.1，那么，你不孤单，我一开始也是这样想的，但是这是</span><span style="color:#ff9900;">不可能</span><span style="color:#0d0016;">的。但是这个对我们的实际意义不大，毕竟有效的区段还是够的。</span></p> 
<p><span style="color:#0d0016;">我在这里具体要解决的是</span><span style="color:#ff9900;"><strong>两个问题</strong></span></p> 
<h2><span style="color:#0d0016;">（1）浮点数的大小比较</span></h2> 
<pre><code>#include&lt;stdio.h&gt;
int main()
{
    double test=0.1;
    if(test==(1-0.9))
    {
        printf("正常");
    }
    else
    {
        printf("what!!!");
    }
    return 0;
}</code></pre> 
<p>这段代码会输出“<span style="color:#0d0016;">what!”</span>。为什么上面已经说了0.1乘不尽，这里换成0.5是OK的，因为0.5D用二进制表示就是0.1B。每次都考虑乘不尽不烦吗？</p> 
<h3><span style="color:#0d0016;">解决方案</span></h3> 
<p><span style="color:#0d0016;">引入库函数&lt;float.h&gt;里定义的宏DBL_EPSILON。</span></p> 
<p><img alt="" height="35" src="https://images2.imgbox.com/b0/32/n6XTSRKd_o.png" width="1158"></p> 
<p> 这里后面的一段英文是他是<strong><span style="color:#fe2c24;">导致x+n!=x的最小值  </span></strong><span style="color:#0d0016;">（n代表EPSILON伊普西隆，x是任意值）</span></p> 
<p><span style="color:#0d0016;">也就是说，任意一个比EPSILON小的值，你给一个数加上，都不会改变它的值。</span></p> 
<p><span style="color:#0d0016;">那么，比EPSILON小的值引起的精度丢失都是在我们的允许范围内的</span></p> 
<pre><code>#include&lt;stdio.h&gt;
#include&lt;float.h&gt;
#include&lt;math.h&gt;
int main()
{
    double test = 0.1;
    if (fabs(test - (1 - 0.9)) &lt; DBL_EPSILON)
    {
        printf("正常");
    }
    else
    {
        printf("what!!!");
    }
    return 0;
}</code></pre> 
<p>上图有两个点</p> 
<h3>1 。在&lt;math.h&gt;下的fabs（a）即取a的绝对值</h3> 
<p>想象一根数轴，他们相减的绝对值就是他们的距离</p> 
<h3>2 。 if（fabs（test-(1-0.9)&lt;DBL_EPSILON））</h3> 
<p>等价于（test==1-0.9）（当然是对我们     人     而言）</p> 
<p>test和（1-0.9）的距离若是小于DBL_EPSILON,那么精度的丢失是在可控范围内的，说明他们俩相等</p> 
<h3><span style="color:#a2e043;"><strong>（2）含浮点数的表达式和0.0的比较</strong></span></h3> 
<p><span style="color:#0d0016;">要先把上面的搞明白。</span></p> 
<p><span style="color:#0d0016;">之所以单独说这个问题，我是想强调一个数字与零作比较到底应该是</span><span style="color:#fe2c24;">a&lt;DBL_EPSILON还是a&lt;=DBL_EPSILON</span><span style="color:#0d0016;">，加强一下理解</span></p> 
<p><span style="color:#0d0016;">EPSILON是允许范围内的最小值（回到宏定义后面的解释），所以这个等于不可以加，加了说明上面的a如果等于EPSILION时，会导致数值的改变。</span></p> 
<hr> 
<hr> 
<hr> 
<p>想要彻底解决精度丢失，是不可能的，也没必要，但我们有办法用近似来解决。</p> 
<p><span style="color:#956fe7;"><strong>如果看完这篇文章你还是很迷糊，但我还是想说这是不能彻底解决的(我一开始也有这种想法)，那么希望下次我准备出的</strong></span><span style="color:#a2e043;"><strong>数据的存取</strong></span><span style="color:#956fe7;"><strong>能对你有帮助。篇幅太长了，所以删删减减还是准备放到下次。</strong></span></p> 
<p>如果有错误，感谢指出。</p> 
<p><span style="color:#956fe7;"><strong>最后感谢您的时间。</strong></span></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/dfb8fda8a72584162b79ae1f83ad0fdf/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">std::enable_if_t MacOS相关问题: no template named ‘enable_if_t‘ in namespace ‘std‘</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/bd4b49e47461bc9403f2d5df4c97d2c8/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">Python入门之print()函数</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>