<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>图解TCP滑动窗口！一分钟搞清楚知识点 - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="图解TCP滑动窗口！一分钟搞清楚知识点" />
<meta property="og:description" content="【产生背景】
TCP 以1个段为单位，每发一个就需要进行一个确认应答的处理，这样的传输方式有一个缺点：包的往返时间越长通信性能就越低。 ***打个比方好比两个人对话：张三说完一句话，得到李四的确认回答，张三才能说下一句。每一次都是你一句话我一句确认，沟通方式非常低下。
【机制介绍】
为解决这个问题，TCP 引人了“窗口“这个概念，它是操作系统开辟的一个缓存空间，即使RTT（往返时间）较长也能控制网络性能的下降。确认应答以更大的单位进行确认，也就是说，发送端主机在发送了1个TCP段以后不必要一直等待确认应答而是继续发送，转发时间将会被大幅度的缩短。
***也就是张三可以一次性连续说多句话，然后一次性等待李四回复OK就行，李四听不清楚的就重新说，完全听清楚了就继续往下说！
窗口大小就是指无需等待确认应答而可以继续发送数据的最大值，上图的窗口大小为4个段（每个段长度1000）。
【窗口类型】
TCP滑动窗口分为两种：发送窗口和接受窗口。
发送端的滑动窗口包含四个部分：
● 已发送且已收到ACK确认
● 已发送但未收到ACK确认
● 未发送但可以发送
● 未发送且不能发送
上图标注的虚线部分就是发送窗口，TCP发送缓存区，是发送端被允许发送的最大数据包大小
● SND.WND：表示发送窗口的大小，上图虚线框的格子大小就是4000个字节。
● SND.UNA：一个绝对指针，它指向的是已发送但未确认的第一个字节的序列号。
● SND.NXT：下一个发送的位置，它指向未发送但可以发送的第一个字节的序列号。
接收端的滑动窗口包含三个部分：
● 已成功接收并确认
● 未收到数据但可以接收
● 未收到数据并不可以接收的数据
上图虚线矩形框就是接收窗口，TCP接收缓存区，用于存储未被进程使用的传入数据。
● REV.WND：表示发送窗口的大小，上图虚线框的格子大小就是3000个字节。
● REV.NXT：下一个接收的位置，它指向未收到但可以接收的第一个字节的序列号。
【实现方式】
下面小云君用图解的方式说明TCP交互中滑动窗口的实现机制：
上述图解是接收端（服务器）进程能很好的处理掉接收的数据的情况，因此可以保证接收窗口大小不变，能持续很好的滑动窗口接收数据。但设想一下，如果来不及处理就会占满TCP接收缓存区，也就是接收端窗口为0，此时就会通知发送端停止发数据了，这也就是TCP流量控制机制。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/d378ef95e842bfda5cb40da2fa173fca/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-12-20T23:04:23+08:00" />
<meta property="article:modified_time" content="2023-12-20T23:04:23+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">图解TCP滑动窗口！一分钟搞清楚知识点</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p id="9%E3%80%81TCP%E7%9A%84%E6%BB%91%E5%8A%A8%E7%AA%97%E6%9C%89%E4%BB%80%E4%B9%88%E4%BD%9C%E7%94%A8%EF%BC%9F%E4%BB%8B%E7%BB%8D%E4%B8%8B%E7%9B%B8%E5%85%B3%E6%9C%BA%E5%88%B6"><span style="color:#f3f3f4;"><strong><span style="background-color:#98c091;">【产生背景】</span></strong></span></p> 
<p>TCP 以1个段为单位，每发一个就需要进行一个确认应答的处理，这样的传输方式有一个缺点：<strong>包的往返时间越长通信性能就越低。</strong> </p> 
<p>***打个比方好比两个人对话：张三说完一句话，得到李四的确认回答，张三才能说下一句。每一次都是你一句话我一句确认，沟通方式非常低下。</p> 
<p class="img-center"><img alt="" height="484" src="https://images2.imgbox.com/ba/b9/3hCmiXPI_o.png" width="474"></p> 
<p><span style="color:#f3f3f4;"><strong><span style="background-color:#98c091;">【机制介绍】</span></strong></span></p> 
<p>为解决这个问题，TCP 引人了“窗口“这个概念，它是操作系统开辟的一个缓存空间，即使RTT（往返时间）较长也能控制网络性能的下降。确认应答以更大的单位进行确认，也就是说，<strong>发送端主机在发送了</strong><strong>1</strong><strong>个</strong><strong>TCP</strong><strong>段以后不必要一直等待确认应答而是继续发送</strong>，转发时间将会被大幅度的缩短。</p> 
<p>***也就是张三可以一次性连续说多句话，然后一次性等待李四回复OK就行，李四听不清楚的就重新说，完全听清楚了就继续往下说！</p> 
<p class="img-center"><img alt="" height="326" src="https://images2.imgbox.com/9c/f4/vTHHacJt_o.png" width="453"></p> 
<p>窗口大小就是指无需等待确认应答而可以继续发送数据的最大值，上图的窗口大小为4个段（每个段长度1000）。</p> 
<p></p> 
<p><span style="color:#f3f3f4;"><strong><span style="background-color:#98c091;">【窗口类型】</span></strong></span></p> 
<p>TCP滑动窗口分为两种：发送窗口和接受窗口。</p> 
<p><strong>发送端的滑动窗口包含四个部分：</strong></p> 
<p>● 已发送且已收到ACK确认</p> 
<p>● 已发送但未收到ACK确认</p> 
<p>● 未发送但可以发送</p> 
<p>● 未发送且不能发送</p> 
<p class="img-center"><img alt="" height="253" src="https://images2.imgbox.com/ab/ac/9EHhryux_o.png" width="422"></p> 
<p>上图标注的虚线部分就是发送窗口，TCP发送缓存区，是发送端被允许发送的最大数据包大小</p> 
<p>● SND.WND：表示发送窗口的大小，上图虚线框的格子大小就是4000个字节。</p> 
<p>● SND.UNA：一个绝对指针，它指向的是已发送但未确认的第一个字节的序列号。</p> 
<p>● SND.NXT：下一个发送的位置，它指向未发送但可以发送的第一个字节的序列号。</p> 
<p></p> 
<p><strong>接收端的滑动窗口包含三个部分：</strong></p> 
<p>● 已成功接收并确认</p> 
<p>● 未收到数据但可以接收</p> 
<p>● 未收到数据并不可以接收的数据</p> 
<p class="img-center"><img alt="" height="254" src="https://images2.imgbox.com/b2/f1/WhbXB5cB_o.png" width="432"></p> 
<p>上图虚线矩形框就是接收窗口，TCP接收缓存区，用于存储未被进程使用的传入数据。</p> 
<p>● REV.WND：表示发送窗口的大小，上图虚线框的格子大小就是3000个字节。</p> 
<p>● REV.NXT：下一个接收的位置，它指向未收到但可以接收的第一个字节的序列号。</p> 
<p></p> 
<p><span style="color:#f3f3f4;"><strong><span style="background-color:#98c091;">【实现方式】</span></strong></span></p> 
<p>下面小云君用图解的方式说明TCP交互中滑动窗口的实现机制：</p> 
<p><img alt="" height="1200" src="https://images2.imgbox.com/d1/d1/Mgx9XXaU_o.png" width="1200"></p> 
<p>上述图解是接收端（服务器）进程能很好的处理掉接收的数据的情况，因此可以保证接收窗口大小不变，能持续很好的滑动窗口接收数据。但设想一下，如果来不及处理就会占满TCP接收缓存区，也就是接收端窗口为0，此时就会通知发送端停止发数据了，这也就是<strong>TCP</strong><strong>流量控制</strong>机制。</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/6e29af9b17efa6b8cfb0b632d9da7bd0/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">人物行迹图/SVG的描点动画</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/b138d5f4d68b53fff844fbe0a64eab6e/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">pip的基本命令与使用</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>