<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>grpc for php,PHP gRPC基础入门指南 - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="grpc for php,PHP gRPC基础入门指南" />
<meta property="og:description" content="gRPC是一个高性能、开放源码的通用RPC框架。本篇文章分享了如何在PHP语言编程中使用gRPC框架。并展示一个简单的PHP gRPC客户端示例。
PHP中gRPC的基本教程介绍。
通过遍历此示例，您将学习如何：
在.proto文件中定义服务。
使用协议缓冲区编译器生成客户端代码。
使用PHP gRPC API为您的服务编写一个简单的客户端。
它假定对协议缓冲区有一定的了解。请注意，本教程中的示例使用协议缓冲区语言的proto2版本。
还要注意，当前，您只能在PHP中为gRPC服务创建客户端。使用另一种语言创建gRPC服务器。
为什么要使用gRPC？
我们的示例是一个简单的路由映射应用程序，它使客户端可以获取有关其路由功能的信息，创建其路由的摘要以及与服务器和其他客户端交换路由信息(例如流量更新)。
借助gRPC，我们可以在一个.proto文件中定义一次服务，并以gRPC支持的任何语言生成客户端和服务器，而这又可以在从大型数据中心内的服务器到您自己的平板电脑的各种环境中运行– gRPC为您处理不同的语言和环境。我们还获得了使用协议缓冲区的所有优点，包括有效的序列化，简单的IDL和轻松的接口更新。
示例代码和设置
git clone -b v1.33.2 https://github.com/grpc/grpc
您需要grpc-php-plugin来帮助您生成原型文件。您可以从源代码构建它：
cd grpc &amp;&amp; git submodule update --init &amp;&amp; make grpc_php_plugin
然后将当前目录更改为examples/php/route_guide并生成原始文件：
cd examples/php/route_guide &amp;&amp; ./route_guide_proto_gen.sh
我们的示例是一个简单的路由映射应用程序，它使客户端可以获取有关其路由功能的信息，创建其路由的摘要以及与服务器和其他客户端交换路由信息(例如流量更新)。
您还应该安装相关的工具来生成客户端接口代码(以及用于测试的另一种语言的服务器)。例如，您可以按照这些设置说明获得后者。
试试看！
要尝试示例应用程序，我们需要在本地运行的gRPC服务器。让我们在此存储库中编译并运行例如Node.js服务器：
$ cd ../../node
$ npm install
$ cd dynamic_codegen/route_guide
$ nodejs ./route_guide_server.js --db_path=route_guide_db.json
运行PHP客户端(在另一个终端中)：
./run_route_guide_client.sh
下一节将逐步指导您定义此原型服务的方式，如何从中生成客户端库以及如何创建使用该库的客户端存根。
定义服务
首先，让我们看看如何定义所使用的服务。使用协议缓冲区的gRPC服务及其方法请求和响应类型。您可以在下面的示例中看到完整的.proto文件examples/protos/route_guide.proto。
要定义服务，请service在.proto文件中指定一个名称：
service RouteGuide {
...
}
然后，rpc在服务定义中定义方法，并指定其请求和响应类型。协议缓冲区使您可以定义四种服务方法，所有这些方法都用于RouteGuide服务中：
1.一个简单的RPC，客户端将请求发送到服务器，然后再接收响应，就像普通的远程过程调用一样。
// Obtains the feature at a given position." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/61471b0880b2c9e7cd4ee1bda5ce43f0/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2021-03-10T09:18:48+08:00" />
<meta property="article:modified_time" content="2021-03-10T09:18:48+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">grpc for php,PHP gRPC基础入门指南</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <div style="font-size:16px;"> 
 <p>gRPC是一个高性能、开放源码的通用RPC框架。本篇文章分享了如何在PHP语言编程中使用gRPC框架。并展示一个简单的PHP gRPC客户端示例。</p> 
 <p>PHP中gRPC的基本教程介绍。</p> 
 <p>通过遍历此示例，您将学习如何：</p> 
 <p>在.proto文件中定义服务。</p> 
 <p>使用协议缓冲区编译器生成客户端代码。</p> 
 <p>使用PHP gRPC API为您的服务编写一个简单的客户端。</p> 
 <p>它假定对协议缓冲区有一定的了解。请注意，本教程中的示例使用协议缓冲区语言的proto2版本。</p> 
 <p>还要注意，当前，您只能在PHP中为gRPC服务创建客户端。使用另一种语言创建gRPC服务器。</p> 
 <p>为什么要使用gRPC？</p> 
 <p>我们的示例是一个简单的路由映射应用程序，它使客户端可以获取有关其路由功能的信息，创建其路由的摘要以及与服务器和其他客户端交换路由信息(例如流量更新)。</p> 
 <p>借助gRPC，我们可以在一个.proto文件中定义一次服务，并以gRPC支持的任何语言生成客户端和服务器，而这又可以在从大型数据中心内的服务器到您自己的平板电脑的各种环境中运行– gRPC为您处理不同的语言和环境。我们还获得了使用协议缓冲区的所有优点，包括有效的序列化，简单的IDL和轻松的接口更新。</p> 
 <p>示例代码和设置</p> 
 <p>git clone -b v1.33.2 https://github.com/grpc/grpc</p> 
 <p>您需要grpc-php-plugin来帮助您生成原型文件。您可以从源代码构建它：</p> 
 <p>cd grpc &amp;&amp; git submodule update --init &amp;&amp; make grpc_php_plugin</p> 
 <p>然后将当前目录更改为examples/php/route_guide并生成原始文件：</p> 
 <p>cd examples/php/route_guide &amp;&amp; ./route_guide_proto_gen.sh</p> 
 <p>我们的示例是一个简单的路由映射应用程序，它使客户端可以获取有关其路由功能的信息，创建其路由的摘要以及与服务器和其他客户端交换路由信息(例如流量更新)。</p> 
 <p>您还应该安装相关的工具来生成客户端接口代码(以及用于测试的另一种语言的服务器)。例如，您可以按照这些设置说明获得后者。</p> 
 <p>试试看！</p> 
 <p>要尝试示例应用程序，我们需要在本地运行的gRPC服务器。让我们在此存储库中编译并运行例如Node.js服务器：</p> 
 <p>$ cd ../../node</p> 
 <p>$ npm install</p> 
 <p>$ cd dynamic_codegen/route_guide</p> 
 <p>$ nodejs ./route_guide_server.js --db_path=route_guide_db.json</p> 
 <p>运行PHP客户端(在另一个终端中)：</p> 
 <p>./run_route_guide_client.sh</p> 
 <p>下一节将逐步指导您定义此原型服务的方式，如何从中生成客户端库以及如何创建使用该库的客户端存根。</p> 
 <p>定义服务</p> 
 <p>首先，让我们看看如何定义所使用的服务。使用协议缓冲区的gRPC服务及其方法请求和响应类型。您可以在下面的示例中看到完整的.proto文件examples/protos/route_guide.proto。</p> 
 <p>要定义服务，请service在.proto文件中指定一个名称：</p> 
 <p>service RouteGuide {<!-- --></p> 
 <p>...</p> 
 <p>}</p> 
 <p>然后，rpc在服务定义中定义方法，并指定其请求和响应类型。协议缓冲区使您可以定义四种服务方法，所有这些方法都用于RouteGuide服务中：</p> 
 <p>1.一个简单的RPC，客户端将请求发送到服务器，然后再接收响应，就像普通的远程过程调用一样。</p> 
 <p>// Obtains the feature at a given position.</p> 
 <p>rpc GetFeature(Point) returns (Feature) {}</p> 
 <p>2.一个响应流RPC，其中客户端向服务器发送一个请求并返回一个响应消息流。您可以通过将stream关键字放在响应类型之前来指定响应流方法。</p> 
 <p>// Obtains the Features available within the given Rectangle. Results are</p> 
 <p>// streamed rather than returned at once (e.g. in a response message with a</p> 
 <p>// repeated field), as the rectangle may cover a large area and contain a</p> 
 <p>// huge number of features.</p> 
 <p>rpc ListFeatures(Rectangle) returns (stream Feature) {}</p> 
 <p>3.一个双向流RPC双方都发送消息序列其他。这两个流是独立运行的，因此客户端和服务器可以按照自己喜欢的顺序进行读写：例如，服务器可以在写响应之前等待接收所有客户端消息，或者可以先读取一条消息再写入一条消息，或其他一些读写组合。每个流中的消息顺序都会保留。您可以通过stream在请求和响应之前放置关键字来指定这种类型的方法。</p> 
 <p>// Accepts a stream of RouteNotes sent while a route is being traversed,</p> 
 <p>// while receiving other RouteNotes (e.g. from other users).</p> 
 <p>rpc RouteChat(stream RouteNote) returns (stream RouteNote) {}</p> 
 <p>我们的.proto文件还包含用于服务方法中所有请求和响应类型的协议缓冲区消息类型定义-例如，以下是Point消息类型：</p> 
 <p>// Points are represented as latitude-longitude pairs in the E7 representation</p> 
 <p>// (degrees multiplied by 10**7 and rounded to the nearest integer).</p> 
 <p>// Latitudes should be in the range +/- 90 degrees and longitude should be in</p> 
 <p>// the range +/- 180 degrees (inclusive).</p> 
 <p>message Point {<!-- --></p> 
 <p>int32 latitude = 1;</p> 
 <p>int32 longitude = 2;</p> 
 <p>}</p> 
 <p>生成客户端代码</p> 
 <p>原型文件的PHP客户端存根实现可以通过gRPC PHP Protoc插件生成。编译插件：</p> 
 <p>make grpc_php_plugin</p> 
 <p>生成客户端存根实现.php文件：</p> 
 <p>cd grpc</p> 
 <p>protoc --proto_path=examples/protos \</p> 
 <p>--php_out=examples/php/route_guide \</p> 
 <p>--grpc_out=examples/php/route_guide \</p> 
 <p>--plugin=protoc-gen-grpc=bins/opt/grpc_php_plugin \</p> 
 <p>./examples/protos/route_guide.proto</p> 
 <p>或在grpc/example/php/route_guide目录下运行帮助程序脚本(如果您通过源代码构建grpc-php-plugin)：</p> 
 <p>./route_guide_proto_gen.sh</p> 
 <p>目录中将生成许多文件examples/php/route_guide。您不需要修改这些文件。</p> 
 <p>要加载这些生成的文件，请将此部分添加到composer.json目录下的 examples/php文件中</p> 
 <p>"autoload": {<!-- --></p> 
 <p>"psr-4": {<!-- --></p> 
 <p>"": "route_guide/"</p> 
 <p>}</p> 
 <p>}</p> 
 <p>该文件包含：</p> 
 <p>用于填充，序列化和检索我们的请求和响应消息类型的所有协议缓冲区代码。</p> 
 <p>名为的类Routeguide\RouteGuideClient，使客户端可以调用RouteGuide服务中定义的方法。</p> 
 <p>创建客户端</p> 
 <p>在本节中，我们将研究为我们的RouteGuide</p> 
 <p>构造客户端对象</p> 
 <p>要调用服务方法，我们首先需要创建一个客户端对象，即所生成RouteGuideClient类的实例。该类的构造函数期望我们要连接的服务器地址和端口：</p> 
 <p>$client = new Routeguide\RouteGuideClient('localhost:50051', [</p> 
 <p>'credentials' =&gt; Grpc\ChannelCredentials::createInsecure(),</p> 
 <p>]);</p> 
 <p>调用服务方法</p> 
 <p>简单的RPC</p> 
 <p>调用简单的RPCGetFeature与调用本地异步方法几乎一样简单。</p> 
 <p>$point = new Routeguide\Point();</p> 
 <p>$point-&gt;setLatitude(409146138);</p> 
 <p>$point-&gt;setLongitude(-746188906);</p> 
 <p>list($feature, $status) = $client-&gt;GetFeature($point)-&gt;wait();</p> 
 <p>如您所见，我们创建并填充了一个请求对象，即一个Routeguide\Point对象。然后，我们在存根上调用方法，并向其传递请求对象。如果没有错误，那么我们可以从服务器的响应对象(即Routeguide\Feature对象)中读取响应信息。</p> 
 <p>print sprintf("Found %s \n at %f, %f\n", $feature-&gt;getName(),</p> 
 <p>$feature-&gt;getLocation()-&gt;getLatitude() / COORD_FACTOR,</p> 
 <p>$feature-&gt;getLocation()-&gt;getLongitude() / COORD_FACTOR);</p> 
 <p>流式RPC</p> 
 <p>现在让我们看一下我们的流媒体方法。在这里，我们称为服务器端流方法ListFeatures，该方法返回geo的流Feature：</p> 
 <p>$lo_point = new Routeguide\Point();</p> 
 <p>$hi_point = new Routeguide\Point();</p> 
 <p>$lo_point-&gt;setLatitude(400000000);</p> 
 <p>$lo_point-&gt;setLongitude(-750000000);</p> 
 <p>$hi_point-&gt;setLatitude(420000000);</p> 
 <p>$hi_point-&gt;setLongitude(-730000000);</p> 
 <p>$rectangle = new Routeguide\Rectangle();</p> 
 <p>$rectangle-&gt;setLo($lo_point);</p> 
 <p>$rectangle-&gt;setHi($hi_point);</p> 
 <p>$call = $client-&gt;ListFeatures($rectangle);</p> 
 <p>// an iterator over the server streaming responses</p> 
 <p>$features = $call-&gt;responses();</p> 
 <p>foreach ($features as $feature) {<!-- --></p> 
 <p>// process each feature</p> 
 <p>} // the loop will end when the server indicates there is no more responses to be sent.</p> 
 <p>该$call-&gt;responses()方法调用返回迭代器。当服务器发送响应时，$feature将在foreach循环中返回一个对象，直到服务器指示不再有要发送的响应为止。</p> 
 <p>客户端流方法RecordRoute类似，不同之处在于，我们$call-&gt;write($point)从客户端调用 要写入的每个点，然后返回aRouteguide\RouteSummary。</p> 
 <p>$call = $client-&gt;RecordRoute();</p> 
 <p>for ($i = 0; $i &lt; $num_points; $i++) {<!-- --></p> 
 <p>$point = new Routeguide\Point();</p> 
 <p>$point-&gt;setLatitude($lat);</p> 
 <p>$point-&gt;setLongitude($long);</p> 
 <p>$call-&gt;write($point);</p> 
 <p>}</p> 
 <p>list($route_summary, $status) = $call-&gt;wait();</p> 
 <p>最后，让我们看一下双向流式RPCrouteChat()。在这种情况下，我们只需将上下文传递给该方法并获取一个BidiStreamingCall流对象，我们就可以使用该对象来写入和读取消息。</p> 
 <p>$call = $client-&gt;RouteChat();</p> 
 <p>要编写来自客户端的消息：</p> 
 <p>foreach ($notes as $n) {<!-- --></p> 
 <p>$route_note = new Routeguide\RouteNote();</p> 
 <p>$call-&gt;write($route_note);</p> 
 <p>}</p> 
 <p>$call-&gt;writesDone();</p> 
 <p>要从服务器读取消息：</p> 
 <p>while ($route_note_reply = $call-&gt;read()) {<!-- --></p> 
 <p>// process $route_note_reply</p> 
 <p>}</p> 
 <p>每一方都将始终按照写入的顺序获取另一方的消息，客户端和服务器都可以按照任何顺序读写——流完全独立地运行。</p> 
</div>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/b63129180f0735b194733a443c7db905/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">php中文意思,php中::是什么意思？</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/17e0672b55f10cc5aeb41ef226026ede/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">友链导航源码php,2020优化版导航源码自动收录秘趣导航批量检查友链有效性导航源码...</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>