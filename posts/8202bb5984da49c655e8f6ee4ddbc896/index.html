<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>C系列-自定义类型：结构体 - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="C系列-自定义类型：结构体" />
<meta property="og:description" content="🌈个人主页: 会编程的果子君
​💫个人格言:“成为自己未来的主人~” 结构体类型的声明 前面我们在学习操作符的时候，已经学习了结构体的知识，这里我们稍微复习一下。
结构体回顾 结构是一些值的集合，这些值称为成员变量，结构的每个成员可以是不同类型的变量
结构的声明 struct stg { member - list; }variable-list; 假如描述一个学生
struct stu { char name[20];//名字 int age;//年龄 char sex[5];//性别 char id[50];//学号 }; 结构体变量的创建和初始化 #include&lt;stdio.h&gt; struct stu { char name[20]; int age; char sex[20]; char id[20]; }; int main() { /* * 第一种 struct stu s = { &#34;张三&#34;,20,&#34;男&#34;,&#34;2023631002&#34; }; printf(&#34;%d&#34;, s.age); printf(&#34;%s&#34;, s.name); printf(&#34;%s&#34;, s.sex); printf(&#34;%s&#34;, s.id); */ //第二种 struct stu s2 = { ." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/8202bb5984da49c655e8f6ee4ddbc896/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2024-01-30T17:43:21+08:00" />
<meta property="article:modified_time" content="2024-01-30T17:43:21+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">C系列-自定义类型：结构体</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p class="img-center"><img alt="" height="204" src="https://images2.imgbox.com/4e/b2/5NKz2lSd_o.png" width="136"></p> 
<p><strong> 🌈个人主页: <strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><a href="https://blog.csdn.net/in_seattle?spm=1010.2135.3001.5343" title="会编程的果子君">会编程的果子君</a></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong><br> ​<strong>💫个人格言:“成为自己未来的主人~”</strong> </p> 
<p> <strong><img alt="" src="https://images2.imgbox.com/a3/7e/bLXKdfoJ_o.gif"></strong></p> 
<h2>结构体类型的声明</h2> 
<p>前面我们在学习操作符的时候，已经学习了结构体的知识，这里我们稍微复习一下。</p> 
<h3>结构体回顾</h3> 
<p>结构是一些值的集合，这些值称为成员变量，结构的每个成员可以是不同类型的变量</p> 
<h4>结构的声明</h4> 
<pre><code class="language-cpp">struct stg
{
	member - list;
}variable-list;</code></pre> 
<p>假如描述一个学生</p> 
<pre><code class="language-cpp">struct stu
{
	char name[20];//名字
	int age;//年龄
	char sex[5];//性别
	char id[50];//学号
};</code></pre> 
<h4>结构体变量的创建和初始化</h4> 
<p> </p> 
<pre><code class="language-cpp">#include&lt;stdio.h&gt;
struct stu
{
	char name[20];
	int age;
	char sex[20];
	char id[20];
};
int main()
{
	/*
	* 第一种
	struct stu s = { "张三",20,"男","2023631002" };
	printf("%d", s.age);
	printf("%s", s.name);
	printf("%s", s.sex);
	printf("%s", s.id);
	*/

	//第二种
	struct stu s2 = { .age = 20,.id = "2023631002",.name = "lisi",.sex = "男" };
	printf("%d", s2.age);
	printf("%s", s2.name);
	printf("%s", s2.sex);
	printf("%s", s2.id);
	return 0;
}</code></pre> 
<h3>结构的特殊声明</h3> 
<p>在声明结构的时候，可以不完全的声明</p> 
<p>比如：</p> 
<p> </p> 
<pre><code class="language-cpp">#include&lt;stdio.h&gt;
struct
{
	int a;
	int b;
}x;

struct
{
	char a[20];
	int b;
	float c;

}a[20],*p;</code></pre> 
<p> 上面的结构在声明的时候省略掉了结构体标签，那么问题来了</p> 
<p>在上面代码的基础上，下面的代码合法吗？</p> 
<p>p=&amp;x；</p> 
<p><strong>警告： </strong></p> 
<p>编译器会把上面的两个声明当成完全不同的两个类型，所以是非法的。</p> 
<p>匿名的结构体类型，如果没有对结构体类型重命名的话，基本上只能使用一次。</p> 
<h3>结构的自引用</h3> 
<p>在结构中包含了一个类型为该结构本身的成员是否可以呢？</p> 
<p>比如，定义一个链表的节点</p> 
<pre><code class="language-cpp">struct Node
{
	int a;
	struct Node next;
};</code></pre> 
<p>上述代码正确吗？如果正确，那sieof(struct Node)结果是多少</p> 
<p>仔细分析，其实是不行的，因为一个结构体中在包含一个同类型的结构体变量，这样的结构体变量的大小就会无穷的大，是不合理的。</p> 
<p>正确的自引用方式：</p> 
<pre><code class="language-cpp">struct Node
{
	int a;
	struct Node* next;
};</code></pre> 
<p>在结构体自引用使用的过程中，夹杂了typedef对匿名结构体类型重命名，也容易引入问题，看着下面的代码，可行吗？</p> 
<pre><code class="language-cpp">typedef struct
{
	int a;
	struct Node* p;
}Node;</code></pre> 
<p>答案是不行的，因为Node是对前面的匿名结构体类型的重命名产生的，但是在匿名结构体内部提前使用Node类型来创建成员变量，这是不行的。</p> 
<p><strong>解决方案如下：定义结构体不要使用匿名结构体了。</strong></p> 
<pre><code class="language-cpp">typedef struct Node
{
	int a;
	struct Node* next;
}Node;</code></pre> 
<h2>结构体内对齐</h2> 
<p>我们已经掌握了结构体的基本使用了</p> 
<p>现在我们深入探讨一个问题，计算结构体的大小</p> 
<p>这也是一个特别热门的考点：结构体内存对齐</p> 
<h3>对齐规则</h3> 
<p>首先得掌握结构体的对齐规则：</p> 
<p>1.结构体的第一个成员对齐到和结构体变量起始位置偏移量为0的位置</p> 
<p>2.其他成员变量要对齐某个数字（对齐数）的整数倍的地址处。</p> 
<p>对齐数=编译器默认的一个对齐数与该成员变量大小的较小值</p> 
<p>VS中默认的值为8</p> 
<p>Linux中gcc没有默认对齐数，对齐数就是成员自身的大小</p> 
<p>3.结构体总大小为最大对齐数（结构体中每个成员变量都有一个对齐数，所有对齐数最大的）的整数倍。</p> 
<p>4.如果嵌套了结构体的情况，嵌套的结构体成员对齐到自己的成员中最大对齐数的整数倍处，结构体的整体大小就是所有最大对齐数（含嵌套结构体中成员的对齐数）的整数倍</p> 
<pre><code class="language-cpp">#include&lt;stdio.h&gt;
//练习1
struct S1
{
	char c1;
	int i;
	char c2;
};
//练习2
struct S2
{
	char c1;
	char c2;
	int i;
};
//练习3
struct S3
{
	double d;
	char c;
	int i;
};
//练习4-结构体嵌套问题
struct S4
{
	char c1;
	struct S3 s3;
	double d;
};
int main()
{
	printf("%d\n", sizeof(struct S1));
	printf("%d\n", sizeof(struct S2));
	printf("%d\n", sizeof(struct S3));
	printf("%d\n", sizeof(struct S4));
	return 0;
}</code></pre> 
<p><img alt="" height="175" src="https://images2.imgbox.com/65/83/clxCSZJS_o.png" width="1200"></p> 
<h3> 为什么存在内存对齐</h3> 
<p>大部分的参考资料是这样说的</p> 
<p><strong>1.平台原因（移植原因）</strong></p> 
<p>不是所有的硬件平台都能访问任意地址上的任意数据的；某些硬件平台只能在某些地址处取某些特定类型的数据，否则抛出异常。</p> 
<p><strong>2.性能原因</strong></p> 
<p> 数据结构（尤其是栈）应该尽可能地在自然边界上对齐，原因在于，为了访问未对齐的内存，处理器必须需要作两次内存访问；而对齐的内存访问仅需要一次访问。</p> 
<p>总体来说，结构体的内存对齐是拿空间换取时间的做法</p> 
<p>那在设计结构体的时候，我们既要满足对齐，又要节省空间，如何做到让占用的空间小的成员尽可能集中在一起。</p> 
<pre><code class="language-cpp">#include&lt;stdio.h&gt;
struct s1
{
	char a;
	char c;
	int b;
};
struct s2
{
	char a;
	int b;
	char c;
};
int main()
{
	printf("%d\n", sizeof(struct s1));
	printf("%d\n", sizeof(struct s2));
	return 0;
}
</code></pre> 
<p>s1和s2类型的成员一模一样，但是两者所占的空间大小存在一定的差别。</p> 
<p><img alt="" height="125" src="https://images2.imgbox.com/50/6e/zTYd7Bae_o.png" width="676"></p> 
<h3>修改默认对齐数</h3> 
<p>#pragma这个预处理指令，可以改变编译器的默认对齐数。</p> 
<pre><code class="language-cpp">#include&lt;stdio.h&gt;
#pragma pack(1)//设置默认对齐数为1
struct s1
{
	char a;
	int b;
	char c;
};

#pragma pack()//将默认对齐数返回默认值

int main()
{
	printf("%d", sizeof(struct s1));


	return 0;
}</code></pre> 
<p> 结构体在对齐方式不合适的时候，我们可以自己更改默认对齐数。</p> 
<p><img alt="" height="139" src="https://images2.imgbox.com/01/34/4pViQbNV_o.png" width="555"></p> 
<h2>结构体传参</h2> 
<p> </p> 
<pre><code class="language-cpp">#include&lt;stdio.h&gt;
struct s1
{
	char name[20];
	int age;
	char sex[10];
};
struct s1 s = { "zhangsan",19,"男" };
void print1(struct s1 s)
{
	printf("%s\n", s.name);
}
void print2(struct s1* s)
{
	printf("%s\n", s-&gt;name);
}
int main()
{
	print1(s);
	print2(&amp;s);
	return 0;
}</code></pre> 
<p>上面的print1和print2函数哪个好些</p> 
<p>答案是：首选print2函数</p> 
<p>原因：函数传参的时候，参数是需要压栈的，会有时间和空间上的系统 开销</p> 
<p>如果传递一个结构体对象的时候，结构体过大，参数压栈的时候系统开销会比较大，所以会造成系统的性能下降。</p> 
<p><strong>结论：</strong></p> 
<p>结构体传参的时候，要传结构体的地址。</p> 
<h2>结构体实现位段</h2> 
<p>结构体讲完就得讲讲结构体实现位段的能力。</p> 
<h3>什么是位段</h3> 
<p>位段的声明和结构是类似的，有两个不同。</p> 
<p>1.位段的成员必须是 int unsigned int 或 signed int ，在C99中成员还可以是其他的类型。</p> 
<p>2.位段的成员名后面有一个冒号和一个数字。</p> 
<p>比如：</p> 
<pre><code class="language-cpp">struct s1
{
	int a : 5;
	int b : 10;
	int c : 10;


};</code></pre> 
<p>s1就是一个位段类型</p> 
<p>那么位段s1所占内存的大小是多少</p> 
<p> <img alt="" height="91" src="https://images2.imgbox.com/57/9f/Udmw2K20_o.png" width="423"></p> 
<p> 上面的一共是25个bit位，三个字节是24个bit，所以需要有4个字节</p> 
<h3>位段的内存分配</h3> 
<ol><li>位段的成员可以是int ，unsigned int ，signed int或者char类型</li><li>位段的空间上是按照需要以4个字节或者1个字节的方式开辟的</li><li>位段涉及很多不确定因素，位段是不跨平台的，注重可移植的程序应该避免使用位段</li></ol> 
<pre><code class="language-cpp">#include&lt;stdio.h&gt;
struct S
{
	char a : 3;
	char b : 4;
	char c : 5;
	char d : 4;
};
struct S s = { 0 };
int main()
{
	s.a = 10;
	s.b = 12;
	s.c = 3;
	s.d = 4;
	return 0;
}
//空间是如何开辟的？</code></pre> 
<h3>位段的跨平台问题</h3> 
<ul><li>int 位段被当成有符号数还是无符号数是不确定的</li><li>位段中最大位的数目不能确定。（16位机器最大16，32位机器最大是32）</li><li>位段的成员在内存中从左向右分配还是从右向左分配是不确定的</li><li>当一个结构包含两个位段，第二个位段成员比较大，无法容纳第一个位段剩余的位时，是舍弃剩余的位还是利用，这是不确定的。</li></ul> 
<p><strong>总结：</strong></p> 
<p>根结构相比，位段可以达到同样的效果，并且可以很好的节省空间。</p> 
<h3>位段使用的注意事项</h3> 
<p>位段的几个成员共有同一个字节，这样有些成员的起始位置并不是某个字节的起始位置，那么这些位置处是没有地址的，内存中每个字节分配一个地址，一个字节内部的bit位是没有地址的</p> 
<p>所以不能对位段的成员使用&amp;操作符，这样就不能使用scanf直接给位段的成员输入值，而是先输入到一个变量当中，然后赋值给位段的成员。</p> 
<pre><code class="language-cpp">#include&lt;stdio.h&gt;
struct s1
{
	int s:30;
};
int a = 0;
int main()
{
	struct s1 s = { 0 };
	//scanf("%d", &amp;s);//这是错误的
	//正确的方法
	int b = 0;
	scanf("%d", &amp;b);
	s.s = b;
	return 0;
}</code></pre> 
<p class="img-center"><img alt="" height="383" src="https://images2.imgbox.com/99/8e/9OEJsgmh_o.gif" width="650"></p> 
<p> </p> 
<p> <img alt="" src="https://images2.imgbox.com/37/f5/ihmoQX7I_o.gif"></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/c576145fa340b8fe13721cd4ca2d51cd/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">Python XPath解析html出现â解决方法 html出现&amp;#123；解决方法</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/283efd82f810a77e056a7431d75ad034/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">systemd：service与target使用及相关命令</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>