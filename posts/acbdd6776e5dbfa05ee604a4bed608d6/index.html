<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>掌握3个Mock工具，轻松玩转单元测试 - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="掌握3个Mock工具，轻松玩转单元测试" />
<meta property="og:description" content="公司要求提升单元测试的质量，提高代码的分支覆盖率和行覆盖率，安排我研究单元测试，指定方案分享并在开发部普及开。
单元测试中的Mock的目的 Mock的主要目的是让单元测试Write Once, Run Everywhere.
即编写一次后，可以在任意时刻任意环境运行，无需依赖数据库网络等。
Mock工具介绍 Mock工具经过调研，基本上是表格下面的这么个情况：
简要介绍下各个的特点和为什么没选：
rap2和easy-mock等，都是基于node开发的，和我们开发部的主力语言Java相性一般，后续改造难度大，并且不支持请求超时的配置和上下文的配置，优点是使用操作简单，pass。
wiremock，和rap2差不多，就是多个支持延时请求，不过是英文的，pass。
mock-server，基于java语言的，底层是netty，编程自由，比较适合java技术栈的团队。
postman，虽然有mock功能，但是只能针对某个请求的返回固定mock，并且每次启动mock的端口和url完全随机，无法接受，pass。
我们最后选的是mockito和mock-server，mockito因为是java的mock工具包，所以并不在上面的表格里。
mockito 相关介绍 这个包是spring官方也推荐的Mock依赖，在spring-boot-starter-test中默认就会自动包含。
这个包提供的相关类，主要功能就是对某个对象进行mock，通过其提供的特殊的语法，对某个对象的返回以及行为做Mock。
应用场景 单元测试时，如果依赖其他系统的RPC调用（比如feign或dubbo），可以针对相关RPC的调用对象进行直接Mock，直接返回成功、超时、异常，减少依赖。
在对系统内部的某些工具类或者数据库层进行单元测试时，可以模拟一些异常情况，比如数据库超时、框架层抛出某些很难复现的特定异常返回，可以通过直接Mock实现来达到效果。
mockito除了Mock外也支持spy，Mock与spy的区别是，Mock产生的是一个空对象，对mock对象未做配置的方法调用均返回null或异常。
spy产生的是一个代理对象，对那些做了配置的方法按照配置的预期返回，未做配置的方法直接会调用原方法。
使用方式（spring） maven中引入：
&lt;dependency&gt; &lt;groupId&gt;org.mockito&lt;/groupId&gt; &lt;artifactId&gt;mockito-all&lt;/artifactId&gt; &lt;version&gt;1.9.5&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; 在测试类中进行如下定义：
//需要mock的服务，一般是RPC，也可以是工具类，总而言之是一个对象 @Mock TestRpc testRpc; @Autowired TestService testService; //在@Before中对其进行初始化 @Before public void initMocks() throws Exception { //1.1 初始化的api，在这一步执行后，testRpc被初始化为一个mock对象 MockitoAnnotations.initMocks(this); //1.2 使用mock对象替换spring中的bean：这里是将后面要用到的testService中的testRpc这个rpc对象， //替换为上面@Mock为我们创建的mock对象，然后我们就可以对这个对象进行mock了，这里的替换是spring容器级别的替换 //注意，理论上对RPC的service进行mock即可，即替换调用RPC的那个bean中的rpc对象。 ReflectionTestUtils.setField(AopTargetUtils.getTarget(orderPayFacade), &#34;testRpc&#34;, testRpc); //1.3 定义mock返回：对新的mock对象进行定义，当后续请求这个rpc的该方法时，会直接return一个空的成功对象 final ResultRpc&lt;TestVO&gt; testVo = new ResultRpc&lt;&gt;(); when(testRpc.getAccountByBindCardId(&#34;101010&#34;)).thenReturn(testVo); } 或者：" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/acbdd6776e5dbfa05ee604a4bed608d6/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-09-08T16:19:17+08:00" />
<meta property="article:modified_time" content="2023-09-08T16:19:17+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">掌握3个Mock工具，轻松玩转单元测试</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/33/90/u5TAv43l_o.png"></p> 
<p>公司要求提升单元测试的质量，提高代码的分支覆盖率和行覆盖率，安排我研究单元测试，指定方案分享并在开发部普及开。</p> 
<h3><strong>单元测试中的Mock的目的</strong></h3> 
<p>Mock的主要目的是让单元测试Write Once, Run Everywhere.</p> 
<p>即编写一次后，可以在任意时刻任意环境运行，无需依赖数据库网络等。</p> 
<h3><strong>Mock工具介绍</strong></h3> 
<p>Mock工具经过调研，基本上是表格下面的这么个情况：</p> 
<p class="img-center"><img alt="图片" height="235" src="https://images2.imgbox.com/90/df/XRIz8t2J_o.png" width="1080"></p> 
<p>简要介绍下各个的特点和为什么没选：</p> 
<ul><li> <p>rap2和easy-mock等，都是基于node开发的，和我们开发部的主力语言Java相性一般，后续改造难度大，并且不支持请求超时的配置和上下文的配置，优点是使用操作简单，pass。</p> </li><li> <p>wiremock，和rap2差不多，就是多个支持延时请求，不过是英文的，pass。</p> </li><li> <p>mock-server，基于java语言的，底层是netty，编程自由，比较适合java技术栈的团队。</p> </li><li> <p>postman，虽然有mock功能，但是只能针对某个请求的返回固定mock，并且每次启动mock的端口和url完全随机，无法接受，pass。</p> </li></ul> 
<p>我们最后选的是mockito和mock-server，mockito因为是java的mock工具包，所以并不在上面的表格里。</p> 
<h3><strong>mockito</strong></h3> 
<h3><strong>相关介绍</strong></h3> 
<ul><li> <p>这个包是spring官方也推荐的Mock依赖，在spring-boot-starter-test中默认就会自动包含。</p> </li><li> <p>这个包提供的相关类，主要功能就是对某个对象进行mock，通过其提供的特殊的语法，对某个对象的返回以及行为做Mock。</p> </li></ul> 
<h3><strong>应用场景</strong></h3> 
<p>单元测试时，如果依赖其他系统的RPC调用（比如feign或dubbo），可以针对相关RPC的调用对象进行直接Mock，直接返回成功、超时、异常，减少依赖。</p> 
<p>在对系统内部的某些工具类或者数据库层进行单元测试时，可以模拟一些异常情况，比如数据库超时、框架层抛出某些很难复现的特定异常返回，可以通过直接Mock实现来达到效果。</p> 
<p>mockito除了Mock外也支持spy，Mock与spy的区别是，Mock产生的是一个空对象，对mock对象未做配置的方法调用均返回null或异常。</p> 
<p>spy产生的是一个代理对象，对那些做了配置的方法按照配置的预期返回，未做配置的方法直接会调用原方法。</p> 
<h3><strong>使用方式（spring）</strong></h3> 
<p>maven中引入：</p> 
<pre><code>&lt;dependency&gt;
    &lt;groupId&gt;org.mockito&lt;/groupId&gt;
    &lt;artifactId&gt;mockito-all&lt;/artifactId&gt;
    &lt;version&gt;1.9.5&lt;/version&gt;
    &lt;scope&gt;test&lt;/scope&gt;
&lt;/dependency&gt;</code></pre> 
<p>在测试类中进行如下定义：</p> 
<pre><code>//需要mock的服务，一般是RPC，也可以是工具类，总而言之是一个对象
@Mock
TestRpc testRpc;
@Autowired
TestService testService;

//在@Before中对其进行初始化
@Before
public void initMocks() throws Exception {
  //1.1 初始化的api，在这一步执行后，testRpc被初始化为一个mock对象
    MockitoAnnotations.initMocks(this);
    //1.2 使用mock对象替换spring中的bean：这里是将后面要用到的testService中的testRpc这个rpc对象，
    //替换为上面@Mock为我们创建的mock对象，然后我们就可以对这个对象进行mock了，这里的替换是spring容器级别的替换
    //注意，理论上对RPC的service进行mock即可，即替换调用RPC的那个bean中的rpc对象。
    ReflectionTestUtils.setField(AopTargetUtils.getTarget(orderPayFacade), "testRpc", testRpc);
    //1.3 定义mock返回：对新的mock对象进行定义，当后续请求这个rpc的该方法时，会直接return一个空的成功对象
    final ResultRpc&lt;TestVO&gt; testVo = new ResultRpc&lt;&gt;();
    when(testRpc.getAccountByBindCardId("101010")).thenReturn(testVo);
}</code></pre> 
<p>或者：</p> 
<pre><code>//另一种初始化方式，更加简单快捷
//这里是另一种写法，设置一个默认的answer，不用每个方法都设置一次返回,也可以继续进行上面那种方式的when配置
final TestRpc testRpcMock = mock(TestRpc.class, new Answer&lt;TestRes&gt;() {
    @Override
    public TestRes answer(InvocationOnMock invocationOnMock) throws Throwable {
        final TestRes testRes = new TestRes();
        testRes.setConfigId(0L);
        testRes.setCityId(86);
        testRes.setServiceId("01");
        testRes.setSysJoinType(0);
        testRes.setMerchantId("320212018002");
        testRes.setMerchantCode("");
        return testRes;
    }
});
ReflectionTestUtils.setField(AopTargetUtils.getTarget(testService), "testRpc", testRpcMock);</code></pre> 
<p>然后直接正常执行测试即可。</p> 
<h3><strong>使用方式（spring-boot及以上）</strong></h3> 
<p>前面说了spring-boot-starter较高版本（2.0以上）的test中默认会包括该依赖，所以直接使用就行，更方便的是无需使用反射工具替换spring上下文的bean，使用@MockBean注解标识bean即可。</p> 
<h3><strong>mock-server</strong></h3> 
<h3><strong>相关资料</strong></h3> 
<p>官方文档 https://www.mock-server.com/</p> 
<h3><strong>应用场景</strong></h3> 
<p>当进行单元测试时，如果我们需要进行http请求级别的模拟以及Mock，那么我们就可以使用mockserver。</p> 
<p>当然mockito也可以通过直接Mock那些http请求的类来达到相似效果，不过使用mock-server，我们可以更逼真的模拟http的环境，以提前发现那些只有在使用网络下才会出现的问题。</p> 
<p>既可以集成在maven的test生命周期里，也可以直接单独启动做一个server。</p> 
<p>在测试类中进行如下定义：</p> 
<pre><code>private final int mockPort = 19999;
private ClientAndServer mockServer;
//在@Before中对其进行初始化
@Before
public void initMocks() throws Exception {
  //1.1 初始化的api：启动mockserver
  mockServer = startClientAndServer(mockPort);
  //1.2 配置mockServer
  mockServer
        .when(
                request()
                        .withMethod("POST")
                        .withPath("/test/pay_v1/trade/pay")
                        .withContentType(MediaType.APPLICATION_JSON)
        )
        .respond(
               new TestResponseCallBack()
        );
}
public static class TestResponseCallBack implements ExpectationResponseCallback{
    private final Gson gson=new Gson();
    @Override
    public HttpResponse handle(HttpRequest httpRequest) throws Exception {
        log.info("------------{}",httpRequest);
        if (httpRequest.getMethod().getValue().equals("POST")) {
            //校验签名
            boolean verify = doVerifySign(httpRequest);
            if (!verify){
                return response()
                        .withStatusCode(OK_200.code())
                        .withBody(gson.toJson(CommonResult.failure(CommonErrors.SIGNATURE_VERIFY_FAIL)));
            }
            //构造返回
            return createResponse(httpRequest);
        } else {
            return notFoundResponse();
        }
    }
    private HttpResponse createResponse(HttpRequest httpRequest) throws Exception {
        final HttpRequest httpRequest1 = httpRequest;
        final String req = new String(httpRequest.getBodyAsRawBytes());
        String respBody="";
        final JSONObject jsonObject= JSON.parseObject(req);
        //比如对参数做一些校验
        Assert.assertNotNull(jsonObject.getString("user_id"));
        //构造返回，可以根据请求的内容构造，这里随便写个返回，
        final String user_id = jsonObject.getString("user_id");
        respBody="{\"success\": true,\"errcode\": \"0000\",\"errmsg\": \"成功\",\"result\": {\"user_id\": \"123456\",\"reserved\":"+user_id+"\"\"}}";
        //这里如果必要的话，也可以触发一个延时的回调
        new Thread(new Runnable() {
            @Override
            public void run() {
                LockSupport.parkNanos(1000000000L*2);
                final String notify_url = jsonObject.getString("notify_url");
                HttpHeaders headers = new HttpHeaders();
                headers.setContentType(org.springframework.http.MediaType.APPLICATION_JSON);
                headers.add("Accept", MediaType.APPLICATION_JSON.toString());
                JSONObject param = new JSONObject();
                param.put("username", "123");
                HttpEntity&lt;String&gt; formEntity = new HttpEntity&lt;String&gt;(param.toJSONString(), headers);
                String result = new RestTemplate().postForObject(notify_url, formEntity, String.class);
                log.info("发送回调：{}",param.toJSONString());
            }
        }).start();
        return response()
                .withStatusCode(OK_200.code())
                .withBody(respBody);
    }
    private boolean doVerifySign(HttpRequest httpRequest) throws Exception {
        String signature = httpRequest.getFirstHeader(RequestHeader.Signature);
        String message = new String(httpRequest.getBodyAsRawBytes(), StandardCharsets.UTF_8);
        String md5HexMessage = DigestUtils.md5Hex(message.getBytes(StandardCharsets.UTF_8));
        return RSAUtils.doCheck(md5HexMessage, signature, privateKey, StandardCharsets.UTF_8.displayName());
    }
}</code></pre> 
<p>然后直接正常执行测试即可。</p> 
<h3><strong>cobertura-maven-plugin</strong></h3> 
<p>前面的2个Mock工具，结合cobertura-maven-plugin，可以瞬间跑起一个带代码覆盖率的测试。</p> 
<h3><strong>使用方式</strong></h3> 
<p>maven</p> 
<pre><code>&lt;plugin&gt;
    &lt;groupId&gt;org.codehaus.mojo&lt;/groupId&gt;
    &lt;artifactId&gt;cobertura-maven-plugin&lt;/artifactId&gt;
    &lt;version&gt;2.7&lt;/version&gt;
&lt;/plugin&gt;</code></pre> 
<p>执行测试：mvn clean cobertura:cobertura -f pom.xml。</p> 
<p>到target/site下打开index文件查看结果：</p> 
<p><img alt="" height="360" src="https://images2.imgbox.com/d0/39/iDTUG3xI_o.png" width="957"></p> 
<h3><strong>总结</strong></h3> 
<p>本文简单介绍了3个工具的使用，主要是提供了一个可行的方案去推进单元测试，具体3个工具的详细使用细节以及进阶，可以自行查找资料。</p> 
<p><strong>最后：</strong>下方这份完整的软件测试视·频教程已经整理上传完成，需要的朋友们可以自行领取<span style="color:#fe2c24;"><strong>【保证100%免费】</strong></span></p> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/32/08/rVGuao9r_o.png"></p> 
<h4><strong>软件测试面试文档</strong></h4> 
<p>我们学习必然是为了找到高薪的工作，下面这些面试题是来自阿里、腾讯、字节等一线互联网大厂最新的面试资料，并且有字节大佬给出了权威的解答，刷完这一套面试资料相信大家都能找到满意的工作。</p> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/d6/cd/baa0uWPa_o.png"></p> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/76/9f/FJWD63R8_o.gif"></p> 
<p></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/081b41c4c76846370d3955c9a39c4634/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">Kubernetes双主集群的部署（二）</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/6d57f583ea056b939c324d841c2b0c35/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">一篇文章搞懂正定矩阵</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>