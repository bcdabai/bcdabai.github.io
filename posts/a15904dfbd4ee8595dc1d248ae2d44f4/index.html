<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>C&#43;&#43; map/set的模拟实现（基于红黑树） - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="C&#43;&#43; map/set的模拟实现（基于红黑树）" />
<meta property="og:description" content="目录
前言
封装前的红黑树源码
红黑树模板参数的控制
红黑树结点当中存储的数据
模板参数中仿函数的增加
迭代器的实现
set的模拟实现
map的模拟实现
前言 map/set是基于红黑树的关联式容器，在stl源码中的红黑树实现，用了header节点，使header节点的parent指向红黑树的根，这样实现了迭代器的end()可以自减到红黑树的最右节点，但本文的红黑树未用header节点封装，所以迭代器部分有缺陷，仅供学习stl复用的思想
封装前的红黑树源码 如下红黑树源码也可以封装出map和set，但是会要用到两颗红黑树，为了体现复用的思想，我们显然要用某种方法封装
enum class Colour { RED, BLACK }; template&lt;class K ,class V&gt; struct RBTreeNode { RBTreeNode(const pair&lt;K, V&gt;&amp; kv) : _left(nullptr), _right(nullptr), _parent(nullptr), _kv(kv) , _col(Colour::RED) {} RBTreeNode&lt;K, V&gt;* _left; RBTreeNode&lt;K, V&gt;* _right; RBTreeNode&lt;K, V&gt;* _parent; pair&lt;K, V&gt; _kv; Colour _col; }; template&lt;class K, class V&gt; class RBTree { typedef RBTreeNode&lt;K, V&gt; Node; public: RBTree():_root(nullptr) {} RBTree(const RBTree&lt;K, V&gt;&amp; t) { _root = _copy(t." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/a15904dfbd4ee8595dc1d248ae2d44f4/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-08-12T13:02:36+08:00" />
<meta property="article:modified_time" content="2023-08-12T13:02:36+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">C&#43;&#43; map/set的模拟实现（基于红黑树）</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p id="main-toc"><strong>目录</strong></p> 
<p id="-toc" style="margin-left:0px;"></p> 
<p id="%E5%89%8D%E8%A8%80-toc" style="margin-left:0px;"><a href="#%E5%89%8D%E8%A8%80" rel="nofollow">前言</a></p> 
<p id="%E5%B0%81%E8%A3%85%E5%89%8D%E7%9A%84%E7%BA%A2%E9%BB%91%E6%A0%91%E6%BA%90%E7%A0%81-toc" style="margin-left:0px;"><a href="#%E5%B0%81%E8%A3%85%E5%89%8D%E7%9A%84%E7%BA%A2%E9%BB%91%E6%A0%91%E6%BA%90%E7%A0%81" rel="nofollow">封装前的红黑树源码</a></p> 
<p id="%E7%BA%A2%E9%BB%91%E6%A0%91%E6%A8%A1%E6%9D%BF%E5%8F%82%E6%95%B0%E7%9A%84%E6%8E%A7%E5%88%B6-toc" style="margin-left:0px;"><a href="#%E7%BA%A2%E9%BB%91%E6%A0%91%E6%A8%A1%E6%9D%BF%E5%8F%82%E6%95%B0%E7%9A%84%E6%8E%A7%E5%88%B6" rel="nofollow">红黑树模板参数的控制</a></p> 
<p id="%E7%BA%A2%E9%BB%91%E6%A0%91%E7%BB%93%E7%82%B9%E5%BD%93%E4%B8%AD%E5%AD%98%E5%82%A8%E7%9A%84%E6%95%B0%E6%8D%AE-toc" style="margin-left:0px;"><a href="#%E7%BA%A2%E9%BB%91%E6%A0%91%E7%BB%93%E7%82%B9%E5%BD%93%E4%B8%AD%E5%AD%98%E5%82%A8%E7%9A%84%E6%95%B0%E6%8D%AE" rel="nofollow">红黑树结点当中存储的数据</a></p> 
<p id="%E6%A8%A1%E6%9D%BF%E5%8F%82%E6%95%B0%E4%B8%AD%E4%BB%BF%E5%87%BD%E6%95%B0%E7%9A%84%E5%A2%9E%E5%8A%A0-toc" style="margin-left:0px;"><a href="#%E6%A8%A1%E6%9D%BF%E5%8F%82%E6%95%B0%E4%B8%AD%E4%BB%BF%E5%87%BD%E6%95%B0%E7%9A%84%E5%A2%9E%E5%8A%A0" rel="nofollow">模板参数中仿函数的增加</a></p> 
<p id="%E8%BF%AD%E4%BB%A3%E5%99%A8%E7%9A%84%E5%AE%9E%E7%8E%B0-toc" style="margin-left:0px;"><a href="#%E8%BF%AD%E4%BB%A3%E5%99%A8%E7%9A%84%E5%AE%9E%E7%8E%B0" rel="nofollow">迭代器的实现</a></p> 
<p id="set%E7%9A%84%E6%A8%A1%E6%8B%9F%E5%AE%9E%E7%8E%B0-toc" style="margin-left:0px;"><a href="#set%E7%9A%84%E6%A8%A1%E6%8B%9F%E5%AE%9E%E7%8E%B0" rel="nofollow">set的模拟实现</a></p> 
<p id="map%E7%9A%84%E6%A8%A1%E6%8B%9F%E5%AE%9E%E7%8E%B0-toc" style="margin-left:0px;"><a href="#map%E7%9A%84%E6%A8%A1%E6%8B%9F%E5%AE%9E%E7%8E%B0" rel="nofollow">map的模拟实现</a></p> 
<hr id="hr-toc"> 
<p></p> 
<h2 id="%E5%89%8D%E8%A8%80">前言</h2> 
<p>map/set是基于红黑树的关联式容器，在stl源码中的红黑树实现，用了header节点，使header节点的parent指向红黑树的根，这样实现了迭代器的end()可以自减到红黑树的最右节点，但本文的红黑树<strong>未用header节点封装</strong>，所以<strong>迭代器部分有缺陷，仅供学习stl复用的思想</strong></p> 
<hr> 
<h2 id="%E5%B0%81%E8%A3%85%E5%89%8D%E7%9A%84%E7%BA%A2%E9%BB%91%E6%A0%91%E6%BA%90%E7%A0%81">封装前的红黑树源码</h2> 
<p>如下红黑树源码也可以封装出map和set，但是会要用到两颗红黑树，<strong>为了体现复用的思想，我们显然要用某种方法封装</strong></p> 
<pre><code>	enum class Colour
	{
		RED, BLACK
	};
	template&lt;class K ,class V&gt;
	struct RBTreeNode
	{

		RBTreeNode(const pair&lt;K, V&gt;&amp; kv) :
			_left(nullptr), _right(nullptr), _parent(nullptr), _kv(kv) , _col(Colour::RED)
		{}
		RBTreeNode&lt;K, V&gt;* _left;
		RBTreeNode&lt;K, V&gt;* _right;
		RBTreeNode&lt;K, V&gt;* _parent;
		pair&lt;K, V&gt; _kv;

		Colour _col;
	};

	template&lt;class K, class V&gt;
	class RBTree
	{
		typedef RBTreeNode&lt;K, V&gt; Node;



	public:
		RBTree():_root(nullptr)
		{}

		RBTree(const RBTree&lt;K, V&gt;&amp; t)
		{
			_root = _copy(t._root, nullptr);
		}

		RBTree&lt;K, V&gt;&amp; operator=(RBTree&lt;K, V&gt; t)
		{
			swap(_root, t._root);
			return *this;
		}

		bool erase(const K&amp; k)
		{
			Node* cur = _root;
			Node* parent = nullptr;

			Node* delPos = nullptr;
			Node* delParentPos = nullptr;

			while (cur)
			{
				if (k &gt; cur-&gt;_kv.first)
				{
					parent = cur;
					cur = cur-&gt;_right;
				}
				else if (k &lt; cur-&gt;_kv.first)
				{
					parent = cur;
					cur = cur-&gt;_left;
				}
				else
				{
					if(cur-&gt;_left == nullptr)
					{
						if (cur == _root)
						{
							_root = cur-&gt;_right;
							if (_root)
							{
								_root-&gt;_parent = nullptr;
								_root-&gt;_col = Colour::BLACK;
							}
							delete cur;
							return true;
						}
						else
						{
							delParentPos = parent;
							delPos = cur;
						}
						break;
					}
					else if (cur-&gt;_right == nullptr)
					{
						if (cur == _root)
						{
							_root = cur-&gt;_left;
							if (_root)
							{
								_root-&gt;_parent = nullptr;
								_root-&gt;_col = Colour::BLACK;
							}
							delete cur;
							return true;
						}
						else
						{
							delParentPos = parent;
							delPos = cur;
						}
						break;
					}
					else 
					{
						Node* RightMin = cur-&gt;_right;
						Node* minParent = cur;

						while (RightMin-&gt;_left)
						{
							minParent = RightMin;
							RightMin = RightMin-&gt;_left;
						}

						cur-&gt;_kv = RightMin-&gt;_kv;
						delParentPos = minParent;
						delPos = RightMin;
						break;
					}
				}
			}

			if (delPos == nullptr)//没有找到待删除节点
			{
				return false;
			}

			Node* del = delPos;
			Node* delP = delParentPos;

			if (delPos-&gt;_col == Colour::BLACK)
			{
				//delPos最多只有一个孩子
				if (delPos-&gt;_left)
				{
					delPos-&gt;_left-&gt;_col = Colour::BLACK;
				}
				else if (delPos-&gt;_right)
				{
					delPos-&gt;_right-&gt;_col = Colour::BLACK;
				}
				else
				{
					//brother 一定存在,不然无法满足各路径黑色数量相同的性质
					while (delPos != _root)
					{
						if (delPos == delParentPos-&gt;_left)
						{
							Node* brother = delParentPos-&gt;_right;

							//case 1

							if (brother-&gt;_col == Colour::RED)
							{
								delParentPos-&gt;_col = Colour::RED;
								brother-&gt;_col = Colour::BLACK;
								RotateL(delParentPos);
								brother = delParentPos-&gt;_right;
							}

							//case 2

							if ((brother-&gt;_left == nullptr || brother-&gt;_left-&gt;_col == Colour::BLACK)
								&amp;&amp; (brother-&gt;_right == nullptr || brother-&gt;_right-&gt;_col == Colour::BLACK))
							{
								brother-&gt;_col = Colour::RED;
								if (delParentPos-&gt;_col == Colour::RED)
								{
									delParentPos-&gt;_col = Colour::BLACK;
									break;
								}
								else
								{
									delPos = delParentPos;
									delParentPos = delParentPos-&gt;_parent;
								}
							}

							//case 3
							else
							{
								if (brother-&gt;_right == nullptr || brother-&gt;_right-&gt;_col == Colour::BLACK)
								{
									brother-&gt;_col = Colour::RED;
									brother-&gt;_left-&gt;_col = Colour::BLACK;
									RotateR(brother);
									brother = delParentPos-&gt;_right;
								}
								//case 4
								brother-&gt;_col = delParentPos-&gt;_col;
								brother-&gt;_right-&gt;_col = Colour::BLACK;
								delParentPos-&gt;_col = Colour::BLACK;
								RotateL(delParentPos);
								break;
							}
						}
						else
						{
							Node* brother = delParentPos-&gt;_left;
							
							//case 1
							if (brother-&gt;_col == Colour::RED)
							{
								delParentPos-&gt;_col = Colour::RED;
								brother-&gt;_col = Colour::BLACK;
								RotateR(delParentPos);
								brother = delParentPos-&gt;_left;
							}

							//case 2
							if ((brother-&gt;_left == nullptr || brother-&gt;_left-&gt;_col == Colour::BLACK)
								&amp;&amp; (brother-&gt;_right == nullptr || brother-&gt;_right-&gt;_col == Colour::BLACK))
							{
								brother-&gt;_col = Colour::RED;
								if (delParentPos-&gt;_col == Colour::RED)
								{
									delParentPos-&gt;_col = Colour::BLACK;
									break;
								}
								else
								{
									delPos = delParentPos;
									delParentPos = delParentPos-&gt;_parent;
								}
							}

							else
							{
								//case 3
								if (brother-&gt;_left == nullptr || brother-&gt;_left-&gt;_col == Colour::BLACK)
								{
									brother-&gt;_right-&gt;_col = Colour::BLACK;
									brother-&gt;_col = Colour::RED;
									RotateL(brother);
									brother = delParentPos-&gt;_left;
								}
								//case 4
								brother-&gt;_col = delParentPos-&gt;_col;
								delParentPos-&gt;_col = Colour::RED;
								brother-&gt;_left-&gt;_col = Colour::BLACK;
								RotateR(delParentPos);
								break;
							}
						}
					}
				}
			}

			//删除操作
			if (del-&gt;_left == nullptr)
			{
				if (delP-&gt;_left == del)
				{
					delP-&gt;_left = del-&gt;_right;
				}
				else
				{
					delP-&gt;_right = del-&gt;_right;
				}
				if (del-&gt;_right)
					del-&gt;_right-&gt;_parent = delP;
			}
			else
			{
				if (delP-&gt;_left == del)
				{
					delP-&gt;_left = del-&gt;_left;
				}
				else
				{
					delP-&gt;_right = del-&gt;_left;
				}
				if (del-&gt;_right)
					del-&gt;_right-&gt;_parent = delP;
			}

			return true;
		}


		bool insert(const pair&lt;K, V&gt;&amp; kv)
		{
			if (!_root)
			{
				_root = new Node(kv);
				_root-&gt;_col = Colour::BLACK;
				return true;
			}

			Node* parent = nullptr;
			Node* cur = _root;
			while (cur)
			{
				parent = cur;

				if (cur-&gt;_kv.first &gt; kv.first)
				{
					cur = cur-&gt;_left;
				}
				else if (cur-&gt;_kv.first &lt; kv.first)
				{
					cur = cur-&gt;_right;
				}
				else
				{
					return false;
				}
			}

			cur = new Node(kv);
			if (parent -&gt;_kv.first &gt; cur-&gt;_kv.first)
			{
				parent-&gt;_left = cur;
			}
			else
			{
				parent-&gt;_right = cur;
			}
			cur-&gt;_parent = parent;



			while (parent &amp;&amp; parent-&gt;_col == Colour::RED)
			{
				Node* grandfather = parent-&gt;_parent;
				if (grandfather-&gt;_left == parent)
				{
					Node* uncle = grandfather-&gt;_right;
					//case 1  uncle存在且为红

					if (uncle &amp;&amp; uncle-&gt;_col == Colour::RED)
					{
						uncle-&gt;_col = parent-&gt;_col = Colour::BLACK;
						grandfather-&gt;_col = Colour::RED;

						//adjustup
						cur = grandfather;
						parent = cur-&gt;_parent;
					}
                    //case 2  uncle存在且为黑
					//case 3  uncle不存在
					else
					{
						if (parent-&gt;_right == cur)
						{
							RotateL(parent);
							RotateR(grandfather);
							cur-&gt;_col = Colour::BLACK;
							grandfather-&gt;_col = Colour::RED;
						}
						else
						{
							RotateR(grandfather);
							grandfather-&gt;_col = Colour::RED;
							parent-&gt;_col = Colour::BLACK;
						}
						break;
					}
				}
				else
				{
					Node* uncle = grandfather-&gt;_left;


					if (uncle &amp;&amp; uncle-&gt;_col == Colour::RED)
					{
						uncle-&gt;_col = parent-&gt;_col = Colour::BLACK;
						grandfather-&gt;_col = Colour::RED;

						cur = grandfather;
						parent = cur-&gt;_parent;
					}
					else
					{
						if (parent-&gt;_left == cur)
						{
							RotateR(parent);
							RotateL(grandfather);
							cur-&gt;_col = Colour::BLACK;
							grandfather-&gt;_col = Colour::RED;
						}
						else
						{
							RotateL(grandfather);
							grandfather-&gt;_col = Colour::RED;
							parent-&gt;_col = Colour::BLACK;
						}
						break;
					}
				}



			}

			_root-&gt;_col = Colour::BLACK;
			return true;
		}

		void InOrder()
		{
			_InOrder(_root);
		}
		//判断是否为红黑树
		bool ISRBTree()
		{
			if (_root == nullptr) //空树是红黑树
			{
				return true;
			}
			if (_root-&gt;_col == Colour::RED)
			{
				cout &lt;&lt; "error：根结点为红色" &lt;&lt; endl;
				return false;
			}

			//找最左路径作为黑色结点数目的参考值
			Node* cur = _root;
			int BlackCount = 0;
			while (cur)
			{
				if (cur-&gt;_col == Colour::BLACK)
					BlackCount++;
				cur = cur-&gt;_left;
			}

			int count = 0;
			return _ISRBTree(_root, count, BlackCount);
		}
		~RBTree()
		{
			_Destroy(_root);
			_root = nullptr;
		}

	private:

		RBTree&lt;K, V&gt;&amp; _copy(Node* root , Node* parent)
		{
			if (!root)
				return nullptr;

			Node* newNode = new Node(root-&gt;_kv);
			newNode-&gt;_parent = parent;
			newNode-&gt;_left = _copy(root-&gt;_left, newNode);
			newNode-&gt;_left = _copy(root-&gt;_right, newNode);

			return newNode;
		}

		void _Destroy(Node* root)
		{
			if (!root)
				return;
			_Destroy(root-&gt;_left);
			_Destroy(root-&gt;_right);

			delete root;
		}



		//判断是否为红黑树的子函数
		bool _ISRBTree(Node* root, int count, int BlackCount)
		{
			if (root == nullptr) //该路径已经走完了
			{
				if (count != BlackCount)
				{
					cout &lt;&lt; "error：黑色结点的数目不相等" &lt;&lt; endl;
					return false;
				}
				return true;
			}

			if (root-&gt;_col == Colour::RED &amp;&amp; root-&gt;_parent-&gt;_col == Colour::RED)
			{
				cout &lt;&lt; "error：存在连续的红色结点" &lt;&lt; endl;
				return false;
			}
			if (root-&gt;_col == Colour::BLACK)
			{
				count++;
			}
			return _ISRBTree(root-&gt;_left, count, BlackCount) &amp;&amp; _ISRBTree(root-&gt;_right, count, BlackCount);
		}
		void _InOrder(Node* root)
		{
			if (!root)
				return;
			_InOrder(root-&gt;_left);
			cout &lt;&lt; root-&gt;_kv.first &lt;&lt; " " &lt;&lt; root-&gt;_kv.second &lt;&lt; endl;
			_InOrder(root-&gt;_right);
		}
		void RotateL(Node* parent)
		{
			Node* SubR = parent-&gt;_right;
			Node* SubRL = SubR-&gt;_left;
			Node* ppNode = parent-&gt;_parent;

			parent-&gt;_right = SubRL;
			if (SubRL)
				SubRL-&gt;_parent = parent;

			SubR-&gt;_left = parent;
			parent-&gt;_parent = SubR;

			if (_root == parent)// _root == parent
			{
				_root = SubR;
			}
			else
			{
				if (ppNode-&gt;_left == parent)
					ppNode-&gt;_left = SubR;
				else
					ppNode-&gt;_right = SubR;
			}
			SubR-&gt;_parent = ppNode;

		}
		void RotateR(Node* parent)
		{
			Node* SubL = parent-&gt;_left;
			Node* SubLR = SubL-&gt;_right;
			Node* ppNode = parent-&gt;_parent;

			parent-&gt;_left = SubLR;
			if (SubLR)
				SubLR-&gt;_parent = parent;

			SubL-&gt;_right = parent;
			parent-&gt;_parent = SubL;


			if (_root == parent)// _root == parent
			{
				_root = SubL;
			}
			else
			{
				if (ppNode-&gt;_left == parent)
					ppNode-&gt;_left = SubL;
				else
					ppNode-&gt;_right = SubL;
			}
			SubL-&gt;_parent = ppNode;
		}
		Node* _root = nullptr;
	};</code></pre> 
<h2 id="%E7%BA%A2%E9%BB%91%E6%A0%91%E6%A8%A1%E6%9D%BF%E5%8F%82%E6%95%B0%E7%9A%84%E6%8E%A7%E5%88%B6" style="background-color:transparent;">红黑树模板参数的控制</h2> 
<blockquote> 
 <p>我们都知道，set是K模型的容器，而map是KV模型的容器，那我们如何用一棵KV模型的红黑树同时实现map和set呢？</p> 
</blockquote> 
<p>这里我们就需要控制map和set传入底层红黑树的模板参数，为了与原红黑树的模板参数进行区分，我们将红黑树第二个模板参数的名字改为T。</p> 
<pre><code>template&lt;class K, class T&gt;
	class RBTree</code></pre> 
<p>T模板参数可能只是键值Key，也可能是由Key和Value共同构成的键值对。如果是set容器，那么它传入底层红黑树的模板参数就是Key和Key：</p> 
<pre><code>template&lt;class K&gt;
class set
{
public:
	//...
private:
	RBTree&lt;K, K&gt; _t;
};
</code></pre> 
<p>但如果是map容器，那么它传入底层红黑树的模板参数就是Key以及Key和Value构成的键值对：</p> 
<pre><code>template&lt;class K, class V&gt;
class map
{
public:
	//...
private:
	RBTree&lt;K, pair&lt;K, V&gt;&gt; _t;
};
</code></pre> 
<h2 id="%E7%BA%A2%E9%BB%91%E6%A0%91%E7%BB%93%E7%82%B9%E5%BD%93%E4%B8%AD%E5%AD%98%E5%82%A8%E7%9A%84%E6%95%B0%E6%8D%AE" style="background-color:transparent;">红黑树结点当中存储的数据</h2> 
<p>原先红黑树中存储的是键值对kv，现在对于<strong>set的T是key</strong>，<strong>map的T是键值对</strong>，那么我们只要把数据域改为<strong>T _data</strong>即可</p> 
<p> 而且这样一来，节点的模板参数也只需要一个class T</p> 
<p>代码如下：</p> 
<pre><code>	template&lt;class T&gt;
	struct RBTreeNode
	{

		RBTreeNode(const T&amp; data) :
			_left(nullptr), _right(nullptr), _parent(nullptr), _data(data), _col(Colour::RED)
		{}
		RBTreeNode&lt;T&gt;* _left;
		RBTreeNode&lt;T&gt;* _right;
		RBTreeNode&lt;T&gt;* _parent;
		T _data;
		Colour _col;
	};</code></pre> 
<h2 id="%E6%A8%A1%E6%9D%BF%E5%8F%82%E6%95%B0%E4%B8%AD%E4%BB%BF%E5%87%BD%E6%95%B0%E7%9A%84%E5%A2%9E%E5%8A%A0" style="background-color:transparent;">模板参数中仿函数的增加</h2> 
<p>我们的目的是要用一颗红黑树封装出map和set，可是<strong>二者节点存储的数据类型不同</strong>，如何在一颗树种<strong>完成不同数据类型的key比较</strong>呢？</p> 
<p>如果我们的map和set在构建红黑树时告诉我们的红黑树<strong>如何获取他们各自的数据的key</strong>，我们似乎就可以实现复用了，这个时候我们就可以增加红黑树的模板参数，这个模<strong>板参数可以拿出T中的key，而拿出key的方法我们让map和set来提供</strong></p> 
<blockquote> 
 <p>我们在学习优先级队列时提到过<strong>Compare</strong>这样一个模板参数，默认是Less，它其实就是一个类，只不过实现了<strong>operator()</strong>的重载，从而有了类似函数的行为</p> 
</blockquote> 
<blockquote> 
 <p>红黑树的模板参数改为：    </p> 
 <p>template&lt;class K, class T , class KOfT&gt;<br> class RBTree</p> 
</blockquote> 
<pre><code>	template&lt;class K&gt;
	class set
	{
		struct SetKeyOfT
		{
			const K&amp; operator()(const K&amp; k)
			{
				return k;
			}
		};
    //....
    private:
	RBTree&lt;K, pair&lt;K, K&gt;, SetKeyOfT&gt; _t;
    }
	template&lt;class K ,class V&gt;
	class map
	{
		struct MapKeyOfT
		{
			const K&amp; operator()(const pair&lt;K, V&gt;&amp; kv)
			{
				return kv.first;
			}
		};
    //....
    private:
	RBTree&lt;K, pair&lt;K, V&gt;, MapKeyOfT&gt; _t;
    }</code></pre> 
<p>这样一来，当底层红黑树需要进行两个结点之间键值的比较时，都会通过传入的仿函数来获取相应结点的键值，然后再进行比较</p> 
<p>例如我们find()的实现</p> 
<pre><code>iterator find(const K&amp; key)
		{
			KOfT koft;
			Node* cur = _root;
			while (cur)
			{
				if (key &lt; koft(cur-&gt;_data))
				{
					cur = cur-&gt;_left;
				}
				else if (key &gt; koft(cur-&gt;_data))
				{
					cur = cur-&gt;_right; 
				}
				else 
				{
					return iterator(cur); 
				}
			}
			return end(); 
		}</code></pre> 
<p><strong>注意：</strong> 所有进行结点键值比较的地方，均需要通过仿函数获取对应结点的键值后再进行键值的比较。</p> 
<h2 id="%E8%BF%AD%E4%BB%A3%E5%99%A8%E7%9A%84%E5%AE%9E%E7%8E%B0" style="background-color:transparent;">迭代器的实现</h2> 
<blockquote> 
 <p>类似于list的迭代器，红黑树的迭代器实际上就是对结点指针进行了封装，因此在正向迭代器当中实际上就只有一个成员变量，那就是正向迭代器所封装结点的指针。</p> 
 <p>而为了体现复用，我们传入Ref和Ptr两个模板参数，就可以复用出const迭代器</p> 
</blockquote> 
<p>对于基本的解引用，-&gt;访问 ， ==  , !=就不再赘述 ，<strong>难处在于++，--的实现</strong></p> 
<pre><code>template&lt;class T , class Ref , class Ptr&gt;
	class _TreeIterator
	{
		typedef RBTreeNode&lt;T&gt; Node;
		typedef _TreeIterator&lt;T, Ref, Ptr&gt; Self;


	public:
		_TreeIterator(Node* node):_node(node)
		{}

		Ref operator*()
		{
			return this-&gt;_node-&gt;_data;
		}

		Ptr operator-&gt;()
		{
			return &amp;(_node-&gt;_data);
		}

		bool operator==(const Self&amp; it)
		{
			return it._node == _node;
		}

		bool operator!=(const Self&amp; it)
		{
			return it._node != _node;
		}
	private:
		Node* _node;
	};</code></pre> 
<blockquote> 
 <p>无论红黑树还是AVL树其本质都是二叉排序树的一种，既然叫做排序树，自然迭代器的移动要保持有序的状态，--，++都与大小挂钩</p> 
</blockquote> 
<p>对于++，我们的下一个节点自然是比当前大，即<strong>中序遍历的后继节点</strong></p> 
<blockquote> 
 <p><strong>具体逻辑如下：</strong></p> 
 <ol><li>如果当前结点的右子树不为空，则<code>++</code>操作后应该找到其右子树当中的最左结点。</li><li>如果当前结点的右子树为空，则<code>++</code>操作后应该在该结点的祖先结点中，找到孩子不在父亲右的祖先。</li></ol> 
</blockquote> 
<p>代码如下：</p> 
<pre><code>        Self&amp; operator--()
		{
			
			if (_node-&gt;_left)
			{
				Node* LeftMax = _node-&gt;_left;
				while (LeftMax-&gt;_right)
					LeftMax = LeftMax-&gt;_right;
				_node = LeftMax;
			}
			else
			{
				Node* parent = _node-&gt;_parent;
				Node* cur = _node;
				while (parent &amp;&amp; cur == parent-&gt;_left)
				{
					cur = parent;
					parent = parent-&gt;_parent;
				}
				_node = parent;
			}
			return *this;
		}
		Self operator++(int)
		{
			iterator ret(*this);
			++(*this);
			return ret;
		}</code></pre> 
<p>同理，对于--，我们的上一个节点即中序遍历的前驱节点</p> 
<p>代码如下：</p> 
<pre><code>		Self&amp; operator--()
		{
			
			if (_node-&gt;_left)
			{
				Node* LeftMax = _node-&gt;_left;
				while (LeftMax-&gt;_right)
					LeftMax = LeftMax-&gt;_right;
				_node = LeftMax;
			}
			else
			{
				Node* parent = _node-&gt;_parent;
				Node* cur = _node;
				while (parent &amp;&amp; cur == parent-&gt;_left)
				{
					cur = parent;
					parent = parent-&gt;_parent;
				}
				_node = parent;
			}
			return *this;
		}

		Self operator--(int)
		{
			Self ret(*this);
			--(*this);
			return ret;
		}</code></pre> 
<p>实现迭代器基本功能后，我们就可以在红黑树中引入迭代器</p> 
<pre><code>	public:
		typedef _TreeIterator&lt;T, T&amp;, T*&gt; iterator;
		typedef _TreeIterator&lt;T, const T&amp;, const T*&gt; const_iterator;</code></pre> 
<p>接着再实现begin,end接口</p> 
<blockquote> 
 <ul><li>begin函数返回中序序列当中第一个结点的正向迭代器，即最左结点。</li><li>end函数返回中序序列当中最后一个结点下一个位置的正向迭代器，这里直接用空指针构造一个正向迭代器。<strong>（但这是不完善的，无法令end--，如果要实现完善的迭代器需要用一个header节点的parent指向root对root进行封装）</strong></li></ul> 
</blockquote> 
<pre><code>const_iterator cend()
		{
			Node* cur = _root;
			while (cur &amp;&amp; cur-&gt;_right)
				cur = cur-&gt;_right;
			return const_iterator(cur);
		}

		const_iterator cbegin()
		{
			Node* cur = _root;
			while (cur &amp;&amp; cur-&gt;_left)
				cur = cur-&gt;_left;
			return const_iterator(cur);
		}

		iterator begin()
		{
			Node* cur = _root;
			while (cur &amp;&amp; cur-&gt;_left)
				cur = cur-&gt;_left;
			return iterator(cur);
		}

		iterator end()
		{
			Node* cur = _root;
			while (cur &amp;&amp; cur-&gt;_right)
				cur = cur-&gt;_right;
			return iterator(cur);
		}</code></pre> 
<blockquote> 
 <p><strong>下面介绍以下STL源码里迭代器的正确实现</strong></p> 
</blockquote> 
<p><img alt="" height="390" src="https://images2.imgbox.com/e3/95/EmuZ7x2p_o.png" width="756"></p> 
<p></p> 
<p>C++STL库当中实现红黑树时，在红黑树的根结点处增加了一个头结点，该头结点的左指针指向红黑树当中的最左结点，右指针指向红黑树当中的最右结点，父指针指向红黑树的根结点。</p> 
<p>在该结构下，实现<code>begin()</code>时，直接用头结点的左孩子构造一个正向迭代器即可，实现<code>rbegin()</code>时，直接用头结点的右孩子构造一个反向迭代器即可（实际是先用该结点构造一个正向迭代器，再用正向迭代器构造出反向迭代器），而实现<code>end()</code>和<code>rend()</code>时，直接用头结点构造出正向和反向迭代器即可。此后，通过对逻辑的控制，就可以实现<code>end()</code>进行<code>--</code>操作后得到最后一个结点的正向迭代器。</p> 
<p>但实现该结构需要更改当前很多函数的逻辑，例如插入结点时，若插入到了红黑树最左结点的左边，或最右结点的右边，此时需要更新头结点左右指针的指向，这里就不进行实际实现了。</p> 
<p><strong>反向迭代器</strong></p> 
<p>红黑树的反向迭代器实际上就是正向迭代器的一个封装，因此红黑树的反向迭代器就是一个迭代器适配器。也不再进行实现了</p> 
<h2>封装后的红黑树源码</h2> 
<pre><code class="hljs">#ifndef RBTREE_H
#define RBTREE_H
namespace Simulate
{
	enum class Colour
	{
		RED, BLACK
	};
	template&lt;class T&gt;
	struct RBTreeNode
	{

		RBTreeNode(const T&amp; data) :
			_left(nullptr), _right(nullptr), _parent(nullptr), _data(data), _col(Colour::RED)
		{}
		RBTreeNode&lt;T&gt;* _left;
		RBTreeNode&lt;T&gt;* _right;
		RBTreeNode&lt;T&gt;* _parent;
		T _data;
		Colour _col;
	};

	template&lt;class T , class Ref , class Ptr&gt;
	class _TreeIterator
	{
		typedef RBTreeNode&lt;T&gt; Node;
		typedef _TreeIterator&lt;T, Ref, Ptr&gt; Self;


	public:
		_TreeIterator(Node* node):_node(node)
		{}

		Ref operator*()
		{
			return this-&gt;_node-&gt;_data;
		}

		Ptr operator-&gt;()
		{
			return &amp;(_node-&gt;_data);
		}

		Self&amp; operator++()
		{
			if (_node-&gt;_right)
			{
				Node* RightMin = _node-&gt;_right;
				while (RightMin-&gt;_left)
					RightMin = RightMin-&gt;_left;
				_node = RightMin;
			}
			else
			{
				Node* parent = _node-&gt;_parent;
				Node* cur = _node;
				while (parent &amp;&amp; cur == parent-&gt;_right)
				{
					cur = parent;
					parent = parent-&gt;_parent;
				}
				_node = parent;
			}
			return *this;
		}

		Self operator++(int)
		{
			iterator ret(*this);
			++(*this);
			return ret;
		}

		Self&amp; operator--()
		{
			
			if (_node-&gt;_left)
			{
				Node* LeftMax = _node-&gt;_left;
				while (LeftMax-&gt;_right)
					LeftMax = LeftMax-&gt;_right;
				_node = LeftMax;
			}
			else
			{
				Node* parent = _node-&gt;_parent;
				Node* cur = _node;
				while (parent &amp;&amp; cur == parent-&gt;_left)
				{
					cur = parent;
					parent = parent-&gt;_parent;
				}
				_node = parent;
			}
			return *this;
		}

		Self operator--(int)
		{
			Self ret(*this);
			--(*this);
			return ret;
		}

		bool operator==(const Self&amp; it)
		{
			return it._node == _node;
		}

		bool operator!=(const Self&amp; it)
		{
			return it._node != _node;
		}
	private:
		Node* _node;
	};


	template&lt;class K, class T , class KOfT&gt;
	class RBTree
	{
		typedef RBTreeNode&lt;T&gt; Node;
	public:
		typedef _TreeIterator&lt;T, T&amp;, T*&gt; iterator;
		typedef _TreeIterator&lt;T, const T&amp;, const T*&gt; const_iterator;

		RBTree():_root(nullptr)
		{}

		RBTree(const RBTree&lt;K, T , KOfT&gt;&amp; t)
		{
			_root = _Copy(t._root, nullptr);
		}

		RBTree&lt;K, T, KOfT&gt;&amp; operator=(RBTree&lt;K, T, KOfT&gt; t)
		{
			swap(_root, t._root);
			return *this;
		}

		~RBTree()
		{
			_Destroy(_root);
			_root = nullptr;
		}

		iterator find(const K&amp; key)
		{
			KOfT koft;
			Node* cur = _root;
			while (cur)
			{
				if (key &lt; koft(cur-&gt;_data))
				{
					cur = cur-&gt;_left;
				}
				else if (key &gt; koft(cur-&gt;_data))
				{
					cur = cur-&gt;_right; 
				}
				else 
				{
					return iterator(cur); 
				}
			}
			return end(); 
		}


		const_iterator cend()
		{
			Node* cur = _root;
			while (cur &amp;&amp; cur-&gt;_right)
				cur = cur-&gt;_right;
			return const_iterator(cur);
		}

		const_iterator cbegin()
		{
			Node* cur = _root;
			while (cur &amp;&amp; cur-&gt;_left)
				cur = cur-&gt;_left;
			return const_iterator(cur);
		}

		iterator begin()
		{
			Node* cur = _root;
			while (cur &amp;&amp; cur-&gt;_left)
				cur = cur-&gt;_left;
			return iterator(cur);
		}

		iterator end()
		{
			Node* cur = _root;
			while (cur &amp;&amp; cur-&gt;_right)
				cur = cur-&gt;_right;
			return iterator(cur);
		}
		bool erase(const K&amp; k)
		{
			KOfT koft;
			Node* cur = _root;
			Node* parent = nullptr;

			Node* delPos = nullptr;
			Node* delParentPos = nullptr;

			while (cur)
			{
				if (k &gt; koft(cur-&gt;_data))
				{
					parent = cur;
					cur = cur-&gt;_right;
				}
				else if (k &lt; koft(cur-&gt;_data))
				{
					parent = cur;
					cur = cur-&gt;_left;
				}
				else
				{
					if (cur-&gt;_left == nullptr)
					{
						if (cur == _root)
						{
							_root = cur-&gt;_right;
							if (_root)
							{
								_root-&gt;_parent = nullptr;
								_root-&gt;_col = Colour::BLACK;
							}
							delete cur;
							return true;
						}
						else
						{
							delParentPos = parent;
							delPos = cur;
						}
						break;
					}
					else if (cur-&gt;_right == nullptr)
					{
						if (cur == _root)
						{
							_root = cur-&gt;_left;
							if (_root)
							{
								_root-&gt;_parent = nullptr;
								_root-&gt;_col = Colour::BLACK;
							}
							delete cur;
							return true;
						}
						else
						{
							delParentPos = parent;
							delPos = cur;
						}
						break;
					}
					else
					{
						Node* RightMin = cur-&gt;_right;
						Node* minParent = cur;

						while (RightMin-&gt;_left)
						{
							minParent = RightMin;
							RightMin = RightMin-&gt;_left;
						}

						cur-&gt;_data = RightMin-&gt;_data;
						delParentPos = minParent;
						delPos = RightMin;
						break;
					}
				}
			}

			if (delPos == nullptr)//没有找到待删除节点
			{
				return false;
			}

			Node* del = delPos;
			Node* delP = delParentPos;

			if (delPos-&gt;_col == Colour::BLACK)
			{
				//delPos最多只有一个孩子
				if (delPos-&gt;_left)
				{
					delPos-&gt;_left-&gt;_col = Colour::BLACK;
				}
				else if (delPos-&gt;_right)
				{
					delPos-&gt;_right-&gt;_col = Colour::BLACK;
				}
				else
				{
					//brother 一定存在,不然无法满足各路径黑色数量相同的性质
					while (delPos != _root)
					{
						if (delPos == delParentPos-&gt;_left)
						{
							Node* brother = delParentPos-&gt;_right;

							//case 1

							if (brother-&gt;_col == Colour::RED)
							{
								delParentPos-&gt;_col = Colour::RED;
								brother-&gt;_col = Colour::BLACK;
								RotateL(delParentPos);
								brother = delParentPos-&gt;_right;
							}

							//case 2

							if ((brother-&gt;_left == nullptr || brother-&gt;_left-&gt;_col == Colour::BLACK)
								&amp;&amp; (brother-&gt;_right == nullptr || brother-&gt;_right-&gt;_col == Colour::BLACK))
							{
								brother-&gt;_col = Colour::RED;
								if (delParentPos-&gt;_col == Colour::RED)
								{
									delParentPos-&gt;_col = Colour::BLACK;
									break;
								}
								else
								{
									delPos = delParentPos;
									delParentPos = delParentPos-&gt;_parent;
								}
							}

							//case 3
							else
							{
								if (brother-&gt;_right == nullptr || brother-&gt;_right-&gt;_col == Colour::BLACK)
								{
									brother-&gt;_col = Colour::RED;
									brother-&gt;_left-&gt;_col = Colour::BLACK;
									RotateR(brother);
									brother = delParentPos-&gt;_right;
								}
								//case 4
								brother-&gt;_col = delParentPos-&gt;_col;
								brother-&gt;_right-&gt;_col = Colour::BLACK;
								delParentPos-&gt;_col = Colour::BLACK;
								RotateL(delParentPos);
								break;
							}
						}
						else
						{
							Node* brother = delParentPos-&gt;_left;

							//case 1
							if (brother-&gt;_col == Colour::RED)
							{
								delParentPos-&gt;_col = Colour::RED;
								brother-&gt;_col = Colour::BLACK;
								RotateR(delParentPos);
								brother = delParentPos-&gt;_left;
							}

							//case 2
							if ((brother-&gt;_left == nullptr || brother-&gt;_left-&gt;_col == Colour::BLACK)
								&amp;&amp; (brother-&gt;_right == nullptr || brother-&gt;_right-&gt;_col == Colour::BLACK))
							{
								brother-&gt;_col = Colour::RED;
								if (delParentPos-&gt;_col == Colour::RED)
								{
									delParentPos-&gt;_col = Colour::BLACK;
									break;
								}
								else
								{
									delPos = delParentPos;
									delParentPos = delParentPos-&gt;_parent;
								}
							}

							else
							{
								//case 3
								if (brother-&gt;_left == nullptr || brother-&gt;_left-&gt;_col == Colour::BLACK)
								{
									brother-&gt;_right-&gt;_col = Colour::BLACK;
									brother-&gt;_col = Colour::RED;
									RotateL(brother);
									brother = delParentPos-&gt;_left;
								}
								//case 4
								brother-&gt;_col = delParentPos-&gt;_col;
								delParentPos-&gt;_col = Colour::RED;
								brother-&gt;_left-&gt;_col = Colour::BLACK;
								RotateR(delParentPos);
								break;
							}
						}
					}
				}
			}

			//删除操作
			if (del-&gt;_left == nullptr)
			{
				if (delP-&gt;_left == del)
				{
					delP-&gt;_left = del-&gt;_right;
				}
				else
				{
					delP-&gt;_right = del-&gt;_right;
				}
				if (del-&gt;_right)
					del-&gt;_right-&gt;_parent = delP;
			}
			else
			{
				if (delP-&gt;_left == del)
				{
					delP-&gt;_left = del-&gt;_left;
				}
				else
				{
					delP-&gt;_right = del-&gt;_left;
				}
				if (del-&gt;_right)
					del-&gt;_right-&gt;_parent = delP;
			}

			return true;
		}


		pair&lt;iterator, bool&gt; insert(const T&amp; data)
		{
			if (!_root)
			{
				_root = new Node(data);
				_root-&gt;_col = Colour::BLACK;
				return make_pair(iterator(_root), true);
			}

			KOfT koft;

			Node* parent = nullptr;
			Node* cur = _root;
			while (cur)
			{
				parent = cur;

				if (koft(cur-&gt;_data) &gt; koft(data))
				{
					cur = cur-&gt;_left;
				}
				else if (koft(cur-&gt;_data) &lt; koft(data))
				{
					cur = cur-&gt;_right;
				}
				else
				{
					return make_pair(iterator(cur), false);
				}
			}

			cur = new Node(data);
			if (koft(parent-&gt;_data) &gt; koft(cur-&gt;_data))
			{
				parent-&gt;_left = cur;
			}
			else
			{
				parent-&gt;_right = cur;
			}
			cur-&gt;_parent = parent;



			while (parent &amp;&amp; parent-&gt;_col == Colour::RED)
			{
				Node* grandfather = parent-&gt;_parent;
				if (grandfather-&gt;_left == parent)
				{
					Node* uncle = grandfather-&gt;_right;
					//case 1  uncle存在且为红

					if (uncle &amp;&amp; uncle-&gt;_col == Colour::RED)
					{
						uncle-&gt;_col = parent-&gt;_col = Colour::BLACK;
						grandfather-&gt;_col = Colour::RED;

						//adjustup
						cur = grandfather;
						parent = cur-&gt;_parent;
					}
					//case 2  uncle存在且为黑
					//case 3  uncle不存在
					else
					{
						if (parent-&gt;_right == cur)
						{
							RotateL(parent);
							RotateR(grandfather);
							cur-&gt;_col = Colour::BLACK;
							grandfather-&gt;_col = Colour::RED;
						}
						else
						{
							RotateR(grandfather);
							grandfather-&gt;_col = Colour::RED;
							parent-&gt;_col = Colour::BLACK;
						}
						break;
					}
				}
				else
				{
					Node* uncle = grandfather-&gt;_left;


					if (uncle &amp;&amp; uncle-&gt;_col == Colour::RED)
					{
						uncle-&gt;_col = parent-&gt;_col = Colour::BLACK;
						grandfather-&gt;_col = Colour::RED;

						cur = grandfather;
						parent = cur-&gt;_parent;
					}
					else
					{
						if (parent-&gt;_left == cur)
						{
							RotateR(parent);
							RotateL(grandfather);
							cur-&gt;_col = Colour::BLACK;
							grandfather-&gt;_col = Colour::RED;
						}
						else
						{
							RotateL(grandfather);
							grandfather-&gt;_col = Colour::RED;
							parent-&gt;_col = Colour::BLACK;
						}
						break;
					}
				}



			}

			_root-&gt;_col = Colour::BLACK;
			return make_pair(iterator(cur), true);
		}

		void InOrder()
		{
			KOfT koft;
			_InOrder(_root, koft);
		}
		//判断是否为红黑树
		bool ISRBTree()
		{
			if (_root == nullptr) //空树是红黑树
			{
				return true;
			}
			if (_root-&gt;_col == Colour::RED)
			{
				cout &lt;&lt; "error：根结点为红色" &lt;&lt; endl;
				return false;
			}

			//找最左路径作为黑色结点数目的参考值
			Node* cur = _root;
			int BlackCount = 0;
			while (cur)
			{
				if (cur-&gt;_col == Colour::BLACK)
					BlackCount++;
				cur = cur-&gt;_left;
			}

			int count = 0;
			return _ISRBTree(_root, count, BlackCount);
		}


	private:

		Node* _Copy(Node* root, Node* parent)
		{
			if (root == nullptr)
			{
				return nullptr;
			}
			Node* copyNode = new Node(root-&gt;_data);
			copyNode-&gt;_parent = parent;
			copyNode-&gt;_left = _Copy(root-&gt;_left, copyNode);
			copyNode-&gt;_right = _Copy(root-&gt;_right, copyNode);
			return copyNode;
		}

		void _Destroy(Node* root)
		{
			if (root == nullptr)
			{
				return;
			}
			_Destroy(root-&gt;_left);
			_Destroy(root-&gt;_right);
			delete root;
		}

		//判断是否为红黑树的子函数
		bool _ISRBTree(Node* root, int count, int BlackCount)
		{
			if (root == nullptr) //该路径已经走完了
			{
				if (count != BlackCount)
				{
					cout &lt;&lt; "error：黑色结点的数目不相等" &lt;&lt; endl;
					return false;
				}
				return true;
			}

			if (root-&gt;_col == Colour::RED &amp;&amp; root-&gt;_parent-&gt;_col == Colour::RED)
			{
				cout &lt;&lt; "error：存在连续的红色结点" &lt;&lt; endl;
				return false;
			}
			if (root-&gt;_col == Colour::BLACK)
			{
				count++;
			}
			return _ISRBTree(root-&gt;_left, count, BlackCount) &amp;&amp; _ISRBTree(root-&gt;_right, count, BlackCount);
		}
		void _InOrder(Node* root , KOfT&amp; koft)
		{
			if (!root)
				return;
			_InOrder(root-&gt;_left, koft);
			cout &lt;&lt; koft(root-&gt;_data) &lt;&lt; endl;
			_InOrder(root-&gt;_right, koft);
		}
		void RotateL(Node* parent)
		{
			Node* SubR = parent-&gt;_right;
			Node* SubRL = SubR-&gt;_left;
			Node* ppNode = parent-&gt;_parent;

			parent-&gt;_right = SubRL;
			if (SubRL)
				SubRL-&gt;_parent = parent;

			SubR-&gt;_left = parent;
			parent-&gt;_parent = SubR;

			if (_root == parent)// _root == parent
			{
				_root = SubR;
			}
			else
			{
				if (ppNode-&gt;_left == parent)
					ppNode-&gt;_left = SubR;
				else
					ppNode-&gt;_right = SubR;
			}
			SubR-&gt;_parent = ppNode;

		}
		void RotateR(Node* parent)
		{
			Node* SubL = parent-&gt;_left;
			Node* SubLR = SubL-&gt;_right;
			Node* ppNode = parent-&gt;_parent;

			parent-&gt;_left = SubLR;
			if (SubLR)
				SubLR-&gt;_parent = parent;

			SubL-&gt;_right = parent;
			parent-&gt;_parent = SubL;


			if (_root == parent)// _root == parent
			{
				_root = SubL;
			}
			else
			{
				if (ppNode-&gt;_left == parent)
					ppNode-&gt;_left = SubL;
				else
					ppNode-&gt;_right = SubL;
			}
			SubL-&gt;_parent = ppNode;
		}
		Node* _root = nullptr;
	};

}

#endif // !RBTREE_H</code></pre> 
<h2 id="set%E7%9A%84%E6%A8%A1%E6%8B%9F%E5%AE%9E%E7%8E%B0" style="background-color:transparent;">set的模拟实现</h2> 
<p>完成上述操作后，set的模拟实现也就很简单了，其中的成员函数都是调用底层红黑树的对应接口就行了，只不过需要注意将插入函数和查找函数返回值当中的结点指针改为迭代器即可。</p> 
<p><strong>代码如下：</strong></p> 
<pre><code>
	template&lt;class K&gt;
	class set
	{
		struct SetKeyOfT
		{
			const K&amp; operator()(const K&amp; k)
			{
				return k;
			}
		};
		typedef typename Simulate::RBTree&lt;K, K, SetKeyOfT&gt;::iterator iterator;

	public:

		iterator begin()
		{
			return _t.begin();
		}
		iterator end()
		{
			return iterator(nullptr);
		}
		pair&lt;iterator, bool&gt; insert(const K&amp; k)
		{
			return _t.insert(k);
		}
		bool erase(const K&amp; k)
		{
			return _t.erase(k);
		}
		void InOrder()
		{
			_t.InOrder();
		}
	private:

		Simulate::RBTree&lt;K, K, SetKeyOfT&gt; _t;
	};

</code></pre> 
<h2 id="map%E7%9A%84%E6%A8%A1%E6%8B%9F%E5%AE%9E%E7%8E%B0">map的模拟实现</h2> 
<p>map的模拟实现也是相同的道理，其成员函数也是调用底层红黑树的对应接口，但对于map来说，除了将插入函数和查找函数返回值当中的结点指针改为迭代器之外，还需要实现<code>[]</code>运算符的重载函数。</p> 
<p><strong>代码如下：</strong></p> 
<pre><code>
	template&lt;class K ,class V&gt;
	class map
	{
		struct MapKeyOfT
		{
			const K&amp; operator()(const pair&lt;K, V&gt;&amp; kv)
			{
				return kv.first;
			}
		};


	public:

		typedef typename Simulate::RBTree&lt;K, pair&lt;K, V&gt;, MapKeyOfT&gt;::iterator iterator;
		typedef typename Simulate::RBTree&lt;K, pair&lt;K, V&gt;, MapKeyOfT&gt;::const_iterator const_iterator;
		
		V&amp; operator[](const K&amp; key)
		{
			pair&lt;iterator, bool&gt; ret = insert(make_pair(key, V()));
			iterator it = ret.first;
			return it-&gt;second;
		}

		const_iterator cbegin()
		{
			return _t.cbegin();
		}
		const_iterator cend()
		{
			return const_iterator(nullptr);
		}

		iterator begin()
		{
			return _t.begin();
		}
		iterator end()
		{
			return iterator(nullptr);
		}
		
		pair&lt;iterator,bool&gt; insert(const pair&lt;K, V&gt;&amp; kv)
		{
			return _t.insert(kv);
		}
		bool erase(const K&amp; k)
		{
			return _t.erase(k);
		}
		void InOrder()
		{
			_t.InOrder();
		}
	private:

		Simulate::RBTree&lt;K, pair&lt;K, V&gt;, MapKeyOfT&gt; _t;

	};
</code></pre> 
<p></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/3bfe65ef57f2e69f87f99716f0ad7e94/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">微信小程序实现身份证拍摄</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/3013470adba543acfcfe0f06913652c8/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">centos 7.9 部署 harbor 镜像仓库实践</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>