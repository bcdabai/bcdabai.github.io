<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>js中常见的几种对象遍历方式Object - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="js中常见的几种对象遍历方式Object" />
<meta property="og:description" content="一：自身可枚举属性
Object.keys() 方法会返回一个由一个给定对象的自身可枚举属性组成的数组，数组中属性名的排列顺序和使用 for...in 循环遍历该对象时返回的顺序一致 。如果对象的键-值都不可枚举，那么将返回由键组成的数组。
这是合理的，因为大多数时候只需要关注对象自身的属性。
来看看一个对象拥有自身和继承属性的例子，Object.keys()只返回自己的属性键：
let simpleColors = { nameA: &#39;a&#39;, nameB: &#39;b&#39; }; let natureColors = { colorC: &#39;green&#39;, colorD: &#39;yellow&#39; }; Object.setPrototypeOf(natureColors, simpleColors); Object.keys(natureColors); // =&gt; [&#39;colorC&#39;, &#39;colorD&#39;] natureColors[&#39;nameA&#39;]; // =&gt; &#39;a&#39; natureColors[&#39;nameB&#39;]; // =&gt; &#39;b&#39; Object.setPrototypeOf() 方法设置一个指定的对象的原型 ( 即, 内部[[Prototype]]属性）到另一个对象或 null。
Object.keys(natureColors)返回natureColors对象的自身可枚举属性键：[&#39;colorC&#39;，&#39;colorD&#39;]。
natureColors包含从simpleColors原型对象继承的属性，但是Object.keys()函数会跳过它们。
Object.values() 和 Object.entries() 也都是返回一个给定对象自身可枚举属性的键值对数组
Object.values(natureColors); // =&gt; [&#39;green&#39;, &#39;yellow&#39;] Object.entries(natureColors); // =&gt; [ [&#39;colorC&#39;, &#39;green&#39;], [&#39;colorD&#39;, &#39;yellow&#39;] ] 现在注意与for..in语句的区别，for..in不仅可以循环枚举自身属性还可以枚举原型链中的属性
let enumerableKeys = []; for (let key in natureColors) { enumerableKeys." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/3f8dc197c733d0581bb2eb8d7c8dfb2b/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2019-08-07T18:39:45+08:00" />
<meta property="article:modified_time" content="2019-08-07T18:39:45+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">js中常见的几种对象遍历方式Object</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-dracula">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p><strong>一：自身可枚举属性</strong><br> <code>Object.keys()</code> 方法会返回一个由一个给定对象的自身可枚举属性组成的数组，数组中属性名的排列顺序和使用 <code>for...in</code> 循环遍历该对象时返回的顺序一致 。如果对象的键-值都不可枚举，那么将返回由键组成的数组。<br> 这是合理的，因为大多数时候只需要关注对象自身的属性。<br> 来看看一个对象拥有自身和继承属性的例子，<code>Object.keys()</code>只返回自己的属性键：</p> 
<pre><code>
  let simpleColors = {
  nameA: 'a',
  nameB: 'b'
};
let natureColors = {
  colorC: 'green',
  colorD: 'yellow'
};
Object.setPrototypeOf(natureColors, simpleColors);
Object.keys(natureColors); // =&gt; ['colorC', 'colorD']
natureColors['nameA'];    // =&gt; 'a'
natureColors['nameB'];    // =&gt; 'b'

</code></pre> 
<p><code>Object.setPrototypeOf()</code> 方法设置一个指定的对象的原型 ( 即, 内部[[Prototype]]属性）到另一个对象或 null。<br> <code>Object.keys(natureColors)</code>返回<code>natureColors</code>对象的自身可枚举属性键：<code>['colorC'，'colorD']</code>。<br> <code>natureColors</code>包含从<code>simpleColors</code>原型对象继承的属性，但是<code>Object.keys()</code>函数会跳过它们。<br> <code>Object.values()</code> 和 <code>Object.entries()</code> 也都是返回一个给定对象自身可枚举属性的键值对数组</p> 
<pre><code>Object.values(natureColors); 
// =&gt; ['green', 'yellow']
Object.entries(natureColors);
// =&gt; [ ['colorC', 'green'], ['colorD', 'yellow'] ]
</code></pre> 
<p>现在注意与<code>for..in</code>语句的区别，<code>for..in</code>不仅可以循环枚举自身属性还可以枚举原型链中的属性</p> 
<pre><code>let enumerableKeys = [];
for (let key in natureColors) {
  enumerableKeys.push(key);
}
enumerableKeys; // =&gt; ['colorC', 'colorD', 'nameA', 'nameB']

</code></pre> 
<p><code>enumerableKeys</code>数组包含<code>natureColors</code>自身属性键: <code>'colorC'</code>和<code>'colorD'</code>。</p> 
<p>另外<code>for..in</code>也遍历了从<code>simpleColors</code>原型对象继承的属性</p> 
<p><strong>二：Object.values() 返回属性值</strong><br> <code>**Object.values()**</code>方法返回一个给定对象自身的所有可枚举属性值的数组，值的顺序与使用<code>for...in</code>循环的顺序相同 ( 区别在于 <code>for-in</code> 循环枚举原型链中的属性 )。</p> 
<p>例如我们可以使用<code>Object.keys()</code>收集<code>keys</code>，然后通过 <code>key</code> 去对象取对应的值：</p> 
<pre><code>let meals = {
  mealA: 'Breakfast',
  mealB: 'Lunch',
  mealC: 'Dinner'
};
for (let key of Object.keys(meals)) {
  let mealName = meals[key];
  // ... do something with mealName
  console.log(mealName);
}
// 'Breakfast' 'Lunch' 'Dinner'

</code></pre> 
<p><code>meal</code>是一个普通对象。 使用<code>Object.keys(meals)</code>和枚举的for…of循环获取对象键值。<br> 代码看起来很简单，但是，<code>let mealName = meals[key]</code> 没有多大的必要，可以进一步优化，如下：</p> 
<pre><code>let meals = {
  mealA: 'Breakfast',
  mealB: 'Lunch',
  mealC: 'Dinner'
};
for (let mealName of Object.values(meals)) {
  console.log(mealName);
}
// 'Breakfast' 'Lunch' 'Dinner'

</code></pre> 
<p>因为<code>Object.values(meals)</code>返回数组中的对象属性值，所以可以直接在 <code>for..of</code> 中简化。 <code>mealName</code>直接在循环中赋值。</p> 
<p><strong>三：Object.entries()</strong><br> <code>**Object.entries()**</code>方法返回一个给定对象自身可枚举属性的键值对数组，其排列与使用 for…in 循环遍历该对象时返回的顺序一致（区别在于 <code>for-in</code> 循环也枚举原型链中的属性）。</p> 
<p><code>Object.entries()</code> 返回键值对数组，如 <code>[ [key1, value1], [key2, value2], ..., [keyN, valueN] ]。</code><br> 可能直接使用这些键值对不怎么方便，但可以通过数组解构赋值方式访问键和值就变得非常容易，如下所示：</p> 
<pre><code>let meals = {
  mealA: 'Breakfast',
  mealB: 'Lunch',
  mealC: 'Dinner'
};
for (let [key, value] of Object.entries(meals)) {
  console.log(key + ':' + value);
}
// 'mealA:Breakfast' 'mealB:Lunch' 'mealC:Dinner'

</code></pre> 
<p>如上所示，因为 <code>Object.entries()</code>返回一个与数组解构赋值兼容的集合，因此不需要为赋值或声明添加额外的行。</p> 
<p>当普通对象要转换成 <code>Map</code> 时<code>Object.entries()</code> 就很有用，因为<code>Object.entries()</code> 返回的格式与<code>Map</code>构造函数接受的格式完全相同：<code>(key,value)</code>。</p> 
<p>使用常规的<code>Map</code>构造函数可以将一个二维键值对数组转换成一个<code>Map</code>对象。<br> 来个例子，让人缓缓：</p> 
<pre><code>
  let greetings = {
  morning: 'Good morning',
  midday: 'Good day',
  evening: 'Good evening'
};
let greetingsMap = new Map(Object.entries(greetings));
greetingsMap.get('morning'); // =&gt; 'Good morning'
greetingsMap.get('midday');  // =&gt; 'Good day'
greetingsMap.get('evening'); // =&gt; 'Good evening'

</code></pre> 
<p><code>Map</code> 对象保存键值对。任何值(对象或者原始值) 都可以作为一个键或一个值</p> 
<p>有趣的是，<code>Map</code>提供了与<code>Object.values()</code>和<code>Object.entries()</code> 等效的方法（只是它们返回<code>Iterators</code>），以便为<code>Map</code>实例提取属性值或键值对：</p> 
<p><code>Map.prototype.values()</code> 等价于<code>Object.values()</code></p> 
<p><code>Map.prototype.entries()</code> 等价于<code>Object</code>.<code>entries</code>()`</p> 
<p><code>map</code>是普通对象的改进版本，可以获取 <code>map</code> 的大小(对于普通对象，必须手动获取)，并使用任意对象类型作为键(普通对象使用字符串基元类型作为键)。<br> 让我们看看返回.<code>values（）</code>和.<code>entries（）</code>的<code>map</code>的方法：</p> 
<pre><code>[...greetingsMap.values()];
// =&gt; ['Good morning', 'Good day', 'Good evening']
[...greetingsMap.entries()];
// =&gt; [ ['morning', 'Good morning'], ['midday', 'Good day'], 
//      ['evening', 'Good evening'] ]

</code></pre> 
<p>注意，<code>greetingsMap.values()</code>和<code>greetingsMap.entries()</code>返回迭代器对象。若要将结果放入数组，扩展运算符<code>…</code>是必要的。</p> 
<p><strong>四：对象属性的顺序</strong></p> 
<p><code>JS</code> 对象是简单的键值映射，因此，对象中属性的顺序是微不足道的， 在大多数情况下，不应该依赖它。<br> 在<code>ES5</code>和早期标准中，根本没有指定属性的顺序。<br> 然而，从<code>ES 6</code>开始，属性的顺序是基于一个特殊的规则的，除非特指按照时间排序。通过两个新方法<code>Object.getOwnPropertyNames</code>和<code>Reflect.ownKeys</code>来编写示例讲解这一属性排序规则。</p> 
<p>数字：当属性的类型时数字类型时，会按照数字的从大到小的顺序进行排序；<br> 字符串：当属性的类型是字符串时，会按照时间的先后顺序进行排序；<br> <code>Symbol</code>：当属性的类型是<code>Symbol</code>时，会按照时间的先后顺序进行排序。<br> 如果需要有序集合，建议将数据存储到数组或<code>Set</code>中。</p> 
<p><strong>五：结束语</strong></p> 
<p><code>Object.values()</code> 和<code>Object.entries()</code> 是为<code>JS</code>开发人员提供新的标准化辅助函数的另一个改进步骤。<br> <code>Object.entries()</code>最适用于数组解构赋值，其方式是将键和值轻松分配给不同的变量。 此函数还可以轻松地将纯<code>JS</code>对象属性映射到Map对象中。、<br> 注意，<code>Object.values()</code>和<code>Object.entries()</code>返回数据的顺序是不确定的，所以不要依赖该方式。</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/608aa1c63581b2bd925bc55402705d28/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">css优化滚动条样式</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/45f7629b57ccfdaf86d4e149a790df65/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">链表每一个节点的数据类型该如何表示</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>