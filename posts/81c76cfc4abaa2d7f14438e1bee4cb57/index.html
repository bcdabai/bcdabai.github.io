<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Mysql 隐式类型转换 可能不走索引？ - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Mysql 隐式类型转换 可能不走索引？" />
<meta property="og:description" content="Mysql 隐式类型转换 可能不走索引？ 在实际开发和运维过程中有没有发现，在对一张数据量很大的表执行查询的时候，明明 where 条件后面的字段有索引的啊，可是查询耗时却相当长，这是为什么呢？
先说结论：Mysql在 varchar 类型字段的索引中如果发生了隐式类型转换，则索引将失效。
创建user表，具有name 和 age 两个属性，还有一个 id 的主键字段：
CREATE TABLE `user` ( `id` int(11) NOT NULL AUTO_INCREMENT, `name` varchar(255) DEFAULT NULL, `age` int(11) DEFAULT NULL, PRIMARY KEY (`id`), KEY `user_name` (`name`), KEY `user_age` (`age`) ) ENGINE=InnoDB DEFAULT CHARSET=utf8; 我们分别为 name 和 age 这两个字段建立了索引，下面我们就来对这两个索引进行测试和验证。
我们尝试一下用 age 字段进行正常类型的查询，看看执行计划是什么样的：
mysql&gt; explain select * from user where age = 1; &#43;----&#43;-------------&#43;-------&#43;------------&#43;------&#43;---------------&#43;----------&#43;---------&#43;-------&#43;------&#43;----------&#43;-------&#43; | id | select_type | table | partitions | type | possible_keys | key | key_len | ref | rows | filtered | Extra | &#43;----&#43;-------------&#43;-------&#43;------------&#43;------&#43;---------------&#43;----------&#43;---------&#43;-------&#43;------&#43;----------&#43;-------&#43; | 1 | SIMPLE | user | NULL | ref | user_age | user_age | 5 | const | 1 | 100." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/81c76cfc4abaa2d7f14438e1bee4cb57/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-07-22T15:35:59+08:00" />
<meta property="article:modified_time" content="2022-07-22T15:35:59+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Mysql 隐式类型转换 可能不走索引？</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <h3><a id="Mysql___0"></a>Mysql 隐式类型转换 可能不走索引？</h3> 
<p>在实际开发和运维过程中有没有发现，在对一张数据量很大的表执行查询的时候，明明 <code>where</code> 条件后面的字段有索引的啊，可是查询耗时却相当长，这是为什么呢？</p> 
<p>先说结论：Mysql在 <code>varchar</code> 类型字段的索引中如果发生了隐式类型转换，则索引将失效。</p> 
<p>创建user表，具有<code>name</code> 和 <code>age</code> 两个属性，还有一个 <code>id</code> 的主键字段：</p> 
<pre><code class="prism language-sql"><span class="token keyword">CREATE</span> <span class="token keyword">TABLE</span> <span class="token identifier"><span class="token punctuation">`</span>user<span class="token punctuation">`</span></span> <span class="token punctuation">(</span>
  <span class="token identifier"><span class="token punctuation">`</span>id<span class="token punctuation">`</span></span> <span class="token keyword">int</span><span class="token punctuation">(</span><span class="token number">11</span><span class="token punctuation">)</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span> <span class="token keyword">AUTO_INCREMENT</span><span class="token punctuation">,</span>
  <span class="token identifier"><span class="token punctuation">`</span>name<span class="token punctuation">`</span></span> <span class="token keyword">varchar</span><span class="token punctuation">(</span><span class="token number">255</span><span class="token punctuation">)</span> <span class="token keyword">DEFAULT</span> <span class="token boolean">NULL</span><span class="token punctuation">,</span>
  <span class="token identifier"><span class="token punctuation">`</span>age<span class="token punctuation">`</span></span> <span class="token keyword">int</span><span class="token punctuation">(</span><span class="token number">11</span><span class="token punctuation">)</span> <span class="token keyword">DEFAULT</span> <span class="token boolean">NULL</span><span class="token punctuation">,</span>
  <span class="token keyword">PRIMARY</span> <span class="token keyword">KEY</span> <span class="token punctuation">(</span><span class="token identifier"><span class="token punctuation">`</span>id<span class="token punctuation">`</span></span><span class="token punctuation">)</span><span class="token punctuation">,</span>
  <span class="token keyword">KEY</span> <span class="token identifier"><span class="token punctuation">`</span>user_name<span class="token punctuation">`</span></span> <span class="token punctuation">(</span><span class="token identifier"><span class="token punctuation">`</span>name<span class="token punctuation">`</span></span><span class="token punctuation">)</span><span class="token punctuation">,</span>
  <span class="token keyword">KEY</span> <span class="token identifier"><span class="token punctuation">`</span>user_age<span class="token punctuation">`</span></span> <span class="token punctuation">(</span><span class="token identifier"><span class="token punctuation">`</span>age<span class="token punctuation">`</span></span><span class="token punctuation">)</span>
<span class="token punctuation">)</span> <span class="token keyword">ENGINE</span><span class="token operator">=</span><span class="token keyword">InnoDB</span> <span class="token keyword">DEFAULT</span> <span class="token keyword">CHARSET</span><span class="token operator">=</span>utf8<span class="token punctuation">;</span>
</code></pre> 
<p>我们分别为 <code>name</code> 和 <code>age</code> 这两个字段建立了索引，下面我们就来对这两个索引进行测试和验证。</p> 
<p>我们尝试一下用 <code>age</code> 字段进行正常类型的查询，看看执行计划是什么样的：</p> 
<pre><code class="prism language-sql">mysql<span class="token operator">&gt;</span> <span class="token keyword">explain</span> <span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> <span class="token keyword">user</span> <span class="token keyword">where</span> age <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
<span class="token operator">+</span><span class="token comment">----+-------------+-------+------------+------+---------------+----------+---------+-------+------+----------+-------+</span>
<span class="token operator">|</span> id <span class="token operator">|</span> select_type <span class="token operator">|</span> <span class="token keyword">table</span> <span class="token operator">|</span> partitions <span class="token operator">|</span> <span class="token keyword">type</span> <span class="token operator">|</span> possible_keys <span class="token operator">|</span> <span class="token keyword">key</span>      <span class="token operator">|</span> key_len <span class="token operator">|</span> ref   <span class="token operator">|</span> <span class="token keyword">rows</span> <span class="token operator">|</span> filtered <span class="token operator">|</span> Extra <span class="token operator">|</span>
<span class="token operator">+</span><span class="token comment">----+-------------+-------+------------+------+---------------+----------+---------+-------+------+----------+-------+</span>
<span class="token operator">|</span>  <span class="token number">1</span> <span class="token operator">|</span> <span class="token keyword">SIMPLE</span>      <span class="token operator">|</span> <span class="token keyword">user</span>  <span class="token operator">|</span> <span class="token boolean">NULL</span>       <span class="token operator">|</span> ref  <span class="token operator">|</span> user_age      <span class="token operator">|</span> user_age <span class="token operator">|</span> <span class="token number">5</span>       <span class="token operator">|</span> const <span class="token operator">|</span>    <span class="token number">1</span> <span class="token operator">|</span>   <span class="token number">100.00</span> <span class="token operator">|</span> <span class="token boolean">NULL</span>  <span class="token operator">|</span>
<span class="token operator">+</span><span class="token comment">----+-------------+-------+------------+------+---------------+----------+---------+-------+------+----------+-------+</span>
<span class="token number">1</span> <span class="token keyword">row</span> <span class="token operator">in</span> <span class="token keyword">set</span><span class="token punctuation">,</span> <span class="token number">1</span> warning <span class="token punctuation">(</span><span class="token number">0.00</span> sec<span class="token punctuation">)</span>
</code></pre> 
<p>我们可以看到执行计划的 <code>type</code> 列显示为 <code>ref</code> 并且 <code>possible_keys</code> 列为 <code>user_age</code> 表明可能会用到索引，而 <code>key</code> 列的值为 <code>user_age</code> 则表明最终将决定采用 <code>user_age</code> 索引。</p> 
<p><code>age</code> 字段本身是数字类型，那么对数字类型进行隐式类型转换的查询会用到索引吗？我们继续测试，将 <code>where</code> 条件中的数字 <code>1</code> 改为字符串 <code>'1'</code>：</p> 
<pre><code class="prism language-sql">mysql<span class="token operator">&gt;</span> <span class="token keyword">explain</span> <span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> <span class="token keyword">user</span> <span class="token keyword">where</span> age <span class="token operator">=</span> <span class="token string">'1'</span><span class="token punctuation">;</span>
<span class="token operator">+</span><span class="token comment">----+-------------+-------+------------+------+---------------+----------+---------+-------+------+----------+-------+</span>
<span class="token operator">|</span> id <span class="token operator">|</span> select_type <span class="token operator">|</span> <span class="token keyword">table</span> <span class="token operator">|</span> partitions <span class="token operator">|</span> <span class="token keyword">type</span> <span class="token operator">|</span> possible_keys <span class="token operator">|</span> <span class="token keyword">key</span>      <span class="token operator">|</span> key_len <span class="token operator">|</span> ref   <span class="token operator">|</span> <span class="token keyword">rows</span> <span class="token operator">|</span> filtered <span class="token operator">|</span> Extra <span class="token operator">|</span>
<span class="token operator">+</span><span class="token comment">----+-------------+-------+------------+------+---------------+----------+---------+-------+------+----------+-------+</span>
<span class="token operator">|</span>  <span class="token number">1</span> <span class="token operator">|</span> <span class="token keyword">SIMPLE</span>      <span class="token operator">|</span> <span class="token keyword">user</span>  <span class="token operator">|</span> <span class="token boolean">NULL</span>       <span class="token operator">|</span> ref  <span class="token operator">|</span> user_age      <span class="token operator">|</span> user_age <span class="token operator">|</span> <span class="token number">5</span>       <span class="token operator">|</span> const <span class="token operator">|</span>    <span class="token number">1</span> <span class="token operator">|</span>   <span class="token number">100.00</span> <span class="token operator">|</span> <span class="token boolean">NULL</span>  <span class="token operator">|</span>
<span class="token operator">+</span><span class="token comment">----+-------------+-------+------------+------+---------------+----------+---------+-------+------+----------+-------+</span>
<span class="token number">1</span> <span class="token keyword">row</span> <span class="token operator">in</span> <span class="token keyword">set</span><span class="token punctuation">,</span> <span class="token number">1</span> warning <span class="token punctuation">(</span><span class="token number">0.00</span> sec<span class="token punctuation">)</span>
</code></pre> 
<p>我们看到Mysql的执行计划完全相同，依然会用到 <code>user_age</code> 这个索引。所以Mysql对待int类型字段的隐式类型转换的时候，不会导致索引失效，那么varcher类型字段的隐式类型转换会导致索引失效吗？我们继续测试。</p> 
<p>首先验证下使用正常的类型会走索引：</p> 
<pre><code class="prism language-sql">mysql<span class="token operator">&gt;</span> <span class="token keyword">explain</span> <span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> <span class="token keyword">user</span> <span class="token keyword">where</span> name <span class="token operator">=</span> <span class="token string">'1'</span><span class="token punctuation">;</span>
<span class="token operator">+</span><span class="token comment">----+-------------+-------+------------+------+---------------+-----------+---------+-------+------+----------+-------+</span>
<span class="token operator">|</span> id <span class="token operator">|</span> select_type <span class="token operator">|</span> <span class="token keyword">table</span> <span class="token operator">|</span> partitions <span class="token operator">|</span> <span class="token keyword">type</span> <span class="token operator">|</span> possible_keys <span class="token operator">|</span> <span class="token keyword">key</span>       <span class="token operator">|</span> key_len <span class="token operator">|</span> ref   <span class="token operator">|</span> <span class="token keyword">rows</span> <span class="token operator">|</span> filtered <span class="token operator">|</span> Extra <span class="token operator">|</span>
<span class="token operator">+</span><span class="token comment">----+-------------+-------+------------+------+---------------+-----------+---------+-------+------+----------+-------+</span>
<span class="token operator">|</span>  <span class="token number">1</span> <span class="token operator">|</span> <span class="token keyword">SIMPLE</span>      <span class="token operator">|</span> <span class="token keyword">user</span>  <span class="token operator">|</span> <span class="token boolean">NULL</span>       <span class="token operator">|</span> ref  <span class="token operator">|</span> user_name     <span class="token operator">|</span> user_name <span class="token operator">|</span> <span class="token number">768</span>     <span class="token operator">|</span> const <span class="token operator">|</span>    <span class="token number">1</span> <span class="token operator">|</span>   <span class="token number">100.00</span> <span class="token operator">|</span> <span class="token boolean">NULL</span>  <span class="token operator">|</span>
<span class="token operator">+</span><span class="token comment">----+-------------+-------+------------+------+---------------+-----------+---------+-------+------+----------+-------+</span>
<span class="token number">1</span> <span class="token keyword">row</span> <span class="token operator">in</span> <span class="token keyword">set</span><span class="token punctuation">,</span> <span class="token number">1</span> warning <span class="token punctuation">(</span><span class="token number">0.00</span> sec<span class="token punctuation">)</span>
</code></pre> 
<p>可以看到where条件后使用的 <code>varcher</code> 类型的 <code>name</code> 字段，并且 <code>=</code> 后面的数据类型采用的是跟 <code>name</code> 字段定义的类型一致的 <code>varcher</code> 类型，以上结果中的 <code>key</code> 字段为 <code>user_name</code> 表明走了索引。好，那我们将字符串类型的 <code>'1'</code> 改为数字类型的 <code>1</code> 看看效果呢：</p> 
<pre><code class="prism language-sql">mysql<span class="token operator">&gt;</span> <span class="token keyword">explain</span> <span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> <span class="token keyword">user</span> <span class="token keyword">where</span> name <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
<span class="token operator">+</span><span class="token comment">----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+-------------+</span>
<span class="token operator">|</span> id <span class="token operator">|</span> select_type <span class="token operator">|</span> <span class="token keyword">table</span> <span class="token operator">|</span> partitions <span class="token operator">|</span> <span class="token keyword">type</span> <span class="token operator">|</span> possible_keys <span class="token operator">|</span> <span class="token keyword">key</span>  <span class="token operator">|</span> key_len <span class="token operator">|</span> ref  <span class="token operator">|</span> <span class="token keyword">rows</span> <span class="token operator">|</span> filtered <span class="token operator">|</span> Extra       <span class="token operator">|</span>
<span class="token operator">+</span><span class="token comment">----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+-------------+</span>
<span class="token operator">|</span>  <span class="token number">1</span> <span class="token operator">|</span> <span class="token keyword">SIMPLE</span>      <span class="token operator">|</span> <span class="token keyword">user</span>  <span class="token operator">|</span> <span class="token boolean">NULL</span>       <span class="token operator">|</span> <span class="token keyword">ALL</span>  <span class="token operator">|</span> user_name     <span class="token operator">|</span> <span class="token boolean">NULL</span> <span class="token operator">|</span> <span class="token boolean">NULL</span>    <span class="token operator">|</span> <span class="token boolean">NULL</span> <span class="token operator">|</span>    <span class="token number">1</span> <span class="token operator">|</span>   <span class="token number">100.00</span> <span class="token operator">|</span> <span class="token keyword">Using</span> <span class="token keyword">where</span> <span class="token operator">|</span>
<span class="token operator">+</span><span class="token comment">----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+-------------+</span>
<span class="token number">1</span> <span class="token keyword">row</span> <span class="token operator">in</span> <span class="token keyword">set</span><span class="token punctuation">,</span> <span class="token number">3</span> <span class="token keyword">warnings</span> <span class="token punctuation">(</span><span class="token number">0.00</span> sec<span class="token punctuation">)</span>
</code></pre> 
<p>咦，我们发现 <code>type</code> 字段变为了 <code>NULL</code> ，<code>possible_keys</code> 字段的值依然是 <code>user_name</code> ，但 <code>key</code> 字段的值变为了 <code>NULL</code> ，说明Mysql还是想用索引的，但最终决定不使用索引。</p> 
<h3><a id="_66"></a>为什么会这样呢？</h3> 
<p>Mysql针对类型不一致的值进行比较的时候，会尽最大努力的执行比较，以上案例 <code>name</code> 字段是 <code>varchar</code> 类型，但语句 <code>where name = 1;</code> 中的 <code>1</code> 是数字类型，此时Mysql将 <code>name</code> 字段的值转换为浮点数进行比较，但索引中存储的都是字符串，所以需要将每一条记录值都进行转换，也就需要全表扫描了。</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/6febfbb03a8e2e6ae03f3e3494ad916c/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">【自动化办公】schedule模块定时执行任务</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/fb19f826abafa60b52881c97766a9759/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">解决：Error:svn: E155037: Previous operation has not finished； run ‘cleanup‘ if it was interrupted</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>