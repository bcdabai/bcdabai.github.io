<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>混合推荐总结 - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="混合推荐总结" />
<meta property="og:description" content=" 混合推荐系统是推荐系统的另一个研究热点，它是指将多种推荐技术进行混合相互弥补缺点，从而可以获得更好的推荐效果。 最常见的是将协同过滤技术和其他技术相结合，克服cold start的问题。 （1）加权型 就是将多种推荐技术的计算结果加权混合产生推荐。 最简单的方式是线性混合，首先将协同过滤的推荐结果和基于内容的推荐结果赋予相同的权重值，然后比较用户对项的评价与系统的预测是否相符，然后调整权重值。 加权型混合方式的特点是整个系统性能都直接与推荐过程相关，这样一来就很容易在这之后斤西瓜信任分配和调整相应的混合模型，不过这种技术有一个假设的前提是对于整个空间中所有可能的项，使用不同技术的相关参数值都基本相同。 （2）转换型 根据问题背景和实际情况采用不同的推荐技术。 比如，使用基于内容推荐和协同过滤混合的方式，系统首先使用基于内容的推荐技术，如果它不能产生高可信度的推荐，然后再尝试使用协同过滤技术。 因为需要各种情况比较转换标准，所以这种方法会增加算法的复杂度和参数化，当然这样做的好处是对各种推荐技术的优点和弱点比较敏感。 （3）合并型 同时采用多种推荐技术给出多种推荐结果，为用户提供参考。 比如，可以构建这样一个基于web日志和缓存数据挖掘的个性化推荐系统，该系统首先通过挖掘web日志和缓存数据构建用户多方面的兴趣模式，然后根据目标用户的短期访问历史与用户兴趣模式进行匹配，采用基于内容的过滤算法，向用户推荐相似网页，同时，通过对多用户间的系统过滤，为目标用户预测下一步最有可能的访问页面，并根据得分对页面进行排序，附在现行用户请求访问页面后推荐给用户。也就是“猜你喜欢可能感兴趣的网页”。 （4）特征组合 将来自不同推荐数据源的特征组合起来，由另一种推荐技术采用。 一般会将协同过滤的信息作为增加的特征向量，然后在这增加的数据集上采用基于内容的推荐技术。 特征组合的混合方式使得系统不再仅仅考虑协同过滤的数据源，所以它降低了用户对项目评分数量的敏感度，相反的，它允许系统拥有项的内部相似信息，其对协同系统是不透明的。 （5）瀑布型 后一个推荐方法优化前一个推荐方法：它是一个分阶段的过程，首先用一种推荐技术产生一个较为粗略的候选结果，在此基础上使用第二种推荐技术对其作出进一步精确地推荐。 瀑布型允许系统对某些项避免采用低优先级的技术，这些项可能是通过第一种推荐技术被较好的予以区分了的，或者是很少被用户评价从来都不会被推荐的项目。 因为瀑布型的第二步，仅仅是集中在需要另外判断的项上。另外，瀑布型在低优先级技术上具有较高的容错性，因为高优先级得出的评分会变得更加精确，而不是被完全修改。 （6）特征递增型 前一个推荐方法的输出作为后一个推荐方法的输入。 比如，你可以将聚类分析作为关联规则的预处理，首先对会话文件进行聚类，再针对每个聚类进行关联规则挖掘，得到不同聚类的关联规则。当一个访问会话获得后，首先计算该访问会话与各聚类的匹配值，确认其属于哪个聚类，再应用这个聚类对应的关联规则进行推荐。 这个类型和瀑布型的不同点在哪里呢？ 在特征递增型中，第二种推荐方法使用的特征包括了第一种的输出。 而在瀑布型中，第二种推荐方法并没有使用第一种产生的任何等级排列的输出，其两种推荐方法的结果以一种优化的方式进行混合。 （7）元层次型 用一种推荐方法产生的模型作为另一种推荐方法的输入。 这个与特征递增型的不同在于： 在特征递增型中使用一个学习模型产生某些特征作为第二种算法的输入，而在元层次型中，整个模型都会作为输入。 比如，你可以通过组合基于用户的协同过滤和基于项目的协同过滤算法，先求解目标项目的相似项目集，在目标项目的相似项目集上再采用基于用户的协同过滤算法。这种基于相似项目的邻居用户协同推荐方法，能很好地处理用户多兴趣下的个性化推荐问题，尤其是候选推荐项目的内容属性相差很大的时候，该方法性能会更好。 " />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/7caf9ed480b9c04743c09b2534991079/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2014-08-27T11:15:08+08:00" />
<meta property="article:modified_time" content="2014-08-27T11:15:08+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">混合推荐总结</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <div style="font-family:Arial; font-size:14px; line-height:26px">
  混合推荐系统是推荐系统的另一个研究热点，它是指将多种推荐技术进行混合相互弥补缺点，从而可以获得更好的推荐效果。 
</div> 
<div style="font-family:Arial; font-size:14px; line-height:26px">
  最常见的是将协同过滤技术和其他技术相结合，克服cold start的问题。 
</div> 
<div style="font-family:Arial; font-size:14px; line-height:26px"> 
 <br> 
</div> 
<div style="font-family:Arial; font-size:14px; line-height:26px">
  （1）加权型 
</div> 
<div style="font-family:Arial; font-size:14px; line-height:26px">
  就是将多种推荐技术的计算结果加权混合产生推荐。 
</div> 
<div style="font-family:Arial; font-size:14px; line-height:26px">
  最简单的方式是线性混合，首先将协同过滤的推荐结果和基于内容的推荐结果赋予相同的权重值，然后比较用户对项的评价与系统的预测是否相符，然后调整权重值。 
</div> 
<div style="font-family:Arial; font-size:14px; line-height:26px">
  加权型混合方式的特点是整个系统性能都直接与推荐过程相关，这样一来就很容易在这之后斤西瓜信任分配和调整相应的混合模型，不过这种技术有一个假设的前提是对于整个空间中所有可能的项，使用不同技术的相关参数值都基本相同。 
</div> 
<div style="font-family:Arial; font-size:14px; line-height:26px"> 
 <br> 
</div> 
<div style="font-family:Arial; font-size:14px; line-height:26px">
  （2）转换型 
</div> 
<div style="font-family:Arial; font-size:14px; line-height:26px">
  根据问题背景和实际情况采用不同的推荐技术。 
</div> 
<div style="font-family:Arial; font-size:14px; line-height:26px">
  比如，使用基于内容推荐和协同过滤混合的方式，系统首先使用基于内容的推荐技术，如果它不能产生高可信度的推荐，然后再尝试使用协同过滤技术。 
</div> 
<div style="font-family:Arial; font-size:14px; line-height:26px">
  因为需要各种情况比较转换标准，所以这种方法会增加算法的复杂度和参数化，当然这样做的好处是对各种推荐技术的优点和弱点比较敏感。 
</div> 
<div style="font-family:Arial; font-size:14px; line-height:26px"> 
 <br> 
</div> 
<div style="font-family:Arial; font-size:14px; line-height:26px">
  （3）合并型 
</div> 
<div style="font-family:Arial; font-size:14px; line-height:26px">
  同时采用多种推荐技术给出多种推荐结果，为用户提供参考。 
</div> 
<div style="font-family:Arial; font-size:14px; line-height:26px">
  比如，可以构建这样一个基于web日志和缓存数据挖掘的个性化推荐系统，该系统首先通过挖掘web日志和缓存数据构建用户多方面的兴趣模式，然后根据目标用户的短期访问历史与用户兴趣模式进行匹配，采用基于内容的过滤算法，向用户推荐相似网页，同时，通过对多用户间的系统过滤，为目标用户预测下一步最有可能的访问页面，并根据得分对页面进行排序，附在现行用户请求访问页面后推荐给用户。也就是“猜你喜欢可能感兴趣的网页”。 
</div> 
<div style="font-family:Arial; font-size:14px; line-height:26px"> 
 <br> 
</div> 
<div style="font-family:Arial; font-size:14px; line-height:26px">
  （4）特征组合 
</div> 
<div style="font-family:Arial; font-size:14px; line-height:26px">
  将来自不同推荐数据源的特征组合起来，由另一种推荐技术采用。 
</div> 
<div style="font-family:Arial; font-size:14px; line-height:26px">
  一般会将协同过滤的信息作为增加的特征向量，然后在这增加的数据集上采用基于内容的推荐技术。 
</div> 
<div style="font-family:Arial; font-size:14px; line-height:26px">
  特征组合的混合方式使得系统不再仅仅考虑协同过滤的数据源，所以它降低了用户对项目评分数量的敏感度，相反的，它允许系统拥有项的内部相似信息，其对协同系统是不透明的。 
</div> 
<div style="font-family:Arial; font-size:14px; line-height:26px"> 
 <br> 
</div> 
<div style="font-family:Arial; font-size:14px; line-height:26px">
  （5）瀑布型 
</div> 
<div style="font-family:Arial; font-size:14px; line-height:26px">
  后一个推荐方法优化前一个推荐方法：它是一个分阶段的过程，首先用一种推荐技术产生一个较为粗略的候选结果，在此基础上使用第二种推荐技术对其作出进一步精确地推荐。 
</div> 
<div style="font-family:Arial; font-size:14px; line-height:26px">
  瀑布型允许系统对某些项避免采用低优先级的技术，这些项可能是通过第一种推荐技术被较好的予以区分了的，或者是很少被用户评价从来都不会被推荐的项目。 
</div> 
<div style="font-family:Arial; font-size:14px; line-height:26px">
  因为瀑布型的第二步，仅仅是集中在需要另外判断的项上。另外，瀑布型在低优先级技术上具有较高的容错性，因为高优先级得出的评分会变得更加精确，而不是被完全修改。 
</div> 
<div style="font-family:Arial; font-size:14px; line-height:26px"> 
 <br> 
</div> 
<div style="font-family:Arial; font-size:14px; line-height:26px">
  （6）特征递增型 
</div> 
<div style="font-family:Arial; font-size:14px; line-height:26px">
  前一个推荐方法的输出作为后一个推荐方法的输入。 
</div> 
<div style="font-family:Arial; font-size:14px; line-height:26px">
  比如，你可以将聚类分析作为关联规则的预处理，首先对会话文件进行聚类，再针对每个聚类进行关联规则挖掘，得到不同聚类的关联规则。当一个访问会话获得后，首先计算该访问会话与各聚类的匹配值，确认其属于哪个聚类，再应用这个聚类对应的关联规则进行推荐。 
</div> 
<div style="font-family:Arial; font-size:14px; line-height:26px">
  这个类型和瀑布型的不同点在哪里呢？ 
</div> 
<div style="font-family:Arial; font-size:14px; line-height:26px">
  在特征递增型中，第二种推荐方法使用的特征包括了第一种的输出。 
</div> 
<div style="font-family:Arial; font-size:14px; line-height:26px">
  而在瀑布型中，第二种推荐方法并没有使用第一种产生的任何等级排列的输出，其两种推荐方法的结果以一种优化的方式进行混合。 
</div> 
<div style="font-family:Arial; font-size:14px; line-height:26px"> 
 <br> 
</div> 
<div style="font-family:Arial; font-size:14px; line-height:26px">
  （7）元层次型 
</div> 
<div style="font-family:Arial; font-size:14px; line-height:26px">
  用一种推荐方法产生的模型作为另一种推荐方法的输入。 
</div> 
<div style="font-family:Arial; font-size:14px; line-height:26px">
  这个与特征递增型的不同在于： 
</div> 
<div style="font-family:Arial; font-size:14px; line-height:26px">
  在特征递增型中使用一个学习模型产生某些特征作为第二种算法的输入，而在元层次型中，整个模型都会作为输入。 
</div> 
<div style="font-family:Arial; font-size:14px; line-height:26px">
  比如，你可以通过组合基于用户的协同过滤和基于项目的协同过滤算法，先求解目标项目的相似项目集，在目标项目的相似项目集上再采用基于用户的协同过滤算法。这种基于相似项目的邻居用户协同推荐方法，能很好地处理用户多兴趣下的个性化推荐问题，尤其是候选推荐项目的内容属性相差很大的时候，该方法性能会更好。 
</div>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/3ed8e28b172b0afb7f0fc5d24a3d453c/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">Android多线程及异步任务消息处理机制(一)--Handler的使用</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/dda4f6c27ccfad86e73b3498b1a6ed7e/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">使用ajaxSubmit方法实现多文件上传(异步)</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>