<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Vue2.0修饰符 - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Vue2.0修饰符" />
<meta property="og:description" content="一、修饰符 修饰符有五种类型：
二、表单修饰符 1.trim trim:去除数据头尾的空格
&lt;input type=&#34;text&#34; v-model.trim=&#34;value&#34;&gt; 2.lazy lazy:光标离开标签的时候，会赋值给变量，也就是在change事件之后再进行信息同步
&lt;input type=&#34;text&#34; v-model.lazy=&#34;name&#34;&gt; 3.number number：将数据转化成数字类型，当无法被parseFloat解析时返回原值（即字符串中的首个字符为数字时即可返回数字，否则返回原值）
例：
输入1323dsdhd,返回1323；输入 asdd414,返回 asdd414 &lt;input type=&#34;text&#34; v-model.number=&#34;num&#34;&gt; 三、事件修饰符 1.stop stop：阻止冒泡，相当于调用event.stopPropagation()
&lt;div @click=&#34;shout(2)&#34;&gt; &lt;button @click.stop=&#34;shout(1)&#34;&gt;按钮&lt;/button&gt; &lt;/div&gt; 此例中不加stop会执行1,2，加上stop阻止冒泡，只执行1，不会执行2
2.prevent prevent:阻止默认事件，相当于调用event.preventDefault()
&lt;a href=&#34;https://www.baidu.com&#34; @click.prevent=&#34;shout(3)&#34;&gt;百度&lt;/a&gt; 此例中点击a标签不会跳转到百度，而是执行shout(3)
3.self self:当event.target为自身元素时触发
&lt;div @click.self=&#34;shout(2)&#34;&gt; &lt;button @click=&#34;shout(1)&#34;&gt;按钮&lt;/button&gt; &lt;/div&gt; 此例中只执行shout(1),不执行shout(2)
使用修饰符时，顺序很重要；相应的代码会以同样的顺序产生。
&lt;div @click=&#34;shout(3)&#34;&gt; &lt;div @click.self.stop=&#34;shout(2)&#34;&gt; &lt;button @click=&#34;shout(1)&#34;&gt;按钮&lt;/button&gt; &lt;/div&gt; &lt;/div&gt; 此代码执行1，执行3，因为阻止了2自身的执行 &lt;div @click=&#34;shout(3)&#34;&gt; &lt;div @click.stop.self=&#34;shout(2)&#34;&gt; &lt;button @click=&#34;shout(1)&#34;&gt;按钮&lt;/button&gt; &lt;/div&gt; &lt;/div&gt; 此代码只执行1，因为阻止了全部冒泡 4.once once:绑定了事件以后只能触发一次，第二次就不会触发，但仍然有冒泡
&lt;div @click=&#34;shout(3)&#34;&gt; &lt;div @click=&#34;" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/bb03512c868e42be78e0cdcf3c0f96d3/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2020-12-29T20:59:46+08:00" />
<meta property="article:modified_time" content="2020-12-29T20:59:46+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Vue2.0修饰符</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <h3>一、修饰符</h3> 
<p>修饰符有五种类型：</p> 
<p><img alt="" height="389" src="https://images2.imgbox.com/39/96/U3UiSWPZ_o.png" width="510"></p> 
<h3>二、表单修饰符</h3> 
<h4>1.trim</h4> 
<p>trim:去除数据头尾的空格</p> 
<pre><code class="language-html">&lt;input type="text" v-model.trim="value"&gt;</code></pre> 
<h4>2.lazy</h4> 
<p>lazy:光标离开标签的时候，会赋值给变量，也就是在<code>change</code>事件之后再进行信息同步</p> 
<pre><code class="language-html">&lt;input type="text" v-model.lazy="name"&gt;</code></pre> 
<h4>3.number</h4> 
<p>number：将数据转化成数字类型，当无法被parseFloat解析时返回原值（即字符串中的首个字符为数字时即可返回数字，否则返回原值）</p> 
<p>例：</p> 
<ul><li>输入1323dsdhd,返回1323；</li><li>输入 asdd414,返回 asdd414</li></ul> 
<pre><code class="language-html">&lt;input type="text" v-model.number="num"&gt;</code></pre> 
<p> </p> 
<h3>三、事件修饰符</h3> 
<h4>1.stop</h4> 
<p>stop：阻止冒泡，相当于调用event.stopPropagation()</p> 
<pre><code class="language-html">&lt;div @click="shout(2)"&gt;
   &lt;button @click.stop="shout(1)"&gt;按钮&lt;/button&gt;
&lt;/div&gt;</code></pre> 
<p>此例中不加stop会执行1,2，加上stop阻止冒泡，只执行1，不会执行2</p> 
<p> </p> 
<h4>2.prevent</h4> 
<p>prevent:阻止默认事件，相当于调用event.preventDefault()</p> 
<pre><code class="language-html">&lt;a href="https://www.baidu.com" @click.prevent="shout(3)"&gt;百度&lt;/a&gt;</code></pre> 
<p>此例中点击a标签不会跳转到百度，而是执行shout(3)</p> 
<p> </p> 
<h4>3.self </h4> 
<p>self:当event.target为自身元素时触发</p> 
<pre><code class="language-html">&lt;div @click.self="shout(2)"&gt;
   &lt;button @click="shout(1)"&gt;按钮&lt;/button&gt;
&lt;/div&gt;</code></pre> 
<p>此例中只执行shout(1),不执行shout(2)</p> 
<p>使用修饰符时，顺序很重要；相应的代码会以同样的顺序产生。</p> 
<pre><code class="language-html">&lt;div @click="shout(3)"&gt;
  &lt;div @click.self.stop="shout(2)"&gt;
    &lt;button @click="shout(1)"&gt;按钮&lt;/button&gt;
  &lt;/div&gt;
&lt;/div&gt;
此代码执行1，执行3，因为阻止了2自身的执行

&lt;div @click="shout(3)"&gt;
  &lt;div @click.stop.self="shout(2)"&gt;
    &lt;button @click="shout(1)"&gt;按钮&lt;/button&gt;
  &lt;/div&gt;
&lt;/div&gt;
此代码只执行1，因为阻止了全部冒泡</code></pre> 
<p> </p> 
<h4>4.once</h4> 
<p>once:绑定了事件以后只能触发一次，第二次就不会触发，但仍然有冒泡</p> 
<pre><code class="language-html">&lt;div @click="shout(3)"&gt;
      &lt;div @click="shout(2)"&gt;
        &lt;button @click.once="shout(1)"&gt;按钮&lt;/button&gt;
      &lt;/div&gt;
&lt;/div&gt;</code></pre> 
<p>第一次点击按钮时，执行1,2,3；第2次及以后点击时执行2,3，不再执行1了。</p> 
<p> </p> 
<h4>5.capture</h4> 
<p>capture：使事件触发从包含这个元素的顶层开始往下触发</p> 
<pre><code class="language-html">&lt;div @click.capture="shout(3)"&gt;
      &lt;div @click="shout(2)"&gt;
        &lt;button @click="shout(1)"&gt;按钮&lt;/button&gt;
      &lt;/div&gt;
&lt;/div&gt;
点击按钮，先执行3，再执行1，再执行2

&lt;div @click.capture="shout(3)"&gt;
      &lt;div @click.capture="shout(2)"&gt;
        &lt;button @click="shout(1)"&gt;按钮&lt;/button&gt;
      &lt;/div&gt;
&lt;/div&gt;
点击按钮，先执行3，再执行2，再执行1</code></pre> 
<h4>6.passive</h4> 
<p>passive:passive 会告诉浏览器你不想阻止事件的默认行为，可以不用去查询程序有没有阻止默认事件，提早告诉，提高性能。</p> 
<pre><code class="language-html">&lt;div class="div_wrapper" @scroll.passive="shout(5)"&gt;&lt;/div&gt;</code></pre> 
<p>注意：不要把 <code>.passive</code> 和 <code>.prevent</code> 一起使用,因为<code>.prevent</code> 将会被忽略，同时浏览器可能会向你展示一个警告。<code>passive</code> 会告诉浏览器你不想阻止事件的默认行为。</p> 
<p> </p> 
<h4> 7.native</h4> 
<p>native:就是在父组件中给子组件绑定一个原生的事件，就将子组件变成了普通的HTML标签，不加 native事件是无法触发的。</p> 
<pre><code class="language-html">&lt;my-component v-on:click.native="doSomething"&gt;&lt;/my-component&gt;</code></pre> 
<p> </p> 
<h3>四、鼠标键盘按钮修饰符</h3> 
<h4>1.鼠标按钮修饰符</h4> 
<p>针对的就是左键、右键、中键点击，对应的鼠标键点击才会触发函数</p> 
<ul><li> <p>left 左键点击</p> </li><li> <p>right 右键点击</p> </li><li> <p>middle 中键点击</p> </li></ul> 
<pre><code class="language-html">&lt;button @click.left="shout(1)"&gt;ok&lt;/button&gt;
&lt;button @click.right="shout(1)"&gt;ok&lt;/button&gt;
&lt;button @click.middle="shout(1)"&gt;ok&lt;/button&gt;</code></pre> 
<h4>2.键盘按钮修饰符</h4> 
<ul><li> <p>普通键（enter、tab、delete、space、esc、up...）</p> </li><li> <p>系统修饰键（ctrl、alt、meta、shift...）</p> </li></ul> 
<pre><code class="language-javascript">// 只有按键为keyCode的时候才触发
&lt;input type="text" @keyup.keyCode="shout(1)"&gt;</code></pre> 
<p>还可以通过以下方式自定义一些全局的键盘码别名：</p> 
<pre><code>Vue.config.keyCodes.f2 = 113</code></pre> 
<p> </p> 
<h3>五、v-bind修饰符</h3> 
<h3>1.sync</h3> 
<p>作用：sync修饰符是一个语法糖，类似v-model，它主要是解决了父子组件的双向绑定问题。因为vue提倡的是单向数据流动，因此不能直接在子组件里面修改父组件传过来的数据，我们一般$emit。</p> 
<p>sync修饰符其实是做了两步动作：<br> 1、声明传的数据visible<br> 2、声明@update:visible事件</p> 
<p>注意：</p> 
<ul><li> <p>使用<code>sync</code>的时候，子组件传递的事件名格式必须为<code>update:value</code>，其中<code>value</code>必须与子组件中<code>props</code>中声明的名称完全一致</p> </li><li> <p>注意带有 <code>.sync</code> 修饰符的 <code>v-bind</code> 不能和表达式一起使用</p> </li><li> <p>将 <code>v-bind.sync</code> 用在一个字面量的对象上，例如 <code>v-bind.sync=”{ title: doc.title }”</code>，是无法正常工作的</p> </li></ul> 
<p>原始写法$emit：</p> 
<pre><code class="language-html">&lt;!-- 父组件 --&gt;
&lt;template&gt;
  &lt;div id="app"&gt;
    &lt;button @click="visible=true"&gt;显示&lt;/button&gt;
    &lt;my-alert :visible="visible" @close="closeAlert"&gt;&lt;/my-alert&gt;
  &lt;/div&gt;
&lt;/template&gt;

&lt;script&gt;
import myalert from './components/myalert'
export default {
  name: 'App',
  components:{'my-alert': myalert},
  data(){
    return {
      visible:false
    }
  },
  methods:{
    closeAlert(value){
      this.visible = value
    }
  }

}
&lt;/script&gt;


&lt;!-- 子组件 --&gt;
&lt;template&gt;
    &lt;div class="cont" v-show="visible"&gt;
        &lt;h2&gt;这是一个对话框&lt;/h2&gt;
        &lt;button @click="closeAlert"&gt;关闭&lt;/button&gt;
    &lt;/div&gt;
&lt;/template&gt;

&lt;script&gt;
    export default {
        name: "myalert",
        props:{
            visible:{
                type:Boolean,
                default:false
            }
        },
        methods:{
            closeAlert(){
                this.$emit('close',false)
            }
        }
    }
&lt;/script&gt;</code></pre> 
<p>一个数据就要带一个自定义事件才能实现双向绑定，为了避免乱起名引起的混乱，事件名我们最好约定一下规则。<br> 因为是修改visible这个数据，因此事件我们统一就叫<strong>@update:visible</strong></p> 
<pre><code class="language-html">&lt;!-- 父组件 --&gt;
&lt;template&gt;
  &lt;div id="app"&gt;
    &lt;button @click="visible=true"&gt;点击&lt;/button&gt;
    &lt;my-alert :visible="visible" @update:visible="value =&gt; visible=value"&gt;&lt;/my-alert&gt;
  &lt;/div&gt;
&lt;/template&gt;

&lt;script&gt;
import myalert from './components/myalert'
export default {
  name: 'App',
  components:{'my-alert': myalert},
  data(){
    return {
      visible:false
    }
  }

}
&lt;/script&gt;

&lt;!-- 子组件 --&gt;
&lt;template&gt;
    &lt;div class="cont" v-show="visible"&gt;
        &lt;h2&gt;这是一个对话框&lt;/h2&gt;
        &lt;button @click="closeAlert"&gt;关闭&lt;/button&gt;
    &lt;/div&gt;
&lt;/template&gt;

&lt;script&gt;
    export default {
        name: "myalert",
        props:{
            visible:{
                type:Boolean,
                default:false
            }
        },
        methods:{
            closeAlert(){
                this.$emit('update:visible',false)
            }
        }
    }
&lt;/script&gt;</code></pre> 
<p>这么写还是太麻烦了，但有了统一的规则，系统就可以帮我们自动生成不必要的代码，这就是sync修饰符的作用，它让写法更为简洁：</p> 
<pre><code class="language-html">&lt;!-- 父组件 --&gt;
&lt;template&gt;
  &lt;div id="app"&gt;
    &lt;button @click="visible=true"&gt;点击&lt;/button&gt;
    &lt;my-alert :visible.sync="visible"&gt;&lt;/my-alert&gt;
  &lt;/div&gt;
&lt;/template&gt;

&lt;script&gt;
import myalert from './components/myalert'
export default {
  name: 'App',
  components:{'my-alert': myalert},
  data(){
    return {
      visible:false
    }
  },

}
&lt;/script&gt;


&lt;!-- 子组件 --&gt;
&lt;template&gt;
    &lt;div class="cont" v-show="visible"&gt;
        &lt;h2&gt;这是一个对话框&lt;/h2&gt;
        &lt;button @click="closeAlert"&gt;关闭&lt;/button&gt;
    &lt;/div&gt;
&lt;/template&gt;

&lt;script&gt;
    export default {
        name: "myalert",
        props:{
            visible:{
                type:Boolean,
                default:false
            }
        },
        methods:{
            closeAlert(){
                this.$emit('update:visible',false)
            }
        }
    }
&lt;/script&gt;</code></pre> 
<p> </p> 
<h4>2.prop</h4> 
<p>prop:设置自定义标签属性，编译后不会出现在html中，避免暴露数据，防止污染HTML结构</p> 
<pre><code class="language-html">&lt;input id="input" type="foo" value="11" :data="inputData"&gt;&lt;/input&gt;
// 标签结构: &lt;input id="input" type="foo" value="11" data="inputData 的值"&gt;&lt;/input&gt;
// input.data === undefined
// input.attributes.data === this.inputData
 
&lt;input id="input" type="foo" value="11" :data.prop="inputData"&gt;&lt;/input&gt;
// 标签结构: &lt;input id="input" type="foo" value="11"&gt;&lt;/input&gt;
// input.data === this.inputData
// input.attributes.data === undefined</code></pre> 
<h4> </h4> 
<h4>3.camel</h4> 
<p>camel:将命名变为驼峰命名法，只有props和.prop会默认将kebab-case转化为camelCase，剩下的作为attribute的不会。而.camel修饰符正是针对attribute的。如将<code>view-Box</code>属性名转换为 <code>viewBox。</code></p> 
<pre><code class="language-html">data() {
    return {
        msgText: 'aaa'
    }
}

&lt;h2 :msg-text="msgText"&gt;原本&lt;/h2&gt;
&lt;!-- 编译后为&lt;h2 msg-text="aaa"&gt;原本&lt;/h2&gt; --&gt;

&lt;h2 :msg-text.camel="msgText"&gt;加camel修饰符&lt;/h2&gt;
&lt;!-- 编译后为&lt;h2 msgtext="aaa"&gt;加camel修饰符&lt;/h2&gt;,由于camel将msg-text转化为msgText,html中不区分大小写，所以会将大写都转化为小写，则最终结果为msgtext --&gt;</code></pre> 
<p> </p> 
<p> </p> 
<p> </p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/1d28271eac67c35c41d564d664e79864/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">PyTorch 笔记Ⅸ——数据增强</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/4bf3982ed274e289f6c1eadc83d7741a/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">三维家导入户型镜像怎么使用_三维家设计中如何镜像？</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>