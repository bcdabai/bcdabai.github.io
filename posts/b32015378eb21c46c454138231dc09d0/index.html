<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>python2内置属性 - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="python2内置属性" />
<meta property="og:description" content="1 # encoding: utf-8 2 # module __builtin__ 3 # from (built-in) 4 # by generator 1.145 5 from __future__ import print_function 6 &#34;&#34;&#34; 7 Built-in functions, exceptions, and other objects. 8 9 Noteworthy: None is the `nil&#39; object; Ellipsis represents `...&#39; in slices. 10 &#34;&#34;&#34; 11 12 # imports 13 from exceptions import (ArithmeticError, AssertionError, AttributeError, 14 BaseException, BufferError, BytesWarning, DeprecationWarning, EOFError, 15 EnvironmentError, Exception, FloatingPointError, FutureWarning, 16 GeneratorExit, IOError, ImportError, ImportWarning, IndentationError, 17 IndexError, KeyError, KeyboardInterrupt, LookupError, MemoryError, 18 NameError, NotImplementedError, OSError, OverflowError, 19 PendingDeprecationWarning, ReferenceError, RuntimeError, RuntimeWarning, 20 StandardError, StopIteration, SyntaxError, SyntaxWarning, SystemError, 21 SystemExit, TabError, TypeError, UnboundLocalError, UnicodeDecodeError, 22 UnicodeEncodeError, UnicodeError, UnicodeTranslateError, UnicodeWarning, 23 UserWarning, ValueError, Warning, ZeroDivisionError) 24 25 26 # Variables with simple values 27 28 False = False 29 30 None = object() # real value of type &lt;type &#39;NoneType&#39;&gt; replaced 31 32 True = True 33 34 __debug__ = True 35 36 # functions 37 38 def abs(number): # real signature unknown; restored from __doc__ 39 &#34;" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/b32015378eb21c46c454138231dc09d0/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2017-11-04T00:17:00+08:00" />
<meta property="article:modified_time" content="2017-11-04T00:17:00+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">python2内置属性</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <div id="cnblogs_post_body" class="blogpost-body blogpost-body-html" style="font-size: 16px;"> 
 <div class="cnblogs_code"> 
  <pre><code class="has">   1 # encoding: utf-8
   2 # module __builtin__
   3 # from (built-in)
   4 # by generator 1.145
   5 from __future__ import print_function
   6 """
   7 Built-in functions, exceptions, and other objects.
   8 
   9 Noteworthy: None is the `nil' object; Ellipsis represents `...' in slices.
  10 """
  11 
  12 # imports
  13 from exceptions import (ArithmeticError, AssertionError, AttributeError, 
  14     BaseException, BufferError, BytesWarning, DeprecationWarning, EOFError, 
  15     EnvironmentError, Exception, FloatingPointError, FutureWarning, 
  16     GeneratorExit, IOError, ImportError, ImportWarning, IndentationError, 
  17     IndexError, KeyError, KeyboardInterrupt, LookupError, MemoryError, 
  18     NameError, NotImplementedError, OSError, OverflowError, 
  19     PendingDeprecationWarning, ReferenceError, RuntimeError, RuntimeWarning, 
  20     StandardError, StopIteration, SyntaxError, SyntaxWarning, SystemError, 
  21     SystemExit, TabError, TypeError, UnboundLocalError, UnicodeDecodeError, 
  22     UnicodeEncodeError, UnicodeError, UnicodeTranslateError, UnicodeWarning, 
  23     UserWarning, ValueError, Warning, ZeroDivisionError)
  24 
  25 
  26 # Variables with simple values
  27 
  28 False = False
  29 
  30 None = object() # real value of type &lt;type 'NoneType'&gt; replaced
  31 
  32 True = True
  33 
  34 __debug__ = True
  35 
  36 # functions
  37 
  38 def abs(number): # real signature unknown; restored from __doc__
  39     """
  40     abs(number) -&gt; number
  41     
  42     Return the absolute value of the argument.
  43     """
  44     return 0
  45 
  46 def all(iterable): # real signature unknown; restored from __doc__
  47     """
  48     all(iterable) -&gt; bool
  49     
  50     Return True if bool(x) is True for all values x in the iterable.
  51     If the iterable is empty, return True.
  52     """
  53     return False
  54 
  55 def any(iterable): # real signature unknown; restored from __doc__
  56     """
  57     any(iterable) -&gt; bool
  58     
  59     Return True if bool(x) is True for any x in the iterable.
  60     If the iterable is empty, return False.
  61     """
  62     return False
  63 
  64 def apply(p_object, args=None, kwargs=None): # real signature unknown; restored from __doc__
  65     """
  66     apply(object[, args[, kwargs]]) -&gt; value
  67     
  68     Call a callable object with positional arguments taken from the tuple args,
  69     and keyword arguments taken from the optional dictionary kwargs.
  70     Note that classes are callable, as are instances with a __call__() method.
  71     
  72     Deprecated since release 2.3. Instead, use the extended call syntax:
  73         function(*args, **keywords).
  74     """
  75     pass
  76 
  77 def bin(number): # real signature unknown; restored from __doc__
  78     """
  79     bin(number) -&gt; string
  80     
  81     Return the binary representation of an integer or long integer.
  82     """
  83     return ""
  84 
  85 def callable(p_object): # real signature unknown; restored from __doc__
  86     """
  87     callable(object) -&gt; bool
  88     
  89     Return whether the object is callable (i.e., some kind of function).
  90     Note that classes are callable, as are instances with a __call__() method.
  91     """
  92     return False
  93 
  94 def chr(i): # real signature unknown; restored from __doc__
  95     """
  96     chr(i) -&gt; character
  97     
  98     Return a string of one character with ordinal i; 0 &lt;= i &lt; 256.
  99     """
 100     return ""
 101 
 102 def cmp(x, y): # real signature unknown; restored from __doc__
 103     """
 104     cmp(x, y) -&gt; integer
 105     
 106     Return negative if x&lt;y, zero if x==y, positive if x&gt;y.
 107     """
 108     return 0
 109 
 110 def coerce(x, y): # real signature unknown; restored from __doc__
 111     """
 112     coerce(x, y) -&gt; (x1, y1)
 113     
 114     Return a tuple consisting of the two numeric arguments converted to
 115     a common type, using the same rules as used by arithmetic operations.
 116     If coercion is not possible, raise TypeError.
 117     """
 118     pass
 119 
 120 def compile(source, filename, mode, flags=None, dont_inherit=None): # real signature unknown; restored from __doc__
 121     """
 122     compile(source, filename, mode[, flags[, dont_inherit]]) -&gt; code object
 123     
 124     Compile the source string (a Python module, statement or expression)
 125     into a code object that can be executed by the exec statement or eval().
 126     The filename will be used for run-time error messages.
 127     The mode must be 'exec' to compile a module, 'single' to compile a
 128     single (interactive) statement, or 'eval' to compile an expression.
 129     The flags argument, if present, controls which future statements influence
 130     the compilation of the code.
 131     The dont_inherit argument, if non-zero, stops the compilation inheriting
 132     the effects of any future statements in effect in the code calling
 133     compile; if absent or zero these statements do influence the compilation,
 134     in addition to any features explicitly specified.
 135     """
 136     pass
 137 
 138 def copyright(*args, **kwargs): # real signature unknown
 139     """
 140     interactive prompt objects for printing the license text, a list of
 141         contributors and the copyright notice.
 142     """
 143     pass
 144 
 145 def credits(*args, **kwargs): # real signature unknown
 146     """
 147     interactive prompt objects for printing the license text, a list of
 148         contributors and the copyright notice.
 149     """
 150     pass
 151 
 152 def delattr(p_object, name): # real signature unknown; restored from __doc__
 153     """
 154     delattr(object, name)
 155     
 156     Delete a named attribute on an object; delattr(x, 'y') is equivalent to
 157     ``del x.y''.
 158     """
 159     pass
 160 
 161 def dir(p_object=None): # real signature unknown; restored from __doc__
 162     """
 163     dir([object]) -&gt; list of strings
 164     
 165     If called without an argument, return the names in the current scope.
 166     Else, return an alphabetized list of names comprising (some of) the attributes
 167     of the given object, and of attributes reachable from it.
 168     If the object supplies a method named __dir__, it will be used; otherwise
 169     the default dir() logic is used and returns:
 170       for a module object: the module's attributes.
 171       for a class object:  its attributes, and recursively the attributes
 172         of its bases.
 173       for any other object: its attributes, its class's attributes, and
 174         recursively the attributes of its class's base classes.
 175     """
 176     return []
 177 
 178 def divmod(x, y): # known case of __builtin__.divmod
 179     """
 180     divmod(x, y) -&gt; (quotient, remainder)
 181     
 182     Return the tuple (x//y, x%y).  Invariant: div*y + mod == x.
 183     """
 184     return (0, 0)
 185 
 186 def eval(source, globals=None, locals=None): # real signature unknown; restored from __doc__
 187     """
 188     eval(source[, globals[, locals]]) -&gt; value
 189     
 190     Evaluate the source in the context of globals and locals.
 191     The source may be a string representing a Python expression
 192     or a code object as returned by compile().
 193     The globals must be a dictionary and locals can be any mapping,
 194     defaulting to the current globals and locals.
 195     If only globals is given, locals defaults to it.
 196     """
 197     pass
 198 
 199 def execfile(filename, globals=None, locals=None): # real signature unknown; restored from __doc__
 200     """
 201     execfile(filename[, globals[, locals]])
 202     
 203     Read and execute a Python script from a file.
 204     The globals and locals are dictionaries, defaulting to the current
 205     globals and locals.  If only globals is given, locals defaults to it.
 206     """
 207     pass
 208 
 209 def exit(*args, **kwargs): # real signature unknown
 210     pass
 211 
 212 def filter(function_or_none, sequence): # known special case of filter
 213     """
 214     filter(function or None, sequence) -&gt; list, tuple, or string
 215     
 216     Return those items of sequence for which function(item) is true.  If
 217     function is None, return the items that are true.  If sequence is a tuple
 218     or string, return the same type, else return a list.
 219     """
 220     pass
 221 
 222 def format(value, format_spec=None): # real signature unknown; restored from __doc__
 223     """
 224     format(value[, format_spec]) -&gt; string
 225     
 226     Returns value.__format__(format_spec)
 227     format_spec defaults to ""
 228     """
 229     return ""
 230 
 231 def getattr(object, name, default=None): # known special case of getattr
 232     """
 233     getattr(object, name[, default]) -&gt; value
 234     
 235     Get a named attribute from an object; getattr(x, 'y') is equivalent to x.y.
 236     When a default argument is given, it is returned when the attribute doesn't
 237     exist; without it, an exception is raised in that case.
 238     """
 239     pass
 240 
 241 def globals(): # real signature unknown; restored from __doc__
 242     """
 243     globals() -&gt; dictionary
 244     
 245     Return the dictionary containing the current scope's global variables.
 246     """
 247     return {}
 248 
 249 def hasattr(p_object, name): # real signature unknown; restored from __doc__
 250     """
 251     hasattr(object, name) -&gt; bool
 252     
 253     Return whether the object has an attribute with the given name.
 254     (This is done by calling getattr(object, name) and catching exceptions.)
 255     """
 256     return False
 257 
 258 def hash(p_object): # real signature unknown; restored from __doc__
 259     """
 260     hash(object) -&gt; integer
 261     
 262     Return a hash value for the object.  Two objects with the same value have
 263     the same hash value.  The reverse is not necessarily true, but likely.
 264     """
 265     return 0
 266 
 267 def help(with_a_twist): # real signature unknown; restored from __doc__
 268     """
 269     Define the builtin 'help'.
 270         This is a wrapper around pydoc.help (with a twist).
 271     """
 272     pass
 273 
 274 def hex(number): # real signature unknown; restored from __doc__
 275     """
 276     hex(number) -&gt; string
 277     
 278     Return the hexadecimal representation of an integer or long integer.
 279     """
 280     return ""
 281 
 282 def id(p_object): # real signature unknown; restored from __doc__
 283     """
 284     id(object) -&gt; integer
 285     
 286     Return the identity of an object.  This is guaranteed to be unique among
 287     simultaneously existing objects.  (Hint: it's the object's memory address.)
 288     """
 289     return 0
 290 
 291 def input(prompt=None): # real signature unknown; restored from __doc__
 292     """
 293     input([prompt]) -&gt; value
 294     
 295     Equivalent to eval(raw_input(prompt)).
 296     """
 297     pass
 298 
 299 def intern(string): # real signature unknown; restored from __doc__
 300     """
 301     intern(string) -&gt; string
 302     
 303     ``Intern'' the given string.  This enters the string in the (global)
 304     table of interned strings whose purpose is to speed up dictionary lookups.
 305     Return the string itself or the previously interned string object with the
 306     same value.
 307     """
 308     return ""
 309 
 310 def isinstance(p_object, class_or_type_or_tuple): # real signature unknown; restored from __doc__
 311     """
 312     isinstance(object, class-or-type-or-tuple) -&gt; bool
 313     
 314     Return whether an object is an instance of a class or of a subclass thereof.
 315     With a type as second argument, return whether that is the object's type.
 316     The form using a tuple, isinstance(x, (A, B, ...)), is a shortcut for
 317     isinstance(x, A) or isinstance(x, B) or ... (etc.).
 318     """
 319     return False
 320 
 321 def issubclass(C, B): # real signature unknown; restored from __doc__
 322     """
 323     issubclass(C, B) -&gt; bool
 324     
 325     Return whether class C is a subclass (i.e., a derived class) of class B.
 326     When using a tuple as the second argument issubclass(X, (A, B, ...)),
 327     is a shortcut for issubclass(X, A) or issubclass(X, B) or ... (etc.).
 328     """
 329     return False
 330 
 331 def iter(source, sentinel=None): # known special case of iter
 332     """
 333     iter(collection) -&gt; iterator
 334     iter(callable, sentinel) -&gt; iterator
 335     
 336     Get an iterator from an object.  In the first form, the argument must
 337     supply its own iterator, or be a sequence.
 338     In the second form, the callable is called until it returns the sentinel.
 339     """
 340     pass
 341 
 342 def len(p_object): # real signature unknown; restored from __doc__
 343     """
 344     len(object) -&gt; integer
 345     
 346     Return the number of items of a sequence or collection.
 347     """
 348     return 0
 349 
 350 def license(*args, **kwargs): # real signature unknown
 351     """
 352     interactive prompt objects for printing the license text, a list of
 353         contributors and the copyright notice.
 354     """
 355     pass
 356 
 357 def locals(): # real signature unknown; restored from __doc__
 358     """
 359     locals() -&gt; dictionary
 360     
 361     Update and return a dictionary containing the current scope's local variables.
 362     """
 363     return {}
 364 
 365 def map(function, sequence, *sequence_1): # real signature unknown; restored from __doc__
 366     """
 367     map(function, sequence[, sequence, ...]) -&gt; list
 368     
 369     Return a list of the results of applying the function to the items of
 370     the argument sequence(s).  If more than one sequence is given, the
 371     function is called with an argument list consisting of the corresponding
 372     item of each sequence, substituting None for missing values when not all
 373     sequences have the same length.  If the function is None, return a list of
 374     the items of the sequence (or a list of tuples if more than one sequence).
 375     """
 376     return []
 377 
 378 def max(*args, **kwargs): # known special case of max
 379     """
 380     max(iterable[, key=func]) -&gt; value
 381     max(a, b, c, ...[, key=func]) -&gt; value
 382     
 383     With a single iterable argument, return its largest item.
 384     With two or more arguments, return the largest argument.
 385     """
 386     pass
 387 
 388 def min(*args, **kwargs): # known special case of min
 389     """
 390     min(iterable[, key=func]) -&gt; value
 391     min(a, b, c, ...[, key=func]) -&gt; value
 392     
 393     With a single iterable argument, return its smallest item.
 394     With two or more arguments, return the smallest argument.
 395     """
 396     pass
 397 
 398 def next(iterator, default=None): # real signature unknown; restored from __doc__
 399     """
 400     next(iterator[, default])
 401     
 402     Return the next item from the iterator. If default is given and the iterator
 403     is exhausted, it is returned instead of raising StopIteration.
 404     """
 405     pass
 406 
 407 def oct(number): # real signature unknown; restored from __doc__
 408     """
 409     oct(number) -&gt; string
 410     
 411     Return the octal representation of an integer or long integer.
 412     """
 413     return ""
 414 
 415 def open(name, mode=None, buffering=None): # real signature unknown; restored from __doc__
 416     """
 417     open(name[, mode[, buffering]]) -&gt; file object
 418     
 419     Open a file using the file() type, returns a file object.  This is the
 420     preferred way to open a file.  See file.__doc__ for further information.
 421     """
 422     return file('/dev/null')
 423 
 424 def ord(c): # real signature unknown; restored from __doc__
 425     """
 426     ord(c) -&gt; integer
 427     
 428     Return the integer ordinal of a one-character string.
 429     """
 430     return 0
 431 
 432 def pow(x, y, z=None): # real signature unknown; restored from __doc__
 433     """
 434     pow(x, y[, z]) -&gt; number
 435     
 436     With two arguments, equivalent to x**y.  With three arguments,
 437     equivalent to (x**y) % z, but may be more efficient (e.g. for longs).
 438     """
 439     return 0
 440 
 441 def print(*args, **kwargs): # known special case of print
 442     """
 443     print(value, ..., sep=' ', end='\n', file=sys.stdout)
 444     
 445     Prints the values to a stream, or to sys.stdout by default.
 446     Optional keyword arguments:
 447     file: a file-like object (stream); defaults to the current sys.stdout.
 448     sep:  string inserted between values, default a space.
 449     end:  string appended after the last value, default a newline.
 450     """
 451     pass
 452 
 453 def quit(*args, **kwargs): # real signature unknown
 454     pass
 455 
 456 def range(start=None, stop=None, step=None): # known special case of range
 457     """
 458     range(stop) -&gt; list of integers
 459     range(start, stop[, step]) -&gt; list of integers
 460     
 461     Return a list containing an arithmetic progression of integers.
 462     range(i, j) returns [i, i+1, i+2, ..., j-1]; start (!) defaults to 0.
 463     When step is given, it specifies the increment (or decrement).
 464     For example, range(4) returns [0, 1, 2, 3].  The end point is omitted!
 465     These are exactly the valid indices for a list of 4 elements.
 466     """
 467     pass
 468 
 469 def raw_input(prompt=None): # real signature unknown; restored from __doc__
 470     """
 471     raw_input([prompt]) -&gt; string
 472     
 473     Read a string from standard input.  The trailing newline is stripped.
 474     If the user hits EOF (Unix: Ctl-D, Windows: Ctl-Z+Return), raise EOFError.
 475     On Unix, GNU readline is used if enabled.  The prompt string, if given,
 476     is printed without a trailing newline before reading.
 477     """
 478     return ""
 479 
 480 def reduce(function, sequence, initial=None): # real signature unknown; restored from __doc__
 481     """
 482     reduce(function, sequence[, initial]) -&gt; value
 483     
 484     Apply a function of two arguments cumulatively to the items of a sequence,
 485     from left to right, so as to reduce the sequence to a single value.
 486     For example, reduce(lambda x, y: x+y, [1, 2, 3, 4, 5]) calculates
 487     ((((1+2)+3)+4)+5).  If initial is present, it is placed before the items
 488     of the sequence in the calculation, and serves as a default when the
 489     sequence is empty.
 490     """
 491     pass
 492 
 493 def reload(module): # real signature unknown; restored from __doc__
 494     """
 495     reload(module) -&gt; module
 496     
 497     Reload the module.  The module must have been successfully imported before.
 498     """
 499     pass
 500 
 501 def repr(p_object): # real signature unknown; restored from __doc__
 502     """
 503     repr(object) -&gt; string
 504     
 505     Return the canonical string representation of the object.
 506     For most object types, eval(repr(object)) == object.
 507     """
 508     return ""
 509 
 510 def round(number, ndigits=None): # real signature unknown; restored from __doc__
 511     """
 512     round(number[, ndigits]) -&gt; floating point number
 513     
 514     Round a number to a given precision in decimal digits (default 0 digits).
 515     This always returns a floating point number.  Precision may be negative.
 516     """
 517     return 0.0
 518 
 519 def setattr(p_object, name, value): # real signature unknown; restored from __doc__
 520     """
 521     setattr(object, name, value)
 522     
 523     Set a named attribute on an object; setattr(x, 'y', v) is equivalent to
 524     ``x.y = v''.
 525     """
 526     pass
 527 
 528 def sorted(iterable, cmp=None, key=None, reverse=False): # real signature unknown; restored from __doc__
 529     """ sorted(iterable, cmp=None, key=None, reverse=False) --&gt; new sorted list """
 530     pass
 531 
 532 def sum(iterable, start=None): # real signature unknown; restored from __doc__
 533     """
 534     sum(iterable[, start]) -&gt; value
 535     
 536     Return the sum of an iterable or sequence of numbers (NOT strings)
 537     plus the value of 'start' (which defaults to 0).  When the sequence is
 538     empty, return start.
 539     """
 540     pass
 541 
 542 def unichr(i): # real signature unknown; restored from __doc__
 543     """
 544     unichr(i) -&gt; Unicode character
 545     
 546     Return a Unicode string of one character with ordinal i; 0 &lt;= i &lt;= 0x10ffff.
 547     """
 548     return u""
 549 
 550 def vars(p_object=None): # real signature unknown; restored from __doc__
 551     """
 552     vars([object]) -&gt; dictionary
 553     
 554     Without arguments, equivalent to locals().
 555     With an argument, equivalent to object.__dict__.
 556     """
 557     return {}
 558 
 559 def zip(seq1, seq2, *more_seqs): # known special case of zip
 560     """
 561     zip(seq1 [, seq2 [...]]) -&gt; [(seq1[0], seq2[0] ...), (...)]
 562     
 563     Return a list of tuples, where each tuple contains the i-th element
 564     from each of the argument sequences.  The returned list is truncated
 565     in length to the length of the shortest argument sequence.
 566     """
 567     pass
 568 
 569 def __import__(name, globals={}, locals={}, fromlist=[], level=-1): # real signature unknown; restored from __doc__
 570     """
 571     __import__(name, globals={}, locals={}, fromlist=[], level=-1) -&gt; module
 572     
 573     Import a module. Because this function is meant for use by the Python
 574     interpreter and not for general use it is better to use
 575     importlib.import_module() to programmatically import a module.
 576     
 577     The globals argument is only used to determine the context;
 578     they are not modified.  The locals argument is unused.  The fromlist
 579     should be a list of names to emulate ``from name import ...'', or an
 580     empty list to emulate ``import name''.
 581     When importing a module from a package, note that __import__('A.B', ...)
 582     returns package A when fromlist is empty, but its submodule B when
 583     fromlist is not empty.  Level is used to determine whether to perform 
 584     absolute or relative imports.  -1 is the original strategy of attempting
 585     both absolute and relative imports, 0 is absolute, a positive number
 586     is the number of parent directories to search relative to the current module.
 587     """
 588     pass
 589 
 590 # classes
 591 
 592 class ___Classobj:
 593     '''A mock class representing the old style class base.'''
 594     __module__ = ''
 595     __class__ = None
 596 
 597     def __init__(self):
 598         pass
 599     __dict__ = {}
 600     __doc__ = ''
 601 
 602 
 603 class __generator(object):
 604     '''A mock class representing the generator function type.'''
 605     def __init__(self):
 606         self.gi_code = None
 607         self.gi_frame = None
 608         self.gi_running = 0
 609 
 610     def __iter__(self):
 611         '''Defined to support iteration over container.'''
 612         pass
 613 
 614     def next(self):
 615         '''Return the next item from the container.'''
 616         pass
 617 
 618     def close(self):
 619         '''Raises new GeneratorExit exception inside the generator to terminate the iteration.'''
 620         pass
 621 
 622     def send(self, value):
 623         '''Resumes the generator and "sends" a value that becomes the result of the current yield-expression.'''
 624         pass
 625 
 626     def throw(self, type, value=None, traceback=None):
 627         '''Used to raise an exception inside the generator.'''
 628         pass
 629 
 630 
 631 class __asyncgenerator(object):
 632     '''A mock class representing the async generator function type.'''
 633     def __init__(self):
 634         '''Create an async generator object.'''
 635         self.__name__ = ''
 636         self.__qualname__ = ''
 637         self.ag_await = None
 638         self.ag_frame = None
 639         self.ag_running = False
 640         self.ag_code = None
 641 
 642     def __aiter__(self):
 643         '''Defined to support iteration over container.'''
 644         pass
 645 
 646     def __anext__(self):
 647         '''Returns an awaitable, that performs one asynchronous generator iteration when awaited.'''
 648         pass
 649 
 650     def aclose(self):
 651         '''Returns an awaitable, that throws a GeneratorExit exception into generator.'''
 652         pass
 653 
 654     def asend(self, value):
 655         '''Returns an awaitable, that pushes the value object in generator.'''
 656         pass
 657 
 658     def athrow(self, type, value=None, traceback=None):
 659         '''Returns an awaitable, that throws an exception into generator.'''
 660         pass
 661 
 662 
 663 class __function(object):
 664     '''A mock class representing function type.'''
 665 
 666     def __init__(self):
 667         self.__name__ = ''
 668         self.__doc__ = ''
 669         self.__dict__ = ''
 670         self.__module__ = ''
 671 
 672         self.func_defaults = {}
 673         self.func_globals = {}
 674         self.func_closure = None
 675         self.func_code = None
 676         self.func_name = ''
 677         self.func_doc = ''
 678         self.func_dict = ''
 679 
 680         self.__defaults__ = {}
 681         self.__globals__ = {}
 682         self.__closure__ = None
 683         self.__code__ = None
 684         self.__name__ = ''
 685 
 686 
 687 class __method(object):
 688     '''A mock class representing method type.'''
 689 
 690     def __init__(self):
 691 
 692         self.im_class = None
 693         self.im_self = None
 694         self.im_func = None
 695 
 696         self.__func__ = None
 697         self.__self__ = None
 698 
 699 
 700 
 701 class __namedtuple(tuple):
 702     '''A mock base class for named tuples.'''
 703 
 704     __slots__ = ()
 705     _fields = ()
 706 
 707     def __new__(cls, *args, **kwargs):
 708         'Create a new instance of the named tuple.'
 709         return tuple.__new__(cls, *args)
 710 
 711     @classmethod
 712     def _make(cls, iterable, new=tuple.__new__, len=len):
 713         'Make a new named tuple object from a sequence or iterable.'
 714         return new(cls, iterable)
 715 
 716     def __repr__(self):
 717         return ''
 718 
 719     def _asdict(self):
 720         'Return a new dict which maps field types to their values.'
 721         return {}
 722 
 723     def _replace(self, **kwargs):
 724         'Return a new named tuple object replacing specified fields with new values.'
 725         return self
 726 
 727     def __getnewargs__(self):
 728         return tuple(self)
 729 
 730 class object:
 731     """ The most base type """
 732     def __delattr__(self, name): # real signature unknown; restored from __doc__
 733         """ x.__delattr__('name') &lt;==&gt; del x.name """
 734         pass
 735 
 736     def __format__(self, *args, **kwargs): # real signature unknown
 737         """ default object formatter """
 738         pass
 739 
 740     def __getattribute__(self, name): # real signature unknown; restored from __doc__
 741         """ x.__getattribute__('name') &lt;==&gt; x.name """
 742         pass
 743 
 744     def __hash__(self): # real signature unknown; restored from __doc__
 745         """ x.__hash__() &lt;==&gt; hash(x) """
 746         pass
 747 
 748     def __init__(self): # known special case of object.__init__
 749         """ x.__init__(...) initializes x; see help(type(x)) for signature """
 750         pass
 751 
 752     @staticmethod # known case of __new__
 753     def __new__(cls, *more): # known special case of object.__new__
 754         """ T.__new__(S, ...) -&gt; a new object with type S, a subtype of T """
 755         pass
 756 
 757     def __reduce_ex__(self, *args, **kwargs): # real signature unknown
 758         """ helper for pickle """
 759         pass
 760 
 761     def __reduce__(self, *args, **kwargs): # real signature unknown
 762         """ helper for pickle """
 763         pass
 764 
 765     def __repr__(self): # real signature unknown; restored from __doc__
 766         """ x.__repr__() &lt;==&gt; repr(x) """
 767         pass
 768 
 769     def __setattr__(self, name, value): # real signature unknown; restored from __doc__
 770         """ x.__setattr__('name', value) &lt;==&gt; x.name = value """
 771         pass
 772 
 773     def __sizeof__(self): # real signature unknown; restored from __doc__
 774         """
 775         __sizeof__() -&gt; int
 776         size of object in memory, in bytes
 777         """
 778         return 0
 779 
 780     def __str__(self): # real signature unknown; restored from __doc__
 781         """ x.__str__() &lt;==&gt; str(x) """
 782         pass
 783 
 784     @classmethod # known case
 785     def __subclasshook__(cls, subclass): # known special case of object.__subclasshook__
 786         """
 787         Abstract classes can override this to customize issubclass().
 788         
 789         This is invoked early on by abc.ABCMeta.__subclasscheck__().
 790         It should return True, False or NotImplemented.  If it returns
 791         NotImplemented, the normal algorithm is used.  Otherwise, it
 792         overrides the normal algorithm (and the outcome is cached).
 793         """
 794         pass
 795 
 796     __class__ = None # (!) forward: type, real value is ''
 797     __dict__ = {}
 798     __doc__ = ''
 799     __module__ = ''
 800 
 801 
 802 class basestring(object):
 803     """ Type basestring cannot be instantiated; it is the base for str and unicode. """
 804     def __init__(self, *args, **kwargs): # real signature unknown
 805         pass
 806 
 807     @staticmethod # known case of __new__
 808     def __new__(S, *more): # real signature unknown; restored from __doc__
 809         """ T.__new__(S, ...) -&gt; a new object with type S, a subtype of T """
 810         pass
 811 
 812 
 813 class int(object):
 814     """
 815     int(x=0) -&gt; int or long
 816     int(x, base=10) -&gt; int or long
 817     
 818     Convert a number or string to an integer, or return 0 if no arguments
 819     are given.  If x is floating point, the conversion truncates towards zero.
 820     If x is outside the integer range, the function returns a long instead.
 821     
 822     If x is not a number or if base is given, then x must be a string or
 823     Unicode object representing an integer literal in the given base.  The
 824     literal can be preceded by '+' or '-' and be surrounded by whitespace.
 825     The base defaults to 10.  Valid bases are 0 and 2-36.  Base 0 means to
 826     interpret the base from the string as an integer literal.
 827     &gt;&gt;&gt; int('0b100', base=0)
 828     4
 829     """
 830     def bit_length(self): # real signature unknown; restored from __doc__
 831         """
 832         int.bit_length() -&gt; int
 833         
 834         Number of bits necessary to represent self in binary.
 835         &gt;&gt;&gt; bin(37)
 836         '0b100101'
 837         &gt;&gt;&gt; (37).bit_length()
 838         6
 839         """
 840         return 0
 841 
 842     def conjugate(self, *args, **kwargs): # real signature unknown
 843         """ Returns self, the complex conjugate of any int. """
 844         pass
 845 
 846     def __abs__(self): # real signature unknown; restored from __doc__
 847         """ x.__abs__() &lt;==&gt; abs(x) """
 848         pass
 849 
 850     def __add__(self, y): # real signature unknown; restored from __doc__
 851         """ x.__add__(y) &lt;==&gt; x+y """
 852         pass
 853 
 854     def __and__(self, y): # real signature unknown; restored from __doc__
 855         """ x.__and__(y) &lt;==&gt; x&amp;y """
 856         pass
 857 
 858     def __cmp__(self, y): # real signature unknown; restored from __doc__
 859         """ x.__cmp__(y) &lt;==&gt; cmp(x,y) """
 860         pass
 861 
 862     def __coerce__(self, y): # real signature unknown; restored from __doc__
 863         """ x.__coerce__(y) &lt;==&gt; coerce(x, y) """
 864         pass
 865 
 866     def __divmod__(self, y): # real signature unknown; restored from __doc__
 867         """ x.__divmod__(y) &lt;==&gt; divmod(x, y) """
 868         pass
 869 
 870     def __div__(self, y): # real signature unknown; restored from __doc__
 871         """ x.__div__(y) &lt;==&gt; x/y """
 872         pass
 873 
 874     def __float__(self): # real signature unknown; restored from __doc__
 875         """ x.__float__() &lt;==&gt; float(x) """
 876         pass
 877 
 878     def __floordiv__(self, y): # real signature unknown; restored from __doc__
 879         """ x.__floordiv__(y) &lt;==&gt; x//y """
 880         pass
 881 
 882     def __format__(self, *args, **kwargs): # real signature unknown
 883         pass
 884 
 885     def __getattribute__(self, name): # real signature unknown; restored from __doc__
 886         """ x.__getattribute__('name') &lt;==&gt; x.name """
 887         pass
 888 
 889     def __getnewargs__(self, *args, **kwargs): # real signature unknown
 890         pass
 891 
 892     def __hash__(self): # real signature unknown; restored from __doc__
 893         """ x.__hash__() &lt;==&gt; hash(x) """
 894         pass
 895 
 896     def __hex__(self): # real signature unknown; restored from __doc__
 897         """ x.__hex__() &lt;==&gt; hex(x) """
 898         pass
 899 
 900     def __index__(self): # real signature unknown; restored from __doc__
 901         """ x[y:z] &lt;==&gt; x[y.__index__():z.__index__()] """
 902         pass
 903 
 904     def __init__(self, x, base=10): # known special case of int.__init__
 905         """
 906         int(x=0) -&gt; int or long
 907         int(x, base=10) -&gt; int or long
 908         
 909         Convert a number or string to an integer, or return 0 if no arguments
 910         are given.  If x is floating point, the conversion truncates towards zero.
 911         If x is outside the integer range, the function returns a long instead.
 912         
 913         If x is not a number or if base is given, then x must be a string or
 914         Unicode object representing an integer literal in the given base.  The
 915         literal can be preceded by '+' or '-' and be surrounded by whitespace.
 916         The base defaults to 10.  Valid bases are 0 and 2-36.  Base 0 means to
 917         interpret the base from the string as an integer literal.
 918         &gt;&gt;&gt; int('0b100', base=0)
 919         4
 920         # (copied from class doc)
 921         """
 922         pass
 923 
 924     def __int__(self): # real signature unknown; restored from __doc__
 925         """ x.__int__() &lt;==&gt; int(x) """
 926         pass
 927 
 928     def __invert__(self): # real signature unknown; restored from __doc__
 929         """ x.__invert__() &lt;==&gt; ~x """
 930         pass
 931 
 932     def __long__(self): # real signature unknown; restored from __doc__
 933         """ x.__long__() &lt;==&gt; long(x) """
 934         pass
 935 
 936     def __lshift__(self, y): # real signature unknown; restored from __doc__
 937         """ x.__lshift__(y) &lt;==&gt; x&lt;&lt;y """
 938         pass
 939 
 940     def __mod__(self, y): # real signature unknown; restored from __doc__
 941         """ x.__mod__(y) &lt;==&gt; x%y """
 942         pass
 943 
 944     def __mul__(self, y): # real signature unknown; restored from __doc__
 945         """ x.__mul__(y) &lt;==&gt; x*y """
 946         pass
 947 
 948     def __neg__(self): # real signature unknown; restored from __doc__
 949         """ x.__neg__() &lt;==&gt; -x """
 950         pass
 951 
 952     @staticmethod # known case of __new__
 953     def __new__(S, *more): # real signature unknown; restored from __doc__
 954         """ T.__new__(S, ...) -&gt; a new object with type S, a subtype of T """
 955         pass
 956 
 957     def __nonzero__(self): # real signature unknown; restored from __doc__
 958         """ x.__nonzero__() &lt;==&gt; x != 0 """
 959         pass
 960 
 961     def __oct__(self): # real signature unknown; restored from __doc__
 962         """ x.__oct__() &lt;==&gt; oct(x) """
 963         pass
 964 
 965     def __or__(self, y): # real signature unknown; restored from __doc__
 966         """ x.__or__(y) &lt;==&gt; x|y """
 967         pass
 968 
 969     def __pos__(self): # real signature unknown; restored from __doc__
 970         """ x.__pos__() &lt;==&gt; +x """
 971         pass
 972 
 973     def __pow__(self, y, z=None): # real signature unknown; restored from __doc__
 974         """ x.__pow__(y[, z]) &lt;==&gt; pow(x, y[, z]) """
 975         pass
 976 
 977     def __radd__(self, y): # real signature unknown; restored from __doc__
 978         """ x.__radd__(y) &lt;==&gt; y+x """
 979         pass
 980 
 981     def __rand__(self, y): # real signature unknown; restored from __doc__
 982         """ x.__rand__(y) &lt;==&gt; y&amp;x """
 983         pass
 984 
 985     def __rdivmod__(self, y): # real signature unknown; restored from __doc__
 986         """ x.__rdivmod__(y) &lt;==&gt; divmod(y, x) """
 987         pass
 988 
 989     def __rdiv__(self, y): # real signature unknown; restored from __doc__
 990         """ x.__rdiv__(y) &lt;==&gt; y/x """
 991         pass
 992 
 993     def __repr__(self): # real signature unknown; restored from __doc__
 994         """ x.__repr__() &lt;==&gt; repr(x) """
 995         pass
 996 
 997     def __rfloordiv__(self, y): # real signature unknown; restored from __doc__
 998         """ x.__rfloordiv__(y) &lt;==&gt; y//x """
 999         pass
1000 
1001     def __rlshift__(self, y): # real signature unknown; restored from __doc__
1002         """ x.__rlshift__(y) &lt;==&gt; y&lt;&lt;x """
1003         pass
1004 
1005     def __rmod__(self, y): # real signature unknown; restored from __doc__
1006         """ x.__rmod__(y) &lt;==&gt; y%x """
1007         pass
1008 
1009     def __rmul__(self, y): # real signature unknown; restored from __doc__
1010         """ x.__rmul__(y) &lt;==&gt; y*x """
1011         pass
1012 
1013     def __ror__(self, y): # real signature unknown; restored from __doc__
1014         """ x.__ror__(y) &lt;==&gt; y|x """
1015         pass
1016 
1017     def __rpow__(self, x, z=None): # real signature unknown; restored from __doc__
1018         """ y.__rpow__(x[, z]) &lt;==&gt; pow(x, y[, z]) """
1019         pass
1020 
1021     def __rrshift__(self, y): # real signature unknown; restored from __doc__
1022         """ x.__rrshift__(y) &lt;==&gt; y&gt;&gt;x """
1023         pass
1024 
1025     def __rshift__(self, y): # real signature unknown; restored from __doc__
1026         """ x.__rshift__(y) &lt;==&gt; x&gt;&gt;y """
1027         pass
1028 
1029     def __rsub__(self, y): # real signature unknown; restored from __doc__
1030         """ x.__rsub__(y) &lt;==&gt; y-x """
1031         pass
1032 
1033     def __rtruediv__(self, y): # real signature unknown; restored from __doc__
1034         """ x.__rtruediv__(y) &lt;==&gt; y/x """
1035         pass
1036 
1037     def __rxor__(self, y): # real signature unknown; restored from __doc__
1038         """ x.__rxor__(y) &lt;==&gt; y^x """
1039         pass
1040 
1041     def __str__(self): # real signature unknown; restored from __doc__
1042         """ x.__str__() &lt;==&gt; str(x) """
1043         pass
1044 
1045     def __sub__(self, y): # real signature unknown; restored from __doc__
1046         """ x.__sub__(y) &lt;==&gt; x-y """
1047         pass
1048 
1049     def __truediv__(self, y): # real signature unknown; restored from __doc__
1050         """ x.__truediv__(y) &lt;==&gt; x/y """
1051         pass
1052 
1053     def __trunc__(self, *args, **kwargs): # real signature unknown
1054         """ Truncating an Integral returns itself. """
1055         pass
1056 
1057     def __xor__(self, y): # real signature unknown; restored from __doc__
1058         """ x.__xor__(y) &lt;==&gt; x^y """
1059         pass
1060 
1061     denominator = property(lambda self: object(), lambda self, v: None, lambda self: None)  # default
1062     """the denominator of a rational number in lowest terms"""
1063 
1064     imag = property(lambda self: object(), lambda self, v: None, lambda self: None)  # default
1065     """the imaginary part of a complex number"""
1066 
1067     numerator = property(lambda self: object(), lambda self, v: None, lambda self: None)  # default
1068     """the numerator of a rational number in lowest terms"""
1069 
1070     real = property(lambda self: object(), lambda self, v: None, lambda self: None)  # default
1071     """the real part of a complex number"""
1072 
1073 
1074 
1075 class bool(int):
1076     """
1077     bool(x) -&gt; bool
1078     
1079     Returns True when the argument x is true, False otherwise.
1080     The builtins True and False are the only two instances of the class bool.
1081     The class bool is a subclass of the class int, and cannot be subclassed.
1082     """
1083     def __and__(self, y): # real signature unknown; restored from __doc__
1084         """ x.__and__(y) &lt;==&gt; x&amp;y """
1085         pass
1086 
1087     def __init__(self, x): # real signature unknown; restored from __doc__
1088         pass
1089 
1090     @staticmethod # known case of __new__
1091     def __new__(S, *more): # real signature unknown; restored from __doc__
1092         """ T.__new__(S, ...) -&gt; a new object with type S, a subtype of T """
1093         pass
1094 
1095     def __or__(self, y): # real signature unknown; restored from __doc__
1096         """ x.__or__(y) &lt;==&gt; x|y """
1097         pass
1098 
1099     def __rand__(self, y): # real signature unknown; restored from __doc__
1100         """ x.__rand__(y) &lt;==&gt; y&amp;x """
1101         pass
1102 
1103     def __repr__(self): # real signature unknown; restored from __doc__
1104         """ x.__repr__() &lt;==&gt; repr(x) """
1105         pass
1106 
1107     def __ror__(self, y): # real signature unknown; restored from __doc__
1108         """ x.__ror__(y) &lt;==&gt; y|x """
1109         pass
1110 
1111     def __rxor__(self, y): # real signature unknown; restored from __doc__
1112         """ x.__rxor__(y) &lt;==&gt; y^x """
1113         pass
1114 
1115     def __str__(self): # real signature unknown; restored from __doc__
1116         """ x.__str__() &lt;==&gt; str(x) """
1117         pass
1118 
1119     def __xor__(self, y): # real signature unknown; restored from __doc__
1120         """ x.__xor__(y) &lt;==&gt; x^y """
1121         pass
1122 
1123 
1124 class buffer(object):
1125     """
1126     buffer(object [, offset[, size]])
1127     
1128     Create a new buffer object which references the given object.
1129     The buffer will reference a slice of the target object from the
1130     start of the object (or at the specified offset). The slice will
1131     extend to the end of the target object (or with the specified size).
1132     """
1133     def __add__(self, y): # real signature unknown; restored from __doc__
1134         """ x.__add__(y) &lt;==&gt; x+y """
1135         pass
1136 
1137     def __cmp__(self, y): # real signature unknown; restored from __doc__
1138         """ x.__cmp__(y) &lt;==&gt; cmp(x,y) """
1139         pass
1140 
1141     def __delitem__(self, y): # real signature unknown; restored from __doc__
1142         """ x.__delitem__(y) &lt;==&gt; del x[y] """
1143         pass
1144 
1145     def __delslice__(self, i, j): # real signature unknown; restored from __doc__
1146         """
1147         x.__delslice__(i, j) &lt;==&gt; del x[i:j]
1148                    
1149                    Use of negative indices is not supported.
1150         """
1151         pass
1152 
1153     def __getattribute__(self, name): # real signature unknown; restored from __doc__
1154         """ x.__getattribute__('name') &lt;==&gt; x.name """
1155         pass
1156 
1157     def __getitem__(self, y): # real signature unknown; restored from __doc__
1158         """ x.__getitem__(y) &lt;==&gt; x[y] """
1159         pass
1160 
1161     def __getslice__(self, i, j): # real signature unknown; restored from __doc__
1162         """
1163         x.__getslice__(i, j) &lt;==&gt; x[i:j]
1164                    
1165                    Use of negative indices is not supported.
1166         """
1167         pass
1168 
1169     def __hash__(self): # real signature unknown; restored from __doc__
1170         """ x.__hash__() &lt;==&gt; hash(x) """
1171         pass
1172 
1173     def __init__(self, p_object, offset=None, size=None): # real signature unknown; restored from __doc__
1174         pass
1175 
1176     def __len__(self): # real signature unknown; restored from __doc__
1177         """ x.__len__() &lt;==&gt; len(x) """
1178         pass
1179 
1180     def __mul__(self, n): # real signature unknown; restored from __doc__
1181         """ x.__mul__(n) &lt;==&gt; x*n """
1182         pass
1183 
1184     @staticmethod # known case of __new__
1185     def __new__(S, *more): # real signature unknown; restored from __doc__
1186         """ T.__new__(S, ...) -&gt; a new object with type S, a subtype of T """
1187         pass
1188 
1189     def __repr__(self): # real signature unknown; restored from __doc__
1190         """ x.__repr__() &lt;==&gt; repr(x) """
1191         pass
1192 
1193     def __rmul__(self, n): # real signature unknown; restored from __doc__
1194         """ x.__rmul__(n) &lt;==&gt; n*x """
1195         pass
1196 
1197     def __setitem__(self, i, y): # real signature unknown; restored from __doc__
1198         """ x.__setitem__(i, y) &lt;==&gt; x[i]=y """
1199         pass
1200 
1201     def __setslice__(self, i, j, y): # real signature unknown; restored from __doc__
1202         """
1203         x.__setslice__(i, j, y) &lt;==&gt; x[i:j]=y
1204                    
1205                    Use  of negative indices is not supported.
1206         """
1207         pass
1208 
1209     def __str__(self): # real signature unknown; restored from __doc__
1210         """ x.__str__() &lt;==&gt; str(x) """
1211         pass
1212 
1213 
1214 class bytearray(object):
1215     """
1216     bytearray(iterable_of_ints) -&gt; bytearray.
1217     bytearray(string, encoding[, errors]) -&gt; bytearray.
1218     bytearray(bytes_or_bytearray) -&gt; mutable copy of bytes_or_bytearray.
1219     bytearray(memory_view) -&gt; bytearray.
1220     
1221     Construct a mutable bytearray object from:
1222       - an iterable yielding integers in range(256)
1223       - a text string encoded using the specified encoding
1224       - a bytes or a bytearray object
1225       - any object implementing the buffer API.
1226     
1227     bytearray(int) -&gt; bytearray.
1228     
1229     Construct a zero-initialized bytearray of the given length.
1230     """
1231     def append(self, p_int): # real signature unknown; restored from __doc__
1232         """
1233         B.append(int) -&gt; None
1234         
1235         Append a single item to the end of B.
1236         """
1237         pass
1238 
1239     def capitalize(self): # real signature unknown; restored from __doc__
1240         """
1241         B.capitalize() -&gt; copy of B
1242         
1243         Return a copy of B with only its first character capitalized (ASCII)
1244         and the rest lower-cased.
1245         """
1246         pass
1247 
1248     def center(self, width, fillchar=None): # real signature unknown; restored from __doc__
1249         """
1250         B.center(width[, fillchar]) -&gt; copy of B
1251         
1252         Return B centered in a string of length width.  Padding is
1253         done using the specified fill character (default is a space).
1254         """
1255         pass
1256 
1257     def count(self, sub, start=None, end=None): # real signature unknown; restored from __doc__
1258         """
1259         B.count(sub [,start [,end]]) -&gt; int
1260         
1261         Return the number of non-overlapping occurrences of subsection sub in
1262         bytes B[start:end].  Optional arguments start and end are interpreted
1263         as in slice notation.
1264         """
1265         return 0
1266 
1267     def decode(self, encoding=None, errors=None): # real signature unknown; restored from __doc__
1268         """
1269         B.decode([encoding[, errors]]) -&gt; unicode object.
1270         
1271         Decodes B using the codec registered for encoding. encoding defaults
1272         to the default encoding. errors may be given to set a different error
1273         handling scheme.  Default is 'strict' meaning that encoding errors raise
1274         a UnicodeDecodeError.  Other possible values are 'ignore' and 'replace'
1275         as well as any other name registered with codecs.register_error that is
1276         able to handle UnicodeDecodeErrors.
1277         """
1278         return u""
1279 
1280     def endswith(self, suffix, start=None, end=None): # real signature unknown; restored from __doc__
1281         """
1282         B.endswith(suffix [,start [,end]]) -&gt; bool
1283         
1284         Return True if B ends with the specified suffix, False otherwise.
1285         With optional start, test B beginning at that position.
1286         With optional end, stop comparing B at that position.
1287         suffix can also be a tuple of strings to try.
1288         """
1289         return False
1290 
1291     def expandtabs(self, tabsize=None): # real signature unknown; restored from __doc__
1292         """
1293         B.expandtabs([tabsize]) -&gt; copy of B
1294         
1295         Return a copy of B where all tab characters are expanded using spaces.
1296         If tabsize is not given, a tab size of 8 characters is assumed.
1297         """
1298         pass
1299 
1300     def extend(self, iterable_int): # real signature unknown; restored from __doc__
1301         """
1302         B.extend(iterable int) -&gt; None
1303         
1304         Append all the elements from the iterator or sequence to the
1305         end of B.
1306         """
1307         pass
1308 
1309     def find(self, sub, start=None, end=None): # real signature unknown; restored from __doc__
1310         """
1311         B.find(sub [,start [,end]]) -&gt; int
1312         
1313         Return the lowest index in B where subsection sub is found,
1314         such that sub is contained within B[start,end].  Optional
1315         arguments start and end are interpreted as in slice notation.
1316         
1317         Return -1 on failure.
1318         """
1319         return 0
1320 
1321     @classmethod # known case
1322     def fromhex(cls, string): # real signature unknown; restored from __doc__
1323         """
1324         bytearray.fromhex(string) -&gt; bytearray
1325         
1326         Create a bytearray object from a string of hexadecimal numbers.
1327         Spaces between two numbers are accepted.
1328         Example: bytearray.fromhex('B9 01EF') -&gt; bytearray(b'\xb9\x01\xef').
1329         """
1330         return bytearray
1331 
1332     def index(self, sub, start=None, end=None): # real signature unknown; restored from __doc__
1333         """
1334         B.index(sub [,start [,end]]) -&gt; int
1335         
1336         Like B.find() but raise ValueError when the subsection is not found.
1337         """
1338         return 0
1339 
1340     def insert(self, index, p_int): # real signature unknown; restored from __doc__
1341         """
1342         B.insert(index, int) -&gt; None
1343         
1344         Insert a single item into the bytearray before the given index.
1345         """
1346         pass
1347 
1348     def isalnum(self): # real signature unknown; restored from __doc__
1349         """
1350         B.isalnum() -&gt; bool
1351         
1352         Return True if all characters in B are alphanumeric
1353         and there is at least one character in B, False otherwise.
1354         """
1355         return False
1356 
1357     def isalpha(self): # real signature unknown; restored from __doc__
1358         """
1359         B.isalpha() -&gt; bool
1360         
1361         Return True if all characters in B are alphabetic
1362         and there is at least one character in B, False otherwise.
1363         """
1364         return False
1365 
1366     def isdigit(self): # real signature unknown; restored from __doc__
1367         """
1368         B.isdigit() -&gt; bool
1369         
1370         Return True if all characters in B are digits
1371         and there is at least one character in B, False otherwise.
1372         """
1373         return False
1374 
1375     def islower(self): # real signature unknown; restored from __doc__
1376         """
1377         B.islower() -&gt; bool
1378         
1379         Return True if all cased characters in B are lowercase and there is
1380         at least one cased character in B, False otherwise.
1381         """
1382         return False
1383 
1384     def isspace(self): # real signature unknown; restored from __doc__
1385         """
1386         B.isspace() -&gt; bool
1387         
1388         Return True if all characters in B are whitespace
1389         and there is at least one character in B, False otherwise.
1390         """
1391         return False
1392 
1393     def istitle(self): # real signature unknown; restored from __doc__
1394         """
1395         B.istitle() -&gt; bool
1396         
1397         Return True if B is a titlecased string and there is at least one
1398         character in B, i.e. uppercase characters may only follow uncased
1399         characters and lowercase characters only cased ones. Return False
1400         otherwise.
1401         """
1402         return False
1403 
1404     def isupper(self): # real signature unknown; restored from __doc__
1405         """
1406         B.isupper() -&gt; bool
1407         
1408         Return True if all cased characters in B are uppercase and there is
1409         at least one cased character in B, False otherwise.
1410         """
1411         return False
1412 
1413     def join(self, iterable_of_bytes): # real signature unknown; restored from __doc__
1414         """
1415         B.join(iterable_of_bytes) -&gt; bytes
1416         
1417         Concatenates any number of bytearray objects, with B in between each pair.
1418         """
1419         return ""
1420 
1421     def ljust(self, width, fillchar=None): # real signature unknown; restored from __doc__
1422         """
1423         B.ljust(width[, fillchar]) -&gt; copy of B
1424         
1425         Return B left justified in a string of length width. Padding is
1426         done using the specified fill character (default is a space).
1427         """
1428         pass
1429 
1430     def lower(self): # real signature unknown; restored from __doc__
1431         """
1432         B.lower() -&gt; copy of B
1433         
1434         Return a copy of B with all ASCII characters converted to lowercase.
1435         """
1436         pass
1437 
1438     def lstrip(self, bytes=None): # real signature unknown; restored from __doc__
1439         """
1440         B.lstrip([bytes]) -&gt; bytearray
1441         
1442         Strip leading bytes contained in the argument.
1443         If the argument is omitted, strip leading ASCII whitespace.
1444         """
1445         return bytearray
1446 
1447     def partition(self, sep): # real signature unknown; restored from __doc__
1448         """
1449         B.partition(sep) -&gt; (head, sep, tail)
1450         
1451         Searches for the separator sep in B, and returns the part before it,
1452         the separator itself, and the part after it.  If the separator is not
1453         found, returns B and two empty bytearray objects.
1454         """
1455         pass
1456 
1457     def pop(self, index=None): # real signature unknown; restored from __doc__
1458         """
1459         B.pop([index]) -&gt; int
1460         
1461         Remove and return a single item from B. If no index
1462         argument is given, will pop the last value.
1463         """
1464         return 0
1465 
1466     def remove(self, p_int): # real signature unknown; restored from __doc__
1467         """
1468         B.remove(int) -&gt; None
1469         
1470         Remove the first occurrence of a value in B.
1471         """
1472         pass
1473 
1474     def replace(self, old, new, count=None): # real signature unknown; restored from __doc__
1475         """
1476         B.replace(old, new[, count]) -&gt; bytes
1477         
1478         Return a copy of B with all occurrences of subsection
1479         old replaced by new.  If the optional argument count is
1480         given, only the first count occurrences are replaced.
1481         """
1482         return ""
1483 
1484     def reverse(self): # real signature unknown; restored from __doc__
1485         """
1486         B.reverse() -&gt; None
1487         
1488         Reverse the order of the values in B in place.
1489         """
1490         pass
1491 
1492     def rfind(self, sub, start=None, end=None): # real signature unknown; restored from __doc__
1493         """
1494         B.rfind(sub [,start [,end]]) -&gt; int
1495         
1496         Return the highest index in B where subsection sub is found,
1497         such that sub is contained within B[start,end].  Optional
1498         arguments start and end are interpreted as in slice notation.
1499         
1500         Return -1 on failure.
1501         """
1502         return 0
1503 
1504     def rindex(self, sub, start=None, end=None): # real signature unknown; restored from __doc__
1505         """
1506         B.rindex(sub [,start [,end]]) -&gt; int
1507         
1508         Like B.rfind() but raise ValueError when the subsection is not found.
1509         """
1510         return 0
1511 
1512     def rjust(self, width, fillchar=None): # real signature unknown; restored from __doc__
1513         """
1514         B.rjust(width[, fillchar]) -&gt; copy of B
1515         
1516         Return B right justified in a string of length width. Padding is
1517         done using the specified fill character (default is a space)
1518         """
1519         pass
1520 
1521     def rpartition(self, sep): # real signature unknown; restored from __doc__
1522         """
1523         B.rpartition(sep) -&gt; (head, sep, tail)
1524         
1525         Searches for the separator sep in B, starting at the end of B,
1526         and returns the part before it, the separator itself, and the
1527         part after it.  If the separator is not found, returns two empty
1528         bytearray objects and B.
1529         """
1530         pass
1531 
1532     def rsplit(self, sep, maxsplit=None): # real signature unknown; restored from __doc__
1533         """
1534         B.rsplit(sep[, maxsplit]) -&gt; list of bytearray
1535         
1536         Return a list of the sections in B, using sep as the delimiter,
1537         starting at the end of B and working to the front.
1538         If sep is not given, B is split on ASCII whitespace characters
1539         (space, tab, return, newline, formfeed, vertical tab).
1540         If maxsplit is given, at most maxsplit splits are done.
1541         """
1542         return []
1543 
1544     def rstrip(self, bytes=None): # real signature unknown; restored from __doc__
1545         """
1546         B.rstrip([bytes]) -&gt; bytearray
1547         
1548         Strip trailing bytes contained in the argument.
1549         If the argument is omitted, strip trailing ASCII whitespace.
1550         """
1551         return bytearray
1552 
1553     def split(self, sep=None, maxsplit=None): # real signature unknown; restored from __doc__
1554         """
1555         B.split([sep[, maxsplit]]) -&gt; list of bytearray
1556         
1557         Return a list of the sections in B, using sep as the delimiter.
1558         If sep is not given, B is split on ASCII whitespace characters
1559         (space, tab, return, newline, formfeed, vertical tab).
1560         If maxsplit is given, at most maxsplit splits are done.
1561         """
1562         return []
1563 
1564     def splitlines(self, keepends=False): # real signature unknown; restored from __doc__
1565         """
1566         B.splitlines(keepends=False) -&gt; list of lines
1567         
1568         Return a list of the lines in B, breaking at line boundaries.
1569         Line breaks are not included in the resulting list unless keepends
1570         is given and true.
1571         """
1572         return []
1573 
1574     def startswith(self, prefix, start=None, end=None): # real signature unknown; restored from __doc__
1575         """
1576         B.startswith(prefix [,start [,end]]) -&gt; bool
1577         
1578         Return True if B starts with the specified prefix, False otherwise.
1579         With optional start, test B beginning at that position.
1580         With optional end, stop comparing B at that position.
1581         prefix can also be a tuple of strings to try.
1582         """
1583         return False
1584 
1585     def strip(self, bytes=None): # real signature unknown; restored from __doc__
1586         """
1587         B.strip([bytes]) -&gt; bytearray
1588         
1589         Strip leading and trailing bytes contained in the argument.
1590         If the argument is omitted, strip ASCII whitespace.
1591         """
1592         return bytearray
1593 
1594     def swapcase(self): # real signature unknown; restored from __doc__
1595         """
1596         B.swapcase() -&gt; copy of B
1597         
1598         Return a copy of B with uppercase ASCII characters converted
1599         to lowercase ASCII and vice versa.
1600         """
1601         pass
1602 
1603     def title(self): # real signature unknown; restored from __doc__
1604         """
1605         B.title() -&gt; copy of B
1606         
1607         Return a titlecased version of B, i.e. ASCII words start with uppercase
1608         characters, all remaining cased characters have lowercase.
1609         """
1610         pass
1611 
1612     def translate(self, table, deletechars=None): # real signature unknown; restored from __doc__
1613         """
1614         B.translate(table[, deletechars]) -&gt; bytearray
1615         
1616         Return a copy of B, where all characters occurring in the
1617         optional argument deletechars are removed, and the remaining
1618         characters have been mapped through the given translation
1619         table, which must be a bytes object of length 256.
1620         """
1621         return bytearray
1622 
1623     def upper(self): # real signature unknown; restored from __doc__
1624         """
1625         B.upper() -&gt; copy of B
1626         
1627         Return a copy of B with all ASCII characters converted to uppercase.
1628         """
1629         pass
1630 
1631     def zfill(self, width): # real signature unknown; restored from __doc__
1632         """
1633         B.zfill(width) -&gt; copy of B
1634         
1635         Pad a numeric string B with zeros on the left, to fill a field
1636         of the specified width.  B is never truncated.
1637         """
1638         pass
1639 
1640     def __add__(self, y): # real signature unknown; restored from __doc__
1641         """ x.__add__(y) &lt;==&gt; x+y """
1642         pass
1643 
1644     def __alloc__(self): # real signature unknown; restored from __doc__
1645         """
1646         B.__alloc__() -&gt; int
1647         
1648         Returns the number of bytes actually allocated.
1649         """
1650         return 0
1651 
1652     def __contains__(self, y): # real signature unknown; restored from __doc__
1653         """ x.__contains__(y) &lt;==&gt; y in x """
1654         pass
1655 
1656     def __delitem__(self, y): # real signature unknown; restored from __doc__
1657         """ x.__delitem__(y) &lt;==&gt; del x[y] """
1658         pass
1659 
1660     def __eq__(self, y): # real signature unknown; restored from __doc__
1661         """ x.__eq__(y) &lt;==&gt; x==y """
1662         pass
1663 
1664     def __getattribute__(self, name): # real signature unknown; restored from __doc__
1665         """ x.__getattribute__('name') &lt;==&gt; x.name """
1666         pass
1667 
1668     def __getitem__(self, y): # real signature unknown; restored from __doc__
1669         """ x.__getitem__(y) &lt;==&gt; x[y] """
1670         pass
1671 
1672     def __ge__(self, y): # real signature unknown; restored from __doc__
1673         """ x.__ge__(y) &lt;==&gt; x&gt;=y """
1674         pass
1675 
1676     def __gt__(self, y): # real signature unknown; restored from __doc__
1677         """ x.__gt__(y) &lt;==&gt; x&gt;y """
1678         pass
1679 
1680     def __iadd__(self, y): # real signature unknown; restored from __doc__
1681         """ x.__iadd__(y) &lt;==&gt; x+=y """
1682         pass
1683 
1684     def __imul__(self, y): # real signature unknown; restored from __doc__
1685         """ x.__imul__(y) &lt;==&gt; x*=y """
1686         pass
1687 
1688     def __init__(self, source=None, encoding=None, errors='strict'): # known special case of bytearray.__init__
1689         """
1690         bytearray(iterable_of_ints) -&gt; bytearray.
1691         bytearray(string, encoding[, errors]) -&gt; bytearray.
1692         bytearray(bytes_or_bytearray) -&gt; mutable copy of bytes_or_bytearray.
1693         bytearray(memory_view) -&gt; bytearray.
1694         
1695         Construct a mutable bytearray object from:
1696           - an iterable yielding integers in range(256)
1697           - a text string encoded using the specified encoding
1698           - a bytes or a bytearray object
1699           - any object implementing the buffer API.
1700         
1701         bytearray(int) -&gt; bytearray.
1702         
1703         Construct a zero-initialized bytearray of the given length.
1704         # (copied from class doc)
1705         """
1706         pass
1707 
1708     def __iter__(self): # real signature unknown; restored from __doc__
1709         """ x.__iter__() &lt;==&gt; iter(x) """
1710         pass
1711 
1712     def __len__(self): # real signature unknown; restored from __doc__
1713         """ x.__len__() &lt;==&gt; len(x) """
1714         pass
1715 
1716     def __le__(self, y): # real signature unknown; restored from __doc__
1717         """ x.__le__(y) &lt;==&gt; x&lt;=y """
1718         pass
1719 
1720     def __lt__(self, y): # real signature unknown; restored from __doc__
1721         """ x.__lt__(y) &lt;==&gt; x&lt;y """
1722         pass
1723 
1724     def __mul__(self, n): # real signature unknown; restored from __doc__
1725         """ x.__mul__(n) &lt;==&gt; x*n """
1726         pass
1727 
1728     @staticmethod # known case of __new__
1729     def __new__(S, *more): # real signature unknown; restored from __doc__
1730         """ T.__new__(S, ...) -&gt; a new object with type S, a subtype of T """
1731         pass
1732 
1733     def __ne__(self, y): # real signature unknown; restored from __doc__
1734         """ x.__ne__(y) &lt;==&gt; x!=y """
1735         pass
1736 
1737     def __reduce__(self, *args, **kwargs): # real signature unknown
1738         """ Return state information for pickling. """
1739         pass
1740 
1741     def __repr__(self): # real signature unknown; restored from __doc__
1742         """ x.__repr__() &lt;==&gt; repr(x) """
1743         pass
1744 
1745     def __rmul__(self, n): # real signature unknown; restored from __doc__
1746         """ x.__rmul__(n) &lt;==&gt; n*x """
1747         pass
1748 
1749     def __setitem__(self, i, y): # real signature unknown; restored from __doc__
1750         """ x.__setitem__(i, y) &lt;==&gt; x[i]=y """
1751         pass
1752 
1753     def __sizeof__(self): # real signature unknown; restored from __doc__
1754         """
1755         B.__sizeof__() -&gt; int
1756          
1757         Returns the size of B in memory, in bytes
1758         """
1759         return 0
1760 
1761     def __str__(self): # real signature unknown; restored from __doc__
1762         """ x.__str__() &lt;==&gt; str(x) """
1763         pass
1764 
1765 
1766 class str(basestring):
1767     """
1768     str(object='') -&gt; string
1769     
1770     Return a nice string representation of the object.
1771     If the argument is a string, the return value is the same object.
1772     """
1773     def capitalize(self): # real signature unknown; restored from __doc__
1774         """
1775         S.capitalize() -&gt; string
1776         
1777         Return a copy of the string S with only its first character
1778         capitalized.
1779         """
1780         return ""
1781 
1782     def center(self, width, fillchar=None): # real signature unknown; restored from __doc__
1783         """
1784         S.center(width[, fillchar]) -&gt; string
1785         
1786         Return S centered in a string of length width. Padding is
1787         done using the specified fill character (default is a space)
1788         """
1789         return ""
1790 
1791     def count(self, sub, start=None, end=None): # real signature unknown; restored from __doc__
1792         """
1793         S.count(sub[, start[, end]]) -&gt; int
1794         
1795         Return the number of non-overlapping occurrences of substring sub in
1796         string S[start:end].  Optional arguments start and end are interpreted
1797         as in slice notation.
1798         """
1799         return 0
1800 
1801     def decode(self, encoding=None, errors=None): # real signature unknown; restored from __doc__
1802         """
1803         S.decode([encoding[,errors]]) -&gt; object
1804         
1805         Decodes S using the codec registered for encoding. encoding defaults
1806         to the default encoding. errors may be given to set a different error
1807         handling scheme. Default is 'strict' meaning that encoding errors raise
1808         a UnicodeDecodeError. Other possible values are 'ignore' and 'replace'
1809         as well as any other name registered with codecs.register_error that is
1810         able to handle UnicodeDecodeErrors.
1811         """
1812         return object()
1813 
1814     def encode(self, encoding=None, errors=None): # real signature unknown; restored from __doc__
1815         """
1816         S.encode([encoding[,errors]]) -&gt; object
1817         
1818         Encodes S using the codec registered for encoding. encoding defaults
1819         to the default encoding. errors may be given to set a different error
1820         handling scheme. Default is 'strict' meaning that encoding errors raise
1821         a UnicodeEncodeError. Other possible values are 'ignore', 'replace' and
1822         'xmlcharrefreplace' as well as any other name registered with
1823         codecs.register_error that is able to handle UnicodeEncodeErrors.
1824         """
1825         return object()
1826 
1827     def endswith(self, suffix, start=None, end=None): # real signature unknown; restored from __doc__
1828         """
1829         S.endswith(suffix[, start[, end]]) -&gt; bool
1830         
1831         Return True if S ends with the specified suffix, False otherwise.
1832         With optional start, test S beginning at that position.
1833         With optional end, stop comparing S at that position.
1834         suffix can also be a tuple of strings to try.
1835         """
1836         return False
1837 
1838     def expandtabs(self, tabsize=None): # real signature unknown; restored from __doc__
1839         """
1840         S.expandtabs([tabsize]) -&gt; string
1841         
1842         Return a copy of S where all tab characters are expanded using spaces.
1843         If tabsize is not given, a tab size of 8 characters is assumed.
1844         """
1845         return ""
1846 
1847     def find(self, sub, start=None, end=None): # real signature unknown; restored from __doc__
1848         """
1849         S.find(sub [,start [,end]]) -&gt; int
1850         
1851         Return the lowest index in S where substring sub is found,
1852         such that sub is contained within S[start:end].  Optional
1853         arguments start and end are interpreted as in slice notation.
1854         
1855         Return -1 on failure.
1856         """
1857         return 0
1858 
1859     def format(self, *args, **kwargs): # known special case of str.format
1860         """
1861         S.format(*args, **kwargs) -&gt; string
1862         
1863         Return a formatted version of S, using substitutions from args and kwargs.
1864         The substitutions are identified by braces ('{' and '}').
1865         """
1866         pass
1867 
1868     def index(self, sub, start=None, end=None): # real signature unknown; restored from __doc__
1869         """
1870         S.index(sub [,start [,end]]) -&gt; int
1871         
1872         Like S.find() but raise ValueError when the substring is not found.
1873         """
1874         return 0
1875 
1876     def isalnum(self): # real signature unknown; restored from __doc__
1877         """
1878         S.isalnum() -&gt; bool
1879         
1880         Return True if all characters in S are alphanumeric
1881         and there is at least one character in S, False otherwise.
1882         """
1883         return False
1884 
1885     def isalpha(self): # real signature unknown; restored from __doc__
1886         """
1887         S.isalpha() -&gt; bool
1888         
1889         Return True if all characters in S are alphabetic
1890         and there is at least one character in S, False otherwise.
1891         """
1892         return False
1893 
1894     def isdigit(self): # real signature unknown; restored from __doc__
1895         """
1896         S.isdigit() -&gt; bool
1897         
1898         Return True if all characters in S are digits
1899         and there is at least one character in S, False otherwise.
1900         """
1901         return False
1902 
1903     def islower(self): # real signature unknown; restored from __doc__
1904         """
1905         S.islower() -&gt; bool
1906         
1907         Return True if all cased characters in S are lowercase and there is
1908         at least one cased character in S, False otherwise.
1909         """
1910         return False
1911 
1912     def isspace(self): # real signature unknown; restored from __doc__
1913         """
1914         S.isspace() -&gt; bool
1915         
1916         Return True if all characters in S are whitespace
1917         and there is at least one character in S, False otherwise.
1918         """
1919         return False
1920 
1921     def istitle(self): # real signature unknown; restored from __doc__
1922         """
1923         S.istitle() -&gt; bool
1924         
1925         Return True if S is a titlecased string and there is at least one
1926         character in S, i.e. uppercase characters may only follow uncased
1927         characters and lowercase characters only cased ones. Return False
1928         otherwise.
1929         """
1930         return False
1931 
1932     def isupper(self): # real signature unknown; restored from __doc__
1933         """
1934         S.isupper() -&gt; bool
1935         
1936         Return True if all cased characters in S are uppercase and there is
1937         at least one cased character in S, False otherwise.
1938         """
1939         return False
1940 
1941     def join(self, iterable): # real signature unknown; restored from __doc__
1942         """
1943         S.join(iterable) -&gt; string
1944         
1945         Return a string which is the concatenation of the strings in the
1946         iterable.  The separator between elements is S.
1947         """
1948         return ""
1949 
1950     def ljust(self, width, fillchar=None): # real signature unknown; restored from __doc__
1951         """
1952         S.ljust(width[, fillchar]) -&gt; string
1953         
1954         Return S left-justified in a string of length width. Padding is
1955         done using the specified fill character (default is a space).
1956         """
1957         return ""
1958 
1959     def lower(self): # real signature unknown; restored from __doc__
1960         """
1961         S.lower() -&gt; string
1962         
1963         Return a copy of the string S converted to lowercase.
1964         """
1965         return ""
1966 
1967     def lstrip(self, chars=None): # real signature unknown; restored from __doc__
1968         """
1969         S.lstrip([chars]) -&gt; string or unicode
1970         
1971         Return a copy of the string S with leading whitespace removed.
1972         If chars is given and not None, remove characters in chars instead.
1973         If chars is unicode, S will be converted to unicode before stripping
1974         """
1975         return ""
1976 
1977     def partition(self, sep): # real signature unknown; restored from __doc__
1978         """
1979         S.partition(sep) -&gt; (head, sep, tail)
1980         
1981         Search for the separator sep in S, and return the part before it,
1982         the separator itself, and the part after it.  If the separator is not
1983         found, return S and two empty strings.
1984         """
1985         pass
1986 
1987     def replace(self, old, new, count=None): # real signature unknown; restored from __doc__
1988         """
1989         S.replace(old, new[, count]) -&gt; string
1990         
1991         Return a copy of string S with all occurrences of substring
1992         old replaced by new.  If the optional argument count is
1993         given, only the first count occurrences are replaced.
1994         """
1995         return ""
1996 
1997     def rfind(self, sub, start=None, end=None): # real signature unknown; restored from __doc__
1998         """
1999         S.rfind(sub [,start [,end]]) -&gt; int
2000         
2001         Return the highest index in S where substring sub is found,
2002         such that sub is contained within S[start:end].  Optional
2003         arguments start and end are interpreted as in slice notation.
2004         
2005         Return -1 on failure.
2006         """
2007         return 0
2008 
2009     def rindex(self, sub, start=None, end=None): # real signature unknown; restored from __doc__
2010         """
2011         S.rindex(sub [,start [,end]]) -&gt; int
2012         
2013         Like S.rfind() but raise ValueError when the substring is not found.
2014         """
2015         return 0
2016 
2017     def rjust(self, width, fillchar=None): # real signature unknown; restored from __doc__
2018         """
2019         S.rjust(width[, fillchar]) -&gt; string
2020         
2021         Return S right-justified in a string of length width. Padding is
2022         done using the specified fill character (default is a space)
2023         """
2024         return ""
2025 
2026     def rpartition(self, sep): # real signature unknown; restored from __doc__
2027         """
2028         S.rpartition(sep) -&gt; (head, sep, tail)
2029         
2030         Search for the separator sep in S, starting at the end of S, and return
2031         the part before it, the separator itself, and the part after it.  If the
2032         separator is not found, return two empty strings and S.
2033         """
2034         pass
2035 
2036     def rsplit(self, sep=None, maxsplit=None): # real signature unknown; restored from __doc__
2037         """
2038         S.rsplit([sep [,maxsplit]]) -&gt; list of strings
2039         
2040         Return a list of the words in the string S, using sep as the
2041         delimiter string, starting at the end of the string and working
2042         to the front.  If maxsplit is given, at most maxsplit splits are
2043         done. If sep is not specified or is None, any whitespace string
2044         is a separator.
2045         """
2046         return []
2047 
2048     def rstrip(self, chars=None): # real signature unknown; restored from __doc__
2049         """
2050         S.rstrip([chars]) -&gt; string or unicode
2051         
2052         Return a copy of the string S with trailing whitespace removed.
2053         If chars is given and not None, remove characters in chars instead.
2054         If chars is unicode, S will be converted to unicode before stripping
2055         """
2056         return ""
2057 
2058     def split(self, sep=None, maxsplit=None): # real signature unknown; restored from __doc__
2059         """
2060         S.split([sep [,maxsplit]]) -&gt; list of strings
2061         
2062         Return a list of the words in the string S, using sep as the
2063         delimiter string.  If maxsplit is given, at most maxsplit
2064         splits are done. If sep is not specified or is None, any
2065         whitespace string is a separator and empty strings are removed
2066         from the result.
2067         """
2068         return []
2069 
2070     def splitlines(self, keepends=False): # real signature unknown; restored from __doc__
2071         """
2072         S.splitlines(keepends=False) -&gt; list of strings
2073         
2074         Return a list of the lines in S, breaking at line boundaries.
2075         Line breaks are not included in the resulting list unless keepends
2076         is given and true.
2077         """
2078         return []
2079 
2080     def startswith(self, prefix, start=None, end=None): # real signature unknown; restored from __doc__
2081         """
2082         S.startswith(prefix[, start[, end]]) -&gt; bool
2083         
2084         Return True if S starts with the specified prefix, False otherwise.
2085         With optional start, test S beginning at that position.
2086         With optional end, stop comparing S at that position.
2087         prefix can also be a tuple of strings to try.
2088         """
2089         return False
2090 
2091     def strip(self, chars=None): # real signature unknown; restored from __doc__
2092         """
2093         S.strip([chars]) -&gt; string or unicode
2094         
2095         Return a copy of the string S with leading and trailing
2096         whitespace removed.
2097         If chars is given and not None, remove characters in chars instead.
2098         If chars is unicode, S will be converted to unicode before stripping
2099         """
2100         return ""
2101 
2102     def swapcase(self): # real signature unknown; restored from __doc__
2103         """
2104         S.swapcase() -&gt; string
2105         
2106         Return a copy of the string S with uppercase characters
2107         converted to lowercase and vice versa.
2108         """
2109         return ""
2110 
2111     def title(self): # real signature unknown; restored from __doc__
2112         """
2113         S.title() -&gt; string
2114         
2115         Return a titlecased version of S, i.e. words start with uppercase
2116         characters, all remaining cased characters have lowercase.
2117         """
2118         return ""
2119 
2120     def translate(self, table, deletechars=None): # real signature unknown; restored from __doc__
2121         """
2122         S.translate(table [,deletechars]) -&gt; string
2123         
2124         Return a copy of the string S, where all characters occurring
2125         in the optional argument deletechars are removed, and the
2126         remaining characters have been mapped through the given
2127         translation table, which must be a string of length 256 or None.
2128         If the table argument is None, no translation is applied and
2129         the operation simply removes the characters in deletechars.
2130         """
2131         return ""
2132 
2133     def upper(self): # real signature unknown; restored from __doc__
2134         """
2135         S.upper() -&gt; string
2136         
2137         Return a copy of the string S converted to uppercase.
2138         """
2139         return ""
2140 
2141     def zfill(self, width): # real signature unknown; restored from __doc__
2142         """
2143         S.zfill(width) -&gt; string
2144         
2145         Pad a numeric string S with zeros on the left, to fill a field
2146         of the specified width.  The string S is never truncated.
2147         """
2148         return ""
2149 
2150     def _formatter_field_name_split(self, *args, **kwargs): # real signature unknown
2151         pass
2152 
2153     def _formatter_parser(self, *args, **kwargs): # real signature unknown
2154         pass
2155 
2156     def __add__(self, y): # real signature unknown; restored from __doc__
2157         """ x.__add__(y) &lt;==&gt; x+y """
2158         pass
2159 
2160     def __contains__(self, y): # real signature unknown; restored from __doc__
2161         """ x.__contains__(y) &lt;==&gt; y in x """
2162         pass
2163 
2164     def __eq__(self, y): # real signature unknown; restored from __doc__
2165         """ x.__eq__(y) &lt;==&gt; x==y """
2166         pass
2167 
2168     def __format__(self, format_spec): # real signature unknown; restored from __doc__
2169         """
2170         S.__format__(format_spec) -&gt; string
2171         
2172         Return a formatted version of S as described by format_spec.
2173         """
2174         return ""
2175 
2176     def __getattribute__(self, name): # real signature unknown; restored from __doc__
2177         """ x.__getattribute__('name') &lt;==&gt; x.name """
2178         pass
2179 
2180     def __getitem__(self, y): # real signature unknown; restored from __doc__
2181         """ x.__getitem__(y) &lt;==&gt; x[y] """
2182         pass
2183 
2184     def __getnewargs__(self, *args, **kwargs): # real signature unknown
2185         pass
2186 
2187     def __getslice__(self, i, j): # real signature unknown; restored from __doc__
2188         """
2189         x.__getslice__(i, j) &lt;==&gt; x[i:j]
2190                    
2191                    Use of negative indices is not supported.
2192         """
2193         pass
2194 
2195     def __ge__(self, y): # real signature unknown; restored from __doc__
2196         """ x.__ge__(y) &lt;==&gt; x&gt;=y """
2197         pass
2198 
2199     def __gt__(self, y): # real signature unknown; restored from __doc__
2200         """ x.__gt__(y) &lt;==&gt; x&gt;y """
2201         pass
2202 
2203     def __hash__(self): # real signature unknown; restored from __doc__
2204         """ x.__hash__() &lt;==&gt; hash(x) """
2205         pass
2206 
2207     def __init__(self, string=''): # known special case of str.__init__
2208         """
2209         str(object='') -&gt; string
2210         
2211         Return a nice string representation of the object.
2212         If the argument is a string, the return value is the same object.
2213         # (copied from class doc)
2214         """
2215         pass
2216 
2217     def __len__(self): # real signature unknown; restored from __doc__
2218         """ x.__len__() &lt;==&gt; len(x) """
2219         pass
2220 
2221     def __le__(self, y): # real signature unknown; restored from __doc__
2222         """ x.__le__(y) &lt;==&gt; x&lt;=y """
2223         pass
2224 
2225     def __lt__(self, y): # real signature unknown; restored from __doc__
2226         """ x.__lt__(y) &lt;==&gt; x&lt;y """
2227         pass
2228 
2229     def __mod__(self, y): # real signature unknown; restored from __doc__
2230         """ x.__mod__(y) &lt;==&gt; x%y """
2231         pass
2232 
2233     def __mul__(self, n): # real signature unknown; restored from __doc__
2234         """ x.__mul__(n) &lt;==&gt; x*n """
2235         pass
2236 
2237     @staticmethod # known case of __new__
2238     def __new__(S, *more): # real signature unknown; restored from __doc__
2239         """ T.__new__(S, ...) -&gt; a new object with type S, a subtype of T """
2240         pass
2241 
2242     def __ne__(self, y): # real signature unknown; restored from __doc__
2243         """ x.__ne__(y) &lt;==&gt; x!=y """
2244         pass
2245 
2246     def __repr__(self): # real signature unknown; restored from __doc__
2247         """ x.__repr__() &lt;==&gt; repr(x) """
2248         pass
2249 
2250     def __rmod__(self, y): # real signature unknown; restored from __doc__
2251         """ x.__rmod__(y) &lt;==&gt; y%x """
2252         pass
2253 
2254     def __rmul__(self, n): # real signature unknown; restored from __doc__
2255         """ x.__rmul__(n) &lt;==&gt; n*x """
2256         pass
2257 
2258     def __sizeof__(self): # real signature unknown; restored from __doc__
2259         """ S.__sizeof__() -&gt; size of S in memory, in bytes """
2260         pass
2261 
2262     def __str__(self): # real signature unknown; restored from __doc__
2263         """ x.__str__() &lt;==&gt; str(x) """
2264         pass
2265 
2266 
2267 bytes = str
2268 
2269 
2270 class classmethod(object):
2271     """
2272     classmethod(function) -&gt; method
2273     
2274     Convert a function to be a class method.
2275     
2276     A class method receives the class as implicit first argument,
2277     just like an instance method receives the instance.
2278     To declare a class method, use this idiom:
2279     
2280       class C:
2281           @classmethod
2282           def f(cls, arg1, arg2, ...):
2283               ...
2284     
2285     It can be called either on the class (e.g. C.f()) or on an instance
2286     (e.g. C().f()).  The instance is ignored except for its class.
2287     If a class method is called for a derived class, the derived class
2288     object is passed as the implied first argument.
2289     
2290     Class methods are different than C++ or Java static methods.
2291     If you want those, see the staticmethod builtin.
2292     """
2293     def __getattribute__(self, name): # real signature unknown; restored from __doc__
2294         """ x.__getattribute__('name') &lt;==&gt; x.name """
2295         pass
2296 
2297     def __get__(self, obj, type=None): # real signature unknown; restored from __doc__
2298         """ descr.__get__(obj[, type]) -&gt; value """
2299         pass
2300 
2301     def __init__(self, function): # real signature unknown; restored from __doc__
2302         pass
2303 
2304     @staticmethod # known case of __new__
2305     def __new__(S, *more): # real signature unknown; restored from __doc__
2306         """ T.__new__(S, ...) -&gt; a new object with type S, a subtype of T """
2307         pass
2308 
2309     __func__ = property(lambda self: object(), lambda self, v: None, lambda self: None)  # default
2310 
2311 
2312 
2313 class complex(object):
2314     """
2315     complex(real[, imag]) -&gt; complex number
2316     
2317     Create a complex number from a real part and an optional imaginary part.
2318     This is equivalent to (real + imag*1j) where imag defaults to 0.
2319     """
2320     def conjugate(self): # real signature unknown; restored from __doc__
2321         """
2322         complex.conjugate() -&gt; complex
2323         
2324         Return the complex conjugate of its argument. (3-4j).conjugate() == 3+4j.
2325         """
2326         return complex
2327 
2328     def __abs__(self): # real signature unknown; restored from __doc__
2329         """ x.__abs__() &lt;==&gt; abs(x) """
2330         pass
2331 
2332     def __add__(self, y): # real signature unknown; restored from __doc__
2333         """ x.__add__(y) &lt;==&gt; x+y """
2334         pass
2335 
2336     def __coerce__(self, y): # real signature unknown; restored from __doc__
2337         """ x.__coerce__(y) &lt;==&gt; coerce(x, y) """
2338         pass
2339 
2340     def __divmod__(self, y): # real signature unknown; restored from __doc__
2341         """ x.__divmod__(y) &lt;==&gt; divmod(x, y) """
2342         pass
2343 
2344     def __div__(self, y): # real signature unknown; restored from __doc__
2345         """ x.__div__(y) &lt;==&gt; x/y """
2346         pass
2347 
2348     def __eq__(self, y): # real signature unknown; restored from __doc__
2349         """ x.__eq__(y) &lt;==&gt; x==y """
2350         pass
2351 
2352     def __float__(self): # real signature unknown; restored from __doc__
2353         """ x.__float__() &lt;==&gt; float(x) """
2354         pass
2355 
2356     def __floordiv__(self, y): # real signature unknown; restored from __doc__
2357         """ x.__floordiv__(y) &lt;==&gt; x//y """
2358         pass
2359 
2360     def __format__(self): # real signature unknown; restored from __doc__
2361         """
2362         complex.__format__() -&gt; str
2363         
2364         Convert to a string according to format_spec.
2365         """
2366         return ""
2367 
2368     def __getattribute__(self, name): # real signature unknown; restored from __doc__
2369         """ x.__getattribute__('name') &lt;==&gt; x.name """
2370         pass
2371 
2372     def __getnewargs__(self, *args, **kwargs): # real signature unknown
2373         pass
2374 
2375     def __ge__(self, y): # real signature unknown; restored from __doc__
2376         """ x.__ge__(y) &lt;==&gt; x&gt;=y """
2377         pass
2378 
2379     def __gt__(self, y): # real signature unknown; restored from __doc__
2380         """ x.__gt__(y) &lt;==&gt; x&gt;y """
2381         pass
2382 
2383     def __hash__(self): # real signature unknown; restored from __doc__
2384         """ x.__hash__() &lt;==&gt; hash(x) """
2385         pass
2386 
2387     def __init__(self, real, imag=None): # real signature unknown; restored from __doc__
2388         pass
2389 
2390     def __int__(self): # real signature unknown; restored from __doc__
2391         """ x.__int__() &lt;==&gt; int(x) """
2392         pass
2393 
2394     def __le__(self, y): # real signature unknown; restored from __doc__
2395         """ x.__le__(y) &lt;==&gt; x&lt;=y """
2396         pass
2397 
2398     def __long__(self): # real signature unknown; restored from __doc__
2399         """ x.__long__() &lt;==&gt; long(x) """
2400         pass
2401 
2402     def __lt__(self, y): # real signature unknown; restored from __doc__
2403         """ x.__lt__(y) &lt;==&gt; x&lt;y """
2404         pass
2405 
2406     def __mod__(self, y): # real signature unknown; restored from __doc__
2407         """ x.__mod__(y) &lt;==&gt; x%y """
2408         pass
2409 
2410     def __mul__(self, y): # real signature unknown; restored from __doc__
2411         """ x.__mul__(y) &lt;==&gt; x*y """
2412         pass
2413 
2414     def __neg__(self): # real signature unknown; restored from __doc__
2415         """ x.__neg__() &lt;==&gt; -x """
2416         pass
2417 
2418     @staticmethod # known case of __new__
2419     def __new__(S, *more): # real signature unknown; restored from __doc__
2420         """ T.__new__(S, ...) -&gt; a new object with type S, a subtype of T """
2421         pass
2422 
2423     def __ne__(self, y): # real signature unknown; restored from __doc__
2424         """ x.__ne__(y) &lt;==&gt; x!=y """
2425         pass
2426 
2427     def __nonzero__(self): # real signature unknown; restored from __doc__
2428         """ x.__nonzero__() &lt;==&gt; x != 0 """
2429         pass
2430 
2431     def __pos__(self): # real signature unknown; restored from __doc__
2432         """ x.__pos__() &lt;==&gt; +x """
2433         pass
2434 
2435     def __pow__(self, y, z=None): # real signature unknown; restored from __doc__
2436         """ x.__pow__(y[, z]) &lt;==&gt; pow(x, y[, z]) """
2437         pass
2438 
2439     def __radd__(self, y): # real signature unknown; restored from __doc__
2440         """ x.__radd__(y) &lt;==&gt; y+x """
2441         pass
2442 
2443     def __rdivmod__(self, y): # real signature unknown; restored from __doc__
2444         """ x.__rdivmod__(y) &lt;==&gt; divmod(y, x) """
2445         pass
2446 
2447     def __rdiv__(self, y): # real signature unknown; restored from __doc__
2448         """ x.__rdiv__(y) &lt;==&gt; y/x """
2449         pass
2450 
2451     def __repr__(self): # real signature unknown; restored from __doc__
2452         """ x.__repr__() &lt;==&gt; repr(x) """
2453         pass
2454 
2455     def __rfloordiv__(self, y): # real signature unknown; restored from __doc__
2456         """ x.__rfloordiv__(y) &lt;==&gt; y//x """
2457         pass
2458 
2459     def __rmod__(self, y): # real signature unknown; restored from __doc__
2460         """ x.__rmod__(y) &lt;==&gt; y%x """
2461         pass
2462 
2463     def __rmul__(self, y): # real signature unknown; restored from __doc__
2464         """ x.__rmul__(y) &lt;==&gt; y*x """
2465         pass
2466 
2467     def __rpow__(self, x, z=None): # real signature unknown; restored from __doc__
2468         """ y.__rpow__(x[, z]) &lt;==&gt; pow(x, y[, z]) """
2469         pass
2470 
2471     def __rsub__(self, y): # real signature unknown; restored from __doc__
2472         """ x.__rsub__(y) &lt;==&gt; y-x """
2473         pass
2474 
2475     def __rtruediv__(self, y): # real signature unknown; restored from __doc__
2476         """ x.__rtruediv__(y) &lt;==&gt; y/x """
2477         pass
2478 
2479     def __str__(self): # real signature unknown; restored from __doc__
2480         """ x.__str__() &lt;==&gt; str(x) """
2481         pass
2482 
2483     def __sub__(self, y): # real signature unknown; restored from __doc__
2484         """ x.__sub__(y) &lt;==&gt; x-y """
2485         pass
2486 
2487     def __truediv__(self, y): # real signature unknown; restored from __doc__
2488         """ x.__truediv__(y) &lt;==&gt; x/y """
2489         pass
2490 
2491     imag = property(lambda self: 0.0)
2492     """the imaginary part of a complex number
2493 
2494     :type: float
2495     """
2496 
2497     real = property(lambda self: 0.0)
2498     """the real part of a complex number
2499 
2500     :type: float
2501     """
2502 
2503 
2504 
2505 class dict(object):
2506     """
2507     dict() -&gt; new empty dictionary
2508     dict(mapping) -&gt; new dictionary initialized from a mapping object's
2509         (key, value) pairs
2510     dict(iterable) -&gt; new dictionary initialized as if via:
2511         d = {}
2512         for k, v in iterable:
2513             d[k] = v
2514     dict(**kwargs) -&gt; new dictionary initialized with the name=value pairs
2515         in the keyword argument list.  For example:  dict(one=1, two=2)
2516     """
2517     def clear(self): # real signature unknown; restored from __doc__
2518         """ D.clear() -&gt; None.  Remove all items from D. """
2519         pass
2520 
2521     def copy(self): # real signature unknown; restored from __doc__
2522         """ D.copy() -&gt; a shallow copy of D """
2523         pass
2524 
2525     @staticmethod # known case
2526     def fromkeys(S, v=None): # real signature unknown; restored from __doc__
2527         """
2528         dict.fromkeys(S[,v]) -&gt; New dict with keys from S and values equal to v.
2529         v defaults to None.
2530         """
2531         pass
2532 
2533     def get(self, k, d=None): # real signature unknown; restored from __doc__
2534         """ D.get(k[,d]) -&gt; D[k] if k in D, else d.  d defaults to None. """
2535         pass
2536 
2537     def has_key(self, k): # real signature unknown; restored from __doc__
2538         """ D.has_key(k) -&gt; True if D has a key k, else False """
2539         return False
2540 
2541     def items(self): # real signature unknown; restored from __doc__
2542         """ D.items() -&gt; list of D's (key, value) pairs, as 2-tuples """
2543         return []
2544 
2545     def iteritems(self): # real signature unknown; restored from __doc__
2546         """ D.iteritems() -&gt; an iterator over the (key, value) items of D """
2547         pass
2548 
2549     def iterkeys(self): # real signature unknown; restored from __doc__
2550         """ D.iterkeys() -&gt; an iterator over the keys of D """
2551         pass
2552 
2553     def itervalues(self): # real signature unknown; restored from __doc__
2554         """ D.itervalues() -&gt; an iterator over the values of D """
2555         pass
2556 
2557     def keys(self): # real signature unknown; restored from __doc__
2558         """ D.keys() -&gt; list of D's keys """
2559         return []
2560 
2561     def pop(self, k, d=None): # real signature unknown; restored from __doc__
2562         """
2563         D.pop(k[,d]) -&gt; v, remove specified key and return the corresponding value.
2564         If key is not found, d is returned if given, otherwise KeyError is raised
2565         """
2566         pass
2567 
2568     def popitem(self): # real signature unknown; restored from __doc__
2569         """
2570         D.popitem() -&gt; (k, v), remove and return some (key, value) pair as a
2571         2-tuple; but raise KeyError if D is empty.
2572         """
2573         pass
2574 
2575     def setdefault(self, k, d=None): # real signature unknown; restored from __doc__
2576         """ D.setdefault(k[,d]) -&gt; D.get(k,d), also set D[k]=d if k not in D """
2577         pass
2578 
2579     def update(self, E=None, **F): # known special case of dict.update
2580         """
2581         D.update([E, ]**F) -&gt; None.  Update D from dict/iterable E and F.
2582         If E present and has a .keys() method, does:     for k in E: D[k] = E[k]
2583         If E present and lacks .keys() method, does:     for (k, v) in E: D[k] = v
2584         In either case, this is followed by: for k in F: D[k] = F[k]
2585         """
2586         pass
2587 
2588     def values(self): # real signature unknown; restored from __doc__
2589         """ D.values() -&gt; list of D's values """
2590         return []
2591 
2592     def viewitems(self): # real signature unknown; restored from __doc__
2593         """ D.viewitems() -&gt; a set-like object providing a view on D's items """
2594         pass
2595 
2596     def viewkeys(self): # real signature unknown; restored from __doc__
2597         """ D.viewkeys() -&gt; a set-like object providing a view on D's keys """
2598         pass
2599 
2600     def viewvalues(self): # real signature unknown; restored from __doc__
2601         """ D.viewvalues() -&gt; an object providing a view on D's values """
2602         pass
2603 
2604     def __cmp__(self, y): # real signature unknown; restored from __doc__
2605         """ x.__cmp__(y) &lt;==&gt; cmp(x,y) """
2606         pass
2607 
2608     def __contains__(self, k): # real signature unknown; restored from __doc__
2609         """ D.__contains__(k) -&gt; True if D has a key k, else False """
2610         return False
2611 
2612     def __delitem__(self, y): # real signature unknown; restored from __doc__
2613         """ x.__delitem__(y) &lt;==&gt; del x[y] """
2614         pass
2615 
2616     def __eq__(self, y): # real signature unknown; restored from __doc__
2617         """ x.__eq__(y) &lt;==&gt; x==y """
2618         pass
2619 
2620     def __getattribute__(self, name): # real signature unknown; restored from __doc__
2621         """ x.__getattribute__('name') &lt;==&gt; x.name """
2622         pass
2623 
2624     def __getitem__(self, y): # real signature unknown; restored from __doc__
2625         """ x.__getitem__(y) &lt;==&gt; x[y] """
2626         pass
2627 
2628     def __ge__(self, y): # real signature unknown; restored from __doc__
2629         """ x.__ge__(y) &lt;==&gt; x&gt;=y """
2630         pass
2631 
2632     def __gt__(self, y): # real signature unknown; restored from __doc__
2633         """ x.__gt__(y) &lt;==&gt; x&gt;y """
2634         pass
2635 
2636     def __init__(self, seq=None, **kwargs): # known special case of dict.__init__
2637         """
2638         dict() -&gt; new empty dictionary
2639         dict(mapping) -&gt; new dictionary initialized from a mapping object's
2640             (key, value) pairs
2641         dict(iterable) -&gt; new dictionary initialized as if via:
2642             d = {}
2643             for k, v in iterable:
2644                 d[k] = v
2645         dict(**kwargs) -&gt; new dictionary initialized with the name=value pairs
2646             in the keyword argument list.  For example:  dict(one=1, two=2)
2647         # (copied from class doc)
2648         """
2649         pass
2650 
2651     def __iter__(self): # real signature unknown; restored from __doc__
2652         """ x.__iter__() &lt;==&gt; iter(x) """
2653         pass
2654 
2655     def __len__(self): # real signature unknown; restored from __doc__
2656         """ x.__len__() &lt;==&gt; len(x) """
2657         pass
2658 
2659     def __le__(self, y): # real signature unknown; restored from __doc__
2660         """ x.__le__(y) &lt;==&gt; x&lt;=y """
2661         pass
2662 
2663     def __lt__(self, y): # real signature unknown; restored from __doc__
2664         """ x.__lt__(y) &lt;==&gt; x&lt;y """
2665         pass
2666 
2667     @staticmethod # known case of __new__
2668     def __new__(S, *more): # real signature unknown; restored from __doc__
2669         """ T.__new__(S, ...) -&gt; a new object with type S, a subtype of T """
2670         pass
2671 
2672     def __ne__(self, y): # real signature unknown; restored from __doc__
2673         """ x.__ne__(y) &lt;==&gt; x!=y """
2674         pass
2675 
2676     def __repr__(self): # real signature unknown; restored from __doc__
2677         """ x.__repr__() &lt;==&gt; repr(x) """
2678         pass
2679 
2680     def __setitem__(self, i, y): # real signature unknown; restored from __doc__
2681         """ x.__setitem__(i, y) &lt;==&gt; x[i]=y """
2682         pass
2683 
2684     def __sizeof__(self): # real signature unknown; restored from __doc__
2685         """ D.__sizeof__() -&gt; size of D in memory, in bytes """
2686         pass
2687 
2688     __hash__ = None
2689 
2690 
2691 class enumerate(object):
2692     """
2693     enumerate(iterable[, start]) -&gt; iterator for index, value of iterable
2694     
2695     Return an enumerate object.  iterable must be another object that supports
2696     iteration.  The enumerate object yields pairs containing a count (from
2697     start, which defaults to zero) and a value yielded by the iterable argument.
2698     enumerate is useful for obtaining an indexed list:
2699         (0, seq[0]), (1, seq[1]), (2, seq[2]), ...
2700     """
2701     def next(self): # real signature unknown; restored from __doc__
2702         """ x.next() -&gt; the next value, or raise StopIteration """
2703         pass
2704 
2705     def __getattribute__(self, name): # real signature unknown; restored from __doc__
2706         """ x.__getattribute__('name') &lt;==&gt; x.name """
2707         pass
2708 
2709     def __init__(self, iterable, start=0): # known special case of enumerate.__init__
2710         """ x.__init__(...) initializes x; see help(type(x)) for signature """
2711         pass
2712 
2713     def __iter__(self): # real signature unknown; restored from __doc__
2714         """ x.__iter__() &lt;==&gt; iter(x) """
2715         pass
2716 
2717     @staticmethod # known case of __new__
2718     def __new__(S, *more): # real signature unknown; restored from __doc__
2719         """ T.__new__(S, ...) -&gt; a new object with type S, a subtype of T """
2720         pass
2721 
2722 
2723 class file(object):
2724     """
2725     file(name[, mode[, buffering]]) -&gt; file object
2726     
2727     Open a file.  The mode can be 'r', 'w' or 'a' for reading (default),
2728     writing or appending.  The file will be created if it doesn't exist
2729     when opened for writing or appending; it will be truncated when
2730     opened for writing.  Add a 'b' to the mode for binary files.
2731     Add a '+' to the mode to allow simultaneous reading and writing.
2732     If the buffering argument is given, 0 means unbuffered, 1 means line
2733     buffered, and larger numbers specify the buffer size.  The preferred way
2734     to open a file is with the builtin open() function.
2735     Add a 'U' to mode to open the file for input with universal newline
2736     support.  Any line ending in the input file will be seen as a '\n'
2737     in Python.  Also, a file so opened gains the attribute 'newlines';
2738     the value for this attribute is one of None (no newline read yet),
2739     '\r', '\n', '\r\n' or a tuple containing all the newline types seen.
2740     
2741     'U' cannot be combined with 'w' or '+' mode.
2742     """
2743     def close(self): # real signature unknown; restored from __doc__
2744         """
2745         close() -&gt; None or (perhaps) an integer.  Close the file.
2746         
2747         Sets data attribute .closed to True.  A closed file cannot be used for
2748         further I/O operations.  close() may be called more than once without
2749         error.  Some kinds of file objects (for example, opened by popen())
2750         may return an exit status upon closing.
2751         """
2752         pass
2753 
2754     def fileno(self): # real signature unknown; restored from __doc__
2755         """
2756         fileno() -&gt; integer "file descriptor".
2757         
2758         This is needed for lower-level file interfaces, such os.read().
2759         """
2760         return 0
2761 
2762     def flush(self): # real signature unknown; restored from __doc__
2763         """ flush() -&gt; None.  Flush the internal I/O buffer. """
2764         pass
2765 
2766     def isatty(self): # real signature unknown; restored from __doc__
2767         """ isatty() -&gt; true or false.  True if the file is connected to a tty device. """
2768         return False
2769 
2770     def next(self): # real signature unknown; restored from __doc__
2771         """ x.next() -&gt; the next value, or raise StopIteration """
2772         pass
2773 
2774     def read(self, size=None): # real signature unknown; restored from __doc__
2775         """
2776         read([size]) -&gt; read at most size bytes, returned as a string.
2777         
2778         If the size argument is negative or omitted, read until EOF is reached.
2779         Notice that when in non-blocking mode, less data than what was requested
2780         may be returned, even if no size parameter was given.
2781         """
2782         pass
2783 
2784     def readinto(self): # real signature unknown; restored from __doc__
2785         """ readinto() -&gt; Undocumented.  Don't use this; it may go away. """
2786         pass
2787 
2788     def readline(self, size=None): # real signature unknown; restored from __doc__
2789         """
2790         readline([size]) -&gt; next line from the file, as a string.
2791         
2792         Retain newline.  A non-negative size argument limits the maximum
2793         number of bytes to return (an incomplete line may be returned then).
2794         Return an empty string at EOF.
2795         """
2796         pass
2797 
2798     def readlines(self, size=None): # real signature unknown; restored from __doc__
2799         """
2800         readlines([size]) -&gt; list of strings, each a line from the file.
2801         
2802         Call readline() repeatedly and return a list of the lines so read.
2803         The optional size argument, if given, is an approximate bound on the
2804         total number of bytes in the lines returned.
2805         """
2806         return []
2807 
2808     def seek(self, offset, whence=None): # real signature unknown; restored from __doc__
2809         """
2810         seek(offset[, whence]) -&gt; None.  Move to new file position.
2811         
2812         Argument offset is a byte count.  Optional argument whence defaults to
2813         0 (offset from start of file, offset should be &gt;= 0); other values are 1
2814         (move relative to current position, positive or negative), and 2 (move
2815         relative to end of file, usually negative, although many platforms allow
2816         seeking beyond the end of a file).  If the file is opened in text mode,
2817         only offsets returned by tell() are legal.  Use of other offsets causes
2818         undefined behavior.
2819         Note that not all file objects are seekable.
2820         """
2821         pass
2822 
2823     def tell(self): # real signature unknown; restored from __doc__
2824         """ tell() -&gt; current file position, an integer (may be a long integer). """
2825         pass
2826 
2827     def truncate(self, size=None): # real signature unknown; restored from __doc__
2828         """
2829         truncate([size]) -&gt; None.  Truncate the file to at most size bytes.
2830         
2831         Size defaults to the current file position, as returned by tell().
2832         """
2833         pass
2834 
2835     def write(self, p_str): # real signature unknown; restored from __doc__
2836         """
2837         write(str) -&gt; None.  Write string str to file.
2838         
2839         Note that due to buffering, flush() or close() may be needed before
2840         the file on disk reflects the data written.
2841         """
2842         pass
2843 
2844     def writelines(self, sequence_of_strings): # real signature unknown; restored from __doc__
2845         """
2846         writelines(sequence_of_strings) -&gt; None.  Write the strings to the file.
2847         
2848         Note that newlines are not added.  The sequence can be any iterable object
2849         producing strings. This is equivalent to calling write() for each string.
2850         """
2851         pass
2852 
2853     def xreadlines(self): # real signature unknown; restored from __doc__
2854         """
2855         xreadlines() -&gt; returns self.
2856         
2857         For backward compatibility. File objects now include the performance
2858         optimizations previously implemented in the xreadlines module.
2859         """
2860         pass
2861 
2862     def __delattr__(self, name): # real signature unknown; restored from __doc__
2863         """ x.__delattr__('name') &lt;==&gt; del x.name """
2864         pass
2865 
2866     def __enter__(self): # real signature unknown; restored from __doc__
2867         """ __enter__() -&gt; self. """
2868         return self
2869 
2870     def __exit__(self, *excinfo): # real signature unknown; restored from __doc__
2871         """ __exit__(*excinfo) -&gt; None.  Closes the file. """
2872         pass
2873 
2874     def __getattribute__(self, name): # real signature unknown; restored from __doc__
2875         """ x.__getattribute__('name') &lt;==&gt; x.name """
2876         pass
2877 
2878     def __init__(self, name, mode=None, buffering=None): # real signature unknown; restored from __doc__
2879         pass
2880 
2881     def __iter__(self): # real signature unknown; restored from __doc__
2882         """ x.__iter__() &lt;==&gt; iter(x) """
2883         pass
2884 
2885     @staticmethod # known case of __new__
2886     def __new__(S, *more): # real signature unknown; restored from __doc__
2887         """ T.__new__(S, ...) -&gt; a new object with type S, a subtype of T """
2888         pass
2889 
2890     def __repr__(self): # real signature unknown; restored from __doc__
2891         """ x.__repr__() &lt;==&gt; repr(x) """
2892         pass
2893 
2894     def __setattr__(self, name, value): # real signature unknown; restored from __doc__
2895         """ x.__setattr__('name', value) &lt;==&gt; x.name = value """
2896         pass
2897 
2898     closed = property(lambda self: True)
2899     """True if the file is closed
2900 
2901     :type: bool
2902     """
2903 
2904     encoding = property(lambda self: '')
2905     """file encoding
2906 
2907     :type: string
2908     """
2909 
2910     errors = property(lambda self: object(), lambda self, v: None, lambda self: None)  # default
2911     """Unicode error handler"""
2912 
2913     mode = property(lambda self: '')
2914     """file mode ('r', 'U', 'w', 'a', possibly with 'b' or '+' added)
2915 
2916     :type: string
2917     """
2918 
2919     name = property(lambda self: '')
2920     """file name
2921 
2922     :type: string
2923     """
2924 
2925     newlines = property(lambda self: '')
2926     """end-of-line convention used in this file
2927 
2928     :type: string
2929     """
2930 
2931     softspace = property(lambda self: True)
2932     """flag indicating that a space needs to be printed; used by print
2933 
2934     :type: bool
2935     """
2936 
2937 
2938 
2939 class float(object):
2940     """
2941     float(x) -&gt; floating point number
2942     
2943     Convert a string or number to a floating point number, if possible.
2944     """
2945     def as_integer_ratio(self): # real signature unknown; restored from __doc__
2946         """
2947         float.as_integer_ratio() -&gt; (int, int)
2948         
2949         Return a pair of integers, whose ratio is exactly equal to the original
2950         float and with a positive denominator.
2951         Raise OverflowError on infinities and a ValueError on NaNs.
2952         
2953         &gt;&gt;&gt; (10.0).as_integer_ratio()
2954         (10, 1)
2955         &gt;&gt;&gt; (0.0).as_integer_ratio()
2956         (0, 1)
2957         &gt;&gt;&gt; (-.25).as_integer_ratio()
2958         (-1, 4)
2959         """
2960         pass
2961 
2962     def conjugate(self, *args, **kwargs): # real signature unknown
2963         """ Return self, the complex conjugate of any float. """
2964         pass
2965 
2966     @staticmethod # known case
2967     def fromhex(string): # real signature unknown; restored from __doc__
2968         """
2969         float.fromhex(string) -&gt; float
2970         
2971         Create a floating-point number from a hexadecimal string.
2972         &gt;&gt;&gt; float.fromhex('0x1.ffffp10')
2973         2047.984375
2974         &gt;&gt;&gt; float.fromhex('-0x1p-1074')
2975         -4.9406564584124654e-324
2976         """
2977         return 0.0
2978 
2979     def hex(self): # real signature unknown; restored from __doc__
2980         """
2981         float.hex() -&gt; string
2982         
2983         Return a hexadecimal representation of a floating-point number.
2984         &gt;&gt;&gt; (-0.1).hex()
2985         '-0x1.999999999999ap-4'
2986         &gt;&gt;&gt; 3.14159.hex()
2987         '0x1.921f9f01b866ep+1'
2988         """
2989         return ""
2990 
2991     def is_integer(self, *args, **kwargs): # real signature unknown
2992         """ Return True if the float is an integer. """
2993         pass
2994 
2995     def __abs__(self): # real signature unknown; restored from __doc__
2996         """ x.__abs__() &lt;==&gt; abs(x) """
2997         pass
2998 
2999     def __add__(self, y): # real signature unknown; restored from __doc__
3000         """ x.__add__(y) &lt;==&gt; x+y """
3001         pass
3002 
3003     def __coerce__(self, y): # real signature unknown; restored from __doc__
3004         """ x.__coerce__(y) &lt;==&gt; coerce(x, y) """
3005         pass
3006 
3007     def __divmod__(self, y): # real signature unknown; restored from __doc__
3008         """ x.__divmod__(y) &lt;==&gt; divmod(x, y) """
3009         pass
3010 
3011     def __div__(self, y): # real signature unknown; restored from __doc__
3012         """ x.__div__(y) &lt;==&gt; x/y """
3013         pass
3014 
3015     def __eq__(self, y): # real signature unknown; restored from __doc__
3016         """ x.__eq__(y) &lt;==&gt; x==y """
3017         pass
3018 
3019     def __float__(self): # real signature unknown; restored from __doc__
3020         """ x.__float__() &lt;==&gt; float(x) """
3021         pass
3022 
3023     def __floordiv__(self, y): # real signature unknown; restored from __doc__
3024         """ x.__floordiv__(y) &lt;==&gt; x//y """
3025         pass
3026 
3027     def __format__(self, format_spec): # real signature unknown; restored from __doc__
3028         """
3029         float.__format__(format_spec) -&gt; string
3030         
3031         Formats the float according to format_spec.
3032         """
3033         return ""
3034 
3035     def __getattribute__(self, name): # real signature unknown; restored from __doc__
3036         """ x.__getattribute__('name') &lt;==&gt; x.name """
3037         pass
3038 
3039     def __getformat__(self, typestr): # real signature unknown; restored from __doc__
3040         """
3041         float.__getformat__(typestr) -&gt; string
3042         
3043         You probably don't want to use this function.  It exists mainly to be
3044         used in Python's test suite.
3045         
3046         typestr must be 'double' or 'float'.  This function returns whichever of
3047         'unknown', 'IEEE, big-endian' or 'IEEE, little-endian' best describes the
3048         format of floating point numbers used by the C type named by typestr.
3049         """
3050         return ""
3051 
3052     def __getnewargs__(self, *args, **kwargs): # real signature unknown
3053         pass
3054 
3055     def __ge__(self, y): # real signature unknown; restored from __doc__
3056         """ x.__ge__(y) &lt;==&gt; x&gt;=y """
3057         pass
3058 
3059     def __gt__(self, y): # real signature unknown; restored from __doc__
3060         """ x.__gt__(y) &lt;==&gt; x&gt;y """
3061         pass
3062 
3063     def __hash__(self): # real signature unknown; restored from __doc__
3064         """ x.__hash__() &lt;==&gt; hash(x) """
3065         pass
3066 
3067     def __init__(self, x): # real signature unknown; restored from __doc__
3068         pass
3069 
3070     def __int__(self): # real signature unknown; restored from __doc__
3071         """ x.__int__() &lt;==&gt; int(x) """
3072         pass
3073 
3074     def __le__(self, y): # real signature unknown; restored from __doc__
3075         """ x.__le__(y) &lt;==&gt; x&lt;=y """
3076         pass
3077 
3078     def __long__(self): # real signature unknown; restored from __doc__
3079         """ x.__long__() &lt;==&gt; long(x) """
3080         pass
3081 
3082     def __lt__(self, y): # real signature unknown; restored from __doc__
3083         """ x.__lt__(y) &lt;==&gt; x&lt;y """
3084         pass
3085 
3086     def __mod__(self, y): # real signature unknown; restored from __doc__
3087         """ x.__mod__(y) &lt;==&gt; x%y """
3088         pass
3089 
3090     def __mul__(self, y): # real signature unknown; restored from __doc__
3091         """ x.__mul__(y) &lt;==&gt; x*y """
3092         pass
3093 
3094     def __neg__(self): # real signature unknown; restored from __doc__
3095         """ x.__neg__() &lt;==&gt; -x """
3096         pass
3097 
3098     @staticmethod # known case of __new__
3099     def __new__(S, *more): # real signature unknown; restored from __doc__
3100         """ T.__new__(S, ...) -&gt; a new object with type S, a subtype of T """
3101         pass
3102 
3103     def __ne__(self, y): # real signature unknown; restored from __doc__
3104         """ x.__ne__(y) &lt;==&gt; x!=y """
3105         pass
3106 
3107     def __nonzero__(self): # real signature unknown; restored from __doc__
3108         """ x.__nonzero__() &lt;==&gt; x != 0 """
3109         pass
3110 
3111     def __pos__(self): # real signature unknown; restored from __doc__
3112         """ x.__pos__() &lt;==&gt; +x """
3113         pass
3114 
3115     def __pow__(self, y, z=None): # real signature unknown; restored from __doc__
3116         """ x.__pow__(y[, z]) &lt;==&gt; pow(x, y[, z]) """
3117         pass
3118 
3119     def __radd__(self, y): # real signature unknown; restored from __doc__
3120         """ x.__radd__(y) &lt;==&gt; y+x """
3121         pass
3122 
3123     def __rdivmod__(self, y): # real signature unknown; restored from __doc__
3124         """ x.__rdivmod__(y) &lt;==&gt; divmod(y, x) """
3125         pass
3126 
3127     def __rdiv__(self, y): # real signature unknown; restored from __doc__
3128         """ x.__rdiv__(y) &lt;==&gt; y/x """
3129         pass
3130 
3131     def __repr__(self): # real signature unknown; restored from __doc__
3132         """ x.__repr__() &lt;==&gt; repr(x) """
3133         pass
3134 
3135     def __rfloordiv__(self, y): # real signature unknown; restored from __doc__
3136         """ x.__rfloordiv__(y) &lt;==&gt; y//x """
3137         pass
3138 
3139     def __rmod__(self, y): # real signature unknown; restored from __doc__
3140         """ x.__rmod__(y) &lt;==&gt; y%x """
3141         pass
3142 
3143     def __rmul__(self, y): # real signature unknown; restored from __doc__
3144         """ x.__rmul__(y) &lt;==&gt; y*x """
3145         pass
3146 
3147     def __rpow__(self, x, z=None): # real signature unknown; restored from __doc__
3148         """ y.__rpow__(x[, z]) &lt;==&gt; pow(x, y[, z]) """
3149         pass
3150 
3151     def __rsub__(self, y): # real signature unknown; restored from __doc__
3152         """ x.__rsub__(y) &lt;==&gt; y-x """
3153         pass
3154 
3155     def __rtruediv__(self, y): # real signature unknown; restored from __doc__
3156         """ x.__rtruediv__(y) &lt;==&gt; y/x """
3157         pass
3158 
3159     def __setformat__(self, typestr, fmt): # real signature unknown; restored from __doc__
3160         """
3161         float.__setformat__(typestr, fmt) -&gt; None
3162         
3163         You probably don't want to use this function.  It exists mainly to be
3164         used in Python's test suite.
3165         
3166         typestr must be 'double' or 'float'.  fmt must be one of 'unknown',
3167         'IEEE, big-endian' or 'IEEE, little-endian', and in addition can only be
3168         one of the latter two if it appears to match the underlying C reality.
3169         
3170         Override the automatic determination of C-level floating point type.
3171         This affects how floats are converted to and from binary strings.
3172         """
3173         pass
3174 
3175     def __str__(self): # real signature unknown; restored from __doc__
3176         """ x.__str__() &lt;==&gt; str(x) """
3177         pass
3178 
3179     def __sub__(self, y): # real signature unknown; restored from __doc__
3180         """ x.__sub__(y) &lt;==&gt; x-y """
3181         pass
3182 
3183     def __truediv__(self, y): # real signature unknown; restored from __doc__
3184         """ x.__truediv__(y) &lt;==&gt; x/y """
3185         pass
3186 
3187     def __trunc__(self, *args, **kwargs): # real signature unknown
3188         """ Return the Integral closest to x between 0 and x. """
3189         pass
3190 
3191     imag = property(lambda self: object(), lambda self, v: None, lambda self: None)  # default
3192     """the imaginary part of a complex number"""
3193 
3194     real = property(lambda self: object(), lambda self, v: None, lambda self: None)  # default
3195     """the real part of a complex number"""
3196 
3197 
3198 
3199 class frozenset(object):
3200     """
3201     frozenset() -&gt; empty frozenset object
3202     frozenset(iterable) -&gt; frozenset object
3203     
3204     Build an immutable unordered collection of unique elements.
3205     """
3206     def copy(self, *args, **kwargs): # real signature unknown
3207         """ Return a shallow copy of a set. """
3208         pass
3209 
3210     def difference(self, *args, **kwargs): # real signature unknown
3211         """
3212         Return the difference of two or more sets as a new set.
3213         
3214         (i.e. all elements that are in this set but not the others.)
3215         """
3216         pass
3217 
3218     def intersection(self, *args, **kwargs): # real signature unknown
3219         """
3220         Return the intersection of two or more sets as a new set.
3221         
3222         (i.e. elements that are common to all of the sets.)
3223         """
3224         pass
3225 
3226     def isdisjoint(self, *args, **kwargs): # real signature unknown
3227         """ Return True if two sets have a null intersection. """
3228         pass
3229 
3230     def issubset(self, *args, **kwargs): # real signature unknown
3231         """ Report whether another set contains this set. """
3232         pass
3233 
3234     def issuperset(self, *args, **kwargs): # real signature unknown
3235         """ Report whether this set contains another set. """
3236         pass
3237 
3238     def symmetric_difference(self, *args, **kwargs): # real signature unknown
3239         """
3240         Return the symmetric difference of two sets as a new set.
3241         
3242         (i.e. all elements that are in exactly one of the sets.)
3243         """
3244         pass
3245 
3246     def union(self, *args, **kwargs): # real signature unknown
3247         """
3248         Return the union of sets as a new set.
3249         
3250         (i.e. all elements that are in either set.)
3251         """
3252         pass
3253 
3254     def __and__(self, y): # real signature unknown; restored from __doc__
3255         """ x.__and__(y) &lt;==&gt; x&amp;y """
3256         pass
3257 
3258     def __cmp__(self, y): # real signature unknown; restored from __doc__
3259         """ x.__cmp__(y) &lt;==&gt; cmp(x,y) """
3260         pass
3261 
3262     def __contains__(self, y): # real signature unknown; restored from __doc__
3263         """ x.__contains__(y) &lt;==&gt; y in x. """
3264         pass
3265 
3266     def __eq__(self, y): # real signature unknown; restored from __doc__
3267         """ x.__eq__(y) &lt;==&gt; x==y """
3268         pass
3269 
3270     def __getattribute__(self, name): # real signature unknown; restored from __doc__
3271         """ x.__getattribute__('name') &lt;==&gt; x.name """
3272         pass
3273 
3274     def __ge__(self, y): # real signature unknown; restored from __doc__
3275         """ x.__ge__(y) &lt;==&gt; x&gt;=y """
3276         pass
3277 
3278     def __gt__(self, y): # real signature unknown; restored from __doc__
3279         """ x.__gt__(y) &lt;==&gt; x&gt;y """
3280         pass
3281 
3282     def __hash__(self): # real signature unknown; restored from __doc__
3283         """ x.__hash__() &lt;==&gt; hash(x) """
3284         pass
3285 
3286     def __init__(self, seq=()): # known special case of frozenset.__init__
3287         """ x.__init__(...) initializes x; see help(type(x)) for signature """
3288         pass
3289 
3290     def __iter__(self): # real signature unknown; restored from __doc__
3291         """ x.__iter__() &lt;==&gt; iter(x) """
3292         pass
3293 
3294     def __len__(self): # real signature unknown; restored from __doc__
3295         """ x.__len__() &lt;==&gt; len(x) """
3296         pass
3297 
3298     def __le__(self, y): # real signature unknown; restored from __doc__
3299         """ x.__le__(y) &lt;==&gt; x&lt;=y """
3300         pass
3301 
3302     def __lt__(self, y): # real signature unknown; restored from __doc__
3303         """ x.__lt__(y) &lt;==&gt; x&lt;y """
3304         pass
3305 
3306     @staticmethod # known case of __new__
3307     def __new__(S, *more): # real signature unknown; restored from __doc__
3308         """ T.__new__(S, ...) -&gt; a new object with type S, a subtype of T """
3309         pass
3310 
3311     def __ne__(self, y): # real signature unknown; restored from __doc__
3312         """ x.__ne__(y) &lt;==&gt; x!=y """
3313         pass
3314 
3315     def __or__(self, y): # real signature unknown; restored from __doc__
3316         """ x.__or__(y) &lt;==&gt; x|y """
3317         pass
3318 
3319     def __rand__(self, y): # real signature unknown; restored from __doc__
3320         """ x.__rand__(y) &lt;==&gt; y&amp;x """
3321         pass
3322 
3323     def __reduce__(self, *args, **kwargs): # real signature unknown
3324         """ Return state information for pickling. """
3325         pass
3326 
3327     def __repr__(self): # real signature unknown; restored from __doc__
3328         """ x.__repr__() &lt;==&gt; repr(x) """
3329         pass
3330 
3331     def __ror__(self, y): # real signature unknown; restored from __doc__
3332         """ x.__ror__(y) &lt;==&gt; y|x """
3333         pass
3334 
3335     def __rsub__(self, y): # real signature unknown; restored from __doc__
3336         """ x.__rsub__(y) &lt;==&gt; y-x """
3337         pass
3338 
3339     def __rxor__(self, y): # real signature unknown; restored from __doc__
3340         """ x.__rxor__(y) &lt;==&gt; y^x """
3341         pass
3342 
3343     def __sizeof__(self): # real signature unknown; restored from __doc__
3344         """ S.__sizeof__() -&gt; size of S in memory, in bytes """
3345         pass
3346 
3347     def __sub__(self, y): # real signature unknown; restored from __doc__
3348         """ x.__sub__(y) &lt;==&gt; x-y """
3349         pass
3350 
3351     def __xor__(self, y): # real signature unknown; restored from __doc__
3352         """ x.__xor__(y) &lt;==&gt; x^y """
3353         pass
3354 
3355 
3356 class list(object):
3357     """
3358     list() -&gt; new empty list
3359     list(iterable) -&gt; new list initialized from iterable's items
3360     """
3361     def append(self, p_object): # real signature unknown; restored from __doc__
3362         """ L.append(object) -- append object to end """
3363         pass
3364 
3365     def count(self, value): # real signature unknown; restored from __doc__
3366         """ L.count(value) -&gt; integer -- return number of occurrences of value """
3367         return 0
3368 
3369     def extend(self, iterable): # real signature unknown; restored from __doc__
3370         """ L.extend(iterable) -- extend list by appending elements from the iterable """
3371         pass
3372 
3373     def index(self, value, start=None, stop=None): # real signature unknown; restored from __doc__
3374         """
3375         L.index(value, [start, [stop]]) -&gt; integer -- return first index of value.
3376         Raises ValueError if the value is not present.
3377         """
3378         return 0
3379 
3380     def insert(self, index, p_object): # real signature unknown; restored from __doc__
3381         """ L.insert(index, object) -- insert object before index """
3382         pass
3383 
3384     def pop(self, index=None): # real signature unknown; restored from __doc__
3385         """
3386         L.pop([index]) -&gt; item -- remove and return item at index (default last).
3387         Raises IndexError if list is empty or index is out of range.
3388         """
3389         pass
3390 
3391     def remove(self, value): # real signature unknown; restored from __doc__
3392         """
3393         L.remove(value) -- remove first occurrence of value.
3394         Raises ValueError if the value is not present.
3395         """
3396         pass
3397 
3398     def reverse(self): # real signature unknown; restored from __doc__
3399         """ L.reverse() -- reverse *IN PLACE* """
3400         pass
3401 
3402     def sort(self, cmp=None, key=None, reverse=False): # real signature unknown; restored from __doc__
3403         """
3404         L.sort(cmp=None, key=None, reverse=False) -- stable sort *IN PLACE*;
3405         cmp(x, y) -&gt; -1, 0, 1
3406         """
3407         pass
3408 
3409     def __add__(self, y): # real signature unknown; restored from __doc__
3410         """ x.__add__(y) &lt;==&gt; x+y """
3411         pass
3412 
3413     def __contains__(self, y): # real signature unknown; restored from __doc__
3414         """ x.__contains__(y) &lt;==&gt; y in x """
3415         pass
3416 
3417     def __delitem__(self, y): # real signature unknown; restored from __doc__
3418         """ x.__delitem__(y) &lt;==&gt; del x[y] """
3419         pass
3420 
3421     def __delslice__(self, i, j): # real signature unknown; restored from __doc__
3422         """
3423         x.__delslice__(i, j) &lt;==&gt; del x[i:j]
3424                    
3425                    Use of negative indices is not supported.
3426         """
3427         pass
3428 
3429     def __eq__(self, y): # real signature unknown; restored from __doc__
3430         """ x.__eq__(y) &lt;==&gt; x==y """
3431         pass
3432 
3433     def __getattribute__(self, name): # real signature unknown; restored from __doc__
3434         """ x.__getattribute__('name') &lt;==&gt; x.name """
3435         pass
3436 
3437     def __getitem__(self, y): # real signature unknown; restored from __doc__
3438         """ x.__getitem__(y) &lt;==&gt; x[y] """
3439         pass
3440 
3441     def __getslice__(self, i, j): # real signature unknown; restored from __doc__
3442         """
3443         x.__getslice__(i, j) &lt;==&gt; x[i:j]
3444                    
3445                    Use of negative indices is not supported.
3446         """
3447         pass
3448 
3449     def __ge__(self, y): # real signature unknown; restored from __doc__
3450         """ x.__ge__(y) &lt;==&gt; x&gt;=y """
3451         pass
3452 
3453     def __gt__(self, y): # real signature unknown; restored from __doc__
3454         """ x.__gt__(y) &lt;==&gt; x&gt;y """
3455         pass
3456 
3457     def __iadd__(self, y): # real signature unknown; restored from __doc__
3458         """ x.__iadd__(y) &lt;==&gt; x+=y """
3459         pass
3460 
3461     def __imul__(self, y): # real signature unknown; restored from __doc__
3462         """ x.__imul__(y) &lt;==&gt; x*=y """
3463         pass
3464 
3465     def __init__(self, seq=()): # known special case of list.__init__
3466         """
3467         list() -&gt; new empty list
3468         list(iterable) -&gt; new list initialized from iterable's items
3469         # (copied from class doc)
3470         """
3471         pass
3472 
3473     def __iter__(self): # real signature unknown; restored from __doc__
3474         """ x.__iter__() &lt;==&gt; iter(x) """
3475         pass
3476 
3477     def __len__(self): # real signature unknown; restored from __doc__
3478         """ x.__len__() &lt;==&gt; len(x) """
3479         pass
3480 
3481     def __le__(self, y): # real signature unknown; restored from __doc__
3482         """ x.__le__(y) &lt;==&gt; x&lt;=y """
3483         pass
3484 
3485     def __lt__(self, y): # real signature unknown; restored from __doc__
3486         """ x.__lt__(y) &lt;==&gt; x&lt;y """
3487         pass
3488 
3489     def __mul__(self, n): # real signature unknown; restored from __doc__
3490         """ x.__mul__(n) &lt;==&gt; x*n """
3491         pass
3492 
3493     @staticmethod # known case of __new__
3494     def __new__(S, *more): # real signature unknown; restored from __doc__
3495         """ T.__new__(S, ...) -&gt; a new object with type S, a subtype of T """
3496         pass
3497 
3498     def __ne__(self, y): # real signature unknown; restored from __doc__
3499         """ x.__ne__(y) &lt;==&gt; x!=y """
3500         pass
3501 
3502     def __repr__(self): # real signature unknown; restored from __doc__
3503         """ x.__repr__() &lt;==&gt; repr(x) """
3504         pass
3505 
3506     def __reversed__(self): # real signature unknown; restored from __doc__
3507         """ L.__reversed__() -- return a reverse iterator over the list """
3508         pass
3509 
3510     def __rmul__(self, n): # real signature unknown; restored from __doc__
3511         """ x.__rmul__(n) &lt;==&gt; n*x """
3512         pass
3513 
3514     def __setitem__(self, i, y): # real signature unknown; restored from __doc__
3515         """ x.__setitem__(i, y) &lt;==&gt; x[i]=y """
3516         pass
3517 
3518     def __setslice__(self, i, j, y): # real signature unknown; restored from __doc__
3519         """
3520         x.__setslice__(i, j, y) &lt;==&gt; x[i:j]=y
3521                    
3522                    Use  of negative indices is not supported.
3523         """
3524         pass
3525 
3526     def __sizeof__(self): # real signature unknown; restored from __doc__
3527         """ L.__sizeof__() -- size of L in memory, in bytes """
3528         pass
3529 
3530     __hash__ = None
3531 
3532 
3533 class long(object):
3534     """
3535     long(x=0) -&gt; long
3536     long(x, base=10) -&gt; long
3537     
3538     Convert a number or string to a long integer, or return 0L if no arguments
3539     are given.  If x is floating point, the conversion truncates towards zero.
3540     
3541     If x is not a number or if base is given, then x must be a string or
3542     Unicode object representing an integer literal in the given base.  The
3543     literal can be preceded by '+' or '-' and be surrounded by whitespace.
3544     The base defaults to 10.  Valid bases are 0 and 2-36.  Base 0 means to
3545     interpret the base from the string as an integer literal.
3546     &gt;&gt;&gt; int('0b100', base=0)
3547     4L
3548     """
3549     def bit_length(self): # real signature unknown; restored from __doc__
3550         """
3551         long.bit_length() -&gt; int or long
3552         
3553         Number of bits necessary to represent self in binary.
3554         &gt;&gt;&gt; bin(37L)
3555         '0b100101'
3556         &gt;&gt;&gt; (37L).bit_length()
3557         6
3558         """
3559         return 0
3560 
3561     def conjugate(self, *args, **kwargs): # real signature unknown
3562         """ Returns self, the complex conjugate of any long. """
3563         pass
3564 
3565     def __abs__(self): # real signature unknown; restored from __doc__
3566         """ x.__abs__() &lt;==&gt; abs(x) """
3567         pass
3568 
3569     def __add__(self, y): # real signature unknown; restored from __doc__
3570         """ x.__add__(y) &lt;==&gt; x+y """
3571         pass
3572 
3573     def __and__(self, y): # real signature unknown; restored from __doc__
3574         """ x.__and__(y) &lt;==&gt; x&amp;y """
3575         pass
3576 
3577     def __cmp__(self, y): # real signature unknown; restored from __doc__
3578         """ x.__cmp__(y) &lt;==&gt; cmp(x,y) """
3579         pass
3580 
3581     def __coerce__(self, y): # real signature unknown; restored from __doc__
3582         """ x.__coerce__(y) &lt;==&gt; coerce(x, y) """
3583         pass
3584 
3585     def __divmod__(self, y): # real signature unknown; restored from __doc__
3586         """ x.__divmod__(y) &lt;==&gt; divmod(x, y) """
3587         pass
3588 
3589     def __div__(self, y): # real signature unknown; restored from __doc__
3590         """ x.__div__(y) &lt;==&gt; x/y """
3591         pass
3592 
3593     def __float__(self): # real signature unknown; restored from __doc__
3594         """ x.__float__() &lt;==&gt; float(x) """
3595         pass
3596 
3597     def __floordiv__(self, y): # real signature unknown; restored from __doc__
3598         """ x.__floordiv__(y) &lt;==&gt; x//y """
3599         pass
3600 
3601     def __format__(self, *args, **kwargs): # real signature unknown
3602         pass
3603 
3604     def __getattribute__(self, name): # real signature unknown; restored from __doc__
3605         """ x.__getattribute__('name') &lt;==&gt; x.name """
3606         pass
3607 
3608     def __getnewargs__(self, *args, **kwargs): # real signature unknown
3609         pass
3610 
3611     def __hash__(self): # real signature unknown; restored from __doc__
3612         """ x.__hash__() &lt;==&gt; hash(x) """
3613         pass
3614 
3615     def __hex__(self): # real signature unknown; restored from __doc__
3616         """ x.__hex__() &lt;==&gt; hex(x) """
3617         pass
3618 
3619     def __index__(self): # real signature unknown; restored from __doc__
3620         """ x[y:z] &lt;==&gt; x[y.__index__():z.__index__()] """
3621         pass
3622 
3623     def __init__(self, x=0): # real signature unknown; restored from __doc__
3624         pass
3625 
3626     def __int__(self): # real signature unknown; restored from __doc__
3627         """ x.__int__() &lt;==&gt; int(x) """
3628         pass
3629 
3630     def __invert__(self): # real signature unknown; restored from __doc__
3631         """ x.__invert__() &lt;==&gt; ~x """
3632         pass
3633 
3634     def __long__(self): # real signature unknown; restored from __doc__
3635         """ x.__long__() &lt;==&gt; long(x) """
3636         pass
3637 
3638     def __lshift__(self, y): # real signature unknown; restored from __doc__
3639         """ x.__lshift__(y) &lt;==&gt; x&lt;&lt;y """
3640         pass
3641 
3642     def __mod__(self, y): # real signature unknown; restored from __doc__
3643         """ x.__mod__(y) &lt;==&gt; x%y """
3644         pass
3645 
3646     def __mul__(self, y): # real signature unknown; restored from __doc__
3647         """ x.__mul__(y) &lt;==&gt; x*y """
3648         pass
3649 
3650     def __neg__(self): # real signature unknown; restored from __doc__
3651         """ x.__neg__() &lt;==&gt; -x """
3652         pass
3653 
3654     @staticmethod # known case of __new__
3655     def __new__(S, *more): # real signature unknown; restored from __doc__
3656         """ T.__new__(S, ...) -&gt; a new object with type S, a subtype of T """
3657         pass
3658 
3659     def __nonzero__(self): # real signature unknown; restored from __doc__
3660         """ x.__nonzero__() &lt;==&gt; x != 0 """
3661         pass
3662 
3663     def __oct__(self): # real signature unknown; restored from __doc__
3664         """ x.__oct__() &lt;==&gt; oct(x) """
3665         pass
3666 
3667     def __or__(self, y): # real signature unknown; restored from __doc__
3668         """ x.__or__(y) &lt;==&gt; x|y """
3669         pass
3670 
3671     def __pos__(self): # real signature unknown; restored from __doc__
3672         """ x.__pos__() &lt;==&gt; +x """
3673         pass
3674 
3675     def __pow__(self, y, z=None): # real signature unknown; restored from __doc__
3676         """ x.__pow__(y[, z]) &lt;==&gt; pow(x, y[, z]) """
3677         pass
3678 
3679     def __radd__(self, y): # real signature unknown; restored from __doc__
3680         """ x.__radd__(y) &lt;==&gt; y+x """
3681         pass
3682 
3683     def __rand__(self, y): # real signature unknown; restored from __doc__
3684         """ x.__rand__(y) &lt;==&gt; y&amp;x """
3685         pass
3686 
3687     def __rdivmod__(self, y): # real signature unknown; restored from __doc__
3688         """ x.__rdivmod__(y) &lt;==&gt; divmod(y, x) """
3689         pass
3690 
3691     def __rdiv__(self, y): # real signature unknown; restored from __doc__
3692         """ x.__rdiv__(y) &lt;==&gt; y/x """
3693         pass
3694 
3695     def __repr__(self): # real signature unknown; restored from __doc__
3696         """ x.__repr__() &lt;==&gt; repr(x) """
3697         pass
3698 
3699     def __rfloordiv__(self, y): # real signature unknown; restored from __doc__
3700         """ x.__rfloordiv__(y) &lt;==&gt; y//x """
3701         pass
3702 
3703     def __rlshift__(self, y): # real signature unknown; restored from __doc__
3704         """ x.__rlshift__(y) &lt;==&gt; y&lt;&lt;x """
3705         pass
3706 
3707     def __rmod__(self, y): # real signature unknown; restored from __doc__
3708         """ x.__rmod__(y) &lt;==&gt; y%x """
3709         pass
3710 
3711     def __rmul__(self, y): # real signature unknown; restored from __doc__
3712         """ x.__rmul__(y) &lt;==&gt; y*x """
3713         pass
3714 
3715     def __ror__(self, y): # real signature unknown; restored from __doc__
3716         """ x.__ror__(y) &lt;==&gt; y|x """
3717         pass
3718 
3719     def __rpow__(self, x, z=None): # real signature unknown; restored from __doc__
3720         """ y.__rpow__(x[, z]) &lt;==&gt; pow(x, y[, z]) """
3721         pass
3722 
3723     def __rrshift__(self, y): # real signature unknown; restored from __doc__
3724         """ x.__rrshift__(y) &lt;==&gt; y&gt;&gt;x """
3725         pass
3726 
3727     def __rshift__(self, y): # real signature unknown; restored from __doc__
3728         """ x.__rshift__(y) &lt;==&gt; x&gt;&gt;y """
3729         pass
3730 
3731     def __rsub__(self, y): # real signature unknown; restored from __doc__
3732         """ x.__rsub__(y) &lt;==&gt; y-x """
3733         pass
3734 
3735     def __rtruediv__(self, y): # real signature unknown; restored from __doc__
3736         """ x.__rtruediv__(y) &lt;==&gt; y/x """
3737         pass
3738 
3739     def __rxor__(self, y): # real signature unknown; restored from __doc__
3740         """ x.__rxor__(y) &lt;==&gt; y^x """
3741         pass
3742 
3743     def __sizeof__(self, *args, **kwargs): # real signature unknown
3744         """ Returns size in memory, in bytes """
3745         pass
3746 
3747     def __str__(self): # real signature unknown; restored from __doc__
3748         """ x.__str__() &lt;==&gt; str(x) """
3749         pass
3750 
3751     def __sub__(self, y): # real signature unknown; restored from __doc__
3752         """ x.__sub__(y) &lt;==&gt; x-y """
3753         pass
3754 
3755     def __truediv__(self, y): # real signature unknown; restored from __doc__
3756         """ x.__truediv__(y) &lt;==&gt; x/y """
3757         pass
3758 
3759     def __trunc__(self, *args, **kwargs): # real signature unknown
3760         """ Truncating an Integral returns itself. """
3761         pass
3762 
3763     def __xor__(self, y): # real signature unknown; restored from __doc__
3764         """ x.__xor__(y) &lt;==&gt; x^y """
3765         pass
3766 
3767     denominator = property(lambda self: object(), lambda self, v: None, lambda self: None)  # default
3768     """the denominator of a rational number in lowest terms"""
3769 
3770     imag = property(lambda self: object(), lambda self, v: None, lambda self: None)  # default
3771     """the imaginary part of a complex number"""
3772 
3773     numerator = property(lambda self: object(), lambda self, v: None, lambda self: None)  # default
3774     """the numerator of a rational number in lowest terms"""
3775 
3776     real = property(lambda self: object(), lambda self, v: None, lambda self: None)  # default
3777     """the real part of a complex number"""
3778 
3779 
3780 
3781 class memoryview(object):
3782     """
3783     memoryview(object)
3784     
3785     Create a new memoryview object which references the given object.
3786     """
3787     def tobytes(self, *args, **kwargs): # real signature unknown
3788         pass
3789 
3790     def tolist(self, *args, **kwargs): # real signature unknown
3791         pass
3792 
3793     def __delitem__(self, y): # real signature unknown; restored from __doc__
3794         """ x.__delitem__(y) &lt;==&gt; del x[y] """
3795         pass
3796 
3797     def __eq__(self, y): # real signature unknown; restored from __doc__
3798         """ x.__eq__(y) &lt;==&gt; x==y """
3799         pass
3800 
3801     def __getattribute__(self, name): # real signature unknown; restored from __doc__
3802         """ x.__getattribute__('name') &lt;==&gt; x.name """
3803         pass
3804 
3805     def __getitem__(self, y): # real signature unknown; restored from __doc__
3806         """ x.__getitem__(y) &lt;==&gt; x[y] """
3807         pass
3808 
3809     def __ge__(self, y): # real signature unknown; restored from __doc__
3810         """ x.__ge__(y) &lt;==&gt; x&gt;=y """
3811         pass
3812 
3813     def __gt__(self, y): # real signature unknown; restored from __doc__
3814         """ x.__gt__(y) &lt;==&gt; x&gt;y """
3815         pass
3816 
3817     def __init__(self, p_object): # real signature unknown; restored from __doc__
3818         pass
3819 
3820     def __len__(self): # real signature unknown; restored from __doc__
3821         """ x.__len__() &lt;==&gt; len(x) """
3822         pass
3823 
3824     def __le__(self, y): # real signature unknown; restored from __doc__
3825         """ x.__le__(y) &lt;==&gt; x&lt;=y """
3826         pass
3827 
3828     def __lt__(self, y): # real signature unknown; restored from __doc__
3829         """ x.__lt__(y) &lt;==&gt; x&lt;y """
3830         pass
3831 
3832     @staticmethod # known case of __new__
3833     def __new__(S, *more): # real signature unknown; restored from __doc__
3834         """ T.__new__(S, ...) -&gt; a new object with type S, a subtype of T """
3835         pass
3836 
3837     def __ne__(self, y): # real signature unknown; restored from __doc__
3838         """ x.__ne__(y) &lt;==&gt; x!=y """
3839         pass
3840 
3841     def __repr__(self): # real signature unknown; restored from __doc__
3842         """ x.__repr__() &lt;==&gt; repr(x) """
3843         pass
3844 
3845     def __setitem__(self, i, y): # real signature unknown; restored from __doc__
3846         """ x.__setitem__(i, y) &lt;==&gt; x[i]=y """
3847         pass
3848 
3849     format = property(lambda self: object(), lambda self, v: None, lambda self: None)  # default
3850 
3851     itemsize = property(lambda self: object(), lambda self, v: None, lambda self: None)  # default
3852 
3853     ndim = property(lambda self: object(), lambda self, v: None, lambda self: None)  # default
3854 
3855     readonly = property(lambda self: object(), lambda self, v: None, lambda self: None)  # default
3856 
3857     shape = property(lambda self: object(), lambda self, v: None, lambda self: None)  # default
3858 
3859     strides = property(lambda self: object(), lambda self, v: None, lambda self: None)  # default
3860 
3861     suboffsets = property(lambda self: object(), lambda self, v: None, lambda self: None)  # default
3862 
3863 
3864 
3865 class property(object):
3866     """
3867     property(fget=None, fset=None, fdel=None, doc=None) -&gt; property attribute
3868     
3869     fget is a function to be used for getting an attribute value, and likewise
3870     fset is a function for setting, and fdel a function for del'ing, an
3871     attribute.  Typical use is to define a managed attribute x:
3872     
3873     class C(object):
3874         def getx(self): return self._x
3875         def setx(self, value): self._x = value
3876         def delx(self): del self._x
3877         x = property(getx, setx, delx, "I'm the 'x' property.")
3878     
3879     Decorators make defining new properties or modifying existing ones easy:
3880     
3881     class C(object):
3882         @property
3883         def x(self):
3884             "I am the 'x' property."
3885             return self._x
3886         @x.setter
3887         def x(self, value):
3888             self._x = value
3889         @x.deleter
3890         def x(self):
3891             del self._x
3892     """
3893     def deleter(self, *args, **kwargs): # real signature unknown
3894         """ Descriptor to change the deleter on a property. """
3895         pass
3896 
3897     def getter(self, *args, **kwargs): # real signature unknown
3898         """ Descriptor to change the getter on a property. """
3899         pass
3900 
3901     def setter(self, *args, **kwargs): # real signature unknown
3902         """ Descriptor to change the setter on a property. """
3903         pass
3904 
3905     def __delete__(self, obj): # real signature unknown; restored from __doc__
3906         """ descr.__delete__(obj) """
3907         pass
3908 
3909     def __getattribute__(self, name): # real signature unknown; restored from __doc__
3910         """ x.__getattribute__('name') &lt;==&gt; x.name """
3911         pass
3912 
3913     def __get__(self, obj, type=None): # real signature unknown; restored from __doc__
3914         """ descr.__get__(obj[, type]) -&gt; value """
3915         pass
3916 
3917     def __init__(self, fget=None, fset=None, fdel=None, doc=None): # known special case of property.__init__
3918         """
3919         property(fget=None, fset=None, fdel=None, doc=None) -&gt; property attribute
3920         
3921         fget is a function to be used for getting an attribute value, and likewise
3922         fset is a function for setting, and fdel a function for del'ing, an
3923         attribute.  Typical use is to define a managed attribute x:
3924         
3925         class C(object):
3926             def getx(self): return self._x
3927             def setx(self, value): self._x = value
3928             def delx(self): del self._x
3929             x = property(getx, setx, delx, "I'm the 'x' property.")
3930         
3931         Decorators make defining new properties or modifying existing ones easy:
3932         
3933         class C(object):
3934             @property
3935             def x(self):
3936                 "I am the 'x' property."
3937                 return self._x
3938             @x.setter
3939             def x(self, value):
3940                 self._x = value
3941             @x.deleter
3942             def x(self):
3943                 del self._x
3944         
3945         # (copied from class doc)
3946         """
3947         pass
3948 
3949     @staticmethod # known case of __new__
3950     def __new__(S, *more): # real signature unknown; restored from __doc__
3951         """ T.__new__(S, ...) -&gt; a new object with type S, a subtype of T """
3952         pass
3953 
3954     def __set__(self, obj, value): # real signature unknown; restored from __doc__
3955         """ descr.__set__(obj, value) """
3956         pass
3957 
3958     fdel = property(lambda self: object(), lambda self, v: None, lambda self: None)  # default
3959 
3960     fget = property(lambda self: object(), lambda self, v: None, lambda self: None)  # default
3961 
3962     fset = property(lambda self: object(), lambda self, v: None, lambda self: None)  # default
3963 
3964 
3965 
3966 class reversed(object):
3967     """
3968     reversed(sequence) -&gt; reverse iterator over values of the sequence
3969     
3970     Return a reverse iterator
3971     """
3972     def next(self): # real signature unknown; restored from __doc__
3973         """ x.next() -&gt; the next value, or raise StopIteration """
3974         pass
3975 
3976     def __getattribute__(self, name): # real signature unknown; restored from __doc__
3977         """ x.__getattribute__('name') &lt;==&gt; x.name """
3978         pass
3979 
3980     def __init__(self, sequence): # real signature unknown; restored from __doc__
3981         pass
3982 
3983     def __iter__(self): # real signature unknown; restored from __doc__
3984         """ x.__iter__() &lt;==&gt; iter(x) """
3985         pass
3986 
3987     def __length_hint__(self, *args, **kwargs): # real signature unknown
3988         """ Private method returning an estimate of len(list(it)). """
3989         pass
3990 
3991     @staticmethod # known case of __new__
3992     def __new__(S, *more): # real signature unknown; restored from __doc__
3993         """ T.__new__(S, ...) -&gt; a new object with type S, a subtype of T """
3994         pass
3995 
3996 
3997 class set(object):
3998     """
3999     set() -&gt; new empty set object
4000     set(iterable) -&gt; new set object
4001     
4002     Build an unordered collection of unique elements.
4003     """
4004     def add(self, *args, **kwargs): # real signature unknown
4005         """
4006         Add an element to a set.
4007         
4008         This has no effect if the element is already present.
4009         """
4010         pass
4011 
4012     def clear(self, *args, **kwargs): # real signature unknown
4013         """ Remove all elements from this set. """
4014         pass
4015 
4016     def copy(self, *args, **kwargs): # real signature unknown
4017         """ Return a shallow copy of a set. """
4018         pass
4019 
4020     def difference(self, *args, **kwargs): # real signature unknown
4021         """
4022         Return the difference of two or more sets as a new set.
4023         
4024         (i.e. all elements that are in this set but not the others.)
4025         """
4026         pass
4027 
4028     def difference_update(self, *args, **kwargs): # real signature unknown
4029         """ Remove all elements of another set from this set. """
4030         pass
4031 
4032     def discard(self, *args, **kwargs): # real signature unknown
4033         """
4034         Remove an element from a set if it is a member.
4035         
4036         If the element is not a member, do nothing.
4037         """
4038         pass
4039 
4040     def intersection(self, *args, **kwargs): # real signature unknown
4041         """
4042         Return the intersection of two or more sets as a new set.
4043         
4044         (i.e. elements that are common to all of the sets.)
4045         """
4046         pass
4047 
4048     def intersection_update(self, *args, **kwargs): # real signature unknown
4049         """ Update a set with the intersection of itself and another. """
4050         pass
4051 
4052     def isdisjoint(self, *args, **kwargs): # real signature unknown
4053         """ Return True if two sets have a null intersection. """
4054         pass
4055 
4056     def issubset(self, *args, **kwargs): # real signature unknown
4057         """ Report whether another set contains this set. """
4058         pass
4059 
4060     def issuperset(self, *args, **kwargs): # real signature unknown
4061         """ Report whether this set contains another set. """
4062         pass
4063 
4064     def pop(self, *args, **kwargs): # real signature unknown
4065         """
4066         Remove and return an arbitrary set element.
4067         Raises KeyError if the set is empty.
4068         """
4069         pass
4070 
4071     def remove(self, *args, **kwargs): # real signature unknown
4072         """
4073         Remove an element from a set; it must be a member.
4074         
4075         If the element is not a member, raise a KeyError.
4076         """
4077         pass
4078 
4079     def symmetric_difference(self, *args, **kwargs): # real signature unknown
4080         """
4081         Return the symmetric difference of two sets as a new set.
4082         
4083         (i.e. all elements that are in exactly one of the sets.)
4084         """
4085         pass
4086 
4087     def symmetric_difference_update(self, *args, **kwargs): # real signature unknown
4088         """ Update a set with the symmetric difference of itself and another. """
4089         pass
4090 
4091     def union(self, *args, **kwargs): # real signature unknown
4092         """
4093         Return the union of sets as a new set.
4094         
4095         (i.e. all elements that are in either set.)
4096         """
4097         pass
4098 
4099     def update(self, *args, **kwargs): # real signature unknown
4100         """ Update a set with the union of itself and others. """
4101         pass
4102 
4103     def __and__(self, y): # real signature unknown; restored from __doc__
4104         """ x.__and__(y) &lt;==&gt; x&amp;y """
4105         pass
4106 
4107     def __cmp__(self, y): # real signature unknown; restored from __doc__
4108         """ x.__cmp__(y) &lt;==&gt; cmp(x,y) """
4109         pass
4110 
4111     def __contains__(self, y): # real signature unknown; restored from __doc__
4112         """ x.__contains__(y) &lt;==&gt; y in x. """
4113         pass
4114 
4115     def __eq__(self, y): # real signature unknown; restored from __doc__
4116         """ x.__eq__(y) &lt;==&gt; x==y """
4117         pass
4118 
4119     def __getattribute__(self, name): # real signature unknown; restored from __doc__
4120         """ x.__getattribute__('name') &lt;==&gt; x.name """
4121         pass
4122 
4123     def __ge__(self, y): # real signature unknown; restored from __doc__
4124         """ x.__ge__(y) &lt;==&gt; x&gt;=y """
4125         pass
4126 
4127     def __gt__(self, y): # real signature unknown; restored from __doc__
4128         """ x.__gt__(y) &lt;==&gt; x&gt;y """
4129         pass
4130 
4131     def __iand__(self, y): # real signature unknown; restored from __doc__
4132         """ x.__iand__(y) &lt;==&gt; x&amp;=y """
4133         pass
4134 
4135     def __init__(self, seq=()): # known special case of set.__init__
4136         """
4137         set() -&gt; new empty set object
4138         set(iterable) -&gt; new set object
4139         
4140         Build an unordered collection of unique elements.
4141         # (copied from class doc)
4142         """
4143         pass
4144 
4145     def __ior__(self, y): # real signature unknown; restored from __doc__
4146         """ x.__ior__(y) &lt;==&gt; x|=y """
4147         pass
4148 
4149     def __isub__(self, y): # real signature unknown; restored from __doc__
4150         """ x.__isub__(y) &lt;==&gt; x-=y """
4151         pass
4152 
4153     def __iter__(self): # real signature unknown; restored from __doc__
4154         """ x.__iter__() &lt;==&gt; iter(x) """
4155         pass
4156 
4157     def __ixor__(self, y): # real signature unknown; restored from __doc__
4158         """ x.__ixor__(y) &lt;==&gt; x^=y """
4159         pass
4160 
4161     def __len__(self): # real signature unknown; restored from __doc__
4162         """ x.__len__() &lt;==&gt; len(x) """
4163         pass
4164 
4165     def __le__(self, y): # real signature unknown; restored from __doc__
4166         """ x.__le__(y) &lt;==&gt; x&lt;=y """
4167         pass
4168 
4169     def __lt__(self, y): # real signature unknown; restored from __doc__
4170         """ x.__lt__(y) &lt;==&gt; x&lt;y """
4171         pass
4172 
4173     @staticmethod # known case of __new__
4174     def __new__(S, *more): # real signature unknown; restored from __doc__
4175         """ T.__new__(S, ...) -&gt; a new object with type S, a subtype of T """
4176         pass
4177 
4178     def __ne__(self, y): # real signature unknown; restored from __doc__
4179         """ x.__ne__(y) &lt;==&gt; x!=y """
4180         pass
4181 
4182     def __or__(self, y): # real signature unknown; restored from __doc__
4183         """ x.__or__(y) &lt;==&gt; x|y """
4184         pass
4185 
4186     def __rand__(self, y): # real signature unknown; restored from __doc__
4187         """ x.__rand__(y) &lt;==&gt; y&amp;x """
4188         pass
4189 
4190     def __reduce__(self, *args, **kwargs): # real signature unknown
4191         """ Return state information for pickling. """
4192         pass
4193 
4194     def __repr__(self): # real signature unknown; restored from __doc__
4195         """ x.__repr__() &lt;==&gt; repr(x) """
4196         pass
4197 
4198     def __ror__(self, y): # real signature unknown; restored from __doc__
4199         """ x.__ror__(y) &lt;==&gt; y|x """
4200         pass
4201 
4202     def __rsub__(self, y): # real signature unknown; restored from __doc__
4203         """ x.__rsub__(y) &lt;==&gt; y-x """
4204         pass
4205 
4206     def __rxor__(self, y): # real signature unknown; restored from __doc__
4207         """ x.__rxor__(y) &lt;==&gt; y^x """
4208         pass
4209 
4210     def __sizeof__(self): # real signature unknown; restored from __doc__
4211         """ S.__sizeof__() -&gt; size of S in memory, in bytes """
4212         pass
4213 
4214     def __sub__(self, y): # real signature unknown; restored from __doc__
4215         """ x.__sub__(y) &lt;==&gt; x-y """
4216         pass
4217 
4218     def __xor__(self, y): # real signature unknown; restored from __doc__
4219         """ x.__xor__(y) &lt;==&gt; x^y """
4220         pass
4221 
4222     __hash__ = None
4223 
4224 
4225 class slice(object):
4226     """
4227     slice(stop)
4228     slice(start, stop[, step])
4229     
4230     Create a slice object.  This is used for extended slicing (e.g. a[0:10:2]).
4231     """
4232     def indices(self, len): # real signature unknown; restored from __doc__
4233         """
4234         S.indices(len) -&gt; (start, stop, stride)
4235         
4236         Assuming a sequence of length len, calculate the start and stop
4237         indices, and the stride length of the extended slice described by
4238         S. Out of bounds indices are clipped in a manner consistent with the
4239         handling of normal slices.
4240         """
4241         pass
4242 
4243     def __cmp__(self, y): # real signature unknown; restored from __doc__
4244         """ x.__cmp__(y) &lt;==&gt; cmp(x,y) """
4245         pass
4246 
4247     def __getattribute__(self, name): # real signature unknown; restored from __doc__
4248         """ x.__getattribute__('name') &lt;==&gt; x.name """
4249         pass
4250 
4251     def __hash__(self): # real signature unknown; restored from __doc__
4252         """ x.__hash__() &lt;==&gt; hash(x) """
4253         pass
4254 
4255     def __init__(self, stop): # real signature unknown; restored from __doc__
4256         pass
4257 
4258     @staticmethod # known case of __new__
4259     def __new__(S, *more): # real signature unknown; restored from __doc__
4260         """ T.__new__(S, ...) -&gt; a new object with type S, a subtype of T """
4261         pass
4262 
4263     def __reduce__(self, *args, **kwargs): # real signature unknown
4264         """ Return state information for pickling. """
4265         pass
4266 
4267     def __repr__(self): # real signature unknown; restored from __doc__
4268         """ x.__repr__() &lt;==&gt; repr(x) """
4269         pass
4270 
4271     start = property(lambda self: 0)
4272     """:type: int"""
4273 
4274     step = property(lambda self: 0)
4275     """:type: int"""
4276 
4277     stop = property(lambda self: 0)
4278     """:type: int"""
4279 
4280 
4281 
4282 class staticmethod(object):
4283     """
4284     staticmethod(function) -&gt; method
4285     
4286     Convert a function to be a static method.
4287     
4288     A static method does not receive an implicit first argument.
4289     To declare a static method, use this idiom:
4290     
4291          class C:
4292              @staticmethod
4293              def f(arg1, arg2, ...):
4294                  ...
4295     
4296     It can be called either on the class (e.g. C.f()) or on an instance
4297     (e.g. C().f()).  The instance is ignored except for its class.
4298     
4299     Static methods in Python are similar to those found in Java or C++.
4300     For a more advanced concept, see the classmethod builtin.
4301     """
4302     def __getattribute__(self, name): # real signature unknown; restored from __doc__
4303         """ x.__getattribute__('name') &lt;==&gt; x.name """
4304         pass
4305 
4306     def __get__(self, obj, type=None): # real signature unknown; restored from __doc__
4307         """ descr.__get__(obj[, type]) -&gt; value """
4308         pass
4309 
4310     def __init__(self, function): # real signature unknown; restored from __doc__
4311         pass
4312 
4313     @staticmethod # known case of __new__
4314     def __new__(S, *more): # real signature unknown; restored from __doc__
4315         """ T.__new__(S, ...) -&gt; a new object with type S, a subtype of T """
4316         pass
4317 
4318     __func__ = property(lambda self: object(), lambda self, v: None, lambda self: None)  # default
4319 
4320 
4321 
4322 class super(object):
4323     """
4324     super(type, obj) -&gt; bound super object; requires isinstance(obj, type)
4325     super(type) -&gt; unbound super object
4326     super(type, type2) -&gt; bound super object; requires issubclass(type2, type)
4327     Typical use to call a cooperative superclass method:
4328     class C(B):
4329         def meth(self, arg):
4330             super(C, self).meth(arg)
4331     """
4332     def __getattribute__(self, name): # real signature unknown; restored from __doc__
4333         """ x.__getattribute__('name') &lt;==&gt; x.name """
4334         pass
4335 
4336     def __get__(self, obj, type=None): # real signature unknown; restored from __doc__
4337         """ descr.__get__(obj[, type]) -&gt; value """
4338         pass
4339 
4340     def __init__(self, type1, type2=None): # known special case of super.__init__
4341         """
4342         super(type, obj) -&gt; bound super object; requires isinstance(obj, type)
4343         super(type) -&gt; unbound super object
4344         super(type, type2) -&gt; bound super object; requires issubclass(type2, type)
4345         Typical use to call a cooperative superclass method:
4346         class C(B):
4347             def meth(self, arg):
4348                 super(C, self).meth(arg)
4349         # (copied from class doc)
4350         """
4351         pass
4352 
4353     @staticmethod # known case of __new__
4354     def __new__(S, *more): # real signature unknown; restored from __doc__
4355         """ T.__new__(S, ...) -&gt; a new object with type S, a subtype of T """
4356         pass
4357 
4358     def __repr__(self): # real signature unknown; restored from __doc__
4359         """ x.__repr__() &lt;==&gt; repr(x) """
4360         pass
4361 
4362     __self_class__ = property(lambda self: type(object))
4363     """the type of the instance invoking super(); may be None
4364 
4365     :type: type
4366     """
4367 
4368     __self__ = property(lambda self: type(object))
4369     """the instance invoking super(); may be None
4370 
4371     :type: type
4372     """
4373 
4374     __thisclass__ = property(lambda self: type(object))
4375     """the class invoking super()
4376 
4377     :type: type
4378     """
4379 
4380 
4381 
4382 class tuple(object):
4383     """
4384     tuple() -&gt; empty tuple
4385     tuple(iterable) -&gt; tuple initialized from iterable's items
4386     
4387     If the argument is a tuple, the return value is the same object.
4388     """
4389     def count(self, value): # real signature unknown; restored from __doc__
4390         """ T.count(value) -&gt; integer -- return number of occurrences of value """
4391         return 0
4392 
4393     def index(self, value, start=None, stop=None): # real signature unknown; restored from __doc__
4394         """
4395         T.index(value, [start, [stop]]) -&gt; integer -- return first index of value.
4396         Raises ValueError if the value is not present.
4397         """
4398         return 0
4399 
4400     def __add__(self, y): # real signature unknown; restored from __doc__
4401         """ x.__add__(y) &lt;==&gt; x+y """
4402         pass
4403 
4404     def __contains__(self, y): # real signature unknown; restored from __doc__
4405         """ x.__contains__(y) &lt;==&gt; y in x """
4406         pass
4407 
4408     def __eq__(self, y): # real signature unknown; restored from __doc__
4409         """ x.__eq__(y) &lt;==&gt; x==y """
4410         pass
4411 
4412     def __getattribute__(self, name): # real signature unknown; restored from __doc__
4413         """ x.__getattribute__('name') &lt;==&gt; x.name """
4414         pass
4415 
4416     def __getitem__(self, y): # real signature unknown; restored from __doc__
4417         """ x.__getitem__(y) &lt;==&gt; x[y] """
4418         pass
4419 
4420     def __getnewargs__(self, *args, **kwargs): # real signature unknown
4421         pass
4422 
4423     def __getslice__(self, i, j): # real signature unknown; restored from __doc__
4424         """
4425         x.__getslice__(i, j) &lt;==&gt; x[i:j]
4426                    
4427                    Use of negative indices is not supported.
4428         """
4429         pass
4430 
4431     def __ge__(self, y): # real signature unknown; restored from __doc__
4432         """ x.__ge__(y) &lt;==&gt; x&gt;=y """
4433         pass
4434 
4435     def __gt__(self, y): # real signature unknown; restored from __doc__
4436         """ x.__gt__(y) &lt;==&gt; x&gt;y """
4437         pass
4438 
4439     def __hash__(self): # real signature unknown; restored from __doc__
4440         """ x.__hash__() &lt;==&gt; hash(x) """
4441         pass
4442 
4443     def __init__(self, seq=()): # known special case of tuple.__init__
4444         """
4445         tuple() -&gt; empty tuple
4446         tuple(iterable) -&gt; tuple initialized from iterable's items
4447         
4448         If the argument is a tuple, the return value is the same object.
4449         # (copied from class doc)
4450         """
4451         pass
4452 
4453     def __iter__(self): # real signature unknown; restored from __doc__
4454         """ x.__iter__() &lt;==&gt; iter(x) """
4455         pass
4456 
4457     def __len__(self): # real signature unknown; restored from __doc__
4458         """ x.__len__() &lt;==&gt; len(x) """
4459         pass
4460 
4461     def __le__(self, y): # real signature unknown; restored from __doc__
4462         """ x.__le__(y) &lt;==&gt; x&lt;=y """
4463         pass
4464 
4465     def __lt__(self, y): # real signature unknown; restored from __doc__
4466         """ x.__lt__(y) &lt;==&gt; x&lt;y """
4467         pass
4468 
4469     def __mul__(self, n): # real signature unknown; restored from __doc__
4470         """ x.__mul__(n) &lt;==&gt; x*n """
4471         pass
4472 
4473     @staticmethod # known case of __new__
4474     def __new__(S, *more): # real signature unknown; restored from __doc__
4475         """ T.__new__(S, ...) -&gt; a new object with type S, a subtype of T """
4476         pass
4477 
4478     def __ne__(self, y): # real signature unknown; restored from __doc__
4479         """ x.__ne__(y) &lt;==&gt; x!=y """
4480         pass
4481 
4482     def __repr__(self): # real signature unknown; restored from __doc__
4483         """ x.__repr__() &lt;==&gt; repr(x) """
4484         pass
4485 
4486     def __rmul__(self, n): # real signature unknown; restored from __doc__
4487         """ x.__rmul__(n) &lt;==&gt; n*x """
4488         pass
4489 
4490 
4491 class type(object):
4492     """
4493     type(object) -&gt; the object's type
4494     type(name, bases, dict) -&gt; a new type
4495     """
4496     def mro(self): # real signature unknown; restored from __doc__
4497         """
4498         mro() -&gt; list
4499         return a type's method resolution order
4500         """
4501         return []
4502 
4503     def __call__(self, *more): # real signature unknown; restored from __doc__
4504         """ x.__call__(...) &lt;==&gt; x(...) """
4505         pass
4506 
4507     def __delattr__(self, name): # real signature unknown; restored from __doc__
4508         """ x.__delattr__('name') &lt;==&gt; del x.name """
4509         pass
4510 
4511     def __eq__(self, y): # real signature unknown; restored from __doc__
4512         """ x.__eq__(y) &lt;==&gt; x==y """
4513         pass
4514 
4515     def __getattribute__(self, name): # real signature unknown; restored from __doc__
4516         """ x.__getattribute__('name') &lt;==&gt; x.name """
4517         pass
4518 
4519     def __ge__(self, y): # real signature unknown; restored from __doc__
4520         """ x.__ge__(y) &lt;==&gt; x&gt;=y """
4521         pass
4522 
4523     def __gt__(self, y): # real signature unknown; restored from __doc__
4524         """ x.__gt__(y) &lt;==&gt; x&gt;y """
4525         pass
4526 
4527     def __hash__(self): # real signature unknown; restored from __doc__
4528         """ x.__hash__() &lt;==&gt; hash(x) """
4529         pass
4530 
4531     def __init__(cls, what, bases=None, dict=None): # known special case of type.__init__
4532         """
4533         type(object) -&gt; the object's type
4534         type(name, bases, dict) -&gt; a new type
4535         # (copied from class doc)
4536         """
4537         pass
4538 
4539     def __instancecheck__(self): # real signature unknown; restored from __doc__
4540         """
4541         __instancecheck__() -&gt; bool
4542         check if an object is an instance
4543         """
4544         return False
4545 
4546     def __le__(self, y): # real signature unknown; restored from __doc__
4547         """ x.__le__(y) &lt;==&gt; x&lt;=y """
4548         pass
4549 
4550     def __lt__(self, y): # real signature unknown; restored from __doc__
4551         """ x.__lt__(y) &lt;==&gt; x&lt;y """
4552         pass
4553 
4554     @staticmethod # known case of __new__
4555     def __new__(S, *more): # real signature unknown; restored from __doc__
4556         """ T.__new__(S, ...) -&gt; a new object with type S, a subtype of T """
4557         pass
4558 
4559     def __ne__(self, y): # real signature unknown; restored from __doc__
4560         """ x.__ne__(y) &lt;==&gt; x!=y """
4561         pass
4562 
4563     def __repr__(self): # real signature unknown; restored from __doc__
4564         """ x.__repr__() &lt;==&gt; repr(x) """
4565         pass
4566 
4567     def __setattr__(self, name, value): # real signature unknown; restored from __doc__
4568         """ x.__setattr__('name', value) &lt;==&gt; x.name = value """
4569         pass
4570 
4571     def __subclasscheck__(self): # real signature unknown; restored from __doc__
4572         """
4573         __subclasscheck__() -&gt; bool
4574         check if a class is a subclass
4575         """
4576         return False
4577 
4578     def __subclasses__(self): # real signature unknown; restored from __doc__
4579         """ __subclasses__() -&gt; list of immediate subclasses """
4580         return []
4581 
4582     __abstractmethods__ = property(lambda self: object(), lambda self, v: None, lambda self: None)  # default
4583 
4584 
4585     __bases__ = (
4586         object,
4587     )
4588     __base__ = object
4589     __basicsize__ = 872
4590     __dictoffset__ = 264
4591     __dict__ = None # (!) real value is ''
4592     __flags__ = 2148423147
4593     __itemsize__ = 40
4594     __mro__ = (
4595         None, # (!) forward: type, real value is ''
4596         object,
4597     )
4598     __name__ = 'type'
4599     __weakrefoffset__ = 368
4600 
4601 
4602 class unicode(basestring):
4603     """
4604     unicode(object='') -&gt; unicode object
4605     unicode(string[, encoding[, errors]]) -&gt; unicode object
4606     
4607     Create a new Unicode object from the given encoded string.
4608     encoding defaults to the current default string encoding.
4609     errors can be 'strict', 'replace' or 'ignore' and defaults to 'strict'.
4610     """
4611     def capitalize(self): # real signature unknown; restored from __doc__
4612         """
4613         S.capitalize() -&gt; unicode
4614         
4615         Return a capitalized version of S, i.e. make the first character
4616         have upper case and the rest lower case.
4617         """
4618         return u""
4619 
4620     def center(self, width, fillchar=None): # real signature unknown; restored from __doc__
4621         """
4622         S.center(width[, fillchar]) -&gt; unicode
4623         
4624         Return S centered in a Unicode string of length width. Padding is
4625         done using the specified fill character (default is a space)
4626         """
4627         return u""
4628 
4629     def count(self, sub, start=None, end=None): # real signature unknown; restored from __doc__
4630         """
4631         S.count(sub[, start[, end]]) -&gt; int
4632         
4633         Return the number of non-overlapping occurrences of substring sub in
4634         Unicode string S[start:end].  Optional arguments start and end are
4635         interpreted as in slice notation.
4636         """
4637         return 0
4638 
4639     def decode(self, encoding=None, errors=None): # real signature unknown; restored from __doc__
4640         """
4641         S.decode([encoding[,errors]]) -&gt; string or unicode
4642         
4643         Decodes S using the codec registered for encoding. encoding defaults
4644         to the default encoding. errors may be given to set a different error
4645         handling scheme. Default is 'strict' meaning that encoding errors raise
4646         a UnicodeDecodeError. Other possible values are 'ignore' and 'replace'
4647         as well as any other name registered with codecs.register_error that is
4648         able to handle UnicodeDecodeErrors.
4649         """
4650         return ""
4651 
4652     def encode(self, encoding=None, errors=None): # real signature unknown; restored from __doc__
4653         """
4654         S.encode([encoding[,errors]]) -&gt; string or unicode
4655         
4656         Encodes S using the codec registered for encoding. encoding defaults
4657         to the default encoding. errors may be given to set a different error
4658         handling scheme. Default is 'strict' meaning that encoding errors raise
4659         a UnicodeEncodeError. Other possible values are 'ignore', 'replace' and
4660         'xmlcharrefreplace' as well as any other name registered with
4661         codecs.register_error that can handle UnicodeEncodeErrors.
4662         """
4663         return ""
4664 
4665     def endswith(self, suffix, start=None, end=None): # real signature unknown; restored from __doc__
4666         """
4667         S.endswith(suffix[, start[, end]]) -&gt; bool
4668         
4669         Return True if S ends with the specified suffix, False otherwise.
4670         With optional start, test S beginning at that position.
4671         With optional end, stop comparing S at that position.
4672         suffix can also be a tuple of strings to try.
4673         """
4674         return False
4675 
4676     def expandtabs(self, tabsize=None): # real signature unknown; restored from __doc__
4677         """
4678         S.expandtabs([tabsize]) -&gt; unicode
4679         
4680         Return a copy of S where all tab characters are expanded using spaces.
4681         If tabsize is not given, a tab size of 8 characters is assumed.
4682         """
4683         return u""
4684 
4685     def find(self, sub, start=None, end=None): # real signature unknown; restored from __doc__
4686         """
4687         S.find(sub [,start [,end]]) -&gt; int
4688         
4689         Return the lowest index in S where substring sub is found,
4690         such that sub is contained within S[start:end].  Optional
4691         arguments start and end are interpreted as in slice notation.
4692         
4693         Return -1 on failure.
4694         """
4695         return 0
4696 
4697     def format(self, *args, **kwargs): # known special case of unicode.format
4698         """
4699         S.format(*args, **kwargs) -&gt; unicode
4700         
4701         Return a formatted version of S, using substitutions from args and kwargs.
4702         The substitutions are identified by braces ('{' and '}').
4703         """
4704         pass
4705 
4706     def index(self, sub, start=None, end=None): # real signature unknown; restored from __doc__
4707         """
4708         S.index(sub [,start [,end]]) -&gt; int
4709         
4710         Like S.find() but raise ValueError when the substring is not found.
4711         """
4712         return 0
4713 
4714     def isalnum(self): # real signature unknown; restored from __doc__
4715         """
4716         S.isalnum() -&gt; bool
4717         
4718         Return True if all characters in S are alphanumeric
4719         and there is at least one character in S, False otherwise.
4720         """
4721         return False
4722 
4723     def isalpha(self): # real signature unknown; restored from __doc__
4724         """
4725         S.isalpha() -&gt; bool
4726         
4727         Return True if all characters in S are alphabetic
4728         and there is at least one character in S, False otherwise.
4729         """
4730         return False
4731 
4732     def isdecimal(self): # real signature unknown; restored from __doc__
4733         """
4734         S.isdecimal() -&gt; bool
4735         
4736         Return True if there are only decimal characters in S,
4737         False otherwise.
4738         """
4739         return False
4740 
4741     def isdigit(self): # real signature unknown; restored from __doc__
4742         """
4743         S.isdigit() -&gt; bool
4744         
4745         Return True if all characters in S are digits
4746         and there is at least one character in S, False otherwise.
4747         """
4748         return False
4749 
4750     def islower(self): # real signature unknown; restored from __doc__
4751         """
4752         S.islower() -&gt; bool
4753         
4754         Return True if all cased characters in S are lowercase and there is
4755         at least one cased character in S, False otherwise.
4756         """
4757         return False
4758 
4759     def isnumeric(self): # real signature unknown; restored from __doc__
4760         """
4761         S.isnumeric() -&gt; bool
4762         
4763         Return True if there are only numeric characters in S,
4764         False otherwise.
4765         """
4766         return False
4767 
4768     def isspace(self): # real signature unknown; restored from __doc__
4769         """
4770         S.isspace() -&gt; bool
4771         
4772         Return True if all characters in S are whitespace
4773         and there is at least one character in S, False otherwise.
4774         """
4775         return False
4776 
4777     def istitle(self): # real signature unknown; restored from __doc__
4778         """
4779         S.istitle() -&gt; bool
4780         
4781         Return True if S is a titlecased string and there is at least one
4782         character in S, i.e. upper- and titlecase characters may only
4783         follow uncased characters and lowercase characters only cased ones.
4784         Return False otherwise.
4785         """
4786         return False
4787 
4788     def isupper(self): # real signature unknown; restored from __doc__
4789         """
4790         S.isupper() -&gt; bool
4791         
4792         Return True if all cased characters in S are uppercase and there is
4793         at least one cased character in S, False otherwise.
4794         """
4795         return False
4796 
4797     def join(self, iterable): # real signature unknown; restored from __doc__
4798         """
4799         S.join(iterable) -&gt; unicode
4800         
4801         Return a string which is the concatenation of the strings in the
4802         iterable.  The separator between elements is S.
4803         """
4804         return u""
4805 
4806     def ljust(self, width, fillchar=None): # real signature unknown; restored from __doc__
4807         """
4808         S.ljust(width[, fillchar]) -&gt; int
4809         
4810         Return S left-justified in a Unicode string of length width. Padding is
4811         done using the specified fill character (default is a space).
4812         """
4813         return 0
4814 
4815     def lower(self): # real signature unknown; restored from __doc__
4816         """
4817         S.lower() -&gt; unicode
4818         
4819         Return a copy of the string S converted to lowercase.
4820         """
4821         return u""
4822 
4823     def lstrip(self, chars=None): # real signature unknown; restored from __doc__
4824         """
4825         S.lstrip([chars]) -&gt; unicode
4826         
4827         Return a copy of the string S with leading whitespace removed.
4828         If chars is given and not None, remove characters in chars instead.
4829         If chars is a str, it will be converted to unicode before stripping
4830         """
4831         return u""
4832 
4833     def partition(self, sep): # real signature unknown; restored from __doc__
4834         """
4835         S.partition(sep) -&gt; (head, sep, tail)
4836         
4837         Search for the separator sep in S, and return the part before it,
4838         the separator itself, and the part after it.  If the separator is not
4839         found, return S and two empty strings.
4840         """
4841         pass
4842 
4843     def replace(self, old, new, count=None): # real signature unknown; restored from __doc__
4844         """
4845         S.replace(old, new[, count]) -&gt; unicode
4846         
4847         Return a copy of S with all occurrences of substring
4848         old replaced by new.  If the optional argument count is
4849         given, only the first count occurrences are replaced.
4850         """
4851         return u""
4852 
4853     def rfind(self, sub, start=None, end=None): # real signature unknown; restored from __doc__
4854         """
4855         S.rfind(sub [,start [,end]]) -&gt; int
4856         
4857         Return the highest index in S where substring sub is found,
4858         such that sub is contained within S[start:end].  Optional
4859         arguments start and end are interpreted as in slice notation.
4860         
4861         Return -1 on failure.
4862         """
4863         return 0
4864 
4865     def rindex(self, sub, start=None, end=None): # real signature unknown; restored from __doc__
4866         """
4867         S.rindex(sub [,start [,end]]) -&gt; int
4868         
4869         Like S.rfind() but raise ValueError when the substring is not found.
4870         """
4871         return 0
4872 
4873     def rjust(self, width, fillchar=None): # real signature unknown; restored from __doc__
4874         """
4875         S.rjust(width[, fillchar]) -&gt; unicode
4876         
4877         Return S right-justified in a Unicode string of length width. Padding is
4878         done using the specified fill character (default is a space).
4879         """
4880         return u""
4881 
4882     def rpartition(self, sep): # real signature unknown; restored from __doc__
4883         """
4884         S.rpartition(sep) -&gt; (head, sep, tail)
4885         
4886         Search for the separator sep in S, starting at the end of S, and return
4887         the part before it, the separator itself, and the part after it.  If the
4888         separator is not found, return two empty strings and S.
4889         """
4890         pass
4891 
4892     def rsplit(self, sep=None, maxsplit=None): # real signature unknown; restored from __doc__
4893         """
4894         S.rsplit([sep [,maxsplit]]) -&gt; list of strings
4895         
4896         Return a list of the words in S, using sep as the
4897         delimiter string, starting at the end of the string and
4898         working to the front.  If maxsplit is given, at most maxsplit
4899         splits are done. If sep is not specified, any whitespace string
4900         is a separator.
4901         """
4902         return []
4903 
4904     def rstrip(self, chars=None): # real signature unknown; restored from __doc__
4905         """
4906         S.rstrip([chars]) -&gt; unicode
4907         
4908         Return a copy of the string S with trailing whitespace removed.
4909         If chars is given and not None, remove characters in chars instead.
4910         If chars is a str, it will be converted to unicode before stripping
4911         """
4912         return u""
4913 
4914     def split(self, sep=None, maxsplit=None): # real signature unknown; restored from __doc__
4915         """
4916         S.split([sep [,maxsplit]]) -&gt; list of strings
4917         
4918         Return a list of the words in S, using sep as the
4919         delimiter string.  If maxsplit is given, at most maxsplit
4920         splits are done. If sep is not specified or is None, any
4921         whitespace string is a separator and empty strings are
4922         removed from the result.
4923         """
4924         return []
4925 
4926     def splitlines(self, keepends=False): # real signature unknown; restored from __doc__
4927         """
4928         S.splitlines(keepends=False) -&gt; list of strings
4929         
4930         Return a list of the lines in S, breaking at line boundaries.
4931         Line breaks are not included in the resulting list unless keepends
4932         is given and true.
4933         """
4934         return []
4935 
4936     def startswith(self, prefix, start=None, end=None): # real signature unknown; restored from __doc__
4937         """
4938         S.startswith(prefix[, start[, end]]) -&gt; bool
4939         
4940         Return True if S starts with the specified prefix, False otherwise.
4941         With optional start, test S beginning at that position.
4942         With optional end, stop comparing S at that position.
4943         prefix can also be a tuple of strings to try.
4944         """
4945         return False
4946 
4947     def strip(self, chars=None): # real signature unknown; restored from __doc__
4948         """
4949         S.strip([chars]) -&gt; unicode
4950         
4951         Return a copy of the string S with leading and trailing
4952         whitespace removed.
4953         If chars is given and not None, remove characters in chars instead.
4954         If chars is a str, it will be converted to unicode before stripping
4955         """
4956         return u""
4957 
4958     def swapcase(self): # real signature unknown; restored from __doc__
4959         """
4960         S.swapcase() -&gt; unicode
4961         
4962         Return a copy of S with uppercase characters converted to lowercase
4963         and vice versa.
4964         """
4965         return u""
4966 
4967     def title(self): # real signature unknown; restored from __doc__
4968         """
4969         S.title() -&gt; unicode
4970         
4971         Return a titlecased version of S, i.e. words start with title case
4972         characters, all remaining cased characters have lower case.
4973         """
4974         return u""
4975 
4976     def translate(self, table): # real signature unknown; restored from __doc__
4977         """
4978         S.translate(table) -&gt; unicode
4979         
4980         Return a copy of the string S, where all characters have been mapped
4981         through the given translation table, which must be a mapping of
4982         Unicode ordinals to Unicode ordinals, Unicode strings or None.
4983         Unmapped characters are left untouched. Characters mapped to None
4984         are deleted.
4985         """
4986         return u""
4987 
4988     def upper(self): # real signature unknown; restored from __doc__
4989         """
4990         S.upper() -&gt; unicode
4991         
4992         Return a copy of S converted to uppercase.
4993         """
4994         return u""
4995 
4996     def zfill(self, width): # real signature unknown; restored from __doc__
4997         """
4998         S.zfill(width) -&gt; unicode
4999         
5000         Pad a numeric string S with zeros on the left, to fill a field
5001         of the specified width. The string S is never truncated.
5002         """
5003         return u""
5004 
5005     def _formatter_field_name_split(self, *args, **kwargs): # real signature unknown
5006         pass
5007 
5008     def _formatter_parser(self, *args, **kwargs): # real signature unknown
5009         pass
5010 
5011     def __add__(self, y): # real signature unknown; restored from __doc__
5012         """ x.__add__(y) &lt;==&gt; x+y """
5013         pass
5014 
5015     def __contains__(self, y): # real signature unknown; restored from __doc__
5016         """ x.__contains__(y) &lt;==&gt; y in x """
5017         pass
5018 
5019     def __eq__(self, y): # real signature unknown; restored from __doc__
5020         """ x.__eq__(y) &lt;==&gt; x==y """
5021         pass
5022 
5023     def __format__(self, format_spec): # real signature unknown; restored from __doc__
5024         """
5025         S.__format__(format_spec) -&gt; unicode
5026         
5027         Return a formatted version of S as described by format_spec.
5028         """
5029         return u""
5030 
5031     def __getattribute__(self, name): # real signature unknown; restored from __doc__
5032         """ x.__getattribute__('name') &lt;==&gt; x.name """
5033         pass
5034 
5035     def __getitem__(self, y): # real signature unknown; restored from __doc__
5036         """ x.__getitem__(y) &lt;==&gt; x[y] """
5037         pass
5038 
5039     def __getnewargs__(self, *args, **kwargs): # real signature unknown
5040         pass
5041 
5042     def __getslice__(self, i, j): # real signature unknown; restored from __doc__
5043         """
5044         x.__getslice__(i, j) &lt;==&gt; x[i:j]
5045                    
5046                    Use of negative indices is not supported.
5047         """
5048         pass
5049 
5050     def __ge__(self, y): # real signature unknown; restored from __doc__
5051         """ x.__ge__(y) &lt;==&gt; x&gt;=y """
5052         pass
5053 
5054     def __gt__(self, y): # real signature unknown; restored from __doc__
5055         """ x.__gt__(y) &lt;==&gt; x&gt;y """
5056         pass
5057 
5058     def __hash__(self): # real signature unknown; restored from __doc__
5059         """ x.__hash__() &lt;==&gt; hash(x) """
5060         pass
5061 
5062     def __init__(self, string=u'', encoding=None, errors='strict'): # known special case of unicode.__init__
5063         """
5064         unicode(object='') -&gt; unicode object
5065         unicode(string[, encoding[, errors]]) -&gt; unicode object
5066         
5067         Create a new Unicode object from the given encoded string.
5068         encoding defaults to the current default string encoding.
5069         errors can be 'strict', 'replace' or 'ignore' and defaults to 'strict'.
5070         # (copied from class doc)
5071         """
5072         pass
5073 
5074     def __len__(self): # real signature unknown; restored from __doc__
5075         """ x.__len__() &lt;==&gt; len(x) """
5076         pass
5077 
5078     def __le__(self, y): # real signature unknown; restored from __doc__
5079         """ x.__le__(y) &lt;==&gt; x&lt;=y """
5080         pass
5081 
5082     def __lt__(self, y): # real signature unknown; restored from __doc__
5083         """ x.__lt__(y) &lt;==&gt; x&lt;y """
5084         pass
5085 
5086     def __mod__(self, y): # real signature unknown; restored from __doc__
5087         """ x.__mod__(y) &lt;==&gt; x%y """
5088         pass
5089 
5090     def __mul__(self, n): # real signature unknown; restored from __doc__
5091         """ x.__mul__(n) &lt;==&gt; x*n """
5092         pass
5093 
5094     @staticmethod # known case of __new__
5095     def __new__(S, *more): # real signature unknown; restored from __doc__
5096         """ T.__new__(S, ...) -&gt; a new object with type S, a subtype of T """
5097         pass
5098 
5099     def __ne__(self, y): # real signature unknown; restored from __doc__
5100         """ x.__ne__(y) &lt;==&gt; x!=y """
5101         pass
5102 
5103     def __repr__(self): # real signature unknown; restored from __doc__
5104         """ x.__repr__() &lt;==&gt; repr(x) """
5105         pass
5106 
5107     def __rmod__(self, y): # real signature unknown; restored from __doc__
5108         """ x.__rmod__(y) &lt;==&gt; y%x """
5109         pass
5110 
5111     def __rmul__(self, n): # real signature unknown; restored from __doc__
5112         """ x.__rmul__(n) &lt;==&gt; n*x """
5113         pass
5114 
5115     def __sizeof__(self): # real signature unknown; restored from __doc__
5116         """ S.__sizeof__() -&gt; size of S in memory, in bytes """
5117         pass
5118 
5119     def __str__(self): # real signature unknown; restored from __doc__
5120         """ x.__str__() &lt;==&gt; str(x) """
5121         pass
5122 
5123 
5124 class xrange(object):
5125     """
5126     xrange(stop) -&gt; xrange object
5127     xrange(start, stop[, step]) -&gt; xrange object
5128     
5129     Like range(), but instead of returning a list, returns an object that
5130     generates the numbers in the range on demand.  For looping, this is 
5131     slightly faster than range() and more memory efficient.
5132     """
5133     def __getattribute__(self, name): # real signature unknown; restored from __doc__
5134         """ x.__getattribute__('name') &lt;==&gt; x.name """
5135         pass
5136 
5137     def __getitem__(self, y): # real signature unknown; restored from __doc__
5138         """ x.__getitem__(y) &lt;==&gt; x[y] """
5139         pass
5140 
5141     def __init__(self, stop): # real signature unknown; restored from __doc__
5142         pass
5143 
5144     def __iter__(self): # real signature unknown; restored from __doc__
5145         """ x.__iter__() &lt;==&gt; iter(x) """
5146         pass
5147 
5148     def __len__(self): # real signature unknown; restored from __doc__
5149         """ x.__len__() &lt;==&gt; len(x) """
5150         pass
5151 
5152     @staticmethod # known case of __new__
5153     def __new__(S, *more): # real signature unknown; restored from __doc__
5154         """ T.__new__(S, ...) -&gt; a new object with type S, a subtype of T """
5155         pass
5156 
5157     def __reduce__(self, *args, **kwargs): # real signature unknown
5158         pass
5159 
5160     def __repr__(self): # real signature unknown; restored from __doc__
5161         """ x.__repr__() &lt;==&gt; repr(x) """
5162         pass
5163 
5164     def __reversed__(self, *args, **kwargs): # real signature unknown
5165         """ Returns a reverse iterator. """
5166         pass
5167 
5168 
5169 # variables with complex values
5170 
5171 Ellipsis = None # (!) real value is ''
5172 
5173 NotImplemented = None # (!) real value is ''</code>
</pre> 
 </div> 
</div>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/f2657efc3b44be1e5944a5647b1e3073/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">RSTP 详细</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/db3f53ddb729edce96ad35cb12e8cf1b/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">Lightgbm算法</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>