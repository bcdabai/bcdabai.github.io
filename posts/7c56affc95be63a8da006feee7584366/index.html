<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>AD2428W手册解读之操作与配置 - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="AD2428W手册解读之操作与配置" />
<meta property="og:description" content="A2B总线是高级可编程的，可以处理许多用例。A2B系统很容易配置，基于系统、节点和外设的知识。准确的系统配置可以通过从每个从属服务器单独收集信息来获得。例如，相同的A2B模块可以由不同的供应商提供，每个模块都有独特的寄存器编程要求。一个模块可以使用TDM4作为音频接口，而另一个模块使用TDM8。一个模块可以提供两个上游通道，而另一个模块可以提供三个上游通道，所有这些通道的主机事先都不知道连接了多少节点。
注意：确保寄存器编程的结果是有效的系统配置。
Analog Devices提供免费的SigmaStudioTM (http://www.analog.com/SigmaStudio)工具，具有直观的图形用户界面来构建、配置和设置A2B总线。这些工具还为嵌入式软件生成驱动程序代码。
Linux和QNX软件驱动程序也可根据要求提供。
1、I2C端口编程概念 上位机收发寄存器由A2B主机通过I2C端口使用I2C寄存器直接访问编程实现。从节点上的I2C连接控制器也可以以这种方式对从节点启用的收发器寄存器进行编程;然而，A2B从收发器寄存器通常是由A2B主机通过主收发器在A2B总线上使用远程从收发器I2C寄存器访问来远程编程的。此外，如果从端收发器与从节点上的I2C从端设备进行了本地连接，那么A2B主机也可以通过A2B总线使用远程外设I2C远程访问已连接的I2C从端设备。I2C访问编程顺序图是对收发机寄存器编程和访问I2C外围设备从节点所需要的编程顺序的图形表示。
I2C接口编程顺序
在I2C接入编程顺序图中：
1、I2C ADDR为主收发器I2C设备地址：
1）、直接I2C寄存器使用BASE_ADDR (I2C ADDR: BASE)访问主收发器。
2）、远程从I2C寄存器访问从收发器，远程外围I2C访问I2C从节点上连接的外围设
备使用BUS_ADDR（I2C ADDR：BUS）。
注意：有关BASE_ADDR和BUS_ADDR的更多详细信息，请参阅收发器I2C访问章
节。
2、NODEADR是主收发器A2B_NODEADR寄存器：
1）、NODE是A2B_NODEADR.NODE字段。
2）、 PERI 是A2B_NODEADR.PERI位。
3、CHIP是A2B_CHIP寄存器：
1）、黑色文本表示A2B_CHIP寄存器本身。
2）、蓝色文本表示A2B_CHIP寄存器的值。
1.1、直接I2C寄存器访问 无论收发器配置为master还是slave, I2C端口都可以直接访问收发器寄存器空间：
1、在主节点上，A2B主机使用该方法直接访问主收发器寄存器空间。
2、在从节点上，本地连接的I2C主机使用该方法直接访问从收发器寄存器空间。
如图《I2C访问编程顺序图》中的I2C主收发器寄存器访问部分所示，主收发器寄存器访问要求从主机传输的I2C数据包括主收发器I2C设备地址(I2C ADDR: BASE = BASE_ADDR)，然后是寄存器地址(ADDR)，最后是与主收发器寄存器相关联的数据(R/W data)。详细信息请参见收发器I2C访问章节。
注意：主I2C访问序列对于从节点上直接访问从收发器寄存器空间的I2C连接主机是相同的。
1.2、远程从I2C寄存器访问 虽然从节点上本地连接的I2C主机可以直接通过I2C端口对从收发器寄存器进行编程，但A2B系统通常由主节点上的A2B主机完全配置。如图《I2C接入编程顺序图》中的Slave 0 I2C接入部分所示，A2B主机首先直接配置主收发器，然后通过A2B总线远程I2C接入对特定的Slave收发器进行编程。A2B主机必须使用以下编程顺序从主节点通过A2B总线远程访问A2B从收发器寄存器空间。
1、使用直接I2C寄存器访问来设置主收发器A2B_NODEADR。NODE字段表示要访问的从节点ID。确保a2b_noder。在这个写操作中，PERI位设置为0，以便后续总线访问的目标是指定的从属收发器寄存器空间，而不是连接到指定从属器的I2C外围设备。
附加信息：设置 A2B_NODEADR.NODE字段为0意味着后续总线访问将以从节点0为目标。如果该字段设置为1，则后续总线访问将以从节点1为目标。如果意图将写操作广播到所有发现的节点(主节点和从节点)，请确保还设置了广播位(A2B_NODEADR.BRCST)。
2、要访问从收发器寄存器，主机的I2C传输包括主收发器的总线地址(I2C ADDR: BUS = BUS_ADDR)，然后是从收发器寄存器地址(ADDR)，最后是与从收发器寄存器相关联的数据(data)。详细信息请参见收发器I2C访问章节。
1.3、远程外围I2C访问 《I2C接入编程顺序》中的“从机1 I2C外设接入”部分，以A2B总线为例，说明A2B主机通过远程外设I2C接入方式，访问与从机I2C端口相连的外设的顺序。A2B主机必须按照以下编程顺序通过A2B总线访问A2B从节点上的I2C外设(例如，麦克风或DAC)。
1、使用直接I2C寄存器访问写访问来设置主收发器A2B_NODEADR.NODE字段表示连接到要访问的外围设备的从节点ID。确保A2B_NODEADR.PERI位在写入过程中被清除，以便随后的总线访问是到目标接收器的寄存器空间，而不是到从外设本身。
附加信息：在这个写操作中将A2B_NODEADR.NODE.NODE字段设置为1，以便后续总线访问目标从节点1。如果意图将外围设备写入广播到所有发现的节点(主节点和从节点)，请确保还设置A2B_NODEADR.BRCST位。如果目标从收发器中的A2B_CHIP寄存器已经设置为预期外围访问的I2C地址，那么使用A2B_NODEADR执行这个写操作。PERI位设置(而不是清除)，并直接进入最后一步。
2、使用远程从I2C寄存器访问用与从机相连的外围设备的I2C设备地址对所需的从机收发器的A2B_CHIP寄存器进行写访问。
3、使用直接I2C寄存器访问写访问来设置主收发器A2B_NODEADR.PERI位(同时维护A2B_NODEADR.NODE字段的内容。)，以便后续的BUS_ADDR访问到所需的从节点I2C外围设备。
4、要访问从节点外围设备，来自主机的I2C传输必须包含主收发器的BUS_ADDR (I2C ADDR: BUS)，然后是从收发器用来访问从节点I2C外围设备的地址(ADDR)，最后是与地址相关的数据(Data)。
2、系统启动和发现 A2B系统由A2B主机组成。正确地建立电源之后，必须发现系统中的每个节点并按顺序进行配置，从主节点开始。
2.1、复位和操作状态 PLL锁的丢失将重置除A2B_BMMCFG和A2B_CONTROL.MSTR之外的所有寄存器信息。收发器状态图显示了收发器状态信息，在启动和运行一个完整的A2B系统时，了解这些信息非常重要。
收发器状态机" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/7c56affc95be63a8da006feee7584366/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-02-06T21:00:38+08:00" />
<meta property="article:modified_time" content="2023-02-06T21:00:38+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">AD2428W手册解读之操作与配置</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p>        A2B总线是高级可编程的，可以处理许多用例。A2B系统很容易配置，基于系统、节点和外设的知识。准确的系统配置可以通过从每个从属服务器单独收集信息来获得。例如，相同的A2B模块可以由不同的供应商提供，每个模块都有独特的寄存器编程要求。一个模块可以使用TDM4作为音频接口，而另一个模块使用TDM8。一个模块可以提供两个上游通道，而另一个模块可以提供三个上游通道，所有这些通道的主机事先都不知道连接了多少节点。</p> 
<p>       <strong> 注意：</strong>确保寄存器编程的结果是有效的系统配置。</p> 
<p>        Analog Devices提供免费的SigmaStudioTM (http://www.analog.com/SigmaStudio)工具，具有直观的图形用户界面来构建、配置和设置A2B总线。这些工具还为嵌入式软件生成驱动程序代码。</p> 
<p>        Linux和QNX软件驱动程序也可根据要求提供。</p> 
<h2><strong>1、I2C端口编程概念</strong></h2> 
<p>        上位机收发寄存器由A2B主机通过I2C端口使用I2C寄存器直接访问编程实现。从节点上的I2C连接控制器也可以以这种方式对从节点启用的收发器寄存器进行编程;然而，A2B从收发器寄存器通常是由A2B主机通过主收发器在A2B总线上使用远程从收发器I2C寄存器访问来远程编程的。此外，如果从端收发器与从节点上的I2C从端设备进行了本地连接，那么A2B主机也可以通过A2B总线使用远程外设I2C远程访问已连接的I2C从端设备。I2C访问编程顺序图是对收发机寄存器编程和访问I2C外围设备从节点所需要的编程顺序的图形表示。</p> 
<p class="img-center"><img alt="" height="453" src="https://images2.imgbox.com/fd/ee/PmjjgouX_o.png" width="808"></p> 
<p style="text-align:center;"><strong> I2C接口编程顺序</strong></p> 
<p>        在I2C接入编程顺序图中：</p> 
<p>                1、I2C ADDR为主收发器I2C设备地址：</p> 
<p>                        1）、直接I2C寄存器使用BASE_ADDR (I2C ADDR: BASE)访问主收发器。</p> 
<p>                        2）、远程从I2C寄存器访问从收发器，远程外围I2C访问I2C从节点上连接的外围设<br>                 备使用BUS_ADDR（I2C ADDR：BUS）。</p> 
<p><strong>                        注意：</strong>有关BASE_ADDR和BUS_ADDR的更多详细信息，请参阅<strong>收发器I2C访问章<br>                 节。</strong></p> 
<p>                2、NODEADR是主收发器A2B_NODEADR寄存器：</p> 
<p>                        1）、NODE是A2B_NODEADR.NODE字段。</p> 
<p>                        2）、 PERI 是A2B_NODEADR.PERI位。</p> 
<p>                3、CHIP是A2B_CHIP寄存器：</p> 
<p>                        1）、黑色文本表示A2B_CHIP寄存器本身。</p> 
<p>                        2）、蓝色文本表示A2B_CHIP寄存器的值。</p> 
<h3>1.1、直接I2C寄存器访问</h3> 
<p>        无论收发器配置为master还是slave, I2C端口都可以直接访问收发器寄存器空间：</p> 
<p>                1、在主节点上，A2B主机使用该方法直接访问主收发器寄存器空间。</p> 
<p>                2、在从节点上，本地连接的I2C主机使用该方法直接访问从收发器寄存器空间。</p> 
<p>        如图《I2C访问编程顺序图》中的I2C主收发器寄存器访问部分所示，主收发器寄存器访问要求从主机传输的I2C数据包括主收发器I2C设备地址(I2C ADDR: BASE = BASE_ADDR)，然后是寄存器地址(ADDR)，最后是与主收发器寄存器相关联的数据(R/W data)。详细信息请参见收发器I2C访问章节。</p> 
<p>        <strong>注意：</strong>主I2C访问序列对于从节点上直接访问从收发器寄存器空间的I2C连接主机是相同的。</p> 
<h3>1.2、远程从I2C寄存器访问</h3> 
<p>        虽然从节点上本地连接的I2C主机可以直接通过I2C端口对从收发器寄存器进行编程，但A2B系统通常由主节点上的A2B主机完全配置。如图《I2C接入编程顺序图》中的Slave 0 I2C接入部分所示，A2B主机首先直接配置主收发器，然后通过A2B总线远程I2C接入对特定的Slave收发器进行编程。A2B主机必须使用以下编程顺序从主节点通过A2B总线远程访问A2B从收发器寄存器空间。</p> 
<p>        1、使用直接I2C寄存器访问来设置主收发器A2B_NODEADR。NODE字段表示要访问的从节点ID。确保a2b_noder。在这个写操作中，PERI位设置为0，以便后续总线访问的目标是指定的从属收发器寄存器空间，而不是连接到指定从属器的I2C外围设备。</p> 
<p>        <strong>附加信息：</strong>设置 A2B_NODEADR.NODE字段为0意味着后续总线访问将以从节点0为目标。如果该字段设置为1，则后续总线访问将以从节点1为目标。如果意图将写操作广播到所有发现的节点(主节点和从节点)，请确保还设置了广播位(A2B_NODEADR.BRCST)。</p> 
<p>        2、要访问从收发器寄存器，主机的I2C传输包括主收发器的总线地址(I2C ADDR: BUS = BUS_ADDR)，然后是从收发器寄存器地址(ADDR)，最后是与从收发器寄存器相关联的数据(data)。详细信息请参见收发器I2C访问章节。</p> 
<h3>1.3、远程外围I2C访问</h3> 
<p>        《I2C接入编程顺序》中的“从机1 I2C外设接入”部分，以A2B总线为例，说明A2B主机通过远程外设I2C接入方式，访问与从机I2C端口相连的外设的顺序。A2B主机必须按照以下编程顺序通过A2B总线访问A2B从节点上的I2C外设(例如，麦克风或DAC)。</p> 
<p>        1、使用直接I2C寄存器访问写访问来设置主收发器A2B_NODEADR.NODE字段表示连接到要访问的外围设备的从节点ID。确保A2B_NODEADR.PERI位在写入过程中被清除，以便随后的总线访问是到目标接收器的寄存器空间，而不是到从外设本身。</p> 
<p>       <strong> 附加信息：</strong>在这个写操作中将A2B_NODEADR.NODE.NODE字段设置为1，以便后续总线访问目标从节点1。如果意图将外围设备写入广播到所有发现的节点(主节点和从节点)，请确保还设置A2B_NODEADR.BRCST位。如果目标从收发器中的A2B_CHIP寄存器已经设置为预期外围访问的I2C地址，那么使用A2B_NODEADR执行这个写操作。PERI位设置(而不是清除)，并直接进入最后一步。</p> 
<p>        2、使用远程从I2C寄存器访问用与从机相连的外围设备的I2C设备地址对所需的从机收发器的A2B_CHIP寄存器进行写访问。</p> 
<p>        3、使用直接I2C寄存器访问写访问来设置主收发器A2B_NODEADR.PERI位(同时维护A2B_NODEADR.NODE字段的内容。)，以便后续的BUS_ADDR访问到所需的从节点I2C外围设备。</p> 
<p>        4、要访问从节点外围设备，来自主机的I2C传输必须包含主收发器的BUS_ADDR (I2C ADDR: BUS)，然后是从收发器用来访问从节点I2C外围设备的地址(ADDR)，最后是与地址相关的数据(Data)。</p> 
<h2>2、系统启动和发现</h2> 
<p>        A2B系统由A2B主机组成。正确地建立电源之后，必须发现系统中的每个节点并按顺序进行配置，从主节点开始。</p> 
<h3>2.1、复位和操作状态</h3> 
<p>        PLL锁的丢失将重置除A2B_BMMCFG和A2B_CONTROL.MSTR之外的所有寄存器信息。收发器状态图显示了收发器状态信息，在启动和运行一个完整的A2B系统时，了解这些信息非常重要。</p> 
<p class="img-center"><img alt="" height="249" src="https://images2.imgbox.com/ec/03/6yNfPpk1_o.png" width="544"></p> 
<p style="text-align:center;"><strong>收发器状态机</strong></p> 
<p>        <strong>注意：</strong>由于维持模式是一个只有从机的特性，主收发机永远不会进入维持状态。主收发器上的锁相环丢失将导致直接返回上电状态。</p> 
<h4>2.1.1、收发器上电和复位</h4> 
<p>        收发器刚上电时，处于RESET状态。当处于RESET状态时，所有A2B系统寄存器都处于复位状态，直到收发器进入POWER-UP RESET状态，才可以对寄存器进行编程，这是收发器功率(VIN)的函数。</p> 
<p>        一个内部上电复位电路监控VIN电源引脚的状态保持一个内部上电复位信号(PORST)低断言直到VRSTN规范满足，此时PORST被去断言高，表明收发器正常供电。然后收发器转换到POWER-UP  RESET状态。收发器进入POWER-UP RESET后，除非VIN电源引脚上感知到的电压下降到其VRST规格范围内，否则PORST信号保持去断言高，在这种情况下，将PORST断言低，使收发器返回RESET。</p> 
<h3>2.2、主机启动和操作</h3> 
<p>        根据收发器状态图，当收发器跃迁到POWER-UP RESET状态时，锁存ADR1/IO1和ADR2/IO2引脚，确定I2C设备地址，且收发器在2.5 ms内可访问I2C设备。然后通过A2B_CONTROL.MSTR位将设备设置为主节点，再以系统的音频采样率(可在48 kHz或44.1 kHz之间选择)驱动SYNC引脚。主收发器根据锁相环锁定时间(tPLK)规范将其锁相环锁定到接收到的同步信号上。</p> 
<p><strong>        注意：</strong>建议主机设置的超时时间超过PLL锁定时间(tPLK)规格，以便软件可以检测到没有响应的主收发器。</p> 
<p>        PLL锁定后，主收发器转换到节点就绪PLL锁定状态，此时向主机生成MSTR_RUNNING（0xFF）中断（IRQ/IO0引脚被驱动为高电平），该中断存储在中断类型寄存器（A2B_INTTYPE）中，指示主收发器已准备好通过I2C进行编程界面。</p> 
<p>        <strong>注意：</strong>一旦锁相环被锁定，写入A2B_CONTROL.MSTR位无效。</p> 
<p>        如果主收发器锁相环在总线运行期间被解锁，收发器返回到POWER-UP状态，因为SUSTAIN状态是一个仅从特性(SUSTAIN = 0)。除A2B_CONTROL寄存器外，所有寄存器返回到它们的重置值。</p> 
<h3>2.3、从机启动和操作</h3> 
<p>        根据收发器状态机，本地或A2B总线电源建立后，收发器处于POWER-UP RESET状态，锁存ADR1/IO1和ADR2/IO2引脚，确定I2C设备地址。收发器默认为从属器，在进入POWERUP RESET后2.5 ms即可被发现和编程。</p> 
<p>        <strong>注意：</strong>在上电复位状态下，BCLK和SYNC输出有三种状态。、</p> 
<p>        在POWER-UP RESETRESET状态下，本地连接的主机可以通过I2C端口使用I2C直接注册访问（直接I2C寄存器访问）配置从收发器寄存器空间的子集。这些记录包括:</p> 
<p class="img-center"><img alt="" height="374" src="https://images2.imgbox.com/07/15/rSR88KIL_o.png" width="813"></p> 
<p>         尽管这些寄存器可以在POWER-UP RESET状态下写入，但编程值直到收发器进入NODE READY PLL LOCKED状态才会生效，除了插槽寄存器(A2B_BCDNSLOTS，A2B_LDNSLOTS，A2B_LUPSLOTS，A2B_DNSLOTS，A2B_UPSLOTS，A2B_UPMASK0到A2B_UPMASK3和A2B_DNMASK0到A2B_DNMASK3)。在主收发器A2B_DATCTL寄存器被编程并且新结构随后被应用(A2B_CONTROL.NEWSTRCT = 1)。</p> 
<p>        在POWER-UP RESET状态下，从端收发器等待来自主机的同步控制帧（SCFs），当主机通过设置主端收发器的A2B_DISCVRY寄存器为目标从端响应时间来启动特定的A2B系统从端发现进程时，就会启动同步控制帧。当发生写操作时，主机通过发送包含SCF中嵌入的响应时间值的发现帧来启动发现。被发现的从机然后提取信息来设置它的响应时间(A2B_RESPCYCS)。这些发现帧向从属收发器提供输入时钟，从属收发器根据锁相环锁定时间(tPLK)规范将其锁相环锁定。一旦从收发器锁相环被锁定，它就处于NODE READY锁相环锁定状态，并开始向上游节点生成同步响应帧(srf)，这导致主收发器产生DSCDONE中断(A2B_INTTYPE = 0x18)，表明从收发器已经准备好使用远程从I2C寄存器访问在A2B总线上编程。</p> 
<p><strong>        注意：</strong>当从A2B总线(使用远程I2C寄存器访问)和I2C端口(使用直接I2C寄存器访问)同时尝试写<br>                 同一个寄存器时，无法预测这些I2C访问发生的顺序。因此，当I2C事务同时来自两个来<br>                 源时，必须特别注意。</p> 
<p>        <strong>提示：</strong>如果需要在应用程序中进行本地节点编程(使用直接I2C注册访问)，那么可以通过与主<br>                 节点使用邮箱握手来避免这种潜在的争用，这样，当主机准备开始进行注册访问时，就<br>                 写入从节点的一个邮箱，然后等待从节点读取该邮箱，以表明其初始化序列已经完成。<br>                 有关详细信息，请参阅邮箱。</p> 
<p>        在NODE READY PLL LOCKED状态下，BCLK和SYNC输出被低电平驱动，直到从收发器的A2B_PDMCTL(用于PDM模式)或A2B_I2SCFG(用于I2S/TDM模式)寄存器中的任何I2S/TDM/PDM端口数据引脚被启用。</p> 
<p>        如果从收发器锁相环在总线运行期间解锁，如果时钟维持功能被禁用，它会回到POWER-UP状态（A2B_SUSCFG.SUSDIS = 1, 在收发器状态图中SUSTAIN = 0）。一旦回到RESET状态，主机就可以发出另一个发现序列：</p> 
<p>                1、以当前时钟频率运行1024个SYNC周期:</p> 
<p>                        1)、I2S/TDM端口继续运行。</p> 
<p>                        2）、如果启用GPIO上将是SUSTAIN状态。</p> 
<p>                        3）、在SUSTAIN状态将不会重新尝试锁定锁相环。</p> 
<p>                2、重置并重新进入POWER-UP状态。</p> 
<p>                3、如果存在稳定的SCF发现帧，则转换到节点就绪锁相环锁定状态</p> 
<p>        如果设置了维持GPIO输出使能(A2B_SUSCFG.SUSOE)位，那么在A2B_SUSCFG选择的GPIO引脚上，PLL的维持信号会被驱动到高电平。当收发机处于维持状态时的SUSSEL位。该特性的优先级高于其他GPIO输出，但低于功能在引脚上的输出。例如，时钟输出1 (A2B_CLK1CFG.CLK1EN = 1)， ADR1/IO1引脚被驱动为时钟输出。设置A2B_SUSCFG.SUSOE位，配置ADR1/IO1引脚(A2B_SUSCFG.SUSSEL = 1)不会覆盖此行为。</p> 
<p>        从锁相环发出的维持信号在超帧开始附近会很高。一旦维持信号高，DTX0/IO3和DTX1/IO4引脚上产生衰减数据值，从下面的I2S/TDM帧开始。</p> 
<p>        从A2B总线接收到的TX帧缓冲区中的数据(参见管理A2B系统数据流)包含一个32位的值，该值输出到I2S DTX0/DTX1数据管脚中的一个或两个。在启用的数据引脚上，负值逐渐衰减为0，而正值逐渐衰减为-109 dB (0x00001F00)。</p> 
<h3>2.4、节点发现和初始化</h3> 
<p>        本节提供关于A2B总线系统的简单节点发现和初始化的信息。《发现流程示例》中描述了修改、优化和高级发现流程。这些软件流程图中的任何一个都可以用作发现和初始化的指导方针。</p> 
<h4><strong>2.4.1、Simple Discovery Flow</strong></h4> 
<p><strong>        </strong>从从0到系统中最后一个可用的从依次发现所有从节点，软件流程如图所示。在这个图中，阶段显示了通过I2C接口在主机和启用主收发器之间发出的命令。写命令标识为“wr”，读命令标识为“rd”，并访问REGISTER_NAME。M表示对BASE_ADDR的访问，S表示对BUS_ADDR的访问</p> 
<p class="img-center"><img alt="" height="807" src="https://images2.imgbox.com/0c/dd/2FZwPCMm_o.png" width="780"></p> 
<p style="text-align:center;"><strong>设备发现流程</strong></p> 
<p>        <strong>注意：</strong>在简单发现流程图中，设置A2B_SWCTL。主节点或任何从节点中的ENSW位导致它<br>                 开始向下游的下一个连接的从节点发送scf，从而允许下一个从收发器在主节点启动针对<br>                 它的发现帧之前开始锁定它的锁相环。</p> 
<p>        对于反向连线特性A2B_CONTROL.XCVRBINV（LVDS XCVRB数据转换）请使用以下指导原则：</p> 
<p>                1、在主节点中，在设置A2B_CONTROL.XCVRBINV位之前设置A2B_SWCTL.ENSW<br>         位，当为其他目的写入A2B_CONTROL寄存器时，例如写入A2B_CONTROL.NEWSTRCT位<br>         时，注意避免无意中清除A2B_CONTROL.XCVRBINV位。</p> 
<p>                2、在任何从节点中，在设置A2B_SWCTL.ENSW位之前，必须先设置<br>         A2B_CONTROL.XCVRBINV。</p> 
<p>        发现所有从节点后，初始化节点以进行同步数据交换。示例流程图从最后一个节点开始初始化，并从主节点结束。</p> 
<p>        发现过程完成得很快，在初始化同步音频之前提供对所有节点及其I2C外设的更早访问，这需要额外的时间来完成。</p> 
<p>        在发现并编程所有节点之后，就不再需要总线管理了。中断服务例程可以用来响应特殊的中断请求(IRQ)事件(例如，来自IO引脚)。另外，可以轮询A2B_INTTYPE寄存器来监视中断事件。</p> 
<p>        优化的发现流程和高级发现流程说明了如何执行自动配置。</p> 
<h4><strong>2.4.2、</strong>响应周期</h4> 
<p>        A2B_RESPCYCS寄存器设置了从同步控制帧(SCF)开始到最后一个slave响应同步响应帧(SRF)的相对时间。寄存器设置向较早的节点指示何时期望来自最后一个从节点的响应。如果最后一个节点没有响应，则假定的最后一个节点旁边的前一个节点会响应。</p> 
<p class="img-center"><img alt="" height="464" src="https://images2.imgbox.com/c9/a0/5TLsQxHA_o.png" width="725"></p> 
<p style="text-align:center;"><strong> 同步数据启用</strong></p> 
<p>        收发器的响应周期值在《附录B：响应周期公式中讨论》，作为以下参数的函数：</p> 
<p>                1、从节点数量。</p> 
<p>                2、下行槽位数。</p> 
<p>                3、下游槽尺寸。</p> 
<p>                4、上行槽位数。</p> 
<p>                5、上游槽尺寸。</p> 
<p>                6、主I2S/TDM信道配置</p> 
<p>        <strong>注意：</strong>主收发信机响应周期值在响应周期计算器电子表格或SigmaStudio软件中使用上述参数<br>                 计算。有关更多信息，请联系您当地的模拟设备代表。</p> 
<h4><strong>2.4.3、</strong>从节点响应周期</h4> 
<p>        从节点响应周期图显示了A和B XCVR上SCF和SRF之间的相对定时从节点的端口。在A XCVR上的SCF启动后，从节点大约生成SRF（（4*A2B\U RESPCYCS）+7）位。例如，当A2B\u RESPCYCS=128（0x80）时，从节点生成SRF从第519位（（4*128）+7=519）开始。</p> 
<p class="img-center"><img alt="" height="152" src="https://images2.imgbox.com/4d/3d/MTAKwmrj_o.png" width="531"></p> 
<p style="text-align:center;"><strong> 从节点响应周期</strong></p> 
<p>        如从节点响应中期示意图所示，在将超级帧从一端传递到另一端的过程中，会产生收发器延迟(TD)。对于超帧的下游部分，从收发器的a端到b端有7(±2)位的延迟(TDDOWN)。相反，在同一超级帧的上游部分，从b端到a端有9(±2)位的延迟(TDUP)。这些延迟汇总为支持的帧速率在T接收机延迟表中，由等式控制：</p> 
<p>                Delay Range = Nominal Latency Range  / (SYNC Rate * 1024) 。</p> 
<p>                延迟范围 = 标称延迟范围 / （同步率 * 1024）。</p> 
<p class="img-center"><img alt="" height="255" src="https://images2.imgbox.com/46/06/ClzQS2Mi_o.png" width="814"></p> 
<p style="text-align:center;"><strong> 传输延迟</strong></p> 
<p>        除了收发器延迟之外，节点之间的电缆延迟(CD)也改变了在超级帧的下游接收到SCF和在同一超级帧的上游部分互补SRF返回到该点之间的相对时间。有一个5位时间窗口（预计位时间±2），其中SRF在B侧正确接收并传递到从节点的a侧。外部的SRF该窗口仍被检测到，预期响应时间由变速器逐渐（自动）调整-接收器在发现期间补偿不匹配，调整范围为-4位到+15位到跨越电缆长度规格。因此，A2B_RESPCYCS公式适用于所有支持的电缆长度。如果在系统设计阶段已知电缆长度，则此建议可应用于所有发现流。如果电缆长度未知，默认响应周期计算(假设电缆长度为4m)是足够的。当使用较长的电缆时，尽管在发现过程中可以观察到一些错误(CRCERR、SRFERR或SRFCRCERR)，但由于这种自动调整能力，在发现完成后，系统可以干净地运行。</p> 
<p>        在发现工作中进行的自动响应周期调整如下：</p> 
<p>                1、主机通过设置A2B_RESPCYCS = 128 (0x80)，使主机在超帧的第519位期望SRF，<br>         如上面((4 * 128)+ 7 = 519)所述。</p> 
<p>                2、当主机将0x80写入其A2B_DISCVRY寄存器时，主节点开始发现从节点0。当从节点<br>         0开始发送srf时，主节点调整其响应时间以与从节点0对齐。</p> 
<p>                短电缆长度(最多20厘米)不会影响主节点在超级帧的519位接收SRF的能力。</p> 
<p>                然而，较长的电缆长度会带来一个物理电缆延迟(CD)，在接收节点捕获SRF的时间为<br>         5ns/m。例如，主节点和从0节点之间的10m电缆会使主节点的SRF接收时间延迟100ns(下行<br>         50ns CD +上行50ns CD)。这100ns的总CD相当于5个A2B位，因此在这种情况下，主节点调<br>         整它的响应周期，以期望SRF位于超帧的524(±2)位。</p> 
<p>                3、当主机向A2B_DISCVRY寄存器写入0x7C时，主节点开始发现从节点1。当从机1开<br>         始发送SRF时，从机0会调整自己的响应时间以与从机1保持一致，这将导致从机0发送的SRF<br>         延迟，从而进一步增加SRF到达主节点的时间延迟。</p> 
<p>                主节点接收SRF, SRF作为主节点与从0之间的CD和从0与从1之间的CD的函数。继续上<br>         面的例子，在从节点0和从节点1之间的第二根10m电缆将主节点的SRF接收时间额外延迟5比<br>         特，从而导致主节点调整其响应周期，以期望在超帧的529(±2)比特处获得SRF。</p> 
<p>        SRF响应图说明了电缆和收发器延迟如何影响SRF响应。在这种情况下，没有观察到SRF错过错误，因为在发现阶段调整了响应周期。</p> 
<p class="img-center"><img alt="" height="337" src="https://images2.imgbox.com/63/00/rf6M0DlH_o.png" width="703"></p> 
<p style="text-align:center;"><strong>SRF响应</strong></p> 
<p>        在这个例子中：</p> 
<p>                1、从节点1是最后一个在线的从节点，它负责启动SRF以开始超帧的上游部分。当使用<br>         A2B_RESPCYCS = 124 (0x7C)编程时，从机1被配置为在超帧((4 * 124)+ 7 = 503)的第503<br>         位生成SRF。</p> 
<p>                2、从上游从0来看，在该超帧的下游部分SCF到达从0 a端收发器与同一超帧的上游部分<br>         相应的SRF出现之间的总时延为430ns(21比特)，包括：</p> 
<p>                        1）、从0 (TDDOWN = 150ns)的下游收发延时，</p> 
<p>                        2）、从站0到从站1之间的下行电缆延迟(CD = 5ns/m × 10m = 50ns)，</p> 
<p>                        3）、slave 1和slave 0之间的上行电缆延迟(CD = 5ns/m × 10m = 50ns)</p> 
<p>                        4）、从0的上游收发器延迟(TDUP = 180ns)。</p> 
<p>                因此，计算从0节点到从1节点的电缆长度为10m时，SCF到达从0 a端收发器与产生SRF<br>         之间的比特数为503 + 21 = 524比特。</p> 
<p>                3、从主节点的角度看，产生SCF和对应的SRF出现在同一超帧的上游部分之间的总延迟<br>         为100ns(5比特)，它由以下部分组成：</p> 
<p>                        1）、主从之间的下行电缆延迟0（CD = 5ns/m x 10m = 50ns）</p> 
<p>                        2）、从0到主设备的上行电缆延时(CD = 5ns/m × 10m = 50ns)</p> 
<p>                因此计算出自SCF场产生到接收到相应的SRF之间的位数为524 + 5 = 529位。</p> 
<h2>3、管理A2B系统数据流</h2> 
<p>        在完整的A2B系统中，每个主收发器和从收发器都必须按照所需的槽位管理方案和格式配置，以便在A2B总线上任意两个收发器之间进行上行和下行流量管理。</p> 
<p>        每个收发器有两个内部框架缓冲器：</p> 
<p>                1、TX帧缓冲区：由A2B总线填充并输出到DTX0和/或DTX1引脚。</p> 
<p>                2、RX帧缓冲器：由DRX0和/或DRX1输入引脚和输出到A2B总线填充</p> 
<p>        这些帧缓冲区在每个超帧期间被填充和清空，下游槽内容占据缓冲区的低阶位置，而上游槽内容占据缓冲区的高阶位置。帧缓冲区深度为32位，宽度为32位，因为任何给定的收发器都可以在A2B总线上占用最多32个槽位，并支持最多32位的数据。</p> 
<p><strong>        注意：</strong>如果配置收发器从A2B总线接收下游和上游槽位之和超过32个，那么与上游槽位相关<br>                 的多余数据将被帧缓冲区丢弃。</p> 
<p>        TX帧缓冲区由A2B总线填充。启用的下游插槽和特定的插槽掩码的数量决定了在超帧的下游部分期间，哪些下游插槽被存储到TX帧缓冲区。同样，上游数据槽的数量和特定的槽掩码决定了哪些上游槽在下游数据完成后被存储到TX帧缓冲区中。然后，这个数据的组合缓冲区被呈现给启用的DTXn数据引脚，作为启用的传输数据引脚数量和是否启用交错的函数。</p> 
<p>        RX帧缓冲区由I2S/TDM端口在启用的DRXn数据引脚上填充。启用接收引脚的数量和交错是否被打开决定了数据如何被放置到RX帧缓冲区。一旦填充了缓冲区，启用的下游插槽和特定的插槽掩码的数量决定了哪些下游插槽在超帧的下游部分被RX帧缓冲区填充。同样，上游数据槽的数量和特定的槽掩码决定了哪些上游数据槽在下游数据发送后被RX帧缓冲区填充。</p> 
<h3>3.1、<strong>dnmaskrx和upmaskrx的定义：</strong></h3> 
<p><strong>        </strong>dnmaskrx值由A2B_DNMASK0到A2B_DNMASK3寄存器的值确定：</p> 
<pre><code class="language-cpp">if (DNMASK3.RXDNSLOT31==1) dnmaskrx = 32;
    else if (DNMASK3.RXDNSLOT30==1) dnmaskrx = 31;
    else if (DNMASK3.RXDNSLOT29==1) dnmaskrx = 30;
    . . .
    else if (DNMASK0.RXDNSLOT02==1) dnmaskrx = 3;
    else if (DNMASK0.RXDNSLOT01==1) dnmaskrx = 2;
    else if (DNMASK0.RXDNSLOT00==1) dnmaskrx = 1;
    else dnmaskrx = 0;</code></pre> 
<p>         upmaskrx值由A2B_UPMASK0到A2B_UPMASK3寄存器的值确定：</p> 
<pre><code class="language-cpp">if (UPMASK3.RXUPSLOT31==1) upmaskrx = 32;
    else if (UPMASK3.RXUPSLOT30==1) upmaskrx = 31;    
    else if (UPMASK3.RXUPSLOT29==1) upmaskrx = 30;
    . . .
    else if (UPMASK0.RXUPSLOT02==1) upmaskrx = 3;
    else if (UPMASK0.RXUPSLOT01==1) upmaskrx = 2;
    else if (UPMASK0.RXUPSLOT00==1) upmaskrx = 1;
    else upmaskrx = 0;</code></pre> 
<h3>3.2、A2B槽格式</h3> 
<p>        上游和下游数据槽的正常(默认)格式是数据后跟一个奇偶校验位。但是，也可以使用支持浮点压缩或ECC保护的替代格式。上游和下游数据槽的大小和格式都使用A2B_SLOTFMT寄存器配置。Slot Format表总结了A2B_SLOTFMT配置的可能数据格式。DNFMT A2B_SLOTFMT.DNSIZE A2B_SLOTFMT.UPFMT和A2B_SLOTFMT.UPSIZE位位。在Slot Format表中，FMT列是A2B_SLOTFMT.DNFMT位或A2B_SLOTFMT.UPFMT位，SIZE列是3位的A2B_SLOTFMT.DNSIZE或A2B_SLOTFMT.UPSIZE字段，取决于它是下游或上游(分别)槽位格式，正在配置。</p> 
<p class="img-center"><img alt="" height="399" src="https://images2.imgbox.com/6d/e7/ZvaZp4Kl_o.png" width="812"></p> 
<p class="img-center"><img alt="" height="90" src="https://images2.imgbox.com/70/69/TOTvR4V1_o.png" width="810"></p> 
<p style="text-align:center;"><strong>槽格式</strong></p> 
<p>       <strong> 说明：</strong>“Slot Format”表中的“I2S/TDM Data Width”列表示I2S/TDM/PDM端口实际交换的数据宽度，格式为“MSB-first”。这个列中8到16位数据宽度的用例可以选择设置A2B_I2SGCFG.TDMSS位在I2S/TDM/PDM端口上利用16位TDM通道数据宽度。20-32位的数据宽度需要清除的A2B_I2SGCFG.TDMSS位(32位TDM通道数据宽度)。详细信息请参见I2S/TDM端口编程概念。</p> 
<h3>3.3、ECC保护</h3> 
<p>        收发器支持24位和32位数据，并对A2B总线数据槽进行ECC保护。</p> 
<p><strong>        注意：</strong>如Slot Format表所示，24位ECC为6位，32位ECC为7位。</p> 
<p>        ECC保护在存在强噪声干扰(短于超帧)的环境中是有用的，否则会产生误码。ECC可以用于音频数据的错误校正(重复上次已知的良好数据)，但它可能只用于非音频数据，因为它需要额外的总线带宽。</p> 
<h3>3.4、<strong>浮点数据压缩</strong></h3> 
<p><strong>        </strong>A2B协议引擎提供可选的浮点数据压缩/解压缩，因此对于给定的数据大小，A2B总线使用的带宽更少(比立即减小的数据大小的质量更好)。这种压缩可用于A2B数据大小为12、16、20位的数据，对应于I2S数据宽度。压缩将源数据中前导符号位的数量编码为一个3位字段，并将符号位本身与N-4位数据(其中N是A2B数据大小)连接起来。“16位到12位压缩示例”表中显示了16位到12位压缩的示例。在表格中，s是符号位，~s是符号位的倒数。</p> 
<p class="img-center"><img alt="" height="162" src="https://images2.imgbox.com/63/6d/yKLz6PG4_o.png" width="808"></p> 
<p class="img-center"><img alt="" height="169" src="https://images2.imgbox.com/fa/a5/0lmphDIN_o.png" width="812"></p> 
<p>         数据解压与此相反。压缩后数据的LSB (12-Bit ~ 16-Bit数据解压缩示例表中的L)用于生成解压缩后未以压缩格式存储的剩余LSB。</p> 
<p class="img-center"><img alt="" height="273" src="https://images2.imgbox.com/87/e8/zq945ADc_o.png" width="810"></p> 
<p>         选择FP压缩是减小数据槽大小的一种好方法。它适用于需要多个数据通道的系统。有时，有足够或不足的可用数据槽是有益的。减少槽的大小也减少了电流抽吸，这在幻影供电节点中是很重要的。</p> 
<p>        启用数据压缩时，保留音频信号的全动态范围(24bit = 144.49 dB)。人耳可以在安静的环境中听到接近噪音水平的声音，但在声音非常大的环境中，人耳会掩盖非常安静的音频内容。浮点压缩(到20位)利用了这种心理声学效应，并在存在高级音频内容的情况下删除低级内容。当没有高水平音频内容时，浮点压缩保留所有低水平内容(这里，对于20位数据槽，16位= 96.33 dB)，并支持强音频信号的全动态范围(对于20位数据槽，高达144.49 dB)，始终以16位= 96.33 dB的分辨率。</p> 
<h3>3.4、下行数据槽</h3> 
<p>        从节点可以有选择地接收下游总线槽，输出到DTXn引脚上。DRXn引脚(A2B_DNOFFSET)上可编程数量的I2S/TDM数据通道可以跳过，然后下一个线路通道作为下行数据槽提供给A2B总线。因此，这种模式允许从节点接收和发送下游数据。</p> 
<p>        A2B_DNMASK0到A2B_DNMASK3寄存器为每个可能的下游数据槽提供一个位。这些下游掩码位选择哪些下游槽位被收发器消耗，并放置在其TX帧缓冲区中，以便通过I2S/TDM端口输出，由下游掩码使能(A2B_LDNSLOTS.DNMASKEN)位控制。</p> 
<p>        当A2B_LDNSLOTS.DNMASKEN= 0时，A2B_DNSLOTS寄存器定义下游数据槽的数量，从SCF之后立即开始，通过从节点向下传递，A2B_LDNSLOTS寄存器定义收发器在超帧的下游部分捕获的下游数据槽的数量。收发器消耗数据槽，不将这些数据槽下行传给下一个节点。因此，从端在a端接收“A2B_BCDNSLOTS + A2B_DNSLOTS + A2B_LDNSLOTS”下行数据槽位，在b端发送“A2B_BCDNSLOTS + A2B_DNSLOTS”下行数据槽位。</p> 
<p><strong>        注意：</strong>当A2B_LDNSLOTS。从收发器清除DNMASKEN位，A2B_DNMASK0到<br>                 A2B_DNMASK3寄存器将被忽略。</p> 
<p>        当A2B_LDNSLOTS.DNMASKEN= 1时，A2B_LDNSLOTS寄存器定义本地节点在超帧的下游部分添加的数据槽的数量。这些数据槽位在A2B_DNSLOTS数据槽位之后通过本地节点下行。在A2B_DNMASK0到A2B_DNMASK3寄存器中设置的最高有效位决定了收发器(dnmaskrx)必须接收的插槽的数量，以便它识别哪些单独的插槽被放置在它的RX帧缓冲区中，以便在I2S/TDM端口上输出。因此，从节点在a端接收到MAX (A2B_DNSLOTS, dnmaskrx)下行数据槽位后，在b端接收到“A2B_DNSLOTS + A2B_LDNSLOTS”下行数据槽位。</p> 
<p>       <strong> 注意：</strong>当A2B_LDNSLOTS。在从收发器中设置DNMASKEN位，A2B_BCDNSLOTS寄存器<br>                 将被忽略。</p> 
<p>        A2B_DNOFFSET寄存器的值只有在配置了下行数据(A2B_LDNSLOTS. A2B_DNOFFSET)时才有意义。DNMASKEN= 1, A2B_LDNSLOTS寄存器是非零的)。除非A2B_DNOFFSET寄存器被编程应用一个偏移量到RX帧缓冲区，数据从RX帧缓冲区开始填充启用的下游槽位，否则从RX帧缓冲区开始，数据从RX帧缓冲区的开始被放置在启用的下游槽位。</p> 
<p>        使用A2B_DNMASK0、A2B_DNMASK1和A2B_DNOFFSET寄存器的从节点图是一个例子，说明了在对A2B_DNMASK0、A2B_DNMASK1和A2B_DNOFFSET寄存器进行编程后，如何在从收发器中使用下游数据槽。</p> 
<p class="img-center"><img alt="" height="439" src="https://images2.imgbox.com/81/fe/q1mB0VHG_o.png" width="721"></p> 
<p style="text-align:center;"> <strong>从节点使用A2B_DNMASKn和A2B_DNOFFSET寄存器</strong></p> 
<h3>3.5、上游数据槽</h3> 
<p>        A2B_UPSLOTS寄存器定义了上游数据槽的数量。对于主收发器，这个寄存器定义了从一线从属收发器向上游发送到主收发器的数据槽的数量。对于备用收发器，这个寄存器定义了上游数据槽的数量，从槽位为0的SRF开始，无论备用收发器是否使用这些槽位的信息，上游数据槽的数量都通过该收发器传递。</p> 
<p>        A2B_UPSLOTS寄存器定义了数据插槽的数量，这些数据插槽在从机向上游传递数据插槽后被从机附加到超帧的上游部分，就像A2B_UPSLOTS寄存器中定义的那样。位于上游数据槽的数据来自收发机内部的RX帧缓冲区，由收发机的I2S/TDM/PDM端口填充。</p> 
<p>        从端收发器有选择地将上游A2B总线数据槽接收到其TX帧缓冲区中，并输出到其DTXn引脚上，以供从端使用。在从收发器中，A2B_UPMASK0到A2B_UPMASK3寄存器为每个可能的上游数据槽提供一个位。当这些寄存器中的任何一个位被设置时，从收发器从相应的槽位获取上游数据，并将其放在其接收到的任何下游数据槽后的TX帧缓冲区中，然后通过I2S/TDM端口输出到相应的DTXn引脚。</p> 
<p>        在A2B_UPMASK0到A2B_UPMASK3寄存器中设置的最高有效位定义了收发器必须接收的插槽数(upmaskrx)，以便将使能的插槽适当地放入TX帧缓冲区，输出到I2S/TDM端口。</p> 
<p>        从端接收MAX (A2B_UPSLOTS, upmaskrx)B端收发器上游数据槽位。然后在a端收发器上向上游数据槽位发送“A2B_UPSLOTS + A2B_LUPSLOTS”。</p> 
<p>        DRXn引脚(A2B_UPOFFSET)上可编程数量的I2S/TDM数据通道可以跳过，然后将下一直列通道作为上游数据槽提供给A2B总线。默认情况下，从节点用它的RX帧缓冲区的第一个条目填充启用的上游槽位。A2B_UPOFFSET寄存器可以写入到RX帧缓冲区中定义一个偏移量，从这个偏移量开始填充启用的上游槽位。</p> 
<p>        使用A2B_UPMASK0、A2B_UPMASK1和a2b_upffset寄存器的从节点图提供了一个在A2B_UPMASK0、A2B_UPMASK1和a2b_upffset寄存器编程后如何在从收发器中使用上游数据槽的示例。</p> 
<p class="img-center"><img alt="" height="433" src="https://images2.imgbox.com/d8/32/wjsH1lmI_o.png" width="725"></p> 
<p style="text-align:center;"> 从节点使用A2B_UPMASKn和A2B_UPOFFSET寄存器</p> 
<h3>3.6、A2B带宽</h3> 
<p>        所有上行数据限制在相同的槽位大小(每个槽位位位数)，所有下行数据限制在相同的槽位大小(每个槽位位位数)，但下行和上行槽位大小可以不同。Analog Devices提供详细的计算电子表格和SigmaStudio软件，用于计算所有可能情况下的带宽。</p> 
<p>        “带宽示例”表提供了采样48khz、同步上下游数据槽的带宽示例。为了简化该表，每个节点使用相同数量的上下行槽位。上行最多32个槽位，下行最多32个槽位。</p> 
<p class="img-center"><img alt="" height="600" src="https://images2.imgbox.com/b7/8d/mQy0wVI1_o.png" width="735"></p> 
<h2>4、I2S/TDM端口编程概念</h2> 
<p>        I2S/TDM接口的编程包括选择端口的操作模式、控制发送和接收操作启用多少数据管脚、配置BCLK和SYNC信号相对于数据的极性和时序。</p> 
<p>        A2B_I2SGCFG和A2B_I2SCFG寄存器用于配置I2S/TDM端口，以支持这些不同的操作模式。串行模式数据和时钟格式表提供了主和从收发器支持的不同数据和时钟格式的摘要。</p> 
<p class="img-center"><img alt="" height="81" src="https://images2.imgbox.com/48/61/9mr1Jzkz_o.png" width="809"></p> 
<p class="img-center"><img alt="" height="347" src="https://images2.imgbox.com/56/2f/e5euf8uN_o.png" width="807"></p> 
<p>         支持多路立体声双通道(TDM2)信号，必须设置A2B_I2SGCFG.TDMMODE字段以启用任何支持的TDM操作模式。一旦配置完成，这就是每个启用的数据引脚所使用的工作模式，由A2B_I2SCFG.RX0EN, A2B_I2SCFG.RX1EN,A2B_I2SCFG.TX0EN, and A2B_I2SCFG.TX1EN位控制。</p> 
<p>        当任意一个方向的两个数据引脚都被启用时，可以通过设置各自的两引脚交错(A2B_I2SCFG.RX2PINTL和A2B_I2SCFG.TX2PINTL)位。当设置时，偶数槽位数据与DTX0/DRX0数据引脚关联，奇数槽位数据与DTX1/DRX1数据引脚关联。清除后，使能槽位的下半部分与DTX0/DRX0数据引脚相关联，上半部分与DTX1/DRX1数据引脚相关联。例如，I2S或TDM2模式下设置了数据格式，则“TDM2设置的数据通道结构”图中总结了数据的对齐方式。</p> 
<p class="img-center"><img alt="" height="347" src="https://images2.imgbox.com/94/b9/wDJJ38ul_o.png" width="608"></p> 
<p style="text-align:center;"> <strong>TDM2设置的数据通道结构(TDMMODE == 000)</strong></p> 
<p>        <strong>注意：</strong>单引脚发送可以在DTX0或DTX1引脚上，单引脚接收可以在DRX0或DRX1引脚上。</p> 
<p>        I2S/TDM端口的A2B_I2SGCFG.TDMSS位选择在16位和32位串行数据之间，主机有责任确保提供适当的定时信号以容纳数据的全窗口。例如，选择TDM8模式(A2B_I2SGCFG.TDMMODE = 0b010)，那么主机必须提供128(8 x 16 位，当A2B_I2SGCFG. TDMSS = 1)或256 (8 x 32位，当A2B_I2SGCFG. TDMSS = 0) BCLK脉冲用于数据和适当的同步信号(根据A2B_I2SGCFG的设置，脉冲或保持50%占空比。“ALT bit”)，如图I2S/TDM8定时示例图所示。</p> 
<p class="img-center"><img alt="" height="231" src="https://images2.imgbox.com/43/85/XYuKPpOL_o.png" width="531"></p> 
<p style="text-align:center;"><strong>I2S/TDM8时序示例</strong></p> 
<p>        如图I2S/TDM8定时示例图所示，TDM通道数据为“MSB-first”格式。当通过A2B总线交换的数据不完全是16位或32位时(由A2B_I2SGCFG.TDMSS位配置)，收发器期望输入的TDM数据通道以MSB-first格式到达，并忽略任何低阶位。收发器在输出到本地节点时，将接收到的A2B槽位数据以MSB-first格式输出到I2S/TDM端口，将未使用的低阶位置零。例如，12位数据配置为A2B槽位(A2B_SLOTFMT.UPSIZE = 1表示上游槽位或A2B_SLOTFMT.DNSIZE = 1表示下行槽位为)， 12位输入数据在TDM通道中必须左对齐，输出数据由12位A2B槽位数据后面加4个零位组成。</p> 
<p>        如果SYNC信号早到一位，可以将其改写为比SYNC信号的相关边缘晚到一位的数据。I2S/TDM2到TDM16 A2B主或从图显示了I2S的典型计时，以及带有可编程选项的TDM2到TDM16接口模式。数据在BCLK的一边提供，在BCLK的另一边采样(A2B_I2SCFG)。TXBCLKINV≠A2B_I2SCFG.RXBCLKINV)。</p> 
<p class="img-center"><img alt="" height="301" src="https://images2.imgbox.com/19/af/EGDbkuCS_o.png" width="811"></p> 
<p style="text-align:center;"><strong>I2S/TDM2 ~ TDM16 A2B主或从</strong></p> 
<p>        当两个数据引脚在TDM16模式下启用时，可以使用完整的32通道组合带宽。</p> 
<p>        <strong>注意：</strong>如果TDM32接口只有一个数据引脚可用，请谨慎，因为这将增加BCLK速率，在竞争条<br>                 件可能发生的速度。</p> 
<p>        A2B主采样BCLK边缘的数据，并改变前一个相同极性的BCLK边缘(A2B_I2SCFG)的数据。TXBCLKINV≠A2B_I2SCFG.RXBCLKINV)，如图TDM32 A2B Master图所示。</p> 
<p class="img-center"><img alt="" height="360" src="https://images2.imgbox.com/f6/eb/AZAuHhLv_o.png" width="812"></p> 
<p style="text-align:center;"> <strong>TDM32 A2B主</strong></p> 
<p>        A2B从站改变一个BCLK边缘的数据，并对下一个相同极性的BCLK边缘(A2B_I2SCFG)的数据进行采样。TXBCLKINV≠A2B_I2SCFG.RXBCLKINV)，如TDM32 A2B Slave图。</p> 
<p class="img-center"><img alt="" height="364" src="https://images2.imgbox.com/b3/b4/Qb2iW2zc_o.png" width="815"></p> 
<p style="text-align:center;"><strong>TDM32 A2B从</strong></p> 
<h3>4.1、从节点同步</h3> 
<p>        通过在A2B_SYNCOFFSET寄存器中单独补偿它们的传播延迟，A2B从节点可以完全同时采样。向该寄存器写入非零值调整A2B总线时钟(fSYSBCLK)周期，在此周期上SYNC引脚指示特定的从收发器音频帧的开始。由于编程的值是8位带符号2的补码，表示SYNC发生的地方和随后开始的超帧之间的SYSBCLK周期的整数，因此只有负值是有效的。</p> 
<p>        可以编程到A2B_SYNCOFFSET寄存器的最大值定义了一个在超帧开始之前发生104个SYSBCLK周期的同步信号(-104 = 0x98)，但是这个值只对在完全填充的A2B网络拓扑中离主节点最远的从节点有效(A2B_NODEADR)。节点= 0 x09)。对于任何离主节点更近的从节点n，支持I2S/TDM数据可预测传输到A2B槽位的有效范围与从节点n在网络中的位置有关，公式如下：</p> 
<p>        (-32 - 8n) &lt;= A2B_SYNCOFFSET &lt;= 0</p> 
<p>        支持的同步偏移量表总结了在SYSBCLK周期(偏移范围)中任何给定的从节点的A2B_SYNCOFFSET寄存器的有效设置。</p> 
<p class="img-center"><img alt="" height="364" src="https://images2.imgbox.com/b8/ed/pW2VbEQy_o.png" width="815"></p> 
<h3>4.2、I2S降低数据速率</h3> 
<p>        从节点还可以以低于超帧速率(fSYNCM)的速率频率运行I2S/TDM接口。降低速率的频率是通过将超帧速率除以一组可编程值得到的。可以配置不同的从节点以不同的降低I2S/TDM速率运行。</p> 
<p>        A2B_I2SRATE.I2SRATE位域用于将超帧A2B速率划分为降低的I2S速率。它还提供了一个控制位A2B_I2SRRATE.RBUS，用于在总线上启用降低速率的数据槽。总线上的A2B数据槽每“A2B_I2SRRATE.RRDIV + 1”只传输一次超帧。</p> 
<p>        A2B_I2SRATE.I2SRATE位字段可用于将除因子编程为2,4，或在A2B_I2SRRATE.RRDIV字段中设置。A2B_I2SRATE.SHARE位使共享的A2B总线槽位在一个减少的从节点中，前提是该节点已禁用I2S传输。</p> 
<p>        A2B_I2SRRCTL寄存器提供位允许处理器跟踪全速率音频帧，其中包含新的降速率采样。IO7引脚可以通过设置A2B_I2SRRCTL.ENSTRB位作为频闪。表示更新降速数据的音频帧。A2B_I2SRRCTL.STRBDIR位配置IO7引脚用作频响时的方向。主节点的降率频闪输出基于A2B_I2SRRATE.RRDIV字段设置。当A2B_I2SRRATE.RRDIV域不是一个，在每个节点中保持减少的速率计数，并产生相应的频闪输出信号。当频闪作为输入时，在SYNC的活动边缘对其采样，并将降低的速率计数同步到它。用户必须创建一个与A2B_I2SRRATE.RRDIV设置匹配的频闪信号。</p> 
<p>        A2B_I2SRRSOFFS寄存器提供了一个位域，在超帧增量中在一个降低速率的从属器中移动SYNC边缘。</p> 
<p>        减少的数据速率图显示了来自收发器的上游槽如何降低总线上的超帧速率，允许从节点在两个共享都被禁用的情况下以降低的采样频率运行(A2B_I2SRATE.SHARE = 0)和使能 (A2B_I2SRATE.SHARE = 1)。这个图是为一个主系统和一个从系统绘制的。</p> 
<p class="img-center"><img alt="" height="391" src="https://images2.imgbox.com/6a/a0/cAoxI1i3_o.png" width="851"></p> 
<p style="text-align:center;"><strong>降低数据率</strong></p> 
<p>        下表显示了I2S/TDM采样率根据降低的速率分为不同的系统模式。</p> 
<p class="img-center"><img alt="" height="252" src="https://images2.imgbox.com/2b/77/bOuMq1Tl_o.png" width="810"></p> 
<p>         降低速率的特性允许系统设计师添加以下功能：</p> 
<p>                1、从节点可以运行I2S/TDM接口，以低于超帧速率的速率运行。例如，48khz超帧速率<br>         的降低率为24khz、12khz、6khz、4khz、3khz、2.4 kHz、2khz、1.71 kHz或1.5 kHz。从机<br>         上的I2S/TDM RX数据可以以降低的速率向上游或下游发送。不同的从节点可以以不同的降低<br>         的I2S/TDM速率运行。</p> 
<p>                2、降低速率从节点的SYNC信号可以在超帧增量中进行调整，以确保降低速率数据交付<br>         的最小延迟。</p> 
<p>                3、对BCLK信号产生的控制可以通过降低速率的I2S数据(例如，在48 kHz的I2S/TDM帧<br>         内)或降低I2S/TDM速率的采样来最小化延迟。</p> 
<p>                4、当降低速率的I2S/TDM数据通道更新时通知处理器的选项。</p> 
<p>                5、选择运行总线数据槽在充分，连续的音频速率(名义上48khz)或降低的速率。该比率<br>         可通过以下方式降低：</p> 
<p>                        1）、跳过不包含数据的超级帧的数据槽(例如，只在A2B总线上减少采样率的麦克<br>                 风节点)。这种方法通过降低总线活动级别来节省电力，但不会增加总线上的通道带宽。<br>                 当一个节点内多个I2S/TDM通道共享相同的A2B数据槽位时，程序不能跳过该A2B数据<br>                 槽位。</p> 
<p>                        2）、将一个节点的总线数据槽分时分成多个I2S/TDM信道，对于超帧不跳过数据<br>                 槽。如果不同类型的从节点连接在同一A2B总线上(例如，在同一总线上带有麦克风或放<br>                 大器节点的多轴加速计节点)，则使用这种方法。总线必须以全数据速率运行，以允许<br>                 A2B数据槽共享。这种方法通过允许降低速率的从节点到总线数据槽上的时间多路<br>                 I2S/TDM数据字来增加总线上的信道带宽。</p> 
<p>                                a）、以½速率运行的从节点可以使用2:1时间多路复用(同一从节点中的两个<br>                         I2S/TDM通道在一个A2B插槽上交替使用)。</p> 
<p>                                b）、运行速率较低的从节点可以使用4:1时间多路复用(同一从节点的4个<br>                         I2S/TDM通道在一个A2B槽上交替)。</p> 
<p>                                c）、不支持超过4:1的A2B数据槽时间复用。</p> 
<p>                                d）、不支持节点间A2B数据槽时间复用。</p> 
<p>                                e）、总线必须在A2B数据槽上运行，以充分的、连续的音频速率，以便数据<br>                         槽被共享。</p> 
<p>                                f）、上行和下行支持I2S/TDM RX降速数据。</p> 
<h3>4.3、<strong>I2S降低速率限制</strong></h3> 
<p><strong>        </strong>在使用I2S降低速率特性时，请遵守以下一般限制：</p> 
<p>                1、每个从节点只能以单一I2S/TDM速率运行。</p> 
<p>                2、对于I2S/TDM的RX数据，而不是I2S/TDM的TX数据，配置以降低I2S/TDM速率运行<br>         的从节点。这意味着降低速率的从节点必须具有A2B_I2SCFG.TX0EN = 0和<br>         A2B_I2SCFG.TX1EN = 0。</p> 
<p>                3、如果设置A2B_I2SRRATE.RBUS，并配置降速(A2B_I2SRRATE.RRDIV &gt; 1)，从节<br>         点必须有A2B_I2SRATE.I2SRATE取值为0 (SFF x 1)或3 (SFF / A2B_I2SRRATE.RRDIV)。</p> 
<p><strong>        数据槽位共享限制（A2B_I2SRATE.SHARE = 1）。</strong></p> 
<p>        使用I2S降速特性时，需要注意以下数据槽位共享限制：</p> 
<p>                1、总线必须以全数据速率(A2B_I2SRRATE.RBUS = 0)运行，允许A2B数据槽共享。当<br>         节点内多个I2S/TDM通道共用相同的A2B数据槽位时，不支持A2B数据槽跳变。</p> 
<p>                2、A2B总线上由A2B_I2SRATE.SHARE = 1降低速率的从属机产生的数据槽。必须由全<br>         速率或增加速率的节点从A2B总线接收。</p> 
<p>                3、如果A2B_I2SRATE.SHARE设置在一个降低速率的从机上，最大同步偏移是一个超<br>         帧(A2B_I2SRRSOFFS.RRSOFFSET必须为0或1)。</p> 
<p>        如果A2B_I2SRATE.SHARE位设置在一个降低速率的从机上，并且没有同步偏移(A2B_I2SRRSOFFS.RRSOFFSET = 0)，对于节点编程还有一个相对于N(可用的上、下槽的数量)的进一步约束。例如，如果TDMS是一个降速从节点(2、4、8、16或32)上每帧的槽位数，N的计算如下表所示：</p> 
<p class="img-center"><img alt="" height="124" src="https://images2.imgbox.com/c4/2e/hZafPagb_o.png" width="810"></p> 
<p>         如果降低速率的从机有A2B_I2SCFG.RX0EN，A2B_I2SCFG.RX1EN，<br> A2B_I2SCFG.RX2PINTL位全部设置，“A2B_LUPSLOTS + A2B_UPOFFSET”必须&lt;= 2N。否则，“A2B_LUPSLOTS +  A2B_UPOFFSET”必须≤N。</p> 
<p>        如果降速从机正在生成下行数据槽(A2B_LDNSLOTS.DNMASKEN= 1)，同样的约束适用于“A2B_LDNSLOTS + A2B_DNOFFSET”。</p> 
<p><strong>        备用BCLK速率的限制 (A2B_I2SRATE.BCLKRATE)</strong></p> 
<p><strong>        </strong>在使用I2S降低速率特性时，请注意以下备用BCLK速率限制。</p> 
<p>                1、对于降速率的从节点，如果I2S速率设置为SFF / 2 (A2B_I2SRATE.I2SRATE = 1)<br>         时，请勿将BCLK频率设置为SYNC x 4096 (A2B_I2SRATE.BCLKRATE != 2)。</p> 
<p>                2、如果系统级减除率因子为1 (A2B_I2SRRATE.RRDIV = 1)， I2S速率设置为“SFF /<br>         A2B_I2SRRATE.RRDIV”(A2B_I2SRATE.I2SRATE = 3)时，请勿将BCLK频率设置为“SYNC x<br>         2048”(A2B_I2SRATE.BCLKRATE = 1)或"SYNC x 4096" (A2B_I2SRATE.BCLKRATE = 2)。</p> 
<p>                3、如果系统级降低的速率因子是2 (A2B_I2SRRATE.RRDIV = 2)， I2S速率设置为“SFF<br>         / A2B_I2SRRATE.RRDIV”(A2B_I2SRATE.I2SRATE = 3)时，请勿将BCLK频率设置为“SYNC<br>         x 4096”(A2B_I2SRATE.BCLKRATE = 2)。</p> 
<p>                4、如果BCLK频率不是由A2B_I2SGCFG寄存器(A2B_I2SRATE.BCLKRATE != 0)在一个<br>         降低速率的slave中，同步偏移不能超过1个超帧(A2B_I2SRRSOFFS.RRSOFFSET &lt; 2)。</p> 
<h3>4.4、I2S提高数据速率</h3> 
<p>        A2B从端收发器支持I2S/TDM接口上相对于超帧速率(fSYNCM)的更高采样速率。在A2B_I2SRATE寄存器中，可以将从机的本地采样率编程为1 × fSYNCM、2 × fSYNCM或4 × fSYNCM。例如，给定48 kHz的超帧频率，本地采样率可以分别设置为48 kHz、96 kHz或192 kHz。在一个主、从系统中增加的数据速率图显示了对于不同的A2B_I2SRATE位设置(使用A2B_I2SRATE.REDUCE = 0)， A2B超帧的上下游槽如何分布在从收发器的DTX0/DTX1和DRX0/DRX1引脚上。</p> 
<p class="img-center"><img alt="" height="424" src="https://images2.imgbox.com/c7/ab/uVg6F4UD_o.png" width="644"></p> 
<p style="text-align:center;"><strong>增加数据速率</strong></p> 
<p>        增加的数据速率示例图进一步说明了基于一个示例系统的A2B_I2SRATE寄存器设置的行为。在图中，两个从收发器(S1和S2)都设置为2 × fSYNCM速率模式。然而，S1具有A2B_I2SRATE.REDUCE位设置为1。图中的波形说明了A2B_I2SRATE.REDUCE位上游和下游槽的影响。当设置A2B_I2SRATE.REDUCE位，仅DRX0/DRX1引脚上的前两个通道用于上游槽位，其他两个通道为2 × fSYNCM速率忽略。对于DTX0/DTX1发射机，当设置A2B_I2SRATE.REDUCE位时，DTX0/DTX1引脚上的两个本地下行槽复制为2 × fSYNCM速率。</p> 
<p class="img-center"><img alt="" height="759" src="https://images2.imgbox.com/ca/8b/O8lNa9xR_o.png" width="641"></p> 
<p style="text-align:center;"> <strong>提高数据速率示例</strong></p> 
<h2>5、GPIO远距离</h2> 
<p>        该特性允许在初始编程后在A2B总线上进行GPIO通信，而无需主机干预。主机只需要通过使用虚拟端口初始化GPIO远距离特性即可。GPIO超距离功能具有以下功能：</p> 
<p>                1、8个并行的1位虚拟端口，由主节点管理。主节点可以在A2B_GPIODDAT寄存器中读<br>         取每个虚拟端口的状态。</p> 
<p>                2、GPIO引脚到虚拟端口0 ~ 7的灵活映射方案。</p> 
<p>                3、GPIO引脚可以配置为更新A2B_GPIODDAT寄存器内容的输入，也可以配置为反映<br>         A2B_GPIODDAT寄存器内容的输出。</p> 
<p>                4、当多个虚拟端口映射到一个GPIO输出引脚时，这些值被“OR”在一起。</p> 
<p>                5、当多个GPIO输入引脚映射到一个虚拟端口时，即使来自多个节点，这些值也会被<br>         “OR”在一起。</p> 
<h3>5.1、配置</h3> 
<p>        在尝试配置给定引脚的GPIO超远距离功能之前，首先要验证它对GPIO可用，如GPIO引脚配置表所示。</p> 
<p class="img-center"><img alt="" height="281" src="https://images2.imgbox.com/b8/6c/8uqYGlIJ_o.png" width="756"></p> 
<p>         如果引脚可用为GPIO，则通过在GPIO超远距离(A2B_GPIODEN)寄存器中设置适当的使能位来使能GPIO 超远距离。当设置一个位时，对应的GPIO引脚可以通过GPIO远端掩码寄存器(A2B_GPIOD0MSK到A2B_GPIOD7MSK，分别对应GPIO能力引脚IO0到IO7)映射到一个或多个远端虚拟端口。这些寄存器中的位0到7分别对应虚拟端口0到7。如果在其中一个寄存器中设置了一个位，它会将与该寄存器相关联的GPIO引脚映射到相应的虚拟端口。</p> 
<p>        如果对给定的GPIO能力引脚使能GPIO超远距离，引脚的方向完全通过GPIO输出使能寄存器(A2B_GPIOOEN)控制，而不是该寄存器和GPIO 超远距离互补GPIO输入使能寄存器(A2B_GPIOIEN)的组合。当在A2B_GPIOOEN寄存器中设置一个位时，相关的GPIO引脚是GPIO在距离上的输出。如果该位在A2B_GPIOOEN寄存器中被清除，则相关的GPIO引脚在距离上是GPIO的输入。在对感兴趣的引脚使用GPIO时，不需要对A2B_GPIOIEN寄存器进行编程。</p> 
<p>        如果GPIO引脚是一个输入(A2B_GPIOOEN中相关位= 0)，本地节点通过距离掩码寄存器更新与GPIO中设置位相关的虚拟端口(A2B_GPIOD0MSK.IOD0MSK通过A2B_GPIOD7MSK.IOD7MSK)。虚拟端口值可以通过远程数据寄存器(A2B_GPIODDAT)在GPIO中读取。</p> 
<p>        如果GPIO引脚是一个输出(A2B_GPIOOEN中的相关位 = 1)，则映射到该引脚的虚拟端口，由通过距离掩码寄存器的相关GPIO中的设置位决定(A2B_GPIOD0MSK. IOD0MSK通过A2B_GPIOD7MSK.IOD7MSK)加OR来产生GPIO输出值(即A2B_GPIODDAT寄存器中相应位的逻辑OR)。</p> 
<p>        <strong>注意：</strong>A2B_GPIODDAT寄存器是只读的。建议主机总是从主节点读取这个寄存器。</p> 
<p>        距离反转寄存器(A2B_GPIODINV)允许GPIO引脚输入或输出的反转。当在这个寄存器中设置一个位时，相关的GPIO引脚信号是反向的。如果GPIO引脚是一个虚拟端口的输入(A2B_GPIOOEN中的相关位= 0)，反转在引脚从引脚进来的时候应用，如果引脚是一个虚拟端口的输出(A2B_GPIOOEN中的相关位= 1)，反转在GPIO引脚出来的时候应用。</p> 
<p>        如果多个节点正在更新同一个虚拟端口，可以使用A2B_GPIODINV寄存器设置将有线或更改为有线和。例如，要创建一个有多个主动高GPIO位的有线和，GPIO输入和GPIO输出必须是反向的。</p> 
<h3>5.2、将多个GPIO输入映射到一个虚拟端口</h3> 
<p>        当多个节点有一个GPIO输入映射到同一个虚拟端口时，协议将输入引脚视为有线或进入虚拟端口。当虚拟端口处于低位(不活动)时，设置虚拟端口的任何请求都会导致主节点执行一个命令，更新整个系统中的所有A2B_GPIODDAT寄存器。</p> 
<p>        当虚拟端口处于高(活动)状态时，任何清除虚拟端口的请求都会导致主节点发出一个特殊命令，通知所有从节点该请求。如果任何一个从节点拒绝请求，主节点看到请求被拒绝，A2B_GPIODDAT寄存器保留它们的值。如果没有一个从节点拒绝请求，那么主节点将看到请求被接受，并使用更新后的A2B_GPIODDAT值。</p> 
<h3>5.3、GPIO远程编程示例</h3> 
<p>        下面的步骤描述了在距离上使用GPIO的引脚映射情况。</p> 
<p>        <strong>注意：</strong>GPIO编程必须在发现节点之后进行。有关节点发现的更多信息，请参见简单发现流程<br>         和附录A:附加发现流程示例小节。</p> 
<h4><strong>5.3.1、将Master节点DRX1/IO6 Pin映射到Slave 2 ADR1/IO1 Pin：</strong></h4> 
<p>        下面以主节点DRX1/IO6引脚映射到从节点2 ADR1/IO1引脚为例进行说明。</p> 
<p>                1、将0x04写入主节点A2B_GPIOD6MSK寄存器，将DRX1/IO6引脚映射到虚拟端口2。</p> 
<p>                2、将0x40写入主节点A2B_GPIODEN寄存器，以在DRX1/IO6引脚上远程访问GPIO。</p> 
<p>                3、将0x02写入从节点2 A2B_GPIOOEN寄存器，使ADR1/IO1引脚GPIO输出。</p> 
<p>                4、将0x04写入从节点2 A2B_GPIOD1MSK寄存器，将虚拟端口2映射到ADR1/IO1引<br>         脚。</p> 
<p>                5、将0x02写入从节点2 A2B_GPIODEN寄存器，使ADR1/IO1引脚上的GPIO通过远程访<br>         问。</p> 
<h4><strong>5.3.2、将Slave 1 DTX1/IO4 Pin映射到Master Node ADR1/IO1 Pin：</strong></h4> 
<p>        下面以从1 DTX1/IO4引脚映射到主节点ADR1/IO1引脚为例进行说明。</p> 
<p>                1、将0x10写入从节点1 A2B_GPIOD4MSK寄存器，将DTX1/IO4引脚映射到总线GPIO<br>         端口4。</p> 
<p>                2、将0x10写入从节点1 A2B_GPIODEN寄存器，使DTX1/IO4引脚上的GPIO通过远程访<br>         问。</p> 
<p>                3、将0x02写入主节点A2B_GPIOOEN寄存器，使ADR1/IO1引脚的GPIO输出生效。</p> 
<p>                4、将0x10写入主节点A2B_GPIOD1MSK寄存器，将总线GPIO端口4映射到ADR1/IO1<br>         引脚。</p> 
<p>                5、将0x02写入主节点A2B_GPIODEN寄存器，使ADR1/IO1引脚上的GPIO通过远程访</p> 
<p>        问。</p> 
<h4><strong>5.3.3、将从0到2上的ADR1/IO1引脚映射到主节点ADR1/IO1引脚</strong></h4> 
<p>        下面介绍如何将从0到2上的ADR1/IO1引脚映射到主节点ADR1/IO1引脚。</p> 
<p>                1、对于从节点2、1和0，将0x01写入A2B_GPIOD1MSK寄存器，将每个从节点的<br>         ADR1/IO1引脚映射到总线GPIO端口0。</p> 
<p>                2、对于从节点2、1和0，将0x02写入A2B_GPIODEN寄存器，以在每个从节点的ad1<br>         /IO1引脚上远程访问GPIO。</p> 
<p>                3、将0x02写入主节点A2B_GPIOOEN寄存器，使ADR1/IO1引脚的GPIO输出生效。</p> 
<p>                4、将0x01写入主节点A2B_GPIOD1MSK寄存器，将总线GPIO端口0映射到ADR1/IO1<br>         引脚。</p> 
<p>                5、将0x02写入主节点A2B_GPIODEN寄存器，使ADR1/IO1引脚上的GPIO通过远程访<br>         问。</p> 
<h2>6、收发器标识</h2> 
<p>        每个A2B收发器都有一个供应商ID寄存器(A2B_VENDOR)，一个产品ID寄存器(A2B_PRODUCT)和一个版本ID寄存器(A2B_VERSION)，以指示主机系统中存在哪些A2B收发器。每个A2B收发器厂商被分配一个唯一的厂商ID(模拟设备A2B收发器使用0xAD作为厂商ID)。A2B_PRODUCT和A2B_VERSION寄存器由芯片供应商分配，以唯一标识芯片并表明A2B互操作性。收发模块的产品ID分别为0x26 (AD2426W)、0x27 (AD2427W)、0x28 (AD2428W)。</p> 
<p>        每个A2B收发器也有一个A2B_CAPABILITY寄存器，以识别可用的控制接口，以及I2C接口的存在(A2B_CAPABILITY.I2CAVAIL = 1)。</p> 
<h3>6.1、在EEPROM中自动配置系统信息</h3> 
<p>        在A2B系统中，如果从模块包含一个配置内存(I2C EEPROM)，其组织和内容如附录C:模块ID和模块配置内存中描述的那样，则可以确定每个A2B节点的供应商和特定的产品ID来进行自动配置。当主机事先不知道确切的系统配置时，使用自动配置进行发现。从节点的特定配置命令也可以通过可选配置块存储在配置内存中。</p> 
<h2>7、待机模式</h2> 
<p>        待机状态下，A2B总线上没有上行流量。只有一个最小的(19位)SCF存在以保持所有从节点同步，并且没有SRF。头计数错误和CRC错误被忽略，数据槽被禁用。在待机模式下，GPIO设置保持不变。</p> 
<p>        在正常模式下，主机可以写主收发器A2B_DATCTL寄存器以进入备用模式，但是直到新的结构应用到系统中，写才生效。主机执行如下操作：</p> 
<p>                1、 在主收发器中设置A2B_DATCTL.A2B_DATCTL位生成一个0x80的广播会将所有发<br>         现的从节点的A2B_DATCTL.STANDBY为设置为0x80。将0x80写入A2B_DATCTL寄存器确保<br>         数据槽被禁用。</p> 
<p>                2、在主收发器上设置A2B_CONTROL.NEWSTRCT位来应用新的结构。</p> 
<p>        应用新的结构后，系统切换到备用模式。通过将0x00写入主节点中的A2B_DATCTL寄存器，主机可以将系统移回正常模式。该指令在所有的从节点中向A2B_DATCTL寄存器生成0x00的广播写操作。当系统回到正常模式时，主节点向主机提供备用完成中断(A2B_INTTYPE = 0xFE)。</p> 
<h2>8、总线监视器的支持</h2> 
<p>        总线监控模式使收发器充当被动的汽车音频总线监视器，也称为嗅探器。A2B测试设备采用该模式。只有主机处理器才能允许A2B总线段上的总线监视器监控同步数据内容。要允许这种同步数据监控，主机必须设置A2B_DATCTL。主收发信端ENDSNIFF位。此配置触发A2B总线广播信息到附加的总线监视器设备。</p> 
<p>        总线监视器行为图显示了插入在A2B网络中从0和1之间的总线监视器节点。</p> 
<p class="img-center"><img alt="" height="254" src="https://images2.imgbox.com/21/96/CbOmAjPP_o.png" width="553"></p> 
<p style="text-align:center;"><strong>总线监控行为示意图</strong></p> 
<p>        总线监视器在系统中是被动的，它不响应总线同步控制帧(scf)或向总线贡献任何数据。当B端收发器失效时，它只使用a端收发器。当处于总线监控模式时，收发器将自己同步到SCF，并可以窥探SCF控制写入，以配置其总线接口以匹配被监控的下游节点。A2B总线监控收发器使用其I2S/TDM端口将A2B总线流量传输到协议分析电路。</p> 
<p>        总线监控节点的行为如下：</p> 
<p>                1、B端(下游)收发器被禁用。</p> 
<p>                2、A端(上游)收发器只使能接收(不使能发送)。</p> 
<p>                3、禁用SRF生成功能。</p> 
<p>                4、数据宽度为32位时，配置I2S/TDM接口：</p> 
<p>                        1）、下游SCFs通过DTX0引脚传输。</p> 
<p>                        2）、上游SCFs通过DTX1引脚传输。</p> 
<p>                        3）、如果A2B总线主机被编程为启用该特性，数据槽位位只能从DTXn引脚流出：</p> 
<p>                                a）、下游槽在DTX0管脚上流出。</p> 
<p>                                b）、上游槽在DTX1管脚上流出。</p> 
<p>                                c）、如果A2B总线上的数据槽比可用的I2S/TDM通道多，则可编程偏移量决<br>                         定在I2S/TDM通道上监控哪些数据槽。</p> 
<p>        <strong>注意：</strong>当总线监视器接收器被禁用时，必须使用外部开关来控制在总线监视器模式下发送到收发器a端的LVDS流量。</p> 
<p>        在发现和初始化后连接到A2B总线的总线监视器可能会错过广播，因此对同步数据槽的监控被禁用。首选的方法是在初始化和发现之前连接总线监视器。另外，对于必须看到数据插槽但在发现后附加的总线监视器的完全支持，主机可以对A2B_DATCTL寄存器执行常规写操作，以生成启用数据插槽嗅闻广播。总线监控节点微控制器必须设置A2B_BMMCFG。BMMEN位使能总线监控模式，当连接和分离A2B总线时，可以进一步配置总线监控收发器：</p> 
<p>                1、A2B_BMMCFG.BMMNDSC位决定总线监视器是在系统发现和初始化之前还是之后<br>         连接。当清除(= 0)时，监视器连接在A2B发现之前，因此发现序列自动设置总线计时属性。<br>         当设置(= 1)时，总线计时属性必须由总线监控节点微控制器使用本地I2C寄存器写入来设置。</p> 
<p>                2、A2B_BMMCFG.BMMRXEN位用于在总线监视器连接时保持LVDS a端收发器输入静<br>         态。它还用于在不物理分离总线监视器节点的情况下重新启动总线监视器锁序列。</p> 
<p>        除了在A2B_BMMCFG寄存器中配置和启用总线监控模式外，总线监控模式的使用还会影响以下A2B寄存器中位的含义和设置：</p> 
<p>                1、I2S全局配置寄存器(A2B_I2SGCFG)：</p> 
<p>                        1）、A2B_I2SGCFG.INV，A2B_I2SGCFG.EARLY和A2B_I2SGCFG.ALT位必须<br>                 被编程以匹配协议分析器的接口。</p> 
<p>                        2）、A2B_I2SGCFG.TDMSS位的32位TDM槽位大小必须编程为0。</p> 
<p>                        3）、A2B_I2SGCFG.TDMMODE位必须设置为匹配协议分析器的功能：</p> 
<p>                                a)、TDM2允许监控SCF和SRF帧。</p> 
<p>                                b)、TDM4允许同时监控SCF和SRF帧，以及最多两个上游和两个下游数据槽.</p> 
<p>                                c)、TDM8允许并行监控SCF和SRF帧，以及同时多达6个上游和下游数据槽。</p> 
<p>                                d)、TDM16允许并行监控SCF和SRF帧，以及同时多达14个上游和14个下游<br>                         数据槽。</p> 
<p>                                e)、TDM32允许并行监控SCF和SRF帧，以及同时多达30个上游和下游数据<br>                         槽。</p> 
<p>        2、I2S配置寄存器(A2B_I2SCFG)：</p> 
<p>                1）、设置A2B_I2SCFG.TX0EN位允许DTX0引脚上的下行数据输出。</p> 
<p>                2）、设置A2B_I2SCFG.TX1EN位允许在DTX1引脚上输出上游数据。</p> 
<p>                3）、设置A2B_I2SCFG.TXBCLKINV位匹配协议分析器的接口。</p> 
<p>                4、A2B_I2SCFG.TX2PINTL，A2B_I2SCFG.RXBCLKINV，A2B_I2SCFG.RX0EN位必<br>         须被编程为0。</p> 
<p>        3、本地上游槽偏移寄存器(A2B_UPOFFSET)：确定从A2B总线接收的上游数据槽和作为I2S/TDM通道驱动到DTX1引脚的上游数据槽之间的数据槽的偏移量。如果插槽的数量超过所选TDM格式中可用的传输通道的数量，则在监控更高或更低索引插槽之间的寄存器程序。</p> 
<p>        4、本地下行槽偏移寄存器(A2B_DNOFFSET)：确定从A2B总线接收的下行数据槽和作为I2S/TDM通道驱动到DTX0引脚的下行数据槽之间的数据槽的偏移量。如果插槽的数量超过所选TDM格式中可用的传输通道的数量，则在监控更高或更低索引插槽之间的寄存器程序。</p> 
<h3>8.1、I2S/TDM信道格式</h3> 
<p>        待机状态下，A2B总线上没有上行流量。只有一个最小的(19位)SCF存在以保持所有从节点同步，并且没有SRF。头计数错误和CRC错误被忽略，数据槽被禁用。在待机模式下，GPIO设置保持不变。</p> 
<p>        下面举例说明总线监控模式下I2S/TDM的输出格式。</p> 
<p>        DTX0引脚在前两个32位I2S/TDM传输信道传输下行帧状态位，随后传输下行控制帧信息。进一步的I2S/TDM通道，如果可用和允许，携带下游同步数据。A2B_DNOFFSET寄存器提供下游数据槽和DTX0上产生的数据槽之间的偏移量。</p> 
<p>        DTX1引脚在前两个32位的I2S/TDM传输信道中传输上游帧状态位，然后传输上游响应帧信息。进一步的I2S/TDM通道，如果可用和允许，携带上游同步数据。A2B_DNOFFSET寄存器提供上游数据槽和DTX1上产生的数据槽之间的偏移量。</p> 
<p>        在发现和初始化期间，主机在主收发器中编写数据槽格式寄存器(A2B_SLOTFMT)，主收发器自动将该信息广播给从端。附加的总线监控器可以监听此控制消息并派生插槽大小设置(最大32位)。</p> 
<p>        数据总是以MSB对齐的方式传输。</p> 
<p>        校验位不包含在I2S/TDM通道中，但是A2B_ERRMGMT寄存器可以用来指示数据LSB中的数据槽错误，数据LSB下面的数据槽错误，或者在数据通道之后的额外错误通道中。</p> 
<p>        TDM16下游示例(DTX0引脚)寄存器图显示了A2B_I2SGCFG.TDMMODE = TDM16在DTX0引脚上产生的用于监控的下游数据。</p> 
<p class="img-center"><img alt="" height="530" src="https://images2.imgbox.com/d8/e8/DEgEUkzp_o.png" width="761"></p> 
<p style="text-align:center;"><strong>TDM16下游示例(DTX0 Pin)寄存器</strong></p> 
<p>        TDM16上游示例(DTX1引脚)寄存器图显示了A2B_I2SGCFG.TDMMODE = TDM16在DTX1引脚上监控产生的上游数据。</p> 
<p class="img-center"><img alt="" height="529" src="https://images2.imgbox.com/1a/e3/P3HQmAIC_o.png" width="760"></p> 
<p style="text-align:center;"><strong> TDM16上游示例(DTX1 Pin)寄存器</strong></p> 
<h3>8.2、启动顺序</h3> 
<p>        所需的启动序列取决于总线监视器节点是在A2B系统发现和初始化之前还是之后连接到总线，这由A2B_BMMCFG.BMMNDSC位控制：</p> 
<h4>8.2.1、设备发现之前</h4> 
<p>        当A2B_BMMCFG.BMMNDSC= 0时，执行如下操作：</p> 
<p>                1、确保探测的总线段不是DC偏置的(在直接上游节点上A2B_SWCTL.ENSW = 0)。</p> 
<p>                2、物理地将总线监视器连接到总线段(探测点)。</p> 
<p>                3、通过I2C设置A2B_BMMCFG.BMMEN = 1，A2B_BMMCFG.BMMRXEN = 1。</p> 
<p>                4、在A2B_I2SGCFG、A2B_I2SCFG、A2B_I2SRATE、A2B_SYNCOFFSET和<br>         A2B_ERRMGMT寄存器中通过I2C配置I2S/TDM传输设置，以匹配所需的时间和格式特征。</p> 
<p>                5、主机将总线电源应用到被探测的总线段，然后在主收发器中写入A2B_DISCVRY寄存<br>         器，从而开始发现下一个直连节点。</p> 
<p>                6、总线监控节点锁定锁相环后，I2S/TDM接口开始发送。总线监视器节点上的IRQ引脚<br>         升高，表示该节点发现了锁。此事件应在下一个直连节点开始响应之前发生。</p> 
<p>                7、对被探测总线段下一列从节点上的A2B_UPMASK0(通过A2B_UPMASK3)和<br>         A2B_DNMASK3(通过A2B_DNMASK3)寄存器A2B_BCDNSLOTS、A2B_LDNSLOTS、<br>         A2B_LUPSLOTS、A2B_DNSLOTS、A2B_UPSLOTS、A2B_SLOTFMTA2B_DATCTL)的写<br>         操作在总线监控节点中被镜像，在总线监控节点中它们可以通过I2C接口本地访问。总线上新<br>         数据结构的应用程序(当主机设置A2B_CONTROL。主收发器中的NEWSTRCT位)也应用于总<br>         线监控节点。</p> 
<p>                8、DTX[1:0]引脚不传输数据槽内容，除非总线监视器看到主机设置A2B_DATCTL产生<br>         的广播写操作。主收发信端ENDSNIFF位。</p> 
<h4>8.2.2、设备发现之后</h4> 
<p>        当A2B_BMMCFG.BMMNDSC = 1时，发生的事件顺序如下：</p> 
<p>                1、被探测总线段的下游从节点已经被DC偏置并被发现。</p> 
<p>                2、通过I2C设置A2B_BMMCFG.BMMEN = A2B_BMMCFG.BMMNDSC = 1。</p> 
<p>                3、物理地将总线监视器连接到总线段(探测点)。</p> 
<p>                4、通过I2C设置A2B_BMMCFG.BMMRXEN = 1，在总线监视器收发器正确锁定到SCFs<br>         后，IRQ引脚升高。</p> 
<p>                5、通I2C设置 A2B_RESPCYCS的初始值为0x20，A2B_RESPCYCS的适当值由SRF计<br>         时确定并自动更新。</p> 
<p>                6、通过A2B_I2SGCFG、A2B_I2SCFG、A2B_I2SRATE、A2B_SYNCOFFSET和<br>         A2B_ERRMGMT寄存器中的I2C接口配置I2S/TDM传输设置，以匹配所需的时间和格式特</p> 
<p>        征。</p> 
<p>                7、如果只需要监视控制帧和响应帧，则可以跳过此步骤。如果需要监视数据槽(并且主<br>         机允许访问它们)，可以通过I2C接口配置A2B_DNSLOTS、A2B_UPSLOTS、<br>         A2B_SLOTFMT和A2B_DATCTL寄存器。这些寄存器的正确值可以来自在发现和初始化期间<br>         嗅验相同总线段后存储在内存中的值。如果数值完全未知，那么软件可以尝试不同的值来找<br>         到合适的设置。</p> 
<p>                        1)、A2B_DNSLOTS寄存器表示下一个直列下行从机在A端收发电路的下行数据槽<br>                 数。</p> 
<p>                        2）、A2B_UPSLOTS表示下一个直列下行从属机a端收发电路的上游数据槽数。</p> 
<p>                        3）、A2B_SLOTFMT寄存器表示数据槽格式。</p> 
<p>                        4）、A2B_DATCTL.DNS和A2B_DATCTL.UPS位必须与下行从节点提交的值相匹<br>                 配。DTX0和DTX1引脚如果不设置I2S/TDM通道数据槽位，则不传输I2S/TDM通道数据<br>                 槽位。</p> 
<p>                8、DTX[1:0]引脚不传输数据槽内容，除非总线监视器看到主机设置主收发信端<br>         A2B_DATCTLENDSNIFF位产生的广播写操作。</p> 
<h2>9、优化电磁兼容性能</h2> 
<p>        在A2B收发器系统设计中，EMC性能至关重要。收发器具有几个可编程特性，可用于优化EMC性能：</p> 
<p>                1、扩展时钟。</p> 
<p>                2、可编程LVDS传输电平.</p> 
<p>                3、只有数据和只有电源的总线操作</p> 
<h3>9.1、扩频时钟</h3> 
<p>        扩展频谱时钟可用于减少PCB上的窄带排放。默认情况下，收发器上禁用扩频时钟，但写入A2B_PLLCTL寄存器可以在发现期间启用扩频时钟。A2B_PLLCTL寄存器包含为收发器内部的时钟启用扩频时钟的设置。</p> 
<p>        如果为内部时钟启用扩展频谱时钟支持，也可以为I2S接口和编程的CLKOUT接口启用扩展频谱时钟。为内部时钟、CLKOUT和I2S接口启用扩展频谱时钟可以在特定节点上减少几个dB的窄带发射。</p> 
<p>        <strong>注意：</strong>当在时钟输出上启用扩频时钟时，该时钟上的TIE抖动会增加。</p> 
<p>        如果使用扩频时钟的A2B网络，所有节点的深度和频率必须相同。按以下顺序设置节点:</p> 
<p>                1、发现所有从设备。</p> 
<p>                2、通过广播写入每个节点的A2B_PLLCTL寄存器，为所有节点(包括主节点)配置扩展频<br>         谱。</p> 
<p>        对于具有扩频的单个节点(包括AD2421/AD2422/AD2425型号的系统)，顺序如下：</p> 
<p>                1、发送所有节点。</p> 
<p>                2、为每个从属服务器配置扩展频谱(通过设置A2B_PLLCTL寄存器)，每次一个。</p> 
<p>                        1）、A2B_PLLCTL.SSDEPTH位仅限设置0x00。</p> 
<p>                        2）、相邻节点必须具有相同的A2B_PLLCTL.SSFREQ设置。</p> 
<p>        <strong>注意：</strong>当系统中的所有节点都启用了扩频时，广播写入A2B_PLLCTL寄存器是强制性的。设<br>                 置A2B_NODEADR.BRCST位，用A2B_BUS_ADDR向A2B_PLLCTL寄存器发起写操<br>                 作。广播写操作影响所有节点。它首先发生在主节点，然后在下一个SCF期间发生在从<br>                 节点。</p> 
<p>                扩频序列规划必须遵循单节点原则。A2B_PLLCTL.SSDEPTH位仅限于为扩频时钟的顺<br>                 序编程设置0x0，以及在启用了扩频时钟的单个节点的系统中。</p> 
<p>                无论是否启动扩展时钟，A2B_PLLCTL.SSMODE位可选择“仅协议”或“I2S+协议”。</p> 
<h3>9.2、可编程LVDST传输电平</h3> 
<p>        LVDS发射器可以设置为高、中、低电平发送信号。更高的传输电平产生更强的抗干扰能力，而更低的传输电平可以减少连接A2B总线节点的双绞线的排放。</p> 
<p>        LVDS传输电平可以通过调整A2B_TXACTL (A端)或A2B_TXBCTL (B端)寄存器中的设置来改变。如果需要一个非默认的传输级别，在设置A2B_SWCTL.ENSW位之前(在发现过程中)，必须在每个节点上写入A2B_TXxCTL。为了使TXxLEVEL设置生效，必须设置A2B_TXACTL.TXAOVREN使能位。</p> 
<h3>9.3、只有数据和只有电源的总线操作</h3> 
<p>        A2B总线可以在不关闭PMOS开关的情况下工作，向下游发送直流偏置。这需要设置A2B_CONTROL.SWBYP位而不是发现期间的A2B_SWCTL.ENSW位。相反，<br> A2B_SWCTL.DISNXT位允许在没有数据的情况下向下游发送直流偏置。这个设置应该与设置A2B_SWCTL.ENSW的写操作和发现设备同时进行。这些模式主要用于调试目的。</p> 
<h2>10、交叉或直通布线</h2> 
<p>        直通线缆可以通过交换B端连接器的DC耦合器来实现。对于支持直通电缆的硬件，发现时需要设置A2B_CONTROL.XCVRBINV位，以保证正常操作。在设置A2B_SWCTL.ENSW位之前需要完成用直通电缆连接每个从站。</p> 
<p>        <strong>重要：</strong>确保A2B_CONTROL.XCVRBINV位不会在执行其他操作，如写入A2B_CONTROL.NEWSTRCT位时被覆盖。(应用一种新的结构)。</p> 
<h4></h4> 
<p></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/5427a5d8da6188b4bc23d00016eb54aa/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">计算机网络概述（入门篇）</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/18ef5b76fd67bbfc439a05366fd6ec71/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">【SPDK】五、bdev子系统</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>