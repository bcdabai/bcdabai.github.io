<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>序列化和反序列化的区别 - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="序列化和反序列化的区别" />
<meta property="og:description" content="首先我们来了解为什么需要序列化 卖个关子，大家玩游戏的时候，相信都知道【存档】的功能吧，每次我们重新进入游戏的时候，直接载入存档就可以了，不用重新在重头开始，这样我们的游戏也不会丢失从面向对象的思维考虑，万事万物皆对象，我们游戏中的角色，怪兽，装备等等都可以看做是对象我们再从计算机思维考虑，创建的对象其实都是保存在内存中的，想必大家都知道内存中存储的数据只是暂时性的，断电之后是会消失的，但是游戏如果你手动存档之后就算你几天之后在开机，再次读取存档就可以了，这就很奇怪了，为什么断电之后我得装备和人物信息还都存在，还可以继续玩，这是为什么呢？其实我们只要稍加思考之后知道，我们手动存档之后是将内存中的数据存储在硬盘上的，硬盘的数据在关机之后，是不会消失的，其实这个过程就是对象的持久化，也就是我们今天理解的序列化，从我们的磁盘上读取出来的数据其实就是对象的反序列化 什么是序列化 上面引入游戏的概念是为了让大家了解为什么需要序列化和反序列化，简单的总结一下
序列化是指将我们对象实例的状态存储到媒体的过程反序列化是我们从媒体中将我们的对象状态转换成对象的过程 抽象点理解
序列化是将对象转成字节序列的过程
反序列化是将我们的字节序列转成对象的过程
序列化的目的 序列化的最终目的是为了实现对象可以跨平台存储和进行网络传输，而我们的跨平台存储和网络传输使用的是IO，IO支持的格式就是字节数组（byte[]）现在存在的问题， 我们如何将对象转成成字节数组呢？其实我们单纯的将对象转成字节数组还是不可行的，因为没有规则的字节数组我们是没办法还原成对象原本面目的，所以我们必须在对象转成字节数组的时候制就定一种规则（序列化），那我们从IO流里面读取数据的时候可以再根据这种规则把对象还原回来（反序列化） 序列化的几种方式 序列化只是定义了拆解对象的具体规则，那这种规则肯定也是多种多样的，比如现在常见的序列化方式有：JDK 原生、JSON、ProtoBuf、Hessian、Kryo等。
1.JDK（原生）
作为一个成熟的语言，JDK自带序列化方法。只要实现了Serializable接口，通过ObjectOutputStream类将对象变成byte[]字节数组
JDK 序列化会把对象类的描述信息和所有的属性以及继承的元数据都序列化为字节流，所以会导致生成的字节流相对比较大。
简单总结一下：JDK 原生的序列化方式生成的字节流比较大，也不支持跨语言，因此在实际项目和框架中用的都比较少。
2.ProtoBuf
谷歌推出的，是一种语言无关、平台无关、可扩展的序列化结构数据的方法，它可用于通信协议、数据存储等。序列化后体积小，一般用于对传输性能有较高要求的系统。
3.Hessian
Hessian 是一个轻量级的二进制 web service 协议，主要用于传输二进制数据。
在传输数据前 Hessian 支持将对象序列化成二进制流，相对于 JDK 原生序列化，Hessian序列化之后体积更小，性能更优。
4.Kryo
Kryo 是一个 Java 序列化框架，号称 Java 最快的序列化框架。Kryo 在序列化速度上很有优势，底层依赖于字节码生成机制。
由于只能限定在 JVM 语言上，所以 Kryo 不支持跨语言使用。
5.JSON
JSON 序列化方式生成的是一串有规则的字符串，在可读性上要优于上面几种方式，但是在体积上就没什么优势了。
另外 JSON 是有规则的字符串，不跟任何编程语言绑定，天然上就具备了跨平台。
总结一下：JSON 可读性强，支持跨平台，体积稍微逊色。
JSON 序列化常见的框架有：fastJSON、Jackson、Gson 等。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/6c8590af1649590a95f0358c55088e12/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-03-15T13:42:44+08:00" />
<meta property="article:modified_time" content="2022-03-15T13:42:44+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">序列化和反序列化的区别</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <h3><a id="_0"></a>首先我们来了解为什么需要序列化</h3> 
<blockquote> 
 <ol><li>卖个关子，大家玩游戏的时候，相信都知道【<strong>存档</strong>】的功能吧，每次我们重新进入游戏的时候，直接载入存档就可以了，不用重新在重头开始，这样我们的游戏也不会丢失</li><li>从面向对象的思维考虑，万事万物皆对象，我们游戏中的角色，怪兽，装备等等都可以看做是对象</li><li>我们再从计算机思维考虑，创建的对象其实都是保存在内存中的，想必大家都知道内存中存储的数据只是暂时性的，断电之后是会消失的，但是游戏如果你手动存档之后就算你几天之后在开机，再次读取存档就可以了，这就很奇怪了，为什么断电之后我得装备和人物信息还都存在，还可以继续玩，这是为什么呢？</li><li>其实我们只要稍加思考之后知道，我们手动存档之后是将内存中的数据存储在硬盘上的，硬盘的数据在关机之后，是不会消失的，其实这个过程就是对象的持久化，也就是我们今天理解的<code>序列化</code>，从我们的磁盘上读取出来的数据其实就是对象的<code>反序列化</code></li></ol> 
</blockquote> 
<h3><a id="_7"></a>什么是序列化</h3> 
<p>上面引入游戏的概念是为了让大家了解为什么需要序列化和反序列化，简单的总结一下</p> 
<ul><li><code>序列化</code>是指将我们对象实例的状态存储到媒体的过程</li><li><code>反序列化</code>是我们从媒体中将我们的对象状态转换成对象的过程</li></ul> 
<p>抽象点理解</p> 
<ul><li><code>序列化</code>是将对象转成字节序列的过程<br> <img src="https://images2.imgbox.com/c9/88/dG8TcX9f_o.png" alt=""></li><li><code>反序列化</code>是将我们的字节序列转成对象的过程<br> <img src="https://images2.imgbox.com/6b/33/a5t22F6F_o.png" alt=""></li></ul> 
<h3><a id="_19"></a>序列化的目的</h3> 
<ul><li>序列化的最终目的是为了实现对象可以跨平台存储和进行网络传输，而我们的跨平台存储和网络传输使用的是<code>IO</code>，<code>IO</code>支持的格式就是字节数组（<code>byte[]</code>）</li><li>现在存在的问题， 我们如何将对象转成成字节数组呢？其实我们单纯的将对象转成字节数组还是不可行的，因为没有规则的字节数组我们是没办法还原成对象原本面目的，所以我们必须在对象转成字节数组的时候制就定一种规则（<code>序列化</code>），<strong>那我们从<code>IO</code>流里面读取数据的时候可以再根据这种规则把对象还原回来（<code>反序列化</code>）</strong></li></ul> 
<h3><a id="_23"></a>序列化的几种方式</h3> 
<p>序列化只是定义了拆解对象的具体规则，那这种规则肯定也是多种多样的，比如现在常见的序列化方式有：JDK 原生、JSON、ProtoBuf、Hessian、Kryo等。</p> 
<blockquote> 
 <p><strong>1.JDK（原生）</strong><br> 作为一个成熟的语言，JDK自带序列化方法。只要实现了<code>Serializable</code>接口，通过<code>ObjectOutputStream</code>类将对象变成byte[]字节数组<br> <code>JDK</code> 序列化会把对象类的描述信息和所有的属性以及继承的元数据都序列化为字节流，所以会导致生成的字节流相对比较大。<br> 简单总结一下：<code>JDK</code> 原生的序列化方式生成的字节流比较大，也不支持跨语言，因此在实际项目和框架中用的都比较少。</p> 
</blockquote> 
<blockquote> 
 <p><strong>2.ProtoBuf</strong><br> 谷歌推出的，是一种语言无关、平台无关、可扩展的序列化结构数据的方法，它可用于通信协议、数据存储等。序列化后体积小，一般用于对传输性能有较高要求的系统。</p> 
</blockquote> 
<blockquote> 
 <p><strong>3.Hessian</strong><br> <code>Hessian</code> 是一个轻量级的二进制 web service 协议，主要用于传输二进制数据。<br> 在传输数据前 <code>Hessian</code> 支持将对象序列化成二进制流，相对于 JDK 原生序列化，<code>Hessian</code>序列化之后体积更小，性能更优。</p> 
</blockquote> 
<blockquote> 
 <p><strong>4.Kryo</strong><br> <code>Kryo</code> 是一个 Java 序列化框架，号称 <code>Java</code> 最快的序列化框架。<code>Kryo</code> 在序列化速度上很有优势，底层依赖于字节码生成机制。</p> 
 <p>由于只能限定在 JVM 语言上，所以 <code>Kryo</code> 不支持跨语言使用。</p> 
</blockquote> 
<blockquote> 
 <p><strong>5.JSON</strong><br> <code>JSON</code> 序列化方式生成的是一串有规则的字符串，在可读性上要优于上面几种方式，但是在体积上就没什么优势了。<br> 另外 <code>JSON</code> 是有规则的字符串，不跟任何编程语言绑定，天然上就具备了跨平台。<br> 总结一下：<code>JSON</code> 可读性强，支持跨平台，体积稍微逊色。<br> <code>JSON</code> 序列化常见的框架有：<code>fastJSON</code>、<code>Jackson</code>、<code>Gson</code> 等。</p> 
</blockquote>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/374719bf0c2da9186e9eb7aa2460174d/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">LVGL V8学习之colorwheel色轮</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/ada6dde77489764fce0dee9888f132fb/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">macos ssh remote linux的介绍</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>