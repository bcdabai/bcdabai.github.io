<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>分布式定时任务调度 - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="分布式定时任务调度" />
<meta property="og:description" content="课程目标 1、了解任务调度的应用场景和 Quartz 的基本特性
2、掌握 Quartz Java 编程和 Spring 集成的使用
3、掌握 Quartz 动态调度和集群部署的实现
4、理解 Quartz 原理与线程模型
内容定位 适合没有用过 Quartz 或者只会 Quartz 基本配置的同学
说明：基于最新稳定版本 2.3.0
1 漫谈任务调度 1.1 什么时候需要任务调度？ 1.1.1 任务调度的背景 在业务系统中有很多这样的场景：
1、账单日或者还款日上午 10 点，给每个信用卡客户发送账单通知，还款通知。如何判断客户的账单日、还款日，完成通知的发送？
2、银行业务系统，夜间要完成跑批的一系列流程，清理数据，下载文件，解析文件， 对账清算、切换结算日期等等。如何触发一系列流程的执行？
3、金融机构跟人民银行二代支付系统对接，人民银行要求低于 5W 的金额（小额支付）半个小时打一次包发送，以缓解并发压力。所以，银行的跨行转账分成了多个流程： 录入、复核、发送。如何把半个小时以内的所有数据一次性发送？
类似于这种 1、基于准确的时刻或者固定的时间间隔触发的任务，或者 2、有批量数据需要处理，或者 3、要实现两个动作解耦的场景，我们都可以用任务调度来实现。
1.2 任务调度需求分析 任务调度的实现方式有很多，如果要实现我们的调度需求，我们对这个工具有什么样的基本要求呢？
1.2.1 基本需求 1）可以定义触发的规则，比如基于时刻、时间间隔、表达式。
2）可以定义需要执行的任务。比如执行一个脚本或者一段代码。任务和规则是分开的。
3）集中管理配置，持久配置。不用把规则写在代码里面，可以看到所有的任务配置，方便维护。重启之后任务可以再次调度——配置文件或者配置中心。
4）支持任务的串行执行，例如执行 A 任务后再执行 B 任务再执行 C 任务。
5）支持多个任务并发执行，互不干扰（例如 ScheduledThreadPoolExecutor）。
6）有自己的调度器，可以启动、中断、停止任务。
7）容易集成到 Spring。
1.3 任务调度工具对比 层次举例特点操作系统Linux crontab &lt;br&gt;Windows 计划任务只能执行简单脚本或者命令数据库MySQL、Oracle可以操作数据。不能执行 Java 代码工具Kettle可以操作数据，执行脚本。没有集中配置开发语言JDK Timer、ScheduledThreadPoolTimer：单线程&lt;br&gt;JDK1." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/896343c4b8f78da37a507da16ee15685/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-09-22T20:00:00+08:00" />
<meta property="article:modified_time" content="2023-09-22T20:00:00+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">分布式定时任务调度</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-tomorrow-night">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <h3><a id="_0"></a><strong>课程目标</strong></h3> 
<p>1、了解任务调度的应用场景和 Quartz 的基本特性</p> 
<p>2、掌握 Quartz Java 编程和 Spring 集成的使用</p> 
<p>3、掌握 Quartz 动态调度和集群部署的实现</p> 
<p>4、理解 Quartz 原理与线程模型</p> 
<h4><a id="_10"></a><strong>内容定位</strong></h4> 
<p>适合没有用过 Quartz 或者只会 Quartz 基本配置的同学</p> 
<p>说明：基于最新稳定版本 2.3.0</p> 
<h3><a id="1__16"></a>1 漫谈任务调度</h3> 
<h4><a id="11__18"></a><strong>1.1 什么时候需要任务调度？</strong></h4> 
<h5><a id="111__20"></a><strong>1.1.1 任务调度的背景</strong></h5> 
<p>在业务系统中有很多这样的场景：</p> 
<p>1、账单日或者还款日上午 10 点，给每个信用卡客户发送账单通知，还款通知。如何判断客户的账单日、还款日，完成通知的发送？</p> 
<p>2、银行业务系统，夜间要完成跑批的一系列流程，清理数据，下载文件，解析文件， 对账清算、切换结算日期等等。如何触发一系列流程的执行？</p> 
<p>3、金融机构跟人民银行二代支付系统对接，人民银行要求低于 5W 的金额（小额支付）半个小时打一次包发送，以缓解并发压力。所以，银行的跨行转账分成了多个流程： 录入、复核、发送。如何把半个小时以内的所有数据一次性发送？</p> 
<p>类似于这种 1、基于准确的时刻或者固定的时间间隔触发的任务，或者 2、有批量数据需要处理，或者 3、要实现两个动作解耦的场景，我们都可以用任务调度来实现。</p> 
<h4><a id="12__32"></a><strong>1.2 任务调度需求分析</strong></h4> 
<p>任务调度的实现方式有很多，如果要实现我们的调度需求，我们对这个工具有什么样的基本要求呢？</p> 
<h5><a id="121__36"></a><strong>1.2.1 基本需求</strong></h5> 
<p>1）可以定义触发的规则，比如基于时刻、时间间隔、表达式。</p> 
<p>2）可以定义需要执行的任务。比如执行一个脚本或者一段代码。任务和规则是分开的。</p> 
<p>3）集中管理配置，持久配置。不用把规则写在代码里面，可以看到所有的任务配置，方便维护。重启之后任务可以再次调度——配置文件或者配置中心。</p> 
<p>4）支持任务的串行执行，例如执行 A 任务后再执行 B 任务再执行 C 任务。</p> 
<p>5）支持多个任务并发执行，互不干扰（例如 ScheduledThreadPoolExecutor）。</p> 
<p>6）有自己的调度器，可以启动、中断、停止任务。</p> 
<p>7）容易集成到 Spring。</p> 
<h4><a id="13__52"></a><strong>1.3 任务调度工具对比</strong></h4> 
<table><thead><tr><th><strong>层次</strong></th><th><strong>举例</strong></th><th><strong>特点</strong></th></tr></thead><tbody><tr><td><strong>操作系统</strong></td><td><strong>Linux crontab &lt;br&gt;Windows 计划任务</strong></td><td><strong>只能执行简单脚本或者命令</strong></td></tr><tr><td><strong>数据库</strong></td><td><strong>MySQL、Oracle</strong></td><td><strong>可以操作数据。不能执行 Java 代码</strong></td></tr><tr><td><strong>工具</strong></td><td><strong>Kettle</strong></td><td><strong>可以操作数据，执行脚本。没有集中配置</strong></td></tr><tr><td><strong>开发语言</strong></td><td><strong>JDK Timer、ScheduledThreadPool</strong></td><td><strong>Timer：单线程&lt;br&gt;JDK1.5 之后：ScheduledThreadPool（Cache、Fiexed、Single）:没有集中配置，日程管理不够灵活</strong></td></tr><tr><td><strong>容器</strong></td><td><strong>Spring Task、@Scheduled</strong></td><td><strong>不支持集群</strong></td></tr><tr><td><strong>分布式框架</strong></td><td><strong>XXL-JOB，Elastic-Job</strong></td><td></td></tr></tbody></table> 
<p><strong>@Scheduled 也是用 JUC 的 ScheduledExecutorService 实现的Scheduled(cron = “0 15 10 15 * ?”)</strong></p> 
<p>1、 ScheduledAnnotationBeanPostProcessor 的 postProcessAfterInitialization 方法将@Scheduled 的方法包装为指定的 task添加到 ScheduledTaskRegistrar 中</p> 
<p>2、 ScheduledAnnotationBeanPostProcessor 会监听 Spring 的容器初始化事件，在 Spring 容器初始化完成后进行TaskScheduler 实现类实例的查找，若发现有 SchedulingConfigurer 的实现类实例，则跳过 3</p> 
<p>3、 查找 TaskScheduler 的实现类实例默认是通过类型查找，若有多个实现则会查找名字为"taskScheduler"的实现 Bean，若没有找到则在 ScheduledTaskRegistrar 调度任务的时候会创建一个 newSingleThreadScheduledExecutor，将TaskScheduler 的实现类实例设置到 ScheduledTaskRegistrar 属性中</p> 
<p>4、 ScheduledTaskRegistrar 的 scheduleTasks 方法触发任务调度</p> 
<p>5、 真正调度任务的类是 TaskScheduler 实现类中的 ScheduledExecutorService，由 J.U.C 提供</p> 
<h3><a id="2_Quartz__75"></a><strong>2 Quartz 基本介绍</strong></h3> 
<p>官网：http://www.quartz-scheduler.org/</p> 
<p>Quartz 的意思是石英，像石英表一样精确。</p> 
<p>Quartz is a richly featured, open source job scheduling library that can be integrated within virtually any Java application - from the smallest stand-alone application to the largest e-commerce system. Quartz can be used to create simple or complex schedules for executing tens, hundreds, or even tens-of-thousands of jobs; jobs whose tasks are defined as standard Java components that may execute virtually anything you may program them to do. The Quartz Scheduler includes many enterprise-class features, such as support for JTA transactions and clustering.</p> 
<p>Quatz 是一个特性丰富的，开源的任务调度库，它几乎可以嵌入所有的 Java 程序，从很小的独立应用程序到大型商业系统。Quartz 可以用来创建成百上千的简单的或者复杂的任务，这些任务可以用来执行任何程序可以做的事情。Quartz 拥有很多企业级的特性，包括支持 JTA 事务和集群。</p> 
<p>Quartz 是一个老牌的任务调度系统，98 年构思，01 年发布到 sourceforge。现在更新比较慢，因为已经非常成熟了。</p> 
<p>https://github.com/quartz-scheduler/quartz</p> 
<p>Quartz 的目的就是让任务调度更加简单，开发人员只需要关注业务即可。他是用 Java 语言编写的（也有.NET 的版本）。Java 代码能做的任何事情，Quartz 都可以调度。</p> 
<p><strong>特点：</strong></p> 
<p>精确到毫秒级别的调度</p> 
<p>可以独立运行，也可以集成到容器中</p> 
<p>支持事务（JobStoreCMT ）</p> 
<p>支持集群</p> 
<p>支持持久化</p> 
<h3><a id="3Quartz_Java__103"></a>3.<strong>Quartz Java 编程</strong></h3> 
<p>http://www.quartz-scheduler.org/documentation/quartz-2.3.0/</p> 
<p>http://www.quartz-scheduler.org/documentation/quartz-2.3.0/quick-start.html</p> 
<h4><a id="31__109"></a><strong>3.1 引入依赖</strong></h4> 
<pre><code class="prism language-xml"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">&gt;</span></span> 
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">&gt;</span></span>org.quartz-scheduler<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">&gt;</span></span> 
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">&gt;</span></span>quartz<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">&gt;</span></span> 
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">&gt;</span></span>2.3.0<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">&gt;</span></span> 
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">&gt;</span></span>
</code></pre> 
<h4><a id="32__119"></a><strong>3.2 默认配置文件</strong></h4> 
<p>org.quartz.core 包下，有一个默认的配置文件，quartz.properties。当我们没有定义一个同名的配置文件的时候，就会使用默认配置文件里面的配置。</p> 
<pre><code class="prism language-properties">org.quartz.scheduler.instanceName: DefaultQuartzScheduler 
org.quartz.scheduler.rmi.export: false 
org.quartz.scheduler.rmi.proxy: false 
org.quartz.scheduler.wrapJobExecutionInUserTransaction: false org.quartz.threadPool.class: org.quartz.simpl.SimpleThreadPool 
org.quartz.threadPool.threadCount: 10 
org.quartz.threadPool.threadPriority: 5 org.quartz.threadPool.threadsInheritContextClassLoaderOfInitializingThread: true org.quartz.jobStore.misfireThreshold: 60000 
org.quartz.jobStore.class: org.quartz.simpl.RAMJobStore
</code></pre> 
<h4><a id="33__Job_133"></a><strong>3.3 创建 Job</strong></h4> 
<p>实现唯一的方法 execute()，方法中的代码就是任务执行的内容。此处仅输出字符串。</p> 
<pre><code class="prism language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">MyJob</span> <span class="token keyword">implements</span> <span class="token class-name">Job</span> <span class="token punctuation">{<!-- --></span> 
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">execute</span><span class="token punctuation">(</span><span class="token class-name">JobExecutionContext</span> context<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">JobExecutionException</span> <span class="token punctuation">{<!-- --></span> 
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"假发在哪里买的"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span> 
<span class="token punctuation">}</span>
</code></pre> 
<p>在测试类 main()方法中，把 Job 进一步包装成 JobDetail。</p> 
<p>必须要指定 JobName 和 groupName，两个合起来是唯一标识符。</p> 
<p>可以携带 KV 的数据（JobDataMap），用于扩展属性，在运行的时候可以从 context 获取到</p> 
<pre><code class="prism language-java"><span class="token class-name">JobDetail</span> jobDetail <span class="token operator">=</span> <span class="token class-name">JobBuilder</span><span class="token punctuation">.</span><span class="token function">newJob</span><span class="token punctuation">(</span><span class="token class-name">MyJob1</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span> 
    <span class="token punctuation">.</span><span class="token function">withIdentity</span><span class="token punctuation">(</span><span class="token string">"job1"</span><span class="token punctuation">,</span> <span class="token string">"group1"</span><span class="token punctuation">)</span> 
    <span class="token punctuation">.</span><span class="token function">usingJobData</span><span class="token punctuation">(</span><span class="token string">"msb"</span><span class="token punctuation">,</span><span class="token string">"我爱涛哥"</span><span class="token punctuation">)</span> 
    <span class="token punctuation">.</span><span class="token function">usingJobData</span><span class="token punctuation">(</span><span class="token string">"moon"</span><span class="token punctuation">,</span><span class="token number">5.21F</span><span class="token punctuation">)</span> 
    <span class="token punctuation">.</span><span class="token function">build</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> 
<h4><a id="34__Trigger_159"></a><strong>3.4 创建 Trigger</strong></h4> 
<p>在测试类 main()方法中，基于 SimpleTrigger 定义了一个每 2 秒钟运行一次、不断重复的 Trigger：</p> 
<pre><code class="prism language-java"><span class="token class-name">Trigger</span> trigger <span class="token operator">=</span> <span class="token class-name">TriggerBuilder</span><span class="token punctuation">.</span><span class="token function">newTrigger</span><span class="token punctuation">(</span><span class="token punctuation">)</span> 
    <span class="token punctuation">.</span><span class="token function">withIdentity</span><span class="token punctuation">(</span><span class="token string">"trigger1"</span><span class="token punctuation">,</span> <span class="token string">"group1"</span><span class="token punctuation">)</span> 
    <span class="token punctuation">.</span><span class="token function">startNow</span><span class="token punctuation">(</span><span class="token punctuation">)</span> 
    <span class="token punctuation">.</span><span class="token function">withSchedule</span><span class="token punctuation">(</span><span class="token class-name">SimpleScheduleBuilder</span><span class="token punctuation">.</span><span class="token function">simpleSchedule</span><span class="token punctuation">(</span><span class="token punctuation">)</span> 
        <span class="token punctuation">.</span><span class="token function">withIntervalInSeconds</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span> 
        <span class="token punctuation">.</span><span class="token function">repeatForever</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> 
    <span class="token punctuation">.</span><span class="token function">build</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> 
<h4><a id="35__Scheduler_173"></a><strong>3.5 创建 Scheduler</strong></h4> 
<p>在测试类 main()方法中，通过 Factory 获取调度器的实例，把 JobDetail 和 Trigger绑定，注册到容器中。</p> 
<p>Scheduler 先启动后启动无所谓，只要有 Trigger 到达触发条件，就会执行任务。</p> 
<pre><code class="prism language-java"><span class="token class-name">SchedulerFactory</span> factory <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">StdSchedulerFactory</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> 
<span class="token class-name">Scheduler</span> scheduler <span class="token operator">=</span> factory<span class="token punctuation">.</span><span class="token function">getScheduler</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> 
scheduler<span class="token punctuation">.</span><span class="token function">scheduleJob</span><span class="token punctuation">(</span>jobDetail<span class="token punctuation">,</span> trigger<span class="token punctuation">)</span><span class="token punctuation">;</span> 
scheduler<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> 
<p>注意这里，调度器一定是单例的。</p> 
<h4><a id="36__188"></a><strong>3.6 体系结构总结</strong></h4> 
<p><img src="https://images2.imgbox.com/2e/be/E49j0JTl_o.png" alt="在这里插入图片描述"></p> 
<h5><a id="361_JobDetail_193"></a><strong>3.6.1 JobDetail</strong></h5> 
<p>我们创建一个实现 Job 接口的类，使用 JobBuilder 包装成 JobDetail，它可以携带 KV 的数据。</p> 
<h5><a id="362_Trigger_197"></a><strong>3.6.2 Trigger</strong></h5> 
<pre><code>定义任务的触发规律，Trigger，使用 TriggerBuilder 来构建。
</code></pre> 
<pre><code>JobDetail 跟 Trigger 是 1:N 的关系。
</code></pre> 
<pre><code>思考：为什么要解耦？
</code></pre> 
<pre><code>Trigger 接口在 Quartz 有 4 个继承的子接口：
</code></pre> 
<table><thead><tr><th><strong>子接口</strong></th><th><strong>描述</strong></th><th><strong>特点</strong></th></tr></thead><tbody><tr><td>SimpleTrigger</td><td>简单触发器</td><td>固定时刻或时间间隔，毫秒</td></tr><tr><td>CalendarIntervalTrigger</td><td>基于日历的触发器</td><td>比简单触发器更多时间单位，支持非固定时间的触发，例如一年可能 365/366，一个月可能 28/29/30/31</td></tr><tr><td>DailyTimeIntervalTrigger</td><td>基于日期的触发器</td><td>每天的某个时间段</td></tr><tr><td>CronTrigger</td><td>基于 Cron 表达式的触发器</td><td></td></tr></tbody></table> 
<p><strong>MutableTrigger 和 CoreTrigger 最终也是用到以上四个类的实现类</strong><br> <img src="https://images2.imgbox.com/3d/6b/TQ7qYG0M_o.png" alt="在这里插入图片描述"></p> 
<p>代码：standalone com.msb.trigger.TriggerDefine</p> 
<h6><a id="SimpleTrigger_229"></a><strong>SimpleTrigger</strong></h6> 
<pre><code>SimpleTrigger 可以定义固定时刻或者固定时间间隔的调度规则（精确到毫秒）。
</code></pre> 
<pre><code>例如：每天 9 点钟运行；每隔 30 分钟运行一次。
</code></pre> 
<h6><a id="CalendarIntervalTrigger_239"></a><strong>CalendarIntervalTrigger</strong></h6> 
<pre><code>CalendarIntervalTrigger 可以定义更多时间单位的调度需求，精确到秒。
</code></pre> 
<pre><code>好处是不需要去计算时间间隔，比如 1 个小时等于多少毫秒。
</code></pre> 
<pre><code>例如每年、每个月、每周、每天、每小时、每分钟、每秒。
</code></pre> 
<pre><code>每年的月数和每个月的天数不是固定的，这种情况也适用。
</code></pre> 
<h6><a id="DailyTimeIntervalTrigger_257"></a><strong>DailyTimeIntervalTrigger</strong></h6> 
<pre><code>每天的某个时间段内，以一定的时间间隔执行任务。
</code></pre> 
<pre><code>例如：每天早上 9 点到晚上 9 点，每隔半个小时执行一次，并且只在周一到周六执行。
</code></pre> 
<h6><a id="CronTrigger_267"></a><strong>CronTrigger</strong></h6> 
<p>CronTrigger可以定义基于 Cron 表达式的调度规则，是最常用的触发器类型。</p> 
<p>Cron 表达式</p> 
<table><thead><tr><th><strong>位置</strong></th><th><strong>时间域</strong></th><th></th><th><strong>特殊值</strong></th></tr></thead><tbody><tr><td>1</td><td>秒</td><td>0-59</td><td>, - * /</td></tr><tr><td>2</td><td>分钟</td><td>0-59</td><td>, - * /</td></tr><tr><td>3</td><td>小时</td><td>0-23</td><td>, - * /</td></tr><tr><td>4</td><td>日期</td><td>1-31</td><td>, - * ? / L W C</td></tr><tr><td>5</td><td>月份</td><td>1-12</td><td>, - * /</td></tr><tr><td>6</td><td>星期</td><td>1-7</td><td>, - * ? / L W C</td></tr><tr><td>7</td><td>年份（可选）</td><td>1-31</td><td>, - * /</td></tr></tbody></table> 
<p>星号(*)：可用在所有字段中，表示对应时间域的每一个时刻，例如，在分钟字段时，表示“每分钟”；</p> 
<p>问号（?）：该字符只在日期和星期字段中使用，它通常指定为“无意义的值”，相当于点位符；</p> 
<p>减号(-)：表达一个范围，如在小时字段中使用“10-12”，则表示从 10 到 12 点，即 10,11,12；</p> 
<p>逗号(,)：表达一个列表值，如在星期字段中使用“MON,WED,FRI”，则表示星期一，星期三和星期五；</p> 
<p>斜杠(/)：x/y 表达一个等步长序列，x 为起始值，y 为增量步长值。如在分钟字段中使用 0/15，则表示为 0,15,30 和 45 秒，而 5/15 在分钟字段中表示 5,20,35,50，你也可以使用*/y，它等同于 0/y；</p> 
<p>L：该字符只在日期和星期字段中使用，代表“Last”的意思，但它在两个字段中意思不同。L 在日期字段中，表示 这个月份的最后一天，如一月的 31 号，非闰年二月的 28 号；如果 L 用在星期中，则表示星期六，等同于 7。但是，如果 L 出现在星期字段里，而且在前面有一个数值 X，则表示“这个月的最后 X 天”，例如，6L 表示该月的最后星期五；</p> 
<p>W：该字符只能出现在日期字段里，是对前导日期的修饰，表示离该日期最近的工作日。例如 15W 表示离该月 15号最近的工作日，如果该月 15 号是星期六，则匹配 14 号星期五；如果 15 日是星期日，则匹配 16 号星期一；如果 15号是星期二，那结果就是 15 号星期二。但必须注意关联的匹配日期不能够跨月，如你指定 1W，如果 1 号是星期六，结果匹配的是 3 号星期一，而非上个月最后的那天。W 字符串只能指定单一日期，而不能指定日期范围；</p> 
<p>LW 组合：在日期字段可以组合使用 LW，它的意思是当月的最后一个工作日；</p> 
<p>井号(#)：该字符只能在星期字段中使用，表示当月某个工作日。如 6#3 表示当月的第三个星期五(6 表示星期五，#3 表示当前的第三个)，而 4#5 表示当月的第五个星期三，假设当月没有第五个星期三，忽略不触发；</p> 
<p>C：该字符只在日期和星期字段中使用，代表“Calendar”的意思。它的意思是计划所关联的日期，如果日期没有被关联，则相当于日历中所有日期。例如 5C 在日期字段中就相当于日历 5 日以后的第一天。1C 在星期字段中相当于星期日后的第一天。</p> 
<p>Cron 表达式对特殊字符的大小写不敏感，对代表星期的缩写英文大小写也不敏感。</p> 
<p>上面我们定义的都是在什么时间执行，但是我们有一些在什么时间不执行的需求，比如：理财周末和法定假日购买不计息；证券公司周末和法定假日休市。</p> 
<p>是不是要把日期写在数据库中，然后读取基于当前时间判断呢？</p> 
<h6><a id="Calendar_309"></a>基于Calendar的排除规则</h6> 
<p>如果要在触发器的基础上，排除一些时间区间不执行任务，就要用到Quartz的Calendar类（注意不是JDK的Calendar）。可以按年、月、周、日、特定日期、Cron表达式排除。<br> <img src="https://images2.imgbox.com/8f/51/AB7hrK85_o.png" alt="在这里插入图片描述"></p> 
<p>调用Trigger的modifiedByCalendar()添加到触发器中，并且调用调度器的addCalendar()方法注册排除规则。</p> 
<p>代码示例：standalone工程：com.msb.calendar.CalendarDemo</p> 
<table><thead><tr><th>Calendar名称</th><th><strong>用法</strong></th></tr></thead><tbody><tr><td>BaseCalendar</td><td>为高级的 Calendar 实现了基本的功能，实现了 org.quartz.Calendar 接口</td></tr><tr><td>AnnualCalendar</td><td>排除年中一天或多天</td></tr><tr><td>CronCalendar</td><td>日历的这种实现排除了由给定的CronExpression表达的时间集合。 例如，您可以使用此日历使用表达式“* * 0-7,18-23？* *”每天排除所有营业时间（上午8点至下午5点）。 如果CronTrigger具有给定的cron表达式并且与具有相同表达式的CronCalendar相关联，则日历将排除触发器包含的所有时间，并且它们将彼此抵消。</td></tr><tr><td>DailyCalendar</td><td>您可以使用此日历来排除营业时间（上午8点 - 5点）每天。 每个DailyCalendar仅允许指定单个时间范围，并且该时间范围可能不会跨越每日边界（即，您不能指定从上午8点至凌晨5点的时间范围）。 如果属性invertTimeRange为false（默认），则时间范围定义触发器不允许触发的时间范围。 如果invertTimeRange为true，则时间范围被反转 - 也就是排除在定义的时间范围之外的所有时间。</td></tr><tr><td>HolidayCalendar</td><td>特别的用于从 Trigger 中排除节假日</td></tr><tr><td>MonthlyCalendar</td><td>排除月份中的指定数天，例如，可用于排除每月的最后一天</td></tr><tr><td>WeeklyCalendar</td><td>排除星期中的任意周几，例如，可用于排除周末，默认周六和周日</td></tr></tbody></table> 
<h5><a id="Scheduler_330"></a><strong>Scheduler</strong></h5> 
<p>调度器，是Quartz的指挥官，由StdSchedulerFactory产生。它是单例的。</p> 
<p>并且是Quartz中最重要的API，默认是实现类是StdScheduler，里面包含了一个QuartzScheduler。QuartzScheduler里面又包含了一个QuartzSchedulerThread。<br> <img src="https://images2.imgbox.com/c2/29/syu4IUvT_o.png" alt="在这里插入图片描述"></p> 
<p>Scheduler中的方法主要分为三大类：</p> 
<p>1）操作调度器本身，例如调度器的启动start()、调度器的关闭shutdown()。</p> 
<p>2）操作Trigger，例如pauseTriggers()、resumeTrigger()。</p> 
<p>3）操作Job，例如scheduleJob()、unscheduleJob()、rescheduleJob()</p> 
<p>这些方法非常重要，可以实现任务的动态调度。</p> 
<p>Scheduler中的方法主要分为三大类：</p> 
<p>1）操作调度器本身，例如调度器的启动start()、调度器的关闭shutdown()。</p> 
<p>2）操作Trigger，例如pauseTriggers()、resumeTrigger()。</p> 
<p>3）操作Job，例如scheduleJob()、unscheduleJob()、rescheduleJob()</p> 
<p>这些方法非常重要，可以实现任务的动态调度。</p> 
<h5><a id="Listener_357"></a><strong>Listener</strong></h5> 
<p>我们有这么一种需求，在每个任务运行结束之后发送通知给运维管理员。那是不是要在每个任务的最后添加一行代码呢？这种方式对原来的代码造成了入侵，不利于维护。如果代码不是写在任务代码的最后一行，怎么知道任务执行完了呢？或者说，怎么监测到任务的生命周期呢？</p> 
<p>观察者模式：定义对象间一种一对多的依赖关系，使得每当一个对象改变状态，则所有依赖它的对象都会得到通知并自动更新。</p> 
<p>Quartz中提供了三种Listener，监听Scheduler的，监听Trigger的，监听Job的。</p> 
<p>只需要创建类实现相应的接口，并在Scheduler上注册Listener，便可实现对核心对象的监听。</p> 
<p>standalone工程：com.msb.listener</p> 
<p>MyJobListenerTest</p> 
<p>MySchedulerListenerTest</p> 
<p>MyTriggerListenerTest</p> 
<h6><a id="JobListener_375"></a>JobListener</h6> 
<p>四个方法：</p> 
<table><thead><tr><th><strong>方法</strong></th><th><strong>作用或****执行实际</strong></th></tr></thead><tbody><tr><td>getName()</td><td>返回JobListener 的名称</td></tr><tr><td>jobToBeExecuted()</td><td>Scheduler 在 JobDetail 将要被执行时调用这个方法</td></tr><tr><td>jobExecutionVetoed()</td><td>Scheduler 在 JobDetail 即将被执行，但又被 TriggerListener 否决了时调用这个方法</td></tr><tr><td>jobWasExecuted()</td><td>Scheduler 在 JobDetail 被执行之后调用这个方法</td></tr></tbody></table> 
<p>工具类：ListenerManager，用于添加、获取、移除监听器</p> 
<p>工具类：Matcher，主要是基于groupName和keyName进行匹配。<br> <img src="https://images2.imgbox.com/6a/37/UozlbUkd_o.png" alt="在这里插入图片描述"></p> 
<h6><a id="TriggerListener_393"></a>TriggerListener</h6> 
<table><thead><tr><th><strong>方法</strong></th><th><strong>作用或执行实际</strong></th></tr></thead><tbody><tr><td>getName()</td><td>返回监听器的名称</td></tr><tr><td>triggerFired()</td><td>Trigger 被触发，Job 上的 execute() 方法将要被执行时，Scheduler 就调用这个方法</td></tr><tr><td>vetoJobExecution()</td><td>在 Trigger 触发后，Job 将要被执行时由 Scheduler 调用这个方法。TriggerListener 给了一个选择去否决 Job 的执行。假如这个方法返回 true，这个 Job 将不会为此次 Trigger 触发而得到执行</td></tr><tr><td>triggerMisfired()</td><td>Trigger 错过触发时调用</td></tr><tr><td>triggerComplete()</td><td>Trigger 被触发并且完成了 Job 的执行时，Scheduler 调用这个方法</td></tr></tbody></table> 
<h6><a id="SchedulerListener_403"></a>SchedulerListener</h6> 
<p>方法比较多，省略。</p> 
<h5><a id="JobStore_407"></a><strong>JobStore</strong></h5> 
<p>问题：最多可以运行多少个任务（磁盘、内存、线程数）</p> 
<p>Jobstore用来存储任务和触发器相关的信息，例如所有任务的名称、数量、状态等等。Quartz中有两种存储任务的方式，一种在在内存，一种是在数据库。</p> 
<h6><a id="RAMJobStore_413"></a>RAMJobStore</h6> 
<p>Quartz默认的JobStore是RAMJobstore，也就是把任务和触发器信息运行的信息存储在内存中，用到了HashMap、TreeSet、HashSet等等数据结构。</p> 
<p>如果程序崩溃或重启，所有存储在内存中的数据都会丢失。所以我们需要把这些数据持久化到磁盘。</p> 
<h6><a id="JDBCJobStore_419"></a>JDBCJobStore</h6> 
<p>JDBCJobStore可以通过JDBC接口，将任务运行数据保存在数据库中。</p> 
<p><img src="https://images2.imgbox.com/64/7c/QpafY7tf_o.png" alt="在这里插入图片描述"></p> 
<p>JDBC的实现方式有两种，JobStoreSupport类的两个子类：</p> 
<p>JobStoreTX：在独立的程序中使用，自己管理事务，不参与外部事务。</p> 
<p>JobStoreCMT：(Container Managed Transactions (CMT)，如果需要容器管理事务时，使用它。</p> 
<p>使用JDBCJobSotre时，需要配置数据库信息：</p> 
<pre><code class="prism language-properties">org.quartz.jobStore.class:org.quartz.impl.jdbcjobstore.JobStoreTX
org.quartz.jobStore.driverDelegateClass:org.quartz.impl.jdbcjobstore.StdJDBCDelegate
\# 使用quartz.properties，不使用默认配置
org.quartz.jobStore.useProperties:true
\#数据库中quartz表的表名前缀
org.quartz.jobStore.tablePrefix:QRTZ_
org.quartz.jobStore.dataSource:myDS
</code></pre> 
<pre><code class="prism language-properties">\#配置数据源
org.quartz.dataSource.myDS.driver:com.mysql.jdbc.Driver
org.quartz.dataSource.myDS.URL:jdbc:mysql://localhost:3306/quartz?useUnicode=true&amp;characterEncoding=utf8
org.quartz.dataSource.myDS.user:root
org.quartz.dataSource.myDS.password:123456
org.quartz.dataSource.myDS.validationQuery=select 0 from dual
</code></pre> 
<p>问题来了？需要建什么表？表里面有什么字段？字段类型和长度是什么？</p> 
<p>在官网的Downloads链接中，提供了11张表的建表语句：</p> 
<p>quartz-2.2.3-distribution\quartz-2.2.3\docs\dbTables</p> 
<p>2.3的版本在这个路径下：src\org\quartz\impl\jdbcjobstore</p> 
<p>表名与作用：</p> 
<table><thead><tr><th><strong>表名</strong></th><th><strong>作用</strong></th></tr></thead><tbody><tr><td>QRTZ_BLOB_TRIGGERS</td><td>Trigger作为Blob类型存储</td></tr><tr><td>QRTZ_CALENDARS</td><td>存储Quartz的Calendar信息</td></tr><tr><td>QRTZ_CRON_TRIGGERS</td><td>存储CronTrigger，包括Cron表达式和时区信息</td></tr><tr><td>QRTZ_FIRED_TRIGGERS</td><td>存储与已触发的Trigger相关的状态信息，以及相关Job的执行信息</td></tr><tr><td>QRTZ_JOB_DETAILS</td><td>存储每一个已配置的Job的详细信息</td></tr><tr><td>QRTZ_LOCKS</td><td>存储程序的悲观锁的信息</td></tr><tr><td>QRTZ_PAUSED_TRIGGER_GRPS</td><td>存储已暂停的Trigger组的信息</td></tr><tr><td>QRTZ_SCHEDULER_STATE</td><td>存储少量的有关Scheduler的状态信息，和别的Scheduler实例</td></tr><tr><td>QRTZ_SIMPLE_TRIGGERS</td><td>存储SimpleTrigger的信息，包括重复次数、间隔、以及已触的次数</td></tr><tr><td>QRTZ_SIMPROP_TRIGGERS</td><td>存储CalendarIntervalTrigger和DailyTimeIntervalTrigger两种类型的触发器</td></tr><tr><td>QRTZ_TRIGGERS</td><td>存储已配置的Trigger的信息</td></tr></tbody></table> 
<h3><a id="4QuartzSpring_477"></a>4.Quartz集成到Spring</h3> 
<p>Spring-quartz工程</p> 
<p>Spring在spring-context-support.jar中直接提供了对Quartz的支持。</p> 
<p><img src="https://images2.imgbox.com/e4/9c/gl8ZRUfL_o.png" alt="在这里插入图片描述"></p> 
<p>可以在配置文件中把JobDetail、Trigger、Scheduler定义成Bean。</p> 
<h4><a id="Job_488"></a>定义Job</h4> 
<pre><code class="prism language-xml"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>bean</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>myJob1<span class="token punctuation">"</span></span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>org.springframework.scheduling.quartz.JobDetailFactoryBean<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>property</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>name<span class="token punctuation">"</span></span> <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>my_job_1<span class="token punctuation">"</span></span><span class="token punctuation">/&gt;</span></span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>property</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>group<span class="token punctuation">"</span></span> <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>my_group<span class="token punctuation">"</span></span><span class="token punctuation">/&gt;</span></span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>property</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>jobClass<span class="token punctuation">"</span></span> <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>com.msb.quartz.MyJob1<span class="token punctuation">"</span></span><span class="token punctuation">/&gt;</span></span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>property</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>durability<span class="token punctuation">"</span></span> <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>true<span class="token punctuation">"</span></span><span class="token punctuation">/&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>bean</span><span class="token punctuation">&gt;</span></span>
</code></pre> 
<h4><a id="Trigger_499"></a>定义Trigger</h4> 
<pre><code class="prism language-xml"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>bean</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>simpleTrigger<span class="token punctuation">"</span></span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>org.springframework.scheduling.quartz.SimpleTriggerFactoryBean<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>   <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>property</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>name<span class="token punctuation">"</span></span> <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>my_trigger_1<span class="token punctuation">"</span></span><span class="token punctuation">/&gt;</span></span>   <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>property</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>group<span class="token punctuation">"</span></span> <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>my_group<span class="token punctuation">"</span></span><span class="token punctuation">/&gt;</span></span>   <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>property</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>jobDetail<span class="token punctuation">"</span></span> <span class="token attr-name">ref</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>myJob1<span class="token punctuation">"</span></span><span class="token punctuation">/&gt;</span></span>   <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>property</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>startDelay<span class="token punctuation">"</span></span> <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>1000<span class="token punctuation">"</span></span><span class="token punctuation">/&gt;</span></span>   <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>property</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>repeatInterval<span class="token punctuation">"</span></span> <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>5000<span class="token punctuation">"</span></span><span class="token punctuation">/&gt;</span></span>   <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>property</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>repeatCount<span class="token punctuation">"</span></span> <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>2<span class="token punctuation">"</span></span><span class="token punctuation">/&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>bean</span><span class="token punctuation">&gt;</span></span>
</code></pre> 
<h4><a id="Scheduler_506"></a>定义Scheduler</h4> 
<pre><code class="prism language-xml"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>bean</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>scheduler<span class="token punctuation">"</span></span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>org.springframework.scheduling.quartz.SchedulerFactoryBean<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>property</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>triggers<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>list</span><span class="token punctuation">&gt;</span></span>
      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>ref</span> <span class="token attr-name">bean</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>simpleTrigger<span class="token punctuation">"</span></span><span class="token punctuation">/&gt;</span></span>
      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>ref</span> <span class="token attr-name">bean</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>cronTrigger<span class="token punctuation">"</span></span><span class="token punctuation">/&gt;</span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>list</span><span class="token punctuation">&gt;</span></span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>property</span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>bean</span><span class="token punctuation">&gt;</span></span>
</code></pre> 
<p>既然可以在配置文件配置，当然也可以用@Bean注解配置。在配置类上加上@Configuration让Spring读取到。</p> 
<pre><code class="prism language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">QuartzConfig</span> <span class="token punctuation">{<!-- --></span>
  <span class="token annotation punctuation">@Bean</span>
  <span class="token keyword">public</span> <span class="token class-name">JobDetail</span> <span class="token function">printTimeJobDetail</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
    <span class="token keyword">return</span> <span class="token class-name">JobBuilder</span><span class="token punctuation">.</span><span class="token function">newJob</span><span class="token punctuation">(</span><span class="token class-name">MyJob1</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span>
       <span class="token punctuation">.</span><span class="token function">withIdentity</span><span class="token punctuation">(</span><span class="token string">"msbJob"</span><span class="token punctuation">)</span>
       <span class="token punctuation">.</span><span class="token function">usingJobData</span><span class="token punctuation">(</span><span class="token string">"msb"</span><span class="token punctuation">,</span> <span class="token string">"涛哥"</span><span class="token punctuation">)</span>
       <span class="token punctuation">.</span><span class="token function">storeDurably</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
       <span class="token punctuation">.</span><span class="token function">build</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
 <span class="token punctuation">}</span>
  <span class="token annotation punctuation">@Bean</span>
  <span class="token keyword">public</span> <span class="token class-name">Trigger</span> <span class="token function">printTimeJobTrigger</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    <span class="token class-name">CronScheduleBuilder</span> cronScheduleBuilder <span class="token operator">=</span> <span class="token class-name">CronScheduleBuilder</span><span class="token punctuation">.</span><span class="token function">cronSchedule</span><span class="token punctuation">(</span><span class="token string">"0/5 * * * * ?"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token class-name">TriggerBuilder</span><span class="token punctuation">.</span><span class="token function">newTrigger</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
       <span class="token punctuation">.</span><span class="token function">forJob</span><span class="token punctuation">(</span><span class="token function">printTimeJobDetail</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
       <span class="token punctuation">.</span><span class="token function">withIdentity</span><span class="token punctuation">(</span><span class="token string">"quartzTaskService"</span><span class="token punctuation">)</span>
       <span class="token punctuation">.</span><span class="token function">withSchedule</span><span class="token punctuation">(</span>cronScheduleBuilder<span class="token punctuation">)</span>
       <span class="token punctuation">.</span><span class="token function">build</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
 <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>运行 spring-quartz工程的com.msb.quartz.QuartzTest</p> 
<h3><a id="5_545"></a>5.动态调度的实现</h3> 
<pre><code>springboot-quartz工程
</code></pre> 
<pre><code>传统的Spring方式集成，由于任务信息全部配置在xml文件中，如果需要操作任务或者修改任务运行频率，只能重新编译、打包、部署、重启，如果有紧急问题需要处理，会浪费很多的时间。
</code></pre> 
<pre><code>有没有可以动态调度任务的方法？比如停止一个Job？启动一个Job？修改Job的触发频率？
</code></pre> 
<pre><code>读取配置文件、写入配置文件、重启Scheduler或重启应用明显是不可取的。
</code></pre> 
<pre><code>对于这种频繁变更并且需要实时生效的配置信息，我们可以放到哪里？
</code></pre> 
<pre><code>ZK、Redis、DB tables。
</code></pre> 
<pre><code>并且，我们可以提供一个界面，实现对数据表的轻松操作。
</code></pre> 
<h4><a id="_575"></a>配置管理</h4> 
<p>这里我们用最简单的数据库的实现。</p> 
<p>问题1：建一张什么样的表？参考JobDetail的属性。</p> 
<pre><code class="prism language-sql"><span class="token keyword">CREATE</span> <span class="token keyword">TABLE</span> <span class="token identifier"><span class="token punctuation">`</span>sys_job<span class="token punctuation">`</span></span> <span class="token punctuation">(</span>
<span class="token identifier"><span class="token punctuation">`</span>id<span class="token punctuation">`</span></span> <span class="token keyword">INT</span> <span class="token punctuation">(</span> <span class="token number">11</span> <span class="token punctuation">)</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span> <span class="token keyword">AUTO_INCREMENT</span> <span class="token keyword">COMMENT</span> <span class="token string">'ID'</span><span class="token punctuation">,</span>
<span class="token identifier"><span class="token punctuation">`</span>job_name<span class="token punctuation">`</span></span> <span class="token keyword">VARCHAR</span> <span class="token punctuation">(</span> <span class="token number">512</span> <span class="token punctuation">)</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span> <span class="token keyword">COMMENT</span> <span class="token string">'任务名称'</span><span class="token punctuation">,</span>
<span class="token identifier"><span class="token punctuation">`</span>job_group<span class="token punctuation">`</span></span> <span class="token keyword">VARCHAR</span> <span class="token punctuation">(</span> <span class="token number">512</span> <span class="token punctuation">)</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span> <span class="token keyword">COMMENT</span> <span class="token string">'任务组名'</span><span class="token punctuation">,</span>
<span class="token identifier"><span class="token punctuation">`</span>job_cron<span class="token punctuation">`</span></span> <span class="token keyword">VARCHAR</span> <span class="token punctuation">(</span> <span class="token number">512</span> <span class="token punctuation">)</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span> <span class="token keyword">COMMENT</span> <span class="token string">'时间表达式'</span><span class="token punctuation">,</span>
<span class="token identifier"><span class="token punctuation">`</span>job_class_path<span class="token punctuation">`</span></span> <span class="token keyword">VARCHAR</span> <span class="token punctuation">(</span> <span class="token number">1024</span> <span class="token punctuation">)</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span> <span class="token keyword">COMMENT</span> <span class="token string">'类路径,全类型'</span><span class="token punctuation">,</span>
<span class="token identifier"><span class="token punctuation">`</span>job_data_map<span class="token punctuation">`</span></span> <span class="token keyword">VARCHAR</span> <span class="token punctuation">(</span> <span class="token number">1024</span> <span class="token punctuation">)</span> <span class="token keyword">DEFAULT</span> <span class="token boolean">NULL</span> <span class="token keyword">COMMENT</span> <span class="token string">'传递map参数'</span><span class="token punctuation">,</span>
<span class="token identifier"><span class="token punctuation">`</span>job_status<span class="token punctuation">`</span></span> <span class="token keyword">INT</span> <span class="token punctuation">(</span> <span class="token number">2</span> <span class="token punctuation">)</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span> <span class="token keyword">COMMENT</span> <span class="token string">'状态:1启用 0停用'</span><span class="token punctuation">,</span>
<span class="token identifier"><span class="token punctuation">`</span>job_describe<span class="token punctuation">`</span></span> <span class="token keyword">VARCHAR</span> <span class="token punctuation">(</span> <span class="token number">1024</span> <span class="token punctuation">)</span> <span class="token keyword">DEFAULT</span> <span class="token boolean">NULL</span> <span class="token keyword">COMMENT</span> <span class="token string">'任务功能描述'</span><span class="token punctuation">,</span>
<span class="token keyword">PRIMARY</span> <span class="token keyword">KEY</span> <span class="token punctuation">(</span> <span class="token identifier"><span class="token punctuation">`</span>id<span class="token punctuation">`</span></span> <span class="token punctuation">)</span> 
<span class="token punctuation">)</span> <span class="token keyword">ENGINE</span> <span class="token operator">=</span> <span class="token keyword">INNODB</span> <span class="token keyword">AUTO_INCREMENT</span> <span class="token operator">=</span> <span class="token number">25</span> <span class="token keyword">DEFAULT</span> <span class="token keyword">CHARSET</span> <span class="token operator">=</span> utf8<span class="token punctuation">;</span>
</code></pre> 
<h4><a id="_595"></a>数据操作与任务调度</h4> 
<pre><code>操作数据表非常简单，SSM增删改查。
</code></pre> 
<pre><code>但是在修改了表的数据之后，怎么让调度器知道呢？
</code></pre> 
<pre><code>	 调度器的接口：Scheduler

	 在我们的需求中，我们需要做的事情：
</code></pre> 
<pre><code>1、 新增一个任务
</code></pre> 
<pre><code>2、 删除一个任务
</code></pre> 
<pre><code>3、 启动、停止一个任务
</code></pre> 
<pre><code>4、 修改任务的信息（包括调度规律）
</code></pre> 
<p>因此可以把相关的操作封装到一个工具类中。com.msb.demo.util.SchedulerUtil</p> 
<h4><a id="_629"></a><strong>前端界面</strong></h4> 
<p><img src="https://images2.imgbox.com/62/87/js4LU6OA_o.png" alt="在这里插入图片描述"></p> 
<p>接下来我们有两个问题要解决：</p> 
<h4><a id="Service_636"></a>容器启动与Service注入</h4> 
<p><strong>容器启动</strong></p> 
<pre><code>因为任务没有定义在ApplicationContext.xml中，而是放到了数据库中，Spring Boot启动时，怎么读取任务信息？
</code></pre> 
<pre><code>或者，怎么在Spring启动完成的时候做一些事情？
</code></pre> 
<pre><code>创建一个类，实现CommandLineRunner接口，实现run方法。
</code></pre> 
<pre><code>从表中查出状态是1的任务，然后构建。
</code></pre> 
<p><strong>Service类注入到Job中</strong></p> 
<pre><code>Spring Bean如何注入到实现了Job接口的类中？
</code></pre> 
<pre><code>例如在TestTask3中，需要注入ISysJobService，查询数据库发送邮件。
</code></pre> 
<pre><code>如果没有任何配置，注入会报空指针异常。
</code></pre> 
<p><strong>原因：</strong></p> 
<pre><code>因为定时任务Job对象的实例化过程是在Quartz中进行的，而Service Bean是由Spring容器管理的，Quartz察觉不到Service Bean的存在，所以无法将Service Bean装配到Job对象中。
</code></pre> 
<pre><code>
</code></pre> 
<p><strong>分析：</strong></p> 
<pre><code>Quartz集成到Spring中，用到SchedulerFactoryBean，其实现了InitializingBean方法，在唯一的方法afterPropertiesSet()在Bean的属性初始化后调用。
</code></pre> 
<pre><code>调度器用AdaptableJobFactory对Job对象进行实例化。所以，如果我们可以把这个JobFactory指定为我们自定义的工厂的话，就可以在Job实例化完成之后，把Job纳入到Spring容器中管理。
</code></pre> 
<p><strong>解决这个问题的步骤：</strong></p> 
<pre><code>1、定义一个AdaptableJobFactory，实现JobFactory接口，实现接口定义的newJob方法，在这里面返回Job实例
</code></pre> 
<p><img src="https://images2.imgbox.com/cc/b0/WqUilT0v_o.png" alt="在这里插入图片描述"></p> 
<pre><code>2、定义一个MyJobFactory，继承AdaptableJobFactory。
</code></pre> 
<p>使用Spring的AutowireCapableBeanFactory，把Job实例注入到容器中。</p> 
<pre><code class="prism language-java"><span class="token annotation punctuation">@Component</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">MyJobFactory</span> <span class="token keyword">extends</span> <span class="token class-name">AdaptableJobFactory</span> <span class="token punctuation">{<!-- --></span>
  <span class="token annotation punctuation">@Autowired</span>
  <span class="token keyword">private</span> <span class="token class-name">AutowireCapableBeanFactory</span> capableBeanFactory<span class="token punctuation">;</span>

  <span class="token keyword">protected</span> <span class="token class-name">Object</span> <span class="token function">createJobInstance</span><span class="token punctuation">(</span><span class="token class-name">TriggerFiredBundle</span> bundle<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">Exception</span> <span class="token punctuation">{<!-- --></span>
    <span class="token class-name">Object</span> jobInstance <span class="token operator">=</span> <span class="token keyword">super</span><span class="token punctuation">.</span><span class="token function">createJobInstance</span><span class="token punctuation">(</span>bundle<span class="token punctuation">)</span><span class="token punctuation">;</span>
    capableBeanFactory<span class="token punctuation">.</span><span class="token function">autowireBean</span><span class="token punctuation">(</span>jobInstance<span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token keyword">return</span> jobInstance<span class="token punctuation">;</span>
 <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> 
<pre><code>3、指定Scheduler的JobFactory为自定义的JobFactory。
</code></pre> 
<pre><code>com.msb.demo.config.InitStartSchedule中：
</code></pre> 
<pre><code class="prism language-java">scheduler<span class="token punctuation">.</span><span class="token function">setJobFactory</span><span class="token punctuation">(</span>myJobFactory<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> 
<p>考虑这么一种情况：</p> 
<p>正在运行的Quartz节点挂了，而所有人完全不知情……</p> 
<h3><a id="6Quartz_736"></a>6.Quartz集群部署</h3> 
<pre><code>springboot-quartz工程
</code></pre> 
<h4><a id="_742"></a>为什么需要集群?</h4> 
<p>1、防止单点故障，减少对业务的影响</p> 
<p>2、减少节点的压力，例如在10点要触发1000个任务，如果有10个节点，则每个节点之需要执行100个任务</p> 
<h4><a id="_748"></a>集群需要解决的问题？</h4> 
<pre><code>1、任务重跑，因为节点部署的内容是一样的，到10点的时候，每个节点都会执行相同的操作，引起数据混乱。比如跑批，绝对不能执行多次。
</code></pre> 
<pre><code>2、任务漏跑，假如任务是平均分配的，本来应该在某个节点上执行的任务，因为节点故障，一直没有得到执行。
</code></pre> 
<pre><code>3、水平集群需要注意时间同步问题
</code></pre> 
<pre><code>4、Quartz使用的是随机的负载均衡算法，不能指定节点执行
</code></pre> 
<pre><code>所以必须要有一种共享数据或者通信的机制。在分布式系统的不同节点中，我们可以采用什么样的方式，实现数据共享？
</code></pre> 
<pre><code>两两通信，或者基于分布式的服务，实现数据共享。
</code></pre> 
<pre><code>例如：ZK、Redis、DB。
</code></pre> 
<pre><code>在Quartz中，提供了一种简单的方式，基于数据库共享任务执行信息。也就是说，一个节点执行任务的时候，会操作数据库，其他的节点查询数据库，便可以感知到了。
</code></pre> 
<pre><code>同样的问题：建什么表？哪些字段？依旧使用系统自带的11张表。
</code></pre> 
<h4><a id="_786"></a>集群配置与验证</h4> 
<pre><code>quartz.properties配置。
</code></pre> 
<pre><code>四个配置：集群实例ID、集群开关、数据库持久化、数据源信息
</code></pre> 
<pre><code>注意先清空quartz所有表、改端口、两个任务频率改成一样
</code></pre> 
<pre><code>验证1：先后启动2个节点，任务是否重跑
</code></pre> 
<pre><code>验证2：停掉一个节点，任务是否漏跑
</code></pre> 
<h3><a id="7Quartz_808"></a>7.Quartz调度原理</h3> 
<p>问题：</p> 
<p>1、Job没有继承Thread和实现Runnable，是怎么被调用的？通过反射还是什么？</p> 
<p>2、任务是什么时候被调度的？是谁在监视任务还是监视Trigger？</p> 
<p>3、任务是怎么被调用的？谁执行了任务？</p> 
<p>4、任务本身有状态吗？还是触发器有状态？</p> 
<p>看源码的入口</p> 
<pre><code class="prism language-java"><span class="token class-name">Scheduler</span> scheduler <span class="token operator">=</span> factory<span class="token punctuation">.</span><span class="token function">getScheduler</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
scheduler<span class="token punctuation">.</span><span class="token function">scheduleJob</span><span class="token punctuation">(</span>jobDetail<span class="token punctuation">,</span> trigger<span class="token punctuation">)</span><span class="token punctuation">;</span>
scheduler<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> 
<h4><a id="_828"></a>获取调度器实例</h4> 
<h5><a id="_830"></a><strong>读取配置文件</strong></h5> 
<pre><code class="prism language-java"><span class="token keyword">public</span> <span class="token class-name">Scheduler</span> <span class="token function">getScheduler</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">SchedulerException</span> <span class="token punctuation">{<!-- --></span>
 <span class="token keyword">if</span> <span class="token punctuation">(</span>cfg <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
   <span class="token comment">// 读取quartz.properties配置文件</span>
   <span class="token function">initialize</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
 <span class="token comment">// 这个类是一个HashMap，用来基于调度器的名称保证调度器的唯一性</span>
 <span class="token class-name">SchedulerRepository</span> schedRep <span class="token operator">=</span> <span class="token class-name">SchedulerRepository</span><span class="token punctuation">.</span><span class="token function">getInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

 <span class="token class-name">Scheduler</span> sched <span class="token operator">=</span> schedRep<span class="token punctuation">.</span><span class="token function">lookup</span><span class="token punctuation">(</span><span class="token function">getSchedulerName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
 <span class="token comment">// 如果调度器已经存在了</span>
 <span class="token keyword">if</span> <span class="token punctuation">(</span>sched <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
   <span class="token comment">// 调度器关闭了，移除</span>
   <span class="token keyword">if</span> <span class="token punctuation">(</span>sched<span class="token punctuation">.</span><span class="token function">isShutdown</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
     schedRep<span class="token punctuation">.</span><span class="token function">remove</span><span class="token punctuation">(</span><span class="token function">getSchedulerName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{<!-- --></span>
     <span class="token comment">// 返回调度器</span>
     <span class="token keyword">return</span> sched<span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

 <span class="token comment">// 调度器不存在，初始化</span>
 sched <span class="token operator">=</span> <span class="token function">instantiate</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

 <span class="token keyword">return</span> sched<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>instantiate()方法中做了初始化的所有工作：</p> 
<pre><code class="prism language-java"><span class="token comment">// 存储任务信息的JobStore</span>
<span class="token class-name">JobStore</span> js <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
<span class="token comment">// 创建线程池，默认是SimpleThreadPool</span>
<span class="token class-name">ThreadPool</span> tp <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
<span class="token comment">// 创建调度器</span>
<span class="token class-name">QuartzScheduler</span> qs <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
<span class="token comment">// 连接数据库的连接管理器</span>
<span class="token class-name">DBConnectionManager</span> dbMgr <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
<span class="token comment">// 自动生成ID</span>
<span class="token comment">// 创建线程执行器，默认为DefaultThreadExecutor</span>
<span class="token class-name">ThreadExecutor</span> threadExecutor<span class="token punctuation">;</span>
</code></pre> 
<h5><a id="_876"></a><strong>创建线程池（包工头）</strong></h5> 
<p>830行和839行，创建了一个线程池，默认是配置文件中指定的SimpleThreadPool。</p> 
<pre><code class="prism language-java"><span class="token class-name">String</span> tpClass <span class="token operator">=</span> cfg<span class="token punctuation">.</span><span class="token function">getStringProperty</span><span class="token punctuation">(</span><span class="token constant">PROP_THREAD_POOL_CLASS</span><span class="token punctuation">,</span> <span class="token class-name">SimpleThreadPool</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
tp <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name">ThreadPool</span><span class="token punctuation">)</span> loadHelper<span class="token punctuation">.</span><span class="token function">loadClass</span><span class="token punctuation">(</span>tpClass<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">newInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> 
<p>SimpleThreadPool里面维护了三个list，分别存放所有的工作线程、空闲的工作线程和忙碌的工作线程。我们可以把SimpleThreadPool理解为包工头。</p> 
<pre><code class="prism language-java"><span class="token keyword">private</span> <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">WorkerThread</span><span class="token punctuation">&gt;</span></span> workers<span class="token punctuation">;</span>
<span class="token keyword">private</span> <span class="token class-name">LinkedList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">WorkerThread</span><span class="token punctuation">&gt;</span></span> availWorkers <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">LinkedList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">WorkerThread</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">private</span> <span class="token class-name">LinkedList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">WorkerThread</span><span class="token punctuation">&gt;</span></span> busyWorkers <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">LinkedList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">WorkerThread</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

</code></pre> 
<p>tp的runInThread()方法是线程池运行线程的接口方法。参数Runnable是执行的任务内容。</p> 
<p>取出WorkerThread去执行参数里面的runnable（JobRunShell）。</p> 
<pre><code class="prism language-java"><span class="token class-name">WorkerThread</span> wt <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name">WorkerThread</span><span class="token punctuation">)</span>availWorkers<span class="token punctuation">.</span><span class="token function">removeFirst</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
busyWorkers<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>wt<span class="token punctuation">)</span><span class="token punctuation">;</span>
wt<span class="token punctuation">.</span><span class="token function">run</span><span class="token punctuation">(</span>runnable<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> 
<h5><a id="WorkerThread_904"></a><strong>WorkerThread（工人）</strong></h5> 
<pre><code>WorkerThread是SimpleThreadPool的内部类，用来执行任务。我们把WorkerThread理解为工人。在WorkerThread的run方法中，执行传入的参数runnable任务：
</code></pre> 
<pre><code class="prism language-java">runnable<span class="token punctuation">.</span><span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> 
<h5><a id="_914"></a><strong>创建调度线程（项目经理）</strong></h5> 
<p>1321行，创建了调度器QuartzScheduler：</p> 
<pre><code class="prism language-java">qs <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">QuartzScheduler</span><span class="token punctuation">(</span>rsrcs<span class="token punctuation">,</span> idleWaitTime<span class="token punctuation">,</span> dbFailureRetry<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> 
<pre><code>在 QuartzScheduler的构造函数中，创建了QuartzSchedulerThread，我们把它理解为项目经理，它会调用包工头的工人资源，给他们安排任务。
</code></pre> 
<pre><code>并且创建了线程执行器schedThreadExecutor，执行了这个QuartzSchedulerThread，也就是调用了它的run方法。
</code></pre> 
<pre><code class="prism language-java"><span class="token comment">// 创建一个线程，resouces里面有线程名称</span>
<span class="token keyword">this</span><span class="token punctuation">.</span>schedThread <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">QuartzSchedulerThread</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> resources<span class="token punctuation">)</span><span class="token punctuation">;</span> 
<span class="token comment">// 线程执行器</span>
<span class="token class-name">ThreadExecutor</span> schedThreadExecutor <span class="token operator">=</span> resources<span class="token punctuation">.</span><span class="token function">getThreadExecutor</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> 
<span class="token comment">//执行这个线程，也就是调用了线程的run方法</span>
schedThreadExecutor<span class="token punctuation">.</span><span class="token function">execute</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>schedThread<span class="token punctuation">)</span><span class="token punctuation">;</span>  

点开 <span class="token class-name">QuartzSchedulerThread</span> 类，找到run方法，这个是<span class="token class-name">Quartz</span>任务调度的核心方法：

  <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    <span class="token keyword">int</span> acquiresFailed <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
   <span class="token comment">// 检查scheuler是否为停止状态</span>
    <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">!</span>halted<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
      <span class="token keyword">try</span> <span class="token punctuation">{<!-- --></span>
        <span class="token comment">// check if we're supposed to pause...</span>
        <span class="token keyword">synchronized</span> <span class="token punctuation">(</span>sigLock<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
          <span class="token comment">// 检查是否为暂停状态</span>
          <span class="token keyword">while</span> <span class="token punctuation">(</span>paused <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span>halted<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
            <span class="token keyword">try</span> <span class="token punctuation">{<!-- --></span>
              <span class="token comment">// wait until togglePause(false) is called...</span>
              <span class="token comment">// 暂停的话会尝试去获得信号锁，并wait一会</span>
              sigLock<span class="token punctuation">.</span><span class="token function">wait</span><span class="token punctuation">(</span><span class="token number">1000L</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
           <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> ignore<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
           <span class="token punctuation">}</span>

            <span class="token comment">// reset failure counter when paused, so that we don't</span>
            <span class="token comment">// wait again after unpausing</span>
            acquiresFailed <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
         <span class="token punctuation">}</span>

          <span class="token keyword">if</span> <span class="token punctuation">(</span>halted<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
            <span class="token keyword">break</span><span class="token punctuation">;</span>
         <span class="token punctuation">}</span>
       <span class="token punctuation">}</span>

        <span class="token comment">// wait a bit, if reading from job store is consistently</span>
        <span class="token comment">// failing (e.g. DB is down or restarting)..</span>
        <span class="token comment">// 从JobStore获取Job持续失败，sleep一下</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>acquiresFailed <span class="token operator">&gt;</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
          <span class="token keyword">try</span> <span class="token punctuation">{<!-- --></span>
            <span class="token keyword">long</span> delay <span class="token operator">=</span> <span class="token function">computeDelayForRepeatedErrors</span><span class="token punctuation">(</span>qsRsrcs<span class="token punctuation">.</span><span class="token function">getJobStore</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> acquiresFailed<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span>delay<span class="token punctuation">)</span><span class="token punctuation">;</span>
         <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Exception</span> ignore<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
         <span class="token punctuation">}</span>
       <span class="token punctuation">}</span>
        <span class="token comment">// 从线程池获取可用的线程</span>
        <span class="token keyword">int</span> availThreadCount <span class="token operator">=</span> qsRsrcs<span class="token punctuation">.</span><span class="token function">getThreadPool</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">blockForAvailableThreads</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">if</span><span class="token punctuation">(</span>availThreadCount <span class="token operator">&gt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span> <span class="token comment">// will always be true, due to semantics of blockForAvailableThreads...</span>

          <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">OperableTrigger</span><span class="token punctuation">&gt;</span></span> triggers<span class="token punctuation">;</span>

          <span class="token keyword">long</span> now <span class="token operator">=</span> <span class="token class-name">System</span><span class="token punctuation">.</span><span class="token function">currentTimeMillis</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

          <span class="token function">clearSignaledSchedulingChange</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
          <span class="token keyword">try</span> <span class="token punctuation">{<!-- --></span>
            <span class="token comment">// 获取需要下次执行的triggers</span>
            <span class="token comment">// idleWaitTime： 默认30s</span>
            <span class="token comment">// availThreadCount：获取可用（空闲）的工作线程数量，总会大于1，因为该方法会一直阻塞，直到有工作线程空闲下来。</span>
            <span class="token comment">// maxBatchSize：一次拉取trigger的最大数量，默认是1</span>
            <span class="token comment">// batchTimeWindow：时间窗口调节参数，默认是0</span>
            <span class="token comment">// misfireThreshold： 超过这个时间还未触发的trigger，被认为发生了misfire，默认60s</span>
            <span class="token comment">// 调度线程一次会拉取NEXT_FIRETIME小于（now + idleWaitTime +batchTimeWindow）,大于（now - misfireThreshold）的，min(availThreadCount,maxBatchSize)个triggers，默认情况下，会拉取未来30s、过去60s之间还未fire的1个trigger</span>
            triggers <span class="token operator">=</span> qsRsrcs<span class="token punctuation">.</span><span class="token function">getJobStore</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">acquireNextTriggers</span><span class="token punctuation">(</span>
                now <span class="token operator">+</span> idleWaitTime<span class="token punctuation">,</span> <span class="token class-name">Math</span><span class="token punctuation">.</span><span class="token function">min</span><span class="token punctuation">(</span>availThreadCount<span class="token punctuation">,</span> qsRsrcs<span class="token punctuation">.</span><span class="token function">getMaxBatchSize</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">,</span> qsRsrcs<span class="token punctuation">.</span><span class="token function">getBatchTimeWindow</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token comment">// 省略…………</span>

            <span class="token comment">// set triggers to 'executing'</span>
            <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">TriggerFiredResult</span><span class="token punctuation">&gt;</span></span> bndles <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">TriggerFiredResult</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

            <span class="token keyword">boolean</span> goAhead <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
            <span class="token keyword">synchronized</span><span class="token punctuation">(</span>sigLock<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
              goAhead <span class="token operator">=</span> <span class="token operator">!</span>halted<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
           <span class="token punctuation">}</span>
            <span class="token keyword">if</span><span class="token punctuation">(</span>goAhead<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
              <span class="token keyword">try</span> <span class="token punctuation">{<!-- --></span>
                <span class="token comment">// 触发Trigger，把ACQUIRED状态改成EXECUTING</span>
                <span class="token comment">// 如果这个trigger的NEXTFIRETIME为空，也就是未来不再触发，就将其状态改为COMPLETE</span>
                <span class="token comment">// 如果trigger不允许并发执行（即Job的实现类标注了@DisallowConcurrentExecution），则将状态变为BLOCKED，否则就将状态改为WAITING</span>
                <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">TriggerFiredResult</span><span class="token punctuation">&gt;</span></span> res <span class="token operator">=</span> qsRsrcs<span class="token punctuation">.</span><span class="token function">getJobStore</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">triggersFired</span><span class="token punctuation">(</span>triggers<span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token comment">// 省略…………</span>
                <span class="token keyword">continue</span><span class="token punctuation">;</span>
             <span class="token punctuation">}</span>

           <span class="token punctuation">}</span>
  
            <span class="token comment">// 循环处理Trigger</span>
            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> bndles<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
              <span class="token class-name">TriggerFiredResult</span> result <span class="token operator">=</span> bndles<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>
              <span class="token class-name">TriggerFiredBundle</span> bndle <span class="token operator">=</span> result<span class="token punctuation">.</span><span class="token function">getTriggerFiredBundle</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
              <span class="token class-name">Exception</span> exception <span class="token operator">=</span> result<span class="token punctuation">.</span><span class="token function">getException</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

              <span class="token comment">// 省略…………</span>

              <span class="token class-name">JobRunShell</span> shell <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
              <span class="token keyword">try</span> <span class="token punctuation">{<!-- --></span>
                <span class="token comment">// 根据trigger信息实例化JobRunShell（implements Runnable），同时依据JOB_CLASS_NAME实例化Job，随后我们将JobRunShell实例丢入工作线。</span>
                shell <span class="token operator">=</span> qsRsrcs<span class="token punctuation">.</span><span class="token function">getJobRunShellFactory</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">createJobRunShell</span><span class="token punctuation">(</span>bndle<span class="token punctuation">)</span><span class="token punctuation">;</span>
                shell<span class="token punctuation">.</span><span class="token function">initialize</span><span class="token punctuation">(</span>qs<span class="token punctuation">)</span><span class="token punctuation">;</span>
             <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">SchedulerException</span> se<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
                qsRsrcs<span class="token punctuation">.</span><span class="token function">getJobStore</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">triggeredJobComplete</span><span class="token punctuation">(</span>triggers<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">,</span> bndle<span class="token punctuation">.</span><span class="token function">getJobDetail</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token class-name">CompletedExecutionInstruction</span><span class="token punctuation">.</span><span class="token constant">SET_ALL_JOB_TRIGGERS_ERROR</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token keyword">continue</span><span class="token punctuation">;</span>
             <span class="token punctuation">}</span>
              <span class="token comment">// 执行JobRunShell的run方法</span>
              <span class="token keyword">if</span> <span class="token punctuation">(</span>qsRsrcs<span class="token punctuation">.</span><span class="token function">getThreadPool</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">runInThread</span><span class="token punctuation">(</span>shell<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token boolean">false</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
                <span class="token comment">// 省略…………</span>
</code></pre> 
<h5><a id="JobRunShell_1038"></a><strong>JobRunShell的作用</strong></h5> 
<p>JobRunShell instances are responsible for providing the ‘safe’ environment for Job s to run in, and for performing all of the work of executing the Job, catching ANY thrown exceptions, updating the Trigger with the Job’s completion code, etc.<br> A JobRunShell instance is created by a JobRunShellFactory on behalf of the QuartzSchedulerThread which then runs the shell in a thread from the configured ThreadPool when the scheduler determines that a Job has been triggered.</p> 
<p>JobRunShell用来为Job提供安全的运行环境的，执行Job中所有的作业，捕获运行中的异常，在任务执行完毕的时候更新Trigger状态，等等。</p> 
<p>JobRunShell实例是用JobRunShellFactory为QuartzSchedulerThread创建的，在调度器决定一个Job被触发的时候，它从线程池中取出一个线程来执行任务。</p> 
<h5><a id="_1047"></a><strong>线程模型总结</strong></h5> 
<p>**SimpleThreadPool：**包工头，管理所有WorkerThread</p> 
<p>**WorkerThread：**工人，把Job包装成JobRunShell，执行</p> 
<p>**QuartSchedulerThread：**项目经理，获取即将触发的Trigger，从包工头出拿到worker，执行Trigger绑定的任务</p> 
<h4><a id="JobDetailTrigger_1055"></a>绑定JobDetail和Trigger</h4> 
<pre><code class="prism language-java"><span class="token comment">// 存储JobDetail和Trigger</span>
resources<span class="token punctuation">.</span><span class="token function">getJobStore</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">storeJobAndTrigger</span><span class="token punctuation">(</span>jobDetail<span class="token punctuation">,</span> trig<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// 通知相关的Listener</span>
<span class="token function">notifySchedulerListenersJobAdded</span><span class="token punctuation">(</span>jobDetail<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">notifySchedulerThread</span><span class="token punctuation">(</span>trigger<span class="token punctuation">.</span><span class="token function">getNextFireTime</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getTime</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> 
<span class="token function">notifySchedulerListenersSchduled</span><span class="token punctuation">(</span>trigger<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> 
<h4><a id="_1066"></a>启动调度器</h4> 
<pre><code class="prism language-java"><span class="token comment">// 通知监听器</span>
<span class="token function">notifySchedulerListenersStarting</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">if</span> <span class="token punctuation">(</span>initialStart <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
  initialStart <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Date</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span>resources<span class="token punctuation">.</span><span class="token function">getJobStore</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">schedulerStarted</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   
  <span class="token function">startPlugins</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{<!-- --></span>
  resources<span class="token punctuation">.</span><span class="token function">getJobStore</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">schedulerResumed</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token comment">// 通知QuartzSchedulerThread不再等待，开始干活</span>
schedThread<span class="token punctuation">.</span><span class="token function">togglePause</span><span class="token punctuation">(</span><span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// 通知监听器</span>
<span class="token function">notifySchedulerListenersStarted</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> 
<h4><a id="_1084"></a><strong>源码总结</strong></h4> 
<pre><code>getScheduler方法创建线程池ThreadPool，创建调度器QuartzScheduler，创建调度线程QuartzSchedulerThread，调度线程初始处于暂停状态。
</code></pre> 
<pre><code>scheduleJob将任务添加到JobStore中。
</code></pre> 
<pre><code>scheduler.start()方法激活调度器，QuartzSchedulerThread从timeTrriger取出待触发的任务，并包装成TriggerFiredBundle，然后由	JobRunShellFactory 创建TriggerFiredBundle的执行线程JobRunShell， 调度执行通过线程池SimpleThreadPool去执行JobRunShell，	而JobRunShell执行的就是任务类的execute方法：job.execute(JobExecutionContext context)。
</code></pre> 
<h4><a id="_1098"></a>集群原理</h4> 
<pre><code>基于数据库，如何实现任务的不重跑不漏跑？
</code></pre> 
<pre><code>问题1：如果任务执行中的资源是“下一个即将触发的任务”，怎么基于数据库实现这个资源的竞争？
</code></pre> 
<pre><code>问题2：怎么对数据的行加锁？
</code></pre> 
<p><img src="https://images2.imgbox.com/96/2c/VCnzWkjh_o.png" alt="在这里插入图片描述"></p> 
<pre><code>QuartzSchedulerThread第287行，获取下一个即将触发的Trigger
</code></pre> 
<pre><code class="prism language-java">triggers <span class="token operator">=</span> qsRsrcs<span class="token punctuation">.</span><span class="token function">getJobStore</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">acquireNextTriggers</span><span class="token punctuation">(</span>
</code></pre> 
<pre><code>调用 JobStoreSupport的acquireNextTriggers()方法，2793行
</code></pre> 
<pre><code>调用JobStoreSupport.executeInNonManagedTXLock()方法，3829行：
</code></pre> 
<pre><code class="prism language-java"><span class="token keyword">return</span> <span class="token function">executeInNonManagedTXLock</span><span class="token punctuation">(</span>lockName<span class="token punctuation">,</span> 
</code></pre> 
<pre><code>尝试获取锁，3843行：
</code></pre> 
<pre><code>transOwner = getLockHandler().obtainLock(conn, lockName);
</code></pre> 
<p>下面有回滚和释放锁的语句，即使发生异常，锁同样能释放。</p> 
<p>调用DBSemaphore的obtainLock()方法，103行</p> 
<pre><code class="prism language-java">  <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">obtainLock</span><span class="token punctuation">(</span><span class="token class-name">Connection</span> conn<span class="token punctuation">,</span> <span class="token class-name">String</span> lockName<span class="token punctuation">)</span>
    <span class="token keyword">throws</span> <span class="token class-name">LockException</span> <span class="token punctuation">{<!-- --></span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">isLockOwner</span><span class="token punctuation">(</span>lockName<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
      <span class="token function">executeSQL</span><span class="token punctuation">(</span>conn<span class="token punctuation">,</span> lockName<span class="token punctuation">,</span> expandedSQL<span class="token punctuation">,</span> expandedInsertSQL<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> 
<p>调用StdRowLockSemaphore的executeSQL()方法，78行。</p> 
<p>最终用JDBC执行SQL，语句内容是expandedSQL和expandedInsertSQL。</p> 
<pre><code class="prism language-java">ps <span class="token operator">=</span> conn<span class="token punctuation">.</span><span class="token function">prepareStatement</span><span class="token punctuation">(</span>expandedSQL<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> 
<p>问题：expandedSQL和expandedInsertSQL是一条什么SQL语句？似乎我们没有赋值？</p> 
<p>在StdRowLockSemaphore的构造函数中，把定义的两条SQL传进去：</p> 
<pre><code class="prism language-java"><span class="token keyword">public</span> <span class="token class-name">StdRowLockSemaphore</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
 <span class="token keyword">super</span><span class="token punctuation">(</span><span class="token constant">DEFAULT_TABLE_PREFIX</span><span class="token punctuation">,</span> <span class="token keyword">null</span><span class="token punctuation">,</span> <span class="token constant">SELECT_FOR_LOCK</span><span class="token punctuation">,</span> <span class="token constant">INSERT_LOCK</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<pre><code class="prism language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token class-name">String</span> <span class="token constant">SELECT_FOR_LOCK</span> <span class="token operator">=</span> <span class="token string">"SELECT * FROM "</span>
     <span class="token operator">+</span> <span class="token constant">TABLE_PREFIX_SUBST</span> <span class="token operator">+</span> <span class="token constant">TABLE_LOCKS</span> <span class="token operator">+</span> <span class="token string">" WHERE "</span> <span class="token operator">+</span> <span class="token constant">COL_SCHEDULER_NAME</span> <span class="token operator">+</span> <span class="token string">" = "</span> <span class="token operator">+</span> <span class="token constant">SCHED_NAME_SUBST</span>
     <span class="token operator">+</span> <span class="token string">" AND "</span> <span class="token operator">+</span> <span class="token constant">COL_LOCK_NAME</span> <span class="token operator">+</span> <span class="token string">" = ? FOR UPDATE"</span><span class="token punctuation">;</span>

 <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token class-name">String</span> <span class="token constant">INSERT_LOCK</span> <span class="token operator">=</span> <span class="token string">"INSERT INTO "</span>
   <span class="token operator">+</span> <span class="token constant">TABLE_PREFIX_SUBST</span> <span class="token operator">+</span> <span class="token constant">TABLE_LOCKS</span> <span class="token operator">+</span> <span class="token string">"("</span> <span class="token operator">+</span> <span class="token constant">COL_SCHEDULER_NAME</span> <span class="token operator">+</span> <span class="token string">", "</span> <span class="token operator">+</span> <span class="token constant">COL_LOCK_NAME</span> <span class="token operator">+</span> <span class="token string">") VALUES ("</span> 
   <span class="token operator">+</span> <span class="token constant">SCHED_NAME_SUBST</span> <span class="token operator">+</span> <span class="token string">", ?)"</span><span class="token punctuation">;</span> 
</code></pre> 
<p>它调用了父类DBSemaphore的构造函数：</p> 
<pre><code class="prism language-java"><span class="token keyword">public</span> <span class="token class-name">DBSemaphore</span><span class="token punctuation">(</span><span class="token class-name">String</span> tablePrefix<span class="token punctuation">,</span> <span class="token class-name">String</span> schedName<span class="token punctuation">,</span> <span class="token class-name">String</span> defaultSQL<span class="token punctuation">,</span> <span class="token class-name">String</span> defaultInsertSQL<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
   <span class="token keyword">this</span><span class="token punctuation">.</span>tablePrefix <span class="token operator">=</span> tablePrefix<span class="token punctuation">;</span>
   <span class="token keyword">this</span><span class="token punctuation">.</span>schedName <span class="token operator">=</span> schedName<span class="token punctuation">;</span>
   <span class="token function">setSQL</span><span class="token punctuation">(</span>defaultSQL<span class="token punctuation">)</span><span class="token punctuation">;</span>
   <span class="token function">setInsertSQL</span><span class="token punctuation">(</span>defaultInsertSQL<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>在setSQL()和setInsertSQL()中为expandedSQL和 expandedInsertSQL赋值。</p> 
<p>执行的SQL语句：</p> 
<pre><code class="prism language-java">select <span class="token operator">*</span> from <span class="token constant">QRTZ_LOCKS</span> t where t<span class="token punctuation">.</span>lock_name<span class="token operator">=</span>'<span class="token constant">TRIGGER_ACCESS</span>' <span class="token keyword">for</span> update
</code></pre> 
<p>在我们执行官方的建表脚本的时候，QRTZ_LOCKS表，它会为每个调度器创建两行数据，获取Trigger和触发Trigger是两把锁：</p> 
<p><img src="https://images2.imgbox.com/97/73/OA4o4Ldr_o.png" alt="在这里插入图片描述"></p> 
<h4><a id="_1211"></a>任务为什么重复执行</h4> 
<pre><code>在我们的演示过程中，有多个调度器，任务没有重复执行，也就是默认会加锁，什么情况下不会上锁呢？
</code></pre> 
<pre><code>JobStoreSupport的executeInNonManagedTXLock()方法
</code></pre> 
<pre><code>如果lockName为空，则不上锁
</code></pre> 
<pre><code class="prism language-java"><span class="token keyword">if</span> <span class="token punctuation">(</span>lockName <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
       <span class="token comment">// If we aren't using db locks, then delay getting DB connection </span>
        <span class="token comment">// until after acquiring the lock since it isn't needed.</span>
       <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">getLockHandler</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">requiresConnection</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
         conn <span class="token operator">=</span> <span class="token function">getNonManagedTXConnection</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
       <span class="token punctuation">}</span>
  
       transOwner <span class="token operator">=</span> <span class="token function">getLockHandler</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">obtainLock</span><span class="token punctuation">(</span>conn<span class="token punctuation">,</span> lockName<span class="token punctuation">)</span><span class="token punctuation">;</span>
     <span class="token punctuation">}</span>
  
     <span class="token keyword">if</span> <span class="token punctuation">(</span>conn <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
       conn <span class="token operator">=</span> <span class="token function">getNonManagedTXConnection</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
     <span class="token punctuation">}</span>
</code></pre> 
<pre><code>而上一步JobStoreSupport的acquireNextTriggers()方法，
</code></pre> 
<pre><code>1）如果acquireTriggersWithinLock=true或者batchTriggerAcquisitionMaxCount&gt;1时，locaName赋值为LOCK_TRIGGER_ACCESS，此时获取Trigger会加锁。
</code></pre> 
<pre><code>2）否则，如果isAcquireTriggersWithinLock()值是false并且maxCount=1的话，lockName赋值为null，这种情况获取Trigger下不加锁。
</code></pre> 
<pre><code class="prism language-java"><span class="token keyword">public</span> <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">OperableTrigger</span><span class="token punctuation">&gt;</span></span> <span class="token function">acquireNextTriggers</span><span class="token punctuation">(</span><span class="token keyword">final</span> <span class="token keyword">long</span> noLaterThan<span class="token punctuation">,</span> <span class="token keyword">final</span> <span class="token keyword">int</span> maxCount<span class="token punctuation">,</span> <span class="token keyword">final</span> <span class="token keyword">long</span> timeWindow<span class="token punctuation">)</span>
   <span class="token keyword">throws</span> <span class="token class-name">JobPersistenceException</span> <span class="token punctuation">{<!-- --></span>
  
   <span class="token class-name">String</span> lockName<span class="token punctuation">;</span>
   <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token function">isAcquireTriggersWithinLock</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">||</span> maxCount <span class="token operator">&gt;</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span> 
     lockName <span class="token operator">=</span> <span class="token constant">LOCK_TRIGGER_ACCESS</span><span class="token punctuation">;</span>
   <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{<!-- --></span>
     lockName <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<pre><code>acquireTriggersWithinLock变量默认是false：
</code></pre> 
<pre><code class="prism language-properties">private boolean acquireTriggersWithinLock = false;
</code></pre> 
<pre><code>maxCount来自QuartzSchedulerThread：
</code></pre> 
<pre><code class="prism language-java">triggers <span class="token operator">=</span> qsRsrcs<span class="token punctuation">.</span><span class="token function">getJobStore</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">acquireNextTriggers</span><span class="token punctuation">(</span>
               now <span class="token operator">+</span> idleWaitTime<span class="token punctuation">,</span> <span class="token class-name">Math</span><span class="token punctuation">.</span><span class="token function">min</span><span class="token punctuation">(</span>availThreadCount<span class="token punctuation">,</span> qsRsrcs<span class="token punctuation">.</span><span class="token function">getMaxBatchSize</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">,</span> qsRsrcs<span class="token punctuation">.</span><span class="token function">getBatchTimeWindow</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> 
<p>getMaxBatchSize()来自QuartzSchedulerResources，代表Scheduler一次拉取trigger的最大数量，默认是1：</p> 
<pre><code class="prism language-properties">private int maxBatchSize = 1;
</code></pre> 
<p>这个值可以通过参数修改，代表允许调度程序节点一次获取（用于触发）的触发器的最大数量，默认值是1。</p> 
<pre><code class="prism language-properties">org.quartz.scheduler.batchTriggerAcquisitionMaxCount=1
</code></pre> 
<p>根据以上两个默认值，理论上在获取Trigger的时候不会上锁，但是实际上为什么没有出现频繁的重复执行问题？因为每个调度器的线程持有锁的时间太短了，单机的测试无法体现，而在高并发的情况下，有可能会出现这个问题。</p> 
<p>QuartzSchedulerThread的triggersFired()方法：</p> 
<pre><code class="prism language-java"><span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">TriggerFiredResult</span><span class="token punctuation">&gt;</span></span> res <span class="token operator">=</span> qsRsrcs<span class="token punctuation">.</span><span class="token function">getJobStore</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">triggersFired</span><span class="token punctuation">(</span>triggers<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> 
<pre><code>调用了JobStoreSupport的triggersFired()方法，接着又调用了一个triggerFired triggerFired(Connection conn, OperableTrigger trigger)方法：
</code></pre> 
<pre><code>如果Trigger的状态不是ACQUIRED，也就是说被其他的线程fire了，返回空。但是这种乐观锁的检查在高并发下难免会出现ABA的问题，比如线程A拿到的时候还是ACQUIRED状态，但是刚准备执行的时候已经变成了EXECUTING状态，这个时候就会出现重复执行的问题。
</code></pre> 
<pre><code class="prism language-java"><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>state<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span><span class="token constant">STATE_ACQUIRED</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
  <span class="token keyword">return</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>总结，如果：</p> 
<p>如果设置的数量为1（默认值），并且使用JDBC JobStore（RAMJobStore不支持分布式，只有一个调度器实例，所以不加锁），则属性org.quartz.jobStore.acquireTriggersWithinLock应设置为true。否则不加锁可能会导致任务重复执行。</p> 
<pre><code class="prism language-properties">org.quartz.scheduler.batchTriggerAcquisitionMaxCount=1
org.quartz.jobStore.acquireTriggersWithinLock=true
</code></pre>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/525673da9c5ce1c0266b21f19c52ca53/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">03Nginx的静态资源部署,反向代理,负载均衡,动静分离的配置</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/9cfe5db3a9a7899be77336f460fff24e/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">Vue3安装配置、开发环境搭建(组件安装卸载)（图文详细）</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>