<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>一.springboot与shiro整合(示例) - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="一.springboot与shiro整合(示例)" />
<meta property="og:description" content="地址： github地址：点击打开链接https://github.com/MeloFocus/focus
前端水平有限见谅
目标： (1)用springboot整合shiro
(2)完成简单的登录功能
(3)对url进行权限控制，当前登录用户拥有此url的权限码时，才可以访问此url
1.pom文件 可以先从此网站拉项目及所需要的依赖 http://start.spring.io/
目前需要的依赖
&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-thymeleaf&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis.spring.boot&lt;/groupId&gt; &lt;artifactId&gt;mybatis-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;1.3.1&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-devtools&lt;/artifactId&gt; &lt;scope&gt;runtime&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;scope&gt;runtime&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.shiro&lt;/groupId&gt; &lt;artifactId&gt;shiro-spring&lt;/artifactId&gt; &lt;version&gt;1.3.2&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt; 2.设计表，逆向生成 user:用户表 role:角色表 user_role_r:用户和角色关系表，多对多
role_business:业务角色表 resource:资源表
role_resource_r:角色资源关系表，多对多
authority:操作码表
resource_authority:资源和操作码关系表，多对多
最后逆向生成实体类，本博客另有一篇记录逆向生成
3.使用java配置，配置shiro ShiroFilterFactoryBean：是个拦截器，在请求进入控制层前将其拦截，需要将安全管理器SecurityManager注入其中
SecurityManager：安全管理器，需要将自定义realm注入其中，以后还可以将缓存、remeberme等注入其中
自定义reaml：认证授权会执行它，需要自己写
@Configuration public class ShiroConfig { /** * ShiroFilterFactoryBean 处理拦截资源文件问题。 * 注意：单独一个ShiroFilterFactoryBean配置是或报错的，因为在初始化ShiroFilterFactoryBean的时候需要注入：SecurityManager * Filter Chain定义说明 1、一个URL可以配置多个Filter，使用逗号分隔 2、当设置多个过滤器时，全部验证通过，才视为通过 * 3、部分过滤器可指定参数，如perms，roles */ @Bean public ShiroFilterFactoryBean shirFilter(SecurityManager securityManager) { ShiroFilterFactoryBean shiroFilterFactoryBean = new ShiroFilterFactoryBean(); // 必须设置 SecurityManager shiroFilterFactoryBean." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/71d716d8ae4e0cdea6c68d8d6ba9db7a/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2018-02-16T23:03:35+08:00" />
<meta property="article:modified_time" content="2018-02-16T23:03:35+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">一.springboot与shiro整合(示例)</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <h2>地址：</h2> 
<p>github地址：<a href="https://github.com/MeloFocus/focus">点击打开链接</a>https://github.com/MeloFocus/focus</p> 
<p>前端水平有限见谅</p> 
<p><img alt="" class="has" height="231" src="https://images2.imgbox.com/f4/13/AkIP4bMO_o.png" width="606"></p> 
<p><img alt="" class="has" height="232" src="https://images2.imgbox.com/ce/dd/BuOI8vC8_o.png" width="570"></p> 
<h2> </h2> 
<h2>目标：</h2> 
<p>(1)用springboot整合shiro</p> 
<p>(2)完成简单的登录功能</p> 
<p>(3)对url进行权限控制，当前登录用户拥有此url的权限码时，才可以访问此url</p> 
<h2>1.pom文件</h2> 
<p>可以先从此网站拉项目及所需要的依赖   http://start.spring.io/</p> 
<p><img alt="" class="has" src="https://images2.imgbox.com/fc/9c/zcW3dpPw_o.png"></p> 
<p>目前需要的依赖</p> 
<pre class="has"><code class="language-html">&lt;dependencies&gt;
		&lt;dependency&gt;
			&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
			&lt;artifactId&gt;spring-boot-starter-thymeleaf&lt;/artifactId&gt;
		&lt;/dependency&gt;
		&lt;dependency&gt;
			&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
			&lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;
		&lt;/dependency&gt;
		&lt;dependency&gt;
			&lt;groupId&gt;org.mybatis.spring.boot&lt;/groupId&gt;
			&lt;artifactId&gt;mybatis-spring-boot-starter&lt;/artifactId&gt;
			&lt;version&gt;1.3.1&lt;/version&gt;
		&lt;/dependency&gt;
		&lt;dependency&gt;
			&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
			&lt;artifactId&gt;spring-boot-devtools&lt;/artifactId&gt;
			&lt;scope&gt;runtime&lt;/scope&gt;
		&lt;/dependency&gt;
		&lt;dependency&gt;
			&lt;groupId&gt;mysql&lt;/groupId&gt;
			&lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;
			&lt;scope&gt;runtime&lt;/scope&gt;
		&lt;/dependency&gt;
		&lt;dependency&gt;
			&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
			&lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt;
			&lt;scope&gt;test&lt;/scope&gt;
		&lt;/dependency&gt;
		
		&lt;dependency&gt;
		    &lt;groupId&gt;org.apache.shiro&lt;/groupId&gt;
		    &lt;artifactId&gt;shiro-spring&lt;/artifactId&gt;
		    &lt;version&gt;1.3.2&lt;/version&gt;
		&lt;/dependency&gt;
	&lt;/dependencies&gt;</code></pre> 
<p> </p> 
<p> </p> 
<h2>2.设计表，逆向生成</h2> 
<p><img alt="" class="has" src="https://images2.imgbox.com/3c/e8/uKQ0hARO_o.png"></p> 
<p>user:用户表       </p> 
<p>role:角色表        </p> 
<p>user_role_r:用户和角色关系表，多对多</p> 
<p>role_business:业务角色表       </p> 
<p>resource:资源表</p> 
<p>role_resource_r:角色资源关系表，多对多</p> 
<p>authority:操作码表</p> 
<p>resource_authority:资源和操作码关系表，多对多</p> 
<p>最后逆向生成实体类，本博客另有一篇记录逆向生成</p> 
<h2>3.使用java配置，配置shiro</h2> 
<p>ShiroFilterFactoryBean：是个拦截器，在请求进入控制层前将其拦截，需要将安全管理器SecurityManager注入其中</p> 
<p>SecurityManager：安全管理器，需要将自定义realm注入其中，以后还可以将缓存、remeberme等注入其中</p> 
<p>自定义reaml：认证授权会执行它，需要自己写</p> 
<p> </p> 
<pre class="has"><code class="language-html">@Configuration
public class ShiroConfig {
	/**
	 * ShiroFilterFactoryBean 处理拦截资源文件问题。
	 * 注意：单独一个ShiroFilterFactoryBean配置是或报错的，因为在初始化ShiroFilterFactoryBean的时候需要注入：SecurityManager
	 * Filter Chain定义说明 1、一个URL可以配置多个Filter，使用逗号分隔 2、当设置多个过滤器时，全部验证通过，才视为通过
	 * 3、部分过滤器可指定参数，如perms，roles
	 */
	@Bean
	public ShiroFilterFactoryBean shirFilter(SecurityManager securityManager) {
		ShiroFilterFactoryBean shiroFilterFactoryBean = new ShiroFilterFactoryBean();
		// 必须设置 SecurityManager
		shiroFilterFactoryBean.setSecurityManager(securityManager);
		
		// 如果不设置默认会自动寻找Web工程根目录下的"/login.jsp"页面
		//访问的是后端url地址为 /login的接口
		shiroFilterFactoryBean.setLoginUrl("/login");
		// 登录成功后要跳转的链接
		shiroFilterFactoryBean.setSuccessUrl("/index");
		// 未授权界面;
		shiroFilterFactoryBean.setUnauthorizedUrl("/403");
		// 拦截器.
		Map&lt;String, String&gt; filterChainDefinitionMap = new LinkedHashMap&lt;String, String&gt;();
		// 配置不会被拦截的链接 顺序判断
		filterChainDefinitionMap.put("/static/**", "anon");
		filterChainDefinitionMap.put("/ajaxLogin", "anon");
		filterChainDefinitionMap.put("/userlogin", "anon");
		
		// 配置退出过滤器,其中的具体的退出代码Shiro已经替我们实现了

		filterChainDefinitionMap.put("/logout", "logout");

                //配置某个url需要某个权限码

                filterChainDefinitionMap.put("/hello", "perms[how_are_you]");

		// 过滤链定义，从上向下顺序执行，一般将 /**放在最为下边 
		// &lt;!-- authc:所有url都必须认证通过才可以访问; anon:所有url都都可以匿名访问--&gt;
		filterChainDefinitionMap.put("/", "user");  
		filterChainDefinitionMap.put("/**", "authc");
		shiroFilterFactoryBean.setFilterChainDefinitionMap(filterChainDefinitionMap);
		System.out.println("Shiro拦截器工厂类注入成功");
		return shiroFilterFactoryBean;
	}
	
	@Bean
	public SecurityManager securityManager() {
		DefaultWebSecurityManager securityManager = new DefaultWebSecurityManager();
		// 设置realm.
		securityManager.setRealm(myShiroRealm());
	}
	/**
	 * 身份认证realm; (这个需要自己写，账号密码校验；权限等)
	 * @return
	 */
	@Bean
	public MyShiroRealm myShiroRealm() {
		MyShiroRealm myShiroRealm = new MyShiroRealm();
		return myShiroRealm;
	}

}</code></pre> 
<p> </p> 
<h2>4.自定义realm</h2> 
<p> </p> 
<p>MyShiroRealm继承 AuthorizingRealm，重写doGetAuthorizationInfo授权方法，和doGetAuthenticationInfo认证方法</p> 
<p> </p> 
<pre class="has"><code class="language-html">public class MyShiroRealm extends AuthorizingRealm{
	
	Boolean cachingEnabled=true;
	@Autowired
	UserService userService;

	@Override
	protected AuthorizationInfo doGetAuthorizationInfo(PrincipalCollection arg0) {

		SimpleAuthorizationInfo simpleAuthorInfo = new SimpleAuthorizationInfo();

		simpleAuthorInfo.addStringPermission("how_are_you");//给当前用户授权url为hello的权限码
		System.out.println("经试验：并不是每次调用接口就会执行，而是调用需要操作码（permission）的接口就会执行");
		return simpleAuthorInfo;
	}

	@Override
	protected AuthenticationInfo doGetAuthenticationInfo(
			AuthenticationToken authcToken) throws AuthenticationException {
		//获取基于用户名和密码的令牌  
        //实际上这个authcToken是从LoginController里面currentUser.login(token)传过来的
		UsernamePasswordToken token = (UsernamePasswordToken) authcToken;
		String account = token.getUsername();
		User user = userService.selectByAccount(account);//根据登陆名account从库中查询user对象
		if(user==null){throw new AuthenticationException("用户不存在");}
		
		//进行认证，将正确数据给shiro处理
		//密码不用自己比对，AuthenticationInfo认证信息对象，一个接口，new他的实现类对象SimpleAuthenticationInfo
		/*	第一个参数随便放，可以放user对象，程序可在任意位置获取 放入的对象
		 * 第二个参数必须放密码，
		 * 第三个参数放 当前realm的名字，因为可能有多个realm*/
		AuthenticationInfo authcInfo=new SimpleAuthenticationInfo(user, user.getPassword(), this.getName());
		//AuthenticationInfo authcInfo=new SimpleAuthenticationInfo(user,user.getPassword(),new MySimpleByteSource(account), this.getName());
	
		//清之前的授权信息
		super.clearCachedAuthorizationInfo(authcInfo.getPrincipals());
		SecurityUtils.getSubject().getSession().setAttribute("login", user);
		return authcInfo;//返回给安全管理器，securityManager，由securityManager比对数据库查询出的密码和页面提交的密码
		//如果有问题，向上抛异常，一直抛到控制器
	}
}</code></pre> 
<p> </p> 
<h2>5.页面</h2> 
<p> </p> 
<p>login页面</p> 
<pre class="has"><code class="language-html">&lt;!DOCTYPE html&gt;
&lt;html xmlns:th="http://www.thymeleaf.org"&gt;
&lt;head&gt;
&lt;meta charset="utf-8" /&gt;
&lt;meta http-equiv="X-UA-Compatible" content="IE=edge" /&gt;
&lt;title&gt;登录&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
	&lt;form action="userlogin" method="post" &gt;
		&lt;input type="text" name="loginName"&gt;请输入登录名&lt;/input&gt;
		&lt;input type="password" name="password"&gt;请输入密码&lt;/input&gt;
		&lt;input type="submit"&gt;&lt;/input&gt;
		&lt;div th:text="${message}"&gt;&lt;/div&gt;
	&lt;/form&gt;
&lt;/body&gt;

&lt;/html&gt;</code></pre> 
<p> </p> 
<p>index页面</p> 
<p> </p> 
<pre class="has"><code class="language-html">&lt;!DOCTYPE html&gt;
&lt;html xmlns:th="http://www.thymeleaf.org"&gt;
&lt;head&gt;
&lt;meta charset="utf-8" /&gt;
&lt;meta http-equiv="X-UA-Compatible" content="IE=edge" /&gt;
&lt;title&gt;首页&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
	&lt;div th:text="'欢迎你'+${session.login.loginName}"&gt;这是谁&lt;/div&gt;
	&lt;a th:href="@{/logout}"&gt;退出登录&lt;/a&gt;
&lt;/body&gt;
&lt;/html&gt;</code></pre> 
<p> </p> 
<h2>6.controller</h2> 
<p> </p> 
<pre class="has"><code class="language-html">@Controller
public class LoginController {
	
	@RequestMapping(value="/userlogin")
	public String userLogin(Model model,User user,HttpServletResponse response){
		if(user==null){return "login";} 
		String account=user.getLoginName();
		String password=user.getPassword();
		UsernamePasswordToken token = new UsernamePasswordToken(account,password,false);
		Subject currentUser = SecurityUtils.getSubject();
		try {
			currentUser.login(token);
			//此步将 调用realm的认证方法
		} catch(IncorrectCredentialsException e){
			//这最好把 所有的 异常类型都背会
			model.addAttribute("message", "密码错误");
			return "login";
		} catch (AuthenticationException e) {
			model.addAttribute("message", "登录失败");
			return "login";
		}		
		return "index";
	}
	
	//配合shiro配置中的默认访问url
	@RequestMapping(value="/login")
	public String getLogin(HttpServletRequest request,Model model,HttpSession session,HttpServletResponse response){
		return "login";
	}
	
	@RequestMapping(value="/hello")
	public String hello(){
		return "NewFile";
	}
	
	@RequestMapping(value="/")
	public String index(){
		System.out.println("访问了后端 /  请求");
		return "login";
	}
	
	/**
	* 退出
	 * @return
	 */
	@RequestMapping(value="logout",method =RequestMethod.GET)
	public String logout(HttpServletRequest request){
		
		//subject的实现类DelegatingSubject的logout方法，将本subject对象的session清空了
		//即使session托管给了redis ，redis有很多个浏览器的session
		//只要调用退出方法，此subject的、此浏览器的session就没了
		try {
			//退出
			SecurityUtils.getSubject().logout();
			
		} catch (Exception e) {
			System.err.println(e.getMessage());
		}
		return "login";

	}	

	@RequestMapping(value="403")
	public String unAuth(){
		
		return "403";
	}

}</code></pre> 
<p> </p> 
<p> </p> 
<p> </p> 
<h2>7.序列化异常</h2> 
<p><img alt="" class="has" src="https://images2.imgbox.com/8a/3b/wT5rKwhA_o.png"><img alt="" class="has" src="https://images2.imgbox.com/e6/db/4MQpd1xj_o.png"></p> 
<p>将 User类 实现序列化接口即可</p> 
<h2>8.登陆</h2> 
<p><img alt="" class="has" src="https://images2.imgbox.com/4f/3c/wFPIKlwm_o.png"><img alt="" class="has" src="https://images2.imgbox.com/e8/9e/BfS2siXB_o.png"></p> 
<h2>9.对url进行权限控制</h2> 
<p>在ShiroFilterFactoryBean shirFilter中我们设置了当前登录用户必须具有 权限码是how_are_you的操作码，才能访问 url为hello的链接.</p> 
<p>filterChainDefinitionMap.put("/hello", "perms[how_are_you]");</p> 
<p>在自定义realm的授权方法中，给登录用户授权了操作码simpleAuthorInfo.addStringPermission("how_are_you");所有可以访问hello</p> 
<p>如果没有授权，访问hello会到url为403的接口，这是在ShiroFilterFactoryBean shirFilter中配置的</p> 
<p>shiroFilterFactoryBean.setUnauthorizedUrl("/403");</p> 
<p><img alt="" class="has" src="https://images2.imgbox.com/5c/2f/UKxZ2c4p_o.png"></p> 
<h2>10.问题</h2> 
<p>登录时调用认证方法后，会调用授权方法，以后每访问一个需要权限码的接口，都会调用自定义realm的授权方法，必然影响效率。后面会记录加入缓存，避免这个问题</p> 
<p><img alt="" class="has" src="https://images2.imgbox.com/f1/ae/80wU43qj_o.png"></p> 
<p> </p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/907bdca979ee4ff3ca84d5650f5545a8/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">大小端模式详解及其测定</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/ea4c08decb168248491184f948b8ca2b/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">unity3d FPS 枪的后座力</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>