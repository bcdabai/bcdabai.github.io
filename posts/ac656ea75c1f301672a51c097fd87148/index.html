<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>【数据结构与算法】归并排序详解：归并排序算法，归并排序非递归实现 - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="【数据结构与算法】归并排序详解：归并排序算法，归并排序非递归实现" />
<meta property="og:description" content="一、归并排序 归并排序是一种经典的排序算法，它使用了分治法的思想。下面是归并排序的算法思想：
递归地将数组划分成较小的子数组，直到每个子数组的长度为1或者0。将相邻的子数组合并，形成更大的已排序的数组，直到最终得到一个完全排序的数组。 归并排序的过程可以分为三个步骤：拆分（Divide）、合并（Merge）和排序（Sort）。
拆分：将待排序的数组不断地划分为两个子数组，直到每个子数组的长度为1或者0。合并：将相邻的子数组合并为一个较大的已排序数组，通过比较两个子数组的首元素，按照从小到大的顺序逐个将元素放入一个辅助数组。排序：重复进行合并的过程，直到最终得到完全排序的数组。 归并排序的时间复杂度为O(nlogn)，其中n是待排序数组的长度。空间复杂度为O(n)，主要是由于需要使用一个大小与原始数组相同的辅助数组来存储合并的结果。
归并排序是一种稳定的排序算法，即相等元素的相对顺序在排序前后保持不变。在合并的过程中，如果遇到两个相等的元素，我们会先将来自前一个子数组的元素放入辅助数组，这样可以确保相等元素的相对顺序不会改变。
代码实现： // 归并排序具体功能实现函数 void MergeSortFun(int* a, int* temp, int begin, int end) { // 如果数组大小为1或者空，直接返回上一层 if (begin &gt;= end) { return; } // 划分数组，递归调用 MergeSortFun 对左右子数组进行排序 int mid = (begin &#43; end) / 2; MergeSortFun(a, temp, begin, mid); MergeSortFun(a, temp, mid &#43; 1, end); // 合并两个有序子数组 int begin1 = begin; int end1 = mid; int begin2 = mid &#43; 1; int end2 = end; int i = begin; // 依次比较两个子数组的元素，将较小的元素放入辅助数组 temp 中 while (begin1 &lt;= end1 &amp;&amp; begin2 &lt;= end2) { if (a[begin1] &lt; a[begin2]) { temp[i&#43;&#43;] = a[begin1&#43;&#43;]; } else { temp[i&#43;&#43;] = a[begin2&#43;&#43;]; } } // 将剩余的元素放入辅助数组 temp 中 while (begin1 &lt;= end1) { temp[i&#43;&#43;] = a[begin1&#43;&#43;]; } while (begin2 &lt;= end2) { temp[i&#43;&#43;] = a[begin2&#43;&#43;]; } // 将辅助数组 temp 中的元素拷贝回原数组 for (i = begin; i &lt;= end; i&#43;&#43;) { a[i] = temp[i]; } } // 归并排序入口函数 void MergeSort(int* a, int n) { int begin = 0; int end = n - 1; // 创建大小为 n 的辅助数组 temp int* temp = (int*)malloc(sizeof(int) * n); // 调用 MergeSortFun 对数组 a 进行归并排序 MergeSortFun(a, temp, begin, end); // 释放辅助数组 temp 的内存空间 free(temp); } 二、归并排序非递归实现 归并排序可以使用非递归的方式实现，其算法思想如下：" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/ac656ea75c1f301672a51c097fd87148/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2024-01-21T21:12:11+08:00" />
<meta property="article:modified_time" content="2024-01-21T21:12:11+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">【数据结构与算法】归并排序详解：归并排序算法，归并排序非递归实现</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <h3>一、归并排序</h3> 
<p>归并排序是一种经典的排序算法，它使用了分治法的思想。下面是归并排序的算法思想：</p> 
<ol><li>递归地将数组划分成较小的子数组，直到每个子数组的长度为1或者0。</li><li>将相邻的子数组合并，形成更大的已排序的数组，直到最终得到一个完全排序的数组。</li></ol> 
<p>归并排序的过程可以分为三个步骤：拆分（Divide）、合并（Merge）和排序（Sort）。</p> 
<ol><li>拆分：将待排序的数组不断地划分为两个子数组，直到每个子数组的长度为1或者0。</li><li>合并：将相邻的子数组合并为一个较大的已排序数组，通过比较两个子数组的首元素，按照从小到大的顺序逐个将元素放入一个辅助数组。</li><li>排序：重复进行合并的过程，直到最终得到完全排序的数组。</li></ol> 
<p>归并排序的时间复杂度为O(nlogn)，其中n是待排序数组的长度。空间复杂度为O(n)，主要是由于需要使用一个大小与原始数组相同的辅助数组来存储合并的结果。</p> 
<p>归并排序是一种稳定的排序算法，即相等元素的相对顺序在排序前后保持不变。在合并的过程中，如果遇到两个相等的元素，我们会先将来自前一个子数组的元素放入辅助数组，这样可以确保相等元素的相对顺序不会改变。</p> 
<p><img alt="" height="919" src="https://images2.imgbox.com/97/f8/T2LFaVCI_o.png" width="1200"></p> 
<p><img alt="" src="https://images2.imgbox.com/98/12/uv9xxtFV_o.gif"></p> 
<h4>代码实现：</h4> 
<pre><code>// 归并排序具体功能实现函数
void MergeSortFun(int* a, int* temp, int begin, int end)
{
    // 如果数组大小为1或者空，直接返回上一层
    if (begin &gt;= end)
    {
        return;
    }
    
    // 划分数组，递归调用 MergeSortFun 对左右子数组进行排序
    int mid = (begin + end) / 2;
    MergeSortFun(a, temp, begin, mid);
    MergeSortFun(a, temp, mid + 1, end);
    
    // 合并两个有序子数组
    int begin1 = begin;
    int end1 = mid;
    int begin2 = mid + 1;
    int end2 = end;
    int i = begin;
    
    // 依次比较两个子数组的元素，将较小的元素放入辅助数组 temp 中
    while (begin1 &lt;= end1 &amp;&amp; begin2 &lt;= end2)
    {
        if (a[begin1] &lt; a[begin2])
        {
            temp[i++] = a[begin1++];
        }
        else 
        {
            temp[i++] = a[begin2++];    
        }
    }
    
    // 将剩余的元素放入辅助数组 temp 中
    while (begin1 &lt;= end1)
    {
        temp[i++] = a[begin1++];
    }
    while (begin2 &lt;= end2)
    {
        temp[i++] = a[begin2++];
    }
    
    // 将辅助数组 temp 中的元素拷贝回原数组
    for (i = begin; i &lt;= end; i++)
    {
        a[i] = temp[i];
    }
}

// 归并排序入口函数
void MergeSort(int* a, int n)
{
    int begin = 0;
    int end = n - 1;
    
    // 创建大小为 n 的辅助数组 temp
    int* temp = (int*)malloc(sizeof(int) * n);
    
    // 调用 MergeSortFun 对数组 a 进行归并排序
    MergeSortFun(a, temp, begin, end);
    
    // 释放辅助数组 temp 的内存空间
    free(temp);
}</code></pre> 
<hr> 
<h3>二、归并排序非递归实现 </h3> 
<p>归并排序可以使用非递归的方式实现，其算法思想如下：</p> 
<ol><li>将待排序的数组划分为多个大小为1的子数组。</li><li>分别对这些子数组进行两两合并，形成新的有序子数组。</li><li>不断重复步骤2，直到得到一个有序的数组。</li></ol> 
<p>具体的非递归实现过程如下：</p> 
<ol><li>首先，定义一个大小为n的辅助数组temp用于存储合并后的有序子数组。</li><li>设置一个变量gap初始值为1，表示每次合并的两个子数组的大小。</li><li>进行多轮合并，直到gap大于等于n。 
  <ul><li><span style="color:#4da8ee;">在每一轮合并中，将数组分为多个大小为gap的子数组，将相邻的两个子数组合并为一个有序子数组。</span><span style="color:#0d0016;">合并时，使用双指针i和j分别指向两个子数组的起始位置，比较两个子数组对应位置上的元素大小，较小的元素放入temp数组中，同时移动指针，直到一个子数组遍历完成。</span><span style="color:#0d0016;">将未遍历完的子数组中剩余的元素直接放入temp数组中。</span></li><li><span style="color:#4da8ee;">更新gap的值为2倍，继续下一轮合并。</span></li></ul></li><li>最后一轮合并时，gap可能大于n，因此需要额外的判断和处理。</li><li>将temp数组中的元素拷贝回原数组中。</li></ol> 
<p>通过不断调整gap的大小，将待排序数组进行分组和合并操作，直到得到一个完全有序的数组。非递归实现的归并排序避免了递归带来的额外开销，提高了算法的效率。、</p> 
<p><img alt="" height="692" src="https://images2.imgbox.com/0e/30/XPGd7SNz_o.png" width="1165"></p> 
<h4> 代码实现：</h4> 
<pre><code>void mergesortnr(int* a, int* temp, int begin, int mid, int end)
{
    // 定义指针和索引
    int head1 = begin;
    int tail1 = mid;
    int head2 = mid + 1;
    int tail2 = end;
    int i = begin;

    // 合并两个有序子数组
    // [head1,tail1] 和 [head2,tail2] 归并
    while (head1 &lt;= tail1 &amp;&amp; head2 &lt;= tail2)
    {
        // 比较两个子数组对应位置上的元素大小，较小的元素放入temp数组中
        if (a[head1] &lt; a[head2])
        {
            temp[i++] = a[head1++];
        }
        else
        {
            temp[i++] = a[head2++];
        }
    }

    // 将第一个子数组中剩余的元素放入temp数组中
    while (head1 &lt;= tail1)
    {
        temp[i++] = a[head1++];
    }

    // 将第二个子数组中剩余的元素放入temp数组中
    while (head2 &lt;= tail2)
    {
        temp[i++] = a[head2++];
    }

    // 将temp数组中的元素拷贝回原数组中
    memcpy(a + begin, temp + begin, sizeof(int) * (end - begin + 1));
}

void MergeSortNR(int *a, int n) 
{
    // 创建辅助数组
    int* temp = (int*)malloc(sizeof(int) * n);
    int gap = 1;

    // 不断调整gap的大小，分组合并
    for (gap = 1; gap &lt; n; gap *= 2)
    {
        // 对每一组进行合并
        for (int i = 0; i &lt; n - gap; i += 2 * gap)
        {
            // 计算子数组的起始索引、中间索引和结束索引
            int begin = i;、
/*如果i + 2 * gap - 1大于等于数组长度n，说明当前的子数组已经超出了数组的范围，此时将结束索引end赋值为n - 1，即最后一个元素的索引。

如果i + 2 * gap - 1小于数组长度n，说明当前的子数组还在数组的范围内，此时将结束索引end赋值为i + 2 * gap - 1。*/
            int end = i + 2 * gap - 1 &gt;= n ? n - 1 : i + 2 * gap - 1;
            int mid = i + gap - 1;

            // 调用mergesortnr函数合并子数组
            mergesortnr(a, temp, begin, mid, end);
        }
    }
}</code></pre> 
<p></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/1f5880c5ca8b6e24ac8d5546dfc4db68/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">PIG框架学习3——Redisson 实现业务接口幂等</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/4927afffe0cc3689e7afef59d756caba/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">八股文学习日常第一期（20240121）</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>