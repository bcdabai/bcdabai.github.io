<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>【CC2530入门教程-02】CC2530的通用I/O端口输入和输出控制 - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="【CC2530入门教程-02】CC2530的通用I/O端口输入和输出控制" />
<meta property="og:description" content="【CC2530入门教程-06】CC2530的ADC工作原理与应用
【CC2530入门教程-05】CC2530的串行接口原理与应用
【CC2530入门教程-04】CC2530的定时/计数器原理与应用
【CC2530入门教程-03】CC2530的中断系统及外部中断应用
【CC2530入门教程-02】CC2530的通用I/O端口输入和输出控制
【CC2530入门教程-01】CC2530微控制器开发入门基础
一、CC2530的引脚概述 CC2530微控制器采用QFN40封装，有40 个引脚。其中，有21个数字I/O端口，其中P0和P1是8 位端口，P2仅有5位可以使用。这21个端口均可以通过编程进行配置。实际上，在P2端口的5个引脚中，有2个需要用作仿真，有2个需要用作晶振，你在CC2530的开发中真正能够使用的只有17个引脚。
在微控制器内部，有一些特殊功能的存储单元，这些单元用来存放控制微控制器内部器件的命令、数据或运行过程中的一些状态信息，这些寄存器统称为“特殊功能寄存器（SFR）”。操作微控制器的本质，就是对这些特殊功能寄存器进行读写操作，并且某些特殊功能寄存器可以位寻址。
每一个特殊功能寄存器本质上就是一个内存单元，而标识每个内存单元的是内存地址，不容易记忆。为了便于使用，每个特殊功能寄存器都会起一个名字，在程序设计时，只要引入头文件“ioCC2530.h”，就可以直接使用寄存器的名称访问内存地址了。
CC2530的通用I/O端口相关的常用寄存器有下面4个：
&lt;1&gt; PxSEL：端口功能选择，设置端口是通用I/O还是外设功能。
&lt;2&gt; PxDIR：作为通用I/O时，用来设置数据的传输方向。
&lt;3&gt; PxINP：作为通用输入端口时，选择输入模式是上拉、下拉还是三态。
&lt;4&gt; Px：数据端口，用来控制端口的输出或获取端口的输入。
二、设置寄存器中某些位的方法 &lt;1&gt; 对寄存器的某些位清0而不影响其他位。 例如：寄存器P1TM的当前值是0x6c，现需要将该寄存器的第1位、第3 位和第5位设置为0，同时不能影响该寄存器其他位的值，那么，在C语言中应该怎么编写代码呢？
使用“&amp;=”将寄存器指定位清0，同时不影响其他位的值。
正确写法：P1TM &amp;= ~0x2A；
因为：逻辑“与”操作的特点是，该位有0结果就为0，若为1则保存原来值不变。
首先将字节 0000 0000 中要操作的位设置为1，即0010 1010，在将该数值取反，即1101 0101，也就是~0x2A。再将该值与寄存器P1TM“相与”，那么有0的位，即1、3、5位将被清0，其余的位会保持原来的值不变。
所以：P1TM的当前值为0x6c，即0110 1100，
0110 1100 &amp;&amp; 1101 0101 = 0100 0100，即1、3、5位清0，其他位不变。
&lt;注意&gt;：该方法只能操作多位同时清0，或者某一位清0的情况，如果要将寄存器的位既要清0又要置1，则不能采用这种写法。（其中原因自己思考一下）
在不少嵌入式应用的源码程序中，对于寄存器的第n位的清0操作也可以写成：寄存器 &amp;= ~(0x01&lt;&lt;(n))；其道理是一样的。
&lt;2&gt; 对寄存器的某些位置1而不影响其他位。 例如：寄存器P1TM的当前值是0x6c，现需要将该寄存器的第1位、第4位和第5位设置为1，同时不能影响该寄存器其他位的值，那么，在C语言中应该怎么编写代码呢？
使用“|=”将寄存器指定位置1，同时不影响其他位的值。
正确写法：P1TM |= 0x32；
因为：逻辑“或”操作的特点是，该位有1结果就为1，若为0则保存原来值不变。
首先将字节 0000 0000 中要操作的位设置为1，即0011 0010，也就是0x32。 再将该值与寄存器P1TM“相或”，那个有1的位，即1、4、5位将被设置为1，其余的位会保持原来的值不变。
所以：P1TM的当前值为0x6c，即0110 1100，
0110 1100 || 0011 0010 = 0111 1110，即1、4、5位置1，其他位不变。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/6b2bf2575fdb3c02e23e183005b77507/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2021-03-03T15:03:33+08:00" />
<meta property="article:modified_time" content="2021-03-03T15:03:33+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">【CC2530入门教程-02】CC2530的通用I/O端口输入和输出控制</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p><strong><a href="https://blog.csdn.net/weixin_44643510/article/details/114440828">【CC2530入门教程-06】CC2530的ADC工作原理与应用</a></strong></p> 
<p><strong><a href="https://blog.csdn.net/weixin_44643510/article/details/114440596">【CC2530入门教程-05】CC2530的串行接口原理与应用</a></strong></p> 
<p><strong><a href="https://blog.csdn.net/weixin_44643510/article/details/114440536">【CC2530入门教程-04】CC2530的定时/计数器原理与应用</a></strong></p> 
<p><strong><a href="https://blog.csdn.net/weixin_44643510/article/details/114319628">【CC2530入门教程-03】CC2530的中断系统及外部中断应用</a></strong></p> 
<p><strong><a href="https://blog.csdn.net/weixin_44643510/article/details/114315442">【CC2530入门教程-02】CC2530的通用I/O端口输入和输出控制</a></strong></p> 
<p><strong><a href="https://blog.csdn.net/weixin_44643510/article/details/114440410">【CC2530入门教程-01】CC2530微控制器开发入门基础</a></strong></p> 
<hr> 
<h3><strong>一、CC2530的引脚概述</strong></h3> 
<p>        CC2530微控制器采用<strong>QFN40封装</strong>，有40 个引脚。其中，有<strong>21个数字I/O端口</strong>，其中<strong>P0和P1是8 位端口</strong>，<strong>P2仅有5位</strong>可以使用。<strong>这21个端口均可以通过编程进行配置</strong>。实际上，在P2端口的5个引脚中，有2个需要用作仿真，有2个需要用作晶振，你在CC2530的开发中真正能够使用的<strong>只有17个引脚</strong>。</p> 
<p><img alt="" height="453" src="https://images2.imgbox.com/d5/9e/Mk6RbAiv_o.png" width="386"></p> 
<p style="text-indent:0;">        在微控制器内部，有一些特殊功能的存储单元，这些单元用来存放控制微控制器内部器件的命令、数据或运行过程中的一些状态信息，这些寄存器统称为“<strong>特殊功能寄存器（SFR）</strong>”。<strong>操作微控制器的本质</strong>，就是对这些特殊功能寄存器进行读写操作，并且某些特殊功能寄存器可以<strong>位寻址</strong>。</p> 
<p style="text-indent:0;">        每一个<strong>特殊功能寄存器</strong>本质上就是一个<strong>内存单元</strong>，而标识每个内存单元的是内存地址，不容易记忆。为了便于使用，每个特殊功能寄存器都会起一个名字，在程序设计时，只要引入头文件“<strong>ioCC2530.h</strong>”，就可以直接使用寄存器的名称访问内存地址了。</p> 
<p style="text-indent:0;">CC2530的通用I/O端口相关的常用寄存器有下面4个：</p> 
<p style="text-indent:0;">        &lt;1&gt; <strong>PxSEL</strong>：端口功能选择，设置端口是<strong>通用I/O</strong>还是<strong>外设功能</strong>。</p> 
<p style="text-indent:0;">        &lt;2&gt; <strong>PxDIR</strong>：作为通用I/O时，用来设置数据的传输方向。</p> 
<p style="text-indent:0;">        &lt;3&gt; <strong>PxINP</strong>：作为通用输入端口时，选择输入模式是<strong>上拉</strong>、<strong>下拉</strong>还是<strong>三态</strong>。</p> 
<p style="text-indent:0;">        &lt;4&gt; <strong>Px</strong>：数据端口，用来控制端口的输出或获取端口的输入。</p> 
<p style="text-indent:0;"> </p> 
<h3><strong>二、设置寄存器中某些位的方法</strong></h3> 
<h3><strong> &lt;1&gt; 对寄存器的某些位清0而不影响其他位。</strong></h3> 
<p>        例如：寄存器P1TM的当前值是0x6c，现需要将该寄存器的第<strong>1</strong>位、第<strong>3</strong> 位和第<strong>5</strong>位设置为<strong>0</strong>，同时不能影响该寄存器其他位的值，那么，在C语言中应该怎么编写代码呢？</p> 
<p>        使用“<strong>&amp;=</strong>”将寄存器指定位清0，同时不影响其他位的值。</p> 
<p>        正确写法：<strong>P1TM &amp;= ~0x2A；</strong></p> 
<p>        因为：<strong>逻辑“与”</strong>操作的特点是，该位有0结果就为0，若为1则保存原来值不变。</p> 
<p>        首先将字节<strong> 0000 0000</strong> 中<strong>要操作的位</strong>设置为<strong>1</strong>，即<strong>0010 1010</strong>，在将该数值<strong>取反</strong>，即<strong>1101 0101</strong>，也就是<strong>~0x2A</strong>。再将该值与寄存器P1TM“相与”，那么有0的位，即1、3、5位将被清0，其余的位会保持原来的值不变。</p> 
<p>        所以：P1TM的当前值为0x6c，即0110 1100，</p> 
<p>       <strong> 0110 1100</strong> <strong>&amp;&amp;</strong> <strong>1101 0101</strong> = <strong>0100 0100</strong>，即1、3、5位清0，其他位不变。</p> 
<p>       <strong> &lt;注意&gt;</strong>：该方法只能操作多位同时清0，或者某一位清0的情况，如果要将寄存器的位既要清0又要置1，则不能采用这种写法。（其中原因自己思考一下）</p> 
<p>        在不少嵌入式应用的源码程序中，对于寄存器的第n位的清0操作也可以写成：<strong>寄存器 &amp;= ~(0x01&lt;&lt;(n))；</strong>其道理是一样的。</p> 
<h3><strong>&lt;2&gt; 对寄存器的某些位置1而不影响其他位。</strong></h3> 
<p>        例如：寄存器P1TM的当前值是0x6c，现需要将该寄存器的第<strong>1</strong>位、第<strong>4</strong>位和第<strong>5</strong>位设置为<strong>1</strong>，同时不能影响该寄存器其他位的值，那么，在C语言中应该怎么编写代码呢？</p> 
<p>        使用“<strong>|=</strong>”将寄存器指定位置1，同时不影响其他位的值。</p> 
<p>        正确写法：<strong>P1TM |= 0x32；</strong></p> 
<p>        因为：<strong>逻辑“或”</strong>操作的特点是，该位有1结果就为1，若为0则保存原来值不变。</p> 
<p>        首先将字节<strong> 0000 0000</strong> 中<strong>要操作的位</strong>设置为<strong>1</strong>，即<strong>0011 0010</strong>，也就是0x32。 再将该值与寄存器P1TM“相或”，那个有1的位，即1、4、5位将被设置为1，其余的位会保持原来的值不变。</p> 
<p>        所以：P1TM的当前值为0x6c，即0110 1100，</p> 
<p>       <strong> 0110 1100 ||</strong> <strong>0011 0010</strong> =<strong> 0111 1110</strong>，即1、4、5位置1，其他位不变。</p> 
<p>        同样要注意：该方法只能操作多位同时置1，或者某一位置1的情况。</p> 
<p>        对于寄存器的第n位的清0操作也可以写成：<strong>寄存器 |= (0x01&lt;&lt;(n))；</strong></p> 
<p> </p> 
<h2><strong>三、实训案例：按键输入控制灯光输出状态</strong></h2> 
<p><img alt="" src="https://images2.imgbox.com/e2/13/UN95q8IR_o.png"></p> 
<h3><strong>【1】准备工作。</strong></h3> 
<p>引入CC2530必要的头文件“<strong>ioCC2530.h</strong>”，定义相关变量等。</p> 
<p><img alt="" src="https://images2.imgbox.com/37/a6/Gcc3NswR_o.png"></p> 
<h3><strong>【2】端口功能选择。</strong></h3> 
<p>        微控制器的大部分I/O端口都是<strong>功能复用</strong>的，在使用的时候需要通过功能选择寄存器来配置端口的功能。</p> 
<p><img alt="" src="https://images2.imgbox.com/31/7b/VRm3lkK5_o.png"></p> 
<h3><strong>【3】端口传输方向设置。</strong></h3> 
<p><img alt="" src="https://images2.imgbox.com/37/1b/HjLJHRXj_o.png"></p> 
<h3><strong>【4】对于输入的端口要设置其输入方式。</strong></h3> 
<p>        输入方式用来从外界器件获取输入的电信号，当CC2530的引脚为输入端口时，该端口能够提供“上拉”、“下拉”和“三态”三种输入模式，可以通过编程进行设置。在本次实训中，实际上不需要对P0_1和P1_2引脚进行输入方式的设置，因为CC2530复位后，各个I/O端口默认使用的就是上拉模式。</p> 
<p><img alt="" src="https://images2.imgbox.com/8c/1b/eyOWbwwB_o.png"></p> 
<p><img alt="" src="https://images2.imgbox.com/41/38/zqUHqeH0_o.png"></p> 
<h3><strong>【5】通用I/O端口寄存器配置的基本思路。</strong></h3> 
<p><strong><img alt="" src="https://images2.imgbox.com/c4/0e/KNtO4RA3_o.png"></strong></p> 
<h3><strong>【6】设计端口初始化函数InitPort()。</strong></h3> 
<p>        &lt;1&gt;设置<strong>P1SEL</strong>寄存器，将P1_2、P1_3和P1_4设置为通用I/O端口。</p> 
<p>        &lt;2&gt;设置<strong>P1DIR</strong>寄存器，将P1_3和P1_4设置为输出，将P1_2设置为输入。</p> 
<p>        &lt;3&gt;设置<strong>P0SEL</strong>寄存器，将P0_1设置为通用I/O端口。</p> 
<p>        &lt;4&gt;设置<strong>P0DIR</strong>寄存器，将P0_1设置为输入。</p> 
<p>        &lt;5&gt;设置<strong>PxINP</strong>寄存器，将P0_1和P1_2设置为上拉模式，也可以不设置。</p> 
<h3><strong>【7】设计键盘扫描函数ScanKeys()。</strong></h3> 
<p>        &lt;1&gt;没有按键下时，端口的输入为<strong>高电平</strong>，当发现该端口有<strong>低电平</strong>产生时，则有可能会是按键按下，需要经过<strong>去抖动</strong>处理，如果该端口还是低电平，则<strong>确认</strong>为按键按下。</p> 
<p>        &lt;2&gt;在进行按键处理时，先<strong>等待按键松开</strong>，然后再将相关的LED进行开关状态的取反控制。</p> 
<h3><strong>【8】主函数的实现。</strong></h3> 
<p><img alt="" src="https://images2.imgbox.com/b2/5d/anRkssoe_o.png"></p> 
<p>至此，大功搞成，连接仿真器，进行编译调试。</p> 
<p><strong>【附件】：本实训源代码。</strong></p> 
<pre><code>#include "ioCC2530.h"

#define LED5 P1_3
#define LED6 P1_4
#define SW1 P1_2
#define SW2 P0_1
/*===================延时函数=========================*/
void Delay(unsigned int t)
{
  while(t--);
}
/*================端口初始化函数======================*/
void InitPort()
{
  P1SEL &amp;= ~0x18;         //将P1_3和P1_4设置为通用I/O端口功能
  P1DIR |= 0x18;          //将P1_3和P1_4的端口传输方式设置为输出
  P1SEL &amp;= ~0x04;         //将P1_2设置为通用I/O端口功能
  P1DIR &amp;= ~0x04;         //将P1_2的端口传输方式设置为输入
  P0SEL &amp;= ~0x02;         //将P0_1设置为通用I/O端口功能
  P0DIR &amp;= ~0x02;         //将P0_1的端口传输方式设置为输入
  P0INP &amp;= ~0x02;         //将P0_1的端口输入方式设置为：上拉/下拉
  P1INP &amp;= ~0x04;         //将P1_2的端口输入方式设置为：上拉/下拉
  P2INP &amp;= ~0x60;         //将P0端口和P1端口引脚设置为：上拉
  LED5 = 0;               //上电的时候，LED5不亮
  LED6 = 0;               //上电的时候，LED6不亮
}
/*=================按键扫描函数=======================*/
void ScanKeys()
{
  if(SW1 == 0)
  {                       //发现SW1有低电平信号
    Delay(100);           //按键去抖动
    if(SW1 == 0)
    {                      //确实是有按键动作
      while(SW1 == 0);    //等待按键1松开
      //将LED5的灯光开关状态取反
      LED5 = ~LED5;
  }
  if(SW2 == 0)
  {                       //发现SW2有低电平信号
    Delay(100);           //按键去抖动
    if(SW2 == 0)
    {                     //确实是有按键动作
      while(SW2 == 0);    //等待按键2松开
      LED6 = ~LED6;
    }
  }
}
/*=====================主函数=========================*/
void main()
{
  InitPort();
  while(1)
  {
    ScanKeys();
  }
}</code></pre> 
<p> </p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/0c7b1fe7ab31b001ee31d3e76a903030/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">Android  关于.9图设置拉伸区域无效问题</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/d65cb7929eed66bb4ca46d5727582d01/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">adf机器_智能运维高招 | 基于机器学习的磁盘故障预测</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>