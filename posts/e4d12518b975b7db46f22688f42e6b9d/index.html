<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Vue3 京东到家项目实战第二篇（商家详情页面及购物车完整逻辑开发） 进阶式掌握vue3完整知识体系 - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Vue3 京东到家项目实战第二篇（商家详情页面及购物车完整逻辑开发） 进阶式掌握vue3完整知识体系" />
<meta property="og:description" content="目录
封装axios请求💙
商家详情页面的实现 💜 页面样式实现
页面防抖
省略号表示多余内容
通过 watchEffect 巧妙的进行代码拆分
底部购物车样式开发❤️ 购物车数据联动 💚 同步改变选中数字与金额
根据购物车选中状态实现计算金额
清空购物车功能
本地存储保存购物车数据
个人主页：小杰学前端
Vue3 京东到家项目实战第一篇：京东到家（首页及登录功能开发）
项目源码在文章最后哦🙋🙋🙋
封装axios请求 💨 在第一篇中我们的附近店铺是写死的数据，我们把它通过接口请求过来。 在 util 下的 request.js 中我们还需要写一个 get 请求来获取附近店铺的数据，那我们创建一个 axios 实例对象，在里面配置参数，这样就不需要在每个请求里都设置 baseURL 了。
const instance = axios.create({ baseURL: &#39;https://www.fastmock.site/mock/ae8e9031947a302fed5f92425995aa19/jd&#39;, timeout: 10000 }) 这样我们把原来的 post 进行一下封装：
export const post = (url, data = {}) =&gt; { return new Promise((resolve, reject) =&gt; { instance.post(url, data, { headers: { &#39;Content-Type&#39;: &#39;application/json&#39; } })." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/e4d12518b975b7db46f22688f42e6b9d/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-07-13T12:13:26+08:00" />
<meta property="article:modified_time" content="2022-07-13T12:13:26+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Vue3 京东到家项目实战第二篇（商家详情页面及购物车完整逻辑开发） 进阶式掌握vue3完整知识体系</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p><strong>目录</strong></p> 
<p id="%E5%B0%81%E8%A3%85axios%E8%AF%B7%E6%B1%82-toc" style="margin-left:40px;"><a href="#%E5%B0%81%E8%A3%85axios%E8%AF%B7%E6%B1%82" rel="nofollow">封装axios请求</a>💙</p> 
<p id="%E5%95%86%E5%AE%B6%E8%AF%A6%E6%83%85%E9%A1%B5%E9%9D%A2%E7%9A%84%E5%AE%9E%E7%8E%B0-toc" style="margin-left:40px;"><a href="#%E5%95%86%E5%AE%B6%E8%AF%A6%E6%83%85%E9%A1%B5%E9%9D%A2%E7%9A%84%E5%AE%9E%E7%8E%B0" rel="nofollow">商家详情页面的实现</a> 💜 </p> 
<p id="%E9%A1%B5%E9%9D%A2%E6%A0%B7%E5%BC%8F%E5%AE%9E%E7%8E%B0-toc" style="margin-left:80px;"><a href="#%E9%A1%B5%E9%9D%A2%E6%A0%B7%E5%BC%8F%E5%AE%9E%E7%8E%B0" rel="nofollow">页面样式实现</a></p> 
<p id="%E9%A1%B5%E9%9D%A2%E9%98%B2%E6%8A%96-toc" style="margin-left:80px;"><a href="#%E9%A1%B5%E9%9D%A2%E9%98%B2%E6%8A%96" rel="nofollow">页面防抖</a></p> 
<p id="%E7%9C%81%E7%95%A5%E5%8F%B7%E8%A1%A8%E7%A4%BA%E5%A4%9A%E4%BD%99%E5%86%85%E5%AE%B9-toc" style="margin-left:80px;"><a href="#%E7%9C%81%E7%95%A5%E5%8F%B7%E8%A1%A8%E7%A4%BA%E5%A4%9A%E4%BD%99%E5%86%85%E5%AE%B9" rel="nofollow">省略号表示多余内容</a></p> 
<p id="%E9%80%9A%E8%BF%87%20watchEffect%20%E5%B7%A7%E5%A6%99%E7%9A%84%E8%BF%9B%E8%A1%8C%E4%BB%A3%E7%A0%81%E6%8B%86%E5%88%86-toc" style="margin-left:80px;"><a href="#%E9%80%9A%E8%BF%87%20watchEffect%20%E5%B7%A7%E5%A6%99%E7%9A%84%E8%BF%9B%E8%A1%8C%E4%BB%A3%E7%A0%81%E6%8B%86%E5%88%86" rel="nofollow">通过 watchEffect 巧妙的进行代码拆分</a></p> 
<p id="%E5%BA%95%E9%83%A8%E8%B4%AD%E7%89%A9%E8%BD%A6%E6%A0%B7%E5%BC%8F%E5%BC%80%E5%8F%91-toc" style="margin-left:40px;"><a href="#%E5%BA%95%E9%83%A8%E8%B4%AD%E7%89%A9%E8%BD%A6%E6%A0%B7%E5%BC%8F%E5%BC%80%E5%8F%91" rel="nofollow">底部购物车样式开发</a>❤️ </p> 
<p id="%E8%B4%AD%E7%89%A9%E8%BD%A6%E6%95%B0%E6%8D%AE%E8%81%94%E5%8A%A8-toc" style="margin-left:40px;"><a href="#%E8%B4%AD%E7%89%A9%E8%BD%A6%E6%95%B0%E6%8D%AE%E8%81%94%E5%8A%A8" rel="nofollow">购物车数据联动</a> 💚 </p> 
<p id="%E5%90%8C%E6%AD%A5%E6%94%B9%E5%8F%98%E9%80%89%E4%B8%AD%E6%95%B0%E5%AD%97%E4%B8%8E%E9%87%91%E9%A2%9D-toc" style="margin-left:80px;"><a href="#%E5%90%8C%E6%AD%A5%E6%94%B9%E5%8F%98%E9%80%89%E4%B8%AD%E6%95%B0%E5%AD%97%E4%B8%8E%E9%87%91%E9%A2%9D" rel="nofollow">同步改变选中数字与金额</a></p> 
<p id="%E6%A0%B9%E6%8D%AE%E8%B4%AD%E7%89%A9%E8%BD%A6%E9%80%89%E4%B8%AD%E7%8A%B6%E6%80%81%E5%AE%9E%E7%8E%B0%E8%AE%A1%E7%AE%97%E9%87%91%E9%A2%9D-toc" style="margin-left:80px;"><a href="#%E6%A0%B9%E6%8D%AE%E8%B4%AD%E7%89%A9%E8%BD%A6%E9%80%89%E4%B8%AD%E7%8A%B6%E6%80%81%E5%AE%9E%E7%8E%B0%E8%AE%A1%E7%AE%97%E9%87%91%E9%A2%9D" rel="nofollow">根据购物车选中状态实现计算金额</a></p> 
<p id="%E6%B8%85%E7%A9%BA%E8%B4%AD%E7%89%A9%E8%BD%A6%E5%8A%9F%E8%83%BD-toc" style="margin-left:80px;"><a href="#%E6%B8%85%E7%A9%BA%E8%B4%AD%E7%89%A9%E8%BD%A6%E5%8A%9F%E8%83%BD" rel="nofollow">清空购物车功能</a></p> 
<p id="%E6%9C%AC%E5%9C%B0%E5%AD%98%E5%82%A8%E4%BF%9D%E5%AD%98%E8%B4%AD%E7%89%A9%E8%BD%A6%E6%95%B0%E6%8D%AE-toc" style="margin-left:80px;"><a href="#%E6%9C%AC%E5%9C%B0%E5%AD%98%E5%82%A8%E4%BF%9D%E5%AD%98%E8%B4%AD%E7%89%A9%E8%BD%A6%E6%95%B0%E6%8D%AE" rel="nofollow">本地存储保存购物车数据</a></p> 
<hr id="hr-toc"> 
<p></p> 
<blockquote> 
 <p><strong>个人主页：<strong><a href="https://blog.csdn.net/qq_49900295?spm=1000.2115.3001.5343" title="小杰学前端">小杰学前端</a></strong></strong></p> 
 <p><strong>Vue3 京东到家项目实战第一篇</strong><strong>：<strong><a class="link-info" href="https://blog.csdn.net/qq_49900295/article/details/124920585?spm=1001.2014.3001.5502" title="京东到家（首页及登录功能开发）">京东到家（首页及登录功能开发）</a></strong></strong></p> 
 <p><strong><strong>项目源码在文章最后哦</strong></strong>🙋🙋🙋</p> 
</blockquote> 
<h3 id="%E5%B0%81%E8%A3%85axios%E8%AF%B7%E6%B1%82">封装axios请求 💨 </h3> 
<p>在第一篇中我们的附近店铺是写死的数据，我们把它通过接口请求过来。 </p> 
<p><strong><span style="color:#be191c;"><span style="background-color:#fef2f0;">在 util 下的 request.js 中我们还需要写一个 get 请求来获取附近店铺的数据，那我们创建一个 axios 实例对象，在里面配置参数，这样就不需要在每个请求里都设置 baseURL 了。</span></span></strong></p> 
<pre><code class="language-javascript">const instance = axios.create({
  baseURL: 'https://www.fastmock.site/mock/ae8e9031947a302fed5f92425995aa19/jd',
  timeout: 10000
})</code></pre> 
<p><strong><span style="color:#1a439c;"><span style="background-color:#eaf4fc;">这样我们把原来的 post 进行一下封装：</span></span></strong></p> 
<pre><code class="language-javascript">export const post = (url, data = {}) =&gt; {
  return new Promise((resolve, reject) =&gt; {
    instance.post(url, data, {
      headers: {
        'Content-Type': 'application/json'
      }
    }).then((response) =&gt; {
      resolve(response)
    }, err =&gt; {
      reject(err)
    })
  })
}
</code></pre> 
<p><strong><span style="color:#1a439c;"><span style="background-color:#eaf4fc;">然后再写一个 get 请求：</span></span></strong></p> 
<pre><code class="language-javascript">export const get = (url, params = {}) =&gt; {
  return new Promise((resolve, reject) =&gt; {
    instance.get(url, { params }).then((response) =&gt; {
      resolve(response)
    }, err =&gt; {
      reject(err)
    })
  })
}</code></pre> 
<p><strong><span style="color:#1a439c;"><span style="background-color:#eaf4fc;">现在附近店铺的数据我们是写在 setup 里：</span></span></strong></p> 
<p><img alt="" height="822" src="https://images2.imgbox.com/71/dc/zhAdoimQ_o.png" width="810"></p> 
<p>现在我们就要改成从后端接口来请求相关数据 ，删掉这些数据然后把刚刚定义的get方法引入进来，向接口发送get请求，这里请求的接口在接口文档里：</p> 
<p><img alt="" height="1200" src="https://images2.imgbox.com/f1/7b/exJ7jh9Y_o.jpg" width="1200"></p> 
<p><strong><span style="color:#511b78;"><span style="background-color:#efedf6;">我们调用封装的 get 请求，把url设置为热门店铺的接口地址 ：</span></span></strong></p> 
<pre><code class="language-javascript">import { ref } from 'vue'
import { get } from '../../utils/request'
export default ({
  name: 'NearBy',
  setup () {
    const nearbyList = ref([])
    const getNearbyList = async () =&gt; {
      const result = await get('/api/shop/hot-list')
      console.log(result)
    }
    getNearbyList()
    return {
      nearbyList,
      getNearbyList
    }
  }
})</code></pre> 
<p><strong><span style="color:#511b78;"><span style="background-color:#efedf6;">打印一下返回的结果，启动项目，查看控制台输出：</span></span></strong></p> 
<p><img alt="" height="231" src="https://images2.imgbox.com/9e/3f/UlcHjRCt_o.png" width="998"></p> 
<p>现在后端的数据就被我们接收到了。</p> 
<p><strong><span style="color:#511b78;"><span style="background-color:#efedf6;">我们修改一下 NearBy 中的代码：</span></span></strong></p> 
<pre><code class="language-javascript">export default ({
  name: 'NearBy',
  setup () {
    // const router = useRouter()
    const nearbyList = ref([])
    const getNearbyList = async () =&gt; {
      const result = await get('/api/shop/hot-list')
      if (result.data.errno === 0) {
        nearbyList.value = result.data.data
      }
    }
    getNearbyList()
    return {
      nearbyList
    }
  }
})</code></pre> 
<p><span style="background-color:#fefcd8;">把原来的 nearblList 通过ref设置为响应式的数组，然后把 get 请求回来的数据赋给我们定义好的数组，当然视图模板里的内容也需要改动，我们先看一下接口信息：</span></p> 
<p><img alt="" height="1200" src="https://images2.imgbox.com/4a/ea/07KiYIaz_o.jpg" width="1200"></p> 
<p>在原来的视图模板中，循环列表里的信息时，key我们定义的是 id ，但是在后端给我们的接口数据结构中就不是 id 了，而是 _id，所以我们都得参照这个数据结构进行修改，修改后的代码如下：</p> 
<pre><code class="language-javascript">&lt;template&gt;
    &lt;div class="nearby"&gt;
      &lt;h3 class="nearby__title"&gt;附近店铺&lt;/h3&gt;
      &lt;div class="nearby__item" v-for="item in nearbyList" :key="item._id"&gt;
        &lt;img :src="item.imgUrl" alt="" class="nearby__item__img"&gt;
        &lt;div class="nearby__content"&gt;
          &lt;div class="nearby__content__title"&gt;{<!-- -->{item.name}}&lt;/div&gt;
          &lt;div class="nearby__content__tags"&gt;
            &lt;span class="nearby__content__tag"&gt;月售：{<!-- -->{item.sales}}&lt;/span&gt;
            &lt;span class="nearby__content__tag"&gt;起送：{<!-- -->{item.expressLimit}}&lt;/span&gt;
            &lt;span class="nearby__content__tag"&gt;基础运费：{<!-- -->{item.expressPrice}}&lt;/span&gt;
          &lt;/div&gt;
          &lt;p class="nearby__content__highlight"&gt;{<!-- -->{item.slogan}}&lt;/p&gt;
        &lt;/div&gt;
      &lt;/div&gt;
    &lt;/div&gt;
&lt;/template&gt;</code></pre> 
<p><strong><span style="color:#511b78;"><span style="background-color:#efedf6;"> 那么现在附近店铺显示的信息就是我们在后端返回过来的数据了：</span></span></strong></p> 
<p><img alt="" height="248" src="https://images2.imgbox.com/4b/c5/V4mjASJM_o.png" width="400"></p> 
<p><span style="background-color:#cbe0f1;">我们为了让代码的逻辑性与可读性更高，在 setup 外面再定义一个函数然后把 get 请求的相关代码都放进去，在 setup 中再把这个函数的返回值引入进来：</span></p> 
<pre><code class="language-javascript">const useNearbyList = () =&gt; {
  const nearbyList = ref([])
  const getNearbyList = async () =&gt; {
    const result = await get('/api/shop/hot-list')
    if (result.data.errno === 0) {
      nearbyList.value = result.data.data
    }
  }
  return { nearbyList, getNearbyList }
}

export default ({
  name: 'NearBy',
  setup () {
    const { nearbyList, getNearbyList } = useNearbyList()
    getNearbyList()
    return {
      nearbyList
    }
  }
})</code></pre> 
<p>这样我们的 setup 里只关心代码的实现逻辑而不需要关心内部的实现细节，这样代码的维护性和可读性就大大增强了。</p> 
<p></p> 
<h3 id="%E5%95%86%E5%AE%B6%E8%AF%A6%E6%83%85%E9%A1%B5%E9%9D%A2%E7%9A%84%E5%AE%9E%E7%8E%B0">商家详情页面的实现 💨 </h3> 
<h4 id="%E9%A1%B5%E9%9D%A2%E6%A0%B7%E5%BC%8F%E5%AE%9E%E7%8E%B0">页面样式实现</h4> 
<p>这是我们要实现的效果图：</p> 
<p><img alt="" height="656" src="https://images2.imgbox.com/df/4e/UsY67mGX_o.jpg" width="500"></p> 
<blockquote> 
 <p><span style="background-color:#fefcd8;">我们可以看到在顶部的内容和我们在附近店铺制作的内容是一样的，那我们就可以把附近店铺共用的部分做成一个组件，这样就可以在这块复用了。</span></p> 
</blockquote> 
<p><strong><span style="color:#1c7331;"><span style="background-color:#edf6e8;">首先我们先创建一个商家详情页面的路由，先进入 router 下的 index.js 配置路由信息：</span></span></strong></p> 
<pre><code class="language-javascript">  {
    path: '/shop',
    name: 'shop',
    component: () =&gt; import('../views/shop/ShopView')
  }</code></pre> 
<p><strong><span style="color:#1c7331;"><span style="background-color:#edf6e8;">然后在 views 下创建这个组件：</span></span></strong><br><img alt="" height="169" src="https://images2.imgbox.com/8d/a3/0cow4wpG_o.png" width="196"></p> 
<p><strong><span style="color:#1c7331;"><span style="background-color:#edf6e8;">下面我们就先把NearBy 里共用的部分摘离出来做成一个组件：</span></span></strong></p> 
<pre><code class="language-javascript">&lt;template&gt;
    &lt;div class="shop"&gt;
        &lt;img :src="item.imgUrl" alt="" class="shop__img"&gt;
        &lt;div class="shop__content"&gt;
          &lt;div class="shop__content__title"&gt;{<!-- -->{item.name}}&lt;/div&gt;
          &lt;div class="shop__content__tags"&gt;
            &lt;span class="shop__content__tag"&gt;月售：{<!-- -->{item.sales}}&lt;/span&gt;
            &lt;span class="shop__content__tag"&gt;起送：{<!-- -->{item.expressLimit}}&lt;/span&gt;
            &lt;span class="shop__content__tag"&gt;基础运费：{<!-- -->{item.expressPrice}}&lt;/span&gt;
          &lt;/div&gt;
          &lt;p class="shop__content__highlight"&gt;{<!-- -->{item.slogan}}&lt;/p&gt;
        &lt;/div&gt;
      &lt;/div&gt;
&lt;/template&gt;

&lt;script&gt;
export default {
  name: 'ShopInfo',
  props: ['item']
}

&lt;/script&gt;
&lt;style lang="scss" scoped&gt;
@import '../style/viriables.scss';
.shop {
    display: flex;
    padding-top: .12rem;
    &amp;__img {
      margin-right: .16rem;
      width: .56rem;
      height: .56rem;
    }
    &amp;__content {
    padding-bottom: .12rem;
    border-bottom: 1px solid $content-fontcolor;
        &amp;__title {
        line-height: .22rem;
        font-size: .16rem;
        color:$content-fontcolor ;
        }
        &amp;__tags {
        margin-top: .08rem;
        line-height: .18rem;
        font-size: .13rem;
        color:$content-fontcolor ;
        }
        &amp;__tag {
        margin-right: .16rem;
        }
        &amp;__highlight {
        margin: .08rem 0 0 0;
        line-height: .18rem;
        font-size: .13rem;
        color: #E93B3B;
        }
  }
}
&lt;/style&gt;</code></pre> 
<blockquote> 
 <p><span style="background-color:#fefcd8;">我们把共用的模板和样式从 nearby 中抽离出来，并且修改相应的类名，因为我们在这个组件中需要用到 item ，我们需要从nearby组件中把它传过来，我们先在 Nearby 中引入子组件然后在视图模板中使用，并且把 item 传递给子组件：</span></p> 
</blockquote> 
<pre><code class="language-javascript">&lt;template&gt;
    &lt;div class="nearby"&gt;
      &lt;h3 class="nearby__title"&gt;附近店铺&lt;/h3&gt;
      &lt;shop-info v-for="item in nearbyList" :key="item._id" :item="item"/&gt;
    &lt;/div&gt;
&lt;/template&gt;</code></pre> 
<p>这样我们就成功创建了一个可复用的组件。</p> 
<p><strong><span style="color:#1c7331;"><span style="background-color:#edf6e8;">在商家详情页面中我们把这个组件引入进来，它的数据请求方式和 NearBy 中的一样，只不过接口是 /api/shop/:id，这里我们先请求沃尔玛商店的数据，所以写1就可以：</span></span></strong></p> 
<pre><code class="language-javascript">&lt;template&gt;
    &lt;div class="wrapper"&gt;
      &lt;shop-info :item="shopList" /&gt;
    &lt;/div&gt;
&lt;/template&gt;

&lt;script&gt;
import { ref } from 'vue'
import { get } from '../../utils/request'
import ShopInfo from '../../components/ShopInfo.vue'

const useShopList = () =&gt; {
  const shopList = ref({})
  const getShopList = async () =&gt; {
    const result = await get('/api/shop/1')
    if (result.data.errno === 0) {
      shopList.value = result.data.data
    }
  }
  return { shopList, getShopList }
}

export default {
  name: 'ShopView',
  components: { ShopInfo },
  setup () {
    const { shopList, getShopList } = useShopList()
    getShopList()
    return {
      shopList
    }
  }
}
&lt;/script&gt;

&lt;style lang="scss" scoped&gt;
.wrapper {
    padding: 0 .18rem;
}
&lt;/style&gt;</code></pre> 
<p><strong><span style="color:#1c7331;"><span style="background-color:#edf6e8;">现在商家详情页面就显示出我们想要的内容了：</span></span></strong><br><img alt="" height="285" src="https://images2.imgbox.com/34/f5/12qDZIPZ_o.png" width="450"></p> 
<blockquote> 
 <p>但是在我们的这个页面中，并没有下面的这个短线，也就是底边框，这个底边框样式是我们在做附近店铺的时候加的，所以我们也不能把他删掉，因为附近店铺中也需要，所以我们通过再设置一个属性来控制子组件中的样式，在子组件中边框样式那里多加一个类，当我们设置 --bordered 这个类为 false的时候就隐藏这个属性：</p> 
</blockquote> 
<p><img alt="" height="130" src="https://images2.imgbox.com/e3/cf/FjLrsO0U_o.png" width="556"></p> 
<p><strong><span style="color:#1c7331;"><span style="background-color:#edf6e8;">我们在 props 里再设置一个hideBorder属性来控制这个类 ：</span></span></strong></p> 
<p><img alt="" height="100" src="https://images2.imgbox.com/ce/ed/Jfdld8uv_o.png" width="335"></p> 
<p><strong><span style="color:#1c7331;"><span style="background-color:#edf6e8;">然后修改对应的视图模板里的语句：</span></span></strong></p> 
<pre><code class="language-html">&lt;div :class="{'shop__content': true, 'shop__content--bordered': hideBorder ? false: true}"&gt;</code></pre> 
<p>当 hideBorder 属性为true的时候，'shop__content--bordered'这个类就是 false，就不显示这个属性。我们在商家详情页面传递这个属性，设置他为 true：</p> 
<pre><code class="language-javascript">&lt;template&gt;
    &lt;div class="wrapper"&gt;
      &lt;shop-info :item="shopList" :hideBorder="true"/&gt;
    &lt;/div&gt;
&lt;/template&gt;</code></pre> 
<p><strong><span style="color:#1c7331;"><span style="background-color:#edf6e8;">启动项目，查看效果：</span></span></strong></p> 
<p><img alt="" height="240" src="https://images2.imgbox.com/00/06/sSICQbUY_o.png" width="450"></p> 
<p>现在我们的商家详情页面中就不显示下面的底边框了。</p> 
<p><strong><span style="color:#be191c;"><span style="background-color:#fef2f0;">下面我们实现在首页单击沃尔玛和山姆会员商店时的跳转效果：</span></span></strong></p> 
<pre><code class="language-javascript">&lt;template&gt;
    &lt;div class="nearby"&gt;
      &lt;h3 class="nearby__title"&gt;附近店铺&lt;/h3&gt;
      &lt;router-link to="/shop" v-for="item in nearbyList" :key="item._id"&gt;
         &lt;shop-info :item="item" /&gt;
      &lt;/router-link&gt;
    &lt;/div&gt;
&lt;/template&gt;</code></pre> 
<p>用 router-link 把它包裹起来，然后把循环指令放在 router-link 上就行。 </p> 
<blockquote> 
 <p><span style="background-color:#d4e9d5;">但是当我们在首页单击沃尔玛或者山姆会员商店的时候，他会跳转到商品详情页面，但是显然沃尔玛和山姆会员商店的显示数据不一样，我们怎么实现这个功能呢？</span></p> 
</blockquote> 
<p><strong><span style="color:#be191c;"><span style="background-color:#fef2f0;">在我们单击沃尔玛或山姆会员商店的时候，会把对应商店的 id 带到商品详情页面。所以下面我们就来修改路由路径：</span></span></strong></p> 
<pre><code class="language-javascript">{
    path: '/shop/:id',
    name: 'shop',
    component: () =&gt; import('../views/shop/ShopView')
}</code></pre> 
<p><strong><span style="color:#be191c;"><span style="background-color:#fef2f0;">修改 NearBy 中的 router-link 如下：</span></span></strong></p> 
<pre><code class="language-javascript">&lt;router-link :to="`/shop/${item._id}`" v-for="item in nearbyList" :key="item._id"&gt;
    &lt;shop-info :item="item" /&gt;
&lt;/router-link&gt;
</code></pre> 
<p><span style="background-color:#fefcd8;">现在当我们单击不同的商店时，商店对应的 id 就会被带到商品详情页面，详情页面就会根据不同的 id 来获取对应的数据。</span></p> 
<p><img alt="" height="436" src="https://images2.imgbox.com/1c/b6/0wnrbhIZ_o.png" width="647"></p> 
<p>当我们单击沃尔玛时，路径中的参数 id 是1。</p> 
<p>当我们单击山姆会员商店时，上面的id就是2了，这就达到我们想要的效果了：<br><img alt="" height="71" src="https://images2.imgbox.com/2a/c1/YcM5ZpOn_o.png" width="412"></p> 
<p><span style="color:#ed7976;">现在要解决的问题就是，我如何根据参数来获取对应的数据呢，现在我们不论点击哪个商店拿到的都是 id 为 1的数据。</span></p> 
<p>在路由里提供给我们了另一个方法来拿到路由中的参数，就是 useRoute。</p> 
<p><strong><span style="color:#be191c;"><span style="background-color:#fef2f0;">我们把它引入进来：</span></span></strong></p> 
<pre><code class="language-javascript">import { useRoute } from 'vue-router'</code></pre> 
<p><strong><span style="color:#be191c;"><span style="background-color:#fef2f0;">通过 route.params.id 我们就可以拿到路由参数中 id 的值：</span></span></strong></p> 
<p><img alt="" height="113" src="https://images2.imgbox.com/9f/8b/CP64bqfE_o.png" width="318"></p> 
<p><strong><span style="color:#be191c;"><span style="background-color:#fef2f0;">我们启动项目，当我们单击山姆会员商店时， 在控制台中查看输出：</span></span></strong></p> 
<p><img alt="" height="58" src="https://images2.imgbox.com/0d/a3/qVgGeB3V_o.png" width="163"></p> 
<p>这样我们就拿到了对应的 id 值</p> 
<p><strong><span style="color:#be191c;"><span style="background-color:#fef2f0;">那我们就修改 get 请求中的参数：</span></span></strong></p> 
<pre><code class="language-javascript">await get(`/api/shop/${route.params.id}`)</code></pre> 
<p><span style="background-color:#fefcd8;">这样当我们单击不同的商店时它返回的就是对应的数据了。由于本项目并不是真正的后端接口，所以每个商店返回的都是同样的数据，我们主要是学习这个过程，明白这个逻辑就行。</span></p> 
<p></p> 
<h4 id="%E9%A1%B5%E9%9D%A2%E9%98%B2%E6%8A%96">页面防抖</h4> 
<p><strong><span style="color:#b95514;"><span style="background-color:#fff5e6;">值得注意的一点是，当我们进入商家详情页面的时候还没有加载完成的图片会有一个空白的展示，</span></span></strong></p> 
<p><strong><span style="color:#b95514;"><span style="background-color:#fff5e6;">这样就显的很难看：</span></span></strong></p> 
<p><img alt="" height="383" src="https://images2.imgbox.com/db/4c/k3UxgUFI_o.gif" width="600"></p> 
<p><strong><span style="color:#b95514;"><span style="background-color:#fff5e6;">我们可以对代码进行一下优化，让元素在没有加载完成的时候不显示：</span></span></strong></p> 
<pre><code class="language-javascript">&lt;shop-info :item="shopList" :hideBorder="true" v-show="shopList.imgUrl"/&gt;</code></pre> 
<p><strong><span style="color:#b95514;"><span style="background-color:#fff5e6;">这段代码的意思就是在图片没有加载完成时，就让 display为 none ，这样就不会显示了，我们再看一下效果：</span></span></strong></p> 
<p><img alt="" height="383" src="https://images2.imgbox.com/e7/51/7hhBEM3K_o.gif" width="600"></p> 
<p>在我们详情页面的样式中，多次使用到了 #333 这个颜色，那我们就把他放到 viriables 里，作为变量使用它：</p> 
<p><img alt="" height="58" src="https://images2.imgbox.com/44/dc/fjlhwexJ_o.png" width="248"></p> 
<p><img alt="" height="272" src="https://images2.imgbox.com/46/97/8h5effqG_o.png" width="415"></p> 
<p></p> 
<h4 id="%E7%9C%81%E7%95%A5%E5%8F%B7%E8%A1%A8%E7%A4%BA%E5%A4%9A%E4%BD%99%E5%86%85%E5%AE%B9">省略号表示多余内容</h4> 
<p>还有一个值得注意的点是，如果番茄250g/份这里字数很多的话，他就会向下换行输出，像这样：</p> 
<p><img alt="" height="416" src="https://images2.imgbox.com/37/08/O0F5cPZU_o.png" width="528"></p> 
<p>这样的话就会影响到下面的商品的布局，我们希望它不换行，多出的部分用省略号表示。</p> 
<p><strong><span style="color:#1a439c;"><span style="background-color:#eaf4fc;">用这三行代码就能实现这个功能：</span></span></strong></p> 
<pre><code class="language-css">overflow: hidden;
white-space: nowrap;
text-overflow: ellipsis;</code></pre> 
<p></p> 
<p><strong><span style="color:#ed7976;">现在我们要实现点击左侧不同的分类，右侧展示不同的样式，这里的数据我们要通过向模拟的后端接口发送请求来实现，我们看一下接口文档，找到对应的接口地址：</span></strong></p> 
<p><img alt="" height="1200" src="https://images2.imgbox.com/4a/8e/7LuZF53q_o.jpg" width="1200"></p> 
<p><strong><span style="color:#1a439c;"><span style="background-color:#eaf4fc;">我们点开它，看看接口的详细信息：</span></span></strong></p> 
<p><img alt="" height="1200" src="https://images2.imgbox.com/30/eb/RrZBBqUq_o.jpg" width="1200"></p> 
<blockquote> 
 <p><span style="background-color:#fefcd8;">接口的 url 格式最后还带一个参数，比如我们点击的是全部商品，传递过去的 tab 值就是 all，点击秒杀传递的 tab 值就是 seckill，点击水果，传递的 tab 值就是 fruit，后端根据返回的这个参数来给我们对应的数据。</span> </p> 
</blockquote> 
<p><strong><span style="color:#1a439c;"><span style="background-color:#eaf4fc;">这里我们对这个接口发送 get 请求，看看返回的结果：</span></span></strong></p> 
<pre><code class="language-javascript">  setup () {
    const getContentData = async () =&gt; {
      const result = await get('/api/shop/1/products', {
        tab: 'all'
      })
      console.log(result)
    }
    getContentData()
    return {
    }
  }</code></pre> 
<p><strong><span style="color:#1a439c;"><span style="background-color:#eaf4fc;">启动项目，查看控制台输出：</span></span></strong><br><img alt="" height="269" src="https://images2.imgbox.com/55/37/6VHFGdUh_o.png" width="739"></p> 
<p>现在我们商品详情页需要的数据就被成功获取到了，下面我们来完善我们的逻辑，现在我们要实现的是把请求的数据展示在页面上替换我们之前写死的数据。</p> 
<p><strong><span style="color:#1a439c;"><span style="background-color:#eaf4fc;">这是我们之前在页面中展示的数据：</span></span></strong></p> 
<p><img alt="" height="187" src="https://images2.imgbox.com/58/90/yxxQnpkl_o.png" width="1032"></p> 
<p><strong><span style="color:#1a439c;"><span style="background-color:#eaf4fc;">现在我们根据接口文档的参数来添加插值表达式：</span></span></strong></p> 
<p><img alt="" height="977" src="https://images2.imgbox.com/33/c7/qKcL4ob3_o.jpg" width="1200"></p> 
<p><strong><span style="color:#1a439c;"><span style="background-color:#eaf4fc;">我们设置一个对象来接收所有数据，并且判断如果数据没有错误，就把请求回来的数据赋给对象：</span></span></strong></p> 
<pre><code class="language-javascript">setup () {
    const contentList = ref({})
    const getContentData = async () =&gt; {
      const result = await get('/api/shop/1/products', {
        tab: 'all'
      })
      if (result.data.errno === 0) {
        contentList.value = result.data.data
      }
    }
    getContentData()
    return {
      contentList
    }
  }</code></pre> 
<p><strong><span style="color:#1a439c;"><span style="background-color:#eaf4fc;">然后我们在视图模板中循环商品数据，根据返回数据的数据结构来写插值表达式：</span></span></strong></p> 
<pre><code class="language-javascript">&lt;div class="product__item" v-for="item in contentList" :key="item._id"&gt;
      &lt;img class="product__item__img" src="http://www.dell-lee.com/imgs/vue3/near.png" alt=""&gt;
      &lt;div class="product__item__detail"&gt;
            &lt;h4 class="product__item__title"&gt;{<!-- -->{item.name}}&lt;/h4&gt;
            &lt;p class="product__item__sales"&gt;月售 {<!-- -->{item.sales}} 件&lt;/p&gt;
            &lt;p class="product__item__price"&gt;
                  &lt;span class="product__item__yen"&gt;&amp;yen;&lt;/span&gt;{<!-- -->{item.price}}
                  &lt;span class="product__item__origin"&gt;&amp;yen;{<!-- -->{item.oldPrice}}&lt;/span&gt;
            &lt;/p&gt;
      &lt;/div&gt;
      &lt;div class="product__number"&gt;
            &lt;span class="product__number__minus"&gt;-&lt;/span&gt;
            0
            &lt;span class="product__number__plus"&gt;+&lt;/span&gt;
      &lt;/div&gt;
&lt;/div&gt;</code></pre> 
<p><strong><span style="color:#1a439c;"><span style="background-color:#eaf4fc;">启动项目，查看效果：</span></span></strong><br><img alt="" height="685" src="https://images2.imgbox.com/53/0f/lTLTrRu6_o.png" width="500"></p> 
<p>现在我们所看到的数据都是通过后端接口返回来的了，这里图片后面会改先这么做。</p> 
<p><strong><span style="color:#ed7976;">现在我们要实现的就是单击左侧不同的选项，能够请求不同的数据，所以我们应该把 tab 值作为参数发送给接口，因为我们刚加载这个页面的时候默认就是请求全部商品，所以我们这么修改代码：</span></strong></p> 
<pre><code class="language-javascript">const getContentData = async (tab) =&gt; {
      const result = await get('/api/shop/1/products', { tab })
      if (result.data.errno === 0) {
        contentList.value = result.data.data
      }
    }
    getContentData('all')</code></pre> 
<p>当单击秒杀或新鲜水果的时候，会传递不同的 tab 值，所以我们应该给他们都绑定不同的事件。</p> 
<p>因为我们需要给左侧每一个选项都绑定点击事件，那就把左侧的数据都放到数组中，通过 v-for 循环来展示数据并绑定事件。</p> 
<p><strong><span style="color:#511b78;"><span style="background-color:#efedf6;">我们定义一个 categories 对象数组来存储信息：</span></span></strong></p> 
<pre><code class="language-javascript">const categories = [
      {
        name: '全部商品',
        tab: 'all'
      },
      {
        name: '秒杀',
        tab: 'seckill'
      },
      {
        name: '新鲜水果',
        tab: 'fruit'
      }
    ]</code></pre> 
<p><strong><span style="color:#511b78;"><span style="background-color:#efedf6;">通过v-for 循环来绑定数据和事件：</span></span></strong> </p> 
<pre><code class="language-javascript"> &lt;div class="category__item" v-for="item in categories" :key="item.name" @click="handleCategoryClick(item)"&gt;{<!-- -->{item.name}}&lt;/div&gt;</code></pre> 
<p><strong><span style="color:#511b78;"><span style="background-color:#efedf6;">我们定义一个一个点击事件，然后输出点击的每个选项的 tab 值：</span></span></strong></p> 
<pre><code class="language-javascript">const handleCategoryClick = (item) =&gt; {
      console.log(item.tab)
    }</code></pre> 
<p><strong><span style="color:#511b78;"><span style="background-color:#efedf6;">启动项目，分别点击全部商品，秒杀和新鲜水果，可以看到控制台中顺序输出了对应的 tab 值：</span></span></strong></p> 
<p><img alt="" height="436" src="https://images2.imgbox.com/82/99/3bGy0A4O_o.png" width="1200"></p> 
<p><strong><span style="color:#511b78;"><span style="background-color:#efedf6;">那现在我们只需要在每个点击事件中调用 getContentData  方法就行：</span></span></strong></p> 
<pre><code class="language-javascript">    const handleCategoryClick = (item) =&gt; {
      getContentData(item.tab)
    }</code></pre> 
<p>这样当我们点击左侧不同选项时，获取的就是对应的数据了。</p> 
<p><strong><span style="color:#ed7976;">我们点击控制台的网络，查看请求内容，当我们分别点击全部商品，秒杀和新鲜水果时，发送的都是对应的 tab 值：</span></strong><br><img alt="" height="125" src="https://images2.imgbox.com/96/13/HAaQwuIM_o.png" width="979"></p> 
<blockquote> 
 <p>有的小伙伴在运行项目时发现数据并没有变化，是因为我们这里用的是 mock 平台，实际上并不是真实的数据，是模拟后端写死的数据，我们只是为了接口跑通，也就是说我们整套逻辑是一点问题没有的，只不过并不是真实后端，而是我们模拟的后端。</p> 
</blockquote> 
<p><span style="background-color:#fefcd8;">现在还有一个问题就是我们在 v-for 循环生成左侧的数据时，全部商品那里的背景应该是白色的，之前我们给了他一个类名，因为在 v-for 循环中加这个类名就会让所有选项背景都变成白色，所以我们给他删掉了，那现在我们怎么再把它加上呢？</span></p> 
<p><strong><span style="color:#511b78;"><span style="background-color:#efedf6;">通过动态绑定类名实现：</span></span></strong></p> 
<pre><code class="language-javascript">&lt;div :class="{'category__item':true, 'category__item--active': currentTab === item.tab}" v-for="item in categories" :key="item.name" @click="handleCategoryClick(item)"&gt;{<!-- -->{item.name}}&lt;/div&gt;</code></pre> 
<p>我们定义一个 currentTab 属性，在setup中设置他的值为 all，当循环的 tab 值是 all 时，就添加这个类名，这样我们这个效果就实现了。</p> 
<p><strong><span style="color:#511b78;"><span style="background-color:#efedf6;">我们把图片的 src 地址也和接口返回的图片地址绑定一下，这样就能生成不同的图片了：</span></span></strong></p> 
<p><img alt="" height="61" src="https://images2.imgbox.com/eb/d6/YtlenRNb_o.png" width="602"></p> 
<p><strong><span style="color:#511b78;"><span style="background-color:#efedf6;">启动项目，查看效果：</span></span></strong></p> 
<p><img alt="" height="801" src="https://images2.imgbox.com/60/2f/ef4pSXay_o.png" width="692"></p> 
<p></p> 
<h4 id="%E9%80%9A%E8%BF%87%20watchEffect%20%E5%B7%A7%E5%A6%99%E7%9A%84%E8%BF%9B%E8%A1%8C%E4%BB%A3%E7%A0%81%E6%8B%86%E5%88%86">通过 watchEffect 巧妙的进行代码拆分</h4> 
<p><strong><span style="color:#ed7976;">现在我们要尽量把 setup 中逻辑相同的代码进行拆分，让我们的代码具备更强的逻辑性和可维护性。</span></strong></p> 
<p>在上一节中我们通过绑定样式来实现全部商品背景颜色的变化，但是这里是有错误的，我们想实现的效果是点击哪个选项哪个选项的背景都会变色。我们把关于 tab 实现逻辑的代码都拆分出来，搬到 setup 的外面：</p> 
<pre><code class="language-javascript">const useTabEffect = () =&gt; {
  const currentTab = ref(categories[0].tab)
  const handleTabClick = (item) =&gt; {
    currentTab.value = item.tab
  }
  return { currentTab, handleTabClick }
}</code></pre> 
<p>因为我们默认跳转到商品详情页面时，全部商品的背景色是白色，所以这里先定义 currentTab 为商品信息数组的第一个元素的 tab 值。然后我们把原来的 handleCategiryClick 改为 handleTabClick，把视图模板里的点击事件函数名也改成这个，因为我们这个函数里只关心 tab 逻辑的实现，所以函数名要一致。当点击左侧选项的时候就把这个选项的 tab 值赋给 currentTab的value值，然后我们再把数据和函数 return 出去，这样在 setup 里就能接收到了：</p> 
<pre><code class="language-javascript">const { currentTab, handleTabClick } = useTabEffect()</code></pre> 
<p><strong><span style="color:#511b78;"><span style="background-color:#efedf6;">现在我们把通过 get 请求获取数据的相关代码从 setup 里抽离出来，在外面定义一个新的函数：</span></span></strong></p> 
<pre><code class="language-javascript">const getContentEffect = (currentTab) =&gt; {
  const route = useRoute()
  const shopId = route.params.id
  const contentList = ref({})
  const getContentData = async () =&gt; {
    const result = await get(`/api/shop/${shopId}/products`, { tab: currentTab.value })
    if (result.data.errno === 0) {
      contentList.value = result.data.data
    }
  }
  // getContentData('all')
  watchEffect(() =&gt; {
    getContentData(currentTab)
  })
  return { route, contentList, getContentData, shopId }
}</code></pre> 
<blockquote> 
 <p><span style="background-color:#fefcd8;">在这里我们把 currentTab 作为参数传了进来，我们这里通过 watchEffect 来监听 getContentEffect 这个方法，在 watchEffect 中会立即执行传入一个函数，同时响应式追踪其依赖，并在其依赖变更时重新运行该函数。也就是说如果 currentTab 变了那么 getContentEffect 就会重新执行来获取数据，这不就是我们想要的么，这样整个代码的了逻辑性就非常强了，我们最后通过 return 把数据和函数 return 出来，在 setup 中调用。</span></p> 
</blockquote> 
<p><strong><span style="color:#511b78;"><span style="background-color:#efedf6;">我们看一下 setup 目前的代码：</span></span></strong></p> 
<pre><code class="language-javascript">setup () {
    const { currentTab, handleTabClick } = useTabEffect()
    const { route, contentList, getContentData, shopId } = getContentEffect(currentTab)
    return {
      contentList,
      categories,
      handleTabClick,
      currentTab,
      getContentData,
      route,
      shopId 
    }
  }</code></pre> 
<p>是不是非常简洁，比原来写的优雅多了，先在这个组件的可维护性就大大加强了。</p> 
<h4></h4> 
<h3 id="%E5%BA%95%E9%83%A8%E8%B4%AD%E7%89%A9%E8%BD%A6%E6%A0%B7%E5%BC%8F%E5%BC%80%E5%8F%91">底部购物车样式开发 💨 </h3> 
<p><strong><span style="color:#1c7892;"><span style="background-color:#e7fafa;">在 shop 目录中新建一个 CartFooter 组件来编写底部购物车：</span></span></strong></p> 
<p><img alt="" height="122" src="https://images2.imgbox.com/af/c2/nySh67z1_o.png" width="187"></p> 
<p><span style="color:#1c7892;"><span style="background-color:#eaf4fc;">我们在 ShopView 页面中引入这个子组件：</span></span></p> 
<pre><code class="language-javascript">import CartFooter from './CartFooter.vue'</code></pre> 
<pre><code class="language-javascript">  components: { ShopInfo, ContentShop, CartFooter }</code></pre> 
<p><strong><span style="color:#1c7892;"><span style="background-color:#e7fafa;">在视图模板中用这个子组件：</span></span></strong></p> 
<p><img alt="" height="110" src="https://images2.imgbox.com/85/db/KztzpZwP_o.png" width="289"></p> 
<p><strong><span style="color:#1c7892;"><span style="background-color:#e7fafa;">我们先给 CartFooter 一个简单的样式：</span></span></strong></p> 
<pre><code class="language-javascript">&lt;template&gt;
  &lt;div class="cart"&gt;cart&lt;/div&gt;
&lt;/template&gt;

&lt;script&gt;
export default {
}
&lt;/script&gt;

&lt;style lang="scss" scoped&gt;
.cart {
  position: absolute;
  left: 0;
  right: 0;
  bottom: 0;
  height: .5rem;
  background-color: pink;
}
&lt;/style&gt;
</code></pre> 
<p><strong><span style="color:#1c7892;"><span style="background-color:#e7fafa;">启动项目，看看输出的效果：</span></span></strong></p> 
<p><img alt="" height="732" src="https://images2.imgbox.com/df/32/IOeoyhlF_o.png" width="500"></p> 
<p>现在底部样式就能展示出来了，接下来我们对底部的内容做一个实现</p> 
<p><strong><span style="color:#1c7892;"><span style="background-color:#e7fafa;">先在视图中完成基本的 dom 结构：</span></span></strong></p> 
<pre><code class="language-javascript">&lt;template&gt;
  &lt;div class="cart"&gt;
    &lt;div class="check"&gt;
      &lt;div class="check__icon"&gt;
        &lt;img src="http://www.dell-lee.com/imgs/vue3/basket.png" alt="" class="check__icon__img"&gt;
        &lt;div class="check__icon__tag"&gt;1&lt;/div&gt;
      &lt;/div&gt;
      &lt;div class="check__info"&gt;
        总计：&lt;span class="check__info__price"&gt;&amp;yen;128&lt;/span&gt;
      &lt;/div&gt;
      &lt;div class="check__btn"&gt;去结算&lt;/div&gt;
    &lt;/div&gt;
  &lt;/div&gt;
&lt;/template&gt;</code></pre> 
<p><strong><span style="color:#1c7892;"><span style="background-color:#e7fafa;">然后编写底部的样式：</span></span></strong></p> 
<pre><code class="language-css">.cart {
  position: absolute;
  left: 0;
  right: 0;
  bottom: 0;
}
.check {
  display: flex;
  height: .49rem;
  border-top: .01rem solid #F1F1F1;
  &amp;__icon {
    position: relative;
    width: .84rem;
    &amp;__img {
      display: block;
      margin: .12rem auto;
      width: .28rem;
      height: .26rem;
    }
    &amp;__tag {
      position: absolute;
      right: .2rem;
      top: .04rem;
      color: #fff;
      width: .2rem;
      height: .2rem;
      transform: scale(.5);
      background-color: #E93B3B;
      border-radius: 50%;
      font-size: .12rem;
      text-align: center;
      line-height: .2rem;
    }
  }
  &amp;__info {
    flex: 1;
    margin: auto 0;
    color: #333;
    font-size: .12rem;
    &amp;__price {
      color: #E93B3B;
      font-size: .18rem;
    }
  }
  &amp;__btn {
    width: .98rem;
    line-height: .49rem;
    text-align: center;
    color: #fff;
    font-size: .14rem;
    background-color: #4FB0F9;
  }
}</code></pre> 
<p><strong><span style="color:#1c7892;"><span style="background-color:#e7fafa;">现在我们底部的样式开发就完成了，启动项目，查看一下效果：</span></span></strong></p> 
<p><img alt="" height="766" src="https://images2.imgbox.com/c0/63/NAcF8137_o.png" width="500"></p> 
<p> </p> 
<h3 id="%E8%B4%AD%E7%89%A9%E8%BD%A6%E6%95%B0%E6%8D%AE%E8%81%94%E5%8A%A8">购物车数据联动 💨 </h3> 
<h4 id="%E5%90%8C%E6%AD%A5%E6%94%B9%E5%8F%98%E9%80%89%E4%B8%AD%E6%95%B0%E5%AD%97%E4%B8%8E%E9%87%91%E9%A2%9D">同步改变选中数字与金额</h4> 
<p>下面我们就开始实现功能，先从购物车开始，当单击商品的加减号时，对应的选中数字和总计金额会相应改变。 </p> 
<blockquote> 
 <p><span style="background-color:#fefcd8;">因为我们购物车的数据不仅在当前这个页面需要用到，在购物车，结算商品等其他页面都需要用到这些数据，所以我们应该把这些数据放在全局进行管理。这就需要  vuex 了。</span></p> 
</blockquote> 
<p><strong><span style="color:#be191c;"><span style="background-color:#fef2f0;">在 state 仓库里我们存储购物车的数据，下面我们来看一下数据存储的结构：</span></span></strong></p> 
<pre><code class="language-javascript"> state: {
    cartList: {
      // 第一层级是商铺的 id
      1: {
        // 第二层是商品内容及购物数量
        111: {
          _id: '1',
          name: '番茄250g/份',
          imgUrl: 'http://www.dell-lee.com/imgs/vue3/tomato.png',
          sales: 10,
          price: 33.6,
          oldPrice: 39.6,
          count: 2
        },
        222: {

        }
      },
      2: {

      }
    }
  }</code></pre> 
<blockquote> 
 <p>第一层指的是商铺的id，因为每个商铺的购物车数据肯定是分开的，不一样的，不可能我在A商铺买了东西，进入B商铺的时候购物车还有这个东西。第二层存储的是每个商铺的所有货物的信息，count指的就是购买的数量。</p> 
</blockquote> 
<p><strong><span style="color:#be191c;"><span style="background-color:#fef2f0;">现在我们回到 ContentShop 组件中，我们先实现点击加减号的时候能够把商品加到购物车里：</span></span></strong></p> 
<p><img alt="" height="102" src="https://images2.imgbox.com/33/f9/T3pbagFy_o.png" width="489"></p> 
<p>再点击加减号的时候要把商品存到购物车里去，我们把相关逻辑封装到一个方法里</p> 
<p><strong><span style="color:#be191c;"><span style="background-color:#fef2f0;">首先我们引入 vue-store：</span></span></strong></p> 
<pre><code class="language-javascript">import { useStore } from 'vuex'</code></pre> 
<p><strong><span style="color:#be191c;"><span style="background-color:#fef2f0;">定义一个 useCartEffect 函数来获取仓库里的购物车数据：</span></span></strong></p> 
<pre><code class="language-javascript">const useCartEffect = () =&gt; {
  const store = useStore()
  const cartList = store.state.cartList
  return { cartList }
}</code></pre> 
<p><strong><span style="color:#be191c;"><span style="background-color:#fef2f0;">在 setup 中使用这个方法：</span></span></strong></p> 
<pre><code class="language-javascript">const { cartList } = useCartEffect()</code></pre> 
<p><img alt="" height="86" src="https://images2.imgbox.com/79/ca/KhTgpO4u_o.png" width="168"></p> 
<p>当我们点击加减号时，里面的数字是什么呢？</p> 
<p><strong><span style="color:#ed7976;">这里改变的就是对应商铺的对应商品的 count 值 </span></strong></p> 
<pre><code class="language-javascript">{<!-- -->{cartList?.[shopId]?.[item._id]?.count || 0}}</code></pre> 
<p>这里先看看 state 里对应商品有没有 count 信息，如果没有的话就存储0</p> 
<p><strong><span style="color:#be191c;"><span style="background-color:#fef2f0;">因为点击加减号时我们会把对应的信息存储到仓库中，那么就需要加上点击事件了：</span></span></strong></p> 
<pre><code class="language-javascript">&lt;span class="product__number__plus" @click="()=&gt;{addItemToCart(shopId, item._id, item)}"&gt;+&lt;/span&gt;</code></pre> 
<p><strong><span style="color:#be191c;"><span style="background-color:#fef2f0;">在 useCartEffect 函数中定义这个方法，我们先做一个简单的输出：</span></span></strong></p> 
<pre><code class="language-javascript">const useCartEffect = () =&gt; {
  const store = useStore()
  const cartList = store.state.cartList
  const addItemToCart = (shopId, productId, productInfo) =&gt; {
    console.log(shopId, productId, productInfo)
  }
  return { cartList, addItemToCart }
}</code></pre> 
<p><strong><span style="color:#be191c;"><span style="background-color:#fef2f0;">当我们进入沃尔玛店铺，先在全部商品里点击番茄那里的加号，再去秒杀这块点击车厘子那里的加号，看看控制台的输出：</span></span></strong></p> 
<p><img alt="" height="222" src="https://images2.imgbox.com/17/4b/2DQ3zzL6_o.png" width="1183"></p> 
<p>这里第一个 1 就是代表商铺，第二个数字表示选择的左侧栏的内容，然后输出的就是选择的商品信息</p> 
<p><strong><span style="color:#be191c;"><span style="background-color:#fef2f0;">通过 store.commit 同步修改 store 中的数据：</span></span></strong></p> 
<pre><code class="language-javascript">const addItemToCart = (shopId, productId, productInfo) =&gt; {
    store.commit('addItemToCart', {
      shopId, productId, productInfo
    })
  }</code></pre> 
<p><strong><span style="color:#be191c;"><span style="background-color:#fef2f0;">然后在 stroe 的 mutations 中接收这个方法</span></span></strong>：</p> 
<pre><code class="language-javascript">  mutations: {
    addItemToCart (state, payload) {
      const { shopId, productId, productInfo } = payload
      console.log(shopId, productId, productInfo)
    }
  }</code></pre> 
<p><strong><span style="color:#be191c;"><span style="background-color:#fef2f0;">启动项目，进入沃尔玛店铺，点击新鲜水果下的帝王蟹，看看控制台输出结果：</span></span></strong></p> 
<p><img alt="" height="120" src="https://images2.imgbox.com/a8/aa/WVQSY0zX_o.png" width="1163"></p> 
<p><strong><span style="color:#be191c;"><span style="background-color:#fef2f0;">控制台能够正常输出，那我们就可以重新编写里面的逻辑了：</span></span></strong></p> 
<pre><code class="language-javascript">addItemToCart (state, payload) {
      const { shopId, productId, productInfo } = payload
      let shopInfo = state.cartList[shopId]
      if (!shopInfo) {
        shopInfo = {}
      }
      let product = shopInfo[productId]
      if (!product) {
        product = productInfo
        product.count = 0
      }
      product.count += 1
      shopInfo[productId] = product
      state.cartList[shopId] = shopInfo
    }</code></pre> 
<blockquote> 
 <p><span style="background-color:#fefcd8;">现在我们的 cartList 就是一个对象，里面没有存储任何信息，因为只有用户在购物车里进行操作了，才会有数据的存储或改变。当用户点击加号时，先判断 cartList 里有没有存储商铺的信息，没有的话就存储一个空对象，再判断商铺里面有没有选择的商品的信息，没有的话就把传过来的 prodectInfo 进行赋值，再添加一个 count 属性用来统计数量。因为我们现在是增加的操作，所以最后一定得让数量加一，最后再把改变后的数据存储在 state 中。</span></p> 
</blockquote> 
<p><strong><span style="color:#1c7331;"><span style="background-color:#edf6e8;">启动项目，进入沃尔玛店铺点击商品信息的加号：</span></span></strong></p> 
<p><img alt="" height="561" src="https://images2.imgbox.com/59/5b/hvgt845O_o.png" width="313"></p> 
<p><strong><span style="color:#1c7331;"><span style="background-color:#edf6e8;">我们再返回山姆会员商店，看看对于另一个店铺有没有影响：</span></span></strong><br><img alt="" height="583" src="https://images2.imgbox.com/9f/7e/UeMXivQz_o.png" width="307"></p> 
<p>山姆会员商店里面的购物车数据都是0，这样我们想要的效果就实现了 </p> 
<p><span style="background-color:#fefcd8;">我们给加号做完点击事件后，如果用同样的方法实现减号的功能显然可以，但是这样会非常冗余，我们就会写了很多重复的代码，下面我们对之前定义的函数做一下修改。</span></p> 
<p><strong><span style="color:#1c7331;"><span style="background-color:#edf6e8;">我们传进去一个数字，减号就是 -1，加号就是 1，这样就能区分开来了：</span></span></strong></p> 
<pre><code class="language-javascript">&lt;span class="product__number__minus" @click="()=&gt;{changeItemToCart(shopId, item._id, item, -1)}"&gt;-&lt;/span&gt;
{<!-- -->{cartList?.[shopId]?.[item._id]?.count || 0}}
&lt;span class="product__number__plus" @click="()=&gt;{changeItemToCart(shopId, item._id, item, 1)}"&gt;+&lt;/span&gt;</code></pre> 
<p><strong><span style="color:#1c7331;"><span style="background-color:#edf6e8;">修改对应代码中的内容：</span></span></strong></p> 
<pre><code class="language-javascript">const useCartEffect = () =&gt; {
  const store = useStore()
  const cartList = store.state.cartList
  const changeItemToCart = (shopId, productId, productInfo, num) =&gt; {
    store.commit('changeItemToCart', {
      shopId, productId, productInfo, num
    })
  }
  return { cartList, changeItemToCart }
}</code></pre> 
<p><strong><span style="color:#1c7331;"><span style="background-color:#edf6e8;">修改 mutations 里的函数：</span></span></strong></p> 
<pre><code class="language-javascript">changeItemToCart (state, payload) {
      const { shopId, productId, productInfo, num } = payload
      let shopInfo = state.cartList[shopId]
      if (!shopInfo) {
        shopInfo = {}
      }
      let product = shopInfo[productId]
      if (!product) {
        product = productInfo
        product.count = 0
      }
      product.count = product.count + num
      if (product.count &lt; 0) { product.count = 0 }
      shopInfo[productId] = product
      state.cartList[shopId] = shopInfo
    }</code></pre> 
<p><strong>注意因为商品数量不能为负数，所以 count 小于零的时候再把它赋为0就行。</strong></p> 
<p>现在我们开始做购物车右上角的数字：<br><img alt="" height="63" src="https://images2.imgbox.com/88/ed/5f5D4QDW_o.png" width="95"></p> 
<p><strong><span style="color:#511b78;"><span style="background-color:#efedf6;">每当购物车里的内容改变时，这里的数字也会相应变化。对他的操作在 CartFooter 组件中实现。</span></span></strong>这里我们通过计算属性来实现这里数字的动态变化。</p> 
<p><img alt="" height="307" src="https://images2.imgbox.com/10/43/UiODdxhV_o.png" width="391"></p> 
<p><span style="background-color:#fefcd8;">这里并不难，就是获取 state 中对应店铺的数据，然后在 computed 中来个循环，循环商铺里的所有商品信息，把他们的 count 值加一起就行。</span></p> 
<p>现在对商品数目做增减时购物车上的数字也会动态变化了：<br><img alt="" height="509" src="https://images2.imgbox.com/79/bf/vjTjW401_o.png" width="292"></p> 
<p><img alt="" height="83" src="https://images2.imgbox.com/fb/49/U3Nn9xk4_o.png" width="110"></p> 
<p><strong><span style="color:#511b78;"><span style="background-color:#efedf6;">我们现在用相同的逻辑做底部金额总计的功能：</span></span></strong></p> 
<pre><code class="language-javascript">const price = computed(() =&gt; {
    let cartShop = cartCount[shopId]
    let pricesum = 0
    if (cartShop) {
      for (let i in cartShop) {
        const product = cartShop[i]
        pricesum += (product.price * product.count)
      }
    }
    return pricesum.toFixed(2)
  })</code></pre> 
<p>最后对金额用 toFiexed 方法是保留小数点后两位的意思。</p> 
<p><strong><span style="color:#511b78;"><span style="background-color:#efedf6;">我们启动项目，查看效果：</span></span></strong></p> 
<p><img alt="" height="383" src="https://images2.imgbox.com/bc/6e/Wz9va2NC_o.gif" width="600"></p> 
<p><strong><span style="color:#511b78;"><span style="background-color:#efedf6;">现在我们想要实现这种显示购物车内容的效果：</span></span></strong></p> 
<p><img alt="" height="382" src="https://images2.imgbox.com/ec/ac/z9yZiYm9_o.png" width="500"></p> 
<p>我们可以看到这块的样式和我们商品信息的样式一模一样，我们只需要把模板和样式 copy 到底部组件中就行</p> 
<p><strong><span style="color:#511b78;"><span style="background-color:#efedf6;">因为底部循环生成的数据是来自我们仓库中存储的数据，所以我们需要定义一个方法来获取商铺中商品信息的列表：</span></span></strong></p> 
<pre><code class="language-javascript">  const productList = computed(() =&gt; {
    let productList = cartCount[shopId] || []
    return productList
  })</code></pre> 
<p><strong><span style="color:#511b78;"><span style="background-color:#efedf6;">这样我们循环的时候循环这个列表就行了：</span></span></strong></p> 
<p><img alt="" height="68" src="https://images2.imgbox.com/f9/f7/dXvKpqqR_o.png" width="302"></p> 
<p><strong><span style="color:#511b78;"><span style="background-color:#efedf6;">这里我们只需要通过 item.count 就能实现单击上面商品的加减号，下面购物车里的数字也随着变化的效果：</span></span></strong></p> 
<p><img alt="" height="231" src="https://images2.imgbox.com/35/dc/4wXNIVWB_o.png" width="500"></p> 
<p><strong><span style="color:#511b78;"><span style="background-color:#efedf6;">可是现在我们点下面的加减号的时候上面不会跟着变，现在我们把这个反向逻辑也做一下：</span></span></strong></p> 
<pre><code class="language-javascript">&lt;span class="product__number__minus" @click="()=&gt;{changeItemToCart(item, -1)}"&gt;-&lt;/span&gt;
{<!-- -->{item.count || 0}}
&lt;span class="product__number__plus" @click="()=&gt;{changeItemToCart(item, 1)}"&gt;+&lt;/span&gt;</code></pre> 
<p><strong><span style="color:#511b78;"><span style="background-color:#efedf6;">在 setup 里定义这个点击事件：</span></span></strong></p> 
<pre><code class="language-javascript">    let changeItemToCart = (item, num) =&gt; {
      item.count += num
      if (item.count &lt; 0) { item.count = 0 }
    }</code></pre> 
<p>现在我们点击下面的加减号时上面也可以动态变化了。</p> 
<p>还有一个点就是如果我们给购物车中的数量减到0了，就取消这块内容的显示</p> 
<p><span style="background-color:#fefcd8;">有的同学可能会说在里面包一层 template ，通过 v-if 实现如果选择商品的数量等于0就不显示，但是这么做是有问题的，因为外面的盒子有一个 Padding 值，所以不显示的盒子也会有一块留白，像这样：</span></p> 
<p><img alt="" height="224" src="https://images2.imgbox.com/de/21/ggifXu2W_o.png" width="605"></p> 
<p><strong><span style="color:#ed7976;">所以正确的做法是应该 v-for 循环 template ，然后 v-if 的是 div 盒子，这样就不会有留白了。</span></strong> </p> 
<p></p> 
<h4 id="%E6%A0%B9%E6%8D%AE%E8%B4%AD%E7%89%A9%E8%BD%A6%E9%80%89%E4%B8%AD%E7%8A%B6%E6%80%81%E5%AE%9E%E7%8E%B0%E8%AE%A1%E7%AE%97%E9%87%91%E9%A2%9D">根据购物车选中状态实现计算金额</h4> 
<p><img alt="" height="246" src="https://images2.imgbox.com/68/fb/tHkCGjaP_o.png" width="500"></p> 
<p> <img alt="" height="244" src="https://images2.imgbox.com/2f/a8/JyePdpVn_o.png" width="500"></p> 
<blockquote> 
 <p>现在我们想在左边加上对勾的这个小图标，当我们往购物车里新增商品的时候默认是处于背景为蓝色的勾选状态，当处于非勾选状态时，改变商品的数额不会改变总计金额，只有商品是勾选状态我们才能统计金额 。</p> 
</blockquote> 
<p><span style="color:#ad720d;"><strong><span style="background-color:#fefcd8;">我们先在 mutations 的方法里添加条件，让点击加号的时候默认图标处于选定状态：</span></strong></span></p> 
<p><img alt="" height="79" src="https://images2.imgbox.com/9c/d3/roUNI0cE_o.png" width="438"></p> 
<p>这里我们的对勾图标通过 v-if 来控制显示与隐藏，changechecked是对勾的点击事件函数，，传入店铺id和商品id，实现当点击的时候让对勾的状态改变。 </p> 
<p><img alt="" height="109" src="https://images2.imgbox.com/fa/c3/i2whcwiJ_o.png" width="753"></p> 
<p><strong><span style="color:#ad720d;"><span style="background-color:#fefcd8;">我们定义这个点击事件：</span></span></strong></p> 
<pre><code class="language-javascript">  const changechecked = (shopId, productId) =&gt; {
    store.commit('changechecked', { shopId, productId })
  }</code></pre> 
<p><strong><span style="color:#ad720d;"><span style="background-color:#fefcd8;">现在我们看一下效果：</span></span></strong></p> 
<p><img alt="" height="383" src="https://images2.imgbox.com/16/c8/hOdvl26T_o.gif" width="600"></p> 
<h4></h4> 
<h4 id="%E6%B8%85%E7%A9%BA%E8%B4%AD%E7%89%A9%E8%BD%A6%E5%8A%9F%E8%83%BD">清空购物车功能</h4> 
<p><strong><span style="color:#1a439c;"><span style="background-color:#eaf4fc;">首先我们先写一下全选和清空购物车的样式：</span></span></strong><br><img alt="" height="396" src="https://images2.imgbox.com/0d/b2/DESkqDId_o.png" width="500"></p> 
<p><strong><span style="color:#1a439c;"><span style="background-color:#eaf4fc;">我们先完成清空购物车的功能，当单击清空购物车时可以把存储在 state 内的指定商家的数据都清空掉，我们先给它加个点击事件：</span></span></strong></p> 
<pre><code class="language-javascript">&lt;div class="product__header__clear" @click="clearAll(shopId)"&gt;清空购物车&lt;/div&gt;</code></pre> 
<p><strong><span style="color:#1a439c;"><span style="background-color:#eaf4fc;">然后在购物车逻辑函数中编写这个函数：</span></span></strong></p> 
<pre><code class="language-javascript">  const clearAll = (shopId) =&gt; {
    store.commit('clearAll', { shopId })
  }</code></pre> 
<p><strong><span style="color:#1a439c;"><span style="background-color:#eaf4fc;">我们在 store 里的 mutations 中接收这个方法，并实现函数的功能：</span></span></strong></p> 
<pre><code class="language-javascript">    clearAll (state, payload) {
      let shopInfo = state.cartList[payload.shopId]
      shopInfo = {}
      state.cartList[payload.shopId] = shopInfo
    }</code></pre> 
<p>我们只要把商家的商品信息赋给一个空对象就行。</p> 
<p><strong><span style="color:#1a439c;"><span style="background-color:#eaf4fc;">现在我们实现全选按钮功能，我们先看一下视图模板：</span></span></strong></p> 
<p><img alt="" height="138" src="https://images2.imgbox.com/d1/cc/1afsd833_o.png" width="598"></p> 
<blockquote> 
 <p><span style="background-color:#fefcd8;">当 ifAll 等于 true 时，就显示背景颜色为蓝色的按钮，等于 false 时就显示背景为白色的按钮代表没有全选状态。</span></p> 
</blockquote> 
<p><strong><span style="color:#1a439c;"><span style="background-color:#eaf4fc;">这里的 ifAll 我们通过计算属性实现，只要有商品没有被选择时，全选按钮就是非选择状态，只有当全部商品都被选择时，全选按钮才是选定状态：</span></span></strong></p> 
<pre><code class="language-javascript">const ifAll = computed(() =&gt; {
    let all = true
    let cartShop = cartCount[shopId]
    if (cartShop) {
      for (let i in cartShop) {
        const product = cartShop[i]
        if (product.count &gt; 0 &amp;&amp; product.check === false) {
          all = false
        }
      }
    }
    return all
  })</code></pre> 
<p><strong><span style="color:#1a439c;"><span style="background-color:#eaf4fc;">我们还想实现当点击全选按钮时，让商品信息中所有未被选择的商品都变成选定状态，定义一个点击事件：</span></span></strong></p> 
<pre><code class="language-javascript">  const changeAll = (shopId) =&gt; {
    store.commit('changeAll', { shopId })
  }</code></pre> 
<p><strong><span style="color:#1a439c;"><span style="background-color:#eaf4fc;">我们在 store 里的 mutations 中接收这个方法，并实现函数的功能：</span></span></strong></p> 
<pre><code class="language-javascript">changeAll (state, payload) {
      let shopInfo = state.cartList[payload.shopId]
      for (let i in shopInfo) {
        shopInfo[i].check = true
      }
    }</code></pre> 
<blockquote> 
 <p>现在我们想在点击购物车时才显示购物车里的内容，我们在 setup 里定义一个响应式数据通过 v-if 来控制购物车内容的显示，一开始让他为 false，再给购物车加个点击事件，每次点击都让状态取反，这样就实现了我们想要的效果。</p> 
</blockquote> 
<p><strong><span style="color:#1a439c;"><span style="background-color:#eaf4fc;">最后我们想在展示购物车中内容时，给盖住的部分加一个蒙层，当不显示购物车内容时蒙层就隐藏，类似这种效果：</span></span></strong></p> 
<p><img alt="" height="729" src="https://images2.imgbox.com/06/93/jg25ryfY_o.png" width="500"></p> 
<p><img alt="" height="767" src="https://images2.imgbox.com/18/5b/3swXrDw5_o.png" width="500"></p> 
<p><strong><span style="color:#1a439c;"><span style="background-color:#eaf4fc;">我们在最外层加个盒子：</span></span></strong></p> 
<p><img alt="" height="74" src="https://images2.imgbox.com/f2/0f/MAzOdoyp_o.png" width="434"></p> 
<p><strong><span style="color:#1a439c;"><span style="background-color:#eaf4fc;">再给 mask 一个样式：</span></span></strong></p> 
<pre><code class="language-css">.mask {
  position: fixed;
  left: 0;
  right: 0;
  top: 0;
  bottom: 0;
  z-index: 1;
  background: rgba(0,0,0,.5);
}</code></pre> 
<p>这样就能实现我们的效果了，蒙层的显示与隐藏和购物车的显示与隐藏都是通过一个数据控制的。</p> 
<p><span style="color:#ed7976;"><strong>还有一个问题就是当我们的购物车中没有商品时，现在还会勾选全选按钮和清空购物车这一栏，显然这是不应该显示的。</strong></span></p> 
<p><img alt="" height="440" src="https://images2.imgbox.com/e6/e9/iG1t8VS7_o.png" width="604"></p> 
<p><strong><span style="color:#1a439c;"><span style="background-color:#eaf4fc;">我们只需要把所有用到 showproduct 的地方再加个判断条件，让当 total 大于等于零的时候才能显示：</span></span></strong></p> 
<p><img alt="" height="97" src="https://images2.imgbox.com/3c/c9/aFC2h0mi_o.png" width="537"></p> 
<p>这样当购物车中没有商品时就不会显示清空购物车这一栏了。</p> 
<p></p> 
<h4 id="%E6%9C%AC%E5%9C%B0%E5%AD%98%E5%82%A8%E4%BF%9D%E5%AD%98%E8%B4%AD%E7%89%A9%E8%BD%A6%E6%95%B0%E6%8D%AE">本地存储保存购物车数据</h4> 
<p>最后每当页面刷新的时候，我们购物车中的数据都会丢失，我们用本地存储来让购物车的数据存在浏览器中，在 store 的index.js中定义本地存储的存储和获取函数：</p> 
<pre><code class="language-javascript">const setLocalStorage = (state) =&gt; {
  const { cartList } = state
  const cartListString = JSON.stringify(cartList)
  localStorage.cartList = cartListString
}
const getLocalStorage = () =&gt; {
  return JSON.parse(localStorage.cartList) || {}
}</code></pre> 
<p><strong><span style="color:#be191c;"><span style="background-color:#fef2f0;">这样 state 中carList的值就可以通过 getLocalStorage  直接获取：</span></span></strong></p> 
<pre><code class="language-javascript">  state: {
    cartList: getLocalStorage()
  }</code></pre> 
<blockquote> 
 <p><span style="background-color:#fefcd8;">并且每当我们对 carList 里的内容有修改时，都调用 setLocalStorage  函数来本地存储数据。这样我们在刷新页面的时候，数据还会存在就不会销毁了。</span></p> 
</blockquote> 
<p>这样我们的购物车的全部逻辑就都实现了，是不是也没有想象中的复杂呀</p> 
<p></p> 
<p><strong>项目源码地址：</strong></p> 
<p><a class="link-info has-card" href="https://gitee.com/jie_shao1112/jingdong-home" rel="nofollow" title="https://gitee.com/jie_shao1112/jingdong-home"><span class="link-card-box"><span class="link-title">https://gitee.com/jie_shao1112/jingdong-home</span><span class="link-link"><img class="link-link-icon" src="https://images2.imgbox.com/80/0b/rZNMtQWX_o.png" alt="icon-default.png?t=M666">https://gitee.com/jie_shao1112/jingdong-home</span></span></a></p> 
<p> </p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/6b01e49a9246eca832d8d53147db3d01/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">GDB 的简单用法</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/de17ff946f9c5db2644100385a285747/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">C#中await/async用法</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>