<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>JavaEE框架学习—Spring - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="JavaEE框架学习—Spring" />
<meta property="og:description" content="文章目录 一、Spring简介1.1 什么是Spring1.2 Spring的两个核心特性1.3 关键策略1.4 模块组成1.5 Spring 的优缺点1.6 Spring 框架涉及到的设计模式 二、IoC2.1 概念2.2 IoC的实现机制2.2 依赖注入(DI)2.3 依赖注入的实现1) setter 注入2) 构造方法注入3) 注解注入 2.4 控制反转(IoC)的作用2.5 控制反转(IoC)的优点2.6 IoC容器2.6.1 BeanFactory和ApplicationContext的区别1) 依赖关系2) 加载方式3) 创建方式4) 注册方式 2.6.2 BeanFactory和ApplicationContext的关系2.6.3 ApplicationContext 的实现 三、Spring Beans3.1 基本概念3.2 bean的作用域3.3 线程安全问题Spring框架中的单例bean是线程安全吗？Spring如何处理线程并发问题？ 3.4 bean的生命周期3.5 bean的装配3.5.1 bean的自动装配3.5.2 自动装配的方式3.5.3 使用@Autowired注解自动装配的过程3.5.4 自动装配的局限性 四、Spring注解4.1 基于Java的Spring注解配置4.2 @Component, @Controller, @Repository, @Service注解4.3 @Required 注解4.4 @Autowired 注解4.5 @Qualifier 注解4.6 @RequestMapping 注解 五、Spring数据访问5.1 对象/关系映射集成模块5.2 如何更有效地使用JDBC5.2.1 JDBC抽象和DAO模块 5.3 Spring访问Hibernate5.4 Spring事务5.4.1 Spring支持的事务管理类型（事务实现方式）5.4.2 Spring事务的实现方式和实现原理5.4.3 Spring的事务传播行为5.4.4 spring 的事务隔离5." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/c2ea7a1ed1a0c7848897f866880a7342/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2020-05-27T16:15:50+08:00" />
<meta property="article:modified_time" content="2020-05-27T16:15:50+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">JavaEE框架学习—Spring</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-light">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p></p> 
<div class="toc"> 
 <h4>文章目录</h4> 
 <ul><li><a href="#Spring_5" rel="nofollow">一、Spring简介</a></li><li><ul><li><a href="#11_Spring_6" rel="nofollow">1.1 什么是Spring</a></li><li><a href="#12_Spring_15" rel="nofollow">1.2 Spring的两个核心特性</a></li><li><a href="#13__22" rel="nofollow">1.3 关键策略</a></li><li><a href="#14__29" rel="nofollow">1.4 模块组成</a></li><li><a href="#15_Spring__45" rel="nofollow">1.5 Spring 的优缺点</a></li><li><a href="#16_Spring__70" rel="nofollow">1.6 Spring 框架涉及到的设计模式</a></li></ul> 
  </li><li><a href="#IoC_79" rel="nofollow">二、IoC</a></li><li><ul><li><a href="#21__80" rel="nofollow">2.1 概念</a></li><li><a href="#22_IoC_85" rel="nofollow">2.2 IoC的实现机制</a></li><li><a href="#22_DI_127" rel="nofollow">2.2 依赖注入(DI)</a></li><li><a href="#23__133" rel="nofollow">2.3 依赖注入的实现</a></li><li><ul><li><a href="#1_setter__142" rel="nofollow">1) setter 注入</a></li><li><a href="#2__169" rel="nofollow">2) 构造方法注入</a></li><li><a href="#3__189" rel="nofollow">3) 注解注入</a></li></ul> 
   </li><li><a href="#24_IoC_208" rel="nofollow">2.4 控制反转(IoC)的作用</a></li><li><a href="#25_IoC_213" rel="nofollow">2.5 控制反转(IoC)的优点</a></li><li><a href="#26_IoC_219" rel="nofollow">2.6 IoC容器</a></li><li><ul><li><a href="#261_BeanFactoryApplicationContext_223" rel="nofollow">2.6.1 BeanFactory和ApplicationContext的区别</a></li><li><ul><li><a href="#1__224" rel="nofollow">1) 依赖关系</a></li><li><a href="#2__233" rel="nofollow">2) 加载方式</a></li><li><a href="#3__238" rel="nofollow">3) 创建方式</a></li><li><a href="#4__241" rel="nofollow">4) 注册方式</a></li></ul> 
    </li><li><a href="#262_BeanFactoryApplicationContext_245" rel="nofollow">2.6.2 BeanFactory和ApplicationContext的关系</a></li><li><a href="#263_ApplicationContext__269" rel="nofollow">2.6.3 ApplicationContext 的实现</a></li></ul> 
  </li></ul> 
  </li><li><a href="#Spring_Beans_274" rel="nofollow">三、Spring Beans</a></li><li><ul><li><a href="#31__275" rel="nofollow">3.1 基本概念</a></li><li><a href="#32_bean_294" rel="nofollow">3.2 bean的作用域</a></li><li><a href="#33__306" rel="nofollow">3.3 线程安全问题</a></li><li><ul><li><a href="#Springbean_307" rel="nofollow">Spring框架中的单例bean是线程安全吗？</a></li><li><a href="#Spring_315" rel="nofollow">Spring如何处理线程并发问题？</a></li></ul> 
   </li><li><a href="#34_bean_322" rel="nofollow">3.4 bean的生命周期</a></li><li><a href="#35_bean_351" rel="nofollow">3.5 bean的装配</a></li><li><ul><li><a href="#351_bean_353" rel="nofollow">3.5.1 bean的自动装配</a></li><li><a href="#352__358" rel="nofollow">3.5.2 自动装配的方式</a></li><li><a href="#353_Autowired_368" rel="nofollow">3.5.3 使用@Autowired注解自动装配的过程</a></li><li><a href="#354__376" rel="nofollow">3.5.4 自动装配的局限性</a></li></ul> 
  </li></ul> 
  </li><li><a href="#Spring_382" rel="nofollow">四、Spring注解</a></li><li><ul><li><a href="#41_JavaSpring_383" rel="nofollow">4.1 基于Java的Spring注解配置</a></li><li><a href="#42_Component_Controller_Repository_Service_399" rel="nofollow">4.2 @Component, @Controller, @Repository, @Service注解</a></li><li><a href="#43_Required__407" rel="nofollow">4.3 @Required 注解</a></li><li><a href="#44_Autowired__421" rel="nofollow">4.4 @Autowired 注解</a></li><li><a href="#45_Qualifier__441" rel="nofollow">4.5 @Qualifier 注解</a></li><li><a href="#46_RequestMapping__444" rel="nofollow">4.6 @RequestMapping 注解</a></li></ul> 
  </li><li><a href="#Spring_450" rel="nofollow">五、Spring数据访问</a></li><li><ul><li><a href="#51__451" rel="nofollow">5.1 对象/关系映射集成模块</a></li><li><a href="#52_JDBC_454" rel="nofollow">5.2 如何更有效地使用JDBC</a></li><li><ul><li><a href="#521_JDBCDAO_457" rel="nofollow">5.2.1 JDBC抽象和DAO模块</a></li></ul> 
   </li><li><a href="#53_SpringHibernate_473" rel="nofollow">5.3 Spring访问Hibernate</a></li><li><a href="#54_Spring_484" rel="nofollow">5.4 Spring事务</a></li><li><ul><li><a href="#541_Spring_485" rel="nofollow">5.4.1 Spring支持的事务管理类型（事务实现方式）</a></li><li><a href="#542_Spring_490" rel="nofollow">5.4.2 Spring事务的实现方式和实现原理</a></li><li><a href="#543_Spring_494" rel="nofollow">5.4.3 Spring的事务传播行为</a></li><li><a href="#544_spring__506" rel="nofollow">5.4.4 spring 的事务隔离</a></li><li><a href="#545_Spring_520" rel="nofollow">5.4.5 Spring框架的事务管理的优点</a></li></ul> 
  </li></ul> 
  </li><li><a href="#AOP_531" rel="nofollow">六、AOP</a></li><li><ul><li><a href="#61_AOP_532" rel="nofollow">6.1 什么是AOP</a></li><li><a href="#62_AOP_536" rel="nofollow">6.2 AOP与代理模式</a></li><li><a href="#63_AOP_556" rel="nofollow">6.3 AOP相关概念</a></li><li><a href="#64_Spring_582" rel="nofollow">6.4 Spring通知的类型</a></li><li><a href="#65_Aspect_610" rel="nofollow">6.5 切面Aspect</a></li></ul> 
 </li></ul> 
</div> 
<br> 参考文章： 
<br> 
<a href="https://blog.csdn.net/ThinkWon/article/details/104397516">Spring面试题（2020最新版）</a> 
<br> 
<a href="https://blog.csdn.net/a745233700/article/details/80959716">Spring常见面试题总结（超详细回答）</a> 
<br> 
<a href="https://blog.csdn.net/zangdaiyang1991/article/details/90788013">Java Web框架篇之Spring</a> 
<p></p> 
<h2><a id="Spring_5"></a>一、Spring简介</h2> 
<h3><a id="11_Spring_6"></a>1.1 什么是Spring</h3> 
<blockquote> 
 <p>Spring是一个轻量级Java开发框架，最早有由Rod Johnson创建，目的是为了解决企业级应用开发的业务逻辑层和其他各层的耦合问题。<br> 它是一个分层的JavaSE/JavaEE full-stack（一站式）轻量级开源框架，为开发Java应用程序提供全面的基础架构支持。<br> Spring负责基础架构，因此Java开发者可以专注于应用程序的开发。</p> 
</blockquote> 
<blockquote> 
 <p>Spring最根本的使命是<strong>解决企业级应用开发的复杂性，即简化Java开发</strong>。</p> 
</blockquote> 
<blockquote> 
 <p>应用场景：JavaEE企业应用开发，包括SSH、SSM等</p> 
</blockquote> 
<h3><a id="12_Spring_15"></a>1.2 Spring的两个核心特性</h3> 
<ul><li>控制反转（Inversion of Control，Ioc）</li><li>面向切面编程（Aspect Oriented Programming，AOP）</li></ul> 
<p>  通过IoC容器管理POJO对象以及他们之间的耦合关系；通过AOP以动态非侵入的方式增强服务。<br>   IoC让相互协作的组件保持松散的耦合，而AOP编程允许你把遍布于应用各层的功能分离出来形成可重用的功能组件。</p> 
<h3><a id="13__22"></a>1.3 关键策略</h3> 
<p>为了降低Java开发的复杂性，Spring采取了以下4种关键策略：</p> 
<ul><li>基于POJO的轻量级和最小侵入性编程；</li><li>通过依赖注入和面向接口实现松耦合；</li><li>基于切面和惯例进行声明式编程；</li><li>通过切面和模板减少样板式代码。</li></ul> 
<h3><a id="14__29"></a>1.4 模块组成</h3> 
<p>  Spring 总共大约有 20 个组件， 由 1300 多个不同的文件构成。<br>   而这些组件被分别整合在 核心容器(Core Container)、AOP(Aspect Oriented Programming)、设备支持(Instrmentation)、数据访问与集成(Data Access/Integeration)、Web、消息(Messaging)、Test等顶层模块中。<br>   以下是 Spring 5 的模块结构图：<br> <img src="https://images2.imgbox.com/4f/7d/tBzSOBtd_o.png" alt="在这里插入图片描述" width="600"><br> 常用模块简介</p> 
<table><thead><tr><th align="left">模块</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left">spring core</td><td align="left">提供了框架的基本组成部分，包括控制反转（Inversion of Control，IOC）和依赖注入（Dependency Injection，DI）功能。</td></tr><tr><td align="left">spring beans</td><td align="left">提供了BeanFactory，是工厂模式的一个经典实现，Spring将管理对象称为Bean。</td></tr><tr><td align="left">spring context</td><td align="left">构建于 core 封装包基础上的 context 封装包，提供了一种框架式的对象访问方法。</td></tr><tr><td align="left">spring jdbc</td><td align="left">提供了一个JDBC的抽象层，消除了烦琐的JDBC编码和数据库厂商特有的错误代码解析， 用于简化JDBC。</td></tr><tr><td align="left">spring aop</td><td align="left">提供了面向切面的编程实现，让你可以自定义拦截器、切点等。</td></tr><tr><td align="left">spring Web</td><td align="left">提供了针对 Web 开发的集成特性，例如文件上传，利用 servlet listeners 进行 ioc 容器初始化和针对 Web 的 ApplicationContext。</td></tr><tr><td align="left">spring test</td><td align="left">主要为测试提供支持的，支持使用JUnit或TestNG对Spring组件进行单元测试和集成测试。</td></tr></tbody></table> 
<h3><a id="15_Spring__45"></a>1.5 Spring 的优缺点</h3> 
<p>1）优点</p> 
<blockquote> 
 <ul><li>Spring是非侵入式的框架，目标是使应用程序代码对框架依赖最小化；</li><li>Spring提供一个一致的编程模型，使应用直接使用POJO开发，与运行环境隔离开来；</li><li>Spring推动应用设计风格向面向对象和面向接口开发转变，提高了代码的重用性和可测试性；</li></ul> 
</blockquote> 
<p>更详细的优点：</p> 
<ul><li>方便解耦，简化开发<br> Spring就是一个大工厂，可以将所有对象的创建和依赖关系的维护，交给Spring管理。</li><li>AOP编程的支持<br> Spring提供面向切面编程，可以方便的实现对程序进行权限拦截、运行监控等功能。</li><li>声明式事务的支持<br> 只需要通过配置就可以完成对事务的管理，而无需手动编程。</li><li>方便程序的测试<br> Spring对Junit4支持，可以通过注解方便的测试Spring程序。</li><li>方便集成各种优秀框架<br> Spring不排斥各种优秀的开源框架，其内部提供了对各种优秀框架的直接支持（如：Struts、Hibernate、MyBatis等）。</li><li>降低JavaEE API的使用难度<br> Spring对JavaEE开发中非常难用的一些API（JDBC、JavaMail、远程调用等），都提供了封装，使这些API应用难度大大降低。</li></ul> 
<p>2）缺点</p> 
<blockquote> 
 <ul><li>Spring明明一个很轻量级的框架，却给人感觉大而全；</li><li>Spring依赖反射，反射影响性能；</li><li>使用门槛升高，入门Spring需要较长时间；</li></ul> 
</blockquote> 
<h3><a id="16_Spring__70"></a>1.6 Spring 框架涉及到的设计模式</h3> 
<ul><li>工厂模式：BeanFactory就是简单工厂模式的体现，用来创建对象的实例；</li><li>单例模式：Bean默认为单例模式。</li><li>代理模式：Spring的AOP功能用到了JDK的动态代理和CGLIB字节码生成技术；</li><li>模板方法：用来解决代码重复的问题。比如，RestTemplate, JmsTemplate, JpaTemplate。</li><li>观察者模式：定义对象键一种一对多的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都会得到通知被制动更新，如Spring中listener的实现——ApplicationListener。</li></ul> 
<p>  各种设计模式的介绍会在后续文章中专门介绍。</p> 
<h2><a id="IoC_79"></a>二、IoC</h2> 
<h3><a id="21__80"></a>2.1 概念</h3> 
<p>  控制反转即IoC (Inversion of Control)，它把传统上由程序代码直接操控的对象的调用权交给<strong>容器</strong>，通过容器来<strong>实现对象组件的装配和管理</strong>。所谓的“控制反转”概念就是对组件对象控制权的转移，从程序代码本身转移到了外部容器。<br>   最直观的表达就是，IoC让对象的创建不用去new了，可以由spring自动生产，使用java的<strong>反射</strong>机制，根据配置文件在运行时动态的去创建对象以及管理对象，并调用对象的方法的。<br>   这样就实现了可插拔式的接口编程，有效地<strong>降低代码的耦合度，降低了扩展和维护的成本</strong>。</p> 
<h3><a id="22_IoC_85"></a>2.2 IoC的实现机制</h3> 
<p>Spring 中的 IoC 的实现原理就是工厂模式加反射机制。<br> 实现原理演示：</p> 
<pre><code class="prism language-java"><span class="token keyword">interface</span> <span class="token class-name">Fruit</span> <span class="token punctuation">{<!-- --></span>
   <span class="token keyword">public</span> <span class="token keyword">abstract</span> <span class="token keyword">void</span> <span class="token function">eat</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">class</span> <span class="token class-name">Apple</span> <span class="token keyword">implements</span> <span class="token class-name">Fruit</span> <span class="token punctuation">{<!-- --></span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">eat</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"Apple"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">class</span> <span class="token class-name">Orange</span> <span class="token keyword">implements</span> <span class="token class-name">Fruit</span> <span class="token punctuation">{<!-- --></span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">eat</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"Orange"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">class</span> <span class="token class-name">Factory</span> <span class="token punctuation">{<!-- --></span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> Fruit <span class="token function">getInstance</span><span class="token punctuation">(</span>String ClassName<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        Fruit f<span class="token operator">=</span>null<span class="token punctuation">;</span>
        <span class="token keyword">try</span> <span class="token punctuation">{<!-- --></span>
            f<span class="token operator">=</span><span class="token punctuation">(</span>Fruit<span class="token punctuation">)</span>Class<span class="token punctuation">.</span><span class="token function">forName</span><span class="token punctuation">(</span>ClassName<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">newInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Exception</span> e<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
            e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">return</span> f<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">class</span> <span class="token class-name">Client</span> <span class="token punctuation">{<!-- --></span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> a<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        Fruit f<span class="token operator">=</span>Factory<span class="token punctuation">.</span><span class="token function">getInstance</span><span class="token punctuation">(</span><span class="token string">"io.github.dunwu.spring.Apple"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">if</span><span class="token punctuation">(</span>f<span class="token operator">!=</span>null<span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
            f<span class="token punctuation">.</span><span class="token function">eat</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> 
<h3><a id="22_DI_127"></a>2.2 依赖注入(DI)</h3> 
<p>  依赖注入（Dependency Injection，DI），是组件之间依赖关系由容器在运行期决定，即由容器动态的将某个依赖关系注入到组件之中。依赖注入的目的并非为软件系统带来更多功能，而是为了<strong>提升组件重用的频率，并为系统搭建一个灵活、可扩展的平台</strong>。<br>   通过依赖注入机制，只需要通过简单的配置，而无需任何代码就可指定目标需要的资源，完成自身的业务逻辑。</p> 
<blockquote> 
 <p><strong>IoC 和 DI 的关系</strong><br>   IoC 是 Spring 中一个极为重要的概念，而 DI 则是实现 IoC 的一种方法和手段。还有一种实现是依赖查找(Dependency Lookup，DL)</p> 
</blockquote> 
<h3><a id="23__133"></a>2.3 依赖注入的实现</h3> 
<p>常见实现方式:</p> 
<ul><li>setter 注入</li><li>构造方法注入：①通过index设置参数的位置；②通过type设置参数类型；</li><li>注解注入</li><li>静态工厂注入；</li><li>实例工厂注入；<br> 其中最常用的是前三种，官方推荐使用的是注解注入，相对使用更简单，维护成本更低，更直观。</li></ul> 
<h4><a id="1_setter__142"></a>1) setter 注入</h4> 
<p>Java 代码：</p> 
<pre><code class="prism language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">UserController</span> <span class="token punctuation">{<!-- --></span>
    <span class="token comment">// 注入 UserService 对象</span>
    <span class="token keyword">private</span> UserService userService<span class="token punctuation">;</span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">setUserService</span><span class="token punctuation">(</span>UserService userService<span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>userService <span class="token operator">=</span> userService<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>XML 配置：</p> 
<pre><code class="prism language-xml"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>bean</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>userController<span class="token punctuation">"</span></span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>com.learning.controller.UserController<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>  
    <span class="token comment">&lt;!-- 依赖注入 --&gt;</span>  
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>property</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>userService<span class="token punctuation">"</span></span> <span class="token attr-name">ref</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>userService<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>property</span><span class="token punctuation">&gt;</span></span>  
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>bean</span><span class="token punctuation">&gt;</span></span>  
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>bean</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>userService<span class="token punctuation">"</span></span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>com.learning.dao.impl.UserServiceImpl<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>bean</span><span class="token punctuation">&gt;</span></span>
</code></pre> 
<p>Bean 标签的常用属性说明：</p> 
<ul><li>id：为实例化对象起名称，根据 id 值可以得到我们配置的实例化对象，id 属性的名称原则上可以任意命名，但是能包含任何特殊符号；</li><li>class：创建对象所在类的全路径；</li><li>name：功能和 id 属性一样，但是现在一般不用；与 id 的区别在于：name 属性值里可以包含特殊符号，但是 id 不可以；</li><li>scope：一般最常用的有两个值： Singleton：单例模式，整个应用程序，只创建 bean 的一个实例；Prototype：原型模式，每次注入都会创建一个新的 bean 实例，Spring 默认的是单例模式。</li></ul> 
<h4><a id="2__169"></a>2) 构造方法注入</h4> 
<p>Java 代码：</p> 
<pre><code class="prism language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">UserController</span> <span class="token punctuation">{<!-- --></span>
    <span class="token keyword">private</span> UserService userService<span class="token punctuation">;</span>
    <span class="token keyword">public</span> <span class="token function">UserController</span><span class="token punctuation">(</span>UserService userService<span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>userService <span class="token operator">=</span> userService<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>XML 配置：</p> 
<pre><code class="prism language-xml"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>bean</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>userController<span class="token punctuation">"</span></span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>com.learning.controller.UserController<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>  
    <span class="token comment">&lt;!-- 依赖注入 --&gt;</span>  
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>constructor-arg</span> <span class="token attr-name">ref</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>userService<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>constructor-arg</span><span class="token punctuation">&gt;</span></span>  
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>bean</span><span class="token punctuation">&gt;</span></span>  
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>bean</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>userService<span class="token punctuation">"</span></span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>com.learning.dao.impl.UserServiceImpl<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>bean</span><span class="token punctuation">&gt;</span></span>  
</code></pre> 
<h4><a id="3__189"></a>3) 注解注入</h4> 
<pre><code class="prism language-java"><span class="token annotation punctuation">@Controller</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">UserController</span> <span class="token punctuation">{<!-- --></span>
    <span class="token comment">// 使用注解自动注入</span>
    <span class="token annotation punctuation">@Autowired</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token keyword">private</span> UserService userService<span class="token punctuation">;</span>
    <span class="token comment">// do something</span>
<span class="token punctuation">}</span>
<span class="token comment">// 创建依赖对象</span>
<span class="token annotation punctuation">@Service</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">UserService</span> <span class="token punctuation">{<!-- --></span>
   <span class="token comment">// do something </span>
<span class="token punctuation">}</span>
</code></pre> 
<p>创建依赖对象的常见注解：@Component、@Controller、@Service、@Repository。</p> 
<p>总结：可以看出注解的方式要比传统的 XML（setter 和构造器注入）实现注入更为方便，同时注解方式也是官方力推的依赖注入最佳使用方式。</p> 
<h3><a id="24_IoC_208"></a>2.4 控制反转(IoC)的作用</h3> 
<ul><li>管理对象的创建和依赖关系的维护。</li><li>解耦，由容器去维护具体的对象。</li><li>托管了类的产生过程，比如我们需要在类的产生过程中做一些处理，最直接的例子就是代理，如果有容器程序可以把这部分处理交给容器，应用程序则无需去关心类是如何完成代理的。</li></ul> 
<h3><a id="25_IoC_213"></a>2.5 控制反转(IoC)的优点</h3> 
<ul><li>IoC 把应用的<strong>代码量</strong>降到最低。</li><li>它使应用容易<strong>测试</strong>，单元测试不再需要单例和JNDI查找机制。</li><li><strong>最小的代价和最小的侵入性</strong>实现松耦合。</li><li>IoC容器支持加载服务时的<strong>饿汉式初始化和懒加载</strong>。</li></ul> 
<h3><a id="26_IoC_219"></a>2.6 IoC容器</h3> 
<p>  IoC容器就是<strong>具有依赖注入功能</strong>的容器，IoC容器负责实例化、定位、配置应用程序中的对象及建立这些对象间的依赖。应用程序无需直接在代码中new相关的对象，应用程序由IoC容器进行组装。<br>   Spring提供两种Ioc容器，分别是BeanFactory和ApplicationContext。<br>   BeanFactory和ApplicationContext是Spring的两大核心接口，都可以当做Spring的容器。其中ApplicationContext是BeanFactory的子接口。</p> 
<h4><a id="261_BeanFactoryApplicationContext_223"></a>2.6.1 BeanFactory和ApplicationContext的区别</h4> 
<h5><a id="1__224"></a>1) 依赖关系</h5> 
<p>  BeanFactory：是Spring里面最底层的接口，包含了各种Bean的定义，读取bean配置文档，管理bean的加载、实例化，控制bean的生命周期，维护bean之间的依赖关系。<br>   ApplicationContext接口作为BeanFactory的派生，除了提供BeanFactory所具有的功能外，还提供了更完整的<strong>框架功能</strong>：</p> 
<blockquote> 
 <ul><li>继承MessageSource，因此支持国际化。</li><li>统一的资源文件访问方式。</li><li>提供在监听器中注册bean的事件。</li><li>同时加载多个配置文件。</li><li>载入多个（有继承关系）上下文 ，使得每一个上下文都专注于一个特定的层次，比如应用的web层。</li></ul> 
</blockquote> 
<h5><a id="2__233"></a>2) 加载方式</h5> 
<p>  BeanFactory：采用<strong>懒加载</strong>(lazy-load)，即只有在使用到某个Bean时(调用getBean())，才对该Bean进行加载实例化，所以启动容器较快。<br>   ApplicationContext：基于BeanFactory，在<strong>启动容器时</strong>就会初始化并注入依赖，<strong>一次性创建</strong>所有的Bean。这样，在容器启动时就可以发现Spring中存在的配置错误，有利于检查所依赖属性是否注入；同时通过预载入单实例bean，确保需要时不用等待可以直接使用。<br>   相对于基本的BeanFactory，ApplicationContext 唯一的不足是占用内存空间。当应用程序配置Bean较多时，程序启动较慢。</p> 
<h5><a id="3__238"></a>3) 创建方式</h5> 
<p>  BeanFactory通常以<strong>编程</strong>的方式被创建，ApplicationContext还能以<strong>声明</strong>的方式创建，如使用ContextLoader。</p> 
<h5><a id="4__241"></a>4) 注册方式</h5> 
<p>  BeanFactory和ApplicationContext都支持BeanPostProcessor、BeanFactoryPostProcessor的使用，但两者之间的区别是：<br> BeanFactory需要<strong>手动注册</strong>，而ApplicationContext则是<strong>自动注册</strong>。</p> 
<h4><a id="262_BeanFactoryApplicationContext_245"></a>2.6.2 BeanFactory和ApplicationContext的关系</h4> 
<p>参考：<a href="https://blog.csdn.net/lisongjia123/article/details/52129340">Spring源码剖析——核心IOC容器原理</a></p> 
<p>BeanFactory 简单粗暴，可以理解为就是个 HashMap，Key 是 BeanName，Value 是 Bean 实例。通常只提供注册（put），获取（get）这两个功能。我们可以称之为 “<strong>低级容器</strong>”。</p> 
<p>ApplicationContext 可以称之为 “<strong>高级容器</strong>”。因为他比 BeanFactory 多了更多的功能。他继承了多个接口。因此具备了更多的功能。例如资源的获取，支持多种消息（例如 JSP tag 的支持），对 BeanFactory 多了工具级别的支持等待。<br> 该接口定义了一个 refresh 方法，此方法用于刷新整个容器，即重新加载/刷新所有的 bean。</p> 
<p>为了更直观的展示 “低级容器” 和 “高级容器” 的关系，这里通过常用的 ClassPathXmlApplicationContext 类来展示整个容器的层级关系。<br> <img src="https://images2.imgbox.com/ec/0e/0ajtLYFm_o.png" alt="在这里插入图片描述"><br> 最上面的是 BeanFactory，下面的 3 个绿色的，都是功能扩展接口，这里就不展开讲。</p> 
<p>看下面的隶属 ApplicationContext 粉红色的 “高级容器”，依赖着 “低级容器”，这里说的是依赖，不是继承。它依赖着 “低级容器” 的 getBean 功能。而高级容器有更多的功能：支持不同的信息源头，可以访问文件资源，支持应用事件（Observer 模式）。</p> 
<p>通常用户看到的就是 “高级容器”，但 BeanFactory 也已经够用了。<br> 左边灰色区域的是 “低级容器”， 只负责加载 Bean，获取 Bean。容器其他的高级功能是没有的。例如上图画的 refresh 刷新 Bean 工厂所有配置，生命周期事件回调等。</p> 
<p><strong>小结</strong><br> IoC 在 Spring 里，只需要低级容器就可以实现，2 个步骤：</p> 
<ul><li>加载配置文件，解析成 BeanDefinition 放在 Map 里。</li><li>调用 getBean 的时候，从 BeanDefinition 所属的 Map 里，拿出 Class 对象进行实例化，同时，如果有依赖关系，将递归调用 getBean 方法 —— 完成依赖注入。</li></ul> 
<p>至于高级容器 ApplicationContext，它包含了低级容器的功能，当它执行 refresh 模板方法的时候，将刷新整个容器的 Bean。同时其作为高级容器，包含了太多的功能。一句话，它不仅仅是 IoC。它支持不同信息源头，支持 BeanFactory 工具类，支持层级容器，支持访问文件资源，支持事件发布通知，支持接口回调等等。</p> 
<h4><a id="263_ApplicationContext__269"></a>2.6.3 ApplicationContext 的实现</h4> 
<ul><li>FileSystemXmlApplicationContext ：此容器从一个XML文件中加载beans的定义，XML Bean 配置文件的全路径名必须提供给它的构造函数。</li><li>ClassPathXmlApplicationContext：此容器也从一个XML文件中加载beans的定义，这里，你需要正确设置classpath，因为这个容器将在classpath里找bean配置。</li><li>WebXmlApplicationContext：此容器加载一个XML文件，此文件定义了一个WEB应用的所有bean。</li></ul> 
<h2><a id="Spring_Beans_274"></a>三、Spring Beans</h2> 
<h3><a id="31__275"></a>3.1 基本概念</h3> 
<p>  Spring beans 是那些形成Spring应用的主干的java对象。它们被Spring IOC容器初始化，装配，和管理。这些beans通过容器中配置的元数据创建。比如，以XML文件中 的形式定义。<br>   一个 Spring Bean 的定义包含容器必知的所有配置元数据，包括如何创建一个bean，它的生命周期详情及它的依赖。</p> 
<p>为Spring容器提供<strong>配置元数据</strong>的几种方式：</p> 
<blockquote> 
 <ul><li>XML配置文件</li><li>基于注解的配置</li><li>基于java的配置</li></ul> 
</blockquote> 
<p>Spring配置文件:</p> 
<blockquote> 
 <p>Spring配置文件是个XML文件，这个文件包含了<strong>类信息</strong>，描述了<strong>如何配置</strong>它们，以及<strong>如何相互调用</strong>。</p> 
</blockquote> 
<p>Spring注入bean的几种方式:</p> 
<blockquote> 
 <ul><li>set方法注入；</li><li>构造器注入：①通过index设置参数的位置；②通过type设置参数类型；</li><li>注解注入；</li><li>静态工厂注入；</li><li>实例工厂注入；</li></ul> 
</blockquote> 
<h3><a id="32_bean_294"></a>3.2 bean的作用域</h3> 
<p>在Spring里，我们还能给bean声明一个作用域。它可以通过bean定义中的scope属性来定义。比如，一个bean每次使用的时候需要生产一个新的bean实例，bean的scope属性被指定为prototype；而如果每次使用的时候必须返回同一个实例，这个bean的scope属性必须设为singleton。</p> 
<p>Spring框架支持以下五种bean的作用域：</p> 
<ul><li>singleton: bean在每个Spring IoC 容器中只有一个实例。</li><li>prototype：一个bean的定义可以有多个实例。</li><li>request：每次http请求都会创建一个bean，该作用域仅在基于web的Spring ApplicationContext情形下有效。</li><li>session：在一个HTTP Session中，一个bean定义对应一个实例。该作用域仅在基于web的Spring ApplicationContext情形下有效。</li><li>global-session：在一个全局的HTTP Session中，一个bean定义对应一个实例。该作用域仅在基于web的Spring ApplicationContext情形下有效。</li></ul> 
<p>注意： 缺省的Spring bean即默认的作用域是Singleton。使用 prototype 作用域需要慎重的思考，因为频繁创建和销毁 bean 会带来很大的性能开销。</p> 
<h3><a id="33__306"></a>3.3 线程安全问题</h3> 
<h4><a id="Springbean_307"></a>Spring框架中的单例bean是线程安全吗？</h4> 
<p>Spring框架中的单例bean不是线程安全的。<br> spring 中的 bean 默认是单例模式，spring 框架并没有对单例 bean 进行多线程的封装处理。</p> 
<p>实际上大部分时候 spring bean 无状态的（比如 dao 类），所有某种程度上来说 bean 也是安全的，但如果 bean <strong>有状态</strong>的话（比如 view model 对象），那就要开发者自己去保证线程安全了，最简单的就是<strong>改变 bean 的作用域</strong>，把“singleton”变更为“<strong>prototype</strong>”，这样请求 bean 相当于 new Bean()了，所以就可以保证线程安全了。</p> 
<blockquote> 
 <p>有状态 就是 <strong>有数据存储功能</strong>。<br> 无状态 就是 <strong>不会保存数据</strong>。</p> 
</blockquote> 
<h4><a id="Spring_315"></a>Spring如何处理线程并发问题？</h4> 
<p>在一般情况下，只有无状态的Bean才可以在多线程环境下共享，在Spring中，绝大部分Bean都可以声明为singleton作用域，因为Spring对一些Bean中非线程安全状态采用 ThreadLocal 进行处理，解决线程安全问题。</p> 
<p><strong>ThreadLocal</strong> 和<strong>线程同步机制</strong>都是为了解决多线程中相同变量的访问冲突问题。同步机制采用了“<strong>时间换空间</strong>”的方式，仅提供一份变量，不同的线程在访问前需要获取锁，没获得锁的线程则需要排队。而ThreadLocal采用了“<strong>空间换时间</strong>”的方式。</p> 
<p>ThreadLocal会为每一个线程提供一个独立的变量副本，从而隔离了多个线程对数据的访问冲突。因为每一个线程都拥有自己的变量副本，从而也就没有必要对该变量进行同步了。ThreadLocal提供了线程安全的共享对象，在编写多线程代码时，可以把不安全的变量封装进ThreadLocal。</p> 
<h3><a id="34_bean_322"></a>3.4 bean的生命周期</h3> 
<blockquote> 
 <ul><li>在传统的Java应用中，bean的生命周期很简单。使用Java关键字new进行bean实例化，然后该bean就可以使用了。一旦该bean不再被使用，则由Java自动进行垃圾回收。</li><li>相比之下，Spring容器中的bean的生命周期就显得相对复杂多了。正确理解Spring bean的生命周期非常重要，因为你或许要利用Spring提供的扩展点来自定义bean的创建过程。</li></ul> 
</blockquote> 
<p>下图展示了bean装载到Spring应用上下文中的一个典型的生命周期过程。<br> <img src="https://images2.imgbox.com/18/a6/xypgHB5Z_o.png" alt="在这里插入图片描述"><br> bean在Spring容器中从创建到销毁经历了若干阶段，每一阶段都可以针对Spring如何管理bean进行<strong>个性化定制</strong>。<br> 正如你所见，在bean准备就绪之前，bean工厂执行了若干启动步骤。<br> 我们对上图进行详细描述：</p> 
<ul><li>Spring对bean进行实例化；</li><li>Spring将值和bean的引用注入到bean对应的属性中；</li><li>接着，Spring会检测该对象是否实现了xxxAware接口，并将相关的xxxAware实例注入给Bean：<br> ① 如果bean实现了<code>BeanNameAware</code>接口，Spring将bean的ID传递给<code>setBeanName()</code>方法；<br> ② 如果bean实现了<code>BeanFactoryAware</code>接口，Spring将调用<code>setBeanFactory()</code>方法，将<code>BeanFactory</code>容器实例传入；<br> ③ 如果bean实现了<code>ApplicationContextAware</code>接口，Spring将调用<code>setApplicationContext()</code>方法，将bean所在的应用上下文的引用传入进来；</li><li>如果bean实现了<code>BeanPostProcessor</code>接口，Spring将调用它们的<code>postProcessBeforeInitialization()</code>预初始化方法；</li><li>如果bean实现了<code>InitializingBean</code>接口，Spring将调用它们的<code>afterPropertiesSet()</code>方法。类似地，如果bean使用<code>init-method</code>声明了初始化方法，该方法也会被调用；</li><li>如果bean实现了<code>BeanPostProcessor</code>接口，Spring将调用它们的<code>postProcessAfterInitialization()</code>初始化后方法；</li><li>此时，bean已经准备就绪，可以被应用程序使用了，它们将一直驻留在应用上下文中，直到该应用上下文被销毁；</li><li>如果bean实现了<code>DisposableBean</code>接口，Spring将调用它的<code>destroy()</code>接口方法。同样，如果bean使用<code>destroy-method</code>声明了销毁方法，该方法也会被调用。</li></ul> 
<p>现在已经了解了如何创建和加载一个Spring容器。但是一个空的容器并没有太大的价值，在你把东西放进去之前，它里面什么都没有。为了从Spring的DI(依赖注入)中受益，我们必须将应用对象装配进Spring容器中。</p> 
<blockquote> 
 <p>spring-bean生命周期之初始化和销毁的三种方式：(具体实现参考：<a href="https://mp.weixin.qq.com/s?__biz=MzAxMjY1NTIxNA==&amp;mid=2454441970&amp;idx=1&amp;sn=55a4491608d6f05a5a406b73024bbc6d&amp;chksm=8c11e0f3bb6669e54a1499a2aad09d38ceb68d40a88dfd89bd53de0fbe84238fa45caf768037&amp;scene=21#wechat_redirect" rel="nofollow">bean生命周期之初始化和销毁</a>)</p> 
 <ul><li>注解bean之指定init-method/destroy-method</li><li>实现InitializingBean/DisposableBean接口</li><li>@PostConstruct和@PreDestroy注解</li></ul> 
</blockquote> 
<h3><a id="35_bean_351"></a>3.5 bean的装配</h3> 
<p>装配，或bean装配是指在Spring容器中把bean组装到一起，前提是容器需要知道bean的依赖关系，如何通过依赖注入来把它们装配到一起。</p> 
<h4><a id="351_bean_353"></a>3.5.1 bean的自动装配</h4> 
<blockquote> 
 <p>在Spring框架中，在配置文件中设定bean的依赖关系是一个很好的机制，Spring容器能够自动装配相互合作的bean，这意味着容器不需要和配置，能通过Bean工厂自动处理bean之间的协作。 这意味着：<br> Spring可以通过向Bean Factory中注入的方式自动搞定bean之间的依赖关系。<br> 自动装配可以设置在每个bean上，也可以设定在特定的bean上。</p> 
</blockquote> 
<h4><a id="352__358"></a>3.5.2 自动装配的方式</h4> 
<p>在spring中，对象无需自己查找或创建与其关联的其他对象，由容器负责把需要相互协作的对象引用赋予各个对象，使用autowire来配置自动装载模式。</p> 
<p>在Spring框架xml配置中共有5种自动装配：</p> 
<ul><li>no：默认的方式是不进行自动装配的，通过手工设置ref属性来进行装配bean。</li><li>byName：通过bean的名称进行自动装配，如果一个bean的property与另一bean的name相同，就进行自动装配。</li><li>byType：通过参数的数据类型进行自动装配。</li><li>constructor：利用构造函数进行装配，并且构造函数的参数通过byType进行装配。</li><li>autodetect：自动探测，如果有构造方法，通过 construct的方式自动装配，否则使用byType的方式自动装配。</li></ul> 
<h4><a id="353_Autowired_368"></a>3.5.3 使用@Autowired注解自动装配的过程</h4> 
<p>使用<code>@Autowired</code>注解来自动装配指定的bean。<br> 在使用<code>@Autowired</code>注解之前需要在Spring配置文件进行配置，<code>&lt;context:annotation-config /&gt;</code>。<br> 在启动spring IoC时，容器自动装载了一个<code>AutowiredAnnotationBeanPostProcessor</code>后置处理器，当容器扫描到<code>@Autowied</code>、<code>@Resource</code>或<code>@Inject</code>时，就会在IoC容器自动查找需要的bean，并装配给该对象的属性。在使用<code>@Autowired</code>时，首先在容器中查询对应类型的bean：</p> 
<ul><li>如果查询结果刚好为一个，就将该bean装配给<code>@Autowired</code>指定的数据；</li><li>如果查询的结果不止一个，那么<code>@Autowired</code>会根据名称来查找；</li><li>如果上述查找的结果为空，那么会抛出异常。解决方法时，使用<code>required=false</code>。</li></ul> 
<h4><a id="354__376"></a>3.5.4 自动装配的局限性</h4> 
<p>自动装配的局限性是：</p> 
<ul><li><strong>重写</strong>：仍需用 <code>&lt;constructor-arg&gt;</code> 和 <code>&lt;property&gt;</code> 配置来定义依赖，意味着总要重写自动装配。</li><li><strong>基本数据类型</strong>：不能自动装配简单的属性，如基本数据类型，String字符串，和类。</li><li><strong>模糊特性</strong>：自动装配不如显式装配精确，如果有可能，建议使用显式装配。</li></ul> 
<h2><a id="Spring_382"></a>四、Spring注解</h2> 
<h3><a id="41_JavaSpring_383"></a>4.1 基于Java的Spring注解配置</h3> 
<p>基于Java的配置，允许你在少量的Java注解的帮助下，进行你的大部分Spring配置而非通过XML文件。<br> 以@Configuration注解为例，它用来标记类可以当做一个bean的定义，被Spring IOC容器使用。<br> 另一个例子是@Bean注解，它表示此方法将要返回一个对象，作为一个bean注册进Spring应用上下文。</p> 
<pre><code class="prism language-java"><span class="token annotation punctuation">@Configuration</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">StudentConfig</span> <span class="token punctuation">{<!-- --></span>
    <span class="token annotation punctuation">@Bean</span>
    <span class="token keyword">public</span> StudentBean <span class="token function">myStudent</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">StudentBean</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> 
<p><strong>如何开启注解装配</strong></p> 
<blockquote> 
 <p>注解装配在默认情况下是不开启的，为了使用注解装配，我们必须在Spring配置文件中配置<code>&lt;context:annotation-config/&gt;</code>元素。</p> 
</blockquote> 
<h3><a id="42_Component_Controller_Repository_Service_399"></a>4.2 @Component, @Controller, @Repository, @Service注解</h3> 
<table><thead><tr><th align="left">注解名</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left">@Component</td><td align="left">这将 java 类标记为 bean。它是任何 Spring 管理组件的通用构造型。spring 的组件扫描机制现在可以将其拾取并将其拉入应用程序环境中。</td></tr><tr><td align="left">@Controller</td><td align="left">这将一个类标记为 Spring Web MVC 控制器。标有它的 Bean 会自动导入到 IoC 容器中。</td></tr><tr><td align="left">@Service</td><td align="left">此注解是组件注解的特化。它不会对 @Component 注解提供任何其他行为。您可以在服务层类中使用 @Service 而不是@Component，因为它以更好的方式指定了意图。</td></tr><tr><td align="left">@Repository</td><td align="left">这个注解是具有类似用途和功能的 @Component 注解的特化。它为 DAO 提供了额外的好处。它将 DAO 导入 IoC 容器，并使未经检查的异常有资格转换为 Spring DataAccessException。</td></tr></tbody></table> 
<h3><a id="43_Required__407"></a>4.3 @Required 注解</h3> 
<p>这个注解表明bean的属性必须在配置的时候设置，通过一个bean定义的显式的属性值或通过自动装配，若@Required注解的bean属性未被设置，容器将抛出BeanInitializationException。示例：</p> 
<pre><code class="prism language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Employee</span> <span class="token punctuation">{<!-- --></span>
    <span class="token keyword">private</span> String name<span class="token punctuation">;</span>
    <span class="token annotation punctuation">@Required</span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">setName</span><span class="token punctuation">(</span>String name<span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>name<span class="token operator">=</span>name<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">public</span> string <span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
        <span class="token keyword">return</span> name<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> 
<h3><a id="44_Autowired__421"></a>4.4 @Autowired 注解</h3> 
<p>@Autowired默认是按照类型装配注入的，默认情况下它要求依赖对象必须存在（可以设置它required属性为false）。@Autowired 注解提供了更细粒度的控制，包括在何处以及如何完成自动装配。它的用法和@Required一样，修饰setter方法、构造器、属性或者具有任意名称和/或多个参数的PN方法。</p> 
<pre><code class="prism language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Employee</span> <span class="token punctuation">{<!-- --></span>
    <span class="token keyword">private</span> String name<span class="token punctuation">;</span>
    <span class="token annotation punctuation">@Autowired</span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">setName</span><span class="token punctuation">(</span>String name<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>name<span class="token operator">=</span>name<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">public</span> string <span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
        <span class="token keyword">return</span> name<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> 
<blockquote> 
 <p>@Autowired可用于：构造函数、成员变量、Setter方法<br> <strong>@Autowired和@Resource之间的区别</strong>：</p> 
 <ul><li>@Autowired默认是按照类型装配注入的，默认情况下它要求依赖对象必须存在（可以设置它required属性为false）。</li><li>@Resource默认是按照名称来装配注入的，只有当找不到与名称匹配的bean才会按照类型来装配注入。</li></ul> 
</blockquote> 
<h3><a id="45_Qualifier__441"></a>4.5 @Qualifier 注解</h3> 
<p>当您创建多个相同类型的 bean 并希望仅使用属性装配其中一个 bean 时，您可以使用@Qualifier 注解和 @Autowired 通过指定应该装配哪个确切的 bean 来消除歧义。</p> 
<h3><a id="46_RequestMapping__444"></a>4.6 @RequestMapping 注解</h3> 
<p>@RequestMapping 注解用于将特定 HTTP 请求方法映射到将处理相应请求的控制器中的特定类/方法。<br> 此注释可应用于两个级别：</p> 
<ul><li>类级别：映射请求的 URL</li><li>方法级别：映射 URL 以及 HTTP 请求方法</li></ul> 
<h2><a id="Spring_450"></a>五、Spring数据访问</h2> 
<h3><a id="51__451"></a>5.1 对象/关系映射集成模块</h3> 
<p>Spring 通过提供ORM模块，支持我们在直接JDBC之上使用一个对象/关系映射映射(ORM)工具，Spring 支持集成主流的ORM框架，如Hiberate，JDO和 iBatis，JPA，TopLink，JDO，OJB 。Spring的事务管理同样支持以上所有ORM框架及JDBC。</p> 
<h3><a id="52_JDBC_454"></a>5.2 如何更有效地使用JDBC</h3> 
<p>使用Spring JDBC 框架，资源管理和错误处理的代价都会被减轻。所以开发者只需写statements 和 queries从数据存取数据，JDBC也可以在Spring框架提供的模板类的帮助下更有效地被使用，这个模板叫JdbcTemplate。</p> 
<h4><a id="521_JDBCDAO_457"></a>5.2.1 JDBC抽象和DAO模块</h4> 
<p>通过使用JDBC抽象和DAO模块，保证数据库代码的简洁，并能避免数据库资源错误关闭导致的问题，它在各种不同的数据库的错误信息之上，提供了一个统一的异常访问层。它还利用Spring的AOP 模块给Spring应用中的对象提供事务管理服务。</p> 
<p><strong>spring DAO 作用</strong></p> 
<blockquote> 
 <p>Spring DAO（数据访问对象） 使得 JDBC，Hibernate 或 JDO 这样的数据访问技术更容易以一种统一的方式工作。这使得用户容易在持久性技术之间切换。它还允许您在编写代码时，无需考虑捕获每种技术不同的异常。</p> 
</blockquote> 
<p><strong>spring JDBC API 中的类</strong></p> 
<blockquote> 
 <ul><li>JdbcTemplate</li><li>SimpleJdbcTemplate</li><li>NamedParameterJdbcTemplate</li><li>SimpleJdbcInsert</li><li>SimpleJdbcCall</li></ul> 
</blockquote> 
<p><strong>JdbcTemplate是什么</strong></p> 
<blockquote> 
 <p>JdbcTemplate 类提供了很多便利的方法解决诸如把数据库数据转变成基本数据类型或对象，执行写好的或可调用的数据库操作语句，提供自定义的数据错误处理。</p> 
</blockquote> 
<h3><a id="53_SpringHibernate_473"></a>5.3 Spring访问Hibernate</h3> 
<p>在Spring中有两种方式访问Hibernate：</p> 
<ul><li>使用 Hibernate 模板和回调进行控制反转</li><li>扩展 HibernateDAOSupport 并应用 AOP 拦截器节点</li></ul> 
<p><strong>如何通过HibernateDaoSupport将Spring和Hibernate结合起来</strong><br> 用Spring的 SessionFactory 调用 LocalSessionFactory。集成过程分三步：</p> 
<ul><li>配置the Hibernate SessionFactory</li><li>继承HibernateDaoSupport实现一个DAO</li><li>在AOP支持的事务中装配</li></ul> 
<h3><a id="54_Spring_484"></a>5.4 Spring事务</h3> 
<h4><a id="541_Spring_485"></a>5.4.1 Spring支持的事务管理类型（事务实现方式）</h4> 
<p>Spring支持两种类型的事务管理：</p> 
<ul><li>编程式事务管理：这意味你通过编程的方式管理事务，给你带来极大的灵活性，但是难维护。</li><li>声明式事务管理：这意味着你可以将业务代码和事务管理分离，你只需用注解和XML配置来管理事务。</li></ul> 
<h4><a id="542_Spring_490"></a>5.4.2 Spring事务的实现方式和实现原理</h4> 
<p>Spring事务的本质其实就是数据库对事务的支持，没有数据库的事务支持，spring是无法提供事务功能的。<br> 真正的数据库层的事务提交和回滚是通过binlog或者redo log实现的。</p> 
<h4><a id="543_Spring_494"></a>5.4.3 Spring的事务传播行为</h4> 
<p>spring事务的传播行为说的是，当多个事务同时存在的时候，spring如何处理这些事务的行为。</p> 
<table><thead><tr><th align="left">传播行为</th><th align="left">含义</th></tr></thead><tbody><tr><td align="left">PROPAGATION_REQUIRED</td><td align="left">如果当前没有事务，就创建一个新事务，如果当前存在事务，就加入该事务，该设置是最常用的设置。</td></tr><tr><td align="left">PROPAGATION_SUPPORTS</td><td align="left">支持当前事务，如果当前存在事务，就加入该事务，如果当前不存在事务，就以非事务执行。</td></tr><tr><td align="left">PROPAGATION_MANDATORY</td><td align="left">支持当前事务，如果当前存在事务，就加入该事务，如果当前不存在事务，就抛出异常。</td></tr><tr><td align="left">PROPAGATION_REQUIRES_NEW</td><td align="left">创建新事务，无论当前存不存在事务，都创建新事务。</td></tr><tr><td align="left">PROPAGATION_NOT_SUPPORTED</td><td align="left">以非事务方式执行操作，如果当前存在事务，就把当前事务挂起。</td></tr><tr><td align="left">PROPAGATION_NEVER</td><td align="left">以非事务方式执行，如果当前存在事务，则抛出异常。</td></tr><tr><td align="left">PROPAGATION_NESTED</td><td align="left">如果当前存在事务，则在嵌套事务内执行。如果当前没有事务，则按REQUIRED属性执行。</td></tr></tbody></table> 
<h4><a id="544_spring__506"></a>5.4.4 spring 的事务隔离</h4> 
<p>spring 有五大隔离级别，默认值为 ISOLATION_DEFAULT（使用数据库的设置），其他四个隔离级别和数据库的隔离级别一致：</p> 
<table><thead><tr><th align="left">隔离级别</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left">ISOLATION_DEFAULT</td><td align="left">用底层数据库的设置隔离级别，数据库设置的是什么我就用什么；</td></tr><tr><td align="left">ISOLATION_READ_UNCOMMITTED</td><td align="left">未提交读，最低隔离级别、事务未提交前，就可被其他事务读取（会出现幻读、脏读、不可重复读）；</td></tr><tr><td align="left">ISOLATION_READ_COMMITTED</td><td align="left">提交读，一个事务提交后才能被其他事务读取到（会造成幻读、不可重复读），SQL server 的默认级别；</td></tr><tr><td align="left">ISOLATION_REPEATABLE_READ</td><td align="left">可重复读，保证多次读取同一个数据时，其值都和事务开始时候的内容是一致，禁止读取到别的事务未提交的数据（会造成幻读），MySQL 的默认级别；</td></tr><tr><td align="left">ISOLATION_SERIALIZABLE</td><td align="left">序列化，代价最高最可靠的隔离级别，该隔离级别能防止<code>脏读</code>、<code>不可重复读</code>、<code>幻读</code>。</td></tr></tbody></table> 
<blockquote> 
 <p><strong>脏读</strong>：表示一个事务能够读取另一个事务中还未提交的数据。比如，某个事务尝试插入记录 A，此时该事务还未提交，然后另一个事务尝试读取到了记录 A。<br> <strong>不可重复读</strong> ：是指在一个事务内，多次读同一数据。<br> <strong>幻读</strong>：指同一个事务内多次查询返回的结果集不一样。比如同一个事务 A 第一次查询时候有 n 条记录，但是第二次同等条件下查询却有 n+1 条记录，这就好像产生了幻觉。发生幻读的原因也是另外一个事务新增或者删除或者修改了第一个事务结果集里面的数据，同一个记录的数据内容被修改了，所有数据行的记录就变多或者变少了。</p> 
</blockquote> 
<h4><a id="545_Spring_520"></a>5.4.5 Spring框架的事务管理的优点</h4> 
<ul><li>为不同的事务API 如 JTA，JDBC，Hibernate，JPA 和JDO，提供一个不变的编程模式。</li><li>为编程式事务管理提供了一套简单的API而不是一些复杂的事务API。</li><li>支持声明式事务管理。</li><li>和Spring各种数据访问抽象层很好得集成。</li></ul> 
<blockquote> 
 <p><strong>事务管理类型的选择</strong></p> 
 <ul><li>大多数Spring框架的用户选择声明式事务管理，因为它对应用代码的影响最小，因此更符合一个无侵入的轻量级容器的思想。</li><li>声明式事务管理要优于编程式事务管理，虽然比编程式事务管理（这种方式允许你通过代码控制事务）少了一点灵活性。</li><li>唯一不足地方是，最细粒度只能作用到方法级别，无法做到像编程式事务那样可以作用到代码块级别。</li></ul> 
</blockquote> 
<h2><a id="AOP_531"></a>六、AOP</h2> 
<h3><a id="61_AOP_532"></a>6.1 什么是AOP</h3> 
<p>OOP(Object-Oriented Programming)面向对象编程，允许开发者定义纵向的关系，但并适用于定义横向的关系，导致了大量代码的重复，而不利于各个模块的重用。</p> 
<p>AOP(Aspect-Oriented Programming)，一般称为面向切面编程，作为面向对象的一种补充，用于将那些<strong>与业务无关</strong>，但却<strong>对多个对象产生影响的公共行为和逻辑</strong>，<strong>抽取并封装</strong>为一个可重用的模块，这个模块被命名为“<strong>切面</strong>”（Aspect），减少系统中的重复代码，降低了模块间的耦合度，同时提高了系统的可维护性。可用于权限认证、日志、事务处理等。</p> 
<h3><a id="62_AOP_536"></a>6.2 AOP与代理模式</h3> 
<p>代理模式参考: <a href="https://www.jianshu.com/p/f56e123817b5" rel="nofollow">Java中的静态代理和动态代理</a><br> <strong>AOP的实现</strong><br> AOP实现的关键在于<strong>代理模式</strong>，AOP代理主要分为静态代理和动态代理。静态代理的代表为AspectJ；动态代理则以Spring AOP为代表。<br> （1）AspectJ是静态代理的增强，所谓静态代理，就是AOP框架会在编译阶段生成AOP代理类，因此也称为编译时增强，他会在编译阶段将AspectJ(切面)织入到Java字节码中，运行的时候就是增强之后的AOP对象。<br> （2）Spring AOP使用的动态代理，所谓的动态代理，就是说AOP框架不会去修改字节码，而是每次运行时在内存中临时为方法生成一个AOP对象，这个AOP对象包含了目标对象的全部方法，并且在特定的切点做了增强处理，并回调原对象的方法。</p> 
<blockquote> 
 <p>静态代理与动态代理<strong>区别在于生成AOP代理对象的时机不同</strong>，相对来说AspectJ的静态代理方式具有更好的性能，但是AspectJ需要特定的编译器进行处理，而Spring AOP则无需特定的编译器处理。</p> 
</blockquote> 
<p><strong>JDK动态代理和CGLIB动态代理的区别</strong><br> Spring AOP中的动态代理主要有两种方式，JDK动态代理和CGLIB动态代理：</p> 
<ul><li>JDK动态代理<strong>只提供接口的代理，不支持类的代理</strong>。核心是InvocationHandler接口和Proxy类，InvocationHandler 通过invoke()方法反射来调用目标类中的代码，动态地将横切逻辑和业务编织在一起；接着，Proxy利用 InvocationHandler动态创建一个符合某一接口的的实例, 生成目标类的代理对象。</li><li>如果代理类没有实现 InvocationHandler 接口，那么Spring AOP会选择使用CGLIB来动态代理目标类。CGLIB（Code Generation Library），是一个代码生成的类库，可以在运行时动态的生成指定类的一个子类对象，并覆盖其中特定方法并添加增强代码，从而实现AOP。CGLIB是<strong>通过继承的方式</strong>做的动态代理，因此如果某个类被标记为final，那么它是无法使用CGLIB做动态代理的。</li></ul> 
<blockquote> 
 <p>InvocationHandler 的 invoke(Object proxy,Method method,Object[] args)：proxy是最终生成的代理实例; method 是被代理目标实例的某个具体方法; args 是被代理目标实例某个方法的具体入参, 在方法反射调用时使用。</p> 
</blockquote> 
<p><strong>如何理解 Spring 中的代理</strong><br> 将 Advice 应用于目标对象后创建的对象称为代理。在客户端对象的情况下，目标对象和代理对象是相同的。<br> Advice + Target Object = Proxy</p> 
<h3><a id="63_AOP_556"></a>6.3 AOP相关概念</h3> 
<p>（1）切面（Aspect）：切面是通知和切点的结合。通知和切点共同定义了切面的全部内容。 在Spring AOP中，切面可以使用通用类（基于模式的风格） 或者在普通类中以 @AspectJ 注解来实现。<br> （2）连接点（Join point）：指方法，在Spring AOP中，一个连接点 总是 代表一个方法的执行。 应用可能有数以千计的时机应用通知。这些时机被称为连接点。连接点是在应用执行过程中能够插入切面的一个点。这个点可以是调用方法时、抛出异常时、甚至修改一个字段时。切面代码可以利用这些点插入到应用的正常流程之中，并添加新的行为。<br> （3）通知（Advice）：在AOP术语中，切面的工作被称为通知。<br> （4）切入点（Pointcut）：切点的定义会匹配通知所要织入的一个或多个连接点。我们通常使用明确的类和方法名称，或是利用正则表达式定义所匹配的类和方法名称来指定这些切点。<br> （5）引入（Introduction）：引入允许我们向现有类添加新方法或属性。<br> （6）目标对象（Target Object）： 被一个或者多个切面（aspect）所通知（advise）的对象。它通常是一个代理对象。也有人把它叫做 被通知（adviced） 对象。 既然Spring AOP是通过运行时代理实现的，这个对象永远是一个 被代理（proxied） 对象。<br> （7）织入（Weaving）：织入是把切面应用到目标对象并创建新的代理对象的过程。在目标对象的生命周期里有多少个点可以进行织入：</p> 
<ul><li><strong>编译期</strong>：切面在目标类编译时被织入。AspectJ的织入编译器是以这种方式织入切面的。</li><li><strong>类加载期</strong>：切面在目标类加载到JVM时被织入。需要特殊的类加载器，它可以在目标类被引入应用之前增强该目标类的字节码。AspectJ5的加载时织入就支持以这种方式织入切面。</li><li><strong>运行期</strong>：切面在应用运行的某个时刻被织入。一般情况下，在织入切面时，AOP容器会为目标对象动态地创建一个代理对象。SpringAOP就是以这种方式织入切面。</li></ul> 
<p><strong>Spring在运行时通知对象</strong></p> 
<blockquote> 
 <p>通过在代理类中包裹切面，Spring在运行期把切面织入到Spring管理的bean中。<br> 代理封装了目标类，并拦截被通知方法的调用，再把调用转发给真正的目标bean。当代理拦截到方法调用时，在调用目标bean方法之前，会执行切面逻辑。<br> 直到应用需要被代理的bean时，Spring才创建代理对象。<br> 如果使用的是ApplicationContext的话，在ApplicationContext从BeanFactory中加载所有bean的时候，Spring才会创建被代理的对象。因为Spring运行时才创建代理对象，所以我们不需要特殊的编译器来织入Spring AOP的切面。</p> 
</blockquote> 
<p><strong>Spring只支持方法级别的连接点（Join point）</strong></p> 
<blockquote> 
 <p>因为Spring基于动态代理，所以Spring只支持方法连接点。Spring缺少对字段连接点的支持，而且它不支持构造器连接点。方法之外的连接点拦截功能，我们可以利用Aspect来补充。</p> 
</blockquote> 
<p><strong>在Spring AOP中，关注点和横切关注的区别</strong></p> 
<blockquote> 
 <p>即在 spring AOP 中 concern 和 cross-cutting concern 的不同之处：</p> 
 <ul><li>关注点（concern）是应用中一个模块的行为，一个关注点可能会被定义成一个我们想实现的一个功能。</li><li>横切关注点（cross-cutting concern）是一种特殊的关注点，此关注点是整个应用都会使用的功能，并影响整个应用，比如日志，安全和数据传输，几乎应用的每个模块都需要的功能。因此这些都属于横切关注点。</li></ul> 
</blockquote> 
<h3><a id="64_Spring_582"></a>6.4 Spring通知的类型</h3> 
<p>在AOP术语中，切面的工作被称为通知，实际上是程序执行时要通过Spring AOP框架触发的代码段。</p> 
<p><strong>Spring切面可以应用5种类型的通知：</strong></p> 
<ul><li>前置通知（Before）：在目标方法<strong>被调用之前</strong>调用通知功能；</li><li>后置通知（After）：在目标方法<strong>完成之后</strong>调用通知，此时不会关心方法的输出是什么；</li><li>返回通知（After-returning ）：在目标方法<strong>成功执行之后</strong>调用通知；</li><li>异常通知（After-throwing）：在目标方法<strong>抛出异常后</strong>调用通知；</li><li>环绕通知（Around）：通知包裹了被通知的方法，在被通知的方法<strong>调用之前和调用之后</strong>执行自定义的行为。</li></ul> 
<p><strong>同一个Aspect，不同Advice的执行顺序：</strong><br> ① 没有异常情况下的执行顺序：</p> 
<blockquote> 
 <p><strong>around before</strong> advice<br> <strong>before</strong> advice<br> target method 执行<br> <strong>around after</strong> advice<br> <strong>after</strong> advice<br> <strong>afterReturning</strong></p> 
</blockquote> 
<p>② 有异常情况下的执行顺序：</p> 
<blockquote> 
 <p><strong>around before</strong> advice<br> <strong>before</strong> advice<br> target method 执行<br> <strong>around after</strong> advice<br> <strong>after</strong> advice<br> <strong>afterThrowing</strong>:异常发生<br> java.lang.RuntimeException:异常发生</p> 
</blockquote> 
<h3><a id="65_Aspect_610"></a>6.5 切面Aspect</h3> 
<p>切面（Aspect）是切入点（Pointcut）和通知（Advice）的结合。 它既包含了横切逻辑的定义, 也包括了连接点的定义。<br> Spring AOP 就是负责实施切面的框架, 它将切面所定义的横切逻辑编织到切面所指定的连接点中。</p> 
<p>AOP 的工作重心在于如何将增强编织目标对象的连接点上, 这里包含两个工作:</p> 
<ul><li>如何通过切入点（Pointcut）和通知（Advice）定位到特定的连接点（Join point）上</li><li>如何在通知（Advice）中编写切面代码</li></ul> 
<p>可以简单地认为, 使用 @Aspect 注解的类就是切面。</p> 
<p><strong>解释基于XML Schema方式的切面实现</strong><br> 在这种情况下，切面由常规类以及基于XML的配置实现。</p> 
<p><strong>解释基于注解的切面实现</strong><br> 在这种情况下(基于@AspectJ的实现)，涉及到的切面声明的风格与带有java5标注的普通java类一致。</p> 
<p><strong>有几种不同类型的自动代理</strong></p> 
<ul><li>BeanNameAutoProxyCreator</li><li>DefaultAdvisorAutoProxyCreator</li><li>Metadata autoproxying</li></ul>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/ad14d11045cbf41f7aba24ab7c43eeb4/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">SqlServer数据库设置指定用户访问指定表</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/a8e0c9c72d34970eeb9aaec335f49ae8/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">python不改变图片尺寸压缩到指定大小</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>