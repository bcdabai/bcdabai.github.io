<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Android音量控制曲线 - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Android音量控制曲线" />
<meta property="og:description" content="本文介绍了android音量的控制曲线的计算方法。 由于人耳对声音的听感具指数曲线型，也就是对小音量时比较敏感，随着声音的加大其听感随之变的不敏感，其变化近似指数函数曲线的形式。为了使听感变的近似直线的变化，人们在实践中就采用了音量变化近似对数式曲线型的电位器来实现这个目的。对比法产生音量控制曲线与最终扬声器输出的声压有关，当然您也可以根据扬声器的输出功率来进行比对，但功率终究不如电压来的方便。音量调节框的UI滑动条的刻度是线性的，这样就给我们生成音量控制曲线打下了很好的对比基础。下面我们就来通过一个音量调节的场景来分析Android是如何控制音量的。
首先，我们按音量调节键使得media音量逐级增加到最大。STREAM_MUSIC流的音量分为15级，通过AudioManger的handleKeyDown函数调用adjustSuggestedStreamVolume设置，一路找下去，发现在AudioService中adjustSuggestedStreamVolume然后调用adjustStreamVolume，通过消息MSG_SET_SYSTEM_VOLUME调用setSystemVolume，转到AudioSystem中的setStreamVolumeIndex，再通过jni层调用本地层的AudioSystem调用AudioPolicymanagerService，最后到AudiopolicyManagerBase的setStreamVolumeIndex，接下来的由checkAndSetVolume调用computeVolume，马上就要到真相大白的时候了。volIndexToAmpl函数时真正计算音量的地方，我们一起来分析这个函数
// 在intel的CherryTrail平台的android 6.0 版本上，这个函数位置是：/frameworks/av/services/audiopolicy/engineconfigurable/src/Stream.cpp 里
float AudioPolicyManagerBase::volIndexToAmpl(audio_devices_t device, const StreamDescriptor&amp; streamDesc, int indexInUi) { device_category deviceCategory = getDeviceCategory(device); const VolumeCurvePoint *curve = streamDesc.mVolumeCurve[deviceCategory]; // the volume index in the UI is relative to the min and max volume indices for this stream type int nbSteps = 1 &#43; curve[VOLMAX].mIndex - curve[VOLMIN].mIndex;//计算预置的曲线区间的范围，这里是（1-100） ALOGI(&#34;VOLUME vol indexInUi=%d, nbSteps=%d, mIndexMin=%d, mIndexMax=%d&#34;,indexInUi,nbSteps,streamDesc.mIndexMin,streamDesc.mIndexMax); int volIdx = (nbSteps * (indexInUi - streamDesc.mIndexMin)) / (streamDesc." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/5f467f93a49216a17fc89b550b25b197/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2016-04-27T17:53:46+08:00" />
<meta property="article:modified_time" content="2016-04-27T17:53:46+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Android音量控制曲线</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    本文介绍了android音量的控制曲线的计算方法。 
<p>　　由于人耳对声音的听感具指数曲线型，也就是对小音量时比较敏感，随着声音的加大其听感随之变的不敏感，其变化近似指数函数曲线的形式。为了使听感变的近似直线的变化，人们在实践中就采用了音量变化近似对数式曲线型的电位器来实现这个目的。对比法产生音量控制曲线与最终扬声器输出的声压有关，当然您也可以根据扬声器的输出功率来进行比对，但功率终究不如电压来的方便。音量调节框的UI滑动条的刻度是线性的，这样就给我们生成音量控制曲线打下了很好的对比基础。下面我们就来通过一个音量调节的场景来分析Android是如何控制音量的。</p> 
<p>　　首先，我们按音量调节键使得media音量逐级增加到最大。STREAM_MUSIC流的音量分为15级，通过AudioManger的handleKeyDown函数调用adjustSuggestedStreamVol<wbr></wbr>ume设置，一路找下去，发现在AudioService中adjustSuggestedStreamVol<wbr></wbr>ume然后调用adjustStreamVolume，通过消息MSG_SET_SYSTEM_VOLUME调用setSystemVolume，转到AudioSystem中的setStreamVolumeIndex，再通过jni层调用本地层的AudioSystem调用AudioPolicymanagerServic<wbr></wbr>e，最后到AudiopolicyManagerBase的setStreamVolumeIndex，接下来的由checkAndSetVolume调用computeVolume，马上就要到真相大白的时候了。volIndexToAmpl函数时真正计算音量的地方，我们一起来分析这个函数</p> 
<p> <wbr></wbr></p> 
<p>//  在intel的CherryTrail平台的android 6.0 版本上，这个函数位置是：/frameworks/av/services/audiopolicy/engineconfigurable/src/Stream.cpp 里<br> </p> 
<p><br> </p> 
<ol><li>float <wbr></wbr>AudioPolicyManagerBase::volIndexToAmpl(audio_devices_t <wbr></wbr>device, <wbr></wbr>const <wbr></wbr>StreamDescriptor&amp; <wbr></wbr>streamDesc, <wbr></wbr></li><li> <wbr></wbr> <wbr></wbr> <wbr></wbr> <wbr></wbr> <wbr></wbr> <wbr></wbr> <wbr></wbr> <wbr></wbr> <wbr></wbr>int <wbr></wbr>indexInUi) <wbr></wbr></li><li> <wbr></wbr>{ <wbr></wbr></li><li> <wbr></wbr> <wbr></wbr> <wbr></wbr> <wbr></wbr> <wbr></wbr>device_category <wbr></wbr>deviceCategory <wbr></wbr>= <wbr></wbr>getDeviceCategory(device); <wbr></wbr></li><li> <wbr></wbr> <wbr></wbr> <wbr></wbr> <wbr></wbr> <wbr></wbr>const <wbr></wbr>VolumeCurvePoint <wbr></wbr>*curve <wbr></wbr>= <wbr></wbr>streamDesc.mVolumeCurve[deviceCategory]; <wbr></wbr></li><li> <wbr></wbr> <wbr></wbr></li><li> <wbr></wbr> <wbr></wbr> <wbr></wbr> <wbr></wbr> <wbr></wbr>// <wbr></wbr>the <wbr></wbr>volume <wbr></wbr>index <wbr></wbr>in <wbr></wbr>the <wbr></wbr>UI <wbr></wbr>is <wbr></wbr>relative <wbr></wbr>to <wbr></wbr>the <wbr></wbr>min <wbr></wbr>and <wbr></wbr>max <wbr></wbr>volume <wbr></wbr>indices <wbr></wbr>for <wbr></wbr>this <wbr></wbr>stream <wbr></wbr>type <wbr></wbr></li><li> <wbr></wbr> <wbr></wbr> <wbr></wbr> <wbr></wbr> <wbr></wbr>int <wbr></wbr>nbSteps <wbr></wbr>= <wbr></wbr>1 <wbr></wbr>+ <wbr></wbr>curve[VOLMAX].mIndex <wbr></wbr>- <wbr></wbr></li><li> <wbr></wbr> <wbr></wbr> <wbr></wbr> <wbr></wbr> <wbr></wbr> <wbr></wbr> <wbr></wbr> <wbr></wbr> <wbr></wbr> <wbr></wbr> <wbr></wbr> <wbr></wbr> <wbr></wbr>curve[VOLMIN].mIndex;//计算预置的曲线区间的范围，这里是（1-100） <wbr></wbr></li><li> <wbr></wbr> <wbr></wbr> <wbr></wbr> <wbr></wbr> <wbr></wbr>ALOGI("VOLUME <wbr></wbr>vol <wbr></wbr>indexInUi=%d, <wbr></wbr>nbSteps=%d, <wbr></wbr>mIndexMin=%d, <wbr></wbr>mIndexMax=%d",indexInUi,nbSteps,streamDesc.mIndexMin,streamDesc.mIndexMax); <wbr></wbr></li><li> <wbr></wbr> <wbr></wbr> <wbr></wbr> <wbr></wbr> <wbr></wbr>int <wbr></wbr>volIdx <wbr></wbr>= <wbr></wbr>(nbSteps <wbr></wbr>* <wbr></wbr>(indexInUi <wbr></wbr>- <wbr></wbr>streamDesc.mIndexMin)) <wbr></wbr>/ <wbr></wbr></li><li> <wbr></wbr> <wbr></wbr> <wbr></wbr> <wbr></wbr> <wbr></wbr> <wbr></wbr> <wbr></wbr> <wbr></wbr> <wbr></wbr> <wbr></wbr> <wbr></wbr> <wbr></wbr> <wbr></wbr>(streamDesc.mIndexMax <wbr></wbr>- <wbr></wbr>streamDesc.mIndexMin);//（由传进来的UIIndex计算百分比的index，比如现在是第一级 <wbr></wbr>100*（1-0）/（15-0）=6） <wbr></wbr></li><li> <wbr></wbr> <wbr></wbr></li><li> <wbr></wbr> <wbr></wbr> <wbr></wbr> <wbr></wbr> <wbr></wbr>// <wbr></wbr>find <wbr></wbr>what <wbr></wbr>part <wbr></wbr>of <wbr></wbr>the <wbr></wbr>curve <wbr></wbr>this <wbr></wbr>index <wbr></wbr>volume <wbr></wbr>belongs <wbr></wbr>to, <wbr></wbr>or <wbr></wbr>if <wbr></wbr>it's <wbr></wbr>out <wbr></wbr>of <wbr></wbr>bounds <wbr></wbr></li><li> <wbr></wbr> <wbr></wbr> <wbr></wbr> <wbr></wbr> <wbr></wbr>int <wbr></wbr>segment <wbr></wbr>= <wbr></wbr>0; <wbr></wbr></li><li> <wbr></wbr> <wbr></wbr> <wbr></wbr> <wbr></wbr> <wbr></wbr>if <wbr></wbr>(volIdx <wbr></wbr>&lt; <wbr></wbr>curve[VOLMIN].mIndex) <wbr></wbr>{ <wbr></wbr> <wbr></wbr> <wbr></wbr> <wbr></wbr> <wbr></wbr> <wbr></wbr> <wbr></wbr> <wbr></wbr> <wbr></wbr>// <wbr></wbr>out <wbr></wbr>of <wbr></wbr>bounds <wbr></wbr></li><li> <wbr></wbr> <wbr></wbr> <wbr></wbr> <wbr></wbr> <wbr></wbr> <wbr></wbr> <wbr></wbr> <wbr></wbr> <wbr></wbr>return <wbr></wbr>0.0f; <wbr></wbr></li><li> <wbr></wbr> <wbr></wbr> <wbr></wbr> <wbr></wbr> <wbr></wbr>} <wbr></wbr>else <wbr></wbr>if <wbr></wbr>(volIdx <wbr></wbr>&lt; <wbr></wbr>curve[VOLKNEE1].mIndex) <wbr></wbr>{ <wbr></wbr></li><li> <wbr></wbr> <wbr></wbr> <wbr></wbr> <wbr></wbr> <wbr></wbr> <wbr></wbr> <wbr></wbr> <wbr></wbr> <wbr></wbr>segment <wbr></wbr>= <wbr></wbr>0; <wbr></wbr></li><li> <wbr></wbr> <wbr></wbr> <wbr></wbr> <wbr></wbr> <wbr></wbr>} <wbr></wbr>else <wbr></wbr>if <wbr></wbr>(volIdx <wbr></wbr>&lt; <wbr></wbr>curve[VOLKNEE2].mIndex) <wbr></wbr>{ <wbr></wbr></li><li> <wbr></wbr> <wbr></wbr> <wbr></wbr> <wbr></wbr> <wbr></wbr> <wbr></wbr> <wbr></wbr> <wbr></wbr> <wbr></wbr>segment <wbr></wbr>= <wbr></wbr>1; <wbr></wbr></li><li> <wbr></wbr> <wbr></wbr> <wbr></wbr> <wbr></wbr> <wbr></wbr>} <wbr></wbr>else <wbr></wbr>if <wbr></wbr>(volIdx <wbr></wbr>&lt;= <wbr></wbr>curve[VOLMAX].mIndex) <wbr></wbr>{ <wbr></wbr></li><li> <wbr></wbr> <wbr></wbr> <wbr></wbr> <wbr></wbr> <wbr></wbr> <wbr></wbr> <wbr></wbr> <wbr></wbr> <wbr></wbr>segment <wbr></wbr>= <wbr></wbr>2; <wbr></wbr></li><li> <wbr></wbr> <wbr></wbr> <wbr></wbr> <wbr></wbr> <wbr></wbr>} <wbr></wbr>else <wbr></wbr>{ <wbr></wbr> <wbr></wbr> <wbr></wbr> <wbr></wbr> <wbr></wbr> <wbr></wbr> <wbr></wbr> <wbr></wbr> <wbr></wbr> <wbr></wbr> <wbr></wbr> <wbr></wbr> <wbr></wbr> <wbr></wbr> <wbr></wbr> <wbr></wbr> <wbr></wbr> <wbr></wbr> <wbr></wbr> <wbr></wbr> <wbr></wbr> <wbr></wbr> <wbr></wbr> <wbr></wbr> <wbr></wbr> <wbr></wbr> <wbr></wbr> <wbr></wbr> <wbr></wbr> <wbr></wbr> <wbr></wbr> <wbr></wbr> <wbr></wbr> <wbr></wbr> <wbr></wbr> <wbr></wbr> <wbr></wbr> <wbr></wbr> <wbr></wbr> <wbr></wbr> <wbr></wbr> <wbr></wbr> <wbr></wbr> <wbr></wbr> <wbr></wbr> <wbr></wbr> <wbr></wbr> <wbr></wbr> <wbr></wbr> <wbr></wbr> <wbr></wbr> <wbr></wbr> <wbr></wbr> <wbr></wbr> <wbr></wbr> <wbr></wbr> <wbr></wbr> <wbr></wbr> <wbr></wbr> <wbr></wbr> <wbr></wbr> <wbr></wbr> <wbr></wbr>// <wbr></wbr>out <wbr></wbr>of <wbr></wbr>bounds <wbr></wbr></li><li> <wbr></wbr> <wbr></wbr> <wbr></wbr> <wbr></wbr> <wbr></wbr> <wbr></wbr> <wbr></wbr> <wbr></wbr> <wbr></wbr>return <wbr></wbr>1.0f; <wbr></wbr></li><li> <wbr></wbr> <wbr></wbr> <wbr></wbr> <wbr></wbr> <wbr></wbr>} <wbr></wbr></li><li> <wbr></wbr>//第一极6是在区间VOLKNEE1之间，其区间表是在AudioPolicyManager初始化的时候就已经加载，因此它对应的segment为0 <wbr></wbr></li><li> <wbr></wbr> <wbr></wbr> <wbr></wbr> <wbr></wbr> <wbr></wbr>// <wbr></wbr>linear <wbr></wbr>interpolation <wbr></wbr>in <wbr></wbr>the <wbr></wbr>attenuation <wbr></wbr>table <wbr></wbr>in <wbr></wbr>dB <wbr></wbr></li><li> <wbr></wbr> <wbr></wbr> <wbr></wbr> <wbr></wbr> <wbr></wbr>float <wbr></wbr>decibels <wbr></wbr>= <wbr></wbr>curve[segment].mDBAttenuation <wbr></wbr>+ <wbr></wbr></li><li> <wbr></wbr> <wbr></wbr> <wbr></wbr> <wbr></wbr> <wbr></wbr> <wbr></wbr> <wbr></wbr> <wbr></wbr> <wbr></wbr> <wbr></wbr> <wbr></wbr> <wbr></wbr> <wbr></wbr>((float)(volIdx <wbr></wbr>- <wbr></wbr>curve[segment].mIndex)) <wbr></wbr>* <wbr></wbr></li><li> <wbr></wbr> <wbr></wbr> <wbr></wbr> <wbr></wbr> <wbr></wbr> <wbr></wbr> <wbr></wbr> <wbr></wbr> <wbr></wbr> <wbr></wbr> <wbr></wbr> <wbr></wbr> <wbr></wbr> <wbr></wbr> <wbr></wbr> <wbr></wbr> <wbr></wbr>( <wbr></wbr>(curve[segment+1].mDBAttenuation <wbr></wbr>- <wbr></wbr></li><li> <wbr></wbr> <wbr></wbr> <wbr></wbr> <wbr></wbr> <wbr></wbr> <wbr></wbr> <wbr></wbr> <wbr></wbr> <wbr></wbr> <wbr></wbr> <wbr></wbr> <wbr></wbr> <wbr></wbr> <wbr></wbr> <wbr></wbr> <wbr></wbr> <wbr></wbr> <wbr></wbr> <wbr></wbr> <wbr></wbr> <wbr></wbr> <wbr></wbr> <wbr></wbr> <wbr></wbr> <wbr></wbr>curve[segment].mDBAttenuation) <wbr></wbr>/ <wbr></wbr></li><li> <wbr></wbr> <wbr></wbr> <wbr></wbr> <wbr></wbr> <wbr></wbr> <wbr></wbr> <wbr></wbr> <wbr></wbr> <wbr></wbr> <wbr></wbr> <wbr></wbr> <wbr></wbr> <wbr></wbr> <wbr></wbr> <wbr></wbr> <wbr></wbr> <wbr></wbr> <wbr></wbr> <wbr></wbr> <wbr></wbr> <wbr></wbr>((float)(curve[segment+1].mIndex <wbr></wbr>- <wbr></wbr></li><li> <wbr></wbr> <wbr></wbr> <wbr></wbr> <wbr></wbr> <wbr></wbr> <wbr></wbr> <wbr></wbr> <wbr></wbr> <wbr></wbr> <wbr></wbr> <wbr></wbr> <wbr></wbr> <wbr></wbr> <wbr></wbr> <wbr></wbr> <wbr></wbr> <wbr></wbr> <wbr></wbr> <wbr></wbr> <wbr></wbr> <wbr></wbr> <wbr></wbr> <wbr></wbr> <wbr></wbr> <wbr></wbr> <wbr></wbr> <wbr></wbr> <wbr></wbr> <wbr></wbr>curve[segment].mIndex)) <wbr></wbr>); <wbr></wbr></li><li> <wbr></wbr>//计算衰减分贝数 <wbr></wbr>curve[0].db <wbr></wbr>+ <wbr></wbr>该区间每一级index对应的db*index数 <wbr></wbr> <wbr></wbr> <wbr></wbr></li><li> <wbr></wbr> <wbr></wbr> <wbr></wbr> <wbr></wbr> <wbr></wbr>float <wbr></wbr>amplification <wbr></wbr>= <wbr></wbr>exp( <wbr></wbr>decibels <wbr></wbr>* <wbr></wbr>0.115129f); <wbr></wbr>// <wbr></wbr>exp( <wbr></wbr>dB <wbr></wbr>* <wbr></wbr>ln(10) <wbr></wbr>/ <wbr></wbr>20 <wbr></wbr>) <wbr></wbr></li><li>//由指数公式计算出音量amplification <wbr></wbr>db <wbr></wbr>= <wbr></wbr>20log(V/Vmax) <wbr></wbr> <wbr></wbr>linearToLog <wbr></wbr>Vmax是一个参考值 <wbr></wbr></li><li> <wbr></wbr> <wbr></wbr> <wbr></wbr> <wbr></wbr> <wbr></wbr>ALOGI("VOLUME <wbr></wbr>vol <wbr></wbr>index=[%d <wbr></wbr>%d <wbr></wbr>%d], <wbr></wbr>dB=[%.1f <wbr></wbr>%.1f <wbr></wbr>%.1f] <wbr></wbr>ampl=%.5f", <wbr></wbr></li><li> <wbr></wbr> <wbr></wbr> <wbr></wbr> <wbr></wbr> <wbr></wbr> <wbr></wbr> <wbr></wbr> <wbr></wbr> <wbr></wbr> <wbr></wbr> <wbr></wbr> <wbr></wbr> <wbr></wbr>curve[segment].mIndex, <wbr></wbr>volIdx, <wbr></wbr></li><li> <wbr></wbr> <wbr></wbr> <wbr></wbr> <wbr></wbr> <wbr></wbr> <wbr></wbr> <wbr></wbr> <wbr></wbr> <wbr></wbr> <wbr></wbr> <wbr></wbr> <wbr></wbr> <wbr></wbr>curve[segment+1].mIndex, <wbr></wbr></li><li> <wbr></wbr> <wbr></wbr> <wbr></wbr> <wbr></wbr> <wbr></wbr> <wbr></wbr> <wbr></wbr> <wbr></wbr> <wbr></wbr> <wbr></wbr> <wbr></wbr> <wbr></wbr> <wbr></wbr>curve[segment].mDBAttenuation, <wbr></wbr></li><li> <wbr></wbr> <wbr></wbr> <wbr></wbr> <wbr></wbr> <wbr></wbr> <wbr></wbr> <wbr></wbr> <wbr></wbr> <wbr></wbr> <wbr></wbr> <wbr></wbr> <wbr></wbr> <wbr></wbr>decibels, <wbr></wbr></li><li> <wbr></wbr> <wbr></wbr> <wbr></wbr> <wbr></wbr> <wbr></wbr> <wbr></wbr> <wbr></wbr> <wbr></wbr> <wbr></wbr> <wbr></wbr> <wbr></wbr> <wbr></wbr> <wbr></wbr>curve[segment+1].mDBAttenuation, <wbr></wbr></li><li> <wbr></wbr> <wbr></wbr> <wbr></wbr> <wbr></wbr> <wbr></wbr> <wbr></wbr> <wbr></wbr> <wbr></wbr> <wbr></wbr> <wbr></wbr> <wbr></wbr> <wbr></wbr> <wbr></wbr>amplification); <wbr></wbr></li><li> <wbr></wbr> <wbr></wbr></li><li> <wbr></wbr> <wbr></wbr> <wbr></wbr> <wbr></wbr> <wbr></wbr>return <wbr></wbr>amplification; <wbr></wbr></li><li> <wbr></wbr>} <wbr></wbr></li></ol> 
<p> <wbr></wbr>  <wbr></wbr>然后通过以上函数计算后得到一个0-1之间的float音量值，最后通过mpClientInterface-&gt;setStreamVolume设置到audioflinger中的mStreamTypes[stream].value,在prepareTracks_l中将音量值传入到audiomixer中混合。至此音量调节的全过程介绍完毕，下面六个附表是在AudioPolicyManagerBase中预置的六个音量曲线db分布表</p> 
<table border="0" style="border:0px solid rgb(0,0,0); width:1000px; height:50px"><tbody><tr><td>音量刻度</td><td>1</td><td>33</td><td>66</td><td>100</td></tr><tr><td>输出衰减量db</td><td>-49.5</td><td>-33.5</td><td>-17.0</td><td>0.0</td></tr></tbody></table> 
<p style="text-align:center">表1-1 default volume curve</p> 
<table border="0" style="border:0px solid rgb(0,0,0); width:1000px; height:50px"><tbody><tr><td>音量刻度</td><td>1</td><td>20</td><td>60</td><td>100</td></tr><tr><td>输出衰减量db</td><td>-58.0</td><td>-40.0</td><td>-17.0</td><td>0.0</td></tr></tbody></table> 
<p style="text-align:center">表1-2 default media volume curve</p> 
<table border="0" style="border:0px solid rgb(0,0,0); width:1000px; height:50px"><tbody><tr><td>音量刻度</td><td>1</td><td>20</td><td>60</td><td>100</td></tr><tr><td>输出衰减量db</td><td>-56.0</td><td>-34.0</td><td>-11.0</td><td>0.0</td></tr></tbody></table> 
<p style="text-align:center">表1-3 speaker media volume curve</p> 
<table border="0" style="border:0px solid rgb(0,0,0); width:1000px; height:50px"><tbody><tr><td>音量刻度</td><td>1</td><td>33</td><td>66</td><td>100</td></tr><tr><td>输出衰减量db</td><td>-29.7</td><td>-20.1</td><td>-10.2</td><td>0.0</td></tr></tbody></table> 
<p style="text-align:center">表1-4 speaker sonification volumecurve</p> 
<table border="0" style="border:0px solid rgb(0,0,0); width:1000px; height:50px"><tbody><tr><td>音量刻度</td><td>1</td><td>33</td><td>66</td><td>100</td></tr><tr><td>输出衰减量db</td><td>-24.0</td><td>-18.0</td><td>-12.0</td><td>-6.0</td></tr></tbody></table> 
<p style="text-align:center">表1-5 default system volume curve</p> 
<table border="0" style="border:0px solid rgb(0,0,0); width:1000px; height:50px"><tbody><tr><td>音量刻度</td><td>1</td><td>33</td><td>66</td><td>100</td></tr><tr><td>输出衰减量db</td><td>-30.0</td><td>-26.0</td><td>-22.0</td><td>-18.0</td></tr></tbody></table> 
<p style="text-align:center">表1-6 headset system volume curve</p> 
<p style="text-align:left"><strong>　　总结：</strong>通过调节音量键这一调节音量的场景，从java层，media本地层，AudioFlinger服务层，硬件抽象层等四层分析音量调节函数是如何完成一个音量调节任务的。总结了从线性UI的Index如何转化为对数关系的人耳的听觉转换的公式，以及预置的区间表，根据不同的硬件，我们可以自己预置适当的区间表，使得音量曲线更符合我们的听感。</p> 
<p style="text-align:left"><br> </p> 
<p style="text-align:left">        在intel的 CherryTrail平台上，是用volume.pfw文件来配置这个三段音量dB值对应曲线的。</p> 
<p style="text-align:left">        位置是：/device/intel/common/audio/parameter-framework/Settings/Policy/volumes.pfw</p> 
<p style="text-align:left"><br> </p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/9475442286b640be7801801676915aae/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">Android gitignore文件解析</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/a5919e87c2a83398f8003b69d5503bee/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">tez跑任务报错</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>