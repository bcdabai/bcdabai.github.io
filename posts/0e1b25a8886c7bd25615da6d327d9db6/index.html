<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Node.js的学习 - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Node.js的学习" />
<meta property="og:description" content="Node.js是什么 原生js是不能脱离浏览器运行的，而Node.js就能够让js脱离浏览器运行在服务器上。
简而言之，Node.js就是运行在服务端的JavaScript。
Node是V8引擎的容器，Node.js是基于Google的V8引擎的。
nodejs是用C&#43;&#43;开发的一种运行于服务器端的语言，node的底层是C&#43;&#43;，是可以直接运行在电脑上的。
Node.js的作用
编译js代码读、写电脑上的文件连接数据库充当Web服务器
回调函数 Node.js 异步编程的直接体现就是回调。异步编程依托于回调来实现，但不能说使用了回调后程序就异步化。
异步与回调的关系
关联
异步任务需要在得到结果时通知JS来读取结果。等待通知的过程就是异步，通知JS读取结果的过程就是回调。
区别
异步任务需要用到回调函数来通知结果；
回调函数却不一定存在于异步任务中，同步任务中也可以用到回调函数。
回调函数就是自己写了却不调用，给别人调用的函数。
EventEmitter Node.js 所有的异步 I/O 操作在完成时都会发送一个事件到事件队列。
Node.js 里面的许多对象都会分发事件：一个 net.Server 对象会在每次有新连接时触发一个事件，一个 fs.readStream 对象会在文件被打开的时候触发一个事件。
所有这些产生事件的对象都是 events.EventEmitter 的实例。
EventEmitter 类：
events 模块只提供了一个对象： events.EventEmitter。EventEmitter的核心就是事件触发与事件监听器功能的封装。
EventEmitter 的每个事件由一个事件名和若干个参数组成，事件名是一个字符串，通常表达一定的语义。对于每个事件，EventEmitter 支持若干个事件监听器。
当事件触发时，注册到这个事件的事件监听器被依次调用，事件参数作为回调函数参数传递。
继承EventEmitter：
大多数时候我们不会直接使用 EventEmitter，而是在对象中继承它。包括 fs、net、 http 在内的，只要是支持事件响应的核心模块都是 EventEmitter 的子类。
Buffer(缓冲区) JavaScript 语言自身只有字符串数据类型，没有二进制数据类型。
Buffer 库为 Node.js 带来了一种存储原始数据的方法，可以让 Node.js 处理二进制数据。
创建Buffer类Buffer.alloc()_Buffer.from()写入缓冲区buf.write()从缓冲区读取数据buf.toString()将Buffer转换为JSON对象buf.toJSON()缓冲区合并Buffer.concat()缓冲区比较buf.compare()复制缓冲区buf.copy()剪裁缓冲区buf.slice()缓冲区长度buf.length Stream Stream 是一个抽象接口，Node 中有很多对象实现了这个接口。
四种流类型：
Readable - 可读操作。Writable - 可写操作。Duplex - 可读可写操作。Transform - 操作被写入数据，然后读出结果。 常用的事件有：" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/0e1b25a8886c7bd25615da6d327d9db6/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-07-27T18:14:15+08:00" />
<meta property="article:modified_time" content="2022-07-27T18:14:15+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Node.js的学习</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-light">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <h3><a id="Nodejs_0"></a>Node.js是什么</h3> 
<hr> 
<p>原生js是不能脱离浏览器运行的，而Node.js就能够让js脱离浏览器运行在服务器上。</p> 
<p>简而言之，<em>Node.js就是运行在服务端的JavaScript</em>。</p> 
<p>Node是V8引擎的容器，Node.js是基于Google的V8引擎的。</p> 
<p>nodejs是用C++开发的一种运行于服务器端的语言，node的底层是C++，是可以直接运行在电脑上的。</p> 
<p><strong>Node.js的作用</strong></p> 
<ul><li>编译js代码</li><li>读、写电脑上的文件</li><li>连接数据库</li><li>充当Web服务器<br> <img src="https://images2.imgbox.com/37/10/S0ZQ6pL5_o.png" alt="js代码经过nodejs在电脑上运行的流程"></li></ul> 
<h3><a id="_19"></a>回调函数</h3> 
<hr> 
<p>Node.js 异步编程的直接体现就是回调。异步编程依托于回调来实现，但不能说使用了回调后程序就异步化。</p> 
<p><strong>异步与回调的关系</strong></p> 
<ol><li> <p>关联<br> 异步任务需要在得到结果时通知JS来读取结果。等待通知的过程就是异步，通知JS读取结果的过程就是回调。</p> </li><li> <p>区别<br> 异步任务需要用到回调函数来通知结果；<br> 回调函数却不一定存在于异步任务中，同步任务中也可以用到回调函数。</p> </li></ol> 
<p><em><strong>回调函数就是自己写了却不调用，给别人调用的函数。</strong></em></p> 
<h3><a id="EventEmitter_34"></a>EventEmitter</h3> 
<hr> 
<p>Node.js 所有的异步 I/O 操作在完成时都会发送一个事件到事件队列。</p> 
<p>Node.js 里面的许多对象都会分发事件：一个 net.Server 对象会在每次有新连接时触发一个事件，一个 fs.readStream 对象会在文件被打开的时候触发一个事件。<br> <em>所有这些产生事件的对象都是 events.EventEmitter 的实例。</em></p> 
<p><strong>EventEmitter 类：</strong><br> events 模块只提供了一个对象： <kbd>events.EventEmitter</kbd>。EventEmitter的核心就是事件触发与事件监听器功能的封装。</p> 
<p>EventEmitter 的每个事件由一个事件名和若干个参数组成，事件名是一个字符串，通常表达一定的语义。对于每个事件，EventEmitter 支持若干个事件监听器。</p> 
<p>当事件触发时，注册到这个事件的事件监听器被依次调用，事件参数作为回调函数参数传递。</p> 
<p><strong>继承EventEmitter：</strong><br> 大多数时候我们不会直接使用 EventEmitter，而是在对象中继承它。包括 fs、net、 http 在内的，只要是支持事件响应的核心模块都是 EventEmitter 的子类。</p> 
<h3><a id="Buffer_52"></a>Buffer(缓冲区)</h3> 
<hr> 
<p>JavaScript 语言自身只有字符串数据类型，没有二进制数据类型。</p> 
<p>Buffer 库为 Node.js 带来了一种存储原始数据的方法，可以让 Node.js 处理二进制数据。</p> 
<table><thead><tr><th></th><th></th></tr></thead><tbody><tr><td>创建Buffer类</td><td>Buffer.alloc()_Buffer.from()</td></tr><tr><td>写入缓冲区</td><td>buf.write()</td></tr><tr><td>从缓冲区读取数据</td><td>buf.toString()</td></tr><tr><td>将Buffer转换为JSON对象</td><td>buf.toJSON()</td></tr><tr><td>缓冲区合并</td><td>Buffer.concat()</td></tr><tr><td>缓冲区比较</td><td>buf.compare()</td></tr><tr><td>复制缓冲区</td><td>buf.copy()</td></tr><tr><td>剪裁缓冲区</td><td>buf.slice()</td></tr><tr><td>缓冲区长度</td><td>buf.length</td></tr></tbody></table> 
<h3><a id="Stream_70"></a>Stream</h3> 
<hr> 
<p>Stream 是一个抽象接口，Node 中有很多对象实现了这个接口。</p> 
<p><strong>四种流类型：</strong></p> 
<ul><li>Readable - 可读操作。</li><li>Writable - 可写操作。</li><li>Duplex - 可读可写操作。</li><li>Transform - 操作被写入数据，然后读出结果。</li></ul> 
<p><strong>常用的事件有：</strong></p> 
<ul><li>data - 当有数据可读时触发。</li><li>end - 没有更多的数据可读时触发。</li><li>error - 在接收和写入过程中发生错误时触发。</li><li>finish - 所有数据已被写入到底层系统时触发。</li></ul> 
<pre><code>var fs = require("fs");
var data = '';
// 创建可读流
var readerStream = fs.createReadStream('input.txt');
// 设置编码为 utf8。
readerStream.setEncoding('UTF8');
// 处理流事件 --&gt; data, end, and error
readerStream.on('data', function(chunk) {
   data += chunk;
});
</code></pre> 
<pre><code>var fs = require("fs");
var data = '写入文件数据内容';
// 创建一个可以写入的流
var writerStream = fs.createWriteStream('output.txt');
// 使用 utf8 编码写入数据
writerStream.write(data,'UTF8');
// 标记文件末尾
writerStream.end();
</code></pre> 
<p><strong>管道流</strong></p> 
<p>管道提供了一个输出流到输入流的机制。通常我们用于从一个流中获取数据并将数据传递到另外一个流中。</p> 
<pre><code>var fs = require("fs");
// 创建一个可读流
var readerStream = fs.createReadStream('input.txt');
// 创建一个写入流
var writerStream = fs.createWriteStream('output.txt');
// 管道读写操作
readerStream.pipe(writerStream);
</code></pre> 
<p><strong>链式流</strong></p> 
<p>链式是通过连接输出流到另外一个流并创建多个流操作链的机制。链式流一般用于管道操作。</p> 
<pre><code>var fs = require("fs");
var zlib = require('zlib');

// 压缩 input.txt 文件为 input.txt.gz
fs.createReadStream('input.txt')
  .pipe(zlib.createGzip())
  .pipe(fs.createWriteStream('input.txt.gz'));
  
// 解压 input.txt.gz 文件为 input.txt
fs.createReadStream('input.txt.gz')
  .pipe(zlib.createGunzip())
  .pipe(fs.createWriteStream('input.txt'));
</code></pre> 
<h3><a id="_139"></a>模块系统</h3> 
<hr> 
<ul><li>模块是Node.js 应用程序的基本组成部分。</li><li>文件和模块是一一对应的，<em>一个 Node.js 文件就是一个模块</em>，这个文件可以是JavaScript 代码、JSON。</li></ul> 
<p><strong>Node.js 提供了exports和require两个对象，其中<kbd>exports</kbd>是模块公开的接口，<kbd>require</kbd>用于从外部获取一个模块的接口，即所获取模块的 exports 对象。</strong></p> 
<p>引入当前目录的模块：</p> 
<pre><code>var helloWorld= require('./helloWorld');
</code></pre> 
<p>hello.js 通过 exports 对象把 world 作为模块的访问接口，通过 <kbd>require(‘./hello’)</kbd>加载这个模块后，就可以直接访问hello.js 中exports对象的成员函数。</p> 
<pre><code>//hello.js
exports.world = () =&gt; {
    console.log("hello world!");
    this.saySomething = () =&gt;{
        console.log("hello world222222");
    }
    this.saySomething();
}
//main.js
const hello = require('./hello');
hello.world();
</code></pre> 
<p>使用<kbd>module.exports = Hello</kbd>代替<kbd>exports.world = function(){}</kbd>，在外部引用该模块时，其接口对象就是要输出的 Hello 对象本身，而不是原先的 exports。</p> 
<pre><code>//hello.js
function Hello() { 
    var name; 
    this.setName = function(thyName) { 
        name = thyName; 
    }; 
    this.sayHello = function() { 
        console.log('Hello ' + name); 
    }; 
}; 
module.exports = Hello;
//main.js
var Hello = require('./hello'); 
hello = new Hello(); 
hello.setName('Wocccccc'); 
hello.sayHello(); 
</code></pre> 
<p>把一个对象封装到模块中：</p> 
<pre><code>//hello.js
module.exports = () =&gt; {
    console.log("hello world!");
    this.saySomething = "hhhhhhhha";
    this.world = () =&gt;{
        console.log("??????");
    }
}
//main.js
var Hello = require('./hello'); 
hello = new Hello();
console.log(hello.saySomething);
hello.world();
</code></pre> 
<p><strong>Node.js 中存在 4 类模块（原生模块和3种文件模块）:</strong></p> 
<ul><li>http、fs、path等，原生模块。</li><li>./mod或…/mod，相对路径的文件模块。</li><li>/pathtomodule/mod，绝对路径的文件模块。</li><li>mod，非原生模块的文件模块。</li></ul> 
<p><em>注：<br> -exports 和 module.exports 的使用：<br> 如果要对外暴露属性或方法，就用 exports 就行，要暴露对象就用 module.exports；<br> -若同时使用 exports 和 module.exports：<br> 如果先使用 exports 对外暴露属性或方法，再使用 module.exports 暴露对象，会使得 exports 上暴露的属性或者方法失效。</em></p> 
<h3><a id="_212"></a>函数</h3> 
<hr> 
<p>一个函数可以作为另一个函数的参数。我们可以先定义一个函数，然后传递；</p> 
<pre><code>function say(word) {
    console.log(word);
}
function execute(someFunction, value) {
    someFunction(value);
}
execute(say, "Hello");
</code></pre> 
<p>也可以在传递参数的地方直接定义函数。</p> 
<pre><code>//匿名函数
const hello = (say, value)=&gt;{
    say(value);
};
hello((word)=&gt;{console.log(word);}, "hello");
</code></pre> 
<h3><a id="_233"></a>全局对象</h3> 
<hr> 
<p>Node.js中的全局对象是global，所有全局变量（global自身除外）都是 global对象的属性。</p> 
<p>global最根本的作用是作为全局变量的宿主。当你定义一个全局变量时，这个变量同时也会成为全局对象的属性。</p> 
<p>最好不要使用<kbd>var</kbd>定义变量以避免引入全局变量，因为全局变量会污染命名空间，提高代码的耦合风险。</p> 
<table><thead><tr><th align="left"></th></tr></thead><tbody><tr><td align="left"><code>__filename</code>表示当前正在执行的脚本的文件名。它将输出文件所在位置的绝对路径，且和命令行参数所指定的文件名不一定相同。 如果在模块中，返回的值是模块文件的路径0。</td></tr><tr><td align="left"><code>__dirname</code>表示当前执行脚本所在的目录。</td></tr><tr><td align="left"><code>setTimeout(function, ms)</code>全局函数在指定的毫秒数后执行函数function。setTimeout()只执行一次指定函数。</td></tr><tr><td align="left"><code>clearTimeout(T)</code>全局函数用于停止一个之前通过 setTimeout()创建的定时器 T。</td></tr><tr><td align="left"><code>setInterval(function, ms)</code>全局函数在指定的毫秒(ms)数后执行函数function。</td></tr><tr><td align="left"><code>clearInterval(T)</code>函数来清除定时器，setInterval()方法会不停地调用函数，直到 clearInterval()被调用或窗口被关闭。</td></tr><tr><td align="left"><code>console</code>用于提供控制台标准输出。</td></tr><tr><td align="left"><code>process</code>是一个全局变量，即global对象的属性。</td></tr></tbody></table> 
<hr> 
<ul><li>util.callbackify(original)</li><li>util.inherits(constructor, superConstructor)</li><li>util.inspect(object,[showHidden],[depth],[colors])</li><li>util.isArray(object)</li><li>util.isRegExp(object)</li><li>util.isDate(object)</li></ul> 
<h3><a id="_260"></a>文件系统</h3> 
<hr> 
<p>Node导入文件系统模块：</p> 
<pre><code>var fs = require("fs")
</code></pre> 
<p><strong>同步异步</strong><br> Node.js 文件系统模块中的方法均有异步和同步版本。<br> 异步的方法函数最后一个参数为回调函数，回调函数的第一个参数包含了错误信息(error)。<br> 异步方法比起同步，异步方法性能更高，速度更快，而且没有阻塞。</p> 
<pre><code>var fs = require("fs");
// 异步读取
fs.readFile('input.txt', function (err, data) {
   if (err) {
       return console.error(err);
   }
   console.log("异步读取: " + data.toString());
});
// 同步读取
var data = fs.readFileSync('input.txt');
console.log("同步读取: " + data.toString());
console.log("程序执行完毕。");
</code></pre> 
<p>异步模式下打开文件：</p> 
<pre><code>fs.open(path, flags[, mode], callback)	//callback(err, fd)
</code></pre> 
<p>异步模式下获取文件信息：</p> 
<pre><code>fs.stat(path, callback)	//callback(err, stats), stats 是fs.Stats对象
</code></pre> 
<p>异步模式下写入文件：</p> 
<pre><code>fs.writeFile(file, data[, options], callback)	//options(encoding, mode, flag)，callback(err)
</code></pre> 
<p>异步模式下读取文件：</p> 
<pre><code>fs.read(fd, buffer, offset, length, position, callback)	//callback(err, bytesRead, buffer)
</code></pre> 
<p>异步模式下关闭文件：</p> 
<pre><code class="prism language-bash">fs.close<span class="token punctuation">(</span>fd, callback<span class="token punctuation">)</span>	//callback没有参数
</code></pre> 
<p>异步模式下截取文件：</p> 
<pre><code class="prism language-bash">fs.ftruncate<span class="token punctuation">(</span>fd, len, callback<span class="token punctuation">)</span>	//callback没有参数
</code></pre> 
<p>删除文件：</p> 
<pre><code class="prism language-bash">fs.unlink<span class="token punctuation">(</span>path, callback<span class="token punctuation">)</span>	//callback没有参数
</code></pre> 
<p>创建目录：</p> 
<pre><code class="prism language-bash">fs.mkdir<span class="token punctuation">(</span>path<span class="token punctuation">[</span>, options<span class="token punctuation">]</span>, callback<span class="token punctuation">)</span>	//options<span class="token punctuation">(</span>recursive, mode<span class="token punctuation">)</span>，callback没有参数
</code></pre> 
<p>读取目录：</p> 
<pre><code class="prism language-bash">fs.readdir<span class="token punctuation">(</span>path, callback<span class="token punctuation">)</span>	//callback<span class="token punctuation">(</span>err, files<span class="token punctuation">)</span>
</code></pre> 
<p>删除目录：</p> 
<pre><code>fs.rmdir(path, callback)	//callback没有参数
</code></pre> 
<h3><a id="_327"></a>常用工具模块</h3> 
<hr> 
<p><strong>os模块</strong>提供了一些基本的系统操作函数<br> <strong>path模块</strong>提供了一些用于处理文件路径的小工具<br> <strong>Net模块</strong>提供了一些用于底层的网络通信的小工具<br> <strong>DNS模块</strong>用于解析域名<br> <strong>Domain</strong>简化异步代码的异常处理，可以捕捉处理try catch无法捕捉的异常。</p> 
<h3><a id="_336"></a>多线程</h3> 
<hr> 
<p>Node.js 是以单线程的模式运行的；但它使用的是事件驱动来处理并发，我们可以在多核 cpu 的系统上创建多个子进程。</p> 
<p>每个子进程总是带有三个流对象：child.stdin, child.stdout 和child.stderr。</p> 
<p>Node提供<kbd>child_process</kbd>模块来创建子进程：</p> 
<ol><li><code>child_process.exec(command[, options], callback(err, stdout, stderr))</code><br> 使用子进程执行命令，缓存子进程的输出，并将子进程的输出以回调函数参数的形式返回。exec()方法返回最大的缓冲区，并等待进程结束，一次性返回缓冲区的内容。</li><li><code>child_process.spawn(command[, args][, options])</code><br> 使用指定的命令行参数创建新进程。spawn()方法返回流 (stdout &amp; stderr)，在进程返回大量数据时使用。进程一旦开始执行时spawn()就开始接收响应。</li><li><code>child_process.fork(modulePath[, args][, options])</code><br> spawn()方法的特殊形式，用于创建进程。</li></ol>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/f1eb3b916cd1cb1f801559bbd5e76750/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">微信小程序引用Map地图规划制定路径行走并显示路径</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/c2af0b4ade2cc99071498775ef230dd6/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">仿牛客网项目第二章:开发社区登录模块（详细步骤和思路）</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>