<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>排序算法简述 - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="排序算法简述" />
<meta property="og:description" content="一、概述 常见的排序算法有冒泡排序、插入排序、选择排序、快速排序、归并排序、桶排序、基数排序，这些排序各自有各自的特点。按照时间时间复杂度可以分为
O(n^2):冒泡、插入、选择排序；O(nlogn):归并、快速排序；O(n):桶排序、计数排序、基数排序； 二、如何分析一个排序算法 最好、最坏、平均情况下的时间复杂度；时间复杂度的常数、系数、低阶；比较次数和交换（移动次数）；堆内存的消耗：针对空间复杂度，引入原地排序概念，就是指空间复杂度为O(1)的算法；排序的稳定性：原序列中相同值数据的前后顺序在排序后会不会被打乱，分为稳定排序和不稳定排序； 三、冒泡排序 每次八前后两个元素比较，判断是否需要互换，一直到序列最后面，这样重复n次。最好情况在第一次排序后看有没有数据交换，如果没有的话说明此时已经有序了，时间复杂度时O(n^2)。 平均时间复杂度也是O(n^2)。
四、插入排序 将数据分为有序区间和无序区间，开始有序区间只有一个元素，然后从后面无序区间区第一个元素插入到有序区间中对应的位置。是原地排序，当遇到相同值时可以选择位置前后的防止，所以是稳定排序。可以选择从有序区间后面开始进行大小的比较，所以最好情况下时间复杂度为O(n)，平均和最坏情况下时间复杂度都是O(n^2)。
相对于冒泡排序，插入排序在每次数据的移动比冒泡排序的数据交换简单，因此插入排序忧郁冒泡排序。
五、选择排序 将数据分为有序区间和无序区间，每次从无需区间找到最小值，放到有序区间的后面。空间复杂度是原地排序。不是稳定排序
六、归并排序 将序列递归的差分为左右两个区间，直到区间不能再拆分，然后在每次回归时将左右两个有序区间合并排序（类似两个有序链表的合并）。
//A是数组，n是数组大小 merge_sort(A, n) { merge_sort_c(A, p, r); } //A是数组，p是开始位置，r是结束位置 merge_sort_c(A, p, r) { if(q &gt;= r) { return; } q = (p &#43; r) / 2; merge_sort_c(A, p, q); merge_sort_c(A, q&#43;1, r); //将有序区间A[p, q],和A[q&#43;1, r]合并为 A[p, r] merge(A[p, q], A[q&#43;1, r], A[p, r]); } 对于merge(A[p, q], A[q&#43;1, r], A[p, r])合并函数设计思路：建立一个大小为[p, r]的临时数组temp，将A[p, q], A[q&#43;1, r]中数据按照大小一次放入，然后将temp的值赋给A[p, r]。因此归并排序不是原地排序。当[p, q], A[q&#43;1, r]存在相同值时，我们可以选择总是将[p, q]的值放在前面，从而保证了数据的稳定性。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/d5693546ed7e321b0d8cf7fccbcdbf4b/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-11-27T13:47:23+08:00" />
<meta property="article:modified_time" content="2022-11-27T13:47:23+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">排序算法简述</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <h3><a id="_0"></a>一、概述</h3> 
<p>常见的排序算法有冒泡排序、插入排序、选择排序、快速排序、归并排序、桶排序、基数排序，这些排序各自有各自的特点。按照时间时间复杂度可以分为</p> 
<ol><li>O(n^2):冒泡、插入、选择排序；</li><li>O(nlogn):归并、快速排序；</li><li>O(n):桶排序、计数排序、基数排序；</li></ol> 
<h3><a id="_6"></a>二、如何分析一个排序算法</h3> 
<ol><li>最好、最坏、平均情况下的时间复杂度；</li><li>时间复杂度的常数、系数、低阶；</li><li>比较次数和交换（移动次数）；</li><li>堆内存的消耗：针对空间复杂度，引入<strong>原地排序</strong>概念，就是指空间复杂度为O(1)的算法；</li><li>排序的稳定性：原序列中相同值数据的前后顺序在排序后会不会被打乱，分为<strong>稳定排序</strong>和<strong>不稳定排序</strong>；</li></ol> 
<h3><a id="_14"></a>三、冒泡排序</h3> 
<p>每次八前后两个元素比较，判断是否需要互换，一直到序列最后面，这样重复n次。最好情况在第一次排序后看有没有数据交换，如果没有的话说明此时已经有序了，时间复杂度时O(n^2)。 平均时间复杂度也是O(n^2)。</p> 
<h3><a id="_17"></a>四、插入排序</h3> 
<p>将数据分为<strong>有序区间</strong>和<strong>无序区间</strong>，开始有序区间只有一个元素，然后从后面无序区间区第一个元素插入到有序区间中对应的位置。是原地排序，当遇到相同值时可以选择位置前后的防止，所以是稳定排序。可以选择从有序区间后面开始进行大小的比较，所以最好情况下时间复杂度为O(n)，平均和最坏情况下时间复杂度都是O(n^2)。<br> 相对于冒泡排序，插入排序在每次数据的移动比冒泡排序的数据交换简单，因此插入排序忧郁冒泡排序。<br> <img src="https://images2.imgbox.com/c5/81/zNlwdd5W_o.png" alt="在这里插入图片描述"></p> 
<h3><a id="_22"></a>五、选择排序</h3> 
<p>将数据分为有序区间和无序区间，每次从无需区间找到最小值，放到有序区间的后面。空间复杂度是<strong>原地排序</strong>。<strong>不是稳定排序</strong></p> 
<h3><a id="_25"></a>六、归并排序</h3> 
<p>将序列递归的差分为左右两个区间，直到区间不能再拆分，然后在每次回归时将左右两个有序区间合并排序（类似两个有序链表的合并）。<br> <img src="https://images2.imgbox.com/1f/02/RuyeaPgH_o.png" alt="在这里插入图片描述"></p> 
<pre><code class="prism language-cpp"><span class="token comment">//A是数组，n是数组大小</span>
<span class="token function">merge_sort</span><span class="token punctuation">(</span>A<span class="token punctuation">,</span> n<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token function">merge_sort_c</span><span class="token punctuation">(</span>A<span class="token punctuation">,</span> p<span class="token punctuation">,</span> r<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment">//A是数组，p是开始位置，r是结束位置</span>
<span class="token function">merge_sort_c</span><span class="token punctuation">(</span>A<span class="token punctuation">,</span> p<span class="token punctuation">,</span> r<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token keyword">if</span><span class="token punctuation">(</span>q <span class="token operator">&gt;=</span> r<span class="token punctuation">)</span>
	<span class="token punctuation">{<!-- --></span>
		<span class="token keyword">return</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
	
	q <span class="token operator">=</span> <span class="token punctuation">(</span>p <span class="token operator">+</span> r<span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">;</span>
	<span class="token function">merge_sort_c</span><span class="token punctuation">(</span>A<span class="token punctuation">,</span> p<span class="token punctuation">,</span> q<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token function">merge_sort_c</span><span class="token punctuation">(</span>A<span class="token punctuation">,</span> q<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span> r<span class="token punctuation">)</span><span class="token punctuation">;</span>

	<span class="token comment">//将有序区间A[p, q],和A[q+1, r]合并为 A[p, r]</span>
	<span class="token function">merge</span><span class="token punctuation">(</span>A<span class="token punctuation">[</span>p<span class="token punctuation">,</span> q<span class="token punctuation">]</span><span class="token punctuation">,</span> A<span class="token punctuation">[</span>q<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span> r<span class="token punctuation">]</span><span class="token punctuation">,</span> A<span class="token punctuation">[</span>p<span class="token punctuation">,</span> r<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

</code></pre> 
<p>对于merge(A[p, q], A[q+1, r], A[p, r])合并函数设计思路：建立一个大小为[p, r]的临时数组temp，将A[p, q], A[q+1, r]中数据按照大小一次放入，然后将temp的值赋给A[p, r]。因此归并排序<strong>不是原地排序</strong>。当[p, q], A[q+1, r]存在相同值时，我们可以选择总是将[p, q]的值放在前面，从而<strong>保证了数据的稳定性</strong>。</p> 
<h3><a id="_55"></a>七、快速排序</h3> 
<p>快速排序采用由上到下的排序思路，每次选择一个参照节点，依照此节点的值，直接原地拆分为小于此节点值的区间和大于此节点值的两个区间，然后将前后两个区间在依照此方法递归拆分，直到无法拆分。<br> 依照快排的拆分思路，如果要找到n个元素中的第k大的元素，可以选择拆分然后比较前后两个区间A[p, q]和A[q+1, r],判断q&gt;k是否成立，从而选择继续实在前区间找还是在后区间继续找。</p> 
<h3><a id="_59"></a>思考题</h3> 
<ol><li>有 10 个接口访问日志文件，每个日志文件大小约 300MB，每个文件里的日志都是按照时间戳从小到大排序的。希望将这 10个较小的日志文件，合并为 1 个日志文件，合并之后的日志仍然按照时间戳从小到大排列。如果处理上述排序任务的机器内存只1GB，能“快速”地将这 10 个日志文件合并吗？<br> **思路：**为例充分利用内存，并减少io次数，理想状态下，每次从每个文件取40MB大小的记录（也不一定，保证文件拿到最后一个的花间戳取完，如果取不完的话，把这个取不完的时间戳舍弃掉不要）。然后在内存中采用归并的思路进行排序，每次从一个文件中把一条时间戳比较排序，然后把对应文件时间戳拿完。某个文件排完了，再从原文件里面计需取。当排序完成的为见到400MB时存储一次文件。</li></ol>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/e214eef91482226e702282e81025cf5e/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">递归和排序算法的应用</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/b87c422b4b56d36a523cc6977cbaf4f4/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">unity实现坦克对战</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>