<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Mybatis----缓存 - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Mybatis----缓存" />
<meta property="og:description" content="MyBatis是一个流行的Java持久化框架，它提供了一个灵活的缓存机制来提高查询性能。
MyBatis的缓存机制主要分为一级缓存和二级缓存。
一级缓存是指在同一个SqlSession中，查询结果会被缓存起来，当再次执行同样的查询时，直接从缓存中获取结果，而不需要再次发起数据库查询。一级缓存是MyBatis默认启用的，可以通过配置来禁用。
二级缓存是指多个SqlSession之间共享的缓存，它可以减少数据库的访问次数，提高性能。默认情况下，二级缓存是禁用的，需要手动配置开启。可以使用一些第三方插件（比如EhCache或Redis）来实现二级缓存。
要启用二级缓存，需要在MyBatis的配置文件中配置相应的缓存配置。在映射文件中，可以使用&lt;cache&gt;标签来配置二级缓存的相关属性，比如缓存类型、缓存过期时间等。
1.一级缓存 Mybatis默认开启一级缓存，当在同一个会话中多次查询同一个语句，Mybatis会自动使用一级缓存获取查询结果。
@Test public void test2() throws IOException { SqlSessionFactory sqlSessionFactory=new SqlSessionFactoryBuilder().build(Resources.getResourceAsStream(&#34;mybatis-config.xml&#34;)); SqlSession sqlSession = sqlSessionFactory.openSession(); AccountMapper mapper = sqlSession.getMapper(AccountMapper.class); System.out.println(&#34;第一次查询：&#34;); System.out.println(mapper.selectAll()); System.out.println(&#34;第二次查询&#34;); System.out.println(mapper.selectAll()); sqlSession.close(); } 由此可见，第二此次查询是从一级缓存中拿到的结果。
修改语句，将查询语句之间插入一条删除语句
一级缓存会在删除时自动清除，不仅仅是删除，增加，更新也会使一级缓存清除。
不同的会话对象不会共享缓存
@Test public void test2() throws IOException { SqlSessionFactory sqlSessionFactory=new SqlSessionFactoryBuilder().build(Resources.getResourceAsStream(&#34;mybatis-config.xml&#34;)); SqlSession sqlSession = sqlSessionFactory.openSession(); SqlSession anthorSqlSession=sqlSessionFactory.openSession(); AccountMapper mapper = sqlSession.getMapper(AccountMapper.class); AccountMapper anthorMapper = anthorSqlSession.getMapper(AccountMapper.class); System.out.println(&#34;第一次查询：&#34;); System.out.println(mapper.selectAll()); System.out.println(&#34;第二次查询&#34;); System.out.println(anthorMapper.selectAll()); sqlSession.close(); } 一级缓存仅仅在同一会话中生效
2.二级缓存 Mybatis中一个SqlSessionFactory对应一个数据库，而二级缓存就是SqlSessionFactory级别的。
开启二级缓存需要一下步骤" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/bd15fd3c4e1652076dc642aa88439f51/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2024-01-23T18:42:12+08:00" />
<meta property="article:modified_time" content="2024-01-23T18:42:12+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Mybatis----缓存</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <h3 id="mNsDd"></h3> 
<blockquote> 
 <p id="ua7e5731b">MyBatis是一个流行的Java持久化框架，它提供了一个灵活的缓存机制来提高查询性能。</p> 
 <p id="u4dd3e07e">MyBatis的缓存机制主要分为一级缓存和二级缓存。</p> 
 <p id="ub8d52564">一级缓存是指在同一个SqlSession中，查询结果会被缓存起来，当再次执行同样的查询时，直接从缓存中获取结果，而不需要再次发起数据库查询。一级缓存是MyBatis默认启用的，可以通过配置来禁用。</p> 
 <p id="uac64b2d9">二级缓存是指多个SqlSession之间共享的缓存，它可以减少数据库的访问次数，提高性能。默认情况下，二级缓存是禁用的，需要手动配置开启。可以使用一些第三方插件（比如EhCache或Redis）来实现二级缓存。</p> 
 <p id="u0f123157">要启用二级缓存，需要在MyBatis的配置文件中配置相应的缓存配置。在映射文件中，可以使用&lt;cache&gt;标签来配置二级缓存的相关属性，比如缓存类型、缓存过期时间等。</p> 
</blockquote> 
<h4 id="LKAm9">1.一级缓存</h4> 
<p id="uf1ee7554">Mybatis默认开启一级缓存，当在同一个会话中多次查询同一个语句，Mybatis会自动使用一级缓存获取查询结果。</p> 
<pre id="TcEfr"><code>@Test
public void test2() throws IOException {
    SqlSessionFactory sqlSessionFactory=new SqlSessionFactoryBuilder().build(Resources.getResourceAsStream("mybatis-config.xml"));
    SqlSession sqlSession = sqlSessionFactory.openSession();
    AccountMapper mapper = sqlSession.getMapper(AccountMapper.class);
    System.out.println("第一次查询：");
    System.out.println(mapper.selectAll());
    System.out.println("第二次查询");
    System.out.println(mapper.selectAll());
    sqlSession.close();

}</code></pre> 
<p id="u8171e3a5"></p> 
<p class="img-center"><img alt="" height="657" id="u2783f433" src="https://images2.imgbox.com/4b/83/4zL3pyic_o.png" width="1200"></p> 
<p id="u526ce408">由此可见，第二此次查询是从一级缓存中拿到的结果。</p> 
<p id="u27fb44e0">修改语句，将查询语句之间插入一条删除语句</p> 
<p id="u1ab1096a"></p> 
<p class="img-center"><img alt="" height="713" id="ucb34b62b" src="https://images2.imgbox.com/53/b6/BeJLuqBo_o.png" width="1200"></p> 
<p id="u3ecacf5a">一级缓存会在删除时自动清除，不仅仅是删除，增加，更新也会使一级缓存清除。</p> 
<p id="uf700768b">不同的会话对象不会共享缓存</p> 
<pre id="GRaus"><code>@Test
public void test2() throws IOException {
    SqlSessionFactory sqlSessionFactory=new SqlSessionFactoryBuilder().build(Resources.getResourceAsStream("mybatis-config.xml"));
    SqlSession sqlSession = sqlSessionFactory.openSession();
    SqlSession anthorSqlSession=sqlSessionFactory.openSession();
    AccountMapper mapper = sqlSession.getMapper(AccountMapper.class);
    AccountMapper anthorMapper = anthorSqlSession.getMapper(AccountMapper.class);
    System.out.println("第一次查询：");
    System.out.println(mapper.selectAll());
    System.out.println("第二次查询");
    System.out.println(anthorMapper.selectAll());
    sqlSession.close();

}</code></pre> 
<p id="u8c4f38b1"></p> 
<p class="img-center"><img alt="" height="615" id="u356ecaa2" src="https://images2.imgbox.com/c3/dd/adr8JyUi_o.png" width="1200"></p> 
<p id="u868fbfce">一级缓存仅仅在同一会话中生效</p> 
<h4 id="cqCld">2.二级缓存</h4> 
<p id="u6c723990">Mybatis中一个SqlSessionFactory对应一个数据库，而二级缓存就是SqlSessionFactory级别的。</p> 
<p id="u6e5b599b">开启二级缓存需要一下步骤</p> 
<h5 id="OhnV4">1.全局的开启关闭映射文件中配置的缓存</h5> 
<pre id="AoW5H"><code>&lt;settings&gt;
    &lt;setting name="cacheEnable" value="true"/&gt;
&lt;/settings&gt;</code></pre> 
<p id="u540e673b">默认值就是true</p> 
<h5 id="en5YP">2.在映射文件中配置&lt;cache&gt;&lt;/cache&gt;</h5> 
<h5 id="AN4cJ">3.映射文件映射的实体类必须为可序列化类</h5> 
<p id="u51a33ce6">实现Serializable接口</p> 
<p id="u7be49e6d"></p> 
<p class="img-center"><img alt="" height="54" id="u0d3ef16b" src="https://images2.imgbox.com/74/a3/T7XZyykJ_o.png" width="651"></p> 
<p id="u961f810d"></p> 
<h5 id="f9n6R">4.会话必须提交或者是关闭，值才能写入二级缓存</h5> 
<h5 id="YbB3M">测试</h5> 
<pre id="CmNwa"><code>public void test2() throws IOException {
    SqlSessionFactory sqlSessionFactory=new SqlSessionFactoryBuilder().build(Resources.getResourceAsStream("mybatis-config.xml"));
    SqlSession sqlSession = sqlSessionFactory.openSession();
    SqlSession anthorSqlSession=sqlSessionFactory.openSession();
    AccountMapper mapper = sqlSession.getMapper(AccountMapper.class);
    AccountMapper anthorMapper = anthorSqlSession.getMapper(AccountMapper.class);
    System.out.println("第一次查询：");
    System.out.println(mapper.selectAll());
    sqlSession.commit();
    System.out.println("第二次查询");
    System.out.println(anthorMapper.selectAll());
    sqlSession.close();

}</code></pre> 
<p id="ud6d1f8e0"></p> 
<p class="img-center"><img alt="" height="796" id="wS7uy" src="https://images2.imgbox.com/82/e9/GrTgPGqi_o.png" width="1200"></p> 
<p id="u76191d0c">注意：当出现增加，删除，更新语句的时候，二级缓存通用会被清除</p> 
<h4 id="iTEu1">二级缓存的驱逐策略</h4> 
<p id="u80dc7a8b">MyBatis的二级缓存提供了多种驱逐策略（Eviction Strategy）来管理缓存中的对象，确保缓存不会无限增长并占用过多的内存。以下是一些常见的驱逐策略：</p> 
<ol><li id="uf42efcf5">LRU（Least Recently Used）：最近最少使用策略会驱逐最近最少被使用的对象。当缓存达到设定的大小上限时，将会移除最近最少被使用的对象。</li><li id="u12f4eab8">FIFO（First In, First Out）：先进先出策略会按照对象最先进入缓存的顺序进行驱逐。当缓存达到设定的大小上限时，最先进入缓存的对象将会被移除。</li><li id="u7b718273">Soft References：软引用策略使用Java的软引用机制，当内存不足时，垃圾回收器会根据软引用对象的使用情况来回收内存。这样可以让缓存中的对象在内存不足时被回收，避免内存溢出。</li><li id="u2fff5474">Time To Live（TTL）：时间驱逐策略允许为缓存中的对象设置一个存活时间，在存活时间到期后，缓存中的对象将被驱逐。</li></ol> 
<p id="u4a476f27">例如：</p> 
<pre id="Gu4A7"><code>&lt;cache eviction="FIFO"&gt;&lt;/cache&gt;</code></pre> 
<p id="u662d9b6f">总结一下，MyBatis的缓存机制包括一级缓存和二级缓存，一级缓存默认启用且无需配置，一级缓存是SqlSession级别的缓存；二级缓存需要手动配置启用，可以减少数据库的访问次数，提高性能，是多个SqlSession共享的缓存。</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/2f9e0f2c2cd871022cdfdc7e7068506c/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">数据中心无法自动化：5大痛点揭秘！</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/fc8005e6541ca471cacdcafa243c320d/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">ES 数据插入异常原因分析</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>