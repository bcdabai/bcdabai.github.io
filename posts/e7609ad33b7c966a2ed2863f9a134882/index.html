<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>xml解析库对比总结(解析方式，第三方库，TinyXml) - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="xml解析库对比总结(解析方式，第三方库，TinyXml)" />
<meta property="og:description" content="一. 解析方式 xml的2种解析方式（DOM和SAX解析方式）: https://blog.csdn.net/weixin_42472048/article/details/81264570
dom解析和sax解析区别：
dom方式解析
根据xml的层级结构在内存中分配一个树形结构，把xml的标签，属性和文本都封装成对象
优点：很方便实现增删改操作
缺点：如果文件过大，造成内存溢出
sax方式解析
采用事件驱动，边读边解析，从上到下，一行一行的解析，解析到某一个对象，返回对象名称，
当SAX解析结束，不会保存任何XML文档的数据。
优点：如果文件过大，不会造成内存溢出，方便实现查询操作
缺点：不能实现增删改操作
二. 第三方库介绍对比： 尽管XML解析器有很多种，而且功能差异很大，甚至是支持跨平台、多语言，但是对于你的应用而言，尽量选择一种相对熟悉、功能够用的即可，没必要去追求庞杂的解析器，我们只需关注：功能够用、相对稳定、适合扩展这三个功能即可。一旦有问题，修正和扩展都要更为容易。
PugiXML： 仅DOM方式；速度快; https://www.cnblogs.com/haomiao/p/5041065.html
RapidXML： 仅DOM方式；速度快
libxml： 可以验证DTD；几乎适合于常见的所有操作系统下编译和开发使用; C代码支持XML解析最全的，支持xpath语法；
libxml&#43;&#43;（地址：http://libxmlplusplus.sourceforge.net/）是对libxml XML解析器的C&#43;&#43;封装版本。此外还有各种语言封装包，参加官方链接。
libxml的使用（1）--读取xml：https://www.cnblogs.com/fire909090/p/6798136.html
libxml2的安装及使用[总结]：https://www.cnblogs.com/Anker/p/3542058.html
Libxml2主要的优点有：
（ http://blog.sina.com.cn/s/blog_a7c44c8801018qc5.html ）：
1. 安装、使用比较简单，容易入门；
2. 支持的编码格式较多，能很好的解决中文问题(使用一个很简单的编码转换函数)；
3. 支持Xpath解析（这点对于任意定位xml文档中的节点还是很有用的哦）；
4. 支持Well-formed 和valid验证，具体而言支持DTD验证，Schema验证功能正在完善中(目前多数解析器都还不完全支持shema验证功能)；
5. 支持目前通用的Dom、Sax方式解析等等。
不足之处也是有的：
1. 指针太多，使用不当时就会出现错误，在Linux系统中表现为常见的段错误，同样管理不当易造成内存泄漏；
2.个人认为内面有些函数的功能设计的不是很好（比如获取Xpath函数，它不获取节点属性，这样子有些情况会定位不准）
C/C&#43;&#43;利用libxml2高效输出XML大文件详解：https://www.jb51.net/article/128707.htm
Xerces： 支持SAX和DOM ；可以验证DTD；文件越大，element解析越慢；除了C&#43;&#43;版本，Xerces同时还提供Xerces Java，Xerces Perl等版本。
TinyXML： DOM方式；C&#43;&#43;开发，支持Windows和Linux。小巧玲珑，非常适合存储简单数据，配置文件，对象序列化等数据量不是很大的操作。支持对XML的读取和修改，不直接支持XPath，需要借助另一个相关的类库TinyXPath才可以支持XPath.
一个例子：https://blog.csdn.net/woniu211111/article/details/76445059
TinyXml库 使用方法: https://blog.csdn.net/qq_26374395/article/details/80171906
使用TinyXML读写xml文件: https://blog.csdn.net/lgstudyvc/article/details/77859919
TinyXml快速入门: https://blog.csdn.net/qq_38022972/article/details/82221898
TinyXml入门简易教程: https://blog.csdn.net/qq_24571549/article/details/70980125
-------------------------------------------------------------------------------------------------
配置使用过程：
1. tinyxml在windows环境下编译：https://blog." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/e7609ad33b7c966a2ed2863f9a134882/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2019-04-19T08:26:03+08:00" />
<meta property="article:modified_time" content="2019-04-19T08:26:03+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">xml解析库对比总结(解析方式，第三方库，TinyXml)</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <h2>一. 解析方式</h2> 
<p>xml的2种解析方式（DOM和SAX解析方式）: <a href="https://blog.csdn.net/weixin_42472048/article/details/81264570">https://blog.csdn.net/weixin_42472048/article/details/81264570</a></p> 
<p>dom解析和sax解析区别：<br>      <strong>dom方式解析</strong><br>             根据xml的层级结构在内存中分配一个<strong>树形结构</strong>，把xml的标签，属性和文本都封装成对象<br>             优点：很方便实现<strong>增删改</strong>操作<br>             缺点：如果文件过大，造成内存溢出<br>      <strong>sax方式解析</strong><br>             采用事件驱动，边读边解析，从上到下，一行一行的解析，解析到某一个对象，返回对象名称，<br>             当SAX解析结束，不会保存任何XML文档的数据。<br>             优点：如果文件过大，不会造成内存溢出，方便实现查询操作<br>             缺点：<strong>不能实现增删改</strong>操作</p> 
<h2>二. 第三方库介绍对比：</h2> 
<p>尽管XML解析器有很多种，而且功能差异很大，甚至是支持跨平台、多语言，但是对于你的应用而言，尽量选择一种相对熟悉、功能够用的即可，没必要去追求庞杂的解析器，我们只需关注：<strong>功能够用、相对稳定、适合扩展</strong>这三个功能即可。一旦有问题，修正和扩展都要更为容易。</p> 
<h3>PugiXML：</h3> 
<p>仅DOM方式；速度快; <a href="https://www.cnblogs.com/haomiao/p/5041065.html" rel="nofollow">https://www.cnblogs.com/haomiao/p/5041065.html</a></p> 
<h3>RapidXML：</h3> 
<p>仅DOM方式；速度快</p> 
<h3>libxml：</h3> 
<p>可以验证<a href="https://www.cnblogs.com/zhengcheng/p/4278899.html" rel="nofollow">DTD</a>；几乎适合于常见的所有操作系统下编译和开发使用; C代码支持XML解析最全的，支持xpath语法；</p> 
<p>libxml++（地址：<a href="http://libxmlplusplus.sourceforge.net/" rel="nofollow">http://libxmlplusplus.sourceforge.net/</a>）是对libxml XML解析器的C++封装版本。此外还有各种语言封装包，参加官方链接。</p> 
<p>libxml的使用（1）--读取xml：<a href="https://www.cnblogs.com/fire909090/p/6798136.html" rel="nofollow">https://www.cnblogs.com/fire909090/p/6798136.html</a></p> 
<p>libxml2的安装及使用[总结]：<a href="https://www.cnblogs.com/Anker/p/3542058.html" rel="nofollow">https://www.cnblogs.com/Anker/p/3542058.html</a></p> 
<p><strong>Libxml2主要的优点有：</strong></p> 
<p>（ <a href="http://blog.sina.com.cn/s/blog_a7c44c8801018qc5.html" rel="nofollow">http://blog.sina.com.cn/s/blog_a7c44c8801018qc5.html</a> ）：</p> 
<p>          1.   安装、使用比较简单，容易入门；</p> 
<p>          2.   支持的编码格式较多，能很好的解决中文问题(使用一个很简单的编码转换函数)；</p> 
<p>          3.   支持Xpath解析（这点对于任意定位xml文档中的节点还是很有用的哦）；</p> 
<p>          4.    支持Well-formed 和valid验证，具体而言支持DTD验证，Schema验证功能正在完善中(目前多数解析器都还不完全支持shema验证功能)；</p> 
<p>          5.   支持目前通用的Dom、Sax方式解析等等。</p> 
<p><strong>不足之处也是有的：</strong></p> 
<p>          1.  指针太多，使用不当时就会出现错误，在Linux系统中表现为常见的段错误，同样管理不当易造成内存泄漏；</p> 
<p>           2.个人认为内面有些函数的功能设计的不是很好（比如获取Xpath函数，它不获取节点属性，这样子有些情况会定位不准）</p> 
<p>C/C++利用libxml2高效输出XML大文件详解：<a href="https://www.jb51.net/article/128707.htm" rel="nofollow">https://www.jb51.net/article/128707.htm</a></p> 
<h3>Xerces：</h3> 
<p>支持SAX和DOM ；可以验证DTD；文件越大，element解析越慢；除了C++版本，Xerces同时还提供Xerces <a href="http://lib.csdn.net/base/17" rel="nofollow">Java</a>，Xerces Perl等版本。</p> 
<h3>TinyXML：</h3> 
<p>DOM方式；C++开发，支持Windows和Linux。小巧玲珑，非常适合存储简单数据，配置文件，对象序列化等数据量不是很大的操作。支持对XML的读取和修改，不直接支持XPath，需要借助另一个相关的类库TinyXPath才可以支持XPath.</p> 
<p>一个例子：<a href="https://blog.csdn.net/woniu211111/article/details/76445059">https://blog.csdn.net/woniu211111/article/details/76445059</a></p> 
<p>TinyXml库 使用方法: <a href="https://blog.csdn.net/qq_26374395/article/details/80171906">https://blog.csdn.net/qq_26374395/article/details/80171906</a></p> 
<p>使用TinyXML读写xml文件: <a href="https://blog.csdn.net/lgstudyvc/article/details/77859919">https://blog.csdn.net/lgstudyvc/article/details/77859919</a></p> 
<p>TinyXml快速入门: <a href="https://blog.csdn.net/qq_38022972/article/details/82221898">https://blog.csdn.net/qq_38022972/article/details/82221898</a></p> 
<p>TinyXml入门简易教程: <a href="https://blog.csdn.net/qq_24571549/article/details/70980125">https://blog.csdn.net/qq_24571549/article/details/70980125</a></p> 
<p>-------------------------------------------------------------------------------------------------</p> 
<p><strong>配置使用过程：</strong></p> 
<p>1. tinyxml在windows环境下编译：<a href="https://blog.csdn.net/u012870721/article/details/78237930">https://blog.csdn.net/u012870721/article/details/78237930</a></p> 
<p>2. Windows下Tinyxml的正确配置：<a href="https://blog.csdn.net/iorijjw/article/details/8515268">https://blog.csdn.net/iorijjw/article/details/8515268</a></p> 
<p>  （在 "项目" -&gt; "xxx 属性" -&gt; "配置属性" -&gt; "连接器" -&gt; "输入" 中, 找到 "忽略特定默认库", 如果是 Debug 模式则向其中输入 libcmtd.lib 这步做与不做，有待进一步研究）</p> 
<p>3. <strong><span style="color:#f33b45;">TinyXML Tutorial 中文指南</span></strong>:</p> 
<p>           <a href="http://www.cnblogs.com/kex1n/archive/2010/10/03/1841502.html" rel="nofollow">http://www.cnblogs.com/kex1n/archive/2010/10/03/1841502.html</a></p> 
<pre><code class="language-html hljs">在线文档： http://www.grinninglizard.com/tinyxmldocs/tutorial0.html
------------------------------------------------------------------</code></pre> 
<p><strong>遇到的问题：</strong></p> 
<p>tinyxml中文乱码（内存模式）: <a href="https://blog.csdn.net/myruo/article/details/81514118">https://blog.csdn.net/myruo/article/details/81514118</a></p> 
<p>-------------------------------------------------------------------------------------------------</p> 
<p><strong>一个简单的实例应用：写xml文件</strong></p> 
<pre class="has"><code class="language-cpp">#include "tinyXml.h"
#pragma comment(lib, "tinyxml.lib")
#pragma comment(lib, "tinyxmlSTL.lib")

int main()
{
    build_simple_doc();
    system("pause");
    return 0;
}</code></pre> 
<pre class="has"><code class="language-cpp">void build_simple_doc()
{
	/*
	&lt;?xml version="1.0" encoding="utf-8" ?&gt;
	&lt;scene version="0.5.0"&gt;
		&lt;integrator type="path"&gt;
			&lt;boolean name="hideEmitters" value="false" otherAttriube="someValue" /&gt;
		&lt;/integrator&gt;
		&lt;!--物体模型--&gt;
	&lt;/scene&gt;
	*/

	TiXmlDocument doc;
	TiXmlDeclaration *decl = new TiXmlDeclaration("1.0", "utf-8", "");
	doc.LinkEndChild(decl);
	
	TiXmlElement *rootElement = new TiXmlElement("scene");
	rootElement-&gt;SetAttribute("version", "0.5.0");
	//TiXmlText *text = new TiXmlText("world");
	//rootElement-&gt;LinkEndChild(text);
	doc.LinkEndChild(rootElement);

	TiXmlElement *myIntegrator = new TiXmlElement("integrator");
	myIntegrator-&gt;SetAttribute("type", "path");
	rootElement-&gt;LinkEndChild(myIntegrator);

	TiXmlElement *myBoolean = new TiXmlElement("boolean");
	myBoolean-&gt;SetAttribute("name", "hideEmitters");
	myBoolean-&gt;SetAttribute("value", "false");
	myBoolean-&gt;SetAttribute("otherAttriube", "someValue");
	myIntegrator-&gt;LinkEndChild(myBoolean);
	/*
		注意：myBoolean没有EndChild， 所以不会有 &lt;/boolean&gt; 这一行
			同一个element不能添加两次（树结构），会导致卡死！！
	*/

	TiXmlComment *comment = new TiXmlComment();
	comment-&gt;SetValue("物体模型");
	rootElement-&gt;LinkEndChild(comment);

	doc.SaveFile("example1_byhand.xml");
}</code></pre> 
<p><strong>一个简单的实例应用：修改xml文件：</strong></p> 
<p>代码：</p> 
<pre class="has"><code class="hljs language-cpp">void modify_secene_xml(const char* pFilename)
{
	printf("File: %-s:\n", pFilename);

	TiXmlDocument doc(pFilename);
	if (!doc.LoadFile()) return;
	TiXmlHandle hDoc(&amp;doc);
	TiXmlElement* pElem;
	TiXmlHandle hRoot(0);
	TiXmlHandle subRoot(0);

	pElem = hDoc.FirstChildElement().Element();
	if (!pElem) return;

	hRoot = TiXmlHandle(pElem);
		
	//pElem = hRoot.FirstChild("shape").FirstChildElement().Element();
	//pElem = pElem-&gt;NextSiblingElement()-&gt;NextSiblingElement();

	 modify string in texture	
	pElem = hRoot.FirstChild("shape").FirstChild("bsdf").Element();
	subRoot = TiXmlHandle(pElem);
	pElem = subRoot.FirstChild("bsdf").FirstChild("texture").FirstChildElement().Element();
	printf( "%-20s\t--&gt;\t", pElem-&gt;Attribute("value") );
	
	pElem-&gt;SetAttribute("value", "mydefine.png");			 // &lt;--------------------
	printf("%-20s\n", pElem-&gt;Attribute("value"));
	
	 modify value of string of emitter
	pElem = hRoot.FirstChild("emitter").FirstChild("string").Element();
	printf("%-20s\t--&gt;\t", pElem-&gt;Attribute("value"));
	
	pElem-&gt;SetAttribute("value", "mydefineenvmap.exr");		// &lt;--------------------
	printf("%-20s\n", pElem-&gt;Attribute("value"));

	doc.SaveFile(pFilename);
}
//************************************************************//
int main()
{
	modify_secene_xml("test_byhand.xml");					// &lt;--------------------
	system("pause");
	return 0;
}</code></pre> 
<p>待修改文件：(修改 "original.png" 及 "original.exr" )</p> 
<pre class="has"><code class="hljs language-html">&lt;?xml version="1.0" encoding="utf-8" ?&gt;
&lt;scene version="0.5.0"&gt;
    &lt;integrator type="path"&gt;
        &lt;boolean name="hideEmitters" value="false" /&gt;
    &lt;/integrator&gt;
    &lt;!-- 物体模型 --&gt;
    &lt;shape type="obj"&gt;
        &lt;string name="filename" value="template.obj" /&gt;
        &lt;transform name="toWorld"&gt;
            &lt;scale value="10" /&gt;
        &lt;/transform&gt;
        &lt;bsdf type="twosided"&gt;
            &lt;bsdf type="diffuse"&gt;
                &lt;texture type="bitmap" name="reflectance"&gt;
                    &lt;string name="filename" value="original.png" /&gt;
                &lt;/texture&gt;
            &lt;/bsdf&gt;
        &lt;/bsdf&gt;
    &lt;/shape&gt;
    &lt;sensor type="perspective"&gt;
        &lt;float name="fov" value="60" /&gt;
        &lt;transform name="toWorld"&gt;
            &lt;lookat target="0 0 0" origin="-10 8 -10" up="0 1 0" /&gt;
        &lt;/transform&gt;
        &lt;sampler type="ldsampler"&gt;
            &lt;integer name="sampleCount" value="128" /&gt;
        &lt;/sampler&gt;
        &lt;film type="hdrfilm"&gt;
            &lt;boolean name="banner" value="false" /&gt;
            &lt;integer name="height" value="512" /&gt;
            &lt;integer name="width" value="512" /&gt;
            &lt;rfilter type="gaussian" /&gt;
        &lt;/film&gt;
    &lt;/sensor&gt;
    &lt;!-- 环境贴图 --&gt;
    &lt;emitter type="envmap" id="Area_002-light"&gt;
        &lt;string name="filename" value="original.exr" /&gt;
        &lt;float name="scale" value="1" /&gt;
    &lt;/emitter&gt;
&lt;/scene&gt;
</code></pre> 
<p>打印结果：</p> 
<p><img alt="" class="has" height="70" src="https://images2.imgbox.com/c5/8e/bp5Qt1rf_o.png" width="408"></p> 
<h2>三. 链接</h2> 
<p>C++各大有名库的介绍对比：<a href="https://blog.csdn.net/business122/article/details/78260909">https://blog.csdn.net/business122/article/details/78260909</a></p> 
<p>常见C/C++ XML解析器比较：<a href="https://www.cnblogs.com/snailgardening/p/xml_jiexi.html" rel="nofollow">https://www.cnblogs.com/snailgardening/p/xml_jiexi.html</a></p> 
<p> </p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/684c3c6b28ce13ec6152c80daaa36f5e/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">idea主题下载</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/fdad6620c1eb0d267c5444dc5788efc3/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">C语言实现的简易FTP客户端</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>