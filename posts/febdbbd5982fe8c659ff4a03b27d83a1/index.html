<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Go语言中的延迟语句是什么？ - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Go语言中的延迟语句是什么？" />
<meta property="og:description" content="延迟语句是什么？ 编程的时候，经常需要申请一些资源，比如数据库连接、文件、锁等，这些资源需要在用完之后释放掉，否则会造成内存泄漏。但编程人员经常容易忘记释放这些资源，从而造成一些事故。语言直接在语言层面提供defer关键字，在申请资源语句的下一行，可以直接用defer语句来注册函数结束后执行释放资源的操作。因为这样一颗小小的语法糖，忘写关闭资源语句的情况就大大地减少了。
defer是Go语言提供的一种用于注册延迟调用的机制：让函数或语句可以在当前函数执行完毕后（包括通过return正常结束或者panic导致的异常结束）执行。在需要释放资源的场景非常有用，可以很方便地在函数结束前做一些清理操作。在打开资源语句的下一行，直接使用defer就可以在函数返回前释放资源，可谓相当有效。
defer通常用于一些成对操作的场景：打开连接/关闭连接、加锁/释放锁、打开文件/关闭文件等。使用非常简单：
func main() { f, err := os.Open(&#34;filename&#34;) if err != nil { panic(err) } if f != nil { defer f.Close() } } 在打开文件的语句附近，用defer语句关闭文件。这样，在函数结束之前，会自动执行defer后面的语句来关闭文件。注意，要先判断f是否为空，如果f不为空，再调用f.CloseO函数，避免出现异常情况。
当然，defer会有短暂延迟，对时间要求特别高的程序，可以避免使用它，其他情况一般可以忽略它带来的延迟。特别是Go1.14又对defer做了很大幅度的优化，效率提升了不少
我们可以来看一个反面例子：
r.mu.Lock() rand.Intn(param) r.mu.Unlock() 上面只有三行代码，看起来这里不用defer执行Unlock并没有什么问题。其实并不是这样，中间这行代码rand.Intn（param）其实是有可能发生panic的，更严重的情况是，这段代码很有可能被其他人修改，增加更多的逻辑，而这完全不可控。也就是说，在Lock和Unlock之间的代码一旦出现异常情况导致panic，就会形成死锁。因此这里的逻辑是，即使是看起来非常简单的代码，使用defer也是有必要的，因为需求总在变化，代码也总会被修改。
延迟语句的执行顺序是什么？ 先看一下官方文档对defer的解释：
Each time a ＂defer＂statement executes，the function value and parameters to the call are evaluated asusual and saved anew but the actual function is not invoked.Instead，deferred functions are invoked immediately before the surrounding function returns，in the reverse order they were deferred." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/febdbbd5982fe8c659ff4a03b27d83a1/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-10-12T14:56:32+08:00" />
<meta property="article:modified_time" content="2022-10-12T14:56:32+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Go语言中的延迟语句是什么？</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <h3><a id="_0"></a>延迟语句是什么？</h3> 
<p>编程的时候，经常需要申请一些资源，比如数据库连接、文件、锁等，这些资源需要在用完之后释放掉，否则会造成内存泄漏。但编程人员经常容易忘记释放这些资源，从而造成一些事故。语言直接在语言层面提供defer关键字，在申请资源语句的下一行，可以直接用defer语句来注册函数结束后执行释放资源的操作。因为这样一颗小小的语法糖，忘写关闭资源语句的情况就大大地减少了。<br> defer是Go语言提供的一种用于注册延迟调用的机制：让函数或语句可以在当前函数执行完毕后（包括通过return正常结束或者panic导致的异常结束）执行。在需要释放资源的场景非常有用，可以很方便地在函数结束前做一些清理操作。在打开资源语句的下一行，直接使用defer就可以在函数返回前释放资源，可谓相当有效。<br> defer通常用于一些成对操作的场景：打开连接/关闭连接、加锁/释放锁、打开文件/关闭文件等。使用非常简单：</p> 
<pre><code class="prism language-go"><span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    f<span class="token punctuation">,</span> err <span class="token operator">:=</span> os<span class="token punctuation">.</span><span class="token function">Open</span><span class="token punctuation">(</span><span class="token string">"filename"</span><span class="token punctuation">)</span>
    <span class="token keyword">if</span> err <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">{<!-- --></span>
        <span class="token function">panic</span><span class="token punctuation">(</span>err<span class="token punctuation">)</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">if</span> f <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">{<!-- --></span>
        <span class="token keyword">defer</span> f<span class="token punctuation">.</span><span class="token function">Close</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>在打开文件的语句附近，用defer语句关闭文件。这样，在函数结束之前，会自动执行defer后面的语句来关闭文件。注意，要先判断f是否为空，如果f不为空，再调用f.CloseO函数，避免出现异常情况。<br> 当然，defer会有短暂延迟，对时间要求特别高的程序，可以避免使用它，其他情况一般可以忽略它带来的延迟。特别是Go1.14又对defer做了很大幅度的优化，效率提升了不少</p> 
<p>我们可以来看一个反面例子：</p> 
<pre><code class="prism language-go">r<span class="token punctuation">.</span>mu<span class="token punctuation">.</span><span class="token function">Lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
rand<span class="token punctuation">.</span><span class="token function">Intn</span><span class="token punctuation">(</span>param<span class="token punctuation">)</span>
r<span class="token punctuation">.</span>mu<span class="token punctuation">.</span><span class="token function">Unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
</code></pre> 
<p>上面只有三行代码，看起来这里不用defer执行Unlock并没有什么问题。其实并不是这样，中间这行代码rand.Intn（param）其实是有可能发生panic的，更严重的情况是，这段代码很有可能被其他人修改，增加更多的逻辑，而这完全不可控。也就是说，在Lock和Unlock之间的代码一旦出现异常情况导致panic，就会形成死锁。因此这里的逻辑是，即使是看起来非常简单的代码，使用defer也是有必要的，因为需求总在变化，代码也总会被修改。</p> 
<h3><a id="_28"></a>延迟语句的执行顺序是什么？</h3> 
<p>先看一下官方文档对defer的解释：<br> Each time a ＂defer＂statement executes，the function value and parameters to the call are evaluated asusual and saved anew but the actual function is not invoked.Instead，deferred functions are invoked immediately before the surrounding function returns，in the reverse order they were deferred.If a deferred function value evaluates to nil，execution panics when the function is invoked，not when the“defer＇statement is executed.（每次defer语句执行的时候，会把函数“压栈”，函数参数会被复制下来；当外层函数（注意不是代码块，如一个for循环块并不是外层函数）退出时，defer函数按照定义的顺序逆序执行；如果defer执行的函数为nil，那么会在最终调用函数的时候产生panic。）</p> 
<p>defer语句并不会马上执行，而是会进入一个栈，函数return前，会按先进后出的顺序执行。也就是说，最先被定义的defer语句最后执行。先进后出的原因是后面定义的函数可能会依赖前面的资源，自然要先执行；否则，如果前面先执行了，那后面函数的依赖就没有了，因而可能会出错。<br> 在defer函数定义时，对外部变量的引用有两种方式：函数参数、闭包引用。前者在defer定义时就把值传递给defer，并被cache起来；后者则会在defer函数真正调用时根据整个上下文确定参数当前的值。</p> 
<p>defer后面的函数在执行的时候，函数调用的参数会被保存起来，也就是复制了一份。真正执行的时候，实际上用到的是这个复制的变量，因此如果此变量是一个“值”，那么就和定义的时候是一致的。如果此变量是一个“引用”，那就可能和定义的时候不一致。<br> 举个例子：</p> 
<pre><code class="prism language-go"><span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
	<span class="token keyword">var</span> whatever <span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token keyword">struct</span><span class="token punctuation">{<!-- --></span><span class="token punctuation">}</span>

	<span class="token keyword">for</span> i <span class="token operator">:=</span> <span class="token keyword">range</span> whatever <span class="token punctuation">{<!-- --></span>
		<span class="token keyword">defer</span> <span class="token keyword">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
			fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span>
		<span class="token punctuation">}</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
	<span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>执行结果:</p> 
<pre><code class="prism language-go"><span class="token number">2</span>
<span class="token number">2</span>
<span class="token number">2</span>
</code></pre> 
<p>defer后面是一个闭包，i 是“引用”类型的变量，for 循环结束后 i 的值为 2 ，因此打印了3个2。</p> 
<p>再来看一个栗子:</p> 
<pre><code class="prism language-go"><span class="token keyword">type</span> number <span class="token builtin">int</span>

<span class="token keyword">func</span> <span class="token punctuation">(</span>n number<span class="token punctuation">)</span> <span class="token function">print</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
	fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>

<span class="token keyword">func</span> <span class="token punctuation">(</span>n <span class="token operator">*</span>number<span class="token punctuation">)</span> <span class="token function">pprint</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
	fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token operator">*</span>n<span class="token punctuation">)</span>
<span class="token punctuation">}</span>

<span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
	<span class="token keyword">var</span> n number

	<span class="token keyword">defer</span> n<span class="token punctuation">.</span><span class="token function">print</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
	<span class="token keyword">defer</span> n<span class="token punctuation">.</span><span class="token function">pprint</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
	<span class="token keyword">defer</span> <span class="token keyword">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
		n<span class="token punctuation">.</span><span class="token function">print</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
	<span class="token punctuation">}</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
	<span class="token keyword">defer</span> <span class="token keyword">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
		n<span class="token punctuation">.</span><span class="token function">pprint</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
	<span class="token punctuation">}</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
	n <span class="token operator">=</span> <span class="token number">3</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>执行结果：</p> 
<pre><code class="prism language-go"><span class="token number">3</span>
<span class="token number">3</span>
<span class="token number">3</span>
<span class="token number">0</span>
</code></pre> 
<p>需要注意的是，defer语句的执行顺序和定义的顺序相反。<br> 第四个defer 语句是闭包，引用外部函数的n，最终结果是3;第三个defer语句同上;第二个defer语句，n是引用，最终求值是3;第一个defer语句，对n直接求值，开始的时候n=0，所以最后是0。</p> 
<p>我们接着再来看两个栗子。</p> 
<p>🙉 <strong>可以思考一下下面例子return后的defer语句执行吗？</strong></p> 
<pre><code class="prism language-go"><span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
	<span class="token keyword">defer</span> <span class="token keyword">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
		fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"before return"</span><span class="token punctuation">)</span>
	<span class="token punctuation">}</span><span class="token punctuation">(</span><span class="token punctuation">)</span>

	<span class="token keyword">if</span> <span class="token boolean">true</span> <span class="token punctuation">{<!-- --></span>
		fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"during return"</span><span class="token punctuation">)</span>
		<span class="token keyword">return</span>
	<span class="token punctuation">}</span>

	<span class="token keyword">defer</span> <span class="token keyword">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
		fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"after return"</span><span class="token punctuation">)</span>
	<span class="token punctuation">}</span><span class="token punctuation">(</span><span class="token punctuation">)</span>

<span class="token punctuation">}</span>
</code></pre> 
<p>运行结果:</p> 
<pre><code class="prism language-go">during <span class="token keyword">return</span>
befer <span class="token keyword">return</span>
</code></pre> 
<p>解析: return 之后的defer 函数不能被注册，因此不能打印出after return。</p> 
<p>🙉🙉<strong>接下这个例子可以理解为对defer的原理的利用</strong>。在一些情况下，会故意用到defer的"先求值，再延迟调用"的性质。可以想象这样的场景：在一个函数里，需要打开两个文件进行合并操作，合并完成后，在函数结束前关闭打开的文件句柄。</p> 
<pre><code class="prism language-go"><span class="token keyword">func</span> <span class="token function">mergeFile</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token builtin">error</span> <span class="token punctuation">{<!-- --></span>
	<span class="token comment">// 打开文件一</span>
	f<span class="token punctuation">,</span> <span class="token boolean">_</span> <span class="token operator">:=</span> os<span class="token punctuation">.</span><span class="token function">Open</span><span class="token punctuation">(</span><span class="token string">"file1.txt"</span><span class="token punctuation">)</span>
	<span class="token keyword">if</span> f <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">{<!-- --></span>
		<span class="token keyword">defer</span> <span class="token keyword">func</span><span class="token punctuation">(</span>f io<span class="token punctuation">.</span>Closer<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
			<span class="token keyword">if</span> err <span class="token operator">:=</span> f<span class="token punctuation">.</span><span class="token function">Close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> err <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">{<!-- --></span>
				fmt<span class="token punctuation">.</span><span class="token function">Printf</span><span class="token punctuation">(</span><span class="token string">"defer close file1.txt err %v"</span><span class="token punctuation">,</span> err<span class="token punctuation">)</span>
			<span class="token punctuation">}</span>
		<span class="token punctuation">}</span><span class="token punctuation">(</span>f<span class="token punctuation">)</span>
	<span class="token punctuation">}</span>

	<span class="token comment">// 打开文件二</span>
	f<span class="token punctuation">,</span> <span class="token boolean">_</span> <span class="token operator">=</span> os<span class="token punctuation">.</span><span class="token function">Open</span><span class="token punctuation">(</span><span class="token string">"file2.txt"</span><span class="token punctuation">)</span>
	<span class="token keyword">if</span> f <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">{<!-- --></span>
		<span class="token keyword">defer</span> <span class="token keyword">func</span><span class="token punctuation">(</span>f io<span class="token punctuation">.</span>Closer<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
			<span class="token keyword">if</span> err <span class="token operator">:=</span> f<span class="token punctuation">.</span><span class="token function">Close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> err <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">{<!-- --></span>
				fmt<span class="token punctuation">.</span><span class="token function">Printf</span><span class="token punctuation">(</span><span class="token string">"defer close file2.txt err %v"</span><span class="token punctuation">,</span> err<span class="token punctuation">)</span>
			<span class="token punctuation">}</span>
		<span class="token punctuation">}</span><span class="token punctuation">(</span>f<span class="token punctuation">)</span>
	<span class="token punctuation">}</span>

	<span class="token comment">// ...</span>
	<span class="token keyword">return</span> <span class="token boolean">nil</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>上面代码用到了defer的原理，defer函数定义的时候，参数就已经复制进去了，之后，真正执行close()函数的时候就刚好关闭的是正确的“文件”了，很巧妙。如果不这样，将f当成函数参数传递进去的话，最后两个语句关闭的就是同一个文件了；都是打开的最后一个文件。<br> 在调用close()函数的时候要注意一点：先判断调用主体是否为空，否则可能会引用了一个空指针，进而panic。</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/3e2240b985e9c31ee190c18aa384a68d/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">C语言 利用指向结构体数组的指针将3个学生的全部信息输出</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/433526e8e23ff19b5e6be54b9191ae67/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">uniapp中uForm的setRules该放在哪里？</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>