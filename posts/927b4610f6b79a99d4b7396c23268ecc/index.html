<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>LeetCode——动态规划（四） - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="LeetCode——动态规划（四）" />
<meta property="og:description" content="刷题顺序及思路来源于代码随想录，网站地址：https://programmercarl.com 目录
322. 零钱兑换 - 力扣（LeetCode）
279. 完全平方数 - 力扣（LeetCode）
139. 单词拆分 - 力扣（LeetCode）
198. 打家劫舍 - 力扣（LeetCode）
213. 打家劫舍 II - 力扣（LeetCode）
337. 打家劫舍 III - 力扣（LeetCode）
322. 零钱兑换 - 力扣（LeetCode） 给你一个整数数组 coins ，表示不同面额的硬币；以及一个整数 amount ，表示总金额。
计算并返回可以凑成总金额所需的 最少的硬币个数 。如果没有任何一种硬币组合能组成总金额，返回 -1 。
你可以认为每种硬币的数量是无限的。
输入：coins = [1, 2, 5], amount = 11 输出：3 解释：11 = 5 &#43; 5 &#43; 1 import java.util.Arrays; /** * @author light * @Description * @create 2023-10-07 12:32 */ public class CoinChangeTest { public int coinChange(int[] coins, int amount) { int[] dp=new int[amount&#43;1]; Arrays." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/927b4610f6b79a99d4b7396c23268ecc/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-10-13T13:46:27+08:00" />
<meta property="article:modified_time" content="2023-10-13T13:46:27+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">LeetCode——动态规划（四）</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p>刷题顺序及思路来源于代码随想录，网站地址：<a href="https://programmercarl.com/" rel="nofollow" title="https://programmercarl.com">https://programmercarl.com</a> </p> 
<p id="main-toc"><strong>目录</strong></p> 
<p id="322.%20%E9%9B%B6%E9%92%B1%E5%85%91%E6%8D%A2%20-%20%E5%8A%9B%E6%89%A3%EF%BC%88LeetCode%EF%BC%89-toc" style="margin-left:0px;"><a href="#322.%20%E9%9B%B6%E9%92%B1%E5%85%91%E6%8D%A2%20-%20%E5%8A%9B%E6%89%A3%EF%BC%88LeetCode%EF%BC%89" rel="nofollow">322. 零钱兑换 - 力扣（LeetCode）</a></p> 
<p id="279.%20%E5%AE%8C%E5%85%A8%E5%B9%B3%E6%96%B9%E6%95%B0%20-%20%E5%8A%9B%E6%89%A3%EF%BC%88LeetCode%EF%BC%89-toc" style="margin-left:0px;"><a href="#279.%20%E5%AE%8C%E5%85%A8%E5%B9%B3%E6%96%B9%E6%95%B0%20-%20%E5%8A%9B%E6%89%A3%EF%BC%88LeetCode%EF%BC%89" rel="nofollow">279. 完全平方数 - 力扣（LeetCode）</a></p> 
<p id="139.%20%E5%8D%95%E8%AF%8D%E6%8B%86%E5%88%86%20-%20%E5%8A%9B%E6%89%A3%EF%BC%88LeetCode%EF%BC%89-toc" style="margin-left:0px;"><a href="#139.%20%E5%8D%95%E8%AF%8D%E6%8B%86%E5%88%86%20-%20%E5%8A%9B%E6%89%A3%EF%BC%88LeetCode%EF%BC%89" rel="nofollow">139. 单词拆分 - 力扣（LeetCode）</a></p> 
<p id="198.%20%E6%89%93%E5%AE%B6%E5%8A%AB%E8%88%8D%20-%20%E5%8A%9B%E6%89%A3%EF%BC%88LeetCode%EF%BC%89-toc" style="margin-left:0px;"><a href="#198.%20%E6%89%93%E5%AE%B6%E5%8A%AB%E8%88%8D%20-%20%E5%8A%9B%E6%89%A3%EF%BC%88LeetCode%EF%BC%89" rel="nofollow">198. 打家劫舍 - 力扣（LeetCode）</a></p> 
<p id="213.%20%E6%89%93%E5%AE%B6%E5%8A%AB%E8%88%8D%20II%20-%20%E5%8A%9B%E6%89%A3%EF%BC%88LeetCode%EF%BC%89-toc" style="margin-left:0px;"><a href="#213.%20%E6%89%93%E5%AE%B6%E5%8A%AB%E8%88%8D%20II%20-%20%E5%8A%9B%E6%89%A3%EF%BC%88LeetCode%EF%BC%89" rel="nofollow">213. 打家劫舍 II - 力扣（LeetCode）</a></p> 
<p id="337.%20%E6%89%93%E5%AE%B6%E5%8A%AB%E8%88%8D%20III%20-%20%E5%8A%9B%E6%89%A3%EF%BC%88LeetCode%EF%BC%89-toc" style="margin-left:0px;"><a href="#337.%20%E6%89%93%E5%AE%B6%E5%8A%AB%E8%88%8D%20III%20-%20%E5%8A%9B%E6%89%A3%EF%BC%88LeetCode%EF%BC%89" rel="nofollow">337. 打家劫舍 III - 力扣（LeetCode）</a></p> 
<hr id="hr-toc"> 
<p></p> 
<p></p> 
<h2 id="322.%20%E9%9B%B6%E9%92%B1%E5%85%91%E6%8D%A2%20-%20%E5%8A%9B%E6%89%A3%EF%BC%88LeetCode%EF%BC%89"><a href="https://leetcode.cn/problems/coin-change/" rel="nofollow" title="322. 零钱兑换 - 力扣（LeetCode）">322. 零钱兑换 - 力扣（LeetCode）</a></h2> 
<p>给你一个整数数组 <code>coins</code> ，表示不同面额的硬币；以及一个整数 <code>amount</code> ，表示总金额。</p> 
<p>计算并返回可以凑成总金额所需的 <strong>最少的硬币个数</strong> 。如果没有任何一种硬币组合能组成总金额，返回 <code>-1</code> 。</p> 
<p>你可以认为每种硬币的数量是无限的。</p> 
<pre><code>输入：coins = [1, 2, 5], amount = 11
输出：3 
解释：11 = 5 + 5 + 1</code></pre> 
<pre><code class="language-java">import java.util.Arrays;

/**
 * @author light
 * @Description
 * @create 2023-10-07 12:32
 */
public class CoinChangeTest {
	public int coinChange(int[] coins, int amount) {
		int[] dp=new int[amount+1];
		Arrays.fill(dp,Integer.MAX_VALUE);
		dp[0]=0;
		for (int i = 0; i &lt; coins.length; i++) { //先遍历物品
			for (int j = coins[i]; j &lt;=amount; j++) {
				//只有dp[j-coins[i]]不是初始最大值时，该位才有选择的必要---没有的话Integer.MAX_VALUE+1会越界
				if(dp[j-coins[i]]!=Integer.MAX_VALUE){
					dp[j]=Math.min(dp[j],dp[j-coins[i]]+1);
				}
			}
		}
		return dp[amount]==Integer.MAX_VALUE?-1:dp[amount];
	}
}
</code></pre> 
<p></p> 
<h2 id="279.%20%E5%AE%8C%E5%85%A8%E5%B9%B3%E6%96%B9%E6%95%B0%20-%20%E5%8A%9B%E6%89%A3%EF%BC%88LeetCode%EF%BC%89"><a href="https://leetcode.cn/problems/perfect-squares/description/" rel="nofollow" title="279. 完全平方数 - 力扣（LeetCode）">279. 完全平方数 - 力扣（LeetCode）</a></h2> 
<p>给你一个整数 <code>n</code> ，返回 <em>和为 <code>n</code> 的完全平方数的最少数量</em> 。</p> 
<p><strong>完全平方数</strong> 是一个整数，其值等于另一个整数的平方；换句话说，其值等于一个整数自乘的积。例如，<code>1</code>、<code>4</code>、<code>9</code> 和 <code>16</code> 都是完全平方数，而 <code>3</code> 和 <code>11</code> 不是。</p> 
<pre><code class="language-java">输入：n = 12
输出：3 
解释：12 = 4 + 4 + 4</code></pre> 
<pre><code class="language-java">class Solution {
//（思路：转换为完全背包问题
    public int numSquares(int n) {
        //dp[j]:和为j的完全平方数的最少数量为dp[j]
		int[] dp=new int[n+1];
		Arrays.fill(dp,Integer.MAX_VALUE);
		dp[0]=0;
		for (int i = 1; i*i&lt;=n; i++) { //先遍历物品--n之内的所有完全平方数
			for (int j = i*i; j &lt;=n; j++) { //在遍历背包
				if(dp[j-i*i]!=Integer.MAX_VALUE){
					dp[j]=Math.min(dp[j],dp[j-i*i]+1);
				}
			}
		}
		return dp[n];
    }
}</code></pre> 
<h2 id="139.%20%E5%8D%95%E8%AF%8D%E6%8B%86%E5%88%86%20-%20%E5%8A%9B%E6%89%A3%EF%BC%88LeetCode%EF%BC%89"><a href="https://leetcode.cn/problems/word-break/description/" rel="nofollow" title="139. 单词拆分 - 力扣（LeetCode）">139. 单词拆分 - 力扣（LeetCode）</a></h2> 
<p>给你一个字符串 <code>s</code> 和一个字符串列表 <code>wordDict</code> 作为字典。请你判断是否可以利用字典中出现的单词拼接出 <code>s</code> 。</p> 
<p><strong>注意：</strong>不要求字典中出现的单词全部都使用，并且字典中的单词可以重复使用。</p> 
<pre><code class="language-java">输入: s = "leetcode", wordDict = ["leet", "code"]
输出: true
解释: 返回 true 因为 "leetcode" 可以由 "leet" 和 "code" 拼接成。</code></pre> 
<pre><code class="language-java">import java.util.Arrays;
import java.util.HashSet;
import java.util.List;
import java.util.Set;

/**
 * @author light
 * @Description 单词拆分
 *
 *
 * （思路：转化为完全背包问题，字符串s--背包；字符串列表中的单词--物品
 * 单词就是物品，字符串s就是背包，单词能否组成字符串s，就是问物品能不能把背包装满。
 * 拆分时可以重复使用字典中的单词，说明就是一个完全背包
 *
 * @create 2023-10-07 16:25
 */
public class WordBreakTest {
	public boolean wordBreak(String s, List&lt;String&gt; wordDict) {
		//dp[j]:长度为j的字符串，dp[j]为true，表示可以利用字典中出现的单词拼接出 s
		boolean[] dp=new boolean[s.length()+1];
		Set&lt;String&gt; set=new HashSet&lt;&gt;(wordDict);
		Arrays.fill(dp,false); //初始化
		dp[0]=true;
		for (int i = 0; i &lt;s.length(); i++) { //求排列--先遍历背包
			for (int j = 0; j&lt;i; j++) { //再遍历物品
				String word=s.substring(j,i); //截取字符串
				if(set.contains(word)&amp;&amp;dp[j]==true){
					dp[i]=true;
				}
			}
		}
		return dp[s.length()];
	}
}
</code></pre> 
<h2 id="198.%20%E6%89%93%E5%AE%B6%E5%8A%AB%E8%88%8D%20-%20%E5%8A%9B%E6%89%A3%EF%BC%88LeetCode%EF%BC%89"><a href="https://leetcode.cn/problems/house-robber/description/" rel="nofollow" title="198. 打家劫舍 - 力扣（LeetCode）">198. 打家劫舍 - 力扣（LeetCode）</a></h2> 
<p>你是一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金，影响你偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统，<strong>如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警</strong>。</p> 
<p>给定一个代表每个房屋存放金额的非负整数数组，计算你<strong> 不触动警报装置的情况下 </strong>，一夜之内能够偷窃到的最高金额。</p> 
<pre><code>输入：[1,2,3,1]
输出：4
解释：偷窃 1 号房屋 (金额 = 1) ，然后偷窃 3 号房屋 (金额 = 3)。
     偷窃到的最高金额 = 1 + 3 = 4 。</code></pre> 
<pre><code>class Solution {
    public int rob(int[] nums) {
        if(nums.length==1){
			return nums[0];
		}
        //dp[i]:考虑偷(就是不一定偷)【0-i】间房，最多可以偷dp[i]的金额
		int[] dp=new int[nums.length+1];
		dp[0]=nums[0];
		dp[1]=Math.max(nums[1],dp[0]);
		for (int i = 2; i &lt; nums.length; i++) {
			dp[i]=Math.max(dp[i-1],dp[i-2]+nums[i]);
		}
		return dp[nums.length-1];
    }
}</code></pre> 
<h2 id="213.%20%E6%89%93%E5%AE%B6%E5%8A%AB%E8%88%8D%20II%20-%20%E5%8A%9B%E6%89%A3%EF%BC%88LeetCode%EF%BC%89"><a href="https://leetcode.cn/problems/house-robber-ii/description/" rel="nofollow" title="213. 打家劫舍 II - 力扣（LeetCode）">213. 打家劫舍 II - 力扣（LeetCode）</a></h2> 
<p>你是一个专业的小偷，计划偷窃沿街的房屋，每间房内都藏有一定的现金。这个地方所有的房屋都 <strong>围成一圈</strong> ，这意味着第一个房屋和最后一个房屋是紧挨着的。同时，相邻的房屋装有相互连通的防盗系统，<strong>如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警</strong> 。</p> 
<p>给定一个代表每个房屋存放金额的非负整数数组，计算你 <strong>在不触动警报装置的情况下</strong> ，今晚能够偷窃到的最高金额。</p> 
<pre><code>输入：nums = [2,3,2]
输出：3
解释：你不能先偷窃 1 号房屋（金额 = 2），然后偷窃 3 号房屋（金额 = 2）, 因为他们是相邻的。</code></pre> 
<pre><code class="language-java">/**
 * @author light
 * @Description 打家劫舍II

 * （思路：分三种情况   情况一包含在情况二、三中
 * 情况一：首尾都不考虑偷
 * 情况二：考虑偷首，不考虑偷尾
 * 情况三：考虑偷尾，不考虑偷首
 * @create 2023-10-11 10:10
 */
public class Rob2Test {
	public int rob(int[] nums) {
		if(nums.length==1){
			return nums[0];
		}
		//情况二
		int res1=robAction(nums,0, nums.length-2);
		//情况三
		int res2=robAction(nums,1, nums.length-1);
		return  Math.max(res1,res2);
	}
	public int robAction(int[] nums, int start, int end) {
		if(start==end){
			return nums[start];
		}
		//dp[i]:考虑偷(就是不一定偷)【0-i】间房，最多可以偷dp[i]的金额
		int[] dp=new int[end+1];
		dp[start]=nums[start];
		dp[start+1]=Math.max(dp[start],nums[start+1]);
		for (int i = start+2; i &lt;=end; i++) {
			dp[i]=Math.max(dp[i-1],dp[i-2]+nums[i]);
		}
		return dp[end];
	}
}
</code></pre> 
<h2 id="337.%20%E6%89%93%E5%AE%B6%E5%8A%AB%E8%88%8D%20III%20-%20%E5%8A%9B%E6%89%A3%EF%BC%88LeetCode%EF%BC%89"><a href="https://leetcode.cn/problems/house-robber-iii/description/" rel="nofollow" title="337. 打家劫舍 III - 力扣（LeetCode）">337. 打家劫舍 III - 力扣（LeetCode）</a></h2> 
<p>小偷又发现了一个新的可行窃的地区。这个地区只有一个入口，我们称之为 <code>root</code> 。</p> 
<p>除了 <code>root</code> 之外，每栋房子有且只有一个“父“房子与之相连。一番侦察之后，聪明的小偷意识到“这个地方的所有房屋的排列类似于一棵二叉树”。 如果 <strong>两个直接相连的房子在同一天晚上被打劫</strong> ，房屋将自动报警。</p> 
<p>给定二叉树的 <code>root</code> 。返回 <em><strong>在不触动警报的情况下</strong> ，小偷能够盗取的最高金额</em> 。</p> 
<p><img alt="" height="522" src="https://images2.imgbox.com/03/9c/5SSOy09n_o.png" width="674"></p> 
<pre><code class="language-java">
/**
 * @author light
 * @Description 打家劫舍III
 *
 * （思路：这里可以使用一个长度为2的数组，记录当前节点偷与不偷所得到的的最大金钱。
 *
 * 树形dp---采用后序遍历二叉树，当前结点有两种情况：
 * 1.考虑偷当前结点---不考虑偷当前结点的左右孩子结点
 * 2.不考虑偷当前结点---取考虑偷左孩子和考虑偷右孩子的最大值之和
 * @create 2023-10-11 10:59
 */
public class Rob3Test {
	public int rob(TreeNode root) {


		int res[]=robAction(root);
		return Math.max(res[0],res[1]);
	}
	public int[] robAction(TreeNode root){
		//dp[0]:考虑不偷当前结点所能获得的最高金额
		//dp[1]:考虑偷当前结点所能获得的最高金额
		int[] dp=new int[2];

		if(root==null){ //每一层都要判断，递归出口
			return dp;
		}
		int[] left=robAction(root.left);
		int[] right=robAction(root.right);
		//不考虑偷当前结点--取考虑偷左孩子和考虑偷右孩子的最大值之和
		dp[0]= Math.max(left[0],left[1])+Math.max(right[0],right[1]);
		//考虑偷当前结点---不考虑偷当前结点的左右孩子结点
		dp[1]=root.val+left[0]+right[0];
		return dp;
	}
}

</code></pre> 
<p></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/323037b72bc445555b14d76b9873b847/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">第八章：分布式系统的麻烦</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/a962be28ed46a1fb4c6195854dfc20b1/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">PG14归档失败解决办法archiver failed on wal_lsn</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>