<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Visual C&#43;&#43;游戏编程基础之利用鼠标消息实现贴图 - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Visual C&#43;&#43;游戏编程基础之利用鼠标消息实现贴图" />
<meta property="og:description" content="一、鼠标键入消息 1.WM_LBUTTONDBLCLK 双击鼠标左键；
2.WM_LBUTTONDOWN 单击鼠标左键；
3.WM_LBUTTONUP 松开鼠标左键；
4.鼠标中键及右键分别将上述L替换为M、R；
5.WM_MOUSEMOVE 鼠标移动消息；
6.WM_MOLSEWHEEL 鼠标滚轮消息；
二、鼠标消息处理 1.lParam：其参数值分为高位字节与低位字节，低位字节存储鼠标光标的X坐标值，高位字节存储Y坐标值；
WORD LOWORD(lParam 参数);
WORD HIWORD(lParam 参数);
2.wParam：记录鼠标按键及Ctrl、Shift键，通过wParam与测试标志的与操作判断按键是否按下；
测试标志：MK_L/M/RBUTTON(左中右)、MK_SHIFT、MK_CONTROL
3.当处理滚轮消息时，1不变，wParam低位字节存储按键的状态信息，高位字节是120或-120，表示向前或向后滚动；
三、鼠标相关函数 1.HWND SetCapture(HWND hwnd)；
功能：获取窗口外的鼠标消息；
2.BOOL SetCursorPos(int x轴坐标，int y轴坐标)；
功能：设定鼠标光标位置，这里的位置是相对于屏幕左上角的坐标；
3.BOOL ClientToScreen(HWND hwnd，LPPOINT 窗口点坐标)；
功能：窗口点坐标转换为屏幕坐标，然后再使用SetCursorPos函数；
4.BOOL ScreenToClient(HWND hwnd，LPPOINT 屏幕点坐标)；
功能：把屏幕坐标转换为窗口坐标；
5. int ShowCursor(BOOL true或false)；
功能：隐藏及显示鼠标光标；
6.BOOL ClipCursor(CONST RECT 移动区域矩形)；
功能：限制鼠标光标的移动区域，解除限制则参数设为NULL；
7.BOOL GetWindowRect(HWND hwnd，LPRECT 矩形结构)；
功能：取得窗口外部区域矩形；
8.BOOL GetClientRect(HWND hwnd，LPRECT 矩形结构)；
功能：取得窗口内部区域矩形；
四、飞机射击子弹的基本思路 1.一开始未按鼠标左键，则进行背景图的贴图并实现背景循环；
2.移动鼠标触发消息处理函数，获取鼠标光标的位置后，在贴图函数中，根据鼠标光标位置，确定飞机的贴图坐标，为了产生移
动效果，让飞机的坐标缓缓接近鼠标光标；
2.单击鼠标左键，消息处理函数处理该消息，设置第一颗子弹的贴图坐标(因为声明的子弹结构体是全局变量，所以它的成员变量 exist默认被初始化为0），然后回到贴图函数，先贴背景，再贴飞机，最后贴第一颗子弹，现在若不进行任何操作，则在主函数" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/15d57c0a52480eec5aa4218ef07f184a/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2019-06-13T21:39:43+08:00" />
<meta property="article:modified_time" content="2019-06-13T21:39:43+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Visual C&#43;&#43;游戏编程基础之利用鼠标消息实现贴图</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <h4><span style="color:#7c79e5;">一、鼠标键入消息</span></h4> 
<p>1.WM_<span style="color:#f33b45;">L</span><span style="color:#ffbb66;">BUTTON</span><span style="color:#86ca5e;">DBL</span><span style="color:#e579b6;">CLK       </span>双击鼠标左键；</p> 
<p>2.WM_<span style="color:#f33b45;">L</span><span style="color:#ffbb66;">BUTTON</span><span style="color:#86ca5e;">DOWN</span>         单击鼠标左键；</p> 
<p>3.WM_<span style="color:#f33b45;">L</span><span style="color:#ffbb66;">BUTTON</span><span style="color:#86ca5e;">UP               </span>松开鼠标左键；</p> 
<p>4.鼠标中键及右键分别将上述<span style="color:#f33b45;">L</span>替换为M、R；</p> 
<p>5.WM_MOUSEMOVE            鼠标移动消息；</p> 
<p>6.WM_MOLSEWHEEL          鼠标滚轮消息；</p> 
<h4><span style="color:#7c79e5;">二、鼠标消息处理</span></h4> 
<p>1.lParam：其参数值分为高位字节与低位字节，低位字节存储鼠标光标的X坐标值，高位字节存储Y坐标值；</p> 
<p>   WORD   LOWORD(lParam 参数);</p> 
<p>   WORD   HIWORD(lParam 参数);</p> 
<p>2.wParam：记录鼠标按键及Ctrl、Shift键，通过wParam与测试标志的与操作判断按键是否按下；</p> 
<p>   测试标志：MK_L/M/RBUTTON(左中右)、MK_SHIFT、MK_CONTROL</p> 
<p>3.当处理滚轮消息时，1不变，wParam低位字节存储按键的状态信息，高位字节是120或-120，表示向前或向后滚动；</p> 
<h4><span style="color:#7c79e5;">三、鼠标相关函数</span></h4> 
<p>1.HWND  SetCapture(HWND hwnd)；</p> 
<p>   功能：获取窗口外的鼠标消息；</p> 
<p>2.BOOL   SetCursorPos(int x轴坐标，int y轴坐标)；</p> 
<p>   功能：设定鼠标光标位置，这里的位置是相对于屏幕左上角的坐标；</p> 
<p>3.BOOL  ClientToScreen(HWND hwnd，LPPOINT  窗口点坐标)；</p> 
<p>   功能：窗口点坐标转换为屏幕坐标，然后再使用SetCursorPos函数；</p> 
<p>4.BOOL  ScreenToClient(HWND hwnd，LPPOINT  屏幕点坐标)；</p> 
<p>   功能：把屏幕坐标转换为窗口坐标；</p> 
<p>5. int      ShowCursor(BOOL true或false)；</p> 
<p>   功能：隐藏及显示鼠标光标；</p> 
<p>6.BOOL ClipCursor(CONST RECT 移动区域矩形)；</p> 
<p>   功能：限制鼠标光标的移动区域，解除限制则参数设为NULL；</p> 
<p>7.BOOL GetWindowRect(HWND hwnd，LPRECT 矩形结构)；</p> 
<p>   功能：取得窗口外部区域矩形；</p> 
<p>8.BOOL GetClientRect(HWND hwnd，LPRECT 矩形结构)；</p> 
<p>   功能：取得窗口内部区域矩形；</p> 
<h4><span style="color:#7c79e5;">四、飞机射击子弹的基本思路</span></h4> 
<p>1.一开始未按鼠标左键，则进行背景图的贴图并实现背景循环；</p> 
<p>2.移动鼠标触发消息处理函数，获取鼠标光标的位置后，在贴图函数中，根据鼠标光标位置，确定飞机的贴图坐标，为了产生移</p> 
<p>   动效果，让飞机的坐标缓缓接近鼠标光标；</p> 
<p>2.单击鼠标左键，消息处理函数处理该消息，设置第一颗子弹的贴图坐标(<span style="color:#f33b45;">因为声明的子弹结构体是全局变量，所以它的成员变量  </span></p> 
<p><span style="color:#f33b45;">   exist默认被初始化为0</span>），然后回到贴图函数，先贴背景，再贴飞机，最后贴第一颗子弹，现在若不进行任何操作，则在主函数</p> 
<p>   内继续循环，该子弹的贴图坐标每次循环横坐标都要减10，直到小于0；</p> 
<p>3.在第一颗子弹未消失之前，继续单击鼠标左键，此时实现的是两颗子弹的贴图，一直循环一直贴，直到消失；</p> 
<h4><span style="color:#7c79e5;">五、效果</span></h4> 
<p><img alt="" class="has" height="400" src="https://images2.imgbox.com/5d/6c/mFSglWeK_o.gif" width="540"></p> 
<h4><span style="color:#7c79e5;">六、代码实现</span></h4> 
<pre class="has"><code class="language-cpp">
#include "stdafx.h"
#include &lt;stdio.h&gt;


struct BULLET//定义子弹结构体
{
	int x,y;
	bool exist;
};


HINSTANCE hInst;
HBITMAP bg,ship,bullet;
HDC		hdc,mdc,bufdc;
HWND	hWnd;
DWORD	tPre,tNow;
int		x,y,nowX,nowY;//光标坐标,飞机贴图坐标
int		w=0,bcount;//w为滚动背景所要裁剪的宽度；记录飞机现有的子弹数目
BULLET  b[30];//存储飞机发出的子弹

ATOM				MyRegisterClass(HINSTANCE hInstance);
BOOL				InitInstance(HINSTANCE, int);
LRESULT CALLBACK	WndProc(HWND, UINT, WPARAM, LPARAM);
void				MyPaint(HDC hdc);


int APIENTRY WinMain(HINSTANCE hInstance,
                     HINSTANCE hPrevInstance,
                     LPSTR     lpCmdLine,
                     int       nCmdShow)
{
	MSG msg;

	MyRegisterClass(hInstance);


	if (!InitInstance (hInstance, nCmdShow)) 
	{
		return FALSE;
	}


    while( msg.message!=WM_QUIT )
    {
        if( PeekMessage( &amp;msg, NULL, 0,0 ,PM_REMOVE) )
        {
            TranslateMessage( &amp;msg );
            DispatchMessage( &amp;msg );
        }
		else
		{
			tNow = GetTickCount();
			if(tNow-tPre &gt;= 40)
				MyPaint(hdc);
		}
    }

	return msg.wParam;
}


ATOM MyRegisterClass(HINSTANCE hInstance)
{
	WNDCLASSEX wcex;

	wcex.cbSize = sizeof(WNDCLASSEX); 
	wcex.style			= CS_HREDRAW | CS_VREDRAW | CS_DBLCLKS;
	wcex.lpfnWndProc	= (WNDPROC)WndProc;
	wcex.cbClsExtra		= 0;
	wcex.cbWndExtra		= 0;
	wcex.hInstance		= hInstance;
	wcex.hIcon			= NULL;
	wcex.hCursor		= NULL;
	wcex.hCursor		= LoadCursor(NULL, IDC_ARROW);
	wcex.hbrBackground	= (HBRUSH)(COLOR_WINDOW+1);
	wcex.lpszMenuName	= NULL;
	wcex.lpszClassName	= "canvas";
	wcex.hIconSm		= NULL;

	return RegisterClassEx(&amp;wcex);
}


BOOL InitInstance(HINSTANCE hInstance, int nCmdShow)
{
	HBITMAP bmp;
	POINT pt,lt,rb;
	RECT rect;

	hInst = hInstance;

	hWnd = CreateWindow("canvas", "绘图窗口" , WS_OVERLAPPEDWINDOW,
		CW_USEDEFAULT, 0, CW_USEDEFAULT, 0, NULL, NULL, hInstance, NULL);

	if (!hWnd)
	{
		return FALSE;
	}

	MoveWindow(hWnd,100,100,640,480,true);
	ShowWindow(hWnd, nCmdShow);
	UpdateWindow(hWnd);

	hdc = GetDC(hWnd);
	mdc = CreateCompatibleDC(hdc);
	bufdc = CreateCompatibleDC(hdc);

	bmp = CreateCompatibleBitmap(hdc,640,480);
	SelectObject(mdc,bmp);

	bg = (HBITMAP)LoadImage(NULL,"bg.bmp",IMAGE_BITMAP,648,480,LR_LOADFROMFILE);
	ship = (HBITMAP)LoadImage(NULL,"ship.bmp",IMAGE_BITMAP,100,148,LR_LOADFROMFILE);
	bullet = (HBITMAP)LoadImage(NULL,"bullet.bmp",IMAGE_BITMAP,10,20,LR_LOADFROMFILE);
	
	x = 300;              
	y = 300;
	nowX = 300;
	nowY = 300;

	设定鼠标光标位置
	pt.x = 300;
	pt.y = 300;
	ClientToScreen(hWnd,&amp;pt);//把窗口坐标转化为屏幕坐标，因为SetCursorPos只认屏幕坐标
	SetCursorPos(pt.x,pt.y);
	
	ShowCursor(false);		//隐藏鼠标光标

	//限制鼠标光标移动区域
	GetClientRect(hWnd,&amp;rect);//获取客户区窗口的大小
	lt.x = rect.left;
	lt.y = rect.top;
	rb.x = rect.right;
	rb.y = rect.bottom;
	ClientToScreen(hWnd,&amp;lt);
	ClientToScreen(hWnd,&amp;rb);
	rect.left = lt.x;
	rect.top = lt.y;
	rect.right = rb.x;
	rect.bottom = rb.y;
	ClipCursor(&amp;rect);//限制鼠标在矩形区域内

	MyPaint(hdc);

	return TRUE;
}


void MyPaint(HDC hdc)
{
	char str[20] = "";
	int i;

	
	SelectObject(bufdc,bg);
	BitBlt(mdc,0,0,w,480,bufdc,640-w,0,SRCCOPY);
	BitBlt(mdc,w,0,640-w,480,bufdc,0,0,SRCCOPY);
	
	//飞机贴图缓慢向鼠标移动
	if(nowX &lt; x)
	{
		nowX += 10;
		if(nowX &gt; x)
			nowX = x;
	}
	else
	{
		nowX -=10;
		if(nowX &lt; x)
			nowX = x;
	}

	if(nowY &lt; y)
	{
		nowY += 10;
		if(nowY &gt; y)
			nowY = y;
	}
	else
	{
		nowY -= 10;
		if(nowY &lt; y)
			nowY = y;
	}


	SelectObject(bufdc,ship);
	BitBlt(mdc,nowX,nowY,100,74,bufdc,0,74,SRCAND);
	BitBlt(mdc,nowX,nowY,100,74,bufdc,0,0,SRCPAINT);

	SelectObject(bufdc,bullet);
	if(bcount!=0)
		for(i=0;i&lt;30;i++)
		
			if(b[i].exist)
			{
			
				BitBlt(mdc,b[i].x,b[i].y,10,10,bufdc,0,10,SRCAND);
				BitBlt(mdc,b[i].x,b[i].y,10,10,bufdc,0,0,SRCPAINT);

				b[i].x -= 10;
				if(b[i].x &lt; 0)
				{
					bcount--;
					b[i].exist = false;
				}
			}
		


	sprintf(str,"X坐标%d    ",x);
	TextOut(mdc,0,0,str,strlen(str));
	sprintf(str,"Y坐标%d    ",y);
	TextOut(mdc,0,20,str,strlen(str));

	BitBlt(hdc,0,0,640,480,mdc,0,0,SRCCOPY);

	tPre = GetTickCount();

	w += 10;
	if(w==640)
		w = 0;
}


LRESULT CALLBACK WndProc(HWND hWnd, UINT message, WPARAM wParam, LPARAM lParam)
{
	int i;

	switch (message)
	{
		case WM_KEYDOWN:				
			if(wParam==VK_ESCAPE)		//只要按下一次鼠标左键，都会从(nowX,nowY+30)出现一颗子弹
				PostQuitMessage(0);
			break;
		
		case WM_LBUTTONDOWN:			
			for(i=0;i&lt;30;i++)
			{

				if(!b[i].exist)
				{
					b[i].x = nowX;		
					b[i].y = nowY + 30; 
					b[i].exist = true;
					bcount++;			
					break;
				}
			}


		case WM_MOUSEMOVE:
			x = LOWORD(lParam);			
			if(x &gt; 530)
				x = 530;
			else if(x &lt; 0)
				x = 0;

			y = HIWORD(lParam);		
			if(y &gt; 380)
				y = 380;
			else if(y &lt; 0)
				y = 0;
				
			break;
		case WM_DESTROY:				
			ClipCursor(NULL);			

			DeleteDC(mdc);
			DeleteDC(bufdc);
			DeleteObject(bg);
			DeleteObject(bullet);
			DeleteObject(ship);
			ReleaseDC(hWnd,hdc);

			PostQuitMessage(0);
			break;
		default:					
			return DefWindowProc(hWnd, message, wParam, lParam);
   }
   return 0;
}

</code></pre> 
<p> </p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/2a28a9c9ede149a22b90eb97a419bdc8/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">eclipse创建一个java web项目？为什么创建的javaweb项目没有web.xml  如何在已经创建好的项目中增加 web.xml</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/15701f8660d00b61eb88e5285fc526a9/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">云计算介绍之云计算存储(5)存储高级特性</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>