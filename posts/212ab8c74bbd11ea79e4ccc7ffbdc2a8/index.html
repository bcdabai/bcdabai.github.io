<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>强化学习：在表征空间中进行新颖性搜索以实现样本的高效探索 - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="强化学习：在表征空间中进行新颖性搜索以实现样本的高效探索" />
<meta property="og:description" content="题目：Novelty Search in Representational Space for Sample Efficient Exploration
出处：Neural Information Processing Systems (NeurIPS，2020)，人工智能领域顶级会议。
摘要：我们提出了一种新的有效探索方法，该方法利用所学环境的低维编码，并结合基于模型和无模型的目标。我们的方法使用基于低维表征空间中最近距离的内在奖励来衡量新奇性。然后，我们利用这些内在奖励进行样本有效的探索，并在代表性空间中规划例程，以完成具有稀疏奖励的硬探索任务。我们的方法的一个关键要素是使用信息论原理来塑造我们的表现，使我们的新奇奖励超越像素相似性。我们在一系列迷宫任务和一个控制问题上测试了我们的方法，结果表明，与强基线相比，我们的探索方法具有更高的样本效率。
1，Introduction 为了有效地解决强化学习（RL）中的任务，主要挑战之一是通过有效地探索状态空间来收集信息性经验。探索的一种常见方法是利用与新奇性的某些指标或分数相关的内在回报（Schmidhuber，2010；Stadie et al.，2015；Houthooft et al.，2016）。通过内在奖励，可以激励代理有效地探索其状态空间。计算这些新颖性得分的直接方法是根据观察结果得出奖励，例如基于计数的奖励（Bellemare et al.，2016；Ostrovski et al.，2017）或基于预测误差的奖励（Burda et al.，2018b）。然而，当直接从原始观测值测量新颖性时，会出现一个问题，因为像素空间中的一些信息（如随机性或背景）可能是不相关的。在这种情况下，如果代理想要有效地探索其状态空间，它应该只关注有意义的新信息。
在这项工作中，我们提出了一种通过在有意义的潜在状态空间中利用内在奖励来实现样本有效探索的方法。为了构建有意义的状态抽象，我们从信息理论的角度来看待基于模型的RL（MBRL）——我们通过信息瓶颈（Tishby et al.，2000）原则来优化我们的动态学习。我们还通过联合表示将基于模型和无模型的组件结合起来。该方法将高维观测值编码为低维表示，以便将动力学上接近的状态在表示空间中紧密结合在一起（François-Lavet et al.，2018）。我们还添加了其他约束，以确保抽象状态之间的距离度量是有意义的。我们利用我们表示的这些属性，在低维表示空间中基于欧几里德距离制定一个新颖性分数，然后使用该分数生成内在奖励，我们可以利用这些奖励进行有效的探索。
我们的探索算法的一个重要因素是，我们采用模型预测控制（MPC）方法（Garcia等人，1989年），只有在我们的模型足够精确（从而确保准确的新颖性启发式）后才能执行操作。通过这项训练计划，我们的智能体还能够以示例有效的方式学习其状态空间的有意义表示。所有实验的代码都可用。
2，Problem setting agent通过离散时间步与其环境进行交互，建模为马尔可夫决策过程（MDP），由6元组 定义（Puterman，1994）：
是状态空间。 是初始状态分布。 是离散动作空间。 是假定为确定性的过渡函数（有可能通过生成方法扩展到随机环境）。 是奖励，其中 。 折扣系数。 在时间 处于状态 ，智能体基于策略 选择动作 ，因此 。执行完动作 ，智能体到达状态 并得到回报 并且折扣因子 。在 个环境步骤中，我们定义了先前访问状态的缓冲区 ，其中 。在RL中，通常的目标是最大化预期未来回报的总和 。
为了学习最大化预期回报的策略 ，RL智能体必须有效地探索其环境（以尽可能少的步骤达到新的状态）。在本文中，我们考虑报酬稀少甚至没有报酬的任务，并且对需要尽可能少的步骤来探索状态空间的探索策略感兴趣。
3，抽象状态表示 当我们的状态（或部分可观测情况下的观测值（Kaelbling et al.，1998））是高维状态时，我们重点学习状态的低维表示（Dayan，1993；Tamar et al.，2016；Silver et al.，2016；Oh et al." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/212ab8c74bbd11ea79e4ccc7ffbdc2a8/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-10-26T09:44:26+08:00" />
<meta property="article:modified_time" content="2022-10-26T09:44:26+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">强化学习：在表征空间中进行新颖性搜索以实现样本的高效探索</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <blockquote> 
 <p><strong><span style="color:#fe2c24;">题目：</span>Novelty Search in Representational Space for Sample Efficient Exploration</strong></p> 
 <p><strong><span style="color:#fe2c24;">出处：</span>Neural Information Processing Systems (NeurIPS，2020)，人工智能领域顶级会议。</strong></p> 
 <p><strong><span style="color:#fe2c24;">摘要：</span>我们提出了一种新的有效探索方法，<span style="color:#fe2c24;">该方法利用所学环境的低维编码，并结合基于模型和无模型的目标。</span>我们的方法使用基于低维表征空间中<span style="color:#fe2c24;">最近距离的内在奖励来衡量新奇性。</span>然后，<span style="color:#956fe7;">我们利用这些内在奖励进行样本有效的探索，并在代表性空间中规划例程，以完成具有稀疏奖励的硬探索任务。</span>我们的方法的一个关键要素是使用信息论原理来塑造我们的表现，使我们的新奇奖励超越像素相似性。我们在一系列迷宫任务和一个控制问题上测试了我们的方法，结果表明，与强基线相比，我们的探索方法具有更高的样本效率。</strong></p> 
</blockquote> 
<h3><span style="color:#4da8ee;">1，Introduction</span></h3> 
<blockquote> 
 <p>为了有效地解决强化学习（RL）中的任务，主要挑战之一是通过有效地探索状态空间来收集信息性经验。探索的一种常见方法是利用与新奇性的某些指标或分数相关的内在回报（Schmidhuber，2010；Stadie et al.，2015；Houthooft et al.，2016）。<strong>通过内在奖励，可以激励代理有效地探索其状态空间。</strong>计算这些新颖性得分的直接方法是根据观察结果得出奖励，例如基于计数的奖励（Bellemare et al.，2016；Ostrovski et al.，2017）或基于预测误差的奖励（Burda et al.，2018b）。然而，当直接从原始观测值测量新颖性时，会出现一个问题，因为像素空间中的一些信息（如随机性或背景）可能是不相关的。在这种情况下，如果代理想要有效地探索其状态空间，<strong>它应该只关注有意义的新信息。</strong></p> 
 <p>在这项工作中，<strong>我们提出了一种通过在有意义的潜在状态空间中利用内在奖励来实现样本有效探索的方法。</strong>为了构建有意义的状态抽象，我们从信息理论的角度来看待基于模型的RL（MBRL）——我们通过信息瓶颈（Tishby et al.，2000）原则来优化我们的动态学习。我们还通过联合表示将基于模型和无模型的组件结合起来。该方法将高维观测值编码为低维表示，以便将动力学上接近的状态在表示空间中紧密结合在一起（François-Lavet et al.，2018）。我们还添加了其他约束，<strong>以确保抽象状态之间的距离度量是有意义的。</strong>我们利用我们表示的这些属性，在低维表示空间中基于欧几里德距离制定一个新颖性分数，然后使用该分数生成内在奖励，我们可以利用这些奖励进行有效的探索。</p> 
 <p>我们的探索算法的一个重要因素是，我们采用模型预测控制（MPC）方法（Garcia等人，1989年），只有在我们的模型足够精确（从而确保准确的新颖性启发式）后才能执行操作。通过这项训练计划，我们的智能体还能够以示例有效的方式学习其状态空间的有意义表示。所有实验的代码都可用。</p> 
</blockquote> 
<h3><span style="color:#4da8ee;">2，Problem setting</span></h3> 
<blockquote> 
 <p><strong>agent通过离散时间步与其环境进行交互，建模为马尔可夫决策过程（MDP），由6元组<img alt="(S,S_0,A,\tau,R,G)" class="mathcode" src="https://images2.imgbox.com/d5/c5/Ow8pJTEC_o.png"> 定义（Puterman，1994）：</strong></p> 
 <ul><li><strong><img alt="S" class="mathcode" src="https://images2.imgbox.com/8b/e1/3G6xS6KK_o.png"> 是状态空间。</strong></li><li><img alt="S_0" class="mathcode" src="https://images2.imgbox.com/1d/2d/Py26JhVX_o.png"> <strong>是初始状态分布。</strong></li><li><strong><img alt="A" class="mathcode" src="https://images2.imgbox.com/ea/8b/b7tLzruM_o.png"> 是离散动作空间。</strong></li><li><strong><img alt="\tau:X\times A\rightarrow S" class="mathcode" src="https://images2.imgbox.com/ed/16/JHv4Fr8H_o.png"> 是假定为确定性的过渡函数（有可能通过生成方法扩展到随机环境）。</strong></li><li><strong><img alt="R:S\times A\rightarrow R" class="mathcode" src="https://images2.imgbox.com/e2/36/godq3lge_o.png"> 是奖励，其中 <img alt="R=[-1,1]" class="mathcode" src="https://images2.imgbox.com/da/b0/qVgbh2I3_o.png">。</strong></li><li><strong><img alt="G:S\times A\rightarrow [0,1)" class="mathcode" src="https://images2.imgbox.com/0b/69/CRNvIjvb_o.png"> 折扣系数。</strong></li></ul> 
 <p><strong>在时间 <img alt="t" class="mathcode" src="https://images2.imgbox.com/1f/2d/gmaxbGiL_o.png"> 处于状态 <img alt="s_t\in S" class="mathcode" src="https://images2.imgbox.com/3e/b4/gdc35wf5_o.png">，智能体基于策略 <img alt="\pi:S\times A\rightarrow [0,1)" class="mathcode" src="https://images2.imgbox.com/be/88/vsEEnEIT_o.png"> 选择动作 <img alt="a_t\in A" class="mathcode" src="https://images2.imgbox.com/93/8a/rbkKw3t3_o.png">，因此 <img alt="a_t\sim \pi(s_t,\cdot)" class="mathcode" src="https://images2.imgbox.com/3d/12/eQ98YP76_o.png">。执行完动作 <img alt="a_t" class="mathcode" src="https://images2.imgbox.com/78/4e/l4M4bTac_o.png"> ，智能体到达状态 <img alt="s_{t+1}=\tau(s_t,a_t)" class="mathcode" src="https://images2.imgbox.com/2a/41/JxX7nZDd_o.png"> 并得到回报 <img alt="r_t\sim R(s_t,a_t)" class="mathcode" src="https://images2.imgbox.com/51/db/u411giUN_o.png">并且折扣因子 <img alt="\gamma_t\sim G" class="mathcode" src="https://images2.imgbox.com/df/33/GmxoZhAS_o.png">。</strong><strong>在 <img alt="n" class="mathcode" src="https://images2.imgbox.com/5f/c3/qLxWaFzv_o.png"> 个环境步骤中，我们定义了先前访问状态的缓冲区 <img alt="B=(s_1,...,s_n)" class="mathcode" src="https://images2.imgbox.com/41/ed/KPNxDtJ3_o.png">，其中 <img alt="s_i\in S\, \forall i\in \mathbb{N}" class="mathcode" src="https://images2.imgbox.com/94/67/U5Tc7pRp_o.png">。在RL中，通常的目标是最大化预期未来回报的总和<img alt="V_{\pi}(s)=\mathbb{E}_{\pi}\left [ r_t+\sum_{i-1}^{\infty } \left ( \prod_{j=0}^{i-1}\gamma_{t+j} \right )r_{t+i}|s=s_t\right ]" class="mathcode" src="https://images2.imgbox.com/83/5c/4UGgXwcf_o.png"> 。</strong></p> 
 <p><strong>为了学习最大化预期回报的策略 <img alt="\pi" class="mathcode" src="https://images2.imgbox.com/92/c8/hSZddvjN_o.png">，RL智能体必须有效地探索其环境（以尽可能少的步骤达到新的状态）。<span style="color:#fe2c24;">在本文中，我们考虑报酬稀少甚至没有报酬的任务，并且对需要尽可能少的步骤来探索状态空间的探索策略感兴趣。</span></strong></p> 
</blockquote> 
<h3><span style="color:#4da8ee;">3，抽象状态表示</span></h3> 
<blockquote> 
 <p>当我们的状态（或部分可观测情况下的观测值（Kaelbling et al.，1998））是高维状态时，我们重点学习状态的低维表示（Dayan，1993；Tamar et al.，2016；Silver et al.，2016；Oh et al.，2017；de Bruin et al.，2018；Ha和Schmidhuber，2018；François Lavet et al.，2018；Hafner et al.，2018；Gelada et al.，2019）。</p> 
</blockquote> 
<h4><span style="color:#4da8ee;">3.1，信息瓶颈</span></h4> 
<blockquote> 
 <p>我们首先激励我们的模型学习方法。为此，我们考虑了<span style="color:#fe2c24;"><strong>信息瓶颈（IB）</strong></span>（Tishby et al.，2000）原则。设 <img alt="Z" class="mathcode" src="https://images2.imgbox.com/93/be/pK6FNmSQ_o.png"> 表示原始源消息空间 <img alt="\tilde{Z}" class="mathcode" src="https://images2.imgbox.com/cb/50/cqh1qXoG_o.png"> 表示其压缩表示。与传统的无损压缩不同，在传统无损压缩中，我们寻求找到相应的编码<img alt="\tilde{Z}" class="mathcode" src="https://images2.imgbox.com/76/10/C2rSS4C1_o.png">，以压缩Z的所有方面， 在IB中，我们寻求只保<img alt="\tilde{Z}" class="mathcode" src="https://images2.imgbox.com/b4/01/orhJQS2y_o.png">中与另一个相关变量 <img alt="Y" class="mathcode" src="https://images2.imgbox.com/06/f0/2mOodJC0_o.png"> 相关的信息。例如，如果我们手头的任务是语音识别，那么在压缩语音波形（<img alt="Z" class="mathcode" src="https://images2.imgbox.com/a4/2c/spuczsOw_o.png">）时， 那么我们的关联变量 <img alt="Y" class="mathcode" src="https://images2.imgbox.com/b0/4b/DKV4TeC4_o.png"> 将是语音的转录本。我们的表<img alt="\tilde{Z}" class="mathcode" src="https://images2.imgbox.com/2d/4f/aHhlS3F1_o.png">只需要最大化有关转录本<img alt="Y" class="mathcode" src="https://images2.imgbox.com/23/47/V9Gv8QDR_o.png">的相关信息，而不是其完整形式，包括音调、音调、背景噪音等。我们可以通过最小化以下关于 <img alt="p(\tilde{z}|z)" class="mathcode" src="https://images2.imgbox.com/41/b1/a9eTPwSq_o.png"> ：</p> 
 <p style="text-align:center;"><img alt="L\left ( p\left ( \tilde{z}|z \right ) \right )=I\left [ Z;\tilde{Z} \right ]-\beta I\left [ \tilde{Z} ;Y\right ]" class="mathcode" src="https://images2.imgbox.com/af/d1/m5OkGq8l_o.png"></p> 
 <p>其中 <img alt="I[\cdot;\cdot]" class="mathcode" src="https://images2.imgbox.com/86/0f/FKSitU1Q_o.png"> 是两个随机变量之间的<span style="color:#fe2c24;"><strong>互信息（MI）</strong></span>。<img alt="\beta" class="mathcode" src="https://images2.imgbox.com/10/88/O6c8nMxW_o.png"> 是我们编码的信息量的拉格朗日乘，<img alt="\tilde{Z}" class="mathcode" src="https://images2.imgbox.com/9b/b7/z242ykdU_o.png">可以量化<img alt="Y" class="mathcode" src="https://images2.imgbox.com/ac/11/bmdhHL6y_o.png">。这对应于最小化编码率 <img alt="I[Z;\tilde{Z}]" class="mathcode" src="https://images2.imgbox.com/4a/b4/1zC30U8d_o.png"> 和最大化编码与随机变量<img alt="Y" class="mathcode" src="https://images2.imgbox.com/3f/12/ZsCejHxN_o.png">之间的互信息之间的权衡。</p> 
 <p>现在，我们将此原则应用于MBRL中的状态表示学习。如果我们的源消息空间是我们的状态<img alt="S^{'}" class="mathcode" src="https://images2.imgbox.com/2f/15/31hCd4pw_o.png">，编码消息是<img alt="X^{'}" class="mathcode" src="https://images2.imgbox.com/1c/15/01SVNMsr_o.png">，那么要提取与我们环境的动态相关的最相关信息，一个相关变量的选择是 <img alt="\left \{ X,A \right \}" class="mathcode" src="https://images2.imgbox.com/16/25/ohRF51aZ_o.png">，即我们在前一个时间步中的编码状态以及动作的存在。这为我们提供了功能：</p> 
 <p style="text-align:center;"><img alt="L\left ( p\left ( x^{'}|s^{'} \right ) \right )=I\left [ S^{'};X^{'} \right ]-\beta I\left [ X^{'};\left \{ X,A \right \} \right ]" class="mathcode" src="https://images2.imgbox.com/ea/c8/B63vpVPe_o.png"></p> 
 <p>在我们的工作中，我们希望找到一种方法来最小化这个函数，从而最大化我们的动力学模型的预测能力。</p> 
 <p>我们的首要目标是最小化编码速率<img alt="I\left [ S^{'};X^{'} \right ]" class="mathcode" src="https://images2.imgbox.com/e8/b3/bTakFVza_o.png">。由于编码速率是对每条消息传输的比特数的度量，所以<img alt="S^{'}" class="mathcode" src="https://images2.imgbox.com/1f/da/cuUSGGkd_o.png">表示维度类似于每条消息的比特数。这种最小化编码率的原则指导我们选择表示每个环境的维度，我们尝试选择尽可能最小的表示维度，以便表示仍然可以封装我们理解的模型动力学。例如，在一个简单的Gridworld示例中，我们只对网格世界中的智能体位置进行编码。</p> 
 <p>现在让我们考虑方程中的第二项。我们的目标是学习环境的最佳预测模型。为此，我们首先考虑表示动作 <img alt="A" class="mathcode" src="https://images2.imgbox.com/44/6c/GGxEiqQb_o.png"> 的随机变量与表示下一时间步 <img alt="X^{'}" class="mathcode" src="https://images2.imgbox.com/5d/cb/X1RQ01zS_o.png"> 状态表示的随机变量之间的MI（Still，2009）。请注意，MI是一个度量，并且是对称的：</p> 
 <p style="text-align:center;"><img alt="I\left [ \left \{ X,A \right \};X^{'} \right ]=\mathbb{E}_{p(x^{'},x,a)}\left [ log\left ( \frac{p(x^{'}|x,a)}{p(x^{'})} \right ) \right ]=H\left [ X^{'} \right ]-H\left [ X^{'}|X,A \right ]" class="mathcode" src="https://images2.imgbox.com/bc/df/h34VI15q_o.png"></p> 
 <p>这个数量是我们的动力学模型预测能力的度量。<strong>如果我们考虑两个<span style="color:#fe2c24;">熵</span>项</strong>（表示为 <img alt="H[\cdot]" class="mathcode" src="https://images2.imgbox.com/80/2b/yeQXGitv_o.png">），我们看到，<img alt="H\left [ X^{'} \right ]" class="mathcode" src="https://images2.imgbox.com/99/0e/rRqPG4VU_o.png"> 构成我们状态表示的熵，<img alt="H\left [ X^{'}|X,A \right ]" class="mathcode" src="https://images2.imgbox.com/71/90/4WUFVZr3_o.png"> 作为下一个状态 <img alt="X^{'}" class="mathcode" src="https://images2.imgbox.com/e5/9d/aQ6jTeMu_o.png"> 的熵，给定当前状态 <img alt="X" class="mathcode" src="https://images2.imgbox.com/ed/dc/atZnMG7d_o.png"> 和动作 <img alt="A" class="mathcode" src="https://images2.imgbox.com/d7/6a/LuhEqNmG_o.png">。回想一下，对于某些编码函数 <img alt="X=e(S)" class="mathcode" src="https://images2.imgbox.com/09/0d/EXXUe6nx_o.png">，我们试图最小化 <img alt="I\left [ X^{'};S^{'} \right ]" class="mathcode" src="https://images2.imgbox.com/3d/c6/KmfiBC98_o.png">，最大化 <img alt="I\left [ X^{'};\left \{ X,A \right \} \right ]" class="mathcode" src="https://images2.imgbox.com/ec/39/sySzfYS0_o.png">。在下一节中，我们将描述此编码函数的方法以及MBRL中的动力学学习。</p> 
 <p></p> 
</blockquote> 
<h4><span style="color:#4da8ee;">3.2，编码和动态学习</span></h4> 
<blockquote> 
 <p>出于我们的目的，<strong>我们使用神经编码器 <img alt="\hat{e}:S\rightarrow X" class="mathcode" src="https://images2.imgbox.com/84/c1/Qr2wU7wm_o.png">，通过 <img alt="\theta_{\hat{e}}" class="mathcode" src="https://images2.imgbox.com/1a/4b/rSZegNzM_o.png"> 参数化，将高维状态空间映射为低维抽象表示，</strong>其中 <img alt="X\subseteq \mathbb{R}^{n_{X}}" class="mathcode" src="https://images2.imgbox.com/49/1a/SqaCC3Q2_o.png"> 。通过以下功能学习动力学：过渡函数 <img alt="\hat{\tau}:X\times A\rightarrow X" class="mathcode" src="https://images2.imgbox.com/0a/fd/irGKHM38_o.png">，通过 <img alt="\theta_{\hat{\tau}}" class="mathcode" src="https://images2.imgbox.com/ea/a6/6mXk6Iqp_o.png"> 参数化，奖励函数 <img alt="\hat{r}:X\times A\rightarrow [-1,1]" class="mathcode" src="https://images2.imgbox.com/5e/01/bzuri7yV_o.png"> 通过 <img alt="\theta_{\hat{r}}" class="mathcode" src="https://images2.imgbox.com/a1/64/atniAWLe_o.png"> 参数化，和每个时间步折扣系数函数 <img alt="\hat{\gamma}:X\times A\rightarrow [0,1)" class="mathcode" src="https://images2.imgbox.com/6f/6a/TT5KTmKG_o.png">，通过 <img alt="\theta_{\hat{\gamma}}" class="mathcode" src="https://images2.imgbox.com/a2/67/aNVp13gT_o.png"> 参数化，该折扣因子仅用于预测终端状态，其中 <img alt="\gamma = 0" class="mathcode" src="https://images2.imgbox.com/36/d7/JMB6kwBq_o.png">。</p> 
 <p>为了利用所有过去的经验，我们使用了一种非策略学习算法，从重播缓冲区中对转换元组<img alt="(s,a,r,\gamma,s^{'})" class="mathcode" src="https://images2.imgbox.com/6f/19/wwXUK1bm_o.png"> 进行采样。我们首先用编码器对当前和下一个状态进行编码，以获得 <img alt="x\leftarrow \hat{e}(s;\theta_{\hat{e}})" class="mathcode" src="https://images2.imgbox.com/4c/a3/8TMlsonI_o.png">，<img alt="x^{'}\leftarrow \hat{e}(s^{'};\theta_{\hat{e}})" class="mathcode" src="https://images2.imgbox.com/68/94/nqLI4l21_o.png">。使用DDQN算法学习Q函数（van Hasselt等人，2015），该算法使用以下目标：</p> 
 <p style="text-align:center;"><img alt="Y=r+\gamma Q\left ( \hat{e}\left ( s^{'};\theta_{\hat{e}^{-}} \right ) ,\underset{a^{'}\in A}{argmax}\,Q(x^{'},a^{'};\theta_Q);\theta_{Q^{-}}\right )" class="mathcode" src="https://images2.imgbox.com/99/eb/CaC7YZiE_o.png"></p> 
 <p>其中 <img alt="\theta_{Q^{-}}" class="mathcode" src="https://images2.imgbox.com/a8/75/2osknZN5_o.png"> 和 <img alt="\theta_{\hat{e}^{-}}" class="mathcode" src="https://images2.imgbox.com/ec/0f/9iwOBJTs_o.png"> 分别是早期缓冲Q函数（或我们的目标Q函数）和编码器的参数。然后智能体将以下损失降至最低：</p> 
 <p style="text-align:center;"><img alt="L_Q(\theta_Q)=\left ( Q\left ( x,a;\theta_Q \right )-Y \right )^2" class="mathcode" src="https://images2.imgbox.com/30/b0/tivIMHvD_o.png"></p> 
 <p>我们通过以下损失了解环境的动态：</p> 
 <p style="text-align:center;"><img alt="L_R\left ( \theta_{\hat{e}},\theta_{\hat{r}} \right )=\left | r-\hat{r}(x,a;\theta_{\hat{r}}) \right |^2,L_G(\theta_{\hat{e}},\theta_{\hat{\gamma}})=\left |\gamma -\hat{\gamma}(x,a;\theta_{\hat{\gamma}}) \right |^2" class="mathcode" src="https://images2.imgbox.com/43/61/eyZ8kqV8_o.png"></p> 
 <p>以及我们的转移损失：</p> 
 <p style="text-align:center;"><img alt="L_{\gamma}\left ( \theta_{\hat{e}},\theta_{\gamma} \right )=||\left [ x+\hat{\gamma}\left ( x,a;\theta_{\hat{\gamma}} \right ) \right ]-x^{'}||_2^2" class="mathcode" src="https://images2.imgbox.com/1e/17/zPkCflmn_o.png">   （3）</p> 
 <p>请注意，我们的转移函数学习先前状态 <img alt="x" class="mathcode" src="https://images2.imgbox.com/6d/93/hbPac6ls_o.png"> 和当前状态 <img alt="x^{'}" class="mathcode" src="https://images2.imgbox.com/17/f2/XC5wfs4r_o.png"> 之间的差异（给定动作）。通过联合学习编码器和不同组件的权重，可以根据环境的动态以有意义的方式形成抽象表示。特别是，通过最小化等式3中给出的关于编码器参数 <img alt="\theta_{\hat{e}}" class="mathcode" src="https://images2.imgbox.com/b1/a8/wlmQSdk7_o.png">（或 <img alt="p(x|s)" class="mathcode" src="https://images2.imgbox.com/07/b3/1ptEI8dJ_o.png">）的损失，我们最小化了熵<img alt="H\left [ X^{'}|X,A \right ]" class="mathcode" src="https://images2.imgbox.com/25/5b/xQvtI5Bz_o.png">。</p> 
 <p>为了最大化我们学习到的抽象状态表示 <img alt="H[ X^{'} ]" class="mathcode" src="https://images2.imgbox.com/c0/64/LhCG0qX9_o.png"> 的熵，我们最小化了状态之间的预期成对高斯势（Borodachov et al.，2019）：</p> 
 <p class="img-center"><img alt="L_{d1}(\theta_{\hat{e}})=\mathbb{E}_{s_1,s_2\sim p(s)}\left [ exp\left ( -C_{d1}||\hat{e}(s_1;\theta_{\hat{e}}) -\hat{e}\left ( s_2;\theta_{\hat{e}} \right )\right ||_2^2) \right ]" class="mathcode" src="https://images2.imgbox.com/7b/3f/p0wzuwgu_o.png"></p> 
 <p>将 <img alt="C_{d1}" class="mathcode" src="https://images2.imgbox.com/4c/2e/mZpX2Zyz_o.png"> 作为超参数。方程式3和方程式4中的损失让人想起François Lavet et al.（2018）中基于模型的损失，并分别对应于Wang和Isola（2020）中的校准和统一对比损失公式，其中，对齐确保相似的状态紧密相连（在编码表示空间中），一致性确保所有状态均匀分布在这个低维表示空间中。</p> 
 <p>损失 <img alt="L_{\gamma}(\theta_{\hat{e}})" class="mathcode" src="https://images2.imgbox.com/bf/1b/Lf2IvEY2_o.png"> 和 <img alt="L_{d1}(\theta_{\hat{e}})" class="mathcode" src="https://images2.imgbox.com/8c/b7/jOLEOBFH_o.png"> 使 <img alt="I[\left \{ X,A \right \};X^{'}]" class="mathcode" src="https://images2.imgbox.com/bd/65/zHjsDtQj_o.png"> 项最大化，并且为我们的表示选择较小的维数使<img alt="I[X^{'},S^{'}]" class="mathcode" src="https://images2.imgbox.com/07/c2/dlad8b6q_o.png"> 最小化。综上所述，我们的方法试图根据方程1最小化 <img alt="L\left ( p(x^{'}|s^{'}) \right )" class="mathcode" src="https://images2.imgbox.com/2a/ee/zZZ66Z4W_o.png">。</p> 
</blockquote> 
<h4><span style="color:#4da8ee;">3.3，表征空间中的距离度量</span></h4> 
<blockquote> 
 <p>出于实际目的，由于我们希望使用<img alt="X" class="mathcode" src="https://images2.imgbox.com/72/0d/5qwhBwnz_o.png">范围内的距离度量作为新颖性得分，我们通过限制两个连续州之间的 <img alt="\rho _2" class="mathcode" src="https://images2.imgbox.com/39/13/rl56UxMA_o.png"> 距离来确保状态与状态之间定义明确的距离：</p> 
 <p style="text-align:center;"><img alt="L_{csc}(\theta_{\hat{e}})=max(||\hat{e}(s_1;\theta_e)-\hat{e}(s_2;\theta_e)||_2-w,0)" class="mathcode" src="https://images2.imgbox.com/cc/ec/QKJvo02L_o.png"></p> 
 <p>其中，<img alt="L_{csc}" class="mathcode" src="https://images2.imgbox.com/a8/8a/I9ZioPu6_o.png"> 是连续状态 <img alt="s_1" class="mathcode" src="https://images2.imgbox.com/f2/c1/iy5eT5Km_o.png"> 和 <img alt="s_2" class="mathcode" src="https://images2.imgbox.com/4b/ed/d7ZKsL8T_o.png"> 之间的软约束，倾向于将两个连续编码表示强制为相距 <img alt="w" class="mathcode" src="https://images2.imgbox.com/65/d9/K1MpYzAZ_o.png"> 。我们添加了<img alt="L_{csc}" class="mathcode" src="https://images2.imgbox.com/cb/27/9Q97JF2M_o.png">，以确保在我们的内在报酬计算中使用的抽象状态之间有一个明确定义的<img alt="\rho _2" class="mathcode" src="https://images2.imgbox.com/43/91/MEmyZQ2Z_o.png">距离（附录B中提供了对该损失的讨论）。我们在附录A中讨论了如何使用<img alt="w" class="mathcode" src="https://images2.imgbox.com/98/e4/ksV2bIPn_o.png">来评估MPC更新的模型精度。最后，我们通过梯度下降来最小化所有上述损失的总和：   </p> 
</blockquote> 
<h3><span style="color:#4da8ee;">4， 抽象表征空间中的新颖性搜索</span></h3> 
<blockquote> 
 <p>我们的探索方法使用内在动机（Schmidhuber，1990；Chentanez et al.，2005；Achiam and Sastry，2017），其中代理人根据收集有趣经验的事实来奖励自己。在大型状态空间设置中，很少访问状态，n步之后的任何状态的计数几乎总是0。Bellemare et al.（2016）通过直接从高维观测值中使用伪计数进行密度估计来解决这一问题，我们的目标是在我们所学的低维表示空间中估计一些新颖的函数。</p> 
</blockquote> 
<h4><span style="color:#4da8ee;">4.1，表示空间中的稀疏性作为新颖性度量</span></h4> 
<blockquote> 
 <p>通过等式1的最小化，动力学上紧密相连的状态在抽象状态空间<img alt="X" class="mathcode" src="https://images2.imgbox.com/c1/61/5lrcAieV_o.png">中被推到了一起。理想情况下，我们需要一个能够有效探索其环境动力学的代理。为了做到这一点，我们奖励我们的智能体在低维表示空间中探索访问较少的区域，理想情况下尽可能远离我们目前已知的动力学。</p> 
 <p>给定表示空间中的一个点 <img alt="x" class="mathcode" src="https://images2.imgbox.com/84/65/26WRXGcJ_o.png">，我们定义了一个考虑<img alt="x" class="mathcode" src="https://images2.imgbox.com/06/e4/taK7XLB4_o.png">周围状态稀疏性的奖励函数-我们使用<img alt="x" class="mathcode" src="https://images2.imgbox.com/34/75/wyAxgcOL_o.png">与其访问历史缓冲区B中的<img alt="k" class="mathcode" src="https://images2.imgbox.com/17/77/WqSXcH7h_o.png">个最近邻居之间的平均距离来实现：</p> 
 <p style="text-align:center;"><img alt="\hat{\rho}x(x)=\frac{1}{k}\sum_{i=1}^kd(x,x_i)" class="mathcode" src="https://images2.imgbox.com/67/df/0wWOQwRe_o.png"></p> 
 <p>其中 <img alt="x\doteq \hat{e}(s;\theta_{\hat{e}})" class="mathcode" src="https://images2.imgbox.com/13/11/G7EhbBlB_o.png"> 是给定的编码状态，<img alt="k\in \mathbb{Z}^{+}" class="mathcode" src="https://images2.imgbox.com/a7/c6/NdC1QrBv_o.png">，<img alt="d(\cdot,\cdot)" class="mathcode" src="https://images2.imgbox.com/ae/a6/hIvejboL_o.png"> 是 <img alt="\mathbb{R}^{nx}" class="mathcode" src="https://images2.imgbox.com/b0/68/3Ck4djHe_o.png"> 某种距离度量单位并且 <img alt="x_i\doteq \hat{e}(s_i;\theta_{\hat{e}})" class="mathcode" src="https://images2.imgbox.com/19/0f/KfXMGGm5_o.png"> ，其中 <img alt="s_i\in B" class="mathcode" src="https://images2.imgbox.com/ae/ff/dmqgkbQF_o.png"> 对于 <img alt="i=1...k" class="mathcode" src="https://images2.imgbox.com/5c/f4/tMOOQbPF_o.png"> 是 <img alt="x" class="mathcode" src="https://images2.imgbox.com/d9/e0/Q94UcwLe_o.png"> 的 <img alt="k" class="mathcode" src="https://images2.imgbox.com/23/59/8G6T3WXy_o.png"> 个最近邻（通过将状态编码到表示空间），根据距离度量<img alt="d(\cdot,\cdot)" class="mathcode" src="https://images2.imgbox.com/c3/1d/G9hPcCEW_o.png">。此度量中隐含的是对代理的访问历史缓冲区 <img alt="B" class="mathcode" src="https://images2.imgbox.com/1e/a5/0m2hZRwJ_o.png"> 的依赖。</p> 
 <p>此分数中的一个重要因素是使用哪种距离度量。对于第3节中使用的损耗，我们使用<img alt="\rho _2" class="mathcode" src="https://images2.imgbox.com/16/9b/gX4BXw3X_o.png">距离，因为方程4和5的抽象状态空间上施加了结构。 </p> 
 <p>正如附录D所示，这种新颖性奖励让人想起重新编码概率（Bellemare et al.，2016；Cover and Thomas，2012），事实上与这些概率成反比，这表明我们的新颖性启发式估计访问计数。这也是雷曼兄弟（Lehman）和斯坦利（Stanley）（2011）用来衡量行为空间“稀疏性”的分数。</p> 
 <p>利用这个奖励函数，我们在算法1中为我们的探索算法提供了伪代码。</p> 
 <p class="img-center"><img alt="" height="324" src="https://images2.imgbox.com/40/2b/q5OEZPPD_o.png" width="623"></p> 
</blockquote> 
<h4><span style="color:#4da8ee;">4.2，渐近行为</span></h4> 
<blockquote> 
 <p>该奖励函数还表现出良好的渐近行为，因为当访问大多数状态空间时，它会减小到0。我们在定理1中说明了这一点。</p> 
 <p>定理1：假设我们有一个有限的状态空间 <img alt="S\subseteq \mathbb{R}^d" class="mathcode" src="https://images2.imgbox.com/62/b7/YwBsLk4v_o.png">，状态历史 <img alt="B=(s_1,..,s_N)" class="mathcode" src="https://images2.imgbox.com/ce/ee/FsTCGUcP_o.png">，编码状态空间 <img alt="X\subseteq \mathbb{R}^{nx}" class="mathcode" src="https://images2.imgbox.com/34/a5/PVDDi9qs_o.png">，确定性映射 <img alt="f:\mathbb{R}^d\rightarrow \mathbb{R}^{nx}" class="mathcode" src="https://images2.imgbox.com/61/34/0GM14PGY_o.png"> 和定义为 <img alt="\hat{\rho}x(x)" class="mathcode" src="https://images2.imgbox.com/cb/38/zedTbZhc_o.png"> 的新奇奖励。对于新奇启发式的奖励，如果有一个最优策略，我们的代理将倾向于具有更高内在回报的状态。如果我们假设一个可通信的MDP设置（Puterman，1994），那么：</p> 
 <p style="text-align:center;"><img alt="\underset{N\rightarrow \infty }{lim}\hat{\rho}x(f(s))=0,\forall s\in S" class="mathcode" src="https://images2.imgbox.com/8a/c0/UkDSjwbK_o.png"></p> 
</blockquote> 
<h4><span style="color:#4da8ee;">4.3，为勘探策略组合无模型和基于模型的组件</span></h4> 
<blockquote> 
 <p>与之前的工作类似（如Oh等人，2017；Chebotar等人，2017），我们将基于模型的规划与无模型Q学习相结合，以获得良好的政策。我们根据我们的过渡模型 <img alt="\hat{\tau}" class="mathcode" src="https://images2.imgbox.com/f8/17/UjsudYNr_o.png"> 计算下一个状态的推出估计，并总结相应的奖励，我们将其表示为 <img alt="r:X\times A\rightarrow [0,R_{max}]" class="mathcode" src="https://images2.imgbox.com/61/d5/l6tzmBP5_o.png"> 可以是内在和外在奖励的组合。我们根据d-depth推出的折扣奖励计算预期回报：</p> 
 <p style="text-align:center;"><img alt="" height="78" src="https://images2.imgbox.com/09/67/LaaWM4sH_o.png" width="426"></p> 
 <p>注意，我们在基于 <img alt="Q(x,a;\theta_Q)" class="mathcode" src="https://images2.imgbox.com/15/88/PwAP9o4u_o.png"> 的每个扩展步骤中只模拟b-best选项，其中 <img alt="b\leqslant |A|" class="mathcode" src="https://images2.imgbox.com/fe/b6/XEs2RSAM_o.png">。在这项工作中，我们只使用完全展开。估计的最佳行动如下所示：</p> 
 <p style="text-align:center;"> <img alt="a^{*}=\underset{a\in A}{argmax}\, \hat{Q}^d(s,a)" class="mathcode" src="https://images2.imgbox.com/ea/cb/32fggEVJ_o.png"></p> 
 <p>在每个步骤中选择的实际操作遵循 <img alt="\epsilon" class="mathcode" src="https://images2.imgbox.com/0c/2a/rQoocq4D_o.png">-贪婪策略（<img alt="\epsilon" class="mathcode" src="https://images2.imgbox.com/9f/0a/Rekcq7sf_o.png">∈ [0,1]），其中代理以概率1遵循估计的最优操作1−<img alt="\epsilon" class="mathcode" src="https://images2.imgbox.com/e3/53/ZqKw15Xq_o.png">和概率为<img alt="\epsilon" class="mathcode" src="https://images2.imgbox.com/6d/8e/AEPZISXf_o.png">的随机动作。 </p> 
 <p class="img-center"><img alt="" height="233" src="https://images2.imgbox.com/21/cf/vdwfUiHs_o.png" width="617"></p> 
 <p>（a）、（b）：绘制500个环境步骤后，从图7a和7b中学习到的开放和4室迷宫环境抽象表示的完整历史。颜色表示代理位于迷宫的哪一侧，显示网格坐标和过渡。（c） ：300步后，我们的多步迷宫的两个相同的完整学习历史抽象三维表示视图。橙色和蓝色点分别表示没有键和有键的状态。我们的代理能够从两组状态之间的距离中分辨出代理拥有密钥的状态和没有密钥的状态。在抽象状态空间中，状态的相对位置也保持着关于agent位置的有意义信息。</p> 
</blockquote> 
<h3><span style="color:#4da8ee;">5，实验</span></h3> 
<blockquote> 
 <p>我们在不同难度的环境中进行实验。所有实验都使用了一种训练方案，在进行环境步骤之前，我们首先训练参数，使其收敛于已经经历的过渡的精确表示。我们优化了第3节中给出的损失（在多次训练迭代中）。我们在Ap-pendix J中讨论了所有特定于环境的超参数。</p> 
</blockquote> 
<h4><span style="color:#4da8ee;">5.1，迷宫探索</span></h4> 
<blockquote> 
 <p>我们考虑两个21×21版本的网格世界环境（附录中的图7）。第一个是一个开放的迷宫网格世界，除了边界墙之外没有墙。第二个是一个大小相似的网格世界，分为四个相连的房间。在这些环境中，动作空间是四个基本方向的集合。这些环境没有奖励或终端状态，目标是探索，对任何任务都不可知。我们使用两个指标来衡量这种环境下的勘探：第一个是仅访问一次的状态的比例，第二个是访问的总状态的比例。</p> 
</blockquote> 
<blockquote> 
 <p>开放式迷宫：在开放迷宫实验（图2a）中，我们将我们的方法的许多变化与随机基线和基于计数的基线进行了比较（Bellemare等人，2016）（因为我们可以在此表格设置中计算状态）。该策略的变化包括argmax超过状态值（d=0）和规划深度d∈ {1,5}. 我们的方法的所有变体都优于此任务中的两个基线，随着规划深度d的增加，性能略有提高。在开放迷宫中，我们的代理能够在大约800个步骤中达到100%的可能状态（总共19×19=361个唯一状态），以及80%的可能状态(≈ 290个状态），大约500个步骤。这些计数还包括训练前采取的九个随机步骤数。</p> 
 <p>我们的智能体在探索其状态空间时，也能够在很少的环境步骤（如图1a所示）中学习高度可解释的抽象表示。此外，在访问其环境中大多数看不见的状态后，我们的代理倾向于一致地探索其状态空间，这是由于我们的新颖启发式的性质。附录H中提供了这种影响的可视化。</p> 
</blockquote> 
<blockquote> 
 <p>4室迷宫：我们现在考虑4室迷宫环境，这是开放迷宫环境的一个更具挑战性的版本（图1a）。与之前一样，我们的编码器 <img alt="\hat{e}" class="mathcode" src="https://images2.imgbox.com/24/45/WpLC0rlI_o.png"> 能够接受高维输入并将其压缩为低维表示。在这两种迷宫环境中，表示包含了与代理在二维中的位置相关的知识，我们称之为主要特征。在4室迷宫环境中，它还必须学习其他信息，例如代理环境（墙、开放空间）等，但它只能通过通过经验学习的过渡功能来实现。我们将这一无关但必要的信息称为次要特征。由于这些次要特征中的大多数仅在动力学模型ˆτ中编码，我们的代理必须经历一个转换，以便准确地表示主要和次要特征。</p> 
 <p>特别是在这种环境中，我们的动力学模型可能会过度概括房间之间的墙，有时一开始无法尝试房间之间通道中的过渡。然而，由于我们的代理倾向于统一访问已知房间内可到达的所有状态，因此我们方法的-贪婪策略仍然确保代理有效地探索通道，即使是在过度泛化到周围墙壁的情况下。</p> 
 <p>我们在4室迷宫域上进行了与开放迷宫相同的实验，结果如图2b所示。在这两种情况下，我们的方法都优于该领域的两个基线（随机和基于计数）。</p> 
 <p class="img-center"><img alt="" height="230" src="https://images2.imgbox.com/0f/54/mbdWvlIq_o.png" width="609"></p> 
</blockquote> 
<h4><span style="color:#4da8ee;">5.2，控制和子目标探索</span></h4> 
<blockquote> 
 <p>为了测试我们的方法在固定迷宫之外的有效性，我们在基于控制的环境Acrobot（Brockman et al.，2016）和多步迷宫环境中进行了实验。我们的方法（规划深度d=5）与不同原型的强勘探基线进行了比较：</p> 
 <ul><li>预测误差激励勘探（Stadie et al.，2015）</li><li>基于哈希计数的探索（Tang等人，2016）</li><li>随机网络蒸馏（Osband et al.，2017）</li><li>Bootstrap DQN（BDQN，Osband等人（2016））</li></ul> 
 <p>为了保持结果的一致性，我们始终使用相同的深度学习体系结构。由于我们在确定性环境中进行实验，我们排除了需要某种形式随机性或密度估计的基线作为基线（例如，Shyam et al.（2018）和Osband et al.（2017））。我们的方法的一个特殊性是，我们在所有实验的每个环境步骤之间运行多个训练迭代，与大多数无模型RL算法（都在同一事件中）相比，这允许代理使用数量级更少的样本。</p> 
</blockquote> 
<blockquote> 
 <p>Acrobot：现在，我们在Acrobot（Brockman et al.，2016）上测试我们的方法，Acrobot具有连续的状态空间，与迷宫环境不同。我们特别选择这项控制任务，因为这种环境的性质使得勘探本身就很困难。代理仅控制内部关节的执行器，并且必须将足够的能量传输到第二个关节，以便将其摆动到目标状态。我们修改了这个环境，使每集最多有3000个环境步骤。虽然这种环境确实存在外在的回报，但我们完全忽略了这些回报。为了衡量我们的勘探方法的性能，我们测量了每集agent将其第二个关节移动到给定线以上所需的平均步骤数，如图所示3a。</p> 
 <p class="img-center"><img alt="" height="302" src="https://images2.imgbox.com/11/60/fPwv6vL8_o.png" width="621"></p> 
 <p>为了证明我们的方法从像素输入学习低维抽象表示的能力，我们使用4个连续像素帧作为输入，而不是6维全状态向量。我们使用四维抽象表示我们的状态，实验结果如表1所示。我们的方法比基线更有效地达到目标状态。</p> 
 <p class="img-center"><img alt="" height="298" src="https://images2.imgbox.com/90/6e/CyGWS63O_o.png" width="631"></p> 
</blockquote> 
<blockquote> 
 <p>多步目标迷宫：我们还将在一个更复杂的迷宫上测试我们的方法，子任务是拿起一把钥匙，打开通向奖励区域的门。我们使用Pycolab游戏引擎构建环境（Stepleton，2017）。可以在图3b中看到环境，其中对代理的输入是环境的自顶向下视图。虽然这种环境确实允许有外在的奖励（1是为了拿起钥匙，10是为了达到最终状态），但我们忽略了这些奖励，只关注内在的奖励。</p> 
 <p>在我们的实验中，我们证明了我们的代理能够以样本有效的方式学习环境的可解释表示。图1c显示了达到目标后在该领域学习的表征示例-我们观察到迷宫中的位置对应于低维表征中几乎相同的结构。我们的表示还通过分离两组状态（拾取密钥时的状态和未拾取密钥时的状态），很好地捕获了内部状态信息（是否拾取了密钥）。两组状态中的相似位置也在低维空间中紧密映射在一起（即（1，1，带键）在` 2中接近（1，1，无键）），表明相似状态之间具有良好的泛化性。</p> 
</blockquote> 
<h3><span style="color:#4da8ee;">6，相关工作 </span></h3> 
<blockquote> 
 <p>拟议的勘探战略属于定向勘探的范畴（Thrun，1992），利用过去与环境的相互作用来指导发现新的状态。这项工作的灵感来自新颖性搜索算法（Lehman和Stanley，2011），该算法使用最近邻评分法来衡量政策空间中的新颖性。我们的方法利用该评分遍历动态空间，这是我们理论上激发的。探索策略已经用无模型和基于模型的方法进行了研究。在Bellemare et al.（2016）和Ostrovski et al.（2017）中，无模型算法通过任意密度模型的伪计数提供了新颖性的概念，该模型提供了在类似状态下采取行动的次数估计。最近，Taiga et al.（2020）对无模型RL中基于奖金的探索方法进行了彻底的比较，并表明架构变化可能对代理性能（基于外在奖励）更为重要，而不是不同的探索策略。</p> 
</blockquote> 
<blockquote> 
 <p>一些勘探策略还使用了环境模型和规划。Hes-ter和Stone（2012）采用两部分策略计算内在奖励，结合模型不确定性（来自基于随机森林的模型）和基于特征空间中L1距离的新奇奖励。Salge等人（2014）研究的策略；Mohamed和Rezende（2015）；Gregor等人（2016）；Chiappa等人（2017年）的目的是让代理人通过规划选择一系列行动，从而使国家的代表性尽可能不同于当前的国家。Pathak等人（2017年）；Haber等人（2018年），代理优化了其环境模型和预测其自身模型误差/不确定性的单独模型。Burda et al.（2018a）基于其动力学模型的不确定性，同样使用了一种内在回归。在Shyam等人（2018年）中，环境正向模型用于衡量未来状态之间分歧产生的新颖性。Still和Precup（2012）采用信息论的方法进行探索，选择一种能够最大化代理人自身行为和环境回报预测能力的政策。在Badia等人（2020年）的研究中，k-NN对代理人经验的内在回报也被用于探索。与我们的方法相反，他们使用一个自监督逆动力学模型来学习嵌入。除了提高勘探效率外，我们方法的可解释性还可能导致人类在环技术（Mandel et al.，2017；Abel et al.，2017）用于勘探，使代理能够更好地利用代理在表示空间中的可解释性反馈。</p> 
</blockquote> 
<h3><span style="color:#4da8ee;">7，讨论</span></h3> 
<blockquote> 
 <p>在本文中，我们通过信息瓶颈原理来描述MBRL中的动力学学习任务。我们提出了通过低维抽象状态表示优化IB方程的方法。我们根据这些学习到的表征进一步开发了一个新颖性分数，我们将其作为一种内在奖励，以实现有效的探索。通过将这种新颖性评分与基于模型和无模型的规划方法相结合，我们可以通过学习到的表达和新颖性奖励，在多个环境中展示更有效的探索。与大多数方法一样，我们的方法也有局限性。我们可能存在的一个限制是非参数方法（如k-NN密度估计）的可伸缩性，因为我们的方法与环境步骤数呈线性伸缩。这个问题的一个可能解决方案是使用一些抽样方案对固定数量的观测值进行抽样，以计算我们的新颖性启发式。由于使用极低维空间来表示状态而产生的另一个问题是泛化。在某些情况下，模型可能会过度泛化，导致低维表示丢失对整个状态空间的探索至关重要的信息。未来工作的一个重要方向是找到合并第5.1.2节所述次要特征的方法。一个有趣的可能性是使用类似的IB方法，但使用状态的完整历史作为条件变量。除此之外，我们还将在附录K中讨论这项工作的局限性和潜在改进。最后，我们将在附录G中展示我们的方法在更复杂任务（Montezuma的复仇）上的初步结果。利用本文开发的理论和方法，我们希望看到在更复杂环境动力学的更大任务上进行的未来工作。</p> 
</blockquote>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/d71ee37336dfd4691636e0f1253e7e1c/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">协程的简单操作，你都知道哪些？Golang如何实现协程交替打印？</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/8188620405b4e8e848d9f6063100a89c/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">mysql创建数据库并指定字符集</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>