<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>2022最新超详细Spring全家桶面试题(待更新ing) - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="2022最新超详细Spring全家桶面试题(待更新ing)" />
<meta property="og:description" content="2022最新超详细Spring全家桶面试题完整版 0. 参考视频1. 谈谈对Spring的理解77.SpringBoot的自动配置原理81. Springboot 启动原理 （启动过程）86. Springboot默认的日志实现框架，如何切换其他日志框架？101.@Component 和@ComponentScan的联系102. @SpringBootApplication和@ComponentScan,扫描包的区别：103 @GetMapping和@RequestMapping的区别1.JDK JRE JVM区别与联系？(JIT即时编译器)2. ACID的实现方式3. Mybatis中#{}和￥{}的区别？4. 浅谈@RequestMapping @ResponseBody 和 @RequestBody 注解的用法与区别5. 如何自定义一个注解(@Annotation)6. 最近最久未使用（LRU算法）算法采用的数据结构7. SpringMVC和JSON的交互8. Spring中@Component与@Bean的区别9. HashMap和HashSet的区别9.1 什么是HashSet9.2 什么是HashMap 0. 参考视频 链接: 2021最新超详细Spring全家桶面试题100道完整版.
链接: 2022中文社区上面试趋势&#43;精选&#43;排行榜上所有热度最高的Java面试八股文.
1. 谈谈对Spring的理解 77.SpringBoot的自动配置原理 81. Springboot 启动原理 （启动过程） 第一步：创建 SpringApplication 对象。
第二步：运⾏ run() ⽅法。
以上两步是粗略介绍。
下述关键步骤：
“ApplicationContext是spring中比较高级的容器。和BeanFactory类似,它可以加载配置文件中定义的bean,并将所有bean集中在一起,
创建ApplicationContext容器将启动类作为配置类进行读取，将配置类注册为BeanDefinition
调用Refresh 加载IOC容器（其中具体包括，解析@import，加载所有的自动配置类，OnRefresh创建内置的servlet容器）
86. Springboot默认的日志实现框架，如何切换其他日志框架？ 默认是logback日志框架
切换log4j2 (springboot 中含有log4j2的对应的starter)
切换log4j (了解)
101.@Component 和@ComponentScan的联系 @Component 这个注解的作用是把我们写的bean注入到容器中,以供使用,
@ComponentScan注解的作用则是扫描包中的bean(比如:Spring不知道你定义了某个bean除非它知道从哪里可以找到这个bean,ComponentScan做的事情就是告诉Spring从哪里找到bean),由你来定义哪些包需要被扫描。一旦你指定了，Spring将会将在被指定的包及其下级包中寻找bean，这两个注解进行配合使用。
102. @SpringBootApplication和@ComponentScan,扫描包的区别： 如果你的其他包都在使用了@SpringBootApplication注解的main app所在的包及其下级包，则你什么都不用做，SpringBoot会自动帮你把其他包都扫描了如果你有一些bean所在的包，不在main app的包及其下级包，那么你需要手动加上@ComponentScan注解并指定那个bean所在的包。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/7b17937884186aa1e22f9d32594caee0/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-02-10T17:53:21+08:00" />
<meta property="article:modified_time" content="2022-02-10T17:53:21+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">2022最新超详细Spring全家桶面试题(待更新ing)</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p></p> 
<div class="toc"> 
 <h4>2022最新超详细Spring全家桶面试题完整版</h4> 
 <ul><li><a href="#0__1" rel="nofollow">0. 参考视频</a></li><li><a href="#1_Spring_4" rel="nofollow">1. 谈谈对Spring的理解</a></li><li><a href="#77SpringBoot_8" rel="nofollow">77.SpringBoot的自动配置原理</a></li><li><a href="#81_Springboot___10" rel="nofollow">81. Springboot 启动原理 （启动过程）</a></li><li><a href="#86_Springboot_22" rel="nofollow">86. Springboot默认的日志实现框架，如何切换其他日志框架？</a></li><li><a href="#101Component_ComponentScan_28" rel="nofollow">101.@Component 和@ComponentScan的联系</a></li><li><a href="#102_SpringBootApplicationComponentScan_31" rel="nofollow">102. @SpringBootApplication和@ComponentScan,扫描包的区别：</a></li><li><a href="#103_GetMappingRequestMapping_33" rel="nofollow">103 @GetMapping和@RequestMapping的区别</a></li><li><a href="#1JDK_JRE_JVMJIT_43" rel="nofollow">1.JDK JRE JVM区别与联系？(JIT即时编译器)</a></li><li><a href="#2_ACID_45" rel="nofollow">2. ACID的实现方式</a></li><li><a href="#3_Mybatis_51" rel="nofollow">3. Mybatis中#{}和￥{}的区别？</a></li><li><a href="#4_RequestMapping_ResponseBody__RequestBody__53" rel="nofollow">4. 浅谈@RequestMapping @ResponseBody 和 @RequestBody 注解的用法与区别</a></li><li><a href="#5_Annotation_56" rel="nofollow">5. 如何自定义一个注解(@Annotation)</a></li><li><a href="#6_LRU_60" rel="nofollow">6. 最近最久未使用（LRU算法）算法采用的数据结构</a></li><li><a href="#7_SpringMVCJSON_65" rel="nofollow">7. SpringMVC和JSON的交互</a></li><li><a href="#8_SpringComponentBean_71" rel="nofollow">8. Spring中@Component与@Bean的区别</a></li><li><a href="#9_HashMapHashSet_77" rel="nofollow">9. HashMap和HashSet的区别</a></li><li><ul><li><a href="#91_HashSet_81" rel="nofollow">9.1 什么是HashSet</a></li><li><a href="#92_HashMap_84" rel="nofollow">9.2 什么是HashMap</a></li></ul> 
 </li></ul> 
</div> 
<p></p> 
<h2><a id="0__1"></a>0. 参考视频</h2> 
<p>链接: <a href="https://www.bilibili.com/video/BV17L411t7Fw?p=79" rel="nofollow">2021最新超详细Spring全家桶面试题100道完整版</a>.<br> 链接: <a href="https://www.bilibili.com/video/BV1Wq4y1C7ro?spm_id_from=333.851.b_7265636f6d6d656e64.1" rel="nofollow">2022中文社区上面试趋势+精选+排行榜上所有热度最高的Java面试八股文</a>.</p> 
<h2><a id="1_Spring_4"></a>1. 谈谈对Spring的理解</h2> 
<p><img src="https://images2.imgbox.com/80/77/4JvksuEB_o.png" alt="在这里插入图片描述"></p> 
<h2><a id="77SpringBoot_8"></a>77.SpringBoot的自动配置原理</h2> 
<p><img src="https://images2.imgbox.com/22/2b/U0Kyg62K_o.png" alt="在这里插入图片描述"></p> 
<h2><a id="81_Springboot___10"></a>81. Springboot 启动原理 （启动过程）</h2> 
<p>第一步：创建 SpringApplication 对象。<br> 第二步：运⾏ run() ⽅法。<br> 以上两步是粗略介绍。<br> 下述关键步骤：<br> <img src="https://images2.imgbox.com/d1/80/S1gUZSf2_o.png" alt="在这里插入图片描述"><br> “ApplicationContext是spring中比较高级的容器。和BeanFactory类似,它可以加载配置文件中定义的bean,并将所有bean集中在一起,</p> 
<ol><li>创建ApplicationContext容器</li><li>将启动类作为配置类进行读取，将配置类注册为BeanDefinition<br> <img src="https://images2.imgbox.com/b0/f2/WOlnKMK9_o.png" alt="在这里插入图片描述"></li><li>调用Refresh 加载IOC容器（其中具体包括，解析@import，加载所有的自动配置类，OnRefresh创建内置的servlet容器）<br> <img src="https://images2.imgbox.com/34/fc/YE3ej5sp_o.png" alt="在这里插入图片描述"></li></ol> 
<h2><a id="86_Springboot_22"></a>86. Springboot默认的日志实现框架，如何切换其他日志框架？</h2> 
<p>默认是logback日志框架<br> 切换log4j2 (springboot 中含有log4j2的对应的starter)<br> <img src="https://images2.imgbox.com/9c/02/7zMC2Oef_o.png" alt="在这里插入图片描述"><br> 切换log4j (了解)<br> <img src="https://images2.imgbox.com/d3/be/hzpuvpuG_o.png" alt="在这里插入图片描述"></p> 
<h2><a id="101Component_ComponentScan_28"></a>101.@Component 和@ComponentScan的联系</h2> 
<p>@Component 这个注解的作用是把我们写的bean注入到容器中,以供使用,<br> @ComponentScan注解的作用则是扫描包中的bean(比如:Spring不知道你定义了某个bean除非它知道从哪里可以找到这个bean,ComponentScan做的事情就是告诉Spring从哪里找到bean),由你来定义哪些包需要被扫描。一旦你指定了，Spring将会将在被指定的包及其下级包中寻找bean，这两个注解进行配合使用。</p> 
<h2><a id="102_SpringBootApplicationComponentScan_31"></a>102. @SpringBootApplication和@ComponentScan,扫描包的区别：</h2> 
<p>如果你的其他包都在使用了@SpringBootApplication注解的main app所在的包及其下级包，则你什么都不用做，SpringBoot会自动帮你把其他包都扫描了如果你有一些bean所在的包，不在main app的包及其下级包，那么你需要手动加上@ComponentScan注解并指定那个bean所在的包。</p> 
<h2><a id="103_GetMappingRequestMapping_33"></a>103 @GetMapping和@RequestMapping的区别</h2> 
<ol><li>@GetMapping用于将HTTP get请求映射到特定处理程序的方法注解<br> 具体来说，@GetMapping是一个组合注解，是@RequestMapping(method = RequestMethod.GET)的缩写。</li><li>RequestMapping 具有类属性的，可以进行 GET,POST,PUT 或者其它的注释中具有的请求方法。<br> GetMapping 是 GET 请求方法中的一个特例。它只是 ResquestMapping 的一个延伸，目的是为了提高清晰度。</li></ol> 
<p>链接: <a href="https://www.bilibili.com/video/BV1cf4y1G7dC/?spm_id_from=333.788.recommend_more_video.0" rel="nofollow">参考视频</a>.</p> 
<h2><a id="1JDK_JRE_JVMJIT_43"></a>1.JDK JRE JVM区别与联系？(JIT即时编译器)</h2> 
<p><img src="https://images2.imgbox.com/32/30/qWwNAoWZ_o.png" alt="在这里插入图片描述"></p> 
<h2><a id="2_ACID_45"></a>2. ACID的实现方式</h2> 
<p>原子性( A )——&gt;undo log实现；<br> 隔离性( I )——&gt;MVC实现；<br> 持久性( D )——&gt;redo log实现<br> 一致性( C )——&gt;依靠以上特性三个实现</p> 
<h2><a id="3_Mybatis_51"></a>3. Mybatis中#{}和￥{}的区别？</h2> 
<p><img src="https://images2.imgbox.com/c8/e9/sAwB9hlU_o.png" alt="在这里插入图片描述"></p> 
<h2><a id="4_RequestMapping_ResponseBody__RequestBody__53"></a>4. 浅谈@RequestMapping @ResponseBody 和 @RequestBody 注解的用法与区别</h2> 
<p>链接: <a href="https://blog.csdn.net/ff906317011/article/details/78552426/">参考链接</a>.</p> 
<h2><a id="5_Annotation_56"></a>5. 如何自定义一个注解(@Annotation)</h2> 
<p>链接: <a href="https://www.cnblogs.com/wenhulu/p/7554034.html" rel="nofollow">参考链接</a>.<br> <strong>自定义校验注解</strong><br> 链接: <a href="https://blog.csdn.net/pzjtian/article/details/107678197/">自定义校验注解</a>.</p> 
<h2><a id="6_LRU_60"></a>6. 最近最久未使用（LRU算法）算法采用的数据结构</h2> 
<p>链接: <a href="https://blog.csdn.net/justloveyou_/article/details/71713781">彻头彻尾理解 LinkedHashMap</a>.<br> HashMap和双向链表合二为一即是LinkedHashMap。所谓LinkedHashMap，其落脚点在HashMap，因此更准确地说，它是一个将所有Entry节点链入一个双向链表的HashMap。由于LinkedHashMap是HashMap的子类，所以LinkedHashMap自然会拥有HashMap的所有特性。比如，LinkedHashMap的元素存取过程基本与HashMap基本类似，只是在细节实现上稍有不同。当然，这是由LinkedHashMap本身的特性所决定的，因为它额外维护了一个双向链表用于保持迭代顺序。此外，LinkedHashMap可以很好的支持LRU算法。<br> <img src="https://images2.imgbox.com/57/9f/y7XqWcbc_o.png" alt="在这里插入图片描述"><br> <img src="https://images2.imgbox.com/7a/a8/948vo36s_o.png" alt="在这里插入图片描述"></p> 
<h2><a id="7_SpringMVCJSON_65"></a>7. SpringMVC和JSON的交互</h2> 
<p><strong>springMVC中和json的交互：主要分为两点：</strong><br> 一是传递过来的是json字符串，springMVC会先进行解析，<br> 二是传递过来的是key:value那么springMVC可以不进行解析，<br> 这里的解析指的是json和java对象之间的转换<br> <img src="https://images2.imgbox.com/af/4f/l8dSNCX6_o.png" alt="在这里插入图片描述"></p> 
<h2><a id="8_SpringComponentBean_71"></a>8. Spring中@Component与@Bean的区别</h2> 
<p>@Component和@Bean的目的是一样的，都是注册bean到Spring容器中。<br> <strong>@Component VS @Bean</strong><br> @Component 和 它的子类型（@Controller, @Service and @Repository）注释在类上。告诉Spring，我是一个bean，通过类路径扫描自动检测并注入到Spring容器中。<br> @Bean不能注释在类上，只能用于在配置类中显式声明单个bean。意思就是，我要获取这个bean的时候，spring要按照这种方式去获取这个bean。默认情况下@Bean注释的方法名作为对象的名字，也可以用name属性定义对象的名字。<br> 链接: <a href="https://www.cnblogs.com/zoe-java/p/11542484.html" rel="nofollow">Spring中@Component与@Bean的区别</a>.</p> 
<h2><a id="9_HashMapHashSet_77"></a>9. HashMap和HashSet的区别</h2> 
<p>HashMap和HashSet的区别是Java面试中最常被问到的问题。如果没有涉及到Collection框架以及多线程的面试，可以说是不完整。而Collection框架的问题不涉及到HashSet和HashMap，也可以说是不完整。HashMap和HashSet都是collection框架的一部分，它们让我们能够使用对象的集合。collection框架有自己的接口和实现，主要分为Set接口，List接口和Queue接口。它们有各自的特点，Set的集合里不允许对象有重复的值，List允许有重复，它对集合中的对象进行索引，Queue的工作原理是FCFS算法(First Come, First Serve)。</p> 
<p>首先让我们来看看什么是HashMap和HashSet，然后再来比较它们之间的分别。</p> 
<h3><a id="91_HashSet_81"></a>9.1 什么是HashSet</h3> 
<p>HashSet实现了Set接口，它不允许集合中有重复的值，当我们提到HashSet时，第一件事情就是在将对象存储在HashSet之前，要先确保对象重写equals()和hashCode()方法，这样才能比较对象的值是否相等，以确保set中没有储存相等的对象。如果我们没有重写这两个方法，将会使用这个方法的默认实现。<br> public boolean add(Object o)方法用来在Set中添加元素，当元素值重复时则会立即返回false，如果成功添加的话会返回true。</p> 
<h3><a id="92_HashMap_84"></a>9.2 什么是HashMap</h3> 
<p>HashMap实现了Map接口，Map接口对键值对进行映射。Map中不允许重复的键。Map接口有两个基本的实现，HashMap和TreeMap。TreeMap保存了对象的排列次序，而HashMap则不能。HashMap允许键和值为null。HashMap是非synchronized的，但collection框架提供方法能保证HashMap synchronized，这样多个线程同时访问HashMap时，能保证只有一个线程更改Map.</p> 
<p>public Object put(Object Key,Object value)方法用来将元素添加到map中。<br> <img src="https://images2.imgbox.com/b1/4c/zfZJ3fhT_o.png" alt="在这里插入图片描述"></p> 
<p>链接: <a href="https://www.cnblogs.com/zhuyeshen/p/10981194.html" rel="nofollow">HashMap和HashSet的区别 </a>.</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/aa17113a18aec17bc954b6f667cf9c26/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">微信小程序中换行空格（多个空格）</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/6969b29a2cee6c1a55b9dd0e71794f8a/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">libtorch问题：Unsupported value kind: Tensor</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>