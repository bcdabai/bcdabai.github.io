<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>【计算机网络】内容整理 - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="【计算机网络】内容整理" />
<meta property="og:description" content="概述 分组交换 分组交换则采用存储转发（整个包必须到达路由器，然后才能在下一个链路上传输)技术。
在发送端，先把较长的报文划分成较短的、固定长度的数据段。
电路交换 在端系统间通信会话期间，预留了端系统间沿路径通信所需要的资源(缓存、链路传输速率)
建立连接：建立一条专用的物理通路，以保证双方通话时所需的通信资源在通信时不会被其他用户占用；通信：主叫和被叫双方就能互相通电话；释放连接：释放刚才使用的这条专用的物理通路（释放刚才占用的所有通信资源）。 时延计算 吞吐量 应用层 体系结构 C/S 客户(client)和服务器(server)都是指通信中所涉及的两个应用进程。
客户-服务器方式所描述的是进程之间服务和被服务的关系。
客户是服务的请求方，服务器是服务的提供方。
服务请求方和服务提供方都要使用网络核心部分所提供的服务。
P2P 没有永远在线的服务器
任意终端系统直接通信
对等方向其他对等方请求服务，向其他对等方提供服务
对等体间歇连接并更改IP地址
Socket 进程间通信利用套接字(Socket)发送和接受消息来实现
URL 统一资源定位器
&lt;协议&gt;：//&lt;主机&gt;：&lt;端口&gt;/&lt;路径&gt;
HTTP 超文本传输协议
基于web的应用层协议
C/S结构
client-----browser:请求接受和展示web对象server-----Web server:响应客户的请求，发送对象 连接 非持续连接
每个TCP连接最多发送一个对象然后关闭连接多个对象需要多个TCP连接HTTP1.0版本使用非持续连接
缺点：
每个对象需要两个RTT
每个TCP连接有开销
浏览器经常打开多个并行TCP连接来获取网页所需的对象 持续连接
客户端和服务器之间的单个TCP连接可以传输多个对象HTTP1.1版本使用持续连接 非流水线 客户在收到前一个响应后才能发出
下一个请求。这比非持续连接的两倍RTT的开销节省了建立TCP连接所需的一个RTT时间。服务器在发送完一个对象后，其TCP连接就处于空闲状态，浪费了服务器资源。 流水线 服务器在发送响应后保持连
接打开同一客户机/服务器之间的后续HTTP请求和响应报文通过已打开的TCP连接发送客户机在遇到被引用对象时立即发送请求对于所有被引用的对象，只有一个RTT 响应时间 RTT(往返时延)：从客户机发送一个很
小的包到服务器并返回所经历的时间
HTTP响应时间：
发起、建立TCP链接需要一个RTT发送HTTP请求消息到HTTP相应消息的前几个字节到达需要一个RTT文件发送时延
非持续HTTP响应时间=2RTT&#43;文件发送时延
请求报文 请求方法：
响应报文 首部 通用首部 Cache-Control:通过指定指令来实现缓存机制。
max-age=&lt;\seconds&gt;设置缓存存储的最大周期，超过这个时间缓存被认为过期指定no-cache或max-age=0表示客户端可以缓存资源，每次使用缓存资源前都必须重新验证其有效性。
Connection:决定当前的事务完成后，是否会关闭网络连接 “keep-alive”“closed”
Keep-Alive:允许消息发送者暗示连接的状态，还可以用来设置超时时长和最大请求数
Date:表明创建HTTP报文的日期和时间。其中时间GMT代表格林威治标准时间 请求头 Host:指明了请求将要发送到的服务器主机名和端口号（可选）
User-Agent:指明用户代理，即浏览器的类型
Accept:列举用户代理希望接收的媒体资源的MIME类型
Accept-Language：用来提示用户期望获得的文档自然语言的优先顺序" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/b642b7244b90321d11621b7009dcdd58/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2024-01-12T15:13:43+08:00" />
<meta property="article:modified_time" content="2024-01-12T15:13:43+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">【计算机网络】内容整理</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <h2><a id="_0"></a>概述</h2> 
<h3><a id="_1"></a>分组交换</h3> 
<p>分组交换则采用存储转发（整个包必须到达路由器，然后才能在下一个链路上传输)技术。</p> 
<p>在发送端，先把较长的报文划分成较短的、固定长度的数据段。</p> 
<h3><a id="_5"></a>电路交换</h3> 
<p>在端系统间通信会话期间，预留了端系统间沿路径通信所需要的资源(缓存、链路传输速率)</p> 
<ol><li>建立连接：建立一条专用的物理通路，以保证双方通话时所需的通信资源在通信时不会被其他用户占用；</li><li>通信：主叫和被叫双方就能互相通电话；</li><li>释放连接：释放刚才使用的这条专用的物理通路（释放刚才占用的所有通信资源）。</li></ol> 
<h3><a id="_11"></a>时延计算</h3> 
<p><img src="https://images2.imgbox.com/49/29/0qCPqGv8_o.png" alt="350"><img src="https://images2.imgbox.com/47/07/jIZPP69C_o.png" alt="350"><br> <img src="https://images2.imgbox.com/54/91/2oCcIDP7_o.png" alt="image.png"></p> 
<h3><a id="_14"></a>吞吐量</h3> 
<p><img src="https://images2.imgbox.com/b3/e2/8sgymQsS_o.png" alt="image.png"></p> 
<h2><a id="_16"></a>应用层</h2> 
<h3><a id="_17"></a>体系结构</h3> 
<h4><a id="CS_18"></a>C/S</h4> 
<p>客户(client)和服务器(server)都是指通信中所涉及的两个应用进程。</p> 
<p>客户-服务器方式所描述的是进程之间服务和被服务的关系。</p> 
<p>客户是服务的请求方，服务器是服务的提供方。</p> 
<p>服务请求方和服务提供方都要使用网络核心部分所提供的服务。</p> 
<h4><a id="P2P_26"></a>P2P</h4> 
<p>没有永远在线的服务器<br> 任意终端系统直接通信<br> 对等方向其他对等方请求服务，向其他对等方提供服务<br> 对等体间歇连接并更改IP地址</p> 
<h3><a id="Socket_32"></a>Socket</h3> 
<p><img src="https://images2.imgbox.com/0d/bc/z3McS7ti_o.png" alt="image.png"><br> 进程间通信利用套接字(Socket)发送和接受消息来实现</p> 
<h3><a id="URL_36"></a>URL</h3> 
<p>统一资源定位器<br> &lt;协议&gt;：//&lt;主机&gt;：&lt;端口&gt;/&lt;路径&gt;</p> 
<h3><a id="HTTP_40"></a>HTTP</h3> 
<p>超文本传输协议</p> 
<p>基于web的应用层协议</p> 
<p>C/S结构</p> 
<ul><li>client-----browser:请求接受和展示web对象</li><li>server-----Web server:响应客户的请求，发送对象</li></ul> 
<h4><a id="_49"></a>连接</h4> 
<ul><li> <p>非持续连接</p> 
  <ul><li>每个TCP连接最多发送一个对象然后关闭连接</li><li>多个对象需要多个TCP连接</li><li>HTTP1.0版本使用非持续连接<br> 缺点：<br> 每个对象需要两个RTT<br> 每个TCP连接有开销<br> 浏览器经常打开多个并行TCP连接来获取网页所需的对象</li></ul> </li><li> <p>持续连接</p> 
  <ul><li>客户端和服务器之间的单个TCP连接可以传输多个对象</li><li>HTTP1.1版本使用持续连接</li></ul> </li></ul> 
<ol><li>非流水线</li></ol> 
<ul><li>客户在收到前一个响应后才能发出<br> 下一个请求。</li><li>这比非持续连接的两倍RTT的开销节省了建立TCP连接所需的一个RTT时间。</li><li>服务器在发送完一个对象后，其TCP连接就处于空闲状态，浪费了服务器资源。</li></ul> 
<ol start="2"><li>流水线</li></ol> 
<ul><li>服务器在发送响应后保持连<br> 接打开</li><li>同一客户机/服务器之间的后续HTTP请求和响应报文通过已打开的TCP连接发送</li><li>客户机在遇到被引用对象时立即发送请求</li><li>对于所有被引用的对象，只有一个RTT</li></ul> 
<h4><a id="_73"></a>响应时间</h4> 
<p>RTT(往返时延)：从客户机发送一个很<br> 小的包到服务器并返回所经历的时间<br> HTTP响应时间：</p> 
<ul><li>发起、建立TCP链接需要一个RTT</li><li>发送HTTP请求消息到HTTP相应消息的前几个字节到达需要一个RTT</li><li>文件发送时延<br> 非持续HTTP响应时间=2RTT+文件发送时延<br> <img src="https://images2.imgbox.com/c1/65/O9msy6vW_o.png" alt="image.png"></li></ul> 
<h4><a id="_82"></a>请求报文</h4> 
<p><img src="https://images2.imgbox.com/3b/ad/sJrDCqdy_o.png" alt="image.png"><br> <img src="https://images2.imgbox.com/b8/36/Hwl7Wo1J_o.png" alt="image.png"><br> 请求方法：<br> <img src="https://images2.imgbox.com/bd/36/UXAW7Jyx_o.png" alt="image.png"></p> 
<h4><a id="_87"></a>响应报文</h4> 
<p><img src="https://images2.imgbox.com/3c/83/qf6rHprF_o.png" alt="image.png"><br> <img src="https://images2.imgbox.com/b6/84/vvWjZHnA_o.png" alt="image.png"></p> 
<h4><a id="_90"></a>首部</h4> 
<h5><a id="_91"></a>通用首部</h5> 
<p><strong>Cache-Control</strong>:通过指定指令来实现缓存机制。</p> 
<ul><li>max-age=&lt;\seconds&gt;设置缓存存储的最大周期，超过这个时间缓存被认为过期</li><li>指定no-cache或max-age=0表示客户端可以缓存资源，每次使用缓存资源前都必须重新验证其有效性。<br> <strong>Connection</strong>:决定当前的事务完成后，是否会关闭网络连接 “keep-alive”“closed”<br> <strong>Keep-Alive</strong>:允许消息发送者暗示连接的状态，还可以用来设置超时时长和最大请求数<br> <strong>Date</strong>:表明创建HTTP报文的日期和时间。其中时间GMT代表格林威治标准时间</li></ul> 
<h5><a id="_98"></a>请求头</h5> 
<p><strong>Host</strong>:指明了请求将要发送到的服务器主机名和端口号（可选）<br> <strong>User-Agent</strong>:指明用户代理，即浏览器的类型<br> <strong>Accept</strong>:列举用户代理希望接收的媒体资源的MIME类型<br> <strong>Accept-Language</strong>：用来提示用户期望获得的文档自然语言的优先顺序<br> <strong>Accept-Encoding</strong>:明确说明了（接收端）可以接受的内容编码形式（所支持的压缩算法)<br> <strong>Accept-Charset</strong>:用于告知服务器该客户代理可以理解何种形式的字符编码（如今UTF-8编码已经得到了广泛的支持，成为首选的字符编码类型。为了通过减少基于配置信息的信息熵来更好地保护隐私信息，大多数浏览器会将Accept-Charset首部移除：Internet Explorer8、Safari5、0pera11以及Firefox10都已经不再发送该首部。)</p> 
<h5><a id="_105"></a>响应头</h5> 
<p><strong>Server</strong>:包含了处理请求的源头服务器所用到的软件相关信息<br> <strong>Last-Modified</strong>：包含源头服务器认定的资源做出修改的日期及时间<br> <strong>ETag</strong>：资源的特定版本的标识符。这可以让缓存更高效，并节省带宽，因为如果内<br> 容没有改变，Wb服务器不需要发送完整的响应。如果给定URL中的资源更改，则一<br> 定要生成新的Etag值<br> <strong>Accept–Ranges</strong>:标识自身支持范围请求，字段的具体值用于定义范围请求的单位<br> <strong>Expires</strong>:响应头包含日期/时间，即在此时候之后，响应过期。如果在Cache<br> Controll响应头设置了"max-age”或者"s-max-age”指令，那么Expires头会被<br> 忽略。</p> 
<h5><a id="_115"></a>实体头</h5> 
<p><strong>Content-Type</strong>:用于指示资源的MIME类型（媒体类型）<br> <strong>Content-Length</strong>:用来指明发送给接收方的消息主体的大小，十进制数字表示的八位字节的数目<br> <strong>Content-Language</strong>：用来说明访问者希望采用的语言或语言组合，这个首部还可以用来描述不同媒体类型的文件，而不单单局限于文本型文档。<br> <strong>Content-Encoding</strong>:用于对特定媒体类型的数据进行压缩。当这个首部出现的时候，它的值表示消息主体进行了何种方式的内容编码转换。这个消息首部用来告知客户端应该怎样解码才能获取在Content-Type中标示<br> 的媒体类型内容。</p> 
<h4><a id="_121"></a>响应状态码</h4> 
<p>1xx表示通知信息的，如请求收到了或正在进行处理。<br> 2xx表示成功，如接受或知道了。<br> 3xx表示重定向，表示要完成请求还必须采取进一步的行动。<br> 301永久移动，域名重定向<br> 302临时性重定向，资源被分配到新的URI,希望用户本次可以使用新的URI访问<br> 303请求对应的资源存在另一个URI,应使用GET方法重定向获取资源。<br> 304找到资源了，但是不符合条件，一般用于缓存，代表缓存资源不符合需求<br> 307临时性重定向，与302有着相同的含义，不会从P0ST方法换成GET方法<br> 客户端响应：<br> 4xx表示客户的差错，如请求中有错误的语法或不能完成<br> 400 Bad Request<br> 404 Not Found<br> 服务器端响应：<br> 5xx表示服务器的差错，如服务器失效无法完成请求<br> 505 HTTP Version Not Supported</p> 
<h4><a id="Cookie_137"></a>Cookie</h4> 
<ul><li>Cookie实际上是一小段的文本信息。</li><li>客户端请求服务器，如果服务器需要记录该用户状态，就使用responsel向客户端浏览器颁发一个Cookie</li><li>客户端浏览器会把Cookie保存起来。</li><li>当浏览器再请求该网站时，浏览器把请求的网址连同该Cookie一同提交给服务器。</li><li>服务器检查该Cookie,以此来辨认用户状态。</li><li>服务器还可以根据需要修改Cookie的内容</li></ul> 
<h4><a id="Session_144"></a>Session</h4> 
<ul><li>Session是另一种记录客户状态的机制，不同的是Cookie保存在客户端浏览器中，而Session保存在服务器上。客户端浏览器访问服务器的时候，服务器把客户端信息以某种形式（内存中、redis、Memcached)记录在服务器上。这就是Session.客户端浏览器再次访问时只需要从该Session中查找该客户的状态就可以了。</li><li>Session基于cookie的，服务器会把一个sessionid以cookie形式种植给浏览器。以后客户端在访问服务端时候，http请求会带着sessionid,服务器会先检查这个客户端的请求里是否已包含了一个session标识(sessionid)。如果已包含这个 sessionId,则说明以前已经为此客户端创建过session,服务器就按照sessionId把这个session检索出来使用。</li></ul> 
<h4><a id="Web_147"></a>Web缓存</h4> 
<p><img src="https://images2.imgbox.com/ac/3d/N0Rvl7za_o.png" alt="image.png"><br> <strong>条件GET</strong><br> <img src="https://images2.imgbox.com/69/4a/xLZL0MrL_o.png" alt="image.png"></p> 
<h4><a id="HTTP2_151"></a>HTTP2</h4> 
<p>HTTP1.1发送一个Web页面的所有对象存在队首阻塞。HTTP2把每个报文分成小帧交错传输，解决阻塞。</p> 
<h3><a id="_153"></a>邮件服务</h3> 
<p><img src="https://images2.imgbox.com/0f/ca/S109KQYm_o.png" alt="image.png"></p> 
<h4><a id="SMTP_155"></a>SMTP</h4> 
<p>基于TCP在客户和服务器之间传递email,端口号为：25<br> 直接传输：发送服务器到接收服务器<br> 传输的三个阶段</p> 
<ul><li>握手(greeting)</li><li>传输消息</li><li>关闭<br> 命令/响应交互式(HTTP)</li><li>命令：ASCII文本</li><li>响应：状态码和语句<br> email消息只包含7位的<strong>ASCII</strong>码</li></ul> 
<h4><a id="_166"></a>邮件访问协议</h4> 
<p><img src="https://images2.imgbox.com/b8/e3/fUax4k8I_o.png" alt="image.png"></p> 
<h3><a id="DNS_168"></a>DNS</h3> 
<p>基于UDP<br> <img src="https://images2.imgbox.com/49/f6/MY2AJmfK_o.png" alt="image.png"></p> 
<h4><a id="_171"></a>迭代查询</h4> 
<p>被查询服务器返回域名解析服务器的名字<br> <img src="https://images2.imgbox.com/26/ec/DGve7bfO_o.png" alt="image.png"></p> 
<h4><a id="_175"></a>递归查询</h4> 
<p>将域名解析的任务交给所联系的服务器<br> <img src="https://images2.imgbox.com/00/a0/Dr9ecSmf_o.png" alt="image.png"></p> 
<h3><a id="P2P_178"></a>P2P</h3> 
<ul><li>没有服务器</li><li>任意终端系统直接通信</li><li>对等点间断续连接并更改IP地址</li><li>在P2P工作方式下，所有的音频/视频文件都是在普通的互联网用户之间传输</li></ul> 
<h4><a id="Napster_183"></a>Napster</h4> 
<p>有一个集中式目录服务器，用户X询问Napster谁有资源m，服务器回应a,b,c。X再随机选一个请求。</p> 
<h4><a id="_186"></a>全分布式</h4> 
<p>洪泛法在用户之间查询</p> 
<h4><a id="CDN_189"></a>CDN</h4> 
<p>CDN的基本原理是依靠放置在各地的<strong>缓存服务器</strong>，通过全局调度，内容分发等功能模块，将用户需要的那部分内容部署到贴近用户的地点，将原本低效、不可靠的IP网络转变成高效、可靠的智能网络，满足用户对内容访问质量的更高要求，改善互联网网络拥塞问题，提高用户访问网站的响应速度。</p> 
<h2><a id="_192"></a>传输层</h2> 
<p>提供应用进程之间的通信机制</p> 
<ul><li>位于网络层之上</li><li>依赖于网络层服务</li><li>对网络层服务进行增强<br> <strong>多路复用</strong>：在源主机从不同套接字中收集数据块，并为每个数据块封装上首部信息，从而生成报文段，然后将报文段传到网络层。（发送过程）<br> <strong>多路分用</strong>：检查传输层报文段，根据<strong>目的端口号</strong>标识出接收套接字，交付给正确的套接字。（接收过程）</li></ul> 
<h3><a id="UDP_199"></a>UDP</h3> 
<ul><li>无需建立连接（减少延迟)</li><li>实现简单：无需维护连接状态</li><li>头部开销小</li><li>没有拥塞控制：应用可以更好地控制发送时间和速率</li></ul> 
<h4><a id="_204"></a>报文段结构</h4> 
<p><strong>报文头8字节</strong><br> <img src="https://images2.imgbox.com/7c/c8/qfR6U6pp_o.png" alt="image.png"></p> 
<h4><a id="_207"></a>检验和</h4> 
<p>发送方UDP对报文段所有16比特字的和求反，放在检验和字段。求和时如果最高位有进位就进到末位。</p> 
<h3><a id="_209"></a>可靠数据传输</h3> 
<p>参考https://blog.csdn.net/qq_53144843/article/details/120896557<br> rdt_send():被上层应用调用，将数据交给rdt以发送给接收方<br> udt_send():被rdt调用，在不可靠的信道上发送数据给接收方<br> deliver_data():被rdt调用，向上层应用交付数据<br> rdt_rcv():数据包到达接收方时被调用</p> 
<h4><a id="rdt10_215"></a>rdt1.0</h4> 
<p>假设以下理想条件：</p> 
<ol><li>不会发生错误</li><li>不会丢弃分组<br> 有限状态机FSM描述：<br> <img src="https://images2.imgbox.com/74/02/jmhhtmWu_o.png" alt="image.png"><br> 发送方：一个状态，等待上层调用，若上层调用，则产生rdt_send，创建packet活动，调用信道上的udt_send()，发送分组，可确定百分百发送，然后回到之前状态，继续等待调用</li></ol> 
<p>接收方：一个状态，等待下层调用，当传入一个分组，rdt_rcv接收，extract提取，交付给上层deliver_data</p> 
<h4><a id="rdt20_224"></a>rdt2.0</h4> 
<p>底层信道可能传输错误比特<br> <strong>自动重传请求协议ARQ</strong>：使用ACK和NAK通知发送方接收状态。</p> 
<ul><li>差错检测</li><li>接收方反馈ACK/NAK</li><li>重传<br> 发送方在等待ACK/NAK时无法处理上层新的数据，所以这样的协议也叫<strong>停等协议</strong><br> <img src="https://images2.imgbox.com/46/f3/9LTELTXZ_o.png" alt="400"><br> <img src="https://images2.imgbox.com/f5/e5/zQMNWkS5_o.png" alt="image.png"><br> 发送方：若上层调用，则产生rdt_send，创建packet活动并加入校验和，调用信道上的udt_send()，发送分组。同时进入等待ACK/NAK状态，若为NAK，则重传分组，继续等待ACK/NAK，一直处于该状态，直到传回ACK才进入等待调用状态</li></ul> 
<p>接收方：当传入一个分组，rdt_rcv接收并且进行判断，如果没有错误extract提取，交付给上层deliver_data并返回ACK，如果发生错误，则直接返回NAK，并处于等待接收状态</p> 
<p>时序图：<br> <img src="https://images2.imgbox.com/d2/06/9MmnMDJU_o.png" alt="image.png"></p> 
<h4><a id="rdt21_239"></a>rdt2.1</h4> 
<p><strong>如果ACK/NAK损坏，发送方重新传输当前pkt</strong><br> 发送方给每个pkt增加序列号<br> 接收者丢弃重复的pkt<br> <strong>发送方：</strong><br> <img src="https://images2.imgbox.com/20/97/VZCWgp7v_o.png" alt="image.png"><br> <strong>接收方：</strong><br> <img src="https://images2.imgbox.com/48/75/17xfIPCi_o.png" alt="image.png"><br> 发送方：等待上层调用，序列号为0，若上层调用，则产生rdt_send，创建packet活动(此处加入序列号)并加入校验盒，调用信道上的udt_send()，发送分组，同时进入等待ACK/NAK状态，若为NAK，则重传分组，继续等待ACK/NAK，一直处于该状态，若传回ACK，则进入等待调用状态，并改变序列号为1<br> 接收方：当传入一个分组，rdt_rcv接收并且进行判断，如果分组没有错误，并且期望收到分组序列号与当前序列号相同，则extract提取，交付给上层deliver_data并返回ACK；如果发生错误，则直接返回NAK，并处于等待接收状态；若接收分组没错，序列号不匹配，则必须发一个ACK，表示正确接收</p> 
<p>时序图：<br> <img src="https://images2.imgbox.com/18/1f/MNi01Bdi_o.png" alt="image.png"></p> 
<h4><a id="rdt22_252"></a>rdt2.2</h4> 
<p>不需要NAK<br> <strong>接收方发送最后一次正确接收到的分组的ACK来代替NAK</strong></p> 
<ul><li>接收方发出的ACK消息中，必须明确包含被确认的分组序列号</li><li>发送方的收到重复ACK会采取与NAK相同的操作：重新传输当前分组<br> <img src="https://images2.imgbox.com/3b/d1/7mmrGqDZ_o.png" alt="image.png"></li></ul> 
<h4><a id="rdt30_258"></a>rdt3.0</h4> 
<p>信道也可能丢失分组，增加了<strong>超时处理</strong><br> 发送方等待ACK合理时间，如果到时未收到ACK,则重新传输；<br> 如果分组或ACK仅仅延迟而没有丢失：</p> 
<ul><li>重传则会产生重复，利用序列号可以解决</li><li>接收方需在ACK中显式告知所确认的分组<br> 发送方：<br> <img src="https://images2.imgbox.com/7d/76/z8orsAwp_o.png" alt="image.png"><br> 接收方没变。</li></ul> 
<h3><a id="_267"></a>流水线协议</h3> 
<p>发送方在收到ACK之前可以连续发送多个分组，从而提高利用率。</p> 
<ul><li>需要更大序号空间</li><li>发送方和/或接收方需要更大的存储空间以缓存分组</li></ul> 
<h4><a id="GBN_271"></a>GBN</h4> 
<ul><li>发送方在管道中最多可以有N个未确认的数据包</li><li>接收方只发送累积确认</li><li>如果有间隔就不会确认数据包</li><li>发送方有未确认数据报的计时器</li><li>当计时器超时，重传所有未确认的数据包</li></ul> 
<h5><a id="_277"></a>发送方</h5> 
<p><img src="https://images2.imgbox.com/03/f1/2aEae6Xo_o.png" alt="image.png"><br> <img src="https://images2.imgbox.com/60/df/qCnDC5kL_o.png" alt="image.png"></p> 
<h5><a id="_281"></a>接收方</h5> 
<p><img src="https://images2.imgbox.com/fb/f8/j2GvKfPp_o.png" alt="image.png"><br> <img src="https://images2.imgbox.com/9c/56/PaC1XGNq_o.png" alt="image.png"><br> <img src="https://images2.imgbox.com/ef/a7/iSsjWsyP_o.png" alt="image.png"></p> 
<h4><a id="SR_285"></a>SR</h4> 
<p>接收方单独确认所有正确收到的分组</p> 
<ul><li>设置缓存机制，缓存乱序到达的分组，最终交给上层<br> 发送方只重传那些没收到ACK的分组</li><li>为每个分组设置定时器<br> 发送方窗口</li><li>N个连续的序号</li><li>限制已发送且未被确认的分组<br> <img src="https://images2.imgbox.com/77/82/nEUD2C4t_o.png" alt="image.png"><br> <img src="https://images2.imgbox.com/de/7b/TUr1qOTn_o.png" alt="image.png"></li></ul> 
<h3><a id="TCP_296"></a>TCP</h3> 
<h4><a id="_297"></a>报文结构</h4> 
<p><img src="https://images2.imgbox.com/28/4a/SLOWyYve_o.png" alt="image.png"><br> 序列号:</p> 
<ul><li>TCP报文段中第一个字节的编号</li><li>建立TCP连接时，双方随机选择序号<br> ACKs:</li><li><strong>期望收到的下一个字节的序列号</strong></li><li><strong>累计确认</strong>，该序号之前的所有字节都已正确接收</li></ul> 
<h4><a id="_305"></a>重传</h4> 
<p><strong>累积确认</strong><br> <strong>快速重传</strong>：如果sendert收到对同一数据的3个ACK,则假定该数据之后的段已经丢失，在定时器超时之前即进行重传</p> 
<h4><a id="_309"></a>流量控制</h4> 
<p>接收方通过在接收方到发送方的TCP报头中包含rwnd值来“通告”空闲缓冲区空间<br> 发送方限制自己已经发送的但还未收到ACK的数据不超过接收方的空闲RcvWindow尺寸</p> 
<h4><a id="_313"></a>连接管理</h4> 
<p>三次握手<br> <img src="https://images2.imgbox.com/08/47/4PWepoPF_o.png" alt="image.png"><br> 四次挥手<br> <img src="https://images2.imgbox.com/5a/81/YiWllcq1_o.png" alt="image.png"></p> 
<h4><a id="_318"></a>拥塞控制</h4> 
<p>太多的主机发送太多数据或者速度太快，网络无法处理<br> 表现形式：</p> 
<ul><li>数据包丢失（路由器缓冲区溢出）</li><li>延迟过长（在路由器缓冲区中排队）<br> TCP从观察到的丢失、延误推断出拥堵</li></ul> 
<h5><a id="AIMD_325"></a>AIMD</h5> 
<p>原理：发送方增加传输速率（窗口大小），探查可用带宽，直到发生丢失<br> 事件：Timeout或3个重复的ACK<br> <img src="https://images2.imgbox.com/c7/cc/JNGH8Pxb_o.png" alt="image.png"><br> 丢失事件细节：</p> 
<ul><li>通过三重重复ACK(TCP Reno)检测到丢失时将其减半(TCP Reno)</li><li>当超时(TCP Tahoe)检测到丢失时，切至1MSS(最大段大小)(TCP Tahoe)</li></ul> 
<h6><a id="_332"></a>慢启动</h6> 
<p>连接开始时，以指数2^n方式增加速率(窗口大小cwnd)，直到发生第一次丢失事件</p> 
<h6><a id="LOSS_335"></a>LOSS处理</h6> 
<p>超时导致loss:</p> 
<ul><li>窗口大小cwnd设为1MSS</li><li>窗口然后按指数增长（如慢启动）到阈值，然后线性增长<br> 由3个重复确认导致的loss(TCP RENO）:</li><li>3个重复ACKs表示网络还能够传输一些segments</li><li>cwnd切到一半；然后线性增长 <strong>此时会加上三个ack的时间段，实际上是从一半+3开始，但阈值是一半。</strong><br> <strong>TCP Tahoe不管是超时还是3个ACK，都把cwnd设为1MSS</strong></li></ul> 
<p>阈值变量sthresh<br> loss事件发生时，sthresh被设置为loss事件前的cwnd值的1/2<br> <strong>cwnd上升到sthresh后开始线性增长</strong>。<br> <strong>线性增长也叫拥塞避免</strong></p> 
<h5><a id="TCP_CUBIC_348"></a>TCP CUBIC</h5> 
<p>Wmax:检测到拥塞丢失的发送速率<br> 瓶颈链路的拥塞状态可能变化不大<br> 在切割速率/窗口减半后，最初更快地斜坡到Wmax,但随后更缓慢地接近Wmax<br> <img src="https://images2.imgbox.com/7f/cb/FwapGnew_o.png" alt="image.png"></p> 
<h2><a id="_353"></a>网络层</h2> 
<p><strong>功能：</strong><br> <strong>转发</strong>：将分组从一个输入链路接口转移到适当的输出链路接口的路由器本地动作<br> <strong>路由选择</strong>：确定分组从源到目的地所选用的网络路径</p> 
<h3><a id="_357"></a>数据平面</h3> 
<ul><li>每台路由器的本地功能</li><li>确定如何将到达路由器输入端口的数据报转发到输出端口</li><li>转发功能<br> <img src="https://images2.imgbox.com/f5/fc/D89O64f3_o.png" alt="image.png"></li></ul> 
<h4><a id="_362"></a>转发方式</h4> 
<h5><a id="_363"></a>基于目的地转发</h5> 
<p>仅根据目的地IP地址的转发<br> <strong>最长前缀匹配：</strong> 根据目的地址查找<strong>转发表</strong>条目时，选择与目标地址匹配的最长地址前缀。<br> <img src="https://images2.imgbox.com/9a/79/Y5ht7hWi_o.png" alt="image.png"></p> 
<h5><a id="_367"></a>通用转发</h5> 
<p>根据任意首部字段值的集合的转发</p> 
<h4><a id="_369"></a>交换结构</h4> 
<h5><a id="_370"></a>内存交换</h5> 
<ul><li>采用传统的计算机，交换是在CPU的直接控制下完成</li><li>分组被复制到系统内存中</li><li>速度受限于内存带宽<br> <img src="https://images2.imgbox.com/8d/f1/oCRGnzAK_o.png" alt="image.png"></li></ul> 
<h5><a id="_375"></a>总线交换</h5> 
<ul><li>报文通过一条共享总线从输入端口内存发送到输出端口</li><li>总线争用：交换速度受限于总线带宽。<br> <img src="https://images2.imgbox.com/46/16/QXqUwLu8_o.png" alt="image.png"></li></ul> 
<h5><a id="_379"></a>互联网状交换</h5> 
<ul><li>克服了总线带宽的限制</li><li>高级设计：将报文分片为固定长度单元以通过交换结构。<br> <img src="https://images2.imgbox.com/f6/19/q9cuMwL1_o.png" alt="image.png"></li></ul> 
<h4><a id="_383"></a>缓存管理</h4> 
<h5><a id="FIFOFCFS_384"></a>先来先服务FIFO/FCFS</h5> 
<ul><li>加权公平排队</li><li>弃尾：丢弃到达的分组</li><li>低优先权丢弃：基于优先级的丢弃/移除</li><li>随机丢弃：随机丢弃/移除</li></ul> 
<h5><a id="_389"></a>优先级调度</h5> 
<ul><li>到达流量分类，按类别排队 
  <ul><li>任何标题字段都可以用于分类，如：IP源/目的，端口号等</li></ul> </li><li>多种类别，具有不同的优先级</li><li>发送最高优先级的队列分组<br> <img src="https://images2.imgbox.com/fd/12/zziH6yT9_o.png" alt=""></li></ul> 
<h5><a id="RR_395"></a>循环排队RR</h5> 
<p>循环扫描类别队列，依次从每一个类别发送一个完整分组(如果有的话)<br> <img src="https://images2.imgbox.com/53/d0/xO3yCV9f_o.png" alt="image.png"></p> 
<h5><a id="WFQ_398"></a>加权公平排队WFQ</h5> 
<p>在每一轮循环中，每一类i获得加权数量wi的服务<br> <img src="https://images2.imgbox.com/63/78/mXoHm58F_o.png" alt="image.png"></p> 
<h4><a id="IPv4_401"></a>IPv4</h4> 
<p><img src="https://images2.imgbox.com/4b/1e/o95iuUI1_o.png" alt="image.png"></p> 
<h5><a id="_403"></a>分片/重组</h5> 
<p>一个大的报文会被拆成多个报文，在目的地进行重组。IP首部字节用于识别排序分片。<br> 最大传送单元MTU：一个链路层帧能承载的最大数据量</p> 
<h5><a id="_406"></a>编址</h5> 
<p>IP地址：32bit主机ID/路由器接口<br> 每一类地址都由两个固定长度的字段组成，其中一个字段是网络号net-id,它标志主机（或路由器）所连接到的网络，而另一个字段则是主机号host-id,它标志该主机（或路由器)。<br> <img src="https://images2.imgbox.com/14/2f/1m4dqMb8_o.png" alt="image.png"><br> 特殊IP地址：<br> <img src="https://images2.imgbox.com/78/2d/NGUKyupf_o.png" alt="image.png"></p> 
<h5><a id="_412"></a>子网</h5> 
<p>设备接口，无需通过中间路由器即可物理连接到彼此<br> <img src="https://images2.imgbox.com/0d/7e/qZqtVDUk_o.png" alt="image.png"><br> <img src="https://images2.imgbox.com/0e/e4/uTmW7IQn_o.png" alt="image.png"></p> 
<h5><a id="DHCP__416"></a>DHCP 动态主机配置协议</h5> 
<p>允许主机加入网络时从网络服务器中动态获取其IP地址。<br> DHCP可以提供：</p> 
<ul><li>在子网中分配的IP地址</li><li>客户端的第一跳路由器地址</li><li>DNS服务器的名字和IP地址</li><li>网络掩码<br> <img src="https://images2.imgbox.com/f7/56/xKxu4gJg_o.png" alt="image.png"></li></ul> 
<h5><a id="NAT__424"></a>NAT 网络地址转换</h5> 
<p>本地网络中的所有设备在“专用”IP地址空间(10/8、172.16/12、192.168/16前缀)中都有32位地址，但只能在本地网络中使用</p> 
<ul><li><strong>外出数据报</strong>：替换每一个外出数据报的（源IP地址，端口号）为(NAT IP地址，新的端口号)<br> 远程客户端/服务器的回复数据报采用(NAT IP地址，新的端口号)作为目的地址</li><li><strong>记住（在NAT转换表中）</strong> 每一个（源IP地址，端口号）到(NAT IP地址，新的端口号)的对应关系</li><li><strong>到达报文</strong>：根据存储的NAT表，替换每一个到达报文目的字段(NAT IP地址，新的端口号)为相应的（源IP地址，端口号）<br> <img src="https://images2.imgbox.com/d4/8e/Nph7i0hU_o.png" alt="image.png"></li></ul> 
<h4><a id="IPv6_432"></a>IPv6</h4> 
<ul><li>固定长度40字节首部</li><li>不允许分片</li><li>去掉了校验和<br> <img src="https://images2.imgbox.com/02/6b/0kildUHJ_o.png" alt="image.png"></li></ul> 
<h5><a id="IPv4_to_IPv6_437"></a>IPv4 to IPv6</h5> 
<p><img src="https://images2.imgbox.com/90/e9/bBZvEyUA_o.png" alt="image.png"></p> 
<h4><a id="OpenFlow_439"></a>OpenFlow</h4> 
<p>流表：<br> <img src="https://images2.imgbox.com/8c/56/uLpx8ddd_o.png" alt="image.png"></p> 
<h3><a id="_442"></a>控制平面</h3> 
<ul><li>网络范围的逻辑</li><li>决定数据报从源主机到目的主机的端到端路径中路由器之间的路由方式</li><li>实现控制平面的两种途径： 
  <ul><li>传统路由算法:运行在路由器中</li><li>软件定义网络SDN:运行在（远程）控制器中</li></ul> </li></ul> 
<h4><a id="_448"></a>路由选择算法</h4> 
<h5><a id="LS_449"></a>链路状态LS</h5> 
<p>使用迪杰斯特拉算法，每一次迭代都选最短的一条的节点。所有路由器掌握网络拓扑和链路费用<br> <img src="https://images2.imgbox.com/b8/9d/TN09JnIc_o.png" alt="image.png"><br> <img src="https://images2.imgbox.com/3c/c8/SYpFz9PC_o.png" alt="image.png"></p> 
<h5><a id="DV_453"></a>距离向量DV</h5> 
<p><img src="https://images2.imgbox.com/25/ce/M6vfrI2Z_o.png" alt="image.png"><br> <img src="https://images2.imgbox.com/cd/1f/P99t3QcL_o.png" alt="image.png"><br> <img src="https://images2.imgbox.com/b2/90/8ELR3sQN_o.png" alt="image.png"><br> <img src="https://images2.imgbox.com/19/4e/jKbDcsay_o.png" alt="image.png"></p> 
<h4><a id="_OSPF_458"></a>自治系统内部的路由选择 OSPF</h4> 
<p>域内路由选择：</p> 
<ul><li>在同一自治域(“网络”)内的主机，路由器之间的路由选择</li><li>在一个自治域内的所有路由器必须运行相同的域内路由选择。</li><li>在不同自治域内的路由器可以运行不同的域内路由协议。</li><li>网关路由：位于其所在自治域的“边界”,通过链路与其位于其他自治域的路由器相连<br> 域间路由选择：</li><li>自治域间的路由选择</li><li>网关执行域间路由选择(与域内路由选择类似)。<br> <strong>OSPF</strong></li><li><strong>链路状态发生变化</strong>时，路由器<strong>洪泛</strong>OSPF链路状态消息到整个AS中的所有其他路由器中,使用网络层<strong>IP</strong>协议。</li><li>发送的信息就是与本路由器<strong>相邻</strong>的所有路由器的链路状态，但这只是路由器所知道的部分信息。</li><li>使用迪杰斯特拉算法</li></ul> 
<h5><a id="_471"></a>链路状态数据库</h5> 
<ul><li>由于各路由器之间频繁地交换链路状态信息，因此所有的路由器最终都能建立一个链路状态数据库。</li><li>这个数据库实际上就是<strong>全网的拓扑结构图</strong>，它在全网范围内是一致的（这称为链路状态数据库的同步）</li><li>OSPF的链路状态数据库能较快地进行更新，使各个路由器能及时更新其路由表</li><li>OSPF的更新过程收敛得快是其重要优点。</li></ul> 
<h5><a id="_476"></a>区域划分</h5> 
<p>为了使OSPF能够用于规模很大的网络，OSP将一个自治系统再划分为若干个更小的范围，叫做区域。<br> <img src="https://images2.imgbox.com/eb/f4/YbHiTWUA_o.png" alt="image.png"><br> 区域边界路由器：“汇总”到达区域内内部网络的距离信息，并广播到其他区域边界路由器<br> 主干路由器：仅在主干路由器中运行OSPF<br> 边界路由器：连接到其他的自治域。<br> <img src="https://images2.imgbox.com/7d/36/iecM0dN7_o.png" alt="image.png"><br> 在一个区域内部的路由器只知道本区域的完整网络拓扑，而不知道其他区域的网络拓扑的情况。<br> 主干区域（Area 0）是所有其他OSPF区域（非零区域）的中心枢纽，起到了路由信息分发和汇聚的作用。<br> 区域边界路由器负责在OSPF的<strong>主干区域</strong>和其他区域之间传递路由信息。<br> <strong>主干路由器</strong><br> <img src="https://images2.imgbox.com/fd/87/uDtB16zO_o.png" alt="image.png"><br> <strong>区域边界路由器</strong><br> <img src="https://images2.imgbox.com/4a/95/HvfVgq1l_o.png" alt="image.png"></p> 
<h4><a id="_BGP_490"></a>域间路由选择 BGP</h4> 
<p>eBGP:从<strong>邻居</strong>自治域获取子网可达信息<br> iBGP:传播可达信息到所有自治域<strong>内部</strong>的路由器<br> <img src="https://images2.imgbox.com/b7/cc/Gv02NHy2_o.png" alt="image.png"></p> 
<h5><a id="_494"></a>路径通告</h5> 
<p><img src="https://images2.imgbox.com/ce/98/lH39ETS8_o.png" alt="image.png"></p> 
<h5><a id="_496"></a>热土豆算法</h5> 
<p>选择具有最小域内开销的本地网关（烫手山芋）<br> <img src="https://images2.imgbox.com/bf/90/0yhEjDau_o.png" alt="image.png"></p> 
<h4><a id="SDN_499"></a>软件定义网络SDN</h4> 
<p><img src="https://images2.imgbox.com/27/ab/ZMY0SMea_o.png" alt="image.png"></p> 
<ul><li>维护网络状态信息</li><li>通过北向API与“上面的”网络控制应用交互。</li><li>通过南向API与“下面的”网络交换机交互。<br> <img src="https://images2.imgbox.com/76/5a/8TVBOylm_o.png" alt="image.png"><br> 网络控制应用<br> eg：ryu<br> <img src="https://images2.imgbox.com/cc/c6/aLLGXZma_o.png" alt="image.png"></li></ul> 
<h4><a id="ICMP_508"></a>ICMP</h4> 
<p>主机及路由器使用ICMP以交互网络层面的信息。<br> IP数据报承载ICMP消息</p> 
<h2><a id="_511"></a>数据链路层</h2> 
<p>结点(nodes):主机和路由器<br> 链路(links):一条无源的点到点的物理线路段，中间没有任何其他的交换结点。<br> 数据链路(data-link layer):除了物理线路外,还必须有通信协议来控制这些数据的传输。若把实现这些协议的硬件和软件加到链路上，就构成了数据链路。<br> 帧(frame)：数据链路层数据单位，封装网络层数据报</p> 
<h3><a id="_516"></a>封装成帧</h3> 
<p><img src="https://images2.imgbox.com/f5/a7/6jG4tyuy_o.png" alt="image.png"><br> 头尾添加开始符，结束符。中间冲突字符转义。<br> <img src="https://images2.imgbox.com/d1/f6/nAvJUbYa_o.png" alt="image.png"></p> 
<h3><a id="_520"></a>差错检测</h3> 
<h4><a id="_521"></a>奇偶校验</h4> 
<h4><a id="CRC_522"></a>CRC校验</h4> 
<h4><a id="_523"></a>校验和</h4> 
<ul><li>将“数据”（校验内容）划分为16位的二进制“整数”序列</li><li>求和:补码求和（最高位进位的“1”，返回最低位继续加）</li><li>校验和为sum的反码</li><li>发送方将校验和放入分组(UDP、TCP、IP)的校验和字段</li></ul> 
<h3><a id="MAC_528"></a>多路访问链路协议MAC</h3> 
<h4><a id="ALOHA_529"></a>时隙ALOHA</h4> 
<p><strong>假定</strong>：</p> 
<ul><li>所有帧大小相同</li><li>时间被划分为等长的时隙（每个时隙可以传输1个帧)</li><li>结点只能在时隙开始时发送帧</li><li>结点间时钟同步</li><li>如果2个或2个以上结点在同一时隙发送帧，结点即检测到冲突<br> <strong>运行</strong>：<br> 当结点有新的帧时，在下一个时隙发送</li><li>如果无冲突：该结点可以在下一个时隙继续发送新的帧</li><li>如果冲突：该结点在下一个时隙以概率p重传该帧，直至成功<br> <img src="https://images2.imgbox.com/ae/cf/cRbcKrnw_o.png" alt="image.png"><br> <strong>效率</strong>：<br> 长期运行时成功发送帧的时隙所占比例<br> 假设：N个结点有很多帧待传输，每个结点在每个时隙均以概率p发送数据<br> 对于给定的一个结点，在一个时隙将帧发送成功的概率=p(1-p)^(N-1)<br> 对于任意结点成功发送帧的概率Np(1-p)^(N-1)<br> 最大效率：N-&gt;无穷时，最大效率 = 1/e = 0.37</li></ul> 
<h4><a id="ALOHA_547"></a>纯ALOHA</h4> 
<ul><li>非时隙Aloha:更加简单，无需同步</li><li>当有新的帧生成时，立即发送<br> <img src="https://images2.imgbox.com/8c/a2/Ts8utlMY_o.png" alt="image.png"><br> 效率：<br> <img src="https://images2.imgbox.com/74/56/s2W7j4fp_o.png" alt="image.png"></li></ul> 
<h4><a id="CSMA_553"></a>CSMA</h4> 
<p>发送帧之前，<strong>监听信道</strong></p> 
<ul><li>信道空闲：发送完整帧</li><li>信道忙：推迟发送</li></ul> 
<h4><a id="CSMACD_557"></a>CSMA/CD</h4> 
<p>载波监听多点接入/碰撞检测</p> 
<ul><li>短时间内可以检测到冲突</li><li>冲突后传输中止，减少信道浪费<br> <img src="https://images2.imgbox.com/d5/4b/THho3h2q_o.png" alt="image.png"><br> <img src="https://images2.imgbox.com/82/dd/eq4Bfti2_o.png" alt="image.png"><br> 最先发送数据帧的站，在发送数据帧后至多经过时间2τ（两倍的端到端往返时延)就可知道发送的数据帧是否遭受了碰撞。<br> <strong>如果两端想要成功碰撞检测，那么传播时延要小于传输时延。</strong><br> 争用期：端到端往返时延2τ</li></ul> 
<h5><a id="_566"></a>二进制指数类退避算法</h5> 
<p>发生碰撞的站在停止发送数据后，要推迟一个随机时间才能再发送数据。</p> 
<ol><li><strong>基本退避时间</strong>取为争用期2τ。</li><li>从整数集合[0,1，…，(2^k-1)]中随机地取出一个数，记为r。重传所需<br> 的时延就是<strong>r*512比特时间</strong>。</li><li>参数k按下面的公式计算：<br> k=Min[重传次数，10]</li><li>当k≤10时，参数k等于重传次数。</li><li>当重传达16次仍不能成功时即丢弃该帧，并向高层报告。</li></ol> 
<h3><a id="_575"></a>交换局域网</h3> 
<h4><a id="ARP_576"></a>ARP</h4> 
<ul><li>A想要给同一局域网内的B发送数据报而B的MAC地址不在A的ARP表中。</li><li>A广播ARP查询分组，其中包含B的IP地址目的MAC地址为：FF-FF-FF-FF-FF-FF;LAN中所有结点都会接收</li><li>B接收ARP查询分组，IP地址匹配成功，利用单播帧向A发送应答B的MAC地址</li><li>A在其ARP表中，缓存B的IP-MAC地址对，直至超时，超时后，再次刷新<br> <img src="https://images2.imgbox.com/34/93/KLyTSz5w_o.png" alt="image.png"></li></ul> 
<h4><a id="_582"></a><strong>寻址过程</strong></h4> 
<p><img src="https://images2.imgbox.com/94/fd/gLWuhNeQ_o.png" alt="image.png"><br> A通过路由器R向B发送数据报：</p> 
<ul><li>主机A构造IP数据报，其中源IP地址是A的IP地址，目的IP地址是主机B的IP地址</li><li>主机A构造链路层帧，其中源MAC地址是A的MAC地址，目的MAC地址是R(左)接口的MAC地址，封装A到B的IP数据报。</li><li>数据帧从主机A发送至路由器R</li><li>路由器R接收数据帧，提取IP数据报，传递给上层IP协议</li><li>R转发IP数据报（源和目的IP地址不变）</li><li>R创建链路层帧，其中源MAC地址是R(右)接口的MAC地址，目的MAC地址是B的MAC地址，封装A到B的IP数据报。</li></ul> 
<h4><a id="_591"></a>以太网</h4> 
<p>有线LAN技术</p> 
<ul><li>不可靠</li><li>无连接</li><li>MAC协议采用CSMA/CD<br> <img src="https://images2.imgbox.com/c2/b3/NxpgjKxq_o.png" alt="image.png"></li></ul> 
<h4><a id="_597"></a>链路层交换机</h4> 
<ul><li>存储-转发以太网帧</li><li>检验到达帧的目的MAC地址，选择性向一个或多个输出链路转发帧，利用<strong>CSMA/CD</strong>访问链路，发送帧</li><li>透明传输，主机感知不到交换机的存在</li><li>即插即用，<strong>自学习</strong><br> <img src="https://images2.imgbox.com/43/91/Tf2Vwtiw_o.png" alt="image.png"><br> 目的MAC未知时泛洪，已知时选择性转发</li></ul> 
<h2><a id="_604"></a>无线网络</h2> 
<h3><a id="IEEE_80211_605"></a>IEEE 802.11</h3> 
<h4><a id="CSMACA_606"></a>CSMA/CA</h4> 
<p>带碰撞避免的CSMA(CSMA/CD是碰撞检测)<br> 交换RTS和CTS帧来实现碰撞避免<br> <img src="https://images2.imgbox.com/16/c3/0OiLwDJV_o.png" alt="image.png"><br> 会对正确接收到的数据帧ack确认<br> <strong>帧结构：</strong><br> <img src="https://images2.imgbox.com/0b/0f/kFGvXiFP_o.png" alt="image.png"></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/726b72eca73b2a6a605893ccd7e4ae3b/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">排列和组合【Combination/Permutation 还是 Choose/Arrangement】</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/343ed14e8892b7a25afa20e57f534c91/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">Apache配置ssl证书-实现https访问</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>