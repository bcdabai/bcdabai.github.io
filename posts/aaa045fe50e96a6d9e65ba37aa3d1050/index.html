<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>MyBatis-Plus进阶 - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="MyBatis-Plus进阶" />
<meta property="og:description" content="目录
1.乐观锁和悲观锁
1.1.什么是乐观锁和悲观锁
1.2.乐观锁和悲观锁的区别
1.3.综合案例
2.逻辑删除
2.1.什么是逻辑删除
2.2.为什么使用逻辑删除
2.3.综合案例
2.3.1.官方提示
2.3.2.配置方式
2.3.3.案例演示
3.分页
1.乐观锁和悲观锁 1.1.什么是乐观锁和悲观锁 乐观锁（ Optimistic Locking ）和悲观锁是数据库中的两种并发控制机制。
乐观锁假定数据一般情况下不会发生冲突，因此在读取数据时不会对其加锁，而是在写入时先比较数据版本号（比如时间戳）是否相同，再进行操作。如果版本号相同，则表示该数据没有被其他进程修改，可以进行写操作；如果版本号不同，则表示该数据已经被其他进程修改，写操作会失败，需要重新读取数据进行操作。
乐观锁是为了解决并发过程中数据更新冲突的问题，乐观锁能提高并发过程中的程序吞吐量。
悲观锁则假定数据会发生冲突，因此在读取数据时就会对其加锁，防止其他进程同时修改此数据，直到当前进程操作完成并解锁后，其他进程才能再次操作该数据。
1.2.乐观锁和悲观锁的区别 乐观锁和悲观锁的区别主要有以下几点：
加锁时间不同：乐观锁在读取数据时不会对其加锁，而是在写入时进行比较和加锁操作；悲观锁在读取数据时就会对其加锁。
冲突处理方式不同：乐观锁会在写入时进行比较和冲突检测，如果版本号不一致则操作失败，需要重新读取数据；悲观锁则会阻塞其他进程对该数据的访问，直到当前进程完成操作并解锁。
适用场景不同：乐观锁适用于并发量比较小、数据量比较大、操作更多为读取的场景；悲观锁适用于并发量比较大、数据量比较小、操作更多为写入的场景。
总的来说，乐观锁适用于并发冲突较少的场景，可以提高系统的并发性；悲观锁适用于并发冲突较多的场景，可以保证数据的一致性和安全性。
1.3.综合案例 使用数据版本(Version)记录机制实现乐观锁，这是乐观锁最常用的一种实现方式。
如何实现乐观锁？
@Version 注解标记乐观锁，通过 version 字段来保证数据的安全性，当修改数据的时候，会以 version 作为条件，当条件成立的时候才会修改成功。
1）取出记录时，获取当前 version
2）更新时，带上这个 version
3）执行更新时，update tableName set version = oldVersion &#43; 1 where version = oldVersion
4）如果 version 不对，就更新失败
如何使用MyBatis-Plus实现乐观锁？
第一步：给数据库表添加 version 字段，并设置默认值为1
第二步：实体类增加 version 属性，并添加 @Version 注解
@Getter @Setter @TableName(&#34;t_book&#34;) public class Book implements Serializable { ​ private static final long serialVersionUID = 1L; /** * 书本类型 */ @TableField(&#34;" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/aaa045fe50e96a6d9e65ba37aa3d1050/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2024-01-02T15:28:37+08:00" />
<meta property="article:modified_time" content="2024-01-02T15:28:37+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">MyBatis-Plus进阶</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p id="main-toc"><strong>目录</strong></p> 
<p id="-toc" style="margin-left:0px;"></p> 
<p id="1.%E4%B9%90%E8%A7%82%E9%94%81%E5%92%8C%E6%82%B2%E8%A7%82%E9%94%81-toc" style="margin-left:0px;"><a href="#1.%E4%B9%90%E8%A7%82%E9%94%81%E5%92%8C%E6%82%B2%E8%A7%82%E9%94%81" rel="nofollow">1.乐观锁和悲观锁</a></p> 
<p id="1.1.%E4%BB%80%E4%B9%88%E6%98%AF%E4%B9%90%E8%A7%82%E9%94%81%E5%92%8C%E6%82%B2%E8%A7%82%E9%94%81-toc" style="margin-left:40px;"><a href="#1.1.%E4%BB%80%E4%B9%88%E6%98%AF%E4%B9%90%E8%A7%82%E9%94%81%E5%92%8C%E6%82%B2%E8%A7%82%E9%94%81" rel="nofollow">1.1.什么是乐观锁和悲观锁</a></p> 
<p id="1.2.%E4%B9%90%E8%A7%82%E9%94%81%E5%92%8C%E6%82%B2%E8%A7%82%E9%94%81%E7%9A%84%E5%8C%BA%E5%88%AB-toc" style="margin-left:40px;"><a href="#1.2.%E4%B9%90%E8%A7%82%E9%94%81%E5%92%8C%E6%82%B2%E8%A7%82%E9%94%81%E7%9A%84%E5%8C%BA%E5%88%AB" rel="nofollow">1.2.乐观锁和悲观锁的区别</a></p> 
<p id="1.3.%E7%BB%BC%E5%90%88%E6%A1%88%E4%BE%8B-toc" style="margin-left:40px;"><a href="#1.3.%E7%BB%BC%E5%90%88%E6%A1%88%E4%BE%8B" rel="nofollow">1.3.综合案例</a></p> 
<p id="2.%E9%80%BB%E8%BE%91%E5%88%A0%E9%99%A4-toc" style="margin-left:0px;"><a href="#2.%E9%80%BB%E8%BE%91%E5%88%A0%E9%99%A4" rel="nofollow">2.逻辑删除</a></p> 
<p id="2.1.%E4%BB%80%E4%B9%88%E6%98%AF%E9%80%BB%E8%BE%91%E5%88%A0%E9%99%A4-toc" style="margin-left:40px;"><a href="#2.1.%E4%BB%80%E4%B9%88%E6%98%AF%E9%80%BB%E8%BE%91%E5%88%A0%E9%99%A4" rel="nofollow">2.1.什么是逻辑删除</a></p> 
<p id="2.2.%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BD%BF%E7%94%A8%E9%80%BB%E8%BE%91%E5%88%A0%E9%99%A4-toc" style="margin-left:40px;"><a href="#2.2.%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BD%BF%E7%94%A8%E9%80%BB%E8%BE%91%E5%88%A0%E9%99%A4" rel="nofollow">2.2.为什么使用逻辑删除</a></p> 
<p id="2.3.%E7%BB%BC%E5%90%88%E6%A1%88%E4%BE%8B-toc" style="margin-left:40px;"><a href="#2.3.%E7%BB%BC%E5%90%88%E6%A1%88%E4%BE%8B" rel="nofollow">2.3.综合案例</a></p> 
<p id="2.3.1.%E5%AE%98%E6%96%B9%E6%8F%90%E7%A4%BA-toc" style="margin-left:80px;"><a href="#2.3.1.%E5%AE%98%E6%96%B9%E6%8F%90%E7%A4%BA" rel="nofollow">2.3.1.官方提示</a></p> 
<p id="2.3.2.%E9%85%8D%E7%BD%AE%E6%96%B9%E5%BC%8F-toc" style="margin-left:80px;"><a href="#2.3.2.%E9%85%8D%E7%BD%AE%E6%96%B9%E5%BC%8F" rel="nofollow">2.3.2.配置方式</a></p> 
<p id="2.3.3.%E6%A1%88%E4%BE%8B%E6%BC%94%E7%A4%BA-toc" style="margin-left:80px;"><a href="#2.3.3.%E6%A1%88%E4%BE%8B%E6%BC%94%E7%A4%BA" rel="nofollow">2.3.3.案例演示</a></p> 
<p id="3.%E5%88%86%E9%A1%B5-toc" style="margin-left:0px;"><a href="#3.%E5%88%86%E9%A1%B5" rel="nofollow">3.分页</a></p> 
<hr id="hr-toc"> 
<p></p> 
<h2 id="1.%E4%B9%90%E8%A7%82%E9%94%81%E5%92%8C%E6%82%B2%E8%A7%82%E9%94%81">1.乐观锁和悲观锁</h2> 
<h3 id="1.1.%E4%BB%80%E4%B9%88%E6%98%AF%E4%B9%90%E8%A7%82%E9%94%81%E5%92%8C%E6%82%B2%E8%A7%82%E9%94%81">1.1.什么是乐观锁和悲观锁</h3> 
<p><strong>乐观锁（ Optimistic Locking ）</strong>和<strong>悲观锁</strong>是数据库中的两种并发控制机制。</p> 
<p><strong>乐观锁</strong>假定数据一般情况下不会发生冲突，因此在读取数据时不会对其加锁，而是在写入时先比较数据版本号（比如时间戳）是否相同，再进行操作。如果版本号相同，则表示该数据没有被其他进程修改，可以进行写操作；如果版本号不同，则表示该数据已经被其他进程修改，写操作会失败，需要重新读取数据进行操作。</p> 
<blockquote> 
 <p><strong>乐观锁是为了解决并发过程中数据更新冲突的问题，乐观锁能提高并发过程中的程序吞吐量。</strong></p> 
</blockquote> 
<p><strong>悲观锁</strong>则假定数据会发生冲突，因此在读取数据时就会对其加锁，防止其他进程同时修改此数据，直到当前进程操作完成并解锁后，其他进程才能再次操作该数据。</p> 
<p></p> 
<h3 id="1.2.%E4%B9%90%E8%A7%82%E9%94%81%E5%92%8C%E6%82%B2%E8%A7%82%E9%94%81%E7%9A%84%E5%8C%BA%E5%88%AB">1.2.乐观锁和悲观锁的区别</h3> 
<p><strong>乐观锁</strong>和<strong>悲观锁</strong>的区别主要有以下几点：</p> 
<ol><li> <p><strong>加锁时间不同</strong>：乐观锁在读取数据时不会对其加锁，而是在写入时进行比较和加锁操作；悲观锁在读取数据时就会对其加锁。</p> </li><li> <p><strong>冲突处理方式不同</strong>：乐观锁会在写入时进行比较和冲突检测，如果版本号不一致则操作失败，需要重新读取数据；悲观锁则会阻塞其他进程对该数据的访问，直到当前进程完成操作并解锁。</p> </li><li> <p><strong>适用场景不同</strong>：乐观锁适用于并发量比较小、数据量比较大、操作更多为读取的场景；悲观锁适用于并发量比较大、数据量比较小、操作更多为写入的场景。</p> </li></ol> 
<p>总的来说，乐观锁适用于并发冲突较少的场景，可以提高系统的并发性；悲观锁适用于并发冲突较多的场景，可以保证数据的一致性和安全性。</p> 
<p></p> 
<h3 id="1.3.%E7%BB%BC%E5%90%88%E6%A1%88%E4%BE%8B">1.3.综合案例</h3> 
<p>使用数据版本(Version)记录机制实现乐观锁，这是乐观锁最常用的一种实现方式。</p> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/9c/77/MTpGab63_o.png"></p> 
<p></p> 
<ul><li> <p><strong>如何实现乐观锁？</strong></p> </li></ul> 
<p><code>@Version</code> 注解标记乐观锁，通过 version 字段来保证数据的安全性，当修改数据的时候，会以 version 作为条件，当条件成立的时候才会修改成功。</p> 
<p>1）取出记录时，获取当前 version</p> 
<p>2）更新时，带上这个 version</p> 
<p>3）执行更新时，<code>update tableName set version = oldVersion + 1 where version = oldVersion</code></p> 
<p>4）如果 version 不对，就更新失败</p> 
<p></p> 
<ul><li> <p><strong>如何使用MyBatis-Plus实现乐观锁？</strong></p> </li></ul> 
<p><strong>第一步：给数据库表添加 version 字段，并设置默认值为1</strong></p> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/1c/9e/EIs2cPHU_o.png"></p> 
<p></p> 
<p><strong>第二步：实体类增加 version 属性，并添加 @Version 注解</strong></p> 
<pre><code>@Getter
@Setter
@TableName("t_book")
public class Book implements Serializable {
​
    private static final long serialVersionUID = 1L;
    
    /**
     * 书本类型
     */
    @TableField("booktype")
    private String booktype;
​
    /**
     * 乐观锁
     */
    @Version
    private Integer version;
}</code></pre> 
<p></p> 
<p><strong>第三步：配置乐观锁插件</strong></p> 
<pre><code>@Configuration
public class MyBatisPlusConfig {
    @Bean
    public MybatisPlusInterceptor mybatisPlusInterceptor() {
        MybatisPlusInterceptor mybatisPlusInterceptor = new MybatisPlusInterceptor();
        //注册乐观锁插件
        mybatisPlusInterceptor.addInnerInterceptor(new OptimisticLockerInnerInterceptor());
        return mybatisPlusInterceptor;
    }
}</code></pre> 
<p></p> 
<p><strong>第四步：测试</strong></p> 
<pre><code>@Test
public void demo2(){
    //先查询，再修改
    Book book = bookMapper.selectById("1685091066406");
    book.setBookname("Java编程思想");
    book.setPrice(100f);
    bookMapper.updateById(book);
}</code></pre> 
<p>从控制台的日志信息发现：修改数据时 version 作为条件判断，并且 version 自动完成自增操作，即：<code>version = version+1</code> 。<img alt="" src="https://images2.imgbox.com/90/20/Gpj3tX9U_o.png"></p> 
<p>测试多线程下乐观锁失败：</p> 
<p style="text-align:center;"></p> 
<pre><code>@Test
public void demo2(){
    //线程1：
    Book book1 = bookMapper.selectById("1685091066406");
    book1.setBookname(".Net之入门");
    book1.setPrice(110f);
​
    //线程2：(在线程1的修改操作未来得及执行时介入)
    Book book2 = bookMapper.selectById("1685091066406");
    book2.setBookname("Python之入门");
    book2.setPrice(200f);
    bookMapper.updateById(book2);
​
    //如果没有乐观锁就会覆盖插队线程的值！
    bookMapper.updateById(book1);//更新失败
}</code></pre> 
<p><img alt="" src="https://images2.imgbox.com/e8/16/BWbO13zn_o.png"></p> 
<p></p> 
<h2 id="2.%E9%80%BB%E8%BE%91%E5%88%A0%E9%99%A4">2.逻辑删除</h2> 
<h3 id="2.1.%E4%BB%80%E4%B9%88%E6%98%AF%E9%80%BB%E8%BE%91%E5%88%A0%E9%99%A4">2.1.什么是逻辑删除</h3> 
<p><code>MyBatis-Plus</code>中的逻辑删除（Logical Delete）是在数据库中进行虚拟删除，即实际删除数据时，并不会将数据从数据库中删除，而是通过一个标记来记录其已被删除。这种删除方式称为逻辑删除或软删除。</p> 
<p></p> 
<h3 id="2.2.%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BD%BF%E7%94%A8%E9%80%BB%E8%BE%91%E5%88%A0%E9%99%A4">2.2.为什么使用逻辑删除</h3> 
<p>当我们使用物理删除时，数据将被永久删除，无法恢复。但有些情况下，我们并不希望永久删除数据，比如用户误删除、操作失误等情况，这时逻辑删除就尤为重要。</p> 
<p>另外，逻辑删除还可以对应业务层逻辑，将数据状态标志为“已删除”，便于后续查询和统计。同时，逻辑删除还能提高删除操作效率，减少物理删除数据对系统性能的影响。</p> 
<p></p> 
<h3 id="2.3.%E7%BB%BC%E5%90%88%E6%A1%88%E4%BE%8B">2.3.综合案例</h3> 
<h4 id="2.3.1.%E5%AE%98%E6%96%B9%E6%8F%90%E7%A4%BA">2.3.1.官方提示</h4> 
<p><strong>说明：只对自动注入的 sql 起效。</strong></p> 
<ul><li> <p>插入: 不作限制</p> </li><li> <p>查找: 追加 where 条件过滤掉已删除数据,如果使用 wrapper.entity 生成的 where 条件也会自动追加该字段</p> </li><li> <p>更新: 追加 where 条件防止更新到已删除数据,如果使用 wrapper.entity 生成的 where 条件也会自动追加该字段</p> </li><li> <p>删除: 转变为 更新</p> </li></ul> 
<p><strong>例如:</strong></p> 
<ul><li> <p>删除: <code>update user set deleted=1 where id = 1 and deleted=0</code></p> </li><li> <p>查找: <code>select id,name,deleted from user where deleted=0</code></p> </li></ul> 
<p><strong>字段类型支持说明:</strong></p> 
<ul><li> <p>支持所有数据类型(推荐使用 <code>Integer</code>,<code>Boolean</code>,<code>LocalDateTime</code>)</p> </li><li> <p>如果数据库字段使用<code>datetime</code>,逻辑未删除值和已删除值支持配置为字符串<code>null</code>,另一个值支持配置为函数来获取值如<code>now()</code></p> </li></ul> 
<p><strong>附录:</strong></p> 
<ul><li> <p>逻辑删除是为了方便数据恢复和保护数据本身价值等等的一种方案，但实际就是删除。</p> </li><li> <p>如果你需要频繁查出来看就不应使用逻辑删除，而是以一个状态去表示。</p> </li></ul> 
<p></p> 
<h4 id="2.3.2.%E9%85%8D%E7%BD%AE%E6%96%B9%E5%BC%8F">2.3.2.配置方式</h4> 
<ul><li> <p><strong>全局配置：</strong></p> </li></ul> 
<p>在<code>application.yml</code>中添加全局逻辑删除配置，如下：</p> 
<pre><code>mybatis-plus:
  global-config:
    db-config:
      logic-delete-field: deleted # 全局逻辑删除的实体字段名
      logic-delete-value: 1       # 逻辑已删除值(默认为 1)
      logic-not-delete-value: 0   # 逻辑未删除值(默认为 0)</code></pre> 
<p>在对应的实体类中添加逻辑删除字段，如下：</p> 
<pre><code>/**
 * 逻辑删除
 */
@TableField("deleted")
private Integer deleted;</code></pre> 
<blockquote> 
 <p><strong>这里不需要配置<code>@TableLogic</code>注解，必须指定<code>@TableField</code>并设置对应数据库中的字段名。</strong></p> 
</blockquote> 
<p></p> 
<ul><li> <p><strong>局部配置：</strong></p> </li></ul> 
<p>请在实体类对应的逻辑删除属性上加入<code>@TableLogic</code>注解。其中<code>@TableLogic</code>注解属性介绍如下：</p> 
<table><thead><tr><th>属性名</th><th>类型</th><th>说明</th></tr></thead><tbody><tr><td>value</td><td>String</td><td>未逻辑删除的值</td></tr><tr><td>delval</td><td>String</td><td>已逻辑删除的值</td></tr></tbody></table> 
<p>在实体类上配置逻辑删除字段，如下：</p> 
<pre><code>/**
* 逻辑删除，1=删除，0=正常
*/
@TableLogic(value = "0",delval = "1")
@TableField("deleted")
private Integer deleted;</code></pre> 
<p></p> 
<h4 id="2.3.3.%E6%A1%88%E4%BE%8B%E6%BC%94%E7%A4%BA">2.3.3.案例演示</h4> 
<p>创建<code>junit</code>测试，使用<code>deleteById</code>方法进行测试。</p> 
<pre><code>@Test
public void demo3(){
    //先使用deleteById删除对应的数据
    bookMapper.deleteById("1662019679144763393");
    //使用查询方法查询数据
    //List&lt;Book&gt; books = bookMapper.selectList(null);
    //books.forEach(System.out::println);
}</code></pre> 
<p>请观察<code>idea</code>控制台输出结果，会发现执行<code>deleteById</code>方法后，不再显示delete语句，而是update语句。则表示逻辑删除成功，可查看<code>MySQL</code>数据表中的结果。</p> 
<p>然后，执行<code>selectList(null)</code>方法，可发现查询语句的<code>where</code>条件后加入逻辑删除字段<code>deleted=0</code>的判断处理，表示只查询出未逻辑删除的数据。</p> 
<h2 id="3.%E5%88%86%E9%A1%B5">3.分页</h2> 
<p><strong>配置分页插件</strong></p> 
<pre><code>@Configuration
public class MyBatisPlusConfig {
    @Bean
    public MybatisPlusInterceptor mybatisPlusInterceptor() {
        MybatisPlusInterceptor mybatisPlusInterceptor = new MybatisPlusInterceptor();
      	...
        //注册分页插件
        mybatisPlusInterceptor.addInnerInterceptor(new PaginationInnerInterceptor(DbType.MYSQL));
        return mybatisPlusInterceptor;
    }
}</code></pre> 
<p><strong>实现分页</strong></p> 
<pre><code>int page=1;
int row=10;
//条件构造器
QueryWrapper&lt;Book&gt; wrapper=new QueryWrapper&lt;&gt;();
//设置条件
//TODO
//设置分页
Page&lt;Book&gt; result = bookMapper.selectPage(new Page&lt;Book&gt;()
                .setCurrent(page)
                .setSize(row)
                , wrapper);
List&lt;Book&gt; records = result.getRecords();
System.out.println("总记录数："+result.getTotal());
records.forEach(System.out::println);</code></pre> 
<p></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/b830bf4657bebd0db6a825c2b59f83be/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">Python程序休眠n秒/毫秒</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/b24d1b323ad3a0ba892d7f925423a426/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">工具类(对两个集合进行筛选,获取增值和差值进行增删更新操作)</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>