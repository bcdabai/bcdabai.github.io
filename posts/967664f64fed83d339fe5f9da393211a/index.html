<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>数据结构与算法 | 第三章：栈与队列 - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="数据结构与算法 | 第三章：栈与队列" />
<meta property="og:description" content="本文参考网课为 数据结构与算法 1 第三章栈，主讲人 张铭 、王腾蛟 、赵海燕 、宋国杰 、邹磊 、黄群。
本文使用IDE为 Clion，开发环境 C&#43;&#43;14。
更新：2023 / 11 / 5
数据结构与算法 | 第三章：栈与队列 栈概念示例 实现顺序栈类定义进出栈进栈出栈 链式栈类定义进出栈进栈出栈 顺序栈 V.S 链式栈 应用表达式求值中缀表达式概念 后缀表达式概念示例对后缀表达式求值中缀表达式转换为后缀表达式 递归概念递归、迭代递归函数尾递归 示例阶乘函数的调用栈递归到非递归的转换 通用的机械转换步骤 队列概念实现顺序队列类定义 链式队列类定义 顺序队列 V.S 链式队列 应用宽度优先搜索示例：人狼羊菜过河初步分析最终分析 参考链接 线性表 可以在表的任意位置进行元素的插入、删除等运算。而 栈（ Stack ）的运算只在表的一端进行，队列（ Queue ）的运算只在表的两端进行，因此可以将 栈 与 队列 视为操作受限的 线性表。
栈 概念 栈 是一种限制访问端口的 线性表，后进先出（ Last In First Out ）。
栈 的主要操作有 进栈（ push ）和 出栈（ pop ）。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/967664f64fed83d339fe5f9da393211a/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-11-05T10:37:00+08:00" />
<meta property="article:modified_time" content="2023-11-05T10:37:00+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">数据结构与算法 | 第三章：栈与队列</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-github-gist">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p>本文参考网课为 <code>数据结构与算法</code> <sup class="footnote-ref"><a href="#fn1" rel="nofollow" id="fnref1">1</a></sup> 第三章栈，主讲人 张铭 、王腾蛟 、赵海燕 、宋国杰 、邹磊 、黄群。</p> 
<p>本文使用IDE为 <code>Clion</code>，开发环境 <code>C++14</code>。</p> 
<p>更新：2023 / 11 / 5</p> 
<hr> 
<p></p> 
<div class="toc"> 
 <h4>数据结构与算法 | 第三章：栈与队列</h4> 
 <ul><li><a href="#_16" rel="nofollow">栈</a></li><li><ul><li><a href="#_17" rel="nofollow">概念</a></li><li><ul><li><a href="#_42" rel="nofollow">示例</a></li></ul> 
   </li><li><a href="#_65" rel="nofollow">实现</a></li><li><ul><li><a href="#_70" rel="nofollow">顺序栈</a></li><li><ul><li><a href="#_76" rel="nofollow">类定义</a></li><li><a href="#_98" rel="nofollow">进出栈</a></li><li><ul><li><a href="#_99" rel="nofollow">进栈</a></li><li><a href="#_119" rel="nofollow">出栈</a></li></ul> 
    </li></ul> 
    </li><li><a href="#_138" rel="nofollow">链式栈</a></li><li><ul><li><a href="#_143" rel="nofollow">类定义</a></li><li><a href="#_161" rel="nofollow">进出栈</a></li><li><ul><li><a href="#_162" rel="nofollow">进栈</a></li><li><a href="#_178" rel="nofollow">出栈</a></li></ul> 
    </li></ul> 
    </li><li><a href="#_VS__197" rel="nofollow">顺序栈 V.S 链式栈</a></li></ul> 
   </li><li><a href="#_210" rel="nofollow">应用</a></li><li><ul><li><a href="#_221" rel="nofollow">表达式求值</a></li><li><ul><li><a href="#_235" rel="nofollow">中缀表达式</a></li><li><ul><li><a href="#_236" rel="nofollow">概念</a></li></ul> 
     </li><li><a href="#_250" rel="nofollow">后缀表达式</a></li><li><ul><li><a href="#_251" rel="nofollow">概念</a></li><li><a href="#_261" rel="nofollow">示例</a></li><li><ul><li><a href="#_262" rel="nofollow">对后缀表达式求值</a></li><li><a href="#_337" rel="nofollow">中缀表达式转换为后缀表达式</a></li></ul> 
     </li></ul> 
    </li></ul> 
    </li><li><a href="#_359" rel="nofollow">递归</a></li><li><ul><li><a href="#_360" rel="nofollow">概念</a></li><li><ul><li><a href="#_361" rel="nofollow">递归、迭代</a></li><li><a href="#_374" rel="nofollow">递归函数</a></li><li><ul><li><a href="#_419" rel="nofollow">尾递归</a></li></ul> 
     </li></ul> 
     </li><li><a href="#_455" rel="nofollow">示例</a></li><li><ul><li><a href="#_456" rel="nofollow">阶乘函数的调用栈</a></li><li><a href="#_474" rel="nofollow">递归到非递归的转换</a></li></ul> 
     </li><li><a href="#_481" rel="nofollow">通用的机械转换步骤</a></li></ul> 
   </li></ul> 
  </li></ul> 
  </li><li><a href="#_496" rel="nofollow">队列</a></li><li><ul><li><a href="#_497" rel="nofollow">概念</a></li><li><a href="#_525" rel="nofollow">实现</a></li><li><ul><li><a href="#_530" rel="nofollow">顺序队列</a></li><li><ul><li><a href="#_548" rel="nofollow">类定义</a></li></ul> 
    </li><li><a href="#_590" rel="nofollow">链式队列</a></li><li><ul><li><a href="#_599" rel="nofollow">类定义</a></li></ul> 
    </li><li><a href="#_VS__643" rel="nofollow">顺序队列 V.S 链式队列</a></li></ul> 
   </li><li><a href="#_650" rel="nofollow">应用</a></li><li><ul><li><a href="#_661" rel="nofollow">宽度优先搜索</a></li><li><ul><li><a href="#_662" rel="nofollow">示例：人狼羊菜过河</a></li><li><ul><li><a href="#_663" rel="nofollow">初步分析</a></li><li><a href="#_724" rel="nofollow">最终分析</a></li></ul> 
    </li></ul> 
   </li></ul> 
  </li></ul> 
  </li><li><a href="#_782" rel="nofollow">参考链接</a></li></ul> 
</div> 
<p></p> 
<hr> 
<p><code>线性表</code> 可以在表的任意位置进行元素的插入、删除等运算。而 <code>栈</code>（ <code>Stack</code> ）的运算只在表的一端进行，<code>队列</code>（ <code>Queue</code> ）的运算只在表的两端进行，因此可以将 <code>栈</code> 与 <code>队列</code> 视为操作受限的 <code>线性表</code>。</p> 
<br> 
<h2><a id="_16"></a>栈</h2> 
<h3><a id="_17"></a>概念</h3> 
<p><code>栈</code> 是一种限制访问端口的 <code>线性表</code>，后进先出（ <code>Last In First Out</code> ）。<br> <code>栈</code> 的主要操作有 <code>进栈</code>（ <code>push</code> ）和 <code>出栈</code>（ <code>pop</code> ）。</p> 
<p><code>栈</code> 的应用有：</p> 
<ul><li>表达式求值</li><li>消除递归</li><li>深度优先搜索</li></ul> 
<p><code>栈</code> 的抽象数据类型如下：</p> 
<pre><code class="prism language-cpp"><span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">T</span><span class="token operator">&gt;</span>
<span class="token keyword">class</span> <span class="token class-name">stack</span><span class="token punctuation">{<!-- --></span>
<span class="token keyword">public</span><span class="token operator">:</span>                                 <span class="token comment">// 栈的运算集</span>
    <span class="token keyword">void</span> <span class="token function">clear</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                       <span class="token comment">// 清空栈</span>
    <span class="token keyword">bool</span> <span class="token function">push</span><span class="token punctuation">(</span><span class="token keyword">const</span> T item<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment">// push item入栈。成功推入，返回真；否则返回假</span>
    <span class="token keyword">bool</span> <span class="token function">pop</span><span class="token punctuation">(</span>T<span class="token operator">&amp;</span> item<span class="token punctuation">)</span><span class="token punctuation">;</span>                  <span class="token comment">// 返回栈顶内容并弹出。成功弹出，返回真；否则返回假</span>
    <span class="token keyword">bool</span> <span class="token function">top</span><span class="token punctuation">(</span>T<span class="token operator">&amp;</span> item<span class="token punctuation">)</span><span class="token punctuation">;</span>                  <span class="token comment">// 返回栈顶但不弹出。成功弹出，返回真；否则返回假</span>
    <span class="token keyword">bool</span> <span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                     <span class="token comment">// 若栈已空，返回真</span>
    <span class="token keyword">bool</span> <span class="token function">isFull</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                      <span class="token comment">// 若栈已满，返回真</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre> 
<br> 
<h4><a id="_42"></a>示例</h4> 
<p>假如给定一个入栈顺序 <code>1、2、3、4</code>，则出栈的顺序可以有哪些？</p> 
<p>设 <code>k</code> 是最后一个出栈的，那么 <code>k</code> 把序列一分为二。在 <code>k</code> 之前入栈的元素，一定在比在 <code>k</code> 之后入栈的元素要提前出栈。</p> 
<p>假设已知出栈顺序为 <code>1、4、2、3</code>，<code>3</code> 是最后1个出栈的，那么 <code>3</code> 将 <code>1、2、3、4</code> 分为 <code>1、2</code> 和 <code>4</code>。即 <code>1、2</code> 的出栈要在 <code>4</code> 之前。然而 <code>2</code> 不可能早于 <code>4</code> 出栈，因此 <code>1、4、2、3</code> 是不可能的。</p> 
<p>再假设出栈顺序为 <code>1、3、4、2</code>，<code>2</code> 是最后1个出栈的，那么 <code>2</code> 将 <code>1、2、3、4</code> 分为 <code>1</code> 和 <code>3、4</code>。显然，<code>1</code> 是在 <code>3、4</code> 之前的，<code>3</code> 也是可以在 <code>4</code> 之前的。</p> 
<hr> 
<p>那么，现在给定一个入栈序列，序列长度为 <code>N</code>，请计算有多少种出栈序列。</p> 
<p>设有 <code>f(N)</code> 个出栈序列，如果 <code>x</code> 是最后一个出栈的，那么 <code>x</code> 个元素一定在 <code>N-1-x</code> 个元素之前出栈。</p> 
<p>前面的 <code>x</code> 个元素有 <code>f(x)</code> 种出栈序列，后面的 <code>N-1-x</code> 个元素有 <code>f(N-1-x)</code> 种出栈序列。<code>x</code> 和 <code>N-1-x</code> 个元素之间的整体出栈顺序是确定的，但是它们内部的出栈顺序是不定的，所以：</p> 
<p><img src="https://images2.imgbox.com/18/8c/GkFZnLDH_o.png" alt="在这里插入图片描述" width="240"><br> <img src="https://images2.imgbox.com/c7/b3/OIIs3CZl_o.png" alt="在这里插入图片描述" width="200"><br> <code>x</code> 可以从 <code>0</code> 到 <code>N-1</code>。</p> 
<br> 
<h3><a id="_65"></a>实现</h3> 
<p><code>栈</code> 的物理实现有2种，1种称为 <code>顺序栈</code>（ <code>Array-based Stack</code> ），另1种称为 <code>链式栈</code>（ <code>Linked Stack</code> ）。</p> 
<br> 
<h4><a id="_70"></a>顺序栈</h4> 
<p>使用向量实现，本质是 <code>顺序表</code> 的简化版。<br> 关键是确定哪一端作为栈顶。</p> 
<br> 
<h5><a id="_76"></a>类定义</h5> 
<pre><code class="prism language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iomanip&gt;</span></span>
<span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span>

<span class="token keyword">template</span> <span class="token keyword">class</span> <span class="token operator">&lt;</span>T<span class="token operator">&gt;</span> <span class="token keyword">class</span> <span class="token class-name">arrStack</span><span class="token operator">:</span><span class="token base-clause"><span class="token keyword">public</span> <span class="token class-name">Stack</span><span class="token operator">&lt;</span><span class="token class-name">T</span><span class="token operator">&gt;</span></span><span class="token punctuation">{<!-- --></span>
<span class="token keyword">private</span><span class="token operator">:</span>                                                <span class="token comment">// 栈的顺序存储</span>
    <span class="token keyword">int</span> mSize<span class="token punctuation">;</span>                                          <span class="token comment">// 栈中最多可存放的元素个数</span>
    <span class="token keyword">int</span> top<span class="token punctuation">;</span>                                            <span class="token comment">// 栈顶位置，应小于mSize</span>
    T <span class="token operator">*</span>st<span class="token punctuation">;</span>                                              <span class="token comment">// 存放栈元素的数组</span>
<span class="token keyword">public</span><span class="token operator">:</span>
    <span class="token function">arrStack</span><span class="token punctuation">(</span><span class="token keyword">int</span> size<span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>                                 <span class="token comment">// 构造函数，创建一个给定长度的顺序栈实例</span>
        mSize <span class="token operator">=</span> size<span class="token punctuation">;</span> top <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span> st <span class="token operator">=</span> <span class="token keyword">new</span> T<span class="token punctuation">[</span>mSize<span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token operator">~</span><span class="token function">arrStack</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span><span class="token keyword">delete</span> <span class="token punctuation">[</span><span class="token punctuation">]</span> st<span class="token punctuation">;</span><span class="token punctuation">}</span>                          <span class="token comment">// 析构函数</span>
    <span class="token keyword">void</span> <span class="token function">clear</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>top <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span><span class="token punctuation">}</span>                             <span class="token comment">// 清空栈；将栈顶top指向栈底，过后，若有新的元素入栈则会覆盖栈内原有的元素</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre> 
<br> 
<h5><a id="_98"></a>进出栈</h5> 
<h6><a id="_99"></a>进栈</h6> 
<p><img src="https://images2.imgbox.com/92/f8/qchDoWS4_o.png" alt="在这里插入图片描述" width="210"></p> 
<p>当栈中已经有 <code>maxsize</code> 个元素时，如果再做进栈运算，会产生 <code>上溢</code>（ <code>overflow</code> ）。</p> 
<p>因此，压入栈顶时需要做边界条件判定再进行入栈，如下：</p> 
<pre><code class="prism language-cpp"><span class="token keyword">bool</span> <span class="token class-name">arrStack</span><span class="token operator">&lt;</span>T<span class="token operator">&gt;</span><span class="token double-colon punctuation">::</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token keyword">const</span> T item<span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>top <span class="token operator">==</span> mSize <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>                  <span class="token comment">// 满栈</span>
            count <span class="token operator">&lt;&lt;</span> <span class="token string">"栈满溢出"</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
            <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span><span class="token keyword">else</span><span class="token punctuation">{<!-- --></span>                                  <span class="token comment">// 新元素入栈并修改栈顶指针</span>
        st<span class="token punctuation">[</span><span class="token operator">++</span>top<span class="token punctuation">]</span> <span class="token operator">==</span> item<span class="token punctuation">;</span>					<span class="token comment">// top指针做自增</span>
        <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> 
<br> 
<h6><a id="_119"></a>出栈</h6> 
<p><img src="https://images2.imgbox.com/aa/62/ruGknQ6x_o.png" alt="在这里插入图片描述" width="220"><br> 对 <code>空栈</code> 进行出栈运算时可能会出现 <code>下溢</code>（ <code>underflow</code> ）。</p> 
<p>因此，弹出栈顶时需要做边界条件判定再进行出栈，如下：</p> 
<pre><code class="prism language-cpp"><span class="token keyword">bool</span> <span class="token class-name">arrStack</span><span class="token operator">&lt;</span>T<span class="token operator">&gt;</span><span class="token double-colon punctuation">::</span><span class="token function">pop</span><span class="token punctuation">(</span>T<span class="token operator">&amp;</span> item<span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>         <span class="token comment">// 出栈</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>top <span class="token operator">==</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>                     <span class="token comment">// 空栈</span>
        cout <span class="token operator">&lt;&lt;</span> <span class="token string">"空栈，不能出栈"</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
        <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span><span class="token keyword">else</span><span class="token punctuation">{<!-- --></span>
        item <span class="token operator">=</span> st<span class="token punctuation">[</span>top<span class="token operator">--</span><span class="token punctuation">]</span><span class="token punctuation">;</span>               <span class="token comment">// 返回栈顶，并缩减1</span>
        <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> 
<br> 
<h4><a id="_138"></a>链式栈</h4> 
<p>用 <code>单链表</code> 方式存储，其中指针的方向是从栈顶向下链接。</p> 
<br> 
<h5><a id="_143"></a>类定义</h5> 
<pre><code class="prism language-cpp"><span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">T</span><span class="token operator">&gt;</span> <span class="token keyword">class</span> <span class="token class-name">lnkStack</span><span class="token operator">:</span> <span class="token base-clause"><span class="token keyword">public</span> <span class="token class-name">Stack</span><span class="token operator">&lt;</span><span class="token class-name">T</span><span class="token operator">&gt;</span></span><span class="token punctuation">{<!-- --></span>
<span class="token keyword">private</span><span class="token operator">:</span>                                                <span class="token comment">// 栈的链式存储</span>
    Link<span class="token operator">&lt;</span>T<span class="token operator">&gt;</span><span class="token operator">*</span> top<span class="token punctuation">;</span>                                       <span class="token comment">// 指向栈顶的指针</span>
    <span class="token keyword">int</span> size<span class="token punctuation">;</span>                                           <span class="token comment">// 存放元素的个数</span>
<span class="token keyword">public</span><span class="token operator">:</span>                                                 <span class="token comment">// 栈运算的链式元素实现</span>
    <span class="token function">lnkStack</span><span class="token punctuation">(</span><span class="token keyword">int</span> defSize<span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>                              <span class="token comment">// 构造函数</span>
        top <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span> size <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token operator">~</span><span class="token function">lnkStack</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>                                        <span class="token comment">// 析构函数</span>
        <span class="token function">clear</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre> 
<br> 
<h5><a id="_161"></a>进出栈</h5> 
<h6><a id="_162"></a>进栈</h6> 
<pre><code class="prism language-cpp"><span class="token keyword">bool</span> <span class="token class-name">lnkStack</span><span class="token operator">&lt;</span>T<span class="token operator">&gt;</span><span class="token double-colon punctuation">::</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token keyword">const</span> T item<span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>           <span class="token comment">// 入栈操作的链式实现</span>
    Link<span class="token operator">&lt;</span>T<span class="token operator">&gt;</span><span class="token operator">*</span> tmp <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token generic-function"><span class="token function">Link</span><span class="token generic class-name"><span class="token operator">&lt;</span>T<span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span>item<span class="token punctuation">,</span> top<span class="token punctuation">)</span><span class="token punctuation">;</span>
    top <span class="token operator">=</span> tmp<span class="token punctuation">;</span>
    size <span class="token operator">++</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token function">Link</span><span class="token punctuation">(</span><span class="token keyword">const</span> T info<span class="token punctuation">,</span> Link<span class="token operator">*</span> nextValue<span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>            <span class="token comment">// 具有2个参数的Link构造函数</span>
    data <span class="token operator">=</span> info<span class="token punctuation">;</span>
    next <span class="token operator">=</span> nextValue<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<br> 
<h6><a id="_178"></a>出栈</h6> 
<pre><code class="prism language-cpp"><span class="token keyword">bool</span> <span class="token class-name">lnkStack</span><span class="token operator">&lt;</span>T<span class="token operator">&gt;</span><span class="token double-colon punctuation">::</span><span class="token function">pop</span><span class="token punctuation">(</span>T<span class="token operator">&amp;</span> item<span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
    Link <span class="token operator">&lt;</span>T<span class="token operator">&gt;</span> <span class="token operator">*</span>tmp<span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>size <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
        cout <span class="token operator">&lt;&lt;</span> <span class="token string">"空栈，不能出栈"</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
        <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    item <span class="token operator">=</span> top <span class="token operator">-&gt;</span> data<span class="token punctuation">;</span>                     <span class="token comment">// 将top的数据赋值给item，将item弹出去</span>
    tmp <span class="token operator">=</span> top <span class="token operator">-&gt;</span> next<span class="token punctuation">;</span>                      <span class="token comment">// 将top的next指向tmp</span>
    <span class="token keyword">delete</span> top<span class="token punctuation">;</span>                             <span class="token comment">// delete top对应的内存空间</span>
    top <span class="token operator">=</span> tmp<span class="token punctuation">;</span>                              <span class="token comment">// 将tmp对应的数据赋值给top</span>
    size<span class="token operator">--</span><span class="token punctuation">;</span>                                 <span class="token comment">// 元素数量自减1</span>
    <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<br> 
<h4><a id="_VS__197"></a>顺序栈 V.S 链式栈</h4> 
<ul><li> <p>时间效率</p> 
  <ul><li>所有操作都只需要常数时间。二者难分伯仲。</li></ul> </li><li> <p>空间效率</p> 
  <ul><li><code>顺序栈</code> 须说明一个固定的长度；</li><li><code>链式栈</code> 的长度可变，但是增加结构性开销；</li></ul> </li><li> <p>应用范围</p> </li></ul> 
<ul><li>实际应用中，<code>顺序栈</code> 比 <code>链式栈</code> 应用范围更广泛</li></ul> 
<br> 
<h3><a id="_210"></a>应用</h3> 
<p><code>栈</code> 的特点是后进先出。</p> 
<p><code>栈</code> 通常被用来处理具有递归结构的数据：</p> 
<ul><li>深度优先搜索</li><li>表达式求值</li><li>子程序 / 函数调用的管理</li><li>消除递归</li></ul> 
<br> 
<h4><a id="_221"></a>表达式求值</h4> 
<p>表达式的递归定义：</p> 
<ul><li>基本符号集<br> { <code>0</code>，<code>1</code>，…，<code>9</code>，<code>+</code>，<code>-</code>，<code>*</code>，<code>/</code>，<code>(</code>，<code>)</code> }</li><li>语法成分集<br> { <code>&lt;表达式&gt;</code>，<code>&lt;项&gt;</code>，<code>&lt;因子&gt;</code>，<code>&lt;常数&gt;</code>，<code>&lt;数字&gt;</code> } 
  <ul><li>表达式 
    <ul><li>中缀表达式<br> 23 + （34*45）/ （5 + 6 + 7）</li><li>后缀表达式<br> 23 34 45 * 5 6 + 7 + / +</li></ul> </li></ul> </li></ul> 
<br> 
<h5><a id="_235"></a>中缀表达式</h5> 
<h6><a id="_236"></a>概念</h6> 
<p><code>中缀表达式</code> 的特点是：</p> 
<ul><li>运算符在中间</li><li>需要括号来改变优先级</li></ul> 
<p><code>中缀表达式</code> 可以使用树状结构表示，例如，以下面的树状结构表达 <code>4 * x * ( 2 * x + a ) - c</code>：<br><br> <img src="https://images2.imgbox.com/b5/58/6COkv6WX_o.png" alt="" width="180"><br> 也可以使用语法公式表示，<br><br> <img src="https://images2.imgbox.com/84/47/rML3VQUQ_o.png" alt="在这里插入图片描述" width="260"><br> 也可以使用递归图示表示，<br><br> <img src="https://images2.imgbox.com/f7/90/UCPkWeJj_o.png" alt="在这里插入图片描述" width="300"></p> 
<br> 
<h5><a id="_250"></a>后缀表达式</h5> 
<h6><a id="_251"></a>概念</h6> 
<p><code>后缀表达式</code> 的特点是：</p> 
<ul><li>运算符在后面</li><li>不需要括号</li></ul> 
<p><code>后缀表达式</code> 可以使用树状结构表示，例如，以下面的树状结构表达 <code>4x * 2x * a+ *c -</code>：</p> 
<p><img src="https://images2.imgbox.com/a0/7d/ePimreZg_o.png" alt="在这里插入图片描述" width="180"><br> <br></p> 
<h6><a id="_261"></a>示例</h6> 
<h6><a id="_262"></a>对后缀表达式求值</h6> 
<p>假设待处理后缀表达式为 <code>34 45 * 5 6 + 7 + / +</code>。</p> 
<p>使用 <code>栈</code> 的概念对该后缀表达式进行求值的算法为：<br> 依次顺序读入表达式的符号序列（假设以 <code>=</code> 作为输入序列的结束 ），并根据读入的元素符号逐一分析：</p> 
<ol><li>当遇到的是一个操作数，则压入栈顶；</li><li>当遇到的是一个运算符，则从栈中两次取出栈顶，按照运算符对这两个操作数进行计算。然后将计算结果压入栈顶。</li></ol> 
<p>如此继续，直到遇到符号 <code>=</code>，这时栈顶的值就是输入表达式的值。</p> 
<p>以代码来表示上述算法思想，即：</p> 
<pre><code class="prism language-cpp"><span class="token keyword">class</span> <span class="token class-name">Calculator</span><span class="token punctuation">{<!-- --></span>
<span class="token keyword">private</span><span class="token operator">:</span>
    Stack<span class="token operator">&lt;</span><span class="token keyword">double</span><span class="token operator">&gt;</span> s<span class="token punctuation">;</span>                                    <span class="token comment">// 这个栈用于压入、保存操作数</span>
    <span class="token keyword">bool</span> <span class="token function">GetTwoOperands</span><span class="token punctuation">(</span><span class="token keyword">double</span><span class="token operator">&amp;</span> opd1<span class="token punctuation">,</span> <span class="token keyword">double</span><span class="token operator">&amp;</span> opd2<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 操作1：从栈顶弹出两个操作数 opd1 和 opd2</span>
    <span class="token keyword">void</span> <span class="token function">Compute</span><span class="token punctuation">(</span><span class="token keyword">char</span> op<span class="token punctuation">)</span><span class="token punctuation">;</span>                              <span class="token comment">// 操作2：取两个操作数，并按op对两个操作数进行计算</span>
<span class="token keyword">public</span><span class="token operator">:</span>
    <span class="token function">Calculator</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span><span class="token punctuation">}</span><span class="token punctuation">;</span>                                 <span class="token comment">// 创建计算器实例，开辟一个空栈</span>
    <span class="token keyword">void</span> <span class="token function">Run</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                                     <span class="token comment">// 读入后缀表达式，遇 "=" 符号结束</span>
    <span class="token keyword">void</span> <span class="token function">Clear</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                                   <span class="token comment">// 清除计算器，为下一次计算做准备</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">ELEM</span><span class="token operator">&gt;</span>
<span class="token keyword">bool</span> <span class="token class-name">Calculator</span><span class="token operator">&lt;</span>ELEM<span class="token operator">&gt;</span><span class="token double-colon punctuation">::</span><span class="token function">GetTwoOperands</span><span class="token punctuation">(</span>ELEM<span class="token operator">&amp;</span> opnd1<span class="token punctuation">,</span> ELEM<span class="token operator">&amp;</span> opnd2<span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>S<span class="token punctuation">.</span><span class="token function">IsEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>                                               <span class="token comment">// 空栈。则无法按预期取出2个操作数。</span>
        cerr <span class="token operator">&lt;&lt;</span> <span class="token string">"Missing Operand!"</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
        <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    opnd1 <span class="token operator">=</span> S<span class="token punctuation">.</span><span class="token function">Pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                                                <span class="token comment">// 取出右操作数</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>S<span class="token punctuation">.</span><span class="token function">IsEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>                                               <span class="token comment">// 取出右操作数后，栈空，则无法取到左操作数。</span>
        cerr <span class="token operator">&lt;&lt;</span> <span class="token string">"Missing Operand!"</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
        <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    opnd2 <span class="token operator">=</span> S<span class="token punctuation">.</span><span class="token function">Pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                                                <span class="token comment">// 取出左操作数</span>
    <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">ELEM</span><span class="token operator">&gt;</span> <span class="token keyword">void</span> <span class="token class-name">Calculator</span><span class="token operator">&lt;</span>ELEM<span class="token operator">&gt;</span><span class="token double-colon punctuation">::</span><span class="token function">Compute</span><span class="token punctuation">(</span><span class="token keyword">char</span> op<span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
    <span class="token keyword">bool</span> result<span class="token punctuation">;</span> ELEM operand1<span class="token punctuation">,</span> operand2<span class="token punctuation">;</span>
    result <span class="token operator">=</span> <span class="token function">GetTwoOperands</span><span class="token punctuation">(</span>operand1<span class="token punctuation">,</span> operand2<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>result <span class="token operator">==</span> <span class="token boolean">true</span><span class="token punctuation">)</span>
        <span class="token keyword">switch</span><span class="token punctuation">(</span>op<span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
        <span class="token keyword">case</span> <span class="token char">'+'</span><span class="token operator">:</span> S<span class="token punctuation">.</span><span class="token function">Push</span><span class="token punctuation">(</span>operand2 <span class="token operator">+</span> operand1<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token keyword">break</span><span class="token punctuation">;</span>
        <span class="token keyword">case</span> <span class="token char">'-'</span><span class="token operator">:</span> S<span class="token punctuation">.</span><span class="token function">Push</span><span class="token punctuation">(</span>operand2 <span class="token operator">-</span> operand1<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token keyword">break</span><span class="token punctuation">;</span>
        <span class="token keyword">case</span> <span class="token char">'*'</span><span class="token operator">:</span> S<span class="token punctuation">.</span><span class="token function">Push</span><span class="token punctuation">(</span>operand2 <span class="token operator">*</span> operand1<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token keyword">break</span><span class="token punctuation">;</span>
        <span class="token keyword">case</span> <span class="token char">'/'</span><span class="token operator">:</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>operand1 <span class="token operator">==</span> <span class="token number">0.0</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
            cerr <span class="token operator">&lt;&lt;</span> <span class="token string">"Divide by 0!"</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
            S<span class="token punctuation">.</span><span class="token function">ClearStack</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span><span class="token keyword">else</span> S<span class="token punctuation">.</span><span class="token function">Push</span><span class="token punctuation">(</span>operand2 <span class="token operator">/</span> operand1<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword">break</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token keyword">else</span> S<span class="token punctuation">.</span><span class="token function">ClearStack</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">ELEM</span><span class="token operator">&gt;</span> <span class="token keyword">void</span> <span class="token class-name">Calculator</span><span class="token operator">&lt;</span>ELEM<span class="token operator">&gt;</span><span class="token double-colon punctuation">::</span><span class="token function">Run</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
    <span class="token keyword">char</span> c<span class="token punctuation">;</span> ELEM newoperand<span class="token punctuation">;</span>
    <span class="token keyword">while</span> <span class="token punctuation">(</span>cin <span class="token operator">&gt;&gt;</span> c<span class="token punctuation">,</span> c<span class="token operator">!=</span><span class="token char">'='</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
        <span class="token keyword">switch</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
        <span class="token keyword">case</span> <span class="token char">'+'</span><span class="token operator">:</span> <span class="token keyword">case</span> <span class="token char">'-'</span><span class="token operator">:</span> <span class="token keyword">case</span> <span class="token char">'*'</span><span class="token operator">:</span> <span class="token keyword">case</span> <span class="token char">'/'</span><span class="token operator">:</span>            <span class="token comment">// 如果碰到的是+-*/这种操作符，则调用compute运算</span>
            <span class="token function">Compute</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword">break</span><span class="token punctuation">;</span>
        <span class="token keyword">default</span><span class="token operator">:</span>                                           <span class="token comment">// 如果碰到的不是+-*/这种运算符，把c这种char类型数据放回栈内并再次读取newoperand这种ELEM</span>
            cin<span class="token punctuation">.</span><span class="token function">putback</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span><span class="token punctuation">;</span> cin <span class="token operator">&gt;&gt;</span> newoperand<span class="token punctuation">;</span>
            S<span class="token punctuation">.</span><span class="token function">Push</span><span class="token punctuation">(</span>newoperand<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword">break</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>S<span class="token punctuation">.</span><span class="token function">IsEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
        cout <span class="token operator">&lt;&lt;</span> S<span class="token punctuation">.</span><span class="token function">Pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>                           <span class="token comment">// 打印出最后结果</span>
<span class="token punctuation">}</span>
</code></pre> 
<br> 
<h6><a id="_337"></a>中缀表达式转换为后缀表达式</h6> 
<p>对后缀表达式求值时，向栈内存操作数；</p> 
<p>转换中缀表达式为后缀表达式时，向栈内存操作符。因为所有的操作数载顺序上并没有变化，但是操作符的顺序有变化。</p> 
<ul><li>当输入是操作数，直接输出到后缀表达式序列；</li><li>当输入是左括号时，直接压栈；</li><li>当输入是运算符时， 
  <ul><li>while 
    <ul><li>if (栈非空 and 栈顶不是左括号 and 输入运算符的优先级 &lt;= 栈顶运算符的优先级) 时，将当前栈顶元素弹栈，输出到后缀表达式序列中；<br> 并将输入运算符压栈；</li><li>else 把输入的运算符压栈</li></ul> </li></ul> </li></ul> 
<blockquote> 
 <p>输入运算符的优先级别&lt;=栈顶运算符的优先级，比如输入运算符 <code>+</code>、栈顶运算符 <code>*</code>，则将栈顶 <code>*</code> 弹栈。</p> 
</blockquote> 
<ul><li>当输入是右括号时，先判断栈是否为空： 
  <ul><li>若栈为空，即无任何左括号已在栈内，则清栈退出；</li><li>若栈非空，则把栈中的元素依次弹出： 
    <ul><li>遇到第一个左括号为止，将弹出的元素输出到后缀表达式的序列中（弹出的开括号不放到序列中）</li><li>若未遇到开括号，说明括号不匹配，则清栈退出；</li></ul> </li></ul> </li><li>当中缀表达式的符号序列全部读入时，若栈内仍有元素，则把它们全部依次弹出，都放到后缀表达式序列尾部； 
  <ul><li>若弹出的元素遇到开括号，说明括号不匹配，需要做错误异常处理。</li></ul> </li></ul> 
<br> 
<h4><a id="_359"></a>递归</h4> 
<h5><a id="_360"></a>概念</h5> 
<h6><a id="_361"></a>递归、迭代</h6> 
<p><code>递归</code> 和 <code>迭代</code> 的异同点：</p> 
<ul><li>相同点<br> 从小规模的相同问题来求解大规模问题</li><li>不同点 
  <ul><li><code>迭代</code> 先从小问题入手，然后自底向上组合成大问题</li><li><code>递归</code> 先从大问题入手，然后自顶向下，对大问题进行分解</li></ul> </li></ul> 
<p><code>递归</code> 更接近人类思维方式。因此，涉及递归算法比设计非递归算法往往更容易，大多数编程语言支持递归，许多函数式编程语言更是直接以递归为基础。<br> <code>递归</code> 在完成问题定义时，基本也同时完成了问题求解。</p> 
<br> 
<h6><a id="_374"></a>递归函数</h6> 
<p>在计算机中，我们通常以函数的方式对递归问题进行定义与求解。所谓 <code>递归函数</code>，指的是会直接或间接调用自身的函数。<br> <code>递归函数</code> 具有2个要素：一是基本的边界情形（ 一般是规模小到不需要依赖子问题、可以直接求解的情形 ），二是递归规则（ 决定如何将一个递归问题转化为规模更小的子问题 ）。</p> 
<p>计算机程序是一组顺序执行的指令序列。那么怎样用指令序列运行一个 <code>递归函数</code> 呢？<br> 先看程序的内存分布，如下图：</p> 
<p><img src="https://images2.imgbox.com/a9/1c/nBbo2uHr_o.png" alt="" width="220"><br> 内存被分为好几个区域，比如有内核、动态链接库、存放代码的只读区、存放全局变量的可读写区等等。<br> 程序运行时，有两个区域的内存是不固定的：</p> 
<ul><li>栈<br> 主要用于函数调用</li><li>堆<br> 用于分配动态内存空间</li></ul> 
<p><code>递归函数</code> 的相关操作主要发生在 <code>栈</code> 内。<br> 在函数调用栈里，元素是一种被称为栈帧的数据结构，每个帧对应1次函数调用，保存当次函数调用时传入的参数、函数返回地址以及局部变量。<br> 比如，调用阶乘函数来求4的阶乘，如下：</p> 
<p><img src="https://images2.imgbox.com/50/fc/1Y0dP3fv_o.png" alt="在这里插入图片描述" width="180"><br> 有一个阶乘4对应的帧；有一个阶乘3对应的帧。每个帧内保存了此次函数调用时的相关信息，比如传入的参数、函数的返回地址以及局部变量等。<br> 计算机中的函数调用与退出主要就是对调用栈中的帧进行操作：</p> 
<ul><li>函数调用时 
  <ul><li>计算机在栈中压入一个帧 
    <ul><li>压入调用参数</li><li>压入返回地址</li><li>为局部变量分配空间</li><li>其它信息（寄存器信息）</li></ul> </li><li>计算机通过指令跳转到被调用函数开始的位置，开始执行</li></ul> </li><li>函数退出时 
  <ul><li>记录返回值</li><li>释放栈帧（局部变量、返回地址、调用函数及其它信息）</li><li>根据返回地址，跳回调用前位置继续执行</li></ul> </li></ul> 
<p><code>递归函数</code> 的运行时的空间、时间开销分析如下：</p> 
<ul><li>空间 
  <ul><li>在每次调用时都需要创建栈帧并进行相应操作。在现实中，许多复杂函数的栈帧都很大，当调用次数很多时可能会把栈的空间全部用完，在一些系统上甚至可能会越界到动态链接库的区域，导致栈溢出的安全风险。</li></ul> </li><li>时间 
  <ul><li>栈操作需要消耗计算资源</li><li>函数调用与退出时的跳转指令相比于其他正常指令的开销也是较大的</li></ul> </li></ul> 
<p>因此，如果能将递归函数转换为非递归函数，就可以减少程序运行时的开销。</p> 
<br> 
<h6><a id="_419"></a>尾递归</h6> 
<p><code>尾递归</code> 指的是函数仅有一次自身调用，且该调用时函数退出前的最后一个操作。</p> 
<p>举例如下：</p> 
<pre><code class="prism language-cpp"><span class="token keyword">long</span> <span class="token function">fact</span><span class="token punctuation">(</span><span class="token keyword">long</span> n<span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>n<span class="token operator">&lt;=</span><span class="token number">1</span><span class="token punctuation">)</span>
        <span class="token keyword">return</span> <span class="token number">1</span><span class="token punctuation">;</span>
    <span class="token keyword">else</span>
        <span class="token keyword">return</span> n <span class="token operator">*</span> <span class="token function">fact</span><span class="token punctuation">(</span>n<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>虽然上面的阶乘递归函数只有一次对自身的调用，但是该调用并不是退出前的最后一个操作。因为在调用之后，还有一个乘法操作。所以该递归阶乘并非尾递归。</p> 
<pre><code class="prism language-cpp"><span class="token keyword">long</span> <span class="token function">fact_tail_rec</span><span class="token punctuation">(</span><span class="token keyword">long</span> n<span class="token punctuation">,</span> <span class="token keyword">long</span> product<span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>n<span class="token operator">&lt;=</span><span class="token number">1</span><span class="token punctuation">)</span>
        <span class="token keyword">return</span> product<span class="token punctuation">;</span>
    <span class="token keyword">else</span>
        <span class="token keyword">return</span> <span class="token function">fact_tail_rec</span><span class="token punctuation">(</span>n<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span> product <span class="token operator">*</span> n<span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>上面的 <code>尾递归</code> 函数多了一个参数用来保存乘积，则原先的乘法结果可以以参数的形式在调用前进行传递，而不再需要在函数内进行乘法操作。这样，自身调用就时函数退出前的最后一个操作，因此，它是一个 <code>尾递归</code> 函数。</p> 
<p><code>尾递归</code> 可以很容易将 <code>递归函数</code> 转化为 <code>非递归函数</code>。<code>尾递归</code> 的本质是将单次计算的结果缓存起来以参数的形式传递给下一次调用，因此我们可以很容易地使用循环迭代的方式来保存这个累计的结果。</p> 
<p>在 <code>递归函数</code> 转化为 <code>非递归函数</code> 之后，就可以消除栈开销与函数调用的开销。相比于原先线性增长的栈空间，转换之后只需要常数空间即可。</p> 
<p>许多现代编程语言支持对 <code>尾递归</code> 的优化：</p> 
<ul><li>编译器/解释器<br> <code>GCC</code>、<code>LLVM</code> / <code>Clang</code>、<code>Intel</code> 编译器、<code>Java</code> 虚拟机</li><li>函数式编程语言<br> <code>LISP</code>、<code>Scheme</code>、<code>Scala</code>、<code>Haskell</code>、<code>Erlang</code></li></ul> 
<br> 
<h5><a id="_455"></a>示例</h5> 
<h6><a id="_456"></a>阶乘函数的调用栈</h6> 
<pre><code class="prism language-cpp"><span class="token keyword">long</span> <span class="token function">fact</span><span class="token punctuation">(</span><span class="token keyword">long</span> n<span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>n<span class="token operator">&lt;</span><span class="token number">1</span><span class="token punctuation">)</span>
        <span class="token keyword">return</span> <span class="token number">1</span><span class="token punctuation">;</span>
    <span class="token keyword">else</span>
        <span class="token keyword">return</span> n<span class="token operator">*</span><span class="token function">fact</span><span class="token punctuation">(</span>n<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
        <span class="token keyword">int</span> x<span class="token operator">=</span><span class="token number">4</span><span class="token punctuation">;</span>
        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d\n"</span><span class="token punctuation">,</span> <span class="token function">fact</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> 
<p><img src="https://images2.imgbox.com/2f/d5/IYxClWJH_o.png" alt="在这里插入图片描述" width="350"><br> <br></p> 
<h6><a id="_474"></a>递归到非递归的转换</h6> 
<p>背景：假如有n件物品，物品i的重量为w[i]。如果限定每种物品，要么完全放进背包、要么不放进背包，即物品是不可分割的。</p> 
<p>问题：能否从这n件物品中选择若干件放入背包，使其重量之和恰好为s。</p> 
<br> 
<h5><a id="_481"></a>通用的机械转换步骤</h5> 
<ol><li>定义栈帧，建立调用帧；</li><li>在栈中压入原始问题的帧（ rd = 0 ）;</li><li>根据递归调用数 t，将程序划分为 t+1 个区域；</li><li>创建（t+2）个标签，逐区域翻译（除 return 语句、递归调用）;<br> （ t+2 ）个标签为（t+1）个区域的边界</li><li>用 goto 实现递归调用<br> 形式 “push stack；goto label 0”，第 i 个调用的 rd=i；</li><li>用 goto 实现 return 语句；<br> 将所有 “return” 替换为 “goto label (t+1)”</li><li>在标签 t+1 后添加递归出口<br> 使用 “switch” 语句，根据栈顶的 rd 值判断继续执行的标签</li></ol> 
<br> 
<h2><a id="_496"></a>队列</h2> 
<h3><a id="_497"></a>概念</h3> 
<p><code>队列</code> 是一种限制访问点的 <code>线性表</code>，先进先出（ <code>First In First Out</code> ）。</p> 
<ul><li>按照到达的顺序来释放元素；</li><li>所有的插入在表的一端进行，所有的删除都在表的另一端进行；</li></ul> 
<p><code>队列</code> 的主要元素有 <code>队头</code>（ <code>front</code> ）、<code>队尾</code>（ <code>rear</code> ）。</p> 
<p><code>队列</code> 的主要操作：</p> 
<ul><li>入队列（ <code>enQueue</code> ）</li><li>出队列（ <code>deQueue</code> ）</li><li>取队首元素（ <code>getFront</code> ）</li><li>判断队列是否为空（ <code>isEmpty</code> ）</li></ul> 
<p><code>队列</code> 的抽象数据类型如下：</p> 
<pre><code class="prism language-cpp"><span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">T</span><span class="token operator">&gt;</span> <span class="token keyword">class</span> <span class="token class-name">Queue</span><span class="token punctuation">{<!-- --></span>
<span class="token keyword">public</span><span class="token operator">:</span>                                 <span class="token comment">// 队列的运算集</span>
    <span class="token keyword">void</span> <span class="token function">clear</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                       <span class="token comment">// 清空队列</span>
    <span class="token keyword">bool</span> <span class="token function">enQueue</span><span class="token punctuation">(</span><span class="token keyword">const</span> T item<span class="token punctuation">)</span><span class="token punctuation">;</span>         <span class="token comment">// 将item插入队尾。成功则返回真，否则则返回假</span>
    <span class="token keyword">bool</span> <span class="token function">deQueue</span><span class="token punctuation">(</span>T <span class="token operator">&amp;</span> item<span class="token punctuation">)</span><span class="token punctuation">;</span>             <span class="token comment">// 返回队头元素并将其从队列中删除，成功则返回真</span>
    <span class="token keyword">bool</span> <span class="token function">getFront</span><span class="token punctuation">(</span>T <span class="token operator">&amp;</span> item<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment">// 返回队头元素，但不删除，成功则返回真</span>
    <span class="token keyword">bool</span> <span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                     <span class="token comment">// 返回真，若队列已空</span>
    <span class="token keyword">bool</span> <span class="token function">isFull</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                      <span class="token comment">// 返回真，若队列已满</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre> 
<br> 
<h3><a id="_525"></a>实现</h3> 
<p><code>队列</code> 的物理实现有2种，1种称为 <code>顺序队列</code>（ <code>Array-based Stack</code> ），另1种称为 <code>链式队列</code>（ <code>Linked Stack</code> ）。</p> 
<br> 
<h4><a id="_530"></a>顺序队列</h4> 
<p><img src="https://images2.imgbox.com/0b/94/T30Qkflw_o.png" alt="在这里插入图片描述" width="300"><br> 用 <code>向量</code> 存储队列元素，用两个变量分别指向队列的前端（ <code>front</code> ）和尾端（ <code>rear</code> ）。</p> 
<ul><li><code>front</code>：指向当前待出队的元素位置（地址）</li><li><code>rear</code>：指向当前待入队的元素位置（地址）</li></ul> 
<p>然而，这种 <code>顺序队列</code> 会有 <code>溢出</code> 的问题 ——</p> 
<ul><li><code>上溢</code><br> 当 <code>队列</code> 满时，再做进队操作</li><li><code>下溢</code><br> 当 <code>队列</code> 空时，再做删除操作</li><li><code>假溢出</code><br> 当 <code>rear = mSize - 1</code> 时，再作插入运算就会产出 <code>溢出</code>。如果这时 <code>队列</code> 的前端还有许多空位置，这种现象称为 <code>假溢出</code></li></ul> 
<p>为了避免 <code>溢出</code> 的出现，可以将 <code>顺序队列</code> 的首尾相连来变成一个 <code>循环队列</code>。</p> 
<br> 
<h5><a id="_548"></a>类定义</h5> 
<pre><code class="prism language-cpp"><span class="token keyword">class</span> <span class="token class-name">arrQueue</span><span class="token operator">:</span><span class="token base-clause"><span class="token keyword">public</span> <span class="token class-name">Queue</span><span class="token operator">&lt;</span><span class="token class-name">T</span><span class="token operator">&gt;</span></span><span class="token punctuation">{<!-- --></span>
<span class="token keyword">private</span><span class="token operator">:</span>
    <span class="token keyword">int</span> mSize<span class="token punctuation">;</span>                          <span class="token comment">// 声明队列的数组大小</span>
    <span class="token keyword">int</span> front<span class="token punctuation">;</span>                          <span class="token comment">// 表示队头所在位置的下标</span>
    <span class="token keyword">int</span> rear<span class="token punctuation">;</span>                           <span class="token comment">// 表示待入队元素所在位置的下标</span>
    T   <span class="token operator">*</span>qu<span class="token punctuation">;</span>                            <span class="token comment">// 存放类型为T的队列元素的数组</span>
<span class="token keyword">public</span><span class="token operator">:</span>
    <span class="token function">arrQueue</span><span class="token punctuation">(</span><span class="token keyword">int</span> size<span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>                 <span class="token comment">// 创建队列的实例</span>
        mSize <span class="token operator">=</span> size <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>               <span class="token comment">// 浪费一个存储空间，以此区别空队列和满队列</span>
        qu <span class="token operator">=</span> <span class="token keyword">new</span> T <span class="token punctuation">[</span>mSize<span class="token punctuation">]</span><span class="token punctuation">;</span>
        front <span class="token operator">=</span> rear <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token operator">~</span><span class="token function">arrQueue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>                        <span class="token comment">// 消除该实例，并释放其空间</span>
        <span class="token keyword">delete</span><span class="token punctuation">[</span><span class="token punctuation">]</span> qu<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">bool</span> <span class="token class-name">arrQueue</span><span class="token operator">&lt;</span>T<span class="token operator">&gt;</span><span class="token double-colon punctuation">::</span><span class="token function">enQueue</span><span class="token punctuation">(</span><span class="token keyword">const</span> T item<span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span><span class="token comment">// item入队，插入队尾</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">(</span>rear <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">%</span> mSize <span class="token operator">==</span> front<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span> <span class="token comment">// rear指针+1，再对mSize取模，如果等于front，说明队列已满</span>
        cout <span class="token operator">&lt;&lt;</span> <span class="token string">"队列已满，溢出"</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
        <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    qu<span class="token punctuation">[</span>rear<span class="token punctuation">]</span> <span class="token operator">=</span> item<span class="token punctuation">;</span>
    rear <span class="token operator">=</span> <span class="token punctuation">(</span>rear <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token operator">%</span>mSize<span class="token punctuation">;</span>            <span class="token comment">// 循环后继，将rear指针后移一位</span>
    <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">bool</span> <span class="token class-name">arrQueue</span><span class="token operator">&lt;</span>T<span class="token operator">&gt;</span><span class="token double-colon punctuation">::</span><span class="token function">deQueue</span><span class="token punctuation">(</span>T<span class="token operator">&amp;</span> item<span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>     <span class="token comment">// 返回队头元素并从队列中删除</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>front <span class="token operator">==</span> rear<span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>                 <span class="token comment">// front指针等于rear指针，说明队列为空，不允许删除元素</span>
        cout <span class="token operator">&lt;&lt;</span> <span class="token string">"队列为空"</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
        <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    item <span class="token operator">=</span> qu<span class="token punctuation">[</span>front<span class="token punctuation">]</span><span class="token punctuation">;</span>                   <span class="token comment">// item为队首元素</span>
    front <span class="token operator">=</span> <span class="token punctuation">(</span>front <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token operator">%</span>mSize<span class="token punctuation">;</span>          <span class="token comment">// 循环后继，将front指针后移一位</span>
    <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<br> 
<h4><a id="_590"></a>链式队列</h4> 
<p><code>链式队列</code> 的本质是 <code>单链表</code>。用 <code>单链表</code> 方式存储，链接指针的方向是从队列的前端向尾端链接。</p> 
<p><img src="https://images2.imgbox.com/7d/46/SwQ7gwGb_o.png" alt="在这里插入图片描述" width="350"><br> 用 <code>front</code> 指向 <code>单链表</code> 的队首。用 <code>rear</code> 指针指向 <code>单链表</code> 的队尾。<br> 我们把入队列和出队列限制在队首和队尾这两部分。不允许在其他部分进行操作。那么这其实就是一个 <code>链式队列</code>。</p> 
<br> 
<h5><a id="_599"></a>类定义</h5> 
<pre><code class="prism language-cpp"><span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">T</span><span class="token operator">&gt;</span>
<span class="token keyword">class</span> <span class="token class-name">lnkQueue</span><span class="token operator">:</span><span class="token base-clause"><span class="token keyword">public</span> <span class="token class-name">Queue</span><span class="token operator">&lt;</span><span class="token class-name">T</span><span class="token operator">&gt;</span></span><span class="token punctuation">{<!-- --></span>
<span class="token keyword">private</span><span class="token operator">:</span>
    <span class="token keyword">int</span> size<span class="token punctuation">;</span>                                       <span class="token comment">// 队列中当前元素的个数</span>
    Link<span class="token operator">&lt;</span>T<span class="token operator">&gt;</span><span class="token operator">*</span> front<span class="token punctuation">;</span>                                 <span class="token comment">// 表示队头的指针</span>
    Link<span class="token operator">&lt;</span>T<span class="token operator">&gt;</span><span class="token operator">*</span> rear<span class="token punctuation">;</span>                                  <span class="token comment">// 表示队尾的指针</span>
<span class="token keyword">public</span><span class="token operator">:</span>
    <span class="token function">lnkQueue</span><span class="token punctuation">(</span><span class="token keyword">int</span> size<span class="token punctuation">)</span><span class="token punctuation">;</span>                             <span class="token comment">// 创建队列的实例</span>
    <span class="token operator">~</span><span class="token function">lnkQueue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                                    <span class="token comment">// 消除该实例，并释放其空间</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">bool</span> <span class="token function">enQueue</span><span class="token punctuation">(</span><span class="token keyword">const</span> T item<span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>                         <span class="token comment">// item入队，插入队尾</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>rear <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>                              <span class="token comment">// 空队列</span>
            front <span class="token operator">=</span> rear <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token generic-function"><span class="token function">Link</span><span class="token generic class-name"><span class="token operator">&lt;</span>T<span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span>item<span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">else</span><span class="token punctuation">{<!-- --></span>                                           <span class="token comment">// 添加新元素</span>
        rear <span class="token operator">-&gt;</span> next <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token generic-function"><span class="token function">Link</span><span class="token generic class-name"><span class="token operator">&lt;</span>T<span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span>item<span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token comment">// rear的next指针指向新元素</span>
        rear <span class="token operator">=</span> rear <span class="token operator">-&gt;</span> next<span class="token punctuation">;</span>                        <span class="token comment">// rear指针指向最后一个元素</span>
    <span class="token punctuation">}</span>
    size <span class="token operator">++</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">bool</span> <span class="token function">deQueue</span><span class="token punctuation">(</span>T<span class="token operator">*</span> item<span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>                              <span class="token comment">// 返回队头元素并从队列中删除</span>
    Link<span class="token operator">&lt;</span>T<span class="token operator">&gt;</span> <span class="token operator">*</span>tmp<span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>size <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>                                 <span class="token comment">// 队列为空，没有元素可出队</span>
        cout <span class="token operator">&lt;&lt;</span> <span class="token string">"队列为空"</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
        <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token operator">*</span>item <span class="token operator">=</span> front <span class="token operator">-&gt;</span> data<span class="token punctuation">;</span>                          <span class="token comment">// 将front指针指向的队首元素传给item</span>
    tmp <span class="token operator">=</span> front<span class="token punctuation">;</span>                                    <span class="token comment">// tmp指针记录front的位置</span>
    front <span class="token operator">=</span> front <span class="token operator">-&gt;</span> next<span class="token punctuation">;</span>                          <span class="token comment">// 将front指针指向原队首的下一个元素</span>
    <span class="token keyword">delete</span> tmp<span class="token punctuation">;</span>                                     <span class="token comment">// 删除tmp</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>front <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span>                              <span class="token comment">// 如果front是空的，则rear也为空</span>
        rear <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>
    size <span class="token operator">--</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<br> 
<h4><a id="_VS__643"></a>顺序队列 V.S 链式队列</h4> 
<ul><li>空间效率 
  <ul><li><code>顺序队列</code> 需要固定的存储空间；</li><li><code>链式队列</code> 可以满足大小无法估计的情况；</li></ul> </li></ul> 
<br> 
<h3><a id="_650"></a>应用</h3> 
<p><code>队列</code> 满足先来先服务特性的应用，作为其数据组织方式或中间数据结构：</p> 
<ul><li>调度或缓冲 
  <ul><li>消息缓冲器</li><li>邮件缓冲器</li><li>计算机硬设备之间的通信也需要队列作为数据缓冲</li><li>操作系统的资源管理</li></ul> </li><li>宽度优先搜索</li></ul> 
<br> 
<h4><a id="_661"></a>宽度优先搜索</h4> 
<h5><a id="_662"></a>示例：人狼羊菜过河</h5> 
<h6><a id="_663"></a>初步分析</h6> 
<ul><li>问题抽象</li></ul> 
<p>“人狼羊菜” 乘船过河。只有人能撑船，船只有两个位置（包括人）。狼羊、羊菜不能在没有人时共处。</p> 
<hr> 
<ul><li>求解方案</li></ul> 
<p>求解该问题最简单的方法是使用试探法，即一步一步进行试探，每一步都搜索所有可能的选择，对前一步合适的选择再考虑下一步的各种方案。</p> 
<p>用计算机实现上述求解的搜索过程可以采用两种不同的策略：</p> 
<ul><li>队列 
  <ul><li>宽度优先搜索<br> 搜索该步的所有可能状态，再进一步考虑后面的各种情况</li></ul> </li><li>栈 
  <ul><li>深度优先搜索<br> 沿某一状态走下去，不行再回头</li></ul> </li></ul> 
<p>假定采用宽度优先搜索解决农夫过河问题：</p> 
<ul><li>采用队列作辅助结构，把下一步所有可能达到的状态都放在队列中，然后顺序取出对其分别处理。</li><li>由于队列的操作按照先进先出原则，因此只有前一步的所有情况都处理完之后才能进入下一步。</li></ul> 
<p>先对数据进行抽象，对每个角色的位置进行描述。人、狼、羊和菜，四个目标依次各用一位，目标在起始岸位置 <code>0</code>、目标岸 <code>1</code>。<br> <code>0110</code> 表示农夫、白菜在起始岸，而狼、羊在目标岸。此状态为不安全状态。<br> <code>1000</code> （ 0x08 ）表示人在目标岸，而狼、羊、菜在起始岸。<br> <code>1111</code> （0x0F）表示人、狼、羊、菜都抵达目标岸。</p> 
<p>如何从上述状态中得到每个角色所在位置？</p> 
<p><img src="https://images2.imgbox.com/7a/e1/olwepnGt_o.png" alt="在这里插入图片描述" width="160"></p> 
<pre><code class="prism language-cpp"><span class="token keyword">bool</span> <span class="token function">farmer</span><span class="token punctuation">(</span><span class="token keyword">int</span> status<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span><span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>status <span class="token operator">&amp;</span> <span class="token number">0x08</span><span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span>

<span class="token keyword">bool</span> <span class="token function">wolf</span><span class="token punctuation">(</span><span class="token keyword">int</span> status<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span><span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>status <span class="token operator">&amp;</span> <span class="token number">0x04</span><span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span>

<span class="token keyword">bool</span> <span class="token function">goat</span><span class="token punctuation">(</span><span class="token keyword">int</span> status<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span><span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>status <span class="token operator">&amp;</span> <span class="token number">0x02</span><span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span>

<span class="token keyword">bool</span> <span class="token function">cabbage</span><span class="token punctuation">(</span><span class="token keyword">int</span> status<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span><span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>status <span class="token operator">&amp;</span> <span class="token number">0x01</span><span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span>
</code></pre> 
<p>函数返回值为真，表示所考察人或物在目标岸。否则，所考察人或物在起始岸；</p> 
<p>在用以上方法拿到每个角色的所在位置之后可以对安全状态进行判断：</p> 
<pre><code class="prism language-cpp"><span class="token keyword">bool</span> <span class="token function">safe</span><span class="token punctuation">(</span><span class="token keyword">int</span> status<span class="token punctuation">)</span>                   <span class="token comment">// 返回true 安全；返回false，不安全</span>
<span class="token punctuation">{<!-- --></span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token function">goat</span><span class="token punctuation">(</span>status<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token function">cabbage</span><span class="token punctuation">(</span>status<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span><span class="token function">goat</span><span class="token punctuation">(</span>status<span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token function">farmer</span><span class="token punctuation">(</span>status<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>  <span class="token comment">// 羊和白菜共处，但是人不在</span>
        <span class="token keyword">return</span><span class="token punctuation">(</span><span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token function">goat</span><span class="token punctuation">(</span>status<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token function">wolf</span><span class="token punctuation">(</span>status<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span><span class="token function">goat</span><span class="token punctuation">(</span>status<span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token function">farmer</span><span class="token punctuation">(</span>status<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>     <span class="token comment">// 狼和羊共处，但是人不在</span>
        <span class="token keyword">return</span><span class="token punctuation">(</span><span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<br> 
<h6><a id="_724"></a>最终分析</h6> 
<ul><li>问题抽象</li></ul> 
<p>从状态 <code>0000</code>（整数0）出发，寻找全部由安全状态构成的状态序列，以 <code>1111</code>（整数15）为最终目标。<br> 状态序列中每个状态都可以从前一状态通过农夫（可以带一样东西）划船过河的动作到达。<br> 序列中不能出现重复状态。</p> 
<hr> 
<ul><li>算法设计</li></ul> 
<p>定义一个整数队列 <code>moveTo</code>，它的每个元素表示一个可以安全到达的中间状态。<br> 还需要定义一个数据结构记录已被访问过的各个状态，以及已被发现的能够到达当前这个状态的路径。</p> 
<ul><li>用 <code>顺序表</code> route 的第i个元素记录状态i是否已被访问过</li><li>若route[i] 已被访问过，则在这个 <code>顺序表</code> 元素中记入前驱状态值，-1表示未被访问</li><li>route的大小（长度）为16</li></ul> 
<hr> 
<ul><li>算法实现</li></ul> 
<pre><code class="prism language-cpp"><span class="token keyword">void</span> <span class="token function">solve</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
    <span class="token keyword">int</span> movers<span class="token punctuation">,</span> i<span class="token punctuation">,</span> location<span class="token punctuation">,</span> newlocation<span class="token punctuation">;</span>
    vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span> <span class="token function">route</span><span class="token punctuation">(</span>END<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    queue<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span> moveTo<span class="token punctuation">;</span>                              <span class="token comment">// 定义初始队列，看它moveTo到哪些队列上去</span>
    moveTo<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token number">0x00</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    route<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">!</span>moveTo<span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> route<span class="token punctuation">[</span><span class="token number">15</span><span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>         <span class="token comment">//</span>
    status <span class="token operator">=</span> moveTo<span class="token punctuation">.</span><span class="token function">front</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                        <span class="token comment">// 拿到moveTo的front指针</span>
    moveTo<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                                   <span class="token comment">// 把当前状态pop出来</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span>movers <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> movers <span class="token operator">&lt;=</span> <span class="token number">8</span><span class="token punctuation">;</span> movers <span class="token operator">&lt;&lt;</span> <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>    <span class="token comment">// 农夫总是在移动。movers指针逐渐左移</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">farmer</span><span class="token punctuation">(</span>status<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token punctuation">(</span><span class="token keyword">bool</span><span class="token punctuation">)</span><span class="token punctuation">(</span>status <span class="token operator">&amp;</span> movers<span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span> <span class="token comment">// farmer(status)获取农夫状态，是1还是0;</span>
                                                        <span class="token comment">// (status&amp;movers)获取菜的状态，是1还是0；</span>
                                                        <span class="token comment">// 如果农夫和菜的状态一致</span>
            newstatus <span class="token operator">=</span> status <span class="token operator">^</span> <span class="token punctuation">(</span><span class="token number">0x08</span> <span class="token operator">|</span> movers<span class="token punctuation">)</span><span class="token punctuation">;</span>       <span class="token comment">// status ^ (0b1001 | 0b0001)，即status 和 0b1001作异或操作，得0b0110</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">safe</span><span class="token punctuation">(</span>newstatus<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span>route<span class="token punctuation">[</span>newstatus<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>   <span class="token comment">// 调用safe判断status的下一个状态newstatus是否安全。如果newstatus不安全，则不能变；</span>
                                                                <span class="token comment">// route[newstatus] == -1，说明newstatus未被访问过</span>
                route<span class="token punctuation">[</span>newstatus<span class="token punctuation">]</span> <span class="token operator">=</span> status<span class="token punctuation">;</span>
                moveTo<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>newstatus<span class="token punctuation">)</span><span class="token punctuation">;</span>                         <span class="token comment">// 将newstatus计入moveTo队列</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>route<span class="token punctuation">[</span><span class="token number">15</span><span class="token punctuation">]</span> <span class="token operator">!=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>                                           <span class="token comment">// 如果最后一个状态0b1111对应的不是-1，说明最后一个状态已经达到</span>
        cout <span class="token operator">&lt;&lt;</span> <span class="token string">"The reverse path is:"</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> status <span class="token operator">=</span> <span class="token number">15</span><span class="token punctuation">;</span> status <span class="token operator">&gt;=</span> <span class="token number">0</span><span class="token punctuation">;</span> status <span class="token operator">=</span> route<span class="token punctuation">[</span>status<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span> <span class="token comment">// 从最后一个状态0b1111开始，</span>
            cout <span class="token operator">&lt;&lt;</span> <span class="token string">"The status is:"</span> <span class="token operator">&lt;&lt;</span> status <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>status <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token keyword">break</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">else</span>
        cout <span class="token operator">&lt;&lt;</span> <span class="token string">"No solution."</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<hr> 
<h2><a id="_782"></a>参考链接</h2> 
<hr class="footnotes-sep"> 
<section class="footnotes"> 
 <ol class="footnotes-list"><li id="fn1" class="footnote-item"><p><a href="https://www.icourse163.org/learn/PKU-1002534001?tid=1470937462#/learn/announce" rel="nofollow">数据结构与算法</a> <a href="#fnref1" rel="nofollow" class="footnote-backref">↩︎</a></p> </li></ol> 
</section>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/16af86e1cba5d9632a92e7601ad8da02/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">数据结构-各章节-思维导图</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/854194bd30b876da82b7c49405d61a63/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">C语言数组详解（超详细！！）</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>