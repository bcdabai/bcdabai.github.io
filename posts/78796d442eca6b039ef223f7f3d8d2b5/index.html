<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Qt之多媒体 - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Qt之多媒体" />
<meta property="og:description" content="1、QSound
QSound提供对平台音频设备的访问.直接继承QObject。
Qt提供了在大多数GUI应用程序中通常都需要的操作：异步播放声音文件。这用一个单呼叫就能简单的完成。
QSound::play(&#34;mysounds/bells.wav&#34;);
另外，可以创建一个QSound对象然后使用play()槽播放文件.
QSound bells(&#34;mysounds/bells.wav&#34;);
bells.play();
成员函数：
QSound::QSound ( const QString &amp; filename, QObject * parent = 0) 构造一个QSound能够快速的通过一个名为filename的文件来播放声音。 这也许会比静态函数play使用更多的内存。但它也可能更立即的（依赖平台音响设备而定）的播放。
父类parent被传递给了QObject的构造函数。 QSound::~QSound () 销毁声音对象。
QString QSound::fileName () const 返回与声音有关的文件名。 bool QSound::isAvailable () [静态] 如果在该平台上存在声音设备便返回真，否则返回假。应用程序要么当声音是十分重要时选择报告用户要么就默默的操作而不麻烦用户了 如果没有有效的声音设备，所有的QSound操作工作安静且快速。
bool QSound::isFinished () const 当声音播放完成时返回真，否则返回假。 int QSound::loops () const 返回声音将播放的次数。 int QSound::loopsRemaining () const 返回声音将循环的次数。该值在每次声音循环后会减少。 该函数在窗口下不支持并且总是返回循环的总数。 void QSound::play ( const QString &amp; filename ) [静态] 播放一个叫做filename的文件中的声音。 void QSound::play () [槽] 这是一个重载成员函数，提供了方便。它的行为基本上和上面的函数相同。 开启声音播放。该数数立即返回。依靠平台的音频设备，其它的声音也许被停止，也许被新的声音混合。 在任何时候声音可以再次播放，可能混合或者替代先播放的声音。 void QSound::setLoops ( int l ) 当它播放时设置声音重复一次。超过-1的值也许会引起声音的死循环。 在Windows中, 不同于1的循环次数的声音将总是死循环。 void QSound::stop () [槽] 停止声音播放。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/78796d442eca6b039ef223f7f3d8d2b5/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2010-12-19T05:02:00+08:00" />
<meta property="article:modified_time" content="2010-12-19T05:02:00+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Qt之多媒体</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p>1、QSound</p> 
<p>     QSound提供对平台音频设备的访问.直接继承QObject。</p> 
<p>     Qt提供了在大多数GUI应用程序中通常都需要的操作：异步播放声音文件。这用一个单呼叫就能简单的完成。</p> 
<p>        QSound::play("mysounds/bells.wav");</p> 
<p>     另外，可以创建一个QSound对象然后使用play()槽播放文件.</p> 
<p>        QSound bells("mysounds/bells.wav");</p> 
<p>        bells.play();</p> 
<p> </p> 
<p>   成员函数：</p> 
<p>  QSound::QSound ( const QString &amp; filename, QObject * parent = 0) <br>        构造一个QSound能够快速的通过一个名为filename的文件来播放声音。 <br>        这也许会比静态函数play使用更多的内存。但它也可能更立即的（依赖平台音响设备而定）的播放。<br>        父类parent被传递给了QObject的构造函数。 </p> 
<p> </p> 
<p>  QSound::~QSound () <br>        销毁声音对象。<br>  <br>  QString QSound::fileName () const <br>        返回与声音有关的文件名。 </p> 
<p> </p> 
<p>  bool QSound::isAvailable () [静态] <br>        如果在该平台上存在声音设备便返回真，否则返回假。应用程序要么当声音是十分重要时选择报告用户要么就默默的操作而不麻烦用户了 <br>        如果没有有效的声音设备，所有的QSound操作工作安静且快速。</p> 
<p> </p> 
<p>  bool QSound::isFinished () const <br>        当声音播放完成时返回真，否则返回假。 </p> 
<p> </p> 
<p>  int QSound::loops () const <br>        返回声音将播放的次数。 </p> 
<p> </p> 
<p>  int QSound::loopsRemaining () const <br>        返回声音将循环的次数。该值在每次声音循环后会减少。 <br>        该函数在窗口下不支持并且总是返回循环的总数。 </p> 
<p> </p> 
<p>  void QSound::play ( const QString &amp; filename ) [静态] <br>        播放一个叫做filename的文件中的声音。  </p> 
<p> </p> 
<p>  void QSound::play () [槽] <br>        这是一个重载成员函数，提供了方便。它的行为基本上和上面的函数相同。 <br>        开启声音播放。该数数立即返回。依靠平台的音频设备，其它的声音也许被停止，也许被新的声音混合。 </p> 
<p>        在任何时候声音可以再次播放，可能混合或者替代先播放的声音。 </p> 
<p> </p> 
<p>  void QSound::setLoops ( int l ) <br>        当它播放时设置声音重复一次。超过-1的值也许会引起声音的死循环。 <br>        在Windows中, 不同于1的循环次数的声音将总是死循环。 </p> 
<p> </p> 
<p>  void QSound::stop () [槽] <br>        停止声音播放。</p> 
<p>  注意:在windows下的QSound 只支持wav格式</p> 
<p>  不知道为什么这个类对接口支持写得这么烂，唉！</p> 
<p> </p> 
<p>2、Phonon</p> 
<p>     Qt phonon多媒体框架，原来QT早已引用这个框架了，呵呵。<br>     Phonon是什么？Qt从4.4版本开始提供的一套多媒体框架，提供多媒体回放的功能。目前在Qt 4.6中实现多媒体播放图形界面主要依赖于     phonon框架，其实qt中还有一个Multimedia模块，帮助文档中对它的描述是：实现底层的多媒体播放功能，在一般情况下上层的接口phonon模块更适合实现这些功能。phonon最初是 一个 源于KDE的项目，为使用音频和视频的应用程序开发提供的一个框架。应用程序不用去管多媒体播放是通过什么实现的（如gstreamer、xine），只需调用相应的接口就行，但这中间需要一个中转，被称为backend。Qt也是通过phonon来实现夸平台的多媒体播放。</p> 
<p>     多媒体文件的播放主要过程包括：文件读取、分流、解码、输出。</p> 
<p>    <img src="https://images2.imgbox.com/26/11/PVMvLQPM_o.gif" alt=""></p> 
<p>       这些在不同的系统中实现方式不同，如windows下的DirectX、Linux下的 gstreamer或xine及Mac下的QuickTime。 而Qt中的phonon作为夸平台的多媒体解决方案，就因该为用户屏蔽掉这些差异。而实际上它做得还不够好，因为用户还需要自己来安装相应的后端插件来完成播放任务。<strong><br>       <img src="https://images2.imgbox.com/c3/47/JTU6lGAd_o.gif" alt=""></strong></p> 
<p>            </p> 
<p><strong>       看完上图，你可以知道，应用Phonon框架实质上分4个部分，你的程序，Phonon库，Phonon后端插件(phonon_backend)，真正的后端。 Phonon其实什么都不干，他只是提供了一套API接口，这套接口可以给你的程序调用，同时也是给编写后端插件提供一个规范。</strong></p> 
<p><strong>       <textarea name="code" class="cpp">#include &lt;QtGui/QApplication&gt;
#include "mainwindow.h"
#include &lt;phonon/mediaobject.h&gt;
#include &lt;QTextCodec&gt;

int main(int argc, char *argv[])
{
    QApplication a(argc, argv);
    QTextCodec *codec = QTextCodec::codecForName("GB2312");
    QTextCodec::setCodecForLocale(codec);
    QTextCodec::setCodecForCStrings(codec);
    QTextCodec::setCodecForTr(codec);

    //音乐播放
    Phonon::MediaObject *music = Phonon::createPlayer(Phonon::MusicCategory, Phonon::MediaSource("E:/msc/a.mp3"));
    music-&gt;play();
    //视频播放
    Phonon::MediaObject *movie = Phonon::createPlayer(Phonon::VideoCategory,Phonon::MediaSource("E:/Movie/lian/窃听风云.avi"));
    movie-&gt;play();
    return a.exec();
}
</textarea> </strong></p> 
<p><strong></strong></p> 
<p><strong>       <img src="https://images2.imgbox.com/c2/e3/DWgLhrDp_o.gif" alt=""></strong></p> 
<p><strong>      </strong>整个播放影音的流程就是首先由media object开始播放，接著把媒体串流经由path送至sink，sink会经由音效卡等装置重新播放(play back)影音</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/0e665bf521d4f08faf56d0971a5cecb8/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">Commons Math学习笔记——多项式函数</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/a55c2f726834654e38e714838cfb41a2/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">Nutch&#43;HBase</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>