<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>STL之三：deque用法详解 - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="STL之三：deque用法详解" />
<meta property="og:description" content="deque函数： deque容器为一个给定类型的元素进行线性处理，像向量一样，它能够快速地随机访问任一个元素，并且能够高效地插入和删除容器的尾部元素。但它又与vector不同，deque支持高效插入和删除容器的头部元素，因此也叫做双端队列。deque类常用的函数如下。
(1) 构造函数
deque():创建一个空deque
deque(int nSize):创建一个deque,元素个数为nSize
deque(int nSize,const T&amp; t):创建一个deque,元素个数为nSize,且值均为t
deque(const deque &amp;):复制构造函数
(2) 增加函数
void push_front(const T&amp; x):双端队列头部增加一个元素X
void push_back(const T&amp; x):双端队列尾部增加一个元素x
iterator insert(iterator it,const T&amp; x):双端队列中某一元素前增加一个元素x
void insert(iterator it,int n,const T&amp; x):双端队列中某一元素前增加n个相同的元素x
void insert(iterator it,const_iterator first,const_iteratorlast):双端队列中某一元素前插入另一个相同类型向量的[forst,last)间的数据
(3) 删除函数
Iterator erase(iterator it):删除双端队列中的某一个元素
Iterator erase(iterator first,iterator last):删除双端队列中[first,last）中的元素
void pop_front():删除双端队列中最前一个元素
void pop_back():删除双端队列中最后一个元素
void clear():清空双端队列中最后一个元素
(4) 遍历函数
reference at(int pos):返回pos位置元素的引用
reference front():返回手元素的引用
reference back():返回尾元素的引用
iterator begin():返回向量头指针，指向第一个元素
iterator end():返回指向向量中最后一个元素下一个元素的指针（不包含在向量中）
reverse_iterator rbegin():反向迭代器，指向最后一个元素" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/7d9e601088801000ab188d1881cb70c3/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2013-01-19T19:55:18+08:00" />
<meta property="article:modified_time" content="2013-01-19T19:55:18+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">STL之三：deque用法详解</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <h2>deque函数：</h2> 
<p><span style="font-size:18px">deque容器为一个给定类型的元素进行线性处理，像向量一样，它能够快速地随机访问任一个元素，并且能够高效地插入和删除容器的尾部元素。但它又与vector不同，deque支持高效插入和删除容器的头部元素，因此也叫做双端队列。deque类常用的函数如下。</span></p> 
<p><span style="font-size:18px">(1)    构造函数</span></p> 
<p><span style="font-size:18px">deque():创建一个空deque</span></p> 
<p><span style="font-size:18px">deque(int nSize):创建一个deque,元素个数为nSize</span></p> 
<p><span style="font-size:18px">deque(int nSize,const T&amp; t):创建一个deque,元素个数为nSize,且值均为t</span></p> 
<p><span style="font-size:18px">deque(const deque &amp;):复制构造函数</span></p> 
<p><span style="font-size:18px">(2)    增加函数</span></p> 
<p><span style="font-size:18px">void push_front(const T&amp; x):双端队列头部增加一个元素X</span></p> 
<p><span style="font-size:18px">void push_back(const T&amp; x):双端队列尾部增加一个元素x</span></p> 
<p><span style="font-size:18px">iterator insert(iterator it,const T&amp; x):双端队列中某一元素前增加一个元素x</span></p> 
<p><span style="font-size:18px">void insert(iterator it,int n,const T&amp; x):双端队列中某一元素前增加n个相同的元素x</span></p> 
<p><span style="font-size:18px">void insert(iterator it,const_iterator first,const_iteratorlast):双端队列中某一元素前插入另一个相同类型向量的[forst,last)间的数据</span></p> 
<p><span style="font-size:18px">(3)    删除函数</span></p> 
<p><span style="font-size:18px">Iterator erase(iterator it):删除双端队列中的某一个元素</span></p> 
<p><span style="font-size:18px">Iterator erase(iterator first,iterator last):删除双端队列中[first,last）中的元素</span></p> 
<p><span style="font-size:18px">void pop_front():删除双端队列中最前一个元素</span></p> 
<p><span style="font-size:18px">void pop_back():删除双端队列中最后一个元素</span></p> 
<p><span style="font-size:18px">void clear():清空双端队列中最后一个元素</span></p> 
<p><span style="font-size:18px">(4)    遍历函数</span></p> 
<p><span style="font-size:18px">reference at(int pos):返回pos位置元素的引用</span></p> 
<p><span style="font-size:18px">reference front():返回手元素的引用</span></p> 
<p><span style="font-size:18px">reference back():返回尾元素的引用</span></p> 
<p><span style="font-size:18px">iterator begin():返回向量头指针，指向第一个元素</span></p> 
<p><span style="font-size:18px">iterator end():返回指向向量中最后一个元素下一个元素的指针（不包含在向量中）</span></p> 
<p><span style="font-size:18px">reverse_iterator rbegin():反向迭代器，指向最后一个元素</span></p> 
<p><span style="font-size:18px">reverse_iterator rend():反向迭代器，指向第一个元素的前一个元素</span></p> 
<p><span style="font-size:18px">(5)    判断函数</span></p> 
<p><span style="font-size:18px">bool empty() const:向量是否为空，若true,则向量中无元素</span></p> 
<p><span style="font-size:18px">(6)    大小函数</span></p> 
<p><span style="font-size:18px">Int size() const:返回向量中元素的个数</span></p> 
<p><span style="font-size:18px">int max_size() const:返回最大可允许的双端对了元素数量值</span></p> 
<p><span style="font-size:18px">(7)    其他函数</span></p> 
<p><span style="font-size:18px">void swap(deque&amp;):交换两个同类型向量的数据</span></p> 
<p><span style="font-size:18px">void assign(int n,const T&amp; x):向量中第n个元素的值设置为x</span></p> 
<p> </p> 
<h2>操作示例：</h2> 
<div> 
 <pre><code class="language-cpp">// deque.cpp : 定义控制台应用程序的入口点。
//

#include "stdafx.h"
#include&lt;iostream&gt;
#include&lt;deque&gt;

using namespace std;
int _tmain(int argc, _TCHAR* argv[])
{
	deque&lt;int&gt; d;
	d.push_back( 10 );
	d.push_back(20);
	d.push_back(30);
	cout&lt;&lt;"原始双端队列："&lt;&lt;endl;
	for(int i = 0; i &lt; d.size(); i++)
	{
		cout&lt;&lt;d.at(i)&lt;&lt;"\t";
	}
	cout&lt;&lt;endl;
	d.push_front(5);
	d.push_front(3);
	d.push_front(1);

	cout&lt;&lt;"after push_front(5.3.1):"&lt;&lt;endl;
	for(int i = 0;i &lt; d.size();i++)
	{
		cout&lt;&lt;d.at(i)&lt;&lt;"\t";
	}
	cout&lt;&lt;endl;
	d.pop_front();
	d.pop_front();
	cout&lt;&lt;"after pop_front() two times:"&lt;&lt;endl;
	for(int i = 0;i &lt; d.size();i++)
	{
		cout&lt;&lt;d.at(i)&lt;&lt;"\t";
	}
	cout&lt;&lt;endl;
	return 0;
}
</code></pre> 
 <br> 程序运行结果如下所示： 
</div> 
<div> 
 <img src="https://images2.imgbox.com/3c/e5/rZW5hmiB_o.png" alt=""> 
 <br> 
</div> 
<div>
  2.deque与vector内存分配比较： 
</div> 
<div> 
 <pre><code class="language-cpp">// deque.cpp : 定义控制台应用程序的入口点。
//

#include "stdafx.h"
#include&lt;iostream&gt;
#include&lt;deque&gt;
#include&lt;vector&gt;

using namespace std;
int _tmain(int argc, _TCHAR* argv[])
{
	vector&lt;int&gt;v(2);
	v[0]=10;
	int *p = &amp;v[0];
	cout&lt;&lt;"vector第一个元素迭代指针*p="&lt;&lt;*p&lt;&lt;endl;
	v.push_back(20);
	cout&lt;&lt;"vector容量变化后原vector第1个元素迭代指针*p="&lt;&lt;*p&lt;&lt;endl;

	deque&lt;int&gt; d(2);
	d[0]=10;
	int *q = &amp;d[0];
	cout&lt;&lt;"deque第一个元素迭代指针*q="&lt;&lt;*q&lt;&lt;endl;
	d.push_back(20);
	cout&lt;&lt;"deque容量变化后第一个元素迭代器指针*q="&lt;&lt;*q&lt;&lt;endl;
}
</code></pre> 
 <br> 程序运行结果如下图所示 
</div> 
<div> 
 <img src="https://images2.imgbox.com/3c/9a/sKR1eG5t_o.png" alt=""> 
 <br> 
</div> 
<div>
  该段程序的功能是：deque、vector初始化后大小为2，第一个元素都为10，当通过push_back函数分别给两个容器增加一个元素后，从结果发现原先保持的指针元素值对vector容器前后发生了变化，而对deque容器前后没有发生变化。原因为，在建立vector容器时，一般来说伴随这建立空间-&gt;填充数据-&gt;重建更大空间-&gt;复制原空间数据-&gt;删除原空间-&gt;添加新数据，如此反复，保证vector始终是一块独立的连续内存空间；在建立deque容器时，一般便随着建立空间-&gt;建立数据-&gt;建立新空间-&gt;填充新数据，如此反复，没有原空间数据的复制和删除过程，是由多个连续的内存空间组成的。 
</div>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/298f2e2e18b2535316836a15e1d0d380/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">java.lang.ClassNotFoundException: org.springframework.web.context.ContextLoaderListener错误解决方案</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/18913965b7344b68e3c94d35055e781e/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">瞬联基于OpenStack的私有云解决方案</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>