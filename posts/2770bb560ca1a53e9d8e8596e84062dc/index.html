<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>什么情况下不能使用最坏情况评估算法的复杂度？ - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="什么情况下不能使用最坏情况评估算法的复杂度？" />
<meta property="og:description" content="前言 本篇文章收录于专辑：http://dwz.win/HjK，点击解锁更多数据结构与算法的知识。
你好，我是彤哥，一个每天爬二十六层楼还不忘读源码的硬核男人。
上一节，我们从最坏、平均、最好三种情况分析了算法的复杂度，得出结论，通常来说，使用最坏情况来评估算法的复杂度完全够用了。
但是，有些算法是不能使用最坏情况来评估算法的复杂度的。
那么，有哪些算法呢？
本节，我们将从动态数组以及快速排序这两个个例入手来分析不能使用最坏情况评估复杂度的情形。
动态数组 动态数组，对应于Java中的ArrayList，在插入元素时，分成两种情况：
数组未满，元素放在size下标的位置即可；数组满了，需要扩容，一般扩容为N倍大小，Java里面是1.5倍，扩容时需要创建一个新的数组，并把原来的元素一个一个地拷贝到新的数组中，再插入新的元素； 我简单地写一段代码，你可以感受下：
public class DynamicArray { private int[] array; private int size; public DynamicArray(int capacity) { this.array = new int[capacity]; this.size = 0; } // 插入元素，时间复杂度为多少呢？ public void add(int element) { // 判断是否需要扩容 if (size &gt;= array.length) { int newCapacity = array.length &#43; (array.length &gt;&gt; 1); int[] newArray = new int[newCapacity]; for (int i = 0; i &lt; array.length; i&#43;&#43;) { newArray[i] = array[i]; } this." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/2770bb560ca1a53e9d8e8596e84062dc/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2020-07-23T07:43:55+08:00" />
<meta property="article:modified_time" content="2020-07-23T07:43:55+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">什么情况下不能使用最坏情况评估算法的复杂度？</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-light">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p><img src="https://images2.imgbox.com/1e/27/8vuitTUz_o.png" alt="file"></p> 
<h2><a id="_1"></a>前言</h2> 
<blockquote> 
 <p>本篇文章收录于专辑：<a href="http://dwz.win/HjK" rel="nofollow">http://dwz.win/HjK</a>，点击解锁更多数据结构与算法的知识。</p> 
</blockquote> 
<p>你好，我是彤哥，一个每天爬二十六层楼还不忘读源码的硬核男人。</p> 
<p>上一节，我们从最坏、平均、最好三种情况分析了算法的复杂度，得出结论，通常来说，使用最坏情况来评估算法的复杂度完全够用了。</p> 
<p>但是，有些算法是不能使用最坏情况来评估算法的复杂度的。</p> 
<p>那么，有哪些算法呢？</p> 
<p>本节，我们将从动态数组以及快速排序这两个个例入手来分析不能使用最坏情况评估复杂度的情形。</p> 
<h2><a id="_16"></a>动态数组</h2> 
<p>动态数组，对应于Java中的ArrayList，在插入元素时，分成两种情况：</p> 
<ol><li>数组未满，元素放在size下标的位置即可；</li><li>数组满了，需要扩容，一般扩容为N倍大小，Java里面是1.5倍，扩容时需要创建一个新的数组，并把原来的元素一个一个地拷贝到新的数组中，再插入新的元素；</li></ol> 
<p>我简单地写一段代码，你可以感受下：</p> 
<pre><code class="prism language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">DynamicArray</span> <span class="token punctuation">{<!-- --></span>
    <span class="token keyword">private</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> array<span class="token punctuation">;</span>
    <span class="token keyword">private</span> <span class="token keyword">int</span> size<span class="token punctuation">;</span>

    <span class="token keyword">public</span> <span class="token function">DynamicArray</span><span class="token punctuation">(</span><span class="token keyword">int</span> capacity<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>array <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">int</span><span class="token punctuation">[</span>capacity<span class="token punctuation">]</span><span class="token punctuation">;</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>size <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token comment">// 插入元素，时间复杂度为多少呢？</span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">int</span> element<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token comment">// 判断是否需要扩容</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>size <span class="token operator">&gt;=</span> array<span class="token punctuation">.</span>length<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
            <span class="token keyword">int</span> newCapacity <span class="token operator">=</span> array<span class="token punctuation">.</span>length <span class="token operator">+</span> <span class="token punctuation">(</span>array<span class="token punctuation">.</span>length <span class="token operator">&gt;&gt;</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> newArray <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">int</span><span class="token punctuation">[</span>newCapacity<span class="token punctuation">]</span><span class="token punctuation">;</span>
            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> array<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
                newArray<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> array<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
            <span class="token keyword">this</span><span class="token punctuation">.</span>array <span class="token operator">=</span> newArray<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        array<span class="token punctuation">[</span>size<span class="token operator">++</span><span class="token punctuation">]</span> <span class="token operator">=</span> element<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">public</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">getArray</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token keyword">return</span> array<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        DynamicArray dynamicArray <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">DynamicArray</span><span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        dynamicArray<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        dynamicArray<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        dynamicArray<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        dynamicArray<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        dynamicArray<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        dynamicArray<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token number">6</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> element <span class="token operator">:</span> dynamicArray<span class="token punctuation">.</span><span class="token function">getArray</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>element<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>那么，对于动态数组，它的插入元素方法的时间复杂度是多少呢？</p> 
<p>按照上一节的说法，按照最坏情况来评估，最坏情况是插入元素时正好数组满了需要扩容的时候，此时，需要创建一个额外的数组，同时有一个遍历原数组的过程。</p> 
<p>所以，在最坏情况下，动态数组插入元素的时间复杂度为O(n)。</p> 
<p>但是，这样合理吗？</p> 
<p>显然是不合理的，我插入前面(n-1)个元素的时候，它的时间复杂度都是O(1)，就只有插入第n个元素的时候它的时间复杂度才是O(n)，所以，这样来评估动态数组插入元素的时间复杂度明显不合理。</p> 
<p>那么，如果我把第n个元素插入所需要的时间均摊到所有元素上会怎么样呢？</p> 
<p>这样的话，前面每个元素的插入时间只需要加1，变成O(2)，忽略常数项，就还是O(1)，这样明显是要合理一些。</p> 
<p>这种方式跟计算平均时间复杂度有点类似，但是，它不是平均时间复杂度，它有一个专门的名称叫做<strong>均摊时间复杂度</strong>。</p> 
<p>均摊时间复杂度，即对一批样本中出现的个例情况，将它们耗费的时间均摊到所有样本上，算出来的一个时间复杂度。</p> 
<p>你可以把它和平均时间复杂度对比一下：</p> 
<ol><li>平均时间复杂度的计算中没有个例，所有样本是同等看待的，想一下线性查找的过程；</li><li>均摊时间复杂度的计算中有个例，这种个例往往就是最坏的情况，想一下动态数组插入元素的过程；</li><li>线性查找第n个元素不是个例，不能把它的时间均摊到所有元素上；</li></ol> 
<blockquote> 
 <p>这两个概念严格来说是有区别的，如果无法理解，当成一样的也问题不大，比如，这里如果按平均时间复杂度计算的话，结果为 (1+1+1+…+n)/n = (n-1+n)/n = (2n-1)/n=2-1/n，忽略常数项和低阶项，最终的结果也是O(1)。</p> 
</blockquote> 
<p>好了，那么，我们再来看一下动态数组插入元素时的额外空间复杂度。</p> 
<p>是不是一样的道理？数组未满时额外空间复杂度为O(1)，数组满时额外空间复杂度为O(n)，均摊一下变成O(1)。</p> 
<p>所以，对于动态数组插入元素的过程，它的均摊时间复杂度和均摊额外空间复杂度都是O(1)。</p> 
<h2><a id="_101"></a>快速排序</h2> 
<p>大家都知道经典的快速排序的时间复杂度是O(nlogn)，那么，它的最坏时间复杂度是不是也是O(nlogn)呢？</p> 
<p>让我们来看下面这个数组：</p> 
<p><img src="https://images2.imgbox.com/48/e3/kGHlRXJ6_o.png" alt="file"></p> 
<p>这是一个有序数组，如果此时用经典快速排序来对其进行排序会怎样呢？</p> 
<p>我们取最右边的元素为轴（Pivot），也就是12，将小于12的放在它的左边，大于12的放在它的右边，发现没有比12大的，所以，右边没有元素，经过此步，12的位置固定不变了。</p> 
<p>接着，将12左右两边的元素再各取最右边的元素为轴，12的右边没有元素，所以，只需要处理左边就可以了，以10为轴，比10小的放在它的左边，比10大的放在它的右边，发现10的右边也没有元素（12已经固定了），经过此步，10的位置固定了。</p> 
<p>同样地，最后一步到1这里，排序完成。</p> 
<p>让我们来分析一下整个过程的复杂度：</p> 
<p>第一步，需要遍历(n-1)个元素；</p> 
<p>第二步，需要遍历(n-2)个元素；</p> 
<p>…</p> 
<p>最后一步，需要遍历0个元素；</p> 
<p>这种情况下的时间复杂度为：(n-1) + (n-2) + … + 1 + 0 = (n-1)n/2 = n^2/2 - n/2，忽略常数项和低阶项，它的时间复杂度为O(n^2)。</p> 
<p>所以，对于有序数组，使用经典快速排序，它的时间复杂度为O(n^2)，这也是最坏的情况。</p> 
<p>但是，似乎从来没有人告诉你，经典快速排序的时间复杂度为O(n^2)，而是O(nlog2)，这是为什么呢？</p> 
<p>那是因为有序数组相对于经典快速排序，也是属于个例，穷举无限多的样本之后，有序数组的可能性实在是太小，所以，我们一般说经典快速排序的时间复杂度为O(nlogn)，而不是以最坏情况来评估它的时间复杂度。</p> 
<blockquote> 
 <p>我们这里说的是经典快速排序，为什么要加“经典”两个字呢？</p> 
</blockquote> 
<h2><a id="_137"></a>后记</h2> 
<p>好了，本节，我们通过两个案例来说明了并不是所有的算法都使用最坏情况来评估它的复杂度。</p> 
<p>到现在为止，我们都是使用的大O来表示算法的复杂度，但是，在其它书籍中，你可能还见过Θ、Ω等表示法，它们又是什么意思呢？</p> 
<p>下一节，我们接着聊。</p> 
<blockquote> 
 <p>关注公众号“彤哥读源码”，解锁更多源码、基础、架构知识！</p> 
</blockquote>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/5546aae6a3efa481a0e898ddda70dbba/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">Microsoft SQL Server Management Studio（SSMS）概述</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/0f098e9090998f97574b4cabac7452c7/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">DATE_SUB(NOW(), INTERVAL 10 MINUTE)的用法（mysql）</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>