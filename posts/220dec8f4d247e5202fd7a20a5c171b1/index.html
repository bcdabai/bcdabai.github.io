<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>C(C&#43;&#43;)和Python实现STM32F4实时操作系统(FreeRTOS)吸尘器 - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="C(C&#43;&#43;)和Python实现STM32F4实时操作系统(FreeRTOS)吸尘器" />
<meta property="og:description" content="Arm Cortex M 微控制器 STM32F4 通过 FreeRTOS 和 Mbed OS 实现的实时操作系统，使用了 C 语言（微控制器的“编程”语言）、C&#43;&#43;语言和 MicroPython（允许在微控制器上使用 Python 语言）数字控制吸尘器。
STM32F4微控制器 STM32F4微控制器不能单独使用，除非为其构建专用开发或特定板。 作为早期学习者，我们的最佳选择是使用可用的 32F429IDISCOVERY 套件来实现此目的。 为了简单起见，我们从现在开始将这块板称为STM32F4。
STM32F4 C&#43;&#43;编程示例 GPIO输出闪烁
#include &lt;cstdint&gt; #include &lt;STM32F4x1/Gpio.hpp&gt; #include &lt;STM32F4x1/Clock.hpp&gt; int main() { using namespace Stm32; deviceInit(); Gpio&lt;Port::C, 13&gt; ledPin; ledPin.setMode(GpioMode::Output); while(true) { ledPin.setLevel(true); for(uint32_t i = 0; i &lt; 1000000; &#43;&#43;i); //&lt; some delay ledPin.setLevel(false); for(uint32_t i = 0; i &lt; 1000000; &#43;&#43;i); //&lt; some delay } return 0; } FreeRTOS实时系统配置和主程序" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/220dec8f4d247e5202fd7a20a5c171b1/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2024-01-21T21:41:04+08:00" />
<meta property="article:modified_time" content="2024-01-21T21:41:04+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">C(C&#43;&#43;)和Python实现STM32F4实时操作系统(FreeRTOS)吸尘器</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p>Arm Cortex M 微控制器 STM32F4 通过 FreeRTOS 和 Mbed OS 实现的实时操作系统，使用了 C 语言（微控制器的“编程”语言）、C++语言和 MicroPython（允许在微控制器上使用 Python 语言）数字控制吸尘器。</p> 
<h3><a id="STM32F4_4"></a>STM32F4微控制器</h3> 
<p>STM32F4微控制器不能单独使用，除非为其构建专用开发或特定板。 作为早期学习者，我们的最佳选择是使用可用的 32F429IDISCOVERY 套件来实现此目的。 为了简单起见，我们从现在开始将这块板称为STM32F4。</p> 
<h4><a id="STM32F4_C_8"></a>STM32F4 C++编程示例</h4> 
<p>GPIO输出闪烁</p> 
<pre><code class="prism language-C++">#include &lt;cstdint&gt;

#include &lt;STM32F4x1/Gpio.hpp&gt;
#include &lt;STM32F4x1/Clock.hpp&gt;

int main()
{
  using namespace Stm32;
  deviceInit();
  Gpio&lt;Port::C, 13&gt; ledPin;
  ledPin.setMode(GpioMode::Output);
  while(true)
  {
    ledPin.setLevel(true);
    for(uint32_t i = 0; i &lt; 1000000; ++i);  //&lt; some delay
    ledPin.setLevel(false);
    for(uint32_t i = 0; i &lt; 1000000; ++i);  //&lt; some delay
  }

  return 0;
}
</code></pre> 
<p>FreeRTOS实时系统配置和主程序</p> 
<pre><code class="prism language-C++">#ifndef FREERTOS_CONFIG_H
#define FREERTOS_CONFIG_H

#include &lt;stdint.h&gt;
extern uint32_t SystemCoreClock;

#define configUSE_PREEMPTION			1
#define configUSE_IDLE_HOOK				1
#define configUSE_TICK_HOOK				1
#define configCPU_CLOCK_HZ				( SystemCoreClock )
#define configTICK_RATE_HZ				( ( TickType_t ) 1000 )
#if !defined USE_CMSIS_RTOS_V2
#define configMAX_PRIORITIES			( 5 )
#endif
#define configMINIMAL_STACK_SIZE		( ( unsigned short ) 50 )
#define configTOTAL_HEAP_SIZE			( ( size_t ) ( 20 * 1024 ) )
#define configMAX_TASK_NAME_LEN			( 10 )
#define configUSE_TRACE_FACILITY		1
#define configUSE_16_BIT_TICKS			0
#define configIDLE_SHOULD_YIELD			1
#define configUSE_MUTEXES				1
#define configQUEUE_REGISTRY_SIZE		8
#define configCHECK_FOR_STACK_OVERFLOW	2
#define configUSE_RECURSIVE_MUTEXES		1
#define configUSE_MALLOC_FAILED_HOOK	1
#define configUSE_APPLICATION_TASK_TAG	0
#define configUSE_COUNTING_SEMAPHORES	1
#define configGENERATE_RUN_TIME_STATS	0

/* Co-routine definitions. */
#define configUSE_CO_ROUTINES 		0
#define configMAX_CO_ROUTINE_PRIORITIES ( 2 )

/* Software timer definitions. */
#define configUSE_TIMERS				0
#define configTIMER_TASK_PRIORITY		( 2 )
#define configTIMER_QUEUE_LENGTH		10
#define configTIMER_TASK_STACK_DEPTH	( configMINIMAL_STACK_SIZE * 2 )

/* Set the following definitions to 1 to include the API function, or zero
to exclude the API function. */
#define INCLUDE_vTaskPrioritySet		1
#define INCLUDE_uxTaskPriorityGet		1
#define INCLUDE_vTaskDelete				1
#define INCLUDE_vTaskCleanUpResources	1
#define INCLUDE_vTaskSuspend			1
#define INCLUDE_vTaskDelayUntil			1
#define INCLUDE_vTaskDelay				1

#if defined USE_CMSIS_RTOS_V2

#ifndef CMSIS_RTOS_V2_DEVICE_HEADER
#error "CMSIS device header needs to be passed by the build system"
#endif
#define CMSIS_device_header CMSIS_RTOS_V2_DEVICE_HEADER

/* Needed for CMSIS RTOS_V2 */
#define configUSE_PORT_OPTIMISED_TASK_SELECTION 0
#define configMAX_PRIORITIES 56

#define INCLUDE_xSemaphoreGetMutexHolder 1
#define INCLUDE_xTaskGetCurrentTaskHandle 1
#define INCLUDE_xTaskGetSchedulerState 1
#define INCLUDE_uxTaskGetStackHighWaterMark 1
#define INCLUDE_eTaskGetState 1
#define INCLUDE_xTimerPendFunctionCall 1

#endif

/* Cortex-M specific definitions. */
#ifdef __NVIC_PRIO_BITS
	/* __BVIC_PRIO_BITS will be specified when CMSIS is being used. */
	#define configPRIO_BITS       		__NVIC_PRIO_BITS
#else
	#define configPRIO_BITS       		4        /* 15 priority levels */
#endif

/* The lowest interrupt priority that can be used in a call to a "set priority"
function. */
#define configLIBRARY_LOWEST_INTERRUPT_PRIORITY			0xf

/* The highest interrupt priority that can be used by any interrupt service
routine that makes calls to interrupt safe FreeRTOS API functions.  DO NOT CALL
INTERRUPT SAFE FREERTOS API FUNCTIONS FROM ANY INTERRUPT THAT HAS A HIGHER
PRIORITY THAN THIS! (higher priorities are lower numeric values. */
#define configLIBRARY_MAX_SYSCALL_INTERRUPT_PRIORITY	5

/* Interrupt priorities used by the kernel port layer itself.  These are generic
to all Cortex-M ports, and do not rely on any particular library functions. */
#define configKERNEL_INTERRUPT_PRIORITY 		( configLIBRARY_LOWEST_INTERRUPT_PRIORITY &lt;&lt; (8 - configPRIO_BITS) )
/* !!!! configMAX_SYSCALL_INTERRUPT_PRIORITY must not be set to zero !!!!
See http://www.FreeRTOS.org/RTOS-Cortex-M3-M4.html. */
#define configMAX_SYSCALL_INTERRUPT_PRIORITY 	( configLIBRARY_MAX_SYSCALL_INTERRUPT_PRIORITY &lt;&lt; (8 - configPRIO_BITS) )
	
/* Normal assert() semantics without relying on the provision of an assert.h
header file. */
#define configASSERT( x ) if( ( x ) == 0 ) { taskDISABLE_INTERRUPTS(); for( ;; ); }	
	
/* Definitions that map the FreeRTOS port interrupt handlers to their CMSIS
standard names. */
#define vPortSVCHandler SVC_Handler
#define xPortPendSVHandler PendSV_Handler

/* When using CMSIS RTOS V2, this define causes  a multiple definition error */
#if !defined USE_CMSIS_RTOS_V2
#define xPortSysTickHandler SysTick_Handler
#endif

#endif /* FREERTOS_CONFIG_H */
</code></pre> 
<p>主程序</p> 
<pre><code class="prism language-c++">#include &lt;cstdio&gt;
#include &lt;chrono&gt;
#include &lt;type_traits&gt;

#include &lt;STM32F4x1/Gpio.hpp&gt;
#include &lt;STM32F4x1/Clock.hpp&gt;

#include &lt;FreeRTOS.h&gt;
#include &lt;task.h&gt;

void task1(void* param)
{
  (void)param;
  using namespace Stm32;
  Pins::PC14 ledPin;
  ledPin.setMode(GpioMode::Output);
  while(true)
  {
    ledPin.setLevel(true);
    vTaskDelay(pdMS_TO_TICKS(300));
    ledPin.setLevel(false);
    vTaskDelay(pdMS_TO_TICKS(300));
  }
}

int main()
{
  using namespace Stm32;
  deviceInit();
  
  xTaskCreate(task1, "task1", 100, NULL, tskIDLE_PRIORITY + 1, NULL);
  xTaskCreate(task2, "task2", 100, NULL, tskIDLE_PRIORITY + 1, NULL);
  vTaskStartScheduler();
  
  while(true);

  return 0;
}
extern "C"
{
  void vApplicationTickHook(void)
  {
  }

  void vApplicationIdleHook(void)
  {
  }
  
  void vApplicationMallocFailedHook(void)
  {
    taskDISABLE_INTERRUPTS();
    while(true);
  }
}
</code></pre> 
<h3><a id="CCPython_209"></a>C(C++)和Python开发平台</h3> 
<h4><a id="STM32CubeIDE_211"></a>STM32CubeIDE平台</h4> 
<p>就资源使用、执行速度和编程简易性而言，C 是对微控制器进行编程最有效的语言。 因此，它被视为大多数微控制器的事实上的语言。 在这里，我们假设读者对基本 C 编程技术有足够的了解。</p> 
<p>我们将受益于STM32CubeIDE平台，通过C语言对STM32F4微控制器进行编程。 该平台有几个优点。 首先，它是免费的。 其次，它是意法半导体专门为微控制器开发的。 第三，可以使用 STM32CubeIDE 访问和修改微控制器的所有属性，包括其外围单元。</p> 
<p>为了熟悉STM32CubeIDE，我们将从它的安装开始。 之后，我们将解释如何创建和管理项目。 我们将重点关注在 STM32CubeIDE 中创建和执行项目的基本属性。</p> 
<h4><a id="Mbed__Mbed_Studio__219"></a>Mbed 和 Mbed Studio 平台</h4> 
<p><strong>Mbed在线平台</strong></p> 
<p>Arm 推出了 Mbed 作为为其微控制器开发项目的在线平台。 为了使用 Mbed，读者应在网站 https://os.mbed.com/ide/ 上开设一个免费帐户。 此外，所选板应受 Mbed 支持。此类板称为“Mbed Enabled”，并在网站 https://os.mbed.com/platforms/ 中列出。 我们的 STM32F4 板支持 Mbed。 因此，我们可以将它与 Mbed 一起使用。</p> 
<p>Mbed在线平台具有三个主要优点。 首先，它不需要在电脑上下载并安装任何IDE。 它的结构使得用户可以在基于网络的平台上开发项目。 在构建项目时，Mbed 创建一个要嵌入到微控制器上的二进制文件（扩展名为“.bin”）。 其次，Mbed 的形成使得，只要满足硬件要求，为 Mbed 生态系统中的一个平台编写的代码就可以轻松移植到另一个平台。因为 Mbed 简化并泛化了低级硬件设置和使用。 从这个角度来看，Mbed 类似于流行的 Arduino 平台。 第三，MBed 是一个在线平台，允许社区成员之间共享代码。 这是通过基于 Web 的界面发布和导入生成的代码来完成的。 事实上，读者可以通过将其他社区成员发布的项目导入到工作区来轻松使用该项目。 然后，读者可以根据自己的需要进一步开发该项目。</p> 
<p><strong>Mbed Studio</strong></p> 
<p>Mbed Studio 是 Mbed 的桌面版本。 读者可以从网站https://os.mbed.com/studio/下载。 下载完成后，读者应按照其中概述的步骤进行安装。 安装完成后，读者应登录Mbed 帐户。Mbed Studio 的界面相当紧凑，窗口左侧有一个面板。 通过它，用户可以创建新项目，选择目标，并为所选目标构建项目。 在窗口的中央，主代码文件将在添加到项目时打开。 面板底部有一些选项卡总结了所有构建和调试操作。</p> 
<p><strong>微控制器Python</strong></p> 
<p>MicroPython 是 Python 语言在微控制器上的实现。 它允许在选定的微控制器上执行高级 Python 代码。 这里需要注意的是，MicroPython 只能在支持它的微控制器系列的子集上使用。 MicroPython 支持 STM32F4 微控制器和 STM32F4 板。</p> 
<p>MicroPython 在微控制器上使用时具有多种优势。 它的第一个优点是允许 Python 程序员使用微控制器。 因此，这样的程序员不需要学习C或C++语言。 MicroPython 的第二个优势是其可用的库。 尽管这个库集合不像 Python 那样多样化，但它正在扩展。 此外，如果读者需要在 MicroPython 下使用特定的库，可以为手头的微控制器从头开始构建它。MicroPython 的第三个优势是它是一种基于解释器的语言。</p> 
<h3><a id="_237"></a>吸尘器功能</h3> 
<h4><a id="_239"></a>数字输入输出控制</h4> 
<p>使用数字 IO 功能控制吸尘器的三个功能，从控制器上的 LED 和按钮开始。 接下来我们测量机器人上的集尘室。 如果已满，我们会通过 LED 通知读者。 最后，我们用数字距离传感器检测机器人右侧和左侧的障碍物。</p> 
<h4><a id="_243"></a>中断和功耗模式</h4> 
<h4><a id="_245"></a>计时功能</h4> 
<p>用吸尘器轮子的编码器和光电传感器，测量吸尘器的速度。 我们还设置了 RTC(实时时钟)，吸尘器每天都会在同一时间自动醒来，清扫房间，然后返回待机模式。</p> 
<h4><a id="_249"></a>数字信号和模拟信号转换</h4> 
<p>执行电池电量测量和显示以及距离感测，并通过 ADC、DAC 和 PWM 模块控制吸尘器的速度和扫描速率。最后，我们在吸尘器前面添加了一个模拟距离传感器来检查可能的，这将控制机器人的速度。</p> 
<h4><a id="_253"></a>数字信号通讯</h4> 
<p>为吸尘器添加了远程控制功能。首先使用一块独立板作为带有蓝牙连接的遥控器，其次，我们开发一个在Android手机上运行的远程控制器应用程序。</p> 
<h4><a id="_257"></a>地图生成和扫描算法</h4> 
<p>吸尘器生成使用的地图和清扫算法。 此外，当吸尘器关闭时，我们将位置、扫地模式等重要信息存储到SDRAM中。</p> 
<h4><a id="_261"></a>实时控制系统</h4> 
<p>将吸尘器开发的软件迁移到RTOS（实时控制系统），展示了如何使用它来组织机器人中的复杂操作。</p> 
<h4><a id="GUI_265"></a>图形界面（GUI）和触摸屏独立遥控器</h4> 
<p>在 LCD 和触摸屏上形成 GUI 来表示第二块 STM32F4 板上的物理 LED 和按钮。</p> 
<h6><a id="httpsviadeangitbookioallqianrushiembeddedccpphepythonshixianstm32f4shishicaozuoxitongfreertosxichenqi_269"></a>参阅一：<a href="https://via-dean.gitbook.io/all/qian-ru-shi-embedded/c-cpp-he-python-shi-xian-stm32f4-shi-shi-cao-zuo-xi-tong-freertos-xi-chen-qi" rel="nofollow">亚图跨际</a></h6> 
<h6><a id="httpsviadeannotionsiteCCppPythonSTM32F4FreeRTOS5729ae48a0e848d68ced59e844164d8fpvs4_270"></a>参阅二：<a href="https://viadean.notion.site/C-Cpp-Python-STM32F4-FreeRTOS-5729ae48a0e848d68ced59e844164d8f?pvs=4" rel="nofollow">亚图跨际</a></h6>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/daa04c346de0e6ef94113ccb3b888bce/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">linux 的nobody是什么用户？ 对安全有没有影响？</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/3d9398f7eb053508288f0a09ccda591a/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">基于SpringBoot&#43;vue的在线视频教育平台的设计与实现，附源码，数据库</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>