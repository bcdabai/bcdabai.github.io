<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>android 按键事件上报机制 - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="android 按键事件上报机制" />
<meta property="og:description" content="1. 按键上报和分发机制 按键处理设计的整体思路是驱动层会有一个消息队列来存放事件，会有一个Reader来不停的读取事件，一个Dispatcher来分发消息队列中的事件。Dispatcher分发的事件最后会通过jni上报到InputManagerService，然后通过接口最后传递给PhoneWindow，这里再根据不同的按键事件类型来做不同的处理。
1.1 输入事件处理准备工作 当系统开机之后SystemServer会启动InputManagerService，在SystemServer.java中的startOtherServices()方法中启动：
Slog.i(TAG, &#34;Input Manager&#34;); inputManager = new InputManagerService(context); Slog.i(TAG, &#34;Window Manager&#34;); wm = WindowManagerService.main(context, inputManager, mFactoryTestMode != FactoryTest.FACTORY_TEST_LOW_LEVEL, !mFirstBoot, mOnlyCore); ServiceManager.addService(Context.WINDOW_SERVICE, wm); ServiceManager.addService(Context.INPUT_SERVICE, inputManager); mActivityManagerService.setWindowManager(wm); inputManager.setWindowManagerCallbacks(wm.getInputMonitor()); inputManager.start(); 复制代码 看一下InputManagerService的构造方法：
public InputManagerService(Context context) { this.mContext = context; this.mHandler = new InputManagerHandler(DisplayThread.get().getLooper()); mUseDevInputEventForAudioJack = context.getResources().getBoolean(R.bool.config_useDevInputEventForAudioJack); Slog.i(TAG, &#34;Initializing input manager, mUseDevInputEventForAudioJack=&#34; &#43; mUseDevInputEventForAudioJack); mPtr = nativeInit(this, mContext, mHandler.getLooper().getQueue()); LocalServices.addService(InputManagerInternal.class, new LocalService()); } 复制代码 主要是通过JNI的方式调用nativeInit方法传入一个消息队列作为参数，nativeInit对应是com_android_server_input_InputManagerService.cpp中的nativeInit。
static jlong nativeInit(JNIEnv* env, jclass /* clazz */, jobject serviceObj, jobject contextObj, jobject messageQueueObj) { sp&lt;MessageQueue&gt; messageQueue = android_os_MessageQueue_getMessageQueue(env, messageQueueObj); if (messageQueue == NULL) { jniThrowRuntimeException(env, &#34;" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/a4b1cf83c8ae82cf30ad34bd0c579de7/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2019-01-13T08:28:56+08:00" />
<meta property="article:modified_time" content="2019-01-13T08:28:56+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">android 按键事件上报机制</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <div class="article-content"> 
 <h2 class="heading">1. 按键上报和分发机制</h2> 
 <p>按键处理设计的整体思路是驱动层会有一个消息队列来存放事件，会有一个Reader来不停的读取事件，一个Dispatcher来分发消息队列中的事件。Dispatcher分发的事件最后会通过jni上报到InputManagerService，然后通过接口最后传递给PhoneWindow，这里再根据不同的按键事件类型来做不同的处理。</p> 
 <p></p> 
 <figure> 
  <figcaption></figcaption> 
 </figure> 
 <p></p> 
 <h3 class="heading">1.1 输入事件处理准备工作</h3> 
 <p>当系统开机之后SystemServer会启动InputManagerService，在SystemServer.java中的startOtherServices()方法中启动：</p> 
 <pre><code class="hljs Java copyable">    Slog.i(TAG, <span class="hljs-string">"Input Manager"</span>);
    inputManager = <span class="hljs-keyword">new</span> InputManagerService(context);

    Slog.i(TAG, <span class="hljs-string">"Window Manager"</span>);
    wm = WindowManagerService.main(context, inputManager,
            mFactoryTestMode != FactoryTest.FACTORY_TEST_LOW_LEVEL,
            !mFirstBoot, mOnlyCore);
    ServiceManager.addService(Context.WINDOW_SERVICE, wm);
    ServiceManager.addService(Context.INPUT_SERVICE, inputManager);

    mActivityManagerService.setWindowManager(wm);

    inputManager.setWindowManagerCallbacks(wm.getInputMonitor());
    inputManager.start();
<span class="copy-code-btn">复制代码</span></code></pre> 
 <p>看一下InputManagerService的构造方法：</p> 
 <pre><code class="hljs Java copyable">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">InputManagerService</span><span class="hljs-params">(Context context)</span> </span>{
        <span class="hljs-keyword">this</span>.mContext = context;
        <span class="hljs-keyword">this</span>.mHandler = <span class="hljs-keyword">new</span> InputManagerHandler(DisplayThread.get().getLooper());

        mUseDevInputEventForAudioJack =
                context.getResources().getBoolean(R.bool.config_useDevInputEventForAudioJack);
        Slog.i(TAG, <span class="hljs-string">"Initializing input manager, mUseDevInputEventForAudioJack="</span>
                + mUseDevInputEventForAudioJack);
        mPtr = nativeInit(<span class="hljs-keyword">this</span>, mContext, mHandler.getLooper().getQueue());

        LocalServices.addService(InputManagerInternal.class, <span class="hljs-keyword">new</span> LocalService());
    }
<span class="copy-code-btn">复制代码</span></code></pre> 
 <p>主要是通过JNI的方式调用nativeInit方法传入一个消息队列作为参数，nativeInit对应是com_android_server_input_InputManagerService.cpp中的nativeInit。</p> 
 <pre><code class="hljs c++ copyable">    <span class="hljs-function"><span class="hljs-keyword">static</span> jlong <span class="hljs-title">nativeInit</span><span class="hljs-params">(JNIEnv* env, jclass <span class="hljs-comment">/* clazz */</span>,
            jobject serviceObj, jobject contextObj, jobject messageQueueObj)</span> </span>{
        sp&lt;MessageQueue&gt; messageQueue = android_os_MessageQueue_getMessageQueue(env, messageQueueObj);
        <span class="hljs-keyword">if</span> (messageQueue == <span class="hljs-literal">NULL</span>) {
            jniThrowRuntimeException(env, <span class="hljs-string">"MessageQueue is not initialized."</span>);
            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
        }
    
        NativeInputManager* im = <span class="hljs-keyword">new</span> NativeInputManager(contextObj, serviceObj,
                messageQueue-&gt;getLooper());
        im-&gt;incStrong(<span class="hljs-number">0</span>);
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">reinterpret_cast</span>&lt;jlong&gt;(im);
    }
<span class="copy-code-btn">复制代码</span></code></pre> 
 <p>这里又new了一个NativeInputManager的对象，构造的参数主要还是这个消息队列的Looper。继续看一下NativeInputManager的构造函数，还是在com_android_server_input_InputManagerService.cpp中。</p> 
 <pre><code class="hljs c++ copyable">    NativeInputManager::NativeInputManager(jobject contextObj,
            jobject serviceObj, <span class="hljs-keyword">const</span> sp&lt;Looper&gt;&amp; looper) :
            mLooper(looper), mInteractive(<span class="hljs-literal">true</span>) {
        JNIEnv* env = jniEnv();
    
        mContextObj = env-&gt;NewGlobalRef(contextObj);
        mServiceObj = env-&gt;NewGlobalRef(serviceObj);
    
        {
            AutoMutex _l(mLock);
            mLocked.systemUiVisibility = ASYSTEM_UI_VISIBILITY_STATUS_BAR_VISIBLE;
            mLocked.pointerSpeed = <span class="hljs-number">0</span>;
            mLocked.pointerGesturesEnabled = <span class="hljs-literal">true</span>;
            mLocked.showTouches = <span class="hljs-literal">false</span>;
        }
        mInteractive = <span class="hljs-literal">true</span>;
    
        sp&lt;EventHub&gt; eventHub = <span class="hljs-keyword">new</span> EventHub();
        mInputManager = <span class="hljs-keyword">new</span> InputManager(eventHub, <span class="hljs-keyword">this</span>, <span class="hljs-keyword">this</span>);
    }
<span class="copy-code-btn">复制代码</span></code></pre> 
 <p>这里主要就是new出了InputManager的实例，最后再看一下构造函数和initialize方法，代码位于frameworks/native/services/inputflinger/InputManager.cpp中。</p> 
 <pre><code class="hljs c++ copyable">    InputManager::InputManager(
            <span class="hljs-keyword">const</span> sp&lt;EventHubInterface&gt;&amp; eventHub,
            <span class="hljs-keyword">const</span> sp&lt;InputReaderPolicyInterface&gt;&amp; readerPolicy,
            <span class="hljs-keyword">const</span> sp&lt;InputDispatcherPolicyInterface&gt;&amp; dispatcherPolicy) {
        mDispatcher = <span class="hljs-keyword">new</span> InputDispatcher(dispatcherPolicy);
        mReader = <span class="hljs-keyword">new</span> InputReader(eventHub, readerPolicy, mDispatcher);
        initialize();
    }
    
    InputManager::InputManager(
            <span class="hljs-keyword">const</span> sp&lt;InputReaderInterface&gt;&amp; reader,
            <span class="hljs-keyword">const</span> sp&lt;InputDispatcherInterface&gt;&amp; dispatcher) :
            mReader(reader),
            mDispatcher(dispatcher) {
        initialize();
    }
    
    InputManager::~InputManager() {
        stop();
    }
    
    <span class="hljs-keyword">void</span> InputManager::initialize() {
        mReaderThread = <span class="hljs-keyword">new</span> InputReaderThread(mReader);
        mDispatcherThread = <span class="hljs-keyword">new</span> InputDispatcherThread(mDispatcher);
    }
<span class="copy-code-btn">复制代码</span></code></pre> 
 <p>在initialize中初始化了mReader和mDispatcher，以及两个相关的Thread。至此所需的关键对象都已经创建准备好，但是线程并未run起来。</p> 
 <h3 class="heading">1.2 启动事件读取和分发线程</h3> 
 <p>在SystemServer中启动InputManagerService之后，调用了start方法：</p> 
 <pre><code class="hljs Java copyable">    inputManager.setWindowManagerCallbacks(wm.getInputMonitor());
    inputManager.start();
<span class="copy-code-btn">复制代码</span></code></pre> 
 <p>在InputManagerService中的start方法中又调用了nativeStart方法，这个方法也是本地方法，具体实现在com_android_server_input_InputManagerService.cpp中。</p> 
 <pre><code class="copyable">static void nativeStart(JNIEnv* env, jclass /* clazz */, jlong ptr) {
    NativeInputManager* im = reinterpret_cast&lt;NativeInputManager*&gt;(ptr);

    status_t result = im-&gt;getInputManager()-&gt;start();
    if (result) {
        jniThrowRuntimeException(env, "Input manager could not be started.");
    }
}
<span class="copy-code-btn">复制代码</span></code></pre> 
 <p>接下来又调用了InputManager.cpp的start方法：</p> 
 <pre><code class="hljs c++ copyable">    <span class="hljs-keyword">status_t</span> InputManager::start() {
        <span class="hljs-keyword">status_t</span> result = mDispatcherThread-&gt;run(<span class="hljs-string">"InputDispatcher"</span>, PRIORITY_URGENT_DISPLAY);
        <span class="hljs-keyword">if</span> (result) {
            ALOGE(<span class="hljs-string">"Could not start InputDispatcher thread due to error %d."</span>, result);
            <span class="hljs-keyword">return</span> result;
        }
    
        result = mReaderThread-&gt;run(<span class="hljs-string">"InputReader"</span>, PRIORITY_URGENT_DISPLAY);
        <span class="hljs-keyword">if</span> (result) {
            ALOGE(<span class="hljs-string">"Could not start InputReader thread due to error %d."</span>, result);
    
            mDispatcherThread-&gt;requestExit();
            <span class="hljs-keyword">return</span> result;
        }
    
        <span class="hljs-keyword">return</span> OK;
    }
<span class="copy-code-btn">复制代码</span></code></pre> 
 <p>在这里将DispatcherThread和ReaderThread运行起来。</p> 
 <p>一张图总结下：</p> 
 <p></p> 
 <figure> 
  <figcaption></figcaption> 
 </figure> 
 <p></p> 
 <h3 class="heading">1.3 事件获取和分发</h3> 
 <p>首先由InputReaderThread等待按键消息到来，该thread在threadLoop中无尽的调用InputReader的loopOnce方法，代码位于frameworks/native/services/inputflinger/InputReader.cpp:</p> 
 <pre><code class="copyable">bool InputReaderThread::threadLoop() {
    mReader-&gt;loopOnce();
    return true;
}
<span class="copy-code-btn">复制代码</span></code></pre> 
 <p>在loopOnce方法中会通过EventHub来获取事件放入buffer中：</p> 
 <pre><code class="copyable">size_t count = mEventHub-&gt;getEvents(timeoutMillis, mEventBuffer, EVENT_BUFFER_SIZE);
<span class="copy-code-btn">复制代码</span></code></pre> 
 <p>frameworks/native/services/inputflinger/EventHub.cpp中的getEvents方法一部分：</p> 
 <pre><code class="copyable">size_t EventHub::getEvents(int timeoutMillis, RawEvent* buffer, size_t bufferSize) {
    ALOG_ASSERT(bufferSize &gt;= 1);

    AutoMutex _l(mLock);

    struct input_event readBuffer[bufferSize];

    RawEvent* event = buffer;
<span class="copy-code-btn">复制代码</span></code></pre> 
 <p>InputReader从设备文件(adb shell getevent就是读的这个文件)中读取的是RawEvent，在交给InputDispatcher进行分发之前，它需要先把RawEvent进行转化分类，拆分成KeyEvent、MotionEvent、TrackEvent各种类型等。如需了解拆分过程可以参照文章 <a href="https://link.juejin.im?target=http%3A%2F%2Fblog.csdn.net%2Fa345017062%2Farticle%2Fdetails%2F6417929" rel="nofollow">Android输入事件流程中的EventHub分析及源码演示</a> 来深入理解EventHub.cpp中的拆分过程。</p> 
 <p>在getEvents方法的最后来将队列中事件刷给监听器，监听器实际上就是InputDispatcher事件分发器。</p> 
 <pre><code class="hljs bash copyable"> // Flush queued events out to the listener. This must happen outside of the lock because the listener could potentially call back into the InputReader<span class="hljs-string">'s methods, such as getScanCodeState, or become blocked on another thread similarly waiting to acquire the InputReader lock thereby resulting in a deadlock. This situation is actually quite plausible because the listener is actually the input dispatcher, which calls into the window manager, which occasionally calls into the input reader.     
 mQueuedListener-&gt;flush();
</span><span class="copy-code-btn">复制代码</span></code></pre> 
 <p>然后会调用到frameworks/native/services/inputflinger/InputDispatcher.cpp的notifyKey方法。</p> 
 <pre><code class="copyable">KeyEvent event;
event.initialize(args-&gt;deviceId, args-&gt;source, args-&gt;action,
        flags, keyCode, args-&gt;scanCode, metaState, 0,
        args-&gt;downTime, args-&gt;eventTime);

mPolicy-&gt;interceptKeyBeforeQueueing(&amp;event, /*byref*/ policyFlags);
<span class="copy-code-btn">复制代码</span></code></pre> 
 <p>在notifyKey方法中通过InputDispatcherPolicyInterface接口来调用到NativeInputManager的interceptKeyBeforeQueueing方法通知是否需要在入队前对事件进行处理，然后接着调用InputDispatcher的enqueueInboundEventLocked方法将事件放入到队尾中。</p> 
 <pre><code class="hljs bash copyable">    KeyEntry* newEntry = new KeyEntry(args-&gt;eventTime,
            args-&gt;deviceId, args-&gt;<span class="hljs-built_in">source</span>, policyFlags,
            args-&gt;action, flags, keyCode, args-&gt;scanCode,
            metaState, repeatCount, args-&gt;downTime);

    needWake = enqueueInboundEventLocked(newEntry);
<span class="copy-code-btn">复制代码</span></code></pre> 
 <pre><code class="hljs bash copyable">    bool InputDispatcher::enqueueInboundEventLocked(EventEntry* entry) {
        bool needWake = mInboundQueue.isEmpty();
        mInboundQueue.enqueueAtTail(entry);
        traceInboundQueueLengthLocked();
    
        switch (entry-&gt;<span class="hljs-built_in">type</span>) {
<span class="copy-code-btn">复制代码</span></code></pre> 
 <p>以上流程是InputReader获取到设备事件通知分发器并存放到事件队列中。</p> 
 <p>下面将介绍InputDispatcher如何从事件队列中读取事件并分发出去。首先在InputDispatcherThread的threadLoop中无尽的调用dispatchOnce方法，该方法两个功能：1、调用dispatchOnceInnerLocked分发事件；2、调用runCommandsLockedInterruptible来处理CommandQueue中的命令，出队并处理，直到队列为空。</p> 
 <p>下面具体介绍事件的分发，如果当前没有挂起的命令即CommandQueue为空，则调用dispatchOnceInnerLocked方法来分发事件，这里也是android系统出现事件响应ANR的地方，在之前挂起的事件命令过多时就会导致新的事件无法分发导致ANR，在dispatchOnceInnerLocked中成功分发后会去调用resetANRTimeoutsLocked()来重置ANR的时间。</p> 
 <pre><code class="copyable">bool InputDispatcherThread::threadLoop() {
    mDispatcher-&gt;dispatchOnce();
    return true;
}

void InputDispatcher::dispatchOnce() {
    nsecs_t nextWakeupTime = LONG_LONG_MAX;
    { // acquire lock             AutoMutex _l(mLock);
        mDispatcherIsAliveCondition.broadcast();

        // Run a dispatch loop if there are no pending commands.             // The dispatch loop might enqueue commands to run afterwards.             if (!haveCommandsLocked()) {
            dispatchOnceInnerLocked(&amp;nextWakeupTime);
        }

        // Run all pending commands if there are any.             // If any commands were run then force the next poll to wake up immediately.             if (runCommandsLockedInterruptible()) {
            nextWakeupTime = LONG_LONG_MIN;
        }
    } // release lock     
    // Wait for callback or timeout or wake. (make sure we round up, not down)         nsecs_t currentTime = now();
    int timeoutMillis = toMillisecondTimeoutDelay(currentTime, nextWakeupTime);
    mLooper-&gt;pollOnce(timeoutMillis);
}
<span class="copy-code-btn">复制代码</span></code></pre> 
 <p>在dispatchOnceInnerLocked中会处理多种类型的事件，这里关注按键类型的（其他如触摸，设备重置等事件流程稍有区别）。如果Event类型为KEY，最后调用dispatchKeyLocked，再经过doInterceptKeyBeforeDispatchingLockedInterruptible这个方法之后就调用到了InputDispatcherPolicyInterface接口的interceptKeyBeforeDispatching方法。到这里就又很熟悉了，由NativeInputManager实现这个接口，然后又通过jni的方式调用到PhoneWindowManager的interceptKeyBeforeDispatching将按键事件分发传递给了java层。</p> 
 <pre><code class="copyable">case EventEntry::TYPE_KEY: {// 如果事件为按键类型         KeyEntry* typedEntry = static_cast&lt;KeyEntry*&gt;(mPendingEvent);
    if (isAppSwitchDue) {
        if (isAppSwitchKeyEventLocked(typedEntry)) {
            resetPendingAppSwitchLocked(true);
            isAppSwitchDue = false;
        } else if (dropReason == DROP_REASON_NOT_DROPPED) {
            dropReason = DROP_REASON_APP_SWITCH;
        }
    }
    if (dropReason == DROP_REASON_NOT_DROPPED
            &amp;&amp; isStaleEventLocked(currentTime, typedEntry)) {
        dropReason = DROP_REASON_STALE;
    }
    if (dropReason == DROP_REASON_NOT_DROPPED &amp;&amp; mNextUnblockedEvent) {
        dropReason = DROP_REASON_BLOCKED;
    }
    done = dispatchKeyLocked(currentTime, typedEntry, &amp;dropReason, nextWakeupTime);
    break;
}
<span class="copy-code-btn">复制代码</span></code></pre> 
 <p>事件的处理包括了两条主线：</p> 
 <ul><li>InputReader从EventHub中获取到按键事件，并通知InputDispatcher；InputDispatcher接到通知后调用interceptKeyBeforeQueueing方法进行相关的操作，并把按键事件加入到队列中，等待后面处理；</li><li>InputDispatcher从消息队列中获取按键消息，调用interceptKeyBeforeDispatching方法判断是否对此消息进行拦截。</li></ul> 
 <p></p> 
 <figure> 
  <figcaption></figcaption> 
 </figure> 
 <p></p> 
 <h3 class="heading">小结</h3> 
 <p>这一部分介绍了事件上报和处理机制，首先是准备工作，SystemServer启动InputManagerService，然后依次创建了NativeInputManager、InputManager、InputReader、InputDispatcher这几个关键的对象以及InputReaderThread和InputDispatcherThread这两个关键线程。然后让这个两个thread启动起来，在InputReaderThread无限循环运行时，通过InputReader从EventHub中不断读取events然后通知InputDispatcher将事件入队。而InputDispatcherThread则通过InputDispatcher不停的将队列中的事件分发出去，这就是整个input系统的基本机制。</p> 
</div>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/8ca1fe19f7371c4c4913a2c550fa5161/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">NUAActf string wp</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/34d9e3cad3f70cccf7f3578617e9793b/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">js原型及原型链</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>