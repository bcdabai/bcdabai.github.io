<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>矩阵的物理意义（二） - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="矩阵的物理意义（二）" />
<meta property="og:description" content="下面让我们把视力集中到一点以改变我们以往看待矩阵的方式。我们知道，线性空间里的基本对象是向量，而向量是这么表示的：
[a1, a2, a3, ..., an]
矩阵呢？矩阵是这么表示的：
a11, a12, a13, ..., a1n
a21, a22, a23, ..., a2n
...
an1, an2, an3, ..., ann
不用太聪明，我们就能看出来，矩阵是一组向量组成的。特别的，n维线性空间里的方阵是由n个n维向量组成的。我们在这里只讨论这个n阶的、非奇异的方阵，如果一组向量是彼此线性无关的话，那么它们就可以成为度量这个线性空间的一组基，从而事实上成为一个坐标系体系，其中每一个向量都躺在一根坐标轴上，并且成为那根坐标轴上的基本度量单位（长度1）。现在到了关键的一步。看上去矩阵就是由一组向量组成的，而且如果矩阵非奇异的话（我说了，只考虑这种情况），那么组成这个矩阵的那一组向量也就是线性无关的了，也就可以成为度量线性空间的一个坐标系。（方阵非奇异=矩阵可逆=矩阵满秩=矩阵行向量线性无关=矩阵列向量线性无关）结论：矩阵描述了一个坐标系。之所以矩阵又是运动，又是坐标系，那是因为——“运动等价于坐标系变换”。对不起，这话其实不准确，我只是想让你印象深刻。准确的说法是：“对象的变换等价于坐标系的变换”。或者：“固定坐标系下一个对象的变换等价于固定对象所处的坐标系变换。”说白了就是： “运动是相对的。” 让我们想想，达成同一个变换的结果，比如把点(1, 1)变到点(2, 3)去，你可以有两种做法。第一，坐标系不动，点动，把(1, 1)点挪到(2, 3)去。第二，点不动，变坐标系，让x轴的度量（单位向量）变成原来的1/2，让y轴的度量（单位向量）变成原先的1/3，这样点还是那个点，可是点的坐标就变成(2, 3)了。方式不同，结果一样。从第一个方式来看，那就是我在《理解矩阵》1/2中说的，把矩阵看成是运动描述，矩阵与向量相乘就是使向量（点）运动的过程。在这个方式下，
Ma = b的意思是：
“向量a经过矩阵M所描述的变换，变成了向量b。”
而从第二个方式来看，矩阵M描述了一个坐标系，姑且也称之为M。那么：
Ma = b的意思是：
“有一个向量，它在坐标系M的度量下得到的度量结果向量为a，那么它在坐标系I的度量下，这个向量的度量结果是b。”
这里的I是指单位矩阵，就是主对角线是1，其他为零的矩阵。而这两个方式本质上是等价的。我希望你务必理解这一点，因为这是本篇的关键。正因为是关键，所以我得再解释一下。在M为坐标系的意义下，如果把M放在一个向量a的前面，形成Ma的样式，我们可以认为这是对向量a的一个环境声明。它相当于是说： “注意了！这里有一个向量，它在坐标系M中度量，得到的度量结果可以表达为a。可是它在别的坐标系里度量的话，就会得到不同的结果。为了明确，我把M放在前面，让你明白，这是该向量在坐标系M中度量的结果。” 那么我们再看孤零零的向量b：
b 多看几遍，你没看出来吗？它其实不是b，它是：
Ib
也就是说：“在单位坐标系，也就是我们通常说的直角坐标系I中，有一个向量，度量的结果是b。”
而 Ma = Ib的意思就是说：
“在M坐标系里量出来的向量a，跟在I坐标系里量出来的向量b，其实根本就是一个向量啊！”这哪里是什么乘法计算，根本就是身份识别嘛。从这个意义上我们重新理解一下向量。向量这个东西客观存在，但是要把它表示出来，就要把它放在一个坐标系中去度量它，然后把度量的结果（向量在各个坐标轴上的投影值）按一定顺序列在一起，就成了我们平时所见的向量表示形式。你选择的坐标系（基）不同，得出来的向量的表示就不同。向量还是那个向量，选择的坐标系不同，其表示方式就不同。因此，按道理来说，每写出一个向量的表示，都应该声明一下这个表示是在哪个坐标系中度量出来的。表示的方式，就是 Ma，也就是说，有一个向量，在M矩阵表示的坐标系中度量出来的结果为a。我们平时说一个向量是[2 3 5 7]T，隐含着是说，这个向量在 I 坐标系中的度量结果是[2 3 5 7]T，因此，这个形式反而是一种简化了的特殊情况。
注意到，M矩阵表示出来的那个坐标系，由一组基组成，而那组基也是由向量组成的，同样存在这组向量是在哪个坐标系下度量而成的问题。也就是说，表述一个矩阵的一般方法，也应该要指明其所处的基准坐标系。所谓M，其实是 IM，也就是说，M中那组基的度量是在 I 坐标系中得出的。从这个视角来看，M×N也不是什么矩阵乘法了，而是声明了一个在M坐标系中量出的另一个坐标系N，其中M本身是在I坐标系中度量出来的。
回过头来说变换的问题。我刚才说，“固定坐标系下一个对象的变换等价于固定对象所处的坐标系变换”，那个“固定对象”我们找到了，就是那个向量。但是坐标系的变换呢？我怎么没看见？请看：
Ma = Ib" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/0391975e9d459a07f87e24a613e99183/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2014-07-28T00:03:25+08:00" />
<meta property="article:modified_time" content="2014-07-28T00:03:25+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">矩阵的物理意义（二）</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <span style="font-family:SimSun; font-size:18px"><span style="color:rgb(69,69,69)">下面让我们把视力集中到一点以改变我们以往看待矩阵的方式。我们知道，线性空间里的基本对象是向量，而向量是这么表示的：<br>         [a1, a2, a3, ..., an]<br> </span>矩阵呢？矩阵是这么表示的：<br>         a11, a12, a13, ..., a1n<br>         a21, a22, a23, ..., a2n<br>                  ...<br> </span> 
<p><span style="font-family:SimSun; font-size:18px">        an1, an2, an3, ..., ann</span></p> 
<p><span style="font-family:SimSun; font-size:18px">    不用太聪明，我们就能看出来，矩阵是一组向量组成的。特别的，n维线性空间里的方阵是由n个n维向量组成的。我们在<span style="color:#ff0000">这里只讨论这个n阶的、非奇异的方阵</span>，如果一组向量是彼此线性无关的话，那么它们就可以成为度量这个线性空间的一组基，从而事实上成为一个坐标系体系，其中每一个向量都躺在一根坐标轴上，并且成为那根坐标轴上的基本度量单位（长度1）。现在到了关键的一步。看上去矩阵就是由一组向量组成的，而且如果矩阵非奇异的话（我说了，只考虑这种情况），那么<span style="color:#ff0000">组成这个矩阵的那一组向量也就是线性无关的了</span>，<span style="color:#ff0000">也就可以成为度量线性空间的一个坐标系</span>。（<u style="background-color:rgb(255,255,255)"><span style="color:#cc66cc">方阵非奇异=</span><span style="color:#cc66cc; background-color:rgb(255,255,255)">矩阵可逆=矩阵满秩=矩阵行</span><span style="color:#cc66cc"><span style="background-color:rgb(255,255,255)">向量线性无</span>关=矩阵列向量线性无关</span></u></span><span style="color:rgb(51,51,51); line-height:24px; white-space:pre-wrap; font-family:SimSun; font-size:18px">）结论：矩阵描述了一个坐标系。之所以矩阵又是运动，又是坐标系，那是因为——“运动等价于坐标系变换”。对不起，这话其实不准确，我只是想让你印象深刻。准确的说法是：“</span><span style="color:#ff0000; line-height:24px; white-space:pre-wrap; font-family:SimSun; font-size:18px">对象的变换等价于坐标系的变换</span><span style="color:rgb(51,51,51); line-height:24px; white-space:pre-wrap; font-family:SimSun; font-size:18px">”。或者：“</span><span style="color:#ff0000; line-height:24px; white-space:pre-wrap; font-family:SimSun; font-size:18px">固定坐标系下一个对象的变换等价于固定对象所处的坐标系变换</span><span style="color:rgb(51,51,51); line-height:24px; white-space:pre-wrap; font-family:SimSun; font-size:18px">。”说白了就是： “运动是相对的。” </span></p> 
<p><span style="font-family:SimSun; font-size:18px">    让我们想想，达成同一个变换的结果，比如把点(1, 1)变到点(2, 3)去，你可以有两种做法。第一，坐标系不动，点动，把(1, 1)点挪到(2, 3)去。第二，点不动，变坐标系，让x轴的度量（单位向量）变成原来的1/2，让y轴的度量（单位向量）变成原先的1/3，这样点还是那个点，可是点的坐标就变成(2, 3)了。方式不同，结果一样。<span style="color:#ff0000">从第一个方式来看，那就是我在《理解矩阵》1/2中说的，把矩阵看成是运动描述，矩阵与向量相乘就是使向量（点）运动的过程。</span>在这个方式下，</span></p> 
<p><span style="font-family:SimSun; font-size:18px">    Ma = b的意思是：</span></p> 
<p><span style="font-family:SimSun; font-size:18px">    “向量a经过矩阵M所描述的变换，变成了向量b。”</span></p> 
<p><span style="font-family:SimSun; font-size:18px">    而从<span style="color:#ff0000">第二个方式</span>来看，矩阵M描述了一个坐标系，姑且也称之为M。那么：</span></p> 
<p><span style="font-family:SimSun; font-size:18px">    Ma = b的意思是：</span></p> 
<p><span style="font-family:SimSun; font-size:18px">    “有一个向量，它在坐标系M的度量下得到的度量结果向量为a，<span style="color:#ff0000">那么它在坐标系I的度量下</span>，这个向量的度量结果是b。”</span></p> 
<span style="font-family:SimSun; font-size:18px">    这里的I是指单位矩阵，就是主对角线是1，其他为零的矩阵。而<span style="color:#ff0000">这两个方式本质上是等价的</span>。我希望你务必理解这一点，因为这是本篇的关键。正因为是关键，所以我得再解释一下。在M为坐标系的意义下，如果把M放在一个向量a的前面，形成Ma的样式，我们可以认为这是对向量a的一个环境声明。它相当于是说： “注意了！<span style="color:#ff0000">这里有一个向量，它在坐标系M中度量，得到的度量结果可以表达为a</span>。可是它在别的坐标系里度量的话，就会得到不同的结果。为了明确，我把M放在前面，让你明白，这是该向量在坐标系M中度量的结果。” 那么我们再看孤零零的向量b：<br>        b          多看几遍，你没看出来吗？它其实不是b，它是：<br>        Ib<br>     也就是说：“在单位坐标系，也就是我们通常说的直角坐标系I中，有一个向量，度量的结果是b。”<br>     而 Ma = Ib的意思就是说：<br>    “在M坐标系里量出来的向量a，跟在I坐标系里量出来的向量b，其实根本就是一个向量啊！”这哪里是什么乘法计算，根本就是身份识别嘛。从这个意义上我们重新理解一下向量。向量这个东西客观存在，但是要把它表示出来，就要把它放在一个坐标系中去度量它，然后把度量的结果（向量在各个坐标轴上的投影值）按一定顺序列在一起，就成了我们平时所见的向量表示形式。你选择的坐标系（基）不同，得出来的向量的表示就不同。<span style="color:#ff0000">向量还是那个向量，选择的坐标系不同，其表示方式就不同。</span>因此，按道理来说，每写出一个向量的表示，都应该声明一下这个表示是在哪个坐标系中度量出来的。表示的方式，就是 Ma，也就是说，有一个向量，在M矩阵表示的坐标系中度量出来的结果为a。我们平时说一个向量是[2 3 5 7]T，隐含着是说，这个向量在 I 坐标系中的度量结果是[2 3 5 7]T，因此，这个形式反而是一种简化了的特殊情况。<br> <br>     注意到，M矩阵表示出来的那个坐标系，由一组基组成，而那组基也是由向量组成的，同样存在这组向量是在哪个坐标系下度量而成的问题。也就是说，表述一个矩阵的一般方法，也应该要指明其所处的基准坐标系。<span style="color:#ff0000">所谓M，其实是 IM，也就是说，M中那组基的度量是在 I 坐标系中得出的。</span>从这个视角来看，M×N也不是什么矩阵乘法了，而是声明了一个在M坐标系中量出的另一个坐标系N，其中M本身是在I坐标系中度量出来的。<br>     回过头来说变换的问题。我刚才说，“固定坐标系下一个对象的变换等价于固定对象所处的坐标系变换”，那个“固定对象”我们找到了，就是那个向量。但是坐标系的变换呢？我怎么没看见？请看：<br>     Ma = Ib<br>     我现在要变M为I，怎么变？对了，再前面乘以个M-1，也就是M的逆矩阵。换句话说，你不是有一个坐标系M吗，现在我让它乘以个M-1，变成I，这样一来的话，原来M坐标系中的a在I中一量，就得到b了。<br>     我建议你此时此刻拿起纸笔，画画图，求得对这件事情的理解。比如，你画一个坐标系，x轴上的衡量单位是2，y轴上的衡量单位是3，在这样一个坐标系里，坐标为(1，1)的那一点，实际上就是笛卡尔坐标系（直角坐标系）里的点(2, 3)。而让它原形毕露的办法，就是把原来那个坐标系:<br> 2 0<br> 0 3<br> 的x方向度量缩小为原来的1/2，而y方向度量缩小为原来的1/3，这样一来坐标系就变成单位坐标系I了。保持点不变，那个向量现在就变成了(2, 3)了。<br> 怎么能够让“x方向度量缩小为原来的1/2，而y方向度量缩小为原来的1/3”呢？就是让原坐标系：<br> 2 0<br> 0 3<br> 被矩阵：<br> 1/2 0<br> 0 1/3<br> 左乘。而这个矩阵就是原矩阵的逆矩阵。<br> 下面我们得出一个重要的结论：<br> “<span style="color:#ff0000">对坐标系施加变换的方法，就是让表示那个坐标系的矩阵与表示那个变化的矩阵相乘。</span>”<br>     再一次的，矩阵的乘法变成了运动的施加。只不过，被施加运动的不再是向量，而是另一个坐标系。<br>     如果你觉得你还搞得清楚，请再想一下刚才已经提到的结论，矩阵MxN（矩阵相乘），一方面表明坐标系N在运动M下的变换结果，另一方面，把M当成N的前缀，当成N的环境描述，那么就是说，在M坐标系度量下，有另一个坐标系N。这个坐标系N如果放在I坐标系中度量，其结果为坐标系MxN。<br>     在这里，我实际上已经回答了一般人在学习线性代数是最困惑的一个问题，那就是为什么矩阵的乘法要规定成这样。简单地说，是因为：<br>     1. 从变换的观点看，对坐标系N施加M变换，就是把组成坐标系N的每一个向量施加M变换。<br>     2. 从坐标系的观点看，在M坐标系中表现为N的另一个坐标系，这也归结为，对N坐标系基的每一个向量，把它在I坐标系中的坐标找出来，然后汇成一个新的矩阵。<br>     3. 至于矩阵乘以向量为什么要那样规定，那是因为一个在M中度量为a的向量，如果想要恢复在I中的真像，就必须分别与M中的每一个向量进行内积运算。我把这个结论的推导留给感兴趣的朋友吧。应该说，其实到了这一步，已经很容易了。<br> 综合以上1/2/3，矩阵的乘法就得那么规定，一切有根有据，绝不是哪个神经病胡思乱想出来的。<br> </span>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/25ed9358e3bc6ef1d501a7056d97fa28/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">Android解耦库EventBus的使用和源码分析</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/8eb256e9ae3c33367b179f296f76cf12/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">游戏外挂：劫持技术</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>