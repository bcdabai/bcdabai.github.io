<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>计算机组成原理知识点汇总（考研用）——第三章：存储系统 - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="计算机组成原理知识点汇总（考研用）——第三章：存储系统" />
<meta property="og:description" content="计算机组成原理知识点汇总（考研用）——第三章：存储系统 本文参考于《2021年计算机组成原理考研复习指导》（王道考研），《计算机组成原理》
思维导图：
文章目录 计算机组成原理知识点汇总（考研用）——第三章：存储系统3.存储系统3.1 存储器概述 3.1.1 存储器的分类 1.按在计算机中的作用（层次）分类 2.按存储介质分类 3.按存取方式分类 4.按信息的可保存性分类 3.1.2 存储器的性能指标 3.2 存储器的层次化结构 3.2.1 多级存储系统 3.3 半导体随机存储器 3.3.1 SRAM和DRAM 1.SRAM的工作原理 2.DRAM的工作原理 3.存储器的读、写周期 4.SRAM和DRAM的比较 3.3.2 只读存储器 1.只读存储器（ROM）的特点 2.ROM的类型 3.3.3 主存储器的基本组成 3.4 主存储器与CPU的连接 3.4.1 连接原理 3.4.2 主存容量的扩展 1.位扩展法 2.字扩展法 3.字位同时扩展法 3.4.3 存储芯片的地址分配和片选 1.线选法 2.译码片选法 3.4.4 存储器与CPU的连接 1.合理选择存储芯片 2.地址线的选择 3.数据线的选择 4.读/写命令线的连接 5.片选线的连接 3.5 双端口RAM和多模块存储器 3.5.1 双端口RAM 3.5.2 多模块存储器 1.单体多字存储器 2.多体并行存储器 3.6 高速缓冲存储器 3.6.1 程序访问的局部性原理 3.6.2 Cache的基本工作原理 3.6.3 Cache和主存的映射方式 1.直接映射 2." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/d29362ab252c246afe6557938073dc95/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2020-08-20T20:52:51+08:00" />
<meta property="article:modified_time" content="2020-08-20T20:52:51+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">计算机组成原理知识点汇总（考研用）——第三章：存储系统</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <h2><a id="_0"></a>计算机组成原理知识点汇总（考研用）——第三章：存储系统</h2> 
<p> 本文参考于《2021年计算机组成原理考研复习指导》（王道考研），《计算机组成原理》</p> 
<p><strong>思维导图：</strong><br> <img src="https://images2.imgbox.com/2e/e1/aJorxCh5_o.png" alt="在这里插入图片描述"></p> 
<p></p> 
<div class="toc"> 
 <h4>文章目录</h4> 
 <ul><li><a href="#_0" rel="nofollow">计算机组成原理知识点汇总（考研用）——第三章：存储系统</a></li><li><ul><li><a href="#3_7" rel="nofollow">3.存储系统</a></li><li><ul><li><a href="#31__8" rel="nofollow">3.1 存储器概述</a></li><li><ul><li><a href="#8195311__9" rel="nofollow"> 3.1.1 存储器的分类</a></li><li><ul><li><a href="#819581951_12" rel="nofollow">  1.按在计算机中的作用（层次）分类</a></li><li><a href="#819581952_21" rel="nofollow">  2.按存储介质分类</a></li><li><a href="#819581953_24" rel="nofollow">  3.按存取方式分类</a></li><li><a href="#819581954_32" rel="nofollow">  4.按信息的可保存性分类</a></li></ul> 
     </li><li><a href="#8195312__35" rel="nofollow"> 3.1.2 存储器的性能指标</a></li></ul> 
    </li><li><a href="#32__68" rel="nofollow">3.2 存储器的层次化结构</a></li><li><ul><li><a href="#8195321__69" rel="nofollow"> 3.2.1 多级存储系统</a></li></ul> 
    </li><li><a href="#33__85" rel="nofollow">3.3 半导体随机存储器</a></li><li><ul><li><a href="#8195331_SRAMDRAM_87" rel="nofollow"> 3.3.1 SRAM和DRAM</a></li><li><ul><li><a href="#819581951SRAM_88" rel="nofollow">  1.SRAM的工作原理</a></li><li><a href="#819581952DRAM_93" rel="nofollow">  2.DRAM的工作原理</a></li><li><a href="#819581953_104" rel="nofollow">  3.存储器的读、写周期</a></li><li><a href="#819581954SRAMDRAM_114" rel="nofollow">  4.SRAM和DRAM的比较</a></li></ul> 
     </li><li><a href="#8195332__117" rel="nofollow"> 3.3.2 只读存储器</a></li><li><ul><li><a href="#819581951ROM_118" rel="nofollow">  1.只读存储器（ROM）的特点</a></li><li><a href="#819581952ROM_120" rel="nofollow">  2.ROM的类型</a></li></ul> 
     </li><li><a href="#8195333__135" rel="nofollow"> 3.3.3 主存储器的基本组成</a></li></ul> 
    </li><li><a href="#34_CPU_193" rel="nofollow">3.4 主存储器与CPU的连接</a></li><li><ul><li><a href="#8195341__194" rel="nofollow"> 3.4.1 连接原理</a></li><li><a href="#8195342__202" rel="nofollow"> 3.4.2 主存容量的扩展</a></li><li><ul><li><a href="#819581951_204" rel="nofollow">  1.位扩展法</a></li><li><a href="#819581952_211" rel="nofollow">  2.字扩展法</a></li><li><a href="#819581953_221" rel="nofollow">  3.字位同时扩展法</a></li></ul> 
     </li><li><a href="#8195343__227" rel="nofollow"> 3.4.3 存储芯片的地址分配和片选</a></li><li><ul><li><a href="#819581951_230" rel="nofollow">  1.线选法</a></li><li><a href="#819581952_235" rel="nofollow">  2.译码片选法</a></li></ul> 
     </li><li><a href="#8195344_CPU_238" rel="nofollow"> 3.4.4 存储器与CPU的连接</a></li><li><ul><li><a href="#819581951_239" rel="nofollow">  1.合理选择存储芯片</a></li><li><a href="#819581952_241" rel="nofollow">  2.地址线的选择</a></li><li><a href="#819581953_244" rel="nofollow">  3.数据线的选择</a></li><li><a href="#819581954_246" rel="nofollow">  4.读/写命令线的连接</a></li><li><a href="#819581955_248" rel="nofollow">  5.片选线的连接</a></li></ul> 
    </li></ul> 
    </li><li><a href="#35_RAM_326" rel="nofollow">3.5 双端口RAM和多模块存储器</a></li><li><ul><li><a href="#8195351_RAM_328" rel="nofollow"> 3.5.1 双端口RAM</a></li><li><a href="#8195352__339" rel="nofollow"> 3.5.2 多模块存储器</a></li><li><ul><li><a href="#819581951_346" rel="nofollow">  1.单体多字存储器</a></li><li><a href="#819581952_350" rel="nofollow">  2.多体并行存储器</a></li></ul> 
    </li></ul> 
    </li><li><a href="#36__438" rel="nofollow">3.6 高速缓冲存储器</a></li><li><ul><li><a href="#8195361__440" rel="nofollow"> 3.6.1 程序访问的局部性原理</a></li><li><a href="#8195362_Cache_471" rel="nofollow"> 3.6.2 Cache的基本工作原理</a></li><li><a href="#8195363_Cache_502" rel="nofollow"> 3.6.3 Cache和主存的映射方式</a></li><li><ul><li><a href="#819581951_506" rel="nofollow">  1.直接映射</a></li><li><a href="#819581952_517" rel="nofollow">  2.全相联映射</a></li><li><a href="#819581953_523" rel="nofollow">  3.组相联映射</a></li></ul> 
     </li><li><a href="#8195364_Cache_558" rel="nofollow"> 3.6.4 Cache中主存块的替换算法</a></li><li><a href="#8195365_Cache_573" rel="nofollow"> 3.6.5 Cache写策略</a></li></ul> 
    </li><li><a href="#37__710" rel="nofollow">3.7 虚拟存储器</a></li><li><ul><li><a href="#8195371__713" rel="nofollow"> 3.7.1 虚拟存储器的基本概念</a></li><li><a href="#8195372__719" rel="nofollow"> 3.7.2 页式虚拟存储器</a></li><li><a href="#8195373_TLB_734" rel="nofollow"> 3.7.3 加快地址转换：快表（TLB）</a></li><li><a href="#8195374__747" rel="nofollow"> 3.7.4 段式虚拟存储器</a></li><li><a href="#8195375__752" rel="nofollow"> 3.7.5 段页式虚拟存储器</a></li><li><a href="#8195376_Cache_757" rel="nofollow"> 3.7.6 虚拟存储器与Cache的比较</a></li><li><ul><li><a href="#819581951_758" rel="nofollow">  1.相同之处</a></li><li><a href="#819581952_764" rel="nofollow">  2.不同之处</a></li></ul> 
    </li></ul> 
   </li></ul> 
  </li></ul> 
 </li></ul> 
</div> 
<p></p> 
<h3><a id="3_7"></a>3.存储系统</h3> 
<h4><a id="31__8"></a>3.1 存储器概述</h4> 
<h5><a id="8195311__9"></a> 3.1.1 存储器的分类</h5> 
<p><img src="https://images2.imgbox.com/37/91/imXv9soC_o.png" alt="在这里插入图片描述"></p> 
<h6><a id="819581951_12"></a>  1.按在计算机中的作用（层次）分类</h6> 
<ul><li> <p>（1）主存储器<br>   简称主存，又称内存储器（内存），用来存放计算机运行期间所需的大量程序和数据，CPU可直接随机地对其进行访问，也可以和高速缓冲存储器（Cache）及辅助存储器交换数据。其特点是容量较小、存取速度较快、每位价格较高。</p> </li><li> <p>（2）辅助存储器<br>   简称辅存，又称外存储器（外存），是主存的后援存储器，用来存放当前暂时不用的程序和数据，以及一些需要永久性保存的信息，它不能与CPU直接交换信息。其特点是容量极大、存取速度较慢、单位成本低。</p> </li><li> <p>（3）高速缓冲存储器<br>   简称Cache，位于主存和CPU之间，用来存放正在执行的程序段和数据，以便CPU能高速地使用它们。Cache的存取速度可与CPU的速度相匹配，但存储容量小、价格高。目前的高档计算机通常将它们制作在CPU中</p> </li></ul> 
<h6><a id="819581952_21"></a>  2.按存储介质分类</h6> 
<p>  按存储介质，存储器可分为磁表面存储器（磁盘、磁带）、磁心存储器、半导体存储器（MOS型存储器、双极型存储器）和光存储器（光盘）</p> 
<h6><a id="819581953_24"></a>  3.按存取方式分类</h6> 
<ul><li> <p>（1）随机存储器（RAM）。<mark>存储器的任何一个存储单元的内容都可以随机存取，而且存取时间与存储单元的物理位置无关。主要用作主存或高速缓冲存储器。</mark> RAM又分为静态RAM（以触发器原理寄存信息）和动态RAM（以电容充电原理寄存信息）</p> </li><li> <p>（2）只读存储器ROM。<mark>存储器的内容只能随机读出而不能写入。信息一旦写入存储器就固定不变，即使断电，内容也不会丢失。</mark> 通常用它存放固定不变的程序、常数和汉字字库，甚至用于OS的固化。它与随机存储器可共同作为主存的一部分，统一构成主存的地址域。<br>   由ROM派生出的存储器也包含可反复重写的类型，广义上的ROM已可通过电擦等方式进行写入，但其写入速度比读取速度慢得多。</p> </li><li> <p>（3）串行访问存储器。对存储单元进行读写操作时，需按其物理位置的先后顺序寻址，包括<mark>顺序存取存储器（如磁带）与直接存取存储器（如磁盘）</mark><br>   顺序存取存储器的内容只能按某种顺序存取，存取时间的长短与信息在存储体上的物理位置有关。直接存取存储器既不像RAM那样随机地访问任何一个存储单元，又不像顺序存取存储器那样完全按顺序存取，而是介于两者之间。<mark>存取信息时通常先寻找整个存储器中的某个小区域（如磁盘上的磁道），再在小区域内顺序查找。</mark></p> </li></ul> 
<h6><a id="819581954_32"></a>  4.按信息的可保存性分类</h6> 
<p>  断电后，存储信息即消失的存储器，称为易失性存储器，如RAM。断电后信息仍然保持的存储器，称为非易失性存储器，如ROM、磁表面存储器和光存储器。<mark>若某个存储单元所存储的信息被读出时，原存储信息被破坏，则称为破坏性读出。若读出时，被读单元原存储信息不被破坏，则称为非破坏性读出。具有破坏性读出性能的存储器，每次读出操作后，必须紧接一个再生的操作，以便恢复被破坏的信息。</mark></p> 
<h5><a id="8195312__35"></a> 3.1.2 存储器的性能指标</h5> 
<p>  存储器有3个主要性能指标，即存储容量、单位成本、存储速度。</p> 
<ul><li>（1）存储容量=存储字数x字长（如1M x 8位）。<mark>存储字数表示存储器的地址空间大小，字长表示一次存取操作的数据量</mark>。</li><li>（2）单位成本：每位价格=总成本/总容量</li><li>（3）存储速度：数据传输率=数据的宽度/存储周期<br>   a.存取时间（T<sub>a</sub>）：存取时间又称存储器的访问时间（Memory Access Time），是指从启动一次存储器操作到完成该操作所经历的时间，分为读出时间和写入时间。（读出时间是指从主存接收到有效地址开始到数据稳定为止的时间，写入时间是指从主存接收到有效地址开始到数据写入被写单元为止的时间）<br>   b.存取周期（T<sub>m</sub>）：存取周期又称读写周期或访问周期。<mark>它是指存储器进行一次完整的读写操作所需的全部时间，即连续两次独立访问存储器操作（读或写操作）之间所需的最小时间间隔</mark> （存取周期=存取时间+恢复时间）<br>   c.主存带宽（B<sub>m</sub>）：主存带宽又称数据传输率，表示每秒从主存进出信息的最大数量，单位为字/秒、字节/秒或位/秒。<br>   <mark>存取时间不等于存储周期，通常存储周期大于存取时间</mark>。这是因为对任何一种存储器，在读写操作之后，总要有一段恢复内部状态的复原时间。对于破坏性读出的存储器，存取周期往往比存取时间大得多，因为存储器中的信息读出后需要马上进行再生。<br> <img src="https://images2.imgbox.com/4c/92/gk2GTfIT_o.png" alt="在这里插入图片描述"></li></ul> 
<hr> 
<p>  一个操作数在内存中可能占多个单元，如何在指令中给出操作数的地址？<br>   现代计算机都采用字节编址方式，即一个内存单元只能存放一字节的信息。一个操作数可能占用1、2、4、8个内存单元。也即一个操作数可能有多个内存地址对应。<br>   有两种不同的地址指定方式：大端方式与小端方式<br>   大端方式：指令中给出的地址是操作数最高有效字节所在的地址<br>   小端方式：指令中给出的地址是操作数最低有效字节所在的地址</p> 
<p>  主存中存储单元地址的分配：<br>   主存各存储单元的空间位置是由单元地址号来表示的，而地址总线是用来指出存储单元地址号的，根据该地址可<mark>读出或写入一个存储字</mark>。通常计算机系统既可按字寻址，也可按字节寻址。例如IBM370的字长为32位，它可按字节寻址，<mark>即它的每个存储字包含4个可独立寻址的字节</mark>，其地址分配如图：<br> <img src="https://images2.imgbox.com/a0/44/0NkUgKtq_o.png" alt="在这里插入图片描述"><br>   <mark>字地址是用该字高位字节的地址来表示，故其字地址是4的整数倍</mark> ，正好用地址码的末二位来区分同一字的4个字节的位置。但对PDP-11机而言，其字长为16位，字地址是2的整数倍，它用低位字节的地址来表示字地址：<br> <img src="https://images2.imgbox.com/dc/c3/LVS3t0th_o.png" alt="在这里插入图片描述"></p> 
<hr> 
<h4><a id="32__68"></a>3.2 存储器的层次化结构</h4> 
<h5><a id="8195321__69"></a> 3.2.1 多级存储系统</h5> 
<p><img src="https://images2.imgbox.com/4f/ba/J6Ar947O_o.png" alt="在这里插入图片描述"><br>   存储系统层次结构主要体现在<mark>Cache-主存层次和主存-辅存层次</mark>。前者主要解决CPU与主存速度不匹配的问题，后者主要解决存储系统的容量问题。（主存与Cache之间的信息调度功能全部由硬件自动完成。而主存与辅存层次的调度目前广泛采用虚拟存储技术实现）在存储体系中，<mark>Cache、主存能与CPU直接交换信息，辅存则要通过主存与CPU交换信息；主存与CPU、Cache、辅存都能交换信息</mark>。<br> <img src="https://images2.imgbox.com/b8/60/r5Ix5Z34_o.png" alt="在这里插入图片描述"><br>   <mark>存储器层次结构的主要思想是上一层的存储器作为低一层存储器的高速缓存</mark>。从CPU角度看，Cache-主存层次速度接近于Cache，容量和价位却接近于主存。从主存-辅存层次分析，其速度接近于主存，容量和价位却接近于辅存。主存和Cache之间的数据调动是由硬件自动完成的，对所有程序员均是透明的；而主存和辅存之间的数据调动则是由硬件和OS共同完成的，对应用程序员是透明的。<br>   <mark>在Cache-主存和主存-辅存层次中，上一层中的内容都只是下一层中内容的副本，也即Cache（或主存）中的内容只是主存（或辅存）中内容的一部分。</mark><br>   在主存-辅存这一层次的不断发展中，逐渐形成了虚拟存储系统，在这个系统中<mark>程序员编程的地址范围与虚拟存储器的地址空间相对应。</mark> 对具有虚存的计算机系统而言，编程时可用的地址空间远大于主存空间。</p> 
<hr> 
<p>  例题：CPU执行一段程序时，Cache完成存取的次数为1900，主存完成存取的次数为100，已知Cache存取周期为50ns，主存存取周期为250ns。设主存与Cache同时访问。<br>   （1）Cache/主存系统的效率是多少；（2）平均访问时间是多少</p> 
<p>  答案：平均访问时间=60ns；<mark>Cache-主存系统的效率=访问Cache的时间/平均访问时间</mark>=83.3%</p> 
<hr> 
<h4><a id="33__85"></a>3.3 半导体随机存储器</h4> 
<p>  主存由DRAM实现，靠处理器的那一层（Cache）由SRAM实现，它们都属于易失性存储器。DRAM的每bit成本低于SRAM。</p> 
<h5><a id="8195331_SRAMDRAM_87"></a> 3.3.1 SRAM和DRAM</h5> 
<h6><a id="819581951SRAM_88"></a>  1.SRAM的工作原理</h6> 
<p>  通常把存放一个二进制位的物理器件称为存储元，它是存储器的最基本的构件。地址码相同的多个存储元构成一个存储单元。若干存储单元的集合构成存储体。当对某个基本单元电路进行读/写操作时，必须被行、列地址共同选中。<br>   静态随机存储器SRAM的存储元是用双稳态触发器（六晶体管MOS）来记忆信息的，因此<mark>即使信息被读出后，它仍保持其原状态而不需要再生（非破坏性读出)</mark>。<br>   SRAM的存取速度快，但集成度低，功耗较大，所以一般用来组成高速缓冲存储器。</p> 
<h6><a id="819581952DRAM_93"></a>  2.DRAM的工作原理</h6> 
<p>  动态随机存储器DRAM是利用存储元电路中栅极电容上的电荷来存储信息的，DRAM的基本存储元通常只使用一个晶体管，所以它比SRAM的密度要高很多。DRAM采用地址复用技术，地址线是原来的1/2，且地址信号分行、列两次传送。<br>   DRAM的存取速度比SRAM慢，一般用来组成大容量主存系统。<br>   DRAM电容上的电荷一般只能维持1~2ms，因此即使电源不断电，信息也会自动消失。为此，<mark>每隔一定时间必须刷新，通常取2ms，这个时间称为刷新周期</mark>。刷新的过程实质上是先将原存信息读出，再由刷新放大器形成原信息并重新写入的再生过程。刷新是一行行进行的。常用的刷新方式有3种：<mark>集中刷新、分散刷新、异步刷新</mark>。<br>   （1）集中刷新：<mark>指在一个刷新周期内，利用一段固定的时间，依次对存储器的所有行进行逐一再生，在此期间停止对存储器的读写操作，称为死时间，又称访存死区</mark>。<br>   集中刷新的优点是读写操作时不受刷新工作的影响，因此系统的存取速度较高；缺点是在集中刷新期间（死区）不能访存。<br>   （2）分散刷新：<mark>把对每行的刷新分散到各个工作周期中。</mark> 一个存储器的系统工作周期分为两部分：前半部分用于正常读、写或保持；后半部分用于刷新某一行。这种刷新方式增加了系统的存取周期。分散刷新的优点是没有死区；缺点是加长了系统的存取周期。<br>   （3）异步刷新：异步刷新是前两种方法的结合，它既可以缩短死时间，又能充分利用最大刷新间隔为2ms的特点。<mark>具体做法是将刷新周期除以行数，得到两次刷新操作之间的时间间隔t，利用逻辑电路每隔时间t产生一次刷新请求。</mark> 这样可以避免使CPU连续等待过长时间，而且减少了刷新次数。<br>   若将刷新安排在不需要访问存储器的译码阶段，则既不会加长存取周期，又不会产生死时间，这是分散刷新方式的发展，也称透明刷新<br>    <mark>DRAM刷新对CPU是透明的，即刷新不依赖于外部的访问；</mark> <mark>DRAM的刷新单位是行，刷新操作仅需要行地址</mark>；刷新类似于读操作，但又有所不同，刷新操作仅给栅极电容补充电荷，不需要信息输出。此外，刷新时不需要选片，即整个存储器中的所有芯片同时被刷新。</p> 
<h6><a id="819581953_104"></a>  3.存储器的读、写周期</h6> 
<ul><li>（1）RAM的读周期<br>   从给出有效地址开始，到读出所选中单元的内容并在外部数据总线上稳定地出现所需的时间，称为读出时间（t<sub>A</sub>）。地址片选信号<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
      
       
        
         
          
          
            C 
           
          
            S 
           
          
         
           ‾ 
          
         
        
       
         \overline{CS} 
        
       
     </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.88333em; vertical-align: 0em;"></span><span class="mord overline"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height: 0.88333em;"><span class="" style="top: -3em;"><span class="pstrut" style="height: 3em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right: 0.07153em;">C</span><span class="mord mathdefault" style="margin-right: 0.05764em;">S</span></span></span><span class="" style="top: -3.80333em;"><span class="pstrut" style="height: 3em;"></span><span class="overline-line" style="border-bottom-width: 0.04em;"></span></span></span></span></span></span></span></span></span></span>必须保持到数据稳定输出，t<sub>CO</sub>为片选的保持时间，在读周期中<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
      
       
        
         
          
          
            W 
           
          
            E 
           
          
         
           ‾ 
          
         
        
       
         \overline{WE} 
        
       
     </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.88333em; vertical-align: 0em;"></span><span class="mord overline"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height: 0.88333em;"><span class="" style="top: -3em;"><span class="pstrut" style="height: 3em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right: 0.13889em;">W</span><span class="mord mathdefault" style="margin-right: 0.05764em;">E</span></span></span><span class="" style="top: -3.80333em;"><span class="pstrut" style="height: 3em;"></span><span class="overline-line" style="border-bottom-width: 0.04em;"></span></span></span></span></span></span></span></span></span></span>为高电平。<br> <img src="https://images2.imgbox.com/b0/3d/8ygMA1OS_o.png" alt="在这里插入图片描述"><br>   读周期与读出时间是两个不同的概念，<mark>读周期时间（t<sub>RC</sub>）表示存储芯片进行两次连续读操作时所必须间隔的时间，它总是大于等于读出时间</mark>。</li><li>（2）RAM的写周期<br>   要实现写操作，要求片选信号<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
      
       
        
         
          
          
            C 
           
          
            S 
           
          
         
           ‾ 
          
         
        
       
         \overline{CS} 
        
       
     </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.88333em; vertical-align: 0em;"></span><span class="mord overline"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height: 0.88333em;"><span class="" style="top: -3em;"><span class="pstrut" style="height: 3em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right: 0.07153em;">C</span><span class="mord mathdefault" style="margin-right: 0.05764em;">S</span></span></span><span class="" style="top: -3.80333em;"><span class="pstrut" style="height: 3em;"></span><span class="overline-line" style="border-bottom-width: 0.04em;"></span></span></span></span></span></span></span></span></span></span>和写命令信号<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
      
       
        
         
          
          
            W 
           
          
            E 
           
          
         
           ‾ 
          
         
        
       
         \overline{WE} 
        
       
     </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.88333em; vertical-align: 0em;"></span><span class="mord overline"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height: 0.88333em;"><span class="" style="top: -3em;"><span class="pstrut" style="height: 3em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right: 0.13889em;">W</span><span class="mord mathdefault" style="margin-right: 0.05764em;">E</span></span></span><span class="" style="top: -3.80333em;"><span class="pstrut" style="height: 3em;"></span><span class="overline-line" style="border-bottom-width: 0.04em;"></span></span></span></span></span></span></span></span></span></span>必须都为低电平。为使数据总线上的信息能够可靠地写入存储器，要求<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
      
       
        
         
          
          
            C 
           
          
            S 
           
          
         
           ‾ 
          
         
        
       
         \overline{CS} 
        
       
     </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.88333em; vertical-align: 0em;"></span><span class="mord overline"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height: 0.88333em;"><span class="" style="top: -3em;"><span class="pstrut" style="height: 3em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right: 0.07153em;">C</span><span class="mord mathdefault" style="margin-right: 0.05764em;">S</span></span></span><span class="" style="top: -3.80333em;"><span class="pstrut" style="height: 3em;"></span><span class="overline-line" style="border-bottom-width: 0.04em;"></span></span></span></span></span></span></span></span></span></span>信号与<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
      
       
        
         
          
          
            W 
           
          
            E 
           
          
         
           ‾ 
          
         
        
       
         \overline{WE} 
        
       
     </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.88333em; vertical-align: 0em;"></span><span class="mord overline"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height: 0.88333em;"><span class="" style="top: -3em;"><span class="pstrut" style="height: 3em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right: 0.13889em;">W</span><span class="mord mathdefault" style="margin-right: 0.05764em;">E</span></span></span><span class="" style="top: -3.80333em;"><span class="pstrut" style="height: 3em;"></span><span class="overline-line" style="border-bottom-width: 0.04em;"></span></span></span></span></span></span></span></span></span></span>信号相"与"的宽度至少为t<sub>w</sub><br>   为保证在地址变化期间不会发生错误写入而破坏存储器的内容，<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
      
       
        
         
          
          
            W 
           
          
            E 
           
          
         
           ‾ 
          
         
        
       
         \overline{WE} 
        
       
     </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.88333em; vertical-align: 0em;"></span><span class="mord overline"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height: 0.88333em;"><span class="" style="top: -3em;"><span class="pstrut" style="height: 3em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right: 0.13889em;">W</span><span class="mord mathdefault" style="margin-right: 0.05764em;">E</span></span></span><span class="" style="top: -3.80333em;"><span class="pstrut" style="height: 3em;"></span><span class="overline-line" style="border-bottom-width: 0.04em;"></span></span></span></span></span></span></span></span></span></span>信号在地址变化期间必须为高电平。为了保证有效数据的可靠写入，地址有效的时间至少为t<sub>WC</sub>=t<sub>AW</sub>+t<sub>W</sub>+t<sub>WR</sub>。为了保证在<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
      
       
        
         
          
          
            W 
           
          
            E 
           
          
         
           ‾ 
          
         
        
       
         \overline{WE} 
        
       
     </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.88333em; vertical-align: 0em;"></span><span class="mord overline"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height: 0.88333em;"><span class="" style="top: -3em;"><span class="pstrut" style="height: 3em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right: 0.13889em;">W</span><span class="mord mathdefault" style="margin-right: 0.05764em;">E</span></span></span><span class="" style="top: -3.80333em;"><span class="pstrut" style="height: 3em;"></span><span class="overline-line" style="border-bottom-width: 0.04em;"></span></span></span></span></span></span></span></span></span></span>和<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
      
       
        
         
          
          
            C 
           
          
            S 
           
          
         
           ‾ 
          
         
        
       
         \overline{CS} 
        
       
     </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.88333em; vertical-align: 0em;"></span><span class="mord overline"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height: 0.88333em;"><span class="" style="top: -3em;"><span class="pstrut" style="height: 3em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right: 0.07153em;">C</span><span class="mord mathdefault" style="margin-right: 0.05764em;">S</span></span></span><span class="" style="top: -3.80333em;"><span class="pstrut" style="height: 3em;"></span><span class="overline-line" style="border-bottom-width: 0.04em;"></span></span></span></span></span></span></span></span></span></span>变为无效前能把数据可靠地写入，要求写入的数据必须在t<sub>DW</sub>以前在数据总线上已经稳定。<br> <img src="https://images2.imgbox.com/82/e1/lc9N82uF_o.png" alt="在这里插入图片描述"></li></ul> 
<h6><a id="819581954SRAMDRAM_114"></a>  4.SRAM和DRAM的比较</h6> 
<p><img src="https://images2.imgbox.com/f2/f7/FMp9Yxzl_o.png" alt="在这里插入图片描述"></p> 
<h5><a id="8195332__117"></a> 3.3.2 只读存储器</h5> 
<h6><a id="819581951ROM_118"></a>  1.只读存储器（ROM）的特点</h6> 
<p>  ROM和RAM都是支持随机存取的存储器，其中SRAM和DRAM均为易失性半导体存储器。而ROM中一旦有了信息，就不能轻易改变，即使掉电也不会丢失，它在计算机系统中是只供读出的存储器。ROM位密度比可读写存储器高，且可靠性高，具有非易失性。</p> 
<h6><a id="819581952ROM_120"></a>  2.ROM的类型</h6> 
<p>  ROM可分为掩模式只读存储器（MROM）、一次可编程只读存储器（PROM）、可擦除可编程只读存储器（EPROM）、闪速存储器（Flash Memory）和固态硬盘（Solid State Drives）</p> 
<ul><li> <p>（1）掩模式只读存储器<br>   MROM的内容由制造厂按用户要求写入，写入后无法更改。</p> </li><li> <p>（2）一次可编程只读存储器<br>   可实现一次性编程，写入后无法改变。</p> </li><li> <p>（3）可擦除可编程只读存储器<br>   可对内容多次改写。需要修改EPROM的内容时，先将其全部内容擦除，然后编程。EPROM又可分为紫外线擦除和电擦除（E<sup>2</sup>PROM）。EPROM不能取代RAM，因为其编程次数有限，且写入时间太长。</p> </li><li> <p>（4）闪速存储器（Flash Memory）<br>   <mark>主要特点是既可在不加电的情况下长期保存信息，又能在线进行快速擦除和重写。</mark></p> </li><li> <p>（5）固态硬盘（Solid State Drives,SSD）<br>   基于闪存的固态硬盘是用固态电子存储芯片阵列制成的硬盘，由控制单元和存储单元（Flash 芯片）组成。</p> </li></ul> 
<h5><a id="8195333__135"></a> 3.3.3 主存储器的基本组成</h5> 
<p><img src="https://images2.imgbox.com/81/0f/N4hlsYwm_o.png" alt="在这里插入图片描述"></p> 
<p>  由一个个存储0或1的记忆单元（也称存储元件）构成的存储矩阵（也称存储体）是存储器的核心部分。记忆单元是具有两种稳态的能表示二进制0和1的物理器件。为了存取存储体中的信息，须对存储单元编号（也称编址）。编址单位是具有相同地址的那些存储元件构成的一个单位，可按字节编址，也可按字编址。现代计算机通常采用字节编址方式，此时存储体内的一个地址中有1字节。<br>   指令执行过程中需要访问主存时，CPU首先把被访问单元的地址送到MAR中，然后通过地址线（单向）将主存地址送到主存中的地址寄存器，以便地址译码器进行译码选中相应单元，同时CPU将读写信号通过控制线送到主存的读写控制电路。如果是写操作，CPU同时将要写的信息送到MDR中，在读写控制电路的控制下，经数据线（双向）将信号写入选中的单元；如果是读操作，那么主存读出选中单元的内容送到数据线，然后送到MDR中。<mark>数据线的宽度与MDR的宽度相同，地址线的宽度与MAR的宽度相同。</mark> 上图中采用64位数据线，所以在按字节编址方式下，每次最多可存取8个单元的内容。地址线的位数决定了主存地址空间的最大可寻址范围。数据线和地址线数共同反映存储体容量的大小，上图芯片的容量=2<sup>36</sup>x64位。</p> 
<hr> 
<p>  例题：某一SRAM芯片，其容量为1024x8位，除电源和接地端外，该芯片的引脚的最小数目为：<br>   A.21   B.22   C.23  D.24</p> 
<p>  答案：A；地址线10根，数据线8根，加上片选线，读写控制线2根，共21根</p> 
<p>  例题：动态RAM采用下列哪种刷新方式时，不存在死时间<br>   A.集中刷新   B.分散刷新   C.异步刷新   D.都不对</p> 
<p>  答案：B;异步刷新虽然缩短了死时间，但死时间依然存在</p> 
<p>  例题：某一DRAM芯片，采用地址复用技术，其容量为1024x8位，除电源和接地端外，该芯片的引脚数最少是（）（读写控制线为两根）</p> 
<p>  A.16   B.17   C.19   D.20</p> 
<p>  答案：B；采用地址复用技术时，通过行通选和列通选分行、列两次传送地址信号，因此地址线减半为5根，数据线8根，加上行通选和列通选及读写控制线共4根，总共为17根。DRAM采用地址复用技术，而SRAM不采用。<br>   关于地址复用：1.地址复用技术只适用于DRAM，不适合于SRAM。2.地址复用技术的目的是为了减少地址线的数量，便于增加DRAM的集成度。3.<mark>地址复用技术的本质是分2次送行列地址</mark>，因为半导体存储芯片的核心存储矩阵是采用行列地址交叉确定存储单元，所以既可以像SRAM那样一次同时取得行列地址，提高运行速度，也可像DRAM那样分两次取得行列地址，减少地址线的数量。</p> 
<p>  例题：某容量为256MB的存储器由若干4Mx8位的DRAM芯片构成，该DRAM芯片的地址引脚和数据引脚总数是（）<br>   A.19   B.22   C.30   D.36</p> 
<p>  答案：A；11+8</p> 
<p>  例题：下列关于闪存的叙述中，错误的是（）<br>   A.信息可读可写，并且读、写速度一样快<br>   B.存储元由MOS管组成，是一种半导体存储器<br>   C.掉电后信息不丢失，是一种非易失性存储器<br>   D.采用随机访问方式，可替代计算机外部存储器</p> 
<p>  答案：A；<mark>闪存依然是ROM的一种，写入时必须擦除原有数据，因此写速度比读速度慢</mark>。对于D，SSD固态硬盘即由Flash芯片组成</p> 
<p>  例题：U盘属于（）类型的存储器<br>   A.高速缓存   B.主存   C.只读存储器   D.随机存取存储器</p> 
<p>  答案：C；随机存取和随机存储器（RAM）不同，只读存储器ROM也是随机存取的，因此，支持随机存取的存储器不一定是RAM</p> 
<p>  例题：在显示适配器中，用于存放显示信息的存储器称为刷新存储器，它的重要性能指标是带宽。具体工作中，显示适配器的多个功能部分要争用刷新存储器的带宽。设总带宽50%用于刷新屏幕，保留50%的带宽用于其他非刷新功能，且采用分辨率为1024x768像素、颜色深度为3B、刷新频率为72Hz的工作方式<br>   （1）计算刷新存储器的总带宽<br>   （2）为达到这样高的刷新存储器带宽，应采取何种技术措施</p> 
<p>  答案：（1）2x72x1024x768x3B/s=339.738MB/s<br>   （2）要提高刷新存储器带宽，可采用：a.采用高速DRAM芯片；b.采用多体交叉存储结构；c.刷新存储器至显示控制器的内部总线宽度加倍；d.采用双端口存储器将刷新端口和更新端口分开</p> 
<p>  例题：一个1K x 4位的动态RAM芯片，若其内部结构排列成64x64形式，且存取周期为0.1μs<br>   （1）若采用分散刷新和集中刷新（即异步刷新）相结合的方式，刷新信号周期应取多少<br>   （2）若采用集中刷新，则对该存储芯片刷新一遍需多少时间？死时间率是多少</p> 
<p>  答案：（1）需在2ms时间内刷新64行，刷新信号的时间间隔为2ms/64=31.25 μs，可取刷新周期为31μs；<br>   （2）刷新一遍需2ms，每次刷新一行需一个存取周期，死时间率为0.32%</p> 
<hr> 
<h4><a id="34_CPU_193"></a>3.4 主存储器与CPU的连接</h4> 
<h5><a id="8195341__194"></a> 3.4.1 连接原理</h5> 
<ul><li>（1）主存储器通过数据总线、地址总线和控制总线和CPU连接</li><li>（2）数据总线的位数与工作频率的乘积正比于数据传输率</li><li>（3）地址总线的位数决定了可寻址的最大内存空间</li><li>（4）控制总线（读/写）指出总线周期的类型和本次输入/输出操作完成的时刻<br> <img src="https://images2.imgbox.com/9d/a0/uLze0LpS_o.png" alt="在这里插入图片描述"></li></ul> 
<h5><a id="8195342__202"></a> 3.4.2 主存容量的扩展</h5> 
<p>  需要在字和位两方面进行扩充才能满足实际存储器的容量要求。通常采用<mark>位扩展法、字扩展法和字位同时扩展法</mark>来扩展主存容量</p> 
<h6><a id="819581951_204"></a>  1.位扩展法</h6> 
<p>  CPU的数据线数与存储芯片的数据位数不一定相等，此时必须对存储芯片扩位（即进行位扩展，用多个存储器件对字长进行扩充，增加存储字长），使其数据位数与CPU的数据线数相等。<br>   位扩展的连接方式是将多个存储芯片的地址端、片选端和读写控制端相应并联，数据端分别引出。<br>   用8片8K x 1位的RAM芯片组成8K x 8位的存储器。8片RAM芯片的地址线A<sub>12</sub>~A<sub>0</sub>、<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
        
         
         
           C 
          
         
           S 
          
         
        
          ‾ 
         
        
       
      
        \overline{CS} 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.88333em; vertical-align: 0em;"></span><span class="mord overline"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height: 0.88333em;"><span class="" style="top: -3em;"><span class="pstrut" style="height: 3em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right: 0.07153em;">C</span><span class="mord mathdefault" style="margin-right: 0.05764em;">S</span></span></span><span class="" style="top: -3.80333em;"><span class="pstrut" style="height: 3em;"></span><span class="overline-line" style="border-bottom-width: 0.04em;"></span></span></span></span></span></span></span></span></span></span>、<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
        
         
         
           W 
          
         
           E 
          
         
        
          ‾ 
         
        
       
      
        \overline{WE} 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.88333em; vertical-align: 0em;"></span><span class="mord overline"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height: 0.88333em;"><span class="" style="top: -3em;"><span class="pstrut" style="height: 3em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right: 0.13889em;">W</span><span class="mord mathdefault" style="margin-right: 0.05764em;">E</span></span></span><span class="" style="top: -3.80333em;"><span class="pstrut" style="height: 3em;"></span><span class="overline-line" style="border-bottom-width: 0.04em;"></span></span></span></span></span></span></span></span></span></span>都分别连在一起，<mark>每片的数据线依次作为CPU数据线的一位</mark><br> <img src="https://images2.imgbox.com/a2/51/dNOpOOZB_o.png" alt="在这里插入图片描述"><br>   仅使用位扩展时，各芯片连接地址线的方式相同，但连接数据线的方式不同，在某一时刻选中所有的芯片，所以<mark>片选信号<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
      
       
        
         
          
          
            C 
           
          
            S 
           
          
         
           ‾ 
          
         
        
       
         \overline{CS} 
        
       
     </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.88333em; vertical-align: 0em;"></span><span class="mord overline"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height: 0.88333em;"><span class="" style="top: -3em;"><span class="pstrut" style="height: 3em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right: 0.07153em;">C</span><span class="mord mathdefault" style="margin-right: 0.05764em;">S</span></span></span><span class="" style="top: -3.80333em;"><span class="pstrut" style="height: 3em;"></span><span class="overline-line" style="border-bottom-width: 0.04em;"></span></span></span></span></span></span></span></span></span></span>要连接到所有芯片</mark>。</p> 
<h6><a id="819581952_211"></a>  2.字扩展法</h6> 
<p>  字扩展是指增加存储器中字的数量，而位数不变。字扩展将芯片的地址线、数据线、读写控制线相应并联，而<mark>由片选信号来区分各芯片的地址范围</mark>。<br>   用4片16K x 8位的RAM芯片组成64K x 8位的存储器。4片RAM芯片的数据线D<sub>0</sub>~D<sub>7</sub>和<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
        
         
         
           W 
          
         
           E 
          
         
        
          ‾ 
         
        
       
      
        \overline{WE} 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.88333em; vertical-align: 0em;"></span><span class="mord overline"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height: 0.88333em;"><span class="" style="top: -3em;"><span class="pstrut" style="height: 3em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right: 0.13889em;">W</span><span class="mord mathdefault" style="margin-right: 0.05764em;">E</span></span></span><span class="" style="top: -3.80333em;"><span class="pstrut" style="height: 3em;"></span><span class="overline-line" style="border-bottom-width: 0.04em;"></span></span></span></span></span></span></span></span></span></span>都分别连在一起。将A<sub>15</sub>A<sub>14</sub>用作片选信号，A<sub>15</sub>A<sub>14</sub>=00时，译码器输出端0有效，选中最左边的1号芯片；A<sub>15</sub>A<sub>14</sub>=01时，译码器输出端1有效，选中2号芯片，依次类推（在同一时间内只能有一个芯片被选中）。各芯片的地址分配如下：<br>   第1片，最低地址：00 0000 0000 0000 0000 00;最高地址：00 1111 1111 1111 1111 11（16位）<br>   第2片，最低地址：01 0000 0000 0000 0000 00;最高地址：01 1111 1111 1111 1111 11（16位）<br>   第3片，最低地址：10 0000 0000 0000 0000 00;最高地址：10 1111 1111 1111 1111 11（16位）<br>   第4片，最低地址：11 0000 0000 0000 0000 00;最高地址：11 1111 1111 1111 1111 11（16位）<br> <img src="https://images2.imgbox.com/dc/52/ZNugoNvd_o.png" alt="在这里插入图片描述"><br>   仅采用字扩展时，各芯片连接地址线的方式相同，连接数据线的方式也相同，但在某一时刻只需选中部分芯片，所以<mark>通过片选信号<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
      
       
        
         
          
          
            C 
           
          
            S 
           
          
         
           ‾ 
          
         
        
       
         \overline{CS} 
        
       
     </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.88333em; vertical-align: 0em;"></span><span class="mord overline"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height: 0.88333em;"><span class="" style="top: -3em;"><span class="pstrut" style="height: 3em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right: 0.07153em;">C</span><span class="mord mathdefault" style="margin-right: 0.05764em;">S</span></span></span><span class="" style="top: -3.80333em;"><span class="pstrut" style="height: 3em;"></span><span class="overline-line" style="border-bottom-width: 0.04em;"></span></span></span></span></span></span></span></span></span></span>或采用译码器设计连接到相应的芯片</mark>。</p> 
<h6><a id="819581953_221"></a>  3.字位同时扩展法</h6> 
<p>  字位同时扩展指既增加存储字的数量，又增加存储字长。<br>   用8片16K x 4位的RAM芯片组成64K x 8位的存储器。每两片构成一组16K x 8位的存储器（位扩展），4组便构成64K x 8位的存储器（字扩展）。地址线A<sub>15</sub>A<sub>14</sub>经译码器得到4个片选信号。<br> <img src="https://images2.imgbox.com/ea/b7/eBZjypwt_o.png" alt="在这里插入图片描述"><br>   采用字位同时扩展时，<mark>各芯片连接地址线的方式相同，但连接数据线的方式不同，而且需要通过片选信号<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
      
       
        
         
          
          
            C 
           
          
            S 
           
          
         
           ‾ 
          
         
        
       
         \overline{CS} 
        
       
     </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.88333em; vertical-align: 0em;"></span><span class="mord overline"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height: 0.88333em;"><span class="" style="top: -3em;"><span class="pstrut" style="height: 3em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right: 0.07153em;">C</span><span class="mord mathdefault" style="margin-right: 0.05764em;">S</span></span></span><span class="" style="top: -3.80333em;"><span class="pstrut" style="height: 3em;"></span><span class="overline-line" style="border-bottom-width: 0.04em;"></span></span></span></span></span></span></span></span></span></span>或采用译码器设计连接到相应的芯片</mark>。</p> 
<h5><a id="8195343__227"></a> 3.4.3 存储芯片的地址分配和片选</h5> 
<p>  CPU要实现对存储单元的访问，首先要选择存储芯片，即进行片选；然后为选中的芯片依地址码选择相应的存储单元，以进行数据的存取，即进行<mark>字选</mark>。片内的字选通常是由CPU送出的N条低位地址线完成的，地址线直接接到所有存储芯片的地址输入端（N由片内存储容量2<sup>n</sup>决定）。<mark>片选信号的产生分为线选法和译码片选法</mark>。</p> 
<h6><a id="819581951_230"></a>  1.线选法</h6> 
<p>  <mark>线选法用除片内寻址外的高位地址线直接（或经反相器）分别连接至各个存储芯片的片选端，当某地址线信息为0时，就选中与之对应的存储芯片。</mark> 这些片选地址线每次寻址时只能有一位有效，不允许同时有多位有效，这样才能保证每次只选中一个芯片（或芯片组）。假设4片2K x 8位存储芯片用线选法构成8K x 8位存储器，各芯片的片选信号如下：（其中低位地址线A<sub>10</sub>~A<sub>0</sub>作为字选线，用于片内寻址）<br> <img src="https://images2.imgbox.com/84/0e/TlE3nO51_o.png" alt="在这里插入图片描述"><br>   线选法不需要地址译码器，但地址空间不连续，选片的地址线必须分时为低电平，不能充分利用系统的存储器空间，造成地址资源的浪费</p> 
<h6><a id="819581952_235"></a>  2.译码片选法</h6> 
<p>  <mark>译码片选法用除片内寻址外的高位地址线通过地址译码器芯片产生片选信号</mark>。如用8片8K x 8位的存储芯片组成64K x 8位存储器（地址线为16位，数据线为8位），需要8个片选信号；若采用线选法，除去片内寻址的13位地址线，仅余高3位，不足以产生8个片选信号。因此，采用译码片选法，即用一片74LS138作为地址译码器，则A<sub>15</sub>A<sub>14</sub>A<sub>13</sub>=000时选第一片，以此类推。</p> 
<h5><a id="8195344_CPU_238"></a> 3.4.4 存储器与CPU的连接</h5> 
<h6><a id="819581951_239"></a>  1.合理选择存储芯片</h6> 
<p>  合理选择存储芯片主要指存储芯片的类型（RAM或ROM）和数量的选择。通常选用ROM存放系统程序、标准子程序和各类常数，RAM则是为用户编程而设置的。</p> 
<h6><a id="819581952_241"></a>  2.地址线的选择</h6> 
<p>  CPU的地址线数往往比存储芯片的地址线数要多。<mark>通常将CPU地址线的低位与存储芯片的地址线相连，以选择芯片中的某一单元（字选）</mark>，这部分的译码通常是由芯片的片内逻辑完成的。<mark>而CPU地址线的高位则在扩充存储芯片时使用，用来选择存储芯片（片选）</mark>，这部分译码由外接译码器逻辑完成。<br>   例如，设CPU地址线为16位，即A<sub>15</sub>~A<sub>0</sub>,1K x 4位的存储芯片仅有10根地址线，此时可将CPU的低位地址A<sub>9</sub>~ A<sub>0</sub>与存储芯片的地址线A<sub>9</sub>~A<sub>0</sub>相连</p> 
<h6><a id="819581953_244"></a>  3.数据线的选择</h6> 
<p>  CPU的数据线数与存储芯片的数据线数不一定相等，在相等时可直接相连；在不等时必须对存储芯片扩位，使其数据位数与CPU的数据线数相等。</p> 
<h6><a id="819581954_246"></a>  4.读/写命令线的连接</h6> 
<p>  CPU的读写命令线一般可直接与存储芯片的读/写控制端相连，通常高电平为读，低电平为写。有些CPU的读/写命令线是分开的（读为<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
        
         
         
           R 
          
         
           D 
          
         
        
          ‾ 
         
        
       
      
        \overline{RD} 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.88333em; vertical-align: 0em;"></span><span class="mord overline"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height: 0.88333em;"><span class="" style="top: -3em;"><span class="pstrut" style="height: 3em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right: 0.00773em;">R</span><span class="mord mathdefault" style="margin-right: 0.02778em;">D</span></span></span><span class="" style="top: -3.80333em;"><span class="pstrut" style="height: 3em;"></span><span class="overline-line" style="border-bottom-width: 0.04em;"></span></span></span></span></span></span></span></span></span></span>，写为<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
        
         
         
           W 
          
         
           E 
          
         
        
          ‾ 
         
        
       
      
        \overline{WE} 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.88333em; vertical-align: 0em;"></span><span class="mord overline"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height: 0.88333em;"><span class="" style="top: -3em;"><span class="pstrut" style="height: 3em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right: 0.13889em;">W</span><span class="mord mathdefault" style="margin-right: 0.05764em;">E</span></span></span><span class="" style="top: -3.80333em;"><span class="pstrut" style="height: 3em;"></span><span class="overline-line" style="border-bottom-width: 0.04em;"></span></span></span></span></span></span></span></span></span></span>，均为低电平有效），此时CPU的读命令线应与存储芯片的允许读控制端相连，而CPU的写命令线则应与存储芯片的允许写控制端相连。</p> 
<h6><a id="819581955_248"></a>  5.片选线的连接</h6> 
<p>  片选线的连接是CPU与存储芯片连接的关键。存储器由许多存储芯片叠加而成，哪一片被选中完全取决于该存储芯片的片选控制端<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
        
         
         
           C 
          
         
           S 
          
         
        
          ‾ 
         
        
       
      
        \overline{CS} 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.88333em; vertical-align: 0em;"></span><span class="mord overline"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height: 0.88333em;"><span class="" style="top: -3em;"><span class="pstrut" style="height: 3em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right: 0.07153em;">C</span><span class="mord mathdefault" style="margin-right: 0.05764em;">S</span></span></span><span class="" style="top: -3.80333em;"><span class="pstrut" style="height: 3em;"></span><span class="overline-line" style="border-bottom-width: 0.04em;"></span></span></span></span></span></span></span></span></span></span>是否能收到来自CPU的片选有效信号。<br>   <mark>片选有效信号与CPU的访存控制信号<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
      
       
        
         
          
          
            M 
           
          
            R 
           
          
            E 
           
          
            Q 
           
          
         
           ‾ 
          
         
        
       
         \overline{MREQ} 
        
       
     </span><span class="katex-html"><span class="base"><span class="strut" style="height: 1.07777em; vertical-align: -0.19444em;"></span><span class="mord overline"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.88333em;"><span class="" style="top: -3em;"><span class="pstrut" style="height: 3em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right: 0.10903em;">M</span><span class="mord mathdefault" style="margin-right: 0.00773em;">R</span><span class="mord mathdefault" style="margin-right: 0.05764em;">E</span><span class="mord mathdefault">Q</span></span></span><span class="" style="top: -3.80333em;"><span class="pstrut" style="height: 3em;"></span><span class="overline-line" style="border-bottom-width: 0.04em;"></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.19444em;"><span class=""></span></span></span></span></span></span></span></span></span>（低电平有效）有关，因为只有当CPU要求访存时，才要求选中存储芯片</mark>。若CPU访问I/O,则<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
        
         
         
           M 
          
         
           R 
          
         
           E 
          
         
           Q 
          
         
        
          ‾ 
         
        
       
      
        \overline{MREQ} 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 1.07777em; vertical-align: -0.19444em;"></span><span class="mord overline"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.88333em;"><span class="" style="top: -3em;"><span class="pstrut" style="height: 3em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right: 0.10903em;">M</span><span class="mord mathdefault" style="margin-right: 0.00773em;">R</span><span class="mord mathdefault" style="margin-right: 0.05764em;">E</span><span class="mord mathdefault">Q</span></span></span><span class="" style="top: -3.80333em;"><span class="pstrut" style="height: 3em;"></span><span class="overline-line" style="border-bottom-width: 0.04em;"></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.19444em;"><span class=""></span></span></span></span></span></span></span></span></span>为高，表示不要求存储器工作。</p> 
<hr> 
<p>  例题：假定用若干2K x 4位的芯片组成一个8K x 8位的存储器，则地址0B1FH所在芯片的最小地址是（）<br>   A.0000H  B.0600H  C.0700H  D.0800H</p> 
<p>  答案：D；各组的地址分配：第一组：0000H~07FFH；<br>   第二组：0800H ~0FFFH；第三组：1000H ~17FFH；<br>   第四组：1800H~1FFFH；</p> 
<p>  例题：80386DX是32位系统，以4B为编址单位，当在该系统中用8KB（8K x 8位）的存储芯片构造32KB的存储体时，应完成存储器的（）设计<br>   A.位扩展  B.字扩展  C.字位扩展  D.字位均不扩展</p> 
<p>  答案：A；</p> 
<p>  例题：地址总线A<sub>0</sub>（高位）~A<sub>15</sub>（低位），用4K x 4位的存储芯片组成16KB存储器，则产生片选信号的译码器的输入地址线应该是（）</p> 
<p>  答案：A；</p> 
<p>  例题：<img src="https://images2.imgbox.com/e4/9a/MMJHtdAn_o.png" alt="在这里插入图片描述"></p> 
<p>  答案：D；</p> 
<p>  例题：主存储器的地址寄存器和数据寄存器各自的作用是什么？设一个1MB容量的存储器，字长为32位，问：<br>   （1）按字节编址，地址寄存器和数据寄存器各几位？编址范围为多大？<br>   （2）按字编址，地址寄存器和数据寄存器各几位？编址范围为多大？</p> 
<p>  答案：在存储器中，MAR用来存放当前CPU访问的内存单元地址，或存放CPU写入内存的内存单元地址。MDR用于存放由内存中读出的信息或写入内存的信息<br>   （1）20位、8位，编址范围00000H~FFFFFH；<br>   （2）18位、32位，00000H~3FFFFH</p> 
<p>  例题：有一组16K x 16位的存储器，由1K x 4位的DRAM芯片构成（芯片是64x64结构）<br>   （1）共需要多少RAM芯片<br>   （2）采用异步刷新方式，如单元刷新间隔不超过2ms，则刷新信号周期是多少</p> 
<p>  答案：（1）64；（2）<mark>刷新时不需要选片，整个存储器中的所有芯片同时被刷新</mark>，2ms/64=31.25μs，可取刷新信号周期为31μs</p> 
<p>  例题：设有32片256K x 1位的SRAM芯片<br>   （1）采用位扩展方法可构成多大容量的存储器<br>   （2）采用32位的字编址方式，该存储器需要多少地址线<br>   （3）画出该存储器与CPU连接的结构图，设CPU的接口信号有地址信号、数据信号和控制信号<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
        
         
         
           M 
          
         
           R 
          
         
           E 
          
         
           Q 
          
         
        
          ‾ 
         
        
       
      
        \overline{MREQ} 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 1.07777em; vertical-align: -0.19444em;"></span><span class="mord overline"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.88333em;"><span class="" style="top: -3em;"><span class="pstrut" style="height: 3em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right: 0.10903em;">M</span><span class="mord mathdefault" style="margin-right: 0.00773em;">R</span><span class="mord mathdefault" style="margin-right: 0.05764em;">E</span><span class="mord mathdefault">Q</span></span></span><span class="" style="top: -3.80333em;"><span class="pstrut" style="height: 3em;"></span><span class="overline-line" style="border-bottom-width: 0.04em;"></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.19444em;"><span class=""></span></span></span></span></span></span></span></span></span>、<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
        
         
         
           W 
          
         
           E 
          
         
        
          ‾ 
         
        
       
      
        \overline{WE} 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.88333em; vertical-align: 0em;"></span><span class="mord overline"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height: 0.88333em;"><span class="" style="top: -3em;"><span class="pstrut" style="height: 3em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right: 0.13889em;">W</span><span class="mord mathdefault" style="margin-right: 0.05764em;">E</span></span></span><span class="" style="top: -3.80333em;"><span class="pstrut" style="height: 3em;"></span><span class="overline-line" style="border-bottom-width: 0.04em;"></span></span></span></span></span></span></span></span></span></span></p> 
<p>  答案：（1）256K x 32位;（2）18；（3）用<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
        
         
         
           M 
          
         
           R 
          
         
           E 
          
         
           Q 
          
         
        
          ‾ 
         
        
       
      
        \overline{MREQ} 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 1.07777em; vertical-align: -0.19444em;"></span><span class="mord overline"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.88333em;"><span class="" style="top: -3em;"><span class="pstrut" style="height: 3em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right: 0.10903em;">M</span><span class="mord mathdefault" style="margin-right: 0.00773em;">R</span><span class="mord mathdefault" style="margin-right: 0.05764em;">E</span><span class="mord mathdefault">Q</span></span></span><span class="" style="top: -3.80333em;"><span class="pstrut" style="height: 3em;"></span><span class="overline-line" style="border-bottom-width: 0.04em;"></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.19444em;"><span class=""></span></span></span></span></span></span></span></span></span>作片选信号，<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
        
         
         
           W 
          
         
           E 
          
         
        
          ‾ 
         
        
       
      
        \overline{WE} 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.88333em; vertical-align: 0em;"></span><span class="mord overline"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height: 0.88333em;"><span class="" style="top: -3em;"><span class="pstrut" style="height: 3em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right: 0.13889em;">W</span><span class="mord mathdefault" style="margin-right: 0.05764em;">E</span></span></span><span class="" style="top: -3.80333em;"><span class="pstrut" style="height: 3em;"></span><span class="overline-line" style="border-bottom-width: 0.04em;"></span></span></span></span></span></span></span></span></span></span>作读写控制信号，CPU访存地址为A<sub>19</sub>~A<sub>2</sub>，最高地址位为A<sub>19</sub>（A<sub>0</sub>、A<sub>1</sub>保留，在字节编址时使用）：<br> <img src="https://images2.imgbox.com/df/8b/q4wuMlx1_o.png" alt="在这里插入图片描述"></p> 
<p>  例题：某机主存空间为64KB，I/O空间与主存单元统一编址，I/O空间占用1KB，范围为FC00H~FFFFH。可选用8K x 8位和1K x 8位两种SRAM芯片构成主存储器，<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
        
         
         
           R 
          
         
           D 
          
         
        
          ‾ 
         
        
       
      
        \overline{RD} 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.88333em; vertical-align: 0em;"></span><span class="mord overline"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height: 0.88333em;"><span class="" style="top: -3em;"><span class="pstrut" style="height: 3em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right: 0.00773em;">R</span><span class="mord mathdefault" style="margin-right: 0.02778em;">D</span></span></span><span class="" style="top: -3.80333em;"><span class="pstrut" style="height: 3em;"></span><span class="overline-line" style="border-bottom-width: 0.04em;"></span></span></span></span></span></span></span></span></span></span>和<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
        
         
         
           W 
          
         
           R 
          
         
        
          ‾ 
         
        
       
      
        \overline{WR} 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.88333em; vertical-align: 0em;"></span><span class="mord overline"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height: 0.88333em;"><span class="" style="top: -3em;"><span class="pstrut" style="height: 3em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right: 0.13889em;">W</span><span class="mord mathdefault" style="margin-right: 0.00773em;">R</span></span></span><span class="" style="top: -3.80333em;"><span class="pstrut" style="height: 3em;"></span><span class="overline-line" style="border-bottom-width: 0.04em;"></span></span></span></span></span></span></span></span></span></span>分别为系统提供的读写信号线。画出该存储器的逻辑图，并标明每块芯片的地址范围</p> 
<p>  答案：<mark>由于64KB存储空间中，I/O占用了最高的1KB空间（FC00H~FFFFH），RAM芯片应当分配在余下的低63KB空间中。选用7片8K x 8位芯片和7片1K x 8位芯片</mark>，共计63KB<br>   8K x 8RAM芯片片内地址应有13根，连接地址线A<sub>12</sub>~A<sub>0</sub>，每片的地址范围为0000H ~1FFFH<br>   64KB的存储器应有64K个存储单元，地址线有16根。地址范围为0000H~FFFFH<br>   地址线A<sub>12</sub>~A<sub>0</sub>并行连接到7片8K x 8位RAM芯片的13个地址端，用3根高地址线A<sub>15</sub>、A<sub>14</sub>、A<sub>13</sub>经3/8译码器译码，译码器的7个输出端（000~110）分别连接到7片8K x 8位芯片的片选端，用以选择7片8K x 8位芯片中的1片。<mark>剩下的1个输出端111用以控制另一个3/8译码器</mark>。<br>   1Kx8的存储器共有1K个存储单元，地址线应有10根，地址范围为000H~ 3FFH。地址线A<sub>9</sub>~A<sub>0</sub>，并行连接到7片1K x 8位RAM芯片的10个地址端。3根地址线A<sub>12</sub>、A<sub>11</sub>、A<sub>10</sub>经3/8译码器译码，译码器的7个输出端（000~110）分别连接到7片1K x 8位芯片的片选端，用以选择7片1K x 8位芯片中的1片。<br> <img src="https://images2.imgbox.com/33/24/MPoOhm8z_o.png" alt="在这里插入图片描述"></p> 
<p>  地址范围：<br>   U<sub>0</sub>：0000H~ 1FFFH；U<sub>1</sub>：2000H~ 3FFFH；U<sub>2</sub>：4000H~ 5FFFH；<br>   U<sub>3</sub>：6000H~ 7FFFH；U<sub>4</sub>：8000H~ 9FFFH；U<sub>5</sub>：A000H~ BFFFH；<br>   U<sub>6</sub>：C000H~ DFFFH；<br>   U<sub>7</sub>：E000H~ E3FFH；U<sub>8</sub>：E400H~ E7FFH；U<sub>9</sub>：E800H~ EBFFH；<br>   U<sub>10</sub>：EC00H~ EFFFH；U<sub>11</sub>：F000H~ F3FFH；U<sub>12</sub>：F400H~ F7FFH；<br>   U<sub>13</sub>：F800H~ FBFFH；<br>   余下的FC00H~FFFFH为I/O空间</p> 
<p>  例题：设CPU有16根地址线，8根数据线，并用<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
        
         
         
           M 
          
         
           R 
          
         
           E 
          
         
           Q 
          
         
        
          ‾ 
         
        
       
      
        \overline{MREQ} 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 1.07777em; vertical-align: -0.19444em;"></span><span class="mord overline"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.88333em;"><span class="" style="top: -3em;"><span class="pstrut" style="height: 3em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right: 0.10903em;">M</span><span class="mord mathdefault" style="margin-right: 0.00773em;">R</span><span class="mord mathdefault" style="margin-right: 0.05764em;">E</span><span class="mord mathdefault">Q</span></span></span><span class="" style="top: -3.80333em;"><span class="pstrut" style="height: 3em;"></span><span class="overline-line" style="border-bottom-width: 0.04em;"></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.19444em;"><span class=""></span></span></span></span></span></span></span></span></span>作为访存控制信号（低电平有效），用<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
        
         
         
           W 
          
         
           R 
          
         
        
          ‾ 
         
        
       
      
        \overline{WR} 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.88333em; vertical-align: 0em;"></span><span class="mord overline"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height: 0.88333em;"><span class="" style="top: -3em;"><span class="pstrut" style="height: 3em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right: 0.13889em;">W</span><span class="mord mathdefault" style="margin-right: 0.00773em;">R</span></span></span><span class="" style="top: -3.80333em;"><span class="pstrut" style="height: 3em;"></span><span class="overline-line" style="border-bottom-width: 0.04em;"></span></span></span></span></span></span></span></span></span></span>作为读写控制信号（高电平为读、低电平为写）。现有下列存储芯片：1Kx4位RAM，4Kx8位RAM，8Kx8位RAM，2Kx8位ROM、4Kx8位ROM，8Kx8位ROM及74LS138译码器和各种门电路。画出CPU与存储器的连接图。要求：<br>   （1）主存地址空间分配：6000H~ 67FFH为系统程序区；6800H ~6BFFH为用户程序区。<br>   （2）合理选用芯片，并说明各选几片<br>   （3）详细画出存储芯片的片选逻辑图</p> 
<p>  答案：选择1片2Kx8位ROM，2片1Kx4位RAM；<br>   0~10号地址线应用来选择ROM芯片，0 ~ 9号地址线应用来选择RAM芯片，能用来作为74LS138（3线-8线译码器）输入的只能是11 ~15号地址线，因此取11、12、13这三位分别作为A、B、C的输入端。<br>   ROM芯片的13、12、11号线为100，因此取74LS138的4号输出端。RAM芯片的13、12、11号线为101，取5号输出端，又因为10号线为0时才选中RAM芯片，选用输入输出端均反相的与非门。<br>   还需注意的点有ROM不接<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
        
         
         
           W 
          
         
           R 
          
         
        
          ‾ 
         
        
       
      
        \overline{WR} 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.88333em; vertical-align: 0em;"></span><span class="mord overline"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height: 0.88333em;"><span class="" style="top: -3em;"><span class="pstrut" style="height: 3em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right: 0.13889em;">W</span><span class="mord mathdefault" style="margin-right: 0.00773em;">R</span></span></span><span class="" style="top: -3.80333em;"><span class="pstrut" style="height: 3em;"></span><span class="overline-line" style="border-bottom-width: 0.04em;"></span></span></span></span></span></span></span></span></span></span>，接地<br> <img src="https://images2.imgbox.com/b2/0a/25Zl5CT0_o.png" alt="在这里插入图片描述"></p> 
<h4><a id="35_RAM_326"></a>3.5 双端口RAM和多模块存储器</h4> 
<p>  为提高CPU访问存储器的速度，可<mark>采用双端口存储器、多模块存储器等技术，它们同属并行技术，前者为空间并行，后者为时间并行。</mark></p> 
<h5><a id="8195351_RAM_328"></a> 3.5.1 双端口RAM</h5> 
<p>  <mark>双端口RAM是指同一个存储器有左、右两个独立的端口，分别具有两组相互独立的地址线、数据线和读写控制线，允许两个独立的控制器同时异步地访问存储单元。</mark> 当两个端口的地址不相同时，在两个端口上进行读写操作一定不会发生冲突。<br> <img src="https://images2.imgbox.com/93/fc/ppPugtrA_o.png" alt="在这里插入图片描述"><br>   <mark>两个端口同时存取存储器的同一地址单元时，会因数据冲突造成数据存储或读取错误</mark>。两个端口对同一主存操作有以下4种情况：<br>   （1）两个端口不同时对同一地址单元存取数据<br>   （2）两个端口同时对同一地址单元读出数据<br>   （3）两个端口同时对同一地址单元写入数据<br>   （4）两个端口同时对同一地址单元操作，一个写入数据，另一个读出数据<br>   其中，（1）和（2）不会出现错误；（3）会出现写错误；（4）会出现读错误<br>   解决方法：置忙信号<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
        
         
         
           B 
          
         
           U 
          
         
           S 
          
         
           Y 
          
         
        
          ‾ 
         
        
       
      
        \overline{BUSY} 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.88333em; vertical-align: 0em;"></span><span class="mord overline"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height: 0.88333em;"><span class="" style="top: -3em;"><span class="pstrut" style="height: 3em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right: 0.05017em;">B</span><span class="mord mathdefault" style="margin-right: 0.10903em;">U</span><span class="mord mathdefault" style="margin-right: 0.05764em;">S</span><span class="mord mathdefault" style="margin-right: 0.22222em;">Y</span></span></span><span class="" style="top: -3.80333em;"><span class="pstrut" style="height: 3em;"></span><span class="overline-line" style="border-bottom-width: 0.04em;"></span></span></span></span></span></span></span></span></span></span>为0，由判断逻辑决定暂时关闭一个端口（即被延时），未被关闭的端口正常访问，被关闭的端口延长一个很短的时间段后再访问。</p> 
<h5><a id="8195352__339"></a> 3.5.2 多模块存储器</h5> 
<p>  <mark>常用的有单体多字存储器和多体低位交叉存储器</mark>。</p> 
<hr> 
<p>  CPU的速度比存储器快，若同时从存储器中取出n条指令，就可充分利用CPU资源，提高运行速度。多体交叉存储器就是基于这种思想提出的。</p> 
<hr> 
<h6><a id="819581951_346"></a>  1.单体多字存储器</h6> 
<p>  <mark>单体多字系统的特点是存储器中只有一个存储体，每个存储单元存储m个字，总线宽度也为m个字。一次并行读出m个字，地址必须顺序排列并处于同一存储单元。</mark><br>   单体多字系统在一个存取周期内，从同一地址取出m条指令，然后将指令逐条送至CPU执行，即每隔1/m存取周期，CPU向主存取一条指令。<mark>单体多字系统的缺点是：指令和数据在主存内必须是连续存放的</mark>，一旦遇到转移指令或操作数不能连续存放，这种方法的效果不明显。</p> 
<h6><a id="819581952_350"></a>  2.多体并行存储器</h6> 
<p>  <mark>多体并行存储器由多体模块组成。每个模块都有相同的容量和存取速度，各模块都有独立的读写控制电路、地址寄存器和数据寄存器。它们既能并行工作、又能交叉工作</mark>。<br>   多体并行存储器分为<mark>高位交叉编址（顺序方式）和低位交叉编址（交叉方式）两种。</mark><br>   （1）高位交叉编址：<mark>高位地址表示体号，低位地址为体内地址。</mark> 高位交叉编址主要用于存储器容量扩展。<br> <img src="https://images2.imgbox.com/2f/92/61KM7sKp_o.png" alt="在这里插入图片描述"><br>   图中存储器共有4个模块M<sub>0</sub>~M<sub>3</sub>，每个模块有n个单元。<br>   高位交叉编址方式下，总是把低位的体内地址送到由高位体号确定的模块内进行译码。访问一个连续主存块时，总是先在一个模块内访问，等到该模块访问完才转到下一个模块访问，CPU总是按顺序访问存储模块，存储模块不能并行访问，因而不能提高存储器的吞吐率。高位交叉编址方式下易出现某一个存储体繁忙，其余空闲。<br>   模块内的地址是连续的，存取方式仍是串行存取，因此这种存储器仍是顺序存储器。</p> 
<hr> 
<p>  取0号地址时，可交叉取得M<sub>1</sub>中的n号地址，而要取1号地址时须等到0号地址取完才能取</p> 
<hr> 
<p>  （2）低位交叉编址<br>   低位交叉编址主要用于存储器带宽、访问速度的提高。 <mark>低位地址为体号，高位地址为体内地址。每个模块按模m交叉编址，模块号=单元地址%m</mark>。假定有m个模块，每个模块有k个单元，则0，m，…，（k-1）m单元位于M<sub>0</sub>；第1，m+1，…，（k-1）m+1单元位于M<sub>1</sub>；以此类推。<br>   低位交叉编址方式下，总是把高位的体内地址送到由低位体号确定的模块内进行译码。<mark>程序连续存放在相邻模块中，因此称采用此编址方式的存储器为交叉存储器</mark>。采用低位交叉编址后，可在不改变每个模块存取周期的前提下，采用流水线的方式并行存取，提高存储器的带宽。<br> <img src="https://images2.imgbox.com/30/5a/wmt7lPei_o.png" alt="在这里插入图片描述"><br>   设模块字长等于数据总线宽度，模块存取一个字的存取周期为T，总线传送周期为r，为实现流水线方式存取，存储器交叉模块数应大于等于<br>   m=T/r<br>   式中，<mark>m称为交叉存取度</mark>。每经过r时间延迟后启动下一个模块，交叉存储器要求其模块数&gt;=m，<mark>以保证启动某模块后经过m x r的时间后再次启动该模块时，其上次的存取操作已完成（即流水线不间断）</mark>。这样，连续存取m个字所需的时间为：t<sub>1</sub>=T+（m-1）r。而顺序方式连续读取m个字所需的时间为t<sub>2</sub>=mT。<br>   模块数为4的流水线方式存取示意图如图：<br> <img src="https://images2.imgbox.com/fe/4a/eDwn6nV5_o.png" alt="在这里插入图片描述"><br>   例：设存储器容量为32个字，字长为64位，模块数为4，分别采用顺序方式和交叉方式进行组织。存储周期T=200ns，数据总线宽度为64位，总线传输周期r=50ns。在连续读出4个字的情况下，求顺序存储器和交叉存储器各自的带宽。<br>   32x10^7b/s;73x10 ^ 7b/s；</p> 
<hr> 
<p>  高性能存储芯片：<br>   （1）SDRAM（同步DRAM）：SDRAM与处理器的数据交换同步于系统的时钟信号，不需要插入等待状态（CPU无须等待）<br>   （2）RDRAM：主要解决存储器带宽的问题<br>   （3）带Cache的DRAM（CDRAM）适合猝发式读取</p> 
<hr> 
<hr> 
<p>  例题：双端口RAM在（）情况下会发生读/写冲突<br>   A.左端口和右端口的地址码不同<br>   B.左端口和右端口的地址码相同<br>   C.左端口和右端口的数据码不同<br>   D.左端口和右端口的数据码相同</p> 
<p>  答案：B；</p> 
<p>  例题：某机器采用四体低位交叉存储器，现分别执行下述操作：1.读取6个连续地址单元中存放的存储字，重复80次；2.读取8个连续地址单元中存放的存储字，重复60次。则1,2所花费的时间比为</p> 
<p>  答案：4:3；对于1：在每轮读取存储器的前6个T/4时间（共3T/2）内，依次进入各体。下一轮欲读取存储器时，最近访问的M<sub>1</sub>还在占用中（才过T/2时间），因此必须再等待T/2的时间才能开始新的读取（M<sub>1</sub>连续完成两次读取，也即总共2T的时间即可进入下一轮。进入下一轮不需要第6个字读取结束，第5个字读取结束，M<sub>1</sub>就已空出，即可马上进入下一轮）。最后一轮读取结束的时间是本轮第6个字读取结束，共（6-1）x(T/4)+T=2.25T。<br>   情况1的总时间为（80-1）x 2T+2.25T=160.25T;<br> <img src="https://images2.imgbox.com/7d/c4/bR9cqire_o.png" alt="在这里插入图片描述"><br>   对于2：（60-1）x 2T+( 8-1 ) x T/4 +T=120.75T</p> 
<p>  例题：下列说法中，正确的是（）<br>   1.高位多体交叉存储器能很好地满足程序的局部性原理<br>   2.高位四体交叉存储器可能在一个存储周期内连续访问4个模块<br>   3.双端口存储器可以同时访问同一区间，同一单元<br>   A.1,3  B.2,3  C.3  D.1</p> 
<p>  答案：B；高位多体交叉存储器若取了0，就不能继续取1，但可以取n，不满足程序的局部性原理；<mark>高位交叉存储器有可能一次连续读出彼此地址相差一个存储体容量的4个字</mark>；</p> 
<p>  例题：某计算机使用四体交叉编址寄存器，假定在存储器总线上出现的主存地址（10进制）序列为8005,8006,8007,8008,8001,8002,8003,8004,8000，则有可能发生访存冲突的地址对是：<br>   A.8004,8008  B.8002,8007  C.8001,8008  D.8000,8004</p> 
<p>  答案：D；</p> 
<p>  例题：某计算机主存按字节编址，由4个64M x 8位的DRAM芯片采用交叉编址方式构成，并与宽度为32位的存储器总线相连，主存每次最多读写32位数据。若double型变量x的主存地址为804001AH，则读取x需要的存储周期数是（）</p> 
<p>  答案：3个存储周期；1个存储周期读4个B，double数据类型占8个字节。因为主存地址最低2位表示该字节存储的芯片编号，数据在从体2上开始，但是对于存储的读取是从体0开始的。所以在第一个周期结束，实际上读了体2，体3上的数据，第二轮周期把4个体都读一遍，现在还剩下体0和体1上的两个数据，然后第三个周期，才能读完8个字节。</p> 
<p>  例题：一个四体并行交叉存储器，每个模块容量是64K x 32位，存取周期为200ns<br>   （1）在一个存取周期中，存储器能向CPU提供多少位二进制信息<br>   （2）若存取周期为400ns,则在0.1μs内每个体可向CPU提供32位二进制信息，该说法对吗？为什么？</p> 
<p>  答案：（1）128位（流水线稳定后）；（2）不对，因为在0.1μs内整个存储器可向CPU提供32位二进制信息（流水线稳定），但每个存储体必须经过400ns才能向CPU提供32位二进制信息</p> 
<p>  例题：某计算机字长32位，存储体的存储周期为200ns<br>   （1）采用四体交叉工作，用低2位的地址作为体地址，存储数据按地址顺序存放。主机最快多长时间可以读出一个数据字？存储器的带宽是多少？<br>   （2）若4个体分别保存主存中前1/4、次1/4、再下个1/4、最后1/4这四段的数据，即选用高2位的地址作为体地址，可以提高存储器顺序读出数据的速度吗？为什么？<br>   （3）若把存储器改成单体4字宽度，会带来什么好处和问题？<br>   （4）比较采用四体低位地址交叉的存储器和四端口读出的存储器这两种方案的优缺点</p> 
<p>  答案：（1）理想情况是每个存取周期平均可读出4个数据字，即读出1个数据字时间为50ns，数据传输率32bit/50ns=80MB/s<br>   （2）若对多体结构的存储器选用高位地址交叉，通常起不到提高存储器读写速度的作用，因为它不符合程序的局部性原理，一次连续读出彼此地址相差1个存储体的容量的4个字的机会太少。因此，通常只有1个存储模块在不停忙碌，其他存储模块是空闲的。<br>   （3）若把存储器的字长扩大为原来的4倍，实现的则是一个单体4字结构的存储器，每次读可以同时读出4个字的内容，有利于提高存储器每个字的平均读写速度，但其灵活性不如多体单字结构的存储器，还会多用到几个缓冲寄存器。<br>   （4）多端口存储器是对同一个存储体使用多套读写电路实现的，扩大存储容量的难度显然比多体结构的存储器要大，而且不能对多端口存储器的同一个存储单元同时执行多个写入操作，而多体结构的存储器则允许在同一个存储周期对几个存储体执行写入操作</p> 
<hr> 
<h4><a id="36__438"></a>3.6 高速缓冲存储器</h4> 
<p>  通常将存储系统分为Cache-主存层次和主存-辅存层次。</p> 
<h5><a id="8195361__440"></a> 3.6.1 程序访问的局部性原理</h5> 
<p>  <mark>程序访问的局部性原理包括时间局部性和空间局部性。</mark> 时间局部性是指在最近的未来要用到的信息，<mark>很可能是现在正在使用的信息</mark>，因为程序中存在循环。空间局部性是指在最近的未来要用到的信息，很可能<mark>与现在正在使用的信息在存储空间上是邻近的</mark>，因为指令通常是顺序存放、顺序执行的，数据一般也是以向量、数组等形式簇聚地存储在一起的。<br>   高速缓冲技术就是利用程序访问的局部性原理，<mark>把程序中正在使用的部分存放在一个高速的、容量较小的Cache中，使CPU的访存操作大多数针对Cache进行</mark>，从而大大提高程序的执行速度。<br>   例：假定数组元素按行优先方式存储，对于下面的两个函数：</p> 
<pre><code class="prism language-c">程序A：
<span class="token keyword">int</span> <span class="token function">sumarrayrows</span><span class="token punctuation">(</span> <span class="token keyword">int</span> a<span class="token punctuation">[</span>M<span class="token punctuation">]</span><span class="token punctuation">[</span>N<span class="token punctuation">]</span> <span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token keyword">int</span> i<span class="token punctuation">,</span>j<span class="token punctuation">,</span>sum<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>
	<span class="token keyword">for</span><span class="token punctuation">(</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>M<span class="token punctuation">;</span>i<span class="token operator">++</span> <span class="token punctuation">)</span>
		<span class="token keyword">for</span><span class="token punctuation">(</span> j<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>j<span class="token operator">&lt;</span>N<span class="token punctuation">;</span>j<span class="token operator">++</span> <span class="token punctuation">)</span>
			sum<span class="token operator">+</span><span class="token operator">=</span>a<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>
	<span class="token keyword">return</span> sum<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
程序B：
<span class="token keyword">int</span> <span class="token function">sumarraycols</span><span class="token punctuation">(</span> <span class="token keyword">int</span> a<span class="token punctuation">[</span>M<span class="token punctuation">]</span><span class="token punctuation">[</span>N<span class="token punctuation">]</span> <span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token keyword">int</span> i<span class="token punctuation">,</span>j<span class="token punctuation">,</span>sum<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>
	<span class="token keyword">for</span><span class="token punctuation">(</span> j<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>j<span class="token operator">&lt;</span>N<span class="token punctuation">;</span>j<span class="token operator">++</span> <span class="token punctuation">)</span>
		<span class="token keyword">for</span><span class="token punctuation">(</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>M<span class="token punctuation">;</span>i<span class="token operator">++</span> <span class="token punctuation">)</span>
			sum<span class="token operator">+</span><span class="token operator">=</span>a<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>
	<span class="token keyword">return</span> sum<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>  （1）对于数组a的访问，哪个空间局部性更好？哪个时间局部性更好？<br>   （2）对于指令访问来说，for循环体的空间局部性和时间局部性如何？</p> 
<p>  答案：（1）程序A对数组a的访问顺序与存放顺序是一致的，因此空间局部性好。程序B对数组a的访问顺序与存放顺序不一致，因而没有空间局部性。两个程序的时间局部性都很差，因为每个数组元素都只被访问一次。<br>   （2）对于for循环体，程序A和程序B中的访问局部性是一样的。因为循环体内指令按序连续存放，所以空间局部性好；内循环体被连续重复执行，因此时间局部性也好。</p> 
<h5><a id="8195362_Cache_471"></a> 3.6.2 Cache的基本工作原理</h5> 
<p>  Cache位于存储器层次结构的顶层，通常由SRAM构成，其基本结构如图：<br> <img src="https://images2.imgbox.com/7b/17/iCQEMF1q_o.png" alt="在这里插入图片描述"><br>   为便于Cache和主存之间交换信息，<mark>Cache和主存都被划分为相等的块，Cache块又称Cache行，每块由若干字节组成，块的长度称为块长（Cache行长）</mark>。主存的地址分成两段：高m位表示主存的块地址，低b位表示块内地址，同样，缓存的地址也分为两段：高c位表示缓存的块号，低b位表示块内地址。由于Cache容量远小于主存容量，所以Cache中的块数要远少于主存中的块数，<mark>它仅保存主存中最活跃的若干块的副本</mark>。因此Cache按照某种策略，预测CPU在未来一段时间内欲访存的数据，将其装入Cache。<br>   当CPU发出读请求时，<mark>若访存地址在Cache中命中，就将此地址转换成Cache地址，直接对Cache进行读操作，与主存无关。若Cache不命中，则仍需访问主存，并把此字所在的块一次性地从主存调入Cache。</mark> 若此时Cache已满，则需根据某种替换算法，用这个块替换Cache中原来的某块信息。<mark>CPU与Cache之间的数据交换以字为单位，而Cache与主存之间的数据交换则以Cache块为单位。</mark></p> 
<hr> 
<p>  某些计算机中也采用同时访问Cache和主存的方式，若Cache命中，则主存访问终止；否则访问主存并替换Cache。</p> 
<hr> 
<p>  当CPU发出写请求时，若Cache命中，有可能会遇到Cache与主存中的内容不一致的问题。例如，由于CPU写Cache，把Cache某单元中的内容从X修改成了X’，而主存对应单元中的内容仍然是X，没有改变。所以若Cache命中，需要按照一定的写策略处理，常见的处理方法有<mark>全写法和写回法</mark>。<br>   <mark>CPU欲访问的信息已在Cache中的比率称为Cache的命中率</mark>。设一个程序执行期间，Cache的总命中次数为N<sub>c</sub>，访问主存的总次数为N<sub>m</sub>，则命中率H为：H=N<sub>c</sub>/（N<sub>c</sub>+N<sub>m</sub>）<br>   设t<sub>c</sub>为命中时的Cache访问时间，t<sub>m</sub>为未命中时的访问时间，则Cache-主存系统的平均访问时间T<sub>a</sub>为：<br>   T<sub>a</sub>=Ht<sub>c</sub>+（1-H）t<sub>m</sub></p> 
<hr> 
<p>  Cache行的大小与命中率：<br>   当块由小到大增长时，起初会因局部性原理使命中率有所提高。倘若继续增大块长，命中率很可能下降。<br>   行长较大，可充分利用程序访问的空间局部性，使一个较大的局部空间被一起调到Cache中，因而可以增加命中机会。但行长也不能过大：（1）行长大使失效损失变大。若未命中，需花更多时间从主存读块。（2）行长太长，Cache项数变少，因而命中的可能性变小。</p> 
<p>  发生取指令Cache缺失的处理过程：<br> （1）PC恢复当前指令的值；（2）对主存进行读操作；(3）将读入的指令写入Cache中，更改有效位和标记位；（4）重新执行当前指令</p> 
<p>  统一缓存与分立缓存、指令Cache与数据Cache:<br>   统一缓存是指指令和数据都存放在同一缓存内的Cache；分立缓存是指指令和数据分别存放在两个Cache中：指令Cache与数据Cache。指令和数据可以分别存储在不同的Cache中，这种结构也称哈佛Cache，<mark>其特点是允许CPU在同一个Cache存储周期内同时提取指令和数据，由于指令执行过程中取指和取数据都有可能访问Cache，因此这一特性可以保证不同的指令同时访存。</mark><br>   统一缓存与分立缓存的选用主要考虑以下两个因素：（1）与主存结构有关，若计算机的主存是统一的（指令、数据存储在同一主存内），则对应的Cache采用统一缓存；若主存采用指令、数据分开存储的方案，则相应的Cache采用分立缓存。（2）与机器对指令执行的控制方式有关。当采用超前控制（超前取指或指令预取）或流水线控制方式时，一般采用分立缓存。</p> 
<hr> 
<h5><a id="8195363_Cache_502"></a> 3.6.3 Cache和主存的映射方式</h5> 
<p>  Cache行中的信息是主存中某个块的副本，<mark>地址映射是指把主存地址空间映射到Cache地址空间</mark>，即把存放在主存中的信息按照某种规则装入Cache。<br>   由于Cache行数比主存块数少得多，因此主存中只有一部分块的信息可放在Cache中，因此<mark>在Cache中要为每块加一个标记，指明它是主存中哪一块的副本。</mark> 该标记的内容相当于主存中块的编号。为了说明Cache行中的信息是否有效，每个Cache行需要一个有效位。<br>   <mark>地址映射不同于地址变换。地址变换是指CPU在访存时，将主存地址按映射规则换算成Cache地址的过程。</mark> 由于主存和Cache的块大小相同，块内地址都是相对于块的起始地址的偏移量（即低位地址相同），因此地址变换主要是主存的块号（高位地址）与Cache块号间的转换。 地址映射的方法有以下三种：</p> 
<h6><a id="819581951_506"></a>  1.直接映射</h6> 
<p>  <mark>主存中的每一块只能装入Cache中的唯一位置。若这个位置已有内容，则产生块冲突，原来的块将无条件地被替换出去（无须使用替换算法）。</mark> 直接映射不够灵活，即使Cache的其他许多地址空着也不能占用，这使得<mark>直接映射的块冲突概率最高，空间利用率最低。</mark><br>   直接映射的关系可定义为：j = i mod 2<sup>c</sup><br>   j是Cache的块号（行号），i是主存的块号，2<sup>c</sup>是Cache中的总块数。在这种映射方式中，主存的第0块、第2<sup>c</sup>块、第2<sup>c+1</sup>…只能映射到Cache的第0行；而主存的第1块、第2<sup>c</sup>+1块、第2<sup>c+1</sup>+1块…只能映射到Cache的第1行，依次类推。<mark>主存块号的低c位正好是它要装入的Cache行号。</mark> <mark>给每个Cache行设置一个长为t=m-c的标记（tag），当主存某块调入Cache后，就将其块号的高t位设置在对应Cache行的标记中</mark>。<br> <img src="https://images2.imgbox.com/4b/33/Qo1aFLgW_o.png" alt="在这里插入图片描述"><br>   直接映射的地址结构为：<br> <img src="https://images2.imgbox.com/95/a8/CJzYHogN_o.png" alt="在这里插入图片描述"><br>   CPU访存过程如图：<br> <img src="https://images2.imgbox.com/f6/2e/S6Q5DcDw_o.png" alt="在这里插入图片描述"><br>   <mark>首先根据访存地址中间的c位，直接找到对应的Cache行，将对应Cache行中的标记和主存地址的高t位标记进行比较，若相等且有效位为1，则访问Cache命中，</mark> 此时根据主存地址中低位的块内地址，在对应的Cache行中存取信息；<mark>若不相等或有效位为0，则不命中，此时CPU从主存中读出该地址所在的一块信息送到对应的Cache行中，将有效位置1，并将标记设置为地址中的高t位，同时将该地址中的内容送CPU</mark>。</p> 
<h6><a id="819581952_517"></a>  2.全相联映射</h6> 
<p>  <mark>主存中的每一块可以装入Cache中的任何位置，每行的标记用于指出该行取自主存的哪一块，所以CPU访存时需要与所有Cache行的标记进行比较。</mark> 全相联映射方式Cache块的冲突概率低，空间利用率高，命中率高；缺点是标记的比较速度较慢，实现成本较高，需采用昂贵的按内容寻址的相联存储器进行地址映射。<br> <img src="https://images2.imgbox.com/c8/ef/6cYdFUo9_o.png" alt="在这里插入图片描述"></p> 
<p>  全相联映射的地址结构为：<br> <img src="https://images2.imgbox.com/16/af/fu3rCXXi_o.png" alt="在这里插入图片描述"></p> 
<h6><a id="819581953_523"></a>  3.组相联映射</h6> 
<p>  <mark>将Cache空间分为大小相同的组，主存的一个数据块可以装入一组内的任何一个位置，即组间采取直接映射，组内采取全相联映射。</mark> 它是对直接映射和全相联映射的一种折中，当Cache组数Q=1时变为全相联映射，Q=Cache块数时变为直接映射。<mark>假设每组有r个Cache行，则称之为r路组相联。</mark><br> <img src="https://images2.imgbox.com/4b/11/HQfLcfMK_o.png" alt="在这里插入图片描述"><br>   组相联映射的关系可定义为：<br>   j=i mod Q<br>   其中，j是Cache行的组号，i是主存的块号，Q是Cache的组数<br>   路数越大，即每组Cache行的数量越大，发生块冲突的概率越低，但相联比较电路越复杂。<mark>选定适当的数量，可使组相联映射的成本接近于直接映射，而性能上仍接近于全相联映射。</mark><br>   组相联映射的地址结构为：<br> <img src="https://images2.imgbox.com/63/2a/uh3abCOm_o.png" alt="在这里插入图片描述"><br>   CPU访存过程如下：<mark>首先根据访存地址中间的组号找到对应的Cache组；将对应Cache组中每个行的标记与主存地址的高位标记进行比较；若有一个相等且有效位为1，则访问Cache命中，</mark> 此时根据主存地址中的块内地址，在对应Cache行中存取信息；若都不相等或相等但有效位为0，则不命中，此时CPU从主存中读出该地址所在的一块信息送到对应Cache组的任意一个空闲行中，将有效位置1，并设置标记，同时将该地址中的内容送CPU。</p> 
<p>  例：假设某个计算机的主存地址空间大小为256MB，按字节编址，其数据Cache有8个Cache行，行长为64B<br>   （1）若不考虑用于Cache的一致维护性和替换算法控制位，并且采用直接映射方式，则该数据Cache的总容量是多少？<br>   （2）若该Cache采用直接映射方式，则主存地址为3200（10进制）的主存块对应的Cache行号是多少？采用二路组相联映射时又是多少？<br>   （3）以直接映射方式为例，简述访存过程（设访存的地址为0123456H）</p> 
<p>  答案：（1）4256位；Cache包括了可以对Cache中所包含的存储器地址进行跟踪的硬件，即Cache的总容量包括：存储容量、标记阵列容量（有效位、标记位）（标记阵列中的一致性维护位和Cache数据一致性维护方式相关，替换算法控制位和替换算法相关，题中不计算）</p> 
<hr> 
<p>  每个Cache行对应一个标记项（包括有效位、标记位Tag、一致性维护位、替换算法维护位），而在组相联中，将每组的标记项排成一行，将各组从上到下排列，成为一个二维的标记阵列（对于直接映射，一行就是一组）。查找Cache时就是查找标记阵列的标记项是否符合要求。二路组相联的标记阵列如图：<br> <img src="https://images2.imgbox.com/71/2a/8W5hM0lo_o.png" alt="在这里插入图片描述"></p> 
<hr> 
<p>  本题中每行相关的存储器容量如图：<br> <img src="https://images2.imgbox.com/17/f3/ZISk2sJ7_o.png" alt="在这里插入图片描述"><br>   标记字段长度的计算：主存地址有28位（256MB=2<sup>28</sup>B），其中6位为块内地址（2<sup>6</sup>B=64B），3位为行号，剩余19位为标记字段，总容量为8x(20+64x8)=4256位。<br>   （2）直接映射方式中，主存按照块的大小划分，主存地址3200对应的字块号为3200B/64B=50。而Cache只有8行，则50mod8=2，因此对应的Cache行号为2。二路组相联方式，实质上就是将两个Cache行合并，内部采用全相联方式，外部采用直接相联方式，50mod4=2,对应的组号为2，即对应的Cache行号为4or5。<br>   （3）直接映射方式中，28位主存地址可分为19位的主存标记位，3位的块号，6位的块内地址，即001为块号，010110为块内地址。首先根据块号，查Cache（即001号Cache行）中对应的主存标记位，看是否相同。若相同，再看Cache行中装入有效位是否为1，若是，则表示有效，称此访问命中，按块内地址010110读出Cache行所对应的单元并送入CPU中，完成访存。若出现标记位不相等或有效位为0的情况，则不命中，访问主存将数据取出并送往CPU和Cache的对应块中，把主存的最高19位存入001行的Tag中，并将有效位置1。</p> 
<p>  <mark>三种映射方式中，直接映射的每个主存块只能映射到Cache中的某一固定行；全相联映射可以映射到所有Cache行；N路组相联映射可以映射到N行。</mark> 当Cache大小、主存块大小一定时：<br>   （1）直接映射的命中率最低，全相联映射的命中率最高<br>   （2）直接映射的判断开销最小、所需时间最短，全相联映射的判断开销最大、所需时间最长。<br>   （3）直接映射标记所占的额外空间开销最少，全相联映射标记所占的额外空间开销最大</p> 
<h5><a id="8195364_Cache_558"></a> 3.6.4 Cache中主存块的替换算法</h5> 
<p>  在采用全相联映射或组相联映射方式时，从主存向Cache传送一个新块，当Cache或Cache组中的空间已被占满时，就需要使用替换算法置换Cache行。<mark>而采用直接映射时，一个给定的主存块只能放到唯一的固定Cache行中，所以在对应Cache行已有一个主存块的情况下，新的主存块毫无选择地把原先已有的那个主存块替换掉，因而无须考虑替换算法。</mark><br>   常用的替换算法有<mark>随机（RAND）算法、先进先出（FIFO）算法、近期最少使用（LRU）算法和最不经常使用（LFU）算法。</mark><br>   （1）随机算法：随机地确定替换的Cache块。不符合程序访问的局部性原理<br>   （2）先进先出算法：选择最早调入的行进行替换。不符合程序的局部性原理。<br>   （3）近期最少使用算法：<mark>依据程序访问的局部性原理，选择近期内长久未访问过的Cache行作为替换的行</mark>，平均命中率比FIFO高，是堆栈类算法。<br>   <mark>LRU算法对每个Cache行设置一个计数器，用计数值来记录主存块的使用情况，并根据计数值选择淘汰某个块，</mark> 计数值的位数与Cache组大小有关，2路时有1位LRU位，4路时有2位LRU位。假定采用4路组相联，有5个主存块{1,2,3,4，5}映射到Cache的同一组，对于主存访问序列{1,2，3,4，1,2，5,1，2,3，4,5}，采用LRU算法的替换过程如图：（图中左边阴影的数字是对应Cache行的计数值，右边的数字是存放在该行中的主存块号）<br> <img src="https://images2.imgbox.com/59/d2/bZt35yEu_o.png" alt="在这里插入图片描述"></p> 
<p>  计数器的变化规则：（1）<mark>命中时，所命中的行的计数器清零，计数值比其低的计数器加1，其余不变；</mark> （2）<mark>未命中且还有空闲行时，新装入的行的计数器置0，其余全加1；</mark> （3）<mark>未命中且无空闲行时，计数值为3的行的信息块被淘汰，新装行的块的计数器置0，其余全加1</mark>。</p> 
<p>  当集中访问的存储区超过Cache组的大小时，命中率可能变得很低，如上例中的访问序列变为1，2,3,4,5，1,2，3,4,5，…，而Cache每组只有4行，那么命中率为0，这种现象称为<mark>抖动</mark>。</p> 
<p>  （4）最不经常使用算法：将一段时间内被访问次数最少的存储行换出。每行也设置一个计数器，新行建立后从0开始计数，每访问一次，被访问的行计数器加1，需要替换时比较各特定行的计数值，将计数值最小的行换出。</p> 
<h5><a id="8195365_Cache_573"></a> 3.6.5 Cache写策略</h5> 
<p>  <mark>因为Cache中的内容是主存块副本，当对Cache中的内容进行更新时，就需选用写操作策略使Cache内容和主存内容保持一致。</mark> 此时分2种情况。<br>   对于Cache写命中（write hit），有两种处理方法<br>   （1）<mark>全写法（写直通法、write-through）</mark>：<mark>当CPU对Cache写命中时，必须把数据同时写入Cache和主存。当某一块需要替换时，不必把这一块写回主存，用新调入的块直接覆盖即可。</mark> 这种方法能随时保持主存数据的正确性。缺点是增加了访存次数，降低了Cache的效率。写直达法的写操作时间就是访问主存的时间。<mark>写缓冲：为减少全写法直接写入主存的时间损耗，在Cache和主存之间加一个写缓冲（Write Buffer）</mark>。CPU同时写数据到Cache和写缓冲中，写缓冲再控制将内容写入主存。写缓冲是一个FIFO队列，写缓冲可以解决速度不匹配的问题。但若出现频繁写时，会使写缓冲饱和溢出。<br> <img src="https://images2.imgbox.com/47/5f/LJJiLFfk_o.png" alt="在这里插入图片描述"><br>   （2）<mark>写回法（write-back）：当CPU对Cache写命中时，只修改Cache的内容，而不立即写入主存，只有当此块被换出时才写回主存。</mark> 写操作时间就是访问Cache的时间。这种方法减少了访存次数，但存在不一致的隐患。采用这种策略时，<mark>每个Cache行必须设置一个标志位（脏位），以反映此块是否被CPU修改过</mark>。<br>   全写法和写回法都对应于Cache写命中（要被修改的单元在Cache中）时的情况。<br>   对于Cache写不命中，也有两种处理方法<br>   （1）<mark>写分配法（write-allocate）：加载主存中的块到Cache中，然后更新这个Cache块。</mark> 它试图利用程序的空间局部性，但缺点是每次不命中都需要从主存中读出一块。<br>   （2）<mark>非写分配法（not-write-allocate）：只写入主存，不进行调块。</mark><br>   <mark>非写分配法通常与全写法合用，写分配法通常和写回法合用</mark></p> 
<p>  现代计算机的Cache通常设立多级Cache（通常为3级），假定设3级Cache，按离CPU的远近可各自命名为L1 Cache、L2 Cache、L3 Cache，离CPU越远，访问速度越慢，容量越大。<mark>指令Cache与数据Cache分离一般在L1级，此时通常为写分配法和写回法合用。</mark><br>   下图是一个含有2级Cache的系统，L1 Cache对L2 Cache使用全写法，L2 Cache对主存使用写回法，由于L2 Cache的存在，其访问速度大于主存，因此避免了因频繁写时造成的写缓冲饱和溢出。<br> <img src="https://images2.imgbox.com/d6/1f/znNkUDTh_o.png" alt="在这里插入图片描述"></p> 
<hr> 
<p>  例题：关于Cache的更新策略，下列说法中正确的是：<br>   A.读操作时，全写法和写回法在命中时应用<br>   B.写操作时，写回法和写分配法在命中时应用<br>   C.读操作时，全写法和写分配法在失效时应用<br>   D.写操作时，写分配法、非写分配法在失效时应用</p> 
<p>  答案：D；写回法和全写法是在命中Cache的情况下使用的，写不命中时，采用写分配法或非写分配法</p> 
<p>  例题：某32位计算机按字节编址，Cache容量为16KB，Cache行的大小为16B，若主存与Cache地址映像采用直接映像方式，则主存地址为0x1234E8F8的单元装入Cache的地址是（）<br>   A.00010001001101  B.01000100011010  C.10100011111000  D.11010011101000</p> 
<p>  答案：C;Cache容量为16KB=2<sup>14</sup>B，Cache地址长14位，分为2段，高10位表示块号，低4位表示块内地址</p> 
<p>  例题：某存储系统中，主存容量是Cache容量的4096倍，Cache被分为64个块，当主存地址和Cache地址采用直接映像方式时，地址映射表的大小应为（）（假设不考虑一致维护和替换算法位）<br>   A.6x4097bit  B.64x12bit<br>   C.6x4096bit  D.64x13bit</p> 
<p>  答案：D；地址映射表也即标记阵列，Cache有64行，该标记阵列每行存储1个标记项，其中主存标记项为12位（主存容量是Cache的4096倍，即地址长度比Cache长12位，多出的长度即为标记位长度），加上1位有效位，因此总共大小为64x13bit;</p> 
<p>  例题：有效容量为128KB的Cache，每块16B，采用8路组相联。字节地址为1234567H的单元调入该Cache，则其Tag应为（）<br>   A.1234H  B.2468H  C.048DH  D.12345H</p> 
<p>  答案：C;块内地址字段4位</p> 
<p>  例题：有一主存-Cache层次的存储器，其主存容量为1MB，Cache容量为16KB，每块有8个字，每字32位，采用直接地址映像方式，若主存地址为35301H，且CPU访问Cache命中，则在Cache的第（）（10进制表示）字块中（Cache起始字块为第0字块）</p> 
<p>  答案：152；</p> 
<p>  例题：有如下C语言程序段：</p> 
<pre><code class="prism language-c"><span class="token keyword">for</span><span class="token punctuation">(</span> k<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>k<span class="token operator">&lt;</span><span class="token number">1000</span><span class="token punctuation">;</span>k<span class="token operator">++</span> <span class="token punctuation">)</span>
	a<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token operator">=</span>a<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token operator">+</span><span class="token number">32</span><span class="token punctuation">;</span>
</code></pre> 
<p>  若数组a和变量k均为int型，int型数据占4B，数据Cache采用直接映射方式，数据区大小为1KB、块大小为16B，该程序段执行前Cache为空，则该程序段执行过程中访问数组a的Cache缺失率约为（）</p> 
<p>  答案：12.5%；8次访问一次缺失</p> 
<p>  例题：对于高速缓存、主存、硬盘构成的三级存储体系，CPU访问该存储系统时发送的地址为（）<br>   A.高速缓冲地址  B.虚拟地址  C.主存物理地址  D.磁盘地址</p> 
<p>  答案：C；当CPU访存时，要先到Cache中查看该主存地址是否在Cache中，所以发送的是主存物理地址。只有在虚拟存储器中，CPU发出的才是虚拟地址，这里并未指出是虚拟存储系统。</p> 
<p>  例题：采用指令Cache与数据Cache分离的主要目的是（）<br>   A.降低Cache的缺失损失  B.提高Cache的命中率<br>   C.降低CPU的平均访存时间  D.减少指令流水线资源冲突</p> 
<p>  答案：把指令Cache与数据Cache分离后，取指与取数分别到不同的Cache中寻找，则指令流水线中取指部分和取数部分就可以很好地避免冲突，即减少了指令流水线的冲突。</p> 
<p>  例题：某C语言程序段如下：</p> 
<pre><code class="prism language-c"><span class="token keyword">for</span><span class="token punctuation">(</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;=</span><span class="token number">9</span><span class="token punctuation">;</span>i<span class="token operator">++</span> <span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	temp<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>
	<span class="token keyword">for</span><span class="token punctuation">(</span> j<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>j<span class="token operator">&lt;=</span>i<span class="token punctuation">;</span>j<span class="token operator">++</span> <span class="token punctuation">)</span> temp<span class="token operator">*</span><span class="token operator">=</span>a<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>
	sum<span class="token operator">+</span><span class="token operator">=</span>temp<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>下列关于数组a的访问局部性的描述中，正确的是：<br>   A.时间局部性和空间局部性皆有  B.无时间局部性，有空间局部性<br>   C.有时间局部性，无空间局部性  D.时间局部性和空间局部性皆无</p> 
<p>  答案：A；时间局部性是，一旦一条指令被执行，它就可能在不久的将来再被执行。空间局部性是，一旦一个存储单元被访问，它附近的存储单元也很快被访问</p> 
<p>  例题：设有8页的逻辑空间，每页有1024B，它们被映射到32块的物理存储区中，则按字节编址逻辑地址的有效位是（），物理地址至少是（）位<br>   A.10,12  B.10,15  C.13,15  D.13,12</p> 
<p>  答案：C；对于逻辑地址，表示页号地址有3位，页内地址10位；对于物理地址，块号5位，块内地址10位</p> 
<p>  例题：<br> <img src="https://images2.imgbox.com/18/d9/WPbrG308_o.png" alt="在这里插入图片描述"></p> 
<p>  答案：（1）4256bit  （2）6,5;数组首地址为320，每个存储单元存放一个数组元素，320/16/4=5,数组元素a[0][0]存放在块号5中，a[0][31]在块号6中，a[1][1]对应的行号为21，21mod8=5; （3）程序A的命中率为15/16，程序B的命中率为0，程序A的执行时间更短</p> 
<p>  例题：有一Cache系统，字长为16位，主存容量为16字x256块，Cache的容量为16字x8块，采用全相联映射<br>   （1）主存和Cache的容量各为多少字节？主存和Cache的字地址各为多少位<br>   （2）若原先已经依次装入了5块信息，问字地址338H所在的主存块将装入Cache块的块号及在Cache中的字地址是多少<br>   （3）若块表中地址为1的行中标记着36H的主存块号标志，Cache块号标志为5H，则在CPU送来主存的字地址为368H时是否命中？若命中，此时Cache的字地址为多少？</p> 
<p>  答案：（1）8192B，256B，12位，7位  （2）高8位为主存块号，低4位为块内地址，块号101，字地址1011000B；  （3）命中，字地址为58H</p> 
<p>  例题：某个Cache的容量大小为64KB，行长为128B，且是四路组相联Cache，主存使用32位地址，按字节编址<br>   （1）该Cache共有多少行、多少组<br>   （2）该Cache的标记阵列中需要有多少标记项？每个标记项中标记位长度是多少？<br>   （3）该Cache采用LRU替换算法，若当该Cache为写直达式Cache时，标记阵列总共需要多大的存储容量？写回式又该如何？（四路组相联Cache使用LRU算法的替换控制位为2位）</p> 
<p>  答案：（1）512行、128组  （2）512个，18位  （3）1344B，1408B</p> 
<p>  例题：某32位计算机，CPU主频为800MHz，Cache命中时的CPI为4，Cache块大小为32B；主存采用8体交叉存储方式，每个体的存储字长为32位，存储周期为40ns；存储器总线宽度为32位，总线时钟频率为200MHz，支持突发传送总线事务。每次读突发传送总线事务的过程包括：送首地址和命令、存储器准备数据、传送数据。每次突发传送32B，传送地址或32位数据均需要一个总线时钟周期。<br>   （1）CPU和总线的时钟周期各为多少？总线的带宽（即最大数据传输率）为多少？<br>   （2）Cache缺失时，需要用几个读突发传送总线事务来完成一个主存块的读取？<br>   （3）存储器总线完成一次读突发传送总线事务所需的时间是多少<br>   （4）若程序BP执行过程中共执行了100条指令，平均每条指令需进行1.2次访存，Cache缺失率为5%，不考虑替换等开销，则BP的CPU平均执行时间是多少</p> 
<p>  答案：（1）1.25ns，5ns，800MB/s<br>   （2）Cache块大小为32B，因此Cache缺失时需要一个读突发传送总线事务读取一个主存块<br>   （3）一次读突发传送总线事务包括一次地址传送和32B数据传送：用1个总线时钟周期传送地址，第一个体读数据花费40ns，之后数据存取和数据传输重叠，总时间为5+40+8x5=85ns<br>   （4）一条指令的平均CPU执行时间包括Cache命中时的指令执行时间和Cache缺失时带来的额外开销。Cache命中时的一条指令执行时间=4x1.25ns=5ns。一条指令执行过程中因Cache缺失而导致的平均额外开销=平均访存次数xCache缺失率x一次读突发传送总线事务时间=1.2x5%x85ns=5.1ns；一条指令的平均CPU执行时间=10.1ns。BP的CPU执行时间=10.1nsx100=1010ns。</p> 
<p>  例题：<img src="https://images2.imgbox.com/4d/b3/KC9T11xd_o.png" alt="在这里插入图片描述"></p> 
<p>  答案：（1）A=19，B=19，C=11，D=13，E=9，F=9，G=6<br> TLB中标记字段B的内容是虚页号<br>   （2）块号=标记+组号，组号为3，H字段内容为000001000B<br>   （3）处理缺页开销大，因为缺页处理需要访问磁盘，Cache缺失只需访问主存<br>   （4）因为采用直写策略需要同时写快速存储器和慢速存储器，而写磁盘比写主存慢很多，所以在Cache-主存层次，可采用直写策略，而在主存-外存层次，修改页面内容时总是采用回写策略</p> 
<p>  例题：有一全相联Cache系统，Cache由8个块构成，CPU送出的主存地址流序列分别为01110，10010，01110，10010，01000，00100，01000和01010，即十进制为14，18,14，18，8，4,8,10<br>   （1）求每次访问后，Cache的地址分配情况<br>   （2）当Cache的容量换成4个块，地址流为6,15，6，13,11，10，8和7时，求采用先进先出替换算法的相应地址分配和操作</p> 
<p>  答案：（1）<img src="https://images2.imgbox.com/73/7f/IqMQrKbZ_o.png" alt="在这里插入图片描述"><br> （2）<br> <img src="https://images2.imgbox.com/00/1d/estbpu8A_o.png" alt="在这里插入图片描述"></p> 
<hr> 
<h4><a id="37__710"></a>3.7 虚拟存储器</h4> 
<p>  <mark>主存和联机工作的辅存共同构成了虚拟存储器，二者在硬件和系统软件的共同管理下工作。</mark> 对于应用程序员而言，虚拟存储器是透明的。<mark>虚拟存储器具有主存的速度和辅存的容量</mark></p> 
<h5><a id="8195371__713"></a> 3.7.1 虚拟存储器的基本概念</h5> 
<p>  虚拟存储器将主存或辅存的地址空间统一编址，形成一个庞大的地址空间，<mark>在这个空间内，用户可以自由编程，而不必在乎实际的主存容量和程序在主存中实际的存放位置。</mark><br>   <mark>用户编程允许涉及的地址称为虚地址或逻辑地址，虚地址对应的存储空间称为虚拟空间或程序空间。</mark> 实际的主存单元地址称为实地址或物理地址，实地址对应的是主存地址空间，也称实地址空间。虚地址比实地址要大很多。虚拟存储器的地址空间如图：<br> <img src="https://images2.imgbox.com/a8/6b/llw49MZy_o.png" alt="在这里插入图片描述"><br>   CPU使用虚地址时，由辅助硬件找出虚地址和实地址之间的对应关系，并判断这个虚地址对应的存储单元内容是否已装入主存。若已在主存中，则通过地址变换，CPU可直接访问主存指示的实际单元；若不在主存中，则把包含这个字的一页或一段调入主存后再由CPU访问。若主存已满，则采用替换算法置换主存中的一页或一段。<br>   在实际的物理存储层次上，所编程序和数据在操作系统管理下，先送入磁盘，然后操作系统将当前运行所需要的部分调入主存，供CPU使用，其余暂不运行的部分则留在磁盘中。</p> 
<h5><a id="8195372__719"></a> 3.7.2 页式虚拟存储器</h5> 
<p>  <mark>以页为基本单位的虚拟存储器称为页式虚拟存储器。</mark> <mark>虚拟空间与主存空间都被划分为同样大小的页</mark>， 主存的页称为实页，虚存的页称为虚页。<mark>把虚拟地址分为两个字段：虚页号和页内地址</mark>。<mark>虚拟地址到物理地址的转换是由页表实现的。</mark> 页表是一张存放在主存中的虚页号和实页号的对照表，它记录程序的虚页调入主存时被安排在主存中的位置。页表一般长久地保存在内存中。<br>   下图为一个页表示例:<br> <img src="https://images2.imgbox.com/5e/d6/bKMrXLIa_o.png" alt="在这里插入图片描述"><br>   <mark>有效位也称装入位，用来表示对应页面是否在主存，</mark> 若为1，则表示该虚拟页已从外存调入主存，<mark>此时页表项存放该页的物理页号；</mark> 若为0，则表示没有调入主存，<mark>此时页表项可以存放该页的磁盘地址。</mark> <mark>脏位也称修改位，用来表示页面是否被修改过，</mark> <mark>虚存机制中采用回写策略，利用脏位可判断替换时是否需要写回磁盘。</mark> <mark>引用位也称使用位，用来配合替换策略进行设置，</mark> 例如是否实现最先调入（FIFO位）或最近最少使用（LRU位）策略等。<br>   CPU执行指令时，需要先将虚拟地址转换为主存物理地址。<mark>每个进程都有一个页表基址寄存器，存放该进程的页表首地址，然后根据虚拟地址高位部分的虚拟页号找到对应的页表项，</mark> 若装入位为1，则取出物理页号，和虚拟地址低位部分的页内地址拼接，形成实际物理地址；若装入位为0，则说明缺页，需要OS进行缺页处理。<br> <img src="https://images2.imgbox.com/a7/44/SNcIVkpP_o.png" alt="在这里插入图片描述"><br>   页式虚拟存储器的优点是，页面长度固定，页表简单，调入方便。缺点是，<mark>由于程序不可能正好是页面的整数倍，最后一页的零头将无法利用而造成浪费，并且页不是逻辑上独立的实体，所以处理、保护和共享都不及段式虚拟存储器方便。</mark></p> 
<hr> 
<p>  在虚拟存储器中，页面不能设置得过大，也不能设置过小：<br>   页面太小时，平均页内剩余空间较少，可节省存储空间，但会使得页表增大，而且页面太小时不能充分利用访存的空间局部性来提高命中率；页面太大时，可减少页表空间，但平均页内剩余空间较大，会浪费较多存储空间，页面太大还会使页面调入/调出的时间较长</p> 
<hr> 
<h5><a id="8195373_TLB_734"></a> 3.7.3 加快地址转换：快表（TLB）</h5> 
<p>  由地址转换过程可知，访存时先访问一次主存去查页表，再访问主存才能取得数据。如果缺页，还要进行页面替换、页面修改等，因此采用虚拟存储机制后，访问主存的次数更多了。<br>   依据程序执行的局部性原理，在一段时间内总是经常访问某些页时，若把这些页对应的页表项存放在高速缓冲器组成的快表（TLB）中，则可以明显提高效率。相应地把放在主存中的页表称为慢表（Page）。<mark>在地址转换时，首先查找快表，若命中，则无须访问主存中的页表。</mark><br>   <mark>快表通常采用全相联或组相联方式。</mark> <mark>每个TLB项由页表表项内容加上一个TLB标记字段组成，TLB标记用来表示该表项取自页表中哪个虚页号对应的页表项，</mark> 因此，<mark>TLB标记的内容在全相联方式下就是该页表项对应的虚页号；组相联方式下则是对应虚页号的高位部分，虚页号的低位部分用于选择TLB组的组索引。</mark><br>   下图为一个具有TLB和Cache的多级存储系统：<br> <img src="https://images2.imgbox.com/cb/32/HpRuzGaC_o.png" alt="在这里插入图片描述"><br>   图中Cache采用二路组相联方式。CPU给出一个32位的虚拟地址，TLB采用全相联方式，每一项都有一个比较器，查找时将虚页号与每个TLB标记字段同时进行比较，若有一项相等且对应有效位为1，则TLB命中，此时可直接通过TLB进行地址转换；若未命中，则TLB缺失，需要访问主存去查页表。图中所示的是两级页表方式，虚页号被分成目录索引和页表索引两部分，由这两部分得到对应的页表项，从而进行地址转换，并将相应表项调入TLB，若TLB已满，则还需要采用替换策略。完成由虚拟地址到物理地址的转换后，Cache机构根据映射方式将物理地址划分为多个字段，然后根据映射规则找到对应的Cache行或组，将对应Cache行中的标记与物理地址中的高位部分进行比较，若相等且对应有效位为1，则Cache命中，此时根据块内地址取出对应的字送CPU。<br>   查找时，快表和慢表也可以同步进行，若快表中有此虚页号，则能很快地找到对应的实页号，并使慢表的查找作废。<br>   在一个具有Cache和TLB的虚拟存储系统中，CPU一次访存操作可能涉及TLB、页表、Cache、主存和磁盘的访问，访问过程如图：<br> <img src="https://images2.imgbox.com/bc/fa/pNm8sbAM_o.png" alt="在这里插入图片描述"><br>   <mark>CPU访存过程中存在3种缺失情况：（1）TLB缺失：要访问的页面对应的页表项不在TLB中；（2）Cache缺失：要访问的主存块不在Cache中；（3）缺页：要访问的页面不在主存中</mark><br> <img src="https://images2.imgbox.com/d8/34/iugSTpVA_o.png" alt="在这里插入图片描述"><br>   第一种组合无须访问主存；第2种和第3种组合需访问一次主存；第4种组合需要访问2次主存；第5种组合发生缺页异常，需访问磁盘，并且至少访问两次主存。<mark>Cache缺失处理由硬件完成；缺页处理由软件完成，由OS通过缺页异常处理程序来实现；而TLB缺失既可以用硬件又可以用软件来处理，比如OS有专门的TLB缺失异常处理程序。</mark></p> 
<h5><a id="8195374__747"></a> 3.7.4 段式虚拟存储器</h5> 
<p>  <mark>段式虚拟存储器中的段是按程序的逻辑结构划分的，各个段的长度因程序而异。</mark> <mark>把虚拟地址分为两部分：段号和段内地址。</mark> <mark>虚拟地址到实地址之间的变换是由段表来实现的。段表是程序的逻辑段和在主存中存放位置的对照表。</mark> 段表的每行记录与某个段对应的段号、装入位、段起点和段长等信息。<mark>由于段的长度可变，所以段表中要给出各段的起始地址与段的长度。</mark><br>   CPU根据虚拟地址访存时，首先根据段号与段表基地址拼接成对应的段表行，然后根据该段表行的装入位判断该段是否已调入主存。已调入主存时，<mark>从段表读出该段在主存中的起始地址，与段内地址（偏移量）相加，得到对应的主存实地址。</mark><br>   段式虚拟存储器的优点是，<mark>段的分界与程序的自然分界相对应，因而具有逻辑独立性，</mark> 使得它易于编译、管理、修改和保护，也便于多道程序的共享；缺点是因为段的长度可变，分配空间不便，<mark>容易在段间留下碎片</mark>，造成浪费。</p> 
<h5><a id="8195375__752"></a> 3.7.5 段页式虚拟存储器</h5> 
<p>  <mark>把程序按逻辑结构分段，每段再划分为固定大小的页，主存空间也划分为大小相等的页，程序对主存的调入、调出仍以页为基本传送单位，这样的虚拟存储器称为段页式虚拟存储器。</mark> 在段页式虚拟存储器中，<mark>每个程序对应一个段表，每段对应一个页表，段的长度必须是页长的整数倍，段的起点必须是某一页的起点。</mark><br>   虚地址分为段号、段内页号、页内地址三部分。CPU根据虚地址访存时，首先根据段号得到段表地址；然后从段表中取出该段的页表起始地址，与虚地址段内页号合成，得到页表地址；最后从页表中取出实页号，与页内地址拼接形成主存实地址。<br>   段页式虚拟存储器兼具页式和段式虚拟存储器的优点，可以按段实现共享和保护。缺点是<mark>在地址变换过程中需要两次查表，系统开销较大。</mark></p> 
<h5><a id="8195376_Cache_757"></a> 3.7.6 虚拟存储器与Cache的比较</h5> 
<h6><a id="819581951_758"></a>  1.相同之处</h6> 
<p>  （1）最终目标都是为了提高系统性能，两者都有容量、速度、价格的梯度<br>   （2）都把数据划分为小信息块，并作为基本的传递单位，虚存系统的信息块更大<br>   （3）都有地址的映射、替换算法、更新策略等问题<br>   （4）依据程序的局部性原理应用快速缓存的思想，将活跃的数据放在相对高速的部件中</p> 
<h6><a id="819581952_764"></a>  2.不同之处</h6> 
<p>  （1）<mark>Cache主要解决系统速度，而虚拟存储器是为了解决主存容量</mark><br>   （2）<mark>Cache全由硬件实现，是硬件存储器，对所有程序员透明；而虚拟存储器由OS和硬件共同实现，是逻辑上的存储器，对系统程序员不透明，但对应用程序员透明</mark><br>   （3）对于不命中性能影响，因为CPU的速度约为Cache的10倍，主存的速度为硬盘的100倍以上，因此虚拟存储器系统不命中时对系统性能的影响更大<br>   （4）CPU与Cache和主存都建立了直接访问的通路，而辅存与CPU没有直接通路。即在Cache不命中时主存能和CPU直接通信，同时将数据调入Cache；而虚拟存储器系统不命中时，只能先由硬盘调入主存，而不能直接和CPU通信。</p> 
<hr> 
<p>  例题：虚拟存储管理系统的基础是程序访问的局部性原理，此理论的基本含义是（）<br>   A.在程序的执行过程中，程序对主存的访问是不均匀的<br>   B.空间局部性<br>   C.时间局部性<br>   D.代码的顺序执行</p> 
<p>  答案：A；</p> 
<p>  例题：<img src="https://images2.imgbox.com/54/82/Y1d7BXwi_o.png" alt="在这里插入图片描述"><br>   答案：（1）24位，高12位；20位，高8位；<br>   （2）<img src="https://images2.imgbox.com/79/af/qiGXUb1z_o.png" alt="在这里插入图片描述"><br>   （3）在主存中，04C60H；主存块映射到Cache的第3行，由于该行标记105H！=04CH，因此未命中<br>   （4）<mark>虚页号中高11位为TLB标记，最低1位为TLB组号。</mark> 该虚拟地址所对应的物理页面映射到TLB的第0组，组0中存在有效位为1，标记=012H的项，因此访问TLB命中，即虚拟地址所在的页面在主存中</p> 
<p>  例题：<img src="https://images2.imgbox.com/86/9d/LYQsgsxF_o.png" alt="在这里插入图片描述"></p> 
<p>  答案：（1）4889、3245、缺页中断、1272、缺页中断、5332<br>   （2）第二页不在内存，产生缺页中断，根据改进的Clock算法，第三页为未被引用和修改的页面，因此淘汰。新页面进入：<br> <img src="https://images2.imgbox.com/bd/a3/rw8MJyIl_o.png" alt="在这里插入图片描述"><br> 地址转换变为：<br> <img src="https://images2.imgbox.com/b8/30/Z7fLUYCN_o.png" alt="在这里插入图片描述"></p> 
<p>  例题：<img src="https://images2.imgbox.com/68/47/oI6nkpWq_o.png" alt="在这里插入图片描述"><br>   答案：（1）80324；（2）96128；（3）该页面在快表（页表）中无记录</p> 
<p>  例题：一个两级存储器系统有8个磁盘上的虚拟页面需要映像到主存的4个页中。某程序生成以下访存页面序列：1,0，2，2，1,7，6，7,0，1，2，0,3，0，4，5，1，5，2，4，5，6,7，6,7,2，4，2,7，3；采用LRU替换策略，设初始时主存为空<br> （1）画出每个页号访问请求之后存放在主存中的位置<br> （2）计算主存的命中率</p> 
<p>  答案：（1）<img src="https://images2.imgbox.com/f5/99/MjOKYlg9_o.png" alt="在这里插入图片描述"><br> （2）13/30</p> 
<p>  例题：<br> <img src="https://images2.imgbox.com/63/3d/usAoYx5n_o.png" alt="在这里插入图片描述"><br>   答案：（1）28位；（2）全相联映射，SRAM；（3）2路组相联，需要1位LRU位（LRU位位数与Cache组大小有关，每组若有2个Cache行，则需1位LRU位），1位脏位；8x2x(1+1+1+20+8x2^5)=558B;Cache中有效位用来指出所在Cache行中的信息是否有效；（4）0040040H，将00400H与Cache中第2组两行中的标志字段同时比较，虽然有一个Cache行中的标志字段与00400H相等，但对应的有效位为0，而另一行的标志字段不相等，因此访问Cache不命中；组号为3</p> 
<hr>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/7468f90ede24bf68e09796e4aac9ded1/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">解决服务启动报错：org.apache.dubbo.remoting.RemotingException: client(url: dubbo://192.168.1.137:20880问题</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/c48f15881de3a84e01324135b8e0ae24/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">网站服务</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>