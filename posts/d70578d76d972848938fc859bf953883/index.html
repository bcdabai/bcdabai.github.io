<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>原码反码补码以及左移右移无符号左移右移。 - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="原码反码补码以及左移右移无符号左移右移。" />
<meta property="og:description" content="一. 机器数和真值 在学习原码, 反码和补码之前, 需要先了解机器数和真值的概念.
1、机器数
一个数在计算机中的二进制表示形式, 叫做这个数的机器数。机器数是带符号的，在计算机用一个数的最高位存放符号, 正数为0, 负数为1.
比如，十进制中的数 &#43;3 ，计算机字长为8位，转换成二进制就是00000011。如果是 -3 ，就是 10000011 。
那么，这里的 00000011 和 10000011 就是机器数。
2、真值
因为第一位是符号位，所以机器数的形式值就不等于真正的数值。例如上面的有符号数 10000011，其最高位1代表负，其真正数值是 -3 而不是形式值131（10000011转换成十进制等于131）。所以，为区别起见，将带符号位的机器数对应的真正数值称为机器数的真值。
例：
0000 0001的真值 = &#43;000 0001 = &#43;1，
1000 0001的真值 = –000 0001 = –1
原码, 反码, 补码的基础概念和计算方法.
二.原码反码补码概念 计算机中二进制相加逢二进一
在探求为何机器要使用补码之前, 让我们先了解原码, 反码和补码的概念.对于一个数, 计算机要使用一定的编码方式进行存储. 原码, 反码, 补码是机器存储一个具体数字的编码方式.
原码: 原码就是符号位加上真值的绝对值, 即用第一位表示符号, 其余位表示值. 比如如果是8位二进制:
[&#43;1]原 = 0000 0001 [-1]原 = 1000 0001 第一位是符号位. 因为第一位是符号位, 所以8位二进制数的取值范围就是:" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/d70578d76d972848938fc859bf953883/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2020-09-26T23:04:10+08:00" />
<meta property="article:modified_time" content="2020-09-26T23:04:10+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">原码反码补码以及左移右移无符号左移右移。</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <h4>一. 机器数和真值 </h4> 
<p>在学习原码, 反码和补码之前, 需要先了解机器数和真值的概念.</p> 
<p><strong>1、机器数</strong><br> 一个数在计算机中的二进制表示形式, 叫做这个数的机器数。机器数是带符号的，在计算机用一个数的最高位存放符号, 正数为0, 负数为1.</p> 
<p>比如，十进制中的数 +3 ，计算机字长为8位，转换成二进制就是00000011。如果是 -3 ，就是 10000011 。</p> 
<p>那么，这里的 00000011 和 10000011 就是机器数。</p> 
<p><strong>2、真值</strong><br> 因为第一位是符号位，所以机器数的形式值就不等于真正的数值。例如上面的有符号数 10000011，其最高位1代表负，其真正数值是 -3 而不是形式值131（10000011转换成十进制等于131）。所以，为区别起见，将带符号位的机器数对应的真正数值称为机器数的真值。</p> 
<p>例：<br> 0000 0001的真值 = +000 0001 = +1，<br> 1000 0001的真值 = –000 0001 = –1<br> 原码, 反码, 补码的基础概念和计算方法.</p> 
<hr> 
<h4>二.原码反码补码概念 </h4> 
<blockquote> 
 <p>计算机中二进制相加逢二进一<br> 在探求为何机器要使用补码之前, 让我们先了解原码, 反码和补码的概念.对于一个数, 计算机要使用一定的编码方式进行存储. 原码, 反码, 补码是机器存储一个具体数字的编码方式.</p> 
</blockquote> 
<h4>原码: </h4> 
<p>原码就是符号位加上真值的绝对值, 即用第一位表示符号, 其余位表示值. 比如如果是8位二进制:</p> 
<pre><code>[+1]原 = 0000 0001

[-1]原 = 1000 0001
</code></pre> 
<p>第一位是符号位. 因为第一位是符号位, 所以8位二进制数的取值范围就是:</p> 
<p>[1111 1111 , 0111 1111<br> 即<br> [-127 , 127]</p> 
<p>原码是人脑最容易理解和计算的表示方式.</p> 
<h4>反码 </h4> 
<p>反码的表示方法是:</p> 
<ul><li> <p>正数的反码是其本身</p> </li><li> <p>负数的反码是在其原码的基础上, 符号位不变，其余各个位取反.</p> </li></ul> 
<p>[+1] = [00000001]原 = [00000001]反</p> 
<p>[-1] = [10000001]原 = [11111110]反</p> 
<p>可见如果一个反码表示的是负数, 人脑无法直观的看出来它的数值. 通常要将其转换成原码再计算.</p> 
<h4>补码 </h4> 
<p>补码的表示方法是:</p> 
<ul><li> <p>正数的补码就是其本身</p> </li><li> <p>负数的补码是在其原码的基础上, 符号位不变, 其余各位取反, 最后+1. (即在反码的基础上+1)</p> </li></ul> 
<p>[+1] = [00000001]原 = [00000001]反 = [00000001]补</p> 
<p>[-1] = [10000001]原 = [11111110]反 = [11111111]补</p> 
<p>对于负数, 补码表示方式也是人脑无法直观看出其数值的. 通常也需要转换成原码在计算其数值.</p> 
<hr> 
<h4>三. 为何要使用原码, 反码和补码 </h4> 
<p>现在我们知道了计算机可以有三种编码方式表示一个数. 对于正数因为三种编码方式的结果都相同:</p> 
<pre><code>[+1] = [00000001]原 = [00000001]反 = [00000001]补
</code></pre> 
<p>所以不需要过多解释. 但是对于负数:</p> 
<pre><code>[-1] = [10000001]原 = [11111110]反 = [11111111]补
</code></pre> 
<p><strong>那有了原码，为什么还需要补码和反码呢？为什么负数需要反码和补码的表示形式呢？</strong><br> 计算十进制的表达式：1+1=2</p> 
<pre><code>1 + 1 = [00000001]原 + [00000001]原 = [00000010]原 = 2 
</code></pre> 
<p>从上面来看十进制只是完成了两个正数的相加，但是看下面：</p> 
<p>计算十进制的表达式: 1-1=0</p> 
<pre><code>1 - 1 = 1 + (-1) = [00000001]原 + [10000001]原 
=  [10000010]原 = -2
</code></pre> 
<p>如果用原码表示, 让符号位也参与计算, 显然对于减法来说, 结果是不正确的.这也就是为何计算机内部不使用原码表示一个数.</p> 
<p><strong>为了解决原码做减法的问题, 出现了反码:</strong></p> 
<p>计算十进制的表达式: 1-1=0</p> 
<pre><code>1 - 1 = 1 + (-1) 
= [0000 0001]原 + [1000 0001]原
= [0000 0001]反 + [1111 1110]反 
= [1111 1111]反 
= [1000 0000]原 = -0
</code></pre> 
<p><strong>发现用反码计算减法, 结果的真值部分是正确的. 而唯一的问题其实就出现在"0"这个特殊的数值上. 虽然人们理解上+0和-0是一样的, 但是0带符号是没有任何意义的. 而且会有[0000 0000]原和[1000 0000]原两个编码表示0.</strong></p> 
<p>于是补码的出现, 解决了0的符号以及两个编码的问题:</p> 
<pre><code>1-1 = 1 + (-1) 
= [0000 0001]原 + [1000 0001]原 
= [0000 0001]补 + [1111 1111]补 
= [0000 0000]补
=[0000 0000]原
=0
</code></pre> 
<p>这样0用[0000 0000]表示, 而以前出现问题的-0则不存在了.而且可以用[1000 0000]表示-128:</p> 
<pre><code>(-1) + (-127) 
= [1000 0001]原 + [1111 1111]原 
= [1111 1111]补 + [1000 0001]补 
= [1000 0000]补
=-128
</code></pre> 
<p><strong>-1-127的结果应该是-128, 在用补码运算的结果中, [1000 0000]补 就是-128.</strong> 但是注意因为实际上是使用以前的-0的补码来表示-128, 所以-128并没有原码和反码表示.(对-128的补码表示[1000 0000]补算出来的原码是[0000 0000]原, 这是不正确的)</p> 
<p>使用补码, 不仅仅修复了0的符号以及存在两个编码的问题, 而且还能够多表示一个最低数. 这就是为什么8位二进制, 使用原码或反码表示的范围为[-127, +127], 而使用补码表示的范围为[-128, 127].</p> 
<p>因为机器使用补码, 所以对于编程中常用到的32位int类型, 可以表示范围是: [-231, 231-1] 因为第一位表示的是符号位.而使用补码表示时又可以多保存一个最小值.</p> 
<p>四.左移&lt;&lt;,右移&gt;&gt;,和无符号右移&gt;&gt;&gt;</p> 
<blockquote> 
 <p>根据上面的结论可以知道，计算机底层使用的是补码的方式进行运算的。</p> 
</blockquote> 
<p><strong>计算十进制表达式：4/4=2</strong></p> 
<pre><code>//换成位移运算(右移两位相当于:4/（2*2）)
4/4 = 4&gt;&gt;2
//转换成二进制补码运算(正数的原码反码补码相同)，也就是4的二进制右移两位。
=00000100[补]
//正数右移后高位补零
=00 000001
//换算成十进制
=1
</code></pre> 
<p><strong>计算十进制表达式:-4/2=-2</strong></p> 
<pre><code>//换算成位运算
-4/2 = -4&gt;&gt;2
//转换成二进制补码运算(负数的补码:符号位不变，其余的取反然后加1)
=10000100[原] = 11111100[补]
//负数右移两位后高位补1,因为要保证符号为负 即1
=11 111111[补]
//负数得到运算后的补码需要转回原码然后转成十进制(符号位不变，然后取反+1)
=10000001[原]
//换算成十进制
=-1
</code></pre> 
<p><strong>计算十进制表达式:1*4=4</strong></p> 
<pre><code>//换算成位运算(左移两位相当于:1*（2*2）)
1*4 = 1&lt;&lt;2
//转换成二进制补码运算
=00000001[补]
//左移两位低位补0
=000001 00[补]
//转换成十进制
=4
</code></pre> 
<p><strong>计算十进制表达式:-1*4=-4</strong></p> 
<pre><code>//换算成位运算
-1*4 = -1&lt;&lt;2
//换算成二进制补码运算
=10000001[原] = 11111111[补]
//左移两位低位补0
=111111 00[补]
//转换成原码（负数补码取反加1 = 原码）
=10000100[原]
//转换成十进制
=-4
</code></pre> 
<p><strong>无符号右移</strong></p> 
<blockquote> 
 <p>无符号右移，不论正负高位统一补0</p> 
</blockquote> 
<p>计算无符号右移:4&gt;&gt;&gt;2</p> 
<pre><code>4&gt;&gt;&gt;2
//换算成二进制补码运算
=00000100[补]
//开始右移两位
=00000001[补]
//换算成十进制
=1
</code></pre> 
<p>计算无符号右移:-4&gt;&gt;&gt;2</p> 
<pre><code>-4&gt;&gt;&gt;2
//换算成二进制补码运算
=10000100[原] = 11111100[补]
//开始右移两位，无符号右移中无论正负高位统一补0
=00111111[补]
//换算成十进制，int类型是32位，以上举例统一用8位只是方便计算。
=1073741823
</code></pre> 
<p><strong>从上面的无符号运算来看，正数的无符号右移和带符号右移的结果是一样的，因为带符号右移的时候也是高位补0，负数在带符号右移的时候是高位补1的，所以负数得到的结果是不会相同的。</strong></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/27f1240bf1a9a0a79695d2325a5eb579/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">mysql列相加和列数据相加的方法函数</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/a8810d4593282560636c8d967d7deb87/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">服务器性能测试-增加了请求数，但是tps上不去，反而下降了</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>