<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>@Import注解使用详解 - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="@Import注解使用详解" />
<meta property="og:description" content="@Import注解使用详解 @Import注解可以用来导入配置类，功能与 xml 中的 import 标签等效。
Import注解定义源码 /** * 可以导入的一个或多个 @Configuration 类 Indicates one or more {@link Configuration @Configuration} classes to import. * @Import的功能与 xml 中的 &lt;import/&gt;标签等效 * &lt;p&gt;Provides functionality equivalent to the {@code &lt;import/&gt;} element in Spring XML. 允许导入 @Configuration 类 、ImportSelector 和 ImportBeanDefinitionRegistrar 的实现 以及导入普通类（4.2版本开始支持；类似 AnnotationConfigApplicationContext#register(java.lang.Class&lt;?&gt;) * Allows for importing {@code @Configuration} classes, {@link ImportSelector} and * {@link ImportBeanDefinitionRegistrar} implementations, as well as regular component * classes (as of 4." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/a5648ec1ffc7b3a9a8630cc08ede4ede/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-03-29T13:48:42+08:00" />
<meta property="article:modified_time" content="2023-03-29T13:48:42+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">@Import注解使用详解</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <h2>@Import注解使用详解</h2> 
<p>@Import注解可以用来导入配置类，功能与 xml 中的 import 标签等效。</p> 
<h4>Import注解定义源码</h4> 
<pre><code>/**
 * 可以导入的一个或多个 @Configuration 类
 Indicates one or more {@link Configuration @Configuration} classes to import.
 * @Import的功能与 xml 中的 &lt;import/&gt;标签等效
 * &lt;p&gt;Provides functionality equivalent to the {@code &lt;import/&gt;} element in Spring XML.
   允许导入 @Configuration 类 、ImportSelector 和 ImportBeanDefinitionRegistrar 的实现 以及导入普通类（4.2版本开始支持；类似 AnnotationConfigApplicationContext#register(java.lang.Class&lt;?&gt;)
 * Allows for importing {@code @Configuration} classes, {@link ImportSelector} and
 * {@link ImportBeanDefinitionRegistrar} implementations, as well as regular component
 * classes (as of 4.2; analogous to {@link AnnotationConfigApplicationContext#register}).
 *
 * 可以在类级别声明或作为元注释。
 * &lt;p&gt;May be declared at the class level or as a meta-annotation.
 * 如果需要导入XML 或其他非bean 定义资源，请改用@ImportResource注解
 * &lt;p&gt;If XML or other non-{@code @Configuration} bean definition resources need to be
 * imported, use the {@link ImportResource @ImportResource} annotation instead.
 * @since 3.0
 * @see Configuration
 * @see ImportSelector
 * @see ImportResource
*/
@Target(ElementType.TYPE)
@Retention(RetentionPolicy.RUNTIME)
@Documented
public @interface Import {

    /**
     * {@link Configuration}, {@link ImportSelector}, {@link ImportBeanDefinitionRegistrar}
     * or regular component classes to import.
     */
    Class&lt;?&gt;[] value();

}
复制代码</code></pre> 
<p><code>Import</code>注解源码的定义非常简单，就一个属性 <code>value</code>，而且是一个 <code>Class</code> 类型的数组。</p> 
<p>结合上面的注释，对我们了解<code>Import</code>有很大的帮助。</p> 
<ul><li>可以同时导入多个 <code>@Configuration</code>类 、<code>ImportSelector 和 ImportBeanDefinitionRegistrar</code> 的实现，以及导入普通类（4.2版本开始支持）</li><li><code>@Import</code>的功能与 xml 中的 <code>&lt;import/&gt;</code>标签等效</li><li>在类级别声明或作为元注释</li><li>如果需要导入XML 或其他非bean 定义资源，请使用<code>@ImportResource</code>注解</li></ul> 
<h4>支持的三种类型</h4> 
<ul><li>实现 <code>ImportSelector</code> 接口的类</li><li>实现 <code>ImportBeanDefinitionRegistrar</code> 接口的类</li><li>不是上述两种情况，将类作为配置类处理。</li></ul> 
<p>接下来小杰带大家来看看使用过程。</p> 
<h2>代码测试</h2> 
<h3>@Import导入普通类</h3> 
<ul><li>提供 <code>ImportTest</code>类，该类没有任何注解标注</li></ul> 
<pre><code>public class ImportTest {

    public void importTest(){
        System.out.println("ImportTest === &gt;");
    }
}
复制代码</code></pre> 
<ul><li>扫描并使用 <code>@Import</code>导入 <code>ImportTest</code>类，进行启动</li></ul> 
<pre><code>@ComponentScan(basePackages = "com.cxyxj.importdemo")
@Import({ImportTest.class})
public class AppMain {

    public static void main(String[] args) {
        AnnotationConfigApplicationContext context = new AnnotationConfigApplicationContext(AppMain.class);
        // 从容器中获得 ImportTest 
        ImportTest bean = context.getBean(ImportTest.class);
        bean.test();

    }
}

结果：
ImportTest === &gt;   
复制代码</code></pre> 
<h3>@Import导入配置类</h3> 
<p>这里说的配置类是被 <code>@Configuration</code>标注的类。</p> 
<pre><code>@Configuration
public class ImportTest {

    public void test(){
        System.out.println("ImportTest === &gt;");
    }
}
复制代码</code></pre> 
<ul><li>启动结果和导入普通类一致。区别在于 <strong>被 <code>@Configuration</code>标注的类会被 CGLIB 进行代理</strong>。</li></ul> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/74/c5/9WHV03fI_o.png"></p> 
<h3>实现 <code>ImportSelector</code></h3> 
<h4>基本使用</h4> 
<ul><li>创建 <code>ImportSelectorComponent</code>类，该类会被导入。</li></ul> 
<pre><code>public class ImportSelectorComponent {

    public void test(){
        System.out.println("ImportSelectorComponent === &gt;");
    }
}
复制代码</code></pre> 
<ul><li>创建 <code>ImportSelectorTest</code>类，实现 <code>ImportSelector</code>接口，并重写 <code>selectImports</code>方法，方法返回的是需要导入类的全限定名的数组。</li></ul> 
<pre><code>public class ImportSelectorTest implements ImportSelector {
    @Override
    public String[] selectImports(AnnotationMetadata importingClassMetadata) {
        //return new String[]{"com.cxyxj.importdemo.ImportSelectorComponent"};
        return new String[]{ImportSelectorComponent.class.getName()};
    }
}
复制代码</code></pre> 
<ul><li><code>@Import</code>导入的值修改为 <code>ImportSelectorTest.class</code>，并进行启动</li></ul> 
<pre><code>@ComponentScan(basePackages = "com.cxyxj.importdemo")
@Import({ImportSelectorTest.class})
public class AppMain {

    public static void main(String[] args) {
        AnnotationConfigApplicationContext context = new AnnotationConfigApplicationContext(AppMain.class);
        //这里也要修改：获得 ImportSelectorComponent
        ImportSelectorComponent bean = context.getBean(ImportSelectorComponent.class);
        bean.test();
 		// 打印 bean 名称
        String[] beanDefinitionNames = context.getBeanDefinitionNames();
        for (String name : beanDefinitionNames){
            System.out.println(name);
        }
    }
}

结果：
ImportSelectorComponent === &gt;
org.springframework.context.annotation.internalConfigurationAnnotationProcessor
org.springframework.context.annotation.internalAutowiredAnnotationProcessor
org.springframework.context.annotation.internalCommonAnnotationProcessor
org.springframework.context.event.internalEventListenerProcessor
org.springframework.context.event.internalEventListenerFactory
appMain
com.cxyxj.importdemo.ImportSelectorComponent
复制代码</code></pre> 
<p><strong>注意被<code>ImportSelector</code>导入的类的 beanName 是类的全限定名称，实现 ImportSelector 的类不会被注入容器中。</strong></p> 
<p>效果达到之后，你会发现这种使用方式有点繁琐，还要写一个实现类。觉得并没有什么用，直接使用 <code>import</code>直接导入不更优雅吗。的确是的，如果是导入固定的 Bean 定义，这种方式肯定不是最优的。所以它的用途在其他方向，比如需要进行一些逻辑处理之后，进行动态注册时，该方式是非常有用的。在 <code>Spring</code>、<code>Spring Boot</code>底层大量使用该方式进行导入Bean定义。</p> 
<h4>源码定义</h4> 
<pre><code>
/**
 * Interface to be implemented by types that determine which @{@link Configuration}
 * class(es) should be imported based on a given selection criteria, usually one or
 * more annotation attributes.
 *
 * &lt;p&gt;An {@link ImportSelector} may implement any of the following
 * {@link org.springframework.beans.factory.Aware Aware} interfaces,
 * and their respective methods will be called prior to {@link #selectImports}:
 * &lt;ul&gt;
 * &lt;li&gt;{@link org.springframework.context.EnvironmentAware EnvironmentAware}&lt;/li&gt;
 * &lt;li&gt;{@link org.springframework.beans.factory.BeanFactoryAware BeanFactoryAware}&lt;/li&gt;
 * &lt;li&gt;{@link org.springframework.beans.factory.BeanClassLoaderAware BeanClassLoaderAware}&lt;/li&gt;
 * &lt;li&gt;{@link org.springframework.context.ResourceLoaderAware ResourceLoaderAware}&lt;/li&gt;
 * &lt;/ul&gt;
 *
 * &lt;p&gt;{@code ImportSelector} implementations are usually processed in the same way
 * as regular {@code @Import} annotations, however, it is also possible to defer
 * selection of imports until all {@code @Configuration} classes have been processed
 * (see {@link DeferredImportSelector} for details).
 *
 * @author Chris Beams
 * @since 3.1
 * @see DeferredImportSelector
 * @see Import
 * @see ImportBeanDefinitionRegistrar
 * @see Configuration
 */
public interface ImportSelector {

	/**
	 * Select and return the names of which class(es) should be imported based on
	 * the {@link AnnotationMetadata} of the importing @{@link Configuration} class.
	 */
	String[] selectImports(AnnotationMetadata importingClassMetadata);

}
复制代码</code></pre> 
<p><code>ImportSelector</code>接口的源码也是很简单的。接口中就一个<code>selectImports</code>方法。方法的参数是<code>AnnotationMetadata</code>，通过该参数我们可以获得被 <code>@Import</code>标注的类的各种信息，比如：Class名称，实现的接口名称、父类名称、类上的其他注解信息。</p> 
<p>代码示例小杰就不写了，我们看看 <code>Spring</code>的处理方式。找到<code>ImportSelector</code>接口的抽象子类 <code>AdviceModeImportSelector</code>，当我们在启动类上加上 <code>@EnableAsync</code>或者<code>@EnableCaching</code>就会进行到这里。</p> 
<p>代码意思也不阐述了，打个断点跑一遍就清楚了。</p> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/51/6c/yBtdpziw_o.png"></p> 
<p>我们来看看接口上的注释，大意如下：</p> 
<pre><code>由类实现的接口，可以导入一个或者多个类。
该接口的实现类同时实现EnvironmentAware， BeanFactoryAware ，BeanClassLoaderAware、ResourceLoaderAware，那么在调用其 selectImports 方法之前先调用上述接口中对应的方法。
ImportSelector实现的处理方式通常与常规的@Import注解相同，如果想延迟导入，可以使用 ImportSelector 的子接口 DeferredImportSelector，它会在所有 @Configuration类都被处理完之后，才开始进行导入。    
复制代码</code></pre> 
<p><code>DeferredImportSelector</code>与 <code>SpringBoot自动装配</code>有很大的关系，这个到<code>Spring Boot</code>系列再说。</p> 
<h3>实现 <code>ImportBeanDefinitionRegistrar</code></h3> 
<h4>基本使用</h4> 
<ul><li>创建 <code>ImportBeanDefinitionRegistrarComponent</code>普通类</li></ul> 
<pre><code>public class ImportBeanDefinitionRegistrarComponent {

    public void test(){
        System.out.println("ImportBeanDefinitionRegistrarComponent === &gt;");
    }
}
复制代码</code></pre> 
<ul><li>创建 <code>ImportBeanDefinitionRegistrarTest</code>，实现 <code>ImportBeanDefinitionRegistrar</code>接口，并重写 <code>registerBeanDefinitions</code>方法</li></ul> 
<pre><code>public class ImportBeanDefinitionRegistrarTest implements ImportBeanDefinitionRegistrar {

    @Override
    public void registerBeanDefinitions(AnnotationMetadata importingClassMetadata, BeanDefinitionRegistry registry) {
        // containsBeanDefinition：判断容器中是否存在指定的 bean 定义，true 存在
        boolean b = registry.containsBeanDefinition(ImportBeanDefinitionRegistrarComponent.class.getName());
        if (!b){
            RootBeanDefinition beanDefinition = new RootBeanDefinition(ImportBeanDefinitionRegistrarComponent.class);
            //注册BeanDefinition，并指定 beanName
            registry.registerBeanDefinition("registrarComponent", beanDefinition);
        }
    }

}
复制代码</code></pre> 
<ul><li><code>@Import</code>导入的值修改为 <code>ImportBeanDefinitionRegistrarTest.class</code>，并进行启动</li></ul> 
<pre><code>@ComponentScan(basePackages = "com.cxyxj.importdemo")
@Import({ImportBeanDefinitionRegistrarTest.class})
public class AppMain {

    public static void main(String[] args) {
        AnnotationConfigApplicationContext context = new AnnotationConfigApplicationContext(AppMain.class);
        //这里也要修改：获得 ImportBeanDefinitionRegistrarComponent
        ImportBeanDefinitionRegistrarComponent bean = context.getBean(ImportBeanDefinitionRegistrarComponent.class);
        bean.test();

        // 打印 bean 名称
        String[] beanDefinitionNames = context.getBeanDefinitionNames();
        for (String name : beanDefinitionNames){
            System.out.println(name);
        }
    }
}

结果：
ImportBeanDefinitionRegistrarComponent === &gt;
复制代码</code></pre> 
<p><strong>注意被<code>ImportBeanDefinitionRegistrar</code>注册的类的 beanName 是可以自定义的，实现 <code>ImportBeanDefinitionRegistrar</code> 的类不会被注入容器中。</strong></p> 
<p>源码释义跟 <code>ImportSelector</code>差不多，就不在阐述。</p> 
<h4>自定义注解</h4> 
<p>接下来小杰将使用 <code>ImportBeanDefinitionRegistrar</code>实现，添加了我们自定义的<code>@Cxyxj</code>注解的类会被自动加入到Spring容器中。</p> 
<ul><li>自定义注解 Cxyxj</li></ul> 
<pre><code>/**
 * 自定义注解
 * @author cxyxj
 */
@Documented
@Inherited
@Retention(RetentionPolicy.RUNTIME)
@Target({ElementType.TYPE})
public @interface Cxyxj {
}
复制代码</code></pre> 
<ul><li>修改 <code>ImportBeanDefinitionRegistrarTest</code>类的代码，修改如下：</li></ul> 
<pre><code>public class ImportBeanDefinitionRegistrarTest implements ImportBeanDefinitionRegistrar {
    
    @Override
    public void registerBeanDefinitions(AnnotationMetadata importingClassMetadata, BeanDefinitionRegistry registry) {
        // 获得 ComponentScan 注解
        Map&lt;String, Object&gt; annotationAttributes = importingClassMetadata.getAnnotationAttributes(ComponentScan.class.getName());
        // 获得 basePackages 的信息
        String[] basePackages = (String[]) annotationAttributes.get("basePackages");
        // 扫描器，这也是Spring底层扫描使用的
        ClassPathBeanDefinitionScanner scanner = new ClassPathBeanDefinitionScanner(registry, false);
        // 满足任意 includeFilters的会被扫描
        scanner.addIncludeFilter(new AnnotationTypeFilter(Cxyxj.class));
        // 继续扫描
        scanner.scan(basePackages);
    }

}
复制代码</code></pre> 
<ul><li>启动类</li></ul> 
<pre><code>@ComponentScan(basePackages = "com.cxyxj.importdemo")
@Import({ImportBeanDefinitionRegistrarTest.class})
public class AppMain {

    public static void main(String[] args) {
        
        AnnotationConfigApplicationContext context = new AnnotationConfigApplicationContext(AppMain.class);

        CxyxjTest bean = context.getBean(CxyxjTest.class);
        bean.cxyxjTest();
        // 打印 bean 名称
        String[] beanDefinitionNames = context.getBeanDefinitionNames();
        for (String name : beanDefinitionNames){
            System.out.println(name);
        }
    }
}
复制代码</code></pre> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/6b/6f/jabOPyLE_o.png"></p> 
<p>该效果使用 <code>ImportSelector</code>也是可以实现的。</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/de6e2362d54ab484cef563740d64caf8/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">UE C&#43;&#43; Timer定时器的使用</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/c04204f13c23c03b46f7c87684e05adf/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">记录OpenCV和ROS工作空间创建时出现的问题及解决方法</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>