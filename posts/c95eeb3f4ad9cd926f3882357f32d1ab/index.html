<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>qt4 udp  QUdpSocket  -------wireshark - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="qt4 udp  QUdpSocket  -------wireshark" />
<meta property="og:description" content="四十六、Qt网络（六）UDP 像QQ那样，当有很多用户，发送的大部分都是短消息，要求能及时响应，并且对安全性要求不是很高的情况下使用UDP协议。 发送（客户请求发送数据） 很简单，仅需QUdpSocket 的writeDatagram函数即可 void Widget::on_pushButton_clicked() { QUdpSocket *sender; sender = new QUdpSocket(this); QByteArray datagram = &#34;hello world!&#34;; sender-&gt;writeDatagram(datagram.data(),datagram.size(),QHostAddress(&#34;192.168.1.100&#34;),45454); //sender-&gt;writeDatagram(datagram.data(),datagram.size(),QHostAddress::Broadcast,45454); // sender-&gt;writeDatagram(datagram.data(),datagram.size(),QHostAddress::LocalHost,45454); delete sender; } 接收（服务器端监听） 使用QUdpSocket 的bind函数监听某个端口 当监听的端口有数据到达时，QUdpSocket 的信号readyRead()就emit，然后在对应的槽函数里使用QUdpSocket 的readDatagram读取数据 void QIODevice::readyRead () [signal] This signal is emitted once every time new data is available for reading from the device. It will only be emitted again once new data is available, such as when a new payload of network data has arrived on your network socket, or when a new block of data has been appended to your device." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/c95eeb3f4ad9cd926f3882357f32d1ab/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2011-11-21T14:21:02+08:00" />
<meta property="article:modified_time" content="2011-11-21T14:21:02+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">qt4 udp  QUdpSocket  -------wireshark</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <h3 class="title"><a href="http://www.yafeilinux.com/?p=789" rel="bookmark" title="Permanent Link to 四十六、Qt网络（六）UDP">四十六、Qt网络（六）UDP</a></h3> 
<span style="color:#3366ff">像QQ那样，当有很多用户，发送的大部分都是短消息，要求能及时响应，并且对安全性要求不是很高的情况下使用UDP协议。</span> 
<br> 
<br> 发送（客户请求发送数据） 
<br> 很简单，仅需QUdpSocket 的writeDatagram函数即可 
<br> 
<pre><code class="language-cpp">void Widget::on_pushButton_clicked()
{   QUdpSocket *sender;
    sender = new QUdpSocket(this);
    QByteArray datagram = "hello world!";
    sender-&gt;writeDatagram(datagram.data(),datagram.size(),QHostAddress("192.168.1.100"),45454);
    //sender-&gt;writeDatagram(datagram.data(),datagram.size(),QHostAddress::Broadcast,45454);
   // sender-&gt;writeDatagram(datagram.data(),datagram.size(),QHostAddress::LocalHost,45454);
    delete sender;
}
</code></pre> 
<br> 接收（服务器端监听） 
<br> 使用QUdpSocket 的bind函数监听某个端口 
<br> 当监听的端口有数据到达时，QUdpSocket 的信号readyRead()就emit，然后在对应的槽函数里使用QUdpSocket 的readDatagram读取数据 
<br> 
<span style=""><span style="font-family:Verdana; font-size:13px; color:#363534; line-height:15px"></span></span> 
<h4 class="fn" style="margin-top:15px; margin-right:0px; margin-bottom:0px; margin-left:0px; padding-top:3px; padding-right:5px; padding-bottom:3px; padding-left:5px; font-size:16px; background-color:rgb(246,246,246); border-top-width:1px; border-right-width:1px; border-bottom-width:1px; border-left-width:1px; border-top-style:solid; border-right-style:solid; border-bottom-style:solid; border-left-style:solid; border-top-color:rgb(230,230,230); border-right-color:rgb(230,230,230); border-bottom-color:rgb(230,230,230); border-left-color:rgb(230,230,230); font-weight:bold; word-spacing:3px; font:normal normal 600 16px/1.2 Arial; width:971px"> void QIODevice::readyRead ()<tt style="word-spacing:5px"> [signal]</tt></h4> 
<p style="margin-top:0px; margin-right:0px; margin-bottom:0px; margin-left:0px; padding-top:5px; padding-right:5px; padding-bottom:5px; padding-left:5px; line-height:20px"> This signal is emitted once every time new data is available for reading from the device. It will only be emitted again once new data is available, such as when a new payload of network data has arrived on your network socket, or when a new block of data has been appended to your device.</p> 
<p style="margin-top:0px; margin-right:0px; margin-bottom:0px; margin-left:0px; padding-top:5px; padding-right:5px; padding-bottom:5px; padding-left:5px; line-height:20px"> readyRead() is not emitted recursively; if you reenter the event loop or call <a href="qiodevice.html#waitForReadyRead" rel="nofollow" style="color:rgb(0,115,47); text-decoration:none">waitForReadyRead</a>() inside a slot connected to the readyRead() signal, the signal will not be reemitted (although <a href="qiodevice.html#waitForReadyRead" rel="nofollow" style="color:rgb(76,0,51); text-decoration:underline">waitForReadyRead</a>() may still return true).</p> 
<p style="margin-top:0px; margin-right:0px; margin-bottom:0px; margin-left:0px; padding-top:5px; padding-right:5px; padding-bottom:5px; padding-left:5px; line-height:20px"> Note for developers implementing classes derived from <a href="qiodevice.html" rel="nofollow" style="color:rgb(0,115,47); text-decoration:none">QIODevice</a>: you should always emit readyRead() when new data has arrived (do not emit it only because there's data still to be read in your buffers). Do not emit readyRead() in other conditions.</p> 
<br> 
<pre><code class="language-cpp">private:
    QUdpSocket *receiver;
private slots:
    void processPendingDatagram();</code></pre> 
<br> 
<pre><code class="language-cpp">    receiver = new QUdpSocket(this);
    receiver-&gt;bind(45454,QUdpSocket::ShareAddress);
    connect(receiver,SIGNAL(readyRead()),this,SLOT(processPendingDatagram()));</code></pre> 
<br> 
<pre><code class="language-cpp">void Widget::processPendingDatagram() //处理等待的数据报
{
    while(receiver-&gt;hasPendingDatagrams())  //拥有等待的数据报
    {
        QByteArray datagram; //拥于存放接收的数据报
        datagram.resize(receiver-&gt;pendingDatagramSize());
        //让datagram的大小为等待处理的数据报的大小，这样才能接收到完整的数据
        receiver-&gt;readDatagram(datagram.data(),datagram.size());
        //接收数据报，将其存放到datagram中
        ui-&gt;label-&gt;setText(datagram);
        //将数据报内容显示出来
    }
}
</code></pre> 
<br> 
<br> 
<br> 用wireshark监听xp 192.168.1.100和虚拟机fedora 192.168.1.103之间的udp数据包，如下 
<br>                                       hello world 
<br> xp 192.168.1.100-------------------------&gt;fedora 192.168.1.103   
<br> （wireshark操作：capture-&gt;Options里选择要监视的网卡，然后点Start。可以选择capture/capture filters然后选择udp only过滤一下） 
<br> 
<img src="https://images2.imgbox.com/d3/41/xnhGWVca_o.gif" alt=""> 
<br> 
<br> 双击进入详细数据 
<br> 
<img src="https://images2.imgbox.com/5d/f1/EgnzpkNL_o.gif" alt="" height="654" width="872"> 
<br> 
<br> 可见udp Frame的层层包裹， 
<br> 第1层EtherNet II包，记录源MAC和目的MAC等 
<br> 第2层是IPv4包，记录源ip和目的ip等 
<br> 第3层是udp包，记录端口等 
<br> 第4层才是真正的数据，"hello world" 
<br> 
<br>                                              hello world           
<br> fedora 192.168.1.103-------------------------&gt;xp 192.168.1.100 
<br> 和上面一样的，源和目的ip换了一下 
<br> 
<img src="https://images2.imgbox.com/f3/60/S0VEdCas_o.gif" alt=""> 
<br>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/a57bd6d25528cca90fe87d1725e3af18/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">tomcat配置多个端口</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/1daf9fd7f59031c714a245ae5c1a1969/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">关于键盘冲突那点事（3键冲突/7键冲突/PS2/USB的各种原理）</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>