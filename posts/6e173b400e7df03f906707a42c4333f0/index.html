<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>C&#43;&#43;类的六个默认成员函数 - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="C&#43;&#43;类的六个默认成员函数" />
<meta property="og:description" content="类的六个默认成员函数： 1. 构造函数 2. 拷贝构造函数 3. 析构函数 4. 赋值运算符重载 5. 取址（&amp;）运算符重载 6. const修饰的取址运算符重载
我们先定义一个空类：
class A { }; 在经过编译器处理之后它就不在为空，编译器会自动加入一些默认的成员函数，即使在这些函数中什么也不做。编译器处理之后的类相当于：
class A { public: A(); //构造函数 A(const A&amp; a); //拷贝构造函数 ~A(); //析构函数 A&amp; operator =(const A&amp; a); //赋值运算符重载 A* operator &amp;(); //取址运算符重载 const A* operator &amp;() const; //取址运算符重载 }; 注意：这些函数在我们没有显式给出时编译器会为我们自动合成。
1、构造函数 什么是构造函数 它是一个特殊的成员函数，函数名与类名相同，无返回值，在创建对象时由编译器自动调用，以保证每个对象都有一个合适的初始值。在该对象的整个生命周期内只被调用一次。
class Time { public: //构造函数 Time(int hour = 0, int minute = 0, int second = 0) :_hour(hour) ,_minute(minute) ,_second(second) { doSomeThing." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/6e173b400e7df03f906707a42c4333f0/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2017-03-10T10:39:49+08:00" />
<meta property="article:modified_time" content="2017-03-10T10:39:49+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">C&#43;&#43;类的六个默认成员函数</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p><strong>类的六个默认成员函数：</strong> <br> 1. 构造函数 <br> 2. 拷贝构造函数 <br> 3. 析构函数 <br> 4. 赋值运算符重载 <br> 5. 取址（&amp;）运算符重载 <br> 6. const修饰的取址运算符重载</p> 
<p>我们先定义一个空类：</p> 
<pre class="prettyprint"><code class=" hljs ruby"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">A</span></span>
{
};</code></pre> 
<p>在经过编译器处理之后它就不在为空，编译器会自动加入一些默认的成员函数，即使在这些函数中什么也不做。编译器处理之后的类相当于：</p> 
<pre class="prettyprint"><code class=" hljs cs">class A
{
<span class="hljs-keyword">public</span>:
    <span class="hljs-title">A</span>(); <span class="hljs-comment">//构造函数</span>
    A(<span class="hljs-keyword">const</span> A&amp; a); <span class="hljs-comment">//拷贝构造函数</span>
    ~A(); <span class="hljs-comment">//析构函数</span>
    A&amp; <span class="hljs-keyword">operator</span> =(<span class="hljs-keyword">const</span> A&amp; a); <span class="hljs-comment">//赋值运算符重载</span>
    A* <span class="hljs-keyword">operator</span> &amp;(); <span class="hljs-comment">//取址运算符重载</span>
    <span class="hljs-keyword">const</span> A* <span class="hljs-keyword">operator</span> &amp;() <span class="hljs-keyword">const</span>; <span class="hljs-comment">//取址运算符重载</span>
};</code></pre> 
<p><strong>注意：这些函数在我们没有显式给出时编译器会为我们自动合成。</strong></p> 
<h2 id="1构造函数"><strong>1、构造函数 </strong></h2> 
<h3 id="什么是构造函数"><strong>什么是构造函数</strong></h3> 
<p>它是一个特殊的成员函数，函数名与类名相同，无返回值，在创建对象时由编译器自动调用，以保证每个对象都有一个合适的初始值。在该对象的整个生命周期内只被调用一次。</p> 
<pre class="prettyprint"><code class=" hljs cs">class Time
{
<span class="hljs-keyword">public</span>:
    //构造函数
    <span class="hljs-title">Time</span>(<span class="hljs-keyword">int</span> hour = <span class="hljs-number">0</span>, <span class="hljs-keyword">int</span> minute = <span class="hljs-number">0</span>, <span class="hljs-keyword">int</span> second = <span class="hljs-number">0</span>)
        :_hour(hour)
        ,_minute(minute)
        ,_second(second)
    {
        doSomeThing...
    }

<span class="hljs-keyword">private</span>:
    <span class="hljs-keyword">int</span> _hour;
    <span class="hljs-keyword">int</span> _minute;
    <span class="hljs-keyword">int</span> _second;
};</code></pre> 
<h3 id="初始化列表"><strong>初始化列表</strong></h3> 
<p>用于对对象成员进行初始化，格式为在函数名和函数体之间，以一个冒号开始，后面跟着以逗号隔开的数据成员列表，在每个成员后接一个圆括号，括号中为初始化的内容。</p> 
<h3 id="数据成员初始化顺序"><strong>数据成员初始化顺序</strong></h3> 
<p>即使初始化列表中的成员顺序与定义顺序不同，初始化顺序实际也与数据成员定义的顺序一致。 <br> <img src="https://images2.imgbox.com/95/48/NGQORiIg_o.png" alt="构造函数初始化" title=""> <br> 我们注意到，编译器在底层处理初始化列表时，是根据成员的实际定义顺序来一一初始化的，即先给hour赋值，接着minute，最后second，我们尝试修改了数据成员在初始化列表中的顺序后，它在底层的处理顺序人没有变。 <br> <img src="https://images2.imgbox.com/a1/07/wrbtHWov_o.png" alt="构造函数初始化2" title=""></p> 
<h3 id="系统默认合成的构造函数"><strong>系统默认合成的构造函数</strong></h3> 
<p>默认构造函数使用与成员变量初始化相同的规则初始化成员，对于内置类型和复合类型的成员，如数组、指针，只对定义在全局定义作用于的对象初始化，对于局部作用域的内置和复合类型不作初始化。</p> 
<h3 id="关键字explicit">关键字<strong>explicit</strong></h3> 
<p><strong>explicit（明确的）关键字可以阻止构造函数对类型的转换。</strong> <br> 有时你可能会写出下面的代码（Time为上面的时间类）</p> 
<pre class="prettyprint"><code class=" hljs autohotkey">Time t<span class="hljs-comment">;</span>
int <span class="hljs-literal">a</span> = <span class="hljs-number">10</span><span class="hljs-comment">;</span>
t = <span class="hljs-literal">a</span><span class="hljs-comment">;</span></code></pre> 
<p>因为该对象的第一个成员也为int型，所以编译器会将这种代码视为正常，可实际上使用int型的变量给一个类类型的对象可能不是我们期望的做法。若果你这样做了，结果将如下: <br> <img src="https://images2.imgbox.com/a0/e3/8MtjeZly_o.png" alt="T = a;" title=""> <br> 它将int型的变量赋给第一个成员，这在某些情况下会造成严重的后果。为了防止这种情况发生，我们在构造函数前加上explicit关键字，这样在你企图像上面那样赋值时，编译器就会给我们报错。 <br> <img src="https://images2.imgbox.com/67/36/mQNI4WP8_o.png" alt="这里写图片描述" title=""></p> 
<h2 id="2拷贝构造函数">2、<strong>拷贝构造函数</strong></h2> 
<h3 id="拷贝构造函数"><strong>拷贝构造函数</strong></h3> 
<p>函数名与类名相同，无返回值，有一个形参（常用const修饰），<strong>该参数是本类类型的引用。是构造函数的重载</strong>，通过已经存在的对象来创建并初始化对象。</p> 
<pre class="prettyprint"><code class=" hljs cs">class Time
{
<span class="hljs-keyword">public</span>:
    //构造函数
    <span class="hljs-title">Time</span>(<span class="hljs-keyword">int</span> hour = <span class="hljs-number">0</span>, <span class="hljs-keyword">int</span> minute = <span class="hljs-number">0</span>, <span class="hljs-keyword">int</span> second = <span class="hljs-number">0</span>)
        :_hour(hour)
        ,_minute(minute)
        ,_second(second)
    {
        doSomeThing...
    }

    <span class="hljs-comment">//拷贝构造函数</span>
    Time(<span class="hljs-keyword">const</span> Time&amp; t)
        :_hour(t._hour)
        ,_minute(t._minute)
        ,_second(t._second)
    {
        doSomeThing...
    }

<span class="hljs-keyword">private</span>:
    <span class="hljs-keyword">int</span> _hour;
    <span class="hljs-keyword">int</span> _minute;
    <span class="hljs-keyword">int</span> _second;
};</code></pre> 
<h3 id="使用场景"><strong>使用场景</strong></h3> 
<p><strong>1</strong>、使用已经存在的对象创建新的对象</p> 
<pre class="prettyprint"><code class=" hljs vhdl"><span class="hljs-typename">Time</span> t1(<span class="hljs-number">12</span>,<span class="hljs-number">01</span>,<span class="hljs-number">59</span>);
<span class="hljs-typename">Time</span> t2(t1);</code></pre> 
<p><strong>2</strong>、传值方式作为函数的参数</p> 
<pre class="prettyprint"><code class=" hljs cs"><span class="hljs-keyword">void</span> FunTest1(<span class="hljs-keyword">const</span> Time t)
{}</code></pre> 
<p><strong>3</strong>、传值方式作为函数返回值</p> 
<pre class="prettyprint"><code class=" hljs vbscript"><span class="hljs-built_in">Time</span> FunTest2()
{
    <span class="hljs-built_in">Time</span> t;
    return t;
}</code></pre> 
<h3 id="浅拷贝和深拷贝"><strong>浅拷贝和深拷贝</strong></h3> 
<p>对于普通类型的数据，它们之间的拷贝是很简单的，比如：</p> 
<pre class="prettyprint"><code class=" hljs cs"><span class="hljs-keyword">int</span> a = <span class="hljs-number">10</span>;
<span class="hljs-keyword">int</span> b = a;</code></pre> 
<p>而类类型的对象，由于它们内部有着复杂的结构，所以就不能使用简单的赋值运算就完成。</p> 
<pre class="prettyprint"><code class=" hljs r">class String
{
    //构造函数
    <span class="hljs-keyword">...</span>

    //拷贝构造
    String(const String&amp; s)
        :_pStr(s)
    {
        doSomeThing...
    }

private:
    char* _pStr;
};</code></pre> 
<p><img src="https://images2.imgbox.com/f5/7d/eUpNf2x5_o.png" alt="浅拷贝" title=""> <br> 像上面这种做法，只是简单的将s赋给 _pStr，即让 _pStr也指向字符串s，这样造成的后果是多个对象指向同一空间，析构（关于析构的概念在下面介绍）出错，这种拷贝方式叫做<strong>浅拷贝</strong>。 <br> <strong>注意</strong>：系统默认合成的为浅拷贝，<strong>在大多数情况下，我们应该自己写出拷贝构造函数</strong>，即使系统会给我们合成它。</p> 
<p>对于上面这种情况，我们需要主动给他重新开辟空间</p> 
<pre class="prettyprint"><code class=" hljs r">class String
{
    //构造函数
    <span class="hljs-keyword">...</span>

    //拷贝构造函数
    String(const String&amp; s)
        :_pStr(new char[strlen(s._pStr)+<span class="hljs-number">1</span>])
    {
        strcpy(_pStr, s._pStr);
        doSomeThing...
    }

private:
    char* _pStr;
};</code></pre> 
<p><img src="https://images2.imgbox.com/9d/6a/ATnsKRlq_o.png" alt="深拷贝" title=""> <br> 像这样，给新创建的对象开辟一块独立的空间，再将旧对象的内容拷贝过来，这样就不会发生如上的错误了，这种拷贝方式叫作深拷贝。</p> 
<h2 id="3析构函数"><strong>3、析构函数</strong></h2> 
<p>析构函数(destructor) 与构造函数相反，当对象脱离其作用域时（例如对象所在的函数已调用完毕），系统自动执行析构函数。 <br> 析构函数往往用来做“清理善后” 的工作（例如在建立对象时用new开辟了一片内存空间，应在退出前在析构函数中用delete释放）。</p> 
<pre class="prettyprint"><code class=" hljs cs">class String
{
    <span class="hljs-comment">//构造函数</span>
    String(<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span>* pStr = <span class="hljs-string">''</span>)
    {
        <span class="hljs-keyword">if</span>(NULL == pStr)
        {
            _pStr = <span class="hljs-keyword">new</span> <span class="hljs-keyword">char</span>[<span class="hljs-number">1</span>];
            *pStr = <span class="hljs-string">'\0'</span>;
        }
        <span class="hljs-keyword">else</span>
        {
            _pStr = <span class="hljs-keyword">new</span> <span class="hljs-keyword">char</span>[strlen(pStr)+<span class="hljs-number">1</span>];
            strcpy(_pStr, pStr);
        }
    }

    <span class="hljs-comment">//析构函数</span>
    ~String()
    {
        <span class="hljs-keyword">if</span>(_pStr)
        {
            delete[] _pStr;
            _pStr = NULL;
        }
    }

<span class="hljs-keyword">private</span>:
    <span class="hljs-keyword">char</span>* _pStr;
};</code></pre> 
<p>如上所示，我们在创建对象时，给对象申请了空间，申请的空间必须手动去释放，所以我们在析构函数中去释放空间。 <br> 析构函数在对象生命周期结束前由系统自动调用。</p> 
<h2 id="4赋值操作符重载"><strong>4、赋值操作符（=）重载</strong></h2> 
<p>普通类型之间的赋值通过简单的=完成</p> 
<pre class="prettyprint"><code class=" hljs cs"><span class="hljs-keyword">int</span> a = <span class="hljs-number">10</span>;
<span class="hljs-keyword">int</span> b = <span class="hljs-number">20</span>;
a = b;</code></pre> 
<p>对于类类型的对象我们需要对‘=’重载，以完成类类型对象之间的赋值。</p> 
<pre class="prettyprint"><code class=" hljs r">class String
{
    //构造函数
    <span class="hljs-keyword">...</span>

    //拷贝构造
    <span class="hljs-keyword">...</span>

    //赋值运算符重载
    String&amp; operator=(String s)
    {
        std::swap(_pStr, s._pStr);
        <span class="hljs-keyword">return</span> *this;
    }

private:
    char* _pStr;
};</code></pre> 
<p><strong>重载的格式</strong>：返回值为该类类型的引用，通过operator关键字后加上要重载的符号完成，它视情况也有参数。 <br> 如同上面拷贝构造函数那样，赋值运算符重载也存在深浅拷贝的问题，上例中直接给出深拷贝的重载。</p> 
<h2 id="5取址运算符重载"><strong>5、取址（&amp;）运算符重载</strong></h2> 
<pre class="prettyprint"><code class=" hljs cs">String* <span class="hljs-keyword">operator</span>&amp;()
{
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;
}</code></pre> 
<p>取址操作符重载函数返回值为该类型的指针，无参数。</p> 
<h2 id="6-const修饰的取址运算符重载"><strong>6. const修饰的取址运算符重载</strong></h2> 
<pre class="prettyprint"><code class=" hljs cs"><span class="hljs-keyword">const</span> String* <span class="hljs-keyword">operator</span>&amp;() <span class="hljs-keyword">const</span>
{
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;
}</code></pre> 
<p>与<strong>5</strong>中不同的是在函数名前和函数体前各加一个const</p> 
<hr> 
<p>【作者：果冻 <a href="http://blog.csdn.net/jelly_9">http://blog.csdn.net/jelly_9</a>】</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/3eab7d01973193877fff66fab5577b72/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">MediaPlayer详解及代码Demo</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/aa5183b2016400cb9adc8265050ac398/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">Xamarin.Android 集成 微支付 和 支付宝 支付 （成功！）</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>