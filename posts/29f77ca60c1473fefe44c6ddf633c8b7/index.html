<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>【Java 设计模式】行为型之模版方法模式 - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="【Java 设计模式】行为型之模版方法模式" />
<meta property="og:description" content="文章目录 1. 定义2. 应用场景3. 代码实现结语 模板方法模式（Template Method Pattern）是一种行为型设计模式，用于定义算法的框架，并将一些步骤的实现延迟到子类。模板方法模式通过定义一个算法骨架，将具体步骤的实现推迟到子类，使得子类可以在不改变算法结构的情况下重定义算法的某些步骤。在本文中，我们将深入研究Java中模板方法模式的定义、结构、使用场景以及如何在实际开发中应用。 1. 定义 模板方法模式是一种行为型设计模式，用于定义算法的框架，并将一些步骤的实现延迟到子类。模板方法模式通过定义一个算法骨架，将具体步骤的实现推迟到子类，使得子类可以在不改变算法结构的情况下重定义算法的某些步骤。模板方法模式通常包含两个主要角色：抽象模板（Abstract Template）和具体模板（Concrete Template）。
抽象模板（Abstract Template）： 定义了算法的骨架，包含一些抽象的步骤，将具体步骤的实现延迟到子类具体模板（Concrete Template）： 实现了抽象模板中的具体步骤，完成算法的实际实现 2. 应用场景 模板方法模式通常在以下场景中使用：
算法的框架已经确定，但某些步骤的具体实现可能会变化：
当算法的框架已经确定，但某些具体步骤的实现可能会变化时，可以使用模板方法模式
重用性要求较高：
当希望在不改变算法结构的情况下，重用算法的某些部分时，可以使用模板方法模式
固定算法的框架，但允许具体步骤的实现发生变化：
当希望固定算法的框架，但允许具体步骤的实现发生变化时，可以使用模板方法模式
3. 代码实现 下面通过一个简单的例子来演示模板方法模式的实现。假设有一个咖啡和茶的制备过程，我们可以使用模板方法模式定义一个制备饮料的框架。
抽象模板 - 制备饮料 BeverageTemplate
package com.cheney.demo; abstract class BeverageTemplate { // 制备饮料的算法骨架 public final void prepareBeverage() { boilWater(); brew(); pourInCup(); addCondiments(); } // 烧水 protected void boilWater() { System.out.println(&#34;烧水&#34;); } // 冲泡 protected abstract void brew(); // 倒入杯中 protected void pourInCup() { System." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/29f77ca60c1473fefe44c6ddf633c8b7/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2024-01-27T18:04:55+08:00" />
<meta property="article:modified_time" content="2024-01-27T18:04:55+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">【Java 设计模式】行为型之模版方法模式</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-light">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p></p> 
<div class="toc"> 
 <h4>文章目录</h4> 
 <ul><li><ul><li><a href="#1__3" rel="nofollow">1. 定义</a></li><li><a href="#2__12" rel="nofollow">2. 应用场景</a></li><li><a href="#3__28" rel="nofollow">3. 代码实现</a></li><li><a href="#_125" rel="nofollow">结语</a></li></ul> 
 </li></ul> 
</div> 
<br> 模板方法模式（Template Method Pattern）是一种行为型设计模式，用于定义算法的框架，并将一些步骤的实现延迟到子类。模板方法模式通过定义一个算法骨架，将具体步骤的实现推迟到子类，使得子类可以在不改变算法结构的情况下重定义算法的某些步骤。在本文中，我们将深入研究Java中模板方法模式的定义、结构、使用场景以及如何在实际开发中应用。 
<p></p> 
<h3><a id="1__3"></a>1. 定义</h3> 
<p>模板方法模式是一种行为型设计模式，用于定义算法的框架，并将一些步骤的实现延迟到子类。模板方法模式通过定义一个算法骨架，将具体步骤的实现推迟到子类，使得子类可以在不改变算法结构的情况下重定义算法的某些步骤。模板方法模式通常包含两个主要角色：抽象模板（Abstract Template）和具体模板（Concrete Template）。</p> 
<ul><li><strong>抽象模板（Abstract Template）：</strong> 定义了算法的骨架，包含一些抽象的步骤，将具体步骤的实现延迟到子类</li><li><strong>具体模板（Concrete Template）：</strong> 实现了抽象模板中的具体步骤，完成算法的实际实现</li></ul> 
<h3><a id="2__12"></a>2. 应用场景</h3> 
<p>模板方法模式通常在以下场景中使用：</p> 
<ul><li> <p><strong>算法的框架已经确定，但某些步骤的具体实现可能会变化：</strong></p> <p>当算法的框架已经确定，但某些具体步骤的实现可能会变化时，可以使用模板方法模式</p> </li><li> <p><strong>重用性要求较高：</strong></p> <p>当希望在不改变算法结构的情况下，重用算法的某些部分时，可以使用模板方法模式</p> </li><li> <p><strong>固定算法的框架，但允许具体步骤的实现发生变化：</strong></p> <p>当希望固定算法的框架，但允许具体步骤的实现发生变化时，可以使用模板方法模式</p> </li></ul> 
<h3><a id="3__28"></a>3. 代码实现</h3> 
<p>下面通过一个简单的例子来演示模板方法模式的实现。假设有一个咖啡和茶的制备过程，我们可以使用模板方法模式定义一个制备饮料的框架。</p> 
<p>抽象模板 - 制备饮料 BeverageTemplate</p> 
<pre><code class="prism language-java"><span class="token keyword">package</span> <span class="token namespace">com<span class="token punctuation">.</span>cheney<span class="token punctuation">.</span>demo</span><span class="token punctuation">;</span>

<span class="token keyword">abstract</span> <span class="token keyword">class</span> <span class="token class-name">BeverageTemplate</span> <span class="token punctuation">{<!-- --></span>
    <span class="token comment">// 制备饮料的算法骨架</span>
    <span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">void</span> <span class="token function">prepareBeverage</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token function">boilWater</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">brew</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">pourInCup</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">addCondiments</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token comment">// 烧水</span>
    <span class="token keyword">protected</span> <span class="token keyword">void</span> <span class="token function">boilWater</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"烧水"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token comment">// 冲泡</span>
    <span class="token keyword">protected</span> <span class="token keyword">abstract</span> <span class="token keyword">void</span> <span class="token function">brew</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token comment">// 倒入杯中</span>
    <span class="token keyword">protected</span> <span class="token keyword">void</span> <span class="token function">pourInCup</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"倒入杯中"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token comment">// 添加调料</span>
    <span class="token keyword">protected</span> <span class="token keyword">abstract</span> <span class="token keyword">void</span> <span class="token function">addCondiments</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>具体模板 - 制备咖啡 Coffee</p> 
<pre><code class="prism language-java"><span class="token keyword">package</span> <span class="token namespace">com<span class="token punctuation">.</span>cheney<span class="token punctuation">.</span>demo</span><span class="token punctuation">;</span>

<span class="token keyword">class</span> <span class="token class-name">Coffee</span> <span class="token keyword">extends</span> <span class="token class-name">BeverageTemplate</span> <span class="token punctuation">{<!-- --></span>
    <span class="token annotation punctuation">@Override</span>
    <span class="token keyword">protected</span> <span class="token keyword">void</span> <span class="token function">brew</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"冲咖啡"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token annotation punctuation">@Override</span>
    <span class="token keyword">protected</span> <span class="token keyword">void</span> <span class="token function">addCondiments</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"添加糖和牛奶"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>具体模板 - 制备茶 Tea</p> 
<pre><code class="prism language-java"><span class="token keyword">package</span> <span class="token namespace">com<span class="token punctuation">.</span>cheney<span class="token punctuation">.</span>demo</span><span class="token punctuation">;</span>

<span class="token keyword">class</span> <span class="token class-name">Tea</span> <span class="token keyword">extends</span> <span class="token class-name">BeverageTemplate</span> <span class="token punctuation">{<!-- --></span>
    <span class="token annotation punctuation">@Override</span>
    <span class="token keyword">protected</span> <span class="token keyword">void</span> <span class="token function">brew</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"泡茶"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token annotation punctuation">@Override</span>
    <span class="token keyword">protected</span> <span class="token keyword">void</span> <span class="token function">addCondiments</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"添加柠檬"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>客户端启动类 Main</p> 
<pre><code class="prism language-java"><span class="token keyword">package</span> <span class="token namespace">com<span class="token punctuation">.</span>cheney<span class="token punctuation">.</span>demo</span><span class="token punctuation">;</span>

<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Main</span> <span class="token punctuation">{<!-- --></span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token comment">// 使用模板方法模式冲咖啡和泡茶</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"冲咖啡:"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">BeverageTemplate</span> coffee <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Coffee</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        coffee<span class="token punctuation">.</span><span class="token function">prepareBeverage</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"泡茶:"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">BeverageTemplate</span> tea <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Tea</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        tea<span class="token punctuation">.</span><span class="token function">prepareBeverage</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>在上述例子中，<code>BeverageTemplate</code> 是抽象模板，定义了制备饮料的算法骨架，包含了一些抽象的步骤，将具体步骤的实现延迟到子类。<code>Coffee</code> 和 <code>Tea</code> 是具体模板，实现了抽象模板中的具体步骤，完成了冲咖啡和泡茶的实际实现。</p> 
<p>在客户端中，我们使用模板方法模式冲咖啡和泡茶。通过继承抽象模板并实现其中的抽象步骤，我们可以定制不同饮料的制备过程，而不改变算法的整体结构。</p> 
<h3><a id="_125"></a>结语</h3> 
<p>模板方法模式是一种用于定义算法框架，并将一些步骤的实现延迟到子类的设计模式。通过使用模板方法模式，可以固定算法的框架，同时允许具体步骤的实现发生变化，提高了代码的复用性和可维护性。在实际开发中，模板方法模式常被用于实现具体算法的共享部分，例如，GUI框架中的事件处理、Junit中的测试方法等。通过合理使用模板方法模式，可以使系统更加灵活和可扩展。<br> <br><br> <em><strong>【Java 设计模式】系列 《23 种设计模式》 与 《7 大设计原则》 总纲</strong></em><br> 🚩设计原则<br> <a href="https://blog.csdn.net/yanyc0411/article/details/135488282">✨单一职责原则（SRP）</a> 规定一个类应该只有一个引起变化的原因<br> <a href="https://blog.csdn.net/yanyc0411/article/details/135488293">✨开放/封闭原则（OCP）</a> 表明软件实体应该是可以扩展的，但是不可修改的<br> <a href="https://blog.csdn.net/yanyc0411/article/details/135511810">✨里氏替换原则（LSP）</a> 强调派生类必须能够替代其基类而不引起程序错误<br> <a href="https://blog.csdn.net/yanyc0411/article/details/135539609">✨依赖倒置原则（DIP）</a> 倡导高层模块不应该依赖于低层模块，二者都应该依赖于抽象<br> <a href="https://blog.csdn.net/yanyc0411/article/details/135539623">✨接口隔离原则（ISP）</a> 提倡一个类不应该被强迫依赖它不使用的接口<br> <a href="https://blog.csdn.net/yanyc0411/article/details/135539636">✨合成/聚合复用原则（CARP）</a> 建议尽量使用合成/聚合，尽量不要使用继承<br> <a href="https://blog.csdn.net/yanyc0411/article/details/135539651">✨迪米特法则（LoD）</a> 规定一个对象应该对其他对象有最少的了解</p> 
<p>🚀创建型设计模式<br> <a href="https://blog.csdn.net/yanyc0411/article/details/135580055">✨单例模式</a> 保证一个类仅有一个实例，并提供一个访问它的全局点<br> <a href="https://blog.csdn.net/yanyc0411/article/details/135580077">✨工厂方法模式</a> 定义一个用于创建对象的接口，但是由子类决定实例化哪一个类<br> <a href="https://blog.csdn.net/yanyc0411/article/details/135634340">✨抽象工厂模式</a> 提供一个创建一系列相关或相互依赖对象的接口，而无需指定它们具体的类<br> <a href="https://blog.csdn.net/yanyc0411/article/details/135635729">✨建造者模式</a> 将一个复杂对象的构建与其表示分离，使得同样的构建过程可以创建不同的表示<br> <a href="https://blog.csdn.net/yanyc0411/article/details/135660025">✨原型模式</a> 通过复制现有的对象来创建新对象，而不是从头开始创建</p> 
<p>🚀结构型设计模式<br> <a href="https://blog.csdn.net/yanyc0411/article/details/135683903">✨适配器模式</a> 将一个类的接口转换成客户希望的另外一个接口<br> <a href="https://blog.csdn.net/yanyc0411/article/details/135684130">✨桥接模式</a> 将抽象部分与它的实现部分分离，使它们都可以独立地变化<br> <a href="https://blog.csdn.net/yanyc0411/article/details/135684440">✨组合模式</a> 将对象以树形结构组合以表示“部分-整体”的层次结构<br> <a href="https://blog.csdn.net/yanyc0411/article/details/135684456">✨装饰器模式</a> 动态地给一个对象添加一些额外的职责<br> <a href="https://blog.csdn.net/yanyc0411/article/details/135718725">✨外观模式</a> 为子系统中的一组接口提供一个一致的界面<br> <a href="https://blog.csdn.net/yanyc0411/article/details/135718704">✨代理模式</a> 为其他对象提供一种代理以控制对这个对象的访问<br> <a href="https://blog.csdn.net/yanyc0411/article/details/135718750">✨享元模式</a> 用共享的方式高效地支持大量小粒度对象</p> 
<p>🚀行为型设计模式<br> <a href="https://blog.csdn.net/yanyc0411/article/details/135719319">✨观察者模式</a> 定义对象间的一对多依赖，当一个对象改变状态，所有依赖者都会受到通知并自动更新<br> <a href="https://blog.csdn.net/yanyc0411/article/details/135755462">✨策略模式</a> 定义一系列算法，将它们封装起来，并且使它们可以相互替换<br> <a href="https://blog.csdn.net/yanyc0411/article/details/135755476">✨命令模式</a> 将请求封装成对象，使得可以用不同的请求对客户进行参数化<br> <a href="https://blog.csdn.net/yanyc0411/article/details/135778909">✨状态模式</a> 允许对象在其内部状态改变时改变它的行为<br> <a href="https://blog.csdn.net/yanyc0411/article/details/135778931">✨责任链模式</a> 为解除请求的发送者和接收者之间的耦合，而使多个对象都有机会处理这个请求<br> <a href="https://blog.csdn.net/yanyc0411/article/details/135778999">✨访问者模式</a> 将算法与对象结构分离，并且可以在不改变对象结构的前提下定义新的操作<br> <a href="https://blog.csdn.net/yanyc0411/article/details/135779184">✨中介者模式</a> 用一个中介对象来封装一系列的对象交互<br> <a href="https://blog.csdn.net/yanyc0411/article/details/135779018">✨备忘录模式</a> 在不破坏封装的情况下，捕获对象的内部状态，并在对象之外保存这个状态<br> <a href="https://blog.csdn.net/yanyc0411/article/details/135779059">✨迭代器模式</a> 提供一种方法顺序访问一个聚合对象中的各个元素，而不暴露其内部表示<br> <a href="https://blog.csdn.net/yanyc0411/article/details/135779104">✨模版方法模式</a> 定义一个操作中的算法的骨架，将一些步骤延迟到子类中<br> <a href="https://blog.csdn.net/yanyc0411/article/details/135779155">✨解释器模式</a> 定义一个语言的文法，并且建立一个解释器来解释该语言中的句子<br> <br></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/81d32e9bc158d9d6de4a0c601908c763/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">Java 基于SpringBoot&#43;Vue的母婴商城系统，附源码，文档</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/15590cf84cea6a0f346aa6a250c41fa8/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">Image Enhancement Guided Object Detection in Visually Degraded Scenes</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>