<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>java yeild_Java 中 Thread.yield() 方法详解 - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="java yeild_Java 中 Thread.yield() 方法详解" />
<meta property="og:description" content="对于很多初学 Java 线程的小伙伴们，很容易将 Thread 类里的 yield() 方法理解错误，或者理解得不够透彻，先看下源码：
public static native void yield();
是的，你没看错，Thread 类源码中定义的这个方法没有方法体，native 关键字修饰的方法表示原生态方法，方法对应的实现不在这个类文件里，而是在用其他语言(如 C 和 C&#43;&#43;)实现的文件中。Java 语言本身不能对操作系统底层进行访问和操作(但可以通过 JNI 接口调用其他语言来实现对底层的访问)。所以，想要知道并理解 yield() 方法的具体实现过程，于初学者来说并没有必要。虽然“无代码无真相”，但采用大白话的解释或许更加通俗易懂吧。
Java线程调度的一点背景
在各种各样的线程中，Java 虚拟机必须实现一个有优先权的、基于优先级的调度程序。这意味着 Java 程序中的每一个线程被分配到一定的优先权，使用定义好的范围内的一个正整数表示。优先级可以被开发者改变。即使线程已经运行了一定时间，Java 虚拟机也不会改变其优先级。
优先级的值很重要，因为 Java 虚拟机和下层的操作系统之间的约定是操作系统必须选择有最高优先权的 Java 线程运行。所以我们说 Java 实现了一个基于优先权的调度程序。该调度程序使用一种有优先权的方式实现，这意味着当一个有更高优先权的线程到来时，无论低优先级的线程是否在运行，都会中断(抢占)它。这个约定对于操作系统来说并不总是这样，这意味着操作系统有时可能会选择运行一个更低优先级的线程。
理解线程的优先权
接下来，理解线程优先级是多线程学习很重要的一步，尤其是了解 yield() 函数的工作过程：
1、记住当线程的优先级没有指定时，所有线程都携带普通优先级。
2、优先级可以用从 1 到 10 的范围指定。10 表示最高优先级，1 表示最低优先级，5 是普通优先级。
3、记住优先级最高的线程在执行时被给予优先。但是不能保证线程在启动时就进入运行状态。
4、与在线程池中等待运行机会的线程相比，当前正在运行的线程可能总是拥有更高的优先级。
5、由调度程序决定哪一个线程被执行。
6、t.setPriority() 用来设定线程的优先级。
7、记住在线程 start() 方法被调用之前，线程的优先级应该被设定。
8、你可以使用常量，如 MIN_PRIORITY，MAX_PRIORITY，NORM_PRIORITY 来设定优先级。
现在，我们对线程调度和线程优先级有一定理解了，进入主题。
Thread.yield() 方法会使当前线程从执行状态(运行状态)变为可执行状态(就绪状态)。CPU 会从众多的可执行态里选择，也就是说，当前也就是刚刚调用 yield() 方法的那个线程还是有可能会被再次继续执行的。yield() 方法并不是让当前线程暂停，让出时间片去执行其他线程，而在下一次时间片内就一定不会执行了(当前线程只是转换为就绪状态，在下一个本该是自己的却让给其他线程的时间片内也可能再次继续被执行)。
很多人将 yield 翻译成线程让步。顾名思义，就是说当一个线程使用了这个方法之后，它就会把自己CPU执行的一段时间片让给自己或者其它的线程运行。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/655979f1d7a355eed1fa18c12fd663a9/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2021-02-12T17:33:04+08:00" />
<meta property="article:modified_time" content="2021-02-12T17:33:04+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">java yeild_Java 中 Thread.yield() 方法详解</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <div style="font-size:16px;"> 
 <p>对于很多初学 Java 线程的小伙伴们，很容易将 Thread 类里的 yield() 方法理解错误，或者理解得不够透彻，先看下源码：</p> 
 <p>public static native void yield();</p> 
 <p>是的，你没看错，Thread 类源码中定义的这个方法没有方法体，native 关键字修饰的方法表示原生态方法，方法对应的实现不在这个类文件里，而是在用其他语言(如 C 和 C++)实现的文件中。Java 语言本身不能对操作系统底层进行访问和操作(但可以通过 JNI 接口调用其他语言来实现对底层的访问)。所以，想要知道并理解 yield() 方法的具体实现过程，于初学者来说并没有必要。虽然“无代码无真相”，但采用大白话的解释或许更加通俗易懂吧。</p> 
 <p>Java线程调度的一点背景</p> 
 <p>在各种各样的线程中，Java 虚拟机必须实现一个有优先权的、基于优先级的调度程序。这意味着 Java 程序中的每一个线程被分配到一定的优先权，使用定义好的范围内的一个正整数表示。优先级可以被开发者改变。即使线程已经运行了一定时间，Java 虚拟机也不会改变其优先级。</p> 
 <p>优先级的值很重要，因为 Java 虚拟机和下层的操作系统之间的约定是操作系统必须选择有最高优先权的 Java 线程运行。所以我们说 Java 实现了一个基于优先权的调度程序。该调度程序使用一种有优先权的方式实现，这意味着当一个有更高优先权的线程到来时，无论低优先级的线程是否在运行，都会中断(抢占)它。这个约定对于操作系统来说并不总是这样，这意味着操作系统有时可能会选择运行一个更低优先级的线程。</p> 
 <p>理解线程的优先权</p> 
 <p>接下来，理解线程优先级是多线程学习很重要的一步，尤其是了解 yield() 函数的工作过程：</p> 
 <p>1、记住当线程的优先级没有指定时，所有线程都携带普通优先级。</p> 
 <p>2、优先级可以用从 1 到 10 的范围指定。10 表示最高优先级，1 表示最低优先级，5 是普通优先级。</p> 
 <p>3、记住优先级最高的线程在执行时被给予优先。但是不能保证线程在启动时就进入运行状态。</p> 
 <p>4、与在线程池中等待运行机会的线程相比，当前正在运行的线程可能总是拥有更高的优先级。</p> 
 <p>5、由调度程序决定哪一个线程被执行。</p> 
 <p>6、t.setPriority() 用来设定线程的优先级。</p> 
 <p>7、记住在线程 start() 方法被调用之前，线程的优先级应该被设定。</p> 
 <p>8、你可以使用常量，如 MIN_PRIORITY，MAX_PRIORITY，NORM_PRIORITY 来设定优先级。</p> 
 <p>现在，我们对线程调度和线程优先级有一定理解了，进入主题。</p> 
 <p>Thread.yield() 方法会使当前线程从执行状态(运行状态)变为可执行状态(就绪状态)。CPU 会从众多的可执行态里选择，也就是说，当前也就是刚刚调用 yield() 方法的那个线程还是有可能会被再次继续执行的。yield() 方法并不是让当前线程暂停，让出时间片去执行其他线程，而在下一次时间片内就一定不会执行了(当前线程只是转换为就绪状态，在下一个本该是自己的却让给其他线程的时间片内也可能再次继续被执行)。</p> 
 <p>很多人将 yield 翻译成线程让步。顾名思义，就是说当一个线程使用了这个方法之后，它就会把自己CPU执行的一段时间片让给自己或者其它的线程运行。</p> 
 <p>看如下例子：</p> 
 <p>public class TestYield {<!-- --></p> 
 <p>public static void main(String[] args) {<!-- --></p> 
 <p>MyThread3 t1 = new MyThread3("t1");</p> 
 <p>MyThread3 t2 = new MyThread3("t2");</p> 
 <p>t1.start();</p> 
 <p>t2.start();</p> 
 <p>}</p> 
 <p>}</p> 
 <p>class MyThread3 extends Thread {<!-- --></p> 
 <p>MyThread3(String s) {<!-- --></p> 
 <p>super(s);</p> 
 <p>}</p> 
 <p>public void run() {<!-- --></p> 
 <p>for (int i = 1; i &lt;= 100; i++) {<!-- --></p> 
 <p>System.out.println(getName() + ": " + i);</p> 
 <p>if (i % 10 == 0) {<!-- --></p> 
 <p>yield();</p> 
 <p>}</p> 
 <p>}</p> 
 <p>}</p> 
 <p>}</p> 
 <p>再看运行结果：</p> 
 <p>.</p> 
 <p>.</p> 
 <p>.</p> 
 <p>t1: 8</p> 
 <p>t1: 9</p> 
 <p>t1: 10</p> 
 <p>t2: 6</p> 
 <p>t1: 11</p> 
 <p>.</p> 
 <p>.</p> 
 <p>.</p> 
 <p>t1: 18</p> 
 <p>t1: 19</p> 
 <p>t1: 20</p> 
 <p>t1: 21</p> 
 <p>t1: 22</p> 
 <p>.</p> 
 <p>.</p> 
 <p>.</p> 
 <p>t1: 10 后 t2: 6；t1: 20 后 t1: 21。</p> 
 <p>总结后可得以下重要的几点：</p> 
 <p>1、yield 是一个静态的原生(native)方法。</p> 
 <p>2、yield 告诉当前正在执行的线程把运行机会交给线程池中拥有相同优先级的线程。</p> 
 <p>3、yield 不能保证使得当前正在运行的线程迅速转换到可运行的状态。</p> 
 <p>4、它仅能使一个线程从运行状态转到可运行状态，而不是等待或阻塞状态。</p> 
</div>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/3818259c1507fc30b0473ebbd748d506/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">java获取cpu的使用率_java如何获取系统CPU、内存占用</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/d0ca8cc6f8db7a8327988aacd838275c/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">java 执行javascript_java中执行javascript案例</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>