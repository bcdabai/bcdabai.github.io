<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Spring中的事务的原理、实现方式、隔离性、传播性 - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Spring中的事务的原理、实现方式、隔离性、传播性" />
<meta property="og:description" content="目录
1. 什么是事务
2、Spring中事务的实现方式
1、编程式---实现事务
2、声明式---实现事务
3、事务的隔离性
1、DEFAULT
2、READ_UNCOMMITTED(读未提交)
3、READ_COMMITTED(读已提交)
4：REPEATABLE_READ(可重复读)
5：SERIALIZABLE(可串行化)
4、事务的传播特性
1、REQUIRED:spring默认的事务的传播性
2、REQUIRES_NEW
3、NESTED
4、MANDATORY
5、SUPPORTS
6、NOT_SUPPORTED
7、NEVER
5、事务失效的场景
1. 什么是事务 数据库事务是指作为单个逻辑工作单元执行的一系列操作，这些操作要么一起成功，要么一起失败，是一个不可分割的工作单元。
在我们日常工作中，涉及到事务的场景非常多，一个 service 中往往需要调用不同的 dao 层方法，这些方法要么同时成功要么同时失败，我们需要在 service 层确保这一点
事务的四大特性:A：原子性 C：一致性 I：隔离性 D：持久性
2、Spring中事务的实现方式 1、编程式---实现事务 在applicationContext.xml中配置好数据源，和事务管理器:
不推荐使用，代码入侵太多。大量的处理事务的代码穿插到业务代码中
2、声明式---实现事务 (1)、声明式事务:xml形式 提前配置好数据源
配置事务管理器
配置通知，添加事务的切面
Aop的织入，将切面和切入点绑定起来
（2）、configration配置类的形式配置声明式事务 1、配置好数据源信息 2、配置事务管理器 3、开启事务的注解支持
将该配置类添加到包扫描路径下，接来下就可以直接在service的方法或者类上使用@Transactional注解给方法添加事务
（3）、xml&#43;注解方式配置声明式事务
配置完成后，只需要在想要开启注解的方法上加上@Transactional注解就可以了
3、事务的隔离性 1、DEFAULT DEFAULT 这是spring默认的隔离级别，表示使用数据库默认的事务隔离级别。另外四个与JDBC的隔离级别相对应。
2、READ_UNCOMMITTED(读未提交) READ_UNCOMMITTED 这是事务最低的隔离级别，它充许别外一个事务可以看到这个事务未提交的数据。这种隔离级别会产生脏读，不可重复读和幻读。 3、READ_COMMITTED(读已提交) 这是Sql Server , Oracle默认隔离级别READ_COMMITTED 保证一个事务修改的数据提交后才能被另外一个事务读取。这种事务隔离级别可以避免脏读出现，但是可能会出现不可重复读和幻读。
4：REPEATABLE_READ(可重复读) 这是MySQL-InnoDB默认隔离级别REPEATABLE_READ这种事务隔离级别可以防止脏读，不可重复读。但是可能出现幻读。
5：SERIALIZABLE(可串行化) SERIALIZABLE 事务被处理为顺序执行。防止脏读，不可重复读，防止幻读。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/5b3345d530b3571044c33ab9ef213745/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-03-24T17:43:55+08:00" />
<meta property="article:modified_time" content="2023-03-24T17:43:55+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Spring中的事务的原理、实现方式、隔离性、传播性</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p id="main-toc"><strong>目录</strong></p> 
<p id="1.%20%E4%BB%80%E4%B9%88%E6%98%AF%E4%BA%8B%E5%8A%A1-toc" style="margin-left:40px;"><a href="#1.%20%E4%BB%80%E4%B9%88%E6%98%AF%E4%BA%8B%E5%8A%A1" rel="nofollow">1. 什么是事务</a></p> 
<p id="2%E3%80%81Spring%E4%B8%AD%E4%BA%8B%E5%8A%A1%E7%9A%84%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F-toc" style="margin-left:40px;"><a href="#2%E3%80%81Spring%E4%B8%AD%E4%BA%8B%E5%8A%A1%E7%9A%84%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F" rel="nofollow">2、Spring中事务的实现方式</a></p> 
<p id="%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A01%E3%80%81%E7%BC%96%E7%A8%8B%E5%BC%8F---%E5%AE%9E%E7%8E%B0%E4%BA%8B%E5%8A%A1-toc" style="margin-left:80px;"><a href="#%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A01%E3%80%81%E7%BC%96%E7%A8%8B%E5%BC%8F---%E5%AE%9E%E7%8E%B0%E4%BA%8B%E5%8A%A1" rel="nofollow">        1、编程式---实现事务</a></p> 
<p id="%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%202%E3%80%81%E5%A3%B0%E6%98%8E%E5%BC%8F---%E5%AE%9E%E7%8E%B0%E4%BA%8B%E5%8A%A1-toc" style="margin-left:80px;"><a href="#%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%202%E3%80%81%E5%A3%B0%E6%98%8E%E5%BC%8F---%E5%AE%9E%E7%8E%B0%E4%BA%8B%E5%8A%A1" rel="nofollow">        2、声明式---实现事务</a></p> 
<p id="3%E3%80%81%E4%BA%8B%E5%8A%A1%E7%9A%84%E9%9A%94%E7%A6%BB%E6%80%A7-toc" style="margin-left:40px;"><a href="#3%E3%80%81%E4%BA%8B%E5%8A%A1%E7%9A%84%E9%9A%94%E7%A6%BB%E6%80%A7" rel="nofollow">3、事务的隔离性</a></p> 
<p id="%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A01%E3%80%81DEFAULT-toc" style="margin-left:80px;"><a href="#%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A01%E3%80%81DEFAULT" rel="nofollow">        1、DEFAULT</a></p> 
<p id="%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A02%E3%80%81READ_UNCOMMITTED(%E8%AF%BB%E6%9C%AA%E6%8F%90%E4%BA%A4)-toc" style="margin-left:80px;"><a href="#%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A02%E3%80%81READ_UNCOMMITTED%28%E8%AF%BB%E6%9C%AA%E6%8F%90%E4%BA%A4%29" rel="nofollow">        2、READ_UNCOMMITTED(读未提交)</a></p> 
<p id="%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A03%E3%80%81READ_COMMITTED(%E8%AF%BB%E5%B7%B2%E6%8F%90%E4%BA%A4)-toc" style="margin-left:80px;"><a href="#%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A03%E3%80%81READ_COMMITTED%28%E8%AF%BB%E5%B7%B2%E6%8F%90%E4%BA%A4%29" rel="nofollow">        3、READ_COMMITTED(读已提交)</a></p> 
<p id="%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A04%EF%BC%9AREPEATABLE_READ(%E5%8F%AF%E9%87%8D%E5%A4%8D%E8%AF%BB)-toc" style="margin-left:80px;"><a href="#%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A04%EF%BC%9AREPEATABLE_READ%28%E5%8F%AF%E9%87%8D%E5%A4%8D%E8%AF%BB%29" rel="nofollow">        4：REPEATABLE_READ(可重复读)</a></p> 
<p id="%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A05%EF%BC%9ASERIALIZABLE(%E5%8F%AF%E4%B8%B2%E8%A1%8C%E5%8C%96)-toc" style="margin-left:80px;"><a href="#%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A05%EF%BC%9ASERIALIZABLE%28%E5%8F%AF%E4%B8%B2%E8%A1%8C%E5%8C%96%29" rel="nofollow">        5：SERIALIZABLE(可串行化)</a></p> 
<p id="4%E3%80%81%E4%BA%8B%E5%8A%A1%E7%9A%84%E4%BC%A0%E6%92%AD%E7%89%B9%E6%80%A7-toc" style="margin-left:40px;"><a href="#4%E3%80%81%E4%BA%8B%E5%8A%A1%E7%9A%84%E4%BC%A0%E6%92%AD%E7%89%B9%E6%80%A7" rel="nofollow">4、事务的传播特性</a></p> 
<p id="%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A01%E3%80%81REQUIRED%3Aspring%E9%BB%98%E8%AE%A4%E7%9A%84%E4%BA%8B%E5%8A%A1%E7%9A%84%E4%BC%A0%E6%92%AD%E6%80%A7-toc" style="margin-left:80px;"><a href="#%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A01%E3%80%81REQUIRED%3Aspring%E9%BB%98%E8%AE%A4%E7%9A%84%E4%BA%8B%E5%8A%A1%E7%9A%84%E4%BC%A0%E6%92%AD%E6%80%A7" rel="nofollow">        1、REQUIRED:spring默认的事务的传播性</a></p> 
<p id="%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A02%E3%80%81REQUIRES_NEW-toc" style="margin-left:80px;"><a href="#%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A02%E3%80%81REQUIRES_NEW" rel="nofollow">        2、REQUIRES_NEW</a></p> 
<p id="%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A03%E3%80%81NESTED-toc" style="margin-left:80px;"><a href="#%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A03%E3%80%81NESTED" rel="nofollow">        3、NESTED</a></p> 
<p id="%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%204%E3%80%81MANDATORY-toc" style="margin-left:80px;"><a href="#%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%204%E3%80%81MANDATORY" rel="nofollow">        4、MANDATORY</a></p> 
<p id="%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%205%E3%80%81SUPPORTS-toc" style="margin-left:80px;"><a href="#%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%205%E3%80%81SUPPORTS" rel="nofollow">        5、SUPPORTS</a></p> 
<p id="%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%206%E3%80%81NOT_SUPPORTED-toc" style="margin-left:80px;"><a href="#%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%206%E3%80%81NOT_SUPPORTED" rel="nofollow">        6、NOT_SUPPORTED</a></p> 
<p id="%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%207%E3%80%81NEVER-toc" style="margin-left:80px;"><a href="#%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%207%E3%80%81NEVER" rel="nofollow">        7、NEVER</a></p> 
<p id="5%E3%80%81%E4%BA%8B%E5%8A%A1%E5%A4%B1%E6%95%88%E7%9A%84%E5%9C%BA%E6%99%AF-toc" style="margin-left:40px;"><a href="#5%E3%80%81%E4%BA%8B%E5%8A%A1%E5%A4%B1%E6%95%88%E7%9A%84%E5%9C%BA%E6%99%AF" rel="nofollow">5、事务失效的场景</a></p> 
<hr id="hr-toc"> 
<h3>1. 什么是事务</h3> 
<p>        数据库事务是指作为单个逻辑工作单元执行的一系列操作，这些操作要么一起成功，要么一起失败，是一个不可分割的工作单元。</p> 
<p>        在我们日常工作中，涉及到事务的场景非常多<span style="color:#fe2c24;"><strong>，一个 service 中往往需要调用不同的 dao 层方法，这些方法要么同时成功要么同时失败，我们需要在 service 层确保这一点</strong></span></p> 
<p>        事务的四大特性:A：原子性 C：一致性 I：隔离性 D：持久性</p> 
<h3 id="2%E3%80%81Spring%E4%B8%AD%E4%BA%8B%E5%8A%A1%E7%9A%84%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F">2、Spring中事务的实现方式</h3> 
<h4 id="%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A01%E3%80%81%E7%BC%96%E7%A8%8B%E5%BC%8F---%E5%AE%9E%E7%8E%B0%E4%BA%8B%E5%8A%A1">        1、编程式---实现事务</h4> 
<p><span style="color:#000000;">                在applicationContext.xml中配置好数据源，和事务管理器:</span></p> 
<p><img alt="" height="351" src="https://images2.imgbox.com/f5/a3/P0DmcF5C_o.png" width="658"></p> 
<p style="margin-left:.0001pt;text-align:justify;"><span style="color:#ff0000;">                不推荐使用</span>，代码入侵太多。大量的处理事务的代码穿插到业务代码中</p> 
<p style="margin-left:.0001pt;text-align:justify;"><img alt="" height="643" src="https://images2.imgbox.com/9a/75/baQtkCzC_o.png" width="695"></p> 
<h4 id="%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%202%E3%80%81%E5%A3%B0%E6%98%8E%E5%BC%8F---%E5%AE%9E%E7%8E%B0%E4%BA%8B%E5%8A%A1" style="margin-left:.0001pt;text-align:justify;">        2、声明式---实现事务</h4> 
<p style="margin-left:.0001pt;text-align:justify;"><strong><span style="color:#ff0000;">            (1)、声明式事务:xml形式</span>  提前配置好数据源</strong></p> 
<p style="text-align:justify;">                        配置事务管理器</p> 
<p style="text-align:justify;">                        配置通知，添加事务的切面</p> 
<p style="text-align:justify;">                        Aop的织入，将切面和切入点绑定起来</p> 
<p style="text-align:justify;"><img alt="" height="497" src="https://images2.imgbox.com/97/fd/AF9j7KAr_o.png" width="790"></p> 
<p><strong>      （2）、configration配置类的形式配置声明式事务 </strong></p> 
<p>                1、配置好数据源信息      2、配置事务管理器        3、开启事务的注解支持</p> 
<p><img alt="" height="545" src="https://images2.imgbox.com/e0/33/QUtmNWCh_o.png" width="691"></p> 
<p style="margin-left:.0001pt;text-align:justify;">        将该配置类添加到包扫描路径下，接来下就可以直接在service的方法或者类上使用@Transactional注解给方法添加事务</p> 
<p style="margin-left:.0001pt;text-align:justify;"><strong>      （3）、xml+注解方式配置声明式事务</strong></p> 
<p style="margin-left:.0001pt;text-align:justify;"><img alt="" height="774" src="https://images2.imgbox.com/41/61/s6OuqyFf_o.png" width="825"></p> 
<p>                配置完成后，只需要在想要开启注解的方法上加上@Transactional注解就可以了</p> 
<h3 id="3%E3%80%81%E4%BA%8B%E5%8A%A1%E7%9A%84%E9%9A%94%E7%A6%BB%E6%80%A7">3、事务的隔离性</h3> 
<h4 id="%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A01%E3%80%81DEFAULT">      <strong>  1、DEFAULT</strong></h4> 
<p>        DEFAULT 这是spring默认的隔离级别，<span style="color:#fe2c24;"><strong>表示使用数据库默认的事务隔离级别</strong></span>。另外四个与JDBC的隔离级别相对应。</p> 
<h4 id="%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A02%E3%80%81READ_UNCOMMITTED(%E8%AF%BB%E6%9C%AA%E6%8F%90%E4%BA%A4)">    <strong>    2、READ_UNCOMMITTED(读未提交)</strong></h4> 
<p>        READ_UNCOMMITTED 这是事务最低的隔离级别，它充许别外一个事务可以看到这个事务未提交的数据。这种隔离级别会产生脏读，不可重复读和幻读。        </p> 
<h4 id="%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A03%E3%80%81READ_COMMITTED(%E8%AF%BB%E5%B7%B2%E6%8F%90%E4%BA%A4)">      <strong>  3、READ_COMMITTED(读已提交)</strong></h4> 
<p>        这是<span style="color:#fe2c24;"><strong>Sql Server , Oracle默认隔离级别READ_COMMITTED</strong></span> 保证一个事务修改的数据提交后才能被另外一个事务读取。这种事务隔离级别<strong>可以避免脏读出现，但是可能会出现不可重复读和幻读。</strong></p> 
<h4 id="%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A04%EF%BC%9AREPEATABLE_READ(%E5%8F%AF%E9%87%8D%E5%A4%8D%E8%AF%BB)">     <strong>   4：REPEATABLE_READ(可重复读)</strong></h4> 
<p>        这是<span style="color:#fe2c24;"><strong>MySQL-InnoDB默认隔离级别REPEATABLE_READ</strong></span>这种事务隔离级别可以<strong>防止脏读，不可重复读。但是可能出现幻读。</strong></p> 
<h4 id="%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A05%EF%BC%9ASERIALIZABLE(%E5%8F%AF%E4%B8%B2%E8%A1%8C%E5%8C%96)">      <strong>  5：SERIALIZABLE(可串行化)</strong></h4> 
<p>        SERIALIZABLE 事务被处理为顺序执行。<strong>防止脏读，不可重复读，防止幻读。</strong></p> 
<p><span style="color:#fe2c24;"><strong>注意：事务的隔离级别和数据库并发性是成反比的，隔离级别越高，并发性越低。</strong></span></p> 
<h2>4、脏读、不可重复读、幻读 </h2> 
<p>        <strong>脏读</strong>：脏读就是指当一个事务正在访问数据，并且对数据进行了修改，而这种修改还没有提交到数据库中，这时，另外一个事务也访问这个数据，然后使用了这个数据。<br>         例如：<br>         张三的工资为5000,事务A中把他的工资改为8000,但事务A尚未提交。与此同时，事务B正在读取张三的工资，读取到张三的工资为8000。随后，事务A发生异常，而<span style="color:#fe2c24;"><strong>回滚</strong></span>了事务。张三的工资又回滚为5000。最后，事务B读取到的张三工资为8000的数据即为脏数据，事务B做了一次脏读。</p> 
<p>        <strong>不可重复读</strong>：是指在一个事务内，多次读同一数据。在这个事务还没有结束时，另外一个事务也访问该同一数据。那么，在第一个事务中的两次读数据之间，由于第二个事务的修改，那么第一个事务两次读到的的数据可能是不一样的。这样就发生了在一个事务内两次读到的数据是不一样的，因此称为是不可重复读。<br>         例如：<br>         在事务A中，读取到张三的工资为5000，操作没有完成，事务还没提交。与此同时，事务B把张三的工资改为8000，并提交了事务。随后，在事务A中，再次读取张三的工资，此时工资变为8000。在一个事务中前后两次读取的结果并不致，导致了不可重复读。</p> 
<p>        <strong>幻读</strong>：是指当事务不是独立执行时发生的一种现象，例如第一个事务对一个表中的数据进行了修改，这种修改涉及到表中的全部数据行。同时，第二个事务也修改这个表中的数据，这种修改是向表中插入一行新数据。那么，以后就会发生操作第一个事务的用户发现表中还有没有修改的数据行，就好象发生了幻觉一样。<br>         例如：<br>         目前工资为5000的员工有10人，事务A读取所有工资为5000的人数为10人。此时，事务B插入一条工资也为5000的记录。这是，事务A再次读取工资为5000的员工，记录为11人。此时产生了幻读。</p> 
<p><strong>提醒 </strong></p> 
<p><strong>脏读和不可重复读的区别是：</strong></p> 
<p>       <span style="color:#fe2c24;"> 脏读 读取的是为提交的数据。不可重复度读 读取的是已提交的数据。</span></p> 
<p><strong>幻读和不可重复读的区别是：</strong></p> 
<p>        不可重复读的重点是<span style="color:#fe2c24;"><strong>修改</strong></span>： 同样的条件，你读取过的数据，再次读取出来发现值不一样了<br>         幻读的重点在于<span style="color:#fe2c24;"><strong>新增或者删除</strong></span>： 同样的条件，第 1 次和第 2 次读出来的记录数不一样</p> 
<h2 id="4%E3%80%81%E4%BA%8B%E5%8A%A1%E7%9A%84%E4%BC%A0%E6%92%AD%E7%89%B9%E6%80%A7">5、事务的传播特性</h2> 
<p>        在一个事务执行的过程中，调用另一个事务时候(比如一个service方法调用另一个service方法)，这个事务将以何种状态存在，是两个事务共存呢，还是一个事务是另一个事务的子事务，还是一个事务加入另一个事务的子事务呢……利用事务的传播性来解决这个问题。</p> 
<h4 id="%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A01%E3%80%81REQUIRED%3Aspring%E9%BB%98%E8%AE%A4%E7%9A%84%E4%BA%8B%E5%8A%A1%E7%9A%84%E4%BC%A0%E6%92%AD%E6%80%A7">        1、REQUIRED:spring默认的事务的传播性</h4> 
<p>                REQUIRED 表示如果当前存在事务，则加入该事务；如果当前没有事务，则创建一个新的事务。</p> 
<pre><code class="language-java">@Service
public class AccountService {
    @Autowired
    JdbcTemplate jdbcTemplate;
    @Transactional
    public void handle1() {
        jdbcTemplate.update("update user set money = ? where id=?;", 1, 2);
    }
}
@Service
public class AccountService2 {
    @Autowired
    JdbcTemplate jdbcTemplate;
    @Autowired
    AccountService accountService;
    public void handle2() {
        jdbcTemplate.update("update user set money = ? where username=?;", 1, "zhangsan");
        accountService.handle1();
    }
}</code></pre> 
<ol><li> <p>如果 handle2 方法本身是有事务的，则 handle1 方法就会加入到 handle2 方法所在的事务中，这样两个方法将处于同一个事务中，一起成功或者一起失败（不管是 handle2 还是 handle1 谁抛异常，都会导致整体回滚）。</p> </li><li> <p>如果 handle2 方法本身是没有事务的，则 handle1 方法就会自己开启一个新的事务。</p> </li></ol> 
<h4 id="%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A02%E3%80%81REQUIRES_NEW">        2、REQUIRES_NEW</h4> 
<p>        REQUIRES_NEW 表示创建一个新的事务，如果当前存在事务，则把<strong>当前事务挂起</strong>。换言之，不管外部方法是否有事务，REQUIRES_NEW 都会开启自己的事务。</p> 
<h4 id="%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A03%E3%80%81NESTED">        3、NESTED</h4> 
<p>        NESTED 表示如果当前存在事务，则创建一个事务作为当前事务的嵌套事务来运行；如果当前没有事务，则该取值等价于 TransactionDefinition.PROPAGATION_REQUIRED。</p> 
<h4 id="%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%204%E3%80%81MANDATORY">        4、MANDATORY</h4> 
<p>        MANDATORY 表示如果当前存在事务，则加入该事务；如果当前没有事务，则抛出异常。</p> 
<h4 id="%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%205%E3%80%81SUPPORTS">        5、SUPPORTS</h4> 
<p>        NOT_SUPPORTED 表示以非事务方式运行，如果当前存在事务，则把当前事务挂起。</p> 
<h4 id="%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%206%E3%80%81NOT_SUPPORTED">        6、NOT_SUPPORTED</h4> 
<p>        NOT_SUPPORTED 表示以非事务方式运行，如果当前存在事务，则把当前事务挂起。</p> 
<h4 id="%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%207%E3%80%81NEVER">        7、NEVER</h4> 
<p>        NEVER 表示以非事务方式运行，如果当前存在事务，则抛出异常。</p> 
<h3 id="5%E3%80%81%E4%BA%8B%E5%8A%A1%E5%A4%B1%E6%95%88%E7%9A%84%E5%9C%BA%E6%99%AF">6、事务失效的场景</h3> 
<p>        1、数据库不支持事务                                2、没有配置事务管理器        </p> 
<p>        3、事务所在的方法没有被public修饰        4、异常被catch，没有抛出，事务会失效</p> 
<p>        5、异常类型错误,默认是<strong>runtimeException</strong>才会回滚的</p> 
<p>            解决方案:加上@Transactional(rollbackFor = Exception.class)注解;这样Exception也会回滚</p> 
<p>        6、用final或者static关键字修饰的方法事务会失效</p> 
<p>        7、事务需要从外部调用，<strong>Spring 自调事务用会失效</strong>。即相同类里边，A 方法没有事务，B 方法有事务，A 方法调用 B 方法，则 B 方法的事务会失效，这点尤其要注意，因为代理模式只拦截通过代理传入的外部方法调用，所以自调用事务是不生效的。</p> 
<h2>7、spring事务的实现原理</h2> 
<p>        底层是通过aop进行实现，@Transactional注解使用环绕通知，在进入方法前<strong>开启事务  。</strong>使用try catch包含目标方法，<strong>执行目标方法</strong>，执行完成后如果没有抛出异常，就<strong>提交事务</strong>。如果抛出异常就<strong>进行回滚</strong>。</p> 
<p>代码实现:</p> 
<p><strong>定义注解:</strong></p> 
<pre><code class="language-java">@Target({ElementType.TYPE, ElementType.METHOD})
@Retention(RetentionPolicy.RUNTIME)
@Inherited
@Documented
public @interface rkTransactional {
}
</code></pre> 
<p><strong>切面:</strong></p> 
<pre><code class="language-java">@Aspect
@Component
@Slf4j
public class ExtrkThreadAop {
    @Autowired
    private RkTransaction rkTransaction;

    /**
     * 只要方法上有加上rkTransactional 走around（）
     * 异常通知
     * @param joinPoint
     * @throws Throwable
     */
    @Around(value = "@annotation(com.rk.aop.rkTransactional)")
    public Object around(ProceedingJoinPoint joinPoint) {
        // 在目标方法之前开启事务  底层实现:将事务状态保存在当前线程里面
        TransactionStatus transactionStatus = rkTransaction.begin();
        try {
            Object result = joinPoint.proceed();//目标方法
            log.info("目标方法之后执行");
            //提交事务
            rkTransaction.commit(transactionStatus);
            return result;
        } catch (Throwable throwable) {
            // 目标方法执行向外抛出异常之后 手动回滚
            rkTransaction.rollback(transactionStatus);
            return "fail";
        }
    }
}</code></pre> 
<p><strong>注解类:</strong></p> 
<pre><code class="language-java">@Component
public class RkTransaction {

    @Autowired
    private DataSourceTransactionManager dataSourceTransactionManager;

    // 开启事务
    public TransactionStatus begin() {
        TransactionStatus transaction = dataSourceTransactionManager.getTransaction(new DefaultTransactionAttribute());
        return transaction;
    }

    // 提交事务
    public void commit(TransactionStatus transactionStatus) {
        dataSourceTransactionManager.commit(transactionStatus);
    }

    // 回滚事务
    public void rollback(TransactionStatus transactionStatus) {
        dataSourceTransactionManager.rollback(transactionStatus);
    }
}</code></pre> 
<p><strong>测试:</strong></p> 
<pre><code class="language-java">    /**
     * 使用事务注解 事务到底在什么时候提交呢？该方法没有抛出异常的情况下就会自动提交事务
     * aop
     * @param name
     * @return
     */
    @GetMapping("/insertUser")
    @rkTransactional
    public String insertUser(String name) {
        int result = userMapper.insertUser(name);
        if ("rk".equals(name)) {
            int j = 1 / 0;
        }
        return result &gt; 0 ? "ok" : "fail";
    }
}</code></pre> 
<p>        </p> 
<p>        </p> 
<p></p> 
<p></p> 
<p></p> 
<p></p> 
<p></p> 
<p></p> 
<p></p> 
<p></p> 
<p>        </p> 
<p></p> 
<p></p> 
<p></p> 
<p></p> 
<p></p> 
<p></p> 
<p style="margin-left:.0001pt;text-align:justify;"></p> 
<p></p> 
<p></p> 
<p></p> 
<p></p> 
<p></p> 
<p>                </p> 
<p></p> 
<p></p> 
<p></p> 
<p></p> 
<p></p> 
<p style="margin-left:.0001pt;text-align:justify;"></p> 
<p></p> 
<p style="margin-left:.0001pt;text-align:justify;"></p> 
<p></p> 
<p></p> 
<p></p> 
<p></p> 
<p></p> 
<p></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/642759da5b79c589d226282ff3128504/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">Python是不是被严重高估了？</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/b2ad08af6e2915f13f2038cc2c445650/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">请求响应数据？Controler层注解！</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>