<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>JAVA并发专题《前引篇》 - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="JAVA并发专题《前引篇》" />
<meta property="og:description" content="写在前面 最近想根据自己平时的工作笔记和学习笔记，整理出一些JAVA专题类的系列文章。平时自己的笔记比较散，趁着这个机会进行系统化的整合一下，同时看到网上能形成体系化的知识点比较少，所以也趁着这个机会，整理、归纳、分享一下给大家。
专题的内容主要采用对话的形式，一个是学习热情高涨，爱好提问的小陈；一个是知识储备丰厚，工作多年且经验丰富的老王；文章的知识讲解主要是通过两人的对话展开。
工作以来和同事交谈过不少，也面试过不少人；但是感觉对于JAVA并发这块的整体知识，很难有人能形成一个比较完整的体系和脉络，比如JAVA并发工具类体系、线程池体系、AtomicInteger体系、Synchronized、volatile底层、内存模型等，很多兄弟都只是了解其中的某个点。
所以我根据之前自己对JAVA并发底层原理的学习、以及之前源码分析的笔记、流程图等，整理出一套比较完善的学习笔记，希望能对你学习并发有所帮助。
专题文章内容 我的笔记中对JAVA并发的学习路线按照修炼层次划分了几个阶段哈，分别为：筑基、炼气、结丹、金丹、元神、飞升等六大阶段哈，从最开始慢慢打好基础，然后逐步修炼，最终成为高手。嘿嘿，我废话不多说了，看一下下面的阶段内容介绍哈：
筑基 最开始的阶段当然是打好基础啦，所以啊我会从多核CPU多级缓存架构、JAVA内存模型、并发的可见性、有序性、原子性、MESI一致性等开始分析底层原理，以及带来了并发安全的什么问题？等先讲解和介绍一些基础的概念，这个阶段就是打基础用的。
练气 有了基础的概念之后，再来分析什么是volatile？什么是内存屏障？内存屏障怎么解决可见性和有序性的问题，以及volatile是怎么使用内存屏障的？
带你来分析一下Synchronized的底层原理是怎么样的？什么是对象头，对象头里面有什么信息？怎么通过对象头和Synchronized进行关联的？synchronized是怎么是加锁的？怎么保证并发安全的？怎么进行锁升级和优化的？
学好了这个阶段，相当在基础之上，并发的一些理解和功力慢慢变得深厚了。
结丹 有了上面筑基、练气的修炼之后，并发的功力慢慢变得深厚，随着修为的提升，进入并发的结丹境界。
在这个阶段会重点介绍JDK底层的unsafe类提供操作系统底层的功能，包括从内存级别CAS操作数据、从操作系统级别分配和释放内存、从操作系统级别阻塞和唤醒线程等功能。
还会从底层源码、实现机制讲解Atomic体系中非常常用的原子类，包括：AtomicInteger、AtomicBoolean是怎么通过volatile和cas机制实现的？从源码级别去分析同时画图理解。
介绍AtomicInteger、AtomicBoolean等简单原子类的缺点，存在ABA问题、高并发竞争导致大量线程自旋问题、无法做到多个变量同时更新的原子性问题等。
然后讲解AtomicReference 是怎么解决多变量更新的原子性问题的？AtomicStampReference怎么解决ABA问题的？LongAdder怎么使用分段解决高并发导致大量线程自旋问题的？等等....
学到这里，恭喜你，CAS操作的底层原理，Atomic体系的原子类底层的实现原理，你都一一了解了，并发修行进入了结丹境界，哈哈。
金丹 有了上面筑基、练气的底层知识基础，通过CAS底层原理、Atomic体系剖析进入结丹境界之后，下一阶段的修行就会非常重要了，那就是金丹期。在这个阶段我们会介绍JUC提供的JAVA并发工具的底层原理。
包括JAVA并发的核心AQS是个什么东西？AQS作为底层的一个并发框架到底实现了什么功能和机制，才能作为并发框架？
基于AQS实现的各种各样的并发工具ReentrantLock、CountDownLatch、Semaphore、ReentrantReadWriteLock等等，它们是怎么基于AQS来实现各种各样的功能的？上面的东西我们都会一个一个的进行源码级别的剖析、画图讲解。
学完了这一章节之后，JAVA并发工具的实现机制和底层原理对你来说已经不成问题了，你的并发功力也是十分深厚了，这一篇并发工具的底层原理是很多修炼者的瓶颈，学完这一章，直接让你的并发功力大增。
元神 学完了上面的篇章，并发功力大增之后；我们逐步开始修炼元神。
这一篇会讲解JUC中非常重要的一些并发安全的数据结构、包括CopyOnWriteArrayList底层是怎么是实现的，怎么通过写时复制提升并发性能？
ConcurrentLinkedQueue是怎么通过CAS无锁化操作提升并发性能的？
最经常讨论的ConcurrentHashMap是怎么通过分段锁机制提升并发性能的？
ArrayBlockedQueue、LinkedBlockedQueue等是怎么基于之前的ReentrantLock锁 &#43; Condition机制实现阻塞唤醒的？
DelayQueue、SynchronousQueue等其它阻塞队列的剖析等
学完这一章节，相信你对JAVA并发的理解变得更加深入了，怎么通过之前的锁、CAS、volatile、synchronized等知识实现我们功能，这些并发安全的数据结构怎么通过之前的知识设计出来的？如果我们要实现并发安全的系统设计应该怎么做？到了这一阶段，好好学习，肯定会对你并发的设用和设计能力提升一大截。
飞升 修炼完上面的境界，相信你的JAVA并发的功力已经非常深厚，这个时候就能进入飞升境界了。
这一篇我们看看线程池底层是怎么设计和实现的？看看一些非常牛逼的人，是怎么运用并发知识设计出线程池这么一个牛逼的东西的？
包括线程池构造函数、每个参数的深入分析，每个参数是什么意思？一个32位的变量怎么使用不同的二进制位表示线程池数量和线程池状态的，对状态和数量的操控对应哪些方法？
往线程池提交任务的整体流程源码是怎么样的？
线程数量未达到核心数量时提交任务会怎么样？
达到核心数量会怎么样？阻塞队列满了会怎么样？线程数量达到最大数量会怎么样？
有哪些拒绝策略，怎么触发线程拒绝策略？
线程池中的Worker（工作者）的概念是什么？
当线程数量大于核心线程数的时候，怎么通过线程最大存活时间移除多余的线程的？
看看为啥不推荐使用Executors提供的创建线程池方式？
这一篇我们主要是来分析一下线程池底层实现原理是什么？看看顶尖的大佬是怎么设计出这么牛逼的线程池的？这一篇对你线程池原理的理解大有帮助，同时借鉴人家的设计思路，如果让你来实现可以做到吗？学完这一片相信你对JAVA并发的整体运用和理解能更加深入，设计思路和能力也很有帮助
最后，加油，修炼无止尽，继续努力，继续进步，祝各位道友修炼有得、不断进步。
关注小陈，公众号上更新更多的java并发文章
JAVA并发文章目录（公众号） JAVA并发专题 《筑基篇》 1.什么是CPU多级缓存模型？
2.什么是JAVA内存模型？
3.线程安全之可见性、有序性、原子性是什么？
4.什么是MESI缓存一致性协议？怎么解决并发的可见性问题？
JAVA并发专题《练气篇》 5.volatile怎么保证可见性？
6.什么是内存屏障？具有什么作用？
7.volatile怎么通过内存屏障保证可见性和有序性？
8.volatile为啥不能保证原子性？
9.synchronized 是个啥东西？应该怎
9.synchronized 是个啥东西？应该怎么使用？
10.synchronized底层之monitor、对象头、Mark Word？
11.synchronized底层是怎么通过monitor进行加锁的？" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/34745face5041683e6de2c69893e89cc/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2021-12-27T16:33:00+08:00" />
<meta property="article:modified_time" content="2021-12-27T16:33:00+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">JAVA并发专题《前引篇》</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <h3>写在前面</h3> 
<p> </p> 
<p>最近想根据自己平时的工作笔记和学习笔记，整理出一些JAVA专题类的系列文章。平时自己的笔记比较散，趁着这个机会进行系统化的整合一下，同时看到网上能形成体系化的知识点比较少，所以也趁着这个机会，整理、归纳、分享一下给大家。</p> 
<p>专题的内容主要采用对话的形式，<span style="color:#fe2c24;"><strong>一个是学习热情高涨，爱好提问的小陈；一个是知识储备丰厚，工作多年且经验丰富的老王；</strong></span>文章的知识讲解主要是通过两人的对话展开。</p> 
<p>工作以来和同事交谈过不少，也面试过不少人；<strong>但是感觉对于JAVA并发这块的整体知识，很难有人能形成一个比较完整的体系和脉络，比如JAVA并发工具类体系、线程池体系、AtomicInteger体系、Synchronized、volatile底层、内存模型等，很多兄弟都只是了解其中的某个点。</strong></p> 
<p>所以我根据之前自己对JAVA并发底层原理的学习、以及之前源码分析的笔记、流程图等，整理出一套比较完善的学习笔记，希望能对你学习并发有所帮助。</p> 
<p></p> 
<h3>专题文章内容</h3> 
<p>我的笔记中对JAVA并发的学习路线按照修炼层次划分了几个阶段哈，分别为：<strong><span style="color:#fe2c24;">筑基、炼气、结丹、金丹、元神、飞升</span></strong>等六大阶段哈，从最开始慢慢打好基础，然后逐步修炼，最终成为高手。嘿嘿，我废话不多说了，看一下下面的阶段内容介绍哈：</p> 
<h4>筑基</h4> 
<p>最开始的阶段当然是打好基础啦，所以啊我会从<strong>多核CPU多级缓存架构、JAVA内存模型、并发的可见性、有序性、原子性、MESI一致性等开始分析底层原理，以及带来了并发安全的什么问题？</strong>等先讲解和介绍一些基础的概念，这个阶段就是打基础用的。</p> 
<h4>练气</h4> 
<p>有了基础的概念之后，再来<strong>分析什么是volatile？什么是内存屏障？内存屏障怎么解决可见性和有序性的问题，以及volatile是怎么使用内存屏障的？</strong></p> 
<p><strong>带你来分析一下Synchronized的底层原理是怎么样的？什么是对象头，对象头里面有什么信息？怎么通过对象头和Synchronized进行关联的？synchronized是怎么是加锁的？怎么保证并发安全的？怎么进行锁升级和优化的？</strong></p> 
<p>学好了这个阶段，相当在基础之上，并发的一些理解和功力慢慢变得深厚了。</p> 
<h4>结丹</h4> 
<p>有了上面筑基、练气的修炼之后，并发的功力慢慢变得深厚，随着修为的提升，进入并发的结丹境界。</p> 
<p>在这个阶段会重点介绍<strong>JDK底层的unsafe类提供操作系统底层的功能，包括从内存级别CAS操作数据、从操作系统级别分配和释放内存、从操作系统级别阻塞和唤醒线程等功能。</strong></p> 
<p>还会从<strong>底层源码、实现机制讲解Atomic体系中非常常用的原子类，包括：AtomicInteger、AtomicBoolean是怎么通过volatile和cas机制实现的？从源码级别去分析同时画图理解。</strong></p> 
<p>介绍AtomicInteger、AtomicBoolean等简单原子类的缺点，<strong>存在ABA问题、高并发竞争导致大量线程自旋问题、无法做到多个变量同时更新的原子性问题等</strong>。</p> 
<p><strong>然后讲解AtomicReference 是怎么解决多变量更新的原子性问题的？AtomicStampReference怎么解决ABA问题的？LongAdder怎么使用分段解决高并发导致大量线程自旋问题的？</strong>等等....</p> 
<p>学到这里，恭喜你，CAS操作的底层原理，Atomic体系的原子类底层的实现原理，你都一一了解了，并发修行进入了结丹境界，哈哈。</p> 
<h4>金丹</h4> 
<p>有了上面筑基、练气的底层知识基础，通过CAS底层原理、Atomic体系剖析进入结丹境界之后，下一阶段的修行就会非常重要了，那就是金丹期。在这个阶段我们会介绍JUC提供的JAVA并发工具的底层原理。</p> 
<p>包括JAVA并发的核心<strong>AQS是个什么东西？AQS作为底层的一个并发框架到底实现了什么功能和机制，才能作为并发框架？</strong></p> 
<p>基于<strong>AQS实现的各种各样的并发工具ReentrantLock、CountDownLatch、Semaphore、ReentrantReadWriteLock等等，它们是怎么基于AQS来实现各种各样的功能的？上面的东西我们都会一个一个的进行源码级别的剖析、画图讲解。</strong></p> 
<p>学完了这一章节之后，JAVA并发工具的实现机制和底层原理对你来说已经不成问题了，你的并发功力也是十分深厚了，这一篇并发工具的底层原理是很多修炼者的瓶颈，学完这一章，直接让你的并发功力大增。</p> 
<h4>元神</h4> 
<p>学完了上面的篇章，并发功力大增之后；我们逐步开始修炼元神。</p> 
<p>这一篇会讲解JUC中非常重要的一些并发安全的数据结构、<strong>包括CopyOnWriteArrayList底层是怎么是实现的，怎么通过写时复制提升并发性能？</strong></p> 
<p><strong>ConcurrentLinkedQueue是怎么通过CAS无锁化操作提升并发性能的？</strong></p> 
<p><strong>最经常讨论的ConcurrentHashMap是怎么通过分段锁机制提升并发性能的？</strong></p> 
<p><strong>ArrayBlockedQueue、LinkedBlockedQueue等是怎么基于之前的ReentrantLock锁 + Condition机制实现阻塞唤醒的？</strong></p> 
<p><strong>DelayQueue、SynchronousQueue等其它阻塞队列的剖析等</strong></p> 
<p>学完这一章节，相信你对JAVA并发的理解变得更加深入了，怎么通过之前的锁、CAS、volatile、synchronized等知识实现我们功能，这些并发安全的数据结构怎么通过之前的知识设计出来的？如果我们要实现并发安全的系统设计应该怎么做？到了这一阶段，好好学习，肯定会对你并发的设用和设计能力提升一大截。</p> 
<h4>飞升</h4> 
<p>修炼完上面的境界，相信你的JAVA并发的功力已经非常深厚，这个时候就能进入飞升境界了。</p> 
<p>这一篇我们看看线程池底层是怎么设计和实现的？<strong><span style="color:#fe2c24;">看看一些非常牛逼的人，是怎么运用并发知识设计出线程池这么一个牛逼的东西的？</span></strong></p> 
<p><strong>包括线程池构造函数、每个参数的深入分析，每个参数是什么意思？一个32位的变量怎么使用不同的二进制位表示线程池数量和线程池状态的，对状态和数量的操控对应哪些方法？</strong></p> 
<p><strong>往线程池提交任务的整体流程源码是怎么样的？</strong></p> 
<p><strong>线程数量未达到核心数量时提交任务会怎么样？</strong></p> 
<p><strong>达到核心数量会怎么样？阻塞队列满了会怎么样？线程数量达到最大数量会怎么样？</strong></p> 
<p><strong>有哪些拒绝策略，怎么触发线程拒绝策略？</strong></p> 
<p><strong>线程池中的Worker（工作者）的概念是什么？</strong></p> 
<p><strong>当线程数量大于核心线程数的时候，怎么通过线程最大存活时间移除多余的线程的？</strong></p> 
<p><strong>看看为啥不推荐使用Executors提供的创建线程池方式？</strong></p> 
<p>这一篇我们主要是来分析一下线程池底层实现原理是什么？看看顶尖的大佬是怎么设计出这么牛逼的线程池的？这一篇对你线程池原理的理解大有帮助，同时借鉴人家的设计思路，如果让你来实现可以做到吗？学完这一片相信你对JAVA并发的整体运用和理解能更加深入，设计思路和能力也很有帮助</p> 
<p>最后，加油，修炼无止尽，继续努力，继续进步，祝各位道友修炼有得、不断进步。</p> 
<p><strong>关注小陈，公众号上更新更多的java并发文章</strong></p> 
<p><img alt="" height="344" src="https://images2.imgbox.com/59/3d/Hs3gOsZN_o.jpg" width="344"></p> 
<h3>JAVA并发文章目录（公众号）</h3> 
<h4>JAVA并发专题 《筑基篇》</h4> 
<p><a href="https://blog.csdn.net/chenzengnian123/article/details/122190878" title="1.什么是CPU多级缓存模型？">1.什么是CPU多级缓存模型？</a></p> 
<p><a href="https://blog.csdn.net/chenzengnian123/article/details/122191798" title="2.什么是JAVA内存模型？">2.什么是JAVA内存模型？</a></p> 
<p><a href="https://blog.csdn.net/chenzengnian123/article/details/122362616" title="3.线程安全之可见性、有序性、原子性是什么？">3.线程安全之可见性、有序性、原子性是什么？</a></p> 
<p><a href="https://blog.csdn.net/chenzengnian123/article/details/122363321" title="4.什么是MESI缓存一致性协议？怎么解决并发的可见性问题？">4.什么是MESI缓存一致性协议？怎么解决并发的可见性问题？</a></p> 
<h4>JAVA并发专题《练气篇》</h4> 
<p><a href="https://blog.csdn.net/chenzengnian123/article/details/122404837" title="5.volatile怎么保证可见性？">5.volatile怎么保证可见性？</a></p> 
<p><a href="https://blog.csdn.net/chenzengnian123/article/details/122405842" title="6.什么是内存屏障？具有什么作用？">6.什么是内存屏障？具有什么作用？</a></p> 
<p><a href="https://blog.csdn.net/chenzengnian123/article/details/122406807" title="7.volatile怎么通过内存屏障保证可见性和有序性？">7.volatile怎么通过内存屏障保证可见性和有序性？</a></p> 
<p><a href="https://blog.csdn.net/chenzengnian123/article/details/122407292" title="8.volatile为啥不能保证原子性？">8.volatile为啥不能保证原子性？</a></p> 
<p>9.synchronized 是个啥东西？应该怎</p> 
<p>9.synchronized 是个啥东西？应该怎么使用？</p> 
<p>10.synchronized底层之monitor、对象头、Mark Word？</p> 
<p>11.synchronized底层是怎么通过monitor进行加锁的？</p> 
<p>12.synchronized的锁重入、锁消除、锁升级原理？无锁、偏向锁、轻量级锁、自旋、重量级锁</p> 
<p>13.synchronized怎么保证可见性、有序性、原子性？</p> 
<h4>JAVA并发专题《结丹篇》</h4> 
<p>14. JDK底层Unsafe类是个啥东西？</p> 
<p>15.unsafe类的CAS是怎么保证原子性的？</p> 
<p>16.Atomic原子类体系讲解</p> 
<p>17.AtomicInteger、AtomicBoolean的底层原理</p> 
<p>18.AtomicReference、AtomicStampReference底层原理</p> 
<p>19.Atomic中的LongAdder底层原理之分段锁机制</p> 
<p>20.Atmoic系列Strimped64分段锁底层实现源码剖析</p> 
<h4>JAVA并发专题《金丹篇》</h4> 
<p>21.AQS是个啥？为啥说它是JAVA并发工具基础框架？</p> 
<p>22.基于AQS的互斥锁底层源码深度剖析</p> 
<p>23.基于AQS的共享锁底层源码深度剖析</p> 
<p>24.ReentrantLock是怎么基于AQS实现独占锁的？</p> 
<p>25.ReentrantLock的Condition机制底层源码剖析</p> 
<p>26.CountDownLatch 门栓底层源码和实现机制深度剖析</p> 
<p>27.CyclicBarrier 栅栏底层源码和实现机制深度剖析</p> 
<p>28.Semaphore 信号量底层源码和实现机深度剖析</p> 
<p>28.ReentrantReadWriteLock 读写锁怎么表示？</p> 
<p>29. ReentrantReadWriteLock 读写锁底层源码和机制深度剖析</p> 
<h4>JAVA并发专题《元神篇》并发数据结构篇</h4> 
<p>30.CopyOnAarrayList 底层分析，怎么通过写时复制副本，提升并发性能？</p> 
<p>31.ConcurrentLinkedQueue 底层分析，CAS 无锁化操作提升并发性能？</p> 
<p>32.ConcurrentHashMap详解，底层怎么通过分段锁提升并发性能？</p> 
<p>33.LinkedBlockedQueue 阻塞队列怎么通过ReentrantLock和Condition实现？</p> 
<p>34.ArrayBlockedQueued 阻塞队列实现思路竟然和LinkedBlockedQueue一样？</p> 
<p>35.DelayQueue 底层源码剖析，延时队列怎么实现？</p> 
<p>36.SynchronousQueue底层原理解析</p> 
<h4>JAVA并发专题《飞升篇》线程池底层深度剖析</h4> 
<p>37. 什么是线程池？看看JDK提供了哪些默认的线程池？底层竟然都是基于ThreadPoolExecutor的？</p> 
<p>38.ThreadPoolExecutor 构造函数有哪些参数？这些参数分别表示什么意思？</p> 
<p>39.内部有哪些变量，怎么表示线程池状态和线程数，看看道格.李大神是怎么设计的？</p> 
<p>40. ThreadPoolExecutor execute执行流程？怎么进行任务提交的？addWorker方法干了啥？什么是workder？</p> 
<p>41. ThreadPoolExecutor execute执行流程？何时将任务提交到阻塞队列？ 阻塞队列满会发生什么？</p> 
<p>42. ThreadPoolExecutor 中的Worker是如何执行提交到线程池的任务的？多余Worker怎么在超出空闲时间后被干掉的？</p> 
<p>43. ThreadPoolExecutor shutdown、shutdownNow内部核心流程</p> 
<p>44. 再回头看看为啥不推荐Executors提供几种线程池？</p> 
<p>45. ThreadPoolExecutor线程池篇总结</p> 
<p></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/c6044b61d0f5ed8089637650fb032030/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">node执行js代码时同步获取用户通过键盘输入的值</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/91152984684ec7a4893b905b8b4e6c20/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">自定义MD5加密工具类,报错ArrayIndexOutOfBoundsException: 15</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>