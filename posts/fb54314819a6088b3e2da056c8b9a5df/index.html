<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>如何使用Pytest进行自动化测试（干货） - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="如何使用Pytest进行自动化测试（干货）" />
<meta property="og:description" content="为什么需要自动化测试 自动化测试有很多优点，但这里有3个主要的点
可重用性:不需要总是编写新的脚本，除非必要，即使是新的操作系统版本也不需要编写脚本。可靠性:人容易出错，机器不太可能。当运行不能跳过的重复步骤/测试时，速度会更快。全天运行:您可以在任何时间或远程启动测试。夜间运行正在测试你的软件，即使是在你睡着的时候。 成熟的、功能齐全的Python测试工具——pytest 目前有多种可用的测试框架和工具。这些框架的风格也各不相同，比如数据驱动、关键字驱动、混合、BDD等等。您可以选择最适合您的要求。
Python和pytest在这场竞争中占据了巨大的份额。Python及其相关工具之所以被大量使用，可能是因为与其他语言相比，没有或很少编程经验的人更能负担得起它们。
pytest框架使得编写小型测试变得很容易，但是可以扩展到支持应用程序和库的复杂功能测试。
Pytest的一些主要特性:
自动发现测试模块和功能有效的CLI来更好地控制您想要运行或跳过的内容大型第三方插件生态系统固定装置-不同的类型，不同的范围与传统的单元测试框架一起工作
自动和可配置的测试发现
在默认情况下，pytest期望在名称以test_开头或以_test.py结尾的python模块中找到测试。在默认情况下，它期望测试函数名以test_ 开头。但是，可以通过在pytest的一个配置文件中添加您自己的配置来修改这个测试发现协议。
# content of pytest.ini # Example 1: have pytest look for &#34;check&#34; instead of &#34;test&#34; # can also be defined in tox.ini or setup.cfg file, although the section # name in setup.cfg files should be &#34;tool:pytest&#34; [pytest] python_files = check_*.py python_classes = Check python_functions = *_check 让我们看一下非常基本的测试函数。
class CheckClass(object): def one_check(self): x = &#34;this&#34; assert &#39;h&#39; in x def two_check(self): x = &#34;" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/fb54314819a6088b3e2da056c8b9a5df/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2020-12-02T20:54:40+08:00" />
<meta property="article:modified_time" content="2020-12-02T20:54:40+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">如何使用Pytest进行自动化测试（干货）</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-tomorrow-night">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <h3><a id="_0"></a>为什么需要自动化测试</h3> 
<p>自动化测试有很多优点，但这里有3个主要的点</p> 
<ol><li>可重用性:不需要总是编写新的脚本，除非必要，即使是新的操作系统版本也不需要编写脚本。</li><li>可靠性:人容易出错，机器不太可能。当运行不能跳过的重复步骤/测试时，速度会更快。</li><li>全天运行:您可以在任何时间或远程启动测试。夜间运行正在测试你的软件，即使是在你睡着的时候。</li></ol> 
<h3><a id="Pythonpytest_8"></a>成熟的、功能齐全的Python测试工具——pytest</h3> 
<p>目前有多种可用的测试框架和工具。这些框架的风格也各不相同，比如数据驱动、关键字驱动、混合、BDD等等。您可以选择最适合您的要求。</p> 
<p>Python和pytest在这场竞争中占据了巨大的份额。Python及其相关工具之所以被大量使用，可能是因为与其他语言相比，没有或很少编程经验的人更能负担得起它们。</p> 
<p>pytest框架使得编写小型测试变得很容易，但是可以扩展到支持应用程序和库的复杂功能测试。</p> 
<p>Pytest的一些主要特性:</p> 
<ul><li>自动发现测试模块和功能</li><li>有效的CLI来更好地控制您想要运行或跳过的内容</li><li>大型第三方插件生态系统</li><li>固定装置-不同的类型，不同的范围</li><li>与传统的单元测试框架一起工作<br> <img src="https://images2.imgbox.com/34/d9/3fceTkMz_o.png" alt=""></li></ul> 
<p><strong>自动和可配置的测试发现</strong></p> 
<p>在默认情况下，pytest期望在名称以test_开头或以_test.py结尾的python模块中找到测试。在默认情况下，它期望测试函数名以test_ 开头。但是，可以通过在pytest的一个配置文件中添加您自己的配置来修改这个测试发现协议。</p> 
<pre><code class="prism language-css"># content of pytest.ini
# Example 1<span class="token punctuation">:</span> have pytest look for <span class="token string">"check"</span> instead of <span class="token string">"test"</span>
# can also be defined in tox.ini or setup.cfg file, although the section
# name in setup.cfg files should be <span class="token string">"tool:pytest"</span>
[pytest]
python_files = check_*.py
python_classes = Check
python_functions = *_check
</code></pre> 
<p>让我们看一下非常基本的测试函数。</p> 
<pre><code class="prism language-css">class <span class="token function">CheckClass</span><span class="token punctuation">(</span>object<span class="token punctuation">)</span><span class="token punctuation">:</span>
    def one_<span class="token function">check</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>
        x = <span class="token string">"this"</span>
        assert <span class="token string">'h'</span> in x

    def two_<span class="token function">check</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>
        x = <span class="token string">"hello"</span>
        assert <span class="token function">hasattr</span><span class="token punctuation">(</span>x, <span class="token string">'check'</span><span class="token punctuation">)</span>
</code></pre> 
<p>你注意到什么了吗?没有花哨的assertEqual或assertDictEqual等，只是简单明了的断言。对于比较两个对象的简单操作，不需要导入这些断言函数。assert是python已经提供的功能，因此无需重新发明。</p> 
<p><strong>固定装置会起作用的</strong></p> 
<p>查看测试功能，测试钱包软件的基本操作，比如，</p> 
<pre><code class="prism language-css">// test_wallet.py
from wallet import Walletdef test_default_initial_<span class="token function">amount</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
   wallet = <span class="token function">Wallet</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
   assert wallet.balance == 0
   wallet.<span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span>def test_setting_initial_<span class="token function">amount</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
   wallet = <span class="token function">Wallet</span><span class="token punctuation">(</span>initial_amount=100<span class="token punctuation">)</span>
   assert wallet.balance == 100
   wallet.<span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span>def test_wallet_add_<span class="token function">cash</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
   wallet = <span class="token function">Wallet</span><span class="token punctuation">(</span>initial_amount=10<span class="token punctuation">)</span>
   wallet.add_<span class="token function">cash</span><span class="token punctuation">(</span>amount=90<span class="token punctuation">)</span>
   assert wallet.balance == 100
   wallet.<span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span>def test_wallet_spend_<span class="token function">cash</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
   wallet = <span class="token function">Wallet</span><span class="token punctuation">(</span>initial_amount=20<span class="token punctuation">)</span>
   wallet.spend_<span class="token function">cash</span><span class="token punctuation">(</span>amount=10<span class="token punctuation">)</span>
   assert wallet.balance == 10
   wallet.<span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
</code></pre> 
<p>嗯,有意思!你注意到了吗，很多样板文件。另一件值得注意的事情是，测试除了测试功能之外还做了一些其他的事情，例如实例化钱包并关闭它——Wallet .close()</p> 
<p>现在让我们看看如何使用pytest fixture去除样板</p> 
<pre><code class="prism language-css">import pytest
from _pytest.fixtures import SubRequest
from wallet import Wallet#==================== fixtures
@pytest.fixture
def <span class="token function">wallet</span><span class="token punctuation">(</span><span class="token property">request</span><span class="token punctuation">:</span> SubRequest<span class="token punctuation">)</span><span class="token punctuation">:</span>
   param = <span class="token function">getattr</span><span class="token punctuation">(</span>request, ‘param’, None<span class="token punctuation">)</span>
   if <span class="token property">param</span><span class="token punctuation">:</span>
     prepared_wallet = <span class="token function">Wallet</span><span class="token punctuation">(</span>initial_amount=param[0]<span class="token punctuation">)</span>
   <span class="token property">else</span><span class="token punctuation">:</span>
     prepared_wallet = <span class="token function">Wallet</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
   yield prepared_wallet
   prepared_wallet.<span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span>#==================== testsdef test_default_initial_<span class="token function">amount</span><span class="token punctuation">(</span>wallet<span class="token punctuation">)</span><span class="token punctuation">:</span>
   assert wallet.balance == 0@pytest.mark.<span class="token function">parametrize</span><span class="token punctuation">(</span>‘wallet’, [<span class="token punctuation">(</span>100,<span class="token punctuation">)</span>], indirect=True<span class="token punctuation">)</span>
def test_setting_initial_<span class="token function">amount</span><span class="token punctuation">(</span>wallet<span class="token punctuation">)</span><span class="token punctuation">:</span>
   assert wallet.balance == 100@pytest.mark.<span class="token function">parametrize</span><span class="token punctuation">(</span>‘wallet’, [<span class="token punctuation">(</span>10,<span class="token punctuation">)</span>], indirect=True<span class="token punctuation">)</span>
def test_wallet_add_<span class="token function">cash</span><span class="token punctuation">(</span>wallet<span class="token punctuation">)</span><span class="token punctuation">:</span>
   wallet.add_<span class="token function">cash</span><span class="token punctuation">(</span>amount=90<span class="token punctuation">)</span>
   assert wallet.balance == 100@pytest.mark.<span class="token function">parametrize</span><span class="token punctuation">(</span>‘wallet’, [<span class="token punctuation">(</span>20,<span class="token punctuation">)</span>], indirect=True<span class="token punctuation">)</span>
def test_wallet_spend_<span class="token function">cash</span><span class="token punctuation">(</span>wallet<span class="token punctuation">)</span><span class="token punctuation">:</span>
   wallet.spend_<span class="token function">cash</span><span class="token punctuation">(</span>amount=10<span class="token punctuation">)</span>
   assert wallet.balance == 10
</code></pre> 
<p>整洁!不是吗。测试函数非常微妙，只做它们想做的事情。夹具钱包负责设置和拆卸、实例化和关闭钱包。它不仅有助于编写可重用的代码，还增加了数据分离的本质。如果仔细看，钱包数量是一块测试逻辑之外提供的测试数据，而不是硬编码在测试函数内部。</p> 
<pre><code class="prism language-css">@pytest.mark.<span class="token function">parametrize</span><span class="token punctuation">(</span>‘wallet’, [<span class="token punctuation">(</span>10,<span class="token punctuation">)</span>], indirect=True<span class="token punctuation">)</span>
</code></pre> 
<p>在更可控的环境中，您可以在存储库中有一个测试数据文件，例如test-data.ini，以及读取该文件的包装器，并且您的测试函数可以调用包装器的另一个接口来读取测试数据。</p> 
<p>但是，建议将您的fixture作为conftest.py文件的一部分。这是pytest中的一个特殊文件，它允许测试发现全局fixture。</p> 
<p><strong>但是，有一个针对许多不同数据集执行的测试用例!</strong></p> 
<p>不用担心，pytest有一个很酷的特性来参数化您的fixture。让我们用一个例子来看看它。</p> 
<p>假设您的产品公开CLI接口以在本地管理它。此外，您的产品在启动时设置了许多默认参数，您需要验证所有这些参数的默认值。</p> 
<p>我们可以考虑为每个设置编写一个测试用例，但是使用pytest就容易得多了</p> 
<pre><code class="prism language-css"><span class="token selector">@pytest.mark.parametrize(“setting_name, setting_value”, [(‘qdb_mem_usage’, ‘low’),
(‘report_crashes’, ‘yes’),
(‘stop_download_on_hang’, ‘no’),
(‘stop_download_on_disconnect’, ‘no’),
(‘reduce_connections_on_congestion’, ‘no’),
(‘global.max_web_users’, ‘1024’),
(‘global.max_downloads’, ‘5’),
(‘use_kernel_congestion_detection’, ‘no’),
(‘log_type’, ‘normal’),
(‘no_signature_check’, ‘no’),
(‘disable_xmlrpc’, ‘no’),
(‘disable_ntp’, ‘yes’),
(‘ssl_mode’, ‘tls_1_2’),])def test_settings_defaults(self, setting_name, setting_value):
   assert product_shell.run_command(setting_name) == \
     self.”The current value for \’</span><span class="token punctuation">{<!-- --></span>0<span class="token punctuation">}</span><span class="token selector">\’ is     \’</span><span class="token punctuation">{<!-- --></span>1<span class="token punctuation">}</span><span class="token selector">\’.”.format(setting_name, setting_value), \
 ‘The</span> <span class="token punctuation">{<!-- --></span><span class="token punctuation">}</span> <span class="token selector">default should be</span> <span class="token punctuation">{<!-- --></span><span class="token punctuation">}</span>’.<span class="token function">format</span><span class="token punctuation">(</span>preference_name, preference_value<span class="token punctuation">)</span>
</code></pre> 
<p>很酷,不是吗!,你只写了13个测试用例(每个不同setting_value),在未来如果你添加一个新的设置到你的产品,你需要做的就是,再添加一个tuple上面。</p> 
<p>它是如何与selenium和API测试的UI测试集成的</p> 
<p>嗯，你的产品可以有多种界面。CLI -就像我们上面讨论的。类似地，GUI和API。在部署软件之前，对所有软件进行测试是很重要的。在多个组件相互依赖和耦合的企业软件中，某个部分的更改可能会影响其他部分。</p> 
<p>记住，pytest只是一个促进“测试”的框架，而不是特定类型的测试。因此，您可以使用selenium构建GUI测试，或者使用Python的请求库构建API测试，然后使用pytest运行它。</p> 
<p>例如，在高层次上，这可能是您的测试存储库结构。</p> 
<p>正如您在上面看到的，这可以很好地分离组件。</p> 
<ul><li>apiobjects:为调用API端点创建包装器的好地方。您可以使用BaseAPIObject和派生类来满足您的需求。</li><li>helper:编写您的helper方法</li><li>库文件，它可以被不同的组件使用，例如你的fixture在conftest, pageobjects等。</li><li>pageobjects:<br> pageobjects设计模式可用于创建不同GUI页面的类。我们在站得住使用Webium，它是Python的一个页面对象模式实现库。</li><li>套件:您可以在这里编写pylint代码验证套件，这将有助于您对代码质量有信心。</li><li>测试:可以根据测试的风格对测试目录进行分类。它使管理和研究您的测试变得容易。</li></ul> 
<p>这只是供参考，存储库的结构和依赖关系可以按照您的需要进行布局。</p> 
<p><strong>我有足够的测试用例,想并行运行它们</strong></p> 
<p>您的测试套件中可能有大量的测试用例，并且有时您可能想并行地运行测试用例，以减少总体测试执行时间。</p> 
<p>Pytest提供了一个很棒的并行运行测试的插件，名为Pytest -xdist，它用一些独特的执行模式扩展了Pytest。使用pip安装此插件</p> 
<pre><code class="prism language-css">pip install pytest-xdist
</code></pre> 
<p>让我们通过一个示例来快速研究它。</p> 
<p>我有一个自动化测试存储库CloudApp，用于使用selenium进行GUI测试。此外，它还随着新的测试用例不断增长，现在已经有了数百个测试。我想做的是并行运行它们，并减少测试执行时间。</p> 
<p>在终端中，只需在项目根文件夹/ tests文件夹中键入pytest。这将执行所有测试。</p> 
<pre><code class="prism language-css">pytest -s -v -n=2
</code></pre> 
<p>并行运行测试的pytest-xdist</p> 
<p>这还可以帮助您在多个浏览器上并行运行测试。</p> 
<p><strong>报告</strong></p> 
<p>Pytest内置支持创建结果文件，可由Jenkins、Bamboo或其他持续集成服务器读取，使用如下调用:</p> 
<pre><code class="prism language-css">pytest test/file/path — junitxml=path
</code></pre> 
<p>这可以生成很好的XML风格的输出，可以由许多CI系统解析器解释。</p> 
<p><strong>结论</strong></p> 
<p>Pytest的受欢迎程度逐年上升。此外，它还拥有广泛的社区支持，这让您可以访问很多扩展，比如pytest-django，它可以帮助您为Django web应用程序集成编写测试。记住，pytest支持运行unittest测试用例，所以如果您正在使用unittest, pytest是值得考虑的。</p> 
<p><strong>如果你</strong></p> 
<p>①从事功能测试，想进阶自动化测试</p> 
<p>②在测试界混了1、2年，依然不会敲代码</p> 
<p>③面试大厂却屡屡碰壁</p> 
<p>我邀你进群吧！来吧~~测试员，313782132（Q群里有技术大牛一起交流分享，学习资源的价值取决于你的行动，莫做“收藏家”）获取更多大厂技术、面试资料</p> 
<p>如果对python自动化测试、web自动化、接口自动化、移动端自动化、面试经验交流等等感兴趣的测试人，可以关注微信公众号：【伤心的辣条】，获取软件测试工程师大厂面试资料！</p> 
<h3><a id="_218"></a>最后：</h3> 
<p>凡事要趁早，特别是技术行业，一定要提升技术功底，丰富自动化项目实战经验，这对于你未来几年职业规划，以及测试技术掌握的深度非常有帮助。</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/70d8eb71e64cbd7899011027d1d6e3bf/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">已超1000&#43;测试员分享！Python自动化测试实战案例</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/75769aced59bcd889dfe55be6c8aa351/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">python极简讲义_Python极简讲义：一本书入门数据分析与机器学习 张玉宏</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>