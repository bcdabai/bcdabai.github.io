<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>AcWing：第56场周赛 - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="AcWing：第56场周赛" />
<meta property="og:description" content="AcWing：第56场周赛 4482. 分组 - AcWing题库 给定一个长度为 n 的数组 a1,a2,…,an。
请你将这 n 个元素重新分组，要求每个组内的元素两两不等，且分组数量应尽可能少。
请你计算最少所需的分组数量。
例如，给定一个数组 a=[1,2,4,3,3,2]，我们至少需要将所有元素分为两组，一种可行分组方案为：[1,2,3] 和 [2,3,4]。
输入格式 第一行包含一个整数 n。
第二行包含 n 个整数 a1,a2,…,an。
输出格式 一个整数，表示最少所需的分组数量。
数据范围 前三个测试点满足 1≤n≤10。
所有测试点满足 1≤n≤100，1≤ai≤100。
输入样例1： 6 1 2 4 3 3 2 输出样例1： 2 问题解析 想象一下，我们要把n个相同的东西分开放，那么显然是需要n个盒子，这样才能保证一个盒子里只有一个相同的东西。
这题直接统计出现最多的那个数的次数就行，次数为多少，就要分多少组。
AC代码 #include&lt;iostream&gt; using namespace std; #include&lt;vector&gt; #include&lt;algorithm&gt; #include&lt;math.h&gt; #include&lt;set&gt; #include&lt;numeric&gt; #include&lt;string&gt; #include&lt;string.h&gt; #include&lt;iterator&gt; #include&lt;map&gt; #include&lt;unordered_map&gt; #include&lt;stack&gt; #include&lt;list&gt; #include&lt;queue&gt; #include&lt;iomanip&gt; #define endl &#39;\n&#39; #define int ll typedef long long ll; typedef unsigned long long ull; typedef pair&lt;ll, ll&gt;PII; const int N = 2e5 &#43; 50; signed main() { ios_base::sync_with_stdio(false); cin." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/dec7cec001688df5b12a5e079f7a1d27/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-06-22T15:42:00+08:00" />
<meta property="article:modified_time" content="2022-06-22T15:42:00+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">AcWing：第56场周赛</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <h2><a id="AcWing56_0"></a>AcWing：第56场周赛</h2> 
<h3><a id="4482___AcWinghttpswwwacwingcomproblemcontent4485_2"></a><a href="https://www.acwing.com/problem/content/4485/" rel="nofollow">4482. 分组 - AcWing题库</a></h3> 
<p>给定一个长度为 n 的数组 a1,a2,…,an。</p> 
<p>请你将这 n 个元素重新分组，要求每个组内的元素两两不等，且分组数量应尽可能少。</p> 
<p>请你计算最少所需的分组数量。</p> 
<p>例如，给定一个数组 a=[1,2,4,3,3,2]，我们至少需要将所有元素分为两组，一种可行分组方案为：[1,2,3] 和 [2,3,4]。</p> 
<h5><a id="_12"></a>输入格式</h5> 
<p>第一行包含一个整数 n。</p> 
<p>第二行包含 n 个整数 a1,a2,…,an。</p> 
<h5><a id="_18"></a>输出格式</h5> 
<p>一个整数，表示最少所需的分组数量。</p> 
<h5><a id="_22"></a>数据范围</h5> 
<p>前三个测试点满足 1≤n≤10。<br> 所有测试点满足 1≤n≤100，1≤ai≤100。</p> 
<h5><a id="1_27"></a>输入样例1：</h5> 
<pre><code>6
1 2 4 3 3 2
</code></pre> 
<h5><a id="1_34"></a>输出样例1：</h5> 
<pre><code>2
</code></pre> 
<h4><a id="_40"></a>问题解析</h4> 
<p>想象一下，我们要把n个相同的东西分开放，那么显然是需要n个盒子，这样才能保证一个盒子里只有一个相同的东西。</p> 
<p>这题直接统计出现最多的那个数的次数就行，次数为多少，就要分多少组。</p> 
<h4><a id="AC_46"></a>AC代码</h4> 
<pre><code>#include&lt;iostream&gt;
using namespace std;
#include&lt;vector&gt;
#include&lt;algorithm&gt;
#include&lt;math.h&gt;
#include&lt;set&gt;
#include&lt;numeric&gt;
#include&lt;string&gt;
#include&lt;string.h&gt;
#include&lt;iterator&gt;
#include&lt;map&gt;
#include&lt;unordered_map&gt;
#include&lt;stack&gt;
#include&lt;list&gt;
#include&lt;queue&gt;
#include&lt;iomanip&gt;

#define endl '\n'
#define int ll
typedef long long ll;
typedef unsigned long long ull;
typedef pair&lt;ll, ll&gt;PII;
const int N = 2e5 + 50;

signed main()
{
    ios_base::sync_with_stdio(false);
    cin.tie(nullptr);
    cout.tie(nullptr);
    int n,res=0;
    unordered_map&lt;int, int&gt;mymap;
    cin &gt;&gt; n;
    vector&lt;int&gt;v(n);
    for (int i = 0; i &lt; n; i++)
    {
        cin &gt;&gt; v[i];
        mymap[v[i]]++;
        res = max(res, mymap[v[i]]);
    }
    cout &lt;&lt; res;
    return 0;
}
</code></pre> 
<h3><a id="4483___AcWinghttpswwwacwingcomproblemcontent4486_93"></a><a href="https://www.acwing.com/problem/content/4486/" rel="nofollow">4483. 格斗场 - AcWing题库</a></h3> 
<p>一个格斗场内有 n 个战士，其中第 i 个战士的战斗力为 ai。</p> 
<p>作为格斗场内的经理人，你需要给战士们安排一对一的决斗。</p> 
<p>这些决斗是一场接一场进行的，一场结束后才会安排下一场。</p> 
<p>为了保证决斗的观赏性，在安排时需保证：</p> 
<ul><li>决斗双方的战斗力不能相同。</li><li>决斗双方的战斗力差距不能超过 K。</li></ul> 
<p>已知，在决斗中战斗力高的选手一定可以将战斗力低的选手击败，并且失败的选手会被赶出格斗场。</p> 
<p>请你合理安排决斗，使得当剩余选手之间无法再安排任何决斗时，剩余选手的数量越少越好。</p> 
<p>请你输出剩余选手的最小可能数量。</p> 
<h5><a id="_112"></a>输入格式</h5> 
<p>第一行包含两个整数 n,K。</p> 
<p>第二行包含 n 个整数 a1,a2,…,an。</p> 
<h5><a id="_118"></a>输出格式</h5> 
<p>一个整数，表示剩余选手的最小可能数量。</p> 
<h5><a id="_122"></a>数据范围</h5> 
<p>前四个测试点满足 1≤n≤10。<br> 所有测试点满足 1≤n≤2×10<sup>5，1≤K≤10</sup>6，1≤ai≤10^6。</p> 
<h5><a id="1_127"></a>输入样例1：</h5> 
<pre><code>7 1
101 53 42 102 101 55 54
</code></pre> 
<h5><a id="1_134"></a>输出样例1：</h5> 
<pre><code>3
</code></pre> 
<h4><a id="_140"></a>问题描述</h4> 
<p>看一个数能不能活下来，只要看数组里有没有和大于它且不超过k的数，如果有，那这个数显然可以被排除掉，如果没有，那这个数就能留到最后面。</p> 
<p>可以对数组升序排序，从最小的数开始找起，如果有大于它，且差值不超过k的数，这个数就被排掉，我们去找下一个，如果没有，那这个数可以留到最后，用一个变量记录下来。</p> 
<h4><a id="AC_146"></a>AC代码</h4> 
<pre><code>#include&lt;iostream&gt;
using namespace std;
#include&lt;vector&gt;
#include&lt;algorithm&gt;
#include&lt;math.h&gt;
#include&lt;set&gt;
#include&lt;numeric&gt;
#include&lt;string&gt;
#include&lt;string.h&gt;
#include&lt;iterator&gt;
#include&lt;map&gt;
#include&lt;unordered_map&gt;
#include&lt;stack&gt;
#include&lt;list&gt;
#include&lt;queue&gt;
#include&lt;iomanip&gt;

#define endl '\n'
#define int ll
typedef long long ll;
typedef unsigned long long ull;
typedef pair&lt;ll, ll&gt;PII;
const int N = 2e5 + 50;

signed main()
{
    ios_base::sync_with_stdio(false);
    cin.tie(nullptr);
    cout.tie(nullptr);
    priority_queue&lt;int, vector&lt;int&gt;, greater&lt;&gt;&gt;que;
    int n, res = 0, mn = -1, ans = 0, k;
    cin &gt;&gt; n &gt;&gt; k;
    vector&lt;int&gt;v(n);
    for (int i = 0; i &lt; n; i++)
    {
        cin &gt;&gt; v[i];
        que.push(v[i]);
    }
    while (!que.empty())
    {
        ans = 1;
        mn = que.top();
        que.pop();
        while (!que.empty() &amp;&amp; que.top() == mn)
        {
            que.pop();
            ans++;
        }
        if (que.empty() || que.top() - mn &gt; k)
        {
            res += ans;
        }
    }
    cout &lt;&lt; res;
    return 0;
}
</code></pre> 
<h3><a id="4484___AcWinghttpswwwacwingcomproblemcontent4487_207"></a><a href="https://www.acwing.com/problem/content/4487/" rel="nofollow">4484. 有限小数 - AcWing题库</a></h3> 
<p>给定三个整数 p,q,b，请你计算十进制表示下的 p/q 的结果在 b 进制下是否为有限小数。</p> 
<h5><a id="_211"></a>输入格式</h5> 
<p>第一行包含整数 T，表示共有 T 组测试数据。</p> 
<p>每组数据占一行，包含三个整数 p,q,b。</p> 
<h5><a id="_217"></a>输出格式</h5> 
<p>每组数据输出一行结果，如果 p/q 的结果在 b进制下是有限小数，则输出 <code>YES</code>，否则输出 <code>NO</code>。</p> 
<h5><a id="_221"></a>数据范围</h5> 
<p>前五个测试点满足 1≤T≤10。<br> 所有测试点满足 1≤T≤10<sup>5，0≤p≤10</sup>18，1≤q≤10<sup>18，2≤b≤10</sup>18。</p> 
<h5><a id="1_226"></a>输入样例1：</h5> 
<pre><code>2
6 12 10
4 3 10
</code></pre> 
<h5><a id="1_234"></a>输出样例1：</h5> 
<pre><code>YES
NO
</code></pre> 
<h4><a id="_241"></a>问题解析</h4> 
<p>首先讲一下小数转化成b进制的形式：假设有个小数是0.abcd，要转成x进制，那就是**(a*x^-1 )+(b *x^-2 )+(c *x^-3)+(d *x^ -4)**。</p> 
<p>如果我们给十进制下的小数乘上一个x，那就会变成：**(a )+(b *x^-1 )+(c <em>x^-2)+(d <em>x^ -3)</em></em></p> 
<p>那么对于一个k位小数，我们只要乘上k个x，就可以把这个小数全部转化成整数。</p> 
<p>也就是说：对于p/q，只要(p/q) * x^k 是整数，就说明p/q的小数可以用k个有限小数表示出来。</p> 
<p>（具体看注释）</p> 
<h4><a id="AC_253"></a>AC代码</h4> 
<pre><code>#include&lt;iostream&gt;
using namespace std;
#include&lt;vector&gt;
#include&lt;algorithm&gt;
#include&lt;math.h&gt;
#include&lt;set&gt;
#include&lt;numeric&gt;
#include&lt;string&gt;
#include&lt;string.h&gt;
#include&lt;iterator&gt;
#include&lt;map&gt;
#include&lt;unordered_map&gt;
#include&lt;stack&gt;
#include&lt;list&gt;
#include&lt;queue&gt;
#include&lt;iomanip&gt;

#define endl '\n'
#define int ll
typedef long long ll;
typedef unsigned long long ull;
typedef pair&lt;ll, ll&gt;PII;
const int N = 2e5 + 50;

ll gcd(ll a, ll b)
{
    return a == 0 ? b : gcd(b % a, a);
}

signed main()
{
    ios_base::sync_with_stdio(false);
    cin.tie(nullptr);
    cout.tie(nullptr);
    int t;
    cin &gt;&gt; t;
    while (t--)
    {
        ll p, q, b;
        cin &gt;&gt; p &gt;&gt; q &gt;&gt; b;
        //(p/q)*b^k要想是整数，b^k * p就要整除q，我们可以直接把p和q约分，这样就不用管p了，直接看q和b就行
        q /= gcd(p, q);
        while (q &gt; 1)
        {
            ll x = gcd(q, b);
            //如果q和b的公约数互质，说明他俩无法继续约分了，结束程序
            if (x == 1)break;
            while (q % x == 0)q /= x;
        }
        //如果q能和k个b约分约到1，就说明q能整除b^k ,反之不行
        if (q &gt; 1)cout &lt;&lt; "NO" &lt;&lt; endl;
        else cout &lt;&lt; "YES" &lt;&lt; endl;
    }
    return 0;
}
</code></pre>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/496dffb6a5ca926058c8dc065e7bc6f6/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">java实现调用Http请求常用的几种方式</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/78eac392eabc3e567951824fcfd6f442/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">【pytorch笔记】（五）自定义损失函数、学习率衰减、模型微调</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>