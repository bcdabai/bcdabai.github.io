<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>-L -Wl,-rpath-link -Wl,-rpath区别精讲 - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="-L -Wl,-rpath-link -Wl,-rpath区别精讲" />
<meta property="og:description" content="目录
前言源码准备 源码内容尝试编译，保证源码没有问题编译 首先编译world.c编译并链接hello.c调试编译test.c结论 前言 关于gcc这三个参数，参考了诸多文档后，仍然理解上有偏差，仿照下面博客中的方法，自己调试了一波，总算是理解了。还是建议大家动手实践一下。
参考资料如下:
https://blog.csdn.net/q1302182594/article/details/42102961https://blog.csdn.net/openme_openwrt/article/details/7860580 源码准备 新建三个文件：test.c hello.c world.c ，其源码依赖关系为：test.c 依赖 hello.c；hello.c 依赖 world.c
源码内容 test.c
#include &lt;stdio.h&gt; void world(void); void hello(void) { printf(&#34;hello &#34;); world(); } hello.c
#include&lt;stdio.h&gt; void hello(void); void main(void) { hello(); } world.c
#include&lt;stdio.h&gt; void world(void) { printf(&#34;world.\n&#34;); } 尝试编译，保证源码没有问题 # -o 指定输出文件 [root@localhost testc]# ls hello.c test.c world.c [root@localhost testc]# gcc -o hehe *.c [root@localhost testc]# ls hehe hello.c test.c world.c [root@localhost testc]# ." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/a187acaf6f5abed9e047880193a9086c/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2020-07-03T11:25:32+08:00" />
<meta property="article:modified_time" content="2020-07-03T11:25:32+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">-L -Wl,-rpath-link -Wl,-rpath区别精讲</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p>目录</p> 
<ul><li><a href="https://www.cnblogs.com/tianknight/p/10648021.html#%E5%89%8D%E8%A8%80" rel="nofollow">前言</a></li><li><a href="https://www.cnblogs.com/tianknight/p/10648021.html#%E6%BA%90%E7%A0%81%E5%87%86%E5%A4%87" rel="nofollow">源码准备</a> 
  <ul><li><a href="https://www.cnblogs.com/tianknight/p/10648021.html#%E6%BA%90%E7%A0%81%E5%86%85%E5%AE%B9" rel="nofollow">源码内容</a></li><li><a href="https://www.cnblogs.com/tianknight/p/10648021.html#%E5%B0%9D%E8%AF%95%E7%BC%96%E8%AF%91%EF%BC%8C%E4%BF%9D%E8%AF%81%E6%BA%90%E7%A0%81%E6%B2%A1%E6%9C%89%E9%97%AE%E9%A2%98" rel="nofollow">尝试编译，保证源码没有问题</a></li></ul></li><li><a href="https://www.cnblogs.com/tianknight/p/10648021.html#%E7%BC%96%E8%AF%91" rel="nofollow">编译</a> 
  <ul><li><a href="https://www.cnblogs.com/tianknight/p/10648021.html#%E9%A6%96%E5%85%88%E7%BC%96%E8%AF%91worldc" rel="nofollow">首先编译world.c</a></li><li><a href="https://www.cnblogs.com/tianknight/p/10648021.html#%E7%BC%96%E8%AF%91%E5%B9%B6%E9%93%BE%E6%8E%A5helloc" rel="nofollow">编译并链接hello.c</a></li><li><a href="https://www.cnblogs.com/tianknight/p/10648021.html#%E8%B0%83%E8%AF%95%E7%BC%96%E8%AF%91testc" rel="nofollow">调试编译test.c</a></li></ul></li><li><a href="https://www.cnblogs.com/tianknight/p/10648021.html#%E7%BB%93%E8%AE%BA" rel="nofollow">结论</a></li></ul> 
<p> </p> 
<h3 id="前言">前言</h3> 
<p>关于gcc这三个参数，参考了诸多文档后，仍然理解上有偏差，仿照下面博客中的方法，自己调试了一波，总算是理解了。还是建议大家动手实践一下。</p> 
<blockquote> 
 <p>参考资料如下:</p> 
 <ul><li><a href="https://blog.csdn.net/q1302182594/article/details/42102961">https://blog.csdn.net/q1302182594/article/details/42102961</a></li><li><a href="https://blog.csdn.net/openme_openwrt/article/details/7860580">https://blog.csdn.net/openme_openwrt/article/details/7860580</a></li></ul> 
</blockquote> 
<h3 id="源码准备">源码准备</h3> 
<p>新建三个文件：test.c hello.c world.c ，其源码依赖关系为：test.c 依赖 hello.c；hello.c 依赖 world.c</p> 
<h4 id="源码内容">源码内容</h4> 
<p>test.c</p> 
<pre><code>#include &lt;stdio.h&gt;
void world(void);
void hello(void)
{
    printf("hello ");
    world();
}
</code></pre> 
<p>hello.c</p> 
<pre><code>#include&lt;stdio.h&gt;
void hello(void);
void main(void)
{
    hello();
}
</code></pre> 
<p>world.c</p> 
<pre><code>#include&lt;stdio.h&gt;
void world(void)
{
	printf("world.\n");
}
</code></pre> 
<h4 id="尝试编译，保证源码没有问题">尝试编译，保证源码没有问题</h4> 
<pre><code># -o 指定输出文件
[root@localhost testc]# ls
hello.c  test.c  world.c
[root@localhost testc]# gcc -o hehe *.c
[root@localhost testc]# ls
hehe  hello.c  test.c  world.c
[root@localhost testc]# ./hehe 
hello world.
</code></pre> 
<h3 id="编译">编译</h3> 
<h4 id="首先编译worldc">首先编译world.c</h4> 
<pre><code># -shared 编译链接库
# -fPIC 我的理解是编译链接库时给代码动态分配内存
[root@localhost testc]# gcc -shared -fPIC -o libworld.so world.c
[root@localhost testc]# ls
hello.c  libworld.so  test.c  world.c
[root@localhost testc]# ldd libworld.so 
	linux-vdso.so.1 =&gt;  (0x00007ffd7498f000)
	libc.so.6 =&gt; /lib64/libc.so.6 (0x00007fcb49815000)
	/lib64/ld-linux-x86-64.so.2 (0x00007fcb49dea000)

#上述命令和下面的等价，建议选取单条命令即可：gcc -shared -fPIC -o libworld.so world.c
# -c 只激活预处理,编译,和汇编,也就是他只把程序做成obj文件
[root@localhost testc]# gcc -c -fPIC world.c 
[root@localhost testc]# ls
hello.c  test.c  world.c  world.o
[root@localhost testc]# gcc -shared -fPIC -o libworld.so world.o
[root@localhost testc]# ls
hello.c  libworld.so  test.c  world.c  world.o
[root@localhost testc]# ldd libworld.so 
	linux-vdso.so.1 =&gt;  (0x00007ffd0dfa9000)
	libc.so.6 =&gt; /lib64/libc.so.6 (0x00007f4357dcb000)
	/lib64/ld-linux-x86-64.so.2 (0x00007f43583a0000)
</code></pre> 
<h4 id="编译并链接helloc">编译并链接hello.c</h4> 
<pre><code># -lxxx 指定需要动态链接的库文件
# -L 指定动态连接库文件的位置(编译时)
# . 指当前路径
# 下面编译出的libhello.so文件已经显式依赖libworld.so文件，但是没有找到libworld.so的位置
[root@localhost testc]# gcc -shared -fPIC -o libhello.so hello.c -lworld -L.
[root@localhost testc]# ls
hello.c  libhello.so  libworld.so  test.c  world.c
[root@localhost testc]# ldd libhello.so 
	linux-vdso.so.1 =&gt;  (0x00007ffe61b89000)
	libworld.so =&gt; not found
	libc.so.6 =&gt; /lib64/libc.so.6 (0x00007ff73cc1e000)
	/lib64/ld-linux-x86-64.so.2 (0x00007ff73d1f4000)
</code></pre> 
<h4 id="调试编译testc">调试编译test.c</h4> 
<pre><code>[root@localhost testc]# ls
hello.c  libhello.so  libworld.so  test.c  world.c

# 编译出错，提示找不到hello
[root@localhost testc]# gcc -o haha test.c 
/tmp/ccQCWcSW.o: In function 'main':
test.c:(.text+0x5): undefined reference to 'hello'
collect2: error: ld returned 1 exit status

# 添加libhello.so的链接索引，并指定库的搜索路径为'.'(当前路径)
# 依然编译失败，提示找不到libworld.so，该库被libhello.so依赖，并提示建议使用-rpath 或 -rpath-link解决
[root@localhost testc]# gcc -o haha test.c -lhello -L.
/usr/bin/ld: warning: libworld.so, needed by ./libhello.so, not found (try using -rpath or -rpath-link)
./libhello.so: undefined reference to 'world'
collect2: error: ld returned 1 exit status

# 手动添加libworld.so的依赖，编译通过，查看haha的链接库，已经显式指出依赖，但是没有找到其位置
[root@localhost testc]# gcc -o haha test.c -lhello -L. -lworld
[root@localhost testc]# ldd haha 
	linux-vdso.so.1 =&gt;  (0x00007fff556ea000)
	libhello.so =&gt; not found
	libworld.so =&gt; not found
	libc.so.6 =&gt; /lib64/libc.so.6 (0x00007f1ff0c97000)
	/lib64/ld-linux-x86-64.so.2 (0x00007f1ff106b000)

# 执行编译出的haha，执行报错，提示找不到依赖库
[root@localhost testc]# ./haha 
./haha: error while loading shared libraries: libhello.so: cannot open shared object file: No such file or directory

#修改系统环境变量'LD_LIBRARY_PATH',增加索引库的位置，查看依赖OK，执行haha, 结果OK, 清空'LD_LIBRARY_PATH'
[root@localhost testc]# export LD_LIBRARY_PATH=/home/testc/  &amp;&amp; echo $LD_LIBRARY_PATH
/home/testc/
[root@localhost testc]# ldd haha 
	linux-vdso.so.1 =&gt;  (0x00007ffd647d2000)
	libhello.so =&gt; /home/testc/libhello.so (0x00007fb7aa063000)
	libworld.so =&gt; /home/testc/libworld.so (0x00007fb7a9e60000)
	libc.so.6 =&gt; /lib64/libc.so.6 (0x00007fb7a9a8e000)
	/lib64/ld-linux-x86-64.so.2 (0x00007fb7aa266000)
[root@localhost testc]# ./haha 
hello world.
[root@localhost testc]# export LD_LIBRARY_PATH=  &amp;&amp; echo $LD_LIBRARY_PATH

# 将-lworld 替换为 -Wl,-rpath-link=. ，编译OK，依然找不到索引库，添加LD_LIBRARY_PATH后，执行OK 
[root@localhost testc]# gcc -o haha test.c -lhello -L. -Wl,-rpath-link=.
[root@localhost testc]# ldd haha 
	linux-vdso.so.1 =&gt;  (0x00007ffdf67c0000)
	libhello.so =&gt; not found
	libc.so.6 =&gt; /lib64/libc.so.6 (0x00007fbdbb94b000)
	/lib64/ld-linux-x86-64.so.2 (0x00007fbdbbd1f000)
[root@localhost testc]# ./haha 
./haha: error while loading shared libraries: libhello.so: cannot open shared object file: No such file or directory
[root@localhost testc]# export LD_LIBRARY_PATH=/home/testc  &amp;&amp; echo $LD_LIBRARY_PATH
/home/testc
[root@localhost testc]# ldd haha 
	linux-vdso.so.1 =&gt;  (0x00007fff89504000)
	libhello.so =&gt; /home/testc/libhello.so (0x00007fc9e75c6000)
	libc.so.6 =&gt; /lib64/libc.so.6 (0x00007fc9e71f3000)
	libworld.so =&gt; /home/testc/libworld.so (0x00007fc9e6ff1000)
	/lib64/ld-linux-x86-64.so.2 (0x00007fc9e77c9000)
[root@localhost testc]# ./haha 
hello world.
[root@localhost testc]# export LD_LIBRARY_PATH=  &amp;&amp; echo $LD_LIBRARY_PATH

# 将-Wl,-rpath-link=. 换成 -Wl,-rpath=. 编译OK， 查看链接库OK，执行OK 
# 修改LD_LIBRARY_PATH后，链接库的位置没有变化
[root@localhost testc]# gcc -o haha test.c -lhello -L. -Wl,-rpath=.
[root@localhost testc]# ls
haha  hello.c  libhello.so  libworld.so  test.c  world.c
[root@localhost testc]# ldd haha 
	linux-vdso.so.1 =&gt;  (0x00007fff86195000)
	libhello.so =&gt; ./libhello.so (0x00007f4c11254000)
	libc.so.6 =&gt; /lib64/libc.so.6 (0x00007f4c10e81000)
	libworld.so =&gt; ./libworld.so (0x00007f4c10c7f000)
	/lib64/ld-linux-x86-64.so.2 (0x00007f4c11457000)
[root@localhost testc]# ./haha 
hello world.
[root@localhost testc]# export LD_LIBRARY_PATH=/home/testc/  &amp;&amp; echo $LD_LIBRARY_PATH
/home/testc/
[root@localhost testc]# ldd haha 
	linux-vdso.so.1 =&gt;  (0x00007ffc9f36c000)
	libhello.so =&gt; ./libhello.so (0x00007f35cf07c000)
	libc.so.6 =&gt; /lib64/libc.so.6 (0x00007f35ceca9000)
	libworld.so =&gt; ./libworld.so (0x00007f35ceaa7000)
	/lib64/ld-linux-x86-64.so.2 (0x00007f35cf27f000)
[root@localhost testc]# export LD_LIBRARY_PATH=  &amp;&amp; echo $LD_LIBRARY_PATH


</code></pre> 
<h3 id="结论">结论</h3> 
<blockquote> 
 <ul><li>编译时链接库需要分为两类： 直接引用 间接引用</li><li><strong>直接引用</strong> 被源码中直接调用的库</li><li><strong>间接引用</strong> 被调用库的依赖库</li><li><strong>-lxxx</strong> 指定具体的库名称，编译时需要显式指定直接引用的库名称</li><li><strong>-L</strong> 指定链接库的位置，编译时需要显式指定直接引用的库位置</li><li><strong>-Wl,-rpath-link</strong> ，用于编译时指定间接引用的库位置<br> 如果知道所有间接引用的库文件名称，并且不嫌麻烦，也可以用-lxxx显式指定每一个库（不推荐-lxxx）</li><li><strong>-Wl,-rpath</strong> ，有两个作用：<br> 1. 用于编译时指定间接引用的库位置，作用同-Wl,-rpath-link<br> 2. 用于运行时指定所有引用库的位置，作用同修改环境变量(LD_LIBRARY_PATH),并且库路径引用优先级高于LD_LIBRARY_PATH</li><li>使用建议<br> 1. 编译命令中使用-Wl,-rpath-link 指定间接引用库位置(编译时)，使用-Wl,-rpath 指定引用库位置（运行时）<br> 2. -Wl,-rpath-link 在 -Wl,-rpath 前</li></ul> 
</blockquote>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/0fbc3a385bd5fcbf6059bd0e57863206/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">Android Studio 基础 之 简单获取手机端所有图片</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/1a4f3ddc0eb55ef4f7757daea5f58804/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">RIP协议距离向量算法——路由表更新</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>