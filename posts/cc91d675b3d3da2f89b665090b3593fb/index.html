<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>java中 Excel文件解析及超大Excel文件读写 - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="java中 Excel文件解析及超大Excel文件读写" />
<meta property="og:description" content="本文主要对Excel中数据的解析和生成进行总结
前言 在应用程序的开发过程中，我们经常要用到Excel进行数据的导入或导出。所以，在通过Java语言实现此类需求时，通常会对Excel文件进行解析或生成。
一、Excel文件解析 1，概述
在应用程序开发过程中，经常需要使用Excel文件来进行数据的导入或导出。所以，在通过Java语言来实现此类需求的时候，往往会面临着Excel文件解析（导入）或生成（导出）。
在Java技术生态圈中，可以进行Excel问价处理的主流技术包括：Apache POI，JXL，Alibaba EasyExcel等。
Apache POI基于DOM方式进行解析，将文件直接加载内存，所以速度较快，适合Excel文件数量不大的应用场景。JXL只支持Excel2003以下版本，所以不太常见。
Alibaba EasyExcel采用逐行读取的解析模式，将每一行的解析结果以观察者模式通知处理（AnalyEventListener），所以比较适合数据体量较大的Excel文件解析。
2， Apache POI
Apache POI使用Java编写的免费开源的跨平台的Java API。Apache POI提供给Java程序对Microso Office 格式档案进行读写功能的API开源类库
HSSF ：提供读写Microsoft Excel格式档案的功能。
XSSF ：提供读写Microsoft Excel 0OXML格式档案的功能。HWPF
HWPF : 提供读写Microsoft Word格式档案的功能。
HSLF : 提供读写Microsoft PowerPoint格式档案的功能。
HDGF : 提供读写Microsoft Visio格式档案的功能。
3， XSSF解析Excel文件
HSSF用于解析旧版本(*.xls) Excel文件， 由于旧版本的Excel文件只能存在65535行数据, 所以目前已经不常用。所以目前主要采用XSSF进行新版本(*.xlsx) Exce文件的解析。
导入下图中的架包：
Workbook (Excel文件)
Workbook接口代表一一个 Excel文件，用于创建或加载(解析)见实现类是XSSFWorkbook。
创建Excel文件：
// 输出流 FileOutputStream fos = new FileOutputStream(&#34;c:\\test\\temp.xlsx&#34;); // Excel文件对象 Workbook workbook = new XSSFWorkbook(); // 通过输出流进行写入 workbook." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/cc91d675b3d3da2f89b665090b3593fb/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-07-17T10:03:12+08:00" />
<meta property="article:modified_time" content="2022-07-17T10:03:12+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">java中 Excel文件解析及超大Excel文件读写</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <blockquote> 
 <p>本文主要对Excel中数据的解析和生成进行总结</p> 
</blockquote> 
<div>
    
</div> 
<hr> 
<h2>前言</h2> 
<p>                在应用程序的开发过程中，我们经常要用到Excel进行数据的导入或导出。所以，在通过Java语言实现此类需求时，通常会对Excel文件进行解析或生成。</p> 
<hr> 
<p> </p> 
<h2>一、Excel文件解析</h2> 
<p>1，概述</p> 
<p>            在应用程序开发过程中，经常需要使用Excel文件来进行数据的导入或导出。所以，在通过Java语言来实现此类需求的时候，往往会面临着Excel文件解析（导入）或生成（导出）。</p> 
<p><br>              在Java技术生态圈中，可以进行Excel问价处理的主流技术包括：Apache POI，JXL，Alibaba EasyExcel等。</p> 
<p><br>              Apache POI基于DOM方式进行解析，将文件直接加载内存，所以速度较快，适合Excel文件数量不大的应用场景。JXL只支持Excel2003以下版本，所以不太常见。</p> 
<p><br>              Alibaba EasyExcel采用逐行读取的解析模式，将每一行的解析结果以观察者模式通知处理（AnalyEventListener），所以比较适合数据体量较大的Excel文件解析。</p> 
<p>2，  Apache POI<br>          Apache POI使用Java编写的免费开源的跨平台的Java API。Apache POI提供给Java程序对Microso Office 格式档案进行读写功能的API开源类库</p> 
<p><br> HSSF ：提供读写Microsoft Excel格式档案的功能。<br><br> XSSF ：提供读写Microsoft Excel 0OXML格式档案的功能。HWPF<br><br> HWPF :  提供读写Microsoft Word格式档案的功能。<br><br> HSLF  :  提供读写Microsoft PowerPoint格式档案的功能。<br><br> HDGF  :  提供读写Microsoft Visio格式档案的功能。<br> 3， XSSF解析Excel文件<br><br> HSSF用于解析旧版本(*.xls) Excel文件， 由于旧版本的Excel文件只能存在65535行数据, 所以目前已经不常用。所以目前主要采用XSSF进行新版本(*.xlsx) Exce文件的解析。</p> 
<p>         导入下图中的架包：</p> 
<p>                                       <img src="https://images2.imgbox.com/ba/c7/1vZTVs3I_o.png" alt="8262fc7c0215428ca748caba5e8b3981.png"></p> 
<p> </p> 
<p> Workbook (Excel文件)<br><br> Workbook接口代表一一个 Excel文件，用于创建或加载(解析)见实现类是XSSFWorkbook。</p> 
<p>                创建Excel文件：</p> 
<pre><code>// 输出流
FileOutputStream fos = new FileOutputStream("c:\\test\\temp.xlsx");

// Excel文件对象
Workbook workbook = new XSSFWorkbook();

// 通过输出流进行写入
workbook.write(fos);

// 关闭资源
fos.close();
workbook.close();</code></pre> 
<pre><code>try (Workbook workbook = new XSSFWorkbook();
                FileOutputStream fos = new FileOutputStream("c:\\test\\temp.xlsx")) {
    workbook.write(fos);
} catch (IOException e) {
    e.printStackTrace();
}

</code></pre> 
<p> </p> 
<p>解析Excel文件</p> 
<pre><code>// 输入流
FileInputStream fis = new FileInputStream("c:\\test\\12345.xlsx");

// Excel文件对象
Workbook workbook = new XSSFWorkbook(fis);</code></pre> 
<h2>Sheet(工作簿)</h2> 
<p>通过Workbook来进行工作簿Sheet对象的获取或创建。</p> 
<p> </p> 
<p>创建工作簿</p> 
<pre><code>// 按照默认名称创建工作簿
Sheet sheet1 = workbook.createSheet();

// 按照自定义名称创建工作簿
Sheet sheet2 = workbook.createSheet("自定义工作簿2");
</code></pre> 
<p>获取工作簿</p> 
<pre><code>// 按照工作簿下标获取Sheet
Sheet sheet01 = workbook.getSheetAt(0);

// 按照工作簿名称获取Sheet
Sheet sheet02 = workbook.getSheet("Sheet0");</code></pre> 
<h3> </h3> 
<p>获取工作簿数量</p> 
<pre><code>int n = workbook.getNumberOfSheets();</code></pre> 
<h3> </h3> 
<p>Row (数据行)<br><br> 通过Sheet 来进行数据行Row 对象的获取或创建</p> 
<h3> </h3> 
<p>获取首行下标</p> 
<p>int first = sheet.getFirstRowNum();</p> 
<p>获取末尾行下标</p> 
<p>int last = sheet.getLastRowNum();</p> 
<p>根据下标获取指定行</p> 
<p>Row row = sheet.getRow(0);</p> 
<p>遍历所有行</p> 
<p>for(Row row : sheet) {<!-- --><br>     System.out.println(row);<br> }</p> 
<p>遍历指定区域行</p> 
<p>for (int i = 1; i &lt;= sheet.getLastRowNum(); i++) {<!-- --><br>     Row row = sheet.getRow(i);<br>     System.out.println(row);<br> }</p> 
<p>Cell (单元格)<br><br> 通过Row 来进行单元格Cell 对象的获取或创建</p> 
<p>创建单元格</p> 
<p>Cell cell0 = row.createCell(0);</p> 
<p>设置单元格值</p> 
<p>cell0.setCellValue(UUID.randomUUID().toString());</p> 
<p>遍历所有单元格</p> 
<p>for(Cell cell : row) {<!-- --><br>                 <br> }</p> 
<p>获取所有单元格类型</p> 
<p>CellType type = cell.getCellType();</p> 
<p>设置单元格样式</p> 
<pre><code>// 创建单元格样式
DataFormat dataFormat = workbook.createDataFormat();
Short formatCode = dataFormat.getFormat("yyyy-MM-dd HH:mm:ss");
CellStyle cellStyle = workbook.createCellStyle();
cellStyle.setDataFormat(formatCode);

// ...

// 为当前行创建单元格
Cell cell1 = row.createCell(1);
cell1.setCellStyle(cellStyle); // 设置单元格样式
cell1.setCellValue(new Date()); // 保存当前日期时间至本单元格
</code></pre> 
<h3> </h3> 
<h2>设置单元格对齐</h2> 
<pre><code>// 创建单元格样式
CellStyle cellStyle = workbook.createCellStyle();

//设置单元格的水平对齐类型。 此时水平居中
cellStyle.setAlignment(HorizontalAlignment.CENTER);

// 设置单元格的垂直对齐类型。 此时垂直靠底边
cellStyle.setVerticalAlignment(VerticalAlignment.BOTTOM);</code></pre> 
<p> </p> 
<h2>二、超大Excel文件读写</h2> 
<p><strong>1，使用POI写入</strong></p> 
<pre><code>package Myde;



import java.io.FileInputStream;
import java.io.FileOutputStream;
import java.io.IOException;
import java.util.Arrays;
import java.util.Date;
import java.util.List;
 
import org.apache.poi.ss.usermodel.Cell;
import org.apache.poi.ss.usermodel.CellStyle;
import org.apache.poi.ss.usermodel.DataFormat;
import org.apache.poi.ss.usermodel.Row;
import org.apache.poi.ss.usermodel.Sheet;
import org.apache.poi.ss.usermodel.Workbook;
import org.apache.poi.xssf.streaming.SXSSFWorkbook;
import org.apache.poi.xssf.usermodel.XSSFWorkbook;
 
public class Demo06{
	public static void main(String[] args) {
		//List&lt;String&gt; list= Arrays.asList("AA","BB","CC","DD","EE","FF");
		
		//读取一个已存在的Excel文件
		try (Workbook workbook=new SXSSFWorkbook(1000);
			FileOutputStream out=new FileOutputStream("D:\\demo-data.xlsx")){
			
			//在已经存在的Excel文件中，创建一个新的sheet
			Sheet sheet=workbook.createSheet();
			
			//获取格式编码值
			DataFormat dataformat=workbook.createDataFormat();
			short dateformatCode=dataformat.getFormat("yy年MM月dd日 HH:mm:ss");
			short moneyformatCode=dataformat.getFormat("￥#,###");
			
			//创建日期格式对象
			CellStyle datecellstyle=workbook.createCellStyle();
			datecellstyle.setDataFormat(dateformatCode);
			
			//创建货币格式对象
			CellStyle moneycellstyle=workbook.createCellStyle();
			moneycellstyle.setDataFormat(moneyformatCode);;
			
			//创建列头
			 Row headrow=sheet.createRow(0);
			 Cell headcell0=headrow.createCell(0);
			 headcell0.setCellValue("序号");
			 
			 Cell headcell1=headrow.createCell(1);
			 headcell1.setCellValue("姓名");
			 
			 Cell headcell2=headrow.createCell(2);
			 headcell2.setCellValue("日期");
			 
			 Cell headcell3=headrow.createCell(3);
			 headcell3.setCellValue("红包金额");
			 long begin=System.currentTimeMillis();
			 for(int i=0;i&lt;1000000;i++) {
				 //String name=list.get(i);
				 String name=i+"A";
				 //创建行
				 Row row=sheet.createRow(i+1);
				 
				 //创建单元格
				 Cell cell0=row.createCell(0);//序号
				 cell0.setCellValue(String.valueOf(i+1));
				 
				 Cell cell1=row.createCell(1);//姓名
				 cell1.setCellValue(name);
				 
				 Cell cell2=row.createCell(2);//日期
				 cell2.setCellStyle(datecellstyle);
				 cell2.setCellValue(new Date());
				 
				 Cell cell3=row.createCell(3);//金额
				 cell3.setCellStyle(moneycellstyle);
				 cell3.setCellValue(Math.random()*1000000);
				 
			 }
			 //写入文件
			workbook.write(out);
			long end=System.currentTimeMillis();
			System.out.println("耗时"+(end-begin)+"毫秒");
		} catch (IOException e) {
			
			e.printStackTrace();
		}
	}
 
}

</code></pre> 
<h3> </h3> 
<h3>可以看到使用SXSSDWorkbook的执行时间为：</h3> 
<p><img src="https://images2.imgbox.com/d4/79/buJ9K0ax_o.png" alt="dd19f5dc88c6457a9852cbf25160be69.png"></p> 
<h3>2.使用EasyExcel</h3> 
<p>   （1）下载alibaba easyexcel相关jar包</p> 
<p>   （2）  订单实体类Order</p> 
<pre><code>public class Order {
    @ExcelProperty("订单编号")
	private String orderId; // 订单编号
	
    @ExcelProperty("支付金额")
	@NumberFormat("￥#,###")
	private Double payment; // 支付金额
	
    @ExcelProperty(value = "创建日期",converter = LocalDateTimeConverter.class)
	private LocalDateTime creationTime; // 创建时间

	public Order() {
		this.orderId = LocalDateTime.now().format(DateTimeFormatter.ofPattern("yyyyMMddhhmmss"))
				+ UUID.randomUUID().toString().substring(0, 5);
		this.payment = Math.random() * 10000;
		this.creationTime = LocalDateTime.now();
	}

	public String getOrderId() {
		return orderId;
	}

	public void setOrderId(String orderId) {
		this.orderId = orderId;
	}

	public Double getPayment() {
		return payment;
	}

	public void setPayment(Double payment) {
		this.payment = payment;
	}

	public LocalDateTime getCreationTime() {
		return creationTime;
	}

	public void setCreationTime(LocalDateTime creationTime) {
		this.creationTime = creationTime;
	}



	@Override
	public String toString() {
		return "Order [orderId=" + orderId + ", payment=" + payment + ", creationTime=" + creationTime + "]";
	}
}</code></pre> 
<p>（3）Converter转换类（兼容LocalDateTime日期时间类）</p> 
<pre><code>public class LocalDateTimeConverter implements Converter&lt;LocalDateTime&gt; {

	@Override
	public Class&lt;LocalDateTime&gt; supportJavaTypeKey() {
		return LocalDateTime.class;
	}

	@Override
	public CellDataTypeEnum supportExcelTypeKey() {
		return CellDataTypeEnum.STRING;
	}

	@Override
	public LocalDateTime convertToJavaData(CellData cellData, ExcelContentProperty contentProperty,
			GlobalConfiguration globalConfiguration) {
		return LocalDateTime.parse(cellData.getStringValue(), DateTimeFormatter.ofPattern("yyyy-MM-dd HH:mm:ss"));
	}

	@Override
	public CellData&lt;String&gt; convertToExcelData(LocalDateTime value, ExcelContentProperty contentProperty,
			GlobalConfiguration globalConfiguration) {
		return new CellData&lt;&gt;(value.format(DateTimeFormatter.ofPattern("yyyy-MM-dd HH:mm:ss")));
	}

}</code></pre> 
<p>（4）写入100w条数据</p> 
<pre><code>public class Demo {
	public static void main(String[] args) {
        // 写入100w
        EasyExcel.write("c:\\test\\run\\easy.xlsx", Order.class)
                 .sheet("订单列表")
                 .doWrite(data());
    }
    
    // 创建100w条订单数据
    private static List&lt;Order&gt; data() {
        List&lt;Order&gt; list = new ArrayList&lt;Order&gt;();
        for (int i = 0; i &lt; 1000000; i++) {
            list.add(new Order());
        }
        return list;
    }
}</code></pre> 
<p>（5）读取100w条数据</p> 
<pre><code>EasyExcel.read("c:\\test\\run\\easy.xlsx", Order.class,new AnalysisEventListener&lt;Order&gt;() {
    @Override
    public void invoke(Order order, AnalysisContext arg1) {
        // 读取每条数据
        orderList.add(order);
    }

    @Override
    public void invokeHeadMap(Map&lt;Integer, String&gt; headMap, AnalysisContext context) {
        // 读取到列头
        System.out.println(headMap);
    }

    @Override
    public void doAfterAllAnalysed(AnalysisContext arg0) {
        // 读取完毕
        System.out.println("END");
    }
}).sheet().doRead();</code></pre> 
<p>EasyExcel的执行时间为</p> 
<p><img src="https://images2.imgbox.com/03/2e/WNqF7Py9_o.png" alt="7550104b22fe42d68d3102edc8201b05.png"></p> 
<p> </p> 
<p>可以看到两种方法时间相差不大，但在运行时，CPU的利用率还是有一定差距。</p> 
<p> </p> 
<p> </p> 
<p> POI:</p> 
<p><img src="https://images2.imgbox.com/25/f3/B693FHLP_o.png" alt="a025ea3ceee9424794995c72dac58185.png"></p> 
<p>EasyExcel：</p> 
<p><img src="https://images2.imgbox.com/19/53/rDr0oKcM_o.png" alt="3655d60bd05f482aba8def326566c29b.png"></p> 
<p> </p> 
<p>从此可以得出，在读写超大Excel文件时，我推荐大家使用EasyExcel。</p> 
<hr> 
<p> </p> 
<p> </p> 
<h2>总结</h2> 
<ol><li style="text-align:justify;">Excel文件解析  apache POI,可以解析world和Excel</li><li style="text-align:justify;">getRow(),获取行    lastRoeNumber() 最后一个，getCell()按下标获取当前行的单元格</li><li style="text-align:justify;">GetStringCellValue() --&gt;文本     getNumberCellValue() --&gt;数字</li><li style="text-align:justify;">Workbook.createSheet() 创建表格</li><li style="text-align:justify;">CellStyle单元格格式</li><li style="text-align:justify;">Excel文件对象  Workbook workbook=new XSSFEorkbook()</li><li style="text-align:justify;">创建工作簿  Sheet sheet1=workbook.createSheet();</li><li style="text-align:justify;">按照工作簿下标获取Sheet  Sheet sheet1=workbook.getSheetAt(0);</li><li style="text-align:justify;">遍历所有行for(Row row:sheet){System.out.println(row);}</li></ol> 
<p> </p> 
<p> </p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/17ee00c498eb4ce9f3b5caa976c45851/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">例题 9-27 方块消除（Blocks, UVa10559）</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/0abfc660a33cdcbb2eb0e83f80210043/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">外卖数据库管理系统</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>