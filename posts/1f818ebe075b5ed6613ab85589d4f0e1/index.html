<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Python基础——7.函数 - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Python基础——7.函数" />
<meta property="og:description" content="Python基础——7.函数 7.0 前言7.1 定义函数7.1.1 向函数传递信息7.1.2 实参和形参 7.2 传递实参7.2.1 位置实参1. 调用函数多次2. 位置实参的顺序很重要 7.2.2 关键字实参7.2.3 默认值7.2.4 等效的函数调用7.2.5 避免实参错误 7.3 返回值7.3.1 返回简单值7.3.2 让实参变成可选的7.3.3 返回字典7.3.4 结合使用函数和while 循环 7.4 传递列表7.4.1 在函数中修改列表7.4.2 禁止函数修改列表 7.5 传递任意数量的实参7.5.1 结合使用位置实参和任意数量实参7.5.2 使用任意数量的关键字实参 7.6 将函数存储在模块中7.6.1 导入整个模块7.6.2 导入特定的函数7.6.3 使用as 给函数指定别名7.6.4 使用as 给模块指定别名7.6.5 导入模块中的所有函数 7.7 函数编写指南7.8 小结习题 7.0 前言 在本章中，你将学习编写函数 。函数是带名字的代码块，用于完成具体的工作。
要执行函数定义的特定任务，可调用该函数。需要在程序中多次执行同一项任务时，你无需反复编写完成该任务的代码，而只需调用执行该任务的函数，让Python运行
其中的代码。你将发现，通过使用函数，程序的编写、阅读、测试和修复都将更容易。
在本章中，你还会学习向函数传递信息的方式。你将学习如何编写主要任务是显示信息的函数，还有用于处理数据并返回一个或一组值的函数。最后，你将学习如何
将函数存储在被称为模块 的独立文件中，让主程序文件的组织更为有序。
7.1 定义函数 下面是一个打印问候语的简单函数，名为hello():
def hello(): # 1 &#34;&#34;&#34;函数作用：输出Hello!&#34;&#34;&#34; # 2 print(&#34;Hello!&#34;) # 3 hello() # 4 print(hello.__doc__) # 5 这个示例演示了最简单的函数结构。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/1f818ebe075b5ed6613ab85589d4f0e1/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-03-24T21:51:55+08:00" />
<meta property="article:modified_time" content="2023-03-24T21:51:55+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Python基础——7.函数</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-dracula">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p></p> 
<div class="toc"> 
 <h4>Python基础——7.函数</h4> 
 <ul><li><a href="#70__2" rel="nofollow">7.0 前言</a></li><li><a href="#71__10" rel="nofollow">7.1 定义函数</a></li><li><ul><li><a href="#711__33" rel="nofollow">7.1.1 向函数传递信息</a></li><li><a href="#712__54" rel="nofollow">7.1.2 实参和形参</a></li></ul> 
  </li><li><a href="#72__66" rel="nofollow">7.2 传递实参</a></li><li><ul><li><a href="#721__72" rel="nofollow">7.2.1 位置实参</a></li><li><ul><li><a href="#1__99" rel="nofollow">1. 调用函数多次</a></li><li><a href="#2__131" rel="nofollow">2. 位置实参的顺序很重要</a></li></ul> 
   </li><li><a href="#722__153" rel="nofollow">7.2.2 关键字实参</a></li><li><a href="#723__176" rel="nofollow">7.2.3 默认值</a></li><li><a href="#724__223" rel="nofollow">7.2.4 等效的函数调用</a></li><li><a href="#725__248" rel="nofollow">7.2.5 避免实参错误</a></li></ul> 
  </li><li><a href="#73__283" rel="nofollow">7.3 返回值</a></li><li><ul><li><a href="#731__291" rel="nofollow">7.3.1 返回简单值</a></li><li><a href="#732__320" rel="nofollow">7.3.2 让实参变成可选的</a></li><li><a href="#733__380" rel="nofollow">7.3.3 返回字典</a></li><li><a href="#734_while__426" rel="nofollow">7.3.4 结合使用函数和while 循环</a></li></ul> 
  </li><li><a href="#74__480" rel="nofollow">7.4 传递列表</a></li><li><ul><li><a href="#741__509" rel="nofollow">7.4.1 在函数中修改列表</a></li><li><a href="#742__617" rel="nofollow">7.4.2 禁止函数修改列表</a></li></ul> 
  </li><li><a href="#75__643" rel="nofollow">7.5 传递任意数量的实参</a></li><li><ul><li><a href="#751__689" rel="nofollow">7.5.1 结合使用位置实参和任意数量实参</a></li><li><a href="#752__719" rel="nofollow">7.5.2 使用任意数量的关键字实参</a></li></ul> 
  </li><li><a href="#76__769" rel="nofollow">7.6 将函数存储在模块中</a></li><li><ul><li><a href="#761__787" rel="nofollow">7.6.1 导入整个模块</a></li><li><a href="#762__834" rel="nofollow">7.6.2 导入特定的函数</a></li><li><a href="#763_as__853" rel="nofollow">7.6.3 使用as 给函数指定别名</a></li><li><a href="#764_as__875" rel="nofollow">7.6.4 使用as 给模块指定别名</a></li><li><a href="#765__896" rel="nofollow">7.6.5 导入模块中的所有函数</a></li></ul> 
  </li><li><a href="#77__916" rel="nofollow">7.7 函数编写指南</a></li><li><a href="#78__946" rel="nofollow">7.8 小结</a></li><li><a href="#_970" rel="nofollow">习题</a></li></ul> 
</div> 
<p></p> 
<h2><a id="70__2"></a>7.0 前言</h2> 
<p>在本章中，你将学习编写函数 。函数是带名字的代码块，用于完成具体的工作。</p> 
<p>要执行函数定义的特定任务，可调用该函数。需要在程序中多次执行同一项任务时，你无需反复编写完成该任务的代码，而只需调用执行该任务的函数，让Python运行<br> 其中的代码。你将发现，通过使用函数，程序的编写、阅读、测试和修复都将更容易。</p> 
<p>在本章中，你还会学习向函数传递信息的方式。你将学习如何编写主要任务是显示信息的函数，还有用于处理数据并返回一个或一组值的函数。最后，你将学习如何<br> 将函数存储在被称为模块 的独立文件中，让主程序文件的组织更为有序。</p> 
<h2><a id="71__10"></a>7.1 定义函数</h2> 
<p>下面是一个打印问候语的简单函数，名为hello():</p> 
<pre><code class="prism language-python"><span class="token keyword">def</span> <span class="token function">hello</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span> <span class="token comment"># 1</span>
    <span class="token triple-quoted-string string">"""函数作用：输出Hello!"""</span> <span class="token comment"># 2</span>
    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"Hello!"</span><span class="token punctuation">)</span> <span class="token comment"># 3</span>

hello<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment"># 4</span>
<span class="token keyword">print</span><span class="token punctuation">(</span>hello<span class="token punctuation">.</span>__doc__<span class="token punctuation">)</span> <span class="token comment"># 5</span>
</code></pre> 
<p>这个示例演示了最简单的函数结构。</p> 
<p>1处的代码行使用关键字def 来告诉Python你要定义一个函数。这是函数定义，向Python指出了函数名，还可能在括号内指出函数为完成其任务需要什么样的信息。在这里，函数名为hello()，它不需要任何信息就能完成其工作，因此括号是空的（即便如此，括号也必不可少）。最后，定义以冒号结尾。 紧跟在def greet_user(): 后面的所有缩进行构成了函数体。</p> 
<p>2处的文本是被称为文档字符串（docstring）的注释，描述了函数是做什么的。文档字符串用三引号括起，Python使用它们来生成有关程序中函数的文档。你可以使用5处的代码查看函数文档。</p> 
<p>代码行print(“Hello!”) （见3）是函数体内的唯一一行代码，hello()只做一项工作：打印Hello!。要使用这个函数，可调用它。函数调用 让Python执行函数的代码。</p> 
<p>要调用 函数，可依次指定函数名以及用括号括起的必要信息，如4处所示。由于这个函数不需要任何信息，因此调用它时只需输入hello()即可。和预期的一样，它打印HelloWorld!</p> 
<pre><code>Hello!
函数作用：输出Hello！
</code></pre> 
<h3><a id="711__33"></a>7.1.1 向函数传递信息</h3> 
<p>只需稍作修改，就可以让函数hello()不仅向用户显示Hello! ，还将用户的名字用作抬头。为此，可在函数定义def hello() 的括号内添加username 。</p> 
<p>通过在这里添加username ，就可让函数接受你给username指定的任何值。现在，这个函数要求你调用它时给username指定一个值。调用hello()时，可将一个名字传递给它，如下所示：</p> 
<pre><code class="prism language-python"><span class="token keyword">def</span> <span class="token function">hello</span><span class="token punctuation">(</span>username<span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token triple-quoted-string string">"""显示简单的问候语"""</span>
    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"Hello, "</span> <span class="token operator">+</span> username <span class="token operator">+</span> <span class="token string">"!"</span><span class="token punctuation">)</span>
    
hello<span class="token punctuation">(</span><span class="token string">'Python'</span><span class="token punctuation">)</span>
</code></pre> 
<p>代码hello(‘Python’)调用函数hello()，并向它提供执行print 语句所需的信息。</p> 
<p>这个函数接受你传递给它的名字，并向这个人发出问候:</p> 
<pre><code>Hello, Python!
</code></pre> 
<p>同样，hello(‘java’)调用函数hello()并向它传递’java’，打印Hello,java!。</p> 
<p>你可以根据需要调用函数hello()任意次，调用时无论传入什么样的名字，都会生成相应的输出。</p> 
<h3><a id="712__54"></a>7.1.2 实参和形参</h3> 
<p>前面定义函数hello()时，要求给变量username指定一个值。</p> 
<p>调用这个函数并提供这种信息（人名）时，它将打印相应的问候语。</p> 
<p>在函数hello()的定义中，变量username是一个形参 ——函数完成其工作所需的一项信息。</p> 
<p>在代码hello(‘Python’)中，值’Python’是一个实参 。</p> 
<p>实参是调用函数时传递给函数的信息。我们调用函数时，将要让函数使用的信息放在括号内。</p> 
<p>在hello(‘Python’)中，将实参’Python’传递给了函数hello()，这个值被存储在形参username 中。</p> 
<h2><a id="72__66"></a>7.2 传递实参</h2> 
<p>鉴于函数定义中可能包含多个形参，因此函数调用中也可能包含多个实参。</p> 
<p>向函数传递实参的方式很多，可使用位置实参，这要求实参的顺序与形参的顺序相同；也可使用关键字实参 ，其中每个实参都由变量名和值组成；还可使用列表和字典。</p> 
<p>下面来依次介绍这些方式。</p> 
<h3><a id="721__72"></a>7.2.1 位置实参</h3> 
<p>你调用函数时，Python必须将函数调用中的每个实参都关联到函数定义中的一个形参。</p> 
<p>为此，最简单的关联方式是基于实参的顺序。这种关联方式被称为位置实参。</p> 
<p>为明白其中的工作原理，来看一个显示宠物信息的函数。这个函数指出一个宠物属于哪种动物以及它叫什么名字，如下所示：</p> 
<pre><code class="prism language-python"><span class="token keyword">def</span> <span class="token function">describe_pet</span><span class="token punctuation">(</span>animal_type<span class="token punctuation">,</span> pet_name<span class="token punctuation">)</span><span class="token punctuation">:</span> <span class="token comment"># ❶ </span>
    <span class="token triple-quoted-string string">"""显示宠物的信息"""</span>
    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"\nI have a "</span> <span class="token operator">+</span> animal_type <span class="token operator">+</span> <span class="token string">"."</span><span class="token punctuation">)</span>
    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"My "</span> <span class="token operator">+</span> animal_type <span class="token operator">+</span> <span class="token string">"'s name is "</span> <span class="token operator">+</span> pet_name <span class="token operator">+</span> <span class="token string">"."</span><span class="token punctuation">)</span>
    
describe_pet<span class="token punctuation">(</span><span class="token string">'hamster'</span><span class="token punctuation">,</span> <span class="token string">'harry'</span><span class="token punctuation">)</span> <span class="token comment"># ❷</span>
</code></pre> 
<p>这个函数的定义表明，它需要一种动物类型和一个名字（见❶）。</p> 
<p>调用describe_pet() 时，需要按顺序提供一种动物类型和一个名字。</p> 
<p>例如，在前面的函数调用中，实参’hamster’ 存储在形参animal_type 中，而实参’harry’ 存储在形参pet_name 中（见❷）。</p> 
<p>在函数体内，使用了这两个形参来显示宠物的信息。</p> 
<p>输出描述了一只名为harry的仓鼠：</p> 
<pre><code>I have a hamster.
My hamster's name is harry.
</code></pre> 
<h4><a id="1__99"></a>1. 调用函数多次</h4> 
<p>你可以根据需要调用函数任意次。</p> 
<p>要再描述一个宠物，只需再次调用describe_pet() 即可：</p> 
<pre><code class="prism language-python"><span class="token keyword">def</span> <span class="token function">describe_pet</span><span class="token punctuation">(</span>animal_type<span class="token punctuation">,</span> pet_name<span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token triple-quoted-string string">"""显示宠物的信息"""</span>
    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"\nI have a "</span> <span class="token operator">+</span> animal_type <span class="token operator">+</span> <span class="token string">"."</span><span class="token punctuation">)</span>
    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"My "</span> <span class="token operator">+</span> animal_type <span class="token operator">+</span> <span class="token string">"'s name is "</span> <span class="token operator">+</span> pet_name <span class="token operator">+</span> <span class="token string">"."</span><span class="token punctuation">)</span>
    
describe_pet<span class="token punctuation">(</span><span class="token string">'hamster'</span><span class="token punctuation">,</span> <span class="token string">'harry'</span><span class="token punctuation">)</span>
describe_pet<span class="token punctuation">(</span><span class="token string">'dog'</span><span class="token punctuation">,</span> <span class="token string">'willie'</span><span class="token punctuation">)</span>
</code></pre> 
<p>第二次调用describe_pet() 函数时，我们向它传递了实参’dog’ 和’willie’ 。</p> 
<p>与第一次调用时一样，Python将实参’dog’ 关联到形参animal_type ，并将实参’willie’ 关联到形参pet_name。</p> 
<p>与前面一样，这个函数完成其任务，但打印的是一条名为willie的小狗的信息。</p> 
<pre><code>I have a hamster.
My hamster's name is harry.

I have a dog.
My dog's name is willie.
</code></pre> 
<p>调用函数多次是一种效率极高的工作方式。</p> 
<p>我们只需在函数中编写描述宠物的代码一次，然后每当需要描述新宠物时，都可调用这个函数，并向它提供新宠物的信息。</p> 
<p>即便描述宠物的代码增加到了10行，你依然只需使用一行调用函数的代码，就可描述一个新宠物。</p> 
<p>在函数中，可根据需要使用任意数量的位置实参，Python将按顺序将函数调用中的实参关联到函数定义中相应的形参。</p> 
<h4><a id="2__131"></a>2. 位置实参的顺序很重要</h4> 
<p>使用<strong>位置实参</strong>来调用函数时，如果实参的顺序不正确，结果可能出乎意料：</p> 
<pre><code class="prism language-python"><span class="token keyword">def</span> <span class="token function">describe_pet</span><span class="token punctuation">(</span>animal_type<span class="token punctuation">,</span> pet_name<span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token triple-quoted-string string">"""显示宠物的信息"""</span>
    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"\nI have a "</span> <span class="token operator">+</span> animal_type <span class="token operator">+</span> <span class="token string">"."</span><span class="token punctuation">)</span>
    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"My "</span> <span class="token operator">+</span> animal_type <span class="token operator">+</span> <span class="token string">"'s name is "</span> <span class="token operator">+</span> pet_name <span class="token operator">+</span> <span class="token string">"."</span><span class="token punctuation">)</span>
    
describe_pet<span class="token punctuation">(</span><span class="token string">'harry'</span><span class="token punctuation">,</span> <span class="token string">'hamster'</span><span class="token punctuation">)</span>
</code></pre> 
<p>在这个函数调用中，我们先指定名字，再指定动物类型。</p> 
<p>由于实参’harry’ 在前，这个值将存储到形参animal_type 中；</p> 
<p>同理，'hamster’将存储到形参pet_name 中。</p> 
<p>结果是我们得到了一个名为hamster 的harry ：</p> 
<pre><code>I have a harry.
My harry's name is hamster.
</code></pre> 
<p>请确认好函数调用中实参的顺序与函数定义中形参的顺序一致。</p> 
<h3><a id="722__153"></a>7.2.2 关键字实参</h3> 
<p><strong>关键字实参</strong>是传递给函数的名称—值对。你直接在实参中将名称和值关联起来了，因此向函数传递实参时不会混淆（不会得到名为Hamster的harry这样的结果）。关键字实参让<br> 你无需考虑函数调用中的实参顺序，还清楚地指出了函数调用中各个值的用途。</p> 
<p>下面来重新编写pets.py，在其中使用关键字实参来调用describe_pet() ：</p> 
<pre><code class="prism language-python"><span class="token keyword">def</span> <span class="token function">describe_pet</span><span class="token punctuation">(</span>animal_type<span class="token punctuation">,</span> pet_name<span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token triple-quoted-string string">"""显示宠物的信息"""</span>
    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"\nI have a "</span> <span class="token operator">+</span> animal_type <span class="token operator">+</span> <span class="token string">"."</span><span class="token punctuation">)</span>
    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"My "</span> <span class="token operator">+</span> animal_type <span class="token operator">+</span> <span class="token string">"'s name is "</span> <span class="token operator">+</span> pet_name <span class="token operator">+</span> <span class="token string">"."</span><span class="token punctuation">)</span>
    
describe_pet<span class="token punctuation">(</span>animal_type<span class="token operator">=</span><span class="token string">'hamster'</span><span class="token punctuation">,</span> pet_name<span class="token operator">=</span><span class="token string">'harry'</span><span class="token punctuation">)</span>
</code></pre> 
<p>看到这个函数调用时，Python知道应该将实参’hamster’ 和’harry’ 分别存储在形参animal_type 和pet_name 中。</p> 
<p>输出正确无误，它指出我们有一只名为harry的仓鼠。</p> 
<p>关键字实参的顺序无关紧要，因为Python知道各个值该存储到哪个形参中。下面两个函数调用是等效的：</p> 
<pre><code class="prism language-python">describe_pet<span class="token punctuation">(</span>animal_type<span class="token operator">=</span><span class="token string">'hamster'</span><span class="token punctuation">,</span> pet_name<span class="token operator">=</span><span class="token string">'harry'</span><span class="token punctuation">)</span>
describe_pet<span class="token punctuation">(</span>pet_name<span class="token operator">=</span><span class="token string">'harry'</span><span class="token punctuation">,</span> animal_type<span class="token operator">=</span><span class="token string">'hamster'</span><span class="token punctuation">)</span>
</code></pre> 
<p><strong>注意</strong>使用关键字实参时，务必准确地指定函数定义中的形参名。</p> 
<h3><a id="723__176"></a>7.2.3 默认值</h3> 
<p>编写函数时，可给每个形参指定默认值 。</p> 
<p>在调用函数中给形参提供了实参时，Python将使用指定的实参值；否则，将使用形参的默认值。</p> 
<p>因此，给形参指定默认值后，可在函数调用中省略相应的实参。</p> 
<p>使用默认值可简化函数调用，还可清楚地指出函数的典型用法。</p> 
<p>例如，如果你发现调用describe_pet() 时，描述的大都是小狗，就可将形参animal_type 的默认值设置为’dog’ 。</p> 
<p>这样，调用describe_pet() 来描述小狗时，就可不提供这种信息：</p> 
<pre><code class="prism language-python"><span class="token keyword">def</span> <span class="token function">describe_pet</span><span class="token punctuation">(</span>pet_name<span class="token punctuation">,</span> animal_type<span class="token operator">=</span><span class="token string">'dog'</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token triple-quoted-string string">"""显示宠物的信息"""</span>
    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"\nI have a "</span> <span class="token operator">+</span> animal_type <span class="token operator">+</span> <span class="token string">"."</span><span class="token punctuation">)</span>
    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"My "</span> <span class="token operator">+</span> animal_type <span class="token operator">+</span> <span class="token string">"'s name is "</span> <span class="token operator">+</span> pet_name <span class="token operator">+</span> <span class="token string">"."</span><span class="token punctuation">)</span>
    
describe_pet<span class="token punctuation">(</span>pet_name<span class="token operator">=</span><span class="token string">'willie'</span><span class="token punctuation">)</span>
</code></pre> 
<p>这里修改了函数describe_pet() 的定义，在其中给形参animal_type 指定了默认值’dog’。</p> 
<p>这样，调用这个函数时，如果没有给animal_type 指定值，Python将把这个形参设置为’dog’</p> 
<pre><code>I have a dog.
My dog's name is willie.
</code></pre> 
<p>请注意，在这个函数的定义中，修改了形参的排列顺序。</p> 
<p>由于给animal_type 指定了默认值，无需通过实参来指定动物类型，因此在函数调用中只包含一个实参——宠物的名 字。</p> 
<p>然而，Python依然将这个实参视为位置实参，因此如果函数调用中只包含宠物的名字，这个实参将关联到函数定义中的第一个形参。</p> 
<p>这就是需要将pet_name 放在形参列表开头的原因所在。</p> 
<p>现在，使用这个函数的最简单的方式是，在函数调用中只提供小狗的名字：</p> 
<pre><code class="prism language-python">describe_pet<span class="token punctuation">(</span><span class="token string">'willie'</span><span class="token punctuation">)</span>
</code></pre> 
<p>这个函数调用的输出与前一个示例相同。只提供了一个实参——‘willie’ ，这个实参将关联到函数定义中的第一个形参——pet_name，因此Python使用其默认值’dog’。</p> 
<p>如果要描述的动物不是小狗，可使用类似于下面的函数调用：</p> 
<pre><code class="prism language-python">describe_pet<span class="token punctuation">(</span>pet_name<span class="token operator">=</span><span class="token string">'harry'</span><span class="token punctuation">,</span> animal_type<span class="token operator">=</span><span class="token string">'hamster'</span><span class="token punctuation">)</span>
</code></pre> 
<p>由于显式地给animal_type 提供了实参，因此Python将忽略这个形参的默认值。</p> 
<h3><a id="724__223"></a>7.2.4 等效的函数调用</h3> 
<p>鉴于可混合使用位置实参、关键字实参和默认值，通常有多种等效的函数调用方式。</p> 
<p>请看下面的函数describe_pets() 的定义，其中给一个形参提供了默认值：</p> 
<pre><code class="prism language-python"><span class="token keyword">def</span> <span class="token function">describe_pet</span><span class="token punctuation">(</span>pet_name<span class="token punctuation">,</span> animal_type<span class="token operator">=</span><span class="token string">'dog'</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
</code></pre> 
<p>基于这种定义，在任何情况下都必须给pet_name 提供实参；指定该实参时可以使用位置方式，也可以使用关键字方式。</p> 
<p>如果要描述的动物不是小狗，还必须在函数调用中给animal_type 提供实参；</p> 
<p>同样，指定该实参时可以使用位置方式，也可以使用关键字方式。</p> 
<p>下面对这个函数的所有调用都可行：</p> 
<pre><code class="prism language-python"><span class="token comment"># 一条名为Willie的小狗</span>
describe_pet<span class="token punctuation">(</span><span class="token string">'willie'</span><span class="token punctuation">)</span>
describe_pet<span class="token punctuation">(</span>pet_name<span class="token operator">=</span><span class="token string">'willie'</span><span class="token punctuation">)</span>
<span class="token comment"># 一只名为Harry的仓鼠</span>
describe_pet<span class="token punctuation">(</span><span class="token string">'harry'</span><span class="token punctuation">,</span> <span class="token string">'hamster'</span><span class="token punctuation">)</span>
describe_pet<span class="token punctuation">(</span>pet_name<span class="token operator">=</span><span class="token string">'harry'</span><span class="token punctuation">,</span> animal_type<span class="token operator">=</span><span class="token string">'hamster'</span><span class="token punctuation">)</span>
describe_pet<span class="token punctuation">(</span>animal_type<span class="token operator">=</span><span class="token string">'hamster'</span><span class="token punctuation">,</span> pet_name<span class="token operator">=</span><span class="token string">'harry'</span><span class="token punctuation">)</span>
</code></pre> 
<p>这些函数调用的输出与前面的示例相同。<br> <strong>注意</strong>使用哪种调用方式无关紧要，只要函数调用能生成你希望的输出就行。使用对你来说最容易理解的调用方式即可。</p> 
<h3><a id="725__248"></a>7.2.5 避免实参错误</h3> 
<p>等你开始使用函数后，如果遇到实参不匹配错误，不要大惊小怪。</p> 
<p>你提供的实参多于或少于函数完成其工作所需的信息时，将出现实参不匹配错误。</p> 
<p>例如，如果调用函数describe_pet() 时没有指定任何实参，结果将如何呢？</p> 
<pre><code class="prism language-python"><span class="token keyword">def</span> <span class="token function">describe_pet</span><span class="token punctuation">(</span>animal_type<span class="token punctuation">,</span> pet_name<span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token triple-quoted-string string">"""显示宠物的信息"""</span>
    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"\nI have a "</span> <span class="token operator">+</span> animal_type <span class="token operator">+</span> <span class="token string">"."</span><span class="token punctuation">)</span>
    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"My "</span> <span class="token operator">+</span> animal_type <span class="token operator">+</span> <span class="token string">"'s name is "</span> <span class="token operator">+</span> pet_name <span class="token operator">+</span> <span class="token string">"."</span><span class="token punctuation">)</span>
describe_pet<span class="token punctuation">(</span><span class="token punctuation">)</span>
</code></pre> 
<p>Python发现该函数调用缺少必要的信息，而报错指出了这一点：</p> 
<pre><code>raceback (most recent call last): 
❶ File "pets.py", line 6, in &lt;module&gt; 
❷ describe_pet() 
❸ TypeError: describe_pet() missing 2 required positional arguments: 'animal_type' and 'pet_name'
</code></pre> 
<p>在❶处，traceback指出了问题出在什么地方，让我们能够回过头去找出函数调用中的错误。</p> 
<p>在❷处，指出了导致问题的函数调用。</p> 
<p>在❸处，traceback指出该函数调用少两个实参，并指出了相应形参的名称。</p> 
<p>如果这个函数存储在一个独立的文件中，我们也许无需打开这个文件并查看函数的代码，就能重新正确地编写函数调用。</p> 
<p>Python读取函数的代码，并指出我们需要为哪些形参提供实参，这提供了极大的帮助。</p> 
<p>这也是应该给变量和函数指定描述性名称的另一个原因；</p> 
<p>如果你这样做了，那么无论对于你，还是可能使用你编写的代码的其他任何人来说，Python提供的错误消息都将更有帮助。</p> 
<p>如果提供的实参太多，将出现类似的报错，帮助你确保函数调用和函数定义匹配。</p> 
<h2><a id="73__283"></a>7.3 返回值</h2> 
<p>函数并非总是直接显示输出，相反，它可以处理一些数据，并返回一个或一组值。</p> 
<p>函数返回的值被称为返回值 。</p> 
<p>在函数中，可使用return 语句将值返回到调用函数的代码行。</p> 
<p>返回值让你能够将程序的大部分繁重工作移到函数中去完成，从而简化主程序。</p> 
<h3><a id="731__291"></a>7.3.1 返回简单值</h3> 
<p>下面来看一个函数，它接受名和姓并返回整洁的姓名：</p> 
<pre><code class="prism language-python"><span class="token keyword">def</span> <span class="token function">get_formatted_name</span><span class="token punctuation">(</span>first_name<span class="token punctuation">,</span> last_name<span class="token punctuation">)</span><span class="token punctuation">:</span> <span class="token comment"># ❶ </span>
    <span class="token triple-quoted-string string">"""返回整洁的姓名"""</span> 
    full_name <span class="token operator">=</span> first_name <span class="token operator">+</span> <span class="token string">' '</span> <span class="token operator">+</span> last_name <span class="token comment"># ❷ </span>
    <span class="token keyword">return</span> full_name<span class="token punctuation">.</span>title<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment"># ❸ </span>
musician <span class="token operator">=</span> get_formatted_name<span class="token punctuation">(</span><span class="token string">'jimi'</span><span class="token punctuation">,</span> <span class="token string">'hendrix'</span><span class="token punctuation">)</span> <span class="token comment"># ❹ </span>
<span class="token keyword">print</span><span class="token punctuation">(</span>musician<span class="token punctuation">)</span>
</code></pre> 
<p>函数get_formatted_name() 的定义通过形参接受名和姓（见❶）。</p> 
<p>它将姓和名合而为一，在它们之间加上一个空格，并将结果存储在变量full_name 中（见❷）。</p> 
<p>然后，将full_name 的值转换为首字母大写格式，并将结果返回到函数调用行（见❸）。</p> 
<p>调用返回值的函数时，需要提供一个变量，用于存储返回的值。</p> 
<p>在这里，将返回值存储在了变量musician 中（见❹）。输出为整洁的姓名：</p> 
<pre><code>Jimi Hendrix
</code></pre> 
<p>我们原本只需编写下面的代码就可输出整洁的姓名，相比于此，前面做的工作好像太多了：</p> 
<pre><code class="prism language-python"><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"Jimi Hendrix"</span><span class="token punctuation">)</span>
</code></pre> 
<p>但在服务器中需要分别存储大量名和姓的大型程序中，像这样的函数非常有用。</p> 
<p>你分别存储名和姓，每当需要显示姓名时都调用这个函数。</p> 
<h3><a id="732__320"></a>7.3.2 让实参变成可选的</h3> 
<p>有时候，需要让实参变成可选的，这样使用函数的人就只需在必要时才提供额外的信息。可使用默认值来让实参变成可选的。</p> 
<p>例如，假设我们要扩展函数get_formatted_name() ，使其还处理中间名。为此，可将其修改成类似于下面这样：</p> 
<pre><code class="prism language-python"><span class="token keyword">def</span> <span class="token function">get_formatted_name</span><span class="token punctuation">(</span>first_name<span class="token punctuation">,</span> middle_name<span class="token punctuation">,</span> last_name<span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token triple-quoted-string string">"""返回整洁的姓名"""</span>
    full_name <span class="token operator">=</span> first_name <span class="token operator">+</span> <span class="token string">' '</span> <span class="token operator">+</span> middle_name <span class="token operator">+</span> <span class="token string">' '</span> <span class="token operator">+</span> last_name
    <span class="token keyword">return</span> full_name<span class="token punctuation">.</span>title<span class="token punctuation">(</span><span class="token punctuation">)</span>
    
musician <span class="token operator">=</span> get_formatted_name<span class="token punctuation">(</span><span class="token string">'john'</span><span class="token punctuation">,</span> <span class="token string">'lee'</span><span class="token punctuation">,</span> <span class="token string">'hooker'</span><span class="token punctuation">)</span>
<span class="token keyword">print</span><span class="token punctuation">(</span>musician<span class="token punctuation">)</span>
</code></pre> 
<p>只要同时提供名、中间名和姓，这个函数就能正确地运行。它根据这三部分创建一个字符串，在适当的地方加上空格，并将结果转换为首字母大写格式：</p> 
<pre><code>John Lee Hooker
</code></pre> 
<p>然而，并非所有的人都有中间名，但如果你调用这个函数时只提供了名和姓，它将不能正确地运行。</p> 
<p>为让中间名变成可选的，可给实参middle_name 指定一个默认值——空字符串，并在用户没有提供中间名时不使用这个实参。</p> 
<p>为让get_formatted_name()在没有提供中间名时依然可行，可给实参middle_name 指定一个默认值——空字符串，并将其移到形参列表的末尾：</p> 
<pre><code class="prism language-python"><span class="token keyword">def</span> <span class="token function">get_formatted_name</span><span class="token punctuation">(</span>first_name<span class="token punctuation">,</span> last_name<span class="token punctuation">,</span> middle_name<span class="token operator">=</span><span class="token string">''</span><span class="token punctuation">)</span><span class="token punctuation">:</span> <span class="token comment"># ❶ </span>
    <span class="token triple-quoted-string string">"""返回整洁的姓名"""</span> 
    <span class="token keyword">if</span> middle_name<span class="token punctuation">:</span> <span class="token comment"># ❷ </span>
        full_name <span class="token operator">=</span> first_name <span class="token operator">+</span> <span class="token string">' '</span> <span class="token operator">+</span> middle_name <span class="token operator">+</span> <span class="token string">' '</span> <span class="token operator">+</span> last_name
    <span class="token keyword">else</span><span class="token punctuation">:</span><span class="token comment"># ❸ </span>
        full_name <span class="token operator">=</span> first_name <span class="token operator">+</span> <span class="token string">' '</span> <span class="token operator">+</span> last_name
    <span class="token keyword">return</span> full_name<span class="token punctuation">.</span>title<span class="token punctuation">(</span><span class="token punctuation">)</span>

musician <span class="token operator">=</span> get_formatted_name<span class="token punctuation">(</span><span class="token string">'jimi'</span><span class="token punctuation">,</span> <span class="token string">'hendrix'</span><span class="token punctuation">)</span>
<span class="token keyword">print</span><span class="token punctuation">(</span>musician<span class="token punctuation">)</span>
musician <span class="token operator">=</span> get_formatted_name<span class="token punctuation">(</span><span class="token string">'john'</span><span class="token punctuation">,</span> <span class="token string">'hooker'</span><span class="token punctuation">,</span> <span class="token string">'lee'</span><span class="token punctuation">)</span> <span class="token comment"># ❹ </span>
<span class="token keyword">print</span><span class="token punctuation">(</span>musician<span class="token punctuation">)</span>
</code></pre> 
<p>在这个示例中，姓名是根据三个可能提供的部分创建的。</p> 
<p>由于人都有名和姓，因此在函数定义中首先列出了这两个形参。</p> 
<p>中间名是可选的，因此在函数定义中最后列出该形参，并将其默认值设置为空字符串（见❶）。</p> 
<p>在函数体中，我们检查是否提供了中间名。Python将非空字符串解读为True ，因此如果函数调用中提供了中间名，if middle_name 将为True （见❷）。</p> 
<p>如果提供了中间名，就将名、中间名和姓合并为姓名，然后将其修改为首字母大写格式，并返回到函数调用行。</p> 
<p>在函数调用行，将返回的值存储在变量musician 中；然后将这个变量的值打印出来。</p> 
<p>如果没有提供中间名，middle_name 将为空字符串，导致if 测试未通过，进而执行else 代码块（见❸）：只使用名和姓来生成姓名，并将设置好格式的姓名返回给函数调用行。</p> 
<p>在函数调用行，将返回的值存储在变量musician 中；然后将这个变量的值打印出来。</p> 
<p>调用这个函数时，如果只想指定名和姓，调用起来将非常简单。如果还要指定中间名，就必须确保它是最后一个实参，这样Python才能正确地将位置实参关联到形参（见❹）。</p> 
<p>这个修改后的版本适用于只有名和姓的人，也适用于还有中间名的人：</p> 
<pre><code>Jimi Hendrix
John Lee Hooker
</code></pre> 
<p>可选值让函数能够处理各种不同情形的同时，确保函数调用尽可能简单。</p> 
<h3><a id="733__380"></a>7.3.3 返回字典</h3> 
<p>函数可返回任何类型的值，包括列表和字典等较复杂的数据结构。</p> 
<p>例如，下面的函数接受姓名的组成部分，并返回一个表示人的字典：</p> 
<pre><code class="prism language-python"><span class="token keyword">def</span> <span class="token function">build_person</span><span class="token punctuation">(</span>first_name<span class="token punctuation">,</span> last_name<span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token triple-quoted-string string">"""返回一个字典，其中包含有关一个人的信息"""</span> 
    person <span class="token operator">=</span> <span class="token punctuation">{<!-- --></span><span class="token string">'first'</span><span class="token punctuation">:</span> first_name<span class="token punctuation">,</span> <span class="token string">'last'</span><span class="token punctuation">:</span> last_name<span class="token punctuation">}</span> <span class="token comment"># ❶ </span>
    <span class="token keyword">return</span> person<span class="token comment"># ❷ </span>

musician <span class="token operator">=</span> build_person<span class="token punctuation">(</span><span class="token string">'jimi'</span><span class="token punctuation">,</span> <span class="token string">'hendrix'</span><span class="token punctuation">)</span> 
<span class="token keyword">print</span><span class="token punctuation">(</span>musician<span class="token punctuation">)</span> <span class="token comment"># ❸ </span>
</code></pre> 
<p>函数build_person() 接受名和姓，并将这些值封装到字典中（见❶）。</p> 
<p>存储first_name 的值时，使用的键为’first’ ，而存储last_name 的值时，使用的键为’last’ 。</p> 
<p>最后，返回表示人的整个字典（见❷）。</p> 
<p>在❸处，打印这个返回的值，此时原来的两项文本信息存储在一个字典中：</p> 
<pre><code>{'first': 'jimi', 'last': 'hendrix'}
</code></pre> 
<p>这个函数接受简单的文本信息，将其放在一个更合适的数据结构中，让你不仅能打印这些信息，还能以其他方式处理它们。</p> 
<p>当前，字符串’jimi’ 和’hendrix’ 被标记为名和姓。</p> 
<p>你可以轻松地扩展这个函数，使其接受可选值，如中间名、年龄、职业或你要存储的其他任何信息。</p> 
<p>例如，下面的修改让你还能存储年龄：</p> 
<pre><code class="prism language-python"><span class="token keyword">def</span> <span class="token function">build_person</span><span class="token punctuation">(</span>first_name<span class="token punctuation">,</span> last_name<span class="token punctuation">,</span> age<span class="token operator">=</span><span class="token string">''</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token triple-quoted-string string">"""返回一个字典，其中包含有关一个人的信息"""</span>
    person <span class="token operator">=</span> <span class="token punctuation">{<!-- --></span><span class="token string">'first'</span><span class="token punctuation">:</span> first_name<span class="token punctuation">,</span> <span class="token string">'last'</span><span class="token punctuation">:</span> last_name<span class="token punctuation">}</span>
    <span class="token keyword">if</span> age<span class="token punctuation">:</span>
        person<span class="token punctuation">[</span><span class="token string">'age'</span><span class="token punctuation">]</span> <span class="token operator">=</span> age
    <span class="token keyword">return</span> person

musician <span class="token operator">=</span> build_person<span class="token punctuation">(</span><span class="token string">'jimi'</span><span class="token punctuation">,</span> <span class="token string">'hendrix'</span><span class="token punctuation">,</span> age<span class="token operator">=</span><span class="token number">27</span><span class="token punctuation">)</span>
<span class="token keyword">print</span><span class="token punctuation">(</span>musician<span class="token punctuation">)</span>
</code></pre> 
<p>在函数定义中，我们新增了一个可选形参age ，并将其默认值设置为空字符串。</p> 
<p>如果函数调用中包含这个形参的值，这个值将存储到字典中。</p> 
<p>在任何情况下，这个函数都会存储人的姓名，但可对其进行修改，使其也存储有关人的其他信息。</p> 
<h3><a id="734_while__426"></a>7.3.4 结合使用函数和while 循环</h3> 
<p>可将函数同本书前面介绍的任何Python结构结合起来使用。</p> 
<p>例如，下面将结合使用函数get_formatted_name()和while 循环，以更正规的方式问候用户。</p> 
<p>下面尝试使用名和姓跟用户打招呼：</p> 
<pre><code class="prism language-python"><span class="token keyword">def</span> <span class="token function">get_formatted_name</span><span class="token punctuation">(</span>first_name<span class="token punctuation">,</span> last_name<span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token triple-quoted-string string">"""返回整洁的姓名"""</span>
    full_name <span class="token operator">=</span> first_name <span class="token operator">+</span> <span class="token string">' '</span> <span class="token operator">+</span> last_name
    <span class="token keyword">return</span> full_name<span class="token punctuation">.</span>title<span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token comment"># 这是一个无限循环!</span>
<span class="token keyword">while</span> <span class="token boolean">True</span><span class="token punctuation">:</span> 
    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"\nPlease tell me your name:"</span><span class="token punctuation">)</span> <span class="token comment"># ❶ </span>
    f_name <span class="token operator">=</span> <span class="token builtin">input</span><span class="token punctuation">(</span><span class="token string">"First name: "</span><span class="token punctuation">)</span>
    l_name <span class="token operator">=</span> <span class="token builtin">input</span><span class="token punctuation">(</span><span class="token string">"Last name: "</span><span class="token punctuation">)</span>
    formatted_name <span class="token operator">=</span> get_formatted_name<span class="token punctuation">(</span>f_name<span class="token punctuation">,</span> l_name<span class="token punctuation">)</span>
    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"\nHello, "</span> <span class="token operator">+</span> formatted_name <span class="token operator">+</span> <span class="token string">"!"</span><span class="token punctuation">)</span>
</code></pre> 
<p>在这个示例中，我们使用的是get_formatted_name() 的简单版本，不涉及中间名。</p> 
<p>其中的while 循环让用户输入姓名：依次提示用户输入名和姓（见❶）。</p> 
<p>但这个while 循环存在一个问题：没有定义退出条件。请用户提供一系列输入时，该在什么地方提供退出条件呢？我们要让用户能够尽可能容易地退出，因此每次提示用户输入时，都应提供退出途径。</p> 
<p>每次提示用户输入时，都使用break 语句提供了退出循环的简单途径：</p> 
<pre><code class="prism language-python"><span class="token keyword">def</span> <span class="token function">get_formatted_name</span><span class="token punctuation">(</span>first_name<span class="token punctuation">,</span> last_name<span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token triple-quoted-string string">"""返回整洁的姓名"""</span>
    full_name <span class="token operator">=</span> first_name <span class="token operator">+</span> <span class="token string">' '</span> <span class="token operator">+</span> last_name
    <span class="token keyword">return</span> full_name<span class="token punctuation">.</span>title<span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token keyword">while</span> <span class="token boolean">True</span><span class="token punctuation">:</span>
        <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"\nPlease tell me your name:"</span><span class="token punctuation">)</span>
        <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"(enter 'q' at any time to quit)"</span><span class="token punctuation">)</span>
        f_name <span class="token operator">=</span> <span class="token builtin">input</span><span class="token punctuation">(</span><span class="token string">"First name: "</span><span class="token punctuation">)</span>
        <span class="token keyword">if</span> f_name <span class="token operator">==</span> <span class="token string">'q'</span><span class="token punctuation">:</span>
            <span class="token keyword">break</span>
        l_name <span class="token operator">=</span> <span class="token builtin">input</span><span class="token punctuation">(</span><span class="token string">"Last name: "</span><span class="token punctuation">)</span>
        <span class="token keyword">if</span> l_name <span class="token operator">==</span> <span class="token string">'q'</span><span class="token punctuation">:</span>
            <span class="token keyword">break</span>
        formatted_name <span class="token operator">=</span> get_formatted_name<span class="token punctuation">(</span>f_name<span class="token punctuation">,</span> l_name<span class="token punctuation">)</span>
        <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"\nHello, "</span> <span class="token operator">+</span> formatted_name <span class="token operator">+</span> <span class="token string">"!"</span><span class="token punctuation">)</span>
</code></pre> 
<p>我们添加了一条消息来告诉用户如何退出，然后在每次提示用户输入时，都检查他输入的是否是退出值，如果是，就退出循环。现在，这个程序将不断地问候，直到用户输入的姓或名为’q’ 为止：</p> 
<pre><code>Please tell me your name:
(enter 'q' at any time to quit)
First name: eric
Last name: matthes
Hello, Eric Matthes!
Please tell me your name:
(enter 'q' at any time to quit)
First name: q
</code></pre> 
<h2><a id="74__480"></a>7.4 传递列表</h2> 
<p>你经常会发现，向函数传递列表很有用，这种列表包含的可能是名字、数字或更复杂的对象（如字典）。将列表传递给函数后，函数就能直接访问其内容。</p> 
<p>下面使用函数来提高处理列表的效率。</p> 
<p>假设有一个用户列表，我们要问候其中的每位用户。</p> 
<p>下面的示例将一个名字列表传递给一个名为greet_users() 的函数，这个函数问候列表中的每个人：</p> 
<pre><code class="prism language-python"><span class="token keyword">def</span> <span class="token function">greet_users</span><span class="token punctuation">(</span>names<span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token triple-quoted-string string">"""向列表中的每位用户都发出简单的问候"""</span>
    <span class="token keyword">for</span> name <span class="token keyword">in</span> names<span class="token punctuation">:</span>
        msg <span class="token operator">=</span> <span class="token string">"Hello, "</span> <span class="token operator">+</span> name<span class="token punctuation">.</span>title<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">"!"</span>
        <span class="token keyword">print</span><span class="token punctuation">(</span>msg<span class="token punctuation">)</span>
usernames <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">'hannah'</span><span class="token punctuation">,</span> <span class="token string">'ty'</span><span class="token punctuation">,</span> <span class="token string">'margot'</span><span class="token punctuation">]</span> <span class="token comment"># ❶ </span>

greet_users<span class="token punctuation">(</span>usernames<span class="token punctuation">)</span>
</code></pre> 
<p>我们将greet_users() 定义成接受一个名字列表，并将其存储在形参names 中。</p> 
<p>这个函数遍历收到的列表，并对其中的每位用户都打印一条问候语。</p> 
<p>在❶处，我们定义了一个用户列表——usernames ，然后调用greet_users() ，并将这个列表传递给它：</p> 
<pre><code>Hello, Hannah!
Hello, Ty!
Hello, Margot!
</code></pre> 
<p>输出完全符合预期，每位用户都看到了一条个性化的问候语。每当你要问候一组用户时，都可调用这个函数。</p> 
<h3><a id="741__509"></a>7.4.1 在函数中修改列表</h3> 
<p>将列表传递给函数后，函数就可对其进行修改。</p> 
<p>在函数中对这个列表所做的任何修改都是永久性的，这让你能够高效地处理大量的数据。</p> 
<p>来看一家为用户提交的设计制作3D打印模型的公司。需要打印的设计存储在一个列表中，打印后移到另一个列表中。</p> 
<p>下面是在不使用函数的情况下模拟这个过程的代码：</p> 
<pre><code class="prism language-python"><span class="token comment"># 首先创建一个列表，其中包含一些要打印的设计</span>
unprinted_designs <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">'iphone case'</span><span class="token punctuation">,</span> <span class="token string">'robot pendant'</span><span class="token punctuation">,</span> <span class="token string">'dodecahedron'</span><span class="token punctuation">]</span>
completed_models <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>

<span class="token comment"># 模拟打印每个设计，直到没有未打印的设计为止</span>
<span class="token comment"># 打印每个设计后，都将其移到列表completed_models中</span>
<span class="token keyword">while</span> unprinted_designs<span class="token punctuation">:</span>
    current_design <span class="token operator">=</span> unprinted_designs<span class="token punctuation">.</span>pop<span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token comment">#模拟根据设计制作3D打印模型的过程</span>
    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"Printing model: "</span> <span class="token operator">+</span> current_design<span class="token punctuation">)</span>
    completed_models<span class="token punctuation">.</span>append<span class="token punctuation">(</span>current_design<span class="token punctuation">)</span>
    <span class="token comment"># 显示打印好的所有模型</span>
    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"\nThe following models have been printed:"</span><span class="token punctuation">)</span>
    
<span class="token keyword">for</span> completed_model <span class="token keyword">in</span> completed_models<span class="token punctuation">:</span>
    <span class="token keyword">print</span><span class="token punctuation">(</span>completed_model<span class="token punctuation">)</span>
</code></pre> 
<p>这个程序首先创建一个需要打印的设计列表，还创建一个名为completed_models 的空列表，每个设计打印都将移到这个列表中。</p> 
<p>只要列表unprinted_designs 中还有设<br> 计，while 循环就模拟打印设计的过程：从该列表末尾删除一个设计，将其存储到变量current_design 中，并显示一条消息，指出正在打印当前的设计，再将该设计加入到列表completed_models 中。</p> 
<p>循环结束后，显示已打印的所有设计：</p> 
<pre><code>Printing model: dodecahedron
Printing model: robot pendant
Printing model: iphone case
The following models have been printed:
dodecahedron
robot pendant
iphone case
</code></pre> 
<p>为重新组织这些代码，我们可编写两个函数，每个都做一件具体的工作。</p> 
<p>大部分代码都与原来相同，只是效率更高。</p> 
<p>第一个函数将负责处理打印设计的工作，而第二个将概述打印了哪些设计：</p> 
<pre><code class="prism language-python"><span class="token keyword">def</span> <span class="token function">print_models</span><span class="token punctuation">(</span>unprinted_designs<span class="token punctuation">,</span> completed_models<span class="token punctuation">)</span><span class="token punctuation">:</span> <span class="token comment"># ❶ </span>
    <span class="token triple-quoted-string string">""" 模拟打印每个设计，直到没有未打印的设计为止
    打印每个设计后，都将其移到列表completed_models中
    """</span>
    <span class="token keyword">while</span> unprinted_designs<span class="token punctuation">:</span>
    current_design <span class="token operator">=</span> unprinted_designs<span class="token punctuation">.</span>pop<span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token comment"># 模拟根据设计制作3D打印模型的过程</span>
    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"Printing model: "</span> <span class="token operator">+</span> current_design<span class="token punctuation">)</span>
    completed_models<span class="token punctuation">.</span>append<span class="token punctuation">(</span>current_design<span class="token punctuation">)</span>

<span class="token keyword">def</span> <span class="token function">show_completed_models</span><span class="token punctuation">(</span>completed_models<span class="token punctuation">)</span><span class="token punctuation">:</span> <span class="token comment"># ❷ </span>
    <span class="token triple-quoted-string string">"""显示打印好的所有模型"""</span>
    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"\nThe following models have been printed:"</span><span class="token punctuation">)</span>
    <span class="token keyword">for</span> completed_model <span class="token keyword">in</span> completed_models<span class="token punctuation">:</span>
    <span class="token keyword">print</span><span class="token punctuation">(</span>completed_model<span class="token punctuation">)</span>
    
unprinted_designs <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">'iphone case'</span><span class="token punctuation">,</span> <span class="token string">'robot pendant'</span><span class="token punctuation">,</span> <span class="token string">'dodecahedron'</span><span class="token punctuation">]</span>
completed_models <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>

print_models<span class="token punctuation">(</span>unprinted_designs<span class="token punctuation">,</span> completed_models<span class="token punctuation">)</span>
show_completed_models<span class="token punctuation">(</span>completed_models<span class="token punctuation">)</span>
</code></pre> 
<p>在❶处，我们定义了函数print_models() ，它包含两个形参：一个需要打印的设计列表和一个打印好的模型列表。</p> 
<p>给定这两个列表，这个函数模拟打印每个设计的过程：将设计逐个地从未打印的设计列表中取出，并加入到打印好的模型列表中。</p> 
<p>在❷处，我们定义了函数show_completed_models() ，它包含一个形参：打印好的模型列表。</p> 
<p>给定这个列表，函数show_completed_models() 显示打印出来的每个模型的名称。</p> 
<p>这个程序的输出与未使用函数的版本相同，但组织更为有序。</p> 
<p>完成大部分工作的代码都移到了两个函数中，让主程序更容易理解。只要看看主程序，你就知道这个程序的功能容易看清得多：</p> 
<pre><code>unprinted_designs = ['iphone case', 'robot pendant', 'dodecahedron']
completed_models = []

print_models(unprinted_designs, completed_models)
show_completed_models(completed_models)
</code></pre> 
<p>我们创建了一个未打印的设计列表，还创建了一个空列表，用于存储打印好的模型。</p> 
<p>接下来，由于我们已经定义了两个函数，因此只需调用它们并传入正确的实参即可。我们调用print_models()并向它传递两个列表；像预期的一样，print_models() 模拟打印设计的过程。</p> 
<p>接下来，我们调用show_completed_models() ，并将打印好的模型列表传递给它，让其能够指出打印了哪些模型。</p> 
<p>描述性的函数名让别人阅读这些代码时也能明白，虽然其中没有任何注释。</p> 
<p>相比于没有使用函数的版本，这个程序更容易扩展和维护。</p> 
<p>如果以后需要打印其他设计，只需再次调用print_models() 即可。</p> 
<p>如果我们发现需要对打印代码进行修改，只需修改这些代码一次，就能影响所有调用该函数的地方；与必须分别修改程序的多个地方相比，这种修改的效率更高。</p> 
<p>这个程序还演示了这样一种理念，即每个函数都应只负责一项具体的工作。</p> 
<p>第一个函数打印每个设计，而第二个显示打印好的模型；这优于使用一个函数来完成两项工作。</p> 
<p>编写函数时，如果你发现它执行的任务太多，请尝试将这些代码划分到两个函数中。</p> 
<p>别忘了，总是可以在一个函数中调用另一个函数，这有助于将复杂的任务划分成一系列的步骤。</p> 
<h3><a id="742__617"></a>7.4.2 禁止函数修改列表</h3> 
<p>有时候，需要禁止函数修改列表。</p> 
<p>例如，假设像前一个示例那样，你有一个未打印的设计列表，并编写了一个将这些设计移到打印好的模型列表中的函数。</p> 
<p>你可能会做出这样的决定：即便打印所有设计后，也要保留原来的未打印的设计列表，以供备案。</p> 
<p>但由于你将所有的设计都移出了unprinted_designs ，这个列表变成了空的，原来的列表没有了。</p> 
<p>为解决这个问题，可向函数传递列表的副本而不是原件；这样函数所做的任何修改都只影响副本，而丝毫不影响原件。</p> 
<p>要将列表的副本传递给函数，可以像下面这样做：</p> 
<pre><code class="prism language-python">function_name<span class="token punctuation">(</span>list_name<span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
</code></pre> 
<p>切片表示法[:] 创建列表的副本。</p> 
<p>在print_models.py中，如果不想清空未打印的设计列表，可像下面这样调用print_models() ：</p> 
<pre><code class="prism language-python">print_models<span class="token punctuation">(</span>unprinted_designs<span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token punctuation">]</span><span class="token punctuation">,</span> completed_models<span class="token punctuation">)</span>
</code></pre> 
<p>这样函数print_models() 依然能够完成其工作，因为它获得了所有未打印的设计的名称，但它使用的是列表unprinted_designs 的副本，而不是列表unprinted_designs 本身。</p> 
<p>像以前一样，列表completed_models 也将包含打印好的模型的名称，但函数所做的修改不会影响到列表unprinted_designs。</p> 
<p>虽然向函数传递列表的副本可保留原始列表的内容，但除非有充分的理由需要传递副本，否则还是应该将原始列表传递给函数，因为让函数使用现成列表可避免花时间和内存创建副本，从而提高效率，在处理大型列表时尤其如此。</p> 
<h2><a id="75__643"></a>7.5 传递任意数量的实参</h2> 
<p>有时候，你预先不知道函数需要接受多少个实参，好在Python允许函数从调用语句中收集任意数量的实参。</p> 
<p>例如，来看一个制作比萨的函数，它需要接受很多配料，但你无法预先确定顾客要多少种配料。</p> 
<p>下面的函数只有一个形参*toppings ，但不管调用语句提供了多少实参，这个形参都将它们统统收入囊中：</p> 
<pre><code class="prism language-python"><span class="token keyword">def</span> <span class="token function">make_pizza</span><span class="token punctuation">(</span><span class="token operator">*</span>toppings<span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token triple-quoted-string string">"""打印顾客点的所有配料"""</span>
    <span class="token keyword">print</span><span class="token punctuation">(</span>toppings<span class="token punctuation">)</span>
    
make_pizza<span class="token punctuation">(</span><span class="token string">'pepperoni'</span><span class="token punctuation">)</span>
make_pizza<span class="token punctuation">(</span><span class="token string">'mushrooms'</span><span class="token punctuation">,</span> <span class="token string">'green peppers'</span><span class="token punctuation">,</span> <span class="token string">'extra cheese'</span><span class="token punctuation">)</span>
</code></pre> 
<p>形参名*toppings 中的星号让Python创建一个名为toppings 的空元组，并将收到的所有值都封装到这个元组中。</p> 
<p>函数体内的print 语句通过生成输出来证明Python能够处理使用一个值调用函数的情形，也能处理使用三个值来调用函数的情形。</p> 
<p>它以类似的方式处理不同的调用，注意，Python将实参封装到一个元组中，即便函数只收到一个值也如此：</p> 
<pre><code>('pepperoni',)
('mushrooms', 'green peppers', 'extra cheese')
</code></pre> 
<p>现在，我们可以将这条print 语句替换为一个循环，对配料列表进行遍历，并对顾客点的比萨进行描述：</p> 
<pre><code class="prism language-python"><span class="token keyword">def</span> <span class="token function">make_pizza</span><span class="token punctuation">(</span><span class="token operator">*</span>toppings<span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token triple-quoted-string string">"""概述要制作的比萨"""</span>
    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"\nMaking a pizza with the following toppings:"</span><span class="token punctuation">)</span>
    <span class="token keyword">for</span> topping <span class="token keyword">in</span> toppings<span class="token punctuation">:</span>
        <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"- "</span> <span class="token operator">+</span> topping<span class="token punctuation">)</span>
    
make_pizza<span class="token punctuation">(</span><span class="token string">'pepperoni'</span><span class="token punctuation">)</span>
make_pizza<span class="token punctuation">(</span><span class="token string">'mushrooms'</span><span class="token punctuation">,</span> <span class="token string">'green peppers'</span><span class="token punctuation">,</span> <span class="token string">'extra cheese'</span><span class="token punctuation">)</span>
</code></pre> 
<p>不管收到的是一个值还是三个值，这个函数都能妥善地处理：</p> 
<pre><code>Making a pizza with the following toppings:
- pepperoni

Making a pizza with the following toppings:
- mushrooms
- green peppers
- extra cheese
</code></pre> 
<p>不管函数收到的实参是多少个，这种语法都管用。</p> 
<h3><a id="751__689"></a>7.5.1 结合使用位置实参和任意数量实参</h3> 
<p>如果要让函数接受不同类型的实参，必须在函数定义中将接纳任意数量实参的形参放在最后。</p> 
<p>Python先匹配位置实参和关键字实参，再将余下的实参都收集到最后一个形参中。</p> 
<p>例如，如果前面的函数还需要一个表示比萨尺寸的实参，必须将该形参放在形参*toppings 的前面：</p> 
<pre><code class="prism language-python"><span class="token keyword">def</span> <span class="token function">make_pizza</span><span class="token punctuation">(</span>size<span class="token punctuation">,</span> <span class="token operator">*</span>toppings<span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token triple-quoted-string string">"""概述要制作的比萨"""</span>
    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"\nMaking a "</span> <span class="token operator">+</span> <span class="token builtin">str</span><span class="token punctuation">(</span>size<span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">"-inch pizza with the following toppings:"</span><span class="token punctuation">)</span>
    <span class="token keyword">for</span> topping <span class="token keyword">in</span> toppings<span class="token punctuation">:</span>
        <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"- "</span> <span class="token operator">+</span> topping<span class="token punctuation">)</span>
        
make_pizza<span class="token punctuation">(</span><span class="token number">16</span><span class="token punctuation">,</span> <span class="token string">'pepperoni'</span><span class="token punctuation">)</span>
make_pizza<span class="token punctuation">(</span><span class="token number">12</span><span class="token punctuation">,</span> <span class="token string">'mushrooms'</span><span class="token punctuation">,</span> <span class="token string">'green peppers'</span><span class="token punctuation">,</span> <span class="token string">'extra cheese'</span><span class="token punctuation">)</span>
</code></pre> 
<p>基于上述函数定义，Python将收到的第一个值存储在形参size 中，并将其他的所有值都存储在元组toppings 中。</p> 
<p>在函数调用中，首先指定表示比萨尺寸的实参，然后根据需要指定任意数量的配料。</p> 
<p>现在，每个比萨都有了尺寸和一系列配料，这些信息按正确的顺序打印出来了——首先是尺寸，然后是配料：</p> 
<pre><code>Making a 16-inch pizza with the following toppings:
- pepperoni

Making a 12-inch pizza with the following toppings:
- mushrooms
- green peppers
- extra cheese
</code></pre> 
<h3><a id="752__719"></a>7.5.2 使用任意数量的关键字实参</h3> 
<p>有时候，需要接受任意数量的实参，但预先不知道传递给函数的会是什么样的信息。</p> 
<p>在这种情况下，可将函数编写成能够接受任意数量的键—值对——调用语句提供了多少就接受多少。</p> 
<p>一个这样的示例是创建用户简介：你知道你将收到有关用户的信息，但不确定会是什么样的信息。</p> 
<p>在下面的示例中，函数build_profile() 接受名和姓，同时还接受任意数量的关键字实参：</p> 
<pre><code class="prism language-python"><span class="token keyword">def</span> <span class="token function">build_profile</span><span class="token punctuation">(</span>first<span class="token punctuation">,</span> last<span class="token punctuation">,</span> <span class="token operator">**</span>user_info<span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token triple-quoted-string string">"""创建一个字典，其中包含我们知道的有关用户的一切"""</span>
    profile <span class="token operator">=</span> <span class="token punctuation">{<!-- --></span><span class="token punctuation">}</span>
    profile<span class="token punctuation">[</span><span class="token string">'first_name'</span><span class="token punctuation">]</span> <span class="token operator">=</span> first <span class="token comment"># ❶ </span>
    profile<span class="token punctuation">[</span><span class="token string">'last_name'</span><span class="token punctuation">]</span> <span class="token operator">=</span> last
    <span class="token keyword">for</span> key<span class="token punctuation">,</span> value <span class="token keyword">in</span> user_info<span class="token punctuation">.</span>items<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span> <span class="token comment"># ❷ </span>
        profile<span class="token punctuation">[</span>key<span class="token punctuation">]</span> <span class="token operator">=</span> value
    <span class="token keyword">return</span> profile

user_profile <span class="token operator">=</span> build_profile<span class="token punctuation">(</span><span class="token string">'albert'</span><span class="token punctuation">,</span> <span class="token string">'einstein'</span><span class="token punctuation">,</span>location<span class="token operator">=</span><span class="token string">'princeton'</span><span class="token punctuation">,</span>field<span class="token operator">=</span><span class="token string">'physics'</span><span class="token punctuation">)</span>
<span class="token keyword">print</span><span class="token punctuation">(</span>user_profile<span class="token punctuation">)</span>
</code></pre> 
<p>函数build_profile() 的定义要求提供名和姓，同时允许用户根据需要提供任意数量的名称—值对。</p> 
<p>形参**user_info 中的两个星号让Python创建一个名为user_info 的空字典，并将收到的所有名称—值对都封装到这个字典中。</p> 
<p>在这个函数中，可以像访问其他字典那样访问user_info 中的名称—值对。</p> 
<p>在build_profile() 的函数体内，我们创建了一个名为profile 的空字典，用于存储用户简介。</p> 
<p>在❶处，我们将名和姓加入到这个字典中，因为我们总是会从用户那里收到这两项信息。</p> 
<p>在❷处，我们遍历字典user_info 中的键—值对，并将每个键—值对都加入到字典profile 中。</p> 
<p>最后，我们将字典profile 返回给函数调用行。</p> 
<p>我们调用build_profile() ，向它传递名（‘albert’ ）、姓（‘einstein’ ）和两个键—值对（location=‘princeton’ 和field=‘physics’ ），并将返回的profile 存储在变量user_profile 中，再打印这个变量：</p> 
<pre><code>{'first_name': 'albert', 'last_name': 'einstein','location': 'princeton', 'field': 'physics'}
</code></pre> 
<p>在这里，返回的字典包含用户的名和姓，还有求学的地方和所学专业。</p> 
<p>调用这个函数时，不管额外提供了多少个键—值对，它都能正确地处理。</p> 
<p>编写函数时，你可以以各种方式混合使用位置实参、关键字实参和任意数量的实参。</p> 
<p>知道这些实参类型大有裨益，因为阅读别人编写的代码时经常会见到它们。</p> 
<p>要正确地使用这些类型的实参并知道它们的使用时机，需要经过一定的练习。</p> 
<p>就目前而言，牢记使用最简单的方法来完成任务就好了。你继续往下阅读，就会知道在各种情况下哪种方法的效率是最高的。</p> 
<h2><a id="76__769"></a>7.6 将函数存储在模块中</h2> 
<p>函数的优点之一是，使用它们可将代码块与主程序分离。</p> 
<p>通过给函数指定描述性名称，可让主程序容易理解得多。</p> 
<p>你还可以更进一步，将函数存储在被称为模块 的独立文件中，再将模块导入到主程序中。</p> 
<p>import语句允许在当前运行的程序文件中使用模块中的代码。</p> 
<p>通过将函数存储在独立的文件中，可隐藏程序代码的细节，将重点放在程序的高层逻辑上</p> 
<p>。这还能让你在众多不同的程序中重用函数。</p> 
<p>将函数存储在独立文件中后，可与其他程序员共享这些文件而不是整个程序。</p> 
<p>知道如何导入函数还能让你使用其他程序员编写的函数库。</p> 
<p>导入模块的方法有多种，下面对每种都作简要的介绍。</p> 
<h3><a id="761__787"></a>7.6.1 导入整个模块</h3> 
<p>要让函数是可导入的，得先创建模块。</p> 
<p>模块 是扩展名为.py的文件，包含要导入到程序中的代码。下面来创建一个包含函数make_pizza() 的模块。</p> 
<p>为此，我们将文件pizza.py中除函数make_pizza() 之外的其他代码都删除：</p> 
<pre><code class="prism language-python"><span class="token comment"># pizza.py</span>
<span class="token keyword">def</span> <span class="token function">make_pizza</span><span class="token punctuation">(</span>size<span class="token punctuation">,</span> <span class="token operator">*</span>toppings<span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token triple-quoted-string string">"""概述要制作的比萨"""</span>
    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"\nMaking a "</span> <span class="token operator">+</span> <span class="token builtin">str</span><span class="token punctuation">(</span>size<span class="token punctuation">)</span> <span class="token operator">+</span>
    <span class="token string">"-inch pizza with the following toppings:"</span><span class="token punctuation">)</span>
    <span class="token keyword">for</span> topping <span class="token keyword">in</span> toppings<span class="token punctuation">:</span>
        <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"- "</span> <span class="token operator">+</span> topping<span class="token punctuation">)</span>
</code></pre> 
<p>接下来，我们在pizza.py所在的目录中创建另一个名为making_pizzas.py的文件，这个文件导入刚创建的模块，再调用make_pizza() 两次：</p> 
<pre><code class="prism language-python"><span class="token comment"># making_pizzas.py</span>
<span class="token keyword">import</span> pizza

pizza<span class="token punctuation">.</span>make_pizza<span class="token punctuation">(</span><span class="token number">16</span><span class="token punctuation">,</span> <span class="token string">'pepperoni'</span><span class="token punctuation">)</span> <span class="token comment"># ❶ </span>
pizza<span class="token punctuation">.</span>make_pizza<span class="token punctuation">(</span><span class="token number">12</span><span class="token punctuation">,</span> <span class="token string">'mushrooms'</span><span class="token punctuation">,</span> <span class="token string">'green peppers'</span><span class="token punctuation">,</span> <span class="token string">'extra cheese'</span><span class="token punctuation">)</span>
</code></pre> 
<p>Python读取这个文件时，代码行import pizza 让Python打开文件pizza.py，并将其中的所有函数都复制到这个程序中。</p> 
<p>你看不到复制的代码，因为这个程序运行时，Python在幕后复制这些代码。</p> 
<p>你只需知道，在making_pizzas.py中，可以使用pizza.py中定义的所有函数。</p> 
<p>要调用被导入的模块中的函数，可指定导入的模块的名称pizza 和函数名make_pizza() ，并用句点分隔它们（见❶）。</p> 
<p>这些代码的输出与没有导入模块的原始程序相同：</p> 
<pre><code>Making a 16-inch pizza with the following toppings:
- pepperoni

Making a 12-inch pizza with the following toppings:
- mushrooms
- green peppers
- extra cheese
</code></pre> 
<p>这就是一种导入方法：只需编写一条import 语句并在其中指定模块名，就可在程序中使用该模块中的所有函数。</p> 
<p>如果你使用这种import 语句导入了名为module_name.py 的整个模块，就可使用下面的语法来使用其中任何一个函数：</p> 
<pre><code class="prism language-python">module_name<span class="token punctuation">.</span>function_name<span class="token punctuation">(</span><span class="token punctuation">)</span>
</code></pre> 
<h3><a id="762__834"></a>7.6.2 导入特定的函数</h3> 
<p>你还可以导入模块中的特定函数，这种导入方法的语法如下：</p> 
<pre><code class="prism language-python"><span class="token keyword">from</span> module_name <span class="token keyword">import</span> function_name
</code></pre> 
<p>通过用逗号分隔函数名，可根据需要从模块中导入任意数量的函数：</p> 
<pre><code class="prism language-python"><span class="token keyword">from</span> module_name <span class="token keyword">import</span> function_0<span class="token punctuation">,</span> function_1<span class="token punctuation">,</span> function_2
</code></pre> 
<p>对于前面的making_pizzas.py示例，如果只想导入要使用的函数，代码将类似于下面这样：</p> 
<pre><code class="prism language-python"><span class="token keyword">from</span> pizza <span class="token keyword">import</span> make_pizza

make_pizza<span class="token punctuation">(</span><span class="token number">16</span><span class="token punctuation">,</span> <span class="token string">'pepperoni'</span><span class="token punctuation">)</span>
make_pizza<span class="token punctuation">(</span><span class="token number">12</span><span class="token punctuation">,</span> <span class="token string">'mushrooms'</span><span class="token punctuation">,</span> <span class="token string">'green peppers'</span><span class="token punctuation">,</span> <span class="token string">'extra cheese'</span><span class="token punctuation">)</span>
</code></pre> 
<p>若使用这种语法，调用函数时就无需使用句点。</p> 
<p>由于我们在import 语句中显式地导入了函数make_pizza() ，因此调用它时只需指定其名称。</p> 
<h3><a id="763_as__853"></a>7.6.3 使用as 给函数指定别名</h3> 
<p>如果要导入的函数的名称可能与程序中现有的名称冲突，或者函数的名称太长，可指定简短而独一无二的别名 ——函数的另一个名称，类似于外号。</p> 
<p>要给函数指定这种特殊外号，需要在导入它时这样做。</p> 
<p>下面给函数make_pizza() 指定了别名mp() 。</p> 
<p>这是在import 语句中使用make_pizza as mp 实现的，关键字as 将函数重命名为你提供的别名：</p> 
<pre><code class="prism language-python"><span class="token keyword">from</span> pizza <span class="token keyword">import</span> make_pizza <span class="token keyword">as</span> mp

mp<span class="token punctuation">(</span><span class="token number">16</span><span class="token punctuation">,</span> <span class="token string">'pepperoni'</span><span class="token punctuation">)</span>
mp<span class="token punctuation">(</span><span class="token number">12</span><span class="token punctuation">,</span> <span class="token string">'mushrooms'</span><span class="token punctuation">,</span> <span class="token string">'green peppers'</span><span class="token punctuation">,</span> <span class="token string">'extra cheese'</span><span class="token punctuation">)</span>
</code></pre> 
<p>上面的import 语句将函数make_pizza() 重命名为mp() ；</p> 
<p>在这个程序中，每当需要调用make_pizza() 时，都可简写成mp() ，而Python将运行make_pizza() 中的代码，这可避免与这个程序可能包含的函数make_pizza() 混淆。</p> 
<p>指定别名的通用语法如下：</p> 
<pre><code class="prism language-python"><span class="token keyword">from</span> module_name <span class="token keyword">import</span> function_name <span class="token keyword">as</span> fn
</code></pre> 
<h3><a id="764_as__875"></a>7.6.4 使用as 给模块指定别名</h3> 
<p>你还可以给模块指定别名。</p> 
<p>通过给模块指定简短的别名（如给模块pizza 指定别名p ），让你能够更轻松地调用模块中的函数。</p> 
<p>相比于pizza.make_pizza() ，p.make_pizza() 更为简洁：</p> 
<pre><code class="prism language-python"><span class="token keyword">import</span> pizza <span class="token keyword">as</span> p
p<span class="token punctuation">.</span>make_pizza<span class="token punctuation">(</span><span class="token number">16</span><span class="token punctuation">,</span> <span class="token string">'pepperoni'</span><span class="token punctuation">)</span>
p<span class="token punctuation">.</span>make_pizza<span class="token punctuation">(</span><span class="token number">12</span><span class="token punctuation">,</span> <span class="token string">'mushrooms'</span><span class="token punctuation">,</span> <span class="token string">'green peppers'</span><span class="token punctuation">,</span> <span class="token string">'extra cheese'</span><span class="token punctuation">)</span>
</code></pre> 
<p>上述import 语句给模块pizza 指定了别名p ，但该模块中所有函数的名称都没变。</p> 
<p>调用函数make_pizza() 时，可编写代码p.make_pizza() 而不是pizza.make_pizza() ，这样不仅能使代码更简洁，还可以让你不再关注模块名，而专注于描述性的函数名。</p> 
<p>这些函数名明确地指出了函数的功能，对理解代码而言，它们比模块名更重要。</p> 
<p>给模块指定别名的通用语法如下：</p> 
<pre><code class="prism language-python"><span class="token keyword">import</span> module_name <span class="token keyword">as</span> mn
</code></pre> 
<h3><a id="765__896"></a>7.6.5 导入模块中的所有函数</h3> 
<p>使用星号（* ）运算符可让Python导入模块中的所有函数：</p> 
<pre><code class="prism language-python"><span class="token keyword">from</span> pizza <span class="token keyword">import</span> <span class="token operator">*</span>

make_pizza<span class="token punctuation">(</span><span class="token number">16</span><span class="token punctuation">,</span> <span class="token string">'pepperoni'</span><span class="token punctuation">)</span>
make_pizza<span class="token punctuation">(</span><span class="token number">12</span><span class="token punctuation">,</span> <span class="token string">'mushrooms'</span><span class="token punctuation">,</span> <span class="token string">'green peppers'</span><span class="token punctuation">,</span> <span class="token string">'extra cheese'</span><span class="token punctuation">)</span>
</code></pre> 
<p>import 语句中的星号让Python将模块pizza 中的每个函数都复制到这个程序文件中。</p> 
<p>由于导入了每个函数，可通过名称来调用每个函数，而无需使用句点表示法。</p> 
<p>然而，使用并非自己编写的大型模块时，最好不要采用这种导入方法：如果模块中有函数的名称与你的项目中使用的名称相同，可能导致意想不到的结果：Python可能遇到多个名称相同的函数或变量，进而覆盖函数，而不是分别导入所有的函数。</p> 
<p>最佳的做法是，要么只导入你需要使用的函数，要么导入整个模块并使用句点表示法。</p> 
<p>这能让代码更清晰，更容易阅读和理解。这里之所以介绍这种导入方法，只是想让你在阅读别人编写的代码时，如果遇到类似于下面的import 语句，能够理解它们：</p> 
<pre><code class="prism language-python"><span class="token keyword">from</span> module_name <span class="token keyword">import</span> <span class="token operator">*</span>
</code></pre> 
<h2><a id="77__916"></a>7.7 函数编写指南</h2> 
<p>编写函数时，需要牢记几个细节。应给函数指定描述性名称，且只在其中使用小写字母和下划线。</p> 
<p>描述性名称可帮助你和别人明白代码想要做什么。给模块命名时也应遵循上述约定。</p> 
<p>每个函数都应包含简要地阐述其功能的注释，该注释应紧跟在函数定义后面，并采用文档字符串格式。</p> 
<p>文档良好的函数让其他程序员只需阅读文档字符串中的描述就能够使用它：他们完全可以相信代码如描述的那样运行；</p> 
<p>只要知道函数的名称、需要的实参以及返回值的类型，就能在自己的程序中使用它。</p> 
<p>给形参指定默认值时，等号两边不要有空格：</p> 
<pre><code class="prism language-python"><span class="token keyword">def</span> <span class="token function">function_name</span><span class="token punctuation">(</span>parameter_0<span class="token punctuation">,</span> parameter_1<span class="token operator">=</span><span class="token string">'default value'</span><span class="token punctuation">)</span>
</code></pre> 
<p>对于函数调用中的关键字实参，也应遵循这种约定：</p> 
<pre><code class="prism language-python">function_name<span class="token punctuation">(</span>value_0<span class="token punctuation">,</span> parameter_1<span class="token operator">=</span><span class="token string">'value'</span><span class="token punctuation">)</span>
</code></pre> 
<p>如果形参很多，导致函数定义的长度超过了79字符，可在函数定义中输入左括号后按回车键，并在下一行按两次Tab键，从而将形参列表和只缩进一层的函数体区分开来。</p> 
<p>大多数编辑器都会自动对齐后续参数列表行，使其缩进程度与你给第一个参数列表行指定的缩进程度相同：</p> 
<pre><code class="prism language-python"><span class="token keyword">def</span> <span class="token function">function_name</span><span class="token punctuation">(</span>parameter_0<span class="token punctuation">,</span> parameter_1<span class="token punctuation">,</span> parameter_2<span class="token punctuation">,</span>
parameter_3<span class="token punctuation">,</span> parameter_4<span class="token punctuation">,</span> parameter_5<span class="token punctuation">)</span><span class="token punctuation">:</span>
    function body<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
</code></pre> 
<p>如果程序或模块包含多个函数，可使用两个空行将相邻的函数分开，这样将更容易知道前一个函数在什么地方结束，下一个函数从什么地方开始。</p> 
<p>所有的import 语句都应放在文件开头，唯一例外的情形是，在文件开头使用了注释来描述整个程序。</p> 
<h2><a id="78__946"></a>7.8 小结</h2> 
<p>在本章中，你学习了：如何编写函数，以及如何传递实参，让函数能够访问完成其工作所需的信息；如何使用位置实参和关键字实参，以及如何接受任意数量的实参；</p> 
<p>显示输出的函数和返回值的函数；如何将函数同列表、字典、if 语句和while 循环结合起来使用。</p> 
<p>你还知道了如何将函数存储在被称为模块的独立文件中，让程序文件更简单、更易于理解。</p> 
<p>最后，你学习了函数编写指南，遵循这些指南可让程序始终结构良好，并对你和其他人来说易于阅读。</p> 
<p>程序员的目标之一是，编写简单的代码来完成任务，而函数有助于你实现这样的目标。</p> 
<p>它们让你编写好代码块并确定其能够正确运行后，就可置之不理。确定函数能够正确地完成其工作后，你就可以接着投身于下一个编码任务。</p> 
<p>函数让你编写代码一次后，想重用它们多少次就重用多少次。需要运行函数中的代码时，只需编写一行函数调用代码，就可让函数完成其工作。</p> 
<p>需要修改函数的行为时，只需修改一个代码块，而所做的修改将影响调用这个函数的每个地方。</p> 
<p>使用函数让程序更容易阅读，而良好的函数名概述了程序各个部分的作用。相对于阅读一系列的代码块，阅读一系列函数调用让你能够更快地明白程序的作用。</p> 
<p>函数还让代码更容易测试和调试。如果程序使用一系列的函数来完成其任务，而其中的每个函数都完成一项具体的工作，测试和维护起来将容易得多：你可编写分别调用每个函数的程序，并测试每个函数是否在它可能遇到的各种情形下都能正确地运行。</p> 
<p>经过这样的测试后你就能信心满满，深信你每次调用这些函数时，它们都将正确地运行。</p> 
<p>在第8章，你将学习编写类。类将函数和数据整洁地封装起来，让你能够灵活而高效地使用它们。</p> 
<h2><a id="_970"></a>习题</h2> 
<p>7-1 消息 ：编写一个名为display_message() 的函数，它打印一个句子，指出你在本章学的是什么。调用这个函数，确认显示的消息正确无误。<br> 7-2 T恤 ：编写一个名为make_shirt() 的函数，它接受一个尺码以及要印到T恤上的字样。这个函数应打印一个句子，概要地说明T恤的尺码和字样。<br> 7-3 城市 ：编写一个名为describe_city() 的函数，它接受一座城市的名字以及该城市所属的国家。这个函数应打印一个简单的句子，如ChangSha is in China 。给用于存储国家的形参指定默认值。为三座不同的城市调用这个函数，且其中至少有一座城市不属于默认国家。<br> 7-4 魔术师 ：创建一个包含魔术师名字的列表，并将其传递给一个名为show_magicians() 的函数，这个函数打印列表中每个魔术师的名字。<br> 7-5 三明治 ：编写一个函数，它接受顾客要在三明治中添加的一系列食材。这个函数只有一个形参（它收集函数调用中提供的所有食材），并打印一条消息，对顾客点的三明治进行概述。调用这个函数三次，每次都提供不同数量的实参。<br> 7-6导入 ：选择一个你编写的且只包含一个函数的程序，并将这个函数放在另一个文件中。在主程序文件中，使用下述各种方法导入这个函数，再调用它：</p> 
<pre><code class="prism language-python"><span class="token keyword">import</span> module_name
<span class="token keyword">from</span> module_name <span class="token keyword">import</span> function_name
<span class="token keyword">from</span> module_name <span class="token keyword">import</span> function_name <span class="token keyword">as</span> fn
<span class="token keyword">import</span> module_name <span class="token keyword">as</span> mn
<span class="token keyword">from</span> module_name <span class="token keyword">import</span> <span class="token operator">*</span>
</code></pre>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/645980b5b4fd24f8d791267346be1331/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">RT-Thread ART-Pi 地址说明、恢复出厂设定&amp;全擦除 兼 踩坑记录</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/3cca87594763d81d68d2396884ef1c10/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">ElementUI 实现el-upload上传文件必填校验</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>