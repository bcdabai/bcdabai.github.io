<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Modbus简介 - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Modbus简介" />
<meta property="og:description" content="参考资料 官方文档： Modbus_Application_Protocol_V1_1b.pdfwiki： Modbus - Wikipedia (jinzhao.wiki)RTU与ASCII比较： Modbus RTU (ozeki.hu)详细说明： Modicon Modbus Protocol Reference Guidemodbus TCP： Modbus_Messaging_Implementation_Guide_V1_0b_tcp.pdf 名词解释 ADU： Application Data Unit 应用数据单元PDU： Protocol Data Unit 协议数据单元RTU： Remote Terminal UnitCRC： Cyclic Redundancy Check 循环冗余校验LRC： Longitudinal Redundancy Check 纵向冗余校验离散变量： 指其数值只能用自然数或整数单位计算的则为离散变量 协议简介 由Modicon （现在的施耐德电气）在1979年发布，用于PLC通信，已经成为事实上的工业领域通信协议的业界标准。
特点： 简单，应用广泛，请求/应答，功能码支持。
modbus支持多种通信栈传输
TCP/IP over Ethernet， 端口为502Asynchronous serial 传输 over EIA/TIA-232-E 或 EIA/TIA-485 或 fiber, radio 等MODBUS PLUS， 一种高速令牌传输网络其他 其中串口通讯最为常见。
总体结构 modbus是由 modbus ADU 构成，不同的通讯协议会对它做一定的封装，ADU的结构如下
Additinal addressModbus PDUError Check地址域协议数据单元差错校验 PDU的结构如下" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/de91228b03bfef35f3f4b18222b87322/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-10-21T16:32:05+08:00" />
<meta property="article:modified_time" content="2022-10-21T16:32:05+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Modbus简介</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <h2><a id="_0"></a>参考资料</h2> 
<ol><li>官方文档： Modbus_Application_Protocol_V1_1b.pdf</li><li>wiki： <a href="https://en.jinzhao.wiki/wiki/Modbus" rel="nofollow">Modbus - Wikipedia (jinzhao.wiki)</a></li><li>RTU与ASCII比较： <a href="https://ozeki.hu/p_5854-modbus-rtu.html" rel="nofollow">Modbus RTU (ozeki.hu)</a></li><li>详细说明： Modicon Modbus Protocol Reference Guide</li><li>modbus TCP： Modbus_Messaging_Implementation_Guide_V1_0b_tcp.pdf</li></ol> 
<h2><a id="_8"></a>名词解释</h2> 
<ul><li>ADU： Application Data Unit 应用数据单元</li><li>PDU： Protocol Data Unit 协议数据单元</li><li>RTU： Remote Terminal Unit</li><li>CRC： Cyclic Redundancy Check 循环冗余校验</li><li>LRC： Longitudinal Redundancy Check 纵向冗余校验</li><li>离散变量： 指其数值只能用自然数或整数单位计算的则为离散变量</li></ul> 
<h2><a id="_19"></a>协议简介</h2> 
<p>由Modicon （现在的施耐德电气）在1979年发布，用于PLC通信，已经成为事实上的工业领域通信协议的业界标准。</p> 
<p>特点： 简单，应用广泛，请求/应答，功能码支持。</p> 
<p>modbus支持多种通信栈传输</p> 
<ol><li>TCP/IP over Ethernet， 端口为502</li><li>Asynchronous serial 传输 over EIA/TIA-232-E 或 EIA/TIA-485 或 fiber, radio 等</li><li>MODBUS PLUS， 一种高速令牌传输网络</li><li>其他</li></ol> 
<p>其中串口通讯最为常见。</p> 
<h2><a id="_34"></a>总体结构</h2> 
<p>modbus是由 modbus ADU 构成，不同的通讯协议会对它做一定的封装，ADU的结构如下</p> 
<table><thead><tr><th>Additinal address</th><th>Modbus PDU</th><th>Error Check</th></tr></thead><tbody><tr><td>地址域</td><td>协议数据单元</td><td>差错校验</td></tr></tbody></table> 
<p>PDU的结构如下</p> 
<table><thead><tr><th>Function code</th><th>Data</th></tr></thead><tbody><tr><td>功能码</td><td>数据</td></tr></tbody></table> 
<p>PDU的格式将在下一段详细介绍。</p> 
<p>modbus有很多种通讯协议，下面是最为常见的三种类型。</p> 
<h3><a id="Modbus_RTU_52"></a>Modbus RTU</h3> 
<p>最常用， Modbus messages are framed (separated) by idle (silent) periods.数据密度高，用于RS-485/<a href="https://en.jinzhao.wiki/wiki/EIA-485" rel="nofollow">EIA-485</a> 等异步串口</p> 
<table><thead><tr><th>Name</th><th>Length (bits)</th><th>Function</th></tr></thead><tbody><tr><td>Start</td><td>3.5 x 8</td><td>At least 3+1⁄2 character times (28 bits) of silence (mark condition)</td></tr><tr><td>Address</td><td>8</td><td>Station address</td></tr><tr><td>Function</td><td>8</td><td>Indicates the function code; e.g., read coils/holding registers</td></tr><tr><td>Data</td><td>n × 8</td><td>Data + length will be filled depending on the message type</td></tr><tr><td>CRC</td><td>16</td><td>Cyclic redundancy check</td></tr><tr><td>End</td><td>3.5 x 8</td><td>At least 3+1⁄2 character times (28 bits) of silence (mark condition) between frames</td></tr></tbody></table> 
<h3><a id="Modbus_ASCII_65"></a>Modbus ASCII</h3> 
<p>易读，有前导码和终止码，主要用于7-bits或8-bits的异步串口线，</p> 
<table><thead><tr><th>Name</th><th>Length (bytes)</th><th>Function</th></tr></thead><tbody><tr><td>Start</td><td>1</td><td>Colon : (ASCII value 0x3A)</td></tr><tr><td>Address</td><td>2</td><td>Station address</td></tr><tr><td>Function</td><td>2</td><td>Indicates the function codes like read coils / inputs</td></tr><tr><td>Data</td><td>n × 2</td><td>Data + length will be filled depending on the message type</td></tr><tr><td>LRC</td><td>2</td><td>Checksum (Longitudinal redundancy check)</td></tr><tr><td>End</td><td>2</td><td>Carriage return + line feed (CR/LF) pair (ASCII values 0x0D and 0x0A)</td></tr></tbody></table> 
<p>RTU和ASCII发送同样的原始数据，区别如下</p> 
<table><thead><tr><th>源数据</th><th>RTU模式</th><th>ASCII模式</th></tr></thead><tbody><tr><td>0x45</td><td>0x45</td><td>0x34 0x35</td></tr><tr><td>0xA1</td><td>0xA1</td><td>0x41 0x31</td></tr><tr><td>0xa1</td><td>0xA1</td><td>0x61 0x31</td></tr></tbody></table> 
<h3><a id="Modbus_TCP_86"></a>Modbus TCP</h3> 
<p>结构最复杂，运行在以太网上，TCP502端口。</p> 
<p>Modbus/TCP应用层报文不需要校验（个人猜测是因为IP层/TCP层已经将校验做掉了）</p> 
<p>modbus TCP的报文整体结构如下</p> 
<table><thead><tr><th>Mac header</th><th>IP header</th><th>TCP header</th><th>Modbus ADU</th></tr></thead><tbody><tr><td>Mac头</td><td>IP头</td><td>TCP头</td><td>Modbus应用数据单元</td></tr></tbody></table> 
<p>下面是modbus中的ADU结构</p> 
<table><thead><tr><th>Name</th><th>Length (bytes)</th><th>Function</th></tr></thead><tbody><tr><td>Transaction identifier</td><td>2</td><td>For synchronization between messages of server and client</td></tr><tr><td>Protocol identifier</td><td>2</td><td>0 for Modbus/TCP</td></tr><tr><td>Length field</td><td>2</td><td>Number of remaining bytes in this frame</td></tr><tr><td>Unit identifier</td><td>1</td><td>Server address (255 if not used)</td></tr><tr><td>Function code</td><td>1</td><td>Function codes as in other variants</td></tr><tr><td>Data bytes</td><td>n</td><td>Data as response or commands</td></tr></tbody></table> 
<table><thead><tr><th>Name</th><th>Length (bytes)</th><th>说明</th></tr></thead><tbody><tr><td>Transaction identifier</td><td>2</td><td>事务识别符，无限制，TC和TS一致</td></tr><tr><td>Protocol identifier</td><td>2</td><td>协议识别符， 0</td></tr><tr><td>Length field</td><td>2</td><td>后续长度， 2~254</td></tr><tr><td>Unit identifier</td><td>1</td><td>单元识别符， 小于等于247或255</td></tr><tr><td>Function code</td><td>1</td><td>见PDU结构章节</td></tr><tr><td>Data bytes</td><td>n</td><td>见PDU结构章节</td></tr></tbody></table> 
<p>wireshark中将前7个固定字节成为MBAP header（Modbus Application Protocol），个人认为这相当于通用结构中的地址域（Additional address）。ADU总长度最大为260字节。</p> 
<h2><a id="PDU_120"></a>PDU</h2> 
<p>根据文档定义，功能码占一个字节，范围是1~127，分为3类</p> 
<ol><li>公共功能码：除去下面两种类型的功能码，均可使用，但是在文档中只有部分已定义</li><li>使用者自定义功能码：65~72， 100~110</li><li>保留功能码：被某些公司使用或者暂时不可用：8,9，10,13,14,41,42,90,91,125,126,127；</li></ol> 
<p>在具体解析功能码前，我们首先来了解一下功能类型和其作用的对象类型</p> 
<h3><a id="_130"></a>功能类型</h3> 
<ol><li>Data Access 数据存取</li><li>Diagnostics 诊断，用于查看链路状态和设备状态，只支持串口</li><li>Other（Encapsulated Interface Transport?）</li></ol> 
<h3><a id="_136"></a>对象类型</h3> 
<table><thead><tr><th align="center">Object type</th><th>说明</th><th align="center">Access</th><th align="center">Size</th><th align="center">Address Space</th></tr></thead><tbody><tr><td align="center">Coil</td><td>线圈</td><td align="center">Read-write</td><td align="center">1 bit</td><td align="center">00001 – 09999</td></tr><tr><td align="center">Discrete input</td><td>离散输入，相当于保持线圈</td><td align="center">Read-only</td><td align="center">1 bit</td><td align="center">10001 – 19999</td></tr><tr><td align="center">Holding register</td><td>保持寄存器</td><td align="center">Read-only</td><td align="center">16 bits</td><td align="center">30001 – 39999</td></tr><tr><td align="center">Input register</td><td>输入寄存器</td><td align="center">Read-write</td><td align="center">16 bits</td><td align="center">40001 – 49999</td></tr></tbody></table> 
<h3><a id="_145"></a>功能码与数据</h3> 
<p>本文解析的功能码只限于文档中出现的已定义公共功能码，如下表所示</p> 
<table><thead><tr><th></th><th></th><th><strong>Function type</strong></th><th><strong>Function name</strong></th><th><strong>Function code</strong></th><th><strong>Comment</strong></th></tr></thead><tbody><tr><td>Data Access</td><td>Bit Access</td><td>Physical Discrete Inputs</td><td><strong>Read Discrete Inputs</strong></td><td>2</td><td></td></tr><tr><td></td><td></td><td>Internal Bits or Physical Coils</td><td><strong>Read Coils</strong></td><td>1</td><td></td></tr><tr><td></td><td></td><td></td><td><strong>Write Single Coil</strong></td><td>5</td><td></td></tr><tr><td></td><td></td><td></td><td><strong>Write Multiple Coils</strong></td><td>15</td><td></td></tr><tr><td></td><td>16-bit access</td><td>Physical Input Registers</td><td><strong>Read Input Registers</strong></td><td>4</td><td></td></tr><tr><td></td><td></td><td>Internal Registers or Physical Output Registers</td><td><strong>Read Multiple Holding Registers</strong></td><td>3</td><td></td></tr><tr><td></td><td></td><td></td><td><strong>Write Single Holding Register</strong></td><td>6</td><td></td></tr><tr><td></td><td></td><td></td><td><strong>Write Multiple Holding Registers</strong></td><td>16</td><td></td></tr><tr><td></td><td></td><td></td><td><strong>Read/Write Multiple Registers</strong></td><td>23</td><td></td></tr><tr><td></td><td></td><td></td><td><strong>Mask Write Register</strong></td><td>22</td><td></td></tr><tr><td></td><td></td><td></td><td><strong>Read FIFO Queue</strong></td><td>24</td><td></td></tr><tr><td></td><td>File Record Access</td><td></td><td>Read File Record</td><td>20</td><td></td></tr><tr><td></td><td></td><td></td><td>Write File Record</td><td>21</td><td></td></tr><tr><td>Diagnostics</td><td></td><td></td><td>Read Exception Status</td><td>7</td><td></td></tr><tr><td></td><td></td><td></td><td>Diagnostic</td><td>8</td><td></td></tr><tr><td></td><td></td><td></td><td>Get Com Event Counter</td><td>11</td><td></td></tr><tr><td></td><td></td><td></td><td>Get Com Event Log</td><td>12</td><td></td></tr><tr><td></td><td></td><td></td><td>Report Server ID</td><td>17</td><td></td></tr><tr><td></td><td></td><td></td><td>Read Device Identification</td><td>43</td><td></td></tr><tr><td>Other</td><td></td><td></td><td>Encapsulated Interface Transport</td><td>43</td><td></td></tr></tbody></table> 
<p>下面根据开发需求将PDU的功能码分成4种类型</p> 
<ol><li> <p>只含有功能码，无后续数据（4种）</p> </li><li> <p>基本读写功能码，长度固定为5字节（6种）</p> </li><li> <p>长度大于5字节的PDU（7种）</p> </li><li> <p>含有子功能码的PDU（2种）</p> </li></ol> 
<h4><a id="_182"></a>单功能码</h4> 
<p>这几种功能码都是只支持串行线（serial line only），对应的PDU中只有功能码，无后续数据</p> 
<table><thead><tr><th>function code</th><th>定义</th><th>说明</th></tr></thead><tbody><tr><td>0x07</td><td>read exception status</td><td>读取远端设备8bit异常状态输出（因设备而异）</td></tr><tr><td>0x0B</td><td>get common event count</td><td>读取远端设备通信事件计数器</td></tr><tr><td>0x0C</td><td>get common event log</td><td>时间计数 + 消息计数 + 事件描述</td></tr><tr><td>0x11</td><td>report slave ID</td><td>读取远端设备ID，运行状态和额外数据</td></tr></tbody></table> 
<h4><a id="_193"></a>基本读写</h4> 
<p>对应的PDU长度固定为5字节</p> 
<table><thead><tr><th>类型</th><th>说明</th><th>function code 1B</th><th>地址 2B</th><th>数量/数值 2B</th></tr></thead><tbody><tr><td>read coils</td><td>读线圈</td><td>0x01</td><td>starting address</td><td>quantity of coils</td></tr><tr><td>read discrete inputs</td><td>读离散输入</td><td>0x02</td><td>starting address</td><td>quantity of inputs</td></tr><tr><td>read holding registers</td><td>读保持寄存器</td><td>0x03</td><td>starting address</td><td>quantity of registers</td></tr><tr><td>read input registers</td><td>读输入寄存器</td><td>0x04</td><td>starting address</td><td>quantity of registers</td></tr><tr><td>write single coil</td><td>写单个线圈</td><td>0x05</td><td>output address</td><td>output value</td></tr><tr><td>write single registers</td><td>写单个寄存器</td><td>0x06</td><td>register address</td><td>register value</td></tr></tbody></table> 
<p>注：</p> 
<ul><li>如果starting address为3，说明是第4个线圈开始</li><li>input register是只读的，holding register可读可写</li></ul> 
<h4><a id="_211"></a>不定长</h4> 
<p>对应的PDU后续数据长度不定，功能码0x14和0x15后面的数据还可能存在多个请求</p> 
<table><thead><tr><th>类型</th><th>说明</th><th>function code 1B</th><th>地址 2B</th><th>数量 2B</th><th>字节数 1B</th><th>数值 NB</th></tr></thead><tbody><tr><td>write multiple coils</td><td>写多个线圈</td><td>0x0F</td><td>starting address</td><td>quantity of outputs</td><td>byte count</td><td>outputs value</td></tr></tbody></table> 
<table><thead><tr><th>类型</th><th>说明</th><th>function code 1B</th><th>地址 2B</th><th>数量 1B</th><th>字节数 1B</th><th>数值 2NB</th></tr></thead><tbody><tr><td>write multiple registers</td><td>写多个寄存器</td><td>0x10</td><td>starting address</td><td>quantity of registers</td><td>byte count</td><td>registers value</td></tr></tbody></table> 
<table><thead><tr><th>类型</th><th>说明</th><th>function code 1B</th><th>字节数 1B</th><th>参考类型 1B</th><th>文件号 2B</th><th>记录号 2B</th><th>记录长度 2B</th><th>重复 7NB</th></tr></thead><tbody><tr><td>read file record</td><td>读取文件记录（读取通用参数）</td><td>0x14</td><td>byte count</td><td>0x06(fixed)</td><td>file number</td><td>record number</td><td>record length</td><td>4个字段一组</td></tr></tbody></table> 
<table><thead><tr><th>类型</th><th>说明</th><th>function code 1B</th><th>数据长度 1B</th><th>参考类型 1B</th><th>文件号 2B</th><th>记录号 2B</th><th>记录长度 2B</th><th>记录数据 2NB</th><th>重复 (7+2N)*MB</th></tr></thead><tbody><tr><td>write file record</td><td>写文件记录（读取通用参数）</td><td>0x15</td><td>request data length</td><td>0x06(fixed)</td><td>file number</td><td>record number</td><td>record length</td><td>register data</td><td>5个字段一组</td></tr></tbody></table> 
<table><thead><tr><th>类型</th><th>说明</th><th>function code 1B</th><th>地址 2B</th><th>与掩码 2B</th><th>或掩码 2B</th></tr></thead><tbody><tr><td>mask write register</td><td>掩写寄存器</td><td>0x16</td><td>reference address</td><td>and_mask</td><td>or_mask</td></tr></tbody></table> 
<table><thead><tr><th>类型</th><th>说明</th><th>function code 1B</th><th>起始读地址 2B</th><th>读取数量 2B</th><th>起始写地址 2B</th><th>写数量 2B</th><th>后续字节数 1B</th><th>写寄存器值 2NB</th></tr></thead><tbody><tr><td>read/write multiple registers</td><td>读写多个寄存器</td><td>0x17</td><td>read starting address</td><td>quantity to read</td><td>write starting address</td><td>quantity to write</td><td>write byte count</td><td>write registers value</td></tr></tbody></table> 
<table><thead><tr><th>类型</th><th>说明</th><th>function code 1B</th><th>地址 2B</th></tr></thead><tbody><tr><td>read FIFO queue</td><td>读先进先出队列</td><td>0x18</td><td>FIFO pointer address</td></tr></tbody></table> 
<h4><a id="_245"></a>子功能码</h4> 
<p>含有子功能码的PDU格式如下</p> 
<table><thead><tr><th>function code</th><th>sub-function code</th><th>data</th></tr></thead><tbody><tr><td>功能码 1B</td><td>子功能码 1B/2B</td><td>数据 不定长</td></tr></tbody></table> 
<h6><a id="0x08DiagnosticsSerial_line_only_253"></a>（0x08）Diagnostics(Serial line only)</h6> 
<p>子功能码长度为2B，范围为0~65535，其中 5~9, 19, 21~65535 保留功能码。已定义的子功能码对应的数据大部分为2字节，值为0；子功能码 0x00 对应数据为任意长度；子功能码 0x01 对应的数据有两种；子功能码 0x03 的数据为字符串’CHAR’ + 00；</p> 
<table><thead><tr><th>类型</th><th>说明</th><th>sub-function code 2B</th><th>data 不定长</th></tr></thead><tbody><tr><td>return query data</td><td>发送若干数据，返回若干相同数据</td><td>0000</td><td>any</td></tr><tr><td>restart communication option</td><td>清空事件计数器，Log是否保留可选</td><td>001</td><td>0000/FF00(clear log)</td></tr><tr><td>return diagnostic register</td><td>返回诊断寄存器</td><td>0002</td><td>0000</td></tr><tr><td>change ASCII input delimiter</td><td>提示不需要换行符(Line Feed)</td><td>0003</td><td>CHAR 00</td></tr><tr><td>force listen only mode</td><td>进入只听模式</td><td>0004</td><td>0000</td></tr><tr><td>clear counters and diagnostic register</td><td>清空所有计数器和诊断寄存器</td><td>000A</td><td>0000</td></tr><tr><td>return bus message count</td><td>返回消息数量</td><td>000B</td><td>0000</td></tr><tr><td>return bus communication error count</td><td>返回CRC校验错误数量</td><td>000C</td><td>0000</td></tr><tr><td>return bus exception error count</td><td>返回异常回复数量</td><td>000D</td><td>0000</td></tr><tr><td>return slave message count</td><td>返回远端设备已处理消息数量</td><td>000E</td><td>0000</td></tr><tr><td>return slave no response count</td><td>返回远端设备未回复消息数量</td><td>000F</td><td>0000</td></tr><tr><td>return slave NAK count</td><td>返回远端设备未确认异常回复数量</td><td>0010</td><td>0000</td></tr><tr><td>return slave busy count</td><td>返回远端设备忙的异常回复的数量</td><td>0011</td><td>0000</td></tr><tr><td>return bus character overrun count</td><td>返回字符速度过快的异常回复数量</td><td>0012</td><td>0000</td></tr><tr><td>clear overrun counter and flag</td><td>清空overrun计数器，重置标志</td><td>0014</td><td>0000</td></tr></tbody></table> 
<h6><a id="0x2BEncapsulated_Interface_Transport_275"></a>（0x2B）Encapsulated Interface Transport</h6> 
<p>本类型用于隧道服务和方法调用，下属子功能码的名称为MEI type（Modbus Encapsulated Interface），常用的有两种，其他均为保留</p> 
<table><thead><tr><th>MEI type 1B</th><th>data NB</th></tr></thead><tbody><tr><td>0x0D</td><td>与CANopen 系统和设备进行交互</td></tr></tbody></table> 
<table><thead><tr><th>MEI type 1B</th><th>read device ID code 1B</th><th>object ID 1B</th></tr></thead><tbody><tr><td>0x0E</td><td>01/02/03/04</td><td>0x00~0xFF</td></tr></tbody></table>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/eb26d14013ebffb0a55624c1c211d536/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">git push 报错：refusing to merge unrelated histories</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/16935f6c3cbe4a296cecee58008d3191/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">Windows Server 2012 R2 安装补丁</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>