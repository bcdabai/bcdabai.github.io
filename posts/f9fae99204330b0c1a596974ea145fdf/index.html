<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Kafka——两种集群搭建详解 - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Kafka——两种集群搭建详解" />
<meta property="og:description" content="目录 1、简介1.1、Kafka集群中的节点类型1.2、两重模式的搭建方式 2、Zookeeper模式集群3、KRaft模式集群4、重要配置介绍4.1、listeners4.2、advertise.listeners4.3、process.roles4.4、controller.quorum.voters4.5、其它配置 1、简介 Kafka是一个能够支持高并发以及流式消息处理的消息中间件，并且Kafka天生就是支持集群的，今天就主要来介绍一下如何搭建Kafka集群。
Kafka目前支持使用Zookeeper模式搭建集群以及KRaft模式（即无Zookeeper）模式这两种模式搭建集群，这两种模式各有各的好处，今天就来分别介绍一下这两种方式
1.1、Kafka集群中的节点类型 一个Kafka集群是由下列几种类型的节点构成的，它们充当着不同的作用：
Broker节点：即代理节点，是Kafka中的工作节点，充当消息队列的角色，负责储存和处理消息，每个Broker都是一个独立的Kafka服务器，可以在不同的机器上运行，除此之外Broker还负责分区（partition）的管理，将主题（topic）划分为多个分区，并分布在集群的不同Broker上Controller节点：即控制器节点，是集群中的特殊节点，负责储存和管理整个集群元数据和状态，它能够监控整个集群中的Broker，在需要时还能够进行平衡操作混合节点：即同时担任Broker和Controller节点角色的节点 1.2、两重模式的搭建方式 Zookeeper模式集群KRaft模式集群 2、Zookeeper模式集群 这是一种比较简单，相对“传统”的搭建方式了！在这种模式下，每个Kafka节点都是依赖于Zookeeper的，使用Zookeeper存储集群中所有节点的元数据。
只要所有的Kafka节点连接到同一个Zookeeper上面（或者同一个Zookeeper集群），这些Kafka节点就构成了一个集群。所以说就算是只有一个Kafka节点在运行，这一个节点也可以称作一个集群。
在Zookeeper模式集群中，Zookeeper节点（或者集群）就充当了Controller的角色，而所有的Kafka节点就充当着Broker的角色。
下面就来介绍一下搭建过程，这里在1台主机上分别运行Zookeeper和Kafka来模拟一个集群，一共一个Zookeeper节点和三个Kafka节点构成，如下：
节点名地址和端口Zookeeper节点localhost:2181Kafka节点1localhost:9092Kafka节点1localhost:9093Kafka节点1localhost:9094 1、搭建Zookeeper
首先我们要运行起一个Zookeeper节点，这里就不再赘述Zookeeper节点如何搭建了，搭建可以查看官方文档，或者使用Docker的方式搭建。
搭建完成并运行Zookeeper之后，我们会把所有的Kafka节点都配置到这一个Zookeeper节点上。
2、配置并运行所有Kafka节点
修改每台虚拟机的Kafka目录中的配置文件，配置文件位于解压的Kafka文件夹中的config/server.properties，对应的三个配置文件如下：
server1.properties
# 每个节点的id，不要不相同的整数 broker.id=1 # 存储位置 log.dirs=/tmp/kafka-logs/cluster/log1 # zookeeper集群的话，多个地址用逗号分割 zookeeper.connect=localhost:2181 # zookeeper连接超时时间 zookeeper.connection.timeout.ms=18000 # 外网暴露 advertised.listeners=PLAINTEXT://localhost:9092 # 内网端口 listeners=PLAINTEXT://localhost:9092 server2.properties
# 每个节点的id，不要不相同的整数 broker.id=2 # 存储位置 log.dirs=/tmp/kafka-logs/cluster/log2 # zookeeper集群的话，多个地址用逗号分割 zookeeper.connect=localhost:2181 # zookeeper连接超时时间 zookeeper.connection.timeout.ms=18000 # 外网暴露 advertised.listeners=PLAINTEXT://localhost:9093 # 内网端口 listeners=PLAINTEXT://localhost:9093 server3.properties
# 每个节点的id，不要不相同的整数 broker.id=3 # 存储位置 log.dirs=/tmp/kafka-logs/cluster/log3 # zookeeper集群的话，多个地址用逗号分割 zookeeper." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/f9fae99204330b0c1a596974ea145fdf/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-08-14T01:13:23+08:00" />
<meta property="article:modified_time" content="2023-08-14T01:13:23+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Kafka——两种集群搭建详解</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-light">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p></p> 
<div class="toc"> 
 <h4>目录</h4> 
 <ul><li><ul><li><a href="#1_2" rel="nofollow">1、简介</a></li><li><ul><li><a href="#11Kafka_7" rel="nofollow">1.1、Kafka集群中的节点类型</a></li><li><a href="#12_15" rel="nofollow">1.2、两重模式的搭建方式</a></li></ul> 
   </li><li><a href="#2Zookeeper_20" rel="nofollow">2、Zookeeper模式集群</a></li><li><a href="#3KRaft_127" rel="nofollow">3、KRaft模式集群</a></li><li><a href="#4_276" rel="nofollow">4、重要配置介绍</a></li><li><ul><li><a href="#41listeners_278" rel="nofollow">4.1、listeners</a></li><li><a href="#42advertiselisteners_293" rel="nofollow">4.2、advertise.listeners</a></li><li><a href="#43processroles_310" rel="nofollow">4.3、process.roles</a></li><li><a href="#44controllerquorumvoters_336" rel="nofollow">4.4、controller.quorum.voters</a></li><li><a href="#45_350" rel="nofollow">4.5、其它配置</a></li></ul> 
  </li></ul> 
 </li></ul> 
</div> 
<p></p> 
<h3><a id="1_2"></a>1、简介</h3> 
<p>Kafka是一个能够支持高并发以及流式消息处理的消息中间件，并且Kafka天生就是支持集群的，今天就主要来介绍一下如何搭建Kafka集群。</p> 
<p>Kafka目前支持使用Zookeeper模式搭建集群以及KRaft模式（即无Zookeeper）模式这两种模式搭建集群，这两种模式各有各的好处，今天就来分别介绍一下这两种方式</p> 
<h4><a id="11Kafka_7"></a>1.1、Kafka集群中的节点类型</h4> 
<p>一个Kafka集群是由下列几种类型的节点构成的，它们充当着不同的作用：</p> 
<ul><li><code>Broker节点</code>：即代理节点，是Kafka中的工作节点，充当消息队列的角色，负责储存和处理消息，每个Broker都是一个独立的Kafka服务器，可以在不同的机器上运行，除此之外Broker还负责分区（partition）的管理，将主题（topic）划分为多个分区，并分布在集群的不同Broker上</li><li><code>Controller节点</code>：即控制器节点，是集群中的特殊节点，负责储存和管理整个集群元数据和状态，它能够监控整个集群中的Broker，在需要时还能够进行平衡操作</li><li><code>混合节点</code>：即同时担任Broker和Controller节点角色的节点</li></ul> 
<h4><a id="12_15"></a>1.2、两重模式的搭建方式</h4> 
<ul><li>Zookeeper模式集群</li><li>KRaft模式集群</li></ul> 
<h3><a id="2Zookeeper_20"></a>2、Zookeeper模式集群</h3> 
<p>这是一种比较简单，相对“传统”的搭建方式了！在这种模式下，每个Kafka节点都是依赖于Zookeeper的，使用Zookeeper存储集群中所有节点的元数据。</p> 
<p>只要所有的Kafka节点连接到同一个Zookeeper上面（或者同一个Zookeeper集群），这些Kafka节点就构成了一个集群。所以说就算是只有一个Kafka节点在运行，这一个节点也可以称作一个集群。</p> 
<p>在Zookeeper模式集群中，Zookeeper节点（或者集群）就充当了Controller的角色，而所有的Kafka节点就充当着Broker的角色。</p> 
<p>下面就来介绍一下搭建过程，这里在1台主机上分别运行Zookeeper和Kafka来模拟一个集群，一共一个Zookeeper节点和三个Kafka节点构成，如下：</p> 
<table><thead><tr><th align="left">节点名</th><th align="left">地址和端口</th></tr></thead><tbody><tr><td align="left">Zookeeper节点</td><td align="left">localhost:2181</td></tr><tr><td align="left">Kafka节点1</td><td align="left">localhost:9092</td></tr><tr><td align="left">Kafka节点1</td><td align="left">localhost:9093</td></tr><tr><td align="left">Kafka节点1</td><td align="left">localhost:9094</td></tr></tbody></table> 
<blockquote> 
 <p>1、搭建Zookeeper</p> 
</blockquote> 
<p>首先我们要运行起一个Zookeeper节点，这里就不再赘述Zookeeper节点如何搭建了，搭建可以查看官方文档，或者使用Docker的方式搭建。</p> 
<p>搭建完成并运行Zookeeper之后，我们会把所有的Kafka节点都配置到这一个Zookeeper节点上。</p> 
<blockquote> 
 <p>2、配置并运行所有Kafka节点</p> 
</blockquote> 
<p>修改每台虚拟机的Kafka目录中的配置文件，配置文件位于解压的Kafka文件夹中的config/server.properties，对应的三个配置文件如下：</p> 
<p>server1.properties</p> 
<pre><code class="prism language-shell"><span class="token comment"># 每个节点的id，不要不相同的整数</span>
<span class="token assign-left variable">broker.id</span><span class="token operator">=</span><span class="token number">1</span>
<span class="token comment"># 存储位置</span>
<span class="token assign-left variable">log.dirs</span><span class="token operator">=</span>/tmp/kafka-logs/cluster/log1
<span class="token comment"># zookeeper集群的话，多个地址用逗号分割</span>
<span class="token assign-left variable">zookeeper.connect</span><span class="token operator">=</span>localhost:2181
<span class="token comment"># zookeeper连接超时时间</span>
<span class="token assign-left variable">zookeeper.connection.timeout.ms</span><span class="token operator">=</span><span class="token number">18000</span>
<span class="token comment"># 外网暴露</span>
<span class="token assign-left variable">advertised.listeners</span><span class="token operator">=</span>PLAINTEXT://localhost:9092
<span class="token comment"># 内网端口</span>
<span class="token assign-left variable">listeners</span><span class="token operator">=</span>PLAINTEXT://localhost:9092
</code></pre> 
<p>server2.properties</p> 
<pre><code class="prism language-shell"><span class="token comment"># 每个节点的id，不要不相同的整数</span>
<span class="token assign-left variable">broker.id</span><span class="token operator">=</span><span class="token number">2</span>
<span class="token comment"># 存储位置</span>
<span class="token assign-left variable">log.dirs</span><span class="token operator">=</span>/tmp/kafka-logs/cluster/log2
<span class="token comment"># zookeeper集群的话，多个地址用逗号分割</span>
<span class="token assign-left variable">zookeeper.connect</span><span class="token operator">=</span>localhost:2181
<span class="token comment"># zookeeper连接超时时间</span>
<span class="token assign-left variable">zookeeper.connection.timeout.ms</span><span class="token operator">=</span><span class="token number">18000</span>
<span class="token comment"># 外网暴露</span>
<span class="token assign-left variable">advertised.listeners</span><span class="token operator">=</span>PLAINTEXT://localhost:9093
<span class="token comment"># 内网端口</span>
<span class="token assign-left variable">listeners</span><span class="token operator">=</span>PLAINTEXT://localhost:9093
</code></pre> 
<p>server3.properties</p> 
<pre><code class="prism language-shell"><span class="token comment"># 每个节点的id，不要不相同的整数</span>
<span class="token assign-left variable">broker.id</span><span class="token operator">=</span><span class="token number">3</span>
<span class="token comment"># 存储位置</span>
<span class="token assign-left variable">log.dirs</span><span class="token operator">=</span>/tmp/kafka-logs/cluster/log3
<span class="token comment"># zookeeper集群的话，多个地址用逗号分割</span>
<span class="token assign-left variable">zookeeper.connect</span><span class="token operator">=</span>localhost:2181
<span class="token comment"># zookeeper连接超时时间</span>
<span class="token assign-left variable">zookeeper.connection.timeout.ms</span><span class="token operator">=</span><span class="token number">18000</span>
<span class="token comment"># 外网暴露</span>
<span class="token assign-left variable">advertised.listeners</span><span class="token operator">=</span>PLAINTEXT://localhost:9094
<span class="token comment"># 内网端口</span>
<span class="token assign-left variable">listeners</span><span class="token operator">=</span>PLAINTEXT://localhost:9094
</code></pre> 
<p>三台虚拟机配置完成后，分别使用终端进入到Kafka目录下并启动，执行下列命令：</p> 
<pre><code class="prism language-shell">./kafka-server-start.sh <span class="token parameter variable">-daemon</span> <span class="token punctuation">..</span>/config/cluster/server1.properties
./kafka-server-start.sh <span class="token parameter variable">-daemon</span> <span class="token punctuation">..</span>/config/cluster/server2.properties
./kafka-server-start.sh <span class="token parameter variable">-daemon</span> <span class="token punctuation">..</span>/config/cluster/server3.properties
</code></pre> 
<p>到此，整个集群就搭建完成了。</p> 
<blockquote> 
 <p>3、测试</p> 
</blockquote> 
<p>先在kafka1的端口上面再开一个终端并进入Kafka目录，执行下列命令创建cluster-topic，共3个分区，每个人去都分配3个副本：</p> 
<pre><code class="prism language-shell">./kafka-topics.sh --bootstrap-server localhost:9092 <span class="token parameter variable">--create</span> <span class="token parameter variable">--topic</span> cluster-topic <span class="token parameter variable">--partitions</span> <span class="token number">3</span> --replication-factor <span class="token number">3</span>
</code></pre> 
<p>然后在kafka2的端口查询该topic：</p> 
<pre><code class="prism language-shell">./kafka-topics.sh --bootstrap-server localhost:9093 <span class="token parameter variable">--describe</span> <span class="token parameter variable">--topic</span> cluster-topic 
</code></pre> 
<p><img src="https://images2.imgbox.com/59/bc/6AU5Flep_o.png" alt="在这里插入图片描述"><br> 显而易见，该topic下有3个分区，每个分区有三个副本。每个分区的leader分别是1，2，3，表明kafka将该topic的3分区均匀地在3台broker上进行了分配。</p> 
<p>删除分区：</p> 
<pre><code class="prism language-shell">./kafka-topics.sh --bootstrap-server localhost:9093 <span class="token parameter variable">--delete</span> <span class="token parameter variable">--topic</span> cluster-topic 
</code></pre> 
<h3><a id="3KRaft_127"></a>3、KRaft模式集群</h3> 
<p>在上述传统方案中，Kafka需要依赖Zookeeper完成元数据存放和共享，这样也就暴露出了一些问题：</p> 
<ul><li>搭建Kafka集群时还需要额外搭建Zookeeper，增加了运维成本</li><li>Zookeeper是强一致性的组件（符合CP理论），如果集群中数据发生变化，那么必须要等到其它节点都同步，至少超过一半同步完成，这样节点数多性能差</li></ul> 
<p>KRaft模式是新版本Kafka中推出的集群模式，这种模式下就完全不需要Zookeeper了！只需要数个Kafka节点就可以直接构成集群，在这时集群中的Kafka节点既有可能是Controller节点也可能是Broker节点，在这个模式中，我们不仅可以手动配置某个节点的角色（是Controller还是Broker），还可以使其同时担任Broker和Controller角色（混合节点）。</p> 
<p>在KRaft模式中，集群的节点会通过投票选举的方式，选择出一个主要的Controller节点，这个节点也称作领导者，它将负责维护整个集群的元数据和状态信息，那么其它的Controller节点或者混合节点就称之为追随者，它们会从领导者同步集群元数据和状态信息。如果领导者宕机了，所有的节点会重新投票选举一个新的领导者。</p> 
<p>在选举过程中，所有的节点都会参与投票过程，而候选节点只会是Controller节点或者混合节点（即Broker节点不会被选举为领导者）。</p> 
<p>需要注意的是，在默认情况下Kafka集群中的Broker节点和Controller节点通常会监听不同的端口：</p> 
<ul><li>Broker节点是Kafka集群中的数据节点（消息队列），它们负责接收客户端的消息和传递消息给客户端，默认情况下，每个Broker节点会监听9092端口，该端口用于与客户端进行通信，客户端可以将消息发送到这个端口，或者从这个端口接收消息，这个端口可以称作客户端通信端口</li><li>Controller节点是Kafka集群中的控制器节点，负责管理集群的状态和元数据，Controller节点监听的端口通常是9093，该端口用于集群中其他节点获取元数据或在混合节点选举新的Controller时进行通信，通过该端口，其他节点可以与Controller节点交互，获取集群的元数据信息或参与控制器的选举过程，这个端口可以称作控制器端口</li><li>混合节点（即同时担任Broker和Controller角色的节点）中，这两个端口都会被使用，默认情况下混合节点将监听9092端口接收和传递消息给客户端，并监听9093端口用于与其他节点进行元数据交换和控制器选举通信，可见混合节点会同时使用两个端口分别作为客户端通信端口与控制器端口</li></ul> 
<p>所以需要根据实际情况配置网络设置和防火墙规则，以确保Kafka集群中的节点能够在正确的端口上进行通信。上述提到的两种端口也是可以修改的，当然不建议修改。</p> 
<p>同样地，就算是你只是搭建了一个Kafka节点，这一个节点也仍然被视为一个Kafka集群，并且KRaft模式下如果只需要建立一个节点，那么这个节点必须是混合节点。</p> 
<p>单台主机模拟搭建三个Kafka节点构成的KRaft模式集群如下：</p> 
<table><thead><tr><th align="left">节点名</th><th align="left">地址</th><th align="left">节点类型</th><th align="left">客户端通信端口</th><th align="left">控制器端口</th></tr></thead><tbody><tr><td align="left">Kafka节点1</td><td align="left">localhost</td><td align="left">混合节点</td><td align="left">9092</td><td align="left">9093</td></tr><tr><td align="left">Kafka节点2</td><td align="left">localhost</td><td align="left">混合节点</td><td align="left">9094</td><td align="left">9095</td></tr><tr><td align="left">Kafka节点3</td><td align="left">localhost</td><td align="left">混合节点</td><td align="left">9096</td><td align="left">9097</td></tr></tbody></table> 
<blockquote> 
 <p>1、修改配置文件</p> 
</blockquote> 
<p>在KRaft模式下，配置文件位于Kafka目录中的config/kraft/server.properties，使用文本编辑器打开并找到下列配置以修改：</p> 
<ul><li><code>node.id</code> 表示这个节点的id，一个集群中每个节点id不能重复，需要是不小于1的整数，这里三台虚拟机的配置分别为1，2和3（类似上述Zookeeper的broker.id配置）</li><li><code>controller.quorum.voters</code> 设定投票者列表，即需要配置所有的Controller节点id及其地址端口，配置格式为节点1的id@节点1地址:节点1端口,节点2的id@节点2地址:节点2端口,节点3的id@节点3地址:节点3端口…，这里的端口需要是控制器端口，默认都是9093，上面也提到过了，默认不需要修改</li><li><code>advertised.listeners</code> 表示这个Kafka节点的外网地址，这里分别配置为PLAINTEXT://localhost:9092，PLAINTEXT://localhost:9094和PLAINTEXT://localhost:9096（和上述Zookeeper模式中的一样，实际在服务器上搭建时替换为服务器的外网地址或者域名）</li><li>process.roles 表示设定这个节点的类型，设定为broker表示设定这个节点为Broker节点，同样地设定controller表示设定为Controller节点，默认是broker,controller表示这个节点会自动切换节点类型</li></ul> 
<p>server1.properties</p> 
<pre><code class="prism language-shell"><span class="token comment"># 节点类型，默认为混合节点</span>
<span class="token assign-left variable">process.roles</span><span class="token operator">=</span>broker,controller
<span class="token comment"># 节点id，为不小于1的整数</span>
<span class="token assign-left variable">node.id</span><span class="token operator">=</span><span class="token number">1</span>
<span class="token comment"># 投票者列表：nodeId+地址端口</span>
<span class="token assign-left variable">controller.quorum.voters</span><span class="token operator">=</span><span class="token number">1</span>@localhost:9093,2@localhost:9095,3@localhost:9097
<span class="token comment"># 内网地址</span>
<span class="token assign-left variable">listeners</span><span class="token operator">=</span>PLAINTEXT://:9092,CONTROLLER://:9093
<span class="token assign-left variable">inter.broker.listener.name</span><span class="token operator">=</span>PLAINTEXT
<span class="token comment"># 外网地址</span>
<span class="token assign-left variable">advertised.listeners</span><span class="token operator">=</span>PLAINTEXT://localhost:9092
<span class="token assign-left variable">controller.listener.names</span><span class="token operator">=</span>CONTROLLER
<span class="token assign-left variable">log.dirs</span><span class="token operator">=</span>/tmp/kraft-combined-logs/log1
</code></pre> 
<p>server2.properties</p> 
<pre><code class="prism language-shell"><span class="token comment"># 节点类型，默认为混合节点</span>
<span class="token assign-left variable">process.roles</span><span class="token operator">=</span>broker,controller
<span class="token comment"># 节点id，为不小于1的整数</span>
<span class="token assign-left variable">node.id</span><span class="token operator">=</span><span class="token number">2</span>
<span class="token comment"># 投票者列表：nodeId+地址端口</span>
<span class="token assign-left variable">controller.quorum.voters</span><span class="token operator">=</span><span class="token number">1</span>@localhost:9093,2@localhost:9095,3@localhost:9097
<span class="token comment"># 内网地址</span>
<span class="token assign-left variable">listeners</span><span class="token operator">=</span>PLAINTEXT://:9094,CONTROLLER://:9095
<span class="token assign-left variable">inter.broker.listener.name</span><span class="token operator">=</span>PLAINTEXT
<span class="token comment"># 外网地址</span>
<span class="token assign-left variable">advertised.listeners</span><span class="token operator">=</span>PLAINTEXT://localhost:9094
<span class="token assign-left variable">controller.listener.names</span><span class="token operator">=</span>CONTROLLER
<span class="token assign-left variable">log.dirs</span><span class="token operator">=</span>/tmp/kraft-combined-logs/log2
</code></pre> 
<p>server3.properties</p> 
<pre><code class="prism language-shell"><span class="token comment"># 节点类型，默认为混合节点</span>
<span class="token assign-left variable">process.roles</span><span class="token operator">=</span>broker,controller
<span class="token comment"># 节点id，为不小于1的整数</span>
<span class="token assign-left variable">node.id</span><span class="token operator">=</span><span class="token number">3</span>
<span class="token comment"># 投票者列表：nodeId+地址端口</span>
<span class="token assign-left variable">controller.quorum.voters</span><span class="token operator">=</span><span class="token number">1</span>@localhost:9093,2@localhost:9095,3@localhost:9097
<span class="token comment"># 内网地址</span>
<span class="token assign-left variable">listeners</span><span class="token operator">=</span>PLAINTEXT://:9096,CONTROLLER://:9097
<span class="token assign-left variable">inter.broker.listener.name</span><span class="token operator">=</span>PLAINTEXT
<span class="token comment"># 外网地址</span>
<span class="token assign-left variable">advertised.listeners</span><span class="token operator">=</span>PLAINTEXT://localhost:9096
<span class="token assign-left variable">controller.listener.names</span><span class="token operator">=</span>CONTROLLER
<span class="token assign-left variable">log.dirs</span><span class="token operator">=</span>/tmp/kraft-combined-logs/log3
</code></pre> 
<blockquote> 
 <p>2、生成集群ID并使用集群ID格式化数据目录</p> 
</blockquote> 
<p>在KRaft模式下，一个集群需要设定一个id，我们可以使用自带的命令生成，先进入上述任意一台虚拟机并使用终端进入Kafka目录中，执行下列命令生成一个UUID：</p> 
<pre><code class="prism language-shell">bin/kafka-storage.sh random-uuid
</code></pre> 
<p><img src="https://images2.imgbox.com/22/f0/0xuXjbH1_o.png" alt="在这里插入图片描述"><br> 这里记录下这个ID以备用。<code>kilMbKEoRUq3Ha6nruW6Aw</code></p> 
<p>这个集群ID事实上是一个长度16位的字符串通过Base64编码后得来的，因此你也可以不使用上述命令，直接自定义一个16位长度的纯英文和数字组成的字符串，然后将这个字符串编码为Base64格式作为这个集群ID也可以。可以使用菜鸟工具中的在线Base64编码工具。</p> 
<p>然后，分别执行下列命令，配置集群元数据：</p> 
<pre><code class="prism language-shell">kafka-storage.sh <span class="token function">format</span> <span class="token parameter variable">-t</span> 生成的集群ID <span class="token parameter variable">-c</span> <span class="token punctuation">..</span>/config/kraft/cluster/server1.properties
kafka-storage.sh <span class="token function">format</span> <span class="token parameter variable">-t</span> kilMbKEoRUq3Ha6nruW6Aw <span class="token parameter variable">-c</span> <span class="token punctuation">..</span>/config/kraft/cluster/server2.properties
kafka-storage.sh <span class="token function">format</span> <span class="token parameter variable">-t</span> kilMbKEoRUq3Ha6nruW6Aw <span class="token parameter variable">-c</span> <span class="token punctuation">..</span>/config/kraft/cluster/server3.properties
</code></pre> 
<p><img src="https://images2.imgbox.com/db/57/Z9UfoDSS_o.png" alt="在这里插入图片描述"></p> 
<blockquote> 
 <p>3、启动Kafka集群</p> 
</blockquote> 
<p>使用终端，分别执行下列命令：</p> 
<pre><code class="prism language-shell">kafka-server-start.sh <span class="token parameter variable">-daemon</span> <span class="token punctuation">..</span>/config/kraft/cluster/server1.properties
kafka-server-start.sh <span class="token parameter variable">-daemon</span> <span class="token punctuation">..</span>/config/kraft/cluster/server2.properties
kafka-server-start.sh <span class="token parameter variable">-daemon</span> <span class="token punctuation">..</span>/config/kraft/cluster/server3.properties
</code></pre> 
<blockquote> 
 <p>4、创建topic测试</p> 
</blockquote> 
<p>先在kafka1的端口(9092)上面再开一个终端并进入Kafka目录，执行下列命令创建cluster-topic，共3个分区，每个人去都分配3个副本：</p> 
<pre><code class="prism language-shell">./kafka-topics.sh --bootstrap-server localhost:9092 <span class="token parameter variable">--create</span> <span class="token parameter variable">--topic</span> cluster-topic <span class="token parameter variable">--partitions</span> <span class="token number">3</span> --replication-factor <span class="token number">3</span>
</code></pre> 
<p><img src="https://images2.imgbox.com/be/73/Sy19XIVV_o.png" alt="在这里插入图片描述"></p> 
<p>然后在kafka2的端口(9094)查询该topic：</p> 
<pre><code class="prism language-shell">./kafka-topics.sh --bootstrap-server localhost:9094 <span class="token parameter variable">--describe</span> <span class="token parameter variable">--topic</span> cluster-topic 
</code></pre> 
<p><img src="https://images2.imgbox.com/13/70/DohAYcID_o.png" alt="在这里插入图片描述"></p> 
<p>在kafka3的端口(9096)删除分区：</p> 
<pre><code class="prism language-shell">./kafka-topics.sh --bootstrap-server localhost:9096 <span class="token parameter variable">--delete</span> <span class="token parameter variable">--topic</span> cluster-topic 
</code></pre> 
<p>可见集群节点之间可以互相通信。</p> 
<h3><a id="4_276"></a>4、重要配置介绍</h3> 
<h4><a id="41listeners_278"></a>4.1、listeners</h4> 
<p>这个配置项用于指定Kafka服务器监听客户端连接的地址和端口，当 Kafka 服务器启动时，它将监听listeners配置项中指定的地址和端口，等待客户端的连接请求。</p> 
<p>一般情况下这个配置以<code>PLAINTEXT://</code>或者<code>CONTROLLER://</code>开头，意义如下：</p> 
<ul><li>若这个节点是Broker节点，则以PLAINTEXT://开头</li><li>若这个节点是Controller节点，则以CONTROLLER://开头</li><li>若这个节点是混合节点，则需要同时配置两者开头的地址</li></ul> 
<p>这个配置项通常不需要修改，下面给出几个配置示例：</p> 
<ul><li><code>PLAINTEXT://:9092</code> 本节点作为Broker节点，监听本机所有可用网卡的9092端口（使用9092端口作为客户端通信端口），也是默认配置</li><li><code>PLAINTEXT://127.0.0.1:9092</code> 本节点作为Broker节点，监听本地的9092端口，这样仅接受来自本地的请求</li><li><code>CONTROLLER://:10000</code> 本节点作为Controller节点，监听本机所有可用网卡的10000端口（使用10000端口作为控制器端口）</li><li><code>PLAINTEXT://:9092,CONTROLLER://:9093</code> 本节点作为混合节点，监听本机所有可用网卡的9092和9093端口，其中9092作为客户端通信端口，9093作为控制器端口</li></ul> 
<h4><a id="42advertiselisteners_293"></a>4.2、advertise.listeners</h4> 
<p>这个配置容易和listeners混淆，事实上它们是有较大的区别的。</p> 
<p>该配置项指定Kafka服务器广播给客户端的地址和端口，通常配置为Kafka所在服务器的外网地址。</p> 
<p>当客户端（生产者或消费者）尝试连接到Kafka服务器时，它首先会获取Kafka服务器广播的地址和端口，也就是advertise.listeners配置所指定的地址和端口，然后才会使用advertise.listeners配置所指定的地址和端口来建立与Kafka服务器的连接。</p> 
<p>相信这时大家会有个疑问：既然客户端要连接Kafka（例如Spring Boot集成Kafka客户端），那一定是已经知道了Kafka对外的地址端口了，那为什么连接的时候还需要获取一下广播的地址端口再进行连接呢？这样是不是有一些多此一举？</p> 
<p>事实上，Kafka设计这个配置是为了解决下面较为复杂的网络场景：</p> 
<ul><li><code>多网络接口的主机部署</code>：在一个多网络接口的主机部署Kafka时，Kafka服务器可能会监听多个地址和端口，这些地址和端口可能与客户端实际访问的地址和端口不同，advertise.listeners允许服务器指定一个公开的、可访问的地址和端口，以便客户端能够正确连接</li><li><code>NAT/代理环境</code>：在某些网络环境下，Kafka服务器位于一个私有网络中，客户端位于一个公共网络中，两者之间可能存在网络地址转换（NAT）或代理，在这种情况下，Kafka服务器的内部地址和端口对客户端来说是不可访问的。通过使用advertise.listeners，Kafka服务器可以将一个公共地址和端口广播给客户端，使得客户端能够通过公共网络连接到服务器</li><li><code>容器环境</code>：例如你把Kafka放在Docker容器中运行，按照默认配置，Kafka服务端只会监听容器网络的9092端口，我们知道外部不能直接访问容器的网络，而是需要使用网络映射，假设你把Kafka容器的9092端口映射至了宿主机9095端口，也就是说外部需要通过9095端口访问到Kafka容器的9092端口，那么你就配置advertise.listeners为PLAINTEXT://服务器外网地址:9095，客户端就可以正确访问容器中的Kafka了</li></ul> 
<p>总之，这个配置设置为Kafka服务器所在的外网地址即可！例如PLAINTEXT://69.54.112.239:9092。</p> 
<h4><a id="43processroles_310"></a>4.3、process.roles</h4> 
<p>这是KRaft模式下专门的配置，用于配置这个节点的类型，可以配置为下列值：</p> 
<ul><li><code>broker</code> 表示这个节点是Broker节点，充当消息队列的角色</li><li><code>controller</code> 表示这个节点是Controller节点，充当元数据存放和管理的角色</li><li><code>broker,controller</code> 表示这个节点同时担任Broker和Controller的角色，也称作混合节点<br> 如果没有配置这个选项，则Kafka会以Zookeeper模式运行。</li></ul> 
<p>这里有下列注意事项：</p> 
<ul><li>如果设定节点为controller： 
  <ul><li>则不能配置advertised.listeners，可以将其注释掉或者删掉</li><li>listeners需要配置为CONTROLLER://开头，建议配置为CONTROLLER://:9093</li></ul> </li><li>如果设定节点为broker： 
  <ul><li>则需要配置advertised.listeners为服务器外网地址和端口，这和Zookeeper模式中相同</li><li>listeners需要配置为PLAINTEXT://开头，建议配置为PLAINTEXT://:9092</li></ul> </li><li>如果设定节点为混合节点： 
  <ul><li>同样需要配置advertised.listeners为服务器外网地址和端口</li><li>listeners需要同时配置CONTROLLER://和PLAINTEXT://，建议配置为PLAINTEXT://:9092,CONTROLLER://:9093</li></ul> </li></ul> 
<p>在开发环境或者小规模集群，可以全部使用混合节点，如果是生产环境就建议设定好每个节点的类型了！并且通常需要先启动Controller节点再启动Broker节点。</p> 
<p>事实上，我们发现Kafka的KRaft配置目录config/kraft下有三个配置文件，其中server.properties是混合节点的配置模板，而broker.properties和controller.properties分别是Broker节点和Controller节点的配置模板，大家如果要设定节点类型，可以直接使用对应的配置文件，将对应配置文件需要修改的部分修改一下，然后将上述格式化数据目录命令和启动命令中的配置文件路径改变一下即可，这样可以省略我们设定process.roles和listeners或者控制器节点删除advertise.listeners配置的操作。</p> 
<h4><a id="44controllerquorumvoters_336"></a>4.4、controller.quorum.voters</h4> 
<p>该配置项用于配置集群中Controller节点选举过程中的投票者，集群中所有的Controller节点都需要被罗列在这个配置项中，其配置格式为<code>id1@host1:port1,id2@host2:port2,id3@host3:port3...</code>。</p> 
<p>有的同学可能认为这里需要把集群中所有节点都写进去，事实上这是错误的，这里只需要写所有的Controller节点和混合节点的id、地址和端口即可，这个配置中配置的端口当然是控制器端口。</p> 
<p>上述集群搭建的例子中，由于所有的节点都是混合节点，因此就全部写在其中了！如果我们手动设定每个节点的类型，例如：</p> 
<table><thead><tr><th>节点名</th><th>节点<code>id</code></th><th>地址</th><th>服务器通信端口</th><th>控制器端口</th><th>节点类型</th></tr></thead><tbody><tr><td>Kafka节点1</td><td><code>1</code></td><td><code>kafka1</code></td><td>/</td><td><code>9093</code></td><td>Controller</td></tr><tr><td>Kafka节点2</td><td><code>2</code></td><td><code>kafka2</code></td><td><code>9092</code></td><td>/</td><td>Broker</td></tr><tr><td>Kafka节点3</td><td><code>3</code></td><td><code>kafka3</code></td><td><code>9092</code></td><td>/</td><td>Broker</td></tr></tbody></table> 
<p>那么所有节点的controller.quorum.voters都需要配置为1@kafka1:9093。</p> 
<p>事实上，所有的节点都是通过这个配置中的节点列表，来得知所有的控制器节点信息（以获取集群元数据）并得到投票候选者的，因此集群中所有节点，不论是Broker还是Controller，还是混合节点，都需要配置这一项。</p> 
<h4><a id="45_350"></a>4.5、其它配置</h4> 
<p>除了上述我们涉及到的一些配置之外，还有下列配置大家可以进行修改：</p> 
<ul><li><code>socket.send.buffer.bytes</code> 每次发送的数据包的最大大小（单位：字节）</li><li><code>socket.receive.buffer.bytes</code> 每次接收的数据包的最大大小（单位：字节）</li><li><code>socket.request.max.bytes</code> 接收的最大请求大小（单位：字节）</li><li><code>num.partitions</code> 每个Topic的默认分区数</li></ul> 
<p>上述无论是哪个模式的集群，都可以在配置文件中找到这些配置，如果找不到可手动加入。除了修改配置文件之外，我们还可以在启动Kafka的命令中指定配置和值，例如：</p> 
<pre><code class="prism language-shell">bin/kafka-server-start.sh config/server.properties <span class="token parameter variable">--override</span> <span class="token assign-left variable">zookeeper.connect</span><span class="token operator">=</span><span class="token number">127.0</span>.0.1:2181 <span class="token parameter variable">--override</span> <span class="token assign-left variable">broker.id</span><span class="token operator">=</span><span class="token number">1</span>
</code></pre> 
<p>上述命令在启动时通过命令指定了zookeeper.connect配置值为127.0.0.1:2181，以及broker.id为1，可见在后面追加–override 配置名=值即可，注意命令行中指定的配置值会覆盖掉配置文件中的配置值！</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/cbd2b52f4ba8776814ff77650d145134/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">k8s-Kubernetes--集群部署</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/367f90e3dcc66781678f2004df9e895a/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">k8s认证详解 k8s证书详解 2023推荐</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>