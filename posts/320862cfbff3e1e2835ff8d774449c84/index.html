<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>【LInux】MySQL高可用之主从复制 - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="【LInux】MySQL高可用之主从复制" />
<meta property="og:description" content="一、Mysql主从架构技术说明 Mysql内建的复制功能是构建大型，高性能应用程序的基础。将Mysql的数据分布到 多个系统上去，这种分布的机制，是通过将Mysql的某一台主机（Master）的数据复 制到其它主（slaves）上，并重新执行一遍来实现的。 复制过程中一个服务器充当主服务器，而一个或多个其它服务器充当从服务器。主服 务器将更新写入二进制日志文件，这些日志可以记录发送到从服务器的更新。当一个 从服务器连接主服务器时，它通知主服务器从服务器在日志中读取的最后一次成功更 新的位置。从服务器接收从那时起发生的任何更新，然后封锁并等待主服务器通知新的更新。
1. 主从复制架构图 二进制日志也就是binlog.log，它里面记录的数据库的操作；
主机数据库的操作记录在二进制日志里；
从机有两个线程：
I/O线程 用来读取主机上的二进制日志的内容，写入到中继日志（relay_log）SQL线程 将中继日志中的数据读取给从机（因为二进制日志里的内容是sql语句，所以中继日志里的内容也是sql语句，这时候就需要sql线程将中继日志的内容读取，读取后相当于在从机上执行了sql语句，这样实现了主从复制） 2、Mysql复制解决的问题 MySQL复制技术有以下一些特点：
数据分布 (Data distribution )负载平衡(load balancing)备份(Backups)高可用性和容错性 High availabilityand failover 主从复制以及主从复制的作用： 在实际的生产环境中，对数据库的读和写都在同一个数据库服务器中，是不能满足 实际需求的，通过主从复制的方式来同步数据，再通过读写分离来提升数据库的并发 负载能力
3、MySQL主从复制的复制方式 1）异步复制（Asynchronous replication） MySQL的复制默认是异步的，MySQL主从异步复制是最常见的复制场景。数据的完
整性依赖于主库BINLOG的不丢失，只要主库的BINLOG不丢失，那么就算主库宕机
了，我们还可以通过BINLOG把丢失的部分数据通过手工同步到从库上去。
异步复制是指 主库在执行完客户端提交的事务后会立即将结果返给给客户端，并不
关心从库是否已经接收并处理，这样就会有一个问题，主如果crash掉了，此时主上
已经提交的事务可能并没有传到从上，如果此时，强行将从提升为主，可能导致新主
上的数据不完整。
MySQL 默认的复制策略，Master处理事务过程中，将其写入Binlog就会通知Dump thread线程处理，然后完成事务的提交，不会关心是否成功发送到任意一个slave中；
【问题】：一旦Master 崩溃，发送主从切换将会发送数据不一致性的风险。
（也就是主机崩溃了，因为是异步，主机已经不再接受数据了，而从机还在同步就可能导致数据不一致）
画外音：性能最好
2）全同步复制（Fully synchronous replication）/组复制 (MySQL Group Replication（MGR）) 指当主库执行完一个事务，所有的从库都执行了该事务才返回给客户端。因为需要等 待所有从库执行完该事务才能返回，所以全同步复制的性能必然会收到严重的影响。 需要有超时时间。
MySQL在引擎层完成Prepare操作写Redo日志之后，会被MySQL的预设Hook拦截 进入MGR层
MGR层将事务信息打包通过Paxos协议发送到全部节点上，只要集群中过半节点回复 ACK，那么将告诉所有节点数据包同步成功，然后每个节点开始自己认证（certify） 通过就开始写Binlog，提交事务或者写relay log，数据同步，如果认证不通过则 rollback；
什么是Certify？ 在不同服务器上并发执行的事务之间可能存在冲突。这种冲突是通过检查和比 较两个不同的并发事务的写入集来检测的，这个过程称为认证 在认证期间，冲突检测是在行级别执行的：如果在不同服务器上执行的两个并 发事务更新了同一行，则存在冲突。 冲突解决过程指出，首先排序的事务将在所有服务器上提交，而第二次排序的 事务将中止，因此将在原始服务器上回滚并被组中的其他服务器丢弃。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/320862cfbff3e1e2835ff8d774449c84/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-04-17T23:14:41+08:00" />
<meta property="article:modified_time" content="2023-04-17T23:14:41+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">【LInux】MySQL高可用之主从复制</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <h2>一、Mysql主从架构技术说明</h2> 
<blockquote> 
 <p>        <strong>Mysql内建的复制功能是构建大型，高性能应用程序的基础</strong>。将Mysql的数据分布到 多个系统上去，这种分布的机制，是通过将Mysql的某一台主机（Master）的数据复 制到其它主（slaves）上，并重新执行一遍来实现的。 复制过程中一个服务器充当主服务器，而一个或多个其它服务器充当从服务器。主服 务器将更新写入二进制日志文件，这些日志可以记录发送到从服务器的更新。当一个 从服务器连接主服务器时，它通知主服务器从服务器在日志中读取的最后一次成功更 新的位置。从服务器接收从那时起发生的任何更新，然后封锁并等待主服务器通知新的更新。</p> 
</blockquote> 
<h3>1. 主从复制架构图</h3> 
<blockquote> 
 <p><img alt="" height="429" src="https://images2.imgbox.com/ab/e1/UhvosK1C_o.png" width="782"></p> 
 <p>二进制日志也就是binlog.log，它里面记录的数据库的操作；</p> 
 <hr> 
 <p>主机数据库的操作记录在二进制日志里；</p> 
 <hr> 
 <p>从机有两个线程：</p> 
 <ul><li>I/O线程 
   <ul><li>用来读取主机上的二进制日志的内容，写入到中继日志（relay_log）</li></ul></li><li>SQL线程  
   <ul><li>将中继日志中的数据读取给从机（因为二进制日志里的内容是sql语句，所以中继日志里的内容也是sql语句，这时候就需要sql线程将中继日志的内容读取，读取后相当于在从机上执行了sql语句，这样实现了主从复制）</li></ul></li></ul> 
</blockquote> 
<h3>2、Mysql复制解决的问题</h3> 
<blockquote> 
 <p>MySQL复制技术有以下一些特点：</p> 
 <ol><li>数据分布 (Data distribution )</li><li>负载平衡(load balancing)</li><li>备份(Backups)</li><li>高可用性和容错性 High availabilityand failover</li></ol> 
 <hr> 
 <p><strong>主从复制以及主从复制的作用： 在实际的生产环境中，对数据库的读和写都在同一个数据库服务器中，是不能满足 实际需求的，通过主从复制的方式来同步数据，再通过读写分离来提升数据库的并发 负载能力</strong></p> 
</blockquote> 
<h3><strong>3、</strong>MySQL主从复制的复制方式</h3> 
<h4>1）异步复制（Asynchronous replication）</h4> 
<blockquote> 
 <p><strong>MySQL的复制默认是异步的，MySQL主从异步复制是最常见的复制场景</strong>。数据的完<br> 整性依赖于主库BINLOG的不丢失，只要主库的BINLOG不丢失，那么就算主库宕机<br> 了，我们还可以通过BINLOG把丢失的部分数据通过手工同步到从库上去。</p> 
 <hr> 
 <p><strong>异步复制是指 主库在执行完客户端提交的事务后会立即将结果返给给客户端，并不<br> 关心从库是否已经接收并处理</strong>，这样就会有一个问题，主如果crash掉了，此时主上<br> 已经提交的事务可能并没有传到从上，如果此时，强行将从提升为主，可能导致新主<br> 上的数据不完整。</p> 
 <p><img alt="" height="515" src="https://images2.imgbox.com/d0/24/khK8QJxm_o.png" width="709"></p> 
 <p></p> 
 <p>MySQL 默认的复制策略，Master处理事务过程中，将其写入Binlog就会通知Dump thread线程处理，然后完成事务的提交，不会关心是否成功发送到任意一个slave中；</p> 
 <hr> 
 <p><span style="color:#be191c;"><strong>【问题】：一旦Master 崩溃，发送主从切换将会发送数据不一致性的风险。</strong></span></p> 
 <p><span style="color:#0d0016;"><strong>（也就是主机崩溃了，因为是异步，主机已经不再接受数据了，而从机还在同步就可能导致数据不一致）</strong></span></p> 
 <p><strong>  画外音：性能最好</strong></p> 
</blockquote> 
<h4><strong>2）</strong>全同步复制（Fully synchronous replication）/组复制 (MySQL Group Replication（MGR）)</h4> 
<blockquote> 
 <p><strong>指当主库执行完一个事务，所有的从库都执行了该事务才返回给客户端</strong>。因为需要等 待所有从库执行完该事务才能返回，所以全同步复制的性能必然会收到严重的影响。 需要有超时时间。</p> 
 <p></p> 
 <p><img alt="" height="666" src="https://images2.imgbox.com/f8/c5/7DsidGE3_o.png" width="834"></p> 
 <p>MySQL在引擎层完成Prepare操作写Redo日志之后，会被MySQL的预设Hook拦截 进入MGR层</p> 
 <p>MGR层将事务信息打包通过Paxos协议发送到全部节点上，只要集群中过半节点回复 ACK，那么将告诉所有节点数据包同步成功，然后每个节点开始自己认证（certify） 通过就开始写Binlog，提交事务或者写relay log，数据同步，如果认证不通过则 rollback；</p> 
 <hr> 
 <p></p> 
 <p>什么是Certify？ 在不同服务器上并发执行的事务之间可能存在冲突。这种冲突是通过检查和比 较两个不同的并发事务的写入集来检测的，这个过程称为认证 在认证期间，冲突检测是在行级别执行的：如果在不同服务器上执行的两个并 发事务更新了同一行，则存在冲突。 冲突解决过程指出，首先排序的事务将在所有服务器上提交，而第二次排序的 事务将中止，因此将在原始服务器上回滚并被组中的其他服务器丢弃。</p> 
 <hr> 
 <p><span style="color:#be191c;"><strong>总结：MGR内部实现了分布式数据一致性协议，paxos通过其来保证数据一致性。</strong></span></p> 
 <hr> 
 <p><span style="color:#be191c;"><strong>【问题】</strong></span></p> 
 <p>1. 性能不高</p> 
 <p>2. TP999升高，吞吐量降低；增大20%～30%响应时间</p> 
</blockquote> 
<h4>3）半同步复制（Semisynchronous replication）</h4> 
<blockquote> 
 <p><strong>介于异步复制和全同步复制之间，主库在执行完客户端提交的事务后不是立刻返回给 客户端，而是等待至少一个从库接收到并写到relay log中才返回给客户端。</strong>相对于 异步复制，半同步复制提高了数据的安全性，同时它也造成了一定程度的延迟，这个 延迟最少是一个TCP/IP往返的时间。<strong>所以，半同步复制最好在低延时的网络中使用。</strong></p> 
 <hr> 
 <p><img alt="" height="706" src="https://images2.imgbox.com/39/06/a1zg8d02_o.png" width="714"></p> 
 <p> Master处理事务过程中，提交完事务后，必须等至少一个Slave将收到的binlog写入 relay log返回ack才能继续执行处理用户的事务。</p> 
 <hr> 
 <p><span style="color:#be191c;"><strong>【问题】</strong>：</span></p> 
 <ol><li><strong>一旦Ack超时，将退化为异步复制模式，那么异步复制的问题也将发送 </strong></li><li><strong>性能下降，增多至少一个RTT时间 </strong></li><li><strong>数据不一致性问题，因为等待ACK的点是Commit之后，此时Master已经完成 数据变更，用户已经可以看到最新数据，当Binlog还未同步到Slave时，发生主 从切换，那么此时从库是没有这个最新数据的，用户又看到老数据。</strong></li></ol> 
</blockquote> 
<hr> 
<h2>二、Mysql实现企业级数据库主从复制架构实战</h2> 
<h3>1、准备两台服务器</h3> 
<blockquote> 
 <p>centos系统服务器2台、一台用户做Mysql主服务器，一台用于做Mysql从服务器， 都在同一个网段中，配置好yum源、防火墙关闭、各节点时钟服务同步、各节点之间 可以通过主机名互相通信；</p> 
 <hr> 
 <p>•Master_IP:192.168.198.142</p> 
 <p>•Slave_IP:192.168.198.148</p> 
 <hr> 
 <p>注意：MySQL版本号最好一致，为了方便学习测试，建议大家直接克隆之前课 程安装过的虚拟机然后修改下网卡配置文件，重新设置一个IP，<span style="color:#be191c;"><strong>并关闭防火墙</strong></span>。</p> 
</blockquote> 
<h3>2、关闭防火墙和selinux</h3> 
<blockquote> 
 <p>1）临时关闭防火墙，下次启动虚拟机防火墙依旧是开启状态</p> 
 <pre><code>systemctl stop firewalld
</code></pre> 
 <p>2）永久关闭防火墙,下次启动虚拟机防火墙是关闭状态</p> 
 <pre><code>systemctl disable firewalld
</code></pre> 
 <p>3）清理防火墙规则</p> 
 <pre><code> iptables -F
</code></pre> 
 <p>4）关闭selinx</p> 
 <p>① 编辑/etc/sysconfig/selinux文件</p> 
 <pre><code> vim /etc/sysconfig/selinux
</code></pre> 
 <p>将高亮显示的地方改为disabled</p> 
 <p><img alt="" height="308" src="https://images2.imgbox.com/c2/e9/aDazZ6hl_o.png" width="927"></p> 
 <p></p> 
 <p> ② 改完之后重启虚拟机</p> 
 <pre><code>reboot</code></pre> 
 <p>③ 查看selinux状态：</p> 
 <pre><code>getenforce</code></pre> 
 <p><img alt="" height="78" src="https://images2.imgbox.com/cc/1f/IGKbZM6g_o.png" width="744"></p> 
 <p></p> 
</blockquote> 
<h3></h3> 
<h3>3、更改从机的uuid</h3> 
<blockquote> 
 <p>mysql 5.6以后的复制引入了uuid的概念，各个复制结构中的server_uuid得保证不一 样，但是查看到直接copy data文件夹后server_uuid是相同的；</p> 
 <p>① 查看主从机的uuid</p> 
 <pre><code>show variables like '%server_uuid%';
</code></pre> 
 <p><img alt="" height="187" src="https://images2.imgbox.com/13/4e/mqY82Nin_o.png" width="816"></p> 
 <p> <img alt="" height="236" src="https://images2.imgbox.com/0b/6c/QJrs9YRb_o.png" width="873"></p> 
 <p> ② 修改从机的uuid</p> 
 <pre><code>vim /var/lib/mysql/auto.cnf
</code></pre> 
 <p><img alt="" height="142" src="https://images2.imgbox.com/a5/c6/HAIZZuPp_o.png" width="1103"></p> 
 <p> 将原本的24改为25</p> 
 <p><img alt="" height="130" src="https://images2.imgbox.com/d3/9f/Bmyj0mOE_o.png" width="1106"></p> 
 <p><img alt="" height="123" src="https://images2.imgbox.com/51/7b/J1OjmmKt_o.png" width="1118"></p> 
 <p> 修改外之后保存退出；</p> 
 <p>③ 重启mysql服务，重新加载配置</p> 
 <pre><code> systemctl restart mysqld
</code></pre> 
 <p> ④ 查看从机的uuid是否修改成功；</p> 
 <p><img alt="" height="198" src="https://images2.imgbox.com/8a/ad/62rhgiYs_o.png" width="902"></p> 
 <p> 修改成功；</p> 
</blockquote> 
<h3><strong>4、修改master主机配置</strong></h3> 
<blockquote> 
 <p><strong>① 修改配置文件</strong></p> 
 <pre><code>vim /etc/my.cnf</code></pre> 
 <pre><code>[mysqld]
server-id=142        #配置server-id，让主服务器有唯一ID号（让从服务器知道他的主服务器是谁）,建议使用ip最后3位
log-bin=mysql-bin    #打开Mysql日志，日志格式为二进制
skip-name-resolve    #关闭名称解析，（非必须）

</code></pre> 
 <p><img alt="" height="497" src="https://images2.imgbox.com/73/2c/g8pQjGiS_o.png" width="1110"></p> 
 <p> ② 然后重启数据库服务</p> 
 <pre><code> systemctl restart network
</code></pre> 
 <p><img alt="" height="62" src="https://images2.imgbox.com/b1/68/xB6ifIfQ_o.png" width="1076"></p> 
 <p></p> 
</blockquote> 
<h3>5、创建复制帐号</h3> 
<blockquote> 
 <p>在Master的数据库中建立一个备份帐户：每个slave使用标准的MySQL用户名和密码 连接master。进行复制操作的用户会授予REPLICATION SLAVE权限。（给从服务器 授权，让它能从主服务器拷贝二进制日志）</p> 
 <pre><code>create user 'copy'@'%' identified with mysql_native_password by
'Nebula@123';
GRANT REPLICATION SLAVE ON *.* TO 'copy'@'%';
flush privileges;
</code></pre> 
 <p><img alt="" height="276" src="https://images2.imgbox.com/f2/95/h2z17nvH_o.png" width="963"></p> 
 <p></p> 
</blockquote> 
<blockquote> 
 <h3>6、查看主服务器状态</h3> 
 <pre><code>show master status\G;</code></pre> 
 <p><img alt="" height="200" src="https://images2.imgbox.com/e2/46/X31WAnu0_o.png" width="945"></p> 
 <p></p> 
 <p>记录上图结果中File和Position的值。</p> 
 <p><strong>注意：执行完此步骤后不要再操作主服务器MySQL，防止主服务器状态发生状态值变化。</strong> </p> 
</blockquote> 
<p></p> 
<h3>7、配置slave从服务器</h3> 
<blockquote> 
 <p>①  修改配置文件<br>  </p> 
 <pre><code>vim /etc/my.cnf</code></pre> 
 <pre><code>[mysqld]
server-id=148    #配置server-id，让从服务器有唯一ID号,建议使用ip最后3位
relay_log=mysql-relay    #打开Mysql日志，日志格式为二进制
read_only=1    #设置只读权限
log_bin=mysql-bin    #开启从服务器二进制日志
log_slave_updates=1    #使得更新的数据写进二进制日志中
</code></pre> 
 <p><img alt="" height="398" src="https://images2.imgbox.com/c5/aa/AOSRQu3C_o.png" width="1106"></p> 
 <p> ② 然后重启数据库服务</p> 
 <pre><code> systemctl restart mysqld
</code></pre> 
 <p><img alt="" height="120" src="https://images2.imgbox.com/4e/31/nKUzunfm_o.png" width="1010"></p> 
 <p></p> 
</blockquote> 
<h3>8、启动从服务器复制线程</h3> 
<blockquote> 
 <p>①在从机上连接主机</p> 
 <p>【直接复制可能会有莫名其妙的报错，最好手敲一遍】</p> 
 <pre><code>CHANGE MASTER TO
master_host = '192.168.198.142', #主库的IP地址
master_user = 'copy', #在主库上创建的复制账号
master_password = 'Nebula@123', #在主库上创建的复制账号密码
master_log_file = 'mysql-bin.000004', #开始复制的二进制文件名（从主库查询结果中获取）
master_log_pos = 773; #开始复制的二进制文件位置（从主
库查询结果中获取）
</code></pre> 
 <p><img alt="" height="154" src="https://images2.imgbox.com/8d/e7/YVsddkeD_o.png" width="796"></p> 
 <p></p> 
 <p> ② 执行start slave；# 启动复制线程。</p> 
 <p><img alt="" height="63" src="https://images2.imgbox.com/5d/30/ND76245G_o.png" width="912"></p> 
 <p> ③ 出现红框的内容，表示主从复制配置成功</p> 
 <p><img alt="" height="525" src="https://images2.imgbox.com/f4/0c/RGnCZSLB_o.png" width="900"></p> 
 <p> ④ 测试主从复制是否成功</p> 
 <p>Master中和Slave中执行SQL：</p> 
 <pre><code> show databases;
</code></pre> 
 <p>Master：</p> 
 <p><img alt="" height="258" src="https://images2.imgbox.com/66/50/TYv1zbAi_o.png" width="788"></p> 
 <p> Slave：</p> 
 <p><img alt="" height="265" src="https://images2.imgbox.com/36/6a/dg5E8UUf_o.png" width="798"></p> 
 <p> 在Master中创建数据库并创建数据表并插入一条数据：</p> 
 <pre><code>create database copy_test2;
use copy_test2;
create table tab1(id int auto_increment,name varchar(10),primary
key(id));
insert into tab1(id,name) values (1,'why');
</code></pre> 
 <p><img alt="" height="308" src="https://images2.imgbox.com/a9/89/SUg1T8TB_o.png" width="1200"></p> 
 <p>⑥ 查看主从机是否都有copy_test2数据库；</p> 
 <p><img alt="" height="352" src="https://images2.imgbox.com/6d/4a/uWyBPjRu_o.png" width="812"> <img alt="" height="342" src="https://images2.imgbox.com/50/28/IdyXxCuv_o.png" width="900"></p> 
</blockquote> 
<h3>9、mysql 主从数据不一致,提示：Slave_SQL_Running: No 的解决方法</h3> 
<blockquote> 
 <p>在slave服务器上通过如下命令：</p> 
 <pre><code>show slave status\G;</code></pre> 
 <p>效果如下图所示，表示slave不同步</p> 
 <p><img alt="" height="315" src="https://images2.imgbox.com/25/f4/9XnlNrfs_o.png" width="697"></p> 
 <p> <strong><span style="background-color:#ffd900;">解决方法(忽略错误，继续同步)：</span></strong></p> 
 <p>① 先停掉slave</p> 
 <pre><code>stop slave;</code></pre> 
 <p>② 跳过错误步数，后面步数可变</p> 
 <pre><code>set global sql_slave_skip_counter=1;</code></pre> 
 <p>③ 再启动slave</p> 
 <pre><code>start slave;</code></pre> 
 <p>④ 查看同步状态</p> 
 <pre><code>show slave status\G;</code></pre> 
 <p><img alt="" height="54" src="https://images2.imgbox.com/97/9a/ASoUUeK4_o.png" width="309"></p> 
 <p></p> 
</blockquote>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/8b83e60e41cf59c7083e18cbdc675300/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">用bp神经网络实现单目测距（训练教程&#43;推理程序&#43;exe实现）</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/e436c75e7292f9523ac84b7284f47eb7/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">Linux配置多版本JDK</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>