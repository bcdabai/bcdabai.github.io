<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>socket编程之accept() - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="socket编程之accept()" />
<meta property="og:description" content="4 accept() 用于接收监听套接字中保存的套接字连接。它提取监听套接字 sockfd 的挂起连接队列上的第一个连接请求，创建一个新的已连接套接字，并返回引用该套接字的新文件描述符。accept()执行的系统调用并不会对原始的监听套接字产生任何其他影响。
4.1 包含头文件 #include &lt;sys/types.h&gt; #include &lt;sys/socket.h&gt; 4.2 函数主体 int accept(int sockfd, struct sockaddr *addr, socklen_t *addrlen); int accept4(int sockfd, struct sockaddr *addr, socklen_t *addrlen, int flags); 参数解释：
int sockfd ​ 参数sockfd必须是指向执行listen()调用以后的监听套接字
struct sockaddr *addr ​ 参数 addr 是指向 sockaddr 结构的指针。 此结构用已知的对等套接字的地址填充。返回地址 addr 的确切格式由套接字的地址系列决定（在socket()函数中指定的）。需要注意的是，该地址返回的是客户端的外网IP，而客户端使用的IP一般均为内网IP，所以我们根据这个地址返回的IP是访问不到客户端主机的。如果addr设置为NULL时，表示不关心客户端的地址，addrlen也应该设置为NULL。
socklen_t *addrlen ​ addrlen类一个特殊的参数，传入参数为调用者提供的缓存区，而传出参数为客户端地址结构体的实际长度，因此，每次调用accept()之前都应该为该参数赋初值。如果提供的缓冲区太小，则返回的地址将被截断;在这种情况下，addrlen 将返回一个大于提供给调用的值。
int flags ​ 这个参数时accept4()所特有的，当flags = 0时，accept()和accept4()是完全相同的。但该参数还可以传递以下两个参数，以实现对socket()的进一步控制：SOCK_NONBLOCK、SOCK_CLOEXECS，这两个参数的含义在第1小节socket()中已经说明，此处不再赘述。
对accept()作进一步补充：
accept()为阻塞型函数，如果队列上不存在挂起的连接，并且套接字未标记为非阻塞，则 accept（） 将阻塞调用进程，直到存在连接为止。 如果套接字标记为非阻塞，并且队列上不存在挂起的连接，则 accept（） 将失败，并显示错误 EAGAIN 或 EWOULDBLOCK。如果不想设置套接字为非阻塞但又需要在调用accept()时避免对进程造成阻塞，则可以选择使用 select()、poll() 或 epoll()，这些函数会有新连接传入是通知调用者有可读事件，然后就可以调用accept()函数了。对于select()、poll() 或 epoll()函数会在IO复用专栏进行说明。 4." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/65e15b680feffab594ea544afd44376e/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-09-08T20:52:17+08:00" />
<meta property="article:modified_time" content="2022-09-08T20:52:17+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">socket编程之accept()</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-light">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <h3><a id="4_accept_0"></a>4 accept()</h3> 
<p>用于接收监听套接字中保存的套接字连接。它提取监听套接字 sockfd 的挂起连接队列上的第一个连接请求，创建一个新的已连接套接字，并返回引用该套接字的新文件描述符。accept()执行的系统调用并不会对原始的监听套接字产生任何其他影响。</p> 
<h5><a id="41__4"></a>4.1 包含头文件</h5> 
<pre><code class="prism language-c++">#include &lt;sys/types.h&gt;       
#include &lt;sys/socket.h&gt;
</code></pre> 
<h5><a id="42__11"></a>4.2 函数主体</h5> 
<pre><code class="prism language-c++">int accept(int sockfd, struct sockaddr *addr, socklen_t *addrlen);
int accept4(int sockfd, struct sockaddr *addr, socklen_t *addrlen, int flags);
</code></pre> 
<p><strong>参数解释：</strong></p> 
<ul><li><strong>int sockfd</strong></li></ul> 
<p>​ 参数sockfd必须是指向执行listen()调用以后的监听套接字</p> 
<ul><li><strong>struct sockaddr *addr</strong></li></ul> 
<p>​ 参数 addr 是指向 sockaddr 结构的指针。 此结构用已知的对等套接字的地址填充。返回地址 addr 的确切格式由套接字的地址系列决定（在socket()函数中指定的）。需要注意的是，该地址返回的是客户端的<strong>外网IP</strong>，而客户端使用的IP一般均为<strong>内网IP</strong>，所以我们根据这个地址返回的IP是访问不到客户端主机的。如果addr设置为NULL时，表示不关心客户端的地址，addrlen也应该设置为NULL。</p> 
<ul><li><strong>socklen_t *addrlen</strong></li></ul> 
<p>​ addrlen类一个特殊的参数，传入参数为调用者提供的缓存区，而传出参数为客户端地址结构体的实际长度，因此，每次调用accept()之前都应该<strong>为该参数赋初值</strong>。如果提供的缓冲区太小，则返回的地址将被截断;在这种情况下，addrlen 将返回一个大于提供给调用的值。</p> 
<ul><li><strong>int</strong> <strong>flags</strong></li></ul> 
<p>​ 这个参数时accept4()所特有的，当flags = 0时，accept()和accept4()是完全相同的。但该参数还可以传递以下两个参数，以实现对socket()的进一步控制：<strong>SOCK_NONBLOCK、SOCK_CLOEXECS</strong>，这两个参数的含义在第1小节socket()中已经说明，此处不再赘述。</p> 
<p>对accept()作进一步补充：</p> 
<ol><li>accept()为<strong>阻塞型</strong>函数，如果队列上不存在挂起的连接，并且套接字未标记为非阻塞，则 accept（） 将阻塞调用进程，直到存在连接为止。 如果套接字标记为非阻塞，并且队列上不存在挂起的连接，则 accept（） 将失败，并显示错误 EAGAIN 或 EWOULDBLOCK。</li><li>如果不想设置套接字为非阻塞但又需要在调用accept()时避免对进程造成阻塞，则可以选择使用 <strong>select()、poll() 或 epoll()</strong>，这些函数会有新连接传入是通知调用者有可读事件，然后就可以调用accept()函数了。对于select()、poll() 或 epoll()函数会在IO复用专栏进行说明。</li></ol> 
<h5><a id="43__41"></a><strong>4.3 返回值</strong></h5> 
<p>​ 调用成功时函数返回一个非负整数，该整数是已接受套接字的文件描述符。调用失败时，返回-1，错误类型如下：</p> 
<table><thead><tr><th>错误类型</th><th>解释</th></tr></thead><tbody><tr><td>EAGAIN或者EWOULDBLOCK</td><td>套接字被标记为非阻塞,且当前没有可接收的连接.</td></tr><tr><td>EBADF</td><td>描述符非法</td></tr><tr><td>ENOTSOC</td><td>描述符指向一个文件,而不是一个套接字</td></tr><tr><td>EOPNOTSUPP</td><td>作为参数的套接字不是 **SOCK_STREAM.**类型</td></tr><tr><td>EFAULT</td><td>参数 <em>addr</em> 不在用户可写地址空间之内.</td></tr><tr><td>EPERM</td><td>防火墙规则禁止连接</td></tr><tr><td>ENOBUFS,ENOMEM</td><td>没有足够内存. 这个错误一般来说意味着内存分配受套接字缓冲区所限, 而不是没有系统内存.</td></tr><tr><td>EINVAL</td><td>非监听套接字，或者 addrlen 无效（例如，为负数）。</td></tr><tr><td>ECONNABORTED</td><td>连接以中止</td></tr></tbody></table> 
<h5><a id="44__57"></a><strong>4.4 结束</strong></h5> 
<p>在 Linux 上，accept（） 返回的新套接字不会从侦听套接字继承文件状态标志，如O_NONBLOCK和O_ASYNC。若对返回的新套接字有相关要要求，需要重新设置所有必需的标志。本接提到的内容代码实现可以参考第2节bind()中代码。</p> 
<p>另外，最后对可能出现所有错误类新做一个总结，可以在文件 /usr/include/sys/errno.h 中找到 Errno。</p> 
<p><img src="https://images2.imgbox.com/aa/2e/5fiiVlH9_o.png" alt="在这里插入图片描述"></p> 
<p>参考：<a href="https://www.cnblogs.com/qq78292959/archive/2013/04/22/3036103.html" rel="nofollow">常见的错误码</a><br> 所讲的函数以及应用：<a href="https://blog.csdn.net/suren_jun/article/details/126689425?spm=1001.2014.3001.5501">代码传送门</a></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/747490b9bb586d091bfb9eee19b37236/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">JavaScript 中常用事件有哪些？</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/7fdc19e5128376780b11376e3d009942/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">深度学习目标检测——AP以及MAP</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>