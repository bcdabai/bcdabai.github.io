<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>排序算法进阶——归并排序【详细图解，递归和非递归】 - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="排序算法进阶——归并排序【详细图解，递归和非递归】" />
<meta property="og:description" content="文章目录 归并算法基本思想：具体代码实现： 归并排序基本思想方法一：递归实现方法：完整代码： 方法二：利用下标变化直接在数组中归并【非递归】实现方法：完整代码： 归并排序的时间复杂度归并排序的空间复杂度归并排序的稳定性 归并算法 在了解归并排序之前让我们先了解一下归并这一算法吧！
归并算法一般应用于合并两个已经有序的序列，使合并后的序列也有序，是一个时间复杂度为O（N）的算法，不过一般要借助两个要排序的序列的元素个数个额外的空间。
一一一一一一一一一一一一一一一一一一一一一一一一一一一一一一一一一一一一一一一一
基本思想： 既然要排序的两个序列已经有序，那么就可以先申请两个序列元素之和大小的空间，再比较两个序列的第一个元素的大小，将小的那一个元素放在申请的空间的第一个【假设排升序】，再让放入的那个元素之后的一个元素与那个第一次比较时没放入的元素比较,再把小的那一个放入申请空间的第二个位置上…
直到有有一个序列已经全部放入了申请的空间，此时另一序列的剩下的元素都大于放完序列的最大值，所以可以直接将它剩下的元素全部放入申请空间。
如下图
一一一一一一一一一一一一一一一一一一一一一一一一一一一一一一一一一一一一一一一一
具体代码实现： 定义两个指针指向两个序列的第一个元素，如果左侧序列的指针指向的元素更小就把它放入申请的空间，否则将右侧序列的元素放入申请空间
借此构成一个循环，循环结束条件是两个指针中有一个指向序列的最后一个元素之后就结束
一一一一一一一一一一一一一一一一一一一一一一一一一一一一一一一一一一一一一一一一
归并排序 基本思想 有了归并算法后，我们知道只要要排序的两个序列是有序的我们就可以轻松地排出一个有序序列
同理如果将一个序列分成两半，如果它坐边有序右边也有序，就可以直接用归并算法整个序列有序。
那么怎么让左右两边的序列有序呢？
我们知道如果序列中只有一个序列时那它肯定是有许的，既然如此，
我们让要排序列的左侧序列和右侧的元素个数为1
此时，不就左右有序可以归并了吗。
如何完成这个操作呢？
有两个方法
一一一一一一一一一一一一一一一一一一一一一一一一一一一一一一一一一一一一一一一一
方法一：递归 将序列分成两半在，分成的两半再分别分成两半…。直到左序列和右序列的元素个数都为1时再从小区间归并到大区间
如下图
该过程可用递归实现。
一一一一一一一一一一一一一一一一一一一一一一一一一一一一一一一一一一一一一一一一
实现方法： 先申请于序列等大的空间，再创建用于递归的函数
再实现递归函数
先将左右区间递归到都只有一个元素
浅浅画了一下递归展开图
left=2,right=3时也类似
做完以上的递归之后，左右区间的元素个数就都只有1了（如上图的左区间【0-0】，右区间【1~1】），此时从大区间向小区间的递归就结束了
然后开始向下执行代码，进行归并，
小区间时的代码执行完后，会自动返回到调用这一小区间的位置，即更大的区间的函数中，继续向下执行代码
具体过程可参考下图【注意：left和right是下标】
一一一一一一一一一一一一一一一一一一一一一一一一一一一一一一一一一一一一一一一一
完整代码： void D_MereSort(int a[], int left, int right, int* tmp) { //left和right分别为递归区间的左右端点的下标 //把要归并的两边的区间递归到各只有1个元素就停 if (left &gt;= right) return; //mid为递归区间中间下标 int mid = (left &#43; right) / 2; //递归 D_MereSort(a, left, mid, tmp); D_MereSort(a, mid&#43;1, right, tmp); //定义begin和end接受left和right //防止left和right改变，导致出错 int begin1 = left, end1 = mid; int begin2 = mid&#43;1, end2 = right; //i必须有且值只能是 左侧区间的左端点 即left int i = left; //归并算法 while (begin1 &lt;= end1 &amp;&amp; begin2 &lt;=end2) { if (a[begin1] &lt; a[begin2]) { tmp[i&#43;&#43;] = a[begin1&#43;&#43;]; } else { tmp[i&#43;&#43;] = a[begin2&#43;&#43;]; } } while (begin1 &lt;= end1) { tmp[i&#43;&#43;] = a[begin1&#43;&#43;]; } while (begin2 &lt;= end2) { tmp[i&#43;&#43;] = a[begin2&#43;&#43;]; } int j = left; //将归并好的放回要排序的数组 for (; j&lt;=right; j&#43;&#43;) a[j] = tmp[j]; } //归并排序（递归） void MergeSort1(int a[], int n) { //创建临时空间，方便归并 int* tmp = (int*)malloc(sizeof(int) * n); //用于递归的函数 D_MereSort(a, 0, n - 1, tmp); //释放申请空间 free(tmp); } 一一一一一一一一一一一一一一一一一一一一一一一一一一一一一一一一一一一一一一一一" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/a441700637fb8347ce97e069f8b01092/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2024-01-23T17:28:58+08:00" />
<meta property="article:modified_time" content="2024-01-23T17:28:58+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">排序算法进阶——归并排序【详细图解，递归和非递归】</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p></p> 
<div class="toc"> 
 <h4>文章目录</h4> 
 <ul><li><a href="#_2" rel="nofollow">归并算法</a></li><li><ul><li><a href="#_9" rel="nofollow">基本思想：</a></li><li><a href="#_21" rel="nofollow">具体代码实现：</a></li></ul> 
  </li><li><a href="#_30" rel="nofollow">归并排序</a></li><li><ul><li><a href="#_32" rel="nofollow">基本思想</a></li><li><a href="#_50" rel="nofollow">方法一：递归</a></li><li><ul><li><a href="#_59" rel="nofollow">实现方法：</a></li><li><a href="#_87" rel="nofollow">完整代码：</a></li></ul> 
   </li><li><a href="#_152" rel="nofollow">方法二：利用下标变化直接在数组中归并【非递归】</a></li><li><ul><li><a href="#_158" rel="nofollow">实现方法：</a></li><li><a href="#_180" rel="nofollow">完整代码：</a></li></ul> 
  </li></ul> 
  </li><li><a href="#_239" rel="nofollow">归并排序的时间复杂度</a></li><li><a href="#_252" rel="nofollow">归并排序的空间复杂度</a></li><li><a href="#_261" rel="nofollow">归并排序的稳定性</a></li></ul> 
</div> 
<p></p> 
<h2><a id="_2"></a>归并算法</h2> 
<p>在了解归并排序之前让我们先了解一下归并这一算法吧！</p> 
<p>归并算法一般应用于合并两个已经有序的序列，使合并后的序列也有序，是一个时间复杂度为O（N）的算法，不过一般要借助两个要排序的序列的元素个数个额外的空间。</p> 
<p>一一一一一一一一一一一一一一一一一一一一一一一一一一一一一一一一一一一一一一一一</p> 
<h3><a id="_9"></a>基本思想：</h3> 
<p>既然要排序的两个序列已经有序，那么就可以先申请<mark>两个序列元素之和大小的空间</mark>，再比较两个序列的第一个元素的大小，将小的那一个元素放在申请的空间的第一个【假设排升序】，再让放入的那个元素之后的一个元素与那个第一次比较时没放入的元素比较,再把小的那一个放入申请空间的第二个位置上…</p> 
<p><mark>直到有有一个序列已经全部放入了申请的空间</mark>，此时另一序列的剩下的元素都大于放完序列的最大值，所以可以直接将它剩下的元素全部放入申请空间。</p> 
<p>如下图<br> <img src="https://images2.imgbox.com/69/d1/VCoGAxKM_o.png" alt="在这里插入图片描述"></p> 
<p>一一一一一一一一一一一一一一一一一一一一一一一一一一一一一一一一一一一一一一一一</p> 
<h3><a id="_21"></a>具体代码实现：</h3> 
<p>定义两个指针指向两个序列的第一个元素，如果左侧序列的指针指向的元素更小就把它放入申请的空间，<mark>否则</mark>将右侧序列的元素放入申请空间<br> 借此构成一个循环，循环结束条件是两个指针中<mark>有一个</mark>指向序列的最后一个元素之后就结束</p> 
<p><img src="https://images2.imgbox.com/85/f9/tz4Lcqi6_o.png" alt="在这里插入图片描述"><br> 一一一一一一一一一一一一一一一一一一一一一一一一一一一一一一一一一一一一一一一一</p> 
<h2><a id="_30"></a>归并排序</h2> 
<h3><a id="_32"></a>基本思想</h3> 
<p>有了归并算法后，我们知道只要要排序的两个序列是有序的我们就可以轻松地排出一个有序序列</p> 
<p>同理如果将一个序列分成两半，如果它坐边有序右边也有序，就可以直接用归并算法整个序列有序。<br> 那么怎么让左右两边的序列有序呢？<br> 我们知道如果序列中只有一个序列时那它肯定是有许的，既然如此，<br> <mark>我们让要排序列的左侧序列和右侧的元素个数为1</mark><br> 此时，不就左右有序可以归并了吗。</p> 
<p>如何完成这个操作呢？</p> 
<p>有两个方法</p> 
<p>一一一一一一一一一一一一一一一一一一一一一一一一一一一一一一一一一一一一一一一一</p> 
<h3><a id="_50"></a>方法一：递归</h3> 
<p>将序列分成两半在，分成的两半再分别分成两半…。直到左序列和右序列的元素个数都为1时再<mark>从小区间归并到大区间</mark><br> 如下图</p> 
<p><img src="https://images2.imgbox.com/01/b7/fXTF5jtB_o.jpg" alt="请添加图片描述"><br> 该过程可用递归实现。</p> 
<p>一一一一一一一一一一一一一一一一一一一一一一一一一一一一一一一一一一一一一一一一</p> 
<h4><a id="_59"></a>实现方法：</h4> 
<p>先申请于序列等大的空间，再创建用于递归的函数<br> <img src="https://images2.imgbox.com/cd/4e/8y6PfiyY_o.png" alt="在这里插入图片描述"><br> 再实现递归函数</p> 
<p>先将左右区间递归到都只有一个元素<br> <img src="https://images2.imgbox.com/2a/b6/oQ5Ifjvj_o.png" alt="在这里插入图片描述"></p> 
<p>浅浅画了一下递归展开图<br> <img src="https://images2.imgbox.com/d3/7b/QmcqADVg_o.png" alt="在这里插入图片描述"></p> 
<p><img src="https://images2.imgbox.com/8b/f0/NMycSD9O_o.png" alt="在这里插入图片描述"><br> <mark>left=2,right=3时也类似</mark></p> 
<p>做完以上的递归之后，左右区间的元素个数就都只有1了（如上图的左区间【0-0】，右区间【1~1】），此时<mark>从大区间向小区间的递归就结束了</mark><br> 然后开始向下执行代码，进行归并，<br> <mark>小区间时的代码执行完后，会自动返回到调用这一小区间的位置，即更大的区间的函数中，继续向下执行代码</mark></p> 
<p><img src="https://images2.imgbox.com/d3/e9/7RSp2RJ4_o.png" alt="在这里插入图片描述"><br> <img src="https://images2.imgbox.com/3c/73/RPhYQjeE_o.png" alt="在这里插入图片描述"><br> 具体过程可参考下图【<mark>注意：left和right是下标</mark>】<br> <img src="https://images2.imgbox.com/16/44/2cztMogl_o.png" alt="在这里插入图片描述"><br> <img src="https://images2.imgbox.com/15/d7/LWB61A2x_o.png" alt="在这里插入图片描述"><br> 一一一一一一一一一一一一一一一一一一一一一一一一一一一一一一一一一一一一一一一一</p> 
<h4><a id="_87"></a>完整代码：</h4> 
<pre><code class="prism language-c"><span class="token keyword">void</span> <span class="token function">D_MereSort</span><span class="token punctuation">(</span><span class="token keyword">int</span> a<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token keyword">int</span> left<span class="token punctuation">,</span> <span class="token keyword">int</span> right<span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token operator">*</span> tmp<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token comment">//left和right分别为递归区间的左右端点的下标</span>
	<span class="token comment">//把要归并的两边的区间递归到各只有1个元素就停</span>
	<span class="token keyword">if</span> <span class="token punctuation">(</span>left <span class="token operator">&gt;=</span> right<span class="token punctuation">)</span>
		<span class="token keyword">return</span><span class="token punctuation">;</span>
	<span class="token comment">//mid为递归区间中间下标</span>
	<span class="token keyword">int</span> mid <span class="token operator">=</span> <span class="token punctuation">(</span>left <span class="token operator">+</span> right<span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">;</span>

	<span class="token comment">//递归</span>
	<span class="token function">D_MereSort</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> left<span class="token punctuation">,</span> mid<span class="token punctuation">,</span> tmp<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token function">D_MereSort</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> mid<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span> right<span class="token punctuation">,</span> tmp<span class="token punctuation">)</span><span class="token punctuation">;</span>

	<span class="token comment">//定义begin和end接受left和right</span>
	<span class="token comment">//防止left和right改变，导致出错</span>
	<span class="token keyword">int</span> begin1 <span class="token operator">=</span> left<span class="token punctuation">,</span> end1 <span class="token operator">=</span> mid<span class="token punctuation">;</span>
	<span class="token keyword">int</span> begin2 <span class="token operator">=</span> mid<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span> end2 <span class="token operator">=</span> right<span class="token punctuation">;</span>
	<span class="token comment">//i必须有且值只能是  左侧区间的左端点  即left</span>
	<span class="token keyword">int</span> i <span class="token operator">=</span> left<span class="token punctuation">;</span>

	<span class="token comment">//归并算法</span>
	<span class="token keyword">while</span> <span class="token punctuation">(</span>begin1 <span class="token operator">&lt;=</span> end1 <span class="token operator">&amp;&amp;</span> begin2 <span class="token operator">&lt;=</span>end2<span class="token punctuation">)</span>
	<span class="token punctuation">{<!-- --></span>
		<span class="token keyword">if</span> <span class="token punctuation">(</span>a<span class="token punctuation">[</span>begin1<span class="token punctuation">]</span> <span class="token operator">&lt;</span> a<span class="token punctuation">[</span>begin2<span class="token punctuation">]</span><span class="token punctuation">)</span>
		<span class="token punctuation">{<!-- --></span>
			tmp<span class="token punctuation">[</span>i<span class="token operator">++</span><span class="token punctuation">]</span> <span class="token operator">=</span> a<span class="token punctuation">[</span>begin1<span class="token operator">++</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
		<span class="token keyword">else</span>
		<span class="token punctuation">{<!-- --></span>
			tmp<span class="token punctuation">[</span>i<span class="token operator">++</span><span class="token punctuation">]</span> <span class="token operator">=</span> a<span class="token punctuation">[</span>begin2<span class="token operator">++</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
	<span class="token punctuation">}</span>
	<span class="token keyword">while</span> <span class="token punctuation">(</span>begin1 <span class="token operator">&lt;=</span> end1<span class="token punctuation">)</span>
	<span class="token punctuation">{<!-- --></span>
		tmp<span class="token punctuation">[</span>i<span class="token operator">++</span><span class="token punctuation">]</span> <span class="token operator">=</span> a<span class="token punctuation">[</span>begin1<span class="token operator">++</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
	<span class="token keyword">while</span> <span class="token punctuation">(</span>begin2 <span class="token operator">&lt;=</span> end2<span class="token punctuation">)</span>
	<span class="token punctuation">{<!-- --></span>
		tmp<span class="token punctuation">[</span>i<span class="token operator">++</span><span class="token punctuation">]</span> <span class="token operator">=</span> a<span class="token punctuation">[</span>begin2<span class="token operator">++</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
	<span class="token keyword">int</span> j <span class="token operator">=</span> left<span class="token punctuation">;</span>
	<span class="token comment">//将归并好的放回要排序的数组</span>
	<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token punctuation">;</span> j<span class="token operator">&lt;=</span>right<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span>
		a<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> tmp<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment">//归并排序（递归）</span>
<span class="token keyword">void</span> <span class="token function">MergeSort1</span><span class="token punctuation">(</span><span class="token keyword">int</span> a<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token keyword">int</span> n<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token comment">//创建临时空间，方便归并</span>
	<span class="token keyword">int</span><span class="token operator">*</span> tmp <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">int</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token function">malloc</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span> <span class="token operator">*</span> n<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token comment">//用于递归的函数</span>
	<span class="token function">D_MereSort</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">,</span> tmp<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token comment">//释放申请空间</span>
	<span class="token function">free</span><span class="token punctuation">(</span>tmp<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

</code></pre> 
<p>一一一一一一一一一一一一一一一一一一一一一一一一一一一一一一一一一一一一一一一一</p> 
<h3><a id="_152"></a>方法二：利用下标变化直接在数组中归并【非递归】</h3> 
<p>如下图<br> <img src="https://images2.imgbox.com/46/a7/eoJWnYRp_o.png" alt="在这里插入图片描述"></p> 
<h4><a id="_158"></a>实现方法：</h4> 
<p>设gap为左右区间的元素个数<br> j为<mark>循环变化的下标</mark>，这样可以将<br> 归并的区间划分为<br> <mark>【i，i+gap-1】【i+gap,i+2*gap-1】</mark><br> <img src="https://images2.imgbox.com/3a/19/v3dCMxfe_o.png" alt="在这里插入图片描述"><br> 将区间划分为【i，i+gap-1】【i+gap,i+2*gap-1】<br> 可能会出现越界的情况</p> 
<ul><li>其中i+gap-1越界和i+gap越界的处理方法相同</li><li>i+2*gap-1<br> 如下图<br> <img src="https://images2.imgbox.com/bd/a0/bBnsT9TC_o.png" alt="在这里插入图片描述"></li></ul> 
<p><img src="https://images2.imgbox.com/04/7a/8EVA19rQ_o.png" alt="在这里插入图片描述"></p> 
<p><img src="https://images2.imgbox.com/5f/d7/S5RQRSRB_o.png" alt="在这里插入图片描述"><br> 一一一一一一一一一一一一一一一一一一一一一一一一一一一一一一一一一一一一一一一一</p> 
<h4><a id="_180"></a>完整代码：</h4> 
<pre><code class="prism language-c"><span class="token keyword">void</span> <span class="token function">MergeSort2</span><span class="token punctuation">(</span><span class="token keyword">int</span> a<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token keyword">int</span> n<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token comment">//申请空间</span>
	<span class="token keyword">int</span><span class="token operator">*</span> tmp <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">int</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token function">malloc</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span> <span class="token operator">*</span> n<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token comment">//gap表示归并的左右区间的元素个数</span>
	<span class="token keyword">int</span> gap <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
	<span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
	<span class="token keyword">while</span> <span class="token punctuation">(</span>gap <span class="token operator">&lt;</span> n<span class="token punctuation">)</span><span class="token comment">//gap不能等于数组的总元素个数</span>
	<span class="token punctuation">{<!-- --></span>
		<span class="token keyword">for</span> <span class="token punctuation">(</span>j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> j <span class="token operator">+=</span> <span class="token number">2</span> <span class="token operator">*</span> gap<span class="token punctuation">)</span>
		<span class="token punctuation">{<!-- --></span>	
			<span class="token keyword">int</span> i <span class="token operator">=</span> j<span class="token punctuation">;</span> <span class="token comment">//防止循环变量改变，影响循环</span>

			<span class="token keyword">int</span> begin1 <span class="token operator">=</span> i<span class="token punctuation">,</span> end1 <span class="token operator">=</span> i <span class="token operator">+</span> gap <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>
			<span class="token keyword">int</span> begin2 <span class="token operator">=</span> i <span class="token operator">+</span> gap<span class="token punctuation">,</span> end2 <span class="token operator">=</span> i <span class="token operator">+</span> <span class="token number">2</span> <span class="token operator">*</span> gap <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>

			<span class="token keyword">if</span> <span class="token punctuation">(</span>begin2 <span class="token operator">&gt;=</span> n<span class="token punctuation">)</span><span class="token comment">//右区间  左端点越界，就直接可以结束</span>
				<span class="token keyword">break</span><span class="token punctuation">;</span>
			<span class="token keyword">if</span> <span class="token punctuation">(</span>end2 <span class="token operator">&gt;=</span> n<span class="token punctuation">)</span><span class="token comment">//右区间  右端点越界，就将它改为n-1</span>
				end2 <span class="token operator">=</span> n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>
			<span class="token comment">//归并</span>
			<span class="token keyword">while</span> <span class="token punctuation">(</span>begin1 <span class="token operator">&lt;=</span> end1 <span class="token operator">&amp;&amp;</span> begin2 <span class="token operator">&lt;=</span> end2<span class="token punctuation">)</span>
			<span class="token punctuation">{<!-- --></span>
				<span class="token keyword">if</span> <span class="token punctuation">(</span>a<span class="token punctuation">[</span>begin1<span class="token punctuation">]</span> <span class="token operator">&lt;</span> a<span class="token punctuation">[</span>begin2<span class="token punctuation">]</span><span class="token punctuation">)</span>
				<span class="token punctuation">{<!-- --></span>
					tmp<span class="token punctuation">[</span>i<span class="token operator">++</span><span class="token punctuation">]</span> <span class="token operator">=</span> a<span class="token punctuation">[</span>begin1<span class="token operator">++</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
				<span class="token punctuation">}</span>
				<span class="token keyword">else</span>
				<span class="token punctuation">{<!-- --></span>
					tmp<span class="token punctuation">[</span>i<span class="token operator">++</span><span class="token punctuation">]</span> <span class="token operator">=</span> a<span class="token punctuation">[</span>begin2<span class="token operator">++</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
				<span class="token punctuation">}</span>
			<span class="token punctuation">}</span>
			<span class="token keyword">while</span> <span class="token punctuation">(</span>begin1 <span class="token operator">&lt;=</span> end1<span class="token punctuation">)</span>
			<span class="token punctuation">{<!-- --></span>
				tmp<span class="token punctuation">[</span>i<span class="token operator">++</span><span class="token punctuation">]</span> <span class="token operator">=</span> a<span class="token punctuation">[</span>begin1<span class="token operator">++</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
			<span class="token punctuation">}</span>
			<span class="token keyword">while</span> <span class="token punctuation">(</span>begin2 <span class="token operator">&lt;=</span> end2<span class="token punctuation">)</span>
			<span class="token punctuation">{<!-- --></span>
				tmp<span class="token punctuation">[</span>i<span class="token operator">++</span><span class="token punctuation">]</span> <span class="token operator">=</span> a<span class="token punctuation">[</span>begin2<span class="token operator">++</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
			<span class="token punctuation">}</span>
		<span class="token punctuation">}</span>
		<span class="token keyword">int</span> z <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
		<span class="token comment">//归并结束后，将归并完成的拷贝回去</span>
        <span class="token comment">//为下次循环的归并做准备</span>
		<span class="token keyword">for</span> <span class="token punctuation">(</span>z <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> z <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> z<span class="token operator">++</span><span class="token punctuation">)</span>
			a<span class="token punctuation">[</span>z<span class="token punctuation">]</span> <span class="token operator">=</span> tmp<span class="token punctuation">[</span>z<span class="token punctuation">]</span><span class="token punctuation">;</span>
		
		gap <span class="token operator">*=</span> <span class="token number">2</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>一一一一一一一一一一一一一一一一一一一一一一一一一一一一一一一一一一一一一一一一</p> 
<h2><a id="_239"></a>归并排序的时间复杂度</h2> 
<p>归并排序的递归版本是将区间从大向小分，一次一半<br> 我们可以将该过程类似二叉树<br> <img src="https://images2.imgbox.com/22/bc/fPZYcajJ_o.png" alt="在这里插入图片描述"><br> 我们把每一层归并操作消耗的时间记作n。<br> 现在，我们只需要知道这棵树的高度h，用高度h乘以每一层的时间消耗n，就可以得到总的时间复杂度O(n∗h)。从归并排序的原理和递归树，可以看出来，归并排序递归树是一棵满二叉树。<br> 而满二叉树的高度大约是log2n<br> 所以，<mark><strong>归并排序递归实现的时间复杂度就是O(nlogn)。</strong></mark></p> 
<p>一一一一一一一一一一一一一一一一一一一一一一一一一一一一一一一一一一一一一一一一</p> 
<h2><a id="_252"></a>归并排序的空间复杂度</h2> 
<p><mark>归并排序需要借助与数组等大的区间</mark><br> 所以<br> <mark>归并排序的空间复杂度为O（N）</mark></p> 
<p>一一一一一一一一一一一一一一一一一一一一一一一一一一一一一一一一一一一一一一一一</p> 
<h2><a id="_261"></a>归并排序的稳定性</h2> 
<p>归并排序采用分治策略，将序列递归地分成短序列，然后将各个有序的短序列合并成一个有序的长序列，不断合并直到原序列全部排好序。<br> 在合并过程中，如果两个当前元素相等时，归并排序会把处在前面的序列的元素保存在结果序列的前面，从而保证了稳定性。</p> 
<p><mark>所以归并排序是稳定的</mark></p> 
<p>一一一一一一一一一一一一一一一一一一一一一一一一一一一一一一一一一一一一一一一一<br> <mark>以上就是全部内容了，如果对你有帮助的话，可以点赞支持一下！！!</mark></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/c49b51992c3d4394011a795d576354dc/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">SpringBoot3整合MyBatisPlus</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/427c0e788929ca1eee9a722439a97f1c/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">docker network网络</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>