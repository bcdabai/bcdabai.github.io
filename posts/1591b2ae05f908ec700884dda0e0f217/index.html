<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>怎么同时建立两个链表 - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="怎么同时建立两个链表" />
<meta property="og:description" content="注意点一
注意点二
注意点三
目前我对于单链表的头插式建立法比较了解但是在遇到Leetcode002题时，我发现它同时建立了两个单链表，以前我建立单链表时总是使用head_creat()这个函数但是这样的话，往往实现不了将两个链表区分开来的作用，经过搜索我发现了这个方法
https://blog.csdn.net/weixin_45774972/article/details/115374066?ops_request_misc=&amp;request_id=&amp;biz_id=102&amp;utm_term=%E5%A6%82%E4%BD%95%E5%90%8C%E6%97%B6%E5%BB%BA%E7%AB%8B%E4%B8%A4%E4%B8%AA%E9%93%BE%E8%A1%A8&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduweb~default-6-.first_rank_v2_pc_rank_v29&amp;spm=1018.2226.3001.4187
以上是他人的文章
这里我们可以发现他使用了这样的方法
注意点一 在头插式建立链表函数的基础上在函数中添加了参数
1：我当前要建立的链表的头指针
2：该链表的长度
注意点二 他在定义结构体时加入了listnode（int x）这样的一个函数
我感觉这就是一个自己定义的构造函数
如果是默认的构造函数，我们会用ListNode*p=new List Node（）；这样的一个函数
此时就会变成ListNode*p=new ListNode（0）前提是还没给这样的一个结点赋值
注意点三 输出函数参数也加入了头指针让我们知道该遍历哪个链表
接下来我将使用自己的方法尝试能否自己实现
#include&lt;iostream&gt; using namespace std; struct Node {//创建进程控制块 int data; struct Node *next;//指向下一个结点的指针 Node(int x) :data(x), next(NULL) {}; }; //头插法创建单链表 void head_creat(Node *head,int l) { int n; for (int i = 0; i &lt; l; i&#43;&#43;) { Node *p = new Node(0); cout &lt;&lt; &#34;请输入当前结点的值&#34; &lt;&lt; endl; cin &gt;&gt; n; p-&gt;data = n;//给结点赋值 p-&gt;next = head-&gt;next; head-&gt;next = p; } } void show(Node *head) { Node *p = head-&gt;next; while (p) { cout &lt;&lt; p-&gt;data&lt;&lt;&#34;" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/1591b2ae05f908ec700884dda0e0f217/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2021-07-11T12:16:59+08:00" />
<meta property="article:modified_time" content="2021-07-11T12:16:59+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">怎么同时建立两个链表</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p id="main-toc"><a href="#%E6%B3%A8%E6%84%8F%E7%82%B9%E4%B8%80" rel="nofollow">注意点一</a></p> 
<p id="%E6%B3%A8%E6%84%8F%E7%82%B9%E4%BA%8C-toc" style="margin-left:0px;"><a href="#%E6%B3%A8%E6%84%8F%E7%82%B9%E4%BA%8C" rel="nofollow">注意点二</a></p> 
<p id="%E6%B3%A8%E6%84%8F%E7%82%B9%E4%B8%89-toc" style="margin-left:0px;"><a href="#%E6%B3%A8%E6%84%8F%E7%82%B9%E4%B8%89" rel="nofollow">注意点三</a></p> 
<hr id="hr-toc"> 
<p>目前我对于单链表的头插式建立法比较了解但是在遇到Leetcode002题时，我发现它同时建立了两个单链表，以前我建立单链表时总是使用head_creat()这个函数但是这样的话，往往实现不了将两个链表区分开来的作用，经过搜索我发现了这个方法</p> 
<p><a href="https://blog.csdn.net/weixin_45774972/article/details/115374066?ops_request_misc=&amp;request_id=&amp;biz_id=102&amp;utm_term=%E5%A6%82%E4%BD%95%E5%90%8C%E6%97%B6%E5%BB%BA%E7%AB%8B%E4%B8%A4%E4%B8%AA%E9%93%BE%E8%A1%A8&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduweb~default-6-.first_rank_v2_pc_rank_v29&amp;spm=1018.2226.3001.4187">https://blog.csdn.net/weixin_45774972/article/details/115374066?ops_request_misc=&amp;request_id=&amp;biz_id=102&amp;utm_term=%E5%A6%82%E4%BD%95%E5%90%8C%E6%97%B6%E5%BB%BA%E7%AB%8B%E4%B8%A4%E4%B8%AA%E9%93%BE%E8%A1%A8&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduweb~default-6-.first_rank_v2_pc_rank_v29&amp;spm=1018.2226.3001.4187</a></p> 
<p>以上是他人的文章</p> 
<p>这里我们可以发现他使用了这样的方法</p> 
<h2 id="%E6%B3%A8%E6%84%8F%E7%82%B9%E4%B8%80" style="text-align:center;">注意点一</h2> 
<p><img alt="" height="434" src="https://images2.imgbox.com/cf/68/UBgZBtlq_o.png" width="445"></p> 
<p> 在头插式建立链表函数的基础上在函数中添加了参数</p> 
<p>1：我当前要建立的链表的头指针</p> 
<p>2：该链表的长度</p> 
<h2 id="%E6%B3%A8%E6%84%8F%E7%82%B9%E4%BA%8C" style="text-align:center;">注意点二</h2> 
<p><img alt="" height="205" src="https://images2.imgbox.com/8b/ce/jxPtHa3d_o.png" width="469"></p> 
<p> 他在定义结构体时加入了listnode（int x）这样的一个函数</p> 
<p>我感觉这就是一个自己定义的构造函数</p> 
<p>如果是默认的构造函数，我们会用ListNode*p=new List Node（）；这样的一个函数</p> 
<p>此时就会变成ListNode*p=new ListNode（0）前提是还没给这样的一个结点赋值</p> 
<h2 id="%E6%B3%A8%E6%84%8F%E7%82%B9%E4%B8%89" style="text-align:center;">注意点三</h2> 
<p><img alt="" height="313" src="https://images2.imgbox.com/9b/1d/VzGrx9FB_o.png" width="436"></p> 
<p> 输出函数参数也加入了头指针让我们知道该遍历哪个链表</p> 
<p>接下来我将使用自己的方法尝试能否自己实现</p> 
<pre><code class="language-cpp">#include&lt;iostream&gt;
using namespace std;
struct Node {//创建进程控制块
	int data;
	struct Node *next;//指向下一个结点的指针
	Node(int x) :data(x), next(NULL) {};
};
//头插法创建单链表
void head_creat(Node *head,int l)
{
	int n;
	for (int i = 0; i &lt; l; i++) {
		Node *p = new Node(0);
		cout &lt;&lt; "请输入当前结点的值" &lt;&lt; endl;
		cin &gt;&gt; n;
		p-&gt;data = n;//给结点赋值
		p-&gt;next = head-&gt;next;
		head-&gt;next = p;
	}
}
void show(Node *head) {
	Node *p = head-&gt;next;
	while (p) {
		cout &lt;&lt; p-&gt;data&lt;&lt;"  ";
		p= p-&gt;next;
	}
	cout &lt;&lt; endl;
}
int main() {
	int l1, l2;
	Node* head1, *head2;//两个头指针指向两条不同的链表
	head1 = new Node(0); head2 = new Node(0);
	head1-&gt;next = NULL;
	head2-&gt;next = NULL;
	cout &lt;&lt; "链表1的长度" &lt;&lt; endl;
	cin &gt;&gt; l1;
	cout &lt;&lt; "输入链表1的值" &lt;&lt; endl;
	head_creat(head1, l1);
	cout &lt;&lt; "链表2的长度" &lt;&lt; endl;
	cin &gt;&gt; l2;
	cout &lt;&lt; "输入链表2的值" &lt;&lt; endl;
	head_creat(head2, l2);
	show(head1);
	show(head2);
	return 0;
}</code></pre> 
<p>成功实现了</p> 
<p></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/f11470879b00b52bb127489414e660f2/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">计算机软件自启动设置,设置开机启动项,详细教您电脑如何设置开机启动项</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/44434e44d27c0b5dc482327402ab6372/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">vbs怎样让别人叫你爸爸、密码锁代码</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>