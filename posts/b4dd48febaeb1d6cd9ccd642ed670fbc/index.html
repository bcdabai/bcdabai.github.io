<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>linux下C&#43;&#43;实现Http请求类(GET，POST，上传，下载) - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="linux下C&#43;&#43;实现Http请求类(GET，POST，上传，下载)" />
<meta property="og:description" content="linux下C&#43;&#43;实现Http请求类(GET，POST，上传，下载) Http协议简述 协议：网络协议的简称，网络协议是通信计算机双方必须共同遵从的一组约定。如怎么样建立连接、怎么样互相识别等。只有遵守这个约定，计算机之间才能相互通信交流，就好比两台计算机交互的语言.
HTTP协议：超文本传输协议（HyperText Transfer Protocol)是互联网上应用最为广泛的一种网络协议。主要被用于在Web浏览器和网站服务器之间传递信息。 HTTP 是基于 TCP/IP 协议的应用层协议。默认使用80端口。最新版本是HTTP 2.0，目前是用最广泛的是HTTP 1.1。
HTTP协议工作于客户端-服务端架构为上。浏览器作为HTTP客户端通过URL向HTTP服务端即WEB服务器发送所有请求。Web服务器根据接收到的请求后，向客户端发送响应信息。
请求方法：
HTTP/1.1协议中共定义了八种方法（有时也叫“动作”）来表明Request-URI指定的资源的不同操作方式：
OPTIONS - 返回服务器针对特定资源所支持的HTTP请求方法。也可以利用向Web服务器发送’*&#39;的请求来测试服务器的功能性。
HEAD- 向服务器索要与GET请求相一致的响应，只不过响应体将不会被返回。这一方法可以在不必传输整个响应内容的情况下，就可以获取包含在响应消息头中的元信息。该方法常用于测试超链接的有效性，是否可以访问，以及最近是否更新。
GET - 向特定的资源发出请求。注意：GET方法不应当被用于产生“副作用”的操作中，例如在web app.中。其中一个原因是GET可能会被网络蜘蛛等随意访问。
POST - 向指定资源提交数据进行处理请求（例如提交表单或者上传文件）。数据被包含在请求体中。POST请求可能会导致新的资源的建立和/或已有资源的修改。
PUT - 向指定资源位置上传其最新内容。
DELETE - 请求服务器删除Request-URI所标识的资源。
TRACE- 回显服务器收到的请求，主要用于测试或诊断。
CONNECT - HTTP/1.1协议中预留给能够将连接改为管道方式的代理服务器。
PATCH - 用来将局部修改应用于某一资源，添加于规范RFC5789。
方法名称是区分大小写的。当某个请求所针对的资源不支持对应的请求方法的时候，服务器应当返回状态码405（Method Not Allowed）；当服务器不认识或者不支持对应的请求方法的时候，应当返回状态码501（Not Implemented）。
HTTP服务器至少应该实现GET和HEAD方法，其他方法都是可选的。此外，除了上述方法，特定的HTTP服务器还能够扩展自定义的方法。
GET和POST请求的区别
GET请求
GET /books/?sex=man&amp;name=Professional HTTP/1.1
Host: www.wrox.com
User-Agent: Mozilla/5.0 (Windows; U; Windows NT 5.1; en-US; rv:1.7.6)
Gecko/20050225 Firefox/1.0.1
Connection: Keep-Alive
注意最后有一行空行
POST请求
POST / HTTP/1." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/b4dd48febaeb1d6cd9ccd642ed670fbc/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2019-02-14T17:27:00+08:00" />
<meta property="article:modified_time" content="2019-02-14T17:27:00+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">linux下C&#43;&#43;实现Http请求类(GET，POST，上传，下载)</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <h3><a id="linuxCHttpGETPOST_0"></a>linux下C++实现Http请求类(GET，POST，上传，下载)</h3> 
<h4><a id="Http_1"></a>Http协议简述</h4> 
<p>协议：网络协议的简称，网络协议是通信计算机双方必须共同遵从的一组约定。如怎么样建立连接、怎么样互相识别等。只有遵守这个约定，计算机之间才能相互通信交流，就好比两台计算机交互的语言.</p> 
<p>HTTP协议：超文本传输协议（HyperText Transfer Protocol)是互联网上应用最为广泛的一种网络协议。主要被用于在Web浏览器和网站服务器之间传递信息。 HTTP 是基于 TCP/IP 协议的应用层协议。默认使用80端口。最新版本是HTTP 2.0，目前是用最广泛的是HTTP 1.1。</p> 
<p>HTTP协议工作于客户端-服务端架构为上。浏览器作为HTTP客户端通过URL向HTTP服务端即WEB服务器发送所有请求。Web服务器根据接收到的请求后，向客户端发送响应信息。</p> 
<p>请求方法：<br> HTTP/1.1协议中共定义了八种方法（有时也叫“动作”）来表明Request-URI指定的资源的不同操作方式：<br> OPTIONS - 返回服务器针对特定资源所支持的HTTP请求方法。也可以利用向Web服务器发送’*'的请求来测试服务器的功能性。<br> HEAD- 向服务器索要与GET请求相一致的响应，只不过响应体将不会被返回。这一方法可以在不必传输整个响应内容的情况下，就可以获取包含在响应消息头中的元信息。该方法常用于测试超链接的有效性，是否可以访问，以及最近是否更新。<br> GET - 向特定的资源发出请求。注意：GET方法不应当被用于产生“副作用”的操作中，例如在web app.中。其中一个原因是GET可能会被网络蜘蛛等随意访问。<br> POST - 向指定资源提交数据进行处理请求（例如提交表单或者上传文件）。数据被包含在请求体中。POST请求可能会导致新的资源的建立和/或已有资源的修改。<br> PUT - 向指定资源位置上传其最新内容。<br> DELETE - 请求服务器删除Request-URI所标识的资源。<br> TRACE- 回显服务器收到的请求，主要用于测试或诊断。<br> CONNECT - HTTP/1.1协议中预留给能够将连接改为管道方式的代理服务器。<br> PATCH - 用来将局部修改应用于某一资源，添加于规范RFC5789。<br> 方法名称是区分大小写的。当某个请求所针对的资源不支持对应的请求方法的时候，服务器应当返回状态码405（Method Not Allowed）；当服务器不认识或者不支持对应的请求方法的时候，应当返回状态码501（Not Implemented）。<br> HTTP服务器至少应该实现GET和HEAD方法，其他方法都是可选的。此外，除了上述方法，特定的HTTP服务器还能够扩展自定义的方法。</p> 
<p>GET和POST请求的区别<br> GET请求<br> GET /books/?sex=man&amp;name=Professional HTTP/1.1<br> Host: <a href="http://www.wrox.com" rel="nofollow">www.wrox.com</a><br> User-Agent: Mozilla/5.0 (Windows; U; Windows NT 5.1; en-US; rv:1.7.6)<br> Gecko/20050225 Firefox/1.0.1<br> Connection: Keep-Alive<br> 注意最后有一行空行</p> 
<p>POST请求<br> POST / HTTP/1.1<br> Host: <a href="http://www.wrox.com" rel="nofollow">www.wrox.com</a><br> User-Agent: Mozilla/5.0 (Windows; U; Windows NT 5.1; en-US; rv:1.7.6)<br> Gecko/20050225 Firefox/1.0.1<br> Content-Type: application/x-www-form-urlencoded<br> Content-Length: 40<br> Connection: Keep-Alive</p> 
<p>name=Professional%20Ajax&amp;publisher=Wiley</p> 
<p>1、GET提交：请求的数据会附在URL之后（就是把数据放置在HTTP协议头中），以?分割URL和传输数据，多个参数用&amp;连接；例 如：login.action?name=hyddd&amp;password=idontknow&amp;verify=%E4%BD%A0 %E5%A5%BD。如果数据是英文字母/数字，原样发送，如果是空格，转换为+，如果是中文/其他字符，则直接把字符串用BASE64加密，得出如： %E4%BD%A0%E5%A5%BD，其中％XX中的XX为该符号以16进制表示的ASCII。</p> 
<p>2、POST提交：把提交的数据放置在是HTTP包的包体中。上文示例中红色字体标明的就是实际的传输数据</p> 
<p>HttpRequest类设计<br> 请求部分<br> HttpRequest::HttpRequest() 通过传入Url构造HttpUrl类分离url域名及uri.<br> HttpRequest::connect() 通过gethostbyname()获取域名ip，与80端口组成远端地址建立链接.<br> HttpRequest::setRequestMethod() 设置请求方法,目前只添加了Get和Post请求.<br> HttpRequest::setRequestProperty() 设置属性.<br> HttpRequest::setRequestBody() 设置content.<br> HttpRequest::send() 将设置的请求流发送出去.</p> 
<p>接收部分<br> HttpRequest::handRead() 处理服务器应答头.<br> HttpRequest::getResponseCode() handRead()后可以获取到应答code<br> HttpRequest::getResponseProperty() handRead()后可以获取到对应的应答属性<br> HttpRequest::getResponseContent() handRead()后可以获取到应答content</p> 
<pre><code>#ifndef _HTTP_REQUEST_HH
#define _HTTP_REQUEST_HH

#include &lt;netdb.h&gt;
#include &lt;arpa/inet.h&gt;
#include &lt;algorithm&gt;
#include &lt;vector&gt;
#include &lt;string&gt;
#include &lt;assert.h&gt;
#include &lt;string.h&gt;
#include &lt;sstream&gt;
#include &lt;map&gt;
#include "Logger.hh"

const size_t kBufferSize = 4096;

/// A buffer class modeled after org.jboss.netty.buffer.ChannelBuffer
///
/// @code
/// +-------------------+------------------+------------------+
/// | prependable bytes |  readable bytes  |  writable bytes  |
/// |                   |     (CONTENT)    |                  |
/// +-------------------+------------------+------------------+
/// |                   |                  |                  |
/// 0      &lt;=      readerIndex   &lt;=   writerIndex    &lt;=     size
/// @endcode
class Buffer
{
public:

  static const size_t kCheapPrepend = 8;
  static const size_t kInitialSize = 4096;
//public:
    explicit Buffer(size_t initialSize = kInitialSize)
    : m_buffer(kCheapPrepend + initialSize),
      m_readerIndex(kCheapPrepend),
      m_writerIndex(kCheapPrepend)
      {
        assert(readableBytes() == 0);
        assert(writableBytes() == initialSize);
        assert(prependableBytes() == kCheapPrepend);
      }

  size_t readableBytes() const
  { return m_writerIndex - m_readerIndex; }

  size_t writableBytes() const
  { return m_buffer.size() - m_writerIndex; }

  size_t prependableBytes() const
  { return m_readerIndex; }

  const char* peek() const
  { return begin() + m_readerIndex; }

  char* beginWrite()
  { return begin() + m_writerIndex; }

  void hasWritten(size_t len)
  {
    assert(len &lt;= writableBytes());
    m_writerIndex += len;
  }

  void unwrite(size_t len)
  {
    assert(len &lt;= readableBytes());
    m_writerIndex -= len;
  }

  // retrieve returns void, to prevent
  // string str(retrieve(readableBytes()), readableBytes());
  // the evaluation of two functions are unspecified
  void retrieve(size_t len)
  {
    assert(len &lt;= readableBytes());
    if (len &lt; readableBytes())
    {
      m_readerIndex += len;
    }
    else
    {
      retrieveAll();
    }
  }

  void retrieveAll()
  {
    m_readerIndex = kCheapPrepend;
    m_writerIndex = kCheapPrepend;
  }

private:
  char* begin()
  {return &amp;*m_buffer.begin(); }

  const char* begin() const
  {return &amp;*m_buffer.begin(); }

private:
    std::vector&lt;char&gt; m_buffer;
    size_t m_readerIndex;
    size_t m_writerIndex;
};


namespace sockets
{

/// Creates a non-blocking socket file descriptor,
/// abort if any error.
int createSocket(sa_family_t family);

int  connect(int sockfd, const struct sockaddr* addr);
ssize_t read(int sockfd, void *buf, size_t count);
ssize_t readv(int sockfd, const struct iovec *iov, int iovcnt);
ssize_t write(int sockfd, const void *buf, size_t count);
void close(int sockfd);

void fromIpPort(const char* ip, uint16_t port,
                struct sockaddr_in* addr);

int getSocketError(int sockfd);
void delaySecond(int sec);
//const struct sockaddr* sockaddr_cast(const struct sockaddr_in* addr)
//const struct sockaddr_in* sockaddr_in_cast(const struct sockaddr* addr);

}

class InetAddress
{
 public:
  /// Constructs an endpoint with given ip and port.
  /// @c ip should be "1.2.3.4"
  InetAddress(std::string ip, uint16_t port);

  /// Constructs an endpoint with given struct @c sockaddr_in
  /// Mostly used when accepting new connections
  explicit InetAddress(const struct sockaddr_in&amp; addr)
    : m_addr(addr)
  { }

  sa_family_t family() const { return m_addr.sin_family; }
  //std::string toIp() const;
  //std::string toIpPort() const;

  const struct sockaddr* getSockAddr() const { return (struct sockaddr*)(&amp;m_addr); }

  uint32_t ipNetEndian() const;

  // resolve hostname to IP address, not changing port or sin_family
  // return true on success.
  // thread safe
  // static bool resolve(StringArg hostname, StringArg* ip);
  // static std::vector&lt;InetAddress&gt; resolveAll(const char* hostname, uint16_t port = 0);

 private:
    struct sockaddr_in m_addr;

};


class HttpUrl
{
public:
    HttpUrl(std::string&amp; httpUrl)
    :m_httpUrl(httpUrl),
     m_smatch(detachHttpUrl())
    {
        LOG_DEBUG &lt;&lt; "URL : " &lt;&lt; m_httpUrl;
    }
    ~HttpUrl(){};

    enum HttpUrlMatch
    {
        URL = 0,
        HOST = 1,
        URI = 2
    };

    std::vector&lt;std::string&gt; detachHttpUrl() const
    {
      std::vector&lt;std::string&gt; v;
      std::string::size_type pos1, pos2;
      pos2 = m_httpUrl.find('/');
      assert(std::string::npos != pos2);
      pos1 = pos2 + 2;
      pos2 = m_httpUrl.find('/', pos1);
      assert(std::string::npos != pos2);
      v.push_back(m_httpUrl);
      v.push_back(m_httpUrl.substr(pos1, pos2 - pos1));
      v.push_back(m_httpUrl.substr(pos2 + 1));
      LOG_DEBUG &lt;&lt; "detachHttpUrl() url :" &lt;&lt; v[0];
      LOG_DEBUG &lt;&lt; "detachHttpUrl() host :" &lt;&lt; v[1];
      LOG_DEBUG &lt;&lt; "detachHttpUrl() uri :" &lt;&lt; v[2];
      return v;
    }

    bool HttpUrlToIp(const std::string&amp; host, char* ip) const
    {
        struct hostent* phost = NULL;

        phost = gethostbyname(host.c_str());
        if (NULL == phost)
        {
            LOG_ERROR &lt;&lt; "HttpUrlToIp(): gethostbyname error : " &lt;&lt; errno &lt;&lt; " : "&lt;&lt; strerror(errno);
            return false;
            //LOG_SYSERR &lt;&lt; "urlToIp(): gethostbyname error";
        }

        inet_ntop(phost-&gt;h_addrtype,  phost-&gt;h_addr, ip, 17);

        return true;
    }

    std::string domain() const
    {
        return getHttpUrlSubSeg(HOST);
    }

    std::string getHttpUrlSubSeg(HttpUrlMatch sub = HOST) const{ return m_smatch[sub]; }

private:
    std::string m_httpUrl;
    std::vector&lt;std::string&gt; m_smatch;
};


class HttpRequest
{
public:
    enum HttpRequestMethod{
        GET = 0,
        POST
    };
    HttpRequest(std::string httpUrl);
    ~HttpRequest();

    void connect();
    //void TEST(const std::string path,const std::string content);
    void setRequestMethod(const std::string &amp;method);
    void setRequestProperty(const std::string &amp;key, const std::string &amp;value);
    void setRequestBody(const std::string &amp;content);

    //void clear() { clearStream(); m_buffer.retrieveAll(); }
    void clearStream() {m_stream.str("");}
    std::string strStream() const { return m_stream.str(); };

    int getResponseCode() const {
        assert(m_haveHandleHead);
        return m_code;
    }

    std::string getResponseProperty(const std::string&amp; key) const {
        assert(m_haveHandleHead);
        return m_ackProperty.at(key);
    }

    std::string getResponseContent() {
        assert(m_haveHandleHead);
        return std::string(m_buffer.peek(), m_buffer.readableBytes());
    }

    void handleRead();
    void uploadFile(const std::string&amp; file, const std::string&amp; contentEnd);
    void downloadFile(const std::string&amp; file);

    void send(){
        sockets::write(m_sockfd, strStream().c_str(), strStream().size());
    }

    void close(){ sockets::close(m_sockfd); }

private:
    void SplitString(const std::string&amp; s, std::vector&lt;std::string&gt;&amp; v, const std::string&amp; c);

  Buffer m_buffer;
    HttpUrl m_httpUrl;
    std::stringstream m_stream;
    int m_code;
    int m_sockfd;
    bool m_haveHandleHead;
    std::map&lt;std::string, std::string&gt; m_ackProperty;
};

#endif
</code></pre> 
<p>关于上传和下载<br> HttpRequest::downloadFile(const std::string&amp; file);<br> 下载直接在 handRead() 处理完应答头后 ， 调用downloadFile() 存储在本地.<br> HttpRequest::uploadFile(const std::string&amp; file, const std::string&amp; contentEnd)<br> 上传部分复杂一点，需要根据kBoundary 设置边界,如下.</p> 
<pre><code>    off_t fileSize = FileSize(uploadFile);
    LOG_DEBUG &lt;&lt; "fileSize : " &lt;&lt; fileSize;
    std::stringstream content;
    content &lt;&lt; "--" + kBoundary &lt;&lt; "\r\n";
    content &lt;&lt; "Content-Disposition: form-data; name=\"upload\"; filename=\"test.file\"\r\n";
    content &lt;&lt; "Content-Type: text/plain\r\n\r\n";

    std::string contentEnd = "\r\n--" + kBoundary + "--\r\n";

    HttpClient upload("http://xxxxx/upload");
    upload.setRequestMethod("POST");
    upload.setRequestProperty("Content-Type", "multipart/form-data; boundary=" + kBoundary);
    upload.setRequestProperty("Cache-Control", "no-cache");
    upload.setRequestProperty("Content-Length", std::to_string(fileSize + content.str().size() + contentEnd.size()));
    upload.setRequestProperty("Connection", "close\r\n");
    upload.setRequestBody(content.str());
</code></pre> 
<p>Cpp实现</p> 
<pre><code>#include &lt;string&gt;
#include &lt;iostream&gt;
#include &lt;fcntl.h&gt;
#include &lt;errno.h&gt;
#include &lt;sys/uio.h&gt;  // readv
#include &lt;stdint.h&gt;
#include &lt;endian.h&gt;
#include &lt;unistd.h&gt;
#include &lt;map&gt;
#include &lt;fstream&gt;

#include "HttpRequest.h"

const std::map&lt;std::string, int&gt;::value_type init_value[] =
{
    std::map&lt;std::string, int&gt;::value_type( "GET", HttpRequest::GET),

    std::map&lt;std::string, int&gt;::value_type( "POST", HttpRequest::POST)
};

const static std::map&lt;std::string, int&gt; kRequestMethodMap(init_value, init_value + (sizeof init_value / sizeof init_value[0]));

static inline uint16_t hostToNetwork16(uint16_t host16)
{
  return htobe16(host16);
}


int sockets::createSocket(sa_family_t family){
  // Call "socket()" to create a (family) socket of the specified type.
  // But also set it to have the 'close on exec' property (if we can)

    int sock;

    //CLOEXEC，即当调用exec（）函数成功后，文件描述符会自动关闭。
    //在以往的内核版本（2.6.23以前）中，需要调用 fcntl(fd, F_SETFD, FD_CLOEXEC) 来设置这个属性。
    //而新版本（2.6.23开始）中，可以在调用open函数的时候，通过 flags 参数设置 CLOEXEC 功能，
#ifdef SOCK_CLOEXEC
  sock = socket(family, SOCK_STREAM|SOCK_CLOEXEC, 0);
  if (sock != -1 || errno != EINVAL) return sock;
  // An "errno" of EINVAL likely means that the system wasn't happy with the SOCK_CLOEXEC; fall through and try again without it:
#endif

  sock = socket(family, SOCK_STREAM, 0);

#ifdef FD_CLOEXEC
  if (sock != -1) fcntl(sock, F_SETFD, FD_CLOEXEC);
#endif
  return sock;
}

int sockets::connect(int sockfd, const struct sockaddr* addr)
{
  return ::connect(sockfd, addr, sizeof(struct sockaddr));
}

void sockets::fromIpPort(const char* ip, uint16_t port,
                         struct sockaddr_in* addr)
{
  addr-&gt;sin_family = AF_INET;
  addr-&gt;sin_port = hostToNetwork16(port);
  if (::inet_pton(AF_INET, ip, &amp;addr-&gt;sin_addr) &lt;= 0)
  {
    LOG_SYSERR &lt;&lt; "sockets::fromIpPort";
  }
}

ssize_t sockets::read(int sockfd, void *buf, size_t count)
{
  return ::read(sockfd, buf, count);
}

ssize_t sockets::readv(int sockfd, const struct iovec *iov, int iovcnt)
{
  return ::readv(sockfd, iov, iovcnt);
}

ssize_t sockets::write(int sockfd, const void *buf, size_t count)
{
  return ::write(sockfd, buf, count);
}

void sockets::close(int sockfd)
{
  if (::close(sockfd) &lt; 0)
  {
    LOG_SYSERR &lt;&lt; "sockets::close";
  }
}

void sockets::delaySecond(int sec)
{
  struct  timeval tv;
  tv.tv_sec = sec;
  tv.tv_usec = 0;
  select(0, NULL, NULL, NULL, &amp;tv);
}



InetAddress::InetAddress(std::string ip, uint16_t port)
{
  ::bzero(&amp;m_addr, sizeof m_addr);
  sockets::fromIpPort(ip.c_str(), port, &amp;m_addr);
}

uint32_t InetAddress::ipNetEndian() const
{
  assert(family() == AF_INET);
  return m_addr.sin_addr.s_addr;
}


HttpRequest::HttpRequest(std::string httpUrl)
  :m_httpUrl(httpUrl)
{

}

HttpRequest::~HttpRequest()
{

}

void HttpRequest::connect()
{
  char ip[32] = {0};
  while(true)
  {
    struct hostent* phost = NULL;

    phost = gethostbyname(m_httpUrl.domain().c_str());
    if (NULL == phost)
    {
      LOG_ERROR &lt;&lt; "HttpUrlToIp(): gethostbyname error : " &lt;&lt; errno &lt;&lt; " : "&lt;&lt; strerror(errno) &lt;&lt; " continue.";
      sockets::delaySecond(1);
      continue;
    }

    inet_ntop(phost-&gt;h_addrtype,  phost-&gt;h_addr, ip, sizeof ip);

    LOG_DEBUG &lt;&lt; "HttpRequest::Connector() gethostbyname Successful";

    InetAddress serverAddr = InetAddress(ip, 80);

    m_sockfd = sockets::createSocket(serverAddr.family());
    if(m_sockfd &lt; 0) LOG_SYSERR &lt;&lt; "HttpRequest::connect() : createSocket error";
    int ret = sockets::connect(m_sockfd, serverAddr.getSockAddr());
    LOG_DEBUG &lt;&lt; "sockfd : " &lt;&lt; m_sockfd &lt;&lt; "sockets::connect ret : " &lt;&lt; ret ;
    int savedErrno = (ret == 0) ? 0 : errno;

    switch (savedErrno)
    {
      case 0:
      case EINPROGRESS:
      case EINTR:
      case EISCONN:
        LOG_INFO &lt;&lt; "HttpRequest::connect() sockfd : " &lt;&lt; m_sockfd &lt;&lt; " Successful";
        break;
      default :
        LOG_ERROR &lt;&lt; "Connect Error ";
        sockets::delaySecond(1);
        continue;
    }

    break;
  }

  LOG_DEBUG &lt;&lt; "HttpRequest::Connector() end";
}

void HttpRequest::setRequestMethod(const std::string &amp;method)
{
    switch(kRequestMethodMap.at(method))
    {
        case HttpRequest::GET :
            m_stream &lt;&lt; "GET " &lt;&lt; "/" &lt;&lt; m_httpUrl.getHttpUrlSubSeg(HttpUrl::URI) &lt;&lt; " HTTP/1.1\r\n";
            LOG_DEBUG &lt;&lt; m_stream.str().c_str();
            break;
        case HttpRequest::POST :
            m_stream &lt;&lt; "POST "  &lt;&lt; "/" &lt;&lt; m_httpUrl.getHttpUrlSubSeg(HttpUrl::URI) &lt;&lt; " HTTP/1.1\r\n";
            LOG_DEBUG &lt;&lt; m_stream.str().c_str();
            break;
        default :
            LOG_ERROR &lt;&lt; "No such Method : " &lt;&lt; method.c_str();
            break;
    }

    m_stream &lt;&lt; "Host: " &lt;&lt; m_httpUrl.getHttpUrlSubSeg(HttpUrl::HOST) &lt;&lt; "\r\n";
}


void HttpRequest::setRequestProperty(const std::string &amp;key, const std::string &amp;value)
{
    m_stream &lt;&lt; key &lt;&lt; ": " &lt;&lt; value &lt;&lt; "\r\n";
}

void HttpRequest::setRequestBody(const std::string &amp;content)
{
    m_stream &lt;&lt; content;
}

void HttpRequest::handleRead()
{
    assert(!m_haveHandleHead);
    ssize_t nread = 0;
    ssize_t writtenBytes = 0;

    nread = sockets::read(m_sockfd, m_buffer.beginWrite(), kBufferSize);
    if(nread &lt; 0) LOG_SYSFATAL &lt;&lt; "sockets::read";
    m_buffer.hasWritten(nread);
    LOG_TRACE &lt;&lt; "sockets::read(): nread: " &lt;&lt; nread &lt;&lt; " remain: " &lt;&lt; m_buffer.writableBytes();
    size_t remain = kBufferSize - nread;
    while(remain &gt; 0)
    {
        size_t n = sockets::read(m_sockfd, m_buffer.beginWrite(), remain);
        if(n &lt; 0) LOG_SYSFATAL &lt;&lt; "sockets::read";
        m_buffer.hasWritten(n);
        if(0 == n)
        {
            LOG_DEBUG &lt;&lt; "sockets::read finish";
            break;
        }
        remain = remain - n;
    }
    //std::cout &lt;&lt; m_buffer.peek();

    //for(int i = 0; i &lt; nread; i++) printf("%02x%c",(unsigned char)buffer[i],i==nread - 1 ?'\n':' ');
    //LOG_DEBUG &lt;&lt; "handleRead Recv Response : \n" &lt;&lt; m_buffer.peek();
    int headsize = 0;
    std::string line;
    std::stringstream ss(m_buffer.peek());
    std::vector&lt;std::string&gt; v;
    getline(ss, line);
    //LOG_DEBUG &lt;&lt; line;
    headsize += line.size() + 1;
    SplitString(line, v, " ");
    //for(int i = 0; i &lt; v.size(); i++) std::cout &lt;&lt; v[i] &lt;&lt; std::endl;
    m_code = std::stoi(v[1]);
    if(v[1] != "200")
    {
      LOG_ERROR &lt;&lt; "Error Http Server Response : " &lt;&lt; v[1].c_str();
    }

    do{
        getline(ss, line);
        headsize += line.size() + 1;  // + 1('\n')
        if(!line.empty()) line.erase(line.end()-1); // remove '/r'
        //LOG_DEBUG &lt;&lt; line;
        v.clear();
        SplitString(line, v, ":");
        if(v.size() == 2){
            m_ackProperty[v[0]] = v[1].erase(0,v[1].find_first_not_of(" "));
        }
    }while(!line.empty());

    LOG_DEBUG &lt;&lt; "Http Head Size is " &lt;&lt; headsize;
    std::string res(m_buffer.peek(), headsize);
    LOG_DEBUG &lt;&lt; "Http Response :\n" &lt;&lt; res;
    m_buffer.retrieve(headsize);

    m_haveHandleHead = true;

}

void HttpRequest::uploadFile(const std::string&amp; file, const std::string&amp; contentEnd)
{

    FILE* fp = fopen(file.c_str(), "rb");
    if(fp == NULL)
    {
        LOG_SYSFATAL &lt;&lt; "fopen() File :" &lt;&lt; file.c_str() &lt;&lt; " Errno";
    }

    bool isEnd = false;
    ssize_t writtenBytes = 0;

    assert(m_buffer.writableBytes() == Buffer::kInitialSize);

    while(!isEnd)
    {
        ssize_t nread = fread(m_buffer.beginWrite(), 1, kBufferSize, fp);
        m_buffer.hasWritten(nread);
        while(m_buffer.writableBytes() &gt; 0)
        {
            LOG_TRACE &lt;&lt; "file read(): nread: " &lt;&lt; nread &lt;&lt; " remain: " &lt;&lt; m_buffer.writableBytes();
            size_t n = fread(m_buffer.beginWrite(), 1, m_buffer.writableBytes(), fp);
            m_buffer.hasWritten(n);
            if(0 == n)
            {   int err = ferror(fp);
                if(err)
                {
                    fprintf(stderr, "fread failed : %s\n", strerror(err));
                }
                LOG_DEBUG &lt;&lt; "sockets::read finish";
                isEnd = true;
                break;
            }
        }

        ssize_t nwrite = sockets::write(m_sockfd, m_buffer.peek(), m_buffer.readableBytes());
        if(nwrite &lt; 0) LOG_SYSFATAL &lt;&lt; "sockets::write";
        writtenBytes += nwrite;
        LOG_TRACE &lt;&lt; "sockets::write nread " &lt;&lt; m_buffer.readableBytes() &lt;&lt; " nwrite " &lt;&lt; nwrite &lt;&lt; " writtenBytes " &lt;&lt; writtenBytes;
        m_buffer.retrieve(nwrite);
    }

    fclose(fp);

    m_buffer.retrieveAll();

    ssize_t n = sockets::write(m_sockfd, contentEnd.c_str(), contentEnd.size());
    if(n &lt; 0) LOG_SYSFATAL &lt;&lt; "sockets::write";
}

void HttpRequest::downloadFile(const std::string&amp; file)
{
    assert(m_haveHandleHead);

    bool isEnd = false;
    ssize_t nread = 0;
    ssize_t writtenBytes = 0;
    bool haveHandleHead = false;
    bool isDownFile = false;

    std::ofstream output(file, std::ios::binary);
    if (!output.is_open()){ // 检查文件是否成功打开
        LOG_SYSFATAL &lt;&lt; "open file error" &lt;&lt; file;
    }

    output.write(m_buffer.peek(), m_buffer.readableBytes());
    writtenBytes += m_buffer.readableBytes();
    m_buffer.retrieve(m_buffer.readableBytes());

    LOG_DEBUG &lt;&lt; "Content-Length : " &lt;&lt; getResponseProperty("Content-Length");

    while(!isEnd)
    {
        nread = sockets::read(m_sockfd, m_buffer.beginWrite(), kBufferSize);
        if(nread &lt; 0) LOG_SYSFATAL &lt;&lt; "sockets::read";
        m_buffer.hasWritten(nread);
        LOG_TRACE &lt;&lt; "sockets::read(): nread: " &lt;&lt; nread &lt;&lt; " remain: " &lt;&lt; m_buffer.writableBytes() &lt;&lt; " writtenBytes: " &lt;&lt; writtenBytes;
        size_t remain = kBufferSize - nread;
        while(remain &gt; 0)
        {
            size_t n = sockets::read(m_sockfd, m_buffer.beginWrite(), remain);
            if(n &lt; 0) LOG_SYSFATAL &lt;&lt; "sockets::read";
            m_buffer.hasWritten(n);
            if(0 == n)
            {
                LOG_DEBUG &lt;&lt; "sockets::read finish";
                isEnd = true;
                break;
            }
            remain = remain - n;
        }

        output.write(m_buffer.peek(), m_buffer.readableBytes());
        writtenBytes += m_buffer.readableBytes();
        m_buffer.retrieve(m_buffer.readableBytes());
    }
    LOG_DEBUG &lt;&lt; " writtenBytes " &lt;&lt; writtenBytes;

    output.close();
    sockets::close(m_sockfd);
}

void HttpRequest::SplitString(const std::string&amp; s, std::vector&lt;std::string&gt;&amp; v, const std::string&amp; c)
{
  std::string::size_type pos1, pos2;
  pos2 = s.find(c);
  pos1 = 0;
  while(std::string::npos != pos2)
  {
    v.push_back(s.substr(pos1, pos2-pos1));

    pos1 = pos2 + c.size();
    pos2 = s.find(c, pos1);
  }
  if(pos1 != s.length())
    v.push_back(s.substr(pos1));
}
</code></pre> 
<p>关于源码中的Logger<br> Logger部分使用的前面文章的Logger类，可通过编辑器批量更改，注释掉,或复制第一篇异步日志的代码直接使用.</p> 
<p>使用示例<br> 下载图片</p> 
<pre><code>#include "HttpRequest.h"

int main()
{

  HttpRequest ImageReq("http://img.zcool.cn/community/01ddc256eb71586ac7257d209712b7.jpg@1280w_1l_2o_100sh.jpg");
  ImageReq.setRequestMethod("GET");
  ImageReq.setRequestProperty("Cache-Control", "no-cache");
  ImageReq.setRequestProperty("Content-Type", "application/octet-stream");
  ImageReq.setRequestProperty("Connection", "close\r\n");

  ImageReq.connect();
  ImageReq.send();
  ImageReq.handleRead();
  ImageReq.downloadFile("./test.jpg");

  return 0;
}
</code></pre> 
<pre><code>2018-10-23 20:24:07.257167 [DEBUG] [HttpRequest.hh:194] [detachHttpUrl] detachHttpUrl() url :http://img.zcool.cn/community/01ddc256eb71586ac7257d209712b7.jpg@1280w_1l_2o_100sh.jpg
2018-10-23 20:24:07.257411 [DEBUG] [HttpRequest.hh:195] [detachHttpUrl] detachHttpUrl() host :img.zcool.cn
2018-10-23 20:24:07.257561 [DEBUG] [HttpRequest.hh:196] [detachHttpUrl] detachHttpUrl() uri :community/01ddc256eb71586ac7257d209712b7.jpg@1280w_1l_2o_100sh.jpg
2018-10-23 20:24:07.257661 [DEBUG] [HttpRequest.hh:171] [HttpUrl] URL : http://img.zcool.cn/community/01ddc256eb71586ac7257d209712b7.jpg@1280w_1l_2o_100sh.jpg
2018-10-23 20:24:07.257734 [DEBUG] [HttpRequest.cpp:178] [setRequestMethod] GET /community/01ddc256eb71586ac7257d209712b7.jpg@1280w_1l_2o_100sh.jpg HTTP/1.1

2018-10-23 20:24:08.192206 [DEBUG] [HttpRequest.cpp:142] [connect] HttpRequest::Connector() gethostbyname Successful
2018-10-23 20:24:08.232474 [DEBUG] [HttpRequest.cpp:149] [connect] sockfd : 3sockets::connect ret : 0
2018-10-23 20:24:08.233236 [INFO ] [HttpRequest.cpp:158] HttpRequest::connect() sockfd : 3 Successful
2018-10-23 20:24:08.233453 [DEBUG] [HttpRequest.cpp:169] [connect] HttpRequest::Connector() end
2018-10-23 20:24:08.257666 [TRACE] [HttpRequest.cpp:212] [handleRead] sockets::read(): nread: 4096 remain: 0
2018-10-23 20:24:08.258490 [DEBUG] [HttpRequest.cpp:257] [handleRead] Http Head Size is 798
2018-10-23 20:24:08.259139 [DEBUG] [HttpRequest.cpp:259] [handleRead] Http Response :
HTTP/1.1 200 OK
Server: Tengine
Content-Type: image/jpeg
Content-Length: 155984
Connection: close
Date: Tue, 23 Oct 2018 10:05:56 GMT
x-oss-request-id: 5BCEF284EA872628A4BA7B32
ETag: "3D2EABCF4B0809B38A154C5087E5ECD4"
Last-Modified: Fri, 18 Mar 2016 03:09:12 GMT
x-oss-object-type: Normal
x-oss-hash-crc64ecma: 17069884749112719525
x-oss-storage-class: Standard
Expires: Thu, 18 Mar 2021 03:09:12 GMT
Cache-Control: max-age=86400
Via: cache10.l2cm9[0,304-0,H], cache35.l2cm9[37,0], cache1.cn683[0,200-0,H], cache1.cn683[2,0]
Age: 8479
Ali-Swift-Global-Savetime: 1538030855
X-Cache: HIT TCP_HIT dirn:6:15817583
X-Swift-SaveTime: Tue, 23 Oct 2018 10:18:38 GMT
X-Swift-CacheTime: 85638
Access-Control-Allow-Origin: *
Timing-Allow-Origin: *
EagleId: 71db884115402976359511426e

</code></pre> 
<p>该篇为转载，程序调试验证中，功能完善，待后续跟帖。</p> 
<p>转载自： <a href="https://www.cnblogs.com/ailumiyana/p/9839170.html" rel="nofollow">https://www.cnblogs.com/ailumiyana/p/9839170.html</a></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/5a578bbd90a467e0681743a283b504b7/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">CSS4 -- @font-face</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/7985a723787086b032d74505a0b7cb71/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">如何在win10&#43;VS2017环境下新建一个简单的WDF示例程序</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>