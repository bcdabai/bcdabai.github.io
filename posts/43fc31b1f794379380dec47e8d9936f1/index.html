<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>11、【死磕 Spring】—— IoC 之解析 &lt;bean&gt; 标签：meta、lookup-method、replace-method（转译） - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="11、【死磕 Spring】—— IoC 之解析 &lt;bean&gt; 标签：meta、lookup-method、replace-method（转译）" />
<meta property="og:description" content="﻿在上篇博客【死磕 Spring】—— IoC 之解析 标签：BeanDefinition 中，已经完成了对 &lt;bean&gt; 标签属性的解析工作。这篇博文开始，分析子元素的解析。
完成 bean 标签的基本属性解析后，会依次调用 BeanDefinitionParserDelegate 的 #parseMetaElements(lement ele, BeanMetadataAttributeAccessor attributeAccessor)、#parseLookupOverrideSubElements(Element beanEle, MethodOverrides overrides)、#parseReplacedMethodSubElements(Element beanEle, MethodOverrides overrides)方法，分别对子元素 meta、lookup-method、replace-method 元素完成解析。三个子元素的作用如下：
&lt;meta&gt; ：元数据。&lt;lookup-method&gt; ：Spring 动态改变 bean 里方法的实现。方法执行返回的对象，使用 Spring 内原有的这类对象替换，通过改变方法返回值来动态改变方法。内部实现为使用 cglib 方法，重新生成子类，重写配置的方法和返回对象，达到动态改变的效果。 &lt;replace-method&gt; ：Spring 动态改变 bean 里方法的实现。需要改变的方法，使用 Spring 内原有其他类（需要继承接口org.springframework.beans.factory.support.MethodReplacer）的逻辑，替换这个方法。通过改变方法执行逻辑来动态改变方法。 1. meta 子元素 meta ：元数据。当需要使用里面的信息时可以通过 key 获取。
meta 所声明的 key 并不会在 Bean 中体现，只是一个额外的声明，当我们需要使用里面的信息时，通过调用 BeanDefinition 的 #getAttribute(String name) 方法来获取。该子元素的解析过程，代码如下：
// BeanDefinitionParserDelegate.java public void parseMetaElements(Element ele, BeanMetadataAttributeAccessor attributeAccessor) { NodeList nl = ele." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/43fc31b1f794379380dec47e8d9936f1/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2020-01-31T18:25:13+08:00" />
<meta property="article:modified_time" content="2020-01-31T18:25:13+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">11、【死磕 Spring】—— IoC 之解析 &lt;bean&gt; 标签：meta、lookup-method、replace-method（转译）</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p>﻿在上篇博客<a href="http://svip.iocoder.cn/Spring/IoC-parse-BeanDefinitions-for-BeanDefinition" rel="nofollow">【死磕 Spring】—— IoC 之解析 标签：BeanDefinition</a> 中，已经完成了对 <code>&lt;bean&gt;</code> 标签属性的解析工作。这篇博文开始，分析<strong>子元素</strong>的解析。</p> 
<p>完成 <code>bean</code> 标签的基本属性解析后，会依次调用 BeanDefinitionParserDelegate 的 <code>#parseMetaElements(lement ele, BeanMetadataAttributeAccessor attributeAccessor)</code>、<code>#parseLookupOverrideSubElements(Element beanEle, MethodOverrides overrides)</code>、<code>#parseReplacedMethodSubElements(Element beanEle, MethodOverrides overrides)</code>方法，分别对子元素 <code>meta</code>、<code>lookup-method</code>、<code>replace-method</code> 元素完成解析。三个子元素的作用如下：</p> 
<ul><li><code>&lt;meta&gt;</code> ：元数据。</li><li><code>&lt;lookup-method&gt;</code> ：Spring 动态改变 bean 里方法的实现。方法执行返回的对象，使用 Spring 内原有的这类对象替换，通过改变方法返回值来动态改变方法。内部实现为使用 cglib 方法，重新生成子类，重写配置的方法和返回对象，达到动态改变的效果。</li></ul> 
<ul><li><code>&lt;replace-method&gt;</code> ：Spring 动态改变 bean 里方法的实现。需要改变的方法，使用 Spring 内原有其他类（需要继承接口<code>org.springframework.beans.factory.support.MethodReplacer</code>）的逻辑，替换这个方法。通过改变方法执行逻辑来动态改变方法。</li></ul> 
<h2 id="1-meta-子元素">1. meta 子元素</h2> 
<blockquote> 
 <p><strong>meta</strong> ：元数据。当需要使用里面的信息时可以通过 key 获取。</p> 
</blockquote> 
<p>meta 所声明的 key 并不会在 Bean 中体现，只是一个额外的声明，当我们需要使用里面的信息时，通过调用 BeanDefinition 的 <code>#getAttribute(String name)</code> 方法来获取。该子元素的解析过程，代码如下：</p> 
<table><tbody><tr><td> <pre class="has"><code class="language-java">// BeanDefinitionParserDelegate.java

public void parseMetaElements(Element ele, BeanMetadataAttributeAccessor attributeAccessor) {
    NodeList nl = ele.getChildNodes();
    // 遍历子节点
    for (int i = 0; i &lt; nl.getLength(); i++) {
        Node node = nl.item(i);
        // &lt;meta key="special-data" value="sprecial stragey" /&gt;
        if (isCandidateElement(node) &amp;&amp; nodeNameEquals(node, META_ELEMENT)) { // 标签名为 meta
            Element metaElement = (Element) node;
            String key = metaElement.getAttribute(KEY_ATTRIBUTE); // key
            String value = metaElement.getAttribute(VALUE_ATTRIBUTE); // value
            // 创建 BeanMetadataAttribute 对象
            BeanMetadataAttribute attribute = new BeanMetadataAttribute(key, value);
            attribute.setSource(extractSource(metaElement));
            // 添加到 BeanMetadataAttributeAccessor 中
            attributeAccessor.addMetadataAttribute(attribute);
        }
    }
}
</code></pre> </td></tr></tbody></table> 
<ul><li> <p>解析过程较为简单，获取相应的 key - value 构建 BeanMetadataAttribute 对象，然后调用 <code>BeanMetadataAttributeAccessor#addMetadataAttribute(BeanMetadataAttribute)</code> 方法，添加 BeanMetadataAttribute 加入到 AbstractBeanDefinition 中。</p> 
  <blockquote> 
   <p>友情提示：</p> 
   <p>AbstractBeanDefinition 继承 BeanMetadataAttributeAccessor 类<br> BeanMetadataAttributeAccessor 继承 AttributeAccessorSupport 类。</p> 
  </blockquote> </li></ul> 
<h3 id="1-1-addMetadataAttribute">1.1 addMetadataAttribute</h3> 
<p>调用 <code>BeanMetadataAttributeAccessor#addMetadataAttribute(BeanMetadataAttribute)</code> 方法，添加 BeanMetadataAttribute 加入到 AbstractBeanDefinition 中。代码如下：</p> 
<table><tbody><tr><td> <pre class="has"><code class="language-html">// BeanMetadataAttributeAccessor.java

public void addMetadataAttribute(BeanMetadataAttribute attribute) {
	super.setAttribute(attribute.getName(), attribute);
}
</code></pre> </td></tr></tbody></table> 
<ul><li>委托 AttributeAccessorSupport 实现，如下：</li></ul> 
<table><tbody><tr><td> <pre class="has"><code class="language-java">// AttributeAccessorSupport.java

/** Map with String keys and Object values. */
private final Map&lt;String, Object&gt; attributes = new LinkedHashMap&lt;&gt;();

@Override
public void setAttribute(String name, @Nullable Object value) {
	Assert.notNull(name, "Name must not be null");
	if (value != null) {
		this.attributes.put(name, value);
	} else {
		removeAttribute(name);
	}
}
</code></pre> </td></tr></tbody></table> 
<p><code>org.springframework.core.AttributeAccessorSupport</code> ，是接口 AttributeAccessor 的实现者。 AttributeAccessor 接口定义了与其他对象的元数据进行连接和访问的约定，可以通过该接口对属性进行获取、设置、删除操作。</p> 
<h3 id="1-2-getAttribute">1.2 getAttribute</h3> 
<p>设置元数据后，则可以通过调用 BeanDefinition 的 <code>#getAttribute(String name)</code> 方法来获取属性。代码如下：</p> 
<table><tbody><tr><td> <pre class="has"><code class="language-java">// AttributeAccessorSupport.java

/** Map with String keys and Object values. */
private final Map&lt;String, Object&gt; attributes = new LinkedHashMap&lt;&gt;();

@Override
@Nullable
public Object getAttribute(String name) {
	Assert.notNull(name, "Name must not be null");
	return this.attributes.get(name);
}
</code></pre> </td></tr></tbody></table> 
<h2 id="2-lookup-method-子元素">2. lookup-method 子元素</h2> 
<blockquote> 
 <p><strong>lookup-method</strong> ：获取器注入，是把一个方法声明为返回某种类型的 bean 但实际要返回的 bean 是在配置文件里面配置的。该方法可以用于设计一些可插拔的功能上，解除程序依赖。</p> 
</blockquote> 
<h3 id="2-1-示例">2.1 示例</h3> 
<p>直接上例子：</p> 
<table><tbody><tr><td> <pre class="has"><code class="language-java">public interface Car {

    void display();

}

public class Bmw implements Car{

    @Override
    public void display() {
        System.out.println("我是 BMW");
    }

}

public class Hongqi implements Car{

    @Override
    public void display() {
        System.out.println("我是 hongqi");
    }

}

public abstract class Display {

    public void display(){
        getCar().display();
    }
    
    public abstract Car getCar();

}

public static void main(String[] args) {
    ApplicationContext context = new ClassPathXmlApplicationContext("classpath:spring.xml");
    Display display = (Display) context.getBean("display");
    display.display();
}
</code></pre> </td></tr></tbody></table> 
<p>XML 配置内容如下：</p> 
<table><tbody><tr><td> <pre class="has"><code class="language-html">&lt;bean id="display" class="org.springframework.core.test1.Display"&gt;
    &lt;lookup-method name="getCar" bean="hongqi"/&gt;
&lt;/bean&gt;
</code></pre> </td></tr></tbody></table> 
<p>运行结果为：</p> 
<table><tbody><tr><td> <pre class="has"><code class="language-html">我是 hongqi
</code></pre> </td></tr></tbody></table> 
<p>如果将 <code>bean="hognqi"</code> 替换为 <code>bean="bmw"</code>，则运行结果变成：</p> 
<table><tbody><tr><td> <pre class="has"><code class="language-html">我是 BMW
</code></pre> </td></tr></tbody></table> 
<h3 id="2-2-parseLookupOverrideSubElements">2.2 parseLookupOverrideSubElements</h3> 
<p>看了这个示例，我们初步了解了 <code>looku-method</code> 子元素提供的功能了。其解析通过 <code>#parseLookupOverrideSubElements(Element beanEle, MethodOverrides overrides)</code> 方法，代码如下：</p> 
<table><tbody><tr><td> <pre class="has"><code class="language-html">// BeanDefinitionParserDelegate.java

public void parseLookupOverrideSubElements(Element beanEle, MethodOverrides overrides) {
    NodeList nl = beanEle.getChildNodes();
    // 遍历子节点
    for (int i = 0; i &lt; nl.getLength(); i++) {
        Node node = nl.item(i);
        if (isCandidateElement(node) &amp;&amp; nodeNameEquals(node, LOOKUP_METHOD_ELEMENT)) { // 标签名为 lookup-method
            Element ele = (Element) node;
            String methodName = ele.getAttribute(NAME_ATTRIBUTE); // name
            String beanRef = ele.getAttribute(BEAN_ELEMENT); // bean
            // 创建 LookupOverride 对象
            LookupOverride override = new LookupOverride(methodName, beanRef);
            override.setSource(extractSource(ele));
            // 添加到 MethodOverrides 中
            overrides.addOverride(override);
        }
    }
}
</code></pre> </td></tr></tbody></table> 
<p>解析过程和 <code>meta</code> 子元素没有多大区别，同样是解析 methodName、beanRef 构造一个 LookupOverride 对象，然后记录到 AbstractBeanDefinition 中的 <code>methodOverrides</code> 属性中。</p> 
<p>在实例化 Bean 的时候，再详细阐述具体的实现过程，这里仅仅只是一个<strong>标记</strong>作用。</p> 
<h2 id="3-replace-method-子元素">3. replace-method 子元素</h2> 
<blockquote> 
 <p><strong>replaced-method</strong> ：可以在运行时调用新的方法替换现有的方法，还能动态的更新原有方法的逻辑。</p> 
</blockquote> 
<h3 id="3-1-示例">3.1 示例</h3> 
<p>该标签使用方法和 <code>lookup-method</code> 标签差不多，只不过替代方法的类需要实现 <code>org.springframework.beans.factory.support.MethodReplacer</code> 接口。如下:</p> 
<table><tbody><tr><td> <pre class="has"><code class="language-html">public class Method {

    public void display(){
        System.out.println("我是原始方法");
    }

}

public class MethodReplace implements MethodReplacer {

    @Override
    public Object reimplement(Object obj, Method method, Object[] args) throws Throwable {
        System.out.println("我是替换方法");
        return null;
    }

}

public static void main(String[] args) {
    ApplicationContext context = new ClassPathXmlApplicationContext("classpath:spring.xml");
    Method method = (Method) context.getBean("method");
    method.display();
}
</code></pre> </td></tr></tbody></table> 
<p>如果 <code>spring.xml</code> 文件如下：</p> 
<table><tbody><tr><td> <pre class="has"><code class="language-html">&lt;bean id="methodReplace" class="org.springframework.core.test1.MethodReplace"/&gt;

&lt;bean id="method" class="org.springframework.core.test1.Method"/&gt;
</code></pre> </td></tr></tbody></table> 
<p>则运行结果为：</p> 
<table><tbody><tr><td> <pre class="has"><code class="language-html">我是原始方法
</code></pre> </td></tr></tbody></table> 
<p>增加 <code>replaced-method</code> 子元素：</p> 
<table><tbody><tr><td> <pre class="has"><code class="language-html">&lt;bean id="methodReplace" class="org.springframework.core.test1.MethodReplace"/&gt;

&lt;bean id="method" class="org.springframework.core.test1.Method"&gt;

    &lt;replaced-method name="display" replacer="methodReplace"/&gt;

&lt;/bean&gt;
</code></pre> </td></tr></tbody></table> 
<p>运行结果为：</p> 
<table><tbody><tr><td> <pre class="has"><code class="language-html">我是替换方法
</code></pre> </td></tr></tbody></table> 
<h3 id="3-2-parseReplacedMethodSubElements">3.2 parseReplacedMethodSubElements</h3> 
<p>上面代码演示了 <code>replaced-method</code> 子元素的用法，其解析通过 <code>#parseReplacedMethodSubElements(Element beanEle, MethodOverrides overrides)</code> 方法，代码如下：</p> 
<table><tbody><tr><td> <pre class="has"><code class="language-html">/**
 * Parse replaced-method sub-elements of the given bean element.
 */
public void parseReplacedMethodSubElements(Element beanEle, MethodOverrides overrides) {
    NodeList nl = beanEle.getChildNodes();
    // 遍历子节点
    for (int i = 0; i &lt; nl.getLength(); i++) {
        Node node = nl.item(i);
        if (isCandidateElement(node) &amp;&amp; nodeNameEquals(node, REPLACED_METHOD_ELEMENT)) { // 标签名为 replace-method
            Element replacedMethodEle = (Element) node;
            String name = replacedMethodEle.getAttribute(NAME_ATTRIBUTE); // name
            String callback = replacedMethodEle.getAttribute(REPLACER_ATTRIBUTE); // replacer
            // 创建 ReplaceOverride 对象
            ReplaceOverride replaceOverride = new ReplaceOverride(name, callback);
            // Look for arg-type match elements. 参见 《spring bean中lookup-method属性 replaced-method属性》 http://linql2010-126-com.iteye.com/blog/2018385
            List&lt;Element&gt; argTypeEles = DomUtils.getChildElementsByTagName(replacedMethodEle, ARG_TYPE_ELEMENT); // arg-type 子标签
            for (Element argTypeEle : argTypeEles) {
                String match = argTypeEle.getAttribute(ARG_TYPE_MATCH_ATTRIBUTE); // arg-type 子标签的 match 属性
                match = (StringUtils.hasText(match) ? match : DomUtils.getTextValue(argTypeEle));
                if (StringUtils.hasText(match)) {
                    replaceOverride.addTypeIdentifier(match);
                }
            }
            replaceOverride.setSource(extractSource(replacedMethodEle));
            // 添加到 MethodOverrides 中
            overrides.addOverride(replaceOverride);
        }
    }
}
</code></pre> </td></tr></tbody></table> 
<p>该子元素和 <code>lookup-method</code> 标签的解析过程差不多，同样是提取 <code>name</code> 和 <code>replacer</code> 属性构建 ReplaceOverride 对象，然后记录到 AbstractBeanDefinition 中的 <code>methodOverrides</code> 属性中。</p> 
<p>在实例化 Bean 的时候，再详细阐述具体的实现过程，这里仅仅只是一个<strong>标记</strong>作用。</p> 
<h2 id="4-小结">4. 小结</h2> 
<p>对于 <code>lookup-method</code> 和 <code>replaced-method</code> 两个子元素是如何使用以完成他们所提供的功能，在后续实例化 Bean 的时候会做详细说明。</p> 
<blockquote> 
 <p>老艿艿：貌似，实际 Spring 使用场景中，也很少用这两个标签。</p> 
</blockquote>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/6a44b1c99a3f2c649c4b170336b17213/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">基础练习 完美的代价</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/bfa7bca57eaec819ed5b1033237575ca/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">基于阿里云服务器的网站部署教程（二） — Python的Flask&#43;uwsgi&#43;nginx部署</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>