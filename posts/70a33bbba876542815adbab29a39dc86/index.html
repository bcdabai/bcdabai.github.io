<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Java并发学习(二十三)-LinkedBlockingQueue和LinkedBlockingDeque分析 - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Java并发学习(二十三)-LinkedBlockingQueue和LinkedBlockingDeque分析" />
<meta property="og:description" content="有两个比较相似的并发阻塞队列，LinkedBlockingQueue和LinkedBlockingDeque，两个都是队列，只不过前者只能一端出一端入，后者则可以两端同时出入，并且都是结构改变线程安全的队列。其实两个队列从实现思想上比较容易理解，有以下特点：
链表结构（动态数组）通过ReentrantLock实现锁利用Condition实现队列的阻塞等待，唤醒 以下将分开讲述LinkedBlockingQueue和LinkedBlockingDeque的基本特点及操作。
LinkedBlockingQueue 这是一个只能一端出一端如的单向队列结构，是有FIFO特性的，并且是通过两个ReentrantLock和两个Condition来实现的。先看它的结构基本字段：
/** * 基于链表。 * FIFO * 单向 *最大容量是Integer.MAX_VALUE. */ public class LinkedBlockingQueueAnalysis&lt;E&gt; extends AbstractQueue&lt;E&gt; implements BlockingQueue&lt;E&gt;, java.io.Serializable { /* * 两个方向。 * putLock * takeLock * 有些操作会需要同时获取两把锁。 * 例如remove操作，也需要获取两把锁 */ //主要的node节点 static class Node&lt;E&gt; { E item; Node&lt;E&gt; next; Node(E x) { item = x; } } //容量，一开始就固定了的。 private final int capacity; //用AtomicInteger 来记录数量。 private final AtomicInteger count = new AtomicInteger(); //head节点 head.item == null transient Node&lt;E&gt; head; //last节点，last." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/70a33bbba876542815adbab29a39dc86/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2018-01-10T20:23:18+08:00" />
<meta property="article:modified_time" content="2018-01-10T20:23:18+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Java并发学习(二十三)-LinkedBlockingQueue和LinkedBlockingDeque分析</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-light">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p>有两个比较相似的并发阻塞队列，LinkedBlockingQueue和LinkedBlockingDeque，两个都是队列，只不过前者只能一端出一端入，后者则可以两端同时出入，并且都是结构改变线程安全的队列。其实两个队列从实现思想上比较容易理解，有以下特点：</p> 
<ul><li>链表结构（动态数组）</li><li>通过ReentrantLock实现锁</li><li>利用Condition实现队列的阻塞等待，唤醒</li></ul> 
<p>以下将分开讲述LinkedBlockingQueue和LinkedBlockingDeque的基本特点及操作。</p> 
<h3 id="linkedblockingqueue">LinkedBlockingQueue</h3> 
<p>这是一个只能一端出一端如的单向队列结构，是有FIFO特性的，并且是通过两个ReentrantLock和两个Condition来实现的。先看它的结构基本字段：</p> 
<pre class="prettyprint"><code class="language-Java hljs axapta"><span class="hljs-comment">/**
 * 基于链表。
 * FIFO
 * 单向
 *最大容量是Integer.MAX_VALUE.
 */</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LinkedBlockingQueueAnalysis</span>&lt;<span class="hljs-title">E</span>&gt; <span class="hljs-inheritance"><span class="hljs-keyword">extends</span></span> <span class="hljs-title">AbstractQueue</span>&lt;<span class="hljs-title">E</span>&gt;
        <span class="hljs-inheritance"><span class="hljs-keyword">implements</span></span> <span class="hljs-title">BlockingQueue</span>&lt;<span class="hljs-title">E</span>&gt;, <span class="hljs-title">java</span>.<span class="hljs-title">io</span>.<span class="hljs-title">Serializable</span> {<!-- --></span>
    <span class="hljs-comment">/*
     * 两个方向。
     * putLock
     * takeLock
     * 有些操作会需要同时获取两把锁。
     * 例如remove操作，也需要获取两把锁
     */</span>

    <span class="hljs-comment">//主要的node节点</span>
    <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Node</span>&lt;<span class="hljs-title">E</span>&gt; {<!-- --></span>
        E item;
        Node&lt;E&gt; next;
        Node(E x) { item = x; }
    }

    <span class="hljs-comment">//容量，一开始就固定了的。</span>
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> capacity;

    <span class="hljs-comment">//用AtomicInteger 来记录数量。</span>
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> AtomicInteger <span class="hljs-keyword">count</span> = <span class="hljs-keyword">new</span> AtomicInteger();

    <span class="hljs-comment">//head节点 head.item == null</span>
    transient Node&lt;E&gt; head;

    <span class="hljs-comment">//last节点，last.next == null</span>
    <span class="hljs-keyword">private</span> transient Node&lt;E&gt; last;

    <span class="hljs-comment">//take锁</span>
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> ReentrantLock takeLock = <span class="hljs-keyword">new</span> ReentrantLock();

    <span class="hljs-comment">//等待take的节点序列。</span>
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Condition notEmpty = takeLock.newCondition();

    <span class="hljs-comment">//put的lock。</span>
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> ReentrantLock putLock = <span class="hljs-keyword">new</span> ReentrantLock();

   <span class="hljs-comment">//等待puts的队列。</span>
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Condition notFull = putLock.newCondition();
    ...
}</code></pre> 
<p>和LinkedBlockingDeque的区别之一就是，LinkedBlockingQueue采用了两把锁来对队列进行操作，也就是队尾添加的时候， <br> 队头仍然可以删除等操作。接下来看典型的操作。</p> 
<h4 id="put操作">put操作</h4> 
<p>首先看put操作：</p> 
<pre class="prettyprint"><code class="language-Java hljs axapta">    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> put(E e) throws InterruptedException {
        <span class="hljs-keyword">if</span> (e == <span class="hljs-keyword">null</span>) <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> NullPointerException();   <span class="hljs-comment">//e不能为null</span>
        <span class="hljs-keyword">int</span> c = -<span class="hljs-number">1</span>;
        Node&lt;E&gt; node = <span class="hljs-keyword">new</span> Node&lt;E&gt;(e);
        <span class="hljs-keyword">final</span> ReentrantLock putLock = <span class="hljs-keyword">this</span>.putLock;     <span class="hljs-comment">//获取put锁</span>
        <span class="hljs-keyword">final</span> AtomicInteger <span class="hljs-keyword">count</span> = <span class="hljs-keyword">this</span>.<span class="hljs-keyword">count</span>;          <span class="hljs-comment">//获取count</span>
        putLock.lockInterruptibly();
        <span class="hljs-keyword">try</span> {
            <span class="hljs-keyword">while</span> (<span class="hljs-keyword">count</span>.get() == capacity) {        <span class="hljs-comment">//如果满了，那么就需要使用notFull阻塞</span>
                notFull.await();
            }
            enqueue(node);
            c = <span class="hljs-keyword">count</span>.getAndIncrement();
            <span class="hljs-keyword">if</span> (c + <span class="hljs-number">1</span> &lt; capacity)                    <span class="hljs-comment">//如果此时又有空间了，那么notFull唤醒</span>
                notFull.signal();
        } <span class="hljs-keyword">finally</span> {
            putLock.unlock();             <span class="hljs-comment">//释放锁</span>
        }
        <span class="hljs-keyword">if</span> (c == <span class="hljs-number">0</span>)            <span class="hljs-comment">//当c为0时候，也要根take锁说一下，并发下</span>
            signalNotEmpty();        <span class="hljs-comment">//调用notEmpty        </span>
    }</code></pre> 
<p>主要的思想还是比较容易理解的，现在看看<code>enqueue</code> 方法：</p> 
<pre class="prettyprint"><code class="language-Java hljs cs">    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">enqueue</span>(Node&lt;E&gt; node) {        <span class="hljs-comment">//入对操作。</span>
        last = last.next = node;      <span class="hljs-comment">//队尾进</span>
    }</code></pre> 
<p>再看看<code>signalNotEmpty</code>方法：</p> 
<pre class="prettyprint"><code class="language-Java hljs cs">    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">signalNotEmpty</span>() {
        final ReentrantLock takeLock = <span class="hljs-keyword">this</span>.takeLock;
        takeLock.<span class="hljs-keyword">lock</span>();        <span class="hljs-comment">//加锁</span>
        <span class="hljs-keyword">try</span> {
            notEmpty.signal();    <span class="hljs-comment">//用于signal，notEmpty</span>
        } <span class="hljs-keyword">finally</span> {
            takeLock.unlock();
        }
    }</code></pre> 
<h4 id="take操作">take操作</h4> 
<p>take操作，就是从队列里面弹出一个元素，下面看它的详细代码：</p> 
<pre class="prettyprint"><code class="language-Java hljs axapta">    <span class="hljs-keyword">public</span> E take() throws InterruptedException {
        E x;
        <span class="hljs-keyword">int</span> c = -<span class="hljs-number">1</span>;            <span class="hljs-comment">//设定一个记录变量</span>
        <span class="hljs-keyword">final</span> AtomicInteger <span class="hljs-keyword">count</span> = <span class="hljs-keyword">this</span>.<span class="hljs-keyword">count</span>;     <span class="hljs-comment">//获得count</span>
        <span class="hljs-keyword">final</span> ReentrantLock takeLock = <span class="hljs-keyword">this</span>.takeLock;
        takeLock.lockInterruptibly();        <span class="hljs-comment">//加锁</span>
        <span class="hljs-keyword">try</span> {
            <span class="hljs-keyword">while</span> (<span class="hljs-keyword">count</span>.get() == <span class="hljs-number">0</span>) {       <span class="hljs-comment">//如果没有元素，那么就阻塞性等待</span>
                notEmpty.await();
            }
            x = dequeue();            <span class="hljs-comment">//一定可以拿到。</span>
            c = <span class="hljs-keyword">count</span>.getAndDecrement();
            <span class="hljs-keyword">if</span> (c &gt; <span class="hljs-number">1</span>)
                notEmpty.signal();        <span class="hljs-comment">//报告还有元素，唤醒队列</span>
        } <span class="hljs-keyword">finally</span> {
            takeLock.unlock();
        }
        <span class="hljs-keyword">if</span> (c == capacity)
            signalNotFull();           <span class="hljs-comment">//解锁</span>
        <span class="hljs-keyword">return</span> x;
    }</code></pre> 
<p>接下来看<code>dequeue</code>方法：</p> 
<pre class="prettyprint"><code class="language-Java hljs cs">   <span class="hljs-keyword">private</span> E <span class="hljs-title">dequeue</span>() {
        Node&lt;E&gt; h = head;
        Node&lt;E&gt; first = h.next;
        h.next = h;        <span class="hljs-comment">// help GC 指向自己，帮助gc回收</span>
        head = first;
        E x = first.item;       <span class="hljs-comment">//从队头出。</span>
        first.item = <span class="hljs-keyword">null</span>;      <span class="hljs-comment">//将head.item设为null。</span>
        <span class="hljs-keyword">return</span> x;
    }</code></pre> 
<p>对于LinkedBlockingQueue来说，有两个ReentrantLock分别控制队头和队尾，这样就可以使得添加操作分开来做，一般的操作是获取一把锁就可以，但有些操作例如remove操作，则需要同时获取两把锁：</p> 
<pre class="prettyprint"><code class="language-Java hljs java">    <span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">remove</span>(Object o) {
        <span class="hljs-keyword">if</span> (o == <span class="hljs-keyword">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;
        fullyLock();     <span class="hljs-comment">//获取锁</span>
        <span class="hljs-keyword">try</span> {
            <span class="hljs-keyword">for</span> (Node&lt;E&gt; trail = head, p = trail.next;
                 p != <span class="hljs-keyword">null</span>;
                 trail = p, p = p.next) {     <span class="hljs-comment">//依次循环遍历</span>
                <span class="hljs-keyword">if</span> (o.equals(p.item)) {       <span class="hljs-comment">//找到了</span>
                    unlink(p, trail);       <span class="hljs-comment">//解除链接</span>
                    <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;
                }
            }
            <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;        <span class="hljs-comment">//没找到，或者解除失败</span>
        } <span class="hljs-keyword">finally</span> {
            fullyUnlock();
        }
    }</code></pre> 
<p><strong>当然，除了上述的remove方法外，在Iterator的next方法，remove方法以及LBQSpliterator分割迭代器中也是需要加全锁进行操作的。</strong></p> 
<h3 id="linkedblockingdeque">LinkedBlockingDeque</h3> 
<p>名字很相近，LinkedBlockingDeque就是一个双端队列，任何一端都可以进行元素的出入，接下来看它的主要字段：</p> 
<pre class="prettyprint"><code class="language-Java hljs axapta"><span class="hljs-comment">/**
 * 双端队列。
 * 最大值是Integer.MAX_VALUE
 * 所谓弱一致性有利于删除，有点理解了，
 * 或许是比如clear方法，不知直接把引用置为null，而是一个个解除连接。
 * 利用lock锁去控制并发访问，利用condition去控制阻塞
 * weakly consistent的iterators。
 * 我们需要保持所有的node都要是gc可达的。
 */</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LinkedBlockingDeque</span>&lt;<span class="hljs-title">E</span>&gt;
    <span class="hljs-inheritance"><span class="hljs-keyword">extends</span></span> <span class="hljs-title">AbstractQueue</span>&lt;<span class="hljs-title">E</span>&gt;
    <span class="hljs-inheritance"><span class="hljs-keyword">implements</span></span> <span class="hljs-title">BlockingDeque</span>&lt;<span class="hljs-title">E</span>&gt;, <span class="hljs-title">java</span>.<span class="hljs-title">io</span>.<span class="hljs-title">Serializable</span> {<!-- --></span>
    <span class="hljs-comment">//双向联结的节点。</span>
    <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Node</span>&lt;<span class="hljs-title">E</span>&gt; {<!-- --></span>
        E item;    <span class="hljs-comment">//泛型的item变量</span>

        <span class="hljs-comment">// 前一个节点</span>
        Node&lt;E&gt; prev;

        <span class="hljs-comment">//next后一个节点</span>
        Node&lt;E&gt; next;

        Node(E x) {
            item = x;
        }
    }

    <span class="hljs-comment">//头节点</span>
    transient Node&lt;E&gt; first;

    <span class="hljs-comment">//尾节点。</span>
    transient Node&lt;E&gt; last;

    <span class="hljs-comment">//count，表示数值。</span>
    <span class="hljs-keyword">private</span> transient <span class="hljs-keyword">int</span> <span class="hljs-keyword">count</span>;

    <span class="hljs-comment">//容量</span>
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> capacity;

    <span class="hljs-comment">//实现控制访问的锁</span>
    <span class="hljs-keyword">final</span> ReentrantLock lock = <span class="hljs-keyword">new</span> ReentrantLock();

    <span class="hljs-comment">//take的Condition</span>
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Condition notEmpty = lock.newCondition();

    <span class="hljs-comment">//put的Condition</span>
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Condition notFull = lock.newCondition();
    ...
}</code></pre> 
<p>从上面的结果来看，其实LinkedBlockingDeque的结构上来说，有点像ArrayBlockingQueue的构造，也是一个ReentrantLock和两个Condition，下面分别对其中重要方法进行分析。</p> 
<ul><li>public void addFirst(E e) </li><li>public void addLast(E e)</li><li>public boolean offerFirst(E e)</li><li>public boolean offerLast(E e)</li><li>…</li></ul> 
<p>对于LinkedBlockingDeque，和ArrayBlockingQueue结构还是很类似的，也是一个ReentrantLock和两个Condition使用，但是仅仅是在这二者使用上，其实内部运转还是很大不同的。</p> 
<h4 id="offerfirst操作">offerFirst操作</h4> 
<p><code>offerFirst</code>就是在队头添加一个元素：</p> 
<pre class="prettyprint"><code class="language-Java hljs cs">    <span class="hljs-keyword">public</span> boolean <span class="hljs-title">offerFirst</span>(E e) {
        <span class="hljs-keyword">if</span> (e == <span class="hljs-keyword">null</span>) <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> NullPointerException();
        Node&lt;E&gt; node = <span class="hljs-keyword">new</span> Node&lt;E&gt;(e);
        final ReentrantLock <span class="hljs-keyword">lock</span> = <span class="hljs-keyword">this</span>.<span class="hljs-keyword">lock</span>;    <span class="hljs-comment">//加锁</span>
        <span class="hljs-keyword">lock</span>.<span class="hljs-keyword">lock</span>();
        <span class="hljs-keyword">try</span> {
            <span class="hljs-keyword">return</span> linkFirst(node);
        } <span class="hljs-keyword">finally</span> {
            <span class="hljs-keyword">lock</span>.unlock();
        }
    }</code></pre> 
<p>接下来看<code>linkFirst</code>方法：</p> 
<pre class="prettyprint"><code class="language-Java hljs java">    <span class="hljs-keyword">private</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">linkFirst</span>(Node&lt;E&gt; node) {
        <span class="hljs-keyword">if</span> (count &gt;= capacity)         <span class="hljs-comment">//容量满了</span>
            <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;
        Node&lt;E&gt; f = first;           <span class="hljs-comment">//在队头添加</span>
        node.next = f;
        first = node;
        <span class="hljs-keyword">if</span> (last == <span class="hljs-keyword">null</span>)        <span class="hljs-comment">//第一个节点</span>
            last = node;
        <span class="hljs-keyword">else</span>
            f.prev = node;
        ++count;              <span class="hljs-comment">//count自增</span>
        notEmpty.signal();           <span class="hljs-comment">//说明不为null。唤醒等待队列</span>
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;
    }</code></pre> 
<p>其他的方法类似，都是加锁后对链表的操作，这里就不赘述了。</p> 
<h4 id="clear操作">clear操作</h4> 
<p>其实我一开始看clear操作时候，总以为它是直接把first和last分别置为null就行了，非常简单，但实际上，它的实现方法却是遍历以便，分别把所有node指针都指向null从而方便gc。</p> 
<pre class="prettyprint"><code class="language-Java hljs cs">    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">clear</span>() {
        final ReentrantLock <span class="hljs-keyword">lock</span> = <span class="hljs-keyword">this</span>.<span class="hljs-keyword">lock</span>;
        <span class="hljs-keyword">lock</span>.<span class="hljs-keyword">lock</span>();               <span class="hljs-comment">//加锁后清空所有。</span>
        <span class="hljs-keyword">try</span> {
            <span class="hljs-keyword">for</span> (Node&lt;E&gt; f = first; f != <span class="hljs-keyword">null</span>; ) {   <span class="hljs-comment">//遍历一遍</span>
                f.item = <span class="hljs-keyword">null</span>;       <span class="hljs-comment">//置空操作</span>
                Node&lt;E&gt; n = f.next;
                f.prev = <span class="hljs-keyword">null</span>;
                f.next = <span class="hljs-keyword">null</span>;
                f = n;      <span class="hljs-comment">//f后移动一个</span>
            }
            first = last = <span class="hljs-keyword">null</span>;
            count = <span class="hljs-number">0</span>;
            notFull.signalAll();           <span class="hljs-comment">//通知等待put线程</span>
        } <span class="hljs-keyword">finally</span> {
            <span class="hljs-keyword">lock</span>.unlock();
        }
    }</code></pre> 
<p>这样的思路很值得学习借鉴。</p> 
<h3 id="总结">总结</h3> 
<p>总的来说，这两个阻塞队列实现上还是比较容易理解的，具体细节方面还是很值得阅读的。</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/671d9a7ff56094541e40a2dbc4b896ad/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">pythonweb——前端（一）：HTML的常用标签</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/7e690eedf608ccd5f84cf207cc2ee15c/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">PTA JAVA选择题汇总（一）</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>