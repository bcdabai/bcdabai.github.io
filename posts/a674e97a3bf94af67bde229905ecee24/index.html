<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>QCOW2镜像格式 - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="QCOW2镜像格式" />
<meta property="og:description" content="QEMU copy-on-write format with a range of special features, including the ability to take multiple snapshots, smaller images on filesystems that don’t support sparse files, optional AES encryption, and optional zlib compression
现在比较主流的一种虚拟化镜像格式，经过一代的优化，目前qcow2的性能上接近raw裸格式的性能
QCOW2镜像格式是Qemu支持的磁盘镜像格式之一。它可以使用一个文件来表示一个固定大小的块设备。与Raw镜像格式相比，QCOW2具有如下优点：
更小的文件大小，即便不支持holes（稀疏文件）的文件系统同样适用支持写时拷贝(COW, Copy-on-write)，QCOW2镜像只反映底层磁盘镜像所做的修改支持快照，QCOW2镜像可以包含镜像历史的多重快照支持基于zlib的数据压缩支持AES加密 qemu-img是管理镜像文件文件最常用的命令，使用方法如下：
# 创建一个名为test.qcow2，大小为4G的qcow2镜像
$ qemu-img create -f qcow2 test.qcow2 4G
# 将QCOW2格式的test.qcow2文件转换成raw格式的test.img文件
$ qemu-img convert test.qcow2 -O raw test.img
QCOW2头
每一个QCOW2文件均以一个大端(big endian)格式的头开始，其格式如下：
typedef struct QCowHeader {
uint32_t magic;
uint32_t version;
uint64_t backing_file_offset;
uint32_t backing_file_size;" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/a674e97a3bf94af67bde229905ecee24/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2021-11-04T10:42:19+08:00" />
<meta property="article:modified_time" content="2021-11-04T10:42:19+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">QCOW2镜像格式</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p>QEMU copy-on-write format with a range of special features, including the ability to take multiple snapshots, smaller images on filesystems that don’t support sparse files, optional AES encryption, and optional zlib compression</p> 
<p>现在比较主流的一种虚拟化镜像格式，经过一代的优化，目前qcow2的性能上接近raw裸格式的性能</p> 
<p></p> 
<p>QCOW2镜像格式是Qemu支持的磁盘镜像格式之一。它可以使用一个文件来表示一个固定大小的块设备。与Raw镜像格式相比，QCOW2具有如下优点：</p> 
<ol><li>更小的文件大小，即便不支持holes（稀疏文件）的文件系统同样适用</li><li>支持写时拷贝(COW, Copy-on-write)，QCOW2镜像只反映底层磁盘镜像所做的修改</li><li>支持快照，QCOW2镜像可以包含镜像历史的多重快照</li><li>支持基于zlib的数据压缩</li><li>支持AES加密</li></ol> 
<p>qemu-img是管理镜像文件文件最常用的命令，使用方法如下：</p> 
<p># 创建一个名为test.qcow2，大小为4G的qcow2镜像</p> 
<p>$ qemu-img create -f qcow2 test.qcow2 4G</p> 
<p># 将QCOW2格式的test.qcow2文件转换成raw格式的test.img文件</p> 
<p>$ qemu-img convert test.qcow2 -O raw test.img</p> 
<p></p> 
<p><strong>QCOW2头</strong></p> 
<p>每一个QCOW2文件均以一个大端(big endian)格式的头开始，其格式如下：</p> 
<p>typedef struct QCowHeader {<!-- --></p> 
<p>      uint32_t magic;</p> 
<p>      uint32_t version;</p> 
<p>      uint64_t backing_file_offset;</p> 
<p>      uint32_t backing_file_size;</p> 
<p>      uint32_t cluster_bits;</p> 
<p>      uint64_t size; /* in bytes */</p> 
<p>      uint32_t crypt_method;</p> 
<p>      uint32_t l1_size;</p> 
<p>      uint64_t l1_table_offset;</p> 
<p>      uint64_t refcount_table_offset;</p> 
<p>      uint32_t refcount_table_clusters;</p> 
<p></p> 
<p>      uint32_t nb_snapshots;</p> 
<p>      uint64_t snapshots_offset;</p> 
<p>  } QCowHeader;</p> 
<ul><li>前四个字节magic字段包含了字符’Q’,’F’和’I’，接下来是0xfb。</li><li>接下来的四个字节version字段表示文件所使用的格式版本号。当前有两种版本格式，版本1和版本2，即QCOW和QCOW2.我们将重点介绍QCOW2，结尾处我们会对QCOW和QCOW2进行比较。</li><li>hacking_field_offset字段给出了文件起始位置到包含文件路径字符串的距离偏移值，该字段为8字节；backing_file_size字段给出了表示文件路径的字符串(非’\0’结尾)的长度。如果该镜像文件为COW镜像，该字符串指向原始文件的绝对路径。后续我们会继续讨论。</li><li>cluster_bits字段，该4字节字段描述了如何将镜像偏移位置映射到本地文件中；该字段决定了在一个簇中，可作为索引的偏移地址低位比特位数。由于L2表独占了一个簇，并包含8字节的项，因此地址中cluster_bits减3之外的其余高位比特作为L2表的索引值。L2表的详细内容会在如下的2级检索中介绍。</li><li>接下来的8字节，size字段，表示了该镜像所表示的块设备大小，块设备大小值以字节为单位。</li><li>cypt_method字段包含0和1两种值，为0时表示没有使用加密方法，1表示采用了AES加密算法。</li><li>l1_size字段给出了L1表的大小，l1_table_offset字段给出了L1表中偏移值。</li><li>refcount_table_offset给出了refcount表的偏移量，refcount_table_clusters描述了以簇为单位的refcount表的大小。</li><li>每一个快照都有一个QCowSnapshotHeader,nb_snapshots给出了镜像中包含的快照数目，即QCowSnapshotHeader的数目，snapshots_offset字段给出了QCowSnapshotHeader的偏移值。</li></ul> 
<p>通常一个镜像文件包含以下几部分：</p> 
<ul><li>上文中提到的头文件信息</li><li>L1表，以簇对齐，从下一个簇的起始点存储</li><li>refcount表，同样为簇对齐</li><li>一个或者多个refcount块</li><li>快照头，第一个头要求簇对齐，其余的头要求8字节对齐</li><li>L2表，每个表独占一个簇</li><li>数据簇</li></ul> 
<p></p> 
<p><strong>二级检索</strong></p> 
<p>    对于QCOW2镜像格式，磁盘设备的内容保存在簇中。每一个簇包含多个512字节的扇区。</p> 
<p>    为了将给定的地址定位到簇的地址，必须要遍历L1表和L2表。L1表中存储了一组到L2表的偏移值，而L2表中存储了一组到簇的偏移值。</p> 
<p>    根据cluster_bits字段，给定的地址被划分为三个单独的偏移值。假设cluster_bits的值为12，那么地址可按如下步骤划分:</p> 
<ul><li>地址的低12位作为4Kb的簇偏移值</li><li>接下来的9比特表示L2表中512个表项数组的偏移值。由于L2表是一个包含8字节项的单独簇，因此这里需要的比特数的计算方式为l2_bits=cluster_bits – 3。</li><li>剩下的43比特为L1表中的8字节文件偏移值。</li></ul> 
<p>    注意，L1表的最小值可以通过给定的磁盘镜像大小来计算，计算方法如下：</p> 
<p>l1_size = round_up(disk_size / (cluster_size * l2_size), cluster_size)</p> 
<p>    总而言之，为了将磁盘镜像地址映射到镜像文件偏移值，需要经历如下步骤：</p> 
<ol><li>使用l1_table_offset字段获取L1表的地址</li><li>使用地址中的高(64-l2_bits-cluster_bits)位来检索L1表中的8字节数组项</li><li>使用L1表中的偏移值获取L2表的地址</li><li>使用地址中的l2_bits字段来检索L2表中的8字节数组项</li><li>使用L2表中偏移值来获取簇的地址</li><li>使用地址中剩下的cluster_bits字段作为簇中地址偏移值</li></ol> 
<p>如果L1或者L2表中获取的偏移值为0，则表示磁盘镜像对应的区域尚未被分配。</p> 
<p>    还需注意的是，L1和L2表中偏移值的高2位为“Copied”和“Compress”的预留比特位。具体细节见下文。</p> 
<p><strong>引用计数</strong></p> 
<p>    每一个簇都会被引用计数，这样做的目的是允许这些簇在不被任何快照使用的前提下能够及时的释放。</p> 
<p>    每一个簇的引用计数为2字节，这2字节的引用计数均保存在簇大小的块中。refcount块在镜像中的偏移值可以检索refcount表得到，而引用计数表则由refcount_table_offset和refcount_table_clusters共同定位，其中refcount_table_offset指定了refcount表相对起始位置的偏移值，refcount_table_clusters指定了refcount表占用的簇数。</p> 
<p>为了获取某个簇的引用计数，可以将簇偏移值划分为refcount表偏移值和refcount块偏移值。由于refcount块是一个两字节的存储项，簇偏移值的低cluster_size – 1位表示块偏移值，其余的位数表示表偏移值。</p> 
<p>这里QCOW2有一个优化处理，如果任何由L1表或者L2表的指向的簇的引用计数为1，则L1或L2表项最高位被置为“copied”标记。这意味着没有快照在使用当前簇，当前簇可以直接被写入，而不需要创建引用当前簇的快照。</p> 
<p></p> 
<p><strong>Copy-on-Write镜像</strong></p> 
<p>    QCOW2镜像可以用来存储另一个磁盘镜像的修改内容，而不影响原有磁盘的内容。这种镜像被称之为拷贝镜像，以用户的角度看起来像是一个独立的镜像文件，但是其中的大部分数据是从原始镜像中获取到的。只有原始镜像的簇发生改变的内容才会被存储到拷贝镜像中。</p> 
<p>    这种表示方式很容易实现。可以通过在Copy-on-write镜像中包含原始磁盘镜像中的路径，头文件中记录原文件的路径字符串。</p> 
<p>    当读取Copy-on-write镜像中的簇时，首先检查该区域是否存在Copy-on-write镜像文件内。如果不存在，则从原始磁盘镜像中读取对应的位置。</p> 
<p><strong>快照</strong></p> 
<p>    快照同COW文件概念比较相似，区别在于原文件是可写的，而快照不可写。</p> 
<p>    近一步解释—一个COW镜像也可被称为“快照”，因为COW确实表示了原始镜像文件的状态。我们可以通过创建多个COW镜像来实现对原始镜像的“快照”，每一个镜像指向原始镜像。值得注意的是，原始镜像必须保持只读，而COW快照为可写。</p> 
<p>    快照—“真实快照”—存在于原始镜像文件中。每个快照都是原始镜像在过去的某个时刻的只读记录。原始镜像文件一直保持可写的状态，当原始文件发生改变时，写时复制出来的簇可以被不同的快照引用。</p> 
<p>每个快照对应如下头：</p> 
<p>typedef struct QCowSnapshotHeader {<!-- --><br>       /* header is 8 byte aligned */<br>       uint64_t l1_table_offset;<br>       uint32_t l1_size;<br>       uint16_t id_str_size;<br>       uint16_t name_size;<br>       uint32_t date_sec;<br>       uint32_t date_nsec;<br>       uint64_t vm_clock_nsec;<br>       uint32_t vm_state_size;<br>       uint32_t extra_data_size; /* for extension */<br>       /* extra data follows */<br>       /* id_str follows */<br>       /* name follows  */<br>   } QCowSnapshotHeader;</p> 
<p>各字段解释如下：</p> 
<ul><li>每个快照都有一个name和ID，均为字符串格式(非’\0’结尾)，其位置在QCOWSnapshotHeader头之后。</li><li>每个快照至少保留L1表的副本， 其值体现在l1_table_offset和l1_size上。</li><li>快照创建时，通过date_sec和date_nsec获取到主机的gettimeofday()</li><li>vm_clock_nsec表示VM锁的当前状态</li><li>vm_state_size表示虚机状态的大小，而虚机状态作为快照的一部分被存储起来。虚机状态被保存在原始L1表中，紧随镜像头之后。</li><li>extra_data_size表示在头之后扩展数据的长度，不包括ID和name字符串。该字段为后续扩展使用。</li></ul> 
<p>    每创建一个快照就会增加一个头文件，复制L1表的内容，并增加所有L2表中的引用计数和被L1表引用的数据簇。之后，如果镜像中的任何L2表或者数据簇被修改了—也就是说，簇的引用计数值超过1，并且/或者当前簇的“拷贝”标志已被标记—Qemu会先拷贝这些L2表和数据簇，而后再进行写入。这样所有的快照都不会被修改。</p> 
<p><strong>压缩</strong></p> 
<p>    QCOW2镜像格式支持压缩特性，允许每一个簇可以独立通过zlib进行压缩。</p> 
<p>    可以通过如下步骤从L2表中获取簇偏移值：</p> 
<ul><li>如果簇偏移值的最高位为1，则表示该簇已被压缩</li><li>簇偏移值接下来的cluster_bits – 1位为压缩簇的大小，其单位为512字节的扇区</li><li>簇偏移值的其余位数为镜像中簇的实际地址</li></ul> 
<p><strong>加密</strong></p> 
<p>    QCOW2镜像格式同样支持簇的加密特性。</p> 
<p>    若QCowHeader头中的crypt_method字段值为1，则会采用16字符128比特的AES秘钥进行加密。</p> 
<p>簇中的每一个扇区都是通过AES密码块链接模式单独进行加密，采用小端模式的扇区偏移地址(相对于设备的起始位置)来作为128位初始化向量的头64位。</p> 
<p></p> 
<p><strong>QCOW2镜像与上一代镜像</strong></p> 
<p>QCOW2相对于QCOW有如下不同之处：</p> 
<ol><li>QCOW2支持快照概念，QCOW1仅支持copy-on-write镜像的概念</li><li>QCOW2中引用了引用计数的概念，引用计数用来支持快照的概念</li><li>QCOW2中L2表总是可以占据一个单独的簇，而之前簇的大小在头l2_bits中被指定</li><li>QCOW2压缩簇的大小以扇区为单位，而非字节为单位</li></ol>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/ebfb50e7808084657273afd5f38fd0cc/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">js把两个对象合并成一个对象</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/763a15943ee05a33b4e6a6b2a3913ae4/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">idea启动时不直接打开项目</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>