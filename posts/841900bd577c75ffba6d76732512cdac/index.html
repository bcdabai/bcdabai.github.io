<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>第3章-python深度学习——（波斯美女） - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="第3章-python深度学习——（波斯美女）" />
<meta property="og:description" content="第3章 神经网络入门 本章包括以下内容： 神经网络的核心组件 Keras 简介 建立深度学习工作站 使用神经网络解决基本的分类问题与回归问题 本章的目的是让你开始用神经网络来解决实际问题。你将进一步巩固在第 2 章第一个示例中学到的知识，还会将学到的知识应用于三个新问题，这三个问题涵盖神经网络最常见的三种使用场景：二分类问题、多分类问题和标量回归问题。 本章将进一步介绍神经网络的核心组件，即层、网络、目标函数和优化器；还会简要介绍Keras，它是贯穿本书的 Python 深度学习库。你还将建立深度学习工作站，安装好 TensorFlow和Keras，并支持GPU。
最后，我们将用三个介绍性示例深入讲解如何使用神经网络解决实际问题，这三个示例分别是：
将电影评论划分为正面或负面（二分类问题） 将新闻按主题分类（多分类问题） 根据房地产数据估算房屋价格（回归问题） 学完本章，你将能够使用神经网络解决简单的机器问题，比如对向量数据的分类问题和回归问题。然后，你就可以从第 4 章开始建立对机器学习更加具有原则性、理论性的理解。
3.1　神经网络剖析 前面几章介绍过，训练神经网络主要围绕以下四个方面。
层，多个层组合成网络（或模型）。 输入数据和相应的目标。 损失函数，即用于学习的反馈信号。 优化器，决定学习过程如何进行。 你可以将这四者的关系可视化，如图 3-1 所示：多个层链接在一起组成了网络，将输入数据映射为预测值。然后损失函数将这些预测值与目标进行比较，得到损失值，用于衡量网络预测值与预期结果的匹配程度。优化器使用这个损失值来更新网络的权重。
我们来进一步研究层、网络、损失函数和优化器。
3.1.1　层：深度学习的基础组件 我们在第 2 章中介绍过，神经网络的基本数据结构是层。层是一个数据处理模块，将一个或多个输入张量转换为一个或多个输出张量。有些层是无状态的，但大多数的层是有状态的，即层的权重。权重是利用随机梯度下降学到的一个或多个张量，其中包含网络的知识。
不同的张量格式与不同的数据处理类型需要用到不同的层。
例如，
（1）简单的向量数据保存在形状为 (samples, features) 的 2D 张量中，通常用密集连接层［densely connected layer，也叫全连接层（fully connected layer）或密集层（dense layer），对应于 Keras 的 Dense 类］来处理。
（2）序列数据保存在形状为 (samples, timesteps, features) 的 3D 张量中，通常用循环层（recurrent layer，比如 Keras 的 LSTM 层）来处理。
（3）图像数据保存在 4D 张量中，通常用二维卷积层（Keras 的 Conv2D）来处理。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/841900bd577c75ffba6d76732512cdac/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2024-01-28T22:46:35+08:00" />
<meta property="article:modified_time" content="2024-01-28T22:46:35+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">第3章-python深度学习——（波斯美女）</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <h2>第3章 神经网络入门</h2> 
<div style="text-align:justify;"> 
 <span style="color:#fe2c24;">本章包括以下内容： </span> 
</div> 
<div style="text-align:justify;"></div> 
<div style="text-align:justify;"> 
 <span style="color:#fe2c24;">神经网络的核心组件 </span> 
</div> 
<div style="text-align:justify;"> 
 <span style="color:#fe2c24;">Keras 简介 </span> 
</div> 
<div style="text-align:justify;"> 
 <span style="color:#fe2c24;">建立深度学习工作站 </span> 
</div> 
<div style="text-align:justify;"> 
 <span style="color:#fe2c24;">使用神经网络解决基本的分类问题与回归问题</span> 
</div> 
<div style="text-align:justify;"></div> 
<p style="text-align:justify;">本章的目的是让你开始用神经网络来解决实际问题。你将进一步巩固在第 2 章第一个示例中学到的知识，还会将学到的知识应用于三个新问题，这三个问题涵盖神经网络<strong>最常见的三种使用场景：二分类问题、多分类问题和标量回归问题。 </strong></p> 
<p style="text-align:justify;">本章将进一步介绍神经网络的核心组件，即层、网络、目标函数和优化器；还会简要介绍Keras，它是贯穿本书的 Python 深度学习库。你还将建立深度学习工作站，安装好 TensorFlow和Keras，并支持GPU。</p> 
<p style="text-align:justify;">最后，我们将用三个介绍性示例深入讲解如何使用神经网络解决实际问题，这三个示例分别是：</p> 
<div style="text-align:justify;"> 
 <span style="color:#fe2c24;">将电影评论划分为正面或负面（二分类问题） </span> 
</div> 
<div style="text-align:justify;"> 
 <span style="color:#fe2c24;">将新闻按主题分类（多分类问题） </span> 
</div> 
<div style="text-align:justify;"> 
 <span style="color:#fe2c24;">根据房地产数据估算房屋价格（回归问题）</span> 
</div> 
<div style="text-align:justify;"></div> 
<p style="text-align:justify;">学完本章，你将能够使用神经网络解决简单的机器问题，比如对向量数据的分类问题和回归问题。然后，你就可以从第 4 章开始建立对机器学习更加具有原则性、理论性的理解。</p> 
<h3 style="text-align:justify;">3.1　神经网络剖析</h3> 
<p style="text-align:justify;">前面几章介绍过，训练神经网络主要围绕以下四个方面。</p> 
<div style="text-align:justify;"> 
 <span style="color:#fe2c24;">层，多个层组合成网络（或模型）。 </span> 
</div> 
<div style="text-align:justify;"> 
 <span style="color:#fe2c24;">输入数据和相应的目标。 </span> 
</div> 
<div style="text-align:justify;"> 
 <span style="color:#fe2c24;">损失函数，即用于学习的反馈信号。 </span> 
</div> 
<div style="text-align:justify;"> 
 <span style="color:#fe2c24;">优化器，决定学习过程如何进行。</span> 
</div> 
<div style="text-align:justify;"></div> 
<p style="text-align:justify;">你可以将这四者的关系可视化，如<span style="color:#fe2c24;">图 3-1 </span>所示：<span style="color:#fe2c24;">多个层链接在一起组成了网络，将输入数据映射为预测值。然后损失函数将这些预测值与目标进行比较，得到损失值，用于衡量网络预测值与预期结果的匹配程度。优化器使用这个损失值来更新网络的权重</span>。</p> 
<p style="text-align:justify;"><img alt="" height="404" src="https://images2.imgbox.com/d1/ff/pooqGPuy_o.png" width="463"></p> 
<p style="text-align:justify;">我们来进一步研究层、网络、损失函数和优化器。</p> 
<h4 style="text-align:justify;"><span style="color:#fe2c24;"><strong>3.1.1　层：深度学习的基础组件</strong></span></h4> 
<p style="text-align:justify;">我们在第 2 章中介绍过，神经网络的基本数据结构是层。<strong><span style="color:#fe2c24;">层是一个数据处理模块，将一个或多个输入张量转换为一个或多个输出张量</span>。</strong>有些层是无状态的，但大多数的层是有状态的，即层的权重。<span style="color:#fe2c24;">权重是利用随机梯度下降学到的一个或多个张量，其中包含网络的知识</span>。</p> 
<p style="text-align:justify;">不同的张量格式与不同的数据处理类型需要用到不同的层。</p> 
<p style="text-align:justify;">例如，</p> 
<p style="text-align:justify;">（1）简单的向量数据保存在形状为 <span style="color:#fe2c24;">(samples, features)</span> 的 2D 张量中，通常用密集连接层［densely connected layer，也叫<span style="color:#fe2c24;"><strong>全连接层（fully connected layer）</strong></span>或<span style="color:#fe2c24;">密集层（dense layer）</span>，对应于 <strong>Keras 的 Dense </strong><strong>类</strong>］来处理。</p> 
<p style="text-align:justify;">（2）序列数据保存在形状为 <span style="color:#fe2c24;">(samples, timesteps, features)</span> 的 3D 张量中，通常用<span style="color:#fe2c24;">循环层（recurrent layer</span>，比如 <span style="color:#fe2c24;"><strong>Keras 的 LSTM </strong><strong>层</strong></span>）来处理。</p> 
<p style="text-align:justify;">（3）图像数据保存在 4D 张量中，通常用二维卷积层（Keras 的 Conv2D）来处理。</p> 
<p style="text-align:justify;">你可以将层看作深度学习的乐高积木，Keras 等框架则将这种比喻具体化。在 Keras 中，构建深度学习模型就是将相互兼容的多个层拼接在一起，以建立有用的数据变换流程。这里层兼容性（<span style="color:#fe2c24;">layer compatibility</span>）具体指的是每一层只接受特定形状的输入张量，并返回特定形状的输出张量。看看下面这个例子。</p> 
<pre><code class="language-python">from keras import layers
layer = layers.Dense(32, input_shape=(784,))</code></pre> 
<p style="text-align:justify;">我们创建了一个层，只接受第一个维度大小为 784 的 2D 张量（第 0 轴是批量维度，其大小没有指定，因此可以任意取值）作为输入。这个层将返回一个张量，第一个维度的大小变成了 32。</p> 
<p style="text-align:justify;">因此，这个层后面只能连接一个接受 32 维向量作为输入的层。<strong>使用 Keras 时，你无须担心兼容性，因为向模型中添加的层都会自动匹配输入层的形状</strong>，例如下面这段代码。</p> 
<pre><code class="language-python">from keras import models
from keras import layers
model = models.Sequential()
model.add(layers.Dense(32, input_shape=(784,)))
model.add(layers.Dense(32))</code></pre> 
<p style="text-align:justify;">其中<span style="color:#fe2c24;">第二层没有输入形状（input_shape）的参数</span>，相反，它可以自动推导出输入形状等于上一层的输出形状。</p> 
<h4 style="text-align:justify;"><span style="color:#fe2c24;">3.1.2　模型：层构成的网络</span></h4> 
<p style="text-align:justify;"><strong>深度学习模型是层构成的有向无环图</strong>。最常见的例子就是层的线性堆叠，将单一输入映射为单一输出。但随着深入学习，你会接触到更多类型的网络拓扑结构。</p> 
<p style="text-align:justify;">一些常见的网络拓扑结构如下。</p> 
<div style="text-align:justify;"> 
 <span style="color:#fe2c24;">双分支（two-branch）网络 </span> 
</div> 
<div style="text-align:justify;"> 
 <span style="color:#fe2c24;">多头（multihead）网络 </span> 
</div> 
<div style="text-align:justify;"> 
 <span style="color:#fe2c24;">Inception 模块</span> 
</div> 
<div style="text-align:justify;"></div> 
<p style="text-align:justify;">网络的拓扑结构定义了一个<span style="color:#fe2c24;">假设空间（hypothesis space）</span>。你可能还记得第 1 章里<span style="color:#fe2c24;">机器学习的定义：“在预先定义好的可能性空间中，利用反馈信号的指引来寻找输入数据的有用表示</span>。”</p> 
<p style="text-align:justify;">选定了网络拓扑结构，意味着将可能性空间（假设空间）限定为一系列特定的张量运算，将输入数据映射为输出数据。然后，你需要为这些张量运算的权重张量找到一组合适的值。</p> 
<p style="text-align:justify;"><span style="color:#fe2c24;"><strong>选择正确的网络架构更像是一门艺术而不是科学</strong></span>。虽然有一些最佳实践和原则，但只有动手实践才能让你成为合格的神经网络架构师。后面几章将教你构建神经网络的详细原则，也会帮你建立直觉，明白对于特定问题哪些架构有用、哪些架构无用。</p> 
<h4 style="text-align:justify;"><span style="color:#4da8ee;">3.1.3　损失函数与优化器：配置学习过程的关键</span></h4> 
<p style="text-align:justify;">一旦确定了网络架构，你还需要选择以下两个参数。</p> 
<p style="text-align:justify;"><span style="color:#fe2c24;"><strong>损失函数（目标函数）</strong></span>——在训练过程中需要将其最小化。它能够衡量当前任务是否已成功完成。</p> 
<p style="text-align:justify;"><span style="color:#fe2c24;"><strong>优化器</strong></span>——决定如何基于损失函数对网络进行更新。它执行的是<span style="color:#fe2c24;"><strong>随机梯度下降（</strong><strong>SGD）</strong></span>的某个变体。</p> 
<p style="text-align:justify;">具有多个输出的神经网络可能具有多个损失函数（每个输出对应一个损失函数）。但是，梯度下降过程必须基于单个标量损失值。因此，对于具有多个损失函数的网络，需要将所有损失函数取平均，变为一个标量值。</p> 
<p style="text-align:justify;"><span style="color:#fe2c24;">选择正确的目标函数对解决问题是非常重要的</span>。网络的目的是使损失尽可能最小化，因此，如果目标函数与成功完成当前任务不完全相关，那么网络最终得到的结果可能会不符合你的预期。想象一下，利用 SGD 训练一个愚蠢而又无所不能的人工智能，给它一个蹩脚的目标函数：“将所有活着的人的平均幸福感最大化”。为了简化自己的工作，这个人工智能可能会选择杀死绝大多数人类，只留几个人并专注于这几个人的幸福——因为平均幸福感并不受人数的影响。这可能并不是你想要的结果！请记住，你构建的所有神经网络在降低损失函数时和上述的人工智能一样无情。因此，<span style="color:#fe2c24;">一定要明智地选择目标函数，否则你将会遇到意想不到的副作用</span>。</p> 
<p style="text-align:justify;">幸运的是，对于<span style="color:#fe2c24;">分类、回归、序列预测</span>等常见问题，你可以遵循一些简单的指导原则来选择正确的损失函数。</p> 
<p style="text-align:justify;">例如，对于<span style="color:#fe2c24;">二分类问题</span>，你可以使用<span style="color:#fe2c24;">二元交叉熵（binary crossentropy）损失函数</span>；</p> 
<p style="text-align:justify;">对于<span style="color:#fe2c24;">多分类问题</span>，可以用<span style="color:#fe2c24;">分类交叉熵（categorical crossentropy）</span>损失函数；</p> 
<p style="text-align:justify;">对于<span style="color:#fe2c24;">回归问题</span>，可以用<span style="color:#fe2c24;">均方误差（mean-squared error）</span>损失函数；</p> 
<p style="text-align:justify;">对于<span style="color:#fe2c24;">序列学习问题</span>，可以用<span style="color:#fe2c24;">联结主义时序分类</span>（CTC，connectionist temporal classification）损失函数，等等。</p> 
<p style="text-align:justify;"><span style="color:#fe2c24;"><strong>只有在面对真正全新的研究问题时，你才需要自主开发目标函数</strong></span>。在后面几章里，我们将详细说明对于各种常见任务应选择哪种损失函数。</p> 
<h3 style="text-align:justify;"><span style="background-color:#ffd900;">3.2 Keras 简介</span></h3> 
<p style="text-align:justify;"><span style="color:#fe2c24;">本书的代码示例全都使用 Keras 实现</span>。Keras 是一个 Python 深度学习框架，可以方便地定义和训练几乎所有类型的深度学习模型。Keras 最开始是为研究人员开发的，其目的在于快速实验。</p> 
<p style="text-align:justify;"><span style="color:#fe2c24;">Keras 具有以下重要特性。</span></p> 
<div style="text-align:justify;"> 
 <span style="color:#fe2c24;">相同的代码可以在 CPU 或 GPU 上无缝切换运行</span> 
 <span style="color:#231f20;">。 </span> 
</div> 
<div style="text-align:justify;"> 
 <span style="color:#231f20;">具有用户友好的 </span> 
 <span style="color:#231f20;">API</span> 
 <span style="color:#231f20;">，便于快速开发深度学习模型的原型。 </span> 
</div> 
<div style="text-align:justify;"> 
 <span style="color:#fe2c24;">内置支持卷积网络（用于计算机视觉）、循环网络（用于序列处理）以及二者的任意组合</span> 
 <span style="color:#231f20;">。 </span> 
</div> 
<div style="text-align:justify;"> 
 <span style="color:#231f20;">支持任意网络架构：多输入或多输出模型、层共享、模型共享等。这也就是说，Keras 能够构建任意深度学习模型，无论是生成式对抗网络还是神经图灵机。</span> 
</div> 
<div style="text-align:justify;"></div> 
<p style="text-align:justify;"><span style="color:#1c7331;"><span style="background-color:#ffd900;">Keras 基于宽松的 </span></span><span style="color:#fe2c24;"><span style="background-color:#ffd900;">MIT</span></span><span style="color:#1c7331;"><span style="background-color:#ffd900;"> 许可证发布</span></span>，这意味着可以在商业项目中免费使用它。它与所有版本的 Python 都兼容（截至 2017 年年中，从 Python 2.7 到 Python 3.6 都兼容）。</p> 
<p style="text-align:justify;">Keras 已有 200 000 多个用户，既包括创业公司和大公司的学术研究人员和工程师，也包括研究生和业余爱好者。Google、Netflix、Uber、CERN、Yelp、Square 以及上百家创业公司都在用 Keras 解决各种各样的问题。Keras 还是机器学习竞赛网站 Kaggle 上的热门框架，最新的深度学习竞赛中，几乎所有的优胜者用的都是 Keras 模型，如图 3-2 所示。</p> 
<p style="text-align:justify;"><img alt="" height="299" src="https://images2.imgbox.com/ae/e0/drEf2K5u_o.png" width="454"></p> 
<h4 style="text-align:justify;"><span style="background-color:#ffd900;">3.2.1 Keras、TensorFlow、Theano 和 CNTK</span></h4> 
<p style="text-align:justify;">Keras 是一个模型级（model-level）的库，为开发深度学习模型提供了高层次的构建模块。它不处理张量操作、求微分等低层次的运算。相反，它依赖于一个专门的、高度优化的张量库来完成这些运算，这个张量库就是 Keras 的后端引擎（backend engine）。Keras 没有选择单个张量库并将 Keras 实现与这个库绑定，而是以模块化的方式处理这个问题（见图 3-3）。因此，几个不同的后端引擎都可以无缝嵌入到 Keras 中。<span style="color:#fe2c24;">目前，Keras 有三个后端实现：TensorFlow 后端、Theano 后端和微软认知工具包（CNTK，Microsoft cognitive toolkit）后端</span>。未来 Keras 可能会扩展到支持更多的深度学习引擎。</p> 
<p style="text-align:justify;"><img alt="" height="286" src="https://images2.imgbox.com/93/fb/NXkGbry8_o.png" width="487"></p> 
<p style="text-align:justify;">TensorFlow、CNTK 和 Theano 是当今深度学习的几个主要平台。Theano 由<span style="color:#fe2c24;">蒙特利尔大学</span>的MILA 实验室开发，TensorFlow 由 Google 开发，CNTK 由微软开发。你用 Keras 写的每一段代码都可以在这三个后端上运行，无须任何修改。也就是说，你在开发过程中可以在两个后端之间无缝切换，这通常是很有用的。例如，对于特定任务，某个后端的速度更快，那么我们就可以无缝切换过去。我们推<span style="color:#fe2c24;">荐使用 TensorFlow 后端作为大部分深度学习任务的默认后端</span>，因为它的应用最广泛，可扩展，而且可用于生产环境。</p> 
<p style="text-align:justify;"><span style="color:#fe2c24;">通过 TensorFlow（或 Theano、CNTK）</span>，<span style="color:#fe2c24;">Keras 可以在 CPU 和 GPU 上无缝运行</span>。在 CPU 上运行时，TensorFlow 本身封装了一个低层次的张量运算库，叫作 Eigen；在 GPU 上运行时，TensorFlow封装了一个高度优化的深度学习运算库，叫作 NVIDIA CUDA 深度神经网络库（cuDNN）。</p> 
<h4 style="text-align:justify;"><span style="background-color:#ffd900;">3.2.2　使用 Keras 开发：概述</span></h4> 
<p style="text-align:justify;">你已经见过一个 Keras 模型的示例，就是 MNIST 的例子。典型的 <span style="color:#fe2c24;"><strong>Keras 工作流程</strong></span>就和那个例子类似。</p> 
<p style="text-align:justify;"><span style="color:#fe2c24;">(1) 定义训练数据：输入张量和目标张量。</span></p> 
<p style="text-align:justify;"><span style="color:#fe2c24;">(2) 定义层组成的网络（或模型），将输入映射到目标。</span></p> 
<p style="text-align:justify;"><span style="color:#fe2c24;">(3) 配置学习过程：选择损失函数、优化器和需要监控的指标。</span></p> 
<p style="text-align:justify;"><span style="color:#fe2c24;">(4) 调用模型的 fit 方法在训练数据上进行迭代。</span></p> 
<p style="text-align:justify;">定义模型有两种方法：<span style="color:#fe2c24;">一种是使用 Sequential 类</span>（仅用于层的线性堆叠，这是目前最常见的网络架构），<span style="color:#fe2c24;">另一种是函数式 API</span>（functional API，用于层组成的有向无环图，让你可以构建任意形式的架构）。</p> 
<p style="text-align:justify;">前面讲过，这是一个利用 Sequential 类定义的两层模型（注意，我们向第一层传入了输入数据的预期形状）。</p> 
<pre><code class="language-python">from keras import models
from keras import layers
model = models.Sequential()
model.add(layers.Dense(32, activation='relu', input_shape=(784,)))
model.add(layers.Dense(10, activation='softmax'))</code></pre> 
<p style="text-align:justify;">下面是用函数式 API 定义的相同模型。</p> 
<pre><code class="language-python">input_tensor = layers.Input(shape=(784,))
x = layers.Dense(32, activation='relu')(input_tensor)
output_tensor = layers.Dense(10, activation='softmax')(x)
model = models.Model(inputs=input_tensor, outputs=output_tensor)</code></pre> 
<p style="text-align:justify;">利用函数式 API，你可以操纵模型处理的数据张量，并将层应用于这个张量，就好像这些层是函数一样。</p> 
<p style="text-align:justify;">注意<span style="color:#fe2c24;"> 第 7 章有关于函数式 API 的详细指南</span>。在那之前，我们的代码示例中只会用到 Sequential 类。</p> 
<p style="text-align:justify;"><span style="color:#fe2c24;">一旦定义好了模型架构，使用 Sequential 模型还是函数式 API 就不重要了</span>。接下来的步骤都是相同的。</p> 
<p style="text-align:justify;"><span style="color:#fe2c24;"><strong>配置学习过程是在编译这一步，你需要指定模型使用的优化器和损失函数，以及训练过程中想要监控的指标</strong></span>。下面是单一损失函数的例子，这也是目前最常见的。</p> 
<pre><code class="language-python">from keras import optimizers
model.compile(optimizer=optimizers.RMSprop(lr=0.001),
 loss='mse',
 metrics=['accuracy'])</code></pre> 
<p style="text-align:justify;">最后，学习过程就是通过 fit() 方法将输入数据的 Numpy 数组（和对应的目标数据）传入模型，这一做法与 <span style="color:#fe2c24;">Scikit-Learn </span>及其他机器学习库类似。</p> 
<pre><code class="language-python">model.fit(input_tensor, target_tensor, batch_size=128, epochs=10)</code></pre> 
<p style="text-align:justify;">在接下来的几章里，你将会在这些问题上培养可靠的直觉：<span style="color:#fe2c24;">哪种类型的网络架构适合解决哪种类型的问题？如何选择正确的学习配置？如何调节模型使其给出你想要的结果？</span>我们将在3.4~3.6 节讲解三个基本示例，分别是二分类问题、多分类问题和回归问题。</p> 
<h3 style="text-align:justify;">3.3　建立深度学习工作站</h3> 
<p style="text-align:justify;">在开始开发深度学习应用之前，你需要建立自己的深度学习工作站。虽然并非绝对必要，但强烈推荐你在现代 NVIDIA GPU 上运行深度学习实验。某些应用，特别是卷积神经网络的图像处理和循环神经网络的序列处理，在 CPU 上的速度非常之慢，即使是高速多核 CPU 也是如此。<span style="color:#fe2c24;">即使是可以在 CPU 上运行的深度学习应用，使用现代 GPU 通常也可以将速度提高 5 倍或 10 倍</span>。如果你不想在计算机上安装 GPU，也可以考虑在 AWS EC2 GPU 实例或 Google 云平台上运行深度学习实验。但请注意，时间一长，云端 GPU 实例可能会变得非常昂贵。</p> 
<p style="text-align:justify;">无论在本地还是在云端运行，最好都使用 UNIX 工作站。虽然从技术上来说可以在 Windows上使用 Keras（Keras 的三个后端都支持 Windows），但我们不建议这么做。在附录 A 的安装说明中，我们以安装了 Ubuntu 的计算机为例。<span style="color:#fe2c24;">如果你是 Windows 用户，最简单的解决方案就是安装 Ubuntu双系统</span>。这看起来可能有点麻烦，但从长远来看，使用 Ubuntu 将会为你省去大量时间和麻烦。</p> 
<p style="text-align:justify;">注意，<span style="color:#fe2c24;">使用 Keras 需要安装 TensorFlow、CNTK 或 Theano（如果你希望能够在三个后端之间来回切换，那么可以安装三个）</span>。本书将重点介绍 TensorFlow，并简要介绍一下 Theano，不会涉及 CNTK。</p> 
<h4 style="text-align:justify;"><strong>3.3.1 Jupyter 笔记本：运行深度学习实验的首选方法</strong></h4> 
<p style="text-align:justify;">Jupyter 笔记本是运行深度学习实验的好方法，特别适合运行本书中的许多代码示例。它广泛用于数据科学和机器学习领域。<span style="color:#fe2c24;">笔记本（notebook）是 Jupyter Notebook 应用生成的文件，可以在浏览器中编辑</span>。它可以执行 Python 代码，还具有丰富的文本编辑功能，可以对代码进行注释。笔记本还可以将冗长的实验代码拆分为可独立执行的短代码，这使得开发具有交互性，而且如果后面的代码出现问题，你也不必重新运行前面的所有代码。</p> 
<p style="text-align:justify;">我们<span style="color:#fe2c24;">推荐使用 Jupyter 笔记本来上手 Keras，虽然这并不是必需的</span>。你也可以运行独立的Python 脚本，或者<span style="color:#fe2c24;">在 IDE（比如 PyCharm）中运行代码</span>。本书所有代码示例都以开源笔记本的形式提供，你可以在本书网站上下载：https://www.manning.com/books/deep-learning-with-python。</p> 
<h4 style="text-align:justify;">3.3.2　运行 Keras：两种选择</h4> 
<p style="text-align:justify;">想要在实践中使用 Keras，我们推荐以下两种方式。</p> 
<p style="text-align:justify;">使用官方的 EC2 深度学习 Amazon 系统映像（AMI），并在 EC2 上以 Jupyter 笔记本的方式运行 Keras 实验。如果你的本地计算机上没有 GPU，你可以选择这种方式。附录 B 给出了详细指南。</p> 
<p style="text-align:justify;">在本地 UNIX 工作站上从头安装。然后你可以运行本地 Jupyter 笔记本或常规的 Python 代码库。如果你已经拥有了高端的 NVIDIA GPU，可以选择这种方式。附录 A 给出了基于 Ubuntu 的详细安装指南。</p> 
<p style="text-align:justify;">我们来详细看一下这两种方式的优缺点。</p> 
<h4 style="text-align:justify;">3.3.3　在云端运行深度学习任务：优点和缺点</h4> 
<p style="text-align:justify;">如果你还没有可用于深度学习的 GPU（即最新的高端 NVIDIA GPU），那么在云端运行深度学习实验是一种简单又低成本的方法，让你无须额外购买硬件就可以上手。如果你使用Jupyter 笔记本，那么在云端运行的体验与在本地运行完全相同。<span style="color:#fe2c24;">截至 2017 年年中，最容易上手深度学习的云产品肯定是 AWS EC2</span>。附录 B 给出了在 EC2 GPU 实例上运行 Jupyter 笔记本的详细指南。</p> 
<p style="text-align:justify;">但如果你是深度学习的重度用户，从长期来看这种方案是难以持续的，甚至几个星期都不行。<span style="color:#fe2c24;">EC2 实例的价格很高</span>：附录 B 推荐的实例（p2.xlarge 实例，计算能力一般）在 2017 年年中的价格是每小时 0.90 美元。与此相对的是，一款可靠的消费级 GPU 价格在 1000~1500 美元——这个价格一直相当稳定，而这种 GPU 的性能则在不断提高。如果你准备认真从事深度学习，那么应该建立具有一块或多块 GPU 的本地工作站。</p> 
<p style="text-align:justify;">简而言之，EC2 是很好的上手方法。你完全可以在 EC2 GPU 实例上运行本书的代码示例。但如果你想成为深度学习的高手，那就自己买 GPU。</p> 
<h4 style="text-align:justify;">3.3.4　深度学习的最佳 GPU</h4> 
<p style="text-align:justify;">如果你准备买一块 GPU，应该选择哪一款呢？首先要注意，一定要买<span style="color:#fe2c24;"><strong> NVIDIA GPU</strong></span>。<span style="color:#fe2c24;">NVIDIA 是目前唯一一家在深度学习方面大规模投资的图形计算公司</span>，现代深度学习框架只能在 NVIDIA 显卡上运行。截至 2017 年年中，最容易上手深度学习的云产品肯定是 AWS EC2。附录 B 给出了在 EC2 GPU 实例上运行 Jupyter 笔记本的详细指南。</p> 
<div style="text-align:justify;"> 
 <span style="color:#231f20;">截至 </span> 
 <span style="color:#231f20;">2017 </span> 
 <span style="color:#231f20;">年年中，我们推荐 </span> 
 <span style="color:#231f20;">NVIDIA TITAN Xp </span>为市场上用于深度学习的最佳显卡。如果预算较少，你也可以考虑 GTX 1060。如果你读到本节的时间是在 2018 年或更晚，请花点时间在网上查找最新的推荐，因为每年都会推出新的模型。 
</div> 
<div style="text-align:justify;"></div> 
<p style="text-align:justify;"><span style="color:#fe2c24;">从这一节开始，我们将认为你的计算机已经安装好 Keras 及其依赖，最好支持 GPU</span>。在继续阅读之前请确认已经完成此步骤。阅读附录中的详细指南，还可以在网上搜索进一步的帮助。安装 Keras 及常见的深度学习依赖的教程有很多。</p> 
<p style="text-align:justify;">下面我们将深入讲解 Keras 示例。</p> 
<h3 style="text-align:justify;">3.4　电影评论分类：二分类问题</h3> 
<p style="text-align:justify;">二分类问题可能是应用最广泛的机器学习问题。在这个例子中，你将<span style="color:#fe2c24;">学习根据电影评论的文字内容将其划分为正面或负面</span>。</p> 
<h4 style="text-align:justify;">3.4.1 IMDB 数据集</h4> 
<p style="text-align:justify;">本节使用 IMDB 数据集，它包含来自互联网电影数据库（IMDB）的 50 000 条严重两极分化的评论。数据集被分为用于训练的 25 000 条评论与用于测试的 25 000 条评论，训练集和测试集都包含 50% 的正面评论和 50% 的负面评论。</p> 
<p style="text-align:justify;">为什么要将训练集和测试集分开？因为你不应该将训练机器学习模型的同一批数据再用于测试模型！模型在训练数据上的表现很好，并不意味着它在前所未见的数据上也会表现得很好，而且你真正关心的是模型在新数据上的性能（因为你已经知道了训练数据对应的标签，显然不再需要模型来进行预测）。例如，你的模型最终可能只是记住了训练样本和目标值之间的映射关系，但这对在前所未见的数据上进行预测毫无用处。下一章将会更详细地讨论这一点。</p> 
<p style="text-align:justify;"><span style="color:#fe2c24;">与 MNIST 数据集一样，IMDB 数据集也内置于 Keras 库</span>。它已经过预处理：评论（单词序列）已经被转换为整数序列，其中每个整数代表字典中的某个单词。</p> 
<p style="text-align:justify;">下列代码将会加载 <strong>IMDB 数据集</strong>（第一次运行时会下载大约 80MB 的数据）。</p> 
<p style="text-align:justify;">代码清单 3-1 加载 IMDB 数据集</p> 
<pre><code class="language-python">from keras.datasets import imdb
(train_data, train_labels), (test_data, test_labels) = imdb.load_data(
 num_words=10000)</code></pre> 
<p style="text-align:justify;"><span style="color:#fe2c24;">参数 num_words=10000 的意思是仅保留训练数据中前 10 000 个最常出现的单词</span>。低频单词将被舍弃。这样得到的向量数据不会太大，便于处理。</p> 
<p style="text-align:justify;"><span style="color:#fe2c24;">train_data 和 test_data 这两个变量都是评论组成的列表</span>，每条评论又是单词索引组成的列表（表示一系列单词）。<span style="color:#fe2c24;">train_labels 和 test_labels 都是 0 和 1 组成的列表</span>，其中 0代表负面（negative），1 代表正面（positive）。</p> 
<pre><code class="language-python">&gt;&gt;&gt; train_data[0]
[1, 14, 22, 16, ... 178, 32]
&gt;&gt;&gt; train_labels[0]
1</code></pre> 
<p style="text-align:justify;">由于限定为前 10 000 个最常见的单词，单词索引都不会超过 10 000。</p> 
<pre><code class="language-python">&gt;&gt;&gt; max([max(sequence) for sequence in train_data])
9999</code></pre> 
<p style="text-align:justify;">下面这段代码很有意思，你可以将某条评论迅速解码为英文单词。</p> 
<pre><code class="language-python"># word_index 是一个将单词映射为整数索引的字典
word_index = imdb.get_word_index() 
# 键值颠倒，将整数索引映射为单词
reverse_word_index = dict(
 [(value, key) for (key, value) in word_index.items()]) 
decoded_review = ' '.join(
 [reverse_word_index.get(i - 3, '?') for i in train_data[0]])

</code></pre> 
<pre><code class="language-python">print('train_labels[0]=', train_labels[0])
# 打印训练数据形状
print('train_data.shape', train_data.shape)</code></pre> 
<pre><code class="language-python">train_labels[0]= 1
train_data.shape (25000,)</code></pre> 
<pre><code class="language-python">print('train_data[0]:', train_data[0])</code></pre> 
<pre><code class="language-python">train_data[0]: [1, 14, 22, 16, 43, 530, 973, 1622, 1385, 65, 458, 4468, 66, 3941, 4, 173, 36, 256, 5, 25, 100, 43, 838, 112, 50, 670, 2, 9, 35, 480, 284, 5, 150, 4, 172, 112, 167, 2, 336, 385, 39, 4, 172, 4536, 1111, 17, 546, 38, 13, 447, 4, 192, 50, 16, 6, 147, 2025, 19, 14, 22, 4, 1920, 4613, 469, 4, 22, 71, 87, 12, 16, 43, 530, 38, 76, 15, 13, 1247, 4, 22, 17, 515, 17, 12, 16, 626, 18, 2, 5, 62, 386, 12, 8, 316, 8, 106, 5, 4, 2223, 5244, 16, 480, 66, 3785, 33, 4, 130, 12, 16, 38, 619, 5, 25, 124, 51, 36, 135, 48, 25, 1415, 33, 6, 22, 12, 215, 28, 77, 52, 5, 14, 407, 16, 82, 2, 8, 4, 107, 117, 5952, 15, 256, 4, 2, 7, 3766, 5, 723, 36, 71, 43, 530, 476, 26, 400, 317, 46, 7, 4, 2, 1029, 13, 104, 88, 4, 381, 15, 297, 98, 32, 2071, 56, 26, 141, 6, 194, 7486, 18, 4, 226, 22, 21, 134, 476, 26, 480, 5, 144, 30, 5535, 18, 51, 36, 28, 224, 92, 25, 104, 4, 226, 65, 16, 38, 1334, 88, 12, 16, 283, 5, 16, 4472, 113, 103, 32, 15, 16, 5345, 19, 178, 32]</code></pre> 
<pre><code class="language-python">print('word_index.get(''this''):', word_index.get('this'))
print('len(word_index):', len(word_index))
print('word_index[''this'']:', word_index['this'])
print('word_index[''film'']:', word_index['film'])
print('word_index[''fawn'']:', word_index['fawn'])

print('reverse_word_index[''11'']:', reverse_word_index[11])</code></pre> 
<pre><code class="language-python">word_index.get(this): 11
len(word_index): 88584
word_index[this]: 11
word_index[film]: 19
word_index[fawn]: 34701
reverse_word_index[11]: this</code></pre> 
<h4 style="text-align:justify;">3.4.2　准备数据</h4> 
<p style="text-align:justify;"><span style="color:#fe2c24;"><strong>你不能将整数序列直接输入神经网络。你需要将列表转换为张量</strong></span>。转换方法有以下两种。</p> 
<p style="text-align:justify;"><span style="color:#fe2c24;"><strong>填充列表</strong></span>，使其具有相同的长度，再将列表转换成形状为 (samples, word_indices)的整数张量，然后网络第一层使用能处理这种整数张量的层（即 Embedding 层，本书后面会详细介绍）。</p> 
<p style="text-align:justify;"><span style="color:#fe2c24;"><strong>对列表进行 one-hot 编码</strong>，将其转换为 0 和 1 组成的向量</span>。举个例子，序列 [3, 5] 将会被转换为 10 000 维向量，只有索引为 3 和 5 的元素是 1，其余元素都是 0。然后网络第一层可以用 Dense 层，它能够处理浮点数向量数据。</p> 
<p style="text-align:justify;">下面我们采用后一种方法将数据向量化。为了加深理解，你可以手动实现这一方法，如下所示。</p> 
<div style="text-align:justify;"> 
 <strong><span style="color:#fe2c24;"><span style="background-color:#ffd900;">代码清单 3-2  将整数序列编码为二进制矩</span></span><span style="color:#ffffff;">阵</span></strong> 
</div> 
<div style="text-align:justify;"></div> 
<div> 
 <pre><code class="language-python">#代码清单 3-2 将整数序列编码为二进制矩阵

# 定义vectorize_sequences函数
def vectorize_sequences(sequences, dimension=10000):
    results = np.zeros((len(sequences), dimension))
    # enumerate
    for i, sequence in enumerate(sequences):
        results[i, sequence] = 1.  # 将 results[i] 的指定索引设为 1
        # print(i, sequence)
        # print(results)
    return results

x_train0 = vectorize_sequences(train_data[0:3])
print(x_train0)</code></pre> 
 <pre><code class="language-python">[[0. 1. 1. ... 0. 0. 0.]
 [0. 1. 1. ... 0. 0. 0.]
 [0. 1. 1. ... 0. 0. 0.]]</code></pre> 
 <pre><code class="language-python">x_train = vectorize_sequences(train_data) 
x_test = vectorize_sequences(test_data)</code></pre> 
 <pre><code class="language-python"># 将训练数据向量化
x_train = vectorize_sequences(train_data)
# 将测试数据向量化
x_test = vectorize_sequences(test_data)
print('x_train:', x_train)
print('x_test:', x_test)</code></pre> 
 <pre><code class="language-python">x_train: [[0. 1. 1. ... 0. 0. 0.]
 [0. 1. 1. ... 0. 0. 0.]
 [0. 1. 1. ... 0. 0. 0.]
 ...
 [0. 1. 1. ... 0. 0. 0.]
 [0. 1. 1. ... 0. 0. 0.]
 [0. 1. 1. ... 0. 0. 0.]]
x_test: [[0. 1. 1. ... 0. 0. 0.]
 [0. 1. 1. ... 0. 0. 0.]
 [0. 1. 1. ... 0. 0. 0.]
 ...
 [0. 1. 1. ... 0. 0. 0.]
 [0. 1. 1. ... 0. 0. 0.]
 [0. 1. 1. ... 0. 0. 0.]]</code></pre> 
 <div style="text-align:justify;"> 
  <span style="color:#231f20;">你还应该将标签向量化。</span> 
 </div> 
 <div style="text-align:justify;"></div> 
 <div> 
  <pre><code class="language-python">y_train = np.asarray(train_labels).astype('float32')
y_test = np.asarray(test_labels).astype('float32')
print('y_train:', y_train)
print('y_test:', y_test)
print('y_train.shape', y_train.shape)</code></pre> 
  <pre><code class="language-python">y_train: [1. 0. 0. ... 0. 1. 0.]
y_test: [0. 1. 1. ... 0. 0. 0.]
y_train.shape (25000,)</code></pre> 
  <pre><code class="language-python"># enumerate的测试
seasons = ['Spring', 'Summer', 'Fall', 'Winter']
print('seasons:', seasons)
print('list(enumerate(seasons)):', list(enumerate(seasons)))
print("list(enumerate(seasons, start=1)):", list(enumerate(seasons, start=1)))</code></pre> 
  <pre><code class="language-python">seasons: ['Spring', 'Summer', 'Fall', 'Winter']
list(enumerate(seasons)): [(0, 'Spring'), (1, 'Summer'), (2, 'Fall'), (3, 'Winter')]
list(enumerate(seasons, start=1)): [(1, 'Spring'), (2, 'Summer'), (3, 'Fall'), (4, 'Winter')]
</code></pre> 
  <div style="text-align:justify;"> 
   <span style="color:#231f20;">现在可以将数据输入到神经网络中。</span> 
  </div> 
  <div> 
   <p style="text-align:justify;"></p> 
   <h4 style="text-align:justify;"><span style="color:#476b86;">3.4.3</span><span style="color:#476b86;">　构建网络 </span></h4> 
   <div> 
    <p style="text-align:justify;"><span style="color:#fe2c24;">输入数据是向量，而标签是标量（1 和 0）</span><span style="color:#231f20;">，这是你会遇到的最简单的情况。有一类网</span><span style="color:#231f20;">络在这种问题上表现很好，就是</span><span style="color:#fe2c24;">带有 relu 激活的全连接层（Dense）的简单堆叠</span><span style="color:#231f20;">，比如</span></p> 
    <div style="text-align:justify;"> 
     <span style="color:#fe2c24;">Dense(16, activation='relu')。 </span> 
    </div> 
    <div style="text-align:justify;"></div> 
    <div style="text-align:justify;"> 
     <span style="color:#231f20;">传入 </span> 
     <span style="color:#231f20;">Dense </span> 
     <span style="color:#231f20;">层的</span> 
     <span style="color:#fe2c24;">参数（16）是该层隐藏单元的个数</span> 
     <span style="color:#231f20;">。一个</span> 
     <span style="color:#231f20;">隐藏单元</span> 
     <span style="color:#231f20;">（</span> 
     <span style="color:#231f20;">hidden unit）是该层 表示空间的一个维度。我们在第 </span> 
     <span style="color:#231f20;">2 </span> 
     <span style="color:#231f20;">章讲过，每个带有 </span> 
     <span style="color:#231f20;">relu </span> 
     <span style="color:#231f20;">激活的 </span> 
     <span style="color:#231f20;">Dense 层都实现了下列张量 运算： </span> 
    </div> 
    <div style="text-align:justify;"></div> 
    <div style="text-align:justify;"> 
     <span style="color:#fe2c24;">output = relu(dot(W, input) + b) </span> 
    </div> 
    <div style="text-align:justify;"></div> 
    <div style="text-align:justify;"> 
     <span style="color:#231f20;">16 </span> 
     <span style="color:#231f20;">个隐藏单元对应的权重矩阵 </span> 
     <span style="color:#231f20;">W </span> 
     <span style="color:#231f20;">的形状为 </span> 
     <span style="color:#fe2c24;">(input_dimension, 16)</span> 
     <span style="color:#231f20;">，与 </span> 
     <span style="color:#231f20;">W 做点积相当于 将输入数据投影到 </span> 
     <span style="color:#231f20;">16 </span> 
     <span style="color:#231f20;">维表示空间中（然后再加上偏置向量 </span> 
     <span style="color:#231f20;">b </span> 
     <span style="color:#231f20;">并应用 </span> 
     <span style="color:#231f20;">relu 运算）。你可以将表示空间的维度直观地理解为“</span> 
     <span style="color:#fe2c24;">网络学习内部表示时所拥有的自由度</span> 
     <span style="color:#231f20;">”。隐藏单元越多（即更高维的表示空间），网络越能够学到更加复杂的表示，但网络的计算代价也变得更大，而且可能会导致学到不好的模式（这种模式会提高训练数据上的性能，但不会提高测试数据上的性能）。 </span> 
    </div> 
    <div style="text-align:justify;"></div> 
    <div style="text-align:justify;"> 
     <span style="color:#231f20;">对于这种 </span> 
     <span style="color:#231f20;">Dense </span> 
     <span style="color:#231f20;">层的堆叠，你需要确定以下两个关键架构： </span> 
    </div> 
    <div style="text-align:justify;"></div> 
    <div style="text-align:justify;"> 
     <span style="color:#fe2c24;">网络有多少层； </span> 
    </div> 
    <div style="text-align:justify;"> 
     <span style="color:#fe2c24;">每层有多少个隐藏单元。 </span> 
    </div> 
    <div style="text-align:justify;"></div> 
    <div style="text-align:justify;"> 
     <span style="color:#231f20;">第 </span> 
     <span style="color:#231f20;">4 </span> 
     <span style="color:#231f20;">章中的原则将会指导你对上述问题做出选择。现在你只需要相信我选择的下列架构： </span> 
    </div> 
    <div style="text-align:justify;"></div> 
    <div style="text-align:justify;"> 
     <span style="color:#231f20;">两个中间层，每层都有 </span> 
     <span style="color:#231f20;">16 </span> 
     <span style="color:#231f20;">个隐藏单元； </span> 
    </div> 
    <div style="text-align:justify;"> 
     <span style="color:#231f20;">第三层输出一个标量，预测当前评论的情感。 </span> 
    </div> 
    <div style="text-align:justify;"></div> 
    <div style="text-align:justify;"> 
     <span style="color:#231f20;">中间层使用 </span> 
     <span style="color:#231f20;">relu </span> 
     <span style="color:#231f20;">作为激活函数，最后一层使用 </span> 
     <span style="color:#231f20;">sigmoid </span> 
     <span style="color:#231f20;">激活以输出一个 </span> 
     <span style="color:#231f20;">0~1 范围内的概率 值（表示样本的目标值等于 </span> 
     <span style="color:#231f20;">1 </span> 
     <span style="color:#231f20;">的可能性，即评论为正面的可能性）。</span> 
    </div> 
    <div style="text-align:justify;"></div> 
    <div style="text-align:justify;"> 
     <span style="color:#fe2c24;">relu（rectified linear unit， 整流线性单元）</span> 
     <span style="color:#231f20;">函数将所有负值归零（见图 </span> 
     <span style="color:#231f20;">3-4</span> 
     <span style="color:#231f20;">），而 </span> 
     <span style="color:#fe2c24;">sigmoid 函数则将任意值“压缩”到 [0, 1] 区间内（</span> 
     <span style="color:#231f20;">见图 </span> 
     <span style="color:#231f20;">3-5</span> 
     <span style="color:#231f20;">），</span> 
     <span style="color:#fe2c24;">其输出值可以看作概率值</span> 
     <span style="color:#231f20;">。</span> 
    </div> 
    <div style="text-align:justify;"></div> 
    <div style="text-align:justify;"> 
     <img alt="" height="354" src="https://images2.imgbox.com/3f/3c/W5QoSgbK_o.png" width="422"> 
    </div> 
    <div style="text-align:justify;"></div> 
    <div style="text-align:justify;"> 
     <img alt="" height="330" src="https://images2.imgbox.com/26/f3/zjazMnRO_o.png" width="392"> 
    </div> 
    <div style="text-align:justify;"> 
     <div></div> 
     <div> 
      <span style="color:#231f20;">3-6 </span> 
      <span style="color:#231f20;">显示了网络的结构。代码清单 </span> 
      <span style="color:#231f20;">3-3 </span> 
      <span style="color:#231f20;">是其 </span> 
      <span style="color:#231f20;">Keras </span> 
      <span style="color:#231f20;">实现，与前面见过的 </span> 
      <span style="color:#231f20;">MNIST </span> 
      <span style="color:#231f20;">例子类似。</span> 
     </div> 
     <div></div> 
     <div> 
      <img alt="" height="310" src="https://images2.imgbox.com/36/bc/Rxgz5Ai5_o.png" width="226"> 
     </div> 
     <div>
         
      <div> 
       <span style="color:#0d0016;">代码清单 3-3 模型定义</span> 
      </div> 
      <div> 
       <pre><code class="language-python">from keras import models
from keras import layers

model = models.Sequential()
model.add(layers.Dense(16, activation='relu', input_shape=(10000,)))
model.add(layers.Dense(16, activation='relu'))
model.add(layers.Dense(1, activation='sigmoid'))</code></pre> 
       <div> 
        <span style="color:#fe2c24;"><span style="background-color:#ffd900;">什么是激活函数？为什么要使用激活函数？ </span></span> 
       </div> 
       <div></div> 
       <div> 
        <span style="color:#231f20;">如果没有 </span> 
        <span style="color:#231f20;">relu </span> 
        <span style="color:#231f20;">等激活函数（也叫</span> 
        <span style="color:#fe2c24;">非线性</span> 
        <span style="color:#231f20;">），</span> 
        <span style="color:#231f20;">Dense 层将只包含两个线性运算——点积和加法： </span> 
       </div> 
       <div></div> 
       <div> 
        <span style="color:#fe2c24;">output = dot(W, input) + b </span> 
       </div> 
       <div></div> 
       <div> 
        <span style="color:#231f20;">这样 </span> 
        <span style="color:#231f20;">Dense 层就只能学习输入数据的</span> 
        <span style="color:#fe2c24;">线性变换（仿射变换）</span> 
        <span style="color:#231f20;">：该层的假设空间是从输入数据到 </span> 
        <span style="color:#231f20;">16 位空间所有可能的线性变换集合。这种假设空间非常有限，无法利用多个表示层的优势，因为多个线性层堆叠实现的仍是线性运算，添加层数并不会扩展假设空间。 </span> 
       </div> 
       <div></div> 
       <div> 
        <span style="color:#231f20;">为了得到更丰富的假设空间，从而充分利用多层表示的优势，你</span> 
        <span style="color:#fe2c24;">需要添加非线性或激活函数</span> 
        <span style="color:#231f20;">。</span> 
        <span style="color:#231f20;">relu 是深度学习中最常用的激活函数，但还有许多其他函数可选，它们都有类似的奇怪名称，比如 </span> 
        <span style="color:#231f20;">prelu</span> 
        <span style="color:#231f20;">、</span> 
        <span style="color:#231f20;">elu </span> 
        <span style="color:#231f20;">等。</span> 
       </div> 
       <div> 
        <span style="color:#231f20;">​​​​​</span> 
       </div> 
       <div> 
        <div> 
         <span style="color:#fe2c24;">最后，你需要选择损失函数和优化器</span> 
         <span style="color:#231f20;">。由于你面对的是一个二分类问题，网络输出是一个概率值（网络最后一层使用 </span> 
         <span style="color:#231f20;">sigmoid </span> 
         <span style="color:#231f20;">激活函数，仅包含一个单元），那么最好使用</span> 
         <span style="color:#fe2c24;"><strong> binary_ crossentropy（二元交叉熵）损失</strong></span> 
         <span style="color:#231f20;">。这并不是唯一可行的选择，比如你还可以使用 mean_ squared_error</span> 
         <span style="color:#231f20;">（均方误差）。但对于输出概率值的模型，</span> 
         <span style="color:#fe2c24;">交叉熵（crossentropy）</span> 
         <span style="color:#231f20;">往往是最好的选择。交叉熵是来自于信息论领域的概念，用于衡量概率分布之间的距离，在这个例子中就 </span> 
        </div> 
        <div> 
         <span style="color:#231f20;">是真实分布与预测值之间的距离。 </span> 
        </div> 
        <div></div> 
        <div> 
         <span style="color:#231f20;">下面的步骤是用 </span> 
         <span style="color:#fe2c24;">rmsprop 优化器</span> 
         <span style="color:#231f20;">和</span> 
         <span style="color:#fe2c24;"> binary_crossentropy 损失函数</span> 
         <span style="color:#231f20;">来配置模型。注意，我们还在训练过程中监控精度。</span> 
        </div> 
        <div></div> 
       </div> 
      </div> 
     </div> 
    </div> 
   </div> 
  </div> 
 </div> 
</div> 
<p style="text-align:justify;"><span style="color:#fe2c24;"><span style="background-color:#ffd900;">代码清单 3-4 编译模型</span></span></p> 
<pre><code class="language-python"># 选择损失函数和优化器
model.compile(optimizer='rmsprop',
              loss='binary_crossentropy',
              metrics=['accuracy'])</code></pre> 
<p style="text-align:justify;"><span style="color:#231f20;">上述代码将优化器、损失函数和指标作为字符串传入，这是因为 </span><span style="color:#fe2c24;">rmsprop、binary_ crossentropy 和 accuracy 都是 Keras 内置的一部分</span><span style="color:#231f20;">。</span></p> 
<p style="text-align:justify;"><span style="color:#231f20;">有时你可能希望配置自定义优化器的参数，或者传入自定义的损失函数或指标函数。前者可通过向 </span><span style="color:#231f20;">optimizer 参数传入一个优化器类实例来实现，如代码清单 </span><span style="color:#231f20;">3-5 </span><span style="color:#231f20;">所示；后者可通过向 </span><span style="color:#231f20;">loss </span><span style="color:#231f20;">和 </span><span style="color:#231f20;">metrics 参数传入函数对象来实现，如代码清单 </span><span style="color:#231f20;">3-6 </span><span style="color:#231f20;">所示。</span></p> 
<p style="text-align:justify;"><span style="color:#fe2c24;"><span style="background-color:#ffd900;">代码清单 3-5 配置优化器</span></span></p> 
<pre><code class="language-python">model.compile(optimizer=optimizers.RMSprop(lr=0.001),
              loss='binary_cross-entropy',
              metrics=['accuracy'])</code></pre> 
<div> 
 <div> 
  <span style="color:#fe2c24;"><span style="background-color:#ffd900;">代码清单 3-6 使用自定义的损失和指标</span></span> 
 </div> 
 <div></div> 
 <div> 
  <pre><code class="language-python">model.compile(optimizer=optimizers.RMSprop(lr=0.001),
              loss=losses.binary_crossentropy,
              metrics=[metrics.binary_accuracy])</code></pre> 
  <h4><span style="color:#476b86;">3.4.4</span><span style="color:#476b86;">　验证你的方法 </span></h4> 
  <div> 
   <span style="color:#231f20;">为了在训练过程中监控模型在前所未见的数据上的精度，你需要将原始训练数据留出 </span> 
   <span style="color:#231f20;">10 000 </span> 
  </div> 
  <div> 
   <span style="color:#231f20;">个样本作为验证集。</span> 
  </div> 
 </div> 
 <div></div> 
 <div> 
  <pre><code class="language-python"># 代码清单 3-7 留出验证集
x_val = x_train[:10000]
partial_x_train = x_train[10000:]
y_val = y_train[:10000]
partial_y_train = y_train[10000:]</code></pre> 
  <div> 
   <span style="color:#231f20;">现在使用 </span> 
   <span style="color:#fe2c24;">512 个样本组成的小批量</span> 
   <span style="color:#231f20;">，将模型训练 </span> 
   <span style="color:#fe2c24;">20 个轮次</span> 
   <span style="color:#231f20;">（即对 </span> 
   <span style="color:#231f20;">x_train </span> 
   <span style="color:#231f20;">和 </span> 
   <span style="color:#231f20;">y_train 两个张量中的所有样本进行 </span> 
   <span style="color:#fe2c24;">20 次迭代</span> 
   <span style="color:#231f20;">）。</span> 
  </div> 
  <div></div> 
  <div> 
   <span style="color:#231f20;">与此同时，你还要监控在留出的 </span> 
   <span style="color:#231f20;">10 000 个样本上的损失和精度。你可以通过将验证数据传入 </span> 
   <span style="color:#231f20;">validation_data </span> 
   <span style="color:#231f20;">参数来完成。</span> 
  </div> 
  <div></div> 
  <div> 
   <pre><code class="language-python"># 代码清单 3-8 训练模型
model.compile(optimizer='rmsprop',
              loss='binary_crossentropy',
              metrics=['acc'])

# 使用 512 个样本组成的小批量，将模型训练 20 个轮次（即对 x_train 和 y_train 两
# 个张量中的所有样本进行 20 次迭代）
# 在 CPU 上运行，每轮的时间不到 2 秒，训练过程将在 20 秒内结束。
# 每轮结束时会有短暂的停顿，因为模型要计算在验证集的 10 000 个样本上的损失和精度。

history = model.fit(partial_x_train,
                    partial_y_train,
                    epochs=20,
                    batch_size=512,
                    validation_data=(x_val, y_val))

# 调用 model.fit() 返回了一个 History 对象
# 这个对象有一个成员 history，它是一个字典，包含训练过程中的所有数据
# 字典中包含 4 个条目，对应训练过程和验证过程中监控的指标</code></pre> 
   <div> 
    <span style="color:#231f20;">在 </span> 
    <span style="color:#231f20;">CPU </span> 
    <span style="color:#231f20;">上运行，每轮的时间不到 </span> 
    <span style="color:#231f20;">2 </span> 
    <span style="color:#231f20;">秒，训练过程将在 </span> 
    <span style="color:#231f20;">20 秒内结束。每轮结束时会有短暂的停顿，因为模型要计算在验证集的 </span> 
    <span style="color:#231f20;">10 000 </span> 
    <span style="color:#231f20;">个样本上的损失和精度。 </span> 
   </div> 
   <div></div> 
   <div> 
    <span style="color:#231f20;">注意，调用 </span> 
    <span style="color:#231f20;">model.fit() </span> 
    <span style="color:#231f20;">返回了一个 </span> 
    <span style="color:#231f20;">History </span> 
    <span style="color:#231f20;">对象。这个对象有一个成员 </span> 
    <span style="color:#231f20;">history，它是一个字典，包含训练过程中的所有数据。我们来看一下。</span> 
   </div> 
   <div></div> 
   <div> 
    <pre><code class="language-python">history_dict = history.history
print(history_dict.keys())</code></pre> 
    <pre><code class="language-python">dict_keys(['loss', 'acc', 'val_loss', 'val_acc'])</code></pre> 
    <pre><code class="language-python">loss_values = history_dict['loss']
val_loss_values = history_dict['val_loss']

print("history_dict:", history_dict)
print("loss_values:", loss_values)
print('val_loss_values:', val_loss_values)</code></pre> 
    <pre><code class="language-python">history_dict: {'loss': [0.5311576724052429, 0.3295612335205078, 0.24616199731826782, 0.20007984340190887, 0.16878725588321686, 0.14065328240394592, 0.12178117036819458, 0.10707651078701019, 0.08816918730735779, 0.08290471136569977, 0.0661439448595047, 0.05832947418093681, 0.04871470853686333, 0.041972383856773376, 0.03593316674232483, 0.03029720112681389, 0.02458023838698864, 0.020768452435731888, 0.020750146359205246, 0.012916498817503452], 

'acc': [0.7743333578109741, 0.8935999870300293, 0.9193999767303467, 0.9332000017166138, 0.9430000185966492, 0.9547333121299744, 0.9611999988555908, 0.9675999879837036, 0.9740666747093201, 0.9751999974250793, 0.9829333424568176, 0.9851999878883362, 0.9885333180427551, 0.9905333518981934, 0.9923999905586243, 0.9939333200454712, 0.9965333342552185, 0.9972666501998901, 0.9962666630744934, 0.9993333220481873], 

'val_loss': [0.3976058065891266, 0.3222864866256714, 0.29301297664642334, 0.28684449195861816, 0.27952781319618225, 0.29999497532844543, 0.2950637638568878, 0.3080497980117798, 0.3298104405403137, 0.3424592912197113, 0.36206743121147156, 0.38678547739982605, 0.3946729898452759, 0.42827942967414856, 0.43978291749954224, 0.4857790470123291, 0.485530823469162, 0.5184621810913086, 0.5329005122184753, 0.5609933137893677], 

'val_acc': [0.8687000274658203, 0.878600001335144, 0.8820000290870667, 0.8851000070571899, 0.8870000243186951, 0.8798999786376953, 0.8855999708175659, 0.8835999965667725, 0.8826000094413757, 0.8754000067710876, 0.8733000159263611, 0.8718000054359436, 0.8756999969482422, 0.8697999715805054, 0.8726000189781189, 0.8718000054359436, 0.8708999752998352, 0.8723999857902527, 0.8716999888420105, 0.8705000281333923]}

loss_values: [0.5311576724052429, 0.3295612335205078, 0.24616199731826782, 0.20007984340190887, 0.16878725588321686, 0.14065328240394592, 0.12178117036819458, 0.10707651078701019, 0.08816918730735779, 0.08290471136569977, 0.0661439448595047, 0.05832947418093681, 0.04871470853686333, 0.041972383856773376, 0.03593316674232483, 0.03029720112681389, 0.02458023838698864, 0.020768452435731888, 0.020750146359205246, 0.012916498817503452]

val_loss_values: [0.3976058065891266, 0.3222864866256714, 0.29301297664642334, 0.28684449195861816, 0.27952781319618225, 0.29999497532844543, 0.2950637638568878, 0.3080497980117798, 0.3298104405403137, 0.3424592912197113, 0.36206743121147156, 0.38678547739982605, 0.3946729898452759, 0.42827942967414856, 0.43978291749954224, 0.4857790470123291, 0.485530823469162, 0.5184621810913086, 0.5329005122184753, 0.5609933137893677]</code></pre> 
    <div> 
     <span style="color:#231f20;">字典中包含 </span> 
     <span style="color:#231f20;">4 个条目，对应训练过程和验证过程中监控的指标。在下面两个代码清单中，我们将使用 </span> 
     <span style="color:#231f20;">Matplotlib </span> 
     <span style="color:#231f20;">在同一张图上绘制训练损失和验证损失（见图 </span> 
     <span style="color:#231f20;">3-7），以及训练精度和验证精度（见图 </span> 
     <span style="color:#231f20;">3-8</span> 
     <span style="color:#231f20;">）。请注意，由于网络的随机初始化不同，你得到的结果可能会略有不同。</span> 
    </div> 
    <div></div> 
    <div> 
     <pre><code class="language-python">print('代码清单 3-9 绘制训练损失和验证损失___结果')
import matplotlib.pyplot

history_dict = history.history
loss_values = history_dict['loss']
val_loss_values = history_dict['val_loss']

epochs = range(1, len(loss_values) + 1)

# 'bo' 表示蓝色圆点 # 'b' 表示蓝色实线
plt.plot(epochs, loss_values, 'bo', label='Training loss')
plt.plot(epochs, val_loss_values, 'b', label='Validation loss')
plt.title('Training and validation loss')
plt.xlabel('Epochs')
plt.ylabel('Loss')
plt.legend()
plt.show()</code></pre> 
     <p></p> 
    </div> 
   </div> 
  </div> 
 </div> 
</div> 
<p style="text-align:justify;"><img alt="" height="362" src="https://images2.imgbox.com/c9/a0/SknIHk5h_o.png" width="483"></p> 
<pre><code class="language-python">import matplotlib.pyplot

matplotlib.pyplot.clf()
acc = history_dict['acc']
val_acc = history_dict['val_acc']
matplotlib.pyplot.plot(epochs, acc, 'bo', label='Training acc')
matplotlib.pyplot.plot(epochs, val_acc, 'b', label='Validation acc')
matplotlib.pyplot.title('Training and validation accuracy')
matplotlib.pyplot.xlabel('Epochs')
matplotlib.pyplot.ylabel('Accuracy')
matplotlib.pyplot.legend()
matplotlib.pyplot.show()</code></pre> 
<p style="text-align:center;"><img alt="" class="left" height="258" src="https://images2.imgbox.com/5d/66/upmTFo47_o.png" width="345"></p> 
<div> 
 <span style="color:#231f20;">如你所见，</span> 
 <span style="color:#fe2c24;">训练损失每轮都在降低</span> 
 <span style="color:#231f20;">，训练精度每轮都在提升。这就是梯度下降优化的预期结果——你想要最小化的量随着每次迭代越来越小。</span> 
</div> 
<div></div> 
<div> 
 <span style="color:#231f20;">但验证损失和验证精度并非如此：它们似乎在第四轮达到最佳值。这就是我们之前警告过的一种情况：模型在训练数据上的表现越来越好，但在前所未见的数据上不一定表现得越来越好。准确地说，你看到的是</span> 
 <span style="color:#fe2c24;">过拟合（overfit）</span> 
 <span style="color:#231f20;">：在第二轮之后，你对训练数据过度优化，最终学到的表示仅针对于训练数据，无法泛化到训练集之外的数据。 </span> 
</div> 
<div></div> 
<div> 
 <span style="color:#231f20;">在这种情况下，为了防止过拟合，你可以在 </span> 
 <span style="color:#231f20;">3 轮之后停止训练。通常来说，你可以使用许多方法来降低过拟合，我们将在第 </span> 
 <span style="color:#231f20;">4 </span> 
 <span style="color:#231f20;">章中详细介绍。 </span> 
</div> 
<div></div> 
<div> 
 <span style="color:#231f20;">我们从头开始训练一个新的网络，训练 </span> 
 <span style="color:#231f20;">4 </span> 
 <span style="color:#231f20;">轮，然后在测试数据上评估模型。</span> 
</div> 
<div></div> 
<div> 
 <pre><code class="language-python">from keras.datasets import imdb
from keras import models
from keras import layers
from keras import optimizers
import numpy as np

(train_data, train_labels), (test_data, test_labels) = imdb.load_data(
    num_words=10000)

# word_index 是一个将单词映射为整数索引的字典
word_index = imdb.get_word_index()

# 键值颠倒，将整数索引映射为单词
reverse_word_index = dict(
    [(value, key) for (key, value) in word_index.items()])

# 反向字典
decoded_review = ' '.join(
    [reverse_word_index.get(i - 3, '?') for i in train_data[0]])

# 定义vectorize_sequences函数
def vectorize_sequences(sequences, dimension=10000):
    results = np.zeros((len(sequences), dimension))
    for i, sequence in enumerate(sequences):
        results[i, sequence] = 1.
    return results

x_train = vectorize_sequences(train_data)
x_test = vectorize_sequences(test_data)

y_train = np.asarray(train_labels).astype('float32')
y_test = np.asarray(test_labels).astype('float32')

model = models.Sequential()
model.compile(optimizer='rmsprop',
              loss='binary_crossentropy',
              metrics=['accuracy'])
#  模型定义
model.add(layers.Dense(16, activation='relu', input_shape=(10000,)))
model.add(layers.Dense(16, activation='relu'))
model.add(layers.Dense(1, activation='sigmoid'))

x_val = x_train[:10000]
partial_x_train = x_train[10000:]
y_val = y_train[:10000]

partial_y_train = y_train[10000:]

#  编译模型
model.compile(optimizer='rmsprop',
              loss='binary_crossentropy',
              metrics=['accuracy'])

# 仅作四次训练
model.fit(x_train, y_train, epochs=4, batch_size=512)
results = model.evaluate(x_test, y_test)

print('results', results)
print('model.predict(x_test):',model.predict(x_test))
</code></pre> 
 <pre><code class="language-python">49/49 [==============================] - 1s 7ms/step - loss: 0.4647 - accuracy: 0.8133
Epoch 2/4
49/49 [==============================] - 0s 6ms/step - loss: 0.2754 - accuracy: 0.9021
Epoch 3/4
49/49 [==============================] - 0s 6ms/step - loss: 0.2135 - accuracy: 0.9230
Epoch 4/4
49/49 [==============================] - 0s 5ms/step - loss: 0.1821 - accuracy: 0.9348
782/782 [==============================] - 1s 830us/step - loss: 0.3018 - accuracy: 0.8806
results [0.3018262982368469, 0.8806399703025818]</code></pre> 
 <div> 
  <span style="color:#231f20;">这种相当简单的方法得到了 </span> 
  <span style="color:#231f20;">88% </span> 
  <span style="color:#231f20;">的精度。利用最先进的方法，你应该能够得到接近 </span> 
  <span style="color:#231f20;">95% 的精度。</span> 
 </div> 
 <div></div> 
 <div> 
  <h4><span style="color:#476b86;">3.4.5</span><span style="color:#476b86;">　使用训练好的网络在新数据上生成预测结果 </span></h4> 
  <div> 
   <span style="color:#231f20;">训练好网络之后，你希望将其用于实践。你可以用 </span> 
   <span style="color:#231f20;">predict 方法来得到评论为正面的可能性大小。</span> 
  </div> 
  <div></div> 
  <div> 
   <pre><code class="language-python">print('model.predict(x_test):',model.predict(x_test))</code></pre> 
   <pre><code class="language-python">model.predict(x_test): [[0.23568308]
 [0.9997094 ]
 [0.9133028 ]
 ...
 [0.08991385]
 [0.07172912]
 [0.647347  ]]</code></pre> 
   <div> 
    <span style="color:#231f20;">如你所见，网络对某些样本的结果非常确信（大于等于 </span> 
    <span style="color:#231f20;">0.99</span> 
    <span style="color:#231f20;">，或小于等于 </span> 
    <span style="color:#231f20;">0.01），但对其他结果却不那么确信（</span> 
    <span style="color:#231f20;">0.6 </span> 
    <span style="color:#231f20;">或 </span> 
    <span style="color:#231f20;">0.4</span> 
    <span style="color:#231f20;">）。</span> 
   </div> 
   <div></div> 
   <div> 
    <h4><span style="color:#476b86;">3.4.6</span><span style="color:#476b86;">　进一步的实验 </span></h4> 
    <div> 
     <span style="color:#231f20;">通过以下实验，你可以确信前面选择的网络架构是非常合理的，虽然仍有改进的空间。 </span> 
    </div> 
    <div></div> 
    <div> 
     <span style="color:#231f20;">前面使用了两个隐藏层。你可以尝试使用一个或三个隐藏层，然后观察对验证精度和测 </span> 
    </div> 
    <div> 
     <span style="color:#231f20;">试精度的影响。 </span> 
    </div> 
    <div></div> 
    <div> 
     <pre><code class="language-python">#  模型定义
model.add(layers.Dense(16, activation='relu', input_shape=(10000,)))
model.add(layers.Dense(16, activation='relu'))
model.add(layers.Dense(16, activation='relu'))
model.add(layers.Dense(1, activation='sigmoid'))</code></pre> 
     <pre><code class="language-python">49/49 [==============================] - 1s 6ms/step - loss: 0.4853 - accuracy: 0.8112
Epoch 2/4
49/49 [==============================] - 0s 6ms/step - loss: 0.2759 - accuracy: 0.9028
Epoch 3/4
49/49 [==============================] - 0s 6ms/step - loss: 0.2136 - accuracy: 0.9216
Epoch 4/4
49/49 [==============================] - 0s 5ms/step - loss: 0.1766 - accuracy: 0.9360
782/782 [==============================] - 1s 825us/step - loss: 0.2884 - accuracy: 0.8860
results [0.2884432375431061, 0.8860399723052979]</code></pre> 
    </div> 
    <div> 
     <span style="color:#fe2c24;">可见：损失下降，精度增加</span> 
    </div> 
    <div></div> 
    <div> 
     <span style="color:#231f20;">尝试使用更多或更少的隐藏单元，比如 </span> 
     <span style="color:#231f20;">32 </span> 
     <span style="color:#231f20;">个、</span> 
     <span style="color:#231f20;">64 </span> 
     <span style="color:#231f20;">个等。 </span> 
    </div> 
    <div> 
     <pre><code class="language-python">#  模型定义
model.add(layers.Dense(32, activation='relu', input_shape=(10000,)))
model.add(layers.Dense(16, activation='relu'))
# model.add(layers.Dense(16, activation='relu'))
model.add(layers.Dense(1, activation='sigmoid'))</code></pre> 
     <pre><code class="language-python">results [0.3072710633277893, 0.877560019493103]</code></pre> 
     <p><span style="color:#231f20;">尝试使用 </span><span style="color:#231f20;">mse </span><span style="color:#231f20;">损失函数代替 </span><span style="color:#231f20;">binary_crossentropy。</span></p> 
     <p><span style="color:#231f20;">尝试使用 </span><span style="color:#231f20;">tanh </span><span style="color:#231f20;">激活（这种激活在神经网络早期非常流行）代替 </span><span style="color:#231f20;">relu</span><span style="color:#231f20;">。</span></p> 
     <p><span style="color:#476b86;">3.4.7</span><span style="color:#476b86;">　小结 </span></p> 
     <div> 
      <span style="color:#231f20;">下面是你应该从这个例子中学到的要点。 </span> 
     </div> 
     <div></div> 
     <div> 
      <span style="color:#231f20;">通常需要对原始数据进行大量预处理，以便将其转换为张量输入到神经网络中。单词序列可以编码为二进制向量，但也有其他编码方式。 </span> 
     </div> 
     <div></div> 
     <div> 
      <span style="color:#231f20;">带有 </span> 
      <span style="color:#231f20;">relu </span> 
      <span style="color:#231f20;">激活的 </span> 
      <span style="color:#231f20;">Dense 层堆叠，可以解决很多种问题（包括情感分类），你可能会经常用到这种模型。 </span> 
     </div> 
     <div></div> 
     <div> 
      <span style="color:#231f20;">对于二分类问题（两个输出类别），网络的最后一层应该是只有一个单元并使用 sigmoid激活的 </span> 
      <span style="color:#231f20;">Dense </span> 
      <span style="color:#231f20;">层，网络输出应该是 </span> 
      <span style="color:#231f20;">0~1 </span> 
      <span style="color:#231f20;">范围内的标量，表示概率值。 </span> 
     </div> 
     <div></div> 
     <div> 
      <span style="color:#231f20;">对于二分类问题的 </span> 
      <span style="color:#231f20;">sigmoid </span> 
      <span style="color:#231f20;">标量输出，你应该使用 </span> 
      <span style="color:#231f20;">binary_crossentropy </span> 
      <span style="color:#231f20;">损失函数。 </span> 
     </div> 
     <div></div> 
     <div> 
      <span style="color:#fe2c24;">无论你的问题是什么，rmsprop 优化器通常都是足够好的选择。这一点你无须担心。 </span> 
     </div> 
     <div></div> 
     <div> 
      <span style="color:#231f20;">随着神经网络在训练数据上的表现越来越好，模型最终会过拟合，并在前所未见的数据上得到越来越差的结果。一定要一直监控模型在训练集之外的数据上的性能。</span> 
     </div> 
     <div></div> 
     <div> 
      <h3><span style="color:#476b86;">3.5</span><span style="color:#476b86;">　新闻分类：多分类问题 </span></h3> 
      <div> 
       <p><span style="color:#231f20;">上一节中，我们介绍了如何用密集连接的神经网络将向量输入划分为两个互斥的类别。但</span><span style="color:#231f20;">如果类别不止两个，要怎么做？</span></p> 
       <div> 
        <span style="color:#231f20;">本节你会构建一个网络，将路透社新闻划分为 </span> 
        <span style="color:#fe2c24;">46 个互斥的主题</span> 
        <span style="color:#231f20;">。因为有多个类别，所以这是</span> 
        <span style="color:#fe2c24;">多分类（multiclass classification</span> 
        <span style="color:#231f20;">）问题的一个例子。</span> 
       </div> 
       <div></div> 
       <div> 
        <span style="color:#231f20;">因为每个数据点只能划分到一个类别，所以更具体地说，这是</span> 
        <span style="color:#231f20;">单标签、多分类</span> 
        <span style="color:#231f20;">（</span> 
        <span style="color:#231f20;">single-label, multiclass classification）问题的一个例子。如果每个数据点可以划分到多个类别（主题），那它就是一个</span> 
        <span style="color:#231f20;">多标签、多分类</span> 
        <span style="color:#231f20;">（multilabel,multiclass classification</span> 
        <span style="color:#231f20;">）问题。 </span> 
       </div> 
       <div></div> 
       <h4><span style="color:#476b86;">3.5.1</span><span style="color:#476b86;">　路透社数据集 </span></h4> 
       <div> 
        <span style="color:#231f20;">本节使用</span> 
        <span style="color:#231f20;">路透社数据集</span> 
        <span style="color:#231f20;">，它包含许多短新闻及其对应的主题，由路透社在 </span> 
        <span style="color:#231f20;">1986 年发布。它是一个简单的、广泛使用的文本分类数据集。它包括 </span> 
        <span style="color:#231f20;">46 个不同的主题：某些主题的样本更多，但训练集中每个主题都有至少 </span> 
        <span style="color:#231f20;">10 </span> 
        <span style="color:#231f20;">个样本。 </span> 
       </div> 
       <div></div> 
       <div> 
        <span style="color:#231f20;">与 </span> 
        <span style="color:#231f20;">IMDB </span> 
        <span style="color:#231f20;">和 </span> 
        <span style="color:#231f20;">MNIST </span> 
        <span style="color:#231f20;">类似，路透社数据集也内置为 </span> 
        <span style="color:#231f20;">Keras </span> 
        <span style="color:#231f20;">的一部分。我们来看一下。</span> 
       </div> 
       <div> 
        <pre><code class="language-python"># 路透社数据集,有 8982 个训练样本和 2246 个测试样本
(train_data, train_labels), (test_data, test_labels) = reuters.load_data(
    num_words=10000)

print('len(train_data):', len(train_data))
print('len(test_data):', len(test_data))</code></pre> 
        <pre><code class="language-python">len(train_data): 8982
len(test_data): 2246</code></pre> 
        <div> 
         <span style="color:#231f20;">与 </span> 
         <span style="color:#231f20;">IMDB </span> 
         <span style="color:#231f20;">数据集一样，参数 </span> 
         <span style="color:#231f20;">num_words=10000 </span> 
         <span style="color:#231f20;">将数据限定为前 </span> 
         <span style="color:#231f20;">10 000 </span> 
         <span style="color:#231f20;">个最常出现的单词。 </span> 
        </div> 
        <div> 
         <span style="color:#231f20;">我们有 </span> 
         <span style="color:#231f20;">8982 </span> 
         <span style="color:#231f20;">个训练样本和 </span> 
         <span style="color:#231f20;">2246 </span> 
         <span style="color:#231f20;">个测试样本。</span> 
        </div> 
        <div></div> 
        <div> 
         <div> 
          <span style="color:#231f20;">IMDB </span> 
          <span style="color:#231f20;">评论一样，每个样本都是一个整数列表（表示单词索引）。</span> 
         </div> 
         <div></div> 
         <div> 
          <div> 
           <span style="color:#0d0016;"><strong>代码清单 3-13　将索引解码为新闻文</strong></span> 
          </div> 
          <div> 
           <span style="color:#ffffff;">本</span> 
          </div> 
         </div> 
         <div> 
          <pre><code class="language-python"># 键值颠倒，将整数索引映射为单词
reverse_word_index = dict(
    [(value, key) for (key, value) in word_index.items()])

# 注意，索引减去了 3，因为 0、1、2 是为“padding”（填充）、
# “start of sequence”（序列开始）、“unknown”（未知词）分别保留的索引
# 样本对应的标签是一个 0~45 范围内的整数，即话题索引编号
decoded_newswire = ' '.join([reverse_word_index.get(i - 3, '?') for i in
                             train_data[0]])</code></pre> 
          <pre><code class="language-python">print('train_data[10]', train_data[10])
print('train_labels[10]=', train_labels[10])</code></pre> 
         </div> 
         <div> 
          <pre><code class="language-python">train_data[10] [1, 245, 273, 207, 156, 53, 74, 160, 26, 14, 46, 296, 26, 39, 74, 2979, 3554, 14, 46, 4689, 4329, 86, 61, 3499, 4795, 14, 61, 451, 4329, 17, 12]
train_labels[10]= 3</code></pre> 
         </div> 
         <div></div> 
        </div> 
       </div> 
      </div> 
     </div> 
    </div> 
   </div> 
  </div> 
 </div> 
</div> 
<h4> <span style="color:#476b86;">3.5.2</span><span style="color:#476b86;">　准备数据</span></h4> 
<p><span style="color:#231f20;">使用与上一个例子相同的代码将数据向量化。</span></p> 
<pre><code class="language-python">def vectorize_sequences(sequences, dimension=10000):
    results = np.zeros((len(sequences), dimension))
    for i, sequence in enumerate(sequences):
        results[i, sequence] = 1.
    return results

x_train = vectorize_sequences(train_data)
x_test = vectorize_sequences(test_data)</code></pre> 
<div> 
 <span style="color:#fe2c24;">将标签向量化有两种方法：你可以将标签列表转换为整数张量，或者使用 one-hot 编码</span> 
 <span style="color:#231f20;">。 one-hot </span> 
 <span style="color:#231f20;">编码是分类数据广泛使用的一种格式，也叫</span> 
 <span style="color:#231f20;">分类编码</span> 
 <span style="color:#231f20;">（</span> 
 <span style="color:#231f20;">categorical encoding</span> 
 <span style="color:#231f20;">）。</span> 
 <span style="color:#231f20;">6.1 节给出了 </span> 
 <span style="color:#231f20;">one-hot </span> 
 <span style="color:#231f20;">编码的详细解释。在这个例子中，标签的 </span> 
 <span style="color:#231f20;">one-hot 编码就是将每个标签表示为全零向量，只有标签索引对应的元素为 </span> 
 <span style="color:#231f20;">1</span> 
 <span style="color:#231f20;">。其代码实现如下。</span> 
</div> 
<div></div> 
<div> 
 <pre><code class="language-python">def to_one_hot(labels, dimension=46):
    results = np.zeros((len(labels), dimension))
    for i, label in enumerate(labels):
        results[i, label] = 1.
    return results

one_hot_train_labels = to_one_hot(train_labels)
one_hot_test_labels = to_one_hot(test_labels)</code></pre> 
 <div> 
  <span style="color:#231f20;">注意，</span> 
  <span style="color:#231f20;">Keras </span> 
  <span style="color:#231f20;">内置方法可以实现这个操作，你在 </span> 
  <span style="color:#231f20;">MNIST </span> 
  <span style="color:#231f20;">例子中已经见过这种方法。</span> 
 </div> 
 <div></div> 
 <div> 
  <pre><code class="language-python">rom keras.utils import to_categorical

one_hot_train_labels = to_categorical(train_labels)
one_hot_test_labels = to_categorical(test_labels)</code></pre> 
  <h4><span style="color:#476b86;">3.5.3</span><span style="color:#476b86;">　构建网络</span></h4> 
  <div> 
   <div> 
    <span style="color:#231f20;">这个主题分类问题与前面的电影评论分类问题类似，两个例子都是试图对简短的文本片段进行分类。但这个问题有一个新的约束条件：输出类别的数量从 </span> 
    <span style="color:#231f20;">2 </span> 
    <span style="color:#231f20;">个变为 </span> 
    <span style="color:#231f20;">46 个。输出空间的维度要大得多。 </span> 
   </div> 
   <div></div> 
   <div> 
    <span style="color:#231f20;">对于前面用过的 Dense 层的堆叠，每层只能访问上一层输出的信息。如果某一层丢失了与分类问题相关的一些信息，那么这些信息无法被后面的层找回，也就是说，每一层都可能成为信息瓶颈。</span> 
    <span style="color:#fe2c24;">上一个例子（电影二分类）使用了 16 维的中间层，但对这个例子来说 16 维空间可能太小了</span> 
    <span style="color:#231f20;">，无法学会区分 </span> 
    <span style="color:#231f20;">46 </span> 
    <span style="color:#231f20;">个不同的类别。这种维度较小的层可能成为信息瓶颈，永久地丢失相关信息。 </span> 
   </div> 
   <div></div> 
   <div> 
    <span style="color:#231f20;">出于这个原因，下面将使用维度更大的层，包含 </span> 
    <span style="color:#231f20;">64 </span> 
    <span style="color:#231f20;">个单元。</span> 
   </div> 
  </div> 
 </div> 
</div> 
<div></div> 
<div> 
 <pre><code class="language-python"># 3.5.3 构建网络
from keras import models
from keras import layers

model = models.Sequential()
model.add(layers.Dense(64, activation='relu', input_shape=(10000,)))
model.add(layers.Dense(64, activation='relu'))
model.add(layers.Dense(46, activation='softmax'))</code></pre> 
 <div> 
  <span style="color:#231f20;">关于这个架构还应该注意另外两点。 </span> 
 </div> 
 <div> 
  <span style="color:#fe2c24;">网络的最后一层是大小为 46 的 Dense 层</span> 
  <span style="color:#231f20;">。这意味着，对于每个输入样本，网络都会输出一个 </span> 
  <span style="color:#231f20;">46 </span> 
  <span style="color:#231f20;">维向量。这个向量的每个元素（即每个维度）代表不同的输出类别。 </span> 
 </div> 
 <div></div> 
 <div> 
  <span style="color:#fe2c24;">最后一层使用了 softmax 激活。</span> 
  <span style="color:#231f20;">你在 </span> 
  <span style="color:#231f20;">MNIST </span> 
  <span style="color:#231f20;">例子中见过这种用法。网络将输出在 46个不同输出类别上的</span> 
  <span style="color:#231f20;">概率分布</span> 
  <span style="color:#231f20;">——对于每一个输入样本，网络都会输出一个 </span> 
  <span style="color:#231f20;">46 维向量，其中 </span> 
  <span style="color:#231f20;">output[i] </span> 
  <span style="color:#231f20;">是样本属于第 </span> 
  <span style="color:#231f20;">i </span> 
  <span style="color:#231f20;">个类别的概率。</span> 
  <span style="color:#231f20;">46 </span> 
  <span style="color:#231f20;">个概率的总和为 </span> 
  <span style="color:#231f20;">1</span> 
  <span style="color:#231f20;">。 </span> 
 </div> 
 <div></div> 
 <div> 
  <span style="color:#231f20;">对于这个例子，</span> 
  <span style="color:#fe2c24;">最好的损失函数是 categorical_crossentropy（分类交叉熵）</span> 
  <span style="color:#231f20;">。它用于衡量两个概率分布之间的距离，这里两个概率分布分别是网络输出的概率分布和标签的真实分布。通过将这两个分布的距离最小化，训练网络可使输出结果尽可能接近真实标签。</span> 
 </div> 
</div> 
<div></div> 
<div></div> 
<div> 
 <pre><code class="language-python">model.compile(optimizer='rmsprop',
              loss='categorical_crossentropy',
              metrics=['accuracy'])</code></pre> 
 <h4><span style="color:#476b86;">3.5.4</span><span style="color:#476b86;">　验证你的方法</span></h4> 
 <div> 
  <div>
      
   <span style="color:#231f20;">我们在训练数据中留出 1000 个样本作为验证集。 </span>  
  </div> 
  <div></div> 
  <div> 
   <span style="color:#0d0016;">代码清单 3-17　留出验证集</span>   
  </div> 
  <div> 
   <pre><code class="language-python">x_val = x_train[:1000]
partial_x_train = x_train[1000:]
y_val = one_hot_train_labels[:1000]
partial_y_train = one_hot_train_labels[1000:]</code></pre> 
   <div> 
    <span style="color:#231f20;">现在开始训练网络，共 </span> 
    <span style="color:#231f20;">20 </span> 
    <span style="color:#231f20;">个轮次。</span> 
   </div> 
   <div></div> 
   <div> 
    <pre><code class="language-python">history = model.fit(partial_x_train,
                    partial_y_train,
                    epochs=20,
                    batch_size=512,
                    validation_data=(x_val, y_val))</code></pre> 
    <div> 
     <span style="color:#231f20;">最后，我们来绘制损失曲线和精度曲线（见图 </span> 
     <span style="color:#231f20;">3-9 </span> 
     <span style="color:#231f20;">和图 </span> 
     <span style="color:#231f20;">3-10</span> 
     <span style="color:#231f20;">）。</span> 
    </div> 
   </div> 
   <div></div> 
   <div> 
    <strong><span style="color:#0d0016;">代码清单 3-19　绘制训练损失和验证损失</span></strong> 
   </div> 
   <div></div> 
   <div> 
    <pre><code class="language-python">loss = history.history['loss']
val_loss = history.history['val_loss']
epochs = range(1, len(loss) + 1)
plt.plot(epochs, loss, 'bo', label='Training loss')
plt.plot(epochs, val_loss, 'b', label='Validation loss')
plt.title('Training and validation loss')
plt.xlabel('Epochs')
plt.ylabel('Loss')
plt.legend()
plt.show()</code></pre> 
    <p style="text-align:center;"><img alt="" height="279" src="https://images2.imgbox.com/16/34/omMmueMZ_o.png" width="372"></p> 
   </div> 
   <div> 
    <pre><code class="language-python">plt.clf()
acc = history.history['accuracy']
val_acc = history.history['val_accuracy']

plt.plot(epochs, acc, 'bo', label='Training accuracy')
plt.plot(epochs, val_acc, 'b', label='Validation accuracy')
plt.title('Training and validation accuracy')
plt.xlabel('Epochs')
plt.ylabel('Accuracy')
plt.legend()
plt.show()</code></pre> 
    <p style="text-align:center;"><img alt="" height="304" src="https://images2.imgbox.com/f6/0c/37m9eqsm_o.png" width="405"></p> 
   </div> 
   <div> 
    <div> 
     <span style="color:#231f20;">网络在训练 </span> 
     <span style="color:#231f20;">9 </span> 
     <span style="color:#231f20;">轮后开始过拟合。我们从头开始训练一个新网络，共 </span> 
     <span style="color:#231f20;">9 个轮次，然后在测试集上评估模型。</span> 
    </div> 
    <div></div> 
    <div> 
     <pre><code class="language-python"># 代码清单 3-21　从头开始重新训练一个模型
model = models.Sequential()
model.add(layers.Dense(64, activation='relu', input_shape=(10000,)))
model.add(layers.Dense(64, activation='relu'))
model.add(layers.Dense(46, activation='softmax'))

model.compile(optimizer='rmsprop',
              loss='categorical_crossentropy',
              metrics=['accuracy'])

model.fit(partial_x_train,
          partial_y_train,
          epochs=9,
          batch_size=512,
          validation_data=(x_val, y_val))

results = model.evaluate(x_test, one_hot_test_labels)
print('results:',results)</code></pre> 
     <pre><code class="language-python">results: [0.969092845916748, 0.7836152911186218]</code></pre> 
     <div> 
      <span style="color:#231f20;">这种方法可以得到约 </span> 
      <span style="color:#231f20;">80% 的精度。对于平衡的二分类问题，完全随机的分类器能够得到50% </span> 
      <span style="color:#231f20;">的精度。但在这个例子中，完全随机的精度约为 </span> 
      <span style="color:#231f20;">19%，所以上述结果相当不错，至少和随机的基准比起来还不错。</span> 
     </div> 
    </div> 
   </div> 
   <div></div> 
   <div> 
    <pre><code class="language-python">import copy

test_labels_copy = copy.copy(test_labels)
np.random.shuffle(test_labels_copy)
hits_array = np.array(test_labels) == np.array(test_labels_copy)
float(np.sum(hits_array)) / len(test_labels)
print('hits_array.mean():', hits_array.mean())</code></pre> 
    <pre><code class="language-python">hits_array.mean(): 0.188780053428317</code></pre> 
    <p>可见，随机分类器的分类精度约为19%。我们的模型看起来相当不错。</p> 
   </div> 
   <div> 
    <h4><span style="color:#476b86;">3.5.5</span><span style="color:#476b86;">　在新数据上生成预测结果 </span></h4> 
    <div> 
     <span style="color:#231f20;">你可以验证，模型实例的 </span> 
     <span style="color:#231f20;">predict </span> 
     <span style="color:#231f20;">方法返回了在 </span> 
     <span style="color:#231f20;">46 个主题上的概率分布。我们对所有测试数据生成主题预测。 </span> 
    </div> 
    <div></div> 
    <div> 
     <span style="color:#0d0016;">代码清单 3-22　在新数据上生成预测结果</span> 
    </div> 
    <div></div> 
    <div> 
     <div> 
      <span style="color:#fe2c24;">predictions = model.predict(x_test) </span> 
     </div> 
     <div></div> 
     <div> 
      <span style="color:#231f20;">predictions </span> 
      <span style="color:#231f20;">中的每个元素都是长度为 </span> 
      <span style="color:#231f20;">46 </span> 
      <span style="color:#231f20;">的向量。 </span> 
     </div> 
     <div></div> 
     <div> 
      <span style="color:#231f20;">&gt;&gt;&gt; </span> 
      <span style="color:#fe2c24;">predictions[0].shape </span> 
     </div> 
     <div> 
      <span style="color:#231f20;">(46,) </span> 
     </div> 
     <div> 
      <span style="color:#231f20;">这个向量的所有元素总和为 </span> 
      <span style="color:#231f20;">1</span> 
      <span style="color:#231f20;">。 </span> 
     </div> 
     <div></div> 
     <div> 
      <span style="color:#231f20;">&gt;&gt;&gt; </span> 
      <span style="color:#fe2c24;">np.sum(predictions[0]) </span> 
     </div> 
     <div> 
      <span style="color:#231f20;">1.0 </span> 
     </div> 
     <div> 
      <span style="color:#231f20;">最大的元素就是预测类别，即概率最大的类别。 </span> 
     </div> 
     <div></div> 
     <div> 
      <span style="color:#231f20;">&gt;&gt;&gt; </span> 
      <span style="color:#fe2c24;">np.argmax(predictions[0]) </span> 
     </div> 
     <div> 
      <span style="color:#231f20;">4</span> 
     </div> 
     <div></div> 
     <div> 
      <h4><span style="color:#476b86;">3.5.6</span><span style="color:#476b86;">　处理标签和损失的另一种方法 </span></h4> 
      <div> 
       <span style="color:#231f20;">前面提到了另一种编码标签的方法，就是将其转换为整数张量，如下所示。</span> 
      </div> 
      <div></div> 
      <div></div> 
      <div> 
       <pre><code class="language-python">y_train = np.array(train_labels)
y_test = np.array(test_labels)</code></pre> 
       <div> 
        <span style="color:#231f20;">对于这种编码方法，</span> 
        <strong><span style="color:#fe2c24;">唯一需要改变的是损失函数的选择</span></strong> 
        <span style="color:#231f20;">。对于代码清单 </span> 
        <span style="color:#231f20;">3-21 使用的损失函数 </span> 
        <span style="color:#231f20;">categorical_crossentropy，标签应该遵循分类编码。对于整数标签，你应该使用 </span> 
        <span style="color:#fe2c24;">sparse_ categorical_ crossentropy</span> 
        <span style="color:#231f20;">。</span> 
       </div> 
       <div></div> 
       <div> 
        <pre><code class="language-python">model.compile(optimizer='rmsprop',
              loss='sparse_categorical_crossentropy',
              metrics=['acc'])</code></pre> 
        <div> 
         <span style="color:#231f20;">这个新的损失函数在数学上与 </span> 
         <span style="color:#231f20;">categorical_crossentropy </span> 
         <span style="color:#231f20;">完全相同，二者只是接口不同。</span> 
        </div> 
       </div> 
      </div> 
      <div></div> 
      <div></div> 
      <div> 
       <h4><span style="color:#476b86;">3.5.7</span><span style="color:#476b86;">　中间层维度足够大的重要性 </span></h4> 
       <div> 
        <span style="color:#231f20;">前面提到，最终输出是 </span> 
        <span style="color:#231f20;">46 </span> 
        <span style="color:#231f20;">维的，因此中间层的隐藏单元个数不应该比 </span> 
        <span style="color:#231f20;">46 </span> 
        <span style="color:#231f20;">小太多。现在来 </span> 
       </div> 
       <div> 
        <span style="color:#0d0016;">看一下，如果中间层的维度远远小于 46（比如 4 维），造成了信息瓶颈，那么会发生什么？ </span> 
       </div> 
       <div></div> 
       <div> 
        <span style="color:#0d0016;">代码清单 3-23　具有信息瓶颈的模型</span> 
       </div> 
      </div> 
      <div></div> 
      <div></div> 
      <div> 
       <pre><code class="language-python">model = models.Sequential()
model.add(layers.Dense(64, activation='relu', input_shape=(10000,)))
model.add(layers.Dense(4, activation='relu'))
model.add(layers.Dense(46, activation='softmax'))

model.compile(optimizer='rmsprop',
              loss='categorical_crossentropy',
              metrics=['accuracy'])

model.fit(partial_x_train,
          partial_y_train,
          epochs=20,
          batch_size=128,
          validation_data=(x_val, y_val))</code></pre> 
      </div> 
      <div> 
       <pre><code class="language-python">results: [2.0253124237060547, 0.6571683287620544]</code></pre> 
       <p><span style="color:#231f20;">现在网络的验证精度最大约为 </span><span style="color:#231f20;">71%（中间层为4维，batch_size = 128时，为66%）</span><span style="color:#231f20;">，比前面下降了 </span><span style="color:#231f20;">8%。导致这一下降的主要原因在于，</span><span style="color:#fe2c24;">你试图将大量信息（这些信息足够恢复 46 个类别的分割超平面）压缩到维度很小的中间空间。网络能够将大部分必要信息塞入这个四维表示中，但并不是全部信息。</span></p> 
       <p><span style="color:#fe2c24;">当</span><span style="color:#231f20;">中间层为4维，batch_size = 512时：性能改善，但不明显</span></p> 
       <pre><code class="language-python">results: [1.4226462841033936, 0.6691896915435791]</code></pre> 
       <p></p> 
       <h4><span style="color:#476b86;">3.5.8</span><span style="color:#476b86;">　进一步的实验 </span></h4> 
       <div> 
        <span style="color:#231f20;">尝试使用更多或更少的隐藏单元，比如 </span> 
        <span style="color:#231f20;">32 </span> 
        <span style="color:#231f20;">个、</span> 
        <span style="color:#231f20;">128 </span> 
        <span style="color:#231f20;">个等。 </span> 
       </div> 
       <div></div> 
       <div> 
        <span style="color:#fe2c24;">当</span> 
        <span style="color:#231f20;">中间层为32维，batch_size = 512时</span> 
       </div> 
       <div> 
        <pre><code class="language-python">results: [1.0372092723846436, 0.7880676984786987]</code></pre> 
        <p><span style="color:#fe2c24;">当</span><span style="color:#231f20;">中间层为128维，batch_size = 512时</span></p> 
       </div> 
       <div> 
        <pre><code class="language-python">results: [1.0692521333694458, 0.7876224517822266]</code></pre> 
       </div> 
       <div></div> 
       <div> 
        <span style="color:#231f20;">前面使用了两个隐藏层，现在尝试使用一个或三个隐藏层。 </span> 
       </div> 
       <div></div> 
       <div> 
        <span style="color:#231f20;">当只有一个隐含层时：</span> 
       </div> 
       <div></div> 
       <div> 
        <pre><code class="language-python">model = models.Sequential()
model.add(layers.Dense(64, activation='relu', input_shape=(10000,)))
model.add(layers.Dense(46, activation='softmax'))</code></pre> 
        <pre><code class="language-python">results: [0.8956318497657776, 0.7974176406860352]</code></pre> 
        <pre><code class="language-python">model = models.Sequential()
model.add(layers.Dense(64, activation='relu', input_shape=(10000,)))
model.add(layers.Dense(64, activation='relu'))
model.add(layers.Dense(64, activation='relu'))
model.add(layers.Dense(46, activation='softmax'))</code></pre> 
        <pre><code class="language-python">results: [1.1916015148162842, 0.7911843061447144]</code></pre> 
        <h4><span style="color:#476b86;">3.5.9</span><span style="color:#476b86;">　小结 </span></h4> 
       </div> 
       <div> 
        <span style="color:#231f20;">下面是你应该从这个例子中学到的要点。 </span> 
       </div> 
       <div></div> 
       <div> 
        <span style="color:#231f20;">如果要对 </span> 
        <span style="color:#231f20;"><em>N </em></span> 
        <span style="color:#231f20;">个类别的数据点进行分类，网络的最后一层应该是大小为 </span> 
        <span style="color:#231f20;"><em>N </em></span> 
        <span style="color:#231f20;">的 </span> 
        <span style="color:#231f20;">Dense </span> 
        <span style="color:#231f20;">层。 </span> 
       </div> 
       <div></div> 
       <div> 
        <span style="color:#231f20;">对于单标签、多分类问题，网络的最后一层应该使用 </span> 
        <span style="color:#231f20;">softmax </span> 
        <span style="color:#231f20;">激活，这样可以输出在 </span> 
        <span style="color:#231f20;"><em>N</em></span> 
        <span style="color:#231f20;">个输出类别上的概率分布。 </span> 
       </div> 
       <div></div> 
       <div> 
        <span style="color:#231f20;">这种问题的损失函数几乎总是应该使用分类交叉熵。它将网络输出的概率分布与目标的真实分布之间的距离最小化。 </span> 
       </div> 
       <div></div> 
       <div> 
        <span style="color:#231f20;">处理多分类问题的标签有两种方法。 </span> 
       </div> 
       <div> 
        <span style="color:#231f20;">通过分类编码（也叫 </span> 
        <span style="color:#231f20;">one-hot </span> 
        <span style="color:#231f20;">编码）对标签进行编码，然后使用 categorical_crossentropy </span> 
        <span style="color:#231f20;">作为损失函数。 </span> 
       </div> 
       <div></div> 
       <div> 
        <span style="color:#231f20;">将标签编码为整数，然后使用 </span> 
        <span style="color:#231f20;">sparse_categorical_crossentropy </span> 
        <span style="color:#231f20;">损失函数。 </span> 
       </div> 
       <div></div> 
       <div> 
        <span style="color:#231f20;">如果你需要将数据划分到许多类别中，应该避免使用太小的中间层，以免在网络中造成信息瓶颈。</span> 
       </div> 
      </div> 
      <div></div> 
      <div> 
       <h3><span style="color:#476b86;">3.6</span><span style="color:#476b86;">　预测房价：回归问题 </span></h3> 
       <div> 
        <span style="color:#231f20;">前面两个例子都是分类问题，其目标是预测输入数据点所对应的单一离散的标签。</span> 
        <span style="color:#fe2c24;">另一种常见的机器学习问题是回归问题，它预测一个连续值而不是离散的标签</span> 
        <span style="color:#231f20;">，例如，根据气象数据预测明天的气温，或者根据软件说明书预测完成软件项目所需要的时间。 </span> 
       </div> 
       <div></div> 
       <div> 
        <span style="color:#231f20;">注意 </span> 
        <span style="color:#231f20;">不要将回归问题与 </span> 
        <span style="color:#231f20;">logistic </span> 
        <span style="color:#231f20;">回归算法混为一谈。令人困惑的是，</span> 
        <span style="color:#fe2c24;">logistic 回归不是回归算法， </span> 
       </div> 
       <div> 
        <span style="color:#fe2c24;">而是分类算法</span> 
        <span style="color:#231f20;">。</span> 
       </div> 
      </div> 
      <div></div> 
      <div> 
       <h4><span style="color:#476b86;">3.6.1</span><span style="color:#476b86;">　波士顿房价数据集 </span></h4> 
       <div> 
        <span style="color:#231f20;">本节将要预测 </span> 
        <span style="color:#231f20;">20 </span> 
        <span style="color:#231f20;">世纪 70 年代中期波士顿郊区房屋价格的中位数，已知当时郊区的一些数据点，比如犯罪率、当地房产税率等。本节用到的数据集与前面两个例子有一个有趣的区别。它包含的数据点相对较少，只有 </span> 
        <span style="color:#fe2c24;">506 个</span> 
        <span style="color:#231f20;">，</span> 
        <span style="color:#fe2c24;">分为 404 个训练样本和 102 个测试样本</span> 
        <span style="color:#231f20;">。输入数据的每个</span> 
        <span style="color:#231f20;">特征</span> 
        <span style="color:#231f20;">（比如犯罪率）都有不同的取值范围。例如，有些特性是比例，取值范围为 </span> 
        <span style="color:#231f20;">0~1</span> 
        <span style="color:#231f20;">；有 </span> 
       </div> 
       <div> 
        <span style="color:#231f20;">的取值范围为 </span> 
        <span style="color:#231f20;">1~12</span> 
        <span style="color:#231f20;">；还有的取值范围为 </span> 
        <span style="color:#231f20;">0~100</span> 
        <span style="color:#231f20;">，等等。</span> 
       </div> 
       <div></div> 
      </div> 
      <div> 
       <div> 
        <strong><span style="color:#0d0016;">代码清单 3-24　加载波士顿房价数据</span></strong> 
       </div> 
      </div> 
      <div></div> 
      <div> 
       <pre><code class="language-python">(train_data, train_targets), (test_data, test_targets) = boston_housing.load_data()

# 有 404 个训练样本和 102 个测试样本,每个样本都有 13 个数值特征（犯罪率、与高速的距离、离商场的距离等）
# 比如人均犯罪率、每个住宅的平均房间数、高速公路可达性等

print('train_data.shape:', train_data.shape)  # train_data.shape: (404, 13)
print('test_data.shape:', test_data.shape)  # test_data.shape: (102, 13)
# 房价大都在 10 000~50 000 美元，
print('train_targets（单位为K 美元）:', train_targets)</code></pre> 
       <div> 
        <pre><code class="language-python">train_data.shape: (404, 13)
test_data.shape: (102, 13)
train_targets（单位为K 美元）: [15.2 42.3 50.  21.1 17.7 18.5 11.3 15.6 15.6 14.4 12.1 17.9 23.1 19.9
 15.7  8.8 50.  22.5 24.1 27.5 10.9 30.8 32.9 24.  18.5 13.3 22.9 34.7
 16.6 17.5 22.3 16.1 14.9 23.1 34.9 25.  13.9 13.1 20.4 20.  15.2 24.7
 22.2 16.7 12.7 15.6 18.4 21.  30.1 15.1 18.7  9.6 31.5 24.8 19.1 22.
 14.5 11.  32.  29.4 20.3 24.4 14.6 19.5 14.1 14.3 15.6 10.5  6.3 19.3
 19.3 13.4 36.4 17.8 13.5 16.5  8.3 14.3 16.  13.4 28.6 43.5 20.2 22.
 23.  20.7 12.5 48.5 14.6 13.4 23.7 50.  21.7 39.8 38.7 22.2 34.9 22.5
 31.1 28.7 46.  41.7 21.  26.6 15.  24.4 13.3 21.2 11.7 21.7 19.4 50.
 22.8 19.7 24.7 36.2 14.2 18.9 18.3 20.6 24.6 18.2  8.7 44.  10.4 13.2
 21.2 37.  30.7 22.9 20.  19.3 31.7 32.  23.1 18.8 10.9 50.  19.6  5.
 14.4 19.8 13.8 19.6 23.9 24.5 25.  19.9 17.2 24.6 13.5 26.6 21.4 11.9
 22.6 19.6  8.5 23.7 23.1 22.4 20.5 23.6 18.4 35.2 23.1 27.9 20.6 23.7
 28.  13.6 27.1 23.6 20.6 18.2 21.7 17.1  8.4 25.3 13.8 22.2 18.4 20.7
 31.6 30.5 20.3  8.8 19.2 19.4 23.1 23.  14.8 48.8 22.6 33.4 21.1 13.6
 32.2 13.1 23.4 18.9 23.9 11.8 23.3 22.8 19.6 16.7 13.4 22.2 20.4 21.8
 26.4 14.9 24.1 23.8 12.3 29.1 21.  19.5 23.3 23.8 17.8 11.5 21.7 19.9
 25.  33.4 28.5 21.4 24.3 27.5 33.1 16.2 23.3 48.3 22.9 22.8 13.1 12.7
 22.6 15.  15.3 10.5 24.  18.5 21.7 19.5 33.2 23.2  5.  19.1 12.7 22.3
 10.2 13.9 16.3 17.  20.1 29.9 17.2 37.3 45.4 17.8 23.2 29.  22.  18.
 17.4 34.6 20.1 25.  15.6 24.8 28.2 21.2 21.4 23.8 31.  26.2 17.4 37.9
 17.5 20.   8.3 23.9  8.4 13.8  7.2 11.7 17.1 21.6 50.  16.1 20.4 20.6
 21.4 20.6 36.5  8.5 24.8 10.8 21.9 17.3 18.9 36.2 14.9 18.2 33.3 21.8
 19.7 31.6 24.8 19.4 22.8  7.5 44.8 16.8 18.7 50.  50.  19.5 20.1 50.
 17.2 20.8 19.3 41.3 20.4 20.5 13.8 16.5 23.9 20.6 31.5 23.3 16.8 14.
 33.8 36.1 12.8 18.3 18.7 19.1 29.  30.1 50.  50.  22.  11.9 37.6 50.
 22.7 20.8 23.5 27.9 50.  19.3 23.9 22.6 15.2 21.7 19.2 43.8 20.3 33.2
 19.9 22.5 32.7 22.  17.1 19.  15.  16.1 25.1 23.7 28.7 37.2 22.6 16.4
 25.  29.8 22.1 17.4 18.1 30.3 17.5 24.7 12.6 26.5 28.7 13.3 10.4 24.4
 23.  20.  17.8  7.  11.8 24.4 13.8 19.4 25.2 19.4 19.4 29.1]
train_data[0]: [  1.23247   0.        8.14      0.        0.538     6.142    91.7
   3.9769    4.      307.       21.      396.9      18.72   ]</code></pre> 
        <p><span style="color:#231f20;">房价大都在 </span><span style="color:#231f20;">10 000~50 000 </span><span style="color:#231f20;">美元。如果你觉得这很便宜，不要忘记当时是 </span><span style="color:#231f20;">20 </span><span style="color:#231f20;">世纪 </span><span style="color:#231f20;">70 年代中期，而且这些价格没有根据通货膨胀进行调整。</span></p> 
       </div> 
       <div></div> 
       <div> 
        <h4><span style="color:#476b86;">3.6.2</span><span style="color:#476b86;">　准备数据 </span></h4> 
        <div> 
         <span style="color:#231f20;">将取值范围差异很大的数据输入到神经网络中，这是有问题的。网络可能会自动适应这种取值范围不同的数据，但学习肯定变得更加困难。对于这种数据，</span> 
         <span style="color:#fe2c24;">普遍采用的最佳实践是对每个特征做标准化</span> 
         <span style="color:#231f20;">，即</span> 
         <span style="color:#fe2c24;">对于输入数据的每个特征（输入数据矩阵中的列），减去特征平均值，再除以标准差</span> 
         <span style="color:#231f20;">，这样得到的特征平均值为 </span> 
         <span style="color:#231f20;">0</span> 
         <span style="color:#231f20;">，标准差为 </span> 
         <span style="color:#231f20;">1</span> 
         <span style="color:#231f20;">。用 </span> 
         <span style="color:#231f20;">Numpy </span> 
         <span style="color:#231f20;">可以很容易实现标准化。</span> 
        </div> 
       </div> 
      </div> 
      <div>
          
      </div> 
      <div> 
       <pre><code class="language-python">mean = train_data.mean(axis=0)  # 沿着y轴
train_data -= mean  # train_data =train_data - mean（mean：期望值）
std = train_data.std(axis=0)  # std：标准差
train_data /= std  # train_data = train_data / std

test_data -= mean
test_data /= std</code></pre> 
       <pre><code class="language-python">print('mean:', mean)
print('_____________________________________')
print('_____________________________________')
print('std:', std)</code></pre> 
       <pre><code class="language-python">mean: [3.74511057e+00 1.14801980e+01 1.11044307e+01 6.18811881e-02
 5.57355941e-01 6.26708168e+00 6.90106436e+01 3.74027079e+00
 9.44059406e+00 4.05898515e+02 1.84759901e+01 3.54783168e+02
 1.27408168e+01]
_____________________________________
_____________________________________
std: [9.22929073e+00 2.37382770e+01 6.80287253e+00 2.40939633e-01
 1.17147847e-01 7.08908627e-01 2.79060634e+01 2.02770050e+00
 8.68758849e+00 1.66168506e+02 2.19765689e+00 9.39946015e+01
 7.24556085e+00]</code></pre> 
       <div> 
        <span style="color:#231f20;">注意，用于测试数据标准化的均值和标准差都是在训练数据上计算得到的。在工作流程中， </span> 
       </div> 
       <div> 
        <span style="color:#231f20;">你不能使用在测试数据上计算得到的任何结果，即使是像数据标准化这么简单的事情也不行。</span> 
       </div> 
       <div></div> 
       <div> 
        <h4><span style="color:#476b86;">3.6.3</span><span style="color:#476b86;">　构建网络 </span></h4> 
        <div> 
         <span style="color:#231f20;">由于样本数量很少，我们</span> 
         <span style="color:#fe2c24;">将使用一个非常小的网络</span> 
         <span style="color:#231f20;">，其中包含两个隐藏层，每层有 </span> 
         <span style="color:#231f20;">64 </span> 
         <span style="color:#231f20;">个单 </span> 
        </div> 
        <div> 
         <span style="color:#231f20;">元。一般来说，训练数据越少，过拟合会越严重，而较小的网络可以降低过拟合。</span> 
        </div> 
       </div> 
       <div></div> 
       <div> 
        <pre><code class="language-python">from keras import models
from keras import layers

def build_model():
    model = models.Sequential()
    model.add(layers.Dense(64, activation='relu',
                           input_shape=(train_data.shape[1],)))
    model.add(layers.Dense(64, activation='relu'))
    model.add(layers.Dense(1))
    model.compile(optimizer='rmsprop', loss='mse', metrics=['mae'])
    return model</code></pre> 
        <div> 
         <span style="color:#231f20;">网络的最后一层只有一个单元，没有激活，是一个线性层。这是标量回归（标量回归是预测单一连续值的回归）的</span> 
         <span style="color:#fe2c24;">典型设置</span> 
         <span style="color:#231f20;">。添加激活函数将会限制输出范围。例如，如果向最后一层添加 </span> 
         <span style="color:#231f20;">sigmoid </span> 
         <span style="color:#231f20;">激活函数，网络只能学会预测 </span> 
         <span style="color:#231f20;">0~1 范围内的值。这里最后一层是纯线性的，所以网络可以学会预测任意范围内的值。 </span> 
        </div> 
        <div></div> 
        <div> 
         <span style="color:#231f20;">注意，编译网络用的是</span> 
         <span style="color:#fe2c24;"> mse 损失函数</span> 
         <span style="color:#231f20;">，即</span> 
         <span style="color:#fe2c24;">均方误差（MSE，mean squared error）</span> 
         <span style="color:#231f20;">，预测值与 </span> 
        </div> 
        <div> 
         <span style="color:#231f20;">目标值之差的平方。这是回归问题常用的损失函数。 </span> 
        </div> 
        <div></div> 
        <div> 
         <span style="color:#231f20;">在训练过程中还监控一个新指标：</span> 
         <span style="color:#231f20;">平均绝对误差</span> 
         <span style="color:#231f20;">（</span> 
         <span style="color:#231f20;">MAE</span> 
         <span style="color:#231f20;">，</span> 
         <span style="color:#231f20;">mean absolute error</span> 
         <span style="color:#231f20;">）。它是预测值 </span> 
        </div> 
        <div> 
         <span style="color:#231f20;">与目标值之差的绝对值。比如，如果这个问题的 </span> 
         <span style="color:#231f20;">MAE </span> 
         <span style="color:#231f20;">等于 </span> 
         <span style="color:#231f20;">0.5</span> 
         <span style="color:#231f20;">，就表示你预测的房价与实际价 </span> 
        </div> 
        <div> 
         <span style="color:#231f20;">格平均相差 </span> 
         <span style="color:#231f20;">500 </span> 
         <span style="color:#231f20;">美元。</span> 
        </div> 
        <div></div> 
        <div> 
         <h4><span style="color:#476b86;">3.6.4</span><span style="color:#476b86;">　利用 </span><span style="color:#476b86;"><em>K </em></span><span style="color:#476b86;">折验证来验证你的方法 </span></h4> 
         <div> 
          <span style="color:#231f20;">为了在调节网络参数（比如训练的轮数）的同时对网络进行评估，你可以将数据划分为训 </span> 
         </div> 
         <div> 
          <span style="color:#231f20;">练集和验证集，正如前面例子中所做的那样。但由于数据点很少，验证集会非常小（比如大约 </span> 
         </div> 
         <div> 
          <span style="color:#231f20;">100 </span> 
          <span style="color:#231f20;">个样本）。因此，验证分数可能会有很大波动，这取决于你所选择的验证集和训练集。也就 </span> 
         </div> 
         <div> 
          <span style="color:#231f20;">是说，验证集的划分方式可能会造成验证分数上有很大的</span> 
          <span style="color:#231f20;">方差</span> 
          <span style="color:#231f20;">，这样就无法对模型进行可靠的 </span> 
         </div> 
         <div> 
          <span style="color:#231f20;">评估。 </span> 
         </div> 
         <div> 
          <span style="color:#231f20;">在这种情况下，最佳做法是使用 </span> 
          <span style="color:#231f20;"><em>K </em></span> 
          <span style="color:#231f20;">折</span> 
          <span style="color:#231f20;">交叉验证（见图 </span> 
          <span style="color:#231f20;">3-11</span> 
          <span style="color:#231f20;">）。这种方法将可用数据划分为 </span> 
          <span style="color:#231f20;"><em>K </em></span> 
         </div> 
         <div> 
          <span style="color:#231f20;">个分区（</span> 
          <span style="color:#231f20;"><em>K </em></span> 
          <span style="color:#231f20;">通常取 </span> 
          <span style="color:#231f20;">4 </span> 
          <span style="color:#231f20;">或 </span> 
          <span style="color:#231f20;">5</span> 
          <span style="color:#231f20;">），实例化 </span> 
          <span style="color:#231f20;"><em>K </em></span> 
          <span style="color:#231f20;">个相同的模型，将每个模型在 </span> 
          <span style="color:#231f20;"><em>K</em></span> 
          <span style="color:#231f20;">-</span> 
          <span style="color:#231f20;">1 </span> 
          <span style="color:#231f20;">个分区上训练，并在剩 </span> 
         </div> 
         <div> 
          <span style="color:#231f20;">下的一个分区上进行评估。模型的验证分数等于 </span> 
          <span style="color:#231f20;"><em>K </em></span> 
          <span style="color:#231f20;">个验证分数的平均值。这种方法的代码实现 </span> 
         </div> 
         <div> 
          <span style="color:#231f20;">很简单。</span> 
         </div> 
        </div> 
       </div> 
       <div></div> 
       <div> 
        <img alt="" height="191" src="https://images2.imgbox.com/43/8e/Nkj2wIOq_o.png" width="398"> 
       </div> 
       <div></div> 
       <div> 
        <pre><code class="language-python">import numpy as np

k = 4
num_val_samples = len(train_data) // k
print('num_val_samples', num_val_samples)
num_epochs = 100
all_scores = []

for i in range(k):
    print('processing fold #', i)
    val_data = train_data[i * num_val_samples: (i + 1) * num_val_samples]
    val_targets = train_targets[i * num_val_samples: (i + 1) * num_val_samples]

    partial_train_data = np.concatenate(  # 准备训练数据：其他所有分区的数据
        [train_data[:i * num_val_samples],
         train_data[(i + 1) * num_val_samples:]],
        axis=0)

    partial_train_targets = np.concatenate(
        [train_targets[:i * num_val_samples],
         train_targets[(i + 1) * num_val_samples:]],
        axis=0)

    model = build_model()  # 构建 Keras 模型（已编译）
    model.fit(partial_train_data, partial_train_targets,  # 训练模型（静默模式，verbose=0）
              epochs=num_epochs, batch_size=1, verbose=0)
    # 在验证数据上评估模型
    val_mse, val_mae = model.evaluate(val_data, val_targets, verbose=0)
    all_scores.append(val_mae)

# 每次运行模型得到的验证分数有很大差异，从 2.6 到 3.2 不等
print(' all_scores:', all_scores)
print(' np.mean(all_scores):', np.mean(all_scores))</code></pre> 
        <p></p> 
       </div> 
       <div></div> 
       <div> 
        <h4><span style="color:#476b86;">3.6.5</span><span style="color:#476b86;">　小结 </span></h4> 
        <div> 
         <span style="color:#231f20;">下面是你应该从这个例子中学到的要点。 </span> 
        </div> 
        <div></div> 
        <div> 
         <span style="color:#231f20;"> </span> 
         <span style="color:#231f20;">回归问题使用的损失函数与分类问题不同。</span> 
         <span style="color:#fe2c24;">回归常用的损失函数是均方误差（MSE）</span> 
         <span style="color:#231f20;">。 </span> 
        </div> 
        <div></div> 
        <div> 
         <span style="color:#231f20;"> </span> 
         <span style="color:#231f20;">同样，回归问题使用的评估指标也与分类问题不同。显而易见，精度的概念不适用于回 </span> 
        </div> 
        <div> 
         <span style="color:#231f20;">归问题。常见的回归指标是</span> 
         <span style="color:#fe2c24;">平均绝对误差（MAE）</span> 
         <span style="color:#231f20;">。 </span> 
        </div> 
        <div></div> 
        <div> 
         <span style="color:#231f20;"> </span> 
         <span style="color:#231f20;">如果输入数据的特征具有不同的取值范围，应该先进行预处理，对每个特征单独进行 </span> 
        </div> 
        <div> 
         <span style="color:#231f20;">缩放。 </span> 
        </div> 
        <div></div> 
        <div> 
         <span style="color:#231f20;"> </span> 
         <span style="color:#231f20;">如果可用的数据很少，使用 </span> 
         <span style="color:#231f20;"><em>K </em></span> 
         <span style="color:#231f20;">折验证可以可靠地评估模型。 </span> 
        </div> 
        <div></div> 
        <div> 
         <span style="color:#231f20;"> </span> 
         <span style="color:#231f20;">如果可用的训练数据很少，最好使用隐藏层较少（通常只有一到两个）的小型网络，以 </span> 
        </div> 
        <div> 
         <span style="color:#231f20;">避免严重的过拟合。</span> 
        </div> 
       </div> 
      </div> 
     </div> 
    </div> 
   </div> 
  </div> 
 </div> 
</div>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/8002c5c2b9328804f4b2f152736f28a6/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">2024美赛数学建模C题思路&#43;模型&#43;代码&#43;论文</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/8fd9afc8abdcd04a6f6197d7fa662ccb/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">【机器学习】工程实践问题概述</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>