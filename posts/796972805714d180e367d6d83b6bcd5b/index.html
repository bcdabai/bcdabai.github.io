<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Cocos Creator ä¸­çš„assembleré‚£ç‚¹äº‹ - ç¼–ç¨‹å¤§ç™½çš„åšå®¢</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Cocos Creator ä¸­çš„assembleré‚£ç‚¹äº‹" />
<meta property="og:description" content="ä¸€ï¼šAssemblerçš„æ¥é¾™å»è„‰
äºŒï¼šè‡ªå®šä¹‰ä¸€ä¸ªæ¸²æŸ“ç»„ä»¶ï¼ˆä½¿ç”¨è‡ªå®šä¹‰çš„assembleræŒ‚è½½ï¼‰
ä¸€ï¼šAssemblerçš„æ¥é¾™å»è„‰ï¼šÂ ä¹‹å‰çš„æ–‡ç« ä¸­æåˆ°å’Œä½¿ç”¨è¿‡assemblerç›¸å…³çš„æŠ€æœ¯ï¼Œä½†æ˜¯ç°åœ¨çœ‹æ¥è¿˜æ˜¯ç†è§£çš„ä¸æ˜¯å¾ˆåˆ°ä½,
1: é¦–å…ˆçœ‹çœ‹é‚£assembleræ˜¯å¦‚ä½•ç»‘å®šåˆ°æ¸²æŸ“ç»„ä»¶çš„ï¼Œéšä¾¿æ‰¾åˆ°ä¸€ä¸ªæ¸²æŸ“ç»„ä»¶ï¼Œæ¯”å¦‚è¯´è€ç”Ÿå¸¸è°ˆçš„Spriteç»„ä»¶Â cocos2d/cocos-engine-2.4.8/cocos2d/core/renderer/webgl/assemblers/sprite/index.js
import Assembler from &#39;../../../assembler&#39;; import { Type, FillType } from &#39;../../../../components/CCSprite&#39;; import Simple from &#34;./2d/simple&#34;; import Sliced from &#34;./2d/sliced&#34;; import Tiled from &#34;./2d/tiled&#34;; import RadialFilled from &#34;./2d/radial-filled&#34;; import BarFilled from &#34;./2d/bar-filled&#34;; import Mesh from &#39;./2d/mesh&#39;; import Simple3D from &#34;./3d/simple&#34;; import Sliced3D from &#34;./3d/sliced&#34;; import Tiled3D from &#34;./3d/tiled&#34;; import RadialFilled3D from &#34;./3d/radial-filled&#34;; import BarFilled3D from &#34;./3d/bar-filled&#34;; import Mesh3D from &#39;./3d/mesh&#39;; let ctor = { getConstructor(sprite) { let is3DNode = sprite." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/796972805714d180e367d6d83b6bcd5b/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-03-16T11:40:19+08:00" />
<meta property="article:modified_time" content="2023-03-16T11:40:19+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="ç¼–ç¨‹å¤§ç™½çš„åšå®¢" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">ç¼–ç¨‹å¤§ç™½çš„åšå®¢</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Cocos Creator ä¸­çš„assembleré‚£ç‚¹äº‹</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p></p> 
<p><strong>ä¸€ï¼šAssemblerçš„æ¥é¾™å»è„‰</strong></p> 
<p><strong>äºŒï¼šè‡ªå®šä¹‰ä¸€ä¸ªæ¸²æŸ“ç»„ä»¶ï¼ˆä½¿ç”¨è‡ªå®šä¹‰çš„assembleræŒ‚è½½ï¼‰</strong></p> 
<p></p> 
<h2><strong>ä¸€ï¼šAssemblerçš„æ¥é¾™å»è„‰ï¼šÂ </strong></h2> 
<p>ä¹‹å‰çš„æ–‡ç« ä¸­æåˆ°å’Œä½¿ç”¨è¿‡assemblerç›¸å…³çš„æŠ€æœ¯ï¼Œä½†æ˜¯ç°åœ¨çœ‹æ¥è¿˜æ˜¯ç†è§£çš„ä¸æ˜¯å¾ˆåˆ°ä½,</p> 
<p><strong>1: é¦–å…ˆçœ‹çœ‹é‚£assembleræ˜¯å¦‚ä½•ç»‘å®šåˆ°æ¸²æŸ“ç»„ä»¶çš„ï¼Œéšä¾¿æ‰¾åˆ°ä¸€ä¸ªæ¸²æŸ“ç»„ä»¶ï¼Œæ¯”å¦‚è¯´è€ç”Ÿå¸¸è°ˆçš„Spriteç»„ä»¶</strong>Â </p> 
<p>cocos2d/cocos-engine-2.4.8/cocos2d/core/renderer/webgl/assemblers/sprite/index.js</p> 
<pre><code class="language-javascript">import Assembler from '../../../assembler';
import { Type, FillType } from '../../../../components/CCSprite';

import Simple from "./2d/simple";
import Sliced from "./2d/sliced";
import Tiled from "./2d/tiled";
import RadialFilled from "./2d/radial-filled";
import BarFilled from "./2d/bar-filled";
import Mesh from './2d/mesh';

import Simple3D from "./3d/simple";
import Sliced3D from "./3d/sliced";
import Tiled3D from "./3d/tiled";
import RadialFilled3D from "./3d/radial-filled";
import BarFilled3D from "./3d/bar-filled";
import Mesh3D from './3d/mesh';

let ctor = {
    getConstructor(sprite) {
        let is3DNode = sprite.node.is3DNode;
        // spriteèŠ‚ç‚¹é»˜è®¤ç»‘å®šçš„æ˜¯SimpleAssembler2D
        let ctor = is3DNode ? Simple3D : Simple;
        switch (sprite.type) {
            case Type.SLICED:
                ctor = is3DNode ? Sliced3D : Sliced;
                break;
            case Type.TILED:
                ctor = is3DNode ? Tiled3D : Tiled;
                break;
            case Type.FILLED:
                if (sprite._fillType === FillType.RADIAL) {
                    ctor = is3DNode ? RadialFilled3D : RadialFilled;
                } else {
                    ctor = is3DNode ? BarFilled3D : BarFilled;
                }
                break;
            case Type.MESH:
                ctor = is3DNode ? Mesh3D : Mesh;
                break;
        }

        return ctor;
    },

    Simple,
    Sliced,
    Tiled,
    RadialFilled,
    BarFilled,
    Mesh,

    Simple3D,
    Sliced3D,
    Tiled3D,
    RadialFilled3D,
    BarFilled3D,
    Mesh3D,
};

Assembler.register(cc.Sprite, ctor);
</code></pre> 
<p>å¯ä»¥çœ‹åˆ°spriteç»„ä»¶ä¼šæ ¹æ®typeé€‰æ‹©å¯¹åº”çš„assembleræ¥ç»„è£…æ¸²æŸ“æ•°æ®ã€‚</p> 
<pre><code class="language-javascript">Assembler.register = function (renderCompCtor, assembler) {
    renderCompCtor.__assembler__ = assembler;
};</code></pre> 
<p>registerå‡½æ•°æ˜¯åˆå§‹åŒ–æ¸²æŸ“ç»„ä»¶çš„æ„é€ å‡½æ•°çš„__assembler__å±æ€§ï¼Œä»¥ä¾¿åæ¥çš„initå‡½æ•°èµ‹å€¼renderComp._assemblerÂ ,ä½ å¯èƒ½ä¼šé—®Assemblerçš„initå‡½æ•°åœ¨å“ªé‡Œæ‰§è¡Œçš„å‘¢ï¼Œä¸é”™è¿™ä¸ªinitå‡½æ•°æ˜¯åœ¨_resetAssemblerå‡½æ•°é‡Œé¢æ‰§è¡Œçš„ã€‚</p> 
<pre><code class="language-javascript">_resetAssembler() {
        Assembler.init(this);
        this._updateColor();
        this.setVertsDirty();
    },</code></pre> 
<p><strong>2ï¼šAssemblerçš„æ‰§è¡Œé¡ºåºæ˜¯æ€æ ·çš„Â </strong></p> 
<p>èŠå®Œäº†æ³¨å†Œå’Œåˆå§‹åŒ–ï¼Œæ¥ä¸‹æ¥çœ‹çœ‹ä¸€ä¸ªAssemblerå®ƒçš„æ‰§è¡Œé¡ºåºæ˜¯æ€ä¹ˆæ ·çš„ï¼Œæƒ³è¦äº†è§£è¿™äº›ä¹‹å‰æœ‰å¿…è¦çŸ¥é“Assembleréƒ½æœ‰å“ªäº›è·Ÿæ¸²æŸ“æœ‰å…³çš„æ–¹æ³•ï¼š</p> 
<pre><code class="language-javascript">export default class Assembler {
    constructor () {
        this._extendNative &amp;&amp; this._extendNative();
    }
    init (renderComp) {
        this._renderComp = renderComp;
    }
    
    updateRenderData (comp) {
    }

    fillBuffers (comp, renderer) {
    }
    
    getVfmt () {
        return vfmtPosUvColor;
    }
}</code></pre> 
<pre><code class="language-javascript">import Assembler from './assembler';
import dynamicAtlasManager from './utils/dynamic-atlas/manager';
import RenderData from './webgl/render-data';

export default class Assembler2D extends Assembler {
    constructor() {
        super();

        this._renderData = new RenderData();
        this._renderData.init(this);

        this.initData();
        this.initLocal();
    }

    get verticesFloats() {
        // verticesCount é¡¶ç‚¹ä¸ªæ•°
        // æ¯ä¸ªé¡¶ç‚¹æ•°æ®å‡ ä¸ªfloatæ•°æ® 5ä¸ª x,y,u,v,
        return this.verticesCount * this.floatsPerVert;
    }

    initData() {
        let data = this._renderData;
        data.createQuadData(0, this.verticesFloats, this.indicesCount);
    }
    initLocal() {
        this._local = [];
        this._local.length = 4;
    }

    updateColor(comp, color) {
        let uintVerts = this._renderData.uintVDatas[0];
        if (!uintVerts) return;
        color = color != null ? color : comp.node.color._val;
        let floatsPerVert = this.floatsPerVert;
        let colorOffset = this.colorOffset;
        for (let i = colorOffset, l = uintVerts.length; i &lt; l; i += floatsPerVert) {
            uintVerts[i] = color;
        }
    }

    getBuffer() {
        return cc.renderer._handle._meshBuffer;
    }

    updateWorldVerts(comp) {
        let local = this._local;
        let verts = this._renderData.vDatas[0];

        let matrix = comp.node._worldMatrix;
        let matrixm = matrix.m,
            a = matrixm[0], b = matrixm[1], c = matrixm[4], d = matrixm[5],
            tx = matrixm[12], ty = matrixm[13];

        let vl = local[0], vr = local[2],
            vb = local[1], vt = local[3];

        let floatsPerVert = this.floatsPerVert;
        let vertexOffset = 0;
        let justTranslate = a === 1 &amp;&amp; b === 0 &amp;&amp; c === 0 &amp;&amp; d === 1;

        if (justTranslate) {
            // left bottom
            verts[vertexOffset] = vl + tx;
            verts[vertexOffset + 1] = vb + ty;
            vertexOffset += floatsPerVert;
            // right bottom
            verts[vertexOffset] = vr + tx;
            verts[vertexOffset + 1] = vb + ty;
            vertexOffset += floatsPerVert;
            // left top
            verts[vertexOffset] = vl + tx;
            verts[vertexOffset + 1] = vt + ty;
            vertexOffset += floatsPerVert;
            // right top
            verts[vertexOffset] = vr + tx;
            verts[vertexOffset + 1] = vt + ty;
        } else {
            let al = a * vl, ar = a * vr,
                bl = b * vl, br = b * vr,
                cb = c * vb, ct = c * vt,
                db = d * vb, dt = d * vt;

            // left bottom
            verts[vertexOffset] = al + cb + tx;
            verts[vertexOffset + 1] = bl + db + ty;
            vertexOffset += floatsPerVert;
            // right bottom
            verts[vertexOffset] = ar + cb + tx;
            verts[vertexOffset + 1] = br + db + ty;
            vertexOffset += floatsPerVert;
            // left top
            verts[vertexOffset] = al + ct + tx;
            verts[vertexOffset + 1] = bl + dt + ty;
            vertexOffset += floatsPerVert;
            // right top
            verts[vertexOffset] = ar + ct + tx;
            verts[vertexOffset + 1] = br + dt + ty;
        }
    }

    // å¡«å…… meshBuffer
    fillBuffers(comp, renderer) {
        if (renderer.worldMatDirty) {
            this.updateWorldVerts(comp);
        }

        let renderData = this._renderData;
        let vData = renderData.vDatas[0];
        let iData = renderData.iDatas[0];

        let buffer = this.getBuffer(renderer);
        let offsetInfo = buffer.request(this.verticesCount, this.indicesCount);

        // buffer data may be realloc, need get reference after request.

        // fill vertices å¡«å……meshBufferä¸­çš„é¡¶ç‚¹æ•°æ®
        let vertexOffset = offsetInfo.byteOffset &gt;&gt; 2,
            vbuf = buffer._vData;

        if (vData.length + vertexOffset &gt; vbuf.length) {
            vbuf.set(vData.subarray(0, vbuf.length - vertexOffset), vertexOffset);
        } else {
            vbuf.set(vData, vertexOffset);
        }

        // fill indices å¡«å……meshBufferä¸­çš„é¡¶ç‚¹ç´¢å¼•æ•°ç»„
        let ibuf = buffer._iData,
            indiceOffset = offsetInfo.indiceOffset,
            vertexId = offsetInfo.vertexOffset;
        for (let i = 0, l = iData.length; i &lt; l; i++) {
            ibuf[indiceOffset++] = vertexId + iData[i];
        }
    }

    packToDynamicAtlas(comp, frame) {
        if (CC_TEST) return;

        if (!frame._original &amp;&amp; dynamicAtlasManager &amp;&amp; frame._texture.packable &amp;&amp; frame._texture.loaded) {
            let packedFrame = dynamicAtlasManager.insertSpriteFrame(frame);
            if (packedFrame) {
                frame._setDynamicAtlasFrame(packedFrame);
            }
        }
        let material = comp._materials[0];
        if (!material) return;

        if (material.getProperty('texture') !== frame._texture._texture) {
            // texture was packed to dynamic atlas, should update uvs
            comp._vertsDirty = true;
            comp._updateMaterial();
        }
    }
}

cc.js.addon(Assembler2D.prototype, {
    floatsPerVert: 5,

    verticesCount: 4,
    indicesCount: 6,

    uvOffset: 2,
    colorOffset: 4,
});

cc.Assembler2D = Assembler2D;
</code></pre> 
<p>Assemblerçš„ä¸»è¦å‡ ä¸ªæ–¹æ³•ï¼šupdateUVs,updateRenderDataÂ ,updateVerts,updateWorldVerts,fillBuffers,updateColor,initData,initLocal</p> 
<p>é‚£ä¹ˆæ¥ä¸‹æ¥çœ‹çœ‹ä»–ä»¬çš„ä½œç”¨ï¼Œ</p> 
<p><strong>a: initDataï¼š æ˜¯åˆ›å»ºæ¸²æŸ“æ‰€éœ€è¦çš„æ•°æ®</strong></p> 
<p>åˆ†ä¸º4ä¸ªé¡¶ç‚¹æ•°æ®å’Œ6ä¸ªé¡¶ç‚¹ç´¢å¼•æ•°æ®ï¼Œå¹¶ä¸”åˆå§‹åŒ–6ä¸ªé¡¶ç‚¹æ•°æ®çš„å€¼ä¸€èˆ¬æ˜¯ï¼ˆ0,1,2ï¼‰ï¼ˆ1,3,2ï¼‰ï¼Œå¦‚æœæƒ³è¦ä¸ªæ€§åŒ–ä¿®æ”¹å›¾ç‰‡çš„è¾¹æ•°å¯ä»¥å†è¿™é‡Œè¿›è¡Œé‡å†™ä¿®æ”¹</p> 
<p><strong>bï¼šinitLocal: åˆå§‹åŒ–èŠ‚ç‚¹çš„æœ¬åœ°åæ ‡ï¼ˆ4ä¸ªåæ ‡ï¼Œåˆ†åˆ«æ˜¯å·¦ä¸‹ï¼Œå³ä¸‹ï¼Œå·¦ä¸Šï¼Œå³ä¸Šçš„åæ ‡ï¼‰æ•°ç»„</strong></p> 
<p>initData,initLocalåœ¨Assembleræ„é€ å‡½æ•°ä¸­å®Œæˆã€‚</p> 
<p>æ›´æ–°é¡¶ç‚¹æ•°æ®å’Œuvæ•°æ®æ˜¯åœ¨ä»€ä¹ˆæ—¶å€™è°ƒç”¨çš„å‘¢ï¼Œé¦–å…ˆæƒ³ä¸€æƒ³ä»€ä¹ˆæ—¶å€™æ‰èƒ½è§¦å‘æ›´æ–°è¿™äº›æ•°æ®çš„æ—¶å€™ï¼Œå¦‚æœä¸€ä¸ªèŠ‚ç‚¹æ¸²æŸ“æ•°æ®æ²¡æœ‰å˜åŒ–è‚¯å®šä¸ä¼šè§¦å‘è¿™äº›æ“ä½œï¼Œåªæœ‰éœ€è¦æ›´æ–°æ¸²æŸ“æ•°æ®çš„æ—¶å€™æ‰ä¼šè§¦å‘ã€‚updateRenderDataæ˜¯è§¦å‘çš„æ¡ä»¶</p> 
<pre><code class="language-javascript">protected updateRenderData(comp: cc.RenderComponent) {
        if (comp._vertsDirty) {
            this.updateUVs(comp);
            this.updateVerts(comp);

            comp._vertsDirty = false;
        }
    }</code></pre> 
<p>æ¥ç€å°±æ˜¯updateRenderDataçš„è°ƒç”¨æ—¶æœºï¼Œè¯´èµ·è¿™ä¸ªçš„è°ƒç”¨æ—¶æœºå®ƒè·Ÿrender-flowæœ‰ç€åƒä¸ä¸‡ç¼•çš„è”ç³»ï¼Œè®²åˆ°render-flowä¹‹å‰Â å¯ä»¥çœ‹çœ‹æˆ‘ä¹‹å‰å†™çš„render-flowæ¸²æŸ“æµçš„ç« èŠ‚ï¼Œç®€å•çš„è¯´å°±æ˜¯æ ¹æ®äºŒè¿›åˆ¶çš„æ ‡å¿—ä½è¿›è¡Œæ¸²æŸ“çš„åˆ‡æ¢ï¼Œä¸€èˆ¬çš„æ¸²æŸ“é“¾æ¡ä¸€èˆ¬æ˜¯ï¼šnull -&gt; Final -&gt; postRender-&gt;children-&gt;render -&gt; Opacity_color -&gt; color -&gt; Opacity -&gt; updateRenderData -&gt; Transform -&gt; WorldTransform -&gt; localTransform,è¿™é‡Œçš„updateRenderDataæ ‡å¿—ä½ä¸º1çš„æ—¶å€™å°±ä¼šè§¦å‘ ä¸Šè¿°çš„updateRenderDataå‡½æ•°</p> 
<pre><code class="language-javascript">_proto._updateRenderData = function (node) {
    let comp = node._renderComponent;
    // è¿™ä¸ªå°±æ˜¯assemblerçš„æ›´æ–°æ¸²æŸ“å‡½æ•°äº†
    comp._assembler.updateRenderData(comp);
    // æ¸²æŸ“ä¹‹å‰çš„_renderFlagæ˜¯éœ€è¦update_render_data,è¿™é‡Œçš„æ“ä½œæ˜¯æ‰§è¡Œå®ŒupdateRenderDataå‡½æ•°ä¹‹åéœ€è¦å°†ä¹‹å‰çš„æ ‡å¿—ä½å–åä¹Ÿå°±æ˜¯è¯æ˜è¯¥æ“ä½œæ‰§è¡Œå®Œæ¯•äº†
    node._renderFlag &amp;= ~UPDATE_RENDER_DATA;
    // è½¬å…¥ä¸‹ä¸€ä¸ªæµç¨‹
    this._next._func(node);
};</code></pre> 
<p>Â ä¸¾ä¸€åä¸‰ç±»ä¼¼çš„updateColoræ˜¯åœ¨coloræ ‡å¿—ä½ä¸º1çš„æ—¶å€™è§¦å‘ï¼š</p> 
<pre><code class="language-javascript">_proto._color = function (node) {
    let comp = node._renderComponent;
    if (comp) {
        comp._updateColor();
    }

    node._renderFlag &amp;= ~COLOR;
    this._next._func(node);
};</code></pre> 
<p>Â ç›¸åº”çš„fillBuffersçš„æ‰§è¡Œæ—¶æœºï¼šrenderæ ‡å¿—ä½ä¸º1çš„æ—¶å€™è§¦å‘ï¼Œæ¯å¸§æ‰§è¡Œ</p> 
<pre><code class="language-javascript">_proto._render = function (node) {
    let comp = node._renderComponent;
    // æ£€æŸ¥åˆæ‰¹
    comp._checkBacth(_batcher, node._cullingMask);
    // å¡«å……ç¼“å†²åŒº meshBuffer
    comp._assembler.fillBuffers(comp, _batcher);
    // è½¬å…¥ä¸‹ä¸€ä¸ªæµç¨‹ children æˆ–è€…æ˜¯postRender
    this._next._func(node);
};</code></pre> 
<p>Â æäº¤æ¸²æŸ“æ•°æ®æµç¨‹æ—¶æœºï¼š</p> 
<pre><code class="language-javascript">_proto._postRender = function (node) {
    let comp = node._renderComponent;
    // æ£€æŸ¥æ˜¯å¦å¯ä»¥åˆæ‰¹
    comp._checkBacth(_batcher, node._cullingMask);
    comp._assembler.postFillBuffers(comp, _batcher);
    this._next._func(node);
};</code></pre> 
<p>Â è®²äº†è¿™ä¹ˆå¤šæ˜¯æ—¶å€™æ‹¿ä¸ªä¾‹å­ğŸŒ°æ¥çœ‹çœ‹äº†ã€‚</p> 
<h2><strong>äºŒï¼šè‡ªå®šä¹‰ä¸€ä¸ªæ¸²æŸ“ç»„ä»¶ï¼ˆä½¿ç”¨è‡ªå®šä¹‰çš„assembleræŒ‚è½½ï¼‰</strong></h2> 
<p>æœ‰è¿™ä¹ˆä¸ªéœ€æ±‚å°±æ˜¯é˜²æ­¢èŠ‚ç‚¹ç»“æ„åˆæ‰¹è¢«æ‰“ä¹±ï¼Œè‡ªå·±å®ç°ä¸€ä¸ªæ¸²æŸ“ç»„ä»¶æ¥æ”¹å–„è¿™ç§æƒ…å†µã€‚æˆ‘ä¹‹å‰çš„åšæ³•æ˜¯å›¾ç‰‡å’Œå›¾ç‰‡æ”¾åˆ°ä¸€èµ·ï¼Œlabelå’Œlabelæ”¾åˆ°ä¸€èµ·ï¼Œè¿™æ ·å°±èƒ½è¾¾åˆ°åˆæ‰¹çš„ç›®çš„ï¼Œä½†æ˜¯è¿™æ ·åšçš„ç»“æœå°±æ˜¯ä»£ç ç»„ç»‡å°±å˜å¾—å¾ˆæ²¡æœ‰ç»“æ„æ€§ï¼Œæœ€å¥½çš„åŠæ³•æ˜¯æ—¢èƒ½ä¿æŒèŠ‚ç‚¹ç»“æ„åˆèƒ½è¾¾åˆ°è½»æ¾åˆæ‰¹çš„æ•ˆæœã€‚ä¹‹æ‰€ä»¥åˆæ‰¹è¢«æ‰“ä¹±çš„åŸå› å°±æ˜¯èŠ‚ç‚¹éå†cocosé»˜è®¤æ˜¯æ·±åº¦ä¼˜å…ˆéå†ï¼Œå¾ˆå®¹æ˜“å°±ä¼šé€ æˆèŠ‚ç‚¹åˆæ‰¹è¢«æ‰“ä¹±ã€‚æ­¤æ¬¡ä¼˜åŒ–æ–¹æ¡ˆï¼ˆèŠ‚ç‚¹é‡‡ç”¨å¹¿åº¦ä¼˜å…ˆéå†çš„æ–¹æ³•ï¼‰ä¹Ÿæ˜¯è®ºå›çš„å¤§ç¥æä¾›çš„æ€è·¯ï¼Œåœ¨æ­¤æ¬ç –åˆ†äº«ç»™å„ä½æ°´å‹ã€‚</p> 
<p><strong>1ï¼šå®šä¹‰è‡ªå·±çš„MyAssembler2D,ç†è§£è¿™ä¸ªä¹‹å‰ä¸€å®šè¦çŸ¥é“æ¸²æŸ“æ•°æ®çš„æ„æˆï¼Œæ³¨é‡Šé‡Œé¢è¯¦ç»†çš„è§£é‡Šäº†</strong></p> 
<pre><code class="language-javascript">
/**
 * 
 * è‡ªå®šä¹‰æ¸²æŸ“æ•°æ®
 * æ¯ä¸ª2dæ¸²æŸ“æ•°æ®é‡Œé¢æœ‰ 
 * 4ä¸ªé¡¶ç‚¹å±æ€§æ•°æ® ä¸ºä»€ä¹ˆæ˜¯4ä¸ªæ˜¯å› ä¸ºä¸€ä¸ªå››è¾¹å½¢ç”±å››ä¸ªé¡¶ç‚¹
 * 6ä¸ªé¡¶ç‚¹ç´¢å¼• -&gt; (ä¸€ä¸ªå››è¾¹å½¢ç”±ä¸¤ä¸ªä¸‰è§’å½¢ç»„æˆ)
 * 
 * 
 * æ¯ä¸ªé¡¶ç‚¹æ•°æ®æ ¼å¼ï¼š
 * | x | y | u | v | r | g | b | a | ....
 *   4   4   4   4   1   1   1   1    ï¼ˆä¸€ä¸ªé¡¶ç‚¹æ€»å…±20ä¸ªå­—èŠ‚çš„æ•°æ®ï¼‰
 * 
 * å…¶ä¸­uvæ•°æ®åç§»æ˜¯2ä¸ªå•ä½ï¼Œcolorçš„åç§»æ˜¯4ä¸ªå•ä½
 * 
 */
export default class MyAssembler2D extends cc.Assembler {
    /** é¡¶ç‚¹æ•°æ®ä¸ªæ•° */
    public verticesCount = 4;
    /** é¡¶ç‚¹ç´¢å¼•ä¸ªæ•° */
    public indicesCount = 6;
    /** æ¯ä¸ªé¡¶ç‚¹æ•°æ®æœ‰å‡ ä¸ªfloat32ä½çš„å€¼ */
    public floatsPerVert = 5;

    /** uvåç§»é‡ä½2ä¸ªå•ä½ */
    public uvOffset = 2;
    public colorOffset = 4;

    protected _renderData: cc.RenderData;
    protected _local: any = null;

    init(comp: cc.RenderComponent) {
        super.init(comp);

        this._renderData = new cc.RenderData();
        /** è¿™é‡Œçš„åˆå§‹åŒ–ï¼Ÿ */
        this._renderData.init(this);

        this.initLocal();
        this.initData();
    }

    get verticesFloats() {
        return this.verticesCount * this.floatsPerVert;
    }

    initData() {
        let data = this._renderData;
        data.createQuadData(0, this.verticesFloats, this.indicesCount);
    }

    initLocal() {
        this._local = [];
        this._local.length = 4;
    }

    /**
     * æ›´æ–°èŠ‚ç‚¹çš„é¢œè‰²
     * @param  {cc.RenderComponent} comp
     * @param  {any} color
     */
    updateColor(comp: cc.RenderComponent, color: any) {
        if (!this._renderData.uintVDatas) {
            if (CC_EDITOR) {
                Editor.log("uintVDatas is undefined");
            }
            return;
        }
        if (CC_EDITOR) {
            Editor.log("unitVDatas is ", this._renderData.uintVDatas);
        }
        let uintVerts = this._renderData.uintVDatas[0];
        if (!uintVerts) {
            if (CC_EDITOR) {
                Editor.warn("uintVerts is null");
                return;
            }
        };
        // @ts-ignore
        color = color != null ? color : comp.node.color._val;
        let floatsPerVert = this.floatsPerVert;
        let colorOffset = this.colorOffset;

        for (let i = colorOffset, l = uintVerts.length; i &lt; l; i += floatsPerVert) {
            uintVerts[i] = color;
        }
        if (CC_EDITOR) {
            Editor.log("verts is ", uintVerts);
        }
    }

    getBuffer() {
        // @ts-ignore
        return cc.renderer._handle._meshBuffer;
    }

    /** æ›´æ–°é¡¶ç‚¹æ•°æ®åˆ°ä¸–ç•Œåæ ‡ç³» */
    updateWorldVerts(comp) {
        if (CC_NATIVERENDERER) {
            this.updateWorldVertsNative(comp);
        } else {
            this.updateWorldVertsWebGL(comp);
        }
    }

    updateWorldVertsNative(comp: cc.RenderComponent) {
        let local = this._local;
        let verts = this._renderData.vDatas[0];
        let floatsPerVert = this.floatsPerVert;

        let l = local[0], r = local[1], b = local[2], t = local[3];
        let index = 0;
        // left bottom 
        verts[index] = l;
        verts[index + 1] = b;
        index += floatsPerVert;

        // right bottom
        verts[index] = r;
        verts[index + 1] = b;
        index += floatsPerVert;

        // left top
        verts[index] = l;
        verts[index + 1] = t;
        index += floatsPerVert;

        // right top
        verts[index] = r;
        verts[index + 1] = t;
    }


    /**
     * æ›´æ–°webGLå¹³å°ä¸–ç•Œåæ ‡ cocos é‡‡ç”¨è¡Œå‘é‡çš„æ–¹å¼(ä¼˜ç‚¹ï¼š ç›´æ¥æ•°ç»„æ“ä½œ)æ¥ä¸çŸ©é˜µè¿ç®—çš„ M * V(åˆ—å¼å‘é‡) V(è¡Œå¼å‘é‡) * M
     * @param  {cc.RenderComponent} comp
     */
    updateWorldVertsWebGL(comp: cc.RenderComponent) {
        if (CC_EDITOR) {
            Editor.warn("updateWorldVerts");
        }
        let local = this._local;
        // é¡¶ç‚¹æ•°æ®
        let verts = this._renderData.vDatas[0];

        // @ts-ignore èŠ‚ç‚¹çš„ä¸–ç•ŒçŸ©é˜µ
        let matrix = comp.node._worldMatrix;
        let m = matrix.m,
            a = m[0], b = m[1], c = m[4], d = m[5],
            tx = m[12], ty = m[13];

        // a, d ç¼©æ”¾å› å­å‚æ•°  b,c æ–œåˆ‡å› å­å‚æ•°    

        let vl = local[0], vr = local[2],
            vb = local[1], vt = local[3];

        /*                         
                                                 -          -
            m00 = 1, m01 = 0, m02 = 0, m03 = 0, | 1  0  0  0 |
            m04 = 0, m05 = 1, m06 = 0, m07 = 0, | 0  1  0  0 |
            m08 = 0, m09 = 0, m10 = 1, m11 = 0, | 0  0  1  0 |
            m12 = 0, m13 = 0, m14 = 0, m15 = 1  | 0  0  0  1 |
                                                 -          -
        */

        let justTranslate = a === 1 &amp;&amp; d === 1 &amp;&amp; b === 0 &amp;&amp; c === 0;
        let index = 0;
        let floatsPerVert = this.floatsPerVert;

        if (CC_EDITOR) {
            Editor.warn("justTranslate is ", justTranslate);
        }

        if (justTranslate) {
            // left bottom
            verts[index] = vl + tx;
            verts[index + 1] = vb + ty;
            index += floatsPerVert;

            // right bottom
            verts[index] = vr + tx;
            verts[index + 1] = vb + ty;
            index += floatsPerVert;

            // left top
            verts[index] = vl + tx;
            verts[index + 1] = vt + ty;
            index += floatsPerVert;

            // right top
            verts[index] = vr + tx;
            verts[index + 1] = vt + ty;

        } else {
            // æ ¹æ®çŸ©é˜µè¿ç®—è§„åˆ™ ã€x,y,z,wã€‘* Må¯ä»¥å¾—åˆ°ä»¥ä¸‹ç»“æœ
            /**            -            -
             *            |  a  b  0  0  |
             *            |  c  d  0  0  |
             *[x,y,z,1] * |  0  0  1  0  | = ã€a*x + cy + tx,bx + dy + ty,0,1ã€‘
             *            | tx  ty 0  1  |
             *             -            -
             */
            // left bottom
            verts[index] = vl * a + c * vb + tx;
            verts[index + 1] = vl * b + d * vb + ty;
            index += floatsPerVert;

            // right bottom 
            verts[index] = vr * a + c * vb + tx;
            verts[index + 1] = vr * b + d * vb + ty;
            index += floatsPerVert;

            // left top
            verts[index] = vl * a + c * vt + tx;
            verts[index + 1] = vl * b + d * vt + ty;
            index += floatsPerVert;

            // right top
            verts[index] = vr * a + c * vt + tx;
            verts[index + 1] = vr * b + d * vt * ty;
        }
    }

    packToDynamicAtlas(comp: cc.RenderComponent, frame: any) {
        if (CC_TEST) return;
        if (!frame._original &amp;&amp; cc.dynamicAtlasManager &amp;&amp; frame._texture.packable) {
            let packedFrame = cc.dynamicAtlasManager.insertSpriteFrame(frame);
            // @ts-ignore
            if (packedFrame) {
                frame._setDynamicAtlasFrame(packedFrame);
            }
        }
        // @ts-ignore
        let material = comp._materials[0];
        if (!material) return;
        if (material.getProperty('texture') !== frame._texture) {
            // @ts-ignore
            comp._vertsDirty = true;
            // @ts-ignore
            comp._updateMaterial();
        }
    }

    protected updateUVs(comp: cc.RenderComponent) {
        if (CC_EDITOR) {
            Editor.warn("updateUVS...");
        }
        // 4ä¸ªé¡¶ç‚¹çš„uvåæ ‡ å¯¹åº”å·¦ä¸‹ï¼Œå³ä¸‹ï¼Œå·¦ä¸Šï¼Œå³ä¸Š
        let uv = [0, 0, 1, 0, 0, 1, 1, 1];

        // if (comp instanceof cc.Sprite) {
        //     // @ts-ignore
        //     uv = comp._spriteFrame.uv;
        // }
        let uvOffset = this.uvOffset;
        let floatsPerVert = this.floatsPerVert;
        let verts = this._renderData.vDatas[0];

        for (let i = 0; i &lt; 4; i++) {
            let srcOffset = i * 2;
            let dstOffset = floatsPerVert * i + uvOffset;
            verts[dstOffset] = uv[srcOffset];
            verts[dstOffset + 1] = uv[srcOffset + 1];
        }
    }

    // æ¯å¸§è°ƒç”¨
    public fillBuffers(comp: cc.RenderComponent, render: cc.ModelBatcher) {
        if (CC_EDITOR) {
            // Editor.warn("fillBuffers...");
        }
        // if(r)
        if (render.worldMatDirty) {
            this.updateWorldVerts(comp);
        }
        let renderData = this._renderData;
        let vData = renderData.vDatas[0];
        let iData = renderData.iDatas[0];
        // è·å–meshBuffer
        let buffer = this.getBuffer();
        let offsetInfo = buffer.request(this.verticesCount, this.indicesCount);

        let vertexOffset = offsetInfo.byteOffset &gt;&gt; 2,
            vbuf = buffer._vData;

        if (vData.length + vertexOffset &gt; vbuf.length) {
            vbuf.set(vData.subarray(0, vbuf.length - vertexOffset), vertexOffset);
        } else {
            vbuf.set(vData, vertexOffset);
        }

        let ibuf = buffer._iData, indiceOffset = offsetInfo.indiceOffset, vertexId = offsetInfo.vertexOffset;
        for (let i = 0, l = iData.length; i &lt; l; i++) {
            ibuf[indiceOffset++] = vertexId + iData[i];
        }


    }

    protected updateVerts(comp: cc.RenderComponent) {
        if (CC_EDITOR) {
            Editor.warn("updateVerts...");
        }
        let node: cc.Node = comp.node,
            cw = node.width,
            ch = node.height,
            // (é”šç‚¹x * cw,é”šç‚¹y * ch)
            appx = node.anchorX * cw,
            appy = node.anchorY * ch,
            l, b, r, t;

        // å·¦è¾¹ç•Œ
        l = -appx;
        // ä¸‹è¾¹ç•Œ
        b = -appy;
        // å³è¾¹ç•Œ
        r = cw - appx;
        // ä¸Šè¾¹ç•Œ
        t = ch - appy;

        this._local[0] = l;
        this._local[1] = b;
        this._local[2] = r;
        this._local[3] = t;

        this.updateWorldVerts(comp);
    }

    protected updateRenderData(comp: cc.RenderComponent) {
        if (comp._vertsDirty) {
            this.updateUVs(comp);
            this.updateVerts(comp);

            comp._vertsDirty = false;
        }
    }
}</code></pre> 
<p><strong>2ï¼šå®šä¹‰è‡ªå·±çš„MySpriteAssembler2D</strong></p> 
<pre><code class="language-javascript">import MyAssembler2D from "./MyAssembler2D";

export default class MySimpleSpriteAssembler2D extends MyAssembler2D {

    protected updateRenderData(sprite: cc.Sprite) {
        // @ts-ignore
        this.packToDynamicAtlas(sprite, sprite._spriteFrame);
        super.updateRenderData(sprite);
    }

    /**
     * å°†å›¾ç‰‡çš„uvæ•°æ®å¤åˆ¶åˆ° renderData.vDataä¸­
     * @param  {cc.Sprite} sprite
     * @returns void
     */
    updateUVs(sprite: cc.Sprite): void {
        if (CC_EDITOR) {
            Editor.log("updateUVs...");
        }
        // @ts-ignore
        let uv = sprite._spriteFrame.uv;
        let uvOffset = this.uvOffset;
        let floatsPerVert = this.floatsPerVert;
        let verts = this._renderData.vDatas[0];
        for (let i = 0; i &lt; 4; i++) {
            let srcOffset = i * 2;
            let dstOffset = floatsPerVert * i + uvOffset;
            verts[dstOffset] = uv[srcOffset];
            verts[dstOffset + 1] = uv[srcOffset + 1];
        }
    }

    /**
     * æ›´æ–°å›¾ç‰‡çš„æ¸²æŸ“é¡¶ç‚¹æ•°æ®
     * @param  {cc.Sprite} sprite
     * @returns void
     */
    protected updateVerts(sprite: cc.Sprite): void {
        if (CC_EDITOR) {
            Editor.log("updateVerts ");
        }
        let node = sprite.node,
            cw = node.width, ch = node.height,
            appx = node.anchorX * cw, appy = node.anchorY * ch, l, b, r, t;
        if (sprite.trim) {
            l = -appx;
            b = -appy;
            r = cw - appx;
            t = ch - appy;
        } else {
            let frame = sprite.spriteFrame,
                // @ts-ignore
                ow = frame._originalSize.width, oh = frame._originalSize.height,
                // @ts-ignore
                rw = frame._rect.width, rh = frame._rect.height,
                // @ts-ignore
                offset = frame._offset, scaleX = cw / ow, scaleY = ch / oh;

            let trimLeft = offset.x + (ow - rw) / 2;
            let trimRight = offset.x - (ow - rw) / 2;
            let trimBottom = offset.y + (oh - rh) / 2;
            let trimTop = offset.y - (oh - rh) / 2;

            l = trimLeft * scaleX - appx;
            b = trimBottom * scaleY - appy;

            r = trimRight * scaleX + cw - appx;
            t = trimTop * scaleY + ch - appy;
        }

        this._local[0] = l;
        this._local[1] = b;
        this._local[2] = r;
        this._local[3] = t;
        this.updateWorldVerts(sprite);
    }
}</code></pre> 
<p>Â 3<strong>ï¼šå®šä¹‰è‡ªå·±çš„åˆæ‰¹Assembler: BatchAssembler2D</strong></p> 
<pre><code class="language-javascript">import { recordData } from "../../bingoslots/scripts/server_data/MockData";
import MySimpleSpriteAssembler2D from "./MySimpleSpriteAssembler2D";

/**
 * 
 * åˆ†å±‚åˆæ‰¹å¤„ç†assemblerï¼ˆå¼•æ“å†…ç½®ä¸ºæ·±åº¦éå†çš„æ–¹å¼ä¸æ–¹ä¾¿åˆæ‰¹å¤„ç†ï¼‰
 * 
 */
// @ts-ignore æ¸²æŸ“æ©ç ç”¨äºæ£€æµ‹å½“å‰èŠ‚ç‚¹çš„æ¸²æŸ“æ ‡å¿—ä½æ˜¯å¦å«æœ‰ renderå’ŒpostRenderæ ‡å¿—ä½
const RENDER_MASK = cc.RenderFlow.FLAG_RENDER | cc.RenderFlow.FLAG_POST_RENDER;
// @ts-ignore é€æ˜åº¦æ©ç ç”¨äºæ£€æµ‹å½“å‰èŠ‚ç‚¹çš„æ¸²æŸ“æ ‡å¿—ä½æ˜¯å¦å«æœ‰ Opacity å’ŒWorldTransformæ ‡å¿—ä½
const PROP_DIRTY_MASK = cc.RenderFlow.FLAG_OPACITY | cc.RenderFlow.FLAG_WORLD_TRANSFORM;

let BATCH_OPTIMIZE_SWITCH: boolean = true;

export default class BatchingAssembler2D extends MySimpleSpriteAssembler2D {
    protected _layers: any[];

    fillBuffers(comp: cc.RenderComponent, render: cc.ModelBatcher) {
        super.fillBuffers(comp, render);

        if (CC_EDITOR || CC_NATIVERENDERER) return;
        if (!BATCH_OPTIMIZE_SWITCH) return;


        let layer = [];
        this._layers = [layer];

        // @ts-ignore
        let worldTransformFlag = render.worldMatDirty ? cc.RenderFlow.FLAG_WORLD_TRANSFORM : 0;
        // @ts-ignore
        let worldOpacityFlag = render.parentOpacityDirty ? cc.RenderFlow.FLAG_OPACITY_COLOR : 0;
        let dirtyFlag = worldTransformFlag | worldOpacityFlag;

        comp.node['__myDirtyFlag'] = dirtyFlag;

        // å¹¿åº¦ä¼˜å…ˆéå†
        let queue: cc.Node[] = [];
        queue.push(comp.node);

        let depth = 0, end = 1, iter = 0;
        let myRenderFlag;
        while (iter &lt; queue.length) {
            let node = queue[iter++];
            dirtyFlag = node['__myDirtyFlag'];

            for (let c of node.children) {
                // @ts-ignore
                if (!c._activeInHierarchy || c.opacity == 0) {
                    continue;
                }
                // @ts-ignore
                myRenderFlag = c._renderFlag &amp; RENDER_MASK;
                if (myRenderFlag &gt; 0) {
                    // æºå¸¦äº†æ¸²æŸ“çš„æ ‡å¿—ä½
                    // ç§»é™¤å­èŠ‚ç‚¹çš„renderFlag,æ˜¯renderFlowä¸æ‰§è¡Œå®ƒçš„renderå‡½æ•°
                    c["__myRenderFlag"] = myRenderFlag;
                    // @ts-ignore ç§»é™¤ä¹‹å‰æœ‰çš„æ¸²æŸ“æ ‡å¿—ä½
                    c._renderFlag &amp;= ~myRenderFlag;
                    // å°†æœ¬æ¥æœ‰æ¸²æŸ“æ ‡å¿—ä½çš„èŠ‚ç‚¹ç»™åŠ å…¥åˆ°å±‚çº§é˜Ÿåˆ—é‡Œé¢
                    layer.push(c);
                }
                // @ts-ignore é€å±‚ä¼ é€’çˆ¶èŠ‚ç‚¹çš„dirtyFlag
                c["__myDirtyFlag"] = dirtyFlag | (c._renderFlag &amp; PROP_DIRTY_MASK);
                // å°†éå†çš„å­èŠ‚ç‚¹æ¨å…¥é˜Ÿåˆ—
                queue.push(c);
            }

            if (iter == end) {
                ++depth;
                end = queue.length;
                layer = [];
                this._layers.push(layer);
            }
        }
        if (CC_EDITOR) {
            Editor.log("layers is ", this._layers);
        }
        console.log("layers is ", this._layers);
    }

    postFillBuffers(comp: cc.RenderComponent, render: cc.ModelBatcher) {
        if (CC_EDITOR) {
            // Editor.log("postFillbuffers");
        }
        let originWorldMatDirty = render.worldMatDirty;
        if (!BATCH_OPTIMIZE_SWITCH || !this._layers) return;

        BATCH_OPTIMIZE_SWITCH = false;
        let myRenderFlag, myDirtyFlag;

        for (let layer of this._layers) {
            if (layer.length == 0) {
                continue;
            }
            for (let c of layer) {
                myRenderFlag = c['__myRenderFlag'];
                myDirtyFlag = c['__myDirtyFlag'];

                render.worldMatDirty = myDirtyFlag &gt; 0 ? 1 : 0;
                // è¿˜åŸä¹‹å‰è¢«ä¿®æ”¹çš„æ ‡å¿—ä½
                c._renderFlag |= myRenderFlag;
                // @ts-ignore
                cc.RenderFlow.flows[myRenderFlag]._func(c);
            }
        }

        this._layers = null;
        BATCH_OPTIMIZE_SWITCH = true;
        render.worldMatDirty = originWorldMatDirty;
    }


}</code></pre> 
<p>Â 4<strong>ï¼šå®šä¹‰è‡ªå·±çš„åˆæ‰¹æ¸²æŸ“ç»„ä»¶ï¼šLayeredBatchingSprite</strong></p> 
<pre><code class="language-javascript">import BatchingAssembler2D from "./BatchingAssembler2D";
import MySimpleSpriteAssembler2D from "./MySimpleSpriteAssembler2D";

const { ccclass } = cc._decorator;

@ccclass
export default class LayeredBatchingSprite extends cc.Sprite {
    protected onEnable(): void {
        super.onEnable();
        if (!CC_EDITOR || !CC_NATIVERENDERER) {
            // @ts-ignore æ·»åŠ ä¸€ä¸ªpostRender æ¸²æŸ“æ ‡å¿—ä½ æ¥æ‰§è¡Œ postFillBuffers
            this.node._renderFlag |= cc.RenderFlow.FLAG_POST_RENDER;
        }
    }

    _resetAssembler() {
        this.setVertsDirty();
        let assembler = this._assembler = new BatchingAssembler2D();
        assembler.init(this);
    }
}</code></pre> 
<p>è‡³æ­¤ä¸€ä¸ªå¹¿åº¦ä¼˜å…ˆéå†çš„èŠ‚ç‚¹åˆæ‰¹æ–¹æ¡ˆå®Œæˆï¼Œå¸Œæœ›ç»™ç»™ä¸ºæ°´å‹ä¸€ç‚¹å¯å‘Â </p> 
<p></p> 
<p></p> 
<p></p> 
<p></p> 
<p></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/ff880e27553cb80bed029b2f5ecbab81/" rel="prev">
			<span class="pager__subtitle">Â«&thinsp;Previous</span>
			<p class="pager__title">å¦‚ä½•æå®š CMake ä¾èµ–å…³ç³»ï¼Ÿï¼ˆå†—ä½™è¿˜æ˜¯ä¾èµ–ï¼Ÿ-å–å†³äºä½ çš„é€‰æ‹©ï¼‰</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/ce9f275c29d06e516626a20e09542f76/" rel="next">
			<span class="pager__subtitle">Next&thinsp;Â»</span>
			<p class="pager__title">ideaä¿®æ”¹é»˜è®¤ä½¿ç”¨çš„mavené…ç½®</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 ç¼–ç¨‹å¤§ç™½çš„åšå®¢.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>