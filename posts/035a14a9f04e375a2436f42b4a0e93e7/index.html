<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>使用 -Wl,rpath设置动态库的指定搜索路径 - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="使用 -Wl,rpath设置动态库的指定搜索路径" />
<meta property="og:description" content="工作中有时会遇到可执行程序运行时使用指定目录下的动态库，若是直接修改环境变量，可能会对其他程序产生影响，因此可以在编译时使用-Wl,rpath来指定运行时路径。
比如 /home/lib 下存在 libtest.so ， /home/test 下存在 test.c 和 libtest.so文件，编译出的可执行文件依赖动态库 libtest.so
/home |--lib -libtest.so |--test - test.c - libtest.so 假设想让可执行文件运行时使用lib下的动态库，可以使用如下命令
gcc -o test test.c -L./ libtest.so -Wl,-rpath=&#39;$ORIGIN/../lib&#39; 其中 -L./ libtest.so 表示编译时使用当前目录下的 libtest.so 进行编译
-Wl,-rpath=’$ORIGIN/…/lib’ 表示运行可执行文件时，从 …/lib 中寻找所需要的动态库。
可以使用ldd命令查看可执行程序的依赖
# ldd test libtest.so =&gt; /home/test/../lib/libtest.so 通过 ldd 命令可知，test 运行时使用的动态库路径为 /home/test/…/lib
还有一种情况是可执行程序test使用的动态库为 libtest.so 而编译时使用的是libtest.so.1.1
比如目录就结构如下
/home |--lib -libtest.so.1.1 |--test - test.c - libtest.so.1.1 编译生成可执行文件
gcc -o test test.c -L./ libtest.so.1.1 -Wl,-rpath=&#39;$ORIGIN/." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/035a14a9f04e375a2436f42b4a0e93e7/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2021-10-19T21:53:48+08:00" />
<meta property="article:modified_time" content="2021-10-19T21:53:48+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">使用 -Wl,rpath设置动态库的指定搜索路径</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p>工作中有时会遇到可执行程序运行时使用指定目录下的动态库，若是直接修改环境变量，可能会对其他程序产生影响，因此可以在编译时使用-Wl,rpath来指定运行时路径。</p> 
<p>比如 /home/lib 下存在 libtest.so ， /home/test 下存在 test.c 和 libtest.so文件，编译出的可执行文件依赖动态库 libtest.so</p> 
<pre><code class="prism language-c"><span class="token operator">/</span>home
  <span class="token operator">|</span><span class="token operator">--</span>lib
       <span class="token operator">-</span>libtest<span class="token punctuation">.</span>so  

  <span class="token operator">|</span><span class="token operator">--</span>test
       <span class="token operator">-</span> test<span class="token punctuation">.</span>c
       <span class="token operator">-</span> libtest<span class="token punctuation">.</span>so    
   
</code></pre> 
<p>假设想让可执行文件运行时使用lib下的动态库，可以使用如下命令</p> 
<pre><code class="prism language-c">gcc <span class="token operator">-</span>o test test<span class="token punctuation">.</span>c <span class="token operator">-</span>L<span class="token punctuation">.</span><span class="token operator">/</span> libtest<span class="token punctuation">.</span>so <span class="token operator">-</span>Wl<span class="token punctuation">,</span><span class="token operator">-</span>rpath<span class="token operator">=</span><span class="token string">'$ORIGIN/../lib'</span>
</code></pre> 
<p>其中 -L./ libtest.so 表示编译时使用当前目录下的 libtest.so 进行编译<br> -Wl,-rpath=’$ORIGIN/…/lib’ 表示运行可执行文件时，从 …/lib 中寻找所需要的动态库。</p> 
<p>可以使用ldd命令查看可执行程序的依赖</p> 
<pre><code class="prism language-c"><span class="token macro property"><span class="token directive-hash">#</span> <span class="token directive keyword">ldd</span> <span class="token expression">test</span></span>
  libtest<span class="token punctuation">.</span>so  <span class="token operator">=</span><span class="token operator">&gt;</span> <span class="token operator">/</span>home<span class="token operator">/</span>test<span class="token operator">/</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token operator">/</span>lib<span class="token operator">/</span>libtest<span class="token punctuation">.</span>so
</code></pre> 
<p>通过 ldd 命令可知，test 运行时使用的动态库路径为 /home/test/…/lib</p> 
<p>还有一种情况是可执行程序test使用的动态库为 libtest.so 而编译时使用的是libtest.so.1.1</p> 
<p>比如目录就结构如下</p> 
<pre><code class="prism language-c">
<span class="token operator">/</span>home
  <span class="token operator">|</span><span class="token operator">--</span>lib
       <span class="token operator">-</span>libtest<span class="token punctuation">.</span>so<span class="token punctuation">.</span><span class="token number">1.1</span>  

  <span class="token operator">|</span><span class="token operator">--</span>test
       <span class="token operator">-</span> test<span class="token punctuation">.</span>c
       <span class="token operator">-</span> libtest<span class="token punctuation">.</span>so<span class="token punctuation">.</span><span class="token number">1.1</span>

</code></pre> 
<p>编译生成可执行文件</p> 
<pre><code class="prism language-c">
gcc <span class="token operator">-</span>o test test<span class="token punctuation">.</span>c <span class="token operator">-</span>L<span class="token punctuation">.</span><span class="token operator">/</span> libtest<span class="token punctuation">.</span>so<span class="token punctuation">.</span><span class="token number">1.1</span> <span class="token operator">-</span>Wl<span class="token punctuation">,</span><span class="token operator">-</span>rpath<span class="token operator">=</span><span class="token string">'$ORIGIN/../lib'</span> 
</code></pre> 
<p>运行 ldd 时发现找不到动态库 libtest.so</p> 
<pre><code class="prism language-c"><span class="token macro property"><span class="token directive-hash">#</span> <span class="token directive keyword">ldd</span> <span class="token expression">test</span></span>
  libtest<span class="token punctuation">.</span>so  <span class="token operator">=</span><span class="token operator">&gt;</span> not found 
</code></pre> 
<p>原因是运行test时他需要的动态库的名字为libtest.so 而 lib 中存放的是libtest.so.1.1， 名字不一样，因此找不到动态库。</p> 
<p>解决办法</p> 
<p>1、可以把 lib 下的 libtest.so.1.1 名字改为 libtest.so</p> 
<p>2、也可以在 lib 下创建一个 libtest.so.1.1 的软连接</p> 
<pre><code class="prism language-c"><span class="token macro property"><span class="token directive-hash">#</span> <span class="token directive keyword">cd</span> <span class="token expression">lib</span></span>
<span class="token macro property"><span class="token directive-hash">#</span> <span class="token directive keyword">ln</span> <span class="token expression"><span class="token operator">-</span>s libtest<span class="token punctuation">.</span>so<span class="token punctuation">.</span><span class="token number">1.1</span> libtest<span class="token punctuation">.</span>so</span></span>
<span class="token macro property"><span class="token directive-hash">#</span> <span class="token directive keyword">ls</span></span>
 libtest<span class="token punctuation">.</span>so   libtest<span class="token punctuation">.</span>so<span class="token punctuation">.</span><span class="token number">1.1</span>

<span class="token macro property"><span class="token directive-hash">#</span> <span class="token directive keyword">ldd</span> <span class="token expression">test</span></span>
   libtest<span class="token punctuation">.</span>so  <span class="token operator">=</span><span class="token operator">&gt;</span> <span class="token operator">/</span>home<span class="token operator">/</span>test<span class="token operator">/</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token operator">/</span>lib<span class="token operator">/</span>libtest<span class="token punctuation">.</span>so
 
</code></pre> 
<p>附：<br> 我们编译程序时会常常遇到如下你几个参数<br> -I (大写的i)<br> -L (大写l)<br> -l (小写l)<br> 接下来对这几个参数进行简单的讲解。</p> 
<p>先举个例子：</p> 
<pre><code class="prism language-c">gcc <span class="token operator">-</span>o test test<span class="token punctuation">.</span>c <span class="token operator">-</span>I <span class="token operator">/</span>home<span class="token operator">/</span>test<span class="token operator">/</span>include  <span class="token operator">-</span>L<span class="token operator">/</span>home<span class="token operator">/</span>test<span class="token operator">/</span>lib <span class="token operator">-</span>ltest

</code></pre> 
<p>编译test时：<br> -I /home/test/include 表示将 /home/test/include 目录作为第一个寻找头文件的目录，其寻找的顺序是：</p> 
<p>/home/test/include --&gt; /usr/include --&gt; /usr/local/include</p> 
<p>-L/home/test/lib 表示将 /home/test/lib 目录作为第一个寻找库文件的目录，其寻找的顺序是：</p> 
<p>/home/test/lib --&gt; /lib -&gt; /usr/lib --&gt; /usr/local/lib</p> 
<p>-ltest 表示在上面的lib的路径中寻找 libtest.so 动态库文件（如果 gcc 编译选项中加入了“-static”表示寻找 libtest.a 静态库文件），程序链接的库名是test。</p> 
<p>-l参数就是用来指定程序要链接的库，-l参数紧接着就是库名，那库名跟真正的库文件名有什么关系呢？<br> 比如数学库，他的库名是 m，他的库文件名是 libm.so，把库文件名的头 lib和尾 .so 去掉就是库名了。</p> 
<p>比如当我们使用第三方提供的库名字叫libtest.so，那么我们只要把 libtest.so拷贝到 /usr/lib 里，编译时加上 -ltest 参数，我们就能用上 libtest.so 库了（当然要用 libtest.so 库里的函数，我们还需要与 libtest.so 配套的头文件）。</p> 
<p>对于放在 /lib 和 /usr/lib 和 /usr/local/lib 里的库直接用-l参数就能链接了，但如果库文件没放在这三个目录里，而是放在其他目录里，若此时我们只用-l参数的话，链接还是会出错，出错信息大概是：<br> /usr/bin/ld: cannot find -lxx</p> 
<p>也就是说链接程序ld在那3个目录里找不到 libxx.so，这个时候另外一个参数-L就派上用场了。</p> 
<p>比如我们使用 test 库 它放在 /usr/test/lib 目录下，我们编译时就要用<br> -L/usr/test/lib -ltest 参数，-L 参数跟着的是库文件所在的目录名。</p> 
<p>再比如我们把libtest.so放在 /var/bbb 目录下，那链接参数就是<br> -L/var/bbb -ltest</p> 
<p>另外，大部分libxx.so只是一个链接，比如libm.so它链接到 lib/libm.so.6，/lib/libm.so.6 又链接到 /lib/libm-2.3.2.so，</p> 
<p>如果没有这样的链接，我们运行可执行程序时可能还是会出错，因为 ld 只会找libxx.so。</p> 
<p>所以如果你要用到 xx 库，而只有 libxx.so.x 或者 libxx-x.x.x.so 时，做一个软链接就可以了。</p> 
<p>命令如下：</p> 
<pre><code class="prism language-c">ln  <span class="token operator">-</span>s  libxx<span class="token operator">-</span>x<span class="token punctuation">.</span>x<span class="token punctuation">.</span>x<span class="token punctuation">.</span>so  libxx<span class="token punctuation">.</span>so
 
</code></pre> 
<br> 
<br> 
<br> 
<br> 
<br> 
<p>原文链接<br> <a href="https://mp.weixin.qq.com/s?__biz=Mzg2NDUyNjYyMg==&amp;mid=2247484331&amp;idx=1&amp;sn=5e67082190f8a77983252cf8325d0f8a&amp;chksm=ce694bdaf91ec2cc5304939eeef07818c033d527892ddbf81f6483a3869664a66b1be24303d8&amp;token=973294214&amp;lang=zh_CN#rd" rel="nofollow">使用 -Wl,rpath设置动态库的指定搜索路径</a></p> 
<br> 
<br> 
<br> 
<p>喜欢本文的朋友，欢迎关注公众号 <strong>Linux码农</strong>，获取更多干货</p> 
<p><img src="https://images2.imgbox.com/ae/cc/ijzNlDJW_o.png" alt="在这里插入图片描述"></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/4586a79b6114861f03da655f99863cb3/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">BUUCTF RE [SUCTF2019] SignIn</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/5e51b6e78da0241e5953295595c517b0/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">Nginx&#43;Tomcat负载均衡集群</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>