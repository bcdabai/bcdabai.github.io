<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Linux网络编程socket错误分析 - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Linux网络编程socket错误分析" />
<meta property="og:description" content="源地址：http://blog.csdn.net/uestc_huan/article/details/5863614
Linux网络编程socket错误分析
socket错误码：
EINTR： 4
阻塞的操作被取消阻塞的调用打断。如设置了发送接收超时，就会遇到这种错误。
只能针对阻塞模式的socket。读，写阻塞的socket时，-1返回，错误号为INTR。另外，如果出现EINTR即errno为4，错误描述Interrupted system call，操作也应该继续。如果recv的返回值为0，那表明连接已经断开，接收操作也应该结束。
ETIMEOUT：110
1、操作超时。一般设置了发送接收超时，遇到网络繁忙的情况，就会遇到这种错误。
2、服务器做了读数据做了超时限制，读时发生了超时。
3、错误被描述为“connect time out”，即“连接超时”，这种情况一般发生在服务器主机崩溃。此时客户 TCP将在一定时间内（依具体实现）持续重发数据分节，试图从服务 TCP 获得一个 ACK 分节。当最终放弃尝试后（此时服务器未重新启动），内核将会向客户进程返回 ETIMEDOUT 错误。如果某个中间路由器判定该服务器主机已经不可达，则一般会响应“destination unreachable”－“目的地不可达”的ICMP消息，相应的客户进程返回的错误是 EHOSTUNREACH 或ENETUNREACH。当服务器重新启动后，由于 TCP 状态丢失，之前所有的连接信息也不存在了，此时对于客户端发来请求将回应 RST。如果客户进程对检测服务器主机是否崩溃很有必要，要求即使客户进程不主动发送数据也能检测出来，那么需要使用其它技术，如配置 SO_KEEPALIVE Socket 选项，或实现某些心跳函数。
EAGAIN：
1、Send返回值小于要发送的数据数目，会返回EAGAIN和EINTR。
2、recv 返回值小于请求的长度时说明缓冲区已经没有可读数据，但再读不一定会触发EAGAIN，有可能返回0表示TCP连接已被关闭。
3、当socket是非阻塞时,如返回此错误,表示写缓冲队列已满,可以做延时后再重试.
4、在Linux进行非阻塞的socket接收数据时经常出现Resource temporarily unavailable，errno代码为11(EAGAIN)，表明在非阻塞模式下调用了阻塞操作，在该操作没有完成就返回这个错误，这个错误不会破坏socket的同步，不用管它，下次循环接着recv就可以。对非阻塞socket而言，EAGAIN不是一种错误。
EPIPE：
1、Socket 关闭，但是socket号并没有置-1。继续在此socket上进行send和recv，就会返回这种错误。这个错误会引发SIGPIPE信号，系统会将产生此EPIPE错误的进程杀死。所以，一般在网络程序中，首先屏蔽此消息，以免发生不及时设置socket进程被杀死的情况。
2、write(..) on a socket that has been closed at the other end will cause a SIGPIPE.
3、错误被描述为“broken pipe”，即“管道破裂”，这种情况一般发生在客户进程不理会（或未及时处理）Socket 错误，继续向服务 TCP 写入更多数据时，内核将向客户进程发送 SIGPIPE 信号，该信号默认会使进程终止（此时该前台进程未进行 core dump）。结合上边的 ECONNRESET 错误可知，向一个 FIN_WAIT2 状态的服务 TCP（已 ACK 响应 FIN 分节）写入数据不成问题，但是写一个已接收了 RST 的 Socket 则是一个错误。程序应该设置成Ignore这个信号。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/2e436432edbe7455eb74e184d6e988ae/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2012-07-18T17:01:53+08:00" />
<meta property="article:modified_time" content="2012-07-18T17:01:53+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Linux网络编程socket错误分析</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p>源地址：<a href="http://blog.csdn.net/uestc_huan/article/details/5863614">http://blog.csdn.net/uestc_huan/article/details/5863614</a></p> 
<p><br> </p> 
<p></p> 
<p align="center" style="color:rgb(51,51,51)"><strong><span style="font-size:18px">Linux网络编程socket错误分析</span></strong></p> 
<p style="color:rgb(51,51,51)"> </p> 
<p style="color:rgb(51,51,51)">socket错误码：</p> 
<p style="color:rgb(51,51,51)"> </p> 
<p style="color:rgb(51,51,51)">EINTR： 4</p> 
<p style="color:rgb(51,51,51)">阻塞的操作被取消阻塞的调用打断。如设置了发送接收超时，就会遇到这种错误。</p> 
<p style="color:rgb(51,51,51)">只能针对阻塞模式的socket。读，写阻塞的socket时，-1返回，错误号为INTR。另外，如果出现EINTR即errno为4，错误描述Interrupted system call，操作也应该继续。如果recv的返回值为0，那表明连接已经断开，接收操作也应该结束。</p> 
<p style="color:rgb(51,51,51)"> </p> 
<p style="color:rgb(51,51,51)">ETIMEOUT：110</p> 
<p style="color:rgb(51,51,51)">1、操作超时。一般设置了发送接收超时，遇到网络繁忙的情况，就会遇到这种错误。</p> 
<p style="color:rgb(51,51,51)">2、服务器做了读数据做了超时限制，读时发生了超时。</p> 
<p style="color:rgb(51,51,51)">3、错误被描述为“connect time out”，即“连接超时”，这种情况一般发生在服务器主机崩溃。此时客户 TCP将在一定时间内（依具体实现）持续重发数据分节，试图从服务 TCP 获得一个 ACK 分节。当最终放弃尝试后（此时服务器未重新启动），内核将会向客户进程返回 ETIMEDOUT 错误。如果某个中间路由器判定该服务器主机已经不可达，则一般会响应“destination unreachable”－“目的地不可达”的ICMP消息，相应的客户进程返回的错误是 EHOSTUNREACH 或ENETUNREACH。当服务器重新启动后，由于 TCP 状态丢失，之前所有的连接信息也不存在了，此时对于客户端发来请求将回应 RST。如果客户进程对检测服务器主机是否崩溃很有必要，要求即使客户进程不主动发送数据也能检测出来，那么需要使用其它技术，如配置 SO_KEEPALIVE Socket 选项，或实现某些心跳函数。</p> 
<p style="color:rgb(51,51,51)"> </p> 
<p style="color:rgb(51,51,51)">EAGAIN：</p> 
<p style="color:rgb(51,51,51)">1、Send返回值小于要发送的数据数目，会返回EAGAIN和EINTR。</p> 
<p style="color:rgb(51,51,51)">2、recv 返回值小于请求的长度时说明缓冲区已经没有可读数据，但再读不一定会触发EAGAIN，有可能返回0表示TCP连接已被关闭。</p> 
<p style="color:rgb(51,51,51)">3、当socket是非阻塞时,如返回此错误,表示写缓冲队列已满,可以做延时后再重试.</p> 
<p style="color:rgb(51,51,51)">4、在Linux进行非阻塞的socket接收数据时经常出现Resource temporarily unavailable，errno代码为11(EAGAIN)，表明在非阻塞模式下调用了阻塞操作，在该操作没有完成就返回这个错误，这个错误不会破坏socket的同步，不用管它，下次循环接着recv就可以。对非阻塞socket而言，EAGAIN不是一种错误。</p> 
<p style="color:rgb(51,51,51)"> </p> 
<p style="color:rgb(51,51,51)">EPIPE：</p> 
<p style="color:rgb(51,51,51)">1、Socket 关闭，但是socket号并没有置-1。继续在此socket上进行send和recv，就会返回这种错误。这个错误会引发SIGPIPE信号，系统会将产生此EPIPE错误的进程杀死。所以，一般在网络程序中，首先屏蔽此消息，以免发生不及时设置socket进程被杀死的情况。</p> 
<p style="color:rgb(51,51,51)">2、write(..) on a socket that has been closed at the other end will cause a SIGPIPE.</p> 
<p style="color:rgb(51,51,51)">3、错误被描述为“broken pipe”，即“管道破裂”，这种情况一般发生在客户进程不理会（或未及时处理）Socket 错误，继续向服务 TCP 写入更多数据时，内核将向客户进程发送 SIGPIPE 信号，该信号默认会使进程终止（此时该前台进程未进行 core dump）。结合上边的 ECONNRESET 错误可知，向一个 FIN_WAIT2 状态的服务 TCP（已 ACK 响应 FIN 分节）写入数据不成问题，但是写一个已接收了 RST 的 Socket 则是一个错误。程序应该设置成Ignore这个信号。</p> 
<p style="color:rgb(51,51,51)"> </p> 
<p align="left" style="color:rgb(51,51,51)">调用write的时候， 一定要检查 write 方法的返回值，尤其是服务端程序，当返回 -1 的时候很有可能是“connection reset by peer”（ECONNRESET 104）。如果服务程序没有处理 SIGPIPE信号的话，第二次程序在这条已经 close 的 socket 再次 write 时 SIGPIPE 信号就发送到socket 关联的 owen 进程，也就是上面说的管道破裂，而该信号的默认处理是结束进程。 </p> 
<p align="left" style="color:rgb(51,51,51)"> </p> 
<p align="left" style="color:rgb(51,51,51)"> </p> 
<p style="color:rgb(51,51,51)">EBADF：</p> 
<p style="color:rgb(51,51,51)">read(..) or write(..) on a locally closed socket will return EBADF</p> 
<p style="color:rgb(51,51,51)"> </p> 
<p style="color:rgb(51,51,51)">EFAULT：</p> 
<p style="color:rgb(51,51,51)">地址错误。</p> 
<p style="color:rgb(51,51,51)"> </p> 
<p style="color:rgb(51,51,51)">EBUSY：</p> 
<p style="color:rgb(51,51,51)"> </p> 
<p style="color:rgb(51,51,51)">ECONNREFUSED：</p> 
<p style="color:rgb(51,51,51)">1、拒绝连接。一般发生在连接建立时。</p> 
<p style="color:rgb(51,51,51)">拔服务器端网线测试，客户端设置keep alive时，recv较快返回0， 先收到ECONNREFUSED (Connection refused)错误码，其后都是ETIMEOUT。</p> 
<p style="color:rgb(51,51,51)">2、an error returned from connect(), so it can only occur in a client (if a client is defined as the party that initiates the connection</p> 
<p style="color:rgb(51,51,51)"> </p> 
<p style="color:rgb(51,51,51)"> </p> 
<p style="color:rgb(51,51,51)"> </p> 
<p style="color:rgb(51,51,51)">ECONNRESET：</p> 
<p style="color:rgb(51,51,51)">1、在客户端服务器程序中，客户端异常退出，并没有回收关闭相关的资源，服务器端会先收到ECONNRESET错误，然后收到EPIPE错误。</p> 
<p style="color:rgb(51,51,51)">2、连接被远程主机关闭。有以下几种原因：远程主机停止服务，重新启动;当在执行某些操作时遇到失败，因为设置了“keep alive”选项，连接被关闭，一般与ENETRESET一起出现。</p> 
<p style="color:rgb(51,51,51)">3、远程端执行了一个“hard”或者“abortive”的关闭。应用程序应该关闭socket，因为它不再可用。当执行在一个UDP socket上时，这个错误表明前一个send操作返回一个ICMP“port unreachable”信息。</p> 
<p style="color:rgb(51,51,51)">4、如果client关闭连接,server端的select并不出错(不返回-1,使用select对唯一一个socket进行non- blocking检测),但是写该socket就会出错,用的是send.错误号:ECONNRESET.读(recv)socket并没有返回错误。</p> 
<p style="color:rgb(51,51,51)">5、该错误被描述为“connection reset by peer”，即“对方复位连接”，这种情况一般发生在服务进程较客户进程提前终止。当服务进程终止时会向客户 TCP 发送 FIN 分节，客户 TCP 回应 ACK，服务 TCP 将转入 FIN_WAIT2状态。此时如果客户进程没有处理该 FIN （如阻塞在其它调用上而没有关闭 Socket 时），则客户 TCP 将处于CLOSE_WAIT 状态。当客户进程再次向 FIN_WAIT2 状态的服务 TCP 发送数据时，则服务 TCP 将立刻响应RST。一般来说，这种情况还可以会引发另外的应用程序异常，客户进程在发送完数据后，往往会等待从网络IO接收数据，很典型的如 read 或 readline 调用，此时由于执行时序的原因，如果该调用发生在 RST 分节收到前执行的话，那么结果是客户进程会得到一个非预期的 EOF 错误。此时一般会输出“server terminated prematurely”－“服务器过早终止”错误。</p> 
<p style="color:rgb(51,51,51)"> </p> 
<p style="color:rgb(51,51,51)">EINVAL：</p> 
<p style="color:rgb(51,51,51)">无效参数。提供的参数非法。有时也会与socket的当前状态相关，如一个socket并没有进入listening状态，此时调用accept，就会产生EINVAL错误。</p> 
<p style="color:rgb(51,51,51)"> </p> 
<p style="color:rgb(51,51,51)">EMFILE：</p> 
<p style="color:rgb(51,51,51)">打开了太多的socket。对进程或者线程而言，每种实现方法都有一个最大的可用socket数目处理，或者是全局的，或者是局部的。</p> 
<p style="color:rgb(51,51,51)"> </p> 
<p style="color:rgb(51,51,51)">EWOULDBLOCK：EAGAIN</p> 
<p style="color:rgb(51,51,51)">资源暂时不可用。这个错误是从对非阻塞socket进行的不能立即结束的操作返回的，如当没有数据在队列中可以读时，调用recv。并不是fatal错误，稍后操作可以被重复。调用在一个非阻塞的SOCK_STREAM socket 上调用connect时会产生这个错误，因为有时连接建立必须消耗一定的时间。</p> 
<p style="color:rgb(51,51,51)"> </p> 
<p style="color:rgb(51,51,51)">ENOTCONN</p> 
<p style="color:rgb(51,51,51)">在一个没有建立连接的socket上，进行read，write操作会返回这个错误。出错的原因是socket没有标识地址。Setsoc也可能会出错。</p> 
<p style="color:rgb(51,51,51)"> </p> 
<p style="color:rgb(51,51,51)">ECONNRESET</p> 
<p style="color:rgb(51,51,51)"> Connection reset by peer.</p> 
<p style="color:rgb(51,51,51)">连接被远程主机关闭。有以下几种原因：远程主机停止服务，重新启动;当在执行某些操作时遇到失败，因为设置了“keep alive”选项，连接被关闭，一般与ENETRESET一起出现。</p> 
<p style="color:rgb(51,51,51)"> </p> 
<p style="color:rgb(51,51,51)">ECONNABORTED</p> 
<p style="color:rgb(51,51,51)">1、软件导致的连接取消。一个已经建立的连接被host方的软件取消，原因可能是数据传输超时或者是协议错误。</p> 
<p style="color:rgb(51,51,51)">2、该错误被描述为“software caused connection abort”，即“软件引起的连接中止”。原因在于当服务和客户进程在完成用于 TCP 连接的“三次握手”后，客户 TCP 却发送了一个 RST （复位）分节，在服务进程看来，就在该连接已由 TCP 排队，等着服务进程调用 accept 的时候 RST 却到达了。POSIX 规定此时的 errno 值必须ECONNABORTED。源自 Berkeley 的实现完全在内核中处理中止的连接，服务进程将永远不知道该中止的发生。服务器进程一般可以忽略该错误，直接再次调用accept。</p> 
<p style="color:rgb(51,51,51)">当TCP协议接收到RST数据段，表示连接出现了某种错误，函数read将以错误返回，错误类型为ECONNERESET。并且以后所有在这个套接字上的读操作均返回错误。错误返回时返回值小于0。</p> 
<p align="left" style="color:rgb(51,51,51)"> </p> 
<p style="color:rgb(51,51,51)"> </p> 
<p style="color:rgb(51,51,51)"> </p> 
<p align="left" style="color:rgb(51,51,51)">accept(2) man page 写道</p> 
<p align="left" style="color:rgb(51,51,51)">[ECONNABORTED] A connection arrived, but it was closed while waiting on the listen queue.</p> 
<p style="color:rgb(51,51,51)"> </p> 
<p style="color:rgb(51,51,51)"> </p> 
<p style="color:rgb(51,51,51)">ENETUNREACH</p> 
<p style="color:rgb(51,51,51)">网络不可达。Socket试图操作一个不可达的网络。这意味着local的软件知道没有路由到达远程的host。</p> 
<p style="color:rgb(51,51,51)"> </p> 
<p style="color:rgb(51,51,51)">ENETRESET</p> 
<p style="color:rgb(51,51,51)">网络重置时丢失连接。</p> 
<p style="color:rgb(51,51,51)">由于设置了"keep-alive"选项，探测到一个错误，连接被中断。在一个已经失败的连接上试图使用setsockopt操作，也会返回这个错误。</p> 
<p style="color:rgb(51,51,51)"> </p> 
<p style="color:rgb(51,51,51)">EINPROGRESS：</p> 
<p style="color:rgb(51,51,51)">操作正在进行中。一个阻塞的操作正在执行。</p> 
<p style="color:rgb(51,51,51)"> </p> 
<p style="color:rgb(51,51,51)">ENOTSOCK：</p> 
<p style="color:rgb(51,51,51)">在非socket上执行socket操作。</p> 
<p style="color:rgb(51,51,51)"> </p> 
<p style="color:rgb(51,51,51)">EDESTADDRREQ：</p> 
<p style="color:rgb(51,51,51)">需要提供目的地址。</p> 
<p style="color:rgb(51,51,51)">在一个socket上的操作需要提供地址。如往一个ADDR_ANY 地址上进行sendto操作会返回这个错误。</p> 
<p style="color:rgb(51,51,51)"> </p> 
<p style="color:rgb(51,51,51)">EMSGSIZE：</p> 
<p style="color:rgb(51,51,51)">消息体太长。</p> 
<p style="color:rgb(51,51,51)">发送到socket上的一个数据包大小比内部的消息缓冲区大，或者超过别的网络限制，或是用来接收数据包的缓冲区比数据包本身小。</p> 
<p style="color:rgb(51,51,51)"> </p> 
<p style="color:rgb(51,51,51)">EPROTOTYPE</p> 
<p style="color:rgb(51,51,51)">协议类型错误。标识了协议的Socket函数在不支持的socket上进行操作。如ARPA Internet</p> 
<p style="color:rgb(51,51,51)">UDP协议不能被标识为SOCK_STREAM socket类型。</p> 
<p style="color:rgb(51,51,51)"> </p> 
<p style="color:rgb(51,51,51)">ENOPROTOOPT</p> 
<p style="color:rgb(51,51,51)">该错误不是一个 Socket 连接相关的错误。errno 给出该值可能由于，通过 getsockopt 系统调用来获得一个套接字的当前选项状态时，如果发现了系统不支持的选项参数就会引发该错误。</p> 
<p style="color:rgb(51,51,51)"> </p> 
<p style="color:rgb(51,51,51)">EPROTONOSUPPORT</p> 
<p style="color:rgb(51,51,51)">不支持的协议。系统中没有安装标识的协议，或者是没有实现。如函数需要SOCK_DGRAM socket，但是标识了stream protocol.。</p> 
<p style="color:rgb(51,51,51)"> </p> 
<p style="color:rgb(51,51,51)">ESOCKTNOSUPPORT</p> 
<p style="color:rgb(51,51,51)">Socket类型不支持。指定的socket类型在其address family中不支持。如可选选中选项SOCK_RAW，但实现并不支持SOCK_RAW sockets。</p> 
<p align="left" style="color:rgb(51,51,51)">    该错误不是一个 Socket 连接相关的错误。errno 给出该值可能由于，通过 getsockopt 系统调用来获得一个套接字的当前选项状态时，如果发现了系统不支持的选项参数就会引发该错误。</p> 
<p style="color:rgb(51,51,51)"> </p> 
<p style="color:rgb(51,51,51)"> </p> 
<p style="color:rgb(51,51,51)">EOPNOTSUPP</p> 
<p style="color:rgb(51,51,51)"> Operation not supported.</p> 
<p style="color:rgb(51,51,51)"> </p> 
<p style="color:rgb(51,51,51)">The attempted operation is not supported for the type of object referenced. Usually this occurs when a socket descriptor to a socket that cannot support this operation, for example, trying to accept a connection on a datagram socket.</p> 
<p style="color:rgb(51,51,51)"> </p> 
<p style="color:rgb(51,51,51)">EPFNOSUPPORT</p> 
<p style="color:rgb(51,51,51)"> Protocol family not supported.</p> 
<p style="color:rgb(51,51,51)"> </p> 
<p style="color:rgb(51,51,51)">The protocol family has not been configured into the system or no implementation for it exists. Has a slightly different meaning to EAFNOSUPPORT, but is interchangeable in most cases, and all Windows Sockets functions that return one of these specify EAFNOSUPPORT.</p> 
<p style="color:rgb(51,51,51)"> </p> 
<p style="color:rgb(51,51,51)">EAFNOSUPPORT</p> 
<p style="color:rgb(51,51,51)"> Address family not supported by protocol family.</p> 
<p style="color:rgb(51,51,51)"> </p> 
<p style="color:rgb(51,51,51)">An address incompatible with the requested protocol was used. All sockets are created with an associated "address family" (i.e. AF_INET for Internet Protocols) and a generic protocol type (i.e. SOCK_STREAM). This error will be returned if an incorrect protocol is explicitly requested in the socket call, or if an address of the wrong family is used for a socket, e.g. in sendto.</p> 
<p style="color:rgb(51,51,51)"> </p> 
<p style="color:rgb(51,51,51)">EADDRINUSE</p> 
<p style="color:rgb(51,51,51)"> Address already in use.</p> 
<p style="color:rgb(51,51,51)"> </p> 
<p style="color:rgb(51,51,51)">Only one usage of each socket address (protocol/IP address/port) is normally permitted. This error occurs if an application attempts to bind a socket to an IP address/port that has already been used for an existing socket, or a socket that wasn't closed properly, or one that is still in the process of closing. For server applications that need to bind multiple sockets to the same port number, consider using setsockopt(SO_REUSEADDR). Client applications usually need not call bind at all - connect will choose an unused port automatically. When bind is called with a wild-card address (involving ADDR_ANY), a EADDRINUSE error could be delayed until the specific address is "committed." This could happen with a call to other function later, including connect, listen, Connect or JoinLeaf.</p> 
<p style="color:rgb(51,51,51)"> </p> 
<p style="color:rgb(51,51,51)">EADDRNOTAVAIL</p> 
<p style="color:rgb(51,51,51)"> Cannot assign requested address.</p> 
<p style="color:rgb(51,51,51)"> </p> 
<p style="color:rgb(51,51,51)">The requested address is not valid in its context. Normally results from an attempt to bind to an address that is not valid for the local machine. This can also result from connect, sendto, Connect, JoinLeaf, or SendTo when the remote address or port is not valid for a remote machine (e.g. address or port 0).</p> 
<p style="color:rgb(51,51,51)"> </p> 
<p style="color:rgb(51,51,51)">ENETDOWN</p> 
<p style="color:rgb(51,51,51)"> Network is down.</p> 
<p style="color:rgb(51,51,51)"> </p> 
<p style="color:rgb(51,51,51)">A socket operation encountered a dead network. This could indicate a serious failure of the network system (i.e. the protocol stack that the WinSock DLL runs over), the network interface, or the local network itself.</p> 
<p style="color:rgb(51,51,51)"> </p> 
<p style="color:rgb(51,51,51)">ENOBUFS</p> 
<p style="color:rgb(51,51,51)"> No buffer space available.</p> 
<p style="color:rgb(51,51,51)"> </p> 
<p style="color:rgb(51,51,51)">An operation on a socket could not be performed because the system lacked sufficient buffer space or because a queue was full.</p> 
<p style="color:rgb(51,51,51)"> </p> 
<p style="color:rgb(51,51,51)">EISCONN</p> 
<p style="color:rgb(51,51,51)"> Socket is already connected.</p> 
<p style="color:rgb(51,51,51)"> </p> 
<p style="color:rgb(51,51,51)">A connect request was made on an already connected socket. Some implementations also return this error if sendto is called on a connected SOCK_DGRAM socket (For SOCK_STREAM sockets, the to parameter in sendto is ignored), although other implementations treat this as a legal occurrence.</p> 
<p style="color:rgb(51,51,51)"> </p> 
<p style="color:rgb(51,51,51)">连接过程可能出现的错误情况有：</p> 
<p style="color:rgb(51,51,51)">（1） 如果客户机TCP协议没有接收到对它的SYN数据段的确认，函数以错误返回，错误类型为ETIMEOUT。通常TCP协议在发送SYN数据段失败之后，会多次发送SYN数据段，在所有的发送都高中失败之后，函数以错误返回。</p> 
<p style="color:rgb(51,51,51)">注：SYN（synchronize）位：请求连接。TCP用这种数据段向对方TCP协议请求建立连接。在这个数据段中，TCP协议将它选择的初始序列号通知对方，并且与对方协议协商最大数据段大小。SYN数据段的序列号为初始序列号，这个SYN数据段能够被确认。当协议接收到对这个数据段的确认之后，建立TCP连接。</p> 
<p style="color:rgb(51,51,51)">（2） 如果远程TCP协议返回一个RST数据段，函数立即以错误返回，错误类型为ECONNREFUSED。当远程机器在SYN数据段指定的目的端口号处没有服务进程在等待连接时，远程机器的TCP协议将发送一个RST数据段，向客户机报告这个错误。客户机的TCP协议在接收到RST数据段后不再继续发送SYN数据段，函数立即以错误返回。</p> 
<p style="color:rgb(51,51,51)">注：RST（reset）位：表示请求重置连接。当TCP协议接收到一个不能处理的数据段时，向对方TCP协议发送这种数据段，表示这个数据段所标识的连接出现了某种错误，请求TCP协议将这个连接清除。有3种情况可能导致TCP协议发送RST数据段：（1）SYN数据段指定的目的端口处没有接收进程在等待；（2）TCP协议想放弃一个已经存在的连接；（3）TCP接收到一个数据段，但是这个数据段所标识的连接不存在。接收到RST数据段的TCP协议立即将这条连接非正常地断开，并向应用程序报告错误。</p> 
<p style="color:rgb(51,51,51)">（3） 如果客户机的SYN数据段导致某个路由器产生“目的地不可到达”类型的ICMP消息，函数以错误返回，错误类型为EHOSTUNREACH或ENETUNREACH。通常TCP协议在接收到这个ICMP消息之后，记录这个消息，然后继续几次发送SYN数据段，在所有的发送都告失败之后，TCP协议检查这个ICMP消息，函数以错误返回。</p> 
<p style="color:rgb(51,51,51)">注：ICMP：Internet 消息控制协议。Internet的运行主要是由Internet的路由器来控制，路由器完成IP数据包的发送和接收，如果发送数据包时发生错误，路由器使用 ICMP协议来报告这些错误。ICMP数据包是封装在IP数据包的数据部分中进行传输的，其格式如下：</p> 
<p style="color:rgb(51,51,51)">类型</p> 
<p style="color:rgb(51,51,51)">码</p> 
<p style="color:rgb(51,51,51)">校验和</p> 
<p style="color:rgb(51,51,51)">数据</p> 
<p style="color:rgb(51,51,51)">0 8 16 24 31</p> 
<p style="color:rgb(51,51,51)">类型：指出ICMP数据包的类型。</p> 
<p style="color:rgb(51,51,51)">代码：提供ICMP数据包的进一步信息。</p> 
<p style="color:rgb(51,51,51)">校验和：提供了对整个ICMP数据包内容的校验和。</p> 
<p style="color:rgb(51,51,51)">ICMP数据包主要有以下类型：</p> 
<p style="color:rgb(51,51,51)">（1） 目的地不可到达：A、目的主机未运行；B、目的地址不存在；C、路由表中没有目的地址对应的条目，因而路由器无法找到去往目的主机的路由。</p> 
<p style="color:rgb(51,51,51)">（2） 超时：路由器将接收到的IP数据包的生存时间（TTL）域减1，如果这个域的值变为0，路由器丢弃这个IP数据包，并且发送这种ICMP消息。</p> 
<p style="color:rgb(51,51,51)">（3） 参数出错：当IP数据包中有无效域时发送。</p> 
<p style="color:rgb(51,51,51)">（4） 重定向：将一条新的路径通知主机。</p> 
<p style="color:rgb(51,51,51)">（5） ECHO请求、ECHO回答：这两条消息用语测试目的主机是否可以到达。请求者向目的主机发送ECHO请求ICMP数据包，目的主机在接收到这个ICMP数据包之后，返回ECHO回答ICMP数据包。</p> 
<p style="color:rgb(51,51,51)">（6） 时戳请求、时戳回答：ICMP协议使用这两种消息从其他机器处获得其时钟的当前时间。</p> 
<p style="color:rgb(51,51,51)"> </p> 
<p style="color:rgb(51,51,51)">调用函数connect的过程中，当客户机TCP协议发送了SYN数据段的确认之后，TCP状态由CLOSED状态转为SYN_SENT状态，在接收到对 SYN数据段的确认之后，TCP状态转换成ESTABLISHED状态，函数成功返回。如果调用函数connect失败，应该用close关闭这个套接字描述符，不能再次使用这个套接字描述符来调用函数connect。</p> 
<p style="color:rgb(51,51,51)"> </p> 
<p style="color:rgb(51,51,51)">connect函数的出错处理：</p> 
<p style="color:rgb(51,51,51)">（1）ETIMEOUT－connection timed out 目的主机不存在，没有返回任何相应，例如主机关闭</p> 
<p style="color:rgb(51,51,51)">（2）ECONNREFUSED－connection refused（硬错）到达目的主机后，由于各种原因建立不了连接，主机返回RST（复位）响应，例如主机监听进程未启用，tcp取消连接等</p> 
<p style="color:rgb(51,51,51)">（3）EHOSTTUNREACH－no route to host（软错)路由上引发了一个目的地不可达的ICMP错误</p> 
<p style="color:rgb(51,51,51)"> </p> 
<p style="color:rgb(51,51,51)">其中（1）（3），客户端会进行定时多次重试，一定次数后才返回错误。另外，当connect连接失败时，sockfd套接口不可用，必须关闭后重新socket分配才行。</p> 
<p style="color:rgb(51,51,51)"> </p> 
<p style="color:rgb(51,51,51)">getsockopt 和 setsockopt 还可能引发以下错误：</p> 
<p style="color:rgb(51,51,51)"> </p> 
<p style="color:rgb(51,51,51)">getsockopt/setsockopt(2) man page 写道</p> 
<p style="color:rgb(51,51,51)">ERRORS</p> 
<p style="color:rgb(51,51,51)"> </p> 
<p style="color:rgb(51,51,51)">The getsockopt() and setsockopt() system calls will succeed unless:</p> 
<p style="color:rgb(51,51,51)"> </p> 
<p style="color:rgb(51,51,51)">[EBADF] The argument socket is not a valid file descriptor.</p> 
<p style="color:rgb(51,51,51)">[EFAULT] The address pointed to by option_value is not in a valid part of the process dress space. For getsockopt(), this error may also be returned if option_len is not in a valid part of the process address space.</p> 
<p style="color:rgb(51,51,51)">[EINVAL] The option is invalid at the level indicated.</p> 
<p style="color:rgb(51,51,51)">[ENOBUFS]Insufficient memory buffers are available.</p> 
<p style="color:rgb(51,51,51)">[ENOPROTOOPT] The option is unknown at the level indicated.</p> 
<p style="color:rgb(51,51,51)">[ENOTSOCK] The argument socket is not a socket (e.g., a plain file).</p> 
<p style="color:rgb(51,51,51)"> </p> 
<p style="color:rgb(51,51,51)">The setsockopt() system call will succeed unless:</p> 
<p style="color:rgb(51,51,51)"> </p> 
<p style="color:rgb(51,51,51)">[EDOM] The argument option_value is out of bounds.</p> 
<p style="color:rgb(51,51,51)">[EISCONN]socket is already connected and a specified option cannot be set while this is the case.</p> 
<p style="color:rgb(51,51,51)"> </p> 
<br>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/66e212ce964e319e7fa7dadfb016a917/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">COM三大接口:IUnknown、IClassFactory、IDispatch</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/527d905067952e801e157377eddffeb4/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">【转】网页调试语法错误代码说明(通用于IIS,MYSQL,FTP,ASP，VBScript)</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>