<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>es---elasticsearch-篇二：idea操作es，常用查询DSL - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="es---elasticsearch-篇二：idea操作es，常用查询DSL" />
<meta property="og:description" content="上一篇我们已经写到了对索引库的操作，现在我们要更进一步，对文档document及后面的操作： 我们现在添加文档到索引库（相当于MySQL添加一条记录到table当中） 我们新建立了一个HotelDocumentTest测试类 @Test//添加文档到索引库 void testIndexDocument() throws IOException { //GET /hotel/_doc/1 IndexRequest request = new IndexRequest(&#34;hotel&#34;).id(&#34;1&#34;); request.source(&#34;{\&#34;name\&#34;:\&#34;zs\&#34;,\&#34;city\&#34;:\&#34;长沙\&#34;}&#34;,XContentType.JSON); client.index(request,RequestOptions.DEFAULT); //在index这里创建倒排索引 } 刚刚我们测试了添加一条记录。但是我们现在需要将MySQL当中的hotel表的所有记录导入hotel索引库，那么我们需要建两个实体类，一个对应MySQL，一个对应es索引库，然后将两个实体类进行关联，从而将MySQL的hotel表和es的索引库进行关联首先我们创建对应MySQL的实体类 @TableName(&#34;tb_hotel&#34;) public class Hotel { @TableId(type = IdType.AUTO) private Long id; private String name; private String address; private Integer price; private Integer score; private String brand; private String city; private String starName; private String business; private String latitude; private String longitude; private String pic; } 然后我们需要用到mybatis-plus来操作MySQL数据库，所以需要导入这两个依赖 &lt;!--整合mybatis-plus--&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;5." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/9d12c3d3a5d17f779a9ff61baf8ca0bb/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-10-31T17:14:43+08:00" />
<meta property="article:modified_time" content="2022-10-31T17:14:43+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">es---elasticsearch-篇二：idea操作es，常用查询DSL</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <h2>上一篇我们已经写到了对索引库的操作，现在我们要更进一步，对文档document及后面的操作：</h2> 
<p></p> 
<p></p> 
<ul><li><strong>我们现在添加文档到索引库（相当于MySQL添加一条记录到table当中）</strong> 
  <ul><li><strong>我们新建立了一个HotelDocumentTest测试类</strong></li><li><img alt="" height="1080" src="https://images2.imgbox.com/81/77/SNazPHjv_o.png" width="1200"></li><li> <pre><code class="language-java"> @Test//添加文档到索引库
    void testIndexDocument() throws IOException {
        //GET /hotel/_doc/1
        IndexRequest request = new IndexRequest("hotel").id("1");
        request.source("{\"name\":\"zs\",\"city\":\"长沙\"}",XContentType.JSON);
        client.index(request,RequestOptions.DEFAULT);
        //在index这里创建倒排索引
    }</code></pre> </li></ul></li><li><span style="color:#ff9900;"><strong>刚刚我们测试了添加一条记录。但是我们现在需要将MySQL当中的hotel表的所有记录导入hotel索引库，那么我们需要建两个实体类，一个对应MySQL，一个对应es索引库，然后将两个实体类进行关联，从而将MySQL的hotel表和es的索引库进行关联</strong></span></li><li>首先我们创建对应MySQL的实体类</li><li> <pre><code class="language-java">@TableName("tb_hotel")
public class Hotel {
    @TableId(type = IdType.AUTO)
    private Long id;
    private String name;
    private String address;
    private Integer price;
    private Integer score;
    private String brand;
    private String city;
    private String starName;
    private String business;
    private String latitude;
    private String longitude;
    private String pic;
}</code></pre> </li><li>然后我们需要用到mybatis-plus来操作MySQL数据库，所以需要导入这两个依赖</li><li> <pre><code class="language-XML"> &lt;!--整合mybatis-plus--&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;mysql&lt;/groupId&gt;
            &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;
            &lt;version&gt;5.1.49&lt;/version&gt;
        &lt;/dependency&gt;
 
        &lt;dependency&gt;
            &lt;groupId&gt;com.baomidou&lt;/groupId&gt;
            &lt;artifactId&gt;mybatis-plus-boot-starter&lt;/artifactId&gt;
            &lt;version&gt;3.0.5&lt;/version&gt;
        &lt;/dependency&gt;

</code></pre> </li><li>然后建一个对应hotel索引库的实体类：（构造函数location那里不一样）</li><li><span style="color:#fe2c24;"><strong><span style="background-color:#38d8f0;">思路：我们是是将MySQL对应的hotel实体类的对象作为参数，传进索引库的构造方法里面来对索引库对象对应的属性进行初始化</span></strong></span></li><li> <pre><code class="language-java">public class HotelDoc {
    private Long id;
    private String name;
    private String address;
    private Integer price;
    private Integer score;
    private String brand;
    private String city;
    private String starName;
    private String business;
    /*经纬度换成location*/
    private String location;
    private String pic;

    
    public HotelDoc() {
    }
    /*构造函数*/
    public HotelDoc(Hotel hotel) {
        this.id = hotel.getId();
        this.name = hotel.getName();
        this.address = hotel.getAddress();
        this.price = hotel.getPrice();
        this.score = hotel.getScore();
        this.brand = hotel.getBrand();
        this.city = hotel.getCity();
        this.starName = hotel.getStarName();
        this.business = hotel.getBusiness();
        /*纬度和经度*/
        this.location = hotel.getLatitude()+","+hotel.getLongitude();
        this.pic = hotel.getPic();
    }
}</code></pre> </li><li><strong>然后写hotelMapper,继承BaseMapper</strong></li><li>再写hotelService,继承苞米豆的<span style="color:#fe2c24;"><strong><span style="background-color:#ffd900;">IService</span></strong></span> 
  <ul><li><img alt="" height="37" src="https://images2.imgbox.com/29/03/NkhYu4YZ_o.png" width="545"></li></ul></li><li><strong>然后写他的实现类</strong>，我们是继承了mybatis-plus提供的<span style="color:#fe2c24;"><strong><span style="background-color:#ffd900;">ServiceImpl</span></strong></span> 
  <ul><li><img alt="" height="252" src="https://images2.imgbox.com/03/45/VoCvXuBP_o.png" width="1125"></li></ul></li><li>紧接着我们写service的测试类 
  <ul><li><img alt="" height="672" src="https://images2.imgbox.com/d3/da/esDi2OJH_o.png" width="1200"></li><li> 我们既然要注入es客户端，那么我们容器当中就需要有这个es客户端，所以我们去启动类配置，并且将启动类配置好扫描器：</li><li>扫描器：<strong>@MapperScan("com.pro.mapper")</strong></li><li> <pre><code class="language-java"> @Bean
    public RestHighLevelClient client(){
        return new RestHighLevelClient(
                RestClient.builder(HttpHost.create("http://192.168.8.171:9200"))
        );
    }</code></pre> </li></ul></li><li><strong>既然要连接MySQL数据库，那么我们需要去核心配置文件写上我们的配置</strong> 
  <ul><li><strong>数据库连接四大金刚</strong></li><li><strong>mybatis.xml文件扫描包的配置</strong></li><li><strong>mapper别名配置</strong></li><li><strong>开启驼峰命名</strong></li></ul></li><li> <pre><code class="language-XML">
#mysql
spring.datasource.driver-class-name=com.mysql.jdbc.Driver
spring.datasource.url=jdbc:mysql://192.168.8.171:3306/hotel
spring.datasource.username=root
spring.datasource.password=root

#扫描包
mybatis-plus.mapper-locations=classpath:mapper/*.xml

#别名
mybatis-plus.type-aliases-package=com.pro.domain

#驼峰
mybatis-plus.configuration.map-underscore-to-camel-case=true
</code></pre> </li><li>执行测试类之后，我们去查一下是否有这个文档记录，</li><li>source里面就是我们加进来的内容</li><li><strong>get /hotel/_doc/38665</strong> 
  <ul><li><img alt="" height="761" src="https://images2.imgbox.com/30/0a/GtqncEjA_o.png" width="1200"></li></ul></li><li> <h4><span style="color:#fe2c24;"><strong><span style="background-color:#38d8f0;">那么我们查询MySQL记录并将其加入索引库成功了！</span></strong></span></h4> </li><li> <h3><span style="color:#fe2c24;"><strong><span style="background-color:#a2e043;">有了增加，我们再来写修改，删除，查看以及批量增加</span></strong></span></h3> </li><li><strong>查单个</strong></li><li> <pre><code class="language-java">  /*根据id查出索引库的文档，强转为对象输出*/
    @Test
    public void testGetDocumentById() throws IOException {
        GetRequest request = new GetRequest("hotel", "38665");
        //发请求，得到响应
        GetResponse response = client.get(request, RequestOptions.DEFAULT);
        String json = response.getSourceAsString();
        HotelDoc hotelDoc = JSON.parseObject(json, HotelDoc.class);
        System.out.println(hotelDoc);
    }</code></pre> </li><li><span style="color:#0d0016;"><strong>修改</strong></span></li><li> <pre><code class="language-java">/*根据id修改索引库对应的文档*/
    @Test
    public void testUpdateDocument(){
        //1.request
        UpdateRequest request = new UpdateRequest("hotel", "38665");
        //修改
        request.doc(
                "price","262",
                "starName","三钻"
        );
    }
</code></pre> </li><li><span style="color:#0d0016;"><strong>删除</strong></span></li><li> <pre><code class="language-java"> /*根据id删除索引库对应的文档*/
    @Test
    public void TestDeleteDocumentById() throws IOException {
        //创建request对象
        DeleteRequest request = new DeleteRequest("hotel", "38665");
        //删除文档
        client.delete(request,RequestOptions.DEFAULT);

    }
</code></pre> </li><li><span style="color:#0d0016;"><strong>批量增加</strong></span></li><li> <pre><code class="language-java">/*将MySQL查出来的所有记录加到索引库
    * 批量操作
    * */
    @Test
    public void testBulkRequest() throws IOException {
        QueryWrapper queryWrapper = new QueryWrapper();
        List&lt;Hotel&gt; hotelList = hotelService.list(queryWrapper);
        BulkRequest request = new BulkRequest();
        for (Hotel hotel : hotelList) {
            HotelDoc hotelDoc = new HotelDoc(hotel);
            //将数据对象，一个个转为json，加入到批量操作的对象request中
            request.add(new IndexRequest("hotel")
                    .id(hotelDoc.getId().toString())
                    .source(JSON.toJSONString(hotelDoc),XContentType.JSON));
        }
        //发送请求
        client.bulk(request,RequestOptions.DEFAULT);
    }</code></pre> </li><li> <h2>es官方提供了基于json的DSL来查询</h2> </li><li>地址：<a href="https://www.elastic.co/guide/en/elasticsearch/reference/current/query-dsl.html" rel="nofollow" title="Query DSL | Elasticsearch Guide [8.4] | Elastic">Query DSL | Elasticsearch Guide [8.4] | Elastic</a> 
  <ul><li> <pre><code>https://www.elastic.co/guide/en/elasticsearch/reference/current/query-dsl.html</code></pre> </li></ul></li><li>译文地址 
  <ul><li> <pre><code>https://www.kancloud.cn/apachecn/elasticsearch-doc-zh/1945172</code></pre> </li></ul></li><li>es提供了基于json的DSL来查询</li><li><strong><span style="color:#ff9900;">ES的DSL类似于MySQL的SQL,我们可以进行一个对比</span></strong></li><li> <pre><code class="language-sql">select * from class;

select * from stu;

select * from stu where classid = 1;

-- in 条件可以是一个或多个--
select * from stu where classid in (1);
select * from stu where classid in (1,2);

select * from stu where classid = (select classid from class where classname='1班');

-- 五个聚合函数 --
select count(*) from stu;

select avg(age) from stu;

select sum(age) from stu;

select max(age) from stu;

select min(age) from stu;

-- 分组查询 select 后面只能跟分组的字段，聚合函数--
select classid,avg(age) from stu GROUP BY classid;

-- 对所有记录筛选 --
select * from stu where age &lt; 20;

-- 对组进行筛选,使用having，后面只能跟分组的字段，聚合函数 --
select classid,avg(age) from stu GROUP BY classid having avg(age) &gt; 21;

-- 温哥华 --
select classid,avg(age) from stu  where gender = '男' GROUP BY classid having avg(age) &gt; 21;


select * from stu,class;

select * from stu,class where stu.classid=class.classid and stu.stuid=1;

-- 内连接 两边协商，没有的去取消，查出5条数据 --
select * from stu s inner join class c on s.classid=c.classid;

-- 左连接,以左为主，可以查6条数据 --
select * from stu s left join class c on s.classid=c.classid;

-- 右连接,以右为主，可以查5条数据 --
select * from stu s right join class c on s.classid=c.classid;




</code></pre> <p></p> </li><li><strong>常见的查询类型</strong>： 
  <ul><li><strong>查所有</strong>，match_all</li><li><strong>全文检索</strong>，可以利用分词器对用户输入进行分词，再去倒排索引库中取匹配 
    <ul><li>match_query</li><li>multi_match_query</li></ul></li><li><strong>精确查询</strong>，一般是keyword，数值，日期，boolean，id，range，term</li><li><strong>地理（geo）查询</strong>，经纬度查询 
    <ul><li>geo_distance</li><li>geo_bounding_box</li></ul></li><li><strong>复合（compound）查询</strong>，可以将上面的查询组织在一起，合并查询 
    <ul><li>bool</li><li>function_score</li></ul></li><li><strong><span style="color:#ff9900;">查询DSL的语法</span>：</strong> 
    <ul><li> <pre><code>#查询dsl的语法
GET /hotel/_search
{
  "query":{
    "查询类型"：{
      "FIELD":"TEXT"
    }
  }
}</code></pre> </li></ul></li><li><span style="background-color:#38d8f0;">查所有</span>： 
    <ul><li> <pre><code>
#查所有
GET /hotel/_search
{
  "query":{
    "match_all":{}
  }
}</code></pre> </li></ul></li><li>match查询，会对用户的输入分词，再到索引库检索 
    <ul><li> <pre><code>#match查询，会对用户的输入分词，再到索引库检索
GET /hotel/_search
{
  "query":{
    "match":{
      "all":"深圳如家"
    }
  }
}


#允许多个字段搜 ，字段越多，查询性能越差
GET /hotel/_search
{
  "query":{
    "multi_match":{
      "query":"深圳如家",
      "fields": ["brand","name","business"]
    }
  }
}


#上面这两种查询结果是一样的，因为这三个字段我们已经copy_to all里面了，所以第一种显然要好些</code></pre> </li><li><img alt="" height="374" src="https://images2.imgbox.com/0a/49/DiEjvr9T_o.png" width="498"></li></ul></li><li><strong>match,multi_match的区别：后者可以搜多个字段</strong></li><li><strong><span style="background-color:#38d8f0;">#精准查，term不分词：例如查品牌</span></strong> 
    <ul><li> <pre><code>#精准查询 term 特点：不分词
GET /hotel/_search
{
  "query":{
    "term":{
      "city":{
        "value": "上海"
      }
    }
  }
}</code></pre> </li></ul></li><li><strong><span style="background-color:#38d8f0;">#范围内精准查询 range 特点：不分词</span></strong>  
    <ul><li><strong>gte:&gt;=,      lte:&lt;=</strong> <pre><code>#范围内精准查询 range 特点：不分词
GET /hotel/_search
{
  "query": {
    "range": {
      "price": {
        "gte": 100,
        "lte": 300
      }
    }
  }
}
</code></pre> </li><li><span style="color:#ff9900;">t<strong>erm,range这两种查询：前者一般搜keyword，后者一般搜数值（在某个范围内</strong></span>）</li></ul></li><li><strong><span style="background-color:#38d8f0;">#地理查询，经纬度查询：geo_distance;   geo_bounding_box</span></strong> <p></p> 
    <ul><li><strong>geo_distance:  圆形范围,根据范围和经纬度查</strong></li><li><img alt="" height="449" src="https://images2.imgbox.com/11/d5/djzluBMP_o.png" width="1200"></li><li> <pre><code>#地理查询，经纬度查询：
#geo_distance:  圆形范围
GET /hotel/_search
{
  "query":{
    "geo_distance":{
      "distance":"150km",
      "location":"31.174377,121.442875"
    }
  }
}
</code></pre> </li><li> <p><strong>geo_bounding_box矩形范围：lat纬度，lon经度</strong></p> </li><li> <p><img alt="" height="770" src="https://images2.imgbox.com/df/a2/YCOwSdYN_o.png" width="1200"></p> <pre><code>#geo_bounding_box矩形范围：lat纬度，lon经度
GET /hotel/_search
{
  "query":{
    "geo_bounding_box":{
      "location":{
        "top_left":{
          "lat":31.1,
          "lon":121.5
        },
        "bottom_right":{
          "lat":30.9,
          "lon":121.7
        }
      }
    }
  }
}</code></pre> </li></ul></li><li> <p><strong><span style="background-color:#38d8f0;">#复合查询  </span></strong></p> 
    <ul><li> <p><strong>将简单的查询组合起来</strong></p> </li><li> <p><strong>算分函数查询，function score ,可以控制文档相关性算分，</strong></p> </li><li> <p><strong>控制文档排名</strong></p> </li><li> <p></p> <p><strong>1）function score</strong></p> <p>先查所有all里面分词有外滩的文档，然后再过滤出brand为如家的品牌（精准过滤），最后对对应文档的_score进行操作​​​​​​</p> </li></ul></li><li> <p><img alt="" height="547" src="https://images2.imgbox.com/4b/81/F9YNQwzQ_o.png" width="904"></p> </li><li><strong>filter：term精准过滤出“如家”这个品牌（过滤出哪些文档要加分）</strong></li><li><strong>算分函数</strong> 
    <ul><li>weight:  给一个常量值作为函数的结果：</li><li>random_score 随机生成一个值，作为函数结果</li><li>script_score 自定义计算公式，公式结果作为函数结果</li><li>field_score_factor 用文档中的某个字段作为函数的结果</li><li>加权模式(boost_mode)：定义function score 和 query score（查出的分值之间的运算方式：<span style="color:#ff9900;"><strong>默认相乘</strong></span>） 
      <ul><li>multiply:  两者相乘 （默认）</li><li>replace:  用算分函数<span style="color:#fe2c24;"><strong>替换</strong></span>查询出来的分值</li><li> <p><strong>其它 ：sum,avg,max,min</strong></p> </li></ul></li><li> <pre><code>#1）function score先查所有all里面分词有外滩的文档，
然后再过滤出brand为如家的品牌（精准过滤），最后对对应文档的_score进行操作

GET /hotel/_search
{
  "query":{
    "function_score": {
      "query": {
        "match":{
          "all":"外滩"
        }
      },
      "functions": [
        {
          "filter": {
            "term":{
              "brand": "如家"
            }
          },
          "weight":10
        }
      ],
        "boost_mode": "replace"
    }
  }
}</code></pre> </li></ul></li><li> <h4><span style="background-color:#38d8f0;">复合查询之布尔查询</span></h4> 
    <ul><li>是一个或多个查询子句的组合，子查询的组合方式</li><li>must  必须匹配每个子查询  &amp;&amp;</li><li>should  选择性的匹配子查询   ||</li><li>must_not 必须不匹配   ，不参与算分</li><li>filter   必须匹配，不参与算分</li><li> <pre><code>#搜索如家，价格小于等于400，坐标在31.2,121.5周围十公里范围内的酒店
GET /hotel/_search
{
  "query":{
    "bool": {
      "must": [
        {
          "match": {
            "FIELD": "如家"
          }
        }
      ],
      "must_not": [
        {
          "range": {
            "FIELD": {
              "gte": 400
            }
          }
        }
      ],
      "filter": [
        {
           "geo_distance":{
            "distance":"10km",
            "location":{
             "lat":31.21,
             "lon":121.5
           }
          }
        }
      ]
    }
    }
  }
}</code></pre> <p></p> </li></ul></li><li> <h4><strong><span style="background-color:#38d8f0;">有了搜索结果之后，我们可以对搜索结果进行排序（默认是根据算分来排）</span></strong></h4> </li><li><strong>可以排序的字段类型<span style="background-color:#ffd900;">：keyword，数值，地理坐标，日期</span></strong> 
    <ul><li><strong>1：</strong> 
      <blockquote> 
       <ul><li><strong>#排序,根据评分降序<br> GET /hotel/_search <br> {<!-- --><br>   "query":{<!-- --><br>     "match_all": {}<br>   },<br>   "sort":[<br>     {<!-- --><br>       "score":{<!-- --><br>         "order":"desc"<br>       }<br>     }<br>   ]<br> }</strong></li></ul> 
      </blockquote> </li><li>2： 
      <blockquote> 
       <ul><li>#按坐标排序<br> GET /hotel/_search<br> {<!-- --><br>   "query":{<!-- --><br>     "match_all": {}<br>   },<br>   "sort":[<br>     {<!-- --><br>      "_geo_distance": {<!-- --><br>        "location": "31.21,121.5",<br>        "order": "desc",<br>        "unit": "km"<br>      }<br>     }<br>   ]<br> }</li></ul> 
      </blockquote> </li><li>3: 
      <blockquote> 
       <ul><li>#按分值排序，分值一致时，按价格升序<br> GET /hotel/_search<br> {<!-- --><br>   "query":{<!-- --><br>     "match_all": {}<br>   },<br>   "sort":[<br>     {<!-- --><br>       "score":{<!-- --><br>         "order": "desc"<br>       },<br>       "price": {<!-- --><br>         "order": "asc"<br>       }<br>     }<br>   ]<br> }<br>  </li></ul> 
      </blockquote> </li><li>4:  
      <blockquote> 
       <ul><li>#按某坐标，周围的酒店，距离降序排序<br> #查询的sort的值，是公里数<br> #注意，如果排序，则打分为null<br> GET /hotel/_search<br> {<!-- --><br>   "query":{<!-- --><br>     "match_all": {}<br>   },<br>   "sort":[<br>     {<!-- --><br>       "_geo_distance": {<!-- --><br>         "location": {<!-- --><br>           "lat": 30,<br>           "lon": 120<br>         },<br>         "order": "desc",<br>         "unit": "km"<br>       }<br>     }<br>   ]<br> }</li></ul> 
      </blockquote> </li><li> <h4><span style="background-color:#38d8f0;">分页：默认的返回10条，from，size</span></h4> 
      <blockquote> 
       <ul><li>#分页<br> #es 默认的返回10条，from，size,我们现在分20条<br> GET /hotel/_search<br> {<!-- --><br>   "query":{<!-- --><br>     "match_all": {}<br>   },<br>   "from": 0,<br>   "size": 20,<br>   "sort":[<br>     {<!-- --><br>       "price": {<!-- --><br>         "order": "asc"<br>       }<br>     }<br>   ]<br> }</li></ul> 
      </blockquote> </li></ul></li></ul></li></ul> 
<h4></h4> 
<h4>         <span style="background-color:#38d8f0;"> #如果集群，：每台机器分配一些</span><br>         #es的查新结果上限为<span style="background-color:#ff9900;">10000条</span>，超一条都会提示large</h4> 
<h4><img alt="" height="775" src="https://images2.imgbox.com/4c/44/wy9iQhnv_o.png" width="1200"><br>         #但是有解决方案：after search (不支持随机翻页，我们有些APP，下拉分页刷新，但是上划没有限制了，回不到上一页<br>         #<span style="background-color:#ffd900;">scroll </span> 没有查询上限，内存消耗大，es7.1之后，就<span style="background-color:#ffd900;">不推荐用</span>了  </h4> 
<p> </p> 
<ul><li><strong><span style="background-color:#a2e043;">练习：搜索:价格在220以内的酒店</span></strong> 
  <ul><li><strong>按从小到大升序排列</strong></li><li><strong>取前五个酒店</strong></li><li> <pre><code class="hljs">#练习：搜索:价格在220以内的酒店
#按从小到大升序排列
#取前五个酒店
GET /hotel/_search
{
  "query": {
    "range": {
      "price": {
        "lte": 220
      }
    }
  },
  "from": 0,
  "size": 5,
  "sort": [
    {
      "price": {
        "order": "asc"
      }
    }
  ]
}</code></pre>          </li></ul></li><li> <h4><span style="background-color:#38d8f0;">高亮显示</span></h4> <p> </p> 
  <ul><li><strong> 高亮,require_field_match表示：是否匹配搜索字段和高亮字段</strong></li><li> <pre><code class="hljs">#高亮,require_field_match表示：是否匹配搜索字段和高亮字段
GET /hotel/_search
{
  "query":{
    "match":{
      "all":"如家"
    }
  },
  "highlight": {
    "fields": {
      "name": {"require_field_match": "false"}
    }
  }
}</code></pre> </li><li><strong>设定标签，不设定，标签<span style="color:#ff9900;">默认是em，</span><span style="color:#fe2c24;">搜索字段和高亮字段默认必须匹配</span></strong></li><li><img alt="" height="436" src="https://images2.imgbox.com/13/e4/QTyz13zr_o.png" width="744"></li></ul></li><li> <h2>搜索小结</h2> 
  <ul><li><span style="color:#fe2c24;"><strong>结构：</strong></span></li><li><span style="color:#fe2c24;"><strong>get /hotel/_search</strong></span> 
    <ul><li><strong><span style="color:#a2e043;">query</span></strong></li><li><strong><span style="color:#a2e043;">from   size</span></strong></li><li><span style="color:#a2e043;"><strong>sort</strong></span> 
      <ul><li><strong><span style="color:#ffd900;">field，_geo_distance</span></strong></li></ul></li><li><strong><span style="color:#a2e043;">hight</span></strong></li></ul></li></ul></li></ul>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/3f87f325de82add8752c46520c9ead73/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">(01)ORB-SLAM2源码无死角解析-(22) 特征点三角化、深度计算、三维点筛选</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/25e6ba5fd7b7e41e7b651f76c2b88174/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">解决 OpenSSL SSL_read: Connection was reset, errno 10054的问题</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>