<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>单源点最短路径 - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="单源点最短路径" />
<meta property="og:description" content="单源点最短路径的C实现 求解单源点最短路径的算法： 1构造所有节点间距离的矩阵（二维数组），无直接路径的为无穷2构造到所有节点最短路径上前一结点数组nodeArray，初始全为源点3构造源点到其他各结点的距离数组distanceArray，无直接路径的为无穷4从数组distanceArray中选出距离最小的结点node,并入集合s（初始为空）5遍历遍历每个不在s集合中的其他结点dot（distanceArray数组），若源点到node距离与node到dot的距离之和小于源点到dot距离，则更新distanceArray对应项的值，并同时更新nodeArray的值为node6重复4-5直至无可选结点7通过nodeArray从某结点出发不断寻找其前一结点，直至源点，此路径即为源点到该结点的最短路径 具体实现 #include &lt;iostream&gt; #include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; using namespace std; /** 自定义比较大小，负数均视为无穷大，其他大小正常 x&lt;y,return true */ bool lessThen(float x, float y); /** 长度为len的s数组是否包含e 包含e，return true */ bool contain(int* s, int len, int e); /** 得到到达e的最短路径字符串描述 keys[i]的值为起点到i的前一个结点索引 */ string getPath(int *keys, int e); /** 以size*size的二维数组paths为前提寻找最短路径，返回有效长度为len一维数组keys keys[i]的值为起点到i的前一个结点索引 */ int* findShortestPath(float **paths, int size, int&amp; len); int main() { //节点数 int size = 0; //读入节点数 cout&lt;&lt;&#34;请输入节点数：&#34;; cin&gt;&gt;size; cout&lt;&lt;endl; if(size &lt;= 0) { cout&lt;&lt;&#34;" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/8c332a236e520dbe29c865afa4cc4ba5/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2015-12-23T13:08:54+08:00" />
<meta property="article:modified_time" content="2015-12-23T13:08:54+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">单源点最短路径</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <h2 id="单源点最短路径的c实现">单源点最短路径的C实现</h2> 
<h3 id="求解单源点最短路径的算法">求解单源点最短路径的算法：</h3> 
<ul><li><strong>1构造所有节点间距离的矩阵（二维数组），无直接路径的为无穷</strong></li><li><strong>2构造到所有节点最短路径上前一结点数组nodeArray，初始全为源点</strong></li><li><strong>3构造源点到其他各结点的距离数组distanceArray，无直接路径的为无穷</strong></li><li><strong>4从数组distanceArray中选出距离最小的结点node,并入集合s（初始为空）</strong></li><li><strong>5遍历遍历每个不在s集合中的其他结点dot（distanceArray数组），若源点到node距离与node到dot的距离之和小于源点到dot距离，则更新distanceArray对应项的值，并同时更新nodeArray的值为node</strong></li><li><strong>6重复4-5直至无可选结点</strong></li><li><strong>7通过nodeArray从某结点出发不断寻找其前一结点，直至源点，此路径即为源点到该结点的最短路径</strong></li></ul> 
<hr> 
<h3 id="具体实现">具体实现</h3> 
<pre class="prettyprint"><code class=" hljs java">#include &lt;iostream&gt;
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;


using namespace std;

<span class="hljs-javadoc">/**
自定义比较大小，负数均视为无穷大，其他大小正常
x&lt;y,return true
*/</span>
bool lessThen(<span class="hljs-keyword">float</span> x, <span class="hljs-keyword">float</span> y);

<span class="hljs-javadoc">/**
长度为len的s数组是否包含e
包含e，return true
*/</span>
bool contain(<span class="hljs-keyword">int</span>* s, <span class="hljs-keyword">int</span> len, <span class="hljs-keyword">int</span> e);

<span class="hljs-javadoc">/**
得到到达e的最短路径字符串描述
keys[i]的值为起点到i的前一个结点索引
*/</span>
string getPath(<span class="hljs-keyword">int</span> *keys, <span class="hljs-keyword">int</span> e);

<span class="hljs-javadoc">/**
以size*size的二维数组paths为前提寻找最短路径，返回有效长度为len一维数组keys
keys[i]的值为起点到i的前一个结点索引
*/</span>
<span class="hljs-keyword">int</span>* findShortestPath(<span class="hljs-keyword">float</span> **paths, <span class="hljs-keyword">int</span> size, <span class="hljs-keyword">int</span>&amp; len);

<span class="hljs-keyword">int</span> main()
{
    <span class="hljs-comment">//节点数</span>
    <span class="hljs-keyword">int</span> size = <span class="hljs-number">0</span>;
    <span class="hljs-comment">//读入节点数</span>
    cout&lt;&lt;<span class="hljs-string">"请输入节点数："</span>;
    cin&gt;&gt;size;
    cout&lt;&lt;endl;
    <span class="hljs-keyword">if</span>(size &lt;= <span class="hljs-number">0</span>)
    {
        cout&lt;&lt;<span class="hljs-string">"节点数非正数"</span>&lt;&lt;endl;
        system(<span class="hljs-string">"pause"</span>);
        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
    }
    <span class="hljs-keyword">int</span> i;
    <span class="hljs-keyword">int</span> j;

    <span class="hljs-comment">//路径集合size*size</span>
    <span class="hljs-keyword">float</span>** paths = <span class="hljs-keyword">new</span> <span class="hljs-keyword">float</span>*[size];

    <span class="hljs-keyword">for</span>(i = <span class="hljs-number">0</span>; i &lt; size; i++)
    {
        paths[i] = <span class="hljs-keyword">new</span> <span class="hljs-keyword">float</span>[size];
    }

    <span class="hljs-comment">//读入路径集合</span>
    <span class="hljs-comment">//readPaths(paths);</span>

    <span class="hljs-keyword">for</span>(i = <span class="hljs-number">0</span>; i &lt; size; i++)
    {
        <span class="hljs-keyword">for</span>(j = <span class="hljs-number">0</span>; j &lt; size; j++)
        {
            <span class="hljs-keyword">if</span>(i == j)
                paths[i][j] = <span class="hljs-number">0</span>;
            <span class="hljs-keyword">else</span>
            {
                cout&lt;&lt;<span class="hljs-string">"请输入节点"</span>&lt;&lt;i&lt;&lt;<span class="hljs-string">"到节点"</span>&lt;&lt;j&lt;&lt;<span class="hljs-string">"的距离(负数表示无穷大):"</span>;
                cin&gt;&gt;paths[i][j];
            }
        }
        cout&lt;&lt;endl;
    }

    <span class="hljs-comment">//计算最短路径</span>
    <span class="hljs-keyword">int</span> len;
    <span class="hljs-keyword">int</span>* keys = findShortestPath(paths, size, len);

    string path;
    <span class="hljs-keyword">for</span>(i = <span class="hljs-number">1</span>; i &lt; size; i++)
    {

        cout&lt;&lt;<span class="hljs-string">"到节点"</span>&lt;&lt;i&lt;&lt;<span class="hljs-string">"的最短距离:"</span>;
        <span class="hljs-keyword">if</span>(paths[<span class="hljs-number">0</span>][i] &gt; <span class="hljs-number">0</span>)
            cout&lt;&lt;paths[<span class="hljs-number">0</span>][i];
        <span class="hljs-keyword">else</span>
            cout&lt;&lt;<span class="hljs-string">"无穷大"</span>;
        cout&lt;&lt;endl;
        path = getPath(keys, i);
        cout&lt;&lt;<span class="hljs-string">"到节点"</span>&lt;&lt;i&lt;&lt;<span class="hljs-string">"的最短路径:"</span>&lt;&lt;path&lt;&lt;endl&lt;&lt;endl;;
    }

    <span class="hljs-comment">//释放内存</span>
    <span class="hljs-keyword">if</span>(keys)
        delete keys;

    <span class="hljs-keyword">for</span>(i = <span class="hljs-number">0</span>; i &lt; size; i++)
    {
        <span class="hljs-keyword">if</span>(paths[i])
            delete paths[i];
    }
    <span class="hljs-keyword">if</span>(paths)
        delete paths;
    system(<span class="hljs-string">"pause"</span>);
    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}

bool contain(<span class="hljs-keyword">int</span>* s, <span class="hljs-keyword">int</span> len, <span class="hljs-keyword">int</span> e)
{
    <span class="hljs-keyword">while</span>(len &gt; <span class="hljs-number">0</span>)
    {
        <span class="hljs-keyword">if</span>(*s == e)
            <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;
        s++;
        len--;
    }
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;
}

string getPath(<span class="hljs-keyword">int</span> *keys, <span class="hljs-keyword">int</span> e)
{
    string path;
    <span class="hljs-keyword">char</span>* temp = <span class="hljs-keyword">new</span> <span class="hljs-keyword">char</span>[<span class="hljs-number">20</span>];
    <span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>)
    {

        sprintf(temp, <span class="hljs-string">"%d"</span>, e);
        path.append(temp);
        <span class="hljs-keyword">if</span>(e == <span class="hljs-number">0</span>)
            <span class="hljs-keyword">break</span>;
        e = keys[e];
        path.append(<span class="hljs-string">" &lt;- "</span>);
    }
    delete temp;
    <span class="hljs-keyword">return</span> path;
}

<span class="hljs-keyword">int</span>* findShortestPath(<span class="hljs-keyword">float</span> **paths, <span class="hljs-keyword">int</span> size, <span class="hljs-keyword">int</span>&amp; len)
{
    len = <span class="hljs-number">0</span>;
    <span class="hljs-keyword">int</span>* keys = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[size];


    <span class="hljs-keyword">int</span>* shortest = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[size];
    shortest[len] = <span class="hljs-number">0</span>;
    len++;

    <span class="hljs-keyword">int</span> index = <span class="hljs-number">0</span>;

    <span class="hljs-keyword">int</span> i;
    <span class="hljs-keyword">int</span> min;
    <span class="hljs-keyword">int</span> temp;

    <span class="hljs-keyword">for</span>(i = <span class="hljs-number">0</span>; i &lt; size; i++)
        keys[i] = <span class="hljs-number">0</span>;

    <span class="hljs-keyword">while</span>(len &lt; size - <span class="hljs-number">1</span>)
    {
        <span class="hljs-comment">//遍历找到距离最短的节点</span>
        min = -<span class="hljs-number">1</span>;
        <span class="hljs-keyword">for</span>(i = <span class="hljs-number">1</span>; i &lt; size; i++)
        {
            <span class="hljs-keyword">if</span>(!contain(shortest, len, i) &amp;&amp; lessThen(paths[<span class="hljs-number">0</span>][i], min))
            {
                min = paths[<span class="hljs-number">0</span>][i];
                index = i;
            }
        }
        <span class="hljs-keyword">if</span>(min &lt; <span class="hljs-number">0</span>)
            <span class="hljs-keyword">break</span>;
        <span class="hljs-comment">//cout&lt;&lt;"find point:"&lt;&lt;index&lt;&lt;",path="&lt;&lt;min&lt;&lt;endl;</span>
        shortest[len] = index;
        len++;

        <span class="hljs-comment">//刷新各节点距离</span>
        <span class="hljs-keyword">for</span>(i = <span class="hljs-number">1</span>; i &lt; size; i++)
        {
            <span class="hljs-keyword">if</span>(i == index)
                <span class="hljs-keyword">continue</span>;
            <span class="hljs-keyword">if</span>(paths[index][i] &gt; <span class="hljs-number">0</span>)
            {
                temp = min+paths[index][i];
                <span class="hljs-keyword">if</span>(lessThen(temp, paths[<span class="hljs-number">0</span>][i]))
                {
                    paths[<span class="hljs-number">0</span>][i] = temp;
                    keys[i] = index;
                }
            }
            <span class="hljs-comment">//cout&lt;&lt;"paths[0]["&lt;&lt;i&lt;&lt;"]="&lt;&lt;paths[0][i]&lt;&lt;endl;</span>
        }
        cout&lt;&lt;endl;
    }
    delete shortest;
    <span class="hljs-keyword">return</span> keys;
}

bool lessThen(<span class="hljs-keyword">float</span> x, <span class="hljs-keyword">float</span> y)
{
    <span class="hljs-keyword">if</span>(x &lt; <span class="hljs-number">0</span>)
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;
    <span class="hljs-keyword">if</span>(y &lt; <span class="hljs-number">0</span>)
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;
    <span class="hljs-keyword">return</span> x &lt; y;
}
</code></pre> 
<h3 id="运行效果">运行效果</h3> 
<h4 id="带权有向图">带权有向图：</h4> 
<p><img src="https://images2.imgbox.com/a5/d0/NCf0bYlX_o.png" alt="V0为源点" title=""></p> 
<h4 id="最短路径结果">最短路径结果：</h4> 
<p><img src="https://images2.imgbox.com/e1/f7/utmBwL6D_o.png" alt="结果描述是反向的'&lt;'" title=""></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/3767f6b121b089ddff0e55b1e099816c/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">VS2015  窗口布局简介  其他版本也一样</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/718826302d72412c8e167bbdc525571d/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">关于getClass().getClassLoader()</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>