<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>【深度学习：BERT 】开源 BERT：最先进的自然语言处理预训练 - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="【深度学习：BERT 】开源 BERT：最先进的自然语言处理预训练" />
<meta property="og:description" content="【深度学习：BERT 】开源 BERT：最先进的自然语言处理预训练 BERT 有何不同？双向性的力量使用云 TPU 进行训练BERT 结果让 BERT 为您服务 自然语言处理（NLP）的最大挑战之一是训练数据的短缺。由于 NLP 是一个多元化的领域，具有许多不同的任务，因此大多数特定于任务的数据集仅包含几千或几十万个人工标记的训练示例。然而，现代基于深度学习的 NLP 模型从大量数据中获益，在数百万或数十亿带注释的训练示例上进行训练时，性能会得到改善。为了帮助缩小数据差距，研究人员开发了多种技术，使用网络上大量未注释的文本（称为预训练）来训练通用语言表示模型。然后，可以针对问答和情感分析等小数据 NLP 任务对预训练模型进行微调，与从头开始对这些数据集进行训练相比，可显着提高准确性。
本周，我们开源了一种用于 NLP 预训练的新技术，称为 Transformers 双向编码器表示（BERT）。通过此版本，世界上任何人都可以在单个 Cloud TPU 上大约 30 分钟内训练自己最先进的问答系统（或各种其他模型），或者使用单个 GPU 在几个小时内训练。该版本包括基于 TensorFlow 构建的源代码和许多预先训练的语言表示模型。在我们的相关论文中，我们展示了 11 项 NLP 任务的最新结果，其中包括非常有竞争力的斯坦福问答数据集 (SQuAD v1.1)。
BERT 有何不同？ BERT 建立在预训练上下文表示方面的最新成果之上，包括半监督序列学习、生成预训练、ELMo 和 ULMFit。然而，与之前的模型不同的是，BERT 是第一个深度双向、无监督的语言表示，仅使用纯文本语料库（在本例中为维基百科）进行预训练。
为什么这很重要？预训练的表示可以是上下文无关的或上下文的，并且上下文表示还可以是单向的或双向的。上下文无关模型（例如 word2vec 或 GloVe）为词汇表中的每个单词生成单个单词嵌入表示。例如，“银行”一词在“银行帐户”和“河岸”中具有相同的上下文无关表示。相反，上下文模型会根据句子中的其他单词生成每个单词的表示。例如，在句子“我访问了银行帐户”中，单向上下文模型将基于“我访问了”而不是“帐户”来表示“银行”。然而，BERT 使用其前一个和下一个上下文（“我访问了……帐户”）来表示“银行”，从深度神经网络的最底层开始，使其成为深度双向的。
下图展示了 BERT 神经网络架构与之前最先进的上下文预训练方法的对比。箭头表示从一层到下一层的信息流。顶部的绿色框表示每个输入单词的最终上下文表示：
BERT 是深度双向的，OpenAI GPT 是单向的，ELMo 是浅度双向的。 双向性的力量 如果双向性如此强大，为什么以前没有这样做呢？要理解原因，请考虑通过根据句子中前面的单词预测每个单词来有效地训练单向模型。然而，不可能通过简单地根据每个单词的前一个和下一个单词来训练双向模型，因为这将允许被预测的单词在多层模型中间接“看到自己”。
为了解决这个问题，我们使用简单的技术来屏蔽输入中的一些单词，然后双向调节每个单词以预测屏蔽的单词。例如：
虽然这个想法已经存在很长时间了，但 BERT 是第一次成功地将其用于预训练深度神经网络。
BERT 还通过预训练一个非常简单的任务来学习建模句子之间的关系，该任务可以从任何文本语料库生成：给定两个句子 A 和 B，B 是语料库中 A 之后的实际下一个句子，还是只是一个随机句子？例如：" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/20168e95be50775b3bd96305c565d291/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2024-01-17T11:36:02+08:00" />
<meta property="article:modified_time" content="2024-01-17T11:36:02+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">【深度学习：BERT 】开源 BERT：最先进的自然语言处理预训练</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-light">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p></p> 
<div class="toc"> 
 <h4>【深度学习：BERT 】开源 BERT：最先进的自然语言处理预训练</h4> 
 <ul><li><ul><li><a href="#BERT__11" rel="nofollow">BERT 有何不同？</a></li><li><a href="#_22" rel="nofollow">双向性的力量</a></li><li><a href="#_TPU__35" rel="nofollow">使用云 TPU 进行训练</a></li><li><a href="#BERT__39" rel="nofollow">BERT 结果</a></li><li><a href="#_BERT__48" rel="nofollow">让 BERT 为您服务</a></li></ul> 
 </li></ul> 
</div> 
<p></p> 
<p>自然语言处理（NLP）的最大挑战之一是训练数据的短缺。由于 NLP 是一个多元化的领域，具有许多不同的任务，因此大多数特定于任务的数据集仅包含几千或几十万个人工标记的训练示例。然而，现代基于深度学习的 NLP 模型从大量数据中获益，在数百万或数十亿带注释的训练示例上进行训练时，性能会得到改善。为了帮助缩小数据差距，研究人员开发了多种技术，使用网络上大量未注释的文本（称为预训练）来训练通用语言表示模型。然后，可以针对问答和情感分析等小数据 NLP 任务对预训练模型进行微调，与从头开始对这些数据集进行训练相比，可显着提高准确性。</p> 
<p>本周，我们开源了一种用于 NLP 预训练的新技术，称为 Transformers 双向编码器表示（BERT）。通过此版本，世界上任何人都可以在单个 Cloud TPU 上大约 30 分钟内训练自己最先进的问答系统（或各种其他模型），或者使用单个 GPU 在几个小时内训练。该版本包括基于 TensorFlow 构建的源代码和许多预先训练的语言表示模型。在我们的相关论文中，我们展示了 11 项 NLP 任务的最新结果，其中包括非常有竞争力的斯坦福问答数据集 (SQuAD v1.1)。</p> 
<h3><a id="BERT__11"></a>BERT 有何不同？</h3> 
<p>BERT 建立在预训练上下文表示方面的最新成果之上，包括半监督序列学习、生成预训练、ELMo 和 ULMFit。然而，与之前的模型不同的是，BERT 是第一个深度双向、无监督的语言表示，仅使用纯文本语料库（在本例中为维基百科）进行预训练。</p> 
<p>为什么这很重要？预训练的表示可以是上下文无关的或上下文的，并且上下文表示还可以是单向的或双向的。上下文无关模型（例如 word2vec 或 GloVe）为词汇表中的每个单词生成单个单词嵌入表示。例如，“银行”一词在“银行帐户”和“河岸”中具有相同的上下文无关表示。相反，上下文模型会根据句子中的其他单词生成每个单词的表示。例如，在句子“我访问了银行帐户”中，单向上下文模型将基于“我访问了”而不是“帐户”来表示“银行”。然而，BERT 使用其前一个和下一个上下文（“我访问了……帐户”）来表示“银行”，从深度神经网络的最底层开始，使其成为深度双向的。</p> 
<p>下图展示了 BERT 神经网络架构与之前最先进的上下文预训练方法的对比。箭头表示从一层到下一层的信息流。顶部的绿色框表示每个输入单词的最终上下文表示：</p> 
<p><img src="https://images2.imgbox.com/15/89/eivhx0ft_o.png" alt="在这里插入图片描述"></p> 
<center>
  BERT 是深度双向的，OpenAI GPT 是单向的，ELMo 是浅度双向的。 
</center> 
<h3><a id="_22"></a>双向性的力量</h3> 
<p>如果双向性如此强大，为什么以前没有这样做呢？要理解原因，请考虑通过根据句子中前面的单词预测每个单词来有效地训练单向模型。然而，不可能通过简单地根据每个单词的前一个和下一个单词来训练双向模型，因为这将允许被预测的单词在多层模型中间接“看到自己”。</p> 
<p>为了解决这个问题，我们使用简单的技术来屏蔽输入中的一些单词，然后双向调节每个单词以预测屏蔽的单词。例如：</p> 
<p><img src="https://images2.imgbox.com/3a/01/U50EwHWd_o.png" alt="在这里插入图片描述"></p> 
<p>虽然这个想法已经存在很长时间了，但 BERT 是第一次成功地将其用于预训练深度神经网络。</p> 
<p>BERT 还通过预训练一个非常简单的任务来学习建模句子之间的关系，该任务可以从任何文本语料库生成：给定两个句子 A 和 B，B 是语料库中 A 之后的实际下一个句子，还是只是一个随机句子？例如：</p> 
<p><img src="https://images2.imgbox.com/b5/ce/wPXqf7aY_o.png" alt="在这里插入图片描述"></p> 
<h3><a id="_TPU__35"></a>使用云 TPU 进行训练</h3> 
<p>到目前为止我们所描述的一切似乎都相当简单，那么它缺少什么让它工作得这么好呢？云 TPU。云 TPU 使我们能够自由地快速实验、调试和调整我们的模型，这对于我们超越现有的预训练技术至关重要。 Google 研究人员于 2017 年开发的 Transformer 模型架构也为我们奠定了 BERT 成功所需的基础。 Transformer 在我们的开源版本以及tensor2tensor 库中实现。</p> 
<h3><a id="BERT__39"></a>BERT 结果</h3> 
<p>为了评估性能，我们将 BERT 与其他最先进的 NLP 系统进行了比较。重要的是，BERT 取得了所有成果，几乎没有对神经网络架构进行任何针对特定任务的更改。在 SQuAD v1.1 上，BERT 达到了 93.2% 的 F1 分数（准确度衡量标准），超过了之前 91.6% 的最先进分数和 91.2% 的人类水平分数：</p> 
<p><img src="https://images2.imgbox.com/98/8f/QOHIXZiX_o.png" alt="在这里插入图片描述"></p> 
<p>BERT 还在极具挑战性的 GLUE 基准（一组 9 种不同的自然语言理解 (NLU) 任务）上将最先进的技术绝对提高了 7.6%。这些任务中人工标记的训练数据量从 2,500 个示例到 400,000 个示例不等，BERT 大大提高了所有这些任务的最先进的准确性：</p> 
<p><img src="https://images2.imgbox.com/15/d4/kQ0nhWfq_o.png" alt="在这里插入图片描述"></p> 
<h3><a id="_BERT__48"></a>让 BERT 为您服务</h3> 
<p>我们发布的模型可以在几个小时或更短的时间内针对各种 NLP 任务进行微调。开源版本还包括运行预训练的代码，尽管我们相信大多数使用 BERT 的 NLP 研究人员永远不需要从头开始预训练自己的模型。我们今天发布的 BERT 模型仅支持英语，但我们希望在不久的将来发布经过多种语言预训练的模型。</p> 
<p>开源 TensorFlow 实现和预训练 BERT 模型的指针可以在 http://goo.gl/language/bert 上找到。或者，您可以通过 Colab 笔记本电脑“BERT FineTuning with Cloud TPUs”开始使用 BERT。</p> 
<p>您还可以阅读我们的论文“BERT：用于语言理解的深度双向变压器的预训练”了解更多详细信息。</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/d96bc2721ffcece806f5fa3aeafb445d/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">xftp7免费版安装教程（详细）</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/8036e7d37b16b425f643a078b97b951a/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">Compose视图的编写</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>