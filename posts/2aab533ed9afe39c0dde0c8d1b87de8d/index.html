<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Redis常见架构及其原理 - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Redis常见架构及其原理" />
<meta property="og:description" content=" Redis常见架构及其原理 主从架构Redis主从数据如何同步？全量同步数据部分数据同步 主从复制风暴 哨兵架构sentinel会与主从服务器建立连接sentinel感知主节点下线sentinel选举流程 集群架构集群的数据存储计算key落入哪个槽位跳转重定位集群的选举原理集群脑裂问题 总结 主从架构 简单的主从架构就是一个master节点，两个slave节点。
Redis主从数据如何同步？ Redis主从架构同步数据分为两种情况：1、全量同步数据 2、部分数据同步。
全量同步数据 当slave和master建立长链接后，slave就会发送psync命令要求同步数据master接收到psync命令后，就会先执行bgsave，将内存的数据生成rdb快照在master生成rdb快照期间，如果还有命令要执行，会缓存到repl buffer当中master将生成的rdb数据发送给slaveslave接收到rdb快照后，会清除本地的旧数据，然后再将rdb加载到内存中master将缓存的buffer数据发送给slaveslave接收到缓存的buffer数据，会重做本地数据master通过长链接发送命令，实现主从数据一致性 部分数据同步 主节点和从节点都会维护一个复制偏移量——offset，如果从节点完整复制了主节点的数据，那么主从节点的复制偏移量就是相同的。
master会缓存近期的一些写操作命令，缓存在repl buffer中，默认大小是1mb。slave节点断开重连后建立socket长链接slave发送psync(offset)命令要求同步数据master的buffer中如果有offset，那么将会把offset之后的所有数据都发送给slave，否则将全量同步数据master通过socket长链接发送数据，实现主从数据一致性 主从复制风暴 当一个主节点有多个从节点时，在同一时刻多个从节点都要同步数据，那么主节点在这一刻的压力会非常大，可能导致主节点出现问题——这个就是主从复制风暴。
为了解决这个问题，可以将主从的架构设置成梯形的，也就是从节点也可以是主节点。
哨兵架构 在主从架构中，虽然能解决一定的并发和读写分离，但是整个主从架构不是高可用的。一旦主节点下线后，只能人为介入切换主节点，为了解决这个问题，sentinel(哨兵)架构就应运而生。
哨兵是特殊的redis服务，不提供读写服务，主要就是用来监控redis节点。
sentinel会与主从服务器建立连接 sentinel一旦和主从服务器建立连接后，就能感知到哪个节点是master。当client第一次连接时，sentinel会返回主节点的信息给client，后续client就直接和master进行通信。
sentinel感知主节点下线 sentinel会定期发送PING命令给其它节点，根据节点是否回复PONG命令来判断哪些节点已下线。一旦sentinel发现master下线，就会选举新的master，然后推送给client。
sentinel选举流程 当某个sentinel发现master下线后，会将自己设置成leader当该sentienl得到了半数以上节点的同意，就会成为sentinel leadersentinel leader开始选取一个存活的slave节点作为新的master，然后推送给client 集群架构 集群的数据存储 redis cluster是通过逻辑槽位来划分数据，redis cluster总共将所有数据划分为16384个slot(槽位),然后每个节点负责一部分槽位的数据进行存储。
计算key落入哪个槽位 通过对key使用CRC16进行hash运算，得到一个hash值，然后再使用hash值和16384进行与运算，得到最终的槽位信息。
计算公式：Hash_slot = CRC16(key) &amp; 16384。
跳转重定位 当服务端发生槽位信息变动时，客户端可能没有感知到最新的槽位信息，让然使用旧的槽位向服务器发送写命令。
当服务器发现该槽位不属于我这个节点管理时，会给客户端响应一个重定位的信息，并附带该槽位对应的节点信息。客户端接收到新的槽位信息后，会更新本地缓存的槽位信息，然后再次发送指令给服务器。
集群的选举原理 当某个slave发现它的master下线后，会对外广播failover信息，然后开始竞选master，当某个slave节点拥有半数以上的投票结果时，这个slave节点就会成为新的master。
选举流程：
slave发现master的状态变成failslave会对外广播failover信息，然后集群的选举周期&#43;1其它节点接收到广播后，只有master才会响应，并且返回ack当该slave节点拥有半数以上的ack时，就成为新的master 当slave发现master下线后，不是立刻发起选举的，而是有一个delay time，这个delay time就是防止多个slave节点竞选master时票数一致，导致选举失败。
集群脑裂问题 当集群中出现网络分区问题时，有多个master对外提供服务，当网络分区恢复时，其中一个master将清空数据，变成salve。这样就会导致部分数据丢失，而redis提供了一个配置项，可以降低数据丢失的风险——min-replicas-to-write 1。
总结 主从架构：能解决读写分离问题，但是只有一个主节点，抗不了很高的并发，主从切换也不支持。哨兵架构：可以自动切换主从节点，但是仍然只有一个主节点，只解决了高可用。集群架构：解决了高可用、高并发问题，还引入了逻辑槽位，将数据进行分片存储，降低了单个小集群的读写压力，还支持水平扩展，整体提升了redis的性能。 " />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/2aab533ed9afe39c0dde0c8d1b87de8d/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-02-11T11:10:19+08:00" />
<meta property="article:modified_time" content="2023-02-11T11:10:19+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Redis常见架构及其原理</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-light">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p></p> 
<div class="toc"> 
 <h4>Redis常见架构及其原理</h4> 
 <ul><li><a href="#_1" rel="nofollow">主从架构</a></li><li><ul><li><a href="#Redis_5" rel="nofollow">Redis主从数据如何同步？</a></li><li><ul><li><a href="#_8" rel="nofollow">全量同步数据</a></li><li><a href="#_19" rel="nofollow">部分数据同步</a></li></ul> 
   </li><li><a href="#_29" rel="nofollow">主从复制风暴</a></li></ul> 
  </li><li><a href="#_34" rel="nofollow">哨兵架构</a></li><li><ul><li><a href="#sentinel_38" rel="nofollow">sentinel会与主从服务器建立连接</a></li><li><a href="#sentinel_41" rel="nofollow">sentinel感知主节点下线</a></li><li><a href="#sentinel_44" rel="nofollow">sentinel选举流程</a></li></ul> 
  </li><li><a href="#_50" rel="nofollow">集群架构</a></li><li><ul><li><a href="#_51" rel="nofollow">集群的数据存储</a></li><li><a href="#key_54" rel="nofollow">计算key落入哪个槽位</a></li><li><a href="#_58" rel="nofollow">跳转重定位</a></li><li><a href="#_62" rel="nofollow">集群的选举原理</a></li><li><a href="#_73" rel="nofollow">集群脑裂问题</a></li></ul> 
  </li><li><a href="#_77" rel="nofollow">总结</a></li></ul> 
</div> 
<p></p> 
<h2><a id="_1"></a>主从架构</h2> 
<blockquote> 
 <p>简单的主从架构就是一个master节点，两个slave节点。</p> 
</blockquote> 
<p><img src="https://images2.imgbox.com/33/b3/vd0KezX5_o.jpg" alt=""></p> 
<h3><a id="Redis_5"></a>Redis主从数据如何同步？</h3> 
<p>Redis主从架构同步数据分为两种情况：1、全量同步数据 2、部分数据同步。</p> 
<h4><a id="_8"></a>全量同步数据</h4> 
<ul><li>当slave和master建立长链接后，slave就会发送psync命令要求同步数据</li><li>master接收到psync命令后，就会先执行bgsave，将内存的数据生成rdb快照</li><li>在master生成rdb快照期间，如果还有命令要执行，会缓存到repl buffer当中</li><li>master将生成的rdb数据发送给slave</li><li>slave接收到rdb快照后，会清除本地的旧数据，然后再将rdb加载到内存中</li><li>master将缓存的buffer数据发送给slave</li><li>slave接收到缓存的buffer数据，会重做本地数据</li><li>master通过长链接发送命令，实现主从数据一致性</li></ul> 
<p><img src="https://images2.imgbox.com/e0/23/OamuDMG7_o.png" alt=""></p> 
<h4><a id="_19"></a>部分数据同步</h4> 
<blockquote> 
 <p>主节点和从节点都会维护一个复制偏移量——offset，如果从节点完整复制了主节点的数据，那么主从节点的复制偏移量就是相同的。</p> 
</blockquote> 
<ul><li>master会缓存近期的一些写操作命令，缓存在repl buffer中，默认大小是1mb。</li><li>slave节点断开重连后建立socket长链接</li><li>slave发送psync(offset)命令要求同步数据</li><li>master的buffer中如果有offset，那么将会把offset之后的所有数据都发送给slave，否则将全量同步数据</li><li>master通过socket长链接发送数据，实现主从数据一致性</li></ul> 
<p><img src="https://images2.imgbox.com/84/cb/K4rO1Edm_o.png" alt=""></p> 
<h3><a id="_29"></a>主从复制风暴</h3> 
<blockquote> 
 <p>当一个主节点有多个从节点时，在同一时刻多个从节点都要同步数据，那么主节点在这一刻的压力会非常大，可能导致主节点出现问题——这个就是主从复制风暴。<br> 为了解决这个问题，可以将主从的架构设置成梯形的，也就是从节点也可以是主节点。</p> 
</blockquote> 
<p><img src="https://images2.imgbox.com/d8/3a/BoUNR3AX_o.png" alt=""></p> 
<h2><a id="_34"></a>哨兵架构</h2> 
<blockquote> 
 <p>在主从架构中，虽然能解决一定的并发和读写分离，但是整个主从架构不是高可用的。一旦主节点下线后，只能人为介入切换主节点，为了解决这个问题，sentinel(哨兵)架构就应运而生。<br> 哨兵是特殊的redis服务，不提供读写服务，主要就是用来监控redis节点。</p> 
</blockquote> 
<h3><a id="sentinel_38"></a>sentinel会与主从服务器建立连接</h3> 
<blockquote> 
 <p>sentinel一旦和主从服务器建立连接后，就能感知到哪个节点是master。当client第一次连接时，sentinel会返回主节点的信息给client，后续client就直接和master进行通信。</p> 
</blockquote> 
<h3><a id="sentinel_41"></a>sentinel感知主节点下线</h3> 
<blockquote> 
 <p>sentinel会定期发送PING命令给其它节点，根据节点是否回复PONG命令来判断哪些节点已下线。一旦sentinel发现master下线，就会选举新的master，然后推送给client。</p> 
</blockquote> 
<h3><a id="sentinel_44"></a>sentinel选举流程</h3> 
<ul><li>当某个sentinel发现master下线后，会将自己设置成leader</li><li>当该sentienl得到了半数以上节点的同意，就会成为sentinel leader</li><li>sentinel leader开始选取一个存活的slave节点作为新的master，然后推送给client</li></ul> 
<p><img src="https://images2.imgbox.com/1f/8d/PlHzpfCB_o.png" alt=""></p> 
<h2><a id="_50"></a>集群架构</h2> 
<h3><a id="_51"></a>集群的数据存储</h3> 
<blockquote> 
 <p>redis cluster是通过逻辑槽位来划分数据，redis cluster总共将所有数据划分为16384个slot(槽位),然后每个节点负责一部分槽位的数据进行存储。</p> 
</blockquote> 
<h3><a id="key_54"></a>计算key落入哪个槽位</h3> 
<blockquote> 
 <p>通过对key使用CRC16进行hash运算，得到一个hash值，然后再使用hash值和16384进行与运算，得到最终的槽位信息。<br> 计算公式：Hash_slot = CRC16(key) &amp; 16384。</p> 
</blockquote> 
<h3><a id="_58"></a>跳转重定位</h3> 
<blockquote> 
 <p>当服务端发生槽位信息变动时，客户端可能没有感知到最新的槽位信息，让然使用旧的槽位向服务器发送写命令。<br> 当服务器发现该槽位不属于我这个节点管理时，会给客户端响应一个重定位的信息，并附带该槽位对应的节点信息。客户端接收到新的槽位信息后，会更新本地缓存的槽位信息，然后再次发送指令给服务器。</p> 
</blockquote> 
<h3><a id="_62"></a>集群的选举原理</h3> 
<blockquote> 
 <p>当某个slave发现它的master下线后，会对外广播failover信息，然后开始竞选master，当某个slave节点拥有半数以上的投票结果时，这个slave节点就会成为新的master。</p> 
</blockquote> 
<p>选举流程：</p> 
<ul><li>slave发现master的状态变成fail</li><li>slave会对外广播failover信息，然后集群的选举周期+1</li><li>其它节点接收到广播后，只有master才会响应，并且返回ack</li><li>当该slave节点拥有半数以上的ack时，就成为新的master</li></ul> 
<blockquote> 
 <p>当slave发现master下线后，不是立刻发起选举的，而是有一个delay time，这个delay time就是防止多个slave节点竞选master时票数一致，导致选举失败。</p> 
</blockquote> 
<h3><a id="_73"></a>集群脑裂问题</h3> 
<blockquote> 
 <p>当集群中出现网络分区问题时，有多个master对外提供服务，当网络分区恢复时，其中一个master将清空数据，变成salve。这样就会导致部分数据丢失，而redis提供了一个配置项，可以降低数据丢失的风险——min-replicas-to-write 1。</p> 
</blockquote> 
<p><img src="https://images2.imgbox.com/8e/fb/CNiJYZta_o.png" alt=""></p> 
<h2><a id="_77"></a>总结</h2> 
<ul><li><strong>主从架构</strong>：能解决读写分离问题，但是只有一个主节点，抗不了很高的并发，主从切换也不支持。</li><li><strong>哨兵架构</strong>：可以自动切换主从节点，但是仍然只有一个主节点，只解决了高可用。</li><li><strong>集群架构</strong>：解决了高可用、高并发问题，还引入了逻辑槽位，将数据进行分片存储，降低了单个小集群的读写压力，还支持水平扩展，整体提升了redis的性能。</li></ul>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/0c2a140540c36efcdff85359a8ed3ec8/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">Python数据结构11：树的实现，树的应用，前中后序遍历，二叉查找树BST，平衡二叉树AVL树，哈夫曼树和哈夫曼编码</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/80426bc33614dc6c8dac139cf14f5e79/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">AD中画四层板遇到的过程即问题（全）</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>