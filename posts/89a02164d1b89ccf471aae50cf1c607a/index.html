<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Java实现Excel导入和导出 - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Java实现Excel导入和导出" />
<meta property="og:description" content="一 、环境准备 maven依赖 本次工具类的封装主要依赖于阿里巴巴的JSON包，以及表格处理的POI包，所以我们需要导入这两个库的依赖包，另外，我们还需要文件上传的相关包，毕竟我们在浏览器页面，做Excel导入时，是上传的Excel文件
&lt;!--excel工具依赖 start--&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.httpcomponents&lt;/groupId&gt; &lt;artifactId&gt;httpmime&lt;/artifactId&gt; &lt;version&gt;4.5.7&lt;/version&gt; &lt;/dependency&gt; &lt;!-- JSON --&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;fastjson&lt;/artifactId&gt; &lt;version&gt;1.2.83&lt;/version&gt; &lt;/dependency&gt; &lt;!-- POI --&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.poi&lt;/groupId&gt; &lt;artifactId&gt;poi-ooxml&lt;/artifactId&gt; &lt;version&gt;3.16&lt;/version&gt; &lt;/dependency&gt; &lt;!--excel工具依赖 end--&gt; 引进knife，方便进行测试 &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;version&gt;2.7.8&lt;/version&gt; &lt;/dependency&gt; &lt;!--knife4j start--&gt; &lt;dependency&gt; &lt;groupId&gt;com.github.xiaoymin&lt;/groupId&gt; &lt;artifactId&gt;knife4j-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;2.0.9&lt;/version&gt; &lt;/dependency&gt; &lt;!--knife4j end--&gt; 相关util工具类 public class ExcelClassField { /** 字段名称 */ private String fieldName; /** 表头名称 */ private String name; /** 映射关系 */ private LinkedHashMap&lt;String, String&gt; kvMap; /** 示例值 */ private Object example; /** 排序 */ private int sort; /** 是否为注解字段：0-否，1-是 */ private int hasAnnotation; public String getFieldName() { return fieldName; } public void setFieldName(String fieldName) { this." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/89a02164d1b89ccf471aae50cf1c607a/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2024-01-11T10:57:44+08:00" />
<meta property="article:modified_time" content="2024-01-11T10:57:44+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Java实现Excel导入和导出</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <h3 id="main-toc">一 、环境准备</h3> 
<h4 id="maven%E4%BE%9D%E8%B5%96">maven依赖</h4> 
<p>本次工具类的封装主要依赖于阿里巴巴的JSON包，以及表格处理的POI包，所以我们需要导入这两个库的依赖包，另外，我们还需要文件上传的相关包，毕竟我们在浏览器页面，做Excel导入时，是上传的Excel文件</p> 
<pre><code class="language-java">    &lt;!--excel工具依赖 start--&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.apache.httpcomponents&lt;/groupId&gt;
            &lt;artifactId&gt;httpmime&lt;/artifactId&gt;
            &lt;version&gt;4.5.7&lt;/version&gt;
        &lt;/dependency&gt;
        &lt;!-- JSON --&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;com.alibaba&lt;/groupId&gt;
            &lt;artifactId&gt;fastjson&lt;/artifactId&gt;
            &lt;version&gt;1.2.83&lt;/version&gt;
        &lt;/dependency&gt;
        &lt;!-- POI --&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.apache.poi&lt;/groupId&gt;
            &lt;artifactId&gt;poi-ooxml&lt;/artifactId&gt;
            &lt;version&gt;3.16&lt;/version&gt;
        &lt;/dependency&gt;
    &lt;!--excel工具依赖 end--&gt;</code></pre> 
<h4 id="%E5%BC%95%E8%BF%9Bknife%EF%BC%8C%E6%96%B9%E4%BE%BF%E8%BF%9B%E8%A1%8C%E6%B5%8B%E8%AF%95">引进knife，方便进行测试</h4> 
<pre><code class="language-bash">        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
            &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;
            &lt;version&gt;2.7.8&lt;/version&gt;
        &lt;/dependency&gt;

        &lt;!--knife4j start--&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;com.github.xiaoymin&lt;/groupId&gt;
            &lt;artifactId&gt;knife4j-spring-boot-starter&lt;/artifactId&gt;
            &lt;version&gt;2.0.9&lt;/version&gt;
        &lt;/dependency&gt;
        &lt;!--knife4j end--&gt;</code></pre> 
<h4 id="%C2%A0%E7%9B%B8%E5%85%B3util%E5%B7%A5%E5%85%B7%E7%B1%BB"> 相关util工具类</h4> 
<pre><code class="language-java">public class ExcelClassField {
 
    /** 字段名称 */
    private String fieldName;
 
    /** 表头名称 */
    private String name;
 
    /** 映射关系 */
    private LinkedHashMap&lt;String, String&gt; kvMap;
 
    /** 示例值 */
    private Object example;
 
    /** 排序 */
    private int sort;
 
    /** 是否为注解字段：0-否，1-是 */
    private int hasAnnotation;
 
    public String getFieldName() {
        return fieldName;
    }
 
    public void setFieldName(String fieldName) {
        this.fieldName = fieldName;
    }
 
    public String getName() {
        return name;
    }
 
    public void setName(String name) {
        this.name = name;
    }
 
    public LinkedHashMap&lt;String, String&gt; getKvMap() {
        return kvMap;
    }
 
    public void setKvMap(LinkedHashMap&lt;String, String&gt; kvMap) {
        this.kvMap = kvMap;
    }
 
    public Object getExample() {
        return example;
    }
 
    public void setExample(Object example) {
        this.example = example;
    }
 
    public int getSort() {
        return sort;
    }
 
    public void setSort(int sort) {
        this.sort = sort;
    }
 
    public int getHasAnnotation() {
        return hasAnnotation;
    }
 
    public void setHasAnnotation(int hasAnnotation) {
        this.hasAnnotation = hasAnnotation;
    }
 
}</code></pre> 
<pre><code class="language-java">@Target(ElementType.FIELD)
@Retention(RetentionPolicy.RUNTIME)
public @interface ExcelExport {
 
    /** 字段名称 */
    String value();
 
    /** 导出排序先后: 数字越小越靠前（默认按Java类字段顺序导出） */
    int sort() default 0;
 
    /** 导出映射，格式如：0-未知;1-男;2-女 */
    String kv() default "";
 
    /** 导出模板示例值（有值的话，直接取该值，不做映射） */
    String example() default "";
 
}</code></pre> 
<pre><code class="language-java">@Target(ElementType.FIELD)
@Retention(RetentionPolicy.RUNTIME)
public @interface ExcelImport {
 
    /** 字段名称 */
    String value();
 
    /** 导出映射，格式如：0-未知;1-男;2-女 */
    String kv() default "";
 
    /** 是否为必填字段（默认为非必填） */
    boolean required() default false;
 
    /** 最大长度（默认255） */
    int maxLength() default 255;
 
    /** 导入唯一性验证（多个字段则取联合验证） */
    boolean unique() default false;
 
}</code></pre> 
<pre><code class="language-java">/**
 * Excel导入导出工具类
 *
 */
@SuppressWarnings("unused")
public class ExcelUtils {
 
    private static final String XLSX = ".xlsx";
    private static final String XLS = ".xls";
    public static final String ROW_MERGE = "row_merge";
    public static final String COLUMN_MERGE = "column_merge";
    private static final String DATE_FORMAT = "yyyy-MM-dd HH:mm:ss";
    private static final String ROW_NUM = "rowNum";
    private static final String ROW_DATA = "rowData";
    private static final String ROW_TIPS = "rowTips";
    private static final int CELL_OTHER = 0;
    private static final int CELL_ROW_MERGE = 1;
    private static final int CELL_COLUMN_MERGE = 2;
    private static final int IMG_HEIGHT = 30;
    private static final int IMG_WIDTH = 30;
    private static final char LEAN_LINE = '/';
    private static final int BYTES_DEFAULT_LENGTH = 10240;
    private static final NumberFormat NUMBER_FORMAT = NumberFormat.getNumberInstance();
 
 
    public static &lt;T&gt; List&lt;T&gt; readFile(File file, Class&lt;T&gt; clazz) throws Exception {
        JSONArray array = readFile(file);
        return getBeanList(array, clazz);
    }
 
    public static &lt;T&gt; List&lt;T&gt; readMultipartFile(MultipartFile mFile, Class&lt;T&gt; clazz) throws Exception {
        JSONArray array = readMultipartFile(mFile);
        return getBeanList(array, clazz);
    }
 
    public static JSONArray readFile(File file) throws Exception {
        return readExcel(null, file);
    }
 
    public static JSONArray readMultipartFile(MultipartFile mFile) throws Exception {
        return readExcel(mFile, null);
    }
 
    public static Map&lt;String, JSONArray&gt; readFileManySheet(File file) throws Exception {
        return readExcelManySheet(null, file);
    }
 
    public static Map&lt;String, JSONArray&gt; readFileManySheet(MultipartFile file) throws Exception {
        return readExcelManySheet(file, null);
    }
 
    private static &lt;T&gt; List&lt;T&gt; getBeanList(JSONArray array, Class&lt;T&gt; clazz) throws Exception {
        List&lt;T&gt; list = new ArrayList&lt;&gt;();
        Map&lt;Integer, String&gt; uniqueMap = new HashMap&lt;&gt;(16);
        for (int i = 0; i &lt; array.size(); i++) {
            T bean = getBean(clazz, array.getJSONObject(i), uniqueMap);
            list.add(bean);
        }
        return list;
    }
 
    /**
     * 获取每个对象的数据
     */
    private static &lt;T&gt; T getBean(Class&lt;T&gt; c, JSONObject obj, Map&lt;Integer, String&gt; uniqueMap) throws Exception {
        T t = c.newInstance();
        Field[] fields = c.getDeclaredFields();
        List&lt;String&gt; errMsgList = new ArrayList&lt;&gt;();
        boolean hasRowTipsField = false;
        StringBuilder uniqueBuilder = new StringBuilder();
        int rowNum = 0;
        for (Field field : fields) {
            // 行号
            if (field.getName().equals(ROW_NUM)) {
                rowNum = obj.getInteger(ROW_NUM);
                field.setAccessible(true);
                field.set(t, rowNum);
                continue;
            }
            // 是否需要设置异常信息
            if (field.getName().equals(ROW_TIPS)) {
                hasRowTipsField = true;
                continue;
            }
            // 原始数据
            if (field.getName().equals(ROW_DATA)) {
                field.setAccessible(true);
                field.set(t, obj.toString());
                continue;
            }
            // 设置对应属性值
            setFieldValue(t, field, obj, uniqueBuilder, errMsgList);
        }
        // 数据唯一性校验
        if (uniqueBuilder.length() &gt; 0) {
            if (uniqueMap.containsValue(uniqueBuilder.toString())) {
                Set&lt;Integer&gt; rowNumKeys = uniqueMap.keySet();
                for (Integer num : rowNumKeys) {
                    if (uniqueMap.get(num).equals(uniqueBuilder.toString())) {
                        errMsgList.add(String.format("数据唯一性校验失败,(%s)与第%s行重复)", uniqueBuilder, num));
                    }
                }
            } else {
                uniqueMap.put(rowNum, uniqueBuilder.toString());
            }
        }
        // 失败处理
        if (errMsgList.isEmpty() &amp;&amp; !hasRowTipsField) {
            return t;
        }
        StringBuilder sb = new StringBuilder();
        int size = errMsgList.size();
        for (int i = 0; i &lt; size; i++) {
            if (i == size - 1) {
                sb.append(errMsgList.get(i));
            } else {
                sb.append(errMsgList.get(i)).append(";");
            }
        }
        // 设置错误信息
        for (Field field : fields) {
            if (field.getName().equals(ROW_TIPS)) {
                field.setAccessible(true);
                field.set(t, sb.toString());
            }
        }
        return t;
    }
 
    private static &lt;T&gt; void setFieldValue(T t, Field field, JSONObject obj, StringBuilder uniqueBuilder, List&lt;String&gt; errMsgList) {
        // 获取 ExcelImport 注解属性
        ExcelImport annotation = field.getAnnotation(ExcelImport.class);
        if (annotation == null) {
            return;
        }
        String cname = annotation.value();
        if (cname.trim().length() == 0) {
            return;
        }
        // 获取具体值
        String val = null;
        if (obj.containsKey(cname)) {
            val = getString(obj.getString(cname));
        }
        if (val == null) {
            return;
        }
        field.setAccessible(true);
        // 判断是否必填
        boolean require = annotation.required();
        if (require &amp;&amp; val.isEmpty()) {
            errMsgList.add(String.format("[%s]不能为空", cname));
            return;
        }
        // 数据唯一性获取
        boolean unique = annotation.unique();
        if (unique) {
            if (uniqueBuilder.length() &gt; 0) {
                uniqueBuilder.append("--").append(val);
            } else {
                uniqueBuilder.append(val);
            }
        }
        // 判断是否超过最大长度
        int maxLength = annotation.maxLength();
        if (maxLength &gt; 0 &amp;&amp; val.length() &gt; maxLength) {
            errMsgList.add(String.format("[%s]长度不能超过%s个字符(当前%s个字符)", cname, maxLength, val.length()));
        }
        // 判断当前属性是否有映射关系
        LinkedHashMap&lt;String, String&gt; kvMap = getKvMap(annotation.kv());
        if (!kvMap.isEmpty()) {
            boolean isMatch = false;
            for (String key : kvMap.keySet()) {
                if (kvMap.get(key).equals(val)) {
                    val = key;
                    isMatch = true;
                    break;
                }
            }
            if (!isMatch) {
                errMsgList.add(String.format("[%s]的值不正确(当前值为%s)", cname, val));
                return;
            }
        }
        // 其余情况根据类型赋值
        String fieldClassName = field.getType().getSimpleName();
        try {
            if ("String".equalsIgnoreCase(fieldClassName)) {
                field.set(t, val);
            } else if ("boolean".equalsIgnoreCase(fieldClassName)) {
                field.set(t, Boolean.valueOf(val));
            } else if ("int".equalsIgnoreCase(fieldClassName) || "Integer".equals(fieldClassName)) {
                try {
                    field.set(t, Integer.valueOf(val));
                } catch (NumberFormatException e) {
                    errMsgList.add(String.format("[%s]的值格式不正确(当前值为%s)", cname, val));
                }
            } else if ("double".equalsIgnoreCase(fieldClassName)) {
                field.set(t, Double.valueOf(val));
            } else if ("long".equalsIgnoreCase(fieldClassName)) {
                field.set(t, Long.valueOf(val));
            } else if ("BigDecimal".equalsIgnoreCase(fieldClassName)) {
                field.set(t, new BigDecimal(val));
            } else if ("Date".equalsIgnoreCase(fieldClassName)) {
                try {
                    field.set(t, new SimpleDateFormat("yyyy-MM-dd HH:mm:ss").parse(val));
                } catch (Exception e) {
                    field.set(t, new SimpleDateFormat("yyyy-MM-dd").parse(val));
                }
            }
        } catch (Exception e) {
            e.printStackTrace();
        }
    }
 
    private static Map&lt;String, JSONArray&gt; readExcelManySheet(MultipartFile mFile, File file) throws IOException {
        Workbook book = getWorkbook(mFile, file);
        if (book == null) {
            return Collections.emptyMap();
        }
        Map&lt;String, JSONArray&gt; map = new LinkedHashMap&lt;&gt;();
        for (int i = 0; i &lt; book.getNumberOfSheets(); i++) {
            Sheet sheet = book.getSheetAt(i);
            JSONArray arr = readSheet(sheet);
            map.put(sheet.getSheetName(), arr);
        }
        book.close();
        return map;
    }
 
    private static JSONArray readExcel(MultipartFile mFile, File file) throws IOException {
        Workbook book = getWorkbook(mFile, file);
        if (book == null) {
            return new JSONArray();
        }
        JSONArray array = readSheet(book.getSheetAt(0));
        book.close();
        return array;
    }
 
    private static Workbook getWorkbook(MultipartFile mFile, File file) throws IOException {
        boolean fileNotExist = (file == null || !file.exists());
        if (mFile == null &amp;&amp; fileNotExist) {
            return null;
        }
        // 解析表格数据
        InputStream in;
        String fileName;
        if (mFile != null) {
            // 上传文件解析
            in = mFile.getInputStream();
            fileName = getString(mFile.getOriginalFilename()).toLowerCase();
        } else {
            // 本地文件解析
            in = new FileInputStream(file);
            fileName = file.getName().toLowerCase();
        }
        Workbook book;
        if (fileName.endsWith(XLSX)) {
            book = new XSSFWorkbook(in);
        } else if (fileName.endsWith(XLS)) {
            POIFSFileSystem poifsFileSystem = new POIFSFileSystem(in);
            book = new HSSFWorkbook(poifsFileSystem);
        } else {
            return null;
        }
        in.close();
        return book;
    }
 
    private static JSONArray readSheet(Sheet sheet) {
        // 首行下标
        int rowStart = sheet.getFirstRowNum();
        // 尾行下标
        int rowEnd = sheet.getLastRowNum();
        // 获取表头行
        Row headRow = sheet.getRow(rowStart);
        if (headRow == null) {
            return new JSONArray();
        }
        int cellStart = headRow.getFirstCellNum();
        int cellEnd = headRow.getLastCellNum();
        Map&lt;Integer, String&gt; keyMap = new HashMap&lt;&gt;();
        for (int j = cellStart; j &lt; cellEnd; j++) {
            // 获取表头数据
            String val = getCellValue(headRow.getCell(j));
            if (val != null &amp;&amp; val.trim().length() != 0) {
                keyMap.put(j, val);
            }
        }
        // 如果表头没有数据则不进行解析
        if (keyMap.isEmpty()) {
            return (JSONArray) Collections.emptyList();
        }
        // 获取每行JSON对象的值
        JSONArray array = new JSONArray();
        // 如果首行与尾行相同，表明只有一行，返回表头数据
        if (rowStart == rowEnd) {
            JSONObject obj = new JSONObject();
            // 添加行号
            obj.put(ROW_NUM, 1);
            for (int i : keyMap.keySet()) {
                obj.put(keyMap.get(i), "");
            }
            array.add(obj);
            return array;
        }
        for (int i = rowStart + 1; i &lt;= rowEnd; i++) {
            Row eachRow = sheet.getRow(i);
            JSONObject obj = new JSONObject();
            // 添加行号
            obj.put(ROW_NUM, i + 1);
            StringBuilder sb = new StringBuilder();
            for (int k = cellStart; k &lt; cellEnd; k++) {
                if (eachRow != null) {
                    String val = getCellValue(eachRow.getCell(k));
                    // 所有数据添加到里面，用于判断该行是否为空
                    sb.append(val);
                    obj.put(keyMap.get(k), val);
                }
            }
            if (sb.length() &gt; 0) {
                array.add(obj);
            }
        }
        return array;
    }
 
    private static String getCellValue(Cell cell) {
        // 空白或空
        if (cell == null || cell.getCellTypeEnum() == CellType.BLANK) {
            return "";
        }
        // String类型
        if (cell.getCellTypeEnum() == CellType.STRING) {
            String val = cell.getStringCellValue();
            if (val == null || val.trim().length() == 0) {
                return "";
            }
            return val.trim();
        }
        // 数字类型
        if (cell.getCellTypeEnum() == CellType.NUMERIC) {
            String s = cell.getNumericCellValue() + "";
            // 去掉尾巴上的小数点0
            if (Pattern.matches(".*\\.0*", s)) {
                return s.split("\\.")[0];
            } else {
                return s;
            }
        }
        // 布尔值类型
        if (cell.getCellTypeEnum() == CellType.BOOLEAN) {
            return cell.getBooleanCellValue() + "";
        }
        // 错误类型
        return cell.getCellFormula();
    }
 
    public static &lt;T&gt; void exportTemplate(HttpServletResponse response, String fileName, Class&lt;T&gt; clazz) {
        exportTemplate(response, fileName, fileName, clazz, false);
    }
 
    public static &lt;T&gt; void exportTemplate(HttpServletResponse response, String fileName, String sheetName,
                                          Class&lt;T&gt; clazz) {
        exportTemplate(response, fileName, sheetName, clazz, false);
    }
 
    public static &lt;T&gt; void exportTemplate(HttpServletResponse response, String fileName, Class&lt;T&gt; clazz,
                                          boolean isContainExample) {
        exportTemplate(response, fileName, fileName, clazz, isContainExample);
    }
 
    public static &lt;T&gt; void exportTemplate(HttpServletResponse response, String fileName, String sheetName,
                                          Class&lt;T&gt; clazz, boolean isContainExample) {
        // 获取表头字段
        List&lt;ExcelClassField&gt; headFieldList = getExcelClassFieldList(clazz);
        // 获取表头数据和示例数据
        List&lt;List&lt;Object&gt;&gt; sheetDataList = new ArrayList&lt;&gt;();
        List&lt;Object&gt; headList = new ArrayList&lt;&gt;();
        List&lt;Object&gt; exampleList = new ArrayList&lt;&gt;();
        Map&lt;Integer, List&lt;String&gt;&gt; selectMap = new LinkedHashMap&lt;&gt;();
        for (int i = 0; i &lt; headFieldList.size(); i++) {
            ExcelClassField each = headFieldList.get(i);
            headList.add(each.getName());
            exampleList.add(each.getExample());
            LinkedHashMap&lt;String, String&gt; kvMap = each.getKvMap();
            if (kvMap != null &amp;&amp; kvMap.size() &gt; 0) {
                selectMap.put(i, new ArrayList&lt;&gt;(kvMap.values()));
            }
        }
        sheetDataList.add(headList);
        if (isContainExample) {
            sheetDataList.add(exampleList);
        }
        // 导出数据
        export(response, fileName, sheetName, sheetDataList, selectMap);
    }
 
    private static &lt;T&gt; List&lt;ExcelClassField&gt; getExcelClassFieldList(Class&lt;T&gt; clazz) {
        // 解析所有字段
        Field[] fields = clazz.getDeclaredFields();
        boolean hasExportAnnotation = false;
        Map&lt;Integer, List&lt;ExcelClassField&gt;&gt; map = new LinkedHashMap&lt;&gt;();
        List&lt;Integer&gt; sortList = new ArrayList&lt;&gt;();
        for (Field field : fields) {
            ExcelClassField cf = getExcelClassField(field);
            if (cf.getHasAnnotation() == 1) {
                hasExportAnnotation = true;
            }
            int sort = cf.getSort();
            if (map.containsKey(sort)) {
                map.get(sort).add(cf);
            } else {
                List&lt;ExcelClassField&gt; list = new ArrayList&lt;&gt;();
                list.add(cf);
                sortList.add(sort);
                map.put(sort, list);
            }
        }
        Collections.sort(sortList);
        // 获取表头
        List&lt;ExcelClassField&gt; headFieldList = new ArrayList&lt;&gt;();
        if (hasExportAnnotation) {
            for (Integer sort : sortList) {
                for (ExcelClassField cf : map.get(sort)) {
                    if (cf.getHasAnnotation() == 1) {
                        headFieldList.add(cf);
                    }
                }
            }
        } else {
            headFieldList.addAll(map.get(0));
        }
        return headFieldList;
    }
 
    private static ExcelClassField getExcelClassField(Field field) {
        ExcelClassField cf = new ExcelClassField();
        String fieldName = field.getName();
        cf.setFieldName(fieldName);
        ExcelExport annotation = field.getAnnotation(ExcelExport.class);
        // 无 ExcelExport 注解情况
        if (annotation == null) {
            cf.setHasAnnotation(0);
            cf.setName(fieldName);
            cf.setSort(0);
            return cf;
        }
        // 有 ExcelExport 注解情况
        cf.setHasAnnotation(1);
        cf.setName(annotation.value());
        String example = getString(annotation.example());
        if (!example.isEmpty()) {
            if (isNumeric(example) &amp;&amp; example.length() &lt; 8) {
                cf.setExample(Double.valueOf(example));
            } else {
                cf.setExample(example);
            }
        } else {
            cf.setExample("");
        }
        cf.setSort(annotation.sort());
        // 解析映射
        String kv = getString(annotation.kv());
        cf.setKvMap(getKvMap(kv));
        return cf;
    }
 
    private static LinkedHashMap&lt;String, String&gt; getKvMap(String kv) {
        LinkedHashMap&lt;String, String&gt; kvMap = new LinkedHashMap&lt;&gt;();
        if (kv.isEmpty()) {
            return kvMap;
        }
        String[] kvs = kv.split(";");
        if (kvs.length == 0) {
            return kvMap;
        }
        for (String each : kvs) {
            String[] eachKv = getString(each).split("-");
            if (eachKv.length != 2) {
                continue;
            }
            String k = eachKv[0];
            String v = eachKv[1];
            if (k.isEmpty() || v.isEmpty()) {
                continue;
            }
            kvMap.put(k, v);
        }
        return kvMap;
    }
 
    /**
     * 导出表格到本地
     *
     * @param file      本地文件对象
     * @param sheetData 导出数据
     */
    public static void exportFile(File file, List&lt;List&lt;Object&gt;&gt; sheetData) {
        if (file == null) {
            System.out.println("文件创建失败");
            return;
        }
        if (sheetData == null) {
            sheetData = new ArrayList&lt;&gt;();
        }
        Map&lt;String, List&lt;List&lt;Object&gt;&gt;&gt; map = new HashMap&lt;&gt;();
        map.put(file.getName(), sheetData);
        export(null, file, file.getName(), map, null);
    }
 
    /**
     * 导出表格到本地
     *
     * @param &lt;T&gt;      导出数据类似，和K类型保持一致
     * @param filePath 文件父路径（如：D:/doc/excel/）
     * @param fileName 文件名称（不带尾缀，如：学生表）
     * @param list     导出数据
     * @throws IOException IO异常
     */
    public static &lt;T&gt; File exportFile(String filePath, String fileName, List&lt;T&gt; list) throws IOException {
        File file = getFile(filePath, fileName);
        List&lt;List&lt;Object&gt;&gt; sheetData = getSheetData(list);
        exportFile(file, sheetData);
        return file;
    }
 
    /**
     * 获取文件
     *
     * @param filePath filePath 文件父路径（如：D:/doc/excel/）
     * @param fileName 文件名称（不带尾缀，如：用户表）
     * @return 本地File文件对象
     */
    private static File getFile(String filePath, String fileName) throws IOException {
        String dirPath = getString(filePath);
        String fileFullPath;
        if (dirPath.isEmpty()) {
            fileFullPath = fileName;
        } else {
            // 判定文件夹是否存在，如果不存在，则级联创建
            File dirFile = new File(dirPath);
            if (!dirFile.exists()) {
                boolean mkdirs = dirFile.mkdirs();
                if (!mkdirs) {
                    return null;
                }
            }
            // 获取文件夹全名
            if (dirPath.endsWith(String.valueOf(LEAN_LINE))) {
                fileFullPath = dirPath + fileName + XLSX;
            } else {
                fileFullPath = dirPath + LEAN_LINE + fileName + XLSX;
            }
        }
        System.out.println(fileFullPath);
        File file = new File(fileFullPath);
        if (!file.exists()) {
            boolean result = file.createNewFile();
            if (!result) {
                return null;
            }
        }
        return file;
    }
 
    private static &lt;T&gt; List&lt;List&lt;Object&gt;&gt; getSheetData(List&lt;T&gt; list) {
        // 获取表头字段
        List&lt;ExcelClassField&gt; excelClassFieldList = getExcelClassFieldList(list.get(0).getClass());
        List&lt;String&gt; headFieldList = new ArrayList&lt;&gt;();
        List&lt;Object&gt; headList = new ArrayList&lt;&gt;();
        Map&lt;String, ExcelClassField&gt; headFieldMap = new HashMap&lt;&gt;();
        for (ExcelClassField each : excelClassFieldList) {
            String fieldName = each.getFieldName();
            headFieldList.add(fieldName);
            headFieldMap.put(fieldName, each);
            headList.add(each.getName());
        }
        // 添加表头名称
        List&lt;List&lt;Object&gt;&gt; sheetDataList = new ArrayList&lt;&gt;();
        sheetDataList.add(headList);
        // 获取表数据
        for (T t : list) {
            Map&lt;String, Object&gt; fieldDataMap = getFieldDataMap(t);
            Set&lt;String&gt; fieldDataKeys = fieldDataMap.keySet();
            List&lt;Object&gt; rowList = new ArrayList&lt;&gt;();
            for (String headField : headFieldList) {
                if (!fieldDataKeys.contains(headField)) {
                    continue;
                }
                Object data = fieldDataMap.get(headField);
                if (data == null) {
                    rowList.add("");
                    continue;
                }
                ExcelClassField cf = headFieldMap.get(headField);
                // 判断是否有映射关系
                LinkedHashMap&lt;String, String&gt; kvMap = cf.getKvMap();
                if (kvMap == null || kvMap.isEmpty()) {
                    rowList.add(data);
                    continue;
                }
                String val = kvMap.get(data.toString());
                if (isNumeric(val)) {
                    rowList.add(Double.valueOf(val));
                } else {
                    rowList.add(val);
                }
            }
            sheetDataList.add(rowList);
        }
        return sheetDataList;
    }
 
    private static &lt;T&gt; Map&lt;String, Object&gt; getFieldDataMap(T t) {
        Map&lt;String, Object&gt; map = new HashMap&lt;&gt;();
        Field[] fields = t.getClass().getDeclaredFields();
        try {
            for (Field field : fields) {
                String fieldName = field.getName();
                field.setAccessible(true);
                Object object = field.get(t);
                map.put(fieldName, object);
            }
        } catch (IllegalArgumentException | IllegalAccessException e) {
            e.printStackTrace();
        }
        return map;
    }
 
    public static void exportEmpty(HttpServletResponse response, String fileName) {
        List&lt;List&lt;Object&gt;&gt; sheetDataList = new ArrayList&lt;&gt;();
        List&lt;Object&gt; headList = new ArrayList&lt;&gt;();
        headList.add("导出无数据");
        sheetDataList.add(headList);
        export(response, fileName, sheetDataList);
    }
 
    public static void export(HttpServletResponse response, String fileName, List&lt;List&lt;Object&gt;&gt; sheetDataList) {
        export(response, fileName, fileName, sheetDataList, null);
    }
 
    public static void exportManySheet(HttpServletResponse response, String fileName, Map&lt;String, List&lt;List&lt;Object&gt;&gt;&gt; sheetMap) {
        export(response, null, fileName, sheetMap, null);
    }
 
 
    public static void export(HttpServletResponse response, String fileName, String sheetName,
                              List&lt;List&lt;Object&gt;&gt; sheetDataList) {
        export(response, fileName, sheetName, sheetDataList, null);
    }
 
    public static void export(HttpServletResponse response, String fileName, String sheetName,
                              List&lt;List&lt;Object&gt;&gt; sheetDataList, Map&lt;Integer, List&lt;String&gt;&gt; selectMap) {
 
        Map&lt;String, List&lt;List&lt;Object&gt;&gt;&gt; map = new HashMap&lt;&gt;();
        map.put(sheetName, sheetDataList);
        export(response, null, fileName, map, selectMap);
    }
 
    public static &lt;T, K&gt; void export(HttpServletResponse response, String fileName, List&lt;T&gt; list, Class&lt;K&gt; template) {
        // list 是否为空
        boolean lisIsEmpty = list == null || list.isEmpty();
        // 如果模板数据为空，且导入的数据为空，则导出空文件
        if (template == null &amp;&amp; lisIsEmpty) {
            exportEmpty(response, fileName);
            return;
        }
        // 如果 list 数据，则导出模板数据
        if (lisIsEmpty) {
            exportTemplate(response, fileName, template);
            return;
        }
        // 导出数据
        List&lt;List&lt;Object&gt;&gt; sheetDataList = getSheetData(list);
        export(response, fileName, sheetDataList);
    }
 
    public static void export(HttpServletResponse response, String fileName, List&lt;List&lt;Object&gt;&gt; sheetDataList, Map&lt;Integer, List&lt;String&gt;&gt; selectMap) {
        export(response, fileName, fileName, sheetDataList, selectMap);
    }
 
    private static void export(HttpServletResponse response, File file, String fileName,
                               Map&lt;String, List&lt;List&lt;Object&gt;&gt;&gt; sheetMap, Map&lt;Integer, List&lt;String&gt;&gt; selectMap) {
        // 整个 Excel 表格 book 对象
        SXSSFWorkbook book = new SXSSFWorkbook();
        // 每个 Sheet 页
        Set&lt;Entry&lt;String, List&lt;List&lt;Object&gt;&gt;&gt;&gt; entries = sheetMap.entrySet();
        for (Entry&lt;String, List&lt;List&lt;Object&gt;&gt;&gt; entry : entries) {
            List&lt;List&lt;Object&gt;&gt; sheetDataList = entry.getValue();
            Sheet sheet = book.createSheet(entry.getKey());
            Drawing&lt;?&gt; patriarch = sheet.createDrawingPatriarch();
            // 设置表头背景色（灰色）
            CellStyle headStyle = book.createCellStyle();
            headStyle.setFillForegroundColor(IndexedColors.GREY_80_PERCENT.index);
            headStyle.setFillPattern(FillPatternType.SOLID_FOREGROUND);
            headStyle.setAlignment(HorizontalAlignment.CENTER);
            headStyle.setFillForegroundColor(IndexedColors.GREY_25_PERCENT.index);
            // 设置表身背景色（默认色）
            CellStyle rowStyle = book.createCellStyle();
            rowStyle.setAlignment(HorizontalAlignment.CENTER);
            rowStyle.setVerticalAlignment(VerticalAlignment.CENTER);
            // 设置表格列宽度（默认为15个字节）
            sheet.setDefaultColumnWidth(15);
            // 创建合并算法数组
            int rowLength = sheetDataList.size();
            int columnLength = sheetDataList.get(0).size();
            int[][] mergeArray = new int[rowLength][columnLength];
            for (int i = 0; i &lt; sheetDataList.size(); i++) {
                // 每个 Sheet 页中的行数据
                Row row = sheet.createRow(i);
                List&lt;Object&gt; rowList = sheetDataList.get(i);
                for (int j = 0; j &lt; rowList.size(); j++) {
                    // 每个行数据中的单元格数据
                    Object o = rowList.get(j);
                    int v = 0;
                    if (o instanceof URL) {
                        // 如果要导出图片的话, 链接需要传递 URL 对象
                        setCellPicture(book, row, patriarch, i, j, (URL) o);
                    } else {
                        Cell cell = row.createCell(j);
                        if (i == 0) {
                            // 第一行为表头行，采用灰色底背景
                            v = setCellValue(cell, o, headStyle);
                        } else {
                            // 其他行为数据行，默认白底色
                            v = setCellValue(cell, o, rowStyle);
                        }
                    }
                    mergeArray[i][j] = v;
                }
            }
            // 合并单元格
            mergeCells(sheet, mergeArray);
            // 设置下拉列表
            setSelect(sheet, selectMap);
        }
        // 写数据
        if (response != null) {
            // 前端导出
            try {
                write(response, book, fileName);
            } catch (IOException e) {
                e.printStackTrace();
            }
        } else {
            // 本地导出
            FileOutputStream fos;
            try {
                fos = new FileOutputStream(file);
                ByteArrayOutputStream ops = new ByteArrayOutputStream();
                book.write(ops);
                fos.write(ops.toByteArray());
                fos.close();
            } catch (Exception e) {
                e.printStackTrace();
            }
        }
    }
 
    /**
     * 合并当前Sheet页的单元格
     *
     * @param sheet      当前 sheet 页
     * @param mergeArray 合并单元格算法
     */
    private static void mergeCells(Sheet sheet, int[][] mergeArray) {
        // 横向合并
        for (int x = 0; x &lt; mergeArray.length; x++) {
            int[] arr = mergeArray[x];
            boolean merge = false;
            int y1 = 0;
            int y2 = 0;
            for (int y = 0; y &lt; arr.length; y++) {
                int value = arr[y];
                if (value == CELL_COLUMN_MERGE) {
                    if (!merge) {
                        y1 = y;
                    }
                    y2 = y;
                    merge = true;
                } else {
                    merge = false;
                    if (y1 &gt; 0) {
                        sheet.addMergedRegion(new CellRangeAddress(x, x, (y1 - 1), y2));
                    }
                    y1 = 0;
                    y2 = 0;
                }
            }
            if (y1 &gt; 0) {
                sheet.addMergedRegion(new CellRangeAddress(x, x, (y1 - 1), y2));
            }
        }
        // 纵向合并
        int xLen = mergeArray.length;
        int yLen = mergeArray[0].length;
        for (int y = 0; y &lt; yLen; y++) {
            boolean merge = false;
            int x1 = 0;
            int x2 = 0;
            for (int x = 0; x &lt; xLen; x++) {
                int value = mergeArray[x][y];
                if (value == CELL_ROW_MERGE) {
                    if (!merge) {
                        x1 = x;
                    }
                    x2 = x;
                    merge = true;
                } else {
                    merge = false;
                    if (x1 &gt; 0) {
                        sheet.addMergedRegion(new CellRangeAddress((x1 - 1), x2, y, y));
                    }
                    x1 = 0;
                    x2 = 0;
                }
            }
            if (x1 &gt; 0) {
                sheet.addMergedRegion(new CellRangeAddress((x1 - 1), x2, y, y));
            }
        }
    }
 
    private static void write(HttpServletResponse response, SXSSFWorkbook book, String fileName) throws IOException {
        response.setContentType("application/vnd.openxmlformats-officedocument.spreadsheetml.sheet");
        response.setCharacterEncoding("utf-8");
        String name = new String(fileName.getBytes("GBK"), "ISO8859_1") + XLSX;
        response.addHeader("Content-Disposition", "attachment;filename=" + name);
        ServletOutputStream out = response.getOutputStream();
        book.write(out);
        out.flush();
        out.close();
    }
 
    private static int setCellValue(Cell cell, Object o, CellStyle style) {
        // 设置样式
        cell.setCellStyle(style);
        // 数据为空时
        if (o == null || o.equals("")) {
            cell.setCellType(CellType.STRING);
            cell.setCellValue("");
            return CELL_OTHER;
        }
        // 是否为字符串
        if (o instanceof String) {
            String s = o.toString();
            // 当数字类型长度超过8位时，改为字符串类型显示（Excel数字超过一定长度会显示为科学计数法）
            if (isNumeric(s) &amp;&amp; s.length() &lt; 8) {
                cell.setCellType(CellType.NUMERIC);
                cell.setCellValue(Double.parseDouble(s));
                return CELL_OTHER;
            } else {
                cell.setCellType(CellType.STRING);
                cell.setCellValue(s);
            }
            if (s.equals(ROW_MERGE)) {
                return CELL_ROW_MERGE;
            } else if (s.equals(COLUMN_MERGE)) {
                return CELL_COLUMN_MERGE;
            } else {
                return CELL_OTHER;
            }
        }
        // 是否为字符串
        if (o instanceof Integer || o instanceof Long || o instanceof Double || o instanceof Float) {
            cell.setCellType(CellType.NUMERIC);
            cell.setCellValue(Double.parseDouble(o.toString()));
            return CELL_OTHER;
        }
        // 是否为Boolean
        if (o instanceof Boolean) {
            cell.setCellType(CellType.BOOLEAN);
            cell.setCellValue((Boolean) o);
            return CELL_OTHER;
        }
        // 如果是BigDecimal，则默认3位小数
        if (o instanceof BigDecimal) {
            cell.setCellType(CellType.NUMERIC);
            cell.setCellValue(((BigDecimal) o).setScale(3, RoundingMode.HALF_UP).doubleValue());
            return CELL_OTHER;
        }
        // 如果是Date数据，则显示格式化数据
        if (o instanceof Date) {
            cell.setCellType(CellType.STRING);
            cell.setCellValue(formatDate((Date) o));
            return CELL_OTHER;
        }
        // 如果是其他，则默认字符串类型
        cell.setCellType(CellType.STRING);
        cell.setCellValue(o.toString());
        return CELL_OTHER;
    }
 
    private static void setCellPicture(SXSSFWorkbook wb, Row sr, Drawing&lt;?&gt; patriarch, int x, int y, URL url) {
        // 设置图片宽高
        sr.setHeight((short) (IMG_WIDTH * IMG_HEIGHT));
        // （jdk1.7版本try中定义流可自动关闭）
        try (InputStream is = url.openStream(); ByteArrayOutputStream outputStream = new ByteArrayOutputStream()) {
            byte[] buff = new byte[BYTES_DEFAULT_LENGTH];
            int rc;
            while ((rc = is.read(buff, 0, BYTES_DEFAULT_LENGTH)) &gt; 0) {
                outputStream.write(buff, 0, rc);
            }
            // 设置图片位置
            XSSFClientAnchor anchor = new XSSFClientAnchor(0, 0, 0, 0, y, x, y + 1, x + 1);
            // 设置这个，图片会自动填满单元格的长宽
            anchor.setAnchorType(AnchorType.MOVE_AND_RESIZE);
            patriarch.createPicture(anchor, wb.addPicture(outputStream.toByteArray(), HSSFWorkbook.PICTURE_TYPE_JPEG));
        } catch (Exception e) {
            e.printStackTrace();
        }
    }
 
    private static String formatDate(Date date) {
        if (date == null) {
            return "";
        }
        SimpleDateFormat format = new SimpleDateFormat(DATE_FORMAT);
        return format.format(date);
    }
 
    private static void setSelect(Sheet sheet, Map&lt;Integer, List&lt;String&gt;&gt; selectMap) {
        if (selectMap == null || selectMap.isEmpty()) {
            return;
        }
        Set&lt;Entry&lt;Integer, List&lt;String&gt;&gt;&gt; entrySet = selectMap.entrySet();
        for (Entry&lt;Integer, List&lt;String&gt;&gt; entry : entrySet) {
            int y = entry.getKey();
            List&lt;String&gt; list = entry.getValue();
            if (list == null || list.isEmpty()) {
                continue;
            }
            String[] arr = new String[list.size()];
            for (int i = 0; i &lt; list.size(); i++) {
                arr[i] = list.get(i);
            }
            DataValidationHelper helper = sheet.getDataValidationHelper();
            CellRangeAddressList addressList = new CellRangeAddressList(1, 65000, y, y);
            DataValidationConstraint dvc = helper.createExplicitListConstraint(arr);
            DataValidation dv = helper.createValidation(dvc, addressList);
            if (dv instanceof HSSFDataValidation) {
                dv.setSuppressDropDownArrow(false);
            } else {
                dv.setSuppressDropDownArrow(true);
                dv.setShowErrorBox(true);
            }
            sheet.addValidationData(dv);
        }
    }
 
    private static boolean isNumeric(String str) {
        if (Objects.nonNull(str) &amp;&amp; "0.0".equals(str)) {
            return true;
        }
        for (int i = str.length(); --i &gt;= 0; ) {
            if (!Character.isDigit(str.charAt(i))) {
                return false;
            }
        }
        return true;
    }
 
    private static String getString(String s) {
        if (s == null) {
            return "";
        }
        if (s.isEmpty()) {
            return s;
        }
        return s.trim();
    }
 
}</code></pre> 
<h3 id="1.2%20%E5%AF%BC%E5%85%A5%E6%B5%8B%E8%AF%95">二、数据导入</h3> 
<h4 id="1%E3%80%81%E5%AF%BC%E5%85%A5%E8%A7%A3%E6%9E%90%E4%B8%BAJSON">1、导入解析为JSON</h4> 
<p>创建一个学生信息的一个表格：</p> 
<p><img alt="" height="200" src="https://images2.imgbox.com/02/58/b7nihkeq_o.png" width="1200"></p> 
<p> Controller 代码：</p> 
<pre><code class="language-java">@RestController
@RequestMapping("/excel")
@Api(tags = "EXCEL模块")
public class ExcelController {

    /****************************** 导入 ************************************/
    @PostMapping("/import1")
    @ApiOperationSupport(order = 1)
    @ApiOperation(value = "导入解析为JSON", notes = "导入解析为JSON")
    @ApiImplicitParams(
            {@ApiImplicitParam(name = "file", value = "文件流对象", required = true,dataType = "MultipartFile")}
    )
    public JSONArray import1(@RequestPart("file") MultipartFile file) throws Exception {
        JSONArray array = ExcelUtils.readMultipartFile(file);
        System.out.println("导入数据为:" + array);
        return array;
    }

}</code></pre> 
<p>测试效果：</p> 
<p><img alt="" height="627" src="https://images2.imgbox.com/ad/8d/CvJeOSo5_o.png" width="1200"></p> 
<h4 id="%C2%A02%E3%80%81%E5%AF%BC%E5%85%A5%E8%A7%A3%E6%9E%90%E4%B8%BA%E5%AF%B9%E8%B1%A1"> 2、导入解析为对象（字段自动映射）</h4> 
<p>首先，你需要创建一个与导入表格对应的Java实体对象，并打上对应的Excel解析的导入注解，@ExcelImport注解的value则为表头名称</p> 
<p>对于有的枚举数据，通常我们导入的时候，表格中的数据是值，而在数据保存时，往往用的是键，比如：我们用sex=1可以表示为男，sex=2表示为女，那么我们通过配置也可以达到导入时，数据的自动映射。</p> 
<p>那么，我们只需要将Java实体中的对象sex字段的类型改为对应的数字类型Integer，然后再注解中配置好 kv 属性（属性格式为：键1-值1;键2-值2;键3-值3;.....）</p> 
<pre><code class="language-java">@Data
@ApiModel(value = "用户导入类")
public class UserImport {

    @ApiModelProperty(value = "姓名")
    @ExcelImport(value = "姓名")
    private String name;

    @ApiModelProperty(value = "年龄")
    @ExcelImport(value = "年龄")
    private Integer age;

    @ApiModelProperty(value = "性别")
    @ExcelImport(value = "性别" , kv="1-男;2-女")
    private Integer sex;

    @ApiModelProperty(value = "电话")
    @ExcelImport(value = "电话")
    private String phone;

    @ApiModelProperty(value = "城市")
    @ExcelImport(value = "城市")
    private String city;

    @ApiModelProperty(value = "头像")
    @ExcelImport(value = "头像")
    private String avatar;
    
}</code></pre> 
<pre><code class="language-java">    @PostMapping("/import2")
    @ApiOperationSupport(order = 2)
    @ApiOperation(value = "导入解析为对象", notes = "导入解析为对象")
    @ApiImplicitParams(
            {@ApiImplicitParam(name = "file", value = "文件流对象", required = true,dataType = "MultipartFile")}
    )
    public List&lt;User&gt; import2(@RequestPart("file")MultipartFile file) throws Exception {
        List&lt;User&gt; users = ExcelUtils.readMultipartFile(file, User.class);
        System.out.println("导入数据为:" + users);
        return users;
    }</code></pre> 
<p>测试效果：</p> 
<p><img alt="" height="549" src="https://images2.imgbox.com/df/db/NdAjXIcY_o.png" width="1200"></p> 
<h4 id="%C2%A04%E3%80%81%E5%AF%BC%E5%85%A5%E8%A7%A3%E6%9E%90%E4%B8%BA%E5%AF%B9%E8%B1%A1%EF%BC%88%E8%8E%B7%E5%8F%96%E8%A1%8C%E5%8F%B7%EF%BC%89"> 3、导入解析为对象（获取行号）</h4> 
<p>我们在做页面数据导入时，有时候可能需要获取行号，好追踪导入的数据。</p> 
<p>那么，我们只需要在对应的实体中加入一个 int 类型的 rowNum 字段即可。</p> 
<pre><code class="language-java">private int rowNum;  //行号</code></pre> 
<p> 测试效果：</p> 
<p><img alt="" height="563" src="https://images2.imgbox.com/0d/bd/Ee6LMBTk_o.png" width="1200"></p> 
<h4> 4、 导入解析为对象（获取原始数据）</h4> 
<p>在做页面数据导入的时候，如果某行存在错误，一般我们会将原始的数据拿出来分析，为什么会造成数据错误。那么，我们在实体类中，增加一个 String 类型的 rowData 字段即可。</p> 
<pre><code class="language-java">private String rowData;     //原始数据</code></pre> 
<p> 测试效果</p> 
<p><img alt="" height="661" src="https://images2.imgbox.com/7b/3e/yX71Nurr_o.png" width="1200"></p> 
<h4 id="6%E3%80%81%E5%AF%BC%E5%85%A5%E8%A7%A3%E6%9E%90%E4%B8%BA%E5%AF%B9%E8%B1%A1%EF%BC%88%E8%8E%B7%E5%8F%96%E9%94%99%E8%AF%AF%E6%8F%90%E7%A4%BA%EF%BC%89">5、导入解析为对象（获取错误提示）</h4> 
<p>当我们在导入数据的时候，如果某行数据存在，字段类型不正确，长度超过最大限制，必填字段验证，数据唯一性验证 等一些错误时候，我们可以往对象中添加一个 String 类型的 rowTips 字段，则可以直接拿到对应的错误信息。</p> 
<pre><code class="language-java">private String rowTips;     //错误提示</code></pre> 
<p>比如，我们将表格中小明的性别改为F（F并不是映射数据），将小红的年龄改为二十八（不能转换为Integer类型数据）</p> 
<p><img alt="" height="159" src="https://images2.imgbox.com/78/8b/ld0oNYdb_o.png" width="1001"></p> 
<p> 测试效果：可以看到，我们可以通过 rowTips 直接拿到对应的错误数据提示。</p> 
<h6 id="%E2%80%8B%E7%BC%96%E8%BE%91"><img alt="" height="718" src="https://images2.imgbox.com/d9/08/1wusiALb_o.png" width="1200"></h6> 
<h4> 6、导入解析为对象（限制字段长度）</h4> 
<p>比如，我们手机通常为11为长度，那么不妨限制电话的最大长度位数为11位。</p> 
<p>对应的做法，就是在 @ExcelImport 注解中，设置 maxLength = 11 即可。</p> 
<pre><code class="language-java">    @ApiModelProperty(value = "电话")
    @ExcelImport(value = "电话",maxLength = 11)
    private String phone;</code></pre> 
<p>比如，我们小明的电话长度设置为超过11位数的一个字符串</p> 
<p><img alt="" height="163" src="https://images2.imgbox.com/52/55/6KBAjzj3_o.png" width="1200"></p> 
<p> 测试效果：</p> 
<h6 id="%E2%80%8B%E7%BC%96%E8%BE%918%E3%80%81%E5%AF%BC%E5%85%A5%E8%A7%A3%E6%9E%90%E4%B8%BA%E5%AF%B9%E8%B1%A1%EF%BC%88%E5%BF%85%E5%A1%AB%E5%AD%97%E6%AE%B5%E9%AA%8C%E8%AF%81%EF%BC%89%C2%A0"><img alt="" height="701" src="https://images2.imgbox.com/5b/c5/Z4EcvgXJ_o.png" width="1200"></h6> 
<h4>7、导入解析为对象（必填字段验证） </h4> 
<p>我们在做数据导入的时候，往往还会有一些必填字段，比如用户的名称，电话。</p> 
<p>那么，我们只需要在 @ExcelImport 注解属性中，加上 required = true 即可</p> 
<pre><code class="language-java">    @ApiModelProperty(value = "姓名")
    @ExcelImport(value = "姓名", required = true)
    private String name;</code></pre> 
<p>我们将小明和小红的姓名去掉，进行测试。 </p> 
<p><img alt="" height="157" src="https://images2.imgbox.com/ed/5c/U0WaWF2n_o.png" width="1200"></p> 
<p> 测试效果 </p> 
<p><img alt="" height="678" src="https://images2.imgbox.com/43/2a/7mTMhvUb_o.png" width="1200"></p> 
<h4>8、导入解析为对象（数据唯一性验证）</h4> 
<h5 id="1%E3%80%81%E5%8D%95%E5%AD%97%E6%AE%B5%E5%94%AF%E4%B8%80%E6%80%A7%E9%AA%8C%E8%AF%81">1、单字段唯一性验证</h5> 
<p>我们在导入数据的时候，某个字段是具有唯一性的，比如我们这里假设规定姓名不能重复，那么则可以在对应字段的 @ExcelImport 注解上加上 unique = true 属性</p> 
<pre><code class="language-java">    @ApiModelProperty(value = "姓名")
    @ExcelImport(value = "姓名", required = true,unique = true)
    private String name;</code></pre> 
<p> 这里我们构建2条姓名一样的数据进行测试</p> 
<p><img alt="" height="142" src="https://images2.imgbox.com/70/4e/DMWk2aVS_o.png" width="1200"> 测试效果：</p> 
<p><img alt="" height="689" src="https://images2.imgbox.com/d8/61/iEUDOFe2_o.png" width="1200"></p> 
<h5> 2、多字段唯一性验证</h5> 
<p>如果你导入的数据存在多字段唯一性验证这种情况，只需要将每个对应字段的 @ExcelImport 注解属性中，都加上 unique = true 即可。</p> 
<p>比如：我们将姓名和电话两个字段进行联合唯一性验证（即不能存在有名称和电话都一样的数据，单个字段属性重复允许）</p> 
<p><img alt="" height="450" src="https://images2.imgbox.com/44/b9/NZSYXWM2_o.png" width="1042"></p> 
<p> 使用刚才的数据 </p> 
<p> 测试效果：可以看到，虽然名称有相同，但电话不相同，所以这里并没有提示唯一性验证错误。</p> 
<p><img alt="" height="682" src="https://images2.imgbox.com/00/d0/Qbegx9lF_o.png" width="1200"></p> 
<p> 现在，我们将小明的电话改成一样</p> 
<p><img alt="" height="177" src="https://images2.imgbox.com/08/73/9vvuc6yg_o.png" width="1200"></p> 
<p> 测试效果：可以看到，我们的联合唯一性验证生效了</p> 
<p><img alt="" height="690" src="https://images2.imgbox.com/7e/32/NzppV1dW_o.png" width="1200"></p> 
<h4>9、导入多Sheet页</h4> 
<p>如果你的导入表格存在多个sheet页（如下图），并想解析每个sheet页的数据，那么也是可以的</p> 
<p><img alt="" height="365" src="https://images2.imgbox.com/91/33/ZOM4YhhC_o.png" width="1156"></p> 
<p><img alt="" height="370" src="https://images2.imgbox.com/fb/2c/pfFEWM6m_o.png" width="1173"> Controller 代码：</p> 
<pre><code class="language-java">    @PostMapping("/import3")
    @ApiOperationSupport(order = 3)
    @ApiOperation(value = "导入多Sheet页", notes = "导入多Sheet页")
    @ApiImplicitParams(
            {@ApiImplicitParam(name = "file", value = "文件流对象", required = true,dataType = "MultipartFile")}
    )
    public Map&lt;String, JSONArray&gt; import3(@RequestPart("file") MultipartFile file) throws Exception {
        Map&lt;String, JSONArray&gt; map = ExcelUtils.readFileManySheet(file);
        map.forEach((key, value) -&gt; {
            System.out.println("Sheet名称：" + key);
            System.out.println("Sheet数据：" + value);
            System.out.println("----------------------");
        });
        return map;
    }</code></pre> 
<p> 测试效果</p> 
<p><img alt="" height="726" src="https://images2.imgbox.com/64/ed/L1hKa8R3_o.png" width="1024"></p> 
<h3> 三、数据导出</h3> 
<h4 id="1.3.1%20%E5%8A%A8%E6%80%81%E5%AF%BC%E5%87%BA">1、动态导出（带图片）</h4> 
<p>如果你的导出中，需要将对应图片链接直接显示为图片的话，那么，这里也是可以的，只需要将对应的类型转为 java.net.URL 类型即可（注意：转的时候有异常处理，为了方便演示，我这里直接抛出）</p> 
<pre><code class="language-java">    @GetMapping("/export4")
    @ApiOperationSupport(order = 4)
    @ApiOperation(value = "动态导出(带图片)", notes = "动态导出(带图片)", produces = MediaType.APPLICATION_OCTET_STREAM_VALUE)
    public void export4(HttpServletResponse response) throws MalformedURLException {
        // 表头数据
        List&lt;Object&gt; head = Arrays.asList("姓名","年龄","性别","头像");

        // 用户1数据
        List&lt;Object&gt; user1 = new ArrayList&lt;&gt;();
        user1.add("诸葛亮");
        user1.add(60);
        user1.add("男");
        user1.add(new URL("https://c-ssl.dtstatic.com/uploads/blog/202101/11/20210111220519_7da89.thumb.1000_0.jpeg"));  //显示图片
        // 用户2数据
        List&lt;Object&gt; user2 = new ArrayList&lt;&gt;();
        user2.add("大乔");
        user2.add(28);
        user2.add("女");
        user2.add(new URL("https://c-ssl.dtstatic.com/uploads/blog/202112/02/20211202113803_9ba69.thumb.1000_0.png"));  //显示图片

        // 将数据汇总
        List&lt;List&lt;Object&gt;&gt; sheetDataList = new ArrayList&lt;&gt;();
        sheetDataList.add(head);
        sheetDataList.add(user1);
        sheetDataList.add(user2);

        // 导出数据
        ExcelUtils.export(response,"用户表", sheetDataList);
    }</code></pre> 
<p>测试效果</p> 
<p><img alt="" height="330" src="https://images2.imgbox.com/7b/c9/jtJEmCoM_o.png" width="818"></p> 
<h4>2、动态导出（带下拉列表）</h4> 
<p>我们在做一些数据导出的时候，可能要对某一行的下拉数据进行约束限制。</p> 
<p>比如，当我们下载一个导入模版的时候，我们可以将性别，城市对应的列设置为下拉选择。</p> 
<pre><code class="language-java">    @GetMapping("/export5")
    @ApiOperationSupport(order = 5)
    @ApiOperation(value = "动态导出(带下拉列表)", notes = "动态导出(带下拉列表)", produces = MediaType.APPLICATION_OCTET_STREAM_VALUE)
    public void export5(HttpServletResponse response) throws MalformedURLException {
        // 表头数据
        List&lt;Object&gt; head = Arrays.asList("姓名","年龄","性别","城市");

        // 用户1数据
        List&lt;Object&gt; user1 = new ArrayList&lt;&gt;();
        user1.add("诸葛亮");
        user1.add(60);
        user1.add("男");
        user1.add("北京");
        // 用户2数据
        List&lt;Object&gt; user2 = new ArrayList&lt;&gt;();
        user2.add("大乔");
        user2.add(28);
        user2.add("女");
        user2.add("上海");

        // 将数据汇总
        List&lt;List&lt;Object&gt;&gt; sheetDataList = new ArrayList&lt;&gt;();
        sheetDataList.add(head);
        sheetDataList.add(user1);
        sheetDataList.add(user2);

        //设置下拉列表,键为第几列(从0开始),值为下拉数据
        Map&lt;Integer,List&lt;String&gt;&gt; selectMap = new HashMap&lt;&gt;(1);
        selectMap.put(2,Arrays.asList("男","女"));
        selectMap.put(3,Arrays.asList("北京","上海","广州"));

        // 导出数据
        ExcelUtils.export(response,"用户表", sheetDataList,selectMap);
    }</code></pre> 
<p>测试效果：</p> 
<p><img alt="" height="263" src="https://images2.imgbox.com/90/07/bNdBrPqP_o.png" width="911"></p> 
<p><img alt="" height="294" src="https://images2.imgbox.com/f2/7f/e1IBPBZD_o.png" width="1111"></p> 
<h4>3、动态导出（横向合并）</h4> 
<p>比如，我们将表头横向合并，只需要将合并的单元格设置为 ExcelUtils.COLUMN_MERGE 即可。</p> 
<p><img alt="" height="424" src="https://images2.imgbox.com/40/9e/RIERCnBZ_o.png" width="1200"></p> 
<pre><code class="language-java">    @GetMapping("/export6")
    @ApiOperationSupport(order = 6)
    @ApiOperation(value = "动态导出(横向合并)", notes = "动态导出(横向合并)", produces = MediaType.APPLICATION_OCTET_STREAM_VALUE)
    public void export6(HttpServletResponse response) throws MalformedURLException {
        // 表头数据
        List&lt;Object&gt; head = Arrays.asList("姓名","年龄","性别","地址",ExcelUtils.COLUMN_MERGE);

        // 用户1数据
        List&lt;Object&gt; user1 = new ArrayList&lt;&gt;();
        user1.add("诸葛亮");
        user1.add(60);
        user1.add("男");
        user1.add("北京");
        user1.add("门头沟区12号");

        // 用户2数据
        List&lt;Object&gt; user2 = new ArrayList&lt;&gt;();
        user2.add("大乔");
        user2.add(28);
        user2.add("女");
        user2.add("上海");
        user2.add("黄埔区24号");

        // 将数据汇总
        List&lt;List&lt;Object&gt;&gt; sheetDataList = new ArrayList&lt;&gt;();
        sheetDataList.add(head);
        sheetDataList.add(user1);
        sheetDataList.add(user2);

        // 导出数据
        ExcelUtils.export(response,"用户表", sheetDataList);
    }</code></pre> 
<p>测试效果</p> 
<p><img alt="" height="214" src="https://images2.imgbox.com/16/e8/cUSmvb1Z_o.png" width="981"></p> 
<h4>4、动态导出（纵向合并） </h4> 
<p>除了横向合并，我们还可以进行纵向合并，只需要将合并的单元格设为 ExcelUtils.ROW_MERGE 即可。</p> 
<pre><code class="language-java">    @GetMapping("/export7")
    @ApiOperationSupport(order = 7)
    @ApiOperation(value = "动态导出(纵向合并)", notes = "动态导出(纵向合并)", produces = MediaType.APPLICATION_OCTET_STREAM_VALUE)
    public void export7(HttpServletResponse response) throws MalformedURLException {
        // 表头数据
        List&lt;Object&gt; head = Arrays.asList("归属地","姓名","年龄","性别","地址");

        // 用户1数据
        List&lt;Object&gt; user1 = new ArrayList&lt;&gt;();
        user1.add("蜀国");
        user1.add("诸葛亮");
        user1.add(60);
        user1.add("男");
        user1.add("北京门头沟区12号");

        // 用户2数据
        List&lt;Object&gt; user2 = new ArrayList&lt;&gt;();
        user2.add("吴国");
        user2.add("大乔");
        user2.add(28);
        user2.add("女");
        user2.add("上海黄埔区24号");

        // 用户3数据
        List&lt;Object&gt; user3 = new ArrayList&lt;&gt;();
        user3.add(ExcelUtils.ROW_MERGE);
        user3.add("小乔");
        user3.add(26);
        user3.add("女");
        user3.add("上海金山区30号");

        // 将数据汇总
        List&lt;List&lt;Object&gt;&gt; sheetDataList = new ArrayList&lt;&gt;();
        sheetDataList.add(head);
        sheetDataList.add(user1);
        sheetDataList.add(user2);
        sheetDataList.add(user3);

        // 导出数据
        ExcelUtils.export(response,"用户表", sheetDataList);
    }</code></pre> 
<p>测试效果</p> 
<p><img alt="" height="201" src="https://images2.imgbox.com/77/b2/923CTeVU_o.png" width="1002"></p> 
<h4>5、导出模板(附示例数据)</h4> 
<p>我们在做数据导入的时候，往往首先会提供一个模版供其下载，这样用户在导入的时候才知道如何去填写数据。导出模板除了可以用上面的动态导出，这里还提供了一种更加便捷的写法。只需要创建一个类，然后再对应字段上打上 @ExcelExport 注解类即可。</p> 
<p>我们在做模版下载时候，有时往往会携带一条样本数据，好提示用户数据格式是什么，那么我们只需要在对应字段加上example</p> 
<pre><code class="language-java">@Data
@ApiModel(value = "用户导出类")
public class UserExport {

    @ApiModelProperty(value = "姓名")
    @ExcelExport(value = "姓名",example = "张三")
    private String name;

    @ApiModelProperty(value = "年龄")
    @ExcelExport(value = "年龄",example = "20")
    private Integer age;

    @ApiModelProperty(value = "性别")
    @ExcelExport(value = "性别",example = "男")
    private Integer sex;

    @ApiModelProperty(value = "电话")
    @ExcelExport(value = "电话",example = "18888888888")
    private String phone;

    @ApiModelProperty(value = "城市")
    @ExcelExport(value = "城市",example = "上海")
    private String city;

}</code></pre> 
<p> Controller 代码：如果不需要显示example，将最后一个参数改为false</p> 
<pre><code class="language-java">    @GetMapping("/export8")
    @ApiOperationSupport(order = 8)
    @ApiOperation(value = "导出模板(附示例数据)", notes = "导出模板(附示例数据)", produces = MediaType.APPLICATION_OCTET_STREAM_VALUE)
    public void export8(HttpServletResponse response) {
        ExcelUtils.exportTemplate(response, "用户表", UserExport.class,true);
    }</code></pre> 
<p>测试效果：</p> 
<p><img alt="" height="111" src="https://images2.imgbox.com/4d/17/9QSag12c_o.png" width="826"></p> 
<h4> 6、按对象导出</h4> 
<p>我们还可以通过 List 对象，对数据直接进行导出。首先，同样需要在对应类的字段上，设置导出名称。</p> 
<pre><code class="language-java">    @GetMapping("/export9")
    @ApiOperationSupport(order = 9)
    @ApiOperation(value = "按对象导出", notes = "按对象导出", produces = MediaType.APPLICATION_OCTET_STREAM_VALUE)
    public void export9(HttpServletResponse response) {
        //构建数据
        List&lt;UserExport&gt; userList = new ArrayList&lt;&gt;();
        UserExport user1 = new UserExport();
        user1.setName("张三");
        user1.setAge(18);
        user1.setSex(1);
        user1.setCity("成都");
        user1.setPhone("19999999999");

        UserExport user2 = new UserExport();
        user2.setName("李四");
        user2.setAge(25);
        user2.setSex(2);
        user2.setCity("西安");
        user2.setPhone("18888888888");

        userList.add(user1);
        userList.add(user2);

        ExcelUtils.export(response, "用户表", userList,UserExport.class);
    }</code></pre> 
<p> 测试效果</p> 
<p><img alt="" height="133" src="https://images2.imgbox.com/01/79/9aEaZofP_o.png" width="774"></p> 
<h4> 7<strong>、按对象导出（数据映射）</strong></h4> 
<p>在上面 的导出中，我们可以看到，性别数据导出来是1和2，这个不利于用户体验，应该需要转换为对应的中文，我们可以在字段注解上进行对应的配置KV</p> 
<pre><code class="language-java">@Data
@ApiModel(value = "用户导出类")
public class UserExport {

    @ApiModelProperty(value = "姓名")
    @ExcelExport(value = "姓名",example = "张三")
    private String name;

    @ApiModelProperty(value = "年龄")
    @ExcelExport(value = "年龄",example = "20")
    private Integer age;

    @ApiModelProperty(value = "性别")
    @ExcelExport(value = "性别",example = "男",kv="1-男;2-女")
    private Integer sex;

    @ApiModelProperty(value = "电话")
    @ExcelExport(value = "电话",example = "18888888888")
    private String phone;

    @ApiModelProperty(value = "城市")
    @ExcelExport(value = "城市",example = "上海")
    private String city;

}</code></pre> 
<p>测试效果：可以看到1和2显示为了对应的男和女</p> 
<p><img alt="" height="175" src="https://images2.imgbox.com/14/f6/LJOEaNu6_o.png" width="982"></p> 
<h4>8、按对象导出（调整表头顺序） </h4> 
<p> 如果你需要对表头字段进行排序，有两种方式：</p> 
<p>第一种：按照表格的顺序，排列Java类中的字段；</p> 
<p>第二种：在 @ExcelExport 注解中，指定 sort 属性，其值越少，排名越靠前。 </p> 
<p><img alt="" height="718" src="https://images2.imgbox.com/c0/7a/6NzdSiWy_o.png" width="1010">测试效果：可以看到，此时导出数据的表头顺序，和我们指定的顺序完全一致。</p> 
<p><img alt="" height="127" src="https://images2.imgbox.com/1e/c9/A9a1MPm2_o.png" width="833"></p> 
<h4>9、多Sheet页导出</h4> 
<p>Controller 代码：</p> 
<pre><code class="language-java">    @GetMapping("/export10")
    @ApiOperationSupport(order = 10)
    @ApiOperation(value = "多Sheet页导出", notes = "多Sheet页导出", produces = MediaType.APPLICATION_OCTET_STREAM_VALUE)
    public void export10(HttpServletResponse response) {
        // 第 1 个 Sheet 页
        List&lt;List&lt;Object&gt;&gt; sheet1 = new ArrayList&lt;&gt;();
        List&lt;Object&gt; sheet1Head = new ArrayList&lt;&gt;();
        sheet1Head.add("姓名");
        sheet1Head.add("数学");
        sheet1Head.add("英语");
        sheet1.add(sheet1Head);
        List&lt;Object&gt; row1 = new ArrayList&lt;&gt;();
        row1.add("Jack");
        row1.add(85);
        row1.add(100);
        sheet1.add(row1);
        List&lt;Object&gt; row2 = new ArrayList&lt;&gt;();
        row2.add("Marry");
        row2.add(85);
        row2.add(100);
        sheet1.add(row2);
        // 第 2 个 Sheet 页
        List&lt;List&lt;Object&gt;&gt; sheet2 = new ArrayList&lt;&gt;();
        List&lt;Object&gt; sheet2Head = new ArrayList&lt;&gt;();
        sheet2Head.add("姓名");
        sheet2Head.add("音乐");
        sheet2Head.add("美术");
        sheet2.add(sheet2Head);
        List&lt;Object&gt; row01 = new ArrayList&lt;&gt;();
        row01.add("Jack");
        row01.add(77);
        row01.add(66);
        sheet2.add(row01);
        List&lt;Object&gt; row02 = new ArrayList&lt;&gt;();
        row02.add("Marry");
        row02.add(99);
        row02.add(88);
        sheet2.add(row02);
        // 将两个 Sheet 页添加到集合中
        Map&lt;String, List&lt;List&lt;Object&gt;&gt;&gt; sheets = new LinkedHashMap&lt;&gt;();
        sheets.put("文化课", sheet1);
        sheets.put("艺术课", sheet2);
        // 导出数据
        ExcelUtils.exportManySheet(response, "学生成绩表", sheets);
    }</code></pre> 
<p>测试效果：</p> 
<p>第一个 Sheet 页 </p> 
<p><img alt="" height="243" src="https://images2.imgbox.com/ea/15/x8O8ITO8_o.png" width="723"></p> 
<p>第二个 Sheet 页  </p> 
<p> <img alt="" height="238" src="https://images2.imgbox.com/94/fe/y6dPXRzy_o.png" width="667"></p> 
<hr> 
<h3>疑问解答</h3> 
<h4 id="4.1%20%E5%85%B3%E4%BA%8E%E8%BA%AB%E4%BB%BD%E8%AF%81%E3%80%81%E7%94%B5%E8%AF%9D%E5%8F%B7%E7%A0%81%E5%AF%BC%E5%85%A5%E6%98%BE%E7%A4%BA%E7%A7%91%E5%AD%A6%E8%AE%A1%E6%95%B0%E6%B3%95%E7%9A%84%E9%97%AE%E9%A2%98">关于身份证导入显示科学计数法的问题</h4> 
<p>首先，当我们把身份证输入到表格中的时候，表格会默认为数字类型，由于数字太大，这时候Excel 会自动显示为科学计数法。</p> 
<p><img alt="" height="479" src="https://images2.imgbox.com/c6/41/Kk7nLWro_o.png" width="672"></p> 
<p> 那么这个时候，我们进行导入的话，确实会显示为科学计数法，如下图所示：</p> 
<p><img alt="" height="276" src="https://images2.imgbox.com/94/2a/W0ZFAKF5_o.png" width="671"></p> 
<p>那么，如果要解决这个问题，需要从根源解决掉，即让 Excel 表格不能显示为科学计数法。 </p> 
<p>这个时候，我们需要将该列设置为文本格式：</p> 
<p><img alt="" height="461" src="https://images2.imgbox.com/b8/42/bY78UjCd_o.png" width="770"></p> 
<p> 然后设置为文本格式。</p> 
<p><img alt="" height="737" src="https://images2.imgbox.com/8f/c0/tbM1ZVzb_o.png" width="770"></p> 
<p> 当设置完成后，你再重新输入身份证后，就会原封不动的显示了。</p> 
<p><img alt="" height="169" src="https://images2.imgbox.com/04/ca/HVttovfR_o.png" width="598"></p> 
<p> 这个时候，你再导入就会完全显示了</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/ed4419cee3a8ce90e147fb268bc33e4e/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">maven的依赖如何添加</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/f997ec7b18b7f7dd21f395f4088feb1a/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">Every derived table must have its own alias</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>