<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>【网络编程】基础知识 - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="【网络编程】基础知识" />
<meta property="og:description" content="文章目录 1.分层模型1.1OSI七层模型1.2TCP/IP四层模型 2.网络应用程序设计模式2.1C/S【client/server】2.2 B/S【browser/server】2.3协议的概念 3.协议3.1网络接口层协议-----以太网帧协议3.2网络层协议----IP协议IP协议的首部格式(IPV4)IP地址 3.3传输层协议----TCP/UDP协议TCP的三次握手【重点】TCP四次挥手【重点】 1.分层模型 1.1OSI七层模型 OSI（Open System Interconnection，开放系统互连）七层网络模型称为开放式系统互联参考模型 ，是一个逻辑上的定义，一个规范，它把网络从逻辑上分为了7层。每一层都有相关、相对应的物理设备，比如路由器，交换机。OSI 七层模型是一种框架性的设计方法 ，建立七层模型的主要目的是为解决异种网络互连时所遇到的兼容性问题，其最主要的功能使就是帮助不同类型的主机实现数据传输。它的最大优点是将服务、接口和协议这三个概念明确地区分开来，通过七个层次化的结构模型使不同的系统不同的网络之间实现可靠的通讯。 1.2TCP/IP四层模型 应用层—http,ftp,ssh
传输层----TCP/UDP协议
网络层----IP协议
网络接口层-----以太网帧协议
比如我们使用QQ向朋友发送消息：
2.网络应用程序设计模式 2.1C/S【client/server】 优点
协议选用灵活可以缓存数据 缺点
对用户安全构成威胁开发工作量大，调试困难 2.2 B/S【browser/server】 优点：跨平台
缺点：只能使用http
2.3协议的概念 规则：数据传输和数据解释的规则原始协议-----&gt;(改进、完善)------&gt; 标准协议典型协议：TCP/UDP HTTP FTP IP ARP 3.协议 3.1网络接口层协议-----以太网帧协议 以太网帧大小必须在641518字节（不包含前导码和定界符），即包括目的地址（6B）、源地址（6B）、类型（2B）、数据、FCS（4B）在内，其中数据段大小在461500字节之间。
认识MAC地址(网卡编号)
MAC地址用来识别数据链路层中相连的节点;长度为48位, 及6个字节. 一般用16进制数字加上冒号的形式来表示(例如: 08:00:27:03:fb:19)在网卡出厂时就确定了, 不能修改. mac地址通常是唯一的(虚拟机中的mac地址不是真实的mac地址, 可能会冲突; 也有些网卡支持用户配置mac地址) 类型2字节
当类型为0800时，正常发送IP数据报
当帧类型为0806时，会发送arp数据报-，根据IP获取对方的mac地址
当帧类型为0835时，会发送parp数据报，返回自己的mac地址
arp数据报，根据IP获取对方的mac地址【比如我们从北京向上海的主机发送消息，要获取广州主机的MAC地址】
认识IP
IP协议有两个版本, IPv4(32位)和IPv6(128位)
IP地址是在IP协议中, 用来标识网络中不同主机的地址;对于IPv4来说, IP地址是一个4字节, 32位的整数;我们通常也使用 “点分十进制” 的字符串表示IP地址, 例如 192.168.0.1 ; 用点分割的每一个数字表示一个字节, 范围是 0 - 255; 3." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/607370e7811b4527b1f444cd6db54205/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-08-30T15:35:40+08:00" />
<meta property="article:modified_time" content="2022-08-30T15:35:40+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">【网络编程】基础知识</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p></p> 
<div class="toc"> 
 <h4>文章目录</h4> 
 <ul><li><ul><li><ul><li><a href="#1_1" rel="nofollow">1.分层模型</a></li><li><ul><li><a href="#11OSI_3" rel="nofollow">1.1OSI七层模型</a></li><li><a href="#12TCPIP_11" rel="nofollow">1.2TCP/IP四层模型</a></li></ul> 
    </li><li><a href="#2_27" rel="nofollow">2.网络应用程序设计模式</a></li><li><ul><li><a href="#21CSclientserver_29" rel="nofollow">2.1C/S【client/server】</a></li><li><a href="#22_BSbrowserserver_40" rel="nofollow">2.2 B/S【browser/server】</a></li><li><a href="#23_44" rel="nofollow">2.3协议的概念</a></li></ul> 
    </li><li><a href="#3_50" rel="nofollow">3.协议</a></li><li><ul><li><a href="#31_52" rel="nofollow">3.1网络接口层协议-----以太网帧协议</a></li><li><a href="#32IP_86" rel="nofollow">3.2网络层协议----IP协议</a></li><li><ul><li><a href="#IPIPV4_94" rel="nofollow">IP协议的首部格式(IPV4)</a></li><li><a href="#IP_114" rel="nofollow">IP地址</a></li></ul> 
     </li><li><a href="#33TCPUDP_122" rel="nofollow">3.3传输层协议----TCP/UDP协议</a></li><li><ul><li><a href="#TCP_158" rel="nofollow">TCP的三次握手【重点】</a></li><li><a href="#TCP_175" rel="nofollow">TCP四次挥手【重点】</a></li></ul> 
    </li></ul> 
   </li></ul> 
  </li></ul> 
 </li></ul> 
</div> 
<p></p> 
<h4><a id="1_1"></a>1.分层模型</h4> 
<h5><a id="11OSI_3"></a>1.1OSI七层模型</h5> 
<ul><li>OSI（Open System Interconnection，开放系统互连）七层网络模型称为开放式系统互联参考模型 ，是一个逻辑上的定义，一个规范，它把网络从逻辑上分为了7层。</li><li>每一层都有相关、相对应的物理设备，比如路由器，交换机。OSI 七层模型是一种框架性的设计方法 ，建立七层模型的主要目的是为解决异种网络互连时所遇到的兼容性问题，其最主要的功能使就是帮助不同类型的主机实现数据传输。</li><li>它的最大优点是将服务、接口和协议这三个概念明确地区分开来，通过七个层次化的结构模型使不同的系统不同的网络之间实现可靠的通讯。</li></ul> 
<p><img src="https://images2.imgbox.com/8a/bc/yFaC7R1l_o.png" alt="image-20220808215401264"></p> 
<h5><a id="12TCPIP_11"></a>1.2TCP/IP四层模型</h5> 
<p>应用层—http,ftp,ssh</p> 
<p>传输层----TCP/UDP协议</p> 
<p>网络层----IP协议</p> 
<p>网络接口层-----以太网帧协议</p> 
<p><img src="https://images2.imgbox.com/e6/ae/oPZ9Mx7t_o.png" alt="image-20220808222951653"></p> 
<p>比如我们使用QQ向朋友发送消息：</p> 
<p><img src="https://images2.imgbox.com/c0/78/oGuGAbzC_o.png" alt="image-20220808224931026"></p> 
<h4><a id="2_27"></a>2.网络应用程序设计模式</h4> 
<h5><a id="21CSclientserver_29"></a>2.1C/S【client/server】</h5> 
<p>优点</p> 
<ul><li>协议选用灵活</li><li>可以缓存数据</li></ul> 
<p>缺点</p> 
<ul><li>对用户安全构成威胁</li><li>开发工作量大，调试困难</li></ul> 
<h5><a id="22_BSbrowserserver_40"></a>2.2 B/S【browser/server】</h5> 
<p>优点：跨平台<br> 缺点：只能使用http</p> 
<h5><a id="23_44"></a>2.3协议的概念</h5> 
<ul><li>规则：数据传输和数据解释的规则</li><li>原始协议-----&gt;(改进、完善)------&gt; 标准协议</li><li>典型协议：TCP/UDP HTTP FTP IP ARP</li></ul> 
<h4><a id="3_50"></a>3.协议</h4> 
<h5><a id="31_52"></a>3.1网络接口层协议-----以太网帧协议</h5> 
<p>以太网帧大小必须在64<sub>1518字节（不包含前导码和定界符），即包括目的地址（6B）、源地址（6B）、类型（2B）、数据、FCS（4B）在内，其中数据段大小在46</sub>1500字节之间。</p> 
<p><img src="https://images2.imgbox.com/13/9e/KN5De1DC_o.png" alt="image-20220808225309624"></p> 
<p><strong>认识MAC地址(网卡编号)</strong></p> 
<ul><li>MAC地址用来识别数据链路层中相连的节点;</li><li>长度为48位, 及6个字节. 一般用16进制数字加上冒号的形式来表示(例如: 08:00:27:03:fb:19)</li><li>在网卡出厂时就确定了, 不能修改. mac地址通常是唯一的(虚拟机中的mac地址不是真实的mac地址, 可能会冲突; 也有些网卡支持用户配置mac地址)</li></ul> 
<p><strong>类型2字节</strong></p> 
<p>当类型为0800时，正常发送IP数据报</p> 
<p><strong>当帧类型为0806时，会发送arp数据报-，根据IP获取对方的mac地址</strong></p> 
<p>当帧类型为0835时，会发送parp数据报，返回自己的mac地址</p> 
<p><img src="https://images2.imgbox.com/de/56/gUGsl4in_o.png" alt="image-20220808231938200"></p> 
<p>arp数据报，根据IP获取对方的mac地址【比如我们从北京向上海的主机发送消息，要获取广州主机的MAC地址】</p> 
<p><img src="https://images2.imgbox.com/da/96/Upu2zmqa_o.png" alt="image-20220808234212818"></p> 
<p><strong>认识IP</strong></p> 
<p>IP协议有两个版本, IPv4(32位)和IPv6(128位)</p> 
<ul><li>IP地址是在IP协议中, 用来标识网络中不同主机的地址;</li><li>对于IPv4来说, IP地址是一个4字节, 32位的整数;</li><li>我们通常也使用 “点分十进制” 的字符串表示IP地址, 例如 192.168.0.1 ; 用点分割的每一个数字表示一个字节, 范围是 0 - 255;</li></ul> 
<h5><a id="32IP_86"></a>3.2网络层协议----IP协议</h5> 
<ul><li>IP（Internet Protocol）网际协议，是TCP/IP协议的核心部分。</li><li>目前IPV4仍然是IP协议的主流版本。如果想要在互联网这个共享网络中精确定位到一台主机，那么就一定需要该主机的IP地址。</li><li>主机是拥有IP地址，但是不能进行路由控制（Routing，意思是中转、分组数据包）。路由器（Router）这种设备既有IP地址，又可以进行路由控制；我们可以将接入互联网中的主机和路由器都叫做节点。</li></ul> 
<p><img src="https://images2.imgbox.com/a4/d8/JyeIzBco_o.png" alt="image-20220809095634331"></p> 
<h6><a id="IPIPV4_94"></a>IP协议的首部格式(IPV4)</h6> 
<p><img src="https://images2.imgbox.com/11/d1/sTG0YSCJ_o.png" alt="image-20220809095714657"></p> 
<p><strong>组成部分</strong></p> 
<ul><li>4位版本号：用来指定IP协议的版本，IPV4的版本号为4，前4位存储0100。IPV6的版本号是6，前4位存储0110</li><li>4位首部长度（Internet Header Length）：表明IP首部的大小，单位是4个字节，length * 4的字节数，因为这一字段共4个比特位，所以这一字段最大值为2 ^ 4 - 1即15，所以IP首部最大长度为15 * 4即60字节；在默认情况下，该字段被设置为5，所以默认IP首部20字节。</li><li>8位服务类型：前三位表示优先度（已经弃用），第4位表示最低延迟、第5位表示最大吞吐、第6位表示最大可靠性、第7位表示最小代价，这四位互相冲突，只能选择一个。需要根据不同情况进行选择，如果是SSH/TELNET这类远端登录，那么就应该选择最小延时，如果是FTP类型的程序，则应该选择最大吞吐量；第8位是保留位，目前没有使用，必须填0。</li><li>16位总长度（Total Length）：表示IP首部和后面携带的数据部分一共有多少个字节。该字段有16个比特位，因此IP数据报整体最大长度为65535个字节。</li><li>16位标识（ID）：唯一地标识主机发送的报文，如果一份IP报文在数据链路层被分片，那么每一片的该字段应该都是相同值。帮助对端主机在接收后进行分片重组。</li><li>3位标志（Flag）：第一位保留（保留的意思是现在不使用，未来如果需要的话再使用），必须填0；第二位用来指明是否可以分片，如果为0则可以分片，如果为1则不能分片。</li><li>13位片偏移（Fragment Offset）：该字段表示分片相对于原始IP报文开始处的偏移量，其实就是表示当前分片在原报文中所处的位置，第一个分片对应值为0。由于该字段总共13个比特位，因此最多可以表示2 ^ 13即8192个相对位置。单位为8字节，所以最大可以表示8192 * 8 = 65536个字节的位置。</li><li><strong>（8位生存时间（Time To Live）：数据报到达目的地的最大报文跳数</strong>（Hop，指网络中一个区间，IP数据包正是在网络中一个跳间被转发），一般为64，每次经过一个路由，TTL–，如果TTL == 0时还没到达目的地，那么这个报文就会被丢弃。这个字段主要是为了防止出现路由循环，数据包在一个循环中一直转发，浪费网络资源。</li><li>8位协议（Protocol）：表示IP的上层是什么协议，我们熟知的TCP、UDP、ICMP等都是在IP上层的。</li><li>16位首部校验和（Header Checksum）：使用CRC进行校验，鉴别IP首部是否收到损坏，如果损坏直接丢弃，它只校验IP头部，不校验下面的内容，因为内容部分的校验是上层传输层（TCP）需要考虑的，IP协议只要发现首部有问题就直接丢弃该报文。</li><li>32位源IP地址（Source Address）：表示发送端的IP。</li><li>32位目的IP地址（Destination Address）：表示接收端的IP。</li><li>选项字段（Options）：不定长，最大可以到40个字节。</li></ul> 
<h6><a id="IP_114"></a>IP地址</h6> 
<p>IP地址由<strong>网络标识（网络地址）和主机标识（主机地址）两部分组成</strong>。</p> 
<p>IP地址划分为五个级别，分别为A类、B类、C类、D类和E类（一直没有使用过），所以目前我们所能见到的<strong>IP地址只有A、B、C、D四类。划分的依据就是IP地址从第1位到第4位的比特位。</strong></p> 
<p><img src="https://images2.imgbox.com/ff/7a/6HBXM1J4_o.png" alt="image-20220809113051273"></p> 
<h5><a id="33TCPUDP_122"></a>3.3传输层协议----TCP/UDP协议</h5> 
<p><strong>UDP数据包格式</strong></p> 
<p><img src="https://images2.imgbox.com/39/63/sCUluDV0_o.png" alt="image-20220809114918542"></p> 
<p>网络环境中</p> 
<ul><li>IP------定位一台主机</li><li>16位端口Port------定位一台主机上的某个进程</li><li>格式：IP:Port 比如：127.0.0.1:80【表示127.0.0.1这台主机上的第80号进程】</li></ul> 
<p><strong>TCP协议</strong></p> 
<ul><li>16位源端口(进程)</li><li>16位目的端口(进程)</li><li>32位序号(Seq)【用来表示A发送给B的数据报序号】</li><li>32位确认序号(Ack)【客户端和服务器端都可以发送，Ack=Seq+1】</li><li>6个标志位【每个标志位1bit,分别是 URG、ACK、PSH、RST、SYN、FIN】 
  <ul><li>URG：紧急指针有效</li><li>ACK：确认序号有效</li><li>PSH：接收方应该尽快将这个报文交给应用层</li><li>PST：重置连接</li><li>SYN：建立一个连接</li><li>FIN：断开一个连接</li></ul> </li><li>16位滑动窗口(表示缓存存储空间的大小) 
  <ul><li>传输数据的双方，如果一边传输的快，一边接收的慢。那么数据接收方会告诉传输方，自己有一个缓存。传输方就会把数据放入缓存，当缓存满了，数据的传输方就会进入阻塞等待。</li></ul> </li></ul> 
<p><img src="https://images2.imgbox.com/86/d8/sxjZQ18l_o.png" alt="image-20220809122447205"></p> 
<p><strong>TCP协议</strong></p> 
<p><img src="https://images2.imgbox.com/e4/7e/bCyC8Gvw_o.png" alt="image-20220809121546967"></p> 
<p><strong>TCP协议中最重要的是理解连接时的三次握手和断开时的四次挥手</strong></p> 
<h6><a id="TCP_158"></a>TCP的三次握手【重点】</h6> 
<ul><li>1.首先客户端发送连接请求【SYN】</li><li>2.服务端接受连接后回复确认号【ACK报文】，此时并同样返回请求序号【Seq】，并且为这次连接分配资源【SYN+ACK】</li><li>3.客户端接收到ACK报文后，也向服务端发送ACK报文，并且分配资源，这样TCP连接就成功了。【ACK】</li></ul> 
<p><img src="https://images2.imgbox.com/5a/3d/MPCfDmpw_o.png" alt="image-20220809123059652"></p> 
<p>**总结：**三次握手的关键是要确认对方收到了自己的数据包<code>，这个目标就是通过“确认号（Ack）”字段实现的。计算机会记录下自己发送的数据包序号Seq，待收到对方的数据包后，检测“确认号（Ack）”字段，</code>看Ack = Seq + 1是否成立，如果成立说明对方正确收到了自己的数据包`。</p> 
<p><strong>为什么需要三次握手？</strong></p> 
<ul><li>1、在第一次通信过程中，A向B发送信息之后，B收到信息后可以确认【自己的收信能力和A的发信能力没有问题。】</li><li>2、在第二次通信中，B向A发送信息之后，【A可以确认自己的发信能力、收信能力和B的收信能力没有问题，但是B不知道自己的发信能力到底如何，所以就需要第三次通信。】</li><li>3、在第三次通信中，A向B发送信息之后，B就可以确认自己的发信能力没有问题。</li><li><strong>小结</strong>：3次握手完成两个重要的功能，<code>既要双方做好发送数据的准备工作(双方都知道彼此已准备好)</code>，也要允许双方就初始序列号进行协商，这个序列号在握手过程中被发送和确认。</li></ul> 
<h6><a id="TCP_175"></a>TCP四次挥手【重点】</h6> 
<p>​ 建立连接非常重要，它是数据正确传输的前提；断开连接同样重要，它让计算机释放不再使用的资源。如果连接不能正常断开，不仅会造成数据传输错误，还会导致套接字不能关闭，持续占用资源，如果并发量高，服务器压力堪忧。</p> 
<pre><code class="prism language-cpp">过程描述
A：“任务处理完毕，我希望断开连接。”
B：“哦，是吗？请稍等，我准备一下。”
等待片刻后……
B：“我准备好了，可以断开连接了。”
A：“好的，谢谢合作。”
</code></pre> 
<ul><li>第一次挥手：Clien发送一个FIN，用来关闭Client到Server的数据传送，Client进入FIN_WAIT_1状态。</li><li>第二次挥手：Server收到FIN后，发送一个ACK给Client,Server进入CLOSE_WAIT状态。</li><li>第三次挥手： Server发送一个FIN，用来关闭Server到Client的数据传送，Server进入LAST_ACK状态。</li><li>第四次挥手：Client收到FIN后，Client进入TIME_WAIT状态，发送ACK给Server，Server进入CLOSED状态，完成四次握手。<img src="https://images2.imgbox.com/72/b3/BG1vUKKX_o.png" alt="image-20220810114517635"></li></ul> 
<p>​ 数据传输完毕后，双方都可释放连接。最开始的时候，客户端和服务器都是处于ESTABLISHED状态，然后客户端主动关闭，服务器被动关闭。</p> 
<p><strong>为什么是连接是三次握手，而关闭是四次握手？</strong></p> 
<ul><li>因为当Server端收到Client端的SYN连接请求报文后，可以直接发送SYN+ACK报文。其中ACK报文是用来应答的，SYN报文是用来同步的。</li><li>但是关闭连接时，当Server端收到FIN报文时，很可能并不会立即关闭SOCKET，所以只能先回复一个ACK报文，告诉Client端，“你发的FIN报文我收到了，我先准备一下就关闭”。</li><li>只有等到我Server端所有的报文都发送完了【准备完毕】，我才能发送FIN报文，因此不能一起发送。故需要四步握手。</li></ul>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/acc081276b87ee8cb4af816cd584ac41/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">8.18 Django 视图 - FBV 与 CBV</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/629143a1bf9101b804494862f303105e/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">c&#43;&#43;单例模式线程安全几种实现方式</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>