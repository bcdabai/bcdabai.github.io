<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>MySQL查漏补缺 - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="MySQL查漏补缺" />
<meta property="og:description" content="WHERE 与 HAVING 有什么区别 WHERE 是一个约束声明，使用 WHERE 约束来自数据库的数据，WHERE 是在结果返回之前起作用的，WHERE 中不能使用聚合函数。
HAVING 是一个过滤声明，是在查询返回结果集以后对查询结果进行的过滤操作，在 HAVING 中可以使用聚合函数。另一方面，HAVING 子句中不能使用除了分组字段和聚合函数之外的其他字段
MySQL调优 索引覆盖 索引覆盖可以减少树的搜索次数，显著提升查询性能，因此使用索引覆盖是一个常用的性能优化手段
最左前缀 如果已经有了（a，b）这个联合索引后，一般就不需要单独在 a 上简历索引了。因此，第一原则是，如果通过调整顺序，可以少维护一个索引，那么这个顺序往往就是需要优先考虑采用的。
索引下推 在 MySQL5.6 之后引入索引下推，可以在索引遍历过程中，对索引包含的字段先做判断，直接过滤掉不满足条件的记录，减少回表的次数。
怎么减少行锁对性能的影响 在 InnoDB 事务中，行锁是在需要的时候才加上的，但并不是不需要了就立刻释放，而是要等到事务结束时才释放。这就是两阶段锁协议。
如果我们的事务中需要锁多个行，要把最可能造成冲突，最可能影响并发度的锁尽量往后放
举例说明：
顾客A到电影城B买票，将会执行一下操作
从顾客 A 账户中扣除电影票价给影院的账户余额增加这张电影票价记录一条交易日志 一共需要 update 两条记录，并 insert 一条记录，该三个语句在一个事务中。
假设又有顾客C到电影城B买票，那么这两个事务冲突的部分就是第二条语句了，因为他们要更新同一个影院账户的余额，需要修改同一行数据。
根据两阶段锁协议，不论怎么安排语句，所有的操作需要的行锁都是在事务提交的时候才释放的。所以，把 2 安排在最后，比如按照 3，1，2这样的顺序，那么影院账户余额这一行的锁时间就最少。最大程度地减少了事务之间地锁等待，提升了并发度。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/b3fae1ea24f275bd7462e68a7be70cc7/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-06-27T20:01:17+08:00" />
<meta property="article:modified_time" content="2022-06-27T20:01:17+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">MySQL查漏补缺</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <h2><a id="WHERE__HAVING__0"></a>WHERE 与 HAVING 有什么区别</h2> 
<p>WHERE 是一个约束声明，使用 WHERE 约束来自数据库的数据，WHERE 是在结果返回之前起作用的，WHERE 中不能使用聚合函数。</p> 
<p>HAVING 是一个过滤声明，是在查询返回结果集以后对查询结果进行的过滤操作，在 HAVING 中可以使用聚合函数。另一方面，HAVING 子句中不能使用除了分组字段和聚合函数之外的其他字段</p> 
<h2><a id="MySQL_8"></a>MySQL调优</h2> 
<ul><li><strong>索引覆盖</strong></li></ul> 
<p>索引覆盖可以减少树的搜索次数，显著提升查询性能，因此使用索引覆盖是一个常用的性能优化手段</p> 
<ul><li>最左前缀</li></ul> 
<p>如果已经有了（a，b）这个联合索引后，一般就不需要单独在 a 上简历索引了。因此，<strong>第一原则是，如果通过调整顺序，可以少维护一个索引，那么这个顺序往往就是需要优先考虑采用的。</strong></p> 
<ul><li><strong>索引下推</strong></li></ul> 
<p>在 MySQL5.6 之后引入索引下推，可以在索引遍历过程中，对索引包含的字段先做判断，直接过滤掉不满足条件的记录，减少回表的次数。</p> 
<p><img src="https://images2.imgbox.com/85/db/QmrmAGsx_o.png" alt="image-20220623161523530"></p> 
<h2><a id="_26"></a>怎么减少行锁对性能的影响</h2> 
<p>在 InnoDB 事务中，行锁是在需要的时候才加上的，但并不是不需要了就立刻释放，而是要等到事务结束时才释放。<strong>这就是两阶段锁协议。</strong></p> 
<p>如果我们的事务中需要锁多个行，要把最可能造成冲突，最可能影响并发度的锁尽量往后放</p> 
<p>举例说明：</p> 
<p>顾客A到电影城B买票，将会执行一下操作</p> 
<blockquote> 
 <ol><li>从顾客 A 账户中扣除电影票价</li><li>给影院的账户余额增加这张电影票价</li><li>记录一条交易日志</li></ol> 
</blockquote> 
<p>一共需要 <strong>update</strong> 两条记录，并 <strong>insert</strong> 一条记录，该三个语句在一个事务中。</p> 
<p>假设又有顾客C到电影城B买票，那么这两个事务冲突的部分就是第二条语句了，因为他们要更新同一个影院账户的余额，需要修改同一行数据。</p> 
<p>根据两阶段锁协议，不论怎么安排语句，所有的操作需要的行锁都是在事务提交的时候才释放的。所以，把 2 安排在最后，比如按照 3，1，2这样的顺序，那么影院账户余额这一行的锁时间就最少。最大程度地减少了事务之间地锁等待，提升了并发度。</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/e5380d579555cffdd9a806c4299ffad0/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">【GD32学习】五、片内Flash读写实验-闪存控制器FMC</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/37a4a1eb01239f8659876ebb57f43c6d/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">最小花费（单源最短路）</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>