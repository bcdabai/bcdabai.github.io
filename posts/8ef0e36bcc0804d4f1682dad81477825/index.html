<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>kafka-offset手动提交和自动提交 - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="kafka-offset手动提交和自动提交" />
<meta property="og:description" content="目录
首先回顾之前的知识点
自动提交offset
手动提交
消费者poll消息的细节
完整代码：
按照新方法进行消费消息
1.指定时间进行消息的消费
2.指定分区开始从头消费&#43;指定分区的偏移量开始消费
新消费组的消费offset规则
首先回顾之前的知识点 消费者消费消息，每消费offset&#43;1，然后提交offset给到我们kafka中topic中的cousumer_offsets，该消费者宕机后，另外的消费者就会读取consumer_offsets读取我们的offset消费后面的消息
我们kafka消费者是自动拉取消息的，mq是队列push给消费者
自动提交：消息poll下来后（还没有消费）直接提交offset，速度很快，可能出现消费失败
手动提交：在消息消费时/消费后再提交offset
自动提交offset 缺点：可能会丢消息，比如消费者poll了topic中partition的消息后，然后提交offset，可能消费者没有消费成功
提交的内容offset——&gt;消费组&#43;topic&#43;offset
自动提交的配置
/** * 1.1设置是否自动提交offset并设置offset的间隔时间 */ properties.put(ConsumerConfig.ENABLE_AUTO_COMMIT_CONFIG,&#34;true&#34;); properties.put(ConsumerConfig.AUTO_COMMIT_INTERVAL_MS_CONFIG,&#34;1000&#34;); 一poll就提交offset了 手动提交 分为手动同步提交&#43;手动异步提交
手动同步提交：在消息消费完后调用同步提交的方法，当集群返回ack前一直阻塞，返回ack后表示成功
consumer.commitAsync(); 手动异步提交：不需要等集群返回ack，直接执行后序的逻辑即可，我们可以设置一个回调方法
消费者poll消息的细节 定义：消费者会根据设置的消费时间来决定消费多少消息
properties.put(ConsumerConfig.MAX_POLL_RECORDS_CONFIG,500)//拉取0.5s消息 默认消费者一次性poll500条信息（长轮询时间为1s），如果时间内poll了500条就结束for循环
//长轮询拉取时间，1s：消费者拉取1s时间不管拉了多少条消息（除非时间内拉取完了zk维护的topic分区中所有消息） ConsumerRecords&lt;String, String&gt; records = consumer.poll(Duration.ofMillis(1000)); 完整代码： while(true){ //长轮询拉取时间，1s：消费者拉取1s时间不管拉了多少条消息（除非时间内拉取完了zk维护的topic分区中所有消息） ConsumerRecords&lt;String, String&gt; records = consumer.poll(Duration.ofMillis(1000)); for (ConsumerRecord&lt;String, String&gt; record : records) { System.out.printf(&#34;收到的消息：partition= %d,offset= %d,key= %s,value=%s %n&#34;,record.partition(), record.offset(),record.key(),record.value()); } /** * 4.1手动提交：所有消息消费完再提交offset给broker中_consumer_offsets */ if(records.count()&gt;0){ //同步：阻塞，提交成功，等待broker的返回ack consumer." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/8ef0e36bcc0804d4f1682dad81477825/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-10-18T02:28:18+08:00" />
<meta property="article:modified_time" content="2022-10-18T02:28:18+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">kafka-offset手动提交和自动提交</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p id="main-toc"><strong>目录</strong></p> 
<p id="%E9%A6%96%E5%85%88%E5%9B%9E%E9%A1%BE%E4%B9%8B%E5%89%8D%E7%9A%84%E7%9F%A5%E8%AF%86%E7%82%B9-toc" style="margin-left:40px;"><a href="#%E9%A6%96%E5%85%88%E5%9B%9E%E9%A1%BE%E4%B9%8B%E5%89%8D%E7%9A%84%E7%9F%A5%E8%AF%86%E7%82%B9" rel="nofollow">首先回顾之前的知识点</a></p> 
<p id="%C2%A0%E8%87%AA%E5%8A%A8%E6%8F%90%E4%BA%A4offset-toc" style="margin-left:80px;"><a href="#%C2%A0%E8%87%AA%E5%8A%A8%E6%8F%90%E4%BA%A4offset" rel="nofollow"> 自动提交offset</a></p> 
<p id="%C2%A0%E6%89%8B%E5%8A%A8%E6%8F%90%E4%BA%A4-toc" style="margin-left:80px;"><a href="#%C2%A0%E6%89%8B%E5%8A%A8%E6%8F%90%E4%BA%A4" rel="nofollow"> 手动提交</a></p> 
<p id="%E6%B6%88%E8%B4%B9%E8%80%85poll%E6%B6%88%E6%81%AF%E7%9A%84%E7%BB%86%E8%8A%82-toc" style="margin-left:40px;"><a href="#%E6%B6%88%E8%B4%B9%E8%80%85poll%E6%B6%88%E6%81%AF%E7%9A%84%E7%BB%86%E8%8A%82" rel="nofollow">消费者poll消息的细节</a></p> 
<p id="%C2%A0%E5%AE%8C%E6%95%B4%E4%BB%A3%E7%A0%81%EF%BC%9A-toc" style="margin-left:80px;"><a href="#%C2%A0%E5%AE%8C%E6%95%B4%E4%BB%A3%E7%A0%81%EF%BC%9A" rel="nofollow"> 完整代码：</a></p> 
<p id="%C2%A0%E6%8C%89%E7%85%A7%E6%96%B0%E6%96%B9%E6%B3%95%E8%BF%9B%E8%A1%8C%E6%B6%88%E8%B4%B9%E6%B6%88%E6%81%AF-toc" style="margin-left:40px;"><a href="#%C2%A0%E6%8C%89%E7%85%A7%E6%96%B0%E6%96%B9%E6%B3%95%E8%BF%9B%E8%A1%8C%E6%B6%88%E8%B4%B9%E6%B6%88%E6%81%AF" rel="nofollow"> 按照新方法进行消费消息</a></p> 
<p id="1.%E6%8C%87%E5%AE%9A%E6%97%B6%E9%97%B4%E8%BF%9B%E8%A1%8C%E6%B6%88%E6%81%AF%E7%9A%84%E6%B6%88%E8%B4%B9-toc" style="margin-left:80px;"><a href="#1.%E6%8C%87%E5%AE%9A%E6%97%B6%E9%97%B4%E8%BF%9B%E8%A1%8C%E6%B6%88%E6%81%AF%E7%9A%84%E6%B6%88%E8%B4%B9" rel="nofollow">1.指定时间进行消息的消费</a></p> 
<p id="%C2%A02.%E6%8C%87%E5%AE%9A%E5%88%86%E5%8C%BA%E5%BC%80%E5%A7%8B%E4%BB%8E%E5%A4%B4%E6%B6%88%E8%B4%B9%2B%E6%8C%87%E5%AE%9A%E5%88%86%E5%8C%BA%E7%9A%84%E5%81%8F%E7%A7%BB%E9%87%8F%E5%BC%80%E5%A7%8B%E6%B6%88%E8%B4%B9-toc" style="margin-left:80px;"><a href="#%C2%A02.%E6%8C%87%E5%AE%9A%E5%88%86%E5%8C%BA%E5%BC%80%E5%A7%8B%E4%BB%8E%E5%A4%B4%E6%B6%88%E8%B4%B9%2B%E6%8C%87%E5%AE%9A%E5%88%86%E5%8C%BA%E7%9A%84%E5%81%8F%E7%A7%BB%E9%87%8F%E5%BC%80%E5%A7%8B%E6%B6%88%E8%B4%B9" rel="nofollow"> 2.指定分区开始从头消费+指定分区的偏移量开始消费</a></p> 
<p id="%E6%96%B0%E6%B6%88%E8%B4%B9%E7%BB%84%E7%9A%84%E6%B6%88%E8%B4%B9offset%E8%A7%84%E5%88%99-toc" style="margin-left:40px;"><a href="#%E6%96%B0%E6%B6%88%E8%B4%B9%E7%BB%84%E7%9A%84%E6%B6%88%E8%B4%B9offset%E8%A7%84%E5%88%99" rel="nofollow">新消费组的消费offset规则</a></p> 
<hr id="hr-toc"> 
<p></p> 
<p> </p> 
<blockquote> 
 <h3 id="%E9%A6%96%E5%85%88%E5%9B%9E%E9%A1%BE%E4%B9%8B%E5%89%8D%E7%9A%84%E7%9F%A5%E8%AF%86%E7%82%B9"><strong>首先回顾之前的知识点</strong></h3> 
</blockquote> 
<p>消费者消费消息，每消费offset+1，然后提交offset给到我们kafka中topic中的cousumer_offsets，该消费者宕机后，另外的消费者就会读取consumer_offsets读取我们的offset消费后面的消息</p> 
<p><strong>我们kafka消费者是自动拉取消息的，mq是队列push给消费者</strong></p> 
<p><strong>自动提交：</strong>消息poll下来后（还没有消费）直接提交offset，速度很快，可能出现消费失败</p> 
<p><strong>手动提交：</strong>在消息消费时/消费后再提交offset</p> 
<p><img alt="" height="624" src="https://images2.imgbox.com/f6/55/zoi8fcZj_o.png" width="1200"></p> 
<blockquote> 
 <h4 id="%C2%A0%E8%87%AA%E5%8A%A8%E6%8F%90%E4%BA%A4offset"><span style="color:#4da8ee;"> 自动提交offset</span></h4> 
</blockquote> 
<p><strong>缺点：</strong>可能会丢消息，比如消费者poll了topic中partition的消息后，然后提交offset，可能消费者没有消费成功</p> 
<p>提交的内容offset——&gt;消费组+topic+offset</p> 
<p><img alt="" height="89" src="https://images2.imgbox.com/b0/b9/ROSUknly_o.png" width="1200"></p> 
<p><strong>自动提交的配置</strong></p> 
<p><img alt="" height="218" src="https://images2.imgbox.com/7e/56/vg5WH6zR_o.png" width="897"></p> 
<pre><code class="language-java">   /**
         * 1.1设置是否自动提交offset并设置offset的间隔时间
         */
        properties.put(ConsumerConfig.ENABLE_AUTO_COMMIT_CONFIG,"true");
        properties.put(ConsumerConfig.AUTO_COMMIT_INTERVAL_MS_CONFIG,"1000");
        </code></pre> 
<p><img alt="" height="343" src="https://images2.imgbox.com/02/02/Yz50T7up_o.png" width="1174"> </p> 
<p>一poll就提交offset了 </p> 
<blockquote> 
 <h4 id="%C2%A0%E6%89%8B%E5%8A%A8%E6%8F%90%E4%BA%A4"><span style="color:#4da8ee;"> 手动提交</span></h4> 
</blockquote> 
<p><strong>分为手动同步提交+手动异步提交</strong></p> 
<p><span style="color:#fe2c24;"><strong>手动同步提交：</strong></span>在<strong>消息消费完后</strong>调用同步提交的方法，当集群返回ack前一直阻塞，返回ack后表示成功</p> 
<p><img alt="" height="564" src="https://images2.imgbox.com/b4/68/0UONrMyk_o.png" width="1125"></p> 
<pre><code class="language-java">  consumer.commitAsync();</code></pre> 
<p><span style="color:#fe2c24;"><strong>手动异步提交：</strong></span>不需要等集群返回ack，直接执行后序的逻辑即可，我们可以设置一个回调方法</p> 
<blockquote> 
 <h3 id="%E6%B6%88%E8%B4%B9%E8%80%85poll%E6%B6%88%E6%81%AF%E7%9A%84%E7%BB%86%E8%8A%82">消费者poll消息的细节</h3> 
</blockquote> 
<p><span style="color:#fe2c24;"><strong>定义：</strong></span>消费者会根据设置的消费时间来决定消费多少消息</p> 
<pre><code class="language-java">properties.put(ConsumerConfig.MAX_POLL_RECORDS_CONFIG,500)//拉取0.5s消息</code></pre> 
<p> 默认消费者一次性poll500条信息（长轮询时间为1s），如果时间内poll了500条就结束for循环</p> 
<pre><code class="language-java"> //长轮询拉取时间，1s：消费者拉取1s时间不管拉了多少条消息（除非时间内拉取完了zk维护的topic分区中所有消息）
            ConsumerRecords&lt;String, String&gt; records = consumer.poll(Duration.ofMillis(1000));</code></pre> 
<h4 id="%C2%A0%E5%AE%8C%E6%95%B4%E4%BB%A3%E7%A0%81%EF%BC%9A"><span style="color:#fe2c24;"> <strong>完整代码：</strong></span></h4> 
<pre><code class="language-java"> while(true){
            //长轮询拉取时间，1s：消费者拉取1s时间不管拉了多少条消息（除非时间内拉取完了zk维护的topic分区中所有消息）
            ConsumerRecords&lt;String, String&gt; records = consumer.poll(Duration.ofMillis(1000));
            for (ConsumerRecord&lt;String, String&gt; record : records) {
                System.out.printf("收到的消息：partition= %d,offset= %d,key= %s,value=%s %n",record.partition(),
                        record.offset(),record.key(),record.value());
            }

            /**
             * 4.1手动提交：所有消息消费完再提交offset给broker中_consumer_offsets
             */
            if(records.count()&gt;0){
                //同步：阻塞，提交成功，等待broker的返回ack
               consumer.commitAsync();

                //异步:提交完后不需要等待broker返回ack，直接往下走

            }
        }</code></pre> 
<p> 如果两次poll的间隔&gt;30s，集群会认为该消费者消费能力弱将其踢出，触发rebalance机制，消息交给消费组中的其他消费者</p> 
<pre><code class="language-java">  properties.put(ConsumerConfig.MAX_POLL_INTERVAL_MS_CONFIG, 30 * 1000);</code></pre> 
<p><img alt="" height="633" src="https://images2.imgbox.com/38/fd/4gAjlFnx_o.png" width="1200"></p> 
<blockquote> 
 <h3 id="%C2%A0%E6%8C%89%E7%85%A7%E6%96%B0%E6%96%B9%E6%B3%95%E8%BF%9B%E8%A1%8C%E6%B6%88%E8%B4%B9%E6%B6%88%E6%81%AF"> 按照新方法进行消费消息</h3> 
</blockquote> 
<h4 id="1.%E6%8C%87%E5%AE%9A%E6%97%B6%E9%97%B4%E8%BF%9B%E8%A1%8C%E6%B6%88%E6%81%AF%E7%9A%84%E6%B6%88%E8%B4%B9"><span style="color:#fe2c24;"><strong>1.指定时间进行消息的消费</strong></span></h4> 
<p>1.根据时间将topic中partition分区信息<strong>全部</strong>放入map中——&gt;2.然后指定时间，封装topic和分区与时间到map中——&gt;3.最后再将map添加到更高级的map，key为分区，如果有两个分区就是2个map——&gt;4.最后遍历，然后提取出value并得到offset打印</p> 
<p><img alt="" height="640" src="https://images2.imgbox.com/fc/e2/RWuHdZ3e_o.png" width="1045"></p> 
<h4 id="%C2%A02.%E6%8C%87%E5%AE%9A%E5%88%86%E5%8C%BA%E5%BC%80%E5%A7%8B%E4%BB%8E%E5%A4%B4%E6%B6%88%E8%B4%B9%2B%E6%8C%87%E5%AE%9A%E5%88%86%E5%8C%BA%E7%9A%84%E5%81%8F%E7%A7%BB%E9%87%8F%E5%BC%80%E5%A7%8B%E6%B6%88%E8%B4%B9"><span style="color:#fe2c24;"> <strong>2.指定分区开始从头消费+指定分区的偏移量开始消费</strong></span></h4> 
<pre><code class="language-java">        //指定分区消费
        consumer.assign(Arrays.asList(new TopicPartition(TOPIC_NAME,0)));

        /**
         * 4.回溯消费消息(指定某分区从头开始消费)
         */
        consumer.assign(Arrays.asList(new TopicPartition(TOPIC_NAME,0)));
        consumer.seekToBeginning(Arrays.asList(new TopicPartition(TOPIC_NAME,0)));

        /**
         * 4.1指定offset开始消费
         */
        consumer.assign(Arrays.asList(new TopicPartition(TOPIC_NAME,0)));
        consumer.seek(new TopicPartition(TOPIC_NAME,0),10);</code></pre> 
<blockquote> 
 <h3 id="%E6%96%B0%E6%B6%88%E8%B4%B9%E7%BB%84%E7%9A%84%E6%B6%88%E8%B4%B9offset%E8%A7%84%E5%88%99">新消费组的消费offset规则</h3> 
</blockquote> 
<p>新消费组在启动后，默认是从当前分区最后一条消息的offset+1开始消费，可以通过配置进行重新消费</p> 
<pre><code class="language-java">  /**
         * 2.13设置下次换了消费组还是按照offset记录继续消费
         */
        properties.put(ConsumerConfig.AUTO_COMMIT_INTERVAL_MS_CONFIG,"earliest");</code></pre> 
<p></p> 
<p></p> 
<p></p> 
<p></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/dcb863db3c9515d013086acaa9036bea/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">商城项目中的缓存使用</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/f31b21ff0e8080172dbc540537ccc3f9/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">Rockchip RK3588 User Guide DP</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>