<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>算法之【动态规划】详解（python） - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="算法之【动态规划】详解（python）" />
<meta property="og:description" content="算法之动态规划详解 定义 动态规划其实是一种运筹学方法，是在多轮决策过程中寻找最优解的方法。
应用场景 动态规划问题的一般形式就是求最值。动态规划其实是运筹学的一种最优化方法，只不过在计算机问题上应用比较多，比如说让你求最长递增子序列呀，最小编辑距离呀等等。
核心思想 求解动态规划的核心求解思路是穷举。因为要求最值，肯定要把所有可行的答案穷举出来，然后在其中找最值。但是我们在求解过程中， 需要避免重复计算从而更快速的找到答案 。
动态规划三要素 最优子结构：原问题的最优解所包含的子问题的解也是最优的，通过子问题的最值得到原问题的最值。存在重叠子问题：子问题间不独立（这是动态规划区别于分治的最大不同）；如果暴力穷举的话效率会极其低下，所以需要「备忘录」或者「DP table」来优化穷举过程，避免不必要的计算。无后效性：即后续的计算结果不会影响当前结果。 动态规划通用解题过程 动态规划没有标准的解题方法，即没有一个完全通用的解题方法。但在宏观上有通用的方法论：
下面的 k 表示多轮决策的第 k 轮：
问题分解，将原问题划分成几个子问题。一个子问题就是多轮决策的一个阶段。
找状态，选择合适的状态变量 S(k)。它需要具备描述多轮决策过程的演变，更像是决策可能的结果。
做决策，确定决策变量 u(k)。每一轮的决策就是每一轮可能的决策动作，即当前可以有哪些决策可以选择。
状态转移方程。这个步骤是动态规划最重要的核心，即 S(k&#43;1)= uk(sk) 。
定目标。写出代表多轮决策目标的指标函数 V(k,n)，即最终需要达到的目标。
寻找目标的终止条件。
动态规划的解题核心就是找到状态转移方程，其实所谓的状态转移方程说白了就是数学上的递推方程，没有什么高大上的。就是通过最基础的问题，一步步递推出所需要的最终目标结果。只是在定义状态转移方程的含义时，有不同的定义方式，不同的定义方式会有不同的递推方程式，但是只要定义正确，都可以得到最终正确的结果。
通常状态转移方程定义过程
明确当前可改变的状态有什么；定义dp数组或者递归函数的具体含义；明确每一步可以进行的选择有哪些；编写递推方程，也就是状态转移方程；明确baseline，也就是递推开始时的基础值是什么。 动态规划解题方式 动态规划的解题方式通常分为两种：
通过定义递归方程解决，这是一种自顶向下的求解方式，通常这种方式会有很多重复计算过程，因此可以通过建立备忘录记录中间过程来进行优化；通过定义DP(Dynamic Programming)数组来求解，这是一种自底向上的求解方式。 至于选择哪一种解题方式，可以根据自己的习惯来。自己比较习惯那种方式思考就用哪种方式即可。
简单举例 下面以常见的斐波拉契数列为例来说明一下上述两种求解方式。
斐波那契数列（Fibonacci sequence）是指的是这样一个数列：0、1、1、2、3、5、8、13、21、34、……。即后一个数为前两个数之和。在数学上，斐波那契数列以如下被以递推的方法定义：F(0)=0，F(1)=1, F(n)=F(n - 1)&#43;F(n - 2)（n ≥ 2，n ∈ N*）
通过暴力递归求解
定义fib(n)函数返回的是斐波拉契数列第n项的值：
def fib(n): if n &lt;= 2: return 1 return fib(n-1) &#43; fib(n-2) 此时的时间复杂度O(2^n)指数级，计算很慢。
我们来看一下递归的状态树：
从状态树我们可以看到有很多重复计算的节点，为了避免重复，我们可以通过建立一个备忘录memo记录,来记录中间节点的计算结果，避免重复计算，可以将时间复杂度直接降为O(n)线性复杂度，优化代码如下：" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/67c463a0fde25e390c6884f8a1b2ad89/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2020-11-30T20:13:12+08:00" />
<meta property="article:modified_time" content="2020-11-30T20:13:12+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">算法之【动态规划】详解（python）</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <h2><a id="_2"></a>算法之动态规划详解</h2> 
<h4><a id="_4"></a>定义</h4> 
<p>动态规划其实是一种运筹学方法，是在多轮决策过程中寻找最优解的方法。</p> 
<h4><a id="_8"></a>应用场景</h4> 
<p>动态规划问题的一般形式就是<code>求最值</code>。动态规划其实是运筹学的一种最优化方法，只不过在计算机问题上应用比较多，比如说让你求<strong>最长</strong>递增子序列呀，<strong>最小</strong>编辑距离呀等等。</p> 
<h4><a id="_12"></a>核心思想</h4> 
<p><strong>求解动态规划的核心求解思路是穷举</strong>。因为要求最值，肯定要把所有可行的答案穷举出来，然后在其中找最值。但是我们在求解过程中， 需要<strong>避免重复计算</strong>从而更快速的找到答案 。</p> 
<h4><a id="_16"></a>动态规划三要素</h4> 
<ol><li><strong>最优子结构</strong>：原问题的最优解所包含的子问题的解也是最优的，通过子问题的最值得到原问题的最值。</li><li><strong>存在重叠子问题</strong>：子问题间不独立（这是动态规划区别于分治的最大不同）；如果暴力穷举的话效率会极其低下，所以需要「<strong>备忘录</strong>」或者「<strong>DP table</strong>」来<strong>优化穷举过程</strong>，避免不必要的计算。</li><li><strong>无后效性</strong>：即后续的计算结果不会影响当前结果。</li></ol> 
<h4><a id="_22"></a>动态规划通用解题过程</h4> 
<p>动态规划没有标准的解题方法，即没有一个完全通用的解题方法。但在宏观上有通用的方法论：</p> 
<p>下面的 k 表示多轮决策的第 k 轮：</p> 
<ol><li> <p>问题分解，将原问题划分成几个子问题。一个子问题就是多轮决策的一个阶段。</p> </li><li> <p>找状态，选择合适的状态变量 S(k)。它需要具备描述多轮决策过程的演变，更像是决策可能的结果。</p> </li><li> <p>做决策，确定决策变量 u(k)。每一轮的决策就是每一轮可能的决策动作，即当前可以有哪些决策可以选择。</p> </li><li> <p>状态转移方程。这个步骤是动态规划最重要的核心，即 S(k+1)= uk(sk) 。</p> </li><li> <p>定目标。写出代表多轮决策目标的指标函数 V(k,n)，即最终需要达到的目标。</p> </li><li> <p>寻找目标的终止条件。</p> </li></ol> 
<p>动态规划的解题核心就是找到<strong>状态转移方程</strong>，其实所谓的<strong>状态转移方程</strong>说白了就是数学上的递推方程，没有什么高大上的。就是通过最基础的问题，一步步递推出所需要的最终目标结果。只是在定义状态转移方程的含义时，有不同的定义方式，不同的定义方式会有不同的递推方程式，但是只要定义正确，都可以得到最终正确的结果。</p> 
<p><strong>通常状态转移方程定义过程</strong></p> 
<ol><li>明确当前可改变的<code>状态</code>有什么；</li><li>定义dp数组或者递归函数的具体含义；</li><li>明确每一步可以进行的<code>选择</code>有哪些；</li><li>编写递推方程，也就是状态转移方程；</li><li>明确baseline，也就是递推开始时的基础值是什么。</li></ol> 
<h4><a id="_50"></a>动态规划解题方式</h4> 
<p>动态规划的解题方式通常分为两种：</p> 
<ol><li>通过定义递归方程解决，这是一种自顶向下的求解方式，通常这种方式会有很多重复计算过程，因此可以通过建立备忘录记录中间过程来进行优化；</li><li>通过定义DP(Dynamic Programming)数组来求解，这是一种自底向上的求解方式。</li></ol> 
<p>至于选择哪一种解题方式，可以根据自己的习惯来。自己比较习惯那种方式思考就用哪种方式即可。</p> 
<h4><a id="_59"></a>简单举例</h4> 
<p>下面以常见的斐波拉契数列为例来说明一下上述两种求解方式。</p> 
<blockquote> 
 <p>斐波那契数列（Fibonacci sequence）是指的是这样一个数列：0、1、1、2、3、5、8、13、21、34、……。即后一个数为前两个数之和。在数学上，斐波那契数列以如下被以递推的方法定义：<em>F</em>(0)=0，<em>F</em>(1)=1, <em>F</em>(n)=<em>F</em>(n - 1)+<em>F</em>(n - 2)（<em>n</em> ≥ 2，<em>n</em> ∈ N*）</p> 
</blockquote> 
<p><strong>通过暴力递归求解</strong></p> 
<p>定义fib(n)函数返回的是斐波拉契数列第n项的值：</p> 
<pre><code class="prism language-python"><span class="token keyword">def</span> <span class="token function">fib</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token keyword">if</span> n <span class="token operator">&lt;=</span> <span class="token number">2</span><span class="token punctuation">:</span>
        <span class="token keyword">return</span> <span class="token number">1</span>
    <span class="token keyword">return</span> fib<span class="token punctuation">(</span>n<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">+</span> fib<span class="token punctuation">(</span>n<span class="token operator">-</span><span class="token number">2</span><span class="token punctuation">)</span>
</code></pre> 
<p>此时的时间复杂度O(2^n)指数级，计算很慢。</p> 
<p>我们来看一下递归的状态树：<br> <img src="https://images2.imgbox.com/d6/2d/spbxCDzx_o.png" alt="在这里插入图片描述"></p> 
<p>从状态树我们可以看到有很多重复计算的节点，为了避免重复，我们可以通过建立一个<code>备忘录memo</code>记录,来记录中间节点的计算结果，避免重复计算，可以将时间复杂度直接降为O(n)线性复杂度，优化代码如下：</p> 
<pre><code class="prism language-python"><span class="token keyword">def</span> <span class="token function">fib</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token keyword">def</span> <span class="token function">helper</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">:</span>
        <span class="token keyword">if</span> n <span class="token operator">&lt;=</span> <span class="token number">2</span><span class="token punctuation">:</span>
            <span class="token keyword">return</span> <span class="token number">1</span>
        <span class="token comment"># 如果n的值已经计算过，则直接返回值memo[n]</span>
        <span class="token keyword">if</span> n <span class="token keyword">in</span> memo<span class="token punctuation">:</span> 
            <span class="token keyword">return</span> memo<span class="token punctuation">[</span>n<span class="token punctuation">]</span>
        memo<span class="token punctuation">[</span>n<span class="token punctuation">]</span> <span class="token operator">=</span> fib<span class="token punctuation">(</span>n<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">+</span> fib<span class="token punctuation">(</span>n<span class="token operator">-</span><span class="token number">2</span><span class="token punctuation">)</span>
        <span class="token keyword">return</span> memo<span class="token punctuation">[</span>n<span class="token punctuation">]</span>
    memo <span class="token operator">=</span> <span class="token punctuation">{<!-- --></span><span class="token punctuation">}</span> <span class="token comment"># 备忘录，记录已经计算过的值，防止重复计算</span>
    <span class="token keyword">return</span> helper<span class="token punctuation">(</span>n<span class="token punctuation">)</span>
</code></pre> 
<p>以fib(6)为例，递归的求解过程如下：<br> <img src="https://images2.imgbox.com/81/ec/45yTW5rm_o.png" alt="在这里插入图片描述"></p> 
<p><strong>DP数组的迭代解法</strong></p> 
<p>上述递归过程是<strong>自顶向下</strong>求解的，也就是从目标值逐步向下 层递归，直至达到递归的终止条件，然后将值逐层返回；dp数组则是<strong>自底向上</strong>求解的，即从最开始的基础出发，然后逐步向上递推至目标值，由于DP数组自身存储了所有的计算过程，因此不存在重复计算。DP的解法如下：</p> 
<pre><code class="prism language-python"><span class="token keyword">def</span> <span class="token function">fib</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">:</span>
    dp <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">0</span> <span class="token keyword">for</span> _ <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span>n<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">]</span>
    <span class="token comment"># 基础值，也就是baseline</span>
    dp<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> dp<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">1</span>
    <span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">,</span> n <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
        dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> dp<span class="token punctuation">[</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">+</span> dp<span class="token punctuation">[</span>i<span class="token operator">-</span><span class="token number">2</span><span class="token punctuation">]</span>
    <span class="token keyword">return</span> dp<span class="token punctuation">[</span>n<span class="token punctuation">]</span>
</code></pre> 
<p>根据斐波那契数列的状态转移方程，当前状态只和之前的两个状态有关，其实并不需要那么长的一个 DP table 来存储所有的状态，只要想办法存储之前的两个状态就行了。所以，可以进一步优化，把空间复杂度降为 O(1)：</p> 
<pre><code class="prism language-python"><span class="token keyword">def</span> <span class="token function">fib</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token keyword">if</span> n <span class="token operator">&lt;=</span> <span class="token number">2</span><span class="token punctuation">:</span>
        <span class="token keyword">return</span> <span class="token number">1</span>
    prev <span class="token operator">=</span> <span class="token number">1</span>
    curr <span class="token operator">=</span> <span class="token number">1</span>
    <span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">,</span>n<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
        prev<span class="token punctuation">,</span> curr <span class="token operator">=</span> curr<span class="token punctuation">,</span> prev <span class="token operator">+</span> curr
    <span class="token keyword">return</span> curr
</code></pre> 
<h4><a id="_129"></a>零钱兑换问题</h4> 
<blockquote> 
 <p>给定不同面额的硬币 coins 和一个总金额 amount。编写一个函数来计算可以凑成总金额所需的最少的硬币个数。如果没有任何一种硬币组合能组成总金额，返回 -1。</p> 
 <p>你可以认为每种硬币的数量是无限的.</p> 
</blockquote> 
<p><strong>示例 1：</strong></p> 
<blockquote> 
 <p>输入：coins = [1, 2, 5], amount = 11<br> 输出：3<br> 解释：11 = 5 + 5 + 1</p> 
</blockquote> 
<p><strong>示例 2：</strong></p> 
<blockquote> 
 <p>输入：coins = [2], amount = 3<br> 输出：-1</p> 
</blockquote> 
<p>由于硬币coins是可以无限用的，因此该题唯一可变的状态为总金额amount。因此定义dp[n]表示:要凑出总金额为n，所需的最少硬币数为dp[n]。</p> 
<p>状态转移方程为：<br> <img src="https://images2.imgbox.com/02/c0/gKL6MVe2_o.png" alt="在这里插入图片描述"></p> 
<pre><code class="prism language-python"><span class="token comment"># 伪码框架</span>
<span class="token keyword">def</span> <span class="token function">coinChange</span><span class="token punctuation">(</span>coins<span class="token punctuation">:</span> List<span class="token punctuation">[</span><span class="token builtin">int</span><span class="token punctuation">]</span><span class="token punctuation">,</span> amount<span class="token punctuation">:</span> <span class="token builtin">int</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token comment"># 定义：要凑出金额 n，至少要 dp(n) 个硬币</span>
    <span class="token keyword">def</span> <span class="token function">dp</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">:</span>
        <span class="token comment"># 做选择，选择需要硬币最少的那个结果</span>
        <span class="token keyword">for</span> coin <span class="token keyword">in</span> coins<span class="token punctuation">:</span>
            res <span class="token operator">=</span> <span class="token builtin">min</span><span class="token punctuation">(</span>res<span class="token punctuation">,</span> <span class="token number">1</span> <span class="token operator">+</span> dp<span class="token punctuation">(</span>n <span class="token operator">-</span> coin<span class="token punctuation">)</span><span class="token punctuation">)</span>
        <span class="token keyword">return</span> res
    <span class="token comment"># 我们要求的问题是 dp(amount)</span>
    <span class="token keyword">return</span> dp<span class="token punctuation">(</span>amount<span class="token punctuation">)</span>
</code></pre> 
<p><strong>递归暴力解法</strong></p> 
<pre><code class="prism language-python"><span class="token keyword">def</span> <span class="token function">coinChange</span><span class="token punctuation">(</span>coins<span class="token punctuation">,</span> amount<span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token keyword">def</span> <span class="token function">dp</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">:</span>
        <span class="token comment"># 函数定义为目标金额为n时，所需的最少硬币数量</span>
        <span class="token comment"># base case</span>
        <span class="token comment"># 目标金额为 0 时，所需硬币数量为 0；当目标金额小于 0 时，无解，返回 -1</span>
        <span class="token keyword">if</span> n <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">:</span> <span class="token keyword">return</span> <span class="token number">0</span>
        <span class="token keyword">if</span> n <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">:</span> <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span>
        <span class="token comment"># 求最小值，所以初始化结果为正无穷</span>
        res <span class="token operator">=</span> <span class="token builtin">float</span><span class="token punctuation">(</span><span class="token string">'inf'</span><span class="token punctuation">)</span>
        <span class="token keyword">for</span> coin <span class="token keyword">in</span> coins<span class="token punctuation">:</span>
            subpro <span class="token operator">=</span> dp<span class="token punctuation">(</span>n<span class="token operator">-</span>coin<span class="token punctuation">)</span>
            <span class="token keyword">if</span> subpro <span class="token operator">==</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">:</span>
                <span class="token comment"># 子问题无解，跳过</span>
                <span class="token keyword">continue</span>
            res <span class="token operator">=</span> <span class="token builtin">min</span><span class="token punctuation">(</span>res<span class="token punctuation">,</span> <span class="token number">1</span> <span class="token operator">+</span> subpro<span class="token punctuation">)</span>
        <span class="token keyword">return</span> res <span class="token keyword">if</span> res <span class="token operator">!=</span> <span class="token builtin">float</span><span class="token punctuation">(</span><span class="token string">'inf'</span><span class="token punctuation">)</span> <span class="token keyword">else</span> <span class="token operator">-</span><span class="token number">1</span>
    <span class="token keyword">return</span> dp<span class="token punctuation">(</span>amount<span class="token punctuation">)</span>
</code></pre> 
<p>为了去除重复的计算，我们使用备忘录进行优化：</p> 
<p><strong>带备忘录的递归</strong></p> 
<pre><code class="prism language-python"><span class="token keyword">def</span> <span class="token function">coinChange</span><span class="token punctuation">(</span>coins<span class="token punctuation">,</span> amount<span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token keyword">def</span> <span class="token function">dp</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">:</span>
        <span class="token comment"># 函数定义为目标金额为n时，所需的最少硬币数量</span>
        <span class="token comment"># base case</span>
        <span class="token comment"># 目标金额为 0 时，所需硬币数量为 0；当目标金额小于 0 时，无解，返回 -1</span>
        <span class="token keyword">if</span> n <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">:</span> <span class="token keyword">return</span> <span class="token number">0</span>
        <span class="token keyword">if</span> n <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">:</span> <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span>
        <span class="token keyword">if</span> n <span class="token keyword">in</span> memo<span class="token punctuation">:</span>
            <span class="token keyword">return</span> memo<span class="token punctuation">[</span>n<span class="token punctuation">]</span>
        <span class="token comment"># 求最小值，所以初始化结果为正无穷</span>
        res <span class="token operator">=</span> <span class="token builtin">float</span><span class="token punctuation">(</span><span class="token string">'inf'</span><span class="token punctuation">)</span>
        <span class="token keyword">for</span> coin <span class="token keyword">in</span> coins<span class="token punctuation">:</span>
            subpro <span class="token operator">=</span> dp<span class="token punctuation">(</span>n<span class="token operator">-</span>coin<span class="token punctuation">)</span>
            <span class="token keyword">if</span> subpro <span class="token operator">==</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">:</span>
                <span class="token comment"># 子问题无解，跳过</span>
                <span class="token keyword">continue</span>
            res <span class="token operator">=</span> <span class="token builtin">min</span><span class="token punctuation">(</span>res<span class="token punctuation">,</span> <span class="token number">1</span> <span class="token operator">+</span> subpro<span class="token punctuation">)</span>
        memo<span class="token punctuation">[</span>n<span class="token punctuation">]</span> <span class="token operator">=</span> res <span class="token keyword">if</span> res <span class="token operator">!=</span> <span class="token builtin">float</span><span class="token punctuation">(</span><span class="token string">'inf'</span><span class="token punctuation">)</span> <span class="token keyword">else</span> <span class="token operator">-</span><span class="token number">1</span>
        <span class="token keyword">return</span> memo<span class="token punctuation">[</span>n<span class="token punctuation">]</span>
    memo <span class="token operator">=</span> <span class="token punctuation">{<!-- --></span><span class="token punctuation">}</span>
    <span class="token keyword">return</span> dp<span class="token punctuation">(</span>amount<span class="token punctuation">)</span>
</code></pre> 
<p><strong>DP数组迭代解法</strong></p> 
<p><code>dp[i] = x</code> 表示，<strong>当目标金额为<code>i</code>时，至少需要<code>x</code>枚硬币</strong> 。</p> 
<pre><code class="prism language-python"><span class="token keyword">def</span> <span class="token function">coinChange</span><span class="token punctuation">(</span>coins<span class="token punctuation">,</span> amount<span class="token punctuation">)</span><span class="token punctuation">:</span>
<span class="token comment"># 数组大小为 amount + 1，初始值也为 amount + 1</span>
<span class="token comment"># 因为总的零钱个数不会超过amount,所以初始化amount + 1即可</span>
    dp <span class="token operator">=</span> <span class="token punctuation">[</span>amount <span class="token operator">+</span> <span class="token number">1</span> <span class="token keyword">for</span> _ <span class="token keyword">in</span> <span class="token punctuation">(</span>amount <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">]</span>
    dp<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0</span>
    <span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span><span class="token builtin">len</span><span class="token punctuation">(</span>dp<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
        <span class="token comment">#  内层 for循环，求解的是所有子问题 + 1 的最小值</span>
        <span class="token keyword">for</span> coin <span class="token keyword">in</span> coins<span class="token punctuation">:</span>
            <span class="token comment"># 子问题无解，跳过</span>
            <span class="token keyword">if</span> i <span class="token operator">-</span> coin <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">:</span>
                <span class="token keyword">continue</span>
            dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token builtin">min</span><span class="token punctuation">(</span>dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token operator">+</span>dp<span class="token punctuation">[</span>i<span class="token operator">-</span>coin<span class="token punctuation">]</span><span class="token punctuation">)</span>
    <span class="token keyword">if</span> dp<span class="token punctuation">[</span>amount<span class="token punctuation">]</span> <span class="token operator">==</span> amount <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">:</span>
        <span class="token keyword">return</span>  <span class="token operator">-</span><span class="token number">1</span>
    <span class="token keyword">else</span><span class="token punctuation">:</span>
        <span class="token keyword">return</span> dp<span class="token punctuation">[</span>amount<span class="token punctuation">]</span>
</code></pre> 
<p>以上便是关于动态规划的详细说明介绍，后续会出关于<strong>动态规划系列的相关常见leetcode题</strong>，目录如下(会持续更新)：</p> 
<ol><li><a href="https://blog.csdn.net/qq_42589613/article/details/110411256">Leetcode 300.最长上升子序列</a></li><li><a href="https://blog.csdn.net/qq_42589613/article/details/110469518">Leetcode 1143.最长公共子序列</a></li><li><a href="https://blog.csdn.net/qq_42589613/article/details/110474308">Leetcode 198.打家劫舍</a></li><li><a href="https://blog.csdn.net/qq_42589613/article/details/110670790">Leetcode72.编辑距离</a></li><li><a href="https://blog.csdn.net/qq_42589613/article/details/110670805">Leetcode62.不同路径1</a></li><li><a href="https://blog.csdn.net/qq_42589613/article/details/110674448">Leetcode63.不同路径2</a></li><li><a href="https://blog.csdn.net/qq_42589613/article/details/110674629">Leetcode322.零钱兑换</a></li><li><a href="https://blog.csdn.net/qq_42589613/article/details/110724043">Leetcode64.最小路径和</a></li><li><a href="https://blog.csdn.net/qq_42589613/article/details/110725223">Leetcode53.最大子序和</a><br> 如果想和作者一起学习，欢迎扫描下面二维码关注公众号：<strong>阿旭算法与机器学习</strong>，一起讨论交流。<br> <img src="https://images2.imgbox.com/66/5e/z5jLiz97_o.jpg" alt="在这里插入图片描述"></li></ol>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/3b3f158e761cf45524961cff52d119bd/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">分页式存储（C语言实现）</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/4191274fab2d6c4be9d3ac0a458ae731/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">数据库MVCC看这个肯定有收获</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>