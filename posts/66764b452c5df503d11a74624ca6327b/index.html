<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>学习笔记——pygame最常用的15个模块 - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="学习笔记——pygame最常用的15个模块" />
<meta property="og:description" content="1、Color类 class pygame.Color
Pygame 中用于描述颜色的对象。Color(name) -&gt; Color Color(r, g, b, a) -&gt; Color Color(rgbvalue) -&gt; Color
方法 &amp; 属性
方法描述pygame.Color.r()获取或设置 Color 对象的红色值pygame.Color.g()获取或设置 Color 对象的绿色值pygame.Color.b()获取或设置 Color 对象的蓝色值pygame.Color.a()获取或设置 Color 对象的 alpha 值pygame.Color.cmy()获取或设置 Color 对象表示的 CMY 值pygame.Color.hsva()获取或设置 Color 对象表示的 HSVA 值pygame.Color.hsla()获取或设置 Color 对象表示的 HSLA 值pygame.Color.i1i2i3()获取或设置 Color 对象表示的 I1I2I3 值pygame.Color.normalize()返回 Color 对象的标准化 RGBA 值pygame.Color.correct_gamma()应用一定的伽马值调整 Color 对象pygame.Color.set_length()设置 Color 对象的长度（成员数量）pygame.Color.lerp()返回给定颜色的线性插值pygame.Color.premul_alpha()返回一个颜色，其中r,g,b组件已经乘以了alphapygame.Color.update()设置颜色的元素 （函数详解见官网：https://www.pygame.org/docs/）
Pygame 使用 Color 类表示 RGBA 颜色值，每个颜色值的取值范围是 0 ~ 255。允许通过基本的算术运算创造新的颜色值，支持转换为其他颜色空间，例如 HSV 或 HSL，并让你调整单个颜色通道。当没有给出 alpha 的值默认是 255（不透明）。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/66764b452c5df503d11a74624ca6327b/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2021-05-07T00:21:35+08:00" />
<meta property="article:modified_time" content="2021-05-07T00:21:35+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">学习笔记——pygame最常用的15个模块</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atelier-sulphurpool-light">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <h3><a id="1Color_0"></a>1、Color类</h3> 
<p><strong>class pygame.Color</strong></p> 
<p>Pygame 中用于描述颜色的对象。Color(name) -&gt; Color Color(r, g, b, a) -&gt; Color Color(rgbvalue) -&gt; Color</p> 
<p><strong>方法 &amp; 属性</strong></p> 
<table><thead><tr><th>方法</th><th>描述</th></tr></thead><tbody><tr><td>pygame.Color.r()</td><td>获取或设置 Color 对象的红色值</td></tr><tr><td>pygame.Color.g()</td><td>获取或设置 Color 对象的绿色值</td></tr><tr><td>pygame.Color.b()</td><td>获取或设置 Color 对象的蓝色值</td></tr><tr><td>pygame.Color.a()</td><td>获取或设置 Color 对象的 alpha 值</td></tr><tr><td>pygame.Color.cmy()</td><td>获取或设置 Color 对象表示的 CMY 值</td></tr><tr><td>pygame.Color.hsva()</td><td>获取或设置 Color 对象表示的 HSVA 值</td></tr><tr><td>pygame.Color.hsla()</td><td>获取或设置 Color 对象表示的 HSLA 值</td></tr><tr><td>pygame.Color.i1i2i3()</td><td>获取或设置 Color 对象表示的 I1I2I3 值</td></tr><tr><td>pygame.Color.normalize()</td><td>返回 Color 对象的标准化 RGBA 值</td></tr><tr><td>pygame.Color.correct_gamma()</td><td>应用一定的伽马值调整 Color 对象</td></tr><tr><td>pygame.Color.set_length()</td><td>设置 Color 对象的长度（成员数量）</td></tr><tr><td>pygame.Color.lerp()</td><td>返回给定颜色的线性插值</td></tr><tr><td>pygame.Color.premul_alpha()</td><td>返回一个颜色，其中r,g,b组件已经乘以了alpha</td></tr><tr><td>pygame.Color.update()</td><td>设置颜色的元素</td></tr></tbody></table> 
<p>（函数详解见官网：<a href="https://www.pygame.org/docs/" rel="nofollow">https://www.pygame.org/docs/</a>）</p> 
<p>Pygame 使用 Color 类表示 RGBA 颜色值，每个颜色值的取值范围是 <code>0 ~ 255</code>。允许通过基本的算术运算创造新的颜色值，支持转换为其他颜色空间，例如 HSV 或 HSL，并让你调整单个颜色通道。当没有给出 alpha 的值默认是 255（不透明）。</p> 
<p>“RGB值”可以是一个颜色名，一个 HTML 颜色格式的字符串，一个 16 进制数的字符串，或者一个整型像素值。HTML 格式是 “#rrggbbaa”，其中 “rr”，“gg”，“bb”，“aa” 都是 2 位的 16 进制数。代表 alpha 的 “aa” 是可选的。16 进制数的字符串组成形式为 “0xrrggbbaa”，当然，其中的 “aa” 也是可选的。</p> 
<hr> 
<h3><a id="2display_31"></a>2、display模块</h3> 
<p><strong>pygame.display</strong></p> 
<p>Pygame 中用于控制窗口和屏幕显示的模块。</p> 
<p>注：为了适应语境，display 在该文档中有时翻译为“显示”，有时翻译为“显示界面”。</p> 
<p><strong>函数</strong></p> 
<table><thead><tr><th>函数</th><th>描述</th></tr></thead><tbody><tr><td>pygame.display.init()</td><td>初始化 display 模块</td></tr><tr><td>pygame.display.quit()</td><td>结束 display 模块</td></tr><tr><td>pygame.display.get_init()</td><td>如果 display 模块已经初始化，返回 True</td></tr><tr><td>pygame.display.set_mode()</td><td>初始化一个准备显示的窗口或屏幕</td></tr><tr><td>pygame.display.get_surface()</td><td>获取当前显示的 Surface 对象</td></tr><tr><td>pygame.display.flip()</td><td>更新整个待显示的 Surface 对象到屏幕上</td></tr><tr><td>pygame.display.update()</td><td>更新部分软件界面显示</td></tr><tr><td>pygame.display.get_driver()</td><td>获取 Pygame 显示后端的名字</td></tr><tr><td>pygame.display.Info()</td><td>创建有关显示界面的信息对象</td></tr><tr><td>pygame.display.get_wm_info()</td><td>获取关于当前窗口系统的信息</td></tr><tr><td>pygame.display.list_modes()</td><td>获取全屏模式下可使用的分辨率</td></tr><tr><td>pygame.display.mode_ok()</td><td>为显示模式选择最合适的颜色深度</td></tr><tr><td>pygame.display.gl_get_attribute()</td><td>获取当前显示界面 OpenGL 的属性值</td></tr><tr><td>pygame.display.gl_set_attribute()</td><td>设置当前显示模式的 OpenGL 属性值</td></tr><tr><td>pygame.display.get_active()</td><td>当前显示界面显示在屏幕上时返回 True</td></tr><tr><td>pygame.display.iconify()</td><td>最小化显示的 Surface 对象</td></tr><tr><td>pygame.display.toggle_fullscreen()</td><td>切换全屏模式和窗口模式</td></tr><tr><td>pygame.display.set_gamma()</td><td>修改硬件显示的 gama 坡道</td></tr><tr><td>pygame.display.set_gamma_ramp()</td><td>自定义修改硬件显示的 gama 坡道</td></tr><tr><td>pygame.display.set_icon()</td><td>修改显示窗口的图标</td></tr><tr><td>pygame.display.set_caption()</td><td>设置当前窗口标题</td></tr><tr><td>pygame.display.get_caption()</td><td>获取当前窗口标题</td></tr><tr><td>pygame.display.set_palette()</td><td>为索引显示设置显示调色板</td></tr><tr><td>pygame.display.get_num_displays()</td><td>返回显示的数量</td></tr><tr><td>pygame.display.get_window_size()</td><td>返回窗口或屏幕的大小</td></tr><tr><td>pygame.display.get_allow_screensaver()</td><td>返回屏幕保护程序是否允许运行</td></tr><tr><td>pygame.display.set_allow_screensaver()</td><td>设置屏幕保护程序是否可以运行</td></tr></tbody></table> 
<p>（函数详解见官网：<a href="https://www.pygame.org/docs/" rel="nofollow">https://www.pygame.org/docs/</a>）</p> 
<p>Pygame 的 display 事实上可以有几种初始化的方式。默认情况下，display 作为一个软件驱动的帧缓冲区。除此之外，你可以使用硬件加速和 OpenGL 支持的特殊模块。这些是通过给 <code>pygame.display.set_mode()</code> 传入 flags 参数来控制的。</p> 
<p>Pygame 在任何时间内都只允许有一个显示界面。使用 <code>pygame.display.set_mode()</code> 创建的新显示界面会自动替换掉旧的。如果需要精确控制像素格式或显示分辨率，使用 <code>pygame.display.mode_ok()</code>，<code>pygame.display.list_modes()</code>，和 <code>pygame.display.Info()</code> 来查询显示界面相关的信息。</p> 
<p>一旦 Surface 对象的显示界面被创建出来，这个模块的函数就只影响当前的显示界面。如果该模块未初始化， Surface 对象也会变为“非法”。如果新的显示模式被设置，当前的 Surface 对象将会自动切换到新的显示界面。</p> 
<p>当一个新的显示模式被设置，会在 Pygame 的事件队列中放入几个相关事件。当用于希望关闭程序时，<code>pygame.QUIT</code> 事件会被发送；当显示界面获得和失去焦点时，窗口会得到 <code>pygame.ACTIVEEVENT</code> 事件；如果显示界面设置了 <code>pygame.RESIZABLE</code> 标志，那么当用户调整窗口尺寸时，<code>pygame.VIDEORESIZE</code> 事件会被发送；硬件显示指当接收到 <code>pygame.VIDEOEXPOSE</code> 事件时，将部分需要被重绘的窗口直接绘制到屏幕上。</p> 
<p>一些显示环境拥有自动拉伸所有窗口的选项。当该选项被启动时，自动拉伸会扭曲 Pygame 窗口的外观。</p> 
<hr> 
<h3><a id="3draw__82"></a>3、draw 模块</h3> 
<p><strong>pygame.draw</strong></p> 
<p>Pygame 中绘制图形的模块。</p> 
<p><strong>函数</strong></p> 
<table><thead><tr><th>函数</th><th>描述</th></tr></thead><tbody><tr><td>pygame.draw.rect()</td><td>绘制矩形</td></tr><tr><td>pygame.draw.polygon()</td><td>绘制多边形</td></tr><tr><td>pygame.draw.circle()</td><td>根据圆心和半径绘制圆形</td></tr><tr><td>pygame.draw.ellipse()</td><td>根据限定矩形绘制一个椭圆形</td></tr><tr><td>pygame.draw.arc()</td><td>绘制弧线</td></tr><tr><td>pygame.draw.line()</td><td>绘制线段</td></tr><tr><td>pygame.draw.lines()</td><td>绘制多条连续的线段</td></tr><tr><td>pygame.draw.aaline()</td><td>绘制抗锯齿的线段</td></tr><tr><td>pygame.draw.aalines()</td><td>绘制多条连续的线段（抗锯齿）</td></tr></tbody></table> 
<p>（函数详解见官网：<a href="https://www.pygame.org/docs/" rel="nofollow">https://www.pygame.org/docs/</a>）</p> 
<p>该模块用于在 Surface 对象上绘制一些简单的形状。这些函数将渲染到任何格式的 Surface 对象上。硬件渲染会比普通的软件渲染更耗时。</p> 
<p>大部分函数用 <code>width</code> 参数指定图形边框的大小，如果 <code>width = 0</code> 则表示填充整个图形。</p> 
<p>所有的绘图函数仅能在 Surface 对象的剪切区域生效。这些函数返回一个 Rect，表示包含实际绘制图形的矩形区域。</p> 
<p>大部分函数都有一个 color 参数，传入一个表示 RGB 颜色值的三元组，当然也支持 RGBA 四元组。其中的 A 是 Alpha 的意思，用于控制透明度。不过该模块的函数并不会绘制透明度，而是直接传入到对应 Surface 对象的 pixel alphas 中。color 参数也可以是已经映射到 Surface 对象的像素格式中的整型像素值。</p> 
<p>当这些函数在绘制时，必须暂时锁定 Surface 对象。许多连续绘制的函数可以通过一次性锁定直到画完再解锁来提高效率。</p> 
<hr> 
<h3><a id="4event_112"></a>4、event模块</h3> 
<p><strong>pygame.event</strong></p> 
<p>用于处理事件与事件队列的 Pygame 模块。</p> 
<p><strong>函数</strong></p> 
<table><thead><tr><th>函数</th><th>描述</th></tr></thead><tbody><tr><td>pygame.event.pump()</td><td>让 Pygame 内部自动处理事件</td></tr><tr><td>pygame.event.get()</td><td>从队列中获取事件</td></tr><tr><td>pygame.event.poll()</td><td>从队列中获取一个事件</td></tr><tr><td>pygame.event.wait()</td><td>等待并从队列中获取一个事件</td></tr><tr><td>pygame.event.peek()</td><td>检测某类型事件是否在队列中</td></tr><tr><td>pygame.event.clear()</td><td>从队列中删除所有的事件</td></tr><tr><td>pygame.event.event_name()</td><td>通过 id 获得该事件的字符串名字</td></tr><tr><td>pygame.event.set_blocked()</td><td>控制哪些事件禁止进入队列</td></tr><tr><td>pygame.event.set_allowed()</td><td>控制哪些事件允许进入队列</td></tr><tr><td>pygame.event.get_blocked()</td><td>检测某一类型的事件是否被禁止进入队列</td></tr><tr><td>pygame.event.set_grab()</td><td>控制输入设备与其他应用程序的共享</td></tr><tr><td>pygame.event.get_grab()</td><td>检测程序是否共享输入设备</td></tr><tr><td>pygame.event.post()</td><td>放置一个新的事件到队列中</td></tr><tr><td>pygame.event.Event()</td><td>创建一个新的事件对象</td></tr><tr><td>pygame.event.EventType()</td><td>代表 SDL 事件的 Pygame 对象</td></tr></tbody></table> 
<p>（函数详解见官网：<a href="https://www.pygame.org/docs/" rel="nofollow">https://www.pygame.org/docs/</a>）</p> 
<p>常规的队列是由 <code>pygame.event.EventType</code> 定义的事件对象的组成，有多种方法来访问里边的事件对象：从简单的检测事件是否存在，到直接从栈中获取它们。</p> 
<p>所有事件都有一个类型标识符，这个标识符对应的值定义在 <code>NOEVENT</code> 到 <code>NUMEVENTS</code> 之间（温馨提示：类似于 C 语言的宏定义，明白？）。用户可以自行定义事件，但类型标识符的值应该高于或等于 <code>USEREVENT</code>。</p> 
<p>获取各种输入设备的状态，推荐你直接通过它们相应的模块（mouse，key 和 joystick）提供的函数访问，而不是通过事件队列；如果你使用此函数，请记住，Pygame 需要通过一些方式与系统的窗口管理器和平台的其他部分进行通信。为了保持 Pygame 和系统同步，你需要调用 <code>pygame.event.pump()</code> 确保实时更新，你将在游戏的每次循环中调用这个函数。</p> 
<p>事件队列提供了一些简单的过滤。通过阻止某些事件进入事件队列，可以略微提高游戏的性能（温馨提示：因为这样事件队列的尺寸就会小一些，所以说可以略微提升性能）。使用 <code>pygame.event.set_allowed()</code> 和 <code>pygame.event.set_blocked()</code> 来控制某些事件是否允许进入事件队列。默认所有事件都会进入事件队列。</p> 
<p>事件子系统应该在主线程被调用。如果你希望从其他线程中投递事件消息进入事件队列，请使用 <code>fastevent</code> 包。</p> 
<p>Joysticks（游戏手柄）只有在设备初始化后才会发送事件。</p> 
<p>一个 EventType 事件对象包含一个事件类型标识符和一组成员数据（事件对象不包含方法，只有数据）。EventType 对象从 Python 的事件队列中获得，你也可以使用 <code>pygame.event.Event()</code> 函数创建自定义的新事件。</p> 
<p>由于 SDL 的事件队列限制了事件数量的上限（标准的 SDL 1.2 限制为 128），所以当队列已满时，新的事件将会被扔掉。为了防止丢失事件消息，尤其是代表退出的输入事件（因为当用户点击退出按钮没有反应，往往会被认为“死机”了），你的程序必须定期检测事件，并对其进行处理。</p> 
<p>为了加快事件队列的处理速度，可以使用 <code>pygame.event.set_blocked()</code> 函数阻止一些我们不关注的事件进入队列中。</p> 
<p>所有的 EventType 实例对象都拥有一个事件类型标识符，属性名是 type。你也可以通过事件对象的 dict 属性来完全访问其他属性。所有其他成员属性的值都是通过事件对象的字典来传递。</p> 
<hr> 
<h3><a id="5font_159"></a>5、font模块</h3> 
<p><strong>pygame.font</strong></p> 
<p>Pygame 中加载和表示字体的模块。</p> 
<p><strong>函数</strong></p> 
<table><thead><tr><th>函数</th><th>参数</th></tr></thead><tbody><tr><td>pygame.font.init()</td><td>初始化字体模块</td></tr><tr><td>pygame.font.quit()</td><td>还原字体模块</td></tr><tr><td>pygame.font.get_init()</td><td>检查字体模块是否被初始化</td></tr><tr><td>pygame.font.get_default_font()</td><td>获得默认字体的文件名</td></tr><tr><td>pygame.font.get_fonts()</td><td>获取所有可使用的字体</td></tr><tr><td>pygame.font.match_font()</td><td>在系统中搜索一种特殊的字体</td></tr><tr><td>pygame.font.SysFont()</td><td>从系统字体库创建一个 Font 对象 类</td></tr><tr><td>pygame.font.Font()</td><td>从一个字体文件创建一个 Font 对象</td></tr></tbody></table> 
<p>（函数详解见官网：<a href="https://www.pygame.org/docs/" rel="nofollow">https://www.pygame.org/docs/</a>）</p> 
<p>通过使用现有的 Font 对象，可以完成大多数与字体有关的工作。<code>Pygame.font</code> 模块自身仅可以完成常规的初始化以及通过 <code>pygame.font.Font()</code> 创建 Font 对象。</p> 
<p>你可以通过使用 <code>pygame.font.SysFont()</code> 函数从系统内加载字体。另外还有其他几个函数可以帮助你搜索系统的字体。</p> 
<p>Pygame 配备了内建的默认字体。通过传递 “None” 为文件名访问此字体。</p> 
<p>在 pygame 第一次导入之前，当<code>pygame.font</code> 模块确定环境变量 <code>PYGAME_FREETYPE</code> 时使用基于 <code>pygame.ftfont</code> 的 <code>pygame.freetype</code> 模块。<code>Pygame.ftfont</code> 是一个<code>pygame.font</code> 可兼容模块，兼容绝大部分，除开其中某个字体模块单元测试：<code>Pygame.ftfont</code> 并没有基于字体模块的 SDL_ttf 的 UCS-2字符限制，所以对于大于 ‘uFFFF’ 的码点会产生异常。如果 <code>pygame.freetype</code> 是不可使用的，那么 SDL_ttf 字体模块将会被加载用于替代。</p> 
<hr> 
<h3><a id="6image_188"></a>6、image模块</h3> 
<p><strong>pygame.image</strong></p> 
<p>用于图像传输的 Pygame 模块。</p> 
<p><strong>函数</strong></p> 
<table><thead><tr><th>函数</th><th>描述</th></tr></thead><tbody><tr><td>pygame.image.load()</td><td>从文件加载新图片</td></tr><tr><td>pygame.image.save()</td><td>将图像保存到磁盘上</td></tr><tr><td>pygame.image.get_extended()</td><td>检测是否支持载入扩展的图像格式</td></tr><tr><td>pygame.image.tostring()</td><td>将图像转换为字符串描述</td></tr><tr><td>pygame.image.fromstring()</td><td>将字符串描述转换为图像</td></tr><tr><td>pygame.image.frombuffer()</td><td>创建一个与字符串描述共享数据的 Surface 对象</td></tr></tbody></table> 
<p>（函数详解见官网：<a href="https://www.pygame.org/docs/" rel="nofollow">https://www.pygame.org/docs/</a>）</p> 
<p><strong>注意</strong>：没有 Image 类；当一个图像被成功载入后，将转换为 Surface 对象。Surface 对象允许你在上边画线、设置像素、捕获区域等。</p> 
<p>Image 是 Pygame 相当依赖的一个模块，支持载入的图像格式如下：</p> 
<pre><code class="prism language-python">JPG
PNG
GIF（无动画）
BMP
PCX
TGA（无压缩）
TIF
LBM（和 PBM）
PBM（和 PGM，PPM）
XPM 
</code></pre> 
<p>支持保存为以下格式：</p> 
<pre><code class="prism language-python">BMP
TGA
PNG
JPEG 
</code></pre> 
<hr> 
<h3><a id="7key_231"></a>7、key模块</h3> 
<p><strong>pygame.key</strong></p> 
<p>与键盘相关的 Pygame 模块。</p> 
<p><strong>函数</strong></p> 
<table><thead><tr><th>函数</th><th>描述</th></tr></thead><tbody><tr><td>pygame.key.get_focused()</td><td>当窗口获得键盘的输入焦点时返回 True</td></tr><tr><td>pygame.key.get_pressed()</td><td>获取键盘上所有按键的状态</td></tr><tr><td>pygame.key.get_mods()</td><td>检测是否有组合键被按下</td></tr><tr><td>pygame.key.set_mods()</td><td>临时设置某些组合键为被按下状态</td></tr><tr><td>pygame.key.set_repeat()</td><td>控制重复响应持续按下按键的时间</td></tr><tr><td>pygame.key.get_repeat()</td><td>获取重复响应按键的参数</td></tr><tr><td>pygame.key.name()</td><td>获取按键标识符对应的名字 该模块包含处理与键盘操作相关的函数。</td></tr></tbody></table> 
<p>（函数详解见官网：<a href="https://www.pygame.org/docs/" rel="nofollow">https://www.pygame.org/docs/</a>）</p> 
<p>pygame.KYEDOWN 事件还有个额外的属性 unicode 和 scancode。unicode 代表一个按键翻译后的 Unicode 编码，这包含 shift 按键和组合键。scancode 是扫描码，不同键盘间该值可能不同。不过这对于特殊按键像多媒体键的选择是有用的。</p> 
<p>温馨提示：当键盘按下的时候，键盘会发送一个扫描码给系统。扫描码是键盘反馈哪一个按键被按下的方式，不同类型的键盘扫描码不同。再由系统调用相应的函数将其转换为统一的 Unicode 编码。</p> 
<p>key 属性的值是一个数字，为了方便使用，Pygame 将这些数字定义为以下这些常量：</p> 
<pre><code class="prism language-python">Constant      ASCII   描述
<span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span>
K_BACKSPACE   \b      退格键（Backspace）
K_TAB         \t      制表键（Tab）
K_CLEAR               清除键（clear）
K_RETURN      \r      回车键（Enter）
K_PAUSE               暂停键（Pause）
K_ESCAPE      <span class="token operator">^</span><span class="token punctuation">[</span>      退出键（Escape）
K_SPACE               空格键（Space）
K_EXCLAIM     !       感叹号（exclaim）
K_QUOTEDBL    "       双引号（quotedbl）
K_HASH        <span class="token comment">#       井号（hash）</span>
K_DOLLAR      $       美元符号（dollar）
K_AMPERSAND   <span class="token operator">&amp;</span>       <span class="token operator">and</span> 符号（ampersand）
K_QUOTE       ’       单引号（quote）
K_LEFTPAREN   <span class="token punctuation">(</span>       左小括号（left parenthesis）
K_RIGHTPAREN  <span class="token punctuation">)</span>       右小括号（right parenthesis）
K_ASTERISK    <span class="token operator">*</span>       星号（asterisk）
K_PLUS        <span class="token operator">+</span>       加号（plus sign）
K_COMMA       <span class="token punctuation">,</span>       逗号（comma）
K_MINUS       <span class="token operator">-</span>       减号（minus sign）
K_PERIOD      <span class="token punctuation">.</span>       句号（period）
K_SLASH       <span class="token operator">/</span>       正斜杠（forward slash）
K_0           <span class="token number">0</span>       <span class="token number">0</span>
K_1           <span class="token number">1</span>       <span class="token number">1</span>
K_2           <span class="token number">2</span>       <span class="token number">2</span>
K_3           <span class="token number">3</span>       <span class="token number">3</span>
K_4           <span class="token number">4</span>       <span class="token number">4</span>
K_5           <span class="token number">5</span>       <span class="token number">5</span>
K_6           <span class="token number">6</span>       <span class="token number">6</span>
K_7           <span class="token number">7</span>       <span class="token number">7</span>
K_8           <span class="token number">8</span>       <span class="token number">8</span>
K_9           <span class="token number">9</span>       <span class="token number">9</span>
K_COLON       <span class="token punctuation">:</span>       冒号（colon）
K_SEMICOLON   <span class="token punctuation">;</span>       分号（semicolon）
K_LESS        <span class="token operator">&lt;</span>       小于号（less<span class="token operator">-</span>than sign）
K_EQUALS      <span class="token operator">=</span>       等于号（equals sign）
K_GREATER     <span class="token operator">&gt;</span>       大于号（greater<span class="token operator">-</span>than sign）
K_QUESTION    ?       问号（question mark）
K_AT          @       at 符号（at）
K_LEFTBRACKET <span class="token punctuation">[</span>       左中括号（left bracket）
K_BACKSLASH   \       反斜杠（backslash）
K_RIGHTBRACKET <span class="token punctuation">]</span>      右中括号（right racket）
K_CARET       <span class="token operator">^</span>       脱字符（caret）
K_UNDERSCORE  _       下划线（underscore）
K_BACKQUOTE   `       重音符（grave）
K_a           a       a
K_b           b       b
K_c           c       c
K_d           d       d
K_e           e       e
K_f           f       f
K_g           g       g
K_h           h       h
K_i           i       i
K_j           j       j
K_k           k       k
K_l           l       l
K_m           m       m
K_n           n       n
K_o           o       o
K_p           p       p
K_q           q       q
K_r           r       r
K_s           s       s
K_t           t       t
K_u           u       u
K_v           v       v
K_w           w       w
K_x           x       x
K_y           y       y
K_z           z       z
K_DELETE              删除键（delete）
K_KP0                 <span class="token number">0</span>（小键盘）
K_KP1                 <span class="token number">1</span>（小键盘）
K_KP2                 <span class="token number">2</span>（小键盘）
K_KP3                 <span class="token number">3</span>（小键盘）
K_KP4                 <span class="token number">4</span>（小键盘）
K_KP5                 <span class="token number">5</span>（小键盘）
K_KP6                 <span class="token number">6</span>（小键盘）
K_KP7                 <span class="token number">7</span>（小键盘）
K_KP8                 <span class="token number">8</span>（小键盘）
K_KP9                 <span class="token number">9</span>（小键盘）
K_KP_PERIOD   <span class="token punctuation">.</span>       句号（小键盘）
K_KP_DIVIDE   <span class="token operator">/</span>       除号（小键盘）
K_KP_MULTIPLY <span class="token operator">*</span>       乘号（小键盘）
K_KP_MINUS    <span class="token operator">-</span>       减号（小键盘）
K_KP_PLUS     <span class="token operator">+</span>       加号（小键盘）
K_KP_ENTER    \r      回车键（小键盘）
K_KP_EQUALS   <span class="token operator">=</span>       等于号（小键盘）
K_UP                  向上箭头（up arrow）
K_DOWN                向下箭头（down arrow）
K_RIGHT               向右箭头（right arrow）
K_LEFT                向左箭头（left arrow）
K_INSERT              插入符（insert）
K_HOME                Home 键（home）
K_END                 End 键（end）
K_PAGEUP              上一页（page up）
K_PAGEDOWN            下一页（page down）
K_F1                  F1
K_F2                  F2
K_F3                  F3
K_F4                  F4
K_F5                  F5
K_F6                  F6
K_F7                  F7
K_F8                  F8
K_F9                  F9
K_F10                 F10
K_F11                 F11
K_F12                 F12
K_F13                 F13
K_F14                 F14
K_F15                 F15
K_NUMLOCK             数字键盘锁定键（numlock）
K_CAPSLOCK            大写字母锁定键（capslock）
K_SCROLLOCK           滚动锁定键（scrollock）
K_RSHIFT              右边的 shift 键（right shift）
K_LSHIFT              左边的 shift 键（left shift）
K_RCTRL               右边的 ctrl 键（right ctrl）
K_LCTRL               左边的 ctrl 键（left ctrl）
K_RALT                右边的 alt 键（right alt）
K_LALT                左边的 alt 键（left alt）
K_RMETA               右边的元键（right meta）
K_LMETA               左边的元键（left meta）
K_LSUPER              左边的 Window 键（left windows key）
K_RSUPER              右边的 Window 键（right windows key）
K_MODE                模式转换键（mode shift）
K_HELP                帮助键（<span class="token builtin">help</span>）
K_PRINT               打印屏幕键（<span class="token keyword">print</span> screen）
K_SYSREQ              魔术键（sysrq）
K_BREAK               中断键（<span class="token keyword">break</span>）
K_MENU                菜单键（menu）
K_POWER               电源键（power）
K_EURO                欧元符号（euro）
</code></pre> 
<p>还有一个 mod 属性，用于描述组合键状态。</p> 
<p>以下是组合键的常量定义：</p> 
<pre><code class="prism language-python">Constant      描述
<span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span>
KMOD_NONE     木有同时按下组合键
KMOD_LSHIFT   同时按下左边的 shift 键
KMOD_RSHIFT   同时按下右边的 shift 键
KMOD_SHIFT    同时按下 shift 键
KMOD_LCTRL    同时按下左边的 ctrl 键
KMOD_RCTRL    同时按下右边的 ctrl 键
KMOD_CTRL     同时按下 ctrl 键
KMOD_LALT     同时按下左边的 alt 键
KMOD_RALT     同时按下右边的 alt 键
KMOD_ALT      同时按下 alt 键
KMOD_LMETA    同时按下左边的元键
KMOD_RMETA    同时按下右边的元键
KMOD_META     同时按下元键
KMOD_CAPS     同时按下数字键盘锁定键
KMOD_MODE     同时按下模式转换键
</code></pre> 
<p>温馨提示：如果 mod &amp; KMOD_CTRL 是真的话，表示用户同时按下了 Ctrl 键。</p> 
<hr> 
<h3><a id="8locals_420"></a>8、locals模块</h3> 
<p><strong>pygame.locals</strong> ：Pygame 定义的常量。</p> 
<p>这个模块包含了 Pygame 定义的各种常量。它的内容会被自动放入到 Pygame 模块的名字空间中。你可以使用</p> 
<p><code>from pygame.locals import *</code>将所有的 Pygame 常量导入。</p> 
<p>各个常量的详细描述记录在 Pygame 各个模块的相关文档中。比如 <code>pygame.display.set_mode()</code> 方法用到的 <code>HWSURFACE</code> 常量，你就可以在 display 模块的文档中找到详细的说明；事件类型在 event 模块的文档中可以找到；当产生 <code>KEYDOWN</code> 或 <code>KEYUP</code> 事件时，key 属性描述具体哪个按键被按下，该值是以 <code>K_</code> 开头的常量（<code>MOD_</code> 开头的常量表示各种组合键被按下），在 key 模块的文档中可以找到；最后，<code>TIME_RESOLUTION</code> 被定义在 time 模块中。</p> 
<hr> 
<h3><a id="9mixer_430"></a>9、mixer模块</h3> 
<p><strong>pygame.mixer</strong></p> 
<p>用于加载和播放声音的pygame模块</p> 
<p><strong>函数</strong></p> 
<table><thead><tr><th>函数</th><th>描述</th></tr></thead><tbody><tr><td>pygame.mixer.init</td><td>初始化混音器模块</td></tr><tr><td>pygame.mixer.pre_init</td><td>预设混音器初始化参数</td></tr><tr><td>pygame.mixer.quit</td><td>卸载混音器模块</td></tr><tr><td>pygame.mixer.get_init</td><td>测试混音器是否初始化</td></tr><tr><td>pygame.mixer.stop</td><td>停止播放所有通道</td></tr><tr><td>pygame.mixer.pause</td><td>暂停播放所有通道</td></tr><tr><td>pygame.mixer.unpause</td><td>恢复播放</td></tr><tr><td>pygame.mixer.fadeout</td><td>淡出停止</td></tr><tr><td>pygame.mixer.set_num_channels</td><td>设置播放频道的总数</td></tr><tr><td>pygame.mixer.get_num_channels</td><td>获取播放频道的总数</td></tr><tr><td>pygame.mixer.set_reserved</td><td>预留频道自动使用</td></tr><tr><td>pygame.mixer.find_channel</td><td>找到一个未使用的频道</td></tr><tr><td>pygame.mixer.get_busy</td><td>测试混音器是否正在使用类</td></tr><tr><td>pygame.mixer.Sound</td><td>从文件或缓冲区对象创建新的Sound对象</td></tr><tr><td>pygame.mixer.Channel</td><td>创建一个Channel对象来控制播放</td></tr></tbody></table> 
<p>（函数详解见官网：<a href="https://www.pygame.org/docs/" rel="nofollow">https://www.pygame.org/docs/</a>）</p> 
<p>此模块包含用于加载 Sound 对象和控制播放的类。混音器模块是可选的，取决于SDL_mixer。您的程序应该在使用它之前 测试 模块是否可用并进行初始化。</p> 
<p>混音器模块具有有限数量的声音播放声道。通常程序会告诉 pygame 开始播放音频，它会自动选择一个可用的频道。默认为8个并发通道，但复杂的程序可以更精确地控制通道数量及其使用。</p> 
<p>所有声音播放都混合在后台线程中。当您开始播放Sound对象时，它会在声音继续播放时立即返回。单个Sound对象也可以自动播放多次。</p> 
<p>混音器还有一个特殊流通道用于音乐播放，可通过 <code>pygame.mixer.music</code> 模块访问。</p> 
<p>混音器模块必须像其他 pygame 模块一样进行初始化，但它有一些额外的条件。<code>pygame.mixer.init()</code> 函数采用几个可选参数来控制播放速率和样本大小。Pygame将 默认为合理的值，但pygame无法执行声音重采样，因此应初始化混音器以匹配音频资源的值。</p> 
<p>注意：不要使用较少的延迟声音，请使用较小的缓冲区大小。 默认设置为减少某些计算机上发出沙哑声音的可能性。 您可以在 pygame.mixer.init() 或者 <code>pygame.init()</code> 之前 通过调用<code>pygame.mixer.pre_init()</code>预设混合器初始化参数来更改默认缓冲区。 例如：<code>pygame.mixer.pre_init（44100，-16,2,1024）</code>。在pygame 1.8中，默认大小从1024更改为3072。</p> 
<hr> 
<h3><a id="10mouse_468"></a>10、mouse模块</h3> 
<p><strong>pygame.mouse</strong></p> 
<p>Pygame 中与鼠标工作相关的模块。</p> 
<p><strong>函数</strong></p> 
<table><thead><tr><th>函数</th><th>描述</th></tr></thead><tbody><tr><td>pygame.mouse.get_pressed()</td><td>获取鼠标按键的情况（是否被按下）</td></tr><tr><td>pygame.mouse.get_rel()</td><td>获取鼠标一系列的活动</td></tr><tr><td>pygame.mouse.set_pos()</td><td>设置鼠标光标的位置</td></tr><tr><td>pygame.mouse.set_visible()</td><td>隐藏或显示鼠标光标</td></tr><tr><td>pygame.mouse.get_focused()</td><td>检查程序界面是否获得鼠标焦点</td></tr><tr><td>pygame.mouse.set_cursor()</td><td>设置鼠标光标在程序内的显示图像</td></tr><tr><td>pygame.mouse.get_cursor()</td><td>获取鼠标光标在程序内的显示图像</td></tr></tbody></table> 
<p>（函数详解见官网：<a href="https://www.pygame.org/docs/" rel="nofollow">https://www.pygame.org/docs/</a>）</p> 
<p>这些函数可以用于获取目前鼠标设备的情况，也可以改变鼠标在程序内的显示光标。</p> 
<p>当设置显示模式之后，事件队列将开始接收鼠标事件。当鼠标按键被按下时会产生 <code>pygame.MOUSEBUTTONDOWN</code> 事件，当鼠标按键被松开时会产生 <code>pygame.MOUSEBUTTONUP</code> 事件。这些事件包含了一个按键属性，用于表示具体由哪个按键所触发。</p> 
<p>当鼠标滑轮被滚动时也会产生 <code>pygame.MOUSEBUTTONDOWN</code> 和 <code>pygame.MOUSEBUTTONUP</code> 事件。当鼠标滑轮往上滚动时，按键将会被设置成4；当鼠标滑轮向下滚动时，按键会被设置成 5。</p> 
<p>任何时候鼠标移动都会产生一个 <code>pygame.MOUSEMOTION</code> 事件。鼠标的活动被拆分成小而精确的事件。当鼠标运动时，大量的运动事件会被放入相应的队列中等待处理。没有及时清除掉一些运动事件是队列被塞满的主要原因。</p> 
<p>如果鼠标光标被隐藏并且输入被当前显示器占用，鼠标会进入虚拟输入模式，在此模式内，鼠标的相关活动不会因为屏幕的边界限制而停止。调用 <code>pygame.mouse.set_visible()</code> 方法和 <code>pygame.event.set_grab()</code> 方法进行设置。</p> 
<hr> 
<h3><a id="11Rect_496"></a>11、Rect对象</h3> 
<p><strong>class pygame.RectRect</strong></p> 
<p>是用于存储矩形坐标的 Pygame 对象。</p> 
<pre><code class="prism language-python">Rect<span class="token punctuation">(</span>left<span class="token punctuation">,</span> top<span class="token punctuation">,</span> width<span class="token punctuation">,</span> height<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">&gt;</span> Rect
Rect<span class="token punctuation">(</span><span class="token punctuation">(</span>left<span class="token punctuation">,</span> top<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">(</span>width<span class="token punctuation">,</span> height<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">&gt;</span> Rect
Rect<span class="token punctuation">(</span><span class="token builtin">object</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">&gt;</span> Rect
</code></pre> 
<p><strong>属性 &amp; 方法</strong></p> 
<table><thead><tr><th>函数</th><th>描述</th></tr></thead><tbody><tr><td>pygame.Rect.copy()</td><td>拷贝 Rect 对象</td></tr><tr><td>pygame.Rect.move()</td><td>移动 Rect 对象</td></tr><tr><td>pygame.Rect.move_ip()</td><td>原地移动 Rect 对象</td></tr><tr><td>pygame.Rect.inflate()</td><td>放大和缩小 Rect 对象的尺寸</td></tr><tr><td>pygame.Rect.inflate_ip()</td><td>原地放大和缩小 Rect 对象的尺寸</td></tr><tr><td>pygame.Rect.clamp()</td><td>将一个 Rect 对象移动到另一个 Rect 对象的中心</td></tr><tr><td>pygame.Rect.clamp_ip()</td><td>原地将一个 Rect 对象移动到另一个 Rect 对象的中心</td></tr><tr><td>pygame.Rect.clip()</td><td>获取两个 Rect 对象互相重叠的部分</td></tr><tr><td>pygame.Rect.union()</td><td>将两个 Rect 对象合并</td></tr><tr><td>pygame.Rect.union_ip()</td><td>原地将两个 Rect 对象合并</td></tr><tr><td>pygame.Rect.unionall()</td><td>将多个 Rect 对象合并</td></tr><tr><td>pygame.Rect.unionall_ip()</td><td>原地将多个 Rect 对象合并</td></tr><tr><td>pygame.Rect.fit()</td><td>按照一定的宽高比调整 Rect 对象</td></tr><tr><td>pygame.Rect.normalize()</td><td>翻转 Rect 对象（如果尺寸为负数）</td></tr><tr><td>pygame.Rect.contains()</td><td>检测一个 Rect 对象是否完全包含在该 Rect 对象内</td></tr><tr><td>pygame.Rect.collidepoint()</td><td>检测一个点是否包含在该 Rect 对象内</td></tr><tr><td>pygame.Rect.colliderect()</td><td>检测两个 Rect 对象是否重叠</td></tr><tr><td>pygame.Rect.collidelist()</td><td>检测该 Rect 对象是否与列表中的任何一个矩形有交集</td></tr><tr><td>pygame.Rect.collidelistall()</td><td>检测该 Rect 对象与列表中的每个矩形是否有交集</td></tr><tr><td>pygame.Rect.collidedict()</td><td>检测该 Rect 对象是否与字典中的任何一个矩形有交集</td></tr><tr><td>pygame.Rect.collidedictall()</td><td>检测该 Rect 对象与字典中的每个矩形是否有交集</td></tr></tbody></table> 
<p>（函数详解见官网：<a href="https://www.pygame.org/docs/" rel="nofollow">https://www.pygame.org/docs/</a>）</p> 
<p>Pygame 通过 Rect 对象存储和操作矩形区域。一个 Rect 对象可以由 <code>left</code>，<code>top</code>，<code>width</code>，<code>height</code> 几个值创建。Rect 也可以是由 Pygame 的对象所创建，它们拥有一个属性叫“rect”。</p> 
<p>任何需要一个 Rect 对象作为参数的 Pygame 函数都可以使用以上值构造一个 Rect。这样使得作为参数传递的同时创建 Rect 成为可能。</p> 
<p>Rect 对象中的大部分方法在修改矩形的位置、尺寸后会返回一个新的 Rect 拷贝，原始的 Rect 对象不会有任何改变。但有些方法比较特殊，它们会“原地”修改 Rect 对象（也就是说它们会改动原始的 Rect 对象），这些方法都会以 “ip” 作为后缀。</p> 
<p>对了方便大家移动和对齐，Rect 对象提供以下这些虚拟属性：</p> 
<pre><code class="prism language-python">x<span class="token punctuation">,</span>y
top<span class="token punctuation">,</span> left<span class="token punctuation">,</span> bottom<span class="token punctuation">,</span> right
topleft<span class="token punctuation">,</span> bottomleft<span class="token punctuation">,</span> topright<span class="token punctuation">,</span> bottomright
midtop<span class="token punctuation">,</span> midleft<span class="token punctuation">,</span> midbottom<span class="token punctuation">,</span> midright
center<span class="token punctuation">,</span> centerx<span class="token punctuation">,</span> centery
size<span class="token punctuation">,</span> width<span class="token punctuation">,</span> height
w<span class="token punctuation">,</span>h
</code></pre> 
<p>上边这些属性均可以被赋值，例如：</p> 
<pre><code class="prism language-python">rect1<span class="token punctuation">.</span>right <span class="token operator">=</span> <span class="token number">10</span> 
rect2<span class="token punctuation">.</span>center <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token number">20</span><span class="token punctuation">,</span><span class="token number">30</span><span class="token punctuation">)</span>
</code></pre> 
<p>给 size，width，height 属性赋值将改变矩形的尺寸；给其它属性赋值将移动矩形。注意：一些属性是整数，一些是整数对。</p> 
<p>如果一个 Rect 对象的 width 或 height 非 0，那么将在非 0 测试中返回 True。一些方法返回尺寸为 0 的 Rect 对象，用于表示一个非法的矩形。</p> 
<p>Rect 对象的坐标都是整数，size 的值可以是负数，但在大多数情况下被认为是非法的。</p> 
<p>还有一些方法可以实现矩形间碰撞检测，大多数 Python 的容器可以用于检索其中的元素与某个 Rect 对象是否碰撞。</p> 
<p>Rect 对象覆盖的范围并不包含 right 和 bottom 指定的边缘位置。</p> 
<hr> 
<h3><a id="13time_568"></a>13、time模块</h3> 
<p><strong>pygame.time</strong></p> 
<p>Pygame 中用于监控时间的模块。</p> 
<p><strong>函数</strong></p> 
<table><thead><tr><th>函数</th><th>描述</th></tr></thead><tbody><tr><td>pygame.time.get_ticks()</td><td>获取以毫秒为单位的时间</td></tr><tr><td>pygame.time.wait()</td><td>暂停程序一段时间</td></tr><tr><td>pygame.time.delay()</td><td>暂停程序一段时间</td></tr><tr><td>pygame.time.set_timer()</td><td>在事件队列上重复创建一个事件</td></tr><tr><td>pygame.time.Clock()</td><td>创建一个对象来帮助跟踪时间</td></tr></tbody></table> 
<p>（函数详解见官网：<a href="https://www.pygame.org/docs/" rel="nofollow">https://www.pygame.org/docs/</a>）</p> 
<p>Pygame中的时间以毫秒（1/1000秒）表示。大多数平台的时间分辨率有限，大约为10毫秒。该分辨率（以毫秒为单位) 以常量 <code>TIMER_RESLUTION</code> 给出。</p> 
<hr> 
<h3><a id="14music_586"></a>14、music模块</h3> 
<p><strong>pygame.mixer.music</strong></p> 
<p>Pygame 中控制音频流的模块。</p> 
<p><strong>函数</strong></p> 
<table><thead><tr><th>函数</th><th>描述</th></tr></thead><tbody><tr><td>pygame.mixer.music.load()</td><td>载入一个音乐文件用于播放</td></tr><tr><td>pygame.mixer.music.play()</td><td>开始播放音乐流</td></tr><tr><td>pygame.mixer.music.rewind()</td><td>重新开始播放音乐</td></tr><tr><td>pygame.mixer.music.stop()</td><td>结束音乐播放</td></tr><tr><td>pygame.mixer.music.pause()</td><td>暂停音乐播放</td></tr><tr><td>pygame.mixer.music.unpause()</td><td>恢复音乐播放</td></tr><tr><td>pygame.mixer.music.fadeout()</td><td>淡出的效果结束音乐播放</td></tr><tr><td>pygame.mixer.music.set_volume()</td><td>设置音量</td></tr><tr><td>pygame.mixer.music.get_volume()</td><td>获取音量</td></tr><tr><td>pygame.mixer.music.get_busy()</td><td>检查是否正在播放音乐</td></tr><tr><td>pygame.mixer.music.set_pos()</td><td>设置播放的位置</td></tr><tr><td>pygame.mixer.music.get_pos()</td><td>获取播放的位置</td></tr><tr><td>pygame.mixer.music.queue()</td><td>将一个音乐文件放入队列中，并排在当前播放的音乐之后</td></tr><tr><td>pygame.mixer.music.set_endevent()</td><td>当播放结束时发出一个事件</td></tr><tr><td>pygame.mixer.music.get_endevent()</td><td>获取播放结束时发送的事件</td></tr></tbody></table> 
<p>（函数详解见官网：<a href="https://www.pygame.org/docs/" rel="nofollow">https://www.pygame.org/docs/</a>）</p> 
<p>Pygame 中播放音乐的模块和 <code>pygame.mixer</code> 模块是密切联系的。使用音乐模块去控制在调音器上的音乐播放。</p> 
<p>音乐（music）播放和声音（sound）播放的不同之处在于音乐是流式的，并且绝对不会在一开始就把一个音乐文件全部载入。调音系统在工作刚开始时仅支持单音乐流。</p> 
<p><strong>注意</strong>：对于 MP3 格式的支持是受限制的。在一些系统上，一种不受支持的格式将会是系统崩溃，例如 Debian Linux。为了游戏的稳定性，建议使用 OGG 进行替代。</p> 
<hr> 
<h3><a id="15pygame_619"></a>15、pygame模块</h3> 
<p><strong>pygame</strong></p> 
<p>Pygame 最顶层的包。</p> 
<p><strong>函数 &amp; 属性</strong></p> 
<table><thead><tr><th>函数</th><th>描述</th></tr></thead><tbody><tr><td>pygame.init()</td><td>初始化所有导入的 pygame 模块</td></tr><tr><td>pygame.quit()</td><td>卸载所有导入的 pygame 模块</td></tr><tr><td>pygame.error()</td><td>标准 pygame 异常模块</td></tr><tr><td>pygame.get_error()</td><td>获得当前错误信息</td></tr><tr><td>pygame.set_error()</td><td>设置当前错误信息</td></tr><tr><td>pygame.get_sdl_version()</td><td>获得 SDL 的版本号</td></tr><tr><td>pygame.get_sdl_byteorder()</td><td>获得 SDL 的字节顺序</td></tr><tr><td>pygame.register_quit()</td><td>注册一个函数，这个函数将在 pygame 退出时被调用</td></tr><tr><td>pygame.encode_string()</td><td>对 unicode 或字节对象编码</td></tr><tr><td>pygame.encode_file_path()</td><td>将 unicode 或字节对象编码为文件系统路径</td></tr></tbody></table> 
<p>（函数详解见官网：<a href="https://www.pygame.org/docs/" rel="nofollow">https://www.pygame.org/docs/</a>）<br> pygame 包是可供使用的最顶层的包。Pygame 被分成许多子模块，但是并不会影响程序使用 Pygame。</p> 
<p>为了方便，在 pygame 中绝大多数的顶级变量被放入名为“<code>pygame.locals</code>”的模块中。意思是说这些变量可通过以下方式导入：</p> 
<pre><code class="prism language-python"><span class="token keyword">import</span> pygame 
<span class="token keyword">from</span> pygame<span class="token punctuation">.</span><span class="token builtin">locals</span> <span class="token keyword">import</span> <span class="token operator">*</span>
</code></pre> 
<p>当你导入 pygame 后，所有可用的 pygame 子模块都将自动被导入。需要注意的是，一些 pygame 模块是“可选的”，并且可能无法使用。以防万一，Pygame 将提供了一个占位符对象替代原来的模块，这个对象可用来测试某些功能（变量）是否可用。</p> 
<hr> 
<p><br><br>参考文章：<br> Pygame官网:<a href="https://www.pygame.org/docs/" rel="nofollow">https://www.pygame.org/docs/</a><br> pygame中文手册pdf版本:<a href="https://yihang.cowtransfer.com/s/7b027011c9cd4a" rel="nofollow">https://yihang.cowtransfer.com/s/7b027011c9cd4a</a></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/c54b0f3d19ee08b097b4a5ff0148e358/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">python数据可视化——画图基础1（figure 、坐标轴和图例设置）</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/6e3a47cc1ef7dab1deb96570933d47b1/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">linux怎么创建交换空间,如何在Linux下创建新的交换空间swap的方法</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>