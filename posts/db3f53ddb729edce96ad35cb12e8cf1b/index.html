<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Lightgbm算法 - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Lightgbm算法" />
<meta property="og:description" content="Lightgbm算法 一. 发展过程----why Lightgbm C 3.0 ( 信 息 增 益 ， 信 息 增 益 率 ) − &amp;gt; C A R T ( G i n i ) − &amp;gt; 提 升 树 ( A d a B o o s t ) C3.0(信息增益，信息增益率)-&amp;gt;CART(Gini)-&amp;gt;提升树(AdaBoost) C3.0(信息增益，信息增益率)−&gt;CART(Gini)−&gt;提升树(AdaBoost)
− &amp;gt; G B D T − &amp;gt; X G B o o s t − &amp;gt; L i g h t g b m -&amp;gt;GBDT-&amp;gt;XGBoost-&amp;gt;Lightgbm −&gt;GBDT−&gt;XGBoost−&gt;Lightgbm" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/db3f53ddb729edce96ad35cb12e8cf1b/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2017-11-04T10:14:21+08:00" />
<meta property="article:modified_time" content="2017-11-04T10:14:21+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Lightgbm算法</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <h3><a id="Lightgbm_0"></a>Lightgbm算法</h3> 
<h4><a id="	why_Lightgbm_2"></a>一. 发展过程----why Lightgbm</h4> 
<p><span class="katex--display"><span class="katex-display"><span class="katex"><span class="katex-mathml"> 
      
       
        
        
          C 
         
        
          3.0 
         
        
          ( 
         
        
          信 
         
        
          息 
         
        
          增 
         
        
          益 
         
        
          ， 
         
        
          信 
         
        
          息 
         
        
          增 
         
        
          益 
         
        
          率 
         
        
          ) 
         
        
          − 
         
        
          &amp;gt; 
         
        
          C 
         
        
          A 
         
        
          R 
         
        
          T 
         
        
          ( 
         
        
          G 
         
        
          i 
         
        
          n 
         
        
          i 
         
        
          ) 
         
        
          − 
         
        
          &amp;gt; 
         
        
          提 
         
        
          升 
         
        
          树 
         
        
          ( 
         
        
          A 
         
        
          d 
         
        
          a 
         
        
          B 
         
        
          o 
         
        
          o 
         
        
          s 
         
        
          t 
         
        
          ) 
         
        
       
         C3.0(信息增益，信息增益率)-&amp;gt;CART(Gini)-&amp;gt;提升树(AdaBoost) 
        
       
     </span><span class="katex-html"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathit" style="margin-right: 0.07153em;">C</span><span class="mord">3</span><span class="mord">.</span><span class="mord">0</span><span class="mopen">(</span><span class="mord cjk_fallback">信</span><span class="mord cjk_fallback">息</span><span class="mord cjk_fallback">增</span><span class="mord cjk_fallback">益</span><span class="mord cjk_fallback">，</span><span class="mord cjk_fallback">信</span><span class="mord cjk_fallback">息</span><span class="mord cjk_fallback">增</span><span class="mord cjk_fallback">益</span><span class="mord cjk_fallback">率</span><span class="mclose">)</span><span class="mord">−</span><span class="mspace" style="margin-right: 0.277778em;"></span><span class="mrel">&gt;</span><span class="mspace" style="margin-right: 0.277778em;"></span></span><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathit" style="margin-right: 0.07153em;">C</span><span class="mord mathit">A</span><span class="mord mathit" style="margin-right: 0.00773em;">R</span><span class="mord mathit" style="margin-right: 0.13889em;">T</span><span class="mopen">(</span><span class="mord mathit">G</span><span class="mord mathit">i</span><span class="mord mathit">n</span><span class="mord mathit">i</span><span class="mclose">)</span><span class="mord">−</span><span class="mspace" style="margin-right: 0.277778em;"></span><span class="mrel">&gt;</span><span class="mspace" style="margin-right: 0.277778em;"></span></span><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord cjk_fallback">提</span><span class="mord cjk_fallback">升</span><span class="mord cjk_fallback">树</span><span class="mopen">(</span><span class="mord mathit">A</span><span class="mord mathit">d</span><span class="mord mathit">a</span><span class="mord mathit" style="margin-right: 0.05017em;">B</span><span class="mord mathit">o</span><span class="mord mathit">o</span><span class="mord mathit">s</span><span class="mord mathit">t</span><span class="mclose">)</span></span></span></span></span></span><br> <span class="katex--display"><span class="katex-display"><span class="katex"><span class="katex-mathml"> 
      
       
        
        
          − 
         
        
          &amp;gt; 
         
        
          G 
         
        
          B 
         
        
          D 
         
        
          T 
         
        
          − 
         
        
          &amp;gt; 
         
        
          X 
         
        
          G 
         
        
          B 
         
        
          o 
         
        
          o 
         
        
          s 
         
        
          t 
         
        
          − 
         
        
          &amp;gt; 
         
        
          L 
         
        
          i 
         
        
          g 
         
        
          h 
         
        
          t 
         
        
          g 
         
        
          b 
         
        
          m 
         
        
       
         -&amp;gt;GBDT-&amp;gt;XGBoost-&amp;gt;Lightgbm 
        
       
     </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.66666em; vertical-align: -0.08333em;"></span><span class="mord">−</span><span class="mspace" style="margin-right: 0.277778em;"></span><span class="mrel">&gt;</span><span class="mspace" style="margin-right: 0.277778em;"></span></span><span class="base"><span class="strut" style="height: 0.76666em; vertical-align: -0.08333em;"></span><span class="mord mathit">G</span><span class="mord mathit" style="margin-right: 0.05017em;">B</span><span class="mord mathit" style="margin-right: 0.02778em;">D</span><span class="mord mathit" style="margin-right: 0.13889em;">T</span><span class="mord">−</span><span class="mspace" style="margin-right: 0.277778em;"></span><span class="mrel">&gt;</span><span class="mspace" style="margin-right: 0.277778em;"></span></span><span class="base"><span class="strut" style="height: 0.76666em; vertical-align: -0.08333em;"></span><span class="mord mathit" style="margin-right: 0.07847em;">X</span><span class="mord mathit">G</span><span class="mord mathit" style="margin-right: 0.05017em;">B</span><span class="mord mathit">o</span><span class="mord mathit">o</span><span class="mord mathit">s</span><span class="mord mathit">t</span><span class="mord">−</span><span class="mspace" style="margin-right: 0.277778em;"></span><span class="mrel">&gt;</span><span class="mspace" style="margin-right: 0.277778em;"></span></span><span class="base"><span class="strut" style="height: 0.88888em; vertical-align: -0.19444em;"></span><span class="mord mathit">L</span><span class="mord mathit">i</span><span class="mord mathit" style="margin-right: 0.03588em;">g</span><span class="mord mathit">h</span><span class="mord mathit">t</span><span class="mord mathit" style="margin-right: 0.03588em;">g</span><span class="mord mathit">b</span><span class="mord mathit">m</span></span></span></span></span></span><br> CART模型往往过于简单无法有效地进行预测，因此一个更加强力的模型叫做tree ensemble。</p> 
<h5><a id="1	AdaBoost_6"></a>1. AdaBoost算法</h5> 
<p>AdaBoost是一种提升树的方法，和三个臭皮匠，赛过诸葛亮的道理一样(类似于专家打分)。<br> AdaBoost两个问题：<br> (1) 如何改变训练数据的权重或概率分布<br> 提高前一轮被弱分类器错误分类的样本的权重，降低前一轮被分对的权重<br> (2) 如何将弱分类器组合成一个强分类器，亦即，每个分类器，前面的权重如何设置<br> 采取”多数表决”的方法.加大分类错误率小的弱分类器的权重，使其作用较大，而减小分类错误率大的弱分类器的权重，使其在表决中起较小的作用。</p> 
<h5><a id="2GBDT_13"></a>2.GBDT算法以及优缺点</h5> 
<p>GBDT和AdaBosst很类似，但是又有所不同。<br> GBDT和其它Boosting算法一样，通过将表现一般的数个模型（通常是深度固定的决策树）组合在一起来集成一个表现较好的模型。AdaBoost是通过提升错分数据点的权重来定位模型的不足， Gradient Boosting通过负梯度来识别问题，通过计算负梯度来改进模型，即通过反复地选择一个指向负梯度方向的函数，该算法可被看做在函数空间里对目标函数进行优化。<br> 因此可以说 。<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         G 
        
       
         r 
        
       
         a 
        
       
         d 
        
       
         i 
        
       
         e 
        
       
         n 
        
       
         t 
        
       
         B 
        
       
         o 
        
       
         o 
        
       
         s 
        
       
         t 
        
       
         i 
        
       
         n 
        
       
         g 
        
       
         = 
        
       
         G 
        
       
         r 
        
       
         a 
        
       
         d 
        
       
         i 
        
       
         e 
        
       
         n 
        
       
         t 
        
       
         D 
        
       
         e 
        
       
         s 
        
       
         c 
        
       
         e 
        
       
         n 
        
       
         t 
        
       
         + 
        
       
         B 
        
       
         o 
        
       
         o 
        
       
         s 
        
       
         t 
        
       
         i 
        
       
         n 
        
       
         g 
        
       
      
        Gradient Boosting = Gradient Descent +Boosting 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.88888em; vertical-align: -0.19444em;"></span><span class="mord mathit">G</span><span class="mord mathit" style="margin-right: 0.02778em;">r</span><span class="mord mathit">a</span><span class="mord mathit">d</span><span class="mord mathit">i</span><span class="mord mathit">e</span><span class="mord mathit">n</span><span class="mord mathit">t</span><span class="mord mathit" style="margin-right: 0.05017em;">B</span><span class="mord mathit">o</span><span class="mord mathit">o</span><span class="mord mathit">s</span><span class="mord mathit">t</span><span class="mord mathit">i</span><span class="mord mathit">n</span><span class="mord mathit" style="margin-right: 0.03588em;">g</span><span class="mspace" style="margin-right: 0.277778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right: 0.277778em;"></span></span><span class="base"><span class="strut" style="height: 0.77777em; vertical-align: -0.08333em;"></span><span class="mord mathit">G</span><span class="mord mathit" style="margin-right: 0.02778em;">r</span><span class="mord mathit">a</span><span class="mord mathit">d</span><span class="mord mathit">i</span><span class="mord mathit">e</span><span class="mord mathit">n</span><span class="mord mathit">t</span><span class="mord mathit" style="margin-right: 0.02778em;">D</span><span class="mord mathit">e</span><span class="mord mathit">s</span><span class="mord mathit">c</span><span class="mord mathit">e</span><span class="mord mathit">n</span><span class="mord mathit">t</span><span class="mspace" style="margin-right: 0.222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right: 0.222222em;"></span></span><span class="base"><span class="strut" style="height: 0.87777em; vertical-align: -0.19444em;"></span><span class="mord mathit" style="margin-right: 0.05017em;">B</span><span class="mord mathit">o</span><span class="mord mathit">o</span><span class="mord mathit">s</span><span class="mord mathit">t</span><span class="mord mathit">i</span><span class="mord mathit">n</span><span class="mord mathit" style="margin-right: 0.03588em;">g</span></span></span></span></span><br> <strong>缺点：</strong><br> GBDT -&gt;预排序方法(pre-sorted)<br> (1).空间消耗大。这样的算法需要保存数据的特征值，还保存了特征排序的结果（例如排序后的索引，为了后续快速的计算分割点），这里需要消耗训练数据两倍的内存。<br> (2).时间上也有较大的开销，在遍历每一个分割点的时候，都需要进行分裂增益的计算，消耗的代价大。<br> (3).对cache优化不友好。在预排序后，特征对梯度的访问是一种随机访问，并且不同的特征访问的顺序不一样，无法对cache进行优化。同时，在每一层长树的时候，需要随机访问一个行索引到叶子索引的数组，并且不同特征访问的顺序也不一样，也会造成较大的cache miss。</p> 
<h5><a id="3Why_22"></a>3.Why？</h5> 
<p>常用的机器学习算法，例如神经网络等算法，都可以以mini-batch的方式训练，训练数据的大小不会受到内存限制。而GBDT在每一次迭代的时候，都需要遍历整个训练数据多次。如果把整个训练数据装进内存则会限制训练数据的大小；如果不装进内存，反复地读写训练数据又会消耗非常大的时间。尤其面对工业级海量的数据，普通的GBDT算法是不能满足其需求的。<br> LightGBM提出的主要原因就是为了解决GBDT在海量数据遇到的问题，让GBDT可以更好更快地用于工业实践。</p> 
<h4><a id="__25"></a>二. 基本介绍</h4> 
<p>LightGBM is a gradient boosting framework that uses tree based learning algorithms. It is designed to be distributed and efficient with the following advantages:<br> LightGBM 是一个基于树学习的梯度提升框架，支持高效率的并行训练，它有以下优势：<br> Faster training speed and higher efficiency</p> 
<ul><li>更快的训练效率<br> Lower memory usage</li><li>低内存使用<br> Better accuracy</li><li>更好的准确率<br> Parallel and GPU learning supported</li><li>支持并行和GPU<br> Capable of handling large-scale data</li><li>可处理大规模数据<br> <strong>参考：</strong> <a href="https://github.com/Microsoft/LightGBM">https://github.com/Microsoft/LightGBM</a><br> LightGBM主打的高效并行训练让其性能超越现有其他boosting工具。一个实验表明，在Higgs数据集上LightGBM比XGBoost快将近10倍，内存占用率大约为XGBoost的1/6。</li></ul> 
<p><img src="https://images2.imgbox.com/75/a0/GHXkJtxS_o.png" alt="内存占用"></p> 
<h4><a id="__lighgbm_44"></a>三. lighgbm原理</h4> 
<ol><li>基于Histogram的决策树算法</li><li>带深度限制的Leaf-wise的叶子生长策略</li><li>直方图做差加速</li><li>直接支持类别特征(Categorical Feature)</li><li>Cache命中率优化</li><li>基于直方图的稀疏特征优化</li><li>多线程优化<br> 下面主要介绍Histogram（直方图）做差加速、带深度限制的Leaf-wise的叶子生长策略。</li></ol> 
<h5><a id="1_54"></a>1.直方图算法</h5> 
<p>直方图算法的基本思想是先把连续的浮点特征值离散化成k个整数，同时构造一个宽度为k的直方图。在遍历数据的时候，根据离散化后的值作为索引在直方图中累积统计量，当遍历一次数据后，直方图累积了需要的统计量，然后根据直方图的离散值，遍历寻找最优的分割点。</p> 
<p><img src="https://images2.imgbox.com/e7/c1/7P5HqBmv_o.png" alt="这里写图片描述"></p> 
<p>使用直方图算法有很多优点。首先，最明显就是内存消耗的降低，直方图算法不仅不需要额外存储预排序的结果，而且可以只保存特征离散化后的值，而这个值一般用8位整型存储就足够了，内存消耗可以降低为原来的1/8。</p> 
<p><img src="https://images2.imgbox.com/14/18/HIC3f7HG_o.png" alt="这里写图片描述"></p> 
<p>然后在计算上的代价也大幅降低，预排序算法每遍历一个特征值就需要计算一次分裂的增益，而直方图算法只需要计算k次（k可以认为是常数），时间复杂度从O(#data*#feature)优化到O(k*#features)。<br> 当然，Histogram算法并不是完美的。由于特征被离散化后，找到的并不是很精确的分割点，所以会对结果产生影响。但在不同的数据集上的结果表明，离散化的分割点对最终的精度影响并不是很大，甚至有时候会更好一点。原因是决策树本来就是弱模型，分割点是不是精确并不是太重要；较粗的分割点也有正则化的效果，可以有效地防止过拟合；即使单棵树的训练误差比精确分割的算法稍大，但在梯度提升（Gradient Boosting）的框架下没有太大的影响。</p> 
<h5><a id="2Lightgbm_Histogram_65"></a>2.Lightgbm 的Histogram（直方图）做差加速</h5> 
<p>一个容易观察到的现象：一个叶子的直方图可以由它的父亲节点的直方图与它兄弟的直方图做差得到。通常构造直方图，需要遍历该叶子上的所有数据，但直方图做差仅需遍历直方图的k个桶。利用这个方法，LightGBM可以在构造一个叶子的直方图后，可以用非常微小的代价得到它兄弟叶子的直方图，在速度上可以提升一倍。<br> <img src="https://images2.imgbox.com/96/f9/GIhlUoej_o.png" alt="这里写图片描述"></p> 
<h5><a id="3Leafwise_69"></a>3.带深度限制的Leaf-wise的叶子生长策略</h5> 
<p>Level-wise过一次数据可以同时分裂同一层的叶子，容易进行多线程优化，也好控制模型复杂度，不容易过拟合。但实际上Level-wise是一种低效的算法，因为它不加区分的对待同一层的叶子，带来了很多没必要的开销，因为实际上很多叶子的分裂增益较低，没必要进行搜索和分裂。<br> <img src="https://images2.imgbox.com/72/7b/Z1A5U8uk_o.png" alt="这里写图片描述"><br> Leaf-wise则是一种更为高效的策略，每次从当前所有叶子中，找到分裂增益最大的一个叶子，然后分裂，如此循环。因此同Level-wise相比，在分裂次数相同的情况下，Leaf-wise可以降低更多的误差，得到更好的精度。Leaf-wise的缺点是可能会长出比较深的决策树，产生过拟合。因此LightGBM在Leaf-wise之上增加了一个最大深度的限制，在保证高效率的同时防止过拟合。<br> <img src="https://images2.imgbox.com/e2/6c/9fiXHFNJ_o.png" alt="这里写图片描述"></p> 
<h5><a id="4_75"></a>4.直接支持类别特征</h5> 
<p>实际上大多数机器学习工具都无法直接支持类别特征，一般需要把类别特征，转化到多维的0/1特征，降低了空间和时间的效率。而类别特征的使用是在实践中很常用的。基于这个考虑，LightGBM优化了对类别特征的支持，可以直接输入类别特征，不需要额外的0/1展开。并在决策树算法上增加了类别特征的决策规则。在Expo数据集上的实验，相比0/1展开的方法，训练速度可以加速8倍，并且精度一致。据我们所知，LightGBM是第一个直接支持类别特征的GBDT工具。<br> LightGBM的单机版本还有很多其他细节上的优化，比如cache访问优化，多线程优化，稀疏特征优化等等，更多的细节可以查阅Github Wiki(<a href="https://github.com/Microsoft/LightGBM/wiki">https://github.com/Microsoft/LightGBM/wiki</a>)上的文档说明<br> <img src="https://images2.imgbox.com/43/f0/hp2fdTnT_o.jpg" alt="这里写图片描述"></p> 
<h5><a id="5_79"></a>5.直接支持高效并行</h5> 
<p>LightGBM还具有支持高效并行的优点。LightGBM原生支持并行学习，目前支持特征并行和数据并行的两种。<br> 特征并行的主要思想是在不同机器在不同的特征集合上分别寻找最优的分割点，然后在机器间同步最优的分割点。<br> 数据并行则是让不同的机器先在本地构造直方图，然后进行全局的合并，最后在合并的直方图上面寻找最优分割点。<br> LightGBM针对这两种并行方法都做了优化，在特征并行算法中，通过在本地保存全部数据避免对数据切分结果的通信；在数据并行中使用分散规约 (Reduce scatter) 把直方图合并的任务分摊到不同的机器，降低通信和计算，并利用直方图做差，进一步减少了一半的通信量。<br> 基于投票的数据并行则进一步优化数据并行中的通信代价，使通信代价变成常数级别。在数据量很大的时候，使用投票并行可以得到非常好的加速效果。更具体的内容可以看NIPS2016的文章<a href="http://download.csdn.net/download/u012513618/10103415">A Communication-Efficient Parallel Algorithm for Decision Tree</a>。</p> 
<p><img src="https://images2.imgbox.com/2c/bc/ySkjGYeZ_o.jpg" alt="这里写图片描述"></p> 
<p><img src="https://images2.imgbox.com/d1/c8/TKP1cc9q_o.jpg" alt="这里写图片描述"></p> 
<h4><a id="_LightGBM_90"></a>四. LightGBM的参数</h4> 
<p>LightGBM uses the leaf-wise tree growth algorithm, while many other popular tools use depth-wise tree growth. Compared with depth-wise growth, the leaf-wise algorithm can convenge much faster. However, the leaf-wise growth may be over-fitting if not used with the appropriate parameters.</p> 
<h5><a id="1_92"></a>1参数微调</h5> 
<p>To get good results using a leaf-wise tree, these are some important parameters:</p> 
<h6><a id="1num_leaves_94"></a>(1).num_leaves.</h6> 
<p>This is the main parameter to control the complexity of the tree model. Theoretically, we can set num_leaves = 2^(max_depth) to convert from depth-wise tree. However, this simple conversion is not good in practice. The reason is, when number of leaves are the same, the leaf-wise tree is much deeper than depth-wise tree. As a result, it may be over-fitting. Thus, when trying to tune the num_leaves, we should let it be smaller than 2^<br> (max_depth).<br> For example, when the max_depth=6 the depth-wise tree can get good accuracy, but setting num_leaves to 127 may cause over-fitting, and setting it to 70 or 80 may get better accuracy than depth-wise. Actually, the concept depth can be forgotten in leaf-wise tree, since it doesn’t have a correct mapping from leaves to depth.<br> 使用num_leaves<br> 因为LightGBM使用的是leaf-wise的算法，因此在调节树的复杂程度时，使用的是num_leaves而不是max_depth，大致换算关系：num_leaves = 2^(max_depth)</p> 
<h6><a id="2min_data_in_leaf_100"></a>(2).min_data_in_leaf</h6> 
<p>This is a very important parameter to deal with over-fitting in leaf-wise tree. Its value depends on the number of training data and num_leaves. Setting it to a large value can avoid growing too deep a tree, but may cause under-fitting. In practice, setting it to hundreds or thousands is enough for a large dataset.<br> (3).max_depth<br> You also can use max_depth to limit the tree depth explicitly.<br> (4). 对于非平衡数据集<br> 可以param[‘is_unbalance’]='true’<br> (5).Bagging参数<br> bagging_fraction+bagging_freq（必须同时设置）、feature_fraction</p> 
<h5><a id="2For_Faster_Speed_108"></a>2.For Faster Speed</h5> 
<p>Use bagging by setting bagging_fraction and bagging_freq<br> Use feature sub-sampling by setting feature_fraction<br> Use small max_bin<br> Use save_binary to speed up data loading in future learning<br> Use parallel learning, refer to Parallel Learning Guide</p> 
<h5><a id="3For_Better_Accuracy_114"></a>3.For Better Accuracy</h5> 
<p>Use large max_bin (may be slower)<br> Use small learning_rate with large num_iterations<br> Use large num_leaves (may cause over-fitting)<br> Use bigger training data<br> Try dart</p> 
<h5><a id="4Deal_with_Overfitting_120"></a>4.Deal with Over-fitting</h5> 
<p>Use small max_bin<br> Use small num_leaves<br> Use min_data_in_leaf and min_sum_hessian_in_leaf<br> Use bagging by set bagging_fraction and bagging_freq<br> Use feature sub-sampling by set feature_fraction<br> Use bigger training data<br> Try lambda_l1, lambda_l2 and min_gain_to_split for regularization<br> Try max_depth to avoid growing deep tree建模过程（python）</p> 
<p><strong>参考文献</strong><br> [1]<a href="https://github.com/Microsoft/LightGBM/blob/master/docs/Features.rst#features">https://github.com/Microsoft/LightGBM/blob/master/docs/Features.rst#features</a><br> [2]<a href="https://lightgbm.readthedocs.io/en/latest/Features.html" rel="nofollow">https://lightgbm.readthedocs.io/en/latest/Features.html</a><br> [3] <a href="http://www.sohu.com/a/123480446_133098" rel="nofollow">http://www.sohu.com/a/123480446_133098</a></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/b32015378eb21c46c454138231dc09d0/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">python2内置属性</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/0d87ed6ffaa9266624b897d51cb79ec7/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">家庭智能网关elinkc</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>