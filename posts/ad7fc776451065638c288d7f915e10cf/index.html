<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>基于frp工具实现内网穿透，跨局域网远程SSH登录 - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="基于frp工具实现内网穿透，跨局域网远程SSH登录" />
<meta property="og:description" content="文章目录 一.概述1.1 为什么要内网穿透？1.2 什么是frp？ 二.frp安装管理流程2.1 frp下载2.2 部署2.3 通过systemd系统服务管理启动程序 三.frp配置测试（通过SSH访问内网机器C）3.1 服务端配置文件frps.toml修改3.2 客户端配置文件frpc.toml修改3.3 启动 frps 和 frpc 四 .一切就绪，执行测试五 .补充：测试网络端口工具六.参考链接 一.概述 1.1 为什么要内网穿透？ 如上图，假设我们想要通过主机A访问主机C（通过SSH登录），但是主机A和主机C在不同的局域网中，绑定的都是私有ip地址，所以它们之间是无法直接进行通信的。要想使得A和C能够进行通信，就需要用到内网穿透的技术。使得局域网内的设备C能够被“穿透”到公网中，被其他设备所访问，这就要用到内网穿透技术。
内网穿透是一种网络技术，通常用于将位于局域网内部的服务、设备、或者应用程序暴露到公共网络（互联网）中，使得外部网络可以访问局域网内的资源。比如上图中，我们把公网中的服务器B作为代理桥梁沟通A和C，由于B是公网ip，因此A和C都可以主动访问到B，那么我们就可以在B和C之间建立通信信道，在A需要访问C时，将访问请求发给B，由B作为代理转发给C，这样就实现了A与C之间的通信，也就实现了C的内网穿透。
现在有多种工具可以提供内网穿透服务，如ngrok，花生壳，frp等，本文将介绍通过frp实现内网穿透，简单免费、配置方便。
1.2 什么是frp？ frp 是一款高性能的反向代理应用，专注于内网穿透。它支持多种协议，包括 TCP、UDP、HTTP、HTTPS 等，并且具备 P2P 通信功能。使用 frp，可以安全、便捷地将内网服务暴露到公网，通过拥有公网 IP 的节点进行中转。
通过在具有公网 IP 的节点上部署 frp 服务端，可以轻松地将内网服务穿透到公网，并享受以下专业特性：
多种协议支持：客户端服务端通信支持 TCP、QUIC、KCP 和 Websocket 等多种协议。TCP 连接流式复用：在单个连接上承载多个请求，减少连接建立时间，降低请求延迟。代理组间的负载均衡。端口复用：多个服务可以通过同一个服务端端口暴露。P2P 通信：流量不必经过服务器中转，充分利用带宽资源。客户端插件：提供多个原生支持的客户端插件，如静态文件查看、HTTPS/HTTP 协议转换、HTTP、SOCKS5 代理等，以便满足各种需求。服务端插件系统：高度可扩展的服务端插件系统，便于根据自身需求进行功能扩展。用户友好的 UI 页面：提供服务端和客户端的用户界面，使配置和监控变得更加方便。 代理类型： frp 支持多种代理类型，以适应不同的使用场景。以下是一些常见的代理类型：
TCP：提供纯粹的 TCP 端口映射，使服务端能够根据不同的端口将请求路由到不同的内网服务。UDP：提供纯粹的 UDP 端口映射，与 TCP 代理类似，但用于 UDP 流量。HTTP：专为 HTTP 应用设计，支持修改 Host Header 和增加鉴权等额外功能。HTTPS：类似于 HTTP 代理，但专门用于处理 HTTPS 流量。STCP：提供安全的 TCP 内网代理，要求在被访问者和访问者的机器上都部署 frpc，不需要在服务端暴露端口。SUDP：提供安全的 UDP 内网代理，与 STCP 类似，需要在被访问者和访问者的机器上都部署 frpc，不需要在服务端暴露端口。XTCP：点对点内网穿透代理，与 STCP 类似，但流量不需要经过服务器中转。TCPMUX：支持服务端 TCP 端口的多路复用，允许通过同一端口访问不同的内网服务。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/ad7fc776451065638c288d7f915e10cf/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2024-01-26T23:00:42+08:00" />
<meta property="article:modified_time" content="2024-01-26T23:00:42+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">基于frp工具实现内网穿透，跨局域网远程SSH登录</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p></p> 
<div class="toc"> 
 <h4>文章目录</h4> 
 <ul><li><a href="#_1" rel="nofollow">一.概述</a></li><li><ul><li><a href="#11__2" rel="nofollow">1.1 为什么要内网穿透？</a></li><li><a href="#12_frp_9" rel="nofollow">1.2 什么是frp？</a></li></ul> 
  </li><li><a href="#frp_35" rel="nofollow">二.frp安装管理流程</a></li><li><ul><li><a href="#21_frp_36" rel="nofollow">2.1 frp下载</a></li><li><a href="#22__44" rel="nofollow">2.2 部署</a></li><li><a href="#23_systemd_49" rel="nofollow">2.3 通过systemd系统服务管理启动程序</a></li></ul> 
  </li><li><a href="#frpSSHC_112" rel="nofollow">三.frp配置测试（通过SSH访问内网机器C）</a></li><li><ul><li><a href="#31_frpstoml_114" rel="nofollow">3.1 服务端配置文件frps.toml修改</a></li><li><a href="#32_frpctoml_122" rel="nofollow">3.2 客户端配置文件frpc.toml修改</a></li><li><a href="#33__frps__frpc_139" rel="nofollow">3.3 启动 frps 和 frpc</a></li></ul> 
  </li><li><a href="#__168" rel="nofollow">四 .一切就绪，执行测试</a></li><li><a href="#__176" rel="nofollow">五 .补充：测试网络端口工具</a></li><li><a href="#_190" rel="nofollow">六.参考链接</a></li></ul> 
</div> 
<p></p> 
<h2><a id="_1"></a>一.概述</h2> 
<h3><a id="11__2"></a>1.1 为什么要内网穿透？</h3> 
<p><img src="https://images2.imgbox.com/01/c8/GsTkRpeq_o.png" alt="在这里插入图片描述" height="250"></p> 
<p>  如上图，假设我们想要通过主机A访问主机C（通过SSH登录），但是主机A和主机C在<font color="#dd0000">不同的局域网中</font>，绑定的都是<strong>私有ip地址</strong>，所以它们之间是无法直接进行通信的。要想使得A和C能够进行通信，就需要用到内网穿透的技术。使得局域网内的设备C能够被“穿透”到公网中，被其他设备所访问，这就要用到内网穿透技术。<br>   内网穿透是一种网络技术，通常用于将位于局域网内部的服务、设备、或者应用程序暴露到公共网络（互联网）中，使得外部网络可以访问局域网内的资源。比如上图中，我们把公网中的服务器B作为<strong>代理</strong>桥梁沟通A和C，由于B是公网ip，因此<strong>A和C都可以主动访问到B</strong>，那么我们就可以在B和C之间建立通信信道，在A需要访问C时，将访问请求发给B，由B作为代理转发给C，这样就实现了A与C之间的通信，也就实现了C的内网穿透。<br>   现在有多种工具可以提供内网穿透服务，如ngrok，花生壳，frp等，本文将介绍通过<code>frp</code>实现内网穿透，简单免费、配置方便。</p> 
<h3><a id="12_frp_9"></a>1.2 什么是frp？</h3> 
<p>  frp 是一款高性能的反向代理应用，专注于内网穿透。它支持多种协议，包括 TCP、UDP、HTTP、HTTPS 等，并且具备 P2P 通信功能。使用 frp，可以安全、便捷地将内网服务暴露到公网，通过拥有公网 IP 的节点进行中转。</p> 
<p>  通过<font color="#dd0000">在具有<strong>公网 IP</strong> 的节点上部署 frp <strong>服务端</strong></font>，可以轻松地将内网服务穿透到公网，并享受以下<strong>专业特性</strong>：</p> 
<ul><li>多种协议支持：客户端服务端通信支持 TCP、QUIC、KCP 和 Websocket 等多种协议。</li><li>TCP 连接流式复用：在单个连接上承载多个请求，减少连接建立时间，降低请求延迟。</li><li>代理组间的负载均衡。</li><li>端口复用：多个服务可以通过同一个服务端端口暴露。</li><li>P2P 通信：流量不必经过服务器中转，充分利用带宽资源。</li><li>客户端插件：提供多个原生支持的客户端插件，如静态文件查看、HTTPS/HTTP 协议转换、HTTP、SOCKS5 代理等，以便满足各种需求。</li><li>服务端插件系统：高度可扩展的服务端插件系统，便于根据自身需求进行功能扩展。</li><li>用户友好的 UI 页面：提供服务端和客户端的用户界面，使配置和监控变得更加方便。</li></ul> 
<p><strong>代理类型：</strong> frp 支持多种代理类型，以适应不同的使用场景。以下是一些常见的代理类型：</p> 
<ul><li>TCP：提供纯粹的 TCP 端口映射，使服务端能够根据不同的端口将请求路由到不同的内网服务。</li><li>UDP：提供纯粹的 UDP 端口映射，与 TCP 代理类似，但用于 UDP 流量。</li><li>HTTP：专为 HTTP 应用设计，支持修改 Host Header 和增加鉴权等额外功能。</li><li>HTTPS：类似于 HTTP 代理，但专门用于处理 HTTPS 流量。</li><li>STCP：提供安全的 TCP 内网代理，要求在被访问者和访问者的机器上都部署 frpc，不需要在服务端暴露端口。</li><li>SUDP：提供安全的 UDP 内网代理，与 STCP 类似，需要在被访问者和访问者的机器上都部署 frpc，不需要在服务端暴露端口。</li><li>XTCP：点对点内网穿透代理，与 STCP 类似，但流量不需要经过服务器中转。</li><li>TCPMUX：支持服务端 TCP 端口的多路复用，允许通过同一端口访问不同的内网服务。<br> 每种代理类型适用于不同的使用情境，您可以根据需求选择合适的代理类型来配置 frp。</li></ul> 
<h2><a id="frp_35"></a>二.frp安装管理流程</h2> 
<h3><a id="21_frp_36"></a>2.1 frp下载</h3> 
<p>  frp 采用 Go 语言编写，支持跨平台，只需下载适用于您平台的二进制文件即可执行，无需额外依赖。您可以从 GitHub 的 <a href="https://github.com/fatedier/frp/releases">Release</a> 页面中下载最新版本的客户端和服务器二进制文件。所有文件都打包在一个压缩包中，还包含了一份完整的配置参数说明，我的linux系统下载的是这个版本：</p> 
<p><img src="https://images2.imgbox.com/28/59/qL1Epsxc_o.png" alt="在这里插入图片描述" height="300"><br>   下载并解压之后有如下文件几个文件，其中<code>frpc</code>和<code>frpc.toml</code>是客户端的执行程序和配置文件（仅在客户端使用），而<code>frps</code>和<code>frps.toml</code>是服务端的执行程序和配置文件（仅在服务端使用）；；<br> <img src="https://images2.imgbox.com/f1/1a/4rL2rDF6_o.png" alt="在这里插入图片描述" height="30"></p> 
<h3><a id="22__44"></a>2.2 部署</h3> 
<ol><li>解压下载的压缩包。</li><li>将<code>frpc</code>和<code>frpc.toml</code>复制到内网服务所在的机器上（客户端）。</li><li>将<code>frps</code>和<code>frps.toml</code>复制到拥有公网 IP 地址的机器上（服务端），并将它们放在任意目录。</li></ol> 
<h3><a id="23_systemd_49"></a>2.3 通过systemd系统服务管理启动程序</h3> 
<p>  在 Linux 系统下可以使用 <code>systemd</code> 来管理<code> frps</code> 服务，包括<strong>启动</strong>、<strong>停止</strong>、<strong>配置后台运行</strong>和<strong>设置开机自启动</strong>功能，非常方便。</p> 
<p><strong>1.安装 systemd</strong></p> 
<p>  如果您的 Linux 服务器上尚未安装 systemd，可以使用包管理器如 yum（适用于 CentOS/RHEL）或 apt（适用于 Debian/Ubuntu）来安装它：</p> 
<pre><code class="prism language-bash"><span class="token comment"># 使用 apt 安装 systemd（Debian/Ubuntu）</span>
<span class="token function">apt</span> <span class="token function">install</span> systemd
</code></pre> 
<p><strong>2.创建 frps.service 文件</strong></p> 
<p>  使用文本编辑器 (如 vim) 在 <code>/etc/systemd/system</code> 目录下创建一个 <code>frps.service</code> 文件(同理，客户端是<code>frpc.service</code>)，用于配置 frps 服务。</p> 
<pre><code class="prism language-bash"><span class="token function">sudo</span> <span class="token function">vim</span> /etc/systemd/system/frps.service   <span class="token comment"># 服务端</span>
或
<span class="token function">sudo</span> <span class="token function">vim</span> /etc/systemd/system/frpc.service   <span class="token comment"># 客户端</span>
</code></pre> 
<p><strong>3.写入内容（以服务端为例）</strong></p> 
<pre><code class="prism language-bash"><span class="token punctuation">[</span>Unit<span class="token punctuation">]</span>
<span class="token comment"># 服务名称，可自定义</span>
Description <span class="token operator">=</span> frp server
After <span class="token operator">=</span> network.target syslog.target
Wants <span class="token operator">=</span> network.target

<span class="token punctuation">[</span>Service<span class="token punctuation">]</span>
Type <span class="token operator">=</span> simple
<span class="token comment"># 启动frps的命令，需修改为您的frps的安装路径</span>
ExecStart <span class="token operator">=</span> /path/to/frps -c /path/to/frps.toml

<span class="token punctuation">[</span>Install<span class="token punctuation">]</span>
WantedBy <span class="token operator">=</span> multi-user.target
</code></pre> 
<p><strong>4.使用 systemd 命令管理 frps 服务（以服务端为例）</strong></p> 
<pre><code class="prism language-bash"><span class="token comment"># 启动frps</span>
<span class="token function">sudo</span> systemctl start frps
<span class="token comment"># 停止frps</span>
<span class="token function">sudo</span> systemctl stop frps
<span class="token comment"># 重启frps</span>
<span class="token function">sudo</span> systemctl restart frps
<span class="token comment"># 查看frps状态</span>
<span class="token function">sudo</span> systemctl status frps
</code></pre> 
<p><strong>5.设置 frps 开机自启动</strong></p> 
<pre><code class="prism language-bash"><span class="token function">sudo</span> systemctl <span class="token builtin class-name">enable</span> frps
</code></pre> 
<p>  命令执行结果如下，可以看出设置开机启动实际就是在<code>/etc/systemd/system/multi-user.target.wants/</code>目录下面创建一个符号链接，即可实现开机自启动，不难分析出开机时系统加载会扫描改目录下的服务配置，从而实现开机自启动，实现原理简单，举一反三，对于自己的服务程序也可以封装成systemd管理方式，这样维护起来更加方便高效。</p> 
<p><img src="https://images2.imgbox.com/32/b6/SWCCQSYJ_o.png" alt="
"></p> 
<p>通过遵循上述步骤，您可以轻松地使用 systemd 来管理 frps 服务，实现启动、停止、自动运行和开机自启动。确保替换路径和配置文件名称以匹配您的实际安装。</p> 
<h2><a id="frpSSHC_112"></a>三.frp配置测试（通过SSH访问内网机器C）</h2> 
<p>  在客户端和服务器分别部署好frp程序之后，下一步需要<font color="#dd0000">修改配置文件</font>，即在服务端修改<code>frps.toml</code>，客户端修改<code>frpc.toml</code>。</p> 
<h3><a id="31_frpstoml_114"></a>3.1 服务端配置文件frps.toml修改</h3> 
<p>  在公网服务器上部署 <code>frps</code> 并编辑 <code>frps.toml </code>文件。以下是简化的配置，其中设置了 frp 服务器用于<strong>接收客户端连接</strong>的端口：</p> 
<pre><code class="prism language-bash">bindPort <span class="token operator">=</span> <span class="token number">7000</span>      <span class="token comment"># 用来接收客户端（被代理机器C）连接的端口</span>
</code></pre> 
<p>  默认配置就是7000，不用改动。</p> 
<h3><a id="32_frpctoml_122"></a>3.2 客户端配置文件frpc.toml修改</h3> 
<p>  在需要被访问的内网机器（客户端C）上部署 <code>frpc</code>，并编辑 <code>frpc.toml</code> 文件，假设 frps 所在服务器的公网 IP 地址为<code>124.156.15.247</code>，以下是示例配置：</p> 
<pre><code class="prism language-bash">serverAddr <span class="token operator">=</span> <span class="token string">"124.156.15.247"</span>      <span class="token comment"># 公网服务器（服务端B）ip</span>
serverPort <span class="token operator">=</span> <span class="token number">7000</span>                  <span class="token comment"># 公网服务器（服务端B）端口，上面设置的</span>

<span class="token punctuation">[</span><span class="token punctuation">[</span>proxies<span class="token punctuation">]</span><span class="token punctuation">]</span>
name <span class="token operator">=</span> <span class="token string">"ssh"</span>
<span class="token builtin class-name">type</span> <span class="token operator">=</span> <span class="token string">"tcp-test"</span>
localIP <span class="token operator">=</span> <span class="token string">"127.0.0.1"</span>              <span class="token comment"># 客户端C本地ip，不用改，就是localhost地址</span>
localPort <span class="token operator">=</span> <span class="token number">22</span>                     <span class="token comment"># 客户端C SSH监听端口，默认是22，通常都不用改</span>
remotePort <span class="token operator">=</span> <span class="token number">6000</span>                  <span class="token comment"># 需要在服务端B上请求开通的监听端口，很关键，这个端口是给登录方A用的</span>
</code></pre> 
<ul><li><code> localIP</code> 和<code>localPort</code>配置为需要从公网访问的内网服务C的地址和端口。</li><li><code>remotePort</code> 表示在 <code>frp</code> 服务端B监听的端口，访问此端口的流量将被转发到本地服务的相应端口，一定要注意公网服务端B的端口防火墙是否开启！！！。</li></ul> 
<h3><a id="33__frps__frpc_139"></a>3.3 启动 frps 和 frpc</h3> 
<p>  一定要先启动公网服务端B，在启动客户端C，不然C的启动会失败（因为连不上B）。<br> 1.通过命令启动服务端B<code>frps</code>服务程序：</p> 
<pre><code class="prism language-bash"><span class="token comment"># 启动frps</span>
<span class="token function">sudo</span> systemctl start frps
</code></pre> 
<p>2.通过命令查看服务端<code>frps</code>运行状态：</p> 
<pre><code class="prism language-bash"><span class="token comment"># 查看frps状态</span>
<span class="token function">sudo</span> systemctl status frps
</code></pre> 
<p>结果如下则表示frps启动成功。<br> <img src="https://images2.imgbox.com/a1/dd/IthKF2F2_o.png" alt="在这里插入图片描述"><br> 3.通过命令启动客户端C<code>frpc</code>服务程序：</p> 
<pre><code class="prism language-bash"><span class="token comment"># 启动frpc</span>
<span class="token function">sudo</span> systemctl start frpc
</code></pre> 
<p>4.通过命令查看客户端C<code>frpc</code>运行状态：</p> 
<pre><code class="prism language-bash"><span class="token comment"># 查看frpc状态</span>
<span class="token function">sudo</span> systemctl status frpc
</code></pre> 
<p>结果如下则表示frpc启动成功。<br> <img src="https://images2.imgbox.com/de/85/2gXnkwsN_o.png" alt="在这里插入图片描述"><br> 备注：只要客户端能启动成功，就说明连上了服务端B，就说明B和C之间的通信信道是打通的！！！</p> 
<h2><a id="__168"></a>四 .一切就绪，执行测试</h2> 
<p>  在客户端和服务端程序都按照上述步骤启动成功后，就说明客户端C借助服务端B完成了内网穿透功能，接下来就可以在需要访问的机器A上进行远程SSH登录，访问局域网主机C，在A上执行以下程序：</p> 
<pre><code class="prism language-bash"><span class="token function">ssh</span> -p <span class="token number">6000</span> username@124.156.15.247    
</code></pre> 
<p>注意，这里的<code>6000</code>是在<code>frpc.toml</code>中设置的服务端B监听端口，<code>username</code>是C的用户名，而不是B的，IP填的是B的公网IP（124.156.15.247）。由此完成B将端口6000的请求转发给C，完成内网穿透下的SSH登录！！！</p> 
<h2><a id="__176"></a>五 .补充：测试网络端口工具</h2> 
<p>  可以通过一些端口或者网络命令来测试刚刚设置的一些网络端口是否能正常工作（6000，7000）,包括：</p> 
<pre><code class="prism language-bash"><span class="token function">sudo</span> <span class="token function">lsof</span> -i:端口号   <span class="token comment"># 测试端口是否处在监听状态</span>
<span class="token function">netstat</span> -tunlp <span class="token operator">|</span><span class="token function">grep</span> 端口号 <span class="token comment"># 用于查看指定的端口号的进程情况</span>
telnet <span class="token function">ip</span> 端口号 <span class="token comment"># 用于测试网络端口是否可达</span>
</code></pre> 
<p>一些测试实例如下：<br> <img src="https://images2.imgbox.com/5a/87/teKpSRG5_o.png" alt="在这里插入图片描述"><br> <img src="https://images2.imgbox.com/f4/b0/sw7hI6qa_o.png" alt="在这里插入图片描述"><br> 通过网络端口测试，可以辅助我们查找哪些端口没打开，方便我们查找问题，一定得学会用哦。</p> 
<h2><a id="_190"></a>六.参考链接</h2> 
<ul><li><a href="https://gofrp.org/zh-cn/docs/overview/" rel="nofollow">https://gofrp.org/zh-cn/docs/overview/</a></li><li><a href="https://blog.csdn.net/jiuweideqixu/article/details/120167410">https://blog.csdn.net/jiuweideqixu/article/details/120167410</a></li></ul>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/786b4acde09b1751cc2b61c1e2e00cad/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">UBUNTU中NGINX的负载均衡和环境搭建</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/beb3df2723a62c8735098616d81bb41d/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">【c&#43;&#43;学习】数据结构中的栈</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>