<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>数据结构(1)--线性表顺序表的主要操作的实现 - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="数据结构(1)--线性表顺序表的主要操作的实现" />
<meta property="og:description" content="参考书籍：数据结构（C语言版） 严蔚敏 吴伟民编著 清华大学出版社
本文中的代码可从这里下载：https://github.com/qingyujean/data-structure
1.基本定义 #include&lt;stdio.h&gt; //顺序表：1.使用动态分配的一维数组 // 2.使用静态分配的一维数组 //本实例使用静态分配 #define LIST_INIT_SIZE 100 typedef int ElemType; typedef struct SqList{ ElemType data[LIST_INIT_SIZE]; int len; }SqList; 2.创建线性表和打印输出线性表 //创建一个长度为n的顺序线性表 void createSqList(SqList &amp;L, int n){ printf(&#34;请输入%d个数:\n&#34;, n); for(int i = 0; i &lt; n; i&#43;&#43;){ scanf(&#34;%d&#34;,&amp;L.data[i]); } L.len = n; //printSqList(L); } //打印输出顺序线性表 void printSqList(SqList L){ printf(&#34;打印线性表:&#34;); for(int i = 0; i &lt; L.len; i&#43;&#43;){ printf(&#34;%d &#34;,L.data[i]); } printf(&#34;\n&#34;); } 演示：
int main(){ //初始化一个空的线性表 SqList L; L." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/f40f855e63cf2f1f9669e480b6c99b59/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2016-02-04T03:13:47+08:00" />
<meta property="article:modified_time" content="2016-02-04T03:13:47+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">数据结构(1)--线性表顺序表的主要操作的实现</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p>参考书籍：数据结构（C语言版） 严蔚敏 吴伟民编著 清华大学出版社</p> 
<p><span style="color:#f33b45;">本文中的代码可从这里下载：</span><a href="https://github.com/qingyujean/data-structure">https://github.com/qingyujean/data-structure</a></p> 
<h2>1.基本定义</h2> 
<pre class="has"><code class="language-cpp">#include&lt;stdio.h&gt;
//顺序表：1.使用动态分配的一维数组
//        2.使用静态分配的一维数组
//本实例使用静态分配
#define LIST_INIT_SIZE 100
typedef int ElemType;

typedef struct SqList{
	ElemType data[LIST_INIT_SIZE];
	int len;
}SqList;
</code></pre> 
<h2> </h2> 
<h2>2.创建线性表和打印输出线性表</h2> 
<pre class="has"><code class="language-cpp">//创建一个长度为n的顺序线性表
void createSqList(SqList &amp;L, int n){
	printf("请输入%d个数:\n", n);
	for(int i = 0; i &lt; n; i++){
		scanf("%d",&amp;L.data[i]);
	}
	L.len = n;
	//printSqList(L);
}</code></pre> 
<p> </p> 
<pre class="has"><code class="language-cpp">//打印输出顺序线性表
void printSqList(SqList L){
	printf("打印线性表:");
	for(int i = 0; i &lt; L.len; i++){
		printf("%d ",L.data[i]);
	}
	printf("\n");
}</code></pre> 
<p>演示：</p> 
<pre class="has"><code class="language-cpp">int main(){
	
	//初始化一个空的线性表
	SqList L;
	L.len=0;
	
	createSqList(L, 5);//创建一个线性表
	printSqList(L);

    return 0;
}</code></pre> 
<p> </p> 
<p><img alt="" class="has" src="https://images2.imgbox.com/f7/a0/tdMFzfe7_o.png"></p> 
<h2> </h2> 
<h2>3.插入操作</h2> 
<pre class="has"><code class="language-cpp">//在第i（1&lt;=i&lt;=n）个元素之前插入一个元素，需要向后移动n-i+1个元素，
//在最后插入则不需要移动任何元素，可供插入的位置有n+1个，
//从后往前找插入的位置，其中i表示位序,第i个元素的下标i-1,i的范围是1~n+1
//时间复杂度：O(n)
void insertSqList(SqList &amp;L,int i, ElemType e){
	if(i&gt;L.len+1||i&lt;1){
		printf("插入位置参数不合法");
	}else if(L.len &gt;= LIST_INIT_SIZE){
		printf("表已满，无法差插入");
	}else{
		int j = L.len-1;
		for(j;j&gt;=i-1;j--){
			L.data[j+1] = L.data[j];//从后往前移动元素
		}
		L.data[i-1] = e;
		L.len++;
	}
}</code></pre> 
<p>演示：</p> 
<pre class="has"><code class="language-cpp">int main(){
	
	//初始化一个空的线性表
	SqList L;
	L.len=0;
	
	createSqList(L, 5);//创建一个线性表
	printSqList(L);
	
	//完成插入功能
	printf("您要插入的数据和位置(1~%d)(如：在第2个位置插入10则输入：10，2)：",L.len);
	int elem, pos;
	scanf("%d,%d",&amp;elem,&amp;pos);
	insertSqList(L,pos,elem);
	printSqList(L);

    return 0;
}</code></pre> 
<p><img alt="" class="has" src="https://images2.imgbox.com/36/03/xP091QPu_o.png"></p> 
<p> </p> 
<pre class="has"><code class="language-cpp">//创建一个线性表实际上也是不断往一个空表里插入元素的过程
//所以可利用插入算法实现线性表的创建
void createUseInsertSqList(SqList &amp;L, int n){
	printf("请输入%d个数:\n", n);
	int x;
	for(int i = 0; i &lt; n; i++){
		scanf("%d", &amp;x);
		insertSqList(L,i+1,x);
	}
	L.len = n;
}</code></pre> 
<p>演示：</p> 
<pre class="has"><code class="language-cpp">int main(){
	
	//初始化一个空的线性表
	SqList L;
	L.len=0;
	/*
	createSqList(L, 5);//创建一个线性表
	printSqList(L);
	*/
	
	createUseInsertSqList(L, 5);
	printSqList(L);

    return 0;
}</code></pre> 
<p> </p> 
<p><img alt="" class="has" src="https://images2.imgbox.com/4b/e2/yLaO0THS_o.png"></p> 
<p> </p> 
<h2>4.删除操作</h2> 
<pre class="has"><code class="language-cpp">//删除第i(1&lt;=i&lt;=L.len)个元素,并用e返回其值
//时间复杂度：O(n)
void delSqList(SqList &amp;L, int i, ElemType &amp;e){
	if(i&gt;L.len||i&lt;1){
		printf("删除位置参数不合法");
	}
	int j = i-1;//j是要被删除元素的下标
	e = L.data[j];</code></pre> 
<pre class="has"><code class="language-cpp">	printf("删除的第%d位置的数据是%d\n",i,e);
	for(j;j&lt;L.len-1;j++){
		L.data[j] = L.data[j+1];
	}
	L.len--;
}</code></pre> 
<p>演示：</p> 
<pre class="has"><code class="language-cpp">int main(){
	
	//初始化一个空的线性表
	SqList L;
	L.len=0;
	
	createSqList(L, 5);//创建一个线性表
	printSqList(L);
	
	//完成删除功能
	printf("您要删除的数据的位置(如：要删除第2个位置的数据则输入(1~%d)：2)：",L.len);
	int pos;
	ElemType elem;
	scanf("%d",&amp;pos);
	delSqList(L,pos,elem);
	printSqList(L);

    return 0;
}</code></pre> 
<p><br><img alt="" class="has" src="https://images2.imgbox.com/f4/6b/8F3WScfn_o.png"></p> 
<p> </p> 
<h2>5.两个线性表的merge操作</h2> 
<pre class="has"><code class="language-cpp">//已知线性表La和Lb中的数据元素按值非递减排列，现要求将La和Lb归并为一个新的线性表Lc，且Lc中的数据元素仍然按值非递减有序排列
//实现：为保持Lc的非递减有序，则当a&lt;=b时，c=a;当a&gt;b时，c=b
//时间复杂度：O(La.len+Lb.len)
//实例：La=(3,5,8,11),Lb=(2,6,8,9,11,15,20),Lc=(2,3,5,6,8,8,9,11,11,15,20),注意并没有去重，只是做了合并
void mergeSqList(SqList La, SqList Lb, SqList &amp;Lc){
	int i=0, j=0;
	Lc.len=La.len+Lb.len;//初始化Lc
	int k =0;
	while(i&lt;La.len&amp;&amp;j&lt;Lb.len){
		if(La.data[i]&lt;=Lb.data[j]){
			Lc.data[k]=La.data[i];
			i++;
			k++;
		}else{
			Lc.data[k]=Lb.data[j];
			j++;
			k++;
		}
	}
	while(i&lt;La.len){
		Lc.data[k]=La.data[i];
		i++;
		k++;
	}
	while(j&lt;Lb.len){
		Lc.data[k]=Lb.data[j];
		j++;
		k++;	
	}
}</code></pre> 
<p>演示：</p> 
<pre class="has"><code class="language-cpp">int main(){
	//完成merge操作
	SqList La, Lb, Lc;
	//初始化线性表
	La.len = Lb.len =Lc.len = 0;
	printf("创建线性表La:\n");
	createSqList(La, 4);//创建线性表La
	printSqList(La);
	printf("创建线性表Lb:\n");
	createSqList(Lb, 7);//创建线性表Lc
	printSqList(Lb);
	mergeSqList(La, Lb, Lc);
	printf("merge以后得到的Lc:");
	printSqList(Lc);

    return 0;
}</code></pre> 
<p><br><img alt="" class="has" src="https://images2.imgbox.com/70/9d/GHoYESnw_o.png"></p> 
<p> </p> 
<h2>6.两个线性表的union操作</h2> 
<p>利用两个线性表La,Lb分别表示两个集合A和B(线性表中的数据元素即为集合元素)，现要求一个新的集合A=AUB<br> 实现：扩展线性表La,即从Lb中依次取得每个数据元素，并依值在La中进行查访，若在La中不存在则插入之。</p> 
<pre class="has"><code class="language-cpp">//实例：La=(3,5,8,11),Lb=(2,6,8,9,11,15,20),union以后的La=(3,5,8,11,2,6,9,15,20),La.len=9,注意有去重，但不care求并集以后的顺序
//时间复杂度：O(La.len * Lb.len)
int locateElem(SqList L, ElemType e){//查找线性表L中第一个与数据元素e相等(也可以是其他比较方法)的元素的位置(1~L.len)，
//若没找到则返回0，找到则返回位序,时间复杂度：O(L.len)
	int i = 1;//i表示位序
	while(i&lt;=L.len&amp;&amp;L.data[i-1]!=e){
		i++;
	}
	if(i&lt;=L.len)
		return i;
	else
		return 0;
}
void unionSqList(SqList &amp;La, SqList Lb){
	for(int i = 0; i &lt; Lb.len; i++){
		ElemType e = Lb.data[i];
		if(!locateElem(La, e)){//e在La中不存在//O(La.len)
			insertSqList(La,La.len+1, e);//由于总在表尾插入，所以插入操作的时间复杂度与表长无关
		}
	}
}</code></pre> 
<p>演示：</p> 
<pre class="has"><code class="language-cpp">int main(){
	//完成union操作
	SqList La, Lb;
	//初始化线性表
	La.len = Lb.len = 0;
	printf("创建线性表La:\n");
	createSqList(La, 4);//创建线性表La
	printSqList(La);
	printf("创建线性表Lb:\n");
	createSqList(Lb, 7);//创建线性表Lc
	printSqList(Lb);
	unionSqList(La, Lb);
	printSqList(La);
    printf("La的长度为%d\n",La.len);
	
	return 0;
}</code></pre> 
<p> </p> 
<p><img alt="" height="365" src="https://images2.imgbox.com/62/1e/iGajJPMw_o.png" width="579"></p> 
<p>注意：将merge第一个循环体中以switch语句代替if语句，即分出3种情况，当a=b时，只将两者之一插入到Lc中，则此时算法完成的操作和union完全相同，而时间复杂度却不同，其原因有二：</p> 
<p>    1.La,Lb中的元素都是依值递增（同一集合中元素不等），则对Lb中每个元素，不需要再La中从表头至表尾进行全程搜索</p> 
<p>    2.由于用新表Lc表示“并集”，则插入操作实际上借助“复制”完成，而无须因插入导致移动一系列元素<br> 由此可见，若以线性表表示集合并进行集合的各种运算，应先对表中的元素进行排序，则可降低集合运算的时间复杂度<br>  </p> 
<p><span style="color:#f33b45;">本文中的代码可从这里下载：</span><a href="https://github.com/qingyujean/data-structure">https://github.com/qingyujean/data-structure</a></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/027774f9db31afa136c3b32a55b5062e/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">纯干货：Linux抓包命令集锦</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/48af20242865a9b05f5a73ecf52e66f3/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">linux命令学习之(ifconfig)</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>