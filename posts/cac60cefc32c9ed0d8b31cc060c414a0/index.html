<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>LeetCode链表刷题 - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="LeetCode链表刷题" />
<meta property="og:description" content="一、判断是否为环形链表 LeetCode141题：环形链表 解题思路 ：快慢指针 设置两个指针，一个每次走一步称为慢指针，另一个每次走两步称为快指针。
当链表无环的时候，快指针会先到达链表末尾。 当链表有环的时候，两个指针走着都会在环里循环的走，终会相遇于某个节点。
代码实现 /** * Definition for singly-linked list. * function ListNode(val) { * this.val = val; * this.next = null; * } */ /** * @param {ListNode} head * @return {boolean} */ var hasCycle = function(head) { if(head == null) { return false; } let fast =head, slow = head; while(fast &amp;&amp; fast.next) { slow = slow.next; fast = fast.next.next; if(slow === fast) { return true; } } return false; }; 二、判断是否为环形链表并确定环的起点 LeetCode142题：环形链表II 解题思路：快慢指针 当有环时，" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/cac60cefc32c9ed0d8b31cc060c414a0/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2021-09-25T15:51:01+08:00" />
<meta property="article:modified_time" content="2021-09-25T15:51:01+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">LeetCode链表刷题</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <h3>一、判断是否为环形链表</h3> 
<h4>LeetCode141题：环形链表</h4> 
<p style="text-align:center;"><img alt="" height="516" src="https://images2.imgbox.com/ef/d7/kG8H76sE_o.png" width="596"></p> 
<p></p> 
<h4>解题思路 ：快慢指针</h4> 
<p>设置两个指针，一个每次走一步称为<strong>慢指针</strong>，另一个每次走两步称为<strong>快指针。</strong></p> 
<p>当链表无环的时候，快指针会先到达链表末尾。 </p> 
<p>当链表有环的时候，两个指针走着都会在环里循环的走，终会相遇于某个节点。</p> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/35/38/E8c48FII_o.gif"></p> 
<h4>代码实现</h4> 
<pre><code class="language-javascript">/**
 * Definition for singly-linked list.
 * function ListNode(val) {
 *     this.val = val;
 *     this.next = null;
 * }
 */

/**
 * @param {ListNode} head
 * @return {boolean}
 */
var hasCycle = function(head) {
    if(head == null) {
        return false;
    }
    let fast =head, slow = head;
    while(fast &amp;&amp; fast.next) {
        slow = slow.next;
        fast = fast.next.next;
        if(slow === fast) {
            return true;
        }
    }
    return false;
};</code></pre> 
<p></p> 
<h4>二、判断是否为环形链表并确定环的起点</h4> 
<h4>LeetCode142题：环形链表II</h4> 
<p><img alt="" height="472" src="https://images2.imgbox.com/68/a6/6h5ni4qZ_o.png" width="579"></p> 
<h4> 解题思路：快慢指针</h4> 
<p><img alt="" height="472" src="https://images2.imgbox.com/e1/54/v6fyvCy2_o.png" width="748"></p> 
<p>当有环时，</p> 
<p>假设当慢指针走到环的起点距离为a，则快指针走了2a距离；</p> 
<p>假设此时快指针距离环的起点为x，则当快指针再走2x的时候，慢指针走了x，此时快慢指针正好相遇。</p> 
<p>由于x+a为一个环的长度，所以慢指针继续走a步就会到达环的起点；</p> 
<p>将慢指针从头开始走，当指针走a步也会到达环的起点，所以这个指针跟慢指针同时走到相遇于环的起点时就能看出a的长度。</p> 
<h4>代码实现</h4> 
<pre><code class="language-javascript">/**
 * Definition for singly-linked list.
 * function ListNode(val) {
 *     this.val = val;
 *     this.next = null;
 * }
 */

/**
 * @param {ListNode} head
 * @return {ListNode}
 */
var detectCycle = function(head) {
    // 创建快慢指针
    let fast = head, slow = head;
    // 当快指针不为空的时候，快慢指针一直往后走
    while(fast &amp;&amp; fast.next) {
        slow = slow.next;
        fast = fast.next.next;
        // 当快慢指针相遇时证明有环
        if(fast === slow) {
            // 将快指针从头开始走，与慢指针同时走，每次走一步，当相遇时证明在环的起点
            fast = head;
            while(slow !== fast) {
                slow = slow.next;
                fast = fast.next;
            }
            return fast;
        }
    }
    // 当快指针为空时证明走到链表尾了，链表无环
    return null;
};</code></pre> 
<p></p> 
<h3>三、快乐数</h3> 
<h4>LeetCode202题：快乐数</h4> 
<p><img alt="" height="512" src="https://images2.imgbox.com/8f/ad/rZzf4vRH_o.png" width="592"></p> 
<h4>解题思路</h4> 
<p>当计算得的值无限循环时，始终变不到1的，只有不循环才可能得到1。</p> 
<p>所以将计算的值看做链表节点，有重复值时相当于链表有环，可使用快慢指针进行判断。</p> 
<p>快慢指针一直往后走，当快指针为1时，返回true。当链表有环时始终到不了1，要返回false。</p> 
<h4>代码实现 </h4> 
<pre><code class="language-javascript">/**
 * @param {number} n
 * @return {boolean}
 */
// 获取每个位置上的数字的平方和
var getSum = function(n) {
    let sum = 0;
    while(n) {
        sum += (n % 10) * (n % 10);
        n = Math.floor(n / 10);
    }
    return sum;
}
var isHappy = function(n) {
    let slow = n;
    let fast = getSum(n);
    while(fast != 1 &amp;&amp; slow != fast) {
        slow = getSum(slow);
        fast = getSum(getSum(fast));
    }
    return fast == 1;
};</code></pre> 
<p></p> 
<h3>四、反转链表</h3> 
<h4>LeetCode206题：反转链表</h4> 
<p><img alt="" height="715" src="https://images2.imgbox.com/00/e8/3NBjEDBh_o.png" width="642"></p> 
<p></p> 
<h4>解题思路</h4> 
<p>当计算得的值无限循环时，始终变不到1的，只有不循环才可能得到1。</p> 
<p>所以将计算的值看做链表节点，有重复值时相当于链表有环，可使用快慢指针进行判断。</p> 
<p>快慢指针一直往后走，当快指针为1时，返回true。当链表有环时始终到不了1，要返回false。</p> 
<h4>代码实现 </h4> 
<pre><code class="language-javascript">/**
 * Definition for singly-linked list.
 * function ListNode(val, next) {
 *     this.val = (val===undefined ? 0 : val)
 *     this.next = (next===undefined ? null : next)
 * }
 */
/**
 * @param {ListNode} head
 * @return {ListNode}
 */
var reverseList = function(head) {
    let pre = null;
    let cur = head;
    while(cur) {
        let next = cur.next;
        cur.next = pre;
        pre = cur;
        cur = next;
    }
    return pre;
};</code></pre> 
<p></p> 
<h3>五、反转链表II（指定位置反转）</h3> 
<h4>LeetCode92题：反转链表II</h4> 
<p><img alt="" height="686" src="https://images2.imgbox.com/66/81/JvauFzOP_o.png" width="652"></p> 
<h4>解题思路</h4> 
<p>将部分链表进行反转，反转后再将头和尾与原来断开的节点连起来。</p> 
<h4>代码实现 </h4> 
<pre><code class="language-javascript">/**
 * Definition for singly-linked list.
 * function ListNode(val, next) {
 *     this.val = (val===undefined ? 0 : val)
 *     this.next = (next===undefined ? null : next)
 * }
 */
/**
 * @param {ListNode} head
 * @param {number} left
 * @param {number} right
 * @return {ListNode}
 */
// 翻转链表
var reverse = function(head, length) {
    let pre = null;
    let cur = head;
    while(length -- ) {
        let next = cur.next;
        cur.next = pre;
        pre = cur;
        cur = next;
    }
    head.next = cur;
    return pre;
}
var reverseBetween = function(head, left, right) {
    // 需要翻转的链表长度
    let length = right - left + 1;
    // 设置一个空的子结点（当后面要用到.next时，这里就要new ListNode,否则可用null）,放在链表前面，
    // 当翻转链表的left为1时，用pre.next接受翻转后的链表才不会报错
    let ret = new ListNode(-1, head)
    let pre = ret;
    let cur = head;
    // 找到翻转前的节点
    while(-- left) {
        pre = cur;
        cur = cur.next;
    }
    // 翻转链表后将pre.next指向翻转后的链表头
    pre.next = reverse(cur, length);
    return ret.next;
};</code></pre> 
<p></p> 
<h3>六、K个一组反转链表</h3> 
<h4>LeetCode25题：K个一组反转链表</h4> 
<p><img alt="" height="557" src="https://images2.imgbox.com/ca/7b/8pVdqJ2C_o.png" width="771"></p> 
<p></p> 
<h4>解题思路</h4> 
<p>判断有没有K个节点组成一组，如果有，则对K个节点进行反转，将指针移动到最后一个节点，再进行递归判断；若没有，则返回整个链表。</p> 
<h4>代码实现 </h4> 
<pre><code class="language-javascript">/**
 * Definition for singly-linked list.
 * function ListNode(val, next) {
 *     this.val = (val===undefined ? 0 : val)
 *     this.next = (next===undefined ? null : next)
 * }
 */
/**
 * @param {ListNode} head
 * @param {number} k
 * @return {ListNode}
 */
var reverseKGroup = function(head, k) {
    if(head == null) return null;
    // 创建虚拟哨兵节点房在第一个节点前面
    let ret = new ListNode(-1, head);
    let pre = ret;
    return reverseRecursion(ret, pre, k)
};

var reverseRecursion= function(ret, pre, k) {
    let tail = pre;
    // 判断是否有K个节点能组成一组
    for(var i = 0; i &lt; k; i++) {
        if(tail &amp;&amp; tail.next != null) {
            tail = tail.next;
        } else {
            tail = null;
            return  ret.next;
        }
    }
    // 如果有K个节点，则反转这K个节点，并将指针移到最后一个节点，当做下个k组的前一个节点，递归操作直到剩余的节点不能组成一组
    if(tail != null) {
        pre &amp;&amp; (pre.next = reverse(pre.next, k));
        for(var i = 0; i &lt; k; i++) {
            pre &amp;&amp; (pre = pre.next);
        }
        return reverseRecursion(ret, pre, k)
    }
}
// k个节点进行反转
var reverse = function(reverseHead, length) {
    let pre = new ListNode(-1, reverseHead);
    let cur = reverseHead;
    while(cur &amp;&amp; length--) {
        let next = cur.next;
        cur.next = pre;
        pre = cur;
        cur = next;
    }
    reverseHead &amp;&amp; (reverseHead.next = cur);
    return pre;
}

</code></pre> 
<p></p> 
<h3>七、旋转链表</h3> 
<h4>LeetCode61题：旋转链表</h4> 
<p><img alt="" height="437" src="https://images2.imgbox.com/49/d3/FUs7aIDz_o.png" width="761"></p> 
<h4>解题思路</h4> 
<p>将链表尾部与头部连起来形成环，再找到对应的移动后的位置断开链表，返回新链表。</p> 
<p>移动后的位置为 size - k % size</p> 
<h4>代码实现 </h4> 
<pre><code class="language-javascript">/**
 * Definition for singly-linked list.
 * function ListNode(val, next) {
 *     this.val = (val===undefined ? 0 : val)
 *     this.next = (next===undefined ? null : next)
 * }
 */
/**
 * @param {ListNode} head
 * @param {number} k
 * @return {ListNode}
 */

var rotateRight = function(head, k) {
    if(!head) return null;
    // 获取链表的长度，并将尾部与头部连起来形成环
    let size = 1, cur = head;
    while(cur.next) {
        cur = cur.next;
        size ++;
    } 
    cur.next = head;

    // 将对应的位置断开,返回新链表
    for(let i = 1; i &lt; size-k%size; i ++) {
        head = head.next;
    }
    let newHead = head.next;
    head.next = null;
    return newHead;
};</code></pre> 
<p></p> 
<h3>九、删除链表的倒数第 N 个结点</h3> 
<h4>LeetCode19题：删除链表的倒数第 N 个结点</h4> 
<p><img alt="" height="666" src="https://images2.imgbox.com/16/96/zgxiAKO5_o.png" width="663"></p> 
<p> <img alt="" height="155" src="https://images2.imgbox.com/31/b0/4uli7ZH0_o.png" width="648"></p> 
<h4>解题思路</h4> 
<p>设置两个指针pre、cur，cur指针先往前走n个节点，然后两个指针同时走，当cur走到链表尾时，pre指针刚好指向要删除的节点的前一个节点，然后将pre.next指向pre.next.next便删除了第n个节点。</p> 
<h4>代码实现 </h4> 
<pre><code class="language-javascript">/**
 * Definition for singly-linked list.
 * function ListNode(val, next) {
 *     this.val = (val===undefined ? 0 : val)
 *     this.next = (next===undefined ? null : next)
 * }
 */
/**
 * @param {ListNode} head
 * @param {number} n
 * @return {ListNode}
 */
var removeNthFromEnd = function(head, n) {
    if(!head) return null;
    let ret = new ListNode(-1, head);
    let pre = ret;
    let cur = head;
    // cur比pre先走n个指针，当cur走到链表尾时，pre刚好指向倒数第n个节点的前一个
    //（题目中1 &lt;= n &lt;= size,所以不用考虑n &gt; size的情况）
    while(n --) {
        cur = cur.next;
    }
    while(cur) {
        pre = pre.next;
        cur = cur.next;
    }
    pre.next = pre.next.next;
    return ret.next;
};</code></pre> 
<h3>十、删除排序链表中的重复元素</h3> 
<h4>LeetCode83题：删除排序链表中的重复元素</h4> 
<p><img alt="" height="462" src="https://images2.imgbox.com/a6/ce/WlwQDVWq_o.png" width="722"></p> 
<p></p> 
<h4>解题思路</h4> 
<p>设置一个指针，一直向后走，如果当前节点是否等于后一个节点，则删除后一个节点，直到走到链表尾为止。</p> 
<h4>代码实现</h4> 
<pre><code class="language-javascript">/**
 * Definition for singly-linked list.
 * function ListNode(val, next) {
 *     this.val = (val===undefined ? 0 : val)
 *     this.next = (next===undefined ? null : next)
 * }
 */
/**
 * @param {ListNode} head
 * @return {ListNode}
 */
var deleteDuplicates = function(head) {
    let cur = head;
    while(cur != null &amp;&amp; cur.next != null) {
        if(cur.val == cur.next.val) {
             cur.next = cur.next.next;
        } else {
            cur = cur.next;
        }
    }
    return head;
};</code></pre> 
<p></p> 
<p></p> 
<h3>十、分隔链表</h3> 
<h4>LeetCode86题：分隔链表</h4> 
<p><img alt="" height="515" src="https://images2.imgbox.com/81/11/bVLQlcUO_o.png" width="585"></p> 
<h4>解题思路</h4> 
<p><img alt="" height="321" src="https://images2.imgbox.com/84/bd/dWL82Tpk_o.png" width="764"></p> 
<p> 设置两个链表small和big,将原链表中的节点一个一个单独取出后，判断其大小，放入到对应的链表中。</p> 
<p>当所有节点都放置完成后，将small链表的尾部链接big链表的头部，这样就形成了所求的链表。</p> 
<h4>代码实现</h4> 
<pre><code class="language-javascript">/**
 * Definition for singly-linked list.
 * function ListNode(val, next) {
 *     this.val = (val===undefined ? 0 : val)
 *     this.next = (next===undefined ? null : next)
 * }
 */
/**
 * @param {ListNode} head
 * @param {number} x
 * @return {ListNode}
 */
var partition = function(head, x) {
    // 设置两个链表
    let small = new ListNode();
    let big = new ListNode();
    // 两个链表的操作指针
    let bigNode= big;
    let smallNode = small;
    // 设置p指向当前操作的节点
    // 设置q指向p的下个节点，并将p.next设置为null使之成为单独的节点
    // 判断p的大小，将p放置到对应的链表中
    for(let p = head; p != null; p = q) {
            q = p.next;
            p.next = null;
        if(p.val &gt;= x) {
            bigNode.next = p;
            bigNode = bigNode.next;
        } else {
            smallNode.next = p;
            smallNode = smallNode.next;
        }
    }
    smallNode.next = big.next;
    return small.next;
};</code></pre> 
<p></p> 
<h3>十、复制带随机指针的链表</h3> 
<h4>LeetCode138题：复制带随机指针的链表</h4> 
<p><img alt="" height="398" src="https://images2.imgbox.com/53/c7/jd0NXxAR_o.png" width="584"></p> 
<p><img alt="" height="448" src="https://images2.imgbox.com/70/a8/NzM5CLVp_o.png" width="586"></p> 
<h4> 解题思路</h4> 
<p>将所有节点一个一个复制后插入到原节点后面，此时新节点的random指向与原节点的random指向相同，所以需要将 新节点的random指向 改为 原节点的random指向的节点的下一个节点。</p> 
<p>所有新节点的random指向改好后，拆分链表，将链表拆为原链表和新链表。</p> 
<p><img alt="" height="260" src="https://images2.imgbox.com/52/64/zdKrMO0t_o.png" width="1036"></p> 
<p></p> 
<h4>代码实现</h4> 
<pre><code class="language-javascript">/**
 * // Definition for a Node.
 * function Node(val, next, random) {
 *    this.val = val;
 *    this.next = next;
 *    this.random = random;
 * };
 */

/**
 * @param {Node} head
 * @return {Node}
 */
var copyRandomList = function(head) {
    if(!head) return null;
    // 克隆每个节点，并插在原节点后面
    let cur = head;
    while(cur) {
        let copyNode = new Node(cur.val, cur.next, cur.random);
        // let copyNode = new Node(cur.val)
        // copyNode.next = cur.next
        // copyNode.random = cur.random;
        cur.next = copyNode;
        cur = copyNode.next;
    }
    // 将所有克隆节点的random指向对应的克隆节点
    cur = head.next;
    while(cur) {
        (cur.random) &amp;&amp; (cur.random = cur.random.next);
        // cur向后走两步，这样写能判断cur.next是否存在
        (cur = cur.next) &amp;&amp; (cur = cur.next);
    }


    // 将链表分为原链表和克隆链表

    // 实现方法一
    // 把第一个克隆的节点储存到p、q、head中
    // let p = q = head.next;
    // while(q.next) {
    //     // 原链表：将head的next指向下下个节点
    //     head.next = head.next.next;
    //     // 新链表：将q的next指向下下个节点
    //     q.next = q.next.next;
    //     head = head.next;
    //     q = q.next;
    // }
    // // 链表尾用null
    // head.next = null;
    // return p;

    // 实现方法二
    let newHead = head.next; //新链表
    let p = head; //原链表指针
    // let q = p.next; 
    while(p) {
        let q = p.next; // q指向p.next
        p.next = q.next; // p.next指向下下个节点
        p.next &amp;&amp; (q.next = p.next.next); // q.next指向下下个节点
        p = p.next; // p指针往后走一步
    }
    return newHead;
};</code></pre> 
<p></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/18af420bfde70a5ca753ff5837521806/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">递归与栈刷题</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/e74366c1b63632bd600588fc723ea20d/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">移动端适配常见坑</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>