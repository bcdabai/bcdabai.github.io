<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>go语言学习：type详解 - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="go语言学习：type详解" />
<meta property="og:description" content="转自：微点阅读 https://www.weidianyuedu.com
在go语言中，type用于类型定义(type definition)与类型别名(type alias)。这两者的差别从名字上已经可以初见端倪。
类型定义即定义新类型，是一个全新的类型，但可能与被定义类型存在一些关系，如类型转换，方法继承等。类型定义在各语言中有不同的体现，如Java是用class, interface等关键字作类型定义，在python中也是使用class关键字。只不过go为了简洁的原则，可以省些关键字，因而与类型别名重用了type关键字。
类型别名则是对被定义类型的别称，与其是相同的类型，只不过取了另外一个名字而已。类型别名是本文讨论的重点。这里有几个问题，一是为何go要引入类型别名，其有什么好处？为什么Java或者其他语言没有类型别名？
在go语言中，type有5种作用，罗列如下。但在本文中，只讲述类型定义与类型别名。
定义接口定义结构体类型定义类型别名类型查询 类型定义
package main
import &#34;fmt&#34;
func main() {
h := House{height: 1.0, width: 2.0}
fmt.Println(h.Height())
wh := WhiteHouse{height: 1.0, width: 2.0}
fmt.Println(wh.Area())
w := House(wh) //类型转换
fmt.Println(w.Width())
f1 := Factory{height: 1.0, width: 2.0}
f2 := Factory2{name: &#34;test&#34;}
fw := House(f1)
fmt.Println(fw)
fw2 := House(f2) //运行时这里会报类型转换错误
fmt.Println(fw2)
}
type House struct {
height float32
width float32
}
func (h *House) Height() float32 {" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/1b49fa0090c7d1766433fd57c4c7dc30/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-03-11T22:30:27+08:00" />
<meta property="article:modified_time" content="2022-03-11T22:30:27+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">go语言学习：type详解</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p>转自：<a class="link-info" href="https://www.weidianyuedu.com" rel="nofollow" title="微点阅读">微点阅读</a>   <a href="https://www.weidianyuedu.com" rel="nofollow" title="https://www.weidianyuedu.com">https://www.weidianyuedu.com</a></p> 
<p></p> 
<p> 在<a href="https://so.csdn.net/so/search?q=go%E8%AF%AD%E8%A8%80&amp;spm=1001.2101.3001.7020" title="go语言">go语言</a>中，type用于类型定义(type definition)与类型别名(type alias)。这两者的差别从名字上已经可以初见端倪。</p> 
<p>  类型定义即定义新类型，是一个全新的类型，但可能与被定义类型存在一些关系，如<a href="https://so.csdn.net/so/search?q=%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2&amp;spm=1001.2101.3001.7020" title="类型转换">类型转换</a>，方法继承等。类型定义在各语言中有不同的体现，如Java是用class, interface等关键字作类型定义，在python中也是使用class关键字。只不过go为了简洁的原则，可以省些关键字，因而与类型别名重用了type关键字。</p> 
<p>  类型别名则是对被定义类型的别称，与其是相同的类型，只不过取了另外一个名字而已。类型别名是本文讨论的重点。这里有几个问题，一是为何go要引入类型别名，其有什么好处？为什么Java或者其他语言没有类型别名？</p> 
<p>  在go语言中，type有5种作用，罗列如下。但在本文中，只讲述类型定义与类型别名。</p> 
<ol><li>定义接口</li><li>定义结构体</li><li>类型定义</li><li>类型别名</li><li>类型查询</li></ol> 
<p>类型定义</p> 
<pre></pre> 
<ol><li> <p><code>package main</code></p> </li><li><li> <p><code>import "fmt"</code></p> </li><li><li> <p><code>func main() {<!-- --></code></p> </li><li> <p><code>h := House{height: 1.0, width: 2.0}</code></p> </li><li> <p><code>fmt.Println(h.Height())</code></p> </li><li> <p><code>wh := WhiteHouse{height: 1.0, width: 2.0}</code></p> </li><li> <p><code>fmt.Println(wh.Area())</code></p> </li><li> <p><code>w := House(wh) //类型转换</code></p> </li><li> <p><code>fmt.Println(w.Width())</code></p> </li><li> <p><code>f1 := Factory{height: 1.0, width: 2.0}</code></p> </li><li> <p><code>f2 := Factory2{name: "test"}</code></p> </li><li> <p><code>fw := House(f1)</code></p> </li><li> <p><code>fmt.Println(fw)</code></p> </li><li> <p><code>fw2 := House(f2) //运行时这里会报类型转换错误</code></p> </li><li> <p><code>fmt.Println(fw2)</code></p> </li><li> <p><code>}</code></p> </li><li><li> <p><code>type House struct {<!-- --></code></p> </li><li> <p><code>height float32</code></p> </li><li> <p><code>width float32</code></p> </li><li> <p><code>}</code></p> </li><li><li> <p><code>func (h *House) Height() float32 {<!-- --></code></p> </li><li> <p><code>return h.height</code></p> </li><li> <p><code>}</code></p> </li><li><li> <p><code>func (h *House) Width() float32 {<!-- --></code></p> </li><li> <p><code>return h.width</code></p> </li><li> <p><code>}</code></p> </li><li><li> <p><code>type WhiteHouse House //类型定义</code></p> </li><li><li> <p><code>func (h *WhiteHouse) Area() float32 {<!-- --></code></p> </li><li> <p><code>return h.height * h.width</code></p> </li><li> <p><code>}</code></p> </li><li><li> <p><code>type Factory struct {<!-- --></code></p> </li><li> <p><code>height float32</code></p> </li><li> <p><code>width float32</code></p> </li><li> <p><code>}</code></p> </li><li><li> <p><code>type Factory2 struct {<!-- --></code></p> </li><li> <p><code>name string</code></p> </li><li> <p><code>}</code></p> </li></ol> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/3d/d5/cSFbxahR_o.png"></p> 
<p>  WhiteHouse与House是两个不同的类型，方法Area只属于WhiteHouse。 WhiteHouse可以转换为House类型。但对于类型Factory与Factory2，House与WhiteHouse都只能与Factory进行类型转换（尽管这种类型转换在实践中基本不会出现），而与Factory2进行类型转换则会报错。个中原因在于struct类型的内存布局是按顺序存储的，因为只要类型拥有的属性一致，则进行类型转换不会报运行时错误。既然是顺序存储，那么适当合理地安排不同类型属性的出现顺序，可以达到优化内存使用的目的。比如将几个可以计算出占用内存和为8、16、32、64的属性放在一起，当然内存对齐的位数因不同平台和编译器而异。</p> 
<p>类型定义通常还用在定义函数类型上，示例如下：</p> 
<pre></pre> 
<ol><li> <p><code>type Handler func(name string)</code></p> </li><li><li> <p><code>func process(h Handler) {<!-- --></code></p> </li><li> <p><code>h("test")</code></p> </li><li> <p><code>}</code></p> </li></ol> 
<p>类型别名</p> 
<p>在go语言中，类型别名的定义示例如下：</p> 
<pre></pre> 
<ol><li> <p><code>package main</code></p> </li><li><li> <p><code>import "fmt"</code></p> </li><li><li> <p><code>func main() {<!-- --></code></p> </li><li> <p><code>h := House{height: 1.0, width: 2.0}</code></p> </li><li> <p><code>fz := Fangzi{height: 1.0, width: 2.0}</code></p> </li><li> <p><code>fmt.Println(h.Area()) //House也有了Area方法</code></p> </li><li> <p><code>fmt.Println(fz.Area())</code></p> </li><li> <p><code>}</code></p> </li><li><li> <p><code>type House struct {<!-- --></code></p> </li><li> <p><code>height float32</code></p> </li><li> <p><code>width float32</code></p> </li><li> <p><code>}</code></p> </li><li><li> <p><code>func (h *House) Height() float32 {<!-- --></code></p> </li><li> <p><code>return h.height</code></p> </li><li> <p><code>}</code></p> </li><li><li> <p><code>func (h *House) Width() float32 {<!-- --></code></p> </li><li> <p><code>return h.width</code></p> </li><li> <p><code>}</code></p> </li><li><li> <p><code>type Fangzi = House //类型别名</code></p> </li><li><li> <p><code>func (f *Fangzi) Area() float32 {<!-- --></code></p> </li><li> <p><code>return f.height * f.width</code></p> </li><li> <p><code>}</code></p> </li></ol> 
<p>  在语法上，类型别名与类型定义的差别仅仅是一个=号。但从上述示例可知，对Fangzi的改变，同样会体现在House上。Fangzi添加了Area方法，同时House也获得了计算Area的能力。这一点与类型定义是明显不同的。</p> 
<p>  从这里可以看出，类型别名的一个好处在于可以为不喜欢的类型<strong>取一个漂亮的名字</strong>。比如，如果你更喜欢Human多于Person的话。</p> 
<pre></pre> 
<ol><li> <p><code>type Person struct {<!-- --></code></p> </li><li> <p><code>name string</code></p> </li><li> <p><code>age int</code></p> </li><li> <p><code>sex string</code></p> </li><li> <p><code>}</code></p> </li><li><li> <p><code>type Human = Person</code></p> </li></ol> 
<p>  除此之外呢？对于库开发者来说，<strong>新旧版本包的迁移</strong>应是比较常见的事，特别是大版本升级的时候。那么为了保证新旧之间的兼容，可能就会用到类型别名的特性。比如旧包中的com.eventer/lib/AI，大版本升级时，需要变成com.eventer/lib2/AI。如果直接去掉lib/AI，则会造成使用这个库的项目，在引用新包时需要修改所有引用了旧包AI类型的代码。因而更好的作法是在移除com.eventer/lib/AI原有代码之后，加上一个类型别名的定义，即可完美解决这个问题。</p> 
<pre></pre> 
<ol><li> <p><code>package com.eventer/lib</code></p> </li><li><li> <p><code>import "com.eventer/lib2"</code></p> </li><li><li> <p><code>type AI = lib2.AI</code></p> </li></ol> 
<p>  还有吗？如果下面的示例也能被称作一种用途的话，那么这一种用法就是<strong>"导出未被导出的类型"</strong>。</p> 
<pre></pre> 
<ol><li> <p><code>type house struct {<!-- --></code></p> </li><li> <p><code>name string</code></p> </li><li> <p><code>height float32</code></p> </li><li> <p><code>width float32</code></p> </li><li> <p><code>}</code></p> </li><li><li> <p><code>func (h *house) getName() string {<!-- --></code></p> </li><li> <p><code>return h.name</code></p> </li><li> <p><code>}</code></p> </li><li><li> <p><code>func (h *house) GetArea() string {<!-- --></code></p> </li><li> <p><code>return h.height * h.width</code></p> </li><li> <p><code>}</code></p> </li><li><li> <p><code>type House = house</code></p> </li></ol> 
<p>  但我认为这还是跟前文所述的类型别名的标准用法一般无异，实在看不出有什么不同，除了单词与原类型相同而已。否则根本没必要这样写代码，直接把house声明为House不是更直截了当？除非是用于取别名。</p> 
<p>  如果go有泛型，那么类型别名在简化代码，提高代码可读性方面，无疑将带来极大的好处。特别是对于java语言那种泛型的复杂度让人抓狂的语言，只可惜java没有语言层面的类型定义语法。虽然可以通过一些取巧的方式也能达到类似的效果，比如继承。比如下面的例子：</p> 
<pre></pre> 
<ol><li> <p><code>public class LongArrayList extends ArrayList&lt;Long&gt; {<!-- --></code></p> </li><li><li> <p><code>}</code></p> </li></ol> 
<p>  上述代码定义一个Long类型的动态数组，相当于为泛型的ArrayList定义了一个新类型，在代码中可以直接使用。这是采用代码技巧突破在java中不能在顶级（top level）定义类型别名的限制，但 通过定义一个类来完成这件事情，是不是太重量级了。再比如：</p> 
<pre></pre> 
<ol><li> <p><code>class Test&lt;I extends Integer&gt; {<!-- --></code></p> </li><li> <p><code>&lt;L extends Long&gt; void x(I i, L l) {<!-- --></code></p> </li><li> <p><code>System.out.println(i.intValue() + ", " + l.longValue());</code></p> </li><li> <p><code>}</code></p> </li><li> <p><code>}</code></p> </li></ol> 
<p>  这是在类级别或方法级别定义类型别名。上述例子是通过给Integer、Long定义更短的名字——I和L。</p> 
<p>  反正这两种都只是语法形式上的变通，通常没人这样用。</p> 
<p>  而在C语言中，有同样的功能typedef关键字，比如：</p> 
<pre></pre> 
<ol><li> <p><code>typedef struct Name1 {<!-- --></code></p> </li><li> <p><code>elemtype ElemName;</code></p> </li><li> <p><code>} Name2, Name3;</code></p> </li></ol> 
<p>其中Name1为结构体名，同时它还有两个"外号"：Name2，Name3，因为c没有对象的概念，所以很明显这里的typedef并没有go的type关键字的内容多，但他们底层的原理应是相同的，都是通过在在编译时期替换完成。</p> 
<p></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/40815c5418cd86dcfe563e5af10462de/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">C语言实现贪吃蛇游戏（Linux下实现）</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/797c7931a966b21b2cf4d3e3770d2b70/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">Python批量处理经纬度数据并生成位置信息</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>