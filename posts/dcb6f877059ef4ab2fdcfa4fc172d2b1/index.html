<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Node.js面试题整理-四年经验 - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Node.js面试题整理-四年经验" />
<meta property="og:description" content="一、Node.js语言部分 I.语言基础 1.闭包的原理 函数就是一个闭包，js的特点是可以在函数内部创建另一个函数。js可以在函数内用外部的变量，所以自然而然产生的闭包概念。
function foo(){ var local = 1 function bar(){ local&#43;&#43; return local } return bar } var func = foo() func() 在内部的那个函数可以引用外部的变量，但同时这个变量也无法被销毁，有消耗内存的风险。
再看一个例子
function makeAdder(x){ return function( y ){ return x &#43; y } } var add5 = makeAdder( 5 ); var add10 = makeAdder( 10 ); console.log( add5(2) ) // 7 console.log( add10(2) ) // 12 以上示例中，我们定义了makeAdder(x) 函数，它接收一个参数x ，并返回一个新的函数。返回的函数接受一个参数y，并返回 x&#43;y的值。
本质上讲，makeAdder 是一个工厂函数 – 它创建了将指定的值和它的参数相加求和的函数。上面的add5和add10都是闭包。它们共享相同的函数定义，但是保存了不同的词法环境。在add5的环境中，x为5，而在add10中，x则是10。
块级作用域 {}也是划分作用域的概念，和闭包略有不同。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/dcb6f877059ef4ab2fdcfa4fc172d2b1/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-01-18T17:41:09+08:00" />
<meta property="article:modified_time" content="2023-01-18T17:41:09+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Node.js面试题整理-四年经验</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-light">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <h2><a id="Nodejs_0"></a>一、Node.js语言部分</h2> 
<h3><a id="I_2"></a>I.语言基础</h3> 
<h4><a id="1_4"></a>1.闭包的原理</h4> 
<p>函数就是一个闭包，js的特点是可以在函数内部创建另一个函数。js可以在函数内用外部的变量，所以自然而然产生的闭包概念。</p> 
<pre><code class="prism language-js"><span class="token keyword">function</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
  <span class="token keyword">var</span> local <span class="token operator">=</span> <span class="token number">1</span>
  <span class="token keyword">function</span> <span class="token function">bar</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
    local<span class="token operator">++</span>
    <span class="token keyword">return</span> local
  <span class="token punctuation">}</span>
  <span class="token keyword">return</span> bar
<span class="token punctuation">}</span>

<span class="token keyword">var</span> func <span class="token operator">=</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token function">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
</code></pre> 
<p>在内部的那个函数可以引用外部的变量，但同时这个变量也无法被销毁，有消耗内存的风险。</p> 
<p>再看一个例子</p> 
<pre><code class="prism language-js"><span class="token keyword">function</span> <span class="token function">makeAdder</span><span class="token punctuation">(</span><span class="token parameter">x</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
    <span class="token keyword">return</span> <span class="token keyword">function</span><span class="token punctuation">(</span> <span class="token parameter">y</span> <span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
        <span class="token keyword">return</span> x <span class="token operator">+</span> y 
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">var</span> add5 <span class="token operator">=</span> <span class="token function">makeAdder</span><span class="token punctuation">(</span> <span class="token number">5</span> <span class="token punctuation">)</span><span class="token punctuation">;</span>    
<span class="token keyword">var</span> add10 <span class="token operator">=</span> <span class="token function">makeAdder</span><span class="token punctuation">(</span> <span class="token number">10</span> <span class="token punctuation">)</span><span class="token punctuation">;</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span> <span class="token function">add5</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span> <span class="token punctuation">)</span>  <span class="token comment">// 7 </span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span> <span class="token function">add10</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span> <span class="token punctuation">)</span>   <span class="token comment">// 12</span>
</code></pre> 
<p>以上示例中，我们定义了makeAdder(x) 函数，它接收一个参数x ，并返回一个新的函数。返回的函数接受一个参数y，并返回 x+y的值。</p> 
<p>本质上讲，makeAdder 是一个工厂函数 – 它创建了将指定的值和它的参数相加求和的函数。上面的add5和add10都是闭包。它们共享相同的函数定义，但是保存了不同的词法环境。在add5的环境中，x为5，而在add10中，x则是10。</p> 
<h5><a id="_44"></a>块级作用域</h5> 
<p>{}也是划分作用域的概念，和闭包略有不同。</p> 
<h4><a id="2Js_48"></a>2.Js的内置对象</h4> 
<p>Object、Array、Boolean、Number、String、Buffer等等。</p> 
<h4><a id="3Nodejs_gc_52"></a>3.Nodejs gc</h4> 
<h5><a id="_56"></a>引用计数法</h5> 
<p>假设有一个对象A，任何对象对A进行引用，那么对象A的引用计数器+1，当引用失效时，对象A的引用计数器-1，当对象A的引用计数器为0时，就说明对象A没用被引用，那么就可以进行回收。</p> 
<h6><a id="_60"></a>优点：</h6> 
<ul><li> <p>实时性高 不需要等内存不足再回首。</p> </li><li> <p>垃圾回收的时候不需要挂起应用。</p> </li><li> <p>区域更新对象，不需要扫描全部对象</p> </li></ul> 
<h6><a id="_67"></a>缺点：</h6> 
<ul><li> <p>每次对象被引用都要更新</p> </li><li> <p>浪费cpu资源，因为内存足够的时候还在统计</p> </li><li> <p>无法解决循环引用</p> </li></ul> 
<p>比如两个对象互相引用 都赋值成null，那就永远回收不了了。</p> 
<h5><a id="_76"></a>标记清除法</h5> 
<p>标记清除法是把gc分为两个阶段，标记和清除。</p> 
<ul><li> <p>标记：从根节点开始标记引用的对象</p> </li><li> <p>清除：没被标记的就是垃圾对象 可以清除。</p> </li></ul> 
<p>结构有点像多叉树。</p> 
<p>从根节点开始遍历，找到所有可达的对象，其他的都是可以清除的。</p> 
<h6><a id="_88"></a>优点</h6> 
<p>解决了循环引用的问题</p> 
<h6><a id="_92"></a>缺点</h6> 
<p>标记和清除都需要遍历所有对象，gc的时候需要暂停程序。对交互性高的程序体验很差。</p> 
<p>内存碎片多，被清理的对象在内存的各个角落。</p> 
<h5><a id="_98"></a>标记压缩算法</h5> 
<p>标记压缩算法是在标记清除法的基础上进行了优化，标记阶段是一样的，在清理阶段不是直接清理标记对象，而是将存活对象压缩到内存的一端，然后清理边界以外的垃圾，从而解决碎片化问题。</p> 
<h6><a id="_103"></a>优缺点</h6> 
<p>解决了内存碎片化的问题，但是多了压缩的一步，对象移动内存位置的步骤，对效率有影响。</p> 
<h4><a id="4__107"></a>4. 原型</h4> 
<p>在js中，对象都有__proto__属性，一般这个是被称为隐式的原型，该隐式原型指向构造该对象的构造函数的原型。</p> 
<p>函数比较特殊，它除了和其他对象一样有__proto__属性，还有自己特有的属性----prototype，这个属性是一个指针，指向一个包含所有实例共享的属性和方法的对象，称之为原型对象。原型对象也有一个constructor属性，该属性指回该函数。</p> 
<h4><a id="5_113"></a>5.模块</h4> 
<h5><a id="_114"></a>模块内部是什么？</h5> 
<p>Node 中，每个文件模块都是一个对象，它的定义如下：</p> 
<pre><code class="prism language-js"><span class="token keyword">function</span> <span class="token function">Module</span><span class="token punctuation">(</span><span class="token parameter">id<span class="token punctuation">,</span> parent</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
  <span class="token keyword">this</span><span class="token punctuation">.</span>id <span class="token operator">=</span> id<span class="token punctuation">;</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span>exports <span class="token operator">=</span> <span class="token punctuation">{<!-- --></span><span class="token punctuation">}</span><span class="token punctuation">;</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span>parent <span class="token operator">=</span> parent<span class="token punctuation">;</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span>filename <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span>loaded <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span>children <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

module<span class="token punctuation">.</span>exports <span class="token operator">=</span> Module<span class="token punctuation">;</span>

<span class="token keyword">var</span> module <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Module</span><span class="token punctuation">(</span>filename<span class="token punctuation">,</span> parent<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> 
<p>基本只需要知道模块是一个对象，并且其中有文件名，父子对象即可。</p> 
<h5><a id="require__135"></a>require 的模块加载机制</h5> 
<ol><li>先计算模块路径</li><li>如果模块在缓存里面，取出缓存</li><li>生成模块实例，存入缓存</li><li>加载模块</li><li>输出模块的exports属性</li></ol> 
<h3><a id="IIlibuv_145"></a>II.libuv原理</h3> 
<p>libuv底层是用了生产者-消费者的模型，libuv在整个生命周期中，每一次循环都执行每个阶段（phase）维护的任务队列。逐个执行节点里的回调，在回调中，不断生产新的任务，从而不断驱动libuv。</p> 
<h4><a id="Nodejs_149"></a>Nodejs的事件循环原理</h4> 
<p>事件循环底层使用libuv。</p> 
<h5><a id="Nodejs_152"></a>Nodejs的特点</h5> 
<p>单线程，它不会为每个请求分配一个线程，而是用主线程处理所有请求，对输入输出进行异步处理，避开了创建销毁线程，和线程切换的开销和复杂性。</p> 
<h5><a id="_156"></a>核心原理</h5> 
<p>Node.js 在主线程里维护了一个事件队列，当接到请求后，就将该请求作为一个事件放入这个队列中，然后继续接收其他请求。</p> 
<p>当主线程空闲时(没有请求接入时)，就开始循环事件队列，检查队列中是否有要处理的事件，这时要分两种情况：如果是非 I/O 任务，就亲自处理，并通过回调函数返回到上层调用；如果是 I/O 任务，就从 线程池 中拿出一个线程来处理这个事件，并指定回调函数，然后继续循环队列中的其他事件。</p> 
<p>当线程中的 I/O 任务完成以后，就执行指定的回调函数，并把这个完成的事件放到事件队列的尾部，等待事件循环，当主线程再次循环到该事件时，就直接处理并返回给上层调用。 这个过程就叫 事件循环 (Event Loop)。</p> 
<p>无论是 Linux 平台还是 Windows 平台，Node.js 内部都是通过 线程池 来完成异步 I/O 操作的，而 LIBUV 针对不同平台的差异性实现了统一调用。因此，Node.js 的单线程仅仅是指 JavaScript 运行在单线程中，而并非 Node.js 是单线程。</p> 
<p>在事件队列中，如果前面的 CPU 计算任务没有完成，后面的任务就会被阻塞，出现响应缓慢的情况，当 Node.js 被CPU 密集型任务占用，导致其他任务被阻塞时，却还有 CPU 内核处于闲置状态，造成资源浪费。</p> 
<h5><a id="Nodejs_168"></a>Nodejs的事件驱动</h5> 
<p>Node 中的 Event Loop 和浏览器中的是完全不相同的东西。Node.js 采用 V8 作为 js 的解析引擎，而 I/O 处理方面使用了自己设计的 libuv，libuv 是一个基于事件驱动的跨平台抽象层，封装了不同操作系统一些底层特性，对外提供统一的 API，事件循环机制也是它里面的实现</p> 
<p>Node.js 的运行机制如下:</p> 
<ul><li>V8 引擎解析 JavaScript 脚本。</li><li>解析后的代码，调用 Node API。</li><li>libuv 库负责 Node API 的执行。它将不同的任务分配给不同的线程，形成一个 Event Loop（事件循环），以异步的方式将任务的执行结果返回给 V8 引擎。</li><li>V8 引擎再将结果返回给用户。</li></ul> 
<h5><a id="_179"></a>事件驱动具体实现</h5> 
<p>进程启动时，Node 便会创建一个类似于 while(true)的循环，每执行一次循环体的过程我们成为 Tick。<br> 每个 Tick 的过程就是查看是否有事件待处理。如果有就取出事件及其相关的回调函数。然后进入下一个循环，如果不再有事件处理，就退出进程。<br> <img src="https://images2.imgbox.com/20/e3/JwHENb0X_o.png" alt="在这里插入图片描述"></p> 
<h6><a id="_tick__184"></a>在每个 tick 的过程中，如何判断是否有事件需要处理呢？</h6> 
<p>每个事件循环中有一个或者多个观察者，而判断是否有事件需要处理的过程就是向这些观察者询问是否有要处理的事件。</p> 
<p>在 Node 中，事件主要来源于网络请求、文件的 I/O 等，这些事件对应的观察者有文件 I/O 观察者，网络 I/O 的观察者。<br> 事件循环是一个典型的生产者/消费者模型。异步 I/O，网络请求等则是事件的生产者，源源不断为 Node 提供不同类型的事件，这些事件被传递到对应的观察者那里，事件循环则从观察者那里取出事件并处理。<br> 在 windows 下，这个循环基于 IOCP 创建，在*nix 下则基于多线程创建</p> 
<h6><a id="IO_192"></a>整个异步IO的流程</h6> 
<p><img src="https://images2.imgbox.com/a3/ea/rP4HbPUm_o.png" alt="在这里插入图片描述"></p> 
<h5><a id="_198"></a>使用要点</h5> 
<p>尽量不在服务器中使用需要同步等待的CPU密集型任务，如fs的同步读文件，因为这会阻塞事件队列的轮询。</p> 
<p><strong>每个 CPU 密集任务只在它被调度到的时候才会得到执行。</strong></p> 
<p>Node.js 有两种类型的线程：一个事件循环线程和 k 个工作线程。 事件循环负责 JavaScript 回调和非阻塞 I/O，工作线程执行与 C++ 代码对应的、完成异步请求的任务，包括阻塞 I/O 和 CPU 密集型工作。</p> 
<p>这两种类型的线程一次都只能处理一个活动。 如果任意一个回调或任务需要很长时间，则运行它的线程将被 阻塞。 如果你的应用程序发起阻塞的回调或任务，在好的情况下这可能只会导致吞吐量下降（客户端/秒），而在最坏情况下可能会导致完全拒绝服务。</p> 
<h3><a id="IIIv8_208"></a>III.v8</h3> 
<p>v8解决的问题是快速解析和执行JavaScript脚本。</p> 
<h4><a id="1_212"></a>1.内存限制</h4> 
<p>32位是0.7gb，64位是1.4gb</p> 
<p>有内存限制是因为V8做GC需要耗时。垃圾回收中引起JavaScript 线程暂停执行，如果内存上限太大会显著降低程序的运行速度。</p> 
<h4><a id="2Nodejs_218"></a>2.和Nodejs的关系</h4> 
<p>v8把js代码翻译成机器码，直接运行。</p> 
<h4><a id="3_222"></a>3.内存结构</h4> 
<p>内存区主要能够分为如下几类：栈区、堆区、常量区、函数定义区、函数缓存区。</p> 
<h5><a id="_226"></a>堆区</h5> 
<p>JavaScript的变量名是用来保存内存中某块内存区的地址的，而栈区就是用来保存变量名和内存地址的键值对的。</p> 
<pre><code class="prism language-js"><span class="token keyword">let</span> a <span class="token operator">=</span> <span class="token punctuation">{<!-- --></span><span class="token punctuation">}</span>
</code></pre> 
<p>对于该语句，V8会在堆区中开辟一块内存，而后在栈区添加一个键值对，键名是咱们声明的变量名a，键值是堆区中开辟出的内存的地址。</p> 
<p>在堆区中存在一个特殊的预置对象null，它在堆区中有固定的内存地址，而且是惟一的。也就是说全部被赋值为null的变量指向的都是这同一块内存地址（所以被赋值为null的变量也是有内存地址的）。</p> 
<h5><a id="_238"></a>常量区</h5> 
<ul><li>全部的值都是不可变的</li><li>全部相同的常量值在常量区都是唯一的。</li></ul> 
<h5><a id="_244"></a>函数定义区</h5> 
<pre><code class="prism language-js"><span class="token comment">//函数声明</span>
<span class="token keyword">function</span> <span class="token function">f</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
  <span class="token operator">...</span>
<span class="token punctuation">}</span>
<span class="token comment">//函数引用</span>
<span class="token keyword">var</span> <span class="token function-variable function">f</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
 <span class="token operator">...</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>其实没什么卵用的知识。</p> 
<pre><code class="prism language-js"><span class="token comment">//能够正常调用，由于引擎会提早扫描代码，将该函数存储到函数定义区</span>
<span class="token function">f</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">function</span> <span class="token function">f</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span><span class="token punctuation">}</span>

<span class="token comment">//报错，由于虽然g也进行了变量提高，但此时g的值是undefined，不能调用</span>
<span class="token function">g</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">var</span> <span class="token function-variable function">g</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span><span class="token punctuation">}</span>
</code></pre> 
<h5><a id="_268"></a>函数缓存区</h5> 
<p>所谓函数缓存区，就是函数运行所用的内存区。当V8引擎须要执行一个函数时，它就会在函数缓存区开辟一块内存，保存该函数运行所须要存储的状态和变量。</p> 
<p>一般情况都会回收内存，用了闭包就有可能不回收（上面有提到）</p> 
<h5><a id="_274"></a>理解相等和全等</h5> 
<pre><code class="prism language-js"><span class="token keyword">var</span> a <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
<span class="token keyword">var</span> b <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
a <span class="token operator">===</span> b<span class="token punctuation">;</span>   <span class="token comment">//值为true，同一个常量在常量区只会生成一个，所以二者获得地址是同样的</span>

<span class="token keyword">var</span> a <span class="token operator">=</span> <span class="token punctuation">{<!-- --></span><span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">var</span> b <span class="token operator">=</span> <span class="token punctuation">{<!-- --></span><span class="token punctuation">}</span><span class="token punctuation">;</span>
a <span class="token operator">===</span> b<span class="token punctuation">;</span>    <span class="token comment">//值为false，引擎会分别为a和b开辟内存，所以二者的地址并不相同</span>

<span class="token keyword">null</span> <span class="token operator">===</span> <span class="token keyword">null</span><span class="token punctuation">;</span>  <span class="token comment">//值为true，由于堆区只有一个null</span>
<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">===</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>  <span class="token comment">//值为false，原理与{}相同</span>
</code></pre> 
<p>在比较字符串的时候，数字会先转成字符串，然后去比较地址。</p> 
<h4><a id="4V8_292"></a>4.V8的垃圾回收机制</h4> 
<p>V8的垃圾回收机制采用的是标记清除法，这也是如今JavaScript引擎通用的一种回收机制。</p> 
<p>新生代空间小一点，老生代空间大一点。</p> 
<h5><a id="_298"></a>新生代</h5> 
<p>新生代区域一分为二，每个16M，一个使用，一个空闲。</p> 
<p>开始垃圾回收的时候，会检查FROM区域中的存活对象，如果还活着，拷贝到TO空间，所有存活对象拷贝完后，清空(释放)FROM区域<br> 然后FROM和To区域互换。</p> 
<p>新生代的空间小，存活对象少。</p> 
<p>当一个对象经理多次的垃圾回收依然存活的时候，生存周期比较差的对象会被移动到老生代，这个移动过程被称为晋升或升级。</p> 
<ul><li> <p>经历过5次以上的回收还存在</p> </li><li> <p>TO的空间使用占比超过25%，或者超大对象</p> </li></ul> 
<h5><a id="_313"></a>老生代</h5> 
<p>老生代垃圾回收策略分为两种：</p> 
<h6><a id="marksweep__317"></a>mark-sweep 标记清除</h6> 
<p>标记活着的对象，虽然清楚在标记阶段没有标记的对象，只清理死亡对象</p> 
<p>会出现的问题：清除后内存不连续，碎片内存无法分配</p> 
<h6><a id="markcompact__323"></a>mark-compact 标记整理</h6> 
<p>标记死亡后会对对象进行整理，活着的左移，移动完成后清理掉边界外的内存(死亡的对象)</p> 
<p>老生代空间大，大部分都是活着的对象，GC耗时比较长</p> 
<p><strong>GC的时候程序无法进行响应</strong></p> 
<h6><a id="_V8__331"></a>哪些情况会造成 V8 无法立即回收内存</h6> 
<p>闭包和全局变量</p> 
<h6><a id="_335"></a>请谈一下内存泄漏是什么，以及常见内存泄漏的原因，和排查的方法</h6> 
<p>内存泄漏(Memory Leak)指由于疏忽或错误造成程序未能释放已经不再使用的内存的情况。</p> 
<p>如果内存泄漏的位置比较关键，那么随着处理的进行可能持有越来越多的无用内存，这些无用的内存变多会引起服务器响应速度变慢。</p> 
<p>严重的情况下导致内存达到某个极限(可能是进程的上限，如 v8 的上限;也可能是系统可提供的内存上限)会使得应用程序崩溃。常见内存泄漏的原因 内存泄漏的几种情况:</p> 
<h6><a id="_343"></a>全局对象</h6> 
<pre><code class="prism language-js">a <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>
<span class="token comment">//未声明对象。</span>
global<span class="token punctuation">.</span>b <span class="token operator">=</span> <span class="token number">11</span><span class="token punctuation">;</span>
<span class="token comment">//全局变量引用</span>
这种比较简单的原因，全局变量直接挂在 root 对象上，不会被清除掉。
</code></pre> 
<h6><a id="_352"></a>闭包</h6> 
<pre><code class="prism language-js"><span class="token keyword">function</span> <span class="token function">out</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    <span class="token keyword">const</span> bigData <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Buffer</span><span class="token punctuation">(</span><span class="token number">100</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function-variable function">inner</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>

    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>闭包会引用到父级函数中的变量，如果闭包未释放，就会导致内存泄漏。上面例子是 inner 直接挂在了 root 上，那么每次执行 out 函数所产生的 bigData 都不会释放，从而导致内存泄漏。需要注意的是，这里举得例子只是简单的将引用挂在全局对象上，实际的业务情况可能是挂在某个可以从 root 追溯到的对象上导致的。</p> 
<p>个人认为这主要是闭包内变量没有申明let导致了变量提升。</p> 
<h6><a id="_368"></a>事件监听</h6> 
<p>Node.js 的事件监听也可能出现的内存泄漏。例如对同一个事件重复监听，忘记移除(removeListener)，将造成内存泄漏。这种情况很容易在复用对象上添加事件时出现。</p> 
<h3><a id="IV__372"></a>IV 多进程</h3> 
<h4><a id="1__node__374"></a>1. 请简述一下 node 的多进程架构</h4> 
<p>面对 node 单线程对多核 CPU 使用不足的情况，Node 提供了 child_process 模块，来实现进程的复制，node 的多进程架构是主从模式，如下所示：</p> 
<p><img src="https://images2.imgbox.com/11/33/mcdsQUbi_o.png" alt="在这里插入图片描述"></p> 
<h4><a id="2__379"></a>2. 多进程崩溃后如何维护</h4> 
<p>在创建子进程的时候就让子进程监听 exit 事件，如果被杀死就重新 fork 一下</p> 
<pre><code class="prism language-js"><span class="token keyword">var</span> <span class="token function-variable function">createWorker</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
    <span class="token keyword">var</span> worker <span class="token operator">=</span> <span class="token function">fork</span><span class="token punctuation">(</span>__dirname <span class="token operator">+</span> <span class="token string">'worker.js'</span><span class="token punctuation">)</span>
    worker<span class="token punctuation">.</span><span class="token function">on</span><span class="token punctuation">(</span><span class="token string">'exit'</span><span class="token punctuation">,</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'Worker'</span> <span class="token operator">+</span> worker<span class="token punctuation">.</span>pid <span class="token operator">+</span> <span class="token string">'exited'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">// 如果退出就创建新的worker</span>
        <span class="token function">createWorker</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre> 
<h3><a id="VNodeWebexpressKoaNestJs_394"></a>V.Node的Web框架(express、Koa、NestJs)</h3> 
<p>一般很少问框架，毕竟上手快，可以谈谈自己对其的理解</p> 
<h4><a id="1expressKoa_398"></a>1.express和Koa的中间件</h4> 
<p>中间件（Middleware ），特指业务流程的中间处理环节，当一个请求到达 Express 的服务器之后，可以连续调用多个中间件，从而对这次请求进行预处理。</p> 
<h5><a id="_403"></a>全局生效的中间件</h5> 
<p>客户端发起的任何请求，到达服务器之后，都会触发的中间件，叫做全局生效的中间件</p> 
<p>通过调用 app.use(中间件函数)，即可定义一个全局生效的中间件</p> 
<pre><code class="prism language-js"><span class="token keyword">const</span> <span class="token function-variable function">mw</span><span class="token operator">=</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">req<span class="token punctuation">,</span>res<span class="token punctuation">,</span>next</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
     console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">"这是一个简单的中间件"</span><span class="token punctuation">)</span>
     <span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 把流转关系，转交给下一个中间件或</span>
<span class="token punctuation">}</span>

<span class="token comment">// 全局生效的中间件</span>
app<span class="token punctuation">.</span><span class="token function">use</span><span class="token punctuation">(</span>mw<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> 
<h5><a id="_418"></a>中间件的作用</h5> 
<p>多个中间件之间，共享同一份 req 和 res。基于这样的特性，我们可以在上游的中间件中，统一为 req 或 res 对象添加自定义的属性或方法，供下游的中间件或路由进行使用</p> 
<h5><a id="express_421"></a>express内置中间件</h5> 
<ol><li> <p>express.static 快速托管静态资源的内置中间件(html css 图片等)</p> </li><li> <p>express.json 解析 JSON 格式的请求体数据 (表单)</p> </li><li> <p>express.urlencoded 解析 URL-encoded 格式的请求体数据 (表单)</p> </li></ol> 
<h4><a id="2NestJs_429"></a>2.NestJs</h4> 
<p><img src="https://images2.imgbox.com/b9/72/z447a0gE_o.png" alt="在这里插入图片描述"><br> NestJs很像Java，还能支持注解，注入各种中间件。<br> 这个框架属于限定了一些代码的写法，必须要安装Nest官方设计的方法去写代码，但这样项目的结构也会非常规整。</p> 
<p>Nest 使用 TS 的装饰器语法，将路由系统封装并提供接口，使得 controller 可以很方便的与路由系统结合，相较于 Express 等框架中心化的路由，Nest 路由是去中心化的, 而且与 controller 的结合非常方便：</p> 
<pre><code class="prism language-js"><span class="token keyword">import</span> <span class="token punctuation">{<!-- --></span> Controller<span class="token punctuation">,</span> Get<span class="token punctuation">,</span> Post <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">'@nestjs/common'</span><span class="token punctuation">;</span>

@<span class="token function">Controller</span><span class="token punctuation">(</span><span class="token string">'cats'</span><span class="token punctuation">)</span>
<span class="token keyword">export</span> <span class="token keyword">class</span> <span class="token class-name">CatsController</span> <span class="token punctuation">{<!-- --></span>
  @<span class="token function">Post</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
  <span class="token function">create</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">:</span> string <span class="token punctuation">{<!-- --></span>
    <span class="token keyword">return</span> <span class="token string">'This action adds a new cat'</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>

  @<span class="token function">Get</span><span class="token punctuation">(</span><span class="token string">'ab*cd'</span><span class="token punctuation">)</span>
  <span class="token function">findAll</span><span class="token punctuation">(</span>@<span class="token function">Req</span><span class="token punctuation">(</span><span class="token punctuation">)</span> request<span class="token operator">:</span> Request<span class="token punctuation">)</span><span class="token operator">:</span> string <span class="token punctuation">{<!-- --></span>
    <span class="token keyword">return</span> <span class="token string">'This action returns all cats'</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>这其中可以对类、方法及参数都可以使用装饰器。对类使用 @Controller 装饰器将类作为一个 controller 与路由结合，对方法可以使用@Get/@Post作为请求方法处理器，对方法参数使用@Req/@Query等访问请求及请求内各部分数据。</p> 
<h5><a id="_455"></a>所谓规整的代码</h5> 
<p>Nest 采用模块化思路，将 APP 分割成各个模块，可以是专属功能的模块，也可以是通用的共享模块以及全局模块。APP 至少有一个根模块，包含定义的providers、controllers，repositories, interceptors, middleware, 等等，以及imports及exports。一个模块可以引用其他模块，也可以被其他模块引用。exports 可以导出providers(service)供其他模块使用。</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/919c8f88d08c9d18dc556360d3f3b9a3/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">怎么查看docker容器的ip</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/daa8a95601e3fcf3999e1963c95b787d/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">长时长视频java存储及vue播放解决方法</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>