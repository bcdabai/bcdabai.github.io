<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>c&#43;&#43;数据结构之树 - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="c&#43;&#43;数据结构之树" />
<meta property="og:description" content="目录
前言
一、树的基本概念
1.1树的定义
1.2基本术语
二、二叉树
2.1二叉树的定义
2.2二叉树的性质
2.3二叉树的ADT
三、二叉树的存储表示
3.1二叉树的数组表示
3.2二叉树的链表表示
四、二叉树的遍历
4.1前序遍历
4.2中序遍历
4.3后序遍历
五、常用二叉树
5.1排序二叉树
5.2哈夫曼树
总结
前言 本文主要介绍的数据结构之树型结构的相关知识，树型数据结构是面试官面试的时候非常喜欢考的一种数据结构，树形结构的遍历也是大厂笔试非常喜欢设置的考点，这些内容都会在本篇文章中进行详细的介绍，并且还会介绍一些常用的算法。
一、树的基本概念 层次结构的数据在现实世界中大量存在。例如，一个国家有若干省，一个省有若干市县，一个市县有若干区乡。又如，一本书包含若干章，一章包含若干节，一节包含若干段。例如，下图是数组的层次关系，这种描述树形数据的形式称为倒置的树形表示法。
图1 数组的层次结构 线性数据结构一般不适合用来表示层次数据。为了组织层次数据，需要对树形数据的结构进行研究。
1.1树的定义 在上图1中，我们采用倒置树来描述树状结构。一棵倒置树的顶端是根，根有几个分枝，称为子树，每棵子树再分成几个小分枝，小分枝再分成更小的分枝，每个分枝也都是树，一个结点也是树。由此，我们可以给树下一个递归定义。
树（Tree）是包括n个结点的有限非空集合T，其中，一个特定的结点r称为根（Root），其余结点T-{r}划分成m个互不相交的子集T1，T2，Tm其中，每个子集都是树，称为树根r的子树。
根据树的定义，一个结点的树是仅有根结点的树，这时m=0，这棵树没有子树。
1.2基本术语 图1可以抽象成图2，它形象地反映了树的逻辑结构。下面，参照图2，给出树结构讨论中常用的术语。
图2 树的逻辑结构 树中元素称为结点（Node），如A、B等。
如果某结点到另一结点之间存在着连线，则称此连线为一条边（Edge），如&lt;A,B&gt;、&lt;B,E&gt;等。
如果从某个结点沿着树中的边可到达另一个结点，则称这两个结点间存在一条路径（Path），如结点A到结点J，存在路径{&lt;A,C&gt;，&lt;C,J&gt;}。
如果一个结点有子树，则称该结点为子树的双亲（Parent），子树的根称为该结点的孩子（Child），如结点A是结点B、C、D的双亲，而结点B、C、D是结点A的孩子。具有相同双亲的结点称为兄弟（Sibling），如结点B、C、D是兄弟。
结点拥有的子树数目称为结点的度（Degree），如结点A的度为3，结点D的度为0，结点J的度为0。
度为零的结点称为叶子(Leaf)。
规定根结点的层次为1，树中结点的最大层次称为该树的高度(Hight)，如图2所表示的树的高度为3。
如果树中结点的各子树是从左至右有次序的，则称该树为有序树，否则称为无序树。
二、二叉树 树结构和自然界的树一样，具有各种各样的形态，这样就使我们对树结构的研究比较困难。为此，我们首先研究最为常见的二叉树，以及二叉树的性质、存储结构和运算，然后给出二叉树和一般树之间的转换。
2.1二叉树的定义 二叉树（Binary Tree）是由有限个结点组成的集合，它或者为空集合，或者仅含一个根结点，或者由一个根结点和两棵互不相交的左、右子树组成。
上述定义表明，二叉树有如图3所示的五种基本形态。
图3 二叉树的基本形态 必须指出，树定义与二叉树定义稍有区别。首先，树不能是空树，却可以有空二叉树。其次，一般树的子树的不分次序，而二叉树的子树却分左、右子树，即使在仅有一棵子树的情况下也要指明是左子树还是右子树。最后，一般树中结点的度(子树数目)可以大于2，但二叉树中结点的度均不超过2。
2.2二叉树的性质 若二叉树高为h，树的结点总数为2^h-1，称此二叉树为满二叉树。如下图4
eg：如下图：h=3，那么结点总数7(包含根节点)
图4 满二叉树 【性质1】高度为h的二叉树的结点总数n&lt;=2^h-1。
这个性质很容易理解：
证明：对于高度为h的满二叉树，其结点总数为
它是高度为h的二叉树结点总数的最大值，故。
对于高度为h的二叉树，如果第1~h-1层构成满二叉树，而第h层的叶子结点严格按从左至右依次排列，称此二叉树为完全二叉树（如图5(a)所示）。
图5 完全二叉树与非完全二叉树 在图5(b)中，双亲结点C仅有右孩子G无左孩子，故它不是完全二叉树。
【性质2】对于含n(n&gt;=1)个结点的完全二叉树(区分满二叉树)，其高度h=[log2(n&#43;1)]。(向上取整)
eg：上述图a，n=6，那么h=[log2(6&#43;1)]=log2(8)=3
【性质3】对于一棵非空二叉树，如果度为0的结点数为，度为2的结点数为，则
=&#43;1。 （即零度结点数总比2度结点数大1）" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/3266d0c3d92dc07a93b10feb61ea07e0/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2021-09-22T22:54:02+08:00" />
<meta property="article:modified_time" content="2021-09-22T22:54:02+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">c&#43;&#43;数据结构之树</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <hr> 
<p id="main-toc"><strong>目录</strong></p> 
<p id="%E5%89%8D%E8%A8%80-toc" style="margin-left:0px;"><a href="#%E5%89%8D%E8%A8%80" rel="nofollow" title="前言">前言</a></p> 
<p id="%E4%B8%80%E3%80%81%E6%A0%91%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5-toc" style="margin-left:0px;"><a href="#%E4%B8%80%E3%80%81%E6%A0%91%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5" rel="nofollow" title="一、树的基本概念">一、树的基本概念</a></p> 
<p id="%C2%A01.1%E6%A0%91%E7%9A%84%E5%AE%9A%E4%B9%89-toc" style="margin-left:40px;"><a href="#%C2%A01.1%E6%A0%91%E7%9A%84%E5%AE%9A%E4%B9%89" rel="nofollow" title=" 1.1树的定义"> 1.1树的定义</a></p> 
<p id="1.2%E5%9F%BA%E6%9C%AC%E6%9C%AF%E8%AF%AD-toc" style="margin-left:40px;"><a href="#1.2%E5%9F%BA%E6%9C%AC%E6%9C%AF%E8%AF%AD" rel="nofollow" title="1.2基本术语">1.2基本术语</a></p> 
<p id="%E4%BA%8C%E3%80%81%E4%BA%8C%E5%8F%89%E6%A0%91-toc" style="margin-left:0px;"><a href="#%E4%BA%8C%E3%80%81%E4%BA%8C%E5%8F%89%E6%A0%91" rel="nofollow" title="二、二叉树">二、二叉树</a></p> 
<p id="2.1%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%AE%9A%E4%B9%89-toc" style="margin-left:40px;"><a href="#2.1%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%AE%9A%E4%B9%89" rel="nofollow" title="2.1二叉树的定义">2.1二叉树的定义</a></p> 
<p id="2.1%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%80%A7%E8%B4%A8-toc" style="margin-left:40px;"><a href="#2.1%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%80%A7%E8%B4%A8" rel="nofollow" title="2.2二叉树的性质">2.2二叉树的性质</a></p> 
<p id="2.3%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84ADT-toc" style="margin-left:40px;"><a href="#2.3%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84ADT" rel="nofollow" title="2.3二叉树的ADT">2.3二叉树的ADT</a></p> 
<p id="%C2%A0%E4%B8%89%E3%80%81%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%AD%98%E5%82%A8%E8%A1%A8%E7%A4%BA-toc" style="margin-left:0px;"><a href="#%C2%A0%E4%B8%89%E3%80%81%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%AD%98%E5%82%A8%E8%A1%A8%E7%A4%BA" rel="nofollow" title=" 三、二叉树的存储表示"> 三、二叉树的存储表示</a></p> 
<p id="3.1%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%95%B0%E7%BB%84%E8%A1%A8%E7%A4%BA-toc" style="margin-left:40px;"><a href="#3.1%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%95%B0%E7%BB%84%E8%A1%A8%E7%A4%BA" rel="nofollow" title="3.1二叉树的数组表示">3.1二叉树的数组表示</a></p> 
<p id="%C2%A03.2%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%93%BE%E8%A1%A8%E8%A1%A8%E7%A4%BA-toc" style="margin-left:40px;"><a href="#%C2%A03.2%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%93%BE%E8%A1%A8%E8%A1%A8%E7%A4%BA" rel="nofollow" title="3.2二叉树的链表表示">3.2二叉树的链表表示</a></p> 
<p id="%E5%9B%9B%E3%80%81%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%81%8D%E5%8E%86-toc" style="margin-left:0px;"><a href="#%E5%9B%9B%E3%80%81%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%81%8D%E5%8E%86" rel="nofollow" title="四、二叉树的遍历">四、二叉树的遍历</a></p> 
<p id="4.1%E5%89%8D%E5%BA%8F%E9%81%8D%E5%8E%86-toc" style="margin-left:40px;"><a href="#4.1%E5%89%8D%E5%BA%8F%E9%81%8D%E5%8E%86" rel="nofollow" title="4.1前序遍历">4.1前序遍历</a></p> 
<p id="4.2%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86-toc" style="margin-left:40px;"><a href="#4.2%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86" rel="nofollow" title="4.2中序遍历">4.2中序遍历</a></p> 
<p id="4.3%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86-toc" style="margin-left:40px;"><a href="#4.3%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86" rel="nofollow" title="4.3后序遍历">4.3后序遍历</a></p> 
<p id="%C2%A0%E4%BA%94%E3%80%81%E5%B8%B8%E7%94%A8%E4%BA%8C%E5%8F%89%E6%A0%91-toc" style="margin-left:0px;"><a href="#%C2%A0%E4%BA%94%E3%80%81%E5%B8%B8%E7%94%A8%E4%BA%8C%E5%8F%89%E6%A0%91" rel="nofollow" title=" 五、常用二叉树"> 五、常用二叉树</a></p> 
<p id="5.1%E6%8E%92%E5%BA%8F%E4%BA%8C%E5%8F%89%E6%A0%91-toc" style="margin-left:40px;"><a href="#5.1%E6%8E%92%E5%BA%8F%E4%BA%8C%E5%8F%89%E6%A0%91" rel="nofollow" title="5.1排序二叉树">5.1排序二叉树</a></p> 
<p id="%C2%A05.2%E5%93%88%E5%A4%AB%E6%9B%BC%E6%A0%91-toc" style="margin-left:40px;"><a href="#%C2%A05.2%E5%93%88%E5%A4%AB%E6%9B%BC%E6%A0%91" rel="nofollow" title="5.2哈夫曼树">5.2哈夫曼树</a></p> 
<p id="%E6%80%BB%E7%BB%93-toc" style="margin-left:0px;"><a href="#%E6%80%BB%E7%BB%93" rel="nofollow" title="总结">总结</a></p> 
<hr id="hr-toc"> 
<hr> 
<h2>前言</h2> 
<p><span style="color:#999aaa;">本文主要介绍的数据结构之树型结构的相关知识，树型数据结构是面试官面试的时候非常喜欢考的一种数据结构，树形结构的遍历也是大厂笔试非常喜欢设置的考点，这些内容都会在本篇文章中进行详细的介绍，并且还会介绍一些常用的算法。</span></p> 
<hr> 
<h2 id="%E4%B8%80%E3%80%81%E6%A0%91%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><a id="pandas_19"></a><br><br><br><br> 一、树的基本概念</h2> 
<p style="margin-left:.0001pt;text-align:justify;"><strong><strong>层次结构的数据在现实世界中大量存在。</strong></strong>例如，一个国家有若干省，一个省有若干市县，一个市县有若干区乡。又如，一本书包含若干章，一章包含若干节，一节包含若干段。例如，下图是数组的层次关系，这种描述树形数据的形式称为<strong><strong>倒置的树形表示法</strong></strong>。</p> 
<div style="text-align:center;"> 
 <figure class="image"> 
  <img alt="" height="181" src="https://images2.imgbox.com/1f/05/jcANjf9q_o.png" width="526"> 
  <figcaption>
    图1 数组的层次结构 
  </figcaption> 
 </figure> 
</div> 
<p> <strong>线性数据结构一般不适合用来表示层次数据</strong>。<strong>为了组织层次数据，需要对树形数据的结构进行研究。</strong></p> 
<h3 id="%C2%A01.1%E6%A0%91%E7%9A%84%E5%AE%9A%E4%B9%89"> 1.1树的定义</h3> 
<p style="margin-left:0;text-align:justify;">在上图1中，我们采用<strong>倒置树</strong>来描述树状结构。一棵倒置树的<strong>顶端是根</strong>，根有几个分枝，称为<strong>子树</strong>，每棵子树再分成几个小分枝，小分枝再分成更小的分枝，每个分枝也都是树，<strong>一个结点也是树</strong>。由此，<strong>我们可以给树下一个递归定义。</strong></p> 
<p style="margin-left:0;text-align:justify;"><strong>树</strong>（Tree）是包括n个<strong>结点</strong>的<strong>有限非空集合T</strong>，其中，一个特定的结点r称为<strong>根</strong>（Root），其余<strong>结点</strong>T-{r}划分成m个<strong>互不相交</strong>的子集T1，T2，Tm其中，<strong>每个子集都是树</strong>，称为树根r的<strong>子树</strong>。</p> 
<p style="margin-left:0;text-align:justify;">根据树的定义，<strong>一个结点的树</strong>是<strong>仅有根结点的树</strong>，这时m=0，这棵树没有子树。</p> 
<h3 id="1.2%E5%9F%BA%E6%9C%AC%E6%9C%AF%E8%AF%AD">1.2基本术语</h3> 
<p>图1可以抽象成图2，它形象地反映了<strong>树的逻辑结构</strong>。下面，参照图2，给出树结构讨论中常用的术语。</p> 
<h2 id="%E4%BA%8C%E3%80%81%E4%BD%BF%E7%94%A8%E6%AD%A5%E9%AA%A4"><a id="_26"></a><br><br><br><br><br><br><br><br>  </h2> 
<div style="text-align:center;"> 
 <figure class="image"> 
  <img alt="" height="142" src="https://images2.imgbox.com/22/37/PKXWHB7P_o.png" width="252"> 
  <figcaption>
    图2 树的逻辑结构 
  </figcaption> 
 </figure> 
</div> 
<p style="margin-left:0;text-align:justify;"> <strong>树中元素</strong>称为<strong>结点</strong>（Node），如A、B等。</p> 
<p style="margin-left:0;text-align:justify;">如果<strong>某结点</strong>到<strong>另一结点</strong>之间存在着连线，则称此连线为一条<strong>边</strong>（Edge），如<strong>&lt;A,B&gt;</strong><strong>、&lt;B,E&gt;</strong>等。</p> 
<p style="margin-left:0;text-align:justify;">如果从某个结点沿着树中的边可到达另一个结点，则称这两个结点间存在一条<strong>路径</strong>（Path），如结点A到结点J，存在<strong>路径</strong>{&lt;A,C&gt;，&lt;C,J&gt;}。</p> 
<p style="margin-left:0;text-align:justify;"><strong>如果一个结点有子树</strong>，则称该<strong>结点为</strong>子树的<strong>双亲</strong>（Parent），子树的根称为该结点的<strong>孩子</strong>（Child），如结点A是结点B、C、D的双亲，而结点B、C、D是结点A的孩子。具有相同双亲的结点称为<strong>兄弟</strong>（Sibling），如结点B、C、D是兄弟。</p> 
<p style="margin-left:0;text-align:justify;"><strong>结点</strong>拥有的<strong>子树数目</strong>称为<strong>结点的度</strong>（Degree），如结点A的度为3，结点D的度为0，结点J的度为0。</p> 
<p style="margin-left:0;text-align:justify;"><strong>度为零的结点</strong>称为<strong>叶子</strong>(Leaf)。</p> 
<p style="margin-left:0;text-align:justify;"><strong>规定</strong>根结点的层次为1，树中结点的最大层次称为该<strong>树的高度</strong><strong>(</strong>Hight<strong>)</strong>，如图2所表示的树的高度为3。</p> 
<p>如果树中结点的各子树是从左至右有次序的，则称该树为<strong>有序树</strong>，否则称为<strong>无序树</strong>。</p> 
<h2 id="%E4%BA%8C%E3%80%81%E4%BA%8C%E5%8F%89%E6%A0%91">二、二叉树</h2> 
<p style="margin-left:0;text-align:justify;">树结构和自然界的树一样，具有各种各样的形态，这样就使我们对树结构的研究比较困难。为此，我们首先<strong>研究最为常见的二叉树</strong>，以及<strong>二叉树的性质</strong>、<strong>存储结构和运算</strong>，然后给出<strong>二叉树和一般树之间的转换</strong>。</p> 
<h3 id="2.1%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%AE%9A%E4%B9%89" style="margin-left:0px;text-align:justify;">2.1二叉树的定义</h3> 
<p style="margin-left:0;text-align:justify;"><strong>二叉树</strong>（Binary Tree）是由有限个结点组成的集合，它或者为空集合，或者仅含一个根结点，或者由一个根结点和两棵互不相交的左、右子树组成。</p> 
<p style="margin-left:0;text-align:justify;">上述定义表明，二叉树有如图3所示的<strong>五种<u>基本</u>形态</strong>。</p> 
<div style="text-align:center;"> 
 <figure class="image"> 
  <img alt="" height="93" src="https://images2.imgbox.com/14/7c/suvbSAw8_o.png" width="281"> 
  <figcaption>
    图3 二叉树的基本形态 
  </figcaption> 
 </figure> 
</div> 
<p> <strong>必须指出，树定义与二叉树定义稍有区别。<span style="color:#ff0000;">首先</span></strong><strong>，树不能是空树，却可以有空二叉树。<span style="color:#ff0000;">其次</span></strong><strong>，一般树的子树的不分次序，而二叉树的子树却分左、右子树，即使在仅有一棵子树的情况下也要指明是左子树还是右子树。<span style="color:#ff0000;">最后</span></strong><strong>，一般树中结点的度(</strong><strong>子树数目)</strong><strong>可以大于2</strong><strong>，但二叉树中结点的度均不超过2</strong><strong>。</strong></p> 
<h3 id="2.1%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%80%A7%E8%B4%A8">2.2二叉树的性质</h3> 
<p> <strong>若</strong>二叉树高为h，树的<strong>结点总数</strong>为<strong>2^h-1</strong>，称此二叉树为<strong>满二叉树。</strong>如下图4</p> 
<p><strong>eg：如下图：h=3</strong><strong>，那么结点总数7(</strong><strong>包含根节点)</strong></p> 
<div style="text-align:center;"> 
 <figure class="image"> 
  <img alt="" height="132" src="https://images2.imgbox.com/3f/3a/bFbux3l0_o.png" width="177"> 
  <figcaption>
    图4 满二叉树 
  </figcaption> 
 </figure> 
</div> 
<p></p> 
<p> <strong>【性质1】</strong>高度为h的二叉树的<strong>结点总数n&lt;=2^h-1。</strong></p> 
<p><strong>这个性质很容易理解：<img alt="n=2^{0}+2^{1}+2^{2}+...+2^{h-1}=2^{h}-1" class="mathcode" src="https://images2.imgbox.com/58/f9/6Wc32Ve0_o.png"></strong></p> 
<p style="margin-left:0;text-align:justify;">证明：对于高度为h的满二叉树，其结点总数为</p> 
<p style="margin-left:0;text-align:justify;"><img alt="\sum_{i=1}^{h}=2^{h}-1" class="mathcode" src="https://images2.imgbox.com/ae/12/ZUzxD3vI_o.png"></p> 
<p style="margin-left:0;text-align:justify;">它是高度为h的二叉树结点总数的最大值，故<img alt="n\leq 2^{h}-1" class="mathcode" src="https://images2.imgbox.com/3a/76/kkFjPvdR_o.png">。</p> 
<p style="margin-left:0;text-align:justify;">对于高度为h的二叉树，如果第1~h-1层构成满二叉树，<strong>而第</strong><strong>h</strong><strong>层的叶子结点严格按从左至右依次排列</strong>，称此二叉树为<strong>完全二叉树</strong>（如图5(a)所示）。</p> 
<div style="text-align:center;"> 
 <figure class="image"> 
  <img alt="" height="155" src="https://images2.imgbox.com/67/eb/VmjeT3ol_o.png" width="378"> 
  <figcaption>
    图5 完全二叉树与非完全二叉树 
  </figcaption> 
 </figure> 
</div> 
<p> 在图5(b)中，双亲结点C仅有右孩子G无左孩子，故它不是完全二叉树。</p> 
<p style="margin-left:0;text-align:justify;"><strong>【性质2</strong><strong>】</strong>对于含n(n&gt;=1)个结点的<strong>完全二叉树</strong><strong>(</strong><strong>区分满二叉树)</strong>，其高度h=[log2(n+1)]。(<strong>向上取整)</strong></p> 
<p style="margin-left:0;text-align:justify;"><strong>eg</strong><strong>：上述图a</strong><strong>，n=6</strong><strong>，那么h=[log2(6+1)]=log2(8)=3</strong></p> 
<p style="margin-left:0;text-align:justify;"><strong>【性质3</strong><strong>】</strong>对于一棵<strong>非空二叉树</strong>，如果<strong>度为</strong><strong>0</strong>的结点数为<img alt="n_{0}" class="mathcode" src="https://images2.imgbox.com/de/af/DWDLPgZT_o.png">，<strong>度为</strong><strong>2</strong>的结点数为<img alt="n_{2}" class="mathcode" src="https://images2.imgbox.com/05/e1/CTraIDnO_o.png">，则</p> 
<p><img alt="n_{0}" class="mathcode" src="https://images2.imgbox.com/53/c5/jkSTBw7V_o.png">=<img alt="n_{2}" class="mathcode" src="https://images2.imgbox.com/02/73/tfR5kGnl_o.png">+1。 <strong>（即零度结点数总比2</strong><strong>度结点数大1</strong><strong>）</strong></p> 
<p style="margin-left:0;text-align:justify;">证 设二叉树的结点数为n，度为1的结点数为n1，边数为e，则</p> 
<p style="margin-left:0;text-align:justify;">e=n-1，e=2*n2+n1，n=n0+n1+n2</p> 
<p style="margin-left:0;text-align:justify;"><strong>边数等于结点数n-1 </strong><strong>，等于2倍的</strong><strong>度为2</strong><strong>的结点数+</strong><strong>度为1</strong><strong>的结点数。</strong></p> 
<p style="margin-left:0;text-align:justify;"><strong>画个树的逻辑结构图就很容易看出来。</strong></p> 
<p style="margin-left:0;text-align:justify;">于是n0=n2+1。</p> 
<p style="margin-left:0;text-align:justify;"><strong>【性质4</strong><strong>】</strong>对于含个结点的<strong>完全二叉树</strong>(<strong>区分满二叉树</strong>)，按<strong>从上到下、从左到右</strong>的顺序，从0到n-1编号（如图6所示）。对于树中编号为i（0=&lt;i&lt;=n-1）的结点，有</p> 
<p style="margin-left:0;text-align:justify;">（1）如果i=0，则该结点为二叉树的根；</p> 
<p style="margin-left:0;text-align:justify;">（2）如果2*i+1&lt;n，则<strong>其</strong>左孩子为2*i+1，否则不存在左孩子；</p> 
<p style="margin-left:0;text-align:justify;">         如果2*i+2&lt;n，则<strong>其</strong>右孩子为2*i+2，否则不存在右孩子；</p> 
<p style="margin-left:0;text-align:justify;">（3）结点的<strong>双亲</strong>为[(i-1)/2]向下取整。<strong>(</strong><strong>求双亲注意双亲只有一个)</strong></p> 
<div style="text-align:center;"> 
 <figure class="image"> 
  <img alt="" height="134" src="https://images2.imgbox.com/bd/06/dwc3cggW_o.png" width="394"> 
  <figcaption>
    图6 带序号的完全二叉树 
   <br>   
  </figcaption> 
 </figure> 
</div> 
<h3 id="2.3%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84ADT">2.3二叉树的ADT</h3> 
<p style="margin-left:0;text-align:justify;">ADT BinTree</p> 
<p style="margin-left:0;text-align:justify;">数据：</p> 
<p style="margin-left:0;text-align:justify;"><strong>        0个或有限个结点组成的集合。</strong></p> 
<p style="margin-left:0;text-align:justify;">运算：</p> 
<table cellspacing="0" style="margin-left:42pt;width:502pt;"><tbody><tr><td style="vertical-align:top;width:106.9pt;"> <p style="margin-left:0;text-align:justify;">Create()</p> </td><td style="vertical-align:top;width:395.1pt;"> <p style="margin-left:0;text-align:justify;">创建一棵空二叉树或二叉树。</p> </td></tr><tr><td style="vertical-align:top;width:106.9pt;"> <p style="margin-left:0;text-align:justify;">IsEmpty()</p> </td><td style="vertical-align:top;width:395.1pt;"> <p style="margin-left:0;text-align:justify;">若二叉树为空，则返回1，否则返回0。</p> </td></tr><tr><td style="vertical-align:top;width:106.9pt;"> <p style="margin-left:0;text-align:justify;">PreOrder()</p> </td><td style="vertical-align:top;width:395.1pt;"> <p style="margin-left:0;text-align:justify;">前序遍历二叉树。</p> </td></tr><tr><td style="vertical-align:top;width:106.9pt;"> <p style="margin-left:0;text-align:justify;">InOrder()</p> </td><td style="vertical-align:top;width:395.1pt;"> <p style="margin-left:0;text-align:justify;">中序遍历二叉树。</p> </td></tr><tr><td style="vertical-align:top;width:106.9pt;"> <p style="margin-left:0;text-align:justify;">PostOrder()</p> </td><td style="vertical-align:top;width:395.1pt;"> <p style="margin-left:0;text-align:justify;">后序遍历二叉树。</p> </td></tr><tr><td style="vertical-align:top;width:106.9pt;"> <p style="margin-left:0;text-align:justify;">Display():</p> </td><td style="vertical-align:top;width:395.1pt;"> <p style="margin-left:0;text-align:justify;">输出二叉树。</p> </td></tr></tbody></table> 
<h2 id="%C2%A0%E4%B8%89%E3%80%81%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%AD%98%E5%82%A8%E8%A1%A8%E7%A4%BA"> 三、二叉树的存储表示</h2> 
<h3 id="3.1%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%95%B0%E7%BB%84%E8%A1%A8%E7%A4%BA">3.1二叉树的数组表示</h3> 
<p style="margin-left:0;text-align:justify;">       用一维数组来存储二叉树，首先将二叉树<strong>想象</strong>成一棵<strong>完全二叉树</strong>，对于没有左孩子或右孩子的结点，用特殊字符（或数字）替代，再依从上至下、从左至右的次序，依次将结点值存放到一维数组之中。</p> 
<p style="margin-left:0;text-align:justify;">【例1】：将图7(a)所示的二叉树，用一维字符数组表示。</p> 
<div style="text-align:center;"> 
 <figure class="image"> 
  <img alt="" height="200" src="https://images2.imgbox.com/8b/68/364JSyE9_o.png" width="374"> 
  <figcaption>
    图7 字符型非完全二叉树的完全二叉树表示 
  </figcaption> 
 </figure> 
</div> 
<p></p> 
<p style="margin-left:0;text-align:justify;">解：</p> 
<p style="margin-left:0;text-align:justify;">首先将图7(a)所示的二叉树，想象成一棵<strong>完全二叉树</strong>（如图7(b)所示），再用表8-1所示的一维字符型数组存储。</p> 
<p style="margin-left:0;text-align:justify;">表8-1</p> 
<table cellspacing="0" style="margin-left:10.5pt;"><tbody><tr><td style="vertical-align:top;width:47.3pt;"> <p style="margin-left:0;text-align:justify;">元素值</p> </td><td style="vertical-align:top;width:1cm;"> <p style="margin-left:0;text-align:justify;">A</p> </td><td style="vertical-align:top;width:1cm;"> <p style="margin-left:0;text-align:justify;">B</p> </td><td style="vertical-align:top;width:1cm;"> <p style="margin-left:0;text-align:justify;">C</p> </td><td style="vertical-align:top;width:1cm;"> <p style="margin-left:0;text-align:justify;">*</p> </td><td style="vertical-align:top;width:1cm;"> <p style="margin-left:0;text-align:justify;">E</p> </td><td style="vertical-align:top;width:1cm;"> <p style="margin-left:0;text-align:justify;">*</p> </td><td style="vertical-align:top;width:1cm;"> <p style="margin-left:0;text-align:justify;">*</p> </td><td style="vertical-align:top;width:1cm;"> <p style="margin-left:0;text-align:justify;">*</p> </td><td style="vertical-align:top;width:1cm;"> <p style="margin-left:0;text-align:justify;">*</p> </td><td style="vertical-align:top;width:1cm;"> <p style="margin-left:0;text-align:justify;">*</p> </td><td style="vertical-align:top;width:1cm;"> <p style="margin-left:0;text-align:justify;">K</p> </td><td style="vertical-align:top;width:1cm;"> <p style="margin-left:0;text-align:justify;">\0</p> </td></tr><tr><td style="vertical-align:top;width:47.3pt;"> <p style="margin-left:0;text-align:justify;">下 标</p> </td><td style="vertical-align:top;width:1cm;"> <p style="margin-left:0;text-align:justify;">0</p> </td><td style="vertical-align:top;width:1cm;"> <p style="margin-left:0;text-align:justify;">1</p> </td><td style="vertical-align:top;width:1cm;"> <p style="margin-left:0;text-align:justify;">2</p> </td><td style="vertical-align:top;width:1cm;"> <p style="margin-left:0;text-align:justify;">3</p> </td><td style="vertical-align:top;width:1cm;"> <p style="margin-left:0;text-align:justify;">4</p> </td><td style="vertical-align:top;width:1cm;"> <p style="margin-left:0;text-align:justify;">5</p> </td><td style="vertical-align:top;width:1cm;"> <p style="margin-left:0;text-align:justify;">6</p> </td><td style="vertical-align:top;width:1cm;"> <p style="margin-left:0;text-align:justify;">7</p> </td><td style="vertical-align:top;width:1cm;"> <p style="margin-left:0;text-align:justify;">8</p> </td><td style="vertical-align:top;width:1cm;"> <p style="margin-left:0;text-align:justify;">9</p> </td><td style="vertical-align:top;width:1cm;"> <p style="margin-left:0;text-align:justify;">10</p> </td><td style="vertical-align:top;width:1cm;"> <p style="margin-left:0;text-align:justify;">1</p> </td></tr></tbody></table> 
<p style="margin-left:0;text-align:justify;">这种表示法的实现程序如下：<span style="color:#ffffff;">示法的实现程序如下：</span></p> 
<p></p> 
<pre><code class="language-cpp">#include&lt;iostream&gt;
#include&lt;cmath&gt;
using namespace std;
#define MaxSize 64//为了树的显示效果,结点数不超过63,即二叉树高不超过6
//创建二叉树
void Create(char Node[], int&amp; n)
{
	cout &lt;&lt; "按完全二叉树输入结点字符,空字符用*替代" &lt;&lt; endl;
	cin &gt;&gt; Node;
	//计算字符数组含字符个数
	n = 0;
	while (Node[n] != '\0')//当Node[n]不等于结束符时
		n++;
}
//输出二叉树
void Display(char Node[], int n)
{
	int hight, layer, num; //hight树高,layer树层,num结点编号
	hight = ceil(log(n + 1) / log(2));//确定完全二叉树高度
	//求下限接近整数ceil//自然对数 log//求上限接近整数 floor
	cout &lt;&lt; hight &lt;&lt; endl;
	num = 0;//从结点Node[0]开始输出
	for (layer = 1; layer &lt;= hight; layer++)//输出1层—hight层
	{	//每层前面空格的输出控制
		for (int i = 1; i &lt;= pow(2, hight - layer)-1; i++)
			cout &lt;&lt; " ";
		//每层结点的输出控制
		for (int j = 1; j &lt;= pow(2, layer - 1); j++, num++)
		{
			if (Node[num] != '*' &amp;&amp; Node[num] != '\0')
				cout &lt;&lt; Node[num];//遇到结点,输出结点
			else if (Node[num] == '*')
				cout &lt;&lt; " ";//遇到*号,输出空格
			else
				break;//遇到结束符,跳出输出
			//每层结点间空格的输出控制
			for (int k = 1; k &lt;= pow(2, hight - layer + 1) - 1; k++)
				cout &lt;&lt; " ";
		}
		cout &lt;&lt; endl;//输完一层,换行
	}
}
//主函数
void main()
{
	int n;//完全二叉树所含结点数
	char Node[MaxSize];//定义字符型的结点数组
	Create(Node, n);//创建二叉树结点的一维数组
	cout &lt;&lt; "二叉树为" &lt;&lt; endl;
	Display(Node, n);//输出二叉树
}
</code></pre> 
<h3 id="2.%E8%AF%BB%E5%85%A5%E6%95%B0%E6%8D%AE"><a id="2_45"></a></h3> 
<div style="text-align:center;"> 
 <figure class="image"> 
  <img alt="" height="148" src="https://images2.imgbox.com/6b/f1/7cBRcNh7_o.png" width="490"> 
  <figcaption>
    图8 
  </figcaption> 
 </figure> 
</div> 
<p></p> 
<p style="margin-left:0;text-align:justify;">程序运行的结果如图8所示：</p> 
<p style="margin-left:0;text-align:justify;">创建这棵5结点二叉树，用了6颗星号替代缺失的左、右孩子，这显然是这种表示法的一个缺点。</p> 
<p style="margin-left:0;text-align:justify;">但当二叉树为完全二叉树时，该表示法具有建树简便，输出直观的优点。</p> 
<h3 id="%C2%A03.2%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%93%BE%E8%A1%A8%E8%A1%A8%E7%A4%BA">3.2二叉树的链表表示</h3> 
<p> 用一维数组表示的二叉树，不便实现二叉树的一些规定运算。<strong>因此，二叉树一般采用链表来创建</strong>。</p> 
<p style="margin-left:0;text-align:justify;">链式二叉树结点的逻辑结构如图9所示，其中，data用来存储结点值，*lChild、*rChild分别用来存储左、右孩子的地址。</p> 
<p></p> 
<div style="text-align:center;"> 
 <figure class="image"> 
  <img alt="" height="42" src="https://images2.imgbox.com/b2/47/luPTu3zd_o.png" width="189"> 
  <figcaption>
    图9 树节点的逻辑结构 
  </figcaption> 
 </figure> 
</div> 
<p> 【例2】创建图7(a)所示的链式二叉树。</p> 
<p> 用链表表示图7(a)，其逻辑结构如图10所示，其中<strong>Λ</strong><strong>代表NULL</strong>。</p> 
<div style="text-align:center;"> 
 <figure class="image"> 
  <img alt="" height="139" src="https://images2.imgbox.com/0f/3a/SKgR6i68_o.png" width="260"> 
  <figcaption>
    图10 链式二叉树的逻辑结构 
  </figcaption> 
 </figure> 
</div> 
<p> <strong>具体的创建过程如下：</strong></p> 
<p style="margin-left:0;text-align:justify;">（1）首先创建<strong>第</strong><strong>4</strong><strong>层</strong>结点，并用结点指针Kp指向其根结点，如图11所示。</p> 
<div style="text-align:center;"> 
 <figure class="image"> 
  <img alt="" height="99" src="https://images2.imgbox.com/d0/92/BmHIIHl0_o.png" width="141"> 
  <figcaption>
    图11 
  </figcaption> 
 </figure> 
</div> 
<p>（2）再创建<strong>第</strong><strong>3</strong><strong>层</strong>结点，并用结点指针Ep指向其根结点<strong>，</strong>如图12所示。</p> 
<p></p> 
<div style="text-align:center;"> 
 <figure class="image"> 
  <img alt="" height="97" src="https://images2.imgbox.com/d2/51/6KyLvfwg_o.png" width="137"> 
  <figcaption>
    图12 
  </figcaption> 
 </figure> 
</div> 
<p>（3）再创建<strong>第</strong><strong>2</strong><strong>层</strong>结点，并用结点指针Bp、Cp分别指向其根结点，如图13所示。</p> 
<div style="text-align:center;"> 
 <figure class="image"> 
  <img alt="" height="95" src="https://images2.imgbox.com/3a/b5/qp6xCPpJ_o.png" width="322"> 
  <figcaption>
    图13 
  </figcaption> 
 </figure> 
</div> 
<p>（4）最后创建<strong>第</strong><strong>1</strong><strong>层</strong>结点，并用结点指针Ap指向其根结点，如图14所示。</p> 
<div style="text-align:center;"> 
 <figure class="image"> 
  <img alt="" height="95" src="https://images2.imgbox.com/7f/7f/oKCPsfXB_o.png" width="134"> 
  <figcaption>
    图14 
  </figcaption> 
 </figure> 
</div> 
<p> 如果用程序来描述上述过程，其程序如下：</p> 
<pre><code class="language-cpp">#include&lt;iostream&gt;
using namespace std;
//二叉树结点定义
struct Node
{	char data;//数据域
	Node *lChild,*rChild;//指针域
};
//二叉树定义
struct BinTree
{	Node *root;};
//创建二叉树
void Create(BinTree &amp;T,char x,Node *left,Node *right)
{	Node *NewNode;//新结点
	NewNode=new Node;//为新结点申请内存
	NewNode-&gt;data=x;//为新结点数据域赋值
	NewNode-&gt;lChild=left;//为新结点左指针域赋值
	NewNode-&gt;rChild=right;//为新结点右指针域赋值
	T.root=NewNode;//让新结点成为该子树根结点
}
//主函数
void main()
{	BinTree K,E,B,C,A;
	Create(K,'K',NULL,NULL);//创建结点K的子树
	Create(E,'E',NULL,K.root);//创建结点E的子树
	Create(B,'B',NULL,E.root);//创建结点B的子树
	Create(C,'C',NULL,NULL);//创建结点C的子树
	Create(A,'A',B.root,C.root);//创建结点A的子树
}
</code></pre> 
<p> 上述链式二叉树的创建过程是，先创建最底层的叶子结点，然后向上逐层创建子树，直至最顶层的根结点。<strong>该方法的优点是直观易懂，缺点是无法给出通用程序。</strong>一般链式二叉树的创建方法与通用程序如下。</p> 
<p style="margin-left:0;text-align:justify;">用广义表构建二叉树。</p> 
<p style="margin-left:0;text-align:justify;"><strong>1. </strong><strong>二叉树的广义表表示法</strong></p> 
<p style="margin-left:0;text-align:justify;">尽管构建二叉树的方法并不复杂，但对于结点多、结构复杂的二叉树，却不易用程序来实现。因此，有必要寻找更具一般性的二叉树的构建方法。</p> 
<p style="margin-left:0;text-align:justify;">图1所示的二叉树，可以用以下方式重新表示它。</p> 
<div style="text-align:center;"> 
 <figure class="image"> 
  <img alt="" height="178" src="https://images2.imgbox.com/53/1a/n2Kkq9Da_o.png" width="96"> 
  <figcaption>
    图1 
  </figcaption> 
 </figure> 
</div> 
<p></p> 
<p></p> 
<p style="margin-left:0;text-align:justify;">用A(B)表示A有左孩子B，无右孩子；</p> 
<p style="margin-left:0;text-align:justify;">用B(C,D)表示B有左孩子C，右孩子D；</p> 
<p style="margin-left:0;text-align:justify;">用C(,E)表示C无左孩子，但有右孩子E；</p> 
<p style="margin-left:0;text-align:justify;">用D(F,G)表示D有左孩子F，右孩子G。</p> 
<p style="margin-left:0;text-align:justify;">将它们复合起来，有A(B(C(,E),D(F,G)))。这是一个字符数组，它是上述二叉树的另一种表示法，称这种二叉树的表示法为广义表法。</p> 
<p style="margin-left:0;text-align:justify;">用广义表来表示二叉树，其具体规定如下：</p> 
<p style="margin-left:0;text-align:justify;">树的根结点放在最前面。</p> 
<p style="margin-left:0;text-align:justify;">每个结点的左子树和右子树用逗号隔开。若仅有左子树没有右子树，逗号可省略；若仅有右子树没有左子树，逗号不能省略。</p> 
<p style="margin-left:0;text-align:justify;">约定，广义表用字符型数组GenList[]来存储。</p> 
<p style="margin-left:0;text-align:justify;"><strong>2. </strong><strong>广义表构建二叉树的算法</strong></p> 
<p style="margin-left:0;text-align:justify;">设结点值均用字母来替代，先建一棵空二叉树T，借助一个简易结点顺序栈stack，广义表A(B(C(,E),D(F,G)))创建二叉树的具体过程如下：</p> 
<p style="margin-left:0;text-align:justify;">（1）读A，创建新结点A，T为空，让T.root=A结点。</p> 
<p style="margin-left:0;text-align:justify;">（2）读（，让新结点A入栈，置k=1，栈stack状态为：</p> 
<table border="1" cellspacing="0" style="margin-left:42pt;"><tbody><tr><td style="border-color:#000000;vertical-align:top;width:1cm;"> <p style="margin-left:0;text-align:center;">A</p> </td><td style="vertical-align:top;width:4cm;"> <p style="margin-left:0;text-align:justify;"></p> </td></tr></tbody></table> 
<p style="margin-left:0;text-align:justify;">（3）读B，创建新结点B，因k=1，让栈顶结点A的左指针指向B，即B←A。</p> 
<p style="margin-left:0;text-align:justify;">（4）读（，让新结点B入栈，置k=1，栈stack状态为：</p> 
<table border="1" cellspacing="0" style="margin-left:42pt;"><tbody><tr><td style="border-color:#000000;vertical-align:top;width:1cm;"> <p style="margin-left:0;text-align:center;">A</p> </td><td style="vertical-align:top;width:1cm;"> <p style="margin-left:0;text-align:center;">B</p> </td><td style="vertical-align:top;width:3cm;"> <p style="margin-left:0;text-align:justify;"></p> </td></tr></tbody></table> 
<p style="margin-left:0;text-align:justify;">（5）读C，创建新结点C，因k=1，让栈顶结点B的左指针指向C，即C←B。</p> 
<p style="margin-left:0;text-align:justify;">（6）读（，让新结点C入栈，置k=1，栈stack状态为：</p> 
<table border="1" cellspacing="0" style="margin-left:42pt;"><tbody><tr><td style="border-color:#000000;vertical-align:top;width:1cm;"> <p style="margin-left:0;text-align:center;">A</p> </td><td style="border-color:#000000;vertical-align:top;width:1cm;"> <p style="margin-left:0;text-align:center;">B</p> </td><td style="vertical-align:top;width:1cm;"> <p style="margin-left:0;text-align:center;">C</p> </td><td style="vertical-align:top;width:2cm;"> <p style="margin-left:0;text-align:justify;"></p> </td></tr></tbody></table> 
<p style="margin-left:0;text-align:justify;">（7）读，号，置k=2。</p> 
<p style="margin-left:0;text-align:justify;">（8）读E，创建新结点E，因k=2，让栈顶结点C的右指针指向E，即C→E。</p> 
<p style="margin-left:0;text-align:justify;">（9）读），栈顶结点C出栈，栈stack状态为：</p> 
<table border="1" cellspacing="0" style="margin-left:42pt;"><tbody><tr><td style="border-color:#000000;vertical-align:top;width:1cm;"> <p style="margin-left:0;text-align:center;">A</p> </td><td style="vertical-align:top;width:1cm;"> <p style="margin-left:0;text-align:center;">B</p> </td><td style="vertical-align:top;width:3cm;"> <p style="margin-left:0;text-align:justify;"></p> </td></tr></tbody></table> 
<p style="margin-left:0;text-align:justify;">（10）读，号，置k=2。</p> 
<p style="margin-left:0;text-align:justify;">（11）读D，创建新结点D，因k=2，让栈顶结点B的右指针指向D，即B→D。</p> 
<p style="margin-left:0;text-align:justify;">（12）读（，让新结点D入栈，置k=1，栈stack状态为：</p> 
<table border="1" cellspacing="0" style="margin-left:42pt;"><tbody><tr><td style="border-color:#000000;vertical-align:top;width:1cm;"> <p style="margin-left:0;text-align:center;">A</p> </td><td style="border-color:#000000;vertical-align:top;width:1cm;"> <p style="margin-left:0;text-align:center;">B</p> </td><td style="vertical-align:top;width:1cm;"> <p style="margin-left:0;text-align:center;">D</p> </td><td style="vertical-align:top;width:2cm;"> <p style="margin-left:0;text-align:justify;"></p> </td></tr></tbody></table> 
<p style="margin-left:0;text-align:justify;">（13）读F，创建新结点F，因k=1，让栈顶结点D的左指针指向F，即F←D。</p> 
<p style="margin-left:0;text-align:justify;">（14）读，号，置k=2。</p> 
<p style="margin-left:0;text-align:justify;">（15）读G，创建新结点G，因k=2，让栈顶结点D的右指针指向G，即D→G。</p> 
<p style="margin-left:0;text-align:justify;">（16）读），栈顶结点D出栈，栈stack状态为：</p> 
<table border="1" cellspacing="0" style="margin-left:42pt;"><tbody><tr><td style="border-color:#000000;vertical-align:top;width:1cm;"> <p style="margin-left:0;text-align:center;">A</p> </td><td style="vertical-align:top;width:1cm;"> <p style="margin-left:0;text-align:center;">B</p> </td><td style="vertical-align:top;width:3cm;"> <p style="margin-left:0;text-align:justify;"></p> </td></tr></tbody></table> 
<p style="margin-left:0;text-align:justify;">（17）读），栈顶结点B出栈，栈stack状态为：</p> 
<table border="1" cellspacing="0" style="margin-left:42pt;"><tbody><tr><td style="border-color:#000000;vertical-align:top;width:1cm;"> <p style="margin-left:0;text-align:center;">A</p> </td><td style="vertical-align:top;width:4cm;"> <p style="margin-left:0;text-align:justify;"></p> </td></tr></tbody></table> 
<p style="margin-left:0;text-align:justify;">（18）读），栈顶结点A出栈，栈stack状态为：</p> 
<table border="1" cellspacing="0" style="margin-left:42pt;"><tbody><tr><td style="border-color:#000000;vertical-align:top;width:5cm;"> <p style="margin-left:0;text-align:justify;"></p> </td></tr></tbody></table> 
<p style="margin-left:0;text-align:justify;">至此，二叉树创建完毕。</p> 
<p style="margin-left:0;text-align:justify;">由T.root=A，B←A，C←B，C→E，可构建如下图2所示的二叉树。</p> 
<div style="text-align:center;"> 
 <figure class="image"> 
  <img alt="" height="212" src="https://images2.imgbox.com/f9/53/8Qcvvsk1_o.png" width="356"> 
  <figcaption>
    图2 二叉树的构建过程1 
  </figcaption> 
 </figure> 
</div> 
<p> 由B→D，F←D，D→G，可构建如图3所示的二叉树。</p> 
<div style="text-align:center;"> 
 <figure class="image"> 
  <img alt="" height="209" src="https://images2.imgbox.com/c9/ce/nFwq6IDQ_o.png" width="348"> 
  <figcaption>
    图3 二叉树的构建过程2 
  </figcaption> 
 </figure> 
</div> 
<p> <strong>3. </strong><strong>广义表构建二叉树算法的程序实现</strong></p> 
<pre><code class="language-cpp">#include&lt;iostream&gt;
using namespace std;
#define MaxSize 100//顺序栈的最大容量
//结点定义
struct Node
{	char data;//数据域
	Node *lChild,*rChild;//指针域
};
//二叉树定义
struct BinTree
{	Node *root;};
//创建空二叉树
void Create(BinTree &amp;T)
{	T.root=NULL;}
//树判空
int IsEmpty(BinTree T)
{	if(T.root==NULL) return 1;
	else return 0;
}
//广义表创建二叉树
void Create(char GenList[],BinTree &amp;T)
{	Node *stack[MaxSize],*NewNode,*p;//简易结点顺序栈,新结点,探测指针
	int top=-1;//置栈空
	int k,i=0;//k=1链接左子树,k=2链接右子树,i广义表字符下标
	char ch;
	do
	{	ch=GenList[i];//读取广义表第i个字符
		switch(ch)
		{	case '('://读到左括号
				stack[++top]=NewNode;//新结点入栈
				k=1;break;
			case ')'://读到右括号
				top--;break;//栈顶结点出栈
			case ','://读到逗号
				k=2;break;
			default://读到字符
				NewNode=new Node;//新结点申请内存
				NewNode-&gt;data=ch;//新结点数据域赋值
				NewNode-&gt;lChild=NULL;//新结点左指针域赋值
				NewNode-&gt;rChild=NULL;//新结点右指针域赋值
				if(IsEmpty(T))//如果树为空
					T.root=NewNode;//新结点作为根结点
				if(k==1)
				{	p=stack[top];//获取栈顶结点
					p-&gt;lChild=NewNode;//让栈顶结点左孩子指向新结点
				}
				else if(k==2)
				{	p=stack[top];//获取栈顶结点
					p-&gt;rChild=NewNode;//让栈顶结点左孩子指向新结点
				}
		}
		i++;//i增1
	}while(GenList[i]!='\0');//逐一读完整个广义表
}
//非递归前序遍历算法
void PreOrder(Node *p)
{	Node *stack[MaxSize];// 简易结点顺序栈
	int top=-1;//置栈空
	while(p||top!=-1)//当p结点所指非空或栈非空时
	{	if(p)//如果p所指结点非空
		{	cout&lt;&lt;p-&gt;data;//输出p的值
			stack[++top]=p;//p所指结点入栈
			p=p-&gt;lChild;//p向左下移
		}
		else//如果p结点所指结点为空
		{	p=stack[top--];//p指向栈顶结点,栈顶结点出栈
			p=p-&gt;rChild;//p向右下移
		}
	}
}
//非递归中序遍历算法
void InOrder(Node *p)
{	Node *stack[MaxSize];//简易结点顺序栈
	int top=-1;//置栈空
	while(p||top!=-1)//当p结点所指非空或栈非空时
	{	if(p)//如果p所指结点非空
		{	stack[++top]=p;//p所指结点入栈
			p=p-&gt;lChild;//p向左下移
		}
		else//如果p所指结点为空
		{	p=stack[top--];//p指向栈顶结点,栈顶结点出栈
			cout&lt;&lt;p-&gt;data;//输出p的值
			p=p-&gt;rChild;//p向右下移
		}
	}
}
//主函数
void main()
{	char GenList[]="A(B(C(,E),D(F,G)))";//定义广义表
	BinTree T;//定义二叉树
	Create(T);//创建空二叉树
	Create(GenList,T); //创建二叉树
	cout&lt;&lt;"前序遍历为 "; PreOrder(T.root); cout&lt;&lt;endl;
	cout&lt;&lt;"中序遍历为 "; InOrder(T.root); cout&lt;&lt;endl;
}
</code></pre> 
<p> 程序运行的结果如图4所示。</p> 
<div style="text-align:center;"> 
 <figure class="image"> 
  <img alt="" height="110" src="https://images2.imgbox.com/2d/be/Ay7YGziP_o.png" width="468"> 
  <figcaption>
    图4 
  </figcaption> 
 </figure> 
</div> 
<h2 id="%E5%9B%9B%E3%80%81%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%81%8D%E5%8E%86">四、二叉树的遍历</h2> 
<p style="margin-left:0;text-align:justify;">欲在屏幕上形象地输出链式二叉树<strong>是一件困难的事</strong>，<strong>一般采用输出它的三个线性序列</strong><strong>VLR</strong><strong>、LVR</strong><strong>和LRV</strong><strong>的方式</strong>，来解决这一问题。</p> 
<p style="margin-left:0;text-align:justify;">VLR称为<strong>前序（</strong><strong>PreOrder</strong><strong>）遍历序列</strong>，它是按先树根，再左子树，后右子树的次序，输出二叉树的结点值。</p> 
<p style="margin-left:0;text-align:justify;">LVR称为<strong>中序（</strong><strong>InOrder</strong><strong>）遍历序列</strong>，它是按先左子树，再树根，后右子树的次序，输出二叉树的结点值。</p> 
<p style="margin-left:0;text-align:justify;">LRV称为<strong>后序（</strong><strong>PostOrder</strong><strong>）遍历序列</strong>，它是按先左子树，再右子树，后树根的次序，输出二叉树的结点值。</p> 
<p style="margin-left:0;text-align:justify;"><strong>所谓前序、中序和后序遍历，是相对于根结点位置而言的。</strong>例如，在中序遍历中，根结点在中间；而前序遍历是根结点在前面，后序遍历是根结点在后面。<strong>三种遍历方式一定是先左子树后右子树。</strong></p> 
<h3 id="4.1%E5%89%8D%E5%BA%8F%E9%81%8D%E5%8E%86" style="margin-left:0px;text-align:justify;"><strong>4.1前序遍历</strong></h3> 
<p style="margin-left:0;text-align:justify;">前序遍历的次序为：<strong>树根—左子树—右子树</strong>，即<strong>从根结点开始处理，根结点处理完后往左子树走，直到无法前进再处理右子树。</strong></p> 
<div style="text-align:center;"> 
 <figure class="image"> 
  <img alt="" height="139" src="https://images2.imgbox.com/55/81/u7ZYUBWp_o.png" width="260"> 
  <figcaption>
    图10 链式二叉树的逻辑结构 
  </figcaption> 
 </figure> 
</div> 
<p style="margin-left:0;text-align:justify;">【例2】的前序遍历为<strong>ABEKC</strong>，<strong>前序遍历的递归算法</strong>如下：</p> 
<pre><code class="language-cpp">void PreOrder(Node *p)
{	if(p!=NULL)
	{	cout&lt;&lt;p-&gt;data;//访问树根
		PreOrder(p-&gt;lChild);//遍历左子树
		PreOrder(p-&gt;rChild); //遍历右子树
	}
}
</code></pre> 
<h3 id="4.2%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86" style="margin-left:0px;text-align:justify;"><a name="_Toc426280162"></a><br><br><br><br><br> 4.2中序遍历</h3> 
<p style="margin-left:0;text-align:justify;">中序遍历的次序为：<strong>左子树—树根—右子树</strong>，即<strong>沿树的左子树一直往下，直到无法前进时后退到双亲结点，而后再沿右子树一直往下</strong>。<strong>如果右子树也走完了就退回上层的左结点，重复左、中、右的顺序遍历。</strong></p> 
<p style="margin-left:0;text-align:justify;">【例2】的中序遍历为<strong>BEKAC</strong>，中序遍历的递归算法如下：</p> 
<pre><code class="language-cpp">void InOrder(Node *p)
{	if(p!=NULL)
	{	InOrder(p-&gt;lChild); //遍历左子树
		cout&lt;&lt;p-&gt;data; //访问树根
		InOrder(p-&gt;rChild);//遍历右子树
	}
}
</code></pre> 
<h3 id="4.3%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86">4.3后序遍历</h3> 
<p style="margin-left:0;text-align:justify;">后序遍历的顺序为：<strong>左子树—右子树—树根</strong>。<strong>后序遍历和前序遍历相反，它是把左、右子树的结点都处理完才处理树根</strong>。</p> 
<p style="margin-left:0;text-align:justify;">【例2】的后序遍历为KEBCA，后序遍历的递归算法如下：</p> 
<pre><code class="language-cpp">void PostOrder(Node *p)
{	if(p!=NULL)
	{	PostOrder(p-&gt;lChild);//遍历左子树
		PostOrder(p-&gt;rChild); //遍历右子树
		cout&lt;&lt;p-&gt;data; //访问树根
	}
}
</code></pre> 
<p style="margin-left:0;text-align:justify;">【例3】给出【例2】所创建的链式二叉树的前序、中序和后序遍历。</p> 
<pre><code class="language-cpp">#include&lt;iostream&gt;
using namespace std;
//二叉树结点定义
struct Node
{
	char data;//数据域
	Node* lChild, * rChild;//指针域
};
//二叉树定义
struct BinTree
{
	Node* root;
};
//创建二叉树
void Create(BinTree&amp; T, char x, Node* left, Node* right)
{
	Node* NewNode;//新结点
	NewNode = new Node;//新结点申请内存
	NewNode-&gt;data = x;//新结点数据域赋值
	NewNode-&gt;lChild = left;//新结点左指针域赋值
	NewNode-&gt;rChild = right;//新结点右指针域赋值
	T.root = NewNode;//让新结点成为该子树根结点
}
//前序遍历
void PreOrder(Node* p)
{
	if (p != NULL)
	{
		cout &lt;&lt; p-&gt;data;//访问树根
		PreOrder(p-&gt;lChild);//遍历左子树
		PreOrder(p-&gt;rChild); //遍历右子树
	}
	if (p == NULL)
	{
		cout &lt;&lt; "*";//输出空的节点，更清楚的理解PreOrder的调用过程
	}
}
//中序遍历
void InOrder(Node* p)
{
	if (p != NULL)
	{
		InOrder(p-&gt;lChild); //遍历左子树
		cout &lt;&lt; p-&gt;data; //访问树根
		InOrder(p-&gt;rChild);//遍历右子树
	}
	if (p == NULL)
	{
		cout &lt;&lt; "*";//输出空的节点，更清楚的理解PreOrder的调用过程
	}
}
//后序遍历
void PostOrder(Node* p)
{
	if (p != NULL)
	{
		PostOrder(p-&gt;lChild);//遍历左子树
		PostOrder(p-&gt;rChild); //遍历右子树
		cout &lt;&lt; p-&gt;data; //访问树根
	}
	if (p == NULL)
	{
		cout &lt;&lt; "*";//输出空的节点，更清楚的理解PreOrder的调用过程
	}
}
//主函数
void main()
{
	BinTree K, E, B, C, A;
	Create(K, 'K', NULL, NULL);//创建结点K的子树
	Create(E, 'E', NULL, K.root);//创建结点E的子树
	Create(B, 'B', NULL, E.root);//创建结点B的子树
	Create(C, 'C', NULL, NULL);//创建结点C的子树
	Create(A, 'A', B.root, C.root);//创建结点A的子树
	cout &lt;&lt; "前序遍历为 "; PreOrder(A.root); cout &lt;&lt; endl;
	cout &lt;&lt; "中序遍历为 "; InOrder(A.root); cout &lt;&lt; endl;
	cout &lt;&lt; "后序遍历为 "; PostOrder(A.root); cout &lt;&lt; endl;
}
</code></pre> 
<p style="margin-left:0;text-align:justify;">程序运行的结果如图16所示：</p> 
<div style="text-align:center;"> 
 <figure class="image"> 
  <img alt="" height="133" src="https://images2.imgbox.com/67/1c/hZm9TeBc_o.png" width="546"> 
  <figcaption>
    图16 
  </figcaption> 
 </figure> 
</div> 
<p> 【定理1】任意n(n&gt;0)个<strong>不同结点</strong>的<strong>二叉树</strong>，都可由其<strong>前序遍历</strong>序列<strong>和中序遍历</strong>序列唯一确定。</p> 
<p style="margin-left:0;text-align:justify;">【例4】画出前序遍历ABEKC，中序遍历BEKAC所确定的二叉树。</p> 
<p> （1）由前序遍历ABEKC，A为根结点；由中序遍历BEKAC，BEK为左子树，C为右子树；其对应的二叉树如图17所示。</p> 
<div style="text-align:center;"> 
 <figure class="image"> 
  <img alt="" height="79" src="https://images2.imgbox.com/a6/b2/KQLL9tVi_o.png" width="133"> 
  <figcaption>
    图17 
  </figcaption> 
 </figure> 
</div> 
<p> （2）对于左子树，由前序遍历BEK，B为根结点；由中序遍历BEK，EK为右子树，其对应的二叉树如图18所示。</p> 
<div style="text-align:center;"> 
 <figure class="image"> 
  <img alt="" height="124" src="https://images2.imgbox.com/84/1c/soehkGLf_o.png" width="128"> 
  <figcaption>
    图18 
  </figcaption> 
 </figure> 
</div> 
<p> （3）对于右子树，由前序遍历EK，E为根结点；由中序遍历EK，K为右子树，其对应的二叉树如图19所示。</p> 
<div style="text-align:center;"> 
 <figure class="image"> 
  <img alt="" height="165" src="https://images2.imgbox.com/3a/24/N7F6ONud_o.png" width="130"> 
  <figcaption>
    图19 
  </figcaption> 
 </figure> 
</div> 
<h2 id="%C2%A0%E4%BA%94%E3%80%81%E5%B8%B8%E7%94%A8%E4%BA%8C%E5%8F%89%E6%A0%91"> 五、常用二叉树</h2> 
<h3 id="5.1%E6%8E%92%E5%BA%8F%E4%BA%8C%E5%8F%89%E6%A0%91">5.1排序二叉树</h3> 
<p style="margin-left:0;text-align:justify;">先给出排序二叉树的定义。</p> 
<p style="margin-left:0;text-align:justify;">设二叉树的所有结点值互异，排序二叉树或者是一棵空树，或者是满足以下条件的树：</p> 
<p style="margin-left:0;text-align:justify;">（1）若左子树不空，则<strong>左子树</strong>上所有结点的值均<strong>小于根结点</strong>的值；<strong>（左小于根）</strong></p> 
<p style="margin-left:0;text-align:justify;">（2）若右子树不空，则<strong>右子树</strong>上所有结点的值均<strong>大于根结点</strong>的值；<strong>（右大于根）</strong></p> 
<p style="margin-left:0;text-align:justify;">（3）左、右子树也分别是排序二叉树。<strong>(</strong><strong>递归定义)</strong></p> 
<p style="margin-left:0;text-align:justify;"><strong>排序二叉树定义是由递归方式给出的，据此定义，可给出排序二叉树的创建方法：</strong></p> 
<p style="margin-left:0;text-align:justify;"><strong>首次输入的数据作为此二叉树的根，其后输入的数据与根进行比较，小于树根的放置到左子树，大于树根的放置到右子树。</strong></p> 
<p style="margin-left:0;text-align:justify;">【例5】依次输入数据32，25，16，35，27，创建一棵排序二叉树。</p> 
<p style="margin-left:0;text-align:justify;"><strong>排序二叉树的创建过程如图20</strong>所示：</p> 
<div style="text-align:center;"> 
 <figure class="image"> 
  <img alt="" height="150" src="https://images2.imgbox.com/f6/18/9zdmyH0j_o.png" width="536"> 
  <figcaption>
    图20 排序二叉树的创建过程 
  </figcaption> 
 </figure> 
</div> 
<p>创建排序二叉树的程序如下：</p> 
<pre><code class="language-cpp">#define _CRT_SECURE_NO_WARNINGS
#include&lt;iostream&gt;
using namespace std;
//二叉树结点定义
struct Node
{	int data;//数据域
	Node *lChild,*rChild;//指针域
};
//二叉树定义
struct BinTree
{	Node *root;};
//创建空二叉树
void Create(BinTree &amp;T)
{	T.root=NULL;}
//判空
int IsEmpty(BinTree T)
{	if(T.root==NULL) return 1;
	else return 0;
}
//创建排序二叉树
void Create(BinTree &amp;T,int x)
{	Node *NewNode,*p;
	NewNode=new Node; //新结点申请内存
	NewNode-&gt;data=x;//新结点数据域赋值
	NewNode-&gt;lChild=NULL;//新结点左指针域赋值
	NewNode-&gt;rChild=NULL;//新结点右指针域赋值
	int flag=0;//新结点入树标识,flag=0表示未入树
	if(IsEmpty(T))//如果二叉树为空
		T.root=NewNode;
	else//如果二叉树非空
	{	p=T.root;//探测指针指向根结点
		while(!flag)//当新结点未入树时//理解江老师说的兑奖劵问题
		{	if(x&lt;p-&gt;data)//如果新结点的值小于双亲结点的值
			{ //进入左子树 
				if(p-&gt;lChild==NULL)//如果左子树为空
				{	p-&gt;lChild=NewNode;//新结点成为左子树
					flag=1;//新结点入树
				}
				else//如果左子树非空
					p=p-&gt;lChild;//探测指针向左下移
			}
			else//如果新结点的值大于双亲结点的值
			{  //进入右子树
				if(p-&gt;rChild==NULL)//如果右子树为空
				{	p-&gt;rChild=NewNode;//新结点成为右子树
					flag=1;//新结点入树
				}
				else
					p=p-&gt;rChild;//探测指针向右下移
			}
		}
	}
}
//前序遍历
void PreOrder(Node *p)
{	if(p!=NULL)
	{	cout&lt;&lt;p-&gt;data&lt;&lt;" ";//访问树根
		PreOrder(p-&gt;lChild);//遍历左子树
		PreOrder(p-&gt;rChild);//遍历右子树
	}
}
//中序遍历
void InOrder(Node *p)
{	if(p!=NULL)
	{	InOrder(p-&gt;lChild);//遍历左子树
		cout&lt;&lt;p-&gt;data&lt;&lt;" ";//访问树根
		InOrder(p-&gt;rChild);//遍历右子树
	}
}
//主函数
int main()
{	BinTree T;//定义二叉树
	Create(T);//创建空二叉树
	char c;
	int x;
	printf("输入二叉树结点值(用空格隔开,回车结束)\n");
	while(scanf("%d%c",&amp;x,&amp;c))//while键盘输入的第一种用法
	{
		Create (T,x);//创建排序二叉树
		if(c=='\n') break;
	}
	cout&lt;&lt;"前序遍历为 "; PreOrder(T.root); cout&lt;&lt;endl;
	cout&lt;&lt;"中序遍历为 "; InOrder(T.root); cout&lt;&lt;endl;
	return 0;
}
</code></pre> 
<p> 程序运行的结果如图21所示：</p> 
<div style="text-align:center;"> 
 <figure class="image"> 
  <img alt="" height="158" src="https://images2.imgbox.com/ec/67/zuNH7PAW_o.png" width="505"> 
  <figcaption>
    图21 
  </figcaption> 
 </figure> 
</div> 
<p id="%C2%A05.2%E5%93%88%E5%A4%AB%E6%9B%BC%E6%A0%91"> 排序二叉树的优点是，建树方便，<strong>中序遍历为升序序列。</strong></p> 
<h3>5.2哈夫曼树</h3> 
<p style="margin-left:0;text-align:justify;">先介绍几个概念   。</p> 
<p style="margin-left:0;text-align:justify;"><strong>路径</strong>长度（Path Length）：<strong>路径</strong>上的<strong>分支</strong>(边)数目。</p> 
<p style="margin-left:0;text-align:justify;"><strong>树</strong>的<strong>路径</strong>长度（Tree Path Length）：<strong>根结点到每个叶子结点</strong>的<strong>路径长度之和</strong>。</p> 
<p style="margin-left:0;text-align:justify;"><strong>树</strong>的<strong>带权</strong><strong>(</strong><strong>叶子结点的权值)</strong>路径长度（Weighted Path Length）：<img alt="WPL=\sum_{i=1}^{n}=w_{i}l_{i}" class="mathcode" src="https://images2.imgbox.com/ce/f7/gM3oJ8b9_o.png">其中wi是第i个<strong>叶子结点</strong>的<strong>权值</strong>，li为从<strong>根结点</strong>到第<strong>i个叶子结点</strong>的<strong>路径长度</strong>，n为<strong>叶子结点的总数</strong>。</p> 
<p style="margin-left:0;text-align:justify;"><strong>最优二叉树</strong>：WPL最小的二叉树，最优二叉树也称<strong>哈夫曼树</strong>（Huffman Tree）。</p> 
<p style="margin-left:0;text-align:justify;">【例6】图27给出了三棵二叉树，分别计算它们的<strong>带权路径长度</strong>（即WPL）。</p> 
<div style="text-align:center;"> 
 <figure class="image"> 
  <img alt="" height="198" src="https://images2.imgbox.com/6b/da/pFrbpkMN_o.png" width="446"> 
  <figcaption>
    图27 二叉树的带权路径长度 
  </figcaption> 
 </figure> 
</div> 
<p> 解：</p> 
<p style="margin-left:0;text-align:justify;">（a）WPL=9×1+15×2+3×3+4×3=60</p> 
<p style="margin-left:0;text-align:justify;">（b）WPL=3×1+4×2+9×3+15×3=83</p> 
<p style="margin-left:0;text-align:justify;">（c）WPL=4×1+15×2+9×3+3×3=70</p> 
<p style="margin-left:0;text-align:justify;"><strong>哈夫曼给出了一个创建最优二叉树的方法。</strong>下面，我们用一个实例来介绍这一方法。</p> 
<p style="margin-left:0;text-align:justify;">【例7】设集合{12，3，10，5，2}为<strong>叶结点</strong>的<strong>权值</strong>，试创建哈夫曼树。</p> 
<p style="margin-left:0;text-align:justify;">创建哈夫曼树的过程，可以由以下步骤和示意图来说明。</p> 
<p style="margin-left:0;text-align:justify;">（1）将<strong>权值按升序排序</strong>，构建<strong>单结点的二叉树集</strong>T，T如图28所示。</p> 
<div style="text-align:center;"> 
 <figure class="image"> 
  <img alt="" height="31" src="https://images2.imgbox.com/45/7d/avDIEal1_o.png" width="132"> 
  <figcaption>
    图28 
  </figcaption> 
 </figure> 
</div> 
<p> （2）从T中选取前两棵的二叉树，分别作为左、右子树，构造一棵新二叉树（注意，排序在前的作左子树），对T中权值再按升序排序（<strong>注意，如果出现权值相等的情况，则原树排前，新树排后</strong>），T如图29所示。</p> 
<div style="text-align:center;"> 
 <figure class="image"> 
  <img alt="" height="72" src="https://images2.imgbox.com/d2/c4/NN0ILlOS_o.png" width="128"> 
  <figcaption>
    图29 
  </figcaption> 
 </figure> 
</div> 
<p style="margin-left:0;text-align:justify;">（3）反复重复第（2）步的操作，T如图30 — 图32所示。</p> 
<p style="margin-left:0;text-align:justify;"><img alt="" height="203" src="https://images2.imgbox.com/60/3b/eYq0Fid5_o.png" width="463"></p> 
<p style="margin-left:0;text-align:justify;">图30 创建过程3         图31 创建过程4              图32 创建过程5</p> 
<p style="margin-left:0;text-align:justify;">必须指出，<strong>哈夫曼树的形状不唯一</strong>。但如果严格按上述规定来创建，哈夫曼树还是唯一</p> 
<p> 的，<strong>编程创建哈夫曼树将严格按上述规定进行。</strong></p> 
<p style="margin-left:0;text-align:justify;">【性质1】哈夫曼树不存在<strong>度</strong>为1的结点。</p> 
<p style="margin-left:0;text-align:justify;">【性质2】设哈夫曼树的<strong>叶子结点数</strong>为n0，则哈夫曼树的<strong>结点数</strong>n=2*n0-1。</p> 
<p style="margin-left:0;text-align:justify;">【性质3】哈夫曼树的<strong>带权路径长度</strong>等于所有<strong>度为</strong><strong>2</strong><strong>的结点值之和</strong>。</p> 
<p style="margin-left:0;text-align:justify;"></p> 
<h2 id="%E6%80%BB%E7%BB%93">总结</h2> 
<p><span style="color:#999aaa;">本文章主要讲述了数据结构之树型结构的一些基础知识点，希望能给大家带来帮助。</span></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/25f7c77a6c82985c62d7fdfcf2292cf8/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">OAuth2第三方登录快速接入</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/8fb85d11060612958036d09aabf451cf/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">讯连科技威力导演20中文版</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>