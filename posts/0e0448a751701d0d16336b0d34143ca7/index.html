<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Java父子类间构造函数调用问题 - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Java父子类间构造函数调用问题" />
<meta property="og:description" content="注：super():调用父类构造函数,super.属性:调用父类的属性
前提一：父类中有一定的属性(参数),子类中无新属性： 情况1：当父类和子类均无自定义构造函数(即均使用默认构造函数)时，可独立创建父和子类实体。
情况1.1：当父类和子类均有自定义无参构造函数时，可独立创建父和子类实体。
情况2：当父类和子类均有自定义构造函数，子类中自定义构造函数使用super()函数可独立创建父和子类实体。
情况3：当父类无自定义构造函数，子类使用super()，编译报错。若此时子类使用super.属性进行构造则只能创建子实体，无法带参创建父实体，但可以无参数创建父实体。
情况4：当父类有自定义构造函数，子类无自定义构造函数时。只能创建父类实体，无法创建子类实体。
情况5：当父子都有自定义构造函数时，子类使用super().还是super.属性都可独立创建父子类。
前提二：父类中有一定的属性(参数),子类有新属性： 情况1：当父类无自定义构造函数，子类有构造函数时，仅当子类使用super.属性时才能独立创建子类实体，无法使用super()。
//父类 public class person { String name; String sex; } //子类 public class OneMan extends person{ String greet; public OneMan(String name, String sex,String greet) { super.name=name; super.sex=sex; this.greet=greet; } } public class Main{ public static void main(String[] args){ OneMan A=new OneMan(&#34;小明儿&#34;,&#34;男&#34;,&#34;哈喽哈喽&#34;); System.out.printf(&#34;%s %s %s\n&#34;,A.name,A.sex,A.greet); } } 情况2：当父子类都有自定义函数时，子类必须先使用super(属性,属性)调用父类构造函数。此时可独立创建父类实体和子类实体。
//父类 public class person { String name; String sex; public person(String name,String sex) { this." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/0e0448a751701d0d16336b0d34143ca7/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-07-08T08:59:04+08:00" />
<meta property="article:modified_time" content="2023-07-08T08:59:04+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Java父子类间构造函数调用问题</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p><span style="color:#fe2c24;">注：super():调用父类构造函数,super.属性:调用父类的属性</span></p> 
<h2>前提一：父类中有一定的属性(参数),子类中无新属性：</h2> 
<p>情况1：当父类和子类均无自定义构造函数(即均使用默认构造函数)时，可独立创建父和子类实体。</p> 
<p>情况1.1：当父类和子类均有自定义无参构造函数时，可独立创建父和子类实体。</p> 
<p>情况2：当父类和子类均有自定义构造函数，子类中自定义构造函数使用super()函数可独立创建父和子类实体。</p> 
<p>情况3：当父类无自定义构造函数，子类使用super()，编译报错。若此时子类使用super.属性进行构造则只能创建子实体，无法带参创建父实体，但可以无参数创建父实体。</p> 
<p>情况4：当父类有自定义构造函数，子类无自定义构造函数时。只能创建父类实体，无法创建子类实体。</p> 
<p>情况5：当父子都有自定义构造函数时，子类使用super().还是super.属性都可独立创建父子类。</p> 
<h2>前提二：父类中有一定的属性(参数),子类有新属性：</h2> 
<p>情况1：当父类无自定义构造函数，子类有构造函数时，仅当子类使用super.属性时才能独立创建子类实体，无法使用super()。</p> 
<pre><code class="language-java">//父类
public class person {
    String name;
    String sex;
}
//子类
public class OneMan extends person{
    String greet;
    public OneMan(String name, String sex,String greet)
    {
        super.name=name;
        super.sex=sex;
        this.greet=greet;
    }
}
public class Main{
    public static void main(String[] args){
         OneMan A=new OneMan("小明儿","男","哈喽哈喽");

        System.out.printf("%s %s %s\n",A.name,A.sex,A.greet);
    }
}
</code></pre> 
<p>情况2：当父子类都有自定义函数时，子类必须先使用super(属性,属性)调用父类构造函数。此时可独立创建父类实体和子类实体。</p> 
<pre><code class="language-java">//父类
public class person {
    String name;
    String sex;
    public person(String name,String sex)
    {
        this.name=name;
        this.sex=sex;
    }
}
//子类
public class OneMan extends person{
    String greet;
    public OneMan(String name, String sex,String greet)
    {
        super(name,sex);
        this.greet=greet;
    }
}
public class Main{
    public static void main(String[] args){
         OneMan A=new OneMan("小明儿","男","哈喽哈喽");
        person B=new person("小刚父","男");

        System.out.printf("%s %s %s\n",A.name,A.sex,A.greet);
        System.out.printf("%s %s ",B.name,B.sex);
    }
}
</code></pre> 
<p><span style="color:#fe2c24;">总结：子类并不能继承父类的构造函数。要想创建子类实体，子类必须要有构造函数(除非父类没有构造函数)。super()函数会调用父类具有相同参数的构造函数(因此若父类中没有构造函数，子类中有构造函数则使用super()构造会报错)。</span></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/1216ae8c30293930765f27369fc2a6f6/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">大数据之路—数据架构体系及模型设计</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/382f812782aa31eaae8bba62b595561e/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">java抽奖</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>