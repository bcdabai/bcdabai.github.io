<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>python punctuation_Python大法学习 - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="python punctuation_Python大法学习" />
<meta property="og:description" content="使用Python写简单的脚本已经有几个月了，由于不是经常写，导致每次用起来经常会忘记一些写法，现在做个笔记：
分类方法、函数作用操作系统
os.name查看操作系统类型
os.uname()函数操作系统详细信息环境变量
os.environ环境变量
os.environ.get(&#39;key&#39;)某个环境变量的值操作文件、目录
os.getcwd()获取当前目录
os.listdir( )目录列表
os.mkdir()创建文件、目录
os.rmdir()删除文件、目录
os.chdir()改变默认目录
shutil.copyfile()复制文件文件重命名、删除
os.rename()文件重命名
os.remove()文件删除
os.path模块
os.path.abspath()绝对路径
os.path.join()重组路径
os.path下拆分路径
os.path.split()拆分路径
os.path.splitext()拆分路径的扩展名
os.path下判断函数
os.path.isdir()判断目录
os.path.isfile()判断文件
#大括号转义
使用两个{{ 或 }}，而不是使用\{ 或 \}
1、时间戳
import datetime(自带库)
print &#34;# time is :&#34;, datetime.datetime.now().strftime(&#39;%Y-%m-%d%H:%M:%S&#39;)
时间格式转换，比如(10/01/2019 --&gt; 2019-10-01)
systemInfoList = cpuResultList[0].split()
timeArray = time.strptime(systemInfoList[3], &#34;%m/%d/%Y&#34;)
saTime=time.strftime(&#34;%Y-%m-%d&#34;, timeArray)
时间戳--&gt;时间格式转换
saTmpFileAdjustTimeStamp = os.path.getmtime(saTmpFile)
timestampTmp = time.localtime(saTmpFileAdjustTimeStamp)
saTmpFileAdjustTime = time.strftime(&#39;%Y-%m-%d&#39;, timestampTmp)
2、打开文件使用with写法，防止忘记关闭文件句柄。
with open(&#39;project.lib&#39;) as pr:
for line in pr:" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/6d6ead9bb648b59ed367c27d4d5d2313/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2020-12-08T12:53:26+08:00" />
<meta property="article:modified_time" content="2020-12-08T12:53:26+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">python punctuation_Python大法学习</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <div style="font-size:16px;"> 
 <p>使用Python写简单的脚本已经有几个月了，由于不是经常写，导致每次用起来经常会忘记一些写法，现在做个笔记：</p> 
 <p>分类方法、函数作用操作系统</p> 
 <p>os.name查看操作系统类型</p> 
 <p>os.uname()函数操作系统详细信息环境变量</p> 
 <p>os.environ环境变量</p> 
 <p>os.environ.get('key')某个环境变量的值操作文件、目录</p> 
 <p>os.getcwd()获取当前目录</p> 
 <p>os.listdir( )目录列表</p> 
 <p>os.mkdir()创建文件、目录</p> 
 <p>os.rmdir()删除文件、目录</p> 
 <p>os.chdir()改变默认目录</p> 
 <p>shutil.copyfile()复制文件文件重命名、删除</p> 
 <p>os.rename()文件重命名</p> 
 <p>os.remove()文件删除</p> 
 <p>os.path模块</p> 
 <p>os.path.abspath()绝对路径</p> 
 <p>os.path.join()重组路径</p> 
 <p>os.path下拆分路径</p> 
 <p>os.path.split()拆分路径</p> 
 <p>os.path.splitext()拆分路径的扩展名</p> 
 <p>os.path下判断函数</p> 
 <p>os.path.isdir()判断目录</p> 
 <p>os.path.isfile()判断文件</p> 
 <p>#大括号转义</p> 
 <p>使用两个{<!-- -->{ 或 }}，而不是使用\{ 或 \}</p> 
 <p>1、时间戳</p> 
 <p>import datetime(自带库)</p> 
 <p>print "# time is :", datetime.datetime.now().strftime('%Y-%m-%d%H:%M:%S')</p> 
 <p>时间格式转换，比如(10/01/2019 --&gt; 2019-10-01)</p> 
 <p>systemInfoList = cpuResultList[0].split()</p> 
 <p>timeArray = time.strptime(systemInfoList[3], "%m/%d/%Y")</p> 
 <p>saTime=time.strftime("%Y-%m-%d", timeArray)</p> 
 <p>时间戳--&gt;时间格式转换</p> 
 <p>saTmpFileAdjustTimeStamp = os.path.getmtime(saTmpFile)</p> 
 <p>timestampTmp = time.localtime(saTmpFileAdjustTimeStamp)</p> 
 <p>saTmpFileAdjustTime = time.strftime('%Y-%m-%d', timestampTmp)</p> 
 <p>2、打开文件使用with写法，防止忘记关闭文件句柄。</p> 
 <p>with open('project.lib') as pr:</p> 
 <p>for line in pr:</p> 
 <p>if re.search('\sreference.lib\s', line):</p> 
 <p>continue</p> 
 <p>string += line</p> 
 <p>3、Hash 数据结构最好使用get方法来得到它的值，以及访问Hash的值，以及Hash排序</p> 
 <p>DBVolume = userDB.get(userName).get('volume')</p> 
 <p>DBQtree = userDB.get(userName).get('qtree')</p> 
 <p>DBVserver = userDB.get(userName).get('vserver')</p> 
 <p>emailContent = transHuman(quotaDB.get(DBVserver).get(DBVolume).get(userName))</p> 
 <p># 获取Hash的值</p> 
 <p>for k,v in prj.items():</p> 
 <p>print ('{k:&lt;10} --&gt; {v:&lt;10}'.format(v = v ,k = k))</p> 
 <p>for k in prj.keys():</p> 
 <p>print ('{k}'.format(k = k))</p> 
 <p># hash 排序</p> 
 <p>Sorted返回的是一个列表</p> 
 <p>dbListTmp = sorted(db.items(), key=lambda x: x[1]) #仅限于一层字典，多层需要注意但是也可以排序。</p> 
 <p>VS</p> 
 <p>import operator</p> 
 <p>dbListTmp = sorted(db.items(), key=operator.itemgetter(1))</p> 
 <p>多层排序：注意db.items()是一个元组，重点二层字典排序EX：</p> 
 <p>DBSortList = sorted(DB.items(), key=lambda x: float(x[1]['Used']))</p> 
 <p>返回值是一个列表。</p> 
 <p>另一种思路：</p> 
 <p>先把hash变成列表</p> 
 <p>stuDBList = Sorted(list[DB.items()])</p> 
 <p>取出key的值组成一个列表</p> 
 <p>stuNameList = [x[0] for x in stuDBList ]</p> 
 <p>取出Value值组成一个列表</p> 
 <p>stuCOCountList = [X[1].get("OUT") for x in stuDBList]</p> 
 <p># 列表排序：</p> 
 <p>timeList = ['20:50:59', '2:50:59', '8:50:59', '14:50:59']</p> 
 <p>timeList = sorted(timeList, key=lambda x:int(x.split(':')[0]))</p> 
 <p>print (timeList)</p> 
 <p># ['2:50:59', '8:50:59', '14:50:59', '20:50:59']</p> 
 <p>4、命令行参数解析最好使用自带库来解析：optParse，argparse</p> 
 <p>from optparse import OptionParse(自带库)</p> 
 <p>def option_process():</p> 
 <p>usage = "%prog [option]"</p> 
 <p>optParser = OptionParser(usage=usage)</p> 
 <p>optParser.add_option('-f', '--file', action='store', dest='cfg_name',</p> 
 <p>help='Please input the confige name, setup database',</p> 
 <p>)</p> 
 <p>optParser.add_option('-g', '--generate', action='store_true', dest='gen',</p> 
 <p>help='Output the templete confige file',</p> 
 <p>)</p> 
 <p>if not len(sys.argv[1:]):</p> 
 <p>optParser.print_help()</p> 
 <p>exit()</p> 
 <p>option, args = optParser.parse_args()</p> 
 <p>return option</p> 
 <p>import argparse</p> 
 <p>def optionProcess():</p> 
 <p>'''</p> 
 <p>input the option from the command line ,</p> 
 <p>decode the option.</p> 
 <p>'''</p> 
 <p>parser = argparse.ArgumentParser(usage='%(prog)s [options]', description='Linux sysstat sar(System Activity Reporter) log analysis script')</p> 
 <p># parser.description=''</p> 
 <p>parser.add_argument("-v", "--version", action="version", version='%(prog)s version is 0.0')</p> 
 <p>parser.add_argument("-c", "--cpu", action="store_true", help='Output Cpu idle usage graph')</p> 
 <p>if not len(sys.argv[1:]):</p> 
 <p>parser.print_help()</p> 
 <p>exit()</p> 
 <p>args = parser.parse_args()</p> 
 <p>return args</p> 
 <p>5、正则匹配与替换：</p> 
 <p>匹配：re.search('^#|^ +#',line)</p> 
 <p>prj_exist = re.search("(^DEFINE|^INCLUDE).+/(.*?)_(pdk|cad)", prj_cont , re.M)(忽略大小写)</p> 
 <p>替换：line_list = re.sub(r'#.*',"",line).rsplit('=')</p> 
 <p>6、去掉空格和分割字符串：</p> 
 <p>cfg_list = cfg_content.strip().rsplit('\n')</p> 
 <p>7、得到当前路径|用户名、打印数据结构、合并路径、调用shell命令并得到相应的值</p> 
 <p>import sys,os,re</p> 
 <p>import pprint as pp</p> 
 <p>import getpass as gp</p> 
 <p>import commands as cmd # python 2.6, for python 3.1 transfer subprocess</p> 
 <p>from optparse import OptionParser</p> 
 <p>#sys.path.append("python")</p> 
 <p>#import NetApp</p> 
 <p>from quotaOb import quotaApi</p> 
 <p># 打印数据结构</p> 
 <p>pp.pprint()(必须有括号)</p> 
 <p># 得到shell命令的实行情况，和返回值</p> 
 <p>(status, userDomain) = cmd.getstatusoutput('ypwhich')</p> 
 <p># 获得目录下的所有文件</p> 
 <p>cwd = os.getcwd()</p> 
 <p>dirList = os.listdir(cwd)</p> 
 <p>pp.pprint(dirList)</p> 
 <p># 得到用户名</p> 
 <p>userName = gp.getuser()</p> 
 <p># 当前路径</p> 
 <p>cwd = os.getcwd()</p> 
 <p>cwdBasename = os.path.basename(cwd)</p> 
 <p># 去掉#注释行</p> 
 <p>if re.search('^\s*?#', line)：</p> 
 <p>string += line</p> 
 <p>continue</p> 
 <p># 合并路径</p> 
 <p>file_location = os.path.join(file_path, file_name)</p> 
 <p>Note：合并路径的除了第一项都不能以/开头，不然会丢失这一项。</p> 
 <p># 得到path下所有的目录及其子文件</p> 
 <p>for root, dirs, files in os.walk(path, topdown=True):</p> 
 <p>for name in files:</p> 
 <p>print (os.path.join(root, name))</p> 
 <p>for name in dirs:</p> 
 <p>print (os.path.join(root, name))</p> 
 <p>8、邮件发送</p> 
 <p>import sys, smtplib</p> 
 <p>import pprint as pp</p> 
 <p>from email.MIMEText import MIMEText</p> 
 <p>from email.Header import Header</p> 
 <p>class quotaApi():</p> 
 <p>def __init__(self):</p> 
 <p>pass</p> 
 <p>def sendMail(self, content, subject, receivers):</p> 
 <p>sender = 'cadinfo@126.com.cn'</p> 
 <p>smtpIp = '192.168.34.168'</p> 
 <p>userName = 'cadinfo@126.com.cn'</p> 
 <p>passwd = 'cad'</p> 
 <p>msg = MIMEText(content,'plain', 'utf-8')</p> 
 <p>msg['Subject'] = Header(subject)</p> 
 <p>msg['From'] = sender</p> 
 <p>msg['To'] = ';'.join(receivers)</p> 
 <p>smtp = smtplib.SMTP()</p> 
 <p>smtp.connect(smtpIp)</p> 
 <p>smtp.login(userName, passwd)</p> 
 <p>smtp.sendmail(sender, receivers, msg.as_string())</p> 
 <p>smtp.quit()</p> 
 <p>9、copy文件，链接</p> 
 <p>import os,re,sys,datetime,time, shutil</p> 
 <p>import operator as op # string size comparison</p> 
 <p>import getpass as gp # get current user name</p> 
 <p># 调用shell链接</p> 
 <p>display = os.path.join(prj_path, 'display.drf')</p> 
 <p>os.system('ln -s {0} display.drf'.format(display))</p> 
 <p># copy 文件夹</p> 
 <p>runset = os.path.join(prj_path, 'runset')</p> 
 <p>shutil.copytree(runset,'runset',symlinks=True )</p> 
 <p># copy 文件</p> 
 <p>cdslib = os.path.join(prj_path, 'cds.lib')</p> 
 <p>shutil.copyfile(cdslib,'cds.lib')</p> 
 <p># setup the user preject work area directory</p> 
 <p>wa_user_name = prj_name + "_" + user_name + ".Work"</p> 
 <p>os.makedirs(wa_user_name)</p> 
 <p>os.chdir(wa_user_name)</p> 
 <p># 打印文件夹下的所有文件</p> 
 <p>prj_name_all = os.listdir(path) # print the file name list of path</p> 
 <p># 字符串比较</p> 
 <p># if the input is large than current str and less than next str, return the location</p> 
 <p>if (op.lt(list_name[j],in_name)):</p> 
 <p>if (op.gt(list_name[j+1],in_name)):</p> 
 <p>insert_location = j + 1</p> 
 <p>break</p> 
 <p>20190401</p> 
 <p>10、查看环境变量及判断环境变量是否存在某值</p> 
 <p># print os.environ['FMSOSPUBNAME']</p> 
 <p>if 'FMSOSPUBNAME' not in os.environ:</p> 
 <p>print "[FMSH_ERROR] Don't find SOS ENVIRMENT.Please user sp command !"</p> 
 <p>exit()</p> 
 <p>11、点(.)符号索引</p> 
 <p>一点提示： Python的列表是从0开始索引。 第一项的索引是0，第二项的是1，依此类推。</p> 
 <p>句点查找规则可概括为： 当模板系统在变量名中遇到点时，按照以下顺序尝试进行查找：</p> 
 <p>字典类型查找 (比如 foo["bar"] )</p> 
 <p>属性查找 (比如 foo.bar )</p> 
 <p>方法调用 (比如 foo.bar() )</p> 
 <p>列表类型索引查找 (比如 foo[bar] )</p> 
 <p>12、使用open读文件时，餐宿read, readline, readlines的区别</p> 
 <p>python文件对象提供了三个“读”方法： read()、readline() 和 readlines()。每种方法可以接受一个变量以限制每次读取的数据量。</p> 
 <p>1.read() 每次读取整个文件，它通常用于将文件内容放到一个字符串变量中。如果文件大于可用内存，为了保险起见，可以反复调用read(size)方法，每次最多读取size个字节的内容。</p> 
 <p>2.readlines() 之间的差异是后者一次读取整个文件，象 .read() 一样。.readlines() 自动将文件内容分析成一个行的列表，该列表可以由 Python 的 for ... in ... 结构进行处理。</p> 
 <p>3.readline() 每次只读取一行，通常比readlines() 慢得多。仅当没有足够内存可以一次读取整个文件时，才应该使用 readline()。</p> 
 <p>注意：这三种方法是把每行末尾的'\n'也读进来了，它并不会默认的把'\n'去掉，需要我们手动去掉。</p> 
 <p>13、由于涉及到公司邮箱，数据库账号的危险性，一般会对这类python进行加密处理，这类程序加密方案基本有</p> 
 <p>1、编译二进制代码。非常不安全，网上有在线的反编译网站，安慰新手。</p> 
 <p>2、混淆代码。出名的是GITHUB上的：git@github.com:astrand/pyobfuscate.git</p> 
 <p>3、使用C编译的方式，比较彻底。</p> 
 <p>但结合实际，可以采用2+1的方式来实现，简单容易。首先使用pyobfuscate混淆代码，但是这样要注意会修改到类的名字。</p> 
 <p>所以要手动找到类名称位置，然后使用python -m script -b来产生二进制代码，不夹-b，python3会生成一个文件夹</p> 
 <p>14、python 来使用模块打包二进制代码时，一定要注意，代码里会吧sys.path更新</p> 
 <p>直接启动是把run.py文件，所在的目录放到了sys.path属性中。</p> 
 <p>模块启动是把你输入命令的目录(也就是当前路径)，放到了sys.path属性中***</p> 
 <p>15、读写编码问题</p> 
 <p>今天遇到一个问题就是python3在打开文档的时候会出现编码错误，但奇怪的是在python2时不会出现这个问题。</p> 
 <p>看了下解释，Python3默认读取的时候按照utf-8读取，python2是按照unicode来读取。</p> 
 <p>不是很明白。</p> 
 <p>最后解决方法：</p> 
 <p>with open (subFile, encoding = 'utf-8', errors='ignore') as subf:</p> 
 <p>print (type(subf))</p> 
 <p>fileConf = subf.read()</p> 
 <p>加了ignore，但是感觉这种方法不好，如果这个文件不存在会出现什么情况？如果文件不存在还是会报错。还好，但是如果编码乱了</p> 
 <p>会把乱掉的编码丢失掉。所以可能会造成数据丢失</p> 
 <p align="center">16、print输出字体颜色<img src="" alt="">字体颜色说明</p> 
 <p>17、生成随机数字符，用到两个库string和random</p> 
 <p># 11位随机数</p> 
 <p>bit = 11</p> 
 <p>for i in range(bit):</p> 
 <p>your_pass = random.choice(string.ascii_letters + string.digits +string.punctuation)</p> 
 <p>user_list.append(your_pass)</p> 
 <p>pass_result = "".join(user_list)</p> 
 <p>18、字典的取值方法，推荐第二种</p> 
 <p># 第一种 若键不存在则会抛出KeyError异常</p> 
 <p>person['city']</p> 
 <p># 第二种 不会抛出异常，不存在则返回None,也可以设置默认返回值</p> 
 <p>person.get('city',"上海")</p> 
 <p># 第三种 与第二种类似，区别在于setdefault方法会更新字典</p> 
 <p>person.setdefault('city', '上海')</p> 
 <p>19、#！/usr/bin/python VS #！ /usr/bin/env python</p> 
 <p>前一种是绝对路径，直接调用/usr/bin下的python，后一种是通过env 查找path路径下的python，可能不一样。</p> 
 <p>当系统看到这一行的时候，首先会到env设置里查找python的安装路径，再调用对应路径下的解释器程序完成操作。</p> 
 <p>#!/usr/bin/python相当于写死了python路径。</p> 
 <p>#!/usr/bin/env python会去环境设置寻找python目录。</p> 
 <p>注意：</p> 
 <p>防止用户没有将python装在默认的/usr/bin路径里，推荐使用#!/usr/bin/env python。</p> 
 <p>20、linux执行python的脚本文件,提示No such file or directory，解决方法</p> 
 <p>1.使用vim打开该py文件</p> 
 <p>2.点击esc，输入：set ff</p> 
 <p>回车，显示fileformat=dos,</p> 
 <p>3.重新设置文件格式：set ff=unix</p> 
 <p>4.保存并推出：wq</p> 
 <p>21、python 跳出多重循环的方法</p> 
 <p>用for...else...语句</p> 
 <p># -*- coding:utf-8 -*-</p> 
 <p>"""</p> 
 <p>功能：python跳出循环</p> 
 <p>"""</p> 
 <p># 方法2：for...else...用法，用于跳出指定循环层</p> 
 <p>for i in range(5):</p> 
 <p>for j in range(5):</p> 
 <p>for k in range(5):</p> 
 <p>if i == j == k == 3:</p> 
 <p>break</p> 
 <p>else:</p> 
 <p>print i, '----', j, '----', k</p> 
 <p>else: # else1</p> 
 <p>continue</p> 
 <p>break # break1</p> 
 <p>else: # else2</p> 
 <p>continue</p> 
 <p>break # break2</p> 
 <p>解释：</p> 
 <p>(1)break能跳出某一重循环(该重循环的本次及剩余次数都不再执行)，</p> 
 <p>但并不能跳出该重循环的其他外重循环。</p> 
 <p>例如，最内第3重循环break之后，程序返回第2重循环继续执行第2重的下一次，</p> 
 <p>然后第3重循环将再次执行。</p> 
 <p>(2)continue是跳过某一重循环的某一次，但该重循环的剩余次数会继续执行。</p> 
 <p>(3)for...else：其中else块中的语句将在for循环完整执行过之后才会被执行，</p> 
 <p>如果for循环被break，则else块将不会被执行。</p> 
 <p>(4)方法3中，当第3重循环满足i == j == k ==3时，第3重循环被break，则并列的else1将跳过，</p> 
 <p>执行break1，导致第2重循环被终止，则else2被跳过，执行break2，导致第1重循环被终止。</p> 
 <p>最终实现跳出整个循环。</p> 
</div>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/507858a738f30add18f1dcca7921caa3/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">2020-12-08</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/1c3291e2fa3b08f555674cf208e50e25/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">产品经理的职责究竟是什么呢</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>