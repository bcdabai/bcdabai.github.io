<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>DICOM：基于DCMTK实现C-FIND SCU - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="DICOM：基于DCMTK实现C-FIND SCU" />
<meta property="og:description" content="背景： 专栏之前写过许多关于DICOM协议的相关文章，有关于概念解析的理论性文章，也有实例演示的应用性文章。目的只有一个，希望能引导大家快速掌握DICOM协议，并着手进行自定义化开发。
目前DICOM协议实现有多种开源库，例如基于C&#43;&#43;的DCMTK、基于C#的fo-dicom、基于Java的dcm4che。由于时间关系博文中的相关实例演示经常会穿插着使用三种开源库，因此具体到某一种库可能博文中并未给出示范工程。例如，近期有网友咨询希望利用DCMTK开源库自己动手实现C-FIND查询请求，并对服务端返回的信息进行定制化处理。因此周末动手编写了一个极简版的示例，代码裁剪于DCMTK开源库的findscu工程，供大家交流学习。
准备知识： 为了更好的理解代码示例，请耐心阅读之前专栏里的相关文章，如果已经对DICOM协议很了解且有过开发经验，或者干脆就想先动手敲代码，想从实践中学习，那么请自行跳到下一节。 在开始工作之前先阅读DICOM医学图像处理：DICOM网路传输了解DICOM协议的含义以及简单的建立规则，随后阅读DICOM医学图像处理：全面解析DICOM3.0标准中的通讯服务模块和DICOM：DICOM3.0网络通信协议(续）进一步了解DICOM协议，以及熟悉DCMTK开源库中对DICOM协议的具体实现。阅读完上述理论概念性文章后，进一步浏览下面两篇实例演示博文DICOM医学图像处理：基于DCMTK工具包学习和分析worklist、DICOM医学图像处理：利用fo-dicom发送C-Find查询Worklist 。
DCMTK实现C-FIND SCU： 待一切先验知识储备完成后，就可以进入我们的正题了，网友的需求是：
在阅读DICOM医学图像处理：基于DCMTK工具包学习和分析worklist、DICOM医学图像处理：利用fo-dicom发送C-Find查询Worklist 两篇实例博文后，希望利用DCMTK尝试发送C-FIND-RQ请求，然后将返回的C-FIND-RSP消息进行解析和后处理。 经过上述【准备知识】阶段后，想必大家已经了解了C-FIND请求建立的正题过程，因此不罗嗦了直接贴代码，用一个简单的实例来进行实际讲解。
a)网络环境初始化 //1)初始化网络环境 WSAData winSockData; /* we need at least version 1.1 */ WORD winSockVersionNeeded = MAKEWORD( 1, 1 ); WSAStartup(winSockVersionNeeded, &amp;winSockData); b)DCMTK库初始化 //2）DCMTK环境监测 if(!dcmDataDict.isDictionaryLoaded()) { printf(&#34;No data dictionary loaded, check environment variable\n&#34;); } c)建立DUL连接 //3）网络层ASC初始化 T_ASC_Network* cfindNetwork=NULL; int timeout=50; OFCondition cond=ASC_initializeNetwork(NET_REQUESTOR,0,timeout,&amp;cfindNetwork); if(cond.bad()) { printf(&#34;DICOM 底层网络初始化失败\n&#34;); return -1; } //4）创建底层连接，即TCP层 T_ASC_Association* assoc=NULL; T_ASC_Parameters* params=NULL; DIC_NODENAME localHost; DIC_NODENAME peerHost; OFString temp_str; cond=ASC_createAssociationParameters(¶ms,maxReceivePDULength); if(cond." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/f87d89de05b5c4e7dbeb3bacf4fdc305/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2015-03-28T00:29:42+08:00" />
<meta property="article:modified_time" content="2015-03-28T00:29:42+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">DICOM：基于DCMTK实现C-FIND SCU</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <h3 id="背景"><font face="Microsoft YaHei" color="blue">背景：</font></h3> 
<p>专栏之前写过许多关于DICOM协议的相关文章，有关于概念解析的理论性文章，也有实例演示的应用性文章。目的只有一个，希望能引导大家快速掌握DICOM协议，并着手进行自定义化开发。<br> 目前DICOM协议实现有多种开源库，例如基于C++的DCMTK、基于C#的fo-dicom、基于Java的dcm4che。由于时间关系博文中的相关实例演示经常会穿插着使用三种开源库，因此具体到某一种库可能博文中并未给出示范工程。例如，近期有网友咨询希望利用DCMTK开源库自己动手实现C-FIND查询请求，并对服务端返回的信息进行定制化处理。因此周末动手编写了一个极简版的示例，代码裁剪于DCMTK开源库的findscu工程，供大家交流学习。</p> 
<h3 id="准备知识"><font face="Microsoft YaHei" color="blue">准备知识：</font></h3> 
<p>为了更好的理解代码示例，请耐心阅读之前专栏里的相关文章，<strong>如果已经对DICOM协议很了解且有过开发经验，或者干脆就想先动手敲代码，想从实践中学习，那么请自行跳到下一节。</strong> <br> 在开始工作之前先阅读<a href="http://blog.csdn.net/zssureqh/article/details/41016091">DICOM医学图像处理：DICOM网路传输</a>了解DICOM协议的含义以及简单的建立规则，随后阅读<a href="http://blog.csdn.net/zssureqh/article/details/39098621">DICOM医学图像处理：全面解析DICOM3.0标准中的通讯服务模块</a>和<a href="" rel="nofollow">DICOM：DICOM3.0网络通信协议(续）</a>进一步了解DICOM协议，以及熟悉DCMTK开源库中对DICOM协议的具体实现。阅读完上述理论概念性文章后，进一步浏览下面两篇实例演示博文<a href="http://blog.csdn.net/zssureqh/article/details/38775315">DICOM医学图像处理：基于DCMTK工具包学习和分析worklist</a>、<a href="http://blog.csdn.net/zssureqh/article/details/38986721">DICOM医学图像处理：利用fo-dicom发送C-Find查询Worklist</a> 。<br></p> 
<h3 id="dcmtk实现c-find-scu"><font face="Microsoft YaHei" color="blue">DCMTK实现C-FIND SCU：</font></h3> 
<p>待一切先验知识储备完成后，就可以进入我们的正题了，网友的需求是：</p> 
<blockquote> 
 <p><font color="gray"> <br> 在阅读<a href="http://blog.csdn.net/zssureqh/article/details/38775315">DICOM医学图像处理：基于DCMTK工具包学习和分析worklist</a>、<a href="http://blog.csdn.net/zssureqh/article/details/38986721">DICOM医学图像处理：利用fo-dicom发送C-Find查询Worklist</a> 两篇实例博文后，希望<font color="red"><strong>利用DCMTK尝试发送C-FIND-RQ请求，然后将返回的C-FIND-RSP消息进行解析和后处理</strong></font>。 <br> </font></p> 
</blockquote> 
<p>经过上述<font color="blue"><strong>【准备知识】</strong></font>阶段后，想必大家已经了解了C-FIND请求建立的正题过程，因此不罗嗦了直接贴代码，用一个简单的实例来进行实际讲解。<br></p> 
<h4 id="a网络环境初始化"><font face="Microsoft YaHei" color="green">a)网络环境初始化</font></h4> 
<pre><code class="language-cpp">    //1)初始化网络环境
    WSAData winSockData;
    /* we need at least version 1.1 */
    WORD winSockVersionNeeded = MAKEWORD( 1, 1 );
    WSAStartup(winSockVersionNeeded, &amp;winSockData);
</code></pre> 
<h4 id="bdcmtk库初始化"><font face="Microsoft YaHei" color="green">b)DCMTK库初始化</font></h4> 
<pre><code class="language-cpp">//2）DCMTK环境监测
    if(!dcmDataDict.isDictionaryLoaded())
    {
        printf("No data dictionary loaded, check environment variable\n");
    }
</code></pre> 
<h4 id="c建立dul连接"><font face="Microsoft YaHei" color="green">c)建立DUL连接</font></h4> 
<pre><code class="language-cpp">    //3）网络层ASC初始化
    T_ASC_Network* cfindNetwork=NULL;
    int timeout=50;
    OFCondition cond=ASC_initializeNetwork(NET_REQUESTOR,0,timeout,&amp;cfindNetwork);
    if(cond.bad())
    {
        printf("DICOM 底层网络初始化失败\n");
        return -1;
    }
    //4）创建底层连接，即TCP层
    T_ASC_Association* assoc=NULL;
    T_ASC_Parameters* params=NULL;
    DIC_NODENAME localHost;
    DIC_NODENAME peerHost;
    OFString temp_str;
    cond=ASC_createAssociationParameters(¶ms,maxReceivePDULength);
    if(cond.bad())
    {
        printf("DCMTK创建连接失败\n");
        return -2;
    }
</code></pre> 
<h4 id="d判别连接"><font face="Microsoft YaHei" color="green">d)判别连接</font></h4> 
<pre class="prettyprint"><code class=" hljs cs"><span class="hljs-comment">//5）设置DICOM相关属性，Presentation Context</span>
    ASC_setAPTitles(<span class="hljs-keyword">params</span>, ourTitle, peerTitle, NULL);

    cond = ASC_setTransportLayerType(<span class="hljs-keyword">params</span>, <span class="hljs-keyword">false</span>);
    <span class="hljs-keyword">if</span> (cond.bad()) <span class="hljs-keyword">return</span> -<span class="hljs-number">3</span>;


    gethostname(localHost, <span class="hljs-keyword">sizeof</span>(localHost) - <span class="hljs-number">1</span>);
    sprintf(peerHost, <span class="hljs-string">"%s:%d"</span>, peer, OFstatic_cast(<span class="hljs-keyword">int</span>, port));
    ASC_setPresentationAddresses(<span class="hljs-keyword">params</span>, localHost, peerHost);

    cond=ASC_addPresentationContext(<span class="hljs-keyword">params</span>,<span class="hljs-number">1</span>,abstractSyntax,transferSyntaxs,transferSyntaxNum);
    <span class="hljs-keyword">if</span>(cond.bad())
        <span class="hljs-keyword">return</span> -<span class="hljs-number">4</span>;
    <span class="hljs-comment">//6）真正创建连接</span>
    cond=ASC_requestAssociation(cfindNetwork,<span class="hljs-keyword">params</span>,&amp;assoc);
    <span class="hljs-keyword">if</span> (cond.bad()) {
        <span class="hljs-keyword">if</span> (cond == DUL_ASSOCIATIONREJECTED) {
            T_ASC_RejectParameters rej;
            ASC_getRejectParameters(<span class="hljs-keyword">params</span>, &amp;rej);

            DCMNET_ERROR(<span class="hljs-string">"Association Rejected:"</span> &lt;&lt; OFendl &lt;&lt; ASC_printRejectParameters(temp_str, &amp;rej));
            <span class="hljs-keyword">return</span> -<span class="hljs-number">5</span>;
        } <span class="hljs-keyword">else</span> {
            DCMNET_ERROR(<span class="hljs-string">"Association Request Failed: "</span> &lt;&lt; DimseCondition::dump(temp_str, cond));
            <span class="hljs-keyword">return</span> -<span class="hljs-number">6</span>;
        }
    }
    <span class="hljs-comment">//7）判别返回结果</span>
    <span class="hljs-comment">//7.1)连接检验阶段，验证Presentation Context</span>
    <span class="hljs-keyword">if</span>(ASC_countAcceptedPresentationContexts(<span class="hljs-keyword">params</span>)==<span class="hljs-number">0</span>)
    {
        printf(<span class="hljs-string">"No acceptable Presentation Contexts\n"</span>);
        <span class="hljs-keyword">return</span> -<span class="hljs-number">7</span>;
    }
    T_ASC_PresentationContextID presID;
    T_DIMSE_C_FindRQ req;
    T_DIMSE_C_FindRSP rsp;
    DcmFileFormat dcmff;

    presID=ASC_findAcceptedPresentationContextID(assoc,abstractSyntax);
    <span class="hljs-keyword">if</span>(presID==<span class="hljs-number">0</span>)
    {
        printf(<span class="hljs-string">"No presentation context\n"</span>);
        <span class="hljs-keyword">return</span> -<span class="hljs-number">8</span>;
    }</code></pre> 
<h4 id="e发送c-find-rq"><font face="Microsoft YaHei" color="green">e)发送C-FIND-RQ</font></h4> 
<pre class="prettyprint"><code class=" hljs cpp"><span class="hljs-comment">//8）发起C-FIND请求</span>
    <span class="hljs-comment">//8.1）准备C-FIND-RQ message</span>
    bzero(OFreinterpret_cast(<span class="hljs-keyword">char</span>*,&amp;req),<span class="hljs-keyword">sizeof</span>(req));<span class="hljs-comment">//内存初始化为空;</span>
    <span class="hljs-built_in">strcpy</span>(req.AffectedSOPClassUID,abstractSyntax);
    req.DataSetType=DIMSE_DATASET_PRESENT;
    req.Priority=DIMSE_PRIORITY_LOW;
    <span class="hljs-comment">//设置要查询的信息为空时，待会儿查询结果中会返回</span>
    DcmDataset* dataset=<span class="hljs-keyword">new</span> DcmDataset();
    InsertQueryItems(dataset,<span class="hljs-string">"A^B^C"</span>);
    <span class="hljs-comment">//赋值自定义的回调函数，这就是该回调函数中可以进行相关信息的操作</span>
    ZSCFindCallback zsCallback;
    DcmFindSCUCallback* callback=&amp;zsCallback;
    callback-&gt;setAssociation(assoc);
    callback-&gt;setPresentationContextID(presID);
    <span class="hljs-comment">/* as long as no error occured and the counter does not equal 0 */</span>
    cond = EC_Normal;</code></pre> 
<h4 id="f设置回调函数进行自定义处理"><font face="Microsoft YaHei" color="green">f)设置回调函数，进行自定义处理</font></h4> 
<pre class="prettyprint"><code class=" hljs cs">class ZSCFindCallback:<span class="hljs-keyword">public</span> DcmFindSCUCallback
{
<span class="hljs-keyword">public</span>:
    <span class="hljs-title">ZSCFindCallback</span>()
    {

    }

    ~ZSCFindCallback()
    {

    }

    <span class="hljs-keyword">void</span> callback( T_DIMSE_C_FindRQ *request,
        <span class="hljs-keyword">int</span> responseCount,
        T_DIMSE_C_FindRSP *rsp,
        DcmDataset *rspMessage
        );

};</code></pre> 
<h4 id="g获取c-find-rsp"><font face="Microsoft YaHei" color="green">g)获取C-FIND-RSP</font></h4> 
<pre class="prettyprint"><code class=" hljs lasso"><span class="hljs-keyword">while</span> (cond<span class="hljs-built_in">.</span>good())
    {
        DcmDataset <span class="hljs-subst">*</span>statusDetail <span class="hljs-subst">=</span> <span class="hljs-built_in">NULL</span>;

        <span class="hljs-comment">/* complete preparation of C-FIND-RQ message */</span>
        req<span class="hljs-built_in">.</span>MessageID <span class="hljs-subst">=</span> assoc<span class="hljs-subst">-&gt;</span>nextMsgID<span class="hljs-subst">++</span>;

        <span class="hljs-comment">/* finally conduct transmission of data */</span>
        cond <span class="hljs-subst">=</span> DIMSE_findUser(assoc, presID, <span class="hljs-subst">&amp;</span>req, dataset,
            progressCallback, callback, DIMSE_BLOCKING, timeout,
            <span class="hljs-subst">&amp;</span>rsp, <span class="hljs-subst">&amp;</span>statusDetail);
        <span class="hljs-comment">//设置了查询采用阻塞模式，DIMSE_BLOCKING</span>
        <span class="hljs-comment">//设置连接超时为50</span>



        <span class="hljs-comment">/*
         *添加异常判别
         *
         */</span>
        cond<span class="hljs-subst">=</span>EC_EndOfStream;<span class="hljs-comment">//假设异常，返回</span>
    }</code></pre> 
<h3 id="实例测试"><font face="Microsoft YaHei" color="blue">实例测试：</font></h3> 
<p>参照之前<a href="http://blog.csdn.net/zssureqh/article/details/38775315">DICOM医学图像处理：基于DCMTK工具包学习和分析worklist</a>、<a href="http://blog.csdn.net/zssureqh/article/details/38986721">DICOM医学图像处理：利用fo-dicom发送C-Find查询Worklist</a>博文中的介绍进行测试即可，具体细节不多说，简单介绍一下：<br></p> 
<h4 id="启动worklist-scp"><font face="Microsoft YaHei" color="green">启动Worklist SCP：</font></h4> 
<p>按照之前博文介绍，构建worklist数据库，在命令行输入：<br> wlmscpfs.exe -d -dfr -dfp ./wlistdb 2234<br> 看到以下结果，说明顺利启动worklist服务端。<br><img src="https://images2.imgbox.com/f0/57/yMi8vbJn_o.jpg" alt="这里写图片描述" title=""> <br> <br></p> 
<h4 id="启动c-find-scp"><font face="Microsoft YaHei" color="green">启动C-Find SCP：</font></h4> 
<p>在VS环境下，直接运行dumpCFindResponse工程，看到如下结果：<br><img src="https://images2.imgbox.com/b6/58/pTWo7tLc_o.jpg" alt="这里写图片描述" title=""> <br> <br> 至此，自己构建的C-Find SCU顺利实现了发送C-FIND-RQ，并自定义处理C-FIND-RSP的目的。<br> <font color="red"><strong>PS:</strong>这里只是简单的给出了一个示范，要实际开发自己的C-FIND SCU和C-FIND SCP时需要考虑更多的细节，诸如PresentationContext、TransferSyntax等等。</font></p> 
<h3 id="示例工程下载"><font face="Microsoft YaHei" color="blue">示例工程下载：</font></h3> 
<p><strong>【GitHub:】</strong> <a href="https://github.com/zssure-thu/CSDN/tree/master/dumpCFindResponse">dumpCFindResponse</a><br> <strong>【Baidu：】</strong> <a href="http://pan.baidu.com/s/1o6HqFSu" rel="nofollow">dumpCFindResponse</a><br> <strong>【CSDN：】</strong><a href="http://download.csdn.net/detail/zssureqh/8540653"> dumpCFindResponse资源下载</a><br> <br> <br> <br> <font face="Microsoft YaHei" color="blue" size="5"><strong>作者：zssure@163.com</strong></font><br> <font face="Microsoft YaHei" color="blue" size="5"><strong>时间：2015-03-28</strong></font><br></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/30cdcd4f22e2e99f6c933bff13df32bd/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">Socket错误详解及处理方法</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/08eef564b3d8677c5fb160b4d8ee817f/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">动态库的装载与卸载</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>