<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>JDK1.8 HashMap put源码剖析 - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="JDK1.8 HashMap put源码剖析" />
<meta property="og:description" content="==&gt; 学习汇总（持续更新）
==&gt; 从零搭建后端基础设施系列（一）-- 背景介绍
从一个最简单的例子开始剖析hashmap的源码
Map&lt;Integer, Integer&gt; map = new HashMap&lt;&gt;(); for (int i = 0; i &lt; 10; i&#43;&#43;) { map.put(i, i); } 内部都发生了什么？ 跟着put方法进去看看
public V put(K key, V value) { return putVal(hash(key), key, value, false, true); } hash(key)这个方法是干嘛的？ 继续跟着hash(key)进去看看
static final int hash(Object key) { int h; return (key == null) ? 0 : (h = key.hashCode()) ^ (h &gt;&gt;&gt; 16); } 咋一看，看不太懂，(h = key.hashCode()) ^ (h &gt;&gt;&gt; 16)这个的目的是什么？" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/394c89ec3b4c7c929c21a1a4af4a48d1/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2019-06-30T02:45:44+08:00" />
<meta property="article:modified_time" content="2019-06-30T02:45:44+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">JDK1.8 HashMap put源码剖析</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-light">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p>==&gt; <b><a href="https://xiejun.blog.csdn.net/article/details/103036852" rel="nofollow">学习汇总（持续更新）</a></b><br> ==&gt; <b><a href="https://xiejun.blog.csdn.net/article/details/96602739" rel="nofollow">从零搭建后端基础设施系列（一）-- 背景介绍</a></b></p> 
<hr> 
<p><font color="red" size="5"><u><b>从一个最简单的例子开始剖析hashmap的源码</b></u></font></p> 
<pre><code>Map&lt;Integer, Integer&gt; map = new HashMap&lt;&gt;();
for (int i = 0; i &lt; 10; i++) {
     map.put(i, i);
 }
</code></pre> 
<p><font color="red" size="5"><u><b>内部都发生了什么？</b></u></font> 跟着put方法进去看看</p> 
<pre><code>public V put(K key, V value) {
 	return putVal(hash(key), key, value, false, true);
}
</code></pre> 
<p><font color="red" size="5"><u><b>hash(key)这个方法是干嘛的？</b></u></font> 继续跟着hash(key)进去看看</p> 
<pre><code>static final int hash(Object key) {
 	int h;
    return (key == null) ? 0 : (h = key.hashCode()) ^ (h &gt;&gt;&gt; 16);
}
</code></pre> 
<p>咋一看，看不太懂，<font color="red" size="5"><u><b>(h = key.hashCode()) ^ (h &gt;&gt;&gt; 16)</b></u></font>这个的目的是什么？</p> 
<p>OK，让我们分析一下，key.hashCode()，对应的是Integer的hashcode，那么Integer的hashcode是什么呢？接着去看看Integer是怎样重写的hashcode。</p> 
<pre><code>@Override
public int hashCode() {
    return Integer.hashCode(value);
}

public static int hashCode(int value) {
  	return value;
}
</code></pre> 
<p>Soga，原来Integer的hashcode就是int的值啊，OK，那现在<font color="red" size="5"><u><b>h=key.hashCode()</b></u></font>的值就知道了</p> 
<p>那为什么<font color="red" size="5"><u><b>h=key.hashCode()</b></u></font>要和它的<font color="red" size="5"><u><b>低16位（h&gt;&gt;&gt;16）异或呢？</b></u></font> 这个后面再说，我们带着这个疑问继续往下探一探。</p> 
<p>好，我们现在假装已经把hash这个方法看完了，并且知道它返回了一个hash值，其实就是一个整数嘛</p> 
<p>现在我们来看一下<font color="red" size="5"><u><b>putVal</b></u></font>的入参</p> 
<pre><code>final V putVal(int hash, K key, V value, boolean onlyIfAbsent, boolean evict)
</code></pre> 
<p>提前透露一下，后面两个参数我们现在不需要关心，所以，假装看不到它。</p> 
<pre><code>final V putVal(int hash, K key, V value, boolean onlyIfAbsent,
                   boolean evict) {
        Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; int n, i;
        if ((tab = table) == null || (n = tab.length) == 0)
            n = (tab = resize()).length;
        if ((p = tab[i = (n - 1) &amp; hash]) == null)
            tab[i] = newNode(hash, key, value, null);
        else {
        	   ……
        }
        ……
 }
</code></pre> 
<p>我们先从最简单的看起，后面的现在这个例子也走不到，所以当它是空气，不?它。</p> 
<p>首先，第一个<font color="red" size="5"><u><b>if ((tab = table) == null || (n = tab.length) == 0)</b></u></font>，table==null的情况只有一种，那就是map被new出来之后，还没有put数据，大家可以看一下hashmap的构造函数，都没有对table进行初始化，对吧？<br> <font color="blue" size="4"><u><b>PS：(n = tab.length) == 0这个东东到底是什么时候会触发啊？？？把相关源码都看一遍了，也没发现，好不爽。。。不会是写着玩的吧，，，哪位大神如果知道的话，能否评论一下。。。</b></u></font></p> 
<p><u><b>OK，现在我们知道hashmap的初始化已经集成到resize这个方法里面了。</b></u></p> 
<p>接着看第二个<font color="red" size="5"><u><b>if ((p = tab[i = (n - 1) &amp; hash]) == null)</b></u></font>，咋一看，这是什么鬼，那我们先从最里面的<font color="red" size="5"><u><b>(n - 1) &amp; hash</b></u></font>说起，这其实就是 hash % (n-1)，看下面</p> 
<pre><code>a = 7, b = 14, c = 8
现在，分别求a % c和 b % c，将它们转成a &amp; (c - 1) 和 b % (c - 1)
7 &amp; (8 - 1)
0111
0111
-------
0111
=7

14 &amp; (8 - 1)
1110
0111
------
0110
=6
</code></pre> 
<p>是不是看出什么规律了，其精髓就是，<font color="red" size="5"><u><b>将2的N次方-1后，除了最高位变为0，低位全部为1，那么这时候，任何数 A &amp;（2^N - 1）得到的结果都是A的低N位。 </b></u></font></p> 
<p><font color="blue" size="4"><u><b>PS:现在知道为什么h^h&gt;&gt;&gt;16，低16位和高16位异或了吧？那就是让高16位的变化，反应到底16位上，这样才可以防止极端情况下，出现大量的hash冲突！</b></u></font></p> 
<p>所以<u><b> tab[i = (n - 1) &amp; hash]</b></u>的意思就很明显了，当定位到的桶 == null的时候，说明这个桶是空的，是可以放数据的，最后<u><b>tab[i] = newNode(hash, key, value, null)</b></u></p> 
<p>接下来就是分析，如何处理冲突的，再来个case</p> 
<pre><code>Map&lt;Integer, Integer&gt; map = new HashMap&lt;&gt;();
Random random = new Random();
for (int i = 0; i &lt; 1000000; i++) {
   map.put(random.nextInt(10000000), random.nextInt(1000000));
}
</code></pre> 
<p>现在终于可以将putVal的源码上齐了</p> 
<pre><code>final V putVal(int hash, K key, V value, boolean onlyIfAbsent,
                   boolean evict) {
        Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; int n, i;
        if ((tab = table) == null || (n = tab.length) == 0)
            n = (tab = resize()).length;
        if ((p = tab[i = (n - 1) &amp; hash]) == null)
            tab[i] = newNode(hash, key, value, null);
        else {
            Node&lt;K,V&gt; e; K k;
            if (p.hash == hash &amp;&amp;
                ((k = p.key) == key || (key != null &amp;&amp; key.equals(k))))
                e = p;
            else if (p instanceof TreeNode)
                e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(this, tab, hash, key, value);
            else {
                for (int binCount = 0; ; ++binCount) {
                    if ((e = p.next) == null) {
                        p.next = newNode(hash, key, value, null);
                        if (binCount &gt;= TREEIFY_THRESHOLD - 1) // -1 for 1st
                            treeifyBin(tab, hash);
                        break;
                    }
                    if (e.hash == hash &amp;&amp;
                        ((k = e.key) == key || (key != null &amp;&amp; key.equals(k))))
                        break;
                    p = e;
                }
            }
            if (e != null) { // existing mapping for key
                V oldValue = e.value;
                if (!onlyIfAbsent || oldValue == null)
                    e.value = value;
                afterNodeAccess(e);
                return oldValue;
            }
        }
        ++modCount;
        if (++size &gt; threshold)
            resize();
        afterNodeInsertion(evict);
        return null;
    }
</code></pre> 
<p>OK，现在终于发生冲突了，先分析第一个if<br> <font color="red" size="5"><u><b>if (p.hash == hash &amp;&amp; ((k = p.key) == key || (key != null &amp;&amp; key.equals(k))))</b></u></font></p> 
<ul><li><u><b>p.hash == hash &amp;&amp; p.key == key，说明了，hash相同的情况下，key也是可以不相同的</b></u></li><li><u><b>((k = p.key) == key || (key != null &amp;&amp; key.equals(k)))，如果key是一个复合类型的对象，那么需要用equals方法判断是否相等，而equals是可以自由重写的。</b></u></li></ul> 
<p><font color="green" size="4"><u><b>提问：如果put key后，改变key的hash值，会发生什么？</b></u></font></p> 
<p>如果重复put同一个key的话，那么我们看最下面那个if</p> 
<pre><code>if (e != null) { // existing mapping for key
    V oldValue = e.value;
    if (!onlyIfAbsent || oldValue == null)
        e.value = value;
    afterNodeAccess(e);
    return oldValue;
}
</code></pre> 
<p>如果<font color="red" size="5"><u><b>e!=null</b></u></font>，那么就判断，是否需要更新值？<br> <font color="blue" size="4"><u><b>PS:afterNodeAccess和afterNodeInsertion是有大用处的，但是对于现在又一丢丢用都没有</b></u></font></p> 
<p>接着分析第二个if<br> <font color="red" size="5"><u><b>if (p instanceof TreeNode)</b></u></font><br> 判断这个桶是不是红黑树节点<br> 如果是，那么就XXX， 现在进去putTreeVal这个方法看看<br> 此处省略1千万个字，以表达我弱鸡的N次方……</p> 
<p>接着分析最后一个else<br> 如果该桶是一个链表，那么</p> 
<ul><li><u><b>遍历到链表末尾，如果此时节点数大于等于7（TREEIFY_THRESHOLD - 1），就将链表转为红黑树。</b></u></li><li><u><b>遍历的过程中，发现有相同的key，那么就停止遍历跳出去到if(e != null)那里。</b></u></li></ul> 
<p>OK，put的方法已经分析到结尾了，就剩下两个，一个是<font color="red" size="5"><u><b>++modCount</b></u></font>，这个到底是干嘛的？一个是<font color="red" size="5"><u><b>resize()</b></u></font></p> 
<p>好的，我们先说++modCount<br> 此处省略100W个字，，，不是我菜，是留着讲另一个知识点的时候再说。</p> 
<p>最后，我们来see see resize这个方法，挺有意思的，还能引出不少的点。</p> 
<p>先来分析如何重新计算newCap和newThr</p> 
<pre><code>final Node&lt;K,V&gt;[] resize() {
        Node&lt;K,V&gt;[] oldTab = table;
        int oldCap = (oldTab == null) ? 0 : oldTab.length;
        int oldThr = threshold;
        int newCap, newThr = 0;
        if (oldCap &gt; 0) {
            if (oldCap &gt;= MAXIMUM_CAPACITY) {
                threshold = Integer.MAX_VALUE;
                return oldTab;
            }
            else if ((newCap = oldCap &lt;&lt; 1) &lt; MAXIMUM_CAPACITY &amp;&amp;
                     oldCap &gt;= DEFAULT_INITIAL_CAPACITY)
                newThr = oldThr &lt;&lt; 1; // double threshold
        }
        else if (oldThr &gt; 0) // initial capacity was placed in threshold
            newCap = oldThr;
        else {               // zero initial threshold signifies using defaults
            newCap = DEFAULT_INITIAL_CAPACITY;
            newThr = (int)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);
        }
        if (newThr == 0) {
            float ft = (float)newCap * loadFactor;
            newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (float)MAXIMUM_CAPACITY ?
                      (int)ft : Integer.MAX_VALUE);
        }
        threshold = newThr;
       ……
    }
</code></pre> 
<p>是不是咋一眼看去，WC，重新计算两个参数，给我整这么一大段。。。嘴里噼里啪啦一顿，但是身体还是很诚实的看了下去。。。</p> 
<p>其实这还不是初始化集成到resize方法惹的祸。。。</p> 
<p>接下来看<font color="red" size="5"><u><b> int oldCap = (oldTab == null) ? 0 : oldTab.length</b></u></font></p> 
<p>这一步就是为了初始化做的，如果oldCap=0，那么就直接跳过第一个if判断了，现在我们来分析这几种情况</p> 
<ul><li><u><b>oldCap=0，oldThr=0，这种情况是new HashMap&lt;&gt;()导致的，因为不指定初始容量的话，是不会初始化threshold的。然后跳到最后一个else里，就会初始化默认值</b></u></li></ul> 
<pre><code>newCap = DEFAULT_INITIAL_CAPACITY;//16
newThr = (int)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);//0.75 * 16
</code></pre> 
<ul><li><u><b>oldCap=0，oldThr &gt; 0，这种情况就是new HashMap&lt;&gt;(n)导致的，指定了初始化容量，就会初始化阈值，初始化阈值的时候，还有个有趣的方法，这里我就不分析了，这个方法的功能是返回离cap最近的2的N次方整数，例如cap=6，返回8</b></u></li></ul> 
<pre><code>static final int tableSizeFor(int cap) {
   int n = cap - 1;
    n |= n &gt;&gt;&gt; 1;
    n |= n &gt;&gt;&gt; 2;
    n |= n &gt;&gt;&gt; 4;
    n |= n &gt;&gt;&gt; 8;
    n |= n &gt;&gt;&gt; 16;
    return (n &lt; 0) ? 1 : (n &gt;= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : n + 1;
}
</code></pre> 
<ul><li><u><b>oldCap&gt;0，oldThr=0 或 oldThr &gt; 1，这种情况是已经put数据了，那么会进行以下判断 </b></u> 
  <ol><li>如果oldCap &gt; MAXIMUM_CAPACITY（1 &lt;&lt; 30），就不再扩容，并且threshold = Integer.MAX_VALUE</li><li>如果oldCap * 2 &lt; MAXIMUM_CAPACITY &amp;&amp; oldCap &gt;= DEFAULT_INITIAL_CAPACITY 就可以设置新的newThr = oldThr &lt;&lt; 1</li></ol> </li></ul> 
<pre><code>if (newThr == 0) {
  float ft = (float)newCap * loadFactor;
  newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (float)MAXIMUM_CAPACITY ?
            (int)ft : Integer.MAX_VALUE);
}
</code></pre> 
<p>这一段，就是处理当oldCap&lt;16的时候的情况</p> 
<p>OK，重新计算newCap和newThr分析完了，下面就是分配新的空间。然后重新洗牌。</p> 
<pre><code>final Node&lt;K,V&gt;[] resize() {
        ……
        @SuppressWarnings({"rawtypes","unchecked"})
        Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])new Node[newCap];
        table = newTab;
        if (oldTab != null) {
            for (int j = 0; j &lt; oldCap; ++j) {
                Node&lt;K,V&gt; e;
                if ((e = oldTab[j]) != null) {
                    oldTab[j] = null;
                    if (e.next == null)
                        newTab[e.hash &amp; (newCap - 1)] = e;
                    else if (e instanceof TreeNode)
                        ((TreeNode&lt;K,V&gt;)e).split(this, newTab, j, oldCap);
                    else { // preserve order
                        Node&lt;K,V&gt; loHead = null, loTail = null;
                        Node&lt;K,V&gt; hiHead = null, hiTail = null;
                        Node&lt;K,V&gt; next;
                        do {
                            next = e.next;
                            if ((e.hash &amp; oldCap) == 0) {
                                if (loTail == null)
                                    loHead = e;
                                else
                                    loTail.next = e;
                                loTail = e;
                            }
                            else {
                                if (hiTail == null)
                                    hiHead = e;
                                else
                                    hiTail.next = e;
                                hiTail = e;
                            }
                        } while ((e = next) != null);
                        if (loTail != null) {
                            loTail.next = null;
                            newTab[j] = loHead;
                        }
                        if (hiTail != null) {
                            hiTail.next = null;
                            newTab[j + oldCap] = hiHead;
                        }
                    }
                }
            }
        }
        return newTab;
    }
</code></pre> 
<p>和put的时候差不多，都是三部曲，要么是普通的node，要么是红黑树，要么是链表</p> 
<ul><li><u><b>普通的node处理，<font color="red">newTab[e.hash &amp; (newCap - 1)] = e</font>，相当于是重新洗了一遍牌。</b></u></li><li><u><b>红黑树，此处省略1亿个字，爱咋地咋地。</b></u></li><li><u><b>链表，这个就比较有趣了，具体看注释</b></u></li></ul> 
<pre><code>//设lo为链表A，hi为链表B
Node&lt;K,V&gt; loHead = null, loTail = null;
Node&lt;K,V&gt; hiHead = null, hiTail = null;
Node&lt;K,V&gt; next;
do {
    //取出下一个节点
    next = e.next;
    //oldCap是2的N次方，所以它肯定只有一位为0
    //那么e.hash&amp;oldCap是不是相当于随机的01出现呢？
    //所以这里这么做就是为了均匀切分链表为AB两个链表！ 
    if ((e.hash &amp; oldCap) == 0) {
        if (loTail == null)
            loHead = e;
        else
            loTail.next = e;
             loTail = e;
    }
    else {
        if (hiTail == null)
            hiHead = e;
        else
            hiTail.next = e;
        hiTail = e;
    }
} while ((e = next) != null);
//原位置就用A链表代替
if (loTail != null) {
    loTail.next = null;
    newTab[j] = loHead;
}
//j + oldCap位置就放置B链表，这样是不是相当于将链表打散了？
if (hiTail != null) {
    hiTail.next = null;
    newTab[j + oldCap] = hiHead;
}
</code></pre> 
<p><font color="green" size="4"><u><b>提问：高并发下hashmap会发生什么情况？（1.7和1.8），先说答案，1.7和1.8都有可能发生XXX，但是发生的位置不一样。</b></u></font></p> 
<p>好了，put方法就简单说到这里。<font color="red"><u><b>有问题，或者有另外的见解的，欢迎讨论！本人专门承接各种疑难杂症，但是不包治，哈哈哈。</b></u></font></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/f853ecf8f8ca9f903db49a87e58657a9/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">LeetCode每日一题——T20. 有效的括号（易）：栈、哈希表</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/84b0ba2aaa77f9dbb68a10530c227c76/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">Python Matplotlib绘制柱状图（bar和barh函数）详解</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>