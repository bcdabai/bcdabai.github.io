<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>mybatis的缓存 - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="mybatis的缓存" />
<meta property="og:description" content="目录
1.什么是缓存
2.mybatis的缓存
2.1一级缓存
2.2 二级缓存
2.2.1 开启二级缓存
2.2.2 在映射文件中使用二级缓存
2.2.3 实体一定要实现序列化接口
2.2.4 二级缓存测试
1.什么是缓存 缓存就是数据交换的缓冲区，当某一硬件要读取数据时，会首先从缓存中查找需要的数据，如果找到了则直接执行，找不到的话则从内存中找。由于缓存的运行速度比内存快得多，故缓存的作用就是帮助硬件更快地运行。
例如 mysql数据库中的数据存在表内也就是在磁盘上。 查询时程序IO读取磁盘的数据，添加时io向磁盘添加数据。
经常查询并且不经常改变的，数据的正确与否对最终结果影响不大的； 这些数据适合放在缓存中。经常改变的数据；数据的正确与否对最终结果影响很大的；---数据安全性要求不高。例如：商品的库存，银行的汇率，股市的牌价； 这些数据不适合放在缓存区。
2.mybatis的缓存 MyBatis 内置了一个强大的事务性查询缓存机制，它可以非常方便地配置和定制。
mybatis支持两种缓存：
（1）一级缓存----基于SqlSession级别的缓存，底层就是一个hashmap。默认一级缓存是开启的，不能关闭。同一个sqlsession中执行相同的sql查询（相同的sql和参数），第一次会去查询数据库并写到缓存中，第二次从一级缓存中取。当执行SQL时候两次查询中间发生了增删改的操作，则SQLSession的缓存会被清空，这样做的目的为了让缓存中存储的是最新的信息，避免脏读。
（2）二级缓存--基于SqlSessionFactory级别的缓存，它可以做到多个SqlSession共享数据。默认它是关闭。需要手动开启。 要启用全局的二级缓存，需要在你的 SQL 映射文件中添加一行语句。
2.1一级缓存 一级缓存基于sqlSession完成的一级缓存，第一次查询编号=2的用户信息--缓存不能命中，则向数据库查询发送sql语句、把查询的结果放入缓存中。当sqlSession不关闭时，不需要再在数据库调数据，而是在缓存中直接调取。下面是测试类及控制台显示只调取一次sql语句。
@Test public void testSession(){ User user = userMapper.getUser(2); User user1 = userMapper.getUser(2); } 2022-06-06 19:07:21,399 [main] DEBUG [com.qy151wd.mapper.UserMapper.getUser] - ==&gt; Preparing: select * from tb_user where id=?
2022-06-06 19:07:21,448 [main] DEBUG [com.qy151wd.mapper.UserMapper.getUser] - ==&gt; Parameters: 2(Integer)" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/1f240f29e669a56e84f3c0618ec7c6dc/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-06-06T21:05:43+08:00" />
<meta property="article:modified_time" content="2022-06-06T21:05:43+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">mybatis的缓存</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p id="main-toc"><strong>目录</strong></p> 
<p id="1.%E4%BB%80%E4%B9%88%E6%98%AF%E7%BC%93%E5%AD%98-toc" style="margin-left:0px;"><a href="#1.%E4%BB%80%E4%B9%88%E6%98%AF%E7%BC%93%E5%AD%98" rel="nofollow">1.什么是缓存</a></p> 
<p id="2.mybatis%E7%9A%84%E7%BC%93%E5%AD%98-toc" style="margin-left:0px;"><a href="#2.mybatis%E7%9A%84%E7%BC%93%E5%AD%98" rel="nofollow">2.mybatis的缓存</a></p> 
<p id="2.1%E4%B8%80%E7%BA%A7%E7%BC%93%E5%AD%98-toc" style="margin-left:40px;"><a href="#2.1%E4%B8%80%E7%BA%A7%E7%BC%93%E5%AD%98" rel="nofollow">2.1一级缓存</a></p> 
<p id="%C2%A02.2%20%E4%BA%8C%E7%BA%A7%E7%BC%93%E5%AD%98-toc" style="margin-left:40px;"><a href="#%C2%A02.2%20%E4%BA%8C%E7%BA%A7%E7%BC%93%E5%AD%98" rel="nofollow"> 2.2 二级缓存</a></p> 
<p id="2.2.1%20%E5%BC%80%E5%90%AF%E4%BA%8C%E7%BA%A7%E7%BC%93%E5%AD%98-toc" style="margin-left:80px;"><a href="#2.2.1%20%E5%BC%80%E5%90%AF%E4%BA%8C%E7%BA%A7%E7%BC%93%E5%AD%98" rel="nofollow">2.2.1 开启二级缓存</a></p> 
<p id="2.2.2%20%E5%9C%A8%E6%98%A0%E5%B0%84%E6%96%87%E4%BB%B6%E4%B8%AD%E4%BD%BF%E7%94%A8%E4%BA%8C%E7%BA%A7%E7%BC%93%E5%AD%98-toc" style="margin-left:80px;"><a href="#2.2.2%20%E5%9C%A8%E6%98%A0%E5%B0%84%E6%96%87%E4%BB%B6%E4%B8%AD%E4%BD%BF%E7%94%A8%E4%BA%8C%E7%BA%A7%E7%BC%93%E5%AD%98" rel="nofollow">2.2.2 在映射文件中使用二级缓存</a></p> 
<p id="2.2.3%20%E5%AE%9E%E4%BD%93%E4%B8%80%E5%AE%9A%E8%A6%81%E5%AE%9E%E7%8E%B0%E5%BA%8F%E5%88%97%E5%8C%96%E6%8E%A5%E5%8F%A3-toc" style="margin-left:80px;"><a href="#2.2.3%20%E5%AE%9E%E4%BD%93%E4%B8%80%E5%AE%9A%E8%A6%81%E5%AE%9E%E7%8E%B0%E5%BA%8F%E5%88%97%E5%8C%96%E6%8E%A5%E5%8F%A3" rel="nofollow">2.2.3 实体一定要实现序列化接口</a></p> 
<p id="%C2%A02.2.4%20%E4%BA%8C%E7%BA%A7%E7%BC%93%E5%AD%98%E6%B5%8B%E8%AF%95-toc" style="margin-left:80px;"><a href="#%C2%A02.2.4%20%E4%BA%8C%E7%BA%A7%E7%BC%93%E5%AD%98%E6%B5%8B%E8%AF%95" rel="nofollow"> 2.2.4 二级缓存测试</a></p> 
<hr id="hr-toc"> 
<p></p> 
<h2>1.什么是缓存</h2> 
<p>        缓存就是数据交换的缓冲区，当某一硬件要读取数据时，会首先从缓存中查找需要的数据，如果找到了则直接执行，找不到的话则从内存中找。由于缓存的运行速度比内存快得多，故缓存的作用就是帮助硬件更快地运行。</p> 
<p>        例如 mysql数据库中的数据存在表内也就是在磁盘上。 查询时程序IO读取磁盘的数据，添加时io向磁盘添加数据。</p> 
<p>        经常查询并且不经常改变的，数据的正确与否对最终结果影响不大的； 这些数据适合放在缓存中。经常改变的数据；数据的正确与否对最终结果影响很大的；---数据安全性要求不高。例如：商品的库存，银行的汇率，股市的牌价； 这些数据不适合放在缓存区。</p> 
<h2 id="2.mybatis%E7%9A%84%E7%BC%93%E5%AD%98">2.mybatis的缓存</h2> 
<p>        MyBatis 内置了一个强大的事务性查询缓存机制，它可以非常方便地配置和定制。</p> 
<p>        mybatis支持两种缓存：</p> 
<p>                （1）一级缓存----基于SqlSession级别的缓存，底层就是一个hashmap。默认一级缓存是开启的，不能关闭。同一个sqlsession中执行相同的sql查询（相同的sql和参数），第一次会去查询数据库并写到缓存中，第二次从一级缓存中取。当执行SQL时候两次查询中间发生了增删改的操作，则SQLSession的缓存会被清空，这样做的目的为了让缓存中存储的是最新的信息，避免脏读。</p> 
<p>                （2）二级缓存--基于SqlSessionFactory级别的缓存，它可以做到多个SqlSession共享数据。默认它是关闭。需要手动开启。 要启用全局的二级缓存，需要在你的 SQL 映射文件中添加一行语句。</p> 
<h3 id="2.1%E4%B8%80%E7%BA%A7%E7%BC%93%E5%AD%98">2.1一级缓存</h3> 
<p>        一级缓存基于sqlSession完成的一级缓存，第一次查询编号=2的用户信息--缓存不能命中，则向数据库查询发送sql语句、把查询的结果放入缓存中。当sqlSession不关闭时，不需要再在数据库调数据，而是在缓存中直接调取。下面是测试类及控制台显示只调取一次sql语句。</p> 
<pre><code class="language-java">
    @Test
    public void testSession(){
        User user = userMapper.getUser(2);
        User user1 = userMapper.getUser(2);

    }</code></pre> 
<blockquote> 
 <p>2022-06-06 19:07:21,399 [main] DEBUG [com.qy151wd.mapper.UserMapper.getUser] - ==&gt;  Preparing: select * from tb_user where id=?<br> 2022-06-06 19:07:21,448 [main] DEBUG [com.qy151wd.mapper.UserMapper.getUser] - ==&gt; Parameters: 2(Integer)<br> 2022-06-06 19:07:21,494 [main] DEBUG [com.qy151wd.mapper.UserMapper.getUser] - &lt;==      Total: 1</p> 
</blockquote> 
<p>        当一个sqlSession关闭时，开启另一个sqlSession语句会重新进行数据库数据调取，会出现两条调取数据库的信息。</p> 
<pre><code class="language-java"> @Test
    public void testSession(){
        User user = userMapper.getUser(2);
        User user1 = userMapper.getUser(2);
       sqlSession.close();
       SqlSession sqlSession1=sqlSessionFactory.openSession();
        UserMapper mapper1 = sqlSession1.getMapper(UserMapper.class);
        mapper1.getUser(2);

    }</code></pre> 
<blockquote> 
 <p>2022-06-06 21:03:16,530 [main] DEBUG [com.qy151wd.mapper.UserMapper.getUser] - ==&gt;  Preparing: select * from tb_user where id=?<br> 2022-06-06 21:03:16,576 [main] DEBUG [com.qy151wd.mapper.UserMapper.getUser] - ==&gt; Parameters: 2(Integer)<br> 2022-06-06 21:03:16,618 [main] DEBUG [com.qy151wd.mapper.UserMapper.getUser] - &lt;==      Total: 1<br> 2022-06-06 21:03:16,623 [main] DEBUG [com.qy151wd.mapper.UserMapper.getUser] - ==&gt;  Preparing: select * from tb_user where id=?<br> 2022-06-06 21:03:16,624 [main] DEBUG [com.qy151wd.mapper.UserMapper.getUser] - ==&gt; Parameters: 2(Integer)<br> 2022-06-06 21:03:16,628 [main] DEBUG [com.qy151wd.mapper.UserMapper.getUser] - &lt;==      Total: 1</p> 
</blockquote> 
<h3 id="%C2%A02.2%20%E4%BA%8C%E7%BA%A7%E7%BC%93%E5%AD%98"> 2.2 二级缓存</h3> 
<h4 id="2.2.1%20%E5%BC%80%E5%90%AF%E4%BA%8C%E7%BA%A7%E7%BC%93%E5%AD%98">2.2.1 开启二级缓存</h4> 
<pre><code class="language-XML">&lt;settings&gt;
        &lt;!--开启二级缓存（conf.xml内）--&gt;
        &lt;setting name="cacheEnabled" value="true"/&gt;
    &lt;/settings&gt;</code></pre> 
<h4 id="2.2.2%20%E5%9C%A8%E6%98%A0%E5%B0%84%E6%96%87%E4%BB%B6%E4%B8%AD%E4%BD%BF%E7%94%A8%E4%BA%8C%E7%BA%A7%E7%BC%93%E5%AD%98">2.2.2 在映射文件中使用二级缓存</h4> 
<pre><code class="language-XML">&lt;!--使用二级缓存 这里面的所有查询都使用了二级缓存（对应mapper.xml内）--&gt;
  &lt;cache/&gt;</code></pre> 
<pre><code class="language-XML">&lt;!--部分开启二级缓存,此处不使用二级缓存--&gt;
&lt;select id="getUser" parameterType="int" resultType="com.qy151wd.entity.User" useCache="false"&gt;
        select * from tb_user where id=#{id}
    &lt;/select&gt;</code></pre> 
<h4 id="2.2.3%20%E5%AE%9E%E4%BD%93%E4%B8%80%E5%AE%9A%E8%A6%81%E5%AE%9E%E7%8E%B0%E5%BA%8F%E5%88%97%E5%8C%96%E6%8E%A5%E5%8F%A3">2.2.3 实体一定要实现序列化接口</h4> 
<p class="img-center"><img alt="" height="237" src="https://images2.imgbox.com/a1/c5/5kj2J6nO_o.png" width="389"></p> 
<h4 id="%C2%A02.2.4%20%E4%BA%8C%E7%BA%A7%E7%BC%93%E5%AD%98%E6%B5%8B%E8%AF%95"> 2.2.4 二级缓存测试</h4> 
<p>        如果开启了二级缓存，那么在关闭sqlsession后(close)，才会把该sqlsession一级缓存中的数据添加到namespace的二级缓存中。所查询的结果会放入一级缓存和二级缓存，若二级缓存能命中，则直接从二级缓存中调取数据，若不能命中，会到一级缓存中去查看是否命中，若能则直接调取数据，若不能则进入数据库调取。查询顺序是二级缓存、一级缓存、数据库。</p> 
<pre><code class="language-java">@Test
    public void testSessionSecond(){
        User user = userMapper.getUser(2);
        User user1 = userMapper.getUser(2);
        sqlSession.close();
        SqlSession sqlSession1=sqlSessionFactory.openSession();
        UserMapper mapper1 = sqlSession1.getMapper(UserMapper.class);
        mapper1.getUser(2);

    }</code></pre> 
<blockquote> 
 <p>2022-06-06 19:51:17,391 [main] DEBUG [com.qy151wd.mapper.UserMapper] - Cache Hit Ratio [com.qy151wd.mapper.UserMapper]: 0.0<br> 2022-06-06 19:51:18,516 [main] DEBUG [com.qy151wd.mapper.UserMapper.getUser] - ==&gt;  Preparing: select * from tb_user where id=?<br> 2022-06-06 19:51:18,564 [main] DEBUG [com.qy151wd.mapper.UserMapper.getUser] - ==&gt; Parameters: 2(Integer)<br> 2022-06-06 19:51:18,593 [main] DEBUG [com.qy151wd.mapper.UserMapper.getUser] - &lt;==      Total: 1<br> 2022-06-06 19:51:18,597 [main] DEBUG [com.qy151wd.mapper.UserMapper] - Cache Hit Ratio [com.qy151wd.mapper.UserMapper]: 0.0<br> 2022-06-06 19:51:18,604 [main] WARN  [org.apache.ibatis.io.SerialFilterChecker] - As you are using functionality that deserializes object streams, it is recommended to define the JEP-290 serial filter. Please refer to https://docs.oracle.com/pls/topic/lookup?ctx=javase15&amp;id=GUID-8296D8E8-2B93-4B9A-856E-0A65AF9B8C66<br> 2022-06-06 19:51:18,607 [main] DEBUG [com.qy151wd.mapper.UserMapper] - Cache Hit Ratio [com.qy151wd.mapper.UserMapper]: 0.3333333333333333</p> 
</blockquote>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/089865ae31404e40467507601a6be811/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">全网唯一的、DIY的Prometheus主备方案，生产未上，测试先行。</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/091038a8bfd35dfe0cb1146b48be056b/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">5G NR 概念之~MCG/SCG/PCell/PSCell/SCellsPCell</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>