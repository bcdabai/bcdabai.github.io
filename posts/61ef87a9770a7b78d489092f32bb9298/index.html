<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>图像特征匹配-SIFT函数应用【opencv】 - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="图像特征匹配-SIFT函数应用【opencv】" />
<meta property="og:description" content="目录 相关函数sift.detectAndComputecv.drawKeypointscv.KeyPointcv2.BFMatcher 相关函数 OpenCV中SIFT（Scale-Invariant Feature Transform）算法的一个重要函数。SIFT算法是一种用于图像特征提取和匹配的经典方法，可以在图像中提取出具有尺度不变性、旋转不变性和部分视角不变性的特征点和特征描述子
sift.detectAndCompute 功能
detectAndCompute函数执行两个主要任务：
（1）检测图像中的关键点（Key Points）。
（2） 计算图像中每个关键点的特征描述子（Feature Descriptors）。输入参数
image: 输入的灰度图像或彩色图像，类型为uint8或float32。
mask（可选）: 可选的掩膜图像，指定哪些区域需要进行特征检测。如果不需要，可以将其设置为None。
kp（可选）: 可选的输入关键点。如果提供关键点，则函数将不再检测关键点，而是直接使用输入的关键点。如果不需要，可以将其设置为None。
descriptors（可选）: 可选的输入特征描述子。如果提供特征描述子，则函数将不再计算特征描述子，而是直接使用输入的描述子。如果不需要，可以将其设置为None。输出结果
kp: 检测到的关键点列表，每个关键点是一个cv2.KeyPoint对象，其中包含关键点的坐标（x、y）、尺度（scale）和方向（angle）等信息。
des: 计算得到的特征描述子，是一个numpy数组，形状为(n, 128)，其中n是关键点的数量，128表示每个特征描述子的维度为128。使用案例 import cv2 # 读取图像 image = cv2.imread(&#34;example.jpg&#34;, cv2.IMREAD_GRAYSCALE) # 创建SIFT对象 sift = cv2.SIFT_create() # 检测关键点并计算特征描述子 kp, des = sift.detectAndCompute(image, None) # 绘制关键点到图像上 image_with_keypoints = cv2.drawKeypoints(image, kp, None) # 显示结果 cv2.imshow(&#34;Image with Keypoints&#34;, image_with_keypoints) cv2.waitKey(0) cv2.destroyAllWindows() cv.drawKeypoints cv.drawKeypoints是OpenCV库中的一个函数，用于在图像上绘制特征点。
函数原型 cv.drawKeypoints(image, keypoints, outImage[, color[, flags]]) 参数说明" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/61ef87a9770a7b78d489092f32bb9298/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-08-04T10:55:08+08:00" />
<meta property="article:modified_time" content="2023-08-04T10:55:08+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">图像特征匹配-SIFT函数应用【opencv】</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-tomorrow-night">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p></p> 
<div class="toc"> 
 <h4>目录</h4> 
 <ul><li><a href="#_1" rel="nofollow">相关函数</a></li><li><ul><li><a href="#siftdetectAndCompute_3" rel="nofollow">sift.detectAndCompute</a></li><li><a href="#cvdrawKeypoints_40" rel="nofollow">cv.drawKeypoints</a></li><li><a href="#cvKeyPoint_67" rel="nofollow">cv.KeyPoint</a></li><li><a href="#cv2BFMatcher_128" rel="nofollow">cv2.BFMatcher</a></li></ul> 
 </li></ul> 
</div> 
<p></p> 
<h2><a id="_1"></a>相关函数</h2> 
<p>OpenCV中SIFT（Scale-Invariant Feature Transform）算法的一个重要函数。SIFT算法是一种用于图像特征提取和匹配的经典方法，可以在图像中提取出具有<strong>尺度不变性、旋转不变性和部分视角不变性</strong>的<strong>特征点</strong>和<strong>特征描述子</strong></p> 
<h3><a id="siftdetectAndCompute_3"></a>sift.detectAndCompute</h3> 
<ol><li>功能<br> detectAndCompute函数执行两个主要任务：<br> （1）检测图像中的关键点（Key Points）。<br> （2） 计算图像中每个关键点的特征描述子（Feature Descriptors）。</li><li>输入参数<br> <strong>image</strong>: 输入的灰度图像或彩色图像，类型为uint8或float32。<br> <strong>mask</strong>（可选）: 可选的掩膜图像，指定哪些区域需要进行特征检测。如果不需要，可以将其设置为None。<br> kp（可选）: 可选的输入关键点。如果提供关键点，则函数将不再检测关键点，而是直接使用输入的关键点。如果不需要，可以将其设置为None。<br> descriptors（可选）: 可选的输入特征描述子。如果提供特征描述子，则函数将不再计算特征描述子，而是直接使用输入的描述子。如果不需要，可以将其设置为None。</li><li>输出结果<br> <strong>kp</strong>: 检测到的关键点列表，每个关键点是一个cv2.KeyPoint对象，其中包含关键点的坐标（x、y）、尺度（scale）和方向（angle）等信息。<br> <strong>des</strong>: 计算得到的特征描述子，是一个numpy数组，形状为(n, 128)，其中n是关键点的数量，128表示每个特征描述子的维度为128。</li><li>使用案例</li></ol> 
<pre><code class="prism language-python"><span class="token keyword">import</span> cv2

<span class="token comment"># 读取图像</span>
image <span class="token operator">=</span> cv2<span class="token punctuation">.</span>imread<span class="token punctuation">(</span><span class="token string">"example.jpg"</span><span class="token punctuation">,</span> cv2<span class="token punctuation">.</span>IMREAD_GRAYSCALE<span class="token punctuation">)</span>

<span class="token comment"># 创建SIFT对象</span>
sift <span class="token operator">=</span> cv2<span class="token punctuation">.</span>SIFT_create<span class="token punctuation">(</span><span class="token punctuation">)</span>

<span class="token comment"># 检测关键点并计算特征描述子</span>
kp<span class="token punctuation">,</span> des <span class="token operator">=</span> sift<span class="token punctuation">.</span>detectAndCompute<span class="token punctuation">(</span>image<span class="token punctuation">,</span> <span class="token boolean">None</span><span class="token punctuation">)</span>

<span class="token comment"># 绘制关键点到图像上</span>
image_with_keypoints <span class="token operator">=</span> cv2<span class="token punctuation">.</span>drawKeypoints<span class="token punctuation">(</span>image<span class="token punctuation">,</span> kp<span class="token punctuation">,</span> <span class="token boolean">None</span><span class="token punctuation">)</span>

<span class="token comment"># 显示结果</span>
cv2<span class="token punctuation">.</span>imshow<span class="token punctuation">(</span><span class="token string">"Image with Keypoints"</span><span class="token punctuation">,</span> image_with_keypoints<span class="token punctuation">)</span>
cv2<span class="token punctuation">.</span>waitKey<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span>
cv2<span class="token punctuation">.</span>destroyAllWindows<span class="token punctuation">(</span><span class="token punctuation">)</span>

</code></pre> 
<h3><a id="cvdrawKeypoints_40"></a>cv.drawKeypoints</h3> 
<p>cv.drawKeypoints是OpenCV库中的一个函数，用于在图像上绘制特征点。</p> 
<ol><li><strong>函数原型</strong></li></ol> 
<pre><code class="prism language-python">cv<span class="token punctuation">.</span>drawKeypoints<span class="token punctuation">(</span>image<span class="token punctuation">,</span> keypoints<span class="token punctuation">,</span> outImage<span class="token punctuation">[</span><span class="token punctuation">,</span> color<span class="token punctuation">[</span><span class="token punctuation">,</span> flags<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
</code></pre> 
<ol start="2"><li> <p><strong>参数说明</strong><br> （1）<strong>image</strong>：输入的图像，即要在其上绘制特征点的图像。它应该是一个灰度图像或彩色图像，类型为numpy.ndarray。<br> （2）<strong>keypoints</strong>：一个包含特征点信息的列表。每个特征点都是一个cv.KeyPoint对象，其中包含特征点的坐标、大小、方向等信息。<br> （3）<strong>outImage</strong>：输出图像，即将特征点绘制在其上的图像。这应该是一个和image具有相同尺寸和通道数的图像，类型为numpy.ndarray。<br> （4）<strong>color</strong> (可选)：特征点的颜色。默认为随机颜色。可以通过(B, G, R)形式的元组来指定BGR颜色，例如(0, 255, 0)表示绿色。<br> （4）<strong>flags</strong> (可选)：特征点绘制的标志。可以使用以下值：<br> <strong>cv.DRAW_MATCHES_FLAGS_DEFAULT</strong>：默认值，单个特征点用圆圈表示，显示特征点的大小和方向。<br> <strong>cv.DRAW_MATCHES_FLAGS_DRAW_RICH_KEYPOINTS</strong>：绘制特征点的大小和方向，但使用特征点的尺寸和方向来显示特征点。</p> </li><li> <p><strong>输出特点</strong><br> （1）<strong>outImage</strong>是一个新的图像，是输入图像的副本，并在其上绘制了特征点。<strong>原始图像不会被修改</strong>。<br> （2）特征点会以可视化的形式显示在输出图像上。通常，特征点会用圆圈表示，并根据特征点的大小和方向进行标记。<br> （3）如果未指定颜色，函数会为每个特征点选择一个随机颜色，使得特征点在输出图像上可以区分开。</p> </li><li> <p><strong>笔记</strong>:<br> 在计算机视觉领域，特征点的大小通常指的是特征点在图像中的尺寸，也称为特征点的尺度。它是描述特征点周围区域大小的一个重要属性。<br> 特征点检测算法通常会在图像中寻找具有不同尺度的特征点，因为<strong>不同尺度的特征点对于不同大小的目标和场景变化更具有鲁棒性</strong>。例如，在图像中找到一个突出的角点，可能在不同的图像尺度下具有不同的大小。<strong>特征点的尺度可以看作是特征点检测器所考虑的一个区域的大小</strong>，用来描述特征点周围的局部图像结构。<br> <strong>一般来说，尺度较大的特征点对应于较大的图像结构或目标，而尺度较小的特征点对应于更细微的图像细节</strong>。特征点的尺度信息在后续的特征匹配和目标识别任务中起着至关重要的作用。例如，在特征点匹配中，我们可能希望将具有相似尺度的特征点进行匹配，因为它们可能对应于相似大小的目标。<br> <strong>在cv.DRAW_MATCHES_FLAGS_DRAW_RICH_KEYPOINTS标志下，绘制特征点时会使用特征点的大小和方向信息</strong>。这样可以以视觉化的方式显示特征点的大小，并且在可视化特征点的同时也展示了它们的尺度和方向信息，使得结果更加丰富和信息丰富。<br> 在cv.DRAW_MATCHES_FLAGS_DRAW_RICH_KEYPOINTS标志下，特征点的大小和方向信息是通过<strong>cv.KeyPoint</strong>对象的属性来确定的。</p> </li></ol> 
<h3><a id="cvKeyPoint_67"></a>cv.KeyPoint</h3> 
<p>链接：<a href="https://docs.opencv.org/3.4/d2/d29/classcv_1_1KeyPoint.html#a507d41b54805e9ee5042b922e68e4372" rel="nofollow">cv::KeyPoint::KeyPoint </a></p> 
<pre><code class="prism language-cpp">cv<span class="token double-colon punctuation">::</span><span class="token class-name">KeyPoint</span><span class="token double-colon punctuation">::</span><span class="token function">KeyPoint</span><span class="token punctuation">(</span> Point2f pt<span class="token punctuation">,</span>
						<span class="token keyword">float</span> 	size<span class="token punctuation">,</span>
						<span class="token keyword">float</span> 	angle <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span>
						<span class="token keyword">float</span> 	response <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span>
						<span class="token keyword">int</span> 	octave <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span>
						<span class="token keyword">int</span> 	class_id <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span> 
						<span class="token punctuation">)</span>	
</code></pre> 
<p>cv.KeyPoint是一个类，它代表了一个特征点，其中包含以下属性：</p> 
<ol><li><strong>相关参数</strong><br> （1）<strong>pt</strong>：特征点的位置坐标，通常为(x, y)的二维点。<br> （2）<strong>size</strong>：特征点的尺度或大小。这个值用来表示特征点检测器在特征点周围选择的区域大小，用来描述特征点的局部结构。通常，size可以理解为特征点的邻域半径。<br> （3）<strong>angle</strong>：特征点的方向或角度。这个值表示特征点在局部区域内的主要方向。在一些特征点检测算法中，特征点是具有主方向的，比如SIFT（尺度不变特征变换）算法。<br> （4）<strong>response</strong>：特征点的响应值，表示检测器对该特征点的检测置信度或强度。在某些检测器中，响应值可以用来过滤掉一些不够显著的特征点。<br> （5）<strong>octave</strong>：特征点所在的金字塔组（octave）。一些尺度空间的特征点检测器，如SIFT，通过图像金字塔来检测不同尺度的特征点。<br> （6）<strong>class_id</strong>：特征点的类别ID，通常用于区分不同类别的特征点。<br> 当使用cv.DRAW_MATCHES_FLAGS_DRAW_RICH_KEYPOINTS标志绘制特征点时，会根据特征点的<strong>size和angle</strong>属性来决定绘制的样式。一般来说，特征点会以圆圈的形式绘制，<strong>圆圈的半径与特征点的size属性相关联，而箭头的方向表示特征点的angle属性</strong>。<br> 需要注意的是，<strong>不同的特征点检测器可能会提供不同的属性信息</strong>。某些检测器可能没有angle属性，因为它们不计算特征点的方向，而只关注特征点的位置和尺度。因此，在使用特定的特征点检测器时，需要了解其输出的cv.KeyPoint对象的属性，并根据需要使用相应的属性来绘制特征点。</li><li><strong>示例程序</strong></li></ol> 
<pre><code class="prism language-python"><span class="token keyword">import</span> cv2
<span class="token keyword">import</span> numpy <span class="token keyword">as</span> np

<span class="token keyword">def</span> <span class="token function">detect_and_display_keypoints</span><span class="token punctuation">(</span>image_path<span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token comment"># 读取图像</span>
    image <span class="token operator">=</span> cv2<span class="token punctuation">.</span>imread<span class="token punctuation">(</span>image_path<span class="token punctuation">,</span> cv2<span class="token punctuation">.</span>IMREAD_GRAYSCALE<span class="token punctuation">)</span>

    <span class="token comment"># 创建SIFT特征点检测器</span>
    sift <span class="token operator">=</span> cv2<span class="token punctuation">.</span>SIFT_create<span class="token punctuation">(</span><span class="token punctuation">)</span>

    <span class="token comment"># 检测特征点</span>
    keypoints <span class="token operator">=</span> sift<span class="token punctuation">.</span>detect<span class="token punctuation">(</span>image<span class="token punctuation">,</span> <span class="token boolean">None</span><span class="token punctuation">)</span>

    <span class="token comment"># 绘制特征点</span>
    image_with_keypoints <span class="token operator">=</span> cv2<span class="token punctuation">.</span>drawKeypoints<span class="token punctuation">(</span>image<span class="token punctuation">,</span> keypoints<span class="token punctuation">,</span> <span class="token boolean">None</span><span class="token punctuation">,</span> flags<span class="token operator">=</span>cv2<span class="token punctuation">.</span>DRAW_MATCHES_FLAGS_DRAW_RICH_KEYPOINTS<span class="token punctuation">)</span>

    <span class="token comment"># 输出特征点信息</span>
    <span class="token keyword">for</span> i<span class="token punctuation">,</span> kp <span class="token keyword">in</span> <span class="token builtin">enumerate</span><span class="token punctuation">(</span>keypoints<span class="token punctuation">)</span><span class="token punctuation">:</span>
        <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string-interpolation"><span class="token string">f"特征点 </span><span class="token interpolation"><span class="token punctuation">{<!-- --></span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">}</span></span><span class="token string">:"</span></span><span class="token punctuation">)</span>
        <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string-interpolation"><span class="token string">f"  位置: (</span><span class="token interpolation"><span class="token punctuation">{<!-- --></span>kp<span class="token punctuation">.</span>pt<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">}</span></span><span class="token string">, </span><span class="token interpolation"><span class="token punctuation">{<!-- --></span>kp<span class="token punctuation">.</span>pt<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">}</span></span><span class="token string">)"</span></span><span class="token punctuation">)</span>
        <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string-interpolation"><span class="token string">f"  尺度: </span><span class="token interpolation"><span class="token punctuation">{<!-- --></span>kp<span class="token punctuation">.</span>size<span class="token punctuation">}</span></span><span class="token string">"</span></span><span class="token punctuation">)</span>
        <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string-interpolation"><span class="token string">f"  方向: </span><span class="token interpolation"><span class="token punctuation">{<!-- --></span>kp<span class="token punctuation">.</span>angle<span class="token punctuation">}</span></span><span class="token string">"</span></span><span class="token punctuation">)</span>
        <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string-interpolation"><span class="token string">f"  金字塔组: </span><span class="token interpolation"><span class="token punctuation">{<!-- --></span>kp<span class="token punctuation">.</span>octave <span class="token operator">&amp;</span> <span class="token number">0xFF</span><span class="token punctuation">}</span></span><span class="token string">"</span></span><span class="token punctuation">)</span> <span class="token comment"># 提取低8位作为金字塔组</span>
        <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string-interpolation"><span class="token string">f"  类别ID: </span><span class="token interpolation"><span class="token punctuation">{<!-- --></span>kp<span class="token punctuation">.</span>class_id<span class="token punctuation">}</span></span><span class="token string">"</span></span><span class="token punctuation">)</span>
        <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token punctuation">)</span>

    <span class="token comment"># 显示图像并等待按键退出</span>
    cv2<span class="token punctuation">.</span>imshow<span class="token punctuation">(</span><span class="token string">'Keypoints'</span><span class="token punctuation">,</span> image_with_keypoints<span class="token punctuation">)</span>
    cv2<span class="token punctuation">.</span>waitKey<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span>
    cv2<span class="token punctuation">.</span>destroyAllWindows<span class="token punctuation">(</span><span class="token punctuation">)</span>

<span class="token keyword">if</span> __name__ <span class="token operator">==</span> <span class="token string">"__main__"</span><span class="token punctuation">:</span>
    image_path <span class="token operator">=</span> <span class="token string">"path/to/your/image.jpg"</span>  <span class="token comment"># 替换为实际图像路径</span>
    detect_and_display_keypoints<span class="token punctuation">(</span>image_path<span class="token punctuation">)</span>
</code></pre> 
<h3><a id="cv2BFMatcher_128"></a>cv2.BFMatcher</h3> 
<p>cv2.BFMatcher是OpenCV中用于创建暴力匹配器（Brute Force Matcher）的类，通常使用方式如下：</p> 
<pre><code class="prism language-python"><span class="token comment"># 创建BFMatcher对象</span>
bf <span class="token operator">=</span> cv2<span class="token punctuation">.</span>BFMatcher<span class="token punctuation">(</span><span class="token punctuation">)</span>

<span class="token comment"># 使用KNN匹配特征</span>
matches <span class="token operator">=</span> bf<span class="token punctuation">.</span>knnMatch<span class="token punctuation">(</span>descriptors_a<span class="token punctuation">,</span> descriptors_b<span class="token punctuation">,</span> k<span class="token operator">=</span><span class="token number">2</span><span class="token punctuation">)</span>
</code></pre> 
<p>（1）<strong>bf</strong>：是一个cv2.BFMatcher对象，代表暴力匹配器（Brute Force Matcher）。它会尝试将第一幅图像（descriptors_a）的每个特征描述子与第二幅图像（descriptors_b）的所有特征描述子进行匹配。<br> （2）<strong>descriptors_a和descriptors_b</strong>：分别是第一幅图像和第二幅图像的特征描述子。在计算机视觉中，通常使用特征检测器（如SIFT、SURF、ORB等）来检测图像中的特征点，并提取这些特征点的描述子。这些描述子是用于表示特征点周围图像信息的向量。<br> （3）<strong>k=2</strong>：是KNN算法的参数之一，指定要返回的最近邻居的数量。在这里，设置为2，即对于每个特征描述子，返回两个最接近的邻居。<br> 函数执行后，matches是一个包含所有匹配项的列表，每个匹配项都是两个最接近邻居的信息。每个匹配项都由以下信息组成：<br> （1）<strong>queryIdx</strong>：查询图像中的特征描述子索引，表示这个匹配是来自descriptors_a中的哪个特征点。<br> （2）<strong>trainIdx</strong>：训练图像中的特征描述子索引，表示这个匹配是来自descriptors_b中的哪个特征点。<br> （3）<strong>distance</strong>：两个描述子之间的距离，距离越小表示这两个描述子越相似。<br> 根据描述子之间的距离（相似程度）可以选择最佳的匹配（去除不可靠的匹配，类似于设置一个置信度）</p> 
<pre><code class="prism language-python"><span class="token comment"># 筛选最佳匹配</span>
good_matches <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>
<span class="token keyword">for</span> m<span class="token punctuation">,</span> n <span class="token keyword">in</span> matches<span class="token punctuation">:</span>
    <span class="token keyword">if</span> m<span class="token punctuation">.</span>distance <span class="token operator">&lt;</span> <span class="token number">0.75</span> <span class="token operator">*</span> n<span class="token punctuation">.</span>distance<span class="token punctuation">:</span>
        good_matches<span class="token punctuation">.</span>append<span class="token punctuation">(</span>m<span class="token punctuation">)</span>
</code></pre>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/5d8628c1d7eb4fab540506997ac9f489/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">harbor2.8.3安装步骤step by step</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/0f501d0dbd2e6260737b91bdcc03e274/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">MINIO安装（centos7）</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>