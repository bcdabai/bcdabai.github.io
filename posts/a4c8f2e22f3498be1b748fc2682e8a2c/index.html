<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>分布式文件存储系统Minio - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="分布式文件存储系统Minio" />
<meta property="og:description" content="一、Minio介绍 MinIO基于Apache License 2.0开源协议的对象存储服务。它兼容Amazon S3云存储接口。适合存储非结构化数据，如图片，音频，视频，日志等。对象文件最大可以达到5TB
官网：https://min.io/ 中文 http://minio.org.cn/
1、Minio基础概念 Object:存储到Minio的基本对象，如文件字节流，AnythingBucket:用来存储Object的逻辑空间。每个Bucket之间的数据是相互隔离的。对于客户端而言，就相当于一个存放文件的顶层文件夹。Drive:即存储数据的磁盘，在MinlO启动时，以参数的方式传入。Minio中所有的对象数据都会存储在Drive里Set:即-组Drive的集合，分布式部署根据集群规模自动划分一个或多个Set，每个Set中的Drive分布在不同位置。一个对象存
储在一个Set上。(For example:{1…64} is divided into 4sets each of size16) 一个对象存储在一个Set上一个集群划分为多个Set一个Set包含的Drive数量是固定的，默认由系统根据集群规模自动计算得出一个SET中的Drive尽可能分布在不同的节点上 1.1 纠删码 MiniO 使用纠删码机制来保证高可靠性，使用highwayhash来处理数据损坏(Bit Rot Protection)。关于纠删码，简单来说就是可以通过数学计算，把丢失的数据进行还原，它可以将n份原始数据，增加m份数据，并能通过n&#43;m份中的任意n份数据，还原为原始数据。即如果有任意小于等于m份的数据失效，仍然能通过剩下的数据还原出来。
1.2 存储形式 文件对象上传到Minio，会在对应的数据存储磁盘中，以Bucket名称为目录，文件名称为下一级目录，文件下是part.1（超过10M时候才会有此文件）和xl.meta，前者是编码数据块以及检验块，后者是元数据文件
1.3 存储方案 二、Minio环境搭建 1、单机部署 基于Centos7 安装路径 /usr/local/soft
wget https://dl.min.io/server/minio/release/darwin-amd64/minio chmod &#43;x minio ./minio server /mnt/data 访问 http://192.168.150.129:41922 用户名密码：minioadmin
发现图中有警告：WARNING: Console endpoint is listening on a dynamic port (41922), please use --console-address &#34;:PORT&#34; to choose a static port.
目前启动的时候端口是动态的，只要在启动命令后加上 --console-address &#34;:PORT&#34; ，就变成静态端口" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/a4c8f2e22f3498be1b748fc2682e8a2c/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-07-14T14:28:03+08:00" />
<meta property="article:modified_time" content="2022-07-14T14:28:03+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">分布式文件存储系统Minio</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p id="main-toc"></p> 
<h2>一、Minio介绍</h2> 
<p><a href="https://so.csdn.net/so/search?q=MinIO&amp;spm=1001.2101.3001.7020" title="MinIO">MinIO</a>基于Apache License 2.0开源协议的对象存储服务。它兼容Amazon S3云存储接口。适合存储非结构化数据，如图片，音频，视频，日志等。对象文件最大可以达到5TB</p> 
<p>官网：<a href="https://min.io/" rel="nofollow" title="https://min.io/">https://min.io/</a>  中文 <a href="http://minio.org.cn/" rel="nofollow" title="http://minio.org.cn/">http://minio.org.cn/</a></p> 
<h3 id="%C2%A01%E3%80%81Minio%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5"> 1、Minio基础概念</h3> 
<ul><li>Object:存储到Minio的基本对象，如文件字节流，Anything</li><li>Bucket:用来存储Object的逻辑空间。每个Bucket之间的数据是相互隔离的。对于客户端而言，就相当于一个存放文件的顶层文件夹。</li><li>Drive:即存储数据的磁盘，在MinlO启动时，以参数的方式传入。Minio中所有的对象数据都会存储在Drive里</li><li>Set:即-组Drive的集合，分布式部署根据集群规模自动划分一个或多个Set，每个Set中的Drive分布在不同位置。一个对象存<br> 储在一个Set上。(For example:{1…64} is divided into 4sets each of size16)</li></ul> 
<ol><li>一个对象存储在一个Set上</li><li>一个集群划分为多个Set</li><li>一个Set包含的Drive数量是固定的，默认由系统根据集群规模自动计算得出</li><li>一个SET中的Drive尽可能分布在不同的节点上</li></ol> 
<h3 id="1.1%20%E7%BA%A0%E5%88%A0%E7%A0%81">1.1 纠删码</h3> 
<p>MiniO 使用纠删码机制来保证高可靠性，使用highwayhash来处理数据损坏(Bit Rot Protection)。关于纠删码，简单来说就是可以通过数学计算，把丢失的数据进行还原，它可以将n份原始数据，增加m份数据，并能通过n+m份中的任意n份数据，还原为原始数据。即如果有任意小于等于m份的数据失效，仍然能通过剩下的数据还原出来。</p> 
<h3 id="1.2%20%E5%AD%98%E5%82%A8%E5%BD%A2%E5%BC%8F" style="margin-left:0px;"><span style="color:#000000;"><span style="background-color:#ffffff;">1.2 存储形式</span></span></h3> 
<p>文件对象上传到Minio，会在对应的数据存储磁盘中，以Bucket名称为目录，文件名称为下一级目录，文件下是part.1（超过10M时候才会有此文件）和xl.meta，前者是编码数据块以及检验块，后者是元数据文件</p> 
<h3 id="1.3%20%E5%AD%98%E5%82%A8%E6%96%B9%E6%A1%88">1.3 存储方案</h3> 
<p><img alt="" height="596" src="https://images2.imgbox.com/65/a5/hBzU5tBG_o.png" width="1192"></p> 
<p></p> 
<h2 id="%E4%BA%8C%E3%80%81Minio%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA">二、Minio环境搭建</h2> 
<h3 id="1%E3%80%81%E5%8D%95%E6%9C%BA%E9%83%A8%E7%BD%B2">1、单机部署</h3> 
<h4 id="%E5%9F%BA%E4%BA%8ECentos7">基于Centos7</h4> 
<p>安装路径 /usr/local/soft</p> 
<pre><code>wget https://dl.min.io/server/minio/release/darwin-amd64/minio
chmod +x minio
./minio server /mnt/data</code></pre> 
<p> <img alt="" height="380" src="https://images2.imgbox.com/75/7b/QHnNKF5a_o.png" width="1043"></p> 
<p> 访问 <a href="http://192.168.150.129:41922" rel="nofollow" title="http://192.168.150.129:41922">http://192.168.150.129:41922</a> 用户名密码：minioadmin</p> 
<p> 发现图中有警告：<span style="color:#fe2c24;">WARNING: Console endpoint is listening on a dynamic port (41922), please use --console-address ":PORT" to choose a static port.</span></p> 
<p> 目前启动的时候端口是动态的，只要在启动命令后加上 --console-address ":PORT" ，就变成静态端口</p> 
<p>再次启动</p> 
<p><strong>./minio server /mnt/data --console-address ":9001"</strong></p> 
<p><img alt="" height="355" src="https://images2.imgbox.com/58/fd/IBhAZPHY_o.png" width="668"></p> 
<p> 图中还有警告：<span style="color:#fe2c24;">WARNING: Detected default credentials 'minioadmin:minioadmin', we recommend that you change these values with 'MINIO_ROOT_USER' and 'MINIO_ROOT_PASSWORD' environment variables</span></p> 
<p>意思是我们在启动的时候可以通过<span style="color:#fe2c24;">MINIO_ROOT_USER</span>和<span style="color:#fe2c24;">MINIO_ROOT_PASSWORD</span>设置用户密码访问</p> 
<p><strong>完整启动命令：</strong></p> 
<pre><code>MINIO_ROOT_USER=admin MINIO_ROOT_PASSWORD=12345678 ./minio server /mnt/data --console-address ":9001"</code></pre> 
<p><img alt="" height="345" src="https://images2.imgbox.com/5e/21/r3D1S3KZ_o.png" width="1006"></p> 
<p>访问 <a href="http://192.168.150.129:9001" rel="nofollow" title="http://192.168.150.129:9001">http://192.168.150.129:9001</a> 账号：admin 密码：12345678</p> 
<p><img alt="" height="905" src="https://images2.imgbox.com/fb/32/f8yzSR6D_o.png" width="1200"></p> 
<h4 id="%C2%A0%E5%9F%BA%E4%BA%8Edocker%E9%83%A8%E7%BD%B2"> 基于docker部署</h4> 
<p>安装docker命令（如果已经安装就跳过此步骤）</p> 
<p>yum install -y yum-utils device-mapper-persistent-data lvm2</p> 
<p>yum-config-manager --add-repo https://download.docker.com/linux/centos/docker-ce.repo</p> 
<p>yum install docker-ce</p> 
<p>启动docker</p> 
<p>systemctl start docker</p> 
<p>部署命令以及自定义用户名密码</p> 
<pre><code>docker run -d -p 9000:9000 -p 9001:9001 --name minio \
  -e "MINIO_ROOT_USER=admin" \
  -e "MINIO_ROOT_PASSWORD=12345678" \
  -v /mnt/data:/data \
  -v /mnt/config:/root/.minio \
  minio/minio server /data --console-address ":9001"</code></pre> 
<p>获取容器ID</p> 
<p>在容器中使用Docker命令, 你需要知道这个容器的 <code>容器ID</code> 。 为了获取 <code>Container ID</code>, 运行<br><code>docker ps -a</code></p> 
<p><code>-a</code> flag 确保你获取所有的容器(创建的，正在运行的，退出的)，然后从输出中识别<code>Container ID</code>。</p> 
<p>启动和停止容器</p> 
<p>启动容器,你可以使用 <a href="https://docs.docker.com/engine/reference/commandline/start/" rel="nofollow" title="docker start">docker start</a> 命令。<br><code>docker start &lt;container_id&gt;</code></p> 
<p>停止一下正在运行的容器, 使用 <a href="https://docs.docker.com/engine/reference/commandline/stop/" rel="nofollow" title="docker stop">docker stop</a> 命令。<br><code>docker stop &lt;container_id&gt;</code></p> 
<p>MinIO容器日志</p> 
<p>获取MinIO日志，使用 <a href="https://docs.docker.com/engine/reference/commandline/logs/" rel="nofollow" title="docker logs">docker logs</a> 命令。<br><code>docker logs &lt;container_id&gt;</code></p> 
<p>监控MinioDocker容器</p> 
<p>监控MinIO容器使用的资源,使用 <a href="https://docs.docker.com/engine/reference/commandline/stats/" rel="nofollow" title="docker stats">docker stats</a> 命令.<br><code>docker stats &lt;container_id&gt;</code></p> 
<h4 id="minio%E7%BA%A0%E5%88%A0%E7%A0%81%E6%A8%A1%E5%BC%8F">minio纠删码模式</h4> 
<p>Minio使用纠删码<code>erasure code</code>和校验和<code>checksum</code>来保护数据免受硬件故障和无声数据损坏。 即便您丢失一半数量（N/2）的硬盘，您仍然可以恢复数据。</p> 
<p>纠删码是一种恢复丢失和损坏数据的数学算法， Minio采用Reed-Solomon code将对象拆分成N/2数据和N/2 奇偶校验块。 这就意味着如果是12块盘，一个对象会被分成6个数据块、6个奇</p> 
<p>偶校验块，你可以丢失任意6块盘（不管其是存放的数据块还是奇偶校验块）</p> 
<p><img alt="" height="443" src="https://images2.imgbox.com/73/02/pQsSR0vX_o.png" width="1139"></p> 
<pre><code>docker run -d -p 9000:9000 -p 9001:9001 --name minio-ec \
  -v /mnt/data1:/data1 \
  -v /mnt/data2:/data2 \
  -v /mnt/data3:/data3 \
  -v /mnt/data4:/data4 \
  -v /mnt/data5:/data5 \
  -v /mnt/data6:/data6 \
  -v /mnt/data7:/data7 \
  -v /mnt/data8:/data8 \
minio/minio server /data{1...8} --console-address ":9001"</code></pre> 
<h3>2、分布式集群部署</h3> 
<p>分布式Minio可以让你将多块硬盘（甚至在不同的机器上）组成一个对象存储服务。由于硬盘分布在不同的节点上，分布式Minio避免了单点故障。</p> 
<p><img alt="architecture-diagram_distributed_nm" src="https://images2.imgbox.com/f3/65/ynafKPxt_o.png"><br>   </p> 
<p></p> 
<h4>分布式存储可靠性常用方法</h4> 
<p>分布式存储，很关键的点在于数据的可靠性，即保证数据的完整，不丢失，不损坏。只有在可靠性实现的前提下，才有了追求一致性、高可用、高性能的基础。而对于在存储领域，一般对于保证数据可靠性的方法主要有两类，一类是冗余法，一类是校验法。<br><strong>冗余</strong><br> 冗余法最简单直接，即对存储的数据进行副本备份，当数据出现丢失，损坏，即可使用备份内容进行恢复，而副本备份的多少，决定了数据可靠性的高低。这其中会有成本的考量，副本数据越多，数据越可靠，但需要的设备就越多，成本就越高。可靠性是允许丢失其中-份数据。当前已有很多分布式系统是采用此种方式实现，如Hadoop的文件系统(3个副本)，Redis的集群，MvSOL的主备模式等。<br><strong>校险</strong><br> 校验法即通过校验码的数学计算的方式，对出现丢失、损坏的数据进行校验，还原。注意，这里有两个作用，一个校验，通过对数据进行校验和(checksum)进行计算，可以检查数据是否完整，有无损坏或更改，在数据传输和保存时经常用到，如TCP协议:二是恢复还原通过对数据结合校验码，通过数学计算，还原丢失或损坏的数据，可以在保证数据可章的前提下，降低冗余，如单机硬盘存储中的RAID技术，纠删码(ErasureCode)技术等。Minlo采用的就是纠删码技术。</p> 
<h4>分布式Minio优势</h4> 
<h4>数据保护</h4> 
<p>分布式Minio采用 <a href="http://docs.minio.org.cn/docs/master/minio-erasure-code-quickstart-guide" rel="nofollow" title="纠删码">纠删码</a>来防范多个节点宕机和<a href="https://github.com/minio/minio/blob/master/docs/zh_CN/erasure/README.md#what-is-bit-rot-protection" title="位衰减bit rot">位衰减bit rot</a>。</p> 
<p>分布式Minio至少需要4个硬盘，使用分布式Minio自动引入了纠删码功能。</p> 
<h4>高可用</h4> 
<p>单机Minio服务存在单点故障，相反，如果是一个有N块硬盘的分布式Minio,只要有N/2硬盘在线，你的数据就是安全的。不过你需要至少有N/2+1个硬盘来创建新的对象。</p> 
<p>例如，一个16节点的Minio集群，每个节点16块硬盘，就算8台服務器宕机，这个集群仍然是可读的，不过你需要9台服務器才能写数据。</p> 
<p>注意，只要遵守分布式Minio的限制，你可以组合不同的节点和每个节点几块硬盘。比如，你可以使用2个节点，每个节点4块硬盘，也可以使用4个节点，每个节点两块硬盘，诸如此类。</p> 
<h4>一致性</h4> 
<p>Minio在分布式和单机模式下，所有读写操作都严格遵守<strong>read-after-write</strong>一致性模型。</p> 
<h4>运行分布式Minio</h4> 
<p>启动一个分布式Minio实例，你只需要把硬盘位置做为参数传给minio server命令即可，然后，你需要在所有其它节点运行同样的命令。</p> 
<ul><li>所有运行分布式 MinIO 的节点都应该共享一个共同的根凭证，以便节点相互连接和信任。为此，<strong>建议</strong>在执行 MinIO 服务器命令之前，将 root 用户和 root 密码导出为环境变量，<code>MINIO_ROOT_USER</code>并在所有节点上导出。<code>MINIO_ROOT_PASSWORD</code>如果未导出，<code>minioadmin/minioadmin</code>则应使用默认凭据。</li><li><strong><em>MinIO 创建每组2</em>到<em>16 个</em>驱动器的纠删码集。您提供的驱动器总数必须是这些数字之一的倍数。</strong></li><li><strong>MinIO 选择最大的 EC 集大小，将其划分为给定的驱动器总数或节点总数 - 确保保持均匀分布，即每个节点参与每组相同数量的驱动器</strong>。</li><li><strong>每个对象都写入单个 EC 集，因此分布在不超过 16 个驱动器上。</strong></li><li><strong>建议运行分布式 MinIO 设置的所有节点是同质的，即相同的操作系统、相同数量的磁盘和相同的网络互连。</strong></li><li>MinIO 分布式模式需要<strong>新目录</strong>。如果需要，驱动器可以与其他应用程序共享。您可以通过使用 MinIO 独有的子目录来执行此操作。例如，如果您已将卷安装在 下<code>/export</code>，则将其作为参数传递<code>/export/data</code>给 MinIO 服务器。</li><li>下面的 IP 地址和驱动器路径仅用于演示目的，您需要将它们替换为实际的 IP 地址和驱动器路径/文件夹。</li><li>运行分布式 MinIO 实例的服务器之间的间隔应小于 15 分钟。您可以启用<a href="http://www.ntp.org/" rel="nofollow" title="NTP">NTP</a>服务作为最佳实践，以确保跨服务器的时间相同。</li><li><code>MINIO_DOMAIN</code>应为桶 DNS 样式支持定义和导出环境变量。</li><li><strong>在Windows</strong>操作系统上运行分布式 MinIO被认为是<strong>实验性</strong>的。请谨慎行事。</li></ul> 
<h4>前期准备</h4> 
<p>四台服务器开启时间同步，命令：</p> 
<pre><code>yum -y install ntp
systemctl enable ntpd
systemctl start ntpd
timedatectl set-ntp yes
ntpdate -u cn.pool.ntp.org
ln -sf /usr/share/zoneinfo/Asia/Shanghai /etc/localtime   
watch -n 1 'date'</code></pre> 
<p> 关闭防火墙</p> 
<pre><code>1.首先查看防火墙状态：
service iptables status
2.永久性生效，重启后不会复原
开启：
chkconfig iptables on
关闭：
chkconfig iptables off
3.即时生效，重启后复原
开启：
service iptables start
关闭：
service iptables stop
4.设置后重启：
reboot</code></pre> 
<p></p> 
<h4>4个节点，每节点4块盘</h4> 
<p>每台服务器中都要配置如下hostname </p> 
<table align="left" border="1" cellpadding="0" cellspacing="1" style="width:500px;"><tbody><tr><td style="width:292px;">服务器 IP</td><td style="width:206px;">hostname</td><td style="width:206px;">说明</td></tr><tr><td style="width:292px;">192.168.150.128</td><td style="width:206px;">minio1.com</td><td style="width:206px;">Minio节点</td></tr><tr><td style="width:292px;">192.168.150.129</td><td style="width:206px;">minio2.com</td><td style="width:206px;">Minio节点</td></tr><tr><td style="width:292px;">192.168.150.130</td><td style="width:206px;">minio3.com</td><td style="width:206px;">Minio节点</td></tr><tr><td style="width:292px;">192.168.150.131</td><td style="width:206px;">minio4.com</td><td style="width:206px;">Minio节点</td></tr><tr><td style="width:292px;">192.168.150.132</td><td style="width:206px;">minio5.com</td><td style="width:206px;"> <p>Nginx负载均衡</p> </td></tr></tbody></table> 
<p></p> 
<p></p> 
<p></p> 
<p></p> 
<p></p> 
<p></p> 
<p></p> 
<p>启动分布式Minio实例，4个节点，每节点4块盘，需要在4个节点上都运行下面的命令。</p> 
<p>1、给每台服务器新增一块硬盘，这里使用的10G（这里使用的是虚拟机，自行百度怎么添加，不使用新硬盘部署集群会报错）<img alt="" height="368" src="https://images2.imgbox.com/26/f3/JSOGASXh_o.png" width="640"></p> 
<p>2、格式化硬盘 （不格式化会提示只读模式）</p> 
<p>mkfs.ext4 /dev/sdb</p> 
<p>3、创建minio数据目录，挂载数据磁盘到数据目录<br> mkdir  -p /data/minio{1..4}   // 模拟四块硬盘<br> mount /dev/sdb /data</p> 
<p>实现永久挂载需要配置 vim /etc/fstab </p> 
<p><img alt="" height="312" src="https://images2.imgbox.com/68/e3/YuyirF3k_o.png" width="885"></p> 
<p>4、minio-cluster.sh脚本</p> 
<p>4.1 第一中写法</p> 
<pre><code class="language-bash">#!/bin/bash
export MINIO_ROOT_USER=admin
export MINIO_ROOT_PASSWORD=12345678
nohup /usr/local/soft/minio server --address ":9000" --console-address ":9001" \
http://192.168.150.128:9000/data/minio1 \
http://192.168.150.128:9000/data/minio2 \
http://192.168.150.128:9000/data/minio3 \
http://192.168.150.128:9000/data/minio4 \
http://192.168.150.129:9000/data/minio1 \
http://192.168.150.129:9000/data/minio2 \
http://192.168.150.129:9000/data/minio3 \
http://192.168.150.129:9000/data/minio4 \
http://192.168.150.130:9000/data/minio1 \
http://192.168.150.130:9000/data/minio2 \
http://192.168.150.130:9000/data/minio3 \
http://192.168.150.130:9000/data/minio4 \
http://192.168.150.131:9000/data/minio1 \
http://192.168.150.131:9000/data/minio2 \
http://192.168.150.131:9000/data/minio3 \
http://192.168.150.131:9000/data/minio4 &gt;/data/minio.log 2&gt;&amp;1 &amp;</code></pre> 
<p>4.2 第二中写法 </p> 
<pre><code class="language-bash">#!/bin/bash
export MINIO_ROOT_USER=admin
export MINIO_ROOT_PASSWORD=12345678
nohup /usr/local/soft/minio server --address ":9000" --console-address ":9001" http://minio{1...4}.com:9000/data/minio{1...4} &gt;/data/minio-data.log  2&gt;&amp;1  &amp;</code></pre> 
<p><img alt="" height="562" src="https://images2.imgbox.com/4f/62/QIqezHCi_o.png" width="1036"></p> 
<p>5、Nginx负载均衡配置</p> 
<pre><code class="language-bash">
#user  nobody;
worker_processes  1;

#error_log  logs/error.log;
#error_log  logs/error.log  notice;
#error_log  logs/error.log  info;

#pid        logs/nginx.pid;


events {
    worker_connections  1024;
}


http {
    include       mime.types;
    default_type  application/octet-stream;

    #log_format  main  '$remote_addr - $remote_user [$time_local] "$request" '
    #                  '$status $body_bytes_sent "$http_referer" '
    #                  '"$http_user_agent" "$http_x_forwarded_for"';

    #access_log  logs/access.log  main;

    sendfile        on;
    #tcp_nopush     on;

    #keepalive_timeout  0;
    keepalive_timeout  65;

    #gzip  on;
    # Minio配置---开始
upstream minio_console {
    server 192.168.150.128:9001 max_fails=3 fail_timeout=5s;
    server 192.168.150.129:9001 max_fails=3 fail_timeout=5s;
    server 192.168.150.130:9001 max_fails=3 fail_timeout=5s;
    server 192.168.150.131:9001 max_fails=3 fail_timeout=5s;
}
upstream minio_api {
    server 192.168.150.128:9000 max_fails=3 fail_timeout=5s;
    server 192.168.150.129:9000 max_fails=3 fail_timeout=5s;
    server 192.168.150.130:9000 max_fails=3 fail_timeout=5s;
    server 192.168.150.131:9000 max_fails=3 fail_timeout=5s;
}

server {
    listen          9001;   #或者用80端口也可以
    server_name     192.168.150.132;    #可以用域名
    location / {
	    #Nginx默认是上传一个不能超过1M大小的文件
        #client_body_buffer_size 配置请求体缓存区大小, 不配的话，
        #client_body_temp_path 设置临时文件存放路径。只有当上传的请求体超出缓存区大小时，才会写到临时文件中
        #client_max_body_size 设置上传文件的最大值
	    client_max_body_size 600M;
        client_body_buffer_size 600M;
        proxy_next_upstream     http_500 http_502 http_503 http_504 error timeout invalid_header;
        proxy_set_header        Host  $host;
        proxy_set_header        X-Forwarded-For $proxy_add_x_forwarded_for;
        proxy_pass              http://minio_console;
        expires                 0;
    }
}

server {
    listen          9000;
    server_name     192.168.150.132;   #可以用域名
    location / {
	    #Nginx默认是上传一个不能超过1M大小的文件
        #client_body_buffer_size 配置请求体缓存区大小, 不配的话，
        #client_body_temp_path 设置临时文件存放路径。只有当上传的请求体超出缓存区大小时，才会写到临时文件中
        #client_max_body_size 设置上传文件的最大值
	    client_max_body_size 600M;
        client_body_buffer_size 600M;
        proxy_next_upstream     http_500 http_502 http_503 http_504 error timeout invalid_header;
        proxy_set_header        Host  $host;
        proxy_set_header        X-Forwarded-For $proxy_add_x_forwarded_for;
        proxy_pass              http://minio_api;
        expires                 0;
    }
}
  # Minio配置---结束
    server {
        listen       80;
        server_name  localhost;

        #charset koi8-r;

        #access_log  logs/host.access.log  main;

        location / {
            root   html;
            index  index.html index.htm;
        }

        #error_page  404              /404.html;

        # redirect server error pages to the static page /50x.html
        #
        error_page   500 502 503 504  /50x.html;
        location = /50x.html {
            root   html;
        }

        # proxy the PHP scripts to Apache listening on 127.0.0.1:80
        #
        #location ~ \.php$ {
        #    proxy_pass   http://127.0.0.1;
        #}

        # pass the PHP scripts to FastCGI server listening on 127.0.0.1:9000
        #
        #location ~ \.php$ {
        #    root           html;
        #    fastcgi_pass   127.0.0.1:9000;
        #    fastcgi_index  index.php;
        #    fastcgi_param  SCRIPT_FILENAME  /scripts$fastcgi_script_name;
        #    include        fastcgi_params;
        #}

        # deny access to .htaccess files, if Apache's document root
        # concurs with nginx's one
        #
        #location ~ /\.ht {
        #    deny  all;
        #}
    }


    # another virtual host using mix of IP-, name-, and port-based configuration
    #
    #server {
    #    listen       8000;
    #    listen       somename:8080;
    #    server_name  somename  alias  another.alias;

    #    location / {
    #        root   html;
    #        index  index.html index.htm;
    #    }
    #}


    # HTTPS server
    #
    #server {
    #    listen       443 ssl;
    #    server_name  localhost;

    #    ssl_certificate      cert.pem;
    #    ssl_certificate_key  cert.key;

    #    ssl_session_cache    shared:SSL:1m;
    #    ssl_session_timeout  5m;

    #    ssl_ciphers  HIGH:!aNULL:!MD5;
    #    ssl_prefer_server_ciphers  on;

    #    location / {
    #        root   html;
    #        index  index.html index.htm;
    #    }
    #}

}
</code></pre> 
<p></p> 
<p></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/ab45ac293ddb8e999575d88c4627e680/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">联想小新Win11系统如何将新建标签页设置为Edge浏览器首页</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/2446fd3f89fa175479086e5440958179/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">Not running on Jetty, JSR-356 support unavailable分析与解决</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>