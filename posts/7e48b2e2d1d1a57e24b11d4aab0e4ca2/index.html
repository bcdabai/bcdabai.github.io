<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Windows下的双显的设置 - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Windows下的双显的设置" />
<meta property="og:description" content="XP系统下设置双显的过程
电脑：AUSUS K50I
显卡为NVIDIA N1-0P-GE
在桌面上右击，选属性。在弹出窗口中找到设置选项卡，会看到有两个显示器编号。点选2号显示器。在下面找到两个选项，先选择下面的扩展桌面到此监视器，然后再选上面的设置此显示器为主显示器。点下面的应用按钮，然后选1号显示器，把下面两个选项中的扩展桌面到此监视器这个选项取消选择，就可以了。
2、一些应用程序在双显时的特性 （1） PPT
把PPT拖到副显，此时按F5放映PPT。却是在主显示PPT全屏放映，而副显还是显示编辑状态的PPT。
（2） RDP
RDP7不支持双显。Win7 下的RDP才支持双显。
（3） 按Ptr Sc键，把桌面的屏幕保存到mspaint中，此时看到是两个屏幕的和。
长*宽是否２６４６＊７６８ ，这个大小就是双显的大小
可以看到2646是主显的分辩率的宽&#43;副显的分辨率的宽。（1280&#43;1366）
Introduction
This has been an ongoing topic for a while and I keep on getting question(s) on how can we launch Windows or in our case application(s) in different screens. In the place that I currently work, City of Dreams, we have many different types of adapters for many A/V systems and the applications like Lucky Draw, Slot Results, etc." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/7e48b2e2d1d1a57e24b11d4aab0e4ca2/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2013-04-03T23:19:09+08:00" />
<meta property="article:modified_time" content="2013-04-03T23:19:09+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Windows下的双显的设置</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p align="left"><strong>XP系统下设置双显的过程</strong></p> 
<p align="left">电脑：AUSUS K50I</p> 
<p align="left">显卡为NVIDIA N1-0P-GE</p> 
<p align="left"><span style="color:#333333">在桌面上右击，选属性。在弹出窗口中找到设置选项卡，会看到有两个显示器编号。点选</span><span style="color:#333333">2</span><span style="color:#333333">号显示器。在下面找到两个选项，先选择下面的扩展桌面到此监视器，然后再选上面的设置此显示器为主显示器。点下面的应用按钮，然后选</span><span style="color:#333333">1</span><span style="color:#333333">号显示器，把下面两个选项中的扩展桌面到此监视器这个选项取消选择，就可以了。</span></p> 
<p align="left"> <img src="https://images2.imgbox.com/44/39/6jrrtuOp_o.jpg" alt=""></p> 
<p align="left"><br> </p> 
<p align="left"> </p> 
<p align="left"> </p> 
<h4><strong>2、一些应用程序在双显时的特性</strong></h4> 
<p align="left">（1）      PPT</p> 
<p align="left">把PPT拖到副显，此时按F5放映PPT。却是在主显示PPT全屏放映，而副显还是显示编辑状态的PPT。</p> 
<p align="left">（2）      RDP</p> 
<p align="left">RDP7不支持双显。Win7 下的RDP才支持双显。</p> 
<p align="left">（3）      按Ptr Sc键，把桌面的屏幕保存到mspaint中，此时看到是两个屏幕的和。</p> 
<p align="left">长*宽是否２６４６＊７６８ ，这个大小就是双显的大小</p> 
<p align="left">可以看到2646是主显的分辩率的宽+副显的分辨率的宽。（1280+1366）</p> 
<p align="left"><br> </p> 
<p align="left"><strong><span style="color:#FF9900">Introduction</span></strong></p> 
<p align="left"><span style="color:#111111"></span><span style="color:rgb(17,17,17); font-family:'Segoe UI',Arial,sans-serif; font-size:16px">This has been an ongoing topic for a while and I keep on getting question(s) on how can we launch Windows or in our case application(s) <span style="background-color:rgb(255,204,153)">in different screens</span>. In the place that I currently work, </span><a href="http://www.cityofdreamsmacau.com/" rel="nofollow" style="margin:0px; padding:0px; border:0px; text-decoration:initial; color:purple; font-family:'Segoe UI',Arial,sans-serif; font-size:16px">City of Dreams</a><span style="color:rgb(17,17,17); font-family:'Segoe UI',Arial,sans-serif; font-size:16px">, we have many different types of adapters for many A/V systems and the applications like Lucky Draw, Slot Results, etc. have to be automatically launched on the correct AV to have effects like Animation(s) on one type, random numbers on other, etc.</span><span style="color:#111111"></span></p> 
<p align="left"><span style="color:#666666">Launcher</span></p> 
<p align="left"><span style="color:#666666"><img src="https://images2.imgbox.com/f0/25/vlfxvVaS_o.jpg" alt=""><br> </span></p> 
<p align="left"></p> 
<p align="left"><span style="color:#666666">Launched</span></p> 
<p align="left"></p> 
<p align="left"> <img src="https://images2.imgbox.com/9c/01/uzHflEox_o.jpg" alt=""></p> 
<p align="left"><strong><span style="color:#FF9900"></span></strong></p> 
<h3 style="font-family:'Segoe UI',Arial,sans-serif; font-size:20px; color:rgb(255,153,0); margin:20px 0px 11px"> The AllScreens</h3> 
<p style="font-family:'Segoe UI',Arial,sans-serif; font-size:16px; color:rgb(17,17,17)"> This is all it takes to get the information of all the screens currently hosted in the system<code style="margin:0px; padding:0px; border:0px; color:rgb(153,0,0); font-size:11pt; font-family:Consolas,'Courier New',Courier,mono">System.Windows.Forms.Screen</code>.</p> 
<p style="font-family:'Segoe UI',Arial,sans-serif; font-size:16px; color:rgb(17,17,17)"> So to populate our dropdown; loop through the:</p> 
<p align="left"><span style="color:#111111"></span></p> 
<p align="left"></p> 
<pre><code class="language-cpp">Screen[] scr = Screen.AllScreens
this.cmbDevices.Items.Clear();
foreach (System.Windows.Forms.Screen s in scr)
{
    strDeviceName = s.DeviceName.Replace("\\\\.\\", "");
    this.cmbDevices.Items.Add(strDeviceName);
    // you can check the device is primary or not this way
    if (s.Primary) this.cmbDevices.Items.Add("&gt;" + strDeviceName);
    else this.cmbDevices.Items.Add(strDeviceName);
}
this.cmbDevices.SelectedIndex = 0;</code></pre> 
<p></p> 
<h3 style="font-family:'Segoe UI',Arial,sans-serif; font-size:20px; color:rgb(255,153,0); margin:20px 0px 11px"> Launch</h3> 
<p></p> 
<p style="font-family:'Segoe UI',Arial,sans-serif; font-size:16px; color:rgb(17,17,17)"> There are only two properties that have to be set correctly in order to ensure it is properly launched into the correct display. <code style="margin:0px; padding:0px; border:0px; color:rgb(153,0,0); font-size:11pt; font-family:Consolas,'Courier New',Courier,mono">Form.StartPosition</code> &amp; <code style="margin:0px; padding:0px; border:0px; color:rgb(153,0,0); font-size:11pt; font-family:Consolas,'Courier New',Courier,mono">Form.Location</code>.</p> 
<pre><code class="language-cpp">Screen[] scr = Screen.AllScreens
Form oForm = new Form()
oForm.Left = scr[0].Bounds.Width;
oForm.Top = scr[0].Bounds.Height;
oForm.StartPosition = FormStartPosition.Manual;
oForm.Location = scr[0].Bounds.Location;
        oForm.Show();</code></pre> 
<br> 
<br> 
<h3 style="font-family:'Segoe UI',Arial,sans-serif; font-size:20px; color:rgb(255,153,0); margin:20px 0px 11px"> Putting It All Together</h3> 
<p style="font-family:'Segoe UI',Arial,sans-serif; font-size:16px; color:rgb(17,17,17)"> Here we go, this is all it takes to launch your forms into user selected display.</p> 
<pre><code class="language-cpp">public partial class frmMain : Form
{
    Form[] aryForms = new Form[5];                      // Allow 5 total forms.
    int currentPointer = 0;                             //
    Screen[] scr = Screen.AllScreens;
    
    public frmMain()
    {
        InitializeComponent();
        LoadScreen();
    }
    
    private void LoadScreen()
    {
        String strDeviceName = String.Empty;
        
        this.cmbDevices.Items.Clear();
        foreach (Screen s in scr)
        {
            strDeviceName = s.DeviceName.Replace("\\\\.\\", "");
            this.cmbDevices.Items.Add(strDeviceName);
            /* Enable this section, if you want to point to 
	   user this is the default screen.
            if (s.Primary) this.cmbDevices.Items.Add("&gt;" + strDeviceName);
            else this.cmbDevices.Items.Add(strDeviceName);
            */
        }
        this.cmbDevices.SelectedIndex = 0;
    }
    
    private void btnLaunchIn_Click(object sender, EventArgs e)
    {
        int intLaunchScreen = getScreenNumber(this.cmbDevices.SelectedItem.ToString());
        
        if (currentPointer &lt;= 4)
        {
            aryForms[currentPointer] = new frmLaunchedWindow();
            aryForms[currentPointer].Text = 
		aryForms[currentPointer].Text + currentPointer;
            aryForms[currentPointer].Left = scr[intLaunchScreen].Bounds.Width;
            aryForms[currentPointer].Top = scr[intLaunchScreen].Bounds.Height;
            aryForms[currentPointer].StartPosition = FormStartPosition.Manual;
            aryForms[currentPointer].Location = scr[intLaunchScreen].Bounds.Location;
            //Point p = new Point(scr[0].Bounds.Location.X, scr[0].Bounds.Location.Y);
            //aryForms[currentPointer].Location = p;
            aryForms[currentPointer].Show();
            currentPointer += 1;
        }
    }
    private int getScreenNumber(String DeviceID)
    {
        int i = 0;
        foreach (Screen s in scr)
        {
            if (s.DeviceName == "\\\\.\\"+DeviceID) return i;
            i += 1;
        }
        // if cannot find the device reset to the default 0
        return 0;
    }
}</code></pre> 
<br> 
<br> 
<p align="left"> <strong><span style="font-size:13.5pt; font-family:宋体">二、</span><span lang="EN-US" style="font-size:13.5pt; font-family:Arial,sans-serif">Windows</span><span style="font-size:13.5pt; font-family:宋体">下的多显介绍</span></strong></p> 
<p align="left"><span style="color:#ff9900"><strong> </strong></span></p> 
<p align="left"> </p> 
<h2 class="title" style="color:rgb(112,112,112); font-weight:100; font-size:3em; line-height:1.167; font-family:'Segoe UI',Verdana,Arial; margin-top:0px"> Positioning Objects on a Multiple Display Setup</h2> 
<p></p> 
<p align="left"><span style="color:#ff9900"><strong> <span style="color:rgb(42,42,42); font-family:'Segoe UI','Lucida Grande',Verdana,Arial,Helvetica,sans-serif; line-height:18px">The following sample code demonstrates how applications can correctly<span style="background-color:rgb(255,153,102)"> position objects on multiple displays</span>. Note, do not assume that the RECT is based on the origin (0,0).</span></strong></span></p> 
<p align="left"><span style="color:#ff9900"><span style="color:rgb(42,42,42); font-family:'Segoe UI','Lucida Grande',Verdana,Arial,Helvetica,sans-serif; line-height:18px"></span></span></p> 
<pre><code class="language-cpp">#include &lt;windows.h&gt;
#include "multimon.h"    

#define MONITOR_CENTER     0x0001        // center rect to monitor 
#define MONITOR_CLIP     0x0000        // clip rect to monitor 
#define MONITOR_WORKAREA 0x0002        // use monitor work area 
#define MONITOR_AREA     0x0000        // use monitor entire area 

// 
//  ClipOrCenterRectToMonitor 
// 
//  The most common problem apps have when running on a 
//  multimonitor system is that they "clip" or "pin" windows 
//  based on the SM_CXSCREEN and SM_CYSCREEN system metrics. 
//  Because of app compatibility reasons these system metrics 
//  return the size of the primary monitor. 
// 
//  This shows how you use the multi-monitor functions 
//  to do the same thing. 
// 
void ClipOrCenterRectToMonitor(LPRECT prc, UINT flags)
{
    HMONITOR hMonitor;
    MONITORINFO mi;
    RECT        rc;
    int         w = prc-&gt;right  - prc-&gt;left;
    int         h = prc-&gt;bottom - prc-&gt;top;

    // 
    // get the nearest monitor to the passed rect. 
    // 
    hMonitor = MonitorFromRect(prc, MONITOR_DEFAULTTONEAREST);

    // 
    // get the work area or entire monitor rect. 
    // 
    mi.cbSize = sizeof(mi);
    GetMonitorInfo(hMonitor, &amp;mi);

    if (flags &amp; MONITOR_WORKAREA)
        rc = mi.rcWork;
    else
        rc = mi.rcMonitor;

    // 
    // center or clip the passed rect to the monitor rect 
    // 
    if (flags &amp; MONITOR_CENTER)
    {
        prc-&gt;left   = rc.left + (rc.right  - rc.left - w) / 2;
        prc-&gt;top    = rc.top  + (rc.bottom - rc.top  - h) / 2;
        prc-&gt;right  = prc-&gt;left + w;
        prc-&gt;bottom = prc-&gt;top  + h;
    }
    else
    {
        prc-&gt;left   = max(rc.left, min(rc.right-w,  prc-&gt;left));
        prc-&gt;top    = max(rc.top,  min(rc.bottom-h, prc-&gt;top));
        prc-&gt;right  = prc-&gt;left + w;
        prc-&gt;bottom = prc-&gt;top  + h;
    }
}

void ClipOrCenterWindowToMonitor(HWND hwnd, UINT flags)
{
    RECT rc;
    GetWindowRect(hwnd, &amp;rc);
    ClipOrCenterRectToMonitor(&amp;rc, flags);
    SetWindowPos(hwnd, NULL, rc.left, rc.top, 0, 0, SWP_NOSIZE | SWP_NOZORDER | SWP_NOACTIVATE);
}<strong>
</strong></code></pre> 
<br> 
<br> 
<p></p> 
<p align="left"><br> </p> 
<h3><span style="font-size:18px">三、<span style="color:#333333">RepositioningWindows on Multiple Monitor Systems</span></span></h3> 
<p></p> 
<p align="left"> 参考代码：</p> 
<p align="left">http://download.csdn.net/detail/chenyujing1234/5218722<br> </p> 
<p align="left"></p> 
<h3 style="font-family:'Segoe UI',Arial,sans-serif; font-size:20px; color:rgb(255,153,0); margin:20px 0px 11px"> Introduction</h3> 
<p></p> 
<p style="font-family:'Segoe UI',Arial,sans-serif; font-size:16px; color:rgb(17,17,17)"> On systems with more than one display, you can get into trouble because of compatibility issues for functions like:</p> 
<div class="pre-action-link" id="premain0" width="100%" style="margin:0px; padding:0px; border-width:0px 0px 1px; border-bottom-style:solid; border-bottom-color:rgb(204,204,204); font-size:16px; text-align:right; color:rgb(0,87,130); font-family:'Segoe UI',Arial,sans-serif"> 
 <img id="preimg0" src="https://images2.imgbox.com/d3/50/xF162KOa_o.gif" height="9" width="9" alt="" style="margin:0px; padding:0px; border:0px; overflow:auto; max-width:100%; height:auto"> 
 <span id="precollapse0" style="margin:0px; padding:0px; border:0px"> Collapse</span> 
 <span style="margin:0px; padding:0px; border:0px"> | </span> 
 <a href="http://www.codeproject.com/Articles/19723/Repositioning-Windows-on-Multiple-Monitor-Systems#" rel="nofollow" style="margin:0px; padding:0px; border:0px; text-decoration:initial; color:purple">Copy Code</a> 
</div> 
<pre lang="C++" id="pre0" style="background-color:rgb(251,237,187); padding:6px; font-size:16px; font-family:Consolas,'Courier New',Courier,mono; white-space:pre-wrap; border:1px solid rgb(251,237,187); overflow:auto; word-wrap:break-word; margin-top:0px">SystemParametersInfo( SPI_GETWORKAREA, <span class="code-digit" style="margin:0px; padding:0px; border:0px; color:navy">0</span>, &amp;rc, <span class="code-digit" style="margin:0px; padding:0px; border:0px; color:navy">0</span> );<span class="code-comment" style="margin:0px; padding:0px; border:0px; color:rgb(0,128,0); font-style:italic">//</span><span class="code-comment" style="margin:0px; padding:0px; border:0px; color:rgb(0,128,0); font-style:italic">only primary Monitor</span></pre> 
<p style="font-family:'Segoe UI',Arial,sans-serif; font-size:16px; color:rgb(17,17,17)"> Here is a possible setup for two displays: the left (1) is the standard monitor, and the right (2) is the extension monitor, for instance, for less needed information like help, e-mail, or browsing.</p> 
<img src="https://images2.imgbox.com/ef/0c/enX7FbMr_o.jpg" alt=""> 
<br> 
<p align="left"></p> 
<h3 style="font-family:'Segoe UI',Arial,sans-serif; font-size:20px; color:rgb(255,153,0); margin:20px 0px 11px"> Background</h3> 
<p></p> 
<p style="font-family:'Segoe UI',Arial,sans-serif; font-size:16px; color:rgb(17,17,17)"> Last week, I got a problem of<span style="background-color:rgb(255,204,204)"> restoring a window</span>on a computer which had multiple monitors. I looked for some samples, but found no good ones, so I wrote some code to solve the issue. And, I want to demonstrate my new knowledge and publish it here.</p> 
<p style="font-family:'Segoe UI',Arial,sans-serif; font-size:16px"><span style="color:rgb(17,17,17)">But there are other setups possible; it might look strange, for instance, to have the right monitor as the primary one.</span><span style="color:#990000">This means that the coordinates of the left monitor have negative values.</span></p> 
<br> 
<p align="left"><img src="https://images2.imgbox.com/03/a5/4IILBab7_o.jpg" alt=""><br> </p> 
<p align="left"></p> 
<h3 style="font-family:'Segoe UI',Arial,sans-serif; font-size:20px; color:rgb(255,153,0); margin:20px 0px 11px"> The taskbar</h3> 
<p></p> 
<p style="font-family:'Segoe UI',Arial,sans-serif; font-size:16px; color:rgb(17,17,17)"> The taskbar also needs some space, so it is better that this area wont be used to show windows. The taskbar can have different positions. This is illustrated from the standard position (1) up to three different positions (2)-(4).</p> 
<div> 
 <img src="https://images2.imgbox.com/0c/05/EjAHOuVq_o.jpg" alt=""> 
 <br> 
</div> 
<br> 
<p align="left"></p> 
<h3 style="font-family:'Segoe UI',Arial,sans-serif; font-size:20px; color:rgb(255,153,0); margin:20px 0px 11px"> Using the code</h3> 
<p></p> 
<p style="font-family:'Segoe UI',Arial,sans-serif; font-size:16px; color:rgb(17,17,17)"> I packed all the interesting code in a designed class to concentrate(<span class="def">浓缩)</span>it and for ease of use. Because of</p> 
<p style="font-family:'Segoe UI',Arial,sans-serif; font-size:16px; color:rgb(17,17,17)"> <code style="margin:0px; padding:0px; border:0px; color:rgb(153,0,0); font-size:11pt; font-family:Consolas,'Courier New',Courier,mono">#define COMPILE_MULTIMON_STUBS</code>, you got to pay some attention on how to use the class. If you find a better way, let me know it.</p> 
<p style="font-family:'Segoe UI',Arial,sans-serif; font-size:16px; color:rgb(17,17,17)"> Now I have coded a global object, so you don't need an extra object, and the object is available if you include the files in your project.</p> 
<pre><code class="language-cpp">//Fetch informations
int cnt ) gMonitor.GetCount(); 
int iMonitor = gMonitor.GetPrimary();

//test for repositioning
CRect rc;
GetWindowRect( rc );

iMonitor = gMonitor.GetNearestDisplay( rc ); //also overloaded for point

if( !gMonitor.EnsureInMonitor( rc, iMonitor ) )
    MoveWindow( rc );</code></pre> 
<br> 
<h3 style="font-family:'Segoe UI',Arial,sans-serif; font-size:20px; color:rgb(255,153,0); margin:20px 0px 11px"> Points of interest</h3> 
<p style="font-family:'Segoe UI',Arial,sans-serif; font-size:16px; color:rgb(17,17,17)"> This code can help you for a better user experience with multiple monitor systems, because a window will be moved if it doesn't fit on one physical screen.</p> 
<p style="font-family:'Segoe UI',Arial,sans-serif; font-size:16px; color:rgb(17,17,17)"> It gets real tricky. When the primary display is the right one (or the upper?), then the left (top) has negative values and sizing needs some extra lines of code.</p> 
<p style="font-family:'Segoe UI',Arial,sans-serif; font-size:16px; color:rgb(17,17,17)"> Also, watch out for the taskbar area, which is another pitfall.</p> 
<br> 
<p align="left"> </p> 
<p align="left"> </p> 
<p align="left"> </p> 
<p align="left"> </p> 
<p align="left"> </p> 
<h2 class="reader_ab_test" style="margin:0px; padding:0px 0px 10px; font-size:20px; font-family:微软雅黑,黑体,arial; color:rgb(51,51,51); width:auto"> <span id="doc-tittle-5">多<wbr></wbr>显<wbr></wbr>示<wbr></wbr>器<wbr></wbr>A<wbr></wbr>P<wbr></wbr>I<wbr></wbr>函<wbr></wbr>数</span></h2> 
<div> 
 <strong>Windows系统的多显示器模式的编程 </strong> 
</div> 
<div> 
 <br>  
</div> 
<div>
   这几天研究了一下Windows系统的多显示器模式的编程,实现了Windows下 
 <span style="background-color:rgb(255,102,102)">支持10显示器模式的通用com组件</span>,这里做一个整理和回顾,希望能对再这方面开发的兄弟们有些启发和帮助:  
</div> 
<div>
   (一) Windows系统下的多显示器模式的原理      
</div> 
<div>
   Microsoft新的操作系统（Windows 98\Windows 2000\Windows XP）内置了对多监视器的支持，即用户可以在一台计算机上安装多个显示卡并接上多个显示器，然后把这些显示器的显示区域组织成一个 
 <span style="background-color:rgb(255,153,102)">大的虚拟的Windows桌面</span>。每一个显示区域的底部都有系统任务栏，我们 
 <span style="background-color:rgb(255,102,102)">可以在任何一个显示区域内增加桌面快捷方式</span>，这样就可以在第一个显示区域上用Visual C＋＋编程，同时在第二个显示区域上打开Internet Explorer上网——再也不用进行麻烦的切换了。      
</div> 
<div>
  多显示器模式的原理实际上很简单,主要还是要靠操作系统的支持,比如 
 <span style="background-color:rgb(255,153,102)">WinXP就支持10个显示器</span>,本文所使用的调试和开发环境都是以WinXP为主,其余的原理都相同慢慢调试就行了.  
</div> 
<div> 
 <strong>Windows提供的多显示器模式主要有以下三个功能</strong>：     
</div> 
<div>
  1.更大的Windows桌面：在多显示器模式下，可以把多个显示器的显示区域结合在一起来显示Windows桌面，不管这些显示器的尺寸、物理位置、分辨率和刷新频率是否相同。当我们运行一个应用程序时，程序的主窗口可以位于任何一个显示器的显示区域内，也可以跨多个显示区域。我们也可以把一个程序的窗口从一个显示区域移到另一个显示区域中。   
</div> 
<div>
  2. 屏幕复制或远程显示：我们可以让两个显示器显示相同的内容。在进行培训或者向众人进行演示时，这个特点是很有用的。利用这个特性，技术支持人员还可以对应用程序进行远程监视和调试。    
</div> 
<div>
  3.多重独立显示：在以上的两种模式下，所有的显示区域都是Windows虚拟桌面的一部分，但是在 
 <span style="background-color:rgb(255,153,102)">多重独立显示模式下，应用程序访问的显示器并不属于Windows虚拟桌面</span>。假设系统的第二个显示器是一个高分辨率的大尺寸显示器，我们可以把它用做CAD应用程序的专用显示。通过 
 <span style="background-color:rgb(255,153,102)">在CAD应用程序中调用新的Windows API，我们可以借助GDI在上面画图</span>。独立显示器的显示区域没有桌面上的任何对象（任务栏和快捷方式），它与Windows桌面是独立的。这可以避免Windows桌面对应用程序输出的任何干扰，我们也 
 <span style="background-color:rgb(255,153,102)">不用担心会在无意中把其它的窗口拽到独立显示的显示区域中</span>，这种方式就好像为应用程序提供了一个专用的显示器。 
</div> 
<div>
   (二)理解虚拟桌面（Virtual Desktop）及其坐标 既然是要对多显示器模式进行编程和开发,那么我们就要首先理解Windows的虚拟桌面（Virtual Desktop））及其坐标了.这是我们编程开发的基础,理解了一切就很顺利了,几乎没有什么难度.   在单显示器系统中，实际Windows桌面的形状和大小与显示器是相同的。在多显示器模式下，每一个显示器 
 <br> 
</div> 
<div> 
 <br> 
</div> 
<div> 
 <span style="background-color:rgb(255,153,102)">实际上是一个大虚拟桌面的一个“子视窗”</span>。   我们可以通过控制面板中的显示器属性对每一个显示器的显示区域的大小（分辨率）和相对位置进行调整，所有这些显示区域互相连接但并不重叠。 
</div> 
<div>
  图一中的显示器1是主显示器， 
 <span style="background-color:rgb(51,204,0)">主显示器的作用是确定虚拟桌面的坐标。</span>不管主显示器的位置如何，它的显示区域的左上角的坐标定为虚拟坐标的零点（0，0），右下角的坐标是（X－1，Y－1）（假设主显示器的分辨率为X×Y）， 
 <span style="color:#990000">其余显示区域的坐标由它和主显示器的相对位置决定</span>。通常虚拟桌面中显示区域的相对位置和实际显示器的物理相对位置是相同的。因为所有显示区域必须相连，因此可以用一个包含所有显示区域的最小矩形来表示虚拟桌面的大小。图一中的矩形边界代表了虚拟桌面的范围。      
</div> 
<div>
  因为虚拟桌面中的坐标系统必须是连续的，因此第二个显示区域的坐标是主显示器的显示区域的继续。假设两个显示器都使用1024×768的分辨率，并且第二个显示器位于第一个显示器（主显示器）的正右方，则 
 <span style="background-color:rgb(255,153,102)">第二个显示区域的坐标是从（1024，0）到（2047，767）</span>。   但是并不是所有的显示区域都具有相同的分辨率，而且这些显示区域也不一定是底边对齐的。就像图一中显示的那样，你真正能看到的有效显示区域是红色＋兰色＋紫色的不规则区域，而黄色区域虽然也属于虚拟桌面的一部分，但它不属于任何一个显示区域，这部分也叫做 
 <span style="background-color:rgb(255,153,102)">无效区域</span>。 
</div> 
<div>
  如图一中所示，假设显示器1的分辨率是1024×768，显示器2的分辨率为800×600，显示器3的分辨率为640×480。零点的位置如图中所示，显示器1的坐标为（0，0）到（1023，767）， 
 <span style="background-color:rgb(255,153,102)">显示器2的坐标为（－800，168）到（－1，767）</span>，显示器3的坐标是（1024，0）到（1663，479）。而（－800，0）到（－1，167）以及（1024，480）到（1663，767）这两块无效区域是不能显示任何信息的，系统不会允许用户把鼠标移动到这两个区域。需要注意的是无效区域是包括在虚拟桌面中的，因此图一中的虚拟桌面的大小是从（－800，0）到（1663，767）。 
 <br> 
</div> 
<div> 
 <br> 
</div> 
<div>
  我在编程开发的过程中就使用了2个显示器,一个是自己的笔记本,分辨率为1024×768作为主显示器,另外一个由于比较懒,直接找了一个小巧的NEC12寸屏幕的小黑白显示器,不是为了别的搬着方便啊,这个NEC黑白支持分辨率800×600,强吧. 如下图我是直接设置了扩展桌面,两个显示器就都可以使用了 在这里要注意主显示器和副显示器的区别,其实主显示器和副显示器你是可以进行任意调整的. 
</div> 
<div>
  (三)系统支持编程开发的API   
</div> 
<div>
   Microsoft为支持多显示器模式提供了一些新的API调用，下面具体介绍它们的功能：   
</div> 
<div>
  1.HMONITOR MonitorFromPoint（POINT pt，DWORD dwFlags）  
 <br> 
</div> 
<div> 
 <br> 
</div> 
<div> 
 <br> 
</div> 
<div> 
 <span style="background-color:rgb(255,102,102)"> MonitorFromPoint返回包含特定点（pt）的一个显示器句柄</span>。如果pt不属于任何一个显示器，返回的显示器句柄由dwFlags标志决定： 
</div> 
<div>
  MONITOR_DEFAULTTONULL时返回NULL，MONITOR_DEFAULTTOPRIMARY时返回代表主显示器的HMONITOR句柄，MONITOR_DEFAULTTONEAREST时返回最靠近pt点的显示器的HMONITOR句柄。    
</div> 
<div>
   2.HMONITOR MonitorFromRect(LPCRECT lprc，DWORD dwFlags)   
 <span style="background-color:rgb(255,102,102)"> MonitorFromRect返回包含lprc代表的矩形的显示器句柄</span>；如果包含此矩形的显示区域不止一个，则返回包含矩形最大部分的显示器句柄；如果矩形不属于任何一个显示区域，返回的句柄由dwFlags决定，规则与MonitorFromPoint相同。    
</div> 
<div>
  3. HMONITOR MonitorFromWindow(HWND hwnd，DWORD dwFlags)   与MonitorFromRect类似，但输入是一个代表窗口的句柄hwnd而不是指向矩形的指针。 
 <br> 
</div> 
<div>
   4. BOOL GetMonitorInfo(HMONITOR hMonitor，LPMONITORINFO lpmi)  
</div> 
<div>
   GetMonitorInfo返回由hMonitor代表的显示器的有关信息，这些信息存储在指向MONITORINFO结构的指针——lpmi中。这些信息包括用RECT结构表示的显示器的显示区域的大小( 
 <span style="background-color:rgb(255,102,102)">如果这个显示器不是主显示器，RECT的坐标可能为负数</span>)，以及用RECT结构表示的显示器的工作区域的大小，工作区域是显示区域中除去系统任务栏和应用程序快捷方式栏所剩下的区域， 
 <span style="background-color:rgb(255,153,102)">还能够判断此显示器是否为主显示器</span>，并返回一个标志。   
</div> 
<div> 
 <br> 
</div> 
<div>
   5.BOOL EnumDisplayMonitors(HDC hdc，LPCRECT lprcClip，MONITORENUMPROC lpfnEnum，LPARAM dwData)   
</div> 
<div>
    hdc是一个代表显示设备环境的句柄，lprcClip是指向一个矩形区域的指针。把这个矩形区域和设备环境中的可见区域取交集，得到的区域可能分布在多个显示器的显示区域中，EnumDisplayMonitors 
 <span style="background-color:rgb(255,204,153)">对每一个包含交集的显示区域调用一次MonitorEnumProc类型的函数</span>。DwData为传递给MonitorEnumProc函数的数据。   
</div> 
<div> 
 <br> 
</div> 
<div>
   6.BOOL CALLBACK MonitorEnumProc(HMONITOR hmonitor，HDC hdcMonitor，LPRC lprcMonitor, DWORD dwData)  
</div> 
<div>
  MonitorEnumProc是一个被函数调用的回调函数，它的内容可以由用户自定义。利用这两个函数，用户在进行跨多个显示器的显示时就可以利用每一个显示器的不同的显示特性。   当然，并不是所有画图程序都必须调用这两个函数，这时你假设所有的显示器都使用同样颜色的分辨率。  
</div> 
<div> 
 <br> 
</div> 
<div>
   7.EnumDisplayDevices(LPVOID lpReserved，int iDeviceNum，DISPLAY_DEVICE×pDisplayDevice，DWORD dwFlags)    
</div> 
<div> 
 <span style="background-color:rgb(255,204,204)">EnumDisplayDevices列出系统中某个显示设备（以iDeviceNum为序号）的信息</span>。与GetMonitorInfo相比，GetMonitorInfo对应的显示器必须是Windows虚拟桌面的一部分，而EnumDisplayDevices 
 <span style="background-color:rgb(255,153,102)">可以列出包括处于独立显示模式下的系统所安装的所有显示器的信息</span>。它返回的信息储存在DISPLAY_DEVICE结构中，包括显示 
 <span style="background-color:rgb(255,153,102)">设备名称、对显示设备的描述和显示设备的状态</span>。    
</div> 
<div>
  此外，一些原有的API调用如SystemParametersInfo和GetSystemMetrics也加入了对多显示器模式的支持。比如调用GetSystemMetrics时，如果用SM_XVIRTUALSCREEN、SM_YVIRTUALSCREEN、SM_CXVIRTUALSCREEN和SM_CYVIRTUALSCREEN，得到的是 
 <span style="background-color:rgb(51,255,51)">虚拟桌面左上角的坐标和整个的长度和宽度</span>。    
</div> 
<div>
  我们在编程时特别要注意坐标的变化： 
</div> 
<div>
  首先 
 <span style="background-color:rgb(255,153,102)">单显示器下负坐标或大于SM_CXSCREEN和SM_CYSCREEN部分的窗口将被隐藏，而在多显示器模式下这些都是合法的</span>。 
</div> 
<div>
  其次在确定应用程序窗口和对话框的位置时，要 
 <span style="color:#cc0000">选择正确的显示器和正确的全局坐标（虚拟桌面坐标</span>）。最后，在恢复原来存储的窗口之前，要检查一下这些窗口坐标的有效性。       
</div> 
<div>
  这些都可以在微软的MSDN上去查出来,需要仔细的看一看,每个API都亲自试一试.      大家可以参考MSND的一篇文章"How to Exploit Multiple Monitor Support in Memphis and Windows NT 5.0",说的很详细 
 <br> 
</div> 
<p></p> 
<p> </p> 
<p>(四)实现多屏幕编程的组件设计 这个组件参考了网上的许多资料,这里先向那些无私的同行表示感谢,我做的工作只是将他们的成果进行了系统化的整理...... </p> 
<p>组件的设计流程如下: </p> 
<p>(1).初始化程序 Syntax:: MScreenInfo(); </p> 
<p>Description : 部件构造函数，初始化部件，获取系统屏幕信息，设置部件属性。</p> 
<p> (2). 获取指定屏幕的宽度 </p> 
<p>Syntax: Short GetScreenWidth( Short ScreenNo) ; <br> </p> 
<p>Input : ScreenNo -- 指定屏幕的序号，0 -- m_monitorNum-1; Return: Screen Width in Pixel;</p> 
<p> Decription: 获取ScreenNo指定屏幕的宽度。</p> 
<p> (3). 获取指定屏幕的高度</p> 
<p> Syntax: Short GetScreenHeight( Short ScreenNo) ; </p> 
<p>Input : ScreenNo -- 指定屏幕的序号，0 -- m_monitorNum-1; Return: Screen Height in Pixel; </p> 
<p>Decription: 获取ScreenNo指定屏幕的高度。 程序流程图：</p> 
<p>与图2相同，只是最后一步返回dm.dmPelsHeight.</p> 
<p> (4). 获取指定屏幕的坐标原点-left Syntax: Short GetScreenLeft( Short ScreenNo) ;</p> 
<p> Input : ScreenNo -- 指定屏幕的序号，0 -- m_monitorNum-1; Return: Screen Left in Pixel;</p> 
<p> Decription: 获取ScreenNo指定屏幕的坐标原点-left。 程序流程图：与图2相同，只是最后一步返回dm.dmPosition.x.</p> 
<p>(5). 获取指定屏幕的坐标原点-top Syntax: Short GetScreenLeft( Short ScreenNo) ; </p> 
<p>Input : ScreenNo -- 指定屏幕的序号，0 -- m_monitorNum-1; Return: Screen Top in Pixel; </p> 
<p>Decription: 获取ScreenNo指定屏幕的坐标原点-top。 程序流程图：与图2相同，只是最后一步返回dm.dmPosition.y.<br> </p> 
<p><br> </p> 
<p>(6). 获取主屏幕--Primary Screen</p> 
<p> Syntax: Short GetPrimaryScreen();</p> 
<p> Input: Null; </p> 
<p>Return: Primary Screen No, 0 -- m_monitorNum - 1</p> 
<p> Description: 获取主屏幕的序号。 程序流程：依次判断那一个屏幕的原点是(0, 0). <br> </p> 
<h4>(五)组件开发的实现和主要代码</h4> 
<p> 1 开发环境 操作系统: WindowsXP  </p> 
<p>  编程环境: VC 6.0 </p> 
<p>2 组件接口如下</p> 
<p> 3 主要代码 </p> 
<p><br> </p> 
<p></p> 
<pre><code class="language-cpp">// 获得显示器的数量
 CMScreenInfoCtrl::CMScreenInfoCtrl()
 {
	InitializeIIDs(&amp;IID_DMScreenInfo, &amp;IID_DMScreenInfoEvents); 
	// 找出显示器的总数量 
	int   i; 
	BOOL flag; 
	DISPLAY_DEVICE dd;
	i = 0; 
	flag = true;    
	ZeroMemory(&amp;dd, sizeof(dd));      
	dd.cb = sizeof(dd); 
	do 
	{    
		flag = EnumDisplayDevices(NULL, i, &amp;dd, 0);    
		if (flag) 
			i += 1; 
	} while (flag); 
	m_monitorNum = i;  
 // 总数量
 }

 // 获得显示区宽度
short CMScreenInfoCtrl::GetScreenWidth(short ScreenNo)
{
	if (ScreenNo &lt; 0 || ScreenNo &gt;= m_monitorNum)
		return 0; 
	BOOL flag; 
	DISPLAY_DEVICE dd;      
	ZeroMemory(&amp;dd, sizeof(dd));      
	dd.cb = sizeof(dd); 
	flag = EnumDisplayDevices(NULL, ScreenNo, &amp;dd, 0); 
	if (!flag) 
		return 0; 
	DEVMODE dm; 
	ZeroMemory(&amp;dm, sizeof(dm)); 
	dm.dmSize = sizeof(dm); 
	flag = EnumDisplaySettings((char*)dd.DeviceName,ENUM_CURRENT_SETTINGS, &amp;dm); 
	if (!flag) 
		return 0; 
	return (short) dm.dmPelsWidth; 
} 

// 设置显示区宽度 
void CMScreenInfoCtrl::SetScreenWidth(short ScreenNo, short nNewValue) 
{ 
	SetModifiedFlag(); 
}
// 获得显示区宽度 
short CMScreenInfoCtrl::GetScreenHeight(short ScreenNo)
{ 
	if (ScreenNo &lt; 0 || ScreenNo &gt;= m_monitorNum) 
		return 0; 
	BOOL flag; 
	DISPLAY_DEVICE dd;      
	ZeroMemory(&amp;dd, sizeof(dd));      
	dd.cb = sizeof(dd); 
	flag = EnumDisplayDevices(NULL, ScreenNo, &amp;dd, 0); 
	if (!flag) 
		return 0;
	DEVMODE dm; 
	ZeroMemory(&amp;dm, sizeof(dm)); 
	dm.dmSize = sizeof(dm); 
	flag = EnumDisplaySettings((char*)dd.DeviceName,ENUM_CURRENT_SETTINGS, &amp;dm); 
	if (!flag) 
		return 0; 
	return (short) dm.dmPelsHeight; 
}

// 设置显示区高度 
void CMScreenInfoCtrl::SetScreenHeight(short ScreenNo, short nNewValue)
{
	SetModifiedFlag(); 
}
// 获得显示区Y坐标 
short CMScreenInfoCtrl::GetScreenTop(short ScreenNo) 
{ 
	if (ScreenNo &lt; 0 || ScreenNo &gt;= m_monitorNum) 
		return -1; BOOL flag; DISPLAY_DEVICE dd;      
	ZeroMemory(&amp;dd, sizeof(dd));     
	dd.cb = sizeof(dd); 
	flag = EnumDisplayDevices(NULL, ScreenNo, &amp;dd, 0); 
	if (!flag) 
		return -1; 
	DEVMODE dm; 
	ZeroMemory(&amp;dm, sizeof(dm)); 
	dm.dmSize = sizeof(dm); 
	flag = EnumDisplaySettings((char*)dd.DeviceName,ENUM_CURRENT_SETTINGS, &amp;dm); 
	if (!flag) 
		return -1; 
	return (short) dm.dmPosition.y ;
}

// 设置显示区Y坐标 
void CMScreenInfoCtrl::SetScreenTop(short ScreenNo, short nNewValue) 
{ 
	SetModifiedFlag(); 
} 
// 获得显示区X坐标 
short CMScreenInfoCtrl::GetScreenLeft(short ScreenNo)
{ 
	if (ScreenNo &lt; 0 || ScreenNo &gt;= m_monitorNum) 
		return -1; 
	BOOL flag; 
	DISPLAY_DEVICE dd;      
	ZeroMemory(&amp;dd, sizeof(dd));      
	dd.cb = sizeof(dd); 
	flag = EnumDisplayDevices(NULL, ScreenNo, &amp;dd, 0); 
	if (!flag) 
		return -1; 
	DEVMODE dm; 
	ZeroMemory(&amp;dm, sizeof(dm)); 
	dm.dmSize = sizeof(dm); 
	flag = EnumDisplaySettings((char*)dd.DeviceName,ENUM_CURRENT_SETTINGS, &amp;dm); 
	if (!flag) 
		return -1; 
	return (short) 
	dm.dmPosition.x ; 
} 
// 设置显示区X坐标 
void CMScreenInfoCtrl::SetScreenLeft(short ScreenNo, short nNewValue)
{ 
	SetModifiedFlag(); 
} 

// 获得主显示区 
short CMScreenInfoCtrl::GetPrimaryScreen() 
{ 
	// TODO: Add your property handler here 
	if (m_monitorNum &lt;= 1) 
		return 0; 
	// if the Screen Top = 0 and Left = 0, then, it’s the Primary Screen 
	short i; 
	for (i=0; i&lt;m_monitorNum; i++)
	{    
		if (GetScreenTop(i)==0 &amp;&amp; GetScreenLeft(i)==0) 
			return i; 
	} 
	return 0; 
} 
// 设置主显示区 
void CMScreenInfoCtrl::SetPrimaryScreen(short nNewValue)
{ 
	SetModifiedFlag();
}
</code></pre> 
<br> 
<br> 
<p></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/1b0fd634c1f8813638ec4b983df18555/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">QT中用Qpainter的drawText方法程序crash的可能原因</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/4a8f004f9d1cd5d3093a2d6a28f60bbe/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">UVA 11538(Chess Queen-矩阵对角线长度)</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>