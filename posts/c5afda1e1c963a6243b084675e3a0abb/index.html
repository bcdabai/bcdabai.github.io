<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>GNU Makefile教程入门 - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="GNU Makefile教程入门" />
<meta property="og:description" content="Intro 1 GCC 官方文档 GCC 官方文档网站：https://gcc.gnu.org/onlinedocs/
官方文档是最权威的，网上所有的答案都来自官方文档适应英语阅读，中文是母语，很多词我们自己有根深蒂固的含义和概念，再重新赋予新含义非常不容易理解或有歧义英语用词、逻辑比较严谨，网上的翻译水平参差不齐，坑很多国内论坛找到好答案全凭运气，好的答案可以节省时间，没有好的答案还是得花时间看官方文档，所以还是自己靠谱一点，锻炼一下英语能力 2 GCC的介绍 GCC 是 GNU项目的一个产品。
GCC（GNU Compiler Collection，GNU编译程序集合）是最重要的开放源码软件。其他所有开放源码软件都在某种层次上依赖于它。甚至其他语言，例如 Python，都是由 C 语言开发的，由 GNU 编译程序编译的。
这个软件对于整个自由软件运动而言具有根本性的意义。如果没有它或类似的软件，就不可能有自由软件运动。GCC 为 Linux 的出现提供了可能性。
GCC 是由许多组件组成的，但它们也并不总是出现的。有些部分是和语言相关的，所以如果没有安装某种特定语言，系统中就不会出现相关的文件。
2.1 GCC常见的组成部分 c&#43;&#43;： gcc 的一个版本，默认语言设置为 C&#43;&#43;，而且在链接的时候自动包含标准 C&#43;&#43; 库。这和 g&#43;&#43; 一样
configure： GCC 源代码树根目录中的一个脚本。用于设置配置值和创建 GCC 编译程序必需的 make 程序文件
g&#43;&#43;： gcc 的一个版本，默认语言设置为 C&#43;&#43;，而且在链接的时候自动包含标准 C&#43;&#43;库。这和 c&#43;&#43; 一样
gcc： 该驱动程序等同于执行编译程序和连接程序以产生需要的输出
libgcc： 该库包含的例程被作为编译程序的一部分，是因为它们可被链接到实际的可执行程序中。它们是特殊的例程，链接到可执行程序，来执行基本的任务，例如浮点运算。这些库中的例程通常都是平台相关的
libstdc&#43;&#43;： 运行时库，包括定义为标准语言一部分的所有的 C&#43;&#43;类和函数
2.2 GCC包含的常见的软件 ar： 这是一个程序，可通过从文档中增加、删除和析取文件来维护库文件。通常使用该工具是为了创建和管理连接程序使用的目标库文档。该程序是 binutils 包的一部分
as： GNU 汇编器。实际上它是一族汇编器，因为它可以被编译或能够在各种不同平台上工作。该程序是 binutjls 包的一部分
autoconf：产生的 shell 脚本自动配置源代码包去编译某个特定版本的 UNIX" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/c5afda1e1c963a6243b084675e3a0abb/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-04-13T15:11:52+08:00" />
<meta property="article:modified_time" content="2023-04-13T15:11:52+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">GNU Makefile教程入门</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-light">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <h2><a id="Intro_0"></a>Intro</h2> 
<h2><a id="1_GCC__1"></a>1 GCC 官方文档</h2> 
<p>GCC 官方文档网站：https://gcc.gnu.org/onlinedocs/</p> 
<ul><li>官方文档是最权威的，网上所有的答案都来自官方文档</li><li>适应英语阅读，中文是母语，很多词我们自己有根深蒂固的含义和概念，再重新赋予新含义非常不容易理解或有歧义</li><li>英语用词、逻辑比较严谨，网上的翻译水平参差不齐，坑很多</li><li>国内论坛找到好答案全凭运气，好的答案可以节省时间，没有好的答案还是得花时间看官方文档，所以还是自己靠谱一点，锻炼一下英语能力</li></ul> 
<p> </p> 
<h2><a id="2_GCC_11"></a>2 GCC的介绍</h2> 
<p>  GCC 是 GNU项目的一个产品。</p> 
<p>  GCC（GNU Compiler Collection，GNU编译程序集合）是最重要的开放源码软件。其他所有开放源码软件都在某种层次上依赖于它。甚至其他语言，例如 Python，都是由 C 语言开发的，由 GNU 编译程序编译的。</p> 
<p>  这个软件对于整个自由软件运动而言具有根本性的意义。如果没有它或类似的软件，就不可能有自由软件运动。GCC 为 Linux 的出现提供了可能性。</p> 
<p>  GCC 是由许多组件组成的，但它们也并不总是出现的。有些部分是和语言相关的，所以如果没有安装某种特定语言，系统中就不会出现相关的文件。</p> 
<p> </p> 
<h3><a id="21_GCC_21"></a>2.1 GCC常见的组成部分</h3> 
<ul><li> <p><strong>c++：</strong> gcc 的一个版本，默认语言设置为 C++，而且在链接的时候自动包含标准 C++ 库。这和 g++ 一样</p> </li><li> <p><strong>configure：</strong> GCC 源代码树根目录中的一个脚本。用于设置配置值和创建 GCC 编译程序必需的 make 程序文件</p> </li><li> <p><strong>g++：</strong> gcc 的一个版本，默认语言设置为 C++，而且在链接的时候自动包含标准 C++库。这和 c++ 一样</p> </li><li> <p><strong>gcc：</strong> 该驱动程序等同于执行编译程序和连接程序以产生需要的输出</p> </li><li> <p><strong>libgcc：</strong> 该库包含的例程被作为编译程序的一部分，是因为它们可被链接到实际的可执行程序中。它们是特殊的例程，链接到可执行程序，来执行基本的任务，例如浮点运算。这些库中的例程通常都是平台相关的</p> </li><li> <p><strong>libstdc++：</strong> 运行时库，包括定义为标准语言一部分的所有的 C++类和函数</p> </li></ul> 
<p> </p> 
<h3><a id="22_GCC_37"></a>2.2 GCC包含的常见的软件</h3> 
<ul><li> <p><strong>ar：</strong> 这是一个程序，可通过从文档中增加、删除和析取文件来维护库文件。通常使用该工具是为了创建和管理连接程序使用的目标库文档。该程序是 binutils 包的一部分</p> </li><li> <p><strong>as：</strong> GNU 汇编器。实际上它是一族汇编器，因为它可以被编译或能够在各种不同平台上工作。该程序是 binutjls 包的一部分<br> autoconf：产生的 shell 脚本自动配置源代码包去编译某个特定版本的 UNIX</p> </li><li> <p><strong>gdb：</strong> GNU 调试器，可用于检查程序运行时的值和行为<br> GNATS：GNU 的调试跟踪系统（GNU Bug Tracking System）。一个跟踪 GCC和其他 GNU 软件问题的在线系统</p> </li><li> <p><strong>gprof：</strong> 该程序会监督编译程序的执行过程，并报告程序中各个函数的运行时间，可以根据所提供的配置文件来优化程序。该程序是 binutils 包的一部分</p> </li><li> <p><strong>ld：</strong> GNU 连接程序。该程序将目标文件的集合组合成可执行程序。该程序是 binutils 包的一部分</p> </li><li> <p><strong>libtool：</strong> 一个基本库，支持 make 程序的描述文件使用的简化共享库用法的脚本</p> </li><li> <p><strong>make：</strong> 一个工具程序，它会读 makefile 脚本来确定程序中的哪个部分需要编译和连接，然后发布必要的命令。它读出的脚本（叫做 makefile 或 Makefile）定义了文件关系和依赖关系</p> </li></ul> 
<p> </p> 
<h2><a id="3_GCC_58"></a>3 GCC默认头文件搜索路径</h2> 
<p>查看命令</p> 
<pre><code class="prism language-shell"><span class="token builtin class-name">echo</span> <span class="token operator">|</span> gcc -v -x c -E -
</code></pre> 
<ul><li>/usr/lib/gcc/x86_64-linux-gnu/7/include</li><li>/usr/local/include</li><li>/usr/lib/gcc/x86_64-linux-gnu/7/include-fixed</li><li>/usr/include/x86_64-linux-gnu</li><li>/usr/include</li></ul> 
<p> </p> 
<h2><a id="_73"></a>简单编译原理</h2> 
<h2><a id="1_hello_world_74"></a>1 hello, world在计算机的表示</h2> 
<p>hello 程序的生命周期是从一个源程序（或者说源文件）开始的，即程序员通过编辑器创建并保存的文本文件，文件名是 hello.c。源程序实际上就是一个由值 0 和 1组成的位（又称为比特）序列，8 个位被组织成一组，称为字节。每个字节表示程序中的某些文本字符</p> 
<p>大部分计算机使用 ASCII 标准来表示文本字符</p> 
<ul><li>用一个唯一的单字节大小的整数值息来表示每个字符</li><li>hello.c 程序是以字节序列的方式储存在文件中的</li></ul> 
<p>hello.c 的表示方法说明了一个基本思想∶ 系统中所有的信息——包括磁盘文件、内存中的程序、内存中存放的用户数据以及网络上传送的数据，都是由一串比特表示的</p> 
<p><img src="https://images2.imgbox.com/bb/b5/PMoU7d13_o.png" alt="在这里插入图片描述"></p> 
<p> </p> 
<h2><a id="2__87"></a>2 编译过程</h2> 
<p>hello 程序的生命周期从一个高级 C 语言程序开始</p> 
<p>为了在系统上运行 hello.c 程序，每条 C 语句都必须被其他程序转化为一系列的低级机器语言指令</p> 
<p>然后这些指令按照一种称为可执行目标程序的格式打好包，并以二进制磁盘文件的形式存放起来</p> 
<p>GCC 编译器读取源程序文件 hello.c，并把它翻译成一个可执行目标文件 hello。这个翻译过程可分为四个阶段完成，如下图所示</p> 
<p>执行这四个阶段的程序（预处理器、编译器、汇编器和链接器）一起构成了编译系统（compilation system）</p> 
<p>[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-iebLFNTc-1681369322961)(images/compilesystem.png)]</p> 
<p> </p> 
<h3><a id="21__101"></a>2.1 预处理阶段</h3> 
<p><code>预处理器（cpp）</code>根据以字符#开头的命令，修改原始的 C 程序。比如 hello.c中第 1行的#include &lt; stdio.h&gt;命令告诉预处理器读取系统头文件 stdio.h 的内容，并把它直接插入程序文本中。结果就得到了另一个 C程序，通常是以.i作为文件扩展名。</p> 
<p> </p> 
<h3><a id="22__105"></a>2.2 编译阶段</h3> 
<p><code>编译器（ccl）</code>将文本文件 hello.i翻译成文本文件 hello.s，它包含一<br> 个汇编语言程序。该程序包含函数 main 的定义，如下所示：</p> 
<pre><code>            main:
            subq    $8, %rsp 
            mov1    $.LCO,%edi 
            call    puts 
            mov1    $0,%eax 
            addq    $8,%rsp 
            ret
</code></pre> 
<p>每条语句都以一种文本格式描述了一条低级机器语言指令。汇编语言非常有用，它为不同高级语言的不同编译器提供了通用的输出语言</p> 
<p> </p> 
<h3><a id="23__120"></a>2.3 汇编阶段</h3> 
<p><code>汇编器（as）</code>将 hello.s 翻译成机器语言指令，把这些指令打包成一种叫做可重定位目标程序（relocatable object program）的格式，并将结果保存在目标文件 hello.o中。</p> 
<p>hello.o 文件是一个二进制文件，它包含的17 个字节是函数 main的指令编码。如果我们在文本编辑器中打开 hello.o文件，将看到一堆乱码。</p> 
<p> </p> 
<h3><a id="24__127"></a>2.4 链接阶段</h3> 
<p>注意，hello程序调用了 printf 函数，它是每个 C 编译器都提供的标准 C 库中的一个函数。printf 函数存在于一个名为 printf.o 的单独的预编译好了的目标文件中，而这个文件必须以某种方式合并到我们的 hello.o 程序中。</p> 
<p><code>链接器（ld）</code>就负责处理这种合并。结果就得到 hello 文件，它是一个可执行目标文件（或者简称为可执行文件），可以被加载到内存中，由系统执行。</p> 
<p> </p> 
<h2><a id="3_hello_world_133"></a>3 hello, world的执行过程</h2> 
<h3><a id="_136"></a>第一步</h3> 
<ul><li>shell 等待我们输入一个命令</li><li>当我们在键盘上输入字符串"./hello"（注意这里是编译好的可执行目标文件）后</li><li>shell 程序将字符逐一读入寄存器</li><li>再把它存放到内存中</li></ul> 
<p><img src="https://images2.imgbox.com/46/a6/ESIrPGtS_o.png" alt="在这里插入图片描述"></p> 
<h3><a id="_149"></a>第二步</h3> 
<ul><li>当我们在键盘上敲回车键时，shell 程序就知道我们已经结束了命令的输人</li><li>然后 shell 执行一系列指令来加载可执行的 hello 文件</li><li>这些指令将 hello 目标文件中的代码和数据从磁盘复制到主存</li><li>数据包括最终会被输出的字符串"hello，world\n"。</li></ul> 
<p><img src="https://images2.imgbox.com/87/12/ddiUee6v_o.png" alt="在这里插入图片描述"></p> 
<h3><a id="_159"></a>第三步</h3> 
<ul><li>一旦目标文件 hello 中的代码和数据被加载到主存</li><li>处理器就开始执行 hello 程序的 main 程序中的机器语言指令</li><li>这些指令将 “hello，world\n” 字符串中的字节从主存复制到寄存器文件</li><li>再从寄存器文件中复制到显示设备，最终显示在屏幕上<br> <img src="https://images2.imgbox.com/b6/52/BfG2SOND_o.png" alt="在这里插入图片描述"></li></ul> 
<p> </p> 
<h2><a id="4__167"></a>4 程序在计算机内的存储</h2> 
<p>上面的例子揭示了一个重要的问题，即系统“似乎”花费了大量的时间和步骤把信息从一个地方挪到另一个地方</p> 
<ul><li>hello程序的机器指令最初是存放在磁盘上</li><li>当程序加载时，它们被复制到主存</li><li>当处理器运行程序时，指令又从主存复制到处理器</li></ul> 
<p>相似地，数据串 "hello，world\n"开始时在磁盘上，然后被复制到主存，最后从主存上复制到显示设备</p> 
<p> </p> 
<h2><a id="1_Fundamental_Compiling_179"></a>1 Fundamental Compiling</h2> 
<blockquote> 
 <p>编译 C 语言相关的后缀<br> <img src="https://images2.imgbox.com/b4/ff/aT3K7KZj_o.png" alt="在这里插入图片描述"></p> 
</blockquote> 
<p> </p> 
<h2><a id="2_Compiling_C_184"></a>2 Compiling C</h2> 
<h3><a id="21_Preprocessing_186"></a>2.1 Preprocessing</h3> 
<pre><code class="prism language-shell"><span class="token comment"># 不会生成 .i 文件</span>
gcc -E main.c
gcc -E main.c -o helloworld.i
</code></pre> 
<ul><li>-E 选项告诉编译器只进行预处理操作</li><li>-o 选项把预处理的结果输出到指定文件</li></ul> 
<p> </p> 
<h3><a id="22_Generating_Assembly_Language_198"></a>2.2 Generating Assembly Language</h3> 
<pre><code class="prism language-shell">gcc -S main.c
gcc -S main.c -o xxx.s
</code></pre> 
<ul><li>-S 选项告诉编译器，进行预处理和编译成汇编语言操作</li></ul> 
<p>每个平台对应的汇编语言的形式是不同的，例如有很多型号的开发板，有很多型号的 CPU</p> 
<p> </p> 
<h3><a id="23_Source_File_to_Object_File_209"></a>2.3 Source File to Object File</h3> 
<pre><code class="prism language-shell">gcc -c main.c
gcc -c main.c -o xxx.o
<span class="token comment"># 编译多个 .c 文件</span>
gcc -c main.c add.c minus.c
</code></pre> 
<p> </p> 
<h3><a id="24_Single_Source_to_Executable_218"></a>2.4 Single Source to Executable</h3> 
<ul><li>注意：后面三个命令执行后并没有按编译过程出现 .i .s 或 .o 文件，并不意味着没有经历这些过程</li></ul> 
<pre><code class="prism language-shell">gcc main.c
gcc main.c -o xxx
</code></pre> 
<p>执行程序</p> 
<pre><code>./可执行文件
</code></pre> 
<h3><a id="25_Multiple_Sources_to_Executable_231"></a>2.5 Multiple Sources to Executable</h3> 
<pre><code>gcc main.c add.c minus.c -o exec
./exec
</code></pre> 
<p> </p> 
<h2><a id="3_Creating_a_Static_Library_239"></a>3 Creating a Static Library</h2> 
<ul><li>编译成 .o 的文件<pre><code class="prism language-shell">gcc -c <span class="token punctuation">[</span>.c<span class="token punctuation">]</span> -o <span class="token punctuation">[</span>自定义文件名<span class="token punctuation">]</span> 
gcc -c <span class="token punctuation">[</span>.c<span class="token punctuation">]</span> <span class="token punctuation">[</span>.c<span class="token punctuation">]</span> <span class="token punctuation">..</span>.
</code></pre> </li><li>编静态库<pre><code class="prism language-shell">ar -r <span class="token punctuation">[</span>lib自定义库名.a<span class="token punctuation">]</span> <span class="token punctuation">[</span>.o<span class="token punctuation">]</span> <span class="token punctuation">[</span>.o<span class="token punctuation">]</span> <span class="token punctuation">..</span>.
</code></pre> </li><li>链接成可执行文件<pre><code class="prism language-shell">gcc <span class="token punctuation">[</span>.c<span class="token punctuation">]</span> <span class="token punctuation">[</span>.a<span class="token punctuation">]</span> -o <span class="token punctuation">[</span>自定义输出文件名<span class="token punctuation">]</span>
gcc <span class="token punctuation">[</span>.c<span class="token punctuation">]</span> -o <span class="token punctuation">[</span>自定义输出文件名<span class="token punctuation">]</span> -l<span class="token punctuation">[</span>库名<span class="token punctuation">]</span> -L<span class="token punctuation">[</span>库所在路径<span class="token punctuation">]</span>
</code></pre> </li></ul> 
<p> </p> 
<h2><a id="4_Creating_a_Shared_Library_258"></a>4 Creating a Shared Library</h2> 
<blockquote> 
 <p>编译二进制.o文件</p> 
</blockquote> 
<pre><code class="prism language-shell">gcc -c -fpic <span class="token punctuation">[</span>.c/.cpp<span class="token punctuation">]</span><span class="token punctuation">[</span>.c/.cpp<span class="token punctuation">]</span><span class="token punctuation">..</span>. 
</code></pre> 
<blockquote> 
 <p>编库</p> 
</blockquote> 
<pre><code class="prism language-shell">gcc -shared <span class="token punctuation">[</span>.o<span class="token punctuation">]</span><span class="token punctuation">[</span>.o<span class="token punctuation">]</span><span class="token punctuation">..</span>. -o <span class="token punctuation">[</span>lib自定义库名.so<span class="token punctuation">]</span>
</code></pre> 
<ul><li>链接库到可执行文件</li></ul> 
<pre><code class="prism language-shell">gcc <span class="token punctuation">[</span>.c/.cpp<span class="token punctuation">]</span> -o <span class="token punctuation">[</span>自定义可执行文件名<span class="token punctuation">]</span>  -l<span class="token punctuation">[</span>库名<span class="token punctuation">]</span> -L<span class="token punctuation">[</span>库路径<span class="token punctuation">]</span> -Wl,-rpath<span class="token operator">=</span><span class="token punctuation">[</span>库路径<span class="token punctuation">]</span>
</code></pre> 
<p> </p> 
<h2><a id="_274"></a>总结</h2> 
<h3><a id="1__275"></a>1 编译过程</h3> 
<p>源文件.c文件 -&gt; 预编译成.i文件 -&gt; 编译成汇编语言.s -&gt; 汇编成.o文件 -&gt; 链接成可执行文件（名字自定义，后缀没关系）</p> 
<h3><a id="2__278"></a>2 编译过程命令</h3> 
<ul><li>预处理：<pre><code>gcc -E [.c源文件] -o [自定义输出文件名.i]
</code></pre> </li><li>编译成汇编语言(隐藏了预处理操作) :<pre><code>gcc -S [.c源文件] 
</code></pre> </li><li>会变成.o的object文件（二进制文件，可用于链接） :<pre><code>gcc -c [.c源文件] [.c源文件] [...] (可选选项：-o [自定文件名])
</code></pre> </li></ul> 
<h3><a id="3__291"></a>3 库</h3> 
<blockquote> 
 <p>静态库</p> 
</blockquote> 
<ul><li>编库（先转成.o文件，再编成lib[自定库名].a）<pre><code>gcc -c [.c源文件] [.c源文件] [...] (可选选项：-o [自定文件名])
</code></pre> <pre><code>ar -r lib[自定库名].a [.o文件] [.o文件] [...]
</code></pre> </li><li>链接<pre><code>gcc [main文件] -o [自定义输出可执行文件名] -l[库名] -L[库的路径]
</code></pre> </li></ul> 
<blockquote> 
 <p>动态库</p> 
</blockquote> 
<ul><li> <p>编库</p> 
  <ul><li>第一种做法， 先转成.o文件，再编成.so文件<pre><code class="prism language-shell">gcc -c -fpic <span class="token punctuation">[</span>.c源文件<span class="token punctuation">]</span> <span class="token punctuation">[</span>.c源文件<span class="token punctuation">]</span> <span class="token punctuation">[</span><span class="token punctuation">..</span>.<span class="token punctuation">]</span>
</code></pre> <pre><code class="prism language-shell">gcc -shared <span class="token punctuation">[</span>.o文件<span class="token punctuation">]</span> <span class="token punctuation">[</span>.o文件<span class="token punctuation">]</span> <span class="token punctuation">[</span><span class="token punctuation">..</span>.<span class="token punctuation">]</span> -o lib<span class="token punctuation">[</span>库名<span class="token punctuation">]</span>.so
</code></pre> </li><li>第二种做法，直接转成.so<pre><code class="prism language-shell">gcc -fpic -shared <span class="token punctuation">[</span>.c源文件<span class="token punctuation">]</span> <span class="token punctuation">[</span>.c源文件<span class="token punctuation">]</span> <span class="token punctuation">[</span><span class="token punctuation">..</span>.<span class="token punctuation">]</span> -o lib<span class="token punctuation">[</span>库名<span class="token punctuation">]</span>.so
</code></pre> </li></ul> </li><li> <p>链接</p> <pre><code class="prism language-shell">gcc <span class="token punctuation">[</span>main文件<span class="token punctuation">]</span> -o <span class="token punctuation">[</span>自定义输出可执行文件名<span class="token punctuation">]</span> -l<span class="token punctuation">[</span>库名<span class="token punctuation">]</span> -L<span class="token punctuation">[</span>库所在路径<span class="token punctuation">]</span> -Wl,-rpath<span class="token operator">=</span><span class="token punctuation">[</span>库所在路径<span class="token punctuation">]</span>
</code></pre> </li></ul> 
<p> </p> 
<h2><a id="Makefile_326"></a>Makefile</h2> 
<ul><li>GNU Make 官方网站：https://www.gnu.org/software/make/</li><li>GNU Make 官方文档下载地址：https://www.gnu.org/software/make/manual/</li><li>Makefile Tutorial：https://makefiletutorial.com/</li></ul> 
<p> </p> 
<h3><a id="1__333"></a>1 基本格式</h3> 
<pre><code class="prism language-makefile">targets : prerequisties
[tab键]command
</code></pre> 
<ul><li>target：目标文件，可以是 OjectFile，也可以是执行文件，还可以是一个标签（Label），对于标签这种特性，在后续的“伪目标”章节中会有叙述。</li><li>prerequisite：要生成那个 target 所需要的文件或是目标。</li><li>command：是 make 需要执行的命令，</li></ul> 
<p> </p> 
<h3><a id="2_Makefile__344"></a>2 Makefile 规则</h3> 
<ul><li>make 会在当前目录下找到一个名字叫 <code>Makefile</code> 或 <code>makefile</code> 的文件</li><li>如果找到，它会找文件中第一个目标文件（target），并把这个文件作为最终的目标文件</li><li>如果 target 文件不存在，或是 target 文件依赖的 .o 文件(prerequities)的文件修改时间要比 target 这个文件新，就会执行后面所定义的命令 command 来生成 target 这个文件</li><li>如果 target 依赖的 .o 文件（prerequisties）也存在，make 会在当前文件中找到 target 为 .o 文件的依赖性，如果找到，再根据那个规则生成 .o 文件</li></ul> 
<p> </p> 
<h3><a id="3__351"></a>3 伪目标</h3> 
<p>“伪目标” 不是一个文件，只是一个标签。我们要显示地指明这个 “目标” 才能让其生效</p> 
<p>“伪目标” 的取名不能和文件名重名，否则不会执行命令</p> 
<p>为了避免和文件重名的这种情况，我们可以使用一个特殊的标记 <code>.PHONY</code> 来显示地指明一个目标是“伪目标”，向 make 说明，不管是否有这个文件，这个目标就是 “伪目标”</p> 
<pre><code class="prism language-makefile">.PHONY : clean
</code></pre> 
<p>只要有这个声明，不管是否有“clean”文件，要运行 “clean” 这个目标，只有"make clean" 这个命令</p> 
<p> </p> 
<h2><a id="Makefile__368"></a>Makefile 的变量</h2> 
<p>变量在声明时需要给予初值，而在使用时，需要给在变量名前加上 <code>$</code> 符号，并用小括号 <code>()</code> 把变量给包括起来。</p> 
<p> </p> 
<h3><a id="1__372"></a>1 变量的定义</h3> 
<pre><code class="prism language-makefile">cpp := src/main.cpp 
obj := objs/main.o
</code></pre> 
<h3><a id="2__378"></a>2 变量的引用</h3> 
<ul><li>可以用 <code>()</code> 或 <code>{}</code></li></ul> 
<pre><code class="prism language-makefile">cpp := src/main.cpp 
obj := objs/main.o

$(obj) : ${cpp}
	@g++ -c $(cpp) -o $(obj)

compile : $(obj)
</code></pre> 
<p> </p> 
<h3><a id="3__391"></a>3 预定义变量</h3> 
<ul><li><code>$@</code>: 目标(target)的完整名称</li><li><code>$&lt;</code>: 第一个依赖文件（prerequisties）的名称</li><li><code>$^</code>: 所有的依赖文件（prerequisties），以空格分开，不包含重复的依赖文件</li></ul> 
<pre><code class="prism language-make">cpp := src/main.cpp 
obj := objs/main.o

$(obj) : ${cpp}
	@g++ -c $&lt; -o $@
	@echo $^

compile : $(obj)
.PHONY : compile
</code></pre> 
<h2><a id="Makefile__407"></a>Makefile 常用符号</h2> 
<h3><a id="1__408"></a>1 =</h3> 
<ul><li>简单的赋值运算符</li><li>用于将右边的值分配给左边的变量</li><li>如果在后面的语句中重新定义了该变量，则将使用新的值</li></ul> 
<blockquote> 
 <p>示例</p> 
</blockquote> 
<pre><code class="prism language-make">HOST_ARCH   = aarch64
TARGET_ARCH = $(HOST_ARCH)

# 更改了变量 a
HOST_ARCH   = amd64

debug:
	@echo $(TARGET_ARCH)
</code></pre> 
<h3><a id="2__425"></a>2 :=</h3> 
<ul><li>立即赋值运算符</li><li>用于在定义变量时立即求值</li><li>该值在定义后不再更改</li><li>即使在后面的语句中重新定义了该变量</li></ul> 
<blockquote> 
 <p>示例</p> 
</blockquote> 
<pre><code class="prism language-make">HOST_ARCH   := aarch64
TARGET_ARCH := $(HOST_ARCH)

# 更改了变量 a
HOST_ARCH := amd64

debug:
	@echo $(TARGET_ARCH)
</code></pre> 
<p> </p> 
<h3><a id="3__445"></a>3 ?=</h3> 
<ul><li>默认赋值运算符</li><li>如果该变量已经定义，则不进行任何操作</li><li>如果该变量尚未定义，则求值并分配</li></ul> 
<pre><code class="prism language-make">HOST_ARCH  = aarch64
HOST_ARCH ?= amd64

debug:
    @echo $(HOST_ARCH)
</code></pre> 
<p> </p> 
<h3><a id="4___458"></a>4 累加 +=</h3> 
<pre><code class="prism language-makefile">CXXFLAGS := -m64 -fPIC -g -O0 -std=c++11 -w -fopenmp

CXXFLAGS += $(include_paths)
</code></pre> 
<p> </p> 
<h3><a id="5__466"></a>5 \</h3> 
<ul><li>续行符</li></ul> 
<blockquote> 
 <p>示例</p> 
</blockquote> 
<pre><code class="prism language-make">LDLIBS := cudart opencv_core \
          gomp nvinfer protobuf cudnn pthread \
          cublas nvcaffe_parser nvinfer_plugin 
</code></pre> 
<p> </p> 
<h3><a id="6____476"></a>6 * 与 %</h3> 
<ul><li><code>*</code>: 通配符表示匹配任意字符串，可以用在目录名或文件名中</li><li><code>%</code>: 通配符表示匹配任意字符串，并将匹配到的字符串作为变量使用</li></ul> 
<p> </p> 
<h2><a id="Makefile__485"></a>Makefile 的常用函数</h2> 
<p>函数调用，很像变量的使用，也是以 “$” 来标识的，其语法如下：</p> 
<pre><code class="prism language-makefile">$(fn, arguments) or ${fn, arguments}
</code></pre> 
<ul><li>fn: 函数名</li><li>arguments: 函数参数，参数间以逗号 <code>,</code> 分隔，而函数名和参数之间以“空格”分隔</li></ul> 
<p> </p> 
<h3><a id="1_shell_494"></a>1 shell</h3> 
<pre><code class="prism language-makefile">$(shell &lt;command&gt; &lt;arguments&gt;)
</code></pre> 
<ul><li>名称：shell 命令函数 —— shell</li><li>功能：调用 shell 命令 command</li><li>返回：函数返回 shell 命令 command 的执行结果</li></ul> 
<blockquote> 
 <p>示例</p> 
</blockquote> 
<pre><code class="prism language-makefile"># shell 指令，src 文件夹下找到 .cpp 文件
cpp_srcs := $(shell find src -name "*.cpp") 
# shell 指令, 获取计算机架构
HOST_ARCH := $(shell uname -m)
</code></pre> 
<p> </p> 
<h3><a id="2_subst_512"></a>2 subst</h3> 
<pre><code class="prism language-makefile">$(subst &lt;from&gt;,&lt;to&gt;,&lt;text&gt;)
</code></pre> 
<ul><li>名称：字符串替换函数——subst</li><li>功能：把字串 &lt;text&gt; 中的 &lt;from&gt; 字符串替换成 &lt;to&gt;</li><li>返回：函数返回被替换过后的字符串</li></ul> 
<blockquote> 
 <p>示例：</p> 
</blockquote> 
<pre><code class="prism language-makefile">
cpp_srcs := $(shell find src -name "*.cpp")
cpp_objs := $(subst src/,objs/,$(cpp_objs)) 

</code></pre> 
<p> </p> 
<h3><a id="3_patsubst_528"></a>3 patsubst</h3> 
<pre><code class="prism language-makefile">$(patsubst &lt;pattern&gt;,&lt;replacement&gt;,&lt;text&gt;)
</code></pre> 
<ul><li>名称：模式字符串替换函数 —— patsubst</li><li>功能：通配符 <code>%</code>，表示任意长度的字串，从 text 中取出 patttern， 替换成 replacement</li><li>返回：函数返回被替换过后的字符串</li></ul> 
<blockquote> 
 <p>示例</p> 
</blockquote> 
<pre><code class="prism language-makefile">cpp_srcs := $(shell find src -name "*.cpp") #shell指令，src文件夹下找到.cpp文件
cpp_objs := $(patsubst %.cpp,%.o,$(cpp_srcs)) #cpp_srcs变量下cpp文件替换成 .o文件
</code></pre> 
<p> </p> 
<h3><a id="4_foreach_544"></a>4 foreach</h3> 
<pre><code class="prism language-makefile">$(foreach &lt;var&gt;,&lt;list&gt;,&lt;text&gt;)
</code></pre> 
<ul><li>名称：循环函数——foreach。</li><li>功能：把字串&lt;list&gt;中的元素逐一取出来，执行&lt;text&gt;包含的表达式</li><li>返回：&lt;text&gt;所返回的每个字符串所组成的整个字符串（以空格分隔）</li></ul> 
<blockquote> 
 <p>示例：</p> 
</blockquote> 
<pre><code class="prism language-makefile">library_paths := /datav/shared/100_du/03.08/lean/protobuf-3.11.4/lib \
                 /usr/local/cuda-10.1/lib64 \

library_paths := $(foreach item,$(library_paths),-L$(item))
</code></pre> 
<blockquote> 
 <p>同等效果</p> 
</blockquote> 
<pre><code class="prism language-makefile">I_flag := $(include_paths:%=-I%)
</code></pre> 
<p> </p> 
<h3><a id="5_dir_565"></a>5 dir</h3> 
<pre><code class="prism language-makefile">$(dir &lt;names...&gt;)
</code></pre> 
<ul><li>名称：取目录函数——dir。</li><li>功能：从文件名序列中取出目录部分。目录部分是指最后一个反斜杠（“/”）之前<br> 的部分。如果没有反斜杠，那么返回“./”。</li><li>返回：返回文件名序列的目录部分。</li><li>示例：</li></ul> 
<pre><code class="prism language-makefile">$(dir src/foo.c hacks)    # 返回值是“src/ ./”。
</code></pre> 
<p> </p> 
<h3><a id="6_notdir_579"></a>6 notdir</h3> 
<pre><code class="prism language-makefile">$(notdir &lt;names...&gt;)
</code></pre> 
<blockquote> 
 <p>示例</p> 
</blockquote> 
<pre><code class="prism language-makefile">libs   := $(notdir $(shell find /usr/lib -name lib*))
</code></pre> 
<p> </p> 
<h3><a id="7_filter_590"></a>7 filter</h3> 
<pre><code class="prism language-makefile">$(filter &lt;names...&gt;)
</code></pre> 
<pre><code class="prism language-makefile">libs    := $(notdir $(shell find /usr/lib -name lib*))
a_libs  := $(filter %.a,$(libs))
so_libs := $(filter %.so,$(libs))
</code></pre> 
<p> </p> 
<h3><a id="8_basename_602"></a>8 basename</h3> 
<pre><code class="prism language-makefile">$(basename &lt;names...&gt;)
</code></pre> 
<pre><code class="prism language-makefile">libs    := $(notdir $(shell find /usr/lib -name lib*))
a_libs  := $(subst lib,,$(basename $(filter %.a,$(libs))))
so_libs := $(subst lib,,$(basename $(filter %.so,$(libs))))
</code></pre> 
<p> </p> 
<h2><a id="Conditional_Rules_617"></a>Conditional Rules</h2> 
<blockquote> 
 <p>注意：</p> 
</blockquote> 
<ul><li>Condition 语句里面全部不能用 Tab 缩进, 你看到的 Makefile 如果好像有 “Tab”, 那全部是空格</li><li>使用 Tab 会报错：*** commands commence before first target</li></ul> 
<h3><a id="1_ifeq__else__endif_623"></a>1 ifeq / else / endif</h3> 
<pre><code class="prism language-makefile"># build flags
ifeq ($(TARGET_OS),darwin)
    LDFLAGS += -rpath $(CUDA_PATH)/lib
    CCFLAGS += -arch $(HOST_ARCH)
else ifeq ($(HOST_ARCH)-$(TARGET_ARCH)-$(TARGET_OS),x86_64-armv7l-linux)
    LDFLAGS += --dynamic-linker=/lib/ld-linux-armhf.so.3
    CCFLAGS += -mfloat-abi=hard
else ifeq ($(TARGET_OS),android)
    LDFLAGS += -pie
    CCFLAGS += -fpie -fpic -fexceptions
endif
</code></pre> 
<p> </p> 
<h3><a id="2_ifneq__else__endif_639"></a>2 ifneq / else / endif</h3> 
<pre><code class="prism language-makefile">HOST_ARCH   := $(shell uname -m)
TARGET_ARCH ?= $(HOST_ARCH)
temp := $(filter $(TARGET_ARCH),x86_64 aarch64 sbsa ppc64le armv7l)

ifneq (,$(filter $(TARGET_ARCH),x86_64 aarch64 sbsa ppc64le armv7l))
    ifneq ($(TARGET_ARCH),$(HOST_ARCH))
        ifneq (,$(filter $(TARGET_ARCH),x86_64 aarch64 sbsa ppc64le))
            TARGET_SIZE := 64
        else ifneq (,$(filter $(TARGET_ARCH),armv7l))
            TARGET_SIZE := 32
        endif
    else
        TARGET_SIZE := $(shell getconf LONG_BIT)
    endif
else
    $(error ERROR - unsupported value $(TARGET_ARCH) for TARGET_ARCH!)
endif
</code></pre> 
<p> </p> 
<h3><a id="3_ifdef__else__endif_661"></a>3 ifdef / else / endif</h3> 
<pre><code class="prism language-make">ifdef TARGET_OVERRIDE # cuda toolkit targets override
    NVCCFLAGS += -target-dir $(TARGET_OVERRIDE)
endif
</code></pre> 
<p> </p> 
<h2><a id="Compile_672"></a>Compile</h2> 
<h2><a id="1__674"></a>1 编译过程</h2> 
<h3><a id="11__675"></a>1.1 预处理</h3> 
<blockquote> 
 <p>示例</p> 
</blockquote> 
<pre><code class="prism language-makefile">cpp_srcs := $(shell find src -name *.cpp)
pp_files := $(patsubst src/%.cpp,src/%.i,$(cpp_srcs))

src/%.i : src/%.cpp
	@g++ -E $^ -o $@

preprocess : $(pp_files)

clean :
	@rm -f src/*.i

debug :
	@echo $(pp_files)

.PHONY : debug preprocess clean
</code></pre> 
<p> </p> 
<h3><a id="12__697"></a>1.2 编译成汇编语言</h3> 
<blockquote> 
 <p>示例</p> 
</blockquote> 
<pre><code class="prism language-makefile">cpp_srcs := $(shell find src -name *.cpp)
as_files := $(patsubst src/%.cpp,src/%.s,$(cpp_srcs))

src/%.s : src/%.cpp
	@g++ -S $^ -o $@

assemble : $(as_files)

clean :
	@rm -f src/*.s

debug :
	@echo $(as_files)

.PHONY : debug assemble clean
</code></pre> 
<p> </p> 
<h3><a id="13__718"></a>1.3 编译成目标文件</h3> 
<blockquote> 
 <p>示例</p> 
</blockquote> 
<pre><code class="prism language-makefile">cpp_srcs := $(shell find src -name *.cpp)
cpp_objs := $(patsubst src/%.cpp,objs/%.o,$(cpp_srcs))

objs/%.o : src/%.cpp
	@mkdir -p $(dir $@)
	@g++ -c $^ -o $@

objects : $(cpp_objs)

clean :
	@rm -rf objs src/*.o

debug :
	@echo $(as_files)

.PHONY : debug objects clean
</code></pre> 
<p> </p> 
<h3><a id="14__740"></a>1.4 链接可执行文件</h3> 
<pre><code class="prism language-makefile">cpp_srcs := $(shell find src -name *.cpp)
cpp_objs := $(patsubst src/%.cpp,objs/%.o,$(cpp_srcs))


objs/%.o : src/%.cpp
	@mkdir -p $(dir $@)
	@g++ -c $^ -o $@

workspace/exec : $(cpp_objs)
	@mkdir workspace/exec
	@g++ $^ -o $@

run : workspace
	@./$&lt;

clean :
	@rm -rf objs workspace/exec

debug :
	@echo $(as_files)

.PHONY : debug run clean
</code></pre> 
<p> </p> 
<h2><a id="2__768"></a>2 编译选项</h2> 
<blockquote> 
 <p>编译选项</p> 
</blockquote> 
<ul><li><code>-m64</code>: 指定编译为 64 位应用程序</li><li><code>-std=</code>: 指定编译标准，例如：-std=c++11、-std=c++14</li><li><code>-g</code>: 包含调试信息</li><li><code>-w</code>: 不显示警告</li><li><code>-O</code>: 优化等级，通常使用：-O3</li><li><code>-I</code>: 加在头文件路径前</li><li><code>fPIC</code>: (Position-Independent Code), 产生的没有绝对地址，全部使用相对地址，代码可以被加载到内存的任意位置，且可以正确的执行。这正是共享库所要求的，共享库被加载时，在内存的位置不是固定的</li></ul> 
<blockquote> 
 <p>链接选项</p> 
</blockquote> 
<ul><li><code>-l</code>: 加在库名前面</li><li><code>-L</code>: 加在库路径前面</li><li><code>-Wl,&lt;选项&gt;</code>: 将逗号分隔的 &lt;选项&gt; 传递给链接器</li><li><code>-rpath=</code>: “运行” 的时候，去找的目录。运行的时候，要找 .so 文件，会从这个选项里指定的地方去找</li></ul> 
<p> </p> 
<h2><a id="3_Implicit_Rules_788"></a>3 Implicit Rules</h2> 
<ul><li>CC: Program for compiling C programs; default cc</li><li>CXX: Program for compiling C++ programs; default g++</li><li>CFLAGS: Extra flags to give to the C compiler</li><li>CXXFLAGS: Extra flags to give to the C++ compiler</li><li>CPPFLAGS: Extra flags to give to the C preprocessor</li><li>LDFLAGS: Extra flags to give to compilers when they are supposed to invoke the linker</li></ul> 
<p> </p> 
<h2><a id="4__800"></a>4 编译带头文件的程序</h2> 
<blockquote> 
 <p>add.hpp</p> 
</blockquote> 
<pre><code class="prism language-c++">#ifndef ADD_HPP
#define ADD_HPP
int add(int a, int b);

#endif // ADD_HPP
</code></pre> 
<blockquote> 
 <p>add.cpp</p> 
</blockquote> 
<pre><code class="prism language-c++">int add(int a, int b)
{
    return a+b;
}
</code></pre> 
<blockquote> 
 <p>minus.hpp</p> 
</blockquote> 
<pre><code class="prism language-c++">#ifndef MINUS_HPP
#define MINUS_HPP
int minus(int a, int b);

#endif // MINUS_HPP
</code></pre> 
<blockquote> 
 <p>minus.cpp</p> 
</blockquote> 
<pre><code class="prism language-c++">int minus(int a, int b)
{
    return a-b;
}
</code></pre> 
<blockquote> 
 <p>main.cpp</p> 
</blockquote> 
<pre><code class="prism language-c++">#include &lt;stdio.h&gt;
#include "add.hpp"
#include "minus.hpp"

int main()
{
    int a=10; int b=5;
    int res = add(a, b);
    printf("a + b = %d\n", res);
    res = minus(a, b);
    printf("a - b = %d\n", res);

    return 0;
}
</code></pre> 
<blockquote> 
 <p>Makefile</p> 
</blockquote> 
<pre><code class="prism language-makefile">cpp_srcs := $(shell find src -name *.cpp)
cpp_objs := $(patsubst src/%.cpp,objs/%.o,$(cpp_srcs))

# 你的头文件所在文件夹路径（建议绝对路径）
include_paths := 
I_flag        := $(include_paths:%=-I%)


objs/%.o : src/%.cpp
	@mkdir -p $(dir $@)
	@g++ -c $^ -o $@ $(I_flag)

workspace/exec : $(cpp_objs)
	@mkdir -p $(dir $@)
	@g++ $^ -o $@ 

run : workspace/exec
	@./$&lt;

debug :
	@echo $(I_flag)

clean :
	@rm -rf objs

.PHONY : debug run
</code></pre> 
<p> </p> 
<h2><a id="Makefile__883"></a>Makefile 静态库编译</h2> 
<h3><a id="1__885"></a>1 程序</h3> 
<blockquote> 
 <p>add.hpp</p> 
</blockquote> 
<pre><code class="prism language-c++">#ifndef ADD_HPP
#define ADD_HPP
int add(int a, int b);

#endif // ADD_HPP
</code></pre> 
<blockquote> 
 <p>add.cpp</p> 
</blockquote> 
<pre><code class="prism language-c++">int add(int a, int b)
{
    return a+b;
}
</code></pre> 
<blockquote> 
 <p>minus.hpp</p> 
</blockquote> 
<pre><code class="prism language-c++">#ifndef MINUS_HPP
#define MINUS_HPP
int minus(int a, int b);

#endif // MINUS_HPP
</code></pre> 
<blockquote> 
 <p>minus.cpp</p> 
</blockquote> 
<pre><code class="prism language-c++">int minus(int a, int b)
{
    return a-b;
}
</code></pre> 
<blockquote> 
 <p>main.cpp</p> 
</blockquote> 
<pre><code class="prism language-c++">#include &lt;stdio.h&gt;
#include "add.hpp"
#include "minus.hpp"

int main()
{
    int a=10; int b=5;
    int res = add(a, b);
    printf("a + b = %d\n", res);
    res = minus(a, b);
    printf("a - b = %d\n", res);

    return 0;
}
</code></pre> 
<p> </p> 
<h3><a id="2__935"></a>2 编译过程</h3> 
<ul><li>源文件[.c/cpp] -&gt; Object文件[.o]<pre><code>g++ -c [.c/cpp][.c/cpp]... -o [.o][.o]... -I[.h/hpp] -g
</code></pre> </li><li>Object文件[.o] -&gt; 静态库文件[lib库名.a]<pre><code>ar -r [lib库名.a] [.o][.o]...
</code></pre> </li><li>main 文件[.c/cpp] -&gt; Object 文件[.o]<pre><code>g++ -c [main.c/cpp] -o [.o] -I[.h/hpp] 
</code></pre> </li><li>链接 main 的 Object 文件与静态库文件 [lib库名.a]<pre><code>g++ [main.o] -o [可执行文件] -l[库名] -L[库路径]
</code></pre> </li></ul> 
<p> </p> 
<h2><a id="_955"></a>动态库（共享库）</h2> 
<h3><a id="1__957"></a>1 编库</h3> 
<blockquote> 
 <p>编译 .c 文件<br> 源文件[.c/cpp] -&gt; Object文件[.o]</p> 
</blockquote> 
<pre><code class="prism language-makefile">g++ -c [.c/cpp][.c/cpp]... -o [.o][.o]... -I[.h/hpp] -g -fpic
</code></pre> 
<blockquote> 
 <p>Object文件[.o] -&gt; 动态库文件[lib库名.so]</p> 
</blockquote> 
<pre><code>g++ -shared [.o][.o]... -o [lib库名.so] 
</code></pre> 
<blockquote> 
 <p>main文件[.c/cpp] -&gt; Object文件[.o]</p> 
</blockquote> 
<pre><code>g++ -c [main.c/cpp] -o [.o] -I[.h/hpp] -g
</code></pre> 
<p> </p> 
<h3><a id="2__973"></a>2 链接</h3> 
<blockquote> 
 <p>链接 main 的 Object 文件与动态库文件[lib库名.so]</p> 
</blockquote> 
<pre><code>g++ [main.o] -o [可执行文件] -l[库名] -L[库路径] -Wl,-rpath=[库路径]
</code></pre> 
<h2><a id="_Error_982"></a>常见 Error</h2> 
<blockquote> 
 <p>*** missing separator. Stop.</p> 
</blockquote> 
<ul><li>原因: Makefile 语法出错</li><li>解决方法: 根据报错的行数，检查 tab 缩进，空格问题</li></ul> 
<blockquote> 
 <p>*** commands commence before first target. Stop</p> 
</blockquote> 
<ul><li>原因: if等语句里面用了 tab 缩进</li><li>解决方法: 缩进的地方全部改为空格</li></ul> 
<p>文章转载至：https://www.bilibili.com/video/BV1EM41177s1?p=15&amp;spm_id_from=pageDriver&amp;vd_source=3ed107622c5e8572cd5d2d075ae86d16</p> 
<p>侵删</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/ae314952b0a9613d6dd8277cdeb7e605/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">百度ueditor粘贴图片自动上传到服务器(Java版)</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/383cd5876b3705ce6352707e7e8143ff/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">探究Java协程的实现原理：从内部机制到应用实践</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>