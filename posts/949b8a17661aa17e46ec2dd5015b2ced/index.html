<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>C&#43;&#43;反射机制的实现 - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="C&#43;&#43;反射机制的实现" />
<meta property="og:description" content="目录
1.什么是反射
2.C&#43;&#43;为什么需要反射
3.具体设计与实现
3.1设计思路
3.2 具体实现
3.3 测试
3.4 可能存在的疑问
4.还有其他的注册方法吗
5.小结
1.什么是反射 首先看一个问题：如何通过类的名称字符串来生成类的对象，比如有一个类Class A，那么如何通过类名称字符串“Class A”来创建类的对象呢？
C&#43;&#43;本身是不支持通过类名称字符串&#34;Classxx&#34;来生成对象的，也就是说我们可以使用ClassXX* object =new ClassXX; 来生成对象，但是不能通过ClassXX* object=new &#34;ClassXX&#34;; 来生成对象。
要想解决这个问题就要用到反射，我们先看下维基百科的定义：反射是指计算机程序在运行时可以访问、检测和修改它本身状态或行为的一种能力。 有点抽象，实际上反射就是程序在运行时动态获取对象信息以及调用对象方法的能力。
2.C&#43;&#43;为什么需要反射 举个例子，设计模式中经常讲IoC，将对象的初始化放在同一的容器之中，减少业务代码之间的依赖，降低耦合度，其中以工厂方法为例：
class Person{}; class Student:public Person{}; class Teacher:public Person{}; Person* factory(const string&amp; type) { if (type == &#34;teacher&#34;) { return new Teacher(); } else if (type == &#34;student&#34;) { return new Student(); } else { return NULL: } } 上面factory根据传入的type的值，初始化person对象并返回，但是当新增person，需要再次修改factory函数。但是如果支持反射，则不需要修改代码。
3.具体设计与实现 3." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/949b8a17661aa17e46ec2dd5015b2ced/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2021-11-21T10:41:33+08:00" />
<meta property="article:modified_time" content="2021-11-21T10:41:33+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">C&#43;&#43;反射机制的实现</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p id="main-toc"><strong>目录</strong></p> 
<p id="1.%E4%BB%80%E4%B9%88%E6%98%AF%E5%8F%8D%E5%B0%84-toc" style="margin-left:0px;"><a href="#1.%E4%BB%80%E4%B9%88%E6%98%AF%E5%8F%8D%E5%B0%84" rel="nofollow" title="1.什么是反射">1.什么是反射</a></p> 
<p id="2.C%2B%2B%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81%E5%8F%8D%E5%B0%84-toc" style="margin-left:0px;"><a href="#2.C%2B%2B%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81%E5%8F%8D%E5%B0%84" rel="nofollow" title="2.C++为什么需要反射">2.C++为什么需要反射</a></p> 
<p id="3.%E5%85%B7%E4%BD%93%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0-toc" style="margin-left:0px;"><a href="#3.%E5%85%B7%E4%BD%93%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0" rel="nofollow" title="3.具体设计与实现">3.具体设计与实现</a></p> 
<p id="3.1%E8%AE%BE%E8%AE%A1%E6%80%9D%E8%B7%AF-toc" style="margin-left:40px;"><a href="#3.1%E8%AE%BE%E8%AE%A1%E6%80%9D%E8%B7%AF" rel="nofollow" title="3.1设计思路">3.1设计思路</a></p> 
<p id="3.2%20%E5%85%B7%E4%BD%93%E5%AE%9E%E7%8E%B0-toc" style="margin-left:40px;"><a href="#3.2%20%E5%85%B7%E4%BD%93%E5%AE%9E%E7%8E%B0" rel="nofollow" title="3.2 具体实现">3.2 具体实现</a></p> 
<p id="3.3%20%E6%B5%8B%E8%AF%95-toc" style="margin-left:40px;"><a href="#3.3%20%E6%B5%8B%E8%AF%95" rel="nofollow" title="3.3 测试">3.3 测试</a></p> 
<p id="3.4%20%E5%8F%AF%E8%83%BD%E5%AD%98%E5%9C%A8%E7%9A%84%E7%96%91%E9%97%AE-toc" style="margin-left:40px;"><a href="#3.4%20%E5%8F%AF%E8%83%BD%E5%AD%98%E5%9C%A8%E7%9A%84%E7%96%91%E9%97%AE" rel="nofollow" title="3.4 可能存在的疑问">3.4 可能存在的疑问</a></p> 
<p id="4.%E8%BF%98%E6%9C%89%E5%85%B6%E4%BB%96%E7%9A%84%E6%B3%A8%E5%86%8C%E6%96%B9%E6%B3%95%E5%90%97-toc" style="margin-left:0px;"><a href="#4.%E8%BF%98%E6%9C%89%E5%85%B6%E4%BB%96%E7%9A%84%E6%B3%A8%E5%86%8C%E6%96%B9%E6%B3%95%E5%90%97" rel="nofollow" title="4.还有其他的注册方法吗">4.还有其他的注册方法吗</a></p> 
<p id="5.%E5%B0%8F%E7%BB%93-toc" style="margin-left:0px;"><a href="#5.%E5%B0%8F%E7%BB%93" rel="nofollow" title="5.小结">5.小结</a></p> 
<hr id="hr-toc"> 
<h2 id="1.%E4%BB%80%E4%B9%88%E6%98%AF%E5%8F%8D%E5%B0%84">1.什么是反射</h2> 
<p>首先看一个问题：<strong>如何通过类的名称字符串来生成类的对象，比如有一个类Class A，那么如何通过类名称字符串“Class A”来创建类的对象呢？</strong></p> 
<p>C++本身是不支持通过类名称字符串"Classxx"来生成对象的，也就是说我们可以使用<span style="color:#fe2c24;"><strong><code>ClassXX* object =new ClassXX;</code></strong> </span>来生成对象，但是不能通过<span style="color:#fe2c24;"><strong><code>ClassXX* object=new "ClassXX";</code></strong></span> 来生成对象。</p> 
<p>要想解决这个问题就要用到反射，我们先看下维基百科的定义：<strong>反射是指计算机程序在运行时可以访问、检测和修改它本身状态或行为的一种能力。</strong> 有点抽象，实际上反射就是程序在运行时动态获取对象信息以及调用对象方法的能力。</p> 
<h2 id="2.C%2B%2B%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81%E5%8F%8D%E5%B0%84">2.C++为什么需要反射</h2> 
<p> 举个例子，设计模式中经常讲IoC，将对象的初始化放在同一的容器之中，减少业务代码之间的依赖，降低耦合度，其中以工厂方法为例：</p> 
<pre><code class="language-cpp">class Person{};
class Student:public Person{};
class Teacher:public Person{};

Person* factory(const string&amp; type) {
    if (type == "teacher") {
        return new Teacher();
    } else if (type == "student") {
        return new Student();
    } else {
        return NULL:
    }
}</code></pre> 
<p>上面factory根据传入的type的值，初始化person对象并返回，但是当新增person，需要再次修改factory函数。但是如果支持反射，则不需要修改代码。</p> 
<h2 id="3.%E5%85%B7%E4%BD%93%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0">3.具体设计与实现</h2> 
<h3 id="3.1%E8%AE%BE%E8%AE%A1%E6%80%9D%E8%B7%AF"><strong>3.1设计思路</strong></h3> 
<p>我的设计思路大致是这样的。<br> （1）为需要反射的类中定义一个创建该类对象的一个回调函数；<br> （2）设计一个工厂类，类中有一个 std::map，用于保存类名和创建实例的回调函数。通过类工厂来动态创建类对象；<br> （3）程序开始运行时，将回调函数存入 std::map 里面，类名字做为 map 的 key 值。<br> 实现流程如下图所示：</p> 
<p><img alt="" src="https://images2.imgbox.com/5d/5b/s1okWShz_o.png"></p> 
<h3 id="3.2%20%E5%85%B7%E4%BD%93%E5%AE%9E%E7%8E%B0">3.2 具体实现</h3> 
<p>下面我来一步一步的讲解具体的实现方法。</p> 
<p><strong>第一步：</strong> 定义一个函数指针类型，用于指向创建类实例的回调函数。</p> 
<pre><code class="language-cpp">typedef void* (*PTRCreateObject)(void);  
</code></pre> 
<p><strong>第二步：</strong> 定义和实现一个工厂类，用于保存保存类名和创建类实例的回调函数。工厂类的作用仅仅是用来保存类名与创建类实例的回调函数，所以程序的整个证明周期内无需多个工厂类的实例，所以这里采用单例模式来涉及工厂类。</p> 
<pre><code class="language-cpp">// 工厂类的定义
class ClassFactory {
private:  
    map&lt;string, PTRCreateObject&gt; m_classMap ;  
	ClassFactory(){}; //构造函数私有化
	
public:   
    void* getClassByName(string className);  
    void registClass(string name, PTRCreateObject method) ;  
    static ClassFactory&amp; getInstance() ;  
};

// 工厂类的实现

// brief: 获取工厂类的单个实例对象  
ClassFactory&amp; ClassFactory::getInstance(){
    static ClassFactory sLo_factory;  
    return sLo_factory ;  
}

// brief: 通过类名称字符串获取类的实例
void* ClassFactory::getClassByName(string className){
    map&lt;string, PTRCreateObject&gt;::const_iterator iter;  
    iter = m_classMap.find(className) ;  
    if ( iter == m_classMap.end() )  
        return NULL ;  
    else  
        return iter-&gt;second() ;  
}  

// brief: 将给定的类名称字符串和对应的创建类对象的函数保存到map中
void ClassFactory::registClass(string name, PTRCreateObject method){
    m_classMap.insert(pair&lt;string, PTRCreateObject&gt;(name, method)) ;  
}
</code></pre> 
<p>第三步： 这一步比较重要，也是最值得深究的一步，也是容易犯迷糊的地方，仔细看。将定义的类注册到工厂类中。也就是说将类名称字符串和创建类实例的回调函数保存到工厂类的 map 中。这里我们又需要完成两个工作，第一个是定义一个创建类实例的回调函数，第二个就是将类名称字符串和我们定义的回调函数保存到工厂类的 map 中。假设我们定义了一个 TestClassA。</p> 
<pre><code class="language-cpp">// test class A
class TestClassA {
public:
	void m_print() {
		cout&lt;&lt;"hello TestClassA"&lt;&lt;endl;
	};
};

// brief 创建类实例的回调函数
TestClassA* createObjTestClassA {
		return new TestClassA;
}
</code></pre> 
<p>好了，我们完了第一个工作，定义了一个创建类实例的回调函数。下面我们要思考一下如何将这个回调函数和对应的类名称字符串保存到工厂类的 map 中。我这里的一个做法是创建一个全局变量，在创建这个全局变量时，调用的构造函数内将回调函数和对应的类名称字符串保存到工厂类的 map 中。在这里，这个全局变量的类型我们定义为 RegisterAction。</p> 
<pre><code class="language-cpp">// 注册动作类
class RegisterAction {
public:
	RegisterAction(string className,PTRCreateObject ptrCreateFn) {
		ClassFactory::getInstance().registClass(className, ptrCreateFn);
	}
};
</code></pre> 
<p>有个这个注册动作类，我们在每个类定义完成之后，我们就创建一个全局的注册动作类的对象，通过注册动作类的构造函数将我们定义的类的名称和回调函数注册到工厂类的 map 中。可以在程序的任何一个源文件中创建注册动作类的对象，但是在这里，我们放在回调函数后面创建。后面你就知道为什么这么做了。创建一个注册动作类的对象如下：</p> 
<pre><code class="language-cpp">RegisterAction g_creatorRegisterTestClassA("TestClassA",(PTRCreateObject)createObjTestClassA);   
</code></pre> 
<p>到这里，我们就完成将类名称和创建类实例的回调函数注册到工厂类的 map。下面再以另外一个类 TestClassB 为例，重温一下上面的步骤：</p> 
<pre><code class="language-cpp">// test class B
class TestClassB {
public:
	void m_print() {
		cout&lt;&lt;"hello TestClassB"&lt;&lt;endl;
	};
};

// brief: 创建类实例的回调函数
TestClassB* createObjTestClassB() {
		return new TestClassB;
}

// 注册动作类的全局实例
RegisterAction g_creatorRegisterTestClassB("TestClassB",(PTRCreateObject)createObjTestClassB);
</code></pre> 
<p>聪明的你有没有发现，如果我们再定义一个类 C、D…，我们重复的在写大量相似度极高的代码。那么如何偷懒让代码变得简洁，提高编码效率呢。有时我们就应该偷懒，不是说这个世界是懒人们创造的么，当然这些懒人们都很聪明。那么我们如何偷懒呢，如果你想到了宏，恭喜，答对了。其实仔细一看，包括回调函数的定义和注册动作的类的变量的定义，每个类的代码除了类名外其它都是一模一样的，那么我们就可以用下面的宏来替代这些重复代码。</p> 
<pre><code class="language-cpp">#define REGISTER(className) 											\
	className* objectCreator##className(){     							\
        return new className;                                         	\
    }                                                                  	\
    RegisterAction g_creatorRegister##className(                        \
		#className,(PTRCreateObject)objectCreator##className)
</code></pre> 
<p>有了上面的宏，我们就可以在每个类后面简单的写一个<code>REGISTER(ClassName)</code> 就完成了注册的功能，是不是很方便快捷呢！！！</p> 
<h3 id="3.3%20%E6%B5%8B%E8%AF%95">3.3 测试</h3> 
<p>至此，我们就完成了 C++ 反射的部分功能，为什么是部分功能，后面再另外说明。急不可耐，我们先来测试一下，是否解决了上面我们提到的问题：<strong>如何通过类的名称字符串来生成类的对象</strong>。测试代码如下：</p> 
<pre><code class="language-cpp">#include &lt;map&gt;
#include &lt;iostream&gt;
#include &lt;string&gt;
using namespace std;

// test class
class TestClass {
public:
	void m_print() {
		cout&lt;&lt;"hello TestClass"&lt;&lt;endl;
	};
};
REGISTER(TestClass);

int main(int argc,char* argv[]) {
	TestClass* ptrObj=(TestClass*)ClassFactory::getInstance().getClassByName("TestClass");
	ptrObj-&gt;m_print();
}
</code></pre> 
<p>程序编译运行输出：<br><img alt="这里写图片描述" src="https://images2.imgbox.com/d0/c9/339G8e1n_o.png"></p> 
<h3 id="3.4%20%E5%8F%AF%E8%83%BD%E5%AD%98%E5%9C%A8%E7%9A%84%E7%96%91%E9%97%AE">3.4 可能存在的疑问</h3> 
<p>看了上面的测试代码，大家可能会唏嘘不已，我们在通过类名称字符串创建类实例的时候，我们还是需要用到类名进行强制类型转换，有了类名称，我们何必还要处心积虑实现反射的功能呢，直接用类名创建实例不就行了么？</p> 
<p>其实，上面实现的反射只是解决了本文最初提出的问题。那么在实际的项目中，还有一种应用场景就是我们定义好了基类，给客户继承，但是我们并不知道客户继承基类后的类型名称。我们可以通过配置文件说明客户实现的具体类型名称，这样我们就可以通过类名称字符串来创建客户自定义类的实例了。</p> 
<h2 id="4.%E8%BF%98%E6%9C%89%E5%85%B6%E4%BB%96%E7%9A%84%E6%B3%A8%E5%86%8C%E6%96%B9%E6%B3%95%E5%90%97">4.还有其他的注册方法吗</h2> 
<p> </p> 
<p>上面具体讲解了通过实现C++的反射来达到通过类名称字符串创建类的实例。其中，在对需要反射的类进行注册的时候，我们用到了一个注册动作类的全局变量，来辅助我们达到注册的功能。除了这个方法，还有没有别的方法呢？大家可以想一想。如有想法，也请留言告之。</p> 
<p>仔细一想，我们通过全局对象的构造函数将类创建实例的函数注册到工厂类中，因为全局对象的构造函数是在程序进入 main() 函数之前执行的，这个问题可以抽象为 C/C++ 中如何在 main() 函数之前执行一条语句。</p> 
<p>主要有以下几种方法：<br> （1）全局变量的构造函数。<br> 也就是上面介绍的通过全局对象的构造函数来实现在main函数之前执行想要的操作。但是很明显的副作用就是定义了一个不从使用的全局变量，从出生，完成使命，就被我们无情的抛弃。</p> 
<p>（2）全局变量的赋值函数。<br> 跟上面的方法有异曲同工之妙，但也同样有着上面的副作用。参考如下代码：</p> 
<pre><code class="language-cpp">#include &lt;iostream&gt;
using namespace std;

int foo(void);
int i=foo();

int foo(void) {
	cout&lt;&lt;"before main"&lt;&lt;endl;
	return 0;
}
int main(void) {
	cout&lt;&lt;"i'm main"&lt;&lt;endl;
}
</code></pre> 
<p>（3）使用 GCC 的话，可以通过 attribute 关键字声明 constructor 和 destructor 分别规定函数在 main 函数之前执行和之后执行。</p> 
<pre><code class="language-cpp">#include &lt;stdio.h&gt;

__attribute((constructor)) void before_main() {
    printf("%s/n",__FUNCTION__);
}  

__attribute((destructor)) void after_main() {
    printf("%s/n",__FUNCTION__);  
}

int main( int argc, char ** argv) {
    printf("%s/n",__FUNCTION__);
    return 0;  
}
</code></pre> 
<p>（4）指定入口点，入口点中调用原来的入口点。<br> 在使用 gcc 编译 C 程序时，我们可以使用 linker 指定入口，使用编译选项 -e 指明程序入口函数。</p> 
<pre><code class="language-cpp">// test.c
#include&lt;stdio.h&gt;

int main(int argc, char **argv) {
	printf("main\n");
	return 0;
}

int xiao(int argc, char **argv) {
	printf("xiao\n");
	return main(argc, argv);
}

编译语句可以为：gcc -e xiao test.c
</code></pre> 
<p>上面是知乎用户提出的方法，但是当我在测试的时候，运行到 main 函数中，总是会出现段错误。C++ 程序时，使用 g++ 如法炮制，编译时记得给新的入口函数添加 extern “C” 说明，以防 g++ 编译时改变了函数签名。虽然编译可以通过，但也是执行到 main 函数时抛出Segmentation fault (core dumped)。</p> 
<p>有兴趣的读者可以尝试一下，如果解决了，请留言告知。<br> （5）可以用 main 调用 main 实现在 main 前执行一段代码，如下：</p> 
<pre><code class="language-cpp">#include&lt;stdio.h&gt;
#include&lt;stdbool.h&gt;

int main(int argc, char **argv) {
	static _Bool firstTime = true;
	if(firstTime) {
		firstTime = false;
		printf("BEFORE MAIN\n");
		return main(argc, argv);
	}

	printf("main\n");
	return 0;
}
</code></pre> 
<h2 id="5.%E5%B0%8F%E7%BB%93">5.小结</h2> 
<p>这里先解释一下上文中 2.3 节中提出的一个问题，我们为什么只是完成了 C++ 反射的部分功能，因为我们在上面并没有完整的实现 C++ 的反射机制，只能实现了反射机制中的一个小功能模块而已，即通过类名称字符串创建类的实例。除此之外，据我所知，编程语言的反射机制所能实现的功能还有通过类名称字符串获取类中属性和方法，修改属性和方法的访问权限等。</p> 
<p>我们为什么需要反射机制。由于在 Java 和 .NET 的成功应用，反射技术以其明确分离描述系统自身结构、行为的信息与系统所处理的信息，建立可动态操纵的因果关联以动态调整系统行为的良好特征，已经从理论和技术研究走向实用化，使得动态获取和调整系统行为具备了坚实的基础。当需要编写扩展性较强的代码、处理在程序设计时并不确定的对象时，反射机制会展示其威力，这样的场合主要有：<br> （1）序列化（Serialization）和数据绑定（Data Binding）；<br> （2）远程方法调用（Remote Method Invocation RMI）；<br> （3）对象/关系数据映射（O/R Mapping）。</p> 
<p>当前许多流行的框架和工具，例如 Castor（基于 Java 的数据绑定工具）、Hibernate（基于 Java 的对象/关系映射框架）等，其核心都使用了反射机制来动态获得类型信息。因此，能够动态获取并操纵类型信息，已经成为现代软件的标志之一。</p> 
<p>反射机制如此复杂，C++ 尚不支持，岂是我这种三教九流之辈的只言片语和几个代码片段所能够勾勒描绘的。</p> 
<p>下面附上本文用到的完整代码，均写在一个源文件中，大家可以根据实际应用，将不同功能的代码写在不同的文件中。也可以在此基础上，进行功能扩充和改良。<br>  </p> 
<pre><code class="language-cpp">#include &lt;map&gt;
#include &lt;iostream&gt;
#include &lt;string&gt;
using namespace std;

typedef void* (*PTRCreateObject)(void);  

class ClassFactory {
private:  
    map&lt;string, PTRCreateObject&gt; m_classMap ;  
	ClassFactory(){}; //构造函数私有化
	
public:   
    void* getClassByName(string className);  
    void registClass(string name, PTRCreateObject method) ;  
    static ClassFactory&amp; getInstance() ;  
};

void* ClassFactory::getClassByName(string className){  
    map&lt;string, PTRCreateObject&gt;::const_iterator iter;  
    iter = m_classMap.find(className) ;  
    if ( iter == m_classMap.end() )  
        return NULL ;  
    else  
        return iter-&gt;second() ;  
}  
   
void ClassFactory::registClass(string name, PTRCreateObject method){  
    m_classMap.insert(pair&lt;string, PTRCreateObject&gt;(name, method)) ;  
}  
   
ClassFactory&amp; ClassFactory::getInstance(){
    static ClassFactory sLo_factory;  
    return sLo_factory ;  
}  

class RegisterAction{
public:
	RegisterAction(string className,PTRCreateObject ptrCreateFn){
		ClassFactory::getInstance().registClass(className,ptrCreateFn);
	}
};

#define REGISTER(className) 											\
	className* objectCreator##className(){     							\
        return new className;                                         	\
    }                                                                  	\
    RegisterAction g_creatorRegister##className(                        \
		#className,(PTRCreateObject)objectCreator##className)

// test class
class TestClass{
public:
	void m_print(){
		cout&lt;&lt;"hello TestClass"&lt;&lt;endl;
	};
};
REGISTER(TestClass);

int main(int argc,char* argv[]) {
	TestClass* ptrObj=(TestClass*)ClassFactory::getInstance().getClassByName("TestClass");
	ptrObj-&gt;m_print();
}
</code></pre> 
<p></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/6c4c5d1925dec7c95dcf83f7c1f0bac4/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">运用for循环找到n个数中的最大数</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/7e3b6502ee977a49bf8ffb0310a177af/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">简单的输入一个数计算其阶乘小程序</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>