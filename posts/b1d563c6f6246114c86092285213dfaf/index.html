<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>springboot-方法处理4-消息转换器 - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="springboot-方法处理4-消息转换器" />
<meta property="og:description" content="1.消息转换器简介 在《方法处理2-参数解析器》那一章，了解到获取body参数的解析器AbstractMessageConverterMethodArgumentResolver及其子类，并没有自己去解析request中的body参数，而是委托消息转换器HttpMessageConverter去解析body参数，并转换为目标方法的参数类型，本文稍微研究一下消息转换器；
1.1.类结构 1.2.功能说明(重点) 消息转换器负责读取httpRequest请求中的body参数，并转换为目标方法的参数类型。并把目标方法的返回值写入到httpResponse中；
支持的数据格式支持的参数类型名称支持的header类型字节Byte[]ByteArrayHttpMessageConverter 1.application/octet-stream类型读取和写入 2.*/*类型读取和写入 文件ResourceResourceHttpMessageConverter 1.*/*类型读取和写入 文本StringStringHttpMessageConverter 1.text/plain类型读取和写入 2.*/*类型读取和写入 任意类型 ObjectToStringHttpMessageConverter 先读取文本，然后使用ConversionService把文本转换为对象 1.text/plain类型读取和写入 MultiValueMap FormHttpMessageConverter 使用其它的消息转换器，把MultiValueMap返回值中包含的对象转换成字节/文本并写入响应 1.application/x-www-form-urlencoded类型读取和写入 2.multipart/form-data类型写入 3.multipart/mixed类型写入 4.*/*类型写入 MultiValueMap AllEncompassingFormHttpMessageConverter 使用其它的消息转换器，把MultiValueMap返回值中包含的对象转换成json/xml并写入响应 xmlSource SourceHttpMessageConverter 使用jdk的api，把xml转换为Source对象 1.application/xml类型读取和写入 2.text/xml类型读取和写入 3.application/*&#43;xml类型读取和写入 任意类型，类包含如下注解： 1.读取:@XmlType/@XmlRootElement 2.写入:@XmlRootElement Jaxb2RootElementHttpMessageConverter 使用jakarta.xml，把xml转换为对象 任意类型 MappingJackson2XmlHttpMessageConverter 使用jackson.xml，把json转换为对象 json任意类型 FastJsonHttpMessageConverter 使用fastjson，把json转换为对象 1.*/*类型读取和写入 任意类型 JsonbHttpMessageConverter 使用javax.json，把json转换为对象 1.application/json类型读取和写入 2.application/*&#43;json类型读取和写入 任意类型 GsonHttpMessageConverter 使用google.gson，把json转换为对象 任意类型 MappingJackson2HttpMessageConverter 使用jackson.json，把json转换为对象 2.消息转换器源码 消息转换器提供了两个接口HttpMessageConverter和GenericHttpMessageConverter，GenericHttpMessageConverter支持推断泛型类型。我们根据这两个接口把消息转换器分成两类：第一类是HttpMessageConverter及其子类，第二类为GenericHttpMessageConverter及其子类；
2.1.HttpMessageConverter及其子类 2.1.1.HttpMessageConverter HttpMessageConverter是参数转换器的顶层接口，定义了参数转换器的行为，包括6个方法。分成三种类型，每种类型2个方法；
读取httpRequest请求中的body参数，并转换为目标方法的参数把目标方法的返回值转换成指定类型，并写入到httpResponse获取支持的http contentType类型； public interface HttpMessageConverter&lt;T&gt; { //**第1类: 读取参数 //**是否支持读取目标参数类型和http contentType boolean canRead(Class&lt;?" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/b1d563c6f6246114c86092285213dfaf/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-09-30T11:47:25+08:00" />
<meta property="article:modified_time" content="2022-09-30T11:47:25+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">springboot-方法处理4-消息转换器</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <h2><a id="1_0"></a>1.消息转换器简介</h2> 
<p>在《方法处理2-参数解析器》那一章，了解到获取body参数的解析器AbstractMessageConverterMethodArgumentResolver及其子类，并没有自己去解析request中的body参数，而是委托消息转换器HttpMessageConverter去解析body参数，并转换为目标方法的参数类型，本文稍微研究一下消息转换器；</p> 
<h3><a id="11_2"></a>1.1.类结构</h3> 
<p><img src="https://images2.imgbox.com/25/4f/Q0P8h2uZ_o.png" alt="消息转换器类结构"></p> 
<h3><a id="12_4"></a>1.2.<mark>功能说明(重点)</mark></h3> 
<p>消息转换器负责读取httpRequest请求中的body参数，并转换为目标方法的参数类型。并把目标方法的返回值写入到httpResponse中；</p> 
<table><tbody><tr><th>支持的数据格式</th><th>支持的参数类型</th><th>名称</th><th>支持的header类型</th></tr><tr><td>字节</td><td>Byte[]</td><td>ByteArrayHttpMessageConverter</td><td> 1.application/octet-stream类型读取和写入 2.*/*类型读取和写入 </td></tr><tr><td>文件</td><td>Resource</td><td>ResourceHttpMessageConverter</td><td> 1.*/*类型读取和写入 </td></tr><tr><td rowspan="4">文本</td><td>String</td><td>StringHttpMessageConverter</td><td> 1.text/plain类型读取和写入 2.*/*类型读取和写入 </td></tr><tr><td>任意类型</td><td> ObjectToStringHttpMessageConverter 先读取文本，然后使用ConversionService把文本转换为对象 </td><td> 1.text/plain类型读取和写入 </td></tr><tr><td>MultiValueMap</td><td> FormHttpMessageConverter 使用其它的消息转换器，把MultiValueMap返回值中包含的对象转换成字节/文本并写入响应 </td><td rowspan="2"> 1.application/x-www-form-urlencoded类型读取和写入 2.multipart/form-data类型写入 3.multipart/mixed类型写入 4.*/*类型写入 </td></tr><tr><td>MultiValueMap</td><td> AllEncompassingFormHttpMessageConverter 使用其它的消息转换器，把MultiValueMap返回值中包含的对象转换成json/xml并写入响应 </td></tr><tr><td rowspan="3">xml</td><td>Source</td><td> SourceHttpMessageConverter 使用jdk的api，把xml转换为Source对象 </td><td rowspan="3"> 1.application/xml类型读取和写入 2.text/xml类型读取和写入 3.application/*+xml类型读取和写入 </td></tr><tr><td> 任意类型，类包含如下注解： 1.读取:@XmlType/@XmlRootElement 2.写入:@XmlRootElement </td><td> Jaxb2RootElementHttpMessageConverter 使用jakarta.xml，把xml转换为对象 </td></tr><tr><td> 任意类型 </td><td> MappingJackson2XmlHttpMessageConverter 使用jackson.xml，把json转换为对象 </td></tr><tr><td rowspan="4">json</td><td>任意类型</td><td> FastJsonHttpMessageConverter 使用fastjson，把json转换为对象 </td><td> 1.*/*类型读取和写入 </td></tr><tr><td>任意类型</td><td> JsonbHttpMessageConverter 使用javax.json，把json转换为对象 </td><td rowspan="3"> 1.application/json类型读取和写入 2.application/*+json类型读取和写入 </td></tr><tr><td>任意类型</td><td> GsonHttpMessageConverter 使用google.gson，把json转换为对象 </td></tr><tr><td>任意类型</td><td> MappingJackson2HttpMessageConverter 使用jackson.json，把json转换为对象 </td></tr></tbody></table> 
<h2><a id="2_140"></a>2.消息转换器源码</h2> 
<p>消息转换器提供了两个接口HttpMessageConverter和GenericHttpMessageConverter，GenericHttpMessageConverter支持推断泛型类型。我们根据这两个接口把消息转换器分成两类：第一类是HttpMessageConverter及其子类，第二类为GenericHttpMessageConverter及其子类；</p> 
<h3><a id="21HttpMessageConverter_142"></a>2.1.HttpMessageConverter及其子类</h3> 
<h4><a id="211HttpMessageConverter_143"></a>2.1.1.HttpMessageConverter</h4> 
<p>HttpMessageConverter是参数转换器的顶层接口，定义了参数转换器的行为，包括6个方法。分成三种类型，每种类型2个方法；</p> 
<ul><li>读取httpRequest请求中的body参数，并转换为目标方法的参数</li><li>把目标方法的返回值转换成指定类型，并写入到httpResponse</li><li>获取支持的http contentType类型；</li></ul> 
<pre><code class="prism language-java"><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">HttpMessageConverter</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">&gt;</span></span> <span class="token punctuation">{<!-- --></span>
    <span class="token comment">//**第1类: 读取参数</span>
    <span class="token comment">//**是否支持读取目标参数类型和http contentType</span>
	<span class="token keyword">boolean</span> <span class="token function">canRead</span><span class="token punctuation">(</span><span class="token class-name">Class</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span><span class="token punctuation">&gt;</span></span> clazz<span class="token punctuation">,</span> <span class="token class-name">MediaType</span> mediaType<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token comment">//**读取http body数据，并转换为目标参数类型的对象</span>
	<span class="token class-name">T</span> <span class="token function">read</span><span class="token punctuation">(</span><span class="token class-name">Class</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span> <span class="token keyword">extends</span> <span class="token class-name">T</span><span class="token punctuation">&gt;</span></span> clazz<span class="token punctuation">,</span> <span class="token class-name">HttpInputMessage</span> inputMessage<span class="token punctuation">)</span><span class="token punctuation">;</span>
	
	<span class="token comment">//**第2类: 写入参数</span>
    <span class="token comment">//**是否支持写入目标方法的返回值类型和http contentType</span>
	<span class="token keyword">boolean</span> <span class="token function">canWrite</span><span class="token punctuation">(</span><span class="token class-name">Class</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span><span class="token punctuation">&gt;</span></span> clazz<span class="token punctuation">,</span> <span class="token class-name">MediaType</span> mediaType<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token comment">//**把目标方法的返回值写入http response</span>
	<span class="token keyword">void</span> <span class="token function">write</span><span class="token punctuation">(</span><span class="token class-name">T</span> t<span class="token punctuation">,</span> <span class="token class-name">MediaType</span> contentType<span class="token punctuation">,</span> <span class="token class-name">HttpOutputMessage</span> outputMessage<span class="token punctuation">)</span><span class="token punctuation">;</span>
	
	<span class="token comment">//**第3类: 获取支持的contentType</span>
    <span class="token comment">//**获取支持的http contentType类型</span>
	<span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">MediaType</span><span class="token punctuation">&gt;</span></span> <span class="token function">getSupportedMediaTypes</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">//**根据目标参数类型获取支持的http contentType类型</span>
	<span class="token keyword">default</span> <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">MediaType</span><span class="token punctuation">&gt;</span></span> <span class="token function">getSupportedMediaTypes</span><span class="token punctuation">(</span><span class="token class-name">Class</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span><span class="token punctuation">&gt;</span></span> clazz<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
		<span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token function">canRead</span><span class="token punctuation">(</span>clazz<span class="token punctuation">,</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token operator">||</span> <span class="token function">canWrite</span><span class="token punctuation">(</span>clazz<span class="token punctuation">,</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token operator">?</span>
				<span class="token function">getSupportedMediaTypes</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token class-name">Collections</span><span class="token punctuation">.</span><span class="token function">emptyList</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> 
<h4><a id="212FormHttpMessageConverter_172"></a>2.1.2.FormHttpMessageConverter</h4> 
<p>FormHttpMessageConverter是HttpMessageConverter的直接子类，接收参数/返回值必须是MultiValueMap；</p> 
<h4><a id="_174"></a>读取</h4> 
<p>FormHttpMessageConverter支持application/x-www-form-urlencoded类型的读取(<mark>FormHttpMessageConverter及其子类AllEncompassingFormHttpMessageConverter是唯二可以读取x-www-form-urlencoded参数的实现类</mark>);<br><br> 读取过程很简单(参数name=test1&amp;sex=38name=test2)，使用&amp;和=切割，最后保存到MultiValueMap中，参数名和参数值都是字符串。同参数名可以有多个，所以值是数组；</p> 
<h4><a id="_177"></a>写入</h4> 
<p>FormHttpMessageConverter支持application/x-www-form-urlencodeda || multipart/form-data || multipart/mixed || */*类型的写入；</p> 
<ul><li>如果内容不是multipart(contentType包含multipart || contentType为null但是MultiValueMap返回值中的value有非字符串类型则认为内容是multipart)，直接写入到response中；</li><li>如果内容是multipart，则根据value的类型分别调用其它的消息转换器，把value转换后写入响应，转换后的类型为byte[]/String/Resource。可以添加新的消息转换器支持新的转换类型(比如其子类AllEncompassingFormHttpMessageConverter，加入了json和xml消息转换器，可以把value转换为json和xml)；</li></ul> 
<h4><a id="_181"></a>源码</h4> 
<p>构造方法添加默认支持的contentType和用于转换multipart的消息转换器；</p> 
<pre><code>public FormHttpMessageConverter() {
    //**添加支持的contentType
	this.supportedMediaTypes.add(MediaType.APPLICATION_FORM_URLENCODED);
	this.supportedMediaTypes.add(MediaType.MULTIPART_FORM_DATA);
	this.supportedMediaTypes.add(MediaType.MULTIPART_MIXED);
    
    //**添加消息转换器，用于把MultiValueMap返回值中包含的对象转换成字节/文本并写入响应
	this.partConverters.add(new ByteArrayHttpMessageConverter());
	this.partConverters.add(new StringHttpMessageConverter());
	this.partConverters.add(new ResourceHttpMessageConverter());
}
</code></pre> 
<p>判断是否支持写入目标方法的返回值类型和http contentType；</p> 
<pre><code>@Override
	public boolean canRead(Class&lt;?&gt; clazz, @Nullable MediaType mediaType) {
	    //**目标参数必须是MultiValueMap
		if (!MultiValueMap.class.isAssignableFrom(clazz)) {
			return false;
		}
		if (mediaType == null) {
			return true;
		}
		for (MediaType supportedMediaType : getSupportedMediaTypes()) {
		    //**不支持包含multipart的contentType
			if (supportedMediaType.getType().equalsIgnoreCase("multipart")) {
				continue;
			}
			if (supportedMediaType.includes(mediaType)) {
				return true;
			}
		}
		return false;
	}
</code></pre> 
<p>判断是是否multipart内容；</p> 
<pre><code>//**contentType包含multipart || contentType为null但是MultiValueMap返回值中的value有非字符串类型则认为内容是multipart
private boolean isMultipart(MultiValueMap&lt;String, ?&gt; map, @Nullable MediaType contentType) {
	if (contentType != null) {
		return contentType.getType().equalsIgnoreCase("multipart");
	}
	for (List&lt;?&gt; values : map.values()) {
		for (Object value : values) {
			if (value != null &amp;&amp; !(value instanceof String)) {
				return true;
			}
		}
	}
	return false;
}
</code></pre> 
<p>如果是multipart内容，调用其它的消息转换器，把value转换后写入响应；</p> 
<pre><code>private void writePart(String name, HttpEntity&lt;?&gt; partEntity, OutputStream os) throws IOException {
	Object partBody = partEntity.getBody();
	if (partBody == null) {
		throw new IllegalStateException("Empty body for part '" + name + "': " + partEntity);
	}
	Class&lt;?&gt; partType = partBody.getClass();
	HttpHeaders partHeaders = partEntity.getHeaders();
	MediaType partContentType = partHeaders.getContentType();
	for (HttpMessageConverter&lt;?&gt; messageConverter : this.partConverters) {
		if (messageConverter.canWrite(partType, partContentType)) {
			Charset charset = isFilenameCharsetSet() ? StandardCharsets.US_ASCII : this.charset;
			HttpOutputMessage multipartMessage = new MultipartHttpOutputMessage(os, charset);
			multipartMessage.getHeaders().setContentDispositionFormData(name, getFilename(partBody));
			if (!partHeaders.isEmpty()) {
				multipartMessage.getHeaders().putAll(partHeaders);
			}
			((HttpMessageConverter&lt;Object&gt;) messageConverter).write(partBody, partContentType, multipartMessage);
			return;
		}
	}
	throw new HttpMessageNotWritableException("Could not write request: no suitable HttpMessageConverter " +
			"found for request type [" + partType.getName() + "]");
}
</code></pre> 
<h4><a id="213AbstractHttpMessageConverter_262"></a>2.1.3.AbstractHttpMessageConverter</h4> 
<ul><li>抽象类，实现了HttpMessageConverter的接口，主要功能是处理了添加了contentType，开放出来的抽象方法中没有contentType参数；</li><li>添加List supportedMediaTypes保存支持的contentType。子类支持的contentType只需要添加到此list，读取和写入的相关方法不需要关注contentType；</li></ul> 
<pre><code>public abstract class AbstractHttpMessageConverter&lt;T&gt; implements HttpMessageConverter&lt;T&gt; {

	private List&lt;MediaType&gt; supportedMediaTypes = Collections.emptyList();
    
    //**是否支持读取目标参数类型/写入目标方法返回值类型
	protected abstract boolean supports(Class&lt;?&gt; clazz);

    //**读取http body数据，并转换为目标参数类型的对象
	protected abstract T readInternal(Class&lt;? extends T&gt; clazz, HttpInputMessage inputMessage)
			throws IOException, HttpMessageNotReadableException;

    //**把目标方法的返回值写入http body
	protected abstract void writeInternal(T t, HttpOutputMessage outputMessage)
			throws IOException, HttpMessageNotWritableException;

}
</code></pre> 
<h4><a id="214ObjectToStringHttpMessageConverter_283"></a>2.1.4.ObjectToStringHttpMessageConverter</h4> 
<ul><li>ObjectToStringHttpMessageConverter是AbstractHttpMessageConverter的子类，支持text/plain类型读取和写入，参数/返回值类型可以是任意对象(非文件)；</li><li>读取：先使用StringHttpMessageConverter把参数转换为String，然后调用ConversionService(转换服务是一个新的接口)把String转换为参数对象；</li><li>写入：先使用ConversionService把返回值对象转换为String，然后使用StringHttpMessageConverter写入response；</li></ul> 
<pre><code>public class ObjectToStringHttpMessageConverter extends AbstractHttpMessageConverter&lt;Object&gt; {

	private final ConversionService conversionService;
	private final StringHttpMessageConverter stringHttpMessageConverter;

    //**先使用StringHttpMessageConverter把参数转换为String，然后调用ConversionService把String转换为参数对象
	@Override
	protected Object readInternal(Class&lt;?&gt; clazz, HttpInputMessage inputMessage)
			throws IOException, HttpMessageNotReadableException {
		String value = this.stringHttpMessageConverter.readInternal(String.class, inputMessage);
		Object result = this.conversionService.convert(value, clazz);
		...
		return result;
	}

    //**先使用ConversionService把返回值对象转换为String，然后使用StringHttpMessageConverter写入response
	@Override
	protected void writeInternal(Object obj, HttpOutputMessage outputMessage) throws IOException {
		String value = this.conversionService.convert(obj, String.class);
		if (value != null) {
			this.stringHttpMessageConverter.writeInternal(value, outputMessage);
		}
	}
}
</code></pre> 
<h3><a id="22GenericHttpMessageConverter_313"></a>2.2.GenericHttpMessageConverter及其子类</h3> 
<h4><a id="221GenericHttpMessageConverter_314"></a>2.2.1.GenericHttpMessageConverter</h4> 
<ul><li>HttpMessageConverter的子接口，支持目标参数/返回值为泛型，可获取泛型的具体类型；</li><li>GenericHttpMessageConverter读取和写入的接口都比HttpMessageConverter多了一个Type type参数。type是目标参数/返回值属方法所在的类的Type对象，用于当目标参数/返回值是泛型类型时，推断泛型的具体类型。例如：public Object test(@RequestBody T test)，HttpMessageConverter接口无法获取参数test的类型；</li></ul> 
<pre><code>public interface GenericHttpMessageConverter&lt;T&gt; extends HttpMessageConverter&lt;T&gt; {

    //**第1类: 读取参数
    //**是否支持读取目标参数类型和http contentType
	boolean canRead(Type type, @Nullable Class&lt;?&gt; contextClass, @Nullable MediaType mediaType);
    //**读取http body数据，并转换为目标参数类型的对象
	T read(Type type, @Nullable Class&lt;?&gt; contextClass, HttpInputMessage inputMessage);

    //**第2类: 写入参数
    //**是否支持写入目标方法的返回值类型和http contentType
	boolean canWrite(@Nullable Type type, Class&lt;?&gt; clazz, @Nullable MediaType mediaType);
	//**把目标方法的返回值写入http response
	void write(T t, @Nullable Type type, @Nullable MediaType contentType, HttpOutputMessage outputMessage);

}
</code></pre> 
<h4><a id="222AbstractGenericHttpMessageConverter_334"></a>2.2.2.AbstractGenericHttpMessageConverter</h4> 
<ul><li>上面GenericHttpMessageConverter接口继承了HttpMessageConverter接口，那GenericHttpMessageConverter接口就存在了很多接口；</li><li>AbstractGenericHttpMessageConverter实现GenericHttpMessageConverter接口的同时，继承AbstractHttpMessageConverter，实现了处理contentType的能力。开放出来的抽象方法中同样没有contentType参数；</li></ul> 
<pre><code>public abstract class AbstractGenericHttpMessageConverter&lt;T&gt; extends AbstractHttpMessageConverter&lt;T&gt;
		implements GenericHttpMessageConverter&lt;T&gt; {
    //**GenericHttpMessageConverter未实现的接口：读取http body数据，并转换为目标参数类型的对象
    T read(Type type, @Nullable Class&lt;?&gt; contextClass, HttpInputMessage inputMessage);
    
    //**AbstractHttpMessageConverter的抽象方法：读取http body数据，并转换为目标参数类型的对象
	protected abstract T readInternal(Class&lt;? extends T&gt; clazz, HttpInputMessage inputMessage)
			throws IOException, HttpMessageNotReadableException;
    
    //**自己的抽象方法：把目标方法的返回值写入http response
	protected abstract void writeInternal(T t, @Nullable Type type, HttpOutputMessage outputMessage)
			throws IOException, HttpMessageNotWritableException;

}
</code></pre> 
<h4><a id="223AbstractJsonHttpMessageConverter_353"></a>2.2.3.AbstractJsonHttpMessageConverter</h4> 
<ul><li>继承AbstractGenericHttpMessageConverter，接收json数据转换为目标参数/把目标方法返回值转换为json数据，写入到response；</li><li>支持的contentType包含application/json和application/*+json；</li><li>其子类JsonbHttpMessageConverter和GsonHttpMessageConverter都是使用第三方的json包，把json数据转换为对象/把对象转换为json数据(<mark>自定json格式的读取和写入也最好继承些抽象类</mark>)；</li></ul> 
<pre><code>public abstract class AbstractJsonHttpMessageConverter extends AbstractGenericHttpMessageConverter&lt;Object&gt; {

    //**构造方法设置支持的contentType
	public AbstractJsonHttpMessageConverter() {
		super(MediaType.APPLICATION_JSON, new MediaType("application", "*+json"));
		setDefaultCharset(DEFAULT_CHARSET);
	}

    //**写入到response时，支持在json数据加入前缀，防止被劫持
	@Override
	protected final void writeInternal(Object object, @Nullable Type type, HttpOutputMessage outputMessage) {
		Writer writer = getWriter(outputMessage);
		if (this.jsonPrefix != null) {
			writer.append(this.jsonPrefix);
		}
		...
	}

    //**读取http body数据，并转换为目标参数类型的对象
	protected abstract Object readInternal(Type resolvedType, Reader reader) throws Exception;

    //**把目标方法的返回值写入http response
	protected abstract void writeInternal(Object object, @Nullable Type type, Writer writer) throws Exception;
}
</code></pre> 
<h4><a id="224AbstractJackson2HttpMessageConverter_383"></a>2.2.4.AbstractJackson2HttpMessageConverter</h4> 
<ul><li>继承AbstractGenericHttpMessageConverter，spring专门为第三方包jackson定义了此抽象方法；</li><li>定义了jackson包进行数据转换的一些配置和依赖，方便子类使用jackson的相关api进数据读取和转换；</li><li>其子类MappingJackson2HttpMessageConverter和MappingJackson2XmlHttpMessageConverter分别支持json数据和xml数据；</li></ul>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/0434be3bbdcc2ab6c3b6f5d3dc020551/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">IDEA将内容上传至Git</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/d851fd40f6ff1e1065053fcaf2441749/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">训练自己的数据_ArcFace/InsightFace使用自己数据训练人脸识别（2/2）</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>