<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Unity —Spine动画 - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Unity —Spine动画" />
<meta property="og:description" content="Spine是什么？
Spine 是一款针对游戏开发的 2D 骨骼动画编辑工具。 Spine 旨在提供更高效和简洁 的工作流程，以创建游戏所需的动画。
优势
在 Spine 中通过将图片绑定到骨骼上，然后再控制骨骼实现动画。 2D 骨骼动画相对于传统的逐帧动画有以下优势:
最小的体积:传统的动画需要提供每一帧图片。而 Spine 动画只保存骨骼的动画数据，它所占用的空间非常小，并能为你的游戏提供独一无二的动画。
美术需求:Spine 动画需要的美术资源更少，能为您节省出更多的人力物力更好的投入到游戏开发中去。
流畅性:Spine 动画使用差值算法计算中间帧，这能让你的动画总是保持流畅的效果。
装备附件:图片绑定在骨骼上来实现动画。如果你需要可以方便的更换角色的装备满足不同的需求。甚至改变角色的样貌来达到动画重用的效果。
混合:动画之间可以进行混合。比如一个角色可以开枪射击，同时也可以走、跑、跳或者游泳。
程序动画:可以通过代码控制骨骼，比如可以实现跟随鼠标的射击，注视敌人，或者上坡时的身体前倾等效果。
功能
摄影表
在动画制作过程中摄影表是最核心的地方。这里包含了所有重要的细节，通过它可以创建动画以及对时间轴进行微调。
曲线编辑器
在曲线编辑器中可以通过调整贝赛尔曲线来控制两帧之间的差值，以实现栩栩如生的动画效果。
反向动力学工具
姿势工具可以利用反向动力学便捷的调整姿势。
皮肤
皮肤可以为做好的动画切换图片素材。通过改变附加在骨骼上的图片来实现动画的重用。
边界框
边界框可以附加在骨骼上，并且随着骨骼移动。它主要用于碰撞检测和物理集成。
网格
允许你在矩形边界内自定义多边形。这将提高最终纹理贴图集的空间使用率，因为在多边形外的像素将被忽略掉，这种优化对移动设备来说特别重要。网格的另外一个功能就是支持自由变形和蒙皮。
自由变形
自由变形也称为FFD，是Free-Form Deformation的简写，它允许你通过移动网格点来变形图片。FFD 能实现网格的:拉伸、挤压、弯曲、反弹，等一些矩形图片无法实现的功能。
蒙皮
蒙皮允许将网格中指定的点附加给指定骨骼。然后附加点将随着骨骼移动，网格则随之自动发生变形。现在可以用骨骼动作控制角色的图片进行弯曲变形了。
输出格式
Spine 能将项目中的动画导出为 JSON 或二进制格式文件，它们能在 Spine 运行时库中完美的再现。 Spine 同时还可以导出 GIF 动画， PNG 或 JPG 序列图，还有 AVI或 QuickTime 的视频文件。
导入
Spine 通过路径查找并导入由其它工具生成的数据文件，它能够识别符合要求的JSON 或二进制格式数据。也可以从别的 Spine 项目中导入骨架和动画。
纹理打包
Spine 能将图片打包成纹理贴图集，这能提高你在游戏中的渲染效率。Spine 的纹理贴图打包工具拥有很多功能比如剥离空白区域，旋转，自动缩放等等…(主要目的是为了充分利用空间)" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/3257553ac07c80f313bd25f8f2539685/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2020-07-15T16:12:24+08:00" />
<meta property="article:modified_time" content="2020-07-15T16:12:24+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Unity —Spine动画</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p><a href="https://link.jianshu.com/?t=http://zh.esotericsoftware.com/spine-in-depth#Spine" rel="nofollow">Spine是什么？</a></p> 
<p>Spine 是一款针对游戏开发的 2D 骨骼动画编辑工具。 Spine 旨在提供更高效和简洁 的工作流程，以创建游戏所需的动画。</p> 
<p><a href="https://link.jianshu.com/?t=http://zh.esotericsoftware.com/spine-in-depth#" rel="nofollow">优势</a></p> 
<p>在 Spine 中通过将图片绑定到骨骼上，然后再控制骨骼实现动画。 2D 骨骼动画相对于传统的逐帧动画有以下优势:</p> 
<p>最小的体积:传统的动画需要提供每一帧图片。而 Spine 动画只保存骨骼的动画数据，它所占用的空间非常小，并能为你的游戏提供独一无二的动画。</p> 
<p>美术需求:Spine 动画需要的美术资源更少，能为您节省出更多的人力物力更好的投入到游戏开发中去。</p> 
<p>流畅性:Spine 动画使用差值算法计算中间帧，这能让你的动画总是保持流畅的效果。</p> 
<p>装备附件:图片绑定在骨骼上来实现动画。如果你需要可以方便的更换角色的装备满足不同的需求。甚至改变角色的样貌来达到动画重用的效果。</p> 
<p>混合:动画之间可以进行混合。比如一个角色可以开枪射击，同时也可以走、跑、跳或者游泳。</p> 
<p>程序动画:可以通过代码控制骨骼，比如可以实现跟随鼠标的射击，注视敌人，或者上坡时的身体前倾等效果。</p> 
<p><a href="https://link.jianshu.com/?t=http://zh.esotericsoftware.com/spine-in-depth#" rel="nofollow">功能</a></p> 
<p>摄影表</p> 
<p>在动画制作过程中摄影表是最核心的地方。这里包含了所有重要的细节，通过它可以创建动画以及对时间轴进行微调。</p> 
<p>曲线编辑器</p> 
<p>在曲线编辑器中可以通过调整贝赛尔曲线来控制两帧之间的差值，以实现栩栩如生的动画效果。</p> 
<p>反向动力学工具</p> 
<p>姿势工具可以利用反向动力学便捷的调整姿势。</p> 
<p><img alt="" src="https://images2.imgbox.com/a4/7a/p0TyjGjq_o.png"></p> 
<p>皮肤</p> 
<p>皮肤可以为做好的动画切换图片素材。通过改变附加在骨骼上的图片来实现动画的重用。</p> 
<p><img alt="" src="https://images2.imgbox.com/14/a7/AAat4veg_o.png"></p> 
<p>边界框</p> 
<p>边界框可以附加在骨骼上，并且随着骨骼移动。它主要用于碰撞检测和物理集成。</p> 
<p>网格</p> 
<p>允许你在矩形边界内自定义多边形。这将提高最终纹理贴图集的空间使用率，因为在多边形外的像素将被忽略掉，这种优化对移动设备来说特别重要。网格的另外一个功能就是支持自由变形和蒙皮。</p> 
<p><img alt="" src="https://images2.imgbox.com/b2/cb/OYYpk7Y9_o.png"></p> 
<p>自由变形</p> 
<p>自由变形也称为FFD，是Free-Form Deformation的简写，它允许你通过移动网格点来变形图片。FFD 能实现网格的:拉伸、挤压、弯曲、反弹，等一些矩形图片无法实现的功能。</p> 
<p>蒙皮</p> 
<p>蒙皮允许将网格中指定的点附加给指定骨骼。然后附加点将随着骨骼移动，网格则随之自动发生变形。现在可以用骨骼动作控制角色的图片进行弯曲变形了。</p> 
<p>输出格式</p> 
<p>Spine 能将项目中的动画导出为 JSON 或二进制格式文件，它们能在 Spine 运行时库中完美的再现。 Spine 同时还可以导出 GIF 动画， PNG 或 JPG 序列图，还有 AVI或 QuickTime 的视频文件。</p> 
<p><img alt="" src="https://images2.imgbox.com/bb/3b/g1PiIERA_o.png"></p> 
<p>导入</p> 
<p>Spine 通过路径查找并导入由其它工具生成的数据文件，它能够识别符合要求的JSON 或二进制格式数据。也可以从别的 Spine 项目中导入骨架和动画。</p> 
<p>纹理打包</p> 
<p>Spine 能将图片打包成纹理贴图集，这能提高你在游戏中的渲染效率。Spine 的纹理贴图打包工具拥有很多功能比如剥离空白区域，旋转，自动缩放等等…(主要目的是为了充分利用空间)</p> 
<p><img alt="" src="https://images2.imgbox.com/dc/e0/MuJgXNCt_o.png"></p> 
<p><a href="https://link.jianshu.com/?t=http://zh.esotericsoftware.com/spine-in-depth#" rel="nofollow">运行库</a></p> 
<p>制作出惊艳的动画只是工作的一部分 —— 您还需要在游戏中显示它们。Spine运行库可以让您的游戏引擎播放这些动画，效果就如同在Spine里显示的那样。</p> 
<p>Spine运行库提供了一组API，可以直接访问骨骼(bones)，附件(attachments)，皮肤(skins)和其它动画数据。在程序中可以控制骨骼，混合动画、淡入淡出等等。</p> 
<p>官方的运行库放在<a href="https://link.jianshu.com/?t=https://github.com/EsotericSoftware/spine-runtimes">GitHub</a>上，并授权允许Spine用户在其程序中使用Spine运行库。这里提供了所有源码，它将是你游戏中必不可少的一部分。</p> 
<p><a href="https://link.jianshu.com/?t=http://esotericsoftware.com/spine-runtimes" rel="nofollow">支持的游戏引擎</a></p> 
<p><a href="https://link.jianshu.com/?t=http://zh.esotericsoftware.com/spine-in-depth#Development" rel="nofollow">开发 Development</a></p> 
<p>Spine尚在积极开发中。我们经常一周发部多个新版本。您可以密切关注<a href="https://link.jianshu.com/?t=http://zh.esotericsoftware.com/spine-changelog" rel="nofollow">更新日志</a>了解详情。如果想更详进的了解我们的开发计划和进度，请关注<a href="https://link.jianshu.com/?t=https://waffle.io/EsotericSoftware/spine" rel="nofollow">Spine Waffle</a>的 Waffle（一种管理进度的团队协作工具）。在上面你可以对开发任务进行投票和评论，还可以订阅它，这样当开发完成时，您就会收到电子邮件通知。</p> 
<p>我们在持续开发新功能同时，也在不断的完善和优化软件的各个方面。通常这些意见都来自用户的反馈。我们渴望了解哪里工作的正常，哪里出了问题。所以请来<a href="https://link.jianshu.com/?t=http://esotericsoftware.com/forum" rel="nofollow">Spine论坛</a>分享您的心得吧。</p> 
<p> </p> 
<p><a href="https://link.jianshu.com/?t=http://zh.esotericsoftware.com/spine-unity#" rel="nofollow">开始步骤</a></p> 
<p><a href="https://link.jianshu.com/?t=http://zh.esotericsoftware.com/spine-unity#" rel="nofollow">安装</a></p> 
<p>下载和安装<a href="https://link.jianshu.com/?t=http://unity3d.com/get-unity" rel="nofollow">Unity</a>(PERSONAL版本是个人免费版.)。</p> 
<p>创建一个空的Unity项目。</p> 
<p>下载最新版本的Spine运行库:<a href="https://link.jianshu.com/?t=http://zh.esotericsoftware.com/http://esotericsoftware.com/files/runtimes/unity/spine-unity.unitypackage" rel="nofollow">spine-unity.unitypackage</a>。</p> 
<p>导入spine-unity.unitypackage(你可以双击也可以将它拖进Unity中)。</p> 
<p>在项目中打开Examples\Getting Started文件夹，然后打开并运行Unity Scene文件，您可以在scene中看到一些提示信息，还可以查看Inspector和示例脚本的内容。</p> 
<p>在Unity中，Spine-Unity运行库可以加载、操作和渲染<a href="https://link.jianshu.com/?t=http://esotericsoftware.com/" rel="nofollow">Spine</a>骨骼动画。 在Unity中使用Spine-Unity可能跟别的插件结合使用。比如使用<a href="https://link.jianshu.com/?t=http://www.unikronsoftware.com/2dtoolkit/" rel="nofollow">2D Toolkit</a>的图集系统，您可以在Unity中点击Edit-&gt;Preferences-&gt;Spine，然后点击Enable。</p> 
<p>如果您不熟悉C#编程和Unity的使用方式，我们建议您先查阅<a href="https://link.jianshu.com/?t=http://unity3d.com/learn/tutorials" rel="nofollow">Unity官方教程</a>。然后从<a href="https://link.jianshu.com/?t=http://unity3d.com/learn/tutorials/topics/interface-essentials" rel="nofollow">Interface &amp; Essentials</a>和<a href="https://link.jianshu.com/?t=http://unity3d.com/cn/learn/tutorials/topics/scripting" rel="nofollow">Scripting</a>这两个主题开始。但是Unity的Animation主题并不能直接适用于Spine-Unity，请直接学习Spine-Unity。</p> 
<p>Spine-Unity是在(<a href="https://link.jianshu.com/?t=http://esotericsoftware.com/git/spine-runtimes/tree/spine-csharp" rel="nofollow">spine-csharp</a>)基础上构建的。</p> 
<p><a href="https://link.jianshu.com/?t=http://zh.esotericsoftware.com/spine-unity#" rel="nofollow">示例代码</a></p> 
<p>导入最新版unitypackage之后，进入Examples\Getting Started目录。</p> 
<p>打开并运行Unity Scene文件。 您可以在scene中看到一些提示信息，还可以查看Inspector和示例脚本的内容。</p> 
<p>这些信息将介绍基本的姿势和角色动画。</p> 
<p>您可以访问<a href="https://link.jianshu.com/?t=http://esotericsoftware.com/forum/viewforum.php?f=12" rel="nofollow">Spine-Unity论坛</a>查阅更多信息。</p> 
<p><a href="https://link.jianshu.com/?t=http://zh.esotericsoftware.com/spine-unity#Spine" rel="nofollow">将Spine资源导入你的项目</a></p> 
<p><a href="https://link.jianshu.com/?t=http://zh.esotericsoftware.com/spine-unity#Spine" rel="nofollow">从Spine导出</a></p> 
<p>在创建骨架和动画之后，点击Spine菜单&gt;导出(CTRL+E)。这会打开导出窗口。</p> 
<p>在导出窗口的左边选择JSON。</p> 
<p>查看创建图集复选框。(推荐初学者查看非必要数据，优质打印)。</p> 
<p>在创建图集复选框旁边点击设置。然后会打开纹理打包器设置窗口。</p> 
<p>在窗口的右下角可以看到图集扩展名标签，你应该将文本框中的.atlas设置为.atlas.txt。(如果不这么做可能会出现一些问题，因为Unity默认不会识别以.atlas后缀的文件，虽然Spine-Unity可以识别这个文件。不管怎么样，设置为.atlas.txt将避免大部分的问题)。</p> 
<p>现在你可以关闭纹理打包器设置窗口了，点击确定关闭。</p> 
<p>在导出窗口中，选择一个输出文件夹。(建议:创建一个空的文件夹，并且确定你可以找到它)。</p> 
<p>点击导出。</p> 
<p>现在会导出三个文件:</p> 
<p>.json文件，它包含所有骨架信息。</p> 
<p>.png文件，它包含当前版本所有图片的集合。</p> 
<p>.atlas.txt文件，它包含打包的图集信息。</p> 
<p>对于2D Toolkit用户，第3步(打包.png和.atlas.txt)不是必须的。相反，你应该适当得在你的SkeletonDataAsset字段中添加一个tk2dSpriteCollectionData引用。然后在Unity中点击`Edit-&gt;Preferences-&gt;Spine面板中点击Enable启用对TK2D的支持。</p> 
<p><a href="https://link.jianshu.com/?t=http://zh.esotericsoftware.com/spine-unity#Unity" rel="nofollow">导入Unity</a></p> 
<p>确保已经打开你的Unity项目</p> 
<p>项目中应该已经有Spine-Unity运行库。</p> 
<p>在文件夹中找到刚才导出的3个文件。(json,.atlas.txtand.png)</p> 
<p>将3个文件(或者包含它们的文件夹)拖进Unity的Project面板。</p> 
<p>Spine-Unity运行库会根据这些文件自动生成必要的Unity资源。</p> 
<p>然后你会看到3个新文件。</p> 
<p>_Material资源包含一个着色器引用和.png纹理。</p> 
<p>_Atlas资源包含一个材质引用和.atlas.txt。</p> 
<p>_SkeletonData资源包含一个json引用和_Atlas资源。</p> 
<p>右键点击_SkeletonData资源然后选择Spine &gt; Instantiate (SkeletonAnimation)，实例化一个Spine游戏对象。</p> 
<p>可以通过查看Examples\Getting Started中的示例学习更多关于Spine游戏对象的知识。</p> 
<p>资源配置手册后期，你可以自己创建者3个文件。这种方式可以关注第3个步骤。</p> 
<p>替换着色器使用Spine-Unity默认的着色器(Spine/Skeleton或者Spine/SkeletonLit)会使用Premultiplied Alpha的方式处理材质。这是Spine纹理打包器默认的设置。如果选择其他的着色器可能会产生意想不到的效果，你需要重新导出不使用Premultiplied Alpha的材质。您可以在<a href="https://link.jianshu.com/?t=http://esotericsoftware.com/forum/Premultiply-Alpha-3132" rel="nofollow">Premultiply Alpha主题</a>中获得更多信息。</p> 
<p>纹理大小Unity默认会缩放过于庞大的图片。Spine-Unity运行库自动设置图集的最大大小为2048x2048。如果你的纹理比2048x2048还要大，这将导致图集坐标是错误的。所以请确保合理的导入设置，或者在Spine纹理打包器中减小最大页面的宽度和高度。</p> 
<p>纹理压缩伪像Unity2D项目默认将导入图片的纹理格式设置为"Sprite"，当使用Spine/Skeleton着色器时会导致伪像。为了避免伪像，请确保纹理类型设置为"Texture"。Spine-Unity在自动导入时会尝试应用这些设置，但是在这个过程中会更新你的纹理，这些设置可能会恢复。</p> 
<p><a href="https://link.jianshu.com/?t=http://zh.esotericsoftware.com/spine-unity#SpineUnity" rel="nofollow">更新你项目中的Spine-Unity运行库</a></p> 
<p>一些Spine编辑器更新时会要求你更新Spine-Unity运行库，所以它会读取和解析导出Spine数据的正确性。</p> 
<p>比如Unity的更新，我们总是建议您在更新之前备份整个Unity项目。</p> 
<p>总是在更新Spine-Unity运行库之前与你的主程和美工一起检查。Spine-Unity运行库可以基于不同的项目需求而修改源代码。在你的项目中可能Spine-Unity运行库已经被程序修改过了。基于这种情况，当更新Spine-Unity运行库之后，还需要重新修改一遍。</p> 
<p>更新Spine-Unity运行库，你有3个选择。便捷更新的方法是，在Unity中点击Assets-&gt;Improt Package-&gt;Custom Package的方式导入。另一种比较繁琐的方式是，你可以删除旧的版本，然后在导入新的版本。</p> 
<p><a href="https://link.jianshu.com/?t=http://zh.esotericsoftware.com/spine-unity#unitypackage" rel="nofollow">便捷更新 (.unitypackage)</a></p> 
<p>下载最新版本的<a href="https://link.jianshu.com/?t=http://esotericsoftware.com/files/runtimes/unity/spine-unity.unitypackage" rel="nofollow">spine-unity.unitypackage</a>。</p> 
<p>双击或者拖动unitypackage导入你的Unity项目中。</p> 
<p>不管你怎么移动之前导入的运行库，在本次导入时，对话框都将显示哪些文件将会被更新。</p> 
<p>如果你的源文件损坏或者替换这个方式可能不能正确工作。对于这种情况，在导入unitypackage之前你可能需要先删除旧版本。</p> 
<p>许多unitypackage旧版本的spine-c#源文件都是不一样的。你或许应该在更新时删除这些旧的spine-csharp文件夹。否则它会工作不正常。</p> 
<p>偶尔，一些文件会被删除或者合并。但是在导入unitypackage时并不会删除这些文件。你可以查看<a href="https://link.jianshu.com/?t=http://esotericsoftware.com/forum/Noteworthy-Spine-Unity-Topics-5924" rel="nofollow">公告</a>。</p> 
<p><a href="https://link.jianshu.com/?t=http://zh.esotericsoftware.com/spine-unity#unitypackage" rel="nofollow">手动 (.unitypackage)</a></p> 
<p>打开一个空的scene. (为保险起见)</p> 
<p>在你的Unity项目中删除之前的spine-unity和spine-csharp运行库。</p> 
<p>导入unitypackage</p> 
<p><a href="https://link.jianshu.com/?t=http://zh.esotericsoftware.com/spine-unity#zip-from-github" rel="nofollow">手动 (zip from github)</a></p> 
<p>打开一个空的scene. (为保险起见)</p> 
<p>从Github下载zip格式的<a href="https://link.jianshu.com/?t=https://github.com/EsotericSoftware/spine-runtimes">Spine运行库</a>。</p> 
<p>在你找得到的地方解压文件。(你只需要spine-csharp和spine-unity)。</p> 
<p>找到解压文件存放并且在你的项目中替换它们。</p> 
<p>你需要以下这些文件夹:</p> 
<p>spine-csharp/src(在unitypackage中它叫做"spine-csharp")</p> 
<p>spine-unity/Assets/Gizmos.</p> 
<p>spine-unity/Assets/spine-unity</p> 
<p>spine-unity/Assets/Examples(可选)</p> 
<p>Gizmos在Unity中是一个<a href="https://link.jianshu.com/?t=http://docs.unity3d.com/Manual/SpecialFolders.html" rel="nofollow">特殊文件</a>。它只有放在assets根目录才能发挥作用。(例如:Assets/Gizmos)</p> 
<p>spine-csharp和spine-unity可以放在任何文件夹内。</p> 
<p>有时候，你会复制许多文件。如果你这么做Unity会发出警告，请确保你复制以后删除旧的文件。</p> 
<p>一些文件可能已经被移除或者合并。请拷贝整个文件夹并且不要删除他们。然后查看关于这方面的<a href="https://link.jianshu.com/?t=http://esotericsoftware.com/forum/Noteworthy-Spine-Unity-Topics-5924" rel="nofollow">公告</a>。</p> 
<p><a href="https://link.jianshu.com/?t=http://zh.esotericsoftware.com/spine-unity#" rel="nofollow">整体结构</a></p> 
<p>Spine-Unity是怎么组合到一起的？ Spine-Unity的功能由以下几个组件组成:</p> 
<p>Spine-C#</p> 
<p>Spine-Unity</p> 
<p>... Unity.</p> 
<p><a href="https://link.jianshu.com/?t=http://zh.esotericsoftware.com/spine-unity#SpineC" rel="nofollow">Spine-C#</a></p> 
<p>spine-csharp是Spine运行库使用C#接口的公共核心。</p> 
<p>你可以在Spine编辑器中看到这个公共核心包含的类型和数据结构的代码，其中包括Skeleton,Bone,Slot,Skin,Attachment,Animation。你可以在<a href="https://link.jianshu.com/?t=http://esotericsoftware.com/spine-using-runtimes" rel="nofollow">Spine官方文档</a>中查看这些类型的描述。</p> 
<p>它会将JSON(.json)和二进制(在Unity中显示为.skel.bytes)的骨架数据反序列化然后写进SkeletonData对象模型中。</p> 
<p>它包含了基本的AnimationState实现、Spine的基础、以及直接可以使用的动画控制。(更多内容请往下看)</p> 
<p>所有的类都是在Spine命名空间下。</p> 
<p>spine-csharp可以让Spine-Unity,Spine-XNAandSpine-MonoGame— 这些C#运行库共同使用的。因为Spine-C#没有使用UnityEngine的类功能，所以其它适用.NET/mono编写的Spine运行库都可以在Spine-C#基础上扩展。</p> 
<p>为了保持老版Unity的Mono运行库和编译器，Spine-C#没有使用C#语言的最新功能。</p> 
<p><a href="https://link.jianshu.com/?t=http://zh.esotericsoftware.com/spine-unity#Stateful-vs-Stateless" rel="nofollow">有状态(Stateful) vs 无状态(Stateless)</a></p> 
<p>Spine的核心类(定义在spine-csharp中)主要分为<em>stateful-instance</em>和<em>stateless-data</em>这两种:</p> 
<p>类似Skeleton、Bone、Slot、AnimationState这些类都是<em>有状态</em>的对象，对它们进行修改不会影响到其它实例。你可以翻转Skeleton、复位Bone、修改Slot或者改变AnimationState的时间轴，并且它只适用于单例。</p> 
<p>类似SkeletonData,Animation,Attachment,BoneData,SlotData这些类都是<em>无状态</em>的对象，设计初衷就是让他们可以被所有Skeleton实例交叉访问(比如每个Spine GameObject可以创建一个骨架)。通常，你不应该去改动这些无状态的对象。</p> 
<p>经验之谈:</p> 
<p>如果想得到<em>有状态</em>的对象，你可以使用Skeleton。(比如:设置骨架的姿势或者替换一个槽的附件)</p> 
<p>如果想得到<em>无状态</em>的对象，你可以使用SkeletonData。(比如:想要获得一些信息，例如Animation的持续性、Event、或者Setup/Bind姿势)</p> 
<p>这只是最简单的设计方案。如果你是一个高级用户或者你知道运行库是如何运行的，那么你可以根据项目需要去自定义一些"无状态"的对象。</p> 
<p>你可以在<a href="https://link.jianshu.com/?t=http://esotericsoftware.com/spine-using-runtimes" rel="nofollow">这里</a>找到更多关于Spine核心类的信息。</p> 
<p><a href="https://link.jianshu.com/?t=http://zh.esotericsoftware.com/spine-unity#SpineCSpinelibGDX" rel="nofollow">Spine-C#和Spine-libGDX的区别</a></p> 
<p>Spine-C#主要使用C#语言，而Spine-libGDX使用的是Java语言，然而因为C#和Java语言的语法和传统都非常相似，这里主要说一下除了语言之外的区别。</p> 
<p>在Spine-C#中:</p> 
<p>Spine-C#引用的核心库是<a href="https://link.jianshu.com/?t=http://referencesource.microsoft.com/#mscorlib,namespaces" rel="nofollow">mscorlib</a>。它包含Dictionary和Array。</p> 
<p>在C#中方法和枚举变量使用Pascal命名法代替camel命名法。(由于序列化兼容性的原因，一些枚举使用camel命名法)</p> 
<p>属性和自动属性代替Java中的getter和setter方法。这纯粹是语法和API的原因。在引擎中，属性会被MonoJIT编译器编译为方法，有时也会是内联的。</p> 
<p>事件的定义和订阅可以使用C#的事件和代理。</p> 
<p>出于对性能的考虑，Spine-C#在经常使用的代码里用ExposedList(T)替代System.Collections.Generic.List(T)。</p> 
<p><a href="https://link.jianshu.com/?t=http://zh.esotericsoftware.com/spine-unity#SpineUnity" rel="nofollow">Spine-Unity</a></p> 
<p>Spine-Unity层是以Spine-C#为基础的，所以它被允许工作在UnityEngine下，还会在Unity编辑器中使用inspectors和windows。</p> 
<p>它包含Spine MonoBehaviours定义和资源文件，就像别的编辑器工具一样，为用户自动处理资源，其代码工具就像是<a href="https://link.jianshu.com/?t=http://docs.unity3d.com/ScriptReference/PropertyDrawer.html" rel="nofollow">PropertyAttributes</a>。</p> 
<p>Spine-Unity大部分的周期管理方法都依靠Spine-C#遵循的<a href="https://link.jianshu.com/?t=http://docs.unity3d.com/Manual/ExecutionOrder.html" rel="nofollow">UnityEngine的生命周期和游戏循环</a>。 但是它也包含主要的渲染代码(在.LateUpdate中)将Spine骨架转化为可见网格。</p> 
<p>Spine-Unity也在编辑器和运行时管理Spine-C#类的反序列化和实例化。</p> 
<p>在编写脚本的时候，请注意:所有的Spine-C#都应该在Awake中实例化。这意味着不能随意控制脚本执行顺序，不然不能保证当Awake被调用时已经实例化骨架和动画状态。</p> 
<p>你应该在Start之后访问(或缓存).state或.skeleton引用。请查看<a href="https://link.jianshu.com/?t=http://docs.unity3d.com/ScriptReference/MonoBehaviour.Awake.html" rel="nofollow">Unity关于Awake的文档</a>.</p> 
<p><a href="https://link.jianshu.com/?t=http://zh.esotericsoftware.com/spine-unity#SkeletonUtilitySpineUnity-Modules" rel="nofollow">SkeletonUtility和Spine-Unity Modules</a></p> 
<p>Spine-Unity还包括一些可选的功能类和工作流</p> 
<p>SkeletonAnimator允许用户使用Mecanim动画控制器控制动画。 SkeletonUtility允许Spine.Bones和UnityEngine.Transform之间进行转换。 这可以让你控制UnityEngine.Transform驱动Bone，或者让GameObject随着Bone运动。</p> 
<p>在`spine-unity\Modules`文件夹中还包括其它几个模块，它们都是直接可以用的，虽然都是一些简单得实现，但是只要稍加研究或修改就可以得到更高级得功能。</p> 
<p>您可以在项目中任性得删除一些没有使用的模块，不用担心影响Spine的其他功能。注意:一些模块可能依赖其它的模块，所以在删除的时候应该一个一个得删。如果出现依赖问题，Unity会在编译之前提示警告。</p> 
<p><a href="https://link.jianshu.com/?t=http://zh.esotericsoftware.com/spine-unity#" rel="nofollow">控制动画</a></p> 
<p><img alt="" src="https://images2.imgbox.com/81/73/xreQr3Y2_o.png"></p> 
<p><a href="https://link.jianshu.com/?t=http://zh.esotericsoftware.com/spine-unity#SkeletonAnimation" rel="nofollow">SkeletonAnimation</a></p> 
<p>一般来说，Spine.AnimationState管理时间轨道、更新骨架、队列、分层以及混合/交叉混合动画。如果你使用过"Mecanim"，Spine.AnimationState更简单，虽然属于不可编程类，但是它足够灵活，可以作为大部分动画的基本逻辑。</p> 
<p>但是Spine.AnimationState是一个C#类。要在Unity使用它，有一个包含MonoBehaviour的Spine.AnimationState对象叫做SkeletonAnimation。你可以在SkeletonAnimation里面找到一个叫做state的成员变量，它是Spine.AnimationState对象的引用。</p> 
<p>SkeletonAnimation既管理更新时间，也生成Mesh对象，因为它是SkeletonRenderer的派生类。你可以把骨架数据资源实例化成"Spine GameObject"然后挂到GameObject上。你可以称SkeletonAnimation为Spine组件。</p> 
<p><a href="https://link.jianshu.com/?t=http://zh.esotericsoftware.com/spine-unity#SkeletonAnimation" rel="nofollow">怎么使用SkeletonAnimation</a></p> 
<p><a href="https://link.jianshu.com/?t=http://zh.esotericsoftware.com/spine-unity#" rel="nofollow">对初学者来说</a></p> 
<p>最开始，可以使用SkeletonAnimation组件实例化一个GameObject。然后可以在Inspector中的找到SkeletonAnimation组件，然后点击Animation Name下拉框选择一个初始动画，当Scene启动时会直接运行这个动画。</p> 
<p>可以设置Loop(循环播放)，也是可以调整TimeScale(播放速度)。那些在Inspector属性会映射到.AnimationName,.loopand.timeScale。</p> 
<p>刚开始写代码的话，你可以给skeletonAnimation.AnimationName属性赋值动画的名字来切换动画。你也可以给skeletonAnimation.loop属性赋值为True，这样在游戏运行时你的动画会重复播放。</p> 
<p>skeletonAnimation.timeScale=1.5f;</p> 
<p>skeletonAnimation.loop=true;</p> 
<p>skeletonAnimation.AnimationName="run";</p> 
<p><a href="https://link.jianshu.com/?t=http://zh.esotericsoftware.com/spine-unity#" rel="nofollow">左右方向动画</a></p> 
<p>不比在Spine编辑对话框中设置动画的朝向(向左、向右)。SkeletonAnimation的Skeleton对象有FlipX(还有FlipY)的属性，你可以根据需要设置骨骼的水平镜像。</p> 
<p>// 如果你的角色已经是面向右边的，那么这样设置后就会面向左边。</p> 
<p>skeletonAnimation.skeleton.FlipX=true;</p> 
<p>然而，如果你的角色在设计时两边朝向的动画是不一样的，你可以使用Spine的皮肤功能，一个皮肤表示向左，而另一个向右，然后再设置一个变量根据不同的朝向切换皮肤。</p> 
<p>boolfacingLeft= (facing!="right");</p> 
<p>skeletonAnimation.skeleton.FlipX=facingLeft;</p> 
<p>skeletonAnimation.skeleton.SetSkin(facingLeft?"leftSkin":"rightSkin");</p> 
<p><a href="https://link.jianshu.com/?t=http://zh.esotericsoftware.com/spine-unity#" rel="nofollow">一个典型的应用</a></p> 
<p>控制骨架的主要类是Spine.AnimationState。SkeletonAnimation是基于AnimationState构建的，它的SkeletonAnimation.state引用就是Spine.AnimationState。它会在Awake中初始化，所以应该在Start或之后访问它。</p> 
<p>AnimationState是Spine动画状态机的基础实现。它的底层在某种层面来说只能管理:更新、队列、分层和混合/交叉混合动画(它不是Mecanim意义上的"State Machine")。</p> 
<p>在代码中，你可以使用AnimationState的方法来播放动画:</p> 
<p>// 在Trank0中播放“stand”动画。</p> 
<p>skeletonAnimation.state.SetAnimation(0, “stand”,false);</p> 
<p>// 在Track0中添加一个“run”动画，当Track0的最后一个动画播放结束后循环播放“run”动画。</p> 
<p>skeletonAnimation.state.AddAnimation(0, “run”,true,0f);</p> 
<p>你可以在SkeletonDataAsset的Inspector中找到混合/淡入淡出选项。你可以在"Default Mix"中调整同一个Track中两个动画切换时的平滑程度。你也可以在这里添加指定动画之间的平滑过度程度。</p> 
<p><a href="https://link.jianshu.com/?t=http://zh.esotericsoftware.com/spine-unity#Track" rel="nofollow">通道(Track)</a></p> 
<p>Track是把动画分层，让角色在同一时间可以播放几个Spine动画。</p> 
<p>这在任何情况下都是有用的，比如，你的角色正在跑动，但是还想在跑动的时候拿枪进行射击。</p> 
<p>如果你在Track 0播放一个动感，然后在Track 1中播放另一个动画，这两个动画在同时播放时可以根据各自的需要去控制结束点和是否循环。</p> 
<p>在动画播放过程中，高层级的通道会覆盖低层级的Track:越大的通道数字就拥有越高的优先级。</p> 
<p>// 跑步动画运行在Track 0，而射击动画运行在Track 1</p> 
<p>skeletonAnimation.state.SetAnimation(0,"run",true);</p> 
<p>skeletonAnimation.state.SetAnimation(1,"shoot",false);</p> 
<p><a href="https://link.jianshu.com/?t=http://zh.esotericsoftware.com/spine-unity#TrackEntry" rel="nofollow">通道实体(TrackEntry)</a></p> 
<p>调用SetAnimation或者AddAnimation这两个方法后，它们会返回一个TrackEntry对象。</p> 
<p>该对象代表一个正在播放或者排队的动画实例。它包含了动画的一些信息:已播放时间、播放速度和其它一些属性。</p> 
<p>TrackEntry可以让你在SetAnimation和AddAnimation之外控制正在播放或排队动画的播放参数。</p> 
<p>如果你不选择保留SetAnimation和AddAnimation返回的TrackEntry对象，你可以这样获得有效的TrackEntry对象。</p> 
<p>vartrackEntry=skeletonAnimation.state.GetCurrent(myTrackNumber);// 返回null，就表示没有动画在运行</p> 
<p>当前时间 (开始时间)</p> 
<p>你可以从动画的任意时间点开始播放。</p> 
<p>例如，你可以在SetAnimation之后设置.Time的值，让动画从指定的帧数开始播放。但是要注意.Time的单位是秒。因为Spine的摄影表每秒30帧，所以你需要把帧转换为秒，公式是time = (帧数/30f)</p> 
<p>// 从第10帧开始播放"dance"动画</p> 
<p>vartrackEntry=skeletonAnimation.state.SetAnimation(0,"dance",false);</p> 
<p>trackEntry.Time=10f/30f;</p> 
<p>// 你可以像这样更方便得设置Time，而不需要使用另一个变量去储存TrackEntry</p> 
<p>skeletonAnimation.state.SetAnimation(0,"dance",false).Time=10f/30f;</p> 
<p>如果你这么做事为了动画事件，请确保lastTime和.Time设置了一样的值。 如果lastTime为0， 在Time0和.Time之间的所有事件都将被捕获，并在下一个Update中增加/减少。</p> 
<p>你也可以设置.EndTime改变动画的结束时间点。</p> 
<p>播放速度(TIMESCALE)</p> 
<p>可以设置TrackEntry.TimeScale去改变播放速度。还可以从SkeletonAnimation.timeScale和AnimationState.timeScale中获得最后修改的播放速度。</p> 
<p>你可以将timeScale设置为0来暂停播放。要知道，即使你将timeScale = 0来暂停骨骼的运动，但是每一帧的骨骼动画仍然存在，同时你对骨骼得任何更改都将会覆盖更新。</p> 
<p>这个简单的方法可以帮助你理解怎么跳转到指定时间点:</p> 
<p>staticpublicSpine.TrackEntryJumpToTime(SkeletonAnimationskeletonAnimation,inttrackNumber,floattime,boolskipEvents,boolstop) {<!-- --></p> 
<p>if(skeletonAnimation==null)returnnull;</p> 
<p>returnJumpToTime(skeletonAnimation.state.GetCurrent(trackNumber),time,skipEvents,stop);</p> 
<p>}</p> 
<p>staticpublicSpine.TrackEntryJumpToTime(Spine.TrackEntrytrackEntry,floattime,boolskipEvents,boolstop) {<!-- --></p> 
<p>if(trackEntry!=null) {<!-- --></p> 
<p>trackEntry.time=time;</p> 
<p>if(skipEvents)</p> 
<p>trackEntry.lastTime=time;// 在3.0中，这也会忽略附件关键帧。</p> 
<p>if(stop)</p> 
<p>trackEntry.timeScale=0;</p> 
<p>}</p> 
<p>returntrackEntry;</p> 
<p>}</p> 
<p>TRACKENTRY-特定事件.</p> 
<p>你可以为特定动画实例订阅事件。更多信息可以查看<a href="https://link.jianshu.com/?t=http://esotericsoftware.com/spine-unity-events" rel="nofollow">事件文档</a>。</p> 
<p><a href="https://link.jianshu.com/?t=http://zh.esotericsoftware.com/spine-unity#SpineAnimation" rel="nofollow">Spine.Animation</a></p> 
<p>Spine.Animation对象对应于Spine中的一个单独的"动画片段"。如果在Spine中跑步动画命名为"run"，你会得到一个叫做"run"的Spine.Animation对象。</p> 
<p>每个Spine.Animation是Timeline对象的集合。每个Timeline对象是关键帧的集合，它定义了某个动画的值(缩放、旋转、位置、颜色、网格、IK、事件、绘制顺序)是怎么随时间改变的。每个Timeline都有它自己的目的:Bone的缩放、旋转和位置;slot的附件和颜色;MeshAttachment的自由变形(FFD)/网格顶点、还有骨架各个部分的<em>绘制顺序</em>和<em>事件</em>。</p> 
<p>在Spine运行库中，使用Animation.Apply(...)将Spine.Animation应用在一个骨架上。这只能根据该骨架各个部分的Timeline和关键帧来设置姿势。如果Timeline不存在，则原动画值不会改变。如果Timeline存在，它会覆盖之前的值。</p> 
<p>这个就是说，如果你使用Spine.AnimationState的Track机制同时播放两个动画，高通道的Timeline会覆盖低通道的Timeline，但是不会改变任何东西。</p> 
<p>该系统允许用户组合骨架各个部分的不同动画，使它们相互独立得播放。</p> 
<p><a href="https://link.jianshu.com/?t=http://zh.esotericsoftware.com/spine-unity#" rel="nofollow">按照动画的帧/时间摆姿势</a></p> 
<p>如果你想按照某个动画的时间点去摆姿势，可以直接调用Animation.Apply。Spine-Unity运行库还有一个叫做Skeleton.PoseWithAnimation的扩展方法，它允许你按照动画的名字去摆姿势。</p> 
<p>其中一个参数始终是时间。该时间使用秒作为单位。如果你想按照Spine中那样摆姿势，你需要在调用Animation.Apply或Skeleton.PoseWithAnimation之前调用skeleton.SetToSetupPose()。</p> 
<p><a href="https://link.jianshu.com/?t=http://zh.esotericsoftware.com/spine-unity#pre30" rel="nofollow">动画连续性 (pre-3.0)</a></p> 
<p>这也意味着，如果没有自动复位逻辑，动画在连续播放的时候不一定和Spine中保持一致。相反，播放一个动画序列会导致之后的动画会继承之前动画的值和骨骼姿势。</p> 
<p>在3.0中，Spine.AnimationState可以让你选择性地使用自动复位逻辑句柄，或者你也可以使用原来的自由模式。</p> 
<p><a href="https://link.jianshu.com/?t=http://zh.esotericsoftware.com/spine-unity#Animation-Callbacks-+-Spine-Events" rel="nofollow">Animation Callbacks + Spine Events</a></p> 
<p>Spine.AnimationState指定动画回掉的格式请参照<a href="https://link.jianshu.com/?t=https://msdn.microsoft.com/en-us/library/awbftdfh.aspx" rel="nofollow">C# 事件</a>。你可以在里面找到一些处理动画播放的基础知识。</p> 
<p>Spine.AnimationState 支持的事件:</p> 
<p>Start当动画开始播放，</p> 
<p>End当动画被清除或中断，</p> 
<p>Complete当动画完成它全部的持续时间，</p> 
<p>Event当检测到用户自定义的事件。</p> 
<p>警告:</p> 
<p>永远不要在订阅End的方法中调用SetAnimation。因为当一个动画被中断就会触发End，然而SetAnimation会打断所有现有的动画，这会引发无限递归(End-&gt;Handle-&gt;SetAnimation-&gt;End-&gt;Handle-&gt;SetAnimation)，导致Unity没有响应，直到堆栈溢出。</p> 
<p>学习更多关于Spine事件和AnimationState回调，请查看<a href="https://link.jianshu.com/?t=http://esotericsoftware.com/spine-unity-events" rel="nofollow">事件文档</a>。</p> 
<p><a href="https://link.jianshu.com/?t=http://zh.esotericsoftware.com/spine-unity#" rel="nofollow">高级动画控制</a></p> 
<p>Tracks和TrackEntry只是Spine.AnimationState的一部分，在Spine运行库中包括AnimationState是为了访问更快捷。它在大部分情况下可以增加性能。 然而，Spine-Unity和Spine-C#即使没有AnimationState也可以起作用。一个例子是，SkeletonAnimator使用UnityEngine.Animator代替Spine.AnimationState，然后使用Mecanim去管理混合、分层和队列的数量和数据。</p> 
<p>如果你想要用不同的方式统计你的动画，你可以根据打算如何使用它或者根据特殊情况去构建一个不一样的系统。</p> 
<p>关于这点，研究<a href="https://link.jianshu.com/?t=http://esotericsoftware.com/spine-using-runtimes" rel="nofollow">Spine运行库官方文档</a>会派得上用场。</p> 
<p><a href="https://link.jianshu.com/?t=http://zh.esotericsoftware.com/spine-unity#" rel="nofollow">渲染</a></p> 
<p>一般来说，Spine的系统利用现代3D游戏引擎的优势。它的高级功能更是如此，比如FFD(自由变形)和权重。</p> 
<p>它通过框架和引擎(3D术语)连接; 在术语中有网格和顶点、还有纹理映射和UVs。所以每个图像部分由多个三角形组成的多边形来定义，或者一个矩形由两个三角形组成。这样的引擎用于2D图形，这是不常见的。</p> 
<p><img alt="" src="https://images2.imgbox.com/8a/0b/BpgVQpth_o.png"></p> 
<p>基本理念是这样的: 你已经做了三角形网格。这是Spine骨架/模型成型的基础。 你有纹理数据。这个来自纹理图集。 你有着色器程序或者混合指令。</p> 
<p>你把这些东西都交给游戏引擎，它再交给GPU，最后由GPU渲染。纹理映射到网格，着色器和混合模式是渲染的基础。</p> 
<p><img alt="" src="https://images2.imgbox.com/e7/d0/apMGYWAN_o.png"></p> 
<p>Spine-Unity使用Unity的MeshRenderer和MeshFilter组件，还有材质资源进行渲染。这些组件都是Unity用来渲染3D模型的。</p> 
<p>SkeletonRenderer类(它的基类是SkeletonAnimation)在它的LateUpdate方法中构建Mesh。它生成顶点数组、顶点颜色、三角形索引和UVs，然后把这些都放进一个UnityEngine.Mesh对象中。MeshFilter再去获得Mesh，它将被MeshRenderer使用。MeshRenderer会在适当的时间渲染网格，详情请见<a href="https://link.jianshu.com/?t=http://docs.unity3d.com/Manual/ExecutionOrder.html" rel="nofollow">Unity’s game loop</a>。</p> 
<p>MeshFilter和MeshRenderer都有<a href="https://link.jianshu.com/?t=https://en.wikipedia.org/wiki/Retained_mode" rel="nofollow">Retained Mode</a>API(与Immediate Mode API截然相反); 也就是说，网格和材质对于持续可见并不需要每帧传递。这意味着，虽然SkeletonRenderer/SkeletonAnimation可以更新网格的每一帧，但是就算在运行时禁用更新(通过禁用SkeletonAnimation或SkeletonRenderer)也不会销毁现有的网格。</p> 
<p>高级运用:骨架跳帧这也意味着，在网格生成后，你可以控制和跳过网格更新去实现特殊的跳帧和逐步更新行为。这可以减少不太重要游戏元素的更新， 或者实现一个看起来像逐帧的动画。</p> 
<p><a href="https://link.jianshu.com/?t=http://zh.esotericsoftware.com/spine-unity#" rel="nofollow">材质</a></p> 
<p>Spine-Unity也使用材质存储信息，包括纹理、着色器和必要的材质属性。该材质通过AtlasAsset分配。</p> 
<p>MeshRenderer的材质数组是由SkeletonRenderer管理的，每一帧都取决于AtlasAssets需要用到什么。直接修改该数组并不是Unity典型的设置方法。</p> 
<p><a href="https://link.jianshu.com/?t=http://zh.esotericsoftware.com/spine-unity#" rel="nofollow">更多的材质</a></p> 
<p>你可能注意到在你的MeshRenderer中有很多材质，特别是，比你实际设置的AtlasAsset还要多。</p> 
<p>如果你有一个以上的图集页是不正常的。渲染器的材质数组不能体现AtlasAsset中每一项的顺序和编号。SkeletonRenderer根据那些需要被渲染的Spine附件材质规划了一个材质数组。</p> 
<p>如果所有附件共享一个材质，SkeletonRenderer只会把这个材质放进MeshRenderer。</p> 
<p>如果一些附件用到了材质A和一些材质B，材质数组会根据材质的需要去排列顺序。这是基于附件绘制的顺序以及哪些附件可以在哪些材质纹理中。</p> 
<p>如果是这样的顺序:</p> 
<p>Attachment 来自 A</p> 
<p>Attachment 来自 A</p> 
<p>Attachment 来自 B</p> 
<p>Attachment 来自 A</p> 
<p>得到的材质数组是这样的:</p> 
<p>Material A (第一和第二)</p> 
<p>Material B (第三)</p> 
<p>Material A (第四)</p> 
<p>换句话说，有更多的附件交替来自于A和B的话，就会有更多的材质进入材质数组，在材质数组中的每一项都表示需要转换的材质。</p> 
<p>Dragon的例子可以说明这点:</p> 
<p><img alt="" src="https://images2.imgbox.com/5a/f7/9eDP4jDX_o.png"></p> 
<p>更多的材质在这个数组中，就表示会有更多的<a href="https://link.jianshu.com/?t=http://docs.unity3d.com/Manual/DrawCallBatching.html" rel="nofollow">draw calls</a>，这会对相同骨架实例化产生不好的影响。如果你只有一个这样的骨架，它可能不是拖慢速度的主要原因。</p> 
<p>学习更多关于Spine资源的排列，请看这个页面<a href="https://link.jianshu.com/?t=http://esotericsoftware.com/spine-texture-packer#Folder-structure" rel="nofollow">Spine纹理打包器: 目录结构</a></p> 
<p><a href="https://link.jianshu.com/?t=http://zh.esotericsoftware.com/spine-unity#" rel="nofollow">为每个实例设置材质属性</a></p> 
<p>同样的，改变MeshRenderer.material的值是没用的。</p> 
<p>Renderer.material属性只是渲染器生成的副本，但是它会立即被SkeletonRenderer的渲染代码给覆盖。</p> 
<p>另一方面，Renderer.sharedMaterial会修改原始材质。如果你使用这个材质生成更多的Spine游戏对象，对于它的修改应用会对所有的实例进行修改。</p> 
<p>在这个例子中，Unity的<a href="https://link.jianshu.com/?t=http://docs.unity3d.com/ScriptReference/Renderer.SetPropertyBlock.html" rel="nofollow">Renderer.SetPropertyBlock</a>是有用的方法。记住，SkeletonRenderer和SkeletonAnimation都使用MeshRenderer。设置MeshRenderer的MaterialPropertyBlock允许你改变渲染器的属性值。</p> 
<p>MaterialPropertyBlockmpb=newMaterialPropertyBlock();</p> 
<p>mpb.SetColor("_FillColor",Color.red);// "_FillColor" 是假设的着色器名字。</p> 
<p>GetComponent().SetPropertyBlock(mpb);</p> 
<p>优化的注意事项</p> 
<p>使用Renderer.SetPropertyBlock允许具有相同材质的渲染器去处理那些由不同的MaterialPropertyBlocks改变的材质属性。</p> 
<p>当你在MaterialPropertyBlock中增加或改变一个属性值的时候，你需要调用SetPropertyBlock。但是你可以把MaterialPropertyBlock作为类的一部分，所以每当你想改变属性时，不必总是实例化一个新的</p> 
<p>如果你需要频繁设置一个属性，你可以使用静态方法:Shader.PropertyToID(string)去缓存一个整数ID，这个ID可以代替String，使MaterialPropertyBlock的Setter可以使用该ID去设置属性。</p> 
<p><a href="https://link.jianshu.com/?t=http://zh.esotericsoftware.com/spine-unity#Z" rel="nofollow">精灵纹理的渲染和Z轴次序</a></p> 
<p><img alt="" src="https://images2.imgbox.com/7c/c1/jq48rdA9_o.png"></p> 
<p>Spine一般使用阿尔法混合的方式去渲染你的Spine模型。</p> 
<p>从Spine项目中绘制、上色和导出部件的时候，你导出PNG文件的像素编码格式是RGBA(红色、绿色、蓝色和阿尔法值)。在文件中，每个像素在阿尔法通道中有0-255的值，就像RGB通道一样，代表每个像素的透明度有256种层次。</p> 
<p>这种透明与半透明在阿尔法通道中定义，展现深度/渲染顺序的经典问题。这些问题有许多不完善的解决方案，并且在我们今天的AAA游戏中也会发生一些奇怪的3D现象。</p> 
<p>但是，在非常标准的方式中，也就是说i，像大多数2D阿尔法混合精灵渲染案例，包括Unity自己的Sprite/SpriteRenderer系统，Spine-Unity使用的渲染器，不使用3Dz-buffer和非阿尔法测试去确定哪些渲染在前，哪些渲染在后。</p> 
<p>在一个网格中，它根据网格中三角形的顺序去渲染物体，然后绘制一个东西在另一个东西上面。该顺序是在Spine中控制槽的绘制顺序来决定的。</p> 
<p>网格之间，Spine-Unity使用一些Unity的渲染顺序系统去确定 精灵/网格 应该谁上面。这是使用Spine-Unity标准配置的典型行为: Between meshes, Spine-Unity uses many of Unity’s render order systems to determine what sprite/mesh should be on top of which. Using the standard Spine-Unity setup, here is typical behavior for it:</p> 
<p>网格数据被当作一个整体传递给Unity。</p> 
<p>它使用GPU的triangle-by-triangle的方式渲染。</p> 
<p>所有网格的渲染由多种因素确定顺序:</p> 
<p>摄像机的距离。(摄像机判定<a href="https://link.jianshu.com/?t=http://docs.unity3d.com/ScriptReference/Camera-transparencySortMode.html" rel="nofollow">哪一种距离:平面还是透视</a>.))</p> 
<p>渲染器Sorting Layer/Sorting Order。(<a href="https://link.jianshu.com/?t=https://unity3d.com/learn/tutorials/modules/beginner/2d/sorting-layers" rel="nofollow">所有的UnityEngine.Renderers都有排序属性</a>.)</p> 
<p>着色器的语言和队列标签(默认为其他精灵的“透明”队列)</p> 
<p>Material.renderQueue。(除非你设置它否则它就什么都不做。它只是覆盖shader语言的队列标签)</p> 
<p><a href="https://link.jianshu.com/?t=http://docs.unity3d.com/ScriptReference/Camera-depth.html" rel="nofollow">摄像机深度</a>. (更多摄像机的设置.)</p> 
<p>在大多数情况下，你不需要也不应该去碰Material.renderQueue和着色器队列标签。</p> 
<p>通过改变材质上的着色器，你可以选择用不同的着色器去获得不同的融合种类。怎么处理混合行为完全取决你。</p> 
<p><a href="https://link.jianshu.com/?t=http://zh.esotericsoftware.com/spine-unity#" rel="nofollow">分层和排序</a></p> 
<p>Sorting Layer和Sorting Order属性其实是在SkeletonRenderer/SkeletonAnimation的Inspector中，实际上它只是修改了MeshRenderer的<a href="https://link.jianshu.com/?t=http://docs.unity3d.com/ScriptReference/Renderer-sortingLayerID.html" rel="nofollow">sorting layer</a>和<a href="https://link.jianshu.com/?t=http://docs.unity3d.com/ScriptReference/Renderer-sortingOrder.html" rel="nofollow">sorting order</a>属性.</p> 
<p>尽管被隐藏在MeshRenderer的Inspector中，这些属性实际上是MeshRendererserialized/stored的一部分，而不是SkeletonRenderer。</p> 
<p><a href="https://link.jianshu.com/?t=http://zh.esotericsoftware.com/spine-unity#" rel="nofollow">通过摄像头距离排序</a></p> 
<p>如果你保持所有的渲染器同样的分层和排序，他们会收到上述其他排序方案的影响。</p> 
<p>如果队列标签页一样(如果你使用相同的材质和着色器)，那么你应该根据摄像机的距离去控制Spine游戏对象的排序。</p> 
<p>别忘了这个<a href="https://link.jianshu.com/?t=http://docs.unity3d.com/ScriptReference/Camera-transparencySortMode.html" rel="nofollow">透视摄像机的排序模式</a>.</p> 
<p><a href="https://link.jianshu.com/?t=http://zh.esotericsoftware.com/spine-unity#Spine" rel="nofollow">那么可以在我的Spine骨架的部分之间渲染任何东西吗？</a></p> 
<p>有时候，你需要你的角色骑一辆自行车、举起一块石头或者拥抱一根柱子。对Spine而言，这意味着你要显示的东西，有些东西渲染在前面，有些东西渲染在后面。</p> 
<p>在Unity中，网格是整体渲染的。那么你怎么知道哪个渲染在前面，哪个渲染在后面？</p> 
<p>对于这个问题的答案是:可能将来会改变。</p> 
<p>但是对于现在来说，你可以使用Spine-unity的SkeletonUtility方法调用"Submesh Renderers"。它会单独覆盖。</p> 
<p>但基本上，它的作用是让你的SkeletonRenderer网格根据槽(上面和下面)去拆分。这些拆分的部分会根据他们自己的GameObject中的MeshRenderers去渲染。因为他们是单独渲染的，你可以分别设置他们的Sorting Order。</p> 
<p><a href="https://link.jianshu.com/?t=http://zh.esotericsoftware.com/spine-unity#" rel="nofollow">我已经调低了骨架的阿尔法值，为什么还会重复显示？</a></p> 
<p>这在任何地方都适用的实时网格渲染。当三角形被绘制时透明度就被应用了，而不是之后。</p> 
<p>这里大概有一些解决方案，或者一些变通方案。 去玩一些你最爱的游戏吧！你可以在各种2D游戏中找到一些变通方法的例子。</p> 
<p><a href="https://link.jianshu.com/?t=http://zh.esotericsoftware.com/spine-unity#SpineUnitySpine" rel="nofollow">Spine-Unity怎么决定我的Spine模型的大小?</a></p> 
<p>Spine使用 1像素:1单位。意思是，如果你只是包含图像在你的骨架中，并且没有任何旋转和缩放，在Spine中该图像的1个像素就对应1个单位高和1个单位宽。</p> 
<p>在Unity中，1单位:1米。这是Unity默认的物理值和约束(包括2D和3D)。对于这点，使用1像素:1单位通常不是一个好主意。反而，Unity自己的精灵默认缩放为1/100；意味着100个像素就是1个Unity的单位大小。</p> 
<p>为了方便，当你将Spine数据带入Unity的时候，可以将缩放设置为0.01用来匹配Unity的精灵。</p> 
<p><img alt="" src="https://images2.imgbox.com/a7/9d/1YQa20fN_o.png"></p> 
<p>如果你想设置骨架的基本比例的高低，你可以在Skeleton Data Asset的Inspector中改变这个值。当你的SkeletonData被读取时这个值是一个乘数。当SkeletonData被加载并且在运行的时候去改变这个值是没有用的。</p> 
<p>如果你想在游戏中动态得改变骨架的视觉比例(像球这种的)，你可以设置gameObject.transform.localScale属性的值。</p> 
<p><a href="https://link.jianshu.com/?t=http://zh.esotericsoftware.com/spine-unity#or" rel="nofollow">水平翻转 or 垂直翻转</a></p> 
<p>访问Skeleton.FlipX和Skeleton.FlipY可以允许骨架的水平翻转和垂直翻转。 这通常是个好主意，这可以让骨架朝着一个方向，所以你可以在代码中控制翻转逻辑。如果没有，你可以随时增加一个额外的bool变量用来控制和<a href="https://link.jianshu.com/?t=http://stackoverflow.com/questions/13983198/negate-a-boolean-based-on-another-boolean" rel="nofollow">取消预期翻转的布尔逻辑</a>.</p> 
<p>你可能已经在Unity中学会怎么反转2D精灵，设置Transform的scale为负数，或者沿着Y轴旋转180度。 这两件事纯粹是视觉的目的。但是它们有其副作用，请记住:</p> 
<p>不均匀的缩放会导致一个网格绕过Unity的配料系统。这意味着每个实例都会有它自己的draw calls。所以对于你的主要角色这没什么问题。如果你的不均匀缩放骨架的规模为数十个，它就是有害的。</p> 
<p>旋转会导致法线随着网格旋转。对于2D精灵的光照，这意味着它们会指向错误的方位。</p> 
<p>旋转X或者Y也可能会导致Unity的2D碰撞发生不可预知的结果。</p> 
<p>负比例的缩放会导致附加的物理碰撞和一些脚本逻辑发生不可预料的结果。</p> 
<p> </p> 
<p>官网地址：<a href="http://zh.esotericsoftware.com/spine-unity" rel="nofollow">http://zh.esotericsoftware.com/spine-unity</a></p> 
<p><a href="https://www.jianshu.com/nb/15568893" rel="nofollow">Unity</a></p> 
<p> </p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/4c7f36175d4fe70216e9aed6f3323ed5/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">搭建Kubernetes高可用集群</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/6870d43da48ef7c90194ec0d201ae881/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">机器人领域会议</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>