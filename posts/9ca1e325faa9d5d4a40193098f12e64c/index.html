<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Spring Boot 分布式事务 Seata 入门 - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Spring Boot 分布式事务 Seata 入门" />
<meta property="og:description" content="1. 概述 在《芋道 Seata 极简入门》文章中，我们对 Seata 进行了简单的了解，并完成了 Seata 的部署。而本文，我们将纯 Spring Boot 应用接入 Seata 来实现分布式事务。
Seata 是阿里开源的一款开源的分布式事务解决方案，致力于提供高性能和简单易用的分布式事务服务。
2. AT 模式 &#43; 多数据源 示例代码对应仓库：lab-52-multiple-datasource 。
在 Spring Boot 单体项目中，如果使用了多个数据源，我们就需要考虑多个数据源的一致性，面临分布式事务的问题。本小节，我们将使用 Seata 的 AT 模式，解决该问题。
友情提示：对 Seata 的 AT 模式不了解的胖友，可以阅读《Seata 文档 —— AT 模式》文档。
我们以用户购买商品的业务逻辑，来作为具体示例，一共会有三个模块的 Service，分别对应不同的数据库。整体如下图所示：
下面，我们来新建 lab-52-multiple-datasource 项目，最终结构如下图：
2.1 初始化数据库 使用 data.sql 脚本，创建 seata_order、seata_storage、seata_amount 三个库。脚本内容如下：
# Order DROP DATABASE IF EXISTS seata_order; CREATE DATABASE seata_order; CREATE TABLE seata_order.orders ( id INT(11) NOT NULL AUTO_INCREMENT, user_id INT(11) DEFAULT NULL, product_id INT(11) DEFAULT NULL, pay_amount DECIMAL(10, 0) DEFAULT NULL, add_time DATETIME DEFAULT CURRENT_TIMESTAMP, last_update_time DATETIME DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP, PRIMARY KEY (id) ) ENGINE = InnoDB AUTO_INCREMENT = 1 DEFAULT CHARSET = utf8; CREATE TABLE seata_order." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/9ca1e325faa9d5d4a40193098f12e64c/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2020-04-29T00:15:55+08:00" />
<meta property="article:modified_time" content="2020-04-29T00:15:55+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Spring Boot 分布式事务 Seata 入门</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <h2>1. 概述</h2> 
<p>在<a href="http://www.iocoder.cn/Seata/install/?self" rel="nofollow">《芋道 Seata 极简入门》</a>文章中，我们对 Seata 进行了简单的了解，并完成了 Seata 的部署。而本文，我们将<strong>纯</strong> Spring Boot 应用接入 Seata 来实现分布式事务。</p> 
<blockquote> 
 <p><a href="https://github.com/seata/seata">Seata</a> 是<strong>阿里</strong>开源的一款开源的<strong>分布式事务</strong>解决方案，致力于提供高性能和简单易用的分布式事务服务。</p> 
</blockquote> 
<h2>2. AT 模式 + 多数据源</h2> 
<blockquote> 
 <p>示例代码对应仓库：<a href="https://github.com/YunaiV/SpringBoot-Labs/blob/master/lab-52/lab-52-multiple-datasource/"><code>lab-52-multiple-datasource</code></a> 。</p> 
</blockquote> 
<p>在 Spring Boot <strong>单体</strong>项目中，如果使用了<strong>多个</strong>数据源，我们就需要考虑多个数据源的<strong>一致性</strong>，面临分布式事务的问题。本小节，我们将使用 Seata 的 AT 模式，解决该问题。</p> 
<blockquote> 
 <p>友情提示：对 Seata 的 AT 模式不了解的胖友，可以阅读<a href="https://seata.io/zh-cn/docs/dev/mode/at-mode.html" rel="nofollow">《Seata 文档 —— AT 模式》</a>文档。</p> 
</blockquote> 
<p>我们以用户<strong>购买商品</strong>的业务逻辑，来作为具体示例，一共会有三个模块的 Service，分别对应不同的数据库。整体如下图所示：<img alt="整体图" height="303" src="https://images2.imgbox.com/cb/4f/uR5dRX43_o.png" width="824"></p> 
<p>下面，我们来新建 <a href="https://github.com/YunaiV/SpringBoot-Labs/blob/master/lab-52/lab-52-multiple-datasource/"><code>lab-52-multiple-datasource</code></a> 项目，最终结构如下图：<img alt="项目结构" height="516" src="https://images2.imgbox.com/62/7b/DYjl1p1N_o.png" width="846"></p> 
<h3>2.1 初始化数据库</h3> 
<p>使用 <a href="https://github.com/YunaiV/SpringBoot-Labs/blob/master/lab-52/lab-52-multiple-datasource/src/main/resources/data.sql"><code>data.sql</code></a> 脚本，创建 <code>seata_order</code>、<code>seata_storage</code>、<code>seata_amount</code> <strong>三个库</strong>。脚本内容如下：</p> 
<pre><code># Order
DROP DATABASE IF EXISTS seata_order;
CREATE DATABASE seata_order;

CREATE TABLE seata_order.orders
(
    id               INT(11) NOT NULL AUTO_INCREMENT,
    user_id          INT(11)        DEFAULT NULL,
    product_id       INT(11)        DEFAULT NULL,
    pay_amount       DECIMAL(10, 0) DEFAULT NULL,
    add_time         DATETIME       DEFAULT CURRENT_TIMESTAMP,
    last_update_time DATETIME       DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
    PRIMARY KEY (id)
) ENGINE = InnoDB AUTO_INCREMENT = 1 DEFAULT CHARSET = utf8;

CREATE TABLE seata_order.undo_log
(
    id            BIGINT(20)   NOT NULL AUTO_INCREMENT,
    branch_id     BIGINT(20)   NOT NULL,
    xid           VARCHAR(100) NOT NULL,
    context       VARCHAR(128) NOT NULL,
    rollback_info LONGBLOB     NOT NULL,
    log_status    INT(11)      NOT NULL,
    log_created   DATETIME     NOT NULL,
    log_modified  DATETIME     NOT NULL,
    PRIMARY KEY (id),
    UNIQUE KEY ux_undo_log (xid, branch_id)
) ENGINE = InnoDB AUTO_INCREMENT = 1 DEFAULT CHARSET = utf8;

# Storage
DROP DATABASE IF EXISTS seata_storage;
CREATE DATABASE seata_storage;

CREATE TABLE seata_storage.product
(
    id               INT(11) NOT NULL AUTO_INCREMENT,
    stock            INT(11)  DEFAULT NULL,
    last_update_time DATETIME DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
    PRIMARY KEY (id)
) ENGINE = InnoDB AUTO_INCREMENT = 1 DEFAULT CHARSET = utf8;
INSERT INTO seata_storage.product (id, stock) VALUES (1, 10); # 插入一条产品的库存

CREATE TABLE seata_storage.undo_log
(
    id            BIGINT(20)   NOT NULL AUTO_INCREMENT,
    branch_id     BIGINT(20)   NOT NULL,
    xid           VARCHAR(100) NOT NULL,
    context       VARCHAR(128) NOT NULL,
    rollback_info LONGBLOB     NOT NULL,
    log_status    INT(11)      NOT NULL,
    log_created   DATETIME     NOT NULL,
    log_modified  DATETIME     NOT NULL,
    PRIMARY KEY (id),
    UNIQUE KEY ux_undo_log (xid, branch_id)
) ENGINE = InnoDB AUTO_INCREMENT = 1 DEFAULT CHARSET = utf8;

# Amount
DROP DATABASE IF EXISTS seata_amount;
CREATE DATABASE seata_amount;

CREATE TABLE seata_amount.account
(
    id               INT(11) NOT NULL AUTO_INCREMENT,
    balance          DOUBLE   DEFAULT NULL,
    last_update_time DATETIME DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
    PRIMARY KEY (id)
) ENGINE = InnoDB AUTO_INCREMENT = 1  DEFAULT CHARSET = utf8;

CREATE TABLE seata_amount.undo_log
(
    id            BIGINT(20)   NOT NULL AUTO_INCREMENT,
    branch_id     BIGINT(20)   NOT NULL,
    xid           VARCHAR(100) NOT NULL,
    context       VARCHAR(128) NOT NULL,
    rollback_info LONGBLOB     NOT NULL,
    log_status    INT(11)      NOT NULL,
    log_created   DATETIME     NOT NULL,
    log_modified  DATETIME     NOT NULL,
    PRIMARY KEY (id),
    UNIQUE KEY ux_undo_log (xid, branch_id)
) ENGINE = InnoDB AUTO_INCREMENT = 1 DEFAULT CHARSET = utf8;
INSERT INTO seata_amount.account (id, balance) VALUES (1, 1);</code></pre> 
<p>其中，每个库中的 <a href="https://github.com/seata/seata/blob/develop/script/client/at/db/mysql.sql"><code>undo_log</code></a> 表，是 Seata AT 模式必须创建的表，主要用于分支事务的回滚。</p> 
<p>另外，考虑到测试方便，我们插入了一条 <code>id = 1</code> 的 <code>account</code> 记录，和一条 <code>id = 1</code> 的 <code>product</code> 记录。</p> 
<h3>2.2 引入依赖</h3> 
<p>创建 <a href="https://github.com/YunaiV/SpringBoot-Labs/blob/master/lab-52/lab-52-multiple-datasource/pom.xml"><code>pom.xml</code></a> 文件，引入相关的依赖。内容如下：</p> 
<pre><code>&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;project xmlns="http://maven.apache.org/POM/4.0.0"
         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"&gt;
    &lt;parent&gt;
        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
        &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt;
        &lt;version&gt;2.2.2.RELEASE&lt;/version&gt;
        &lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt;
    &lt;/parent&gt;
    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;

    &lt;artifactId&gt;lab-52-multiple-datasource&lt;/artifactId&gt;

    &lt;dependencies&gt;
        &lt;!-- 实现对 Spring MVC 的自动化配置 --&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
            &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;
        &lt;/dependency&gt;

        &lt;!-- 实现对数据库连接池的自动化配置 --&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
            &lt;artifactId&gt;spring-boot-starter-jdbc&lt;/artifactId&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt; &lt;!-- 本示例，我们使用 MySQL --&gt;
            &lt;groupId&gt;mysql&lt;/groupId&gt;
            &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;
            &lt;version&gt;5.1.48&lt;/version&gt;
        &lt;/dependency&gt;

        &lt;!-- 实现对 MyBatis 的自动化配置 --&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.mybatis.spring.boot&lt;/groupId&gt;
            &lt;artifactId&gt;mybatis-spring-boot-starter&lt;/artifactId&gt;
            &lt;version&gt;2.1.2&lt;/version&gt;
        &lt;/dependency&gt;

        &lt;!-- 实现对 dynamic-datasource 的自动化配置 --&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;com.baomidou&lt;/groupId&gt;
            &lt;artifactId&gt;dynamic-datasource-spring-boot-starter&lt;/artifactId&gt;
            &lt;version&gt;3.0.0&lt;/version&gt;
        &lt;/dependency&gt;

        &lt;!-- 实现对 Seata 的自动化配置 --&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;io.seata&lt;/groupId&gt;
            &lt;artifactId&gt;seata-spring-boot-starter&lt;/artifactId&gt;
            &lt;version&gt;1.1.0&lt;/version&gt;
        &lt;/dependency&gt;
    &lt;/dependencies&gt;

&lt;/project&gt;</code></pre> 
<p>① 引入 <a href="https://mvnrepository.com/artifact/com.baomidou/dynamic-datasource-spring-boot-starter" rel="nofollow"><code>dynamic-datasource-spring-boot-starter</code></a> 依赖，实现对 <a href="https://mp.baomidou.com/guide/dynamic-datasource.html" rel="nofollow"><code>dynamic-datasource</code></a> 的自动配置，用于多数据源的<strong>切换</strong>功能。</p> 
<blockquote> 
 <p>友情提示：关于数据源的切换功能，胖友可以阅读<a href="http://www.iocoder.cn/Spring-Boot/dynamic-datasource/?self" rel="nofollow">《芋道 Spring Boot 多数据源（读写分离）入门》</a>文章，贼详细。</p> 
</blockquote> 
<p>② 引入 <a href="https://mvnrepository.com/artifact/io.seata/seata-spring-boot-starter" rel="nofollow"><code>seata-spring-boot-starter</code></a> 依赖，实现对 Seata 的自动配置。</p> 
<h3>2.3 配置文件</h3> 
<p>创建 <a href="https://github.com/YunaiV/SpringBoot-Labs/blob/master/lab-52/lab-52-multiple-datasource/src/main/resources/application.yaml"><code>application.yaml</code></a> 配置文件，添加相关的配置项。内容如下：</p> 
<pre><code>server:
  port: 8081 # 端口

spring:
  application:
    name: multi-datasource-service  # 应用名

  datasource:
    # dynamic-datasource-spring-boot-starter 动态数据源的配配项，对应 DynamicDataSourceProperties 类
    dynamic:
      primary: order-ds # 设置默认的数据源或者数据源组，默认值即为 master
      datasource:
        # 订单 order 数据源配置
        order-ds:
          url: jdbc:mysql://127.0.0.1:3306/seata_order?useSSL=false&amp;useUnicode=true&amp;characterEncoding=UTF-8
          driver-class-name: com.mysql.jdbc.Driver
          username: root
          password:
        # 账户 pay 数据源配置
        amount-ds:
          url: jdbc:mysql://127.0.0.1:3306/seata_pay?useSSL=false&amp;useUnicode=true&amp;characterEncoding=UTF-8
          driver-class-name: com.mysql.jdbc.Driver
          username: root
          password:
        # 库存 storage 数据源配置
        storage-ds:
          url: jdbc:mysql://127.0.0.1:3306/seata_storage?useSSL=false&amp;useUnicode=true&amp;characterEncoding=UTF-8
          driver-class-name: com.mysql.jdbc.Driver
          username: root
          password:
      seata: true # 是否启动对 Seata 的集成

# Seata 配置项，对应 SeataProperties 类
seata:
  application-id: ${spring.application.name} # Seata 应用编号，默认为 ${spring.application.name}
  tx-service-group: ${spring.application.name}-group # Seata 事务组编号，用于 TC 集群名
  # 服务配置项，对应 ServiceProperties 类
  service:
    # 虚拟组和分组的映射
    vgroup-mapping:
      multi-datasource-service-group: default
    # 分组和 Seata 服务的映射
    grouplist:
      default: 127.0.0.1:8091</code></pre> 
<p>① <code>spring.datasource.dynamic</code> 配置项，设置 <code>dynamic-datasource-spring-boot-starter</code> 动态数据源的配置项，对应 <a href="https://github.com/baomidou/dynamic-datasource-spring-boot-starter/blob/master/src/main/java/com/baomidou/dynamic/datasource/spring/boot/autoconfigure/DynamicDataSourceProperties.java">DynamicDataSourceProperties</a> 类。</p> 
<p><strong>注意</strong>，一定要设置 <code>spring.datasource.dynamic.seata</code> 配置项为 <code>true</code>，开启对 Seata 的集成！！！艿艿一开始忘记配置，导致 Seata 全局事务回滚失败。</p> 
<p>② <code>seata</code> 配置项，设置 Seata 的配置项目，对应 <a href="https://github.com/seata/seata/blob/develop/seata-spring-boot-starter/src/main/java/io/seata/spring/boot/autoconfigure/properties/SeataProperties.java">SeataProperties</a> 类。</p> 
<ul><li><code>application-id</code> 配置项，对应 Seata 应用编号，默认为 <code>${spring.application.name}</code>。实际上，可以不进行设置。</li><li><code>tx-service-group</code> 配置项，Seata 事务组编号，用于 TC 集群名。</li></ul> 
<p>③ <code>seata.service</code> 配置项，Seata 服务配置项，对应 <a href="https://github.com/seata/seata/blob/develop/seata-spring-boot-starter/src/main/java/io/seata/spring/boot/autoconfigure/properties/file/ServiceProperties.java">ServiceProperties</a> 类。它主要用于 Seata 在事务分组的特殊设计，可见<a href="https://seata.io/zh-cn/docs/user/transaction-group.html" rel="nofollow">《Seata 文档 —— 事务分组专题》</a>。如果不能理解的胖友，可以见如下图：</p> 
<p><img alt="åç»æ å°" height="284" src="https://images2.imgbox.com/ce/e8/GUmVMhfC_o.png" width="877"></p> 
<p>简单来说，就是多了一层<strong>虚拟</strong>映射。这里，我们<strong>直接</strong>设置 TC Server 的地址，为 <code>127.0.0.1:8091</code>。</p> 
<h3>2.4 订单模块</h3> 
<h4>2.4.1 OrderController</h4> 
<p>创建 <a href="https://github.com/YunaiV/SpringBoot-Labs/blob/master/lab-52/lab-52-multiple-datasource/src/main/java/cn/iocoder/springboot/lab52/seatademo/controller/OrderController.java">OrderController</a> 类，提供 <code>order/create</code> 下单 HTTP API。代码如下：</p> 
<pre><code class="language-java">@RestController
@RequestMapping("/order")
public class OrderController {

    private Logger logger = LoggerFactory.getLogger(OrderController.class);

    @Autowired
    private OrderService orderService;

    @PostMapping("/create")
    public Integer createOrder(@RequestParam("userId") Long userId,
                               @RequestParam("productId") Long productId,
                               @RequestParam("price") Integer price) throws Exception {
        logger.info("[createOrder] 收到下单请求,用户:{}, 商品:{}, 价格:{}", userId, productId, price);
        return orderService.createOrder(userId, productId, price);
    }

}</code></pre> 
<ul><li>该 API 中，会调用 OrderService 进行下单。</li></ul> 
<blockquote> 
 <p>友情提示：因为这个是示例项目，所以直接传入 <code>price</code> 参数，作为订单的金额，实际肯定不是这样的，哈哈哈~</p> 
</blockquote> 
<h4>2.4.2 OrderService</h4> 
<p>创建 <a href="https://github.com/YunaiV/SpringBoot-Labs/blob/master/lab-52/lab-52-multiple-datasource/src/main/java/cn/iocoder/springboot/lab52/seatademo/service/OrderService.java">OrderService</a> 接口，定义了创建订单的方法。代码如下：</p> 
<pre><code class="language-java">/**
 * 订单 Service
 */
public interface OrderService {

    /**
     * 创建订单
     *
     * @param userId 用户编号
     * @param productId 产品编号
     * @param price 价格
     * @return 订单编号
     * @throws Exception 创建订单失败，抛出异常
     */
    Integer createOrder(Long userId, Long productId, Integer price) throws Exception;

}</code></pre> 
<h4>2.4.3 OrderServiceImpl</h4> 
<p>创建 <a href="https://github.com/YunaiV/SpringBoot-Labs/blob/master/lab-52/lab-52-multiple-datasource/src/main/java/cn/iocoder/springboot/lab52/seatademo/service/impl/OrderServiceImpl.java">OrderServiceImpl</a> 类，实现创建订单的方法。代码如下：</p> 
<pre><code class="language-java">@Service
public class OrderServiceImpl implements OrderService {

    private Logger logger = LoggerFactory.getLogger(getClass());

    @Autowired
    private OrderDao orderDao;

    @Autowired
    private AccountService accountService;

    @Autowired
    private ProductService productService;

    @Override
    @DS(value = "order-ds") // &lt;1&gt;
    @GlobalTransactional // &lt;2&gt;
    public Integer createOrder(Long userId, Long productId, Integer price) throws Exception {
        Integer amount = 1; // 购买数量，暂时设置为 1。

        logger.info("[createOrder] 当前 XID: {}", RootContext.getXID());

        // &lt;3&gt; 扣减库存
        productService.reduceStock(productId, amount);

        // &lt;4&gt; 扣减余额
        accountService.reduceBalance(userId, price);

        // &lt;5&gt; 保存订单
        OrderDO order = new OrderDO().setUserId(userId).setProductId(productId).setPayAmount(amount * price);
        orderDao.saveOrder(order);
        logger.info("[createOrder] 保存订单: {}", order.getId());

        // 返回订单编号
        return order.getId();
    }

}</code></pre> 
<p><code>&lt;1&gt;</code> 处，在类上，添加了 <code>@DS</code> 注解，设置使用 <code>order-ds</code> 订单数据源。</p> 
<p><code>&lt;2&gt;</code> 处，在类上，添加 Seata <code>@GlobalTransactional</code> 注解，<strong>声明全局事务</strong>。</p> 
<p><code>&lt;3&gt;</code> 和 <code>&lt;4&gt;</code> 处，在该方法中，调用 ProductService 扣除商品的库存，调用 AccountService 扣除账户的余额。虽然说，调用是 <strong>JVM 进程</strong>内的，但是 ProductService 操作的是 <code>product-ds</code> 商品数据源，AccountService 操作的是 <code>account-ds</code> 账户数据源。</p> 
<p><code>&lt;5&gt;</code> 处，在全部调用成功后，调用 OrderDao 保存订单。</p> 
<h4>2.4.4 OrderDao</h4> 
<p>创建 <a href="https://github.com/YunaiV/SpringBoot-Labs/blob/master/lab-52/lab-52-multiple-datasource/src/main/java/cn/iocoder/springboot/lab52/seatademo/dao/OrderDao.java">OrderDao</a> 接口，定义保存订单的操作。代码如下：</p> 
<pre><code class="language-java">@Mapper
@Repository
public interface OrderDao {

    /**
     * 插入订单记录
     *
     * @param order 订单
     * @return 影响记录数量
     */
    @Insert("INSERT INTO orders (user_id, product_id, pay_amount) VALUES (#{userId}, #{productId}, #{payAmount})")
    @Options(useGeneratedKeys = true, keyColumn = "id", keyProperty = "id")
    int saveOrder(OrderDO order);

}</code></pre> 
<p>其中，<a href="https://github.com/YunaiV/SpringBoot-Labs/blob/master/lab-52/lab-52-multiple-datasource/src/main/java/cn/iocoder/springboot/lab52/seatademo/entity/OrderDO.java">OrderDO</a> <strong>实体</strong>类，对应 <code>orders</code> 表。代码如下： </p> 
<pre><code class="language-java">/**
 * 订单实体
 */
public class OrderDO {

    /** 订单编号 **/
    private Integer id;

    /** 用户编号 **/
    private Long userId;

    /** 产品编号 **/
    private Long productId;

    /** 支付金额 **/
    private Integer payAmount;
    
    // ... 省略 setter/getter 方法
    
}</code></pre> 
<h3>2.5 商品模块</h3> 
<h4>2.5.1 ProductService</h4> 
<p>创建 <a href="https://github.com/YunaiV/SpringBoot-Labs/blob/master/lab-52/lab-52-multiple-datasource/src/main/java/cn/iocoder/springboot/lab52/seatademo/service/ProductService.java">ProductService</a> 接口，定义了扣除库存的方法。代码如下：</p> 
<pre><code class="language-java">/**
 * 商品 Service
 */
public interface ProductService {

    /**
     * 扣减库存
     *
     * @param productId 商品 ID
     * @param amount    扣减数量
     * @throws Exception 扣减失败时抛出异常
     */
    void reduceStock(Long productId, Integer amount) throws Exception;

}</code></pre> 
<h4>2.5.2 ProductServiceImpl</h4> 
<p>创建 <a href="https://github.com/YunaiV/SpringBoot-Labs/blob/master/lab-52/lab-52-multiple-datasource/src/main/java/cn/iocoder/springboot/lab52/seatademo/service/impl/ProductServiceImpl.java">ProductServiceImpl</a> 类，实现扣减库存的方法。代码如下：</p> 
<pre><code class="language-java">@Service
public class ProductServiceImpl implements ProductService {

    private Logger logger = LoggerFactory.getLogger(getClass());

    @Autowired
    private ProductDao productDao;

    @Override
    @DS(value = "product-ds") // &lt;1&gt;
    @Transactional(propagation = Propagation.REQUIRES_NEW) // &lt;2&gt; 开启新事物
    public void reduceStock(Long productId, Integer amount) throws Exception {
        logger.info("[reduceStock] 当前 XID: {}", RootContext.getXID());

        // &lt;3&gt; 检查库存
        checkStock(productId, amount);

        logger.info("[reduceStock] 开始扣减 {} 库存", productId);
        // &lt;4&gt; 扣减库存
        int updateCount = productDao.reduceStock(productId, amount);
        // 扣除成功
        if (updateCount == 0) {
            logger.warn("[reduceStock] 扣除 {} 库存失败", productId);
            throw new Exception("库存不足");
        }
        // 扣除失败
        logger.info("[reduceStock] 扣除 {} 库存成功", productId);
    }

    private void checkStock(Long productId, Integer requiredAmount) throws Exception {
        logger.info("[checkStock] 检查 {} 库存", productId);
        Integer stock = productDao.getStock(productId);
        if (stock &lt; requiredAmount) {
            logger.warn("[checkStock] {} 库存不足，当前库存: {}", productId, stock);
            throw new Exception("库存不足");
        }
    }

}</code></pre> 
<p><code>&lt;1&gt;</code> 处，在类上，添加了 <code>@DS</code> 注解，设置使用 <code>product-ds</code> 商品数据源。</p> 
<p><code>&lt;2&gt;</code> 处，在类上，添加了 Spring <code>@Transactional</code> 注解，<strong>声明本地事务</strong>。也就是说，此处会开启一个 <code>seata_product</code> 库的数据库事务。</p> 
<ul><li> </li></ul> 
<p><code>&lt;3&gt;</code> 处，检查库存是否足够，如果不够则抛出 Exception 异常。因为我们需要通过异常，回滚全局异常。</p> 
<p><code>&lt;4&gt;</code> 处，进行扣除库存，如果扣除失败则抛出 Exception 异常。</p> 
<h4>2.5.3 ProductDao</h4> 
<p>创建 <a href="https://github.com/YunaiV/SpringBoot-Labs/blob/master/lab-52/lab-52-multiple-datasource/src/main/java/cn/iocoder/springboot/lab52/seatademo/dao/ProductDao.java">ProductDao</a> 接口，定义获取和扣除库存的操作。代码如下：</p> 
<pre><code class="language-java">@Mapper
@Repository
public interface ProductDao {

    /**
     * 获取库存
     *
     * @param productId 商品编号
     * @return 库存
     */
    @Select("SELECT stock FROM product WHERE id = #{productId}")
    Integer getStock(@Param("productId") Long productId);

    /**
     * 扣减库存
     *
     * @param productId 商品编号
     * @param amount    扣减数量
     * @return 影响记录行数
     */
    @Update("UPDATE product SET stock = stock - #{amount} WHERE id = #{productId} AND stock &gt;= #{amount}")
    int reduceStock(@Param("productId") Long productId, @Param("amount") Integer amount);

}</code></pre> 
<h3>2.6 账户模块</h3> 
<blockquote> 
 <p>友情提示：逻辑和<a href="http://www.iocoder.cn/Spring-Boot/Seata/?self#" rel="nofollow">「2.5 商品模块」</a>基本一致，也是扣减逻辑。</p> 
</blockquote> 
<h4>2.6.1 AccountService</h4> 
<p>创建 <a href="https://github.com/YunaiV/SpringBoot-Labs/blob/master/lab-52/lab-52-multiple-datasource/src/main/java/cn/iocoder/springboot/lab52/seatademo/service/AccountService.java">AccountService</a> 类，定义扣除余额的方法。代码如下：</p> 
<pre><code class="language-java">/**
 * 账户 Service
 */
public interface AccountService {

    /**
     * 扣除余额
     *
     * @param userId 用户编号
     * @param price  扣减金额
     * @throws Exception 失败时抛出异常
     */
    void reduceBalance(Long userId, Integer price) throws Exception;

}</code></pre> 
<h4>2.6.2 AccountServiceImpl</h4> 
<p>创建 <a href="https://github.com/YunaiV/SpringBoot-Labs/blob/master/lab-52/lab-52-multiple-datasource/src/main/java/cn/iocoder/springboot/lab52/seatademo/service/impl/AccountServiceImpl.java">AccountServiceImpl</a> 类，实现扣除余额的方法。代码如下：</p> 
<pre><code class="language-java">@Service
public class AccountServiceImpl implements AccountService {

    private Logger logger = LoggerFactory.getLogger(getClass());

    @Autowired
    private AccountDao accountDao;

    @Override
    @DS(value = "account-ds") // &lt;1&gt;
    @Transactional(propagation = Propagation.REQUIRES_NEW) // &lt;2&gt; 开启新事物
    public void reduceBalance(Long userId, Integer price) throws Exception {
        logger.info("[reduceBalance] 当前 XID: {}", RootContext.getXID());

        // &lt;3&gt; 检查余额
        checkBalance(userId, price);

        logger.info("[reduceBalance] 开始扣减用户 {} 余额", userId);
        // &lt;4&gt; 扣除余额
        int updateCount = accountDao.reduceBalance(price);
        // 扣除成功
        if (updateCount == 0) {
            logger.warn("[reduceBalance] 扣除用户 {} 余额失败", userId);
            throw new Exception("余额不足");
        }
        logger.info("[reduceBalance] 扣除用户 {} 余额成功", userId);
    }

    private void checkBalance(Long userId, Integer price) throws Exception {
        logger.info("[checkBalance] 检查用户 {} 余额", userId);
        Integer balance = accountDao.getBalance(userId);
        if (balance &lt; price) {
            logger.warn("[checkBalance] 用户 {} 余额不足，当前余额:{}", userId, balance);
            throw new Exception("余额不足");
        }
    }

}</code></pre> 
<p><code>&lt;1&gt;</code> 处，在类上，添加了 <code>@DS</code> 注解，设置使用 <code>account-ds</code> 账户数据源。</p> 
<p><code>&lt;2&gt;</code> 处，在类上，添加了 Spring <code>@Transactional</code> 注解，<strong>声明本地事务</strong>。也就是说，此处会开启一个 <code>seata_account</code> 库的数据库事务。</p> 
<p><code>&lt;3&gt;</code> 处，检查余额是否足够，如果不够则抛出 Exception 异常。因为我们需要通过异常，回滚全局异常。</p> 
<p><code>&lt;4&gt;</code> 处，进行扣除余额，如果扣除失败则抛出 Exception 异常。</p> 
<h4>2.6.3 AccountDao</h4> 
<p>创建 <a href="https://github.com/YunaiV/SpringBoot-Labs/blob/master/lab-52/lab-52-multiple-datasource/src/main/java/cn/iocoder/springboot/lab52/seatademo/dao/AccountDao.java">AccountDao</a> 接口，定义查询和扣除余额的操作。代码如下：</p> 
<pre><code class="language-java">@Mapper
@Repository
public interface AccountDao {

    /**
     * 获取账户余额
     *
     * @param userId 用户 ID
     * @return 账户余额
     */
    @Select("SELECT balance FROM account WHERE id = #{userId}")
    Integer getBalance(@Param("userId") Long userId);

    /**
     * 扣减余额
     *
     * @param price 需要扣减的数目
     * @return 影响记录行数
     */
    @Update("UPDATE account SET balance = balance - #{price} WHERE id = 1 AND balance &gt;= ${price}")
    int reduceBalance(@Param("price") Integer price);

}</code></pre> 
<h3>2.7 MultipleDatasourceApplication</h3> 
<p>创建 <a href="https://github.com/YunaiV/SpringBoot-Labs/blob/master/lab-52/lab-52-multiple-datasource/src/main/java/cn/iocoder/springboot/lab52/seatademo/MultipleDatasourceApplication.java">MultipleDatasourceApplication</a> 类，用于启动项目。代码如下：</p> 
<pre><code class="language-java">@SpringBootApplication
public class MultipleDatasourceApplication {

    public static void main(String[] args) {
        SpringApplication.run(MultipleDatasourceApplication.class, args);
    }

}</code></pre> 
<h3>2.8 简单测试</h3> 
<p>下面，我们将测试两种情况：</p> 
<ol><li>分布式事务正常提交</li><li>分布式事务异常回滚</li></ol> 
<p><strong>Debug</strong> 执行 MultipleDatasourceApplication 启动 Spring Boot 应用。此时，我们可以看到 Seata 相关日志如下：</p> 
<blockquote> 
 <p>友情提示：日志的顺序，艿艿做了简单的整理，为了更容易阅读。</p> 
</blockquote> 
<pre><code># ... 上面还有 Seata 相关 Bean 初始化的日志，忘记加进来了，嘿嘿~

# `dynamic-datasource` 初始化动态数据源
2020-04-03 21:01:28.305  INFO 24912 --- [           main] c.b.d.d.DynamicRoutingDataSource         : dynamic-datasource detect ALIBABA SEATA and enabled it
2020-04-03 21:01:28.415  INFO 24912 --- [           main] com.alibaba.druid.pool.DruidDataSource   : {dataSource-1,order-ds} inited
2020-04-03 21:01:28.416  INFO 24912 --- [           main] com.alibaba.druid.pool.DruidDataSource   : {dataSource-2,account-ds} inited
2020-04-03 21:01:28.417  INFO 24912 --- [           main] com.alibaba.druid.pool.DruidDataSource   : {dataSource-3,product-ds} inited
# 给数据源增加 Seata 的数据源代理
2020-04-03 21:01:28.933  INFO 24912 --- [           main] s.s.a.d.SeataDataSourceBeanPostProcessor : Auto proxy of [dataSource]
# 加载 Druid 提供的 SQL 解析器
2020-04-03 21:01:28.742  INFO 24912 --- [           main] i.s.common.loader.EnhancedServiceLoader  : load DbTypeParser[druid] extension by class[io.seata.sqlparser.druid.DruidDelegatingDbTypeParser]
# 连接到 Seata TC Server 服务器
2020-04-03 21:01:28.750  INFO 24912 --- [           main] i.s.c.r.netty.NettyClientChannelManager  : will connect to 127.0.0.1:8091
2020-04-03 21:01:28.752  INFO 24912 --- [           main] i.s.core.rpc.netty.NettyPoolableFactory  : NettyPool create channel to transactionRole:RMROLE,address:127.0.0.1:8091,msg:&lt; RegisterRMRequest{resourceIds='jdbc:mysql://127.0.0.1:3306/seata_product', applicationId='multi-datasource-service', transactionServiceGroup='multi-datasource-service-group'} &gt;
# 加载 Seata 序列化器
2020-04-03 21:01:28.883  INFO 24912 --- [lector_RMROLE_1] i.s.common.loader.EnhancedServiceLoader  : load Serializer[SEATA] extension by class[io.seata.serializer.seata.SeataSerializer]
# 注册 Seata Resource Manager 到 Seata TC Server 成功 
2020-04-03 21:01:28.751  INFO 24912 --- [           main] io.seata.core.rpc.netty.RmRpcClient      : RM will register :jdbc:mysql://127.0.0.1:3306/seata_product
2020-04-03 21:01:28.902  INFO 24912 --- [           main] io.seata.core.rpc.netty.RmRpcClient      : register RM success. server version:1.1.0,channel:[id: 0x0ec2ca91, L:/127.0.0.1:56463 - R:/127.0.0.1:8091]
2020-04-03 21:01:28.911  INFO 24912 --- [           main] i.s.core.rpc.netty.NettyPoolableFactory  : register success, cost 52 ms, version:1.1.0,role:RMROLE,channel:[id: 0x0ec2ca91, L:/127.0.0.1:56463 - R:/127.0.0.1:8091]
2020-04-03 21:01:28.916  INFO 24912 --- [           main] io.seata.core.rpc.netty.RmRpcClient      : will register resourceId:jdbc:mysql://127.0.0.1:3306/seata_account
2020-04-03 21:01:28.920  INFO 24912 --- [           main] io.seata.core.rpc.netty.RmRpcClient      : will register resourceId:jdbc:mysql://127.0.0.1:3306/seata_order
2020-04-03 21:01:28.937  INFO 24912 --- [           main] io.seata.core.rpc.netty.RmRpcClient      : will register resourceId:jdbc:mysql://127.0.0.1:3306/seata_order
# `dynamic-datasource` 针对 Seata 的集成
2020-04-03 21:01:28.921  INFO 24912 --- [           main] c.b.d.d.DynamicRoutingDataSource         : dynamic-datasource - load a datasource named [order-ds] success
2020-04-03 21:01:28.912  INFO 24912 --- [           main] c.b.d.d.DynamicRoutingDataSource         : dynamic-datasource [product-ds] wrap seata plugin
2020-04-03 21:01:28.912  INFO 24912 --- [           main] c.b.d.d.DynamicRoutingDataSource         : dynamic-datasource - load a datasource named [product-ds] success
2020-04-03 21:01:28.916  INFO 24912 --- [           main] c.b.d.d.DynamicRoutingDataSource         : dynamic-datasource [account-ds] wrap seata plugin
2020-04-03 21:01:28.916  INFO 24912 --- [           main] c.b.d.d.DynamicRoutingDataSource         : dynamic-datasource - load a datasource named [account-ds] success
2020-04-03 21:01:28.921  INFO 24912 --- [           main] c.b.d.d.DynamicRoutingDataSource         : dynamic-datasource [order-ds] wrap seata plugin
2020-04-03 21:01:28.921  INFO 24912 --- [           main] c.b.d.d.DynamicRoutingDataSource         : dynamic-datasource initial loaded [3] datasource,primary datasource named [order-ds]
# 因为 OrderServiceImpl 添加了 `@GlobalTransactional` 注解，所以创建其代理，用于全局事务。
2020-04-03 21:01:29.115  INFO 24912 --- [           main] i.s.s.a.GlobalTransactionScanner         : Bean[cn.iocoder.springboot.lab52.seatademo.service.impl.OrderServiceImpl$$EnhancerBySpringCGLIB$$f38d0660] with name [orderServiceImpl] would use interceptor [io.seata.spring.annotation.GlobalTransactionalInterceptor]</code></pre> 
<h4>2.8.1 正常流程</h4> 
<p>① 先查询下目前数据库的数据情况。如下图所示：<img alt="数据库 - 初始" src="https://images2.imgbox.com/78/df/q6qOmRbr_o.png"></p> 
<p>② 使用 Postman 模拟调用 <a href="http://127.0.0.1:8081/order/create" rel="nofollow">http://127.0.0.1:8081/order/create</a> 创建订单的接口，如下图所示：<img alt="Postman" height="309" src="https://images2.imgbox.com/4a/0d/UH6maxEv_o.png" width="862"></p> 
<p>此时，在控制台打印日志如下图所示：<img alt="执行日志" height="423" src="https://images2.imgbox.com/40/a1/MO521lAs_o.png" width="862"></p> 
<p>再查询下目前数据库的数据情况。如下图所示：<img alt="数据库 - 结果" height="475" src="https://images2.imgbox.com/9f/96/yrF2Jn1G_o.png" width="865"></p> 
<h4>2.8.2 异常流程</h4> 
<p>① 先查询下目前数据库的数据情况。如下图所示：<img alt="数据库 - 结果" height="474" src="https://images2.imgbox.com/af/df/C2K0qQuL_o.png" width="863"></p> 
<p>② 在 OrderServiceImpl 的 <code>#createOrder(...)</code> 方法上，打上断点如下图，方便我们看到 <code>product</code> 表的 <code>balance</code> 被减少：<img alt="断点" height="713" src="https://images2.imgbox.com/5d/63/RL4dR7Zr_o.png" width="868"></p> 
<blockquote> 
 <p>友情提示：这里忘记截图了，稍后 IDEA 停留在该断点时，胖友可以去查询 <code>product</code> 表，会发现 <code>balance</code> 已经减少。</p> 
</blockquote> 
<p>③ 使用 Postman 模拟调用 <a href="http://127.0.0.1:8081/order/create" rel="nofollow">http://127.0.0.1:8081/order/create</a> 创建订单的接口，如下图所示：<img alt="Postman" height="307" src="https://images2.imgbox.com/97/cf/9OpYXVdH_o.png" width="871"></p> 
<p>此时，在控制台打印日志如下图所示：<img alt="执行日志" height="425" src="https://images2.imgbox.com/ab/b9/1AHGvpm5_o.png" width="874"></p> 
<p>再查询下目前数据库的数据情况。如下图所示：<img alt="数据库 - 结果" height="393" src="https://images2.imgbox.com/63/41/F6d7bFTG_o.png" width="875"></p> 
<h2>3. AT 模式 + HttpClient 远程调用</h2> 
<blockquote> 
 <p>示例代码对应仓库：</p> 
 <ul><li>订单服务：<a href="https://github.com/YunaiV/SpringBoot-Labs/blob/master/lab-52/lab-52-seata-at-httpclient-demo/lab-52-seata-at-httpclient-demo-order-service/"><code>lab-52-seata-at-httpclient-demo-order-service</code></a></li><li>商品服务：<a href="https://github.com/YunaiV/SpringBoot-Labs/blob/master/lab-52/lab-52-seata-at-httpclient-demo/lab-52-seata-at-httpclient-demo-product-service/"><code>lab-52-seata-at-httpclient-demo-product-service</code></a></li><li>账户服务：<a href="https://github.com/YunaiV/SpringBoot-Labs/blob/master/lab-52/lab-52-seata-at-httpclient-demo/lab-52-seata-at-httpclient-demo-account-service/"><code>lab-52-seata-at-httpclient-demo-account-service</code></a></li></ul> 
</blockquote> 
<p>本小节，我们会将<a href="http://www.iocoder.cn/Spring-Boot/Seata/?self#" rel="nofollow">「2. AT 模式 + 多数据源」</a>小节的用户<strong>购买商品</strong>的 Spring Boot <strong>单体</strong>应用，拆成分<strong>多个</strong> Spring Boot 应用，通过 <a href="https://hc.apache.org/" rel="nofollow">Apache HttpClient</a> 来实现 HTTP 远程调用每个 Spring Boot 应用提供的 Restful API 接口。整体如下图所示：<img alt="整体图" height="313" src="https://images2.imgbox.com/09/14/4FFnVtdf_o.png" width="870"></p> 
<blockquote> 
 <p>友情提示：早期的微服务架构，会采用 Nginx 对后端的服务进行负载均衡，而服务提供者使用 HttpClient 进行远程 HTTP 调用。例如说：<img alt="Nginx + Spring Boot" height="349" src="https://images2.imgbox.com/86/ab/TT9ptX3Q_o.png" width="844"></p> 
</blockquote> 
<p>Seata 提供了 <a href="https://github.com/seata/seata/blob/develop/integration/http/"><code>seata-http</code></a> 项目，对 Apache HttpClient 进行集成。实现原理是：</p> 
<ul><li>服务<strong>消费者</strong>，使用 Seata 封装的 <a href="https://github.com/seata/seata/blob/develop/integration/http/src/main/java/io/seata/integration/http/AbstractHttpExecutor.java#L117-L136">AbstractHttpExecutor</a> 执行器，在使用HttpClient 发起 HTTP 调用时，将 Seata 全局事务 <strong>XID</strong> 通过 <a href="https://www.w3schools.com/tags/tag_header.asp" rel="nofollow">Header</a> 传递。</li><li>服务<strong>提供者</strong>，使用 Seata 提供的 SpringMVC <a href="https://github.com/seata/seata/blob/develop/integration/http/src/main/java/io/seata/integration/http/TransactionPropagationIntercepter.java">TransactionPropagationIntercepter</a> 拦截器，将 Header 中的 Seata 全局事务 <strong>XID</strong> 解析出来，设置到 Seata <a href="https://github.com/seata/seata/blob/develop/core/src/main/java/io/seata/core/context/RootContext.java">上下文</a> 中。</li></ul> 
<p>如此，我们便实现了多个 Spring Boot 应用的 Seata 全局事务的<strong>传播</strong>。</p> 
<p>下面，我们来新建 <a href="https://github.com/YunaiV/SpringBoot-Labs/blob/master/lab-52/lab-52-seata-at-httpclient-demo/"><code>lab-52-seata-at-httpclient-demo</code></a> 模块，包含三个 Spring Boot 项目。最终结构如下图：<img alt="项目结构" height="537" src="https://images2.imgbox.com/e8/69/T4nb7DJ5_o.png" width="874"></p> 
<h3>3.1 初始化数据库</h3> 
<p>使用 <a href="https://github.com/YunaiV/SpringBoot-Labs/blob/master/lab-52/lab-52-multiple-datasource/src/main/resources/data.sql"><code>data.sql</code></a> 脚本，创建 <code>seata_order</code>、<code>seata_storage</code>、<code>seata_amount</code> <strong>三个库</strong>。</p> 
<blockquote> 
 <p>友情提示：整体内容和<a href="http://www.iocoder.cn/Spring-Boot/Seata/?self#" rel="nofollow">「2.1 初始化数据库」</a>小节一样。</p> 
</blockquote> 
<h3>3.2 订单服务</h3> 
<p>新建 <a href="https://github.com/YunaiV/SpringBoot-Labs/blob/master/lab-52/lab-52-seata-at-httpclient-demo/lab-52-seata-at-httpclient-demo-order-service/"><code>lab-52-seata-at-httpclient-demo-order-service</code></a> 项目，作为<strong>订单</strong>服务。它主要提供 <code>/order/create</code> 接口，实现下单逻辑。</p> 
<blockquote> 
 <p>友情提示：整体内容和<a href="http://www.iocoder.cn/Spring-Boot/Seata/?self#" rel="nofollow">「2.4 订单模块」</a>一致。</p> 
</blockquote> 
<h4>3.2.1 引入依赖</h4> 
<p>创建 <a href="https://github.com/YunaiV/SpringBoot-Labs/blob/master/lab-52/lab-52-seata-at-httpclient-demo/lab-52-seata-at-httpclient-demo-order-service/pom.xml"><code>pom.xml</code></a> 文件，引入相关的依赖。内容如下：</p> 
<pre><code>&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;project xmlns="http://maven.apache.org/POM/4.0.0"
         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"&gt;
    &lt;parent&gt;
        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
        &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt;
        &lt;version&gt;2.2.2.RELEASE&lt;/version&gt;
        &lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt;
    &lt;/parent&gt;
    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;

    &lt;artifactId&gt;lab-52-seata-at-httpclient-demo-account-service&lt;/artifactId&gt;

    &lt;dependencies&gt;
        &lt;!-- 实现对 Spring MVC 的自动化配置 --&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
            &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;
        &lt;/dependency&gt;

        &lt;!-- 实现对数据库连接池的自动化配置 --&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
            &lt;artifactId&gt;spring-boot-starter-jdbc&lt;/artifactId&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt; &lt;!-- 本示例，我们使用 MySQL --&gt;
            &lt;groupId&gt;mysql&lt;/groupId&gt;
            &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;
            &lt;version&gt;5.1.48&lt;/version&gt;
        &lt;/dependency&gt;

        &lt;!-- 实现对 MyBatis 的自动化配置 --&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.mybatis.spring.boot&lt;/groupId&gt;
            &lt;artifactId&gt;mybatis-spring-boot-starter&lt;/artifactId&gt;
            &lt;version&gt;2.1.2&lt;/version&gt;
        &lt;/dependency&gt;

        &lt;!-- 实现对 Seata 的自动化配置 --&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;io.seata&lt;/groupId&gt;
            &lt;artifactId&gt;seata-spring-boot-starter&lt;/artifactId&gt;
            &lt;version&gt;1.1.0&lt;/version&gt;
        &lt;/dependency&gt;
        &lt;!-- 实现 Seata 对 HttpClient 的集成支持  --&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;io.seata&lt;/groupId&gt;
            &lt;artifactId&gt;seata-http&lt;/artifactId&gt;
            &lt;version&gt;1.1.0&lt;/version&gt;
        &lt;/dependency&gt;

        &lt;!-- Apache HttpClient 依赖 --&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.apache.httpcomponents&lt;/groupId&gt;
            &lt;artifactId&gt;httpclient&lt;/artifactId&gt;
            &lt;version&gt;4.5.8&lt;/version&gt;
        &lt;/dependency&gt;
    &lt;/dependencies&gt;

&lt;/project&gt;</code></pre> 
<p>① 引入 <a href="https://mvnrepository.com/artifact/io.seata/seata-spring-boot-starter" rel="nofollow"><code>seata-spring-boot-starter</code></a> 依赖，实现对 Seata 的自动配置。</p> 
<p>② 引入 <a href="https://mvnrepository.com/artifact/io.seata/seata-http" rel="nofollow"><code>seata-http</code></a> 依赖，实现 Seata 对 HttpClient 的集成支持。</p> 
<h4>3.2.2 配置文件</h4> 
<p>创建 <a href="https://github.com/YunaiV/SpringBoot-Labs/blob/master/lab-52/lab-52-seata-at-httpclient-demo/lab-52-seata-at-httpclient-demo-order-service/src/main/resources/application.yaml"><code>application.yaml</code></a> 配置文件，添加相关的配置项。内容如下：</p> 
<pre><code>server:
  port: 8081 # 端口

spring:
  application:
    name: order-service

  datasource:
    url: jdbc:mysql://127.0.0.1:3306/seata_order?useSSL=false&amp;useUnicode=true&amp;characterEncoding=UTF-8
    driver-class-name: com.mysql.jdbc.Driver
    username: root
    password:

# Seata 配置项，对应 SeataProperties 类
seata:
  application-id: ${spring.application.name} # Seata 应用编号，默认为 ${spring.application.name}
  tx-service-group: ${spring.application.name}-group # Seata 事务组编号，用于 TC 集群名
  # 服务配置项，对应 ServiceProperties 类
  service:
    # 虚拟组和分组的映射
    vgroup-mapping:
      order-service-group: default
    # 分组和 Seata 服务的映射
    grouplist:
      default: 127.0.0.1:8091</code></pre> 
<p>① <code>spring.datasource</code> 配置项，设置连接 <code>seata_order</code> 库。</p> 
<p>② <code>seata</code> 配置项，设置 Seata 的配置项目，对应 <a href="https://github.com/seata/seata/blob/develop/seata-spring-boot-starter/src/main/java/io/seata/spring/boot/autoconfigure/properties/SeataProperties.java">SeataProperties</a> 类。</p> 
<ul><li><code>application-id</code> 配置项，对应 Seata 应用编号，默认为 <code>${spring.application.name}</code>。实际上，可以不进行设置。</li><li><code>tx-service-group</code> 配置项，Seata 事务组编号，用于 TC 集群名。</li></ul> 
<p>③ <code>seata.service</code> 配置项，Seata 服务配置项，对应 <a href="https://github.com/seata/seata/blob/develop/seata-spring-boot-starter/src/main/java/io/seata/spring/boot/autoconfigure/properties/file/ServiceProperties.java">ServiceProperties</a> 类。它主要用于 Seata 在事务分组的特殊设计，可见<a href="https://seata.io/zh-cn/docs/user/transaction-group.html" rel="nofollow">《Seata 文档 —— 事务分组专题》</a>。如果不能理解的胖友，可以见如下图：<img alt="分组映射" height="295" src="https://images2.imgbox.com/5a/0e/A7g9QMEY_o.png" width="882"></p> 
<p>简单来说，就是多了一层<strong>虚拟</strong>映射。这里，我们<strong>直接</strong>设置 TC Server 的地址，为 <code>127.0.0.1:8091</code>。</p> 
<h4>3.2.3 OrderController</h4> 
<p>创建 <a href="https://github.com/YunaiV/SpringBoot-Labs/blob/master/lab-52/lab-52-seata-at-httpclient-demo/lab-52-seata-at-httpclient-demo-order-service/src/main/java/cn/iocoder/springboot/lab52/orderservice/controller/OrderController.java">OrderController</a> 类，提供 <code>order/create</code> 下单 HTTP API。代码如下：</p> 
<pre><code class="language-java">@RestController
@RequestMapping("/order")
public class OrderController {

    private Logger logger = LoggerFactory.getLogger(OrderController.class);

    @Autowired
    private OrderService orderService;

    @PostMapping("/create")
    public Integer createOrder(@RequestParam("userId") Long userId,
                               @RequestParam("productId") Long productId,
                               @RequestParam("price") Integer price) throws Exception {
        logger.info("[createOrder] 收到下单请求,用户:{}, 商品:{}, 价格:{}", userId, productId, price);
        return orderService.createOrder(userId, productId, price);
    }

}</code></pre> 
<ul><li>该 API 中，会调用 OrderService 进行下单。</li></ul> 
<blockquote> 
 <p>友情提示：因为这个是示例项目，所以直接传入 <code>price</code> 参数，作为订单的金额，实际肯定不是这样的，哈哈哈~</p> 
</blockquote> 
<h4>3.2.4 OrderService</h4> 
<p>创建 <a href="https://github.com/YunaiV/SpringBoot-Labs/blob/master/lab-52/lab-52-seata-at-httpclient-demo/lab-52-seata-at-httpclient-demo-order-service/src/main/java/cn/iocoder/springboot/lab52/orderservice/service/OrderService.java">OrderService</a> 接口，定义了创建订单的方法。代码如下：</p> 
<pre><code class="language-java">/**
 * 订单 Service
 */
public interface OrderService {

    /**
     * 创建订单
     *
     * @param userId 用户编号
     * @param productId 产品编号
     * @param price 价格
     * @return 订单编号
     * @throws Exception 创建订单失败，抛出异常
     */
    Integer createOrder(Long userId, Long productId, Integer price) throws Exception;

}</code></pre> 
<h4>3.2.5 OrderServiceImpl</h4> 
<p>创建 <a href="https://github.com/YunaiV/SpringBoot-Labs/blob/master/lab-52/lab-52-multiple-datasource/src/main/java/cn/iocoder/springboot/lab52/seatademo/service/impl/OrderServiceImpl.java">OrderServiceImpl</a> 类，实现创建订单的方法。代码如下：</p> 
<pre><code class="language-java">@Service
public class OrderServiceImpl implements OrderService {

    private Logger logger = LoggerFactory.getLogger(getClass());

    @Autowired
    private OrderDao orderDao;

    @Override
    @GlobalTransactional // &lt;1&gt;
    public Integer createOrder(Long userId, Long productId, Integer price) throws Exception {
        Integer amount = 1; // 购买数量，暂时设置为 1。

        logger.info("[createOrder] 当前 XID: {}", RootContext.getXID());

        // &lt;2&gt; 扣减库存
        this.reduceStock(productId, amount);

        // &lt;3&gt; 扣减余额
        this.reduceBalance(userId, price);

        // &lt;4&gt; 保存订单
        OrderDO order = new OrderDO().setUserId(userId).setProductId(productId).setPayAmount(amount * price);
        orderDao.saveOrder(order);
        logger.info("[createOrder] 保存订单: {}", order.getId());

        // 返回订单编号
        return order.getId();
    }
    
    private void reduceStock(Long productId, Integer amount) throws IOException {
        // 参数拼接
        JSONObject params = new JSONObject().fluentPut("productId", String.valueOf(productId))
                .fluentPut("amount", String.valueOf(amount));
        // 执行调用
        HttpResponse response = DefaultHttpExecutor.getInstance().executePost("http://127.0.0.1:8082", "/product/reduce-stock",
                params, HttpResponse.class);
        // 解析结果
        Boolean success = Boolean.valueOf(EntityUtils.toString(response.getEntity()));
        if (!success) {
            throw new RuntimeException("扣除库存失败");
        }
    }

    private void reduceBalance(Long userId, Integer price) throws IOException {
        // 参数拼接
        JSONObject params = new JSONObject().fluentPut("userId", String.valueOf(userId))
                .fluentPut("price", String.valueOf(price));
        // 执行调用
        HttpResponse response = DefaultHttpExecutor.getInstance().executePost("http://127.0.0.1:8083", "/account/reduce-balance",
                params, HttpResponse.class);
        // 解析结果
        Boolean success = Boolean.valueOf(EntityUtils.toString(response.getEntity()));
        if (!success) {
            throw new RuntimeException("扣除余额失败");
        }
    }
}</code></pre> 
<p><code>&lt;1&gt;</code> 处，在类上，添加 Seata <code>@GlobalTransactional</code> 注解，<strong>声明全局事务</strong>。</p> 
<p><code>&lt;2&gt;</code> 处，调用 <code>#reduceStock(productId, amount)</code> 方法，通过 Apache HttpClient 远程 <strong>HTTP</strong> 调用<strong>商品</strong>服务，进行扣除库存。</p> 
<p>其中，<a href="https://github.com/seata/seata/blob/develop/integration/http/src/main/java/io/seata/integration/http/DefaultHttpExecutor.java">DefaultHttpExecutor</a> 是 Seata 封装，在使用个 HttpClient 发起 HTTP 调用时，将 Seata 全局事务 XID 通过 Header 传递。不过有两点要注意：</p> 
<ul><li> <p>在使用 POST 请求时，DefaultHttpExecutor 暂时只支持 <code>application/json</code> 请求参数格式。所以，如果胖友想要 <code>application/x-www-form-urlencoded</code> 等格式，需要自己重新封装~</p> </li><li> <p>针对返回结果的转换，DefaultHttpExecutor 暂时没有实现完成，<a href="https://github.com/seata/seata/blob/develop/integration/http/src/main/java/io/seata/integration/http/DefaultHttpExecutor.java#L111-L119">代码</a>如下图所示：<img alt="实现代码" height="266" src="https://images2.imgbox.com/d3/74/JhNiVOFz_o.png" width="851"></p> 
  <blockquote> 
   <p>艿艿使用的是 Seata 1.1.0 版本，未来这块应该会实现。</p> 
  </blockquote> </li></ul> 
<p>另外，<strong>商品</strong>服务提供的 <code>/product/reduce-stock</code> 接口，通过返回 <code>true</code> 或 <code>false</code> 来表示扣除库存是否成功。因此，我们在 <code>false</code> 扣除失败时，抛出 RuntimeException 异常，从而实现<strong>全局</strong>事务的回滚。</p> 
<p><code>&lt;3&gt;</code> 处，调用 <code>#reduceBalance(userId, price)</code> 方法，通过 Apache HttpClient 远程 <strong>HTTP</strong> 调用<strong>账户</strong>服务，进行扣除余额。整体逻辑和 <code>&lt;2&gt;</code> 一致，就不重复哔哔。</p> 
<p><code>&lt;4&gt;</code> 处，在全部调用成功后，调用 OrderDao 保存订单。</p> 
<h4>3.2.6 OrderDao</h4> 
<p>创建 <a href="https://github.com/YunaiV/SpringBoot-Labs/blob/master/lab-52/lab-52-seata-at-httpclient-demo/lab-52-seata-at-httpclient-demo-order-service/src/main/java/cn/iocoder/springboot/lab52/orderservice/dao/OrderDao.java">OrderDao</a> 接口，定义保存订单的操作。代码如下：</p> 
<pre><code class="language-java">@Mapper
@Repository
public interface OrderDao {

    /**
     * 插入订单记录
     *
     * @param order 订单
     * @return 影响记录数量
     */
    @Insert("INSERT INTO orders (user_id, product_id, pay_amount) VALUES (#{userId}, #{productId}, #{payAmount})")
    @Options(useGeneratedKeys = true, keyColumn = "id", keyProperty = "id")
    int saveOrder(OrderDO order);

}</code></pre> 
<p>其中，<a href="https://github.com/YunaiV/SpringBoot-Labs/blob/master/lab-52/lab-52-seata-at-httpclient-demo/lab-52-seata-at-httpclient-demo-order-service/src/main/java/cn/iocoder/springboot/lab52/orderservice/entity/OrderDO.java">OrderDO</a> <strong>实体</strong>类，对应 <code>orders</code> 表。代码如下： </p> 
<pre><code class="language-java">/**
 * 订单实体
 */
public class OrderDO {

    /** 订单编号 **/
    private Integer id;

    /** 用户编号 **/
    private Long userId;

    /** 产品编号 **/
    private Long productId;

    /** 支付金额 **/
    private Integer payAmount;
    
    // ... 省略 setter/getter 方法
    
}</code></pre> 
<h4>3.2.7 OrderServiceApplication</h4> 
<p>创建 <a href="https://github.com/YunaiV/SpringBoot-Labs/blob/master/lab-52/lab-52-seata-at-httpclient-demo/lab-52-seata-at-httpclient-demo-order-service/src/main/java/cn/iocoder/springboot/lab52/orderservice/OrderServiceApplication.java">OrderServiceApplication</a> 类，用于启动<strong>订单</strong>服务。代码如下：</p> 
<pre><code class="language-java">@SpringBootApplication
public class OrderServiceApplication {

    public static void main(String[] args) {
        SpringApplication.run(OrderServiceApplication.class, args);
    }

}</code></pre> 
<h3>3.3 商品服务</h3> 
<p>新建 <a href="https://github.com/YunaiV/SpringBoot-Labs/blob/master/lab-52/lab-52-seata-at-httpclient-demo/lab-52-seata-at-httpclient-demo-product-service/"><code>lab-52-seata-at-httpclient-demo-product-service</code></a> 项目，作为<strong>商品</strong>服务。它主要提供 <code>/product/reduce-stock</code> 接口，实现扣除商品的库存逻辑。</p> 
<blockquote> 
 <p>友情提示：整体内容和<a href="http://www.iocoder.cn/Spring-Boot/Seata/?self#" rel="nofollow">「2.5 商品模块」</a>一致。</p> 
</blockquote> 
<h4>3.3.1 引入依赖</h4> 
<p>创建 <a href="https://github.com/YunaiV/SpringBoot-Labs/blob/master/lab-52/lab-52-seata-at-httpclient-demo/lab-52-seata-at-httpclient-demo-product-service/pom.xml"><code>pom.xml</code></a> 文件，引入相关的依赖。和<a href="http://www.iocoder.cn/Spring-Boot/Seata/?self#" rel="nofollow">「3.2.1 引入依赖」</a>是一致的，就不重复“贴”出来了，胖友点击 <a href="https://github.com/YunaiV/SpringBoot-Labs/blob/master/lab-52/lab-52-seata-at-httpclient-demo/lab-52-seata-at-httpclient-demo-product-service/pom.xml"><code>pom.xml</code></a> 文件查看。</p> 
<h4>3.3.2 配置文件</h4> 
<p>创建 <a href="https://github.com/YunaiV/SpringBoot-Labs/blob/master/lab-52/lab-52-seata-at-httpclient-demo/lab-52-seata-at-httpclient-demo-product-service/src/main/resources/application.yaml"><code>application.yaml</code></a> 配置文件，添加相关的配置项。和<a href="http://www.iocoder.cn/Spring-Boot/Seata/?self#" rel="nofollow">「3.2.2 配置文件」</a>是一致的，就不重复“贴”出来了，胖友点击 <a href="https://github.com/YunaiV/SpringBoot-Labs/blob/master/lab-52/lab-52-seata-at-httpclient-demo/lab-52-seata-at-httpclient-demo-product-service/src/main/resources/application.yaml"><code>application.yaml</code></a> 文件查看。</p> 
<h4>3.3.3 ProductController</h4> 
<p>创建 <a href="https://github.com/YunaiV/SpringBoot-Labs/blob/master/lab-52/lab-52-seata-at-httpclient-demo/lab-52-seata-at-httpclient-demo-product-service/src/main/java/cn/iocoder/springboot/lab52/productservice/controller/ProductController.java">ProductController</a> 类，提供 <code>/product/reduce-stock</code> 扣除库存 HTTP API。代码如下：</p> 
<pre><code class="language-java">@RestController
@RequestMapping("/product")
public class ProductController {

    private Logger logger = LoggerFactory.getLogger(ProductController.class);

    @Autowired
    private ProductService productService;

    @PostMapping("/reduce-stock")
    public Boolean reduceStock(@RequestBody ProductReduceStockDTO productReduceStockDTO) {
        logger.info("[reduceStock] 收到减少库存请求, 商品:{}, 价格:{}", productReduceStockDTO.getProductId(),
                productReduceStockDTO.getAmount());
        try {
            productService.reduceStock(productReduceStockDTO.getProductId(), productReduceStockDTO.getAmount());
            // 正常扣除库存，返回 true
            return true;
        } catch (Exception e) {
            // 失败扣除库存，返回 false
            return false;
        }
    }

}</code></pre> 
<ul><li>该 API 中，会调用 ProductService 进行扣除库存，最终通过返回结果为 <code>true</code> 或者 <code>false</code>，表示扣除库存成功或是失败。</li></ul> 
<p>其中，<a href="https://github.com/YunaiV/SpringBoot-Labs/blob/master/lab-52/lab-52-seata-at-httpclient-demo/lab-52-seata-at-httpclient-demo-product-service/src/main/java/cn/iocoder/springboot/lab52/productservice/dto/ProductReduceStockDTO.java">ProductReduceStockDTO</a> 为商品减少库存 DTO 类，代码如下：</p> 
<pre><code class="language-java">public class ProductReduceStockDTO {

    /**
     * 商品编号
     */
    private Long productId;
    /**
     * 数量
     */
    private Integer amount;
    
    // ... 省略 setter/getter 方法
    
}</code></pre> 
<h4>3.3.4 ProductService</h4> 
<p>创建 <a href="https://github.com/YunaiV/SpringBoot-Labs/blob/master/lab-52/lab-52-seata-at-httpclient-demo/lab-52-seata-at-httpclient-demo-product-service/src/main/java/cn/iocoder/springboot/lab52/productservice/service/ProductService.java">ProductService</a> 接口，定义了扣除库存的方法。代码如下：</p> 
<pre><code class="language-java">/**
 * 商品 Service
 */
public interface ProductService {

    /**
     * 扣减库存
     *
     * @param productId 商品 ID
     * @param amount    扣减数量
     * @throws Exception 扣减失败时抛出异常
     */
    void reduceStock(Long productId, Integer amount) throws Exception;

}</code></pre> 
<h4>3.3.5 ProductServiceImpl</h4> 
<p>创建 <a href="https://github.com/YunaiV/SpringBoot-Labs/blob/master/lab-52/lab-52-seata-at-httpclient-demo/lab-52-seata-at-httpclient-demo-product-service/src/main/java/cn/iocoder/springboot/lab52/productservice/service/ProductServiceImpl.java">ProductServiceImpl</a> 类，实现扣减库存的方法。代码如下：</p> 
<pre><code class="language-java">@Service
public class ProductServiceImpl implements ProductService {

    private Logger logger = LoggerFactory.getLogger(getClass());

    @Autowired
    private ProductDao productDao;

    @Override
    @Transactional // &lt;1&gt; 开启新事物
    public void reduceStock(Long productId, Integer amount) throws Exception {
        logger.info("[reduceStock] 当前 XID: {}", RootContext.getXID());

        // &lt;2&gt; 检查库存
        checkStock(productId, amount);

        logger.info("[reduceStock] 开始扣减 {} 库存", productId);
        // &lt;3&gt; 扣减库存
        int updateCount = productDao.reduceStock(productId, amount);
        // 扣除成功
        if (updateCount == 0) {
            logger.warn("[reduceStock] 扣除 {} 库存失败", productId);
            throw new Exception("库存不足");
        }
        // 扣除失败
        logger.info("[reduceStock] 扣除 {} 库存成功", productId);
    }

    private void checkStock(Long productId, Integer requiredAmount) throws Exception {
        logger.info("[checkStock] 检查 {} 库存", productId);
        Integer stock = productDao.getStock(productId);
        if (stock &lt; requiredAmount) {
            logger.warn("[checkStock] {} 库存不足，当前库存: {}", productId, stock);
            throw new Exception("库存不足");
        }
    }

}</code></pre> 
<p><code>&lt;1&gt;</code> 处，在类上，添加了 Spring <code>@Transactional</code> 注解，<strong>声明本地事务</strong>。也就是说，此处会开启一个 <code>seata_product</code> 库的数据库事务。</p> 
<p><code>&lt;2&gt;</code> 处，检查库存是否足够，如果不够则抛出 Exception 异常。因为我们需要通过异常，回滚全局异常。</p> 
<p><code>&lt;3&gt;</code> 处，进行扣除库存，如果扣除失败则抛出 Exception 异常。</p> 
<h4>3.3.6 ProductDao</h4> 
<p>创建 <a href="https://github.com/YunaiV/SpringBoot-Labs/blob/master/lab-52/lab-52-seata-at-httpclient-demo/lab-52-seata-at-httpclient-demo-product-service/src/main/java/cn/iocoder/springboot/lab52/productservice/dao/ProductDao.java">ProductDao</a> 接口，定义获取和扣除库存的操作。代码如下：</p> 
<pre><code class="language-java">@Mapper
@Repository
public interface ProductDao {

    /**
     * 获取库存
     *
     * @param productId 商品编号
     * @return 库存
     */
    @Select("SELECT stock FROM product WHERE id = #{productId}")
    Integer getStock(@Param("productId") Long productId);

    /**
     * 扣减库存
     *
     * @param productId 商品编号
     * @param amount    扣减数量
     * @return 影响记录行数
     */
    @Update("UPDATE product SET stock = stock - #{amount} WHERE id = #{productId} AND stock &gt;= #{amount}")
    int reduceStock(@Param("productId") Long productId, @Param("amount") Integer amount);

}</code></pre> 
<h4>3.3.7 ProductServiceApplication</h4> 
<p>创建 <a href="https://github.com/YunaiV/SpringBoot-Labs/blob/master/lab-52/lab-52-seata-at-httpclient-demo/lab-52-seata-at-httpclient-demo-product-service/src/main/java/cn/iocoder/springboot/lab52/productservice/ProductServiceApplication.java">ProductServiceApplication</a> 类，用于启动<strong>商品</strong>服务。代码如下：</p> 
<pre><code class="language-java">@SpringBootApplication
public class ProductServiceApplication {

    public static void main(String[] args) {
        SpringApplication.run(ProductServiceApplication.class, args);
    }

}</code></pre> 
<h3>3.4 账户服务</h3> 
<p>新建 <a href="https://github.com/YunaiV/SpringBoot-Labs/blob/master/lab-52/lab-52-seata-at-httpclient-demo/lab-52-seata-at-httpclient-demo-account-service/"><code>lab-52-seata-at-httpclient-demo-account-service</code></a> 项目，作为<strong>账户</strong>服务。它主要提供 <code>/account/reduce-balance</code> 接口，实现扣除账户的余额逻辑。</p> 
<blockquote> 
 <p>友情提示：整体内容和<a href="http://www.iocoder.cn/Spring-Boot/Seata/?self#" rel="nofollow">「2.5 账户模块」</a>一致。</p> 
</blockquote> 
<h4>3.4.1 引入依赖</h4> 
<p>创建 <a href="https://github.com/YunaiV/SpringBoot-Labs/blob/master/lab-52/lab-52-seata-at-httpclient-demo/lab-52-seata-at-httpclient-demo-account-service/pom.xml"><code>pom.xml</code></a> 文件，引入相关的依赖。和<a href="http://www.iocoder.cn/Spring-Boot/Seata/?self#" rel="nofollow">「3.2.1 引入依赖」</a>是一致的，就不重复“贴”出来了，胖友点击 <a href="https://github.com/YunaiV/SpringBoot-Labs/blob/master/lab-52/lab-52-seata-at-httpclient-demo/lab-52-seata-at-httpclient-demo-account-service/pom.xml"><code>pom.xml</code></a> 文件查看。</p> 
<h4>3.4.2 配置文件</h4> 
<p>创建 <a href="https://github.com/YunaiV/SpringBoot-Labs/blob/master/lab-52/lab-52-seata-at-httpclient-demo/lab-52-seata-at-httpclient-demo-account-service/src/main/resources/application.yaml"><code>application.yaml</code></a> 配置文件，添加相关的配置项。和<a href="http://www.iocoder.cn/Spring-Boot/Seata/?self#" rel="nofollow">「3.2.2 配置文件」</a>是一致的，就不重复“贴”出来了，胖友点击 <a href="https://github.com/YunaiV/SpringBoot-Labs/blob/master/lab-52/lab-52-seata-at-httpclient-demo/lab-52-seata-at-httpclient-demo-account-service/src/main/resources/application.yaml"><code>application.yaml</code></a> 文件查看。</p> 
<h4>3.4.3 AccountController</h4> 
<p>创建 <a href="https://github.com/YunaiV/SpringBoot-Labs/blob/master/lab-52/lab-52-seata-at-httpclient-demo/lab-52-seata-at-httpclient-demo-account-service/src/main/java/cn/iocoder/springboot/lab52/accountservice/controller/AccountController.java">AccountController</a> 类，提供 <code>/account/reduce-balance</code> 扣除余额 HTTP API。代码如下：</p> 
<pre><code class="language-java">@RestController
@RequestMapping("/account")
public class AccountController {

    private Logger logger = LoggerFactory.getLogger(AccountController.class);

    @Autowired
    private AccountService accountService;

    @PostMapping("/reduce-balance")
    public Boolean reduceBalance(@RequestBody AccountReduceBalanceDTO accountReduceBalanceDTO) {
        logger.info("[reduceBalance] 收到减少余额请求, 用户:{}, 金额:{}", accountReduceBalanceDTO.getUserId(),
                accountReduceBalanceDTO.getPrice());
        try {
            accountService.reduceBalance(accountReduceBalanceDTO.getUserId(), accountReduceBalanceDTO.getPrice());
            // 正常扣除余额，返回 true
            return true;
        } catch (Exception e) {
            // 失败扣除余额，返回 false
            return false;
        }
    }

}</code></pre> 
<ul><li>该 API 中，会调用 AccountService 进行扣除余额，最终通过返回结果为 <code>true</code> 或者 <code>false</code>，表示扣除余额成功或是失败。</li></ul> 
<p>其中，<a href="https://github.com/YunaiV/SpringBoot-Labs/blob/master/lab-52/lab-52-seata-at-httpclient-demo/lab-52-seata-at-httpclient-demo-account-service/src/main/java/cn/iocoder/springboot/lab52/accountservice/dto/AccountReduceBalanceDTO.java">AccountReduceBalanceDTO</a> 为账户减少余额 DTO 类，代码如下：</p> 
<pre><code class="language-java">public class AccountReduceBalanceDTO {

    /**
     * 用户编号
     */
    private Long userId;

    /**
     * 扣减金额
     */
    private Integer price;

    public Long getUserId() {
        return userId;
    }
    
    // ... 省略 setter/getter 方法
    
}</code></pre> 
<h4>3.4.4 AccountService</h4> 
<p>创建 <a href="https://github.com/YunaiV/SpringBoot-Labs/blob/master/lab-52/lab-52-seata-at-httpclient-demo/lab-52-seata-at-httpclient-demo-account-service/src/main/java/cn/iocoder/springboot/lab52/accountservice/service/AccountService.java">AccountService</a> 类，定义扣除余额的方法。代码如下：</p> 
<pre><code class="language-java">/**
 * 账户 Service
 */
public interface AccountService {

    /**
     * 扣除余额
     *
     * @param userId 用户编号
     * @param price  扣减金额
     * @throws Exception 失败时抛出异常
     */
    void reduceBalance(Long userId, Integer price) throws Exception;

}</code></pre> 
<h4>3.4.5 AccountServiceImpl</h4> 
<p>创建 <a href="https://github.com/YunaiV/SpringBoot-Labs/blob/master/lab-52/lab-52-multiple-datasource/src/main/java/cn/iocoder/springboot/lab52/seatademo/service/impl/AccountServiceImpl.java">AccountServiceImpl</a> 类，实现扣除余额的方法。代码如下：</p> 
<pre><code class="language-java">@Service
public class AccountServiceImpl implements AccountService {

    private Logger logger = LoggerFactory.getLogger(getClass());

    @Autowired
    private AccountDao accountDao;

    @Override
    @Transactional(propagation = Propagation.REQUIRES_NEW) // &lt;1&gt; 开启新事物
    public void reduceBalance(Long userId, Integer price) throws Exception {
        logger.info("[reduceBalance] 当前 XID: {}", RootContext.getXID());

        // &lt;2&gt; 检查余额
        checkBalance(userId, price);

        logger.info("[reduceBalance] 开始扣减用户 {} 余额", userId);
        // &lt;3&gt; 扣除余额
        int updateCount = accountDao.reduceBalance(price);
        // 扣除成功
        if (updateCount == 0) {
            logger.warn("[reduceBalance] 扣除用户 {} 余额失败", userId);
            throw new Exception("余额不足");
        }
        logger.info("[reduceBalance] 扣除用户 {} 余额成功", userId);
    }

    private void checkBalance(Long userId, Integer price) throws Exception {
        logger.info("[checkBalance] 检查用户 {} 余额", userId);
        Integer balance = accountDao.getBalance(userId);
        if (balance &lt; price) {
            logger.warn("[checkBalance] 用户 {} 余额不足，当前余额:{}", userId, balance);
            throw new Exception("余额不足");
        }
    }

}</code></pre> 
<p><code>&lt;1&gt;</code> 处，在类上，添加了 Spring <code>@Transactional</code> 注解，<strong>声明本地事务</strong>。也就是说，此处会开启一个 <code>seata_account</code> 库的数据库事务。</p> 
<p><code>&lt;2&gt;</code> 处，检查余额是否足够，如果不够则抛出 Exception 异常。因为我们需要通过异常，回滚全局异常。</p> 
<p><code>&lt;3&gt;</code> 处，进行扣除余额，如果扣除失败则抛出 Exception 异常。</p> 
<h4>3.4.6 AccountDao</h4> 
<p>创建 <a href="https://github.com/YunaiV/SpringBoot-Labs/blob/master/lab-52/lab-52-seata-at-httpclient-demo/lab-52-seata-at-httpclient-demo-account-service/src/main/java/cn/iocoder/springboot/lab52/accountservice/dao/AccountDao.java">AccountDao</a> 接口，定义查询和扣除余额的操作。代码如下：</p> 
<pre><code class="language-java">@Mapper
@Repository
public interface AccountDao {

    /**
     * 获取账户余额
     *
     * @param userId 用户 ID
     * @return 账户余额
     */
    @Select("SELECT balance FROM account WHERE id = #{userId}")
    Integer getBalance(@Param("userId") Long userId);

    /**
     * 扣减余额
     *
     * @param price 需要扣减的数目
     * @return 影响记录行数
     */
    @Update("UPDATE account SET balance = balance - #{price} WHERE id = 1 AND balance &gt;= ${price}")
    int reduceBalance(@Param("price") Integer price);

}</code></pre> 
<h4>3.4.7 AccountServiceApplication</h4> 
<p>创建 <a href="https://github.com/YunaiV/SpringBoot-Labs/blob/master/lab-52/lab-52-seata-at-httpclient-demo/lab-52-seata-at-httpclient-demo-account-service/src/main/java/cn/iocoder/springboot/lab52/accountservice/AccountServiceApplication.java">AccountServiceApplication</a> 类，用于启动<strong>商品</strong>服务。代码如下：</p> 
<pre><code class="language-java">@SpringBootApplication
public class AccountServiceApplication {

    public static void main(String[] args) {
        SpringApplication.run(AccountServiceApplication.class, args);
    }

}</code></pre> 
<h3>3.5 简单测试</h3> 
<p>下面，我们将测试两种情况：</p> 
<ol><li>分布式事务正常提交</li><li>分布式事务异常回滚</li></ol> 
<p><strong>Debug</strong> 执行 <strong>Order</strong>ServiceApplication 启动<strong>订单</strong>服务。此时，我们可以看到 Seata 相关日志如下：</p> 
<blockquote> 
 <p>友情提示：日志的顺序，艿艿做了简单的整理，为了更容易阅读。</p> 
</blockquote> 
<pre><code># ... 上面还有 Seata 相关 Bean 初始化的日志，忘记加进来了，嘿嘿~

# 给数据源增加 Seata 的数据源代理
2020-04-05 10:51:00.687  INFO 52124 --- [           main] s.s.a.d.SeataDataSourceBeanPostProcessor : Auto proxy of [dataSource]
2020-04-05 10:51:00.688  INFO 52124 --- [           main] com.zaxxer.hikari.HikariDataSource       : HikariPool-1 - Starting...
2020-04-05 10:51:00.833  INFO 52124 --- [           main] com.zaxxer.hikari.HikariDataSource       : HikariPool-1 - Start completed.
# 加载 Druid 提供的 SQL 解析器
2020-04-05 10:51:00.881  INFO 52124 --- [           main] i.s.common.loader.EnhancedServiceLoader  : load DbTypeParser[druid] extension by class[io.seata.sqlparser.druid.DruidDelegatingDbTypeParser]
# 连接到 Seata TC Server 服务器
2020-04-05 10:51:00.892  INFO 52124 --- [           main] i.s.c.r.netty.NettyClientChannelManager  : will connect to 127.0.0.1:8091
2020-04-05 10:51:00.893  INFO 52124 --- [           main] i.s.core.rpc.netty.NettyPoolableFactory  : NettyPool create channel to transactionRole:RMROLE,address:127.0.0.1:8091,msg:&lt; RegisterRMRequest{resourceIds='jdbc:mysql://127.0.0.1:3306/seata_order', applicationId='order-service', transactionServiceGroup='order-service-group'} &gt;
# 加载 Seata 序列化器
2020-04-05 10:51:01.042  INFO 52124 --- [lector_RMROLE_1] i.s.common.loader.EnhancedServiceLoader  : load Serializer[SEATA] extension by class[io.seata.serializer.seata.SeataSerializer]
# 注册 Seata Resource Manager 到 Seata TC Server 成功 
2020-04-05 10:51:00.892  INFO 52124 --- [           main] io.seata.core.rpc.netty.RmRpcClient      : RM will register :jdbc:mysql://127.0.0.1:3306/seata_order
2020-04-05 10:51:01.054  INFO 52124 --- [           main] io.seata.core.rpc.netty.RmRpcClient      : register RM success. server version:1.1.0,channel:[id: 0xc7553923, L:/127.0.0.1:64449 - R:/127.0.0.1:8091]
2020-04-05 10:51:01.061  INFO 52124 --- [           main] i.s.core.rpc.netty.NettyPoolableFactory  : register success, cost 34 ms, version:1.1.0,role:RMROLE,channel:[id: 0xc7553923, L:/127.0.0.1:64449 - R:/127.0.0.1:8091]
# 因为 OrderServiceImpl 添加了 `@GlobalTransactional` 注解，所以创建其代理，用于全局事务。
2020-04-05 10:51:01.157  INFO 52124 --- [           main] i.s.s.a.GlobalTransactionScanner         : Bean[cn.iocoder.springboot.lab52.orderservice.service.OrderServiceImpl] with name [orderServiceImpl] would use interceptor [io.seata.spring.annotation.GlobalTransactionalInterceptor]</code></pre> 
<p>执行 <strong>Product</strong>ServiceApplication 启动<strong>商品</strong>服务。相关的日志，胖友自己瞅瞅。<br> 执行 <strong>Account</strong>ServiceApplication 启动<strong>账户</strong>服务。相关的日志，胖友自己瞅瞅。</p> 
<h4>3.5.1 正常流程</h4> 
<p>① 先查询下目前数据库的数据情况。如下图所示：<img alt="数据库 - 初始" src="https://images2.imgbox.com/3c/c5/RTM49KEP_o.png"></p> 
<p>② 使用 Postman 模拟调用 <a href="http://127.0.0.1:8081/order/create" rel="nofollow">http://127.0.0.1:8081/order/create</a> 创建订单的接口，如下图所示：<img alt="Postman" height="322" src="https://images2.imgbox.com/65/da/C05w81jQ_o.png" width="897"></p> 
<p>此时，在控制台打印日志如下图所示：</p> 
<ul><li><strong>订单</strong>服务：<img alt="执行日志" src="https://images2.imgbox.com/27/e8/1AbAsILY_o.png"></li><li><strong>商品</strong>服务：<img alt="执行日志" src="https://images2.imgbox.com/04/08/WAHFkvns_o.png"></li><li><strong>账户</strong>服务：<img alt="执行日志" src="https://images2.imgbox.com/41/e5/KDh9Gxqn_o.png"></li></ul> 
<p>再查询下目前数据库的数据情况。如下图所示：<img alt="数据库 - 结果" src="https://images2.imgbox.com/12/47/4GZ9Zpor_o.png"></p> 
<h4>3.5.2 异常流程</h4> 
<p>① 先查询下目前数据库的数据情况。如下图所示：<img alt="数据库 - 结果" src="https://images2.imgbox.com/53/27/clfoxc57_o.png"></p> 
<p>② 在 OrderServiceImpl 的 <code>#createOrder(...)</code> 方法上，打上断点如下图，方便我们看到 <code>product</code> 表的 <code>balance</code> 被减少：<img alt="断点" src="https://images2.imgbox.com/7c/ff/ZPtJO9fr_o.png"></p> 
<blockquote> 
 <p>友情提示：这里忘记截图了，稍后 IDEA 停留在该断点时，胖友可以去查询 <code>product</code> 表，会发现 <code>balance</code> 已经减少。</p> 
</blockquote> 
<p>③ 使用 Postman 模拟调用 <a href="http://127.0.0.1:8081/order/create" rel="nofollow">http://127.0.0.1:8081/order/create</a> 创建订单的接口，如下图所示：<img alt="Postman" src="https://images2.imgbox.com/d3/2b/g1rxBefJ_o.png"></p> 
<p>此时，在控制台打印日志如下图所示：</p> 
<ul><li><strong>订单</strong>服务：<img alt="执行日志" src="https://images2.imgbox.com/29/01/mhh9Dk9T_o.png"></li><li><strong>商品</strong>服务：<img alt="执行日志" src="https://images2.imgbox.com/b8/7c/qLRnXsYC_o.png"></li><li><strong>账户</strong>服务：<img alt="执行日志" src="https://images2.imgbox.com/9b/72/8xsYz58Z_o.png"></li></ul> 
<p>再查询下目前数据库的数据情况。如下图所示：<img alt="数据库 - 结果" src="https://images2.imgbox.com/a9/cc/YkJKlHJo_o.png"></p> 
<p> </p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/a3d5a904524dae512b3c322437385208/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">html中的details与summary</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/8ea0df45a05343ca623d23a4a048abb7/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">Spring源码分析-从源码看BeanFactory和FactoryBean的区别</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>