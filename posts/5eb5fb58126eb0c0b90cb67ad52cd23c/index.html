<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Lua闭包简述 - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Lua闭包简述" />
<meta property="og:description" content="Lua闭包简述 前言 最近工作上比较忙，没有太多时间来进行学习和总结，有点难受。
由于最近接触这一块比较多，所以赶紧忙里偷闲总结一篇闭包相关的笔记。
基本概念 首先我们必须知道，闭包是什么？
简而言之，闭包就是一个环境，一个能够访问外部声明的变量和方法的环境。
举个简单的小例子：
local a = 100 local function f() a = 200 end 上面的代码中，f方法访问了外部的变量a，f方法就是一个闭包或者说闭包函数。
这里的变量a，也就是所谓的上值（upvalue）。
原理 外部变量是如何调到的呢？这一部分最终在内存中存的到底是什么东西呢？
当Lua编译一个函数的时候，它会对应地生成一个原型prototype。这个prototype中所包含的有函数的虚拟机指令、函数用到的常量和一些调试用的信息。
而当Lua执行一个函数，即运行一个 function … end 的时候都会产生一个闭包closure，每个闭包都会有一个对应的prototype引用和存放upvalue引用的数组。
至于闭包的环境，在Lua 5.2之前，闭包中还存在一个对闭包所在环境的引用；在Lua 5.2之后，闭包环境通过 _ENV 变量来进行配置。
那么闭包是如何通过upvalue来访问外部变量的呢？
upvalue本质上也是一个数据结构，其中包含一个指向栈变量的指针、包含一个存储复制值的空间和一个指向下一个upvalue的next指针。当栈上的变量离开作用域被释放时，upvalue会把栈上的值复制一份到自己的结构中，同时让指针由指向原来的栈变量的空间转为指向自己的空间。每个变量最多只会创建一个upvalue。
这种机制解决了变量离开作用域就会被释放从而无法再访问的问题，其实本质上确实是无法再被访问到了，闭包只是通过把值复制了一份才得以继续访问。这也就是我们常说的闭包中内存泄漏的部分，内存泄漏泄漏的其实不是栈上原变量的那部分内存，而是upvalue中的那部分内存。但实际上Lua对于这种“被关闭”的upvalue，如果检测到其不再被任何闭包所引用，那么它的存储空间将被回收。所以精确地说，闭包中很可能出现内存泄漏，但不一定。只要处理得当就不会发生。
正常来说，每当我们创建一个变量时，都会存放在Lua栈上。当一个闭包尝试访问外部变量时，就会先在存放upvalue引用的数组中找到对应的upvalue，然后通过upvalue来返回想要获取的值。
（图片参考）
优势 1、可以让外部变量或方法能够被访问，或者说提供访问其他函数内部变量的环境。
2、可以让变量不被随意修改、污染，即起到保护和封装作用。比如说，可以通过闭包实现get和set方法来对一个变量进行操作，而不是直接对变量进行赋值：
例一：
local getA local setA local function initA() local a getA = function() return a end setA = function(value) a = value end end initA() setA(100) print(getA()) 例二：" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/5eb5fb58126eb0c0b90cb67ad52cd23c/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2021-08-26T22:54:32+08:00" />
<meta property="article:modified_time" content="2021-08-26T22:54:32+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Lua闭包简述</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <h3><a id="Lua_0"></a>Lua闭包简述</h3> 
<hr> 
<h4><a id="_4"></a>前言</h4> 
<p>最近工作上比较忙，没有太多时间来进行学习和总结，有点难受。</p> 
<p>由于最近接触这一块比较多，所以赶紧忙里偷闲总结一篇闭包相关的笔记。</p> 
<br> 
<h4><a id="_12"></a>基本概念</h4> 
<p>首先我们必须知道，闭包是什么？</p> 
<p>简而言之，闭包就是一个环境，一个能够访问外部声明的变量和方法的环境。</p> 
<p>举个简单的小例子：</p> 
<pre><code class="prism language-lua"><span class="token keyword">local</span> a <span class="token operator">=</span> <span class="token number">100</span>

<span class="token keyword">local</span> <span class="token keyword">function</span> <span class="token function">f</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
	a <span class="token operator">=</span> <span class="token number">200</span>    
<span class="token keyword">end</span>
</code></pre> 
<p>上面的代码中，f方法访问了外部的变量a，f方法就是一个闭包或者说闭包函数。</p> 
<p>这里的变量a，也就是所谓的上值（upvalue）。</p> 
<br> 
<h4><a id="_34"></a>原理</h4> 
<p>外部变量是如何调到的呢？这一部分最终在内存中存的到底是什么东西呢？</p> 
<p>当Lua编译一个函数的时候，它会对应地生成一个原型prototype。这个prototype中所包含的有函数的虚拟机指令、函数用到的常量和一些调试用的信息。</p> 
<p>而当Lua执行一个函数，即运行一个 function … end 的时候都会产生一个闭包closure，每个闭包都会有一个对应的prototype引用和存放upvalue引用的数组。</p> 
<p>至于闭包的环境，在Lua 5.2之前，闭包中还存在一个对闭包所在环境的引用；在Lua 5.2之后，闭包环境通过 _ENV 变量来进行配置。</p> 
<p>那么闭包是如何通过upvalue来访问外部变量的呢？</p> 
<p>upvalue本质上也是一个数据结构，其中包含一个指向栈变量的指针、包含一个存储复制值的空间和一个指向下一个upvalue的next指针。当栈上的变量离开作用域被释放时，upvalue会把栈上的值复制一份到自己的结构中，同时让指针由指向原来的栈变量的空间转为指向自己的空间。每个变量最多只会创建一个upvalue。</p> 
<p>这种机制解决了变量离开作用域就会被释放从而无法再访问的问题，其实本质上确实是无法再被访问到了，闭包只是通过把值复制了一份才得以继续访问。这也就是我们常说的闭包中内存泄漏的部分，内存泄漏泄漏的其实不是栈上原变量的那部分内存，而是upvalue中的那部分内存。但实际上Lua对于这种“被关闭”的upvalue，如果检测到其不再被任何闭包所引用，那么它的存储空间将被回收。所以精确地说，闭包中很可能出现内存泄漏，但不一定。只要处理得当就不会发生。</p> 
<p>正常来说，每当我们创建一个变量时，都会存放在Lua栈上。当一个闭包尝试访问外部变量时，就会先在存放upvalue引用的数组中找到对应的upvalue，然后通过upvalue来返回想要获取的值。</p> 
<p><img src="https://images2.imgbox.com/5b/c0/fD1TdFnQ_o.png" alt="在这里插入图片描述"></p> 
<p>（图片<a href="https://blog.csdn.net/sbddbfm/article/details/94424695?utm_medium=distribute.pc_relevant.none-task-blog-2~default~baidujs_baidulandingword~default-0.essearch_pc_relevant&amp;spm=1001.2101.3001.4242">参考</a>）</p> 
<br> 
<h4><a id="_58"></a>优势</h4> 
<p>1、可以让外部变量或方法能够被访问，或者说提供访问其他函数内部变量的环境。</p> 
<p>2、可以让变量不被随意修改、污染，即起到保护和封装作用。比如说，可以通过闭包实现get和set方法来对一个变量进行操作，而不是直接对变量进行赋值：</p> 
<p>例一：</p> 
<pre><code class="prism language-lua"><span class="token keyword">local</span> getA
<span class="token keyword">local</span> setA
<span class="token keyword">local</span> <span class="token keyword">function</span> <span class="token function">initA</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token keyword">local</span> a
    getA <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
        <span class="token keyword">return</span> a
    <span class="token keyword">end</span>
    setA <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span>
        a <span class="token operator">=</span> value
    <span class="token keyword">end</span>
<span class="token keyword">end</span>

<span class="token function">initA</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token function">setA</span><span class="token punctuation">(</span><span class="token number">100</span><span class="token punctuation">)</span>
<span class="token function">print</span><span class="token punctuation">(</span><span class="token function">getA</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
</code></pre> 
<p>例二：</p> 
<pre><code class="prism language-lua"><span class="token keyword">local</span> <span class="token keyword">function</span> <span class="token function">init</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token keyword">local</span> count <span class="token operator">=</span> <span class="token number">0</span>
    <span class="token keyword">return</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
        count <span class="token operator">=</span> count <span class="token operator">+</span> <span class="token number">1</span>
        <span class="token keyword">return</span> count
    <span class="token keyword">end</span>
<span class="token keyword">end</span>

<span class="token keyword">local</span> f <span class="token operator">=</span> <span class="token function">init</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token function">print</span><span class="token punctuation">(</span><span class="token function">f</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment">-- 输出1</span>
<span class="token function">print</span><span class="token punctuation">(</span><span class="token function">f</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment">-- 输出2</span>
<span class="token function">print</span><span class="token punctuation">(</span><span class="token function">f</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment">-- 输出3</span>
<span class="token keyword">local</span> g <span class="token operator">=</span> <span class="token function">init</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token function">print</span><span class="token punctuation">(</span><span class="token function">g</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment">-- 输出1</span>
<span class="token function">print</span><span class="token punctuation">(</span><span class="token function">g</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment">-- 输出2</span>
<span class="token function">print</span><span class="token punctuation">(</span><span class="token function">g</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment">-- 输出3</span>
</code></pre> 
<p>在上面两个例子中，巧妙使用闭包，非常好地实现了封装性。</p> 
<br> 
<h4><a id="_109"></a>劣势</h4> 
<p>为什么说使用闭包耗？闭包它耗在哪了呢？</p> 
<p>一是耗在内存上，因为使用闭包会很容易产生内存泄漏。</p> 
<p>就比如上面两个例子，被封装起来的变量一直不会被释放，导致内存有一块空间被长期占用，产生内存泄漏。简单来说，就是闭包中的局部变量会常驻内存，从而产生内存泄漏。</p> 
<p>那么如何解决闭包容易产生的内存泄露问题呢？——主动释放闭包引用到的变量。</p> 
<p>举个例子，一看就明白：</p> 
<pre><code class="prism language-lua"><span class="token keyword">function</span> <span class="token function">f</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
   <span class="token keyword">local</span> a <span class="token operator">=</span> <span class="token number">0</span>
    <span class="token keyword">return</span> <span class="token keyword">function</span> <span class="token function">g</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
        a <span class="token operator">=</span> a <span class="token operator">+</span> <span class="token number">1</span>
        <span class="token function">print</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span>
    <span class="token keyword">end</span>
    a <span class="token operator">=</span> <span class="token keyword">nil</span> <span class="token comment">-- 主动释放闭包引用到的变量</span>
<span class="token keyword">end</span>
</code></pre> 
<p>二是耗在调用和交互上，在C#和Lua的交互过程中，频繁地函数传递会导致delegate被频繁创建和管理。举个例子，在Lua做按钮事件交互的时候很多时候会把一个匿名函数当参数传过去。实际上是非常耗的。而且还要记得及时反注册C#的delegate，否则会发生内存泄漏。</p> 
<p>解决方法有很多，比如可以通过监听收发事件来代替函数传参。</p> 
<br> 
<h4><a id="_140"></a>应用</h4> 
<p>1、高阶函数，如table.sort类似的函数；</p> 
<p>2、创建其他函数的函数；</p> 
<p>3、做匿名回调函数；</p> 
<p>4、创建安全的运行环境，即所谓的沙盒；</p> 
<p>5、实现迭代器。</p> 
<br> 
<h4><a id="_154"></a>小结</h4> 
<p>闭包这些概念看上去简单，但是深究起来还是有很多东西可以探讨的。</p> 
<p>学就完事了。</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/bb44ddcaca3a786a7a9ef8ca28d733ad/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">19、计算机图形学——蒙特卡洛路径追踪</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/c8923ca3634f3a752234a15cd7e27241/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">MySQL怎么存储表情</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>