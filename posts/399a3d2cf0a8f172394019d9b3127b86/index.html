<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>并查集&#43;巧妙分块，Codeforces1424B. 0-1 MST - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="并查集&#43;巧妙分块，Codeforces1424B. 0-1 MST" />
<meta property="og:description" content="目录
一、题目
1、题目描述
2、输入输出
2.1输入
2.2输出
3、原题链接
二、解题报告
1、思路分析
2、复杂度
3、代码详解
一、题目
1、题目描述 Ujan has a lot of useless stuff in his drawers, a considerable part of which are his math notebooks: it is time to sort them out. This time he found an old dusty graph theory notebook with a description of a graph.
It is an undirected weighted graph on n vertices. It is a complete graph: each pair of vertices is connected by an edge." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/399a3d2cf0a8f172394019d9b3127b86/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2024-01-30T01:01:27+08:00" />
<meta property="article:modified_time" content="2024-01-30T01:01:27+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">并查集&#43;巧妙分块，Codeforces1424B. 0-1 MST</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p id="main-toc"><strong>目录</strong></p> 
<p id="-toc" style="margin-left:40px;"></p> 
<p id="%E4%B8%80%E3%80%81%E9%A2%98%E7%9B%AE-toc" style="margin-left:40px;"><a href="#%E4%B8%80%E3%80%81%E9%A2%98%E7%9B%AE" rel="nofollow">一、题目</a></p> 
<p id="1%E3%80%81%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0-toc" style="margin-left:80px;"><a href="#1%E3%80%81%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0" rel="nofollow">1、题目描述</a></p> 
<p id="2%E3%80%81%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA-toc" style="margin-left:80px;"><a href="#2%E3%80%81%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA" rel="nofollow">2、输入输出</a></p> 
<p id="2.1%E8%BE%93%E5%85%A5-toc" style="margin-left:120px;"><a href="#2.1%E8%BE%93%E5%85%A5" rel="nofollow">2.1输入</a></p> 
<p id="2.2%E8%BE%93%E5%87%BA-toc" style="margin-left:120px;"><a href="#2.2%E8%BE%93%E5%87%BA" rel="nofollow">2.2输出</a></p> 
<p id="3%E3%80%81%E5%8E%9F%E9%A2%98%E9%93%BE%E6%8E%A5-toc" style="margin-left:80px;"><a href="#3%E3%80%81%E5%8E%9F%E9%A2%98%E9%93%BE%E6%8E%A5" rel="nofollow">3、原题链接</a></p> 
<p id="%E4%BA%8C%E3%80%81%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8A-toc" style="margin-left:40px;"><a href="#%E4%BA%8C%E3%80%81%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8A" rel="nofollow">二、解题报告</a></p> 
<p id="1%E3%80%81%E6%80%9D%E8%B7%AF%E5%88%86%E6%9E%90-toc" style="margin-left:80px;"><a href="#1%E3%80%81%E6%80%9D%E8%B7%AF%E5%88%86%E6%9E%90" rel="nofollow">1、思路分析</a></p> 
<p id="2%E3%80%81%E5%A4%8D%E6%9D%82%E5%BA%A6-toc" style="margin-left:80px;"><a href="#2%E3%80%81%E5%A4%8D%E6%9D%82%E5%BA%A6" rel="nofollow">2、复杂度</a></p> 
<p id="3%E3%80%81%E4%BB%A3%E7%A0%81%E8%AF%A6%E8%A7%A3-toc" style="margin-left:80px;"><a href="#3%E3%80%81%E4%BB%A3%E7%A0%81%E8%AF%A6%E8%A7%A3" rel="nofollow">3、代码详解</a></p> 
<hr id="hr-toc"> 
<p>一、题目</p> 
<h4 id="1%E3%80%81%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0">1、题目描述</h4> 
<blockquote> 
 <p>Ujan has a lot of useless stuff in his drawers, a considerable part of which are his math notebooks: it is time to sort them out. This time he found an old dusty graph theory notebook with a description of a graph.</p> 
 <p>It is an undirected weighted graph on n vertices. It is a complete graph: each pair of vertices is connected by an edge. The weight of each edge is either 0 or 1; exactly mm edges have weight 1, and all others have weight 0.</p> 
 <p>Since Ujan doesn’t really want to organize his notes, he decided to find the weight of the minimum spanning tree of the graph. (The weight of a spanning tree is the sum of all its edges.) Can you find the answer for Ujan so he stops procrastinating?</p> 
</blockquote> 
<h4 id="2%E3%80%81%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA">2、输入输出</h4> 
<h5 id="2.1%E8%BE%93%E5%85%A5">2.1输入</h5> 
<blockquote> 
 <p>The first line of the input contains two integers n and m (1≤n≤10^5, 0≤m≤min(n*(n−1)/2,10^5)), the number of vertices and the number of edges of weight 1 in the graph.</p> 
 <p>The i-th of the next m lines contains two integers ai and bi (1≤ai,bi≤n, ai≠bi), the endpoints of the i-th edge of weight 1.</p> 
 <p>It is guaranteed that no edge appears twice in the input.</p> 
</blockquote> 
<h5 id="2.2%E8%BE%93%E5%87%BA">2.2输出</h5> 
<blockquote> 
 <p>Output a single integer, the weight of the minimum spanning tree of the graph.</p> 
</blockquote> 
<h4 id="3%E3%80%81%E5%8E%9F%E9%A2%98%E9%93%BE%E6%8E%A5">3、原题链接</h4> 
<p><a href="https://codeforc.es/problemset/problem/1242/B" rel="nofollow" title="Problem - 1242B - Codeforces (Unofficial mirror by Menci)">Problem - 1242B - Codeforces (Unofficial mirror by Menci)</a></p> 
<hr> 
<p></p> 
<h3 id="%E4%BA%8C%E3%80%81%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8A">二、解题报告</h3> 
<h4 id="1%E3%80%81%E6%80%9D%E8%B7%AF%E5%88%86%E6%9E%90">1、思路分析</h4> 
<p>思来想去只能想到O(n^2)解法，看到大佬一句话点破梦中人了属于是orz。</p> 
<p>朴素思想：直接跑生成树——MLE</p> 
<p>进一步：无权边连通块数目-1即为答案——如果只能想出O(n^2)解法会TLE</p> 
<p>一个特别妙的思路：因为一共有m条带权边，那么只考虑带权边的情况下所有节点的出度入度之和为2*m，那么假如最小度为dmin，那么度为dmin的点不会超过2*m/n！！！(这个不难想</p> 
<p>精彩的来了：我们先拿到一个最小度的点，O(n)求出它所在的无权边连通块，那么剩下的点中的无权边连通块的数目即为答案</p> 
<p>那么如何求剩下点的无权连通块呢？</p> 
<p>剩下的点不超过2*m/n个，我们对于每个点都枚举1~n的所有点，如果两个点之间没有边就合并</p> 
<p>这一步骤时间复杂度为O(2*m/n * n) = O(m)！！！</p> 
<p>所以我们在O(N+M)的时间内就解决了问题</p> 
<p>最坏情况下，如果最小度的点特别多，我们效率仍然是线性的（可以结合n，m的数据范围想一下</p> 
<p></p> 
<h4 id="2%E3%80%81%E5%A4%8D%E6%9D%82%E5%BA%A6">2、复杂度</h4> 
<blockquote> 
 <p>时间复杂度：O(n+m) 空间复杂度：O(m)</p> 
</blockquote> 
<p></p> 
<h4 id="3%E3%80%81%E4%BB%A3%E7%A0%81%E8%AF%A6%E8%A7%A3">3、代码详解</h4> 
<pre>​</pre> 
<pre><code class="language-cpp">#include &lt;iostream&gt;
#include &lt;cstdio&gt;
#include &lt;cstring&gt;
#include &lt;algorithm&gt;
using namespace std;
const int N = 100005;
const int M = 505;
int n, m, cnt;
bool g[M][N];
struct edge
{
    int u, v;
} edges[N];
int deg[N], minid = 0;
int p[N];
int seq[N], tot = 0, pos[N];
int findp(int x)
{
    return p[x] &lt; 0 ? x : p[x] = findp(p[x]);
}
bool Union(int x, int y)
{
    int px = findp(x), py = findp(y);
    if (px == py)
        return false;
    if (p[px] &gt; p[py])
        swap(px, py);
    p[px] += p[py], p[py] = px;
    return true;
}
bool vis[N];
int main()
{
    ios::sync_with_stdio(false), cin.tie(0), cout.tie(0);
    // freopen("in.txt", "r", stdin);
    cin &gt;&gt; n &gt;&gt; m, memset(p, -1, sizeof(p));
    for (int i = 1, u, v; i &lt;= m; ++i)
        cin &gt;&gt; u &gt;&gt; v, edges[i] = {u, v}, ++deg[u], ++deg[v];

    minid = 1;
    for (int i = 2; i &lt;= n; ++i)
        if (deg[i] &lt; deg[minid])
            minid = i;

    for (int i = 1; i &lt;= m; ++i)
    {
        if (edges[i].u == minid)
            vis[edges[i].v] = true;
        if (edges[i].v == minid)
            vis[edges[i].u] = true;
    }
    for (int i = 1; i &lt;= n; ++i)
        if (vis[i])
            seq[++tot] = i, pos[i] = tot;
        else
            Union(i, minid);

    for (int i = 1; i &lt;= m; ++i)
    {
        if (vis[edges[i].u])
            g[pos[edges[i].u]][edges[i].v] = true;
        if (vis[edges[i].v])
            g[pos[edges[i].v]][edges[i].u] = true;
    }
    for (int i = 1; i &lt;= tot; ++i)
        for (int j = 1, u = seq[i]; j &lt;= n; ++j)
            if (g[i][j])
                continue;
            else
                cnt += Union(u, j);

    cout &lt;&lt; tot - cnt;
    return 0;
}
</code></pre> 
<p></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/7f248916ea47d341ec828e93186f48ac/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">测试ASP.NET Core项目调用EasyCaching的基本用法（Redis）</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/2c2878fc4abf70564c721c678387e38b/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">Linux中的known_hosts</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>