<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>漏桶算法和令牌桶算法 - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="漏桶算法和令牌桶算法" />
<meta property="og:description" content="目录
一、漏桶和令牌桶介绍
二、Redis&#43; lua脚本 &#43; 令牌桶算法 实现限流控制
1、自定义一个注解，用来给限流的方法标注
2、编写lua脚本
3、读取lua脚本
4、创建拦截器拦截带有该注解的方法
5、在WebConfig中注册这个这个拦截器
6、注解使用
一、漏桶和令牌桶介绍 漏桶算法与令牌桶算法在表面看起来类似，很容易将两者混淆。但事实上，这两者具有截然不同的特性，且为不同的目的而使用。漏桶算法与令牌桶算法的区别在于：l 漏桶算法能够强行限制数据的传输速率。l 令牌桶算法能够在限制数据的平均传输速率的同
时还允许某种程度的突发传输。需要说明的是：在某些情况下，漏桶算法不能够有效地使用网络资源。因为漏桶的漏出速率是固定的，所以即使网络中没有发生拥塞，漏桶算法也不能使某一个单独的数据流达到端口速率。因此，漏桶算法对于存在突发特性的
流量来说缺乏效率。而令牌桶算法则能够满足这些具有突发特性的流量。通常，漏桶算法与令牌桶算法结合起来为网络流量提供更高效的控制。
常用的限流算法有两种：漏桶算法和令牌桶算法。
漏桶算法思路很简单，水（请求）先进入到漏桶里，漏桶以一定的速度出水，当水流入速度过大会直接溢出，可以看出漏桶算法能强行限制数据的传输速率。
漏桶算法示意图
对于很多应用场景来说，除了要求能够限制数据的平均传输速率外，还要求允许某种程度的突发传输。这时候漏桶算法可能就不合适了，令牌桶算法更为适合。如图2所示，令牌桶算法的原理是系统会以一个恒定的速度往桶里放入令牌，而如果请求需要被处
理，则需要先从桶里获取一个令牌，当桶里没有令牌可取时，则拒绝服务。
令牌桶算法示意图
并不能说明令牌桶一定比漏洞好，她们使用场景不一样。令牌桶可以用来保护自己，主要用来对调用者频率进行限流，为的是让自己不被打垮。所以如果自己本身有处理能力的时候，如果流量突发（实际消费能力强于配置的流量限制），那么实际处理速率可
以超过配置的限制。而漏桶算法，这是用来保护他人，也就是保护他所调用的系统。主要场景是，当调用的第三方系统本身没有保护机制，或者有流量限制的时候，我们的调用速度不能超过他的限制，由于我们不能更改第三方系统，所以只有在主调方控制。
这个时候，即使流量突发，也必须舍弃。因为消费能力是第三方决定的。
总结起来：如果要让自己的系统不被打垮，用令牌桶。如果保证被别人的系统不被打垮，用漏桶算法。
二、Redis&#43; lua脚本 &#43; 令牌桶算法 实现限流控制 1、自定义一个注解，用来给限流的方法标注 @Target({ElementType.TYPE, ElementType.METHOD}) @Retention(RetentionPolicy.RUNTIME) public @interface RateLimit { //限流唯一标示 String key() default &#34;&#34;; //限流单位时间（单位为s） int time() default 1; //单位时间内限制的访问次数 int count(); //是否限制ip boolean ipLimit() default false; } 2、编写lua脚本 根据key（参数） 查询 对应的 value（令牌数） 如果为null 说明该key 是第一次进入 { 初始化 令牌桶（参数）数量;记录初始化时间 -&gt;返回 剩余令牌数 } 如果不为null { 判断 value 是否大于1 { 大于1 -&gt;value - 1 -&gt; 返回 剩余令牌数 小于1 -&gt; 判断 补充令牌时间间隔是否足够 { 足够 -&gt; 补充令牌；更新补充令牌时间-&gt; 返回 剩余令牌数 不足够	-&gt; 返回 -1 (说明超过限流访问次数) } } } redis." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/37dd8c1e8210c786e22b08b40f47422c/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2021-05-21T16:29:58+08:00" />
<meta property="article:modified_time" content="2021-05-21T16:29:58+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">漏桶算法和令牌桶算法</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p id="main-toc"><strong>目录</strong></p> 
<p id="%E4%B8%80%E3%80%81%E6%BC%8F%E6%A1%B6%E5%92%8C%E4%BB%A4%E7%89%8C%E6%A1%B6%E4%BB%8B%E7%BB%8D-toc" style="margin-left:0px;"><a href="#%E4%B8%80%E3%80%81%E6%BC%8F%E6%A1%B6%E5%92%8C%E4%BB%A4%E7%89%8C%E6%A1%B6%E4%BB%8B%E7%BB%8D" rel="nofollow">一、漏桶和令牌桶介绍</a></p> 
<p id="%E4%BA%8C%E3%80%81Redis%2B%C2%A0lua%E8%84%9A%E6%9C%AC%20%2B%20%E4%BB%A4%E7%89%8C%E6%A1%B6%E7%AE%97%E6%B3%95%20%E5%AE%9E%E7%8E%B0%E9%99%90%E6%B5%81%E6%8E%A7%E5%88%B6-toc" style="margin-left:0px;"><a href="#%E4%BA%8C%E3%80%81Redis%2B%C2%A0lua%E8%84%9A%E6%9C%AC%20%2B%20%E4%BB%A4%E7%89%8C%E6%A1%B6%E7%AE%97%E6%B3%95%20%E5%AE%9E%E7%8E%B0%E9%99%90%E6%B5%81%E6%8E%A7%E5%88%B6" rel="nofollow">二、Redis+ lua脚本 + 令牌桶算法 实现限流控制</a></p> 
<p id="1%E3%80%81%E8%87%AA%E5%AE%9A%E4%B9%89%E4%B8%80%E4%B8%AA%E6%B3%A8%E8%A7%A3%EF%BC%8C%E7%94%A8%E6%9D%A5%E7%BB%99%E9%99%90%E6%B5%81%E7%9A%84%E6%96%B9%E6%B3%95%E6%A0%87%E6%B3%A8-toc" style="margin-left:40px;"><a href="#1%E3%80%81%E8%87%AA%E5%AE%9A%E4%B9%89%E4%B8%80%E4%B8%AA%E6%B3%A8%E8%A7%A3%EF%BC%8C%E7%94%A8%E6%9D%A5%E7%BB%99%E9%99%90%E6%B5%81%E7%9A%84%E6%96%B9%E6%B3%95%E6%A0%87%E6%B3%A8" rel="nofollow">1、自定义一个注解，用来给限流的方法标注</a></p> 
<p id="2%E3%80%81%E7%BC%96%E5%86%99lua%E8%84%9A%E6%9C%AC-toc" style="margin-left:40px;"><a href="#2%E3%80%81%E7%BC%96%E5%86%99lua%E8%84%9A%E6%9C%AC" rel="nofollow">2、编写lua脚本</a></p> 
<p id="3%E3%80%81%E8%AF%BB%E5%8F%96lua%E8%84%9A%E6%9C%AC-toc" style="margin-left:40px;"><a href="#3%E3%80%81%E8%AF%BB%E5%8F%96lua%E8%84%9A%E6%9C%AC" rel="nofollow">3、读取lua脚本</a></p> 
<p id="4%E3%80%81%E5%88%9B%E5%BB%BA%E6%8B%A6%E6%88%AA%E5%99%A8%E6%8B%A6%E6%88%AA%E5%B8%A6%E6%9C%89%E8%AF%A5%E6%B3%A8%E8%A7%A3%E7%9A%84%E6%96%B9%E6%B3%95-toc" style="margin-left:40px;"><a href="#4%E3%80%81%E5%88%9B%E5%BB%BA%E6%8B%A6%E6%88%AA%E5%99%A8%E6%8B%A6%E6%88%AA%E5%B8%A6%E6%9C%89%E8%AF%A5%E6%B3%A8%E8%A7%A3%E7%9A%84%E6%96%B9%E6%B3%95" rel="nofollow">4、创建拦截器拦截带有该注解的方法</a></p> 
<p id="5%E3%80%81%E5%9C%A8WebConfig%E4%B8%AD%E6%B3%A8%E5%86%8C%E8%BF%99%E4%B8%AA%E8%BF%99%E4%B8%AA%E6%8B%A6%E6%88%AA%E5%99%A8-toc" style="margin-left:40px;"><a href="#5%E3%80%81%E5%9C%A8WebConfig%E4%B8%AD%E6%B3%A8%E5%86%8C%E8%BF%99%E4%B8%AA%E8%BF%99%E4%B8%AA%E6%8B%A6%E6%88%AA%E5%99%A8" rel="nofollow">5、在WebConfig中注册这个这个拦截器</a></p> 
<p id="6%E3%80%81%E6%B3%A8%E8%A7%A3%E4%BD%BF%E7%94%A8-toc" style="margin-left:40px;"><a href="#6%E3%80%81%E6%B3%A8%E8%A7%A3%E4%BD%BF%E7%94%A8" rel="nofollow">6、注解使用</a></p> 
<hr id="hr-toc"> 
<h2 id="%E4%B8%80%E3%80%81%E6%BC%8F%E6%A1%B6%E5%92%8C%E4%BB%A4%E7%89%8C%E6%A1%B6%E4%BB%8B%E7%BB%8D">一、漏桶和令牌桶介绍</h2> 
<blockquote> 
 <p><a href="https://www.baidu.com/s?wd=%E6%BC%8F%E6%A1%B6%E7%AE%97%E6%B3%95&amp;tn=SE_PcZhidaonwhc_ngpagmjz&amp;rsv_dl=gh_pc_zhidao" rel="nofollow">漏桶算法</a>与<a href="https://www.baidu.com/s?wd=%E4%BB%A4%E7%89%8C%E6%A1%B6%E7%AE%97%E6%B3%95&amp;tn=SE_PcZhidaonwhc_ngpagmjz&amp;rsv_dl=gh_pc_zhidao" rel="nofollow">令牌桶算法</a>在表面看起来类似，很容易将两者混淆。但事实上，这两者具有截然不同的特性，且为不同的目的而使用。<a href="https://www.baidu.com/s?wd=%E6%BC%8F%E6%A1%B6%E7%AE%97%E6%B3%95&amp;tn=SE_PcZhidaonwhc_ngpagmjz&amp;rsv_dl=gh_pc_zhidao" rel="nofollow">漏桶算法</a>与<a href="https://www.baidu.com/s?wd=%E4%BB%A4%E7%89%8C%E6%A1%B6%E7%AE%97%E6%B3%95&amp;tn=SE_PcZhidaonwhc_ngpagmjz&amp;rsv_dl=gh_pc_zhidao" rel="nofollow">令牌桶算法</a>的区别在于：l <a href="https://www.baidu.com/s?wd=%E6%BC%8F%E6%A1%B6%E7%AE%97%E6%B3%95&amp;tn=SE_PcZhidaonwhc_ngpagmjz&amp;rsv_dl=gh_pc_zhidao" rel="nofollow">漏桶算法</a>能够强行限制数据的<a href="https://www.baidu.com/s?wd=%E4%BC%A0%E8%BE%93%E9%80%9F%E7%8E%87&amp;tn=SE_PcZhidaonwhc_ngpagmjz&amp;rsv_dl=gh_pc_zhidao" rel="nofollow">传输速率</a>。l <a href="https://www.baidu.com/s?wd=%E4%BB%A4%E7%89%8C%E6%A1%B6%E7%AE%97%E6%B3%95&amp;tn=SE_PcZhidaonwhc_ngpagmjz&amp;rsv_dl=gh_pc_zhidao" rel="nofollow">令牌桶算法</a>能够在限制数据的平均<a href="https://www.baidu.com/s?wd=%E4%BC%A0%E8%BE%93%E9%80%9F%E7%8E%87&amp;tn=SE_PcZhidaonwhc_ngpagmjz&amp;rsv_dl=gh_pc_zhidao" rel="nofollow">传输速率</a>的同</p> 
 <p>时还允许某种程度的<a href="https://www.baidu.com/s?wd=%E7%AA%81%E5%8F%91%E4%BC%A0%E8%BE%93&amp;tn=SE_PcZhidaonwhc_ngpagmjz&amp;rsv_dl=gh_pc_zhidao" rel="nofollow">突发传输</a>。需要说明的是：在某些情况下，漏桶算法不能够有效地使用网络资源。因为漏桶的漏出速率是固定的，所以即使网络中没有发生拥塞，漏桶算法也不能使某一个单独的数据流达到端口速率。因此，漏桶算法对于存在突发特性的</p> 
 <p>流量来说缺乏效率。而令牌桶算法则能够满足这些具有突发特性的流量。通常，漏桶算法与令牌桶算法结合起来为<a href="https://www.baidu.com/s?wd=%E7%BD%91%E7%BB%9C%E6%B5%81%E9%87%8F&amp;tn=SE_PcZhidaonwhc_ngpagmjz&amp;rsv_dl=gh_pc_zhidao" rel="nofollow">网络流量</a>提供更高效的控制。</p> 
</blockquote> 
<blockquote> 
 <p>常用的限流算法有两种：漏桶算法和令牌桶算法。</p> 
 <p>      漏桶算法思路很简单，水（请求）先进入到漏桶里，漏桶以一定的速度出水，当水流入速度过大会直接溢出，可以看出漏桶算法能强行限制数据的传输速率。</p> 
</blockquote> 
<p><strong>漏桶算法示意图</strong></p> 
<p><img alt="" src="https://images2.imgbox.com/25/72/B69Fwpua_o.png"></p> 
<blockquote> 
 <p>对于很多应用场景来说，除了要求能够限制数据的平均传输速率外，还要求允许某种程度的突发传输。这时候漏桶算法可能就不合适了，令牌桶算法更为适合。如图2所示，令牌桶算法的原理是系统会以一个恒定的速度往桶里放入令牌，而如果请求需要被处</p> 
 <p>理，则需要先从桶里获取一个令牌，当桶里没有令牌可取时，则拒绝服务。</p> 
</blockquote> 
<p><strong>令牌桶算法示意图</strong></p> 
<p><img alt="" height="251" src="https://images2.imgbox.com/a9/1b/YgTnx7fE_o.png" width="424"></p> 
<blockquote> 
 <p>并不能说明令牌桶一定比漏洞好，她们使用场景不一样。令牌桶可以用来保护自己，主要用来对调用者频率进行限流，为的是让自己不被打垮。所以如果自己本身有处理能力的时候，如果流量突发（实际消费能力强于配置的流量限制），那么实际处理速率可</p> 
 <p>以超过配置的限制。而漏桶算法，这是用来保护他人，也就是保护他所调用的系统。主要场景是，当调用的第三方系统本身没有保护机制，或者有流量限制的时候，我们的调用速度不能超过他的限制，由于我们不能更改第三方系统，所以只有在主调方控制。</p> 
 <p>这个时候，即使流量突发，也必须舍弃。因为消费能力是第三方决定的。</p> 
 <p><strong>总结起来：如果要让自己的系统不被打垮，用令牌桶。如果保证被别人的系统不被打垮，用漏桶算法。</strong></p> 
</blockquote> 
<h2 id="%E4%BA%8C%E3%80%81Redis%2B%C2%A0lua%E8%84%9A%E6%9C%AC%20%2B%20%E4%BB%A4%E7%89%8C%E6%A1%B6%E7%AE%97%E6%B3%95%20%E5%AE%9E%E7%8E%B0%E9%99%90%E6%B5%81%E6%8E%A7%E5%88%B6"><code>二、Redis</code>+ <code>lua</code>脚本 + 令牌桶算法 实现限流控制</h2> 
<h3 id="1%E3%80%81%E8%87%AA%E5%AE%9A%E4%B9%89%E4%B8%80%E4%B8%AA%E6%B3%A8%E8%A7%A3%EF%BC%8C%E7%94%A8%E6%9D%A5%E7%BB%99%E9%99%90%E6%B5%81%E7%9A%84%E6%96%B9%E6%B3%95%E6%A0%87%E6%B3%A8">1、自定义一个注解，用来给限流的方法标注</h3> 
<pre><code class="language-java">@Target({ElementType.TYPE, ElementType.METHOD})
@Retention(RetentionPolicy.RUNTIME)
public @interface RateLimit {
    //限流唯一标示
    String key() default "";
 
    //限流单位时间（单位为s）
    int time() default 1;
 
    //单位时间内限制的访问次数
    int count();
 
    //是否限制ip
    boolean ipLimit() default false;
}</code></pre> 
<h3 id="2%E3%80%81%E7%BC%96%E5%86%99lua%E8%84%9A%E6%9C%AC">2、编写<code>lua</code>脚本</h3> 
<pre><code class="language-Lua">根据key（参数） 查询 对应的 value（令牌数）
	如果为null 说明该key 是第一次进入 
	{
		初始化 令牌桶（参数）数量;记录初始化时间 -&gt;返回 剩余令牌数
	} 
	
	如果不为null
	{
		判断 value 是否大于1 
		{
			大于1  -&gt;value - 1  -&gt; 返回 剩余令牌数
			小于1  -&gt; 判断  补充令牌时间间隔是否足够
			{
				足够 -&gt; 补充令牌；更新补充令牌时间-&gt; 返回 剩余令牌数
				不足够	-&gt; 返回 -1 (说明超过限流访问次数)
			}
		}
	}
	</code></pre> 
<pre><code class="language-Lua">redis.replicate_commands();
-- 参数中传递的key
local key = KEYS[1]
-- 令牌桶填充 最小时间间隔
local update_len = tonumber(ARGV[1])
-- 记录 当前key上次更新令牌桶的时间的 key
local key_time = 'ratetokenprefix'..key
-- 获取当前时间(这里的curr_time_arr 中第一个是 秒数，第二个是 秒数后毫秒数)，由于我是按秒计算的，这里只要curr_time_arr[1](注意：redis数组下标是从1开始的)
--如果需要获得毫秒数 则为 tonumber(arr[1]*1000 + arr[2])
local curr_time_arr = redis.call('TIME')
-- 当前时间秒数
local nowTime = tonumber(curr_time_arr[1])
-- 从redis中获取当前key 对应的上次更新令牌桶的key 对应的value
local curr_key_time = tonumber(redis.call('get',KEYS[1]) or 0)
-- 获取当前key对应令牌桶中的令牌数
local token_count = tonumber(redis.call('get',KEYS[1]) or -1)
-- 当前令牌桶的容量
local token_size = tonumber(ARGV[2])
-- 令牌桶数量小于0 说明令牌桶没有初始化
if token_count &lt; 0 then
	redis.call('set',key_time,nowTime)
	redis.call('set',key,token_size -1)
	return token_size -1
else
	if token_count &gt; 0 then --当前令牌桶中令牌数够用
		redis.call('set',key,token_count - 1)
		return token_count -1   --返回剩余令牌数
	else    --当前令牌桶中令牌数已清空
		if curr_key_time + update_len &lt; nowTime then    --判断一下，当前时间秒数 与上次更新时间秒数  的间隔，是否大于规定时间间隔数 （update_len）
			redis.call('set',key,token_size -1)
			return token_size - 1
		else
			return -1
		end
	end
end</code></pre> 
<h3 id="3%E3%80%81%E8%AF%BB%E5%8F%96lua%E8%84%9A%E6%9C%AC">3、读取<code>lua</code>脚本</h3> 
<pre><code class="language-java">@Component
public class CommonConfig {
    /**
     * 读取限流脚本
     */
    @Bean
    public DefaultRedisScript&lt;Number&gt; redisluaScript() {
        DefaultRedisScript&lt;Number&gt; redisScript = new DefaultRedisScript&lt;&gt;();
        //这里脚本的路径为path for source root 路径
        redisScript.setScriptSource(new ResourceScriptSource(new ClassPathResource("myLua.lua"))); 
        redisScript.setResultType(Number.class);
        return redisScript;
    }
    /**
     * RedisTemplate
     */
    @Bean
    public RedisTemplate&lt;String, Serializable&gt; limitRedisTemplate(LettuceConnectionFactory redisConnectionFactory) {
        RedisTemplate&lt;String, Serializable&gt; template = new RedisTemplate&lt;String, Serializable&gt;();
        template.setKeySerializer(new StringRedisSerializer());
        template.setValueSerializer(new GenericJackson2JsonRedisSerializer());
        template.setConnectionFactory(redisConnectionFactory);
        return template;
    }
}</code></pre> 
<h3 id="4%E3%80%81%E5%88%9B%E5%BB%BA%E6%8B%A6%E6%88%AA%E5%99%A8%E6%8B%A6%E6%88%AA%E5%B8%A6%E6%9C%89%E8%AF%A5%E6%B3%A8%E8%A7%A3%E7%9A%84%E6%96%B9%E6%B3%95">4、创建拦截器拦截带有该注解的方法</h3> 
<pre><code class="language-java">@Component
public class RateLimitInterceptor implements HandlerInterceptor {
    private final Logger LOG = LoggerFactory.getLogger(this.getClass());
    
    @Autowired
    private RedisTemplate&lt;String, Serializable&gt; limitRedisTemplate;
 
    @Autowired
    private DefaultRedisScript&lt;Number&gt; redisLuaScript;
    
    @Override
    public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception {
        assert handler instanceof HandlerMethod;
        HandlerMethod method = (HandlerMethod) handler;
        RateLimit rateLimit = method.getMethodAnnotation(RateLimit.class);
        //当前方法上有我们自定义的注解
        if (rateLimit != null) {
            //获得单位时间内限制的访问次数
            int count = rateLimit.count();
            String key = rateLimit.key();
            //获得限流单位时间（单位为s）
            int time = rateLimit.time();
            boolean ipLimit = rateLimit.ipLimit();
            //拼接 redis中的key
            StringBuilder sb = new StringBuilder();
            sb.append(Constants.RATE_LIMIT_KEY).append(key).append(":");
            //如果需要限制ip的话
            if(ipLimit){
                sb.append(getIpAddress(request)).append(":");
            }
            List&lt;String&gt; keys = Collections.singletonList(sb.toString());
           //执行lua脚本
            Number execute = limitRedisTemplate.execute(redisLuaScript, keys, time, count);
            assert execute != null;
            if (-1 == execute.intValue()) {
                ResultModel resultModel = ResultModel.error_900("接口调用超过限流次数");
                response.setStatus(901);
                response.setCharacterEncoding("utf-8");
                response.setContentType("application/json");
                response.getWriter().write(JSONObject.toJSONString(resultModel));
                response.getWriter().flush();
                response.getWriter().close();
                LOG.info("当前接口调用超过时间段内限流,key:{}", sb.toString());
                return false;
            } else {
                LOG.info("当前访问时间段内剩余{}次访问次数", execute.toString());
            }
        }
        return true;
    }
 
    @Override
    public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView) throws Exception {
 
    }
 
    @Override
    public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) throws Exception {
 
    }
    
    public static String getIpAddr(HttpServletRequest request) {
        String ipAddress = null;
        try {
            ipAddress = request.getHeader("x-forwarded-for");
            if (ipAddress == null || ipAddress.length() == 0 || "unknown".equalsIgnoreCase(ipAddress)) {
                ipAddress = request.getHeader("Proxy-Client-IP");
            }
            if (ipAddress == null || ipAddress.length() == 0 || "unknown".equalsIgnoreCase(ipAddress)) {
                ipAddress = request.getHeader("WL-Proxy-Client-IP");
            }
            if (ipAddress == null || ipAddress.length() == 0 || "unknown".equalsIgnoreCase(ipAddress)) {
                ipAddress = request.getRemoteAddr();
            }
            // 对于通过多个代理的情况，第一个IP为客户端真实IP,多个IP按照','分割
            // "***.***.***.***".length()
            if (ipAddress != null &amp;&amp; ipAddress.length() &gt; 15) { 
                // = 15
                if (ipAddress.indexOf(",") &gt; 0) {
                    ipAddress = ipAddress.substring(0, ipAddress.indexOf(","));
                }
            }
        } catch (Exception e) {
            ipAddress = "";
        }
        return ipAddress;
    }
 
}</code></pre> 
<p><strong>一个自定义的常量用作<code>redis</code>前缀</strong></p> 
<pre><code class="language-java">public class Constants {
    public static final String RATE_LIMIT_KEY = "rateLimit:";
}</code></pre> 
<h3 id="5%E3%80%81%E5%9C%A8WebConfig%E4%B8%AD%E6%B3%A8%E5%86%8C%E8%BF%99%E4%B8%AA%E8%BF%99%E4%B8%AA%E6%8B%A6%E6%88%AA%E5%99%A8">5、在<code>WebConfig</code>中注册这个这个拦截器</h3> 
<pre><code class="language-java">@Configuration
@EnableWebMvc
public class WebConfig extends WebMvcConfigurerAdapter {
 
    @Autowired
    private RateLimitInterceptor rateLimitInterceptor;
 
    @Override
    public void addInterceptors(InterceptorRegistry registry) {
        registry.addInterceptor(rateLimitInterceptor);
        super.addInterceptors(registry);
    }
}</code></pre> 
<h3 id="6%E3%80%81%E6%B3%A8%E8%A7%A3%E4%BD%BF%E7%94%A8">6、注解使用</h3> 
<pre><code class="language-java">@RestController
@RequestMapping(value = "/test")
public class TestController {
 
    //限流规则为 1秒内只允许同一个ip发送5次请求
    @RateLimit(key = "testGet",time = 1,count = 5,ipLimit = true)
    @RequestMapping(value = "/get")
    public ResultModel testGet(){
        return ResultModel.ok_200();
    }
 
}</code></pre> 
<p> </p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/a2fc4fc841fcdcd5f53b8868dab07330/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">HAL库常见报错（1）：error:  #20: identifier “HAL_StatusTypeDef“ is undefined</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/cd0eb98cfa672a9200141fc2d71fd131/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">c语言 1累乘至100,C语言1乘到100怎么编写</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>