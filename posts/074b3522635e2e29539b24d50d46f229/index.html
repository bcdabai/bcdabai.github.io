<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Redis概述及安装、使用和管理 - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Redis概述及安装、使用和管理" />
<meta property="og:description" content="目录
一、NoSQL非关系型数据库
1.NoSQL概述
2.关系型数据库和非关系型数据库区别
（1）数据存储方式不同
（2）扩展方式不同
（3）对事务性的支持不同
3.非关系型数据库使用场景
二、Redis概述
1.简介
2.优点
3.Redis读写快的原因
4.适用场景
三、Redis安装配置
四、Redis的使用
1.命令行工具redis-cli（登录）
2.测试工具redis-benchmark（测试）
3.redis命令的使用
4.Redis多库常用命令
五、Redis性能管理
1.查看内存使用
2.清理内存碎片
（1）内存碎片如何产生
（2）内存碎片率
（3）清理内存碎片
3.内存使用率
4.内回收key
一、NoSQL非关系型数据库 1.NoSQL概述 NoSQL (Not Only SQL)，是非关系型数据库的总称。除了主流的关系型数据库外的数据库，都认为是非关系型。
不需要预先建库建表定义数据存储表结构，每条记录可以有不同的数据类型和字段个数（比如微信群聊里的文字、图片、视频、音乐等)。
主流的 NoSQL数据库有 Redis、MongBD、Hbase、Memcached、ElasticSearch、TSD等。
2.关系型数据库和非关系型数据库区别 （1）数据存储方式不同 关系型和非关系型数据库的主要差异是数据存储的方式。
SQL数据库天然就是表格式的，因此存储在数据表的行和列中。数据表可以彼此关联协作存储，也很容易提取数据。
NoSQL型数据不适合存储在数据表的行和列中，而是大块组合在一起。非关系型数据通常存储在数据集中，就像文档、键值对或者图结构。你的数据及其特性是选择数据存储和提取方式的首要影响因素。
（2）扩展方式不同 关系型和非关系型数据库最大的差别是在扩展方式上，要支持日益增长的需求当然要扩展。
SQL数据库是纵向扩展，也就是说提高处理能力，使用速度更快速的计算机，这样处理相同的数据集就更快了。因为数据存储在关系表中，操作的性能瓶颈可能涉及很多个表，这都需要通过提高计算机性能来克服。虽然sql数据库有很大扩展空间，但最终肯定会达到纵向扩展的上限。
NoSQL数据库是横向扩展的。因为非关系型数据存储天然就是分布式的，NoSQL数据库的扩展可以通过给资源池添加更多普通的数据库服务器:节点)来分担负载。
（3）对事务性的支持不同 如果数据操作需要高事务性或者复杂数据查询需要控制执行计划，那么传统的SQL数据库从性能和稳定性方面考虑是你的最佳选择。
SQL数据库支持对事务原子性细粒度控制，并且易于回滚事务。
虽然NoSQL数据库也可以使用事务操作，但稳定性方面没法和关系型数据库比较。所以它们真正闪亮的价值是在操作的扩展性和大数据量处理方面。
3.非关系型数据库使用场景 可用于应对web2.0纯动态网站类型的三高问题（高并发、高性能、高可用)。
High performance——对数据库高并发读写需求；Huge Storage——对海量数据高效存储与访问需求；High Scalability and High Availability——对数据库高可扩展性与高可用性需求。 关系型数据库和非关系型数据库都有各自的特点与应用场景，两者的紧密结合将会给web2.0的数据库发展带来新的思路：
关系型数据库关注在关系和对数据的一致性保障上；
非关系型数据库关注在存储和高效率上。
例如：在读写分离的Mysql数据库环境中，可以把经常访问的数据存储在非关系型数据库中，提升访问速度。
二、Redis概述 1.简介 Redis(远程字典服务器）是一个开源的、使用c语言编写的 NoSQL数据库。
Redis基于内存运行并支持持久化，采用key-value(键值对）的存储形式，是目前分布式架构中不可或缺的一环。
Redis服务器程序是单进程模型，也就是在一台服务器上可以同时启动多个Redis进程，Redis的实际处理速度则是完全依靠主进程的执行效率。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/074b3522635e2e29539b24d50d46f229/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-07-26T16:26:00+08:00" />
<meta property="article:modified_time" content="2023-07-26T16:26:00+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Redis概述及安装、使用和管理</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p id="main-toc"><strong>目录</strong></p> 
<p id="-toc" style="margin-left:0px;"></p> 
<p id="%E4%B8%80%E3%80%81NoSQL%E9%9D%9E%E5%85%B3%E7%B3%BB%E5%9E%8B%E6%95%B0%E6%8D%AE%E5%BA%93-toc" style="margin-left:0px;"><a href="#%E4%B8%80%E3%80%81NoSQL%E9%9D%9E%E5%85%B3%E7%B3%BB%E5%9E%8B%E6%95%B0%E6%8D%AE%E5%BA%93" rel="nofollow">一、NoSQL非关系型数据库</a></p> 
<p id="1.NoSQL%E6%A6%82%E8%BF%B0-toc" style="margin-left:40px;"><a href="#1.NoSQL%E6%A6%82%E8%BF%B0" rel="nofollow">1.NoSQL概述</a></p> 
<p id="2.%E5%85%B3%E7%B3%BB%E5%9E%8B%E6%95%B0%E6%8D%AE%E5%BA%93%E5%92%8C%E9%9D%9E%E5%85%B3%E7%B3%BB%E5%9E%8B%E6%95%B0%E6%8D%AE%E5%BA%93%E5%8C%BA%E5%88%AB-toc" style="margin-left:40px;"><a href="#2.%E5%85%B3%E7%B3%BB%E5%9E%8B%E6%95%B0%E6%8D%AE%E5%BA%93%E5%92%8C%E9%9D%9E%E5%85%B3%E7%B3%BB%E5%9E%8B%E6%95%B0%E6%8D%AE%E5%BA%93%E5%8C%BA%E5%88%AB" rel="nofollow">2.关系型数据库和非关系型数据库区别</a></p> 
<p id="%EF%BC%881%EF%BC%89%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8%E6%96%B9%E5%BC%8F%E4%B8%8D%E5%90%8C-toc" style="margin-left:80px;"><a href="#%EF%BC%881%EF%BC%89%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8%E6%96%B9%E5%BC%8F%E4%B8%8D%E5%90%8C" rel="nofollow">（1）数据存储方式不同</a></p> 
<p id="%EF%BC%882%EF%BC%89%E6%89%A9%E5%B1%95%E6%96%B9%E5%BC%8F%E4%B8%8D%E5%90%8C-toc" style="margin-left:80px;"><a href="#%EF%BC%882%EF%BC%89%E6%89%A9%E5%B1%95%E6%96%B9%E5%BC%8F%E4%B8%8D%E5%90%8C" rel="nofollow">（2）扩展方式不同</a></p> 
<p id="%EF%BC%883%EF%BC%89%E5%AF%B9%E4%BA%8B%E5%8A%A1%E6%80%A7%E7%9A%84%E6%94%AF%E6%8C%81%E4%B8%8D%E5%90%8C-toc" style="margin-left:80px;"><a href="#%EF%BC%883%EF%BC%89%E5%AF%B9%E4%BA%8B%E5%8A%A1%E6%80%A7%E7%9A%84%E6%94%AF%E6%8C%81%E4%B8%8D%E5%90%8C" rel="nofollow">（3）对事务性的支持不同</a></p> 
<p id="3.%E9%9D%9E%E5%85%B3%E7%B3%BB%E5%9E%8B%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF-toc" style="margin-left:40px;"><a href="#3.%E9%9D%9E%E5%85%B3%E7%B3%BB%E5%9E%8B%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF" rel="nofollow">3.非关系型数据库使用场景</a></p> 
<p id="%E4%BA%8C%E3%80%81Redis%E6%A6%82%E8%BF%B0-toc" style="margin-left:0px;"><a href="#%E4%BA%8C%E3%80%81Redis%E6%A6%82%E8%BF%B0" rel="nofollow">二、Redis概述</a></p> 
<p id="1.%E7%AE%80%E4%BB%8B-toc" style="margin-left:40px;"><a href="#1.%E7%AE%80%E4%BB%8B" rel="nofollow">1.简介</a></p> 
<p id="2.%E4%BC%98%E7%82%B9-toc" style="margin-left:40px;"><a href="#2.%E4%BC%98%E7%82%B9" rel="nofollow">2.优点</a></p> 
<p id="3.Redis%E8%AF%BB%E5%86%99%E5%BF%AB%E7%9A%84%E5%8E%9F%E5%9B%A0-toc" style="margin-left:40px;"><a href="#3.Redis%E8%AF%BB%E5%86%99%E5%BF%AB%E7%9A%84%E5%8E%9F%E5%9B%A0" rel="nofollow">3.Redis读写快的原因</a></p> 
<p id="4.%E9%80%82%E7%94%A8%E5%9C%BA%E6%99%AF-toc" style="margin-left:40px;"><a href="#4.%E9%80%82%E7%94%A8%E5%9C%BA%E6%99%AF" rel="nofollow">4.适用场景</a></p> 
<p id="%E4%B8%89%E3%80%81Redis%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AE-toc" style="margin-left:0px;"><a href="#%E4%B8%89%E3%80%81Redis%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AE" rel="nofollow">三、Redis安装配置</a></p> 
<p id="%E4%B8%89%E3%80%81Redis%E7%9A%84%E4%BD%BF%E7%94%A8-toc" style="margin-left:0px;"><a href="#%E4%B8%89%E3%80%81Redis%E7%9A%84%E4%BD%BF%E7%94%A8" rel="nofollow">四、Redis的使用</a></p> 
<p id="1.%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%B7%A5%E5%85%B7redis-cli%EF%BC%88%E7%99%BB%E5%BD%95%EF%BC%89-toc" style="margin-left:40px;"><a href="#1.%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%B7%A5%E5%85%B7redis-cli%EF%BC%88%E7%99%BB%E5%BD%95%EF%BC%89" rel="nofollow">1.命令行工具redis-cli（登录）</a></p> 
<p id="2.%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7redis-benchmark%EF%BC%88%E6%B5%8B%E8%AF%95%EF%BC%89-toc" style="margin-left:40px;"><a href="#2.%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7redis-benchmark%EF%BC%88%E6%B5%8B%E8%AF%95%EF%BC%89" rel="nofollow">2.测试工具redis-benchmark（测试）</a></p> 
<p id="3.redis%E5%91%BD%E4%BB%A4%E7%9A%84%E4%BD%BF%E7%94%A8-toc" style="margin-left:40px;"><a href="#3.redis%E5%91%BD%E4%BB%A4%E7%9A%84%E4%BD%BF%E7%94%A8" rel="nofollow">3.redis命令的使用</a></p> 
<p id="4.Redis%E5%A4%9A%E5%BA%93%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4-toc" style="margin-left:40px;"><a href="#4.Redis%E5%A4%9A%E5%BA%93%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4" rel="nofollow">4.Redis多库常用命令</a></p> 
<p id="%E4%BA%94%E3%80%81Redis%E6%80%A7%E8%83%BD%E7%AE%A1%E7%90%86-toc" style="margin-left:0px;"><a href="#%E4%BA%94%E3%80%81Redis%E6%80%A7%E8%83%BD%E7%AE%A1%E7%90%86" rel="nofollow">五、Redis性能管理</a></p> 
<p id="1.%E6%9F%A5%E7%9C%8B%E5%86%85%E5%AD%98%E4%BD%BF%E7%94%A8-toc" style="margin-left:40px;"><a href="#1.%E6%9F%A5%E7%9C%8B%E5%86%85%E5%AD%98%E4%BD%BF%E7%94%A8" rel="nofollow">1.查看内存使用</a></p> 
<p id="2.%E6%B8%85%E7%90%86%E5%86%85%E5%AD%98%E7%A2%8E%E7%89%87-toc" style="margin-left:40px;"><a href="#2.%E6%B8%85%E7%90%86%E5%86%85%E5%AD%98%E7%A2%8E%E7%89%87" rel="nofollow">2.清理内存碎片</a></p> 
<p id="%EF%BC%881%EF%BC%89%E5%86%85%E5%AD%98%E7%A2%8E%E7%89%87%E5%A6%82%E4%BD%95%E4%BA%A7%E7%94%9F-toc" style="margin-left:80px;"><a href="#%EF%BC%881%EF%BC%89%E5%86%85%E5%AD%98%E7%A2%8E%E7%89%87%E5%A6%82%E4%BD%95%E4%BA%A7%E7%94%9F" rel="nofollow">（1）内存碎片如何产生</a></p> 
<p id="%EF%BC%882%EF%BC%89%E5%86%85%E5%AD%98%E7%A2%8E%E7%89%87%E7%8E%87-toc" style="margin-left:80px;"><a href="#%EF%BC%882%EF%BC%89%E5%86%85%E5%AD%98%E7%A2%8E%E7%89%87%E7%8E%87" rel="nofollow">（2）内存碎片率</a></p> 
<p id="%EF%BC%883%EF%BC%89%E6%B8%85%E7%90%86%E5%86%85%E5%AD%98%E7%A2%8E%E7%89%87-toc" style="margin-left:80px;"><a href="#%EF%BC%883%EF%BC%89%E6%B8%85%E7%90%86%E5%86%85%E5%AD%98%E7%A2%8E%E7%89%87" rel="nofollow">（3）清理内存碎片</a></p> 
<p id="3.%E5%86%85%E5%AD%98%E4%BD%BF%E7%94%A8%E7%8E%87-toc" style="margin-left:40px;"><a href="#3.%E5%86%85%E5%AD%98%E4%BD%BF%E7%94%A8%E7%8E%87" rel="nofollow">3.内存使用率</a></p> 
<p id="4.%E5%86%85%E5%9B%9E%E6%94%B6key-toc" style="margin-left:40px;"><a href="#4.%E5%86%85%E5%9B%9E%E6%94%B6key" rel="nofollow">4.内回收key</a></p> 
<hr id="hr-toc"> 
<p></p> 
<h2 id="%E4%B8%80%E3%80%81NoSQL%E9%9D%9E%E5%85%B3%E7%B3%BB%E5%9E%8B%E6%95%B0%E6%8D%AE%E5%BA%93">一、NoSQL非关系型数据库</h2> 
<h3 id="1.NoSQL%E6%A6%82%E8%BF%B0">1.NoSQL概述</h3> 
<p>        NoSQL (Not Only SQL)，是非关系型数据库的总称。除了主流的关系型数据库外的数据库，都认为是非关系型。</p> 
<p>        不需要预先建库建表定义数据存储表结构，每条记录可以有不同的数据类型和字段个数（比如微信群聊里的文字、图片、视频、音乐等)。</p> 
<p>        主流的 NoSQL数据库有 Redis、MongBD、Hbase、Memcached、ElasticSearch、TSD等。</p> 
<h3 id="2.%E5%85%B3%E7%B3%BB%E5%9E%8B%E6%95%B0%E6%8D%AE%E5%BA%93%E5%92%8C%E9%9D%9E%E5%85%B3%E7%B3%BB%E5%9E%8B%E6%95%B0%E6%8D%AE%E5%BA%93%E5%8C%BA%E5%88%AB">2.关系型数据库和非关系型数据库区别</h3> 
<h4 id="%EF%BC%881%EF%BC%89%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8%E6%96%B9%E5%BC%8F%E4%B8%8D%E5%90%8C">（1）数据存储方式不同</h4> 
<blockquote> 
 <p><strong>关系型和非关系型数据库的主要差异是数据存储的方式。</strong></p> 
</blockquote> 
<p>        SQL数据库天然就是<strong>表格式</strong>的，因此<strong>存储在数据表的行和列</strong>中。数据表可以彼此关联协作存储，也很容易提取数据。</p> 
<p>        NoSQL型数据不适合存储在数据表的行和列中，而是<strong>大块组合</strong>在一起。非关系型数据通常<strong>存储在数据集</strong>中，就像文档、键值对或者图结构。你的数据及其特性是选择数据存储和提取方式的首要影响因素。</p> 
<h4 id="%EF%BC%882%EF%BC%89%E6%89%A9%E5%B1%95%E6%96%B9%E5%BC%8F%E4%B8%8D%E5%90%8C">（2）扩展方式不同</h4> 
<blockquote> 
 <p><strong>关系型和非关系型数据库最大的差别是在扩展方式上，要支持日益增长的需求当然要扩展。</strong></p> 
</blockquote> 
<p>        SQL数据库是<strong>纵向扩展</strong>，也就是说提高处理能力，使用速度更快速的计算机，这样处理相同的数据集就更快了。因为数据存储在关系表中，操作的性能瓶颈可能涉及很多个表，这都需要通过提高计算机性能来克服。虽然sql数据库有很大扩展空间，但最终肯定会达到纵向扩展的上限。</p> 
<p>        NoSQL数据库是<strong>横向扩展</strong>的。因为非关系型数据存储天然就是分布式的，NoSQL数据库的扩展可以通过给资源池添加更多普通的数据库服务器:节点)来分担负载。</p> 
<h4 id="%EF%BC%883%EF%BC%89%E5%AF%B9%E4%BA%8B%E5%8A%A1%E6%80%A7%E7%9A%84%E6%94%AF%E6%8C%81%E4%B8%8D%E5%90%8C">（3）对事务性的支持不同</h4> 
<blockquote> 
 <p><strong>如果数据操作需要高事务性或者复杂数据查询需要控制执行计划，那么传统的SQL数据库从性能和稳定性方面考虑是你的最佳选择。</strong></p> 
</blockquote> 
<p>        SQL数据库支持对事务原子性细粒度控制，并且易于回滚事务。</p> 
<p>        虽然NoSQL数据库也可以使用事务操作，但稳定性方面没法和关系型数据库比较。所以它们真正闪亮的价值是在操作的扩展性和大数据量处理方面。</p> 
<h3 id="3.%E9%9D%9E%E5%85%B3%E7%B3%BB%E5%9E%8B%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF">3.非关系型数据库使用场景</h3> 
<p><strong>可用于应对web2.0纯动态网站类型的三高问题（高并发、高性能、高可用)。</strong></p> 
<ul><li>High performance——对数据库高并发读写需求；</li><li>Huge Storage——对海量数据高效存储与访问需求；</li><li>High Scalability and High Availability——对数据库高可扩展性与高可用性需求。</li></ul> 
<blockquote> 
 <p>        关系型数据库和非关系型数据库都有各自的特点与应用场景，两者的紧密结合将会给web2.0的数据库发展带来新的思路：</p> 
 <p><strong>        关系型数据库</strong>关注在<strong>关系</strong>和<strong>对数据的一致性保障上；</strong></p> 
 <p><strong>        非关系型数据库</strong>关注在<strong>存储</strong>和<strong>高效率上。</strong></p> 
 <p>        例如：在读写分离的Mysql数据库环境中，可以把经常访问的数据存储在非关系型数据库中，提升访问速度。</p> 
</blockquote> 
<h2 id="%E4%BA%8C%E3%80%81Redis%E6%A6%82%E8%BF%B0">二、Redis概述</h2> 
<h3 id="1.%E7%AE%80%E4%BB%8B">1.简介</h3> 
<p>        Redis(远程字典服务器）是一个开源的、使用c语言编写的 NoSQL数据库。</p> 
<p>        Redis基于内存运行并支持持久化，采用key-value(键值对）的存储形式，是目前分布式架构中不可或缺的一环。</p> 
<p>        Redis服务器程序是单进程模型，也就是在一台服务器上可以同时启动多个Redis进程，Redis的实际处理速度则是完全依靠主进程的执行效率。</p> 
<h3 id="2.%E4%BC%98%E7%82%B9">2.优点</h3> 
<p><strong>具有极高的数据读写速度</strong>：数据读取的速度最高可达到110000 次/s，数据写入速度最高可达到 81000 次/s。</p> 
<p><strong>支持丰富的数据类型</strong>：支持 key-value、Strings、Lists、Hashes、Sets 及 Sorted Sets等数据类型操作。</p> 
<p><strong>支持数据的持久化</strong>：可以将内存中的数据保存在磁盘中，重启的时候可以再次加载进行使用。</p> 
<p><strong>原子性</strong>：Redis 所有操作都是原子性的。</p> 
<p><strong>支持数据备份</strong>：即支持 master-salve 模式的数据备份。</p> 
<h3 id="3.Redis%E8%AF%BB%E5%86%99%E5%BF%AB%E7%9A%84%E5%8E%9F%E5%9B%A0">3.Redis读写快的原因</h3> 
<p>        Redis<strong>基于内存运行</strong>，避免了磁盘I/O等耗时操作。</p> 
<p>        Redis命令处理的核心模块为<strong>单线程</strong>，减少了锁竞争，以及频繁创建线程和销毁线程的代价，减少了线程上下文切换的消耗。</p> 
<blockquote> 
 <p><strong>注：</strong>在Redis 6.0 中新增加的多线程也只是针对处理网络请求过程采用了多线性，而数据的读写命令，仍然是单线程处理的。</p> 
</blockquote> 
<p>        采用了<strong>I/O多路复用机制</strong>，减少网络I/O消耗，大大提升了并发效率。</p> 
<h3 id="4.%E9%80%82%E7%94%A8%E5%9C%BA%E6%99%AF">4.适用场景</h3> 
<p>        Redis作为基于内存运行的数据库，是一个高性能的缓存，一般应用在session缓存、队列<br> 、排行榜、计数器、最近最热文章、最近最热评论、发布订阅等。</p> 
<p>        Redis 适用于数据实时性要求高、数据存储有过期和淘汰特征的、不需要持久化或者只需<br> 要保证弱一致性、逻辑简单的场景。</p> 
<h2 id="%E4%B8%89%E3%80%81Redis%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AE">三、Redis安装配置</h2> 
<pre><code class="language-bash">#将安装包放在/opt下
cd /opt
tar xf redis-5.0.7.tar.gz
cd redis-5.0.7/

#编译
make

#安装到指定目录
make install PREFIX=/usr/local/redis</code></pre> 
<p><img alt="" height="104" src="https://images2.imgbox.com/e4/0a/t7JMnPnk_o.png" width="721"></p> 
<p><strong>还需要到安装包中的utils/下，执行install_server.sh</strong></p> 
<p><img alt="" height="921" src="https://images2.imgbox.com/72/b0/Fd7nhyEa_o.png" width="1101"></p> 
<p><strong>再在配置文件/etc/redis/6379.conf中修改监听地址 </strong></p> 
<p><img alt="" height="299" src="https://images2.imgbox.com/8f/91/BdfNP1Up_o.png" width="833"></p> 
<p><img alt="" height="248" src="https://images2.imgbox.com/83/9a/27Lcp7mh_o.png" width="1200"></p> 
<h2 id="%E4%B8%89%E3%80%81Redis%E7%9A%84%E4%BD%BF%E7%94%A8">四、Redis的使用</h2> 
<table border="1" cellpadding="1" cellspacing="1"><thead><tr><th>工具</th><th>作用</th></tr></thead><tbody><tr><td>redis-server</td><td>用于启动redis的工具</td></tr><tr><td>redis-benchmark</td><td>用于检测redis在本机的运行效率</td></tr><tr><td>redis-check-aof</td><td>修复AOF持久化文件</td></tr><tr><td>redis-check-rdb</td><td>修复RDB持久化文件</td></tr><tr><td>redis-cli</td><td>redis命令行工具</td></tr></tbody></table> 
<h3 id="1.%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%B7%A5%E5%85%B7redis-cli%EF%BC%88%E7%99%BB%E5%BD%95%EF%BC%89">1.命令行工具redis-cli（登录）</h3> 
<p><img alt="" height="128" src="https://images2.imgbox.com/84/a9/xfJuBfGn_o.png" width="1132"></p> 
<h3 id="2.%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7redis-benchmark%EF%BC%88%E6%B5%8B%E8%AF%95%EF%BC%89">2.测试工具redis-benchmark（测试）</h3> 
<blockquote> 
 <p>redis-benchmark [选项] [选项值]<br>                                 -h        指定服务器主机名<br>                                 -p        指定服务器端口<br>                                 -s        指定服务器 socket<br>                                 -c        指定并发连接数<br>                                 -n        指定请求数<br>                                 -d        以字节的形式指定SET/GET值的数据大小<br>                                 -k        1代表keep alive保持连接 ；0代表reconnect重连<br>                                 -r         SET、GET、INCR 使用随机key ；SADD使用随机值<br>                                 -P        通过管道传输&lt;numreg&gt;请求<br>                                 -q         强制退出redis 仅显示query/sec值<br>                                 --csv    以CSV格式（，分割字段的文本）输出<br>                                 -l          生成循环，永久执行测试<br>                                 -t          仅运行以逗号分隔的测试命令列表<br>                                 -I          Idle模式（仅打开N个idle连接并等待）</p> 
</blockquote> 
<pre><code class="language-bash">#向IP地址为192.168.109.133、端口为6379的Redis服务器发送100个并发连接与100000个请求测试性能
redis-benchmark -h 192.168.116.10 -p 6379 -c 100 -n 100000
</code></pre> 
<p><img alt="" height="1077" src="https://images2.imgbox.com/bf/7b/r493ZGBx_o.png" width="1092"></p> 
<pre><code class="language-bash">#测试存取大小为100字节的数据包的性能
redis-benchmark -h 192.168.116.10 -p 6379 -q -d 100
</code></pre> 
<p><img alt="" height="474" src="https://images2.imgbox.com/ed/c6/VgfaaaJv_o.png" width="1136"></p> 
<pre><code class="language-bash">#测试本机上Redis服务在进行set与lpush操作时的性能
redis-benchmark -t set,lpush -n 100000 -q</code></pre> 
<p><img alt="" height="104" src="https://images2.imgbox.com/5a/89/9Dxzs9k1_o.png" width="916"></p> 
<h3 id="3.redis%E5%91%BD%E4%BB%A4%E7%9A%84%E4%BD%BF%E7%94%A8"><strong>3.redis命令的使用</strong></h3> 
<p><strong>（1）存入键值对</strong></p> 
<blockquote> 
 <p>SET 键 值</p> 
</blockquote> 
<p><img alt="" height="104" src="https://images2.imgbox.com/ef/5d/Lu0o1Xcj_o.png" width="501"></p> 
<p><strong>（2）获取键的值</strong></p> 
<blockquote> 
 <p>GET 键</p> 
</blockquote> 
<p><img alt="" height="101" src="https://images2.imgbox.com/8a/66/tsr5Hs0P_o.png" width="762"></p> 
<p><strong>（3）判断键的数据类型（redis默认数据类型为string）</strong></p> 
<blockquote> 
 <p>TYPE 键</p> 
</blockquote> 
<p><img alt="" height="56" src="https://images2.imgbox.com/28/4d/aUU01qg8_o.png" width="645"></p> 
<p><strong>Redis中的五大数据类型</strong></p> 
<table border="1" cellpadding="1" cellspacing="1"><thead><tr><th>名称</th><th>类型</th></tr></thead><tbody><tr><td>String</td><td>字符串</td></tr><tr><td>List</td><td>列表</td></tr><tr><td>Hash</td><td>散列</td></tr><tr><td>Set</td><td>无序集合</td></tr><tr><td>Sorted Set</td><td>有序集合</td></tr></tbody></table> 
<p><strong>（4）查看键</strong></p> 
<blockquote> 
 <p>KEYS *                  查看所有键</p> 
 <p>KEYS 通配符        查看通配符匹配的指定键</p> 
</blockquote> 
<p><img alt="" height="342" src="https://images2.imgbox.com/4f/8a/Brr8xhSq_o.png" width="768"></p> 
<p><strong>（5）判断键是否存在</strong></p> 
<blockquote> 
 <p>EXISTS 键</p> 
</blockquote> 
<p><img alt="" height="104" src="https://images2.imgbox.com/d6/55/B6diYYWC_o.png" width="770"></p> 
<p><strong>（6）删除键</strong></p> 
<blockquote> 
 <p>DEL 键</p> 
</blockquote> 
<p><img alt="" height="56" src="https://images2.imgbox.com/18/a2/rP8OvBXZ_o.png" width="717"></p> 
<p><strong>（7）修改键名</strong></p> 
<blockquote> 
 <p>RENAME 原键名 新键名     </p> 
 <p><strong>若要更改的新键名已存在，则会覆盖此键名的值（建议改名前先exists一下）或使用：</strong></p> 
 <p><strong>RENAMENX 原键名 新键名</strong>        <strong>//</strong><strong>修改前判断新键名是否存在，存在则返回0，不存在则返回1并执行修改</strong></p> 
</blockquote> 
<p><img alt="" height="58" src="https://images2.imgbox.com/14/97/5GNKf7x7_o.png" width="682"></p> 
<p><img alt="" height="198" src="https://images2.imgbox.com/54/b3/ueIoU4Ft_o.png" width="916"></p> 
<p><img alt="" height="53" src="https://images2.imgbox.com/f1/ed/JocJijKn_o.png" width="780"></p> 
<p><strong>（8）统计键数量</strong></p> 
<blockquote> 
 <p>DBSIZE</p> 
</blockquote> 
<p><img alt="" height="219" src="https://images2.imgbox.com/8f/e9/z9vc15iO_o.png" width="559"></p> 
<p><strong>（9）设置密码</strong></p> 
<blockquote> 
 <p>CONFIG SET REQUIREPASS 密码</p> 
</blockquote> 
<p><img alt="" height="361" src="https://images2.imgbox.com/8b/d6/1Lp0Ad1m_o.png" width="1002"></p> 
<blockquote> 
 <p>AUTH 密码       <strong> 登入后做验证</strong></p> 
</blockquote> 
<p><img alt="" height="177" src="https://images2.imgbox.com/e4/cf/Sn0zy8Cr_o.png" width="641"></p> 
<p><strong>（10）查看当前密码</strong></p> 
<blockquote> 
 <p> CONFIG GET REQUIREPASS</p> 
</blockquote> 
<p><img alt="" height="76" src="https://images2.imgbox.com/1a/83/uv5yw2ud_o.png" width="780"></p> 
<p><strong> （11）删除密码</strong></p> 
<blockquote> 
 <p> CONFIG SET REQUIREPASS ''</p> 
</blockquote> 
<p><img alt="" height="52" src="https://images2.imgbox.com/9b/4e/Yihlw5YS_o.png" width="920"></p> 
<h3 id="4.Redis%E5%A4%9A%E5%BA%93%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4">4.Redis多库常用命令</h3> 
<blockquote> 
 <p><strong>        Redis 支持多数据库，Redis默认情况下包含16个数据库，数据库名称是用数字0-15来依次命名的（默认登入是0号数据库）。多数据库相互独立，互不干扰。</strong></p> 
</blockquote> 
<p><strong>（1）切换数据库</strong></p> 
<blockquote> 
 <p> SELECT 库号</p> 
</blockquote> 
<p><img alt="" height="169" src="https://images2.imgbox.com/90/94/Sjj0L8QO_o.png" width="697"></p> 
<p><strong>（2） 将数据移动到指定库</strong></p> 
<blockquote> 
 <p>MOVE 键 库号</p> 
</blockquote> 
<p><img alt="" height="197" src="https://images2.imgbox.com/f8/33/EdS8XeTS_o.png" width="639"></p> 
<h2 id="%E4%BA%94%E3%80%81Redis%E6%80%A7%E8%83%BD%E7%AE%A1%E7%90%86">五、Redis性能管理</h2> 
<h3 id="1.%E6%9F%A5%E7%9C%8B%E5%86%85%E5%AD%98%E4%BD%BF%E7%94%A8">1.查看内存使用</h3> 
<blockquote> 
 <p>info memory</p> 
</blockquote> 
<p><img alt="" height="1015" src="https://images2.imgbox.com/c7/96/vWWvmnAw_o.png" width="1078"></p> 
<blockquote> 
 <p>mem fragmentation _ratio        #内存碎片率   = used memory_rss / used memoryused</p> 
 <p>memory _rss                            #是Redis向操作系统申请的内存。<br> used memory                           #是Redis中的数据占用的内存。<br> used memory peak                  # redis内存使用的峰值。</p> 
</blockquote> 
<h3 id="2.%E6%B8%85%E7%90%86%E5%86%85%E5%AD%98%E7%A2%8E%E7%89%87">2.清理内存碎片</h3> 
<h4 id="%EF%BC%881%EF%BC%89%E5%86%85%E5%AD%98%E7%A2%8E%E7%89%87%E5%A6%82%E4%BD%95%E4%BA%A7%E7%94%9F">（1）内存碎片如何产生</h4> 
<p>        Redis内部有自己的内存管理器，为了提高内存使用的效率，来对内存的申请和释放进行管理。</p> 
<p>        Redis中的值删除的时候，并没有把内存直接释放，交还给操作系统，而是交给了Redis内部有内存管理器。</p> 
<p>        Redis中申请内存的时候，也是先看自己的内存管理器中是否有足够的内存可用。</p> 
<p>        Redis的这种机制，提高了内存的使用率，但是会使Redis中有部分自己没在用，却不释放的内存，导致了内存碎片的发生。</p> 
<h4 id="%EF%BC%882%EF%BC%89%E5%86%85%E5%AD%98%E7%A2%8E%E7%89%87%E7%8E%87">（2）内存碎片率</h4> 
<p><strong>跟踪内存碎片率对理解Redis实例的资源性能是非常重要的</strong></p> 
<ul><li>内存碎片率在<strong>1到1.5</strong>之间是<strong>正常</strong>的，这个值表示内存碎片率比较低，也说明Redis没有发生内存交换。</li><li>内存碎片率<strong>超过1.5</strong>，说明Redis<strong>消耗了实际需要物理内存的150%</strong>，其中50%是内存碎片率。</li><li>内存碎片率<strong>低于1</strong>的，说明<strong>Redis内存分配超出了物理内存，操作系统正在进行内存交换</strong>。需要增加可用物理内存或减少Redis内存占用。</li></ul> 
<h4 id="%EF%BC%883%EF%BC%89%E6%B8%85%E7%90%86%E5%86%85%E5%AD%98%E7%A2%8E%E7%89%87">（3）清理内存碎片</h4> 
<p><strong>Redis版本4.0以下</strong></p> 
<p>        需要在 <strong>redis-cli工具上输入shutdown save 命令</strong>，让Redis数据库执行保存操作并关闭Redis服务，再重启服务器。Redis服务器重启后，Redis会将没用的内存归还给操作系统，碎片率会降下来。</p> 
<p><strong>Redis4.0版本以上</strong></p> 
<p>        执行 <strong>config set activedefrag yes</strong>，开启自动碎片清理；</p> 
<p>        执行 <strong>memory purge</strong>，手动碎片清理。</p> 
<h3 id="3.%E5%86%85%E5%AD%98%E4%BD%BF%E7%94%A8%E7%8E%87"><strong>3.内存使用率</strong></h3> 
<p>        redis实例的内存使用率超过可用最大内存，操作系统将开始进行内存与swap空间交换，导致性能大大降低。</p> 
<p><strong>避免内存交换发生的方法</strong></p> 
<ul><li>针对缓存数据大小选择安装 Redis实例</li><li>尽可能的使用Hash数据结构存储</li><li>设置key的TTL生命周期（setex 键名 时间(s) 值）</li></ul> 
<h3 id="4.%E5%86%85%E5%9B%9E%E6%94%B6key">4.内回收key</h3> 
<p>        内存清理策略，保证合理分配redis有限的内存资源。默认情况下回收策略是禁止删除，当达到设置的最大阀值时，需选择一种key的回收策略。</p> 
<p><strong>配置文件中修改maxmemory-policy属性值</strong></p> 
<p><img alt="" height="683" src="https://images2.imgbox.com/8b/49/GDzlnVBk_o.png" width="1097"></p> 
<table border="1" cellpadding="1" cellspacing="1"><tbody><tr><td>volatile-lru</td><td>使用LRU算法从已设置过期时间的数据集合中淘汰数据<strong>（移除最近最少使用的key，针对设置了TTL的key）</strong></td></tr><tr><td>volatile-ttl</td><td>从已设置过期时间的数据集合中挑选即将过期的数据淘汰<strong>（移除最近过期的key）</strong></td></tr><tr><td>volatile-random</td><td>从已设置过期时间的数据集合中随机挑选数据淘汰<strong>（在设置了TTL的key里随机移除）</strong></td></tr><tr><td>allkeys-lru</td><td>使用LRU算法从所有数据集合中淘汰数据<strong>（移除最少使用的key，针对所有的key）</strong></td></tr><tr><td>allkeys-random</td><td>从数据集合中任意选择数据淘汰<strong>（随机移除key)</strong></td></tr><tr><td>noenviction</td><td>禁止淘汰数据<strong>（不删除直到写满报错）</strong></td></tr></tbody></table> 
<p></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/a8d442e2307b05a221958a218984a77e/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">c语言的代码类型</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/b507e9e8c5536de5264965e27f70a10e/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">ChatGPT 1.0.0安卓逆向分析，仅限中国分享</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>