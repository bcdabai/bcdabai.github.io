<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>记一次PageHelper分页未生效问题排查 - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="记一次PageHelper分页未生效问题排查" />
<meta property="og:description" content="问题描述 最近在项目中使用PageHelper分页工具&#43;Mybatis实现分页查询逻辑，但是发现分页逻辑并没有生效，代码片段如下：
public PageDTO&lt;ChargeMetaDO&gt; pageByParams(SearchChargeReq searchChargeRequest, int pageNo, int pageSize) { PageHelper.startPage(pageNo, pageSize); ChargePOExample example = buildExample(searchChargeRequest); long total = chargeMapper.countByExample(example); List&lt;ChargeMetaDO&gt; chargeMetaDoList = selectByExample(example); return new PageDTO&lt;&gt;(total, chargeMetaDoList); } 这段代码中传入了查询参数和分页信息，并返回总页数和当前页号的数据。但是实际执行的时候返回了全部的数据。
修复方式 排查的时候发现，count代码通过mybatis生成的sql语句中包含了分页参数，但是select语句却没有，因此将查询数据列表的请求放在计算总数据行数前面即可解决这个问题。
public PageDTO&lt;ChargeMetaDO&gt; pageByParams(SearchChargeReq searchChargeRequest, int pageNo, int pageSize) { PageHelper.startPage(pageNo, pageSize); ChargePOExample example = buildExample(searchChargeRequest); // 需要先执行分页查询，再查询总数 List&lt;ChargeMetaDO&gt; chargeMetaDoList = selectByExample(example); long total = chargeMapper.countByExample(example); return new PageDTO&lt;&gt;(total, chargeMetaDoList); } 原因分析 这里阅读了一下PageHepler，简单介绍一下PageHelper是如何将分页信息塞入当查询请求中的。
在调用PageHelper.startPage方法后最终会进入这段逻辑：
protected static final ThreadLocal&lt;Page&gt; LOCAL_PAGE = new ThreadLocal(); public static &lt;E&gt; Page&lt;E&gt; startPage(int pageNum, int pageSize, boolean count, Boolean reasonable, Boolean pageSizeZero) { Page&lt;E&gt; page = new Page(pageNum, pageSize, count); page." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/7ec97841c8d262e7e1014a15a1428c02/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-06-23T13:58:31+08:00" />
<meta property="article:modified_time" content="2022-06-23T13:58:31+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">记一次PageHelper分页未生效问题排查</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <h2>问题描述</h2> 
<p>最近在项目中使用PageHelper分页工具+Mybatis实现分页查询逻辑，但是发现分页逻辑并没有生效，代码片段如下：</p> 
<pre><code>   public PageDTO&lt;ChargeMetaDO&gt; pageByParams(SearchChargeReq searchChargeRequest, int pageNo, int pageSize) {
        PageHelper.startPage(pageNo, pageSize);
        ChargePOExample example = buildExample(searchChargeRequest);
        long total = chargeMapper.countByExample(example);
        List&lt;ChargeMetaDO&gt; chargeMetaDoList = selectByExample(example);
        return new PageDTO&lt;&gt;(total, chargeMetaDoList);
    }</code></pre> 
<p>这段代码中传入了查询参数和分页信息，并返回总页数和当前页号的数据。但是实际执行的时候返回了全部的数据。</p> 
<h2>修复方式</h2> 
<p>排查的时候发现，count代码通过mybatis生成的sql语句中包含了分页参数，但是select语句却没有，因此将查询数据列表的请求放在计算总数据行数前面即可解决这个问题。</p> 
<pre><code>    public PageDTO&lt;ChargeMetaDO&gt; pageByParams(SearchChargeReq searchChargeRequest, int pageNo, int pageSize) {
        PageHelper.startPage(pageNo, pageSize);
        ChargePOExample example = buildExample(searchChargeRequest);
        // 需要先执行分页查询，再查询总数
        List&lt;ChargeMetaDO&gt; chargeMetaDoList = selectByExample(example);
        long total = chargeMapper.countByExample(example);
        return new PageDTO&lt;&gt;(total, chargeMetaDoList);
    }</code></pre> 
<h2>原因分析</h2> 
<p>这里阅读了一下PageHepler，简单介绍一下PageHelper是如何将分页信息塞入当查询请求中的。</p> 
<p>在调用PageHelper.startPage方法后最终会进入这段逻辑：</p> 
<pre><code>    protected static final ThreadLocal&lt;Page&gt; LOCAL_PAGE = new ThreadLocal();

    public static &lt;E&gt; Page&lt;E&gt; startPage(int pageNum, int pageSize, boolean count, Boolean reasonable, Boolean pageSizeZero) {
        Page&lt;E&gt; page = new Page(pageNum, pageSize, count);
        page.setReasonable(reasonable);
        page.setPageSizeZero(pageSizeZero);
        Page&lt;E&gt; oldPage = getLocalPage();
        if (oldPage != null &amp;&amp; oldPage.isOrderByOnly()) {
            page.setOrderBy(oldPage.getOrderBy());
        }

        setLocalPage(page);
        return page;
    }

    protected static void setLocalPage(Page page) {
        LOCAL_PAGE.set(page);
    }</code></pre> 
<p>这里要关注setLocalPage这个方法，这一行代码将分页的信息放入了当前线程上下文LOCAL_PAGE中，使得后续的同线程内查询可以从该变量中取到分页信息。</p> 
<p>那么这个分页信息是在哪里被编入到SQL的呢？PageHelper工具实现了一个mybatis的拦截器PageInterceptor，在请求经过该拦截器时会读取LOCAL_PAGE中的分页信息并写入到SQL中。这里通过Dialect接口进行了抽象，Dialect接口定义了在经过该切面时的各种行为（如是否跳过，执行前操作，执行后操作等），并子类PageHelper实现分页逻辑。</p> 
<pre><code>public class PageInterceptor implements Interceptor {
    public Object intercept(Invocation invocation) throws Throwable {
        try {
            Object[] args = invocation.getArgs();
            MappedStatement ms = (MappedStatement)args[0];
            Object parameter = args[1];
            RowBounds rowBounds = (RowBounds)args[2];
            ResultHandler resultHandler = (ResultHandler)args[3];
            Executor executor = (Executor)invocation.getTarget();
            CacheKey cacheKey;
            BoundSql boundSql;
            if (args.length == 4) {
                boundSql = ms.getBoundSql(parameter);
                cacheKey = executor.createCacheKey(ms, parameter, rowBounds, boundSql);
            } else {
                cacheKey = (CacheKey)args[4];
                boundSql = (BoundSql)args[5];
            }

            this.checkDialectExists();
            List resultList;
            // 需要跳过该Dialect
            if (!this.dialect.skip(ms, parameter, rowBounds)) {
                // 是否要执行count操作
                if (this.dialect.beforeCount(ms, parameter, rowBounds)) {
                    // 计算数据总量
                    Long count = this.count(executor, ms, parameter, rowBounds, resultHandler, boundSql);
                    // 判断是否需要执行count后的逻辑
                    if (!this.dialect.afterCount(count, parameter, rowBounds)) {
                        // 无需执行分页，直接返回
                        Object var12 = this.dialect.afterPage(new ArrayList(), parameter, rowBounds);
                        return var12;
                    }
                }

                // 分页查询数据
                resultList = ExecutorUtil.pageQuery(this.dialect, executor, ms, parameter, rowBounds, resultHandler, boundSql, cacheKey);
            } else {
                // rowBounds用参数值，不使用分页插件处理
                resultList = executor.query(ms, parameter, rowBounds, resultHandler, cacheKey, boundSql);
            }

            // 分页结束，返回结果
            Object var16 = this.dialect.afterPage(resultList, parameter, rowBounds);
            return var16;
        } finally {
            // 分页操作的收尾工作
            if (this.dialect != null) {
                this.dialect.afterAll();
            }

        }
    }

     private Long count(Executor executor, MappedStatement ms, Object parameter,
                       RowBounds rowBounds, ResultHandler resultHandler,
                       BoundSql boundSql) throws SQLException {
        String countMsId = ms.getId() + countSuffix;
        Long count;
        //先判断是否存在手写的 count 查询
        MappedStatement countMs = ExecutorUtil.getExistedMappedStatement(ms.getConfiguration(), countMsId);
        if (countMs != null) {
            count = ExecutorUtil.executeManualCount(executor, countMs, parameter, boundSql, resultHandler);
        } else {
            // 优先获取缓存的SQL语句，减少重新生成的成本
            countMs = msCountMap.get(countMsId);
            //自动创建
            if (countMs == null) {
                //拼接count语句
                countMs = MSUtils.newCountMappedStatement(ms, countMsId);
                msCountMap.put(countMsId, countMs);
            }
            // 执行count语句
            count = ExecutorUtil.executeAutoCount(dialect, executor, countMs, parameter, boundSql, rowBounds, resultHandler);
        }
        return count;
    }
}</code></pre> 
<p>上文中对关键行增加了注释，可以看到intercept方法其实就是对Dialect的几个方法进行编排：</p> 
<pre><code>public interface Dialect {
    /**
     * 跳过 count 和 分页查询
     *
     * @param ms              MappedStatement
     * @param parameterObject 方法参数
     * @param rowBounds       分页参数
     * @return true 跳过，返回默认查询结果，false 执行分页查询
     */
    boolean skip(MappedStatement ms, Object parameterObject, RowBounds rowBounds);

    /**
     * 执行分页前，返回 true 会进行 count 查询，false 会继续下面的 beforePage 判断
     *
     * @param ms              MappedStatement
     * @param parameterObject 方法参数
     * @param rowBounds       分页参数
     * @return
     */
    boolean beforeCount(MappedStatement ms, Object parameterObject, RowBounds rowBounds);


    /**
     * 执行完 count 查询后
     *
     * @param count           查询结果总数
     * @param parameterObject 接口参数
     * @param rowBounds       分页参数
     * @return true 继续分页查询，false 直接返回
     */
    boolean afterCount(long count, Object parameterObject, RowBounds rowBounds);

    /**
     * 执行分页前，返回 true 会进行分页查询，false 会返回默认查询结果
     *
     * @param ms              MappedStatement
     * @param parameterObject 方法参数
     * @param rowBounds       分页参数
     * @return
     */
    boolean beforePage(MappedStatement ms, Object parameterObject, RowBounds rowBounds);

    /**
     * 生成分页查询 sql
     *
     * @param ms              MappedStatement
     * @param boundSql        绑定 SQL 对象
     * @param parameterObject 方法参数
     * @param rowBounds       分页参数
     * @param pageKey         分页缓存 key
     * @return
     */
    String getPageSql(MappedStatement ms, BoundSql boundSql, Object parameterObject, RowBounds rowBounds, CacheKey pageKey);

    /**
     * 分页查询后，处理分页结果，拦截器中直接 return 该方法的返回值
     *
     * @param pageList        分页查询结果
     * @param parameterObject 方法参数
     * @param rowBounds       分页参数
     * @return
     */
    Object afterPage(List pageList, Object parameterObject, RowBounds rowBounds);

    /**
     * 完成所有任务后
     */
    void afterAll();

    /**
     * 设置参数
     *
     * @param properties 插件属性
     */
    void setProperties(Properties properties);
}</code></pre> 
<p>PageHelper中主要是对PageAutoDialect加了一层代理实现，二者的代码如下：</p> 
<pre><code>public class PageHelper extends PageMethod implements Dialect {
    private PageParams pageParams;
    private PageAutoDialect autoDialect;

    @Override
    public boolean skip(MappedStatement ms, Object parameterObject, RowBounds rowBounds) {
        if (ms.getId().endsWith(MSUtils.COUNT)) {
            throw new RuntimeException("在系统中发现了多个分页插件，请检查系统配置!");
        }
        // 获取上下文中的分页信息
        Page page = pageParams.getPage(parameterObject, rowBounds);
        if (page == null) {
            // 上下文中无分页信息，跳过分页拦截器
            return true;
        } else {
            //设置默认的 count 列
            if (StringUtil.isEmpty(page.getCountColumn())) {
                page.setCountColumn(pageParams.getCountColumn());
            }
            autoDialect.initDelegateDialect(ms);
            return false;
        }
    }

    /**
    * 代理模式
    */
    @Override
    public boolean beforeCount(MappedStatement ms, Object parameterObject, RowBounds rowBounds) {
        return autoDialect.getDelegate().beforeCount(ms, parameterObject, rowBounds);
    }

    /**
    * 代理模式
    */
    @Override
    public boolean afterCount(long count, Object parameterObject, RowBounds rowBounds) {
        return autoDialect.getDelegate().afterCount(count, parameterObject, rowBounds);
    }

    @Override
    public boolean beforePage(MappedStatement ms, Object parameterObject, RowBounds rowBounds) {
        return autoDialect.getDelegate().beforePage(ms, parameterObject, rowBounds);
    }

    @Override
    public String getPageSql(MappedStatement ms, BoundSql boundSql, Object parameterObject, RowBounds rowBounds, CacheKey pageKey) {
        return autoDialect.getDelegate().getPageSql(ms, boundSql, parameterObject, rowBounds, pageKey);
    }

    public String getPageSql(String sql, Page page, RowBounds rowBounds, CacheKey pageKey) {
        return autoDialect.getDelegate().getPageSql(sql, page, pageKey);
    }

    @Override
    public Object afterPage(List pageList, Object parameterObject, RowBounds rowBounds) {
        //这个方法即使不分页也会被执行，所以要判断 null
        AbstractHelperDialect delegate = autoDialect.getDelegate();
        if (delegate != null) {
            return delegate.afterPage(pageList, parameterObject, rowBounds);
        }
        return pageList;
    }

    @Override
    public void afterAll() {
        AbstractHelperDialect delegate = autoDialect.getDelegate();
        if (delegate != null) {
            delegate.afterAll();
            autoDialect.clearDelegate();
        }
        // 清理线程上下文中的分页信息，防止影响后续的调用
        clearPage();
    }
}


public abstract class AbstractHelperDialect extends AbstractDialect implements Constant {

    /**
     * 获取分页参数
     *
     * @param &lt;T&gt;
     * @return
     */
    public &lt;T&gt; Page&lt;T&gt; getLocalPage() {
        return PageHelper.getLocalPage();
    }

    @Override
    public final boolean skip(MappedStatement ms, Object parameterObject, RowBounds rowBounds) {
        //该方法不会被调用
        return true;
    }

    @Override
    public boolean beforeCount(MappedStatement ms, Object parameterObject, RowBounds rowBounds) {
        // page配置中要求count
        Page page = getLocalPage();
        return !page.isOrderByOnly() &amp;&amp; page.isCount();
    }


    @Override
    public boolean afterCount(long count, Object parameterObject, RowBounds rowBounds) {
        Page page = getLocalPage();
        page.setTotal(count);
        if (rowBounds instanceof PageRowBounds) {
            ((PageRowBounds) rowBounds).setTotal(count);
        }
        //pageSize &lt; 0 的时候，不执行分页查询
        //pageSize = 0 的时候，还需要执行后续查询，但是不会分页
        if (page.getPageSize() &lt; 0) {
            return false;
        }
        return count &gt; ((page.getPageNum() - 1) * page.getPageSize());
    }


    @Override
    public boolean beforePage(MappedStatement ms, Object parameterObject, RowBounds rowBounds) {
        Page page = getLocalPage();
        // 页数大于0，需要进行分页查询
        if (page.isOrderByOnly() || page.getPageSize() &gt; 0) {
            return true;
        }
        return false;
    }

    // 该方法会在当前SQL后面添加上分页信息，需要查看MySqlDialect子类的实现
    @Override
    public String getPageSql(MappedStatement ms, BoundSql boundSql, Object parameterObject, RowBounds rowBounds, CacheKey pageKey) {
        String sql = boundSql.getSql();
        Page page = getLocalPage();
        //支持 order by
        String orderBy = page.getOrderBy();
        if (StringUtil.isNotEmpty(orderBy)) {
            pageKey.update(orderBy);
            sql = OrderByParser.converToOrderBySql(sql, orderBy);
        }
        if (page.isOrderByOnly()) {
            return sql;
        }
        return getPageSql(sql, page, pageKey);
    }


    @Override
    public Object afterPage(List pageList, Object parameterObject, RowBounds rowBounds) {
        Page page = getLocalPage();
        if (page == null) {
            return pageList;
        }
        page.addAll(pageList);
        if (!page.isCount()) {
            page.setTotal(-1);
        } else if ((page.getPageSizeZero() != null &amp;&amp; page.getPageSizeZero()) &amp;&amp; page.getPageSize() == 0) {
            page.setTotal(pageList.size());
        } else if(page.isOrderByOnly()){
            page.setTotal(pageList.size());
        }
        return page;
    }

    @Override
    public void afterAll() {

    }

     @Override
    public String getPageSql(String sql, Page page, CacheKey pageKey) {
        StringBuilder sqlBuilder = new StringBuilder(sql.length() + 14);
        sqlBuilder.append(sql);
        if (page.getStartRow() == 0) {
            sqlBuilder.append(" LIMIT ? ");
        } else {
            sqlBuilder.append(" LIMIT ?, ? ");
        }
        return sqlBuilder.toString();
    }
}</code></pre> 
<h2>总结</h2> 
<p>PageHelper本质上是通过线程上下文变量来实现，并且仅生效于设置分页参数后的第一条SQL。因此需要先执行分页查询，再执行count。</p> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/8a/3d/djQhFu9n_o.jpg"></p> 
<p> </p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/66d172fa4ddbd9fdc985b451b1029bb6/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">基于Java Web的图书管理系统</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/51a338638f8b785830918eba9f4d22af/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">antdv select 样式改变</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>