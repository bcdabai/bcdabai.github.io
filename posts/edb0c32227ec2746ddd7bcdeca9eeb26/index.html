<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Spring 教程（二） - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Spring 教程（二）" />
<meta property="og:description" content="一、Spring AOP介绍 开发其实就是在不断的重构，抽象重复代码，然后进行封装。从最原始的模块化编程到面向对象编程，代码的封装越来越整齐清晰，但是依然存在重复的代码，而这些重复代码几乎都是与业务逻辑无关的系统逻辑代码。比如在数据操作类中的插入、更新、删除数据等方法中都存在数据库事务的处理，重要业务逻辑方法中都有日志记录的逻辑等等。每个应用系统都存在着这种系统级的重复逻辑代码，而我们并没有更好的方法去将这些代码抽象出来并进行管理。然而AOP的出现弥补了这一缺陷，AOP可以在不改变原有业务逻辑代码的情况下对原有业务进行横切拦截，处理那些重复的系统逻辑。 与Ioc容器一样，AOP也是Spring的核心模块之一。AOP是Aspect-Oriented Programming的简称，现在通常称为面向切面编程。我们学了OOP，面向对象编程，而AOP并非是OOP的替代技术，它只是OOP的一个有益补充。 需要指出的是AOP的应用场合是受限的，它一般只适合于那些具有横切逻辑的应用场合：如性能监测、访问控制、事务管理以及日志记录，它并不适合处理具体的业务逻辑，分散处理业务逻辑会使得逻辑混乱、增加维护成本。 二、如何使用Spring AOP 下面以对用户操作类UserDao的AOP拦截演示Spring AOP的使用。 1、创建Java项目，添加Spring AOP依赖支持 aopalliance-1.0.jar commons-logging-1.1.1.jar spring-aop-3.2.0.RELEASE.jar spring-beans-3.2.0.RELEASE.jar spring-context-3.2.0.RELEASE.jar spring-core-3.2.0.RELEASE.jar spring-expression-3.2.0.RELEASE.jar 2、添加User及UserDao类 User类： public class User { private Integer id; private String name; } UserDao类： public class UserDao { public void save(User user){ System.out.println(&#34;save user....&#34;); } public void delete(int id){ System.out.println(&#34;delete user....&#34;); } public void update(User user) { System.out.println(&#34;update user ....&#34;); } public User query(String name) { System.out.println(&#34;getUser ....&#34;); return new User(); } } 3、添加AOP拦截处理 AOP前置通知： public class UserBeforeAdvice implements MethodBeforeAdvice { public void before(Method method, Object[] args, Object target) { System." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/edb0c32227ec2746ddd7bcdeca9eeb26/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2014-10-27T15:35:00+08:00" />
<meta property="article:modified_time" content="2014-10-27T15:35:00+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Spring 教程（二）</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <div id="cnblogs_post_body" class="blogpost-body"> 
 <div> 
  <div> 
   <strong>一、Spring AOP介绍</strong> 
  </div> 
  <div>
    开发其实就是在不断的重构，抽象重复代码，然后进行封装。从最原始的模块化编程到面向对象编程，代码的封装越来越整齐清晰，但是依然存在重复的代码，而这些重复代码几乎都是与业务逻辑无关的系统逻辑代码。比如在数据操作类中的插入、更新、删除数据等方法中都存在数据库事务的处理，重要业务逻辑方法中都有日志记录的逻辑等等。每个应用系统都存在着这种系统级的重复逻辑代码，而我们并没有更好的方法去将这些代码抽象出来并进行管理。然而AOP的出现弥补了这一缺陷，AOP可以在不改变原有业务逻辑代码的情况下对原有业务进行横切拦截，处理那些重复的系统逻辑。 
  </div> 
  <div>
      
  </div> 
 </div> 
 <div> 
  <div>
    与Ioc容器一样，AOP也是Spring的核心模块之一。AOP是Aspect-Oriented Programming的简称，现在通常称为面向切面编程。我们学了OOP，面向对象编程，而AOP并非是OOP的替代技术，它只是OOP的一个有益补充。 
  </div> 
  <div>
      
  </div> 
  <div> 
   <div>
     需要指出的是AOP的应用场合是受限的，它一般只适合于那些具有横切逻辑的应用场合：如性能监测、访问控制、事务管理以及日志记录，它并不适合处理具体的业务逻辑，分散处理业务逻辑会使得逻辑混乱、增加维护成本。 
   </div> 
   <div>
       
   </div> 
   <div>
       
   </div> 
   <div> 
    <strong>二、如何使用Spring AOP</strong> 
   </div> 
   <div>
     下面以对用户操作类UserDao的AOP拦截演示Spring AOP的使用。 
   </div> 
   <div>
     1、创建Java项目，添加Spring AOP依赖支持 
   </div> 
   <div> 
    <div>
      aopalliance-1.0.jar 
    </div> 
    <div>
      commons-logging-1.1.1.jar 
    </div> 
    <div>
      spring-aop-3.2.0.RELEASE.jar 
    </div> 
    <div>
      spring-beans-3.2.0.RELEASE.jar 
    </div> 
    <div>
      spring-context-3.2.0.RELEASE.jar 
    </div> 
    <div>
      spring-core-3.2.0.RELEASE.jar 
    </div> 
    <div>
      spring-expression-3.2.0.RELEASE.jar 
    </div> 
   </div> 
   <div>
       
   </div> 
   <div>
     2、添加User及UserDao类 
   </div> 
   <div>
     User类： 
   </div> 
   <div> 
    <div class="dp-highlighter bg_java"> 
     <ol class="dp-j" start="1"><li class="alt"><span class="keyword">public <span class="keyword">class User {  </span></span></li><li>    <span class="keyword">private Integer id;  </span></li><li class="alt">    <span class="keyword">private String name;  </span></li><li>}  </li></ol> 
    </div> 
   </div> 
   <div>
     UserDao类： 
   </div> 
   <div> 
    <div class="dp-highlighter bg_java"> 
     <ol class="dp-j" start="1"><li class="alt"><span class="keyword">public <span class="keyword">class UserDao {  </span></span></li><li>    <span class="keyword">public <span class="keyword">void save(User user){  </span></span></li><li class="alt">        System.out.println(<span class="string">"save user....");  </span></li><li>    }  </li><li class="alt">      </li><li>    <span class="keyword">public <span class="keyword">void delete(<span class="keyword">int id){  </span></span></span></li><li class="alt">        System.out.println(<span class="string">"delete user....");  </span></li><li>    }  </li><li class="alt">      </li><li>    <span class="keyword">public <span class="keyword">void update(User user) {  </span></span></li><li class="alt">        System.out.println(<span class="string">"update user ....");  </span></li><li>    }  </li><li class="alt">      </li><li>    <span class="keyword">public User query(String name) {  </span></li><li class="alt">        System.out.println(<span class="string">"getUser ....");  </span></li><li>        <span class="keyword">return <span class="keyword">new User();  </span></span></li><li class="alt">    }  </li><li>}  </li></ol> 
    </div> 
   </div> 
   <div>
     3、添加AOP拦截处理 
   </div> 
   <div> 
    <div>
      AOP前置通知： 
    </div> 
    <div> 
     <div class="dp-highlighter bg_java"> 
      <ol class="dp-j" start="1"><li class="alt"><span class="keyword">public <span class="keyword">class UserBeforeAdvice <span class="keyword">implements MethodBeforeAdvice {      </span></span></span></li><li>    <span class="keyword">public <span class="keyword">void before(Method method, Object[] args, Object target) {  </span></span></li><li class="alt">        System.out.println(<span class="string">"调用方法："+method.getName() + <span class="string">"()前拦截处理");  </span></span></li><li>    }     </li><li class="alt">}  </li></ol> 
     </div> 
    </div> 
    <div>
      AOP后置通知： 
    </div> 
    <div> 
     <div class="dp-highlighter bg_java"> 
      <ol class="dp-j" start="1"><li class="alt"><span class="keyword">public <span class="keyword">class UserAfterAdvice <span class="keyword">implements AfterReturningAdvice {  </span></span></span></li><li>    <span class="keyword">public <span class="keyword">void afterReturning(Object returnValue, Method method, Object[] args, Object target) {  </span></span></li><li class="alt">        System.out.println(<span class="string">"方法："+method.getName() + <span class="string">"()返回后拦截处理");  </span></span></li><li>    }  </li><li class="alt">}  </li></ol> 
     </div> 
    </div> 
    <div>
      AOP环绕通知： 
    </div> 
    <div> 
     <div class="dp-highlighter bg_java"> 
      <ol class="dp-j" start="1"><li class="alt"><span class="keyword">public <span class="keyword">class UserAroundAdvice <span class="keyword">implements MethodInterceptor {  </span></span></span></li><li>    <span class="keyword">public Object invoke(MethodInvocation invocation) <span class="keyword">throws Throwable {  </span></span></li><li class="alt">        System.out.println(<span class="string">"调用方法："+invocation.getMethod().getName() + <span class="string">"()前拦截处理");  </span></span></li><li>        Object o = invocation.proceed();  </li><li class="alt">        System.out.println(<span class="string">"调用方法："+invocation.getMethod().getName() + <span class="string">"()后拦截处理");  </span></span></li><li>        <span class="keyword">return o;  </span></li><li class="alt">    }  </li><li>}  </li></ol> 
     </div> 
    </div> 
   </div> 
   <div>
     4、添加Spring配置文件applicationContext.xml 
   </div> 
   <div> 
    <div class="dp-highlighter bg_html"> 
     <ol class="dp-xml" start="1"><li class="alt"><span class="tag">&lt;?<span class="tag-name">xml <span class="attribute">version=<span class="attribute-value">"1.0" <span class="attribute">encoding=<span class="attribute-value">"UTF-8"<span class="tag">?&gt;  </span></span></span></span></span></span></span></li><li><span class="tag">&lt;<span class="tag-name">beans <span class="attribute">xmlns=<span class="attribute-value">"http://www.springframework.org/schema/beans"  </span></span></span></span></li><li class="alt">       <span class="attribute">xmlns:xsi=<span class="attribute-value">"http://www.w3.org/2001/XMLSchema-instance"  </span></span></li><li>       <span class="attribute">xsi:schemaLocation="http://www.springframework.org/schema/beans   </span></li><li class="alt">           http://www.springframework.org/schema/beans/spring-beans-3.2.xsd"<span class="tag">&gt;  </span></li><li>    <span class="tag">&lt;<span class="tag-name">bean <span class="attribute">id=<span class="attribute-value">"userDaoTarget" <span class="attribute">class=<span class="attribute-value">"com.boya.spring.dao.UserDao" <span class="tag">/&gt;  </span></span></span></span></span></span></span></li><li class="alt">    <span class="tag">&lt;<span class="tag-name">bean <span class="attribute">id=<span class="attribute-value">"userBeforeAdvice" <span class="attribute">class=<span class="attribute-value">"com.boya.spring.aop.UserBeforeAdvice" <span class="tag">/&gt;  </span></span></span></span></span></span></span></li><li>    <span class="tag">&lt;<span class="tag-name">bean <span class="attribute">id=<span class="attribute-value">"userAfterAdvice" <span class="attribute">class=<span class="attribute-value">"com.boya.spring.aop.UserAfterAdvice" <span class="tag">/&gt;  </span></span></span></span></span></span></span></li><li class="alt">    <span class="tag">&lt;<span class="tag-name">bean <span class="attribute">id=<span class="attribute-value">"userAroundAdvice" <span class="attribute">class=<span class="attribute-value">"com.boya.spring.aop.UserAroundAdvice" <span class="tag">/&gt;  </span></span></span></span></span></span></span></li><li>    <span class="tag">&lt;<span class="tag-name">bean <span class="attribute">id=<span class="attribute-value">"userDao" <span class="attribute">class=<span class="attribute-value">"org.springframework.aop.framework.ProxyFactoryBean"<span class="tag">&gt;  </span></span></span></span></span></span></span></li><li class="alt">        <span class="tag">&lt;<span class="tag-name">property <span class="attribute">name=<span class="attribute-value">"interceptorNames"<span class="tag">&gt;  </span></span></span></span></span></li><li>            <span class="tag">&lt;<span class="tag-name">list<span class="tag">&gt;<span class="tag">&lt;<span class="tag-name">value<span class="tag">&gt;userAroundAdvice<span class="tag">&lt;/<span class="tag-name">value<span class="tag">&gt;<span class="tag">&lt;/<span class="tag-name">list<span class="tag">&gt;  </span></span></span></span></span></span></span></span></span></span></span></span></li><li class="alt">        <span class="tag">&lt;/<span class="tag-name">property<span class="tag">&gt;  </span></span></span></li><li>        <span class="tag">&lt;<span class="tag-name">property <span class="attribute">name=<span class="attribute-value">"target" <span class="attribute">ref=<span class="attribute-value">"userDaoTarget"<span class="tag">&gt;<span class="tag">&lt;/<span class="tag-name">property<span class="tag">&gt;  </span></span></span></span></span></span></span></span></span></span></li><li class="alt">    <span class="tag">&lt;/<span class="tag-name">bean<span class="tag">&gt;  </span></span></span></li><li><span class="tag">&lt;/<span class="tag-name">beans<span class="tag">&gt;  </span></span></span></li></ol> 
    </div> 
   </div> 
   <div>
     5、测试AOP 
   </div> 
   <div> 
    <div class="dp-highlighter bg_java"> 
     <ol class="dp-j" start="1"><li class="alt"><span class="keyword">public <span class="keyword">static <span class="keyword">void main(String[] args) {  </span></span></span></li><li>    ApplicationContext context = <span class="keyword">new ClassPathXmlApplicationContext(<span class="string">"classpath:applicationContext.xml");  </span></span></li><li class="alt">    UserDao userDao = context.getBean(<span class="string">"userDao", UserDao.<span class="keyword">class);  </span></span></li><li>    userDao.save(<span class="keyword">new User());  </span></li><li class="alt">}  </li></ol> 
    </div> 
   </div> 
   <div>
     输出结果： 
   </div> 
   <blockquote dir="ltr"> 
    <div>
      调用方法：save()前拦截处理 
    </div> 
    <div>
      save user.... 
    </div> 调用方法：save()后拦截处理 
   </blockquote> 
   <div>
       
   </div> 
   <div>
     回过头来再看刚才的示例。 
   </div> 
   <div>
     1、首先，原来的业务逻辑代码不变 
   </div> 
   <div>
         不再关心重复的系统逻辑代码 
   </div> 
   <div>
     2、编写AOP切面处理逻辑 
   </div> 
   <div>
         把原业务逻辑中的重复代码抽象出来，封装入切面代码中，如上面示例的三种Advice通知封装不同的系统处理逻辑。 
   </div> 
   <div>
         前置通知：实现MethodBeforeAdvice 接口，在调用业务方法前调用该接口 
   </div> 
   <div>
         后置通知：实现AfterReturningAdvice 接口，在业务方法返回后调用该接口，在该接口中可以查看返回值（但不能修改返回值） 
   </div> 
   <div>
         环绕通知：实现MethodInterceptor 接口，在该接口中invocation.proceed();这个方法会调用真实对象的方法 
    <br>3、使用Spring配置文件将业务逻辑和AOP切面逻辑进行组装 
   </div> 
   <div>
         AOP代理Bean类型需要设置为org.springframework.aop.framework.ProxyFactoryBean 
   </div> 
   <div>
         必须设置代理目标（target属性设置）和通知类型（interceptorNames属性设置） 
   </div> 
   <div>
         代理目标并非必须实现接口，作为POJO被代理时，会对目标所有方法进行拦截 
   </div> 
   <div>
       
   </div> 
   <div> 
    <strong>三、AOP实现原理</strong> 
   </div> 
   <div>
     Spring AOP是基于Java反射和动态代理实现的。在讲解动态代理之前，我们先回顾一下代理模式。 
   </div> 
   <div>
     代理模式，就是为某一对象提供一个代理，通过代理操作该对象的方法。通常情况下，真实对象和代理对象需要实现相同的接口，在代理对象中保存真实对象的引用，以此来控制操作真实对象。 
   </div> 
   <div>
       
   </div> 
   <div>
     我们以班长代理老师签到来演示代理模式。 
   </div> 
   <div>
     创建签到接口： 
   </div> 
   <div> 
    <div class="dp-highlighter bg_java"> 
     <ol class="dp-j" start="1"><li class="alt"><span class="keyword">public <span class="keyword">interface SignInterface {  </span></span></li><li>    <span class="keyword">public Object sign(String nameList);  </span></li><li class="alt">}  </li></ol> 
    </div> 
   </div> 
   <div>
     创建真实对象，Teacher类： 
   </div> 
   <div> 
    <div class="dp-highlighter bg_java"> 
     <ol class="dp-j" start="1"><li class="alt"><span class="keyword">public   <span class="keyword">class  Teacher  <span class="keyword">implements  SignInterface {  </span></span></span></li><li>     <span class="keyword">public  Object sign(String nameList) {  </span></li><li class="alt">        System. out .println( <span class="string">"Teacher sign..." );  </span></li><li>         <span class="keyword">return   <span class="keyword">new  Object();  </span></span></li><li class="alt">    }  </li><li>}  </li></ol> 
    </div> 
   </div> 
   <div>
     创建代理对象，Leader类： 
   </div> 
   <div> 
    <div class="dp-highlighter bg_java"> 
     <ol class="dp-j" start="1"><li class="alt"><span class="keyword">public <span class="keyword">class Leader <span class="keyword">implements SignInterface {  </span></span></span></li><li>    <span class="keyword">private Teacher teacher;  </span></li><li class="alt">    <span class="keyword">public Object sign(String nameList) {  </span></li><li>        <span class="keyword">if (teacher == <span class="keyword">null) {  </span></span></li><li class="alt">            teacher = <span class="keyword">new Teacher();  </span></li><li>        }  </li><li class="alt">        Object o = teacher.sign(nameList);  </li><li>        <span class="keyword">return o;  </span></li><li class="alt">    }  </li><li>}  </li></ol> 
    </div> 
   </div> 
   <div>
     测试代理： 
   </div> 
   <div> 
    <div class="dp-highlighter bg_java"> 
     <ol class="dp-j" start="1"><li class="alt"><span class="keyword">public <span class="keyword">static <span class="keyword">void main(String[] args) {  </span></span></span></li><li>    SignInterface s = <span class="keyword">new Leader();  </span></li><li class="alt">    s.sign(<span class="string">"names");  </span></li><li>}  </li></ol> 
    </div> 
   </div> 
   <div>
     以上就是一个代理模式的例子，代理类在编译时就已经被创建了，而动态代理是在运行时动态创建代理类来实现代理模式。如下代码： 
   </div> 
   <div> 
    <div class="dp-highlighter bg_java"> 
     <ol class="dp-j" start="1"><li class="alt"><span class="keyword">public <span class="keyword">class ProxyObject <span class="keyword">implements InvocationHandler {  </span></span></span></li><li>    <span class="keyword">private Object proxy_obj;  </span></li><li class="alt">    ProxyObject(Object obj) {  </li><li>        <span class="keyword">this.proxy_obj = obj;  </span></li><li class="alt">    }  </li><li>    <span class="keyword">public <span class="keyword">static Object getProxy(Object obj) {  </span></span></li><li class="alt">        Class cls = obj.getClass();  </li><li>        <span class="comment">// 通过Proxy类的newProxyInstance方法来返回代理对象  </span></li><li class="alt">        <span class="keyword">return Proxy.newProxyInstance(cls.getClassLoader(), cls.getInterfaces(), <span class="keyword">new ProxyObject(obj));  </span></span></li><li>    }  </li><li class="alt">    <span class="comment">/** </span></li><li><span class="comment">     * 实现InvocationHandler接口的invoke </span></li><li class="alt"><span class="comment">     */  </span></li><li>    <span class="keyword">public Object invoke(Object proxy, Method method, Object[] args) <span class="keyword">throws Throwable {  </span></span></li><li class="alt">        System.out.println(<span class="string">"调用方法:" + method + <span class="string">"()之前拦截处理");  </span></span></li><li>        <span class="keyword">if (args != <span class="keyword">null) {  </span></span></li><li class="alt">            System.out.println(<span class="string">"方法有" + args.length + <span class="string">"个参数");  </span></span></li><li>            <span class="keyword">for (<span class="keyword">int i = <span class="number">0; i &lt; args.length; i++) {  </span></span></span></li><li class="alt">                System.out.println(args[i]);  </li><li>            }  </li><li class="alt">        }  </li><li>        <span class="comment">// 利用反射机制动态调用真实对象的方法  </span></li><li class="alt">        Object o = method.invoke(proxy_obj, args);  </li><li>        System.out.println(<span class="string">"调用方法:" + method + <span class="string">"()之后拦截处理");  </span></span></li><li class="alt">        <span class="keyword">return o;  </span></li><li>    }  </li><li class="alt">    <span class="comment">// 测试代码  </span></li><li>    <span class="keyword">public <span class="keyword">static <span class="keyword">void main(String agr[]) {  </span></span></span></li><li class="alt">        SignInterface si = (SignInterface) getProxy(<span class="keyword">new Teacher());  </span></li><li>        si.sign(<span class="string">"names");  </span></li><li class="alt">    }  </li><li>}  </li></ol> 
    </div> 
   </div> 
   <div>
     以上就是使用JDK的Proxy实现的动态代理，不过JDK的动态代理实现只支持针对接口的动态代理实现。Spring AOP实现默认也是动态代理方式，不过，Spring AOP支持CGLib Proxy的实现方式，可以针对POJO进行动态代理，实现AOP拦截。 
   </div> 
   <div>
       
   </div> 
   <div>
     我们来看一下CGLib实现的一个简单AOP拦截 
   </div> 
   <div>
     创建业务POJO： 
   </div> 
   <div> 
    <div class="dp-highlighter bg_java"> 
     <ol class="dp-j" start="1"><li class="alt"><span class="keyword">public <span class="keyword">class CGLibTeacher {  </span></span></li><li>    <span class="keyword">public Object sign(String nameList) {  </span></li><li class="alt">        System.out.println(<span class="string">"Teacher sign...");  </span></li><li>        <span class="keyword">return <span class="keyword">new Object();  </span></span></li><li class="alt">    }  </li><li>}  </li></ol> 
    </div> 
   </div> 
   <div>
     创建AOP拦截： 
   </div> 
   <div> 
    <div class="dp-highlighter bg_java"> 
     <ol class="dp-j" start="1"><li class="alt"><span class="keyword">public <span class="keyword">class CGLibAop <span class="keyword">implements MethodInterceptor {  </span></span></span></li><li>        <span class="keyword">public Object intercept(Object arg0, Method arg1, Object[] arg2,     </span></li><li class="alt">                MethodProxy arg3) <span class="keyword">throws Throwable {     </span></li><li>            System.out.println(<span class="string">"before...");  </span></li><li class="alt">            Object o = arg3.invokeSuper(arg0, arg2);  </li><li>            System.out.println(<span class="string">"after...");  </span></li><li class="alt">            <span class="keyword">return o;  </span></li><li>        }     </li><li class="alt">}  </li></ol> 
    </div> 
   </div> 
   <div>
     CGLib代理对象创建及测试： 
   </div> 
   <div> 
    <div class="dp-highlighter bg_java"> 
     <ol class="dp-j" start="1"><li class="alt"><span class="keyword">public <span class="keyword">class CGLibProxy {  </span></span></li><li>    <span class="keyword">public <span class="keyword">static CGLibTeacher create(CGLibAop aop){  </span></span></li><li class="alt">        Enhancer en = <span class="keyword">new Enhancer();     </span></li><li>        <span class="comment">//进行代理    </span></li><li class="alt">        en.setSuperclass(CGLibTeacher.<span class="keyword">class);     </span></li><li>        en.setCallback(aop);     </li><li class="alt">        <span class="comment">//生成代理实例    </span></li><li>        <span class="keyword">return (CGLibTeacher)en.create();     </span></li><li class="alt">    }  </li><li>      </li><li class="alt">    <span class="keyword">public <span class="keyword">static <span class="keyword">void main(String[] args) {  </span></span></span></li><li>        CGLibTeacher t = CGLibProxy.create(<span class="keyword">new CGLibAop());  </span></li><li class="alt">        t.sign(<span class="string">"names");  </span></li><li>    }  </li><li class="alt">}  </li></ol> 
    </div> 
   </div> 
   <div>
     从CGLib的代理对象创建中可以看到，代理对象需要设置代理目标以及AOP拦截实现，和Spring AOP的实现非常类似。 
   </div> 
  </div> 
 </div> 
</div> 
<p>转载于:https://www.cnblogs.com/Raymond-YYC/p/4054328.html</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/a92eee60e2cb0023bbc832dfc23f88e5/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">Odoo加载翻译后无法登陆 - REINDEX</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/a41a064102cbe592d848120fbb1ef879/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">Struts2 教程</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>