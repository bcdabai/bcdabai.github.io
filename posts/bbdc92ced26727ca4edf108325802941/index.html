<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Rust语言基础教程学习【一】（Rust基础语法、数据类型） - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Rust语言基础教程学习【一】（Rust基础语法、数据类型）" />
<meta property="og:description" content="安装vscode环境 首先，需要安装最新版的 Rust 编译工具和 Visual Studio Code。
Rust 编译工具：安装 Rust - Rust 程序设计语言
Visual Studio Code：Download Visual Studio Code - Mac, Linux, Windows
初次编译时 遇到报错 error: linker `link.exe` not found
rustup toolchain install stable-x86_64-pc-windows-gnu
rustup default stable-x86_64-pc-windows-gnu
执行上面两个命令。解决了
一、Rust基础语法 1.变量 用let关键字声明变量，Rust具有自动判断变量类型的能力。
let a = 111; a = &#34;abc&#34;; //错误，当声明 a 是111以后，a 就被确定为整型数字，不能把字符串类型的值赋给它。 a = 4.56; //错误，自动转换数字精度有损失，Rust 语言不允许精度有损失的自动数据类型转换。 Rust 语言为了高并发安全而做的设计：在语言层面尽量少的让变量的值可以改变。所以 a 的值不可变。但这不意味着 a 不是&#34;变量&#34;（英文中的 variable），官方文档称 a 这种变量为&#34;不可变变量&#34;。如果我们编写的程序的一部分在假设值永远不会改变的情况下运行，而我们代码的另一部分在改变该值，那么代码的第一部分可能就不会按照设计的意图去运转。由于这种原因造成的错误很难在事后找到。这是 Rust 语言设计这种机制的原因。
Rust 编译器保证，如果声明一个值不会变，它就真的不会变，所以你不必自己跟踪它。这意味着你的代码更易于推导。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/bbdc92ced26727ca4edf108325802941/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-05-31T16:54:34+08:00" />
<meta property="article:modified_time" content="2023-05-31T16:54:34+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Rust语言基础教程学习【一】（Rust基础语法、数据类型）</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <h2>安装vscode环境</h2> 
<p>首先，需要安装最新版的 Rust 编译工具和 Visual Studio Code。</p> 
<p>Rust 编译工具：<a href="https://www.rust-lang.org/zh-CN/tools/install" rel="nofollow" title="安装 Rust - Rust 程序设计语言">安装 Rust - Rust 程序设计语言</a></p> 
<p>Visual Studio Code：<a href="https://code.visualstudio.com/Download" rel="nofollow" title="Download Visual Studio Code - Mac, Linux, Windows">Download Visual Studio Code - Mac, Linux, Windows</a></p> 
<h2>初次编译时</h2> 
<p>遇到报错 error: linker `link.exe` not found</p> 
<p><img alt="" src="https://images2.imgbox.com/a5/76/c9SwngJH_o.png"></p> 
<p>rustup toolchain install  stable-x86_64-pc-windows-gnu<br> rustup default stable-x86_64-pc-windows-gnu</p> 
<p><strong>执行上面两个命令。解决了</strong></p> 
<p></p> 
<h2><strong>一、Rust基础语法</strong></h2> 
<h3><strong>1.</strong>变量</h3> 
<p><strong>        </strong>用let关键字声明变量，Rust具有自动判断变量类型的能力。</p> 
<pre><code class="language-rust">let a = 111;

a = "abc"; //错误，当声明 a 是111以后，a 就被确定为整型数字，不能把字符串类型的值赋给它。
a = 4.56; //错误，自动转换数字精度有损失，Rust 语言不允许精度有损失的自动数据类型转换。
</code></pre> 
<p>         Rust 语言为了高并发安全而做的设计：在语言层面尽量少的让变量的值可以改变。所以 a 的值不可变。但这不意味着 a 不是"变量"（英文中的 variable），官方文档称 a 这种变量为"不可变变量"。如果我们编写的程序的一部分在假设值永远不会改变的情况下运行，而我们代码的另一部分在改变该值，那么代码的第一部分可能就不会按照设计的意图去运转。由于这种原因造成的错误很难在事后找到。这是 Rust 语言设计这种机制的原因。</p> 
<p>        Rust 编译器保证，如果声明一个值不会变，它就真的不会变，所以你不必自己跟踪它。这意味着你的代码更易于推导。</p> 
<pre><code class="language-rust">/* 接上边代码 */
a = 222; //错误，a不是一个可变变量</code></pre> 
<p>        如果想使变量可变（mutable）只需一个 mut 关键字。</p> 
<pre><code class="language-rust">let mut a = 111;
a = 222; // 正确，利用mut关键字后，可以改变变量的值</code></pre> 
<p>        是否让变量可变的最终决定权仍然在你，取决于在某个特定情况下，你是否认为变量可变会让代码更加清晰明了。</p> 
<h3><strong>2.常量</strong></h3> 
<p>        类似于不可变变量，<em>常量 (constants)</em> 是绑定到一个名称的不允许改变的值，不过常量与变量还是有一些区别。</p> 
<p>        首先，不允许对常量使用 <code>mut</code>。常量不光默认不可变，它总是不可变。声明常量使用 <code>const</code> 关键字而不是 <code>let</code>，并且 <em>必须</em> 注明值的类型。</p> 
<p>        在 Rust 中，以下程序是合法的：</p> 
<pre><code class="language-rust">let a = 111;
let a = 222;</code></pre> 
<p>        但是如果 a 是常量就不合法：</p> 
<pre><code class="language-rust">const A_CONST: i32 = 111;
let A_CONST = 222; //错误，常量的值不能改变
A_CONST = 333; //错误，常量的值不能改变
const b = 222; //错误，定义常量必须声明类型</code></pre> 
<p>        Rust 对常量的命名约定是在单词之间使用全大写加下划线。</p> 
<p>        在声明它的作用域之中，常量在整个程序生命周期中都有效，此属性使得常量可以作为多处代码使用的全局范围的值，例如一个游戏中所有玩家可以获取的最高分或者光速。</p> 
<p>        将遍布于应用程序中的硬编码值声明为常量，能帮助后来的代码维护人员了解值的意图。如果将来需要修改硬编码值，也只需修改汇聚于一处的硬编码值。</p> 
<h3>3.重影/隐藏（<strong>Shadowing</strong>）</h3> 
<p>        我们可以定义一个与之前变量同名的新变量，称之为第一个变量被第二个变量隐藏了（shadowing），或者说重影了。这意味着当使用变量的名称时，编译器将看到第二个变量。实际上，第二个变量“遮蔽”了第一个变量，此时任何使用该变量名的行为中都会视为是在使用第二个变量，直到第二个变量自己也被隐藏或第二个变量的作用域结束。可以用相同变量名称来隐藏一个变量，以及重复使用 <code>let</code> 关键字来多次隐藏。</p> 
<pre><code class="language-rust">fn main()
{
    let x = 5;
    let x = x * 2;

    println!("The value of x is: {x}");

    let x = x * 2;
    println!("The value of x in the inner scope is: {x}");
}
</code></pre> 
<p>此段代码输出如下图：</p> 
<p><img alt="" height="60" src="https://images2.imgbox.com/4b/2a/syCao2Jv_o.png" width="364"></p> 
<p>         当使用 <code>let</code> 时，实际上创建了一个新变量，我们可以改变值的类型，并且复用这个名字。</p> 
<pre><code class="language-rust">let s = "abcd";
let s = s.len();</code></pre> 
<p>        以上代码是正确的，第一个变量s是字符串类型，第二个变量是数字类型，可以获得字符串的长度。</p> 
<p>然而，如果尝试使用 <code>mut</code>，将会得到一个编译时错误，这个错误说明，我们不能改变变量的类型，如下所示：</p> 
<pre><code class="language-rust">let mut s = "abcd";
s = s.len(); //错误，我们不能改变变量的类型</code></pre> 
<p><img alt="" height="80" src="https://images2.imgbox.com/d7/e1/ylMKpKZ3_o.png" width="502"></p> 
<h2> <strong>二、Rust数据类型</strong></h2> 
<p>        在 Rust 中，每一个值都属于某一个 <strong>数据类型</strong>（<em>data type</em>），这告诉 Rust 它被指定为何种数据，以便明确数据处理方式。我们将看到两类数据类型子集：标量（scalar）和复合（compound）。</p> 
<p>        记住，Rust 是 <strong>静态类型</strong>（<em>statically typed</em>）语言，也就是说在编译时就必须知道所有变量的类型。根据值及其使用方式，编译器通常可以推断出我们想要用的类型。当多种类型均有可能时，必须增加类型注解。比如当进行数据类型转换时，必须增加数据类型注解，如：</p> 
<pre><code class="language-rust">/* 将整型数据类型转换成字符型 */
let a: u32 = "42".parse().expect("Not a number!"); //正确
let c = "42".parse().expect("Not a number!"); //错误，没用给出c的数据类型注解</code></pre> 
<p><img alt="" height="247" src="https://images2.imgbox.com/b8/f9/tvecT7TU_o.png" width="554"></p> 
<h3> 1. 标量类型</h3> 
<p><strong>        标量</strong>（<em>scalar</em>）类型代表一个单独的值。Rust 有四种基本的标量类型：整型、浮点型、布尔类型和字符类型。</p> 
<h4>1.1 整型</h4> 
<p><strong>        整数</strong> 是一个没有小数部分的数字。表格 2-1 展示了 Rust 内建的整数类型。我们可以使用其中的任一个来声明一个整数值的类型。</p> 
<p>                                                        表格 2-1: Rust 中的整型</p> 
<table border="1" cellpadding="1" cellspacing="1" style="width:300px;"><thead><tr><th>长度</th><th>有符号</th><th>无符号</th></tr></thead><tbody><tr><td>8-bit</td><td>i8        </td><td>u8</td></tr><tr><td>16-bit</td><td>i16</td><td>u16</td></tr><tr><td>32-bit</td><td>i32</td><td>u32</td></tr><tr><td>64-bit</td><td>i64</td><td>u64</td></tr><tr><td>128-bit</td><td>i128</td><td>u128</td></tr><tr><td>arch</td><td>isize</td><td>usize</td></tr></tbody></table> 
<p>        每一个变量都可以是有符号或无符号的，并有一个明确的大小。<strong>有符号</strong> 和 <strong>无符号</strong>代表数字能否为负值，换句话说，这个数字是否有可能是负数（有符号数），或者永远为正而不需要符号（无符号数），有符号数以补码形式存储。</p> 
<p>        每一个有符号的变量可以储存包含从 -(<img alt="2^{n-1}" class="mathcode" src="https://images2.imgbox.com/05/af/J7VMf7ej_o.png">- 1) 到 <img alt="2^{n-1}" class="mathcode" src="https://images2.imgbox.com/86/b2/2dsIU4sZ_o.png"> - 1 在内的数字，这里 <em>n</em> 是变量使用的位数。所以 <code>i8</code> 可以储存从 -(<img alt="2^{7}" class="mathcode" src="https://images2.imgbox.com/69/1d/qdsQdjpS_o.png">) 到 <img alt="2^{7}" class="mathcode" src="https://images2.imgbox.com/d5/c1/WYyvj6AK_o.png">- 1 在内的数字，也就是从 -128 到 127。无符号的变量可以储存从 0 到 <img alt="2^{n}" class="mathcode" src="https://images2.imgbox.com/d4/8e/023hJeXc_o.png"> - 1 的数字，所以 <code>u8</code> 可以储存从 0 到 <img alt="2^{8}" class="mathcode" src="https://images2.imgbox.com/0d/2e/I0UyXwd6_o.png"> - 1 的数字，也就是从 0 到 255。</p> 
<p>         另外，<code>isize</code> 和 <code>usize</code> 类型依赖运行程序的计算机架构：64 位架构上它们是 64 位的，32 位架构上它们是 32 位的。</p> 
<p>         可以使用表格 2-2 中的任何一种形式编写数字字面值。请注意可以是多种数字类型的数字字面值允许使用类型后缀，例如 <code>57u8</code> 来指定类型，指定该数值的数据类型为u8，值为57。同时也允许使用 <code>_</code> 做为分隔符以方便读数，例如<code>1_000</code>，它的值与你指定的 <code>1000</code> 相同。</p> 
<p>                                         表格 2-2: Rust 中的整型字面值</p> 
<p>         <img alt="" height="238" src="https://images2.imgbox.com/7b/75/mJ2tMPpt_o.png" width="530"></p> 
<p>        那么该使用哪种类型的数字呢？如果拿不定主意，Rust 的默认类型通常是个不错的起点，数字类型默认是 <code>i32</code>。<code>isize</code> 或 <code>usize</code> 主要作为某些集合的索引。</p> 
<blockquote> 
 <p> 整型溢出</p> 
 <p>        假如有一个u8类型的变量，它的值的范围为0~255，如果为其赋予一个超过这个范围的数值，将会发生整型溢出（“integer overflow” ），这会导致以下两种行为之一的发生。</p> 
 <p>        当在 debug 模式编译时，Rust 检查这类问题并使程序 <em>panic</em>，这个术语被 Rust 用来表明程序因错误而退出。</p> 
 <p>        使用 <code>--release</code> flag 在 release 模式中构建时，Rust不会检测会导致 panic 的整型溢出。相反发生整型溢出时，Rust 会进行一种被称为二进制补码 wrapping（<em>two’s complement wrapping</em>）的操作。简而言之，比此类型能容纳最大值还大的值会回绕到最小值，值 <code>256</code> 变成 <code>0</code>，值 <code>257</code> 变成 <code>1</code>，依此类推。程序不会 panic，不过变量可能也不会是你所期望的值。依赖整型溢出 wrapping 的行为被认为是一种错误。</p> 
 <p>    为了显式地处理溢出的可能性，可以使用这几类标准库提供的原始数字类型方法：</p> 
 <ul><li>所有模式下都可以使用 <code>wrapping_*</code> 方法进行 wrapping，如 <code>wrapping_add</code></li><li>如果 <code>checked_*</code> 方法出现溢出，则返回 <code>None</code>值</li><li>用 <code>overflowing_*</code> 方法返回值和一个布尔值，表示是否出现溢出</li><li>用 <code>saturating_*</code> 方法在值的最小值或最大值处进行饱和处理</li></ul> 
</blockquote> 
<h4> 1.2 浮点型</h4> 
<p>        Rust 也有两个原生的 <strong>浮点数</strong>（<em>floating-point numbers</em>）类型，它们是带小数点的数字。Rust 的浮点数类型是 <code>f32</code> 和 <code>f64</code>，分别占 32 位和 64 位。默认类型是 <code>f64</code>，因为在现代 CPU 中，它与 <code>f32</code> 速度几乎一样，不过精度更高。所有的浮点型都是有符号的。</p> 
<h4> 1.3 布尔型</h4> 
<p>        正如其他大部分编程语言一样，Rust 中的布尔类型有两个可能的值：<code>true</code> 和 <code>false</code>。使用布尔值的主要场景是条件表达式。Rust 中的布尔类型使用 <code>bool</code> 表示。例如：</p> 
<pre><code class="language-rust">let t = true;
let f: bool = false; </code></pre> 
<h4> 1.4 字符型</h4> 
<p>Rust 的 <code>char</code> 类型是语言中最原生的字母类型。char字符型用单引号表示，字符串用双引号表示。</p> 
<pre><code class="language-rust">let c : char = 'a';
let s : &amp;str = "aaaa";</code></pre> 
<blockquote> 
 <p>        Rust 的 <code>char</code> 类型的大小为四个字节 (four bytes)，并代表了一个 Unicode 标量值（Unicode Scalar Value），这意味着它可以比 ASCII 表示更多内容。在 Rust 中，带变音符号的字母（Accented letters），中文、日文、韩文等字符，emoji（绘文字）以及零长度的空白字符都是有效的 <code>char</code> 值。Unicode 标量值包含从 <code>U+0000</code> 到 <code>U+D7FF</code> 和 <code>U+E000</code> 到 <code>U+10FFFF</code> 在内的值。不过，“字符” 并不是一个 Unicode 中的概念，所以人直觉上的 “字符” 可能与 Rust 中的 <code>char</code> 并不符合。</p> 
 <p><strong>注意：</strong>由于中文文字编码有两种（GBK 和 UTF-8），所以编程中使用中文字符串有可能导致乱码的出现，这是因为源程序与命令行的文字编码不一致，所以在 Rust 中字符串和字符都必须使用 UTF-8 编码，否则编译器会报错。</p> 
</blockquote> 
<h4>1.5 数值运算</h4> 
<p>        Rust 中的所有数字类型都支持基本数学运算：加法、减法、乘法、除法和取余。整数除法会向下舍入到最接近的整数。</p> 
<pre><code class="language-rust">fn main() {
    // addition
    let sum = 5 + 10; //结果为15

    // subtraction
    let difference = 95.5 - 4.3; //结果为91.2

    // multiplication
    let product = 4 * 30; //结果为120

    // division
    let quotient = 56.7 / 32.2; //结果为1.7608695652173911
    let truncated = -5 / 3; // 结果为 -1

    // remainder
    let remainder = 43 % 5; //结果为3
}</code></pre> 
<p>        输出结果如下：</p> 
<p><img alt="" height="186" src="https://images2.imgbox.com/40/8e/QnxoXdLK_o.png" width="644"></p> 
<blockquote> 
 <p>许多运算符号之后加上 = 号是自运算的意思，例如：</p> 
 <p>sum += 1 等同于 sum = sum + 1。</p> 
 <p>sum *= 1 等同于 sum = sum * 1。</p> 
 <p><strong>注意：</strong>Rust 不支持 <strong>++</strong> 和 <strong>--</strong>，因为这两个运算符出现在变量的前后会影响代码可读性，减弱了开发者对变量改变的意识能力。</p> 
</blockquote> 
<h3> 2. 复合类型</h3> 
<p>        <strong>复合类型</strong>（<em>Compound types</em>）可以将多个值组合成一个类型。Rust 有两个原生的复合类型：元组（tuple）和数组（array）。</p> 
<h4>2.1 元组类型</h4> 
<p>        元组是一个将多个其他类型的值组合进一个复合类型的主要方式。元组长度固定：一旦声明，其长度不会增大或缩小。</p> 
<p>        我们使用包含在圆括号中的逗号分隔的值列表来创建一个元组，元组中的每一个位置都有一个类型，而且这些不同值的类型也不必是相同的。例如：</p> 
<pre><code class="language-rust">let tup: (i32, f64, u8,&amp;str) = (500, 6.4, 1,"ssss");
let tup_a= (500, 6.4, 1,"ssss");//也是可以的</code></pre> 
<p><code>  tup</code> 变量绑定到整个元组上，因为元组是一个单独的复合元素。为了从元组中获取单个值，可以使用模式匹配（pattern matching）来解构（destructure）元组值，像这样：</p> 
<pre><code class="language-rust">let tup = (500, 6.4, 1, "ssss");
let (x, y, z, w) = tup;
println!("The value of x is: {x}");
println!("The value of y is: {y}");
println!("The value of z is: {z}");
println!("The value of w is: {w}");</code></pre> 
<p>输出如下：</p> 
<p><img alt="" height="126" src="https://images2.imgbox.com/73/17/jMP9rpg8_o.png" width="480"></p> 
<p>         程序首先创建了一个元组并绑定到 <code>tup</code> 变量上。接着使用了 <code>let</code> 和一个模式将 <code>tup</code> 分成了四个不同的变量，<code>x</code>、<code>y</code> 、 <code>z、w</code>。这叫做 <strong>解构</strong>（<em>destructuring</em>），因为它将一个元组拆成了四个部分。</p> 
<p>        我们也可以使用点号（<code>.</code>）后跟值的索引来直接访问它们。例如：</p> 
<pre><code class="language-rust">let tup: (i32, f64, u8,&amp;str) = (500, 6.4, 1,"ssss");
let x = tup.0;
let y = tup.1;
let z = tup.2;
let w = tup.3;
</code></pre> 
<p>输出结果和上边相同。</p> 
<p><img alt="" height="134" src="https://images2.imgbox.com/db/85/Rnbl0trK_o.png" width="452"></p> 
<p>        这个程序创建了一个元组，<code>x</code>，然后使用其各自的索引访问元组中的每个元素。跟大多数编程语言一样，元组的第一个索引值是 0。</p> 
<p>        不带任何值的元组有个特殊的名称，叫做 <strong>单元（unit）</strong> 元组。这种值以及对应的类型都写作 <code>()</code>，表示空值或空的返回类型。如果表达式不返回任何其他值，则会隐式返回单元值。</p> 
<h4>2.2 数组类型</h4> 
<p>        另一个包含多个值的方式是 <strong>数组</strong>（<em>array</em>）。与元组不同，数组中的每个元素的类型必须相同。Rust 中的数组与一些其他语言中的数组不同，Rust 中的数组长度是固定的。</p> 
<p>我们将数组的值写成在方括号内，用逗号分隔：</p> 
<pre><code class="language-rust">let a = [1, 2, 3, 4, 5];
let a: [i32; 5] = [1, 2, 3, 4, 5]; //这里，i32 是每个元素的类型。分号之后，数字 5 表明该数组包含五个元素。</code></pre> 
<p>当你想要在栈（stack）而不是在堆（heap）上为数据分配空间，或者是想要确保总是有固定数量的元素时，数组非常有用。但是数组并不如 vector 类型灵活。vector 类型是标准库提供的一个 <strong>允许</strong> 增长和缩小长度的类似数组的集合类型。当不确定是应该使用数组还是 vector 的时候，那么很可能应该使用 vector（在后续章节会学习到vector）。</p> 
<p>        然而，当你确定元素个数不会改变时，数组会更有用。例如，当你在一个程序中使用月份名字时，你更应趋向于使用数组而不是 vector，因为你确定只会有 12 个元素。</p> 
<pre><code class="language-rust">let months = ["January", "February", "March", "April", "May", "June", "July",
              "August", "September", "October", "November", "December"];</code></pre> 
<p>        还可以通过在方括号中指定初始值加分号再加元素个数的方式来创建一个每个元素都为相同值的数组：</p> 
<pre><code class="language-rust">let a = [3; 5];</code></pre> 
<p>        变量名为 <code>a</code> 的数组将包含 <code>5</code> 个元素，这些元素的值最初都将被设置为 <code>3</code>。这种写法与 <code>let a = [3, 3, 3, 3, 3];</code> 效果相同，但更简洁。</p> 
<p>        数组是可以在栈 (stack) 上分配的已知固定大小的单个内存块。可以使用索引来访问数组的元素：</p> 
<pre><code class="language-rust">let a = [1, 2, 3, 4, 5];

let first = a[0];
let second = a[1];</code></pre> 
<pre><code class="language-rust">let a = [1, 2, 3, 4, 5];
a[0] = 123; // 错误：数组 a 不可变
let mut a = [1, 2, 3];
a[0] = 4; // 正确</code></pre> 
<p>        当尝试用索引访问一个元素时，Rust 会检查指定的索引是否小于数组的长度。如果索引超出了数组长度，Rust 会 <em>panic</em>，这是 Rust 术语，它用于程序因为错误而退出的情况。这种检查必须在运行时进行，特别是在这种情况下，因为编译器不可能知道用户在以后运行代码时将输入什么值。这样当提供了一个不正确的索引时，就会访问无效的内存。通过立即退出而不是允许内存访问并继续执行，Rust 让你避开此类错误。</p> 
<h2>Rust语言基础教程学习其他章节【未完待续】：</h2> 
<p>Rust语言基础教程学习【二】：<a href="https://blog.csdn.net/cyf1294311560/article/details/130551188?spm=1001.2014.3001.5502" title="Rust语言基础教程学习【二】（函数、条件语句、循环）_LLLL、的博客-CSDN博客">Rust语言基础教程学习【二】（函数、条件语句、循环）_LLLL、的博客-CSDN博客</a></p> 
<p>Rust语言基础教程学习【三】： <a href="https://blog.csdn.net/cyf1294311560/article/details/130552899?spm=1001.2014.3001.5502" title="Rust语言基础教程学习【三】（所有权）_LLLL、的博客-CSDN博客">Rust语言基础教程学习【三】（所有权）_LLLL、的博客-CSDN博客</a></p> 
<p>Rust语言基础教程学习【四】：<a href="https://blog.csdn.net/cyf1294311560/article/details/130622466?spm=1001.2014.3001.5502" title="Rust语言基础教程学习【四】（结构体）_LLLL、的博客-CSDN博客">Rust语言基础教程学习【四】（结构体）_LLLL、的博客-CSDN博客</a></p> 
<p>Rust语言基础教程学习【五】： <a href="https://blog.csdn.net/cyf1294311560/article/details/130711865?spm=1001.2014.3001.5502" title="Rust语言基础教程学习【五】（枚举和模式匹配）_LLLL、的博客-CSDN博客">Rust语言基础教程学习【五】（枚举和模式匹配）_LLLL、的博客-CSDN博客</a></p> 
<p>Rust语言基础教程学习【六】：<a href="https://blog.csdn.net/cyf1294311560/article/details/130754122?spm=1001.2014.3001.5502" title="Rust语言基础教程学习【六】（包、Crate、模块）_LLLL、的博客-CSDN博客">Rust语言基础教程学习【六】（包、Crate、模块）_LLLL、的博客-CSDN博客</a></p> 
<p>Rust语言基础教程学习【七】： <a href="https://blog.csdn.net/cyf1294311560/article/details/130863375?spm=1001.2014.3001.5502" title="Rust语言基础教程学习【七】（常见集合）_LLLL、的博客-CSDN博客">Rust语言基础教程学习【七】（常见集合）_LLLL、的博客-CSDN博客</a></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/3d7d9c386bad5d8c3f717e0b67cfa58d/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">手把手教你如何通过datadome滑块验证码</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/0adeb6d88af1411aed591581deb46556/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">Linux系统Docker使用指北</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>