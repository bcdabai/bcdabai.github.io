<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>汇编语言语法学习 - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="汇编语言语法学习" />
<meta property="og:description" content="主要是介绍汇编指令的用法。
1、LDR
指令说明：读内存指令
例子1：LDR R0 ,[R1]
例子说明：假设地址R1的值为x，读取地址x上的数据（4个字节）保存到R0中。
例子2：LDR R0, 0X0209C004
例子说明：将0X0209C004地址上的值赋值给R0
2、LDR（伪指令）
指令说明：伪指令（并不存在的指令，最终被解析成真正的汇编指令）
例子：LDR R0,=0x12345678
例子说明：把0x12345678的值赋值给R0。
3、STR
指令说明：写内存指令
例子1：STR R0 ,[R1]
例子说明：假设R1的值为x，将R0数据写到地址R1上。
例子2：STR R0，[R1，＃8]
例子说明：将R0中的字数据写入以R1＋8为地址的存储器中。
例子3：STR R0，[R1]，＃8
例子说明：将R0中的字数据写入以R1为地址的存储器中，并将新地址R1＋8写入R1
4、MOV
指令说明：赋值指令
例子1：MOV R0,R1
例子说明：把R1的值赋给R0，即R0=R1。
例子2：MOV R0,#0x100
例子说明：把0x100赋值给R0 //#0x100的写法表示为立即数
5、LEA
指令说明：取有效地址指令
例子1：LEA REC,OPRD
例子说明：把操作数oprd的有效地址传送到操作数rec，源操作数oprd必须是一个存储器操作数，目的操作数rec必须是一个16位或32位的通用寄存器。
注：与mov指令的区别：mov：移动地址中的值；lea：将地址进行移动。
6、JMP
指令说明：无条件段内直接转移指令
例子1：JMP LABEL
例子说明：使控制无条件地转移到标号为label的位置。无条件转移指令本身不影响标志
7、CALL
指令说明：过程调用指令
例子1：CALL LABEL
例子说明：段内直接调用LABEL
注：与jmp的区别在于call指令会在调用label之前保存返回地址（call 中return之后主程序还可以继续执行，jmp 当label执行完毕后不能返回主程序继续执行）
8、B
指令说明：跳转指令。//用于函数跳出不再回来的过程
例子：
_start
ldr sp, =0x80200000 //sp是指向栈顶的指针，此处是设置栈指针
b main
例子说明：跳转到main函数
9、BL
指令说明：跳转指令。//用于函数调用完之后回来继续当前函数的过程" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/b27ebc729a9eec3acf5bdce34dfa4c49/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-08-13T22:55:25+08:00" />
<meta property="article:modified_time" content="2022-08-13T22:55:25+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">汇编语言语法学习</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p>主要是介绍汇编指令的用法。</p> 
<p>1、LDR<br> 指令说明：读内存指令<br> 例子1：LDR R0 ,[R1]<br> 例子说明：假设地址R1的值为x，读取地址x上的数据（4个字节）保存到R0中。<br> 例子2：LDR R0, 0X0209C004<br> 例子说明：将0X0209C004地址上的值赋值给R0</p> 
<p>2、LDR（伪指令）<br> 指令说明：伪指令（并不存在的指令，最终被解析成真正的汇编指令）<br> 例子：LDR R0,=0x12345678<br> 例子说明：把0x12345678的值赋值给R0。</p> 
<p>3、STR<br> 指令说明：写内存指令<br> 例子1：STR R0 ,[R1]<br> 例子说明：假设R1的值为x，将R0数据写到地址R1上。<br> 例子2：STR R0，[R1，＃8]<br> 例子说明：将R0中的字数据写入以R1＋8为地址的存储器中。<br> 例子3：STR R0，[R1]，＃8<br> 例子说明：将R0中的字数据写入以R1为地址的存储器中，并将新地址R1＋8写入R1</p> 
<p>4、MOV<br> 指令说明：赋值指令<br> 例子1：MOV R0,R1<br> 例子说明：把R1的值赋给R0，即R0=R1。<br> 例子2：MOV R0,#0x100<br> 例子说明：把0x100赋值给R0 //#0x100的写法表示为立即数</p> 
<p>5、LEA<br> 指令说明：取有效地址指令<br> 例子1：LEA REC,OPRD<br> 例子说明：把操作数oprd的有效地址传送到操作数rec，源操作数oprd必须是一个存储器操作数，目的操作数rec必须是一个16位或32位的通用寄存器。<br> 注：与mov指令的区别：mov：移动地址中的值；lea：将地址进行移动。</p> 
<p>6、JMP<br> 指令说明：无条件段内直接转移指令<br> 例子1：JMP LABEL<br> 例子说明：使控制无条件地转移到标号为label的位置。无条件转移指令本身不影响标志</p> 
<p>7、CALL<br> 指令说明：过程调用指令<br> 例子1：CALL LABEL<br> 例子说明：段内直接调用LABEL<br> 注：与jmp的区别在于call指令会在调用label之前保存返回地址（call 中return之后主程序还可以继续执行，jmp 当label执行完毕后不能返回主程序继续执行）</p> 
<p>8、B<br> 指令说明：跳转指令。//用于函数跳出不再回来的过程<br> 例子：<br> _start<br> ldr sp, =0x80200000 //sp是指向栈顶的指针，此处是设置栈指针<br> b main<br> 例子说明：跳转到main函数</p> 
<p>9、BL<br> 指令说明：跳转指令。//用于函数调用完之后回来继续当前函数的过程<br> 例子：<br> 例子说明：<br> 注：BL 指令相比 B 指令，在跳转之前会在寄存器 LR(R14)中保存当前 PC 寄存器值，所以可以通过将 LR 寄存器中的值重新加载到 PC 中来继续从跳转之前的代码处运行。</p> 
<p>10、SAL<br> 指令说明：算术左移<br> 例子1：SAL OPRD，count<br> 例子说明：把操作数oprd左移count位，右边补0。</p> 
<p>11、SHL<br> 指令说明：逻辑左移<br> 例子1：SHL OPRD，count<br> 例子说明：把操作数oprd左移count位，右边补0。<br> 注：与shl指令一样。通过截取count的低5位，实际的移位数被限于0到31之间。</p> 
<p>12、SAR<br> 指令说明：算术右移<br> 例子1：SAR OPRD，count<br> 例子说明：把操作数oprd右移count位，同时每右移一位，左边补符号位，移出的最低位进入标志位CF。</p> 
<p>13、SHR<br> 指令说明：逻辑右移<br> 例子1：SHR OPRD，count<br> 例子说明：把操作数oprd右移count位，左边补0，移出的最低位进入标志位CF。</p> 
<p>14、ROL<br> 指令说明：左循环移位指令<br> 例子1：ROL OPRD,count<br> 例子说明：把操作数oprd左移count位。<br> 15、ROR<br> 指令说明：右循环移位指令<br> 例子1：ROR OPRD,count<br> 例子说明：把操作数oprd右移count位。</p> 
<p>16、RCL<br> 指令说明：带进位左循环移位<br> 例子1：RCL OPRD,count<br> 例子说明：</p> 
<p>17、RCR<br> 指令说明：带进位右循环移位<br> 例子1：RCR OPRD,count<br> 例子说明：</p> 
<p>18、LOOP<br> 指令说明：计数循环指令<br> 例子1：LOOP LABEL<br> 例子说明：</p> 
<p>19、SUB<br> 指令说明：减法指令<br> 例子1：sub r0 ,r1,#5<br> 例子说明：r0 = r1 - 5。<br> 例子2：sub r0 ,r1,r2<br> 例子说明：r0 = r1 - r2。</p> 
<p>20、SBC<br> 指令说明：带借位的减法<br> 例子：SBC Rd，Rn，#immed<br> 例子说明：Rd = Rn - #immed -借位。<br> 例子2：SBC Rd，Rn，Rm<br> 例子说明：Rd = Rn - Rm - 借位。</p> 
<p>21、ADD<br> 指令说明：加法指令<br> 例子：add r0,r1,#5<br> 例子说明：r0 = r1+5。<br> 例子2：add r0 ,r1,r2<br> 例子说明：r0 = r1 + r2</p> 
<p>22、ADC<br> 指令说明：带进位的加法运算<br> 例子：adc Rd，Rn，Rm<br> 例子说明：Rd = Rn + Rm + 进位<br> 例子2：add Rd，Rn，#immed<br> 例子说明：Rd = Rn + #immed + 进位</p> 
<p>23、MUL<br> 指令说明：乘法指令<br> 例子：MUL Rd，Rn，Rm<br> 例子说明：Rd = Rn * Rm</p> 
<p>24、UDIV<br> 指令说明：无符号除法指令<br> 例子：UDIV Rd，Rn，Rm<br> 例子说明：Rd = Rn / Rm</p> 
<p>25、SDIV<br> 指令说明：有符号除法指令<br> 例子：UDIV Rd，Rn，Rm<br> 例子说明：Rd = Rn / Rm</p> 
<p>26、CMP<br> 指令说明：比较两个操作数的大小<br> 例子：cmp oprd1,oprd2<br> 例子说明：执行从目的操作数中减去源操作数的隐含减法操作，并且不修改任何操作数。<br> 注：它影响flag的CF，ZF，OF，AF，PF，说明如下：<br> 若执行指令后:ZF=1,则说明两个数相等，因为zero为1说明结果为0.<br> 当无符号时：<br> 若CF=1,则说明了有进位或借位，cmp是进行的减操作，故可以看出为借位，所以，此时oprd1&lt;oprd2;<br> CF=0,则说明了无借位，但此时要注意ZF是否为0，若为0，则说明结果不为0，故此时oprd1&gt;oprd2.<br> 当有符号时：<br> 若SF=0，OF=0 则说明了此时的值为正数，没有溢出，可以直观的看出，oprd1&gt;oprd2;<br> 若SF=1，OF=0 则说明了此时的值为负数，没有溢出，则为oprd1&lt;oprd2;<br> 若SF=0，OF=1 则说明了此时的值为正数，有溢出，可以看出oprd1&lt;oprd2;<br> 若SF=1，OF=1则说明了此时的值为负数，有溢出，可以看出oprd1&gt;oprd2;</p> 
<p>27、TEST <br> 指令说明： 指令在两个操作数的对应位之间进行 AND 操作，并根据运算结果设置符号标志位、零标志位和奇偶标志位<br> 例子：<br> test eax, 100b ;b后缀意为二进制<br> jnz ****** ;如果eax右数第三个位为1,jnz将会跳转<br> 例子说明：jnz跳转的条件非0，即ZF=0，ZF=0意味着零标志没被置位，即逻辑与结果为1。<br> 例子2：<br> test ecx, ecx<br> jz somewhere<br> 如果ecx为零，设置ZF零标志为1，Jz跳转<br> 注：TEST AX,BX 与AND AX,BX命令有相同效果，只是Test指令不改变AX和BX的内容，而AND指令会把结果保存到AX中<br> 注：条件码说明：<br> 条件码：<br> OF(Overflow Flag)溢出标志,溢出时为1，否则置0.标明一个溢出了的计算,如:结构和目标不匹配。<br> SF(Sign Flag)符号标志,结果为负时置1，否则置0。<br> ZF(Zero Flag)零标志,运算结果为0时置1，否则置0。<br> CF(Carry Flag)进位标志,进位时置1，否则置0.注意:Carry标志中存放计算后最右的位。<br> AF(Auxiliary carry Flag)辅助进位标志，记录运算时第3位(半个字节)产生的进位置。<br> 有进位时1,否则置0。<br> PF(Parity Flag)奇偶标志.结果操作数中1的个数为偶数时置1，否则置0。<br> 控制标志位：<br> DF(Direction Flag)方向标志，在串处理指令中控制信息的方向。<br> IF(Interrupt Flag)中断标志。<br> TF(Trap Flag)陷井标志。</p> 
<p>28、BNE<br> 指令说明：是个条件跳转，即:是“不相等(或不为0)跳转指令”。如果不为0就跳转到后面指定的地址，继续执行<br> 例子：<br> TST R0, #0X8<br> BNE SuspendUp ；BNE指令是“不相等（或不为0）跳转指令”：<br> LDR R1,#0x00000000<br> 例子说明：先进行and运算，如果R0的第四位不为1，则结果为零，则设置zero=1（继续下面的LDR指令）。否则，如果R0的第四位为1，zero=0（跳到SuspendUp处执行）。</p> 
<p>29、BEQ<br> 指令说明：是个条件跳转，即:是“等于0时进行跳转指令”。<br> 例子：<br> TST R0, #0X8<br> BEQ SuspendUp ；BNE指令是“不相等（或不为0）跳转指令”：<br> LDR R1,#0x00000000<br> 例子说明：先进行and运算，如果R0的第四位不为1，则结果为零，则设置zero=1且执行BEQ的跳转。否则，如果R0的第四位为1，则设置zero=0，且执行LDR部分。<br> 注：tst 和bne连用: 先是用tst进行位与运算，然后将位与的结果与0比较，如果不为0，则跳到bne紧跟着的标记（如bne sleep，则跳到sleep处）。<br> tst 和beq连用: 先是用tst进行位与运算，然后将位与的结果与0比较，如果为0，则跳到beq紧跟着的标记（如bne AAAA，则跳到AAAA处）</p> 
<p>30、MRS<br> 指令说明：用于将程序状态寄存器的内容传送到通用寄存器中。<br> 格式：MRS{条件} 通用寄存器，程序状态寄存器（CPSR或SPSR）<br> 例子1：MRS R0，CPSR<br> 例子说明：传送CPSR的内容到R0。<br> 例子2：MRS R0，SPSR<br> 例子说明：传送SPSR的内容到R0。<br> 注：<br> MRS指令用于将程序状态寄存器的内容传送到通用寄存器中，使用情况如下：<br> 1）当需要改变程序状态寄存器的内容时，可用MRS将程序状态寄存器的内容读入通用寄存器，修改后再写回程序状态寄存器<br> 2）当在异常处理或进程切换时，需要保存程序状态寄存器的值，可先用该指令读出程序状态寄存器的值，然后保存</p> 
<p>31、MSR<br> 指令说明：将操作数的内容传送到程序状态寄存器的特定域中。其中，操作数可以为通用寄存器或立即数<br> 格式：MSR{条件} 程序状态寄存器（CPSR或SPSR）_&lt;域&gt;，操作数<br> 例子1：MSR CPSR，R0<br> 例子说明：传送R0的内容到CPSR<br> 例子2：MSR SPSR，R0<br> 例子说明：传送R0的内容到SPSR<br> 例子3：MSR CPSR_c，R0<br> 例子说明：传送R0的内容到SPSR，但仅修改CPSR中的控制位域<br> 注：<br> &lt;域&gt;用于设置程序状态寄存器中需要操作的位，32位的程序状态寄存器可分为4个域：<br> 1）位[31：24]为条件标志位域，用f表示；<br> 2）位[23：16]为状态位域，用s表示；<br> 3）位[15：8]为扩展位域，用x表示；<br> 4）位[7：0]为控制位域，用c表示；<br> 该指令通常用于恢复或改变程序状态寄存器的内容，在使用时，一般要在MSR指令中指明将要操作的域。</p> 
<p>32、BIC<br> 指令说明：BIC指令用于清除（操作数1）的某些位，并把结果放置到目的寄存器中。（操作数1）应是一个寄存器，（操作数2）可以是一个寄存器，被移位的寄存器，或一个立即数。（操作数2）为32位的掩码，如果在掩码中设置了某一位，则清除返一位。未设置的掩码位保持不变。<br> 格式：BIC{条件}{S} 目的寄存器，操作数1，操作数2<br> 例子1：bic r0,r0,#0x1f<br> 例子说明：清除r0的bit[4:0]位。<br> 例子2：BIC Rd, Rn<br> 例子说明：Rd = Rd &amp; (~Rn)<br> 例子3：BIC Rd, Rn, Rm<br> 例子说明：Rd = Rn &amp; (~Rm)</p> 
<p>33、AND<br> 指令说明：按位与<br> 例子1：AND Rd, Rn<br> 例子说明：Rd = Rd &amp; Rn。<br> 例子2：AND Rd, Rn, #immed<br> 例子说明：Rd = Rn &amp; #immed<br> 例子3：AND Rd, Rn, Rm<br> 例子说明：Rd = Rn &amp; Rm</p> 
<p>34、ORR<br> 指令说明：按位或<br> 例子1：ORR Rd, Rn<br> 例子说明：Rd = Rd | Rn。<br> 例子2：ORR Rd, Rn, #immed<br> 例子说明：Rd = Rn | #immed<br> 例子3：ORR Rd, Rn, Rm<br> 例子说明：Rd = Rn | Rm</p> 
<p>35、ORN<br> 指令说明：按位或非<br> 例子1：ORN Rd, Rn<br> 例子说明：Rd = Rd |(~ Rn)</p> 
<p>36、INC<br> 指令说明：加1指令<br> 例子1：INC DEST<br> 例子说明：</p> 
<p>37、DEC<br> 指令说明：减1指令<br> 例子1：DEC DEST<br> 例子说明：</p> 
<p>38、NEG<br> 指令说明：取补指令<br> 例子1：NEG OPRD<br> 例子说明：</p> 
<p>39、EOR<br> 指令说明：按位异或<br> 例子：EOR Rd, Rn<br> 例子说明：Rd = Rd ^ Rn。</p> 
<p>40、PUSH<br> 指令说明：将寄存器列表存入栈中<br> 格式：PUSH <br> 例子1：PUSH {R0~R3, R12}<br> 例子说明：将 R0~R3 和 R12 压栈。<br> 例子2：PUSH {LR}<br> 例子说明：将 LR 进行压栈</p> 
<p>41、POP<br> 指令说明：从栈中恢复寄存器列表<br> 格式：POP <br> 例子1：POP {LR}<br> 例子说明：先恢复 LR。<br> 例子2：POP {R0~R3,R12}<br> 例子说明：再恢复 R0~R3,R12</p> 
<p>42、NOP<br> 指令说明：空操作指令，用作延时。无任何效果，在指令书写处占用一个字节的内存空间<br> 例子：LDR R0 ,[R1]<br> 例子说明：假设R1的值为x，读取地址x上的数据（4个字节）保存到R0中。</p> 
<p>43、XCHG<br> 指令说明：交换指令<br> 例子：XCHG OPER1,OPER2<br> 例子说明：把操作数oper1的内容与操作数oper2的内容交换。oper1和oper2可以是通用寄存器或存储单元，但不能同时是操作单元，也不能是立即数。</p> 
<p>44、LDM<br> 指令说明：多数据加载,将地址上的值加载到寄存器上<br> 格式：LDM{cond} mode Rn{!}, reglist{^}<br> 例子：<br> Ldr R1,=0x10000000 //传送数据的起始地址0x10000000<br> LDMIB R1!,{R0,R4-R6}<br> 例子说明：从左到右加载,相当于 LDR R0,10000004 LDR R4,10000008… …<br> /*传送前地址加+4,<br> 所以地址加4,R0=0X1000004地址里的内容，<br> 地址加4,R4=0X10000008地址里的内容，<br> 地址加4,R5=0X1000000C地址里的内容，<br> 地址加4,R6=0X10000010 地址里的内容，<br> 由于!, 最后的地址写回到R1中,R1=0X10000010。</p> 
<p>45、STM<br> 指令说明：多数据存储,将寄存器的值存到地址上<br> 格式：STM{cond} mode Rn{!}, reglist{^}<br> 例子：stmia sp, {r0 - r12} //注意这里的-号不是减，而是范围<br> 例子说明：将r0存入sp指向的内存处（假设为0x30001000）；然后地址+4（即指向0x30001004），将r1存入该地址；然后地址再+4（指向0x30001008），将r2存入该地址······直到r12内容放入（0x3001030），指令完成。即将r0~r12的内容存入以sp为起始地址的内容空间里。<br> 注：<br> 1）8种后缀，如下：<br> ia（increase after）先传输，再地址+4<br> ib（increase before）先地址+4，再传输<br> da（decrease after）先传输，再地址-4<br> db（decrease before）先地址-4，再传输<br> fd（full decrease）满递减堆栈<br> ed（empty decrease）空递减堆栈<br> fa（·······） 满递增堆栈<br> ea（·······）空递增堆栈<br> 2） ！：表示最后的地址写回到Rn中<br> 3） reglist：可包含多于一个寄存器范围，用“，”隔开，如{R1，R2，R6-R9}，寄存器由小到大顺序排列<br> 4） ^：不允许在用户模式和系统模式下运行</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/3e1956e25b9d165c3dda5ddc929e19a0/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">eclipse下载与安装（汉化教程）超详细</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/3c19f3164d11f5f28169598eee30a491/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">SpringBoot-内置 Tomcat 配置和切换</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>