<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>C#调用带结构体指针的C Dll的方法 - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="C#调用带结构体指针的C Dll的方法" />
<meta property="og:description" content="在C#中调用C（C&#43;&#43;）类的DLL的时候，有时候C的接口函数包含很多参数，而且有的时候这些参数有可能是个结构体，而且有可能是结构体指针，那么在C#到底该如何安全的调用这样的DLL接口函数呢？本文将详细介绍如何调用各种参数的方法。
一、调用接口仅含普通变量
eg：int fnAdd(int num1,int num2);
那么在C#调用这种函数最简单了，直接用函数原型即可，如下：
[DllImport(&#34;你的dll名称&#34;, EntryPoint = &#34;fnAdd&#34;, CallingConvention = CallingConvention.Cdecl)] public static extern int fnAdd(int num1, int num2); 这样在C#的方法内可以放心的使用这个dll函数了。
二、调用接口含普通变量的指针
大家都知道C#为了安全起见，隐形的避开了指针（其实在C#完全可以使用指针的，只是为了安全），采用了引用的方式来取代指针，引用的好处就是可以和指针一样操作参数原地址内的数据，并且这些数据在调用函数返回时还存活，但是引用不可以想指针那样&#43;&#43;或者--到此PC指针乱跑，引出的一系列问题，下面举例来操作普通变量的指针，如下：
eg：int fnAdd(int *p_n1,int *p_n2);
上文已经说了C#采用引用来代替指针，那么好了调用接口可以这么写了：
[DllImport(&#34;你的dll名称&#34;, EntryPoint = &#34;fnAdd&#34;, CallingConvention = CallingConvention.Cdecl)] public static extern int fnAdd(ref int num1,ref int num2); 对，就这样的简单，这样C#便可以调用带指针的普通变量了。
三、来电稍微难度点的，调用接口含结构体
eg：在C的头文件内包含这样一个简单的结构体
struct mybuf { int num1; int num2; } 接口函数如下：
int fnAdd(struct mybuf mydata);
那么这样在C#该如何调用这样的接口函数呢？
首先在C#我们要声明一个结构体，在C#结构体并没有被抛弃，只不过在使用结构体时需要注意一些细节，比如要调用C的DLL那么最好在C#内定义的结构体前加上一些修饰符，如下：
[StructLayout(LayoutKind.Sequential)] public struct MyBuf { public int num1; public int num2; public MyBuf(int n1,int n2) { num1 = n1; num2 = n2; } } [DllImport(&#34;" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/9f73f393599d81ad84d8aa542f06b664/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2014-07-31T11:39:32+08:00" />
<meta property="article:modified_time" content="2014-07-31T11:39:32+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">C#调用带结构体指针的C Dll的方法</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p>在C#中调用C（C++）类的DLL的时候，有时候C的接口函数包含很多参数，而且有的时候这些参数有可能是个结构体，而且有可能是结构体指针，那么在C#到底该如何安全的调用这样的DLL接口函数呢？本文将详细介绍如何调用各种参数的方法。</p> 
<p><strong>一、</strong>调用接口仅含普通变量</p> 
<p><span style="white-space:pre"></span>eg：int fnAdd(int num1,int num2);</p> 
<p><span style="white-space:pre"></span>那么在C#调用这种函数最简单了，直接用函数原型即可，如下：</p> 
<p></p> 
<pre><code class="language-csharp">[DllImport("你的dll名称", EntryPoint = "fnAdd", CallingConvention = CallingConvention.Cdecl)]
public static extern int fnAdd(int num1, int num2);</code></pre> 
<p><span style="white-space:pre"></span>这样在C#的方法内可以放心的使用这个dll函数了。</p> 
<p><strong>二、</strong>调用接口含普通变量的指针</p> 
<p><span style="white-space:pre"></span>大家都知道C#为了安全起见，隐形的避开了指针（其实在C#完全可以使用指针的，只是为了安全），采用了引用的方式来取代指针，引用的好处就是可以和指针一样操作参数原地址内的数据，并且这些数据在调用函数返回时还存活，但是引用不可以想指针那样++或者--到此PC指针乱跑，引出的一系列问题，下面举例来操作普通变量的指针，如下：</p> 
<p><span style="white-space:pre"></span>eg：int fnAdd(int *p_n1,int *p_n2);</p> 
<p><span style="white-space:pre"></span>上文已经说了C#采用引用来代替指针，那么好了调用接口可以这么写了：</p> 
<p></p> 
<pre><code class="language-csharp">[DllImport("你的dll名称", EntryPoint = "fnAdd", CallingConvention = CallingConvention.Cdecl)]
public static extern int fnAdd(ref int num1,ref int num2);</code></pre> 
<p><span style="white-space:pre"></span>对，就这样的简单，这样C#便可以调用带指针的普通变量了。</p> 
<p><strong>三、</strong>来电稍微难度点的，调用接口含结构体</p> 
<p><span style="white-space:pre"></span>eg：在C的头文件内包含这样一个简单的结构体</p> 
<p><span style="white-space:pre"></span></p> 
<pre><code class="language-cpp">struct mybuf
{
	int num1;
	int num2;
}</code></pre> 
<p><span style="white-space:pre"></span>接口函数如下：</p> 
<p><span style="white-space:pre"></span>int fnAdd(struct mybuf mydata);</p> 
<p><span style="white-space:pre"></span>那么这样在C#该如何调用这样的接口函数呢？</p> 
<p><span style="white-space:pre"></span>首先在C#我们要声明一个结构体，在C#结构体并没有被抛弃，只不过在使用结构体时需要注意一些细节，比如要调用C的DLL那么最好在C#内定义的结构体前加上一些修饰符，如下：</p> 
<p></p> 
<pre><code class="language-csharp">[StructLayout(LayoutKind.Sequential)]
public struct MyBuf
{
	public int num1;
	public int num2;
	public MyBuf(int n1,int n2)
	{
		num1 = n1;
		num2 = n2;
	}
}
[DllImport("你的dll名称", EntryPoint = "fnAdd", CallingConvention = CallingConvention.Cdecl)]
public static extern int fnAdd(MyBuf mydata);</code></pre> 
<p><span style="white-space:pre"></span>大家可能会发现怎么这个结构体这么像个类啊，是的啊在C#中结构体确实是个特殊的类，也有构造函数，如上例子中的public MyBuf(int n1,int n2)这样的构造函数；</p> 
<p><span style="white-space:pre"></span>大家也可能看到定义结构体前我们使用StructLayout这样的结构体布局修饰符，这个其实是很有用的，我们使用了LayoutKind.Sequential这个属性，这在dll的参数是指针的时候特别有用，因为你的C中的结构体内存是顺序布局的，因此我们在C#内也要采用顺序布局，这样传递指针的时候在C dll内就不会出错了（也不一定）。</p> 
<p><span style="white-space:pre"></span>另外大家看到结构体的成员变量我们都用来public修饰符，当没有public只有int num1这样的语句的时候，C#默认成员变量是保护的，那么你在C#中其他方法内定义这个结构体就不能随便的访问修改其成员变量了（只能通过构造函数new的时候进行初始化），因此需要使用public来修饰一下成员变量。</p> 
<p><strong>四、</strong>继续来点难度，其实也没什么难度，就是dll接口参数包含结构体指针</p> 
<p><span style="white-space:pre"></span>eg：int fnAdd(struct mybuf *p_mydata)，或者写成int fnAdd(void *p_mydata)</p> 
<p><span style="white-space:pre"></span>上面两个函数其实是一样的，因为C规定void类型的指针可以指向任何数据类型，只不过在c函数实体内强制为你的数据类型即可，比如：</p> 
<p><span style="white-space:pre">struct </span>mybuf<span style="white-space:pre">*p = (struct</span>mybuf<span style="white-space:pre">*)p</span>_mydata<span style="white-space:pre">;</span></p> 
<p><span style="white-space:pre"></span>那么在C#内该如何调用该函数接口呢？很简单举一反三ref嘛……</p> 
<p><span style="white-space:pre"></span>好了,代码如下：<span style="white-space:pre"> </span> </p> 
<p></p> 
<pre><code class="language-csharp">[StructLayout(LayoutKind.Sequential)]
public struct MyBuf
{
	public int num1;
	public int num2;
	public MyBuf(int n1,int n2)
	{
		num1 = n1;
		num2 = n2;
	}
}
[DllImport("你的dll名称", EntryPoint = "fnAdd", CallingConvention = CallingConvention.Cdecl)]
public static extern int fnAdd(ref MyBuf mydata);</code></pre> 
<p><span style="white-space:pre"><span style="white-space:pre"></span>对这样就OK了。</span></p> 
<p><span style="white-space:pre"><strong>五、</strong>其实这样调用还有更复杂的，比如结构体内嵌套结构体，嵌套结构体指针，结构体内包含数组，这些都需要在C#</span></p> 
<p><span style="white-space:pre">内声明结构体的时候需要特别处理，暂时就不增加这样的难度了。</span></p> 
<p><span style="white-space:pre"><span style="white-space:pre"></span>&lt;over&gt;</span></p> 
<p><span style="white-space:pre"><strong><span style="color:#ff0000">&lt;补&gt;</span></strong></span></p> 
<p><span style="white-space:pre"><strong>为了继续增加点难度，下面继续补充几种情况，来涨点姿势……</strong></span></p> 
<p><span style="white-space:pre"><strong>六、</strong>dll接口参数内的结构体包含一个整形，一个字符数组</span></p> 
<p><span style="white-space:pre"><span style="white-space:pre"></span>eg：如下的结构体</span></p> 
<p><span style="white-space:pre"><span style="white-space:pre"></span></span></p> 
<pre><code class="language-cpp">struct mybuf
{
	int a;
	int b;
	bool bl;
	int arr[200];
	char ch[100];
};</code></pre> 
<span style="white-space:pre"></span>dll内接口原型为int fnAdd(struct mybuf mydata)，那么这种情况在C#下该如何调用呢？ 
<p></p> 
<p><span style="white-space:pre"><span style="white-space:pre"></span>在C#中数据的布局和C(C++)中的数据布局有很大的不同，因此当用户需要在C#和C代码间进行数据传递时，必须手动</span></p> 
<p><span style="white-space:pre">的告诉C#的老大.NET，这批数据该怎么传递给C的DLL来使用；因此这就涉及了C#的历史遗留问题（<strong><span style="color:#ff0000">数据封送</span></strong>）。好</span></p> 
<p><span style="white-space:pre">不多说先上代码，在C#该怎么声明这样一个结构体呢，如下：</span></p> 
<p></p> 
<pre><code class="language-csharp">[StructLayout(LayoutKind.Sequential)]
public struct MyBuf
{
    public int num1;
    public int num2;
    public bool flg;
    // 整形数组
    [MarshalAs(UnmanagedType.ByValArray, SizeConst = 200)]
    public int[] buf;
    // 字符数组
    [MarshalAs(UnmanagedType.ByValTStr, SizeConst = 100)]
    public char[] ch;
    public MyBuf(int n1, int n2, bool bl)
    {
        num1 = n1;
        num2 = n2;
        flg = bl;
        buf = new int[200];
        ch = new char[100];
    }
};</code></pre> 
<p><br> </p> 
<p>是的，你可能奇怪的发现每个数值的声明前，增加了一个[MarshalAsxxxx]字段，这是干嘛用的呢？这就是前面红色字体标注的数据封送格式，简单介绍一下，MarshalAs的属性告诉了.NET如何将下面的数据进行封送到dll接口中，当UnmanagedType的值为ByValArray时，就是告诉下面的数据是一个数组，并且使用这个ByValArray值后面必须跟上SizeConst来告诉.NET这个数组的大小，如上；其实VS2010内写代码的时候当输入UnmanagedType之后按【.】之后VS会自动弹出框里面会列举很多数据封送格式，每个格式都有中文的tooltip来说明，自己看看就会明白的；前段时间看到字符数组和整形数据数据封送格式不一样，整形用ByValArray，而字符使用ByValTStr，但是实际我测下来当字符使用ByValTStr时调试的时候回报错，说非法的封送格式，把字符封送也改为ByValArray后就OK了，不晓得啥问题？还要继续研究。那么继续，在C#把结构体封装好了，就可以直接调用了，无论是结构体还是结构体指针按照前面的方法就可以使用了。<br> </p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/aa5fb4b21d469b0c9ea7de6610c54137/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">【Linux知识】服务器性能测试--UnixBench</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/a4e1809a7568f79798188379c73dec6a/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">如何查看某个网站的ip地址(根据域名怎么知道IP)</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>