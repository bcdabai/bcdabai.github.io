<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>this指针详解 - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="this指针详解" />
<meta property="og:description" content="this指针 this 实际上是成员函数的一个形参，在调用成员函数时将对象的地址作为实参传递给 this。不过 this 这个形参是隐式的，它并不出现在代码中，而是在编译阶段由编译器默默地将它添加到参数列表中。
this指针是类的指针，指向对象的首地址。
this指针只能在成员函数中使用，在全局函数、静态成员函数中都不能用this。
this指针只有在成员函数中才有定义，且存储位置会因编译器不同有不同存储位置。
this指针的用处 一个对象的this指针并不是对象本身的一部分，不会影响sizeof(对象)的结果。this作用域是在类内部， 当在类的非静态成员函数中访问类的非静态成员的时候（全局函数，静态函数中不能使用this指针）， 编译器会自动将对象本身的地址作为一个隐含参数传递给函数。也就是说，即使你没有写上this指针， 编译器在编译的时候也是加上this的，它作为非静态成员函数的隐含形参，对各成员的访问均通过this 进行
this指针的使用 一种情况就是，在类的非静态成员函数中返回类对象本身的时候，直接使用 return *this；
另外一种情况是当形参数与成员变量名相同时用于区分，如this-&gt;n = n （不能写成n = n）
类的this指针有以下特点 (1）this只能在成员函数中使用，全局函数、静态函数都不能使用this。实际上，成员函数默认第一个 参数为T * const this
如：
class A{ public: int func(int p){} 4	}; 其中，func的原型在编译器看来应该是： int func(A * const this,int p); （2）由此可见，this在成员函数的开始前构造，在成员函数的结束后清除。这个生命周期同任何一个 函数的参数是一样的，没有任何区别。当调用一个类的成员函数时，编译器将类的指针作为函数的this 参数传递进去。如：
A a; a.func(10); //此处，编译器将会编译成： 4	A::func(&amp;a,10); 看起来和静态函数没差别，对吗？不过，区别还是有的。编译器通常会对this指针做一些优化，因此，
this指针的传递效率比较高，例如VC通常是通过ecx（计数寄存器）传递this参数的。
几个this指针的易混问题 A. this指针是什么时候创建的？ this在成员函数的开始执行前构造，在成员的执行结束后清除。
但是如果class或者struct里面没有方法的话，它们是没有构造函数的，只能当做C的struct使用。采用TYPE xx的方式定义的话，在栈里分配内存，这时候this指针的值就是这块内存的地址。采用new的方式创建对象的话，在堆里分配内存，new操作符通过eax（累加寄存器）返回分配的地址，然后设置给指针变量。之后去调用构造函数（如果有构造函数的话），这时将这个内存块的地址传给ecx，之后构造 函数里面怎么处理请看上面的回答
B. this指针存放在何处？堆、栈、全局变量，还是其他？ this指针会因编译器不同而有不同的放置位置。可能是栈，也可能是寄存器，甚至全局变量。在汇编级 别里面，一个值只会以3种形式出现：立即数、寄存器值和内存变量值。不是存放在寄存器就是存放在 内存中，它们并不是和高级语言变量对应的。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/ffa2d4fe1e4539512bc5bf0083578011/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-11-07T20:16:29+08:00" />
<meta property="article:modified_time" content="2022-11-07T20:16:29+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">this指针详解</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <h3><a id="this_0"></a>this指针</h3> 
<p>this 实际上是成员函数的一个形参，在调用成员函数时将对象的地址作为实参传递给 this。不过 this 这个形参是隐式的，它并不出现在代码中，而是在编译阶段由编译器默默地将它添加到参数列表中。</p> 
<p>this指针是类的指针，指向对象的首地址。<br> this指针只能在成员函数中使用，在全局函数、静态成员函数中都不能用this。<br> this指针只有在成员函数中才有定义，且存储位置会因编译器不同有不同存储位置。</p> 
<h3><a id="this_7"></a>this指针的用处</h3> 
<p>一个对象的this指针并不是对象本身的一部分，不会影响sizeof(对象)的结果。this作用域是在类内部， 当在类的非静态成员函数中访问类的非静态成员的时候（全局函数，静态函数中不能使用this指针）， 编译器会自动将对象本身的地址作为一个隐含参数传递给函数。也就是说，即使你没有写上this指针， 编译器在编译的时候也是加上this的，它作为非静态成员函数的隐含形参，对各成员的访问均通过this 进行</p> 
<h3><a id="this_10"></a>this指针的使用</h3> 
<p>一种情况就是，在类的非静态成员函数中返回类对象本身的时候，直接使用 return *this；</p> 
<p>另外一种情况是当形参数与成员变量名相同时用于区分，如this-&gt;n = n （不能写成n = n）</p> 
<h3><a id="this_15"></a>类的this指针有以下特点</h3> 
<p>(1）this只能在成员函数中使用，全局函数、静态函数都不能使用this。实际上，成员函数默认第一个 参数为T * const this<br> 如：</p> 
<pre><code class="prism language-cpp">	<span class="token keyword">class</span> <span class="token class-name">A</span><span class="token punctuation">{<!-- --></span>
	<span class="token keyword">public</span><span class="token operator">:</span>
	<span class="token keyword">int</span> <span class="token function">func</span><span class="token punctuation">(</span><span class="token keyword">int</span> p<span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span><span class="token punctuation">}</span> <span class="token number">4</span>	<span class="token punctuation">}</span><span class="token punctuation">;</span>

其中，func的原型在编译器看来应该是：
 
<span class="token keyword">int</span> <span class="token function">func</span><span class="token punctuation">(</span>A <span class="token operator">*</span> <span class="token keyword">const</span> <span class="token keyword">this</span><span class="token punctuation">,</span><span class="token keyword">int</span> p<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> 
<p>（2）由此可见，this在成员函数的开始前构造，在成员函数的结束后清除。这个生命周期同任何一个 函数的参数是一样的，没有任何区别。当调用一个类的成员函数时，编译器将类的指针作为函数的this 参数传递进去。如：</p> 
<pre><code class="prism language-cpp">	A a<span class="token punctuation">;</span>
	a<span class="token punctuation">.</span><span class="token function">func</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token comment">//此处，编译器将会编译成： </span>
	<span class="token number">4</span>	<span class="token class-name">A</span><span class="token double-colon punctuation">::</span><span class="token function">func</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>a<span class="token punctuation">,</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> 
<p>看起来和静态函数没差别，对吗？不过，区别还是有的。编译器通常会对this指针做一些优化，因此，<br> this指针的传递效率比较高，例如VC通常是通过ecx（计数寄存器）传递this参数的。</p> 
<h3><a id="this_38"></a>几个this指针的易混问题</h3> 
<h3><a id="A_this_39"></a>A. this指针是什么时候创建的？</h3> 
<p>this在成员函数的开始执行前构造，在成员的执行结束后清除。<br> 但是如果class或者struct里面没有方法的话，它们是没有构造函数的，只能当做C的struct使用。采用TYPE xx的方式定义的话，在栈里分配内存，这时候this指针的值就是这块内存的地址。采用new的方式创建对象的话，在堆里分配内存，new操作符通过eax（累加寄存器）返回分配的地址，然后设置给指针变量。之后去调用构造函数（如果有构造函数的话），这时将这个内存块的地址传给ecx，之后构造 函数里面怎么处理请看上面的回答</p> 
<h3><a id="B_this_43"></a>B. this指针存放在何处？堆、栈、全局变量，还是其他？</h3> 
<p>this指针会因编译器不同而有不同的放置位置。可能是栈，也可能是寄存器，甚至全局变量。在汇编级 别里面，一个值只会以3种形式出现：立即数、寄存器值和内存变量值。不是存放在寄存器就是存放在 内存中，它们并不是和高级语言变量对应的。</p> 
<h3><a id="C_thisthisthis__47"></a>C. this指针是如何传递类中的函数的？绑定？还是在函数参数的首参数就是this指针？那么，this指针 又是如何找到“类实例后函数的”？</h3> 
<p>大多数编译器通过ecx（计数寄存器）寄存器传递this指针。事实上，这也是一个潜规则。一般来说，不 同编译器都会遵从一致的传参规则，否则不同编译器产生的obj就无法匹配了。<br> 在call之前，编译器会把对应的对象地址放到eax中。this是通过函数参数的首参来传递的。this指针在 调用之前生成，至于“类实例后函数”，没有这个说法。类在实例化时，只分配类中的变量空间，并没有 为函数分配空间。自从类的函数定义完成后，它就在那儿，不会跑的</p> 
<h3><a id="D_this_52"></a>D. this指针是如何访问类中的变量的？</h3> 
<p>如果不是类，而是结构体的话，那么，如何通过结构指针来访问结构中的变量呢？如果你明白这一点的 话，就很容易理解这个问题了。<br> 在C++中，类和结构是只有一个区别的：类的成员默认是private，而结构是public。<br> this是类的指针，如果换成结构体，那this就是结构的指针了。</p> 
<h3><a id="E_thisthis__58"></a>E. 我们只有获得一个对象后，才能通过对象使用this指针。如果我们知道一个对象this指针的位置，可 以直接使用吗？</h3> 
<p>this指针只有在成员函数中才有定义。因此，你获得一个对象后，也不能通过对象使用this指针。所 以，我们无法知道一个对象的this指针的位置（只有在成员函数里才有this指针的位置）。当然，在成 员函数里，你是可以知道this指针的位置的（可以通过&amp;this获得），也可以直接使用它。</p> 
<h3><a id="F__62"></a>F. 每个类编译后，是否创建一个类中函数表保存函数指针，以便用来调用函数？</h3> 
<p>普通的类函数（不论是成员函数，还是静态函数）都不会创建一个函数表来保存函数指针。只有虚函数 才会被放到函数表中。但是，即使是虚函数，如果编译期就能明确知道调用的是哪个函数，编译器就不会通过函数表中的指针来间接调用，而是会直接调用该函数。正是由于this指针的存在，用来指向不同的对象，从而确保不同对象之间调用相同的函数可以互不干扰。</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/704462e3e987dce638ef510b4f88ee34/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">SQL Server数据库管理</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/ccd2a23361c2a0f75826c993a774103e/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">Json以及Json在Qt中的使用</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>