<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>设计模式之访问者模式 - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="设计模式之访问者模式" />
<meta property="og:description" content="问者模式概念：封装作用于某对象结构中的各元素的操作，它使你可以在不改变各元素的类的前提下定义作用于这些元素的新操作。
通俗的解释就是，系统中有一些固定结构的对象(元素)，在其内部提供一个accept()方法用来接受访问者对象的访问，不同的访问者对同一元素的访问内容不同，所以使得相同的元素可以产生不同的元素结果。
比如在一个人事管理系统中，有多个工种的员工和多个老板，不同的老板对同一个员工的关注点是不同的，CTO可能关注的就是技术，CEO可能更注重绩效。
员工就是一个稳定的元素，老板就是变化的，对应概念就是：封装员工的一些操作，可以在不改变员工类的前提下，增加新的老板访问同一个员工。
在访问者模式中包含五个角色，抽象元素、具体元素、抽象访问者、具体访问者、结构元素。
抽象元素：定义一个接受访问的方法accept，参数为访问者对象。
具体元素：提供接受访问者访问的具体实现调用访问者的访问visit，并定义额外的数据操作方法。
抽象访问者：这个角色主要是定义对具体元素的访问方法visit，理论上来说方法数等于元素(固定类型的对象，也就是被访问者)个数。
具体访问者：实现对具体元素的访问visit方法，参数就是具体元素。
结构对象：创建一个数组用来维护元素，并提供一个方法访问所有的元素。
二、案例实现 在一个公司有干活的工程师和管理者，也有抓技术的CTO和管绩效的CEO，CTO和CEO都会访问管理员和工程师，当公司来了新的老板，只需要增加访问者即可。
工程师和管理者就是元素、公司就是结构体、CEO、CTO就是访问者。
抽象元素：
1 2 3 4 5 6 7 8 /** * 员工 抽象元素 被访问者 * @author tcy * @Date 29-09-2022 */ public interface ElementAbstract { void accept(VisitorAbstract visitor); } ASPECTJ
具体元素-工程师：
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 /** * 工程师 具体元素 被访问者 * @author tcy * @Date 29-09-2022 */ public class ElementEngineer implements ElementAbstract { private String name; private int kpi; ElementEngineer(String name){ this." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/83934f096bfe37a156b9af9a76e99f1b/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-05-18T14:00:08+08:00" />
<meta property="article:modified_time" content="2023-05-18T14:00:08+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">设计模式之访问者模式</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p>问者模式概念：封装作用于某对象结构中的各元素的操作，它使你可以在不改变各元素的类的前提下定义作用于这些元素的新操作。</p> 
<p>通俗的解释就是，系统中有一些固定结构的对象(元素)，在其内部提供一个accept()方法用来接受访问者对象的访问，不同的访问者对同一元素的访问内容不同，所以使得相同的元素可以产生不同的元素结果。</p> 
<p>比如在一个人事管理系统中，有多个工种的员工和多个老板，不同的老板对同一个员工的关注点是不同的，CTO可能关注的就是技术，CEO可能更注重绩效。</p> 
<p>员工就是一个稳定的元素，老板就是变化的，对应概念就是：封装员工的一些操作，可以在不改变员工类的前提下，增加新的老板访问同一个员工。</p> 
<p>在访问者模式中包含五个角色，抽象元素、具体元素、抽象访问者、具体访问者、结构元素。</p> 
<p>抽象元素：定义一个接受访问的方法accept，参数为访问者对象。</p> 
<p>具体元素：提供接受访问者访问的具体实现调用访问者的访问visit，并定义额外的数据操作方法。</p> 
<p>抽象访问者：这个角色主要是定义对具体元素的访问方法visit，理论上来说方法数等于元素(固定类型的对象，也就是被访问者)个数。</p> 
<p>具体访问者：实现对具体元素的访问visit方法，参数就是具体元素。</p> 
<p>结构对象：创建一个数组用来维护元素，并提供一个方法访问所有的元素。</p> 
<h3 id="二、案例实现">二、案例实现</h3> 
<p>在一个公司有干活的工程师和管理者，也有抓技术的CTO和管绩效的CEO，CTO和CEO都会访问管理员和工程师，当公司来了新的老板，只需要增加访问者即可。</p> 
<p>工程师和管理者就是元素、公司就是结构体、CEO、CTO就是访问者。</p> 
<p>抽象元素：</p> 
<table><tbody><tr><td> <pre>1
2
3
4
5
6
7
8
</pre> </td><td> <pre><code>/**
 *  员工 抽象元素 被访问者
 * @author tcy
 * @Date 29-09-2022
 */
public interface ElementAbstract {
    void accept(VisitorAbstract visitor);
}
</code></pre> <p>ASPECTJ</p> </td></tr></tbody></table> 
<p>具体元素-工程师：</p> 
<table><tbody><tr><td> <pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
</pre> </td><td> <pre><code>/**
 * 工程师 具体元素 被访问者
 * @author tcy
 * @Date 29-09-2022
 */
public class ElementEngineer implements ElementAbstract {

    private String name;

    private int kpi;

    ElementEngineer(String name){
        this.name = name;
        this.kpi = new Random().nextInt(10);
    }

    public String getName() {
        return name;
    }

    public int getKpi() {
        return kpi;
    }


    @Override
    public void accept(VisitorAbstract visitor) {
        visitor.visit(this);
    }

    public int getCodeLineTotal(){
        return this.kpi * 1000000;
    }
}
</code></pre> <p>TYPESCRIPT</p> </td></tr></tbody></table> 
<p>具体元素-管理者：</p> 
<table><tbody><tr><td> <pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
</pre> </td><td> <pre><code>/**
 * 管理者 具体元素 被访问者
 * @author tcy
 * @Date 29-09-2022
 */
public class ElementManager implements ElementAbstract {
    private String name;

    private int kpi;

    ElementManager(String name){
        this.name = name;
        this.kpi = new Random().nextInt(10);
    }

    public String getName() {
        return name;
    }

    public int getKpi() {
        return kpi;
    }

    @Override
    public void accept(VisitorAbstract visitor) {
        visitor.visit(this);
    }

    public int getProductNum(){
        return this.kpi * 10;
    }

}
</code></pre> <p>TYPESCRIPT</p> </td></tr></tbody></table> 
<p>抽象访问者：</p> 
<table><tbody><tr><td> <pre>1
2
3
4
5
6
7
8
9
10
</pre> </td><td> <pre><code>/**
 * 抽象访问者
 * @author tcy
 * @Date 29-09-2022
 */
public interface VisitorAbstract {
    void visit(ElementEngineer engineer);

    void visit(ElementManager manager);
}
</code></pre> <p>ASPECTJ</p> </td></tr></tbody></table> 
<p>具体访问者-CEO</p> 
<table><tbody><tr><td> <pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
</pre> </td><td> <pre><code>/**
 * 具体访问者CEO
 * @author tcy
 * @Date 29-09-2022
 */
public class VisitorCEO implements VisitorAbstract {
    @Override
    public void visit(ElementEngineer engineer) {
        System.out.println("工程师：" + engineer.getName() + "KPI:" + engineer.getKpi());
    }

    @Override
    public void visit(ElementManager manager) {
        System.out.println("经理：" + manager.getName() + "KPI:" + manager.getKpi() + " 今年共完成项目：" + manager.getProductNum() + "个");
    }
}
</code></pre> <p>TYPESCRIPT</p> </td></tr></tbody></table> 
<p>具体访问者-CTO</p> 
<table><tbody><tr><td> <pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
</pre> </td><td> <pre><code>/**
 * 具体访问者CTO
 * @author tcy
 * @Date 29-09-2022
 */
public class VisitorCTO implements VisitorAbstract {
    @Override
    public void visit(ElementEngineer engineer) {
        System.out.println("工程师：" + engineer.getName() + " 今年代码量" + engineer.getCodeLineTotal() + "行");
    }

    @Override
    public void visit(ElementManager manager) {
        System.out.println("经理：" + manager.getName() + " 今年共完成项目：" + manager.getProductNum() + "个");
    }
}
</code></pre> <p>TYPESCRIPT</p> </td></tr></tbody></table> 
<p>结构体：</p> 
<table><tbody><tr><td> <pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
</pre> </td><td> <pre><code>/**
 * 结构对象
 * @author tcy
 * @Date 29-09-2022
 */
public class Structure {
    List&lt;ElementAbstract&gt; list = new ArrayList&lt;&gt;();

    public Structure addEmployee(ElementAbstract employee){
        list.add(employee);
        return this;
    }

    public void report(VisitorAbstract visitor){
        list.forEach(employee -&gt; {
            employee.accept(visitor);
        });
    }

}
</code></pre> <p>TYPESCRIPT</p> </td></tr></tbody></table> 
<p>客户端：</p> 
<table><tbody><tr><td> <pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
</pre> </td><td> <pre><code>/**
 * @author tcy
 * @Date 29-09-2022
 */
public class Client {
    public static void main(String[] args) {
        //元素对象
        ElementEngineer engineerZ = new ElementEngineer("小张");
        ElementEngineer engineerW = new ElementEngineer("小王");
        ElementEngineer engineerL = new ElementEngineer("小李");

        ElementManager managerZ = new ElementManager("张总");
        ElementManager managerW = new ElementManager("王总");
        ElementManager managerL = new ElementManager("李总");

        //结构体对象
        Structure structure = new Structure();
        structure.addEmployee(engineerZ).addEmployee(engineerW).addEmployee(engineerL).addEmployee(managerZ).addEmployee(managerW).addEmployee(managerL);
        structure.report(new VisitorCTO());
        System.out.println("---------------------------------------");
        structure.report(new VisitorCEO());


    }
}
</code></pre> <p>REASONML</p> </td></tr></tbody></table> 
<p>访问者不愧是最难的设计模式，方法间的调用错综复杂，日常开发的使用频率很低，很多程序员宁可代码写的麻烦一点也不用这种设计模式，但是作为学习者就要学习各种设计模式了。</p> 
<h3 id="三、访问者模式在JDk中的应用">三、访问者模式在JDk中的应用</h3> 
<p>JDK的NIO中的 FileVisitor 接口采用的就是访问者模式。</p> 
<p>在早期的 Java 版本中，如果要对指定目录下的文件进行遍历，必须用递归的方式来实现，这种方法复杂且灵活性不高。</p> 
<p>Java 7 版本后，Files 类提供了 walkFileTree() 方法，该方法可以很容易的对目录下的所有文件进行遍历，需要 Path、FileVisitor 两个参数。其中，Path 是要遍历文件的路径，FileVisitor 则可以看成一个文件访问器，源码如下。</p> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/29/6b/TayLXiis_o.png"></p> 
<p>image-20220930092623291</p> 
<p>FileVisitor 主要提供了 4 个方法，且返回结果的都是 FileVisitResult 对象值，用于决定当前操作完成后接下来该如何处理。FileVisitResult 是一个枚举类，代表返回之后的一些后续操作，源码如下。</p> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/d1/08/gqjXK1OO_o.png"></p> 
<p>image-20220929150014824</p> 
<p>FileVisitResult 主要包含 4 个常见的操作。</p> 
<ul><li>FileVisitResult.CONTINUE：这个访问结果表示当前的遍历过程将会继续。</li><li>FileVisitResult.SKIP_SIBLINGS：这个访问结果表示当前的遍历过程将会继续，但是要忽略当前文件/目录的兄弟节点。</li><li>FileVisitResult.SKIP_SUBTREE：这个访问结果表示当前的遍历过程将会继续，但是要忽略当前目录下的所有节点。</li><li>FileVisitResult.TERMINATE：这个访问结果表示当前的遍历过程将会停止。</li></ul> 
<p>通过访问者去遍历文件树会比较方便，比如查找文件夹内符合某个条件的文件或者某一天内所创建的文件，这个类中都提供了相对应的方法。它的实现也非常简单，代码如下。</p> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/e8/5e/ruxpvGps_o.png"></p> 
<p>image-20220929150056647</p> 
<p>在JDK的应用中我们提供的文件就看做是一个稳定元素，对应访问者模式中的抽象元素；而Files.walkFileTree()方法中的FileVisitor 参数就可看做是角色中的访问者。</p> 
<h3 id="四、访问者模式中的伪动态双分派">四、访问者模式中的伪动态双分派</h3> 
<p>访问者模式中有一个重要的概念叫：伪动态双分派。</p> 
<p>我们一步一步解读它的含义，什么叫分派？根据对象的类型而对方法进行的选择,就是分派(Dispatch)。</p> 
<p>发生在编译时的分派叫静态分派，例如重载（overload），发生在运行时的分派叫动态分派，例如重写（overwrite）。</p> 
<p>其中分派又分为单分派和多分派。</p> 
<p>单分派:依据单个变量进行方法的选择就叫单分派，Java 动态分派（重写）只根据方法的接收者一个变量进行分配，所以其是单分派。</p> 
<p>多分派:依据多个变量进行方法的选择就叫多分派，Java 静态分派（重载）要根据方法的接收者与参数这两个变量进行分配，所以其是多分派。</p> 
<p>理解了概念我们接着看我们的案例：</p> 
<table><tbody><tr><td> <pre>1
2
3
4
</pre> </td><td> <pre><code>@Override
   public void accept(VisitorAbstract visitor) {
       visitor.visit(this);
   }
</code></pre> <p>TYPESCRIPT</p> </td></tr></tbody></table> 
<p>我们案例中的accept方法，是由元素的运行时类型决定的，应该是属于动态单分派。</p> 
<p>我们接着看 visitor.visit(this)又是一次动态单分派，两次动态单分派实现了双分派的效果，所以称为伪动态双分派。</p> 
<p>这个概念理解就好，实际应用中知不知道这玩意都不影响。</p> 
<h3 id="五、总结"></h3>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/1f7d3537a7955b5c20f38f840b61a0f0/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">VueSeamlessScroll 无缝滚动点击事件不生效</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/5afb5ff9788b408b1a84cb051456516f/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">K8S的Pod类型-StatefulSet和Deployment区别与应用</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>