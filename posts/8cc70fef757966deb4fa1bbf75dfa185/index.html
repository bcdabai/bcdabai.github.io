<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>kubernetes中PV和PVC - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="kubernetes中PV和PVC" />
<meta property="og:description" content="目录
一、PV、PVC简介
二、PV、PVC关系
三、创建静态PV
1.配置nfs存储
2.定义PV
3.定义PVC
4.测试访问
四、 搭建 StorageClass &#43; nfs-client-provisioner ，实现 NFS 的动态 PV 创建
1. 配置nfs服务
2.创建 Service Account
3.使用 Deployment 来创建 NFS Provisioner
3.1由于 1.20 版本启用了 selfLink，所以 k8s 1.20&#43; 版本通过 nfs provisioner 动态生成pv会报错，解决方法如下
3.2创建 NFS Provisioner 4.创建 StorageClass
5.创建 PVC 和 Pod 测试
一、PV、PVC简介 PV 全称叫做 Persistent Volume，持久化存储卷。K8S在指定存储设备空间中逻辑划分创建的可持久化的存储资源对象。
PVC 的全称是 Persistent Volume Claim，是持久化存储的请求。是对PV资源对象的请求和绑定，也是Pod能挂载使用的一种存储卷类型。
PV是集群中的资源。 PVC是对这些资源的请求，也是对资源的索引检查。 二、PV、PVC关系 PV和PVC之间的相互作用遵循生命周期：
Provisioning（配置）---&gt; Binding（绑定）---&gt; Using（使用）---&gt; Releasing（释放） ---&gt; Recycling（回收）
Provisioning，即 PV 的创建，可以直接创建 PV（静态方式），也可以使用 StorageClass 动态创建Binding，将 PV 分配给 PVCUsing，Pod 通过 PVC 使用该 Volume，并可以通过准入控制StorageProtection（1." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/8cc70fef757966deb4fa1bbf75dfa185/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-08-14T22:00:58+08:00" />
<meta property="article:modified_time" content="2023-08-14T22:00:58+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">kubernetes中PV和PVC</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p id="main-toc"><strong>目录</strong></p> 
<p id="-toc" style="margin-left:0px;"></p> 
<p id="%E4%B8%80%E3%80%81PV%E3%80%81PVC%E7%AE%80%E4%BB%8B-toc" style="margin-left:0px;"><a href="#%E4%B8%80%E3%80%81PV%E3%80%81PVC%E7%AE%80%E4%BB%8B" rel="nofollow">一、PV、PVC简介</a></p> 
<p id="%E4%BA%8C%E3%80%81PV%E3%80%81PVC%E5%85%B3%E7%B3%BB-toc" style="margin-left:0px;"><a href="#%E4%BA%8C%E3%80%81PV%E3%80%81PVC%E5%85%B3%E7%B3%BB" rel="nofollow">二、PV、PVC关系</a></p> 
<p id="%E4%B8%89%E3%80%81%E5%88%9B%E5%BB%BA%E9%9D%99%E6%80%81PV-toc" style="margin-left:0px;"><a href="#%E4%B8%89%E3%80%81%E5%88%9B%E5%BB%BA%E9%9D%99%E6%80%81PV" rel="nofollow">三、创建静态PV</a></p> 
<p id="1.%E9%85%8D%E7%BD%AEnfs%E5%AD%98%E5%82%A8-toc" style="margin-left:40px;"><a href="#1.%E9%85%8D%E7%BD%AEnfs%E5%AD%98%E5%82%A8" rel="nofollow">1.配置nfs存储</a></p> 
<p id="2.%E5%AE%9A%E4%B9%89PV-toc" style="margin-left:40px;"><a href="#2.%E5%AE%9A%E4%B9%89PV" rel="nofollow">2.定义PV</a></p> 
<p id="%C2%A03.%E5%AE%9A%E4%B9%89PVC-toc" style="margin-left:40px;"><a href="#%C2%A03.%E5%AE%9A%E4%B9%89PVC" rel="nofollow"> 3.定义PVC</a></p> 
<p id="4.%E6%B5%8B%E8%AF%95%E8%AE%BF%E9%97%AE-toc" style="margin-left:40px;"><a href="#4.%E6%B5%8B%E8%AF%95%E8%AE%BF%E9%97%AE" rel="nofollow">4.测试访问</a></p> 
<p id="%E5%9B%9B%E3%80%81%C2%A0%E6%90%AD%E5%BB%BA%20StorageClass%20%2B%20nfs-client-provisioner%20%EF%BC%8C%E5%AE%9E%E7%8E%B0%20NFS%20%E7%9A%84%E5%8A%A8%E6%80%81%20PV%20%E5%88%9B%E5%BB%BA-toc" style="margin-left:0px;"><a href="#%E5%9B%9B%E3%80%81%C2%A0%E6%90%AD%E5%BB%BA%20StorageClass%20%2B%20nfs-client-provisioner%20%EF%BC%8C%E5%AE%9E%E7%8E%B0%20NFS%20%E7%9A%84%E5%8A%A8%E6%80%81%20PV%20%E5%88%9B%E5%BB%BA" rel="nofollow">四、 搭建 StorageClass + nfs-client-provisioner ，实现 NFS 的动态 PV 创建</a></p> 
<p id="1.%C2%A0%E9%85%8D%E7%BD%AEnfs%E6%9C%8D%E5%8A%A1-toc" style="margin-left:40px;"><a href="#1.%C2%A0%E9%85%8D%E7%BD%AEnfs%E6%9C%8D%E5%8A%A1" rel="nofollow">1. 配置nfs服务</a></p> 
<p id="2.%E5%88%9B%E5%BB%BA%20Service%20Account-toc" style="margin-left:40px;"><a href="#2.%E5%88%9B%E5%BB%BA%20Service%20Account" rel="nofollow">2.创建 Service Account</a></p> 
<p id="3.%E4%BD%BF%E7%94%A8%20Deployment%20%E6%9D%A5%E5%88%9B%E5%BB%BA%20NFS%20Provisioner-toc" style="margin-left:40px;"><a href="#3.%E4%BD%BF%E7%94%A8%20Deployment%20%E6%9D%A5%E5%88%9B%E5%BB%BA%20NFS%20Provisioner" rel="nofollow">3.使用 Deployment 来创建 NFS Provisioner</a></p> 
<p id="3.1%E7%94%B1%E4%BA%8E%201.20%20%E7%89%88%E6%9C%AC%E5%90%AF%E7%94%A8%E4%BA%86%20selfLink%EF%BC%8C%E6%89%80%E4%BB%A5%20k8s%201.20%2B%20%E7%89%88%E6%9C%AC%E9%80%9A%E8%BF%87%20nfs%20provisioner%20%E5%8A%A8%E6%80%81%E7%94%9F%E6%88%90pv%E4%BC%9A%E6%8A%A5%E9%94%99%EF%BC%8C%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95%E5%A6%82%E4%B8%8B-toc" style="margin-left:80px;"><a href="#3.1%E7%94%B1%E4%BA%8E%201.20%20%E7%89%88%E6%9C%AC%E5%90%AF%E7%94%A8%E4%BA%86%20selfLink%EF%BC%8C%E6%89%80%E4%BB%A5%20k8s%201.20%2B%20%E7%89%88%E6%9C%AC%E9%80%9A%E8%BF%87%20nfs%20provisioner%20%E5%8A%A8%E6%80%81%E7%94%9F%E6%88%90pv%E4%BC%9A%E6%8A%A5%E9%94%99%EF%BC%8C%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95%E5%A6%82%E4%B8%8B" rel="nofollow">3.1由于 1.20 版本启用了 selfLink，所以 k8s 1.20+ 版本通过 nfs provisioner 动态生成pv会报错，解决方法如下</a></p> 
<p id="3.2%E5%88%9B%E5%BB%BA%20NFS%20Provisioner%C2%A0-toc" style="margin-left:80px;"><a href="#3.2%E5%88%9B%E5%BB%BA%20NFS%20Provisioner%C2%A0" rel="nofollow">3.2创建 NFS Provisioner </a></p> 
<p id="4.%E5%88%9B%E5%BB%BA%20StorageClass-toc" style="margin-left:40px;"><a href="#4.%E5%88%9B%E5%BB%BA%20StorageClass" rel="nofollow">4.创建 StorageClass</a></p> 
<p id="5.%E5%88%9B%E5%BB%BA%20PVC%20%E5%92%8C%20Pod%20%E6%B5%8B%E8%AF%95-toc" style="margin-left:40px;"><a href="#5.%E5%88%9B%E5%BB%BA%20PVC%20%E5%92%8C%20Pod%20%E6%B5%8B%E8%AF%95" rel="nofollow">5.创建 PVC 和 Pod 测试</a></p> 
<hr id="hr-toc"> 
<p></p> 
<h2 id="%E4%B8%80%E3%80%81PV%E3%80%81PVC%E7%AE%80%E4%BB%8B">一、PV、PVC简介</h2> 
<p>PV 全称叫做 Persistent Volume，持久化存储卷。K8S在指定存储设备空间中逻辑划分创建的可持久化的存储资源对象。</p> 
<p>PVC 的全称是 Persistent Volume Claim，是持久化存储的请求。是对PV资源对象的请求和绑定，也是Pod能挂载使用的一种存储卷类型。</p> 
<p><strong>PV是集群中的资源。 PVC是对这些资源的请求，也是对资源的索引检查。</strong> </p> 
<h2 id="%E4%BA%8C%E3%80%81PV%E3%80%81PVC%E5%85%B3%E7%B3%BB">二、PV、PVC关系</h2> 
<p><img alt="" height="587" src="https://images2.imgbox.com/90/40/UKirbgXx_o.png" width="1174"></p> 
<p><strong> PV和PVC之间的相互作用遵循生命周期：</strong></p> 
<p>Provisioning（配置）---&gt; Binding（绑定）---&gt; Using（使用）---&gt; Releasing（释放） ---&gt; Recycling（回收）</p> 
<ul><li>Provisioning，即 PV 的创建，可以直接创建 PV（静态方式），也可以使用 StorageClass 动态创建</li><li>Binding，将 PV 分配给 PVC</li><li>Using，Pod 通过 PVC 使用该 Volume，并可以通过准入控制StorageProtection（1.9及以前版本为PVCProtection） 阻止删除正在使用的 PVC</li><li>Releasing，Pod 释放 Volume 并删除 PVC</li><li>Reclaiming，回收 PV，可以保留 PV 以便下次使用，也可以直接从云存储中删除</li></ul> 
<p><strong> 根据5个阶段，PV的状态有以下4种：</strong></p> 
<ul><li>Available（可用）：表示可用状态，还未被任何 PVC 绑定</li><li>Bound（已绑定）：表示 PV 已经绑定到 PVC</li><li>Released（已释放）：表示 PVC 被删掉，但是资源尚未被集群回收</li><li>Failed（失败）：表示该 PV 的自动回收失败</li></ul> 
<p><strong>PV从创建到销毁的具体流程：</strong> </p> 
<ol><li>一个PV创建完后状态会变成Available，等待被PVC绑定。</li><li>一旦被PVC邦定，PV的状态会变成Bound，就可以被定义了相应PVC的Pod使用。</li><li>Pod使用完后会释放PV，PV的状态变成Released。</li><li>变成Released的PV会根据定义的回收策略做相应的回收工作。有三种回收策略，Retain、Delete和Recycle。</li></ol> 
<p><strong>PV回收策略：</strong></p> 
<ul><li>Retain(保留)：当用户删除与之绑定的PVC时候，这个PV被标记为released（PVC与PV解绑但还没有执行回收策略）且之前的数据依然保存在该PV上，但是该PV不可用，需要手动来处理这些数据并删除该PV。</li><li>Delete(删除)：删除与PV相连的后端存储资源。对于动态配置的PV来说，默认回收策略为Delete。表示当用户删除对应的PVC时，动态配置的volume将被自动删除。（只有 AWS EBS, GCE PD, Azure Disk 和 Cinder 支持）</li><li>Recycle(回收)：如果用户删除PVC，则删除卷上的数据，卷不会删除。（只有 NFS 和 HostPath 支持）</li></ul> 
<h2 id="%E4%B8%89%E3%80%81%E5%88%9B%E5%BB%BA%E9%9D%99%E6%80%81PV">三、创建静态PV</h2> 
<p><strong>创建使用 静态PV</strong></p> 
<ol><li>准备好存储设备和共享目录</li><li>手动创建PV资源，配置 存储卷类型 访问模式（RWO RWX ROX RWOP） 存储空间大小  回收策略（Retain Recycle Delete）等</li><li>创建PVC资源，配置请求PV资源的访问模式（必要条件，必须是PV能支持的访问模式） 存储空间大小（默认就近选择大于等于指定大小的PV）来绑定PV</li><li>创建Pod和Pod控制器资源挂载PVC存储卷，配置存储卷类型为 persistentVolumeClaim ，并在容器配置中定义存储卷挂载点目录  </li></ol> 
<p><img alt="" height="698" src="https://images2.imgbox.com/8a/cc/BNr4JrfH_o.png" width="1200"></p> 
<h3 id="1.%E9%85%8D%E7%BD%AEnfs%E5%AD%98%E5%82%A8">1.配置nfs存储</h3> 
<pre><code class="language-bash">mkdir /data/v{1..5}

vim /etc/exports
/data/v1 192.168.88.0/24(rw,no_root_squash,sync)
/data/v2 192.168.88.0/24(rw,no_root_squash,sync)
/data/v3 192.168.88.0/24(rw,no_root_squash,sync)
/data/v4 192.168.88.0/24(rw,no_root_squash,sync)
/data/v5 192.168.88.0/24(rw,no_root_squash,sync)

exportfs -arv

showmount -e</code></pre> 
<h3 id="2.%E5%AE%9A%E4%B9%89PV">2.定义PV</h3> 
<pre><code class="language-bash">vim pv.yaml
apiVersion: v1
kind: PersistentVolume
metadata:        #由于 PV 是集群级别的资源，即 PV 可以跨 namespace 使用，所以 PV 的 metadata 中不用配置 namespace
  name: pv01
  labels:
    name: pv01
spec:
  nfs:                        #定义存储类型
    path: /data/v1            #定义挂载卷路径
    server: 192.168.88.60     #定义服务器名称或地址
  accessModes:                #定义访问模型
  - ReadWriteOnce
  - ReadWriteMany
  capacity:                   #定义存储能力，一般用于设置存储空间
    storage: 1Gi              #指定大小
  storageClassName: slow      #自定义存储类名称，此配置用于绑定具有相同类别的PVC和PV
  persistentVolumeReclaimPolicy: Retain  #回收策略（Retain/Delete/Recycle）
--- 
apiVersion: v1
kind: PersistentVolume
metadata:
  name: pv02
  labels:
    name: pv02
spec:
  nfs:
    path: /data/v2
    server: 192.168.88.60
  accessModes:
  - ReadWriteOnce
  capacity:
    storage: 2Gi
---
apiVersion: v1
kind: PersistentVolume
metadata:
  name: pv03
  labels:
    name: pv03
spec:
  nfs:
    path: /data/v3
    server: 192.168.88.60
  accessModes:
  - ReadWriteOnce
  - ReadWriteMany
  capacity:
    storage: 2Gi
---
apiVersion: v1
kind: PersistentVolume
metadata:
  name: pv04
  labels:
    name: pv04
spec:
  nfs:
    path: /data/v4
    server: 192.168.88.60
  accessModes:
  - ReadWriteOnce
  - ReadWriteMany
  capacity:
    storage: 4Gi
---
apiVersion: v1
kind: PersistentVolume
metadata:
  name: pv05
  labels:
    name: pv05
spec:
  nfs:
    path: /data/v5
    server: 192.168.88.60
  accessModes:
  - ReadWriteOnce
  - ReadWriteMany
  capacity:
    storage: 5Gi

kubectl apply -f pv.yaml
</code></pre> 
<p><img alt="" height="235" src="https://images2.imgbox.com/78/d8/imRI9R9x_o.png" width="1200"></p> 
<h3 id="%C2%A03.%E5%AE%9A%E4%B9%89PVC"> 3.定义PVC</h3> 
<p>定义了pvc的访问模式为多路读写，该访问模式必须在前面pv定义的访问模式之中。定义PVC申请的大小为2Gi，此时PVC会自动去匹配多路读写且大小为2Gi的PV，匹配成功获取PVC的状态即为Bound</p> 
<pre><code class="language-bash">vim pvc.yaml
apiVersion: v1
kind: PersistentVolumeClaim   #定义类型为pvc
metadata:
  name: mypvc-a
  namespace: default
spec:
  accessModes:                #定义pvc的访问模式
  - ReadWriteMany
  resources:
    requests:
      storage: 2Gi            #定义请求pv的大小
---
apiVersion: v1
kind: Pod
metadata:
  name: pod-vol-pvc
  namespace: default
spec:
  containers:
  - name: myapp
    image: nginx:1.14
    volumeMounts:
    - name: html
      mountPath: /usr/share/nginx/html
  volumes:
  - name: html
    persistentVolumeClaim:    #定义挂载的pvc详细信息
      claimName: mypvc-a      #挂载pvc的名称

kubectl apply -f pvc.yaml</code></pre> 
<p><img alt="" height="472" src="https://images2.imgbox.com/e5/ce/BtbAiItw_o.png" width="1200"></p> 
<h3 id="4.%E6%B5%8B%E8%AF%95%E8%AE%BF%E9%97%AE">4.测试访问</h3> 
<pre><code class="language-bash">在存储服务器上创建index.html，并写入数据，通过访问Pod进行查看，可以获取到相应的页面。
cd /data/v3/
echo "welcome to use pv3" &gt; index.html

kubectl get pods -o wide

curl  10.244.1.37
welcome to use pv3</code></pre> 
<h2 id="%E5%9B%9B%E3%80%81%C2%A0%E6%90%AD%E5%BB%BA%20StorageClass%20%2B%20nfs-client-provisioner%20%EF%BC%8C%E5%AE%9E%E7%8E%B0%20NFS%20%E7%9A%84%E5%8A%A8%E6%80%81%20PV%20%E5%88%9B%E5%BB%BA">四、 搭建 StorageClass + nfs-client-provisioner ，实现 NFS 的动态 PV 创建</h2> 
<p>Kubernetes 本身支持的动态 PV 创建不包括 NFS，所以需要使用外部存储卷插件分配PV。详见：https://kubernetes.io/zh/docs/concepts/storage/storage-classes/</p> 
<p>卷插件称为 Provisioner（存储分配器），NFS 使用的是 nfs-client，这个外部卷插件会使用已经配置好的 NFS 服务器自动创建 PV。<br> Provisioner：用于指定 Volume 插件的类型，包括内置插件（如 kubernetes.io/aws-ebs）和外部插件（如 external-storage 提供的 ceph.com/cephfs）。</p> 
<p><strong>创建使用动态PV</strong></p> 
<ol><li>准备好存储设备和共享目录</li><li>如果是外置存储卷插件，需要先创建serviceaccount账户（Pod使用的账户）和做RBAC授权（创建角色授予相关资源对象的操作权限，再将账户和角色进行绑定），使serviceaccount账户具有对PV PVC StorageClass等资源的操作权限</li><li>创建外置存储卷插件provisioner的Pod，配置中使用serviceaccount账户作为Pod的用户，并设置相关环境变量参数</li><li>创建StorageClass（SC）资源，配置中引用存储卷插件的插件（PROVISIONER_NAME）</li><li>创建PVC资源，配置中设置 StorageClass资源名称 访问模式 存储空间大小。创建PVC资源会自动创建相关的PV资源。</li><li>创建Pod资源挂载PVC存储卷，配置存储卷类型为 persistentVolumeClaim ，并在容器配置中定义存储卷挂载点目录<br>  </li></ol> 
<h3 id="1.%C2%A0%E9%85%8D%E7%BD%AEnfs%E6%9C%8D%E5%8A%A1">1. 配置nfs服务</h3> 
<pre><code class="language-bash">mkdir /opt/k8s
chmod 777 /data/volumes

vim /etc/exports
/data/volumes 192.168.88.0/24(rw,no_root_squash,sync)

exportfs -arv</code></pre> 
<h3 id="2.%E5%88%9B%E5%BB%BA%20Service%20Account">2.创建 Service Account</h3> 
<p><strong>Service Account：用来管理 NFS Provisioner 在 k8s 集群中运行的权限，设置 nfs-client 对 PV，PVC，StorageClass 等的规则</strong></p> 
<pre><code class="language-bash">vim nfs-client-rbac.yaml
#创建 Service Account 账户，用来管理 NFS Provisioner 在 k8s 集群中运行的权限
apiVersion: v1
kind: ServiceAccount
metadata:
  name: nfs-client-provisioner
---
#创建集群角色
apiVersion: rbac.authorization.k8s.io/v1
kind: ClusterRole
metadata:
  name: nfs-client-provisioner-clusterrole
rules:
- apiGroups: [""]
  resources: ["persistentvolumes"]
  verbs: ["get", "list", "watch", "create", "delete"]
- apiGroups: [""]
  resources: ["persistentvolumesclaims"]
  verbs: ["get", "list", "watch", "update"]
- apiGroups: ["storage.k8s.io"]
  resources: ["storageclasses"]
  verbs: ["get", "list", "watch"]
- apiGroups: [""]
  resources: ["events"]
 verbs: ["list", "watch", "create", "update", "patch"]
- apiGroups: [""]
  resources: ["endpoints"]
  verbs: ["create", "delete", "get", "list", "watch", "patch", "update"]
---
#集群角色绑定
apiVersion: rbac.authorization.k8s.io/v1
kind: ClusterRoleBinding
metadata:
  name: nfs-client-provisioner-clusterrolebinding
subjects:
- kind: ServiceAccount
  name: nfs-client-provisioner
  namespace: default
roleRef:
  kind: ClusterRole
  name: nfs-client-provisioner-clusterrole
  apiGroup: rbac.authorization.k8s.io

  verbs: ["list", "watch", "create", "update", "patch"]
- apiGroups: [""]
  resources: ["endpoints"]

kubectl apply -f nfs-client-rbac.yaml
</code></pre> 
<h3 id="3.%E4%BD%BF%E7%94%A8%20Deployment%20%E6%9D%A5%E5%88%9B%E5%BB%BA%20NFS%20Provisioner">3.使用 Deployment 来创建 NFS Provisioner</h3> 
<p>NFS Provisioner(即 nfs-client)，有两个功能：一个是在 NFS 共享目录下创建挂载点(volume)，另一个则是将 PV 与 NFS 的挂载点建立关联。</p> 
<h4 id="3.1%E7%94%B1%E4%BA%8E%201.20%20%E7%89%88%E6%9C%AC%E5%90%AF%E7%94%A8%E4%BA%86%20selfLink%EF%BC%8C%E6%89%80%E4%BB%A5%20k8s%201.20%2B%20%E7%89%88%E6%9C%AC%E9%80%9A%E8%BF%87%20nfs%20provisioner%20%E5%8A%A8%E6%80%81%E7%94%9F%E6%88%90pv%E4%BC%9A%E6%8A%A5%E9%94%99%EF%BC%8C%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95%E5%A6%82%E4%B8%8B">3.1由于 1.20 版本启用了 selfLink，所以 k8s 1.20+ 版本通过 nfs provisioner 动态生成pv会报错，解决方法如下</h4> 
<pre><code class="language-bash">vim /etc/kubernetes/manifests/kube-apiserver.yaml
spec:
  containers:
  - command:
    - kube-apiserver
    - --feature-gates=RemoveSelfLink=false   #添加这行
    - --advertise-address=192.168.88.70

kubectl apply -f /etc/kubernetes/manifests/kube-apiserver.yaml
kubectl delete pods kube-apiserver -n kube-system 
kubectl get pods -n kube-system | grep apiserver</code></pre> 
<h4 id="3.2%E5%88%9B%E5%BB%BA%20NFS%20Provisioner%C2%A0">3.2创建 NFS Provisioner </h4> 
<pre><code class="language-bash">vim nfs-client-provisioner.yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: nfs-client-provisioner
spec:
  replicas: 1
  selector:
    matchLabels:
      app: nfs-client-provisioner
  strategy:
    type: Recreate
  template:
    metadata:
      labels:
        app: nfs-client-provisioner
    spec:
      serviceAccountName: nfs-client-provisioner
      containers:
      - name: nfs-client-provisioner
        image: quay.io/external_storage/nfs-client-provisioner:latest
        imagePullPolicy: IfNotPresent
        volumeMounts:
        - name: nfs-client-root
          mountPath: /persistentvolumes
        env:
        - name: PROVISIONER_NAME
          value: nfs-storage       #配置provisioner的Name，确保该名称与StorageClass资源中的provisioner名称保持一致
        - name: NFS_SERVER
          value: 192.168.88.60     #配置绑定的nfs服务器
        - name: NFS_PATH
          value: /data/volumes     #配置绑定的nfs服务器目录
      volumes:                     #申明nfs数据卷
      - name: nfs-client-root
        nfs:
          server: 192.168.88.60
          path: /data/volumes
    
kubectl apply -f nfs-client-provisioner.yaml     
kubectl get pod                              </code></pre> 
<h3 id="4.%E5%88%9B%E5%BB%BA%20StorageClass">4.创建 StorageClass</h3> 
<p>StorageClass：负责建立 PVC 并调用 NFS provisioner 进行预定的工作，并让 PV 与 PVC 建立关联</p> 
<pre><code class="language-bash">vim nfs-client-storageclass.yaml
apiVersion: storage.k8s.io/v1
kind: StorageClass
metadata:
  name: nfs-client-storageclass
provisioner: nfs-storage      #这里的名称要和provisioner配置文件中的环境变量PROVISIONER_NAME保持一致
parameters:
  archiveOnDelete: "false"     #false表示在删除PVC时不会对数据目录进行打包存档，即删除数据；为ture时就会自动对数据目录进行打包存档，存档文件以archived开头


kubectl apply -f nfs-client-storageclass.yaml
kubectl get storageclass</code></pre> 
<h3 id="5.%E5%88%9B%E5%BB%BA%20PVC%20%E5%92%8C%20Pod%20%E6%B5%8B%E8%AF%95">5.创建 PVC 和 Pod 测试</h3> 
<pre><code class="language-bash">vim test-pvc-pod.yaml
apiVersion: v1
kind: PersistentVolumeClaim
metadata:
  name: test-nfs-pvc
  #annotations: volume.beta.kubernetes.io/storage-class: "nfs-client-storageclass"     #另一种SC配置方式，（annotations也可表示为注释字段）
spec:
  accessModes:
    - ReadWriteMany
  storageClassName: nfs-client-storageclass    #关联StorageClass对象
  resources:
    requests:
      storage: 1Gi
---
apiVersion: v1
kind: Pod
metadata:
  name: test-storageclass-pod
spec:
  containers:
  - name: busybox
    image: busybox:latest
    imagePullPolicy: IfNotPresent
    command:
    - "/bin/sh"
    - "-c"
    args:
    - "sleep 3600"
    volumeMounts:
    - name: nfs-pvc
      mountPath: /mnt
  restartPolicy: Never
  volumes:
  - name: nfs-pvc
    persistentVolumeClaim:
      claimName: test-nfs-pvc      #与PVC名称保持一致

#PVC 通过 StorageClass 自动申请到空间
kubectl get pvc
#查看 NFS 服务器上是否生成对应的目录，自动创建的 PV 会以 ${namespace}-${pvcName}-${pvName} 的目录格式放到 NFS 服务器上
ls /data/volumes

#进入 Pod 在挂载目录 /mnt 下写一个文件，然后查看 NFS 服务器上是否存在该文件
kubectl exec -it test-storageclass-pod sh
/ # cd /mnt/
/mnt # echo 'this is test file' &gt; test.txt

#发现 NFS 服务器上存在，说明验证成功
cat /data/volumes/default-test-nfs-pvc-pvc-bff2245e-990d-4119-a846-06f898f95efb</code></pre> 
<p><img alt="" height="191" src="https://images2.imgbox.com/67/48/xdpLFSDm_o.png" width="1200"></p> 
<p><img alt="" height="198" src="https://images2.imgbox.com/17/1c/A1K5doUy_o.png" width="908"></p> 
<p> </p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/6c754a2f76c4d7cfc3af714547c4e992/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">经典题目和算法</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/578173ea8e98482699ea65e2564c6a54/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">全网小说下载器，只需书名，一键下载（Python爬虫&#43;tkinter 实现）小白实战案例系统教学！</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>