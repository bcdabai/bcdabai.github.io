<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>《现代C&#43;&#43;语言核心特性解析》笔记（一） - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="《现代C&#43;&#43;语言核心特性解析》笔记（一）" />
<meta property="og:description" content="一、新基础类型（C&#43;&#43;11～C&#43;&#43;20） C&#43;&#43;基础类型回顾一览表
1. 整数类型 long long 我们知道long通常表示一个32位整型，而long long则是用来表示一个64位的整型。不得不说，这种命名方式简单粗暴。不仅写法冗余，而且表达的含义也并不清晰。如果按照这个命名规则，那么128位整型就该被命名为long long long了。但是不管怎么样，long long既然已经加入了 C&#43;&#43; 11 的标准，那么我们能做的就是适应它，并且希望不会有long long long这种类型的诞生。
C&#43;&#43;标准中定义，long long是一个至少为64位的整数类型。请注意这里的用词“至少”，也就说 long long 的实际长度可能大于64位。
另外，long long 是一个有符号类型，对应的无符号类型为 unsigned long long，当然读者可能看到过诸如 long long int、unsigned long long int等类型，实际上它们和long long、unsigned long long具有相同的含义。C&#43;&#43;标准还为其定义LL和ULL作为这两种类型的字面量后缀，所以在初始化long long类型变量的时候可以这么写：
long long x = 65536LL; 当然，这里可以忽略LL这个字面量后缀，直接写成下面的形式也可以达到同样的效果：
long long x = 65536; 要强调的是，字面量后缀并不是没有意义的，在某些场合下我们必须用到它才能让代码的逻辑正确，比如下面的代码：
long long x1 = 65536 &lt;&lt; 16; // 计算得到的 x1 值为 0 std::cout &lt;&lt; &#34;x1 = &#34; &lt;&lt; x1 &lt;&lt; std::endl; long long x2 = 65536LL &lt;&lt; 16; // 计算得到的 x2 值为 4294967296（0x100000000） std::cout &lt;&lt; &#34;" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/d96b71501f455c3861c6bf5e2596e315/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-11-06T21:57:42+08:00" />
<meta property="article:modified_time" content="2023-11-06T21:57:42+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">《现代C&#43;&#43;语言核心特性解析》笔记（一）</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-light">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <h2><a id="C11C20_0"></a>一、新基础类型（C++11～C++20）</h2> 
<p>C++基础类型回顾一览表</p> 
<p><img src="https://images2.imgbox.com/4d/4f/FB3v3aKt_o.png" alt="在这里插入图片描述" width="350"></p> 
<h3><a id="1__long_long_6"></a>1. 整数类型 long long</h3> 
<p>我们知道<code>long</code>通常表示一个<code>32</code>位整型，而<code>long long</code>则是用来表示一个<code>64</code>位的整型。不得不说，这种命名方式简单粗暴。不仅写法冗余，而且表达的含义也并不清晰。如果按照这个命名规则，那么<code>128</code>位整型就该被命名为<code>long long long</code>了。但是不管怎么样，<code>long long</code>既然已经加入了 C++ 11 的标准，那么我们能做的就是适应它，并且希望不会有<code>long long long</code>这种类型的诞生。</p> 
<p>C++标准中定义，<code>long long</code>是一个<strong>至少为<code>64</code>位</strong>的整数类型。请注意这里的用词“<strong>至少</strong>”，也就说 <code>long long</code> 的实际长度<strong>可能大于<code>64</code>位</strong>。</p> 
<p>另外，<code>long long</code> 是一个有符号类型，对应的无符号类型为 <code>unsigned long long</code>，当然读者可能看到过诸如 <code>long long int</code>、<code>unsigned long long int</code>等类型，实际上它们和<code>long long</code>、<code>unsigned long long</code>具有相同的含义。C++标准还为其定义<code>LL</code>和<code>ULL</code>作为这两种类型的字面量后缀，所以在初始化<code>long long</code>类型变量的时候可以这么写：</p> 
<pre><code class="prism language-c"><span class="token keyword">long</span> <span class="token keyword">long</span> x <span class="token operator">=</span> <span class="token number">65536LL</span><span class="token punctuation">;</span>
</code></pre> 
<p>当然，这里可以忽略<code>LL</code>这个字面量后缀，直接写成下面的形式也可以达到同样的效果：</p> 
<pre><code class="prism language-c"><span class="token keyword">long</span> <span class="token keyword">long</span> x <span class="token operator">=</span> <span class="token number">65536</span><span class="token punctuation">;</span>
</code></pre> 
<p>要强调的是，字面量后缀并不是没有意义的，在某些场合下我们必须用到它才能让代码的逻辑正确，比如下面的代码：</p> 
<pre><code class="prism language-c"><span class="token keyword">long</span> <span class="token keyword">long</span> x1 <span class="token operator">=</span> <span class="token number">65536</span> <span class="token operator">&lt;&lt;</span> <span class="token number">16</span><span class="token punctuation">;</span> <span class="token comment">// 计算得到的 x1 值为 0</span>
std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"x1 = "</span> <span class="token operator">&lt;&lt;</span> x1 <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>endl<span class="token punctuation">;</span>
<span class="token keyword">long</span> <span class="token keyword">long</span> x2 <span class="token operator">=</span> <span class="token number">65536LL</span> <span class="token operator">&lt;&lt;</span> <span class="token number">16</span><span class="token punctuation">;</span> <span class="token comment">// 计算得到的 x2 值为 4294967296（0x100000000）</span>
std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"x2 = "</span> <span class="token operator">&lt;&lt;</span> x2 <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>endl<span class="token punctuation">;</span>
</code></pre> 
<p>以上代码的目的是将<code>65536</code>左移<code>16</code>位，以获得一个更大的数值。但是，<code>x1</code>计算出来的值却是<code>0</code>，没有增大反而减小了。原因是在没有字面量后缀的情况下，这里的<code>65536</code>被当作<code>32</code>位整型操作，在左移<code>16</code>位以后，这个<code>32</code>位整型的值变成了<code>0</code>，所以事实是将<code>0</code>赋值给了<code>x1</code>，于是我们看到<code>x1</code>输出的结果为<code>0</code>。而在计算<code>x2</code>的过程中，代码给<code>65536</code>添加了字面量后缀<code>LL</code>，这使编译器将其编译为一个<code>64</code>位整型，左移<code>16</code>位后仍然可以获得正确的结果：<code>4294967296</code>（<code>0x100000000</code>）。另外，有些编译器可能在编译<code>long long x1 = 65536 &lt;&lt; 16;</code>的时候显示一些警告提示，而另一些编译器可能没有，无论如何我们必须在编写代码的时候足够小心，避免上面情况的发生。</p> 
<p>和其他整型一样，<code>long long</code>也能运用于枚举类型和位域，例如：</p> 
<pre><code class="prism language-cpp"><span class="token keyword">enum</span> <span class="token class-name">longlong_enum</span> <span class="token operator">:</span> <span class="token keyword">long</span> <span class="token keyword">long</span> <span class="token punctuation">{<!-- --></span>
	x1<span class="token punctuation">,</span>
	x2
<span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">struct</span> <span class="token class-name">longlong_struct</span> <span class="token punctuation">{<!-- --></span>
	<span class="token keyword">long</span> <span class="token keyword">long</span> x1 <span class="token operator">:</span> <span class="token number">8</span><span class="token punctuation">;</span>
	<span class="token keyword">long</span> <span class="token keyword">long</span> x2 <span class="token operator">:</span> <span class="token number">24</span><span class="token punctuation">;</span>
	<span class="token keyword">long</span> <span class="token keyword">long</span> x3 <span class="token operator">:</span> <span class="token number">32</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>longlong_enum<span class="token double-colon punctuation">::</span>x1<span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span> <span class="token comment">// 输出大小为8</span>
std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>longlong_struct<span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span> <span class="token comment">// 输出大小为8</span>
</code></pre> 
<p>作为一个新的整型<code>long long</code>，C++标准必须为它配套地加入整型的大小限制。在头文件中增加了以下宏，分别代表<code>long long</code>的最大值和最小值以及<code>unsigned long long</code>的最大值：</p> 
<pre><code class="prism language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">LLONG_MAX</span> <span class="token expression"><span class="token number">9223372036854775807LL</span>         </span><span class="token comment">// long long的最大值</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">LLONG_MIN</span> <span class="token expression"><span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">9223372036854775807LL</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span>  </span><span class="token comment">// long long的最小值</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">ULLONG_MAX</span> <span class="token expression"><span class="token number">0xffffffffffffffffULL</span>        </span><span class="token comment">// unsigned long long的最大值</span></span>
</code></pre> 
<p>在C++中应该尽量少使用宏，用模板取而代之是明智的选择。</p> 
<p>C++标准中对标准库头文件做了扩展，特化了<code>long long</code>和<code>unsigned long long</code>版本的<code>numeric_ limits</code>类模板。这使我们能够更便捷地获取这些类型的最大值和最小值，如下面的代码示例：</p> 
<pre><code class="prism language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;limits&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;cstdio&gt;</span></span>
<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">int</span> argc<span class="token punctuation">,</span> <span class="token keyword">char</span> <span class="token operator">*</span>argv<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token comment">// 使用宏方法</span>
	std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"LLONG_MAX = "</span> <span class="token operator">&lt;&lt;</span> LLONG_MAX <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span>
	std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"LLONG_MIN = "</span> <span class="token operator">&lt;&lt;</span> LLONG_MIN <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span>
	std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"ULLONG_MAX = "</span> <span class="token operator">&lt;&lt;</span> ULLONG_MAX <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span>
	<span class="token comment">// 使用类模板方法</span>
	std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"std::numeric_limits&lt;long long&gt;::max() = "</span>
	<span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span><span class="token class-name">numeric_limits</span><span class="token operator">&lt;</span><span class="token keyword">long</span> <span class="token keyword">long</span><span class="token operator">&gt;</span><span class="token double-colon punctuation">::</span><span class="token function">max</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span>
	std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"std::numeric_limits&lt;long long&gt;::min() = "</span>
	<span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span><span class="token class-name">numeric_limits</span><span class="token operator">&lt;</span><span class="token keyword">long</span> <span class="token keyword">long</span><span class="token operator">&gt;</span><span class="token double-colon punctuation">::</span><span class="token function">min</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span>
	std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"std::numeric_limits&lt;unsigned long long&gt;::max() = "</span>
	<span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span><span class="token class-name">numeric_limits</span><span class="token operator">&lt;</span><span class="token keyword">unsigned</span> <span class="token keyword">long</span> <span class="token keyword">long</span><span class="token operator">&gt;</span><span class="token double-colon punctuation">::</span><span class="token function">max</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span>
	std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span>
	<span class="token comment">// 使用printf打印输出</span>
	std<span class="token double-colon punctuation">::</span><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"LLONG_MAX = %lld\n"</span><span class="token punctuation">,</span> LLONG_MAX<span class="token punctuation">)</span><span class="token punctuation">;</span>
	std<span class="token double-colon punctuation">::</span><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"LLONG_MIN = %lld\n"</span><span class="token punctuation">,</span> LLONG_MIN<span class="token punctuation">)</span><span class="token punctuation">;</span>
	std<span class="token double-colon punctuation">::</span><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"ULLONG_MAX = %llu\n"</span><span class="token punctuation">,</span> ULLONG_MAX<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>输出结果如下：</p> 
<pre><code class="prism language-cpp">LLONG_MAX <span class="token operator">=</span> <span class="token number">9223372036854775807</span>
LLONG_MIN <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">9223372036854775808</span>
ULLONG_MAX <span class="token operator">=</span> <span class="token number">18446744073709551615</span>
std<span class="token double-colon punctuation">::</span><span class="token class-name">numeric_limits</span><span class="token operator">&lt;</span><span class="token keyword">long</span> <span class="token keyword">long</span><span class="token operator">&gt;</span><span class="token double-colon punctuation">::</span><span class="token function">max</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token number">9223372036854775807</span>
std<span class="token double-colon punctuation">::</span><span class="token class-name">numeric_limits</span><span class="token operator">&lt;</span><span class="token keyword">long</span> <span class="token keyword">long</span><span class="token operator">&gt;</span><span class="token double-colon punctuation">::</span><span class="token function">min</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">9223372036854775808</span>
std<span class="token double-colon punctuation">::</span><span class="token class-name">numeric_limits</span><span class="token operator">&lt;</span><span class="token keyword">unsigned</span> <span class="token keyword">long</span> <span class="token keyword">long</span><span class="token operator">&gt;</span><span class="token double-colon punctuation">::</span><span class="token function">max</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token number">18446744073709551615</span>
LLONG_MAX <span class="token operator">=</span> <span class="token number">9223372036854775807</span>
LLONG_MIN <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">9223372036854775808</span>
ULLONG_MAX <span class="token operator">=</span> <span class="token number">18446744073709551615</span>
</code></pre> 
<p>随着整型<code>long long</code>的加入，<code>std::printf</code>也加入了对其格式化打印的能力。新增的长度指示符<code>ll</code>可以用来指明变量是一个<code>long long</code>类型，所以我们分别使用<code>%lld</code>和<code>%llu</code>来格式化有符号和无符号的<code>long long</code>整型了。当然，使用C++标准的流输入/输出是一个更好的选择。</p> 
<h3><a id="2__char16_t__char32_t_100"></a>2. 新字符类型 char16_t 和 char32_t</h3> 
<p>在C++11标准中添加两种新的字符类型<code>char16_t</code>和<code>char32_t</code>，它们分别用来对应<code>Unicode</code>字符集的<code>UTF-16</code>和<code>UTF-32</code>两种编码方法。在正式介绍它们之前，需要先弄清楚字符集和编码方法的区别。</p> 
<h4><a id="_104"></a>字符集和编码方法</h4> 
<p>通常我们所说的字符集是指系统支持的所有抽象字符的集合，通常一个字符集的字符是稳定的。而编码方法是利用数字和字符集建立对应关系的一套方法，这个方法可以有很多种，比如<code>Unicode</code>字符集就有<code>UTF-8</code>、<code>UTF-16</code>和<code>UTF-32</code>这<code>3</code>种编码方法。除了<code>Unicode</code>字符集，我们常见的字符集还包括<code>ASCII</code>字符集、<code>GB2312</code>字符集、<code>BIG5</code>字符集等，它们都有各自的编码方法。字符集需要和编码方式对应，如果这个对应关系发生了错乱，那么我们就会看到计算机世界中令人深恶痛绝的乱码。</p> 
<p>不过，现在的计算机世界逐渐达成了一致，就是尽量以 <strong><code>Unicode</code></strong> 作为字符集标准，那么剩下的工作就是处理 <code>UTF-8</code>、<code>UTF-16</code> 和 <code>UTF-32</code> 这 <code>3</code> 种编码方法的问题了。</p> 
<p><code>UTF-8</code>、<code>UTF-16</code> 和 <code>UTF-32</code> 简单来说是使用不同大小内存空间的编码方法。</p> 
<p><code>UTF-32</code> 是最简单的编码方法，该方法用一个<code>32</code>位的内存空间（也就是<code>4</code>字节）存储一个字符编码，由于<code>Unicode</code>字符集的最大个数为 <code>0x10FFFF</code>（<code>ISO 10646</code>），因此<code>4</code>字节的空间完全能够容纳任何一个字符编码。<code>UTF-32</code> 编码方法的优点显而易见，它非常简单，计算字符串长度和查找字符都很方便；缺点也很明显，太占用内存空间。</p> 
<p><code>UTF-16</code> 编码方法所需的内存空间从 <code>32</code> 位缩小到 <code>16</code> 位（占用 <code>2</code> 字节），但是由于存储空间的缩小，因此 <code>UTF-16</code> 最多只能支持 <code>0xFFFF</code> 个字符，这显然不太够用，于是 <code>UTF-16</code> 采用了一种特殊的方法来表达无法表示的字符。简单来说，从 <code>0x0000 ~ 0xD7FF</code> 以及 <code>0xE000 ~ 0xFFFF</code> 直接映射到 <code>Unicode</code> 字符集，而剩下的 <code>0xD800 ~ 0xDFFF</code> 则用于映射 <code>0x10000 ~ 0x10FFFF</code> 的 <code>Unicode</code> 字符集，映射方法为：字符编码减去 <code>0x10000</code> 后剩下的 <code>20</code> 比特位分为高位和低位，高 <code>10</code> 位的映射范围为 <code>0xD800 ~ 0xDBFF</code>，低 <code>10</code> 位的映射范围为 <code>0xDC00 ~ 0xDFFF</code>。例如 <code>0x10437</code>，减去 <code>0x10000</code> 后的高低位分别为 <code>0x1</code> 和 <code>0x37</code>，分别加上 <code>0xD800</code> 和 <code>0xDC00</code> 的结果是 <code>0xD801</code> 和 <code>0xDC37</code>。</p> 
<p>幸运的是，一般情况下 <code>0xFFFF</code> 足以覆盖日常字符需求，我们也不必为了 <code>UTF-16</code> 的特殊编码方法而烦恼。 <code>UTF-16</code> 编码的优势是可以用固定长度的编码表达常用的字符，所以计算字符长度和查找字符也比较方便。另外，在内存空间使用上也比 <code>UTF-32</code> 好得多。</p> 
<p>最后说一下我们最常用的 <code>UTF-8</code> 编码方法，它是一种可变长度的编码方法。由于 <code>UTF-8</code> 编码方法只占用 <code>8</code> 比特位（<code>1</code> 字节），因此要表达完数量高达 <code>0x10FFFF</code> 的字符集，它采用了一种前缀编码的方法。这个方法可以用 <code>1 ~ 4</code> 字节表示字符个数为 <code>0x10FFFF</code> 的 <code>Unicode</code>（<code>ISO 10646</code>）字符集。为了尽量节约空间，常用的字符通常用 <code>1 ~ 2</code> 字节就能表达，其他的字符才会用到 <code>3 ~ 4</code> 字节，所以在内存空间可以使用 <code>UTF-8</code>，但是计算字符串长度和查找字符在 <code>UTF-8</code> 中却是一个令人头痛的问题。表1-1展示了 <code>UTF-8</code> 对应的范围。</p> 
<p><img src="https://images2.imgbox.com/ca/e3/yOmz2rR1_o.png" alt="在这里插入图片描述" width="650"></p> 
<h4><a id="_char16_t__char32_t_128"></a>使用新字符类型 char16_t 和 char32_t</h4> 
<p>对于 <code>UTF-8</code> 编码方法而言，普通类型似乎是无法满足需求的，毕竟普通类型无法表达变长的内存空间。所以一般情况下我们直接使用基本类型 <code>char</code> 进行处理，而过去也没有一个针对 <code>UTF-16</code> 和 <code>UTF-32</code> 的字符类型。到了 <code>C++11</code>，<code>char16_t</code> 和 <code>char32_t</code> 的出现打破了这个尴尬的局面。除此之外， <code>C++11</code> 标准还为<code>3</code>种编码提供了新前缀用于声明<code>3</code>种编码字符和字符串的字面量，它们分别是 <code>UTF-8</code> 的前缀 <code>u8</code>、 <code>UTF-16</code> 的前缀 <code>u</code> 和 <code>UTF-32</code> 的前缀 <code>U</code>：</p> 
<pre><code class="prism language-cpp"><span class="token keyword">char</span> utf8c <span class="token operator">=</span> u8<span class="token char">'a'</span><span class="token punctuation">;</span> <span class="token comment">// C++17标准</span>
<span class="token comment">//char utf8c = u8'好';</span>
<span class="token keyword">char16_t</span> utf16c <span class="token operator">=</span> u<span class="token char">'好'</span><span class="token punctuation">;</span>
<span class="token keyword">char32_t</span> utf32c <span class="token operator">=</span> U<span class="token char">'好'</span><span class="token punctuation">;</span>
<span class="token keyword">char</span> utf8<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> u8<span class="token string">"你好世界"</span><span class="token punctuation">;</span>
<span class="token keyword">char16_t</span> utf16<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> u<span class="token string">"你好世界"</span><span class="token punctuation">;</span>
<span class="token keyword">char32_t</span> utf32<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> U<span class="token string">"你好世界"</span><span class="token punctuation">;</span>
</code></pre> 
<p>在上面的代码中，分别使用<code>UTF-8</code>、<code>UTF-16</code>和<code>UTF-32</code>编码的字符和字符串对变量进行了初始化，代码很简单，不过还是有两个地方值得一提。</p> 
<ul><li> <p><code>char utf8c = u8'a'</code>在 C++11 标准中实际上是无法编译成功的，因为在 C++11 标准中<code>u8</code>只能作为字符串字面量的前缀，而无法作为字符的前缀。这个问题直到 C++17 标准才得以解决，所以上述代码需要 C++17 的环境来执行编译。</p> </li><li> <p><code>char utf8c = u8'好'</code>是无法通过编译的，因为存储“<code>好</code>”需要<code>3</code>字节，显然<code>utf8c</code>只能存储<code>1</code>字节，所以会编译失败。</p> </li></ul> 
<h4><a id="wchar_t__149"></a>wchar_t 存在的问题</h4> 
<p>在 C++98 的标准中提供了一个<code>wchar_t</code>字符类型，并且还提供了前缀<code>L</code>，用它表示一个宽字符。事实上 Windows 系统的 API 使用的就是<code>wchar_t</code>，它在 Windows 内核中是一个最基础的字符类型：</p> 
<pre><code class="prism language-cpp">HANDLE <span class="token function">CreateFileW</span><span class="token punctuation">(</span>
	LPCWSTR lpFileName<span class="token punctuation">,</span>
	…
<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">CreateFileW</span><span class="token punctuation">(</span>L<span class="token string">"c:\\tmp.txt"</span><span class="token punctuation">,</span> …<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> 
<p>上面是一段在Windows系统上创建文件的伪代码，可以看出Windows为创建文件的API提供了宽字符版本，其中<code>LPCWSTR</code>实际上是<code>const wchar_t</code>的指针类型，我们可以通过<code>L</code>前缀来定义一个<code>wchar_t</code>类型的字符串字面量，并且将其作为实参传入API。</p> 
<p>讨论到这里读者会产生一个疑问，既然已经有了处理宽字符的字符类型，那么为什么又要加入新的字符类型呢？没错，<code>wchar_t</code>确实在一定程度上能够满足我们对于字符表达的需求，但是起初在定义<code>wchar_t</code>时并没有规定其占用内存的大小。于是就给了实现者充分的自由，以至于在Windows上<code>wchar_t</code>是一个<code>16</code>位长度的类型（<code>2</code>字节），而在 Linux 和 macOS 上<code>wchar_t</code>却是<code>32</code>位的（<code>4</code>字节）。这导致了一个严重的后果，我们写出的代码无法在不同平台上保持相同行为。而<code>char16_t</code>和<code>char32_t</code>的出现解决了这个问题，它们明确规定了其所占内存空间的大小，让代码在任何平台上都能够有一致的表现。</p> 
<h4><a id="_164"></a>新字符串连接</h4> 
<p>由于字符类型增多，因此我们还需要了解一下字符串连接的规则：</p> 
<ul><li>如果两个字符串字面量具有相同的前缀，则生成的连接字符串字面量也具有该前缀，如表1-2所示。</li><li>如果其中一个字符串字面量没有前缀，则将其视为与另一个字符串字面量具有相同前缀的字符串字面量，</li><li>其他的连接行为由具体实现者定义。另外，这里的连接操作是编译时的行为，而不是一个转换。</li></ul> 
<p><img src="https://images2.imgbox.com/f7/ba/DADW7t0w_o.png" alt="在这里插入图片描述" width="650"></p> 
<p>需要注意的是，进行连接的字符依然是保持独立的，也就是说不会因为字符串连接，将两个字符合并为一个，例如连接"<code>\xA</code>" “<code>B</code>"的结果应该是”<code>\nB</code>"（换行符和字符<code>B</code>），而不是一个字符"<code>\xAB</code>"。</p> 
<h4><a id="_175"></a>库对新字符类型的支持</h4> 
<p>随着新字符类型加入C++11标准，相应的库函数也加入进来。C11在中增加了4个字符的转换函数，包括：</p> 
<pre><code class="prism language-cpp">size_t <span class="token function">mbrtoc16</span><span class="token punctuation">(</span> <span class="token keyword">char16_t</span><span class="token operator">*</span> pc16<span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">char</span><span class="token operator">*</span> s<span class="token punctuation">,</span> size_t n<span class="token punctuation">,</span> mbstate_t<span class="token operator">*</span> ps <span class="token punctuation">)</span><span class="token punctuation">;</span>
size_t <span class="token function">c16rtomb</span><span class="token punctuation">(</span> <span class="token keyword">char</span><span class="token operator">*</span> s<span class="token punctuation">,</span> <span class="token keyword">char16_t</span> c16<span class="token punctuation">,</span> mbstate_t<span class="token operator">*</span> ps <span class="token punctuation">)</span><span class="token punctuation">;</span>
size_t <span class="token function">mbrtoc32</span><span class="token punctuation">(</span> <span class="token keyword">char32_t</span><span class="token operator">*</span> pc32<span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">char</span><span class="token operator">*</span> s<span class="token punctuation">,</span> size_t n<span class="token punctuation">,</span> mbstate_t<span class="token operator">*</span> ps <span class="token punctuation">)</span><span class="token punctuation">;</span>
size_t <span class="token function">c32rtomb</span><span class="token punctuation">(</span> <span class="token keyword">char</span><span class="token operator">*</span> s<span class="token punctuation">,</span> <span class="token keyword">char32_t</span> c32<span class="token punctuation">,</span> mbstate_t<span class="token operator">*</span> ps <span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> 
<p>它们的功能分别是多字节字符和 <code>UTF-16</code> 编码字符互转，以及多字节字符和 <code>UTF-32</code> 编码字符互转。在 C++11 中，我们可以通过包含 <code>&lt;cuchar&gt;</code> 来使用这 <code>4</code> 个函数。当然 <code>C++11</code> 中也添加了 C++ 风格的转发方法 <code>std::wstring_convert</code> 以及 <code>std::codecvt</code>。使用类模板 <code>std::wstring_convert</code> 和 <code>std::codecvt</code> 相结合，可以对多字节字符串和宽字符串进行转换。（不过它们在 <code>C++17</code> 标准中已经不被推荐使用了，所以应该尽量避免使用它们）</p> 
<p>除此之外，C++标准库的字符串也加入了对新字符类型的支持，例如：</p> 
<pre><code class="prism language-cpp"><span class="token keyword">using</span> u16string <span class="token operator">=</span> basic_string<span class="token punctuation">;</span>
<span class="token keyword">using</span> u32string <span class="token operator">=</span> basic_string<span class="token punctuation">;</span>
<span class="token keyword">using</span> wstring <span class="token operator">=</span> basic_string<span class="token punctuation">;</span>
</code></pre> 
<h3><a id="3_char8_t__197"></a>3. char8_t 字符类型</h3> 
<p>使用<code>char</code>类型来处理<code>UTF-8</code>字符虽然可行，但是也会带来一些困扰，比如当库函数需要同时处理多种字符时必须采用不同的函数名称以区分普通字符和<code>UTF-8</code>字符。C++20 标准新引入的类型<code>char8_t</code>可以解决以上问题，它可以代替<code>char</code>作为<code>UTF-8</code>的字符类型。<code>char8_t</code>具有和<code>unsigned char</code>相同的符号属性、存储大小、对齐方式以及整数转换等级。引入<code>char8_t</code>类型后，在 C++17 环境下可以编译的<code>UTF-8</code>字符相关的代码会出现问题，例如：</p> 
<pre><code class="prism language-cpp"><span class="token keyword">char</span> str<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> u8<span class="token string">"text"</span><span class="token punctuation">;</span> <span class="token comment">// C++17编译成功；C++20编译失败，需要char8_t</span>
<span class="token keyword">char</span> c <span class="token operator">=</span> u8<span class="token char">'c'</span><span class="token punctuation">;</span>
</code></pre> 
<p>当然反过来也不行：</p> 
<pre><code class="prism language-cpp"><span class="token keyword">char8_t</span> c8a<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">"text"</span><span class="token punctuation">;</span> <span class="token comment">// C++20编译失败，需要char</span>
<span class="token keyword">char8_t</span> c8 <span class="token operator">=</span> <span class="token char">'c'</span><span class="token punctuation">;</span>
</code></pre> 
<p>另外，为了匹配新的<code>char8_t</code>字符类型，库函数也有相应的增加：</p> 
<pre><code class="prism language-cpp">size_t <span class="token function">mbrtoc8</span><span class="token punctuation">(</span><span class="token keyword">char8_t</span><span class="token operator">*</span> pc8<span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">char</span><span class="token operator">*</span> s<span class="token punctuation">,</span> size_t n<span class="token punctuation">,</span> mbstate_t<span class="token operator">*</span> ps<span class="token punctuation">)</span><span class="token punctuation">;</span>
size_t <span class="token function">c8rtomb</span><span class="token punctuation">(</span><span class="token keyword">char</span><span class="token operator">*</span> s<span class="token punctuation">,</span> <span class="token keyword">char8_t</span> c8<span class="token punctuation">,</span> mbstate_t<span class="token operator">*</span> ps<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">using</span> u8string <span class="token operator">=</span> basic_string<span class="token punctuation">;</span>
</code></pre> 
<p>最后需要说明的是，上面这些例子只是C++标准库为新字符类型新增代码的冰山一角，有兴趣的读者可以翻阅标准库代码，包括<code>&lt;atomic&gt;、&lt;filesystem&gt;、&lt;istream&gt;、&lt;limits&gt;、&lt;locale&gt;、&lt;ostream&gt;</code>以及<code>&lt;string_ view&gt;</code>等头文件，这里就不一一介绍了。</p> 
<h3><a id="_221"></a>总结</h3> 
<p>本章从 <code>C++</code> 最基础的新特性入手，介绍了整型 <code>long long</code> 以及 <code>char8_t</code>、<code>char16_t</code> 和 <code>char32_t</code> 字符类型。虽说这些新的基础类型非常简单，但是磨刀不误砍柴工，掌握新基础类型（尤其是 <code>3</code> 种不同的 <code>Unicode</code> 字符类型）会让我们在使用 <code>C++</code> 处理字符、字符串以及文本方面更加游刃有余。比如，当你正在为处理文本文件中 <code>UTF-32</code> 编码的字符而头痛时，采用新标准中 <code>char32_t</code> 和 <code>u32string</code> 也许会让问题迎刃而解。</p> 
<h2><a id="C11C20_225"></a>二、内联和嵌套命名空间（C++11～C++20）</h2> 
<h3><a id="1__227"></a>1. 内联命名空间的定义和使用</h3> 
<p>开发一个大型工程必然会有很多开发人员的参与，也会引入很多第三方库，这导致程序中偶尔会碰到同名函数和类型，造成编译冲突的问题。为了缓解该问题对开发的影响，我们需要合理使用命名空间。程序员可以将函数和类型纳入命名空间中，这样在不同命名空间的函数和类型就不会产生冲突，当要使用它们的时候只需打开其指定的命名空间即可，例如：</p> 
<pre><code class="prism language-cpp"><span class="token keyword">namespace</span> S1 <span class="token punctuation">{<!-- --></span>
	<span class="token keyword">void</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span><span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token keyword">namespace</span> S2 <span class="token punctuation">{<!-- --></span>
	<span class="token keyword">void</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span><span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token keyword">using</span> <span class="token keyword">namespace</span> S1<span class="token punctuation">;</span>
<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token class-name">S2</span><span class="token double-colon punctuation">::</span><span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>以上是命名空间的一个典型例子，例子中命名空间 <code>S1</code> 和 <code>S2</code> 都有相同的函数 <code>foo</code>，在调用两个函数时，由于命名空间 <code>S1</code> 被 <strong><code>using</code></strong> 关键字打开，因此 <code>S1</code> 的 <code>foo</code> 函数可以直接使用，而 <code>S2</code> 的 <code>foo</code> 函数需要使用 <strong><code>::</code></strong> 来指定函数的命名空间。</p> 
<p>C++11 标准增强了命名空间的特性，提出了内联命名空间的概念。内联命名空间能够把空间内函数和类型导出到父命名空间中，这样即使不指定子命名空间也可以使用其空间内的函数和类型了，比如：</p> 
<pre><code class="prism language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream&gt;</span></span>

<span class="token keyword">namespace</span> Parent <span class="token punctuation">{<!-- --></span>
	<span class="token keyword">namespace</span> Child1
	<span class="token punctuation">{<!-- --></span>
		<span class="token keyword">void</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span> std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"Child1::foo()"</span> <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span> <span class="token punctuation">}</span>
	<span class="token punctuation">}</span>
	
	<span class="token keyword">inline</span> <span class="token keyword">namespace</span> Child2
	<span class="token punctuation">{<!-- --></span>
		<span class="token keyword">void</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span> std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"Child2::foo()"</span> <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span> <span class="token punctuation">}</span>
	<span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	Parent<span class="token double-colon punctuation">::</span><span class="token class-name">Child1</span><span class="token double-colon punctuation">::</span><span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token class-name">Parent</span><span class="token double-colon punctuation">::</span><span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>在上面的代码中，<code>Child1</code> 不是一个<strong>内联</strong>命名空间，所以调用 <code>Child1</code> 的 <code>foo</code> 函数需要明确指定所属命名空间。而调用 <code>Child2</code> 的 <code>foo</code> 函数则方便了许多，直接指定<strong>父命名空间</strong>即可。现在问题来了，这个新特性的用途是什么呢？这里删除内联命名空间，将 <code>foo</code> 函数直接纳入 <code>Parent</code> 命名空间也能达到同样的效果。</p> 
<p>实际上，该特性可以帮助库作者无缝升级库代码，让客户不用修改任何代码也能够自由选择新老库代码。举个例子：</p> 
<pre><code class="prism language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream&gt;</span></span>
<span class="token keyword">namespace</span> Parent <span class="token punctuation">{<!-- --></span>
	<span class="token keyword">void</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span> std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"foo v1.0"</span> <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span> <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token class-name">Parent</span><span class="token double-colon punctuation">::</span><span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>假设现在<code>Parent</code>代码库提供了一个接口<code>foo</code>来完成一些工作，突然某天由于加入了新特性，需要升级接口。有些用户喜欢新的特性但并不愿意为了新接口去修改他们的代码；还有部分用户认为新接口影响了稳定性，所以希望沿用老的接口。这里最直接的办法是提供两个不同的接口函数来对应不同的版本。但是如果库中函数很多，则会出现大量需要修改的地方。另一个方案就是使用内联命名空间，将不同版本的接口归纳到不同的命名空间中，然后给它们一个容易辨识的空间名称，最后将当前最新版本的接口以内联的方式导出到父命名空间中，比如：</p> 
<pre><code class="prism language-cpp"><span class="token keyword">namespace</span> Parent <span class="token punctuation">{<!-- --></span>
    <span class="token keyword">namespace</span> V1 <span class="token punctuation">{<!-- --></span>
		<span class="token keyword">void</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span> std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"foo v1.0"</span> <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span> <span class="token punctuation">}</span>
	<span class="token punctuation">}</span>

	<span class="token keyword">inline</span> <span class="token keyword">namespace</span> V2 <span class="token punctuation">{<!-- --></span>
		<span class="token keyword">void</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span> std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"foo v2.0"</span> <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span> <span class="token punctuation">}</span>
	<span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token class-name">Parent</span><span class="token double-colon punctuation">::</span><span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>从上面的代码可以看出，虽然 <code>foo</code> 函数从 <code>V1</code> 升级到了 <code>V2</code>，但是客户的代码并不需要任何修改。如果用户还想使用 <code>V1</code> 版本的函数，则只需要统一添加函数版本的命名空间，比如 <code>Parent::V1::foo()</code>。使用这种方式管理接口版本非常清晰，如果想加入 <code>V3</code> 版本的接口，则只需要创建 <code>V3</code> 的内联命名空间，并且将命名空间 <code>V2</code> 的 <code>inline</code> 关键字删除。请注意，示例代码中只能有一个内联命名空间，否则编译时会造成二义性问题，编译器不知道使用哪个内联命名空间的 <code>foo</code> 函数。</p> 
<h3><a id="2__307"></a>2. 嵌套命名空间的简化语法</h3> 
<p>有时候打开一个嵌套命名空间可能只是为了向前声明某个类或者函数，但是却需要编写冗长的嵌套代码，加入一些无谓的缩进，这很难让人接受。幸运的是，C++17标准允许使用一种更简洁的形式描述嵌套命名空间，例如：</p> 
<pre><code class="prism language-cpp"><span class="token keyword">namespace</span> A<span class="token double-colon punctuation">::</span>B<span class="token double-colon punctuation">::</span>C <span class="token punctuation">{<!-- --></span>
	<span class="token keyword">int</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span> <span class="token keyword">return</span> <span class="token number">5</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>以上代码等同于：</p> 
<pre><code class="prism language-cpp"><span class="token keyword">namespace</span> A <span class="token punctuation">{<!-- --></span>
	<span class="token keyword">namespace</span> B <span class="token punctuation">{<!-- --></span>
		<span class="token keyword">namespace</span> C <span class="token punctuation">{<!-- --></span>
			<span class="token keyword">int</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span> <span class="token keyword">return</span> <span class="token number">5</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>
		<span class="token punctuation">}</span>
	<span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>很显然前者是一种更简洁的定义嵌套命名空间的方法。除简洁之外，它也更加符合我们已有的语法习惯，比如嵌套类：</p> 
<pre><code class="prism language-cpp">std<span class="token double-colon punctuation">::</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span><span class="token double-colon punctuation">::</span>iterator it<span class="token punctuation">;</span>
</code></pre> 
<p>实际上这份语法规则的提案早在2003年的时候就已经提出，只不过到C++17才被正式引入标准。另外有些遗憾的是，在<strong>C++17</strong>标准中没有办法简洁地定义<strong>内联命名空间</strong>，这个问题直到<strong>C++20</strong>标准才得以解决。在<strong>C++20</strong>中，我们可以这样定义<strong>内联命名空间</strong>：</p> 
<pre><code class="prism language-cpp"><span class="token keyword">namespace</span> A<span class="token double-colon punctuation">::</span>B<span class="token double-colon punctuation">::</span><span class="token keyword">inline</span> C <span class="token punctuation">{<!-- --></span>
    <span class="token keyword">int</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span> <span class="token keyword">return</span> <span class="token number">5</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token comment">// 或者</span>
<span class="token keyword">namespace</span> A<span class="token double-colon punctuation">::</span><span class="token keyword">inline</span> B<span class="token double-colon punctuation">::</span>C <span class="token punctuation">{<!-- --></span>
    <span class="token keyword">int</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span> <span class="token keyword">return</span> <span class="token number">5</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>它们分别等同于：</p> 
<pre><code class="prism language-cpp"><span class="token keyword">namespace</span> A<span class="token double-colon punctuation">::</span>B <span class="token punctuation">{<!-- --></span> 
    <span class="token keyword">inline</span> <span class="token keyword">namespace</span> C <span class="token punctuation">{<!-- --></span>
        <span class="token keyword">int</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span> <span class="token keyword">return</span> <span class="token number">5</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>
    <span class="token punctuation">}</span> 
<span class="token punctuation">}</span>

<span class="token keyword">namespace</span> A <span class="token punctuation">{<!-- --></span> 
    <span class="token keyword">inline</span> <span class="token keyword">namespace</span> B <span class="token punctuation">{<!-- --></span> 
        <span class="token keyword">namespace</span> C <span class="token punctuation">{<!-- --></span>
            <span class="token keyword">int</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span> <span class="token keyword">return</span> <span class="token number">5</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>
        <span class="token punctuation">}</span> 
    <span class="token punctuation">}</span> 
<span class="token punctuation">}</span>
</code></pre> 
<p>请注意，<code>inline</code>可以出现在除第一个<code>namespace</code>之外的任意<code>namespace</code>之前。</p> 
<h3><a id="_364"></a>总结</h3> 
<p>本章主要介绍内联命名空间，正如上文中介绍的，该特性可以帮助库作者无缝切换代码版本而无须库的使用者参与。另外，使用新的嵌套命名空间语法能够有效消除代码冗余，提高代码的可读性。</p> 
<h2><a id="auto_C11C17_369"></a>三、auto 占位符（C++11～C++17）</h2> 
<h3><a id="1__auto__371"></a>1. 重新定义的 auto 关键字</h3> 
<p>严格来说<code>auto</code>并不是一个新的关键字，因为它从C++98标准开始就已经存在了。当时<code>auto</code>是用来声明自动变量的，简单地说，就是拥有自动生命期的变量，显然这是多余的，现在我们几乎不会使用它。于是C++11标准赋予了<code>auto</code>新的含义：<strong>声明变量时根据初始化表达式自动推断该变量的类型、声明函数时函数返回值的占位符</strong>。例如：</p> 
<pre><code class="prism language-cpp"><span class="token keyword">auto</span> i <span class="token operator">=</span> <span class="token number">5</span><span class="token punctuation">;</span> <span class="token comment">// 推断为 int</span>
<span class="token keyword">auto</span> str <span class="token operator">=</span> <span class="token string">"hello auto"</span><span class="token punctuation">;</span> <span class="token comment">// 推断为 const char*</span>
<span class="token keyword">auto</span> <span class="token function">sum</span><span class="token punctuation">(</span><span class="token keyword">int</span> a1<span class="token punctuation">,</span> <span class="token keyword">int</span> a2<span class="token punctuation">)</span><span class="token operator">-&gt;</span><span class="token keyword">int</span> <span class="token comment">// 返回类型后置，auto 为返回值占位符</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token keyword">return</span> a1<span class="token operator">+</span>a2<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>在上面的代码中，我们不需要为<code>i</code>和<code>str</code>去声明具体的类型，<code>auto</code>要求编译器自动完成变量类型的推导工作。<code>sum</code>函数中的<code>auto</code>是一个返回值占位符，真正的返回值类型是<code>int</code>，<code>sum</code>函数声明采用了函数返回类型后置的方法，该方法主要用于函数模板的返回值推导（见第5章）。注意，<code>auto</code>占位符会让编译器去推导变量类型，如果我们编写的代码让编译器无法进行推导，那么使用<code>auto</code>会导致编译失败，例如：</p> 
<pre><code class="prism language-cpp"><span class="token keyword">auto</span> i<span class="token punctuation">;</span> <span class="token comment">// 编译失败</span>
i <span class="token operator">=</span> <span class="token number">5</span><span class="token punctuation">;</span>
</code></pre> 
<p>很明显，以上代码在声明变量时没有对变量进行初始化，这使编译器无法确认其具体类型要导致编译错误，所以在使用<code>auto</code>占位符声明变量的时候必须初始化变量。进一步来说，有4点需要引起注意。</p> 
<p><strong>（1）当用一个<code>auto</code>关键字声明多个变量的时候，编译器遵从由左往右的推导规则，以最左边的表达式推断<code>auto</code>的具体类型：</strong></p> 
<pre><code class="prism language-cpp"><span class="token keyword">int</span> n <span class="token operator">=</span> <span class="token number">5</span><span class="token punctuation">;</span>
<span class="token keyword">auto</span> <span class="token operator">*</span>pn <span class="token operator">=</span> <span class="token operator">&amp;</span>n<span class="token punctuation">,</span> m <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>
</code></pre> 
<p>在上面的代码中，因为<code>&amp;n</code>类型为<code>int *</code>，所以<code>pn</code>的类型被推导为<code>int *</code>，<code>auto</code>被推导为<code>int</code>，于是<code>m</code>被声明为<code>int</code>类型，可以编译成功。但是如果写成下面的代码，将无法通过编译：</p> 
<pre><code class="prism language-cpp"><span class="token keyword">int</span> n <span class="token operator">=</span> <span class="token number">5</span><span class="token punctuation">;</span>
<span class="token keyword">auto</span> <span class="token operator">*</span>pn <span class="token operator">=</span> <span class="token operator">&amp;</span>n<span class="token punctuation">,</span> m <span class="token operator">=</span> <span class="token number">10.0</span><span class="token punctuation">;</span> <span class="token comment">// 编译失败，声明类型不统一</span>
</code></pre> 
<p>上面两段代码唯一的区别在于赋值<code>m</code>的是浮点数，这和<code>auto</code>推导类型不匹配，所以编译器通常会给予一条<code>“in a declarator-list 'auto' must always deduce to the same type”</code>报错信息。细心的读者可能会注意到，如果将赋值代码替换为<code>int m = 10.0;</code>，则编译器会进行缩窄转换，最终结果可能会在给出一条警告信息后编译成功，而在使用<code>auto</code>声明变量的情况下编译器是直接报错的。</p> 
<p><strong>（2）当使用条件表达式初始化<code>auto</code>声明的变量时，编译器总是使用表达能力更强的类型：</strong></p> 
<pre><code class="prism language-cpp"><span class="token keyword">auto</span> i <span class="token operator">=</span> <span class="token boolean">true</span> <span class="token operator">?</span> <span class="token number">5</span> <span class="token operator">:</span> <span class="token number">8.0</span><span class="token punctuation">;</span> <span class="token comment">// i 的数据类型为 double</span>
</code></pre> 
<p>在上面的代码中，虽然能够确定表达式返回的是<code>int</code>类型，但是<code>i</code>的类型依旧会被推导为表达能力更强的类型<code>double</code>。</p> 
<p><strong>（3）虽然C++11标准已经支持在声明成员变量时初始化，但是<code>auto</code>却无法在这种情况下声明非静态成员变量：</strong></p> 
<pre><code class="prism language-cpp"><span class="token keyword">struct</span> <span class="token class-name">sometype</span> <span class="token punctuation">{<!-- --></span>
	<span class="token keyword">auto</span> i <span class="token operator">=</span> <span class="token number">5</span><span class="token punctuation">;</span> <span class="token comment">// 错误，无法编译通过</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre> 
<p>在C++11中<strong>静态成员变量</strong>是可以用<code>auto</code>声明并且初始化的，不过前提是<code>auto</code>必须使用<code>const</code>限定符：</p> 
<pre><code class="prism language-cpp"><span class="token keyword">struct</span> <span class="token class-name">sometype</span> <span class="token punctuation">{<!-- --></span>
	<span class="token keyword">static</span> <span class="token keyword">const</span> <span class="token keyword">auto</span> i <span class="token operator">=</span> <span class="token number">5</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre> 
<p>遗憾的是，<code>const</code>限定符会导致<code>i</code>常量化，显然这不是我们想要的结果。幸运的是，在C++17标准中，对于静态成员变量，<code>auto</code>可以在没有<code>const</code>的情况下使用，例如：</p> 
<pre><code class="prism language-cpp"><span class="token keyword">struct</span> <span class="token class-name">sometype</span> <span class="token punctuation">{<!-- --></span>
	<span class="token keyword">static</span> <span class="token keyword">inline</span> <span class="token keyword">auto</span> i <span class="token operator">=</span> <span class="token number">5</span><span class="token punctuation">;</span> <span class="token comment">// C++17</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre> 
<p><strong>（4）按照C++20之前的标准，无法在函数形参列表中使用<code>auto</code>声明形参（注意，在C++14中，<code>auto</code>可以为<code>lambda</code>表达式声明形参）：</strong></p> 
<pre><code class="prism language-cpp"><span class="token keyword">void</span> <span class="token function">echo</span><span class="token punctuation">(</span><span class="token keyword">auto</span> str<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>…<span class="token punctuation">}</span> <span class="token comment">// C++20之前编译失败，C++20编译成功</span>
</code></pre> 
<p>另外，<code>auto</code>也可以和<code>new</code>关键字结合。当然，我们通常不会这么用，例如：</p> 
<pre><code class="prism language-cpp"><span class="token keyword">auto</span> i <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">auto</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">auto</span><span class="token operator">*</span> j <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">auto</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> 
<p>这种用法比较有趣，编译器实际上进行了两次推导，第一次是<code>auto(5)</code>，<code>auto</code>被推导为<code>int</code>类型，于是<code>new int</code>的类型为<code>int *</code>，再通过<code>int *</code>推导<code>i</code>和<code>j</code>的类型。我不建议像上面这样使用<code>auto</code>，因为它会破坏代码的可读性。在后面的内容中，我们将讨论应该在什么时候避免使用<code>auto</code>关键字。</p> 
<h3><a id="2__446"></a>2. 推导规则</h3> 
<p><strong>（1）如果<code>auto</code>声明的变量是按值初始化，则推导出的类型会忽略<code>cv</code>限定符</strong>。进一步解释为，<strong>在使用<code>auto</code>声明变量时，既没有使用引用，也没有使用指针，那么编译器在推导的时候会忽略<code>const</code>和<code>volatile</code>限定符</strong>。当然<code>auto</code>本身也支持添加<code>cv</code>限定符：</p> 
<pre><code class="prism language-cpp"><span class="token keyword">const</span> <span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">5</span><span class="token punctuation">;</span>
<span class="token keyword">auto</span> j <span class="token operator">=</span> i<span class="token punctuation">;</span>   <span class="token comment">// auto 推导类型为 int，而非 const int</span>
<span class="token keyword">auto</span> <span class="token operator">&amp;</span>m <span class="token operator">=</span> i<span class="token punctuation">;</span>  <span class="token comment">// auto 推导类型为 const int，m 推导类型为 const int&amp;</span>
<span class="token keyword">auto</span> <span class="token operator">*</span>k <span class="token operator">=</span> <span class="token operator">&amp;</span>i<span class="token punctuation">;</span> <span class="token comment">// auto 推导类型为 const int，k 推导类型为 const int*</span>
<span class="token keyword">const</span> <span class="token keyword">auto</span> n <span class="token operator">=</span> j<span class="token punctuation">;</span> <span class="token comment">// auto 推导类型为 int，n 的类型为 const int</span>
</code></pre> 
<p>根据规则1，在上面的代码中，虽然<code>i</code>是<code>const int</code>类型，但是因为按值初始化会忽略<code>cv</code>限定符，所以<code>j</code>的推导类型是<code>int</code>而不是<code>const int</code>。而<code>m</code>和<code>k</code>分别按<strong>引用</strong>和<strong>指针</strong>初始化，因此其<code>cv</code>属性保留了下来。另外，可以用<code>const</code>结合<code>auto</code>，让<code>n</code>的类型推导为<code>const int</code>。</p> 
<p><strong>（2）使用<code>auto</code>声明变量初始化时，目标对象如果是引用，则引用属性会被忽略：</strong></p> 
<pre><code class="prism language-cpp"><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">5</span><span class="token punctuation">;</span>
<span class="token keyword">int</span> <span class="token operator">&amp;</span>j <span class="token operator">=</span> i<span class="token punctuation">;</span>
<span class="token keyword">auto</span> m <span class="token operator">=</span> j<span class="token punctuation">;</span> <span class="token comment">// auto 推导类型为 int，而非 int&amp;</span>
</code></pre> 
<p>根据规则2，虽然<code>j</code>是<code>i</code>的<strong>引用</strong>，类型为<code>int&amp;</code>，但是在推导<code>m</code>的时候会忽略其<strong>引用</strong>。</p> 
<p><strong>（3）使用<code>auto</code>和万能引用声明变量时，对于<code>左值</code>会将<code>auto</code>推导为引用类型：</strong></p> 
<pre><code class="prism language-cpp"><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">5</span><span class="token punctuation">;</span>
<span class="token keyword">auto</span><span class="token operator">&amp;&amp;</span> m <span class="token operator">=</span> i<span class="token punctuation">;</span> <span class="token comment">// auto 推导类型为 int&amp; （这里涉及引用折叠的概念）</span>
<span class="token keyword">auto</span><span class="token operator">&amp;&amp;</span> j <span class="token operator">=</span> <span class="token number">5</span><span class="token punctuation">;</span> <span class="token comment">// auto 推导类型为 int</span>
</code></pre> 
<p><strong>引用折叠</strong>是在自动类型推导（使用<code>auto</code>关键字）时的一个重要规则，它可以帮助确定最终的引用类型。在这段代码中，<code>auto&amp;&amp;</code>是一个<strong>通用引用</strong>，可以接受<strong>左值</strong>和<strong>右值</strong>。</p> 
<p>根据规则3，因为<code>i</code>是一个<strong>左值</strong>，所以<code>m</code>的类型被推导为<code>int&amp;</code>，这里涉及到了引用折叠的规则，因为 <code>auto&amp;&amp;</code> 是一个通用引用，当<strong>通用引用</strong>绑定到<strong>左值</strong>时，最终类型将成为<strong>左值引用</strong>。所以<code>auto</code>也被推导为<code>int&amp;</code>。</p> 
<p>而<code>5</code>是一个右值，因为它是一个临时值，因此<code>j</code>的类型被推导为<code>int&amp;&amp;</code>，而当<strong>通用引用</strong>绑定到<strong>右值</strong>时，最终类型仍然是<strong>右值引用</strong>，因此<code>auto</code>也被推导为<code>int</code>。</p> 
<p><strong>（4）使用<code>auto</code>声明变量，如果目标对象是一个数组或者函数，则<code>auto</code>会被推导为对应的指针类型：</strong></p> 
<pre><code class="prism language-cpp"><span class="token keyword">int</span> i<span class="token punctuation">[</span><span class="token number">5</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token keyword">auto</span> m <span class="token operator">=</span> i<span class="token punctuation">;</span> <span class="token comment">// auto 推导类型为 int*</span>
<span class="token keyword">int</span> <span class="token function">sum</span><span class="token punctuation">(</span><span class="token keyword">int</span> a1<span class="token punctuation">,</span> <span class="token keyword">int</span> a2<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token keyword">return</span> a1 <span class="token operator">+</span> a2<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">auto</span> j <span class="token operator">=</span> sum <span class="token comment">// auto 推导类型为 int (__cdecl *)(int,int)</span>
</code></pre> 
<p>根据规则4，虽然<code>i</code>是数组类型，但是<code>m</code>会被推导退化为<strong>指针类型</strong>，同样，<code>j</code>也退化<strong>为函数指针</strong>类型。</p> 
<p><strong>（5）当<code>auto</code>关键字与列表初始化组合时</strong>，这里的规则有新老两个版本，这里只介绍新规则（C++17标准）。</p> 
<ul><li><strong>① 直接使用列表初始化，列表中必须为单元素，否则无法编译，<code>auto</code>类型被推导为单元素的类型。</strong></li><li><strong>② 用等号加列表初始化，列表中可以包含单个或者多个元素，<code>auto</code>类型被推导为<code>std::initializer_list&lt;T&gt;</code>，其中<code>T</code>是元素类型。请注意，在列表中包含多个元素的时候，元素的类型必须相同，否则编译器会报错。</strong></li></ul> 
<pre><code class="prism language-cpp"><span class="token keyword">auto</span> x5<span class="token punctuation">{<!-- --></span> <span class="token number">3</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>         <span class="token comment">// x5 类型为 int</span>
<span class="token keyword">auto</span> x3<span class="token punctuation">{<!-- --></span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>      <span class="token comment">// 编译失败，不是单个元素</span>

<span class="token keyword">auto</span> x1 <span class="token operator">=</span> <span class="token punctuation">{<!-- --></span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>   <span class="token comment">// x1 类型为 std::initializer_list&lt;int&gt;</span>
<span class="token keyword">auto</span> x2 <span class="token operator">=</span> <span class="token punctuation">{<!-- --></span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2.0</span> <span class="token punctuation">}</span><span class="token punctuation">;</span> <span class="token comment">// 编译失败，花括号中元素类型不同</span>
<span class="token keyword">auto</span> x4 <span class="token operator">=</span> <span class="token punctuation">{<!-- --></span> <span class="token number">3</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>      <span class="token comment">// x4 类型为 std::initializer_list&lt;int&gt;</span>
</code></pre> 
<p>在上面的代码中，<code>x1</code>根据规则（5）② 被推导为<code>std::initializer_list&lt;T&gt;</code>，其中的元素都是<code>int</code>类型，所以<code>x1</code>被推导为<code>std::initializer_list&lt;int&gt;</code>。同样，<code>x2</code>也应该被推导为<code>std::initializer_list&lt;T&gt;</code>，但是显然两个元素类型不同，导致编译器无法确定<code>T</code>的类型，所以编译失败。根据规则（5）①，<code>x3</code>包含多个元素，直接导致编译失败。<code>x4</code>和<code>x1</code>一样被推导为<code>std::initializer_list&lt;T&gt;</code>，<code>x5</code>被推导为单元素的类型<code>int</code>。</p> 
<p>根据上面这些规则，读者可以思考下面的代码，<code>auto</code>会被推导成什么类型呢？</p> 
<pre><code class="prism language-cpp"><span class="token keyword">class</span> <span class="token class-name">Base</span> <span class="token punctuation">{<!-- --></span>
<span class="token keyword">public</span><span class="token operator">:</span>
    <span class="token keyword">virtual</span> <span class="token keyword">void</span> <span class="token function">f</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"Base::f()"</span> <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span>
    <span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">class</span> <span class="token class-name">Derived</span> <span class="token operator">:</span> <span class="token base-clause"><span class="token keyword">public</span> <span class="token class-name">Base</span></span> <span class="token punctuation">{<!-- --></span>
<span class="token keyword">public</span><span class="token operator">:</span>
    <span class="token keyword">virtual</span> <span class="token keyword">void</span> <span class="token function">f</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">override</span> <span class="token punctuation">{<!-- --></span>
        std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"Derived::f()"</span> <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span>
    <span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
Base<span class="token operator">*</span> d <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token function">Derived</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">auto</span> b <span class="token operator">=</span> <span class="token operator">*</span>d<span class="token punctuation">;</span>
b<span class="token punctuation">.</span><span class="token function">f</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> 
<p>以上代码有<code>Derived</code>和<code>Base</code>之间的继承关系，并且<code>Derived</code>重写了<code>Base</code>的<code>f</code>函数。代码使用<code>new</code>创建了一个<code>Derived</code>对象，并赋值于基类的指针类型变量上。我们知道<code>d-&gt;f()</code>一定调用的是<code>Derived</code>的<code>f</code>函数。但是<code>b.f()</code>调用的又是谁的<code>f</code>函数呢？实际上，由于<code>auto b = *d</code>这一句代码是按值赋值的，因此<code>auto</code>会直接推导为<code>Base</code>。代码自然会调用<code>Base</code>的复制构造函数，也就是说<code>Derived</code>被切割成了<code>Base</code>，这里的<code>b.f()</code>最终调用<code>Base</code>的<code>f</code>函数。那么进一步发散，如果代码写的是<code>auto &amp;b = *d</code>，结果又会如何呢？（<code>auto</code>会被推导为<code>Base&amp;</code>，<code>Base&amp;</code>等价于<code>new Derived()</code>，因此会调用<code>Derived::f()</code>）</p> 
<p>在 CLion 中编辑器会给出推断类型的提示：</p> 
<p><img src="https://images2.imgbox.com/ad/ee/BPtR7eR0_o.png" alt="在这里插入图片描述" width="300"><br> <img src="https://images2.imgbox.com/e4/48/TNf7Dnvl_o.png" alt="在这里插入图片描述" width="300"></p> 
<h3><a id="3__auto_536"></a>3. 什么时候使用 auto</h3> 
<p>合理使用 <code>auto</code>，可以让程序员从复杂的类型编码中解放出来，不但可以少敲很多代码，也会大大提高代码的可读性。但是事情总是有它的两面性，如果滥用<code>auto</code>，则会让代码失去可读性，不仅让后来人难以理解，间隔时间长了可能自己写的代码也要研读很久才能弄明白其含义。</p> 
<p>所以，下面我们来探讨一下，如何合理地使用<code>auto</code>。</p> 
<ol><li><strong>当一眼就能看出声明变量的初始化类型的时候可以使用<code>auto</code>。</strong></li><li><strong>对于复杂的类型，例如<code>lambda</code>表达式、<code>bind</code>等直接使用<code>auto</code>。</strong></li></ol> 
<p>对于第一条规则，常见的是在容器的迭代器上使用，例如：</p> 
<pre><code class="prism language-cpp">std<span class="token double-colon punctuation">::</span>map<span class="token operator">&lt;</span>std<span class="token double-colon punctuation">::</span>string<span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token operator">&gt;</span> str2int<span class="token punctuation">;</span>
<span class="token comment">// … 填充 str2int 的代码</span>
<span class="token keyword">for</span> <span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span>map<span class="token operator">&lt;</span>std<span class="token double-colon punctuation">::</span>string<span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token operator">&gt;</span><span class="token double-colon punctuation">::</span>const_iterator it <span class="token operator">=</span> str2int<span class="token punctuation">.</span><span class="token function">cbegin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>it <span class="token operator">!=</span> str2int<span class="token punctuation">.</span><span class="token function">cend</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token operator">++</span>it<span class="token punctuation">)</span> 
<span class="token punctuation">{<!-- --></span>
 <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token punctuation">}</span>
<span class="token comment">// 或者</span>
<span class="token keyword">for</span> <span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span>pair<span class="token operator">&lt;</span><span class="token keyword">const</span> std<span class="token double-colon punctuation">::</span>string<span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token operator">&gt;</span> <span class="token operator">&amp;</span>it <span class="token operator">:</span> str2int<span class="token punctuation">)</span> 
<span class="token punctuation">{<!-- --></span>
 <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>上面的代码如果不用<code>auto</code>来声明迭代器，那么我们需要编写<code>std::map &lt;std::string, int&gt;::const_iterator</code>和<code>std::pair&lt;const std::string, int&gt;</code>来代替<code>auto</code>，而多出来的代码并不会增强代码的可读性，反而会让代码看起来冗余，因为通常我们一眼就能看明白<code>it</code>的具体类型。请注意，第二个<code>for</code>的<code>it</code>类型是<code>std::pair&lt;const std::string, int&gt;</code>，而不是<code>std::pair&lt;std:: string, int&gt;</code>，如果写成后者是无法通过编译的。直接使用<code>auto</code>，可以避免上述问题：</p> 
<pre><code class="prism language-cpp">std<span class="token double-colon punctuation">::</span>map<span class="token operator">&lt;</span>std<span class="token double-colon punctuation">::</span>string<span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token operator">&gt;</span> str2int<span class="token punctuation">;</span>
<span class="token comment">// … 填充 str2int 的代码</span>
<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">auto</span> it <span class="token operator">=</span> str2int<span class="token punctuation">.</span><span class="token function">cbegin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> it <span class="token operator">!=</span> str2int<span class="token punctuation">.</span><span class="token function">cend</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token operator">++</span>it<span class="token punctuation">)</span> 
<span class="token punctuation">{<!-- --></span>
 <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token punctuation">}</span>
<span class="token comment">// 或者</span>
<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">auto</span> <span class="token operator">&amp;</span>it <span class="token operator">:</span> str2int<span class="token punctuation">)</span> 
<span class="token punctuation">{<!-- --></span>
 <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>这样是不是简洁了很多！</p> 
<p>反过来说，如果使用<code>auto</code>声明变量，则会导致其他程序员阅读代码时需要翻阅初始化变量的具体类型，那么我们需要慎重考虑是否适合使用<code>auto</code>关键字。</p> 
<p>对于第二条规则，我们有时候会遇到<strong>无法写出类型</strong>或者<strong>过于复杂的类型</strong>，或者即使能正确写出某些复杂类型，但是其他程序员阅读起来也很费劲，这种时候建议使用<code>auto</code>来声明，例如<code>lambda</code>表达式：</p> 
<pre><code class="prism language-cpp"><span class="token keyword">auto</span> l <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token keyword">int</span> a1<span class="token punctuation">,</span> <span class="token keyword">int</span> a2<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span> <span class="token keyword">return</span> a1 <span class="token operator">+</span> a2<span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre> 
<p>这里<code>l</code>的类型可能是一个这样的名称<code>xxx::&lt;lambda_efdefb7231ea076 22630c86251a36ed4&gt;</code>（不同的编译器命名方法会有所不同），我们根本无法写出其类型，只能用<code>auto</code>来声明。</p> 
<p>再例如：</p> 
<pre><code class="prism language-cpp"><span class="token keyword">int</span> <span class="token function">sum</span><span class="token punctuation">(</span><span class="token keyword">int</span> a1<span class="token punctuation">,</span> <span class="token keyword">int</span> a2<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span> <span class="token keyword">return</span> a1 <span class="token operator">+</span> a2<span class="token punctuation">;</span> <span class="token punctuation">}</span>
<span class="token keyword">auto</span> b <span class="token operator">=</span> std<span class="token double-colon punctuation">::</span><span class="token function">bind</span><span class="token punctuation">(</span>sum<span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">,</span> std<span class="token double-colon punctuation">::</span>placeholders<span class="token double-colon punctuation">::</span>_1<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> 
<p>这里<code>b</code>的类型为<code>std::_Binder&lt;std::_Unforced,int( cdecl&amp;) (int,int),int, const std::_Ph&lt;1&gt; &amp;&gt;</code>，绝大多数读者看到这种类型时会默契地选择使用<code>auto</code>来声明变量。</p> 
<h3><a id="4__594"></a>4. 返回类型推导</h3> 
<p>C++14标准支持对返回类型声明为<code>auto</code>的推导，例如：</p> 
<pre><code class="prism language-cpp"><span class="token keyword">auto</span> <span class="token function">sum</span><span class="token punctuation">(</span><span class="token keyword">int</span> a1<span class="token punctuation">,</span> <span class="token keyword">int</span> a2<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span> <span class="token keyword">return</span> a1 <span class="token operator">+</span> a2<span class="token punctuation">;</span> <span class="token punctuation">}</span>
</code></pre> 
<p>在上面的代码中，编译器会帮助我们推导<code>sum</code>的返回值，由于<code>a1</code>和<code>a2</code>都是<code>int</code>类型，所以其返回类型也是<code>int</code>，于是返回类型被推导为<code>int</code>类型。请注意，如果有多重返回值，那么需要保证返回值类型是相同的。例如：</p> 
<pre><code class="prism language-cpp"><span class="token keyword">auto</span> <span class="token function">sum</span><span class="token punctuation">(</span><span class="token keyword">long</span> a1<span class="token punctuation">,</span> <span class="token keyword">long</span> a2<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token keyword">if</span> <span class="token punctuation">(</span>a1 <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
		<span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token comment">// 返回int类型</span>
	<span class="token punctuation">}</span>
	<span class="token keyword">else</span> <span class="token punctuation">{<!-- --></span>
		<span class="token keyword">return</span> a1 <span class="token operator">+</span> a2<span class="token punctuation">;</span> <span class="token comment">// 返回long类型</span>
	<span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>以上代码中有两处返回，<code>return 0</code> 返回的是 <code>int</code> 类型，而 <code>return a1+a2</code>返回的是<code>long</code>类型，这种不同的返回类型会导致编译失败。</p> 
<h3><a id="5_lambda__auto__617"></a>5. lambda 表达式中使用 auto 类型推导</h3> 
<p>在C++14标准中我们还可以把<code>auto</code>写到<code>lambda</code>表达式的形参中，这样就得到了一个泛型的<code>lambda</code>表达式，例如：</p> 
<pre><code class="prism language-cpp"><span class="token keyword">auto</span> l <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token keyword">auto</span> a1<span class="token punctuation">,</span> <span class="token keyword">auto</span> a2<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span> <span class="token keyword">return</span> a1 <span class="token operator">+</span> a2<span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">auto</span> retval <span class="token operator">=</span> <span class="token function">l</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">5.0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> 
<p>在上面的代码中<code>a1</code>被推导为<code>int</code>类型，<code>a2</code>被推导为<code>double</code>类型，返回值<code>retval</code>被推导为<code>double</code>类型。</p> 
<p>让我们看一看<code>lambda</code>表达式返回<code>auto</code>引用的方法：</p> 
<pre><code class="prism language-cpp"><span class="token keyword">auto</span> l <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token keyword">int</span> <span class="token operator">&amp;</span>i<span class="token punctuation">)</span><span class="token operator">-&gt;</span><span class="token keyword">auto</span><span class="token operator">&amp;</span> <span class="token punctuation">{<!-- --></span> <span class="token keyword">return</span> i<span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">auto</span> x1 <span class="token operator">=</span> <span class="token number">5</span><span class="token punctuation">;</span>
<span class="token keyword">auto</span> <span class="token operator">&amp;</span>x2 <span class="token operator">=</span> <span class="token function">l</span><span class="token punctuation">(</span>x1<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">assert</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>x1 <span class="token operator">==</span> <span class="token operator">&amp;</span>x2<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 有相同的内存地址</span>
</code></pre> 
<p>起初在后置返回类型中使用<code>auto</code>是不允许的，但是后来人们发现，这是唯一让<code>lambda</code>表达式通过推导返回引用类型的方法了。</p> 
<h3><a id="6__637"></a>6. 非类型模板形参占位符</h3> 
<p>C++17标准对<code>auto</code>关键字又一次进行了扩展，使它可以作为非类型模板形参的占位符。当然，我们必须保证推导出来的类型是可以用作模板形参的，否则无法通过编译，例如：</p> 
<pre><code class="prism language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream&gt;</span></span>
<span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">auto</span> N<span class="token operator">&gt;</span>
<span class="token keyword">void</span> <span class="token function">f</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> N <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token generic-function"><span class="token function">f</span><span class="token generic class-name"><span class="token operator">&lt;</span><span class="token number">5</span><span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment">// N 为 int 类型</span>
	f<span class="token operator">&lt;</span><span class="token char">'c'</span><span class="token operator">&gt;</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// N 为 char 类型</span>
	<span class="token generic-function"><span class="token function">f</span><span class="token generic class-name"><span class="token operator">&lt;</span><span class="token number">5.0</span><span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 编译失败，模板参数不能为 double</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>在上面的代码中，函数<code>f&lt;5&gt;()</code>中<code>5</code>的类型为<code>int</code>，所以<code>auto</code>被推导为<code>int</code>类型。同理，<code>f&lt;'c'&gt;()</code>的<code>auto</code>被推导为<code>char</code>类型。由于<code>f&lt;5.0&gt;()</code>的<code>5.0</code>被推导为<code>double</code>类型，但是模板参数不能为<code>double</code>类型，因此导致编译失败。</p> 
<h2><a id="decltypeC11C17_657"></a>四、decltype说明符（C++11～C++17）</h2> 
<h3><a id="1__typeof__typeid__659"></a>1. 回顾 typeof 和 typeid 获取类型</h3> 
<p>在C++11标准发布以前，GCC的扩展提供了一个名为<code>typeof</code>的运算符。通过该运算符可以获取操作数的具体类型。这让使用GCC的程序员在很早之前就具有了对对象类型进行推导的能力，例如：</p> 
<pre><code class="prism language-cpp"><span class="token keyword">int</span> a <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token function">typeof</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span> b <span class="token operator">=</span> <span class="token number">5</span><span class="token punctuation">;</span>
</code></pre> 
<p>由于<code>typeof</code>并非C++标准，因此就不再深入介绍了。关于<code>typeof</code>更多具体的用法可以参考GCC的相关文档。</p> 
<p>除使用GCC提供的<code>typeof</code>运算符获取对象类型以外，C++标准还提供了一个<code>typeid</code>运算符来获取与目标操作数类型有关的信息。获取的类型信息会包含在一个类型为<code>std::type_info</code>的对象里。我们可以调用成员函数<code>name</code>获取其类型名，例如：</p> 
<pre><code class="prism language-java"><span class="token keyword">int</span> x1 <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token keyword">double</span> x2 <span class="token operator">=</span> <span class="token number">5.5</span><span class="token punctuation">;</span>
std<span class="token operator">::</span><span class="token function">cout</span> <span class="token operator">&lt;&lt;</span> <span class="token function">typeid</span><span class="token punctuation">(</span>x1<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">name</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span><span class="token function">endl</span><span class="token punctuation">;</span>      <span class="token comment">// Clion 中输出 i</span>
std<span class="token operator">::</span><span class="token function">cout</span> <span class="token operator">&lt;&lt;</span> <span class="token function">typeid</span><span class="token punctuation">(</span>x1 <span class="token operator">+</span> x2<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">name</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span><span class="token function">endl</span><span class="token punctuation">;</span> <span class="token comment">// Clion 中输出 d</span>
std<span class="token operator">::</span><span class="token function">cout</span> <span class="token operator">&lt;&lt;</span> <span class="token function">typeid</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">name</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span><span class="token function">endl</span><span class="token punctuation">;</span>     <span class="token comment">// Clion 中输出 i</span>
</code></pre> 
<p>值得注意的是，成员函数<code>name</code>返回的类型名在C++标准中并没有明确的规范，所以输出的类型名会因编译器而异。比如，MSVC会输出一个符合程序员阅读习惯的名称，而GCC则会输出一个它自定义的名称。</p> 
<p>另外，还有3点也需要注意。</p> 
<ol><li><code>typeid</code>的返回值是一个<strong>左值</strong>，且其生命周期一直被扩展到程序生命周期结束。</li><li><code>typeid</code>返回的<code>std::type_info</code>删除了复制构造函数，若想保存<code>std::type_info</code>，只能获取其引用或者指针，例如：</li></ol> 
<pre><code class="prism language-cpp"><span class="token keyword">auto</span> t1 <span class="token operator">=</span> <span class="token keyword">typeid</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 编译失败，没有复制构造函数无法编译</span>
<span class="token keyword">auto</span> <span class="token operator">&amp;</span>t2 <span class="token operator">=</span> <span class="token keyword">typeid</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 编译成功，t2 推导为 const std::type_info&amp;</span>
<span class="token keyword">auto</span> t3 <span class="token operator">=</span> <span class="token operator">&amp;</span><span class="token keyword">typeid</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 编译成功，t3 推导为 const std::type_info*</span>
</code></pre> 
<ol start="3"><li><code>typeid</code>的返回值总是忽略类型的 <code>cv</code> 限定符，也就是<code>typeid(const T) == typeid(T))</code>。</li></ol> 
<p>虽然<code>typeid</code>可以获取类型信息并帮助我们判断类型之间的关系，但遗憾的是，它并不能像<code>typeof</code>那样在编译期就确定对象类型。</p> 
<h3><a id="2__decltype__695"></a>2. 使用 decltype 说明符获取类型</h3> 
<p>为了用统一方法解决上述问题，C++11标准引入了<code>decltype</code>说明符，<strong>使用<code>decltype</code>说明符可以获取对象或者表达式的类型</strong>，其语法和<code>typeof</code>类似：</p> 
<pre><code class="prism language-cpp"><span class="token keyword">int</span> x1 <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token keyword">decltype</span><span class="token punctuation">(</span>x1<span class="token punctuation">)</span> x2 <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token keyword">typeid</span><span class="token punctuation">(</span>x2<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">name</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span> <span class="token comment">// x2 的类型为 int</span>
<span class="token keyword">double</span> x3 <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token keyword">decltype</span><span class="token punctuation">(</span>x1 <span class="token operator">+</span> x3<span class="token punctuation">)</span> x4 <span class="token operator">=</span> x1 <span class="token operator">+</span> x3<span class="token punctuation">;</span>
std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token keyword">typeid</span><span class="token punctuation">(</span>x4<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">name</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span> <span class="token comment">// x1 + x3 的类型为 double</span>
<span class="token keyword">decltype</span><span class="token punctuation">(</span><span class="token punctuation">{<!-- --></span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">}</span><span class="token punctuation">)</span> x5<span class="token punctuation">;</span> <span class="token comment">// 编译失败，{1, 2} 不是表达式</span>
</code></pre> 
<p>以上代码展示了 <code>decltype</code> 的一般用法，代码中分别获取变量 <code>x1</code> 和表达式 <code>x1 + x3</code> 的类型并且声明该类型的变量。但是 <code>decltype</code> 的使用场景还远远不止于此。还记得在第3章中讨论过 <code>auto</code> 不能在非静态成员变量中使用吗？<code>decltype</code> 却是可以的：</p> 
<pre><code class="prism language-cpp"><span class="token keyword">struct</span> <span class="token class-name">S1</span> <span class="token punctuation">{<!-- --></span>
	<span class="token keyword">int</span> x1<span class="token punctuation">;</span>
	<span class="token keyword">decltype</span><span class="token punctuation">(</span>x1<span class="token punctuation">)</span> x2<span class="token punctuation">;</span>
	<span class="token keyword">double</span> x3<span class="token punctuation">;</span>
	<span class="token keyword">decltype</span><span class="token punctuation">(</span>x2 <span class="token operator">+</span> x3<span class="token punctuation">)</span> x4<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre> 
<p>比如，在函数的形参列表中使用：</p> 
<pre><code class="prism language-cpp"><span class="token keyword">int</span> x1 <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token keyword">decltype</span><span class="token punctuation">(</span>x1<span class="token punctuation">)</span> <span class="token function">sum</span><span class="token punctuation">(</span><span class="token keyword">decltype</span><span class="token punctuation">(</span>x1<span class="token punctuation">)</span> a1<span class="token punctuation">,</span> <span class="token keyword">decltype</span><span class="token punctuation">(</span>a1<span class="token punctuation">)</span> a2<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token keyword">return</span> a1 <span class="token operator">+</span> a2<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">auto</span> x2 <span class="token operator">=</span> <span class="token function">sum</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> 
<p>看到这里，读者应该会质疑 <code>decltype</code> 是否有实际用途，因为到目前为止我们看到的无非是一些画蛇添足的用法，直接声明变量类型或者使用 <code>auto</code> 占位符要简单得多。确实如此，上面的代码并没有展示 <code>decltype</code> 的独特之处，只是描述其基本功能。</p> 
<p>为了更好地讨论<code>decltype</code>的优势，需要用到函数返回类型后置（见第5章）的例子：</p> 
<pre><code class="prism language-cpp"><span class="token keyword">auto</span> <span class="token function">sum</span><span class="token punctuation">(</span><span class="token keyword">int</span> a1<span class="token punctuation">,</span> <span class="token keyword">int</span> a2<span class="token punctuation">)</span><span class="token operator">-&gt;</span><span class="token keyword">int</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token keyword">return</span> a1 <span class="token operator">+</span> a2<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>以上代码以 <code>C++11</code> 为标准，该标准中 <code>auto</code> 作为占位符并不能使编译器对函数返回类型进行推导，必须使用返回类型后置的形式指定返回类型。如果接下来想泛化这个函数，让其支持各种类型运算应该怎么办？由于形参不能声明为 <code>auto</code>，因此我们需要用到函数模板：</p> 
<pre><code class="prism language-cpp"><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">T</span><span class="token operator">&gt;</span>
T <span class="token function">sum</span><span class="token punctuation">(</span>T a1<span class="token punctuation">,</span> T a2<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token keyword">return</span> a1 <span class="token operator">+</span> a2<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">auto</span> x1 <span class="token operator">=</span> <span class="token function">sum</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">)</span>
</code></pre> 
<p>代码看上去很好，但是并不能适应所有情况，因为调用者如果传递不同类型的实参，则无法编译通过：</p> 
<pre><code class="prism language-cpp"><span class="token keyword">auto</span> x2 <span class="token operator">=</span> <span class="token function">sum</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">10.5</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 编译失败，无法确定 T 的类型</span>
</code></pre> 
<p>既然如此，我们只能编写一个更加灵活的函数模板：</p> 
<pre><code class="prism language-cpp"><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">R</span><span class="token punctuation">,</span> <span class="token keyword">class</span> <span class="token class-name">T1</span><span class="token punctuation">,</span> <span class="token keyword">class</span> <span class="token class-name">T2</span><span class="token operator">&gt;</span>
R <span class="token function">sum</span><span class="token punctuation">(</span>T1 a1<span class="token punctuation">,</span> T2 a2<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token keyword">return</span> a1 <span class="token operator">+</span> a2<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">auto</span> x3 <span class="token operator">=</span> <span class="token generic-function"><span class="token function">sum</span><span class="token generic class-name"><span class="token operator">&lt;</span><span class="token keyword">double</span><span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">10.5</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> 
<p>不错，这样好像可以满足我们泛化<code>sum</code>函数的要求了。但美中不足的是我们必须为函数模板指定返回值类型。为了让编译期完成所有的类型推导工作，我们决定继续优化函数模板：</p> 
<pre><code class="prism language-cpp"><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">T1</span><span class="token punctuation">,</span> <span class="token keyword">class</span> <span class="token class-name">T2</span><span class="token operator">&gt;</span>
<span class="token keyword">auto</span> <span class="token function">sum</span><span class="token punctuation">(</span>T1 a1<span class="token punctuation">,</span> T2 a2<span class="token punctuation">)</span><span class="token operator">-&gt;</span><span class="token keyword">decltype</span><span class="token punctuation">(</span>a1 <span class="token operator">+</span> a2<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token keyword">return</span> a1 <span class="token operator">+</span> a2<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">auto</span> x4 <span class="token operator">=</span> <span class="token function">sum</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">10.5</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> 
<p><code>decltype</code> 终于登场了，可以看到它完美地解决了之前需要指定返回类型的问题。解释一下这段代码，<code>auto</code> 是返回类型的占位符，参数类型分别是 <code>T1</code> 和 <code>T2</code>，我们利用 <code>decltype</code> 说明符能推断表达式的类型特性，在函数尾部对 <code>auto</code> 的类型进行说明，如此一来，在实例化 <code>sum</code> 函数的时候，编译器就能够知道 <code>sum</code> 的返回类型了。</p> 
<blockquote> 
 <p>注意，形参也是有作用域的，它只能按顺序访问，即放在后面的可以访问放在前面的，这也是为什么decltype(a1 + a2)要放在后面，而不是放在前面</p> 
</blockquote> 
<p>上述用法只推荐在<strong>C++11</strong>标准的编译环境中使用，因为<strong>C++14</strong>标准已经支持对<code>auto</code>声明的返回类型进行推导了，所以以上代码可以简化为：</p> 
<pre><code class="prism language-cpp"><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">T1</span><span class="token punctuation">,</span> <span class="token keyword">class</span> <span class="token class-name">T2</span><span class="token operator">&gt;</span>
<span class="token keyword">auto</span> <span class="token function">sum</span><span class="token punctuation">(</span>T1 a1<span class="token punctuation">,</span> T2 a2<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token keyword">return</span> a1 <span class="token operator">+</span> a2<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">auto</span> x5 <span class="token operator">=</span> <span class="token function">sum</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">10.5</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> 
<p>讲到这里，读者肯定有疑问了，在C++14中<code>decltype</code>的作用又被<code>auto</code>代替了。是否从C++14标准以后<code>decltype</code>就没有用武之地了呢？</p> 
<p>并不是这样的，<code>auto</code>作为返回类型的占位符还存在一些问题，请看下面的例子：</p> 
<pre><code class="prism language-cpp"><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">T</span><span class="token operator">&gt;</span>
<span class="token keyword">auto</span> <span class="token function">return_ref</span><span class="token punctuation">(</span>T<span class="token operator">&amp;</span> t<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token keyword">return</span> t<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">int</span> x1 <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token keyword">static_assert</span><span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span>is_reference_v<span class="token operator">&lt;</span><span class="token keyword">decltype</span><span class="token punctuation">(</span><span class="token function">return_ref</span><span class="token punctuation">(</span>x1<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token operator">&gt;</span><span class="token punctuation">)</span> <span class="token comment">// 编译错误，返回值不为引用类型</span>
</code></pre> 
<p>在上面的代码中，我们期望 <code>return_ref</code> 返回的是一个 <code>T</code> 的引用类型，但是如果编译此段代码，则必然会编译失败，因为 <code>auto</code> 被推导为值类型，这就是第3章所讲的 <code>auto</code> 推导规则2。如果想正确地返回引用类型，则需要用到 <code>decltype</code> 说明符，例如：</p> 
<pre><code class="prism language-cpp"><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">T</span><span class="token operator">&gt;</span>
<span class="token keyword">auto</span> <span class="token function">return_ref</span><span class="token punctuation">(</span>T<span class="token operator">&amp;</span> t<span class="token punctuation">)</span><span class="token operator">-&gt;</span><span class="token keyword">decltype</span><span class="token punctuation">(</span>t<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token keyword">return</span> t<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">int</span> x1 <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token keyword">static_assert</span><span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span>is_reference_v<span class="token operator">&lt;</span><span class="token keyword">decltype</span><span class="token punctuation">(</span><span class="token function">return_ref</span><span class="token punctuation">(</span>x1<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token operator">&gt;</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 编译成功</span>
</code></pre> 
<p>以上两段代码几乎相同，只是在 <code>return_ref</code> 函数的尾部用 <code>decltype(t)</code> 声明了返回类型，但是代码却可以顺利地通过编译。为了弄清楚编译成功的原因，我们需要讨论 <code>decltype</code> 的推导规则。</p> 
<h3><a id="3__815"></a>3. 推导规则</h3> 
<p><code>decltype(e)</code>（其中 <code>e</code> 的类型为 <code>T</code>）的推导规则有 <code>5</code> 条：</p> 
<ol><li>如果 <code>e</code> 是一个未加括号的标识符表达式（结构化绑定除外）或者未加括号的类成员访问，则 <code>decltype(e)</code> 推断出的类型是 <code>e</code> 的类型 <code>T</code>。如果并不存在这样的类型，或者 <code>e</code> 是一组重载函数，则无法进行推导。</li><li>如果 <code>e</code> 是一个函数调用或者仿函数调用，那么 <code>decltype(e)</code> 推断出的类型是其返回值的类型。</li><li>如果 <code>e</code> 是一个类型为 <code>T</code> 的左值，则 <code>decltype(e)</code> 是 <code>T&amp;</code>。</li><li>如果 <code>e</code> 是一个类型为 <code>T</code> 的将亡值，则 <code>decltype(e)</code> 是 <code>T&amp;&amp;</code>。</li><li>除去以上情况，则 <code>decltype(e)</code> 是 <code>T</code>。</li></ol> 
<p>根据这5条规则，我们来看一看C++标准文档给的几个例子：</p> 
<pre><code class="prism language-cpp"><span class="token keyword">const</span> <span class="token keyword">int</span><span class="token operator">&amp;&amp;</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">int</span> i<span class="token punctuation">;</span>
<span class="token keyword">struct</span> <span class="token class-name">A</span> <span class="token punctuation">{<!-- --></span>
	<span class="token keyword">double</span> x<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">const</span> A<span class="token operator">*</span> a <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token function">A</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">decltype</span><span class="token punctuation">(</span><span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// decltype(foo()) 推导类型为 const int&amp;&amp;</span>
<span class="token keyword">decltype</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token comment">// decltype(i) 推导类型为int</span>
<span class="token keyword">decltype</span><span class="token punctuation">(</span>a<span class="token operator">-&gt;</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// decltype(a-&gt;x) 推导类型为 double</span>
<span class="token keyword">decltype</span><span class="token punctuation">(</span><span class="token punctuation">(</span>a<span class="token operator">-&gt;</span>x<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// decltype((a-&gt;x)) 推导类型为 const double&amp;</span>
</code></pre> 
<p>在上面的代码中，<code>decltype(foo())</code> 满足规则2和规则4，<code>foo</code> 函数的返回类型是 <code>const int&amp;&amp;</code>，所以推导结果也为 <code>const int&amp;&amp;</code>；<code>decltype(i)</code> 和 <code>decltype(a-&gt;x)</code> 很简单，满足规则1，所以其类型为 <code>int</code> 和 <code>double</code>；最后一句代码，由于 <code>decltype((a-&gt;x))</code> 推导的是一个带括号的表达式 <code>(a-&gt;x)</code>，因此规则1不再适用，但很明显 <code>a-&gt;x</code> 是一个左值，又因为 <code>a</code> 带有 <code>const</code> 限定符，所以其类型被推导为 <code>const double&amp;</code>。</p> 
<p>如果读者已经理解了<code>decltype</code>的推导规则，不妨尝试推导下列代码中<code>decltype</code>的推导结果：</p> 
<pre><code class="prism language-cpp"><span class="token keyword">int</span> i<span class="token punctuation">;</span>
<span class="token keyword">int</span> <span class="token operator">*</span>j<span class="token punctuation">;</span>
<span class="token keyword">int</span> n<span class="token punctuation">[</span><span class="token number">10</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token keyword">const</span> <span class="token keyword">int</span><span class="token operator">&amp;&amp;</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">decltype</span><span class="token punctuation">(</span><span class="token generic-function"><span class="token function">static_cast</span><span class="token generic class-name"><span class="token operator">&lt;</span><span class="token keyword">short</span><span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// decltype(static_cast&lt;short&gt;(i)) 推导类型为 short</span>
<span class="token keyword">decltype</span><span class="token punctuation">(</span>j<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// decltype(j) 推导类型为 int*</span>
<span class="token keyword">decltype</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// decltype(n) 推导类型为 int[10]</span>
<span class="token keyword">decltype</span><span class="token punctuation">(</span>foo<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// decltype(foo) 推导类型为 int const &amp;&amp;(void)</span>
<span class="token keyword">struct</span> <span class="token class-name">A</span> <span class="token punctuation">{<!-- --></span>
	<span class="token keyword">int</span> <span class="token keyword">operator</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span> <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
A a<span class="token punctuation">;</span>
<span class="token keyword">decltype</span><span class="token punctuation">(</span><span class="token function">a</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// decltype(a()) 推导类型为 int</span>
</code></pre> 
<p>最后让我们看几个更为复杂的例子：</p> 
<pre><code class="prism language-cpp"><span class="token keyword">int</span> i<span class="token punctuation">;</span>
<span class="token keyword">int</span> <span class="token operator">*</span>j<span class="token punctuation">;</span>
<span class="token keyword">int</span> n<span class="token punctuation">[</span><span class="token number">10</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token keyword">decltype</span><span class="token punctuation">(</span>i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// decltype(i=0) 推导类型为 int&amp;</span>
<span class="token keyword">decltype</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// decltype(0,i) 推导类型为 int&amp;</span>
<span class="token keyword">decltype</span><span class="token punctuation">(</span>i<span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// decltype(i,0) 推导类型为 int</span>
<span class="token keyword">decltype</span><span class="token punctuation">(</span>n<span class="token punctuation">[</span><span class="token number">5</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// decltype(n[5]) 推导类型为 int&amp;</span>
<span class="token keyword">decltype</span><span class="token punctuation">(</span><span class="token operator">*</span>j<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// decltype(*j) 推导类型为 int&amp;</span>
<span class="token keyword">decltype</span><span class="token punctuation">(</span><span class="token generic-function"><span class="token function">static_cast</span><span class="token generic class-name"><span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&amp;&amp;</span><span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// decltype(static_cast&lt;int&amp;&amp;&gt;(i)) 推导类型为 int&amp;&amp;</span>
<span class="token keyword">decltype</span><span class="token punctuation">(</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// decltype(i++) 推导类型为 int</span>
<span class="token keyword">decltype</span><span class="token punctuation">(</span><span class="token operator">++</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// decltype(++i) 推导类型为 int&amp;</span>
<span class="token keyword">decltype</span><span class="token punctuation">(</span><span class="token string">"hello world"</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// decltype("hello world") 推导类型为 const char(&amp;)[12]</span>
</code></pre> 
<p>让我们来看一看上面代码中的例子都是怎么推导出来的：</p> 
<ol><li>可以确认以上例子中的表达式都不是标识符表达式，这样就排除了规则1。</li><li><code>i=0</code> 和 <code>0, i</code> 表达式都返回左值 <code>i</code>，所以推导类型为 <code>int&amp;</code>。</li><li><code>i, 0</code> 表达式返回 <code>0</code>，所以推导类型为 <code>int</code>。</li><li><code>n[5]</code> 返回的是数组 <code>n</code> 中的第6个元素，也是左值，所以推导类型为 <code>int&amp;</code>。</li><li><code>*j</code> 很明显也是一个左值，所以推导类型也为 <code>int&amp;</code>。</li><li><code>static_cast&lt;int&amp;&amp;&gt;(i)</code> 被转换为一个将亡值类型，所以其推导类型为 <code>int&amp;&amp;</code>。</li><li><code>i++</code> 和 <code>++i</code> 分别返回右值和左值，所以推导类型分别为 <code>int</code> 和 <code>int&amp;</code>。</li><li><code>hello world</code> 是一个常量数组的左值，其推导类型为 <code>const char(&amp;)[12]</code>。</li></ol> 
<h3><a id="4_cv__884"></a>4. cv 限定符的推导</h3> 
<p>通常情况下，<code>decltype(e)</code> 所推导的类型会同步 <code>e</code> 的 <code>cv</code> 限定符，比如：</p> 
<pre><code class="prism language-cpp"><span class="token keyword">const</span> <span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token keyword">decltype</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// decltype(i) 推导类型为 const int</span>
</code></pre> 
<p>但是还有其他情况，当<code>e</code>是未加括号的成员变量时，父对象表达式的<code>cv</code>限定符会被忽略，不能同步到推导结果：</p> 
<pre><code class="prism language-cpp"><span class="token keyword">struct</span> <span class="token class-name">A</span> <span class="token punctuation">{<!-- --></span>
    <span class="token keyword">double</span> x<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">const</span> A<span class="token operator">*</span> a <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token function">A</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">decltype</span><span class="token punctuation">(</span>a<span class="token operator">-&gt;</span>x<span class="token punctuation">)</span> i<span class="token punctuation">;</span> <span class="token comment">// decltype(a-&gt;x) 推导类型为 double, const 属性被忽略</span>
i <span class="token operator">=</span> <span class="token number">6.0</span><span class="token punctuation">;</span> <span class="token comment">// i 可以被正常赋值</span>
</code></pre> 
<p>在上面的代码中，<code>a</code> 被声明为 <code>const</code> 类型，如果想在代码中改变 <code>a</code> 中 <code>x</code> 的值，则肯定会编译失败。但是 <code>decltype(a-&gt;x)</code> 却得到了一个没有 <code>const</code> 属性的 <code>double</code> 类型。当然，如果我们给 <code>a-&gt;x</code> 加上括号，则情况会有所不同：</p> 
<pre><code class="prism language-cpp"><span class="token keyword">struct</span> <span class="token class-name">A</span> <span class="token punctuation">{<!-- --></span>
    <span class="token keyword">double</span> x<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">const</span> A<span class="token operator">*</span> a <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token function">A</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">decltype</span><span class="token punctuation">(</span><span class="token punctuation">(</span>a<span class="token operator">-&gt;</span>x<span class="token punctuation">)</span><span class="token punctuation">)</span> i<span class="token punctuation">;</span> <span class="token comment">// decltype((a-&gt;x)) 推导类型为 const double&amp;</span>
i <span class="token operator">=</span> <span class="token number">6.0</span><span class="token punctuation">;</span> <span class="token comment">// 编译失败，i 不可以被赋值</span>
</code></pre> 
<p>总的来说，<strong>当<code>e</code>是加括号的数据成员时，父对象表达式的<code>cv</code>限定符会同步到推断结果</strong>。</p> 
<h3><a id="5_decltypeauto_915"></a>5. decltype(auto)</h3> 
<p>在 <code>C++14</code> 标准中出现了 <code>decltype</code> 和 <code>auto</code> 两个关键字的结合体：<code>decltype(auto)</code>。它的作用简单来说，就是告诉编译器用 <code>decltype</code> 的推导表达式规则来推导 <code>auto</code>。另外需要注意的是，<code>decltype(auto)</code> 必须单独声明，也就是它不能结合指针、引用以及 <code>cv</code> 限定符。看完下面的例子，读者就会有所体会：</p> 
<pre><code class="prism language-cpp"><span class="token keyword">int</span> i<span class="token punctuation">;</span>
<span class="token keyword">int</span><span class="token operator">&amp;&amp;</span> <span class="token function">f</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">auto</span> x1a <span class="token operator">=</span> i<span class="token punctuation">;</span>              <span class="token comment">// x1a 推导类型为 int</span>
<span class="token keyword">decltype</span><span class="token punctuation">(</span><span class="token keyword">auto</span><span class="token punctuation">)</span> x1d <span class="token operator">=</span> i<span class="token punctuation">;</span>    <span class="token comment">// x1d 推导类型为 int</span>
<span class="token keyword">auto</span> x2a <span class="token operator">=</span> <span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment">// x2a 推导类型为 int</span>
<span class="token keyword">decltype</span><span class="token punctuation">(</span><span class="token keyword">auto</span><span class="token punctuation">)</span> x2d <span class="token operator">=</span> <span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// x2d 推导类型为 int&amp;</span>
<span class="token keyword">auto</span> x3a <span class="token operator">=</span> <span class="token function">f</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment">// x3a 推导类型为 int</span>
<span class="token keyword">decltype</span><span class="token punctuation">(</span><span class="token keyword">auto</span><span class="token punctuation">)</span> x3d <span class="token operator">=</span> <span class="token function">f</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// x3d 推导类型为 int&amp;&amp;</span>
<span class="token keyword">auto</span> x4a <span class="token operator">=</span> <span class="token punctuation">{<!-- --></span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>       <span class="token comment">// x4a 推导类型为 std::initializer_list&lt;int&gt;</span>
<span class="token keyword">decltype</span><span class="token punctuation">(</span><span class="token keyword">auto</span><span class="token punctuation">)</span> x4d <span class="token operator">=</span> <span class="token punctuation">{<!-- --></span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span> <span class="token punctuation">}</span><span class="token punctuation">;</span> <span class="token comment">// 编译失败, {1, 2} 不是表达式</span>
<span class="token keyword">auto</span> <span class="token operator">*</span>x5a <span class="token operator">=</span> <span class="token operator">&amp;</span>i<span class="token punctuation">;</span>           <span class="token comment">// x5a 推导类型为 int*</span>
<span class="token keyword">decltype</span><span class="token punctuation">(</span><span class="token keyword">auto</span><span class="token punctuation">)</span><span class="token operator">*</span>x5d <span class="token operator">=</span> <span class="token operator">&amp;</span>i<span class="token punctuation">;</span>  <span class="token comment">// 编译失败, decltype(auto) 必须单独声明</span>
</code></pre> 
<p>观察上面的代码可以发现，<code>auto</code> 和 <code>decltype(auto)</code> 的用法几乎相同，只是在推导规则上遵循 <code>decltype</code> 而已。比如<code>(i)</code>在 <code>auto</code> 规则的作用下，<code>x2a</code> 的类型被推导为 <code>int</code>，而 <code>x2d</code> 的类型被推导为 <code>int&amp;</code>。另外，由于 <code>decltype(auto)</code> 必须单独声明，因此 <code>x5d</code> 无法通过编译。</p> 
<blockquote> 
 <p>这里特别解释一下 <code>int&amp;&amp; f();</code> 和 <code>auto x3a = f();</code> 这里使用了<strong>引用折叠</strong>（Reference Collapsing）：<br><br> 当<code>auto</code>用于推导函数的返回值类型时，它会忽略引用限定符（<code>&amp;</code>和<code>&amp;&amp;</code>），并将其结果类型视为一个普通的对象类型。这意味着无论函数<code>f</code>返回的是左值引用还是右值引用，<code>auto</code>都会推导它为对象类型。<br><br> 在上面代码中，<code>f()</code> 返回一个右值引用 <code>int&amp;&amp;</code>，但由于<code>auto</code>会忽略引用限定符，所以<code>auto x3a</code> 的类型被推导为 <code>int</code> 而不是 <code>int&amp;&amp;</code>。<br><br> 而对于 <code>decltype(auto) x3d = f();</code>这一行使用了 <code>decltype(auto)</code>，它不是一个类型推导，而是根据初始化表达式的类型来推导变量的类型。在这里，<code>x3d</code> 的类型将根据表达式 <code>f()</code> 的类型来推导。因为 <code>f()</code> 返回一个右值引用，所以 <code>x3d</code> 的类型也会成为右值引用，即 <code>int&amp;&amp;</code>。这就是为什么 <code>x3d</code> 的类型被推导为 <code>int&amp;&amp;</code>。<br><br> <strong>总结：<code>auto</code> 在类型推导时会忽略引用，但<code>decltype(auto)</code> 会保留引用类型。因此，<code>x3a</code> 的类型是 <code>int</code>，而 <code>x3d</code> 的类型是 <code>int&amp;&amp;</code>，这符合函数 <code>f()</code> 返回值的类型。</strong></p> 
</blockquote> 
<p>接下来让我们看一看 <code>decltype(auto)</code> 是如何发挥作用的。还记得 <code>decltype</code> 不可被 <code>auto</code> 代替的例子吗？<code>return_ref</code> 想返回一个引用类型，但是如果直接使用 <code>auto</code>，则一定会返回一个值类型。这让我们不得不采用返回类型后置的方式声明返回类型。</p> 
<p>现在有了<code>decltype(auto)</code>组合，我们可以进一步简化代码，消除返回类型后置的语法，例如：</p> 
<pre><code class="prism language-cpp"><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">T</span><span class="token operator">&gt;</span>
<span class="token keyword">decltype</span><span class="token punctuation">(</span><span class="token keyword">auto</span><span class="token punctuation">)</span> <span class="token function">return_ref</span><span class="token punctuation">(</span>T<span class="token operator">&amp;</span> t<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
    <span class="token keyword">return</span> t<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">int</span> x1 <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token keyword">static_assert</span><span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span>is_reference_v<span class="token operator">&lt;</span><span class="token keyword">decltype</span><span class="token punctuation">(</span><span class="token function">return_ref</span><span class="token punctuation">(</span>x1<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token operator">&gt;</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 编译成功</span>
</code></pre> 
<h3><a id="6_decltypeauto__957"></a>6. decltype(auto) 作为非类型模板形参占位符</h3> 
<p>与<code>auto</code>一样，在C++17标准中<code>decltype(auto)</code>也能作为非类型模板形参的占位符，其推导规则和上面介绍的保持一致，例如：</p> 
<pre><code class="prism language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream&gt;</span></span>
<span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">decltype</span><span class="token punctuation">(</span><span class="token keyword">auto</span><span class="token punctuation">)</span> N<span class="token operator">&gt;</span>
<span class="token keyword">void</span> <span class="token function">f</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> N <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">static</span> <span class="token keyword">const</span> <span class="token keyword">int</span> x <span class="token operator">=</span> <span class="token number">11</span><span class="token punctuation">;</span>
<span class="token keyword">static</span> <span class="token keyword">int</span> y <span class="token operator">=</span> <span class="token number">7</span><span class="token punctuation">;</span>
<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token generic-function"><span class="token function">f</span><span class="token generic class-name"><span class="token operator">&lt;</span>x<span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment">// N 为 const int 类型</span>
	<span class="token generic-function"><span class="token function">f</span><span class="token generic class-name"><span class="token operator">&lt;</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// N 为 const int&amp; 类型</span>
	<span class="token generic-function"><span class="token function">f</span><span class="token generic class-name"><span class="token operator">&lt;</span>y<span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment">// 编译错误</span>
	<span class="token generic-function"><span class="token function">f</span><span class="token generic class-name"><span class="token operator">&lt;</span><span class="token punctuation">(</span>y<span class="token punctuation">)</span><span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// N 为 int&amp; 类型</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>在上面的代码中，<code>x</code> 的类型为 <code>const int</code>，所以 <code>f&lt;x&gt;()</code> 推导出 <code>N</code> 为 <code>const int</code> 类型，这里和 <code>auto</code> 作为占位符的结果是一样的；<code>f&lt;(x)&gt;()</code> 则不同，推导出的 <code>N</code> 为 <code>const int&amp;</code> 类型，符合 <code>decltype(auto)</code> 的推导规则。另外，<code>f&lt;y&gt;()</code> 会导致编译出错，因为 <code>y</code> 不是一个常量，所以编译器无法对函数模板进行实例化。而 <code>f&lt;(y)&gt;()</code> 则没有这种问题，因为 <code>(y)</code> 被推断为引用类型，恰好对于静态对象而言内存地址是固定的，所以可以顺利地通过编译，最终 <code>N</code> 被推导为 <code>int&amp;</code> 类型。</p> 
<h3><a id="_980"></a>总结</h3> 
<p><code>decltype</code> 和 <code>auto</code> 的使用方式有一些相似之处，但是推导规则却有所不同，理解起来有一定难度。不过幸运的是，大部分情况下推导结果能够符合我们的预期。另外从上面的示例代码来看，在通常的编程过程中并不会存在太多使用 <code>decltype</code> 的情况。实际上， <code>decltype</code> 说明符对于库作者更加实用。因为它很大程度上加强了C++的泛型能力，比如利用 <code>decltype</code> 和 <code>SFINAE</code> 特性让编译器自动选择正确的函数模板进行调用等，当然这些是比较高级的话题了，有兴趣的读者可以提前翻阅第40章的内容。</p> 
<h2><a id="C11_984"></a>五、函数返回类型后置（C++11）</h2> 
<h3><a id="1__986"></a>1. 使用函数返回类型后置声明函数</h3> 
<p>前面已经出现了函数返回类型后置的例子，接下来我们将详细讨论C++11标准中的新语法特性：</p> 
<pre><code class="prism language-cpp"><span class="token keyword">auto</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">-&gt;</span><span class="token keyword">int</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token keyword">return</span> <span class="token number">42</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>以上代码中的函数声明等同于 <code>int foo()</code>，只不过采用了函数返回类型后置的方法，其中 <code>auto</code> 是一个占位符，函数名后 <code>-&gt;</code> 紧跟的 <code>int</code> 才是真正的返回类型。当然，在这个例子中传统的函数声明方式更加简洁。而在返回类型比较复杂的时候，比如返回一个函数指针类型，返回类型后置可能会是一个不错的选择，例如：</p> 
<pre><code class="prism language-cpp"><span class="token keyword">int</span> <span class="token function">bar_impl</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token keyword">return</span> x<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">typedef</span> <span class="token keyword">int</span><span class="token punctuation">(</span><span class="token operator">*</span>bar<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
bar <span class="token function">foo1</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token keyword">return</span> bar_impl<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">auto</span> <span class="token function">foo2</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">-&gt;</span><span class="token keyword">int</span><span class="token punctuation">(</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token keyword">return</span> bar_impl<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
	<span class="token keyword">auto</span> func <span class="token operator">=</span> <span class="token function">foo2</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token function">func</span><span class="token punctuation">(</span><span class="token number">58</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>在上面的代码中，函数 <code>foo2</code> 的返回类型不再是简单的 <code>int</code> 而是函数指针类型。使用传统函数声明语法的 <code>foo1</code> 无法将函数指针类型作为返回类型直接使用，所以需要使用 <code>typedef</code> 给函数指针类型创建别名 <code>bar</code>，再使用别名作为函数 <code>foo1</code> 的返回类型。而使用函数返回类型后置语法的 <code>foo2</code> 则没有这个问题。同样，<code>auto</code> 作为返回类型占位符，在 <code>-&gt;</code> 后声明返回的函数指针类型 <code>int(*)(int)</code> 即可。</p> 
<h3><a id="2__1023"></a>2. 推导函数模板返回类型</h3> 
<p>C++11标准中函数返回类型后置的作用之一是推导函数模板的返回类型，当然前提是需要用到<code>decltype</code>说明符，例如：</p> 
<pre><code class="prism language-cpp"><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">T1</span><span class="token punctuation">,</span> <span class="token keyword">class</span> <span class="token class-name">T2</span><span class="token operator">&gt;</span>
<span class="token keyword">auto</span> <span class="token function">sum1</span><span class="token punctuation">(</span>T1 t1<span class="token punctuation">,</span> T2 t2<span class="token punctuation">)</span><span class="token operator">-&gt;</span><span class="token keyword">decltype</span><span class="token punctuation">(</span>t1 <span class="token operator">+</span> t2<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token keyword">return</span> t1 <span class="token operator">+</span> t2<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
	<span class="token keyword">auto</span> x1 <span class="token operator">=</span> <span class="token function">sum1</span><span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>在上面的代码中，函数模板 <code>sum1</code> 有两个模板形参 <code>T1</code> 和 <code>T2</code>，它们分别是函数形参 <code>t1</code> 和 <code>t2</code> 的类型。为了让 <code>sum1</code> 函数的返回类型由实参自动推导，这里需要使用函数返回类型后置来指定 <code>decltype</code> 说明符推导类型作为函数的返回类型。</p> 
<p>请注意，<code>decltype(t1 + t2)</code> 不能写在函数声明前，编译器在解析返回类型的时候还没解析到参数部分，所以它对 <code>t1</code> 和 <code>t2</code> 一无所知，自然会编译失败：</p> 
<pre><code class="prism language-cpp"><span class="token keyword">decltype</span><span class="token punctuation">(</span>t1 <span class="token operator">+</span> t2<span class="token punctuation">)</span> <span class="token keyword">auto</span> <span class="token function">sum1</span><span class="token punctuation">(</span>T1 t1<span class="token punctuation">,</span> T2 t2<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>…<span class="token punctuation">}</span> <span class="token comment">// 编译失败，无法识别 t1 和 t2</span>
</code></pre> 
<p>实际上，在C++11标准中只用<code>decltype</code>关键字也能写出自动推导返回类型的函数模板，但是函数可读性却差了很多，以下是最容易理解的写法：</p> 
<pre><code class="prism language-cpp"><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">T1</span><span class="token punctuation">,</span> <span class="token keyword">class</span> <span class="token class-name">T2</span><span class="token operator">&gt;</span>
<span class="token keyword">decltype</span><span class="token punctuation">(</span><span class="token function">T1</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token function">T2</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token function">sum2</span><span class="token punctuation">(</span>T1 t1<span class="token punctuation">,</span> T2 t2<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token keyword">return</span> t1 <span class="token operator">+</span> t2<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
	<span class="token function">sum2</span><span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>以上代码使用 <code>decltype(T1()+T2())</code> 让编译器为我们推导函数的返回类型，其中 <code>T1()+T2()</code> 表达式告诉编译器应该推导 <code>T1</code> 类型对象与 <code>T2</code> 类型对象之和的对象类型。但是这种写法并不通用，它存在一个潜在问<br> 题，由于 <code>T1() + T2()</code> 表达式使用了 <code>T1</code> 和 <code>T2</code> 类型的<strong>默认构造函数</strong>，因此编译器要求 <code>T1</code> 和 <code>T2</code> 的<strong>默认构造函数必须存在，否则会编译失败</strong>，比如：</p> 
<pre><code class="prism language-cpp"><span class="token keyword">class</span> <span class="token class-name">IntWrap</span> <span class="token punctuation">{<!-- --></span>
<span class="token keyword">public</span><span class="token operator">:</span>
    <span class="token function">IntWrap</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token function">n_</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span><span class="token punctuation">}</span>
    IntWrap <span class="token keyword">operator</span><span class="token operator">+</span> <span class="token punctuation">(</span><span class="token keyword">const</span> IntWrap<span class="token operator">&amp;</span> other<span class="token punctuation">)</span>
    <span class="token punctuation">{<!-- --></span>
        <span class="token keyword">return</span> <span class="token function">IntWrap</span><span class="token punctuation">(</span>n_ <span class="token operator">+</span> other<span class="token punctuation">.</span>n_<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token keyword">private</span><span class="token operator">:</span>
    <span class="token keyword">int</span> n_<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    <span class="token function">sum2</span><span class="token punctuation">(</span><span class="token function">IntWrap</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">IntWrap</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 编译失败，IntWrap 没有默认构造函数</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>虽然编译器在推导表达式类型的时候并没有真正计算表达式，但是会检查表达式是否正确，所以在推导 <code>IntWrap() + IntWrap()</code> 时会报错。为了解决这个问题，需要既可以在表达式中让 <code>T1</code> 和 <code>T2</code> 两个对象求和，又不用使用其构造函数方法，于是就有了以下两个函数模板：</p> 
<pre><code class="prism language-cpp"><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">T1</span><span class="token punctuation">,</span> <span class="token keyword">class</span> <span class="token class-name">T2</span><span class="token operator">&gt;</span>
<span class="token keyword">decltype</span><span class="token punctuation">(</span><span class="token operator">*</span><span class="token generic-function"><span class="token function">static_cast</span><span class="token generic class-name"><span class="token operator">&lt;</span>T1 <span class="token operator">*</span><span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span><span class="token keyword">nullptr</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token operator">*</span><span class="token generic-function"><span class="token function">static_cast</span><span class="token generic class-name"><span class="token operator">&lt;</span>T2 <span class="token operator">*</span><span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span><span class="token keyword">nullptr</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token function">sum3</span><span class="token punctuation">(</span>T1 t1<span class="token punctuation">,</span> T2 t2<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token keyword">return</span> t1 <span class="token operator">+</span> t2<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">T</span><span class="token operator">&gt;</span>
T<span class="token operator">&amp;&amp;</span> <span class="token function">declval</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">T1</span><span class="token punctuation">,</span> <span class="token keyword">class</span> <span class="token class-name">T2</span><span class="token operator">&gt;</span>
<span class="token keyword">decltype</span><span class="token punctuation">(</span><span class="token generic-function"><span class="token function">declval</span><span class="token generic class-name"><span class="token operator">&lt;</span>T1<span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token generic-function"><span class="token function">declval</span><span class="token generic class-name"><span class="token operator">&lt;</span>T2<span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token function">sum4</span><span class="token punctuation">(</span>T1 t1<span class="token punctuation">,</span> T2 t2<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token keyword">return</span> t1 <span class="token operator">+</span> t2<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
	<span class="token function">sum3</span><span class="token punctuation">(</span><span class="token function">IntWrap</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">IntWrap</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token function">sum4</span><span class="token punctuation">(</span><span class="token function">IntWrap</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">IntWrap</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>在上面的代码中，函数模板 <code>sum3</code> 使用指针类型转换和解引用求和的方法推导返回值，其中 <code>*static_cast&lt;T1*&gt;(nullptr) + *static_cast&lt;T2*&gt;(nullptr)</code> 分别将 <code>nullptr</code> 转换为 <code>T1</code> 和 <code>T2</code> 的指针类型，然后解引用求和，最后利用 <code>decltype</code> 推导出求和后的对象类型。由于编译器不会真的计算求值，因此这里求和操作不会有问题。</p> 
<p>函数模板 <code>sum4</code> 利用了另外一个技巧，与 <code>sum3</code> 本质上相似。在标准库中提供了一个 <code>std::declval</code> 函数模板声明（没有具体实现），它将类型 <code>T</code> 转换成引用类型，这样在使用 <code>decltype</code> 推导表达式类型时不必经过构造函数检查。由于标准库中 <code>std::declval</code> 的实现比较复杂，因此我在这里实现了一个简化版本。<code>declval&lt;T1&gt;() + declval&lt;T2&gt;()</code> 表达式分别通过 <code>declval</code> 将 <code>T1</code> 和 <code>T2</code> 转换为引用类型并且求和，最后通过 <code>decltype</code> 推导返回类型。</p> 
<p>可以看出，虽然这两种方法都能达到函数返回类型后置的效果，但是它们在实现上更加复杂，同时要理解它们也必须有一定的模板元编程的知识。为了让代码更容易被其他人阅读和理解，还是建议使用函数返回类型后置的方法来推导返回类型。</p> 
<h3><a id="_1107"></a>总结</h3> 
<p>本章介绍了<strong>C++11</strong>标准中的函数返回类型后置语法，通过这种方法可以让返回复杂类型的函数声明更加清晰易读。在无法使用<strong>C++14</strong>以及更新标准的情况下，通过返回类型后置语法来推导函数模板的返回类型无疑是最便捷的方法。</p> 
<h2><a id="C11_C17_C20_1111"></a>六、右值引用（C++11 C++17 C++20）</h2> 
<h3><a id="1__1113"></a>1. 左值和右值</h3> 
<p>左值和右值的概念早在C++98的时候就已经出现了，从最简单的字面理解，无非是表达式等号左边的值为左值，而表达式右边的值为右值，比如：</p> 
<pre><code class="prism language-cpp"><span class="token keyword">int</span> x <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
<span class="token keyword">int</span> y <span class="token operator">=</span> <span class="token number">3</span><span class="token punctuation">;</span>
<span class="token keyword">int</span> z <span class="token operator">=</span> x <span class="token operator">+</span> y<span class="token punctuation">;</span>
</code></pre> 
<p>以上面的代码为例，<code>x</code> 是左值，<code>1</code> 是右值；<code>y</code> 是左值，<code>3</code> 是右值；<code>z</code> 是左值，<code>x + y</code> 的结果是右值。用表达式等号左右的标准区分左值和右值虽然在一些场景下确实能得到正确结果，但是还是过于简单，有些情况下是无法准确区分左值和右值的，比如：</p> 
<pre><code class="prism language-cpp"><span class="token keyword">int</span> a <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
<span class="token keyword">int</span> b <span class="token operator">=</span> a<span class="token punctuation">;</span>
</code></pre> 
<p>按照表达式等号左右的区分方式，在第一行代码中<code>a</code> 是左值，<code>1</code> 是右值；在第二行代码中 <code>b</code> 是左值，而 <code>a</code> 是右值。这里出现了矛盾，在第一行代码中我们判断 <code>a</code> 是一个左值，它却在第二行变成了右值，很明显这不是我们想要的结果，要准确地区分左值和右值还是应该理解其内在含义。</p> 
<p>在C++中所谓的<strong>左值一般是指一个指向特定内存的具有名称的值（具名对象）</strong>，<strong>它有一个相对稳定的内存地址，并且有一段较长的生命周期</strong>。而<strong>右值则是不指向稳定内存地址的匿名值（不具名对象），它的生命周期很短，通常是暂时性的</strong>。基于这一特征，我们可以<strong>用取地址符<code>&amp;</code>来判断左值和右值，能取到内存地址的值为左值，否则为右值</strong>。还是以上面的代码为例，因为<code>&amp;a</code>和<code>&amp;b</code>都是符合语法规则的，所以<code>a</code>和<code>b</code>都是左值，而<code>&amp;1</code>在GCC中会给出“<code>lvalue required as unary '&amp;' operand</code>”错误信息以提示程序员<code>&amp;</code>运算符需要的是一个左值。</p> 
<p>上面的代码在左右值的判断上比较简单，但是并非所有的情况都是如此，下面这些情况左值和右值的判断可能是违反直觉的，例如：</p> 
<pre><code class="prism language-cpp"><span class="token keyword">int</span> x <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
<span class="token keyword">int</span> <span class="token function">get_val</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token keyword">return</span> x<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">void</span> <span class="token function">set_val</span><span class="token punctuation">(</span><span class="token keyword">int</span> val<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	x <span class="token operator">=</span> val<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	x<span class="token operator">++</span><span class="token punctuation">;</span>
	<span class="token operator">++</span>x<span class="token punctuation">;</span>
	<span class="token keyword">int</span> y <span class="token operator">=</span> <span class="token function">get_val</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token function">set_val</span><span class="token punctuation">(</span><span class="token number">6</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>在上面的代码中，<code>x++</code>和<code>++x</code>虽然都是自增操作，但是却分为不同的左右值。其中 <strong><code>x++</code> 是右值</strong>，因为在后置<code>++</code>操作中编译器首先会生成一份<code>x</code>值的临时副本，然后才对<code>x</code>递增，最后返回临时副本内容。而<code>++x</code>则不同，它是直接对<code>x</code>递增后马上返回其自身，所以 <strong><code>++x</code> 是一个左值</strong>。如果对它们实施取地址操作，就会发现<code>++x</code>的取地址操作可以编译成功，而对<code>x++</code>取地址则会报错。但是从直觉上来说，<code>&amp;x++</code>看起来更像是会编译成功的一方：</p> 
<pre><code class="prism language-cpp"><span class="token keyword">int</span> <span class="token operator">*</span>p <span class="token operator">=</span> <span class="token operator">&amp;</span>x<span class="token operator">++</span><span class="token punctuation">;</span> <span class="token comment">// 编译失败</span>
<span class="token keyword">int</span> <span class="token operator">*</span>q <span class="token operator">=</span> <span class="token operator">&amp;</span><span class="token operator">++</span>x<span class="token punctuation">;</span> <span class="token comment">// 编译成功</span>
</code></pre> 
<p>接着来看上一份代码中的<code>get_val</code>函数，该函数返回了一个全局变量<code>x</code>，虽然很明显变量<code>x</code>是一个左值，但是它经过函数返回以后变成了一个右值。原因和<code>x++</code>类似，在函数返回的时候编译器并不会返回<code>x</code>本身，而是返回<code>x</code>的临时复制，所以<code>int * p = &amp;get_val();</code>也会编译失败。</p> 
<pre><code class="prism language-cpp"><span class="token keyword">int</span> <span class="token operator">*</span>p <span class="token operator">=</span> <span class="token operator">&amp;</span><span class="token function">get_val</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 编译失败，不能取到地址</span>
</code></pre> 
<p>对于<code>set_val</code>函数，该函数接受一个参数并且将参数的值赋值到<code>x</code>中。在<code>main</code>函数中<code>set_val(6);</code>实参<code>6</code>是一个右值，但是进入函数之后形参<code>val</code>却变成了一个左值，我们可以对<code>val</code>使用取地址符，并且不会引起任何问题：</p> 
<pre><code class="prism language-cpp"><span class="token keyword">void</span> <span class="token function">set_val</span><span class="token punctuation">(</span><span class="token keyword">int</span> val<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
    <span class="token keyword">int</span> <span class="token operator">*</span>p <span class="token operator">=</span> <span class="token operator">&amp;</span>val<span class="token punctuation">;</span>
	x <span class="token operator">=</span> val<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>最后需要强调的是，<strong>通常字面量都是一个右值，但除了字符串字面量以外</strong>：</p> 
<pre><code class="prism language-cpp"><span class="token keyword">int</span> x <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
<span class="token function">set_val</span><span class="token punctuation">(</span><span class="token number">6</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">auto</span> p <span class="token operator">=</span> <span class="token operator">&amp;</span><span class="token string">"hello world"</span><span class="token punctuation">;</span>
</code></pre> 
<p>这一点非常容易被忽略，因为经验告诉我们上面的代码中前两行的 <code>1</code> 和 <code>6</code> 都是右值，因为不存在 <code>&amp;1</code> 和 <code>&amp;6</code> 的语法，这会让我们想当然地认为 <code>"hello world"</code> 也是一个右值，毕竟 <code>&amp;"hello world"</code> 的语法也很少看到。但是这段代码是可以编译成功的，其实原因仔细想来也很简单，编译器会将字符串字面量存储到程序的数据段中，程序加载的时候也会为其开辟内存空间，所以我们可以使用取地址符 <code>&amp;</code> 来获取字符串字面量的内存地址。</p> 
<h3><a id="2__1183"></a>2. 左值引用</h3> 
<p>左值引用是编程过程中的常用特性之一，它的出现让C++编程在一定程度上脱离了危险的指针。当我们需要将一个对象作为参数传递给子函数的时候，往往会使用左值引用，因为这样可以免去创建临时对象的<br> 操作。非常量左值的引用对象很单纯，它们必须是一个左值。</p> 
<p>例如常见的一个例子是下面代码中使用左值引用来交换两个变量的值：</p> 
<pre><code class="prism language-cpp"><span class="token keyword">void</span> <span class="token function">swap</span><span class="token punctuation">(</span><span class="token keyword">int</span> <span class="token operator">&amp;</span>a<span class="token punctuation">,</span> <span class="token keyword">int</span> <span class="token operator">&amp;</span>b<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    <span class="token keyword">int</span> temp <span class="token operator">=</span> a<span class="token punctuation">;</span>
    a <span class="token operator">=</span> b<span class="token punctuation">;</span>
    b <span class="token operator">=</span> temp<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>对于这一点，<strong>常量左值引用</strong>的特性显得更加有趣，它除了能<strong>引用左值</strong>，还能够<strong>引用右值</strong>，比如：</p> 
<pre><code class="prism language-cpp"><span class="token keyword">int</span> a <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span>
<span class="token keyword">int</span> <span class="token operator">&amp;</span>x1 <span class="token operator">=</span> a<span class="token punctuation">;</span>       
<span class="token keyword">int</span> <span class="token operator">&amp;</span>x1 <span class="token operator">=</span> <span class="token number">7</span><span class="token punctuation">;</span>       <span class="token comment">// 编译错误</span>
<span class="token keyword">const</span> <span class="token keyword">int</span> <span class="token operator">&amp;</span>x <span class="token operator">=</span> <span class="token number">11</span><span class="token punctuation">;</span> <span class="token comment">// 编译成功</span>
<span class="token keyword">const</span> <span class="token keyword">int</span> <span class="token operator">&amp;</span>x <span class="token operator">=</span> a<span class="token punctuation">;</span>   
</code></pre> 
<p>在上面的代码中，<code>int &amp;x1 = 7;</code>代码会编译报错，因为 <code>int&amp;</code> 无法绑定一个 <code>int</code> 类型的右值，但是<code>const int &amp;x = 11</code>却可以编译成功。请注意，虽然在结果上 <code>const int &amp;x = 11</code> 和 <code>const int x = 11</code> 是一样的，但是从语法上来说，前者是被引用了，所以语句结束后 <code>11</code> 的生命周期被延长，而后者当语句结束后右值 <code>11</code> 应该被销毁。</p> 
<p>虽然常量左值引用可以引用右值的这个特性在赋值表达式中看不出什么实用价值，但是在<strong>函数形参列表</strong>中却有着巨大的作用。一个典型的例子就是<strong>复制构造函数</strong>和<strong>复制赋值运算符函数</strong>，通常情况下我们实现的这两个函数的形参都是一个<strong>常量左值引用</strong>，例如：</p> 
<pre><code class="prism language-cpp"><span class="token keyword">class</span> <span class="token class-name">X</span> <span class="token punctuation">{<!-- --></span>
<span class="token keyword">public</span><span class="token operator">:</span>
	<span class="token function">X</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span><span class="token punctuation">}</span>
	<span class="token function">X</span><span class="token punctuation">(</span><span class="token keyword">const</span> X<span class="token operator">&amp;</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span><span class="token punctuation">}</span>
	X<span class="token operator">&amp;</span> <span class="token keyword">operator</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">const</span> X<span class="token operator">&amp;</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span> <span class="token keyword">return</span> <span class="token operator">*</span><span class="token keyword">this</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

X <span class="token function">make_x</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token keyword">return</span> <span class="token function">X</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> 
<span class="token punctuation">{<!-- --></span>
	X x1<span class="token punctuation">;</span>
	X <span class="token function">x2</span><span class="token punctuation">(</span>x1<span class="token punctuation">)</span><span class="token punctuation">;</span>
	X <span class="token function">x3</span><span class="token punctuation">(</span><span class="token function">make_x</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	x3 <span class="token operator">=</span> <span class="token function">make_x</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>以上代码可以通过编译，但是如果这里将类 <code>X</code> 的复制构造函数和复制赋值函数形参类型的常量修饰 <code>const</code> 删除，则 <code>X x3(make_x());</code> 和 <code>x3 = make_x();</code> 这两句代码会编译报错，因为非常量左值引用无法绑定到 <code>make_x()</code> 产生的右值。常量左值引用可以绑定右值是一条非常棒的特性，但是它也存在一个很大的缺点——<strong>常量性</strong>。一旦使用了常量左值引用，就表示我们无法在函数内修改该对象的内容（强制类型转换除外）。所以需要另外一个特性来帮助我们完成这项工作，它就是右值引用。</p> 
<blockquote> 
 <p>注意，上面代码中去掉 <code>const</code> 常量修饰符以后， <code>X x3(make_x());</code> 以及 <code>make_x()</code> 函数中在 C++ 17 以前编译会报错，但是从 C++ 17 开始对拷贝构造函数做了优化，所以如果是使用C++ 17及以上版本不会报错。但是 <code>x3 = make_x();</code>这句不管是现在还是以前的版本都会报错。</p> 
</blockquote> 
<h3><a id="3__1236"></a>3. 右值引用</h3> 
<p>顾名思义，<strong>右值引用是一种引用右值且只能引用右值的方法</strong>。在语法方面右值引用可以对比左值引用，在左值引用声明中，需要在类型后添加<code>&amp;</code>，而右值引用则是在类型后添加<code>&amp;&amp;</code>，例如：</p> 
<pre><code class="prism language-cpp"><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token keyword">int</span> <span class="token operator">&amp;</span>j <span class="token operator">=</span> i<span class="token punctuation">;</span>   <span class="token comment">// 左值引用</span>
<span class="token keyword">int</span> <span class="token operator">&amp;&amp;</span>k <span class="token operator">=</span> <span class="token number">11</span><span class="token punctuation">;</span> <span class="token comment">// 右值引用</span>
</code></pre> 
<p>在上面的代码中，<code>k</code> 是一个右值引用，如果试图用 <code>k</code> 引用变量 <code>i</code>，则会引起编译错误。</p> 
<pre><code class="prism language-cpp"><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token keyword">int</span> <span class="token operator">&amp;&amp;</span>k <span class="token operator">=</span> i<span class="token punctuation">;</span> <span class="token comment">// 编译报错，右值引用无法引用左值 i</span>
</code></pre> 
<p>右值引用的特点之一是可以延长右值的生命周期，这个对于字面量 <code>11</code> 可能看不出效果，那么请看下面的例子：</p> 
<pre><code class="prism language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream&gt;</span></span>

<span class="token keyword">class</span> <span class="token class-name">X</span> <span class="token punctuation">{<!-- --></span>
<span class="token keyword">public</span><span class="token operator">:</span>
	<span class="token function">X</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span> std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"X ctor"</span> <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span> <span class="token punctuation">}</span>
	<span class="token function">X</span><span class="token punctuation">(</span><span class="token keyword">const</span> X<span class="token operator">&amp;</span>x<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span> std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"X copy ctor"</span> <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span> <span class="token punctuation">}</span>
	<span class="token operator">~</span><span class="token function">X</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span> std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"X dtor"</span> <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span> <span class="token punctuation">}</span>
	<span class="token keyword">void</span> <span class="token function">show</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span> std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"show X"</span> <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span> <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

X <span class="token function">make_x</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	X x1<span class="token punctuation">;</span>
	<span class="token keyword">return</span> x1<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	X <span class="token operator">&amp;&amp;</span>x2 <span class="token operator">=</span> <span class="token function">make_x</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token comment">// X x2 = make_x()</span>
	x2<span class="token punctuation">.</span><span class="token function">show</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>在理解这段代码之前，让我们想一下如果将 <code>X &amp;&amp;x2 = make_x()</code> 这句代码替换为 <code>X x2 = make_x()</code> 会发生几次构造。在没有进行任何优化的情况下应该是 3 次构造，首先 <code>make_x</code> 函数中 <code>x1</code> 会默认构造一次，然后 <code>return x1</code> 会使用复制构造产生临时对象，接着 <code>X x2 = make_x()</code> 会使用复制构造将临时对象复制到 <code>x2</code>，最后临时对象被销毁。所以使用 <code>X x2 = make_x()</code> 应该期望的输出是下面这样：</p> 
<pre><code class="prism language-cpp">X ctor
X copy ctor
X dtor
X copy ctor
X dtor
show X
X dtor
</code></pre> 
<p>在使用了右值引用以后，以上流程发生了微妙的变化，让我们编译运行这段代码。输出结果：</p> 
<pre><code class="prism language-cpp">X ctor
X copy ctor
X dtor
show X
X dtor
</code></pre> 
<blockquote> 
 <p>请注意，用GCC编译以上代码需要加上命令行参数 <code>-fno-elide-constructors</code> 用于关闭函数返回值优化（RVO）。因为GCC的 RVO 优化会减少复制构造函数的调用，不利于语言特性实验。</p> 
</blockquote> 
<p>从运行结果可以看出上面的代码只发生了两次构造。第一次是 <code>make_x</code> 函数中 <code>x1</code> 的默认构造，第二次是 <code>return x1</code> 引发的复制构造。不同的是，由于 <code>x2</code> 是一个右值引用，引用的对象是函数 <code>make_x</code> 返回的临时对象，因此该临时对象的生命周期得到延长，所以我们可以在 <code>X &amp;&amp;x2 = make_x()</code> 语句结束后继续调用 <code>show</code> 函数而不会发生任何问题。对性能敏感的读者应该注意到了，延长临时对象生命周期并不是这里右值引用的最终目标，其真实目标应该是<strong>减少对象复制，提升程序性能</strong>。</p> 
<p>PS：如果使用 CLion 可以在 <code>CMakeLists.txt</code> 中添加如下代码禁用编译器优化：</p> 
<pre><code class="prism language-c"># 禁用函数返回值优化（RVO）
<span class="token function">set</span><span class="token punctuation">(</span>CMAKE_CXX_FLAGS <span class="token string">"-fno-elide-constructors"</span><span class="token punctuation">)</span>

# 如何添加每个带main函数的cpp文件为可执行文件
<span class="token function">file</span><span class="token punctuation">(</span>GLOB files <span class="token string">"${CMAKE_CURRENT_SOURCE_DIR}/*.cpp"</span><span class="token punctuation">)</span>

<span class="token function">foreach</span> <span class="token punctuation">(</span>file $<span class="token punctuation">{<!-- --></span>files<span class="token punctuation">}</span><span class="token punctuation">)</span>
    <span class="token function">get_filename_component</span><span class="token punctuation">(</span>name $<span class="token punctuation">{<!-- --></span>file<span class="token punctuation">}</span> NAME_WE<span class="token punctuation">)</span> # 使用NAME_WE以去掉文件扩展名
    <span class="token function">add_executable</span><span class="token punctuation">(</span>$<span class="token punctuation">{<!-- --></span>name<span class="token punctuation">}</span> $<span class="token punctuation">{<!-- --></span>file<span class="token punctuation">}</span><span class="token punctuation">)</span>
<span class="token function">endforeach</span> <span class="token punctuation">(</span><span class="token punctuation">)</span>
</code></pre> 
<blockquote> 
 <p>但是我实际使用的时候，发现添加了也不起作用，仍然会被优化，也就是说 <code>X x2 = make_x()</code> 和 <code>X &amp;&amp;x2 = make_x()</code> 的执行结果是一样的，不知道为什么。</p> 
</blockquote> 
<p>如果不加上面的禁用参数，输出如下：</p> 
<pre><code class="prism language-cpp">X ctor
show X
X dtor
</code></pre> 
<p>可见现代的C++编译器都很聪明，都会直接优化去掉拷贝构造函数的调用。</p> 
<h3><a id="4__1332"></a>4. 右值的性能优化空间</h3> 
<p>通过前面的介绍我们知道了很多情况下右值都存储在临时对象中，当右值被使用之后程序会马上销毁对象并释放内存。这个过程可能会引发一个性能问题，例如：</p> 
<pre><code class="prism language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream&gt;</span></span>
<span class="token keyword">class</span> <span class="token class-name">BigMemoryPool</span> <span class="token punctuation">{<!-- --></span>
<span class="token keyword">public</span><span class="token operator">:</span>
	<span class="token keyword">static</span> <span class="token keyword">const</span> <span class="token keyword">int</span> PoolSize <span class="token operator">=</span> <span class="token number">4096</span><span class="token punctuation">;</span>
	<span class="token function">BigMemoryPool</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token function">pool_</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token keyword">char</span><span class="token punctuation">[</span>PoolSize<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span><span class="token punctuation">}</span>
	<span class="token operator">~</span><span class="token function">BigMemoryPool</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
	<span class="token punctuation">{<!-- --></span>
		<span class="token keyword">if</span> <span class="token punctuation">(</span>pool_ <span class="token operator">!=</span> <span class="token keyword">nullptr</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
			<span class="token keyword">delete</span><span class="token punctuation">[</span><span class="token punctuation">]</span> pool_<span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
	<span class="token punctuation">}</span>

	<span class="token function">BigMemoryPool</span><span class="token punctuation">(</span><span class="token keyword">const</span> BigMemoryPool<span class="token operator">&amp;</span> other<span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token function">pool_</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token keyword">char</span><span class="token punctuation">[</span>PoolSize<span class="token punctuation">]</span><span class="token punctuation">)</span>
	<span class="token punctuation">{<!-- --></span>
		std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"copy big memory pool."</span> <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span>
		<span class="token function">memcpy</span><span class="token punctuation">(</span>pool_<span class="token punctuation">,</span> other<span class="token punctuation">.</span>pool_<span class="token punctuation">,</span> PoolSize<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>

<span class="token keyword">private</span><span class="token operator">:</span>
	<span class="token keyword">char</span> <span class="token operator">*</span>pool_<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

BigMemoryPool <span class="token function">get_pool</span><span class="token punctuation">(</span><span class="token keyword">const</span> BigMemoryPool<span class="token operator">&amp;</span> pool<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token keyword">return</span> pool<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

BigMemoryPool <span class="token function">make_pool</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	BigMemoryPool pool<span class="token punctuation">;</span>
	<span class="token keyword">return</span> <span class="token function">get_pool</span><span class="token punctuation">(</span>pool<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	BigMemoryPool my_pool <span class="token operator">=</span> <span class="token function">make_pool</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>以上代码同样需要加上编译参数<code>-fno-elide-constructors</code>，编译运行程序会在屏幕上输出字符串：</p> 
<pre><code class="prism language-cpp">copy big memory pool<span class="token punctuation">.</span>
copy big memory pool<span class="token punctuation">.</span>
copy big memory pool<span class="token punctuation">.</span>
</code></pre> 
<p>可以看到 <code>BigMemoryPool my_pool = make_pool();</code> 调用了 3 次复制构造函数。</p> 
<ol><li><code>get_pool</code> 函数中返回的 <code>BigMemoryPool</code> 临时对象调用复制构造函数复制了 <code>pool</code> 对象。</li><li><code>make_pool</code> 函数中返回的 <code>BigMemoryPool</code> 临时对象调用复制构造函数复制了 <code>get_pool</code> 返回的临时对象。</li><li><code>main</code> 函数中 <code>my_pool</code> 调用其复制构造函数复制 <code>make_pool</code> 返回的临时对象。</li></ol> 
<p>该代码从正确性上看毫无问题，但是从运行性能的角度上看却还有巨大的优化空间。在这里每发生一次复制构造都会复制整整<code>4KB</code>的数据，如果数据量更大一些，比如<code>4MB</code>或者<code>400MB</code>，那么将对程序性能造成很大影响。</p> 
<h3><a id="5__1392"></a>5. 移动语义</h3> 
<p>仔细分析上面代码中 3 次复制构造函数的调用，不难发现第二次和第三次的复制构造是影响性能的主要原因。在这个过程中都有临时对象参与进来，而临时对象本身只是做数据的复制。如果有办法能将临时对象的内存直接转移到 <code>my_pool</code> 对象中，不就能消除内存复制对性能的消耗吗？好消息是在C++11标准中引入了移动语义，它可以帮助我们将临时对象的内存移动到 <code>my_pool</code> 对象中，以避免内存数据的复制。让我们简单修改一下 <code>BigMemoryPool</code> 类代码：</p> 
<pre><code class="prism language-cpp"><span class="token keyword">class</span> <span class="token class-name">BigMemoryPool</span> <span class="token punctuation">{<!-- --></span>
<span class="token keyword">public</span><span class="token operator">:</span>
	<span class="token keyword">static</span> <span class="token keyword">const</span> <span class="token keyword">int</span> PoolSize <span class="token operator">=</span> <span class="token number">4096</span><span class="token punctuation">;</span>
	<span class="token function">BigMemoryPool</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token function">pool_</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token keyword">char</span><span class="token punctuation">[</span>PoolSize<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span><span class="token punctuation">}</span>
	<span class="token operator">~</span><span class="token function">BigMemoryPool</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
	<span class="token punctuation">{<!-- --></span>
		<span class="token keyword">if</span> <span class="token punctuation">(</span>pool_ <span class="token operator">!=</span> <span class="token keyword">nullptr</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
			<span class="token keyword">delete</span><span class="token punctuation">[</span><span class="token punctuation">]</span> pool_<span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
	<span class="token punctuation">}</span>

	<span class="token function">BigMemoryPool</span><span class="token punctuation">(</span>BigMemoryPool<span class="token operator">&amp;&amp;</span> other<span class="token punctuation">)</span>
	<span class="token punctuation">{<!-- --></span>
		std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"move big memory pool."</span> <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span>
		pool_ <span class="token operator">=</span> other<span class="token punctuation">.</span>pool_<span class="token punctuation">;</span>
		other<span class="token punctuation">.</span>pool_ <span class="token operator">=</span> <span class="token keyword">nullptr</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>

	<span class="token function">BigMemoryPool</span><span class="token punctuation">(</span><span class="token keyword">const</span> BigMemoryPool<span class="token operator">&amp;</span> other<span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token function">pool_</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token keyword">char</span><span class="token punctuation">[</span>PoolSize<span class="token punctuation">]</span><span class="token punctuation">)</span>
	<span class="token punctuation">{<!-- --></span>
		std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"copy big memory pool."</span> <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span>
		<span class="token function">memcpy</span><span class="token punctuation">(</span>pool_<span class="token punctuation">,</span> other<span class="token punctuation">.</span>pool_<span class="token punctuation">,</span> PoolSize<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>

<span class="token keyword">private</span><span class="token operator">:</span>
	<span class="token keyword">char</span> <span class="token operator">*</span>pool_<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre> 
<p>在上面的代码中增加了一个类 <code>BigMemoryPool</code> 的构造函数 <code>BigMemoryPool(BigMemoryPool&amp;&amp; other)</code>，它的形参是一个右值引用类型，称为<strong>移动构造函数</strong>。这个名称很容易让人联想到复制构造函数，那么就让我们先了解一下它们的区别。</p> 
<p>从构造函数的名称和它们的参数可以很明显地发现其中的区别，对于<strong>复制构造函数</strong>而言形参是一个<strong>左值引用</strong>，也就是说函数的<strong>实参</strong>必须是一个<strong>具名的左值</strong>，在复制构造函数中往往进行的是<strong>深复制</strong>，即在不能破坏实参对象的前提下复制目标对象。而<strong>移动构造函数</strong>恰恰相反，它接受的是一个<strong>右值引用</strong>，其核心思想是通过转移实参对象的数据以达成构造目标对象的目的，也就是说<strong>实参对象是会被修改的</strong>。</p> 
<p>进一步来说类<code>BigMemoryPool</code>的移动构造函数，在函数中没有了复制构造中的内存复制，取而代之的是简单的指针替换操作。它将实参对象的<code>pool_</code>赋值到当前对象，然后置空实参对象以保证实参对象析构的时候不会影响这片内存的生命周期。</p> 
<p>编译运行这段代码，其输出结果如下：</p> 
<pre><code class="prism language-cpp">copy big memory pool<span class="token punctuation">.</span>
move big memory pool<span class="token punctuation">.</span>
move big memory pool<span class="token punctuation">.</span>
</code></pre> 
<p>可以看到后面两次的构造函数变成了移动构造函数，因为这两次操作中源对象都是右值（临时对象），对于右值编译器会优先选择使用移动构造函数去构造目标对象。当移动构造函数不存在的时候才会退而求其次地使用复制构造函数。在移动构造函数中使用了指针转移的方式构造目标对象，所以整个程序的运行效率得到大幅提升。</p> 
<p>为了验证效率的提升，我们可以将上面的代码重复运行 100 万次，然后输出运行时间。请注意，在做实验前需要将构造函数中的打印输出语句删除，否则会影响实验数据：</p> 
<pre><code class="prism language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;chrono&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream&gt;</span></span>
<span class="token keyword">class</span> <span class="token class-name">BigMemoryPool</span> <span class="token punctuation">{<!-- --></span>
<span class="token keyword">public</span><span class="token operator">:</span>
	<span class="token keyword">static</span> <span class="token keyword">const</span> <span class="token keyword">int</span> PoolSize <span class="token operator">=</span> <span class="token number">4096</span><span class="token punctuation">;</span>
	<span class="token function">BigMemoryPool</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token function">pool_</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token keyword">char</span><span class="token punctuation">[</span>PoolSize<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span><span class="token punctuation">}</span>
	<span class="token operator">~</span><span class="token function">BigMemoryPool</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
	<span class="token punctuation">{<!-- --></span>
		<span class="token keyword">if</span> <span class="token punctuation">(</span>pool_ <span class="token operator">!=</span> <span class="token keyword">nullptr</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
			<span class="token keyword">delete</span><span class="token punctuation">[</span><span class="token punctuation">]</span> pool_<span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
	<span class="token punctuation">}</span>

	<span class="token function">BigMemoryPool</span><span class="token punctuation">(</span>BigMemoryPool<span class="token operator">&amp;&amp;</span> other<span class="token punctuation">)</span>
	<span class="token punctuation">{<!-- --></span>
<span class="token comment">//		std::cout &lt;&lt; "move big memory pool." &lt;&lt; std::endl;</span>
		pool_ <span class="token operator">=</span> other<span class="token punctuation">.</span>pool_<span class="token punctuation">;</span>
		other<span class="token punctuation">.</span>pool_ <span class="token operator">=</span> <span class="token keyword">nullptr</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>

	<span class="token function">BigMemoryPool</span><span class="token punctuation">(</span><span class="token keyword">const</span> BigMemoryPool<span class="token operator">&amp;</span> other<span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token function">pool_</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token keyword">char</span><span class="token punctuation">[</span>PoolSize<span class="token punctuation">]</span><span class="token punctuation">)</span>
	<span class="token punctuation">{<!-- --></span>
<span class="token comment">//		std::cout &lt;&lt; "copy big memory pool." &lt;&lt; std::endl;</span>
		<span class="token function">memcpy</span><span class="token punctuation">(</span>pool_<span class="token punctuation">,</span> other<span class="token punctuation">.</span>pool_<span class="token punctuation">,</span> PoolSize<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>

<span class="token keyword">private</span><span class="token operator">:</span>
	<span class="token keyword">char</span> <span class="token operator">*</span>pool_<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

BigMemoryPool <span class="token function">get_pool</span><span class="token punctuation">(</span><span class="token keyword">const</span> BigMemoryPool<span class="token operator">&amp;</span> pool<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
    <span class="token keyword">return</span> pool<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

BigMemoryPool <span class="token function">make_pool</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
    BigMemoryPool pool<span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token function">get_pool</span><span class="token punctuation">(</span>pool<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token keyword">auto</span> start <span class="token operator">=</span> std<span class="token double-colon punctuation">::</span>chrono<span class="token double-colon punctuation">::</span>high_resolution_clock<span class="token double-colon punctuation">::</span><span class="token function">now</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">1000000</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
		BigMemoryPool my_pool <span class="token operator">=</span> <span class="token function">make_pool</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
	<span class="token keyword">auto</span> end <span class="token operator">=</span> std<span class="token double-colon punctuation">::</span>chrono<span class="token double-colon punctuation">::</span>high_resolution_clock<span class="token double-colon punctuation">::</span><span class="token function">now</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	std<span class="token double-colon punctuation">::</span>chrono<span class="token double-colon punctuation">::</span>duration<span class="token operator">&lt;</span><span class="token keyword">double</span><span class="token operator">&gt;</span> diff <span class="token operator">=</span> end <span class="token operator">-</span> start<span class="token punctuation">;</span>
	std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"Time to call make_pool :"</span> <span class="token operator">&lt;&lt;</span> diff<span class="token punctuation">.</span><span class="token function">count</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> <span class="token string">" s"</span> <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>以上代码在我的机器上运行结果是<code>0.206474s</code>，如果将移动构造函数删除，运行结果是<code>0.47077s</code>，可见使用移动构造函数将性能提升了 1 倍多。</p> 
<p>除移动构造函数能实现移动语义以外，<strong>移动赋值运算符函数</strong>也能完成移动操作，继续以<code>BigMemoryPool</code>为例，在这个类中添加移动赋值运算符函数：</p> 
<pre><code class="prism language-cpp"><span class="token keyword">class</span> <span class="token class-name">BigMemoryPool</span> <span class="token punctuation">{<!-- --></span>
<span class="token keyword">public</span><span class="token operator">:</span>
	…
	BigMemoryPool<span class="token operator">&amp;</span> <span class="token keyword">operator</span><span class="token operator">=</span><span class="token punctuation">(</span>BigMemoryPool<span class="token operator">&amp;&amp;</span> other<span class="token punctuation">)</span>
	<span class="token punctuation">{<!-- --></span>
		std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"move(operator=) big memory pool."</span> <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span>
		<span class="token keyword">if</span> <span class="token punctuation">(</span>pool_ <span class="token operator">!=</span> <span class="token keyword">nullptr</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
			<span class="token keyword">delete</span><span class="token punctuation">[</span><span class="token punctuation">]</span> pool_<span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
		pool_ <span class="token operator">=</span> other<span class="token punctuation">.</span>pool_<span class="token punctuation">;</span>
		other<span class="token punctuation">.</span>pool_ <span class="token operator">=</span> <span class="token keyword">nullptr</span><span class="token punctuation">;</span>
		<span class="token keyword">return</span> <span class="token operator">*</span><span class="token keyword">this</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">private</span><span class="token operator">:</span>
	<span class="token keyword">char</span> <span class="token operator">*</span>pool_<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	BigMemoryPool my_pool<span class="token punctuation">;</span>
	my_pool <span class="token operator">=</span> <span class="token function">make_pool</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>这段代码编译运行的结果是：</p> 
<pre><code class="prism language-cpp">copy big memory pool<span class="token punctuation">.</span>
move big memory pool<span class="token punctuation">.</span>
<span class="token function">move</span><span class="token punctuation">(</span><span class="token keyword">operator</span><span class="token operator">=</span><span class="token punctuation">)</span> big memory pool<span class="token punctuation">.</span>
</code></pre> 
<p>可以看到赋值操作<code>my_pool = make_pool()</code>调用了移动赋值运算符函数，这里的规则和构造函数一样，即编译器对于赋值源对象是右值的情况会优先调用移动赋值运算符函数，如果该函数不存在，则调用复制赋值运算符函数。</p> 
<p>最后有两点需要说明一下。</p> 
<ol><li>同复制构造函数一样，编译器在一些条件下会生成一份移动构造函数，这些条件包括：没有任何的复制函数，包括复制构造函数和复制赋值函数；没有任何的移动函数，包括移动构造函数和移动赋值函数；也没有析构函数。虽然这些条件严苛得让人有些不太愉快，但是我们也不必对生成的移动构造函数有太多期待，因为编译器生成的移动构造函数和复制构造函数并没有什么区别。</li><li>虽然使用移动语义在性能上有很大收益，但是却也有一些风险，这些风险来自异常。试想一下，在一个移动构造函数中，如果当一个对象的资源移动到另一个对象时发生了异常，也就是说对象的一部分发生了转移而另一部分没有，这就会造成源对象和目标对象都不完整的情况发生，这种情况的后果是无法预测的。所以在编写移动语义的函数时建议确保函数不会抛出异常，与此同时，如果无法保证移动构造函数不会抛出异常，可以使用<code>noexcept</code>说明符限制该函数。这样当函数抛出异常的时候，程序不会再继续执行而是调用<code>std::terminate</code>中止执行以免造成其他不良影响。</li></ol> 
<h3><a id="6__1540"></a>6. 值类别</h3> 
<p>到目前为止一切都非常容易理解，其中一个原因是我在前面的内容中隐藏了一个概念。但是在进一步探讨右值引用之前，我们必须先掌握这个概念——值类别。值类别是C++11标准中新引入的概念，具体来说它是表达式的一种属性，该属性将表达式分为3个类别，它们分别是<strong>左值</strong>（<code>lvalue</code>）、<strong>纯右值</strong>（<code>prvalue</code>）和<strong>将亡值</strong>（<code>xvalue</code>），如图6-1所示。从前面的内容中我们知道早在C++98的时候，已经有了一些关于左值和右值的概念了，只不过当时这些概念对于C++程序编写并不重要。但是由于C++11中右值引用的出现，值类别被赋予了全新的含义。可惜的是，在C++11标准中并没能够清晰地定义它们，比如在C++11的标准文档中，左值的概念只有一句话：“指定一个函数或一个对象”，这样的描述显然是不清晰的。这种糟糕的情况一直延续到C++17标准的推出才得到解决。所以现在是时候让我们重新认识这些概念了。</p> 
<p><img src="https://images2.imgbox.com/2e/41/GErKKWGl_o.png" alt="在这里插入图片描述" width="450"></p> 
<p>表达式首先被分为了泛左值（<code>glvalue</code>) 和右值（<code>rvalue</code>），其中泛左值被进一步划分为左值和将亡值，右值又被划分为将亡值和纯右值。理解这些概念的关键在于泛左值、纯右值和将亡值。</p> 
<ol><li>所谓<strong>泛左值</strong>是指一个通过评估能够<strong>确定对象、位域或函数的标识的表达式</strong>。简单来说，<strong>它确定了对象或者函数的标识（具名对象）</strong>。</li><li>而<strong>纯右值</strong>是指一个通过评估<strong>能够用于初始化对象和位域</strong>，或者<strong>能够计算运算符操作数的值</strong>的<strong>表达式</strong>。</li><li><strong>将亡值属</strong>于泛左值的一种，它表示资源可以被重用的对象和位域，通常这是因为它们接近其<strong>生命周期的末尾</strong>，另外也可能是经过右值引用的转换产生的。</li></ol> 
<p>剩下的两种类别就很容易理解了，其中左值是指非将亡值的泛左值，而右值则包含了纯右值和将亡值。再次强调，值类别都是表达式的属性，所以我们常说的左值和右值实际上指的是表达式，不过为了描述方便我们常常会忽略它。</p> 
<p>是不是感觉有点晕。相信我，当我第一次看到这些概念的时候也是这个反应。不过好在我们对传统左值和右值的概念已经了然于心了，现在只需要做道连线题就能弄清楚它们的概念。实际上，这里的左值（<code>lvalue</code>）就是我们上文中描述的C++98的左值，而这里的纯右值（<code>prvalue</code>）则对应上文中描述的C++98的右值。最后我们惊喜地发现，现在只需要弄清楚将亡值（<code>xvalue</code>）到底是如何产生的就可以了。</p> 
<p>从本质上说产生<strong>将亡值</strong>的途径有两种，<strong>第一种是使用类型转换将泛左值转换为该类型的右值引用</strong>。比如：</p> 
<pre><code class="prism language-cpp"><span class="token generic-function"><span class="token function">static_cast</span><span class="token generic class-name"><span class="token operator">&lt;</span>BigMemoryPool<span class="token operator">&amp;&amp;</span><span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span>my_pool<span class="token punctuation">)</span>
</code></pre> 
<p>第二种在C++17标准中引入，我们称它为<strong>临时量实质化</strong>，指的是纯右值转换到临时对象的过程。每当纯右值出现在一个需要泛左值的地方时，临时量实质化都会发生，也就是说都会创建一个临时对象并且使用纯右值对其进行初始化，这也符合纯右值的概念，而这里的<strong>临时对象就是一个将亡值</strong>。</p> 
<pre><code class="prism language-cpp"><span class="token keyword">struct</span> <span class="token class-name">X</span> <span class="token punctuation">{<!-- --></span>
	<span class="token keyword">int</span> a<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token keyword">int</span> b <span class="token operator">=</span> <span class="token function">X</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>a<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>在上面的代码中，<code>X()</code> 是一个纯右值，访问其成员变量 <code>a</code> 却需要一个泛左值，所以这里会发生一次临时量实质化，将 <code>X()</code> 转换为将亡值，最后再访问其成员变量 <code>a</code>。还有一点需要说明，在C++17标准之前临时变量是纯右值，只有转换为右值引用的类型才是将亡值。</p> 
<p>在本节之后的内容中，依然会以左值和右值这样的术语为主。但是读者应该清楚，这里的左值是C++17中的左值（<code>lvalue</code>），右值是C++17中的纯右值（<code>prvalue</code>）和将亡值（<code>xvalue</code>）。对于将亡值（<code>xvalue</code>），读者实际上只需要知道它是泛左值和右值交集即可，后面的内容也不会重点强调它，所以不会影响到读者对后续内容的理解。</p> 
<h3><a id="7__1578"></a>7. 将左值转换为右值</h3> 
<p>在前面提到过右值引用只能绑定一个右值，如果尝试绑定左值会导致编译错误：</p> 
<pre><code class="prism language-cpp"><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token keyword">int</span> <span class="token operator">&amp;&amp;</span>k <span class="token operator">=</span> i<span class="token punctuation">;</span> <span class="token comment">// 编译失败</span>
</code></pre> 
<p>不过，如果想完成将右值引用绑定到左值这个“壮举”还是有办法的。在C++11标准中可以在不创建临时值的情况下显式地将左值通过<code>static_cast</code>转换为将亡值，通过值类别的内容我们知道将亡值属于右值，所以可以被右值引用绑定。值得注意的是，由于转换的并不是右值，因此它依然有着和转换之前相同的生命周期和内存地址，例如：</p> 
<pre><code class="prism language-cpp"><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token keyword">int</span> <span class="token operator">&amp;&amp;</span>k <span class="token operator">=</span> <span class="token generic-function"><span class="token function">static_cast</span><span class="token generic class-name"><span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&amp;&amp;</span><span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 编译成功</span>
</code></pre> 
<p>读者在这里应该会有疑问，既然这个转换既不改变生命周期也不改变内存地址，那它有什么存在的意义呢？实际上它的最大作用是<strong>让左值使用移动语义</strong>，还是以<code>BigMemoryPool</code>为例：</p> 
<pre><code class="prism language-cpp">BigMemoryPool my_pool1<span class="token punctuation">;</span>
BigMemoryPool my_pool2 <span class="token operator">=</span> my_pool1<span class="token punctuation">;</span>
BigMemoryPool my_pool3 <span class="token operator">=</span> <span class="token generic-function"><span class="token function">static_cast</span><span class="token generic class-name"><span class="token operator">&lt;</span>BigMemoryPool <span class="token operator">&amp;&amp;</span><span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span>my_pool1<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> 
<p>在这段代码中，<code>my_pool1</code> 是一个 <code>BigMemoryPool</code> 类型的对象，也是一个<strong>左值</strong>，所以用它去构造 <code>my_pool2</code> 的时候调用的是<strong>复制构造函数</strong>。为了让编译器调用<strong>移动构造函数</strong>构造 <code>my_pool3</code>，这里使用了 <code>static_cast&lt;BigMemoryPool &amp;&amp;&gt;(my_pool1)</code> 将 <code>my_pool1</code> 强制转换为<strong>右值</strong>（也是<strong>将亡值</strong>，为了叙述思路的连贯性后面不再强调）。由于调用了移动构造函数，<code>my_pool1</code> 失去了自己的内存数据，后面的代码也不能对 <code>my_pool1</code> 进行操作了。</p> 
<p>现在问题又来了，这样单纯地将一个左值数据转换到另外一个左值似乎并没有什么意义。在这个例子中的确如此，这样的转换不仅没有意义，而且如果有程序员在移动构造之后的代码中再次使用<code>my_pool1</code>还会引发未定义的行为。正确的使用场景是在<strong>一个右值被转换为左值后需要再次转换为右值</strong>，最典型的例子是一个<strong>右值作为实参传递到函数</strong>中。我们在讨论左值和右值的时候曾经提到过，<strong>无论一个函数的实参是左值还是右值，其形参都是一个左值</strong>，即使这个形参看上去是一个<strong>右值引用</strong>，例如：</p> 
<pre><code class="prism language-cpp">BigMemoryPool <span class="token function">get_pool</span><span class="token punctuation">(</span><span class="token keyword">const</span> BigMemoryPool<span class="token operator">&amp;</span> pool<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
    <span class="token keyword">return</span> pool<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

BigMemoryPool <span class="token function">make_pool</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
    BigMemoryPool pool<span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token function">get_pool</span><span class="token punctuation">(</span>pool<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">void</span> <span class="token function">move_pool</span><span class="token punctuation">(</span>BigMemoryPool <span class="token operator">&amp;&amp;</span>pool<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"call move_pool"</span> <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span>
	BigMemoryPool <span class="token function">my_pool</span><span class="token punctuation">(</span>pool<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token function">move_pool</span><span class="token punctuation">(</span><span class="token function">make_pool</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>编译运行以上代码输出结果如下：</p> 
<pre><code class="prism language-cpp">copy big memory pool<span class="token punctuation">.</span>
move big memory pool<span class="token punctuation">.</span>
call move_pool
copy big memory pool<span class="token punctuation">.</span>
</code></pre> 
<p>在上面的代码中，<code>move_pool</code> 函数的实参是 <code>make_pool</code> 函数返回的临时对象，也是一个右值，<code>move_pool</code> 的形参是一个右值引用，但是在使用形参 <code>pool</code> 构造 <code>my_pool</code> 的时候还是会调用复制构造函数而非移动构造函数。为了让 <code>my_pool</code> 调用移动构造函数进行构造，需要将形参 <code>pool</code> 强制转换为右值：</p> 
<pre><code class="prism language-cpp"><span class="token keyword">void</span> <span class="token function">move_pool</span><span class="token punctuation">(</span>BigMemoryPool <span class="token operator">&amp;&amp;</span>pool<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"call move_pool"</span> <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span>
	BigMemoryPool <span class="token function">my_pool</span><span class="token punctuation">(</span><span class="token generic-function"><span class="token function">static_cast</span><span class="token generic class-name"><span class="token operator">&lt;</span>BigMemoryPool<span class="token operator">&amp;&amp;</span><span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span>pool<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<pre><code class="prism language-cpp">copy big memory pool<span class="token punctuation">.</span>
move big memory pool<span class="token punctuation">.</span>
call move_pool
move big memory pool<span class="token punctuation">.</span>
</code></pre> 
<p>请注意，在这个场景下强制转换为右值就没有任何问题了，因为<code>move_pool</code>函数的实参是<code>make_pool</code>返回的临时对象，当函数调用结束后临时对象就会被销毁，所以转移其内存数据不会存在任何问题。</p> 
<p><strong>在C++11的标准库中还提供了一个函数模板 <code>std::move</code> 帮助我们将左值转换为右值</strong>，这个函数内部也是用 <code>static_cast</code> 做类型转换。只不过由于它是使用模板实现的函数，因此会根据传参类型自动推导返回类型，省去了指定转换类型的代码。另一方面从移动语义上来说，使用 <code>std::move</code> 函数的描述更加准确。所以建议读者使用 <code>std::move</code> 将左值转换为右值而非自己使用 <code>static_cast</code> 转换，例如：</p> 
<pre><code class="prism language-cpp"><span class="token keyword">void</span> <span class="token function">move_pool</span><span class="token punctuation">(</span>BigMemoryPool <span class="token operator">&amp;&amp;</span>pool<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"call move_pool"</span> <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span>
	BigMemoryPool <span class="token function">my_pool</span><span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span><span class="token function">move</span><span class="token punctuation">(</span>pool<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<h3><a id="8__1663"></a>8. 万能引用和引用折叠</h3> 
<p>第 2 节提到过<strong>常量左值引用既可以引用左值又可以引用右值</strong>，是一个几乎万能的引用，但可惜的是由于其<strong>常量性</strong>，导致它的使用范围受到一些限制。其实在C++11中确实存在着一个被称为“万能”的引用，它看似是一个<strong>右值引用</strong>，但其实有着很大区别，请看下面的代码：</p> 
<pre><code class="prism language-cpp"><span class="token keyword">void</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token keyword">int</span> <span class="token operator">&amp;&amp;</span>i<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span><span class="token punctuation">}</span>     <span class="token comment">// i 为右值引用</span>

<span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">T</span><span class="token operator">&gt;</span>
<span class="token keyword">void</span> <span class="token function">bar</span><span class="token punctuation">(</span>T <span class="token operator">&amp;&amp;</span>t<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span><span class="token punctuation">}</span>       <span class="token comment">// t 为万能引用</span>

<span class="token keyword">int</span> <span class="token function">get_val</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span> <span class="token keyword">return</span> <span class="token number">5</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>
<span class="token keyword">int</span> <span class="token operator">&amp;&amp;</span>x <span class="token operator">=</span> <span class="token function">get_val</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token comment">// x 为右值引用</span>
<span class="token keyword">auto</span> <span class="token operator">&amp;&amp;</span>y <span class="token operator">=</span> <span class="token function">get_val</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// y 为万能引用</span>
</code></pre> 
<p>在上面的代码中，函数 <code>foo</code> 的形参 <code>i</code> 和变量 <code>x</code> 是右值引用，而函数模板的形参 <code>t</code> 和变量 <code>y</code> 则是万能引用。我们知道右值引用只能绑定一个右值，但是<strong>万能引用既可以绑定左值也可以绑定右值</strong>，甚至 <code>const</code> 和 <code>volatile</code> 的值都可以绑定，例如：</p> 
<pre><code class="prism language-cpp"><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">42</span><span class="token punctuation">;</span>
<span class="token keyword">const</span> <span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">11</span><span class="token punctuation">;</span>
<span class="token function">bar</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">bar</span><span class="token punctuation">(</span>j<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">bar</span><span class="token punctuation">(</span><span class="token function">get_val</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">auto</span> <span class="token operator">&amp;&amp;</span>x <span class="token operator">=</span> i<span class="token punctuation">;</span>
<span class="token keyword">auto</span> <span class="token operator">&amp;&amp;</span>y <span class="token operator">=</span> j<span class="token punctuation">;</span>
<span class="token keyword">auto</span> <span class="token operator">&amp;&amp;</span>z <span class="token operator">=</span> <span class="token function">get_val</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> 
<p>看到这里读者应该已经发现了其中的奥秘。所谓的万能引用是因为发生了类型推导，在 <code>T&amp;&amp;</code> 和 <code>auto&amp;&amp;</code> 的初始化过程中都会发生类型的推导，如果已经有一个确定的类型，比如 <code>int &amp;&amp;</code>，则是右值引用。在这个推导过程中，初始化的源对象如果是一个左值，则目标对象会推导出左值引用；反之如果源对象是一个右值，则会推导出右值引用，不过无论如何都会是一个引用类型。</p> 
<p>万能引用能如此灵活地引用对象，实际上是因为在C++11中添加了一套引用叠加推导的规则——引用折叠。在这套规则中规定了在不同的引用类型互相作用的情况下应该如何推导出最终类型，如表6-1所示。</p> 
<p><img src="https://images2.imgbox.com/85/a9/eyiTR4As_o.png" alt="在这里插入图片描述" width="600"></p> 
<p>上面的表格显示了引用折叠的推导规则，可以看出在整个推导过程中，只要有左值引用参与进来，最后推导的结果就是一个左值引用。只有实际类型是一个非引用类型或者右值引用类型时，最后推导出来的才是一个右值引用。</p> 
<p>那么这个规则是如何在万能引用中体现的呢？让我们以函数模板<code>bar</code>为例看一下具体的推导过程。</p> 
<p>在 <code>bar(i);</code> 中 <code>i</code> 是一个左值，所以 <code>T</code> 的推导类型结果是 <code>int&amp;</code>，根据引用折叠规则 <code>T&amp;&amp; int&amp;</code> 的最终推导类型为 <code>int&amp;</code>，于是 <code>bar</code> 函数的形参是一个左值引用。而在 <code>bar(get_val());</code> 中 <code>get_val</code> 返回的是一个右值，所以 <code>T</code> 的推导类型为非引用类型 <code>int</code>，根据引用折叠规则 <code>T&amp;&amp; int</code>，于是最终的推导类型是 <code>int&amp;&amp;</code>，<code>bar</code> 函数的形参成为一个右值引用。</p> 
<p>值得一提的是，万能引用的形式必须是 <code>T&amp;&amp;</code> 或者 <code>auto&amp;&amp;</code>，也就是说它们必须在初始化的时候被直接推导出来，如果在推导中出现中间过程，则不是一个万能引用，例如：</p> 
<pre><code class="prism language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;vector&gt;</span></span>

<span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">T</span><span class="token operator">&gt;</span>
<span class="token keyword">void</span> <span class="token function">foo</span><span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span>vector<span class="token operator">&lt;</span>T<span class="token operator">&gt;</span> <span class="token operator">&amp;&amp;</span>t<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span><span class="token punctuation">}</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	std<span class="token double-colon punctuation">::</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span> v<span class="token punctuation">{<!-- --></span> <span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>
	<span class="token function">foo</span><span class="token punctuation">(</span>v<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 编译错误</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>一个万能引用，而是一个右值引用。因为<code>foo</code>的形参类型是<code>std::vector&lt;T&gt;&amp;&amp;</code>而不是<code>T&amp;&amp;</code>，所以编译器无法将其看作一个万能引用处理。</p> 
<h3><a id="9__1722"></a>9. 完美转发</h3> 
<p>万能引用最典型的用途被称为完美转发。在介绍完美转发之前，我们先看一个常规的转发函数模板：</p> 
<pre><code class="prism language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;string&gt;</span></span>

<span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">T</span><span class="token operator">&gt;</span>
<span class="token keyword">void</span> <span class="token function">show_type</span><span class="token punctuation">(</span>T t<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token keyword">typeid</span><span class="token punctuation">(</span>t<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">name</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">T</span><span class="token operator">&gt;</span>
<span class="token keyword">void</span> <span class="token function">normal_forwarding</span><span class="token punctuation">(</span>T t<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token function">show_type</span><span class="token punctuation">(</span>t<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	std<span class="token double-colon punctuation">::</span>string s <span class="token operator">=</span> <span class="token string">"hello world"</span><span class="token punctuation">;</span>
	<span class="token function">normal_forwarding</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>在上面的代码中，函数<code>normal_forwarding</code>是一个常规的转发函数模板，它可以完成字符串的转发任务。但是它的效率却令人堪忧。因为<code>normal_forwarding</code>按值转发，也就是说<code>std::string</code>在转发过程中会额外发生一次临时对象的复制。其中一个解决办法是将<code>void normal_forwarding(T t)</code>替换为<code>void normal_ forwarding(T &amp;t)</code>，这样就能避免临时对象的复制。不过这样会带来另外一个问题，如果传递过来的是一个右值，则该代码无法通过编译，例如：</p> 
<pre><code class="prism language-cpp">std<span class="token double-colon punctuation">::</span>string <span class="token function">get_string</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token keyword">return</span> <span class="token string">"hi world"</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token function">normal_forwarding</span><span class="token punctuation">(</span><span class="token function">get_string</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 编译失败</span>
</code></pre> 
<p>当然，我们还可以将<code>void normal_forwarding(T &amp;t)</code>替换为<code>void normal_forwarding (const T &amp;t)</code>来解决这个问题，因为<strong>常量左值引用</strong>是可以<strong>引用右值</strong>的。</p> 
<pre><code class="prism language-cpp"><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">T</span><span class="token operator">&gt;</span>
<span class="token keyword">void</span> <span class="token function">normal_forwarding</span><span class="token punctuation">(</span><span class="token keyword">const</span> T <span class="token operator">&amp;</span>t<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token function">show_type</span><span class="token punctuation">(</span>t<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

std<span class="token double-colon punctuation">::</span>string <span class="token function">get_string</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
    <span class="token keyword">return</span> <span class="token string">"hi world"</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	std<span class="token double-colon punctuation">::</span>string s <span class="token operator">=</span> <span class="token string">"hello world"</span><span class="token punctuation">;</span>
	<span class="token function">normal_forwarding</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">normal_forwarding</span><span class="token punctuation">(</span><span class="token function">get_string</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>但是我们也知道，虽然常量左值引用在这个场景下可以“完美”地转发字符串，但是如果在后续的函数中需要修改该字符串，则会编译错误。所以这些方法都不能称得上是完美转发。</p> 
<p>万能引用的出现改变了这个尴尬的局面。上文提到过，对于万能引用的形参来说，如果实参是给左值，则形参被推导为左值引用；反之如果实参是一个右值，则形参被推导为右值引用，所以下面的代码无论传递的是左值还是右值都可以被转发，而且不会发生多余的临时复制：</p> 
<pre><code class="prism language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;string&gt;</span></span>

<span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">T</span><span class="token operator">&gt;</span>
<span class="token keyword">void</span> <span class="token function">show_type</span><span class="token punctuation">(</span>T t<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token keyword">typeid</span><span class="token punctuation">(</span>t<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">name</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">T</span><span class="token operator">&gt;</span>
<span class="token keyword">void</span> <span class="token function">perfect_forwarding</span><span class="token punctuation">(</span>T <span class="token operator">&amp;&amp;</span>t<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token function">show_type</span><span class="token punctuation">(</span><span class="token generic-function"><span class="token function">static_cast</span><span class="token generic class-name"><span class="token operator">&lt;</span>T<span class="token operator">&amp;&amp;</span><span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span>t<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

std<span class="token double-colon punctuation">::</span>string <span class="token function">get_string</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token keyword">return</span> <span class="token string">"hi world"</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	std<span class="token double-colon punctuation">::</span>string s <span class="token operator">=</span> <span class="token string">"hello world"</span><span class="token punctuation">;</span>
	<span class="token function">perfect_forwarding</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token function">perfect_forwarding</span><span class="token punctuation">(</span><span class="token function">get_string</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>如果已经理解了引用折叠规则，那么上面的代码就很容易理解了。唯一可能需要注意的是<code>show_type(static_cast&lt;T&amp;&amp;&gt;(t));</code>中的类型转换，之所以这里需要用到类型转换，是因为作为形参的<code>t</code>是左值。为了让转发将左右值的属性也带到目标函数中，这里需要进行类型转换。当实参是一个左值时，<code>T</code>被推导为<code>std::string&amp;</code>，于是<code>static_cast&lt;T&amp;&amp;&gt;</code>被推导为<code>static_cast&lt;std:: string&amp;&gt;</code>，传递到<code>show_type</code>函数时继续保持着左值引用的属性；当实参是一个右值时，<code>T</code>被推导为<code>std::string</code>，于是<code>static_cast &lt;T&amp;&amp;&gt;</code>被推导为<code>static_cast&lt;std::string&amp;&amp;&gt;</code>，所以传递到<code>show_type</code>函数时保持了右值引用的属性。</p> 
<p>和移动语义的情况一样，显式使用<code>static_cast</code>类型转换进行转发不是一个便捷的方法。在C++11的标准库中提供了一个<code>std::forward</code>函数模板，在函数内部也是使用<code>static_cast</code>进行类型转换，只不过使用<code>std::forward</code>转发语义会表达得更加清晰，<code>std::forward</code>函数模板的使用方法也很简单：</p> 
<pre><code class="prism language-cpp"><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">T</span><span class="token operator">&gt;</span>
<span class="token keyword">void</span> <span class="token function">perfect_forwarding</span><span class="token punctuation">(</span>T <span class="token operator">&amp;&amp;</span>t<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token function">show_type</span><span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span><span class="token generic-function"><span class="token function">forward</span><span class="token generic class-name"><span class="token operator">&lt;</span>T<span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span>t<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p><strong>请注意<code>std::move</code>和<code>std::forward</code>的区别，其中<code>std::move</code>一定会将实参转换为一个右值引用，并且使用<code>std::move</code>不需要指定模板实参，模板实参是由函数调用推导出来的。而<code>std::forward</code>会根据左值和右值的实际情况进行转发，在使用的时候需要指定模板实参。</strong></p> 
<h3><a id="10__1827"></a>10. 针对局部变量和右值引用的隐式移动操作</h3> 
<p>在对旧程序代码升级新编译环境之后，我们可能会发现程序运行的效率提高了，这里的原因一定少不了新标准的编译器在某些情况下将隐式复制修改为隐式移动。虽然这些是编译器“偷偷”完成的，但是我们不能因为运行效率提高就忽略其中的缘由，所以接下来我们要弄清楚这些隐式移动是怎么发生的：</p> 
<pre><code class="prism language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream&gt;</span></span>
<span class="token keyword">struct</span> <span class="token class-name">X</span> <span class="token punctuation">{<!-- --></span>
	<span class="token function">X</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token keyword">default</span><span class="token punctuation">;</span>
	<span class="token function">X</span><span class="token punctuation">(</span><span class="token keyword">const</span> X<span class="token operator">&amp;</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token keyword">default</span><span class="token punctuation">;</span>
	<span class="token function">X</span><span class="token punctuation">(</span>X<span class="token operator">&amp;&amp;</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
		std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"move ctor"</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
X <span class="token function">f</span><span class="token punctuation">(</span>X x<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
	<span class="token keyword">return</span> x<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
	X r <span class="token operator">=</span> <span class="token function">f</span><span class="token punctuation">(</span>X<span class="token punctuation">{<!-- --></span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>这段代码很容易理解，函数<code>f</code>直接返回调用者传进来的实参 <code>x</code>，在 <code>main</code> 函数中使用 <code>r</code> 接收 <code>f</code> 函数的返回值。关键问题是，这个赋值操作究竟是如何进行的。从代码上看，将 <code>r</code> 赋值为 <code>x</code> 应该是一个复制，对于旧时的标准这是没错的。但是对于支持移动语义的新标准，这个地方会隐式地采用移动构造函数来完成数据的交换。编译运行以上代码最终会显示 “<code>move ctor</code>” 字符串。</p> 
<p>除此之外，对于局部变量也有相似的规则，只不过大多数时候编译器会采用更加高效的返回值优化代替移动操作，这里我们稍微修改一点<code>f</code>函数：</p> 
<pre><code class="prism language-cpp">X <span class="token function">f</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
	X x<span class="token punctuation">;</span>
	<span class="token keyword">return</span> x<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
	X r <span class="token operator">=</span> <span class="token function">f</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>请注意，编译以上代码的时候需要使用<code>-fno-elide-constructors</code>选项用于关闭返回值优化。然后运行编译好的程序，会发现<code>X r = f();</code>同样调用的是移动构造函数。</p> 
<p>在C++20标准中，隐式移动操作针对右值引用和<code>throw</code>的情况进行了扩展，例如：</p> 
<pre><code class="prism language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;string&gt;</span></span>

<span class="token keyword">struct</span> <span class="token class-name">X</span> <span class="token punctuation">{<!-- --></span>
	<span class="token function">X</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token keyword">default</span><span class="token punctuation">;</span>
	<span class="token function">X</span><span class="token punctuation">(</span><span class="token keyword">const</span> X<span class="token operator">&amp;</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token keyword">default</span><span class="token punctuation">;</span>
	<span class="token function">X</span><span class="token punctuation">(</span>X<span class="token operator">&amp;&amp;</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
		std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"move"</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

X <span class="token function">f</span><span class="token punctuation">(</span>X <span class="token operator">&amp;&amp;</span>x<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
	<span class="token keyword">return</span> x<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
	X r <span class="token operator">=</span> <span class="token function">f</span><span class="token punctuation">(</span>X<span class="token punctuation">{<!-- --></span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>以上代码使用<strong>C++20</strong>之前的标准编译是不会调用任何移动构造函数的。原因前面也解释过，因为函数<code>f</code>的形参 <code>x</code> 是一个左值，对于左值要调用复制构造函数。要实现移动语义，需要将 <code>return x;</code> 修改为 <code>return std::move(x);</code>。显然这里是有优化空间的，<strong>C++20</strong>标准规定在这种情况下可以隐式采用移动语义完成赋值。具体规则如下。</p> 
<p>可隐式移动的对象必须是一个非易失或一个右值引用的非易失自动存储对象，在以下情况下可以使用移动代替复制。</p> 
<ol><li><code>return</code> 或 <code>co_return</code> 语句中的返回对象是函数或 lambda 表达式中的对象或形参。</li><li><code>throw</code> 语句中抛出的对象是函数或 <code>try</code> 代码块中的对象。</li></ol> 
<p>实际上<code>throw</code>调用移动构造的情况和<code>return</code>差不多，我们只需要将上面的代码稍作修改即可：</p> 
<pre><code class="prism language-cpp"><span class="token keyword">void</span> <span class="token function">f</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
	X x<span class="token punctuation">;</span>
	<span class="token keyword">throw</span> x<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
	<span class="token keyword">try</span> <span class="token punctuation">{<!-- --></span>
		<span class="token function">f</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
	<span class="token keyword">catch</span> <span class="token punctuation">(</span>…<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
	<span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>可以看到函数<code>f</code>不再有返回值，它通过<code>throw</code>抛出<code>x</code>，<code>main</code>函数用<code>try-catch</code>捕获f抛出的<code>x</code>。这个捕获调用的就是移动构造函数。</p> 
<h2><a id="lambdaC11C20_1911"></a>七、lambda表达式（C++11～C++20）</h2> 
<h3><a id="1_lambda_1913"></a>1. lambda表达式语法</h3> 
<p><code>lambda</code>表达式是现代编程语言的一个基础特性，比如LISP、Python、C#等具备该特性。但是遗憾的是，直到C++11标准之前，C++都没有在语言特性层面上支持<code>lambda</code>表达式。程序员曾尝试使用库来实现<code>lambda</code>表达式的功能，比如<code>Boost.Bind</code>或<code>Boost.Lambda</code>，但是它们有着共同的缺点，实现代码非常复杂，使用的时候也需要十分小心，一旦有错误发生，就可能会出现一堆错误和警告信息，总之其编程体验并不好。</p> 
<p>另外，虽然C++一直以来都没有支持<code>lambda</code>表达式，但是它对<code>lambda</code>表达式的需求却非常高。最明显的就是<code>STL</code>，在<code>STL</code>中有大量需要传入谓词的算法函数，比如<code>std::find_if</code>、<code>std::replace_if</code>等。过去有两种方法实现谓词函数：编写纯函数或者仿函数。但是它们的定义都无法直接应用到函数调用的实参中，面对复杂工程的代码，我们可能需要四处切换源文件来搜索这些函数或者仿函数。</p> 
<p>为了解决上面这些问题，C++11标准为我们提供了<code>lambda</code>表达式的支持，而且语法非常简单明了。这种简单可能会让我们觉得它与传统的C++语法有点格格不入。不过在习惯新的语法之后，就会发觉<code>lambda</code>表达式的方便之处。</p> 
<p><code>lambda</code>表达式的语法非常简单，具体定义如下：</p> 
<pre><code class="prism language-cpp"><span class="token punctuation">[</span> captures <span class="token punctuation">]</span> <span class="token punctuation">(</span> params <span class="token punctuation">)</span> specifiers exception <span class="token operator">-&gt;</span> ret <span class="token punctuation">{<!-- --></span> body <span class="token punctuation">}</span>
</code></pre> 
<p>先不用急于解读这个定义，我们可以结合<code>lambda</code>表达式的例子来读懂它的语法：</p> 
<pre><code class="prism language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream&gt;</span></span>
<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token keyword">int</span> x <span class="token operator">=</span> <span class="token number">5</span><span class="token punctuation">;</span>
	<span class="token keyword">auto</span> foo <span class="token operator">=</span> <span class="token punctuation">[</span>x<span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token keyword">int</span> y<span class="token punctuation">)</span><span class="token operator">-&gt;</span><span class="token keyword">int</span> <span class="token punctuation">{<!-- --></span> <span class="token keyword">return</span> x <span class="token operator">*</span> y<span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>
	std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token number">8</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>在这个例子中，<code>[x](int y)-&gt;int { return x * y; }</code> 是一个标准的<code>lambda</code>表达式，对应到<code>lambda</code>表达式的语法。</p> 
<ul><li><code>[ captures ]</code> —— <strong>捕获列表</strong>，它可以<strong>捕获当前函数作用域的零个或多个变量</strong>，变量之间用逗号分隔。在对应的例子中，<code>[x]</code> 是一个捕获列表，不过它只捕获了当前函数作用域的一个变量 <code>x</code>，在捕获了变量之后，我们可以在 <code>lambda</code> 表达式函数体内使用这个变量，比如 <code>return x * y</code>。另外，捕获列表的捕获方式有两种：<strong>按值捕获</strong>和<strong>引用捕获</strong>，下文会详细介绍。</li><li><code>( params )</code> —— <strong>可选参数列表</strong>，语法和普通函数的参数列表一样，在不需要参数的时候可以忽略参数列表。对应例子中的 <code>(int y)</code>。</li><li><code>specifiers</code> —— <strong>可选限定符</strong>，C++11中可以用 <code>mutable</code>，它允许我们在<code>lambda</code>表达式函数体内改变按值捕获的变量，或者调用非<code>const</code>的成员函数。上面的例子中没有使用说明符。</li><li><code>exception</code> —— <strong>可选异常说明符</strong>，我们可以使用 <code>noexcept</code> 来指明<code>lambda</code>是否会抛出异常。对应的例子中没有使用异常说明符。</li><li><code>ret</code> —— <strong>可选返回值类型</strong>，不同于普通函数，<code>lambda</code>表达式使用返回类型后置的语法来表示返回类型，如果没有返回值（<code>void</code>类型），可以忽略包括<code>-&gt;</code>在内的整个部分。另外，我们也可以在有返回值的情况下不指定返回类型，这时编译器会为我们推导出一个返回类型。对应到上面的例子是 <code>-&gt;int</code>。</li><li><code>{ body }</code> —— <strong><code>lambda</code>表达式的函数体</strong>，这个部分和普通函数的函数体一样。对应例子中的 <code>{ return x * y; }</code>。</li></ul> 
<p>细心的读者肯定发现了一个有趣的事实，由于参数列表，限定符以及返回值都是可选的，于是我们可以写出的最简单的<code>lambda</code>表达式是<code>[]{}</code>。虽然看上去非常奇怪，但它确实是一个合法的<code>lambda</code>表达式。需要特别强调的是，上面的语法定义只属于C++11标准，C++14和C++17标准对<code>lambda</code>表达式又进行了很有用的扩展，我们会在后面介绍。</p> 
<h3><a id="2__1954"></a>2. 捕获列表</h3> 
<p>在lambda表达式的语法中，与传统C++语法差异最大的部分应该算是捕获列表了。实际上，除了语法差异较大之外，它也是lambda表达式中最为复杂的一个部分。接下来我们会把捕获列表分解开来逐步讨论其特性。</p> 
<h4><a id="_1958"></a>作用域</h4> 
<p>我们必须了解捕获列表的作用域，通常我们说一个对象在某一个作用域内，不过这种说法在捕获列表中发生了变化。捕获列表中的变量存在于两个作用域——<strong>lambda表达式定义的函数作用域</strong>以及<strong>lambda表达式函数体的作用域</strong>。前者是为了捕获变量，后者是为了使用变量。另外，标准还规定<strong>能捕获的变量必须是一个自动存储类型</strong>。简单来说就是<strong>非静态的局部变量</strong>。让我们看一看下面的例子：</p> 
<pre><code class="prism language-cpp"><span class="token keyword">int</span> x <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token keyword">int</span> y <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
	<span class="token keyword">static</span> <span class="token keyword">int</span> z <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
	<span class="token keyword">auto</span> foo <span class="token operator">=</span> <span class="token punctuation">[</span>x<span class="token punctuation">,</span> y<span class="token punctuation">,</span> z<span class="token punctuation">]</span> <span class="token punctuation">{<!-- --></span><span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>以上代码可能是无法通过编译的，其原因有两点：第一，变量<code>x</code>和<code>z</code>不是自动存储类型的变量；第二，<code>x</code>不存在于<code>lambda</code>表达式定义的作用域。这里可能无法编译，因为不同编译器对于这段代码的处理会有所不同，比如GCC就不会报错，而是给出警告。那么如果想在<code>lambda</code>表达式中使用全局变量或者静态局部变量该怎么办呢？马上能想到的办法是用参数列表传递全局变量或者静态局部变量，其实不必这么麻烦，直接用就行了，来看一看下面的代码：</p> 
<pre><code class="prism language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream&gt;</span></span>
<span class="token keyword">int</span> x <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token keyword">int</span> y <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span>
	<span class="token keyword">static</span> <span class="token keyword">int</span> z <span class="token operator">=</span> <span class="token number">3</span><span class="token punctuation">;</span>
	<span class="token keyword">auto</span> foo <span class="token operator">=</span> <span class="token punctuation">[</span>y<span class="token punctuation">]</span> <span class="token punctuation">{<!-- --></span> <span class="token keyword">return</span> x <span class="token operator">+</span> y <span class="token operator">+</span> z<span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>
	std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>在上面的代码中，虽然我们没有捕获变量<code>x</code>和<code>z</code>，但是依然可以使用它们。</p> 
<p>进一步来说，如果我们将一个<code>lambda</code>表达式定义在全局作用域，那么<code>lambda</code>表达式的捕获列表必须为空。因为根据上面提到的规则，捕获列表的变量必须是一个自动存储类型，但是全局作用域并没有这样的类型，比如：</p> 
<pre><code class="prism language-cpp"><span class="token keyword">int</span> x <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
<span class="token keyword">auto</span> foo <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token punctuation">{<!-- --></span> <span class="token keyword">return</span> x<span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<h4><a id="_1995"></a>捕获值和捕获引用</h4> 
<p>捕获列表的捕获方式分为<strong>捕获值</strong>和<strong>捕获引用</strong>，其中捕获值的语法我们已经在前面的例子中看到了，在<code>[]</code>中直接写入变量名，如果有多个变量，则用逗号分隔，例如：</p> 
<pre><code class="prism language-cpp"><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token keyword">int</span> x <span class="token operator">=</span> <span class="token number">5</span><span class="token punctuation">,</span> y <span class="token operator">=</span> <span class="token number">8</span><span class="token punctuation">;</span>
	<span class="token keyword">auto</span> foo <span class="token operator">=</span> <span class="token punctuation">[</span>x<span class="token punctuation">,</span> y<span class="token punctuation">]</span> <span class="token punctuation">{<!-- --></span> <span class="token keyword">return</span> x <span class="token operator">*</span> y<span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>捕获值是将函数作用域的<code>x</code>和<code>y</code>的值复制到<code>lambda</code>表达式对象的内部，就如同<code>lambda</code>表达式的成员变量一样。</p> 
<p>捕获引用的语法与捕获值只有一个<code>&amp;</code>的区别，要表达捕获引用我们只需要在捕获变量之前加上<code>&amp;</code>，类似于取变量指针。只不过这里捕获的是引用而不是指针，在<code>lambda</code>表达式内可以直接使用变量名访问变量而<br> 不需解引用，比如：</p> 
<pre><code class="prism language-cpp"><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token keyword">int</span> x <span class="token operator">=</span> <span class="token number">5</span><span class="token punctuation">,</span> y <span class="token operator">=</span> <span class="token number">8</span><span class="token punctuation">;</span>
	<span class="token keyword">auto</span> foo <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token operator">&amp;</span>x<span class="token punctuation">,</span> <span class="token operator">&amp;</span>y<span class="token punctuation">]</span> <span class="token punctuation">{<!-- --></span> <span class="token keyword">return</span> x <span class="token operator">*</span> y<span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>上面的两个例子只是读取变量的值，从结果上看两种捕获没有区别，但是如果加入变量的赋值操作，情况就不同了，请看下面的例子：</p> 
<pre><code class="prism language-cpp"><span class="token keyword">void</span> <span class="token function">bar1</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token keyword">int</span> x <span class="token operator">=</span> <span class="token number">5</span><span class="token punctuation">,</span> y <span class="token operator">=</span> <span class="token number">8</span><span class="token punctuation">;</span>
	<span class="token keyword">auto</span> foo <span class="token operator">=</span> <span class="token punctuation">[</span>x<span class="token punctuation">,</span> y<span class="token punctuation">]</span> <span class="token punctuation">{<!-- --></span>
		x <span class="token operator">+=</span> <span class="token number">1</span><span class="token punctuation">;</span> <span class="token comment">// 编译失败，无法改变捕获变量的值</span>
		y <span class="token operator">+=</span> <span class="token number">2</span><span class="token punctuation">;</span> <span class="token comment">// 编译失败，无法改变捕获变量的值</span>
		<span class="token keyword">return</span> x <span class="token operator">*</span> y<span class="token punctuation">;</span>
	<span class="token punctuation">}</span><span class="token punctuation">;</span>
	std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">void</span> <span class="token function">bar2</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token keyword">int</span> x <span class="token operator">=</span> <span class="token number">5</span><span class="token punctuation">,</span> y <span class="token operator">=</span> <span class="token number">8</span><span class="token punctuation">;</span>
	<span class="token keyword">auto</span> foo <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token operator">&amp;</span>x<span class="token punctuation">,</span> <span class="token operator">&amp;</span>y<span class="token punctuation">]</span> <span class="token punctuation">{<!-- --></span>
		x <span class="token operator">+=</span> <span class="token number">1</span><span class="token punctuation">;</span>
		y <span class="token operator">+=</span> <span class="token number">2</span><span class="token punctuation">;</span>
		<span class="token keyword">return</span> x <span class="token operator">*</span> y<span class="token punctuation">;</span>
	<span class="token punctuation">}</span><span class="token punctuation">;</span>
	std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>在上面的代码中函数<code>bar1</code>无法通过编译，原因是我们无法改变捕获变量的值。这就引出了<code>lambda</code>表达式的一个特性：<strong>捕获的变量默认为常量</strong>，或者说 <strong><code>lambda</code>是一个常量函数</strong>（类似于<strong>常量成员函数</strong>）。<code>bar2</code>函数里的<code>lambda</code>表达式能够顺利地通过编译，虽然其函数体内也有改变变量<code>x</code>和<code>y</code>的行为。这是因为捕获的变量默认为常量指的是变量本身，当变量按值捕获的时候，变量本身就是值，所以改变值就会发生错误。相反，在捕获引用的情况下，捕获变量实际上是一个引用，我们在函数体内改变的并不是引用本身，而是引用的值，所以并没有被编译器拒绝。</p> 
<p>另外，还记得上文提到的可选说明符<code>mutable</code>吗？使用<code>mutable</code>说明符可以移除<code>lambda</code>表达式的常量性，也就是说我们可以在<code>lambda</code>表达式的函数体中修改捕获值的变量了，例如：</p> 
<pre><code class="prism language-cpp"><span class="token keyword">void</span> <span class="token function">bar3</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token keyword">int</span> x <span class="token operator">=</span> <span class="token number">5</span><span class="token punctuation">,</span> y <span class="token operator">=</span> <span class="token number">8</span><span class="token punctuation">;</span>
	<span class="token keyword">auto</span> foo <span class="token operator">=</span> <span class="token punctuation">[</span>x<span class="token punctuation">,</span> y<span class="token punctuation">]</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">mutable</span> <span class="token punctuation">{<!-- --></span>
		x <span class="token operator">+=</span> <span class="token number">1</span><span class="token punctuation">;</span>
		y <span class="token operator">+=</span> <span class="token number">2</span><span class="token punctuation">;</span>
		<span class="token keyword">return</span> x <span class="token operator">*</span> y<span class="token punctuation">;</span>
	<span class="token punctuation">}</span><span class="token punctuation">;</span>
	std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>以上代码可以通过编译，也就是说<code>lambda</code>表达式成功地修改了其作用域内的<code>x</code>和<code>y</code>的值。值得注意的是，函数<code>bar3</code>相对于函数<code>bar1</code>除了增加说明符<code>mutable</code>，还多了一对<code>()，这是因为语法规定</code>lambda`表达式如果存在说明符，那么形参列表不能省略。</p> 
<p>编译运行<code>bar2</code>和<code>bar3</code>两个函数会输出相同的结果，但这并不代表两个函数是等价的，捕获值和捕获引用还是存在着本质区别。当<code>lambda</code>表达式<strong>捕获值</strong>时，<strong>表达式内实际获得的是捕获变量的复制</strong>，我们可以任意地<strong>修改内部捕获变量，但不会影响外部变量</strong>。而<strong>捕获引用</strong>则不同，在<code>lambda</code><strong>表达式内修改捕获引用的变量，对应的外部变量也会被修改</strong>。</p> 
<pre><code class="prism language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream&gt;</span></span>

<span class="token keyword">void</span> <span class="token function">bar2</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
    <span class="token keyword">int</span> x <span class="token operator">=</span> <span class="token number">5</span><span class="token punctuation">,</span> y <span class="token operator">=</span> <span class="token number">8</span><span class="token punctuation">;</span>
    <span class="token keyword">auto</span> foo <span class="token operator">=</span> <span class="token punctuation">[</span>x<span class="token punctuation">,</span> y<span class="token punctuation">]</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">mutable</span> <span class="token punctuation">{<!-- --></span>
        x <span class="token operator">+=</span> <span class="token number">1</span><span class="token punctuation">;</span>
        y <span class="token operator">+=</span> <span class="token number">2</span><span class="token punctuation">;</span>
        std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span><span class="token string">"bar2 in lambda x = "</span><span class="token operator">&lt;&lt;</span> x <span class="token operator">&lt;&lt;</span> <span class="token string">" y = "</span> <span class="token operator">&lt;&lt;</span> y <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span>
        <span class="token keyword">return</span> x <span class="token operator">*</span> y<span class="token punctuation">;</span>
    <span class="token punctuation">}</span><span class="token punctuation">;</span>
    <span class="token keyword">int</span> a <span class="token operator">=</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span><span class="token string">"bar2 foo() = "</span><span class="token operator">&lt;&lt;</span> a <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span>
    std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span><span class="token string">"bar2 x = "</span> <span class="token operator">&lt;&lt;</span> x <span class="token operator">&lt;&lt;</span> <span class="token string">" y = "</span> <span class="token operator">&lt;&lt;</span> y <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">void</span> <span class="token function">bar3</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
    <span class="token keyword">int</span> x <span class="token operator">=</span> <span class="token number">5</span><span class="token punctuation">,</span> y <span class="token operator">=</span> <span class="token number">8</span><span class="token punctuation">;</span>
    <span class="token keyword">auto</span> foo <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token operator">&amp;</span>x<span class="token punctuation">,</span> <span class="token operator">&amp;</span>y<span class="token punctuation">]</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        x <span class="token operator">+=</span> <span class="token number">1</span><span class="token punctuation">;</span>
        y <span class="token operator">+=</span> <span class="token number">2</span><span class="token punctuation">;</span>
        std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span><span class="token string">"bar3 in lambda x = "</span><span class="token operator">&lt;&lt;</span> x <span class="token operator">&lt;&lt;</span> <span class="token string">" y = "</span> <span class="token operator">&lt;&lt;</span> y <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span>
        <span class="token keyword">return</span> x <span class="token operator">*</span> y<span class="token punctuation">;</span>
    <span class="token punctuation">}</span><span class="token punctuation">;</span>
    <span class="token keyword">int</span> a <span class="token operator">=</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span><span class="token string">"bar3 foo() = "</span><span class="token operator">&lt;&lt;</span> a <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span>
    std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span><span class="token string">"bar3 x = "</span> <span class="token operator">&lt;&lt;</span> x <span class="token operator">&lt;&lt;</span> <span class="token string">" y = "</span> <span class="token operator">&lt;&lt;</span> y <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
    <span class="token function">bar2</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">bar3</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>输出：</p> 
<pre><code class="prism language-cpp">bar2 in lambda x <span class="token operator">=</span> <span class="token number">6</span> y <span class="token operator">=</span> <span class="token number">10</span>
bar2 <span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token number">60</span>
bar2 x <span class="token operator">=</span> <span class="token number">5</span> y <span class="token operator">=</span> <span class="token number">8</span>

bar3 in lambda x <span class="token operator">=</span> <span class="token number">6</span> y <span class="token operator">=</span> <span class="token number">10</span>
bar3 <span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token number">60</span>
bar3 x <span class="token operator">=</span> <span class="token number">6</span> y <span class="token operator">=</span> <span class="token number">10</span>
</code></pre> 
<p>从上面代码输出可以看出，使用按值捕获+<code>mutable</code> 的方式修改lambda内部的<code>x</code>和<code>y</code>的值不会影响外部的<code>x</code>和<code>y</code>的值，而使用按引用捕获的方式修改lambda内部的<code>x</code>和<code>y</code>的值会影响外部的<code>x</code>和<code>y</code>的值。</p> 
<p>对于<strong>捕获值</strong>的<code>lambda</code>表达式还有一点需要注意，捕获值的变量在<code>lambda</code>表达式定义的时候已经固定下来了，无论函数在<code>lambda</code>表达式定义后如何修改外部变量的值，<code>lambda</code>表达式捕获的值都不会变化，例如：</p> 
<pre><code class="prism language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream&gt;</span></span>
<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
    <span class="token keyword">int</span> x <span class="token operator">=</span> <span class="token number">5</span><span class="token punctuation">,</span> y <span class="token operator">=</span> <span class="token number">8</span><span class="token punctuation">;</span>
    <span class="token keyword">auto</span> foo <span class="token operator">=</span> <span class="token punctuation">[</span>x<span class="token punctuation">,</span> <span class="token operator">&amp;</span>y<span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">mutable</span> <span class="token punctuation">{<!-- --></span>
        x <span class="token operator">+=</span> <span class="token number">1</span><span class="token punctuation">;</span>
        y <span class="token operator">+=</span> <span class="token number">2</span><span class="token punctuation">;</span>
        std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"lambda x = "</span> <span class="token operator">&lt;&lt;</span> x <span class="token operator">&lt;&lt;</span> <span class="token string">", y = "</span> <span class="token operator">&lt;&lt;</span> y <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span>
        <span class="token keyword">return</span> x <span class="token operator">*</span> y<span class="token punctuation">;</span>
    <span class="token punctuation">}</span><span class="token punctuation">;</span>
    x <span class="token operator">=</span> <span class="token number">9</span><span class="token punctuation">;</span>
    y <span class="token operator">=</span> <span class="token number">20</span><span class="token punctuation">;</span>
    <span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>运行结果如下：</p> 
<pre><code class="prism language-cpp">lambda x <span class="token operator">=</span> <span class="token number">6</span><span class="token punctuation">,</span> y <span class="token operator">=</span> <span class="token number">22</span>
</code></pre> 
<p>在上面的代码中，虽然在调用<code>foo</code>之前分别修改了<code>x</code>和<code>y</code>的值，但是<strong>捕获值</strong>的变量<code>x</code>依然延续着<code>lambda</code>定义时的值，而在<strong>捕获引用</strong>的变量<code>y</code>被重新赋值以后，<code>lambda</code>表达式捕获的变量<code>y</code>的值也跟着发生了变化。</p> 
<h4><a id="_2139"></a>特殊的捕获方法</h4> 
<p><code>lambda</code>表达式的捕获列表除了指定捕获变量之外还有3种特殊的捕获方法。</p> 
<ol><li><code>[this]</code> —— 捕获<code>this</code>指针，捕获<code>this</code>指针可以让我们使用<code>this</code>类型的成员变量和函数。</li><li><code>[=]</code> —— 捕获<code>lambda</code>表达式定义作用域的全部变量的<strong>值</strong>，包括<code>this</code>。</li><li><code>[&amp;]</code> —— 捕获<code>lambda</code>表达式定义作用域的全部变量的<strong>引用</strong>，包括<code>this</code>。</li></ol> 
<p>首先来看看捕获<code>this</code>的情况：</p> 
<pre><code class="prism language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream&gt;</span></span>
<span class="token keyword">class</span> <span class="token class-name">A</span>
<span class="token punctuation">{<!-- --></span>
<span class="token keyword">public</span><span class="token operator">:</span>
	<span class="token keyword">void</span> <span class="token function">print</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
	<span class="token punctuation">{<!-- --></span>
		std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"class A"</span> <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
	
	<span class="token keyword">void</span> <span class="token function">test</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
	<span class="token punctuation">{<!-- --></span>
		<span class="token keyword">auto</span> foo <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token keyword">this</span><span class="token punctuation">]</span> <span class="token punctuation">{<!-- --></span>
			<span class="token function">print</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
			x <span class="token operator">=</span> <span class="token number">5</span><span class="token punctuation">;</span>
		<span class="token punctuation">}</span><span class="token punctuation">;</span>
		<span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
<span class="token keyword">private</span><span class="token operator">:</span>
	<span class="token keyword">int</span> x<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	A a<span class="token punctuation">;</span>
	a<span class="token punctuation">.</span><span class="token function">test</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>在上面的代码中，因为<code>lambda</code>表达式捕获了<code>this</code>指针，所以可以在<code>lambda</code>表达式内调用该类型的成员函数<code>print</code>或者使用其成员变量<code>x</code>。</p> 
<p>捕获全部变量的值或引用则更容易理解：</p> 
<pre><code class="prism language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream&gt;</span></span>
<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token keyword">int</span> x <span class="token operator">=</span> <span class="token number">5</span><span class="token punctuation">,</span> y <span class="token operator">=</span> <span class="token number">8</span><span class="token punctuation">;</span>
	<span class="token keyword">auto</span> foo <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token operator">=</span><span class="token punctuation">]</span> <span class="token punctuation">{<!-- --></span> <span class="token keyword">return</span> x <span class="token operator">*</span> y<span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>
	std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>以上代码并没有指定需要捕获的变量，而是使用<code>[=]</code>捕获所有变量的值，这样在<code>lambda</code>表达式内也能访问<code>x</code>和<code>y</code>的值。同理，使用<code>[&amp;]</code>也会有同样的效果，读者不妨自己尝试一下。</p> 
<h3><a id="3_lambda__2193"></a>3. lambda 表达式的实现原理</h3> 
<p>如果读者是一个C++的老手，可能已经发现<code>lambda</code>表达式与<strong>函数对象</strong>（<strong>仿函数</strong>）非常相似，所以让我们从函数对象开始深入探讨<code>lambda</code>表达式的实现原理。请看下面的例子：</p> 
<pre><code class="prism language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream&gt;</span></span>

<span class="token keyword">class</span> <span class="token class-name">Bar</span>
<span class="token punctuation">{<!-- --></span>
<span class="token keyword">public</span><span class="token operator">:</span>
	<span class="token function">Bar</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">,</span> <span class="token keyword">int</span> y<span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token function">x_</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">y_</span><span class="token punctuation">(</span>y<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span><span class="token punctuation">}</span>
	<span class="token keyword">int</span> <span class="token keyword">operator</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token punctuation">)</span>
	<span class="token punctuation">{<!-- --></span>
		<span class="token keyword">return</span> x_ <span class="token operator">*</span> y_<span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
<span class="token keyword">private</span><span class="token operator">:</span>
	<span class="token keyword">int</span> x_<span class="token punctuation">;</span>
	<span class="token keyword">int</span> y_<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token keyword">int</span> x <span class="token operator">=</span> <span class="token number">5</span><span class="token punctuation">,</span> y <span class="token operator">=</span> <span class="token number">8</span><span class="token punctuation">;</span>
	<span class="token keyword">auto</span> foo <span class="token operator">=</span> <span class="token punctuation">[</span>x<span class="token punctuation">,</span> y<span class="token punctuation">]</span> <span class="token punctuation">{<!-- --></span> <span class="token keyword">return</span> x <span class="token operator">*</span> y<span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>
	Bar <span class="token function">bar</span><span class="token punctuation">(</span>x<span class="token punctuation">,</span> y<span class="token punctuation">)</span><span class="token punctuation">;</span>
	std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"foo() = "</span> <span class="token operator">&lt;&lt;</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span>
	std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"bar() = "</span> <span class="token operator">&lt;&lt;</span> <span class="token function">bar</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>在上面的代码中，<code>foo</code>是一个<code>lambda</code>表达式，而<code>bar</code>是一个函数对象。它们都能在初始化的时候获取<code>main</code>函数中变量<code>x</code>和<code>y</code>的值，并在调用之后返回相同的结果。这两者比较明显的区别如下：</p> 
<ol><li>使用<code>lambda</code>表达式不需要我们去显式定义一个类，这一点在快速实现功能上有较大的优势。</li><li>使用函数对象可以在初始化的时候有更加丰富的操作，例如<code>Bar bar(x+y, x * y)</code>，而这个操作在C++11标准的<code>lambda</code>表达式中是不允许的。另外，在<code>Bar</code>初始化对象的时候使用全局或者静态局部变量也是没有问题的。</li></ol> 
<p>这样看来在C++11标准中，<code>lambda</code>表达式的优势在于书写简单方便且易于维护，而函数对象的优势在于使用更加灵活不受限制，但总的来说它们非常相似。而实际上这也正是<code>lambda</code>表达式的实现原理。</p> 
<p><code>lambda</code>表达式在<strong>编译期</strong>会由编译器自动生成一个<strong>闭包类</strong>，在运行时由这个闭包类产生一个对象，我们称它为<strong>闭包</strong>。在C++中，所谓的闭包可以简单地理解为<strong>一个匿名且可以包含定义时作用域上下文的函数对象</strong>。现在让我们抛开这些概念，观察lambda表达式究竟是什么样子的。</p> 
<p>首先，定义一个简单的<code>lambda</code>表达式：</p> 
<pre><code class="prism language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream&gt;</span></span>
<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token keyword">int</span> x <span class="token operator">=</span> <span class="token number">5</span><span class="token punctuation">,</span> y <span class="token operator">=</span> <span class="token number">8</span><span class="token punctuation">;</span>
	<span class="token keyword">auto</span> foo <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token operator">=</span><span class="token punctuation">]</span> <span class="token punctuation">{<!-- --></span> <span class="token keyword">return</span> x <span class="token operator">*</span> y<span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>
	<span class="token keyword">int</span> z <span class="token operator">=</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>接着，我们用<code>GCC</code>输出其<code>GIMPLE</code>的中间代码：</p> 
<pre><code class="prism language-cpp"><span class="token function">main</span> <span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
    <span class="token keyword">int</span> D<span class="token punctuation">.</span><span class="token number">39253</span><span class="token punctuation">;</span>
    <span class="token punctuation">{<!-- --></span>
        <span class="token keyword">int</span> x<span class="token punctuation">;</span>
        <span class="token keyword">int</span> y<span class="token punctuation">;</span>
        <span class="token keyword">struct</span> <span class="token class-name">__lambda0</span> foo<span class="token punctuation">;</span>
        <span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token class-name">__lambda0</span> __lambda0<span class="token punctuation">;</span>
        <span class="token keyword">int</span> z<span class="token punctuation">;</span>
        <span class="token keyword">try</span>
        <span class="token punctuation">{<!-- --></span>
            x <span class="token operator">=</span> <span class="token number">5</span><span class="token punctuation">;</span>
            y <span class="token operator">=</span> <span class="token number">8</span><span class="token punctuation">;</span>
            foo<span class="token punctuation">.</span>__x <span class="token operator">=</span> x<span class="token punctuation">;</span>
            foo<span class="token punctuation">.</span>__y <span class="token operator">=</span> y<span class="token punctuation">;</span>
            z <span class="token operator">=</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token double-colon punctuation">::</span><span class="token operator">&lt;</span><span class="token function">lambda</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">&gt;</span><span class="token double-colon punctuation">::</span><span class="token keyword">operator</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token operator">&amp;</span>foo<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        finally
        <span class="token punctuation">{<!-- --></span>
            foo <span class="token operator">=</span> <span class="token punctuation">{<!-- --></span>CLOBBER<span class="token punctuation">}</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
    D<span class="token punctuation">.</span><span class="token number">39253</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> D<span class="token punctuation">.</span><span class="token number">39253</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token double-colon punctuation">::</span><span class="token operator">&lt;</span><span class="token function">lambda</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">&gt;</span><span class="token double-colon punctuation">::</span><span class="token keyword">operator</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">struct</span> <span class="token class-name">__lambda0</span> <span class="token operator">*</span> <span class="token keyword">const</span> __closure<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
    <span class="token keyword">int</span> D<span class="token punctuation">.</span><span class="token number">39255</span><span class="token punctuation">;</span>
    <span class="token keyword">const</span> <span class="token keyword">int</span> x <span class="token punctuation">[</span>value<span class="token operator">-</span>expr<span class="token operator">:</span> __closure<span class="token operator">-&gt;</span>__x<span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token keyword">const</span> <span class="token keyword">int</span> y <span class="token punctuation">[</span>value<span class="token operator">-</span>expr<span class="token operator">:</span> __closure<span class="token operator">-&gt;</span>__y<span class="token punctuation">]</span><span class="token punctuation">;</span>
    _1 <span class="token operator">=</span> __closure<span class="token operator">-&gt;</span>__x<span class="token punctuation">;</span>
    _2 <span class="token operator">=</span> __closure<span class="token operator">-&gt;</span>__y<span class="token punctuation">;</span>
    D<span class="token punctuation">.</span><span class="token number">39255</span> <span class="token operator">=</span> _1 <span class="token operator">*</span> _2<span class="token punctuation">;</span>
    <span class="token keyword">return</span> D<span class="token punctuation">.</span><span class="token number">39255</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>从上面的中间代码可以看出<code>lambda</code>表达式的类型名为<code>__lambda0</code>，通过这个类型实例化了对象<code>foo</code>，然后在函数内对<code>foo</code>对象的成员<code>__x</code>和<code>__y</code>进行赋值，最后通过自定义的<code>()</code>运算符对表达式执行计算并将结果赋值给变量<code>z</code>。在这个过程中，<code>__lambda0</code>是一个拥有<code>operator()</code>自定义运算符的结构体，这也正是函数对象类型的特性。所以，在某种程度上来说，<code>lambda</code>表达式是C++11给我们提供的一块语法糖而已，<code>lambda</code>表达式的功能完全能够手动实现，而且如果实现合理，代码在运行效率上也不会有差距，只不过实用<code>lambda</code>表达式让代码编写更加轻松了。</p> 
<blockquote> 
 <p>我们也可以复制上面的代码到<a href="https://cppinsights.io/" rel="nofollow">https://cppinsights.io/</a>这个网站上运行来探查其内部的实现原理。</p> 
</blockquote> 
<h3><a id="4__lambda__2286"></a>4. 无状态 lambda 表达式</h3> 
<p>C++标准对于无状态的<code>lambda</code>表达式有着特殊的照顾，即它可以<strong>隐式</strong>转换为<strong>函数指针</strong>，例如：</p> 
<pre><code class="prism language-cpp"><span class="token keyword">void</span> <span class="token function">f</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">(</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span><span class="token punctuation">}</span>
<span class="token keyword">void</span> <span class="token function">g</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span> <span class="token function">f</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token punctuation">{<!-- --></span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>  <span class="token comment">// 编译成功</span>
</code></pre> 
<p>在上面的代码中，<code>lambda</code>表达式<code>[] {}</code>隐式转换为<code>void(*)()</code>类型的函数指针。同样，看下面的代码：</p> 
<pre><code class="prism language-cpp"><span class="token keyword">void</span> <span class="token function">f</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">(</span><span class="token operator">&amp;</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span><span class="token punctuation">}</span>
<span class="token keyword">void</span> <span class="token function">g</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span> <span class="token function">f</span><span class="token punctuation">(</span><span class="token operator">*</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token punctuation">{<!-- --></span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>
</code></pre> 
<p>这段代码也可以顺利地通过编译。我们经常会在<code>STL</code>的代码中遇到<code>lambda</code>表达式的这种应用。</p> 
<h3><a id="5__STL__lambda__2302"></a>5. 在 STL 中使用 lambda 表达式</h3> 
<p>要探讨<code>lambda</code>表达式的常用场合，就必须讨论C++的标准库<code>STL</code>。在<code>STL</code>中我们常常会见到这样一些算法函数，它们的形参需要传入一个函数指针或函数对象从而完成整个算法，例如<code>std::sort</code>、<code>std::find_if</code>等。</p> 
<p>在C++11标准以前，我们通常需要在函数外部定义一个辅助函数或辅助函数对象类型。对于简单的需求，我们也可能使用<code>STL</code>提供的辅助函数，例如<code>std::less</code>、<code>std::plus</code>等。另外，针对稍微复杂一点的需求还可能会用到<code>std::bind1st</code>、<code>std::bind2nd</code>等函数。总之，无论使用以上的哪种方法，表达起来都相当晦涩。</p> 
<p>幸运的是，在有了<code>lambda</code>表达式以后，这些问题就迎刃而解了。我们可以直接在<code>STL</code>算法函数的参数列表内实现辅助函数，例如：</p> 
<pre><code class="prism language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;vector&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;algorithm&gt;</span></span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
    std<span class="token double-colon punctuation">::</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span> x <span class="token operator">=</span> <span class="token punctuation">{<!-- --></span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
    std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token operator">*</span>std<span class="token double-colon punctuation">::</span><span class="token function">find_if</span><span class="token punctuation">(</span>x<span class="token punctuation">.</span><span class="token function">cbegin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>x<span class="token punctuation">.</span><span class="token function">cend</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
                             <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span> <span class="token keyword">return</span> <span class="token punctuation">(</span>i <span class="token operator">%</span> <span class="token number">3</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>函数<code>std::find_if</code>需要一个辅助函数帮助确定需要找出的值，而这里我们使用<code>lambda</code>表达式直接在传参时定义了辅助函数。无论是编写还是阅读代码，直接定义<code>lambda</code>表达式都比定义辅助函数更加简洁且容易理解。</p> 
<h3><a id="6__2324"></a>6. 广义捕获</h3> 
<p>C++14标准中定义了广义捕获，所谓广义捕获实际上是两种捕获方式，第一种称为简单捕获，这种捕获就是我们在前文中提到的捕获方法，即<code>[identifier]</code>、<code>[&amp;identifier]</code>以及<code>[this]</code>等。第二种叫作初始化捕获，这种捕获方式是在C++14标准中引入的，它解决了简单捕获的一个重要问题，即只能捕获<code>lambda</code>表达式定义上下文的变量，而无法捕获表达式结果以及自定义捕获变量名，比如：</p> 
<pre><code class="prism language-cpp"><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token keyword">int</span> x <span class="token operator">=</span> <span class="token number">5</span><span class="token punctuation">;</span>
	<span class="token keyword">auto</span> foo <span class="token operator">=</span> <span class="token punctuation">[</span>x <span class="token operator">=</span> x <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">{<!-- --></span> <span class="token keyword">return</span> x<span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>以上在C++14标准之前是无法编译通过的，因为C++11标准只支持简单捕获。而C++14标准对这样的捕获进行了支持，在这段代码里捕获列表是一个赋值表达式，不过这个赋值表达式有点特殊，因为它通过等号跨越了两个作用域。等号左边的变量<code>x</code>存在于<code>lambda</code>表达式的作用域，而等号右边<code>x</code>存在于<code>main</code>函数的作用域。如果读者觉得两个<code>x</code>的写法有些绕，我们还可以采用更清晰的写法：</p> 
<pre><code class="prism language-cpp"><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token keyword">int</span> x <span class="token operator">=</span> <span class="token number">5</span><span class="token punctuation">;</span>
	<span class="token keyword">auto</span> foo <span class="token operator">=</span> <span class="token punctuation">[</span>r <span class="token operator">=</span> x <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">{<!-- --></span> <span class="token keyword">return</span> r<span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>很明显这里的变量<code>r</code>只存在于<code>lambda</code>表达式，如果此时在<code>lambda</code>表达式函数体里使用变量<code>x</code>，则会出现编译错误。初始化捕获在某些场景下是非常实用的，这里举两个例子，第一个场景是使用移动操作减少代码运行的开销，例如：</p> 
<pre><code class="prism language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;string&gt;</span></span>
<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	std<span class="token double-colon punctuation">::</span>string x <span class="token operator">=</span> <span class="token string">"hello c++ "</span><span class="token punctuation">;</span>
	<span class="token keyword">auto</span> foo <span class="token operator">=</span> <span class="token punctuation">[</span>x <span class="token operator">=</span> std<span class="token double-colon punctuation">::</span><span class="token function">move</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">{<!-- --></span> <span class="token keyword">return</span> x <span class="token operator">+</span> <span class="token string">"world"</span><span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>上面这段代码使用<code>std::move</code>对捕获列表变量<code>x</code>进行初始化，这样避免了简单捕获的复制对象操作，代码运行效率得到了提升。</p> 
<p>第二个场景是在异步调用时复制<code>this</code>对象，防止<code>lambda</code>表达式被调用时因原始<code>this</code>对象被析构造成未定义的行为，比如：</p> 
<pre><code class="prism language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;future&gt;</span></span>

<span class="token keyword">class</span> <span class="token class-name">Work</span>
<span class="token punctuation">{<!-- --></span>
<span class="token keyword">private</span><span class="token operator">:</span>
    <span class="token keyword">int</span> value<span class="token punctuation">;</span>
<span class="token keyword">public</span><span class="token operator">:</span>
    <span class="token function">Work</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token function">value</span><span class="token punctuation">(</span><span class="token number">42</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span><span class="token punctuation">}</span>
    std<span class="token double-colon punctuation">::</span>future<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span> <span class="token function">spawn</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token punctuation">{<!-- --></span>
        <span class="token keyword">return</span> std<span class="token double-colon punctuation">::</span><span class="token function">async</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token operator">=</span><span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token keyword">int</span> <span class="token punctuation">{<!-- --></span> <span class="token keyword">return</span> value<span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

std<span class="token double-colon punctuation">::</span>future<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
    Work tmp<span class="token punctuation">;</span>
    <span class="token keyword">return</span> tmp<span class="token punctuation">.</span><span class="token function">spawn</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
    std<span class="token double-colon punctuation">::</span>future<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span> f <span class="token operator">=</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    f<span class="token punctuation">.</span><span class="token function">wait</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"f.get() = "</span> <span class="token operator">&lt;&lt;</span> f<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>输出结果如下：</p> 
<pre><code class="prism language-cpp">f<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token number">32766</span>
</code></pre> 
<blockquote> 
 <p>注意，书中这里说输出 <code>f.get() = 32766</code>，但是我使用 CLion 按C++17标准运行输出是<code>f.get() = 42</code>，不知道为什么。不过可以通过加入一个析构函数中清空<code>value</code>的值同样能说明本节的问题：<code>~Work() { value = 0; }</code></p> 
</blockquote> 
<p>这里我们期待<code>f.get()</code>返回的结果是<code>42</code>，而实际上返回了<code>32766</code>，这就是一个未定义的行为，它造成了程序的计算错误，甚至有可能让程序崩溃。为了解决这个问题，我们引入初始化捕获的特性，将对象复制到<br> <code>lambda</code>表达式内，让我们简单修改一下<code>spawn</code>函数：</p> 
<pre><code class="prism language-cpp"><span class="token keyword">class</span> <span class="token class-name">Work</span>
<span class="token punctuation">{<!-- --></span>
<span class="token keyword">private</span><span class="token operator">:</span>
    <span class="token keyword">int</span> value<span class="token punctuation">;</span>
<span class="token keyword">public</span><span class="token operator">:</span>
    <span class="token function">Work</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token function">value</span><span class="token punctuation">(</span><span class="token number">42</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span><span class="token punctuation">}</span>
    std<span class="token double-colon punctuation">::</span>future<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span> <span class="token function">spawn</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token punctuation">{<!-- --></span>
        <span class="token keyword">return</span> std<span class="token double-colon punctuation">::</span><span class="token function">async</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token operator">=</span><span class="token punctuation">,</span> tmp <span class="token operator">=</span> <span class="token operator">*</span><span class="token keyword">this</span><span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token keyword">int</span> <span class="token punctuation">{<!-- --></span> <span class="token keyword">return</span> tmp<span class="token punctuation">.</span>value<span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre> 
<p>以上代码使用初始化捕获，将<code>*this</code> 复制到 <code>tmp</code> 对象中，然后在函数体内返回 <code>tmp</code> 对象的 <code>value</code>。由于整个对象通过复制的方式传递到<code>lambda</code>表达式内，因此即使 <code>this</code> 所指的对象析构了也不会影响lambda表达式的计算。编译运行修改后的代码，程序正确地输出 <code>f.get() = 42</code>。</p> 
<h3><a id="7__lambda__2413"></a>7. 泛型 lambda 表达式</h3> 
<p>C++14标准让<code>lambda</code>表达式具备了模版函数的能力，我们称它为泛型<code>lambda</code>表达式。虽然具备模版函数的能力，但是它的定义方式却用不到<code>template</code>关键字。实际上泛型<code>lambda</code>表达式语法要简单很多，我们只需要使用<code>auto</code>占位符即可，例如：</p> 
<pre><code class="prism language-cpp"><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token keyword">auto</span> foo <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token keyword">auto</span> a<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span> <span class="token keyword">return</span> a<span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>
	<span class="token keyword">int</span> three <span class="token operator">=</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">char</span> <span class="token keyword">const</span><span class="token operator">*</span> hello <span class="token operator">=</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token string">"hello"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>由于泛型<code>lambda</code>表达式更多地利用了<code>auto</code>占位符的特性，而<code>lambda</code>表达式本身并没有什么变化，因此想更多地理解泛型<code>lambda</code>表达式，可以阅读第3章，这里就不再赘述了。</p> 
<h3><a id="8__lambda__this_2427"></a>8. 常量 lambda 表达式和捕获 *this</h3> 
<p><strong>C++17</strong>标准对<code>lambda</code>表达式同样有两处增强，一处是常量<code>lambda</code>表达式，另一处是对捕获<code>this</code>的增强。其中常量<code>lambda</code>表达式的主要特性体现在<code>constexpr</code>关键字上，请阅读<code>constexpr</code>的有关章节来掌握常量<code>lambda</code>表达式的特性，这里主要说明一下对于捕获<code>this</code>的增强。</p> 
<p>还记得前面初始化捕获<code>*this</code>对象的代码吗？我们在捕获列表内复制了一份<code>this</code>指向的对象到<code>tmp</code>，然后使用<code>tmp</code>的<code>value</code>。没错，这样做确实解决了异步问题，但是这个解决方案并不优美。试想一下，如果在<code>lambda</code>表达式中用到了大量<code>this</code>指向的对象，那我们就不得不将它们全部修改，一旦遗漏就会引发问题。为了更方便地复制和使用<code>*this</code>对象，C++17增加了捕获列表的语法来简化这个操作，具体来说就是在捕获列表中直接添加<code>[*this]</code>，然后在<code>lambda</code>表达式函数体内直接使用<code>this</code>指向对象的成员，还是以前面的<code>Work</code>类为例：</p> 
<pre><code class="prism language-cpp"><span class="token keyword">class</span> <span class="token class-name">Work</span>
<span class="token punctuation">{<!-- --></span>
<span class="token keyword">private</span><span class="token operator">:</span>
    <span class="token keyword">int</span> value<span class="token punctuation">;</span>
    
<span class="token keyword">public</span><span class="token operator">:</span>
    <span class="token function">Work</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token function">value</span><span class="token punctuation">(</span><span class="token number">42</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span><span class="token punctuation">}</span>
    std<span class="token double-colon punctuation">::</span>future<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span> <span class="token function">spawn</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token punctuation">{<!-- --></span>
        <span class="token keyword">return</span> std<span class="token double-colon punctuation">::</span><span class="token function">async</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token operator">=</span><span class="token punctuation">,</span> <span class="token operator">*</span><span class="token keyword">this</span><span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token keyword">int</span> <span class="token punctuation">{<!-- --></span> <span class="token keyword">return</span> value<span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre> 
<p>在上面的代码中没有再使用<code>tmp=*this</code>来初始化捕获列表，而是直接使用<code>*this</code>。在<code>lambda</code>表达式内也没有再使用<code>tmp.value</code>而是直接返回了<code>value</code>。编译运行这段代码可以得到预期的结果<code>42</code>。从结果可以看出，<code>[*this]</code>的语法让程序生成了一个<code>*this</code>对象的副本并存储在lambda表达式内，可以在<code>lambda</code>表达式内直接访问这个复制对象的成员，消除了之前<code>lambda</code>表达式需要通过<code>tmp</code>访问对象成员的尴尬。</p> 
<h3><a id="9___this_2448"></a>9. 捕获 [=, this]</h3> 
<p>在C++20标准中，又对<code>lambda</code>表达式进行了小幅修改。这一次修改没有加强<code>lambda</code>表达式的能力，而是让<code>this</code>指针的相关语义更加明确。我们知道<code>[=]</code>可以捕获<code>this</code>指针，相似的，<code>[=,*this]</code>会捕获<code>this</code>对象的副本。但是在代码中大量出现<code>[=]</code>和<code>[=,*this]</code>的时候我们可能很容易忘记前者与后者的区别。为了解决这个问题，在C++20标准中引入了<code>[=, this]</code>捕获<code>this</code>指针的语法，它实际上表达的意思和<code>[=]</code>相同，目的是让程序员们区分它与<code>[=,*this]</code>的不同。</p> 
<pre><code class="prism language-cpp"><span class="token punctuation">[</span><span class="token operator">=</span><span class="token punctuation">,</span> <span class="token keyword">this</span><span class="token punctuation">]</span><span class="token punctuation">{<!-- --></span><span class="token punctuation">}</span><span class="token punctuation">;</span> <span class="token comment">// C++17 编译报错或者报警告， C++20成功编译</span>
</code></pre> 
<blockquote> 
 <p>我使用 CLion 按照 C++17 编译上面写法的代码没有报错，也没有警告，只是最终运行结果不正确。</p> 
</blockquote> 
<p>虽然在C++17标准中认为<code>[=, this]{};</code> 是有语法问题的，但是实践中GCC和CLang都只是给出了警告而并未报错。另外，在C++20标准中还特别强调了要用<code>[=, this]</code>代替<code>[=]</code>，如果用GCC编译下面这段代码：</p> 
<pre><code class="prism language-cpp"><span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">T</span><span class="token operator">&gt;</span>
<span class="token keyword">void</span> <span class="token function">g</span><span class="token punctuation">(</span>T<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span><span class="token punctuation">}</span>

<span class="token keyword">struct</span> <span class="token class-name">Foo</span> <span class="token punctuation">{<!-- --></span>
	<span class="token keyword">int</span> n <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
	<span class="token keyword">void</span> <span class="token function">f</span><span class="token punctuation">(</span><span class="token keyword">int</span> a<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
		<span class="token function">g</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token operator">=</span><span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token keyword">int</span> k<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span> <span class="token keyword">return</span> n <span class="token operator">+</span> a <span class="token operator">*</span> k<span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre> 
<p>编译器会输出警告信息，表示标准已经不再支持使用 <code>[=]</code> 隐式捕获 <code>this</code> 指针了，提示用户显式添加 <code>this</code> 或 <code>*this</code>。最后值得注意的是，同时用两种语法捕获 <code>this</code> 指针是不允许的，比如：</p> 
<pre><code class="prism language-cpp"><span class="token punctuation">[</span><span class="token keyword">this</span><span class="token punctuation">,</span> <span class="token operator">*</span><span class="token keyword">this</span><span class="token punctuation">]</span><span class="token punctuation">{<!-- --></span><span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre> 
<p>这种写法在CLang中一定会给出编译错误，而GCC则稍显温柔地给出警告，在我看来这种写法没有意义，是应该避免的。</p> 
<h3><a id="10__lambda__2476"></a>10. 模板语法的泛型 lambda 表达式</h3> 
<p>在7.7节中我们讨论了C++14标准中lambda表达式通过支持<code>auto</code>来实现泛型。大部分情况下，这是一种不错的特性，但不幸的是，这种语法也会使我们难以与类型进行互动，对类型的操作变得异常复杂。用提案文档的举例来说：</p> 
<pre><code class="prism language-cpp"><span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token class-name">T</span><span class="token operator">&gt;</span> <span class="token keyword">struct</span> <span class="token class-name">is_std_vector</span> <span class="token operator">:</span> <span class="token base-clause">std<span class="token double-colon punctuation">::</span><span class="token class-name">false_type</span></span> <span class="token punctuation">{<!-- --></span> <span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token class-name">T</span><span class="token operator">&gt;</span> <span class="token keyword">struct</span> <span class="token class-name">is_std_vector</span><span class="token operator">&lt;</span>std<span class="token double-colon punctuation">::</span>vector<span class="token operator">&lt;</span>T<span class="token operator">&gt;&gt;</span> <span class="token operator">:</span> std<span class="token double-colon punctuation">::</span>true_type <span class="token punctuation">{<!-- --></span> <span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">auto</span> f <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token keyword">auto</span> vector<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
	<span class="token keyword">static_assert</span><span class="token punctuation">(</span>is_std_vector<span class="token operator">&lt;</span><span class="token keyword">decltype</span><span class="token punctuation">(</span>vector<span class="token punctuation">)</span><span class="token operator">&gt;</span><span class="token double-colon punctuation">::</span>value<span class="token punctuation">,</span> <span class="token string">""</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre> 
<p>普通的函数模板可以轻松地通过形参模式匹配一个实参为 <code>vector</code> 的容器对象，但是对于 <code>lambda</code> 表达式，<code>auto</code> 不具备这种表达能力，所以不得不实现 <code>is_std_vector</code>，并且通过 <code>static_assert</code> 来辅助判断实参的真实类型是否为 <code>vector</code>。在 C++ 委员会的专家看来，把一个本可以通过模板推导完成的任务交给 <code>static_assert</code> 来完成是不合适的。除此之外，这样的语法让获取 <code>vector</code> 存储对象的类型也变得十分复杂，比如：</p> 
<pre><code class="prism language-cpp"><span class="token keyword">auto</span> f <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token keyword">auto</span> vector<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
	<span class="token keyword">using</span> T <span class="token operator">=</span> <span class="token keyword">typename</span> <span class="token keyword">decltype</span><span class="token punctuation">(</span>vector<span class="token punctuation">)</span><span class="token double-colon punctuation">::</span>value_type<span class="token punctuation">;</span>
	<span class="token comment">// …</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre> 
<p>当然，能这样实现已经是很侥幸了。我们知道 <code>vector</code> 容器类型通常使用内嵌类型 <code>value_type</code> 表示存储对象的类型。但我们不能保证面对的所有容器都会遵循这一规则，因此依赖内嵌类型是不可靠的。</p> 
<p>进一步来说，<code>decltype(obj)</code> 有时不能直接获取我们所需的类型。不记得<code>decltype</code>推导规则的读者可以复习一下前面的章节，这里就直接说明示例代码：</p> 
<pre><code class="prism language-cpp"><span class="token keyword">auto</span> f <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">auto</span><span class="token operator">&amp;</span> x<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
	<span class="token keyword">using</span> T <span class="token operator">=</span> <span class="token keyword">decltype</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span>
	T copy <span class="token operator">=</span> x<span class="token punctuation">;</span> <span class="token comment">// 可以编译，但是语义错误</span>
	<span class="token keyword">using</span> Iterator <span class="token operator">=</span> <span class="token keyword">typename</span> <span class="token class-name">T</span><span class="token double-colon punctuation">::</span>iterator<span class="token punctuation">;</span> <span class="token comment">// 编译错误</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

std<span class="token double-colon punctuation">::</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span> v<span class="token punctuation">;</span>
<span class="token function">f</span><span class="token punctuation">(</span>v<span class="token punctuation">)</span>
</code></pre> 
<p>请注意，在上面的代码中，<code>decltype(x)</code> 推导出的类型并不是 <code>std::vector</code>，而是 <code>const std::vector&amp;</code>，所以 <code>T copy = x;</code> 不是一个复制操作而是引用。对于一个引用类型，<code>T::iterator</code> 也是不符合语法的，所以会导致编译错误。在提案文档中，作者使用了 STL 的 <code>decay</code>，这样可以删除类型的常量性（<code>cv</code>）以及引用属性，于是就有了下面的代码：</p> 
<pre><code class="prism language-cpp"><span class="token keyword">auto</span> f <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">auto</span><span class="token operator">&amp;</span> x<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
	<span class="token keyword">using</span> T <span class="token operator">=</span> std<span class="token double-colon punctuation">::</span>decay_t<span class="token operator">&lt;</span><span class="token keyword">decltype</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token operator">&gt;</span><span class="token punctuation">;</span>
	T copy <span class="token operator">=</span> x<span class="token punctuation">;</span>
	<span class="token keyword">using</span> Iterator <span class="token operator">=</span> <span class="token keyword">typename</span> <span class="token class-name">T</span><span class="token double-colon punctuation">::</span>iterator<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre> 
<p>问题虽然解决了，但是要时刻注意<code>auto</code>，以免给代码带来意想不到的问题，况且这都是建立在容器本身设计得比较完善的情况下才能继续下去的。</p> 
<p>鉴于以上种种问题，C++委员会决定在C++20中添加模板对<code>lambda</code>的支持，语法非常简单：</p> 
<pre><code class="prism language-cpp"><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token class-name">T</span><span class="token operator">&gt;</span><span class="token punctuation">(</span>T t<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span><span class="token punctuation">}</span>
</code></pre> 
<p>于是，上面那些让我们为难的例子就可以改写为：</p> 
<pre><code class="prism language-cpp"><span class="token keyword">auto</span> f <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token class-name">T</span><span class="token operator">&gt;</span><span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span>vector<span class="token operator">&lt;</span>T<span class="token operator">&gt;</span> vector<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
	<span class="token comment">// …</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre> 
<p>以及</p> 
<pre><code class="prism language-cpp"><span class="token keyword">auto</span> f <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token class-name">T</span><span class="token operator">&gt;</span><span class="token punctuation">(</span>T <span class="token keyword">const</span><span class="token operator">&amp;</span> x<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
	T copy <span class="token operator">=</span> x<span class="token punctuation">;</span>
	<span class="token keyword">using</span> Iterator <span class="token operator">=</span> <span class="token keyword">typename</span> <span class="token class-name">T</span><span class="token double-colon punctuation">::</span>iterator<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre> 
<p>上面的代码是否能让读者眼前一亮？这些代码不仅简洁了很多，而且也更符合C++泛型编程的习惯。</p> 
<p>最后再说一个有趣的故事，事实上早在2012年，让<code>lambda</code>支持模板的提案文档N3418已经提交给了C++委员会，不过当时这份提案并没有被接受，到2013年N3559中提出的基于<code>auto</code>的泛型在C++14标准中实现，而2017年<code>lambda</code>支持模板的提案又一次被提出来，这一次可以说是踩在N3559的肩膀上成功地加入了C++20标准。回过头来看整个过程，虽说算不上曲折，但也颇为耐人寻味，C++作为一个发展近30年的语言，依然在不断地探索和纠错中砺志前行。</p> 
<h3><a id="11__lambda__2546"></a>11. 可构造和可赋值的无状态 lambda 表达式</h3> 
<p>在7.4节中我们提到了无状态<code>lambda</code>表达式可以转换为函数指针，但遗憾的是，在<code>C++20</code>标准之前无状态的<code>lambda</code>表达式类型既不能构造也无法赋值，这阻碍了许多应用的实现。举例来说，我们已经了解了像<code>std::sort</code>和<code>std::find_if</code>这样的函数需要一个函数对象或函数指针来辅助排序和查找，这种情况我们可以使用<code>lambda</code>表达式完成任务。但是如果遇到<code>std::map</code>这种容器类型就不好办了，因为<code>std::map</code>的比较函数对象是通过模板参数确定的，这个时候我们需要的是一个类型：</p> 
<pre><code class="prism language-cpp"><span class="token keyword">auto</span> greater <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token keyword">auto</span> x<span class="token punctuation">,</span> <span class="token keyword">auto</span> y<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span> <span class="token keyword">return</span> x <span class="token operator">&gt;</span> y<span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>
std<span class="token double-colon punctuation">::</span>map<span class="token operator">&lt;</span>std<span class="token double-colon punctuation">::</span>string<span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token punctuation">,</span> <span class="token keyword">decltype</span><span class="token punctuation">(</span>greater<span class="token punctuation">)</span><span class="token operator">&gt;</span> mymap<span class="token punctuation">;</span>
</code></pre> 
<p>这段代码的意图很明显，它首先定义了一个无状态的<code>lambda</code>表达式<code>greate</code>，然后使用<code>decltype(greater)</code>获取其类型作为模板实参传入模板。这个想法非常好，但是在<code>C++17</code>标准中是不可行的，因为<code>lambda</code>表达式类型无法构造。编译器会明确告知，<code>lambda</code>表达式的默认构造函数已经被删除了（“<code>note: a lambda closure type has a deleted defaultconstructor</code>”）。</p> 
<p>除了无法构造，无状态的<code>lambda</code>表达式也没办法赋值，比如：</p> 
<pre><code class="prism language-cpp"><span class="token keyword">auto</span> greater <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token keyword">auto</span> x<span class="token punctuation">,</span> <span class="token keyword">auto</span> y<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span> <span class="token keyword">return</span> x <span class="token operator">&gt;</span> y<span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>
std<span class="token double-colon punctuation">::</span>map<span class="token operator">&lt;</span>std<span class="token double-colon punctuation">::</span>string<span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token punctuation">,</span> <span class="token keyword">decltype</span><span class="token punctuation">(</span>greater<span class="token punctuation">)</span><span class="token operator">&gt;</span> mymap1<span class="token punctuation">,</span> mymap2<span class="token punctuation">;</span>
mymap1 <span class="token operator">=</span> mymap2<span class="token punctuation">;</span>
</code></pre> 
<p>这里<code>mymap1 = mymap2;</code>也会被编译器报错，原因是复制赋值函数也被删除了（“<code>note: a lambda closure type has a deleted copy assignmentoperator</code>”）。</p> 
<p>为了解决以上问题，C++20标准允许了无状态<code>lambda</code>表达式类型的构造和赋值，所以使用C++20标准的编译环境来编译上面的代码是可行的。</p> 
<h3><a id="_2567"></a>总结</h3> 
<p>在本章我们介绍了<code>lambda</code>表达式的语法、使用方法以及原理。总的来说<code>lambda</code>表达式不但容易使用，而且原理也容易理解。它很好地解决了过去C++中无法直接编写内嵌函数的尴尬。虽然在GCC中提供了一个叫作<code>nest function</code>的C语言扩展，这个扩展允许我们在函数内部编写内嵌函数，但这个特性一直没有被纳入标准当中。当然我们也并不用为此遗憾，因为现在提供的<code>lambda</code>表达式无论在语法简易程度上，还是用途广泛程度上都要优于<code>nest function</code>。合理地使用<code>lambda</code>表达式，可以让代码更加短小精悍的同时也具有良好的可读性。</p> 
<h2><a id="C11_C20_2571"></a>八、非静态数据成员默认初始化（C++11 C++20）</h2> 
<h3><a id="1__2573"></a>1. 使用默认初始化</h3> 
<p>在C++11以前，对非静态数据成员初始化需要用到初始化列表，当类的数据成员和构造函数较多时，编写构造函数会是一个令人头痛的问题：</p> 
<pre><code class="prism language-cpp"><span class="token keyword">class</span> <span class="token class-name">X</span> <span class="token punctuation">{<!-- --></span>
<span class="token keyword">public</span><span class="token operator">:</span>
	<span class="token function">X</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token function">a_</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">b_</span><span class="token punctuation">(</span><span class="token number">0.</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">c_</span><span class="token punctuation">(</span><span class="token string">"hello world"</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span><span class="token punctuation">}</span>
	<span class="token function">X</span><span class="token punctuation">(</span><span class="token keyword">int</span> a<span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token function">a_</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">b_</span><span class="token punctuation">(</span><span class="token number">0.</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">c_</span><span class="token punctuation">(</span><span class="token string">"hello world"</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span><span class="token punctuation">}</span>
	<span class="token function">X</span><span class="token punctuation">(</span><span class="token keyword">double</span> b<span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token function">a_</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">b_</span><span class="token punctuation">(</span>b<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">c_</span><span class="token punctuation">(</span><span class="token string">"hello world"</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span><span class="token punctuation">}</span>
	<span class="token function">X</span><span class="token punctuation">(</span><span class="token keyword">const</span> std<span class="token double-colon punctuation">::</span>string <span class="token operator">&amp;</span>c<span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token function">a_</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">b_</span><span class="token punctuation">(</span><span class="token number">0.</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">c_</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span><span class="token punctuation">}</span>
<span class="token keyword">private</span><span class="token operator">:</span>
	<span class="token keyword">int</span> a_<span class="token punctuation">;</span>
	<span class="token keyword">double</span> b_<span class="token punctuation">;</span>
	std<span class="token double-colon punctuation">::</span>string c_<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre> 
<p>在上面的代码中，类X有4个构造函数，为了在构造的时候初始化非静态数据成员，它们的初始化列表有一些冗余代码，而造成的后果是维护困难且容易出错。为了解决这种问题，C++11标准提出了新的初始化方法，即<strong>在声明非静态数据成员的同时直接对其使用<code>=</code>或者<code>{}</code>初始化</strong>（见第9章）。在此之前只有类型为整型或者枚举类型的常量静态数据成员才有这种声明默认初始化的待遇：</p> 
<pre><code class="prism language-cpp"><span class="token keyword">class</span> <span class="token class-name">X</span> <span class="token punctuation">{<!-- --></span>
<span class="token keyword">public</span><span class="token operator">:</span>
	<span class="token function">X</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span><span class="token punctuation">}</span>
	<span class="token function">X</span><span class="token punctuation">(</span><span class="token keyword">int</span> a<span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token function">a_</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span><span class="token punctuation">}</span>
	<span class="token function">X</span><span class="token punctuation">(</span><span class="token keyword">double</span> b<span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token function">b_</span><span class="token punctuation">(</span>b<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span><span class="token punctuation">}</span>
	<span class="token function">X</span><span class="token punctuation">(</span><span class="token keyword">const</span> std<span class="token double-colon punctuation">::</span>string <span class="token operator">&amp;</span>c<span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token function">c_</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span><span class="token punctuation">}</span>
<span class="token keyword">private</span><span class="token operator">:</span>
	<span class="token keyword">int</span> a_ <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
	<span class="token keyword">double</span> b_<span class="token punctuation">{<!-- --></span> <span class="token number">0.</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>
	std<span class="token double-colon punctuation">::</span>string c_<span class="token punctuation">{<!-- --></span> <span class="token string">"hello world"</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre> 
<p>以上代码使用了非静态数据成员默认初始化的方法，可以看到这种初始化的方式更加清晰合理，每个构造函数只需要专注于特殊成员的初始化，而其他的数据成员则默认使用声明时初始化的值。比如<code>X(conststd::string c)</code>这个构造函数，它只需要关心数据成员<code>c_</code>的初始化而不必初始化<code>a_</code>和<code>b_</code>。在初始化的优先级上有这样的规则，初始化列表对数据成员的初始化总是优先于声明时默认初始化。</p> 
<p>最后来看一看非静态数据成员在声明时默认初始化需要注意的两个问题。</p> 
<ol><li>不要使用括号<code>()</code>对非静态数据成员进行初始化，因为这样会造成解析问题，所以会编译错误。</li><li>不要用<code>auto</code>来声明和初始化非静态数据成员，虽然这一点看起来合理，但是C++并不允许这么做。</li></ol> 
<pre><code class="prism language-cpp"><span class="token keyword">struct</span> <span class="token class-name">X</span> <span class="token punctuation">{<!-- --></span>
	<span class="token keyword">int</span> <span class="token function">a</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment">// 编译错误，不能使用 () 进行默认初始化</span>
	<span class="token keyword">auto</span> b <span class="token operator">=</span> <span class="token number">8</span><span class="token punctuation">;</span> <span class="token comment">// 编译错误，不能使用 auto 声明和初始化非静态数据成员</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre> 
<h3><a id="2__2619"></a>2. 位域的默认初始化</h3> 
<p>在C++11标准提出非静态数据成员默认初始化方法之后，C++20标准又对该特性做了进一步扩充。在C++20中我们可以对数据成员的位域进行默认初始化了，例如：</p> 
<pre><code class="prism language-cpp"><span class="token keyword">struct</span> <span class="token class-name">S</span> <span class="token punctuation">{<!-- --></span>
	<span class="token keyword">int</span> y <span class="token operator">:</span> <span class="token number">8</span> <span class="token operator">=</span> <span class="token number">11</span><span class="token punctuation">;</span>
	<span class="token keyword">int</span> z <span class="token operator">:</span> <span class="token number">4</span> <span class="token punctuation">{<!-- --></span><span class="token number">7</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre> 
<p>在上面的代码中，<code>int</code>数据的低<code>8</code>位被初始化为<code>11</code>，紧跟它的高<code>4</code>位被初始化为<code>7</code>。</p> 
<p>位域的默认初始化语法很简单，但是也有一个需要注意的地方。当表示位域的常量表达式是一个条件表达式时我们就需要警惕了，例如：</p> 
<pre><code class="prism language-cpp"><span class="token keyword">int</span> a<span class="token punctuation">;</span>
<span class="token keyword">struct</span> <span class="token class-name">S2</span> <span class="token punctuation">{<!-- --></span>
	<span class="token keyword">int</span> y <span class="token operator">:</span> <span class="token boolean">true</span> <span class="token operator">?</span> <span class="token number">8</span> <span class="token operator">:</span> a <span class="token operator">=</span> <span class="token number">42</span><span class="token punctuation">;</span>
	<span class="token keyword">int</span> z <span class="token operator">:</span> <span class="token number">1</span> <span class="token operator">||</span> <span class="token keyword">new</span> <span class="token keyword">int</span> <span class="token punctuation">{<!-- --></span> <span class="token number">0</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre> 
<p>请注意，这段代码中并不存在默认初始化，因为最大化识别标识符的解析规则让<code>=42</code>和<code>{0}</code>不可能存在于解析的顶层。于是以上代码会被认为是：</p> 
<pre><code class="prism language-cpp"><span class="token keyword">int</span> a<span class="token punctuation">;</span>
<span class="token keyword">struct</span> <span class="token class-name">S2</span> <span class="token punctuation">{<!-- --></span>
	<span class="token keyword">int</span> y <span class="token operator">:</span> <span class="token punctuation">(</span><span class="token boolean">true</span> <span class="token operator">?</span> <span class="token number">8</span> <span class="token operator">:</span> a <span class="token operator">=</span> <span class="token number">42</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">int</span> z <span class="token operator">:</span> <span class="token punctuation">(</span><span class="token number">1</span> <span class="token operator">||</span> <span class="token keyword">new</span> <span class="token keyword">int</span> <span class="token punctuation">{<!-- --></span> <span class="token number">0</span> <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre> 
<p>所以我们可以通过使用括号明确代码被解析的优先级来解决这个问题：</p> 
<pre><code class="prism language-cpp"><span class="token keyword">int</span> a<span class="token punctuation">;</span>
<span class="token keyword">struct</span> <span class="token class-name">S2</span> <span class="token punctuation">{<!-- --></span>
	<span class="token keyword">int</span> y <span class="token operator">:</span> <span class="token punctuation">(</span><span class="token boolean">true</span> <span class="token operator">?</span> <span class="token number">8</span> <span class="token operator">:</span> a<span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token number">42</span><span class="token punctuation">;</span>
	<span class="token keyword">int</span> z <span class="token operator">:</span> <span class="token punctuation">(</span><span class="token number">1</span> <span class="token operator">||</span> <span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span> <span class="token number">0</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre> 
<p>通过以上方法就可以对<code>S2::y</code>和<code>S2::z</code>进行默认初始化了。</p> 
<h2><a id="C11_C20_2660"></a>九、列表初始化（C++11 C++20）</h2> 
<h3><a id="1__2662"></a>1. 回顾变量初始化</h3> 
<p>在介绍列表初始化之前，让我们先回顾一下初始化变量的传统方法。其中常见的是使用括号和等号在变量声明时对其初始化，例如：</p> 
<pre><code class="prism language-cpp"><span class="token keyword">struct</span> <span class="token class-name">C</span> <span class="token punctuation">{<!-- --></span>
	<span class="token function">C</span><span class="token punctuation">(</span><span class="token keyword">int</span> a<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span><span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token keyword">int</span> x <span class="token operator">=</span> <span class="token number">5</span><span class="token punctuation">;</span>
	<span class="token keyword">int</span> <span class="token function">x1</span><span class="token punctuation">(</span><span class="token number">8</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	C x2 <span class="token operator">=</span> <span class="token number">4</span><span class="token punctuation">;</span>
	C <span class="token function">x3</span><span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>一般来说，我们称使用括号初始化的方式叫作直接初始化，而使用等号初始化的方式叫作拷贝初始化（复制初始化）。请注意，这里使用等号对变量初始化并不是调用等号运算符的赋值操作。实际情况是，<strong>等号是拷贝初始化</strong>，调用的依然是直接初始化对应的构造函数，只不过这里是隐式调用而已。如果我们将<code>C(int a)</code>声明为<code>explicit</code>，那么<code>C x2= 4</code>就会编译失败。</p> 
<p>使用括号和等号只是直接初始化和拷贝初始化的代表，还有一些经常用到的初始化方式也属于它们。比如 <strong><code>new</code>运算符和类构造函数的初始化列表就属于直接初始化</strong>，而<strong>函数传参和<code>return</code>返回则是拷贝初始化</strong>。前者比较好理解，后者可以通过具体的例子来理解：</p> 
<pre><code class="prism language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;map&gt;</span></span>
<span class="token keyword">struct</span> <span class="token class-name">C</span> <span class="token punctuation">{<!-- --></span>
	<span class="token function">C</span><span class="token punctuation">(</span><span class="token keyword">int</span> a<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span><span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">void</span> <span class="token function">foo</span><span class="token punctuation">(</span>C c<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span><span class="token punctuation">}</span>

C <span class="token function">bar</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token keyword">return</span> <span class="token number">5</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token function">foo</span><span class="token punctuation">(</span><span class="token number">8</span><span class="token punctuation">)</span><span class="token punctuation">;</span> 	 <span class="token comment">// 拷贝初始化</span>
	C c <span class="token operator">=</span> <span class="token function">bar</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 拷贝初始化</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>这段代码中<code>foo</code>函数的传参和<code>bar</code>函数的返回都调用了隐式构造函数，是一个拷贝初始化。</p> 
<h3><a id="2__2705"></a>2. 使用列表初始化</h3> 
<p>C++11标准引入了列表初始化，它使用大括号<code>{}</code>对变量进行初始化，和传统变量初始化的规则一样，它也区分为<strong>直接初始化</strong>和<strong>拷贝初始化</strong>，例如：</p> 
<pre><code class="prism language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;string&gt;</span></span>

<span class="token keyword">struct</span> <span class="token class-name">C</span> <span class="token punctuation">{<!-- --></span>
	<span class="token function">C</span><span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span>string a<span class="token punctuation">,</span> <span class="token keyword">int</span> b<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span><span class="token punctuation">}</span>
	<span class="token function">C</span><span class="token punctuation">(</span><span class="token keyword">int</span> a<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span><span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">void</span> <span class="token function">foo</span><span class="token punctuation">(</span>C<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span><span class="token punctuation">}</span>

C <span class="token function">bar</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token keyword">return</span> <span class="token punctuation">{<!-- --></span><span class="token string">"world"</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token keyword">int</span> x <span class="token operator">=</span> <span class="token punctuation">{<!-- --></span><span class="token number">5</span><span class="token punctuation">}</span><span class="token punctuation">;</span>             <span class="token comment">// 拷贝初始化</span>
	<span class="token keyword">int</span> x1<span class="token punctuation">{<!-- --></span><span class="token number">8</span><span class="token punctuation">}</span><span class="token punctuation">;</span>               <span class="token comment">// 直接初始化</span>
	C x2 <span class="token operator">=</span> <span class="token punctuation">{<!-- --></span><span class="token number">4</span><span class="token punctuation">}</span><span class="token punctuation">;</span>              <span class="token comment">// 拷贝初始化</span>
	C x3<span class="token punctuation">{<!-- --></span><span class="token number">2</span><span class="token punctuation">}</span><span class="token punctuation">;</span>                 <span class="token comment">// 直接初始化</span>
	<span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">{<!-- --></span><span class="token number">8</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token comment">// 拷贝初始化</span>
	<span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">{<!-- --></span><span class="token string">"hello"</span><span class="token punctuation">,</span> <span class="token number">8</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>       <span class="token comment">// 拷贝初始化</span>
	C x4 <span class="token operator">=</span> <span class="token function">bar</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment">// 拷贝初始化</span>
	C <span class="token operator">*</span>x5 <span class="token operator">=</span> <span class="token keyword">new</span> C<span class="token punctuation">{<!-- --></span> <span class="token string">"hi"</span><span class="token punctuation">,</span> <span class="token number">42</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>  <span class="token comment">// 直接初始化</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>仔细观察以上代码会发现，列表初始化和传统的变量初始化几乎相同，除了<code>foo({"hello", 8})</code>和<code>return {"world", 5}</code>这两处不同。读者应该发现了列表初始化在这里的奥妙所在，它支持隐式调用多参数的构造函数，于是<code>{"hello", 8}</code>和<code>{"world", 5}</code>通过隐式调用构造函数<code>C::C(std::string a, int b)</code>成功构造了类<code>C</code>的对象。当然了，有时候我们并不希望编译器进行隐式构造，这时候只需要在特定构造函数上声明<code>explicit</code>即可。</p> 
<p>讨论使用大括号初始化变量就不得不提用大括号初始化数组，例如<code>int x[] = { 1, 2, 3, 4, 5 }</code>。不过遗憾的是，这个特性无法使用到<code>STL</code>的<code>vector</code>、<code>list</code>等容器中。想要初始化容器，我们不得不编写一个循环来完成初始化工作。现在，列表初始化将程序员从这个问题中解放了出来，我们可以使用列表初始化对标准容器进行初始化了，例如：</p> 
<pre><code class="prism language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;vector&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;list&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;set&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;map&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;string&gt;</span></span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token keyword">int</span> x<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{<!-- --></span> <span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">5</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>
	<span class="token keyword">int</span> x1<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">{<!-- --></span> <span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">5</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>
	std<span class="token double-colon punctuation">::</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span> x2<span class="token punctuation">{<!-- --></span> <span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">5</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>
	std<span class="token double-colon punctuation">::</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span> x3 <span class="token operator">=</span> <span class="token punctuation">{<!-- --></span> <span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">5</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>
	std<span class="token double-colon punctuation">::</span>list<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span> x4<span class="token punctuation">{<!-- --></span> <span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">5</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>
	std<span class="token double-colon punctuation">::</span>list<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span> x5 <span class="token operator">=</span> <span class="token punctuation">{<!-- --></span> <span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">5</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>
	std<span class="token double-colon punctuation">::</span>set<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span> x6<span class="token punctuation">{<!-- --></span> <span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">5</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>
	std<span class="token double-colon punctuation">::</span>set<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span> x7 <span class="token operator">=</span> <span class="token punctuation">{<!-- --></span> <span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">5</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>
	std<span class="token double-colon punctuation">::</span>map<span class="token operator">&lt;</span>std<span class="token double-colon punctuation">::</span>string<span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token operator">&gt;</span> x8<span class="token punctuation">{<!-- --></span> <span class="token punctuation">{<!-- --></span><span class="token string">"bear"</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token punctuation">{<!-- --></span><span class="token string">"cassowary"</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token punctuation">{<!-- --></span><span class="token string">"tiger"</span><span class="token punctuation">,</span><span class="token number">7</span><span class="token punctuation">}</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>
	std<span class="token double-colon punctuation">::</span>map<span class="token operator">&lt;</span>std<span class="token double-colon punctuation">::</span>string<span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token operator">&gt;</span> x9 <span class="token operator">=</span> <span class="token punctuation">{<!-- --></span> <span class="token punctuation">{<!-- --></span><span class="token string">"bear"</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token punctuation">{<!-- --></span><span class="token string">"cassowary"</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token punctuation">{<!-- --></span><span class="token string">"tiger"</span><span class="token punctuation">,</span><span class="token number">7</span><span class="token punctuation">}</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>以上代码在C++11环境下可以成功编译，可以看到使用列表初始化标准容器和初始化数组一样简单，唯一值得注意的地方是对<code>x8</code>和<code>x9</code>的初始化，因为它使用了列表初始化的一个特殊的特性。</p> 
<h3><a id="3_stdinitializer_list__2763"></a>3. std::initializer_list 详解</h3> 
<p>标准容器之所以能够支持列表初始化，离不开编译器支持的同时，它们自己也必须满足一个条件：支持<code>std::initializer_list</code>为形参的构造函数。<code>std::initializer_list</code>简单地说就是一个支持<code>begin</code>、<code>end</code>以及<code>size</code>成员函数的类模板，有兴趣的读者可以翻阅STL的源代码，然后会发现无论是它的结构还是函数都直截了当。编译器负责将列表里的元素（大括号包含的内容）构造为一个<code>std::initializer_list</code>的对象，然后寻找标准容器中支持<code>std::initializer_list</code>为形参的构造函数并调用它。而标准容器的构造函数的处理就更加简单了，它们只需要调用<code>std::initializer_list</code>对象的<code>begin</code>和<code>end</code>函数，在循环中对本对象进行初始化。</p> 
<p>通过了解原理能够发现，支持列表初始化并不是标准容器的专利，我们也能写出一个支持列表初始化的类，需要做的只是添加一个以<code>std::initializer_list</code>为形参的构造函数罢了，比如下面的例子：</p> 
<pre><code class="prism language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;string&gt;</span></span>

<span class="token keyword">struct</span> <span class="token class-name">C</span> <span class="token punctuation">{<!-- --></span>
	<span class="token function">C</span><span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span>initializer_list<span class="token operator">&lt;</span>std<span class="token double-colon punctuation">::</span>string<span class="token operator">&gt;</span> a<span class="token punctuation">)</span>
	<span class="token punctuation">{<!-- --></span>
		<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">const</span> std<span class="token double-colon punctuation">::</span>string<span class="token operator">*</span> item <span class="token operator">=</span> a<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> item <span class="token operator">!=</span> a<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token operator">++</span>item<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
			std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token operator">*</span>item <span class="token operator">&lt;&lt;</span> <span class="token string">" "</span><span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
		std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	C c<span class="token punctuation">{<!-- --></span> <span class="token string">"hello"</span><span class="token punctuation">,</span> <span class="token string">"c++"</span><span class="token punctuation">,</span> <span class="token string">"world"</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>上面这段代码实现了一个支持列表初始化的类 C，类 C 的构造函数为 <code>C(std:: initializer_list&lt;std::string&gt; a)</code>，这是支持列表初始化所必需的，值得注意的是，<code>std:: initializer_list</code>的 <code>begin</code> 和 <code>end</code> 函数并不是返回的迭代器对象，而是一个常量对象指针 <code>const T *</code>。本着刨根问底的精神，让我们进一步探究编译器对列表的初始化处理：</p> 
<pre><code class="prism language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;string&gt;</span></span>

<span class="token keyword">struct</span> <span class="token class-name">C</span> <span class="token punctuation">{<!-- --></span>
	<span class="token function">C</span><span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span>initializer_list<span class="token operator">&lt;</span>std<span class="token double-colon punctuation">::</span>string<span class="token operator">&gt;</span> a<span class="token punctuation">)</span>
	<span class="token punctuation">{<!-- --></span>
		<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">const</span> std<span class="token double-colon punctuation">::</span>string<span class="token operator">*</span> item <span class="token operator">=</span> a<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> item <span class="token operator">!=</span> a<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token operator">++</span>item<span class="token punctuation">)</span>
		<span class="token punctuation">{<!-- --></span>
			std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> item <span class="token operator">&lt;&lt;</span> <span class="token string">" "</span><span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
		std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	C c<span class="token punctuation">{<!-- --></span> <span class="token string">"hello"</span><span class="token punctuation">,</span> <span class="token string">"c++"</span><span class="token punctuation">,</span> <span class="token string">"world"</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>
	std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"sizeof(std::string) = "</span> <span class="token operator">&lt;&lt;</span>
	std<span class="token double-colon punctuation">::</span>hex <span class="token operator">&lt;&lt;</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span>string<span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>运行输出结果如下：</p> 
<pre><code class="prism language-cpp"><span class="token number">0x77fdd0</span> <span class="token number">0x77fdf0</span> <span class="token number">0x77fe10</span>
<span class="token keyword">sizeof</span><span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span>string<span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token number">20</span>
</code></pre> 
<p>以上代码输出了<code>std::string</code>对象的内存地址以及单个对象的大小（不同编译环境的<code>std::string</code>实现方式会有所区别，其对象大小也会不同，这里的例子是使用GCC编译的，<code>std::string</code>对象的大小为0x20）。仔细观察3个内存地址会发现，它们的差别正好是<code>std::string</code>所占的内存大小。于是我们能推断出，编译器所进行的工作大概是这样的：</p> 
<pre><code class="prism language-cpp"><span class="token keyword">const</span> std<span class="token double-colon punctuation">::</span>string __a<span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{<!-- --></span>std<span class="token double-colon punctuation">::</span>string<span class="token punctuation">{<!-- --></span><span class="token string">"hello"</span><span class="token punctuation">}</span><span class="token punctuation">,</span> std<span class="token double-colon punctuation">::</span>string<span class="token punctuation">{<!-- --></span><span class="token string">"c++"</span><span class="token punctuation">}</span><span class="token punctuation">,</span> std<span class="token double-colon punctuation">::</span>string<span class="token punctuation">{<!-- --></span><span class="token string">"world"</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
C <span class="token function">c</span><span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span><span class="token generic-function"><span class="token function">initializer_list</span><span class="token generic class-name"><span class="token operator">&lt;</span>std<span class="token double-colon punctuation">::</span>string<span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span>__a<span class="token punctuation">,</span> __a<span class="token operator">+</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> 
<p>另外，有兴趣的读者不妨用GCC对上面这段代码生成中间代码GIMPLE，不出意外会发现类似这样的中间代码：</p> 
<pre><code class="prism language-cpp"><span class="token function">main</span> <span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token keyword">struct</span> <span class="token class-name">initializer_list</span> D<span class="token punctuation">.</span><span class="token number">40094</span><span class="token punctuation">;</span>
	<span class="token keyword">const</span> <span class="token keyword">struct</span> <span class="token class-name">basic_string</span> D<span class="token punctuation">.</span><span class="token number">36430</span><span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
	…
	std<span class="token double-colon punctuation">::</span>__cxx11<span class="token double-colon punctuation">::</span><span class="token class-name">basic_string</span><span class="token operator">&lt;</span><span class="token keyword">char</span><span class="token operator">&gt;</span><span class="token double-colon punctuation">::</span><span class="token function">basic_string</span> <span class="token punctuation">(</span><span class="token operator">&amp;</span>D<span class="token punctuation">.</span><span class="token number">36430</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token string">"hello"</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>D<span class="token punctuation">.</span><span class="token number">36424</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	…
	std<span class="token double-colon punctuation">::</span>__cxx11<span class="token double-colon punctuation">::</span><span class="token class-name">basic_string</span><span class="token operator">&lt;</span><span class="token keyword">char</span><span class="token operator">&gt;</span><span class="token double-colon punctuation">::</span><span class="token function">basic_string</span> <span class="token punctuation">(</span><span class="token operator">&amp;</span>D<span class="token punctuation">.</span><span class="token number">36430</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token string">"c++"</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>D<span class="token punctuation">.</span><span class="token number">36426</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	…
	std<span class="token double-colon punctuation">::</span>__cxx11<span class="token double-colon punctuation">::</span><span class="token class-name">basic_string</span><span class="token operator">&lt;</span><span class="token keyword">char</span><span class="token operator">&gt;</span><span class="token double-colon punctuation">::</span><span class="token function">basic_string</span> <span class="token punctuation">(</span><span class="token operator">&amp;</span>D<span class="token punctuation">.</span><span class="token number">36430</span><span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token string">"world"</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>D<span class="token punctuation">.</span><span class="token number">36428</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	…
	D<span class="token punctuation">.</span><span class="token number">40094.</span>_M_array <span class="token operator">=</span> <span class="token operator">&amp;</span>D<span class="token punctuation">.</span><span class="token number">36430</span><span class="token punctuation">;</span>
	D<span class="token punctuation">.</span><span class="token number">40094.</span>_M_len <span class="token operator">=</span> <span class="token number">3</span><span class="token punctuation">;</span>
	<span class="token class-name">C</span><span class="token double-colon punctuation">::</span><span class="token function">C</span> <span class="token punctuation">(</span><span class="token operator">&amp;</span>c<span class="token punctuation">,</span> D<span class="token punctuation">.</span><span class="token number">40094</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	…
<span class="token punctuation">}</span>
</code></pre> 
<h3><a id="4__2843"></a>4. 使用列表初始化的注意事项</h3> 
<p>使用列表初始化是如此的方便，让人不禁想马上运用到自己的代码中去。但是请别着急，这里还有两个地方需要读者注意。</p> 
<h4><a id="1__2847"></a>1) 隐式缩窄转换问题</h4> 
<p>隐式缩窄转换是在编写代码中稍不留意就会出现的，而且它的出现并不一定会引发错误，甚至有可能连警告都没有，所以有时候容易被人们忽略，比如：</p> 
<pre><code class="prism language-cpp"><span class="token keyword">int</span> x <span class="token operator">=</span> <span class="token number">12345</span><span class="token punctuation">;</span>
<span class="token keyword">char</span> y <span class="token operator">=</span> x<span class="token punctuation">;</span>
<span class="token comment">// char y{x}; // 这样编译器报错</span>
</code></pre> 
<p>这段代码中变量<code>y</code>的初始化明显是一个隐式缩窄转换，这在传统变量初始化中是没有问题的，代码能顺利通过编译。但是如果采用列表初始化，比如<code>char z{ x }</code>，根据标准编译器通常会给出一个错误，MSVC和CLang就是这么做的，而GCC有些不同，它只是给出了警告。</p> 
<p>现在问题来了，在C++中哪些属于隐式缩窄转换呢？在C++标准里列出了这么4条规则。</p> 
<ol><li><strong>从浮点类型转换整数类型。</strong></li><li><strong>从<code>long double</code>转换到<code>double</code>或<code>float</code>，或从<code>double</code>转换到<code>float</code>，除非转换源是常量表达式以及转换后的实际值在目标可以表示的值范围内。</strong></li><li><strong>从整数类型或非强枚举类型转换到浮点类型，除非转换源是常量表达式，转换后的实际值适合目标类型并且能够将生成目标类型的目标值转换回原始类型的原始值。</strong></li><li><strong>从整数类型或非强枚举类型转换到不能代表所有原始类型值的整数类型，除非源是一个常量表达式，其值在转换之后能够适合目标类型。</strong></li></ol> 
<p>4条规则虽然描述得比较复杂，但是要表达的意思还是很简单的，结合标准的例子就很容易理解了：</p> 
<pre><code class="prism language-cpp"><span class="token keyword">int</span> x <span class="token operator">=</span> <span class="token number">999</span><span class="token punctuation">;</span>
<span class="token keyword">const</span> <span class="token keyword">int</span> y <span class="token operator">=</span> <span class="token number">999</span><span class="token punctuation">;</span>
<span class="token keyword">const</span> <span class="token keyword">int</span> z <span class="token operator">=</span> <span class="token number">99</span><span class="token punctuation">;</span>
<span class="token keyword">const</span> <span class="token keyword">double</span> cdb <span class="token operator">=</span> <span class="token number">99.9</span><span class="token punctuation">;</span>
<span class="token keyword">double</span> db <span class="token operator">=</span> <span class="token number">99.9</span><span class="token punctuation">;</span>
<span class="token keyword">char</span> c1 <span class="token operator">=</span> x<span class="token punctuation">;</span>  <span class="token comment">// 编译成功，传统变量初始化支持隐式缩窄转换</span>
<span class="token keyword">char</span> c2<span class="token punctuation">{<!-- --></span> x <span class="token punctuation">}</span><span class="token punctuation">;</span> <span class="token comment">// 编译失败，可能是隐式缩窄转换，对应规则4</span>
<span class="token keyword">char</span> c3<span class="token punctuation">{<!-- --></span> y <span class="token punctuation">}</span><span class="token punctuation">;</span> <span class="token comment">// 编译失败，确定是隐式缩窄转换，999 超出 char 能够适应的范围，对应规则4</span>
<span class="token keyword">char</span> c4<span class="token punctuation">{<!-- --></span> z <span class="token punctuation">}</span><span class="token punctuation">;</span> <span class="token comment">// 编译成功，99 在 char 能够适应的范围内，对应规则4</span>
<span class="token keyword">unsigned</span> <span class="token keyword">char</span> uc1 <span class="token operator">=</span> <span class="token punctuation">{<!-- --></span> <span class="token number">5</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>  <span class="token comment">// 编译成功，5 在 unsigned char 能够适应的范围内，对应规则4</span>
<span class="token keyword">unsigned</span> <span class="token keyword">char</span> uc2 <span class="token operator">=</span> <span class="token punctuation">{<!-- --></span> <span class="token operator">-</span><span class="token number">1</span> <span class="token punctuation">}</span><span class="token punctuation">;</span> <span class="token comment">// 编译失败，unsigned char 不能够适应负数，对应规则4</span>
<span class="token keyword">unsigned</span> <span class="token keyword">int</span> ui1 <span class="token operator">=</span> <span class="token punctuation">{<!-- --></span> <span class="token operator">-</span><span class="token number">1</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>  <span class="token comment">// 编译失败，unsigned int 不能够适应负数，对应规则4</span>
<span class="token keyword">signed</span> <span class="token keyword">int</span> si1 <span class="token operator">=</span> <span class="token punctuation">{<!-- --></span> <span class="token punctuation">(</span><span class="token keyword">unsigned</span> <span class="token keyword">int</span><span class="token punctuation">)</span><span class="token operator">-</span><span class="token number">1</span> <span class="token punctuation">}</span><span class="token punctuation">;</span> <span class="token comment">// 编译失败，signed int 不能够适应 -1 所对应的 unsigned int，通常是 4294967295，对应规则4</span>
<span class="token keyword">int</span> ii <span class="token operator">=</span> <span class="token punctuation">{<!-- --></span> <span class="token number">2.0</span> <span class="token punctuation">}</span><span class="token punctuation">;</span> <span class="token comment">// 编译失败，int 不能适应浮点范围，对应规则1</span>
<span class="token keyword">float</span> f1<span class="token punctuation">{<!-- --></span> x <span class="token punctuation">}</span><span class="token punctuation">;</span>    <span class="token comment">// 编译失败，float 可能无法适应整数或者互相转换，对应规则3</span>
<span class="token keyword">float</span> f2<span class="token punctuation">{<!-- --></span> <span class="token number">7</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>    <span class="token comment">// 编译成功，7 能够适应 float，且 float 也能转换回整数 7，对应规则3</span>
<span class="token keyword">float</span> f3<span class="token punctuation">{<!-- --></span> cdb <span class="token punctuation">}</span><span class="token punctuation">;</span>  <span class="token comment">// 编译成功，99.9 能适应 float，对应规则2</span>
<span class="token keyword">float</span> f4<span class="token punctuation">{<!-- --></span> db <span class="token punctuation">}</span><span class="token punctuation">;</span>   <span class="token comment">// 编译失败，可能是隐式缩窄转无法表达 double，对应规则2</span>
</code></pre> 
<h4><a id="2__2887"></a>2) 列表初始化的优先级问题</h4> 
<p>通过9.2节和9.3节的介绍我们知道，列表初始化既可以支持普通的构造函数，也能够支持以<code>std::initializer_list</code>为形参的构造函数。如果这两种构造函数同时出现在同一个类里，那么编译器会如何选择构造函数呢？比如：</p> 
<pre><code class="prism language-cpp">std<span class="token double-colon punctuation">::</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span> <span class="token function">x1</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
std<span class="token double-colon punctuation">::</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span> x2<span class="token punctuation">{<!-- --></span> <span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">5</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre> 
<p>以上两种方法都可以对<code>std::vector&lt;int&gt;</code>进行初始化，但是初始化的结果却是不同的。变量<code>x1</code>的初始化结果是包含5个元素，且5个元素的值都为5，调用了<code>vector(size_type count, const T&amp; value, const Allocator&amp; alloc = Allocator())</code>这个构造函数。而变量<code>x2</code>的初始化结果是包含两个元素，且两个元素的值为5，也就是调用了构造函数<code>vector(std::initializer_list&lt;T&gt; init, const Allocator&amp; alloc = Allocator())</code>。</p> 
<p>所以，上述问题的结论是，<strong>如果有一个类同时拥有满足列表初始化的构造函数，且其中一个是以<code>std::initializer_list</code>为参数，那么编译器将优先以<code>std::initializer_list</code>为参数构造函数</strong>。由于这个特性的存在，我们在编写或阅读代码的时候就一定需要注意初始化代码的意图是什么，应该选择哪种方法对变量初始化。</p> 
<p>最后让我们回头看一看9.2节中没有解答的一个问题，<code>std::map&lt;std::string, int&gt; x8{ {"bear",4}, {"cassowary",2}, {"tiger",7} }</code>中两个层级的列表初始化分别使用了什么构造函数。其实答案已经非常明显了，内层 <code>{"bear",4}</code>, <code>{"cassowary",2}</code> 和 <code>{"tiger",7}</code> 都隐式调用了 <code>std::pair</code> 的构造函数 <code>pair(const T1&amp; x, const T2&amp; y)</code>，而外层的 <code>{…}</code> 隐式调用的则是 <code>std::map</code> 的构造函数 <code>map(std::initializer_list&lt;value_type&gt; init, const Allocator&amp;)</code>。</p> 
<h3><a id="5__2900"></a>5. 指定初始化</h3> 
<p>为了提高数据成员初始化的可读性和灵活性，C++20标准中引入了指定初始化的特性。该特性<strong>允许指定初始化数据成员的名称</strong>，从而使代码意图更加明确。让我们看一看示例：</p> 
<pre><code class="prism language-cpp"><span class="token keyword">struct</span> <span class="token class-name">Point</span> <span class="token punctuation">{<!-- --></span>
	<span class="token keyword">int</span> x<span class="token punctuation">;</span>
	<span class="token keyword">int</span> y<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
Point p<span class="token punctuation">{<!-- --></span> <span class="token punctuation">.</span>x <span class="token operator">=</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token punctuation">.</span>y <span class="token operator">=</span> <span class="token number">2</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre> 
<p>虽然在这段代码中<code>Point</code>的初始化并不如 <code>Point p{ 4, 2 };</code> 方便，但是这个例子却很好地展现了指定初始化语法。实际上，当初始化的结构体的数据成员比较多且真正需要赋值的只有少数成员的时候，这样的指定初始化就非常好用了：</p> 
<pre><code class="prism language-cpp"><span class="token keyword">struct</span> <span class="token class-name">Point3D</span> <span class="token punctuation">{<!-- --></span>
	<span class="token keyword">int</span> x<span class="token punctuation">;</span>
	<span class="token keyword">int</span> y<span class="token punctuation">;</span>
	<span class="token keyword">int</span> z<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
Point3D p<span class="token punctuation">{<!-- --></span> <span class="token punctuation">.</span>z <span class="token operator">=</span> <span class="token number">3</span> <span class="token punctuation">}</span><span class="token punctuation">;</span> <span class="token comment">// x = 0, y = 0</span>
</code></pre> 
<p>在上面的代码中 <code>Point3D</code> 需要 3 个坐标，不过我们只需要设置 <code>z</code> 的值，指定 <code>.z = 3</code> 即可。其中 <code>x</code> 和 <code>y</code> 坐标会调用默认初始化将其值设置为 <code>0</code>。可能这个例子还是不能完全体现出它相对于 <code>Point3D p{ 0, 0, 3 };</code> 的优势所在，不过读者应该能感觉到，一旦结构体更加复杂，指定初始化就一定能带来不少方便之处。</p> 
<p>最后需要注意的是，并不是什么对象都能够指定初始化的。</p> 
<ol><li><strong>它要求对象必须是一个聚合类型</strong>，例如下面的结构体就无法使用指定初始化：</li></ol> 
<pre><code class="prism language-cpp"><span class="token keyword">struct</span> <span class="token class-name">Point3D</span> <span class="token punctuation">{<!-- --></span>
	<span class="token function">Point3D</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span><span class="token punctuation">}</span>
	<span class="token keyword">int</span> x<span class="token punctuation">;</span>
	<span class="token keyword">int</span> y<span class="token punctuation">;</span>
	<span class="token keyword">int</span> z<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
Point3D p<span class="token punctuation">{<!-- --></span> <span class="token punctuation">.</span>z <span class="token operator">=</span> <span class="token number">3</span> <span class="token punctuation">}</span><span class="token punctuation">;</span> <span class="token comment">// 编译失败，Point3D 不是一个聚合类型</span>
</code></pre> 
<p>这里读者可能会有疑问，如果不能提供构造函数，那么我们希望数据成员 <code>x</code> 和 <code>y</code> 的默认值不为 <code>0</code> 的时候应该怎么做？不要忘了，从 C++11 开始我们有了非静态成员变量直接初始化的方法，比如当希望 <code>Point3D</code> 的默认坐标值都是 <code>100</code> 时，代码可以修改为：</p> 
<pre><code class="prism language-cpp"><span class="token keyword">struct</span> <span class="token class-name">Point3D</span> <span class="token punctuation">{<!-- --></span>
	<span class="token keyword">int</span> x <span class="token operator">=</span> <span class="token number">100</span><span class="token punctuation">;</span>
	<span class="token keyword">int</span> y <span class="token operator">=</span> <span class="token number">100</span><span class="token punctuation">;</span>
	<span class="token keyword">int</span> z <span class="token operator">=</span> <span class="token number">100</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
Point3D p<span class="token punctuation">{<!-- --></span> <span class="token punctuation">.</span>z <span class="token operator">=</span> <span class="token number">3</span> <span class="token punctuation">}</span><span class="token punctuation">;</span> <span class="token comment">// x = 100, y = 100, z = 3</span>
</code></pre> 
<ol start="2"><li>指<strong>定的数据成员必须是非静态数据成员</strong>。这一点很好理解，静态数据成员不属于某个对象。</li><li><strong>每个非静态数据成员最多只能初始化一次</strong>：</li></ol> 
<pre><code class="prism language-cpp">Point p<span class="token punctuation">{<!-- --></span> <span class="token punctuation">.</span>y <span class="token operator">=</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token punctuation">.</span>y <span class="token operator">=</span> <span class="token number">2</span> <span class="token punctuation">}</span><span class="token punctuation">;</span> <span class="token comment">// 编译失败，y不能初始化多次</span>
</code></pre> 
<ol start="4"><li><strong>非静态数据成员的初始化必须按照声明的顺序进行</strong>。请注意，这一点和C语言中指定初始化的要求不同，在C语言中，乱序的指定初始化是合法的，但C++不行。其实这一点也很好理解，因为C++中的数据成员会按照声明的顺序构造，按照顺序指定初始化会让代码更容易阅读：</li></ol> 
<pre><code class="prism language-cpp">Point p<span class="token punctuation">{<!-- --></span> <span class="token punctuation">.</span>y <span class="token operator">=</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token punctuation">.</span>x <span class="token operator">=</span> <span class="token number">2</span> <span class="token punctuation">}</span><span class="token punctuation">;</span> <span class="token comment">// C++编译失败，C编译没问题</span>
</code></pre> 
<ol start="5"><li><strong>针对联合体中的数据成员只能初始化一次，不能同时指定</strong>：</li></ol> 
<pre><code class="prism language-cpp">u f <span class="token operator">=</span> <span class="token punctuation">{<!-- --></span> <span class="token punctuation">.</span>a <span class="token operator">=</span> <span class="token number">1</span> <span class="token punctuation">}</span><span class="token punctuation">;</span> <span class="token comment">// 编译成功</span>
u g <span class="token operator">=</span> <span class="token punctuation">{<!-- --></span> <span class="token punctuation">.</span>b <span class="token operator">=</span> <span class="token string">"asdf"</span> <span class="token punctuation">}</span><span class="token punctuation">;</span> <span class="token comment">// 编译成功</span>
u h <span class="token operator">=</span> <span class="token punctuation">{<!-- --></span> <span class="token punctuation">.</span>a <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token punctuation">.</span>b <span class="token operator">=</span> <span class="token string">"asdf"</span> <span class="token punctuation">}</span><span class="token punctuation">;</span> <span class="token comment">// 编译失败，同时指定初始化联合体中的多个数据成员</span>
</code></pre> 
<ol start="6"><li><strong>不能嵌套指定初始化数据成员</strong>。虽然这一点在C语言中也是允许的，但是C++标准认为这个特性很少有用，所以直接禁止了：</li></ol> 
<pre><code class="prism language-cpp"><span class="token keyword">struct</span> <span class="token class-name">Line</span> <span class="token punctuation">{<!-- --></span>
	Point a<span class="token punctuation">;</span>
	Point b<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
Line l<span class="token punctuation">{<!-- --></span> <span class="token punctuation">.</span>a<span class="token punctuation">.</span>y <span class="token operator">=</span> <span class="token number">5</span> <span class="token punctuation">}</span><span class="token punctuation">;</span> <span class="token comment">// 编译失败, .a.y = 5 访问了嵌套成员，不符合C++标准</span>
</code></pre> 
<p>当然，如果确实想嵌套指定初始化，我们可以换一种形式来达到目的：</p> 
<pre><code class="prism language-cpp">Line l<span class="token punctuation">{<!-- --></span> <span class="token punctuation">.</span>a <span class="token punctuation">{<!-- --></span><span class="token punctuation">.</span>y <span class="token operator">=</span> <span class="token number">5</span><span class="token punctuation">}</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre> 
<ol start="7"><li><strong>在C++20中，一旦使用指定初始化，就不能混用其他方法对数据成员初始化了</strong>，而这一点在C语言中是允许的：</li></ol> 
<pre><code class="prism language-cpp">Point p<span class="token punctuation">{<!-- --></span> <span class="token punctuation">.</span>x <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span> <span class="token punctuation">}</span><span class="token punctuation">;</span> <span class="token comment">// 编译失败，混用数据成员的初始化</span>
</code></pre> 
<ol start="8"><li>最后再来了解一下指定初始化在C语言中处理数组的能力，当然在C++中这同样是被禁止的：</li></ol> 
<pre><code class="prism language-cpp"><span class="token keyword">int</span> arr<span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{<!-- --></span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">5</span> <span class="token punctuation">}</span><span class="token punctuation">;</span> <span class="token comment">// 编译失败</span>
</code></pre> 
<p>C++标准中给出的禁止理由非常简单，它的语法和<code>lambda</code>表达式冲突了。</p> 
<h3><a id="_2991"></a>总结</h3> 
<p>列表初始化是我非常喜欢的一个特性，因为它解决了以往标准容器初始化十分不方便的问题，使用列表初始化可以让容器如同数组一般被初始化。除此以外，实现以<code>std::initializer_list</code>为形参的构造函数也非常容易，这使自定义容器支持列表初始化也变得十分简单。C++20引入的指定初始化在一定程度上简化了复杂聚合类型初始化工作，让初始化复杂聚合类型的代码变得简洁清晰。</p> 
<h2><a id="C11_2995"></a>十、默认和删除函数（C++11）</h2> 
<h3><a id="1__2997"></a>1. 类的特殊成员函数</h3> 
<p>在定义一个类的时候，我们可能会省略类的构造函数，因为C++标准规定，在没有自定义构造函数的情况下，编译器会为类添加默认的构造函数。像这样有特殊待遇的成员函数一共有 6 个（C++11以前是4个），具体如下。</p> 
<ol><li><strong>默认构造函数。</strong></li><li><strong>析构函数。</strong></li><li><strong>复制构造函数。</strong></li><li><strong>复制赋值运算符函数。</strong></li><li><strong>移动构造函数（C++11新增）。</strong></li><li><strong>移动赋值运算符函数（C++11新增）。</strong></li></ol> 
<p>添加默认特殊成员函数的这条特性非常实用，它让程序员可以有更多精力关注类本身的功能而不必为了某些语法特性而分心，同时也避免了让程序员编写重复的代码，比如：</p> 
<pre><code class="prism language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;string&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;vector&gt;</span></span>

<span class="token keyword">class</span> <span class="token class-name">City</span> <span class="token punctuation">{<!-- --></span>
	std<span class="token double-colon punctuation">::</span>string name<span class="token punctuation">;</span>
	std<span class="token double-colon punctuation">::</span>vector<span class="token operator">&lt;</span>std<span class="token double-colon punctuation">::</span>string<span class="token operator">&gt;</span> street_name<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	City a<span class="token punctuation">,</span> b<span class="token punctuation">;</span>
	a <span class="token operator">=</span> b<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>在上面的代码中，我们虽然没有为 <code>City</code> 类添加复制赋值运算符函数 <code>City::operator=(const City &amp;)</code>，但是编译器仍然可以成功编译代码，并且在运行过程中正确地调用 <code>std::string</code> 和<code>std::vector&lt;std::string&gt;</code> 的复制赋值运算符函数。假如编译器没有提供这条特性，我们就不得不在编写类的时候添加以下代码：</p> 
<pre><code class="prism language-cpp">City<span class="token operator">&amp;</span> City<span class="token double-colon punctuation">::</span><span class="token keyword">operator</span><span class="token operator">=</span><span class="token punctuation">(</span><span class="token keyword">const</span> City <span class="token operator">&amp;</span> other<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	name <span class="token operator">=</span> other<span class="token punctuation">.</span>name<span class="token punctuation">;</span>
	street_name <span class="token operator">=</span> other<span class="token punctuation">.</span>street_name<span class="token punctuation">;</span>
	<span class="token keyword">return</span> <span class="token operator">*</span><span class="token keyword">this</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>很明显，编写这段代码除了满足语法的需求以外没有其他意义，很庆幸可以把这件事情交给编译器去处理。不过还不能高兴得太早，因为该特性的存在也给我们带来了一些麻烦。</p> 
<ol><li><strong>声明任何构造函数都会抑制默认构造函数的添加。</strong></li><li><strong>一旦用自定义构造函数代替默认构造函数，类就将转变为非平凡类型。</strong></li><li><strong>没有明确的办法彻底禁止特殊成员函数的生成（C++11之前）。</strong></li></ol> 
<p>下面来详细地解析这些问题，还是以<code>City</code>类为例，我们给它添加一个构造函数：</p> 
<pre><code class="prism language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;string&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;vector&gt;</span></span>

<span class="token keyword">class</span> <span class="token class-name">City</span> <span class="token punctuation">{<!-- --></span>
	std<span class="token double-colon punctuation">::</span>string name<span class="token punctuation">;</span>
	std<span class="token double-colon punctuation">::</span>vector<span class="token operator">&lt;</span>std<span class="token double-colon punctuation">::</span>string<span class="token operator">&gt;</span> street_name<span class="token punctuation">;</span>
<span class="token keyword">public</span><span class="token operator">:</span>
	<span class="token function">City</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>n<span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token function">name</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span><span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	City <span class="token function">a</span><span class="token punctuation">(</span><span class="token string">"wuhan"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	City b<span class="token punctuation">;</span> <span class="token comment">// 编译失败，自定义构造函数抑制了默认构造函数</span>
	b <span class="token operator">=</span> a<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>以上代码由于添加了构造函数<code>City(const char *n)</code>，导致编译器不再为类提供默认构造函数，因此在声明对象<code>b</code>的时候出现编译错误，为了解决这个问题我们不得不添加一个无参数的构造函数：</p> 
<pre><code class="prism language-cpp"><span class="token keyword">class</span> <span class="token class-name">City</span> <span class="token punctuation">{<!-- --></span>
	std<span class="token double-colon punctuation">::</span>string name<span class="token punctuation">;</span>
	std<span class="token double-colon punctuation">::</span>vector<span class="token operator">&lt;</span>std<span class="token double-colon punctuation">::</span>string<span class="token operator">&gt;</span> street_name<span class="token punctuation">;</span>
<span class="token keyword">public</span><span class="token operator">:</span>
	<span class="token function">City</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>n<span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token function">name</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span><span class="token punctuation">}</span>
	<span class="token function">City</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span><span class="token punctuation">}</span> <span class="token comment">// 新添加的构造函数</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre> 
<p>可以看到这段代码新添加的构造函数什么也没做，但却必须定义。乍看虽然做了一些多此一举的工作，但是毕竟也能让程序重新编译和运行，问题得到了解决。真的是这样吗？事实上，我们又不知不觉地陷入另一个麻烦中，请看下面的代码：</p> 
<pre><code class="prism language-cpp"><span class="token keyword">class</span> <span class="token class-name">Trivial</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token keyword">int</span> i<span class="token punctuation">;</span>
<span class="token keyword">public</span><span class="token operator">:</span>
	<span class="token function">Trivial</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token function">i</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">j</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span><span class="token punctuation">}</span>
	<span class="token function">Trivial</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span><span class="token punctuation">}</span>
	<span class="token keyword">int</span> j<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	Trivial <span class="token function">a</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	Trivial b<span class="token punctuation">;</span>
	b <span class="token operator">=</span> a<span class="token punctuation">;</span>
	std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"std::is_trivial_v&lt;Trivial&gt; : "</span> <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>is_trivial_v<span class="token operator">&lt;</span>Trivial<span class="token operator">&gt;</span> <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>上面的代码中有两个动作会将Trivial类的类型从一个平凡类型转变为非平凡类型。第一是定义了一个构造函数Trivial(int n)，它导致编译器抑制添加默认构造函数，于是Trivial类转变为非平凡类型。第二是定义了一个无参数的构造函数，同样可以让Trivial类转变为非平凡类型。</p> 
<p>最后一个问题大家肯定也都遇到过，举例来说，有时候我们需要编写一个禁止复制操作的类，但是过去C++标准并没有提供这样的能力。聪明的程序员通过将复制构造函数和复制赋值运算符函数声明为<code>private</code>并且不提供函数实现的方式，间接地达成目的。为了使用方便，<code>boost</code>库也提供了<code>noncopyable</code>类辅助我们完成禁止复制的需求。</p> 
<p>不过就如前面的问题一样，虽然能间接地完成禁止复制的需求，但是这样的实现方法并不完美。比如，友元就能够在编译阶段破坏类对复制的禁止。这里可能会有读者反驳，虽然友元能够访问私有的复制构造函数，但是别忘了，我们并没有实现这个函数，也就是说程序最后仍然无法运行。没错，程序最后会在链接阶段报错，原因是找不到复制构造函数的实现。但是这个报错显然来得有些晚，试想一下，如果面临的是一个巨大的项目，有不计其数的源文件需要编译，那么编译过程将非常耗时。如果某个错误需要等到编译结束以后的链接阶段才能确定，那么修改错误的时间代价将会非常高，所以我们还是更希望能在编译阶段就找到错误。</p> 
<p>还有一个典型的例子，禁止重载函数的某些版本，考虑下面的例子：</p> 
<pre><code class="prism language-cpp"><span class="token keyword">class</span> <span class="token class-name">Base</span> <span class="token punctuation">{<!-- --></span>
	<span class="token keyword">void</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token keyword">long</span> <span class="token operator">&amp;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">public</span><span class="token operator">:</span>
	<span class="token keyword">void</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span><span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	Base b<span class="token punctuation">;</span>
	<span class="token keyword">long</span> x <span class="token operator">=</span> <span class="token number">5</span><span class="token punctuation">;</span>
    b<span class="token punctuation">.</span><span class="token function">foo</span><span class="token punctuation">(</span><span class="token number">8</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    b<span class="token punctuation">.</span><span class="token function">foo</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 编译错误</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>由于将成员函数 <code>foo(long &amp;)</code> 声明为私有访问并且没有提供代码实现，因此在调用 <code>b.foo(x)</code> 的时候会编译出错。这样看来它跟我们之前讨论的例子没有什么实际区别，再进一步讨论，假设现在我们需要继承 <code>Base</code> 类，并且实现子类的 <code>foo</code> 函数；另外，还想沿用基类 <code>Base</code> 的 <code>foo</code> 函数，于是这里使用 <code>using</code> 说明符将 <code>Base</code> 的 <code>foo</code> 成员函数引入子类，代码如下：</p> 
<pre><code class="prism language-cpp"><span class="token keyword">class</span> <span class="token class-name">Base</span> <span class="token punctuation">{<!-- --></span>
	<span class="token keyword">void</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token keyword">long</span> <span class="token operator">&amp;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">public</span><span class="token operator">:</span>
	<span class="token keyword">void</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span><span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">class</span> <span class="token class-name">Derived</span> <span class="token operator">:</span> <span class="token base-clause"><span class="token keyword">public</span> <span class="token class-name">Base</span></span> <span class="token punctuation">{<!-- --></span>
<span class="token keyword">public</span><span class="token operator">:</span>
	<span class="token keyword">using</span> Base<span class="token double-colon punctuation">::</span>foo<span class="token punctuation">;</span>
	<span class="token keyword">void</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span><span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	Derived d<span class="token punctuation">;</span>
	d<span class="token punctuation">.</span><span class="token function">foo</span><span class="token punctuation">(</span><span class="token string">"hello"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	d<span class="token punctuation">.</span><span class="token function">foo</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>上面这段代码看上去合情合理，而实际上却无法通过编译。因为<code>using</code>说明符无法将基类的私有成员函数引入子类当中，即使这里我们将代码<code>d.foo(5)</code>删除，即不再调用基类的函数，编译器也是不会让这段代码编译成功的。</p> 
<h3><a id="2__3140"></a>2. 显式默认和显式删除</h3> 
<p>为了解决以上种种问题，C++11标准提供了一种方法能够简单有效又精确地控制默认特殊成员函数的添加和删除，我们将这种方法叫作<strong>显式默认</strong>和<strong>显式删除</strong>。显式默认和显式删除的语法非常简单，<strong>只需要在声明函数的尾部添加<code>=default</code>和<code>=delete</code></strong>，它们分别指示编译器添加特殊函数的默认版本以及删除指定的函数：</p> 
<pre><code class="prism language-cpp"><span class="token keyword">struct</span> <span class="token class-name">type</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token function">type</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token keyword">default</span><span class="token punctuation">;</span>
	<span class="token keyword">virtual</span> <span class="token operator">~</span><span class="token function">type</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token keyword">delete</span><span class="token punctuation">;</span>
	<span class="token function">type</span><span class="token punctuation">(</span><span class="token keyword">const</span> type <span class="token operator">&amp;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
type<span class="token double-colon punctuation">::</span><span class="token function">type</span><span class="token punctuation">(</span><span class="token keyword">const</span> type <span class="token operator">&amp;</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token keyword">default</span><span class="token punctuation">;</span>
</code></pre> 
<p>以上代码显式地添加了默认构造和复制构造函数，同时也删除了析构函数。请注意，<code>=default</code> 可以添加到类内部函数声明，也可以添加到类外部。这里默认构造函数的 <code>=default</code> 就是添加在类内部，而复制构造函数的 <code>=default</code> 则是添加在类外部。提供这种能力的意义在于，它可以让我们在不修改头文件里函数声明的情况下，改变函数内部的行为，例如：</p> 
<pre><code class="prism language-cpp"><span class="token comment">// type.h</span>
<span class="token keyword">struct</span> <span class="token class-name">type</span> <span class="token punctuation">{<!-- --></span>
	<span class="token function">type</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">int</span> x<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token comment">// type1.cpp</span>
type<span class="token double-colon punctuation">::</span><span class="token function">type</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token keyword">default</span><span class="token punctuation">;</span>

<span class="token comment">// type2.cpp</span>
type<span class="token double-colon punctuation">::</span><span class="token function">type</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span> x <span class="token operator">=</span> <span class="token number">3</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>
</code></pre> 
<p><code>=delete</code>与<code>=default</code>不同，它必须添加在<strong>类内部</strong>的函数声明中，如果将其添加到类外部，那么会引发编译错误。</p> 
<p>通过使用<code>=default</code>，我们可以很容易地解决之前提到的前两个问题，请观察以下代码：</p> 
<pre><code class="prism language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream&gt;</span></span>

<span class="token keyword">class</span> <span class="token class-name">NonTrivial</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token keyword">int</span> i<span class="token punctuation">;</span>
<span class="token keyword">public</span><span class="token operator">:</span>
	<span class="token function">NonTrivial</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token function">i</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">j</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span><span class="token punctuation">}</span>
	<span class="token function">NonTrivial</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span><span class="token punctuation">}</span>
	<span class="token keyword">int</span> j<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">class</span> <span class="token class-name">Trivial</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token keyword">int</span> i<span class="token punctuation">;</span>
<span class="token keyword">public</span><span class="token operator">:</span>
	<span class="token function">Trivial</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token function">i</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">j</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span><span class="token punctuation">}</span>
	<span class="token function">Trivial</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token keyword">default</span><span class="token punctuation">;</span>
	<span class="token keyword">int</span> j<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	Trivial <span class="token function">a</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	Trivial b<span class="token punctuation">;</span>
	b <span class="token operator">=</span> a<span class="token punctuation">;</span>
	std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"std::is_trivial_v&lt;Trivial&gt;   : "</span> <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>is_trivial_v<span class="token operator">&lt;</span>Trivial<span class="token operator">&gt;</span> <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span>
	std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"std::is_trivial_v&lt;NonTrivial&gt; : "</span> <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>is_trivial_v<span class="token operator">&lt;</span>NonTrivial<span class="token operator">&gt;</span> <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>注意，我们只是将构造函数<code>Trivial() {}</code>替换为显式默认构造函数<code>Trivial() = default</code>，类就从非平凡类型恢复到平凡类型了。这样一来，既让编译器为类提供了默认构造函数，又保持了类本身的性质，可以说完美解决了之前的问题。</p> 
<p>另外，针对禁止调用某些函数的问题，我们可以使用 <code>= delete</code> 来删除特定函数，相对于使用 <code>private</code> 限制函数访问，使用 <code>= delete</code> 更加彻底，它从编译层面上抑制了函的生成，所以无论调用者是什么身份（包括类的成员函数），都无法调用被删除的函数。进一步来说，由于必须在函数声明中使用 <code>= delete</code> 来删除函数，因此编译器可以在第一时间发现有代码错误地调用被删除的函数并且显示错误报告，这种快速报告错误的能力也是我们需要的，来看下面的代码：</p> 
<pre><code class="prism language-cpp"><span class="token keyword">class</span> <span class="token class-name">NonCopyable</span>
<span class="token punctuation">{<!-- --></span>
<span class="token keyword">public</span><span class="token operator">:</span>
	<span class="token function">NonCopyable</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token keyword">default</span><span class="token punctuation">;</span>                       <span class="token comment">// 显式添加默认构造函数</span>
	<span class="token function">NonCopyable</span><span class="token punctuation">(</span><span class="token keyword">const</span> NonCopyable<span class="token operator">&amp;</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token keyword">delete</span><span class="token punctuation">;</span>      <span class="token comment">// 显式删除拷贝构造函数</span>
	NonCopyable<span class="token operator">&amp;</span> <span class="token keyword">operator</span><span class="token operator">=</span><span class="token punctuation">(</span><span class="token keyword">const</span> NonCopyable<span class="token operator">&amp;</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token keyword">delete</span><span class="token punctuation">;</span>	<span class="token comment">// 显式删除拷贝赋值运算符函数</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	NonCopyable a<span class="token punctuation">,</span> b<span class="token punctuation">;</span>
	a <span class="token operator">=</span> b<span class="token punctuation">;</span>			<span class="token comment">// 编译失败，拷贝赋值运算符已被删除</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>以上代码删除了类<code>NonCopyable</code>的复制构造函数和复制赋值运算符函数，这样就禁止了该类对象相互之间的复制操作。请注意，由于显式地删除了复制构造函数，导致默认情况下编译器也不再自动添加默认构造函数，因此我们必须显式地让编译器添加默认构造函数，否则会导致编译失败。</p> 
<p>最后，让我们用<code>= delete</code>来解决禁止重载函数的继承问题，这里只需要对基类<code>Base</code>稍作修改即可：</p> 
<pre><code class="prism language-cpp"><span class="token keyword">class</span> <span class="token class-name">Base</span> <span class="token punctuation">{<!-- --></span>
<span class="token comment">//	void foo(long &amp;); </span>
<span class="token keyword">public</span><span class="token operator">:</span>
	<span class="token keyword">void</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token keyword">long</span> <span class="token operator">&amp;</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token keyword">delete</span><span class="token punctuation">;</span>	<span class="token comment">// 删除 foo(long &amp;) 函数</span>
	<span class="token keyword">void</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span><span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">class</span> <span class="token class-name">Derived</span> <span class="token operator">:</span> <span class="token base-clause"><span class="token keyword">public</span> <span class="token class-name">Base</span></span> <span class="token punctuation">{<!-- --></span>
<span class="token keyword">public</span><span class="token operator">:</span>
	<span class="token keyword">using</span> Base<span class="token double-colon punctuation">::</span>foo<span class="token punctuation">;</span>
	<span class="token keyword">void</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span><span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	Derived d<span class="token punctuation">;</span>
	d<span class="token punctuation">.</span><span class="token function">foo</span><span class="token punctuation">(</span><span class="token string">"hello"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	d<span class="token punctuation">.</span><span class="token function">foo</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>请注意，上面对代码做了两处修改。第一是将<code>foo(long &amp;)</code>函数从<code>private</code>移动到<code>public</code>，第二是使用<code>= delete</code>来显式删除该函数。如果只是显式删除了函数，却没有将函数移动到<code>public</code>，那么编译还是会出错的。</p> 
<p>PS：这个地方我没有理解书中作者想表达的含义，因为如果只是将<code>foo(long &amp;)</code>函数从<code>private</code>移动到<code>public</code>的话，也可以使上面代码通过编译，可以正常运行，那添加<code>= delete</code>来显式删除该函数显得没有必要了。即如下代码可以正常编译运行：</p> 
<pre><code class="prism language-cpp"><span class="token keyword">class</span> <span class="token class-name">Base</span> <span class="token punctuation">{<!-- --></span>
<span class="token keyword">public</span><span class="token operator">:</span>
	<span class="token keyword">void</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token keyword">long</span> <span class="token operator">&amp;</span><span class="token punctuation">)</span><span class="token punctuation">;</span> 
	<span class="token keyword">void</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span><span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">class</span> <span class="token class-name">Derived</span> <span class="token operator">:</span> <span class="token base-clause"><span class="token keyword">public</span> <span class="token class-name">Base</span></span> <span class="token punctuation">{<!-- --></span>
<span class="token keyword">public</span><span class="token operator">:</span>
	<span class="token keyword">using</span> Base<span class="token double-colon punctuation">::</span>foo<span class="token punctuation">;</span>
	<span class="token keyword">void</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span><span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	Derived d<span class="token punctuation">;</span>
	d<span class="token punctuation">.</span><span class="token function">foo</span><span class="token punctuation">(</span><span class="token string">"hello"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	d<span class="token punctuation">.</span><span class="token function">foo</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<h3><a id="3__3271"></a>3. 显式删除的其他用法</h3> 
<p>显式删除不仅适用于类的成员函数，对于普通函数同样有效。只不过相对于应用于成员函数，应用于普通函数的意义就不大了：</p> 
<pre><code class="prism language-cpp"><span class="token keyword">void</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token keyword">delete</span><span class="token punctuation">;</span>
<span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">bar</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token keyword">delete</span><span class="token punctuation">;</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token function">bar</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 编译失败，函数已经被显式删除</span>
	<span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 编译失败，函数已经被显式删除</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>另外，显式删除还可以用于类的<code>new</code>运算符和类析构函数。显式删除特定类的<code>new</code>运算符可以阻止该类在堆上动态创建对象，换句话说它可以限制类的使用者只能通过自动变量、静态变量或者全局变量的方式创建对象，例如：</p> 
<pre><code class="prism language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;cstddef&gt;</span></span>

<span class="token keyword">struct</span> <span class="token class-name">type</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token keyword">void</span> <span class="token operator">*</span> <span class="token keyword">operator</span> <span class="token keyword">new</span><span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span>size_t<span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token keyword">delete</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

type global_var<span class="token punctuation">;</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token keyword">static</span> type static_var<span class="token punctuation">;</span>
	type auto_var<span class="token punctuation">;</span>
	type <span class="token operator">*</span>var_ptr <span class="token operator">=</span> <span class="token keyword">new</span> type<span class="token punctuation">;</span>	<span class="token comment">// 编译失败，该类的 new 已被删除</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>显式删除类的析构函数在某种程度上和删除 <code>new</code> 运算符的目的正好相反，它阻止类通过自动变量、静态变量或者全局变量的方式创建对象，但是却可以通过 <code>new</code> 运算符创建对象。原因是删除析构函数后，类无法进行析构。所以像自动变量、静态变量或者全局变量这种会隐式调用析构函数的对象就无法创建了，当然了，通过 <code>new</code> 运算符创建的对象也无法通过 <code>delete</code> 销毁，例如：</p> 
<pre><code class="prism language-cpp"><span class="token keyword">struct</span> <span class="token class-name">type</span> 
<span class="token punctuation">{<!-- --></span>
	<span class="token operator">~</span><span class="token function">type</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token keyword">delete</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
type global_var<span class="token punctuation">;</span>			<span class="token comment">// 编译失败，析构函数被删除无法隐式调用</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token keyword">static</span> type static_var<span class="token punctuation">;</span>	<span class="token comment">// 编译失败，析构函数被删除无法隐式调用</span>
	type auto_var<span class="token punctuation">;</span>			<span class="token comment">// 编译失败，析构函数被删除无法隐式调用</span>
	type <span class="token operator">*</span>var_ptr <span class="token operator">=</span> <span class="token keyword">new</span> type<span class="token punctuation">;</span> <span class="token comment">// 可以被 new</span>
	<span class="token keyword">delete</span> var_ptr<span class="token punctuation">;</span>			<span class="token comment">// 编译失败，析构函数被删除无法显式调用</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>通过上面的代码可以看出，只有new创建对象会成功，其他创建和销毁操作都会失败，所以这样的用法并不多见，大部分情况可能在单例模式中出现。</p> 
<h3><a id="4_explicit__delete_3323"></a>4. explicit 和 =delete</h3> 
<p>在类的构造函数上同时使用<code>explicit</code>和<code>=delete</code>是一个不明智的做法，它常常会造成代码行为混乱难以理解，应尽量避免这样做。下面这个例子就是反面教材：</p> 
<pre><code class="prism language-cpp"><span class="token keyword">struct</span> <span class="token class-name">type</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token function">type</span><span class="token punctuation">(</span><span class="token keyword">long</span> <span class="token keyword">long</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span><span class="token punctuation">}</span>
	<span class="token keyword">explicit</span> <span class="token function">type</span><span class="token punctuation">(</span><span class="token keyword">long</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token keyword">delete</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">void</span> <span class="token function">foo</span><span class="token punctuation">(</span>type<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span><span class="token punctuation">}</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token function">foo</span><span class="token punctuation">(</span><span class="token function">type</span><span class="token punctuation">(</span><span class="token number">58</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 编译报错</span>
	<span class="token function">foo</span><span class="token punctuation">(</span><span class="token number">58</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p><code>foo(type(58))</code> 会造成编译失败，原因是 <code>type(58)</code> 显式调用了构造函数，但是 <code>explicit type(long)</code> 却被删除了。<code>foo(58)</code> 可以通过编译，因为编译器会选择 <code>type(long long)</code> 来构造对象。虽然原因解释得很清楚，但是建议还是不要这么使用，因为这样除了让人难以理解外，没有实际作用。</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/765bc21e37198eb6fc40127b6859105e/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">win11系统完全卸载Oracle11g图文详细步骤</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/891f5dbe52d80031c666b72dcceb5a1b/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">Single Image Haze Removal Using Dark Channel Prior(暗通道先验)</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>