<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Python 中的类对象和实例对象 - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Python 中的类对象和实例对象" />
<meta property="og:description" content="概念 类对象： 就是类本身实例对象： 由类实例化出来的对象 In [1]: class Person(object): ...: def __init__(self): ...: pass ...: In [2]: print(Person) &lt;class &#39;__main__.Person&#39;&gt; In [3]: p1 = Person() In [4]: print(p1) &lt;__main__.Person object at 0x0000022E52AB0D30&gt; 上面的 Person 就是类对象，而 p1 则是这个类的实例对象 类对象的使用 类对象支持两种操作：属性引用和实例化。 In [5]: class Person(object): ...: name = &#34;xxx&#34; ...: age = 20 ...: ...: def __init__(self): ...: pass ...: In [6]: Person.name Out[6]: &#39;xxx&#39; In [7]: Person.age Out[7]: 20 In [8]: p1 = Person() In [9]: print(p1." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/3d93b6d956d297ed4c820fcb0cd7a424/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2019-08-26T12:49:55+08:00" />
<meta property="article:modified_time" content="2019-08-26T12:49:55+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Python 中的类对象和实例对象</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <h3><a id="_1"></a>概念</h3> 
<ul><li>类对象： 就是类本身</li><li>实例对象： 由类实例化出来的对象</li></ul> 
<pre><code class="prism language-Python">In [1]: class Person(object):
   ...:     def __init__(self):
   ...:         pass
   ...:

In [2]: print(Person)
&lt;class '__main__.Person'&gt;

In [3]: p1 = Person()

In [4]: print(p1)
&lt;__main__.Person object at 0x0000022E52AB0D30&gt;
</code></pre> 
<ul><li>上面的 Person 就是类对象，而 p1 则是这个类的实例对象</li></ul> 
<h3><a id="_23"></a>类对象的使用</h3> 
<ul><li>类对象支持两种操作：属性引用和实例化。</li></ul> 
<pre><code class="prism language-Python">In [5]: class Person(object):
   ...:     name = "xxx"
   ...:     age = 20
   ...:
   ...:     def __init__(self):
   ...:         pass
   ...:

In [6]: Person.name
Out[6]: 'xxx'

In [7]: Person.age
Out[7]: 20

In [8]: p1 = Person()

In [9]: print(p1.name, p1.age)
xxx 20

In [10]: p1.name = 'yyy'

In [11]: print(Person.name, p1.name)
xxx yyy
</code></pre> 
<ul><li> <p>上面 In[6]和In[7] 是类对象的属性引用，In[8] 为类对象的实例化</p> </li><li> <p>实例对象唯一操作是属性引用，有两种有效的属性名称，数据属性和方法。</p> </li></ul> 
<h3><a id="_57"></a>类属性、实例属性、类方法、实例方法、静态方法</h3> 
<h4><a id="_59"></a>类属性</h4> 
<ul><li>类属性就是类对象所拥有的属性，它被所有类对象的实例对象所共有，在内存中只存在一个副本；</li><li>对于公有的类属性，在类外可以通过类对象和实例对象访问。</li></ul> 
<h4><a id="_64"></a>实例属性</h4> 
<ul><li>类的实例化对象的属性，属于实例对象独有。</li></ul> 
<pre><code class="prism language-Python">In [26]: class Person(object):	
    ...:     name = "xxx"	# 类属性
    ...:     age = 20		# 类属性
    ...:
    ...:     def __init__(self):
    ...:        self.addr = "China"		# 实例属性
    ...:
    ...:

In [27]: p1 = Person()

In [28]: Person.name
Out[28]: 'xxx'

In [29]: Person.age
Out[29]: 20

In [30]: p1.name
Out[30]: 'xxx'

In [31]: p1.addr
Out[31]: 'China'

In [32]: Person.addr
---------------------------------------------------------------------------
AttributeError                            Traceback (most recent call last)
&lt;ipython-input-32-0ed446385bbc&gt; in &lt;module&gt;
----&gt; 1 Person.addr

AttributeError: type object 'Person' has no attribute 'addr'
In [33]: p1.name = "yyy"

In [34]: print(Person.name, p1.name)
Out[34]: 'xxx' 'yyy'
</code></pre> 
<ul><li>类对象和实例对象都可以访问类属性</li><li>类对象无法访问实例属性</li><li>类属性只有通过类对象进行修改，实例对象无法修改类属性, 通过实例对象给类属性进行赋值，实际上是给实例对象添加了一条新的属性</li></ul> 
<h4><a id="_109"></a>类方法</h4> 
<ul><li>类方法：是类对象所拥有的方法，需要用修饰器"@classmethod"来标识其为类方法，</li><li>对于类方法，第一个参数必须是类对象，一般以"cls"作为第一个参数(只是一个参数命名习惯，也可以换成其他的，不过不推荐)</li><li>能够通过实例对象和类对象去访问。</li></ul> 
<pre><code class="prism language-Python">In [36]: class Person(object):
    ...:     name = "xxx"
    ...:     age = 20
    ...:
    ...:     def __init__(self):
    ...:         self.addr = "China"
    ...:
    ...:     @classmethod
    ...:     def hello(cls):
    ...:         return "hello world"
    ...:

In [37]: Person.hello()
Out[37]: 'hello world'

In [38]: Person().hello()
Out[38]: 'hello world'
</code></pre> 
<ul><li>类方法的一个用途就是可以对类属性进行修改, 这样的话，实例对象通过调用类方法也可以对类属性进行修改</li></ul> 
<pre><code class="prism language-Python">In [39]: class Person(object):
    ...:     name = "xxx"
    ...:     age = 20
    ...:
    ...:     def __init__(self):
    ...:         self.addr = "China"
    ...:
    ...:     @classmethod
    ...:     def set_name(cls, value):
    ...:         cls.name = value
    ...:

In [40]: Person().set_name("yyy")

In [41]: Person.name
Out[41]: 'yyy'
</code></pre> 
<h4><a id="_156"></a>实例方法</h4> 
<ul><li>实例方法：在类中最常定义的成员方法，它至少有一个参数并且必须以实例对象作为其第一个参数，一般以名为"self"的变量作为第一个参数。</li><li>在类外实例方法只能通过实例对象去调用，不能通过其他方式去调用(其实类对象可以调用实例方法，只不过需要传一个实例对象作为第一个参数)。</li></ul> 
<pre><code class="prism language-Python">In [42]: class Person(object):
    ...:     name = "xxx"
    ...:     age = 20
    ...:
    ...:     def __init__(self):
    ...:         self.addr = "China"
    ...:
    ...:     def get_addr(self):
    ...:         return self.addr
    ...:

In [43]: p = Person()

In [44]: p.get_addr()
Out[44]: 'China'

In [45]: Person.get_addr()		
---------------------------------------------------------------------------
TypeError                                 Traceback (most recent call last)
&lt;ipython-input-45-c70e23dcb313&gt; in &lt;module&gt;
----&gt; 1 Person.get_addr()

TypeError: get_addr() missing 1 required positional argument: 'self'

In [46]: Person.get_addr(p)
Out[46]: 'China'
</code></pre> 
<ul><li>如上所示，类对象直接调用实例方法会报错，但是将一个实例实例对象作为第一个参数传入后，则可以成功调用实例方法</li></ul> 
<h4><a id="_192"></a>静态方法</h4> 
<ul><li> <p>需要通过修饰器 @staticmethod 来进⾏修饰，静态⽅法不需要多定义参数</p> </li><li> <p>跟普通函数没什么区别，与类和实例都没有所谓的绑定关系，不论是通过类还是实例都可以引用该方法。</p> </li><li> <p>静态方法使用场景</p> 
  <ul><li>如果在方法中不需要访问任何实例方法和属性，纯粹地通过传入参数并返回数据的功能性方法，那么它就适合用静态方法来定义，它节省了实例化对象的开销成本，往往这种方法放在类外面的模块层作为一个函数存在也是没问题的，而放在类中，仅为这个类服务。</li></ul> </li></ul> 
<pre><code class="prism language-Python">In [54]: class Person(object):
    ...:     name = "xxx"
    ...:     age = 20
    ...:
    ...:     def __init__(self):
    ...:         self.addr = "China"
    ...:
    ...:     @staticmethod
    ...:     def sleep(sec):
    ...:         """暂停几秒"""
    ...:         time.sleep(sec)
    ...:     def do_somethings(self):
    ...:         print("do ......")
    ...:         self.sleep(5)
    ...:         print("end ....")
    ...:

In [55]: p = Person()

In [56]: Person.sleep(2)

In [57]: p.sleep(2)

In [58]: p.do_somethings()
do ......
end ....
</code></pre> 
<h4><a id="_229"></a>区别</h4> 
<table><thead><tr><th>…</th><th>类对象是否可以调用</th><th>实例对象是否可以调用</th></tr></thead><tbody><tr><td>类属性</td><td>是</td><td>是(可以调用但是无法直接修改)</td></tr><tr><td>实例属性</td><td>否</td><td>是</td></tr><tr><td>类方法</td><td>是</td><td>是</td></tr><tr><td>实例方法</td><td>否(其实可以调用，但是要传入一个实例对象)</td><td>是</td></tr><tr><td>静态方法</td><td>是</td><td>是</td></tr></tbody></table>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/ee397bec88e002110c1ace793f460fff/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">SpringBoot两种开启方式</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/fcc2c92d07f32fe1a33bef7053c4a6cc/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">js文件中引入js的方法</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>