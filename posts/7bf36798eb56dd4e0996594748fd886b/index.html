<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>操作系统文件分配策略_操作系统中的文件分配方法 - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="操作系统文件分配策略_操作系统中的文件分配方法" />
<meta property="og:description" content="操作系统文件分配策略
分配方法 (Allocation Method) The allocation method defines how the files are stored in the disk blocks. The direct access nature of the disks gives us the flexibility to implement the files. In many cases, different files or many files are stored on the same disk. The main problem that occurs in the operating system is that how we allocate the spaces to these files so that the utilization of disk is efficient and the quick access to the file is possible." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/7bf36798eb56dd4e0996594748fd886b/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2020-07-16T05:16:31+08:00" />
<meta property="article:modified_time" content="2020-07-16T05:16:31+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">操作系统文件分配策略_操作系统中的文件分配方法</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <div style="font-size: 16px;"> 
 <p>操作系统文件分配策略</p> 
 <h3> 分配方法 <span style="font-weight: bold;">(</span>Allocation Method<span style="font-weight: bold;">)</span></h3> 
 <p>The allocation method defines how the files are stored in the disk blocks. The direct access nature of the disks gives us the flexibility to implement the files. In many cases, different files or many files are stored on the same disk. The main problem that occurs in the operating system is that how we allocate the spaces to these files so that the utilization of disk is efficient and the quick access to the file is possible. There are mainly three methods of file allocation in the disk. Each method has its advantages and disadvantages. Mainly a system uses one method for all files within the system.</p> 
 <p> 分配方法定义文件如何存储在磁盘块中。 磁盘的直接访问特性使我们可以灵活地实现文件。 在许多情况下，不同的文件或许多文件存储在同一磁盘上。 操作系统中出现的主要问题是我们如何为这些文件分配空间，以便磁盘利用效率高，并且可以快速访问文件。 磁盘中主要有三种文件分配方法。 每种方法都有其优点和缺点。 主要是系统对系统中的所有文件使用一种方法。 </p> 
 <ul><li><p>Contiguous allocation</p><p> 连续分配 </p></li><li><p>Linked allocation</p><p> 链接分配 </p></li><li><p>Indexed allocation</p><p> 索引分配 </p></li></ul> 
 <p>The main idea behind contiguous allocation methods is to provide</p> 
 <p> 连续分配方法背后的主要思想是提供 </p> 
 <ul><li><p>Efficient disk space utilization</p><p> 高效的磁盘空间利用 </p></li><li><p>Fast access to the file blocks</p><p> 快速访问文件块 </p></li></ul> 
 <h4> 连续分配 <span style="font-weight: bold;">(</span>Contiguous allocation<span style="font-weight: bold;">)</span></h4> 
 <p>In this scheme, a file is made from the contiguous set of blocks on the disk. Linear ordering on the disk is defined by the disk addresses. In this scheme only one job is accessing the disk block b after that it accesses the block b+1 and there are no head movements. When the movement of the head is needed the head moves only from one track to another track. So the disk number that is required for accessing the contiguous allocation is minimal. Contiguous allocation method provides a good performance that’s why it is used by the IBM VM/CMS operating system. For example, if a file requires n blocks and is given a block b as the starting location, then the blocks assigned to the file will be: <b>b, b+1, b+2,..., b+n-1</b>. This means that given the starting block address and the length of the file (in terms of blocks required), we can determine the blocks occupied by the file. For a contiguous allocation the directory entry the address of the starting block and Length of the allocated portion.</p> 
 <p> 在这种方案中，文件是由磁盘上连续的块集组成的。 磁盘上的线性顺序由磁盘地址定义。 在此方案中，只有一个作业正在访问磁盘块b，之后它才访问块b + 1，并且没有磁头移动。 当需要头部移动时，头部仅从一个轨道移动到另一轨道。 因此，访问连续分配所需的磁盘数量最少。 连续分配方法提供了良好的性能，这就是IBM VM / CMS操作系统使用它的原因。 例如，如果一个文件需要n个块，并以b作为起始位置，则分配给该文件的块将为： <b class="raw_b_node">b，b + 1，b + 2，...，b + n-1</b> 。 这意味着给定起始块地址和文件长度(以所需的块数为单位)，我们可以确定文件所占用的块。 对于连续分配，目录条目的起始块的地址和分配部分的长度。 </p> 
 <p>The file <b>'A'</b> in the following figure starts from block 19 with <b>length = 6 blocks</b>. Therefore, it occupies <b>19, 20, 21, 22, 23, 24</b> blocks.</p> 
 <p> 下图中的文件<b class="raw_b_node">“ A”</b>从块19开始，其<b class="raw_b_node">长度= 6个块</b> 。 因此，它占用<b class="raw_b_node">19、20、21、22、23、24个</b>块。 </p> 
 <ul><li><p>Each file in the disk occupies a contiguous address space on the disk.</p><p> 磁盘中的每个文件都占据磁盘上连续的地址空间。 </p></li><li><p>In this scheme, the address is assigned in the linear fashion.</p><p> 在此方案中，以线性方式分配地址。 </p></li><li><p>The is very easy to implement the contiguous allocation method.</p><p> 实现连续分配方法非常容易。 </p></li><li><p>In the contiguous allocation technique, external fragmentation is a major issue.</p><p> 在连续分配技术中，外部碎片化是一个主要问题。 </p></li></ul> 
 <p><b>Advantages:</b></p> 
 <p> <b class="raw_b_node">优点：</b> </p> 
 <ol><li><p>In the contiguous allocation, sequential and direct access both are supported.</p><p> 在连续分配中，同时支持顺序访问和直接访问。 </p></li><li><p>For the direct access, the starting address of the kth block is given and further blocks are obtained by b+K,</p><p> 对于直接访问，给出第k个块的起始地址，并通过b + K获得其他块， </p></li><li><p>This is very fast and the number of seeks is minimal in the contiguous allocation method.</p><p> 在连续分配方法中，这非常快并且搜寻次数最少。 </p></li></ol> 
 <p><b>Disadvantages:</b></p> 
 <p> <b class="raw_b_node">缺点：</b> </p> 
 <ol><li><p>Contiguous allocation method suffers internal as well as external fragmentation.</p><p> 连续分配方法遭受内部和外部碎片。 </p></li><li><p>In terms of memory utilization, this method is inefficient.</p><p> 在内存利用率方面，此方法效率低下。 </p></li><li><p>It is difficult to increase the file size because it depends on the availability of contiguous memory.</p><p> 很难增加文件的大小，因为它取决于连续内存的可用性。 </p></li></ol> 
 <p><b>Example:</b></p> 
 <p> <b class="raw_b_node">例：</b> </p> 
 <table class="w3-table-all"><tbody><tr><th>File</th><th>Start</th><th>Length</th></tr><tr><td>Count</td><td>0</td><td>2</td></tr><tr><td>Tr</td><td>14</td><td>3</td></tr><tr><td>Mail</td><td>19</td><td>6</td></tr><tr><td>List</td><td>28</td><td>4</td></tr></tbody></table> 
 <table class="w3-table-all"><tbody><tr><th> 文件 </th><th> 开始 </th><th> 长度 </th></tr><tr><td> 计数 </td><td> 0 </td><td> 2 </td></tr><tr><td> Tr </td><td> 14 </td><td> 3 </td></tr><tr><td> 邮件 </td><td> 19 </td><td> 6 </td></tr><tr><td> 清单 </td><td> 28 </td><td> 4 </td></tr></tbody></table> 
 <h4> 链接分配 <span style="font-weight: bold;">(</span>Linked allocation<span style="font-weight: bold;">)</span></h4> 
 <p>The problems of contiguous allocation are solved in the linked allocation method. In this scheme, disk blocks are arranged in the linked list form which is not contiguous. The disk block is scattered in the disk. In this scheme, the directory entry contains the pointer of the first block and pointer of the ending block. These pointers are not for the users. For example, a file of six blocks starts at block 10 and end at the block. Each pointer contains the address of the next block. When we create a new file we simply create a new entry with the linked allocation. Each directory contains the pointer to the first disk block of the file. when the pointer is nil then it defines the empty file. </p> 
 <p> 链接分配方法解决了连续分配的问题。 在这种方案中，磁盘块以不连续的链表形式排列。 磁盘块分散在磁盘中。 在此方案中，目录条目包含第一个块的指针和结束块的指针。 这些指针不适用于用户。 例如，六个块的文件从块10开始，到块结束。 每个指针都包含下一个块的地址。 当我们创建一个新文件时，我们只需创建一个带有链接分配的新条目。 每个目录都包含指向文件第一个磁盘块的指针。 当指针为nil时，它将定义空文件。 </p> 
 <p><b>Advantages:</b></p> 
 <p> <b class="raw_b_node">优点：</b> </p> 
 <ol><li><p>In terms of the file size, this scheme is very flexible.</p><p> 就文件大小而言，此方案非常灵活。 </p></li><li><p>We can easily increase or decrease the file size and system does not worry about the contiguous chunks of memory.</p><p> 我们可以轻松地增加或减少文件大小，并且系统不必担心连续的内存块。 </p></li><li><p>This method free from external fragmentation this makes it better in terms of memory utilization.</p><p> 此方法没有外部碎片，因此在内存利用率方面更好。 </p></li></ol> 
 <p><b>Disadvantages:</b></p> 
 <p> <b class="raw_b_node">缺点：</b> </p> 
 <ol><li><p>In this scheme, there is large no of seeks because the file blocks are randomly distributed on disk.</p><p> 在这种方案中，由于文件块是随机分布在磁盘上的，因此不需要大量查找。 </p></li><li><p>Linked allocation is comparatively slower than contiguous allocation.</p><p> 链接分配比连续分配要慢。 </p></li><li><p>Random or direct access is not supported by this scheme we cannot access the blocks directly.</p><p> 此方案不支持随机或直接访问，我们无法直接访问块。 </p></li><li><p>The pointer is extra overhead on the system due to the linked list.</p><p> 由于链接列表，指针在系统上会产生额外的开销。 </p></li></ol> 
 <h4> 索引分配 <span style="font-weight: bold;">(</span>Indexed Allocation<span style="font-weight: bold;">)</span></h4> 
 <p>In this scheme, a special block known as the index block contains the pointer to all the blocks occupied by a file. each file contains its index which is in the form of an array of disk block addresses. The ith entry of index block point to the ith block of the file. The address of the index block is maintained by the directory. When we create a file all pointer is set to nil. A block is obtained from the free space manager when the first ith block is written. When the index block is very small it is difficult to hold all the pointers for the large file. to deal with this issue a mechanism is available. Mechanism includes the following:</p> 
 <p> 在此方案中，称为索引块的特殊块包含指向文件所占据的所有块的指针。 每个文件都包含其索引，该索引采用磁盘块地址数组的形式。 索引块的第i个条目指向文件的第i个块。 索引块的地址由目录维护。 创建文件时，所有指针都设置为nil。 当第一个第i个块被写入时，将从可用空间管理器中获得一个块。 当索引块很小时，很难保存大文件的所有指针。 解决此问题的机制是可用的。 机制包括以下内容： </p> 
 <ul><li><p>Linked scheme</p><p> 链接方案 </p></li><li><p>Multilevel scheme</p><p> 多级方案 </p></li><li><p>Combined scheme</p><p> 组合方案 </p></li></ul> 
 <p><b>Advantages:</b></p> 
 <p> <b class="raw_b_node">优点：</b> </p> 
 <ol><li><p>This scheme supports random access of the file.</p><p> 该方案支持文件的随机访问。 </p></li><li><p>This scheme provides fast access to the file blocks.</p><p> 该方案提供对文件块的快速访问。 </p></li><li><p>This scheme is free from the problem of external fragmentation.</p><p> 该方案没有外部碎片的问题。 </p></li></ol> 
 <p><b>Disadvantages:</b></p> 
 <p> <b class="raw_b_node">缺点：</b> </p> 
 <ol><li><p>The pointer head is relatively greater than the linked allocation of the file.</p><p> 指针头相对大于文件的链接分配。 </p></li><li><p>Indexed allocation suffers from the wasted space.</p><p> 索引分配遭受空间浪费。 </p></li><li><p>For the large size file, it is very difficult for single index block to hold all the pointers.</p><p> 对于大文件，单个索引块很难容纳所有指针。 </p></li><li><p>For very small files say files that expend only 2-3 blocks the indexed allocation would keep on the entire block for the pointers which is insufficient in terms of memory utilization.</p><p> 对于很小的文件，例如仅消耗2-3个块的文件，索引分配将保留整个块的指针，这在内存利用率方面是不够的。 </p></li></ol> 
 <blockquote> 
  <p>翻译自: <a href="https://www.includehelp.com/operating-systems/file-allocation-method.aspx" rel="nofollow">https://www.includehelp.com/operating-systems/file-allocation-method.aspx</a></p> 
 </blockquote> 
 <p>操作系统文件分配策略</p> 
</div>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/0703765ae6d4950985ff69567bf0a6f7/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">ABAP 选择画面SELECT-OPTIONS必输项检查&amp;图标设置</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/e4ed90e153734d0bfcfee6fdaf2bbac5/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">wifi 802.11 kvr  漫游</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>