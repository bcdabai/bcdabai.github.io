<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>RK fb源码分析之SCREEN - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="RK fb源码分析之SCREEN" />
<meta property="og:description" content="前言 学习，学而时习之。在工作中，利用闲暇时光简单分析下RK平台下fb源码部分，本人才疏学浅，很多地方理解的也不到位，只是简单的分析下代码流程，搞明白驱动调试过程中需要注意的地方。现将自己的一些理解与建议总结下来，如有错误之处，还望指正。
RK的LCD这块，亮点也就在于双屏异显，才开始搞驱动时，感觉这就是个高大上的东西，一脸懵逼，不知所措。随着后来慢慢深入才发现，原理和单屏也是差不多的。
分析之前，我将RK LCD这块首先分为四大块：fb、lcdc、screen、screen_type.这四部分相互依赖，首先从我们最容易入手的地方开始:rk_screen.c 一、函数调用关系 rk_screen.c函数调用关系如下： 二、probe()分析
毫无疑问，驱动的重点就是probe()函数，驱动在匹配到compatible = “rockchip,screen”后进入probe()函数，rk_screen_probe()： 在probe函数中获取”screen_prop”、”native-mode”等属性，在这里有个重要的结构体：prmry_screen会被初始化，prmry_screen 定义如下： static struct rk_screen *prmry_screen 还有一个结构体：struct rk_screen *rk_screen，rk_screen贯串上下文，并将prmry_screen指向rk_screen，prmry_screen之所以重要,是因为之后screen_type(例如LVDS，EDP,MIPI等)需要获取screen参数，就是获取prmry_screen的值，而这里prmry_screen就是rk_screen。 进入probe函数有两个函数比较重要：rk_fb_prase_timing_dt()和rk_disp_pwr_ctr_parse_dt。 首先会根据device_node中”screen_prop”的值，来决定rk_screen的”归属”： 代码中，dts的”screen_prop”的值决定了屏参文件传递进来后赋值给了谁：prmry_screen或者extend_screen.(NOTE:只有在DUAL_LCD时，screen节点下才会有”screen_prop”属性，单屏，由LCDC部分判断”screen_prop”) rk_fb_prase_timing_dt() 通过of_get_display_timings(np)解析device_node中的所有display_timing条目，然后调用 display_timings_get()从结构体display_timing中得到入口地址，最后调用了rk_fb_video_mode_from_timing(dt, screen)从display_timing中获取screen的详细信息，并将其赋值给rk_screen结构体(即prmry_screen).
rk_disp_pwr_ctr_parse_dt() 该函数主要是从dts中解析power control节点。其中，又引出来一个比较重要的结构体：struct rk_disp_pwr_ctr_list *pwr_ctr;该结构体也是一个双向链表。然后，初始化了一个双向链表rk_screen-&gt;pwrlist_head，最终会将pwr_ctr挂到rk_screen-&gt;pwrlist_head链表下： list_add_tail(&amp;pwr_ctr-&gt;list, rk_screen-&gt;pwrlist_head); for_each_child_of_node(root, child)循环解析每个子节点,例如： 首先为每个子节点(如lcd_en,lcd_cs,lcd_rst等)kmalloc一段空间, 解析dts中”rockchip,power_type”的值，rockchip,power_type = GPIO，分别获取其GPIO存至各自的pwr_ctr-&gt;pwr_ctr.gpio中，然后申请GPIO。这里，还有一个值：rockchip,delay，可以控制上电时序的延时操作，这个值在后面用到时再讲。 2. rk_fb_video_mode_from_timing() 该函数获取dts中display_timing各个子节点的值，其中有我们熟悉的VBP,VFP,HBP,HFP等可变参数，最终将获取到的值写入变量screen中，这样screen就被初始化完。 至此，screen部分probe()函数完结，现在总结下： Screen的probe()函数主要干了两件事： 解析dts中的display_timing，获取屏幕信息 解析dts中的power control，获取LCD的使能脚、片选脚、复位脚 最终，这些信息都存在了struct rk_screen *rk_screen这个结构体中，也就是prmry_screen这个结构体。那么，prmry_screen这个结构体在什么地方会用到呢？答案也是在rk_screen.c中： 调用rk_fb_get_screen()这个函数来取得screen的信息。该函数在哪被调用，后续会碰到，暂且不讨论。
以上部分，是双屏时screen部分的流程，事实上，单屏的代码更为简单。就是在probe()直接调用rk_fb_prase_timing_dt(np, rk_screen)来获取LCD屏信息，获取screen： 区别在于display_timings_get()的第二形参不同
但是，有些人又有疑问了？那双屏时会去获取power control节点的信息，单屏时为什么不用获取呢？其实也不是没有获取，只不过处理的地方不一样。双屏时，在screen部分获取power control，因为有两个LCD屏，有各自的使能脚、背光脚等等，所以引入链表保存至rk_screen结构体中，待将来使用。而单屏只有一组控制脚，只要在需要的地方获取使用就可以了。后续，只分析单屏的，理清思路即可。
最后，我们再来总结下probe()的功能： 1.如果是双屏，解析dts中screen节点下的power_ctl节点,单屏的power_ctl节点在别的地方(后续讲述)处理 2.从dts中获取LCD各个参数(VFP,VBP,HBP,HFP,W,H,CLOCK等等) 3.单屏保存至全局静态变量rk_screen，双屏时分别保存至prmry_screen和extend_screen以区别主副屏
SCREEN部分是整个fb调试过程中，需要更改参数最多的，通常LCD调试只需要调整screen的dts各个参数即可。LCD调试部分请参考另外一篇博文【Rk平台LCD调试说明】
三、struct rk_screen
struct rk_screen { #ifdef CONFIG_DUAL_LCD struct device *dev; int prop; struct list_head *pwrlist_head; //power ctl链表，保存power ctl gpio int native_mode; #endif u16 type; u16 lvds_format; //LVDS数据格式 u16 face; //display out face,18bit,24bit u16 color_mode; u8 lcdc_id; //dual lcd时用于区分LCD u8 screen_id; struct fb_videomode mode; //important u32 post_dsp_stx; u32 post_dsp_sty; u32 post_xsize; u32 post_ysize; u16 x_mirror; u16 y_mirror; int interlace; int pixelrepeat; //For 480i/576i format, pixel is repeated twice." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/38416cc7e0cdebdb5b18131a56daddbb/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2017-03-23T12:21:18+08:00" />
<meta property="article:modified_time" content="2017-03-23T12:21:18+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">RK fb源码分析之SCREEN</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-github-gist">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p><strong>前言</strong> <br> 学习，学而时习之。在工作中，利用闲暇时光简单分析下RK平台下fb源码部分，本人才疏学浅，很多地方理解的也不到位，只是简单的分析下代码流程，搞明白驱动调试过程中需要注意的地方。现将自己的一些理解与建议总结下来，如有错误之处，还望指正。</p> 
<p>RK的LCD这块，亮点也就在于双屏异显，才开始搞驱动时，感觉这就是个高大上的东西，一脸懵逼，不知所措。随着后来慢慢深入才发现，原理和单屏也是差不多的。</p> 
<hr> 
<pre><code>分析之前，我将RK LCD这块首先分为四大块：fb、lcdc、screen、screen_type.这四部分相互依赖，首先从我们最容易入手的地方开始:rk_screen.c
</code></pre> 
<p><strong>一、函数调用关系</strong> <br> rk_screen.c函数调用关系如下： <br> <img src="https://images2.imgbox.com/c0/47/7MiDD4a9_o.png" alt="这里写图片描述" title=""></p> 
<p><strong>二、probe()分析</strong></p> 
<p>毫无疑问，驱动的重点就是probe()函数，驱动在匹配到compatible = “rockchip,screen”后进入probe()函数，rk_screen_probe()： <br> 在probe函数中获取”screen_prop”、”native-mode”等属性，在这里有个重要的结构体：prmry_screen会被初始化，prmry_screen 定义如下： <br> static struct rk_screen *prmry_screen <br> 还有一个结构体：struct rk_screen *rk_screen，rk_screen贯串上下文，并将prmry_screen指向rk_screen，prmry_screen之所以重要,是因为之后screen_type(例如LVDS，EDP,MIPI等)需要获取screen参数，就是获取prmry_screen的值，而这里prmry_screen就是rk_screen。 <br> 进入probe函数有两个函数比较重要：rk_fb_prase_timing_dt()和rk_disp_pwr_ctr_parse_dt。 <br> 首先会根据device_node中”screen_prop”的值，来决定rk_screen的”归属”： <br> <img src="https://images2.imgbox.com/68/62/4nysf9wy_o.jpg" alt="这里写图片描述" title=""> <br> 代码中，dts的”screen_prop”的值决定了屏参文件传递进来后赋值给了谁：prmry_screen或者extend_screen.(NOTE:只有在DUAL_LCD时，screen节点下才会有”screen_prop”属性，单屏，由LCDC部分判断”screen_prop”) <br> rk_fb_prase_timing_dt() <br> <img src="https://images2.imgbox.com/9c/4d/J5UqJDvQ_o.jpg" alt="这里写图片描述" title=""> <br> 通过of_get_display_timings(np)解析device_node中的所有display_timing条目，然后调用 <br> display_timings_get()从结构体display_timing中得到入口地址，最后调用了rk_fb_video_mode_from_timing(dt, screen)从display_timing中获取screen的详细信息，并将其赋值给rk_screen结构体(即prmry_screen).</p> 
<ol><li>rk_disp_pwr_ctr_parse_dt() <br> 该函数主要是从dts中解析power control节点。其中，又引出来一个比较重要的结构体：struct rk_disp_pwr_ctr_list *pwr_ctr;该结构体也是一个双向链表。然后，初始化了一个双向链表rk_screen-&gt;pwrlist_head，最终会将pwr_ctr挂到rk_screen-&gt;pwrlist_head链表下： <br> list_add_tail(&amp;pwr_ctr-&gt;list, rk_screen-&gt;pwrlist_head); <br> <img src="https://images2.imgbox.com/2a/5d/BOK4jP9D_o.jpg" alt="这里写图片描述" title=""> </li></ol> 
<p>for_each_child_of_node(root, child)循环解析每个子节点,例如： <br> <img src="https://images2.imgbox.com/4a/46/BPbzNllk_o.jpg" alt="这里写图片描述" title=""> <br> 首先为每个子节点(如lcd_en,lcd_cs,lcd_rst等)kmalloc一段空间, 解析dts中”rockchip,power_type”的值，rockchip,power_type = GPIO，分别获取其GPIO存至各自的pwr_ctr-&gt;pwr_ctr.gpio中，然后申请GPIO。这里，还有一个值：rockchip,delay，可以控制上电时序的延时操作，这个值在后面用到时再讲。 <br> <img src="https://images2.imgbox.com/16/c4/e47QAYT0_o.jpg" alt="这里写图片描述" title=""> <br> 2. rk_fb_video_mode_from_timing() <br> <img src="https://images2.imgbox.com/35/48/bJMpSnc2_o.jpg" alt="这里写图片描述" title=""> <br> 该函数获取dts中display_timing各个子节点的值，其中有我们熟悉的VBP,VFP,HBP,HFP等可变参数，最终将获取到的值写入变量screen中，这样screen就被初始化完。 <br> 至此，screen部分probe()函数完结，现在总结下： <br> Screen的probe()函数主要干了两件事： <br> 解析dts中的display_timing，获取屏幕信息 <br> 解析dts中的power control，获取LCD的使能脚、片选脚、复位脚 <br> 最终，这些信息都存在了struct rk_screen *rk_screen这个结构体中，也就是prmry_screen这个结构体。那么，prmry_screen这个结构体在什么地方会用到呢？答案也是在rk_screen.c中： <br> <img src="https://images2.imgbox.com/46/c4/kMJ0aQjn_o.jpg" alt="这里写图片描述" title=""> <br> 调用rk_fb_get_screen()这个函数来取得screen的信息。该函数在哪被调用，后续会碰到，暂且不讨论。</p> 
<p>以上部分，是双屏时screen部分的流程，事实上，单屏的代码更为简单。就是在probe()直接调用rk_fb_prase_timing_dt(np, rk_screen)来获取LCD屏信息，获取screen： <br> <img src="https://images2.imgbox.com/92/6d/vaqLVcG8_o.jpg" alt="这里写图片描述" title=""> <br> 区别在于display_timings_get()的第二形参不同</p> 
<p>但是，有些人又有疑问了？那双屏时会去获取power control节点的信息，单屏时为什么不用获取呢？其实也不是没有获取，只不过处理的地方不一样。双屏时，在screen部分获取power control，因为有两个LCD屏，有各自的使能脚、背光脚等等，所以引入链表保存至rk_screen结构体中，待将来使用。而单屏只有一组控制脚，只要在需要的地方获取使用就可以了。后续，只分析单屏的，理清思路即可。</p> 
<p>最后，我们再来总结下probe()的功能： <br> 1.如果是双屏，解析dts中screen节点下的power_ctl节点,单屏的power_ctl节点在别的地方(后续讲述)处理 <br> 2.从dts中获取LCD各个参数(VFP,VBP,HBP,HFP,W,H,CLOCK等等) <br> 3.单屏保存至全局静态变量rk_screen，双屏时分别保存至prmry_screen和extend_screen以区别主副屏</p> 
<p>SCREEN部分是整个fb调试过程中，需要更改参数最多的，通常LCD调试只需要调整screen的dts各个参数即可。LCD调试部分请参考另外一篇博文【Rk平台LCD调试说明】</p> 
<p><strong>三、struct rk_screen</strong></p> 
<pre class="prettyprint"><code class=" hljs vala"><span class="hljs-keyword">struct</span> rk_screen {
<span class="hljs-preprocessor">#ifdef CONFIG_DUAL_LCD</span>
    <span class="hljs-keyword">struct</span> device   *dev;
    <span class="hljs-keyword">int</span> prop;
    <span class="hljs-keyword">struct</span> list_head *pwrlist_head;    <span class="hljs-comment">//power ctl链表，保存power ctl gpio</span>
    <span class="hljs-keyword">int</span> native_mode;
<span class="hljs-preprocessor">#endif</span>
    u16 type;
    u16 lvds_format;    <span class="hljs-comment">//LVDS数据格式</span>
    u16 face;           <span class="hljs-comment">//display out face,18bit,24bit</span>
    u16 color_mode;     
    u8 lcdc_id;         <span class="hljs-comment">//dual lcd时用于区分LCD</span>
    u8 screen_id; 

    <span class="hljs-keyword">struct</span> fb_videomode mode;   <span class="hljs-comment">//important</span>
    u32 post_dsp_stx;
    u32 post_dsp_sty;
    u32 post_xsize;
    u32 post_ysize;
    u16 x_mirror;
    u16 y_mirror;
    <span class="hljs-keyword">int</span> interlace;
    <span class="hljs-keyword">int</span> pixelrepeat; <span class="hljs-comment">//For 480i/576i format, pixel is repeated twice.</span>
    u16 width;
    u16 height;
    u8  ft;
    <span class="hljs-keyword">int</span> *dsp_lut;
    <span class="hljs-keyword">int</span> *cabc_lut;
    <span class="hljs-keyword">int</span> *cabc_gamma_base;

<span class="hljs-preprocessor">#if defined(CONFIG_MFD_RK616) || defined(CONFIG_LCDC_RK312X)</span>
    u32 pll_cfg_val;  <span class="hljs-comment">//bellow are for jettaB</span>
    u32 frac;
    u16 scl_vst;
    u16 scl_hst;
    u16 vif_vst;
    u16 vif_hst;
<span class="hljs-preprocessor">#endif</span>
    u8 hdmi_resolution;
    u8 mcu_wrperiod;
    u8 mcu_usefmk;
    u8 mcu_frmrate;

    u8 pin_hsync;
    u8 pin_vsync;
    u8 pin_den;
    u8 pin_dclk;

    <span class="hljs-comment">/* Swap rule */</span>
    u8 swap_gb;
    u8 swap_rg;
    u8 swap_rb;
    u8 swap_delta;
    u8 swap_dumy;

<span class="hljs-preprocessor">#if defined(CONFIG_MIPI_DSI)</span>
    <span class="hljs-comment">/* MIPI DSI */</span>
    u8 dsi_lane;
    u8 dsi_video_mode;
    u32 hs_tx_clk;
<span class="hljs-preprocessor">#endif</span>

    <span class="hljs-keyword">int</span> xpos;  <span class="hljs-comment">//horizontal display start position on the sceen ,then can be changed by application</span>
    <span class="hljs-keyword">int</span> ypos;
    <span class="hljs-keyword">int</span> xsize; <span class="hljs-comment">//horizontal and vertical display size on he screen,they can be changed by application</span>
    <span class="hljs-keyword">int</span> ysize;
    <span class="hljs-keyword">struct</span> overscan overscan;
    <span class="hljs-keyword">struct</span> rk_screen *ext_screen;
    <span class="hljs-comment">/* Operation function*/</span>
    <span class="hljs-keyword">int</span> (*init)(<span class="hljs-keyword">void</span>);
    <span class="hljs-keyword">int</span> (*standby)(u8 enable);
    <span class="hljs-keyword">int</span> (*refresh)(u8 arg);
    <span class="hljs-keyword">int</span> (*scandir)(u16 dir);
    <span class="hljs-keyword">int</span> (*disparea)(u8 area);
    <span class="hljs-keyword">int</span> (*sscreen_get)(<span class="hljs-keyword">struct</span> rk_screen *screen, u8 resolution);
    <span class="hljs-keyword">int</span> (*sscreen_set)(<span class="hljs-keyword">struct</span> rk_screen *screen, <span class="hljs-keyword">bool</span> type);<span class="hljs-comment">// 1: use scaler 0:bypass</span>
};

<span class="hljs-keyword">struct</span> fb_videomode {
    <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *name;   <span class="hljs-comment">/* optional */</span>
    u32 refresh;        <span class="hljs-comment">/* optional */</span>
    u32 xres;
    u32 yres;
    u32 pixclock;
    u32 left_margin;     
    u32 right_margin;    
    u32 upper_margin;    
    u32 lower_margin;    
    u32 hsync_len;
    u32 vsync_len;
    u32 sync;
    u32 vmode;
    u32 flag;
};
</code></pre> 
<p>SCREEN主要填充rk_screen结构体的各个字段，这个结构体将由SCREEN_TYPE和fb来获取使用。</p> 
<p><strong>后记</strong></p> 
<p>&lt;还记得初学linux驱动时，老版本的内核大量充斥于arch/arm/mach-xxxx下的board文件，相对于现在的dts机制，此时我们是幸福的，也是悲哀的。”我们不是配置工程师!”&gt;</p> 
<p>Email:hellobirthdayzhao@gmail.com</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/6029ca4a79cff0da0abd562becb247c1/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">彻底搞懂CoordinatorLayout</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/dd750d33d273109f0c3c54e3bbb3d166/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">TestFlight 新项目创建新的testflight record，查看和删除</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>