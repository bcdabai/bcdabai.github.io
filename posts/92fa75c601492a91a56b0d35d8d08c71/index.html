<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>js之深拷贝与浅拷贝 - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="js之深拷贝与浅拷贝" />
<meta property="og:description" content="一、拷贝是什么? 从生活中理解,拷贝就是用u盘中复制一份文件到电脑中,或者是将某个文件夹的快捷方式发到桌面上。
拷贝分为两种
浅拷贝深拷贝 二、产生浅拷贝与深拷贝的原因 浅拷贝就是类似于将一个文件夹的快捷方式发送到桌面上,无论是从桌面上打开还是从路径中打开都是对同一个文件夹的操作。
1)从js理解,因为js有基本类型和引用类型之分。
基本类型存放在栈内存中引用类型放在堆内存中
当我们调用一个变量时,实际上是在栈内存中查询该变量, 此时堆内存中的引用类型将地址放在栈内存中。如果我们调用该引用类型,是在栈内存中查找该地址,然后根据对应的地址去调用堆内存中的数据 2)正因为引用类型是放在堆内存中,地址放在栈内存中才有了深拷贝与浅拷贝。所以将一个引用类型直接赋值给另一个变量,只是将栈内存中的地址复制,对堆内存中的数据并未进行任何实质性的操作。
三、解决浅拷贝的办法 1、手动赋值
let obj = { username:&#39;wz&#39;, age:&#39;18&#39;, sex:&#39;male&#39; } //浅拷贝 let obj2 = obj //深拷贝 let obj2 = { username:obj.username, age:obj.age, sex:obj.sex } 2.递归算法
let arr = [] console.log(recurrence(obj)); function recurrence(data) { Object.keys(data).forEach(item =&gt; { if (typeof data[item] === &#34;object&#34;) { return recurrence(data[item]) } arr.push(data[item]) }) return arr } 3、JSON转换
//该方法利用的是JSON.parse(JSON.stringify(obj)) //我对于该方法的理解是利用json格式对于字符串和对象实现灵活的转换 该方法是存在坑点的,我总结一下
obj有时间对象 =&gt; 转换后将还是字符串类型(很好理解,json只能实现字符串和对象转换)obj有函数 =&gt; 转换后函数将是undefined(理由同上) 以下的丢失我并不是太理解,但还是写下吧" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/92fa75c601492a91a56b0d35d8d08c71/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2020-06-03T20:47:07+08:00" />
<meta property="article:modified_time" content="2020-06-03T20:47:07+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">js之深拷贝与浅拷贝</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <h3><a id="_0"></a>一、拷贝是什么?</h3> 
<p>从生活中理解,拷贝就是用u盘中复制一份文件到电脑中,或者是将某个文件夹的快捷方式发到桌面上。</p> 
<p><strong>拷贝分为两种</strong></p> 
<ul><li>浅拷贝</li><li>深拷贝</li></ul> 
<h3><a id="_7"></a>二、产生浅拷贝与深拷贝的原因</h3> 
<p>浅拷贝就是类似于将一个文件夹的快捷方式发送到桌面上,无论是从桌面上打开还是从路径中打开都是对同一个文件夹的操作。<br> 1)<strong>从js理解,因为js有基本类型和引用类型之分。</strong></p> 
<ul><li>基本类型存放在栈内存中</li><li>引用类型放在堆内存中<br> <strong>当我们调用一个变量时,实际上是在栈内存中查询该变量, 此时堆内存中的引用类型将地址放在栈内存中。如果我们调用该引用类型,是在栈内存中查找该地址,然后根据对应的地址去调用堆内存中的数据</strong></li></ul> 
<p>2)正因为引用类型是放在堆内存中,地址放在栈内存中才有了深拷贝与浅拷贝。所以将一个引用类型直接赋值给另一个变量,只是将栈内存中的地址复制,对堆内存中的数据并未进行任何实质性的操作。</p> 
<h3><a id="_16"></a>三、解决浅拷贝的办法</h3> 
<p>1、手动赋值</p> 
<pre><code>let obj = {
	username:'wz',
	age:'18',
	sex:'male'
}

//浅拷贝
let obj2 = obj

//深拷贝
let obj2 = {
	username:obj.username,
	age:obj.age,
	sex:obj.sex
}
</code></pre> 
<p>2.递归算法</p> 
<pre><code>let arr = []
console.log(recurrence(obj));
function recurrence(data) {
    Object.keys(data).forEach(item =&gt; {
        if (typeof data[item] === "object") {
            return recurrence(data[item])
        }
        arr.push(data[item])
    })
    return arr
}
</code></pre> 
<p>3、JSON转换</p> 
<pre><code>	//该方法利用的是JSON.parse(JSON.stringify(obj))
	//我对于该方法的理解是利用json格式对于字符串和对象实现灵活的转换
</code></pre> 
<p><strong>该方法是存在坑点的,我总结一下</strong></p> 
<ul><li>obj有时间对象 =&gt; 转换后将还是字符串类型(很好理解,json只能实现字符串和对象转换)</li><li>obj有函数 =&gt; 转换后函数将是undefined(理由同上)</li></ul> 
<p><strong>以下的丢失我并不是太理解,但还是写下吧</strong></p> 
<ul><li>如果obj里有RegExp、Error对象，则序列化的结果将只得到空对象</li><li>如果obj里有NaN、Infinity和-Infinity，则序列化的结果会变成null</li><li>SON.stringify()只能序列化对象的可枚举的自有属性，例如 如果obj中的对象是有构造函数生成的， 则使用JSON.parse(JSON.stringify(obj))深拷贝后，会丢弃对象的constructor</li><li>如果对象中存在循环引用的情况也无法正确实现深拷贝</li></ul> 
<h3><a id="_66"></a>四、总结</h3> 
<p>json转换是常用的一个深拷贝方式,但是其存在的坑点也是我之前面试遇到的,开发应该是不常见的</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/a3b1ff8928e6042689eaa54f22b193cc/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">课程设计心得_关于switch输入字母进入死循环问题</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/12274d0f867a80680ecdaedb9c961dca/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">tp和laravel 模板输出 html标签</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>