<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Linux2.6.33虚拟文件系统 - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Linux2.6.33虚拟文件系统" />
<meta property="og:description" content="文章目录 VFS对象及其数据结构超级块对象超级块操作索引节点对象索引节点操作目录项对象目录项状态目录项缓存 目录项操作文件对象文件操作 和文件系统相关的数据结构和进程相关的数据结构 虚拟文件系统(虚拟文件交换VFS)作为内核子系统，为用户空间程序提供了文件和文件系统相关的接口系统中所有文件系统不但依赖VFS共存，而且依靠VFS系统协同工作VFS把目录当作文件对待，因此可以对目录执行与文件相同的操作文件相关信息(文件的元数据)，被存储在一个单独的数据结构中，该结构被称为索引节点inode文件系统的控制信息存储在超级块中，超级块是一种包含文件系统信息的数据结构 VFS对象及其数据结构 VFS中有四个主要的对象类型 超级块对象，代表一个具体的已安装文件系统索引节点对象，代表一个具体文件目录项对象，代表一个目录项，是路径的一个组成部分文件对象，代表有进程打开的文件 每个主要对象中都包含一个操作对象，这些操作对象描述了内核针对主要对象可以使用的方法 super_operations对象，其中包含内核针对特定文件系统所能调用的方法，如write_inode()和sync_fs()等方法inode_operations对象，其中包含内核针对特定文件所能调用的方法，如create()和link()等方法dentry_operations对象，其中包含内核针对特定目录所能调用的方法，如d_compare()和d_delete()等方法file_operations对象，其中包含进程针对已打开文件所能调用的方法，如read()和write()等方法 操作对象作为一个结构体指针来实现，此结构体包含指向操作其父对象的函数指针VFS使用了大量结构体对象，如每个注册的文件系统都由file_system_type结构体来表示，描述文件系统及其性能；每一个安装点都用vfsmount结构体表示，包含安装点的相关信息，如位置和安装标志等 超级块对象 各种文件系统都必须实现超级块对象，该对象用于控制存储特定文件系统的信息，通常对应于存放在磁盘特定扇区中的文件系统超级块或文件系统控制块对于并非基于磁盘的文件系统(如基于内存的文件系统sysfs)，会在使用现场创建超级块并将其保存在内存中创建、管理和撤销超级块对象的代码位于fs/super.c中，超级块对象通过alloc_super()函数创建并初始化在文件系统安装时，文件系统会调用该函数以便从磁盘读取文件系统超级块，并且将其信息填充到内存中的超级块对象中 #include &lt;linux/fs.h&gt; struct super_block { struct list_head s_list;//指向所有超级块的连接 dev_t s_dev;//设备标识符 unsigned long s_blocksize;//以字节为单位的块大小 unsigned char s_blocksize_bits;//以位为单位的块大小 unsigned char s_dir;//修改(脏)标志 unsigned long long s_maxbytes;//文件大小上限 struct file_system_type s_type;//文件系统类型 struct super_operations s_op;//超级块方法 struct dquot_operations *dq_op;//磁盘限额方法 struct quotactl_ops *s_qcop;//限额控制方法 struct export_operations *s_export_op;//导出方法 unsigned long s_flags;//挂载标志 unsigned long s_magic;//文件系统的幻术 struct dentry *s_root;//目录挂载点 struct rw_semaphore s_umount;//卸载信号量 struct semaphore s_lock;//超级块信号量 int s_count;//超级块引用计数 int s_need_sync;//尚未同步标志 atomic_t s_active;//活动引用计数 void *s_security;//安全模块 struct xattr_handler **s_xattr;//扩展的属性操作 struct list_head s_inodes;//inodes链表 struct list_head s_dirty;//脏数据链表 struct list_head s_io;//回写链表 struct list_head s_more_io;//更多回写链表 struct list_head s_anon;//匿名目录项 struct list_head s_files;//被分配文件链表 struct list_head s_dentry_lru;//未被使用目录项链表 int s_nr_dentry_unused;//链表总目录项的数目 struct block_device *s_bdev;//相关的块设备 struct mtd_info *s_mtd;//存储磁盘信息 struct list_head s_instances;//该类型文件系统 struct quota_info s_dquot;//限额相关选项 int s_frozen;//frozen标志位 wait_queue_head_t s_wait_unfrozen;//冻结的等待队列 char s_id[32];//文本名字 void *s_fs_info;//文件系统特殊信息 fmode_t s_mode;//安装权限 struct semaphore s_vfs_rename_sem;//重命名信号量 u32 s_time_gran;//时间戳粒度 char *s_subtype;//子类型名称 char *s_options;//已存安装选项 }; 超级块操作 超级块对象有一个成员s_op，指向超级块的操作函数表操作函数表的每一项都是一个指向超级块操作函数的指针，执行文件系统和索引节点的底层操作当文件系统需要对其超级块执行操作时，首先要在超级块对象中寻找需要操作方法 #include &lt;linux/fs." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/1bbc206f03c4535456b2e4fbf6690d89/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2020-07-30T10:53:56+08:00" />
<meta property="article:modified_time" content="2020-07-30T10:53:56+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Linux2.6.33虚拟文件系统</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p></p> 
<div class="toc"> 
 <h4>文章目录</h4> 
 <ul><li><a href="#VFS_6" rel="nofollow">VFS对象及其数据结构</a></li><li><ul><li><a href="#_19" rel="nofollow">超级块对象</a></li><li><a href="#_71" rel="nofollow">超级块操作</a></li><li><a href="#_136" rel="nofollow">索引节点对象</a></li><li><a href="#_192" rel="nofollow">索引节点操作</a></li><li><a href="#_268" rel="nofollow">目录项对象</a></li><li><ul><li><a href="#_298" rel="nofollow">目录项状态</a></li><li><a href="#_304" rel="nofollow">目录项缓存</a></li></ul> 
   </li><li><a href="#_313" rel="nofollow">目录项操作</a></li><li><a href="#_346" rel="nofollow">文件对象</a></li><li><a href="#_377" rel="nofollow">文件操作</a></li></ul> 
  </li><li><a href="#_469" rel="nofollow">和文件系统相关的数据结构</a></li><li><a href="#_534" rel="nofollow">和进程相关的数据结构</a></li></ul> 
</div> 
<p></p> 
<ul><li>虚拟文件系统(虚拟文件交换VFS)作为内核子系统，为用户空间程序提供了文件和文件系统相关的接口</li><li>系统中所有文件系统不但依赖VFS共存，而且依靠VFS系统协同工作</li><li>VFS把目录当作文件对待，因此可以对目录执行与文件相同的操作</li><li>文件相关信息(文件的元数据)，被存储在一个单独的数据结构中，该结构被称为索引节点inode</li><li>文件系统的控制信息存储在超级块中，超级块是一种包含文件系统信息的数据结构</li></ul> 
<h2><a id="VFS_6"></a>VFS对象及其数据结构</h2> 
<ul><li>VFS中有四个主要的对象类型</li></ul> 
<ol><li>超级块对象，代表一个具体的已安装文件系统</li><li>索引节点对象，代表一个具体文件</li><li>目录项对象，代表一个目录项，是路径的一个组成部分</li><li>文件对象，代表有进程打开的文件</li></ol> 
<ul><li>每个主要对象中都包含一个操作对象，这些操作对象描述了内核针对主要对象可以使用的方法</li></ul> 
<ol><li>super_operations对象，其中包含内核针对特定文件系统所能调用的方法，如write_inode()和sync_fs()等方法</li><li>inode_operations对象，其中包含内核针对特定文件所能调用的方法，如create()和link()等方法</li><li>dentry_operations对象，其中包含内核针对特定目录所能调用的方法，如d_compare()和d_delete()等方法</li><li>file_operations对象，其中包含进程针对已打开文件所能调用的方法，如read()和write()等方法</li></ol> 
<ul><li>操作对象作为一个结构体指针来实现，此结构体包含指向操作其父对象的函数指针</li><li>VFS使用了大量结构体对象，如每个注册的文件系统都由file_system_type结构体来表示，描述文件系统及其性能；每一个安装点都用vfsmount结构体表示，包含安装点的相关信息，如位置和安装标志等</li></ul> 
<h3><a id="_19"></a>超级块对象</h3> 
<ul><li>各种文件系统都必须实现超级块对象，该对象用于控制存储特定文件系统的信息，通常对应于存放在磁盘特定扇区中的文件系统超级块或文件系统控制块</li><li>对于并非基于磁盘的文件系统(如基于内存的文件系统sysfs)，会在使用现场创建超级块并将其保存在内存中</li><li>创建、管理和撤销超级块对象的代码位于fs/super.c中，超级块对象通过alloc_super()函数创建并初始化</li><li>在文件系统安装时，文件系统会调用该函数以便从磁盘读取文件系统超级块，并且将其信息填充到内存中的超级块对象中</li></ul> 
<pre><code class="prism language-c"><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;linux/fs.h&gt;</span></span>
<span class="token keyword">struct</span> super_block <span class="token punctuation">{<!-- --></span>
	<span class="token keyword">struct</span> list_head s_list<span class="token punctuation">;</span><span class="token comment">//指向所有超级块的连接</span>
	dev_t s_dev<span class="token punctuation">;</span><span class="token comment">//设备标识符</span>
	<span class="token keyword">unsigned</span> <span class="token keyword">long</span> s_blocksize<span class="token punctuation">;</span><span class="token comment">//以字节为单位的块大小</span>
	<span class="token keyword">unsigned</span> <span class="token keyword">char</span> s_blocksize_bits<span class="token punctuation">;</span><span class="token comment">//以位为单位的块大小</span>
	<span class="token keyword">unsigned</span> <span class="token keyword">char</span> s_dir<span class="token punctuation">;</span><span class="token comment">//修改(脏)标志</span>
	<span class="token keyword">unsigned</span> <span class="token keyword">long</span> <span class="token keyword">long</span> s_maxbytes<span class="token punctuation">;</span><span class="token comment">//文件大小上限</span>
	<span class="token keyword">struct</span> file_system_type s_type<span class="token punctuation">;</span><span class="token comment">//文件系统类型</span>
	<span class="token keyword">struct</span> super_operations s_op<span class="token punctuation">;</span><span class="token comment">//超级块方法</span>
	<span class="token keyword">struct</span> dquot_operations <span class="token operator">*</span>dq_op<span class="token punctuation">;</span><span class="token comment">//磁盘限额方法</span>
	<span class="token keyword">struct</span> quotactl_ops <span class="token operator">*</span>s_qcop<span class="token punctuation">;</span><span class="token comment">//限额控制方法</span>
	<span class="token keyword">struct</span> export_operations <span class="token operator">*</span>s_export_op<span class="token punctuation">;</span><span class="token comment">//导出方法</span>
	<span class="token keyword">unsigned</span> <span class="token keyword">long</span> s_flags<span class="token punctuation">;</span><span class="token comment">//挂载标志</span>
	<span class="token keyword">unsigned</span> <span class="token keyword">long</span> s_magic<span class="token punctuation">;</span><span class="token comment">//文件系统的幻术</span>
	<span class="token keyword">struct</span> dentry <span class="token operator">*</span>s_root<span class="token punctuation">;</span><span class="token comment">//目录挂载点</span>
	<span class="token keyword">struct</span> rw_semaphore s_umount<span class="token punctuation">;</span><span class="token comment">//卸载信号量</span>
	<span class="token keyword">struct</span> semaphore s_lock<span class="token punctuation">;</span><span class="token comment">//超级块信号量</span>
	<span class="token keyword">int</span> s_count<span class="token punctuation">;</span><span class="token comment">//超级块引用计数</span>
	<span class="token keyword">int</span> s_need_sync<span class="token punctuation">;</span><span class="token comment">//尚未同步标志</span>
	atomic_t s_active<span class="token punctuation">;</span><span class="token comment">//活动引用计数</span>
	<span class="token keyword">void</span> <span class="token operator">*</span>s_security<span class="token punctuation">;</span><span class="token comment">//安全模块</span>
	<span class="token keyword">struct</span> xattr_handler <span class="token operator">*</span><span class="token operator">*</span>s_xattr<span class="token punctuation">;</span><span class="token comment">//扩展的属性操作</span>
	<span class="token keyword">struct</span> list_head s_inodes<span class="token punctuation">;</span><span class="token comment">//inodes链表</span>
	<span class="token keyword">struct</span> list_head s_dirty<span class="token punctuation">;</span><span class="token comment">//脏数据链表</span>
	<span class="token keyword">struct</span> list_head s_io<span class="token punctuation">;</span><span class="token comment">//回写链表</span>
	<span class="token keyword">struct</span> list_head s_more_io<span class="token punctuation">;</span><span class="token comment">//更多回写链表</span>
	<span class="token keyword">struct</span> list_head s_anon<span class="token punctuation">;</span><span class="token comment">//匿名目录项</span>
	<span class="token keyword">struct</span> list_head s_files<span class="token punctuation">;</span><span class="token comment">//被分配文件链表</span>
	<span class="token keyword">struct</span> list_head s_dentry_lru<span class="token punctuation">;</span><span class="token comment">//未被使用目录项链表</span>
	<span class="token keyword">int</span> s_nr_dentry_unused<span class="token punctuation">;</span><span class="token comment">//链表总目录项的数目</span>
	<span class="token keyword">struct</span> block_device <span class="token operator">*</span>s_bdev<span class="token punctuation">;</span><span class="token comment">//相关的块设备</span>
	<span class="token keyword">struct</span> mtd_info <span class="token operator">*</span>s_mtd<span class="token punctuation">;</span><span class="token comment">//存储磁盘信息</span>
	<span class="token keyword">struct</span> list_head s_instances<span class="token punctuation">;</span><span class="token comment">//该类型文件系统</span>
	<span class="token keyword">struct</span> quota_info s_dquot<span class="token punctuation">;</span><span class="token comment">//限额相关选项</span>
	<span class="token keyword">int</span> s_frozen<span class="token punctuation">;</span><span class="token comment">//frozen标志位</span>
	wait_queue_head_t s_wait_unfrozen<span class="token punctuation">;</span><span class="token comment">//冻结的等待队列</span>
	<span class="token keyword">char</span> s_id<span class="token punctuation">[</span><span class="token number">32</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token comment">//文本名字</span>
	<span class="token keyword">void</span> <span class="token operator">*</span>s_fs_info<span class="token punctuation">;</span><span class="token comment">//文件系统特殊信息</span>
	fmode_t s_mode<span class="token punctuation">;</span><span class="token comment">//安装权限</span>
	<span class="token keyword">struct</span> semaphore s_vfs_rename_sem<span class="token punctuation">;</span><span class="token comment">//重命名信号量</span>
	u32 s_time_gran<span class="token punctuation">;</span><span class="token comment">//时间戳粒度</span>
	<span class="token keyword">char</span> <span class="token operator">*</span>s_subtype<span class="token punctuation">;</span><span class="token comment">//子类型名称</span>
	<span class="token keyword">char</span> <span class="token operator">*</span>s_options<span class="token punctuation">;</span><span class="token comment">//已存安装选项</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre> 
<h3><a id="_71"></a>超级块操作</h3> 
<ul><li>超级块对象有一个成员s_op，指向超级块的操作函数表</li><li>操作函数表的每一项都是一个指向超级块操作函数的指针，执行文件系统和索引节点的底层操作</li><li>当文件系统需要对其超级块执行操作时，首先要在超级块对象中寻找需要操作方法</li></ul> 
<pre><code class="prism language-c"><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;linux/fs.h&gt;</span></span>
<span class="token keyword">struct</span> super_operations <span class="token punctuation">{<!-- --></span>
	<span class="token keyword">struct</span> inode <span class="token operator">*</span><span class="token punctuation">(</span><span class="token operator">*</span>alloc_inode<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">struct</span> super_block <span class="token operator">*</span>sb<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">void</span> <span class="token punctuation">(</span><span class="token operator">*</span>destroy_inode<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">struct</span> inode<span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">void</span> <span class="token punctuation">(</span><span class="token operator">*</span>dirty_inode<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">struct</span> inode<span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">int</span> <span class="token punctuation">(</span><span class="token operator">*</span>write_inode<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">struct</span> inode<span class="token operator">*</span><span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">void</span> <span class="token punctuation">(</span><span class="token operator">*</span>drop_inode<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">struct</span> inode<span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">void</span> <span class="token punctuation">(</span><span class="token operator">*</span>delete_inode<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">struct</span> inode<span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">void</span> <span class="token punctuation">(</span><span class="token operator">*</span>put_super<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">struct</span> super_block<span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">void</span> <span class="token punctuation">(</span><span class="token operator">*</span>write_super<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">struct</span> super_block<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">int</span> <span class="token punctuation">(</span><span class="token operator">*</span>sync_fs<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">struct</span> super_block <span class="token operator">*</span>sb<span class="token punctuation">,</span> <span class="token keyword">int</span> wait<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">int</span> <span class="token punctuation">(</span><span class="token operator">*</span>freeze_fs<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">struct</span> super_block<span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">int</span> <span class="token punctuation">(</span><span class="token operator">*</span>unfreeze_fs<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">struct</span> super_block<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">int</span> <span class="token punctuation">(</span><span class="token operator">*</span>statfs<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">struct</span> dentry<span class="token operator">*</span><span class="token punctuation">,</span> <span class="token keyword">struct</span> kstatfs<span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">int</span> <span class="token punctuation">(</span><span class="token operator">*</span>remount_fs<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">struct</span> super_block<span class="token operator">*</span><span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token operator">*</span><span class="token punctuation">,</span> <span class="token keyword">char</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">void</span> <span class="token punctuation">(</span><span class="token operator">*</span>clear_inode<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">struct</span> inode<span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">void</span> <span class="token punctuation">(</span><span class="token operator">*</span>umount_begin<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">struct</span> super_block<span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">int</span> <span class="token punctuation">(</span><span class="token operator">*</span>show_options<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">struct</span> seq_file<span class="token operator">*</span><span class="token punctuation">,</span> <span class="token keyword">struct</span> vfsmount<span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">int</span> <span class="token punctuation">(</span><span class="token operator">*</span>show_stats<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">struct</span> seq_file<span class="token operator">*</span><span class="token punctuation">,</span> <span class="token keyword">struct</span> vfsmount<span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	ssize_t <span class="token punctuation">(</span><span class="token operator">*</span>quota_read<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">struct</span> super_block<span class="token operator">*</span><span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token punctuation">,</span> <span class="token keyword">char</span><span class="token operator">*</span><span class="token punctuation">,</span> size_t<span class="token punctuation">,</span> loff_t<span class="token punctuation">)</span><span class="token punctuation">;</span>
	ssize_t <span class="token punctuation">(</span><span class="token operator">*</span>quota_write<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">struct</span> super_block<span class="token operator">*</span><span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">char</span><span class="token operator">*</span><span class="token punctuation">,</span> size_t<span class="token punctuation">,</span> loff_t<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">int</span> <span class="token punctuation">(</span><span class="token operator">*</span>bdev_try_to_free_page<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">struct</span> super_block<span class="token operator">*</span><span class="token punctuation">,</span> <span class="token keyword">struct</span> page<span class="token operator">*</span><span class="token punctuation">,</span> gfp_t<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<pre><code class="prism language-c"><span class="token comment">//如果一个文件系统要写自己的超级块，则调用(其中sb指向文件系统超级块指针)</span>
sb<span class="token operator">-&gt;</span>s_op<span class="token operator">-&gt;</span><span class="token function">write_super</span><span class="token punctuation">(</span>sb<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">//在给定的超级块下创建和初始化一个新的索引节点对象</span>
<span class="token keyword">struct</span> inode <span class="token operator">*</span><span class="token function">alloc_inode</span><span class="token punctuation">(</span><span class="token keyword">struct</span> super_block <span class="token operator">*</span>sb<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">//释放给定的索引节点</span>
<span class="token keyword">void</span> <span class="token function">destroy_inode</span><span class="token punctuation">(</span><span class="token keyword">struct</span> inode <span class="token operator">*</span>inode<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">//VFS在索引节点脏(被修改)时调用此函数，日志文件系统(如ext3和ext4)执行该函数更新日志</span>
<span class="token keyword">void</span> <span class="token function">dirty_inode</span><span class="token punctuation">(</span><span class="token keyword">struct</span> inode <span class="token operator">*</span>inode<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">//将给定的索引节点写入磁盘，wait参数指明操作是否需要同步</span>
<span class="token keyword">void</span> <span class="token function">write_inode</span><span class="token punctuation">(</span><span class="token keyword">struct</span> inode <span class="token operator">*</span>inode<span class="token punctuation">,</span> <span class="token keyword">int</span> wait<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">//在最后一个指向索引节点的引用被释放后，VFS调用该函数删除这个索引节点，普通Unix文件系统不会定义该函数</span>
<span class="token keyword">void</span> <span class="token function">drop_inode</span><span class="token punctuation">(</span><span class="token keyword">struct</span> inode <span class="token operator">*</span>inode<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">//从磁盘上删除给定的索引节点</span>
<span class="token keyword">void</span> <span class="token function">delete_inode</span><span class="token punctuation">(</span><span class="token keyword">struct</span> inode <span class="token operator">*</span>inode<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">//在卸载文件系统时由VFS调用，释放超级块，调用者必须一直持有s_lock锁</span>
<span class="token keyword">void</span> <span class="token function">put_super</span><span class="token punctuation">(</span><span class="token keyword">struct</span> super_block <span class="token operator">*</span>sb<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">//给定的超级块更新磁盘上的超级块，VFS通过该函数对内存中的超级块和磁盘中的超级块进行同步，调用者必须一直持有s_lock锁</span>
<span class="token keyword">void</span> <span class="token function">write_super</span><span class="token punctuation">(</span><span class="token keyword">struct</span> super_block <span class="token operator">*</span>sb<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">//使文件系统的数据元与磁盘上的文件系统同步，wait参数指定操作是否同步</span>
<span class="token keyword">int</span> <span class="token function">sync_fs</span><span class="token punctuation">(</span><span class="token keyword">struct</span> super_block <span class="token operator">*</span>sb<span class="token punctuation">,</span> <span class="token keyword">int</span> wait<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">//首先禁止对文件系统做改变，再使用给定的超级块更新磁盘上的超级快，目前LVM(逻辑卷标管理)调用该函数</span>
<span class="token keyword">void</span> <span class="token function">write_super_lockfs</span><span class="token punctuation">(</span><span class="token keyword">struct</span> super_block <span class="token operator">*</span>sb<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">//对文件系统解除锁定，是write_super_lockfs()的逆操作</span>
<span class="token keyword">void</span> <span class="token function">unlockfs</span><span class="token punctuation">(</span><span class="token keyword">struct</span> super_block <span class="token operator">*</span>sb<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">//VFS通过调用该函数获取文件系统状态，指定文件系统相关的统计信息将放置在statfs中</span>
<span class="token keyword">int</span> <span class="token function">statfs</span><span class="token punctuation">(</span><span class="token keyword">struct</span> super_block <span class="token operator">*</span>sb<span class="token punctuation">,</span> <span class="token keyword">struct</span> statfs <span class="token operator">*</span>statfs<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">//当指定新的安装选项重新安装文件系统时，VFS调用该函数，调用者必须一直持有lock锁</span>
<span class="token keyword">int</span> <span class="token function">remount_fs</span><span class="token punctuation">(</span><span class="token keyword">struct</span> super_block <span class="token operator">*</span>sb<span class="token punctuation">,</span> <span class="token keyword">int</span> <span class="token operator">*</span>flags<span class="token punctuation">,</span> <span class="token keyword">char</span> <span class="token operator">*</span>data<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">//VFS调用该函数释放索引节点，并清空包含相关数据的所有页面</span>
<span class="token keyword">void</span> <span class="token function">clear_inode</span><span class="token punctuation">(</span><span class="token keyword">struct</span> inode <span class="token operator">*</span>inode<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">//VFS调用该函数中断安装操作，该函数被网络文件系统使用，如NFS</span>
<span class="token keyword">void</span> <span class="token function">umount_begin</span><span class="token punctuation">(</span><span class="token keyword">struct</span> super_block <span class="token operator">*</span>sb<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> 
<ul><li>以上函数都是由VFS在进程上下文中调用</li><li>除了dirty_inode()，其他函数在必要时都可以阻塞</li></ul> 
<h3><a id="_136"></a>索引节点对象</h3> 
<ul><li>索引节点对象包含了内核在操作文件或目录时需要的全部信息，对于Unix风格的文件系统，索引节点信息可以从磁盘索引节点之间读入</li><li>如果一个文件系统没有索引节点，那么不管相关信息如何在磁盘存放，文件系统都必须从中提取信息，没有索引节点的文件系统通常将文件的描述信息作为文件的一部分存放</li><li>索引节点必须在内存中创建，以便文件系统使用</li></ul> 
<pre><code class="prism language-c"><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;linux/fs.h&gt;</span></span>
<span class="token keyword">struct</span> inode <span class="token punctuation">{<!-- --></span>
	<span class="token keyword">struct</span> hlist_node i_hash<span class="token punctuation">;</span><span class="token comment">//散列表</span>
	<span class="token keyword">struct</span> list_head i_list<span class="token punctuation">;</span><span class="token comment">//索引节点链表</span>
	<span class="token keyword">struct</span> list_head i_sb_list<span class="token punctuation">;</span><span class="token comment">//超级块链表</span>
	<span class="token keyword">struct</span> list_head i_dentry<span class="token punctuation">;</span><span class="token comment">//目录项链表</span>
	<span class="token keyword">unsigned</span> <span class="token keyword">long</span> i_ino<span class="token punctuation">;</span><span class="token comment">//节点号</span>
	atomic_t i_count<span class="token punctuation">;</span><span class="token comment">//引用计数</span>
	<span class="token keyword">unsigned</span> <span class="token keyword">int</span> i_nlink<span class="token punctuation">;</span><span class="token comment">//硬链接数</span>
	uid_t i_uid<span class="token punctuation">;</span><span class="token comment">//使用者的id</span>
	gid_t i_gid<span class="token punctuation">:</span><span class="token operator">/</span><span class="token operator">/</span>使用组的id
	kdev_t i_rdev<span class="token punctuation">;</span><span class="token comment">//实际设备标识符</span>
	u64 i_version<span class="token punctuation">;</span><span class="token comment">//版本号</span>
	loff_t i_size<span class="token punctuation">;</span><span class="token comment">//以字节为单位的文件大小</span>
	seqcount_t i_size_seqcount<span class="token punctuation">;</span><span class="token comment">//对i_size进行串行计数</span>
	<span class="token keyword">struct</span> timespec i_atime<span class="token punctuation">;</span><span class="token comment">//最后访问时间</span>
	<span class="token keyword">struct</span> timespec i_mtime<span class="token punctuation">;</span><span class="token comment">//最后修改时间</span>
	<span class="token keyword">struct</span> timespec i_ctime<span class="token punctuation">;</span><span class="token comment">//最后改变时间</span>
	<span class="token keyword">unsigned</span> <span class="token keyword">int</span> i_blkbits<span class="token punctuation">;</span><span class="token comment">//以位为单位的块大小</span>
	blkcnt_t i_blocks<span class="token punctuation">;</span><span class="token comment">//文件的块数</span>
	<span class="token keyword">unsigned</span> <span class="token keyword">short</span> i_bytes<span class="token punctuation">;</span><span class="token comment">//使用的字节数</span>
	umode_t i_mode<span class="token punctuation">;</span><span class="token comment">//访问权限</span>
	spinlock_t i_lock<span class="token punctuation">;</span><span class="token comment">//自旋锁</span>
	<span class="token keyword">struct</span> rw_semaphore i_alloc_sem<span class="token punctuation">;</span><span class="token comment">//嵌入i_sem内部</span>
	<span class="token keyword">struct</span> semaphore i_sem<span class="token punctuation">;</span><span class="token comment">//索引节点信号量</span>
	<span class="token keyword">struct</span> inode_operations <span class="token operator">*</span>i_op<span class="token punctuation">;</span><span class="token comment">//索引节点操作表</span>
	<span class="token keyword">struct</span> file_operations <span class="token operator">*</span>i_fop<span class="token punctuation">;</span><span class="token comment">//缺省的索引节点操作</span>
	<span class="token keyword">struct</span> super_block <span class="token operator">*</span>i_sb<span class="token punctuation">;</span><span class="token comment">//相关的超级块</span>
	<span class="token keyword">struct</span> file_lock <span class="token operator">*</span>i_flock<span class="token punctuation">;</span><span class="token comment">//文件锁链表</span>
	<span class="token keyword">struct</span> address_space <span class="token operator">*</span>i_mapping<span class="token punctuation">;</span><span class="token comment">//相关的地址映射</span>
	<span class="token keyword">struct</span> address_apace i_data<span class="token punctuation">;</span><span class="token comment">//设备地址映射</span>
	<span class="token keyword">struct</span> dquot <span class="token operator">*</span>i_dquot<span class="token punctuation">[</span>MAXQUOTAS<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token comment">//索引节点的磁盘限额</span>
	<span class="token keyword">struct</span> list_head i_devices<span class="token punctuation">;</span><span class="token comment">//块设备链表</span>
	<span class="token keyword">union</span> <span class="token punctuation">{<!-- --></span>
		<span class="token keyword">struct</span> pipe_inode_info <span class="token operator">*</span>i_pipe<span class="token punctuation">;</span><span class="token comment">//管道信息</span>
		<span class="token keyword">struct</span> block_device <span class="token operator">*</span>i_bdev<span class="token punctuation">;</span><span class="token comment">//块设备驱动</span>
		<span class="token keyword">struct</span> cdev <span class="token operator">*</span>i_cdev<span class="token comment">//字符设备驱动</span>
	<span class="token punctuation">}</span><span class="token punctuation">;</span>
	<span class="token keyword">unsigned</span> <span class="token keyword">long</span> i_dnotify_mask<span class="token punctuation">;</span><span class="token comment">//目录通知掩码</span>
	<span class="token keyword">struct</span> dnotify_struct <span class="token operator">*</span>i_dnotify<span class="token punctuation">;</span><span class="token comment">//目录通知</span>
	<span class="token keyword">struct</span> list_head inotify_watches<span class="token punctuation">;</span><span class="token comment">//索引节点通知监测链表</span>
	<span class="token keyword">struct</span> mutex inotify_mutex<span class="token punctuation">;</span><span class="token comment">//保护inotify_watches</span>
	<span class="token keyword">unsigned</span> <span class="token keyword">long</span> i_state<span class="token punctuation">;</span><span class="token comment">//状态标志</span>
	<span class="token keyword">unsigned</span> <span class="token keyword">long</span> dirtied_when<span class="token punctuation">;</span><span class="token comment">//第一次弄脏数据的时间</span>
	<span class="token keyword">unsigned</span> <span class="token keyword">int</span> i_flags<span class="token punctuation">;</span><span class="token comment">//文件系统标志</span>
	atomic_t i_writecount<span class="token punctuation">;</span><span class="token comment">//写者技术</span>
	<span class="token keyword">void</span> <span class="token operator">*</span>i_security<span class="token punctuation">;</span><span class="token comment">//安全模块</span>
	<span class="token keyword">void</span> <span class="token operator">*</span>i_private<span class="token punctuation">;</span><span class="token comment">//fs私有指针</span>
<span class="token punctuation">}</span>
</code></pre> 
<ul><li>一个索引节点代表文件系统中(索引节点仅当文件被访问时，才在内存中创建)的一个文件，可以是设备或管道等特殊文件，因此索引节点结构体中与特殊文件相关的项，如i_pipe指向一个代表有名管道的数据结构，i_bdev指向块设备结构体，i_cdev指向字符设备结构体(一个给定的索引节点每次只能表示三者之一，或三者均不)</li></ul> 
<h3><a id="_192"></a>索引节点操作</h3> 
<pre><code class="prism language-c"><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;linux/fs.h&gt;</span></span>
<span class="token keyword">struct</span> inode_operations <span class="token punctuation">{<!-- --></span>
	<span class="token keyword">int</span> <span class="token punctuation">(</span><span class="token operator">*</span>create<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">struct</span> inode<span class="token operator">*</span><span class="token punctuation">,</span> <span class="token keyword">struct</span> dentry<span class="token operator">*</span><span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token punctuation">,</span> <span class="token keyword">struct</span> nameidata<span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">struct</span> dentry <span class="token operator">*</span><span class="token punctuation">(</span><span class="token operator">*</span>lookup<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">struct</span> inode<span class="token operator">*</span><span class="token punctuation">,</span> <span class="token keyword">struct</span> dentry<span class="token operator">*</span><span class="token punctuation">,</span> <span class="token keyword">struct</span> nameidata<span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">int</span> <span class="token punctuation">(</span><span class="token operator">*</span>link<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">struct</span> dentry<span class="token operator">*</span><span class="token punctuation">,</span> <span class="token keyword">struct</span> inode<span class="token operator">*</span><span class="token punctuation">,</span> <span class="token keyword">struct</span> dentry<span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">int</span> <span class="token punctuation">(</span><span class="token operator">*</span>unlink<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">struct</span> inode<span class="token operator">*</span><span class="token punctuation">,</span> <span class="token keyword">struct</span> dentry<span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">int</span> <span class="token punctuation">(</span><span class="token operator">*</span>symlink<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">struct</span> inode<span class="token operator">*</span><span class="token punctuation">,</span> <span class="token keyword">struct</span> dentry<span class="token operator">*</span><span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">char</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">int</span> <span class="token punctuation">(</span><span class="token operator">*</span>mkdir<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">struct</span> inode<span class="token operator">*</span><span class="token punctuation">,</span> <span class="token keyword">struct</span> dentry<span class="token operator">*</span><span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">int</span> <span class="token punctuation">(</span><span class="token operator">*</span>rmdir<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">struct</span> inode<span class="token operator">*</span><span class="token punctuation">,</span> <span class="token keyword">struct</span> dentry<span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">int</span> <span class="token punctuation">(</span><span class="token operator">*</span>mknod<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">struct</span> inode<span class="token operator">*</span><span class="token punctuation">,</span> <span class="token keyword">struct</span> dentry<span class="token operator">*</span><span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token punctuation">,</span> dev_t<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">int</span> <span class="token punctuation">(</span><span class="token operator">*</span>rename<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">struct</span> inode<span class="token operator">*</span><span class="token punctuation">,</span> <span class="token keyword">struct</span> dentry<span class="token operator">*</span><span class="token punctuation">,</span> <span class="token keyword">struct</span> inode<span class="token operator">*</span><span class="token punctuation">,</span> <span class="token keyword">struct</span> dengtry<span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">int</span> <span class="token punctuation">(</span><span class="token operator">*</span>readlink<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">struct</span> dentry<span class="token operator">*</span><span class="token punctuation">,</span> <span class="token keyword">char</span> __user<span class="token operator">*</span><span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">void</span> <span class="token operator">*</span><span class="token punctuation">(</span><span class="token operator">*</span>follow_link<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">struct</span> dentry<span class="token operator">*</span><span class="token punctuation">,</span> <span class="token keyword">struct</span> nameidata<span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">void</span> <span class="token punctuation">(</span><span class="token operator">*</span>put_link<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">struct</span> dentry<span class="token operator">*</span><span class="token punctuation">,</span> <span class="token keyword">struct</span> nameidata<span class="token operator">*</span><span class="token punctuation">,</span> <span class="token keyword">void</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">void</span> <span class="token punctuation">(</span><span class="token operator">*</span>truncate<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">struct</span> inode<span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">int</span> <span class="token punctuation">(</span><span class="token operator">*</span>permission<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">struct</span> inode<span class="token operator">*</span><span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">int</span> <span class="token punctuation">(</span><span class="token operator">*</span>setattr<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">struct</span> dentry<span class="token operator">*</span><span class="token punctuation">,</span> <span class="token keyword">struct</span> iattr<span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">int</span> <span class="token punctuation">(</span><span class="token operator">*</span>getattr<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">struct</span> vfsmount <span class="token operator">*</span>mnt<span class="token punctuation">,</span> <span class="token keyword">struct</span> dentry<span class="token operator">*</span><span class="token punctuation">,</span> <span class="token keyword">struct</span> kstat<span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">int</span> <span class="token punctuation">(</span><span class="token operator">*</span>setxattr<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">struct</span> dentry<span class="token operator">*</span><span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">char</span><span class="token operator">*</span><span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">void</span><span class="token operator">*</span><span class="token punctuation">,</span> size_t<span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	ssize_t <span class="token punctuation">(</span><span class="token operator">*</span>getxattr<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">struct</span> dentry<span class="token operator">*</span><span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">char</span><span class="token operator">*</span><span class="token punctuation">,</span> <span class="token keyword">void</span><span class="token operator">*</span><span class="token punctuation">,</span> size_t<span class="token punctuation">)</span><span class="token punctuation">;</span>
	ssize_t <span class="token punctuation">(</span><span class="token operator">*</span>listxattr<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">struct</span> dentry<span class="token operator">*</span><span class="token punctuation">,</span> <span class="token keyword">char</span><span class="token operator">*</span><span class="token punctuation">,</span> size_t<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">int</span> <span class="token punctuation">(</span><span class="token operator">*</span>removexattr<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">struct</span> dentry<span class="token operator">*</span><span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">char</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">void</span> <span class="token punctuation">(</span><span class="token operator">*</span>truncate_range<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">struct</span> inode<span class="token operator">*</span><span class="token punctuation">,</span> loff_t<span class="token punctuation">,</span> loff_t<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">long</span> <span class="token punctuation">(</span><span class="token operator">*</span>fallocate<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">struct</span> inode<span class="token operator">*</span><span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token punctuation">,</span> loff_t<span class="token punctuation">,</span> loff_t<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">int</span> <span class="token punctuation">(</span><span class="token operator">*</span>filemap<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">struct</span> inode<span class="token operator">*</span><span class="token punctuation">,</span> <span class="token keyword">struct</span> filemap_extent_info<span class="token operator">*</span><span class="token punctuation">,</span> u64<span class="token punctuation">,</span> u64<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<pre><code class="prism language-c"><span class="token comment">//与超级块类型，对索引节点的操作(i指向给定的索引节点)</span>
i<span class="token operator">-&gt;</span>i_op<span class="token operator">-&gt;</span><span class="token function">truncate</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">//VFS通过系统调用create()和open()调用该函数，从而为dentry对象创建一个新的索引节点，在创建时使用mode指定的初始模式</span>
<span class="token keyword">int</span> <span class="token function">create</span><span class="token punctuation">(</span><span class="token keyword">struct</span> inode <span class="token operator">*</span>dir<span class="token punctuation">,</span> <span class="token keyword">struct</span> dentry <span class="token operator">*</span>dentry<span class="token punctuation">,</span> <span class="token keyword">int</span> mode<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">//该函数在特定目录中寻找索引节点，该索引节点要对应于dentry给出的文件名</span>
<span class="token keyword">struct</span> dentry <span class="token operator">*</span><span class="token function">lookup</span><span class="token punctuation">(</span><span class="token keyword">struct</span> inode <span class="token operator">*</span>dir<span class="token punctuation">,</span> <span class="token keyword">struct</span> dentry <span class="token operator">*</span>dentry<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">//该函数被系统调用link()调用，用来创建硬链接，硬链接名称由dentry参数指定，链接对象是dir目录中的old_dentry目录项所代表的文件</span>
<span class="token keyword">int</span> <span class="token function">link</span><span class="token punctuation">(</span><span class="token keyword">struct</span> dentry <span class="token operator">*</span>old_dentry<span class="token punctuation">,</span> <span class="token keyword">struct</span> inode <span class="token operator">*</span>dir<span class="token punctuation">,</span> <span class="token keyword">struct</span> dentry <span class="token operator">*</span>dentry<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">//该函数被系统调用unlink()调用，从目录dir中删除由目录项dentry指定的索引节点对象</span>
<span class="token keyword">int</span> <span class="token function">unlink</span><span class="token punctuation">(</span><span class="token keyword">struct</span> inode <span class="token operator">*</span>dir<span class="token punctuation">,</span> <span class="token keyword">struct</span> dentry <span class="token operator">*</span>dentry<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">//该函数被系统调用symlik()调用，创建符号链接，该符号链接名称由symname指定，链接对象是dir目录中的dentry目录项</span>
<span class="token keyword">int</span> <span class="token function">symlink</span><span class="token punctuation">(</span><span class="token keyword">struct</span> inode <span class="token operator">*</span>dir<span class="token punctuation">,</span> <span class="token keyword">struct</span> dentry <span class="token operator">*</span>dentry<span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>symname<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">//该函数被系统调用mkdir()调用，创建一个新目录，创建是使用mode指定的初始模式</span>
<span class="token keyword">int</span> <span class="token function">mkdir</span><span class="token punctuation">(</span><span class="token keyword">struct</span> inode <span class="token operator">*</span>dir<span class="token punctuation">,</span> <span class="token keyword">struct</span> dentry <span class="token operator">*</span>dentry<span class="token punctuation">,</span> <span class="token keyword">int</span> mode<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">//该函数被系统调用rmdir()调用，删除dir目录中的dengtry目录项代表的文件</span>
<span class="token keyword">int</span> <span class="token function">rmdir</span><span class="token punctuation">(</span><span class="token keyword">struct</span> inode <span class="token operator">*</span>dir<span class="token punctuation">,</span> <span class="token keyword">struct</span> dentry <span class="token operator">*</span>dentry<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">//该函数被系统调用mknod()调用，创建特殊文件(设备文件、命名管道或套接字)，要创建的文件放在dir目录中，其目录项为dentry，关联的设备为rdev，初始权限由mode指定</span>
<span class="token keyword">int</span> <span class="token function">mknod</span><span class="token punctuation">(</span><span class="token keyword">struct</span> inode <span class="token operator">*</span>dir<span class="token punctuation">,</span> <span class="token keyword">struct</span> dentry <span class="token operator">*</span>dentry<span class="token punctuation">,</span> <span class="token keyword">int</span> mode<span class="token punctuation">,</span> dev_t rdev<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">//VFS调用该函数来移动文件，文件源路径在old_dir目录中，源文件由old_dentry目录项指定，目标路径在new_dir目录中，目标文件由new_dentry指定</span>
<span class="token keyword">int</span> <span class="token function">rename</span><span class="token punctuation">(</span><span class="token keyword">struct</span> inode <span class="token operator">*</span>old_dir<span class="token punctuation">,</span> <span class="token keyword">struct</span> dentry <span class="token operator">*</span>old_dentry<span class="token punctuation">,</span> <span class="token keyword">struct</span> inode <span class="token operator">*</span>new_dir<span class="token punctuation">,</span> <span class="token keyword">struct</span> dentry <span class="token operator">*</span>new<span class="token punctuation">)</span>dentry<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">//该函数被系统调用readlink()调用，拷贝数据到特定的缓冲buffer中，拷贝的数据来自dentry指定的符号连接，拷贝大小最大可达buflen字节</span>
<span class="token keyword">int</span> <span class="token function">readlink</span><span class="token punctuation">(</span><span class="token keyword">struct</span> dentry <span class="token operator">*</span>dentry<span class="token punctuation">,</span> <span class="token keyword">char</span> <span class="token operator">*</span>buffer<span class="token punctuation">,</span> <span class="token keyword">int</span> buflen<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">//该函数由VFS调用，从一个符号链接查找指向的索引节点，由dentry指向的链接被解析，其结果存放在由nd指向的nameidata结构体中</span>
<span class="token keyword">int</span> <span class="token function">follow_link</span><span class="token punctuation">(</span><span class="token keyword">struct</span> dentry <span class="token operator">*</span>dentry<span class="token punctuation">,</span> <span class="token keyword">struct</span> nameidata <span class="token operator">*</span>nd<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">//在follow_link()调用之后，该函数由VFS调用进行清除工作</span>
<span class="token keyword">int</span> <span class="token function">put_link</span><span class="token punctuation">(</span><span class="token keyword">struct</span> dentry <span class="token operator">*</span>dentry<span class="token punctuation">,</span> <span class="token keyword">struct</span> nameidata <span class="token operator">*</span>nd<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">//该函数由VFS调用，修改文件的大小，在调用前，索引节点的i_size项必须设置为预期的大小</span>
<span class="token keyword">void</span> <span class="token function">truncate</span><span class="token punctuation">(</span><span class="token keyword">struct</span> inode <span class="token operator">*</span>inode<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">//该函数用来检查给定的inode所代表的文件是否允许特定的访问模式，如果允许返回0，否则返回负值的错误码</span>
<span class="token comment">//多数文件系统都将此区域设置为NULL，使用VFS提供的通用方法进行检查，这种检查仅仅比较索引节点对象中的访问模式位是否和给定的mask一致</span>
<span class="token keyword">int</span> <span class="token function">permission</span><span class="token punctuation">(</span><span class="token keyword">struct</span> inode <span class="token operator">*</span>inode<span class="token punctuation">,</span> <span class="token keyword">int</span> mask<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">//该函数被notify_change()调用，在修改索引节点后，通知发生“改变事件”</span>
<span class="token keyword">int</span> <span class="token function">setattr</span><span class="token punctuation">(</span><span class="token keyword">struct</span> dentry <span class="token operator">*</span>dentry<span class="token punctuation">,</span> <span class="token keyword">struct</span> iattr <span class="token operator">*</span>attr<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">//在通知索引节点需要从磁盘更新时，VFS会调用该函数</span>
<span class="token keyword">int</span> <span class="token function">getattr</span><span class="token punctuation">(</span><span class="token keyword">struct</span> vfsmount <span class="token operator">*</span>mnt<span class="token punctuation">,</span> <span class="token keyword">struct</span> dentry <span class="token operator">*</span>dentry<span class="token punctuation">,</span> <span class="token keyword">struct</span> kstat <span class="token operator">*</span>stat<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">//该函数由VFS调用，给dentry指定的文件设置扩展属性，属性名为name，值为value</span>
<span class="token keyword">int</span> <span class="token function">setxattr</span><span class="token punctuation">(</span><span class="token keyword">struct</span> dentry <span class="token operator">*</span>dentry<span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>name<span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">void</span> <span class="token operator">*</span>value<span class="token punctuation">,</span> size_t size<span class="token punctuation">,</span> <span class="token keyword">int</span> flags<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">//该函数由VFS调用，向value中拷贝指定文件的扩展属性name对应的数值</span>
ssize_t <span class="token function">getxattr</span><span class="token punctuation">(</span><span class="token keyword">struct</span> dentry <span class="token operator">*</span>dentry<span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>name<span class="token punctuation">,</span> <span class="token keyword">void</span> <span class="token operator">*</span>value<span class="token punctuation">,</span> size_t size<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">//该函数将特定文件的所有属性列表拷贝到一个缓冲列表中</span>
ssize_t <span class="token function">listxattr</span><span class="token punctuation">(</span><span class="token keyword">struct</span> dentry <span class="token operator">*</span>dentry<span class="token punctuation">,</span> <span class="token keyword">char</span> <span class="token operator">*</span>list<span class="token punctuation">,</span> size_t size<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">//该函数从给定文件中删除指定的属性</span>
<span class="token keyword">int</span> <span class="token function">removexattr</span><span class="token punctuation">(</span><span class="token keyword">struct</span> dentry <span class="token operator">*</span>dentry<span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> 
<ul><li>在给定的节点上，可能由VFS执行，也有可能由具体的文件系统执行</li></ul> 
<h3><a id="_268"></a>目录项对象</h3> 
<ul><li>VFS把目录当作文件对待，在路径/bin/vi中，bin和vi都属于文件，路径中的每个组成部分都由一个索引节点对象表示</li><li>每个dentry代表路径中的一个特定部分，在路径中(包括普通文件在内)，每一个部分都是目录项对象</li><li>VFS在执行目录操作时(如果需要的话)会现场创建目录项对象</li><li>目录项对象没有对应的磁盘数据结构，VFS根据字符串形式的路径名创建，而且由于目录项对象并非真正保存在磁盘上，所以目录项结构体没有是否被修改的标志</li></ul> 
<pre><code class="prism language-c"><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;linux/dcache.h&gt;</span></span>
<span class="token keyword">struct</span> dentry <span class="token punctuation">{<!-- --></span>
	atomic_t d_count<span class="token punctuation">;</span><span class="token comment">//使用计数</span>
	<span class="token keyword">unsigned</span> <span class="token keyword">int</span> d_flags<span class="token punctuation">;</span><span class="token comment">//目录项标识</span>
	spinlock_t d_lock<span class="token punctuation">;</span><span class="token comment">//单目录项锁</span>
	<span class="token keyword">int</span> d_mounted<span class="token punctuation">;</span><span class="token comment">//是登陆点的目录项吗？</span>
	<span class="token keyword">struct</span> inode <span class="token operator">*</span>d_inode<span class="token punctuation">;</span><span class="token comment">//相关联的索引节点</span>
	<span class="token keyword">struct</span> hlist_node d_hash<span class="token punctuation">;</span><span class="token comment">//散列表</span>
	<span class="token keyword">struct</span> dentry <span class="token operator">*</span>d_parent<span class="token punctuation">;</span><span class="token comment">//父目录的目录项对象</span>
	<span class="token keyword">struct</span> qstr d_name<span class="token punctuation">;</span><span class="token comment">//目录项名称</span>
	<span class="token keyword">struct</span> list_head d_lru<span class="token punctuation">;</span><span class="token comment">//未使用的链表</span>
	<span class="token keyword">union</span> <span class="token punctuation">{<!-- --></span>
		<span class="token keyword">struct</span> list_head d_child<span class="token punctuation">;</span><span class="token comment">//目录项内部形成的链表</span>
		<span class="token keyword">struct</span> rcu_head d_rcu<span class="token punctuation">;</span><span class="token comment">//RCU加锁</span>
	<span class="token punctuation">}</span> d_u<span class="token punctuation">;</span>
	<span class="token keyword">struct</span> list_head d_subdirs<span class="token punctuation">;</span><span class="token comment">//子目录链表</span>
	<span class="token keyword">struct</span> list_head d_alias<span class="token punctuation">;</span><span class="token comment">//索引节点别名链表</span>
	<span class="token keyword">unsigned</span> <span class="token keyword">long</span> d_time<span class="token punctuation">;</span><span class="token comment">//重置时间</span>
	<span class="token keyword">struct</span> dentry_operations <span class="token operator">*</span>d_op<span class="token punctuation">;</span><span class="token comment">//目录项操作指针</span>
	<span class="token keyword">struct</span> super_block <span class="token operator">*</span>d_sb<span class="token punctuation">;</span><span class="token comment">//文件的超级块</span>
	<span class="token keyword">void</span> <span class="token operator">*</span>d_fsdata<span class="token punctuation">;</span><span class="token comment">//文件系统特有数据</span>
	<span class="token keyword">unsigned</span> <span class="token keyword">char</span> d_iname<span class="token punctuation">[</span>DNAME_INLINE_LEN_MIN<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token comment">//短文件名</span>
<span class="token punctuation">}</span>
</code></pre> 
<h4><a id="_298"></a>目录项状态</h4> 
<ul><li>目录项对象有三种有效状态：被使用，未被使用和负状态</li></ul> 
<ol><li>一个被使用的目录项对应一个有效的索引节点(即d_inode指向相应的索引节点)并且表明该对象存在一个或多个使用者(即d_count为正值)，一个目录项处于被使用状态，意味着被VFS使用并且指向有效的数据，因此不能丢弃</li><li>一个未被使用的目录项对应一个有效的索引节点(d_inode指向一个索引节点)，但是应指明VFS当前并未使用(d_count为0)，该目录项对象仍然指向一个有效对象，而且保留在缓存中以便需要时再次使用。由于该目录项不会过早被撤销，所以再次使用时无需重新创建，与未缓存的目录项相比，路径查找更迅速。但如果要回收内存，可以撤销未使用的目录项</li><li>一个负状态的目录项没有对应的有效索引节点(d_inode为NULL)，因为索引节点已被删除，或路径不再正确，但是目录项仍然保留，以便快速解析以后的路径查询。比如，一个守护程序不断地试图打开并读取一个不存在的配置文件，open()系统调用不断返回ENOENT，直到内核构建这个路径、遍历磁盘上的目录结构体并检查这个文件的确不存在为止。即便失败的查询浪费资源，但是将负状态缓存是值得的，但是如果需要，可以撤销目录项对象</li></ol> 
<ul><li>目录项对象被释放后也可以保存到slab对象缓冲中，此时，任何VFS或文件系统代码都没有指向该目录项对象的有效引用</li></ul> 
<h4><a id="_304"></a>目录项缓存</h4> 
<ul><li>内核将目录项对象缓存在目录项缓存(dcache)中</li><li>目录项缓存包括三大主要部分</li></ul> 
<ol><li>“被使用的”目录项链表，该链表通过索引节点对象中的i_dentry项连接相关的索引节点，因为一个给定的索引节点可能有多个链接，所以可能有多个目录项对象，因此使用一个链表来连接它们</li><li>“最近被使用的”双向链表，该链表含有未被使用的和负状态的目录项对象，由于该链表总是在头部插入目录项，所以链头节点的数据总比链尾的数据更新，因此尾部的节点最旧，近期被使用的可能性最小，当内核必须通过删除节点项回收内存时，从链尾删除节点项</li><li>散列表和相应的散列函数用来快速将给定路径解析为相关目录项对象</li></ol> 
<ul><li>散列表有数组dentry_hashtable表示，其中每一个元素都是一个指向具有相同键值的目录项对象链表的指针，数组的大小取决于系统中物理内存的大小</li><li>实际的散列值由d_hash()函数计算，是内核提供给文件系统的唯一的一个散列函数</li><li>查找散列表要通过d_lookup()函数，如果该函数在的cache中发现与其匹配的目录项对象，则匹配的对象被返回，否则，返回NULL指针</li></ul> 
<h3><a id="_313"></a>目录项操作</h3> 
<ul><li>dentry_operation结构体指明了VFS操作目录项的所有方法</li></ul> 
<pre><code class="prism language-c"><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;linux/dcache.h&gt;</span></span>
<span class="token keyword">struct</span> dentry_operations <span class="token punctuation">{<!-- --></span>
	<span class="token keyword">int</span> <span class="token punctuation">(</span><span class="token operator">*</span>d_revalidate<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">struct</span> dentry<span class="token operator">*</span><span class="token punctuation">,</span> <span class="token keyword">struct</span> nameidata<span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">int</span> <span class="token punctuation">(</span><span class="token operator">*</span>d_hash<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">struct</span> dentry<span class="token operator">*</span><span class="token punctuation">,</span> <span class="token keyword">struct</span> qstr<span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">int</span> <span class="token punctuation">(</span><span class="token operator">*</span>d_compare<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">struct</span> dentry<span class="token operator">*</span><span class="token punctuation">,</span> <span class="token keyword">struct</span> qstr<span class="token operator">*</span><span class="token punctuation">,</span> <span class="token keyword">struct</span> qstr<span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">int</span> <span class="token punctuation">(</span><span class="token operator">*</span>d_delete<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">struct</span> dentry<span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">void</span> <span class="token punctuation">(</span><span class="token operator">*</span>d_release<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">struct</span> dentry<span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">void</span> <span class="token punctuation">(</span><span class="token operator">*</span>d_iput<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">struct</span> dentry<span class="token operator">*</span><span class="token punctuation">,</span> <span class="token keyword">struct</span> inode<span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">char</span> <span class="token operator">*</span><span class="token punctuation">(</span><span class="token operator">*</span>d_name<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">struct</span> dentry<span class="token operator">*</span><span class="token punctuation">,</span> <span class="token keyword">char</span><span class="token operator">*</span><span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<pre><code class="prism language-c"><span class="token comment">//该函数判断目录对象是否有效，VFS准备从dcache中使用一个目录项时，会调用该函数</span>
<span class="token comment">//大部分文件系统将该方法置NULL，因为认为dcache中的目录项对象总是有效的</span>
<span class="token keyword">int</span> <span class="token function">d_revalidate</span><span class="token punctuation">(</span><span class="token keyword">struct</span> dentry <span class="token operator">*</span>dentry<span class="token punctuation">,</span> <span class="token keyword">struct</span> nameidata <span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">//该函数为目录项生成散列值，当目录项需要加入到散列表中时，VFS调用该函数</span>
<span class="token keyword">int</span> <span class="token function">d_hash</span><span class="token punctuation">(</span><span class="token keyword">struct</span> dentry <span class="token operator">*</span>dentry<span class="token punctuation">,</span> <span class="token keyword">struct</span> qstr <span class="token operator">*</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">//VFS调用该函数比较name1和name2两个文件名，多数文件系统都使用VFS默认的操作，仅仅做字符串比较</span>
<span class="token comment">//对有些文件系统，如FAT，简单的字符串比较不能满足要求，因为FAT文件系统不区分大小写，所以需要实现不区分大小写的字符串比较函数</span>
<span class="token comment">//使用该函数需要加dcache_lock锁</span>
<span class="token keyword">int</span> <span class="token function">d_compare</span><span class="token punctuation">(</span><span class="token keyword">struct</span> dentry <span class="token operator">*</span>dentry<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">//当目录项对象的d_count计数值等于0时，VFS调用该函数，使用该函数需要加dcache_lock锁和目录项的d_lock锁</span>
<span class="token keyword">int</span> <span class="token function">d_delete</span><span class="token punctuation">(</span><span class="token keyword">struct</span> dentry <span class="token operator">*</span>dentry<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">//当目录项对象将要释放时，VFS调用该函数，默认情况下，啥也不做</span>
<span class="token keyword">void</span> <span class="token function">d_release</span><span class="token punctuation">(</span><span class="token keyword">struct</span> dentry <span class="token operator">*</span>dentry<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">//当一个目录项对象丢失其相关的索引节点时(也就是说磁盘索引节点被删除)，VFS调用该函数</span>
<span class="token comment">//默认情况下VFS会调用iput()函数释放索引节点</span>
<span class="token comment">//如果文件系统重载了该函数，那么除了执行此文件系统特殊的工作外，还必须调用iput()函数</span>
<span class="token keyword">void</span> <span class="token function">d_iput</span><span class="token punctuation">(</span><span class="token keyword">struct</span> dentry <span class="token operator">*</span>dentry<span class="token punctuation">,</span> <span class="token keyword">struct</span> inode <span class="token operator">*</span>inode<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> 
<h3><a id="_346"></a>文件对象</h3> 
<ul><li>文件对象表示进程已打开的文件</li><li>因为多个进程可以同时打开和操作同一个文件，所以同一个文件也可能存在多个对应的文件对象</li><li>类似目录项对象，文件对象实际上没有对应的磁盘数据，所以结构体中没有代表其对象是否为脏、是否需要回写磁盘的标志</li><li>文件对象通过f_dentry指针指向相关的目录项对象，目录项指向相关的索引节点，索引节点会记录文件是否是脏的</li></ul> 
<pre><code class="prism language-c"><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;linux/fs.h&gt;</span></span>
<span class="token keyword">struct</span> file <span class="token punctuation">{<!-- --></span>
	<span class="token keyword">union</span> <span class="token punctuation">{<!-- --></span>
		<span class="token keyword">struct</span> list_head fu_list<span class="token punctuation">;</span><span class="token comment">//文件对象链表</span>
		<span class="token keyword">struct</span> rcu_head fu_rcuhead<span class="token punctuation">;</span><span class="token comment">//释放之后的RCU链表</span>
	<span class="token punctuation">}</span> f_u<span class="token punctuation">;</span>
	<span class="token keyword">struct</span> path f_path<span class="token punctuation">;</span><span class="token comment">//包含目录项</span>
	<span class="token keyword">struct</span> file_operations <span class="token operator">*</span>f_op<span class="token punctuation">;</span><span class="token comment">//文件操作表</span>
	spinlock_t f_lock<span class="token punctuation">;</span><span class="token comment">//当个文件结构锁</span>
	atomic_t f_count<span class="token punctuation">;</span><span class="token comment">//文件对象的使用计数</span>
	<span class="token keyword">unsigned</span> <span class="token keyword">int</span> f_flags<span class="token punctuation">;</span><span class="token comment">//当打开文件时所指定的标志</span>
	mode_t f_mode<span class="token punctuation">;</span><span class="token comment">//文件的访问模式</span>
	loff_t f_pos<span class="token punctuation">;</span><span class="token comment">//文件当前的位移量(文件指针)</span>
	<span class="token keyword">struct</span> fown_struct f_owner<span class="token punctuation">;</span><span class="token comment">//拥有者通过信号进行异步I/O数据的传送</span>
	<span class="token keyword">const</span> <span class="token keyword">struct</span> cred <span class="token operator">*</span>f_cred<span class="token punctuation">;</span><span class="token comment">//文件的信任状态</span>
	<span class="token keyword">struct</span> file_ra_state f_ra<span class="token punctuation">;</span><span class="token comment">//预读状态</span>
	u64 f_version<span class="token punctuation">;</span><span class="token comment">//版本号</span>
	<span class="token keyword">void</span> <span class="token operator">*</span>f_security<span class="token punctuation">;</span><span class="token comment">//安全模块</span>
	<span class="token keyword">void</span> <span class="token operator">*</span>private_data<span class="token punctuation">;</span><span class="token comment">//tty设备驱动的钩子</span>
	<span class="token keyword">struct</span> list_head f_ep_links<span class="token punctuation">;</span><span class="token comment">//事件池链表</span>
	spinlock_t f_ep_lock<span class="token punctuation">;</span><span class="token comment">//事件池锁</span>
	<span class="token keyword">struct</span> address_space <span class="token operator">*</span>f_mapping<span class="token punctuation">;</span><span class="token comment">//页缓存映射</span>
	<span class="token keyword">unsigned</span> <span class="token keyword">long</span> f_mnt_write_state<span class="token punctuation">;</span><span class="token comment">//调试状态</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre> 
<h3><a id="_377"></a>文件操作</h3> 
<pre><code class="prism language-c"><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;linux/fs.h&gt;</span></span>
<span class="token keyword">struct</span> file_operations <span class="token punctuation">{<!-- --></span>
	<span class="token keyword">struct</span> module <span class="token operator">*</span>owner<span class="token punctuation">;</span>
	loff_t <span class="token punctuation">(</span><span class="token operator">*</span>llseek<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">struct</span> file<span class="token operator">*</span><span class="token punctuation">,</span> loff_t<span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	ssize_t <span class="token punctuation">(</span><span class="token operator">*</span>read<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">struct</span> file<span class="token operator">*</span><span class="token punctuation">,</span> <span class="token keyword">char</span> __user<span class="token operator">*</span><span class="token punctuation">,</span> size_t<span class="token punctuation">,</span> loff_t<span class="token operator">*</span><span class="token punctuation">)</span>
	ssize_t <span class="token punctuation">(</span><span class="token operator">*</span>write<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">struct</span> file<span class="token operator">*</span><span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">char</span> __user<span class="token operator">*</span><span class="token punctuation">,</span> size_t<span class="token punctuation">,</span> loff_t<span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	ssize_t <span class="token punctuation">(</span><span class="token operator">*</span>aio_read<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">struct</span> kiocb<span class="token operator">*</span><span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">struct</span> iovec<span class="token operator">*</span><span class="token punctuation">,</span> <span class="token keyword">unsigned</span> <span class="token keyword">long</span><span class="token punctuation">,</span> loff_t<span class="token punctuation">)</span><span class="token punctuation">;</span>
	ssize_t <span class="token punctuation">(</span><span class="token operator">*</span>aio_write<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">struct</span> kiocb<span class="token operator">*</span><span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">struct</span> iovec<span class="token operator">*</span><span class="token punctuation">,</span> <span class="token keyword">unsigned</span> <span class="token keyword">long</span><span class="token punctuation">,</span> loff_t<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">int</span> <span class="token punctuation">(</span><span class="token operator">*</span>readdir<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">struct</span> file<span class="token operator">*</span><span class="token punctuation">,</span> <span class="token keyword">void</span><span class="token operator">*</span><span class="token punctuation">,</span> filldir_t<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">unsigned</span> <span class="token keyword">int</span> <span class="token punctuation">(</span><span class="token operator">*</span>poll<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">struct</span> file<span class="token operator">*</span><span class="token punctuation">,</span> <span class="token keyword">struct</span> poll_table_struct<span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">int</span> <span class="token punctuation">(</span><span class="token operator">*</span>ioctl<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">struct</span> inode<span class="token operator">*</span><span class="token punctuation">,</span> <span class="token keyword">struct</span> file<span class="token operator">*</span><span class="token punctuation">,</span> <span class="token keyword">unsigned</span> <span class="token keyword">int</span><span class="token punctuation">,</span> <span class="token keyword">unsigned</span> <span class="token keyword">long</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">long</span> <span class="token punctuation">(</span><span class="token operator">*</span>unlocked_ioctl<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">struct</span> file<span class="token operator">*</span><span class="token punctuation">,</span> <span class="token keyword">unsigned</span> <span class="token keyword">int</span><span class="token punctuation">,</span> <span class="token keyword">unsigned</span> <span class="token keyword">long</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">long</span> <span class="token punctuation">(</span><span class="token operator">*</span>compat_ioctl<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">struct</span> file<span class="token operator">*</span><span class="token punctuation">,</span> <span class="token keyword">unsigned</span> <span class="token keyword">int</span><span class="token punctuation">,</span> <span class="token keyword">unsigned</span> <span class="token keyword">long</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">int</span> <span class="token punctuation">(</span><span class="token operator">*</span>mmap<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">struct</span> file<span class="token operator">*</span><span class="token punctuation">,</span> <span class="token keyword">struct</span> vm_area_struct<span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">int</span> <span class="token punctuation">(</span><span class="token operator">*</span>open<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">struct</span> inode<span class="token operator">*</span><span class="token punctuation">,</span><span class="token keyword">struct</span> file<span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">int</span> <span class="token punctuation">(</span><span class="token operator">*</span>flush<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">struct</span> file<span class="token operator">*</span><span class="token punctuation">,</span> fl_owner_t id<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">int</span> <span class="token punctuation">(</span><span class="token operator">*</span>release<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">struct</span> inode<span class="token operator">*</span><span class="token punctuation">,</span> <span class="token keyword">struct</span> file<span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">int</span> <span class="token punctuation">(</span><span class="token operator">*</span>fsync<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">struct</span> file<span class="token operator">*</span><span class="token punctuation">,</span> <span class="token keyword">struct</span> dentry<span class="token operator">*</span><span class="token punctuation">,</span> <span class="token keyword">int</span> datasync<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">int</span> <span class="token punctuation">(</span><span class="token operator">*</span>aio_sync<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">struct</span> kiocb<span class="token operator">*</span><span class="token punctuation">,</span> <span class="token keyword">int</span> datasync<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">int</span> <span class="token punctuation">(</span><span class="token operator">*</span>fasync<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">int</span> <span class="token punctuation">,</span><span class="token keyword">struct</span> file<span class="token operator">*</span><span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">int</span> <span class="token punctuation">(</span><span class="token operator">*</span>lock<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">struct</span> file<span class="token operator">*</span><span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token punctuation">,</span> <span class="token keyword">struct</span> file_lock<span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	ssize_t <span class="token punctuation">(</span><span class="token operator">*</span>sendpage<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">struct</span> file<span class="token operator">*</span><span class="token punctuation">,</span> <span class="token keyword">struct</span> page<span class="token operator">*</span><span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token punctuation">,</span> size_t<span class="token punctuation">,</span> loff_t<span class="token operator">*</span><span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">unsigned</span> <span class="token keyword">long</span> <span class="token punctuation">(</span><span class="token operator">*</span>get_unmapped_area<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">struct</span> file<span class="token operator">*</span><span class="token punctuation">,</span> <span class="token keyword">unsigned</span> <span class="token keyword">long</span><span class="token punctuation">,</span> <span class="token keyword">unsigned</span> <span class="token keyword">long</span><span class="token punctuation">,</span> <span class="token keyword">unsigned</span> <span class="token keyword">long</span><span class="token punctuation">,</span> <span class="token keyword">unsigned</span> <span class="token keyword">long</span><span class="token punctuation">,</span> <span class="token keyword">unsigned</span> <span class="token keyword">long</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">int</span> <span class="token punctuation">(</span><span class="token operator">*</span>check_flags<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">int</span> <span class="token punctuation">(</span><span class="token operator">*</span>flock<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">struct</span> file<span class="token operator">*</span><span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token punctuation">,</span> <span class="token keyword">struct</span> file_lock<span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	ssize_t <span class="token punctuation">(</span><span class="token operator">*</span>splice_write<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">struct</span> pipe_inode_info<span class="token operator">*</span><span class="token punctuation">,</span> <span class="token keyword">struct</span> file<span class="token operator">*</span><span class="token punctuation">,</span> loff_t<span class="token operator">*</span><span class="token punctuation">,</span> size_t<span class="token punctuation">,</span> <span class="token keyword">unsigned</span> <span class="token keyword">int</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	ssize_t <span class="token punctuation">(</span><span class="token operator">*</span>splice_read<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">struct</span> file<span class="token operator">*</span><span class="token punctuation">,</span> loff_t<span class="token operator">*</span><span class="token punctuation">,</span> <span class="token keyword">struct</span> pipe_inode_info<span class="token operator">*</span><span class="token punctuation">,</span> size_t<span class="token punctuation">,</span> <span class="token keyword">unsigned</span> <span class="token keyword">int</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">int</span> <span class="token punctuation">(</span><span class="token operator">*</span>setlease<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">struct</span> file<span class="token operator">*</span><span class="token punctuation">,</span> <span class="token keyword">long</span><span class="token punctuation">,</span> <span class="token keyword">struct</span> file_lock<span class="token operator">*</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<pre><code class="prism language-c"><span class="token comment">//该函数用于更新偏移量指针，由系统调用llseek()调用</span>
loff_t <span class="token function">llseek</span><span class="token punctuation">(</span><span class="token keyword">struct</span> file <span class="token operator">*</span>file<span class="token punctuation">,</span> loff_t offset<span class="token punctuation">,</span> <span class="token keyword">int</span> origin<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">//该函数从给定文件的offset偏移处读取count字节的数据到buf中，同时更新文件指针，由系统调用read()调用</span>
ssize_t <span class="token function">read</span><span class="token punctuation">(</span><span class="token keyword">struct</span> file <span class="token operator">*</span>file<span class="token punctuation">,</span> <span class="token keyword">char</span> <span class="token operator">*</span>buf<span class="token punctuation">,</span> size_t count<span class="token punctuation">,</span> loff_t offset<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">//该函数从iocb描述的文件里，以同步方式读取count字节的数据到buf中，由系统调用aio_read()调用</span>
ssize_t <span class="token function">aio_read</span><span class="token punctuation">(</span><span class="token keyword">struct</span> kiocb <span class="token operator">*</span>iocb<span class="token punctuation">,</span> <span class="token keyword">char</span> <span class="token operator">*</span>buf<span class="token punctuation">,</span> size_t count<span class="token punctuation">,</span> loff_t offset<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">//该函数从给定的buf中取出count字节的数据，写入给定文件的offset偏移处，同时更新文件指针，由系统调用write()调用</span>
ssize_t <span class="token function">write</span><span class="token punctuation">(</span><span class="token keyword">struct</span> file <span class="token operator">*</span>file<span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>buf<span class="token punctuation">,</span> size_t count<span class="token punctuation">,</span> loff_t <span class="token operator">*</span>offset<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">//该函数以同步方式从给定的buf中取出count字节的数据，写入由iocb描述的文件中，由系统调用aio_write()调用</span>
ssize_t <span class="token function">aio_write</span><span class="token punctuation">(</span><span class="token keyword">struct</span> kiocb <span class="token operator">*</span>iocb<span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>buf<span class="token punctuation">,</span> size_t count<span class="token punctuation">,</span> loff_t offset<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">//该函数返回目录列表中的下一个目录，由系统调用readdir()调用</span>
<span class="token keyword">int</span> <span class="token function">readdir</span><span class="token punctuation">(</span><span class="token keyword">struct</span> file <span class="token operator">*</span>file<span class="token punctuation">,</span> <span class="token keyword">void</span> <span class="token operator">*</span>dirent<span class="token punctuation">,</span> filldir_t filldir<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">//该函数睡眠等待给定文件活动，由系统调用poll()调用</span>
<span class="token keyword">unsigned</span> <span class="token keyword">int</span> <span class="token function">poll</span><span class="token punctuation">(</span><span class="token keyword">struct</span> file <span class="token operator">*</span>file<span class="token punctuation">,</span> <span class="token keyword">struct</span> poll_table_struct <span class="token operator">*</span>poll_table<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">//该函数用来给设备发送命令参数对，只不过是一个被打开的设备节点时，可以通过它进行设置操作</span>
<span class="token comment">//由系统调用ioctl()调用</span>
<span class="token keyword">int</span> <span class="token function">iotcl</span><span class="token punctuation">(</span><span class="token keyword">struct</span> inode <span class="token operator">*</span>inode<span class="token punctuation">,</span> <span class="token keyword">struct</span> file <span class="token operator">*</span>file<span class="token punctuation">,</span> <span class="token keyword">unsigned</span> <span class="token keyword">int</span> cmd<span class="token punctuation">,</span> <span class="token keyword">unsigned</span> <span class="token keyword">long</span> arg<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">//与ioctl()类似功能，只不过不需要调用者持有BKL</span>
<span class="token comment">//如果用户空间调用ioctl()系统调用，VFS便可以调用unlocked_ioctl()</span>
<span class="token comment">//因此文件系统只需要实现其中一个，一般优先实现unlocked_ioctl()</span>
<span class="token keyword">int</span> <span class="token function">unlocked_ioctl</span><span class="token punctuation">(</span><span class="token keyword">struct</span> file <span class="token operator">*</span>file<span class="token punctuation">,</span> <span class="token keyword">unsigned</span> <span class="token keyword">int</span> cmd<span class="token punctuation">,</span> <span class="token keyword">unsigned</span> <span class="token keyword">long</span> arg<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">//该函数时ioctl()函数的可移植变种，被32位应用程序用在64位系统上</span>
<span class="token comment">//这个函数被设计成即使在得到4位的体系结构上对32位也是安全的，可以进行必要的字大小转换</span>
<span class="token comment">//新的驱动程序应该设计ioctl命令以便所有的驱动程序都是可移植的，从而使得compat_ioctl()和unlocked_ioctl()指向同一个函数</span>
<span class="token keyword">int</span> <span class="token function">compat_ioctl</span><span class="token punctuation">(</span><span class="token keyword">struct</span> file <span class="token operator">*</span>file<span class="token punctuation">,</span> <span class="token keyword">unsigned</span> <span class="token keyword">int</span> cmd<span class="token punctuation">,</span> <span class="token keyword">unsigned</span> <span class="token keyword">long</span> arg<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">//该函数将给定的文件映射到指定的地址空间上，由系统调用mmap()调用</span>
<span class="token keyword">int</span> <span class="token function">mmap</span><span class="token punctuation">(</span><span class="token keyword">struct</span> file <span class="token operator">*</span>file<span class="token punctuation">,</span> <span class="token keyword">struct</span> vm_area_struct <span class="token operator">*</span>vm<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">//该函数创建一个新的文件对象，并将它和相应的索引节点对象关联起来，由系统调用open()调用</span>
<span class="token keyword">int</span> <span class="token function">open</span><span class="token punctuation">(</span><span class="token keyword">struct</span> inode <span class="token operator">*</span>inode<span class="token punctuation">,</span> <span class="token keyword">struct</span> file <span class="token operator">*</span>file<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">//当打开文件的引用计数减少时，该函数被VFS调用，作用依据文件系统而定</span>
<span class="token keyword">int</span> <span class="token function">flush</span><span class="token punctuation">(</span><span class="token keyword">struct</span> file <span class="token operator">*</span>file<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">//当文件的最后一个引用被注销时(比如当最后一个共享文件描述符的进程调用了close()或退出时)，该函数会被VFS调用，作用根据具体文件系统而定</span>
<span class="token keyword">int</span> <span class="token function">release</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token keyword">struct</span> inode <span class="token operator">*</span>inode<span class="token punctuation">,</span> <span class="token keyword">struct</span> file <span class="token operator">*</span>file<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">//将给定文件的所有被缓存数据写回磁盘，由系统调用fsync()调用</span>
<span class="token keyword">int</span> <span class="token function">fsync</span><span class="token punctuation">(</span><span class="token keyword">struct</span> file <span class="token operator">*</span>file<span class="token punctuation">,</span> <span class="token keyword">struct</span> dentry <span class="token operator">*</span>dentry<span class="token punctuation">,</span> <span class="token keyword">int</span> datasync<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">//将iocb描述的文件所有被缓存数据写回到磁盘，由系统调用aio_fsync()调用</span>
<span class="token keyword">int</span> <span class="token function">aio_fsync</span><span class="token punctuation">(</span><span class="token keyword">struct</span> kiocb <span class="token operator">*</span>iocb<span class="token punctuation">,</span> <span class="token keyword">int</span> datasync<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">//该函数用于打开或关闭异步I/O的通告信号</span>
<span class="token keyword">int</span> <span class="token function">fasync</span><span class="token punctuation">(</span><span class="token keyword">int</span> fd<span class="token punctuation">,</span> <span class="token keyword">struct</span> file <span class="token operator">*</span>file<span class="token punctuation">,</span> <span class="token keyword">int</span> no<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">//该函数用于给定文件上锁</span>
<span class="token keyword">int</span> <span class="token function">lock</span><span class="token punctuation">(</span><span class="token keyword">struct</span> file <span class="token operator">*</span>file<span class="token punctuation">,</span> <span class="token keyword">int</span> cmd<span class="token punctuation">,</span> <span class="token keyword">struct</span> file_lock <span class="token operator">*</span>lock<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">//该函数从给定文件中读取数据，并将其写入由vector描述的count个缓冲中去，同时增加文件的偏移量，由系统调用readv()调用</span>
ssize_t <span class="token function">readv</span><span class="token punctuation">(</span><span class="token keyword">struct</span> file <span class="token operator">*</span>file<span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">struct</span> iovec <span class="token operator">*</span>vector<span class="token punctuation">,</span> <span class="token keyword">unsigned</span> <span class="token keyword">long</span> count<span class="token punctuation">,</span> loff_t <span class="token operator">*</span>offset<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">//该函数将由vector描述的count个缓冲中的数据写入由file指定的文件中去，同时减少文件的偏移量，由系统调用writev()调用</span>
ssize_t <span class="token function">writev</span><span class="token punctuation">(</span><span class="token keyword">struct</span> file <span class="token operator">*</span>file<span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">struct</span> iovec <span class="token operator">*</span>vector<span class="token punctuation">,</span> <span class="token keyword">unsigned</span> <span class="token keyword">long</span> count<span class="token punctuation">,</span> loff_t <span class="token operator">*</span>offset<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">//该函数用于从一个文件拷贝数据到另一个文件中，执行的拷贝操作完全在内核中完成，避免向用户空间进行不必要的拷贝，由系统调用sendfile()调用</span>
ssize_t <span class="token function">sendfile</span><span class="token punctuation">(</span><span class="token keyword">struct</span> file <span class="token operator">*</span>file<span class="token punctuation">,</span> loff_t <span class="token operator">*</span>offset<span class="token punctuation">,</span> size_t size<span class="token punctuation">,</span> read_actor_t actor<span class="token punctuation">,</span> <span class="token keyword">void</span> <span class="token operator">*</span>target<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">//该函数用来从一个文件向另一个文件发送数据</span>
ssize_t <span class="token function">sendpage</span><span class="token punctuation">(</span><span class="token keyword">struct</span> file <span class="token operator">*</span>file<span class="token punctuation">,</span> <span class="token keyword">struct</span> page <span class="token operator">*</span>page<span class="token punctuation">,</span> <span class="token keyword">int</span> offset<span class="token punctuation">,</span> size_t size<span class="token punctuation">,</span> loff_t <span class="token operator">*</span>pos<span class="token punctuation">,</span> <span class="token keyword">int</span> more<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">//该函数用于获取未使用的地址空间来映射给定的文件</span>
<span class="token keyword">unsigned</span> <span class="token keyword">long</span> <span class="token function">get_unmapped_area</span><span class="token punctuation">(</span><span class="token keyword">struct</span> file <span class="token operator">*</span>file<span class="token punctuation">,</span> <span class="token keyword">unsigned</span> <span class="token keyword">long</span> addr<span class="token punctuation">,</span> <span class="token keyword">unsigned</span> <span class="token keyword">long</span> len<span class="token punctuation">,</span> <span class="token keyword">unsigned</span> <span class="token keyword">long</span> offset<span class="token punctuation">,</span> <span class="token keyword">unsigned</span> <span class="token keyword">long</span> flags<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">//当给出SETFL命令时，这个函数用来检查传递给fcntl()系统调用的flags的有效性</span>
<span class="token comment">//与大多数VFS操作一样，文件系统不必实现check_flags()，目前只有NFS文件系统上实现</span>
<span class="token comment">//这个函数能使文件系统限制无效的SETFL标志，不进行限制，普通的fcntl()函数能使标志生效</span>
<span class="token comment">//在NFS文件系统中，不允许把O_APPEND和O_DIRECT相结合</span>
<span class="token keyword">int</span> <span class="token function">check_flags</span><span class="token punctuation">(</span><span class="token keyword">int</span> flags<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">//该函数用来实现flock()系统调用，该调用提供忠告锁</span>
<span class="token keyword">int</span> <span class="token function">flock</span><span class="token punctuation">(</span><span class="token keyword">struct</span> file <span class="token operator">*</span>file<span class="token punctuation">,</span> <span class="token keyword">int</span> cmd<span class="token punctuation">,</span> <span class="token keyword">struct</span> file_lock <span class="token operator">*</span>fl<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> 
<h2><a id="_469"></a>和文件系统相关的数据结构</h2> 
<ul><li>file_system_type用来描述各种特定文件系统类型，如ext3、ext4或UDF</li><li>vfsmount用来描述一个安装文件系统的实例</li></ul> 
<pre><code class="prism language-c"><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;linux/fs.h&gt;</span></span>
<span class="token keyword">struct</span> file_system_type <span class="token punctuation">{<!-- --></span>
	<span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>name<span class="token punctuation">;</span><span class="token comment">//文件系统的名字</span>
	<span class="token keyword">int</span> fs_flags<span class="token punctuation">;</span><span class="token comment">//文件系统类型标志</span>
	<span class="token comment">/*该函数用来从磁盘中读取超级块*/</span>
	<span class="token keyword">struct</span> super_block <span class="token operator">*</span><span class="token punctuation">(</span><span class="token operator">*</span>get_sb<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">struct</span> file_system_type<span class="token operator">*</span><span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token punctuation">,</span> <span class="token keyword">char</span><span class="token operator">*</span><span class="token punctuation">,</span> <span class="token keyword">void</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token comment">/*该函数用来终止访问超级块*/</span>
	<span class="token keyword">void</span> <span class="token punctuation">(</span><span class="token operator">*</span>kill_sb<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">struct</span> super_block<span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	
	<span class="token keyword">struct</span> module <span class="token operator">*</span>owner<span class="token punctuation">;</span><span class="token comment">//文件系统模块</span>
	<span class="token keyword">struct</span> file_system_type <span class="token operator">*</span>next<span class="token punctuation">;</span><span class="token comment">//链表中下一个文件系统类型</span>
	<span class="token keyword">struct</span> list_head fs_supers<span class="token punctuation">;</span><span class="token comment">//超级块对象链表</span>
	<span class="token comment">/*剩下的几个字段运行时使锁生效*/</span>
	<span class="token keyword">struct</span> lock_class_key s_lock_key<span class="token punctuation">;</span>
	<span class="token keyword">struct</span> lock_class_key s_umount_key<span class="token punctuation">;</span>
	<span class="token keyword">struct</span> lock_class_key i_lock_key<span class="token punctuation">;</span>
	<span class="token keyword">struct</span> lock_class_key i_mutex_key<span class="token punctuation">;</span>
	<span class="token keyword">struct</span> lock_class_key i_mutex_dir_key<span class="token punctuation">;</span>
	<span class="token keyword">struct</span> lock_class_key i_alloc_sem_key<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<ul><li>get_sb()函数从磁盘读取超级块，并且在文件系统被安装时，在内存中组装超级块对象，剩余的成员描述文件系统的属性</li><li>每种文件系统，不管多数实例安装到系统中，还是没有安装到系统中，都只有一个file_system_type结构</li></ul> 
<pre><code class="prism language-c"><span class="token macro property">#inlude &lt;linux/mount.h&gt;</span>
<span class="token keyword">struct</span> vfsmount <span class="token punctuation">{<!-- --></span>
	<span class="token keyword">struct</span> list_head mnt_hash<span class="token punctuation">;</span><span class="token comment">//散列表</span>
	<span class="token keyword">struct</span> vfsmount <span class="token operator">*</span>mnt_parent<span class="token punctuation">;</span><span class="token comment">//父文件系统</span>
	<span class="token keyword">struct</span> dentry <span class="token operator">*</span>mnt_mountpoint<span class="token punctuation">;</span><span class="token comment">//安装点的目录项</span>
	<span class="token keyword">struct</span> dentry <span class="token operator">*</span>mnt_root<span class="token punctuation">;</span><span class="token comment">//该文件系统的根目录项</span>
	<span class="token keyword">struct</span> super_block <span class="token operator">*</span>mnt_sb<span class="token punctuation">;</span><span class="token comment">//该文件系统的超级块</span>
	<span class="token keyword">struct</span> list_head mnt_mounts<span class="token punctuation">;</span><span class="token comment">//子文件系统链表</span>
	<span class="token keyword">struct</span> list_head mnt_child<span class="token punctuation">;</span><span class="token comment">//子文件系统链表</span>
	<span class="token keyword">int</span> mnt_flags<span class="token punctuation">;</span><span class="token comment">//安装标志</span>
	<span class="token keyword">char</span> <span class="token operator">*</span>mnt_devname<span class="token punctuation">;</span><span class="token comment">//设备文件名</span>
	<span class="token keyword">struct</span> list_head mnt_list<span class="token punctuation">;</span><span class="token comment">//描述符链表</span>
	<span class="token keyword">struct</span> list_head mnt_expire<span class="token punctuation">;</span><span class="token comment">//到期链表的入口</span>
	<span class="token keyword">struct</span> list_head mnt_share<span class="token punctuation">;</span><span class="token comment">//共享安装链表的入口</span>
	<span class="token keyword">struct</span> list_head mnt_slave_list<span class="token punctuation">;</span><span class="token comment">//从安装链表</span>
	<span class="token keyword">struct</span> list_head mnt_slave<span class="token punctuation">;</span><span class="token comment">//从安装链表的入口</span>
	<span class="token keyword">struct</span> vfsmount <span class="token operator">*</span>mnt_master<span class="token punctuation">;</span><span class="token comment">//相关的命名空间</span>
	<span class="token keyword">int</span> mnt_id<span class="token punctuation">;</span><span class="token comment">//安装标识符</span>
	<span class="token keyword">int</span> mnt_group_id<span class="token punctuation">;</span><span class="token comment">//组标识符</span>
	atomic_t mnt_count<span class="token punctuation">;</span><span class="token comment">//使用计数</span>
	<span class="token keyword">int</span> mnt_expiry_mark<span class="token punctuation">;</span><span class="token comment">//如果标记到期，则值为真</span>
	<span class="token keyword">int</span> mnt_pinned<span class="token punctuation">;</span><span class="token comment">//”钉住“进程计数</span>
	<span class="token keyword">int</span> mnt_ghosts<span class="token punctuation">;</span><span class="token comment">//“镜像”引用计数</span>
	atomic_t __mnt_writers<span class="token punctuation">;</span><span class="token comment">//写者引用计数</span>
	
<span class="token punctuation">}</span>
</code></pre> 
<ul><li>当文件系统被实际安装时，将有一个vfsmount结构体在安装点被创建，该结构体代表文件系统的实例，也就是说代表一个安装点</li><li>vfsmount结构保存在安装时指定的标志信息，该信息存储在mnt_flags中</li></ul> 
<p>标准安装标准列表</p> 
<table><thead><tr><th>标准</th><th>描述</th></tr></thead><tbody><tr><td>MNT_NOSUID</td><td>禁止该文件系统的可执行文件设置setuid和setgid标志</td></tr><tr><td>MNT_MODEV</td><td>禁止访问该文件系统上的设备文件</td></tr><tr><td>MNT_NOEXEC</td><td>禁止执行该文件系统上的可执行文件</td></tr></tbody></table> 
<h2><a id="_534"></a>和进程相关的数据结构</h2> 
<ul><li>系统中的每一个进程都有自己的一组打开的文件，像根文件系统、当前工作目录、安装点等</li><li>有三个数据结构将VFS层和系统的进程紧密联系，分别是：file_struct、fs_struct和namespace结构体</li><li>file_struct该结构体由进程描述符中的files目录项指向，所有与单个进程(per_process)相关信息(如打开的文件及文件描述符)都包含在其中</li></ul> 
<pre><code class="prism language-c"><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;linux/fdtable.h&gt;</span></span>
<span class="token keyword">struct</span> files_strcut <span class="token punctuation">{<!-- --></span>
	atomic_t count<span class="token punctuation">;</span><span class="token comment">//结构的使用计数</span>
	<span class="token keyword">struct</span> fdtable <span class="token operator">*</span>fdt<span class="token punctuation">;</span><span class="token comment">//指向其他fa表的指针</span>
	<span class="token keyword">struct</span> fdtable fdtab<span class="token punctuation">;</span><span class="token comment">//fd表</span>
	spinlock_t file_lock<span class="token punctuation">;</span><span class="token comment">//单个文件的锁</span>
	<span class="token keyword">int</span> next_fd<span class="token punctuation">;</span><span class="token comment">//缓存下一个可用的fd</span>
	<span class="token keyword">struct</span> embedded_fd_set close_on_exec_init<span class="token punctuation">;</span><span class="token comment">//exec()时关闭的文件描述符链表</span>
	<span class="token keyword">struct</span> embedded_fd_set open_fds_init<span class="token punctuation">;</span><span class="token comment">//打开的文件描述符链表</span>
	<span class="token keyword">struct</span> file <span class="token operator">*</span>fd_array<span class="token punctuation">[</span>NR_OPEN_DEFAULT<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token comment">//缺省的文件对象数组</span>
<span class="token punctuation">}</span>
</code></pre> 
<ol><li>fd_array数组指针指向已打开的文件对象，因为NR_OPEN_DEFAULT等于BITS_PER_LONG，在64位机器体系结构中这个宏的值为64，所以该数组可以容纳64个文件对象</li><li>如果一个进程所打开的文件对象超过64个，内核将分配一个新数组，并且将fdt指针指向新数组</li></ol> 
<ul><li>fs_struct该结构由进程描述符fs成员指向，包含文件系统和进程相关的信息</li></ul> 
<pre><code class="prism language-c"><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;linux/fs_struct.h&gt;</span></span>
<span class="token keyword">struct</span> fs_struct <span class="token punctuation">{<!-- --></span>
	<span class="token keyword">int</span> users<span class="token punctuation">;</span><span class="token comment">//用户数目</span>
	rwlock_t lock<span class="token punctuation">;</span><span class="token comment">//包含该结构体的锁</span>
	<span class="token keyword">int</span> umask<span class="token punctuation">;</span><span class="token comment">//掩码</span>
	<span class="token keyword">int</span> in_exec<span class="token punctuation">;</span><span class="token comment">//当前正在执行的文件</span>
	<span class="token keyword">struct</span> path root<span class="token punctuation">;</span><span class="token comment">//根目录路径</span>
	<span class="token keyword">struct</span> path pwd<span class="token punctuation">;</span><span class="token comment">//当前工作目录路径</span>
<span class="token punctuation">}</span>
</code></pre> 
<ul><li>namespace，由进程描述符中的mmt_namespace成员指向，2.4版内核以后，单进程命名空间被加入内核，使得每一个进程在系统中都看到唯一的安装文件系统</li></ul> 
<pre><code class="prism language-c"><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;linux/mmt_namespace.h&gt;</span></span>
<span class="token keyword">struct</span> mmt_namespace <span class="token punctuation">{<!-- --></span>
	atomic_t count<span class="token punctuation">;</span><span class="token comment">//结构的使用计数</span>
	<span class="token keyword">struct</span> vfsmount <span class="token operator">*</span>root<span class="token punctuation">;</span><span class="token comment">//根目录的安装点对象</span>
	<span class="token keyword">struct</span> list_head list<span class="token punctuation">;</span><span class="token comment">//安装点链表</span>
	wait_queue_head_t poll<span class="token punctuation">;</span><span class="token comment">//轮询的等待队列</span>
	<span class="token keyword">int</span> event<span class="token punctuation">;</span><span class="token comment">//事件计数</span>
<span class="token punctuation">}</span>
</code></pre> 
<ol><li>list成员时连接已安装文件系统的双向链表，包含的元素组成了全体命名空间</li></ol> 
<ul><li>三个主要数据结构都是通过进程描述符连接起来，对多数进程来说，进程描述符都指向唯一的files_struct和fs_struct结构体，但是对于哪些使用克隆标志CLONE_FILES或CLONE_FS创建的进程，会共享这两个结构体，所以多个进程描述符可能指向同一个files_struct和fs_struct结构体，每个结构体都维护一个count成员作为引用计数，防止进程正在使用该结构时，该结构被撤销</li><li>namespace结构体在默认情况下，所有进程共享同样的命名空间(也就是说，都从相同的挂载表中看到同一个文件系统层次结构)，只有在进行clone()操作时使用CLONE_NEWS标志，才会给进程一个唯一的命名空间结构体的拷贝，因为大多数进程不提供该标志，所有进程都继承其父进程的命名空间</li></ul>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/0bdc93693d12a6959640ef7e918f3351/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">scala的match匹配基础代码</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/f624d8e4148fd65df46bce55632e8905/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">c#  在控件TabControl中的子控件TabItem中显示的窗口怎么一起关闭</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>