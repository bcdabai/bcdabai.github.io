<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>【总结】用户权限设置和进程权限提升 - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="【总结】用户权限设置和进程权限提升" />
<meta property="og:description" content="使用某些Windows API的时候需要提升进程的默认权限，例如RegRestoreKey需要SE_RESTORE_NAME 和SE_BACKUP_NAME 权限。在这种情况下，我们需要使用到一组Windows API提升进程权限。需要的函数有：
1.OpenProcessToken
2.LookupPrivilegeValue
3.AdjustTokenPrivileges
使用这组函数提升权限的前提是进程具备该权限，只是访问令牌中没有启用该权限。如果进程的访问令牌中本身就没有关联该权限，这AdjustTokenPrivileges函数调用将会返回ERROR_NOT_ALL_ASSIGNED（值为1300L）的错误码。如何让进程具有该权限？可以通过“控制面板”—“管理工具”—“本地安全策略”—“本地策略”—“用户权利指派”设置将该权限关联到指定的用户分组或用户上。具体设置如下图所示：
win7之本地安全策略启动:
1.单击“控制面板”--“系统和安全”--“管理工具”--“本地安全策略”，会进入“本地安全策略”界面。 2..win&#43;R--secpol.msc，也可以。
利用AdjustTokenPrivileges提升权限，准确的说不是提升，而是将访问令牌中禁用的权限启用。
BOOL SetPrivilege( HANDLE hToken, // access token handle LPCTSTR lpszPrivilege, // name of privilege to enable/disable BOOL bEnablePrivilege // to enable or disable privilege ) { TOKEN_PRIVILEGES tp; LUID luid; if ( !LookupPrivilegeValue( NULL, // lookup privilege on local system lpszPrivilege, // privilege to lookup &amp;luid ) ) // receives LUID of privilege { printf(&#34;LookupPrivilegeValue error: %u\n&#34;" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/4645a854e26173f4cb81e9207f89cfad/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2013-11-29T20:23:34+08:00" />
<meta property="article:modified_time" content="2013-11-29T20:23:34+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">【总结】用户权限设置和进程权限提升</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <span style="font-size:18px">使用某些Windows API的时候需要提升进程的默认权限，例如RegRestoreKey需要SE_RESTORE_NAME 和SE_BACKUP_NAME 权限。在这种情况下，我们需要使用到一组Windows API提升进程权限。需要的函数有：<br> <br> <span style="color:#ff0000">1.OpenProcessToken<br> 2.LookupPrivilegeValue<br> 3.AdjustTokenPrivileges</span><br> </span> 
<p><span style="font-size:18px">使用这组函数提升权限的<span style="color:#ff0000">前提是进程具备该权限，只是访问令牌中没有启用该权限</span>。<span style="color:#ff0000">如果进程的访问令牌中本身就没有关联该权限，这AdjustTokenPrivileges函数调用将会返回ERROR_NOT_ALL_ASSIGNED（值为1300L）的错误码</span>。如何让进程具有该权限？可以通过“控制面板”—“管理工具”—“本地安全策略”—“本地策略”—“用户权利指派”设置将该权限关联到指定的用户分组或用户上。具体设置如下图所示：</span></p> 
<p><span style="font-size:18px"><img src="https://images2.imgbox.com/86/b1/jTTLdNcS_o.jpg" alt=""><br> </span></p> 
<p><span style="font-size:18px"><span style="white-space:pre"></span><span style="color:#ff0000">win7之本地安全策略启动</span>:</span></p> 
<p><span style="font-size:18px">1.单击“控制面板”--“系统和安全”--“管理工具”--“本地安全策略”，会进入“本地安全策略”界面。 </span></p> 
<p><span style="font-size:18px">2..win+R--secpol.msc，也可以。<br> </span></p> 
<p><span style="font-size:18px"><br> </span></p> 
<p><span style="font-size:18px"><br> </span></p> 
<p><span style="font-size:18px"><span style="white-space:pre"></span>利用AdjustTokenPrivileges提升权限，准确的说不是提升，而是将访问令牌中禁用的权限启用。<br> </span></p> 
<p><span style="font-size:18px"></span></p> 
<pre><code class="language-cpp">BOOL SetPrivilege(
		HANDLE hToken,          // access token handle
		LPCTSTR lpszPrivilege,  // name of privilege to enable/disable
		BOOL bEnablePrivilege   // to enable or disable privilege
		) 
{
	TOKEN_PRIVILEGES tp;
	LUID luid;

	if ( !LookupPrivilegeValue( 
		NULL,            // lookup privilege on local system
		lpszPrivilege,   // privilege to lookup 
		&amp;luid ) )        // receives LUID of privilege
	{
		printf("LookupPrivilegeValue error: %u\n", GetLastError() ); 
		return FALSE; 
	}

	tp.PrivilegeCount = 1;
	tp.Privileges[0].Luid = luid;
	if (bEnablePrivilege)
		tp.Privileges[0].Attributes = SE_PRIVILEGE_ENABLED;
	else
		tp.Privileges[0].Attributes = 0;

	// Enable the privilege or disable all privileges.

	if ( !AdjustTokenPrivileges(
		hToken, 
		FALSE, 
		&amp;tp, 
		sizeof(TOKEN_PRIVILEGES), 
		(PTOKEN_PRIVILEGES) NULL, 
		(PDWORD) NULL) )
	{ 
		printf("AdjustTokenPrivileges error: %u\n", GetLastError() ); 
		return FALSE; 
	} 

	if (GetLastError() == ERROR_NOT_ALL_ASSIGNED)

	{
		printf("The token does not have the specified privilege. \n");
		return FALSE;
	} 

	return TRUE;
}

void main( )
{

	HANDLE hToken;
	BOOL bRet = OpenProcessToken(GetCurrentProcess(),TOKEN_ALL_ACCESS,&amp;hToken);
	SetPrivilege(hToken,SE_DEBUG_NAME,TRUE);
}</code></pre> 
<br> 这段代码在xp上没有问题，但 
<span style="color:#ff0000">如果在windows 7 或者vista上，如果程序以标准用户启动，AdjustTokenPrivileges将会调用失败，以管理员身份启动没有问题</span>。 
<br> 
<br> 这是因为在Windows 7上，标准用户权限很少，没有Debug权限，更无从谈起启用Debug权限，用户可以以管理员和标准用户两种方式启用控制台，输入命令whoami /ALL 
<span style="font-size:18px">来查看两种权限下权限的不同。</span> 
<p></p> 
<p><span style="font-size:18px">PS：即使提升调试权限，也不意味着对其它进程调用OpenProcess会成功（例如win7系统下的system和audiodg进程)<br> </span></p> 
<p><span style="font-size:18px"><br> </span></p> 
<p><span style="font-size:18px"><span style="white-space:pre"></span><span style="color:#ff0000">下面解释这三个函数</span>：</span></p> 
<p><span style="font-size:18px">首先需要获取进程的令牌句柄<br> <span style="color:#ff0000">OpenProcessToken</span>的原型.<br> </span></p> 
<p><span style="font-size:18px"></span></p> 
<pre><code class="language-cpp">BOOL WINAPI OpenProcessToken( 
  __in          HANDLE ProcessHandle, 
  __in          DWORD DesiredAccess, 
  __out         PHANDLE TokenHandle 
);</code></pre> 
<br> 第一个参数 进程句柄(当前进程为GetCurrentProcess()为参数) 
<br> 第二个参数 访问令牌特权 
<br> 第三个参数 返回的参数 就是AdjustTokenPrivileges的第一个参数 
<br> 例子： 
<br> 
<p></p> 
<p><span style="font-size:18px"></span></p> 
<pre><code class="language-cpp">HANDLE hToken; 
    
bool retn = OpenProcessToken(GetCurrentProcess(),TOKEN_ADJUST_PRIVILEGES,&amp;hToken); 
    
if(!retn) 
    
{ 
    
      return; //获取令牌失败。。 
    
}</code></pre> 
<br> 注:第二个参数 是令牌的权限,这个权限是要有修改权限的特权，意思就是要把你程序的权限修改得更高。 
<br> 关于其他权限可以查MSDN.. 所有权限可以写TOKEN_ALL_ACCESS ，去查看一个令牌特权可以用TOKEN_QUERY 
<br> 这个下面函数有写。 
<br> -------------------------------------------------------------- 
<br> 首先先说一下使用 
<span style="color:#ff0000">AdjustTokenPrivileges</span>需要的。 
<br> 在这个函数中的第3和第5个参数中需要用到一个TOKEN_PRIVILEGES的结构体,在这个结构体中还有个LUID_AND_ATTRIBUTES结构体 
<br> TOKEN_PRIVILEGES结构体 
<br> 
<p></p> 
<p><span style="font-size:18px"></span></p> 
<pre><code class="language-cpp">typedef struct _TOKEN_PRIVILEGES 
    
{ 
       DWORD PrivilegeCount;  
       LUID_AND_ATTRIBUTES Privileges[ANYSIZE_ARRAY]; 
}TOKEN_PRIVILEGES;</code></pre> 
<br> 下面的参数是个特权数组。 
<br> 上面的参数是要修改的特权数目 
<br> LUID_AND_ATTRIBUTES 结构体 
<br> 
<p></p> 
<p><span style="font-size:18px"></span></p> 
<pre><code class="language-cpp">typedef struct _LUID_AND_ATTRIBUTES  
{   
       LUID Luid;   
       DWORD Attributes; 
} LUID_AND_ATTRIBUTES;</code></pre> 
<br> 第一个参数是Luid是一个标志，不同的Luid代表着各种不同的特权类型 
<br> 第二个参数是要这个特权干嘛，如启用这个特权(SE_PRIVILEGE_ENABLED) 
<br> 这里的Luid的值需要用 
<span style="color:#ff0000">LookupPrivilegeValue</span>来获取。 
<br> ------------------------------------------------------------------------------------------ 
<br> 
<span style="color:#ff0000">LookupPrivilegeValue</span>的原型 
<br> 
<p></p> 
<p><span style="font-size:18px"></span></p> 
<pre><code class="language-cpp">BOOL WINAPI LookupPrivilegeValue( 
  __in_opt      LPCTSTR lpSystemName, 
  __in          LPCTSTR lpName, 
  __out         PLUID lpLuid 
);</code></pre> 
<br> 第一个参数是系统的名字，如果为NULL，就是本地名字(这里就填NULL) 
<br> 第二个参数是特权的名字，要查看详细特权，看我的博客里翻译分类里的 包含特权 的文章。(在这里写SE_DEBUG_NAME) 
<br> 第三个参数就可以通过指针返回一个LUID类型的Luid的标识了。 通过这个值就可以填入刚才的结构体里了。 
<br> ---------------------------------------------------------------------------------------------------------------------------- 
<br> 最后就可以介绍 
<span style="color:#ff0000">AdjustTokenPrivilege</span>就应该没什么问题了。 
<br> 它的原型为： 
<br> 
<p></p> 
<p><span style="font-size:18px"></span></p> 
<pre><code class="language-cpp">BOOL WINAPI AdjustTokenPrivileges( 
  __in          HANDLE TokenHandle, 
  __in          BOOL DisableAllPrivileges, 
  __in_opt      PTOKEN_PRIVILEGES NewState, 
  __in          DWORD BufferLength, 
  __out_opt     PTOKEN_PRIVILEGES PreviousState, 
  __out_opt     PDWORD ReturnLength 
);</code></pre>第一个参数为OpenProcessToken第三个指针参数传出的句柄值 
<br> 第二个参数为是否禁用所有所有的特权(这里填false) 
<br> 第三个参数为新的TOKEN_PRIVILEGES的特权结构体指针 
<br> 第四个参数是上面结构体的字节长度(sizeof) 
<br> 第五个参数是 接受原先的特权的结构体 
<br> 第六个参数也是这个结构体的字节长度的指针 
<br> 在这里后两个参数不用管。 
<br> 
<br> MSDN里说 
<br> 如果第五个参数不是NULL，在OpenProcessToken加特权时除了需要指定TOKEN_ADJUST_PRIVILEGES还必须指定TOKEN_QUERY 
<br> 如果第五个参数是NULL，你不接受原先的结构体(第六个当然也是NULL), 就不用再指定附加的TOKEN_QUERY的特权了。 
<br> 还要注意： 
<br> 就算这个函数返回为真，还要调用GetLastError()来检验是否完全成功。如果 
<span style="color:#ff0000"><span style="font-size:18px">GetLastError()==</span>ERROR_SUCCESS</span>就代表修改非常成功 ，这个非常重要！！ 
<br> 还有就是Vista和Window7 里 一定要开管理员模式 才能获取成功 
<br> ---------------------------------------------------- 
<br> 完整的例子 
<br> 可以直接复制运行 
<br> 
<p></p> 
<p><span style="font-size:18px"></span></p> 
<pre><code class="language-cpp">#include &lt;windows.h&gt;    
#include &lt;iostream&gt;    
using namespace std;    
     
     
void main()    
{    
        BOOL retn;    
        HANDLE hToken;    
        retn = OpenProcessToken(GetCurrentProcess(),TOKEN_ADJUST_PRIVILEGES,&amp;hToken);    
        if(retn != TRUE)    
        {    
                    cout&lt;&lt;"获取令牌句柄失败!"&lt;&lt;endl;    
                    return;    
        }    
       
        TOKEN_PRIVILEGES tp; //新特权结构体    
        LUID Luid;    
        retn = LookupPrivilegeValue(NULL,SE_DEBUG_NAME,&amp;Luid);    
     
        if(retn != TRUE)    
        {    
                    cout&lt;&lt;"获取Luid失败"&lt;&lt;endl;    
                    return;    
        }    
                //给TP和TP里的LUID结构体赋值    
        tp.PrivilegeCount = 1;    
        tp.Privileges[0].Attributes = SE_PRIVILEGE_ENABLED;    
        tp.Privileges[0].Luid = Luid;    
          
        AdjustTokenPrivileges(hToken,FALSE,&amp;tp,sizeof(TOKEN_PRIVILEGES),NULL,NULL);    
        if(GetLastError() != ERROR_SUCCESS)    
        {    
                    cout&lt;&lt;"修改特权不完全或失败!"&lt;&lt;endl;    
        }    
       else  
       {    
                    cout&lt;&lt;"修改成功!"&lt;&lt;endl;    
       }    
}</code></pre> 
<br> 
<br> 
<p></p> 
<p><span style="font-size:18px">参考：</span></p> 
<p><span style="font-size:18px">http://blog.csdn.net/xbgprogrammer/article/details/7276760<br> </span></p> 
<p><span style="font-size:18px">http://hi.baidu.com/honfei/item/c8f53302a60104c32f4c6b76<br> </span></p> 
<p><span style="font-size:18px"><br> </span></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/ccaf32c5ea9ca1f8b117c5c8531dd985/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">Css：实现背景色透明/半透明而内容不透明</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/864da8d6c5f2eb541362ed45c9abb928/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">PLSQL中文乱码问题</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>