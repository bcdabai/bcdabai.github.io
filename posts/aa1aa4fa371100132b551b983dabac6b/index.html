<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Redis（6）删除策略（定时删除、惰性删除、定期删除）和数据逐出策略 - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Redis（6）删除策略（定时删除、惰性删除、定期删除）和数据逐出策略" />
<meta property="og:description" content="目录
一、过期数据
二、数据删除策略
1. 定时删除 2. 惰性删除 3. 定期删除 4. 删除策略比对 三、逐出算法
1. 新数据进入检测
2. 影响数据逐出的相关配置
3. 数据逐出策略配置依据
一、过期数据 Redis是一种内存级数据库，所有数据均存放在内存中，内存中的数据可以通过TTL指令获取其状态：
XX ：具有时效性的数据 -1 ：永久有效的数据 -2 ：已经过期的数据 或 被删除的数据 或 未定义的数据 二、数据删除策略 数据删除策略的目标：在内存占用与CPU占用之间寻找一种平衡，顾此失彼都会造成整体redis性能的下降，甚至引发服务器宕机或
内存泄露。
时效性数据的存储结构：
1. 定时删除 创建一个定时器，当key设置有过期时间，且过期时间到达时，由定时器任务立即执行对键的删除操作 优点：节约内存，到时就删除，快速释放掉不必要的内存占用 缺点：CPU压力很大，无论CPU此时负载量多高，均占用CPU，会影响redis服务器响应时间和指令吞吐量 总结：用处理器性能换取存储空间 （拿时间换空间） 2. 惰性删除 数据到达过期时间，不做处理。等下次访问该数据时，如果未过期，返回数据 ；发现已过期，删除，返回不存在。 优点：节约CPU性能，发现必须删除的时候才删除 缺点：内存压力很大，出现长期占用内存的数据 总结：用存储空间换取处理器性能（拿空间换时间） 3. 定期删除 两种方案都走极端，有没有折中方案？ 周期性轮询redis库中的时效性数据，采用随机抽取的策略，利用过期数据占比的方式控制删除频度 特点1：CPU性能占用设置有峰值，检测频度可自定义设置 特点2：内存压力不是很大，长期占用内存的冷数据会被持续清理 总结：周期性抽查存储空间 （随机抽查，重点抽查） 4. 删除策略比对 三、逐出算法 1. 新数据进入检测 当新数据进入redis时，如果内存不足怎么办？ Redis使用内存存储数据，在执行每一个命令前，会调用freeMemoryIfNeeded()检测内存是否充足。如果内存不满足新加入数据的最低存储要求，redis要临时删除一些数据为当前指令清理存储空间。清理数据的策略称为逐出算法。 注意：逐出数据的过程不是100%能够清理出足够的可使用的内存空间，如果不成功则反复执行。当对所有数据尝试完毕后，如果不能达到内存清理的要求，将出现错误信息。 2. 影响数据逐出的相关配置 1）检测易失数据（可能会过期的数据集server.db[i].expires ） ① volatile-lru：挑选最近最少使用的数据淘汰 ② volatile-lfu：挑选最近使用次数最少的数据淘汰 ③ volatile-ttl：挑选将要过期的数据淘汰 ④ volatile-random：任意选择数据淘汰 2）检测全库数据（所有数据集server." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/aa1aa4fa371100132b551b983dabac6b/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2020-07-29T17:29:59+08:00" />
<meta property="article:modified_time" content="2020-07-29T17:29:59+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Redis（6）删除策略（定时删除、惰性删除、定期删除）和数据逐出策略</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p id="main-toc"><strong>目录</strong></p> 
<p id="%E4%B8%80%E3%80%81%E8%BF%87%E6%9C%9F%E6%95%B0%E6%8D%AE-toc" style="margin-left:0px;"><a href="#%E4%B8%80%E3%80%81%E8%BF%87%E6%9C%9F%E6%95%B0%E6%8D%AE" rel="nofollow">一、过期数据</a></p> 
<p id="%E4%BA%8C%E3%80%81%E6%95%B0%E6%8D%AE%E5%88%A0%E9%99%A4%E7%AD%96%E7%95%A5-toc" style="margin-left:0px;"><a href="#%E4%BA%8C%E3%80%81%E6%95%B0%E6%8D%AE%E5%88%A0%E9%99%A4%E7%AD%96%E7%95%A5" rel="nofollow">二、数据删除策略</a></p> 
<p id="1.%20%E5%AE%9A%E6%97%B6%E5%88%A0%E9%99%A4%C2%A0-toc" style="margin-left:40px;"><a href="#1.%20%E5%AE%9A%E6%97%B6%E5%88%A0%E9%99%A4%C2%A0" rel="nofollow">1. 定时删除 </a></p> 
<p id="2.%20%E6%83%B0%E6%80%A7%E5%88%A0%E9%99%A4%C2%A0-toc" style="margin-left:40px;"><a href="#2.%20%E6%83%B0%E6%80%A7%E5%88%A0%E9%99%A4%C2%A0" rel="nofollow">2. 惰性删除 </a></p> 
<p id="3.%20%E5%AE%9A%E6%9C%9F%E5%88%A0%E9%99%A4%C2%A0-toc" style="margin-left:40px;"><a href="#3.%20%E5%AE%9A%E6%9C%9F%E5%88%A0%E9%99%A4%C2%A0" rel="nofollow">3. 定期删除 </a></p> 
<p id="4%E3%80%81%E5%88%A0%E9%99%A4%E7%AD%96%E7%95%A5%E6%AF%94%E5%AF%B9%C2%A0-toc" style="margin-left:40px;"><a href="#4%E3%80%81%E5%88%A0%E9%99%A4%E7%AD%96%E7%95%A5%E6%AF%94%E5%AF%B9%C2%A0" rel="nofollow">4. 删除策略比对 </a></p> 
<p id="%E4%B8%89%E3%80%81%E9%80%90%E5%87%BA%E7%AE%97%E6%B3%95-toc" style="margin-left:0px;"><a href="#%E4%B8%89%E3%80%81%E9%80%90%E5%87%BA%E7%AE%97%E6%B3%95" rel="nofollow">三、逐出算法</a></p> 
<p id="1%E3%80%81%E6%96%B0%E6%95%B0%E6%8D%AE%E8%BF%9B%E5%85%A5%E6%A3%80%E6%B5%8B-toc" style="margin-left:40px;"><a href="#1%E3%80%81%E6%96%B0%E6%95%B0%E6%8D%AE%E8%BF%9B%E5%85%A5%E6%A3%80%E6%B5%8B" rel="nofollow">1. 新数据进入检测</a></p> 
<p id="2%E3%80%81%E5%BD%B1%E5%93%8D%E6%95%B0%E6%8D%AE%E9%80%90%E5%87%BA%E7%9A%84%E7%9B%B8%E5%85%B3%E9%85%8D%E7%BD%AE-toc" style="margin-left:40px;"><a href="#2%E3%80%81%E5%BD%B1%E5%93%8D%E6%95%B0%E6%8D%AE%E9%80%90%E5%87%BA%E7%9A%84%E7%9B%B8%E5%85%B3%E9%85%8D%E7%BD%AE" rel="nofollow">2. 影响数据逐出的相关配置</a></p> 
<p id="3%E3%80%81%E6%95%B0%E6%8D%AE%E9%80%90%E5%87%BA%E7%AD%96%E7%95%A5%E9%85%8D%E7%BD%AE%E4%BE%9D%E6%8D%AE-toc" style="margin-left:40px;"><a href="#3%E3%80%81%E6%95%B0%E6%8D%AE%E9%80%90%E5%87%BA%E7%AD%96%E7%95%A5%E9%85%8D%E7%BD%AE%E4%BE%9D%E6%8D%AE" rel="nofollow">3. 数据逐出策略配置依据</a></p> 
<hr id="hr-toc"> 
<h2 id="%E4%B8%80%E3%80%81%E8%BF%87%E6%9C%9F%E6%95%B0%E6%8D%AE">一、过期数据</h2> 
<p>Redis是一种内存级数据库，所有数据均存放在内存中，内存中的数据可以通过TTL指令获取其状态：</p> 
<ul><li>XX ：具有时效性的数据 </li><li>-1 ：永久有效的数据 </li><li>-2 ：已经过期的数据 或 被删除的数据 或 未定义的数据 </li></ul> 
<h2 id="%E4%BA%8C%E3%80%81%E6%95%B0%E6%8D%AE%E5%88%A0%E9%99%A4%E7%AD%96%E7%95%A5">二、数据删除策略</h2> 
<p><strong>数据删除策略的目标：</strong>在内存占用与CPU占用之间寻找一种平衡，顾此失彼都会造成整体redis性能的下降，甚至引发服务器宕机或<br> 内存泄露。</p> 
<p>时效性数据的存储结构：</p> 
<p><img alt="" height="669" src="https://images2.imgbox.com/0e/8a/PhnfQRv5_o.png" width="1200"></p> 
<h3 id="1.%20%E5%AE%9A%E6%97%B6%E5%88%A0%E9%99%A4%C2%A0">1. 定时删除 </h3> 
<ul><li>创建一个定时器，当key设置有过期时间，且过期时间到达时，由定时器任务立即执行对键的删除操作 </li><li>优点：节约内存，到时就删除，快速释放掉不必要的内存占用 </li><li>缺点：CPU压力很大，无论CPU此时负载量多高，均占用CPU，会影响redis服务器响应时间和指令吞吐量 </li><li><span style="color:#f33b45;">总结：用处理器性能换取存储空间 （拿时间换空间） </span></li></ul> 
<p><img alt="" height="430" src="https://images2.imgbox.com/7f/3f/XRBjQqwd_o.png" width="848"></p> 
<h3 id="2.%20%E6%83%B0%E6%80%A7%E5%88%A0%E9%99%A4%C2%A0">2. 惰性删除 </h3> 
<p> </p> 
<ul><li>数据到达过期时间，不做处理。等下次访问该数据时，如果未过期，返回数据 ；发现已过期，删除，返回不存在。 </li><li>优点：节约CPU性能，发现必须删除的时候才删除 </li><li>缺点：内存压力很大，出现长期占用内存的数据 </li><li><span style="color:#f33b45;">总结：用存储空间换取处理器性能（拿空间换时间）</span></li></ul> 
<p><img alt="" height="485" src="https://images2.imgbox.com/fd/20/yo2fXbBx_o.png" width="947"></p> 
<h3 id="3.%20%E5%AE%9A%E6%9C%9F%E5%88%A0%E9%99%A4%C2%A0">3. 定期删除 </h3> 
<p>两种方案都走极端，有没有折中方案？ </p> 
<ul><li>周期性轮询redis库中的时效性数据，采用随机抽取的策略，利用过期数据占比的方式控制删除频度 </li><li>特点1：CPU性能占用设置有峰值，检测频度可自定义设置 </li><li>特点2：内存压力不是很大，长期占用内存的冷数据会被持续清理 </li><li><span style="color:#f33b45;">总结：周期性抽查存储空间 （随机抽查，重点抽查） </span></li></ul> 
<p><img alt="" height="576" src="https://images2.imgbox.com/27/25/M4ZS2PA7_o.png" width="1060"></p> 
<p style="text-align:center;"><img alt="" height="691" src="https://images2.imgbox.com/8f/d9/nqD3hHBk_o.png" width="584"></p> 
<h3 id="4%E3%80%81%E5%88%A0%E9%99%A4%E7%AD%96%E7%95%A5%E6%AF%94%E5%AF%B9%C2%A0">4. 删除策略比对 </h3> 
<p><img alt="" height="188" src="https://images2.imgbox.com/3e/35/yZ0BGDme_o.png" width="1200"></p> 
<h2 id="%E4%B8%89%E3%80%81%E9%80%90%E5%87%BA%E7%AE%97%E6%B3%95">三、逐出算法</h2> 
<h3 id="1%E3%80%81%E6%96%B0%E6%95%B0%E6%8D%AE%E8%BF%9B%E5%85%A5%E6%A3%80%E6%B5%8B">1. 新数据进入检测</h3> 
<p>当新数据进入redis时，如果内存不足怎么办？ </p> 
<ul><li>Redis使用内存存储数据，在执行每一个命令前，会调用freeMemoryIfNeeded()检测内存是否充足。如果内存不满足新加入数据的最低存储要求，redis要临时删除一些数据为当前指令清理存储空间。清理数据的策略称为逐出算法。 </li><li>注意：逐出数据的过程不是100%能够清理出足够的可使用的内存空间，如果不成功则反复执行。当对所有数据尝试完毕后，如果不能达到内存清理的要求，将出现错误信息。 </li></ul> 
<p><img alt="" height="96" src="https://images2.imgbox.com/5a/4f/pTqWGQTg_o.png" width="1176"></p> 
<h3 id="2%E3%80%81%E5%BD%B1%E5%93%8D%E6%95%B0%E6%8D%AE%E9%80%90%E5%87%BA%E7%9A%84%E7%9B%B8%E5%85%B3%E9%85%8D%E7%BD%AE">2. 影响数据逐出的相关配置</h3> 
<p><img alt="" height="506" src="https://images2.imgbox.com/c0/f7/PQfharPI_o.png" width="1160"></p> 
<p>1）检测易失数据（可能会过期的数据集server.db[i].expires ） <br> ① volatile-lru：挑选最近最少使用的数据淘汰 <br> ② volatile-lfu：挑选最近使用次数最少的数据淘汰 <br> ③ volatile-ttl：挑选将要过期的数据淘汰 <br> ④ volatile-random：任意选择数据淘汰 </p> 
<p><br> 2）检测全库数据（所有数据集server.db[i].dict ） <br> ⑤ allkeys-lru：挑选最近最少使用的数据淘汰 <br> ⑥ allkeys-lfu：挑选最近使用次数最少的数据淘汰 <br> ⑦ allkeys-random：任意选择数据淘汰 </p> 
<p><br> 3）放弃数据驱逐 <br> ⑧ no-enviction（驱逐）：禁止驱逐数据（redis4.0中默认策略），会引发错误OOM（Out Of Memory） </p> 
<h3 id="3%E3%80%81%E6%95%B0%E6%8D%AE%E9%80%90%E5%87%BA%E7%AD%96%E7%95%A5%E9%85%8D%E7%BD%AE%E4%BE%9D%E6%8D%AE">3. 数据逐出策略配置依据</h3> 
<p>使用INFO命令输出监控信息，查询缓存 hit 和 miss 的次数，根据业务需求调优Redis配置 。</p> 
<p> </p> 
<p> </p> 
<p> </p> 
<p> </p> 
<p> </p> 
<p> </p> 
<p> </p> 
<p> </p> 
<p> </p> 
<p> </p> 
<p> </p> 
<p> </p> 
<p> </p> 
<p> </p> 
<p> </p> 
<p> </p> 
<p> </p> 
<p> </p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/d021245d3120bb2d005d4d6b1fe8957f/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">Error: ER_NOT_SUPPORTED_AUTH_MODE: Client does not support authentication protocol</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/d4c6703dad0f9249eb9ee73edf7e73c9/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">Laravel 多应用 多模块开发</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>