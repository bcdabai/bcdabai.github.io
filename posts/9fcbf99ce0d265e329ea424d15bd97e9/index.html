<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Stm32定时器 - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Stm32定时器" />
<meta property="og:description" content="TIM简介 TIM（Timer）定时器
定时器可以对输入的时钟进行计数，并在计数值达到设定值时触发中断
16位计数器（每来一个时钟，计数器加1）、预分频器（对计数器的时钟进行分频）、自动重装寄存器的时基单元（设定多少个时钟申请中断），在72MHz计数时钟下可以实现最大59.65s（1/（72/65536/65536））的定时，还可用级联（多个定时器串联）增加定时时长。
不仅具备基本的定时中断功能，而且还包含内外时钟源选择、输入捕获、输出比较、编码器接口、主从触发模式等多种功能
根据复杂度和应用场景分为了高级定时器、通用定时器、基本定时器三种类型
STM32F103C8T6定时器资源：TIM1、TIM2、TIM3、TIM4
预分频寄存器：对时钟进行预分频，写0时不分频，就是1分频（输出频率=输入频率），写1时就是2分频（输出=输入/2），依次类推。
计数器寄存器：计数时钟每来一个上升沿，计数&#43;1的向上计数模式，到达65535，产生中断后重回0。
自动重装寄存器：存的是写入的计数目标，当计数值等于设定值时就产生中断信号，清零计数器寄存器 。UI通向NVIC，U会触发其他电路的工作。
通用定时器这里包含了基本定时器的功能，但基本定时器只有向上计数的模式，而通用和高级定时器还支持向下（从重装值开始向下自减，减到0回到重装值同时申请中断）和中央对齐的模式（从0开始，先向上自增，计到重装值，申请中断，然后向下自减，减到0再申请中断）。
在基本时钟上方的部分为内外时钟源和主从触发模式结构：ETR为外部时钟，对应PAO口。TRGI主要用作触发输入来使用，也可以当做外部时钟使用，这一路叫做外部时钟模式1。TRGO可以接回到ITR部分的可以实现定时器的级联，连接方式见手册14.4.3,
在基本定时器右下部分是输出比较电路1-4，可用于输出PWM波形，驱动电机。左边的是输入捕获电路，用于测输入方波的频率、中间的是捕获/比较寄存器。
运行控制是控制启动停止、向上或向下计数等功能，中断输出控制只允许一个中断。使用定时器中断时就需要配置这些定时器。
CK_PSC:预分频的输入时钟，选内部时钟一般是72（由时钟决定）。
CK_EN:计数器使能，决定工作
CK_CNT:前半段为预分频的时钟，系数变2，时钟也变一半。
计数寄存器：自增到FC从0开始，重装值就是FC同时UEV产生更新事件或者中断。
上述以下的的就是为了改写分频值后不会立刻发生改变，而是计完这个周期才开始变。0的时候就输出CNT后半部分的时钟。（通用定时器电路图中有阴影的就是带有这种功能）
计数器计数频率：CK_CNT = CK_PSC / (PSC &#43; 1)
计数器溢出频率：CK_CNT_OV = CK_CNT / (ARR &#43; 1)
= CK_PSC / (PSC &#43; 1) / (ARR &#43; 1)
以下是使用定时器进行1s的时间更新一次中断并显示在OLED屏上
//定时器代码C #include &#34;stm32f10x.h&#34; // Device header extern uint16_t Num; void Timer_Init(void) { RCC_APB1PeriphClockCmd(RCC_APB1Periph_TIM2,ENABLE);//选择TIM2定时器 TIM_InternalClockConfig(TIM2);//由内部时钟驱动 TIM_TimeBaseInitTypeDef TIM_TimeBaseInitStructure; TIM_TimeBaseInitStructure.TIM_ClockDivision=TIM_CKD_DIV1; //预分频系数1 TIM_TimeBaseInitStructure.TIM_CounterMode=TIM_CounterMode_Up;//向上计数模式 TIM_TimeBaseInitStructure.TIM_Prescaler=7200-1;//在72M进行7200分频	=10K的计数频率,产生一次更新事件 TIM_TimeBaseInitStructure.TIM_Period=10000-1;//10K的频率下，计算10000个数得到定时1S的时间，-1因为公式里面PSC&#43;1了，而这里配置的就是PSC TIM_TimeBaseInitStructure.TIM_RepetitionCounter=0;//高级定时器的中的重复计数器的 TIM_TimeBaseInit(TIM2,&amp;TIM_TimeBaseInitStructure);//时机单元初始化函数 TIM_ITConfig(TIM2,TIM_IT_Update,ENABLE);//使能中断 TIM_Cmd(TIM2,ENABLE); NVIC_PriorityGroupConfig(NVIC_PriorityGroup_2); NVIC_InitTypeDef NVIC_InitStructure; NVIC_InitStructure." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/9fcbf99ce0d265e329ea424d15bd97e9/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-07-16T22:00:28+08:00" />
<meta property="article:modified_time" content="2023-07-16T22:00:28+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Stm32定时器</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <h3 style="margin-left:0;text-align:justify;">TIM简介</h3> 
<p>TIM（Timer）定时器</p> 
<p style="margin-left:0;text-align:justify;"></p> 
<p>定时器可以对输入的时钟进行计数，并在计数值达到设定值时触发中断</p> 
<p style="margin-left:0;text-align:justify;"></p> 
<p>16位计数器（每来一个时钟，计数器加1）、预分频器（对计数器的时钟进行分频）、自动重装寄存器的时基单元（设定多少个时钟申请中断），在72MHz计数时钟下可以实现最大59.65s（1/（72/65536/65536））的定时，还可用级联（多个定时器串联）增加定时时长。</p> 
<p style="margin-left:0;text-align:justify;"></p> 
<p>不仅具备基本的定时中断功能，而且还包含内外时钟源选择、输入捕获、输出比较、编码器接口、主从触发模式等多种功能</p> 
<p style="margin-left:0;text-align:justify;"></p> 
<p>根据复杂度和应用场景分为了高级定时器、通用定时器、基本定时器三种类型</p> 
<p style="margin-left:0;text-align:justify;">STM32F103C8T6定时器资源：TIM1、TIM2、TIM3、TIM4</p> 
<p style="margin-left:0;text-align:justify;"></p> 
<p class="img-center"><img alt="" height="166" src="https://images2.imgbox.com/d3/7b/9mpiHz3B_o.png" width="554"></p> 
<p></p> 
<p class="img-center"><img alt="" height="263" src="https://images2.imgbox.com/4d/43/BbnefsWK_o.png" width="554"></p> 
<p></p> 
<p style="margin-left:0;text-align:justify;">预分频寄存器：对时钟进行预分频，写0时不分频，就是1分频（输出频率=输入频率），写1时就是2分频（输出=输入/2），依次类推。</p> 
<p style="margin-left:0;text-align:justify;">计数器寄存器：计数时钟每来一个上升沿，计数+1的向上计数模式，到达65535，产生中断后重回0。</p> 
<p style="margin-left:0;text-align:justify;">自动重装寄存器：存的是写入的计数目标，当计数值等于设定值时就产生中断信号，清零计数器寄存器 。UI通向NVIC，U会触发其他电路的工作。</p> 
<p style="margin-left:0;text-align:justify;">通用定时器这里包含了基本定时器的功能，但基本定时器只有向上计数的模式，而通用和高级定时器还支持向下（从重装值开始向下自减，减到0回到重装值同时申请中断）和中央对齐的模式（从0开始，先向上自增，计到重装值，申请中断，然后向下自减，减到0再申请中断）。</p> 
<p style="margin-left:0;text-align:justify;">在基本时钟上方的部分为内外时钟源和主从触发模式结构：ETR为外部时钟，对应PAO口。TRGI主要用作触发输入来使用，也可以当做外部时钟使用，这一路叫做外部时钟模式1。TRGO可以接回到ITR部分的可以实现定时器的级联，连接方式见手册14.4.3,</p> 
<p style="margin-left:0;text-align:justify;">在基本定时器右下部分是输出比较电路1-4，可用于输出PWM波形，驱动电机。左边的是输入捕获电路，用于测输入方波的频率、中间的是捕获/比较寄存器。</p> 
<p style="margin-left:0;text-align:justify;"></p> 
<p class="img-center"><img alt="" height="280" src="https://images2.imgbox.com/10/92/TiWnqUYz_o.png" width="647"></p> 
<p> 运行控制是控制启动停止、向上或向下计数等功能，中断输出控制只允许一个中断。使用定时器中断时就需要配置这些定时器。</p> 
<p class="img-center"><img alt="" height="299" src="https://images2.imgbox.com/15/0f/2kD4VtWn_o.png" width="554"></p> 
<p></p> 
<p style="margin-left:0;text-align:justify;">CK_PSC:预分频的输入时钟，选内部时钟一般是72（由时钟决定）。</p> 
<p style="margin-left:0;text-align:justify;">CK_EN:计数器使能，决定工作</p> 
<p style="margin-left:0;text-align:justify;">CK_CNT:前半段为预分频的时钟，系数变2，时钟也变一半。</p> 
<p style="margin-left:0;text-align:justify;">计数寄存器：自增到FC从0开始，重装值就是FC同时UEV产生更新事件或者中断。</p> 
<p style="margin-left:0;text-align:justify;">上述以下的的就是为了改写分频值后不会立刻发生改变，而是计完这个周期才开始变。0的时候就输出CNT后半部分的时钟。（通用定时器电路图中有阴影的就是带有这种功能）</p> 
<p style="margin-left:0;text-align:justify;">计数器计数频率：CK_CNT = CK_PSC / (PSC + 1)</p> 
<p style="margin-left:0;text-align:justify;">计数器溢出频率：CK_CNT_OV = CK_CNT / (ARR + 1)</p> 
<p style="margin-left:0;text-align:justify;">       = CK_PSC / (PSC + 1) / (ARR + 1)</p> 
<p style="margin-left:0;text-align:justify;"></p> 
<p style="margin-left:0;text-align:justify;">以下是使用定时器进行1s的时间更新一次中断并显示在OLED屏上</p> 
<pre><code>//定时器代码C
#include "stm32f10x.h"                  // Device header

extern uint16_t Num;

void Timer_Init(void)
{
	RCC_APB1PeriphClockCmd(RCC_APB1Periph_TIM2,ENABLE);//选择TIM2定时器
	TIM_InternalClockConfig(TIM2);//由内部时钟驱动
	TIM_TimeBaseInitTypeDef TIM_TimeBaseInitStructure;
	TIM_TimeBaseInitStructure.TIM_ClockDivision=TIM_CKD_DIV1;     //预分频系数1
	TIM_TimeBaseInitStructure.TIM_CounterMode=TIM_CounterMode_Up;//向上计数模式
	
	TIM_TimeBaseInitStructure.TIM_Prescaler=7200-1;//在72M进行7200分频	=10K的计数频率,产生一次更新事件 
TIM_TimeBaseInitStructure.TIM_Period=10000-1;//10K的频率下，计算10000个数得到定时1S的时间，-1因为公式里面PSC+1了，而这里配置的就是PSC
	TIM_TimeBaseInitStructure.TIM_RepetitionCounter=0;//高级定时器的中的重复计数器的
	
	TIM_TimeBaseInit(TIM2,&amp;TIM_TimeBaseInitStructure);//时机单元初始化函数
	
	TIM_ITConfig(TIM2,TIM_IT_Update,ENABLE);//使能中断
	
	TIM_Cmd(TIM2,ENABLE);
	
	NVIC_PriorityGroupConfig(NVIC_PriorityGroup_2);
	NVIC_InitTypeDef NVIC_InitStructure;
	NVIC_InitStructure.NVIC_IRQChannel=TIM2_IRQn;
	NVIC_InitStructure.NVIC_IRQChannelCmd=ENABLE;
	NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority=2;
	NVIC_InitStructure.NVIC_IRQChannelSubPriority=1;
	NVIC_Init(&amp;NVIC_InitStructure);
	
	
	}

void TIM2_IRQHandler(void)
{
	if(TIM_GetITStatus(TIM2,TIM_IT_Update)==SET)//检查标志位
	{
		Num++;
	}
	TIM_ClearITPendingBit(TIM2,TIM_IT_Update);
}
		
		
	

</code></pre> 
<p></p> 
<pre><code>//main函数
#include "stm32f10x.h"                  // Device header
#include "Delay.h" 
#include "OLED.h"
#include"Timer.h"
uint16_t Num=-1;
int main(void)
{
	OLED_Init();
    Timer_Init();
	OLED_ShowString(1,1,"Num;");


	while(1)
	{
		OLED_ShowNum(1,5,Num,5);
	}
}
</code></pre> 
<p></p> 
<pre><code>//头文件
#ifndef __TIMER_H
#define __TIMER_H
void Timer_Init(void);
#endif
</code></pre> 
<p></p> 
<p>本文是跟着江科大学习，这是本人的学习笔记，如有侵权请联系本人删除！</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/9869a9dee53f7600df90d65afaaad3da/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">第十二周：机器学习周报</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/03cf4381ad51e178bae920fc2a645cd6/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">牛客小白月赛75 方豆子（递归模拟）</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>