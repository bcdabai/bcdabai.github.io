<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>RPC和Http的区别 - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="RPC和Http的区别" />
<meta property="og:description" content="什么是 RPC ? RPC (Remote Procedure Call)即远程过程调用，是分布式系统常见的一种通信方法，已经有 40 多年历史。当两个物理分离的子系统需要建立逻辑上的关联时，RPC 是牵线搭桥的常见技术手段之一。除 RPC 之外，常见的多系统数据交互方案还有分布式消息队列、HTTP 请求调用、数据库和分布式缓存等。
RPC 在我们熟知的各种中间件中都有它的身影。Nginx/Redis/MySQL/Dubbo/Hadoop/Spark/Tensorflow 等重量级开源产品都是在 RPC 技术的基础上构建出来的，我们这里说的 RPC 指的是广义的 RPC，也就是分布式系统的通信技术。RPC 在技术中的地位好比我们身边的空气，它无处不在，但是又有很多人根本不知道它的存在。
RPC服务的基本架构：
一个完整的RPC架构里面包含了四个核心的组件，分别是Client ,Server,Client Stub以及Server Stub，这个Stub可以理解为存根。
客户端（Client），服务的调用方。服务端（Server），真正的服务提供者。客户端存根(Client Stub)，存放服务端的地址消息，再将客户端的请求参数打包成网络消息，然后通过网络远程发送给服务方。服务端存根(Server Stub)，接收客户端发送过来的消息，将消息解包，并调用本地的方法。 RPC主要是用在大型企业里面，系统繁多，业务线复杂，而且效率优势非常重要的一块，这个时候RPC的优势就比较明显了。
实际的开发当中是这么做的，项目一般使用maven来管理。比如我们有一个处理订单的系统服务，先声明它的所有的接口（这里就是具体指Java中的interface），然后将整个项目打包为一个jar包，服务端这边引入这个二方库，然后实现相应的功能，客户端这边也只需要引入这个二方库即可调用了。为什么这么做？主要是为了减少客户端这边的jar包大小，因为每一次打包发布的时候，jar包太多总是会影响效率。另外也是将客户端和服务端解耦，提高代码的可移植性。
同步调用与异步调用 什么是同步调用？什么是异步调用？同步调用就是客户端等待调用执行完成并返回结果。异步调用就是客户端不等待调用执行完成返回结果，不过依然可以通过回调函数等接收到返回结果的通知。如果客户端并不关心结果，则可以变成一个单向的调用。这个过程有点类似于Java中的callable和runnable接口，我们进行异步执行的时候，如果需要知道执行的结果，就可以使用callable接口，并且可以通过Future类获取到异步执行的结果信息。如果不关心执行的结果，直接使用runnable接口就可以了，因为它不返回结果，当然啦，callable也是可以的，我们不去获取Future就可以了。
流行的RPC框架 目前流行的开源RPC框架还是比较多的。下面重点介绍三种：
gRPC是Google最近公布的开源软件，基于最新的HTTP2.0协议，并支持常见的众多编程语言。 我们知道HTTP2.0是基于二进制的HTTP协议升级版本，目前各大浏览器都在快马加鞭的加以支持。 这个RPC框架是基于HTTP协议实现的，底层使用到了Netty框架的支持。Thrift是Facebook的一个开源项目，主要是一个跨语言的服务开发框架。它有一个代码生成器来对它所定义的IDL定义文件自动生成服务代码框架。用户只要在其之前进行二次开发就行，对于底层的RPC通讯等都是透明的。不过这个对于用户来说的话需要学习特定领域语言这个特性，还是有一定成本的。Dubbo是阿里集团开源的一个极为出名的RPC框架，在很多互联网公司和企业应用中广泛使用。协议和序列化框架都可以插拔是及其鲜明的特色。同样 的远程接口是基于Java Interface，并且依托于spring框架方便开发。可以方便的打包成单一文件，独立进程运行，和现在的微服务概念一致。（阿里集团内部已经不怎么使用dubbo，现在用的比较多的叫HSF。暂未开源。） HTTP服务 其实在很久以前，很多企业开发的模式一直定性为HTTP接口开发，也就是我们常说的RESTful风格的服务接口。
的确，对于在接口不多、系统与系统交互较少的情况下，解决信息孤岛初期常使用的一种通信手段；优点就是简单、直接、开发方便。利用现成的http协议进行传输。
接口可能返回一个JSON字符串或者是XML文档。然后客户端再去处理这个返回的信息，从而可以比较快速地进行开发。但是对于大型企业来说，内部子系统较多、接口非常多的情况下，RPC框架的好处就显示出来了。
首先是长链接，不必每次通信都要像http一样去3次握手，减少了网络开销；
其次，RPC框架一般都有注册中心，有丰富的监控管理；发布、下线接口、动态扩展等，对调用方来说是无感知、统一化的操作。
RPC服务和HTTP服务还是存在很多的不同点的，一般来说，RPC服务主要是针对大型企业的，而HTTP服务主要是针对小企业的，因为RPC效率更高，而HTTP服务开发迭代会更快。总之，选用什么样的框架不是按照市场上流行什么而决定的，而是要对整个项目进行完整地评估，从而在仔细比较两种开发框架对于整个项目的影响，最后再决定什么才是最适合这个项目的。一定不要为了使用RPC而每个项目都用RPC，而是要因地制宜，具体情况具体分析。
--------------------- 作者：Y仟仟 原文：https://blog.csdn.net/weixin_38410177/article/details/89394180 为什么有了Http请求，还要使用RPC调用 这个解释挺复杂的，但是我们可以简单的理解一下，毕竟，现在已经不是以前那个年代了。
还是先来看一下，没有PRC的时候，会怎么样。
在过去是这样的，包括现在很多对企业服务可能也是这样的，只有一个包部署在Tomcat里
那个时候，没什么需要用到RPC的场景。
然后当用户量大的时候呢？渐渐出现了负载均衡。
大概是这个样子。
负载均衡能解决的问题很多，但是还是不够好，比如说，只是某一个功能模块（假设是用户中心）被访问的次数特别频繁，我可不可以把这部分内容单独拿出去？用户中心的机器独立，给它单独的带宽，给他单独的服务器，给他单独的数据库？
不这么干其他的功能模块都干不下去了啊。
好比是原来是学校餐厅，可以同时供200个人用餐，但是修真院的饺子馆生意特别好，每次来吃饭的人都有5000人，占满了所有餐椅，排队几万米，餐厅的其他摊位肯定不乐意了吧？
比如说那个卖炒菜的，虽然我每天只有30来个人吃饭，那也是钱啊，你人这么多，想来我这边吃饭的人都找不着了。
大概的情景应该是这样的。
能理解么？
遇到这种场景怎么办？不可能不让修真院饺子馆开门啊，那最好的方式就是：
你可不可以搬出去？你不搬我们搬也行！（哭泣脸，反正我们是再也不要和你家饺子馆开在一起了，必须给我们一个说法）
那么，搬家之后的样子可能是这样的。
嗯啊。分是分开了，然后餐卡什么的还是在一起，还是和其他摊位一样，给大家提供就餐的功能。这就是分而治之，哪怕你修真院饺子馆关门了，也不影响我，这又叫分布式。
说到分布式，就问题就来了。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/e9b313f97914d6e824c5f3dfc4d79e7f/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2019-07-18T19:20:29+08:00" />
<meta property="article:modified_time" content="2019-07-18T19:20:29+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">RPC和Http的区别</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <h4><strong>什么是 RPC ?</strong></h4> 
<p>RPC (Remote Procedure Call)即远程过程调用，是分布式系统常见的一种通信方法，已经有 40 多年历史。当两个物理分离的子系统需要建立逻辑上的关联时，RPC 是牵线搭桥的常见技术手段之一。除 RPC 之外，常见的多系统数据交互方案还有分布式消息队列、HTTP 请求调用、数据库和分布式缓存等。</p> 
<p style="text-align:center;"><img alt="æéä¿çè¯­è¨è®²æ¸æ¥RPCåHTTP" class="has" src="https://images2.imgbox.com/6b/88/reIFbH7k_o.jpg"></p> 
<p>RPC 在我们熟知的各种中间件中都有它的身影。Nginx/Redis/MySQL/Dubbo/Hadoop/Spark/Tensorflow 等重量级开源产品都是在 RPC 技术的基础上构建出来的，我们这里说的 RPC 指的是广义的 RPC，也就是分布式系统的通信技术。RPC 在技术中的地位好比我们身边的空气，它无处不在，但是又有很多人根本不知道它的存在。</p> 
<p>RPC服务的基本架构：</p> 
<p>一个完整的RPC架构里面包含了四个核心的组件，分别是Client ,Server,Client Stub以及Server Stub，这个Stub可以理解为存根。</p> 
<ul><li>客户端（Client），服务的调用方。</li><li>服务端（Server），真正的服务提供者。</li><li>客户端存根(Client Stub)，存放服务端的地址消息，再将客户端的请求参数打包成网络消息，然后通过网络远程发送给服务方。</li><li>服务端存根(Server Stub)，接收客户端发送过来的消息，将消息解包，并调用本地的方法。</li></ul> 
<p><a href="https://obrxbqjbi.qnssl.com/blog/image/rpc-architecture.jpg" rel="nofollow"><img alt="" class="has" src="https://images2.imgbox.com/1a/04/anVsUIPh_o.png"></a></p> 
<p>RPC主要是用在大型企业里面，系统繁多，业务线复杂，而且效率优势非常重要的一块，这个时候RPC的优势就比较明显了。</p> 
<p>实际的开发当中是这么做的，项目一般使用maven来管理。比如我们有一个处理订单的系统服务，先声明它的所有的接口（这里就是具体指Java中的<code>interface</code>），然后将整个项目打包为一个<code>jar</code>包，服务端这边引入这个二方库，然后实现相应的功能，客户端这边也只需要引入这个二方库即可调用了。为什么这么做？主要是为了减少客户端这边的<code>jar</code>包大小，因为每一次打包发布的时候，<code>jar</code>包太多总是会影响效率。另外也是将客户端和服务端解耦，提高代码的可移植性。</p> 
<p> </p> 
<h4 id="同步调用与异步调用"><a name="t3"></a>同步调用与异步调用</h4> 
<p>什么是同步调用？什么是异步调用？<code>同步调用</code>就是客户端等待调用执行完成并返回结果。<code>异步调用</code>就是客户端不等待调用执行完成返回结果，不过依然可以通过回调函数等接收到返回结果的通知。如果客户端并不关心结果，则可以变成一个单向的调用。这个过程有点类似于Java中的<code>callable</code>和<code>runnable</code>接口，我们进行异步执行的时候，如果需要知道执行的结果，就可以使用<code>callable</code>接口，并且可以通过<code>Future</code>类获取到异步执行的结果信息。如果不关心执行的结果，直接使用<code>runnable</code>接口就可以了，因为它不返回结果，当然啦，<code>callable</code>也是可以的，我们不去获取<code>Future</code>就可以了。</p> 
<p> </p> 
<h4 id="流行的RPC框架">流行的RPC框架</h4> 
<p>目前流行的开源RPC框架还是比较多的。下面重点介绍三种：</p> 
<ol><li>gRPC是Google最近公布的开源软件，基于最新的HTTP2.0协议，并支持常见的众多编程语言。 我们知道HTTP2.0是基于二进制的HTTP协议升级版本，目前各大浏览器都在快马加鞭的加以支持。 这个RPC框架是基于HTTP协议实现的，底层使用到了Netty框架的支持。</li><li>Thrift是Facebook的一个开源项目，主要是一个跨语言的服务开发框架。它有一个代码生成器来对它所定义的IDL定义文件自动生成服务代码框架。用户只要在其之前进行二次开发就行，对于底层的RPC通讯等都是透明的。不过这个对于用户来说的话需要学习特定领域语言这个特性，还是有一定成本的。</li><li>Dubbo是阿里集团开源的一个极为出名的RPC框架，在很多互联网公司和企业应用中广泛使用。协议和序列化框架都可以插拔是及其鲜明的特色。同样 的远程接口是基于Java Interface，并且依托于spring框架方便开发。可以方便的打包成单一文件，独立进程运行，和现在的微服务概念一致。（阿里集团内部已经不怎么使用dubbo，现在用的比较多的叫HSF。暂未开源。）</li></ol> 
<p> </p> 
<p> </p> 
<h4>HTTP服务</h4> 
<p><br> 其实在很久以前，很多企业开发的模式一直定性为HTTP接口开发，也就是我们常说的RESTful风格的服务接口。</p> 
<p>的确，对于在接口不多、系统与系统交互较少的情况下，解决信息孤岛初期常使用的一种通信手段；优点就是简单、直接、开发方便。利用现成的http协议进行传输。<br> 接口可能返回一个JSON字符串或者是XML文档。然后客户端再去处理这个返回的信息，从而可以比较快速地进行开发。但是对于大型企业来说，内部子系统较多、接口非常多的情况下，RPC框架的好处就显示出来了。</p> 
<p>首先是长链接，不必每次通信都要像http一样去3次握手，减少了网络开销；</p> 
<p>其次，RPC框架一般都有注册中心，有丰富的监控管理；发布、下线接口、动态扩展等，对调用方来说是无感知、统一化的操作。</p> 
<p>RPC服务和HTTP服务还是存在很多的不同点的，一般来说，RPC服务主要是针对大型企业的，而HTTP服务主要是针对小企业的，因为RPC效率更高，而HTTP服务开发迭代会更快。总之，选用什么样的框架不是按照市场上流行什么而决定的，而是要对整个项目进行完整地评估，从而在仔细比较两种开发框架对于整个项目的影响，最后再决定什么才是最适合这个项目的。一定不要为了使用RPC而每个项目都用RPC，而是要因地制宜，具体情况具体分析。<br> --------------------- <br> 作者：Y仟仟 <br> 原文：https://blog.csdn.net/weixin_38410177/article/details/89394180 <br>  </p> 
<h4>为什么有了Http请求，还要使用RPC调用</h4> 
<p>这个解释挺复杂的，但是我们可以简单的理解一下，毕竟，现在已经不是以前那个年代了。</p> 
<p>还是先来看一下，没有PRC的时候，会怎么样。</p> 
<p style="text-align:center;"><img alt="" class="has" src="https://images2.imgbox.com/42/a7/HGZbLh1u_o.png" width="532"></p> 
<p> </p> 
<p>在过去是这样的，包括现在很多对企业服务可能也是这样的，只有一个包部署在Tomcat里</p> 
<p>那个时候，没什么需要用到RPC的场景。</p> 
<p>然后当用户量大的时候呢？渐渐出现了负载均衡。</p> 
<p style="text-align:center;"><img alt="" class="has" src="https://images2.imgbox.com/6b/20/sBPhruF7_o.png" width="599"></p> 
<p>大概是这个样子。</p> 
<p>负载均衡能解决的问题很多，但是还是不够好，比如说，只是某一个功能模块（假设是用户中心）被访问的次数特别频繁，我可不可以把这部分内容单独拿出去？用户中心的机器独立，给它单独的带宽，给他单独的服务器，给他单独的数据库？</p> 
<p>不这么干其他的功能模块都干不下去了啊。</p> 
<p> </p> 
<p>好比是原来是学校餐厅，可以同时供200个人用餐，但是修真院的饺子馆生意特别好，每次来吃饭的人都有5000人，占满了所有餐椅，排队几万米，餐厅的其他摊位肯定不乐意了吧？</p> 
<p>比如说那个卖炒菜的，虽然我每天只有30来个人吃饭，那也是钱啊，你人这么多，想来我这边吃饭的人都找不着了。</p> 
<p>大概的情景应该是这样的。</p> 
<p style="text-align:center;"><img alt="" class="has" src="https://images2.imgbox.com/12/68/NExJRC6P_o.png" width="810"></p> 
<p>能理解么？</p> 
<p>遇到这种场景怎么办？不可能不让修真院饺子馆开门啊，那最好的方式就是：</p> 
<p>你可不可以搬出去？你不搬我们搬也行！（哭泣脸，反正我们是再也不要和你家饺子馆开在一起了，必须给我们一个说法）</p> 
<p>那么，搬家之后的样子可能是这样的。</p> 
<p style="text-align:center;"><img alt="" class="has" src="https://images2.imgbox.com/ab/9a/zAnXDawq_o.jpg" width="758"></p> 
<p>嗯啊。分是分开了，然后餐卡什么的还是在一起，还是和其他摊位一样，给大家提供就餐的功能。这就是分而治之，哪怕你修真院饺子馆关门了，也不影响我，这又叫分布式。</p> 
<p> </p> 
<p>说到分布式，就问题就来了。</p> 
<p>可不可以互相调用？其实细分下去，买菜，切菜，结账这些都是独立的流程，我们能不能都把它们独立出来？</p> 
<p>当然是可以的，但是带来的问题就是，如何通信？大家都不在一个进程里。</p> 
<p>这种通信的方式，就叫做RPC，在今天，RPC已经不仅仅是远程，这个远程，确切来说，就是指不在一个进程内，只能通过其他协议来完成，通常都是TCP或者是Http。</p> 
<p> </p> 
<p>好了，RPC讲清楚了，再看RPC的重点是什么。</p> 
<p>不能太慢，对不对？如果太慢了，怎么办？这种性能的要求，要做到什么程度？希望是和在同一个进程里，一致的体验。</p> 
<p>Http能做到这种程度么？</p> 
<p>不行。Http（TCP）本身的三次握手协议，就会带来大概1MS的延迟（emmm，这个数据其实我有点不确定了，也可能是几微秒，很早之前做过测试）。</p> 
<p>每发送一次请求，都会有一次建立连接的过程，加上Http报文本身的庞大，以及Json的庞大，都需要作一些优化。</p> 
<p> </p> 
<p>一般的场景下，没什么问题，但是对于Google这种级别的公司，他们接受不了。</p> 
<p>几MS的延迟可能就导致多出来几万台服务器，所以他们想尽办法去优化，优化从哪方面入手？</p> 
<p>1.减少传输量。</p> 
<p>2.简化协议。</p> 
<p>3.用长连接，不再每一个请求都重新走三次握手流程。</p> 
<p> </p> 
<p>Http的协议就注定了，在高性能要求的下，不适合用做线上分布式服务之间互相使用的通信协议。</p> 
<p>而常见的几种高效的协议有：protocolBuffer,Thrift，<strong>Hessian，RMI等。</strong></p> 
<p> </p> 
<p><strong>所以再回到题主的问题上面，为什么不使用http?</strong></p> 
<p><strong>因为有些场景下极限的追求，是普通人一生都难达到的境界啊。</strong></p> 
<p> </p> 
<p>本节作者：技能树IT修真院<br> 链接：https://www.zhihu.com/question/41609070/answer/480577185<br>  </p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/dad88465e6a8171f6a4b466e3968d64e/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">BeanFactoryPostProcessor注入spring对象</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/f2e581ea6c335516195083988e01519c/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">Android Framework 包管理子系统（01）PackageManagerService启动分析</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>