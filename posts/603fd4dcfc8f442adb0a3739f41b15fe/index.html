<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>二十三种设计模式 - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="二十三种设计模式" />
<meta property="og:description" content="二十三种设计模式 1 引言
谈到设计模式，绝对应该一起来说说重构。重构给我们带来了什么？除了作为对遗留代码的改进的方法，另一 大意义在于，可以让我们在写程序的时候可以不需事先考虑太多的代码组织问题，当然这其中也包括了应用模式的问题。尽管大多数开发者都已经养成了写代码前先 从设计开始的习惯，但是，这种程度的设计，涉及到到大局、到总体架构、到主要的模块划分我觉得就够了。换句话说，这时就能写代码了。这就得益于重构的思想 了。如果没有重构的思想，有希望获得非常高质量的代码，我们就不得不在开始写代码前考虑更多其实并非非常稳定的代码组织及设计模式的应用问题，那开发效率 当然就大打折扣了。在重构和设计模式的合理应用之下，我们可以相对较早的开始写代码，并在功能尽早实现的同时，不断地通过重构和模式来改善我们的代码质 量。所以，下面的章节中，在谈模式的同时，我也会谈谈关于常用的这些模式的重构成本的理解。重构成本越高意味着，在遇到类似的问题情形的时候，我们更应该 提前考虑应用对应的设计模式，而重构成本比较低则说明，类似的情形下，完全可以先怎么方便，怎么快怎么写，哪怕代码不是很优雅也没关系，回头再重构也很容 易。
1 创建型
1.1 Factory Method
思想：Factory Method的主要思想是使一个类的实例化延迟到其子类。
场景：典 型的应用场景如：在某个系统开发的较早阶段，有某些类的实例化过程，实例化方式可能还不是很确定，或者实际实例化的对象（可能是需要对象的某个子类中的一 个）不确定，或者比较容易变化。此时，如果直接将实例化过程写在某个函数中，那么一般就是if-else或select-case代 码。如果，候选项的数目较少、类型基本确定，那么这样的if-else还是可以接受的，一旦情形变 得复杂、不确定性增加，更甚至包含这个构造过程的函数所在的类包含几个甚至更多类似的函数时，这样的if-else代 码就会变得比较不那么容易维护了。此时，应用本模式，可以将这种复杂情形隔离开，即将这类不确定的对象的实例化过程延迟到子类。
实现：该模式的典型实现方法就是将调用类定义为一个虚类，在调用类定义一个专门用于构造不确定的对象实例的虚函数，再将实际的对象实例化代码 留到调用类的子类来实现。如果，被构造的对象比较复杂的话，同时可以将这个对象定义为可以继承、甚至虚类，再在不同的调用类的子类中按需返回被构造类的子 类。
重构成本：低。该模式的重构成本实际上还与调用类自己的实例化方式相关。如果调用类是通过Factory方 式（此处“Factory方式”泛指对象的实例化通过Factory Method或Abstract Factory这样的相对独立出来的 方式构造）构造的，那么，重构成本相对就会更低。否则，重构时可能除了增加调用类的子类，还要将所有实例化调用类的地方，修改为以新增的子类代替。可能这 样的子类还不止一个，那就可以考虑迭代应用模式来改善调用类的实例化代码。
1.2 Abstract Factory
思想：不直接通过对象的具体实现类，而是通过使用专门的类来负责一组相关联的对象的创建。
场景：最典型的应用场景是：您只想暴露对象的接口而不想暴露具体的实现类，但是又想提供实例化对象的接口给用户；或者，您希望所有的对象能够 集中在一个或一组类（通常称作工厂类）来创建，从而可以更方便的对对象的实例化过程进行动态配置（此时只需要修改工厂类的代码或配置）。
实现：该模式的实现是比较清晰简单的，如上图，就是定义创建和返回各种类对象实例的工厂类。在最复杂而灵活的情形，无论工厂类本身还是被创建 的对象类都可能需要有一个继承体系。简单情形其实可以只是一个工厂类和需要被创建的对象类。不一定非要像上图中结构那么完备（累赘）。
重构成本：中。如果一开始所有的对象都是直接创建，例如通过new实例化的， 而之后想重构为Abstract Factory模式，那么，很自然的我们需要替换所有直接的new实 例化代码为对工厂类对象创建方法的调用。考虑到像Resharper这样的重构工具的支持，找出对 某个方法或构造函数的调用位置这样的操作相对还是比较容易，重构成本也不是非常高。同时，重构成本还和被创建对象的构造函数的重载数量相关。您需要根据实 际情况考虑，是否工厂类要映射被创建对象的所有重载版本的构造函数。
1.3 Builder
思想：将一个类的创建过程和他的主体部分分离。
场景：该模式的典型的应用场景是：一个类的创建过程可能比较复杂，或者创建过程中的某些阶段可能会容易变化；或者多个类的创建过程比较类似， 但是主体不同。
实现：在 以上提到的两种场景中，我们就可以取出一个类的创建过程的代码，定义一个专门的Builder类， 而在原来创建类对象实例的地方，将这个Builder类的实例作为参数传入。还有第二个重点，就是Builder类 可以将将整个创建过程分为几个阶段，每个阶段不必在类中直接实现，而可以通过继承体系在子类中实现，或者通过子类的方法过载来修改创建过程中的某个阶段， 但是重用其他的阶段。可以发现，该模式将一个对象的复杂创建过程重用到非常高的层次。这正是它的意义所在。
重构成本：低。该模式的重构成本我觉得是非常低的，因为一般来讲，创建过程的代码本来也就应该在原来的类的构造函数中，把它Extract出 来就好了。如果发现多个类的创建过程有比较多的代码重复或类似，那么就可以重用这些提取出来的Builder类 或者Builder类中的某些阶段。
1.4 Prototype
思想：克 隆一个已有的类的实例（大家相比都用过甚至写过类的Clone实现，应该很容易理解了）。
场景：应 用Clone的场景应该说非常多，理想情况下我当然希望任何类都能Clone， 需要的时候就能Clone一份一模一样的出来。
实现：这 里将的实现主要之实现的表现形式，而不是如何用具体的语言来实现。因此，只要为需要Clone能力 的类定义一个Clone方法就行。当然，一般，主流的程序语言框架都已经定义了通用的Clone接 口（当然也可以自己定义），继承并实现该接口和方法就好。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/603fd4dcfc8f442adb0a3739f41b15fe/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2021-03-30T17:53:44+08:00" />
<meta property="article:modified_time" content="2021-03-30T17:53:44+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">二十三种设计模式</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <h2 style="margin-left:0cm;"><strong>                                           二十三种设计模式</strong></h2> 
<p style="margin-left:0cm;"><strong>1 </strong><strong>引言</strong></p> 
<p style="margin-left:0cm;">谈到设计模式，绝对应该一起来说说重构。重构给我们带来了什么？除了作为对遗留代码的改进的方法，另一 大意义在于，可以让我们在写程序的时候可以不需事先考虑太多的代码组织问题，当然这其中也包括了应用模式的问题。尽管大多数开发者都已经养成了写代码前先 从设计开始的习惯，但是，这种程度的设计，涉及到到大局、到总体架构、到主要的模块划分我觉得就够了。换句话说，这时就能写代码了。这就得益于重构的思想 了。如果没有重构的思想，有希望获得非常高质量的代码，我们就不得不在开始写代码前考虑更多其实并非非常稳定的代码组织及设计模式的应用问题，那开发效率 当然就大打折扣了。在重构和设计模式的合理应用之下，我们可以相对较早的开始写代码，并在功能尽早实现的同时，不断地通过重构和模式来改善我们的代码质 量。所以，下面的章节中，在谈模式的同时，我也会谈谈关于常用的这些模式的重构成本的理解。重构成本越高意味着，在遇到类似的问题情形的时候，我们更应该 提前考虑应用对应的设计模式，而重构成本比较低则说明，类似的情形下，完全可以先怎么方便，怎么快怎么写，哪怕代码不是很优雅也没关系，回头再重构也很容 易。</p> 
<p style="margin-left:0cm;"><strong>1 </strong><strong>创建型</strong></p> 
<p style="margin-left:0cm;"><strong>1.1 Factory Method</strong><img alt="" height="190" src="https://images2.imgbox.com/71/d0/c9Zq2v5n_o.jpg" width="542"></p> 
<p style="margin-left:0cm;"><strong>思想：</strong>Factory Method的主要思想是使一个类的实例化延迟到其子类。</p> 
<p style="margin-left:0cm;"><strong>场景：</strong>典 型的应用场景如：在某个系统开发的较早阶段，有某些类的实例化过程，实例化方式可能还不是很确定，或者实际实例化的对象（可能是需要对象的某个子类中的一 个）不确定，或者比较容易变化。此时，如果直接将实例化过程写在某个函数中，那么一般就是if-else或select-case代 码。如果，候选项的数目较少、类型基本确定，那么这样的if-else还是可以接受的，一旦情形变 得复杂、不确定性增加，更甚至包含这个构造过程的函数所在的类包含几个甚至更多类似的函数时，这样的if-else代 码就会变得比较不那么容易维护了。此时，应用本模式，可以将这种复杂情形隔离开，即将这类不确定的对象的实例化过程延迟到子类。</p> 
<p style="margin-left:0cm;"><strong>实现：</strong>该模式的典型实现方法就是将调用类定义为一个虚类，在调用类定义一个专门用于构造不确定的对象实例的虚函数，再将实际的对象实例化代码 留到调用类的子类来实现。如果，被构造的对象比较复杂的话，同时可以将这个对象定义为可以继承、甚至虚类，再在不同的调用类的子类中按需返回被构造类的子 类。</p> 
<p style="margin-left:0cm;"><strong>重构成本：</strong>低。该模式的重构成本实际上还与调用类自己的实例化方式相关。如果调用类是通过Factory方 式（此处“Factory方式”泛指对象的实例化通过Factory Method或Abstract Factory这样的相对独立出来的 方式构造）构造的，那么，重构成本相对就会更低。否则，重构时可能除了增加调用类的子类，还要将所有实例化调用类的地方，修改为以新增的子类代替。可能这 样的子类还不止一个，那就可以考虑迭代应用模式来改善调用类的实例化代码。</p> 
<p style="margin-left:0cm;"><strong>1.2 Abstract Factory</strong><img alt="" height="190" src="https://images2.imgbox.com/0d/f4/gbFERbW9_o.jpg" width="542"></p> 
<p style="margin-left:0cm;"><strong>思想：</strong>不直接通过对象的具体实现类，而是通过使用专门的类来负责一组相关联的对象的创建。</p> 
<p style="margin-left:0cm;"><strong>场景：</strong>最典型的应用场景是：您只想暴露对象的接口而不想暴露具体的实现类，但是又想提供实例化对象的接口给用户；或者，您希望所有的对象能够 集中在一个或一组类（通常称作工厂类）来创建，从而可以更方便的对对象的实例化过程进行动态配置（此时只需要修改工厂类的代码或配置）。</p> 
<p style="margin-left:0cm;"><strong>实现：</strong>该模式的实现是比较清晰简单的，如上图，就是定义创建和返回各种类对象实例的工厂类。在最复杂而灵活的情形，无论工厂类本身还是被创建 的对象类都可能需要有一个继承体系。简单情形其实可以只是一个工厂类和需要被创建的对象类。不一定非要像上图中结构那么完备（累赘）。</p> 
<p style="margin-left:0cm;"><strong>重构成本：</strong>中。如果一开始所有的对象都是直接创建，例如通过new实例化的， 而之后想重构为Abstract Factory模式，那么，很自然的我们需要替换所有直接的new实 例化代码为对工厂类对象创建方法的调用。考虑到像Resharper这样的重构工具的支持，找出对 某个方法或构造函数的调用位置这样的操作相对还是比较容易，重构成本也不是非常高。同时，重构成本还和被创建对象的构造函数的重载数量相关。您需要根据实 际情况考虑，是否工厂类要映射被创建对象的所有重载版本的构造函数。</p> 
<p style="margin-left:0cm;"><strong>1.3 Builder</strong><img alt="" height="204" src="https://images2.imgbox.com/ca/1b/WbvyfLKj_o.jpg" width="554"></p> 
<p style="margin-left:0cm;"><strong>思想：</strong>将一个类的创建过程和他的主体部分分离。</p> 
<p style="margin-left:0cm;"><strong>场景：</strong>该模式的典型的应用场景是：一个类的创建过程可能比较复杂，或者创建过程中的某些阶段可能会容易变化；或者多个类的创建过程比较类似， 但是主体不同。</p> 
<p style="margin-left:0cm;"><strong>实现：</strong>在 以上提到的两种场景中，我们就可以取出一个类的创建过程的代码，定义一个专门的Builder类， 而在原来创建类对象实例的地方，将这个Builder类的实例作为参数传入。还有第二个重点，就是Builder类 可以将将整个创建过程分为几个阶段，每个阶段不必在类中直接实现，而可以通过继承体系在子类中实现，或者通过子类的方法过载来修改创建过程中的某个阶段， 但是重用其他的阶段。可以发现，该模式将一个对象的复杂创建过程重用到非常高的层次。这正是它的意义所在。</p> 
<p style="margin-left:0cm;"><strong>重构成本：</strong>低。该模式的重构成本我觉得是非常低的，因为一般来讲，创建过程的代码本来也就应该在原来的类的构造函数中，把它Extract出 来就好了。如果发现多个类的创建过程有比较多的代码重复或类似，那么就可以重用这些提取出来的Builder类 或者Builder类中的某些阶段。</p> 
<p style="margin-left:0cm;"><strong>1.4 Prototype</strong><img alt="" height="240" src="https://images2.imgbox.com/db/17/JzWg031v_o.png" width="521"></p> 
<p style="margin-left:0cm;"><strong>思想：</strong>克 隆一个已有的类的实例（大家相比都用过甚至写过类的Clone实现，应该很容易理解了）。</p> 
<p style="margin-left:0cm;"><strong>场景：</strong>应 用Clone的场景应该说非常多，理想情况下我当然希望任何类都能Clone， 需要的时候就能Clone一份一模一样的出来。</p> 
<p style="margin-left:0cm;"><strong>实现：</strong>这 里将的实现主要之实现的表现形式，而不是如何用具体的语言来实现。因此，只要为需要Clone能力 的类定义一个Clone方法就行。当然，一般，主流的程序语言框架都已经定义了通用的Clone接 口（当然也可以自己定义），继承并实现该接口和方法就好。</p> 
<p style="margin-left:0cm;"><strong>重构成本：</strong>极低。不多解释了吧。</p> 
<p style="margin-left:0cm;"><strong>1.5 Singleton</strong><img alt="" height="146" src="https://images2.imgbox.com/ca/31/qYJLldFm_o.png" width="395"></p> 
<p style="margin-left:0cm;"><strong>思想：</strong>保证一个类只有一个唯一的实例。</p> 
<p style="margin-left:0cm;"><strong>场景：</strong>生活中有些对象就是只要一个就好了，我们的代码中为什么要每次都为这样的对象生成一个实例呢？</p> 
<p style="margin-left:0cm;"><strong>实现：</strong>最 简单的实现方式就是使用一个static型的类实例，每次对该对象的创建请求都返回这个static的 唯一实例就行。</p> 
<p style="margin-left:0cm;"><strong>重构成本：</strong>极低。</p> 
<p style="margin-left:0cm;"><strong>2 </strong><strong>结构型</strong></p> 
<p style="margin-left:0cm;"><strong>2.1 Adapter</strong><img alt="" height="408" src="https://images2.imgbox.com/cc/40/tQSnWrtN_o.png" width="541"></p> 
<p style="margin-left:0cm;"><strong>思想：</strong>将一个类的接口转换成另外一个接口，使得原本由于接口不兼容而不能一起工作的那些类可以一起工作。</p> 
<p style="margin-left:0cm;"><strong>场景：</strong>该 模式的应用场景太多了，很多需要的功能模块的接口和我们需要的不完全一致或者有多余或不足，但是需要和我们的系统协同工作，通过Adapter把 它包装一下就能让使它接口兼容了。</p> 
<p style="margin-left:0cm;"><strong>实现：</strong>定 义一个Adapter类，包含需要包装的类，实现需要的其它接口，调用被包装的类的方法来实现需要 的接口。</p> 
<p style="margin-left:0cm;"><strong>重构成本：</strong>低。</p> 
<p style="margin-left:0cm;"><strong>2.2 Bridge</strong><img alt="" height="228" src="https://images2.imgbox.com/cb/2f/qLv7LKtL_o.png" width="553"></p> 
<p style="margin-left:0cm;"><strong>思想：</strong>将一个类的抽象定义和具体实现解耦。</p> 
<p style="margin-left:0cm;"><strong>场景：</strong>该 模式的典型应用场景是：一个类的抽象定义已经确定，但是，其实现代码甚至原理可能会不同。比如：我们最熟悉的图形界面中的window的 实现，无论在什么操作系统，什么平台的机器上，一个window应具有的抽象定义基本上是一致的， 但是，其实现代码肯定会因为平台不同，机器的代码指令不同而不同。此时，如果希望您写的window类 能跨平台，应用Bridge模式就是一个好主意。</p> 
<p style="margin-left:0cm;"><strong>实现：</strong>该 模式的实现方法很简单，就是除了定义类的抽象定义之外，将一个类的所有实现代码独立出一个实现类。这样一来，无论是抽象定义还是实现类都能分别修改和重 用，但只要两部分的交互接口不变，还是可以方便的互相组装。当然，实际上也没有必要隔离出“所有实现代码”，只需要隔离需要的部分就行了。因此，也可以 说，从代码结构来看，Builder模式是一种变种的Bridge模 式的。也经常有人将Bridge模式和接口相比较，如果隔离出所有的实现，那么的确接口的方式也能 做到抽象定义和实现分离，但是，Bridge有其优势如下：一、究竟隔离多少代码到Bridge类 中可以灵活确定，二、减少了总的类的数目，三、允许被隔离出来的Bridge类被其它的类直接共享 使用。</p> 
<p style="margin-left:0cm;"><strong>重构成本：</strong>中。将所有的（或很大部分）实现代码分离开来总还是一件不大，但是，也不小的事。所以标个“中”在这里。：）</p> 
<p style="margin-left:0cm;"><strong>2.3 Composite</strong><img alt="" height="261" src="https://images2.imgbox.com/f1/b8/9hpNNcm9_o.png" width="570"></p> 
<p style="margin-left:0cm;"><strong>思想：</strong>将 对象组合成树形结构以表示“部分-整体”的层次结构，使得用户对单个对象和组合对象的使用具有一致 性。</p> 
<p style="margin-left:0cm;"><strong>场景：</strong>该 模式的应用场景极其类似，比如像图形系统，如电路设计、UML建模系统，或者像web的 显示元素等，都是那种需要整体和部分具有使用接口上的一定的一致性的需求的结构，实际上，我觉得这样的系统如果不使用Composite模 式将会是惨不忍睹的。</p> 
<p style="margin-left:0cm;"><strong>实现：</strong>该模式的实现主要就是要表示整体或部分的所有类都继承自同一的基类或接口，从而拥有使用接口上一定的一致性。</p> 
<p style="margin-left:0cm;"><strong>重构成本：</strong>高。</p> 
<p style="margin-left:0cm;"><strong>2.4 Decorator</strong><img alt="" height="251" src="https://images2.imgbox.com/13/eb/8xSCE1Za_o.png" width="553"></p> 
<p style="margin-left:0cm;"><strong>思想：</strong>为一个对象已有的子类添加一些额外的职责。</p> 
<p style="margin-left:0cm;"><strong>场景：</strong>该模式的使用场景，主要是有的时候我们不愿意定义逻辑上新的子类，因为没有新的逻辑含义上的子类概念，而只是想为一个已存在的子类附加 一些职责。</p> 
<p style="margin-left:0cm;"><strong>实现：</strong>该 模式的实现主要就是定义一个物理上的新的子类，但是，它只是包含要附加职责的类，传递外部对相同接口的调用，在这个传递调用的通道上附加额外的功能。突然 想到，Decorator模式是不是一定程度上也能代替DynamicProxy模 式，从而成为一种AOP实现的方案呢？</p> 
<p style="margin-left:0cm;"><strong>重构成本：</strong>低。定义一个Decorator和一个已有类的逻辑上的子类，物理 表现形式上都是一个子类，重构也确实不是难事。</p> 
<p style="margin-left:0cm;"><strong>2.5 Facade</strong><img alt="" height="195" src="https://images2.imgbox.com/28/4e/7gGnvQ3Q_o.png" width="491"></p> 
<p style="margin-left:0cm;"><strong>思想：</strong>为子系统中的一组接口提供一个一致的界面，这个接口使得这一子系统更加容易使用。</p> 
<p style="margin-left:0cm;"><strong>场景：</strong>当 你要为一个复杂子系统提供一个简单接口时。子系统往往因为不断演化而变得越来越复杂。大多数模式使用时都会产生更多更小的类。这使得子系统更具可重用性， 也更容易对子系统进行定制，但这也给那些不需要定制子系统的用户带来一些使用上的困难。Facade可 以提供一个简单的缺省视图，这一视图对大多数用户来说已经足够，而那些需要更多的可定制性的用户可以越过Facade层。 客户程序与抽象类的实现部分之间存在着很大的依赖性。引入Facade将这个子系统与客户以及其他 的子系统分离，可以提高子系统的独立性和可移植性。当你需要构建一个层次结构的子系统时，使用Facade模 式定义子系统中每层的入口点。如果子系统之间是相互依赖的，你可以让它们仅通过Facade进行通 讯，从而简化了它们之间的依赖关系。（这里直接引用了《设计模式迷你手册》，因为觉得它确实已经说得很明了了，下面类似的情形我直接引用原文的就不再注明 了，这里先说明一下，感谢《手册》作者的这些优秀总结。当然，本文的绝大多数文字都是Teddy本 人的原创看法，绝非抄袭，您可以比较本文和附件《手册》，附件同时也会提供本文的Word版本下 载。）</p> 
<p style="margin-left:0cm;"><strong>实现：</strong>该 模式的实现需要定义一个新的系统构架上的Layer，该层向上提供一组新的接口，向下调用子系统原 有的接口。</p> 
<p style="margin-left:0cm;"><strong>重构成本：</strong>高。要修改所有直接对子系统的地调用为对Façade层的调用还是 有很多事情要做的。不过，现代IDE中，如果我们删除调用层对子系统的程序集引用，那么所有这些我 们需要修改的调用都能标示出来，因为编译不能通过了嘛，因此，重构的风险还不算特别大，只是工作量着实不小。</p> 
<p style="margin-left:0cm;"><strong>2.6 Flyweight</strong><img alt="" height="347" src="https://images2.imgbox.com/00/67/w3x7OPkR_o.png" width="553"></p> 
<p style="margin-left:0cm;"><strong>思想：</strong>说Flyweight可 能有的朋友第一次看到想象不到是什么样子，其实说他就是一个Pool，你可能就明白了。也就是由一 个Flyweight Factory来管理一族一定数目逻辑上经常需要构建和销毁的细颗粒对象， 例如我们常见的数据库连接池。在Factory内部，并不物理销毁这些对象，而在接到实例化请求时 返回这些被关系对象的实例，从而减少创建销毁这些细颗粒对象的开销。</p> 
<p style="margin-left:0cm;"><strong>场景：</strong>基 本上所有的需要Pool这个概念的环境都能应用。</p> 
<p style="margin-left:0cm;"><strong>实现：</strong>实现的底层方式可以千变万化，在接口上就是如上图所示，花样不多。这里就不多解释。</p> 
<p style="margin-left:0cm;"><strong>重构成本：</strong>低。</p> 
<p style="margin-left:0cm;"><strong>2.7 Proxy</strong><img alt="" height="215" src="https://images2.imgbox.com/31/dd/dWBFXU6S_o.png" width="520"></p> 
<p style="margin-left:0cm;"><strong>思想：</strong>前 面在Decorator模式中也提到了Proxy模 式了。它是通过逻辑上继承一个已有类的子类，从而扩展原有的子类的功能。</p> 
<p style="margin-left:0cm;"><strong>场景：</strong>需 要注意体会他和Decorator的需别。Proxy是 继承需要修饰的类，而Decorator用的是包含的方式。Proxy模 式，或者准确地说DynamicProxy模式，是现代AOP框 架实现中的一种常用方式。典型的实现如Spring，JBoss以 及Castle Project中的Aspect#。</p> 
<p style="margin-left:0cm;"><strong>实现：</strong>继承，并在过载方法中添加需要的修饰功能。</p> 
<p style="margin-left:0cm;"><strong>重构成本：</strong>低。</p> 
<p style="margin-left:0cm;"><strong>3 </strong><strong>行为型</strong></p> 
<p style="margin-left:0cm;"><strong>3.1 Interpreter</strong><img alt="" height="241" src="https://images2.imgbox.com/5d/9e/tTyPLQ0d_o.png" width="448"></p> 
<p style="margin-left:0cm;"><strong>思想：</strong>当 有一个语言需要解释执行, 并且你可将该语言中的句子表示为一个抽象语法树时，定义一个解释器，这 个解释器使用该表示来解释语言中的句子。</p> 
<p style="margin-left:0cm;"><strong>场景：</strong>其 实，从物理结构上，该模式的代码架构看起来可能和Composite模式一模一样，致使其针对的逻 辑语义不同。Composite模式描述一种一般的整体和部分使用接口上的一致性，而Interpreter模 式则侧重于语言解释器的实现构架。</p> 
<p style="margin-left:0cm;"><strong>实现：</strong>如 上图，基本同Composite模式。</p> 
<p style="margin-left:0cm;"><strong>重构成本：</strong>高。</p> 
<p style="margin-left:0cm;"><strong>3.2 Iterator</strong><img alt="" height="267" src="https://images2.imgbox.com/96/05/38LzdFvY_o.png" width="555"></p> 
<p style="margin-left:0cm;"><strong>思想：</strong>提 供一种方法顺序访问一个聚合对象中各个元素, 而又不需暴露该对象的内部表示。</p> 
<p style="margin-left:0cm;"><strong>场景：</strong>访 问一个聚合对象的内容而无需暴露它的内部表示。支持对聚合对象的多种遍历。为遍历不同的聚合结构提供一个统一的接口(即, 支持多态迭代)。</p> 
<p style="margin-left:0cm;"><strong>实现：</strong>其 实就是定义一个逻辑上类似一个指针的迭代类。专门用于这种迭代工作。如果对C++ STL火锅功夫 学习的朋友一定不会陌生啦。实际使用过一下就明白了。除了功能之外，他给我最大的感受就是他让我熟悉的for(int i = 0; i &lt; list.Count; i++)语句，变长了好多。^-^</p> 
<p style="margin-left:0cm;"><strong>重构成本：</strong>中。</p> 
<p style="margin-left:0cm;"><strong>3.3 Mediator</strong><img alt="" height="155" src="https://images2.imgbox.com/f9/df/MDlCC4l5_o.png" width="515"></p> 
<p style="margin-left:0cm;"><strong>思想：</strong>用一个中介对象来封装一系列的对象交互。中介者使各对象不需要显式地相互引用，从而使其耦合松散，而且可以独立地改变它们之间的交互。</p> 
<p style="margin-left:0cm;"><strong>场景：</strong>该模式主要用来进行降低一组相互关联调用的对象间的耦合度。如果您发现您的系统的某部分的一组对象间调用极其频繁的坏味道的话，可能您 需要考虑使用该模式来进行一些解耦，否则，这些对象中的任何一个的修改，都将可能导致其他对象许多地方的修改，可维护性就降低了。</p> 
<p style="margin-left:0cm;"><strong>实现：</strong>定义一个专门的中介对象来封装和传递一组对象间的调用。</p> 
<p style="margin-left:0cm;"><strong>重构成本：</strong>中。</p> 
<p style="margin-left:0cm;"><strong>3.4 Memento</strong><img alt="" height="175" src="https://images2.imgbox.com/53/40/4wnmqfJK_o.png" width="563"></p> 
<p style="margin-left:0cm;"><strong>思想：</strong>用在不破坏封装性的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态。这样以后就可将该对象恢复到原先保存的状态。</p> 
<p style="margin-left:0cm;"><strong>场景：</strong>该 模式主要用来实现类似我们在常见的编辑器中经常执行的Undo（Ctrl+Z） 操作。实际上就是在外部保持一组对象的某一时刻的状态，并在需要的另一个时候将这组对象回复到之前的状态。</p> 
<p style="margin-left:0cm;"><strong>实现：</strong>该 模式其实主要是一种对象状态的暂存和回复的思想。上面的UML图是一种比较典型的实现方式——定一 个专门用于保存类状态的类，为被保存状态的类定义返回当前状态类实例，和根据状态类实例回复对象状态的接口。实际上也不必太拘泥于这个实现，简单情形下， 我们完全可以利用任何的已有的对象持久化或者序列化机制来用一个字符串暂存对象的当前完整状态。</p> 
<p style="margin-left:0cm;"><strong>重构成本：</strong>低。</p> 
<p style="margin-left:0cm;"><strong>3.5 Template Method</strong><img alt="" height="218" src="https://images2.imgbox.com/cb/27/MorVHJrX_o.png" width="386"></p> 
<p style="margin-left:0cm;"><strong>思想：</strong>定 义一个操作中的算法的骨架，而将一些步骤延迟到子类中。Te m p l a t e M e t h o d 使 得子类可以不改变一个算法的结构即可重定义该算法的某些特定步骤。</p> 
<p style="margin-left:0cm;"><strong>场景：</strong>该 模式实际上是一种非常直观和可理解的OO思想下的代码重用的实现。只需一次性实现一个算法的不变的 部分，并将可变的行为留给子类来实现。各子类中公共的行为应被提取出来并集中到一个公共父类中以避免代码重复。模板方法只允许在特定点计算法的某个阶段被 过载，这样也就只允许在这些点进行扩展。</p> 
<p style="margin-left:0cm;"><strong>实现：</strong>见上图，太简单了，就不多说了。</p> 
<p style="margin-left:0cm;"><strong>重构成本：</strong>低。</p> 
<p style="margin-left:0cm;"><strong>3.6 Chain of Responsibility</strong><img alt="" height="203" src="https://images2.imgbox.com/ca/50/yXHCatRb_o.png" width="389"></p> 
<p style="margin-left:0cm;"><strong>思想：</strong>使多个对象都有机会处理请求，从而避免请求的发送者和接收者之间的耦合关系。将这些对象连成一条链，并沿着这条链传递该请求，直到有一 个对象处理它为止。</p> 
<p style="margin-left:0cm;"><strong>场景：</strong>该模式实际上是对人们常会不自觉地去做的一种代码组织方式的总结而已。有的时候一条消息需要被处理，我们当然可以在一个雷的一个方法中 对他进行所有需要的处理。但是，如果要做的处理很复杂的情形，甚至能够按照一定的逻辑醒来分类所有这些处理，则不要在一个雷一个函数里处以一切会更好，我 们可以定义多个处理类类表示逻辑上的不同的处理，然后一个个处理类的传递这个消息对象，让希望处理该消息的类自己决定是不是要处理。这样，就能将一个难以 维护的复杂处理过程，分解为一系列简单明了，易于维护的类了。</p> 
<p style="margin-left:0cm;"><strong>实现：</strong>上图是实现方式之一。即，使所有可能处理该请求的对象继承自一个基类，实际上，只要逻辑语义上我们保持这样一种让每个处理类自己决定何 时处理，并传递请求的思想，实现方式也可以千变万化，无论是用接口代替，或者甚至只是简单的定义相同结构的处理函数而通过反射机制来调用处理函数和传递处 理请求，都是可选的方案。</p> 
<p style="margin-left:0cm;"><strong>重构成本：</strong>中。</p> 
<p style="margin-left:0cm;"><strong>3.7 Command</strong><img alt="" height="190" src="https://images2.imgbox.com/1e/f5/ucefmOGL_o.png" width="553"></p> 
<p style="margin-left:0cm;"><strong>思想：</strong>将一个动态的执行过程封装成一个对象，可以像处理数据来处理和管理这样的对象，在需要的时候激发该对象的方法就能执行被封装的执行过 程。</p> 
<p style="margin-left:0cm;"><strong>场景：</strong>该模式在很多时候非常有用，它使得我们对逻辑上已经激发的行为进行优化成为可能，我们不仅可以根据需要改变一组逻辑上以经济法的活动的 顺序，消冗余操作，撤销不必要的操作等。也可以把活动和操作视为资源一样来管理和重用。同时该模式也是许多事务处理机制的基础。</p> 
<p style="margin-left:0cm;"><strong>实现：</strong>实现很简单，只是定义一些能够通过指定接口被激发的对活动进行封装的类，然后我们按照需要管理这些类，并在需要的时候激发这些活动。您 还是应该更多地去体会，为什么他是事务处理机制的基础，当我们可以这样来管理一组活动的时候，可以对这些活动进行那些有趣的控制。</p> 
<p style="margin-left:0cm;"><strong>重构成本：</strong>高。</p> 
<p style="margin-left:0cm;"><strong>3.8 Observer</strong><img alt="" height="218" src="https://images2.imgbox.com/92/a7/byfTispG_o.png" width="553"></p> 
<p style="margin-left:0cm;"><strong>思想：</strong>定 义对象间的一种一对多的依赖关系,当一个对象的状态发生改变时, 所 有依赖于它的对象都得到通知并被自动更新。</p> 
<p style="margin-left:0cm;"><strong>场景：</strong>上面描述该模式思想的文字可能显得有些拗口，实际上你也不用想得过于复杂。只要你写过任何的基于图形界面的程序，那么实际上您对他是一 点也不该陌生的。它就是我们每一次鼠标键盘敲击都在我们的程序内部流转着的事件机制的基础。当一个事件发生，则通知订阅该事件的对象。</p> 
<p style="margin-left:0cm;"><strong>实现：</strong>上 面的UML图看似复杂，实际上，去理解它的最好的办法就是试着思考和使用任何一种OO语 言来定义一个拥有事件机制的类。比如，.Net下，你只要好好去看看关于delegate的 文档，尝试着根据MSDN写写看一个最简单的自定义事件。那么，上面的UML图， 我敢保证你能很轻易的看明白。</p> 
<p style="margin-left:0cm;"><strong>重构成本：</strong>高。</p> 
<p style="margin-left:0cm;"><strong>3.9 State</strong><img alt="" height="181" src="https://images2.imgbox.com/46/8f/iIr2Dvmz_o.png" width="466"></p> 
<p style="margin-left:0cm;"><strong>思想：</strong>允许一个对象在其内部状态改变时改变它的行为。</p> 
<p style="margin-left:0cm;"><strong>场景：</strong>实 际上该模式在作为重构的目的是，绝大多数情况我们做的事情是将对一个类的state进行if-else或 者select-case，决定该执行什么操作的过程解耦的过程。</p> 
<p style="margin-left:0cm;"><strong>实现：</strong>将 表述一个类的某些操作该做什么，该怎么做的信息保存到其state中。即用一个包含更多信息，甚至 执行逻辑的state类实例来代替一个简单数据类型的state属 性。</p> 
<p style="margin-left:0cm;"><strong>重构成本：</strong>中。</p> 
<p style="margin-left:0cm;"><strong>3.10 Strategy</strong><img alt="" height="176" src="https://images2.imgbox.com/b7/2c/oB0qvHTD_o.png" width="543"></p> 
<p style="margin-left:0cm;"><strong>思想：</strong>定 义一系列的算法,把它们一个个封装起来, 并 且使它们可相互替换。本模式使得算法可独立于使用它的客户而变化。</p> 
<p style="margin-left:0cm;"><strong>场景：</strong>该 模式实际上也可以理解为一种Bridge模式的变种。只是它突出的是，一般当我们把一个类或者一组 类的一些代码独立成一个Strategy类的时候，我们可能会为同样接口的这些算法定义多个接口一 致，但是实现方法不同的版本，并在需要的时候灵活的替换这些算法。</p> 
<p style="margin-left:0cm;"><strong>实现：</strong>实 现方式同Bridge模式。</p> 
<p style="margin-left:0cm;"><strong>重构成本：</strong>中。</p> 
<p style="margin-left:0cm;"><strong>3.11 Visitor</strong><img alt="" height="429" src="https://images2.imgbox.com/01/1a/czY5QGUj_o.png" width="550"></p> 
<p style="margin-left:0cm;"><strong>思想：</strong>表 示一个作用于某对象结构中的各元素的操作。它使你可以在不改变各元素的类的前提下定义作用于这些元素的新操作。</p> 
<p style="margin-left:0cm;"><strong>场景：</strong>其 实你不用去理解上面这句话。该模式其实又是一个在代码的物理结构上和Bridge模式很相似的模 式。但是，其语义，其目的，在逻辑上又是不同的。如果说Bridge，以及上述我称为可视为Bridge扩 展的模式中，作为参数的Bridge类，是作为调用类的被访问对象的话，Visitor， 在大多数情形下，如其英文含义，它在语义上是完全相反的。不是他被调用的类处理，更大程度上它处于主动状态，是它去访问，去处理调用它的类。调用它的类， 把自己对别人隐藏起来的东西，暴露给Visitor品尝，任君蹂躏（这个，这个~~千 万别想歪了;-））。另一方面，即使逻辑上没有这种Visitor主 动去访问调用类的语义，只要Visitor类中的操作，是依赖于调用类的具体实现类（它本身或他某 个层次的子类）的某些状态或者方法的，那么，就可以应用该模式来分离出这样的可重用的操作。</p> 
<p style="margin-left:0cm;"><strong>实现：</strong>类 似Bridge模式。</p> 
<p style="margin-left:0cm;"><strong>重构成本：</strong>中。</p> 
<p style="margin-left:0cm;"><strong>二十三种设计模式介绍</strong></p> 
<p style="margin-left:0cm;"> </p> 
<p style="margin-left:0cm;">设计模式主要分三个类型:创建型、结构型和行为型。<br> 其中创建型有：<br> 一、Singleton，单例模式：保证一个类只有一个实例，并提供一个访问它的全局访问点<br> 二、Abstract Factory，抽象工厂：提供一个创建一系列相关或相互依赖对象的接口，而无须指定它们的具体类。<br> 三、Factory Method，工厂方法：定义一个用于创建对象的接口，让子类决定实例化哪一个类，Factory Method使 一个类的实例化延迟到了子类。<br> 四、Builder，建造模式：将一个复杂对象的构建与他的表示相分离，使得同样的构建过程可以创建不同的表示。<br> 五、Prototype，原型模式：用原型实例指定创建对象的种类，并且通过拷贝这些原型来创建新的对象。<br> 行为型有：<br> 六、Iterator，迭代器模式：提供一个方法顺序访问一个聚合对象的各个元素，而又不需要暴露该对象的内部表示。<br> 七、Observer，观察者模式：定义对象间一对多的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都得到通知自动更新。<br> 八、Template Method，模板方法：定义一个操作中的算法的骨架，而将一些步骤延迟到子类中，TemplateMethod 使得子类可以不改变一个算法的结构即可以重定义该算法得某些特定步骤。<br> 九、Command，命令模式：将一个请求封装为一个对象，从而使你可以用不同的请求对客户进行参数化，对请求排队和记录请求日志，以及 支持可撤销的操作。<br> 十、State，状态模式：允许对象在其内部状态改变时改变他的行为。对象看起来似乎改变了他的类。<br> 十一、Strategy，策略模式：定义一系列的算法，把他们一个个封装起来，并使他们可以互相替换，本模式使得算法可以独立于使用它们 的客户。<br> 十二、China of Responsibility，职责链模式：使多个对象都有机会处理请求，从而避免请求的送发者和接收者之间的 耦合关系<br> 十三、Mediator，中介者模式：用一个中介对象封装一些列的对象交互。<br> 十四、Visitor，访问者模式：表示一个作用于某对象结构中的各元素的操作，它使你可以在不改变各元素类的前提下定义作用于这个元素 的新操作。<br> 十五、Interpreter，解释器模式：给定一个语言，定义他的文法的一个表示，并定义一个解释器，这个解释器使用该表示来解释语言 中的句子。<br> 十六、Memento，备忘录模式：在不破坏对象的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态。<br> 结构型有：<br> 十七、Composite，组合模式：将对象组合成树形结构以表示部分整体的关系，Composite使得用户对单个对象和组合对象的使 用具有一致性。<br> 十八、Facade，外观模式：为子系统中的一组接口提供一致的界面，fa?ade提供了一高层接口，这个接口使得子系统更容易使用。<br> 十九、Proxy，代理模式：为其他对象提供一种代理以控制对这个对象的访问<br> 二十、Adapter,适配器模式：将一类的接口转换成客户希望的另外一个接口，Adapter模式使得原本由于接口不兼容而不能一起工 作那些类可以一起工作。<br> 二十一、Decrator，装饰模式：动态地给一个对象增加一些额外的职责，就增加的功能来说，Decorator模式相比生成子类更加 灵活。<br> 二十二、Bridge，桥模式：将抽象部分与它的实现部分相分离，使他们可以独立的变化。<br> 二十三、Flyweight，享元模式：</p> 
<p style="margin-left:0cm;"> </p> 
<p style="margin-left:0cm;"><strong>二十三种设计模式通俗理解</strong></p> 
<p style="margin-left:0cm;"> </p> 
<p style="margin-left:0cm;">这几天接触到了设计模式，就查了一些关于这方面的资料，觉得还不错，所以就拿出来与大家一起分享了。<br> 1、FACTORY 追MM少不了请吃饭了，麦当劳的鸡翅和肯德基的鸡翅都是MM爱吃的东西，虽然口味有所不同，但不管你带MM去麦当劳或肯德基，只管向服务员说“来四个鸡翅”就行了。麦当劳和肯德基就是生产鸡翅的Factory 工厂模式：客户类和工厂类分开。消费者任何时候需要某种产品，只需向工厂请求即可。消费者无须修改就可以接纳新产品。缺点是当产品修改时，工厂类也要做相应的修改。如：如何创建及如何向客户端提供。<br><br> 2、BUILDER MM最爱听的就是“我爱你”这句话了，见到不同地方的MM,要能够用她们的方言跟她说这句话哦，我有一个多种语言翻译机，上面每种语言都有一个按键，见到 MM我只要按对应的键，它就能够用相应的语言说出“我爱你”这句话了，国外的MM也可以轻松搞掂，这就是我的“我爱你”builder。（这一定比美军在伊拉克用的翻译机好卖） 建造模式：将产品的内部表象和产品的生成过程分割开来，从而使一个建造过程生成具有不同的内部表象的产品对象。建造模式使得产品内部表象可以独立的变化，客户不必知道产品内部组成的细节。建造模式可以强制实行一种分步骤进行的建造过程。<br><br> 3、FACTORY METHOD 请MM去麦当劳吃汉堡，不同的MM有不同的口味，要每个都记住是一件烦人的事情，我一般采用Factory Method模式，带着MM到服务员那儿，说“要一个汉堡”，具体要什么样的汉堡呢，让MM直接跟服务员说就行了。 工厂方法模式：核心工厂类不再负责所有产品的创建，而是将具体创建的工作交给子类去做，成为一个抽象工厂角色，仅负责给出具体工厂类必须实现的接口，而不接触哪一个产品类应当被实例化这种细节。<br><br> 4、PROTOTYPE 跟MM用QQ聊天，一定要说些深情的话语了，我搜集了好多肉麻的情话，需要时只要copy出来放到QQ里面就行了，这就是我的情话prototype 了。（100块钱一份，你要不要） 原始模型模式：通过给出一个原型对象来指明所要创建的对象的类型，然后用复制这个原型对象的方法创建出更多同类型的对象。原始模型模式允许动态的增加或减少产品类，产品类不需要非得有任何事先确定的等级结构，原始模型模式适用于任何的等级结构。缺点是每一个类都必须配备一个克隆方法。<br><br> 5、SINGLETON 俺有6个漂亮的老婆，她们的老公都是我，我就是我们家里的老公Sigleton，她们只要说道“老公”，都是指的同一个人，那就是我(刚才做了个梦啦，哪有这么好的事) 单例模式：单例模式确保某一个类只有一个实例，而且自行实例化并向整个系统提供这个实例单例模式。单例模式只应在有真正的“单一实例”的需求时才可使用。 [b:9ceca65206]结构型模式[/b:9ceca65206]<br><br> 6、ADAPTER 在朋友聚会上碰到了一个美女Sarah，从香港来的，可我不会说粤语，她不会说普通话，只好求助于我的朋友kent了，他作为我和Sarah之间的 Adapter，让我和Sarah可以相互交谈了(也不知道他会不会耍我) 适配器（变压器）模式：把一个类的接口变换成客户端所期待的另一种接口，从而使原本因接口原因不匹配而无法一起工作的两个类能够一起工作。适配类可以根据参数返还一个合适的实例给客户端。<br><br> 7、BRIDGE 早上碰到MM，要说早上好，晚上碰到MM，要说晚上好；碰到MM穿了件新衣服，要说你的衣服好漂亮哦，碰到MM新做的发型，要说你的头发好漂亮哦。不要问我“早上碰到MM新做了个发型怎么说”这种问题，自己用BRIDGE组合一下不就行了 桥梁模式：将抽象化与实现化脱耦，使得二者可以独立的变化，也就是说将他们之间的强关联变成弱关联，也就是指在一个软件系统的抽象化和实现化之间使用组合 /聚合关系而不是继承关系，从而使两者可以独立的变化。<br><br> 8、COMPOSITE Mary今天过生日。“我过生日，你要送我一件礼物。”“嗯，好吧，去商店，你自己挑。”“这件T恤挺漂亮，买，这条裙子好看，买，这个包也不错，买。” “喂，买了三件了呀，我只答应送一件礼物的哦。”“什么呀，T恤加裙子加包包，正好配成一套呀，小姐，麻烦你包起来。”“……”，MM都会用 Composite模式了，你会了没有？ 合成模式：合成模式将对象组织到树结构中，可以用来描述整体与部分的关系。合成模式就是一个处理对象的树结构的模式。合成模式把部分与整体的关系用树结构表示出来。合成模式使得客户端把一个个单独的成分对象和由他们复合而成的合成对象同等看待。<br><br> 9、DECORATOR Mary过完轮到Sarly过生日，还是不要叫她自己挑了，不然这个月伙食费肯定玩完，拿出我去年在华山顶上照的照片，在背面写上“最好的的礼物，就是爱你的Fita”，再到街上礼品店买了个像框（卖礼品的MM也很漂亮哦），再找隔壁搞美术设计的Mike设计了一个漂亮的盒子装起来……，我们都是 Decorator，最终都在修饰我这个人呀，怎么样，看懂了吗？ 装饰模式：装饰模式以对客户端透明的方式扩展对象的功能，是继承关系的一个替代方案，提供比继承更多的灵活性。动态给一个对象增加功能，这些功能可以再动态的撤消。增加由一些基本功能的排列组合而产生的非常大量的功能。<br><br> 10、FACADE 我有一个专业的Nikon相机，我就喜欢自己手动调光圈、快门，这样照出来的照片才专业，但MM可不懂这些，教了半天也不会。幸好相机有Facade设计模式，把相机调整到自动档，只要对准目标按快门就行了，一切由相机自动调整，这样MM也可以用这个相机给我拍张照片了。 门面模式：外部与一个子系统的通信必须通过一个统一的门面对象进行。门面模式提供一个高层次的接口，使得子系统更易于使用。每一个子系统只有一个门面类，而且此门面类只有一个实例，也就是说它是一个单例模式。但整个系统可以有多个门面类。<br><br> 11、FLYWEIGHT 每天跟MM发短信，手指都累死了，最近买了个新手机，可以把一些常用的句子存在手机里，要用的时候，直接拿出来，在前面加上MM的名字就可以发送了，再不用一个字一个字敲了。共享的句子就是Flyweight，MM的名字就是提取出来的外部特征，根据上下文情况使用。 享元模式：FLYWEIGHT在拳击比赛中指最轻量级。享元模式以共享的方式高效的支持大量的细粒度对象。享元模式能做到共享的关键是区分内蕴状态和外蕴状态。内蕴状态存储在享元内部，不会随环境的改变而有所不同。外蕴状态是随环境的改变而改变的。外蕴状态不能影响内蕴状态，它们是相互独立的。将可以共享的状态和不可以共享的状态从常规类中区分开来，将不可以共享的状态从类里剔除出去。客户端不可以直接创建被共享的对象，而应当使用一个工厂对象负责创建被共享的对象。享元模式大幅度的降低内存中对象的数量。<br><br> 12、PROXY 跟MM在网上聊天，一开头总是“hi,你好”,“你从哪儿来呀？”“你多大了？”“身高多少呀？”这些话，真烦人，写个程序做为我的Proxy吧，凡是接收到这些话都设置好了自己的回答，接收到其他的话时再通知我回答，怎么样，酷吧。 代理模式：代理模式给某一个对象提供一个代理对象，并由代理对象控制对源对象的引用。代理就是一个人或一个机构代表另一个人或者一个机构采取行动。某些情况下，客户不想或者不能够直接引用一个对象，代理对象可以在客户和目标对象直接起到中介的作用。客户端分辨不出代理主题对象与真实主题对象。代理模式可以并不知道真正的被代理对象，而仅仅持有一个被代理对象的接口，这时候代理对象不能够创建被代理对象，被代理对象必须有系统的其他角色代为创建并传入。 [b:9ceca65206]行为模式[/b:9ceca65206]<br><br> 13、CHAIN OF RESPONSIBLEITY 晚上去上英语课，为了好开溜坐到了最后一排，哇，前面坐了好几个漂亮的MM哎，找张纸条，写上“Hi,可以做我的女朋友吗？如果不愿意请向前传”，纸条就一个接一个的传上去了，糟糕，传到第一排的MM把纸条传给老师了，听说是个老处女呀，快跑! 责任链模式：在责任链模式中，很多对象由每一个对象对其下家的引用而接起来形成一条链。请求在这个链上传递，直到链上的某一个对象决定处理此请求。客户并不知道链上的哪一个对象最终处理这个请求，系统可以在不影响客户端的情况下动态的重新组织链和分配责任。处理者有两个选择：承担责任或者把责任推给下家。一个请求可以最终不被任何接收端对象所接受。<br><br> 14、COMMAND 俺有一个MM家里管得特别严，没法见面，只好借助于她弟弟在我们俩之间传送信息，她对我有什么指示，就写一张纸条让她弟弟带给我。这不，她弟弟又传送过来一个COMMAND，为了感谢他，我请他吃了碗杂酱面，哪知道他说：“我同时给我姐姐三个男朋友送COMMAND，就数你最小气，才请我吃面。”， 命令模式：命令模式把一个请求或者操作封装到一个对象中。命令模式把发出命令的责任和执行命令的责任分割开，委派给不同的对象。命令模式允许请求的一方和发送的一方独立开来，使得请求的一方不必知道接收请求的一方的接口，更不必知道请求是怎么被接收，以及操作是否执行，何时被执行以及是怎么被执行的。系统支持命令的撤消。<br><br> 15、INTERPRETER 俺有一个《泡MM真经》，上面有各种泡MM的攻略，比如说去吃西餐的步骤、去看电影的方法等等，跟MM约会时，只要做一个Interpreter，照着上面的脚本执行就可以了。 解释器模式：给定一个语言后，解释器模式可以定义出其文法的一种表示，并同时提供一个解释器。客户端可以使用这个解释器来解释这个语言中的句子。解释器模式将描述怎样在有了一个简单的文法后，使用模式设计解释这些语句。在解释器模式里面提到的语言是指任何解释器对象能够解释的任何组合。在解释器模式中需要定义一个代表文法的命令类的等级结构，也就是一系列的组合规则。每一个命令对象都有一个解释方法，代表对命令对象的解释。命令对象的等级结构中的对象的任何排列组合都是一个语言。<br><br> 16、ITERATOR 我爱上了Mary，不顾一切的向她求婚。 Mary：“想要我跟你结婚，得答应我的条件” 我：“什么条件我都答应，你说吧” Mary：“我看上了那个一克拉的钻石” 我：“我买，我买，还有吗？” Mary：“我看上了湖边的那栋别墅” 我：“我买，我买，还有吗？” Mary：“我看上那辆法拉利跑车” 我脑袋嗡的一声，坐在椅子上，一咬牙：“我买，我买，还有吗？” …… 迭代子模式：迭代子模式可以顺序访问一个聚集中的元素而不必暴露聚集的内部表象。多个对象聚在一起形成的总体称之为聚集，聚集对象是能够包容一组对象的容器对象。迭代子模式将迭代逻辑封装到一个独立的子对象中，从而与聚集本身隔开。迭代子模式简化了聚集的界面。每一个聚集对象都可以有一个或一个以上的迭代子对象，每一个迭代子的迭代状态可以是彼此独立的。迭代算法可以独立于聚集角色变化。<br><br> 17、MEDIATOR 四个MM打麻将，相互之间谁应该给谁多少钱算不清楚了，幸亏当时我在旁边，按照各自的筹码数算钱，赚了钱的从我这里拿，赔了钱的也付给我，一切就OK啦，俺得到了四个MM的电话。 调停者模式：调停者模式包装了一系列对象相互作用的方式，使得这些对象不必相互明显作用。从而使他们可以松散偶合。当某些对象之间的作用发生改变时，不会立即影响其他的一些对象之间的作用。保证这些作用可以彼此独立的变化。调停者模式将多对多的相互作用转化为一对多的相互作用。调停者模式将对象的行为和协作抽象化，把对象在小尺度的行为上与其他对象的相互作用分开处理。<br><br> 18、MEMENTO 同时跟几个MM聊天时，一定要记清楚刚才跟MM说了些什么话，不然MM发现了会不高兴的哦，幸亏我有个备忘录，刚才与哪个MM说了什么话我都拷贝一份放到备忘录里面保存，这样可以随时察看以前的记录啦。 备忘录模式：备忘录对象是一个用来存储另外一个对象内部状态的快照的对象。备忘录模式的用意是在不破坏封装的条件下，将一个对象的状态捉住，并外部化，存储起来，从而可以在将来合适的时候把这个对象还原到存储起来的状态。<br><br> 19、OBSERVER 想知道咱们公司最新MM情报吗？加入公司的MM情报邮件组就行了，tom负责搜集情报，他发现的新情报不用一个一个通知我们，直接发布给邮件组，我们作为订阅者（观察者）就可以及时收到情报啦 观察者模式：观察者模式定义了一种一队多的依赖关系，让多个观察者对象同时监听某一个主题对象。这个主题对象在状态上发生变化时，会通知所有观察者对象，使他们能够自动更新自己。<br><br> 20、STATE 跟MM交往时，一定要注意她的状态哦，在不同的状态时她的行为会有不同，比如你约她今天晚上去看电影，对你没兴趣的MM就会说“有事情啦”，对你不讨厌但还没喜欢上的MM就会说“好啊，不过可以带上我同事么？”，已经喜欢上你的MM就会说“几点钟？看完电影再去泡吧怎么样？”，当然你看电影过程中表现良好的话，也可以把MM的状态从不讨厌不喜欢变成喜欢哦。 状态模式：状态模式允许一个对象在其内部状态改变的时候改变行为。这个对象看上去象是改变了它的类一样。状态模式把所研究的对象的行为包装在不同的状态对象里，每一个状态对象都属于一个抽象状态类的一个子类。状态模式的意图是让一个对象在其内部状态改变的时候，其行为也随之改变。状态模式需要对每一个系统可能取得的状态创立一个状态类的子类。当系统的状态变化时，系统便改变所选的子类。<br><br> 21、STRATEGY 跟不同类型的MM约会，要用不同的策略，有的请电影比较好，有的则去吃小吃效果不错，有的去海边浪漫最合适，单目的都是为了得到MM的芳心，我的追MM锦囊中有好多Strategy哦。 策略模式：策略模式针对一组算法，将每一个算法封装到具有共同接口的独立的类中，从而使得它们可以相互替换。策略模式使得算法可以在不影响到客户端的情况下发生变化。策略模把行为和环境分开。环境类负责维持和查询行为类，各种算法在具体的策略类中提供。由于算法和环境独立开来，算法的增减，修改都不会影响到环境和客户端。<br><br> 22、TEMPLATE METHOD 看过《如何说服女生上床》这部经典文章吗？女生从认识到上床的不变的步骤分为巧遇、打破僵局、展开追求、接吻、前戏、动手、爱抚、进去八大步骤 (Template method)，但每个步骤针对不同的情况，都有不一样的做法，这就要看你随机应变啦(具体实现)； 模板方法模式：模板方法模式准备一个抽象类，将部分逻辑以具体方法以及具体构造子的形式实现，然后声明一些抽象方法来迫使子类实现剩余的逻辑。不同的子类可以以不同的方式实现这些抽象方法，从而对剩余的逻辑有不同的实现。先制定一个顶级逻辑框架，而将逻辑的细节留给具体的子类去实现。<br><br> 23、VISITOR 情人节到了，要给每个MM送一束鲜花和一张卡片，可是每个MM送的花都要针对她个人的特点，每张卡片也要根据个人的特点来挑，我一个人哪搞得清楚，还是找花店老板和礼品店老板做一下Visitor，让花店老板根据MM的特点选一束花，让礼品店老板也根据每个人特点选一张卡，这样就轻松多了； 访问者模式：访问者模式的目的是封装一些施加于某种数据结构元素之上的操作。一旦这些操作需要修改的话，接受这个操作的数据结构可以保持不变。访问者模式适用于数据结构相对未定的系统，它把数据结构和作用于结构上的操作之间的耦合解脱开，使得操作集合可以相对自由的演化。访问者模式使得增加新的操作变的很容易，就是增加一个新的访问者类。访问者模式将有关的行为集中到一个访问者对象中，而不是分散到一个个的节点类中。当使用访问者模式时，要将尽可能多的对象浏览逻辑放在访问者类中，而不是放到它的子类中。访问者模式可以跨过几个类的等级结构访问属于不同的等级结构的成员类。阿斯顿法国红酒看来</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/3e53ce0d0c7e99530efa7dae532f1d71/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">一些优秀的编程课程下载学习，如Java课程下载，PHP课程下载，前端开发课程下载</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/0a9602db4010dd1f083c9921273c39db/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">正则表达式匹配汉字</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>