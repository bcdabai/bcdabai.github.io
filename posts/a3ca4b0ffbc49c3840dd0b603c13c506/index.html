<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>洛谷 P1126 机器人搬重物 - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="洛谷 P1126 机器人搬重物" />
<meta property="og:description" content="题目描述 机器人移动学会（RMI）现在正尝试用机器人搬运物品。机器人的形状是一个直径 1.6 米的球。在试验阶段，机器人被用于在一个储藏室中搬运货物。储藏室是一个 N×M 的网格，有些格子为不可移动的障碍。机器人的中心总是在格点上，当然，机器人必须在最短的时间内把物品搬运到指定的地方。机器人接受的指令有：
向前移动 1 步（Creep）；向前移动 2 步（Walk）；向前移动 3 步（Run）；向左转（Left）；向右转（Right）。 每个指令所需要的时间为 1 秒。请你计算一下机器人完成任务所需的最少时间。
输入格式 第一行为两个正整数 N,M (1≤N,M≤50)，下面 N 行是储藏室的构造，0 表示无障碍，1 表示有障碍，数字之间用一个空格隔开。接着一行有 4 个整数和 1 个大写字母，分别为起始点和目标点左上角网格的行与列，起始时的面对方向（东 E，南 S，西 W，北 N），数与数，数与字母之间均用一个空格隔开。终点的面向方向是任意的。
输出格式 一个整数，表示机器人完成任务所需的最少时间。如果无法到达，输出 −1−1。
输入输出样例 输入 #1
9 10 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 1 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 1 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 1 0 7 2 2 7 S 输出 #1" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/a3ca4b0ffbc49c3840dd0b603c13c506/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2024-01-22T16:09:33+08:00" />
<meta property="article:modified_time" content="2024-01-22T16:09:33+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">洛谷 P1126 机器人搬重物</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <h3>题目描述</h3> 
<p>机器人移动学会（RMI）现在正尝试用机器人搬运物品。机器人的形状是一个直径 1.6 米的球。在试验阶段，机器人被用于在一个储藏室中搬运货物。储藏室是一个 N×M 的网格，有些格子为不可移动的障碍。机器人的中心总是在格点上，当然，机器人必须在最短的时间内把物品搬运到指定的地方。机器人接受的指令有：</p> 
<ul><li>向前移动 1 步（<code>Creep</code>）；</li><li>向前移动 2 步（<code>Walk</code>）；</li><li>向前移动 3 步（<code>Run</code>）；</li><li>向左转（<code>Left</code>）；</li><li>向右转（<code>Right</code>）。</li></ul> 
<p>每个指令所需要的时间为 1 秒。请你计算一下机器人完成任务所需的最少时间。</p> 
<h3>输入格式</h3> 
<p>第一行为两个正整数 N,M (1≤N,M≤50)，下面 N 行是储藏室的构造，0 表示无障碍，1 表示有障碍，数字之间用一个空格隔开。接着一行有 4 个整数和 1 个大写字母，分别为起始点和目标点左上角网格的行与列，起始时的面对方向（东 E，南 S，西 W，北 N），数与数，数与字母之间均用一个空格隔开。终点的面向方向是任意的。</p> 
<h3>输出格式</h3> 
<p>一个整数，表示机器人完成任务所需的最少时间。如果无法到达，输出 −1−1。</p> 
<p></p> 
<p class="img-center"><img alt="" height="1080" src="https://images2.imgbox.com/42/21/h8VKzzrb_o.png" width="1200"></p> 
<h3>输入输出样例</h3> 
<p><strong>输入 #1</strong></p> 
<pre>9 10
0 0 0 0 0 0 1 0 0 0
0 0 0 0 0 0 0 0 1 0
0 0 0 1 0 0 0 0 0 0
0 0 1 0 0 0 0 0 0 0
0 0 0 0 0 0 1 0 0 0
0 0 0 0 0 1 0 0 0 0
0 0 0 1 1 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0
1 0 0 0 0 0 0 0 1 0
7 2 2 7 S</pre> 
<p><strong>输出 #1</strong></p> 
<pre>12</pre> 
<p>这题耗时2个多小时终于算是做出来了</p> 
<p class="img-center"><img alt="" height="150" src="https://images2.imgbox.com/5d/a7/wh9Pub2U_o.jpg" width="150"></p> 
<p> 这题求最少时间，很容易想到用广度搜索，然而这题与一般的找出口最短时间稍微有点不同，</p> 
<p>1.需要考虑转变方向所消耗的时间。</p> 
<p>2.每次移动不止移动一步。</p> 
<p>这里我个人觉得还是要抓住广搜的原理，这题中，广搜是把一秒能发生的运动的所有情况都存下来，这题中，<strong>不管是改变方向，还是改变位置，都是一秒发生的，所以都要进行入队操作，我们的标记数组也不单单只标记坐标，还要判断每个坐标的4个方向是否都使用过，</strong>多了一个考虑的因素（这里我用三维数组标记），导致题目的难度上升。</p> 
<p>这题还有一些需要注意的；</p> 
<p>1.因为存在一秒移动多个位置，所以不单单只判断到达的那个点是否是障碍物，还需要判断移动的过程中是否遇到障碍物。</p> 
<p>2.终点和起点可能重合（特判就行）</p> 
<p>3.机器人占四个格子，只有组成正方形的4个格子都为0才能移动（这里刚开始的时候处理一下就行）</p> 
<p>具体操作看代码</p> 
<p><strong>AC代码</strong></p> 
<pre><code class="hljs">#include&lt;stdio.h&gt;
struct nb {//结构体列队
	int x, y;//x为横坐标，y为纵坐标
	int s, f;//s为步数，//f为方向
}link[850100];
int n, m, x, y, p, q, f;
int hard = 1, tail = 1;
int a[52][52], b[52][52], book[52][52][91];
int main()
{
	int i, j;
	scanf("%d %d", &amp;n, &amp;m);//输入矩阵大小
	for (i = 1; i &lt;= n; i++)
		for (j = 1; j &lt;= m; j++)
			scanf("%d", &amp;a[i][j]);
	for(i=1;i&lt;n;i++)//特殊处理只有4个格子组成的正方形都为0，机器人才能通过
		for (j = 1; j &lt; m; j++)
		{
			if (a[i][j] == 0 &amp;&amp; a[i][j + 1] == 0 &amp;&amp; a[i + 1][j] == 0 &amp;&amp; a[i + 1][j + 1] == 0)
				b[i][j] = 0;
			else
				b[i][j] = 1;
		}
	scanf("%d %d %d %d", &amp;x, &amp;y, &amp;p, &amp;q);//输入起点，终点
	getchar();
	scanf("%c", &amp;f);//起始朝向
	if (x == p &amp;&amp; y == q)//特判起点终点是否重合
	{
		printf("0");
		return 0;
	}
	//起始点入队
	link[tail].x = x; link[tail].y = y;
	link[tail].s = 0; 
	if (f == 'E') link[tail].f = 1;//f=1表示东方向，2表示南，3表示西，4表示北
	else if(f == 'S') link[tail].f = 2;
	else if (f == 'W') link[tail].f = 3;
	else  link[tail].f = 4;
	book[x][y][link[tail].f] = 1; tail++;
	int flag = 0;//flag用于判断是否找到出口
	//广搜核心代码
	while (hard &lt; tail)
	{
		//先广度搜索方向
		for (i = 0; i &lt;= 1; i++)
		{
			int tf;
			if (i == 0)//0表示左转
			{
				tf = link[hard].f + 1;
				if (tf == 5)
					tf = 1;
			}
			else//右转
			{
				tf = link[hard].f - 1;
				if (tf == 0)
					tf = 4;
			}
			if (book[link[hard].x][link[hard].y][tf] == 0)//如果这个方向没有入队，进行入队操作
			{
				link[tail].x = link[hard].x;
				link[tail].y = link[hard].y;
				link[tail].s = link[hard].s + 1;
				link[tail].f = tf;
				book[link[hard].x][link[hard].y][tf] = 1;
				tail++;
			}
		}
		//广度搜索不同移动距离
		for (i = 3; i &gt;= 1; i--)
		{
			int tx, ty;
			int fl = 0;//判断移动期间是否遇到障碍物，0为没有遇到
			if (link[hard].f == 1)//link[hard].f大小不同移动方向不同
			{
				tx = link[hard].x;
				ty = link[hard].y + i;
				if (tx&lt;1 || tx&gt;n - 1 || ty&lt;1 || ty&gt;m - 1)//是否越界
					continue;
				for (j = link[hard].y + 1; j &lt;= ty; j++)//判断是否遇到障碍物
				{
					if (b[tx][j] == 1)
					{
						fl = 1;
						break;
					}
				}
			}
			else if (link[hard].f == 2)
			{
				tx = link[hard].x + i;
				ty = link[hard].y;
				if (tx&lt;1 || tx&gt;n - 1 || ty&lt;1 || ty&gt;m - 1)//是否越界
					continue;
				for (j = link[hard].x + 1; j &lt;= tx; j++)//判断是否遇到障碍物
				{
					if (b[j][ty] == 1)
					{
						fl = 1;
						break;
					}
				}
			}
			else if (link[hard].f == 3)
			{
				tx = link[hard].x;
				ty = link[hard].y - i;
				if (tx&lt;1 || tx&gt;n - 1 || ty&lt;1 || ty&gt;m - 1)//是否越界
					continue;
				for (j = link[hard].y - 1; j &gt;= ty; j--)//判断是否遇到障碍物
				{
					if (b[tx][j] == 1)
					{
						fl = 1;
						break;
					}
				}
			}
			else
			{
				tx = link[hard].x - i;
				ty = link[hard].y;
				if (tx&lt;1 || tx&gt;n - 1 || ty&lt;1 || ty&gt;m - 1)//是否越界
					continue;
				for (j = link[hard].x - 1; j &gt;= tx; j--)//判断是否遇到障碍物
				{
					if (b[j][ty] == 1)
					{
						fl = 1;
						break;
					}
				}
			}
			if (book[tx][ty][link[hard].f] == 0 &amp;&amp; fl == 0)//如果这个点的这个方向第一次遇到且到这个点期间没有遇到障碍物
			{
				//入队操作+标记
				link[tail].x = tx;
				link[tail].y = ty;
				link[tail].s = link[hard].s + 1;
				link[tail].f = link[hard].f;
				book[tx][ty][link[tail].f] = 1;
				tail++;
				if (tx == p &amp;&amp; ty == q)//如果找到出口标记并提前结束
				{
					flag = 1;
					break;
				}
			}
		}
		hard++;//一个点广搜完，判断下一个点
		if (flag == 1)//找到出口，提前结束
			break;
	}
	if (flag == 1)//找到输出最短时间
		printf("%d", link[tail - 1].s);
	else//没找到输出-1
		printf("-1");
	return 0;
}
</code></pre> 
<p></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/f326a97244c0932727a37300f54091c3/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">C&#43;&#43;&amp;Python&amp;C# 三语言OpenCV从零开发(6):边界填充&#43;Csharp调用Python matplotlib代码</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/4370d96cc981547d2d9689879fe9f1f9/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">2024最新Windows版本的Redis安装包和工具</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>