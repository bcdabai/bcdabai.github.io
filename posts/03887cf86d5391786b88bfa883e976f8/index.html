<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>python的面向对象基础 - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="python的面向对象基础" />
<meta property="og:description" content="python的面向对象基础
1.类和对象基础 类具有抽象性、封装性和多态性。 类的抽象性：类是对具有共同方法和属性的一类对象的描述。类的封装性：类将属性和方法封装，外部都是不可见的，只有通过类提供的接口才能与属于类的实例对象进行信息交换。类的继承性：类可以从已有的类派生。派生出的类具有父类的方法和属性。类的多态性：类可以根据不同的参数类型调用不同的方法。同一个方法可以处理不同类型的参数。实际上，python的内部已实现了多态，在python中，使用类不需要考虑太多不同类型之间数据的处理问题。 2.python中类使用 2.1属性和方法 类的属性=类内部的变量 类的方法=类内部定义的函数 类内部的属性若以双下划线开始，则其为类的私有属性，不能在类的外部被使用或者访问。 在类内部使用def可以为类定义一个方法，与函数定义不同的是，类的方法必须包含参数self，且self必须为第一参数。 同理，类内部的方法若以双下划线开始，则其为类的私有方法。 class Book: #定义Book类 __author = &#39;&#39; #定义Book类的私有属性 __name = &#39;&#39; __page = &#39;&#39; __press = &#39;&#39; price = 0 #定义Book类的公有属性 def show(self): print(self.__author) print(self.__name) def set(self, author, name): #定义公有方法（设置其私有属性__name和__author） self.__name = name self.__author = author def __check(self, item): #定义私有方法 if item == &#39;&#39;: return 0 else: return 1 b = Book() #生成类的实例b b.set(&#39;Tom&#39;, &#39;Py Class Demo&#39;) #调用公有方法set，向其传递参数 b.show() #调用公有方法show，输出 a = Book() #生成类的实例a a." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/03887cf86d5391786b88bfa883e976f8/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2016-04-21T09:16:38+08:00" />
<meta property="article:modified_time" content="2016-04-21T09:16:38+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">python的面向对象基础</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p><span style="font-size:14px">python的面向对象基础</span></p> 
<h2><span style="font-size:32px">1.类和对象基础</span></h2> 
<div> 
 <span style="font-size:14px">类具有抽象性、封装性和多态性。</span> 
</div> 
<div> 
 <ul><li><span style="font-size:14px">类的抽象性：类是对具有共同方法和属性的一类对象的描述。</span></li><li><span style="font-size:14px">类的封装性：类将属性和方法封装，外部都是不可见的，只有通过类提供的接口才能与属于类的实例对象进行信息交换。</span></li><li><span style="font-size:14px">类的继承性：类可以从已有的类派生。派生出的类具有父类的方法和属性。</span></li><li><span style="font-size:14px">类的多态性：类可以根据不同的参数类型调用不同的方法。同一个方法可以处理不同类型的参数。实际上，python的内部已实现了多态，在python中，使用类不需要考虑太多不同类型之间数据的处理问题。</span></li></ul> 
 <div> 
  <br> 
 </div> 
</div> 
<h3><br> </h3> 
<h2><span style="font-size:32px">2.python中类使用</span></h2> 
<h3><span style="font-size:18px">2.1属性和方法</span></h3> 
<div> 
 <span style="font-size:14px"></span> 
 <div>
   类的属性=类内部的变量 
 </div> 
 <div>
   类的方法=类内部定义的函数 
 </div> 
</div> 
<div> 
 <span style="font-size:14px">类内部的属性若以双下划线开始，则其为类的私有属性，不能在类的外部被使用或者访问。</span> 
</div> 
<div> 
 <span style="font-size:14px">在类内部使用def可以为类定义一个方法，与函数定义不同的是，类的方法必须包含参数self，且self必须为第一参数。</span> 
</div> 
<div> 
 <span style="font-size:14px">同理，类内部的方法若以双下划线开始，则其为类的私有方法。</span> 
</div> 
<div> 
 <span style="font-size:14px"></span> 
 <pre><code class="language-python">class Book:          #定义Book类
    __author = ''    #定义Book类的私有属性
    __name = ''
    __page = ''
    __press = ''
    price = 0        #定义Book类的公有属性
    def show(self):               
        print(self.__author)
        print(self.__name)
    def set(self, author, name):  #定义公有方法（设置其私有属性__name和__author）
        self.__name = name
        self.__author = author
    def __check(self, item):      #定义私有方法
        if item == '':
            return 0
        else:
            return 1

b = Book()                       #生成类的实例b
b.set('Tom', 'Py Class Demo')    #调用公有方法set，向其传递参数
b.show()                         #调用公有方法show，输出
a = Book()                       #生成类的实例a
a.__check()                      #调用私有方法__check()，将会报错</code></pre>输出： 
 <br> Tom 
 <br> Py Class Demo 
 <br>     a.__check() 
 <br> AttributeError: 'Book' object has no attribute '__check' 
 <br> 
</div> 
<div> 
 <span style="font-size:14px"><br> </span> 
</div> 
<div> 
 <h3><span style="font-size:18px">2.2类的专有方法</span></h3> 
 <div> 
  <table border="1" width="200" cellspacing="1" cellpadding="1" style="text-align:center"><tbody><tr><th><span style="font-size:14px">方法名</span></th><th><span style="font-size:14px">描述</span></th></tr></tbody><tbody><tr><td><span style="font-size:14px">__init__</span></td><td><span style="font-size:14px">构造函数</span></td></tr><tr><td><span style="font-size:14px">__del__</span></td><td><span style="font-size:14px">析构函数</span></td></tr><tr><td><span style="font-size:14px">__add__</span></td><td><span style="font-size:14px">加运算</span></td></tr><tr><td><span style="font-size:14px">__mul__</span></td><td><span style="font-size:14px">乘运算</span></td></tr><tr><td><span style="font-size:14px">__cmp__</span></td><td><span style="font-size:14px">比较运算</span></td></tr><tr><td><span style="font-size:14px">__len__</span></td><td><span style="font-size:14px">获得长度</span></td></tr><tr><td><span style="font-size:14px">__repr__</span></td><td><span style="font-size:14px">打印/转换</span></td></tr><tr><td><span style="font-size:14px">__call__</span></td><td><span style="font-size:14px">函数调用</span></td></tr><tr><td><span style="font-size:14px">__setitem__</span></td><td><span style="font-size:14px">按索引赋值</span></td></tr><tr><td><span style="font-size:14px">__getitem__</span></td><td><span style="font-size:14px">按索引取值</span></td></tr></tbody></table> 
 </div> 
 <div style="text-align:left"> 
  <br> 
 </div> 
 <div style="text-align:left"> 
  <span style="font-size:18px">python<span style="font-size:14px">的专有方法是对类进行操作的特殊方法。例如在类实例化时，将调用__init__方法。</span></span> 
 </div> 
 <div style="text-align:left"> 
  <span style="font-size:18px"><span style="font-size:14px"></span></span> 
  <pre><code class="language-python">class Book:
    __author = ''
    __name = ''
    __page = ''
    __press = ''
    price = 0
    def __init__(self, author, name): #调用__init__方法，在生成实例时，为__author和__name赋初值
        self.__name = name
        self.__author = author
    def show(self):
        print(self.__author)
        print(self.__name)
    def set(self, author, name):
        self.__name = name
        self.__author = author
    def __check(self, item):
        if item == '':
            return 0
        else:
            return 1


a = Book('Alice', 'Demo of Python Class')  #实例化a,并赋予初值
a.show()
a.set('Bob', 'Changed the Name ')          #调用set方法，重设私有属性_author和__name
a.show()</code></pre> 
  <span style="font-size:14px">输出：</span> 
 </div> 
 <div style="text-align:left"> 
  <span style="font-size:18px"><span style="font-size:14px">Alice<br> Demo of Python Class<br> Bob<br> Changed the Name <br> <br> </span></span> 
 </div> 
 <div style="text-align:left"> 
  <span style="font-size:14px"></span> 
  <h3>2.3类的继承</h3> 
 </div> 
 <div style="text-align:left"> 
  <span style="font-size:14px">新类可以继承父类的公有属性和公有方法，但是不能继承父类的私有属性和私有方法</span> 
 </div> 
 <div style="text-align:left"> 
  <span style="font-size:14px"></span> 
  <pre><code class="language-python">class Book:
    __author = ''
    __name = ''
    __page = ''
    __press = ''
    price = 0
    def __init__(self, author, name): 
        self.__name = name
        self.__author = author
    def show(self):
        print(self.__author)
        print(self.__name)
    def set(self, author, name):
        self.__name = name
        self.__author = author
    def __check(self, item):
        if item == '':
            return 0
        else:
            return 1

class student(Book):                      #创建student类，它继承父类Book
    __class = ''
    __grade = ''
    __sname = ''
    def ShowStudent(self):
        self.show()

cc = student('Jack', 'Name attribute From Class Book') #实例化cc，student类继承了父类Book的__init__方法
cc.ShowStudent()                                       #调用student类的ShowStudent方法，输出
cc.show()                                              #调用父类的show方法，输出</code></pre> 
  <div style="text-align:left"> 
   <span style="font-size:14px">输出：</span> 
  </div> 
  <div style="text-align:left"> 
   <span style="font-size:14px">Jack<br> Name attribute From Class Book<br> Jack<br> Name attribute From Class Book<br> </span> 
  </div> 
  <div style="text-align:left"> 
   <span style="font-size:14px"><br> </span> 
  </div> 
  <h3>2.4在类中重载方法</h3> 通过继承而创建的类，其父类的方法不一定能满足类的需求。新类实际上只需修改部分功能，为了避免重新命名方法，可以用重载来解决。例如，新的类需要重新初始化，此时就可以通过重载__init__方法来实现。 
 </div> 
 <div style="text-align:left"> 
  <span style="font-size:14px">如果重载父类的方法，但又要在类中先使用父类的该方法，则可以使用父类名+'.'+方法名的形式调用。</span> 
 </div> 
 <div style="text-align:left"> 
  <span style="font-size:14px"></span> 
  <pre><code class="language-python">class human:     #定义父类human
    __age = 0
    __sex = ''
    __height = ''
    __weight = ''
    __name = ''
    def __init__(self, age, sex, height, weight):
        self.__age = age
        self.__sex = sex
        self.__height = height
        self.__weight = weight
    def setname(self, name):
        self.__name = name
    def show(self):
        print(self.__name)
        print(self.__age)
        print(self.__sex)
        print(self.__height)
        print(self.__weight)


class student(human):    #定义student类，继承human
    __classes = ''
    __grade = ''
    __num = ''
    #重载__init__方法
    def __init__(self, classes, grade, num, age, sex, height, weight):
        #调用父类human的__init__方法，初始化human类的属性
        human.__init__(self, age, sex, height, weight)
        self.__classes = classes
        self.__grade = grade
        self.__num = num
    #重载show方法
    def show(self):
        #调用父类human的show方法
        human.show(self)
        print(self.__classes)
        print(self.__grade)
        print(self.__num)



a = student('3班', '7年级', 'NO.0712', 19, 'male', 180, 70)  #生成student类的实例a
a.setname('David')                                #调用父类human的setname方法
a.show()                                          #调用重载后的show方法，输出</code></pre> 
 </div> 
 <div style="text-align:left"> 
  <span style="font-size:14px">输出：</span> 
 </div> 
 <div style="text-align:left"> 
  <span style="font-size:14px">David<br> 19<br> male<br> 180<br> 70<br> 3班<br> 7年级<br> NO.0712<br> </span> 
 </div> 
 <div style="text-align:left"> 
  <span style="font-size:14px"><br> </span> 
 </div> 
 <div style="text-align:left"> 
  <span style="font-size:14px">参考文献</span> 
 </div> 
 <div style="text-align:left"> 
  <span style="font-size:14px">杨佩鹿等著.python宝典[M]. 电子工业出版社, 2014<br> </span> 
 </div> 
 <div style="text-align:center"> 
  <span style="font-size:14px"><br> </span> 
 </div> 
</div> 
<div style="text-align:center"> 
 <br> 
</div>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/4cca10aea51b8b60e685123fa4c54e24/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">指针</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/0bf3fadad541772c584d0a426bbb329e/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">iOS 中各种折线.曲线.图形绘制方法集锦(折线图.走势图.柱状图.动态曲线图.形状图.划线图)</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>