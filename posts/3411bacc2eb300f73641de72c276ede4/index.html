<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>C#使用Protocol Buffer(ProtoBuf)进行对象的序列化与反序列化 - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="C#使用Protocol Buffer(ProtoBuf)进行对象的序列化与反序列化" />
<meta property="og:description" content="Protocol Buffer是Google开发的数据格式,也是除了XML和JSON之外人气第三高的^^需要的朋友可以参考下
首先来说一下本文中例子所要实现的功能：
基于ProtoBuf序列化对象 下面来看具体的步骤：
Unity中使用ProtoBuf
导入DLL到Unity中，
创建网络传输的模型类：
using System; using ProtoBuf; //添加特性，表示可以被ProtoBuf工具序列化 [ProtoContract] public class NetModel { //添加特性，表示该字段可以被序列化，1可以理解为下标 [ProtoMember(1)] public int ID; [ProtoMember(2)] public string Commit; [ProtoMember(3)] public string Message; } using ProtoBuf;的引用需要使用protobuf-net.dll动态链接库文件 将这个DLL文件放入Plugins文件夹下就行
整个示例代码如下：
using UnityEngine; using System; using ProtoBuf; using System.IO; using System.Collections; //添加特性，表示可以被ProtoBuf工具序列化 [ProtoContract] public class NetModel { //添加特性，表示该字段可以被序列化，1可以理解为下标 [ProtoMember(1)] public int ID; [ProtoMember(2)] public string Commit; [ProtoMember(3)] public string Message; } public class ProtocolBuffer : MonoBehaviour { // Use this for initialization void Start () { Test (); } void Test() { //创建对象 NetModel item = new NetModel(){ID = 1, Commit = &#34;" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/3411bacc2eb300f73641de72c276ede4/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2016-10-13T14:46:54+08:00" />
<meta property="article:modified_time" content="2016-10-13T14:46:54+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">C#使用Protocol Buffer(ProtoBuf)进行对象的序列化与反序列化</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p>Protocol Buffer是Google开发的数据格式,也是除了XML和JSON之外人气第三高的^^需要的朋友可以参考下</p> 
<p><br> </p> 
<p></p> 
<p>首先来说一下本文中例子所要实现的功能：</p> 
<ul><li>基于ProtoBuf序列化对象</li></ul> 
<p>下面来看具体的步骤：</p> 
<p><strong>Unity中使用ProtoBuf</strong></p> 
<p>导入DLL到Unity中，<br> 创建网络传输的模型类：</p> 
<p></p> 
<pre><code class="language-csharp">using System;
using ProtoBuf;
 
//添加特性，表示可以被ProtoBuf工具序列化
[ProtoContract]
public class NetModel {
 //添加特性，表示该字段可以被序列化，1可以理解为下标
 [ProtoMember(1)] 
 public int ID;
 [ProtoMember(2)]
 public string Commit;
 [ProtoMember(3)]
 public string Message;
}
</code></pre>using ProtoBuf;的引用需要使用protobuf-net.dll动态链接库文件 
<p></p> 
<p>将这个DLL文件放入Plugins文件夹下就行</p> 
<p>整个示例代码如下：</p> 
<p></p> 
<pre><code class="language-csharp">using UnityEngine;
using System;
using ProtoBuf;
using System.IO;
using System.Collections;

//添加特性，表示可以被ProtoBuf工具序列化
[ProtoContract]
public class NetModel {
	//添加特性，表示该字段可以被序列化，1可以理解为下标
	[ProtoMember(1)] 
	public int ID;
	[ProtoMember(2)]
	public string Commit;
	[ProtoMember(3)]
	public string Message;
}


public class ProtocolBuffer : MonoBehaviour {

	// Use this for initialization
	void Start () {
		Test ();
	}

	void Test()
	{
		//创建对象
		NetModel item = new NetModel(){ID = 1, Commit = "LanOu", Message = "Unity"};
		//序列化对象
		byte[] temp = Serialize(item);
		//ProtoBuf的优势一：小
		Debug.Log(temp.Length);
		//反序列化为对象
		NetModel result = DeSerialize(temp);
		Debug.Log(result.Message);
	}

	// 将消息序列化为二进制的方法
	// &lt; param name="model"&gt;要序列化的对象&lt; /param&gt;
	private byte[] Serialize(NetModel model)
	{
		try {
			//涉及格式转换，需要用到流，将二进制序列化到流中
			using (MemoryStream ms = new MemoryStream()) {
				//使用ProtoBuf工具的序列化方法
				ProtoBuf.Serializer.Serialize&lt;NetModel&gt; (ms, model);
				//定义二级制数组，保存序列化后的结果
				byte[] result = new byte[ms.Length];
				//将流的位置设为0，起始点
				ms.Position = 0;
				//将流中的内容读取到二进制数组中
				ms.Read (result, 0, result.Length);
				return result;
			}
		} catch (Exception ex) {
			Debug.Log ("序列化失败: " + ex.ToString());
			return null;
		}
	}

	// 将收到的消息反序列化成对象
	// &lt; returns&gt;The serialize.&lt; /returns&gt;
	// &lt; param name="msg"&gt;收到的消息.&lt;/param&gt;
	private NetModel DeSerialize(byte[] msg)
	{
		try {
			using (MemoryStream ms = new MemoryStream()) {
				//将消息写入流中
				ms.Write (msg, 0, msg.Length);
				//将流的位置归0
				ms.Position = 0;
				//使用工具反序列化对象
				NetModel result = ProtoBuf.Serializer.Deserialize&lt;NetModel&gt; (ms);
				return result;
			}
		} catch (Exception ex) {  
			Debug.Log("反序列化失败: " + ex.ToString());
			return null;
		}
	}
}


</code></pre> 
<br> 
<br> 
<br> 
<p></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/bb07b5f2a97acaec411738a53f171b53/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">sigmoid和softmax总结</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/ae6fb27903f8f0592e077b1c4ed24330/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">applicationContext.xml文件配置小结（1）</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>