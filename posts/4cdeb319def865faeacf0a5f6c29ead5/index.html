<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>jwt单点登录 - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="jwt单点登录" />
<meta property="og:description" content="一、前言 在我们日常开发中登录是每个系统都要做的，对于单点登录是在多个应用系统中，用户只需要登录一次就可以访问所有相互信任的应用系统。
开一下传统登录：
单点登录：
通俗讲：用户登录一次，就可已访问系统里的其他子系统。 二、JWT是什么 1.JWT的概况 通俗讲：就是一种生存字符串的规则叫JWT。JWT是JSON WEB TOKEN的缩写，它是基于 RFC 7519 标准定义的一种可以安全传输的的JSON对象，由于使用了数字签名，所以是可信任和安全的。
Token（令牌）属于无状态，因每个人制定的规则不同，生成的结果也不同。目前，多数人采用JWT为统一令牌标准，之后我也采用JWT作为token生成标准。
2.JWT的组成 jwt实例可以在该网站上获得解析结果：JSON Web Tokens - jwt.io
组成： 该对象为一个很长的字符串，字符之间通过&#34;.&#34;分隔符分为三个子串。
每一个子串表示了一个功能块，总共有以下三个部分：JWT头、有效载荷和签名
JWT头:
JWT头部分是一个描述JWT元数据的JSON对象，通常如下所示。
{ &#34;alg&#34;: &#34;HS256&#34;, &#34;typ&#34;: &#34;JWT&#34; } 在上面的代码中，
alg属性表示签名使用的算法，默认为HMAC SHA256（写为HS256）；
typ属性表示令牌的类型，JWT令牌统一写为JWT。
最后，使用Base64 URL算法将上述JSON对象转换为字符串保存。
有效载荷【用户信息】:
(通俗的讲就是用户信息)有效载荷部分，是JWT的主体内容部分，也是一个JSON对象，包含需要传递的数据。 JWT指定七个默认字段供选择
iss：发行人 exp：到期时间 sub：主题 aud：用户 nbf：在此之前不可用 iat：发布时间 jti：JWT ID用于标识该JWT 上默认字段外，我们还可以自定义私有字段，如下例：
{ &#34;userId&#34;: &#34;1234567890&#34;, &#34;name&#34;: &#34;zhangsan&#34;, &#34;admin&#34;: true } 请注意，默认情况下JWT是未加密的，任何人都可以解读其内容，因此不要构建隐私信息字段，存放保密信息，以防止信息泄露。
JSON对象也使用Base64 URL算法转换为字符串保存。
签名哈希【防伪标志】:
签名哈希部分是对上面两部分数据签名，通过指定的算法生成哈希，以确保数据不会被篡改。
首先，需要指定一个密码（secret）。该密码仅仅为保存在服务器中，并且不能向用户公开。然后，使用标头中指定的签名算法（默认情况下为HMAC SHA256）根据以下公式生成签名。
HMACSHA256(base64UrlEncode(header) &#43; &#34;.&#34; &#43; base64UrlEncode(claims), secret) Base64URL算法：" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/4cdeb319def865faeacf0a5f6c29ead5/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-11-20T18:05:58+08:00" />
<meta property="article:modified_time" content="2023-11-20T18:05:58+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">jwt单点登录</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <h3> 一、前言</h3> 
<p>在我们日常开发中登录是每个系统都要做的，对于单点登录是在多个应用系统中，用户只需要登录一次就可以访问所有相互信任的应用系统。</p> 
<p>开一下传统登录：</p> 
<p><img alt="" height="726" src="https://images2.imgbox.com/80/4b/Cx2a6cs1_o.png" width="1132"></p> 
<p>单点登录：</p> 
<p><img alt="" height="480" src="https://images2.imgbox.com/63/50/cnHdMSZ5_o.png" width="1116"> </p> 
<p>通俗讲：用户登录一次，就可已访问系统里的其他子系统。 </p> 
<h3>二、JWT是什么</h3> 
<h4><br> 1.JWT的概况</h4> 
<p><br> 通俗讲：就是一种生存字符串的规则叫JWT。JWT是JSON WEB TOKEN的缩写，它是基于 RFC 7519 标准定义的一种可以安全传输的的JSON对象，由于使用了数字签名，所以是可信任和安全的。</p> 
<p> Token（令牌）属于无状态，因每个人制定的规则不同，生成的结果也不同。目前，多数人采用JWT为统一令牌标准，之后我也采用JWT作为token生成标准。</p> 
<h4>2.JWT的组成</h4> 
<p><br> jwt实例可以在该网站上获得解析结果：JSON Web Tokens - jwt.io</p> 
<p>组成： </p> 
<p><img alt="" height="469" src="https://images2.imgbox.com/28/3d/ni2YKYKK_o.png" width="1200"></p> 
<p><img alt="" height="822" src="https://images2.imgbox.com/58/74/wrDBXU5z_o.png" width="1200"></p> 
<p> 该对象为一个很长的字符串，字符之间通过<code>"."</code>分隔符分为三个子串。</p> 
<p> 每一个子串表示了一个功能块，总共有以下三个部分：<strong><code>JWT头</code></strong>、<strong><code>有效载荷</code></strong>和<strong><code>签名</code></strong></p> 
<p><strong>JWT头:</strong></p> 
<p>JWT头部分是一个描述JWT元数据的JSON对象，通常如下所示。</p> 
<pre><code class="hljs">{
    "alg": "HS256",
    "typ": "JWT"
}</code></pre> 
<p> </p> 
<p>在上面的代码中，</p> 
<p>alg属性表示签名使用的算法，默认为HMAC SHA256（写为HS256）；</p> 
<p>typ属性表示令牌的类型，JWT令牌统一写为JWT。</p> 
<p>最后，使用Base64 URL算法将上述JSON对象转换为字符串保存。</p> 
<p>有效载荷【用户信息】:</p> 
<p>(通俗的讲就是用户信息)有效载荷部分，是JWT的主体内容部分，也是一个JSON对象，包含需要传递的数据。 JWT指定七个默认字段供选择</p> 
<pre><code class="hljs">iss：发行人
exp：到期时间
sub：主题
aud：用户
nbf：在此之前不可用
iat：发布时间
jti：JWT ID用于标识该JWT</code></pre> 
<p>上默认字段外，我们还可以自定义私有字段，如下例：</p> 
<pre><code class="hljs">{
    "userId": "1234567890",
    "name": "zhangsan",
    "admin": true
}</code></pre> 
<p> </p> 
<p>请注意，默认情况下JWT是未加密的，任何人都可以解读其内容，因此不要构建隐私信息字段，存放保密信息，以防止信息泄露。</p> 
<p>JSON对象也使用Base64 URL算法转换为字符串保存。</p> 
<p>签名哈希【防伪标志】:</p> 
<p>签名哈希部分是对上面两部分数据签名，通过指定的算法生成哈希，以确保数据不会被篡改。</p> 
<p>首先，需要指定一个密码（secret）。该密码仅仅为保存在服务器中，并且不能向用户公开。然后，使用标头中指定的签名算法（默认情况下为HMAC SHA256）根据以下公式生成签名。<br>  </p> 
<pre><code class="hljs">HMACSHA256(base64UrlEncode(header) + "." + base64UrlEncode(claims), secret)
</code></pre> 
<p>Base64URL算法：<br> 如前所述，JWT头和有效载荷序列化的算法都用到了Base64URL。该算法和常见Base64算法类似，稍有差别。 作为令牌的JWT可以放在URL中（例如api.example/?token=xxx）。 Base64中用的三个字符是"+"，"/“和”="，由于在URL中有特殊含义，因此Base64URL中对他们做了替换："=“去掉，”+“用”-“替换，”/“用”_"替换，这就是Base64URL算法。</p> 
<h4>3.JWT的用法</h4> 
<p><br> 客户端接收服务器返回的JWT，将其存储在Cookie或localStorage中。</p> 
<p>此后，客户端将在与服务器交互中都会带JWT。如果将它存储在Cookie中，就可以自动发送，但是不会跨域，因此一般是将它放入HTTP请求的Header Authorization字段中。当跨域时，也可以将JWT被放置于POST请求的数据主体中。</p> 
<h4>4.JWT优缺点</h4> 
<ul><li>JWT不仅可用于认证，还可用于信息交换。善用JWT有助于减少服务器请求数据库的次数。</li><li>生产的token可以包含基本信息，比如id、用户昵称、头像等信息，避免再次查库</li><li>存储在客户端，不占用服务端的内存资源</li><li>JWT默认不加密，但可以加密。生成原始令牌后，可以再次对其进行加密。</li><li>当JWT未加密时，一些私密数据无法通过JWT传输。</li><li>JWT的最大缺点是服务器不保存会话状态，所以在使用期间不可能取消令牌或更改令牌的权限。也就是说，一旦JWT签发，在有效期内将会一直有效。</li><li>JWT本身包含认证信息，token是经过base64编码，所以可以解码，因此token加密前的对象不应该包含敏感信息，一旦信息泄露，任何人都可以获得令牌的所有权限。为了减少盗用，JWT的有效期不宜设置太长。对于某些重要操作，用户在使用时应该每次都进行进行身份验证。</li></ul> 
<p>为了减少盗用和窃取，JWT不建议使用HTTP协议来传输代码，而是使用加密的HTTPS协议进行传输。</p> 
<h3 id="%E5%9B%9B%E3%80%81Token%E5%AE%9E%E7%8E%B0%E5%8D%95%E7%82%B9%E7%99%BB%E5%BD%95%EF%BC%88%E4%BB%A3%E7%A0%81%EF%BC%89">三、Token实现单点登录（代码）</h3> 
<h4 id="1.%E6%B7%BB%E5%8A%A0JWT%E4%BE%9D%E8%B5%96%E4%B8%8EJWT%E5%B7%A5%E5%85%B7%E7%B1%BB"><a name="t15"></a>1.添加JWT依赖与<a href="https://so.csdn.net/so/search?q=JWT%E5%B7%A5%E5%85%B7%E7%B1%BB&amp;spm=1001.2101.3001.7020" title="JWT工具类">JWT工具类</a></h4> 
<p>依赖：</p> 
<pre><code class="hljs">       &lt;!--  jwt依赖    --&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;io.jsonwebtoken&lt;/groupId&gt;
            &lt;artifactId&gt;jjwt&lt;/artifactId&gt;
            &lt;version&gt;0.9.1&lt;/version&gt;
        &lt;/dependency&gt;</code></pre> 
<p>jwt工具类:</p> 
<pre><code class="hljs">public class JwtUtils {
 
    //token过期时间
    public static final long EXPIRE = 1000 * 60 * 60 * 24;
 
    //秘钥，每个公司生成规则不一样
    public static final String APP_SECRET = "rikka六花";
 
    //生成token字符串方法,参数根据自己实际要求指定
    public static String getJwtToken(String id, String nickname) {
        String JwtToken = Jwts.builder()
                //设置jwt头信息，红色部分，内容固定，不需要改
                .setHeaderParam("typ", "JWT")
                .setHeaderParam("alg", "HS256")
 
                .setSubject("guli-user")//设置主题（可选）
                .setIssuedAt(new Date())//设置发布时间（可选）
                .setExpiration(new Date(System.currentTimeMillis() + EXPIRE))//设置过期时间
 
                //设置token主体部分，存储用户信息，可设置多个值
                .claim("id", id)
                .claim("nickname", nickname)
 
                //设置签名哈希（防伪标志）
                .signWith(SignatureAlgorithm.HS256, APP_SECRET)
                .compact();
 
        return JwtToken;
    }
 
    /**
     * 判断token是否存在与有效
     *
     * @param jwtToken
     * @return
     */
    public static boolean checkToken(String jwtToken) {
        if (StringUtils.isEmpty(jwtToken)) return false;
        try {
            //根据设置的防伪码解析token
            Jwts.parser().setSigningKey(APP_SECRET).parseClaimsJws(jwtToken);
        } catch (Exception e) {
            e.printStackTrace();
            return false;
        }
        return true;
    }
 
    /**
     * 判断token是否存在与有效
     *
     * @param request
     * @return
     */
    public static boolean checkToken(HttpServletRequest request) {
        try {
            String jwtToken = request.getHeader("token");
            if (StringUtils.isEmpty(jwtToken)) return false;
            //根据设置的防伪码解析token
            Jwts.parser().setSigningKey(APP_SECRET).parseClaimsJws(jwtToken);
        } catch (Exception e) {
            e.printStackTrace();
            return false;
        }
        return true;
    }
 
    /**
     * 根据token获取id
     *
     * @param request
     * @return
     */
    public static String getMemberIdByJwtToken(HttpServletRequest request) {
        String jwtToken = request.getHeader("token");
        if (StringUtils.isEmpty(jwtToken)) return "";
        //根据设置的防伪码解析token，获取对象
        Jws&lt;Claims&gt; claimsJws =
                Jwts.parser().setSigningKey(APP_SECRET).parseClaimsJws(jwtToken);
        //获取token有效载荷【用户信息】
        Claims claims = claimsJws.getBody();
        return (String) claims.get("id");
    }
 
 
}</code></pre> 
<h4 id="2.%E7%BC%96%E5%86%99%E7%99%BB%E5%BD%95%E6%96%B9%E6%B3%95">2.编写登录方法</h4> 
<pre><code class="hljs">    @Override
    public String login(LoginVo loginVo) {
        //写你自己的具体登录逻辑：
        //1.判断参数是否为空
        ...
        //2.判断数据库是否存在该用户
        ...
        //3.判断加密后的密码参数和数据库是否一致
        ...
        //4.判断用户是否禁用
        ...
        //5.生成jwt令牌返回给前端
        return JwtUtils.getJwtToken(ucenterMember.getId(), ucenterMember.getNickname());
    }</code></pre> 
<p> 将JWT返回给前端，前端选择将令牌存入cookie或放进地址栏。之后每次都带着JWT发送请求，因为JWT有效载荷里存有id，所以下次后端可根据id查找对应用户信息返回。可根据是否有token判断是否登录，所以单点登录就实现了。 </p> 
<p></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/3e8acea24ff8401fccf2679dca9008d3/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">QProcess：在QT中调用外部程序（也是QT写的程序）（1）</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/ab3c6a6f37d874a6ea8b8cdb738900c5/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">北京讯为电子RK3568开发板Android11系统移植笔记</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>