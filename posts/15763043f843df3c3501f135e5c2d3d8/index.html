<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>K8S群集调度 - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="K8S群集调度" />
<meta property="og:description" content="目录 一、调度约束二、Pod 启动典型创建过程三、K8S的调度过程3.1 Predicate（预选策略） 常见的算法使用3.2 常见优先级选项3.3 指定调度节点3.3.1 nodeName指定3.3.2 nodeSelector指定3.3.3 Pod亲和性与反亲和1.节点亲和硬策略示例2.节点亲和软策略示例3.硬限制和软限制结合使用4.使用 Pod 亲和性调度，创建多个 Pod 资源5.反亲和的硬策略6.反亲和的软策略 3.3.4 污点(Taint)1. 打上污点2. 删除污点 3.3.5 容忍(Tolerations)3.3.6 其它注意事项3.3.7 cordon 和 drain 对节点执行维护操作 3.4 Pod启动阶段（相位 phase）3.4.1 phase 的可能状态3.4.2 如何删除 Unknown 状态的 Pod3.4.3 故障排除步骤 四、总结4.1 亲和性4.2 污点4.3 容忍4.4 不可调度4.5 Pod 生命周期的 5 种状态4.6 排障手段 一、调度约束 Kubernetes 是通过 List-Watch 的机制进行每个组件的协作，保持数据同步的，每个组件之间的设计实现了解耦。
用户是通过 kubectl 根据配置文件，向 APIServer 发送命令，在 Node 节点上面建立 Pod 和 Container。
APIServer 经过 API 调用，权限控制，调用资源和存储资源的过程，实际上还没有真正开始部署应用。这里 需要 Controller Manager、Scheduler 和 kubelet 的协助才能完成整个部署过程。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/15763043f843df3c3501f135e5c2d3d8/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-07-31T20:37:29+08:00" />
<meta property="article:modified_time" content="2023-07-31T20:37:29+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">K8S群集调度</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p></p> 
<div class="toc"> 
 <h4>目录</h4> 
 <ul><li><a href="#_7" rel="nofollow">一、调度约束</a></li><li><a href="#Pod__15" rel="nofollow">二、Pod 启动典型创建过程</a></li><li><a href="#K8S_67" rel="nofollow">三、K8S的调度过程</a></li><li><ul><li><a href="#31_Predicate__80" rel="nofollow">3.1 Predicate（预选策略） 常见的算法使用</a></li><li><a href="#32__88" rel="nofollow">3.2 常见优先级选项</a></li><li><a href="#33__96" rel="nofollow">3.3 指定调度节点</a></li><li><ul><li><a href="#331_nodeName_97" rel="nofollow">3.3.1 nodeName指定</a></li><li><a href="#332_nodeSelector_124" rel="nofollow">3.3.2 nodeSelector指定</a></li><li><a href="#333_Pod_185" rel="nofollow">3.3.3 Pod亲和性与反亲和</a></li><li><ul><li><a href="#1_215" rel="nofollow">1.节点亲和硬策略示例</a></li><li><a href="#2_259" rel="nofollow">2.节点亲和软策略示例</a></li><li><a href="#3_289" rel="nofollow">3.硬限制和软限制结合使用</a></li><li><a href="#4_Pod__Pod__368" rel="nofollow">4.使用 Pod 亲和性调度，创建多个 Pod 资源</a></li><li><a href="#5_514" rel="nofollow">5.反亲和的硬策略</a></li><li><a href="#6_580" rel="nofollow">6.反亲和的软策略</a></li></ul> 
    </li><li><a href="#334_Taint_620" rel="nofollow">3.3.4 污点(Taint)</a></li><li><ul><li><a href="#1__653" rel="nofollow">1. 打上污点</a></li><li><a href="#2__704" rel="nofollow">2. 删除污点</a></li></ul> 
    </li><li><a href="#335_Tolerations_727" rel="nofollow">3.3.5 容忍(Tolerations)</a></li><li><a href="#336__843" rel="nofollow">3.3.6 其它注意事项</a></li><li><a href="#337_cordon__drain__884" rel="nofollow">3.3.7 cordon 和 drain 对节点执行维护操作</a></li></ul> 
   </li><li><a href="#34_Pod_phase_991" rel="nofollow">3.4 Pod启动阶段（相位 phase）</a></li><li><ul><li><a href="#341_phase__999" rel="nofollow">3.4.1 phase 的可能状态</a></li><li><a href="#342__Unknown__Pod_1010" rel="nofollow">3.4.2 如何删除 Unknown 状态的 Pod</a></li><li><a href="#343__1018" rel="nofollow">3.4.3 故障排除步骤</a></li></ul> 
  </li></ul> 
  </li><li><a href="#_1054" rel="nofollow">四、总结</a></li><li><ul><li><a href="#41__1055" rel="nofollow">4.1 亲和性</a></li><li><a href="#42__1072" rel="nofollow">4.2 污点</a></li><li><a href="#43__1085" rel="nofollow">4.3 容忍</a></li><li><a href="#44__1096" rel="nofollow">4.4 不可调度</a></li><li><a href="#45_Pod__5__1109" rel="nofollow">4.5 Pod 生命周期的 5 种状态</a></li><li><a href="#46__1123" rel="nofollow">4.6 排障手段</a></li></ul> 
 </li></ul> 
</div> 
<p></p> 
<hr> 
<h2><a id="_7"></a>一、调度约束</h2> 
<p>Kubernetes 是通过 List-Watch 的机制进行每个组件的协作，保持数据同步的，每个组件之间的设计实现了解耦。</p> 
<p>用户是通过 kubectl 根据配置文件，向 APIServer 发送命令，在 Node 节点上面建立 Pod 和 Container。<br> APIServer 经过 API 调用，权限控制，调用资源和存储资源的过程，实际上还没有真正开始部署应用。这里 需要 Controller Manager、Scheduler 和 kubelet 的协助才能完成整个部署过程。</p> 
<p>在 Kubernetes 中，所有部署的信息都会写到 etcd 中保存。实际上 etcd 在存储部署信息的时候，会发送 Create 事件给 APIServer，而 APIServer 会通过监听（Watch）etcd 发过来的事件。其他组件也会监听（Watch）APIServer 发出来的事件。</p> 
<h2><a id="Pod__15"></a>二、Pod 启动典型创建过程</h2> 
<p>（1）这里有三个 List-Watch，分别是 Controller Manager（运行在 Master），Scheduler（运行在 Master），kubelet（运行在 Node）。 他们在进程已启动就会监听（Watch）APIServer 发出来的事件。</p> 
<p>（2）用户通过 kubectl 或其他 API 客户端提交请求给 APIServer 来建立一个 Pod 对象副本。</p> 
<p>（3）APIServer 尝试着将 Pod 对象的相关元信息存入 etcd 中，待写入操作执行完成，APIServer 即会返回确认信息至客户端。</p> 
<p>（4）当 etcd 接受创建 Pod 信息以后，会发送一个 Create 事件给 APIServer。</p> 
<p>（5）由于 Controller Manager 一直在监听（Watch，通过https的6443端口）APIServer 中的事件。此时 APIServer 接受到了 Create 事件，又会发送给 Controller Manager。</p> 
<p>（6）Controller Manager 在接到 Create 事件以后，调用其中的 Replication Controller 来保证 Node 上面需要创建的副本数量。一旦副本数量少于 RC 中定义的数量，RC 会自动创建副本。总之它是保证副本数量的 Controller（PS：扩容缩容的担当）。</p> 
<p>（7）在 Controller Manager 创建 Pod 副本以后，APIServer 会在 etcd 中记录这个 Pod 的详细信息。例如 Pod 的副本数，Container 的内容是什么。</p> 
<p>（8）同样的 etcd 会将创建 Pod 的信息通过事件发送给 APIServer。</p> 
<p>（9）由于 Scheduler 在监听（Watch）APIServer，并且它在系统中起到了“承上启下”的作用，“承上”是指它负责接收创建的 Pod 事件，为其安排 Node；“启下”是指安置工作完成后，Node 上的 kubelet 进程会接管后继工作，负责 Pod 生命周期中的“下半生”。 换句话说，Scheduler 的作用是将待调度的 Pod 按照调度算法和策略绑定到集群中 Node 上。</p> 
<p>（10）Scheduler 调度完毕以后会更新 Pod 的信息，此时的信息更加丰富了。除了知道 Pod 的副本数量，副本内容。还知道部署到哪个 Node 上面了。并将上面的 Pod 信息更新至 API Server，由 APIServer 更新至 etcd 中，保存起来。</p> 
<p>（11）etcd 将更新成功的事件发送给 APIServer，APIServer 也开始反映此 Pod 对象的调度结果。</p> 
<p>（12）kubelet 是在 Node 上面运行的进程，它也通过 List-Watch 的方式监听（Watch，通过https的6443端口）APIServer 发送的 Pod 更新的事件。kubelet 会尝试在当前节点上调用 Docker 启动容器，并将 Pod 以及容器的结果状态回送至 APIServer。</p> 
<p>（13）APIServer 将 Pod 状态信息存入 etcd 中。在 etcd 确认写入操作成功完成后，APIServer将确认信息发送至相关的 kubelet，事件将通过它被接受。</p> 
<p><strong>注意：在创建 Pod 的工作就已经完成了后，为什么 kubelet 还要一直监听呢？原因很简单，假设这个时候 kubectl 发命令，要扩充 Pod 副本数量，那么上面的流程又会触发一遍，kubelet 会根据最新的 Pod 的部署情况调整 Node 的资源。又或者 Pod 副本数量没有发生变化，但是其中的镜像文件升级了，kubelet 也会自动获取最新的镜像文件并且加载。</strong></p> 
<p><img src="https://images2.imgbox.com/5b/e4/l7tGFYkh_o.png" alt="在这里插入图片描述"><br> <strong>List-Watch 机制</strong></p> 
<p><strong>1. kubectl 将创建Pod资源对象副本的请求发送给 apiserver ，然后 apiserver 将创建Pod资源对象副本请求写入到 etcd 里</strong></p> 
<p><strong>2. etcd 写完后会发送创建完成Pod副本的 create 事件给 apiserver ，apiserver 会直接返回生命周期给客户端</strong></p> 
<p><strong>3. 再把发送创建Pod副本的事件给 controller-manager ，controller-manager 会根据相关事件创建Pod,之后把创建Pod的信息发送给 apiserver，再由 apiserver 把创建Pod的相关内容信息（如副本数量，容器内容）写入到 etcd 里</strong></p> 
<p><strong>4. etcd 会发送创建Pod的事件给 apiserver , apiserver 再把事件发送给 scheduler</strong></p> 
<p><strong>5. scheduler 会通过调度算法确定Pod创建在哪个Node节点上，确定好之后，scheduler 会把更新Pod的信息通过 apiserver 写入到etcd</strong></p> 
<p><strong>6. 然后 etcd 会发送更新Pod的事件给 apiserver，再通过apiserver 发送给监听着 apiserver 的 kubelet</strong></p> 
<p><strong>7. kubelet 就会创建容器引擎，通过交互来创建Pod及容器，并且将Pod的运行状态和容器的状态发送给apiserver</strong></p> 
<p><strong>8. apiserver 会把Pod的运行状态和容器的状态写入到etcd</strong></p> 
<p><strong>9. etcd 会返回确认信息，通过 apiserver 告诉 kubelet 该信息已写入</strong></p> 
<h2><a id="K8S_67"></a>三、K8S的调度过程</h2> 
<p>Scheduler 是 kubernetes 的调度器，主要的任务是把定义的 pod 分配到集群的节点上。其主要考虑的问题如下：<br> ●公平：如何保证每个节点都能被分配资源<br> ●资源高效利用：集群所有资源最大化被使用<br> ●效率：调度的性能要好，能够尽快地对大批量的 pod 完成调度工作<br> ●灵活：允许用户根据自己的需求控制调度的逻辑</p> 
<p><strong>Sheduler 是作为单独的程序运行的，启动之后会一直监听 APIServer，获取 spec.nodeName 为空的 pod，对每个 pod 都会创建一个 binding，表明该 pod 应该放到哪个节点上。</strong></p> 
<p><strong>调度分为几个部分：首先是过滤掉不满足条件的节点，这个过程称为预选策略（predicate）；然后对通过的节点按照优先级排序，这个是优选策略（priorities）；最后从中选择优先级最高的节点。如果中间任何一步骤有错误，就直接返回错误。</strong></p> 
<h3><a id="31_Predicate__80"></a>3.1 Predicate（预选策略） 常见的算法使用</h3> 
<p>●PodFitsResources：节点上剩余的资源是否大于 pod 请求的资源。<br> ●PodFitsHost：如果 pod 指定了 NodeName，检查节点名称是否和 NodeName 匹配。<br> ●PodFitsHostPorts：节点上已经使用的 port 是否和 pod 申请的 port 冲突。<br> ●PodSelectorMatches：过滤掉和 pod 指定的 label 不匹配的节点。<br> ●NoDiskConflict：已经 mount 的 volume 和 pod 指定的 volume 不冲突，除非它们都是只读。</p> 
<p><strong>如果在 predicate 过程中没有合适的节点，pod 会一直在 pending 状态，不断重试调度，直到有节点满足条件。 经过这个步骤，如果有多个节点满足条件，就继续 priorities 过程：按照优先级大小对节点排序。</strong></p> 
<h3><a id="32__88"></a>3.2 常见优先级选项</h3> 
<p>优先级由一系列键值对组成，键是该优先级项的名称，值是它的权重（该项的重要性）。有一系列的常见的优先级选项包括：<br> ●LeastRequestedPriority：通过计算CPU和Memory的使用率来决定权重，使用率越低权重越高。也就是说，这个优先级指标倾向于资源使用比例更低的节点。<br> ●BalancedResourceAllocation：节点上 CPU 和 Memory 使用率越接近，权重越高。这个一般和上面的一起使用，不单独使用。比如 node01 的 CPU 和 Memory 使用率 20:60，node02 的 CPU 和 Memory 使用率 50:50，虽然 node01 的总使用率比 node02 低，但 node02 的 CPU 和 Memory 使用率更接近，从而调度时会优选 node02。<br> ●ImageLocalityPriority：倾向于已经有要使用镜像的节点，镜像总大小值越大，权重越高。</p> 
<p>通过算法对所有的优先级项目和权重进行计算，得出最终的结果。</p> 
<h3><a id="33__96"></a>3.3 指定调度节点</h3> 
<h4><a id="331_nodeName_97"></a>3.3.1 nodeName指定</h4> 
<p>●pod.spec.nodeName 将 Pod 直接调度到指定的 Node 节点上，会跳过 Scheduler 的调度策略，该匹配规则是强制匹配</p> 
<pre><code class="prism language-bash">apiVersion: v1
kind: Pod
metadata:
  labels:
    run: myapp-demo4
  name: myapp-demo5
spec:
  nodeName: node02
  containers:
  - image: soscscs/myapp:v1
    name: myapp-demo4
    ports:
    - containerPort: <span class="token number">80</span>
</code></pre> 
<p><img src="https://images2.imgbox.com/84/48/Q1cCubhP_o.png" alt="在这里插入图片描述"><br> <img src="https://images2.imgbox.com/64/71/kWTQZ2VL_o.png" alt="在这里插入图片描述"></p> 
<pre><code class="prism language-bash">kubectl describe pod myapp-demo4
</code></pre> 
<p><img src="https://images2.imgbox.com/42/05/Wq7attwN_o.png" alt="在这里插入图片描述"></p> 
<h4><a id="332_nodeSelector_124"></a>3.3.2 nodeSelector指定</h4> 
<p>●pod.spec.nodeSelector：通过 kubernetes 的 label-selector 机制选择节点，由调度器调度策略匹配 label，然后调度 Pod 到目标节点，该匹配规则属于强制约束</p> 
<pre><code class="prism language-bash">//获取标签帮助
kubectl label <span class="token parameter variable">--help</span>
Usage:
  kubectl label <span class="token punctuation">[</span>--overwrite<span class="token punctuation">]</span> <span class="token punctuation">(</span>-f FILENAME <span class="token operator">|</span> TYPE NAME<span class="token punctuation">)</span> <span class="token assign-left variable">KEY_1</span><span class="token operator">=</span>VAL_1 <span class="token punctuation">..</span>. <span class="token assign-left variable">KEY_N</span><span class="token operator">=</span>VAL_N <span class="token punctuation">[</span>--resource-version<span class="token operator">=</span>version<span class="token punctuation">]</span> <span class="token punctuation">[</span>options<span class="token punctuation">]</span>
</code></pre> 
<pre><code class="prism language-bash">//先给node节点打上标签
kubectl label nodes node01 <span class="token assign-left variable">test</span><span class="token operator">=</span>a
kubectl label nodes node02 <span class="token assign-left variable">test</span><span class="token operator">=</span>b
kubectl get nodes --show-labels
</code></pre> 
<p><img src="https://images2.imgbox.com/cd/ab/QdEXgWcO_o.png" alt="在这里插入图片描述"></p> 
<pre><code class="prism language-bash">//将Pod全部调度到具有 <span class="token assign-left variable">test</span><span class="token operator">=</span>a 的节点
apiVersion: apps/v1
kind: Deployment
metadata:
  creationTimestamp: null
  labels:
    run: myapp-demo4
  name: myapp-demo6
spec:
  replicas: <span class="token number">5</span>
  selector:
    matchLabels:
      app: myapp-demo6
  strategy: <span class="token punctuation">{<!-- --></span><span class="token punctuation">}</span>
  template:
    metadata:
      creationTimestamp: null
      labels:
        app: myapp-demo6
    spec:
      <span class="token comment">#nodeName: node02</span>
      nodeSelector:
        test: a
      containers:
      - image: soscscs/myapp:v1
        name: myapp-demo4
        ports:
        - containerPort: <span class="token number">80</span>
        resources: <span class="token punctuation">{<!-- --></span><span class="token punctuation">}</span>
status: <span class="token punctuation">{<!-- --></span><span class="token punctuation">}</span>

</code></pre> 
<p><img src="https://images2.imgbox.com/d2/66/aykC3lvr_o.png" alt="在这里插入图片描述"></p> 
<p><img src="https://images2.imgbox.com/96/9b/bfRYspkP_o.png" alt="在这里插入图片描述"></p> 
<p><img src="https://images2.imgbox.com/0c/0d/7Wi9YyUC_o.png" alt="在这里插入图片描述"></p> 
<h4><a id="333_Pod_185"></a>3.3.3 Pod亲和性与反亲和</h4> 
<p><img src="https://images2.imgbox.com/1a/5e/mFjjJ4Hg_o.png" alt="在这里插入图片描述"></p> 
<p><a href="https://kubernetes.io/zh/docs/concepts/scheduling-eviction/assign-pod-node/" rel="nofollow">https://kubernetes.io/zh/docs/concepts/scheduling-eviction/assign-pod-node/</a></p> 
<p><strong>（1）节点亲和性</strong><br> <strong>pod.spec.nodeAffinity</strong><br> ●preferredDuringSchedulingIgnoredDuringExecution：软策略<br> ●requiredDuringSchedulingIgnoredDuringExecution：硬策略</p> 
<p><strong>（2）Pod 亲和性<br> pod.spec.affinity.podAffinity/podAntiAffinity</strong><br> ●preferredDuringSchedulingIgnoredDuringExecution：软策略<br> ●requiredDuringSchedulingIgnoredDuringExecution：硬策略</p> 
<p><strong>可以把自己理解成一个Pod，当你开学报名上学，如果你更倾向去zhangsan老师带的班级，把不同老师带的班级当作一个node的话，这个就是节点亲和性。如果你是必须要去zhangsan老师带的班级，这就是硬策略；而你说你想去并且最好能zhangsan老师带的班级，这就是软策略。</strong></p> 
<p><strong>如果你有一个很好的朋友叫lisi，你倾向和lisi同学在同一个班级，这个就是Pod亲和性。如果你一定要去lisi同学在的班级，这就是硬策略；而你说你想去并且最好能去lisi同学在的班级，这就是软策略。软策略是不去也可以，硬策略则是不去就不行。</strong></p> 
<p><strong>键值运算关系</strong><br> ●<strong>In：label 的值在某个列表中</strong><br> ●<strong>NotIn：label 的值不在某个列表中</strong><br> ●<strong>Gt：label 的值大于某个值</strong><br> ●<strong>Lt：label 的值小于某个值</strong><br> ●<strong>Exists：某个 label 存在</strong><br> ●<strong>DoesNotExist：某个 label 不存在</strong></p> 
<h5><a id="1_215"></a>1.节点亲和硬策略示例</h5> 
<pre><code class="prism language-bash">apiVersion: v1
kind: Pod
metadata:
  labels:
    run: myapp-demo7
  name: myapp-demo7
spec:
  containers:
  - image: soscscs/myapp:v1
    name: myapp-demo7
    ports:
    - containerPort: <span class="token number">80</span>
  affinity:
    nodeAffinity:
      requiredDuringSchedulingIgnoredDuringExecution:
        nodeSelectorTerms:
        - matchExpressions:
          - key: <span class="token builtin class-name">test</span>
            operator: NotIn
            values:
            - a

</code></pre> 
<p><img src="https://images2.imgbox.com/13/56/Kl1Jfab4_o.png" alt="在这里插入图片描述"></p> 
<p><img src="https://images2.imgbox.com/62/28/BMfJPDmH_o.png" alt="在这里插入图片描述"><br> <img src="https://images2.imgbox.com/78/49/GJAWRwoa_o.png" alt="在这里插入图片描述"><br> <img src="https://images2.imgbox.com/2a/84/IO97qprk_o.png" alt="在这里插入图片描述"><br> <img src="https://images2.imgbox.com/fd/b2/1w5gTLwO_o.png" alt="在这里插入图片描述"></p> 
<pre><code class="prism language-bash">kubectl describe pod myapp-demo7
</code></pre> 
<p><img src="https://images2.imgbox.com/09/f9/JitrkoUv_o.png" alt="在这里插入图片描述"><br> <img src="https://images2.imgbox.com/c7/e3/QieIX3Pl_o.png" alt="在这里插入图片描述"></p> 
<p><img src="https://images2.imgbox.com/d3/d1/HFu45iKH_o.png" alt="在这里插入图片描述"></p> 
<h5><a id="2_259"></a>2.节点亲和软策略示例</h5> 
<pre><code class="prism language-bash">apiVersion: v1
kind: Pod
metadata:
  labels:
    run: myapp-demo8
  name: myapp-demo8
spec:
  containers:
  - image: soscscs/myapp:v1
    name: myapp-demo7
    ports:
    - containerPort: <span class="token number">80</span>
  affinity:
    nodeAffinity:
      preferredDuringSchedulingIgnoredDuringExecution:
      - weight: <span class="token number">100</span>
        preference:
          matchExpressions:
          - key: <span class="token builtin class-name">test</span>
            operator: NotIn
            values:
            - a
</code></pre> 
<p><img src="https://images2.imgbox.com/db/e8/41uH4TO0_o.png" alt="在这里插入图片描述"></p> 
<p><img src="https://images2.imgbox.com/d9/d6/JFTD33VI_o.png" alt="在这里插入图片描述"><br> <img src="https://images2.imgbox.com/e7/b7/mB8Tw9Cz_o.png" alt="在这里插入图片描述"></p> 
<h5><a id="3_289"></a>3.硬限制和软限制结合使用</h5> 
<p><strong>如果把硬策略和软策略合在一起使用，则要先满足硬策略之后才会满足软策略</strong></p> 
<pre><code class="prism language-bash">apiVersion: v1
kind: Pod
metadata:
  labels:
    run: myapp-demo8
  name: myapp-demo9
spec:
  containers:
  - image: soscscs/myapp:v1
    name: myapp-demo7
    ports:
    - containerPort: <span class="token number">80</span>
  affinity:
    nodeAffinity:
      preferredDuringSchedulingIgnoredDuringExecution:
      - weight: <span class="token number">100</span>
        preference:
          matchExpressions:
          - key: <span class="token builtin class-name">test</span>
            operator: In
            values:
            - a
      requiredDuringSchedulingIgnoredDuringExecution:
       nodeSelectorTerms:
       - matchExpressions:
         - key: class
           operator: NotIn
           values:
           - demo1
           - demo2

</code></pre> 
<p><img src="https://images2.imgbox.com/15/3e/NOjS0y6L_o.png" alt="在这里插入图片描述"></p> 
<p><img src="https://images2.imgbox.com/b4/7f/WLx6Pr0L_o.png" alt="在这里插入图片描述"><br> <img src="https://images2.imgbox.com/64/19/cGnsjo4w_o.png" alt="在这里插入图片描述"><br> <img src="https://images2.imgbox.com/35/82/jNK0YUtG_o.png" alt="在这里插入图片描述"></p> 
<pre><code class="prism language-bash">//修改后
apiVersion: v1
kind: Pod
metadata:
  labels:
    run: myapp-demo8
  name: myapp-demo9
spec:
  containers:
  - image: soscscs/myapp:v1
    name: myapp-demo7
    ports:
    - containerPort: <span class="token number">80</span>
  affinity:
    nodeAffinity:
      preferredDuringSchedulingIgnoredDuringExecution:
      - weight: <span class="token number">100</span>
        preference:
          matchExpressions:
          - key: <span class="token builtin class-name">test</span>
            operator: In
            values:
            - b
      requiredDuringSchedulingIgnoredDuringExecution:
       nodeSelectorTerms:
       - matchExpressions:
         - key: class
           operator: NotIn
           values:
           - demo1
           - demo2

</code></pre> 
<p><img src="https://images2.imgbox.com/64/7b/9y44itrK_o.png" alt="在这里插入图片描述"><br> <img src="https://images2.imgbox.com/ff/95/ldsduyTb_o.png" alt="在这里插入图片描述"></p> 
<h5><a id="4_Pod__Pod__368"></a>4.使用 Pod 亲和性调度，创建多个 Pod 资源</h5> 
<p><strong>先在创建一个Pod指定在node02节点上</strong></p> 
<pre><code class="prism language-bash"><span class="token function">vim</span> myapp-demo.yaml

apiVersion: v1
kind: Pod
metadata:
  labels:
    run: myapp-demo
  name: myapp-demo
spec:
  nodeName: node02
  containers:
  - image: soscscs/myapp:v1
    name: myapp-demo
    ports:
    - containerPort: <span class="token number">80</span>                    
</code></pre> 
<p><img src="https://images2.imgbox.com/59/e0/t9FN6tdW_o.png" alt="在这里插入图片描述"><br> <strong>给节点设置标签，test为不在同一拓扑域，class在同一拓扑域</strong></p> 
<pre><code class="prism language-bash"> kubectl label nodes node01 <span class="token assign-left variable">class</span><span class="token operator">=</span>demo <span class="token parameter variable">--overwrite</span>
 kubectl label nodes node02 <span class="token assign-left variable">class</span><span class="token operator">=</span>demo <span class="token parameter variable">--overwrite</span>
</code></pre> 
<p><img src="https://images2.imgbox.com/39/85/7tgyC5sF_o.png" alt="在这里插入图片描述"><br> <strong>创建一个 demo 的命名空间</strong></p> 
<pre><code class="prism language-bash">kubectl create namespace demo
kubectl get ns
</code></pre> 
<p><img src="https://images2.imgbox.com/18/81/uP1GO8xj_o.png" alt="在这里插入图片描述"></p> 
<pre><code class="prism language-bash"><span class="token function">vim</span> myapp-demo.yaml
</code></pre> 
<p><img src="https://images2.imgbox.com/7b/04/4hcDyYZN_o.png" alt="在这里插入图片描述"><br> <img src="https://images2.imgbox.com/09/17/ZBryJZTc_o.png" alt="在这里插入图片描述"></p> 
<pre><code class="prism language-bash"><span class="token function">vim</span> demo9.yaml 

apiVersion: v1
kind: Pod
metadata:
  labels:
    run: myapp-demo9
  name: myapp-wangwu
  namespace: demo
spec:
  containers:
  - image: soscscs/myapp:v1
    name: myapp-demo7
    ports:
    - containerPort: <span class="token number">80</span>
  affinity:
    podAffinity:
      requiredDuringSchedulingIgnoredDuringExecution:
      - namespaces:
        - demo
        topologyKey: <span class="token builtin class-name">test</span>
        labelSelector:
          matchExpressions:
          - key: run
            operator: In
            values:
            - myapp-demo
</code></pre> 
<p><strong>都创建在一个节点 node02 上</strong><br> <img src="https://images2.imgbox.com/82/ca/dU1kiLkN_o.png" alt="在这里插入图片描述"><br> <img src="https://images2.imgbox.com/14/b0/bouaQUYO_o.png" alt="在这里插入图片描述"></p> 
<p><strong>利用亲和性负载均衡创建Pod</strong></p> 
<pre><code class="prism language-bash">kubectl create namespace <span class="token builtin class-name">test</span>
</code></pre> 
<p><img src="https://images2.imgbox.com/04/3e/6Y7Hf2TK_o.png" alt="在这里插入图片描述"></p> 
<pre><code class="prism language-bash">//指定在node02节点上创建一个Pod并指定命名空间test
<span class="token function">vim</span> myapp-demo.yaml

apiVersion: v1
kind: Pod
metadata:
  labels:
    run: myapp-demo
  name: myapp-demo
  namespace: <span class="token builtin class-name">test</span>
spec:
  nodeName: node02
  containers:
  - image: soscscs/myapp:v1
    name: myapp-demo
    ports:
    - containerPort: <span class="token number">80</span>                                                                                                 
</code></pre> 
<p><img src="https://images2.imgbox.com/f4/89/X3HIizCK_o.png" alt="在这里插入图片描述"></p> 
<pre><code class="prism language-bash">//根据myapp-demo.yaml创建的Pod采用亲和性实现负载均衡创建Pod
<span class="token function">vim</span> demo9.yaml
apiVersion: v1
kind: Pod
metadata:
  labels:
    run: myapp-demo9
  name: myapp-a
  namespace: <span class="token builtin class-name">test</span>
spec:
  containers:
  - image: soscscs/myapp:v1
    name: myapp-demo9
    ports:
    - containerPort: <span class="token number">80</span>
  affinity:
    podAffinity:
      requiredDuringSchedulingIgnoredDuringExecution:
      - namespaces:
        - <span class="token builtin class-name">test</span>
        topologyKey: class
        labelSelector:
          matchExpressions:
          - key: run
            operator: In
            values:
            - myapp-demo
</code></pre> 
<p><img src="https://images2.imgbox.com/6d/31/xCxfufFw_o.png" alt="在这里插入图片描述"><br> <strong>根据目标节点所使用的标签 run=myapp-demo ，然后根据目标Pod去判断 node节点用什么拓扑域的键，再看拓扑域的键有哪些node节点的键值是一样的，如果相同，根据Pod就会创建在同一个拓扑域，如果是根据Pod亲和来创建调度Pod，Pod就负载均衡创建在不同node节点。</strong></p> 
<pre><code class="prism language-bash">kubectl label nodes node01 <span class="token assign-left variable">class</span><span class="token operator">=</span>ll <span class="token parameter variable">--overwrite</span>
kubectl label nodes node02 <span class="token assign-left variable">class</span><span class="token operator">=</span>ll <span class="token parameter variable">--overwrite</span>
</code></pre> 
<p><img src="https://images2.imgbox.com/ce/28/S9yJRTzJ_o.png" alt="在这里插入图片描述"><br> <img src="https://images2.imgbox.com/7e/69/0dUKRtHB_o.png" alt="在这里插入图片描述"></p> 
<h5><a id="5_514"></a>5.反亲和的硬策略</h5> 
<pre><code class="prism language-bash"><span class="token function">vim</span> demo9.yaml

apiVersion: v1
kind: Pod
metadata:
  labels:
    run: myapp-demo9
  name: myapp-zhangsan
  namespace: <span class="token builtin class-name">test</span>
spec:
  containers:
  - image: soscscs/myapp:v1
    name: myapp-demo9
    ports:
    - containerPort: <span class="token number">80</span>
  affinity:
    podAntiAffinity:
      requiredDuringSchedulingIgnoredDuringExecution:
      - namespaces:
        - <span class="token builtin class-name">test</span>
        topologyKey: <span class="token builtin class-name">test</span>
        labelSelector:
          matchExpressions:
          - key: run
            operator: In
            values:
            - myapp-demo
</code></pre> 
<p><img src="https://images2.imgbox.com/ec/02/Y0sCLkSy_o.png" alt="在这里插入图片描述"><br> <img src="https://images2.imgbox.com/2e/f1/hcTzYOhA_o.png" alt="在这里插入图片描述"></p> 
<pre><code class="prism language-bash"><span class="token function">vim</span> demo9.yaml

apiVersion: v1
kind: Pod
metadata:
  labels:
    run: myapp-demo9
  name: myapp-d
  namespace: <span class="token builtin class-name">test</span>
spec:
  containers:
  - image: soscscs/myapp:v1
    name: myapp-demo9
    ports:
    - containerPort: <span class="token number">80</span>
  affinity:
    podAntiAffinity:
      requiredDuringSchedulingIgnoredDuringExecution:
      - namespaces:
        - <span class="token builtin class-name">test</span>
        topologyKey: <span class="token builtin class-name">test</span>
        labelSelector:
          matchExpressions:
          - key: run
            operator: In
            values:
            - myapp-demo
</code></pre> 
<p><img src="https://images2.imgbox.com/53/1f/JajFvfp1_o.png" alt="在这里插入图片描述"></p> 
<p><img src="https://images2.imgbox.com/a8/51/iWyqEhSY_o.png" alt="在这里插入图片描述"></p> 
<h5><a id="6_580"></a>6.反亲和的软策略</h5> 
<pre><code class="prism language-bash"><span class="token function">cp</span> demo9.yaml demo10.yaml
<span class="token function">vim</span> demo10.yaml

apiVersion: v1
kind: Pod
metadata:
  labels:
    run: myapp-demo9
  name: myapp-a
  namespace: <span class="token builtin class-name">test</span>
spec:
  containers:
  - image: soscscs/myapp:v1
    name: myapp-demo9
    ports:
    - containerPort: <span class="token number">80</span>
  affinity:
    podAntiAffinity:
      preferredDuringSchedulingIgnoredDuringExecution:
      - weight: <span class="token number">100</span>
        podAffinityTerm:
          namespaces:
          - <span class="token builtin class-name">test</span>
          topologyKey: class
          labelSelector:
            matchExpressions:
            - key: run
              operator: In
              values:
              - myapp-demo
</code></pre> 
<p><img src="https://images2.imgbox.com/b3/d3/AdTrjnk3_o.png" alt="在这里插入图片描述"><br> <img src="https://images2.imgbox.com/67/dd/RzlETghw_o.png" alt="在这里插入图片描述"></p> 
<p><img src="https://images2.imgbox.com/70/f1/OPlx4VUw_o.png" alt="在这里插入图片描述"></p> 
<h4><a id="334_Taint_620"></a>3.3.4 污点(Taint)</h4> 
<p><strong>污点(Taint)</strong><br> 节点亲和性，是Pod的一种属性（偏好或硬性要求），它使Pod被吸引到一类特定的节点。Taint 则相反，它使节点能够排斥一类特定的 Pod。<br> Taint 和 Toleration 相互配合，可以用来避免 Pod 被分配到不合适的节点上。每个节点上都可以应用一个或多个 taint ，这表示对于那些不能容忍这些 taint 的 Pod，是不会被该节点接受的。如果将 toleration 应用于 Pod 上，则表示这些 Pod 可以（但不一定）被调度到具有匹配 taint 的节点上。</p> 
<p><strong>使用 kubectl taint 命令可以给某个 Node 节点设置污点，Node 被设置上污点之后就和 Pod 之间存在了一种相斥的关系，可以让 Node节点 拒绝 Pod 的调度执行，甚至将 Node节点 已经存在的 Pod 驱逐出去。</strong></p> 
<p><strong>污点的组成格式如下：</strong></p> 
<p><code>key=value:effect</code></p> 
<p>每个污点有一个 key 和 value 作为污点的标签，其中 value 可以为空，effect 描述污点的作用。</p> 
<p>当前 taint effect 支持如下三个选项：<br> ●<strong>NoSchedule</strong>：表示 k8s 将不会将 Pod 调度到具有该污点的 Node 上<br> ●<strong>PreferNoSchedule</strong>：表示 k8s 将尽量避免将 Pod 调度到具有该污点的 Node 上<br> ●<strong>NoExecute</strong>：表示 k8s 将不会将 Pod 调度到具有该污点的 Node 上，同时会将 Node 上已经存在的 Pod 驱逐出去</p> 
<pre><code class="prism language-bash">kubectl describe nodes <span class="token operator">|</span> <span class="token function">grep</span> <span class="token parameter variable">-i</span> taint
</code></pre> 
<p><img src="https://images2.imgbox.com/43/70/zWMvZDqe_o.png" alt="在这里插入图片描述"></p> 
<pre><code class="prism language-bash">//master 就是因为有 NoSchedule 污点，k8s 才不会将 Pod 调度到 master 节点上
kubectl describe nodes master
</code></pre> 
<p><img src="https://images2.imgbox.com/47/6d/4QchLay9_o.png" alt="在这里插入图片描述"></p> 
<h5><a id="1__653"></a>1. 打上污点</h5> 
<p><strong>示例1：给node01打上NoSchedule污点</strong></p> 
<pre><code class="prism language-bash">kubectl taint nodes node01 <span class="token assign-left variable">check</span><span class="token operator">=</span>mycheck:NoSchedule
kubectl describe nodes node01
</code></pre> 
<p><img src="https://images2.imgbox.com/9b/2e/fiE78XOl_o.png" alt="在这里插入图片描述"><br> <strong>测试打上污点后，pod会在哪个节点上创建</strong></p> 
<pre><code class="prism language-bash"><span class="token function">vim</span> test-deploy.yaml 

apiVersion: apps/v1
kind: Deployment
metadata:
  creationTimestamp: null
  labels:
    app: myapp-test
  name: myapp-test
spec:
  replicas: <span class="token number">5</span>
  selector:
    matchLabels:
      app: myapp-test
  strategy: <span class="token punctuation">{<!-- --></span><span class="token punctuation">}</span>
  template:
    metadata:
      creationTimestamp: null
      labels:
        app: myapp-test
    spec:
      containers:
      - image: soscscs/myapp:v1
        name: myapp
        ports:
        - containerPort: <span class="token number">80</span>
        resources: <span class="token punctuation">{<!-- --></span><span class="token punctuation">}</span>
status: <span class="token punctuation">{<!-- --></span><span class="token punctuation">}</span>
</code></pre> 
<p><img src="https://images2.imgbox.com/5b/cf/ArSnqZoV_o.png" alt="在这里插入图片描述"><br> <strong>示例2：给node01打上NoExecute污点</strong></p> 
<pre><code class="prism language-bash">kubectl get pods <span class="token parameter variable">-o</span> wide <span class="token parameter variable">-n</span> <span class="token builtin class-name">test</span>
kubectl taint nodes node01 <span class="token assign-left variable">mycheck</span><span class="token operator">=</span>check:NoExecute
</code></pre> 
<p><img src="https://images2.imgbox.com/f3/c6/AZuCYxKH_o.png" alt="在这里插入图片描述"></p> 
<h5><a id="2__704"></a>2. 删除污点</h5> 
<pre><code class="prism language-bash">kubectl taint nodes node01 check:NoSchedule-
kubectl describe nodes node01
</code></pre> 
<p><img src="https://images2.imgbox.com/b1/0d/EjcXe1kv_o.png" alt="在这里插入图片描述"></p> 
<pre><code class="prism language-bash"> kubectl taint nodes node01 mycheck-
</code></pre> 
<p><img src="https://images2.imgbox.com/eb/8f/DkhZco3D_o.png" alt="在这里插入图片描述"><br> <img src="https://images2.imgbox.com/4b/01/IKTTNCYX_o.png" alt="在这里插入图片描述"></p> 
<pre><code class="prism language-bash">kubectl taint nodes node01 <span class="token assign-left variable">mycheck</span><span class="token operator">=</span>check:NoExecute
kubectl get pods <span class="token parameter variable">-o</span> wide <span class="token parameter variable">-w</span>
</code></pre> 
<p><img src="https://images2.imgbox.com/ba/34/pHG5BajQ_o.png" alt="在这里插入图片描述"><br> <img src="https://images2.imgbox.com/f9/70/tdsRNt1Y_o.png" alt="在这里插入图片描述"><br> <strong>查看 Pod 状态，会发现 node01 上的 Pod 已经被全部驱逐（注：如果是 Deployment 或者StatefulSet 资源类型，为了维持副本数量则会在别的 Node 上再创建新的 Pod）</strong></p> 
<h4><a id="335_Tolerations_727"></a>3.3.5 容忍(Tolerations)</h4> 
<p>设置了污点的 Node 将根据 taint 的 effect:NoSchedule、PreferNoSchedule、NoExecute 和 Pod 之间产生互斥的关系，Pod 将在一定程度上不会被调度到 Node 上。但我们可以在 Pod 上设置容忍(Tolerations)，意思是设置了容忍的 Pod 将可以容忍污点的存在，可以被调度到存在污点的 Node 上。</p> 
<pre><code class="prism language-bash">示例：
kubectl taint nodes node01 <span class="token assign-left variable">mycheck</span><span class="token operator">=</span>test:NoExecute
kubectl taint nodes node02 <span class="token assign-left variable">mycheck</span><span class="token operator">=</span>test:NoExecute
</code></pre> 
<p><img src="https://images2.imgbox.com/21/e4/lLY98der_o.png" alt="在这里插入图片描述"></p> 
<pre><code class="prism language-bash"> kubectl apply <span class="token parameter variable">-f</span> test-deploy.yaml
 kubectl get pods <span class="token parameter variable">-owide</span> 
</code></pre> 
<p><img src="https://images2.imgbox.com/ef/57/zqFdGXNL_o.png" alt="在这里插入图片描述"><br> <img src="https://images2.imgbox.com/be/f1/FuaODyp9_o.png" alt="在这里插入图片描述"><br> <strong>在两个 Node 上都设置了污点后，此时 Pod 将无法创建成功</strong><br> <img src="https://images2.imgbox.com/5c/3b/OOsZRZ8b_o.png" alt="在这里插入图片描述"><br> <strong>创建能容忍污点的Pod</strong></p> 
<pre><code class="prism language-bash">示例1：
<span class="token function">cp</span> myapp-demo.yaml demo11.yaml
<span class="token function">vim</span> demo11.yaml

apiVersion: v1
kind: Pod
metadata:
  labels:
    run: myapp-demo11
  name: myapp-demo11
  namespace: default
spec:
  containers:
  - image: soscscs/myapp:v1
    name: myapp-demo11
    ports:
    - containerPort: <span class="token number">80</span>
  tolerations:
  - key: mycheck
    operator: Equal
    value: <span class="token builtin class-name">test</span>
    effect: NoExecute
    tolerationSeconds: <span class="token number">60</span>
</code></pre> 
<p><img src="https://images2.imgbox.com/0a/ad/x8y9L3Ve_o.png" alt="在这里插入图片描述"></p> 
<p><img src="https://images2.imgbox.com/f2/e2/ciF9kHxu_o.png" alt="在这里插入图片描述"><br> <strong>在master节点创建能容忍污点的Pod</strong></p> 
<pre><code class="prism language-bash">示例2：
<span class="token function">vim</span> demo11.yaml

apiVersion: v1
kind: Pod
metadata:
  labels:
    run: myapp-master
  name: myapp-master
  namespace: default
spec:
  containers:
  - image: soscscs/myapp:v1
    name: myapp-master
    ports:
    - containerPort: <span class="token number">80</span>
  tolerations:
  - key: node-role.kubernetes.io/master
    operator: Exists
    effect: NoSchedule
</code></pre> 
<p><img src="https://images2.imgbox.com/f2/a0/aI1NvEij_o.png" alt="在这里插入图片描述"><br> <strong>创建多副本Pod容忍污点</strong></p> 
<pre><code class="prism language-bash">示例3：
<span class="token function">vim</span> test-deploy.yaml 

apiVersion: apps/v1
kind: Deployment
metadata:
  creationTimestamp: null
  labels:
    app: myapp-test
  name: myapp-test
spec:
  replicas: <span class="token number">5</span>
  selector:
    matchLabels:
      app: myapp-test
  strategy: <span class="token punctuation">{<!-- --></span><span class="token punctuation">}</span>
  template:
    metadata:
      creationTimestamp: null
      labels:
        app: myapp-test
    spec:
      tolerations:
      - key: mycheck
        operator: Exists
        effect: NoExecute
      containers:
      - image: soscscs/myapp:v1
        name: myapp
        ports:
        - containerPort: <span class="token number">80</span>
        resources: <span class="token punctuation">{<!-- --></span><span class="token punctuation">}</span>
status: <span class="token punctuation">{<!-- --></span><span class="token punctuation">}</span>
</code></pre> 
<p><img src="https://images2.imgbox.com/6a/8b/N96X3owe_o.png" alt="在这里插入图片描述"><br> <img src="https://images2.imgbox.com/9a/9e/eVd1cIak_o.png" alt="在这里插入图片描述"></p> 
<h4><a id="336__843"></a>3.3.6 其它注意事项</h4> 
<p><strong>（1）当不指定 key 值时，表示容忍所有的污点 key</strong></p> 
<pre><code class="prism language-bash"> tolerations:
  - operator: <span class="token string">"Exists"</span>
</code></pre> 
<p><strong>（2）当不指定 effect 值时，表示容忍所有的污点作用</strong></p> 
<pre><code class="prism language-bash">  tolerations:
  - key: <span class="token string">"key"</span>
    operator: <span class="token string">"Exists"</span>
</code></pre> 
<p><strong>（3）有多个 Master 存在时，防止资源浪费，可以如下设置</strong></p> 
<pre><code class="prism language-bash">kubectl taint <span class="token function">node</span> Master-Name node-role.kubernetes.io/master<span class="token operator">=</span>:PreferNoSchedule
</code></pre> 
<p><strong>如果某个 Node 更新升级系统组件，为了防止业务长时间中断，可以先在该 Node 设置 NoExecute 污点，把该 Node 上的 Pod 都驱逐出去</strong></p> 
<pre><code class="prism language-bash">kubectl taint <span class="token function">node</span> node01 <span class="token assign-left variable">check</span><span class="token operator">=</span>mycheck:NoExecute
</code></pre> 
<p><strong>此时如果别的 Node 资源不够用，可临时给 Master 设置 PreferNoSchedule 污点，让 Pod 可在 Master 上临时创建</strong></p> 
<pre><code class="prism language-bash">kubectl taint <span class="token function">node</span> master node-role.kubernetes.io/master<span class="token operator">=</span>:PreferNoSchedule
</code></pre> 
<p><strong>待所有 Node 的更新操作都完成后，再去除污点</strong></p> 
<pre><code class="prism language-bash">kubectl taint <span class="token function">node</span> node01 <span class="token assign-left variable">check</span><span class="token operator">=</span>mycheck:NoExecute-
</code></pre> 
<h4><a id="337_cordon__drain__884"></a>3.3.7 cordon 和 drain 对节点执行维护操作</h4> 
<p><strong>将 Node 标记为不可调度的状态，这样就不会让新创建的 Pod 在此 Node 上运行</strong></p> 
<pre><code class="prism language-bash">kubectl cordon <span class="token operator">&lt;</span>NODE_NAME<span class="token operator">&gt;</span> 		 //该node将会变为SchedulingDisabled状态
</code></pre> 
<pre><code class="prism language-bash">示例：
kubectl cordon node01
kubectl get nodes
</code></pre> 
<p><img src="https://images2.imgbox.com/30/87/i2bOJuTR_o.png" alt="在这里插入图片描述"></p> 
<pre><code class="prism language-bash"><span class="token function">vim</span> test-deploy.yaml

apiVersion: apps/v1
kind: Deployment
metadata:
  creationTimestamp: null
  labels:
    app: myapp-test
  name: myapp-work
spec:
  replicas: <span class="token number">5</span>
  selector:
    matchLabels:
      app: myapp-test
  strategy: <span class="token punctuation">{<!-- --></span><span class="token punctuation">}</span>
  template:
    metadata:
      creationTimestamp: null
      labels:
        app: myapp-test
    spec:
      tolerations:
      - key: mycheck
        operator: Exists
        effect: NoExecute
      containers:
      - image: soscscs/myapp:v1
        name: myapp
        ports:
        - containerPort: <span class="token number">80</span>
        resources: <span class="token punctuation">{<!-- --></span><span class="token punctuation">}</span>
status: <span class="token punctuation">{<!-- --></span><span class="token punctuation">}</span>

</code></pre> 
<p><img src="https://images2.imgbox.com/47/64/E3iYcu9S_o.png" alt="在这里插入图片描述"></p> 
<p><code>kubectl drain</code> <strong>可以让 Node 节点开始释放所有 pod，并且不接收新的 pod 进程。drain 本意排水，意思是将出问题的 Node 下的 Pod 转移到其它 Node 下运行</strong></p> 
<pre><code class="prism language-bash">kubectl drain <span class="token operator">&lt;</span>NODE_NAME<span class="token operator">&gt;</span> --ignore-daemonsets --delete-emptydir-data <span class="token parameter variable">--force</span>
</code></pre> 
<p><code>--ignore-daemonsets</code>：无视 DaemonSet 管理下的 Pod。<br> <code>--delete-emptydir-data</code>：如果有 mount local volume 的 pod，会强制杀掉该 pod。<br> <code>--force</code>：强制释放不是控制器管理的 Pod。</p> 
<pre><code class="prism language-bash">kubectl drain node01  --ignore-daemonsets --delete-emptydir-data <span class="token parameter variable">--force</span>
</code></pre> 
<p><img src="https://images2.imgbox.com/c3/9d/pXkXo71L_o.png" alt="在这里插入图片描述"></p> 
<p><strong>注：执行 drain 命令，会自动做了两件事情:</strong><br> <strong>（1）设定此 node 为不可调度状态（cordon)</strong><br> <strong>（2）evict（驱逐）了 Pod</strong></p> 
<p><code>kubectl uncordon</code> 将 Node 标记为可调度的状态</p> 
<pre><code class="prism language-bash">kubectl uncordon <span class="token operator">&lt;</span>NODE_NAME<span class="token operator">&gt;</span>
</code></pre> 
<pre><code class="prism language-bash">kubectl drain node02  --ignore-daemonsets --delete-emptydir-data <span class="token parameter variable">--force</span>
</code></pre> 
<p><img src="https://images2.imgbox.com/d2/92/OumOIlLw_o.png" alt="在这里插入图片描述"></p> 
<pre><code class="prism language-bash">kubectl get nodes 
</code></pre> 
<p><img src="https://images2.imgbox.com/47/52/hOHfPF8k_o.png" alt="在这里插入图片描述"><br> <img src="https://images2.imgbox.com/f1/32/YQJp7Kmu_o.png" alt="在这里插入图片描述"></p> 
<pre><code class="prism language-bash">kubectl uncordon node01
kubectl uncordon node02
</code></pre> 
<p><img src="https://images2.imgbox.com/fa/ff/QqRuEGy1_o.png" alt="在这里插入图片描述"><br> <img src="https://images2.imgbox.com/8f/8c/25XCDNkJ_o.png" alt="在这里插入图片描述"></p> 
<h3><a id="34_Pod_phase_991"></a>3.4 Pod启动阶段（相位 phase）</h3> 
<p>Pod 创建完之后，一直到持久运行起来，中间有很多步骤，也就有很多出错的可能，因此会有很多不同的状态。<br> 一般来说，<strong>pod 这个过程</strong>包含以下几个步骤：<br> <strong>（1）调度到某台 node 上。kubernetes 根据一定的优先级算法选择一台 node 节点将其作为 Pod 运行的 node</strong><br> <strong>（2）拉取镜像</strong><br> <strong>（3）挂载存储配置等</strong><br> <strong>（4）容器运行起来。如果有健康检查，会根据检查的结果来设置其状态。</strong></p> 
<h4><a id="341_phase__999"></a>3.4.1 phase 的可能状态</h4> 
<p>●<code>Pending</code>：表示APIServer创建了Pod资源对象并已经存入了etcd中，但是它并未被调度完成（比如还没有调度到某台node上），或者仍然处于从仓库下载镜像的过程中。</p> 
<p>●<code>Running</code>：Pod已经被调度到某节点之上，并且Pod中所有容器都已经被kubelet创建。至少有一个容器正在运行，或者正处于启动或者重启状态（也就是说Running状态下的Pod不一定能被正常访问）。</p> 
<p>●<code>Succeeded</code>：有些pod不是长久运行的，比如job、cronjob，一段时间后Pod中的所有容器都被成功终止，并且不会再重启。需要反馈任务执行的结果。</p> 
<p>●<code>Failed</code>：Pod中的所有容器都已终止了，并且至少有一个容器是因为失败终止。也就是说，容器以非0状态退出或者被系统终止，比如 command 写的有问题。</p> 
<p>●<code>Unknown</code>：表示无法读取 Pod 状态，通常是 kube-controller-manager 无法与 Pod 通信。Pod 所在的 Node 出了问题或失联，从而导致 Pod 的状态为 Unknow</p> 
<h4><a id="342__Unknown__Pod_1010"></a>3.4.2 如何删除 Unknown 状态的 Pod</h4> 
<p>●从集群中删除有问题的 Node。使用公有云时，kube-controller-manager 会在 VM 删除后自动删除对应的 Node。 而在物理机部署的集群中，需要管理员手动删除 Node（<code>kubectl delete node &lt;node_name&gt;</code>）。</p> 
<p>●被动等待 Node 恢复正常，Kubelet 会重新跟 kube-apiserver 通信确认这些 Pod 的期待状态，进而再决定删除或者继续运行这些 Pod。</p> 
<p>●主动删除 Pod，通过执行 <code>kubectl delete pod &lt;pod_name&gt; --grace-period=0 --force</code> 强制删除 Pod。<strong>但是这里需要注意的是，除非明确知道 Pod 的确处于停止状态（比如 Node 所在 VM 或物理机已经关机），否则不建议使用该方法。特别是 StatefulSet 管理的 Pod，强制删除容易导致脑裂或者数据丢失等问题。</strong></p> 
<h4><a id="343__1018"></a>3.4.3 故障排除步骤</h4> 
<p><strong>查看Pod事件</strong></p> 
<pre><code class="prism language-bash">kubectl describe TYPE NAME_PREFIX  
</code></pre> 
<p><strong>查看Pod日志（Failed状态下）</strong></p> 
<pre><code class="prism language-bash">kubectl logs <span class="token operator">&lt;</span>POD_NAME<span class="token operator">&gt;</span> <span class="token punctuation">[</span>-c Container_NAME<span class="token punctuation">]</span>
</code></pre> 
<p><strong>进入Pod（状态为running，但是服务没有提供）</strong></p> 
<pre><code class="prism language-bash">kubectl <span class="token builtin class-name">exec</span> –it <span class="token operator">&lt;</span>POD_NAME<span class="token operator">&gt;</span> <span class="token function">bash</span>
</code></pre> 
<p><strong>查看集群信息</strong></p> 
<pre><code class="prism language-bash">kubectl get nodes
</code></pre> 
<p><strong>发现集群状态正常</strong></p> 
<pre><code class="prism language-bash">kubectl cluster-info
</code></pre> 
<p><strong>查看kubelet日志发现</strong></p> 
<pre><code class="prism language-bash">journalctl <span class="token parameter variable">-xefu</span> kubelet
</code></pre> 
<h2><a id="_1054"></a>四、总结</h2> 
<h3><a id="41__1055"></a>4.1 亲和性</h3> 
<p><strong>节点亲和性：匹配指定的Node节点标签，将Pod调度到满足指定条件的Node节点上</strong></p> 
<p><strong>Pod亲和：匹配指定的Pod标签，将要部署的Pod调度到与指定Pod所在的Node节点处于 同一个拓扑域 的Node节点上</strong></p> 
<p><strong>Pod反亲和：匹配指定的Pod标签，将要部署的Pod调度到与指定Pod所在的Node节点处于 不同的拓扑域 的Node节点上</strong></p> 
<p><strong>硬策略：要强制性的满足指定条件，如果没有满足条件的Node节点，Pod会处于Pending状态，直到有符合条件的Node节点出现</strong></p> 
<p><strong>软策略：非强制性的，会优先选择满足条件的Node节点调度，即使没有满足条件的Node节点，Pod依然会完成调度</strong></p> 
<p><strong>如果硬策略和软策略同时存在，则要先满足硬策略，之后会从满足硬策略的Node节点中优先选择满足软策略的Node节点调度</strong></p> 
<p><strong>怎么判断是否在同一个拓扑域？</strong><br> <strong>看拓扑域key（topologyKey），如果有其它Node节点拥有与指定Pod所在的Node节点相同的 拓扑域key和值的标签，那么它们就在同一个拓扑域中</strong></p> 
<h3><a id="42__1072"></a>4.2 污点</h3> 
<p><code>kubectl describe nodes 节点名称 | grep Taints</code></p> 
<p><code>kubectl taint node 节点名称 key=value:effect</code></p> 
<p><strong>effect的三种类型：</strong><br> <strong>1. NoSchedule一定不会被调度</strong><br> <strong>2. PreferNoSchedule尽量不被调度</strong><br> <strong>3. NoExecute不会被调度，并驱逐节点上的Pod</strong></p> 
<p><strong>删除污点：</strong><code>kubectl taint node 节点名称 key[:effect]-</code></p> 
<h3><a id="43__1085"></a>4.3 容忍</h3> 
<pre><code class="prism language-bash">spec:
  tolerations:
  - key: 键名
    operator: Equal<span class="token operator">|</span>Exists
    value: 键值
    effect: NoSchedule<span class="token operator">|</span>PreferNoSchedule<span class="token operator">|</span>NoExecute
</code></pre> 
<h3><a id="44__1096"></a>4.4 不可调度</h3> 
<pre><code class="prism language-bash">kubectl cordon 节点名称
kubectl uncordon 节点名称
</code></pre> 
<pre><code class="prism language-bash">不可调度+驱逐
kubectl drain 节点名称  --ignore-daemonsets --delete-emptydir-data <span class="token parameter variable">--force</span>
</code></pre> 
<h3><a id="45_Pod__5__1109"></a>4.5 Pod 生命周期的 5 种状态</h3> 
<p><code>pending</code> ：<strong>Pod已经已经创建，但是至少有一个容器没有创建完成，包括Pod还未完成调度到Node节点的过程或者处于镜像拉取过程中、存储卷挂载失败</strong></p> 
<p><code>running</code> ：<strong>Pod中至少有一个容器正在运行</strong></p> 
<p><code>succeeded</code> ： <strong>Pod中的所有容器都已成功终止，并且不会再重启（Completed）</strong></p> 
<p><code>failed</code> ： <strong>Pod中的所有容器都已终止，并且至少有一个容器异常退出（Error）</strong></p> 
<p><code>unknown</code> ： <strong>无法获取Pod的状态，通常是因为Master节点与Pod所在的Node节点通信失败</strong></p> 
<p><strong>Pod遵循预定义的生命周期，起始于Pending阶段，如果至少其中有一个主要容器正常启动，则进入Running阶段，之后取决于Pod中是否有容器以失败状态结束而进入Succeeded或者Failed阶段。</strong><br> <img src="https://images2.imgbox.com/57/54/apAWpxwy_o.png" alt="在这里插入图片描述"></p> 
<h3><a id="46__1123"></a>4.6 排障手段</h3> 
<pre><code class="prism language-bash">kubectl get pods                       查看Pod状态
kubectl describe pod                   查看资源的详细信息和事件
kubectl logs <span class="token punctuation">[</span>-c 容器名<span class="token punctuation">]</span> <span class="token punctuation">[</span>--previous<span class="token punctuation">]</span>   查看Pod容器的日志
kubectl <span class="token builtin class-name">exec</span> <span class="token parameter variable">-it</span> <span class="token punctuation">[</span>-c 容器名<span class="token punctuation">]</span>            进去Pod容器查看相关状态信息
kubectl debug   <span class="token parameter variable">--target</span><span class="token operator">=</span>目标Pod        临时创建Pod容器进入目标Pod进行调试

kubectl get nodes                      查看Node节点状态
kubectl get cs                         查看Master组件状态
kubectl cluster-info                   查看集群信息

journalctl <span class="token parameter variable">-u</span> <span class="token parameter variable">-f</span> kubelet               跟踪kubelet进程日志
</code></pre>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/39dd988bd03c8793f86aa9fff505474c/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">【23物联网国赛样题第一套】蓝色ZigBee节点盒按键长按控制，物联网竞赛今年历年国赛样题真题代码</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/f6d1e82abb80ca19e0089a657cf50200/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">route命令 路由表 Linux Centos</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>