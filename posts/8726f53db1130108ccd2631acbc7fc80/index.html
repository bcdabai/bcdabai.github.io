<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>C&#43;&#43;标准模板库(STL)——vector、set、string、map - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="C&#43;&#43;标准模板库(STL)——vector、set、string、map" />
<meta property="og:description" content="文章目录 一、vector二、set三、string四、map 一、vector vector是“长度根据需要而自动改变的数组”。在算法中，有时会碰到使用普通数组就会超内存的情况，这种情况下可以使用vector数组。另外，vector数组还可以用来以邻接表的方式存储图，这对于无法使用邻接矩阵、又害怕使用指针实现邻接表的题目是非常友好的。
使用vector，需要添加头文件#include&lt; vector &gt;。除此之外，还要添上一句“using namespace std”。
1、vector的定义：
vector&lt;typename&gt; name; typename为基本数据类型：
vector&lt;int&gt; name; vector&lt;double&gt; name; vector&lt;char&gt; name; vector&lt;node&gt; name;//node是结构体类型 vector也可以为STL标准容器，但是这种情况下，定义时要在&gt;&gt;中间加上空格，因为某些编译器会将其认为是移位操作，导致编译错误。如下：
vector&lt;vector&lt;int&gt; &gt; name; 上面这种方法可以联想到二维数组，可以将这个二维的vector数组当做是两个维都可以边长的二维数组理解。
定义vector数组：
vector&lt;typename&gt; ArrayName[arraySize]; 上面这种定义的方式将一维长度固定为arraySize
2、vector容器内元素的访问：
通过下标访问：同普通数组，下标从0~vi.size()-1
通过迭代器访问：迭代器可以理解为一种类似指针的东西
vector&lt;typename&gt;::iterator it; 这样得到了迭代器it，可以通过*it来访问里面的元素
#include&lt;stdio.h&gt; #include&lt;vector&gt; using namespace std; int main(){ vector&lt;int&gt; vi; for(int i = 0 ; i &lt; 5 ; i&#43;&#43;) vi.push_back(i);//在vi末尾依次添加元素i vector&lt;int&gt;::iterator it = vi.begin();//it指向vi的首地址 for(int i = 0 ; i &lt; 5 ; i&#43;&#43;) printf(&#34;" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/8726f53db1130108ccd2631acbc7fc80/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-02-06T16:59:19+08:00" />
<meta property="article:modified_time" content="2022-02-06T16:59:19+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">C&#43;&#43;标准模板库(STL)——vector、set、string、map</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p></p> 
<div class="toc"> 
 <h4>文章目录</h4> 
 <ul><li><a href="#vector_8" rel="nofollow">一、vector</a></li><li><a href="#set_172" rel="nofollow">二、set</a></li><li><a href="#string_259" rel="nofollow">三、string</a></li><li><a href="#map_443" rel="nofollow">四、map</a></li></ul> 
</div> 
<p></p> 
<hr color="#000000" size='1"'> 
<h2><a id="vector_8"></a>一、vector</h2> 
<p>vector是“长度根据需要而自动改变的数组”。在算法中，有时会碰到使用普通数组就会超内存的情况，这种情况下可以使用vector数组。另外，vector数组还可以用来以邻接表的方式存储图，这对于无法使用邻接矩阵、又害怕使用指针实现邻接表的题目是非常友好的。</p> 
<p>使用vector，需要添加头文件#include&lt; vector &gt;。除此之外，还要添上一句“using namespace std”。</p> 
<p><strong>1、vector的定义：</strong></p> 
<pre><code>vector&lt;typename&gt; name;
</code></pre> 
<p>typename为基本数据类型：</p> 
<pre><code>vector&lt;int&gt; name;
vector&lt;double&gt; name;
vector&lt;char&gt; name;
vector&lt;node&gt; name;//node是结构体类型
</code></pre> 
<p>vector也可以为STL标准容器，但是这种情况下，定义时要在&gt;&gt;中间加上空格，因为某些编译器会将其认为是移位操作，导致编译错误。如下：</p> 
<pre><code>vector&lt;vector&lt;int&gt; &gt; name;
</code></pre> 
<p>上面这种方法可以联想到二维数组，可以将这个二维的vector数组当做是两个维都可以边长的二维数组理解。</p> 
<p>定义vector数组：</p> 
<pre><code>vector&lt;typename&gt; ArrayName[arraySize]; 
</code></pre> 
<p>上面这种定义的方式将一维长度固定为arraySize</p> 
<p><strong>2、vector容器内元素的访问：</strong></p> 
<p>通过下标访问：同普通数组，下标从0~vi.size()-1</p> 
<p>通过迭代器访问：迭代器可以理解为一种类似指针的东西</p> 
<pre><code>vector&lt;typename&gt;::iterator it;
</code></pre> 
<p>这样得到了迭代器it，可以通过*it来访问里面的元素</p> 
<pre><code>#include&lt;stdio.h&gt;
#include&lt;vector&gt;
using namespace std;

int main(){
    vector&lt;int&gt; vi;
    for(int i = 0 ; i &lt; 5 ; i++)
        vi.push_back(i);//在vi末尾依次添加元素i
    vector&lt;int&gt;::iterator it = vi.begin();//it指向vi的首地址
    for(int i = 0 ; i &lt; 5 ; i++)
        printf("%d ",*(it+i));
    return 0;
}

</code></pre> 
<p>另外还有一种访问方式：</p> 
<pre><code>    //迭代器能够实现自增操作
    for(vector&lt;int&gt;::iterator it = vi.begin();it!=vi.end();it++)
        printf("%d ",*it);
</code></pre> 
<p><strong>3、push_back()函数：</strong><br> push_back(x)是指在vector后面添加一个元素x，时间复杂度为O(1)</p> 
<p><strong>4、pop_back()函数</strong><br> 删除vector末尾的元素，时间复杂度为O(1)</p> 
<pre><code>#include&lt;stdio.h&gt;
#include&lt;vector&gt;
using namespace std;

int main(){
    vector&lt;int&gt; vi;
    for(int i = 0 ; i &lt; 5 ; i++)
        vi.push_back(i);//在vi末尾依次添加元素i
    vi.pop_back();
    //迭代器能够实现自增操作
    for(vector&lt;int&gt;::iterator it = vi.begin();it!=vi.end();it++)
        printf("%d ",*it);
    return 0;
}

</code></pre> 
<p><img src="https://images2.imgbox.com/85/38/fBAsTsMo_o.png" alt="在这里插入图片描述"></p> 
<p><strong>5、size()</strong><br> 获取vector中元素的个数，时间复杂度为O(1)</p> 
<p><strong>6、clear()</strong><br> 用来清空vector中所有的元素</p> 
<p><strong>7、insert()</strong><br> insert(it,x)：用来想vector的任意迭代器it处插入一个元素x，时间复杂度为O(N)</p> 
<pre><code>#include&lt;stdio.h&gt;
#include&lt;vector&gt;
using namespace std;

int main(){
    vector&lt;int&gt; vi;
    for(int i = 1 ; i &lt;= 5 ; i++)
        vi.push_back(i);//在vi末尾依次添加元素i
    vi.insert(vi.begin()+2,-1);//将-1插入到vi[2]的位置
    for(int i = 0 ; i &lt; vi.size() ; i++)
        printf("%d ",vi[i]);
    return 0;
}

</code></pre> 
<p><img src="https://images2.imgbox.com/ca/99/ONyalthr_o.png" alt="在这里插入图片描述"></p> 
<p><strong>8、erase()</strong><br> 删除单个元素erase(it)：删除迭代器为it处的元素</p> 
<pre><code>#include&lt;stdio.h&gt;
#include&lt;vector&gt;
using namespace std;

int main(){
    vector&lt;int&gt; vi;
    for(int i = 1 ; i &lt;= 5 ; i++)
        vi.push_back(i);//在vi末尾依次添加元素i
    vi.erase(vi.begin()+2);//将-删除vi[2]
    for(int i = 0 ; i &lt; vi.size() ; i++)
        printf("%d ",vi[i]);
    return 0;
}

</code></pre> 
<p><img src="https://images2.imgbox.com/db/e7/KcIeceX3_o.png" alt="在这里插入图片描述"><br> erase(first,last)：删除[first,last)区间内的元素</p> 
<pre><code>#include&lt;stdio.h&gt;
#include&lt;vector&gt;
using namespace std;

int main(){
    vector&lt;int&gt; vi;
    for(int i = 1 ; i &lt;= 5 ; i++)
        vi.push_back(i);//在vi末尾依次添加元素i
    vi.erase(vi.begin()+2,vi.begin()+4);//将-删除vi[2]、vi[3]
    for(int i = 0 ; i &lt; vi.size() ; i++)
        printf("%d ",vi[i]);
    return 0;
}

</code></pre> 
<p><img src="https://images2.imgbox.com/e5/03/uDBDH1y5_o.png" alt="在这里插入图片描述"><br> <strong>常见用途：</strong></p> 
<ul><li>在元素不确定的场合能够节省空间</li><li>由于有些场合输出元素个数不确定，为了更方便地处理最后一个满足条件地元素后面不输出额外的空格，可以先用vector记录所有需要输出的元素然后一次性输出</li><li>用邻接表存储图</li></ul> 
<h2><a id="set_172"></a>二、set</h2> 
<p>set是一个内部自动有序切不含重复元素的集合。使用时需要添加#include&lt; set &gt;以及using namespace std;</p> 
<p><strong>1、set的定义：</strong></p> 
<pre><code>set&lt;typename&gt; name;
</code></pre> 
<p>具体定义方式同vector</p> 
<p><strong>2、set内元素的访问：</strong><br> set只能通过迭代器去访问，并且除了vector和String之外的STL容器都不支持*(it+i)的访问方式，因此只能按照以下方式枚举：</p> 
<pre><code>#include&lt;stdio.h&gt;
#include&lt;set&gt;
using namespace std;

int main(){
    set&lt;int&gt; st;
    st.insert(3);//将3插入st中
    st.insert(5);
    st.insert(2);
    st.insert(3);
    //注意：不支持it&lt;st.end()写法
    for(set&lt;int&gt;::iterator it = st.begin();it!=st.end();it++)
        printf("%d ",*it);
    return 0;
}

</code></pre> 
<p><img src="https://images2.imgbox.com/5c/4a/iQg50IGs_o.png" alt="在这里插入图片描述"><br> 可以发现set内的元素自动递增排序并且去除了重复元素</p> 
<p><strong>3、insert()</strong><br> insert(x)可以将x插入到Set容器中，并自动递增排序和去重</p> 
<p><strong>4、find()</strong><br> find(value)返回set中对应值为value的迭代器</p> 
<pre><code>#include&lt;stdio.h&gt;
#include&lt;set&gt;
using namespace std;

int main(){
    set&lt;int&gt; st;
    for(int i = 1 ; i &lt;=3 ; i++)
        st.insert(i);
    set&lt;int&gt;::iterator it = st.find(2);
    printf("%d",*it);
    return 0;
}

</code></pre> 
<p><strong>5、erase()</strong></p> 
<p>删除单个元素：st.erase(it)，it为所需要删除元素的迭代器，可以结合find()函数使用；st.erase(value)，value为所需要删除元素的值</p> 
<p>删除一个区间内的元素：st.erase(first,last)，删除区间[first,last)内的元素</p> 
<pre><code>#include&lt;stdio.h&gt;
#include&lt;set&gt;
using namespace std;

int main(){
    set&lt;int&gt; st;
    st.insert(20);
    st.insert(10);
    st.insert(40);
    st.insert(30);
    set&lt;int&gt;::iterator it = st.find(30);
    st.erase(it,st.end());//st.end()指向末尾元素的下一个位置，这里即删除30、40
    for(it = st.begin();it!=st.end();it++)
        printf("%d ",*it);
    return 0;
}

</code></pre> 
<p><strong>6、size()</strong><br> 用来获取set内元素的个数</p> 
<p><strong>7、clear()</strong><br> 用来清空set内所有的元素</p> 
<h2><a id="string_259"></a>三、string</h2> 
<p>在C语言中，一般使用字符数组char str[]来存放字符串，C++引入了string类型，对字符串的常用功能进行了封装。使用string需要添加#include&lt; string &gt;以及using namespace std;(string.h和string是不一样的头文件)</p> 
<p><strong>1、string的定义：</strong></p> 
<pre><code>string str;

string str1 = "abcd";
</code></pre> 
<p><strong>2、string中内容的访问：</strong><br> (1)通过下标访问：</p> 
<pre><code>#include&lt;iostream&gt;
#include&lt;stdio.h&gt;
#include&lt;string&gt;
using namespace std;

int main(){
    string str;
    cin&gt;&gt;str;
    for(int i = 0 ; i &lt; str.length() ; i++)
        printf("%c",str[i]);
    return 0;
}

</code></pre> 
<p>(2)通过迭代器访问：</p> 
<pre><code>#include&lt;iostream&gt;
#include&lt;stdio.h&gt;
#include&lt;string&gt;
using namespace std;

int main(){
    string str;
    cin&gt;&gt;str;
    for(string::iterator it = str.begin();it!=str.end();it++)
        printf("%c ",*it);
    return 0;
}

</code></pre> 
<p><strong>3、operator+=</strong><br> 可以将两个string直接拼接起来</p> 
<pre><code>#include&lt;iostream&gt;
#include&lt;stdio.h&gt;
#include&lt;string&gt;
using namespace std;

int main(){
    string str1,str2,str3;
    cin&gt;&gt;str1;
    cin&gt;&gt;str2;
    str3 = str1+str2;
    cout&lt;&lt;str3;
    return 0;
}

</code></pre> 
<p><strong>4、compare operator</strong><br> 两个string类型可以用==、!=、&lt;、&lt;=、&gt;、&gt;=来比较大小，比较的规则是字典序</p> 
<p><strong>5、length()/size()</strong><br> length()返回string的长度，即存放的字符数</p> 
<p><strong>6、insert()</strong><br> insert(pos,string)，在pos号位置插入string</p> 
<pre><code>#include&lt;iostream&gt;
#include&lt;stdio.h&gt;
#include&lt;string&gt;
using namespace std;

int main(){
    string str1,str2;
    cin&gt;&gt;str1;
    cin&gt;&gt;str2;
    str1.insert(2,str2);
    cout&lt;&lt;str1;
    return 0;
}

</code></pre> 
<p><img src="https://images2.imgbox.com/58/8f/EyjvSU9z_o.png" alt="在这里插入图片描述"><br> insert(it,it2,it3)：it为原字符串的欲插入的位置,it2,it3为待插入字符串的首位迭代器，表示串[it2,it3)被插入在it的位置上</p> 
<p><strong>7、erase()</strong><br> 删除单个元素：str.erase(it) it为需要删除的元素的迭代器</p> 
<pre><code>#include&lt;iostream&gt;
#include&lt;stdio.h&gt;
#include&lt;string&gt;
using namespace std;

int main(){
    string str = "abcdefg";
    str.erase(str.begin()+4);
    cout&lt;&lt;str;
    return 0;
}

</code></pre> 
<p>删除一个区间内的元素:str.erase(first,last)，删除区间[first,last)内的元素</p> 
<p>删除一个区间内的元素：str.erase(pos,length)，pos为需要开始删除元素的起始位置，length为删除的字符个数</p> 
<p><strong>8、clear()</strong><br> 清空string中的数据</p> 
<p><strong>9、substr()</strong><br> substr(pos,len)：从pos位开始，长度为len的字串</p> 
<pre><code>#include&lt;iostream&gt;
#include&lt;stdio.h&gt;
#include&lt;string&gt;
using namespace std;

int main(){
    string str = "Thank you for your smile.";
    cout&lt;&lt;str.substr(0,5)&lt;&lt;endl;//Thank
    cout&lt;&lt;str.substr(14,4)&lt;&lt;endl;//your
    cout&lt;&lt;str.substr(19,5)&lt;&lt;endl;//smile
    return 0;
}

</code></pre> 
<p><strong>10、string::npos</strong><br> string::npos是一个常数，其值本身为-1，但是由于是unsigned int类型，因此也可以认为是unsigned int的最大值。它用以作为find()函数失配的返回值</p> 
<p><strong>11、find()</strong><br> str.find(str2)：当str2是str的字串时，返回其在str中第一次出现的位置，如果str2不是str的字串就返回string::npos</p> 
<p>str.find(str2,pos)：从str的pos位开始匹配str2，返回值同上</p> 
<pre><code>#include&lt;iostream&gt;
#include&lt;stdio.h&gt;
#include&lt;string&gt;
using namespace std;

int main(){
    string str = "Thank you for your smile.";
    string str2 = "you";
    if(str.find(str2)!=string::npos){
        cout&lt;&lt;str.find(str2)&lt;&lt;endl;
    }
    return 0;
}

</code></pre> 
<p><strong>12、replace()</strong><br> str.replace(pos,len,str2)：把str从pos位开始、长度位len的字串替换位str2<br> str.replace(it1,it2,str2)：把str的迭代器[it1,it2)范围内的字串替换位str2</p> 
<pre><code>#include&lt;iostream&gt;
#include&lt;stdio.h&gt;
#include&lt;string&gt;
using namespace std;

int main(){
    string str = "Maybe you will turn around.";
    string str2 = "will not";
    string str3 = "surely";
    cout&lt;&lt;str.replace(10,4,str2)&lt;&lt;endl;
    cout&lt;&lt;str.replace(str.begin(),str.begin()+5,str3);
    return 0;
}

</code></pre> 
<p><img src="https://images2.imgbox.com/46/06/HvuWAnJY_o.png" alt="在这里插入图片描述"></p> 
<h2><a id="map_443"></a>四、map</h2> 
<p>map翻译为映射。map可以将任何基本类型(包括STL容器)映射为任何基本类型(包括STL容器)。使用map，需要添加#include&lt; map &gt;头文件以及using namespace std;</p> 
<p><strong>1、map定义</strong></p> 
<pre><code>map&lt;typename1,typename2&gt; mp; //第一个是键的类型，第二个是值的类型，键是唯一的
</code></pre> 
<p>如果是字符串到整型的映射，必须使用string而不是char数组</p> 
<pre><code>map&lt;string,int&gt; mp;
</code></pre> 
<p><strong>map中元素的访问：</strong><br> (1)通过键访问(键是唯一的)：</p> 
<pre><code>#include&lt;map&gt;
#include&lt;stdio.h&gt;
using namespace std;

int main(){
    map&lt;char,int&gt; mp;
    mp['c'] = 20;
    mp['c'] = 30;
    printf("%d\n",mp['c']);//30
    return 0;
}

</code></pre> 
<p>(2)通过迭代器进行访问</p> 
<pre><code>map&lt;typename1,typename2&gt;::iterator it;
</code></pre> 
<p>通过it-&gt;first访问键，通过it-&gt;second访问值</p> 
<pre><code>#include&lt;map&gt;
#include&lt;stdio.h&gt;
using namespace std;

int main(){
    map&lt;char,int&gt; mp;
    mp['m'] = 20;
    mp['r'] = 30;
    for(map&lt;char,int&gt;::iterator it = mp.begin();it!=mp.end();it++){
        printf("%c %d\n",it-&gt;first,it-&gt;second);
    }
    return 0;
}

</code></pre> 
<p>map的键会从小到大自动排序</p> 
<p><strong>3、find()：</strong><br> find(key)返回键为key的映射的迭代器</p> 
<pre><code>#include&lt;map&gt;
#include&lt;stdio.h&gt;
using namespace std;

int main(){
    map&lt;char,int&gt; mp;
    mp['m'] = 20;
    mp['r'] = 30;
    map&lt;char,int&gt;::iterator it = mp.find('m');
    printf("%c %d\n",it-&gt;first,it-&gt;second);//m 20
    return 0;
}

</code></pre> 
<p><strong>4、erase()</strong><br> 删除单个元素：mp.erase(it) it为要删除de 元素的迭代器</p> 
<p>删除单个元素：mp.erase(key)：key为欲删除的映射的键</p> 
<p>删除一个区间内的元素：mp.erase(first,last)，first和last均为迭代器，删除元素的区间为[first,last)</p> 
<p><strong>5、size()</strong><br> 获取map中映射的对数</p> 
<p><strong>6、clear()</strong><br> 清空map中的所有元素</p> 
<p><strong>常见用途：</strong></p> 
<ul><li>需要建立字符或者字符串与整数之间的映射的题目</li><li>判断大整数或者其他类型数据是否存在的题目，可以将map当做bool数组使用</li></ul> 
<p>注意：map的键和值是一一对应的，如果想要一个键对应多个值，需要使用multimap</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/1b6783e8402a90307f137de97a2cc6b1/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">JDK、JRE、JVM区别与联系</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/1b029bb74bff8174749b63cfd28dd8b4/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">vsCode 控制是否显示悬停提示&#43;插件推荐&#43;快捷键</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>