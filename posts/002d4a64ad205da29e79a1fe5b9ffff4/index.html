<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>【Java多线程】死锁问题 - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="【Java多线程】死锁问题" />
<meta property="og:description" content="死锁 死锁的理解：不同的线程分别占用对方需要的同步资源不放弃，都在等待对方放弃自己需要的同步资源，就形成了线程的死锁。
说明：
1.出现死锁后，不会出现异常，不会出现提示，只是所有的线程都处于 阻塞状态，无法继续。
2.我们使用同步时，要避免出现死锁
解决方法 专门的算法、原则
尽量减少同步资源的定义
尽量避免嵌套同步
=========================================================================
首先我们看两张图理解一下JDK中用Thread.State类定义了线程的几种状态：
要想实现多线程，必须在主线程中创建新的线程对象。Java语言使用Thread类及其子类的对象来表示线程，在它的一个完整的生命周期中通常要经历如下的五种状态：
新建： 当一个Thread类或其子类的对象被声明并创建时，新生的线程对象处于新建状态
就绪：处于新建状态的线程被start()后，将进入线程队列等待CPU时间片，此时它已具备了运行的条件，只是没分配到CPU资源
运行：当就绪的线程被调度并获得CPU资源时,便进入运行状态， run()方法定义了线 程的操作和功能
阻塞：在某种特殊情况下，被人为挂起或执行输入输出操作时，让出 CPU 并临时中止自己的执行，进入阻塞状态
死亡：线程完成了它的全部工作或线程被提前强制性地中止或出现异常导致结束
1：线程的生命周期
2：线程的转换：
=========================================================================
下面关于死锁问题演示说明
代码如下：
public class ThreadTest { public static void main(String[] args) { StringBuffer s1 = new StringBuffer(); StringBuffer s2 = new StringBuffer(); new Thread(){ @Override public void run() { synchronized (s1){ s1.append(&#34;a&#34;); s2.append(&#34;1&#34;); try { Thread.sleep(100); } catch (InterruptedException e) { e.printStackTrace(); } synchronized (s2){ s1." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/002d4a64ad205da29e79a1fe5b9ffff4/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-02-05T21:09:49+08:00" />
<meta property="article:modified_time" content="2023-02-05T21:09:49+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">【Java多线程】死锁问题</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <h2><strong>死锁</strong></h2> 
<p><strong>死锁的理解</strong>：不同的线程分别占用对方需要的同步资源不放弃，都在等待对方放弃自己需要的同步资源，就形成了线程的死锁。</p> 
<p><strong>说明</strong>：</p> 
<p>1.出现死锁后，不会出现异常，不会出现提示，只是所有的线程都处于 阻塞状态，无法继续。</p> 
<p>2.我们使用同步时，要避免出现死锁</p> 
<h2><span style="color:#fe2c24;"><strong>解决方法</strong></span></h2> 
<p>专门的算法、原则</p> 
<p>尽量减少同步资源的定义</p> 
<p>尽量避免嵌套同步</p> 
<p>=========================================================================</p> 
<p><strong>首先我们看两张图理解一下JDK中用Thread.State类定义了线程的几种状态：</strong></p> 
<p>要想实现多线程，必须在主线程中创建新的线程对象。Java语言使用Thread类及其子类的对象来表示线程，在它的一个完整的生命周期中通常要经历如下的五种状态：</p> 
<p><span style="color:#fe2c24;"><strong>新建</strong>：</span> 当一个Thread类或其子类的对象被声明并创建时，新生的线程对象处于新建状态</p> 
<p><span style="color:#fe2c24;"><strong>就绪：</strong></span>处于新建状态的线程被start()后，将进入线程队列等待CPU时间片，此时它已具备了运行的条件，只是没分配到CPU资源</p> 
<p><span style="color:#fe2c24;"><strong>运行：</strong></span>当就绪的线程被调度并获得CPU资源时,便进入运行状态， run()方法定义了线 程的操作和功能</p> 
<p><span style="color:#fe2c24;"><strong>阻塞：</strong></span>在某种特殊情况下，被人为挂起或执行输入输出操作时，让出 CPU 并临时中止自己的执行，进入阻塞状态</p> 
<p><span style="color:#fe2c24;"><strong>死亡：</strong></span>线程完成了它的全部工作或线程被提前强制性地中止或出现异常导致结束</p> 
<p>1：线程的生命周期</p> 
<p><img alt="" height="577" src="https://images2.imgbox.com/08/c4/HPFP5cgG_o.png" width="1200"></p> 
<p>2：线程的转换：</p> 
<p><img alt="" height="460" src="https://images2.imgbox.com/12/02/uIfmnQmH_o.png" width="1048"></p> 
<p></p> 
<p><strong>=========================================================================</strong></p> 
<p><strong>下面关于死锁问题演示说明</strong></p> 
<p>代码如下：</p> 
<pre><code class="language-java">public class ThreadTest {
    public static void main(String[] args) {

        StringBuffer s1 = new StringBuffer();
        StringBuffer s2 = new StringBuffer();

        new Thread(){
            @Override
            public void run() {

                synchronized (s1){
                    s1.append("a");
                    s2.append("1");

                    try {
                        Thread.sleep(100);
                    } catch (InterruptedException e) {
                        e.printStackTrace();
                    }
                    synchronized (s2){
                        s1.append("b");
                        s2.append("2");

                        System.out.println(s1);
                        System.out.println(s2);
                    }
                }
            }
        }.start();

        new Thread(new Runnable() {
            @Override
            public void run() {
                synchronized (s2){
                    s1.append("c");
                    s2.append("3");
                    try {
                        Thread.sleep(100);
                    } catch (InterruptedException e) {
                        e.printStackTrace();
                    }

                    synchronized (s1){
                        s1.append("d");
                        s2.append("4");

                        System.out.println(s1);
                        System.out.println(s2);
                    }
                }
            }
        }){}.start();
    }
}</code></pre> 
<p>运行结果如图：</p> 
<p><img alt="" height="847" src="https://images2.imgbox.com/2b/fa/Y5bNW4ad_o.png" width="1200"></p> 
<p>我们可以看到，程序既不报异常也不会终止。</p> 
<p>可以再看下面这个例子理解一下 </p> 
<pre><code class="language-java">class A {
	public synchronized void foo(B b) {
		System.out.println("当前线程名: " + Thread.currentThread().getName()
				+ " 进入了A实例的foo方法"); // ①
		try {
			Thread.sleep(200);
		} catch (InterruptedException ex) {
			ex.printStackTrace();
		}
		System.out.println("当前线程名: " + Thread.currentThread().getName()
				+ " 企图调用B实例的last方法"); // ③
		b.last();
	}

	public synchronized void last() {
		System.out.println("进入了A类的last方法内部");
	}
}

class B {
	public synchronized void bar(A a) {
		System.out.println("当前线程名: " + Thread.currentThread().getName()
				+ " 进入了B实例的bar方法"); // ②
		try {
			Thread.sleep(200);
		} catch (InterruptedException ex) {
			ex.printStackTrace();
		}
		System.out.println("当前线程名: " + Thread.currentThread().getName()
				+ " 企图调用A实例的last方法"); // ④
		a.last();
	}

	public synchronized void last() {
		System.out.println("进入了B类的last方法内部");
	}
}

public class DeadLock implements Runnable {
	A a = new A();
	B b = new B();

	public void init() {
		Thread.currentThread().setName("主线程");
		// 调用a对象的foo方法
		a.foo(b);
		System.out.println("进入了主线程之后");
	}

	public void run() {
		Thread.currentThread().setName("副线程");
		// 调用b对象的bar方法
		b.bar(a);
		System.out.println("进入了副线程之后");
	}

	public static void main(String[] args) {
		DeadLock dl = new DeadLock();
		new Thread(dl).start();
		dl.init();
	}
}
</code></pre> 
<p><span style="color:#fe2c24;"><strong>感谢观看！！！</strong></span></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/d13740e337c5cce1b554e8d7e3adc865/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">华清远见学习—“进制之间的转换”</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/a27c009222f254f1ae44407c816fc8d7/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">strapi和gridesome 博客发布记录</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>