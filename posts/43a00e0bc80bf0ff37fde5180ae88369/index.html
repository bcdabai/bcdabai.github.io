<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Spring 中 HttpServletRequest 作为成员变量是安全的吗？ - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Spring 中 HttpServletRequest 作为成员变量是安全的吗？" />
<meta property="og:description" content="在使用spring框架开发的时候，经常会在controller类中看到 HttpServletRequest 对象参数，一般我们都是直接使用，但是它是何时、怎么注入到 spring 容器的呢 ？另外以成员变量注入的 request 是线程安全的吗 ?
@Controller public class SomeController { @Resource private HttpServletRequest request1; @RequestMapping(&#34;/test&#34;) public String test2(HttpServletRequest request2) { System.out.println(request1.getQueryString()); System.out.println(request2.getQueryString()); return &#34;&#34;; } } 1、request 成员变量是否线程安全 ？ 先说结论：注入request这个成员变量是线程安全的，来看下 spring 是如何做到的，先 debug 看下两种做法真实注入类的区别
可以看出成员变量注入的是代理对象AutowireUtils.ObjectFactoryDelegatingInvocationHandler ，而作为方法参数注入的就是我们一般使用的Request对象，先看下 AutowireUtils 的内部类ObjectFactoryDelegatingInvocationHandler
/** * Reflective InvocationHandler for lazy access to the current target object. */ @SuppressWarnings(&#34;serial&#34;) private static class ObjectFactoryDelegatingInvocationHandler implements InvocationHandler, Serializable { private final ObjectFactory&lt;?&gt; objectFactory; public ObjectFactoryDelegatingInvocationHandler(ObjectFactory&lt;?" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/43a00e0bc80bf0ff37fde5180ae88369/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2024-01-17T15:07:28+08:00" />
<meta property="article:modified_time" content="2024-01-17T15:07:28+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Spring 中 HttpServletRequest 作为成员变量是安全的吗？</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p>        在使用spring框架开发的时候，经常会在controller类中看到 <span style="color:#000000;">HttpServletRequest 对象参数，一般我们都是直接使用，但是它是何时、怎么注入到 spring 容器的呢 ？另外以成员变量注入的 request 是线程安全的吗 ?</span></p> 
<pre><code>@Controller
public class SomeController {
    
    @Resource
    private HttpServletRequest request1;

    @RequestMapping("/test")
    public String test2(HttpServletRequest request2) {
        System.out.println(request1.getQueryString());
        System.out.println(request2.getQueryString());
        return "";
    }
	
}</code></pre> 
<h4> 1、request 成员变量是否线程安全 ？</h4> 
<p>       先说结论：注入request这个成员变量是线程安全的，来看下 spring 是如何做到的，先 debug 看下两种做法真实注入类的区别</p> 
<p><img alt="" height="529" src="https://images2.imgbox.com/97/4c/eJIUSEyi_o.png" width="1000"></p> 
<p>      可以看出成员变量注入的是代理对象AutowireUtils.ObjectFactoryDelegatingInvocationHandler ，而作为方法参数注入的就是我们一般使用的Request对象，先看下 AutowireUtils 的内部类ObjectFactoryDelegatingInvocationHandler</p> 
<pre><code class="language-java">/**
 * Reflective InvocationHandler for lazy access to the current target object.
 */
@SuppressWarnings("serial")
private static class ObjectFactoryDelegatingInvocationHandler implements InvocationHandler, Serializable {

    private final ObjectFactory&lt;?&gt; objectFactory;

    public ObjectFactoryDelegatingInvocationHandler(ObjectFactory&lt;?&gt; objectFactory) {
        this.objectFactory = objectFactory;
    }

    @Override
    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
        String methodName = method.getName();
        if (methodName.equals("equals")) {
            // Only consider equal when proxies are identical.
            return (proxy == args[0]);
        } else if (methodName.equals("hashCode")) {
            // Use hashCode of proxy.
            return System.identityHashCode(proxy);
        } else if (methodName.equals("toString")) {
            return this.objectFactory.toString();
        }

        try {
            return method.invoke(this.objectFactory.getObject(), args);
        }catch (InvocationTargetException ex) {
            throw ex.getTargetException();
        }
     }
}   
</code></pre> 
<p style="margin-left:0;">        当代理对象的方法被调用时，除去少数几个方法，大部分的情况都是通过<strong>this.objectFactory.getObject() </strong>获取被代理对象，再调用被代理对象的相应方法</p> 
<p><img alt="" height="241" src="https://images2.imgbox.com/47/22/XeXTf5pN_o.png" width="828"></p> 
<p style="margin-left:0;">        进一步 debug，终于看到了熟悉的Request类，可以看到它是从 <strong>requestAttributesHolder </strong>中取到的，那么requestAttributesHolder又是什么？</p> 
<p style="margin-left:0;"><img alt="" height="222" src="https://images2.imgbox.com/89/8e/AXc9d1lC_o.png" width="975">        RequestContextHolder的<strong>ThreadLocal成员变量</strong>就是实现的关键所在，它存放了每个线程对应的Request对象，因此在@Controller中调用作为成员变量注入的<strong>代理类的方法</strong>时，最终可以取到当前线程相对应的Request对象，并调用<strong>Request对应的方法</strong>，这样@Controller中的成员变量不需要重复注入（它一直都是最初bean初始化时注入的代理类），也避免了线程不安全的问题。</p> 
<h4 style="margin-left:0px;">2、<strong>spring是何时将Request放入这个ThreadLocal之中的 ？      </strong></h4> 
<p>        同样先说结论：在 Springmvc 的 dispatcherServlet 的父类 FrameworkServlet 里完成的，分析代码实现</p> 
<p><img alt="" height="524" src="https://images2.imgbox.com/04/13/IgZygzqp_o.png" width="802"></p> 
<p style="margin-left:0;">        所有的请求调用到 Servlet 的doGet、dePost 时，最终都会通过 <strong>processRequest(request, response) </strong>进行处理</p> 
<p style="margin-left:0;"><img alt="" height="448" src="https://images2.imgbox.com/cc/f1/cmJoUt26_o.png" width="908"></p> 
<p style="margin-left:0;"><strong>        processRequest </strong>方法在调用了 <strong>initContextHolders(request, localeContext, requestAttributes) </strong>时会将Request放入ThreadLocal，方便后续线程安全的获取</p> 
<p style="margin-left:0;"><img alt="" height="259" src="https://images2.imgbox.com/10/82/kTPNjvjQ_o.png" width="901"></p> 
<h4 style="margin-left:0px;"><strong>3、总结</strong></h4> 
<blockquote> 
 <p>        1、在bean中注入<strong>成员变量 </strong>HttpServletRequest 时，实际注入的是 spring 框架生成的代理对象 <strong>ObjectFactoryDelegatingInvocationHandler </strong>的实例。在我们实际调用这个成员变量的方法时，会调用 objectFactory 的 getObject() 对象对应的方法（objectFactory 是<strong>RequestObjectFactory </strong>这个类的对象）</p> 
 <p></p> 
 <p>        2、RequestObjectFactory 的 getObject 方法是从<strong>RequestContextHolder</strong>的<strong>threadlocal </strong>中去取值的。</p> 
 <p></p> 
 <p>        3、请求刚进入 springmvc 的 <strong>dispatcherServlet </strong>时，会把 request 相关对象设置到RequestContextHolder 的 threadlocal 中去，方便后续线程安全的获取</p> 
</blockquote>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/81e5f2deecd548b0668802d2de3a4dad/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">水质净化厂物联网远程监控系统解决方案</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/26e862a813dec3087089f0ebf500a610/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">Docker consul、容器服务更新与发现</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>