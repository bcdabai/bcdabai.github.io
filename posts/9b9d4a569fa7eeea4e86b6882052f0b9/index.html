<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>windows使用detours实现进程拦截实操 - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="windows使用detours实现进程拦截实操" />
<meta property="og:description" content="Detours是微软开发的一个函数库，可用于捕获系统API。可以从github下载源码并编译。Detours通过更改被拦截的API函数的跳转地址为用户自定义的函数地址来实现拦截。比如我们知道要拦截API函数A,我们需要自定义一个函数B,在实现拦截之前,此时函数A所在的线程正常调用A。开始拦截的时候,Detours库函数将A的入口地址修改为B的函数指针。此前线程对函数A的调用将会被替换为被函数B的调用,当然前提是函数A和函数B的函数签名完全一致。在将函数A的入口地址修改函数B的地址时已经保留了函数A的原始地址,所以函数B的函数形式形如
void* funcB(arg1,arg2,...){
void* retPtr= funcA(arg1,arg2,...)
}
所以我们在函数B中能做的事情就是拦截并修改目标函数参数或者修改原函数的返回值。那么我们如何拦截一个进程的命令行参数呢。在windows系统中,进程是存在父子关系的树状结构。每一个子进程都由它的父进程所创建。一般的 我们都是在资源管理器中点击程序的exe可执行文件来启动进程,那么此时资源管理器进程(explorer.exe) 就是被启动进程的父进程,还有我们熟悉的命令行程序cmd.exe,还有开发者们常用的开发工具如idea,visual studio,eclipse 等等都扮演着父进程的角色。父进程一般通过CreateProcess来创建子程,CreateProcess函数通过命令行参数即可以启动子进程。所以拦截进程的创建和启动就是通过拦截父进程中CreateProcess函数的参数和返回值来实现。我们要实现的函数B需要在一个独立的dll中实现,这个dll可以通过detours工具setdll.exe插入目标父进程的导入表
或者detours工具withdll.exe启动时被目标父进程加载到进程空间,
以下的例子程序通过拦截idea64.exe中的CreateProcess函数 实现打印CreateProcess函数的命令行参数。如果原函数CreateProcess为A，那么MyCreateProcessW则为B。
// dllmain.cpp : 定义 DLL 应用程序的入口点。
#include &#34;stdafx.h&#34;
#include &lt;stdio.h&gt;
#include &lt;windows.h&gt;
#include &#34;detours.h&#34;
#pragma comment(lib,&#34;detours.lib&#34;)
typedef BOOL(WINAPI* PMyCreateProcessW)(
_In_opt_ LPCWSTR lpApplicationName,
_Inout_opt_ LPWSTR lpCommandLine,
_In_opt_ LPSECURITY_ATTRIBUTES lpProcessAttributes,
_In_opt_ LPSECURITY_ATTRIBUTES lpThreadAttributes,
_In_ BOOL bInheritHandles,
_In_ DWORD dwCreationFlags,
_In_opt_ LPVOID lpEnvironment,
_In_opt_ LPCWSTR lpCurrentDirectory,
_In_ LPSTARTUPINFOW lpStartupInfo,
_Out_ LPPROCESS_INFORMATION lpProcessInformation
);
PMyCreateProcessW gOldCreateProcessW = NULL;" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/9b9d4a569fa7eeea4e86b6882052f0b9/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-04-26T00:04:26+08:00" />
<meta property="article:modified_time" content="2022-04-26T00:04:26+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">windows使用detours实现进程拦截实操</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p>Detours是微软开发的一个函数库，可用于捕获系统API。可以从github下载源码并编译。Detours通过更改被拦截的API函数的跳转地址为用户自定义的函数地址来实现拦截。比如我们知道要拦截API函数A,我们需要自定义一个函数B,在实现拦截之前,此时函数A所在的线程正常调用A。开始拦截的时候,Detours库函数将A的入口地址修改为B的函数指针。此前线程对函数A的调用将会被替换为被函数B的调用,当然前提是函数A和函数B的函数签名完全一致。在将函数A的入口地址修改函数B的地址时已经保留了函数A的原始地址,所以函数B的函数形式形如</p> 
<p>void* funcB(arg1,arg2,...){<!-- --></p> 
<p>void* retPtr= funcA(arg1,arg2,...)</p> 
<p>}</p> 
<p>所以我们在函数B中能做的事情就是拦截并修改目标函数参数或者修改原函数的返回值。那么我们如何拦截一个进程的命令行参数呢。在windows系统中,进程是存在父子关系的树状结构。每一个子进程都由它的父进程所创建。一般的 我们都是在资源管理器中点击程序的exe可执行文件来启动进程,那么此时资源管理器进程(explorer.exe) 就是被启动进程的父进程,还有我们熟悉的命令行程序cmd.exe,还有开发者们常用的开发工具如idea,visual studio,eclipse 等等都扮演着父进程的角色。父进程一般通过CreateProcess来创建子程,CreateProcess函数通过命令行参数即可以启动子进程。所以拦截进程的创建和启动就是通过拦截父进程中CreateProcess函数的参数和返回值来实现。我们要实现的函数B需要在一个独立的dll中实现,这个dll可以通过detours工具setdll.exe插入目标父进程的导入表</p> 
<p><img alt="" height="180" src="https://images2.imgbox.com/3c/5b/MIqX5qLa_o.png" width="657"></p> 
<p> 或者detours工具withdll.exe启动时被目标父进程加载到进程空间,</p> 
<p><img alt="" height="165" src="https://images2.imgbox.com/2f/c9/2XKBCdw7_o.png" width="632"></p> 
<p> </p> 
<p><strong>以下的例子程序通过拦截idea64.exe中的CreateProcess函数 实现打印CreateProcess函数的命令行参数。如果原函数CreateProcess为A，那么MyCreateProcessW则为B。</strong></p> 
<p>// dllmain.cpp : 定义 DLL 应用程序的入口点。</p> 
<p>#include "stdafx.h"<br> #include &lt;stdio.h&gt;<br> #include &lt;windows.h&gt;<br> #include "detours.h"<br> #pragma comment(lib,"detours.lib")</p> 
<p>typedef BOOL(WINAPI* PMyCreateProcessW)(<br>     _In_opt_ LPCWSTR lpApplicationName,<br>     _Inout_opt_ LPWSTR lpCommandLine,<br>     _In_opt_ LPSECURITY_ATTRIBUTES lpProcessAttributes,<br>     _In_opt_ LPSECURITY_ATTRIBUTES lpThreadAttributes,<br>     _In_ BOOL bInheritHandles,<br>     _In_ DWORD dwCreationFlags,<br>     _In_opt_ LPVOID lpEnvironment,<br>     _In_opt_ LPCWSTR lpCurrentDirectory,<br>     _In_ LPSTARTUPINFOW lpStartupInfo,<br>     _Out_ LPPROCESS_INFORMATION lpProcessInformation<br>     );</p> 
<p>PMyCreateProcessW gOldCreateProcessW = NULL;</p> 
<p><br> BOOL<br> WINAPI<br> MyCreateProcessW(<br>     _In_opt_ LPCWSTR lpApplicationName,<br>     _Inout_opt_ LPWSTR lpCommandLine,<br>     _In_opt_ LPSECURITY_ATTRIBUTES lpProcessAttributes,<br>     _In_opt_ LPSECURITY_ATTRIBUTES lpThreadAttributes,<br>     _In_ BOOL bInheritHandles,<br>     _In_ DWORD dwCreationFlags,<br>     _In_opt_ LPVOID lpEnvironment,<br>     _In_opt_ LPCWSTR lpCurrentDirectory,<br>     _In_ LPSTARTUPINFOW lpStartupInfo,<br>     _Out_ LPPROCESS_INFORMATION lpProcessInformation<br> ) {<!-- --><br>     printf("lpApplicationName:【%ls】,lpCommandLine【%ls】\n\n", lpApplicationName, lpCommandLine);<br>     return gOldCreateProcessW(lpApplicationName, lpCommandLine, lpProcessAttributes, lpThreadAttributes,<br>         bInheritHandles, dwCreationFlags, lpEnvironment, lpCurrentDirectory, lpStartupInfo, lpProcessInformation<br>         );<br> }</p> 
<p>void Hook(){<!-- --><br>     AllocConsole();<br>     freopen("CON", "r", stdin);<br>     freopen("CON", "w", stdout);<br>     DetourTransactionBegin();<br>     DetourUpdateThread(GetCurrentThread());<br>     gOldCreateProcessW = (PMyCreateProcessW)DetourFindFunction("kernel32.dll", "CreateProcessW");<br>     DetourAttach(&amp;gOldCreateProcessW,MyCreateProcessW);<br>     LONG ret = DetourTransactionCommit();<br> }</p> 
<p>BOOL APIENTRY DllMain( HMODULE hModule,<br>                        DWORD  ul_reason_for_call,<br>                        LPVOID lpReserved<br>                      )<br> {<!-- --><br>     switch (ul_reason_for_call)<br>     {<!-- --><br>     case DLL_PROCESS_ATTACH:<br>         //printf("命令行参数:%s\n", GetCommandLineA());<br>         //MessageBoxA(NULL, GetCommandLineA(),GetCommandLineA(),MB_OK);<br>         Hook();<br>     case DLL_THREAD_ATTACH:<br>     case DLL_THREAD_DETACH:<br>     case DLL_PROCESS_DETACH:<br>         break;<br>     }<br>     return TRUE;<br> }</p> 
<p>extern "C" _declspec(dllexport) void _stdcall add() {<!-- --><br>     printf("zzz\n");<br> }</p> 
<p>//CreateProcessW</p> 
<p><strong>编译后得到DetourJavaCDemo.dll</strong></p> 
<p><img alt="" height="342" src="https://images2.imgbox.com/08/0a/h3wtXyik_o.png" width="875"></p> 
<p><span style="color:#0d0016;"><strong>此时 我们使用setdll.exe将编译好的dll插入idea64.exe的导入表</strong></span></p> 
<p><span style="color:#fe2c24;"><strong>D:\test4\Detours\bin.X64\setdll /d:D:\Users\DELL\source\repos\DetourJavaCDemo\x64\Release\DetourJavaCDemo.dll "C:\Program Files\JetBrains\IntelliJ IDEA 2017.3.5\bin\idea64.exe" </strong></span></p> 
<p><img alt="" height="105" src="https://images2.imgbox.com/41/35/Wpv4HzYv_o.png" width="982"></p> 
<p>当然最好是使用管理员权限运行命令、否则报出无权访问(error:5)</p> 
<p><img alt="" height="193" src="https://images2.imgbox.com/e8/cb/GK2hMymZ_o.png" width="887"></p> 
<p> </p> 
<p> 成功将dll插入idea64.exe的导入表之后,生成了idea64.exe~,idea64.exe~则是 idea64.exe被插入前的备份</p> 
<p> <img alt="" height="83" src="https://images2.imgbox.com/9f/8f/JANUXsjY_o.png" width="360"></p> 
<p></p> 
<p><strong> 下面再以withdll启动idea64.exe</strong></p> 
<p><img alt="" height="101" src="https://images2.imgbox.com/03/17/073YmYQL_o.png" width="924"></p> 
<p><img alt="" height="512" src="https://images2.imgbox.com/5d/e5/0s0QkDTQ_o.png" width="1111"><strong> 由于上面代码中使用</strong></p> 
<p> <strong><span style="color:#fe2c24;">  AllocConsole();<br>     freopen("CON", "r", stdin);<br>     freopen("CON", "w", stdout);</span></strong></p> 
<p><strong><span style="color:#fe2c24;">为idea64分配了一个控制台窗口。可以看出由idea64启动的子进程命令行参数被打印了出来。</span></strong></p> 
<p> </p> 
<p> </p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/0339ddb1f4c41c6d80bb977748a382b4/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">C&#43;&#43;程序异常退出问题总结</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/f3e849c7e135eca0f42c5f31d36aa151/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">jquery粒子动画鼠标视差js特效</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>