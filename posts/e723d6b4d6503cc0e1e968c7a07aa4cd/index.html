<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Pandas参考手册、常用函数及方法汇总 - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Pandas参考手册、常用函数及方法汇总" />
<meta property="og:description" content="一、入门与升级宝典 如果个人时间充裕，可以去官网查看文档信息
官网链接：pandas - Python Data Analysis Library
pandas参考文档：pandas documentation — pandas 1.3.3 documentation
二、常用的函数和方法 创建测试对象：
pd.DataFrame(np.random.rand(20,5))：创建20行5列的随机数组成的DataFrame对象pd.Series(my_list)：从可迭代对象my_list创建一个Series对象df.index = pd.date_range(&#39;1900/1/30&#39;, periods=df.shape[0])：增加一个日期索引 df为某个读入进来的数据帧。
需知：
axis的参数：0（index） 逐行 1 (column) 逐列
1.导入数据
pd.read_csv(filename)：从CSV文件导入数据
pd.read_table(filename)：从限定分隔符的文本文件导入数据
pd.read_excel(filename)：从Excel文件导入数据
pd.read_sql(query, connection_object)：从SQL表/库导入数据
pd.read_json(json_string)：从JSON格式的字符串导入数据
pd.read_html(url)：解析URL、字符串或者HTML文件，抽取其中的tables表格
pd.read_clipboard()：从你的粘贴板获取内容，并传给read_table()
pd.DataFrame(dict)：从字典对象导入数据，Key是列名，Value是数据
pd.ExcelFile(Filename): 从Excel中读取数据，sheet_names查看相应sheet, parse方法解析某个sheet
2.导出数据
df.to_csv(filename)：导出数据到CSV文件df.to_excel(filename)：导出数据到Excel文件df.to_sql(table_name, connection_object)：导出数据到SQL表。注意：dtype可以指定输出字段的格式，如df.to_sql(&#39;test&#39;,con=engine,dtype={&#39;A&#39;:Integer(),&#39;B&#39;:DateTime()})df.to_json(filename)：以Json格式导出数据到文本文件writer=pd.ExcelWriter(&#39;test.xlsx&#39;) ：然后调用df1.to_excel(writer,sheet_name=&#39;单位&#39;,index=False) 和 writer.save()，将多个数据帧写入同一个工作簿的多个sheet(工作表) 3.查看、检查数据
df.head(n)：查看DataFrame对象的前n行df.tail(n)：查看DataFrame对象的最后n行df.shape()：查看行数和列数df.info()：查看索引、数据类型和内存信息df.columns():查看字段（首行）名称df.describe()：查看数值型列的汇总统计s.value_counts(dropna=False)：查看Series对象的唯一值和计数df.apply(pd.Series.value_counts)：查看DataFrame对象中每一列的唯一值和计数df.isnull().any(): 查看是否有缺失值df[df[column_name].duplicated()]:查看column_name字段数据重复的数据信息df[df[column_name].duplicated()].count():查看column_name字段数据重复的个数df[col1].unique() :查看col1字段的唯一值df[col1].nunique():查看col1字段唯一值个数 4.数据选取
df[col]：根据列名，并以Series的形式返回列df[[col1, col2]]：以DataFrame形式返回多列s.iloc[0]：按位置选取数据s.loc[&#39;index_one&#39;]：按索引选取数据df.iloc[0,:]：返回第一行df.iloc[0,0]：返回第一列的第一个元素df.loc[0,:] ： 返回第一行（索引为默认的数字时，用法同df.iloc），但需要注意的是loc是按索引,iloc参数只接受数字参数df.ix[[:5],[&#34;col1&#34;,&#34;col2&#34;]] ： 返回字段为col1和col2的前5条数据，可以理解为loc和iloc的结合体。df.at[5,&#34;col1&#34;] ：选择索引名称为5，字段名称为col1的数据df.iat[5,0] ： 选择索引排序为5，字段排序为0的数据data.str.contains(&#34;s&#34;) ： 数据中含有&#34;s&#34;字符串的数据data.astype(int).isin(list1) ：数据的某条数据的某个字段在列表list1中的数据df[-df[column_name].duplicated()] ：选取column_name字段不重复的数据，支持df[-df.duplicated()]df.loc[df[&#39;col_name&#39;]==value,:]：选取col_name字段为value的数据df.loc[df[&#39;col_name&#39;].isin(value_list),:]：选取col_name字段为value_list中的值的数据 df.loc[~df[&#39;col_name&#39;].isin(value_list),:]：选取col_name字段不在value_list中的值的数据df.loc[(df[&#39;col_name1&#39;] == value1) &amp; df[&#39;col_name2&#39;].isin(value_list)]：选取col_name1等于value1，并且col_name2在value_list中的数据df.loc[(df[&#39;col_name1&#39;] == value1) | df[&#39;col_name2&#39;]." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/e723d6b4d6503cc0e1e968c7a07aa4cd/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-12-27T16:37:20+08:00" />
<meta property="article:modified_time" content="2022-12-27T16:37:20+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Pandas参考手册、常用函数及方法汇总</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <h4 id="%E4%B8%80%E3%80%81%E5%85%A5%E9%97%A8%E4%B8%8E%E5%8D%87%E7%BA%A7%E5%AE%9D%E5%85%B8">一、入门与升级宝典</h4> 
<p>如果个人时间充裕，可以去官网查看文档信息</p> 
<p>官网链接：<a href="http://pandas.pydata.org" rel="nofollow" title="pandas - Python Data Analysis Library">pandas - Python Data Analysis Library</a></p> 
<p>pandas参考文档：<a href="http://pandas.pydata.org/pandas-docs/stable/index.html" rel="nofollow" title="pandas documentation — pandas 1.3.3 documentation">pandas documentation — pandas 1.3.3 documentation</a></p> 
<h4 id="%E4%BA%8C%E3%80%81%E5%B8%B8%E7%94%A8%E7%9A%84%E5%87%BD%E6%95%B0%E5%92%8C%E6%96%B9%E6%B3%95">二、常用的函数和方法</h4> 
<p>创建测试对象：</p> 
<ul><li>pd.DataFrame(np.random.rand(20,5))：创建20行5列的随机数组成的DataFrame对象</li><li>pd.Series(my_list)：从可迭代对象my_list创建一个Series对象</li><li>df.index = pd.date_range('1900/1/30', periods=df.shape[0])：增加一个日期索引</li></ul> 
<p>df为某个读入进来的数据帧。</p> 
<p>需知：</p> 
<p>       axis的参数：0（index）  逐行   </p> 
<p>                           1 (column)   逐列</p> 
<p><strong>1.导入数据</strong></p> 
<ul><li> <p>pd.read_csv(filename)：从CSV文件导入数据</p> </li><li> <p>pd.read_table(filename)：从限定分隔符的文本文件导入数据</p> </li><li> <p>pd.read_excel(filename)：从Excel文件导入数据</p> </li><li> <p>pd.read_sql(query, connection_object)：从SQL表/库导入数据</p> </li><li> <p>pd.read_json(json_string)：从JSON格式的字符串导入数据</p> </li><li> <p>pd.read_html(url)：解析URL、字符串或者HTML文件，抽取其中的tables表格</p> </li><li> <p>pd.read_clipboard()：从你的粘贴板获取内容，并传给read_table()</p> </li><li> <p>pd.DataFrame(dict)：从字典对象导入数据，Key是列名，Value是数据</p> </li><li> <p>pd.ExcelFile(Filename): 从Excel中读取数据，sheet_names查看相应sheet, parse方法解析某个sheet</p> </li></ul> 
<p><strong>2.导出数据</strong></p> 
<ul><li>df.to_csv(filename)：导出数据到CSV文件</li><li>df.to_excel(filename)：导出数据到Excel文件</li><li>df.to_sql(table_name, connection_object)：导出数据到SQL表。注意：dtype可以指定输出字段的格式，如df.to_sql('test',con=engine,dtype={'A':Integer(),'B':DateTime()})</li><li>df.to_json(filename)：以Json格式导出数据到文本文件</li><li>writer=pd.ExcelWriter('test.xlsx')  ：然后调用df1.to_excel(writer,sheet_name='单位',index=False) 和 writer.save()，将多个数据帧写入同一个工作簿的多个sheet(工作表)</li></ul> 
<p><strong>3.查看、检查数据</strong></p> 
<ul><li>df.head(n)：查看DataFrame对象的前n行</li><li>df.tail(n)：查看DataFrame对象的最后n行</li><li>df.shape()：查看行数和列数</li><li>df.info()：查看索引、数据类型和内存信息</li><li>df.columns():查看字段（首行）名称</li><li>df.describe()：查看数值型列的汇总统计</li><li>s.value_counts(dropna=False)：查看Series对象的唯一值和计数</li><li>df.apply(pd.Series.value_counts)：查看DataFrame对象中每一列的唯一值和计数</li><li>df.isnull().any(): 查看是否有缺失值</li><li>df[df[column_name].duplicated()]:查看column_name字段数据重复的数据信息</li><li>df[df[column_name].duplicated()].count():查看column_name字段数据重复的个数</li><li>df[col1].unique() :查看col1字段的唯一值</li><li>df[col1].nunique():查看col1字段唯一值个数</li></ul> 
<p><strong>4.数据选取</strong></p> 
<ul><li>df[col]：根据列名，并以Series的形式返回列</li><li>df[[col1, col2]]：以DataFrame形式返回多列</li><li>s.iloc[0]：按位置选取数据</li><li>s.loc['index_one']：按索引选取数据</li><li>df.iloc[0,:]：返回第一行</li><li>df.iloc[0,0]：返回第一列的第一个元素</li><li>df.loc[0,:] ： 返回第一行（索引为默认的数字时，用法同df.iloc），但需要注意的是loc是按索引,iloc参数只接受数字参数</li><li>df.ix[[:5],["col1","col2"]] ： 返回字段为col1和col2的前5条数据，可以理解为loc和iloc的结合体。</li><li>df.at[5,"col1"] ：选择索引名称为5，字段名称为col1的数据</li><li>df.iat[5,0]  ： 选择索引排序为5，字段排序为0的数据</li><li>data.str.contains("s") ： 数据中含有"s"字符串的数据</li><li>data.astype(int).isin(list1) ：数据的某条数据的某个字段在列表list1中的数据</li><li>df[-df[column_name].duplicated()] ：选取column_name字段不重复的数据，支持df[-df.duplicated()]</li><li>df.loc[df['col_name']==value,:]：选取col_name字段为value的数据</li><li>df.loc[df['col_name'].isin(value_list),:]：选取col_name字段为value_list中的值的数据</li><li> df.loc[~df['col_name'].isin(value_list),:]：选取col_name字段不在value_list中的值的数据</li><li>df.loc[(df['col_name1'] == value1) &amp; df['col_name2'].isin(value_list)]：选取col_name1等于value1，并且col_name2在value_list中的数据</li><li>df.loc[(df['col_name1'] == value1) | df['col_name2'].isin(value_list)]：选取col_name1等于value1，或者col_name2在value_list中的数据</li><li>df.loc[df['col_name'] != value2,:]：选取col_name字段不等于value2的数据</li><li>df[[col_1,col_2]].max(axis=1):  选取col_1和col_2中的最大值</li></ul> 
<p><strong>5.数据清理</strong></p> 
<ul><li>df.columns = ['a','b','c']：重命名列名（需要将所有列名列出，否则会报错）</li><li>pd.isnull()：检查DataFrame对象中的空值，并返回一个Boolean数组</li><li>pd.notnull()：检查DataFrame对象中的非空值，并返回一个Boolean数组</li><li>df.dropna()：删除所有包含空值的行</li><li>df.dropna(axis=1)：删除所有包含空值的列</li><li>df.dropna(axis=1,thresh=n)：删除所有小于n个非空值的行</li><li>df.fillna(x)：用x替换DataFrame对象中所有的空值，支持df[column_name].fillna(x)</li><li>s.astype(float)：将Series中的数据类型更改为float类型</li><li>s.replace(1,'one')：用‘one’代替所有等于1的值</li><li>s.replace([1,3],['one','three'])：用'one'代替1，用'three'代替3</li><li>df.rename(columns=lambda x: x + 1)：批量更改列名</li><li>df.rename(columns={'old_name': 'new_ name'})：选择性更改列名</li><li>df.set_index('column_one')：将某个字段设为索引，可接受列表参数，即设置多个索引</li><li>df.reset_index("col1"):  将索引设置为col1字段，并将索引新设置为0,1,2...</li><li>df.rename(index=lambda x: x + 1)：批量重命名索引</li></ul> 
<p><strong>6.数据处理：Filter、Sort、GroupBy、Map</strong></p> 
<ul><li>df[df[col] &gt; 0.5]：选择col列的值大于0.5的行</li><li>df.sort_index().loc[:5]:对前5条数据进行索引排序 </li><li>df.sort_values(col1)：按照列col1排序数据，默认升序排列</li><li>df.sort_values(col2, ascending=False)：按照列col1降序排列数据</li><li>df.sort_values([col1,col2], ascending=[True,False])：先按列col1升序排列，后按col2降序排列数据</li><li>df.groupby(col)：返回一个按列col进行分组的Groupby对象</li><li>df.groupby([col1,col2])：返回一个按多列进行分组的Groupby对象</li><li>df.groupby(col1)[col2].agg(mean)：返回按列col1进行分组后，列col2的均值,agg可以接受列表参数，agg([len,np.mean])</li><li>df.pivot_table(index=col1, values=[col2,col3], aggfunc={col2:max,col3:[ma,min]})：创建一个按列col1进行分组，计算col2的最大值和col3的最大值、最小值的数据透视表</li><li>df.groupby(col1).agg(np.mean)：返回按列col1分组的所有列的均值,支持df.groupby(col1).col2.agg(['min','max'])</li><li>data.apply(np.mean)：对DataFrame中的每一列应用函数np.mean，特别注意：apply时引用的对象是一个series，而不是一个单值。</li><li>data[[col1,col2]].apply(np.max,axis=1)：对DataFrame中的col1和col2字段的每一行应用函数np.max，即取两者的最大值</li><li>data[col1].map(lambda x:str(x)): 将col1字段的每一行数据转为字符串，同data[col1].apply(lambda x:str(x))</li><li>data[col1].map(lambda x:float(x[1:-1])) : 改变数据类型为浮点数</li><li>df.groupby(col1).col2.transform("sum"):通常与groupby连用，避免索引更改</li><li>df.set_index("date").groupby([col1,pd.Grouper(freq="M")]).agg(sum): 将某列时间设置为索引，并按照月份求和</li><li>df.groupby(col1,as_index=False).agg(sum).loc[:,[col2,col3]]: 按照col1字段对 col2和col3进行聚合求和，并避免col1被设置为索引</li></ul> 
<p><strong>7.数据合并</strong></p> 
<ul><li>df1.append(df2)：将df2中的行添加到df1的尾部</li><li>pd.concat([df1, df2],axis=1,join='inner')：将df2中的列添加到df1的尾部,值为空的对应行与对应列都不要。当axis=0时，即按照行进行拼接。</li><li>df1.join(df2.set_index(col1),on=col1,how='inner')：对df1的列和df2的列执行SQL形式的join，默认按照索引来进行合并，如果df1和df2有共同字段时，会报错，可通过设置lsuffix,rsuffix来进行解决，如果需要按照共同列进行合并，就要用到set_index(col1)</li><li>pd.merge(df1,df2,on='col1',how='outer') :对df1和df2合并，按照col1，方式为outer </li><li>pd.merge(df1, df2, left_index=True, right_index=True, how='outer')  与  df1.join(df2, how='outer') 效果相同</li></ul> 
<p><strong>8.数据统计</strong></p> 
<ul><li>df.describe()：查看数据值列的汇总统计</li><li>df.mean()：返回所有列的均值</li><li>df.corr()：返回列与列之间的相关系数</li><li>df.count()：返回每一列中的非空值的个数</li><li>df.max()：返回每一列的最大值</li><li>df.min()：返回每一列的最小值</li><li>df.median()：返回每一列的中位数</li><li>pd.date_range('1/1/2000', periods=7)</li><li>df.std()：返回每一列的标准差</li></ul> 
<p><strong>9.时间处理</strong></p> 
<ul><li>pd.date_range('1/1/2018',periods=7) : 指定开始的时间为2018-1-1，周期为7，生成一系列时间(时间格式不固定)</li><li>pd.to_datetime(df['date'])  ： 将date列的数据类型转为datetime类型</li><li>df.to_period('Q')  ：季度，按照不同维度划分(w,m,y,Q) </li><li>df[['date','time']] = df['deal_time'].radd(' ').str.rsplit(' ', n=1, expand=True)  :拆分日期和时间</li></ul> 
<p><strong>10.文本处理</strong></p> 
<ul><li>df['col1'].str.cat([df['col2'],df['col3'],df['col4']],sep=';') : 将df中的col1,col2,col3,col4字段的值拼接起来，并用";"作为分隔符；</li><li>df['col1'].str.split(';'):  将df中的col1字段按照";"进行拆分，结果为列表。df['col1'].str.split(';',expend=True)会将拆分的内容生成一列；</li></ul> 
<p id="main-toc"><strong>10.其他设置类(Nonebook中)</strong></p> 
<ul><li>pd.set_option('max_colwidth',100)：  设置value的显示长度为100</li><li>pd.set_option('display.max_rows',None)： 设置显示所有行</li><li>pd.set_option('display.max_columns',None)： 设置显示所有列</li><li>pd.set_option('display.float_format', lambda x: '%.3f' % x)： 设置取消科学计数法，如果有小数出现时，保留三位小数。</li></ul> 
<h4 id="%E4%B8%89%E3%80%81%E5%85%B6%E4%BB%96%E5%B8%B8%E7%94%A8">三、其他常用</h4> 
<p>1.pipe</p> 
<p>将  f(g(h(df), arg1=a), arg2=b, arg3=c) 形式化为</p> 
<pre class="has"><code class="language-python">(df.pipe(h)
...    .pipe(g, arg1=a)
...    .pipe((f, 'arg2'), arg1=a, arg3=c)
...  )</code></pre> 
<p>2.series转为dataframe</p> 
<pre class="has"><code class="language-python">s.to_frame()     将格式为series的s转为dataframe,索引不会发生变化；
#该方法索引会发生变化
dict_s = {"col1":s.index,"col2":s.values}    
df=pd.DataFrame(dict_s)    </code></pre> 
<p>3.计算时间差</p> 
<p>比如需要计算df中time1和time2的时间差</p> 
<pre class="has"><code class="language-python">#方法1（直接进行加减）
df['diff']=(df['time2']-df['time1']).dt.days
#方法2（apply）
def time_diff(data,before,after):
    dt1=data[before]
    dt2=data[after]
    days=(dt2-dt1).days
    return days
df['diff']=df.apply(time_diff,axis=1,args=("time1","time2"))         #调用方式1
#df['diff']=df.apply(time_diff,axis=1,before="time1",after="time2")   #调用方式2
#df['diff']=df.apply(time_diff,axis=1,**{before:"time1",after:"time2"})  #调用方式3</code></pre> 
<p></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/55feb34eebb16ce11771fc1e13d2b88c/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">关于TPS与CPU的性能综合分析</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/aec3d0fa7d787d6b02370c94a4013e1b/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">C语言零基础项目：2D 赛车游戏，详细思路&#43;源码分享</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>