<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>GPIO的内部结构和工作模式 - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="GPIO的内部结构和工作模式" />
<meta property="og:description" content="参考链接已放至最上方，大家如果有疑惑也可直接观看参考链接。
[1]https://www.eefocus.com/component/405097/r0
[2]https://blog.csdn.net/techexchangeischeap/article/details/72569999
GPIO支持三种最大翻转速度：2MHz、10MHz、50MHz。每个I/O口可以自由编程，但I/O寄存器必须按32位字被访问。GPIO共有8种工作模式，通过编程选择相应的工作模式。
一、输入： 浮空输入、上拉输入、下拉输入、模拟输入 [1]
（一）浮空输入 1)外部通过IO口输入电平(上下拉电阻处于关闭状态)
2)传输到施密特触发器(此时施密特触发器为打开状态)
3)继续传输到输入数据寄存器IDR
4)CPU通过读输入数据寄存器IDR实现读取外部输入电平值
施密特触发器可以解决基本IO电路在读取外部信号的跳变沿时出现的抖动现象 [2]。浮空输入容易受外部噪声信号干扰，改变输入端检测到的电平 [2]。
（二）上拉输入 外部输入通过上拉电阻，施密特触发器存入输入数据寄存器IDR，被CPU读取。
输入上拉模式有上拉电阻连接至VDD，上拉电阻开关接通，阻值约30-50K [1]。当输入管脚悬空时不受外部噪声信号干扰。对于此种输入方式，无论输入管脚悬空或者被高电平驱动时，读取的都是1。只有在输入端为0的时候，读取到的值才是0。因此采取的时非0输入模式。即若读取非0，即为1，若读取为0，即为0 [2]。
（三）下拉输入 与上拉模式相同，外部输入通过下拉电阻，施密特触发器存入输入数据寄存器IDR，被CPU读取。
输入下拉模式有下拉电阻连接至VSS，下拉电阻开关接通，阻值约30-50K [1]。但是该电路对外呈现的不是高阻，某种意义上说也在向外输出，当外部驱动电路不同时可能出现错误的检测结果 [2]。
（四）模拟输入 此时，上下拉处于关闭状态。施密特触发器处于截止状态。通过模拟输入通道输入到CPU，IO口外部电压为模拟量(电压形式非电平形式),作为模拟输入范围一般为0~3.3V [1]。
二、输出： 推挽输出、开漏输出、推挽复用输出IO、开漏复用输出IO
（一）开漏输出 开漏输出即三极管的集电极或者MOS管的漏极进行输出。开漏输出可以实现线与功能。开漏输出只能输出强低电平，高电平需要依靠外部上拉电子拉高，适合做电流型驱动，吸收电流能力较强[1]。
1）CPU写入位设置/清楚寄存器BSRR,映射到输出数据寄存器ODR
2）联通到输出控制电路(也就是ODR的电平)
3）ODR电平通过输出控制电路进入N-MOS管
1、ODR输出0：
N-MOS截止，IO端口电平不会由ODR输出决定，而由外部上拉/下拉决定　在输出状态下，输出的电平可以被读取，数据存入输入数据寄存器，由CPU读取，实现CPU读取输出电平　所以，当N-MOS截止时，如果读取到输出电平为1，不一定是我们输出的1，有可能是外部上拉产生的1
2、ODR输出1：
N-MOS开启，IO端口电平被N-MOS管拉倒VSS，使IO输出低电平。此时输出的低电平同样可以被CPU读取到
（二）推挽输出 与开漏式输出不同，推挽式输出采用上图结构。推挽输出可以采取强高/强低输出，可以连接数字电路。[1-2]
但推挽输出的一个缺点是，如果当两个推挽输出结构相连在一起，一个输出高电平，即上面的MOS导通，下面的MOS闭合时；同时另一个输出低电平，即上面的MOS闭合，下面的MOS导通时。电流会从第一个引脚的VCC通过上端MOS再经过第二个引脚的下端MOS直接流向GND。整个通路上电阻很小，会发生短路，进而可能造成端口的损害。这也是为什么推挽输出不能实现&#34; 线与&#34;的原因。[2]
（三）推挽复用输出IO 与推挽输出模式唯一的区别在于输出控制电路之前电平的来源，推挽输出模式的输出电平是由CPU写入输出数据寄存器控制的，推挽复用输出模式的输出电平是由复用功能外设输出决定的。其他与开漏输出模式相似。
（四）开漏复用输出IO 与开漏输出模式唯一的区别在于输出控制电路之前电平的来源。开漏输出模式的输出电平是由CPU写入输出数据寄存器控制的，开漏复用输出模式的输出电平是由复用功能外设输出决定的。其他与开漏输出模式相似。
https://blog.csdn.net/qq_38410730/article/details/79858906
https://blog.csdn.net/huanggenda568/article/details/7723238
https://www.cnblogs.com/sky-heaven/p/8553951.html
https://wenku.baidu.com/view/b627eb2b482fb4daa58d4b80.html" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/1624a4cb553e94169967f85d811dd17c/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2019-05-30T14:21:18+08:00" />
<meta property="article:modified_time" content="2019-05-30T14:21:18+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">GPIO的内部结构和工作模式</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p>参考链接已放至最上方，大家如果有疑惑也可直接观看参考链接。</p> 
<p>[1]<a href="https://www.eefocus.com/component/405097/r0" rel="nofollow">https://www.eefocus.com/component/405097/r0</a></p> 
<p>[2]<a href="https://blog.csdn.net/techexchangeischeap/article/details/72569999">https://blog.csdn.net/techexchangeischeap/article/details/72569999</a></p> 
<p> </p> 
<p>GPIO支持三种最大翻转速度：2MHz、10MHz、50MHz。每个I/O口可以自由编程，但I/O寄存器必须按32位字被访问。GPIO共有8种工作模式，通过编程选择相应的工作模式。</p> 
<h3>一、输入：</h3> 
<p><strong>浮空输入、上拉输入、下拉输入、模拟输入 [1]</strong></p> 
<h4>（一）浮空输入</h4> 
<p><img alt="" class="has" src="https://images2.imgbox.com/45/a5/UFrJRTy6_o.png"></p> 
<p>1)外部通过IO口输入电平(上下拉电阻处于关闭状态)</p> 
<p>2)传输到施密特触发器(此时施密特触发器为打开状态)</p> 
<p>3)继续传输到输入数据寄存器IDR</p> 
<p>4)CPU通过读输入数据寄存器IDR实现读取外部输入电平值</p> 
<p>施密特触发器可以解决基本IO电路在读取外部信号的跳变沿时出现的抖动现象 [2]。浮空输入容易受外部噪声信号干扰，改变输入端检测到的电平 [2]。</p> 
<h4>（二）上拉输入</h4> 
<p><img alt="" class="has" src="https://images2.imgbox.com/c3/d9/Ma5hGNQ7_o.png"></p> 
<p>外部输入通过上拉电阻，施密特触发器存入输入数据寄存器IDR，被CPU读取。</p> 
<p>输入上拉模式有上拉电阻连接至VDD，上拉电阻开关接通，阻值约30-50K [1]。当输入管脚悬空时不受外部噪声信号干扰。对于此种输入方式，无论输入管脚悬空或者被高电平驱动时，读取的都是1。只有在输入端为0的时候，读取到的值才是0。因此采取的时非0输入模式。即若读取非0，即为1，若读取为0，即为0 [2]。</p> 
<h4>（三）下拉输入</h4> 
<p><img alt="" class="has" src="https://images2.imgbox.com/dc/48/S3cOMYEw_o.png"></p> 
<p>与上拉模式相同，外部输入通过下拉电阻，施密特触发器存入输入数据寄存器IDR，被CPU读取。</p> 
<p>输入下拉模式有下拉电阻连接至VSS，下拉电阻开关接通，阻值约30-50K [1]。但是该电路对外呈现的不是高阻，某种意义上说也在向外输出，当外部驱动电路不同时可能出现错误的检测结果 [2]。</p> 
<h4>（四）模拟输入</h4> 
<p><img alt="" class="has" src="https://images2.imgbox.com/27/7f/9BgzNsdj_o.png"></p> 
<p>此时，上下拉处于关闭状态。施密特触发器处于截止状态。通过模拟输入通道输入到CPU，IO口外部电压为模拟量(电压形式非电平形式),作为模拟输入范围一般为0~3.3V [1]。</p> 
<h3>二、输出：</h3> 
<p><strong>推挽输出、开漏输出、推挽复用输出IO、开漏复用输出IO</strong></p> 
<h4>（一）开漏输出</h4> 
<p> </p> 
<p><img alt="" class="has" height="182" src="https://images2.imgbox.com/e3/a2/x5Ht7Vxa_o.png" width="335"></p> 
<p>开漏输出即三极管的集电极或者MOS管的漏极进行输出。开漏输出可以实现线与功能。开漏输出只能输出强低电平，高电平需要依靠外部上拉电子拉高，适合做电流型驱动，吸收电流能力较强[1]。</p> 
<p><img alt="" class="has" src="https://images2.imgbox.com/16/ed/bvP5e897_o.png"></p> 
<p>1）CPU写入位设置/清楚寄存器BSRR,映射到输出数据寄存器ODR</p> 
<p>2）联通到输出控制电路(也就是ODR的电平)</p> 
<p>3）ODR电平通过输出控制电路进入N-MOS管</p> 
<p>1、ODR输出0：</p> 
<p>N-MOS截止，IO端口电平不会由ODR输出决定，而由外部上拉/下拉决定　　</p> 
<p>在输出状态下，输出的电平可以被读取，数据存入输入数据寄存器，由CPU读取，实现CPU读取输出电平　　</p> 
<p>所以，当N-MOS截止时，如果读取到输出电平为1，不一定是我们输出的1，有可能是外部上拉产生的1</p> 
<p>2、ODR输出1：</p> 
<p>N-MOS开启，IO端口电平被N-MOS管拉倒VSS，使IO输出低电平。此时输出的低电平同样可以被CPU读取到</p> 
<h4>（二）推挽输出</h4> 
<p><img alt="" class="has" height="209" src="https://images2.imgbox.com/64/ef/jvMBmZal_o.png" width="442"></p> 
<p>与开漏式输出不同，推挽式输出采用上图结构。推挽输出可以采取强高/强低输出，可以连接数字电路。[1-2]</p> 
<p><img alt="" class="has" src="https://images2.imgbox.com/3c/66/sbIP6qPA_o.png"></p> 
<p>但推挽输出的一个缺点是，如果当两个推挽输出结构相连在一起，一个输出高电平，即上面的MOS导通，下面的MOS闭合时；同时另一个输出低电平，即上面的MOS闭合，下面的MOS导通时。电流会从第一个引脚的VCC通过上端MOS再经过第二个引脚的下端MOS直接流向GND。整个通路上电阻很小，会发生短路，进而可能造成端口的损害。这也是为什么推挽输出不能实现" 线与"的原因。[2]</p> 
<h4>（三）推挽复用输出IO</h4> 
<p><img alt="" class="has" src="https://images2.imgbox.com/22/11/LVTZ1ubl_o.png"></p> 
<p>与推挽输出模式唯一的区别在于输出控制电路之前电平的来源，推挽输出模式的输出电平是由CPU写入输出数据寄存器控制的，推挽复用输出模式的输出电平是由复用功能外设输出决定的。其他与开漏输出模式相似。</p> 
<h4>（四）开漏复用输出IO</h4> 
<p><img alt="" class="has" src="https://images2.imgbox.com/c7/40/v2qh8CNE_o.png"></p> 
<p>与开漏输出模式唯一的区别在于输出控制电路之前电平的来源。开漏输出模式的输出电平是由CPU写入输出数据寄存器控制的，开漏复用输出模式的输出电平是由复用功能外设输出决定的。其他与开漏输出模式相似。</p> 
<p><a href="https://blog.csdn.net/qq_38410730/article/details/79858906">https://blog.csdn.net/qq_38410730/article/details/79858906</a></p> 
<p><a href="https://blog.csdn.net/huanggenda568/article/details/7723238">https://blog.csdn.net/huanggenda568/article/details/7723238</a></p> 
<p><a href="https://www.cnblogs.com/sky-heaven/p/8553951.html" rel="nofollow">https://www.cnblogs.com/sky-heaven/p/8553951.html</a></p> 
<p><a href="https://wenku.baidu.com/view/b627eb2b482fb4daa58d4b80.html" rel="nofollow">https://wenku.baidu.com/view/b627eb2b482fb4daa58d4b80.html</a></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/2bd6b0b456528b8b8e6793eb233957ed/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">sklearn机器学习（六）逻辑回归实例乳腺癌检测</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/a4b97d0907f46b6eb2dfc7359edf33c6/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">周期性线程池newScheduledThreadPool详解</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>