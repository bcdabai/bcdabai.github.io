<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>数据结构9 - 常用的10种算法 - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="数据结构9 - 常用的10种算法" />
<meta property="og:description" content="1. 二分查找算法(非递归) 1.1 二分查找算法(非递归)介绍 1) 前面《数据结构7 -查找》中的二分查找算法，是使用递归的方式，下面我们讲解二分查找算法的非递归方式。
2) 二分查找法只适用于从有序的数列中进行查找(比如数字和字母等)，将数列排序后再进行查找。
3) 二分查找法的运行时间为对数时间O(㏒₂n) ，即查找到需要的目标位置最多只需要㏒₂n步。假设从[0,99]的队列(100个数，即n=100)中寻到目标数30，则需要查找步数为㏒₂100 , 即最多需要查找7次( 2^6 &lt; 100 &lt; 2^7)。
1.2 二分查找算法(非递归)代码实现 数组 {1,3, 8, 10, 11, 67, 100}, 编程实现二分查找， 要求使用非递归的方式完成.
public class BinarySearchNoRecur { public static void main(String[] args) { int[] arr = {1,3, 8, 10, 11, 67, 100}; System.out.println(binarySearch(arr,8)); //2 } //二分查找的非递归实现 /** * @param arr 待查找的数组，arr是升序排列 * @param target 需要查找的数 * @return 返回对应下标，-1 表示没有找到 * */ public static int binarySearch(int[] arr, int target){ int left = 0; int right = arr." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/2a3bfe3cdda3c7b1cb6a4bdff1be11e1/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-05-14T21:06:06+08:00" />
<meta property="article:modified_time" content="2023-05-14T21:06:06+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">数据结构9 - 常用的10种算法</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <h2 style="margin-left:0in;">1. 二分查找算法(非递归)</h2> 
<h3 style="margin-left:0in;"><strong>1.1 二分查找算法(非递归)介绍</strong></h3> 
<p>1) <span style="color:#000000;">前面《数据结构7 -查找》中的二分查找算法，是使用递归的方式，下面我们讲解二分查找算法的非递归方式。</span></p> 
<p>2) <span style="color:#000000;">二分查找法只适用于从</span><span style="color:#3399ea;">有序的数列</span><span style="color:#000000;">中</span><span style="color:#000000;">进行查找</span><span style="color:#000000;">(</span><span style="color:#000000;">比如数字和字母等</span><span style="color:#000000;">)</span><span style="color:#000000;">，</span><span style="color:#000000;">将</span><span style="color:#000000;">数列</span><span style="color:#000000;">排</span><span style="color:#000000;">序后再进行查</span><span style="color:#000000;">找。</span></p> 
<p>3) <span style="color:#000000;">二分查找法的运行时间为对数时间</span><span style="color:#e579b6;">O(㏒₂n)</span><span style="color:#000000;"> </span><span style="color:#000000;">，即查找到需要的目标位置</span><span style="color:#000000;"><strong>最多</strong></span><span style="color:#000000;">只需要㏒₂n</span><span style="color:#000000;">步。假设从</span><span style="color:#000000;">[0,99]</span><span style="color:#000000;">的队列</span><span style="color:#000000;">(100</span><span style="color:#000000;">个数，即</span><span style="color:#000000;">n=100)</span><span style="color:#000000;">中寻到目标数</span><span style="color:#000000;">30</span><span style="color:#000000;">，则需要查找步数为㏒₂</span><span style="color:#000000;">100 , </span><span style="color:#000000;">即</span><span style="color:#000000;"><strong>最多</strong></span><span style="color:#000000;">需要查找</span><span style="color:#000000;">7</span><span style="color:#000000;">次</span><span style="color:#000000;">( 2^6 &lt; 100 &lt; 2^7)。</span></p> 
<h3 style="margin-left:0in;"><strong>1.2 二分查找算法(非递归)代码实现</strong></h3> 
<p style="margin-left:0in;"><span style="color:#000000;">数组 {1,3, 8, 10, 11, 67, 100}, </span><span style="color:#000000;">编程实现二分查找， </span><span style="color:#000000;">要</span><span style="color:#000000;">求使用非递归的方式完成</span><span style="color:#000000;">.</span></p> 
<pre class="has"><code class="language-java">
public class BinarySearchNoRecur {
    public static void main(String[] args) {
        int[] arr = {1,3, 8, 10, 11, 67, 100};
        System.out.println(binarySearch(arr,8)); //2

    }


    //二分查找的非递归实现
    /**
     * @param arr 待查找的数组，arr是升序排列
     * @param target 需要查找的数
     * @return 返回对应下标，-1 表示没有找到
     * */
    public static int binarySearch(int[] arr, int target){
        int left = 0;
        int right = arr.length - 1;
        while (left &lt;= right){ //说明继续查找
            int mid = (left + right) / 2;
            if(arr[mid] == target)
                return mid;
            else if (arr[mid] &gt; target)
                right = mid - 1; //向左边查找
            else
                left = mid + 1; //向右边查找
        }
        return -1;
    }
    
}</code></pre> 
<p style="margin-left:0in;">递归：</p> 
<pre class="has"><code class="language-java">    /*
    * 只查找到一个符合结果的数就行
    *
    * 假设传入的数组是从小到大排列的有序数组
    * */
    public int binarySearch(int[] arr, int left, int right, int findVal){
        if(left &gt; right)
            return -1;
        int mid = (left + right) / 2;
        if(findVal &gt; arr[mid])
            return binarySearch(arr, mid + 1, right, findVal );
        else if(findVal &lt; arr[mid])
            return binarySearch(arr, left, mid - 1, findVal );
        else
            return mid;
    }
</code></pre> 
<p style="margin-left:0in;"></p> 
<h2 style="margin-left:0in;"><span style="color:#000000;">2. 分治算法</span></h2> 
<h3 style="margin-left:0in;"><strong>2.1 分治算法介绍</strong></h3> 
<p>1) <span style="color:#000000;">分</span><span style="color:#000000;">治法是一种很重要的算法。字面上的解释是“分而治之”，就是把一个复杂的问题分成两个或更多的相同或相似的子问题，再把子问题分成更小的子问题</span><span style="color:#000000;">……</span><span style="color:#000000;">直到最后子问题可以简单的直接求解，原问题的解即子问题的解的合并。这个技巧是很多高效算法的基础，如排序算法</span><span style="color:#000000;">(</span><u><span style="color:#000000;"><a href="https://blog.csdn.net/weixin_44210965/article/details/102014164" title="快速排序">快速排序</a></span></u><span style="color:#000000;">，</span><u><span style="color:#000000;"><a href="https://blog.csdn.net/weixin_44210965/article/details/102014164" title="归并排序">归并排序</a></span></u><span style="color:#000000;">)</span><span style="color:#000000;">，傅立叶变换</span><span style="color:#000000;">(</span><span style="color:#000000;">快速傅立叶变换</span><span style="color:#000000;">)……</span></p> 
<p>2) <span style="color:#000000;">分治算法可以</span><span style="color:#000000;">求</span><span style="color:#000000;">解的一些经典问</span><span style="color:#000000;">题</span></p> 
<ul><li><span style="color:#000000;">二</span><span style="color:#000000;">分搜索</span></li><li><span style="color:#000000;">大</span><span style="color:#000000;">整数乘</span><span style="color:#000000;">法</span></li><li><span style="color:#000000;">棋</span><span style="color:#000000;">盘覆盖</span></li><li>归并排序</li><li>快速排序</li><li><span style="color:#000000;">线</span><span style="color:#000000;">性时间选择</span></li><li><span style="color:#000000;">最</span><span style="color:#000000;">接近点对问题</span></li><li><span style="color:#000000;">循</span><span style="color:#000000;">环赛日程表</span></li><li><span style="color:#000000;"><strong>汉</strong></span><span style="color:#000000;"><strong>诺塔</strong></span></li></ul> 
<h3 style="margin-left:0in;"><strong>2.2 分治算法的基本步骤</strong></h3> 
<p style="margin-left:0in;"><span style="color:#000000;">分治法在每一层递归上都有三个步骤：</span></p> 
<p>1) <span style="color:#000000;">分</span><span style="color:#000000;">解：将原问题分解为若干个规模较小，相互独立，与原问题形式相同的子问</span><span style="color:#000000;">题</span></p> 
<p>2) <span style="color:#000000;">解</span><span style="color:#000000;">决：若子问题规模较小而容易被解决则直接解，否则递归地解各个子问</span><span style="color:#000000;">题</span></p> 
<p>3) <span style="color:#000000;">合</span><span style="color:#000000;">并：将各个子问题的解合并为原问题的解。</span></p> 
<h3><strong>2.3 分治(Divide-and-Conquer(P))算法设计模式</strong></h3> 
<pre class="has"><code class="language-java">if |P|≤n0
   then return(ADHOC(P))
//将P分解为较小的子问题 P1 ,P2 ,…,Pk
for i←1 to k
do yi ← Divide-and-Conquer(Pi)   递归解决Pi
T ← MERGE(y1,y2,…,yk)   合并子问题
return(T)
</code></pre> 
<p><span style="color:#000000;">其</span><span style="color:#000000;">中</span><span style="color:#000000;">|P|</span><span style="color:#000000;">表示问题</span><span style="color:#000000;">P</span><span style="color:#000000;">的规模；</span><span style="color:#000000;"><img alt="n_{0}" class="mathcode" src="https://images2.imgbox.com/3b/4e/lQoKYISD_o.gif"></span><span style="color:#000000;">为一阈值，表示当问题</span><span style="color:#000000;">P的规模不超过<img alt="n_{0}" class="mathcode" src="https://images2.imgbox.com/34/e6/0hxXwt56_o.gif">时，问题已容易直接解出，不必再继续分解。</span><span style="color:#000000;">ADHOC(P)</span><span style="color:#000000;">是该分治法中的基本子算法，用于直接解小规模的问题</span><span style="color:#000000;">P</span><span style="color:#000000;">。因此，当</span><span style="color:#000000;">P的规模不超过<img alt="n_{0}" class="mathcode" src="https://images2.imgbox.com/c2/33/Zb1mCtyK_o.gif">时直接用算法</span><span style="color:#000000;">ADHOC(P)</span><span style="color:#000000;">求解。算法</span><span style="color:#000000;">MERGE(y1,y2,…,</span><span style="color:#000000;">yk</span><span style="color:#000000;">)</span><span style="color:#000000;">是该分治法中的合并子算法，用于将</span><span style="color:#000000;">P</span><span style="color:#000000;">的子问题</span><span style="color:#000000;">P1 ,P2 ,…,</span><span style="color:#000000;">Pk</span><span style="color:#000000;">的相应的解</span><span style="color:#000000;">y1,y2,…,</span><span style="color:#000000;">yk</span><span style="color:#000000;">合并为</span><span style="color:#000000;">P</span><span style="color:#000000;">的解。</span></p> 
<h3 style="margin-left:0in;"><strong>2.4 分治算法最佳实践 - 汉诺塔</strong></h3> 
<p style="margin-left:0in;"><strong><span style="color:#000000;">汉诺塔的传说</span></strong></p> 
<p style="margin-left:0in;"><span style="color:#000000;">汉诺塔：汉诺塔（又称河内塔）问题是源于印度一个古老传说的益智玩具。大梵天创造世界的时候做了三根</span><a href="https://baike.baidu.com/item/%E9%87%91%E5%88%9A%E7%9F%B3/80698" rel="nofollow" title="金刚石">金刚石</a><span style="color:#000000;">柱子，在一根柱子上从下往上按照大小顺序摞着</span><span style="color:#000000;">64</span><span style="color:#000000;">片黄金圆盘。大梵天命令婆罗门把圆盘从下面开始按大小顺序重新摆放在另一根柱子上。并且规定，在小圆盘上不能放大圆盘，在三根柱子之间一次只能移动一个圆盘。</span></p> 
<p style="margin-left:0in;"><span style="color:#000000;">假如每秒钟一次，共需多长时间呢？移完这些金片需要5845.54</span><span style="color:#000000;">亿年以上，太阳系的预期寿命据说也就是数百亿年。真的过了</span><span style="color:#000000;">5845.54</span><span style="color:#000000;">亿年，地球上的一切生命，连同梵塔、庙宇等，都早已经灰飞烟灭。</span></p> 
<pre class="has"><code class="language-java">
public class Hanoitower {
    public static void main(String[] args) {
        Hanoitower hanoitower = new Hanoitower();
        hanoitower.hanoiTower(3,'a','b','c');
    }

    //移动的次数
    private static int time = 0;

    //a---&gt;c, 借助b
    public static void hanoiTower(int num, char a, char b, char c){
        if(num == 1)
            move(num,a,c);
        else {
            hanoiTower(num - 1, a, c, b); //a---&gt;b, 借助c  把前n-m个盘移动到b盘上，借助c
            move(num,a,c);//把第nmu个从a移动到c
            hanoiTower(num - 1, b, a, c); //把前n-m个盘从b移动到c盘上，借助a
        }
    }

    public static void move(int num, char x, char y){
        System.out.println("第"+ ++time + "次移动，"+ num +"号圆盘："+ x + "--&gt;" + y);
    }

}
</code></pre> 
<p>Output：</p> 
<pre class="has"><code class="language-java">第1次移动，1号圆盘：a--&gt;c
第2次移动，2号圆盘：a--&gt;b
第3次移动，1号圆盘：c--&gt;b
第4次移动，3号圆盘：a--&gt;c
第5次移动，1号圆盘：b--&gt;a
第6次移动，2号圆盘：b--&gt;c
第7次移动，1号圆盘：a--&gt;c</code></pre> 
<p></p> 
<h2><span style="color:#000000;">3. 动态规划算法</span></h2> 
<h3 style="margin-left:0in;"><strong>3.1 动态规划算法介绍</strong></h3> 
<p>1) <span style="color:#000000;">动</span><span style="color:#000000;">态规</span><span style="color:#000000;">划</span><span style="color:#000000;">(</span><span style="color:#000000;"><strong>Dynamic </strong></span><span style="color:#000000;"><strong>Programming</strong></span><span style="color:#000000;">)</span><span style="color:#000000;">算法的核心思想是：将</span><span style="color:#000000;">大问题划分为小问题进行解决，从而一步步获取最优解的处理算</span><span style="color:#000000;">法。</span></p> 
<p>2) <span style="color:#000000;">动</span><span style="color:#000000;">态规划算法与分</span><span style="color:#000000;">治</span><span style="color:#000000;">算</span><span style="color:#000000;">法类似，</span><span style="color:#000000;">其基本思想也是将待求解问题分解成若干个子问题，先求解子问题，然后从这些子问题的解得到原问题的解</span><span style="color:#000000;">。</span></p> 
<p>3) <span style="color:#000000;">与</span><span style="color:#000000;">分治法不同的是，</span><span style="color:#000000;"><strong>适合于用动态规划求解的问题，经分解得到子问题往往不是互相独立的</strong></span> <span style="color:#000000;">( </span><span style="color:#000000;">即</span><span style="color:#000000;">下一个子阶段的求解是建立在上一个子阶段的解的基础上，进行进一步的求</span><span style="color:#000000;">解 </span><span style="color:#000000;">)。</span></p> 
<p><span style="color:#000000;">4) 动态规</span><span style="color:#000000;">划</span><span style="color:#000000;">可</span><span style="color:#000000;">以通过</span><span style="color:#000000;"><strong>填</strong></span><span style="color:#000000;"><strong>表的方式</strong></span><span style="color:#000000;">来</span><span style="color:#000000;">逐</span><span style="color:#000000;">步推进，得到最优解。</span></p> 
<h3 style="margin-left:0in;"><span style="color:#0070c0;"><strong>3.2 动态规划算法最佳实践</strong></span><span style="color:#0070c0;"><strong>-</strong></span><span style="color:#0070c0;"><strong>背包问题</strong></span></h3> 
<p style="margin-left:0in;"><span style="color:#000000;">背包问题：有一个背包，容量为4</span><span style="color:#000000;">磅 ， 现有如下物品：</span></p> 
<table border="1" cellpadding="1" cellspacing="1" style="width:500px;"><thead><tr><th>物品</th><th>重量</th><th>价格</th></tr></thead><tbody><tr><td>吉他（G）</td><td>1</td><td>1500</td></tr><tr><td>音响（S）</td><td>4</td><td>3000</td></tr><tr><td>电脑（L）</td><td>3</td><td>2000</td></tr></tbody></table> 
<p>1) <span style="color:#000000;">要求达到的目标为装入的背包的总价值最大，并且重量不超出。</span></p> 
<p>2) <span style="color:#000000;">要求装入的物品不能重</span><span style="color:#000000;">复。</span></p> 
<p><strong>3) <span style="color:#000000;">思路分析和图解</span></strong></p> 
<p><span style="color:#000000;">       算法的主要思想，利用动态规划来解决。每次遍历到的第 </span><span style="color:#000000;">i </span><span style="color:#000000;">个物品，根据 </span><span style="color:#000000;">w[</span><span style="color:#000000;">i</span><span style="color:#000000;">] </span><span style="color:#000000;">和 </span><span style="color:#000000;">v[</span><span style="color:#000000;">i</span><span style="color:#000000;">] </span><span style="color:#000000;">来确定是否需要将该物品放入背包中。即对于给定的 </span><span style="color:#000000;">n </span><span style="color:#000000;">个物品，设 </span><span style="color:#ffbb66;">v[i] </span><span style="color:#000000;">、</span><span style="color:#ffbb66;">w[i] </span><span style="color:#000000;">分别为第 </span><span style="color:#000000;">i </span><span style="color:#000000;">个物品的价值和重量，</span><span style="color:#000000;">C </span><span style="color:#000000;">为背包的容量。再令 </span><span style="color:#ffbb66;">v[i][j]</span><span style="color:#000000;"> </span><span style="color:#000000;">表示在前 </span><span style="color:#000000;">i </span><span style="color:#000000;">个物品中能够装入容量为 </span><span style="color:#000000;">j </span><span style="color:#000000;">的背包中的最大价值。则我们有下面的结果：</span></p> 
<p><span style="color:#000000;">① v[</span><span style="color:#000000;">i</span><span style="color:#000000;">][0] = v[0][j] = </span><span style="color:#000000;">0;  </span><span style="color:#86ca5e;">//表示 填入表 第一行和第一列是 0。</span></p> 
<p><span style="color:#000000;">②当 </span><span style="color:#000000;">w[</span><span style="color:#000000;">i</span><span style="color:#000000;">] &gt; j </span><span style="color:#000000;">时：</span><span style="color:#000000;">v[</span><span style="color:#000000;">i</span><span style="color:#000000;">][j] = v[i-1][j]  </span><span style="color:#ffbb66;"> </span><span style="color:#86ca5e;">// 当准备加入新增的商品的容量大于当前背包的容量时，就直接使用上一个单元格的装入策略。</span></p> 
<p style="margin-left:0in;"><span style="color:#000000;">③</span><span style="color:#000000;">当 </span><span style="color:#000000;">j &gt;= w[</span><span style="color:#000000;">i</span><span style="color:#000000;">]</span><span style="color:#000000;">时：</span><span style="color:#000000;"> v[</span><span style="color:#000000;">i</span><span style="color:#000000;">][j</span><span style="color:#000000;">] = max{ v[i-1</span><span style="color:#000000;">][j</span><span style="color:#000000;">],  </span><span style="color:#000000;">v[</span><span style="color:#000000;">i</span><span style="color:#000000;">] + v[</span><span style="color:#000000;">i</span><span style="color:#000000;"> - 1</span><span style="color:#000000;">][</span><span style="color:#000000;">j - w[</span><span style="color:#000000;">i</span><span style="color:#000000;">]] } </span><span style="color:#86ca5e;">  // 当 准备加入的新增的商品的容量小于等于当前背包的容量</span></p> 
<p style="margin-left:0in;"><span style="color:#86ca5e;">// 装入的方式:</span></p> 
<p style="margin-left:0in;"><span style="color:#86ca5e;">v[i - 1][j]： 就是上一个单元格的装入的最大值</span></p> 
<p style="margin-left:0in;"><span style="color:#86ca5e;">v[i] : 表示当前商品的价值 </span></p> 
<p style="margin-left:0in;"><span style="color:#86ca5e;">v[i - 1][j - w[i]] ： 装入 i - 1 商品，到剩余空间 j - w[i] 的最大值</span></p> 
<p><img alt="" class="has" height="494" src="https://images2.imgbox.com/98/be/oNXN7d89_o.png" width="793"></p> 
<pre class="has"><code class="language-java">/**
 * 
 * 动态规划算法 - 背包问题
 */
public class KnaspackProblem {
    public static void main(String[] args) {
        int[] w = {1,4,3}; //物品的重量
        int[] val = {1500,3000,2000}; //物品的价值 这里的val[i] 就是前面讲的v[i]
        int m = 4; //背包的数量
        int n = val.length; //物品的个数
        
        //创建二维数组
        //v[i][j] 表示在前 i 个物品中能够装入容量为 j 的背包中的最大价值
        int[][] v = new int[n + 1][m + 1];

        //为了记录放入商品的情况，我们定一个二维数组
        int[][] path = new int[n + 1][m + 1];

        //初始化第一行和第一列，这里在本程序中，可以不去处理，因为默认值就是0
        for (int i = 0; i &lt; v.length; i++) {
            v[i][0] = 0; //将第一列设置为0
        }
        for (int i = 0; i &lt; v[0].length; i++) {
            v[0][i] = 0; //将第一行设置为0
        }
        
        //根据前面的公式来动态规划处理
        for (int i = 1; i &lt; v.length; i++) { //不处理第一行， i 从1开始
            for (int j = 1; j &lt; v[0].length; j++) { //不处理第一列， j 从1开始
                //公式
                if(w[i - 1] &gt; j) //因为此程序时从 1 开始的，因此原来的公式中的 w[i] 需改为 w[i - 1]
                    v[i][j] = v[i - 1][j];
                else { //因为此程序时从 1 开始的，因此原来的公式调整为如下：
                    //v[i][j] = Math.max(v[i - 1][j], val[i - 1] + v[i - 1][j - w[i - 1]]);
                    //为了记录商品放到背包的情况，我们不能直接使用上面的公式
                    if(v[i - 1][j] &lt; val[i - 1] + v[i - 1][j - w[i - 1]]){
                        v[i][j] = val[i - 1] + v[i - 1][j - w[i - 1]];
                        path[i][j] = 1; //把当前的情况记录到path
                    }else
                        v[i][j] = v[i - 1][j];
                }
            }
        }
        

        //输出一下v 看看目前的情况
        for (int i = 0; i &lt; v.length; i++) {
            for (int j = 0; j &lt; v[i].length; j++) {
                System.out.print(v[i][j] + " ");
            }
            System.out.println();
        }

        System.out.println("--------------------------------------------");

        int i = path.length - 1; //行的最大下标
        int j = path[0].length - 1; //列的最大下标
        while(i &gt; 0 &amp;&amp; j &gt; 0){ //从path的最后开始找
            if(path[i][j] == 1){
                System.out.printf("第%d个商品放入到背包\n",i);
                j = w[i - 1];
            }
            i --;
        }
        
    }
}</code></pre> 
<p>Output：</p> 
<pre class="has"><code class="language-java">0 0 0 0 0 
0 1500 1500 1500 1500 
0 1500 1500 1500 3000 
0 1500 1500 2000 3500 
--------------------------------------------
第3个商品放入到背包
第1个商品放入到背包</code></pre> 
<p></p> 
<h2>4. KMP算法</h2> 
<p><a href="https://blog.csdn.net/weixin_44210965/article/details/101722751" title="KMP算法">KMP算法</a></p> 
<p></p> 
<h2>5. 贪心算法</h2> 
<h3 style="margin-left:0in;"><strong>5.1 贪心算法介绍</strong></h3> 
<p style="margin-left:0in;">1) <span style="color:#000000;">贪</span><span style="color:#000000;">婪算法</span><span style="color:#000000;">(</span><span style="color:#000000;">贪心算法</span><span style="color:#000000;">)</span><span style="color:#000000;">是指在对问题进行求解时，在每一步选择中都采取最好或者最优</span><span style="color:#000000;">(</span><span style="color:#000000;">即最有利</span><span style="color:#000000;">)</span><span style="color:#000000;">的选择，从而希望能够导致结果是最好或者最优的算</span><span style="color:#000000;">法。</span></p> 
<p style="margin-left:0in;">2) <span style="color:#000000;">贪婪算法所得到的结</span><span style="color:#000000;">果</span><span style="color:#000000;"><strong>不</strong></span><span style="color:#000000;"><strong>一</strong></span><span style="color:#000000;"><strong>定</strong></span><span style="color:#000000;"><strong>是</strong></span><span style="color:#000000;"><strong>最</strong></span><span style="color:#000000;"><strong>优的结果</strong></span><span style="color:#000000;"><strong>(</strong></span><span style="color:#000000;"><strong>有时候会是最优解</strong></span><span style="color:#000000;"><strong>)</strong></span><span style="color:#000000;">，但是都是相对近似</span><span style="color:#000000;">(</span><span style="color:#000000;">接近</span><span style="color:#000000;">)</span><span style="color:#000000;">最优解的结</span><span style="color:#000000;">果。</span></p> 
<h3 style="margin-left:0in;"><span style="color:#0070c0;"><strong>5.2 贪心算法最佳应用 </strong></span><span style="color:#0070c0;"><strong>- </strong></span><span style="color:#0070c0;"><strong>集合覆盖</strong></span></h3> 
<p style="margin-left:0in;">1)<span style="color:#000000;">假</span><span style="color:#000000;">设存在如下表的需要付费的广播台，以及广播台信号可以覆盖的地区。 </span><span style="color:#000000;"><strong>如何选择最少的广播台</strong></span><span style="color:#000000;">，让所有的地区都可以接收到信</span><span style="color:#000000;">号。</span></p> 
<table border="1" cellpadding="1" cellspacing="1" style="width:500px;"><thead><tr><th>广播台</th><th>覆盖地区</th></tr></thead><tbody><tr><td>K1</td><td>“北京”，“上海”，“天津”</td></tr><tr><td>K2</td><td>“广州”，“北京”，“深圳”</td></tr><tr><td>K3</td><td>“成都”，“上海”，“杭州”</td></tr><tr><td>K4</td><td>“上海”，“天津”</td></tr><tr><td>K5</td><td>“杭州”，“大连”</td></tr></tbody></table> 
<p><strong>2)<span style="color:#000000;">思路分析</span><span style="color:#000000;">: </span></strong></p> 
<p><span style="color:#000000;">使用贪婪算法</span><span style="color:#000000;">，效</span><span style="color:#000000;">率高：</span></p> 
<p style="margin-left:0in;"><span style="color:#000000;">目前并没有算法可以快速计算得到准备的值， </span><span style="color:#000000;">使</span><span style="color:#000000;">用贪婪算法，则可以得到非常接近的解，并且效率</span><span style="color:#000000;">高。选</span><span style="color:#000000;">择策略上，因为需要覆盖全部地区的最小集合：</span></p> 
<p style="margin-left:0in;"><span style="color:#000000;">①遍历所有的广播电台</span><span style="color:#000000;">, </span><span style="color:#000000;">找到一个覆</span><span style="color:#000000;">盖了最多</span><span style="color:#da0000;"><strong>未覆盖的地</strong></span><span style="color:#da0000;"><strong>区</strong></span><span style="color:#000000;">的电台</span><span style="color:#000000;">(</span><span style="color:#000000;">此电台</span><span style="color:#000000;">可能</span><span style="color:#000000;">包</span><span style="color:#000000;">含一些已覆盖的地</span><span style="color:#000000;">区，但没有关系） </span></p> 
<p style="margin-left:0in;"><span style="color:#000000;">②将这个电台加入到一</span><span style="color:#000000;">个集合中</span><span style="color:#000000;">(</span><span style="color:#000000;">比如</span><span style="color:#000000;">ArrayList</span><span style="color:#000000;">), </span><span style="color:#000000;">想办法把该电台覆盖的地区在下次比较时去掉</span><span style="color:#000000;">。</span></p> 
<p style="margin-left:0in;"><span style="color:#000000;">③重复第</span><span style="color:#000000;">1</span><span style="color:#000000;">步</span><span style="color:#000000;">直到覆盖了全部的地区</span></p> 
<p><img alt="" class="has" height="385" src="https://images2.imgbox.com/d7/2a/pGIOhU3X_o.png" width="516"></p> 
<pre class="has"><code class="language-java">/**
 *
 * 贪心算法 - 集合覆盖问题
 */
public class GreedyAlgorithm {
    public static void main(String[] args) {
        //创建广播电台,放入到Map
        HashMap&lt;String,HashSet&lt;String&gt;&gt; broadcasts = new HashMap&lt;String, HashSet&lt;String&gt;&gt;();
        //将各个电台放入到broadcasts
        HashSet&lt;String&gt; hashSet1 = new HashSet&lt;String&gt;();
        hashSet1.add("北京");
        hashSet1.add("上海");
        hashSet1.add("天津");
        HashSet&lt;String&gt; hashSet2 = new HashSet&lt;String&gt;();
        hashSet2.add("广州");
        hashSet2.add("北京");
        hashSet2.add("深圳");
        HashSet&lt;String&gt; hashSet3 = new HashSet&lt;String&gt;();
        hashSet3.add("成都");
        hashSet3.add("上海");
        hashSet3.add("杭州");
        HashSet&lt;String&gt; hashSet4 = new HashSet&lt;String&gt;();
        hashSet4.add("上海");
        hashSet4.add("天津");
        HashSet&lt;String&gt; hashSet5 = new HashSet&lt;String&gt;();
        hashSet5.add("杭州");
        hashSet5.add("大连");

        //加入到map
        broadcasts.put("K1", hashSet1);
        broadcasts.put("K2", hashSet2);
        broadcasts.put("K3", hashSet3);
        broadcasts.put("K4", hashSet4);
        broadcasts.put("K5", hashSet5);

        //allAreas 存放所有的地区
        HashSet&lt;String&gt; allAreas = new HashSet&lt;String&gt;();
        allAreas.addAll(hashSet1);
        allAreas.addAll(hashSet2);
        allAreas.addAll(hashSet3);
        allAreas.addAll(hashSet4);
        allAreas.addAll(hashSet5);

        //创建ArrayList, 存放选择的电台集合
        ArrayList&lt;String&gt; selects = new ArrayList&lt;String&gt;();

        //定义一个临时的集合， 在遍历的过程中，存放遍历过程中的电台覆盖的地区和当前还没有覆盖的地区的交集
        HashSet&lt;String&gt; tempSet = new HashSet&lt;String&gt;();

        //定义给maxKey ， 保存在一次遍历过程中，能够覆盖最大未覆盖的地区对应的电台的key。如果maxKey 不为null , 则会加入到 selects
        String maxKey = null;
        while(allAreas.size() != 0) { // 如果allAreas 不为0, 则表示还没有覆盖到所有的地区
            maxKey = null; //每进行一次while,需要
            for(String key : broadcasts.keySet()) { //遍历 broadcasts, 取出对应key
                tempSet.clear(); //每进行一次for
                HashSet&lt;String&gt; areas = broadcasts.get(key); //当前这个key能够覆盖的地区
                tempSet.addAll(areas);
                tempSet.retainAll(allAreas); //求出tempSet 和 allAreas 集合的交集, 交集会赋给 tempSet
                //如果当前这个集合包含的未覆盖地区的数量，比maxKey指向的集合地区还多，就需要重置maxKey
                // tempSet.size() &gt;broadcasts.get(maxKey).size()) 体现出贪心算法的特点,每次都选择最优的
                if(tempSet.size() &gt; 0 &amp;&amp; (maxKey == null || tempSet.size() &gt;broadcasts.get(maxKey).size())){
                    maxKey = key;
                }
            }
            if(maxKey != null) { //maxKey != null, 就应该将maxKey 加入selects
                selects.add(maxKey);
                allAreas.removeAll(broadcasts.get(maxKey)); //将maxKey指向的广播电台覆盖的地区，从 allAreas 去掉
            }
        }
        System.out.println("得到的选择结果是" + selects);//[K1,K2,K3,K5]

    }
}
</code></pre> 
<h3><strong>5.3 贪心算法注意事项和细节</strong></h3> 
<p style="margin-left:0in;">(1)<span style="color:#3399ea;">贪婪算法所得到的结果不一定是最优的结果(有时候会是最优解)，但是都是相对近似(接近)最优解的结果。</span></p> 
<p style="margin-left:0in;">(2)<span style="color:#000000;">比</span><span style="color:#000000;">如上题的</span><span style="color:#000000;">算法选出的是</span><span style="color:#000000;">K1, K2, K3, K5</span><span style="color:#000000;">，符合覆盖了全部的地</span><span style="color:#000000;">区。</span></p> 
<p style="margin-left:0in;">(3)<span style="color:#000000;">但</span><span style="color:#000000;">是我们发现 </span><span style="color:#000000;">K2, </span><span style="color:#000000;">K3,K4,K5 </span><span style="color:#000000;">也可以覆盖全部地区，如果</span><span style="color:#000000;">K2 </span><span style="color:#000000;">的使用成本低于</span><span style="color:#000000;">K1,</span><span style="color:#000000;">那么我们上题的 </span><span style="color:#000000;">K1, K2, K3, K5 </span><span style="color:#000000;">虽然是满足条件，但是并不是最优的。</span></p> 
<p></p> 
<h2>6. 普里姆算法、克鲁斯卡尔算法、迪杰斯特拉算法、弗洛伊德算法</h2> 
<p><a href="https://blog.csdn.net/weixin_44210965/article/details/102871710" title="数据结构5 - 图_单椒煜泽的博客-CSDN博客">数据结构5 - 图_单椒煜泽的博客-CSDN博客</a></p> 
<p></p> 
<h2>7. 马踏棋盘算法</h2> 
<h3 style="margin-left:0in;"><span style="color:#0070c0;"><strong>马</strong></span><span style="color:#0070c0;"><strong>踏棋</strong></span><span style="color:#0070c0;"><strong>盘算法介绍和游戏演示</strong></span></h3> 
<p style="margin-left:0in;">1) <span style="color:#000000;">马</span><span style="color:#000000;">踏棋盘算</span><span style="color:#000000;">法</span><span style="color:#000000;">也</span><span style="color:#000000;">被称为骑</span><span style="color:#000000;">士周游问</span><span style="color:#000000;">题。</span></p> 
<p style="margin-left:0in;">2) <span style="color:#000000;">将</span><span style="color:#000000;">马随机放在国际象棋的</span><span style="color:#000000;">8×8</span><span style="color:#000000;">棋盘</span><span style="color:#000000;">Board[0</span><span style="color:#000000;">～</span><span style="color:#000000;">7][0</span><span style="color:#000000;">～</span><span style="color:#000000;">7]</span><span style="color:#000000;">的某个方格中，马按走棋规</span><span style="color:#000000;">则</span><span style="color:#000000;">(</span><span style="color:#000000;"><strong>马走日字</strong></span><span style="color:#000000;">)</span><span style="color:#000000;">进</span><span style="color:#000000;">行移动。要求每个方格只进入一次，走遍棋盘上全部</span><span style="color:#000000;">64</span><span style="color:#000000;">个方</span><span style="color:#000000;">格。</span></p> 
<p style="margin-left:0in;">3) <span style="color:#000000;">游</span><span style="color:#000000;">戏演示</span><span style="color:#000000;">: </span><span style="color:#000000;"><a href="http://www.4399.com/flash/146267_2.htm" rel="nofollow" title="http://">http://</a></span><span style="color:#000000;"><a href="http://www.4399.com/flash/146267_2.htm" rel="nofollow" title="www.4399.com/flash/146267_2.htm">www.4399.com/flash/146267_2.htm</a></span></p> 
<p style="margin-left:0in;"><img alt="" class="has" height="422" src="https://images2.imgbox.com/d9/ca/9U2vffH5_o.png" width="830"></p> 
<pre class="has"><code class="language-java">/**
 * 
 * 马踏棋盘算法
 */
public class HorseChessboard {
    public static void main(String[] args) {
        System.out.println("骑士周游算法，开始运行~~");
        //测试骑士周游算法是否正确
        X = 8;
        Y = 8;
        int row = 1; //马儿初始位置的行，从1开始编号
        int column = 1; //马儿初始位置的列，从1开始编号
        //创建棋盘
        int[][] chessboard = new int[X][Y];
        visited = new boolean[X * Y];//初始值都是false
        //测试一下耗时
//        long start = System.currentTimeMillis();
        traversalChessboard(chessboard, row - 1, column - 1, 1);
//        long end = System.currentTimeMillis();
//        System.out.println("共耗时: " + (end - start) + " 毫秒");

        //输出棋盘的最后情况
        for(int[] rows : chessboard) {
            for(int step: rows) {
                System.out.print(step + "\t");
            }
            System.out.println();
        }
    }


    private static int X; // 棋盘的列数
    private static int Y; // 棋盘的行数
    //创建一个数组，标记棋盘的各个位置是否被访问过
    private static boolean visited[];
    //使用一个属性，标记是否棋盘的所有位置都被访问
    private static boolean finished; // 如果为true,表示成功

    /**
     * 完成骑士周游问题的算法
     * @param chessboard 棋盘
     * @param row 马儿当前的位置的行 从0开始
     * @param column 马儿当前的位置的列  从0开始
     * @param step 是第几步 ,初始位置就是第1步
     */
    public static void traversalChessboard(int[][] chessboard, int row, int column, int step) {
        chessboard[row][column] = step;
        //row = 4 X = 8 column = 4 = 4 * 8 + 4 = 36 （因为visited事业从0开始，所以37就是这里的36）
        visited[row * X + column] = true; //标记该位置已经访问
        //获取当前位置可以走的下一个位置的集合
        ArrayList&lt;Point&gt; ps = next(new Point(column, row));
        sort(ps); //对ps进行排序,排序的规则就是对ps的所有的Point对象的下一步的位置的数目，进行非递减排序
        while(!ps.isEmpty()) { //遍历 ps
            Point p = ps.remove(0);//取出下一个可以走的位置
            //判断该点是否已经访问过
            if(!visited[p.y * X + p.x]) {//说明还没有访问过
                traversalChessboard(chessboard, p.y, p.x, step + 1);
            }
        }
        //判断马儿是否完成了任务，使用   step 和应该走的步数比较 ， 如果没有达到数量，则表示没有完成任务，将整个棋盘置0
        //说明: step &lt; X * Y  成立的情况有两种
        //1. 棋盘到目前位置,仍然没有走完, 2. 棋盘处于一个回溯过程
        if(step &lt; X * Y &amp;&amp; !finished ) {
            chessboard[row][column] = 0;
            visited[row * X + column] = false;
        } else {
            finished = true;
        }
    }

    /**
     * 功能： 根据当前位置(Point对象)，计算马儿还能走哪些位置(Point)，并放入到一个集合中(ArrayList), 最多有8个位置
     * @param curPoint
     * @return
     */
    public static ArrayList&lt;Point&gt; next(Point curPoint) {
        //创建一个ArrayList
        ArrayList&lt;Point&gt; ps = new ArrayList&lt;Point&gt;();
        //创建一个Point
        Point p1 = new Point();
        //表示马儿可以走5这个位置
        if((p1.x = curPoint.x - 2) &gt;= 0 &amp;&amp; (p1.y = curPoint.y -1) &gt;= 0) {
            ps.add(new Point(p1));
        }
        //判断马儿可以走6这个位置
        if((p1.x = curPoint.x - 1) &gt;=0 &amp;&amp; (p1.y=curPoint.y-2)&gt;=0) {
            ps.add(new Point(p1));
        }
        //判断马儿可以走7这个位置
        if ((p1.x = curPoint.x + 1) &lt; X &amp;&amp; (p1.y = curPoint.y - 2) &gt;= 0) {
            ps.add(new Point(p1));
        }
        //判断马儿可以走0这个位置
        if ((p1.x = curPoint.x + 2) &lt; X &amp;&amp; (p1.y = curPoint.y - 1) &gt;= 0) {
            ps.add(new Point(p1));
        }
        //判断马儿可以走1这个位置
        if ((p1.x = curPoint.x + 2) &lt; X &amp;&amp; (p1.y = curPoint.y + 1) &lt; Y) {
            ps.add(new Point(p1));
        }
        //判断马儿可以走2这个位置
        if ((p1.x = curPoint.x + 1) &lt; X &amp;&amp; (p1.y = curPoint.y + 2) &lt; Y) {
            ps.add(new Point(p1));
        }
        //判断马儿可以走3这个位置
        if ((p1.x = curPoint.x - 1) &gt;= 0 &amp;&amp; (p1.y = curPoint.y + 2) &lt; Y) {
            ps.add(new Point(p1));
        }
        //判断马儿可以走4这个位置
        if ((p1.x = curPoint.x - 2) &gt;= 0 &amp;&amp; (p1.y = curPoint.y + 1) &lt; Y) {
            ps.add(new Point(p1));
        }
        return ps;
    }

    //根据当前这个一步的所有的下一步的选择位置，进行非递减排序, 减少回溯的次数
    public static void sort(ArrayList&lt;Point&gt; ps) {
        ps.sort(new Comparator&lt;Point&gt;() {
            @Override
            public int compare(Point o1, Point o2) {
                // TODO Auto-generated method stub
                //获取到o1的下一步的所有位置个数
                int count1 = next(o1).size();
                //获取到o2的下一步的所有位置个数
                int count2 = next(o2).size();
                if(count1 &lt; count2) {
                    return -1;
                } else if (count1 == count2) {
                    return 0;
                } else {
                    return 1;
                }
            }
        });
    }
}</code></pre> 
<p></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/01f5602a352ddbcfe71c0331885419ee/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">mysql5.7安装后无法启动没有服务问题</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/9e3d43438621f77c50daa4a7c35377c0/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">mysql-单张表查询各科成绩前两名的记录</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>