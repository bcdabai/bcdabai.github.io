<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>QCustomplot - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="QCustomplot" />
<meta property="og:description" content="QCustomPlot是一个用于绘图和数据可视化的Qt C&#43;&#43;小部件。它没有进一步的依赖性，并且有很好的文档记录。该绘图库专注于制作美观、出版质量的2D绘图、图形和图表，并为实时可视化应用程序提供高性能。查看设置和基本绘图教程以开始。
QCustomPlot可以导出为各种格式，如矢量化PDF文件和光栅化图像，如PNG、JPG和BMP。QCustomPlot是在应用程序中显示实时数据以及为其他媒体生成高质量绘图的解决方案。
eg1:一个简单的带填充的衰减正弦函数及其红色指数包络
// add two new graphs and set their look: customPlot-&gt;addGraph(); customPlot-&gt;graph(0)-&gt;setPen(QPen(Qt::blue)); // line color blue for first graph customPlot-&gt;graph(0)-&gt;setBrush(QBrush(QColor(0, 0, 255, 20))); // first graph will be filled with translucent blue customPlot-&gt;addGraph(); customPlot-&gt;graph(1)-&gt;setPen(QPen(Qt::red)); // line color red for second graph // generate some points of data (y0 for first, y1 for second graph): QVector&lt;double&gt; x(251), y0(251), y1(251); for (int i=0; i&lt;251; &#43;&#43;i) { x[i] = i; y0[i] = qExp(-i/150." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/d97c449ff9e1b23f704cc44d87043edd/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-09-05T13:39:05+08:00" />
<meta property="article:modified_time" content="2022-09-05T13:39:05+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">QCustomplot</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <blockquote> 
 <p>QCustomPlot是一个用于绘图和数据可视化的Qt C++小部件。它没有进一步的依赖性，并且有很好的文档记录。该绘图库专注于制作美观、出版质量的2D绘图、图形和图表，并为实时可视化应用程序提供高性能。查看设置和基本绘图教程以开始。<br> QCustomPlot可以导出为各种格式，如矢量化PDF文件和光栅化图像，如PNG、JPG和BMP。QCustomPlot是在应用程序中显示实时数据以及为其他媒体生成高质量绘图的解决方案。</p> 
</blockquote> 
<blockquote> 
 <p> eg1:一个简单的带填充的衰减正弦函数及其红色指数包络</p> 
</blockquote> 
<p> <img alt="" height="431" src="https://images2.imgbox.com/59/13/e2pHCOsA_o.png" width="558"></p> 
<pre><code class="language-cpp">// add two new graphs and set their look:
customPlot-&gt;addGraph();
customPlot-&gt;graph(0)-&gt;setPen(QPen(Qt::blue)); // line color blue for first graph
customPlot-&gt;graph(0)-&gt;setBrush(QBrush(QColor(0, 0, 255, 20))); // first graph will be filled with translucent blue
customPlot-&gt;addGraph();
customPlot-&gt;graph(1)-&gt;setPen(QPen(Qt::red)); // line color red for second graph
// generate some points of data (y0 for first, y1 for second graph):
QVector&lt;double&gt; x(251), y0(251), y1(251);
for (int i=0; i&lt;251; ++i)
{
  x[i] = i;
  y0[i] = qExp(-i/150.0)*qCos(i/10.0); // exponentially decaying cosine
  y1[i] = qExp(-i/150.0);              // exponential envelope
}
// configure right and top axis to show ticks but no labels:
// (see QCPAxisRect::setupFullAxesBox for a quicker method to do this)
customPlot-&gt;xAxis2-&gt;setVisible(true);
customPlot-&gt;xAxis2-&gt;setTickLabels(false);
customPlot-&gt;yAxis2-&gt;setVisible(true);
customPlot-&gt;yAxis2-&gt;setTickLabels(false);
// make left and bottom axes always transfer their ranges to right and top axes:
connect(customPlot-&gt;xAxis, SIGNAL(rangeChanged(QCPRange)), customPlot-&gt;xAxis2, SLOT(setRange(QCPRange)));
connect(customPlot-&gt;yAxis, SIGNAL(rangeChanged(QCPRange)), customPlot-&gt;yAxis2, SLOT(setRange(QCPRange)));
// pass data points to graphs:
customPlot-&gt;graph(0)-&gt;setData(x, y0);
customPlot-&gt;graph(1)-&gt;setData(x, y1);
// let the ranges scale themselves so graph 0 fits perfectly in the visible area:
customPlot-&gt;graph(0)-&gt;rescaleAxes();
// same thing for graph 1, but only enlarge ranges (in case graph 1 is smaller than graph 0):
customPlot-&gt;graph(1)-&gt;rescaleAxes(true);
// Note: we could have also just called customPlot-&gt;rescaleAxes(); instead
// Allow user to drag axis ranges with mouse, zoom with mouse wheel and select graphs by clicking:
customPlot-&gt;setInteractions(QCP::iRangeDrag | QCP::iRangeZoom | QCP::iSelectPlottables);</code></pre> 
<blockquote> 
 <p>eg2:具有数据点、相应误差条和2sigma置信带的sinc函数</p> 
</blockquote> 
<p> <img alt="" height="431" src="https://images2.imgbox.com/4c/5f/KUarums6_o.jpg" width="558"></p> 
<pre><code class="language-cpp">customPlot-&gt;legend-&gt;setVisible(true);
customPlot-&gt;legend-&gt;setFont(QFont("Helvetica",9));
// set locale to english, so we get english decimal separator:
customPlot-&gt;setLocale(QLocale(QLocale::English, QLocale::UnitedKingdom));
// add confidence band graphs:
customPlot-&gt;addGraph();
QPen pen;
pen.setStyle(Qt::DotLine);
pen.setWidth(1);
pen.setColor(QColor(180,180,180));
customPlot-&gt;graph(0)-&gt;setName("Confidence Band 68%");
customPlot-&gt;graph(0)-&gt;setPen(pen);
customPlot-&gt;graph(0)-&gt;setBrush(QBrush(QColor(255,50,30,20)));
customPlot-&gt;addGraph();
customPlot-&gt;legend-&gt;removeItem(customPlot-&gt;legend-&gt;itemCount()-1); // don't show two confidence band graphs in legend
customPlot-&gt;graph(1)-&gt;setPen(pen);
customPlot-&gt;graph(0)-&gt;setChannelFillGraph(customPlot-&gt;graph(1));
// add theory curve graph:
customPlot-&gt;addGraph();
pen.setStyle(Qt::DashLine);
pen.setWidth(2);
pen.setColor(Qt::red);
customPlot-&gt;graph(2)-&gt;setPen(pen);
customPlot-&gt;graph(2)-&gt;setName("Theory Curve");
// add data point graph:
customPlot-&gt;addGraph();
customPlot-&gt;graph(3)-&gt;setPen(QPen(Qt::blue));
customPlot-&gt;graph(3)-&gt;setLineStyle(QCPGraph::lsNone);
customPlot-&gt;graph(3)-&gt;setScatterStyle(QCPScatterStyle(QCPScatterStyle::ssCross, 4));
// add error bars:
QCPErrorBars *errorBars = new QCPErrorBars(customPlot-&gt;xAxis, customPlot-&gt;yAxis);
errorBars-&gt;removeFromLegend();
errorBars-&gt;setAntialiased(false);
errorBars-&gt;setDataPlottable(customPlot-&gt;graph(3));
errorBars-&gt;setPen(QPen(QColor(180,180,180)));
customPlot-&gt;graph(3)-&gt;setName("Measurement");
 
// generate ideal sinc curve data and some randomly perturbed data for scatter plot:
QVector&lt;double&gt; x0(250), y0(250);
QVector&lt;double&gt; yConfUpper(250), yConfLower(250);
for (int i=0; i&lt;250; ++i)
{
  x0[i] = (i/249.0-0.5)*30+0.01; // by adding a small offset we make sure not do divide by zero in next code line
  y0[i] = qSin(x0[i])/x0[i]; // sinc function
  yConfUpper[i] = y0[i]+0.15;
  yConfLower[i] = y0[i]-0.15;
  x0[i] *= 1000;
}
QVector&lt;double&gt; x1(50), y1(50), y1err(50);
for (int i=0; i&lt;50; ++i)
{
  // generate a gaussian distributed random number:
  double tmp1 = rand()/(double)RAND_MAX;
  double tmp2 = rand()/(double)RAND_MAX;
  double r = qSqrt(-2*qLn(tmp1))*qCos(2*M_PI*tmp2); // box-muller transform for gaussian distribution
  // set y1 to value of y0 plus a random gaussian pertubation:
  x1[i] = (i/50.0-0.5)*30+0.25;
  y1[i] = qSin(x1[i])/x1[i]+r*0.15;
  x1[i] *= 1000;
  y1err[i] = 0.15;
}
// pass data to graphs and let QCustomPlot determine the axes ranges so the whole thing is visible:
customPlot-&gt;graph(0)-&gt;setData(x0, yConfUpper);
customPlot-&gt;graph(1)-&gt;setData(x0, yConfLower);
customPlot-&gt;graph(2)-&gt;setData(x0, y0);
customPlot-&gt;graph(3)-&gt;setData(x1, y1);
errorBars-&gt;setData(y1err);
customPlot-&gt;graph(2)-&gt;rescaleAxes();
customPlot-&gt;graph(3)-&gt;rescaleAxes(true);
// setup look of bottom tick labels:
customPlot-&gt;xAxis-&gt;setTickLabelRotation(30);
customPlot-&gt;xAxis-&gt;ticker()-&gt;setTickCount(9);
customPlot-&gt;xAxis-&gt;setNumberFormat("ebc");
customPlot-&gt;xAxis-&gt;setNumberPrecision(1);
customPlot-&gt;xAxis-&gt;moveRange(-10);
// make top right axes clones of bottom left axes. Looks prettier:
customPlot-&gt;axisRect()-&gt;setupFullAxesBox();</code></pre> 
<blockquote> 
 <p> eg3:几种散点样式的演示</p> 
</blockquote> 
<p> <img alt="" height="431" src="https://images2.imgbox.com/d4/17/EuQbqXKw_o.jpg" width="558"></p> 
<pre><code class="language-cpp">customPlot-&gt;legend-&gt;setVisible(true);
customPlot-&gt;legend-&gt;setFont(QFont("Helvetica", 9));
customPlot-&gt;legend-&gt;setRowSpacing(-3);
QVector&lt;QCPScatterStyle::ScatterShape&gt; shapes;
shapes &lt;&lt; QCPScatterStyle::ssCross;
shapes &lt;&lt; QCPScatterStyle::ssPlus;
shapes &lt;&lt; QCPScatterStyle::ssCircle;
shapes &lt;&lt; QCPScatterStyle::ssDisc;
shapes &lt;&lt; QCPScatterStyle::ssSquare;
shapes &lt;&lt; QCPScatterStyle::ssDiamond;
shapes &lt;&lt; QCPScatterStyle::ssStar;
shapes &lt;&lt; QCPScatterStyle::ssTriangle;
shapes &lt;&lt; QCPScatterStyle::ssTriangleInverted;
shapes &lt;&lt; QCPScatterStyle::ssCrossSquare;
shapes &lt;&lt; QCPScatterStyle::ssPlusSquare;
shapes &lt;&lt; QCPScatterStyle::ssCrossCircle;
shapes &lt;&lt; QCPScatterStyle::ssPlusCircle;
shapes &lt;&lt; QCPScatterStyle::ssPeace;
shapes &lt;&lt; QCPScatterStyle::ssCustom;
 
QPen pen;
// add graphs with different scatter styles:
for (int i=0; i&lt;shapes.size(); ++i)
{
  customPlot-&gt;addGraph();
  pen.setColor(QColor(qSin(i*0.3)*100+100, qSin(i*0.6+0.7)*100+100, qSin(i*0.4+0.6)*100+100));
  // generate data:
  QVector&lt;double&gt; x(10), y(10);
  for (int k=0; k&lt;10; ++k)
  {
    x[k] = k/10.0 * 4*3.14 + 0.01;
    y[k] = 7*qSin(x[k])/x[k] + (shapes.size()-i)*5;
  }
  customPlot-&gt;graph()-&gt;setData(x, y);
  customPlot-&gt;graph()-&gt;rescaleAxes(true);
  customPlot-&gt;graph()-&gt;setPen(pen);
  customPlot-&gt;graph()-&gt;setName(QCPScatterStyle::staticMetaObject.enumerator(QCPScatterStyle::staticMetaObject.indexOfEnumerator("ScatterShape")).valueToKey(shapes.at(i)));
  customPlot-&gt;graph()-&gt;setLineStyle(QCPGraph::lsLine);
  // set scatter style:
  if (shapes.at(i) != QCPScatterStyle::ssCustom)
  {
    customPlot-&gt;graph()-&gt;setScatterStyle(QCPScatterStyle(shapes.at(i), 10));
  }
  else
  {
    QPainterPath customScatterPath;
    for (int i=0; i&lt;3; ++i)
      customScatterPath.cubicTo(qCos(2*M_PI*i/3.0)*9, qSin(2*M_PI*i/3.0)*9, qCos(2*M_PI*(i+0.9)/3.0)*9, qSin(2*M_PI*(i+0.9)/3.0)*9, 0, 0);
    customPlot-&gt;graph()-&gt;setScatterStyle(QCPScatterStyle(customScatterPath, QPen(Qt::black, 0), QColor(40, 70, 255, 50), 10));
  }
}
// set blank axis lines:
customPlot-&gt;rescaleAxes();
customPlot-&gt;xAxis-&gt;setTicks(false);
customPlot-&gt;yAxis-&gt;setTicks(false);
customPlot-&gt;xAxis-&gt;setTickLabels(false);
customPlot-&gt;yAxis-&gt;setTickLabels(false);
// make top right axes clones of bottom left axes:
customPlot-&gt;axisRect()-&gt;setupFullAxesBox();</code></pre> 
<blockquote> 
 <p>eg4:演示QCustomPlot在设置情节样式方面的多功能性</p> 
</blockquote> 
<p> <img alt="" height="431" src="https://images2.imgbox.com/b1/b8/lJz63env_o.jpg" width="558">eg</p> 
<blockquote> 
 <pre><code class="language-cpp">// prepare data:
QVector&lt;double&gt; x1(20), y1(20);
QVector&lt;double&gt; x2(100), y2(100);
QVector&lt;double&gt; x3(20), y3(20);
QVector&lt;double&gt; x4(20), y4(20);
for (int i=0; i&lt;x1.size(); ++i)
{
  x1[i] = i/(double)(x1.size()-1)*10;
  y1[i] = qCos(x1[i]*0.8+qSin(x1[i]*0.16+1.0))*qSin(x1[i]*0.54)+1.4;
}
for (int i=0; i&lt;x2.size(); ++i)
{
  x2[i] = i/(double)(x2.size()-1)*10;
  y2[i] = qCos(x2[i]*0.85+qSin(x2[i]*0.165+1.1))*qSin(x2[i]*0.50)+1.7;
}
for (int i=0; i&lt;x3.size(); ++i)
{
  x3[i] = i/(double)(x3.size()-1)*10;
  y3[i] = 0.05+3*(0.5+qCos(x3[i]*x3[i]*0.2+2)*0.5)/(double)(x3[i]+0.7)+qrand()/(double)RAND_MAX*0.01;
}
for (int i=0; i&lt;x4.size(); ++i)
{
  x4[i] = x3[i];
  y4[i] = (0.5-y3[i])+((x4[i]-2)*(x4[i]-2)*0.02);
}
 
// create and configure plottables:
QCPGraph *graph1 = customPlot-&gt;addGraph();
graph1-&gt;setData(x1, y1);
graph1-&gt;setScatterStyle(QCPScatterStyle(QCPScatterStyle::ssCircle, QPen(Qt::black, 1.5), QBrush(Qt::white), 9));
graph1-&gt;setPen(QPen(QColor(120, 120, 120), 2));
 
QCPGraph *graph2 = customPlot-&gt;addGraph();
graph2-&gt;setData(x2, y2);
graph2-&gt;setPen(Qt::NoPen);
graph2-&gt;setBrush(QColor(200, 200, 200, 20));
graph2-&gt;setChannelFillGraph(graph1);
 
QCPBars *bars1 = new QCPBars(customPlot-&gt;xAxis, customPlot-&gt;yAxis);
bars1-&gt;setWidth(9/(double)x3.size());
bars1-&gt;setData(x3, y3);
bars1-&gt;setPen(Qt::NoPen);
bars1-&gt;setBrush(QColor(10, 140, 70, 160));
 
QCPBars *bars2 = new QCPBars(customPlot-&gt;xAxis, customPlot-&gt;yAxis);
bars2-&gt;setWidth(9/(double)x4.size());
bars2-&gt;setData(x4, y4);
bars2-&gt;setPen(Qt::NoPen);
bars2-&gt;setBrush(QColor(10, 100, 50, 70));
bars2-&gt;moveAbove(bars1);
 
// move bars above graphs and grid below bars:
customPlot-&gt;addLayer("abovemain", customPlot-&gt;layer("main"), QCustomPlot::limAbove);
customPlot-&gt;addLayer("belowmain", customPlot-&gt;layer("main"), QCustomPlot::limBelow);
graph1-&gt;setLayer("abovemain");
customPlot-&gt;xAxis-&gt;grid()-&gt;setLayer("belowmain");
customPlot-&gt;yAxis-&gt;grid()-&gt;setLayer("belowmain");
 
// set some pens, brushes and backgrounds:
customPlot-&gt;xAxis-&gt;setBasePen(QPen(Qt::white, 1));
customPlot-&gt;yAxis-&gt;setBasePen(QPen(Qt::white, 1));
customPlot-&gt;xAxis-&gt;setTickPen(QPen(Qt::white, 1));
customPlot-&gt;yAxis-&gt;setTickPen(QPen(Qt::white, 1));
customPlot-&gt;xAxis-&gt;setSubTickPen(QPen(Qt::white, 1));
customPlot-&gt;yAxis-&gt;setSubTickPen(QPen(Qt::white, 1));
customPlot-&gt;xAxis-&gt;setTickLabelColor(Qt::white);
customPlot-&gt;yAxis-&gt;setTickLabelColor(Qt::white);
customPlot-&gt;xAxis-&gt;grid()-&gt;setPen(QPen(QColor(140, 140, 140), 1, Qt::DotLine));
customPlot-&gt;yAxis-&gt;grid()-&gt;setPen(QPen(QColor(140, 140, 140), 1, Qt::DotLine));
customPlot-&gt;xAxis-&gt;grid()-&gt;setSubGridPen(QPen(QColor(80, 80, 80), 1, Qt::DotLine));
customPlot-&gt;yAxis-&gt;grid()-&gt;setSubGridPen(QPen(QColor(80, 80, 80), 1, Qt::DotLine));
customPlot-&gt;xAxis-&gt;grid()-&gt;setSubGridVisible(true);
customPlot-&gt;yAxis-&gt;grid()-&gt;setSubGridVisible(true);
customPlot-&gt;xAxis-&gt;grid()-&gt;setZeroLinePen(Qt::NoPen);
customPlot-&gt;yAxis-&gt;grid()-&gt;setZeroLinePen(Qt::NoPen);
customPlot-&gt;xAxis-&gt;setUpperEnding(QCPLineEnding::esSpikeArrow);
customPlot-&gt;yAxis-&gt;setUpperEnding(QCPLineEnding::esSpikeArrow);
QLinearGradient plotGradient;
plotGradient.setStart(0, 0);
plotGradient.setFinalStop(0, 350);
plotGradient.setColorAt(0, QColor(80, 80, 80));
plotGradient.setColorAt(1, QColor(50, 50, 50));
customPlot-&gt;setBackground(plotGradient);
QLinearGradient axisRectGradient;
axisRectGradient.setStart(0, 0);
axisRectGradient.setFinalStop(0, 350);
axisRectGradient.setColorAt(0, QColor(80, 80, 80));
axisRectGradient.setColorAt(1, QColor(30, 30, 30));
customPlot-&gt;axisRect()-&gt;setBackground(axisRectGradient);
 
customPlot-&gt;rescaleAxes();
customPlot-&gt;yAxis-&gt;setRange(0, 2);</code></pre> 
</blockquote> 
<blockquote> 
 <p> eg5:一个带有色阶的二维彩色地图。色阶可以像轴一样拖动和缩放</p> 
</blockquote> 
<p> <img alt="" height="431" src="https://images2.imgbox.com/8d/ef/z7MSrIUd_o.jpg" width="558"></p> 
<pre><code class="language-cpp">// configure axis rect:
customPlot-&gt;setInteractions(QCP::iRangeDrag|QCP::iRangeZoom); // this will also allow rescaling the color scale by dragging/zooming
customPlot-&gt;axisRect()-&gt;setupFullAxesBox(true);
customPlot-&gt;xAxis-&gt;setLabel("x");
customPlot-&gt;yAxis-&gt;setLabel("y");
 
// set up the QCPColorMap:
QCPColorMap *colorMap = new QCPColorMap(customPlot-&gt;xAxis, customPlot-&gt;yAxis);
int nx = 200;
int ny = 200;
colorMap-&gt;data()-&gt;setSize(nx, ny); // we want the color map to have nx * ny data points
colorMap-&gt;data()-&gt;setRange(QCPRange(-4, 4), QCPRange(-4, 4)); // and span the coordinate range -4..4 in both key (x) and value (y) dimensions
// now we assign some data, by accessing the QCPColorMapData instance of the color map:
double x, y, z;
for (int xIndex=0; xIndex&lt;nx; ++xIndex)
{
  for (int yIndex=0; yIndex&lt;ny; ++yIndex)
  {
    colorMap-&gt;data()-&gt;cellToCoord(xIndex, yIndex, &amp;x, &amp;y);
    double r = 3*qSqrt(x*x+y*y)+1e-2;
    z = 2*x*(qCos(r+2)/r-qSin(r+2)/r); // the B field strength of dipole radiation (modulo physical constants)
    colorMap-&gt;data()-&gt;setCell(xIndex, yIndex, z);
  }
}
 
// add a color scale:
QCPColorScale *colorScale = new QCPColorScale(customPlot);
customPlot-&gt;plotLayout()-&gt;addElement(0, 1, colorScale); // add it to the right of the main axis rect
colorScale-&gt;setType(QCPAxis::atRight); // scale shall be vertical bar with tick/axis labels right (actually atRight is already the default)
colorMap-&gt;setColorScale(colorScale); // associate the color map with the color scale
colorScale-&gt;axis()-&gt;setLabel("Magnetic Field Strength");
 
// set the color gradient of the color map to one of the presets:
colorMap-&gt;setGradient(QCPColorGradient::gpPolar);
// we could have also created a QCPColorGradient instance and added own colors to
// the gradient, see the documentation of QCPColorGradient for what's possible.
 
// rescale the data dimension (color) such that all data points lie in the span visualized by the color gradient:
colorMap-&gt;rescaleDataRange();
 
// make sure the axis rect and color scale synchronize their bottom and top margins (so they line up):
QCPMarginGroup *marginGroup = new QCPMarginGroup(customPlot);
customPlot-&gt;axisRect()-&gt;setMarginGroup(QCP::msBottom|QCP::msTop, marginGroup);
colorScale-&gt;setMarginGroup(QCP::msBottom|QCP::msTop, marginGroup);
 
// rescale the key (x) and value (y) axes so the whole color map is visible:
customPlot-&gt;rescaleAxes();</code></pre> 
<blockquote> 
 <p>eg6:Pixmap散点和多行轴标签，以及顶部的绘图标题</p> 
</blockquote> 
<p> <img alt="" height="431" src="https://images2.imgbox.com/46/66/6mKLlepR_o.jpg" width="558"></p> 
<pre><code class="language-cpp">customPlot-&gt;axisRect()-&gt;setBackground(QPixmap("./solarpanels.jpg"));
customPlot-&gt;addGraph();
customPlot-&gt;graph()-&gt;setLineStyle(QCPGraph::lsLine);
QPen pen;
pen.setColor(QColor(255, 200, 20, 200));
pen.setStyle(Qt::DashLine);
pen.setWidthF(2.5);
customPlot-&gt;graph()-&gt;setPen(pen);
customPlot-&gt;graph()-&gt;setBrush(QBrush(QColor(255,200,20,70)));
customPlot-&gt;graph()-&gt;setScatterStyle(QCPScatterStyle(QPixmap("./sun.png")));
// set graph name, will show up in legend next to icon:
customPlot-&gt;graph()-&gt;setName("Data from Photovoltaic\nenergy barometer 2011");
// set data:
QVector&lt;double&gt; year, value;
year  &lt;&lt; 2005 &lt;&lt; 2006 &lt;&lt; 2007 &lt;&lt; 2008  &lt;&lt; 2009  &lt;&lt; 2010 &lt;&lt; 2011;
value &lt;&lt; 2.17 &lt;&lt; 3.42 &lt;&lt; 4.94 &lt;&lt; 10.38 &lt;&lt; 15.86 &lt;&lt; 29.33 &lt;&lt; 52.1;
customPlot-&gt;graph()-&gt;setData(year, value);
 
// set title of plot:
customPlot-&gt;plotLayout()-&gt;insertRow(0);
customPlot-&gt;plotLayout()-&gt;addElement(0, 0, new QCPTextElement(customPlot, "Regenerative Energies", QFont("sans", 12, QFont::Bold)));
// axis configurations:
customPlot-&gt;xAxis-&gt;setLabel("Year");
customPlot-&gt;yAxis-&gt;setLabel("Installed Gigawatts of\nphotovoltaic in the European Union");
customPlot-&gt;xAxis2-&gt;setVisible(true);
customPlot-&gt;yAxis2-&gt;setVisible(true);
customPlot-&gt;xAxis2-&gt;setTickLabels(false);
customPlot-&gt;yAxis2-&gt;setTickLabels(false);
customPlot-&gt;xAxis2-&gt;setTicks(false);
customPlot-&gt;yAxis2-&gt;setTicks(false);
customPlot-&gt;xAxis2-&gt;setSubTicks(false);
customPlot-&gt;yAxis2-&gt;setSubTicks(false);
customPlot-&gt;xAxis-&gt;setRange(2004.5, 2011.5);
customPlot-&gt;yAxis-&gt;setRange(0, 52);
// setup legend:
customPlot-&gt;legend-&gt;setFont(QFont(font().family(), 7));
customPlot-&gt;legend-&gt;setIconSize(50, 20);
customPlot-&gt;legend-&gt;setVisible(true);
customPlot-&gt;axisRect()-&gt;insetLayout()-&gt;setInsetAlignment(0, Qt::AlignLeft | Qt::AlignTop);
</code></pre> 
<blockquote> 
 <p> eg7:实时生成数据和时间底轴</p> 
</blockquote> 
<p> <img alt="" height="431" src="https://images2.imgbox.com/80/03/TQ7ogKGM_o.jpg" width="558"></p> 
<p></p> 
<pre><code class="language-cpp">Setup function:
customPlot-&gt;addGraph(); // blue line
customPlot-&gt;graph(0)-&gt;setPen(QPen(QColor(40, 110, 255)));
customPlot-&gt;addGraph(); // red line
customPlot-&gt;graph(1)-&gt;setPen(QPen(QColor(255, 110, 40)));
 
QSharedPointer&lt;QCPAxisTickerTime&gt; timeTicker(new QCPAxisTickerTime);
timeTicker-&gt;setTimeFormat("%h:%m:%s");
customPlot-&gt;xAxis-&gt;setTicker(timeTicker);
customPlot-&gt;axisRect()-&gt;setupFullAxesBox();
customPlot-&gt;yAxis-&gt;setRange(-1.2, 1.2);
 
// make left and bottom axes transfer their ranges to right and top axes:
connect(customPlot-&gt;xAxis, SIGNAL(rangeChanged(QCPRange)), customPlot-&gt;xAxis2, SLOT(setRange(QCPRange)));
connect(customPlot-&gt;yAxis, SIGNAL(rangeChanged(QCPRange)), customPlot-&gt;yAxis2, SLOT(setRange(QCPRange)));
 
// setup a timer that repeatedly calls MainWindow::realtimeDataSlot:
connect(&amp;dataTimer, SIGNAL(timeout()), this, SLOT(realtimeDataSlot()));
dataTimer.start(0); // Interval 0 means to refresh as fast as possible


realtimeDataSlot, called by timer:
static QTime time(QTime::currentTime());
// calculate two new data points:
double key = time.elapsed()/1000.0; // time elapsed since start of demo, in seconds
static double lastPointKey = 0;
if (key-lastPointKey &gt; 0.002) // at most add point every 2 ms
{
  // add data to lines:
  ui-&gt;customPlot-&gt;graph(0)-&gt;addData(key, qSin(key)+qrand()/(double)RAND_MAX*1*qSin(key/0.3843));
  ui-&gt;customPlot-&gt;graph(1)-&gt;addData(key, qCos(key)+qrand()/(double)RAND_MAX*0.5*qSin(key/0.4364));
  // rescale value (vertical) axis to fit the current data:
  //ui-&gt;customPlot-&gt;graph(0)-&gt;rescaleValueAxis();
  //ui-&gt;customPlot-&gt;graph(1)-&gt;rescaleValueAxis(true);
  lastPointKey = key;
}
// make key axis range scroll with the data (at a constant range size of 8):
ui-&gt;customPlot-&gt;xAxis-&gt;setRange(key, 8, Qt::AlignRight);
ui-&gt;customPlot-&gt;replot();
 
// calculate frames per second:
static double lastFpsKey;
static int frameCount;
++frameCount;
if (key-lastFpsKey &gt; 2) // average fps over 2 seconds
{
  ui-&gt;statusBar-&gt;showMessage(
        QString("%1 FPS, Total Data points: %2")
        .arg(frameCount/(key-lastFpsKey), 0, 'f', 0)
        .arg(ui-&gt;customPlot-&gt;graph(0)-&gt;data()-&gt;size()+ui-&gt;customPlot-&gt;graph(1)-&gt;data()-&gt;size())
        , 0);
  lastFpsKey = key;
  frameCount = 0;
}</code></pre> 
<blockquote> 
 <p>eg8:具有不同键/值轴和顶部轴圆周率刻度标记的多种绘图样式</p> 
</blockquote> 
<p> <img alt="" height="431" src="https://images2.imgbox.com/e1/9d/lTf9q7o6_o.jpg" width="558"></p> 
<p></p> 
<pre><code class="language-cpp">customPlot-&gt;setLocale(QLocale(QLocale::English, QLocale::UnitedKingdom)); // period as decimal separator and comma as thousand separator
customPlot-&gt;legend-&gt;setVisible(true);
QFont legendFont = font();  // start out with MainWindow's font..
legendFont.setPointSize(9); // and make a bit smaller for legend
customPlot-&gt;legend-&gt;setFont(legendFont);
customPlot-&gt;legend-&gt;setBrush(QBrush(QColor(255,255,255,230)));
// by default, the legend is in the inset layout of the main axis rect. So this is how we access it to change legend placement:
customPlot-&gt;axisRect()-&gt;insetLayout()-&gt;setInsetAlignment(0, Qt::AlignBottom|Qt::AlignRight);
 
// setup for graph 0: key axis left, value axis bottom
// will contain left maxwell-like function
customPlot-&gt;addGraph(customPlot-&gt;yAxis, customPlot-&gt;xAxis);
customPlot-&gt;graph(0)-&gt;setPen(QPen(QColor(255, 100, 0)));
customPlot-&gt;graph(0)-&gt;setBrush(QBrush(QPixmap("./balboa.jpg"))); // fill with texture of specified image
customPlot-&gt;graph(0)-&gt;setLineStyle(QCPGraph::lsLine);
customPlot-&gt;graph(0)-&gt;setScatterStyle(QCPScatterStyle(QCPScatterStyle::ssDisc, 5));
customPlot-&gt;graph(0)-&gt;setName("Left maxwell function");
 
// setup for graph 1: key axis bottom, value axis left (those are the default axes)
// will contain bottom maxwell-like function with error bars
customPlot-&gt;addGraph();
customPlot-&gt;graph(1)-&gt;setPen(QPen(Qt::red));
customPlot-&gt;graph(1)-&gt;setBrush(QBrush(QPixmap("./balboa.jpg"))); // same fill as we used for graph 0
customPlot-&gt;graph(1)-&gt;setLineStyle(QCPGraph::lsStepCenter);
customPlot-&gt;graph(1)-&gt;setScatterStyle(QCPScatterStyle(QCPScatterStyle::ssCircle, Qt::red, Qt::white, 7));
customPlot-&gt;graph(1)-&gt;setName("Bottom maxwell function");
QCPErrorBars *errorBars = new QCPErrorBars(customPlot-&gt;xAxis, customPlot-&gt;yAxis);
errorBars-&gt;removeFromLegend();
errorBars-&gt;setDataPlottable(customPlot-&gt;graph(1));
 
// setup for graph 2: key axis top, value axis right
// will contain high frequency sine with low frequency beating:
customPlot-&gt;addGraph(customPlot-&gt;xAxis2, customPlot-&gt;yAxis2);
customPlot-&gt;graph(2)-&gt;setPen(QPen(Qt::blue));
customPlot-&gt;graph(2)-&gt;setName("High frequency sine");
 
// setup for graph 3: same axes as graph 2
// will contain low frequency beating envelope of graph 2
customPlot-&gt;addGraph(customPlot-&gt;xAxis2, customPlot-&gt;yAxis2);
QPen blueDotPen;
blueDotPen.setColor(QColor(30, 40, 255, 150));
blueDotPen.setStyle(Qt::DotLine);
blueDotPen.setWidthF(4);
customPlot-&gt;graph(3)-&gt;setPen(blueDotPen);
customPlot-&gt;graph(3)-&gt;setName("Sine envelope");
 
// setup for graph 4: key axis right, value axis top
// will contain parabolically distributed data points with some random perturbance
customPlot-&gt;addGraph(customPlot-&gt;yAxis2, customPlot-&gt;xAxis2);
customPlot-&gt;graph(4)-&gt;setPen(QColor(50, 50, 50, 255));
customPlot-&gt;graph(4)-&gt;setLineStyle(QCPGraph::lsNone);
customPlot-&gt;graph(4)-&gt;setScatterStyle(QCPScatterStyle(QCPScatterStyle::ssCircle, 4));
customPlot-&gt;graph(4)-&gt;setName("Some random data around\na quadratic function");
 
// generate data, just playing with numbers, not much to learn here:
QVector&lt;double&gt; x0(25), y0(25);
QVector&lt;double&gt; x1(15), y1(15), y1err(15);
QVector&lt;double&gt; x2(250), y2(250);
QVector&lt;double&gt; x3(250), y3(250);
QVector&lt;double&gt; x4(250), y4(250);
for (int i=0; i&lt;25; ++i) // data for graph 0
{
  x0[i] = 3*i/25.0;
  y0[i] = qExp(-x0[i]*x0[i]*0.8)*(x0[i]*x0[i]+x0[i]);
}
for (int i=0; i&lt;15; ++i) // data for graph 1
{
  x1[i] = 3*i/15.0;;
  y1[i] = qExp(-x1[i]*x1[i])*(x1[i]*x1[i])*2.6;
  y1err[i] = y1[i]*0.25;
}
for (int i=0; i&lt;250; ++i) // data for graphs 2, 3 and 4
{
  x2[i] = i/250.0*3*M_PI;
  x3[i] = x2[i];
  x4[i] = i/250.0*100-50;
  y2[i] = qSin(x2[i]*12)*qCos(x2[i])*10;
  y3[i] = qCos(x3[i])*10;
  y4[i] = 0.01*x4[i]*x4[i] + 1.5*(rand()/(double)RAND_MAX-0.5) + 1.5*M_PI;
}
 
// pass data points to graphs:
customPlot-&gt;graph(0)-&gt;setData(x0, y0);
customPlot-&gt;graph(1)-&gt;setData(x1, y1);
errorBars-&gt;setData(y1err);
customPlot-&gt;graph(2)-&gt;setData(x2, y2);
customPlot-&gt;graph(3)-&gt;setData(x3, y3);
customPlot-&gt;graph(4)-&gt;setData(x4, y4);
// activate top and right axes, which are invisible by default:
customPlot-&gt;xAxis2-&gt;setVisible(true);
customPlot-&gt;yAxis2-&gt;setVisible(true);
// set ranges appropriate to show data:
customPlot-&gt;xAxis-&gt;setRange(0, 2.7);
customPlot-&gt;yAxis-&gt;setRange(0, 2.6);
customPlot-&gt;xAxis2-&gt;setRange(0, 3.0*M_PI);
customPlot-&gt;yAxis2-&gt;setRange(-70, 35);
// set pi ticks on top axis:
customPlot-&gt;xAxis2-&gt;setTicker(QSharedPointer&lt;QCPAxisTickerPi&gt;(new QCPAxisTickerPi));
// add title layout element:
customPlot-&gt;plotLayout()-&gt;insertRow(0);
customPlot-&gt;plotLayout()-&gt;addElement(0, 0, new QCPTextElement(customPlot, "Way too many graphs in one plot", QFont("sans", 12, QFont::Bold)));
// set labels:
customPlot-&gt;xAxis-&gt;setLabel("Bottom axis with outward ticks");
customPlot-&gt;yAxis-&gt;setLabel("Left axis label");
customPlot-&gt;xAxis2-&gt;setLabel("Top axis label");
customPlot-&gt;yAxis2-&gt;setLabel("Right axis label");
// make ticks on bottom axis go outward:
customPlot-&gt;xAxis-&gt;setTickLength(0, 5);
customPlot-&gt;xAxis-&gt;setSubTickLength(0, 3);
// make ticks on right axis go inward and outward:
customPlot-&gt;yAxis2-&gt;setTickLength(3, 3);
customPlot-&gt;yAxis2-&gt;setSubTickLength(1, 1);</code></pre> 
<blockquote> 
 <p>eg9:对数轴缩放。正弦函数在负无穷远处过零点的正确显示注记</p> 
</blockquote> 
<p> <img alt="" height="431" src="https://images2.imgbox.com/63/f8/i3iU1gkV_o.jpg" width="558"></p> 
<p></p> 
<pre><code class="language-cpp">customPlot-&gt;setNoAntialiasingOnDrag(true); // more performance/responsiveness during dragging
customPlot-&gt;addGraph();
QPen pen;
pen.setColor(QColor(255,170,100));
pen.setWidth(2);
pen.setStyle(Qt::DotLine);
customPlot-&gt;graph(0)-&gt;setPen(pen);
customPlot-&gt;graph(0)-&gt;setName("x");
 
customPlot-&gt;addGraph();
customPlot-&gt;graph(1)-&gt;setPen(QPen(Qt::red));
customPlot-&gt;graph(1)-&gt;setBrush(QBrush(QColor(255, 0, 0, 20)));
customPlot-&gt;graph(1)-&gt;setName("-sin(x)exp(x)");
 
customPlot-&gt;addGraph();
customPlot-&gt;graph(2)-&gt;setPen(QPen(Qt::blue));
customPlot-&gt;graph(2)-&gt;setBrush(QBrush(QColor(0, 0, 255, 20)));
customPlot-&gt;graph(2)-&gt;setName(" sin(x)exp(x)");
 
customPlot-&gt;addGraph();
pen.setColor(QColor(0,0,0));
pen.setWidth(1);
pen.setStyle(Qt::DashLine);
customPlot-&gt;graph(3)-&gt;setPen(pen);
customPlot-&gt;graph(3)-&gt;setBrush(QBrush(QColor(0,0,0,15)));
customPlot-&gt;graph(3)-&gt;setLineStyle(QCPGraph::lsStepCenter);
customPlot-&gt;graph(3)-&gt;setName("x!");
 
const int dataCount = 200;
const int dataFactorialCount = 21;
QVector&lt;QCPGraphData&gt; dataLinear(dataCount), dataMinusSinExp(dataCount), dataPlusSinExp(dataCount), dataFactorial(dataFactorialCount);
for (int i=0; i&lt;dataCount; ++i)
{
  dataLinear[i].key = i/10.0;
  dataLinear[i].value = dataLinear[i].key;
  dataMinusSinExp[i].key = i/10.0;
  dataMinusSinExp[i].value = -qSin(dataMinusSinExp[i].key)*qExp(dataMinusSinExp[i].key);
  dataPlusSinExp[i].key = i/10.0;
  dataPlusSinExp[i].value = qSin(dataPlusSinExp[i].key)*qExp(dataPlusSinExp[i].key);
}
for (int i=0; i&lt;dataFactorialCount; ++i)
{
  dataFactorial[i].key = i;
  dataFactorial[i].value = 1.0;
  for (int k=1; k&lt;=i; ++k) dataFactorial[i].value *= k; // factorial
}
customPlot-&gt;graph(0)-&gt;data()-&gt;set(dataLinear);
customPlot-&gt;graph(1)-&gt;data()-&gt;set(dataMinusSinExp);
customPlot-&gt;graph(2)-&gt;data()-&gt;set(dataPlusSinExp);
customPlot-&gt;graph(3)-&gt;data()-&gt;set(dataFactorial);
 
customPlot-&gt;yAxis-&gt;grid()-&gt;setSubGridVisible(true);
customPlot-&gt;xAxis-&gt;grid()-&gt;setSubGridVisible(true);
customPlot-&gt;yAxis-&gt;setScaleType(QCPAxis::stLogarithmic);
customPlot-&gt;yAxis2-&gt;setScaleType(QCPAxis::stLogarithmic);
QSharedPointer&lt;QCPAxisTickerLog&gt; logTicker(new QCPAxisTickerLog);
customPlot-&gt;yAxis-&gt;setTicker(logTicker);
customPlot-&gt;yAxis2-&gt;setTicker(logTicker);
customPlot-&gt;yAxis-&gt;setNumberFormat("eb"); // e = exponential, b = beautiful decimal powers
customPlot-&gt;yAxis-&gt;setNumberPrecision(0); // makes sure "1*10^4" is displayed only as "10^4"
customPlot-&gt;xAxis-&gt;setRange(0, 19.9);
customPlot-&gt;yAxis-&gt;setRange(1e-2, 1e10);
// make range draggable and zoomable:
customPlot-&gt;setInteractions(QCP::iRangeDrag | QCP::iRangeZoom);
 
// make top right axes clones of bottom left axes:
customPlot-&gt;axisRect()-&gt;setupFullAxesBox();
// connect signals so top and right axes move in sync with bottom and left axes:
connect(customPlot-&gt;xAxis, SIGNAL(rangeChanged(QCPRange)), customPlot-&gt;xAxis2, SLOT(setRange(QCPRange)));
connect(customPlot-&gt;yAxis, SIGNAL(rangeChanged(QCPRange)), customPlot-&gt;yAxis2, SLOT(setRange(QCPRange)));
 
customPlot-&gt;legend-&gt;setVisible(true);
customPlot-&gt;legend-&gt;setBrush(QBrush(QColor(255,255,255,150)));
customPlot-&gt;axisRect()-&gt;insetLayout()-&gt;setInsetAlignment(0, Qt::AlignLeft|Qt::AlignTop); // make legend align in top left corner or axis rect
</code></pre> 
<blockquote> 
 <p>eg10:几种线条风格的演示</p> 
</blockquote> 
<p> <img alt="" height="431" src="https://images2.imgbox.com/18/72/yyKLZ6jB_o.jpg" width="558"></p> 
<pre><code class="language-cpp">customPlot-&gt;legend-&gt;setVisible(true);
customPlot-&gt;legend-&gt;setFont(QFont("Helvetica", 9));
QPen pen;
QStringList lineNames;
lineNames &lt;&lt; "lsNone" &lt;&lt; "lsLine" &lt;&lt; "lsStepLeft" &lt;&lt; "lsStepRight" &lt;&lt; "lsStepCenter" &lt;&lt; "lsImpulse";
// add graphs with different line styles:
for (int i=QCPGraph::lsNone; i&lt;=QCPGraph::lsImpulse; ++i)
{
  customPlot-&gt;addGraph();
  pen.setColor(QColor(qSin(i*1+1.2)*80+80, qSin(i*0.3+0)*80+80, qSin(i*0.3+1.5)*80+80));
  customPlot-&gt;graph()-&gt;setPen(pen);
  customPlot-&gt;graph()-&gt;setName(lineNames.at(i-QCPGraph::lsNone));
  customPlot-&gt;graph()-&gt;setLineStyle((QCPGraph::LineStyle)i);
  customPlot-&gt;graph()-&gt;setScatterStyle(QCPScatterStyle(QCPScatterStyle::ssCircle, 5));
  // generate data:
  QVector&lt;double&gt; x(15), y(15);
  for (int j=0; j&lt;15; ++j)
  {
    x[j] = j/15.0 * 5*3.14 + 0.01;
    y[j] = 7*qSin(x[j])/x[j] - (i-QCPGraph::lsNone)*5 + (QCPGraph::lsImpulse)*5 + 2;
  }
  customPlot-&gt;graph()-&gt;setData(x, y);
  customPlot-&gt;graph()-&gt;rescaleAxes(true);
}
// zoom out a bit:
customPlot-&gt;yAxis-&gt;scaleRange(1.1, customPlot-&gt;yAxis-&gt;range().center());
customPlot-&gt;xAxis-&gt;scaleRange(1.1, customPlot-&gt;xAxis-&gt;range().center());
// set blank axis lines:
customPlot-&gt;xAxis-&gt;setTicks(false);
customPlot-&gt;yAxis-&gt;setTicks(true);
customPlot-&gt;xAxis-&gt;setTickLabels(false);
customPlot-&gt;yAxis-&gt;setTickLabels(true);
// make top right axes clones of bottom left axes:
customPlot-&gt;axisRect()-&gt;setupFullAxesBox();</code></pre> 
<blockquote> 
 <p>eg11:在底轴上使用填充和智能日期刻度的随机游动</p> 
</blockquote> 
<p> <img alt="" height="431" src="https://images2.imgbox.com/c2/1c/I4BVgx3u_o.jpg" width="558"></p> 
<pre><code class="language-cpp">// set locale to english, so we get english month names:
customPlot-&gt;setLocale(QLocale(QLocale::English, QLocale::UnitedKingdom));
// seconds of current time, we'll use it as starting point in time for data:
double now = QDateTime::currentDateTime().toTime_t();
srand(8); // set the random seed, so we always get the same random data
// create multiple graphs:
for (int gi=0; gi&lt;5; ++gi)
{
  customPlot-&gt;addGraph();
  QColor color(20+200/4.0*gi,70*(1.6-gi/4.0), 150, 150);
  customPlot-&gt;graph()-&gt;setLineStyle(QCPGraph::lsLine);
  customPlot-&gt;graph()-&gt;setPen(QPen(color.lighter(200)));
  customPlot-&gt;graph()-&gt;setBrush(QBrush(color));
  // generate random walk data:
  QVector&lt;QCPGraphData&gt; timeData(250);
  for (int i=0; i&lt;250; ++i)
  {
    timeData[i].key = now + 24*3600*i;
    if (i == 0)
      timeData[i].value = (i/50.0+1)*(rand()/(double)RAND_MAX-0.5);
    else
      timeData[i].value = qFabs(timeData[i-1].value)*(1+0.02/4.0*(4-gi)) + (i/50.0+1)*(rand()/(double)RAND_MAX-0.5);
  }
  customPlot-&gt;graph()-&gt;data()-&gt;set(timeData);
}
// configure bottom axis to show date instead of number:
QSharedPointer&lt;QCPAxisTickerDateTime&gt; dateTicker(new QCPAxisTickerDateTime);
dateTicker-&gt;setDateTimeFormat("d. MMMM\nyyyy");
customPlot-&gt;xAxis-&gt;setTicker(dateTicker);
// configure left axis text labels:
QSharedPointer&lt;QCPAxisTickerText&gt; textTicker(new QCPAxisTickerText);
textTicker-&gt;addTick(10, "a bit\nlow");
textTicker-&gt;addTick(50, "quite\nhigh");
customPlot-&gt;yAxis-&gt;setTicker(textTicker);
// set a more compact font size for bottom and left axis tick labels:
customPlot-&gt;xAxis-&gt;setTickLabelFont(QFont(QFont().family(), 8));
customPlot-&gt;yAxis-&gt;setTickLabelFont(QFont(QFont().family(), 8));
// set axis labels:
customPlot-&gt;xAxis-&gt;setLabel("Date");
customPlot-&gt;yAxis-&gt;setLabel("Random wobbly lines value");
// make top and right axes visible but without ticks and labels:
customPlot-&gt;xAxis2-&gt;setVisible(true);
customPlot-&gt;yAxis2-&gt;setVisible(true);
customPlot-&gt;xAxis2-&gt;setTicks(false);
customPlot-&gt;yAxis2-&gt;setTicks(false);
customPlot-&gt;xAxis2-&gt;setTickLabels(false);
customPlot-&gt;yAxis2-&gt;setTickLabels(false);
// set axis ranges to show all data:
customPlot-&gt;xAxis-&gt;setRange(now, now+24*3600*249);
customPlot-&gt;yAxis-&gt;setRange(0, 60);
// show legend with slightly transparent background brush:
customPlot-&gt;legend-&gt;setVisible(true);
customPlot-&gt;legend-&gt;setBrush(QColor(255, 255, 255, 150));</code></pre> 
<blockquote> 
 <p> eg12:半透明梯度填充参数曲线</p> 
</blockquote> 
<p><img alt="" height="431" src="https://images2.imgbox.com/78/32/GLKvOiqJ_o.jpg" width="558"></p> 
<p></p> 
<pre><code class="language-cpp">// create empty curve objects:
QCPCurve *fermatSpiral1 = new QCPCurve(customPlot-&gt;xAxis, customPlot-&gt;yAxis);
QCPCurve *fermatSpiral2 = new QCPCurve(customPlot-&gt;xAxis, customPlot-&gt;yAxis);
QCPCurve *deltoidRadial = new QCPCurve(customPlot-&gt;xAxis, customPlot-&gt;yAxis);
// generate the curve data points:
const int pointCount = 500;
QVector&lt;QCPCurveData&gt; dataSpiral1(pointCount), dataSpiral2(pointCount), dataDeltoid(pointCount);
for (int i=0; i&lt;pointCount; ++i)
{
  double phi = i/(double)(pointCount-1)*8*M_PI;
  double theta = i/(double)(pointCount-1)*2*M_PI;
  dataSpiral1[i] = QCPCurveData(i, qSqrt(phi)*qCos(phi), qSqrt(phi)*qSin(phi));
  dataSpiral2[i] = QCPCurveData(i, -dataSpiral1[i].key, -dataSpiral1[i].value);
  dataDeltoid[i] = QCPCurveData(i, 2*qCos(2*theta)+qCos(1*theta)+2*qSin(theta), 2*qSin(2*theta)-qSin(1*theta));
}
// pass the data to the curves; we know t (i in loop above) is ascending, so set alreadySorted=true (saves an extra internal sort):
fermatSpiral1-&gt;data()-&gt;set(dataSpiral1, true);
fermatSpiral2-&gt;data()-&gt;set(dataSpiral2, true);
deltoidRadial-&gt;data()-&gt;set(dataDeltoid, true);
// color the curves:
fermatSpiral1-&gt;setPen(QPen(Qt::blue));
fermatSpiral1-&gt;setBrush(QBrush(QColor(0, 0, 255, 20)));
fermatSpiral2-&gt;setPen(QPen(QColor(255, 120, 0)));
fermatSpiral2-&gt;setBrush(QBrush(QColor(255, 120, 0, 30)));
QRadialGradient radialGrad(QPointF(310, 180), 200);
radialGrad.setColorAt(0, QColor(170, 20, 240, 100));
radialGrad.setColorAt(0.5, QColor(20, 10, 255, 40));
radialGrad.setColorAt(1,QColor(120, 20, 240, 10));
deltoidRadial-&gt;setPen(QPen(QColor(170, 20, 240)));
deltoidRadial-&gt;setBrush(QBrush(radialGrad));
// set some basic customPlot config:
customPlot-&gt;setInteractions(QCP::iRangeDrag | QCP::iRangeZoom | QCP::iSelectPlottables);
customPlot-&gt;axisRect()-&gt;setupFullAxesBox();
customPlot-&gt;rescaleAxes();</code></pre> 
<blockquote> 
 <p>eg13:带手动x轴刻度标签的三个堆叠条形图</p> 
</blockquote> 
<p> <img alt="" height="431" src="https://images2.imgbox.com/bb/d7/TqgASFj0_o.jpg" width="558"></p> 
<p></p> 
<pre><code class="language-cpp">// set dark background gradient:
QLinearGradient gradient(0, 0, 0, 400);
gradient.setColorAt(0, QColor(90, 90, 90));
gradient.setColorAt(0.38, QColor(105, 105, 105));
gradient.setColorAt(1, QColor(70, 70, 70));
customPlot-&gt;setBackground(QBrush(gradient));
 
// create empty bar chart objects:
QCPBars *regen = new QCPBars(customPlot-&gt;xAxis, customPlot-&gt;yAxis);
QCPBars *nuclear = new QCPBars(customPlot-&gt;xAxis, customPlot-&gt;yAxis);
QCPBars *fossil = new QCPBars(customPlot-&gt;xAxis, customPlot-&gt;yAxis);
regen-&gt;setAntialiased(false); // gives more crisp, pixel aligned bar borders
nuclear-&gt;setAntialiased(false);
fossil-&gt;setAntialiased(false);
regen-&gt;setStackingGap(1);
nuclear-&gt;setStackingGap(1);
fossil-&gt;setStackingGap(1);
// set names and colors:
fossil-&gt;setName("Fossil fuels");
fossil-&gt;setPen(QPen(QColor(111, 9, 176).lighter(170)));
fossil-&gt;setBrush(QColor(111, 9, 176));
nuclear-&gt;setName("Nuclear");
nuclear-&gt;setPen(QPen(QColor(250, 170, 20).lighter(150)));
nuclear-&gt;setBrush(QColor(250, 170, 20));
regen-&gt;setName("Regenerative");
regen-&gt;setPen(QPen(QColor(0, 168, 140).lighter(130)));
regen-&gt;setBrush(QColor(0, 168, 140));
// stack bars on top of each other:
nuclear-&gt;moveAbove(fossil);
regen-&gt;moveAbove(nuclear);
 
// prepare x axis with country labels:
QVector&lt;double&gt; ticks;
QVector&lt;QString&gt; labels;
ticks &lt;&lt; 1 &lt;&lt; 2 &lt;&lt; 3 &lt;&lt; 4 &lt;&lt; 5 &lt;&lt; 6 &lt;&lt; 7;
labels &lt;&lt; "USA" &lt;&lt; "Japan" &lt;&lt; "Germany" &lt;&lt; "France" &lt;&lt; "UK" &lt;&lt; "Italy" &lt;&lt; "Canada";
QSharedPointer&lt;QCPAxisTickerText&gt; textTicker(new QCPAxisTickerText);
textTicker-&gt;addTicks(ticks, labels);
customPlot-&gt;xAxis-&gt;setTicker(textTicker);
customPlot-&gt;xAxis-&gt;setTickLabelRotation(60);
customPlot-&gt;xAxis-&gt;setSubTicks(false);
customPlot-&gt;xAxis-&gt;setTickLength(0, 4);
customPlot-&gt;xAxis-&gt;setRange(0, 8);
customPlot-&gt;xAxis-&gt;setBasePen(QPen(Qt::white));
customPlot-&gt;xAxis-&gt;setTickPen(QPen(Qt::white));
customPlot-&gt;xAxis-&gt;grid()-&gt;setVisible(true);
customPlot-&gt;xAxis-&gt;grid()-&gt;setPen(QPen(QColor(130, 130, 130), 0, Qt::DotLine));
customPlot-&gt;xAxis-&gt;setTickLabelColor(Qt::white);
customPlot-&gt;xAxis-&gt;setLabelColor(Qt::white);
 
// prepare y axis:
customPlot-&gt;yAxis-&gt;setRange(0, 12.1);
customPlot-&gt;yAxis-&gt;setPadding(5); // a bit more space to the left border
customPlot-&gt;yAxis-&gt;setLabel("Power Consumption in\nKilowatts per Capita (2007)");
customPlot-&gt;yAxis-&gt;setBasePen(QPen(Qt::white));
customPlot-&gt;yAxis-&gt;setTickPen(QPen(Qt::white));
customPlot-&gt;yAxis-&gt;setSubTickPen(QPen(Qt::white));
customPlot-&gt;yAxis-&gt;grid()-&gt;setSubGridVisible(true);
customPlot-&gt;yAxis-&gt;setTickLabelColor(Qt::white);
customPlot-&gt;yAxis-&gt;setLabelColor(Qt::white);
customPlot-&gt;yAxis-&gt;grid()-&gt;setPen(QPen(QColor(130, 130, 130), 0, Qt::SolidLine));
customPlot-&gt;yAxis-&gt;grid()-&gt;setSubGridPen(QPen(QColor(130, 130, 130), 0, Qt::DotLine));
 
// Add data:
QVector&lt;double&gt; fossilData, nuclearData, regenData;
fossilData  &lt;&lt; 0.86*10.5 &lt;&lt; 0.83*5.5 &lt;&lt; 0.84*5.5 &lt;&lt; 0.52*5.8 &lt;&lt; 0.89*5.2 &lt;&lt; 0.90*4.2 &lt;&lt; 0.67*11.2;
nuclearData &lt;&lt; 0.08*10.5 &lt;&lt; 0.12*5.5 &lt;&lt; 0.12*5.5 &lt;&lt; 0.40*5.8 &lt;&lt; 0.09*5.2 &lt;&lt; 0.00*4.2 &lt;&lt; 0.07*11.2;
regenData   &lt;&lt; 0.06*10.5 &lt;&lt; 0.05*5.5 &lt;&lt; 0.04*5.5 &lt;&lt; 0.06*5.8 &lt;&lt; 0.02*5.2 &lt;&lt; 0.07*4.2 &lt;&lt; 0.25*11.2;
fossil-&gt;setData(ticks, fossilData);
nuclear-&gt;setData(ticks, nuclearData);
regen-&gt;setData(ticks, regenData);
 
// setup legend:
customPlot-&gt;legend-&gt;setVisible(true);
customPlot-&gt;axisRect()-&gt;insetLayout()-&gt;setInsetAlignment(0, Qt::AlignTop|Qt::AlignHCenter);
customPlot-&gt;legend-&gt;setBrush(QColor(255, 255, 255, 100));
customPlot-&gt;legend-&gt;setBorderPen(Qt::NoPen);
QFont legendFont = font();
legendFont.setPointSize(10);
customPlot-&gt;legend-&gt;setFont(legendFont);
customPlot-&gt;setInteractions(QCP::iRangeDrag | QCP::iRangeZoom);</code></pre> 
<blockquote> 
 <p>eg14:带离群点的统计5参数盒图</p> 
</blockquote> 
<p> <img alt="" height="431" src="https://images2.imgbox.com/37/b8/ZOFtypjh_o.jpg" width="558"></p> 
<p></p> 
<pre><code class="language-cpp">QCPStatisticalBox *statistical = new QCPStatisticalBox(customPlot-&gt;xAxis, customPlot-&gt;yAxis);
QBrush boxBrush(QColor(60, 60, 255, 100));
boxBrush.setStyle(Qt::Dense6Pattern); // make it look oldschool
statistical-&gt;setBrush(boxBrush);
 
// specify data:
statistical-&gt;addData(1, 1.1, 1.9, 2.25, 2.7, 4.2);
statistical-&gt;addData(2, 0.8, 1.6, 2.2, 3.2, 4.9, QVector&lt;double&gt;() &lt;&lt; 0.7 &lt;&lt; 0.34 &lt;&lt; 0.45 &lt;&lt; 6.2 &lt;&lt; 5.84); // provide some outliers as QVector
statistical-&gt;addData(3, 0.2, 0.7, 1.1, 1.6, 2.9);
 
// prepare manual x axis labels:
customPlot-&gt;xAxis-&gt;setSubTicks(false);
customPlot-&gt;xAxis-&gt;setTickLength(0, 4);
customPlot-&gt;xAxis-&gt;setTickLabelRotation(20);
QSharedPointer&lt;QCPAxisTickerText&gt; textTicker(new QCPAxisTickerText);
textTicker-&gt;addTick(1, "Sample 1");
textTicker-&gt;addTick(2, "Sample 2");
textTicker-&gt;addTick(3, "Control Group");
customPlot-&gt;xAxis-&gt;setTicker(textTicker);
 
// prepare axes:
customPlot-&gt;yAxis-&gt;setLabel(QString::fromUtf8("O₂ Absorption [mg]"));
customPlot-&gt;rescaleAxes();
customPlot-&gt;xAxis-&gt;scaleRange(1.7, customPlot-&gt;xAxis-&gt;range().center());
customPlot-&gt;yAxis-&gt;setRange(0, 7);
customPlot-&gt;setInteractions(QCP::iRangeDrag | QCP::iRangeZoom);</code></pre> 
<blockquote> 
 <p>eg15:</p> 
</blockquote> 
<p><img alt="" height="532" src="https://images2.imgbox.com/df/3b/dv7gwxcM_o.jpg" width="634"></p> 
<p></p> 
<pre><code class="language-cpp">#include "mainwindow.h"
#include "ui_mainwindow.h"
 
MainWindow::MainWindow(QWidget *parent) :
  QMainWindow(parent),
  ui(new Ui::MainWindow)
{
  srand(QDateTime::currentDateTime().toTime_t());
  ui-&gt;setupUi(this);
   
  ui-&gt;customPlot-&gt;setInteractions(QCP::iRangeDrag | QCP::iRangeZoom | QCP::iSelectAxes |
                                  QCP::iSelectLegend | QCP::iSelectPlottables);
  ui-&gt;customPlot-&gt;xAxis-&gt;setRange(-8, 8);
  ui-&gt;customPlot-&gt;yAxis-&gt;setRange(-5, 5);
  ui-&gt;customPlot-&gt;axisRect()-&gt;setupFullAxesBox();
   
  ui-&gt;customPlot-&gt;plotLayout()-&gt;insertRow(0);
  QCPTextElement *title = new QCPTextElement(ui-&gt;customPlot, "Interaction Example", QFont("sans", 17, QFont::Bold));
  ui-&gt;customPlot-&gt;plotLayout()-&gt;addElement(0, 0, title);
   
  ui-&gt;customPlot-&gt;xAxis-&gt;setLabel("x Axis");
  ui-&gt;customPlot-&gt;yAxis-&gt;setLabel("y Axis");
  ui-&gt;customPlot-&gt;legend-&gt;setVisible(true);
  QFont legendFont = font();
  legendFont.setPointSize(10);
  ui-&gt;customPlot-&gt;legend-&gt;setFont(legendFont);
  ui-&gt;customPlot-&gt;legend-&gt;setSelectedFont(legendFont);
  ui-&gt;customPlot-&gt;legend-&gt;setSelectableParts(QCPLegend::spItems); // legend box shall not be selectable, only legend items
   
  addRandomGraph();
  addRandomGraph();
  addRandomGraph();
  addRandomGraph();
  ui-&gt;customPlot-&gt;rescaleAxes();
   
  // connect slot that ties some axis selections together (especially opposite axes):
  connect(ui-&gt;customPlot, SIGNAL(selectionChangedByUser()), this, SLOT(selectionChanged()));
  // connect slots that takes care that when an axis is selected, only that direction can be dragged and zoomed:
  connect(ui-&gt;customPlot, SIGNAL(mousePress(QMouseEvent*)), this, SLOT(mousePress()));
  connect(ui-&gt;customPlot, SIGNAL(mouseWheel(QWheelEvent*)), this, SLOT(mouseWheel()));
   
  // make bottom and left axes transfer their ranges to top and right axes:
  connect(ui-&gt;customPlot-&gt;xAxis, SIGNAL(rangeChanged(QCPRange)), ui-&gt;customPlot-&gt;xAxis2, SLOT(setRange(QCPRange)));
  connect(ui-&gt;customPlot-&gt;yAxis, SIGNAL(rangeChanged(QCPRange)), ui-&gt;customPlot-&gt;yAxis2, SLOT(setRange(QCPRange)));
   
  // connect some interaction slots:
  connect(ui-&gt;customPlot, SIGNAL(axisDoubleClick(QCPAxis*,QCPAxis::SelectablePart,QMouseEvent*)), this, SLOT(axisLabelDoubleClick(QCPAxis*,QCPAxis::SelectablePart)));
  connect(ui-&gt;customPlot, SIGNAL(legendDoubleClick(QCPLegend*,QCPAbstractLegendItem*,QMouseEvent*)), this, SLOT(legendDoubleClick(QCPLegend*,QCPAbstractLegendItem*)));
  connect(title, SIGNAL(doubleClicked(QMouseEvent*)), this, SLOT(titleDoubleClick(QMouseEvent*)));
   
  // connect slot that shows a message in the status bar when a graph is clicked:
  connect(ui-&gt;customPlot, SIGNAL(plottableClick(QCPAbstractPlottable*,int,QMouseEvent*)), this, SLOT(graphClicked(QCPAbstractPlottable*,int)));
   
  // setup policy and connect slot for context menu popup:
  ui-&gt;customPlot-&gt;setContextMenuPolicy(Qt::CustomContextMenu);
  connect(ui-&gt;customPlot, SIGNAL(customContextMenuRequested(QPoint)), this, SLOT(contextMenuRequest(QPoint)));
}
 
MainWindow::~MainWindow()
{
  delete ui;
}
 
void MainWindow::titleDoubleClick(QMouseEvent* event)
{
  Q_UNUSED(event)
  if (QCPTextElement *title = qobject_cast&lt;QCPTextElement*&gt;(sender()))
  {
    // Set the plot title by double clicking on it
    bool ok;
    QString newTitle = QInputDialog::getText(this, "QCustomPlot example", "New plot title:", QLineEdit::Normal, title-&gt;text(), &amp;ok);
    if (ok)
    {
      title-&gt;setText(newTitle);
      ui-&gt;customPlot-&gt;replot();
    }
  }
}
 
void MainWindow::axisLabelDoubleClick(QCPAxis *axis, QCPAxis::SelectablePart part)
{
  // Set an axis label by double clicking on it
  if (part == QCPAxis::spAxisLabel) // only react when the actual axis label is clicked, not tick label or axis backbone
  {
    bool ok;
    QString newLabel = QInputDialog::getText(this, "QCustomPlot example", "New axis label:", QLineEdit::Normal, axis-&gt;label(), &amp;ok);
    if (ok)
    {
      axis-&gt;setLabel(newLabel);
      ui-&gt;customPlot-&gt;replot();
    }
  }
}
 
void MainWindow::legendDoubleClick(QCPLegend *legend, QCPAbstractLegendItem *item)
{
  // Rename a graph by double clicking on its legend item
  Q_UNUSED(legend)
  if (item) // only react if item was clicked (user could have clicked on border padding of legend where there is no item, then item is 0)
  {
    QCPPlottableLegendItem *plItem = qobject_cast&lt;QCPPlottableLegendItem*&gt;(item);
    bool ok;
    QString newName = QInputDialog::getText(this, "QCustomPlot example", "New graph name:", QLineEdit::Normal, plItem-&gt;plottable()-&gt;name(), &amp;ok);
    if (ok)
    {
      plItem-&gt;plottable()-&gt;setName(newName);
      ui-&gt;customPlot-&gt;replot();
    }
  }
}
 
void MainWindow::selectionChanged()
{
  /*
   normally, axis base line, axis tick labels and axis labels are selectable separately, but we want
   the user only to be able to select the axis as a whole, so we tie the selected states of the tick labels
   and the axis base line together. However, the axis label shall be selectable individually.
    
   The selection state of the left and right axes shall be synchronized as well as the state of the
   bottom and top axes.
    
   Further, we want to synchronize the selection of the graphs with the selection state of the respective
   legend item belonging to that graph. So the user can select a graph by either clicking on the graph itself
   or on its legend item.
  */
   
  // make top and bottom axes be selected synchronously, and handle axis and tick labels as one selectable object:
  if (ui-&gt;customPlot-&gt;xAxis-&gt;selectedParts().testFlag(QCPAxis::spAxis) || ui-&gt;customPlot-&gt;xAxis-&gt;selectedParts().testFlag(QCPAxis::spTickLabels) ||
      ui-&gt;customPlot-&gt;xAxis2-&gt;selectedParts().testFlag(QCPAxis::spAxis) || ui-&gt;customPlot-&gt;xAxis2-&gt;selectedParts().testFlag(QCPAxis::spTickLabels))
  {
    ui-&gt;customPlot-&gt;xAxis2-&gt;setSelectedParts(QCPAxis::spAxis|QCPAxis::spTickLabels);
    ui-&gt;customPlot-&gt;xAxis-&gt;setSelectedParts(QCPAxis::spAxis|QCPAxis::spTickLabels);
  }
  // make left and right axes be selected synchronously, and handle axis and tick labels as one selectable object:
  if (ui-&gt;customPlot-&gt;yAxis-&gt;selectedParts().testFlag(QCPAxis::spAxis) || ui-&gt;customPlot-&gt;yAxis-&gt;selectedParts().testFlag(QCPAxis::spTickLabels) ||
      ui-&gt;customPlot-&gt;yAxis2-&gt;selectedParts().testFlag(QCPAxis::spAxis) || ui-&gt;customPlot-&gt;yAxis2-&gt;selectedParts().testFlag(QCPAxis::spTickLabels))
  {
    ui-&gt;customPlot-&gt;yAxis2-&gt;setSelectedParts(QCPAxis::spAxis|QCPAxis::spTickLabels);
    ui-&gt;customPlot-&gt;yAxis-&gt;setSelectedParts(QCPAxis::spAxis|QCPAxis::spTickLabels);
  }
   
  // synchronize selection of graphs with selection of corresponding legend items:
  for (int i=0; i&lt;ui-&gt;customPlot-&gt;graphCount(); ++i)
  {
    QCPGraph *graph = ui-&gt;customPlot-&gt;graph(i);
    QCPPlottableLegendItem *item = ui-&gt;customPlot-&gt;legend-&gt;itemWithPlottable(graph);
    if (item-&gt;selected() || graph-&gt;selected())
    {
      item-&gt;setSelected(true);
      graph-&gt;setSelection(QCPDataSelection(graph-&gt;data()-&gt;dataRange()));
    }
  }
}
 
void MainWindow::mousePress()
{
  // if an axis is selected, only allow the direction of that axis to be dragged
  // if no axis is selected, both directions may be dragged
   
  if (ui-&gt;customPlot-&gt;xAxis-&gt;selectedParts().testFlag(QCPAxis::spAxis))
    ui-&gt;customPlot-&gt;axisRect()-&gt;setRangeDrag(ui-&gt;customPlot-&gt;xAxis-&gt;orientation());
  else if (ui-&gt;customPlot-&gt;yAxis-&gt;selectedParts().testFlag(QCPAxis::spAxis))
    ui-&gt;customPlot-&gt;axisRect()-&gt;setRangeDrag(ui-&gt;customPlot-&gt;yAxis-&gt;orientation());
  else
    ui-&gt;customPlot-&gt;axisRect()-&gt;setRangeDrag(Qt::Horizontal|Qt::Vertical);
}
 
void MainWindow::mouseWheel()
{
  // if an axis is selected, only allow the direction of that axis to be zoomed
  // if no axis is selected, both directions may be zoomed
   
  if (ui-&gt;customPlot-&gt;xAxis-&gt;selectedParts().testFlag(QCPAxis::spAxis))
    ui-&gt;customPlot-&gt;axisRect()-&gt;setRangeZoom(ui-&gt;customPlot-&gt;xAxis-&gt;orientation());
  else if (ui-&gt;customPlot-&gt;yAxis-&gt;selectedParts().testFlag(QCPAxis::spAxis))
    ui-&gt;customPlot-&gt;axisRect()-&gt;setRangeZoom(ui-&gt;customPlot-&gt;yAxis-&gt;orientation());
  else
    ui-&gt;customPlot-&gt;axisRect()-&gt;setRangeZoom(Qt::Horizontal|Qt::Vertical);
}
 
void MainWindow::addRandomGraph()
{
  int n = 50; // number of points in graph
  double xScale = (rand()/(double)RAND_MAX + 0.5)*2;
  double yScale = (rand()/(double)RAND_MAX + 0.5)*2;
  double xOffset = (rand()/(double)RAND_MAX - 0.5)*4;
  double yOffset = (rand()/(double)RAND_MAX - 0.5)*10;
  double r1 = (rand()/(double)RAND_MAX - 0.5)*2;
  double r2 = (rand()/(double)RAND_MAX - 0.5)*2;
  double r3 = (rand()/(double)RAND_MAX - 0.5)*2;
  double r4 = (rand()/(double)RAND_MAX - 0.5)*2;
  QVector&lt;double&gt; x(n), y(n);
  for (int i=0; i&lt;n; i++)
  {
    x[i] = (i/(double)n-0.5)*10.0*xScale + xOffset;
    y[i] = (qSin(x[i]*r1*5)*qSin(qCos(x[i]*r2)*r4*3)+r3*qCos(qSin(x[i])*r4*2))*yScale + yOffset;
  }
   
  ui-&gt;customPlot-&gt;addGraph();
  ui-&gt;customPlot-&gt;graph()-&gt;setName(QString("New graph %1").arg(ui-&gt;customPlot-&gt;graphCount()-1));
  ui-&gt;customPlot-&gt;graph()-&gt;setData(x, y);
  ui-&gt;customPlot-&gt;graph()-&gt;setLineStyle((QCPGraph::LineStyle)(rand()%5+1));
  if (rand()%100 &gt; 50)
    ui-&gt;customPlot-&gt;graph()-&gt;setScatterStyle(QCPScatterStyle((QCPScatterStyle::ScatterShape)(rand()%14+1)));
  QPen graphPen;
  graphPen.setColor(QColor(rand()%245+10, rand()%245+10, rand()%245+10));
  graphPen.setWidthF(rand()/(double)RAND_MAX*2+1);
  ui-&gt;customPlot-&gt;graph()-&gt;setPen(graphPen);
  ui-&gt;customPlot-&gt;replot();
}
 
void MainWindow::removeSelectedGraph()
{
  if (ui-&gt;customPlot-&gt;selectedGraphs().size() &gt; 0)
  {
    ui-&gt;customPlot-&gt;removeGraph(ui-&gt;customPlot-&gt;selectedGraphs().first());
    ui-&gt;customPlot-&gt;replot();
  }
}
 
void MainWindow::removeAllGraphs()
{
  ui-&gt;customPlot-&gt;clearGraphs();
  ui-&gt;customPlot-&gt;replot();
}
 
void MainWindow::contextMenuRequest(QPoint pos)
{
  QMenu *menu = new QMenu(this);
  menu-&gt;setAttribute(Qt::WA_DeleteOnClose);
   
  if (ui-&gt;customPlot-&gt;legend-&gt;selectTest(pos, false) &gt;= 0) // context menu on legend requested
  {
    menu-&gt;addAction("Move to top left", this, SLOT(moveLegend()))-&gt;setData((int)(Qt::AlignTop|Qt::AlignLeft));
    menu-&gt;addAction("Move to top center", this, SLOT(moveLegend()))-&gt;setData((int)(Qt::AlignTop|Qt::AlignHCenter));
    menu-&gt;addAction("Move to top right", this, SLOT(moveLegend()))-&gt;setData((int)(Qt::AlignTop|Qt::AlignRight));
    menu-&gt;addAction("Move to bottom right", this, SLOT(moveLegend()))-&gt;setData((int)(Qt::AlignBottom|Qt::AlignRight));
    menu-&gt;addAction("Move to bottom left", this, SLOT(moveLegend()))-&gt;setData((int)(Qt::AlignBottom|Qt::AlignLeft));
  } else  // general context menu on graphs requested
  {
    menu-&gt;addAction("Add random graph", this, SLOT(addRandomGraph()));
    if (ui-&gt;customPlot-&gt;selectedGraphs().size() &gt; 0)
      menu-&gt;addAction("Remove selected graph", this, SLOT(removeSelectedGraph()));
    if (ui-&gt;customPlot-&gt;graphCount() &gt; 0)
      menu-&gt;addAction("Remove all graphs", this, SLOT(removeAllGraphs()));
  }
   
  menu-&gt;popup(ui-&gt;customPlot-&gt;mapToGlobal(pos));
}
 
void MainWindow::moveLegend()
{
  if (QAction* contextAction = qobject_cast&lt;QAction*&gt;(sender())) // make sure this slot is really called by a context menu action, so it carries the data we need
  {
    bool ok;
    int dataInt = contextAction-&gt;data().toInt(&amp;ok);
    if (ok)
    {
      ui-&gt;customPlot-&gt;axisRect()-&gt;insetLayout()-&gt;setInsetAlignment(0, (Qt::Alignment)dataInt);
      ui-&gt;customPlot-&gt;replot();
    }
  }
}
 
void MainWindow::graphClicked(QCPAbstractPlottable *plottable, int dataIndex)
{
  // since we know we only have QCPGraphs in the plot, we can immediately access interface1D()
  // usually it's better to first check whether interface1D() returns non-zero, and only then use it.
  double dataValue = plottable-&gt;interface1D()-&gt;dataMainValue(dataIndex);
  QString message = QString("Clicked on graph '%1' at data point #%2 with value %3.").arg(plottable-&gt;name()).arg(dataIndex).arg(dataValue);
  ui-&gt;statusBar-&gt;showMessage(message, 2500);
}</code></pre> 
<blockquote> 
 <p>eg16:</p> 
</blockquote> 
<p> <img alt="" height="431" src="https://images2.imgbox.com/bd/a1/V3CGLLTx_o.jpg" width="558"></p> 
<p> </p> 
<pre><code class="language-cpp">Setup function:
customPlot-&gt;setInteractions(QCP::iRangeDrag | QCP::iRangeZoom);
QCPGraph *graph = customPlot-&gt;addGraph();
int n = 500;
double phase = 0;
double k = 3;
QVector&lt;double&gt; x(n), y(n);
for (int i=0; i&lt;n; ++i)
{
  x[i] = i/(double)(n-1)*34 - 17;
  y[i] = qExp(-x[i]*x[i]/20.0)*qSin(k*x[i]+phase);
}
graph-&gt;setData(x, y);
graph-&gt;setPen(QPen(Qt::blue));
graph-&gt;rescaleKeyAxis();
customPlot-&gt;yAxis-&gt;setRange(-1.45, 1.65);
customPlot-&gt;xAxis-&gt;grid()-&gt;setZeroLinePen(Qt::NoPen);
 
// add the bracket at the top:
QCPItemBracket *bracket = new QCPItemBracket(customPlot);
bracket-&gt;left-&gt;setCoords(-8, 1.1);
bracket-&gt;right-&gt;setCoords(8, 1.1);
bracket-&gt;setLength(13);
 
// add the text label at the top:
QCPItemText *wavePacketText = new QCPItemText(customPlot);
wavePacketText-&gt;position-&gt;setParentAnchor(bracket-&gt;center);
wavePacketText-&gt;position-&gt;setCoords(0, -10); // move 10 pixels to the top from bracket center anchor
wavePacketText-&gt;setPositionAlignment(Qt::AlignBottom|Qt::AlignHCenter);
wavePacketText-&gt;setText("Wavepacket");
wavePacketText-&gt;setFont(QFont(font().family(), 10));
 
// add the phase tracer (red circle) which sticks to the graph data (and gets updated in bracketDataSlot by timer event):
QCPItemTracer *phaseTracer = new QCPItemTracer(customPlot);
itemDemoPhaseTracer = phaseTracer; // so we can access it later in the bracketDataSlot for animation
phaseTracer-&gt;setGraph(graph);
phaseTracer-&gt;setGraphKey((M_PI*1.5-phase)/k);
phaseTracer-&gt;setInterpolating(true);
phaseTracer-&gt;setStyle(QCPItemTracer::tsCircle);
phaseTracer-&gt;setPen(QPen(Qt::red));
phaseTracer-&gt;setBrush(Qt::red);
phaseTracer-&gt;setSize(7);
 
// add label for phase tracer:
QCPItemText *phaseTracerText = new QCPItemText(customPlot);
phaseTracerText-&gt;position-&gt;setType(QCPItemPosition::ptAxisRectRatio);
phaseTracerText-&gt;setPositionAlignment(Qt::AlignRight|Qt::AlignBottom);
phaseTracerText-&gt;position-&gt;setCoords(1.0, 0.95); // lower right corner of axis rect
phaseTracerText-&gt;setText("Points of fixed\nphase define\nphase velocity vp");
phaseTracerText-&gt;setTextAlignment(Qt::AlignLeft);
phaseTracerText-&gt;setFont(QFont(font().family(), 9));
phaseTracerText-&gt;setPadding(QMargins(8, 0, 0, 0));
 
// add arrow pointing at phase tracer, coming from label:
QCPItemCurve *phaseTracerArrow = new QCPItemCurve(customPlot);
phaseTracerArrow-&gt;start-&gt;setParentAnchor(phaseTracerText-&gt;left);
phaseTracerArrow-&gt;startDir-&gt;setParentAnchor(phaseTracerArrow-&gt;start);
phaseTracerArrow-&gt;startDir-&gt;setCoords(-40, 0); // direction 30 pixels to the left of parent anchor (tracerArrow-&gt;start)
phaseTracerArrow-&gt;end-&gt;setParentAnchor(phaseTracer-&gt;position);
phaseTracerArrow-&gt;end-&gt;setCoords(10, 10);
phaseTracerArrow-&gt;endDir-&gt;setParentAnchor(phaseTracerArrow-&gt;end);
phaseTracerArrow-&gt;endDir-&gt;setCoords(30, 30);
phaseTracerArrow-&gt;setHead(QCPLineEnding::esSpikeArrow);
phaseTracerArrow-&gt;setTail(QCPLineEnding(QCPLineEnding::esBar, (phaseTracerText-&gt;bottom-&gt;pixelPosition().y()-phaseTracerText-&gt;top-&gt;pixelPosition().y())*0.85));
 
// add the group velocity tracer (green circle):
QCPItemTracer *groupTracer = new QCPItemTracer(customPlot);
groupTracer-&gt;setGraph(graph);
groupTracer-&gt;setGraphKey(5.5);
groupTracer-&gt;setInterpolating(true);
groupTracer-&gt;setStyle(QCPItemTracer::tsCircle);
groupTracer-&gt;setPen(QPen(Qt::green));
groupTracer-&gt;setBrush(Qt::green);
groupTracer-&gt;setSize(7);
 
// add label for group tracer:
QCPItemText *groupTracerText = new QCPItemText(customPlot);
groupTracerText-&gt;position-&gt;setType(QCPItemPosition::ptAxisRectRatio);
groupTracerText-&gt;setPositionAlignment(Qt::AlignRight|Qt::AlignTop);
groupTracerText-&gt;position-&gt;setCoords(1.0, 0.20); // lower right corner of axis rect
groupTracerText-&gt;setText("Fixed positions in\nwave packet define\ngroup velocity vg");
groupTracerText-&gt;setTextAlignment(Qt::AlignLeft);
groupTracerText-&gt;setFont(QFont(font().family(), 9));
groupTracerText-&gt;setPadding(QMargins(8, 0, 0, 0));
 
// add arrow pointing at group tracer, coming from label:
QCPItemCurve *groupTracerArrow = new QCPItemCurve(customPlot);
groupTracerArrow-&gt;start-&gt;setParentAnchor(groupTracerText-&gt;left);
groupTracerArrow-&gt;startDir-&gt;setParentAnchor(groupTracerArrow-&gt;start);
groupTracerArrow-&gt;startDir-&gt;setCoords(-40, 0); // direction 30 pixels to the left of parent anchor (tracerArrow-&gt;start)
groupTracerArrow-&gt;end-&gt;setCoords(5.5, 0.4);
groupTracerArrow-&gt;endDir-&gt;setParentAnchor(groupTracerArrow-&gt;end);
groupTracerArrow-&gt;endDir-&gt;setCoords(0, -40);
groupTracerArrow-&gt;setHead(QCPLineEnding::esSpikeArrow);
groupTracerArrow-&gt;setTail(QCPLineEnding(QCPLineEnding::esBar, (groupTracerText-&gt;bottom-&gt;pixelPosition().y()-groupTracerText-&gt;top-&gt;pixelPosition().y())*0.85));
 
// add dispersion arrow:
QCPItemCurve *arrow = new QCPItemCurve(customPlot);
arrow-&gt;start-&gt;setCoords(1, -1.1);
arrow-&gt;startDir-&gt;setCoords(-1, -1.3);
arrow-&gt;endDir-&gt;setCoords(-5, -0.3);
arrow-&gt;end-&gt;setCoords(-10, -0.2);
arrow-&gt;setHead(QCPLineEnding::esSpikeArrow);
 
// add the dispersion arrow label:
QCPItemText *dispersionText = new QCPItemText(customPlot);
dispersionText-&gt;position-&gt;setCoords(-6, -0.9);
dispersionText-&gt;setRotation(40);
dispersionText-&gt;setText("Dispersion with\nvp &lt; vg");
dispersionText-&gt;setFont(QFont(font().family(), 10));
 
// setup a timer that repeatedly calls MainWindow::bracketDataSlot:
connect(&amp;dataTimer, SIGNAL(timeout()), this, SLOT(bracketDataSlot()));
dataTimer.start(0); // Interval 0 means to refresh as fast as possible
bracketDataSlot, called by timer:



double secs = QCPAxisTickerDateTime::dateTimeToKey(QDateTime::currentDateTime());
 
// update data to make phase move:
int n = 500;
double phase = secs*5;
double k = 3;
QVector&lt;double&gt; x(n), y(n);
for (int i=0; i&lt;n; ++i)
{
  x[i] = i/(double)(n-1)*34 - 17;
  y[i] = qExp(-x[i]*x[i]/20.0)*qSin(k*x[i]+phase);
}
ui-&gt;customPlot-&gt;graph()-&gt;setData(x, y);
 
itemDemoPhaseTracer-&gt;setGraphKey((8*M_PI+fmod(M_PI*1.5-phase, 6*M_PI))/k);
 
ui-&gt;customPlot-&gt;replot();
 
// calculate frames per second:
double key = secs;
static double lastFpsKey;
static int frameCount;
++frameCount;
if (key-lastFpsKey &gt; 2) // average fps over 2 seconds
{
  ui-&gt;statusBar-&gt;showMessage(
        QString("%1 FPS, Total Data points: %2")
        .arg(frameCount/(key-lastFpsKey), 0, 'f', 0)
        .arg(ui-&gt;customPlot-&gt;graph(0)-&gt;data()-&gt;size())
        , 0);
  lastFpsKey = key;
  frameCount = 0;
}</code></pre> 
<blockquote> 
 <p> eg17:</p> 
</blockquote> 
<p> <img alt="" height="431" src="https://images2.imgbox.com/29/09/5YO4oFg5_o.jpg" width="558"></p> 
<p> </p> 
<pre><code class="language-cpp">// configure axis rect:
customPlot-&gt;plotLayout()-&gt;clear(); // clear default axis rect so we can start from scratch
QCPAxisRect *wideAxisRect = new QCPAxisRect(customPlot);
wideAxisRect-&gt;setupFullAxesBox(true);
wideAxisRect-&gt;axis(QCPAxis::atRight, 0)-&gt;setTickLabels(true);
wideAxisRect-&gt;addAxis(QCPAxis::atLeft)-&gt;setTickLabelColor(QColor("#6050F8")); // add an extra axis on the left and color its numbers
QCPLayoutGrid *subLayout = new QCPLayoutGrid;
customPlot-&gt;plotLayout()-&gt;addElement(0, 0, wideAxisRect); // insert axis rect in first row
customPlot-&gt;plotLayout()-&gt;addElement(1, 0, subLayout); // sub layout in second row (grid layout will grow accordingly)
//customPlot-&gt;plotLayout()-&gt;setRowStretchFactor(1, 2);
// prepare axis rects that will be placed in the sublayout:
QCPAxisRect *subRectLeft = new QCPAxisRect(customPlot, false); // false means to not setup default axes
QCPAxisRect *subRectRight = new QCPAxisRect(customPlot, false);
subLayout-&gt;addElement(0, 0, subRectLeft);
subLayout-&gt;addElement(0, 1, subRectRight);
subRectRight-&gt;setMaximumSize(150, 150); // make bottom right axis rect size fixed 150x150
subRectRight-&gt;setMinimumSize(150, 150); // make bottom right axis rect size fixed 150x150
// setup axes in sub layout axis rects:
subRectLeft-&gt;addAxes(QCPAxis::atBottom | QCPAxis::atLeft);
subRectRight-&gt;addAxes(QCPAxis::atBottom | QCPAxis::atRight);
subRectLeft-&gt;axis(QCPAxis::atLeft)-&gt;ticker()-&gt;setTickCount(2);
subRectRight-&gt;axis(QCPAxis::atRight)-&gt;ticker()-&gt;setTickCount(2);
subRectRight-&gt;axis(QCPAxis::atBottom)-&gt;ticker()-&gt;setTickCount(2);
subRectLeft-&gt;axis(QCPAxis::atBottom)-&gt;grid()-&gt;setVisible(true);
// synchronize the left and right margins of the top and bottom axis rects:
QCPMarginGroup *marginGroup = new QCPMarginGroup(customPlot);
subRectLeft-&gt;setMarginGroup(QCP::msLeft, marginGroup);
subRectRight-&gt;setMarginGroup(QCP::msRight, marginGroup);
wideAxisRect-&gt;setMarginGroup(QCP::msLeft | QCP::msRight, marginGroup);
// move newly created axes on "axes" layer and grids on "grid" layer:
foreach (QCPAxisRect *rect, customPlot-&gt;axisRects())
{
  foreach (QCPAxis *axis, rect-&gt;axes())
  {
    axis-&gt;setLayer("axes");
    axis-&gt;grid()-&gt;setLayer("grid");
  }
}
 
// prepare data:
QVector&lt;QCPGraphData&gt; dataCos(21), dataGauss(50), dataRandom(100);
QVector&lt;double&gt; x3, y3;
qsrand(3);
for (int i=0; i&lt;dataCos.size(); ++i)
{
  dataCos[i].key = i/(double)(dataCos.size()-1)*10-5.0;
  dataCos[i].value = qCos(dataCos[i].key);
}
for (int i=0; i&lt;dataGauss.size(); ++i)
{
  dataGauss[i].key = i/(double)dataGauss.size()*10-5.0;
  dataGauss[i].value = qExp(-dataGauss[i].key*dataGauss[i].key*0.2)*1000;
}
for (int i=0; i&lt;dataRandom.size(); ++i)
{
  dataRandom[i].key = i/(double)dataRandom.size()*10;
  dataRandom[i].value = qrand()/(double)RAND_MAX-0.5+dataRandom[qMax(0, i-1)].value;
}
x3 &lt;&lt; 1 &lt;&lt; 2 &lt;&lt; 3 &lt;&lt; 4;
y3 &lt;&lt; 2 &lt;&lt; 2.5 &lt;&lt; 4 &lt;&lt; 1.5;
 
// create and configure plottables:
QCPGraph *mainGraphCos = customPlot-&gt;addGraph(wideAxisRect-&gt;axis(QCPAxis::atBottom), wideAxisRect-&gt;axis(QCPAxis::atLeft));
mainGraphCos-&gt;data()-&gt;set(dataCos);
mainGraphCos-&gt;valueAxis()-&gt;setRange(-1, 1);
mainGraphCos-&gt;rescaleKeyAxis();
mainGraphCos-&gt;setScatterStyle(QCPScatterStyle(QCPScatterStyle::ssCircle, QPen(Qt::black), QBrush(Qt::white), 6));
mainGraphCos-&gt;setPen(QPen(QColor(120, 120, 120), 2));
QCPGraph *mainGraphGauss = customPlot-&gt;addGraph(wideAxisRect-&gt;axis(QCPAxis::atBottom), wideAxisRect-&gt;axis(QCPAxis::atLeft, 1));
mainGraphGauss-&gt;data()-&gt;set(dataGauss);
mainGraphGauss-&gt;setPen(QPen(QColor("#8070B8"), 2));
mainGraphGauss-&gt;setBrush(QColor(110, 170, 110, 30));
mainGraphCos-&gt;setChannelFillGraph(mainGraphGauss);
mainGraphCos-&gt;setBrush(QColor(255, 161, 0, 50));
mainGraphGauss-&gt;valueAxis()-&gt;setRange(0, 1000);
mainGraphGauss-&gt;rescaleKeyAxis();
 
QCPGraph *subGraphRandom = customPlot-&gt;addGraph(subRectLeft-&gt;axis(QCPAxis::atBottom), subRectLeft-&gt;axis(QCPAxis::atLeft));
subGraphRandom-&gt;data()-&gt;set(dataRandom);
subGraphRandom-&gt;setLineStyle(QCPGraph::lsImpulse);
subGraphRandom-&gt;setPen(QPen(QColor("#FFA100"), 1.5));
subGraphRandom-&gt;rescaleAxes();
 
QCPBars *subBars = new QCPBars(subRectRight-&gt;axis(QCPAxis::atBottom), subRectRight-&gt;axis(QCPAxis::atRight));
subBars-&gt;setWidth(3/(double)x3.size());
subBars-&gt;setData(x3, y3);
subBars-&gt;setPen(QPen(Qt::black));
subBars-&gt;setAntialiased(false);
subBars-&gt;setAntialiasedFill(false);
subBars-&gt;setBrush(QColor("#705BE8"));
subBars-&gt;keyAxis()-&gt;setSubTicks(false);
subBars-&gt;rescaleAxes();
// setup a ticker for subBars key axis that only gives integer ticks:
QSharedPointer&lt;QCPAxisTickerFixed&gt; intTicker(new QCPAxisTickerFixed);
intTicker-&gt;setTickStep(1.0);
intTicker-&gt;setScaleStrategy(QCPAxisTickerFixed::ssMultiples);
subBars-&gt;keyAxis()-&gt;setTicker(intTicker);</code></pre> 
<blockquote> 
 <p> eg18:</p> 
</blockquote> 
<p> <img alt="" height="431" src="https://images2.imgbox.com/a8/bb/rI9IUEY7_o.jpg" width="558"></p> 
<p> </p> 
<pre><code class="language-cpp">customPlot-&gt;legend-&gt;setVisible(true);
 
// generate two sets of random walk data (one for candlestick and one for ohlc chart):
int n = 500;
QVector&lt;double&gt; time(n), value1(n), value2(n);
QDateTime start = QDateTime(QDate(2014, 6, 11));
start.setTimeSpec(Qt::UTC);
double startTime = start.toTime_t();
double binSize = 3600*24; // bin data in 1 day intervals
time[0] = startTime;
value1[0] = 60;
value2[0] = 20;
qsrand(9);
for (int i=1; i&lt;n; ++i)
{
  time[i] = startTime + 3600*i;
  value1[i] = value1[i-1] + (qrand()/(double)RAND_MAX-0.5)*10;
  value2[i] = value2[i-1] + (qrand()/(double)RAND_MAX-0.5)*3;
}
 
// create candlestick chart:
QCPFinancial *candlesticks = new QCPFinancial(customPlot-&gt;xAxis, customPlot-&gt;yAxis);
candlesticks-&gt;setName("Candlestick");
candlesticks-&gt;setChartStyle(QCPFinancial::csCandlestick);
candlesticks-&gt;data()-&gt;set(QCPFinancial::timeSeriesToOhlc(time, value1, binSize, startTime));
candlesticks-&gt;setWidth(binSize*0.9);
candlesticks-&gt;setTwoColored(true);
candlesticks-&gt;setBrushPositive(QColor(245, 245, 245));
candlesticks-&gt;setBrushNegative(QColor(40, 40, 40));
candlesticks-&gt;setPenPositive(QPen(QColor(0, 0, 0)));
candlesticks-&gt;setPenNegative(QPen(QColor(0, 0, 0)));
 
// create ohlc chart:
QCPFinancial *ohlc = new QCPFinancial(customPlot-&gt;xAxis, customPlot-&gt;yAxis);
ohlc-&gt;setName("OHLC");
ohlc-&gt;setChartStyle(QCPFinancial::csOhlc);
ohlc-&gt;data()-&gt;set(QCPFinancial::timeSeriesToOhlc(time, value2, binSize/3.0, startTime)); // divide binSize by 3 just to make the ohlc bars a bit denser
ohlc-&gt;setWidth(binSize*0.2);
ohlc-&gt;setTwoColored(true);
 
// create bottom axis rect for volume bar chart:
QCPAxisRect *volumeAxisRect = new QCPAxisRect(customPlot);
customPlot-&gt;plotLayout()-&gt;addElement(1, 0, volumeAxisRect);
volumeAxisRect-&gt;setMaximumSize(QSize(QWIDGETSIZE_MAX, 100));
volumeAxisRect-&gt;axis(QCPAxis::atBottom)-&gt;setLayer("axes");
volumeAxisRect-&gt;axis(QCPAxis::atBottom)-&gt;grid()-&gt;setLayer("grid");
// bring bottom and main axis rect closer together:
customPlot-&gt;plotLayout()-&gt;setRowSpacing(0);
volumeAxisRect-&gt;setAutoMargins(QCP::msLeft|QCP::msRight|QCP::msBottom);
volumeAxisRect-&gt;setMargins(QMargins(0, 0, 0, 0));
// create two bar plottables, for positive (green) and negative (red) volume bars:
customPlot-&gt;setAutoAddPlottableToLegend(false);
QCPBars *volumePos = new QCPBars(volumeAxisRect-&gt;axis(QCPAxis::atBottom), volumeAxisRect-&gt;axis(QCPAxis::atLeft));
QCPBars *volumeNeg = new QCPBars(volumeAxisRect-&gt;axis(QCPAxis::atBottom), volumeAxisRect-&gt;axis(QCPAxis::atLeft));
for (int i=0; i&lt;n/5; ++i)
{
  int v = qrand()%20000+qrand()%20000+qrand()%20000-10000*3;
  (v &lt; 0 ? volumeNeg : volumePos)-&gt;addData(startTime+3600*5.0*i, qAbs(v)); // add data to either volumeNeg or volumePos, depending on sign of v
}
volumePos-&gt;setWidth(3600*4);
volumePos-&gt;setPen(Qt::NoPen);
volumePos-&gt;setBrush(QColor(100, 180, 110));
volumeNeg-&gt;setWidth(3600*4);
volumeNeg-&gt;setPen(Qt::NoPen);
volumeNeg-&gt;setBrush(QColor(180, 90, 90));
 
// interconnect x axis ranges of main and bottom axis rects:
connect(customPlot-&gt;xAxis, SIGNAL(rangeChanged(QCPRange)), volumeAxisRect-&gt;axis(QCPAxis::atBottom), SLOT(setRange(QCPRange)));
connect(volumeAxisRect-&gt;axis(QCPAxis::atBottom), SIGNAL(rangeChanged(QCPRange)), customPlot-&gt;xAxis, SLOT(setRange(QCPRange)));
// configure axes of both main and bottom axis rect:
QSharedPointer&lt;QCPAxisTickerDateTime&gt; dateTimeTicker(new QCPAxisTickerDateTime);
dateTimeTicker-&gt;setDateTimeSpec(Qt::UTC);
dateTimeTicker-&gt;setDateTimeFormat("dd. MMMM");
volumeAxisRect-&gt;axis(QCPAxis::atBottom)-&gt;setTicker(dateTimeTicker);
volumeAxisRect-&gt;axis(QCPAxis::atBottom)-&gt;setTickLabelRotation(15);
customPlot-&gt;xAxis-&gt;setBasePen(Qt::NoPen);
customPlot-&gt;xAxis-&gt;setTickLabels(false);
customPlot-&gt;xAxis-&gt;setTicks(false); // only want vertical grid in main axis rect, so hide xAxis backbone, ticks, and labels
customPlot-&gt;xAxis-&gt;setTicker(dateTimeTicker);
customPlot-&gt;rescaleAxes();
customPlot-&gt;xAxis-&gt;scaleRange(1.025, customPlot-&gt;xAxis-&gt;range().center());
customPlot-&gt;yAxis-&gt;scaleRange(1.1, customPlot-&gt;yAxis-&gt;range().center());
 
// make axis rects' left side line up:
QCPMarginGroup *group = new QCPMarginGroup(customPlot);
customPlot-&gt;axisRect()-&gt;setMarginGroup(QCP::msLeft|QCP::msRight, group);
volumeAxisRect-&gt;setMarginGroup(QCP::msLeft|QCP::msRight, group);</code></pre>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/6a55f1cda5bfdb96849c4a45e8ea4132/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">2.基于正点原子STM32F103的定时器中断实验（HAL库实现）（cubeMX）</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/d969b163174109a6565633ba7a22dab6/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">解决：PicGo插件安装失败，失败码为1（404）</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>