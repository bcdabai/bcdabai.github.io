<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>（图解）循环队列的三种判断队空、队满操作（附带源码和插入删除操作等一些基本操作） - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="（图解）循环队列的三种判断队空、队满操作（附带源码和插入删除操作等一些基本操作）" />
<meta property="og:description" content="目录
一、普通的顺序存储队列
二、循环队列
（1）少用一个元素空间
i、初始化队列操作：
iii、入队操作：
iv、出队操作：
（2）设置flag标志
i、初始化队列操作：
ii、判断队空操作：
iii、入队操作：
iv、出队操作：
（3）设置length存储队列元素的个数
i、初始化队列操作：
ii、判断队空操作：
iii、入队操作：
iv、出队操作：
（4） 总结
三、循环队列测试程序
（1）少用一个元素空间
（2）设置flag标志
（3）设置length存储队列元素的个数
四、拓展
（1）思路
（2）修改代码
队空和队满条件没有改变。
i、初始化操作：
ii、判断队列为空操作：
iii、入队操作：
iv、出队操作：
（3）测试程序
一、普通的顺序存储队列 在介绍循环队列三种判断队空、队满操作之前，先解释下为啥会用循环队列。
队列：一种先进先出（First In First Out）的线性表，简称FIFO。允许插入的一段称为队尾，允许删除的一段称为队头。
咱们看一下普通的顺序存储队列：
普通的顺序储存队列的存储结构为：
#define MAXSIZE 5 typedef int DataType; typedef struct Queue { DataType data[MAXSIZE]; // 存储队列的数据空间 int front; // 队头指针 int rear; // 队尾指针 }SeqQueue; 如图所示：
front、rear分别指向队头，也就是数组索引为0的地方，此时队列为空（即rear == front）， 现在将0、1、2、3、4依次入队（队尾指针rear一直向后移，队头指针front不动）。
如图所示：" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/879b682d55d91741659f4a4c107b3ca1/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-01-23T12:07:37+08:00" />
<meta property="article:modified_time" content="2023-01-23T12:07:37+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">（图解）循环队列的三种判断队空、队满操作（附带源码和插入删除操作等一些基本操作）</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p id="main-toc"><strong>目录</strong></p> 
<p> </p> 
<p id="%E4%B8%80%E3%80%81%E6%99%AE%E9%80%9A%E7%9A%84%E9%A1%BA%E5%BA%8F%E5%AD%98%E5%82%A8%E9%98%9F%E5%88%97-toc" style="margin-left:0px;"><a href="#%E4%B8%80%E3%80%81%E6%99%AE%E9%80%9A%E7%9A%84%E9%A1%BA%E5%BA%8F%E5%AD%98%E5%82%A8%E9%98%9F%E5%88%97" rel="nofollow">一、普通的顺序存储队列</a></p> 
<p id="%E4%BA%8C%E3%80%81%E5%BE%AA%E7%8E%AF%E9%98%9F%E5%88%97-toc" style="margin-left:0px;"><a href="#%E4%BA%8C%E3%80%81%E5%BE%AA%E7%8E%AF%E9%98%9F%E5%88%97" rel="nofollow">二、循环队列</a></p> 
<p id="%EF%BC%881%EF%BC%89%E5%B0%91%E7%94%A8%E4%B8%80%E4%B8%AA%E5%85%83%E7%B4%A0%E7%A9%BA%E9%97%B4-toc" style="margin-left:40px;"><a href="#%EF%BC%881%EF%BC%89%E5%B0%91%E7%94%A8%E4%B8%80%E4%B8%AA%E5%85%83%E7%B4%A0%E7%A9%BA%E9%97%B4" rel="nofollow">（1）少用一个元素空间</a></p> 
<p id="i%E3%80%81%E5%88%9D%E5%A7%8B%E5%8C%96%E9%98%9F%E5%88%97%E6%93%8D%E4%BD%9C%EF%BC%9A-toc" style="margin-left:80px;"><a href="#i%E3%80%81%E5%88%9D%E5%A7%8B%E5%8C%96%E9%98%9F%E5%88%97%E6%93%8D%E4%BD%9C%EF%BC%9A" rel="nofollow">i、初始化队列操作：</a></p> 
<p id="iii%E3%80%81%E5%85%A5%E9%98%9F%E6%93%8D%E4%BD%9C%EF%BC%9A-toc" style="margin-left:80px;"><a href="#iii%E3%80%81%E5%85%A5%E9%98%9F%E6%93%8D%E4%BD%9C%EF%BC%9A" rel="nofollow">iii、入队操作：</a></p> 
<p id="iv%E3%80%81%E5%87%BA%E9%98%9F%E6%93%8D%E4%BD%9C%EF%BC%9A-toc" style="margin-left:80px;"><a href="#iv%E3%80%81%E5%87%BA%E9%98%9F%E6%93%8D%E4%BD%9C%EF%BC%9A" rel="nofollow">iv、出队操作：</a></p> 
<p id="%EF%BC%882%EF%BC%89%E8%AE%BE%E7%BD%AEflag%E6%A0%87%E5%BF%97-toc" style="margin-left:40px;"><a href="#%EF%BC%882%EF%BC%89%E8%AE%BE%E7%BD%AEflag%E6%A0%87%E5%BF%97" rel="nofollow">（2）设置flag标志</a></p> 
<p id="i%E3%80%81%E5%88%9D%E5%A7%8B%E5%8C%96%E9%98%9F%E5%88%97%E6%93%8D%E4%BD%9C%EF%BC%9A-toc" style="margin-left:80px;"><a href="#i%E3%80%81%E5%88%9D%E5%A7%8B%E5%8C%96%E9%98%9F%E5%88%97%E6%93%8D%E4%BD%9C%EF%BC%9A" rel="nofollow">i、初始化队列操作：</a></p> 
<p id="ii%E3%80%81%E5%88%A4%E6%96%AD%E9%98%9F%E7%A9%BA%E6%93%8D%E4%BD%9C%EF%BC%9A-toc" style="margin-left:80px;"><a href="#ii%E3%80%81%E5%88%A4%E6%96%AD%E9%98%9F%E7%A9%BA%E6%93%8D%E4%BD%9C%EF%BC%9A" rel="nofollow">ii、判断队空操作：</a></p> 
<p id="iii%E3%80%81%E5%85%A5%E9%98%9F%E6%93%8D%E4%BD%9C%EF%BC%9A-toc" style="margin-left:80px;"><a href="#iii%E3%80%81%E5%85%A5%E9%98%9F%E6%93%8D%E4%BD%9C%EF%BC%9A" rel="nofollow">iii、入队操作：</a></p> 
<p id="iv%E3%80%81%E5%87%BA%E9%98%9F%E6%93%8D%E4%BD%9C%EF%BC%9A-toc" style="margin-left:80px;"><a href="#iv%E3%80%81%E5%87%BA%E9%98%9F%E6%93%8D%E4%BD%9C%EF%BC%9A" rel="nofollow">iv、出队操作：</a></p> 
<p id="%EF%BC%883%EF%BC%89%E8%AE%BE%E7%BD%AElength%E5%AD%98%E5%82%A8%E9%98%9F%E5%88%97%E5%85%83%E7%B4%A0%E7%9A%84%E4%B8%AA%E6%95%B0-toc" style="margin-left:40px;"><a href="#%EF%BC%883%EF%BC%89%E8%AE%BE%E7%BD%AElength%E5%AD%98%E5%82%A8%E9%98%9F%E5%88%97%E5%85%83%E7%B4%A0%E7%9A%84%E4%B8%AA%E6%95%B0" rel="nofollow">（3）设置length存储队列元素的个数</a></p> 
<p id="i%E3%80%81%E5%88%9D%E5%A7%8B%E5%8C%96%E9%98%9F%E5%88%97%E6%93%8D%E4%BD%9C%EF%BC%9A-toc" style="margin-left:80px;"><a href="#i%E3%80%81%E5%88%9D%E5%A7%8B%E5%8C%96%E9%98%9F%E5%88%97%E6%93%8D%E4%BD%9C%EF%BC%9A" rel="nofollow">i、初始化队列操作：</a></p> 
<p id="ii%E3%80%81%E5%88%A4%E6%96%AD%E9%98%9F%E7%A9%BA%E6%93%8D%E4%BD%9C%EF%BC%9A-toc" style="margin-left:80px;"><a href="#ii%E3%80%81%E5%88%A4%E6%96%AD%E9%98%9F%E7%A9%BA%E6%93%8D%E4%BD%9C%EF%BC%9A" rel="nofollow">ii、判断队空操作：</a></p> 
<p id="iii%E3%80%81%E5%85%A5%E9%98%9F%E6%93%8D%E4%BD%9C%EF%BC%9A-toc" style="margin-left:80px;"><a href="#iii%E3%80%81%E5%85%A5%E9%98%9F%E6%93%8D%E4%BD%9C%EF%BC%9A" rel="nofollow">iii、入队操作：</a></p> 
<p id="iv%E3%80%81%E5%87%BA%E9%98%9F%E6%93%8D%E4%BD%9C%EF%BC%9A-toc" style="margin-left:80px;"><a href="#iv%E3%80%81%E5%87%BA%E9%98%9F%E6%93%8D%E4%BD%9C%EF%BC%9A" rel="nofollow">iv、出队操作：</a></p> 
<p id="%C2%A0%EF%BC%884%EF%BC%89%C2%A0%E6%80%BB%E7%BB%93-toc" style="margin-left:40px;"><a href="#%C2%A0%EF%BC%884%EF%BC%89%C2%A0%E6%80%BB%E7%BB%93" rel="nofollow"> （4） 总结</a></p> 
<p id="%E4%B8%89%E3%80%81%E5%BE%AA%E7%8E%AF%E9%98%9F%E5%88%97%E6%B5%8B%E8%AF%95%E7%A8%8B%E5%BA%8F-toc" style="margin-left:0px;"><a href="#%E4%B8%89%E3%80%81%E5%BE%AA%E7%8E%AF%E9%98%9F%E5%88%97%E6%B5%8B%E8%AF%95%E7%A8%8B%E5%BA%8F" rel="nofollow">三、循环队列测试程序</a></p> 
<p id="%EF%BC%881%EF%BC%89%E5%B0%91%E7%94%A8%E4%B8%80%E4%B8%AA%E5%85%83%E7%B4%A0%E7%A9%BA%E9%97%B4-toc" style="margin-left:40px;"><a href="#%EF%BC%881%EF%BC%89%E5%B0%91%E7%94%A8%E4%B8%80%E4%B8%AA%E5%85%83%E7%B4%A0%E7%A9%BA%E9%97%B4" rel="nofollow">（1）少用一个元素空间</a></p> 
<p id="%EF%BC%882%EF%BC%89%E8%AE%BE%E7%BD%AEflag%E6%A0%87%E5%BF%97-toc" style="margin-left:40px;"><a href="#%EF%BC%882%EF%BC%89%E8%AE%BE%E7%BD%AEflag%E6%A0%87%E5%BF%97" rel="nofollow">（2）设置flag标志</a></p> 
<p id="%EF%BC%883%EF%BC%89%E8%AE%BE%E7%BD%AElength%E5%AD%98%E5%82%A8%E9%98%9F%E5%88%97%E5%85%83%E7%B4%A0%E7%9A%84%E4%B8%AA%E6%95%B0-toc" style="margin-left:40px;"><a href="#%EF%BC%883%EF%BC%89%E8%AE%BE%E7%BD%AElength%E5%AD%98%E5%82%A8%E9%98%9F%E5%88%97%E5%85%83%E7%B4%A0%E7%9A%84%E4%B8%AA%E6%95%B0" rel="nofollow">（3）设置length存储队列元素的个数</a></p> 
<p id="%E5%9B%9B%E3%80%81%E6%8B%93%E5%B1%95-toc" style="margin-left:0px;"><a href="#%E5%9B%9B%E3%80%81%E6%8B%93%E5%B1%95" rel="nofollow">四、拓展</a></p> 
<p id="%EF%BC%881%EF%BC%89%E6%80%9D%E8%B7%AF-toc" style="margin-left:40px;"><a href="#%EF%BC%881%EF%BC%89%E6%80%9D%E8%B7%AF" rel="nofollow">（1）思路</a></p> 
<p id="%EF%BC%882%EF%BC%89%E4%BF%AE%E6%94%B9%E4%BB%A3%E7%A0%81-toc" style="margin-left:40px;"><a href="#%EF%BC%882%EF%BC%89%E4%BF%AE%E6%94%B9%E4%BB%A3%E7%A0%81" rel="nofollow">（2）修改代码</a></p> 
<p id="%E9%98%9F%E7%A9%BA%E5%92%8C%E9%98%9F%E6%BB%A1%E6%9D%A1%E4%BB%B6%E6%B2%A1%E6%9C%89%E6%94%B9%E5%8F%98%E3%80%82-toc" style="margin-left:80px;"><a href="#%E9%98%9F%E7%A9%BA%E5%92%8C%E9%98%9F%E6%BB%A1%E6%9D%A1%E4%BB%B6%E6%B2%A1%E6%9C%89%E6%94%B9%E5%8F%98%E3%80%82" rel="nofollow">队空和队满条件没有改变。</a></p> 
<p id="%C2%A0i%E3%80%81%E5%88%9D%E5%A7%8B%E5%8C%96%E6%93%8D%E4%BD%9C%EF%BC%9A-toc" style="margin-left:80px;"><a href="#%C2%A0i%E3%80%81%E5%88%9D%E5%A7%8B%E5%8C%96%E6%93%8D%E4%BD%9C%EF%BC%9A" rel="nofollow"> i、初始化操作：</a></p> 
<p id="ii%E3%80%81%E5%88%A4%E6%96%AD%E9%98%9F%E5%88%97%E4%B8%BA%E7%A9%BA%E6%93%8D%E4%BD%9C%EF%BC%9A-toc" style="margin-left:80px;"><a href="#ii%E3%80%81%E5%88%A4%E6%96%AD%E9%98%9F%E5%88%97%E4%B8%BA%E7%A9%BA%E6%93%8D%E4%BD%9C%EF%BC%9A" rel="nofollow">ii、判断队列为空操作：</a></p> 
<p id="iii%E3%80%81%E5%85%A5%E9%98%9F%E6%93%8D%E4%BD%9C%EF%BC%9A-toc" style="margin-left:80px;"><a href="#iii%E3%80%81%E5%85%A5%E9%98%9F%E6%93%8D%E4%BD%9C%EF%BC%9A" rel="nofollow">iii、入队操作：</a></p> 
<p id="iv%E3%80%81%E5%87%BA%E9%98%9F%E6%93%8D%E4%BD%9C%EF%BC%9A-toc" style="margin-left:80px;"><a href="#iv%E3%80%81%E5%87%BA%E9%98%9F%E6%93%8D%E4%BD%9C%EF%BC%9A" rel="nofollow">iv、出队操作：</a></p> 
<p id="%EF%BC%883%EF%BC%89%E6%B5%8B%E8%AF%95%E7%A8%8B%E5%BA%8F-toc" style="margin-left:40px;"><a href="#%EF%BC%883%EF%BC%89%E6%B5%8B%E8%AF%95%E7%A8%8B%E5%BA%8F" rel="nofollow">（3）测试程序</a></p> 
<hr id="hr-toc"> 
<h2><strong>一、普通的顺序存储队列</strong></h2> 
<p>在介绍循环队列三种判断队空、队满操作之前，先解释下为啥会用循环队列。</p> 
<p><strong>队列</strong>：<span style="color:#ff9900;">一种先进先出（First In First Out）的线性表，简称FIFO。允许插入的一段称为队尾，允许删除的一段称为队头</span>。</p> 
<p>咱们看一下普通的顺序存储队列：</p> 
<p>普通的顺序储存队列的存储结构为：</p> 
<pre><code class="language-objectivec">#define MAXSIZE 5

typedef int DataType;

typedef struct Queue
{
    DataType data[MAXSIZE];  // 存储队列的数据空间
    int front;   // 队头指针
    int rear;    // 队尾指针   
}SeqQueue;    
</code></pre> 
<p><strong>如图所示：</strong></p> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/bb/7b/GYQFhsbh_o.jpg"></p> 
<p>         front、rear分别指向队头，也就是数组索引为0的地方，此时队列为空（即rear == front）， </p> 
<p>现在将<strong>0、1、2、3、4依次入队（队尾指针rear一直向后移，队头指针front不动）。</strong></p> 
<p><strong>如图所示：</strong></p> 
<p><img alt="" src="https://images2.imgbox.com/ef/56/82IFy5x2_o.jpg"></p> 
<p><strong>         0、1、2、3、4入队后</strong>，rear指向数组的后面，此时<strong>队满（即rear == MAXSIZE）</strong>，然后再将<strong>0、1、2、3、4出队</strong>，出队后变为 队尾指针和队头指针都指向数组后面（即 rear == front），但如果现在 5 想入队却又入不了，应为 rear的值已经超过数组的最大索引，像这种数组有位置但却无法插入的这种现象叫做“假溢出”。</p> 
<p><strong>如图所示：</strong></p> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/36/19/S4JMKSoQ_o.jpg"></p> 
<p>         但如果咱们想rear在数组索引为0处就好。有这个想法的同学很不错，这就引出了<strong>循环队列</strong>。</p> 
<h2 id="%E4%BA%8C%E3%80%81%E5%BE%AA%E7%8E%AF%E9%98%9F%E5%88%97">二、循环队列</h2> 
<p>        像上面想的那样，咱们只要把队尾和队头连，那个rear不就指向数组索引为0的地方，这就是循环队列。而怎样实现呢？只需将 <strong>入队后的rear</strong> 和 <strong>出队后的front</strong> 同 MAXSIZE取余即可。例如上面的队满时，rear = 5，对MAXSIZE取余后，即 rear = rear % MAXSIZE = 0；符合我们的想法。</p> 
<pre><code class="language-objectivec">rear = (rear + 1) % MAXSIZE; // 入队后取余
front = (front + 1) % MAXSIZE; // 出队后取余</code></pre> 
<p><strong>循环队列</strong>：队列头尾相接的顺序存储结构就是循环队列。</p> 
<p><strong>如图所示</strong>：</p> 
<p style="text-align:center;"><img alt="" height="413" src="https://images2.imgbox.com/f3/ef/L9fGnWI1_o.jpg" width="619"></p> 
<p> 此时循环队列为空（rear == front）。然后将<strong>0、1、2、3、4入队，</strong>此时的rear会指向数组索引为0的地方，不会像上面普通队列那样指到数组外。</p> 
<p style="text-align:center;"><img alt="" height="476" src="https://images2.imgbox.com/7f/e5/dj3G6wY4_o.jpg" width="659"></p> 
<p> 然后将<strong>0、1出队</strong>，rear指针不动，front指向2处。</p> 
<p style="text-align:center;"><img alt="" height="461" src="https://images2.imgbox.com/be/73/wdP1STuy_o.jpg" width="631"></p> 
<p> 此时 5 入队，如果是普通队列的话，此时入队便失败（由于rear指向了数组外），但循环队列不会，此时rear指向 0 处，而之前 0 处的项已经出队，故可入队。</p> 
<p style="text-align:center;"><img alt="" height="437" src="https://images2.imgbox.com/e1/c1/RvwqCU38_o.jpg" width="611"></p> 
<p>        此时衍生一个问题，就是咱们之前队满时，有rear == front，但之前队空时 ，也有rear == front。那当 rear == front 时，是队空还是队满呢？这是不是很有歧义，所以咱们就要来解决这个问题。（即<strong>使判断队空和队满的条件不同，消除歧义</strong>）。</p> 
<p><span style="background-color:#fbd4d0;">解决这个问题的三种方法：</span></p> 
<ol><li>少用一个元素的空间；</li><li>设置一个flag，来区别队列的 “空” 和 “满” ；</li><li>设置一个变量。统计队列中的元素数量。</li></ol> 
<h3 id="%EF%BC%881%EF%BC%89%E5%B0%91%E7%94%A8%E4%B8%80%E4%B8%AA%E5%85%83%E7%B4%A0%E7%A9%BA%E9%97%B4">（1）少用一个元素空间</h3> 
<p>        当队满时，rear 和 front相差一个元素，此时的 rear 不等于 front，也就区分了队空和队满的条件（即 rear == front 为队空，而非队满）。</p> 
<p style="text-align:center;"><img alt="" height="448" src="https://images2.imgbox.com/15/45/eUTxS276_o.jpg" width="577"></p> 
<p> 此时 (rear + 1) % MAXSIZE == front 为队队满，rear == front 为队空。</p> 
<p><strong>队空的判断条件</strong>：</p> 
<pre><code class="language-objectivec">q-&gt;rear == q-&gt;front</code></pre> 
<p><strong>队满的判断条件</strong>：</p> 
<pre><code class="language-objectivec">(q-&gt;rear + 1) % MAXSIZE == q-&gt;front;</code></pre> 
<p><strong>队列的存储结构：</strong></p> 
<pre><code class="language-objectivec">#define MAXSIZE 5

typedef int DataType;

typedef struct Queue
{
    DataType data[MAXSIZE];  // 存储队列的数据空间
    int front;   // 队头指针
    int rear;    // 队尾指针   
}SeqQueue;    
</code></pre> 
<h4 id="i%E3%80%81%E5%88%9D%E5%A7%8B%E5%8C%96%E9%98%9F%E5%88%97%E6%93%8D%E4%BD%9C%EF%BC%9A">i、初始化队列操作：</h4> 
<p>        利用malloc()函数分配队列的存储结构，再将 front = rear = 0；此时队列为空。</p> 
<pre><code class="language-objectivec">SeqQueue* InitQueue()
{
	SeqQueue* q;
	q = (SeqQueue*)malloc(sizeof(SeqQueue)); // 队列的存储结构
	q-&gt;front = q-&gt;rear = 0; // 初始化rear和front，队列为空
	printf("循环队列已经创建完毕\n");
	return q;
}</code></pre> 
<p><strong>ii、判断队空操作：</strong></p> 
<p>        利用队空判断条件 rear == front；成立队列为空，不成立队列不为空。</p> 
<pre><code class="language-objectivec">bool QueueEmpty(SeqQueue* q)
{
	if (q-&gt;rear == q-&gt;front)  // 判断队空
		return true;
	return false;
}</code></pre> 
<h4 id="iii%E3%80%81%E5%85%A5%E9%98%9F%E6%93%8D%E4%BD%9C%EF%BC%9A"><strong>iii、入队操作：</strong></h4> 
<p><strong>    </strong>    首先利用队满条件判断队列是否为满，队满则退出入队函数，不为满着进行入队操作，并将 rear 利用 rear =（rear+1） % MAXSIZE 进行更新。</p> 
<pre><code class="language-objectivec">bool EnQueue(SeqQueue* q, DataType x)
{
	if ((q-&gt;rear+1) % MAXSIZE == q-&gt;front) // 判断队满
	{
		printf("循环队列已满！\n");
		return false;
	}
	q-&gt;data[q-&gt;rear] = x; // 入队
	q-&gt;rear = (q-&gt;rear + 1) % MAXSIZE; // 更新rear
	return true;
}</code></pre> 
<h4 id="iv%E3%80%81%E5%87%BA%E9%98%9F%E6%93%8D%E4%BD%9C%EF%BC%9A">iv、出队操作：</h4> 
<p>        利用队空条件判断队列是否为空，队列为空不能进行出队操作。队不为空时，进行出队操作，并将front = (front + 1) % MAXSIZE 进行更新。</p> 
<pre><code class="language-objectivec">DataType DeQueue(SeqQueue* q)
{
	DataType x; // 出队元素的值
	if (q-&gt;rear == q-&gt;front)  // 判断队空
	{
		printf("队列为空！不能进行删除操作\n");
		return -1;
	}
	x = q-&gt;data[q-&gt;front]; // 出队
	q-&gt;front = (q-&gt;front + 1) % MAXSIZE; // 更新front
	return x;
}</code></pre> 
<h3 id="%EF%BC%882%EF%BC%89%E8%AE%BE%E7%BD%AEflag%E6%A0%87%E5%BF%97">（2）设置flag标志</h3> 
<p>        当设置flag标志时，就不需要空出一个元素的位置。队满时，flag对应一个值，队空时，flag对应一个与队满时flag的值不同的值（即队空和队满的flag值不一样），所以当 front == rear 时，依靠 flag值就可以区分队空队满。</p> 
<p><strong><span style="background-color:#fbd4d0;">注</span></strong>：flag标志可以自选，符合上面的flag条件即可。（队满和队空的flag值不同）。</p> 
<p><strong>队列的存储结构：</strong></p> 
<pre><code class="language-objectivec">#define MAXSIZE 5

typedef int DataType;

typedef struct Queue{
	DataType data[MAXSIZE];
	int front;
	int rear;
	bool flag;
}SeqQueue;</code></pre> 
<p><strong>当 rear = front 且 flag = flase 时队空. </strong></p> 
<p><img alt="" height="434" src="https://images2.imgbox.com/58/29/vU0ZT3Ft_o.jpg" width="623"></p> 
<p><strong> 当 rear = front 且 flag = true时，队列为满。</strong></p> 
<p style="text-align:center;"> <img alt="" height="467" src="https://images2.imgbox.com/57/f2/az82I4Qi_o.jpg" width="652"></p> 
<p><strong> 队空判断条件：</strong></p> 
<pre><code class="language-objectivec">(q-&gt;front == q-&gt;rear) &amp;&amp; !(q-&gt;flag)</code></pre> 
<p><strong>队满判断条件：</strong></p> 
<pre><code class="language-objectivec">(q-&gt;front == q-&gt;rear) &amp;&amp; q-&gt;flag</code></pre> 
<h4>i、初始化队列操作：</h4> 
<p>        利用malloc()函数创建队列，初始化 rear = front = 0，并将 flag 设置为队空标志（flag = false）。</p> 
<pre><code class="language-objectivec">SeqQueue* InitQueue()
{
	SeqQueue* q;
	q = (SeqQueue*)malloc(sizeof(SeqQueue)); // 分配队列的内存
	q-&gt;flag = false; // 设置队空标志
	q-&gt;front = q-&gt;rear = 0; // 初始化 rear和 front
	printf("循环队列已经创建完毕\n");
	return q;
}</code></pre> 
<h4 id="ii%E3%80%81%E5%88%A4%E6%96%AD%E9%98%9F%E7%A9%BA%E6%93%8D%E4%BD%9C%EF%BC%9A"><strong>ii、判断队空操作：</strong></h4> 
<p><strong>        </strong>利用队空判断条件进行判断，成立则队空，不成立则队不为空。</p> 
<pre><code class="language-objectivec">bool QueueEmpty(SeqQueue* q)
{
	if ((q-&gt;front == q-&gt;rear) &amp;&amp; !(q-&gt;flag))  // 判断队空
		return true;
	return false;
}</code></pre> 
<h4><strong>iii、入队操作：</strong></h4> 
<p>        首先判断利用队满条件判断是否可以入队，可以入队，然后再进行入队操作，并更新rear，入队后，需要判断 rear 是否等于 front，（即入队后要判断队是否为满）队满设置<strong>flag</strong>为队满的的flag值。（这就是和最开始的循环队列的区别，因为最开始的循环队列，当入队后rear = front，没设置区分队空和队满的标志，在退出入队函数后，就区分不了队空、队满，此时 rear = front）。</p> 
<pre><code class="language-objectivec">bool EnQueue(SeqQueue* q, DataType x)
{
	if ((q-&gt;front == q-&gt;rear) &amp;&amp; q-&gt;flag) // 判断队满
	{
		printf("循环队列已满！\n");
		return false;
	}
	q-&gt;data[q-&gt;rear++] = x; // 入队
	q-&gt;rear %= MAXSIZE; // 更新rear
	if (q-&gt;rear == q-&gt;front) // 判断入队后，队是否为满，满则设置队满标志flag
		q-&gt;flag = true; // 队满
	return true;
}</code></pre> 
<h4>iv、出队操作：</h4> 
<p>        首先利用队空判断条件判断队列是否为空，可以出队，再执行出队操作，并更新front，出队后，需要判断 rear 是否等于 front，（即出队后要判断队是否为空）队空设置<strong>flag</strong>为队空的的flag值。（这就是和最开始的循环队列的区别，因为最开始的循环队列，当出队后rear = front，没设置区分队空和队满的标志，在退出出队函数后，就区分不了队空、队满，此时 rear = front）。</p> 
<pre><code class="language-objectivec">DataType DeQueue(SeqQueue* q)
{
	DataType x; // 出队的元素的值
	if ((q-&gt;front == q-&gt;rear) &amp;&amp; !(q-&gt;flag))  // 判断队空
	{
		printf("队列为空！不能进行删除操作\n");
		return -1;
	}
	x = q-&gt;data[q-&gt;front++]; // 出队
	q-&gt;front %= MAXSIZE; // 更新front
	if (q-&gt;front == q-&gt;rear) // 判断出队后队列是否为空，设置flag标志
		q-&gt;flag = false; // 队空
	return x;
}</code></pre> 
<h3 id="%EF%BC%883%EF%BC%89%E8%AE%BE%E7%BD%AElength%E5%AD%98%E5%82%A8%E9%98%9F%E5%88%97%E5%85%83%E7%B4%A0%E7%9A%84%E4%B8%AA%E6%95%B0">（3）设置length存储队列元素的个数</h3> 
<p>        利用length来存储队列的元素个数（即队列的长度），不需要为了判断队满、队空牺牲一个元素的空间，同时利用 length 这个变量，判断队空、队满很简单，（即length = 0，<strong>队空</strong>；length = MAXSIZE，<strong>队满</strong>），不需要利用到 rear 和 front 来判断队空、队满。</p> 
<p><strong>队列的存储结构：</strong></p> 
<pre><code class="language-objectivec">#define MAXSIZE 5

typedef int DataType;

typedef struct Queue {
	DataType data[MAXSIZE];
	int front;
	int rear;
	int length;
}SeqQueue;</code></pre> 
<p><strong>当 length = 0时，队空。</strong></p> 
<p style="text-align:center;"><strong><img alt="" height="429" src="https://images2.imgbox.com/26/fa/lLPVGZLG_o.jpg" width="606"></strong></p> 
<p><strong> 当 length = MAXSIZE时，队满。</strong></p> 
<p style="text-align:center;"><strong><img alt="" height="427" src="https://images2.imgbox.com/4c/42/LC3hLdCt_o.jpg" width="597"></strong></p> 
<p><strong> 队空判断条件：</strong></p> 
<pre><code class="language-objectivec">q-&gt;length == 0</code></pre> 
<p><strong>队满判断条件：</strong></p> 
<pre><code class="language-objectivec">q-&gt;length == MAXSIZE</code></pre> 
<h4>i、初始化队列操作：</h4> 
<p>        利用malloc()函数分配队列的空间，并初始化 rear 和 front，初始化 length = 0，为队空的标志。</p> 
<pre><code class="language-objectivec">SeqQueue* InitQueue()
{
	SeqQueue* q;
	q = (SeqQueue*)malloc(sizeof(SeqQueue)); // 分配队列空间
	q-&gt;length = 0;   // 初始化length，队列为空
	q-&gt;rear = q-&gt;front = 0; // 初始化rear 和 front
	printf("循环队列已经创建完毕\n");
	return q;
}</code></pre> 
<h4><strong>ii、判断队空操作：</strong></h4> 
<p><strong>       </strong> 直接利用 length = 0 来判断队列是否为空。</p> 
<pre><code class="language-objectivec">bool QueueEmpty(SeqQueue* q)
{
	if (q-&gt;length == 0)  // 判断队空
		return true;
	return false;
}</code></pre> 
<h4><strong>iii、入队操作：</strong></h4> 
<p><strong>        </strong>首先利用队满条件判断队列是否已满，未满则进行入队操作，并更新rear，队列长度加一（length++）。</p> 
<pre><code class="language-objectivec">bool EnQueue(SeqQueue* q, DataType x)
{
	if (q-&gt;length == MAXSIZE) // 判断队满
	{
		printf("循环队列已满！\n");
		return false;
	}
	q-&gt;data[q-&gt;rear++] = x; // 入队
	q-&gt;rear %= MAXSIZE; // 更新rear
	q-&gt;length++; // 队列长度加一
	return true;
}</code></pre> 
<h4>iv、出队操作：</h4> 
<p>        利用队列为空条件判断队列是否为空，空就不进行出队操作。不为空时，出队，更新front，队列长度减一(length--）。</p> 
<pre><code class="language-objectivec">DataType DeQueue(SeqQueue* q)
{
	DataType x; // 出队元素的值
	if (q-&gt;length == 0)  // 判断队空
	{
		printf("队列为空！不能进行删除操作\n");
		return -1;
	}
	q-&gt;data[q-&gt;front++] = x; // 出队
	q-&gt;front %= MAXSIZE; // 更新front
	q-&gt;length--; // 队列的长度减一
	return x;
}</code></pre> 
<hr> 
<h3 id="%C2%A0%EF%BC%884%EF%BC%89%C2%A0%E6%80%BB%E7%BB%93"> （4） 总结</h3> 
<p> <strong>       总体来说，使用 length 来保存队列的元素个数（队列长度）的方法，是最简单的。而带有flag标志区分队满、对空的方法，则较难点。牺牲一个元素的方法在二者之间，可以根据自身的情况来选用这三种方法的一种。</strong></p> 
<h2 id="%E4%B8%89%E3%80%81%E5%BE%AA%E7%8E%AF%E9%98%9F%E5%88%97%E6%B5%8B%E8%AF%95%E7%A8%8B%E5%BA%8F">三、循环队列测试程序</h2> 
<p style="text-align:center;"><strong><span style="background-color:#fbd4d0;">在所有队列使用之前，均要初始化队列。</span></strong></p> 
<h3>（1）少用一个元素空间</h3> 
<pre><code class="language-objectivec">#include &lt;stdio.h&gt;
#include &lt;stdbool.h&gt;
#include &lt;stdlib.h&gt;

#define MAXSIZE 5

typedef int DataType;

typedef struct Queue{
	DataType data[MAXSIZE];
	int front;
	int rear;
}SeqQueue;

SeqQueue* InitQueue();
bool QueueEmpty(SeqQueue* q);
bool EnQueue(SeqQueue* q, DataType x);
DataType DeQueue(SeqQueue* q);
void ShowQueue(SeqQueue* q);
int ShowMeanu();

int main(void)
{
	int choice;
	SeqQueue* queue;
	while (true)
	{
		int choice;
		choice = ShowMeanu();
		switch (choice)
		{
			case 0:	exit(0);
				break;
			case 1: queue = InitQueue();
				break;
			case 2: {
				int x;
				printf("请输入要入队的值：");
				scanf("%d", &amp;x);
				EnQueue(queue, x);
			}
				  break;
			case 3: DeQueue(queue);
				break;
			case 4: {
				bool statue = QueueEmpty(queue);
				if (statue)
					printf("队列为空\n");
				else
					printf("队列不为空\n");
			}
				  break;
			case 5: ShowQueue(queue);
				break;

			default: printf("请输入恰当的测试功能！！！\n");
		}
	}
	return 0;
}

int ShowMeanu()
{
	int choice;
	printf("\n欢迎来到循环队列测试程序！！！！！\n");
	printf("有以下功能可提供测试\n");
	printf("1.创建循环队列        2.入队\n");
	printf("3.出队               4.判断队空\n");
	printf("5.队列显示\n");
	printf("0.退出程序\n");
	printf("你需要测试的功能是：");
	scanf("%d", &amp;choice);
	return choice;
}

SeqQueue* InitQueue()
{
	SeqQueue* q;
	q = (SeqQueue*)malloc(sizeof(SeqQueue));
	q-&gt;front = q-&gt;rear = 0;
	printf("循环队列已经创建完毕\n");
	return q;
}

bool QueueEmpty(SeqQueue* q)
{
	if (q-&gt;rear == q-&gt;front)  // 判断队空
		return true;
	return false;
}

bool EnQueue(SeqQueue* q, DataType x)
{
	if ((q-&gt;rear+1) % MAXSIZE == q-&gt;front)
	{
		printf("循环队列已满！\n");
		return false;
	}
	q-&gt;data[q-&gt;rear] = x;
	q-&gt;rear = (q-&gt;rear + 1) % MAXSIZE;
	return true;
}

DataType DeQueue(SeqQueue* q)
{
	DataType x;
	if (q-&gt;rear == q-&gt;front)  // 判断队空
	{
		printf("队列为空！不能进行删除操作\n");
		return -1;
	}
	x = q-&gt;data[q-&gt;front];
	q-&gt;front = (q-&gt;front + 1) % MAXSIZE;
	return x;
}

void ShowQueue(SeqQueue* q)
{
	int front, rear;
	front = q-&gt;front;
	rear = q-&gt;rear;
	if (rear == front)
    {
		printf("队列为空！！！\n");
        return;
    }
	while (rear != front)
		printf("%d\n", q-&gt;data[front++]);
	return;
}</code></pre> 
<h3>（2）设置flag标志</h3> 
<pre><code class="language-objectivec">#include &lt;stdio.h&gt;
#include &lt;stdbool.h&gt;
#include &lt;stdlib.h&gt;

#define MAXSIZE 5

typedef int DataType;

typedef struct Queue{
	DataType data[MAXSIZE];
	int front;
	int rear;
	bool flag;
}SeqQueue;

SeqQueue* InitQueue();
bool QueueEmpty(SeqQueue* q);
bool EnQueue(SeqQueue* q, DataType x);
DataType DeQueue(SeqQueue* q);
void ShowQueue(SeqQueue* q);
int ShowMeanu();

int main(void)
{
	int choice;
	SeqQueue* queue;
	while (true)
	{
		int choice;
		choice = ShowMeanu();
		switch (choice)
		{
			case 0:	exit(0);
				break;
			case 1: queue = InitQueue();
				break;
			case 2: {
				int x;
				printf("请输入要入队的值：");
				scanf("%d", &amp;x);
				EnQueue(queue, x);
			}
				  break;
			case 3: DeQueue(queue);
				break;
			case 4: {
				bool statue = QueueEmpty(queue);
				if (statue)
					printf("队列为空\n");
				else
					printf("队列不为空\n");
			}
				  break;
			case 5: ShowQueue(queue);
				break;

			default: printf("请输入恰当的测试功能！！！\n");
		}
	}
	return 0;
}

int ShowMeanu()
{
	int choice;
	printf("\n欢迎来到循环队列测试程序！！！！！\n");
	printf("有以下功能可提供测试\n");
	printf("1.创建循环队列        2.入队\n");
	printf("3.出队               4.判断队空\n");
	printf("5.队列显示\n");
	printf("0.退出程序\n");
	printf("你需要测试的功能是：");
	scanf("%d", &amp;choice);
	return choice;
}

SeqQueue* InitQueue()
{
	SeqQueue* q;
	q = (SeqQueue*)malloc(sizeof(SeqQueue));
	q-&gt;flag = false;
	q-&gt;front = q-&gt;rear = 0;
	printf("循环队列已经创建完毕\n");
	return q;
}

bool QueueEmpty(SeqQueue* q)
{
	if ((q-&gt;front == q-&gt;rear) &amp;&amp; !(q-&gt;flag))  // 判断队空
		return true;
	return false;
}

bool EnQueue(SeqQueue* q, DataType x)
{
	if ((q-&gt;front == q-&gt;rear) &amp;&amp; q-&gt;flag)
	{
		printf("循环队列已满！\n");
		return false;
	}
	q-&gt;data[q-&gt;rear] = x;
	++(q-&gt;rear);
	q-&gt;rear %= MAXSIZE;
	if (q-&gt;rear == q-&gt;front) // 设置队列已满
		q-&gt;flag = true;
	return true;
}

DataType DeQueue(SeqQueue* q)
{
	DataType x;
	if ((q-&gt;front == q-&gt;rear) &amp;&amp; !(q-&gt;flag))  // 判断队空
	{
		printf("队列为空！不能进行删除操作\n");
		return -1;
	}
	x = q-&gt;data[q-&gt;front++];
	q-&gt;front %= MAXSIZE;
	if (q-&gt;front == q-&gt;rear) // 设置队列为空
		q-&gt;flag = false;
	return x;
}

void ShowQueue(SeqQueue* q)
{
	int front, rear;
	front = q-&gt;front;
	rear = q-&gt;rear;
	if ((front == rear) &amp;&amp; !(q-&gt;flag))
    {
	    printf("队列为空\n");
        return;
    }
	/*while (front != rear) // 循环输出队列元素
	{
		printf("%d\n", q-&gt;data[front++]);
		front %= MAXSIZE;
	}  // 忽略了队满 rear == front*/

	// 先输出一个元素，便可解决上面此种情况
	printf("%d\n", q-&gt;data[front++]);
	while (front != rear) // 循环输出队列元素
	{
		printf("%d\n", q-&gt;data[front++]);
		front %= MAXSIZE;
	}
	return;
}</code></pre> 
<h3>（3）设置length存储队列元素的个数</h3> 
<pre><code class="language-objectivec">#include &lt;stdio.h&gt;
#include &lt;stdbool.h&gt;
#include &lt;stdlib.h&gt;

#define MAXSIZE 5

typedef int DataType;

typedef struct Queue {
	DataType data[MAXSIZE];
	int front;
	int rear;
	int length;
}SeqQueue;

SeqQueue* InitQueue();
bool QueueEmpty(SeqQueue* q);
bool EnQueue(SeqQueue* q, DataType x);
DataType DeQueue(SeqQueue* q);
void ShowQueue(SeqQueue* q);
int ShowMeanu();

int main(void)
{
	int choice;
	SeqQueue* queue;
	while (true)
	{
		int choice;
		choice = ShowMeanu();
		switch (choice)
		{
		case 0:	exit(0);
			break;
		case 1: queue = InitQueue();
			break;
		case 2: {
			int x;
			printf("请输入要入队的值：");
			scanf("%d", &amp;x);
			EnQueue(queue, x);
		}
			  break;
		case 3: DeQueue(queue);
			break;
		case 4: {
			bool statue = QueueEmpty(queue);
			if (statue)
				printf("队列为空\n");
			else
				printf("队列不为空\n");
		}
			  break;
		case 5: ShowQueue(queue);
			break;

		default: printf("请输入恰当的测试功能！！！\n");
		}
	}
	return 0;
}

int ShowMeanu()
{
	int choice;
	printf("\n欢迎来到循环队列测试程序！！！！！\n");
	printf("有以下功能可提供测试\n");
	printf("1.创建循环队列        2.入队\n");
	printf("3.出队               4.判断队空\n");
	printf("5.队列显示\n");
	printf("0.退出程序\n");
	printf("你需要测试的功能是：");
	scanf("%d", &amp;choice);
	return choice;
}

SeqQueue* InitQueue()
{
	SeqQueue* q;
	q = (SeqQueue*)malloc(sizeof(SeqQueue));
	q-&gt;length = 0;
	q-&gt;rear = q-&gt;front = 0;
	printf("循环队列已经创建完毕\n");
	return q;
}

bool QueueEmpty(SeqQueue* q)
{
	if (q-&gt;length == 0)  // 判断队空
		return true;
	return false;
}

bool EnQueue(SeqQueue* q, DataType x)
{
	if (q-&gt;length == MAXSIZE)
	{
		printf("循环队列已满！\n");
		return false;
	}
	q-&gt;data[q-&gt;rear++] = x;
	q-&gt;rear %= MAXSIZE;
	q-&gt;length++;
	return true;
}

DataType DeQueue(SeqQueue* q)
{
	DataType x;
	if (q-&gt;length == 0)  // 判断队空
	{
		printf("队列为空！不能进行删除操作\n");
		return -1;
	}
	q-&gt;data[q-&gt;front++] = x;
	q-&gt;front %= MAXSIZE;
	q-&gt;length--;
	return x;
}

void ShowQueue(SeqQueue* q)
{
	int front = q-&gt;front;
	int length = q-&gt;length; // 存储队列长度
	if (length == 0)
	{
		printf("队列为空！！！\n");
		return;
	}
	while (length != 0)
	{
		printf("%d\n", q-&gt;data[front++]);
		front %= MAXSIZE;
		length--;
	}
	return;
}</code></pre> 
<h2 id="%E5%9B%9B%E3%80%81%E6%8B%93%E5%B1%95">四、拓展</h2> 
<p>        当上面的方法三（即利用length来保存队列的元素个数），少了一个指针，你是否还能进行入队、出队的操作。这里我用少了一个队头指针（front）来做演示。</p> 
<h3 id="%EF%BC%881%EF%BC%89%E6%80%9D%E8%B7%AF">（1）思路</h3> 
<p>        少了一个front队头指针，我们的出队就变的好像不知所措，我们一般想如果它能用length 和 rear 表示该多好，而这也正是解决此题的方法，我们需要找出 rear、front 和 length 这三者之间的关系。</p> 
<p>       <strong>length 表示列表长度</strong>，那 首先猜想length = rear - front 是不是可以推出 front = rear - length 呢？看下图：</p> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/91/77/d29Mdg6l_o.jpg"></p> 
<p> 此时length = 2， rear = 4,。front = rear - length = 2好像可以，但再看下图：</p> 
<p><img alt="" src="https://images2.imgbox.com/4b/1e/xXdJDCkh_o.jpg">此时 length = 3，rear = 0。front = rear - length = -3那就不行了，故 <strong>front <img alt="\neq" class="mathcode" src="https://images2.imgbox.com/b6/2a/vWPp9EjX_o.png"> rear - length</strong>。</p> 
<p>        咱们想对上面第二个图（即front = -3），rear 加上空的位置个数是不是就是front，对的，它就是front，那空的位置个数等于数组的最大元素的个数减去队列的长度（<strong>MAXSIZE - length</strong>），即<strong> front = (rear + MAXSIZE - length). </strong>但又看第一个图：</p> 
<p style="text-align:center;"><img alt="" height="369" src="https://images2.imgbox.com/42/88/1Iiym8sI_o.jpg" width="677"></p> 
<p> 此时 front 好像不需要MAXSIZE就可得出（front = rear - length）；那现在要解决的问题就是，要在需要MAXSIZE就要有，不需要则无，因为 MAXSIZE 对其本身求模为 0，故在把上公式对MAXSIZE求模，就相当于MAXSIZE没有，故公式改进为 <strong>front = (rear + MAXSIZE - length) % MASIZE.</strong>符合两个图，那就推出了length 、rear、front三者之间的关系（即  <strong>front = (rear + MAXSIZE - length) % MASIZE</strong>）。然后利用这个关系就可以修改之前那个源码了。</p> 
<h3 id="%EF%BC%882%EF%BC%89%E4%BF%AE%E6%94%B9%E4%BB%A3%E7%A0%81">（2）修改代码</h3> 
<p><strong>队列的存储结构：</strong></p> 
<pre><code class="language-objectivec">#define MAXSIZE 5

typedef int DataType;

typedef struct Queue{
	DataType data[MAXSIZE];
	int rear;
	int length; // 少了front指针
}SeqQueue;</code></pre> 
<h4 id="%E9%98%9F%E7%A9%BA%E5%92%8C%E9%98%9F%E6%BB%A1%E6%9D%A1%E4%BB%B6%E6%B2%A1%E6%9C%89%E6%94%B9%E5%8F%98%E3%80%82">队空和队满条件没有改变。</h4> 
<p><strong>队空条件：</strong></p> 
<pre><code class="language-objectivec">q-&gt;length == 0</code></pre> 
<p><strong>队满条件：</strong></p> 
<pre><code class="language-objectivec">q-&gt;length == MAXSIZE</code></pre> 
<h4 id="%C2%A0i%E3%80%81%E5%88%9D%E5%A7%8B%E5%8C%96%E6%93%8D%E4%BD%9C%EF%BC%9A"> i、初始化操作：</h4> 
<p>        利用malloc()函数分配队列的空间，初始化length和rear。</p> 
<pre><code class="language-objectivec">SeqQueue* InitQueue()
{
	SeqQueue* q;
	q = (SeqQueue*)malloc(sizeof(SeqQueue));
	q-&gt;length = 0; // 初始化length
	q-&gt;rear = 0; // 初始化
	printf("循环队列已经创建完毕\n");
	return q;
}</code></pre> 
<h4 id="ii%E3%80%81%E5%88%A4%E6%96%AD%E9%98%9F%E5%88%97%E4%B8%BA%E7%A9%BA%E6%93%8D%E4%BD%9C%EF%BC%9A">ii、判断队列为空操作：</h4> 
<p>        利用length == 0.</p> 
<pre><code class="language-objectivec">bool QueueEmpty(SeqQueue* q)
{
	if (q-&gt;length == 0)  // 判断队空
		return true;
	return false;
}</code></pre> 
<h4>iii、入队操作：</h4> 
<p>        入队操作和上面的没变——利用队满条件判断队列是否已满，未满则进行入队操作，并更新rear，队列长度加一（length++）。</p> 
<pre><code class="language-objectivec">bool EnQueue(SeqQueue* q, DataType x)
{
	if (q-&gt;length == MAXSIZE) // 判断队满
	{
		printf("循环队列已满！\n");
		return false;
	}
	q-&gt;data[q-&gt;rear++] = x; // 入队
	q-&gt;rear %= MAXSIZE;    // 更新rear
	q-&gt;length++;    // 队列长度加一
	return true;
}</code></pre> 
<h4>iv、出队操作：</h4> 
<p>        出队操作改变了，这里要声明一个局部变量，充当 front 队头指针，利用关系<strong>front = (rear + MAXSIZE - length) % MASIZE</strong>求出队头的位置，再进行出队操作并更新length。</p> 
<pre><code class="language-objectivec">DataType DeQueue(SeqQueue* q)
{
	DataType x;
	int front; // 局部变量，相当于队头指针
	if (q-&gt;length == 0)  // 判断队空
	{
		printf("队列为空！不能进行删除操作\n");
		return -1;
	}
	front = (MAXSIZE - q-&gt;length + q-&gt;rear) % MAXSIZE; // 求出队头指针位置
	x = q-&gt;data[front]; // 出队
	q-&gt;length--;    // 队列长度减一
	return x;
}
</code></pre> 
<hr> 
<p>        如果是<strong>去掉队尾指针rear</strong>，则利用等式<strong> rear = (front + length) % MAXSIZE</strong> 求出rear，其等式过程是怎样形成的，与上面类似（去掉front队头指针），请自行思考。</p> 
<h3 id="%EF%BC%883%EF%BC%89%E6%B5%8B%E8%AF%95%E7%A8%8B%E5%BA%8F">（3）测试程序</h3> 
<p style="text-align:center;"><strong><span style="background-color:#fbd4d0;">在使用队列之前，请对队列初始化。</span></strong></p> 
<pre><code class="language-objectivec">#include &lt;stdio.h&gt;
#include &lt;stdbool.h&gt;
#include &lt;stdlib.h&gt;

#define MAXSIZE 5

typedef int DataType;

typedef struct Queue{
	DataType data[MAXSIZE];
	int rear;
	int length;
}SeqQueue;

SeqQueue* InitQueue();
bool QueueEmpty(SeqQueue* q);
bool EnQueue(SeqQueue* q, DataType x);
DataType DeQueue(SeqQueue* q);
void ShowQueue(SeqQueue* q);
int ShowMeanu();

int main(void)
{
	int choice;
	SeqQueue* queue;
	while (true)
	{
		int choice;
		choice = ShowMeanu();
		switch (choice)
		{
		case 0:	exit(0);
			break;
		case 1: queue = InitQueue();
			break;
		case 2: {
			int x;
			printf("请输入要入队的值：");
			scanf("%d", &amp;x);
			EnQueue(queue, x);
		}
			  break;
		case 3: DeQueue(queue);
			break;
		case 4: {
			bool statue = QueueEmpty(queue);
			if (statue)
				printf("队列为空\n");
			else
				printf("队列不为空\n");
		}
			  break;
		case 5: ShowQueue(queue);
			break;

		default: printf("请输入恰当的测试功能！！！\n");
		}
	}
	return 0;
}

int ShowMeanu()
{
	int choice;
	printf("\n欢迎来到循环队列测试程序！！！！！\n");
	printf("有以下功能可提供测试\n");
	printf("1.创建循环队列        2.入队\n");
	printf("3.出队               4.判断队空\n");
	printf("5.队列显示\n");
	printf("0.退出程序\n");
	printf("你需要测试的功能是：");
	scanf("%d", &amp;choice);
	return choice;
}

SeqQueue* InitQueue()
{
	SeqQueue* q;
	q = (SeqQueue*)malloc(sizeof(SeqQueue));
	q-&gt;length = 0;
	q-&gt;rear = 0;
	printf("循环队列已经创建完毕\n");
	return q;
}

bool QueueEmpty(SeqQueue* q)
{
	if (q-&gt;length == 0)  // 判断队空
		return true;
	return false;
}

bool EnQueue(SeqQueue* q, DataType x)
{
	if (q-&gt;length == MAXSIZE)
	{
		printf("循环队列已满！\n");
		return false;
	}
	q-&gt;data[q-&gt;rear++] = x;
	q-&gt;rear %= MAXSIZE;
	q-&gt;length++;
	return true;
}

DataType DeQueue(SeqQueue* q)
{
	DataType x;
	int front;
	if (q-&gt;length == 0)  // 判断队空
	{
		printf("队列为空！不能进行删除操作\n");
		return -1;
	}
	front = (MAXSIZE - q-&gt;length + q-&gt;rear) % MAXSIZE;
	x = q-&gt;data[front];
	q-&gt;length--;
	return x;
}

void ShowQueue(SeqQueue* q)
{
	int front;
	int length = q-&gt;length; // 存储队列长度
	if (length == 0)
	{
		printf("队列为空！！！\n");
		return;
	}
	while (length != 0)
	{
		front = (MAXSIZE - length + q-&gt;rear) % MAXSIZE;
		printf("%d", q-&gt;data[front]);
		length--;
	}
	return;
}</code></pre> 
<p></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/183cfcdc29a225bb260989fbda7b82d5/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">【Kotlin】泛型 ① ( 泛型类 | 泛型参数 | 泛型函数 | 多泛型参数 | 泛型类型约束 )</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/2d0111f72c1085207e1eb3c34038907f/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">Tarjan算法详解（AcWing 1174 受欢迎的牛）</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>