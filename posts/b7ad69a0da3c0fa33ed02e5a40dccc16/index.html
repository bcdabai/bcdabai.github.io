<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>c&#43;&#43; - 第18节 - 哈希 - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="c&#43;&#43; - 第18节 - 哈希" />
<meta property="og:description" content="目录
1.unordered系列关联式容器
1.1.unordered_set
1.1.1.unordered_set的介绍
1.1.2.unordered_set的使用
1.2.unordered_map
1.2.1.unordered_map的介绍
1.2.2.unordered_map的使用
1.3.unordered_multiset和unordered_multimap
2.底层结构
2.1.哈希概念
2.2.哈希冲突
2.3.哈希函数
2.4.哈希冲突解决
2.4.1.闭散列
2.4.2 开散列
3.哈希开散列模拟实现STL中的unordered_map与unordered_set
3.1.封装开散列代码，同时实现unordered_map和unordered_set
3.2.开散列哈希表的迭代器
3.3.开散列哈希表容量为素数的优化
3.4.开散列哈希表模拟实现STL中unordered_map和unordered_set的代码
4.哈希的应用
4.1.位图
4.1.1.位图概念
4.1.2.位图的实现
4.1.3.位图的应用
4.2.布隆过滤器
4.2.1.布隆过滤器提出
4.2.2.布隆过滤器概念
4.2.3.布隆过滤器的实现
4.2.4.布隆过滤器删除
4.2.5.布隆过滤器优点
4.2.6.布隆过滤器缺陷
4.2.7.布隆过滤器应用场景
5. 海量数据面试题
5.1.哈希切割
5.2.位图应用
5.3.布隆过滤器
6.分布式存储
1.unordered系列关联式容器 在C&#43;&#43;98中，STL提供了底层为红黑树结构的一系列关联式容器，在查询时效率可达到 ，即最差情况下需要比较红黑树的高度次，当树中的节点非常多时，查询效率也不理想。最好的查询是，进行很少的比较次数就能够将元素找到，因此在C&#43;&#43;11中，STL又提供了4个unordered系列的关联式容器，这四个容器与红黑树结构的关联式容器使用方式基本类似，只是其底层结构不同，这里只对unordered_map和unordered_set进行介绍，unordered_multimap和unordered_multiset学生可查看文档介绍。 1.1.unordered_set 1.1.1.unordered_set的介绍 unordered_set类的文档介绍：unordered_set - C&#43;&#43; Reference (cplusplus.com)
注：
1. unordered_set是存储key值的关联式容器。 2. 在unordered_set中，key值用于惟一地标识元素。 3. 在内部,unordered_set没有对key按照任何特定的顺序排序, 为了能在常数范围内找到key，unordered_set将相同哈希值的key放在相同的桶中。 4. unordered_set容器通过key访问单个元素要比set快，但它通常在遍历元素子集的范围迭代方面效率较低。 5. 它的迭代器是前向迭代器。 1.1.2.unordered_set的使用 此处只简单演示unordered_set与set的不同，其他接口与set相同，可参考set。
（1）set中的迭代器是双向迭代器，因此set中有begin、end、rbegin、rend函数。unordered_set中的迭代器是单向迭代器，因此unordered_set中有begin、end函数而没有rbegin、rend函数。
（2）set遍历访问的数据是有序的，unordered_set遍历访问的数据是无序的。
（3）set底层是红黑树，其搜索效率为，unordered_set底层是哈希，其搜索效率为O(1)，如下面代码所示
注：rand函数产生的随机数其实是有限制的，c语言rand函数有一个RAND_MAX，其最大只能产生三万多个随机数，因此如果上面的n值很大时，重复的数据是很多的，打印出来的size值（不重复的值）远小于n值。如果想让随机数变得更多可以如下图所示，给rand函数&#43;循环变量i。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/b7ad69a0da3c0fa33ed02e5a40dccc16/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-12-30T16:19:49+08:00" />
<meta property="article:modified_time" content="2022-12-30T16:19:49+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">c&#43;&#43; - 第18节 - 哈希</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p id="main-toc"><strong>目录</strong></p> 
<p id="1.unordered%E7%B3%BB%E5%88%97%E5%85%B3%E8%81%94%E5%BC%8F%E5%AE%B9%E5%99%A8-toc" style="margin-left:0px;"><a href="#1.unordered%E7%B3%BB%E5%88%97%E5%85%B3%E8%81%94%E5%BC%8F%E5%AE%B9%E5%99%A8" rel="nofollow">1.unordered系列关联式容器</a></p> 
<p id="1.1.unordered_set-toc" style="margin-left:40px;"><a href="#1.1.unordered_set" rel="nofollow">1.1.unordered_set</a></p> 
<p id="1.1.1.unordered_set%E7%9A%84%E4%BB%8B%E7%BB%8D-toc" style="margin-left:80px;"><a href="#1.1.1.unordered_set%E7%9A%84%E4%BB%8B%E7%BB%8D" rel="nofollow">1.1.1.unordered_set的介绍</a></p> 
<p id="1.1.2.unordered_set%E7%9A%84%E4%BD%BF%E7%94%A8-toc" style="margin-left:80px;"><a href="#1.1.2.unordered_set%E7%9A%84%E4%BD%BF%E7%94%A8" rel="nofollow">1.1.2.unordered_set的使用</a></p> 
<p id="1.2.unordered_map-toc" style="margin-left:40px;"><a href="#1.2.unordered_map" rel="nofollow">1.2.unordered_map</a></p> 
<p id="1.2.1.unordered_map%E7%9A%84%E4%BB%8B%E7%BB%8D-toc" style="margin-left:80px;"><a href="#1.2.1.unordered_map%E7%9A%84%E4%BB%8B%E7%BB%8D" rel="nofollow">1.2.1.unordered_map的介绍</a></p> 
<p id="1.2.2.unordered_map%E7%9A%84%E4%BD%BF%E7%94%A8-toc" style="margin-left:80px;"><a href="#1.2.2.unordered_map%E7%9A%84%E4%BD%BF%E7%94%A8" rel="nofollow">1.2.2.unordered_map的使用</a></p> 
<p id="1.3.unordered_multiset%E5%92%8Cunordered_multimap-toc" style="margin-left:40px;"><a href="#1.3.unordered_multiset%E5%92%8Cunordered_multimap" rel="nofollow">1.3.unordered_multiset和unordered_multimap</a></p> 
<p id="2.%E5%BA%95%E5%B1%82%E7%BB%93%E6%9E%84-toc" style="margin-left:0px;"><a href="#2.%E5%BA%95%E5%B1%82%E7%BB%93%E6%9E%84" rel="nofollow">2.底层结构</a></p> 
<p id="2.1.%E5%93%88%E5%B8%8C%E6%A6%82%E5%BF%B5-toc" style="margin-left:40px;"><a href="#2.1.%E5%93%88%E5%B8%8C%E6%A6%82%E5%BF%B5" rel="nofollow">2.1.哈希概念</a></p> 
<p id="2.2.%E5%93%88%E5%B8%8C%E5%86%B2%E7%AA%81-toc" style="margin-left:40px;"><a href="#2.2.%E5%93%88%E5%B8%8C%E5%86%B2%E7%AA%81" rel="nofollow">2.2.哈希冲突</a></p> 
<p id="2.3.%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0-toc" style="margin-left:40px;"><a href="#2.3.%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0" rel="nofollow">2.3.哈希函数</a></p> 
<p id="2.4.%E5%93%88%E5%B8%8C%E5%86%B2%E7%AA%81%E8%A7%A3%E5%86%B3-toc" style="margin-left:40px;"><a href="#2.4.%E5%93%88%E5%B8%8C%E5%86%B2%E7%AA%81%E8%A7%A3%E5%86%B3" rel="nofollow">2.4.哈希冲突解决</a></p> 
<p id="2.4.1.%E9%97%AD%E6%95%A3%E5%88%97-toc" style="margin-left:80px;"><a href="#2.4.1.%E9%97%AD%E6%95%A3%E5%88%97" rel="nofollow">2.4.1.闭散列</a></p> 
<p id="2.4.2%20%E5%BC%80%E6%95%A3%E5%88%97-toc" style="margin-left:80px;"><a href="#2.4.2%20%E5%BC%80%E6%95%A3%E5%88%97" rel="nofollow">2.4.2 开散列</a></p> 
<p id="3.%E5%93%88%E5%B8%8C%E5%BC%80%E6%95%A3%E5%88%97%E6%A8%A1%E6%8B%9F%E5%AE%9E%E7%8E%B0STL%E4%B8%AD%E7%9A%84unordered_map%E4%B8%8Eunordered_set-toc" style="margin-left:0px;"><a href="#3.%E5%93%88%E5%B8%8C%E5%BC%80%E6%95%A3%E5%88%97%E6%A8%A1%E6%8B%9F%E5%AE%9E%E7%8E%B0STL%E4%B8%AD%E7%9A%84unordered_map%E4%B8%8Eunordered_set" rel="nofollow">3.哈希开散列模拟实现STL中的unordered_map与unordered_set</a></p> 
<p id="3.1.%E5%B0%81%E8%A3%85%E7%BA%A2%E9%BB%91%E6%A0%91%E4%BB%A3%E7%A0%81%EF%BC%8C%E5%90%8C%E6%97%B6%E5%AE%9E%E7%8E%B0map%E5%92%8Cset-toc" style="margin-left:40px;"><a href="#3.1.%E5%B0%81%E8%A3%85%E7%BA%A2%E9%BB%91%E6%A0%91%E4%BB%A3%E7%A0%81%EF%BC%8C%E5%90%8C%E6%97%B6%E5%AE%9E%E7%8E%B0map%E5%92%8Cset" rel="nofollow">3.1.封装开散列代码，同时实现unordered_map和unordered_set</a></p> 
<p id="3.2.%E5%BC%80%E6%95%A3%E5%88%97%E5%93%88%E5%B8%8C%E8%A1%A8%E7%9A%84%E8%BF%AD%E4%BB%A3%E5%99%A8-toc" style="margin-left:40px;"><a href="#3.2.%E5%BC%80%E6%95%A3%E5%88%97%E5%93%88%E5%B8%8C%E8%A1%A8%E7%9A%84%E8%BF%AD%E4%BB%A3%E5%99%A8" rel="nofollow">3.2.开散列哈希表的迭代器</a></p> 
<p id="3.3.%E5%BC%80%E6%95%A3%E5%88%97%E5%93%88%E5%B8%8C%E8%A1%A8%E5%AE%B9%E9%87%8F%E4%B8%BA%E7%B4%A0%E6%95%B0%E7%9A%84%E4%BC%98%E5%8C%96-toc" style="margin-left:40px;"><a href="#3.3.%E5%BC%80%E6%95%A3%E5%88%97%E5%93%88%E5%B8%8C%E8%A1%A8%E5%AE%B9%E9%87%8F%E4%B8%BA%E7%B4%A0%E6%95%B0%E7%9A%84%E4%BC%98%E5%8C%96" rel="nofollow">3.3.开散列哈希表容量为素数的优化</a></p> 
<p id="3.3.%E7%BA%A2%E9%BB%91%E6%A0%91%E6%A8%A1%E6%8B%9F%E5%AE%9E%E7%8E%B0STL%E4%B8%ADmap%E4%B8%8Eset%E7%9A%84%E4%BB%A3%E7%A0%81-toc" style="margin-left:40px;"><a href="#3.3.%E7%BA%A2%E9%BB%91%E6%A0%91%E6%A8%A1%E6%8B%9F%E5%AE%9E%E7%8E%B0STL%E4%B8%ADmap%E4%B8%8Eset%E7%9A%84%E4%BB%A3%E7%A0%81" rel="nofollow">3.4.开散列哈希表模拟实现STL中unordered_map和unordered_set的代码</a></p> 
<p id="4.%E5%93%88%E5%B8%8C%E7%9A%84%E5%BA%94%E7%94%A8-toc" style="margin-left:0px;"><a href="#4.%E5%93%88%E5%B8%8C%E7%9A%84%E5%BA%94%E7%94%A8" rel="nofollow">4.哈希的应用</a></p> 
<p id="4.1.%E4%BD%8D%E5%9B%BE-toc" style="margin-left:40px;"><a href="#4.1.%E4%BD%8D%E5%9B%BE" rel="nofollow">4.1.位图</a></p> 
<p id="4.1.1.%E4%BD%8D%E5%9B%BE%E6%A6%82%E5%BF%B5-toc" style="margin-left:80px;"><a href="#4.1.1.%E4%BD%8D%E5%9B%BE%E6%A6%82%E5%BF%B5" rel="nofollow">4.1.1.位图概念</a></p> 
<p id="4.1.2.%E4%BD%8D%E5%9B%BE%E7%9A%84%E5%AE%9E%E7%8E%B0-toc" style="margin-left:80px;"><a href="#4.1.2.%E4%BD%8D%E5%9B%BE%E7%9A%84%E5%AE%9E%E7%8E%B0" rel="nofollow">4.1.2.位图的实现</a></p> 
<p id="4.1.3.%E4%BD%8D%E5%9B%BE%E7%9A%84%E5%BA%94%E7%94%A8-toc" style="margin-left:80px;"><a href="#4.1.3.%E4%BD%8D%E5%9B%BE%E7%9A%84%E5%BA%94%E7%94%A8" rel="nofollow">4.1.3.位图的应用</a></p> 
<p id="4.2.%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8-toc" style="margin-left:40px;"><a href="#4.2.%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8" rel="nofollow">4.2.布隆过滤器</a></p> 
<p id="4.2.1.%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8%E6%8F%90%E5%87%BA-toc" style="margin-left:80px;"><a href="#4.2.1.%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8%E6%8F%90%E5%87%BA" rel="nofollow">4.2.1.布隆过滤器提出</a></p> 
<p id="4.2.2.%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8%E6%A6%82%E5%BF%B5-toc" style="margin-left:80px;"><a href="#4.2.2.%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8%E6%A6%82%E5%BF%B5" rel="nofollow">4.2.2.布隆过滤器概念</a></p> 
<p id="4.2.3.%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8%E7%9A%84%E5%AE%9E%E7%8E%B0-toc" style="margin-left:80px;"><a href="#4.2.3.%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8%E7%9A%84%E5%AE%9E%E7%8E%B0" rel="nofollow">4.2.3.布隆过滤器的实现</a></p> 
<p id="4.2.4.%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8%E5%88%A0%E9%99%A4-toc" style="margin-left:80px;"><a href="#4.2.4.%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8%E5%88%A0%E9%99%A4" rel="nofollow">4.2.4.布隆过滤器删除</a></p> 
<p id="4.2.5.%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8%E4%BC%98%E7%82%B9-toc" style="margin-left:80px;"><a href="#4.2.5.%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8%E4%BC%98%E7%82%B9" rel="nofollow">4.2.5.布隆过滤器优点</a></p> 
<p id="4.2.6.%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8%E7%BC%BA%E9%99%B7-toc" style="margin-left:80px;"><a href="#4.2.6.%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8%E7%BC%BA%E9%99%B7" rel="nofollow">4.2.6.布隆过滤器缺陷</a></p> 
<p id="4.2.7.%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF-toc" style="margin-left:80px;"><a href="#4.2.7.%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF" rel="nofollow">4.2.7.布隆过滤器应用场景</a></p> 
<p id="5.%20%E6%B5%B7%E9%87%8F%E6%95%B0%E6%8D%AE%E9%9D%A2%E8%AF%95%E9%A2%98-toc" style="margin-left:0px;"><a href="#5.%20%E6%B5%B7%E9%87%8F%E6%95%B0%E6%8D%AE%E9%9D%A2%E8%AF%95%E9%A2%98" rel="nofollow">5. 海量数据面试题</a></p> 
<p id="5.1.%E5%93%88%E5%B8%8C%E5%88%87%E5%89%B2-toc" style="margin-left:40px;"><a href="#5.1.%E5%93%88%E5%B8%8C%E5%88%87%E5%89%B2" rel="nofollow">5.1.哈希切割</a></p> 
<p id="5.2.%E4%BD%8D%E5%9B%BE%E5%BA%94%E7%94%A8-toc" style="margin-left:40px;"><a href="#5.2.%E4%BD%8D%E5%9B%BE%E5%BA%94%E7%94%A8" rel="nofollow">5.2.位图应用</a></p> 
<p id="5.3.%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8-toc" style="margin-left:40px;"><a href="#5.3.%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8" rel="nofollow">5.3.布隆过滤器</a></p> 
<p id="6.%E5%88%86%E5%B8%83%E5%BC%8F%E5%AD%98%E5%82%A8-toc" style="margin-left:0px;"><a href="#6.%E5%88%86%E5%B8%83%E5%BC%8F%E5%AD%98%E5%82%A8" rel="nofollow">6.分布式存储</a></p> 
<hr id="hr-toc"> 
<p></p> 
<h2 id="1.unordered%E7%B3%BB%E5%88%97%E5%85%B3%E8%81%94%E5%BC%8F%E5%AE%B9%E5%99%A8"><span style="color:#333333;"><strong>1.unordered</strong></span><span style="color:#333333;"><strong>系列关联式容器</strong></span></h2> 
<blockquote> 
 <div>
   在C++98中，STL提供了底层为红黑树结构的一系列关联式容器，在查询时效率可达到 
  <img alt="log_{2}^{N}" class="mathcode" src="https://images2.imgbox.com/85/da/eRfwYrCz_o.png">，即最差情况下需要比较红黑树的高度次，当树中的节点非常多时，查询效率也不理想。最好的查询是，进行很少的比较次数就能够将元素找到，因此在C++11中，STL又提供了4个unordered系列的关联式容器，这四个容器与红黑树结构的关联式容器使用方式基本类似，只是其底层结构不同，这里只对unordered_map和unordered_set进行介绍，unordered_multimap和unordered_multiset学生可查看文档介绍。 
 </div> 
</blockquote> 
<h3 id="1.1.unordered_set"><span style="color:#333333;">1.1.unordered_set </span></h3> 
<h4 id="1.1.1.unordered_set%E7%9A%84%E4%BB%8B%E7%BB%8D">1.1.1.unordered_set的介绍</h4> 
<blockquote> 
 <p><strong>unordered_set类的文档介绍：</strong><a href="https://legacy.cplusplus.com/reference/unordered_set/unordered_set/" rel="nofollow" title="unordered_set - C++ Reference (cplusplus.com)">unordered_set - C++ Reference (cplusplus.com)</a></p> 
 <p>注：</p> 
 <div>
   1. unordered_set是存储key值的关联式容器。 
 </div> 
 <div>
   2. 在unordered_set中，key值用于惟一地标识元素。 
 </div> 
 <div>
   3. 在内部,unordered_set没有对key按照任何特定的顺序排序, 为了能在常数范围内找到key，unordered_set将相同哈希值的key放在相同的桶中。 
 </div> 
 <div>
   4. unordered_set容器通过key访问单个元素要比set快，但它通常在遍历元素子集的范围迭代方面效率较低。 
 </div> 
 <div>
   5. 它的迭代器是前向迭代器。 
 </div> 
</blockquote> 
<h4 id="1.1.2.unordered_set%E7%9A%84%E4%BD%BF%E7%94%A8">1.1.2.unordered_set的使用</h4> 
<blockquote> 
 <p>此处只简单演示unordered_set与set的不同，其他接口与set相同，可参考set。</p> 
 <p>（1）set中的迭代器是双向迭代器，因此set中有begin、end、rbegin、rend函数。unordered_set中的迭代器是单向迭代器，因此unordered_set中有begin、end函数而没有rbegin、rend函数。</p> 
 <p>（2）set遍历访问的数据是有序的，unordered_set遍历访问的数据是无序的。</p> 
 <p>（3）set底层是红黑树，其搜索效率为<img alt="O(log_{2}^{N})" class="mathcode" src="https://images2.imgbox.com/f8/7b/AOqK3E7E_o.png">，unordered_set底层是哈希，其搜索效率为O(1)，如下面代码所示</p> 
 <p><img alt="" height="1200" src="https://images2.imgbox.com/da/98/IDOcpLbj_o.png" width="1056"></p> 
 <p>注：rand函数产生的随机数其实是有限制的，c语言rand函数有一个RAND_MAX，其最大只能产生三万多个随机数，因此如果上面的n值很大时，重复的数据是很多的，打印出来的size值（不重复的值）远小于n值。如果想让随机数变得更多可以如下图所示，给rand函数+循环变量i。</p> 
 <p><img alt="" height="183" src="https://images2.imgbox.com/1f/39/KwEsWkW8_o.png" width="739"></p> 
</blockquote> 
<p></p> 
<h3 id="1.2.unordered_map">1.2.unordered_map</h3> 
<h4 id="1.2.1.unordered_map%E7%9A%84%E4%BB%8B%E7%BB%8D">1.2.1.unordered_map的介绍</h4> 
<blockquote> 
 <div> 
  <strong>unordered_map类的文档介绍：</strong> 
  <a href="https://legacy.cplusplus.com/reference/unordered_map/unordered_map/" rel="nofollow" title="unordered_map - C++ Reference (cplusplus.com)">unordered_map - C++ Reference (cplusplus.com)</a> 
 </div> 
 <div>
   注： 
 </div> 
 <div>
   1. unordered_map是存储&lt;key, value&gt;键值对的关联式容器，其允许通过keys快速的索引到与其对应的value。 
 </div> 
 <div>
   2. 在unordered_map中，键值通常用于惟一地标识元素，而映射值是一个对象，其内容与此 
 </div> 
 <div>
   键关联。键和映射值的类型可能不同。 
 </div> 
 <div>
   3. 在内部,unordered_map没有对&lt;kye, value&gt;按照任何特定的顺序排序, 为了能在常数范围内找到key所对应的value，unordered_map将相同哈希值的键值对放在相同的桶中。 
 </div> 
 <div>
   4. unordered_map容器通过key访问单个元素要比map快，但它通常在遍历元素子集的范围迭代方面效率较低。 
 </div> 
 <div>
   5. unordered_maps实现了直接访问操作符(operator[])，它允许使用key作为参数直接访问 
 </div> 
 <div>
   value。 
 </div> 
 <div>
   6. 它的迭代器是前向迭代器。 
 </div> 
</blockquote> 
<h4 id="1.2.2.unordered_map%E7%9A%84%E4%BD%BF%E7%94%A8">1.2.2.unordered_map的使用</h4> 
<blockquote> 
 <p>此处只简单演示unordered_map与map的不同，其他接口与map相同，可参考map。</p> 
 <p>（1）map中的迭代器是双向迭代器，因此map中有begin、end、rbegin、rend函数。unordered_map中的迭代器是单向迭代器，因此unordered_map中有begin、end函数而没有rbegin、rend函数。</p> 
 <p>（2）map遍历访问的数据是有序的，unordered_map遍历访问的数据是无序的。</p> 
 <p>（3）map底层是红黑树，其搜索效率为<img alt="O(log_{2}^{N})" class="mathcode" src="https://images2.imgbox.com/f1/8f/gTNYUzLh_o.png">，unordered_map底层是哈希，其搜索效率为O(1)。 </p> 
</blockquote> 
<p></p> 
<h3 id="1.3.unordered_multiset%E5%92%8Cunordered_multimap">1.3.unordered_multiset和unordered_multimap</h3> 
<blockquote> 
 <p>unordered_multiset和multiset用法及功能基本相同，unordered_multimap和multimap用法及功能基本相同，下面讲解unordered_multiset、unordered_multimap和multiset、multimap的不同：</p> 
 <p>（1）multiset、multimap中的迭代器是双向迭代器，因此multiset、multimap中有begin、end、rbegin、rend函数。unordered_multiset、unordered_multimap中的迭代器是单向迭代器，因此unordered_multiset、unordered_multimap中有begin、end函数而没有rbegin、rend函数。</p> 
 <p>（2）multiset、multimap遍历访问的数据是有序的，unordered_multiset、unordered_multimap遍历访问的数据是无序的。</p> 
 <p>（3）multiset、multimap底层是红黑树，其搜索效率为<img alt="O(log_{2}^{N})" class="mathcode" src="https://images2.imgbox.com/d8/f5/Fc2VgEPj_o.png">，unordered_multiset、unordered_multimap底层是哈希，其搜索效率为O(1)。 </p> 
</blockquote> 
<p></p> 
<hr> 
<h2 id="2.%E5%BA%95%E5%B1%82%E7%BB%93%E6%9E%84"><span style="color:#333333;">2.</span><span style="color:#333333;">底层结构 </span></h2> 
<blockquote> 
 <div>
   unordered系列的关联式容器之所以效率比较高，是因为其底层使用了哈希结构。 
 </div> 
</blockquote> 
<h3 id="2.1.%E5%93%88%E5%B8%8C%E6%A6%82%E5%BF%B5">2.1.哈希概念</h3> 
<blockquote> 
 <div>
   顺序结构以及平衡树中，元素关键码与其存储位置之间没有对应的关系，因此在查找一个元素时，必须要经过关键码的多次比较。顺序查找时间复杂度为O(N)，平衡树中为树的高度为 
  <strong><img alt="log_{2}^{N}" class="mathcode" src="https://images2.imgbox.com/fd/20/FleaP9R3_o.png"></strong>，时间复杂度为 
  <img alt="O(log_{2}^{N})" class="mathcode" src="https://images2.imgbox.com/31/53/9RKInMmm_o.png">，搜索的效率取决于搜索过程中元素的比较次数。 
 </div> 
 <div> 
  <strong>理想的搜索方法：可以不经过任何比较，一次直接从表中得到要搜索的元素</strong>。 
 </div> 
 <div> 
  <strong>如果构造一种存储结构，通过某种函数(hashFunc)使元素的存储位置与它的关键码之间能够建立一一映射的关系，那么在查找时通过该函数可以很快找到该元素。</strong> 
 </div> 
 <div> 
  <div></div> 
  <div>
    当向该结构中： 
  </div> 
  <div> 
   <strong><img alt="\bullet" class="mathcode" src="https://images2.imgbox.com/b3/36/hi87NTts_o.png"> 插入元素 </strong> 
  </div> 
  <p>根据待插入元素的关键码，以此函数计算出该元素的存储位置并按此位置进行存放。</p> 
  <div> 
   <strong><img alt="\bullet" class="mathcode" src="https://images2.imgbox.com/92/4b/hVXMSAXD_o.png"> 搜索元素 </strong> 
  </div> 
  <p>对元素的关键码进行同样的计算，把求得的函数值当做元素的存储位置，在结构中按此位置</p> 
  <div>
    取元素比较，若关键码相等，则搜索成功。 
  </div> 
  <div> 
   <strong>该方式即为哈希(散列)方法，哈希方法中使用的转换函数称为哈希(散列)函数，构造出来的结构称为哈希表(Hash Table)(或者称散列表)</strong> 
  </div> 
  <div> 
   <div></div> 
   <div>
     例如：数据集合{1，7，6，4，5，9}； 
   </div> 
   <div>
     哈希函数设置为：hash(key) = key % capacity; capacity为存储元素底层空间总的大小。 
   </div> 
   <div> 
    <img alt="" height="181" src="https://images2.imgbox.com/d5/ae/eGIPkx1X_o.png" width="506"> 
   </div> 
   <p><strong>用该方法进行搜索不必进行多次关键码的比较，因此搜索的速度比较快 </strong></p> 
   <p>问题：按照上述哈希方式，向集合中插入元素44，会出现什么问题？</p> 
  </div> 
 </div> 
</blockquote> 
<p id=""></p> 
<h3 id="2.2.%E5%93%88%E5%B8%8C%E5%86%B2%E7%AA%81"><span style="color:#333333;">2.2.</span><span style="color:#333333;">哈希冲突 </span></h3> 
<blockquote> 
 <div> 
  <div>
    对于两个数据元素的关键字ki和kj(i!=j)，有ki!= kj，但有：Hash(ki)==Hash(kj)，即： 
   <strong>不同关键字通过相同哈希哈数计算出相同的哈希地址，该种现象称为哈希冲突或哈希碰撞</strong>。 
  </div> 
  <div> 
   <strong>把具有不同关键码而具有相同哈希地址的数据元素称为“同义词”</strong>。 
  </div> 
  <div>
    发生哈希冲突该如何处理呢？ 
  </div> 
 </div> 
</blockquote> 
<p></p> 
<h3 id="2.3.%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0"><span style="color:#333333;">2.3.</span><span style="color:#333333;">哈希函数</span></h3> 
<blockquote> 
 <div>
   引起哈希冲突的一个原因可能是： 
  <strong>哈希函数设计不够合理</strong>。 
 </div> 
 <div> 
  <strong>哈希函数设计原则</strong>： 
 </div> 
 <div> 
  <strong><strong><img alt="\bullet" class="mathcode" src="https://images2.imgbox.com/0b/fb/ob5rBo4p_o.png"></strong> </strong>哈希函数的定义域必须包括需要存储的全部关键码，而如果散列表允许有m个地址时，其值域必须在0到m-1之间 
 </div> 
 <div> 
  <strong><strong><img alt="\bullet" class="mathcode" src="https://images2.imgbox.com/a5/0d/h7HEOv6a_o.png"></strong> </strong>哈希函数计算出来的地址能均匀分布在整个空间中 
 </div> 
 <div> 
  <strong><strong><img alt="\bullet" class="mathcode" src="https://images2.imgbox.com/64/23/sO9Q1i7e_o.png"></strong> </strong>哈希函数应该比较简单 
 </div> 
</blockquote> 
<blockquote> 
 <div> 
  <strong>常见哈希函数：</strong> 
 </div> 
 <div> 
  <strong>1.直接定址法(常用) </strong> 
 </div> 
 <div>
   取关键字的某个线性函数为散列地址：Hash（Key）= A*Key + B 
 </div> 
 <div>
   优点：简单、均匀 
 </div> 
 <div>
   缺点：需要事先知道关键字的分布情况 
 </div> 
 <div>
   使用场景：适合查找比较小且连续的情况 
 </div> 
 <div>
   面试题： 
  <a href="https://leetcode.cn/problems/first-unique-character-in-a-string/" rel="nofollow" title="387. 字符串中的第一个唯一字符 - 力扣（LeetCode）">387. 字符串中的第一个唯一字符 - 力扣（LeetCode）</a> 
 </div> 
 <div></div> 
 <div> 
  <strong>2.除留余数法(常用) </strong> 
 </div> 
 <div>
   设散列表中允许的地址数为m，取一个不大于m，但最接近或者等于m的质数p作为除数， 
 </div> 
 <div>
   按照哈希函数：Hash(key) = key%p(p&lt;=m),将关键码转换成哈希地址 
 </div> 
 <div></div> 
 <div> 
  <strong>3.平方取中法(了解) </strong> 
 </div> 
 <div>
   假设关键字为1234，对它平方就是1522756，抽取中间的3位227作为哈希地址； 
 </div> 
 <div>
   再比如关键字为4321，对它平方就是18671041，抽取中间的3位671(或710)作为哈希地址 
 </div> 
 <div>
   平方取中法比较适合：不知道关键字的分布，而位数又不是很大的情况 
 </div> 
 <div></div> 
 <div> 
  <strong>4.折叠法(了解) </strong> 
 </div> 
 <div>
   折叠法是将关键字从左到右分割成位数相等的几部分(最后一部分位数可以短些)，然后将这 
 </div> 
 <div>
   几部分叠加求和，并按散列表表长，取后几位作为散列地址。 
 </div> 
 <div>
   折叠法适合事先不需要知道关键字的分布，适合关键字位数比较多的情况 
 </div> 
 <div></div> 
 <div> 
  <strong>5.随机数法(了解) </strong> 
 </div> 
 <div>
   选择一个随机函数，取关键字的随机函数值为它的哈希地址，即H(key) = random(key),其中 
 </div> 
 <div>
   random为随机数函数。 
 </div> 
 <div>
   通常应用于关键字长度不等时采用此法 
 </div> 
 <div></div> 
 <div> 
  <strong>6.数学分析法(了解) </strong> 
 </div> 
 <div>
   设有n个d位数，每一位可能有r种不同的符号，这r种不同的符号在各位上出现的频率不一定 
 </div> 
 <div>
   相同，可能在某些位上分布比较均匀，每种符号出现的机会均等，在某些位上分布不均匀只 
 </div> 
 <div>
   有某几种符号经常出现。可根据散列表的大小，选择其中各种符号分布均匀的若干位作为散 
 </div> 
 <div>
   列地址。例如： 
 </div> 
 <div> 
  <img alt="" height="219" src="https://images2.imgbox.com/7a/98/Z3AUSEiU_o.png" width="252"> 
 </div> 
 <div>
   假设要存储某家公司员工登记表，如果用手机号作为关键字，那么极有可能前7位都是 相同 
 </div> 
 <div>
   的，那么我们可以选择后面的四位作为散列地址，如果这样的抽取工作还容易出现 冲突，还 
 </div> 
 <div>
   可以对抽取出来的数字进行反转(如1234改成4321)、右环位移(如1234改成4123)、左环移 
 </div> 
 <div>
   位、前两数与后两数叠加(如1234改成12+34=46)等方法。 
 </div> 
 <div>
   数字分析法通常适合处理关键字位数比较大的情况，如果事先知道关键字的分布且关键字的 
 </div> 
 <div>
   若干位分布较均匀的情况 
 </div> 
 <div></div> 
 <div> 
  <strong>注意：哈希函数设计的越精妙，产生哈希冲突的可能性就越低，但是无法避免哈希冲突</strong> 
 </div> 
</blockquote> 
<p></p> 
<h3 id="2.4.%E5%93%88%E5%B8%8C%E5%86%B2%E7%AA%81%E8%A7%A3%E5%86%B3"><span style="color:#333333;">2.4.</span><span style="color:#333333;">哈希冲突解决 </span></h3> 
<blockquote> 
 <div> 
  <strong>解决哈希冲突</strong>两种常见的方法是： 
  <strong>闭散列</strong>和 
  <strong>开散列</strong> 
 </div> 
</blockquote> 
<h4 id="2.4.1.%E9%97%AD%E6%95%A3%E5%88%97">2.4.1.闭散列</h4> 
<blockquote> 
 <div> 
  <strong>闭散列：也叫开放定址法，当发生哈希冲突时，如果哈希表未被装满，说明在哈希表中必然还有空位置，那么可以把key存放到冲突位置中的“下一个”空位置中去。</strong>那如何寻找下一个空位置呢？有 
  <strong>线性探测</strong>和 
  <strong>二次探测</strong>两种方法。 
 </div> 
</blockquote> 
<blockquote> 
 <div> 
  <strong>1. 线性探测</strong> 
 </div> 
 <div> 
  <div>
    比如2.1中的场景，现在需要插入元素44，先通过哈希函数计算哈希地址，hashAddr为4， 
  </div> 
  <div>
    因此44理论上应该插在该位置，但是该位置已经放了值为4的元素，即发生哈希冲突。 
  </div> 
  <div> 
   <strong>线性探测：从发生冲突的位置开始，依次向后探测，直到寻找到下一个空位置为止</strong>。 
  </div> 
  <div> 
   <div> 
    <strong>线性探测</strong> 
    <strong>找下一个空位置的方法</strong> 
    <strong>为：Hi= (H0+i)%m 或者 Hi=(H0-i)%m，其中：i = </strong> 
    <strong>1,2,3…，H0是通过散列函数Hash(x)对元素的关键码key进行计算得到的位置，m是表</strong> 
    <strong>的大小。</strong> 
   </div> 
   <div></div> 
   <div> 
    <strong>插入：</strong> 
   </div> 
   <div> 
    <div> 
     <strong><strong><strong><strong><img alt="\bullet" class="mathcode" src="https://images2.imgbox.com/60/32/swNZETwK_o.png"></strong></strong></strong> </strong>通过哈希函数获取待插入元素在哈希表中的位置 
    </div> 
    <div> 
     <strong><strong><strong><strong><img alt="\bullet" class="mathcode" src="https://images2.imgbox.com/9a/24/Fat6Vipf_o.png"></strong></strong></strong> </strong>如果该位置中没有元素则直接插入新元素，如果该位置中有元素发生哈希冲突，使用线性探测找到下一个空位置，插入新元素 
    </div> 
   </div> 
   <div> 
    <img alt="" height="201" src="https://images2.imgbox.com/88/2c/hbVhk4IP_o.png" width="552"> 
   </div> 
   <div></div> 
   <div> 
    <strong>线性探测优点：</strong>实现非常简单 
   </div> 
   <div> 
    <strong>线性探测缺点：</strong>一旦发生哈希冲突，所有的冲突连在一起，容易产生数据“堆积”，即不同 
   </div> 
   <div>
     关键码占据了可利用的空位置，使得寻找某关键码的位置需要许多次比较，导致搜索效率降 
   </div> 
   <div>
     低。如何缓解呢？使用二次探测可以缓解。 
   </div> 
  </div> 
 </div> 
</blockquote> 
<blockquote> 
 <div> 
  <strong>2. 二次探测</strong> 
 </div> 
 <div>
   线性探测的缺陷是产生冲突的数据堆积在一块，这与其找下一个空位置有关系，因为找空位 
 </div> 
 <div> 
  <div>
    置的方式就是挨着往后逐个去找，因此二次探测为了避免该问题。 
  </div> 
  <div> 
   <strong>二次探测</strong> 
   <strong>：从发生冲突的位置开始，跳跃向后探测，直到寻找到下一个空位置为止</strong>。 
  </div> 
  <div> 
   <strong>二次探测找下一个空位置的方法</strong> 
   <strong>为：Hi= (H0+i^2)%m 或者 Hi=(H0-i^2)%m，其中：i = </strong> 
   <strong>1,2,3…，H0是通过散列函数Hash(x)对元素的关键码key进行计算得到的位置，m是表</strong> 
   <strong>的大小。 </strong> 
  </div> 
  <div> 
   <div></div> 
   <div> 
    <strong>插入：</strong> 
   </div> 
   <div> 
    <div> 
     <strong><strong><strong><strong><strong><strong><strong><strong><img alt="\bullet" class="mathcode" src="https://images2.imgbox.com/aa/da/Lae32vqO_o.png"></strong></strong></strong></strong></strong></strong></strong> </strong>通过哈希函数获取待插入元素在哈希表中的位置 
    </div> 
    <div> 
     <strong><strong><strong><strong><strong><strong><strong><strong><img alt="\bullet" class="mathcode" src="https://images2.imgbox.com/e7/f8/Wb2FXdtJ_o.png"></strong></strong></strong></strong></strong></strong></strong> </strong>如果该位置中没有元素则直接插入新元素，如果该位置中有元素发生哈希冲突，使用二次探测找到下一个空位置，插入新元素 
    </div> 
   </div> 
  </div> 
 </div> 
 <div> 
  <img alt="" height="309" src="https://images2.imgbox.com/44/69/eqhWWPzM_o.png" width="860"> 
 </div> 
 <div></div> 
 <div> 
  <strong>二次探测的优缺点：</strong>二次探测相对线性探测而言减轻了产生数据的“堆积”，但是其本质还是让不同的关键码占据了本属于其他关键码的位置，这样哈希冲突越多，搜索效率还是会降低。 
 </div> 
</blockquote> 
<blockquote> 
 <div> 
  <strong>基于线性探测和</strong> 
  <strong>二次探测的哈希表</strong> 
  <strong>代码实现</strong> 
 </div> 
 <div> 
  <strong>HashTable.h文件：</strong> 
 </div> 
 <div> 
  <pre><code class="language-cpp">#pragma once
#include&lt;vector&gt;

namespace CloseHash
{
	enum State
	{
		EMPTY,
		EXITS,
		DELETE
	};

	template&lt;class K, class V&gt;
	struct HashData
	{
		pair&lt;K, V&gt; _kv;
		State _state = EMPTY;
	};

	template&lt;class K&gt;
	struct DefaultHash
	{
		size_t operator()(const K&amp; key)
		{
			return (size_t)key;
		}
	};

	template&lt;&gt;
	struct DefaultHash&lt;string&gt;
	{
		size_t operator()(const string&amp; key)
		{
			// BKDR
			size_t hash = 0;
			for (auto ch : key)
			{
				hash = hash * 131 + ch;
			}

			return hash;
		}
	};

	template&lt;class K, class V, class HashFunc = DefaultHash&lt;K&gt;&gt;
	class HashTable
	{
		typedef HashData&lt;K, V&gt; Data;
	public:
		bool Insert(const pair&lt;K, V&gt;&amp; kv)
		{
			if (Find(kv.first))
			{
				return false;
			}

			// 负载因子到0.7及以上，就扩容
			if (_tables.size() == 0 || _n * 10 / _tables.size() &gt;= 7)
			{
				size_t newSize = _tables.size() == 0 ? 10 : _tables.size() * 2;
				// 扩容以后，需要重新映射
				HashTable&lt;K, V, HashFunc&gt; newHT;
				newHT._tables.resize(newSize);
				// 遍历旧表，插入newHT
				for (auto&amp; e : _tables)
				{
					if (e._state == EXITS)
					{
						newHT.Insert(e._kv);
					}
				}
				newHT._tables.swap(_tables);
			}

			HashFunc hf;
			size_t starti = hf(kv.first);
			starti %= _tables.size();

			size_t hashi = starti;
			size_t i = 1;
			// 线性探测/二次探测
			while (_tables[hashi]._state == EXITS)
			{
				hashi = starti + i;
				++i;
				hashi %= _tables.size();
			}

			_tables[hashi]._kv = kv;
			_tables[hashi]._state = EXITS;
			_n++;

			return true;
		}

		Data* Find(const K&amp; key)
		{
			if (_tables.size() == 0)
			{
				return nullptr;
			}

			HashFunc hf;
			size_t starti = hf(key);
			starti %= _tables.size();

			size_t hashi = starti;
			size_t i = 1;
			while (_tables[hashi]._state != EMPTY)
			{
				if (_tables[hashi]._state != DELETE &amp;&amp; _tables[hashi]._kv.first == key)
				{
					return &amp;_tables[hashi];
				}

				hashi = starti + i;
				++i;
				hashi %= _tables.size();
			}

			return nullptr;
		}

		bool Erase(const K&amp; key)
		{
			Data* ret = Find(key);
			if (ret)
			{
				ret-&gt;_state = DELETE;
				--_n;
				return true;
			}
			else
			{
				return false;
			}
		}

	private:
		vector&lt;Data&gt; _tables;
		size_t _n = 0; // 存储关键字个数
	};
}
</code></pre> 
  <p><strong>注：</strong></p> 
 </div> 
 <div>
   1.查找元素x时，首先通过哈希函数获取待插入元素在哈希表中的位置，如果该位置是元素x则找到了，如果该位置不是元素x，则使用对应的探索方式（线性探索或二次探测）依次往后找下一个位置是否是x，如果某一次找到的位置是x则找到了，如果某一次找到的位置是空则找不到。 
 </div> 
 <div>
   2.采用闭散列处理哈希冲突时，不能随便物理删除哈希表中已有的元素，若直接删除元素会影响其他元素的搜索。如下图一所示，删除元素4，如果直接删除掉，后面44查找起来可能会受影响。因此应该采用标记的伪删除法来删除一个元素，如下图二所示一个元素有三种状态，要删除某个元素时只改变该元素的状态为DELETE，不删除该元素。 
 </div> 
 <div> 
  <img alt="" height="82" src="https://images2.imgbox.com/48/b7/fXc20ufO_o.png" width="393">  
  <img alt="" height="269" src="https://images2.imgbox.com/51/24/27alfYZG_o.png" width="244"> 
 </div> 
 <p>3.如下图所示，在插入函数中，我们使用无符号整型starti来获取对应的值，进而通过哈希函数计算得到要插入的位置。这里哈希函数中，应该用starti去模顺序表vector的size而不是capacity，因为顺序表vector是不能在大于size的位置插入数据的，如果是starti模capacity，得到的结果刚好大于size，是无法插入的。</p> 
 <p>在插入时，如果哈希函数计算得到位置的状态为空EMPTY或者删除DELETE时，可以进行插入，如果哈希函数计算得到位置的状态为存在EXITS时，则继续探索下一个位置，直到探索到的位置状态为空或删除时再进行插入。</p> 
 <p><img alt="" height="318" src="https://images2.imgbox.com/cd/4c/fQ88hsx2_o.png" width="372"></p> 
 <div>
   思考：哈希表什么情况下进行扩容？如何扩容？ 
 </div> 
 <p><img alt="" height="288" src="https://images2.imgbox.com/33/40/tFBYDqIW_o.png" width="1200"></p> 
 <p>哈希表HashTable类中，我们利用成员变量_n来记录存储关键字的个数，每次插入一个元素对成员变量_n++，如果_n除以哈希表_tables的大小大于等于0.7则进行扩容。</p> 
 <p>代码_n/_tables.size()&gt;=0.7是有问题的，因为_n和_tables.size()的返回值都是无符号整型的，应该将其强转成浮点型，这里我们不强转，可以用代码_n*10/_tables.size()&gt;=7间接实现该功能。</p> 
 <p>哈希表的扩容不是简单的进行扩容，而是应该根据要扩容的大小重新创建一个vector，根据新vector的size大小即扩容后的大小，重新计算原来每一个元素的位置并插入到新vector中，然后释放旧vector。</p> 
 <p>这里我们可以使用一种简单的方式来实现，创建一个新的哈希表HashTable类对象，遍历旧的vector，将遍历到的每个数据插入到新的哈希表HashTable类对象中，这样在插入的过程中就自动根据扩容后的大小算好了旧表元素在新表中的位置并进行插入操作。最后将新哈希表HashTable类中的vector和我们本身的vector进行交换即可，代码如下图所示。</p> 
 <p><img alt="" height="543" src="https://images2.imgbox.com/13/54/LWg895Rb_o.png" width="459"></p> 
 <p>上面的插入函数代码没有去除数据冗余，适合于multiset和multimap类，在插入时我们可以复用find函数去除数据冗余，这样就适合于set和map类，如下图所示。</p> 
 <p><img alt="" height="601" src="https://images2.imgbox.com/10/1e/yGLyJ9fF_o.png" width="480"></p> 
 <p>4.根据哈希表HashTable插入函数的特点，我们可以知道，哈希表的插入函数效率变化图应该类似于下图所示，正常情况下插入的很快，当某一次插入需要扩容时，效率变得很慢，因为这里扩容不仅仅是空间上进行扩容，每个元素还需要重新进行映射位置，因此时间上也会有损耗。</p> 
 <p><img alt="" height="153" src="https://images2.imgbox.com/70/3c/YXqNKEcI_o.png" width="338"></p> 
 <p>这就是前面验证set和unordered_set插入、查找、删除效率时，当重复数据多时unordered_set插入效率很高、当重复数据少时unordered_set插入效率低的原因。因为重复数据多时数据量小扩容少，重复数据多时，数据量大扩容多。</p> 
 <p>5.哈希表HashTable的find查找函数首先通过哈希函数计算出查找数据的位置，如果该位置元素状态不是空并且是要查找的数据则返回该元素的地址，如果该位置元素状态不是空但不是要查找的数据，则依次探索下一个位置，直到探索到某元素状态不是空并且是要查找的数据，返回该元素地址，如果遇到探索位置元素状态为空，则没有要查找的元素返回空指针，代码如下图所示。</p> 
 <p><img alt="" height="330" src="https://images2.imgbox.com/08/f6/B3NoR1gG_o.png" width="352"></p> 
 <p>上面的代码还有两个问题。第一个问题，如果哈希表为空即_table.size=0，则有starti模0的问题。第二个问题是删除的元素还能被找到，因此我们还需要加一个元素状态不为DELETE的判断。解决两个问题的find函数改进代码如下图所示。</p> 
 <p><img alt="" height="340" src="https://images2.imgbox.com/20/f5/Lxkksehv_o.png" width="501"></p> 
 <p>6.哈希表HashTable的erase删除函数只需要复用find函数找到要删除的元素位置，如果找到了要删除的元素位置则将该元素的状态改为DELET进行伪删除并返回true，如果没找到要删除的元素位置则返回false，如下图所示。</p> 
 <p><img alt="" height="232" src="https://images2.imgbox.com/92/ac/KtYSfLRE_o.png" width="227"></p> 
 <p>7.哈希表HashTable的模板参数K和V的类型不确定，也就是哈希表存储的键值对数据pair的first和second数据类型不确定。参数K的类型不确定，如果我们直接使用size_t starti = kv.first获取插入的值，然后哈希函数计算位置，这样只适合于整型，面对字符串、自定义对象或更复杂的情况如何解决呢？</p> 
 <p>在哈希表HashTable的模板参数中传一个仿函数类来解决，那么使用者使用哈希表HashTable什么类型的模板参数K，就传对应类型的仿函数类即可，如下图所示。仿函数类对象实现把key元素转换成映射的整数，其中不同的元素尽可能转换成不同的整数（如果不同的元素转换成了相同的整数，那么就会造成访问冲突，访问冲突越多哈希表效率越低）。</p> 
 <p><img alt="" height="97" src="https://images2.imgbox.com/be/a1/LlCR5nzo_o.png" width="478"></p> 
 <p>我们使用DefaultHash仿函数类作为默认的仿函数类解决参数K为整型的情况如下图所示，如果参数K为整型直接返回对应的整型值即可。</p> 
 <p><img alt="" height="134" src="https://images2.imgbox.com/f2/af/6mf5HbjU_o.png" width="275"></p> 
 <p>我们使用StringHash仿函数类解决参数K为string类的情况如下图一所示，如果参数K为string类，将字符串每个字符的ASCII码加起来进行返回即可。</p> 
 <p>博客：<a href="https://www.cnblogs.com/-clq/archive/2012/05/31/2528153.html" rel="nofollow" title="各种字符串Hash函数 - clq - 博客园 (cnblogs.com)">各种字符串Hash函数 - clq - 博客园 (cnblogs.com)</a>中提到了很多种更加优秀的匹配string类的仿函数，降低了不同元素转换成相同整数的可能，减少了访问冲突。我们使用其中《The C Programming Language》的方案，如下图二所示。</p> 
 <p><img alt="" height="208" src="https://images2.imgbox.com/b1/7a/BCu6hDmw_o.png" width="303"> <img alt="" height="209" src="https://images2.imgbox.com/31/c2/ep0B92ro_o.png" width="304"></p> 
 <p>如果是Student类，仿函数类可以返回学号、身份证、电话号码等，如果没有这些唯一项信息，可以多项拼接，例如班级+名字。</p> 
 <p>8.库里面的unorder_set、unorder_map、unorder_multiset、unorder_multimap即使是sring类也不需要显式的传仿函数类，如下图一所示，这是因为源代码对默认的仿函数类DefaultHash进行了特化，如下图所示二。</p> 
 <p><img alt="" height="173" src="https://images2.imgbox.com/56/cd/4zCh5MUr_o.png" width="335"><img alt="" height="381" src="https://images2.imgbox.com/0e/90/a1oOiJRy_o.png" width="306"></p> 
 <p>9.哈希表HashTable类中不需要专门去写构造函数、析构函数、拷贝构造函数、赋值运算符重载函数。</p> 
</blockquote> 
<blockquote> 
 <div> 
  <div>
    补充内容：研究表明当表的长度为质数且表装载因子a不超过0.5时，新的表项一定能够插入，而且任何一个位置都不会被探查两次。因此只要表中有一半的空位置，就不会存在表满的问题。在搜索时可以不考虑表装满的情况，但在插入时必须确保表的装载因子a不超过0.5，如果超出必须考虑增容。 
  </div> 
 </div> 
 <div>
   因此：闭散列最大的缺陷就是空间利用率比较低，这也是哈希的缺陷。 
 </div> 
</blockquote> 
<p></p> 
<h4 id="2.4.2%20%E5%BC%80%E6%95%A3%E5%88%97">2.4.2 开散列</h4> 
<blockquote> 
 <div> 
  <strong>1. 开散列概念 </strong> 
 </div> 
 <div>
   开散列法又叫链地址法(开链法)（哈希桶），首先对关键码集合用散列函数计算散列地址，具有相同地址的关键码归于同一子集合，每一个子集合称为一个桶，各个桶中的元素通过一个单链表链接起来，各链表的头结点存储在哈希表中。 
 </div> 
 <div>
   如下图所示，数据不存在哈希表中，哈希表中存储的是链表指针，冲突的数据以链表的形式挂起来。开散列中每个桶中放的都是发生哈希冲突的元素。 
 </div> 
 <div> 
  <img alt="" height="418" src="https://images2.imgbox.com/b5/66/aRjVU38f_o.png" width="1039"> 
 </div> 
 <p>开散列中使用单链表即可，因为每个桶中的元素顺序没有要求，每次插入元素头插即可，并且单链表中少存一个指针，空间占有更少。</p> 
</blockquote> 
<blockquote> 
 <div> 
  <strong>2. 开散列实现</strong> 
 </div> 
 <div> 
  <strong>HashTable.h文件：</strong> 
 </div> 
 <div> 
  <pre><code class="language-cpp">#pragma once
#include&lt;vector&gt;

template&lt;class K&gt;
struct DefaultHash
{
	size_t operator()(const K&amp; key)
	{
		return (size_t)key;
	}
};


template&lt;&gt;
struct DefaultHash&lt;string&gt;
{
	size_t operator()(const string&amp; key)
	{
		// BKDR
		size_t hash = 0;
		for (auto ch : key)
		{
			hash = hash * 131 + ch;
		}

		return hash;
	}
};

namespace Bucket
{
	template&lt;class K, class V&gt;
	struct HashNode
	{
		pair&lt;K, V&gt; _kv;
		HashNode&lt;K, V&gt;* _next;

		HashNode(const pair&lt;K, V&gt;&amp; kv)
			:_kv(kv)
			, _next(nullptr)
		{}
	};

	template&lt;class K, class V, class HashFunc = DefaultHash&lt;K&gt;&gt;
	class HashTable
	{
		typedef HashNode&lt;K, V&gt; Node;
	public:
		~HashTable()
		{
			for (size_t i = 0; i &lt; _tables.size(); ++i)
			{
				Node* cur = _tables[i];
				while (cur)
				{
					Node* next = cur-&gt;_next;
					delete cur;
					cur = next;
				}

				_tables[i] = nullptr;
			}
		}

		bool Insert(const pair&lt;K, V&gt;&amp; kv)
		{
			if (Find(kv.first))
			{
				return false;
			}

			HashFunc hf;

			// 负载因子 == 1 扩容
			if (_tables.size() == _n)
			{
				size_t newSize = _tables.size() == 0 ? 10 : _tables.size() * 2;
				vector&lt;Node*&gt; newTable;
				newTable.resize(newSize, nullptr);
				for (size_t i = 0; i &lt; _tables.size(); ++i)
				{
					Node* cur = _tables[i];
					while (cur)
					{
						Node* next = cur-&gt;_next;

						size_t hashi = hf(cur-&gt;_kv.first) % newSize;
						cur-&gt;_next = newTable[hashi];
						newTable[hashi] = cur;

						cur = next;
					}

					_tables[i] = nullptr;
				}

				newTable.swap(_tables);
			}

			size_t hashi = hf(kv.first);
			hashi %= _tables.size();

			// 头插到对应的桶即可
			Node* newnode = new Node(kv);
			newnode-&gt;_next = _tables[hashi];
			_tables[hashi] = newnode;

			++_n;

			return true;
		}

		Node* Find(const K&amp; key)
		{
			if (_tables.size() == 0)
			{
				return nullptr;
			}

			HashFunc hf;
			size_t hashi = hf(key);
			//size_t hashi = HashFunc()(key);

			hashi %= _tables.size();
			Node* cur = _tables[hashi];
			while (cur)
			{
				if (cur-&gt;_kv.first == key)
				{
					return cur;
				}

				cur = cur-&gt;_next;
			}

			return nullptr;
		}

		bool Erase(const K&amp; key)
		{
			if (_tables.size() == 0)
			{
				return false;
			}

			HashFunc hf;
			size_t hashi = hf(key);
			hashi %= _tables.size();
			Node* prev = nullptr;
			Node* cur = _tables[hashi];
			while (cur)
			{
				if (cur-&gt;_kv.first == key)
				{
					if (prev == nullptr)
					{
						_tables[hashi] = cur-&gt;_next;
					}
					else
					{
						prev-&gt;_next = cur-&gt;_next;
					}

					delete cur;

					return true;
				}

				prev = cur;
				cur = cur-&gt;_next;
			}

			return false;
		}

	private:
		// 指针数组
		vector&lt;Node*&gt; _tables;
		size_t _n = 0;
	};
}
</code></pre> 
  <p><strong>注：</strong></p> 
 </div> 
 <div>
   1.开散列哈希表的insert插入函数，也是首先通过哈希函数计算出要插入元素的位置，如果哈希表vector中该位置桶不为空，则新元素节点头插到该桶中即可，如果哈希表vector中该位置桶为空，则让哈希表vector中该位置桶指针指向新元素节点，新元素节点指向空即可。其实上面两种情况可以用同一段代码解决，如下图所示。 
 </div> 
 <div> 
  <img alt="" height="408" src="https://images2.imgbox.com/2b/c8/Owuv4GUR_o.png" width="362"> 
 </div> 
 <div>
   开散列的哈希表也需要扩容，如果开散列哈希表不扩容，那么可能存在大量的哈希冲突，每个桶中的链表过长影响效率。开散列的哈希表负载因子可以大一点（负载因子小冲突概率小时间效率高空间效率低，负载因子大冲突概率大时间效率低空间效率高），因为开散列处理哈希冲突直接头插即可效率较高，我们取负载因子为1，下面代码当_tables.size()==_n时扩容，就相当于负载因子为1时扩容。扩容方式可以采取和闭散列相同的扩容方式，如下图所示。 
 </div> 
 <p><img alt="" height="624" src="https://images2.imgbox.com/12/17/XlPpdEEU_o.png" width="472"></p> 
 <p>上面这种开散列扩容方式和闭散列扩容方式相同，但是开散列使用这种方式是有缺陷的，开散列使用这种方式那么之前哈希表每个桶中的节点将被释放掉不再使用，然后创建完全相同的节点挂在新的哈希表上。我们在扩容的时候其实不需要创建新的节点而是使用原本的节点即可，如下图所示。</p> 
 <div> 
  <img alt="" height="641" src="https://images2.imgbox.com/b4/93/MWEHewXb_o.png" width="506"> 
 </div> 
 <p>2.开散列哈希表的find查找函数，首先通过哈希函数计算出要插入元素的位置，然后遍历该位置的桶中是否有要找元素，找到对应元素返回该元素节点指针，如果没有找到则返回空指针。如果哈希表最开始里面没有数据时，返回空指针，如下图所示。</p> 
 <div> 
  <img alt="" height="326" src="https://images2.imgbox.com/21/22/AN8ZcZ2U_o.png" width="239"> 
 </div> 
 <p>3.开散列哈希表的~HashTable析构函数，开散列哈希表需要显式的写析构函数，因为如果使用系统自动生成的析构函数，那么系统会去自动调用vector的析构函数释放指针数组成员变量_tables，但是每个桶中的节点空间并不会自动去释放，造成空间泄漏。因此我们应该显式的写析构函数将每个桶中节点空间释放掉。这样自己写的析构函数将桶结点空间释放掉，系统自动调用vector析构函数将指针数组成员变量_tables空间释放掉。</p> 
 <p><img alt="" height="265" src="https://images2.imgbox.com/66/2f/Z6OFG2Li_o.png" width="378"></p> 
 <p>4.开散列哈希表的Erase删除函数，其正常代码实现如下图所示。</p> 
 <p><img alt="" height="576" src="https://images2.imgbox.com/77/0a/gchp95k9_o.png" width="360"></p> 
 <p>5.开散列哈希表的构造函数不需要显式的写，析构函数需要显式的写，拷贝构造函数和赋值运算符重载函数需要显示的写进行深拷贝（如果不写会调用vector的拷贝构造和赋值运算符重载，vector的拷贝构造和赋值运算符重载是深拷贝，vector里面的数据如果是自定义类型，就会去调用对应的拷贝构造函数，这里vector里面的数据是node*类型，也就是指针类型，是内置类型，对于内置类型vector的拷贝构造和赋值运算符重载是进行浅拷贝，那么拷贝的vector和原vector中的指针数据会指向同一个桶）。这里开散列哈希表的拷贝构造函数和赋值运算符重载函数实现我们不再赘述。</p> 
 <p>6.和闭散列相同，为了让开散列哈希表支持字符串、自定义对象或更复杂的情况，我们增加一个开散列哈希表HashTable模板参数HashFunc，其缺省值给成DefaultHash&lt;K&gt;，如下图所示。</p> 
 <p><img alt="" height="95" src="https://images2.imgbox.com/94/e2/26dwHe2y_o.png" width="511"></p> 
 <p>和闭散列相同，使用DefaultHash仿函数类作为默认的仿函数类，解决参数K为整型的情况，特化一个版本来解决参数K为string类的情况，这里不再赘述。</p> 
</blockquote> 
<p></p> 
<div> 
 <hr> 
 <h2 id="3.%E5%93%88%E5%B8%8C%E5%BC%80%E6%95%A3%E5%88%97%E6%A8%A1%E6%8B%9F%E5%AE%9E%E7%8E%B0STL%E4%B8%AD%E7%9A%84unordered_map%E4%B8%8Eunordered_set">3.哈希开散列模拟实现STL中的unordered_map与unordered_set</h2> 
</div> 
<h3 id="3.1.%E5%B0%81%E8%A3%85%E7%BA%A2%E9%BB%91%E6%A0%91%E4%BB%A3%E7%A0%81%EF%BC%8C%E5%90%8C%E6%97%B6%E5%AE%9E%E7%8E%B0map%E5%92%8Cset">3.1.封装开散列代码，同时实现unordered_map和unordered_set</h3> 
<blockquote> 
 <p><strong>将<span style="color:#333333;">开散列</span>进行封装，使之可以同时实现<span style="color:#333333;">unordered_map和unordered_set</span></strong></p> 
 <p>这里与对红黑树RBTree进行封装，使之可以同时实现map和set的思路相同。我们将开散列哈希表中每个桶节点HashNode的数据泛化成其模板参数T类型的成员变量_data，开散列哈希表HashTable的模板参数改为K、T和HashFunc，如下图一所示。</p> 
 <p>如果是<span style="color:#333333;">unordered_map，那么哈希表</span>HashTable的第一个模板参数传K，第二个模板参数传pair&lt;K,V&gt;。如果是<span style="color:#333333;">unordered_set，那么哈希表</span>HashTable的第一个模板参数传K，第二个模板参数传K。</p> 
 <p><img alt="" height="487" src="https://images2.imgbox.com/98/24/zAvdJifO_o.png" width="1200"></p> 
 <p></p> 
 <p>在<span style="color:#333333;">unordered_map和unordered_set中，使用</span>开散列哈希表HashTable创建对象，除了第一个模板参数和第二个模板参数传对应的类型外，还需要传MapKeyOfT和SetKeyOfT仿函数类作为key值提取函数，哈希表HashTable的模板参数也同时加上一个KeyOfT参数来获取仿函数类如下图所示。</p> 
 <p><img alt="" height="689" src="https://images2.imgbox.com/52/ed/YymBDPqQ_o.png" width="1200"></p> 
 <p></p> 
 <p>哈希表HashTable的模板参数HashFunc是一个仿函数类，默认传的是DefaultHash仿函数类，解决K是整型的情况，还有一个特化版本，解决K是string类的情况。如果K是自定义类型的，例如是日期Date类型的，就需要我们自己去传仿函数类给哈希表的模板HashFunc参数。</p> 
 <p>但是我们使用时只能给<span style="color:#333333;">unordered_map和unordered_set传模板参数而无法直接给</span>哈希表HashTable传模板参数，所以我们应该给<span style="color:#333333;">unordered_map和unordered_set加一个模板参数</span>HashFunc来获取用户传的哈希函数，然后<span style="color:#333333;">unordered_map和unordered_set内部调用</span>哈希表HashTable时再将用户传的哈希函数传给哈希表HashTable即可，如下图所示。</p> 
 <p><img alt="" height="1200" src="https://images2.imgbox.com/08/a4/EvXJGo6W_o.png" width="1200"></p> 
</blockquote> 
<p></p> 
<h3 id="3.2.%E5%BC%80%E6%95%A3%E5%88%97%E5%93%88%E5%B8%8C%E8%A1%A8%E7%9A%84%E8%BF%AD%E4%BB%A3%E5%99%A8">3.2.开散列哈希表的迭代器</h3> 
<blockquote> 
 <p><strong>unordered_set类代码：</strong></p> 
 <pre><code class="language-cpp">#pragma once

#include "HashTable.h"

namespace bit
{
	template&lt;class K, class HashFunc = DefaultHash&lt;K&gt;&gt;
	class unordered_set
	{
		struct SetKeyOfT
		{
			const K&amp; operator()(const K&amp; key)
			{
				return key;
			}
		};
	public:
		typedef typename Bucket::HashTable&lt;K, K, SetKeyOfT, HashFunc&gt;::iterator iterator;

		iterator begin()
		{
			return _ht.begin();
		}

		iterator end()
		{
			return _ht.end();
		}

		pair&lt;iterator, bool&gt; insert(const K&amp; key)
		{
			return _ht.Insert(key);
		}

		iterator find(const K&amp; key)
		{
			return _ht.Find(key);
		}

		bool erase(const K&amp; key)
		{
			return _ht.Erase(key);
		}
	private:
		Bucket::HashTable&lt;K, K, SetKeyOfT, HashFunc&gt; _ht;
	};

	struct Date
	{
		Date(int year = 1, int month = 1, int day = 1)
			:_year(year)
			, _month(month)
			, _day(day)
		{}

		bool operator==(const Date&amp; d) const
		{
			return _year == d._year
				&amp;&amp; _month == d._month
				&amp;&amp; _day == d._day;
		}

		int _year;
		int _month;
		int _day;
	};

	struct DateHash
	{
		size_t operator()(const Date&amp; d)
		{
			//return d._year + d._month + d._day;
			size_t hash = 0;
			hash += d._year;
			hash *= 131;
			hash += d._month;
			hash *= 1313;
			hash += d._day;

			//cout &lt;&lt; hash &lt;&lt; endl;

			return hash;
		}
	};

	void test_set()
	{
		unordered_set&lt;int&gt; s;
		s.insert(2);
		s.insert(3);
		s.insert(1);
		s.insert(2);
		s.insert(5);
		s.insert(12);

		//unordered_set&lt;int&gt;::iterator it = s.begin();
		unordered_set&lt;int&gt;::iterator it;
		it = s.begin();

		while (it != s.end())
		{
			cout &lt;&lt; *it &lt;&lt; " ";
			++it;
		}
		cout &lt;&lt; endl;


		for (auto e : s)
		{
			cout &lt;&lt; e &lt;&lt; " ";
		}
		cout &lt;&lt; endl;

		unordered_set&lt;Date, DateHash&gt; sd;
		sd.insert(Date(2022, 3, 4));
		sd.insert(Date(2022, 4, 3));
	}
}
</code></pre> 
 <p><strong>unordered_map类代码：</strong></p> 
 <pre><code class="language-cpp">#pragma once

#include "HashTable.h"

namespace bit
{
	template&lt;class K, class V, class HashFunc = DefaultHash&lt;K&gt;&gt;
	class unordered_map
	{
		struct MapKeyOfT
		{
			const K&amp; operator()(const pair&lt;K, V&gt;&amp; kv)
			{
				return kv.first;
			}
		};
	public:
		typedef typename Bucket::HashTable&lt;K, pair&lt;K, V&gt;, MapKeyOfT, HashFunc&gt;::iterator iterator;

		iterator begin()
		{
			return _ht.begin();
		}

		iterator end()
		{
			return _ht.end();
		}

		pair&lt;iterator, bool&gt; insert(const pair&lt;K, V&gt;&amp; kv)
		{
			return _ht.Insert(kv);
		}

		iterator find(const K&amp; key)
		{
			return _ht.Find(key);
		}

		bool erase(const K&amp; key)
		{
			return _ht.Erase(key);
		}

		V&amp; operator[](const K&amp; key)
		{
			pair&lt;iterator, bool&gt; ret = insert(make_pair(key, V()));
			return ret.first-&gt;second;
		}

	private:
		Bucket::HashTable&lt;K, pair&lt;K, V&gt;, MapKeyOfT, HashFunc&gt; _ht;
	};

	void test_map()
	{
		unordered_map&lt;string, string&gt; dict;
		dict.insert(make_pair("sort", "排序"));
		dict.insert(make_pair("left", "左边"));
		dict.insert(make_pair("left", "剩余"));
		dict["string"];
		dict["left"] = "剩余";
		dict["string"] = "字符串";

		unordered_map&lt;string, string&gt;::iterator it = dict.begin();
		while (it != dict.end())
		{
			cout &lt;&lt; it-&gt;first &lt;&lt; " " &lt;&lt; it-&gt;second &lt;&lt; endl;
			++it;
		}

		cout &lt;&lt; endl;

		for (auto&amp; kv : dict)
		{
			cout &lt;&lt; kv.first &lt;&lt; " " &lt;&lt; kv.second &lt;&lt; endl;
		}
	}
}
</code></pre> 
 <p><strong>开散列哈希表迭代器部分代码：</strong></p> 
 <pre><code class="language-cpp">template&lt;class K, class T, class KeyOfT, class HashFunc&gt;
class __HTIterator
{
	typedef HashNode&lt;T&gt; Node;
	typedef __HTIterator&lt;K, T, KeyOfT, HashFunc&gt; Self;
public:
	Node* _node;
	HashTable&lt;K, T, KeyOfT, HashFunc&gt;* _pht;

	__HTIterator() {}

	__HTIterator(Node* node, HashTable&lt;K, T, KeyOfT, HashFunc&gt;* pht)
		:_node(node)
		, _pht(pht)
	{}

	Self&amp; operator++()
	{
		if (_node-&gt;_next)
		{
			_node = _node-&gt;_next;
		}
		else
		{
			KeyOfT kot;
			HashFunc hf;
			size_t hashi = hf(kot(_node-&gt;_data)) % _pht-&gt;_tables.size();
			++hashi;
			//找下一个不为空的桶
			for (; hashi &lt; _pht-&gt;_tables.size(); ++hashi)
			{
				if (_pht-&gt;_tables[hashi])
				{
					_node = _pht-&gt;_tables[hashi];
					break;
				}
			}

			// 没有找到不为空的桶，用nullptr去做end标识
			if (hashi == _pht-&gt;_tables.size())
			{
				_node = nullptr;
			}
		}

		return *this;
	}

	T&amp; operator*()
	{
		return _node-&gt;_data;
	}

	T* operator-&gt;()
	{
		return &amp;_node-&gt;_data;
	}

	bool operator!=(const Self&amp; s) const
	{
		return _node != s._node;
	}

	bool operator==(const Self&amp; s) const
	{
		return _node == s._node;
	}
};</code></pre> 
 <p>注：</p> 
 <p>1.开散列哈希表迭代器__HTIterator需要一个指针成员变量_node和一个哈希表指针成员变量_pht，指针成员变量_node标识此时迭代器走到的位置，哈希表指针成员变量_pht负责支持实现哈希表迭代器的++功能。</p> 
 <p>2.哈希表迭代器__HTIterator中实现operator++运算符重载函数，如果迭代器的指针成员变量_node指向节点的下一个节点不是空，则_node=_node-&gt;_next指向下一个节点，如果迭代器的指针成员变量_node指向节点的下一个节点是空，则计算此时的桶号hashi，然后往后遍历找到下一个不为空的桶，如果找到了下一个不为空的桶，让_node指向该不为空的桶的第一个节点，如果没找到下一个不为空的桶，也就是后面的桶全为空，那么就给_node赋值为空标识走到了end。</p> 
 <p><img alt="" height="444" src="https://images2.imgbox.com/7a/bb/ZDqpvMWN_o.png" width="357"></p> 
 <p>3.哈希表HashTable中begin函数需要找到第一个不为空的桶的第一个节点，找到节点的指针作为_node，this指针指向的哈希表地址正好作为_pht，生成哈希表的迭代器，返回该哈希表的迭代器。如果哈希表为空即找不到第一个不为空的桶则返回end。哈希表HashTable中end函数返回迭代器的_node我们用空指针来标识。begin函数和end函数如下图所示</p> 
 <p><img alt="" height="306" src="https://images2.imgbox.com/62/7f/yUg7RwVK_o.png" width="376"></p> 
 <p>4.哈希表迭代器__HTIterator中operator*、operator-&gt;、operator!=和operator==代码实现如下图所示</p> 
 <p><img alt="" height="130" src="https://images2.imgbox.com/fc/e1/bmWqhWZB_o.png" width="1200"></p> 
 <p>5.在<span style="color:#333333;">unordered_map和unordered_set中要将</span>哈希表的迭代器<span style="color:#333333;">类型重定义iterator作为自己的迭代器，然后修改并复用</span>哈希表的begin、end、Insert、Find、Erase函数来实现自己的begin、end、insert、find、erase函数功能，并且<span style="color:#333333;">unordered_map中要</span>复用自己的insert函数实现operator[]运算符重载函数，如下图所示<span style="color:#333333;">。</span></p> 
 <p>这里哈希表的迭代器进行<span style="color:#333333;">类型重定义时要用</span>typename修饰，原因和红黑树封装map和set那里相同，这里不再赘述。</p> 
 <p><img alt="" height="663" src="https://images2.imgbox.com/d3/a2/Hc78QtWq_o.png" width="1200"></p> 
 <p>6.哈希表迭代器__HTIterator中使用了哈希表指针成员变量_pht，而编译器遵循向上查找原则，哈希表是在哈希表迭代器的后面定义的，那么要在哈希表迭代器的前面对哈希表进行声明，如下图所示</p> 
 <p><img alt="" height="109" src="https://images2.imgbox.com/29/ac/h0BDCZkI_o.png" width="482"></p> 
 <p>7.哈希表迭代器__HTIterator中找下一个不为空的桶时要访问哈希表的私有成员变量_tables，因此我们要将哈希表迭代器设置成哈希表的友元，这里哈希表迭代器__HTIterator和哈希表HashTable都是类模板，类模板要设置友元要加上模板参数部分，如下图所示</p> 
 <p><img alt="" height="169" src="https://images2.imgbox.com/2d/1d/N0cV6uJf_o.png" width="566"></p> 
</blockquote> 
<p></p> 
<h3 id="3.3.%E5%BC%80%E6%95%A3%E5%88%97%E5%93%88%E5%B8%8C%E8%A1%A8%E5%AE%B9%E9%87%8F%E4%B8%BA%E7%B4%A0%E6%95%B0%E7%9A%84%E4%BC%98%E5%8C%96">3.3.开散列哈希表容量为素数的优化</h3> 
<blockquote> 
 <p><strong>很多研究证明，哈希表的容量如果是一个素数可以有效降低哈希冲突的概率。</strong></p> 
 <p>如何保证每一次扩容扩容后的结果都是素数呢？我们观察STL源码中是如何解决的。</p> 
 <p>如下图所示，源码中给了一个静态的素数表，素数表中每一个数都是素数且后一个数约是前一个数的两倍。</p> 
 <p><img alt="" height="198" src="https://images2.imgbox.com/6f/82/niaheZ0h_o.png" width="533"></p> 
 <p></p> 
 <p>在我们的实现中可以增加一个GetNextPrime函数，找比当前素数值大的下一个素数，用来当作哈希表扩容的大小。其中每个素数后面跟着ul，ul是unsigned long代表该素数是unsigned long类型的。</p> 
 <p><img alt="" height="886" src="https://images2.imgbox.com/89/68/Boz4rAcY_o.png" width="1200"></p> 
</blockquote> 
<p></p> 
<h3 id="3.3.%E7%BA%A2%E9%BB%91%E6%A0%91%E6%A8%A1%E6%8B%9F%E5%AE%9E%E7%8E%B0STL%E4%B8%ADmap%E4%B8%8Eset%E7%9A%84%E4%BB%A3%E7%A0%81">3.4.开散列哈希表模拟实现STL中<span style="color:#333333;">unordered_map和unordered_set</span>的代码</h3> 
<p><strong>UnorderedSet.h文件：</strong></p> 
<pre><code class="language-cpp">#pragma once

#include "HashTable.h"

namespace bit
{
	template&lt;class K, class HashFunc = DefaultHash&lt;K&gt;&gt;
	class unordered_set
	{
		struct SetKeyOfT
		{
			const K&amp; operator()(const K&amp; key)
			{
				return key;
			}
		};
	public:
		typedef typename Bucket::HashTable&lt;K, K, SetKeyOfT, HashFunc&gt;::iterator iterator;

		iterator begin()
		{
			return _ht.begin();
		}

		iterator end()
		{
			return _ht.end();
		}

		pair&lt;iterator, bool&gt; insert(const K&amp; key)
		{
			return _ht.Insert(key);
		}

		iterator find(const K&amp; key)
		{
			return _ht.Find(key);
		}

		bool erase(const K&amp; key)
		{
			return _ht.Erase(key);
		}
	private:
		Bucket::HashTable&lt;K, K, SetKeyOfT, HashFunc&gt; _ht;
	};

	struct Date
	{
		Date(int year = 1, int month = 1, int day = 1)
			:_year(year)
			, _month(month)
			, _day(day)
		{}

		bool operator==(const Date&amp; d) const
		{
			return _year == d._year
				&amp;&amp; _month == d._month
				&amp;&amp; _day == d._day;
		}

		int _year;
		int _month;
		int _day;
	};

	struct DateHash
	{
		size_t operator()(const Date&amp; d)
		{
			//return d._year + d._month + d._day;
			size_t hash = 0;
			hash += d._year;
			hash *= 131;
			hash += d._month;
			hash *= 1313;
			hash += d._day;

			//cout &lt;&lt; hash &lt;&lt; endl;

			return hash;
		}
	};

	void test_set()
	{
		unordered_set&lt;int&gt; s;
		s.insert(2);
		s.insert(3);
		s.insert(1);
		s.insert(2);
		s.insert(5);
		s.insert(12);

		//unordered_set&lt;int&gt;::iterator it = s.begin();
		unordered_set&lt;int&gt;::iterator it;
		it = s.begin();

		while (it != s.end())
		{
			cout &lt;&lt; *it &lt;&lt; " ";
			++it;
		}
		cout &lt;&lt; endl;


		for (auto e : s)
		{
			cout &lt;&lt; e &lt;&lt; " ";
		}
		cout &lt;&lt; endl;

		unordered_set&lt;Date, DateHash&gt; sd;
		sd.insert(Date(2022, 3, 4));
		sd.insert(Date(2022, 4, 3));
	}
}
</code></pre> 
<p><strong>UnorderedMap.h文件：</strong></p> 
<pre><code class="language-cpp">#pragma once

#include "HashTable.h"

namespace bit
{
	template&lt;class K, class V, class HashFunc = DefaultHash&lt;K&gt;&gt;
	class unordered_map
	{
		struct MapKeyOfT
		{
			const K&amp; operator()(const pair&lt;K, V&gt;&amp; kv)
			{
				return kv.first;
			}
		};
	public:
		typedef typename Bucket::HashTable&lt;K, pair&lt;K, V&gt;, MapKeyOfT, HashFunc&gt;::iterator iterator;

		iterator begin()
		{
			return _ht.begin();
		}

		iterator end()
		{
			return _ht.end();
		}

		pair&lt;iterator, bool&gt; insert(const pair&lt;K, V&gt;&amp; kv)
		{
			return _ht.Insert(kv);
		}

		iterator find(const K&amp; key)
		{
			return _ht.Find(key);
		}

		bool erase(const K&amp; key)
		{
			return _ht.Erase(key);
		}

		V&amp; operator[](const K&amp; key)
		{
			pair&lt;iterator, bool&gt; ret = insert(make_pair(key, V()));
			return ret.first-&gt;second;
		}

	private:
		Bucket::HashTable&lt;K, pair&lt;K, V&gt;, MapKeyOfT, HashFunc&gt; _ht;
	};

	void test_map()
	{
		unordered_map&lt;string, string&gt; dict;
		dict.insert(make_pair("sort", "排序"));
		dict.insert(make_pair("left", "左边"));
		dict.insert(make_pair("left", "剩余"));
		dict["string"];
		dict["left"] = "剩余";
		dict["string"] = "字符串";

		unordered_map&lt;string, string&gt;::iterator it = dict.begin();
		while (it != dict.end())
		{
			cout &lt;&lt; it-&gt;first &lt;&lt; " " &lt;&lt; it-&gt;second &lt;&lt; endl;
			++it;
		}

		cout &lt;&lt; endl;

		for (auto&amp; kv : dict)
		{
			cout &lt;&lt; kv.first &lt;&lt; " " &lt;&lt; kv.second &lt;&lt; endl;
		}
	}
}
</code></pre> 
<p><strong>HashTable.h文件：</strong></p> 
<pre><code class="language-cpp">#pragma once
#include&lt;vector&gt;

template&lt;class K&gt;
struct DefaultHash
{
	size_t operator()(const K&amp; key)
	{
		return (size_t)key;
	}
};


template&lt;&gt;
struct DefaultHash&lt;string&gt;
{
	size_t operator()(const string&amp; key)
	{
		// BKDR
		size_t hash = 0;
		for (auto ch : key)
		{
			hash = hash * 131 + ch;
		}

		return hash;
	}
};

namespace Bucket
{
	template&lt;class T&gt;
	struct HashNode
	{
		T _data;
		HashNode&lt;T&gt;* _next;

		HashNode(const T&amp; data)
			:_data(data)
			, _next(nullptr)
		{}
	};

	template&lt;class K, class T, class KeyOfT, class HashFunc&gt;
	class HashTable;

	template&lt;class K, class T, class KeyOfT, class HashFunc&gt;
	class __HTIterator
	{
		typedef HashNode&lt;T&gt; Node;
		typedef __HTIterator&lt;K, T, KeyOfT, HashFunc&gt; Self;
	public:
		Node* _node;
		HashTable&lt;K, T, KeyOfT, HashFunc&gt;* _pht;

		__HTIterator() {}

		__HTIterator(Node* node, HashTable&lt;K, T, KeyOfT, HashFunc&gt;* pht)
			:_node(node)
			, _pht(pht)
		{}

		Self&amp; operator++()
		{
			if (_node-&gt;_next)
			{
				_node = _node-&gt;_next;
			}
			else
			{
				KeyOfT kot;
				HashFunc hf;
				size_t hashi = hf(kot(_node-&gt;_data)) % _pht-&gt;_tables.size();
				++hashi;
				//找下一个不为空的桶
				for (; hashi &lt; _pht-&gt;_tables.size(); ++hashi)
				{
					if (_pht-&gt;_tables[hashi])
					{
						_node = _pht-&gt;_tables[hashi];
						break;
					}
				}

				// 没有找到不为空的桶，用nullptr去做end标识
				if (hashi == _pht-&gt;_tables.size())
				{
					_node = nullptr;
				}
			}

			return *this;
		}

		T&amp; operator*()
		{
			return _node-&gt;_data;
		}

		T* operator-&gt;()
		{
			return &amp;_node-&gt;_data;
		}

		bool operator!=(const Self&amp; s) const
		{
			return _node != s._node;
		}

		bool operator==(const Self&amp; s) const
		{
			return _node == s._node;
		}
	};

	// unordered_map -&gt;HashTable&lt;K, pair&lt;K, V&gt;, MapKeyOfT&gt; _ht;
	// unordered_set -&gt;HashTable&lt;K, K, SetKeyOfT&gt; _ht;
	template&lt;class K, class T, class KeyOfT, class HashFunc&gt;
	class HashTable
	{
		template&lt;class K, class T, class KeyOfT, class HashFunc&gt;
		friend class __HTIterator;

		typedef HashNode&lt;T&gt; Node;
	public:
		typedef __HTIterator&lt;K, T, KeyOfT, HashFunc&gt; iterator;

		iterator begin()
		{
			for (size_t i = 0; i &lt; _tables.size(); ++i)
			{
				Node* cur = _tables[i];
				if (cur)
				{
					return iterator(cur, this);
				}
			}

			return end();
		}

		iterator end()
		{
			return iterator(nullptr, this);
		}

		~HashTable()
		{
			for (size_t i = 0; i &lt; _tables.size(); ++i)
			{
				Node* cur = _tables[i];
				while (cur)
				{
					Node* next = cur-&gt;_next;
					delete cur;
					cur = next;
				}

				_tables[i] = nullptr;
			}
		}

		size_t GetNextPrime(size_t prime)
		{
			const int PRIMECOUNT = 28;
			static const size_t primeList[PRIMECOUNT] =
			{
				53ul, 97ul, 193ul, 389ul, 769ul,
				1543ul, 3079ul, 6151ul, 12289ul, 24593ul,
				49157ul, 98317ul, 196613ul, 393241ul, 786433ul,
				1572869ul, 3145739ul, 6291469ul, 12582917ul, 25165843ul,
				50331653ul, 100663319ul, 201326611ul, 402653189ul, 805306457ul,
				1610612741ul, 3221225473ul, 4294967291ul
			};

			// 获取比prime大那一个素数
			size_t i = 0;
			for (; i &lt; PRIMECOUNT; ++i)
			{
				if (primeList[i] &gt; prime)
					return primeList[i];
			}

			return primeList[i];
		}

		pair&lt;iterator, bool&gt; Insert(const T&amp; data)
		{
			HashFunc hf;
			KeyOfT kot;

			iterator pos = Find(kot(data));
			if (pos != end())
			{
				return make_pair(pos, false);
			}

			// 负载因子 == 1 扩容
			if (_tables.size() == _n)
			{
				//size_t newSize = _tables.size() == 0 ? 11 : _tables.size() * 2;
				size_t newSize = GetNextPrime(_tables.size());
				if (newSize != _tables.size())
				{
					vector&lt;Node*&gt; newTable;
					newTable.resize(newSize, nullptr);
					for (size_t i = 0; i &lt; _tables.size(); ++i)
					{
						Node* cur = _tables[i];
						while (cur)
						{
							Node* next = cur-&gt;_next;

							size_t hashi = hf(kot(cur-&gt;_data)) % newSize;
							cur-&gt;_next = newTable[hashi];
							newTable[hashi] = cur;

							cur = next;
						}

						_tables[i] = nullptr;
					}

					newTable.swap(_tables);
				}
			}

			size_t hashi = hf(kot(data));
			hashi %= _tables.size();

			// 头插到对应的桶即可
			Node* newnode = new Node(data);
			newnode-&gt;_next = _tables[hashi];
			_tables[hashi] = newnode;

			++_n;

			return make_pair(iterator(newnode, this), false);;
		}

		iterator Find(const K&amp; key)
		{
			if (_tables.size() == 0)
			{
				return iterator(nullptr, this);
			}

			KeyOfT kot;
			HashFunc hf;
			size_t hashi = hf(key);
			//size_t hashi = HashFunc()(key);

			hashi %= _tables.size();
			Node* cur = _tables[hashi];
			while (cur)
			{
				if (kot(cur-&gt;_data) == key)
				{
					return iterator(cur, this);
				}

				cur = cur-&gt;_next;
			}

			return iterator(nullptr, this);
		}

		bool Erase(const K&amp; key)
		{
			if (_tables.size() == 0)
			{
				return false;
			}

			HashFunc hf;
			KeyOfT kot;
			size_t hashi = hf(key);
			hashi %= _tables.size();
			Node* prev = nullptr;
			Node* cur = _tables[hashi];
			while (cur)
			{
				if (kot(cur-&gt;_data) == key)
				{
					if (prev == nullptr)
					{
						_tables[hashi] = cur-&gt;_next;
					}
					else
					{
						prev-&gt;_next = cur-&gt;_next;
					}

					delete cur;

					return true;
				}

				prev = cur;
				cur = cur-&gt;_next;
			}

			return false;
		}

	private:
		// 指针数组
		vector&lt;Node*&gt; _tables;
		size_t _n = 0;
	};
}
</code></pre> 
<p><strong>test.cpp文件：</strong></p> 
<pre><code class="language-cpp">#include&lt;iostream&gt;
#include &lt;set&gt;
#include &lt;map&gt;
#include &lt;string&gt;
#include &lt;unordered_set&gt;
#include &lt;unordered_map&gt;
#include &lt;time.h&gt;
using namespace std;

#include "HashTable.h"
#include "UnorderedMap.h"
#include "UnorderedSet.h"

int main()
{
	bit::test_map();

	return 0;
}
</code></pre> 
<p></p> 
<hr> 
<h2 id="4.%E5%93%88%E5%B8%8C%E7%9A%84%E5%BA%94%E7%94%A8">4.哈希的应用</h2> 
<h3 id="4.1.%E4%BD%8D%E5%9B%BE">4.1.位图</h3> 
<h4 id="4.1.1.%E4%BD%8D%E5%9B%BE%E6%A6%82%E5%BF%B5">4.1.1.位图概念</h4> 
<blockquote> 
 <div>
   面试题：给40亿个不重复的无符号整数，没排过序。给一个无符号整数，如何快速判断一个数是否在这40亿个数中。 
 </div> 
 <div>
   方法一：遍历，时间复杂度O(N) 
 </div> 
 <div>
   方法二：先排序：NlogN，后二分查找: logN，时间复杂度O(NlogN) 
 </div> 
 <div>
   方法三：位图解决 
 </div> 
 <div>
   数据是否在给定的整形数据中，结果是在或者不在，刚好是两种状态，那么可以使用一 
 </div> 
 <div>
   个二进制比特位来代表数据是否存在的信息，如果二进制比特位为1，代表存在，为0 
 </div> 
 <div>
   代表不存在。比如： 
 </div> 
 <div> 
  <img alt="" height="139" src="https://images2.imgbox.com/f7/c5/TNVTQgc2_o.png" width="460"> 
 </div> 
 <p>因为数据集中是无符号整数，无符号整数的最大值为0xffffffff，大约为四十二亿九千万，所以开四十二亿九千万个比特位空间作为位图空间，四十二亿九千万个比特位空间是500M内存空间。遍历数据集中40亿个不重复的无符号整数，将每一个无符号整数对应位图的那个比特位由0改成1。这样判断任意一个给定的无符号整数是否在数据集中只需要判断给定的无符号整数对应位图的那个比特位是否为1即可，为1则给定的无符号整数在数据集中，为0则给定的无符号整数不在数据集中。</p> 
 <p></p> 
 <p>注：</p> 
 <p>1.STL库中的bitset就是位图数据结构，如下图所示，其核心接口有test、set、reset。</p> 
 <p><img alt="" height="80" src="https://images2.imgbox.com/5c/08/WPGtC3fs_o.png" width="1149"></p> 
 <p>2.位图只能处理整型数据，无法处理浮点数据以及字符串数据等。</p> 
</blockquote> 
<div></div> 
<h4 id="4.1.2.%E4%BD%8D%E5%9B%BE%E7%9A%84%E5%AE%9E%E7%8E%B0">4.1.2.位图的实现</h4> 
<p><strong>BitSet.h文件：</strong></p> 
<pre><code class="language-cpp">#pragma once
#include &lt;vector&gt;

namespace bit
{
	// N个比特位的位图  10  16
	template&lt;size_t N&gt;
	class bitset
	{
	public:
		bitset()
		{
			// +1保证足够比特位，最多浪费8个
			_bits.resize(N / 8 + 1, 0);
		}

		//x映射的位标记成1
		void set(size_t x)
		{
			// x映射的比特位在第几个char对象
			size_t i = x / 8;

			// x在char第几个比特位
			size_t j = x % 8;

			_bits[i] |= (1 &lt;&lt; j);
		}

		void reset(size_t x)
		{
			// x映射的比特位在第几个char对象
			size_t i = x / 8;

			// x在char第几个比特位
			size_t j = x % 8;

			_bits[i] &amp;= (~(1 &lt;&lt; j));
		}

		bool test(size_t x)
		{
			// x映射的比特位在第几个char对象
			size_t i = x / 8;

			// x在char第几个比特位
			size_t j = x % 8;

			return _bits[i] &amp; (1 &lt;&lt; j);
		}

	private:
		std::vector&lt;char&gt; _bits;
		//vector&lt;int&gt; _bits;
	};

	void test_bit_set1()
	{
		bitset&lt;100&gt; bs;
		bs.set(18);
		bs.set(19);

		cout &lt;&lt; bs.test(18) &lt;&lt; endl;
		cout &lt;&lt; bs.test(19) &lt;&lt; endl;
		cout &lt;&lt; bs.test(20) &lt;&lt; endl;


		bs.reset(18);
		bs.reset(18);

		cout &lt;&lt; bs.test(18) &lt;&lt; endl;
		cout &lt;&lt; bs.test(19) &lt;&lt; endl;
		cout &lt;&lt; bs.test(20) &lt;&lt; endl;


		//开无符号整数最大值的内存空间
		//bitset&lt;0xFFFFFFFF&gt; bigBS;
		//bitset&lt;-1&gt; bigBS;

	}
}
</code></pre> 
<p><strong>注：</strong></p> 
<p>1.编译器无法按照比特位来开空间，要么使用char类型一次开一个字节空间八个比特位，或者使用int类型一次开四个字节空间三十二个比特位，我们这里使用char类型开空间，如下图所示。</p> 
<p><img alt="" height="160" src="https://images2.imgbox.com/83/18/levMbagl_o.png" width="182"></p> 
<p>2.bitset构造函数，根据模板参数N创建N个比特位的位图，N/8+1是计算N个比特位需要多少个char类型的空间，其中+1保证足够比特位，最多浪费8个，bitset构造函数代码如下图所示。</p> 
<p><img alt="" height="97" src="https://images2.imgbox.com/c8/3d/5xfMGqsl_o.png" width="238"></p> 
<p>3.set函数的功能是给定一个无符号整数，将无符号整数对应位图的那个比特位由0改成1，首先size_t i = x / 8计算无符号整数映射的比特位在第i个char对象，然后size_t j = x % 8计算无符号整数映射在char第j个比特位，最后_bits[i] |= (1 &lt;&lt; j)将第i个char空间从右往左数第j个比特位置为1即可，代码如下图所示。</p> 
<p><img alt="" height="184" src="https://images2.imgbox.com/95/96/5thAmdTW_o.png" width="235"></p> 
<p>4.reset函数的功能是给定一个无符号整数，将无符号整数对应位图的那个比特位由1改成0，首先size_t i = x / 8计算无符号整数映射的比特位在第i个char对象，然后size_t j = x % 8计算无符号整数映射在char第j个比特位，最后_bits[i] &amp;= (~(1 &lt;&lt; j))将第i个char空间从右往左数第j个比特位置为0即可，代码如下图所示。</p> 
<p><img alt="" height="209" src="https://images2.imgbox.com/33/5b/xvoN8S5a_o.png" width="244"></p> 
<p>5.test函数的功能是判断给定的一个无符号整数在不在，也就是判断给定的一个无符号整数对应位图的那个比特位是1还是0，是1则返回true，是0则返回false。首先size_t i = x / 8计算无符号整数映射的比特位在第i个char对象，然后size_t j = x % 8计算无符号整数映射在char第j个比特位，最后返回_bits[i] &amp; (1 &lt;&lt; j)，代码如下图所示。</p> 
<p><img alt="" height="176" src="https://images2.imgbox.com/86/d0/I3mqmHxd_o.png" width="244"></p> 
<p id=""></p> 
<h4 id="4.1.3.%E4%BD%8D%E5%9B%BE%E7%9A%84%E5%BA%94%E7%94%A8">4.1.3.位图的应用</h4> 
<blockquote> 
 <div>
   1. 快速查找某个数据是否在一个集合中 
 </div> 
 <div>
   2. 排序 + 去重 
 </div> 
 <div>
   3. 求两个集合的交集、并集等 
 </div> 
 <div>
   4. 操作系统中磁盘块标记 
 </div> 
</blockquote> 
<p></p> 
<h3 id="4.2.%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8">4.2.布隆过滤器</h3> 
<h4 id="4.2.1.%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8%E6%8F%90%E5%87%BA">4.2.1.布隆过滤器提出</h4> 
<blockquote> 
 <div>
   我们在使用新闻客户端看新闻时，它会给我们不停地推荐新的内容，它每次推荐时要去重，去掉那些已经看过的内容。问题来了，新闻客户端推荐系统如何实现推送去重的？ 用服务器记录了用户看过的所有历史记录，当推荐系统推荐新闻时会从每个用户的历史记录里进行筛选，过滤掉那些已经存在的记录。 如何快速查找呢？ 
 </div> 
 <div>
   1. 用哈希表存储用户记录，缺点：浪费空间。 
 </div> 
 <div>
   2. 用位图存储用户记录，缺点：位图一般只能处理整形，如果内容编号是字符串，就无法处理了。 
 </div> 
 <div>
   3. 将哈希与位图结合，即布隆过滤器。 
 </div> 
</blockquote> 
<p></p> 
<h4 id="4.2.2.%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8%E6%A6%82%E5%BF%B5">4.2.2.布隆过滤器概念</h4> 
<blockquote> 
 <div>
   布隆过滤器是由布隆（Burton Howard Bloom）在1970年提出的 一种紧凑型的、比较巧妙的概率型数据结构，特点是高效地插入和查询，可以用来告诉你 “某样东西一定不存在或者可能存在”，它是用多个哈希函数，将一个数据映射到位图结构中。此种方式不仅可以提升查询效率，也可以节省大量的内存空间。 
 </div> 
 <div> 
  <img alt="" height="139" src="https://images2.imgbox.com/2e/e0/ok4XEVBp_o.png" width="384"> 
 </div> 
 <p>注：</p> 
 <p>1.布隆过滤器同时使用多个哈希函数进行映射，一个数据映射多个位置，这样即使某个哈希函数存在哈希冲突，也不会误判，只有所有哈希函数同时哈希冲突才会误判，误判概率较低。</p> 
 <p>2.布隆过滤器的思想是将一个元素用多个哈希函数映射到一个位图中，因此被映射到的位置的比特位一定为1。所以可以按照以下方式进行查找：分别计算每个哈希值对应的比特位置存储的是否为零，只要有一个为零，代表该元素一定不在哈希表中，否则可能在哈希表中。</p> 
 <div>
   注意：布隆过滤器如果说某个元素不存在时，该元素一定不存在，如果该元素存在时，该元素可能存在，因为有些哈希函数存在一定的误判。 
 </div> 
 <div>
   比如：在布隆过滤器中查找"alibaba"时，假设3个哈希函数计算的哈希值为：1、3、7，刚好和其他元素的比特位重叠，此时布隆过滤器告诉该元素存在，但实该元素是不存在的。 
 </div> 
 <p>3.布隆过滤器误判概率较低，但也有误判的可能性，所以如果一个数据经过所有哈希函数映射的多个位置都是1，也只能推出该数据可能存在，如果一个数据经过所有哈希函数映射的多个位置有0，可以推出该数据一定不存在。</p> 
 <div>
   4.布隆过滤器同时使用多个哈希函数进行映射，哈希函数使用的越多误判概率越低，但空间消耗越高。博客 
  <a href="https://zhuanlan.zhihu.com/p/43263751/" rel="nofollow" title="详解布隆过滤器的原理，使用场景和注意事项 - 知乎 (zhihu.com)">详解布隆过滤器的原理，使用场景和注意事项 - 知乎 (zhihu.com)</a>中介绍了如何选取哈希函数个数，来平衡误判和空间消耗的问题。 
 </div> 
 <p>在该博客中提到哈希函数个数k、布隆过滤器长度m和插入元素个数n之间的关系公式，如下图所示，如果满足该公式则可以达到较好的性能。</p> 
 <p><img alt="" height="112" src="https://images2.imgbox.com/b4/3f/M6VNa9Zv_o.png" width="387"></p> 
 <p></p> 
</blockquote> 
<p></p> 
<h4 id="4.2.3.%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8%E7%9A%84%E5%AE%9E%E7%8E%B0">4.2.3.布隆过滤器的实现</h4> 
<p><strong>BloomFilter.h文件：</strong></p> 
<pre><code class="language-cpp">#pragma once

namespace bit
{
	struct BKDRHash
	{
		size_t operator()(const string&amp; s)
		{
			// BKDR
			size_t value = 0;
			for (auto ch : s)
			{
				value *= 31;
				value += ch;
			}
			return value;
		}
	};

	struct APHash
	{
		size_t operator()(const string&amp; s)
		{
			size_t hash = 0;
			for (long i = 0; i &lt; s.size(); i++)
			{
				if ((i &amp; 1) == 0)
				{
					hash ^= ((hash &lt;&lt; 7) ^ s[i] ^ (hash &gt;&gt; 3));
				}
				else
				{
					hash ^= (~((hash &lt;&lt; 11) ^ s[i] ^ (hash &gt;&gt; 5)));
				}
			}
			return hash;
		}
	};

	struct DJBHash
	{
		size_t operator()(const string&amp; s)
		{
			size_t hash = 5381;
			for (auto ch : s)
			{
				hash += (hash &lt;&lt; 5) + ch;
			}
			return hash;
		}
	};


	struct JSHash
	{
		size_t operator()(const string&amp; s)
		{
			size_t hash = 1315423911;
			for (auto ch : s)
			{
				hash ^= ((hash &lt;&lt; 5) + ch + (hash &gt;&gt; 2));
			}
			return hash;
		}
	};

	template&lt;size_t M,
		class K = string,
		class HashFunc1 = BKDRHash,
		class HashFunc2 = APHash,
		class HashFunc3 = DJBHash,
		class HashFunc4 = JSHash&gt;
		class BloomFilter
	{
	public:
		void Set(const K&amp; key)
		{
			size_t hash1 = HashFunc1()(key) % M;
			size_t hash2 = HashFunc2()(key) % M;
			size_t hash3 = HashFunc3()(key) % M;
			size_t hash4 = HashFunc4()(key) % M;

			_bs.set(hash1);
			_bs.set(hash2);
			_bs.set(hash3);
			_bs.set(hash4);
		}

		bool Test(const K&amp; key)
		{
			size_t hash1 = HashFunc1()(key) % M;
			if (_bs.test(hash1) == false)
			{
				return false;
			}

			size_t hash2 = HashFunc2()(key) % M;
			if (_bs.test(hash2) == false)
			{
				return false;
			}

			size_t hash3 = HashFunc3()(key) % M;
			if (_bs.test(hash3) == false)
			{
				return false;
			}

			size_t hash4 = HashFunc4()(key) % M;
			if (_bs.test(hash4) == false)
			{
				return false;
			}

			return true; // 存在误判
		}

	private:
		bitset&lt;M&gt; _bs;
	};

	void TestBloomFilter1()
	{
		// 插入10个值
		BloomFilter&lt;43&gt; bf;

		string a[] = { "苹果", "香蕉", "西瓜", "111111111", "eeeeeffff", "草莓", "休息", "继续", "查找", "set" };

		for (auto&amp; e : a)
		{
			bf.Set(e);
		}

		for (auto&amp; e : a)
		{
			cout &lt;&lt; bf.Test(e) &lt;&lt; endl;
		}
		cout &lt;&lt; endl;

		cout &lt;&lt; bf.Test("芒果") &lt;&lt; endl;
		cout &lt;&lt; bf.Test("string") &lt;&lt; endl;
		cout &lt;&lt; bf.Test("ffffeeeee") &lt;&lt; endl;
		cout &lt;&lt; bf.Test("31341231") &lt;&lt; endl;
		cout &lt;&lt; bf.Test("ddddd") &lt;&lt; endl;
		cout &lt;&lt; bf.Test("3333343") &lt;&lt; endl;

	}

	void TestBloomFilter2()
	{
		srand(time(0));
		const size_t N = 100000;
		BloomFilter&lt;6 * N&gt; bf;

		std::vector&lt;std::string&gt; v1;
		std::string url = "https://www.cnblogs.com/-clq/archive/2012/05/31/2528153.html";

		for (size_t i = 0; i &lt; N; ++i)
		{
			v1.push_back(url + std::to_string(1234 + i));
		}

		for (auto&amp; str : v1)
		{
			bf.Set(str);
		}

		std::vector&lt;std::string&gt; v2;
		for (size_t i = 0; i &lt; N; ++i)
		{
			std::string url = "https://www.cnblogs.com/-clq/archive/2012/05/31/2528153.html";
			url += std::to_string(999999 + i);
			v2.push_back(url);
		}

		size_t n2 = 0;
		for (auto&amp; str : v2)
		{
			if (bf.Test(str))
			{
				++n2;
			}
		}
		cout &lt;&lt; "相似字符串误判率:" &lt;&lt; (double)n2 / (double)N &lt;&lt; endl;

		std::vector&lt;std::string&gt; v3;
		for (size_t i = 0; i &lt; N; ++i)
		{
			string url = "zhihu.com";
			url += std::to_string(rand());
			v3.push_back(url);
		}

		size_t n3 = 0;
		for (auto&amp; str : v3)
		{
			if (bf.Test(str))
			{
				++n3;
			}
		}
		cout &lt;&lt; "不相似字符串误判率:" &lt;&lt; (double)n3 / (double)N &lt;&lt; endl;
	}
}
</code></pre> 
<p><strong>注：</strong><br> 1.布隆过滤器BloomFilter的模板参数由数据类型K、布隆过滤器长度M和多个仿函数类构成，需要多少个哈希函数进行映射模板中就有多少个仿函数类，这里我们使用BKDRHash、APHash、DJBHash三个哈希函数，如下图一所示。布隆过滤器的底层其实是位图，我们使用STL库中的位图bitset来实现，如下图二所示。</p> 
<p><img alt="" height="174" src="https://images2.imgbox.com/d2/bf/ahfQmpdQ_o.png" width="475"><img alt="" height="179" src="https://images2.imgbox.com/aa/7c/cIfjxcx9_o.png" width="203"></p> 
<p>2.布隆过滤器BloomFilter的Set函数接口功能是将给定数据根据多个哈希函数映射的对应比特位设置成1，Set函数的实现如下图所示。</p> 
<p><img alt="" height="178" src="https://images2.imgbox.com/67/73/bspQqgm4_o.png" width="334"></p> 
<p>3.布隆过滤器BloomFilter的Test函数接口功能是检测给定数据是否存在，即判断定数据根据多个哈希函数映射的对应比特位是否全为1，如果全为1则返回true，如果不全为1则返回false，Test函数的实现如下图所示。这里Test函数即使返回true给定数据也是可能存在，不能确保一定存在。</p> 
<p><img alt="" height="424" src="https://images2.imgbox.com/07/b1/8NlGfL5f_o.png" width="372"></p> 
<p>4.根据前面提到的哈希函数个数k、布隆过滤器长度m和插入元素个数n之间的关系公式，如下图一所示，我们使用3个哈希函数即k=3，如果我们要插入10个数据，那么根据公式布隆过滤器长度m等于43可以达到较好的性能，如下图二所示。</p> 
<p><img alt="" height="99" src="https://images2.imgbox.com/f0/f8/U5hcqdEW_o.png" width="342"><img alt="" height="44" src="https://images2.imgbox.com/78/b3/VDdJYO6s_o.png" width="339"></p> 
<p>5.因为布隆过滤器BloomFilter的模板参数中参数M是一定需要传的，而参数K大概率是字符串可以给默认缺省值，多个哈希函数都可以给字符串哈希函数的默认缺省，所以我们调整一下顺序将参数M放在第一个，其余参数放在后面给缺省值，使用的时候只需要给参数M即可，如下图所示。</p> 
<p><img alt="" height="443" src="https://images2.imgbox.com/92/a9/auyP1mxO_o.png" width="1200"></p> 
<p>6.如下图所示代码，在TestBloomFilter2中，我们可以改变插入元素个数N，检测相似字符串误判率和不相似字符串误判率。将哈希函数增加到四个并改变插入元素个数N，测相似字符串误判率和不相似字符串误判率，可以看出增加一个哈希函数，误判率整体有所下降，但根据公式k大了布隆过滤器长度大了即开空间就大了空间消耗增加了。</p> 
<p>注意如果将哈希函数增加到四个，那么哈希函数个数k为4，插入元素个数N，布隆过滤器长度m应为5.8×N，我们给成6×N。这里如果尝试将6改成更大的值，那么误判率还会有所下降，但是空间消耗会增加。</p> 
<p><img alt="" height="736" src="https://images2.imgbox.com/05/85/ZGBe7OhV_o.png" width="502"></p> 
<p></p> 
<h4 id="4.2.4.%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8%E5%88%A0%E9%99%A4">4.2.4.布隆过滤器删除</h4> 
<blockquote> 
 <div> 
  <strong>布隆过滤器不能直接支持删除工作，因为在删除一个元素时，可能会影响其他元素。 </strong> 
 </div> 
 <div>
   比如：删除上图中"tencent"元素，如果直接将该元素所对应的二进制比特位置0，“baidu”元素也被删除了，因为这两个元素在多个哈希函数计算出的比特位上刚好有重叠。 
 </div> 
 <div></div> 
 <div> 
  <strong>一种支持删除的方法：</strong>将布隆过滤器中的每个比特位扩展成一个小的计数器，插入元素时给k个计数器(k个哈希函数计算出的哈希地址)加一，删除元素时，给k个计数器减一。这样每个比特位变成了多个比特位的计数器，通过多占用几倍存储空间（计数器所占空间）的代价来增加删除操作。 
 </div> 
 <div>
   缺陷： 
 </div> 
 <div>
   1. 无法确认元素是否真正在布隆过滤器中 
 </div> 
 <div>
   2. 存在计数回绕（计数溢出后重新从0开始计数） 
 </div> 
</blockquote> 
<p></p> 
<h4 id="4.2.5.%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8%E4%BC%98%E7%82%B9">4.2.5.布隆过滤器优点</h4> 
<blockquote> 
 <div>
   1. 增加和查询元素的时间复杂度为:O(K), (K为哈希函数的个数，一般比较小)，与数据量大小无关 
 </div> 
 <div>
   2. 哈希函数相互之间没有关系，方便硬件并行运算 
 </div> 
 <div>
   3. 布隆过滤器不需要存储元素本身，在某些对保密要求比较严格的场合有很大优势 
 </div> 
 <div>
   4. 在能够承受一定的误判时，布隆过滤器比其他数据结构有这很大的空间优势 
 </div> 
 <div>
   5. 数据量很大时，布隆过滤器可以表示全集，其他数据结构不能 
 </div> 
 <div>
   6. 使用同一组散列函数的布隆过滤器可以进行交、并、差运算 
 </div> 
</blockquote> 
<p></p> 
<h4 id="4.2.6.%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8%E7%BC%BA%E9%99%B7">4.2.6.布隆过滤器缺陷</h4> 
<blockquote> 
 <div>
   1. 有误判率，即存在假阳性(False Position)，即不能准确判断元素是否在集合中(补救方法：再建立一个白名单，存储可能会误判的数据) 
 </div> 
 <div>
   2. 不能获取元素本身 
 </div> 
 <div>
   3. 一般情况下不能从布隆过滤器中删除元素 
 </div> 
 <div>
   4. 如果采用计数方式删除，可能会存在计数回绕问题 
 </div> 
</blockquote> 
<div></div> 
<h4 id="4.2.7.%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF">4.2.7.布隆过滤器应用场景</h4> 
<blockquote> 
 <div>
   1.注册的时候，通过布隆过滤器快速判断一个昵称是否使用过。如果不在，那么该昵称没有用过可以使用；如果在，那么大概率昵称使用过，小概率昵称没使用过误判了，如果要确保准确，再去数据库查找确认即可。 
 </div> 
 <div>
   2.黑名单，通过布隆过滤器快速判断一个人是否在黑名单中。如果不在，那么该人不在黑名单中可以通行；如果在，那么大概率该人在黑名单中，小概率该人不在黑名单中误判了，如果要确保准确，再去数据库查找确认即可。 
 </div> 
 <div>
   注：很多数据系统会生成一个对应的布隆过滤器，查找数据时在布隆过滤器查找，如果在布隆过滤器中，可能存在误判，继续去数据系统中查找，然后返回在或不在，如果不在布隆过滤器中，则直接返回不在。 
 </div> 
</blockquote> 
<p></p> 
<hr> 
<h2 id="5.%20%E6%B5%B7%E9%87%8F%E6%95%B0%E6%8D%AE%E9%9D%A2%E8%AF%95%E9%A2%98">5. 海量数据面试题</h2> 
<h3 id="5.1.%E5%93%88%E5%B8%8C%E5%88%87%E5%89%B2">5.1.哈希切割</h3> 
<blockquote> 
 <div> 
  <strong>1.给一个超过100G大小的log file, log中存着IP地址, 设计算法找到出现次数最多的IP地址？</strong> 
 </div> 
 <div> 
  <strong>如何找到top K的IP？</strong> 
 </div> 
 <div> 
  <strong>思路一：</strong>将100G大小的log file文件平均分成100个1G大小的文件A0、A1......A99。内存中创建一个map&lt;string,int&gt;来记录ip和对应次数，每一次遍历一个文件记录文件中的ip。这种思路有一个问题是如果ip过多导致map过大内存中可能存不下。 
 </div> 
 <div> 
  <strong>思路二：</strong>创建一百个小文件A0、A1......A99，依次读取log file文件中的ip，利用哈希函数i=HashFunc(ip)%100，将log file文件中每一个ip通过哈希函数分配到对应序号的小文件中，这样相同的ip一定进入了同一个小文件，这一步骤就叫做哈希切分。然后使用map&lt;string,int&gt;统计小文件中的ip和对应次数，利用pair&lt;ip,int&gt;记录次数最多的ip和对应次数，map&lt;string,int&gt;依次遍历每一个小文件遍历完一个小文件后clear清空map再遍历下一个，每一次遍历完一个小文件将本次记录的最多ip次数和pair&lt;ip,int&gt;中的次数比较，如果次数多余pair&lt;ip,int&gt;则更新pair&lt;ip,int&gt;。这样map&lt;string,int&gt;遍历完全部的100个小文件后pair&lt;ip,int&gt;中的ip就是出现次数最多的IP地址。 
 </div> 
 <div>
   如果要找top K的IP，那么将pair&lt;ip,int&gt;换成优先级队列priority_queue&lt;pair&lt;ip,int&gt;,_&gt;(其中_部分是用来比较大小的仿函数)创建一个小堆结构即可。 
 </div> 
 <div>
   这个思路有一个缺点就是哈希切分后的100个小文件有的小文件可能很大，有的小文件可能很小，文件大的原因可能是某个相同的ip太多或映射冲突到这个编号文件的ip太多。 
 </div> 
 <div>
   解决方法一：可以创建1000个小文件，哈希函数改为i=HashFunc(ip)%1000，该方法不能保证一定解决问题。 
 </div> 
 <div>
   解决方法二：如果是相同的ip太多导致的小文件过大，那么map&lt;string,int&gt;统计时只需要次数++即可，因此这种情况导致的小文件大不会有问题。如果是映射冲突到这个编号文件的ip太多，那么map&lt;string,int&gt;统计时可能导致map过大，因此这种情况导致的小文件大是有问题的，我们利用try catch进行异常捕获，如果捕获到内存不足的异常说明是这种情况导致的内存不足，可以针对这个小文件再次换个哈希函数，进行哈希切分，再切分成小文件，对小文件依次统计。 
 </div> 
</blockquote> 
<p></p> 
<h3 id="5.2.%E4%BD%8D%E5%9B%BE%E5%BA%94%E7%94%A8">5.2.位图应用</h3> 
<blockquote> 
 <p><strong>1.给定100亿个整数，设计算法找到只出现一次的整数？</strong></p> 
 <p>答：找在给定的整形数据中只出现一次的整数，可以将整数出现次数标记为出现0次、出现1次、出现2次及以上，刚好是三种状态，那么可以使用两个二进制比特位来代表数据出现次数的信息，如果两个二进制比特位为00，代表出现0次，为01代表出现1次，为10代表出现2次及以上。</p> 
 <div>
   因为数据集中是无符号整数，无符号整数的最大值为0xffffffff，大约为四十二亿九千万，所以要开大约为四十二亿九千万×2个比特位空间作为位图空间，四十二亿九千万×2个比特位空间是1G内存空间。 
 </div> 
 <div></div> 
 <div> 
  <strong>代码实现：</strong> 
 </div> 
 <div>
   BitSet.h文件： 
 </div> 
 <div> 
  <pre><code class="language-cpp">#pragma once
#include &lt;vector&gt;

namespace bit
{
	// N个比特位的位图  10  16
	template&lt;size_t N&gt;
	class bitset
	{
	public:
		bitset()
		{
			// +1保证足够比特位，最多浪费8个
			_bits.resize(N / 8 + 1, 0);
		}

		//x映射的位标记成1
		void set(size_t x)
		{
			// x映射的比特位在第几个char对象
			size_t i = x / 8;

			// x在char第几个比特位
			size_t j = x % 8;

			_bits[i] |= (1 &lt;&lt; j);
		}

		void reset(size_t x)
		{
			// x映射的比特位在第几个char对象
			size_t i = x / 8;

			// x在char第几个比特位
			size_t j = x % 8;

			_bits[i] &amp;= (~(1 &lt;&lt; j));
		}

		bool test(size_t x)
		{
			// x映射的比特位在第几个char对象
			size_t i = x / 8;

			// x在char第几个比特位
			size_t j = x % 8;

			return _bits[i] &amp; (1 &lt;&lt; j);
		}

	private:
		std::vector&lt;char&gt; _bits;
	};

	template&lt;size_t N&gt;
	class two_bitset
	{
	public:
		void set(size_t x)
		{
			int in1 = _bs1.test(x);
			int in2 = _bs2.test(x);
			if (in1 == 0 &amp;&amp; in2 == 0)
			{
				_bs2.set(x);
			}
			else if (in1 == 0 &amp;&amp; in2 == 1)
			{
				_bs1.set(x);
				_bs2.reset(x);
			}
		}

		bool is_once(size_t x)
		{
			return _bs1.test(x) == 0 &amp;&amp; _bs2.test(x) == 1;
		}

	private:
		bitset&lt;N&gt; _bs1;
		bitset&lt;N&gt; _bs2;
	};

	void test_two_bitset()
	{
		int a[] = { 4, 3, 2, 4, 5, 2, 2, 4, 7, 8, 9, 2, 1,3,7 };
		two_bitset&lt;10&gt; tbs;
		for (auto e : a)
		{
			tbs.set(e);
		}

		for (size_t i = 0; i &lt; 10; ++i)
		{
			if (tbs.is_once(i))
			{
				cout &lt;&lt; i &lt;&lt; endl;
			}
		}
	}
}
</code></pre> 
  <p><strong>注：</strong></p> 
 </div> 
 <div>
   1.我们这里的实现可以用两个bitset来实现two_bitset，每一个无符号整数对应位图的一个比特位，那么使用两个bitset位图一个无符号整数就可以认为对应两个比特位。如下图所示，_bs1位图的比特位代表高位的比特位，_bs2位图的比特位代表低位的比特位。 
 </div> 
 <div> 
  <img alt="" height="150" src="https://images2.imgbox.com/ed/40/fsqeKJbg_o.png" width="128"> 
 </div> 
 <p>2.set函数的功能是给定一个无符号整数，将无符号整数对应位图的那两个比特位加一（两个比特位如果是10除外，因为10就代表出现2次及以上），即如果是00变成01，如果是01变成10，如果是10不再变化，代码实现如下图所示。</p> 
 <p><img alt="" height="234" src="https://images2.imgbox.com/96/3b/McRS2Qb1_o.png" width="234"></p> 
 <p>3.is_once函数的功能是给定一个无符号整数，返回该整数在数据集中是否只出现一次，即无符号整数对应位图的那两个比特位如果是01则返回true，如果不是则返回false，代码实现如下图所示。</p> 
 <p><img alt="" height="84" src="https://images2.imgbox.com/d4/c4/58IOW5hd_o.png" width="332"></p> 
</blockquote> 
<blockquote> 
 <div> 
  <strong>2.给两个文件，分别有100亿个整数，我们只有1G内存，如何找到两个文件交集？</strong> 
 </div> 
 <div>
   答：数据是否在给定的整形数据中，结果是在或者不在，刚好是两种状态，那么可以使用一个二进制比特位来代表数据是否存在的信息，如果二进制比特位为1，代表存在，为0代表不存在。假设两个文件分别是A文件和B文件，A文件开一个位图1，B文件开一个位图2，遍历A文件和B文件，将每一个无符号整数对应位图的那个比特位由0改成1，就得到了位图1和位图2，这个步骤同时完成了去重的功能。将两个位图进行按位与运算，得到的位图中所有比特位为1的位置对应的整数就是交集整数。 
 </div> 
 <div> 
  <p>因为数据集中是无符号整数，无符号整数的最大值为0xffffffff，大约为四十二亿九千万，因为要开两个位图，所以要开大约为四十二亿九千万×2个比特位空间作为位图空间，四十二亿九千万×2个比特位空间是1G内存空间。</p> 
 </div> 
</blockquote> 
<blockquote> 
 <p><strong>3.位图应用变形：1个文件有100亿个int，1G内存，设计算法找到出现次数不超过2次的所有整数。</strong></p> 
 <p>答：找在给定的整形数据中出现次数不超过两次的整数，可以将整数出现次数标记为出现0次、出现1次、出现2次，出现3次及以上，刚好是四种状态，那么可以使用两个二进制比特位来代表数据出现次数的信息，如果两个二进制比特位为00，代表出现0次，为01代表出现1次，为10代表出现2次，为11代表出现3次及以上。</p> 
 <div>
   因为数据集中是int，int的最小值为-2147483647-1，最大值为2147483647，范围大约为四十二亿九千万，因为要开两个位图，所以要开大约为四十二亿九千万×2个比特位空间作为位图空间，四十二亿九千万×2个比特位空间是1G内存空间。 
 </div> 
</blockquote> 
<p id=""></p> 
<h3 id="5.3.%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8">5.3.布隆过滤器</h3> 
<blockquote> 
 <div> 
  <strong>1.给两个文件，分别有100亿个query，我们只有1G内存，如何找到两个文件交集？分别给出</strong> 
 </div> 
 <div> 
  <strong>精确算法和近似算法</strong> 
  <span style="color:#777777;"> </span> 
 </div> 
 <div> 
  <strong>精确算法：</strong>假设每个query平均30字节，十亿字节是1G，100亿query就是300G。假设两个文件分别是A文件和B文件，每一个文件是300G，我们进行哈希切割可以模1000，这样每个小文件平均300M，即使个别大一点内存也可以存下。通过哈希函数i=HashFunc(query)%1000将文件A和文件B哈希分割成A0、A1......A999和B0、B1......B999小文件，这样A和B文件中相同的query一定进入了编号相同的小文件，那么A和B文件找交集就转换成了A0和B0找交集、A1和B1找交集......A999和B999找交集。小文件找交集可以将一个小文件中的数据插入set进行去重，然后遍历对应的另一个小文件看每个数据是否在set中，如果在则是交集。 
 </div> 
 <div> 
  <strong>近似算法：</strong>使用布隆过滤器，将一个文件生成对应的布隆过滤器，然后遍历另一个文件数据，如果数据在布隆过滤器中就是交集，不在就不是交集。 
 </div> 
</blockquote> 
<blockquote> 
 <p><strong>2.如何扩展BloomFilter使得它支持删除元素的操作</strong><span style="color:#777777;"> </span></p> 
 <p>答：将布隆过滤器中的每个比特位扩展成一个小的计数器，插入元素时给k个计数器(k个哈希函数计算出的哈希地址)加一，删除元素时，给k个计数器减一。这样每个比特位变成了多个比特位的计数器，通过多占用几倍存储空间（计数器所占空间）的代价来增加删除操作。</p> 
</blockquote> 
<p></p> 
<hr> 
<h2 id="6.%E5%88%86%E5%B8%83%E5%BC%8F%E5%AD%98%E5%82%A8">6.分布式存储</h2> 
<blockquote> 
 <p>例如：腾讯要存储用户朋友圈数据，如何存储。</p> 
 <p>微信有10亿+用户，假设平均每个用户朋友圈占用100M，那么10亿个用户朋友圈总共占用10亿×100M大约1亿G存储空间，1亿G的数据还需要多备份几份，一台机器肯定存不下，需要很多台机器共同存储。</p> 
 <p>那么刷朋友圈请求数据，怎么知道数据在哪台机器上呢？发朋友圈，数据应该存在哪台机器上呢？</p> 
 <p>这就涉及到分布式存储，每一个用户有一个ID，使用哈希映射就能解决问题。如下图所示有100台服务器存储数据，发朋友圈存储数据的时候使用哈希函数i=HashFunc(ID)%100就得到了数据应该存储在编号为几的服务器上。查找的时候也是根据哈希函数将用户ID映射成对应编号的服务器，在对应服务器中查找数据。</p> 
 <p>如果随着每个人的朋友圈数据越来越多，100台服务器的存储空间可能不够了，需要扩展服务器到150台，如果要扩展服务器那么之前的哈希映射关系就全乱了（和哈希表扩容一样），需要重新映射，代价太大。</p> 
 <p>解决方案：一致性哈希。这里作为扩展学习，有兴趣可以自己去了解。</p> 
</blockquote> 
<p></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/c4b1dd8c1c2f2d19f8ee1c88ee6791af/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">蓝桥杯寒假集训第二天（分巧克力）</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/fff4ebbb09cd6badf942256bcdfdc1c7/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">mt4 api跟单接口</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>