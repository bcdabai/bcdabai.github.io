<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>泛型的讲解 - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="泛型的讲解" />
<meta property="og:description" content="泛型的讲解 一、什么是泛型二、引出泛型三、泛型类的使用3.1 语法3.2 示例3.3 类型推导(Type Inference)3.4 裸类型(Raw Type) （了解） 四、泛型如何编译的4.1 擦除机制4.2 为什么不能实例化泛型类型数组 五、泛型的上界5.1 语法5.2 示例5.3 复杂示例5.4 总结 六、泛型方法6.1 定义语法6.2 示例6.3 使用示例-不使用类型推导6.4 使用示例-可以类型推导 七、通配符7.1 通配符解决什么问题7.2 通配符上限7.3 通配符下界 八、 包装类8.1 基本数据类型和对应的包装类8.2 装箱和拆箱8.3 自动装箱和自动拆箱8.4 包装类常用方法 一、什么是泛型 一般的类和方法，只能使用具体的类型: 要么是基本类型，要么是自定义的类。如果要编写可以应用于多种类型的代码，这种刻板的限制对代码的束缚就会很大。
----- 来源《Java编程思想》对泛型的介绍。
泛型是在JDK1.5引入的新的语法，通俗讲，泛型：就是适用于许多许多类型。从代码上讲，就是对类型实现了参数化。
二、引出泛型 实现一个类，类中包含一个数组成员，使得数组中可以存放任何类型的数据，也可以根据成员方法返回数组中某个下标的值？
思路：
我们以前学过的数组，只能存放指定类型的元素，例如：int[] array = new int[10]; String[] strs = new String[10];所有类的父类，默认为Object类。数组是否可以创建为Object? 代码示例：
问题：以上代码实现后 发现
任何类型数据都可以存放1号下标本身就是字符串，但是确编译报错。必须进行强制类型转换：
虽然在这种情况下，当前数组任何数据都可以存放，但是，更多情况下，我们还是希望他只能够持有一种数据类型。而不是同时持有这么多类型。所以，泛型的主要目的：就是指定当前的容器，要持有什么类型的对象。让编译器去做检查。此时，就需要把类型，作为参数传递。需要什么类型，就传入什么类型。
上述代码进行改写如下：
我们发现创建数组时报错了！修改如下：
代码解释：
类名后的 &lt;T&gt; 代表占位符，表示当前类是一个泛型类。
了解： 【规范】类型形参一般使用一个大写字母表示，常用的名称有： E 表示 ElementK 表示 KeyV 表示 ValueN 表示 NumberT 表示 TypeS, U, V 等等 - 第二、第三、第四个类型 不能new泛型类型的数组。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/5d1cb7430205be7c6ec1ca3e2cd9d974/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-10-23T16:07:21+08:00" />
<meta property="article:modified_time" content="2022-10-23T16:07:21+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">泛型的讲解</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p></p> 
<div class="toc"> 
 <h4>泛型的讲解</h4> 
 <ul><li><a href="#_1" rel="nofollow">一、什么是泛型</a></li><li><a href="#_6" rel="nofollow">二、引出泛型</a></li><li><a href="#_47" rel="nofollow">三、泛型类的使用</a></li><li><ul><li><a href="#31__48" rel="nofollow">3.1 语法</a></li><li><a href="#32__54" rel="nofollow">3.2 示例</a></li><li><a href="#33_Type_Inference_61" rel="nofollow">3.3 类型推导(Type Inference)</a></li><li><a href="#34_Raw_Type__75" rel="nofollow">3.4 裸类型(Raw Type) （了解）</a></li></ul> 
  </li><li><a href="#_85" rel="nofollow">四、泛型如何编译的</a></li><li><ul><li><a href="#41__86" rel="nofollow">4.1 擦除机制</a></li><li><a href="#42__101" rel="nofollow">4.2 为什么不能实例化泛型类型数组</a></li></ul> 
  </li><li><a href="#_110" rel="nofollow">五、泛型的上界</a></li><li><ul><li><a href="#51__112" rel="nofollow">5.1 语法</a></li><li><a href="#52__114" rel="nofollow">5.2 示例</a></li><li><a href="#53__120" rel="nofollow">5.3 复杂示例</a></li><li><a href="#54__123" rel="nofollow">5.4 总结</a></li></ul> 
  </li><li><a href="#_129" rel="nofollow">六、泛型方法</a></li><li><ul><li><a href="#61__135" rel="nofollow">6.1 定义语法</a></li><li><a href="#62__138" rel="nofollow">6.2 示例</a></li><li><a href="#63__144" rel="nofollow">6.3 使用示例-不使用类型推导</a></li><li><a href="#64__150" rel="nofollow">6.4 使用示例-可以类型推导</a></li></ul> 
  </li><li><a href="#_153" rel="nofollow">七、通配符</a></li><li><ul><li><a href="#71__155" rel="nofollow">7.1 通配符解决什么问题</a></li><li><a href="#72__174" rel="nofollow">7.2 通配符上限</a></li><li><a href="#73__189" rel="nofollow">7.3 通配符下界</a></li></ul> 
  </li><li><a href="#__200" rel="nofollow">八、 包装类</a></li><li><ul><li><a href="#81__202" rel="nofollow">8.1 基本数据类型和对应的包装类</a></li><li><a href="#82__215" rel="nofollow">8.2 装箱和拆箱</a></li><li><a href="#83__217" rel="nofollow">8.3 自动装箱和自动拆箱</a></li><li><a href="#84__232" rel="nofollow">8.4 包装类常用方法</a></li></ul> 
 </li></ul> 
</div> 
<p></p> 
<h2><a id="_1"></a>一、什么是泛型</h2> 
<blockquote> 
 <p>一般的类和方法，只能使用具体的类型: 要么是基本类型，要么是自定义的类。如果要编写可以应用于多种类型的代码，这种刻板的限制对代码的束缚就会很大。<br> ----- 来源《Java编程思想》对泛型的介绍。</p> 
</blockquote> 
<p>泛型是在JDK1.5引入的新的语法，通俗讲，泛型：<strong>就是适用于许多许多类型</strong>。从代码上讲，就是<strong>对类型实现了参数化</strong>。</p> 
<h2><a id="_6"></a>二、引出泛型</h2> 
<p>实现一个类，类中包含一个数组成员，使得数组中可以存放任何类型的数据，也可以根据成员方法返回数组中某个下标的值？<br> 思路：</p> 
<ol><li>我们以前学过的数组，只能存放指定类型的元素，例如：int[] array = new int[10]; String[] strs = new String[10];</li><li>所有类的父类，默认为Object类。数组是否可以创建为Object?</li></ol> 
<p>代码示例：<br> <img src="https://images2.imgbox.com/25/e6/86PpWgv8_o.png" alt="在这里插入图片描述" height="250"><br> <img src="https://images2.imgbox.com/5f/c2/RTai3M6S_o.png" alt="在这里插入图片描述" height="250"></p> 
<p>问题：以上代码实现后 发现</p> 
<ol><li>任何类型数据都可以存放</li><li>1号下标本身就是字符串，但是确编译报错。必须进行强制类型转换：<br> <img src="https://images2.imgbox.com/0d/00/u5I32rXs_o.png" alt="在这里插入图片描述"></li></ol> 
<p>虽然在这种情况下，当前数组任何数据都可以存放，但是，更多情况下，我们还是希望他只能够持有一种数据类型。而不是同时持有这么多类型。<strong>所以，泛型的主要目的：就是指定当前的容器，要持有什么类型的对象。让编译器去做检查</strong>。此时，就需要把类型，作为参数传递。需要什么类型，就传入什么类型。<br> <img src="https://images2.imgbox.com/53/cc/eniSWLHm_o.png" alt="在这里插入图片描述" height="120"><br> <img src="https://images2.imgbox.com/a9/e6/L5VU2E3m_o.png" alt="在这里插入图片描述" height="130"></p> 
<p><mark>上述代码进行改写如下：</mark><br> <img src="https://images2.imgbox.com/10/6a/lq2N5da9_o.png" alt="在这里插入图片描述" height="300"><br> <mark>我们发现创建数组时报错了！修改如下：</mark><br> <img src="https://images2.imgbox.com/4e/86/ckkWgrKe_o.png" alt="在这里插入图片描述" height="50"><br> <img src="https://images2.imgbox.com/ae/80/rHdncehW_o.png" alt="在这里插入图片描述" height="320"><br> 代码解释：</p> 
<ol><li>类名后的 <code>&lt;T&gt;</code> 代表<strong>占位符</strong>，表示当前类是一个<strong>泛型类</strong>。<br> 了解： 【规范】类型形参一般使用一个大写字母表示，常用的名称有：</li></ol> 
<blockquote> 
 <ul><li>E 表示 Element</li><li>K 表示 Key</li><li>V 表示 Value</li><li>N 表示 Number</li><li>T 表示 Type</li><li>S, U, V 等等 - 第二、第三、第四个类型</li></ul> 
</blockquote> 
<ol start="2"><li> <p>不能new泛型类型的数组。<br> 意味着：<code>T[] ts = new T[5];//是不对的</code><br> 课件当中的代码：<code>T[] array = (T[])new Object[10];</code>是否就足够好？答案是未必的。</p> </li><li> <p>&lt;&gt;内一定<strong>必须是类类型</strong>，不能是基本类型。<br> <img src="https://images2.imgbox.com/b1/77/L2FEqxGZ_o.png" alt="在这里插入图片描述"></p> </li></ol> 
<h2><a id="_47"></a>三、泛型类的使用</h2> 
<h3><a id="31__48"></a>3.1 语法</h3> 
<pre><code class="prism language-java">泛型类<span class="token operator">&lt;</span>类型实参<span class="token operator">&gt;</span> 变量名<span class="token punctuation">;</span> <span class="token comment">// 定义一个泛型类引用</span>
<span class="token keyword">new</span> 泛型类<span class="token operator">&lt;</span>类型实参<span class="token operator">&gt;</span><span class="token punctuation">(</span>构造方法实参<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 实例化一个泛型类对象</span>
</code></pre> 
<h3><a id="32__54"></a>3.2 示例</h3> 
<pre><code class="prism language-java"><span class="token class-name">MyArray</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">&gt;</span></span> list <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">MyArray</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> 
<p><strong>注意：泛型只能接受类，所有的基本数据类型必须使用包装类！</strong></p> 
<h3><a id="33_Type_Inference_61"></a>3.3 类型推导(Type Inference)</h3> 
<p>当编译器可以根据上下文推导出类型实参时，可以省略类型实参的填写</p> 
<pre><code class="prism language-java"><span class="token class-name">MyArray</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">&gt;</span></span> list <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">MyArray</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> 
<span class="token comment">// 可以推导出实例化需要的类型实参为 String</span>
</code></pre> 
<p><strong>小结：</strong></p> 
<ol><li>泛型是将数据类型参数化，进行传递</li><li>类名后的 <code>&lt;T&gt;</code> 代表占位符，表示当前类是一个泛型类</li><li>泛型目前为止的优点：数据类型参数化，编译时自动进行类型检查和转换</li></ol> 
<h3><a id="34_Raw_Type__75"></a>3.4 裸类型(Raw Type) （了解）</h3> 
<p>裸类型是一个泛型类但没有带着类型实参，例如 MyArrayList 就是一个裸类型：<br> （就没有使用到泛型）</p> 
<pre><code class="prism language-java"><span class="token class-name">MyArray</span> list <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">MyArray</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// 或者</span>
<span class="token class-name">MyArray</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">&gt;</span></span> list <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">MyArray</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> 
<p><strong>注意</strong>： 我们不要自己去使用裸类型，裸类型是为了兼容老版本的 API 保留的机制</p> 
<h2><a id="_85"></a>四、泛型如何编译的</h2> 
<h3><a id="41__86"></a>4.1 擦除机制</h3> 
<p>那么，泛型到底是怎么编译的？<br> 通过命令：javap -c 查看字节码文件，所有的T都是Object。<br> <img src="https://images2.imgbox.com/9f/56/NQgzbtt6_o.png" alt="在这里插入图片描述"><br> 在编译的过程当中，将所有的T替换为Object这种机制，我们称为：<strong>擦除机制</strong>。<br> Java的泛型机制是在编译级别实现的。编译器生成的字节码在运行期间并不包含泛型的类型信息。<br> <mark>可以理解为：在编译的时候，会先拿着&lt;&gt;内的类型去检查数据与类型是否匹配，检查完之后，擦除机制会使所有的类型都转换为Object。</mark><br> 这样我们可以更好的理解：<img src="https://images2.imgbox.com/d7/17/Kzsib03j_o.png" alt="在这里插入图片描述"></p> 
<hr> 
<p>例子：<br> <img src="https://images2.imgbox.com/c1/10/bAlXkbrl_o.png" alt="在这里插入图片描述" height="200"><br> 因为<strong>擦除机制</strong>，所以 ：<br> <img src="https://images2.imgbox.com/3e/e0/1Dpa5kK0_o.png" alt="在这里插入图片描述" height="150"></p> 
<h3><a id="42__101"></a>4.2 为什么不能实例化泛型类型数组</h3> 
<p>代码1：<br> <img src="https://images2.imgbox.com/8d/a1/L2fNt8H2_o.png" alt="在这里插入图片描述" height="400"><br> <img src="https://images2.imgbox.com/e0/ac/8iN5MRxU_o.png" alt="在这里插入图片描述"><br> 原因：替换后的方法为：将Object[]分配给Integer[]引用，程序报错。<br> <strong>数组和泛型之间的一个重要区别是它们如何强制执行类型检查。</strong> 具体来说，数组在运行时存储和检查类型信息。然而，泛型在编译时检查类型错误。<br> 通俗讲就是：返回的Object数组里面，可能存放的是任何的数据类型，可能是String，可能是Person，运行的时候，直接转给Intefer类型的数组，编译器认为是不安全的。<br> <em><strong>正确的方式：通过反射创建，指定类型的数组</strong></em></p> 
<h2><a id="_110"></a>五、泛型的上界</h2> 
<p>在定义泛型类时，有时需要对传入的类型变量做一定的约束，可以通过类型边界来约束。</p> 
<h3><a id="51__112"></a>5.1 语法</h3> 
<p><img src="https://images2.imgbox.com/09/94/DyrO3ovk_o.png" alt="在这里插入图片描述" height="70"></p> 
<h3><a id="52__114"></a>5.2 示例</h3> 
<p><img src="https://images2.imgbox.com/1c/ae/zmlMtufI_o.png" alt="在这里插入图片描述" height="71"><br> <strong>只接受 Number 的子类型或者 Number 本身作为 E 的类型实参。</strong><br> <img src="https://images2.imgbox.com/c8/f9/ogcfPPjY_o.png" alt="在这里插入图片描述" height="50"><br> <img src="https://images2.imgbox.com/6f/87/YzM5JBYr_o.png" alt="在这里插入图片描述" height="100"><br> <strong>了解：</strong> 没有指定类型边界 E，可以视为 E extends Object</p> 
<h3><a id="53__120"></a>5.3 复杂示例</h3> 
<p><img src="https://images2.imgbox.com/89/d1/C4G8vTlh_o.png" alt="在这里插入图片描述" height="70"><br> <strong>E必须是实现了Comparable接口的。</strong></p> 
<h3><a id="54__123"></a>5.4 总结</h3> 
<p><mark>综上，若extends的是一个类：只接受其子类型或者本身作为类型实参；<br> 若extends的是一个接口：必须是实现了这个接口的。</mark></p> 
<hr> 
<p><mark>当存在泛型上界时，擦除机制会擦除成泛型上界类型。</mark></p> 
<h2><a id="_129"></a>六、泛型方法</h2> 
<p><img src="https://images2.imgbox.com/3b/dc/H4Qko0J4_o.png" alt="在这里插入图片描述" height="150"></p> 
<hr> 
<p><img src="https://images2.imgbox.com/6f/03/8wafif3D_o.png" alt="在这里插入图片描述" height="110"></p> 
<h3><a id="61__135"></a>6.1 定义语法</h3> 
<p><mark>分为普通泛型方法和静态泛型方法。</mark><br> <img src="https://images2.imgbox.com/04/f3/kZNqIFow_o.png" alt="在这里插入图片描述"></p> 
<h3><a id="62__138"></a>6.2 示例</h3> 
<p><img src="https://images2.imgbox.com/b2/1d/eKxmPBpm_o.png" alt="在这里插入图片描述" height="250"></p> 
<hr> 
<p><img src="https://images2.imgbox.com/b2/bb/40FNVKuq_o.png" alt="在这里插入图片描述"></p> 
<h3><a id="63__144"></a>6.3 使用示例-不使用类型推导</h3> 
<p><img src="https://images2.imgbox.com/90/56/QC7zaSQo_o.png" alt="在这里插入图片描述" height="210"></p> 
<hr> 
<p><img src="https://images2.imgbox.com/53/4a/ALVTRklt_o.png" alt="在这里插入图片描述"></p> 
<h3><a id="64__150"></a>6.4 使用示例-可以类型推导</h3> 
<p>普通泛型方法同。<br> <img src="https://images2.imgbox.com/ac/09/KsXXqcR0_o.png" alt="在这里插入图片描述"></p> 
<h2><a id="_153"></a>七、通配符</h2> 
<p><code>?</code> 用于在泛型的使用，即为通配符</p> 
<h3><a id="71__155"></a>7.1 通配符解决什么问题</h3> 
<p><strong>通配符是用来解决泛型无法协变的问题的</strong>，协变指的就是如果 <code>Student</code> 是 <code>Person</code> 的子类，那么 <code>List&lt;Student&gt;</code> 也应该是 <code>List&lt;Person&gt;</code> 的子类。但是泛型是不支持这样的父子类关系的。</p> 
<blockquote> 
 <p>泛型 <code>T</code> 是确定的类型，一旦你传了我就定下来了，而通配符则更为灵活或者说是不确定，更多的是用于扩充参数的范围。</p> 
</blockquote> 
<p>示例：<br> <img src="https://images2.imgbox.com/4d/50/TkKqlxtn_o.png" alt="在这里插入图片描述" height="170"><br> <img src="https://images2.imgbox.com/eb/7b/RyAkJyjs_o.png" alt="在这里插入图片描述" height="70"><br> <img src="https://images2.imgbox.com/15/5c/EkmHTzgl_o.png" alt="在这里插入图片描述" height="215"><br> 以上程序会带来新的问题，如果现在泛型的类型设置的不是String，而是Integer：<br> <img src="https://images2.imgbox.com/69/c5/Q7wiTfFz_o.png" alt="在这里插入图片描述" height="220"><br> 我们需要的解决方案：可以接收所有的泛型类型，但是又不能够让用户随意修改。这种情况就需要使用通配符"?“来处理<br> 范例：使用通配符：<br> <mark>一般情况下：只能取不能放。</mark><br> <mark>因为此时使用通配符"?"描述的是它可以接收任意类型，但是由于不确定类型，所以无法修改</mark><br> <img src="https://images2.imgbox.com/b6/58/RSr2BKcG_o.png" alt="在这里插入图片描述" height="260"><br> 在”?"的基础上又产生了两个子通配符：</p> 
<blockquote> 
 <p>? extends 类：设置通配符上限<br> ? super 类：设置通配符下限</p> 
</blockquote> 
<h3><a id="72__174"></a>7.2 通配符上限</h3> 
<p><strong>语法：</strong><br> <img src="https://images2.imgbox.com/45/4a/yzRfeOwx_o.png" alt="在这里插入图片描述" height="65"><br> <img src="https://images2.imgbox.com/3b/54/R1APAiMI_o.png" alt="在这里插入图片描述"><br> 示例：<br> <img src="https://images2.imgbox.com/d4/fa/fJ5t8AJ3_o.png" alt="在这里插入图片描述"><br> <img src="https://images2.imgbox.com/a1/e8/l9HY3pfC_o.png" alt="在这里插入图片描述" height="220"><br> 此时无法在fun函数中对temp进行添加元素，因为temp接收的是Fruit和他的子类，此时存储的元素应该是哪个子类无法确定，可能会发生向下转型。所以添加会报错！但是可以获取元素。<br> <img src="https://images2.imgbox.com/26/2d/77pCJ3gG_o.png" alt="在这里插入图片描述"><br> <mark>此时可以用通配符上界Fruit接收（get）：可能会发生向上转型。</mark><br> <img src="https://images2.imgbox.com/39/db/YVtYX1Bg_o.png" alt="在这里插入图片描述"><br> new Fruit也不可行：站在编译器的角度，它并不知道我们new的是什么，且若发生向下转型不安全，所以<strong>都会报错</strong>。</p> 
<p>设置通配符上限，<strong>不能进行写入数据，只能进行读取数据</strong>。</p> 
<h3><a id="73__189"></a>7.3 通配符下界</h3> 
<p><strong>语法：</strong><br> <img src="https://images2.imgbox.com/2c/fe/GSfiGB4W_o.png" alt="在这里插入图片描述"><br> <img src="https://images2.imgbox.com/d9/e1/puglMr5L_o.png" alt="在这里插入图片描述"><br> 示例：<br> <img src="https://images2.imgbox.com/e2/ee/hu8x5mxH_o.png" alt="在这里插入图片描述"><br> <img src="https://images2.imgbox.com/29/c1/jN4CeolI_o.png" alt="在这里插入图片描述"><br> <img src="https://images2.imgbox.com/d4/99/RG1crEnY_o.png" alt="在这里插入图片描述"><br> <mark>可以放（set）通配符下界的本身或者其子类。</mark><br> <mark>get不能接收，因为无法确定，所以可能会发生向下转型；但是可以直接输出。</mark><br> 设置通配符下限，不能进行读取数据，<strong>只能写入数据</strong>。</p> 
<h2><a id="__200"></a>八、 包装类</h2> 
<p>在Java中，由于基本类型不是继承自Object，为了在泛型代码中可以支持基本类型，Java给每个基本类型都对应了一个包装类型。</p> 
<h3><a id="81__202"></a>8.1 基本数据类型和对应的包装类</h3> 
<table><thead><tr><th>基本数据类型</th><th>包装类</th></tr></thead><tbody><tr><td>byte</td><td>Byte</td></tr><tr><td>short</td><td>Short</td></tr><tr><td>int</td><td>Integer</td></tr><tr><td>long</td><td>Long</td></tr><tr><td>float</td><td>Float</td></tr><tr><td>double</td><td>Double</td></tr><tr><td>char</td><td>Character</td></tr><tr><td>boolean</td><td>Boolean</td></tr></tbody></table> 
<p>除了 Integer 和 Character， 其余基本类型的包装类都是首字母大写。</p> 
<h3><a id="82__215"></a>8.2 装箱和拆箱</h3> 
<p><img src="https://images2.imgbox.com/ba/2d/ueH0dOv3_o.png" alt="在这里插入图片描述" height="180"></p> 
<h3><a id="83__217"></a>8.3 自动装箱和自动拆箱</h3> 
<p>可以看到在使用过程中，装箱和拆箱带来不少的代码量，所以为了减少开发者的负担，java 提供了自动机制。<br> <img src="https://images2.imgbox.com/36/8e/U5xclujA_o.png" alt="在这里插入图片描述" height="160"></p> 
<hr> 
<p><img src="https://images2.imgbox.com/a7/4c/4Ae8dQR5_o.png" alt="在这里插入图片描述" height="80"></p> 
<hr> 
<p><img src="https://images2.imgbox.com/ce/33/OaTFRUoG_o.png" alt="在这里插入图片描述"></p> 
<hr> 
<p><mark>也可以拆箱为其他基本类型：</mark><br> <img src="https://images2.imgbox.com/f7/95/NkDNrTMo_o.png" alt="在这里插入图片描述"></p> 
<hr> 
<h3><a id="84__232"></a>8.4 包装类常用方法</h3> 
<ul><li>将字符串转化为整数：<code>Integer.parseInt(s)</code></li></ul> 
<hr> 
<p>【面试题】<br> 下列代码输出什么，为什么？<br> <img src="https://images2.imgbox.com/26/fe/rwljM2Ry_o.png" alt="在这里插入图片描述" height="210"><br> 运行结果：<br> <img src="https://images2.imgbox.com/a1/65/vAPkEAHJ_o.png" alt="在这里插入图片描述"><br> 解析：注意valueOf源码：<br> <img src="https://images2.imgbox.com/37/e9/Aosow2Pu_o.png" alt="在这里插入图片描述"><br> <mark>在-128~127之间的话在数组里取，否则new一个新对象！！！</mark><br> 这样做的好处就是这些频繁使用到的小的数据不需要每次进行new了。</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/7482ef8a88a4a93238e86ffc0c45441e/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">【Spring Boot】整合Mybatis与Mybatis-plus</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/43778f22806c492fcace7bc85e8cb984/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">【测试面试】2022年软件测试面试题大全（附答案）</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>