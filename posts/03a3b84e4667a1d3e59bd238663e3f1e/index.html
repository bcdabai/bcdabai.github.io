<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Hadoop生态系统之Hive和HBase and Zookeeper - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Hadoop生态系统之Hive和HBase and Zookeeper" />
<meta property="og:description" content=" 今天来说一下Hadoop生态系统中的Zookeeper,HBase,Hive,说到Zookeeper简单来说其实就是Hadoop分布式框架的一个协调服务,也就是分布式应用都需要一个主控协调器或者控制器来管理物理分布的子进程.那再说的明白点就是:Zookeeper在hadoop生态系统中的集群担任着非常重要的责任.集群中的资源调配或者是服务的切换,都得需要他去管理.所以说在Hadoop生态系统中Hadoop是一头大象,而Zookeeper却是一个动物园的管理员.至于图这里就不展示了.百度一搜就有的.对了.告诉大家一个秘诀,学习Hadoop生态系统的前期,自己从网上下载一张这样的图解.特别有用.####特别推荐啊#### 好了,言归正传啊.这个Zookeeper他包含一个简单的原语集,分布式应用可以通过它,来实现一些同步服务,配置的服务和命名服务等.我们都知道Hadoop2.0时代迎来了高可用.那么Zookeeper怎么才能做到高可用那?那么他的机制里边有一个leader和一些Follower当这个leader挂掉的时候这些Follower就会通过特殊的机制选出一个leader来.那么究竟这个leader和Follower到底是什么那,他们到底是干什么的那?我们可以这样倒着想.我们刚才说Zookeeper是一个协调机制,那么他既然要去维持这个生态系统,那么他就要主控HDFS中的nameNode因为控制住了nameNode就真正的做到了协调者的这个角色.所以他要保证整个集群,要有一个活跃的nameNode这样才能够存储到dataNode上信息.才能够完成MapReduce和yarn机制.(服务).那么这个leader中就有这样一个机制,(他是监控整个集群的,如果说一个集群七台机器的话,我就会有两台搭载nameNode两台搭载resourceManager然后如果说其中一台的nameNode挂掉了,然后这个Leader和Follower就会有一个具体的选举机制,然后再选举另外一台nameNode的机器,以保证正常的数据支持.)而Zookeeper中也有一个叫qjournal的机制目的在于(我们都知道在nameNode上有一个叫editsLog这个日志文件是要和nameNode的镜像文件去合并,从而达到更新nameNode.然后这个editsLog就存在于在这个qjournal这样的每一个edits文件就叫做一个qjournalnode,而zookeeper集群中也有一个叫ZKFC的机制目的就在于一个nameNode为active一个为Standby当active挂掉的时候ZKFC会告诉Zookeeper 并且执行一些Kill active服务的机制 从而达到Standby上任的这样一个目的) 我们刚才说过Zookeeper是一个搭建集群的服务,因为他是一个协调框架.所以在搭建集群的时候需要给他配置两个配置文件(具体是什么,自己去上百度搜索,那速度嗖嗖的) 继续来说一下HBase首先他是一个分布式,版本化,面向列的数据库.构建在Hadoop上和Zookeeper上.可以用HBase技术在廉价的PC Server上搭建起大规模的结构化存储集群.HBase利用Hadoop中的HDFS作为其文件系统用Zookeeper作为协调工具.用Hadoop中的MapReduce作为其的计算系统来为他处理海量数据.HBase中的主键是用来检索记录的主键,访问HBase table中的行,而HBase中的列族,一个列族可以包含多个列,列中的数据都是以二进制的形式存在的,没有数据类型.列也称为:列名和列的标识符,行有一个叫行标的标识符.这样就可以把一条数据根据列来显示出来.&#39;&#43;&#39;像十字架一样相交的才是数据.启动HBase:HBase如果启动一个单节点的是不需要任何配置文件的这里我们只说单节点的配置文件,后序会引出来集群.先要进入/bin文件,然后先启动服务, ./start-hbase.sh 之后在启动客户端, ./hbase shell这样一执行这样一个面向列的数据库就启动了.对了,忘了声明一点,HBase是按住ctrl加backspace才是从后往前删除,如果单单是按住backspace的话是从前往后删除的.归根到底其实HBase就是一个存放数据的载体,就比如Windows用的NTFS文件系统,怎么才能读到其中所有的数据那,那么我就会用一个数据库去访问本地的资源或者连接网络通过网络让外部的计算机可以通过服务器中的数据库来访问我的本地资源,那么同样别的计算机也可以通过网络流来向我传输一些文件.这样整体的一个数据访问系统的目的就达到了.那么同样的道理,我在Hadoop生态系统上,用HBase数据库的目的也是在于我Hadoop可以获取数据,然后再交给MapReduce去计算得到用户想要的数据.以上均为个人理解,如果有什么差别之处,望指明. 最后来说一下Hive:Hive是建立在Hadoop上的数据仓库基础架构,它提供了一系列的工具,可以用来进行提取转化加载这是一种可以存储 查询和分析存储在Hadoop中的大规模数据的机制.Hive定义了简单的类SQL语言,称为QL,同时这个语言也允许熟悉MapReduce处理过程中无法mapper和reducer无法完成的复杂的分析工作.Hive的系统架构是:用户接口:包括Java中连接数据库的JDBC/ODBC,WebUI,CLI.元数据的存储一般放在MySql或者derby数据库中(derby很迷你,但是漏洞很多比如他是一个单例的他是用Java编写的一个数据库存储系统),解释器,编译器,优化器,执行器,Hadoop:利用HDFS来进行存储,利用MapReduce来计算海量数据.总结一下,Hive主要是在MapReduce处理不了的时候派上用场.因为什么东西不是万能的,总会有弊端的,所以说,在MapReduce无法完成的任务的之后,还有Hive去为你排忧艰难.这是最基本的用处.还有一个用处就是我们在文上也说过了,它是一个数据仓库,也就是说用来存储数据的,说到存储数据了,我们就会想到数据库,但是他和数据库最根本的区别就是一点:他是把数据存放在HDFS上的,但是数据库是一个自我的数据存储系统,所以说两者不可混淆,当然了,你只需要记住Hive是把数据存放在HDFS上的但是他还能够帮助MapReduce来计算数据,所以他要 依托着Hadoop的.而HBase却是一个存放数据的载体,而他的功能是写入是数据和读出来数据,这是他俩的根本的区别.OK The End Today.我刚学习的时候也总是理解不清楚,但是有贵人指路,终于可以在这里给你们写文档了.这是多么艰难的一件事情啊.所以说遇到问题要积极的面对而且自己心里要知道,这是在学习的时候最应该遇到的,该踩的坑都踩了,那么你就牛逼了.Be strong , Believe in who you are; " />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/03a3b84e4667a1d3e59bd238663e3f1e/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2017-10-19T15:45:59+08:00" />
<meta property="article:modified_time" content="2017-10-19T15:45:59+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Hadoop生态系统之Hive和HBase and Zookeeper</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <h3>今天来说一下<strong>Hadoop生态系统中的Zookeeper,HBase,Hive</strong>,说到Zookeeper简单来说其实就是Hadoop分布式框架的一个协调服务,也就是分布式应用都需要一个主控协调器或者控制器来管理物理分布的子进程.那再说的明白点就是:Zookeeper在hadoop生态系统中的集群担任着非常重要的责任.集群中的资源调配或者是服务的切换,都得需要他去管理.所以说在Hadoop生态系统中Hadoop是一头大象,而Zookeeper却是一个动物园的管理员.至于图这里就不展示了.百度一搜就有的.对了.告诉大家一个秘诀,学习Hadoop生态系统的前期,自己从网上下载一张这样的图解.特别有用.####特别推荐啊####</h3> 好了,言归正传啊.这个Zookeeper他包含一个简单的原语集,分布式应用可以通过它,来实现一些同步服务,配置的服务和命名服务等.我们都知道Hadoop2.0时代迎来了高可用.那么Zookeeper怎么才能做到高可用那?那么他的机制里边有一个leader和一些Follower当这个leader挂掉的时候这些Follower就会通过特殊的机制选出一个leader来.那么究竟这个leader和Follower到底是什么那,他们到底是干什么的那?我们可以这样倒着想.我们刚才说Zookeeper是一个协调机制,那么他既然要去维持这个生态系统,那么他就要主控HDFS中的nameNode因为控制住了nameNode就真正的做到了协调者的这个角色.所以他要保证整个集群,要有一个活跃的nameNode这样才能够存储到dataNode上信息.才能够完成MapReduce和yarn机制.(服务).那么这个leader中就有这样一个机制,(他是监控整个集群的,如果说一个集群七台机器的话,我就会有两台搭载nameNode两台搭载resourceManager然后如果说其中一台的nameNode挂掉了,然后这个Leader和Follower就会有一个具体的选举机制,然后再选举另外一台nameNode的机器,以保证正常的数据支持.)而Zookeeper中也有一个叫qjournal的机制目的在于(我们都知道在nameNode上有一个叫editsLog这个日志文件是要和nameNode的镜像文件去合并,从而达到更新nameNode.然后这个editsLog就存在于在这个qjournal这样的每一个edits文件就叫做一个qjournalnode,而zookeeper集群中也有一个叫ZKFC的机制目的就在于一个nameNode为active一个为Standby当active挂掉的时候ZKFC会告诉Zookeeper 并且执行一些Kill active服务的机制 从而达到Standby上任的这样一个目的) 
<br> 我们刚才说过Zookeeper是一个搭建集群的服务,因为他是一个协调框架.所以在搭建集群的时候需要给他配置两个配置文件(具体是什么,自己去上百度搜索,那速度嗖嗖的)     
<br> 
<br> 继续来说一下HBase首先他是一个分布式,版本化,面向列的数据库.构建在Hadoop上和Zookeeper上.可以用HBase技术在廉价的PC Server上搭建起大规模的结构化存储集群.HBase利用Hadoop中的HDFS作为其文件系统用Zookeeper作为协调工具.用Hadoop中的MapReduce作为其的计算系统来为他处理海量数据.HBase中的主键是用来检索记录的主键,访问HBase table中的行,而HBase中的列族,一个列族可以包含多个列,列中的数据都是以二进制的形式存在的,没有数据类型.列也称为:列名和列的标识符,行有一个叫行标的标识符.这样就可以把一条数据根据列来显示出来.'+'像十字架一样相交的才是数据.启动HBase:HBase如果启动一个单节点的是不需要任何配置文件的这里我们只说单节点的配置文件,后序会引出来集群.先要进入/bin文件,然后先启动服务,  ./start-hbase.sh  之后在启动客户端, ./hbase shell这样一执行这样一个面向列的数据库就启动了.对了,忘了声明一点,HBase是按住ctrl加backspace才是从后往前删除,如果单单是按住backspace的话是从前往后删除的.归根到底其实HBase就是一个存放数据的载体,就比如Windows用的NTFS文件系统,怎么才能读到其中所有的数据那,那么我就会用一个数据库去访问本地的资源或者连接网络通过网络让外部的计算机可以通过服务器中的数据库来访问我的本地资源,那么同样别的计算机也可以通过网络流来向我传输一些文件.这样整体的一个数据访问系统的目的就达到了.那么同样的道理,我在Hadoop生态系统上,用HBase数据库的目的也是在于我Hadoop可以获取数据,然后再交给MapReduce去计算得到用户想要的数据.以上均为个人理解,如果有什么差别之处,望指明. 
<br> 
<br> 
<br> 最后来说一下Hive:Hive是建立在Hadoop上的数据仓库基础架构,它提供了一系列的工具,可以用来进行提取转化加载这是一种可以存储 查询和分析存储在Hadoop中的大规模数据的机制.Hive定义了简单的类SQL语言,称为QL,同时这个语言也允许熟悉MapReduce处理过程中无法mapper和reducer无法完成的复杂的分析工作.Hive的系统架构是:用户接口:包括Java中连接数据库的JDBC/ODBC,WebUI,CLI.元数据的存储一般放在MySql或者derby数据库中(derby很迷你,但是漏洞很多比如他是一个单例的他是用Java编写的一个数据库存储系统),解释器,编译器,优化器,执行器,Hadoop:利用HDFS来进行存储,利用MapReduce来计算海量数据.总结一下,Hive主要是在MapReduce处理不了的时候派上用场.因为什么东西不是万能的,总会有弊端的,所以说,在MapReduce无法完成的任务的之后,还有Hive去为你排忧艰难.这是最基本的用处.还有一个用处就是我们在文上也说过了,它是一个数据仓库,也就是说用来存储数据的,说到存储数据了,我们就会想到数据库,但是他和数据库最根本的区别就是一点:他是把数据存放在HDFS上的,但是数据库是一个自我的数据存储系统,所以说两者不可混淆,当然了,你只需要记住Hive是把数据存放在HDFS上的但是他还能够帮助MapReduce来计算数据,所以他要 依托着Hadoop的.而HBase却是一个存放数据的载体,而他的功能是写入是数据和读出来数据,这是他俩的根本的区别.OK The End Today.我刚学习的时候也总是理解不清楚,但是有贵人指路,终于可以在这里给你们写文档了.这是多么艰难的一件事情啊.所以说遇到问题要积极的面对而且自己心里要知道,这是在学习的时候最应该遇到的,该踩的坑都踩了,那么你就牛逼了.Be strong , Believe in who you are;
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/4a3fe66cd849a175367ec4eccc90e836/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">intellij idea Swing GUI</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/d32e336ddf8c3e24304a8cf602d461ec/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">万能近似定理（universal approximation theorrm）</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>