<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>WebApi 接口参数不再困惑：传参详解 Get - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="WebApi 接口参数不再困惑：传参详解 Get" />
<meta property="og:description" content="一、get请求 对于取数据，我们使用最多的应该就是get请求了吧。下面通过几个示例看看我们的get请求参数传递。
回到顶部
1、基础类型参数 [HttpGet] public string GetAllChargingData(int id, string name) { return &#34;ChargingData&#34; &#43; id; } $.ajax({ type: &#34;get&#34;, url: &#34;http://localhost:27221/api/Charging/GetAllChargingData&#34;, data: { id: 1, name: &#34;Jim&#34;, bir: &#34;1988-09-11&#34;}, success: function (data, status) { if (status == &#34;success&#34;) { $(&#34;#div_test&#34;).html(data); } } }); 参数截图效果
2、实体作为参数 如果我们在get请求时想将实体对象做参数直接传递到后台，是否可行呢？我们来看看。
public class TB_CHARGING { /// &lt;summary&gt; /// 主键Id /// &lt;/summary&gt; public string ID { get; set; } /// &lt;summary&gt; /// 充电设备名称 /// &lt;/summary&gt; public string NAME { get; set; } /// &lt;summary&gt; /// 充电设备描述 /// &lt;/summary&gt; public string DES { get; set; } /// &lt;summary&gt; /// 创建时间 /// &lt;/summary&gt; public DateTime CREATETIME { get; set; } } [HttpGet] public string GetByModel(TB_CHARGING oData) { return &#34;" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/e355c4010f2d9ca30ec19f785ff96bb1/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2019-02-14T20:37:57+08:00" />
<meta property="article:modified_time" content="2019-02-14T20:37:57+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">WebApi 接口参数不再困惑：传参详解 Get</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <h2>一、get请求</h2> 
<p>对于取数据，我们使用最多的应该就是get请求了吧。下面通过几个示例看看我们的get请求参数传递。</p> 
<p><a href="http://www.cnblogs.com/landeanfen/p/5337072.html#_labelTop" rel="nofollow">回到顶部</a><a name="_label0_0"></a></p> 
<h3>1、基础类型参数</h3> 
<pre class="has"><code>[HttpGet]
public string GetAllChargingData(int id, string name)
{
    return "ChargingData" + id;
}</code></pre> 
<pre class="has"><code>$.ajax({
        type: "get",
        url: "http://localhost:27221/api/Charging/GetAllChargingData",
        data: { id: 1, name: "Jim", bir: "1988-09-11"},
        success: function (data, status) {
            if (status == "success") {
                $("#div_test").html(data);
            }
        }
    });</code></pre> 
<p>参数截图效果<img alt="" class="has" height="197" src="https://images2.imgbox.com/16/f0/EoZc9GD9_o.gif" width="762"></p> 
<h3>2、实体作为参数</h3> 
<p>如果我们在get请求时想将实体对象做参数直接传递到后台，是否可行呢？我们来看看。</p> 
<pre class="has"><code>public class TB_CHARGING
    {
        /// &lt;summary&gt;
        /// 主键Id
        /// &lt;/summary&gt;
        public string ID { get; set; }

        /// &lt;summary&gt;
        /// 充电设备名称
        /// &lt;/summary&gt;
        public string NAME { get; set; }

        /// &lt;summary&gt;
        /// 充电设备描述
        /// &lt;/summary&gt;
        public string DES { get; set; }

        /// &lt;summary&gt;
        /// 创建时间
        /// &lt;/summary&gt;
        public DateTime CREATETIME { get; set; }
    }</code></pre> 
<pre class="has"><code>[HttpGet]
public string GetByModel(TB_CHARGING oData)
{
     return "ChargingData" + oData.ID;
}</code></pre> 
<pre class="has"><code>      type: "get",
        url: "http://localhost:27221/api/Charging/GetByModel",
        contentType: "application/json",
        data: { ID: "1", NAME: "Jim", CREATETIME: "1988-09-11" },
        success: function (data, status) {
            if (status == "success") {
                $("#div_test").html(data);
            }
        }
    });</code></pre> 
<p>测试结果<img alt="" class="has" height="174" src="https://images2.imgbox.com/ca/87/DeJellMb_o.gif" width="597"></p> 
<p>由上图可知，在get请求时，我们直接将json对象当做实体传递后台，后台是接收不到的。这是为什么呢？我们来看看对应的http请求<img alt="" class="has" src="https://images2.imgbox.com/54/0c/hB6Fg9xF_o.png"> </p> 
<p>原来，get请求的时候，默认是将参数全部放到了url里面直接以string的形式传递的，后台自然接不到了。</p> 
<p>原因分析：<strong>还记得有面试题问过get和post请求的区别吗？其中有一个区别就是get请求的数据会附在URL之后（就是把数据放置在HTTP协议头中），而post请求则是放在http协议包的包体中。</strong></p> 
<p>根据园友们的提议，Get请求的时候可以在参数里面加上[FromUri]即可直接得到对象。还是贴上代码：</p> 
<pre class="has"><code>var postdata = { ID: "1", NAME: "Jim", CREATETIME: "1988-09-11" };
    $.ajax({
        type: "get",
        url: "http://localhost:27221/api/Charging/GetAllChargingData",
        data: postdata,
        success: function (data, status) { }
    });



 [HttpGet]
        public string GetAllChargingData([FromUri]TB_CHARGING obj)
        {
            return "ChargingData" + obj.ID;
        }</code></pre> 
<p> 得到结果：<img alt="" class="has" src="https://images2.imgbox.com/56/60/ATNtfWqC_o.png"></p> 
<p> 如果你不想使用[FromUri]这些在参数里面加特性的这种“怪异”写法，也可以采用先序列化，再在后台反序列的方式。</p> 
<pre class="has"><code>$.ajax({
        type: "get",
        url: "http://localhost:27221/api/Charging/GetByModel",
        contentType: "application/json",
        data: { strQuery: JSON.stringify({ ID: "1", NAME: "Jim", CREATETIME: "1988-09-11" }) },
        success: function (data, status) {
            if (status == "success") {
                $("#div_test").html(data);
            }
        }
    });



[HttpGet]
        public string GetByModel(string strQuery)
        {
            TB_CHARGING oData = Newtonsoft.Json.JsonConvert.DeserializeObject&lt;TB_CHARGING&gt;(strQuery);
            return "ChargingData" + oData.ID;
        }</code></pre> 
<p><img alt="" class="has" src="https://images2.imgbox.com/d9/2a/7FfYh3Ra_o.png"></p> 
<p> </p> 
<p>这样在后台得到我们序列化过的对象，再通过反序列化就能得到对象。</p> 
<p>在url里面我们可以看到它自动给对象加了一个编码<img alt="" class="has" src="https://images2.imgbox.com/35/9a/n4BwNISn_o.png"></p> 
<p>至于还有园友们提到<a href="http://www.asp.net/web-api/overview/formats-and-model-binding/parameter-binding-in-aspnet-web-api" rel="nofollow">http://www.asp.net/web-api/overview/formats-and-model-binding/parameter-binding-in-aspnet-web-api</a>的model binder这种方式，博主看了下，觉得略复杂。有兴趣的也可以试试。至于用哪一种方式传递对象，园友们可以自行选择。</p> 
<p><a href="http://www.cnblogs.com/landeanfen/p/5337072.html#_labelTop" rel="nofollow">回到顶部</a><a name="_label0_2"></a></p> 
<h3>3、数组作为参数</h3> 
<p>一般get请求不建议将数组作为参数，因为我们知道get请求传递参数的大小是有限制的，最大1024字节，数组里面内容较多时，将其作为参数传递可能会发生参数超限丢失的情况。</p> 
<p><a href="http://www.cnblogs.com/landeanfen/p/5337072.html#_labelTop" rel="nofollow">回到顶部</a><a name="_label0_3"></a></p> 
<h3>4、“怪异”的get请求</h3> 
<p>为什么会说get请求“怪异”呢？我们先来看看下面的两种写法对比。</p> 
<h4>（1）WebApi的方法名称以get开头</h4> 
<pre class="has"><code>$.ajax({
        type: "get",
        url: "http://localhost:27221/api/Charging/GetByModel",
        contentType: "application/json",
        data: { strQuery: JSON.stringify({ ID: "1", NAME: "Jim", CREATETIME: "1988-09-11" }) },
        success: function (data, status) {
            if (status == "success") {
                $("#div_test").html(data);
            }
        }
    });


 [HttpGet]
        public string GetByModel(string strQuery)
        {
            TB_CHARGING oData = Newtonsoft.Json.JsonConvert.DeserializeObject&lt;TB_CHARGING&gt;(strQuery);
            return "ChargingData" + oData.ID;
        }</code></pre> 
<p> 这是标准写法，后台加<strong>[HttpGet]</strong>，参数正常得到：</p> 
<p><img alt="" class="has" src="https://images2.imgbox.com/b5/09/NnvFDkmT_o.png"></p> 
<p> </p> 
<p> </p> 
<p>为了对比，我将<strong>[HttpGet]</strong>去掉，然后再调用</p> 
<pre>        //[HttpGet]
        public string GetByModel(string strQuery)
        {
            TB_CHARGING oData = Newtonsoft.Json.JsonConvert.DeserializeObject&lt;TB_CHARGING&gt;(strQuery);
            return "ChargingData" + oData.ID;
        }</pre> 
<p>貌似没有任何问题！有人就想，那是否所有的get请求都可以省略掉[HttpGet]这个标注呢。我们试试便知。</p> 
<h4>（2）WebApi的方法名称不以get开头</h4> 
<p>我们把之前的方法名由<strong>GetByModel</strong>改成<strong>FindByModel</strong>，这个再正常不过了，很多人查询就不想用Get开头，还有直接用Query开头的。这个有什么关系吗？有没有关系，我们以事实说话。</p> 
<pre class="has"><code>$.ajax({
        type: "get",
        url: "http://localhost:27221/api/Charging/FindByModel",
        contentType: "application/json",
        data: { strQuery: JSON.stringify({ ID: "1", NAME: "Jim", CREATETIME: "1988-09-11" }) },
        success: function (data, status) {
            if (status == "success") {
                $("#div_test").html(data);
            }
        }
    });

[HttpGet]
        public string FindByModel(string strQuery)
        {
            TB_CHARGING oData = Newtonsoft.Json.JsonConvert.DeserializeObject&lt;TB_CHARGING&gt;(strQuery);
            return "ChargingData" + oData.ID;
        }</code></pre> 
<p><img alt="" class="has" src="https://images2.imgbox.com/54/be/EtsDNIWs_o.png"></p> 
<p>貌似又可行，没有任何问题啊。根据上面的推论，我们去掉<strong>[HttpGet]</strong>也是可行的，好，我们注释掉[HttpGet]，运行起来试试。</p> 
<p><img alt="" class="has" height="138" src="https://images2.imgbox.com/c6/94/YigY0x2k_o.png" width="809"> </p> 
<p><strong>结果是不进断点</strong>，有些人不信，我们在浏览器里面看看http请求：<img alt="" class="has" src="https://images2.imgbox.com/1d/d4/LLZfXyw5_o.png"> </p> 
<p>呵呵，这就奇怪了，就改了个方法名，至于这样么？还真至于！</p> 
<h2>博主的理解是：<strong>方法名以Get开头，WebApi会自动默认这个请求就是get请求，<span style="color:#f33b45;">而如果你以其他名称开头而又不标注方法的请求方式，那么这个时候服务器虽然找到了这个方法，但是由于请求方式不确定，所以直接返回给你405——方法不被允许的错误</span>。</strong></h2> 
<p>最后结论：<strong>所有的WebApi方法最好是加上请求的方式（[HttpGet]/[HttpPost]/[HttpPut]/[HttpDelete]），不要偷懒，这样既能防止类似的错误，也有利于方法的维护，别人一看就知道这个方法是什么请求。</strong></p> 
<p>这也就是为什么很多人在园子里面问道为什么方法名不加[HttpGet]就调用不到的原因！</p> 
<p> </p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/7985a723787086b032d74505a0b7cb71/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">如何在win10&#43;VS2017环境下新建一个简单的WDF示例程序</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/3ce4607b9df90fd054e38cf71e4a1787/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">MySQL压力测试工具</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>