<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>C&#43;&#43;力扣题目98--验证二叉搜索树 - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="C&#43;&#43;力扣题目98--验证二叉搜索树" />
<meta property="og:description" content="给你一个二叉树的根节点 root ，判断其是否是一个有效的二叉搜索树。
有效 二叉搜索树定义如下：
节点的左子树只包含 小于 当前节点的数。节点的右子树只包含 大于 当前节点的数。所有左子树和右子树自身必须也是二叉搜索树。 示例 1：
输入：root = [2,1,3] 输出：true 示例 2：
输入：root = [5,1,4,null,null,3,6] 输出：false 解释：根节点的值是 5 ，但是右子节点的值是 4 。 提示： 树中节点数目范围在[1, 104] 内-231 &lt;= Node.val &lt;= 231 - 1 思路 要知道中序遍历下，输出的二叉搜索树节点的数值是有序序列。
有了这个特性，验证二叉搜索树，就相当于变成了判断一个序列是不是递增的了。
#递归法 可以递归中序遍历将二叉搜索树转变成一个数组，代码如下：
vector&lt;int&gt; vec; void traversal(TreeNode* root) { if (root == NULL) return; traversal(root-&gt;left); vec.push_back(root-&gt;val); // 将二叉搜索树转换为有序数组 traversal(root-&gt;right); } 然后只要比较一下，这个数组是否是有序的，注意二叉搜索树中不能有重复元素。
traversal(root); for (int i = 1; i &lt; vec.size(); i&#43;&#43;) { // 注意要小于等于，搜索树里不能有相同元素 if (vec[i] &lt;= vec[i - 1]) return false; } return true; 整体代码如下：" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/75faf0ee8006026d2b2dd24d3dea5c17/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2024-01-13T12:46:16+08:00" />
<meta property="article:modified_time" content="2024-01-13T12:46:16+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">C&#43;&#43;力扣题目98--验证二叉搜索树</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <h3><a id="_0"></a></h3> 
<p>给你一个二叉树的根节点 <code>root</code> ，判断其是否是一个有效的二叉搜索树。</p> 
<p><strong>有效</strong> 二叉搜索树定义如下：</p> 
<ul><li>节点的左子树只包含<strong> 小于 </strong>当前节点的数。</li><li>节点的右子树只包含 <strong>大于</strong> 当前节点的数。</li><li>所有左子树和右子树自身必须也是二叉搜索树。</li></ul> 
<p><strong>示例 1：</strong></p> 
<p></p> 
<p class="img-center"><img alt="" height="182" src="https://images2.imgbox.com/7c/7c/IqA9ZBiN_o.jpg" width="302"></p> 
<pre><strong>输入：</strong>root = [2,1,3]
<strong>输出：</strong>true
</pre> 
<p><strong>示例 2：</strong></p> 
<p></p> 
<p class="img-center"><img alt="" height="292" src="https://images2.imgbox.com/ba/81/OFNn7Pc4_o.jpg" width="422"></p> 
<pre><strong>输入：</strong>root = [5,1,4,null,null,3,6]
<strong>输出：</strong>false
<strong>解释：</strong>根节点的值是 5 ，但是右子节点的值是 4 。
<strong>提示：</strong></pre> 
<ul><li>树中节点数目范围在<code>[1, 104]</code> 内</li><li><code>-231 &lt;= Node.val &lt;= 231 - 1</code></li></ul> 
<p> </p> 
<h3 id="思路">思路</h3> 
<p>要知道中序遍历下，输出的二叉搜索树节点的数值是有序序列。</p> 
<p>有了这个特性，<strong>验证二叉搜索树，就相当于变成了判断一个序列是不是递增的了。</strong></p> 
<h4 id="递归法"><a href="https://programmercarl.com/0098.%E9%AA%8C%E8%AF%81%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91.html#%E9%80%92%E5%BD%92%E6%B3%95" rel="nofollow" title="#">#</a>递归法</h4> 
<p>可以递归中序遍历将二叉搜索树转变成一个数组，代码如下：</p> 
<pre><code class="language-cpp">vector&lt;int&gt; vec;
void traversal(TreeNode* root) {
    if (root == NULL) return;
    traversal(root-&gt;left);
    vec.push_back(root-&gt;val); // 将二叉搜索树转换为有序数组
    traversal(root-&gt;right);
}
</code></pre> 
<p></p> 
<p>然后只要比较一下，这个数组是否是有序的，<strong>注意二叉搜索树中不能有重复元素</strong>。</p> 
<pre><code class="language-cpp">traversal(root);
for (int i = 1; i &lt; vec.size(); i++) {
    // 注意要小于等于，搜索树里不能有相同元素
    if (vec[i] &lt;= vec[i - 1]) return false;
}
return true;
</code></pre> 
<p></p> 
<p>整体代码如下：</p> 
<pre><code class="language-cpp">class Solution {
private:
    vector&lt;int&gt; vec;
    void traversal(TreeNode* root) {
        if (root == NULL) return;
        traversal(root-&gt;left);
        vec.push_back(root-&gt;val); // 将二叉搜索树转换为有序数组
        traversal(root-&gt;right);
    }
public:
    bool isValidBST(TreeNode* root) {
        vec.clear(); // 不加这句在leetcode上也可以过，但最好加上
        traversal(root);
        for (int i = 1; i &lt; vec.size(); i++) {
            // 注意要小于等于，搜索树里不能有相同元素
            if (vec[i] &lt;= vec[i - 1]) return false;
        }
        return true;
    }
};
</code></pre> 
<p></p> 
<p>以上代码中，我们把二叉树转变为数组来判断，是最直观的，但其实不用转变成数组，可以在递归遍历的过程中直接判断是否有序。</p> 
<p>这道题目比较容易陷入两个陷阱：</p> 
<ul><li>陷阱1</li></ul> 
<p><strong>不能单纯的比较左节点小于中间节点，右节点大于中间节点就完事了</strong>。</p> 
<p>写出了类似这样的代码：</p> 
<pre><code class="language-cpp">if (root-&gt;val &gt; root-&gt;left-&gt;val &amp;&amp; root-&gt;val &lt; root-&gt;right-&gt;val) {
    return true;
} else {
    return false;
}
</code></pre> 
<p></p> 
<p><strong>我们要比较的是 左子树所有节点小于中间节点，右子树所有节点大于中间节点</strong>。所以以上代码的判断逻辑是错误的。</p> 
<p>例如： [10,5,15,null,null,6,20] 这个case：</p> 
<p></p> 
<p class="img-center"><img alt="二叉搜索树" height="370" src="https://images2.imgbox.com/40/35/506qJ6xZ_o.png" width="354"></p> 
<p>节点10大于左节点5，小于右节点15，但右子树里出现了一个6 这就不符合了！</p> 
<ul><li>陷阱2</li></ul> 
<p>样例中最小节点 可能是int的最小值，如果这样使用最小的int来比较也是不行的。</p> 
<p>此时可以初始化比较元素为longlong的最小值。</p> 
<p>问题可以进一步演进：如果样例中根节点的val 可能是longlong的最小值 又要怎么办呢？文中会解答。</p> 
<p>了解这些陷阱之后我们来看一下代码应该怎么写：</p> 
<p>递归三部曲：</p> 
<ul><li>确定递归函数，返回值以及参数</li></ul> 
<p>要定义一个longlong的全局变量，用来比较遍历的节点是否有序，因为后台测试数据中有int最小值，所以定义为longlong的类型，初始化为longlong最小值。</p> 
<p>注意递归函数要有bool类型的返回值， 我们在<a href="https://programmercarl.com/0112.%E8%B7%AF%E5%BE%84%E6%80%BB%E5%92%8C.html" rel="nofollow" title="二叉树：递归函数究竟什么时候需要返回值，什么时候不要返回值？ (opens new window)">二叉树：递归函数究竟什么时候需要返回值，什么时候不要返回值？ (opens new window)</a>中讲了，只有寻找某一条边（或者一个节点）的时候，递归函数会有bool类型的返回值。</p> 
<p>其实本题是同样的道理，我们在寻找一个不符合条件的节点，如果没有找到这个节点就遍历了整个树，如果找到不符合的节点了，立刻返回。</p> 
<p>代码如下：</p> 
<pre><code class="language-cpp">long long maxVal = LONG_MIN; // 因为后台测试数据中有int最小值
bool isValidBST(TreeNode* root)
</code></pre> 
<ul><li>确定终止条件</li></ul> 
<p>如果是空节点 是不是二叉搜索树呢？</p> 
<p>是的，二叉搜索树也可以为空！</p> 
<p>代码如下：</p> 
<pre><code class="language-cpp">if (root == NULL) return true;
</code></pre> 
<p></p> 
<ul><li>确定单层递归的逻辑</li></ul> 
<p>中序遍历，一直更新maxVal，一旦发现maxVal &gt;= root-&gt;val，就返回false，注意元素相同时候也要返回false。</p> 
<p>代码如下：</p> 
<pre><code class="language-cpp">bool left = isValidBST(root-&gt;left);         // 左

// 中序遍历，验证遍历的元素是不是从小到大
if (maxVal &lt; root-&gt;val) maxVal = root-&gt;val; // 中
else return false;

bool right = isValidBST(root-&gt;right);       // 右
return left &amp;&amp; right;
</code></pre> 
<p></p> 
<p>整体代码如下：</p> 
<pre><code class="language-cpp">class Solution {
public:
    long long maxVal = LONG_MIN; // 因为后台测试数据中有int最小值
    bool isValidBST(TreeNode* root) {
        if (root == NULL) return true;

        bool left = isValidBST(root-&gt;left);
        // 中序遍历，验证遍历的元素是不是从小到大
        if (maxVal &lt; root-&gt;val) maxVal = root-&gt;val;
        else return false;
        bool right = isValidBST(root-&gt;right);

        return left &amp;&amp; right;
    }
};
</code></pre> 
<p></p> 
<p>以上代码是因为后台数据有int最小值测试用例，所以都把maxVal改成了longlong最小值。</p> 
<p>如果测试数据中有 longlong的最小值，怎么办？</p> 
<p>不可能在初始化一个更小的值了吧。 建议避免 初始化最小值，如下方法取到最左面节点的数值来比较。</p> 
<p>代码如下：</p> 
<pre><code class="language-cpp">class Solution {
public:
    TreeNode* pre = NULL; // 用来记录前一个节点
    bool isValidBST(TreeNode* root) {
        if (root == NULL) return true;
        bool left = isValidBST(root-&gt;left);

        if (pre != NULL &amp;&amp; pre-&gt;val &gt;= root-&gt;val) return false;
        pre = root; // 记录前一个节点

        bool right = isValidBST(root-&gt;right);
        return left &amp;&amp; right;
    }
};
</code></pre> 
<p></p> 
<p>最后这份代码看上去整洁一些，思路也清晰。</p> 
<h4 id="迭代法"><a href="https://programmercarl.com/0098.%E9%AA%8C%E8%AF%81%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91.html#%E8%BF%AD%E4%BB%A3%E6%B3%95" rel="nofollow" title="#">#</a>迭代法</h4> 
<p>可以用迭代法模拟二叉树中序遍历，对前中后序迭代法生疏的同学可以看这两篇<a href="https://programmercarl.com/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E8%BF%AD%E4%BB%A3%E9%81%8D%E5%8E%86.html" rel="nofollow" title="二叉树：听说递归能做的，栈也能做！ (opens new window)">二叉树：听说递归能做的，栈也能做！ (opens new window)</a>，<a href="https://programmercarl.com/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E7%BB%9F%E4%B8%80%E8%BF%AD%E4%BB%A3%E6%B3%95.html" rel="nofollow" title="二叉树：前中后序迭代方式统一写法(opens new window)">二叉树：前中后序迭代方式统一写法(opens new window)</a></p> 
<p>迭代法中序遍历稍加改动就可以了，代码如下：</p> 
<pre><code class="language-cpp">class Solution {
public:
    bool isValidBST(TreeNode* root) {
        stack&lt;TreeNode*&gt; st;
        TreeNode* cur = root;
        TreeNode* pre = NULL; // 记录前一个节点
        while (cur != NULL || !st.empty()) {
            if (cur != NULL) {
                st.push(cur);
                cur = cur-&gt;left;                // 左
            } else {
                cur = st.top();                 // 中
                st.pop();
                if (pre != NULL &amp;&amp; cur-&gt;val &lt;= pre-&gt;val)
                return false;
                pre = cur; //保存前一个访问的结点

                cur = cur-&gt;right;               // 右
            }
        }
        return true;
    }
};
</code></pre> 
<p></p> 
<p>在<a href="https://programmercarl.com/0700.%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%AD%E7%9A%84%E6%90%9C%E7%B4%A2.html" rel="nofollow" title="二叉树：二叉搜索树登场！ (opens new window)">二叉树：二叉搜索树登场！ (opens new window)</a>中我们分明写出了痛哭流涕的简洁迭代法，怎么在这里不行了呢，因为本题是要验证二叉搜索树啊。</p> 
<h3 id="总结"><a href="https://programmercarl.com/0098.%E9%AA%8C%E8%AF%81%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91.html#%E6%80%BB%E7%BB%93" rel="nofollow" title="#">#</a>总结</h3> 
<p>这道题目是一个简单题，但对于没接触过的同学还是有难度的。</p> 
<p>所以初学者刚开始学习算法的时候，看到简单题目没有思路很正常，千万别怀疑自己智商，学习过程都是这样的，大家智商都差不多。</p> 
<p>只要把基本类型的题目都做过，总结过之后，思路自然就开阔了，加油</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/7df75211158a210321f54436d0a11de4/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">Dubbo的服务降级策略剖析</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/d0e406d2dc9858d452c7663f7c13d535/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">考研经验总结——目录</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>