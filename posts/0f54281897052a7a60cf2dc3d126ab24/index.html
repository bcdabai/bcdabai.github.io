<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>GoLang学习之路，对Elasticsearch的使用，一文足以（包括泛型使用思想）（一） - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="GoLang学习之路，对Elasticsearch的使用，一文足以（包括泛型使用思想）（一）" />
<meta property="og:description" content="这几天没有更新，其主要的的原因是，在学习对Elasticsearch的使用。Elasticsearch是一个非常强大的数据库索引工具。是一个基于Lucene库的搜索引擎。它提供了一个分布式、支持多租户的全文搜索引擎，具有HTTP Web接口和无模式JSON文档。Elasticsearch是用Java开发的，并在Apache许可证下作为开源软件发布。官方客户端在Java、.NET（C#）、PHP、Python、Apache Groovy、Ruby和许多其他语言中都是可用的。根据DB-Engines的排名显示，Elasticsearch是最受欢迎的企业搜索引擎，其次是Apache Solr，也是基于Lucene。
所以你可以不用，但是你不能不知道，不可谓重要。
文章目录 Elasticsearch概念安装使用ElasticSearch`使用前提`存储结构Elasticsearch语法常见的几种查询方法`精确匹配单个字段``多值匹配``范围查询``bool组合查询``排序``聚合查询``count函数``cardinality``avg`求平均值`Sum`求和计算`max`求最大值`min`求最小值 Elasticsearch概念 ElasticSearch是一个分布式、RESTful风格的搜索和数据分析引擎，在国内简称为ES；使用Java开发的，底层基于Lucene是一种全文检索的搜索库，直接使用使用Lucene还是比较麻烦的，Elasticsearch在Lucene的基础上开发了一个强大的搜索引擎。
主要功能有：
分布式的搜索引擎和数据分析引擎全文检索、结构化检索、数据分析对海量数据进行近实时的处理 Elastic 是Lucene的封装，提供了REST API的操作接口，开箱即用
Lucene：是单机应用，只能在单台服务器上使用，最多只能处理单台服务器可以处理的数据量。Elasric：ES自动可以将海量数据分散到多台服务器上去存储和检索海量数据的处理： 分布式以后，就可以采用大量的服务器去存储和检索数据，自然而然就可以实现海量数据的处理了，近实时；在秒级别对数据进行搜索和分析。 国外 维基百科，类似百度百科，全文检索，高亮，搜索推荐
- Stack Overflow（国外的程序异常讨论论坛）GitHub（开源代码管理）电商网站，检索商品日志数据分析，logstash采集日志，ES进行复杂的数据分析（ELK技术，elasticsearch&#43;logstash&#43;kibana）BI系统，商业智能，Business Intelligence 国内 站内搜索（电商，招聘，门户）IT系统搜索（OA，CRM，ERP）数据分析（ES热门的一个使用场景） 优点：
Elasticsearch，将全文检索、数据饭呢西、分布式技术合并到了一起。lucene（全文检索），商用的数据分析软件（也是有的），分布式数据库（mycat）数据库的功能面对很多领域是不够用的（事务，还有各种联机事务型的操作）；特殊的功能，比如全文检索，同义词处理，相关度排名，复杂数据分析，海量数据的近实时处理；Elasticsearch作为传统数据库的一个补充，提供了数据库所不不能提供的很多功能可以作为一个大型分布式集群（数百台服务器）技术，处理PB级数据，服务大公司；也可以运行在单机上，服务小公司对用户而言，是开箱即用的，非常简单，作为中小型的应用，直接3分钟部署一下ES，就可以作为生产环境的系统来使用了，数据量不大，操作不是太复杂 安装 现在的安装并不像之前的版本那样，包括对Elasticsearch使用。主要存在的问题是密钥。说到密钥，这个就不得不说一个东西。
Elasticsearch其实有三个方面构成：
调用的服务器，这个服务器指代的是，你通过API去使用Elasticsearch引擎的服务器。Elasticsearch服务器。这个服务器就是搭载Elasticsearch的云服务器Elasticsearch可视化工具。这个可视化工具功能最齐全的就是Kibana，这个是Elacsticsearch官方指定的可视化工具。除了这个我推荐一个更加轻量的可视化工具es-client,当然对于Kibana的来说，是比不上的，但是轻量啊。安装没有那么复杂。执行需要在浏览器的插件管理中下载就可以用了，非常方便 这里建议安装用docker去安装。这里献上官方文档（官网的不一定能成，主要是看你的虚拟机是什么）
注意：如果是按照别人博客上的安装的话，跟着就行。诺是按照官网的上的，你就注意：
密钥的生成。这个密钥的生成非常重要，Kibana在登录的时候是需要的。这个密钥是安全密钥，在配置的时候是可以取消的。（一定要注意不然在后面是非常弄的）在用安全组中将相应的端口开放。可视化工具链接的接口与服务器调用端口是一致的。 这里不放我如何去安装的因为我怕更不上时代，到时候误人子弟，官网是一直在变的。
使用ElasticSearch 使用前提 必须要有一个ElasticSearch服务器必须要有一个可视化工具安装API包，&#34;github.com/elastic/go-elasticsearch/v8&#34; import &#34;github.com/elastic/go-elasticsearch/v8&#34; 但是这个包下面其实还有一些包，这些包非常的重要。当时我在使用的时候，根本不知道，走了不少的弯路的，找了官网的文档，又找了一些博客，都没有详细的说明情况和要点。要不就少些，要不就只把部分给列出来。但是现在我将这些无私的奉献给各位。
因为这个v8的包非常的多，所以很难将所有的放进去。这里我做一些解释：
客户端： 调用NewDefaultClient()和NewClient(cfg Config)方法会返回一个普通客户端 NewDefaultClient() 不需要去配置链接时的配置参数，默认参数链接，并返回一个普通客户端NewClient(cfg Config)需要按照总共需要的配置需求去配置参数，并返回一个普通客户端 调用NewTypedClient(cfg Config)会返回一个属性客户端（相比普通客户端强大，但是有局限，后面再说） 工具包： 这个工具包主要是普通客户端进行调用的，使用的范围是对于批量处理数据的情况 参数类型包： 我们在对ElasticSearch进行处理的时候会有很多中情况： 首先是对于语法的选择，ElasticSearch有独属于他自己的一套语法。查询时会有很多选择，比如对于字段是模糊查询，还是精确查询，还是对地图进行查询。这些参数都有，也有对于AI进行处理的参数。（建议下一个翻译软件，去看看。那个参数太多了。。。也就是说功能非常齐全） 存储结构 ES存储结构Mysql存储结构Index（索引）表document（文档）行，一行数据Field（字段）表字段mapping(映射)表结构定义 index ES中索引(index)就像mysql中的表一样，代表着文档数据的集合，文档就相当于ES中存储的一条数据 type type也就是文档类型，不过在Elasticsearch7.0以后的版本,已经废弃文档类型了。在Elasticsearch老的版本中文档类型，代表一类文档的集合，index(索引)类似mysql的数据库、文档类型类似Mysql的表。新的版本文档类型没什么作用了，那么index（索引）就类似mysql的表的概念，ES没有数据库的概念了。 document ES是面向文档的数据库，文档是ES存储的最基本的存储单元，文档类似mysql表中的一行数据。其实在ES中，文档指的就是一条JSON数据ES中文档使用JSON格式存储，因此存储上要比mysql灵活的很多，ES支持任意格式的json数据 要注意：虽然说， 一个索引就理解成一个表，但是这个表是可以存任意数据的，也就是说，不遵从约定的一开始的索引也是可以的。（所以索引名一定不能错否则，会有脏数据）
一个document的数据
{ &#34;_index&#34; : &#34;order&#34;, &#34;" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/0f54281897052a7a60cf2dc3d126ab24/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-12-28T18:16:12+08:00" />
<meta property="article:modified_time" content="2023-12-28T18:16:12+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">GoLang学习之路，对Elasticsearch的使用，一文足以（包括泛型使用思想）（一）</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p>这几天没有更新，其主要的的原因是，在学习对Elasticsearch的使用。Elasticsearch是一个非常强大的数据库索引工具。是一个基于Lucene库的搜索引擎。它提供了一个分布式、支持多租户的全文搜索引擎，具有HTTP Web接口和无模式JSON文档。Elasticsearch是用Java开发的，并在Apache许可证下作为开源软件发布。官方客户端在Java、.NET（C#）、PHP、Python、Apache Groovy、Ruby和许多其他语言中都是可用的。根据DB-Engines的排名显示，Elasticsearch是最受欢迎的企业搜索引擎，其次是Apache Solr，也是基于Lucene。</p> 
<p>所以你可以不用，但是你不能不知道，不可谓重要。</p> 
<p></p> 
<div class="toc"> 
 <h4>文章目录</h4> 
 <ul><li><a href="#Elasticsearch_5" rel="nofollow">Elasticsearch概念</a></li><li><a href="#_38" rel="nofollow">安装</a></li><li><a href="#ElasticSearch_54" rel="nofollow">使用ElasticSearch</a></li><li><ul><li><a href="#_56" rel="nofollow">`使用前提`</a></li><li><ul><li><a href="#_84" rel="nofollow">存储结构</a></li><li><a href="#Elasticsearch_197" rel="nofollow">Elasticsearch语法</a></li><li><ul><li><a href="#_263" rel="nofollow">常见的几种查询方法</a></li><li><ul><li><a href="#_283" rel="nofollow">`精确匹配单个字段`</a></li><li><a href="#_302" rel="nofollow">`多值匹配`</a></li><li><a href="#_322" rel="nofollow">`范围查询`</a></li><li><a href="#bool_353" rel="nofollow">`bool组合查询`</a></li><li><a href="#_372" rel="nofollow">`排序`</a></li><li><a href="#_399" rel="nofollow">`聚合查询`</a></li><li><ul><li><a href="#count_461" rel="nofollow">`count函数`</a></li><li><a href="#cardinality_476" rel="nofollow">`cardinality`</a></li><li><a href="#avg_491" rel="nofollow">`avg`求平均值</a></li><li><a href="#Sum_505" rel="nofollow">`Sum`求和计算</a></li><li><a href="#max_519" rel="nofollow">`max`求最大值</a></li><li><a href="#min_533" rel="nofollow">`min`求最小值</a></li></ul> 
     </li></ul> 
    </li></ul> 
   </li></ul> 
  </li></ul> 
 </li></ul> 
</div> 
<p></p> 
<h2><a id="Elasticsearch_5"></a>Elasticsearch概念</h2> 
<p><code>ElasticSearch</code>是一个分布式、<code>RESTful</code>风格的搜索和数据分析引擎，在国内简称为<code>ES</code>；使用<code>Java</code>开发的，底层基于<code>Lucene</code>是一种全文检索的搜索库，直接使用使用<code>Lucene</code>还是比较麻烦的，<code>Elasticsearch</code>在<code>Lucene</code>的基础上开发了一个强大的搜索引擎。</p> 
<p>主要功能有：</p> 
<ul><li>分布式的搜索引擎和数据分析引擎</li><li>全文检索、结构化检索、数据分析</li><li>对海量数据进行近实时的处理</li></ul> 
<p><code>Elastic</code> 是<code>Lucene</code>的封装，提供了<code>REST API</code>的操作接口，开箱即用</p> 
<ol><li><code>Lucene</code>：是单机应用，只能在单台服务器上使用，最多只能处理单台服务器可以处理的数据量。</li><li><code>Elasric</code>：ES自动可以将海量数据分散到多台服务器上去存储和检索海量数据的处理： 
  <ul><li>分布式以后，就可以采用大量的服务器去存储和检索数据，自然而然就可以实现海量数据的处理了，近实时；在秒级别对数据进行搜索和分析。</li></ul> </li></ol> 
<ul><li>国外 
  <ul><li>维基百科，类似百度百科，全文检索，高亮，搜索推荐<br> -<code> Stack Overflow</code>（国外的程序异常讨论论坛）</li><li><code>GitHub</code>（开源代码管理）</li><li>电商网站，检索商品</li><li>日志数据分析，<code>logstash</code>采集日志，ES进行复杂的数据分析（<code>ELK</code>技术，<code>elasticsearch+logstash+kibana</code>）</li><li>BI系统，商业智能，<code>Business Intelligence</code></li></ul> </li><li>国内 
  <ul><li>站内搜索（电商，招聘，门户）</li><li>IT系统搜索（<code>OA</code>，<code>CRM</code>，<code>ERP</code>）</li><li>数据分析（ES热门的一个使用场景）</li></ul> </li></ul> 
<p>优点：</p> 
<ul><li><code>Elasticsearch</code>，将全文检索、数据饭呢西、分布式技术合并到了一起。<code>lucene</code>（全文检索），商用的数据分析软件（也是有的），分布式数据库（<code>mycat</code>）</li><li>数据库的功能面对很多领域是不够用的（事务，还有各种联机事务型的操作）；特殊的功能，比如全文检索，同义词处理，相关度排名，复杂数据分析，海量数据的近实时处理；Elasticsearch作为传统数据库的一个补充，提供了数据库所不不能提供的很多功能</li><li>可以作为一个大型分布式集群（数百台服务器）技术，处理<code>PB</code>级数据，服务大公司；也可以运行在单机上，服务小公司</li><li>对用户而言，是开箱即用的，非常简单，作为中小型的应用，直接3分钟部署一下<code>ES</code>，就可以作为生产环境的系统来使用了，数据量不大，操作不是太复杂</li></ul> 
<h2><a id="_38"></a>安装</h2> 
<p>现在的安装并不像之前的版本那样，包括对Elasticsearch使用。主要存在的问题是密钥。说到密钥，这个就不得不说一个东西。</p> 
<p>Elasticsearch其实有三个方面构成：</p> 
<ol><li>调用的服务器，这个服务器指代的是，你通过API去使用Elasticsearch引擎的服务器。</li><li>Elasticsearch服务器。这个服务器就是搭载Elasticsearch的云服务器</li><li>Elasticsearch可视化工具。这个可视化工具功能最齐全的就是Kibana，这个是Elacsticsearch官方指定的可视化工具。除了这个我推荐一个更加轻量的可视化工具<code>es-client</code>,当然对于Kibana的来说，是比不上的，但是轻量啊。安装没有那么复杂。执行需要在<code>浏览器的插件管理中</code>下载就可以用了，非常方便</li></ol> 
<p>这里建议安装用docker去安装。这里献上<a href="https://www.elastic.co/guide/en/elasticsearch/reference/current/docker.html" rel="nofollow">官方文档</a>（官网的不一定能成，主要是看你的虚拟机是什么）</p> 
<p><code>注意</code>：如果是按照别人博客上的安装的话，跟着就行。诺是按照官网的上的，你就注意：</p> 
<ol><li>密钥的生成。这个密钥的生成非常重要，Kibana在登录的时候是需要的。这个密钥是安全密钥，在配置的时候是可以取消的。（一定要注意不然在后面是非常弄的）</li><li>在用安全组中将相应的端口开放。可视化工具链接的接口与服务器调用端口是一致的。</li></ol> 
<p>这里不放我如何去安装的因为我怕更不上时代，到时候误人子弟，官网是一直在变的。</p> 
<h2><a id="ElasticSearch_54"></a>使用ElasticSearch</h2> 
<h3><a id="_56"></a><code>使用前提</code></h3> 
<ol><li>必须要有一个<code>ElasticSearch</code>服务器</li><li>必须要有一个可视化工具</li><li>安装API包，<code>"github.com/elastic/go-elasticsearch/v8"</code></li></ol> 
<pre><code class="prism language-go"><span class="token keyword">import</span> <span class="token string">"github.com/elastic/go-elasticsearch/v8"</span>
</code></pre> 
<p>但是这个包下面其实还有一些包，这些包非常的重要。当时我在使用的时候，根本不知道，走了不少的弯路的，找了官网的文档，又找了一些博客，都没有详细的说明情况和要点。要不就少些，要不就只把部分给列出来。但是现在我将这些无私的奉献给各位。<br> <img src="https://images2.imgbox.com/9b/f5/iHe2tVsX_o.png" alt="在这里插入图片描述"></p> 
<p>因为这个v8的包非常的多，所以很难将所有的放进去。这里我做一些解释：</p> 
<ol><li>客户端： 
  <ul><li>调用<code>NewDefaultClient()</code>和<code>NewClient(cfg Config)</code>方法会返回一个普通客户端 
    <ul><li><code>NewDefaultClient()</code> 不需要去配置链接时的配置参数，默认参数链接，并返回一个普通客户端</li><li><code>NewClient(cfg Config)</code>需要按照总共需要的配置需求去配置参数，并返回一个普通客户端</li></ul> </li><li>调用<code>NewTypedClient(cfg Config)</code>会返回一个属性客户端（相比普通客户端强大，但是有局限，后面再说）</li></ul> </li><li>工具包： 
  <ul><li>这个工具包主要是<code>普通客户端</code>进行调用的，使用的范围是对于<code>批量处理数据</code>的情况</li></ul> </li><li>参数类型包： 
  <ul><li>我们在对<code>ElasticSearch</code>进行处理的时候会有很多中情况： 
    <ul><li>首先是对于语法的选择，<code>ElasticSearch</code>有独属于他自己的一套语法。</li><li>查询时会有很多选择，比如对于字段是模糊查询，还是精确查询，还是对地图进行查询。这些参数都有，也有对于<code>AI</code>进行处理的参数。（建议下一个翻译软件，去看看。那个参数太多了。。。也就是说功能非常齐全）</li></ul> </li></ul> </li></ol> 
<h4><a id="_84"></a>存储结构</h4> 
<table><thead><tr><th>ES存储结构</th><th>Mysql存储结构</th></tr></thead><tbody><tr><td>Index（索引）</td><td>表</td></tr><tr><td>document（文档）</td><td>行，一行数据</td></tr><tr><td>Field（字段）</td><td>表字段</td></tr><tr><td>mapping(映射)</td><td>表结构定义</td></tr></tbody></table> 
<ul><li><code> index</code> 
  <ul><li><code>ES</code>中索引(<code>index</code>)就像<code>mysql</code>中的表一样，代表着文档数据的集合，文档就相当于<code>ES</code>中存储的一条数据</li></ul> </li><li><code>type</code> 
  <ul><li><code>type</code>也就是文档类型，不过在<code>Elasticsearch7.0</code>以后的版本,已经废弃文档类型了。</li><li>在<code>Elasticsearch</code>老的版本中文档类型，代表一类文档的集合，<code>index(索引)</code>类似<code>mysql</code>的数据库、文档类型类似<code>Mysql</code>的表。</li><li>新的版本文档类型没什么作用了，那么<code>index（索引</code>）就类似mysql的表的概念，<code>ES</code>没有数据库的概念了。</li></ul> </li><li><code>document</code> 
  <ul><li><code>ES</code>是面向文档的数据库，文档是<code>ES存储</code>的最基本的存储单元，文档类似<code>mysql</code>表中的一行数据。</li><li>其实在<code>ES</code>中，文档指的就是一条<code>JSON</code>数据</li><li>ES中文档使用JSON格式存储，因此存储上要比mysql灵活的很多，<code>ES支持任意格式的json数据</code> 
    <ul><li> 
      <blockquote> 
       <p>要注意：虽然说， 一个索引就理解成一个表，但是这个表是可以存任意数据的，也就是说，不遵从约定的一开始的索引也是可以的。（所以索引名一定不能错否则，会有脏数据）</p> 
      </blockquote> </li></ul> </li></ul> </li></ul> 
<blockquote> 
 <p>一个<code>document</code>的数据</p> 
</blockquote> 
<pre><code class="prism language-go"><span class="token punctuation">{<!-- --></span>
  <span class="token string">"_index"</span> <span class="token punctuation">:</span> <span class="token string">"order"</span><span class="token punctuation">,</span>
  <span class="token string">"_type"</span> <span class="token punctuation">:</span> <span class="token string">"_doc"</span><span class="token punctuation">,</span>
  <span class="token string">"_id"</span> <span class="token punctuation">:</span> <span class="token string">"1"</span><span class="token punctuation">,</span>
  <span class="token string">"_version"</span> <span class="token punctuation">:</span> <span class="token number">2</span><span class="token punctuation">,</span>
  <span class="token string">"_seq_no"</span> <span class="token punctuation">:</span> <span class="token number">1</span><span class="token punctuation">,</span>
  <span class="token string">"_primary_term"</span> <span class="token punctuation">:</span> <span class="token number">1</span><span class="token punctuation">,</span>
  <span class="token string">"found"</span> <span class="token punctuation">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span>
  <span class="token string">"_source"</span> <span class="token punctuation">:</span> <span class="token punctuation">{<!-- --></span>
    		<span class="token string">"productName"</span><span class="token punctuation">:</span> <span class="token string">"12370"</span><span class="token punctuation">,</span>
            <span class="token string">"masterPic"</span><span class="token punctuation">:</span> <span class="token string">"12345650"</span><span class="token punctuation">,</span>
            <span class="token string">"categoryId"</span><span class="token punctuation">:</span> <span class="token number">1</span><span class="token punctuation">,</span>
            <span class="token string">"desc"</span><span class="token punctuation">:</span> <span class="token string">"12345640"</span><span class="token punctuation">,</span>
            <span class="token string">"price"</span><span class="token punctuation">:</span> <span class="token string">"12345630"</span><span class="token punctuation">,</span>
            <span class="token string">"tags"</span><span class="token punctuation">:</span> null<span class="token punctuation">,</span>
            <span class="token string">"startProvinceCode"</span><span class="token punctuation">:</span> <span class="token string">"12345690"</span><span class="token punctuation">,</span>
            <span class="token string">"startCityCode"</span><span class="token punctuation">:</span> <span class="token string">"12345680"</span><span class="token punctuation">,</span>
            <span class="token string">"destinationProvinceCode"</span><span class="token punctuation">:</span> <span class="token string">"12345640"</span><span class="token punctuation">,</span>
            <span class="token string">"destinationCityCode"</span><span class="token punctuation">:</span> <span class="token string">"12345670"</span><span class="token punctuation">,</span>
            <span class="token string">"startDate"</span><span class="token punctuation">:</span> null
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>文档中的任何json字段都可以作为查询条件。并且文档的json格式没有严格限制，可以随意增加，减少字段，甚至每个文档的格式都不一样也可以。<br> 值得注意的是：</p> 
<ul><li><code>_index</code>：代表当前<code>json</code>文档所属的文档名字(重要)</li><li><code>_type</code>：代表当前<code>json</code>文档所属的类型。不过在<code>es7.0</code>以后废弃了<code>type</code>用法，但是元数据还是可以看到的(API可以)（重要）</li><li><code>_id</code>：文档唯一<code>ID</code>，如果我们没有为文档指定<code>id</code>，系统自动生成。（重要，一定要自己去控制）</li><li><code>_source</code>：代表我们插入进入json数据</li><li><code>_version</code>：文档的版本号，每修改一次文档数据，字段就会加1，这个字段新版es也给取消了</li><li><code>_seq_no</code>：文档的编号，替代老的 <code>version</code>字段</li><li><code>_primary_term</code>：文档所在主分区，这个可以跟<code>seq_no</code>字段搭配实现乐观锁（重要）</li></ul> 
<blockquote> 
 <p><code>Field</code></p> 
</blockquote> 
<p>文档由多个json字段，这个字段跟mysql中的表的字段是类似的。ES中的字段也是有类型的：</p> 
<ul><li> <p><code>数值类型</code>(long、integer、short、byte、double、float)</p> </li><li> <p><code>Date</code> 日期类型</p> </li><li> <p><code>boolean</code>布尔类型</p> </li><li> <p><code>Text </code>支持全文搜索</p> </li><li> <p><code>Keyword</code> 不支持全文搜索，例如：phone这种数据，用一个整体进行匹配就ok了，也不要进行分词处理</p> </li><li> <p><code>Geo</code> 这里主要用于地理信息检索、多边形区域的表达。</p> </li></ul> 
<blockquote> 
 <p><code>mapping</code>:</p> 
</blockquote> 
<p>Elasticsearch的mapping类似于mysql中的表结构体定义，每个索引都有一个映射的规则，我们可以通过定义索引的映射规则，提前定义好文档的json结构和字段类型，如果没有定义索引的映射规则，ElasticSearch会在写入数据的时候，根据我们写入的数据字段推测出对应的字段类型，相当于自动定义索引的映射规则。</p> 
<p>这里献上一篇我在学习时看见的一篇<a href="https://www.cnblogs.com/wupeixuan/p/12514843.html" rel="nofollow">非常详细的文章</a>：</p> 
<pre><code class="prism language-go">mappingTpl <span class="token operator">=</span> <span class="token string">`{
 "mappings":{
  "properties":{
   "categoryId":     { 
   		"type": "long" 
   		},
   "productName":   {
   		 "type": "keyword" 
   		 },
   "masterPic":   {
   		 "type": "text"
   		  },
   "desc":   {
   		 "type": "keyword" 
   		 },
   "price":    { 
   		"type": "long"
   		 },
   "startProvinceCode":  {
   		 "type": "text" 
   		 },
   "startCityCode":         {
   		 "type": "text" 
   		 },
   "update_time":  { 
   		"type": "long"
   		 },
   "create_time":  { 
   		"type": "long"
   		 }
	   }
 	 }
 }`</span>
</code></pre> 
<p>这样我们就定义好了，一个索引的结构</p> 
<h4><a id="Elasticsearch_197"></a>Elasticsearch语法</h4> 
<p><strong>在使用ES时，查询是我们经常使用的</strong></p> 
<pre><code class="prism language-yaml">GET /<span class="token punctuation">{<!-- --></span>索引名<span class="token punctuation">}</span>/_search
<span class="token punctuation">{<!-- --></span>
 <span class="token key atrule">"from"</span> <span class="token punctuation">:</span> <span class="token number">0</span><span class="token punctuation">,</span>  // 搜索结果的开始位置
   <span class="token key atrule">"size"</span> <span class="token punctuation">:</span> <span class="token number">10</span><span class="token punctuation">,</span> // 分页大小，也就是一次返回多少数据
   "_source" <span class="token punctuation">:</span><span class="token punctuation">[</span> <span class="token punctuation">...</span>需要返回的字段数组<span class="token punctuation">...</span> <span class="token punctuation">]</span><span class="token punctuation">,</span>
 <span class="token key atrule">"query"</span> <span class="token punctuation">:</span> <span class="token punctuation">{<!-- --></span> <span class="token punctuation">...</span>query子句<span class="token punctuation">...</span> <span class="token punctuation">}</span><span class="token punctuation">,</span>
 <span class="token key atrule">"aggs"</span> <span class="token punctuation">:</span> <span class="token punctuation">{<!-- --></span> ..aggs子句..  <span class="token punctuation">}</span><span class="token punctuation">,</span>
 <span class="token key atrule">"sort"</span> <span class="token punctuation">:</span> <span class="token punctuation">{<!-- --></span> ..sort子句..  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> 
<ul><li><code>ES</code>查询分页：通过<code>from</code>和<code>size</code>参数设置，相当于<code>MYSQL</code>的<code>limit</code>和<code>offset</code>结构</li><li><code>query</code>：主要编写类似<code>SQL</code>的<code>Where</code>语句，支持布尔查询（<code>and/or</code>）、<code>IN</code>、全文搜索、模糊匹配、范围查询（大于小于）</li><li><code>aggs</code>：主要用来编写统计分析语句，类似<code>SQL</code>的<code>group by</code>语句</li><li><code>sort</code>：用来设置排序条件，类似SQL的<code>order by</code>语句</li><li><code>source</code>：用于设置查询结果返回什么字段，相当于<code>select</code>语句后面指定字段</li></ul> 
<p>查询语句：GET /{索引名}/_search</p> 
<p>查询 <code>GET /test/_search</code></p> 
<p>返回结果：</p> 
<pre><code class="prism language-yaml">
<span class="token punctuation">{<!-- --></span>
    <span class="token key atrule">"took"</span><span class="token punctuation">:</span> <span class="token number">1</span><span class="token punctuation">,</span>
    <span class="token key atrule">"timed_out"</span><span class="token punctuation">:</span> <span class="token boolean important">false</span><span class="token punctuation">,</span>
    <span class="token key atrule">"_shards"</span><span class="token punctuation">:</span> <span class="token punctuation">{<!-- --></span>
        <span class="token key atrule">"total"</span><span class="token punctuation">:</span> <span class="token number">1</span><span class="token punctuation">,</span>
        <span class="token key atrule">"successful"</span><span class="token punctuation">:</span> <span class="token number">1</span><span class="token punctuation">,</span>
        <span class="token key atrule">"skipped"</span><span class="token punctuation">:</span> <span class="token number">0</span><span class="token punctuation">,</span>
        <span class="token key atrule">"failed"</span><span class="token punctuation">:</span> <span class="token number">0</span>
    <span class="token punctuation">}</span><span class="token punctuation">,</span>
    <span class="token key atrule">"hits"</span><span class="token punctuation">:</span> <span class="token punctuation">{<!-- --></span>
        <span class="token key atrule">"total"</span><span class="token punctuation">:</span> <span class="token punctuation">{<!-- --></span>
            <span class="token key atrule">"value"</span><span class="token punctuation">:</span> <span class="token number">1006</span><span class="token punctuation">,</span>
            <span class="token key atrule">"relation"</span><span class="token punctuation">:</span> <span class="token string">"eq"</span>
        <span class="token punctuation">}</span><span class="token punctuation">,</span>
        <span class="token key atrule">"max_score"</span><span class="token punctuation">:</span> <span class="token number">1</span><span class="token punctuation">,</span>
        <span class="token key atrule">"hits"</span><span class="token punctuation">:</span> <span class="token punctuation">[</span>
            <span class="token punctuation">{<!-- --></span>
                <span class="token key atrule">"_index"</span><span class="token punctuation">:</span> <span class="token string">"test"</span><span class="token punctuation">,</span>
                <span class="token key atrule">"_id"</span><span class="token punctuation">:</span> <span class="token string">"bZ8TfIwBuOjgAaUNdD1u"</span><span class="token punctuation">,</span>
                <span class="token key atrule">"_score"</span><span class="token punctuation">:</span> <span class="token number">1</span><span class="token punctuation">,</span>
                <span class="token key atrule">"_source"</span><span class="token punctuation">:</span> <span class="token punctuation">{<!-- --></span>
                    <span class="token key atrule">"productName"</span><span class="token punctuation">:</span> <span class="token string">"123"</span><span class="token punctuation">,</span>
                    <span class="token key atrule">"masterPic"</span><span class="token punctuation">:</span> <span class="token string">"123456"</span><span class="token punctuation">,</span>
                    <span class="token key atrule">"categoryId"</span><span class="token punctuation">:</span> <span class="token number">1</span><span class="token punctuation">,</span>
                    <span class="token key atrule">"desc"</span><span class="token punctuation">:</span> <span class="token string">"123456"</span><span class="token punctuation">,</span>
                    <span class="token key atrule">"price"</span><span class="token punctuation">:</span> <span class="token string">"123456"</span><span class="token punctuation">,</span>
                    <span class="token key atrule">"tags"</span><span class="token punctuation">:</span> <span class="token null important">null</span><span class="token punctuation">,</span>
                    <span class="token key atrule">"startProvinceCode"</span><span class="token punctuation">:</span> <span class="token string">"123456"</span><span class="token punctuation">,</span>
                    <span class="token key atrule">"startCityCode"</span><span class="token punctuation">:</span> <span class="token string">"123456"</span><span class="token punctuation">,</span>
                    <span class="token key atrule">"destinationProvinceCode"</span><span class="token punctuation">:</span> <span class="token string">"123456"</span><span class="token punctuation">,</span>
                    <span class="token key atrule">"destinationCityCode"</span><span class="token punctuation">:</span> <span class="token string">"123456"</span><span class="token punctuation">,</span>
                    <span class="token key atrule">"startDate"</span><span class="token punctuation">:</span> <span class="token null important">null</span>
                <span class="token punctuation">}</span>
            <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> 
<h5><a id="_263"></a>常见的几种查询方法</h5> 
<ul><li><code>匹配单个字段</code><br> 通过<code>match</code>实现全文索引，全文搜索是ES的关键特性之一，我们平时使用搜索一些文本、字符串是否包含指定的关键词，但是如果两篇文章，都包含我们的关键词。</li></ul> 
<pre><code class="prism language-yaml">GET /<span class="token punctuation">{<!-- --></span>索引名<span class="token punctuation">}</span>/_search
<span class="token punctuation">{<!-- --></span>
  <span class="token key atrule">"query"</span><span class="token punctuation">:</span> <span class="token punctuation">{<!-- --></span>
    <span class="token key atrule">"match"</span><span class="token punctuation">:</span> <span class="token punctuation">{<!-- --></span>
      <span class="token key atrule">"{FIELD}"</span><span class="token punctuation">:</span> <span class="token string">"{TEXT}"</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> 
<ul><li> <p>{FIELD} 就是我们需要匹配的字段名</p> </li><li> <p>{TEXT} 就是我们需要匹配的内容</p> </li></ul> 
<hr> 
<h6><a id="_283"></a><code>精确匹配单个字段</code></h6> 
<p>当我们需要根据手机号、用户名来搜索一个用户信息时，这就需要使用精确匹配了。可以使用<code>term</code>实现精确匹配语法</p> 
<pre><code class="prism language-yaml">GET /<span class="token punctuation">{<!-- --></span>索引名<span class="token punctuation">}</span>/_search
<span class="token punctuation">{<!-- --></span>
  <span class="token key atrule">"query"</span><span class="token punctuation">:</span> <span class="token punctuation">{<!-- --></span>
    <span class="token key atrule">"term"</span><span class="token punctuation">:</span> <span class="token punctuation">{<!-- --></span>
      <span class="token key atrule">"{FIELD}"</span><span class="token punctuation">:</span> <span class="token string">"{VALUE}"</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> 
<ul><li> <p>{FIELD} - 就是我们需要匹配的字段名</p> </li><li> <p>{VALUE}- 就是我们需要匹配的内容，除了<code>TEXT</code>类型字段以外的任意类型</p> </li></ul> 
<hr> 
<h6><a id="_302"></a><code>多值匹配</code></h6> 
<p>多值匹配，也就是想<code>mysql</code>中的<code>in</code>语句一样，一个字段包含给定数组中的任意一个值匹配。上文使用term实现单值精确匹配，同理<code>terms</code>就可以实现多值匹配</p> 
<pre><code class="prism language-yaml">GET /<span class="token punctuation">{<!-- --></span>索引名<span class="token punctuation">}</span>/_search
<span class="token punctuation">{<!-- --></span>
  <span class="token key atrule">"query"</span><span class="token punctuation">:</span> <span class="token punctuation">{<!-- --></span>
    <span class="token key atrule">"terms"</span><span class="token punctuation">:</span> <span class="token punctuation">{<!-- --></span>
      <span class="token key atrule">"{FIELD}"</span><span class="token punctuation">:</span> <span class="token punctuation">[</span>
        <span class="token string">"{VALUE1}"</span><span class="token punctuation">,</span>
        <span class="token string">"{VALUE2}"</span>
      <span class="token punctuation">]</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> 
<ul><li> <p>{FIELD}- 就是我们需要匹配的字段名</p> </li><li> <p>{VALUE1}, {VALUE2} … {VALUE N} - 就是我们需要匹配的内容，除了TEXT类型字段以外的任意类型。</p> </li></ul> 
<hr> 
<h6><a id="_322"></a><code>范围查询</code></h6> 
<p>使用<code>range</code>就可以实现范围查询，相当于SQL语句的<code>&gt;，&gt;=，&lt;，&lt;=</code>表达式</p> 
<pre><code class="prism language-yaml">GET /<span class="token punctuation">{<!-- --></span>索引名<span class="token punctuation">}</span>/_search
<span class="token punctuation">{<!-- --></span>
  <span class="token key atrule">"query"</span><span class="token punctuation">:</span> <span class="token punctuation">{<!-- --></span>
    <span class="token key atrule">"range"</span><span class="token punctuation">:</span> <span class="token punctuation">{<!-- --></span>
      <span class="token key atrule">"{FIELD}"</span><span class="token punctuation">:</span> <span class="token punctuation">{<!-- --></span>
        <span class="token key atrule">"gte"</span><span class="token punctuation">:</span> <span class="token number">100</span><span class="token punctuation">,</span> 
        <span class="token key atrule">"lte"</span><span class="token punctuation">:</span> <span class="token number">200</span>
      <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> 
<ul><li>{FIELD} - 字段名</li><li>gte范围参数 - 等价于&gt;=</li><li>lte范围参数 - 等价于 &lt;=</li><li>范围参数可以只写一个，例如：仅保留 “gte”: 100， 则代表 FIELD字段 &gt;= 100</li></ul> 
<p>范围参数有如下：</p> 
<ul><li> <p>gt - 大于 （ &gt; ）</p> </li><li> <p>gte - 大于且等于 （ &gt;= ）</p> </li><li> <p>lt - 小于 （ &lt; ）</p> </li><li> <p>lte - 小于且等于 （ &lt;= ）</p> </li></ul> 
<hr> 
<h6><a id="bool_353"></a><code>bool组合查询</code></h6> 
<p>前面的查询都是设置单个字段的查询条件，实际项目中这么应用是很少的，基本都是多个字段的查询条件。</p> 
<pre><code class="prism language-yaml">GET /<span class="token punctuation">{<!-- --></span>索引名<span class="token punctuation">}</span>/_search
<span class="token punctuation">{<!-- --></span>
  <span class="token key atrule">"query"</span><span class="token punctuation">:</span> <span class="token punctuation">{<!-- --></span>
    <span class="token key atrule">"bool"</span><span class="token punctuation">:</span> <span class="token punctuation">{<!-- --></span> // bool查询
      <span class="token key atrule">"must"</span><span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span> // must条件，类似SQL中的and<span class="token punctuation">,</span> 代表必须匹配条件
      <span class="token key atrule">"must_not"</span><span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span> // must_not条件，跟must相反，必须不匹配条件
      <span class="token key atrule">"should"</span><span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token punctuation">]</span> // should条件，类似SQL中or<span class="token punctuation">,</span> 代表匹配其中一个条件
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> 
<ul><li>must条件：类似SQL的and，代表必须匹配的条件。</li><li>must_not条件：跟must作用刚好相反，相当于sql语句中的 !=</li><li>should条件：类似SQL中的 or， 只要匹配其中一个条件即可</li></ul> 
<hr> 
<h6><a id="_372"></a><code>排序</code></h6> 
<p>假设我们现在要查询订单列表，那么返回符合条件的列表肯定不会是无序的，一般都是按照时间进行排序的，所以我们就要使用到了排序语句。<br> <code>ES</code>的默认排序是根据相关性分数排序，如果我们想根据查询结果中的指定字段排序。</p> 
<p><code>sort</code>子句支持多个字段排序，类似SQL的<code>order by</code>。</p> 
<pre><code class="prism language-yaml">GET /<span class="token punctuation">{<!-- --></span>索引名<span class="token punctuation">}</span>/_search
<span class="token punctuation">{<!-- --></span>
  <span class="token key atrule">"query"</span><span class="token punctuation">:</span> <span class="token punctuation">{<!-- --></span>
    <span class="token punctuation">...</span>查询条件<span class="token punctuation">...</span>.
  <span class="token punctuation">}</span><span class="token punctuation">,</span>
  <span class="token key atrule">"sort"</span><span class="token punctuation">:</span> <span class="token punctuation">[</span>
    <span class="token punctuation">{<!-- --></span>
      <span class="token key atrule">"{Field1}"</span><span class="token punctuation">:</span> <span class="token punctuation">{<!-- --></span> // 排序字段1
        <span class="token key atrule">"order"</span><span class="token punctuation">:</span> "desc" // 排序方向，asc或者desc<span class="token punctuation">,</span> 升序和降序
      <span class="token punctuation">}</span>
    <span class="token punctuation">}</span><span class="token punctuation">,</span>
    <span class="token punctuation">{<!-- --></span>
      <span class="token key atrule">"{Field2}"</span><span class="token punctuation">:</span> <span class="token punctuation">{<!-- --></span> // 排序字段2
        <span class="token key atrule">"order"</span><span class="token punctuation">:</span> "desc" // 排序方向，asc或者desc<span class="token punctuation">,</span> 升序和降序
      <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
    <span class="token punctuation">...</span>.多个排序字段<span class="token punctuation">...</span>..
  <span class="token punctuation">]</span>
<span class="token punctuation">}</span>
</code></pre> 
<hr> 
<h6><a id="_399"></a><code>聚合查询</code></h6> 
<p><code>ES</code>中的聚合查询，类似<code>SQL</code>的<code>SUM</code>/<code>AVG</code>/<code>COUNT</code>/<code>GROUP BY</code>分组查询，主要用于统计分析场景。</p> 
<p>一般统计分析主要分为两个步骤：</p> 
<ul><li><code>分组</code>： 
  <ul><li>对查询的数据首先进行一轮分组，可以设置分组条件 
    <ul><li>例如：新生入学，把所有的学生按专业分班，这个分班的过程就是对学生进行了分组。</li></ul> </li></ul> </li><li><code>组内聚合</code>： 
  <ul><li>组内聚合，就是对组内的数据进行统计 
    <ul><li>例如：计算总数、求平均值等等，接上面的例子，学生都按专业分班了，那么就可以统计每个班的学生总数， 这个统计每个班学生总数的计算，就是组内聚合计算。</li></ul> </li></ul> </li></ul> 
<p>一些概念：</p> 
<p>1.<code> 桶</code>：</p> 
<ul><li>桶的就是一组数据的集合，对数据分组后，得到一组组的数据，就是一个个的桶。 
  <ul><li>ES中桶聚合，指的就是先对数据进行分组。</li></ul> </li></ul> 
<ol start="2"><li><code>指标</code>：指标指的是对文档进行统计计算方式，又叫指标聚合。 
  <ul><li><code>桶内聚合</code>，说的就是先对数据进行分组（分桶），然后对每一个桶内的数据进行<code>指标聚合</code>。 
    <ul><li>其实就是，前面将数据经过一轮桶聚合，把数据分成一个个的桶之后，我们根据上面计算指标对桶内的数据进行统计。</li><li>常用的指标有：<code>SUM</code>、<code>COUNT</code>、<code>MAX</code>等统计函数。</li></ul> </li></ul> </li></ol> 
<pre><code class="prism language-yaml"><span class="token punctuation">{<!-- --></span>
  <span class="token key atrule">"aggregations"</span> <span class="token punctuation">:</span> <span class="token punctuation">{<!-- --></span>
    <span class="token key atrule">"&lt;aggregation_name&gt;"</span> <span class="token punctuation">:</span> <span class="token punctuation">{<!-- --></span>
        <span class="token key atrule">"&lt;aggregation_type&gt;"</span> <span class="token punctuation">:</span> <span class="token punctuation">{<!-- --></span>
            &lt;aggregation_body<span class="token punctuation">&gt;</span>
        <span class="token punctuation">}</span>
        <span class="token punctuation">[</span><span class="token punctuation">,</span><span class="token key atrule">"aggregations"</span> <span class="token punctuation">:</span> <span class="token punctuation">{<!-- --></span> <span class="token punctuation">[</span>&lt;sub_aggregation<span class="token punctuation">&gt;</span><span class="token punctuation">]</span>+ <span class="token punctuation">}</span> <span class="token punctuation">]</span><span class="token punctuation">?</span> // 嵌套聚合查询，支持多层嵌套
    <span class="token punctuation">}</span>
    <span class="token punctuation">[</span><span class="token punctuation">,</span><span class="token key atrule">"&lt;aggregation_name_2&gt;"</span> <span class="token punctuation">:</span> <span class="token punctuation">{<!-- --></span> <span class="token punctuation">...</span> <span class="token punctuation">}</span> <span class="token punctuation">]</span>* // 多个聚合查询，每个聚合查询取不同的名字
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> 
<ul><li><code>aggregations</code> 
  <ul><li>代表聚合查询语句，可以简写为aggs</li></ul> </li><li><code>&lt;aggregation_name&gt; </code> 
  <ul><li>代表一个聚合计算的名字，可以随意命名，因为ES支持一次进行多次统计分析查询，后面需要通过这个名字在查询结果中找到我们想要的计算结果。</li></ul> </li><li><code>&lt;aggregation_type&gt; </code> 
  <ul><li>聚合类型，代表我们想要怎么统计数据，主要有两大类聚合类型，桶聚合和指标聚合，这两类聚合又包括多种聚合类型</li><li>例如：指标聚合：<code>sum</code>、<code>avg</code>， 桶聚合：<code>terms</code>、<code>Date histogram</code>等等。</li></ul> </li><li><code>&lt;aggregation_body&gt; </code> 
  <ul><li>聚合类型的参数，选择不同的聚合类型，有不同的参数。</li></ul> </li><li><code>aggregation_name_2 </code> 
  <ul><li>代表其他聚合计算的名字，意思就是可以一次进行多种类型的统计。</li></ul> </li></ul> 
<p>例子：</p> 
<pre><code class="prism language-yaml">GET /order/_search
<span class="token punctuation">{<!-- --></span>
    <span class="token key atrule">"size"</span> <span class="token punctuation">:</span> <span class="token number">0</span><span class="token punctuation">,</span> // 设置size=0的意思就是，仅返回聚合查询结果，不返回普通query查询结果。
    <span class="token key atrule">"aggs"</span> <span class="token punctuation">:</span> <span class="token punctuation">{<!-- --></span> // 简写
        <span class="token key atrule">"count_store"</span> <span class="token punctuation">:</span> <span class="token punctuation">{<!-- --></span> // 聚合查询名字
            <span class="token key atrule">"terms"</span> <span class="token punctuation">:</span> <span class="token punctuation">{<!-- --></span> // 聚合类型为，terms，terms是桶聚合的一种，类似SQL的group by的作用，根据字段分组，相同字段值的文档分为一组。
              <span class="token key atrule">"field"</span> <span class="token punctuation">:</span> "store_name" // terms聚合类型的参数，这里需要设置分组的字段为store_name，根据store_name分组
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> 
<h6><a id="count_461"></a><code>count函数</code></h6> 
<p><code>Value Count</code>：值聚合，主要用于统计文档总数，类似<code>SQL</code>的<code>count</code>函数。</p> 
<pre><code class="prism language-yaml">GET /sales/_search<span class="token punctuation">?</span>size=0
<span class="token punctuation">{<!-- --></span>
  <span class="token key atrule">"aggs"</span><span class="token punctuation">:</span> <span class="token punctuation">{<!-- --></span>
    <span class="token key atrule">"types_count"</span><span class="token punctuation">:</span> <span class="token punctuation">{<!-- --></span> // 聚合查询的名字，随便取个名字
      <span class="token key atrule">"value_count"</span><span class="token punctuation">:</span> <span class="token punctuation">{<!-- --></span> // 聚合类型为：value_count
        <span class="token key atrule">"field"</span><span class="token punctuation">:</span> "type" // 计算type这个字段值的总数
      <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> 
<h6><a id="cardinality_476"></a><code>cardinality</code></h6> 
<p>基数聚合，也是用于统计文档的总数，跟<code>Value Count</code>的区别是，基数聚合会去重，不会统计重复的值，类似<code>SQL</code>的count(DISTINCT 字段)用法。</p> 
<pre><code class="prism language-yaml">POST /sales/_search<span class="token punctuation">?</span>size=0
<span class="token punctuation">{<!-- --></span>
    <span class="token key atrule">"aggs"</span> <span class="token punctuation">:</span> <span class="token punctuation">{<!-- --></span>
        <span class="token key atrule">"type_count"</span> <span class="token punctuation">:</span> <span class="token punctuation">{<!-- --></span> // 聚合查询的名字，随便取一个
            <span class="token key atrule">"cardinality"</span> <span class="token punctuation">:</span> <span class="token punctuation">{<!-- --></span> // 聚合查询类型为：cardinality
                <span class="token key atrule">"field"</span> <span class="token punctuation">:</span> "type" // 根据type这个字段统计文档总数
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> 
<h6><a id="avg_491"></a><code>avg</code>求平均值</h6> 
<pre><code class="prism language-yaml">POST /exams/_search<span class="token punctuation">?</span>size=0
<span class="token punctuation">{<!-- --></span>
  <span class="token key atrule">"aggs"</span><span class="token punctuation">:</span> <span class="token punctuation">{<!-- --></span>
    <span class="token key atrule">"avg_grade"</span><span class="token punctuation">:</span> <span class="token punctuation">{<!-- --></span> // 聚合查询名字，随便取一个名字
      <span class="token key atrule">"avg"</span><span class="token punctuation">:</span> <span class="token punctuation">{<!-- --></span> <span class="token key atrule">// 聚合查询类型为</span><span class="token punctuation">:</span> avg
        <span class="token key atrule">"field"</span><span class="token punctuation">:</span> "grade" // 统计grade字段值的平均值
      <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> 
<h6><a id="Sum_505"></a><code>Sum</code>求和计算</h6> 
<pre><code class="prism language-yaml">POST /sales/_search<span class="token punctuation">?</span>size=0
<span class="token punctuation">{<!-- --></span>
  <span class="token key atrule">"aggs"</span><span class="token punctuation">:</span> <span class="token punctuation">{<!-- --></span>
    <span class="token key atrule">"hat_prices"</span><span class="token punctuation">:</span> <span class="token punctuation">{<!-- --></span> // 聚合查询名字，随便取一个名字
      <span class="token key atrule">"sum"</span><span class="token punctuation">:</span> <span class="token punctuation">{<!-- --></span> // 聚合类型为：sum
        <span class="token key atrule">"field"</span><span class="token punctuation">:</span> "price" // 计算price字段值的总和
      <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> 
<h6><a id="max_519"></a><code>max</code>求最大值</h6> 
<pre><code class="prism language-yaml">POST /sales/_search<span class="token punctuation">?</span>size=0
<span class="token punctuation">{<!-- --></span>
  <span class="token key atrule">"aggs"</span><span class="token punctuation">:</span> <span class="token punctuation">{<!-- --></span>
    <span class="token key atrule">"max_price"</span><span class="token punctuation">:</span> <span class="token punctuation">{<!-- --></span> // 聚合查询名字<span class="token punctuation">,</span>随便取一个名字
      <span class="token key atrule">"max"</span><span class="token punctuation">:</span> <span class="token punctuation">{<!-- --></span> // 聚合类型为：max
        <span class="token key atrule">"field"</span><span class="token punctuation">:</span> "price" // 求price字段的最大值
      <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> 
<h6><a id="min_533"></a><code>min</code>求最小值</h6> 
<pre><code class="prism language-yaml">POST /sales/_search<span class="token punctuation">?</span>size=0
<span class="token punctuation">{<!-- --></span>
  <span class="token key atrule">"aggs"</span><span class="token punctuation">:</span> <span class="token punctuation">{<!-- --></span>
    <span class="token key atrule">"min_price"</span><span class="token punctuation">:</span> <span class="token punctuation">{<!-- --></span> // 聚合查询名字，随便取一个
      <span class="token key atrule">"min"</span><span class="token punctuation">:</span> <span class="token punctuation">{<!-- --></span> <span class="token key atrule">// 聚合类型为</span><span class="token punctuation">:</span> min
        <span class="token key atrule">"field"</span><span class="token punctuation">:</span> "price" // 求price字段值的最小值
      <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>到了这里查询语法就全部结束了，但是语法只是语法，如何去用包的API去调用就是一个非常重要的问题。这里我说明一下。无论是什么Elasticsearch语句，最后都会转换成相应的接口API去实现的。所以调用也会变得简单。</p> 
<p>具体API调用方式请看这个文章：<a href="https://blog.csdn.net/Cheer_RIO/article/details/135204439?csdn_share_tail=%7B%22type%22:%22blog%22,%22rType%22:%22article%22,%22rId%22:%22135204439%22,%22source%22:%22Cheer_RIO%22%7D">GoLang学习之路，对Elasticsearch的使用，一文足以（包括泛型使用思想）（二）</a></p> 
<p>本来是想继续写下去，但是超过一万字真的好卡啊。。。。。csdn什么扩充一下啊。</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/8a2fb2e5fb2c57d73e765f096180ae03/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">小米汽车首款车型SU7亮相，定位C级高性能生态科技轿车</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/d699edd56074ac28d8c75ac9fb4f62a5/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">【Electron】富文本编辑器之文本粘贴</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>