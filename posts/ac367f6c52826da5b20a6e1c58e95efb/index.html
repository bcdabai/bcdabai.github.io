<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Hibernate中的Session详解 - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Hibernate中的Session详解" />
<meta property="og:description" content="Session缓存 session缓存是由一系列的Java集合构成的。当一个对象被加入到Session缓存中，这个对象的引用就加入到了java的集合中，以后即使应用程序中的引用变量不再引用该对象，只要Session缓存不被清空，这个对象一直处于生命周期中。
Session缓存的作用：
1）减少访问数据库的频率。
2）保证缓存中的对象与数据库中的相关记录保持同步。
Session清理缓存的时机：
1）当调用Transaction的commit()方法时，commit()方法先清理缓存（前提是FlushMode.COMMIT/AUTO），然后再向数据库提交事务。
2）当应用程序调用Session的find()或者iterate()时，如果缓存中的持久化对象的属性发生了变化，就会先清理缓存，以保证查询结果能反映持久化对象的最新状态。
3）当应用程序显示调用Session的flush()方法的时候。
Session清理模式执行清理缓存操作的时间点：
Session接口 Session接口是Hibernate向应用程序提供的操纵数据库的最主要的接口，它提供了基本的保存，更新，删除和查询的方法。
1.save()： 把一个临时对象加入到缓存中，是它变成持久化对象
--&gt;选用映射文件指定的主键生成器为持久化对象分配唯一的OID
--&gt;计划一条insert语句，把参数对象当前的属性值组装到insert语句中，但是save()方法并不立即执行SQL insert语句，只有当Session清理缓存时候才会执行。
--&gt;如果在save()方法之后，又修改了持久化对象的属性，会使得Session在清理缓存的时候额外执行SQL update语句。
注意：save()方法是用来持久化一个临时对象的！
如果将一个持久化对象传给save()方法将不会执行任何操作，多余的步骤
如果将一个游离态对象传给save()方法，session会将它当作临时对象来处理，再次向数据库中插入一条记录，不符合业务需求！
2.update()：把Customer对象重新加入到Session缓存中，使之变为持久化对象。
---&gt;计划一条update语句，只有在清理缓存的时候才会执行，并且在执行的时候才会把参数对象中的属性值组装到update语句中。
注意：update()是将一个游离对象转变为持久化对象的。
只要通过update()方法使游离对象被一个session关联，即使没有修改参数对象的任何属性，Session在清理缓存的时候也会执行由update方法计划的Update语句。
3.saveOrUpdate()：同时包含了save()与update()方法的功能，如果传入的参数是临时对象，调用save方法，如果参入参数是游离对象，调用update()方法，如果传入的是持久化对象，直接返回。
4.load()/get(): 都会根据给定的OID从数据库中加载一个持久化对象，区别在于，当数据库中不存在与OID对应的记录时，load()方法会抛出ObjectNotFoundException异常，而get()方法返回null.
5.delete()：用于从数据库中删除与参数对象对应的记录，如果传入的参数是持久化对象，Session就计划执行一个delete语句，如果传入的参数是游离对象，先使游离对象被Session关联，使它变为持久化对象，然后计划一个delete语句，在清理缓存的时候执行。
6.evict()：从缓存中清除参数指定的持久化对象。
适用场合：不希望Session继续按照该对象的状态改变来同步更新数据库。
在批量更新或批量删除的场合，当更新或者删除一个对象后，及时释放该对象占用的内存。当然批量操作优先考虑JDBC.
7.clear()：清空缓存中所有持久化对象。
下一篇说一下Hibernate的get和load方法的区别~" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/ac367f6c52826da5b20a6e1c58e95efb/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2016-07-23T23:33:43+08:00" />
<meta property="article:modified_time" content="2016-07-23T23:33:43+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Hibernate中的Session详解</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <h2><span style="color:#ff0000">Session缓存</span></h2> 
<div> 
 <p><span style="font-size:14px">session<span style="font-family:宋体">缓存是由一系列的</span><span style="font-family:Calibri">Java</span><span style="font-family:宋体">集合构成的。当一个对象被加入到</span><span style="font-family:Calibri">Session</span><span style="font-family:宋体">缓存中，这个对象的引用就加入到了</span><span style="font-family:Calibri">java</span><span style="font-family:宋体">的集合中，以后即使应用程序中的引用变量不再引用该对象，只要</span><span style="font-family:Calibri">Session</span><span style="font-family:宋体">缓存不被清空，这个对象一直处于生命周期中。</span></span></p> 
 <p><span style="font-size:14px"> <strong> Session<span style="font-family:宋体">缓存的作用</span></strong>：</span></p> 
 <p><span style="font-size:14px">  1<span style="font-family:宋体">）减少访问数据库的频率。</span></span></p> 
 <p><span style="font-size:14px">  2<span style="font-family:宋体">）保证缓存中的对象与数据库中的相关记录保持同步。</span></span></p> 
 <p><span style="font-size:14px"> <strong> Session<span style="font-family:宋体">清理缓存的时机：</span></strong></span></p> 
 <p><span style="font-size:14px">  1<span style="font-family:宋体">）当调用</span><span style="font-family:Calibri">Transaction</span><span style="font-family:宋体">的</span><span style="font-family:Calibri">commit()</span><span style="font-family:宋体">方法时，</span><span style="font-family:Calibri">commit()</span><span style="font-family:宋体">方法先清理缓存（前提是</span><span style="font-family:Calibri">FlushMode.COMMIT/AUTO</span><span style="font-family:宋体">），然后再向数据库提交事务。</span></span></p> 
 <p><span style="font-size:14px">  2<span style="font-family:宋体">）当应用程序调用</span><span style="font-family:Calibri">Session</span><span style="font-family:宋体">的</span><span style="font-family:Calibri">find()</span><span style="font-family:宋体">或者</span><span style="font-family:Calibri">iterate()</span><span style="font-family:宋体">时，如果缓存中的持久化对象的属性发生了变化，就会先清理缓存，以保证查询结果能反映持久化对象的最新状态。</span></span></p> 
 <p><span style="font-size:14px">  3<span style="font-family:宋体">）当应用程序显示调用</span><span style="font-family:Calibri">Session</span><span style="font-family:宋体">的</span><span style="font-family:Calibri">flush()</span><span style="font-family:宋体">方法的时候。</span></span></p> 
 <p><span style="font-size:14px"> <strong> Session<span style="font-family:宋体">清理模式执行清理缓存操作的时间点：</span></strong></span></p> 
 <p><span style="font-size:14px"><strong><span style="font-family:宋体"><img src="https://images2.imgbox.com/96/3c/GBIZFzZa_o.png" alt=""><br> </span></strong></span></p> 
 <h2><span style="font-family:宋体"><span style="font-size:24px; color:#ff0000">Session接口</span></span></h2> 
 <p><span style="font-size:14px"><span style="font-family:宋体"></span></span></p> 
 <p>Session<span style="font-family:宋体">接口是</span><span style="font-family:Calibri">Hibernate</span><span style="font-family:宋体">向应用程序提供的操纵数据库的最主要的接口，它提供了基本的保存，更新，删除和查询的方法。</span></p> 
 <p><span style="color:#ff0000">1.save()</span><span style="font-family:宋体">：</span> 把一个临时对象加入到缓存中，是它变成持久化对象</p> 
 <p>--&gt;<span style="font-family:宋体">选用映射文件指定的主键生成器为持久化对象分配唯一的</span><span style="font-family:Calibri">OID</span></p> 
 <p>--&gt;<span style="font-family:宋体">计划一条</span><span style="font-family:Calibri">insert</span><span style="font-family:宋体">语句，把参数对象当前的属性值组装到</span><span style="font-family:Calibri">insert</span><span style="font-family:宋体">语句中，但是</span><span style="font-family:Calibri">save()</span><span style="font-family:宋体">方法并不立即执行</span><span style="font-family:Calibri">SQL insert</span><span style="font-family:宋体">语句，只有当</span><span style="font-family:Calibri">Session</span><span style="font-family:宋体">清理缓存时候才会执行。</span></p> 
 <p>--&gt;<span style="font-family:宋体">如果在</span><span style="font-family:Calibri">save()</span><span style="font-family:宋体">方法之后，又修改了持久化对象的属性，会使得</span><span style="font-family:Calibri">Session</span><span style="font-family:宋体">在清理缓存的时候额外执行</span><span style="font-family:Calibri">SQL update</span><span style="font-family:宋体">语句。</span></p> 
 <p>注意：<span style="font-family:Calibri">save()</span><span style="font-family:宋体">方法是用来持久化一个临时对象的！</span></p> 
 <p>  如果将一个持久化对象传给<span style="font-family:Calibri">save()</span><span style="font-family:宋体">方法将不会执行任何操作，多余的步骤</span></p> 
 <p>  如果将一个游离态对象传给<span style="font-family:Calibri">save()</span><span style="font-family:宋体">方法，</span><span style="font-family:Calibri">session</span><span style="font-family:宋体">会将它当作临时对象来处理，再次向数据库中插入一条记录，不符合业务需求！</span></p> 
 <p><span style="color:#ff0000">2.update()</span><span style="font-family:宋体">：</span>把<span style="font-family:Calibri">Customer</span><span style="font-family:宋体">对象重新加入到</span><span style="font-family:Calibri">Session</span><span style="font-family:宋体">缓存中，使之变为持久化对象。</span></p> 
 <p>   ---&gt;<span style="font-family:宋体">计划一条</span><span style="font-family:Calibri">update</span><span style="font-family:宋体">语句，只有在清理缓存的时候才会执行，并且在执行的时候才会把参数对象中的属性值组装到</span><span style="font-family:Calibri">update</span><span style="font-family:宋体">语句中。</span></p> 
 <p>注意：<span style="font-family:Calibri">update()</span><span style="font-family:宋体">是将一个</span>游离对象转变为持久化对象的。</p> 
 <p>  只要通过<span style="font-family:Calibri">update()</span><span style="font-family:宋体">方法使游离对象被一个</span><span style="font-family:Calibri">session</span><span style="font-family:宋体">关联，即使没有修改参数对象的任何属性，</span><span style="font-family:Calibri">Session</span><span style="font-family:宋体">在清理缓存的时候也会执行由</span><span style="font-family:Calibri">update</span><span style="font-family:宋体">方法计划的</span><span style="font-family:Calibri">Update</span><span style="font-family:宋体">语句。</span></p> 
 <p><span style="color:#ff0000">3.saveOrUpdate()</span><span style="font-family:宋体">：同时包含了</span><span style="font-family:Calibri">save()</span><span style="font-family:宋体">与</span><span style="font-family:Calibri">update()</span><span style="font-family:宋体">方法的功能，如果传入的参数是临时对象，调用</span><span style="font-family:Calibri">save</span><span style="font-family:宋体">方法，如果参入参数是游离对象，调用</span><span style="font-family:Calibri">update()</span><span style="font-family:宋体">方法，如果传入的是持久化对象，直接返回。</span></p> 
 <p><span style="color:#ff0000">4.load()/get()</span>: 都会根据给定的<span style="font-family:Calibri">OID</span><span style="font-family:宋体">从数据库中加载一个持久化对象，区别在于，当数据库中不存在与</span><span style="font-family:Calibri">OID</span><span style="font-family:宋体">对应的记录时，</span><span style="font-family:Calibri">load()</span><span style="font-family:宋体">方法会抛出</span><span style="font-family:Calibri">ObjectNotFoundException</span><span style="font-family:宋体">异常，而</span><span style="font-family:Calibri">get()</span><span style="font-family:宋体">方法返回</span><span style="font-family:Calibri">null.</span></p> 
 <p><span style="color:#ff0000">5.delete()</span>：用于从数据库中删除与参数对象对应的记录，如果传入的参数是持久化对象，<span style="font-family:Calibri">Session</span><span style="font-family:宋体">就计划执行一个</span><span style="font-family:Calibri">delete</span><span style="font-family:宋体">语句，如果传入的参数是游离对象，先使游离对象被</span><span style="font-family:Calibri">Session</span><span style="font-family:宋体">关联，使它变为持久化对象，然后计划一个</span><span style="font-family:Calibri">delete</span><span style="font-family:宋体">语句，在清理缓存的时候执行。</span></p> 
 <p><span style="color:#ff0000">6.evict()</span><span style="font-family:宋体">：</span>从缓存中清除参数指定的持久化对象。</p> 
 <p>  适用场合：不希望<span style="font-family:Calibri">Session</span><span style="font-family:宋体">继续按照该对象的状态改变来同步更新数据库。</span></p> 
 <p>    在批量更新或批量删除的场合，当更新或者删除一个对象后，及时释放该对象占用的内存。当然批量操作优先考虑<span style="font-family:Calibri">JDBC.</span></p> 
 <p><span style="color:#ff0000">7.clear()</span><span style="font-family:宋体">：</span>清空缓存中所有持久化对象。</p> 
 <p><br> </p> 
 <p><span style="font-size:14px"><strong><span style="font-family:宋体"><br> </span></strong></span></p> 
 <p><span style="font-size:14px"><strong><span style="font-family:宋体">下一篇说一下Hibernate的get和load方法的区别~</span></strong></span></p> 
 <p><span style="font-size:14px"><strong><span style="font-family:宋体"><br> </span></strong></span></p> 
 <p><span style="font-size:14px"><strong><span style="font-family:宋体"><br> </span></strong></span></p> 
 <br> 
</div>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/916b1f0334ecbb4dec9bb4d6ef2ea2dc/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">DOM节点操作</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/69c9cfe0c114be6fd7d6fff6f9c4dd46/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">Hyper-V双网卡的正确设置</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>