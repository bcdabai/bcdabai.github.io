<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>vue-router详解及实例 - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="vue-router详解及实例" />
<meta property="og:description" content="写在前面 用户进行了交互操作，现在要对页面内容进行变更，可以通过javascript进行动态替换DOM，但是其不便于分享、收藏，对于搜索引擎和用户来说都是不友好的！
什么是前端路由？
​ 根据不同的 url 地址展示不同的内容或页面，无需依赖服务器根据不同URL进行页面展示操作
优点
用户体验好，不需要每次都从服务器全部获取，快速展现给用户 缺点
使用浏览器的前进，后退键的时候会重新发送请求，没有合理地利用缓存单页面无法记住之前滚动的位置，无法在前进，后退的时候记住滚动的位置 简介 ​ 使用 Vue.js ，可以通过组合组件来组成应用程序，当你要把 vue-router 添加进来，我们需要做的是，将组件(components)映射到路由(routes)，然后告诉 vue-router 在哪里渲染它们。
// 1. 定义、引用（路由）组件。 const Foo = { template: &#39;&lt;div&gt;foo&lt;/div&gt;&#39; } import Bar from &#39;@/views/bar.vue&#39; // 2. 定义路由 const routes = [ { path: &#39;/foo&#39;, name: &#39;foo&#39;, component: Foo }, { path: &#39;/bar&#39;, name: &#39;bar&#39;, component: Bar } ] // 3. 创建 router 实例，然后传 `routes` 配置 const router = new VueRouter({ routes // （缩写）相当于 routes: routes }) // 4." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/98dd810601db8cabec43017452e57e90/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2018-01-13T16:01:20+08:00" />
<meta property="article:modified_time" content="2018-01-13T16:01:20+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">vue-router详解及实例</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-light">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <h3 id="写在前面">写在前面</h3> 
<p>用户进行了交互操作，现在要对页面内容进行变更，可以通过javascript进行动态替换DOM，但是其不便于分享、收藏，对于搜索引擎和用户来说都是不友好的！</p> 
<p><strong>什么是前端路由？</strong></p> 
<p>​ 根据不同的 url 地址展示不同的内容或页面，无需依赖服务器根据不同URL进行页面展示操作</p> 
<p><strong>优点</strong></p> 
<ul><li>用户体验好，不需要每次都从服务器全部获取，快速展现给用户</li></ul> 
<p><strong>缺点</strong></p> 
<ul><li>使用浏览器的前进，后退键的时候会重新发送请求，没有合理地利用缓存</li><li>单页面无法记住之前滚动的位置，无法在前进，后退的时候记住滚动的位置</li></ul> 
<h3 id="简介">简介</h3> 
<p>​ 使用 Vue.js ，可以通过组合组件来组成应用程序，当你要把 vue-router 添加进来，我们需要做的是，将组件(components)映射到路由(routes)，然后告诉 vue-router 在哪里渲染它们。</p> 
<pre class="prettyprint"><code class="language-javascript hljs "><span class="hljs-comment">// 1. 定义、引用（路由）组件。</span>
<span class="hljs-keyword">const</span> Foo = { template: <span class="hljs-string">'&lt;div&gt;foo&lt;/div&gt;'</span> }
import Bar from <span class="hljs-string">'@/views/bar.vue'</span>

<span class="hljs-comment">// 2. 定义路由</span>
<span class="hljs-keyword">const</span> routes = [
  { path: <span class="hljs-string">'/foo'</span>, name: <span class="hljs-string">'foo'</span>, component: Foo },
  { path: <span class="hljs-string">'/bar'</span>, name: <span class="hljs-string">'bar'</span>, component: Bar }
]

<span class="hljs-comment">// 3. 创建 router 实例，然后传 `routes` 配置</span>
<span class="hljs-keyword">const</span> router = <span class="hljs-keyword">new</span> VueRouter({
  routes <span class="hljs-comment">// （缩写）相当于 routes: routes</span>
})

<span class="hljs-comment">// 4. 创建和挂载根实例。通过 router 配置参数注入路</span>
<span class="hljs-keyword">const</span> app = <span class="hljs-keyword">new</span> Vue({
  router
}).$mount(<span class="hljs-string">'#app'</span>)
</code></pre> 
<h3 id="动态路由匹配">动态路由匹配</h3> 
<p>两种方式传递<code>$route.params</code>和<code>$route.query</code></p> 
<table><thead><tr><th>模式</th><th>匹配路径</th><th>获取参数（路由信息对象）</th></tr></thead><tbody><tr><td>/user/:username</td><td>/user/ligang</td><td><code>$route.params.username</code></td></tr><tr><td>/user?:username</td><td>/user?username=ligang</td><td><code>$route.query.username</code></td></tr></tbody></table> 
<h4 id="响应路由参数的变化">响应路由参数的变化</h4> 
<p>​ 当使用路由参数时，例如从 <code>/user/ligang</code> 导航到 <code>user/lg</code>，<strong>原来的组件实例会被复用</strong>。因为两个路由都渲染同个组件，比起销毁再创建，复用则显得更加高效。<strong>不过，这也意味着组件的生命周期钩子不会再被调用</strong>。</p> 
<p><strong>方式一：简单地watch(监测变化)$route对象</strong></p> 
<pre class="prettyprint"><code class="language-javascript hljs "> watch: {
    <span class="hljs-string">'$route'</span> (to, from) {
      <span class="hljs-comment">// 对路由变化作出响应...</span>
    }
  }</code></pre> 
<p><strong>方式二：使用 2.2 中引入的 <code>beforeRouteUpdate</code> 守卫</strong></p> 
<pre class="prettyprint"><code class="language-javascript hljs ">beforeRouteUpdate (to, from, next) {
  <span class="hljs-comment">// 对路由变化作出响应...不要忘记调用next()</span>
}</code></pre> 
<p><strong>示例</strong>：新增和编辑使用同一模块，从编辑切换到新增页面信息不会更新！</p> 
<pre class="prettyprint"><code class="language-javascript hljs ">{
  path: <span class="hljs-string">'add'</span>,
  name: <span class="hljs-string">'setting-user-manager-add'</span>,
  component: () =&gt; import(<span class="hljs-string">'@/views/setting/user-manager/add-edit.vue'</span>),
  meta: {name: <span class="hljs-string">'用户新增'</span>}
}, {
  path: <span class="hljs-string">'edit'</span>,
  name: <span class="hljs-string">'setting-user-manager-edit'</span>,
  component: () =&gt; import(<span class="hljs-string">'@/views/setting/user-manager/add-edit.vue'</span>),
  meta: {
      name: <span class="hljs-string">'用户编辑'</span>,
      hidden: <span class="hljs-literal">true</span>
  }
}</code></pre> 
<h3 id="嵌套路由">嵌套路由</h3> 
<pre class="prettyprint"><code class="language-javascript hljs ">routes: [{ 
    path: <span class="hljs-string">'/user/:id'</span>, 
    component: User,
    children: [
        <span class="hljs-comment">// 匹配 /user/:id</span>
        { path: <span class="hljs-string">''</span>, component: UserHome },
        <span class="hljs-comment">// 匹配 /user/:id/profile</span>
        { path: <span class="hljs-string">'profile'</span>, component: UserProfile },
        <span class="hljs-comment">// 匹配 /user/:id/posts</span>
        { path: <span class="hljs-string">'posts'</span>, component: UserPosts }
    ]
}]</code></pre> 
<p><strong>要注意，以 / 开头的嵌套路径会被当作根路径。 这让你充分的使用嵌套组件而无须设置嵌套的路径。</strong></p> 
<h3 id="编程式导航">编程式导航</h3> 
<h4 id="routerpushlocation-oncomplete-onabort"><code>router.push(location, onComplete?, onAbort?)</code></h4> 
<table><thead><tr><th>声明式</th><th>编程式</th></tr></thead><tbody><tr><td><code>&lt;router-link :to="..."&gt;</code></td><td><code>router.push(...)</code></td></tr></tbody></table> 
<pre class="prettyprint"><code class="language-javascript hljs "><span class="hljs-comment">// 方式一：字符串路径</span>
router.push(<span class="hljs-string">'/user'</span>)
<span class="hljs-comment">// 方式二：path对象</span>
router.push({ path: <span class="hljs-string">'/user'</span> })
<span class="hljs-comment">// 方式三：路由名称</span>
router.push({ name: <span class="hljs-string">'user'</span>})</code></pre> 
<p><strong>注意：如果提供了 path，params 会被忽略，query不会！！</strong></p> 
<pre class="prettyprint"><code class="language-javascript hljs "><span class="hljs-comment">// 不生效</span>
router.push({ path: <span class="hljs-string">'/user'</span>, params: { id: <span class="hljs-number">1</span> }})
<span class="hljs-comment">// params生效 /user/1</span>
router.push({ name: <span class="hljs-string">'user'</span>, params: { id: <span class="hljs-number">1</span> }}) <span class="hljs-comment">// 使用name方式</span>
router.push({ path: `/user/<span class="hljs-number">1</span>` }) <span class="hljs-comment">// 直接在path上扩充</span>
<span class="hljs-comment">// query不受影响 /user?id=1</span>
router.push({ path: <span class="hljs-string">'/user'</span>, query: { id: <span class="hljs-number">1</span> }})</code></pre> 
<h4 id="routerreplacelocation-oncomplete-onabort"><code>router.replace(location, onComplete?, onAbort?)</code></h4> 
<table><thead><tr><th>声明式</th><th>编程式</th></tr></thead><tbody><tr><td><code>&lt;router-link :to="..." replace&gt;</code></td><td><code>router.replace(...)</code></td></tr></tbody></table> 
<p>跟<code>router.push</code> 很像，唯一的不同就是，它不会向 history 添加新记录！</p> 
<h4 id="routergon"><code>router.go(n)</code></h4> 
<p>在 history 记录中向前或者后退多少步，类似 <code>window.history.go(n)</code></p> 
<h3 id="命名视图">命名视图</h3> 
<p>多个非嵌套视图展示，例如创建一个布局，有<code>header</code>头信息、 <code>sidebar</code>（侧导航） 和 <code>main</code>（主内容） 两个视图。</p> 
<pre class="prettyprint"><code class="language-vue hljs xml"><span class="hljs-tag">&lt;<span class="hljs-title">router-view</span> <span class="hljs-attribute">class</span>=<span class="hljs-value">"view header"</span> <span class="hljs-attribute">name</span>=<span class="hljs-value">"header"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-title">router-view</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-title">router-view</span> <span class="hljs-attribute">class</span>=<span class="hljs-value">"view sidebar"</span> <span class="hljs-attribute">name</span>=<span class="hljs-value">"sidebar"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-title">router-view</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-title">router-view</span> <span class="hljs-attribute">class</span>=<span class="hljs-value">"view main"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-title">router-view</span>&gt;</span></code></pre> 
<pre class="prettyprint"><code class="language-javascript hljs "><span class="hljs-keyword">const</span> router = <span class="hljs-keyword">new</span> VueRouter({
  routes: [
    {
      path: <span class="hljs-string">'/'</span>,
      components: {
        <span class="hljs-keyword">default</span>: mainComponent,
        sidebar: sidebarComponent,
        header: headerComponent
      }
    }
  ]
})</code></pre> 
<h3 id="重定向和别名">重定向和别名</h3> 
<h4 id="重定向">重定向</h4> 
<pre class="prettyprint"><code class="language-javascript hljs "><span class="hljs-comment">// 方式一：字符串路径path</span>
{ path: <span class="hljs-string">'/a'</span>, redirect: <span class="hljs-string">'/b'</span> }
<span class="hljs-comment">// 方式二：name</span>
{ path: <span class="hljs-string">'/a'</span>, redirect: {name: <span class="hljs-string">'b'</span>} }
<span class="hljs-comment">// 方式三：动态返回重定向目标</span>
{ path: <span class="hljs-string">'/a'</span>, redirect: to =&gt; {
  <span class="hljs-comment">/* 方法接收 目标路由 作为参数；return 重定向的 字符串路径/路径对象 */</span>
}}</code></pre> 
<h4 id="别名">别名</h4> 
<p><code>/a</code>的别名是<code>/b</code>，意味着当用户访问<code>/b</code>时，URL会保持为<code>/b</code>，但是路由匹配则为<code>/a</code>，就像用户访问<code>/a</code>一样。</p> 
<pre class="prettyprint"><code class="language-javascript hljs ">{ path: <span class="hljs-string">'/a'</span>, component: A, alias: <span class="hljs-string">'/b'</span> }</code></pre> 
<p>『别名』的功能让你可以自由地将 UI 结构映射到任意的 URL，而不是受限于配置的嵌套路由结构。</p> 
<p>示例：上述【动态路由匹配】可修改成如下，可能存在name问题</p> 
<pre class="prettyprint"><code class="language-javascript hljs ">{
  path: <span class="hljs-string">'add'</span>,
  name: <span class="hljs-string">'setting-user-manager-add'</span>,
  component: () =&gt; import(<span class="hljs-string">'@/views/setting/user-manager/add-edit.vue'</span>),
  meta: {name: <span class="hljs-string">'用户新增'</span>},
  alias: <span class="hljs-string">'edit'</span>
}</code></pre> 
<h3 id="向路由组件传递-props">向路由组件传递 props</h3> 
<h4 id="路由组件传参">路由组件传参</h4> 
<p><strong>默认(常规)方式：通过$route.params获取</strong></p> 
<pre class="prettyprint"><code class="language-vue hljs cs"><span class="hljs-keyword">const</span> User = {
  template: <span class="hljs-string">'&lt;div&gt;User {<!-- -->{ $route.params.id }}&lt;/div&gt;'</span>
}
<span class="hljs-keyword">const</span> router = <span class="hljs-keyword">new</span> VueRouter({
  routes: [{ path: <span class="hljs-string">'/user/:id'</span>, component: User }]
})</code></pre> 
<p><strong>使用props解耦：只需要将props设置为true</strong></p> 
<pre class="prettyprint"><code class="language-vue hljs cs"><span class="hljs-keyword">const</span> User = {
  props: [<span class="hljs-string">'id'</span>],
  template: <span class="hljs-string">'&lt;div&gt;User {<!-- -->{ id }}&lt;/div&gt;'</span>
}
<span class="hljs-keyword">const</span> router = <span class="hljs-keyword">new</span> VueRouter({
  routes: [{ path: <span class="hljs-string">'/user/:id'</span>, component: User, props: <span class="hljs-keyword">true</span> }]
})</code></pre> 
<p>注意：上述props不仅可以设置为布尔值，还可以设置为对象或函数，具体请查看:「<a href="https://router.vuejs.org/zh-cn/essentials/passing-props.html" rel="nofollow">https://router.vuejs.org/zh-cn/essentials/passing-props.html</a>」</p> 
<h3 id="html5-history-模式">HTML5 History 模式</h3> 
<pre class="prettyprint"><code class=" hljs r">const router = new VueRouter({
  mode: <span class="hljs-string">'history'</span>,
  routes: [<span class="hljs-keyword">...</span>]
})</code></pre> 
<p>需要后台配置，否则输入的除首页外都为404（当然系统内跳转可以）。具体ngix、Apache、node等配置参考：「<a href="https://router.vuejs.org/zh-cn/essentials/history-mode.html" rel="nofollow">https://router.vuejs.org/zh-cn/essentials/history-mode.html</a>」</p> 
<p><strong>这里说一下本地webpack需要增加的配置情况：</strong><code>historyApiFallback: true</code>「<a href="https://doc.webpack-china.org/configuration/dev-server/#devserver-historyapifallback" rel="nofollow">https://doc.webpack-china.org/configuration/dev-server/#devserver-historyapifallback</a>」vue-cli生成的默认webpack配置，</p> 
<pre class="prettyprint"><code class="language-javascript hljs ">historyApiFallback: {
  rewrites: [
    { from: <span class="hljs-regexp">/.*/</span>, to: path.join(config.dev.assetsPublicPath, <span class="hljs-string">'index.html'</span>) },
  ],
}</code></pre> 
<p>在window下特定node版本会有问题！</p> 
<h3 id="导航守卫">导航守卫</h3> 
<blockquote> 
 <p>『导航』表示路由正在发生改变</p> 
</blockquote> 
<p>导航守卫主要用来通过跳转或取消的方式守卫导航。注意<strong>参数或查询的改变并不会触发进入/离开的导航守卫</strong>。可以通过<a href="https://router.vuejs.org/zh-cn/essentials/dynamic-matching.html#%E5%93%8D%E5%BA%94%E8%B7%AF%E7%94%B1%E5%8F%82%E6%95%B0%E7%9A%84%E5%8F%98%E5%8C%96" rel="nofollow">观察 <code>$route</code> 对象</a>来应对这些变化，或使用 <code>beforeRouteUpdate</code> 的组件内守卫。</p> 
<h4 id="全局守卫">全局守卫</h4> 
<p>使用 <code>router.beforeEach</code> 注册一个全局前置守卫</p> 
<pre class="prettyprint"><code class="language-javascript hljs "><span class="hljs-keyword">const</span> router = <span class="hljs-keyword">new</span> VueRouter({ ... })
router.beforeEach((to, from, next) =&gt; {
  <span class="hljs-comment">// ...</span>
})</code></pre> 
<p>守卫是异步解析执行，此时导航在所有守卫 resolve 完之前一直处于 <strong>等待中</strong>。所以<strong>确保要调用 next 方法，否则钩子就不会被 resolved</strong>。</p> 
<h4 id="全局解析守卫">全局解析守卫</h4> 
<p>在 2.5.0+ 你可以用 <code>router.beforeResolve</code> 注册一个全局守卫。这和 <code>router.beforeEach</code> 类似，区别是在导航被确认之前，<strong>同时在所有组件内守卫和异步路由组件被解析之后</strong>，解析守卫就被调用。</p> 
<h4 id="全局后置钩子">全局后置钩子</h4> 
<p>你也可以注册全局后置钩子，然而和守卫不同的是，这些钩子不会接受 <code>next</code> 函数也不会改变导航本身：</p> 
<pre class="prettyprint"><code class="language-javascript hljs ">router.afterEach((to, from) =&gt; {
  <span class="hljs-comment">// ...</span>
})</code></pre> 
<h4 id="路由独享的守卫">路由独享的守卫</h4> 
<pre class="prettyprint"><code class="language-javascript hljs "><span class="hljs-keyword">const</span> router = <span class="hljs-keyword">new</span> VueRouter({
  routes: [
    {
      path: <span class="hljs-string">'/foo'</span>,
      component: Foo,
      beforeEnter: (to, from, next) =&gt; {
        <span class="hljs-comment">// ...</span>
      }
    }
  ]
})</code></pre> 
<h4 id="组件内的守卫">组件内的守卫</h4> 
<ul><li><code>beforeRouteEnter</code></li><li><code>beforeRouteUpdate</code> (2.2 新增)</li><li><code>beforeRouteLeave</code></li></ul> 
<p>需要注意的是beforeRouteEnter不能访问this，可以通过传一个回调给 <code>next</code>来访问组件实例。</p> 
<pre class="prettyprint"><code class="language-javascript hljs ">beforeRouteEnter (to, from, next) {
  next(vm =&gt; {
    <span class="hljs-comment">// 通过 `vm` 访问组件实例</span>
  })
}</code></pre> 
<h4 id="完整的导航解析流程">完整的导航解析流程</h4> 
<ol><li>导航被触发。</li><li>在失活的<strong>组件内</strong>调用离开守卫<code>beforeRouteLeave</code>。</li><li>调用<strong>全局</strong>的 <code>beforeEach</code> 守卫。</li><li>在重用的<strong>组件内</strong>调用 <code>beforeRouteUpdate</code> 守卫 (2.2+)。</li><li>在<strong>路由</strong>配置里调用<strong>独享</strong>守卫 <code>beforeEnter</code>。</li><li>解析异步路由组件。</li><li>在被激活的<strong>组件内</strong>调用 <code>beforeRouteEnter</code>。</li><li>调用<strong>全局</strong>的 <code>beforeResolve</code> 守卫 (2.5+)。</li><li>导航被确认。</li><li>调用<strong>全局</strong>的 <code>afterEach</code> 钩子。</li><li>触发 DOM 更新。</li><li>用创建好的实例调用 <code>beforeRouteEnter</code> 守卫中传给 <code>next</code> 的回调函数。</li></ol> 
<h3 id="路由元信息">路由元信息</h3> 
<p><code>meta</code> 字段来设置名称、是否需要验证、是否隐藏等附加信息！！</p> 
<p>一个路由匹配到的所有路由记录会暴露为 <code>$route</code> 对象（还有在导航守卫中的路有对象）的 <code>$route.matched</code> 数组。因此，我们需要遍历 <code>$route.matched</code> 来检查路由记录中的 <code>meta</code> 字段。</p> 
<pre class="prettyprint"><code class="language-javascript hljs "><span class="hljs-keyword">if</span> (to.meta.requireAuth) {   <span class="hljs-comment">// 判断该路由是否需要登录权限</span>
    <span class="hljs-keyword">if</span> (store.state.token) {  <span class="hljs-comment">// 通过vuex state获取当前的token是否存在</span>
        next();
    }<span class="hljs-keyword">else</span> {
        next({
            path: <span class="hljs-string">'/login'</span>,
            query: {redirect: to.fullPath}  <span class="hljs-comment">// 将跳转的路由path作为参数，登录成功后跳转到该路由</span>
        })
    }
}<span class="hljs-keyword">else</span> {
    next();
}</code></pre> 
<h3 id="数据获取">数据获取</h3> 
<p>有时候，进入某个路由后，需要从服务器获取数据。</p> 
<ul><li><p><strong>导航完成之后获取</strong>：先完成导航，然后在接下来的组件生命周期钩子中获取数据。在数据获取期间显示『加载中』之类的指示。</p> <p>该方式会马上导航和渲染组件，然后在组件的 <code>created</code> 钩子中获取数据。这让我们有机会在数据获取期间展示一个 loading 状态，还可以在不同视图间展示不同的 loading 状态。</p></li><li><p><strong>导航完成之前获取</strong>：导航完成前，在路由进入的守卫中获取数据，在数据获取成功后执行导航。</p> <p>该方式在导航转入新的路由前获取数据。我们可以在接下来的<strong>组件内</strong>的 <code>beforeRouteEnter</code> 守卫中获取数据，当数据获取成功后只调用 <code>next</code> 方法。</p></li></ul> 
<h3 id="滚动行为">滚动行为</h3> 
<p><strong>只在 HTML5 history 模式下可用。</strong>当切换到新路由时，想要页面滚到顶部，或者是保持原先的滚动位置，就像重新加载页面那样。 <code>vue-router</code> 能做到，而且更好，它让你可以自定义路由切换时页面如何滚动。</p> 
<pre class="prettyprint"><code class="language-javascript hljs "><span class="hljs-keyword">const</span> router = <span class="hljs-keyword">new</span> VueRouter({
  routes: [...],
  scrollBehavior (to, from, savedPosition) {
    <span class="hljs-comment">// return 期望滚动到哪个的位置</span>
  }
})</code></pre> 
<p>参考地址：「<a href="https://router.vuejs.org/zh-cn/advanced/scroll-behavior.html" rel="nofollow">https://router.vuejs.org/zh-cn/advanced/scroll-behavior.html</a>」</p> 
<h3 id="特别说明">特别说明</h3> 
<h4 id="router-实例">Router 实例</h4> 
<table><thead><tr><th>属性</th><th>说明</th></tr></thead><tbody><tr><td>router.app</td><td><code>router</code> 的 Vue 根实例</td></tr><tr><td>router.mode</td><td>路由使用的模式</td></tr><tr><td>router.currentRoute</td><td>当前路由对应的<strong>路由信息对象</strong></td></tr></tbody></table> 
<p>方法：router.beforeEach(guard)、router.beforeResolve(guard) 、router.afterEach(hook)、router.push(location, onComplete?, onAbort?)、router.replace(location, onComplete?, onAbort?)、router.go(n)、router.back()、router.forward()、router.getMatchedComponents(location?)、router.resolve(location, current?, append?)、router.addRoutes(routes)、router.onReady(callback, [errorCallback])、router.onError(callback)</p> 
<h4 id="路由信息对象">路由信息对象</h4> 
<p>每次成功的导航后都会产生一个新的对象</p> 
<ul><li><p>在组件内，即 <code>this.$route</code></p></li><li><p>在 <code>$route</code> 观察者回调内</p></li><li><p><code>router.match(location)</code> 的返回值</p></li><li><p>导航守卫的参数：</p> <pre class="prettyprint"><code class="language-javascript hljs ">router.beforeEach((to, from, next) =&gt; {
<span class="hljs-comment">// to 和 from 都是 路由信息对象</span>
})</code></pre></li><li><p><code>scrollBehavior</code> 方法的参数:</p> <pre class="prettyprint"><code class="language-javascript hljs "><span class="hljs-keyword">const</span> router = <span class="hljs-keyword">new</span> VueRouter({
scrollBehavior (to, from, savedPosition) {
  <span class="hljs-comment">// to 和 from 都是 路由信息对象</span>
}
})</code></pre> <p>其包含的属性值：<span class="MathJax_Preview"></span><span class="MathJax" id="MathJax-Element-24-Frame" style=""> 
     
     <span class="math" id="MathJax-Span-425" style="width: 6.253em; display: inline-block;"><span style="display: inline-block; position: relative; width: 5.211em; height: 0px; font-size: 120%;"><span style="position: absolute; clip: rect(1.565em 1000em 2.867em -0.414em); top: -2.497em; left: 0.003em;"><span class="mrow" id="MathJax-Span-426"><span class="mi" id="MathJax-Span-427" style="font-family: STIXGeneral-Italic;">r<span style="display: inline-block; overflow: hidden; height: 1px; width: 0.003em;"></span></span><span class="mi" id="MathJax-Span-428" style="font-family: STIXGeneral-Italic;">o</span><span class="mi" id="MathJax-Span-429" style="font-family: STIXGeneral-Italic;">u</span><span class="mi" id="MathJax-Span-430" style="font-family: STIXGeneral-Italic;">t<span style="display: inline-block; overflow: hidden; height: 1px; width: 0.003em;"></span></span><span class="mi" id="MathJax-Span-431" style="font-family: STIXGeneral-Italic;">e</span><span class="mo" id="MathJax-Span-432" style="font-family: STIXGeneral-Regular;">.</span><span class="mi" id="MathJax-Span-433" style="font-family: STIXGeneral-Italic; padding-left: 0.211em;">p</span><span class="mi" id="MathJax-Span-434" style="font-family: STIXGeneral-Italic;">a</span><span class="mi" id="MathJax-Span-435" style="font-family: STIXGeneral-Italic;">t<span style="display: inline-block; overflow: hidden; height: 1px; width: 0.003em;"></span></span><span class="mi" id="MathJax-Span-436" style="font-family: STIXGeneral-Italic;">h</span><span class="texatom" id="MathJax-Span-437"><span class="mrow" id="MathJax-Span-438"><span class="mo" id="MathJax-Span-439"><span style='font-family: STIXGeneral, "Arial Unicode MS", serif; font-size: 83%; font-style: normal; font-weight: normal;'>、</span></span></span></span></span><span style="display: inline-block; width: 0px; height: 2.503em;"></span></span></span><span style="border-left: 0.003em solid; display: inline-block; overflow: hidden; width: 0px; height: 1.316em; vertical-align: -0.309em;"></span></span> 
    </span><script type="math/tex" id="MathJax-Element-24">route.path、</script>route.params、<span class="MathJax_Preview"></span><span class="MathJax" id="MathJax-Element-25-Frame" style=""> 
     
     <span class="math" id="MathJax-Span-440" style="width: 6.826em; display: inline-block;"><span style="display: inline-block; position: relative; width: 5.68em; height: 0px; font-size: 120%;"><span style="position: absolute; clip: rect(1.565em 1000em 2.867em -0.414em); top: -2.497em; left: 0.003em;"><span class="mrow" id="MathJax-Span-441"><span class="mi" id="MathJax-Span-442" style="font-family: STIXGeneral-Italic;">r<span style="display: inline-block; overflow: hidden; height: 1px; width: 0.003em;"></span></span><span class="mi" id="MathJax-Span-443" style="font-family: STIXGeneral-Italic;">o</span><span class="mi" id="MathJax-Span-444" style="font-family: STIXGeneral-Italic;">u</span><span class="mi" id="MathJax-Span-445" style="font-family: STIXGeneral-Italic;">t<span style="display: inline-block; overflow: hidden; height: 1px; width: 0.003em;"></span></span><span class="mi" id="MathJax-Span-446" style="font-family: STIXGeneral-Italic;">e</span><span class="mo" id="MathJax-Span-447" style="font-family: STIXGeneral-Regular;">.</span><span class="mi" id="MathJax-Span-448" style="font-family: STIXGeneral-Italic; padding-left: 0.211em;">q</span><span class="mi" id="MathJax-Span-449" style="font-family: STIXGeneral-Italic;">u</span><span class="mi" id="MathJax-Span-450" style="font-family: STIXGeneral-Italic;">e</span><span class="mi" id="MathJax-Span-451" style="font-family: STIXGeneral-Italic;">r<span style="display: inline-block; overflow: hidden; height: 1px; width: 0.003em;"></span></span><span class="mi" id="MathJax-Span-452" style="font-family: STIXGeneral-Italic;">y</span><span class="texatom" id="MathJax-Span-453"><span class="mrow" id="MathJax-Span-454"><span class="mo" id="MathJax-Span-455"><span style='font-family: STIXGeneral, "Arial Unicode MS", serif; font-size: 83%; font-style: normal; font-weight: normal;'>、</span></span></span></span></span><span style="display: inline-block; width: 0px; height: 2.503em;"></span></span></span><span style="border-left: 0.003em solid; display: inline-block; overflow: hidden; width: 0px; height: 1.316em; vertical-align: -0.309em;"></span></span> 
    </span><script type="math/tex" id="MathJax-Element-25">route.query、</script>route.hash、<span class="MathJax_Preview"></span><span class="MathJax" id="MathJax-Element-26-Frame" style=""> 
     
     <span class="math" id="MathJax-Span-456" style="width: 8.128em; display: inline-block;"><span style="display: inline-block; position: relative; width: 6.773em; height: 0px; font-size: 120%;"><span style="position: absolute; clip: rect(1.565em 1000em 2.867em -0.414em); top: -2.497em; left: 0.003em;"><span class="mrow" id="MathJax-Span-457"><span class="mi" id="MathJax-Span-458" style="font-family: STIXGeneral-Italic;">r<span style="display: inline-block; overflow: hidden; height: 1px; width: 0.003em;"></span></span><span class="mi" id="MathJax-Span-459" style="font-family: STIXGeneral-Italic;">o</span><span class="mi" id="MathJax-Span-460" style="font-family: STIXGeneral-Italic;">u</span><span class="mi" id="MathJax-Span-461" style="font-family: STIXGeneral-Italic;">t<span style="display: inline-block; overflow: hidden; height: 1px; width: 0.003em;"></span></span><span class="mi" id="MathJax-Span-462" style="font-family: STIXGeneral-Italic;">e</span><span class="mo" id="MathJax-Span-463" style="font-family: STIXGeneral-Regular;">.</span><span class="mi" id="MathJax-Span-464" style="font-family: STIXGeneral-Italic; padding-left: 0.211em;">f<span style="display: inline-block; overflow: hidden; height: 1px; width: 0.159em;"></span></span><span class="mi" id="MathJax-Span-465" style="font-family: STIXGeneral-Italic;">u</span><span class="mi" id="MathJax-Span-466" style="font-family: STIXGeneral-Italic;">l<span style="display: inline-block; overflow: hidden; height: 1px; width: 0.003em;"></span></span><span class="mi" id="MathJax-Span-467" style="font-family: STIXGeneral-Italic;">l<span style="display: inline-block; overflow: hidden; height: 1px; width: 0.003em;"></span></span><span class="mi" id="MathJax-Span-468" style="font-family: STIXGeneral-Italic;">P</span><span class="mi" id="MathJax-Span-469" style="font-family: STIXGeneral-Italic;">a</span><span class="mi" id="MathJax-Span-470" style="font-family: STIXGeneral-Italic;">t<span style="display: inline-block; overflow: hidden; height: 1px; width: 0.003em;"></span></span><span class="mi" id="MathJax-Span-471" style="font-family: STIXGeneral-Italic;">h</span><span class="texatom" id="MathJax-Span-472"><span class="mrow" id="MathJax-Span-473"><span class="mo" id="MathJax-Span-474"><span style='font-family: STIXGeneral, "Arial Unicode MS", serif; font-size: 83%; font-style: normal; font-weight: normal;'>、</span></span></span></span></span><span style="display: inline-block; width: 0px; height: 2.503em;"></span></span></span><span style="border-left: 0.003em solid; display: inline-block; overflow: hidden; width: 0px; height: 1.316em; vertical-align: -0.309em;"></span></span> 
    </span><script type="math/tex" id="MathJax-Element-26">route.fullPath、</script>route.matched</p></li></ul> 
<blockquote> 
 <p><strong>重点强调</strong>：this.<span class="MathJax_Preview"></span><span class="MathJax" id="MathJax-Element-27-Frame" style=""> 
    
    <span class="math" id="MathJax-Span-475" style="width: 15.122em; display: inline-block;"><span style="display: inline-block; position: relative; width: 12.563em; height: 0px; font-size: 120%;"><span style="position: absolute; clip: rect(1.729em 1000em 2.741em -0.473em); top: -2.557em; left: 0.003em;"><span class="mrow" id="MathJax-Span-476"><span class="mi" id="MathJax-Span-477" style="font-family: STIXGeneral-Italic;">r<span style="display: inline-block; overflow: hidden; height: 1px; width: 0.003em;"></span></span><span class="mi" id="MathJax-Span-478" style="font-family: STIXGeneral-Italic;">o</span><span class="mi" id="MathJax-Span-479" style="font-family: STIXGeneral-Italic;">u</span><span class="mi" id="MathJax-Span-480" style="font-family: STIXGeneral-Italic;">t<span style="display: inline-block; overflow: hidden; height: 1px; width: 0.003em;"></span></span><span class="mi" id="MathJax-Span-481" style="font-family: STIXGeneral-Italic;">e</span><span class="mi" id="MathJax-Span-482" style="font-family: STIXGeneral-Italic;">r<span style="display: inline-block; overflow: hidden; height: 1px; width: 0.003em;"></span></span><span class="mo" id="MathJax-Span-483" style="font-family: STIXGeneral-Regular;">.</span><span class="mi" id="MathJax-Span-484" style="font-family: STIXGeneral-Italic; padding-left: 0.182em;">c</span><span class="mi" id="MathJax-Span-485" style="font-family: STIXGeneral-Italic;">u</span><span class="mi" id="MathJax-Span-486" style="font-family: STIXGeneral-Italic;">r<span style="display: inline-block; overflow: hidden; height: 1px; width: 0.003em;"></span></span><span class="mi" id="MathJax-Span-487" style="font-family: STIXGeneral-Italic;">r<span style="display: inline-block; overflow: hidden; height: 1px; width: 0.003em;"></span></span><span class="mi" id="MathJax-Span-488" style="font-family: STIXGeneral-Italic;">e</span><span class="mi" id="MathJax-Span-489" style="font-family: STIXGeneral-Italic;">n</span><span class="mi" id="MathJax-Span-490" style="font-family: STIXGeneral-Italic;">t<span style="display: inline-block; overflow: hidden; height: 1px; width: 0.003em;"></span></span><span class="mi" id="MathJax-Span-491" style="font-family: STIXGeneral-Italic;">R</span><span class="mi" id="MathJax-Span-492" style="font-family: STIXGeneral-Italic;">o</span><span class="mi" id="MathJax-Span-493" style="font-family: STIXGeneral-Italic;">u</span><span class="mi" id="MathJax-Span-494" style="font-family: STIXGeneral-Italic;">t<span style="display: inline-block; overflow: hidden; height: 1px; width: 0.003em;"></span></span><span class="mi" id="MathJax-Span-495" style="font-family: STIXGeneral-Italic;">e</span><span class="mo" id="MathJax-Span-496" style="font-family: STIXGeneral-Regular; padding-left: 0.301em;">=<span style="font-family: STIXGeneral-Regular; font-style: normal; font-weight: normal;">=</span><span style="font-family: STIXGeneral-Regular; font-style: normal; font-weight: normal;">=</span></span><span class="mi" id="MathJax-Span-497" style="font-family: STIXGeneral-Italic; padding-left: 0.301em;">t<span style="display: inline-block; overflow: hidden; height: 1px; width: 0.003em;"></span></span><span class="mi" id="MathJax-Span-498" style="font-family: STIXGeneral-Italic;">h</span><span class="mi" id="MathJax-Span-499" style="font-family: STIXGeneral-Italic;">i</span><span class="mi" id="MathJax-Span-500" style="font-family: STIXGeneral-Italic;">s</span><span class="mo" id="MathJax-Span-501" style="font-family: STIXGeneral-Regular;">.</span></span><span style="display: inline-block; width: 0px; height: 2.562em;"></span></span></span><span style="border-left: 0.004em solid; display: inline-block; overflow: hidden; width: 0px; height: 1.004em; vertical-align: -0.068em;"></span></span> 
   </span><script type="math/tex" id="MathJax-Element-27">router.currentRoute === this.</script>route</p> 
</blockquote> 
<h4 id="行为表现">行为表现</h4> 
<p>因为它也是个组件，所以可以配合 <code>&lt;transition&gt;</code> 和 <code>&lt;keep-alive&gt;</code> 使用。如果两个结合一起用，要确保在内层使用 <code>&lt;keep-alive&gt;</code>：</p> 
<pre class="prettyprint"><code class="language-vue hljs xml"><span class="hljs-tag">&lt;<span class="hljs-title">transition</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-title">keep-alive</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-title">router-view</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-title">router-view</span>&gt;</span>
  <span class="hljs-tag">&lt;/<span class="hljs-title">keep-alive</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-title">transition</span>&gt;</span></code></pre> 
<h4 id="router-link">router-link</h4> 
<p><code>&lt;router-link&gt;</code> 比起写死的 <code>&lt;a href="..."&gt;</code> 会好一些，理由如下：</p> 
<ul><li><p>无论是 HTML5 history 模式还是 hash 模式，它的表现行为一致，所以，当你要切换路由模式，或者在 IE9 降级使用 hash 模式，无须作任何变动。</p></li><li><p>在 HTML5 history 模式下，<code>router-link</code> 会守卫点击事件，让浏览器不再重新加载页面。</p></li><li><p>当你在 HTML5 history 模式下使用 <code>base</code> 选项之后，所有的 <code>to</code> 属性都不需要写（基路径）了。</p> <p>base相关说明：「<a href="https://router.vuejs.org/zh-cn/api/options.html#base" rel="nofollow">https://router.vuejs.org/zh-cn/api/options.html#base</a>」</p></li></ul> 
<h3 id="实例">实例</h3> 
<h4 id="header编写">header编写</h4> 
<p><strong>第一步：</strong>获取router的全部配置信息<code>import {ROUTES} from '@/app.router'</code>，然后循环铺值（获取一级的路由）<code>meta.name</code></p> 
<p><strong>第二步：</strong>选择header，路由跳转；主要思路：在一级组件上配置<code>meta.defaultRouteName</code>信息，获取该信息后，进行调整（如果不含有该信息，则默认第一个子路由）</p> 
<p><strong>第三步：</strong>处理当前选中的的header项目</p> 
<pre class="prettyprint"><code class="language-javascript hljs "> watch: {
  <span class="hljs-string">'$route'</span>: {
    <span class="hljs-comment">// 必须，解决路由同步加载组件时，$watch首次不执行的问题</span>
    immediate: <span class="hljs-literal">true</span>,
    handler (to) {
      <span class="hljs-keyword">if</span> (to.matched[<span class="hljs-number">0</span>]) {
        <span class="hljs-keyword">this</span>.currentRoute = to.matched[<span class="hljs-number">0</span>].name
      }
    }
  }
}</code></pre> 
<h4 id="sidebar编写">sidebar编写</h4> 
<p>基本思路和header相似，唯一区别是要根据当前一级路由进行铺值！</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/c6c6c67aa0c34ec869620134b9482830/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">Android TabLayout 设置间距\字体大小的正确姿势</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/a8972f3c8ad4adeff0c0e85872654635/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">【Postgresql】数据库postgresql 10的data目录迁移(不用重新安装)</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>