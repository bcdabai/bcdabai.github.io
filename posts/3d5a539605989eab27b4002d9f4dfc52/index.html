<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Vue用JSEncrypt对长文本json加密以及发现解密失败 - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Vue用JSEncrypt对长文本json加密以及发现解密失败" />
<meta property="og:description" content="哈喽 大家好啊，最近发现进行加密后 超长文本后端解密失败，经过看其他博主修改
JSEncrypt原生代码如下：
// 分段加密，支持中文 JSEncrypt.prototype.encryptUnicodeLong = function (string) { var k = this.getKey(); //根据key所能编码的最大长度来定分段长度。key size - 11：11字节随机padding使每次加密结果都不同。 var maxLength = ((k.n.bitLength()&#43;7)&gt;&gt;3)-11; try { var subStr=&#34;&#34;, encryptedString = &#34;&#34;; var subStart = 0, subEnd=0; var bitLen=0, tmpPoint=0; for(var i = 0, len = string.length; i &lt; len; i&#43;&#43;){ //js 是使用 Unicode 编码的，每个字符所占用的字节数不同 var charCode = string.charCodeAt(i); if(charCode &lt;= 0x007f) { bitLen &#43;= 1; }else if(charCode &lt;= 0x07ff){ bitLen &#43;= 2; }else if(charCode &lt;= 0xffff){ bitLen &#43;= 3; }else{ bitLen &#43;= 4; } //字节数到达上限，获取子字符串加密并追加到总字符串后。更新下一个字符串起始位置及字节计算。 if(bitLen&gt;maxLength){ subStr=string." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/3d5a539605989eab27b4002d9f4dfc52/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-09-12T00:03:57+08:00" />
<meta property="article:modified_time" content="2023-09-12T00:03:57+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Vue用JSEncrypt对长文本json加密以及发现解密失败</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p>哈喽 大家好啊，最近发现进行加密后 超长文本后端解密失败，经过看其他博主修改</p> 
<p>JSEncrypt原生代码如下：</p> 
<p><img alt="" height="52" src="https://images2.imgbox.com/3c/6a/RrkLnyGn_o.png" width="726"></p> 
<p><img alt="" height="193" src="https://images2.imgbox.com/79/f8/vcN24BMx_o.png" width="725"></p> 
<p></p> 
<pre><code class="language-javascript"> // 分段加密，支持中文
     JSEncrypt.prototype.encryptUnicodeLong = function (string) {
         var k = this.getKey();
         //根据key所能编码的最大长度来定分段长度。key size - 11：11字节随机padding使每次加密结果都不同。
         var maxLength = ((k.n.bitLength()+7)&gt;&gt;3)-11;
         try {
             var subStr="", encryptedString = "";
             var subStart = 0, subEnd=0;
             var bitLen=0, tmpPoint=0;
             for(var i = 0, len = string.length; i &lt; len; i++){
                 //js 是使用 Unicode 编码的，每个字符所占用的字节数不同
                 var charCode = string.charCodeAt(i);
                 if(charCode &lt;= 0x007f) {
                     bitLen += 1;
                 }else if(charCode &lt;= 0x07ff){
                     bitLen += 2;
                 }else if(charCode &lt;= 0xffff){
                     bitLen += 3;
                 }else{
                     bitLen += 4;
                 }
                 //字节数到达上限，获取子字符串加密并追加到总字符串后。更新下一个字符串起始位置及字节计算。
                 if(bitLen&gt;maxLength){
                     subStr=string.substring(subStart,subEnd)
                     encryptedString += k.encrypt(subStr);
                     subStart=subEnd;
                     bitLen=bitLen-tmpPoint;
                 }else{
                     subEnd=i;
                     tmpPoint=bitLen;
                 }
             }
             subStr=string.substring(subStart,len)
             encryptedString += k.encrypt(subStr);
             return hex2b64(encryptedString);
         } catch (ex) {
             return false;
         }
     };</code></pre> 
<p>这个源码算法 我还是不是太懂啦 但是目前已经测试成功</p> 
<p>原博主：</p> 
<p><a href="https://blog.csdn.net/lionking1990/article/details/106092990" title="前端RSA加密解密：支持中文 - 基于jsencrypt使用任意长度密钥，对任意长度字符串进行分段加解密_encryptunicodelong_小傻哥的博客-CSDN博客">前端RSA加密解密：支持中文 - 基于jsencrypt使用任意长度密钥，对任意长度字符串进行分段加解密_encryptunicodelong_小傻哥的博客-CSDN博客</a></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/d222cf692f68a32a2ef24abacf1bebfa/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">【网络基础】——HTTPS</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/452e8e81ab786aed48bd856b38b7aaca/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">如何在Excel中创建VBA程序--基于Office 365版本</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>