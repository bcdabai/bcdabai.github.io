<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Hystrix核心篇-滑动窗口基础 - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Hystrix核心篇-滑动窗口基础" />
<meta property="og:description" content="前言 RxJava可能有些小伙伴没有听过是什么东西，可能是因为大家平时在做业务需求的时候对异步编程了解得比较少，而RxJava就是这么一个响应式编程框架，RxJava在安卓上面用得非常多，做安卓的朋友肯定对它很熟悉。那我这里为什么要讲这个呢？因为spring cloud中服务治理框架Hystrix中大量用到了RxJava的响应式编程，为了便于理解，这里也简单给大家介绍一下。这里介绍的版本是RxJava 1.X版本的， 而在去年的早些时候，官方便宣布，将在一段时间后不再对 RxJava 1.x 进行维护，推出了RxJava2.X版本，既然有新的，为什么不介绍新的呢？因为目前最新的Hystrix版本1.5.12中使用的RxJava是1.2版本的，而2.X版本的api改动还是比较大的，所以为了大家能更加简单的理解Hystrix，所以这里是对1.X版本的介绍。
响应式编程是什么 响应式编程是一种基于异步数据流概念的编程模式，有点类似于JAVA里面的lambda表达式，相信大家都很熟悉lambda吧。数据流，stream，大家肯定不陌生，我们可以对stream有很多操作，filter、map、reduce 等常见操作。然后响应式中的核心就是响应二字，响应什么呢？响应的是事件，event 。 而流就是一个按照时间进行排序的事件序列。RxJava里面的事件是基于观察者模式，事件流将从上往下，从订阅源传递到观察者。
RxJava中重要概念 RxJava 有四个基本概念：Observable (可观察者，即被观察者)、 Observer (观察者)、 Subscriber (订阅，是Observer的抽象实现类，本质上使用是一样的)、事件。Observable 和 Observer 通过 subscribe() 方法实现订阅关系，从而 Observable 可以在需要的时候发出事件来通知 Observer。Observable 就像是一个生产者，在不断的生产消息，而Subscriber 和 Observer 就像是一个消费者，在不断的消费消息
另外， RxJava 的事件回调方法还定义了两个特殊的事件，在Hystrix中用得也非常多：onCompleted() 和 onError()。
onCompleted(): 事件队列完结。RxJava 不仅把每个事件单独处理，还会把它们看做一个队列。RxJava 规定，当不会再有新的 onNext() 发出时，需要触发 onCompleted() 方法作为标志。onError(): 事件队列异常。在事件处理过程中出异常时，onError() 会被触发，同时队列自动终止，不允许再有事件发出。 怎么做 说了这么多概念，估计大家都是一头雾水，我们直接来些实际的，加深大家的印象理解。用多的自然而然就会了，就懂了，这里说得可能不是最全的，但是说的都是Hystrix中用得很多的一些操作符，加深大家对Hystrix的理解，看源码就会容易一些。
例子 Observable&lt;String&gt; producer = Observable.create(new Observable.OnSubscribe&lt;String&gt;() { @Override public void call(Subscriber&lt;? super String&gt; subscriber) { subscriber.onNext(&#34;apple&#34;); subscriber.onNext(&#34;orange&#34;); subscriber.onCompleted(); } }); Subscriber&lt;String&gt; consumer = new Subscriber&lt;String&gt;() { @Override public void onNext(String s) { LOG." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/758f7c2706fb9d11c570422f7ccd0acc/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2018-04-27T15:56:55+08:00" />
<meta property="article:modified_time" content="2018-04-27T15:56:55+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Hystrix核心篇-滑动窗口基础</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <h2 id="前言">前言</h2> 
<p>RxJava可能有些小伙伴没有听过是什么东西，可能是因为大家平时在做业务需求的时候对异步编程了解得比较少，而RxJava就是这么一个响应式编程框架，RxJava在安卓上面用得非常多，做安卓的朋友肯定对它很熟悉。那我这里为什么要讲这个呢？因为spring cloud中服务治理框架Hystrix中大量用到了RxJava的响应式编程，为了便于理解，这里也简单给大家介绍一下。这里介绍的版本是RxJava 1.X版本的， 而在去年的早些时候，官方便宣布，将在一段时间后不再对 RxJava 1.x 进行维护，推出了RxJava2.X版本，既然有新的，为什么不介绍新的呢？因为目前最新的Hystrix版本1.5.12中使用的RxJava是1.2版本的，而2.X版本的api改动还是比较大的，所以为了大家能更加简单的理解Hystrix，所以这里是对1.X版本的介绍。</p> 
<h2 id="响应式编程是什么">响应式编程是什么</h2> 
<p><strong>响应式编程</strong>是一种基于异步数据流概念的编程模式，有点类似于JAVA里面的lambda表达式，相信大家都很熟悉lambda吧。数据流，stream，大家肯定不陌生，我们可以对stream有很多操作，filter、map、reduce 等常见操作。然后响应式中的核心就是响应二字，响应什么呢？响应的是事件，event 。 而流就是一个按照时间进行排序的事件序列。RxJava里面的事件是基于观察者模式，事件流将从上往下，从订阅源传递到观察者。</p> 
<h2 id="rxjava中重要概念">RxJava中重要概念</h2> 
<p>RxJava 有四个基本概念：<code>Observable</code> (可观察者，即被观察者)、 <code>Observer</code> (观察者)、 <code>Subscriber</code> (订阅，是<code>Observer</code>的抽象实现类，本质上使用是一样的)、事件。<code>Observable</code> 和 <code>Observer</code> 通过 <code>subscribe()</code> 方法实现订阅关系，从而 <code>Observable</code> 可以在需要的时候发出事件来通知 <code>Observer</code>。<code>Observable</code> 就像是一个生产者，在不断的生产消息，而<code>Subscriber</code> 和 <code>Observer</code> 就像是一个消费者，在不断的消费消息</p> 
<p>另外， RxJava 的事件回调方法还定义了两个特殊的事件，在Hystrix中用得也非常多：<code>onCompleted()</code> 和 <code>onError()</code>。</p> 
<ul><li><code>onCompleted()</code>: 事件队列完结。RxJava 不仅把每个事件单独处理，还会把它们看做一个队列。RxJava 规定，当不会再有新的 <code>onNext()</code> 发出时，需要触发 <code>onCompleted()</code> 方法作为标志。</li><li><code>onError()</code>: 事件队列异常。在事件处理过程中出异常时，<code>onError()</code> 会被触发，同时队列自动终止，不允许再有事件发出。</li></ul> 
<h2 id="怎么做">怎么做</h2> 
<p>说了这么多概念，估计大家都是一头雾水，我们直接来些实际的，加深大家的印象理解。用多的自然而然就会了，就懂了，这里说得可能不是最全的，但是说的都是Hystrix中用得很多的一些操作符，加深大家对Hystrix的理解，看源码就会容易一些。</p> 
<h3 id="例子">例子</h3> 
<pre class="prettyprint"><code class="language-java hljs ">Observable&lt;String&gt; producer = Observable.create(<span class="hljs-keyword">new</span> Observable.OnSubscribe&lt;String&gt;() {
            <span class="hljs-annotation">@Override</span>
            <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">call</span>(Subscriber&lt;? <span class="hljs-keyword">super</span> String&gt; subscriber) {
                subscriber.onNext(<span class="hljs-string">"apple"</span>);
                subscriber.onNext(<span class="hljs-string">"orange"</span>);
                subscriber.onCompleted();
            }
        });
Subscriber&lt;String&gt; consumer = <span class="hljs-keyword">new</span> Subscriber&lt;String&gt;() {
            <span class="hljs-annotation">@Override</span>
            <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onNext</span>(String s) {
                LOG.info(<span class="hljs-string">"我收到的水果有 = {}"</span> , s);
            }
            <span class="hljs-annotation">@Override</span>
            <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onCompleted</span>() {
            }
            <span class="hljs-annotation">@Override</span>
            <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onError</span>(Throwable e) {
            }
        };
producer.subscribe(consumer);</code></pre> 
<p>先来一个简单的例子给大家直观的介绍下<code>Observable</code> 和 <code>Subscriber</code> 做了些什么，<code>Observable</code> 使用了onNext方法生产了2个水果，Apple和orange ，然后调用了onCompleted方法结束了这次生产， 消费者用onnext方法收到了2个水果，所以消费者就将收到的水果打印出来了，没有做任何处理</p> 
<p>执行结果如下：</p> 
<pre class="prettyprint"><code class="language-verilog hljs markdown">2018-04-27 10:21:11.440 INFO  [<span class="hljs-link_label">#</span>][<span class="hljs-link_reference">#</span>] <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-title">main</span>&gt;</span></span> com.dzy.learn.other.NormalTest :我收到的水果有 = apple
2018-04-27 10:21:11.440 INFO  [<span class="hljs-link_label">#</span>][<span class="hljs-link_reference">#</span>] <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-title">main</span>&gt;</span></span> com.dzy.learn.other.NormalTest :我收到的水果有 = orange</code></pre> 
<p>然后再给大家介绍一下Hystrix中用得非常多的操作符</p> 
<h3 id="create">create</h3> 
<pre class="prettyprint"><code class="language-java hljs ">Observable.create(<span class="hljs-keyword">new</span> Observable.OnSubscribe&lt;String&gt;() {
        <span class="hljs-annotation">@Override</span>
        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">call</span>(Subscriber&lt;? <span class="hljs-keyword">super</span> String&gt; subscriber) {
            subscriber.onNext(<span class="hljs-string">"item1"</span>);
            subscriber.onNext(<span class="hljs-string">"item2"</span>);
            subscriber.onCompleted();
        }
});
<span class="hljs-comment">//在上面的例子中已经跟大家讲过了，create就是创建一个Observable，来生产消息</span></code></pre> 
<h3 id="from">from</h3> 
<pre class="prettyprint"><code class="language-java hljs ">List&lt;String&gt; fruitList = Arrays.asList(<span class="hljs-string">"apple"</span>,<span class="hljs-string">"orange"</span>);
        Observable.from(fruitList).subscribe(<span class="hljs-keyword">new</span> Action1&lt;String&gt;() {
            <span class="hljs-annotation">@Override</span>
            <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">call</span>(String fruit) {
                LOG.info(<span class="hljs-string">"fruit = {}"</span> , fruit);
            }
        });</code></pre> 
<p>上面订阅者的代码被我简化了，直接new 一个Action1， 是subscribe支持的一种订阅方式，跟Subscriber是一样的道理，只是更加简化。然后我们再用lambda表达式简化一下就是这样的了</p> 
<pre class="prettyprint"><code class="language-java hljs ">List&lt;String&gt; fruitList = Arrays.asList(<span class="hljs-string">"apple"</span>,<span class="hljs-string">"orange"</span>);
        Observable.from(fruitList).subscribe(fruit -&gt; LOG.info(<span class="hljs-string">"fruit = {}"</span> , fruit));</code></pre> 
<p>执行结果如下：</p> 
<pre class="prettyprint"><code class="language-verilog hljs markdown">2018-04-27 10:30:59.030 INFO  [<span class="hljs-link_label">#</span>][<span class="hljs-link_reference">#</span>] <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-title">main</span>&gt;</span></span> com.dzy.learn.other.NormalTest :fruid = apple
2018-04-27 10:30:59.030 INFO  [<span class="hljs-link_label">#</span>][<span class="hljs-link_reference">#</span>] <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-title">main</span>&gt;</span></span> com.dzy.learn.other.NormalTest :fruid = orange</code></pre> 
<h3 id="defer"><strong>defer</strong></h3> 
<p>只有当订阅者订阅才创建Observable，为每个订阅创建一个新的Observable。内部通过<code>OnSubscribeDefer</code>在订阅时调用Func0创建Observable</p> 
<pre class="prettyprint"><code class="language-java hljs ">List&lt;String&gt; fruitList = Arrays.asList(<span class="hljs-string">"apple"</span>,<span class="hljs-string">"orange"</span>);
        Observable.defer(<span class="hljs-keyword">new</span> Func0&lt;Observable&lt;String&gt;&gt;() {
            <span class="hljs-annotation">@Override</span>
            <span class="hljs-keyword">public</span> Observable&lt;String&gt; <span class="hljs-title">call</span>() {
                <span class="hljs-keyword">return</span> Observable.from(fruitList);
            }
        }).subscribe(<span class="hljs-keyword">new</span> Action1&lt;String&gt;() {
            <span class="hljs-annotation">@Override</span>
            <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">call</span>(String fruit) {
                LOG.info(<span class="hljs-string">"defer fruit = {}"</span> , fruit);
            }
        });</code></pre> 
<p>不知道大家理解了没有，每次生产消息都会生产一个新的消息生产者</p> 
<p>执行结果如下：</p> 
<pre class="prettyprint"><code class="language-verilog hljs markdown">2018-04-27 10:37:26.209 INFO  [<span class="hljs-link_label">#</span>][<span class="hljs-link_reference">#</span>] <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-title">main</span>&gt;</span></span> com.dzy.learn.other.NormalTest :defer fruit = apple
2018-04-27 10:37:26.209 INFO  [<span class="hljs-link_label">#</span>][<span class="hljs-link_reference">#</span>] <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-title">main</span>&gt;</span></span> com.dzy.learn.other.NormalTest :defer fruit = orange</code></pre> 
<h3 id="startwith">startWith</h3> 
<p>在生产的第一个消息前加上一个或者一些消息，看例子比较直观</p> 
<pre class="prettyprint"><code class="language-java hljs "> List&lt;String&gt; fruitList = Arrays.asList(<span class="hljs-string">"apple"</span>,<span class="hljs-string">"orange"</span>);
        Observable.from(fruitList)
                .startWith(<span class="hljs-string">"before apple"</span>,<span class="hljs-string">"before apple2"</span>)
                .subscribe(fruit-&gt;LOG.info(<span class="hljs-string">"fruit = {}"</span> , fruit));</code></pre> 
<p>执行结果如下:</p> 
<pre class="prettyprint"><code class="language-verilog hljs markdown">2018-04-27 10:40:52.221 INFO  [<span class="hljs-link_label">#</span>][<span class="hljs-link_reference">#</span>] <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-title">main</span>&gt;</span></span> com.dzy.learn.other.NormalTest :fruit = before apple
2018-04-27 10:40:52.221 INFO  [<span class="hljs-link_label">#</span>][<span class="hljs-link_reference">#</span>] <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-title">main</span>&gt;</span></span> com.dzy.learn.other.NormalTest :fruit = before apple2
2018-04-27 10:40:52.222 INFO  [<span class="hljs-link_label">#</span>][<span class="hljs-link_reference">#</span>] <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-title">main</span>&gt;</span></span> com.dzy.learn.other.NormalTest :fruit = apple
2018-04-27 10:40:52.222 INFO  [<span class="hljs-link_label">#</span>][<span class="hljs-link_reference">#</span>] <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-title">main</span>&gt;</span></span> com.dzy.learn.other.NormalTest :fruit = orange</code></pre> 
<h3 id="filter">Filter</h3> 
<p>跟lambda里面的filter很像，也是用来筛选数据的，filter接收的Func1第二个参数是Boolean，定死的</p> 
<pre class="prettyprint"><code class="language-java hljs ">List&lt;Integer&gt; list = Arrays.asList(<span class="hljs-number">10</span>, <span class="hljs-number">5</span>, <span class="hljs-number">3</span>, <span class="hljs-number">2</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>);
Observable.from(list)
                .filter(<span class="hljs-keyword">new</span> Func1&lt;Integer, Boolean&gt;() {
                    <span class="hljs-annotation">@Override</span>
                    <span class="hljs-keyword">public</span> Boolean <span class="hljs-title">call</span>(Integer integer) {
                        <span class="hljs-keyword">return</span> integer&gt;<span class="hljs-number">4</span>;
                    }
                })
                .subscribe(num-&gt;LOG.info(<span class="hljs-string">"比4大的num = {}"</span> , num));</code></pre> 
<h3 id="map">Map</h3> 
<p>Map是将需要生产的数据经过Func1进行变换之后，然后在发送给消费者。第二个参数是Object类型的，可以转化成一个Object对象</p> 
<pre class="prettyprint"><code class="language-java hljs ">List&lt;Integer&gt; list = Arrays.asList(<span class="hljs-number">10</span>, <span class="hljs-number">5</span>, <span class="hljs-number">3</span>, <span class="hljs-number">2</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>);
        Observable.from(list)
                .map(<span class="hljs-keyword">new</span> Func1&lt;Integer, Object&gt;() {
                    <span class="hljs-annotation">@Override</span>
                    <span class="hljs-keyword">public</span> Object <span class="hljs-title">call</span>(Integer integer) {
                        <span class="hljs-keyword">return</span> integer+<span class="hljs-string">"变成str"</span>;
                    }
                })
                .subscribe(s -&gt; LOG.info(<span class="hljs-string">"s = {}"</span> , s));</code></pre> 
<p>输出如下：</p> 
<pre class="prettyprint"><code class="language-verilog hljs markdown">2018-04-27 11:08:02.743 INFO  [<span class="hljs-link_label">#</span>][<span class="hljs-link_reference">#</span>] <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-title">main</span>&gt;</span></span> com.dzy.learn.other.NormalTest :s = 10变成str
2018-04-27 11:08:02.747 INFO  [<span class="hljs-link_label">#</span>][<span class="hljs-link_reference">#</span>] <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-title">main</span>&gt;</span></span> com.dzy.learn.other.NormalTest :s = 5变成str
2018-04-27 11:08:02.747 INFO  [<span class="hljs-link_label">#</span>][<span class="hljs-link_reference">#</span>] <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-title">main</span>&gt;</span></span> com.dzy.learn.other.NormalTest :s = 3变成str
2018-04-27 11:08:02.748 INFO  [<span class="hljs-link_label">#</span>][<span class="hljs-link_reference">#</span>] <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-title">main</span>&gt;</span></span> com.dzy.learn.other.NormalTest :s = 2变成str
2018-04-27 11:08:02.748 INFO  [<span class="hljs-link_label">#</span>][<span class="hljs-link_reference">#</span>] <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-title">main</span>&gt;</span></span> com.dzy.learn.other.NormalTest :s = 1变成str
2018-04-27 11:08:02.748 INFO  [<span class="hljs-link_label">#</span>][<span class="hljs-link_reference">#</span>] <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-title">main</span>&gt;</span></span> com.dzy.learn.other.NormalTest :s = 0变成str</code></pre> 
<h3 id="flatmap">FlatMap</h3> 
<p>跟map有些类似，但是也有很大的区别，map是一个对象变成另外一个对象，<strong>而flatMap可以把一个对象转化为多个对象</strong> , 其实FlatMap是将一个对象转成了一个<code>Observable</code> 对象，转完之后，最开始的生产者并不发送这个 <code>Observable</code>, 而是将它激活，于是它开始发送事件，每一个创建出来的 <code>Observable</code> 发送的事件，都被汇入同一个 <code>Observable</code> ，而这个 <code>Observable</code> 负责将这些事件统一交给 <code>Subscriber</code> 的回调方法，这样也就产生了一对多的概念，就像是把对象铺平了一样，flat</p> 
<p>我会跟lambda的flatMap做一个对比，还是很像的</p> 
<pre class="prettyprint"><code class="language-java hljs ">List&lt;Integer&gt; list = Arrays.asList(<span class="hljs-number">10</span>, <span class="hljs-number">5</span>, <span class="hljs-number">3</span>, <span class="hljs-number">2</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>);
List&lt;Object&gt; flatMapcollect = list.stream().flatMap(<span class="hljs-keyword">new</span> Function&lt;Integer, Stream&lt;?&gt;&gt;() {
            <span class="hljs-annotation">@Override</span>
            <span class="hljs-keyword">public</span> Stream&lt;?&gt; <span class="hljs-title">apply</span>(Integer integer) {
                <span class="hljs-comment">//通过list里面的元素创建一个list返回回去</span>
                List&lt;Integer&gt; list1 = Arrays.asList(integer, integer + <span class="hljs-number">10</span>, integer + <span class="hljs-number">100</span>, integer + <span class="hljs-number">1000</span>);
                <span class="hljs-keyword">return</span> list1.stream();
            }
        }).collect(Collectors.toList());
        flatMapcollect.forEach(s-&gt;LOG.info(<span class="hljs-string">"complex integer  = {}"</span> , s));</code></pre> 
<p>打印的结果是一开始的每个元素10 ，5等都被加上了10 100 1000 然后输出了，相当于平铺了</p> 
<pre class="prettyprint"><code class="language-verilog hljs markdown">2018-04-27 11:50:21.186 INFO  [<span class="hljs-link_label">#</span>][<span class="hljs-link_reference">#</span>] <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-title">main</span>&gt;</span></span> com.dzy.learn.other.NormalTest :complex integer  = 10   // 10本来数字
2018-04-27 11:50:21.191 INFO  [<span class="hljs-link_label">#</span>][<span class="hljs-link_reference">#</span>] <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-title">main</span>&gt;</span></span> com.dzy.learn.other.NormalTest :complex integer  = 20   //加上10之后
2018-04-27 11:50:21.191 INFO  [<span class="hljs-link_label">#</span>][<span class="hljs-link_reference">#</span>] <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-title">main</span>&gt;</span></span> com.dzy.learn.other.NormalTest :complex integer  = 110  //加上100之后
2018-04-27 11:50:21.191 INFO  [<span class="hljs-link_label">#</span>][<span class="hljs-link_reference">#</span>] <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-title">main</span>&gt;</span></span> com.dzy.learn.other.NormalTest :complex integer  = 1010  //加上1000之后
2018-04-27 11:50:21.191 INFO  [<span class="hljs-link_label">#</span>][<span class="hljs-link_reference">#</span>] <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-title">main</span>&gt;</span></span> com.dzy.learn.other.NormalTest :complex integer  = 5
2018-04-27 11:50:21.191 INFO  [<span class="hljs-link_label">#</span>][<span class="hljs-link_reference">#</span>] <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-title">main</span>&gt;</span></span> com.dzy.learn.other.NormalTest :complex integer  = 15
2018-04-27 11:50:21.191 INFO  [<span class="hljs-link_label">#</span>][<span class="hljs-link_reference">#</span>] <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-title">main</span>&gt;</span></span> com.dzy.learn.other.NormalTest :complex integer  = 105
2018-04-27 11:50:21.191 INFO  [<span class="hljs-link_label">#</span>][<span class="hljs-link_reference">#</span>] <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-title">main</span>&gt;</span></span> com.dzy.learn.other.NormalTest :complex integer  = 1005
//限于篇幅，后面的略，都是 源数 加上10 100 1000后输出的</code></pre> 
<p>RxJava里面的flatMap， 我乘以10，乘以100然后加下<code>|</code>转成一个String</p> 
<pre class="prettyprint"><code class="language-java hljs ">List&lt;Integer&gt; list = Arrays.asList(<span class="hljs-number">10</span>, <span class="hljs-number">5</span>, <span class="hljs-number">3</span>, <span class="hljs-number">2</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>);

        Observable.from(list).flatMap(<span class="hljs-keyword">new</span> Func1&lt;Integer, Observable&lt;?&gt;&gt;() {
            <span class="hljs-annotation">@Override</span>
            <span class="hljs-keyword">public</span> Observable&lt;?&gt; <span class="hljs-title">call</span>(Integer num) {
                List&lt;String&gt; strings = Arrays.asList(<span class="hljs-string">"|"</span> + num + <span class="hljs-string">"|"</span>, <span class="hljs-string">"|"</span> + num * <span class="hljs-number">10</span> + <span class="hljs-string">"|"</span>, <span class="hljs-string">"|"</span> + num * <span class="hljs-number">100</span> + <span class="hljs-string">"|"</span>);
                <span class="hljs-keyword">return</span> Observable.from(strings);
            }
        }).subscribe(<span class="hljs-keyword">new</span> Action1&lt;Object&gt;() {
            <span class="hljs-annotation">@Override</span>
            <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">call</span>(Object o) {
                LOG.info(<span class="hljs-string">"新转化后的字符串是 = {}"</span> , o);
            }
        });</code></pre> 
<p>输出如下：</p> 
<pre class="prettyprint"><code class="language-verilog hljs markdown">2018-04-27 11:57:13.316 INFO  [<span class="hljs-link_label">#</span>][<span class="hljs-link_reference">#</span>] <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-title">main</span>&gt;</span></span> com.dzy.learn.other.NormalTest :新转化后的字符串是 = |10|
2018-04-27 11:57:13.320 INFO  [<span class="hljs-link_label">#</span>][<span class="hljs-link_reference">#</span>] <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-title">main</span>&gt;</span></span> com.dzy.learn.other.NormalTest :新转化后的字符串是 = |100|
2018-04-27 11:57:13.320 INFO  [<span class="hljs-link_label">#</span>][<span class="hljs-link_reference">#</span>] <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-title">main</span>&gt;</span></span> com.dzy.learn.other.NormalTest :新转化后的字符串是 = |1000|
2018-04-27 11:57:13.320 INFO  [<span class="hljs-link_label">#</span>][<span class="hljs-link_reference">#</span>] <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-title">main</span>&gt;</span></span> com.dzy.learn.other.NormalTest :新转化后的字符串是 = |5|
2018-04-27 11:57:13.320 INFO  [<span class="hljs-link_label">#</span>][<span class="hljs-link_reference">#</span>] <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-title">main</span>&gt;</span></span> com.dzy.learn.other.NormalTest :新转化后的字符串是 = |50|
2018-04-27 11:57:13.320 INFO  [<span class="hljs-link_label">#</span>][<span class="hljs-link_reference">#</span>] <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-title">main</span>&gt;</span></span> com.dzy.learn.other.NormalTest :新转化后的字符串是 = |500|
2018-04-27 11:57:13.320 INFO  [<span class="hljs-link_label">#</span>][<span class="hljs-link_reference">#</span>] <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-title">main</span>&gt;</span></span> com.dzy.learn.other.NormalTest :新转化后的字符串是 = |3|
2018-04-27 11:57:13.321 INFO  [<span class="hljs-link_label">#</span>][<span class="hljs-link_reference">#</span>] <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-title">main</span>&gt;</span></span> com.dzy.learn.other.NormalTest :新转化后的字符串是 = |30|
2018-04-27 11:57:13.321 INFO  [<span class="hljs-link_label">#</span>][<span class="hljs-link_reference">#</span>] <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-title">main</span>&gt;</span></span> com.dzy.learn.other.NormalTest :新转化后的字符串是 = |300|</code></pre> 
<h3 id="reduce">reduce</h3> 
<p>reduce是一个聚合函数，接收上次运算的结果，放在下次的参数中，然后输出最后的结果，结果只输出一次。有点类似于递归。跟scan操作符很像，但是有区别，大家看下scan的输出就知道是什么区别了。</p> 
<p>RxJava里面的reduce</p> 
<pre class="prettyprint"><code class="language-java hljs ">Observable.from(list).reduce(<span class="hljs-keyword">new</span> Func2&lt;Integer, Integer, Integer&gt;() {
                    <span class="hljs-annotation">@Override</span>
                    <span class="hljs-keyword">public</span> Integer <span class="hljs-title">call</span>(Integer result, Integer num) {
                        LOG.info(<span class="hljs-string">"开始前： result {}, num = {}"</span> , result,num);
                        result+=num;
                        <span class="hljs-keyword">return</span> result;
                    }
                }).subscribe(<span class="hljs-keyword">new</span> Action1&lt;Integer&gt;() {
                    <span class="hljs-annotation">@Override</span>
                    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">call</span>(Integer result) {
                        LOG.info(<span class="hljs-string">"result = {}"</span> , result);
                    }
                });</code></pre> 
<p>打印结果如下：</p> 
<pre class="prettyprint"><code class="language-verilog hljs markdown">2018-04-27 13:47:29.237 INFO  [<span class="hljs-link_label">#</span>][<span class="hljs-link_reference">#</span>] <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-title">main</span>&gt;</span></span> com.dzy.learn.other.NormalTest :开始前： result 10, num = 5
2018-04-27 13:47:29.241 INFO  [<span class="hljs-link_label">#</span>][<span class="hljs-link_reference">#</span>] <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-title">main</span>&gt;</span></span> com.dzy.learn.other.NormalTest :开始前： result 15, num = 3
2018-04-27 13:47:29.241 INFO  [<span class="hljs-link_label">#</span>][<span class="hljs-link_reference">#</span>] <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-title">main</span>&gt;</span></span> com.dzy.learn.other.NormalTest :开始前： result 18, num = 2
2018-04-27 13:47:29.241 INFO  [<span class="hljs-link_label">#</span>][<span class="hljs-link_reference">#</span>] <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-title">main</span>&gt;</span></span> com.dzy.learn.other.NormalTest :开始前： result 20, num = 1
2018-04-27 13:47:29.241 INFO  [<span class="hljs-link_label">#</span>][<span class="hljs-link_reference">#</span>] <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-title">main</span>&gt;</span></span> com.dzy.learn.other.NormalTest :开始前： result 21, num = 0
2018-04-27 13:47:29.241 INFO  [<span class="hljs-link_label">#</span>][<span class="hljs-link_reference">#</span>] <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-title">main</span>&gt;</span></span> com.dzy.learn.other.NormalTest :result = 21</code></pre> 
<p>lambda里面的reduce</p> 
<pre class="prettyprint"><code class="language-java hljs ">List&lt;Integer&gt; list = Arrays.asList(<span class="hljs-number">10</span>, <span class="hljs-number">5</span>, <span class="hljs-number">3</span>, <span class="hljs-number">2</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>);

        Integer sum = list.stream().reduce((result, sum1) -&gt; {
            result += sum1;
            <span class="hljs-keyword">return</span> result;
        }).get();
        LOG.info(<span class="hljs-string">"sum = {}"</span> , sum);
<span class="hljs-comment">//sum是21，就是累加起来</span></code></pre> 
<h3 id="scan">scan</h3> 
<p>scan和reduce都是把上一次操作的结果做为第二次的参数传递给第二次Observable使用，但是scan每次操作之后先把数据输出，然后在调用scan的回调函数进行第二次操作，看例子</p> 
<pre class="prettyprint"><code class="language-java hljs ">Observable.from(list)
                .scan(<span class="hljs-keyword">new</span> Func2&lt;Integer, Integer, Integer&gt;() {
                    <span class="hljs-annotation">@Override</span>
                    <span class="hljs-keyword">public</span> Integer <span class="hljs-title">call</span>(Integer result, Integer num) {
                        LOG.info(<span class="hljs-string">"开始前： result {}, num = {}"</span> , result,num);
                        result+=num;
                        <span class="hljs-keyword">return</span> result;
                    }
                }).subscribe(<span class="hljs-keyword">new</span> Action1&lt;Integer&gt;() {
                    <span class="hljs-annotation">@Override</span>
                    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">call</span>(Integer result) {
                        LOG.info(<span class="hljs-string">"result = {}"</span> , result);
                    }
                });</code></pre> 
<pre class="prettyprint"><code class="language-verilog hljs markdown">2018-04-27 13:47:29.245 INFO  [<span class="hljs-link_label">#</span>][<span class="hljs-link_reference">#</span>] <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-title">main</span>&gt;</span></span> com.dzy.learn.other.NormalTest :result = 10
2018-04-27 13:47:29.245 INFO  [<span class="hljs-link_label">#</span>][<span class="hljs-link_reference">#</span>] <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-title">main</span>&gt;</span></span> com.dzy.learn.other.NormalTest :开始前： result 10, num = 5
2018-04-27 13:47:29.245 INFO  [<span class="hljs-link_label">#</span>][<span class="hljs-link_reference">#</span>] <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-title">main</span>&gt;</span></span> com.dzy.learn.other.NormalTest :result = 15
2018-04-27 13:47:29.245 INFO  [<span class="hljs-link_label">#</span>][<span class="hljs-link_reference">#</span>] <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-title">main</span>&gt;</span></span> com.dzy.learn.other.NormalTest :开始前： result 15, num = 3
2018-04-27 13:47:29.245 INFO  [<span class="hljs-link_label">#</span>][<span class="hljs-link_reference">#</span>] <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-title">main</span>&gt;</span></span> com.dzy.learn.other.NormalTest :result = 18
2018-04-27 13:47:29.245 INFO  [<span class="hljs-link_label">#</span>][<span class="hljs-link_reference">#</span>] <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-title">main</span>&gt;</span></span> com.dzy.learn.other.NormalTest :开始前： result 18, num = 2
2018-04-27 13:47:29.245 INFO  [<span class="hljs-link_label">#</span>][<span class="hljs-link_reference">#</span>] <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-title">main</span>&gt;</span></span> com.dzy.learn.other.NormalTest :result = 20
2018-04-27 13:47:29.245 INFO  [<span class="hljs-link_label">#</span>][<span class="hljs-link_reference">#</span>] <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-title">main</span>&gt;</span></span> com.dzy.learn.other.NormalTest :开始前： result 20, num = 1
2018-04-27 13:47:29.245 INFO  [<span class="hljs-link_label">#</span>][<span class="hljs-link_reference">#</span>] <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-title">main</span>&gt;</span></span> com.dzy.learn.other.NormalTest :result = 21
2018-04-27 13:47:29.245 INFO  [<span class="hljs-link_label">#</span>][<span class="hljs-link_reference">#</span>] <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-title">main</span>&gt;</span></span> com.dzy.learn.other.NormalTest :开始前： result 21, num = 0
2018-04-27 13:47:29.245 INFO  [<span class="hljs-link_label">#</span>][<span class="hljs-link_reference">#</span>] <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-title">main</span>&gt;</span></span> com.dzy.learn.other.NormalTest :result = 21</code></pre> 
<p>每次运算后都会调用订阅者</p> 
<h3 id="window">window</h3> 
<p>Hystrix 滑动窗口的核心用的就是window操作符，那么window有什么作用呢？他能将Observable的数据分拆成一些Observable窗口，然后把Observable窗口推送给订阅者，而不是一个数据，是一个Observable。来点例子更加直白</p> 
<h4 id="windowint-count-int-skip">window(int count, int skip)</h4> 
<pre class="prettyprint"><code class="language-java hljs ">List&lt;Integer&gt; list = Arrays.asList(<span class="hljs-number">10</span>, <span class="hljs-number">5</span>, <span class="hljs-number">3</span>, <span class="hljs-number">2</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>);
        Observable.from(list).window(<span class="hljs-number">2</span>, <span class="hljs-number">2</span>).subscribe(<span class="hljs-keyword">new</span> Action1&lt;Observable&lt;Integer&gt;&gt;() {
            <span class="hljs-annotation">@Override</span>
            <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">call</span>(Observable&lt;Integer&gt; integerObservable) {
                integerObservable.reduce((sum, num) -&gt; sum+=num).subscribe(<span class="hljs-keyword">new</span> Action1&lt;Integer&gt;() {
                    <span class="hljs-annotation">@Override</span>
                    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">call</span>(Integer integer) {
                        LOG.info(<span class="hljs-string">"我被2个打印一次 = {}"</span> , integer);
                    }
                });
            }
        });</code></pre> 
<p>window里面有2个参数，第一个参数2 表示 选取2个事件，比如说10,5 5,3 等，第二个参数是skip，表示跳跃2个事件，来选取，所以是3组窗口，里面是 （10,5）（3,2）（1,0）</p> 
<p>输出：</p> 
<pre class="prettyprint"><code class="language-verilog hljs markdown">2018-04-27 14:06:08.703 INFO  [<span class="hljs-link_label">#</span>][<span class="hljs-link_reference">#</span>] <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-title">main</span>&gt;</span></span> com.dzy.learn.other.NormalTest :我被2个打印一次 = 15
2018-04-27 14:06:08.707 INFO  [<span class="hljs-link_label">#</span>][<span class="hljs-link_reference">#</span>] <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-title">main</span>&gt;</span></span> com.dzy.learn.other.NormalTest :我被2个打印一次 = 5
2018-04-27 14:06:08.707 INFO  [<span class="hljs-link_label">#</span>][<span class="hljs-link_reference">#</span>] <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-title">main</span>&gt;</span></span> com.dzy.learn.other.NormalTest :我被2个打印一次 = 1</code></pre> 
<h4 id="windowlong-timespan-timeunit-unit">window(long timespan, TimeUnit unit)</h4> 
<pre class="prettyprint"><code class="language-java hljs ">CountDownLatch countDownLatch = <span class="hljs-keyword">new</span> CountDownLatch(<span class="hljs-number">1</span>);
        Observable inputEventStream = Observable.create(<span class="hljs-keyword">new</span> Observable.OnSubscribe&lt;Object&gt;() {
            <span class="hljs-annotation">@Override</span>
            <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">call</span>(Subscriber&lt;? <span class="hljs-keyword">super</span> Object&gt; subscriber) {
                subscriber.onNext(<span class="hljs-string">"我是生产者........."</span>);
            }
        });
        inputEventStream.window(<span class="hljs-number">1000</span>,TimeUnit.MILLISECONDS).subscribe(<span class="hljs-keyword">new</span> Action1() {
            <span class="hljs-annotation">@Override</span>
            <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">call</span>(Object o) {
                Calendar calendar = Calendar.getInstance();
                <span class="hljs-keyword">int</span> i = calendar.get(Calendar.SECOND);
                LOG.info(<span class="hljs-string">"我会{}就被唤醒触发..."</span>,i);
            }
        });
        countDownLatch.await();</code></pre> 
<p>输出：</p> 
<pre class="prettyprint"><code class="language-verilog hljs markdown">2018-04-27 14:26:18.721 INFO  [<span class="hljs-link_label">#</span>][<span class="hljs-link_reference">#</span>] <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-title">RxComputationScheduler-1</span>&gt;</span></span> com.dzy.learn.other.NormalTest :我会18就被唤醒触发...
2018-04-27 14:26:19.722 INFO  [<span class="hljs-link_label">#</span>][<span class="hljs-link_reference">#</span>] <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-title">RxComputationScheduler-1</span>&gt;</span></span> com.dzy.learn.other.NormalTest :我会19就被唤醒触发...
2018-04-27 14:26:20.721 INFO  [<span class="hljs-link_label">#</span>][<span class="hljs-link_reference">#</span>] <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-title">RxComputationScheduler-1</span>&gt;</span></span> com.dzy.learn.other.NormalTest :我会20就被唤醒触发...
2018-04-27 14:26:21.721 INFO  [<span class="hljs-link_label">#</span>][<span class="hljs-link_reference">#</span>] <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-title">RxComputationScheduler-1</span>&gt;</span></span> com.dzy.learn.other.NormalTest :我会21就被唤醒触发...
2018-04-27 14:26:22.722 INFO  [<span class="hljs-link_label">#</span>][<span class="hljs-link_reference">#</span>] <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-title">RxComputationScheduler-1</span>&gt;</span></span> com.dzy.learn.other.NormalTest :我会22就被唤醒触发...
2018-04-27 14:26:23.721 INFO  [<span class="hljs-link_label">#</span>][<span class="hljs-link_reference">#</span>] <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-title">RxComputationScheduler-1</span>&gt;</span></span> com.dzy.learn.other.NormalTest :我会23就被唤醒触发...
2018-04-27 14:26:24.721 INFO  [<span class="hljs-link_label">#</span>][<span class="hljs-link_reference">#</span>] <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-title">RxComputationScheduler-1</span>&gt;</span></span> com.dzy.learn.other.NormalTest :我会24就被唤醒触发...
2018-04-27 14:26:25.721 INFO  [<span class="hljs-link_label">#</span>][<span class="hljs-link_reference">#</span>] <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-title">RxComputationScheduler-1</span>&gt;</span></span> com.dzy.learn.other.NormalTest :我会25就被唤醒触发...
.....
...
..</code></pre> 
<p>这里用CountDownLatch 阻塞了主线程的关闭，如果不用锁，那么主线程关闭了之后，你就看不到定时输出了。</p> 
<p>第二个demo，用到了window另外的一个函数，第一个参数是缓存在这个window的间隔时间，第二个参数是时间单位 , 1s内收到的所有的生产消息都会缓存到window里面，然后统一发出给订阅者。就好像一个时间轴上面，有个窗子在收集数据，1s钟之后收集好了之后，就发送出去，然后到了第二个窗子，这就是Hystrix滑动窗口的精髓所在。</p> 
<h2 id="学以致用">学以致用</h2> 
<pre class="prettyprint"><code class="language-java hljs "><span class="hljs-javadoc">/**
     * 两个数字相加，reduce，scan用
     */</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Func2&lt;Integer, Integer, Integer&gt; PUBLIC_SUM =
            (integer, integer2) -&gt; integer + integer2;

    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Func1&lt;Observable&lt;Integer&gt;, Observable&lt;Integer&gt;&gt; WINDOW_SUM =
            <span class="hljs-comment">//跳过第一个数据，因为给了scan一个默认值0，这个值需要跳过，如果不设置就不需要跳过</span>
            window -&gt; window.scan(<span class="hljs-number">0</span>, PUBLIC_SUM).skip(<span class="hljs-number">1</span>);

    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Func1&lt;Observable&lt;Integer&gt;, Observable&lt;Integer&gt;&gt; INNER_BUCKET_SUM =
            integerObservable -&gt; integerObservable.reduce(<span class="hljs-number">0</span>, PUBLIC_SUM);

    <span class="hljs-annotation">@Test</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">testWindowSlide</span>() <span class="hljs-keyword">throws</span> InterruptedException {
        CountDownLatch countDownLatch = <span class="hljs-keyword">new</span> CountDownLatch(<span class="hljs-number">1</span>);
        BehaviorSubject&lt;Integer&gt; behaviorSubject = BehaviorSubject.create();
        behaviorSubject
                <span class="hljs-comment">// 1秒作为一个基本块,横向移动</span>
                .window(<span class="hljs-number">1000</span>, TimeUnit.MILLISECONDS)
                <span class="hljs-comment">//将flatMap汇总平铺成一个事件,然后累加成一个Observable&lt;Integer&gt;对象，比如说1s内有10个对象，被累加起来</span>
                .flatMap(INNER_BUCKET_SUM)
                <span class="hljs-comment">//对这个对象2个发送，步长为1</span>
                .window(<span class="hljs-number">2</span>,<span class="hljs-number">1</span>)
                <span class="hljs-comment">//对窗口里面的进行求和,用的scan, 每次累加都会打印出来</span>
                .flatMap(WINDOW_SUM)
                .subscribe((Integer integer) -&gt;
                        <span class="hljs-comment">// 输出统计数据到日志</span>
                        LOG.info(<span class="hljs-string">"[{}] call ...... {}"</span>,
                                Thread.currentThread().getName(), integer));

        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">1000</span>; i++) {
            <span class="hljs-comment">//200ms生产一个数据，</span>
            behaviorSubject.onNext(i);
            LOG.info(<span class="hljs-string">"i = {}"</span> ,i);
            Thread.sleep(<span class="hljs-number">200</span>);
        }
        countDownLatch.await();
    }</code></pre> 
<p>输出：</p> 
<pre class="prettyprint"><code class="language-verilog hljs markdown">2018-04-27 15:46:06.547 INFO  [<span class="hljs-link_label">#</span>][<span class="hljs-link_reference">#</span>] <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-title">main</span>&gt;</span></span> com.dzy.learn.other.NormalTest :i = 0
2018-04-27 15:46:06.756 INFO  [<span class="hljs-link_label">#</span>][<span class="hljs-link_reference">#</span>] <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-title">main</span>&gt;</span></span> com.dzy.learn.other.NormalTest :i = 1
2018-04-27 15:46:07.010 INFO  [<span class="hljs-link_label">#</span>][<span class="hljs-link_reference">#</span>] <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-title">main</span>&gt;</span></span> com.dzy.learn.other.NormalTest :i = 2
2018-04-27 15:46:07.211 INFO  [<span class="hljs-link_label">#</span>][<span class="hljs-link_reference">#</span>] <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-title">main</span>&gt;</span></span> com.dzy.learn.other.NormalTest :i = 3
2018-04-27 15:46:07.411 INFO  [<span class="hljs-link_label">#</span>][<span class="hljs-link_reference">#</span>] <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-title">main</span>&gt;</span></span> com.dzy.learn.other.NormalTest :i = 4
2018-04-27 15:46:07.517 INFO  [<span class="hljs-link_label">#</span>][<span class="hljs-link_reference">#</span>] <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-title">RxComputationScheduler-1</span>&gt;</span></span> com.dzy.learn.other.NormalTest :[RxComputationScheduler-1] call ...... 10
2018-04-27 15:46:07.517 INFO  [<span class="hljs-link_label">#</span>][<span class="hljs-link_reference">#</span>] <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-title">RxComputationScheduler-1</span>&gt;</span></span> com.dzy.learn.other.NormalTest :[RxComputationScheduler-1] call ...... 10
2018-04-27 15:46:07.611 INFO  [<span class="hljs-link_label">#</span>][<span class="hljs-link_reference">#</span>] <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-title">main</span>&gt;</span></span> com.dzy.learn.other.NormalTest :i = 5
2018-04-27 15:46:07.811 INFO  [<span class="hljs-link_label">#</span>][<span class="hljs-link_reference">#</span>] <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-title">main</span>&gt;</span></span> com.dzy.learn.other.NormalTest :i = 6
2018-04-27 15:46:08.011 INFO  [<span class="hljs-link_label">#</span>][<span class="hljs-link_reference">#</span>] <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-title">main</span>&gt;</span></span> com.dzy.learn.other.NormalTest :i = 7
2018-04-27 15:46:08.211 INFO  [<span class="hljs-link_label">#</span>][<span class="hljs-link_reference">#</span>] <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-title">main</span>&gt;</span></span> com.dzy.learn.other.NormalTest :i = 8
2018-04-27 15:46:08.411 INFO  [<span class="hljs-link_label">#</span>][<span class="hljs-link_reference">#</span>] <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-title">main</span>&gt;</span></span> com.dzy.learn.other.NormalTest :i = 9
2018-04-27 15:46:08.517 INFO  [<span class="hljs-link_label">#</span>][<span class="hljs-link_reference">#</span>] <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-title">RxComputationScheduler-1</span>&gt;</span></span> com.dzy.learn.other.NormalTest :[RxComputationScheduler-1] call ...... 45
2018-04-27 15:46:08.517 INFO  [<span class="hljs-link_label">#</span>][<span class="hljs-link_reference">#</span>] <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-title">RxComputationScheduler-1</span>&gt;</span></span> com.dzy.learn.other.NormalTest :[RxComputationScheduler-1] call ...... 35
2018-04-27 15:46:08.611 INFO  [<span class="hljs-link_label">#</span>][<span class="hljs-link_reference">#</span>] <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-title">main</span>&gt;</span></span> com.dzy.learn.other.NormalTest :i = 10
2018-04-27 15:46:08.811 INFO  [<span class="hljs-link_label">#</span>][<span class="hljs-link_reference">#</span>] <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-title">main</span>&gt;</span></span> com.dzy.learn.other.NormalTest :i = 11
2018-04-27 15:46:09.011 INFO  [<span class="hljs-link_label">#</span>][<span class="hljs-link_reference">#</span>] <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-title">main</span>&gt;</span></span> com.dzy.learn.other.NormalTest :i = 12
2018-04-27 15:46:09.211 INFO  [<span class="hljs-link_label">#</span>][<span class="hljs-link_reference">#</span>] <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-title">main</span>&gt;</span></span> com.dzy.learn.other.NormalTest :i = 13
2018-04-27 15:46:09.411 INFO  [<span class="hljs-link_label">#</span>][<span class="hljs-link_reference">#</span>] <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-title">main</span>&gt;</span></span> com.dzy.learn.other.NormalTest :i = 14
2018-04-27 15:46:09.517 INFO  [<span class="hljs-link_label">#</span>][<span class="hljs-link_reference">#</span>] <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-title">RxComputationScheduler-1</span>&gt;</span></span> com.dzy.learn.other.NormalTest :[RxComputationScheduler-1] call ...... 95
2018-04-27 15:46:09.517 INFO  [<span class="hljs-link_label">#</span>][<span class="hljs-link_reference">#</span>] <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-title">RxComputationScheduler-1</span>&gt;</span></span> com.dzy.learn.other.NormalTest :[RxComputationScheduler-1] call ...... 60</code></pre> 
<p>解析，第一个window产生了一个滑动窗口，每秒钟就会把生产者生产的消息累加起来，第二个window是积累2个对象，然后进行发送，每次跳一个数字，第二个window是建立在第一个windows累加之后的基础上的，可能有点难理解，我们来看第一个window产生的序列如下：</p> 
<pre class="prettyprint"><code class="language-java hljs "><span class="hljs-number">0</span>  <span class="hljs-number">10</span>  <span class="hljs-number">35</span>  <span class="hljs-number">60</span>  <span class="hljs-number">85</span>  ......</code></pre> 
<p>有的同学可能会问，你怎么知道，我看的log日志，打印出来的序列是 10 10 、 45 35 、95 60 、 145 85 、因为这里用的scan，每次累加之后都会把源数打印一遍，所以是0 10 35 60 85 。第二个window就在这个基础上进行累加 0+10 10+35 35+60 60+85，这样就完成了一个滑动窗口的监控过程</p> 
<h2 id="结语">结语</h2> 
<p>这里总结的也许不是最全的，也许不是最新的版本，但是是Hystrix中用到的，结合Hystrix进行针对性讲解，对Hystrix的理解更加深刻，如有错误，望加以斧正，谢谢。</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/45b9634a63aa1d724fe2bd51cf1cd60b/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">【Redis】获取没有设置ttl的key脚本</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/8586a5657f5ccfa52713072bd2ae411e/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">servlet2接收servlet1通过form提交的post请求数据,结果获取的数据中文乱码,使用req.setCharacterEncoding(&#34;UTF-8&#34;);不管用</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>