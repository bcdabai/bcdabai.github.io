<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>依葫芦画瓢-Kotlin --003.基本语法 - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="依葫芦画瓢-Kotlin --003.基本语法" />
<meta property="og:description" content="文章目录 1、基本类型1.1 数字1.1.1 字面常量1.1.2 显式转换 1.2 字符串 2 变量与常量2.1 常量2.2 属性包装 3 函数3.1 函数声明单表达式返回值类型函数类型函数参数3.2 闭包3.3 lambda 表达式 1、基本类型 kotlin 的基本类型主要包括：
数字字符布尔数组
看起来与Java差不多，但是有一个根本的区别，kotlin 中的基本类型也都是面向对象的，而Java中的基本类型还区分包装类型和原始类型。 1.1 数字 Kotlin 对数字的处理与Java类似，但也有很大差异。 然而对于数字类型， Kotlin 却不兼容 Java 中的类型 例如，你不能这样在 Kotlin中声明和初始化一个 Java 中的整型类型：
var a : Integer= Intege r(3)
同样，在 Kotlin 中，不能声明 Java 中其他的基本数字类型，例如：
var b : Long = Long ()
之所以会这样，是因为 Kotlin 有自己的一套基本类型，并且有重名的类，例如Kotlin 的长整型类型为 Long ，这与 Java 的长整型类型名称相同。
kotlin 一共提供了6种类型
Double、Float、Long、Int、Short、Byte
var c=&#39;a&#39; var a = c as Int val b = 1 1." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/95a9a73fe0c45018f7aed97d5b6d54cf/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-07-30T16:12:10+08:00" />
<meta property="article:modified_time" content="2023-07-30T16:12:10+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">依葫芦画瓢-Kotlin --003.基本语法</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-light">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p></p> 
<div class="toc"> 
 <h4>文章目录</h4> 
 <ul><li><a href="#1_5" rel="nofollow">1、基本类型</a></li><li><ul><li><a href="#11__13" rel="nofollow">1.1 数字</a></li><li><ul><li><a href="#111__27" rel="nofollow">1.1.1 字面常量</a></li><li><a href="#112__38" rel="nofollow">1.1.2 显式转换</a></li></ul> 
   </li><li><a href="#12__51" rel="nofollow">1.2 字符串</a></li></ul> 
  </li><li><a href="#2___61" rel="nofollow">2 变量与常量</a></li><li><ul><li><a href="#21__62" rel="nofollow">2.1 常量</a></li><li><a href="#22__75" rel="nofollow">2.2 属性包装</a></li></ul> 
  </li><li><a href="#3__79" rel="nofollow">3 函数</a></li><li><ul><li><a href="#31__80" rel="nofollow">3.1 函数声明</a></li><li><ul><li><a href="#_89" rel="nofollow">单表达式</a></li><li><a href="#_97" rel="nofollow">返回值类型</a></li><li><a href="#_100" rel="nofollow">函数类型</a></li><li><a href="#_133" rel="nofollow">函数参数</a></li><li><a href="#32__160" rel="nofollow">3.2 闭包</a></li><li><a href="#33__lambda__178" rel="nofollow">3.3 lambda 表达式</a></li><li><a href="#_185" rel="nofollow"></a></li></ul> 
  </li></ul> 
 </li></ul> 
</div> 
<p></p> 
<hr> 
<h2><a id="1_5"></a>1、基本类型</h2> 
<p>kotlin 的基本类型主要包括：</p> 
<ul><li>数字</li><li>字符</li><li>布尔</li><li>数组<br> 看起来与Java差不多，但是有一个根本的区别，kotlin 中的基本类型也都是面向对象的，而Java中的基本类型还区分包装类型和原始类型。</li></ul> 
<h3><a id="11__13"></a>1.1 数字</h3> 
<p>Kotlin 对数字的处理与Java类似，但也有很大差异。 然而对于数字类型， Kotlin 却不兼容 Java 中的类型 例如，你不能这样在 Kotlin中声明和初始化一个 Java 中的整型类型：<br> var a : Integer= Intege r(3)<br> 同样，在 Kotlin 中，不能声明 Java 中其他的基本数字类型，例如：<br> var b : Long = Long ()<br> 之所以会这样，是因为 Kotlin 有自己的一套基本类型，并且有重名的类，例如Kotlin 的长整型类型为 Long ，这与 Java 的长整型类型名称相同。<br> kotlin 一共提供了6种类型<br> Double、Float、Long、Int、Short、Byte</p> 
<pre><code class="prism language-c">var c<span class="token operator">=</span><span class="token char">'a'</span>
var a <span class="token operator">=</span> c as Int
val b <span class="token operator">=</span> <span class="token number">1</span>
</code></pre> 
<h4><a id="111__27"></a>1.1.1 字面常量</h4> 
<p>字面常量就是直接在源程序中写一个数字，编译器在进行编译时，会识别的这种数字符号。<br> kotlin 所支持的数字标识符包括以下几种：</p> 
<ul><li>普通十进制 不需要添加任何标识符，如val a=123</li><li>Long 类型 用L标识 如：12L</li><li>十六进制 用0X 开头 如val d=0x0BAF</li><li>二进制 用0b开头 val c=0b1011001010</li><li>浮点类型 默认double 如 12.34、34.567</li><li>Float类型 用 f 或 F 标记 12.13f</li></ul> 
<h4><a id="112__38"></a>1.1.2 显式转换</h4> 
<p>每一种数字类型都支持以下方法：<br> • toByte(): Byte<br> • toShort(): Short<br> • tolnt(): Int<br> • toLong(): Long<br> • toFloat(): Float<br> • toDouble(): Double<br> • toChar(): Char<br> 有了这些接口，你可以进行任意两种数字类型之间的转换 例如可以这样：<br> var a:Int = 3<br> va r b:Long = a.toLong()</p> 
<h3><a id="12__51"></a>1.2 字符串</h3> 
<p>Ko ti In 中的字符串使用 String 类型表示，不过这种类型也是 Kotlin 内置的类型，并不是 Java 中的字符串类型。<br> 与Java 中的字符串一样， Koti in 的字符串也是不可变的一一不能被继承，值不能被修改。因此在对字符串执行拼接操作时需要考虑性能问题Kotlin 中，关于字符串有一个很贴心的功能，那就是模板表达式。</p> 
<pre><code class="prism language-c">va l i <span class="token operator">=</span> <span class="token number">3</span> 
val s <span class="token operator">=</span> <span class="token string">" i = $i"</span>
val ss <span class="token operator">=</span> <span class="token string">" i ＝$｛ i + 5 )"</span>
<span class="token function">println</span> <span class="token punctuation">(</span>” $s” <span class="token punctuation">)</span>
</code></pre> 
<h2><a id="2___61"></a>2 变量与常量</h2> 
<h3><a id="21__62"></a>2.1 常量</h3> 
<p>所谓常<br> 就是其值不能在运行期被修改的变量 Kotlin 中声明 个常量很简单，使用 val<br> 键字 可，如下所示</p> 
<pre><code class="prism language-c">val a <span class="token operator">:</span> Int <span class="token operator">=</span> <span class="token number">3</span>
</code></pre> 
<p>并非加了val 关键字的变更才会被认为是常量，还有一类隐式的常量，那就是函数的入参。</p> 
<pre><code>   fun add(a: Int) {
        val b =a+3
    }
</code></pre> 
<h3><a id="22__75"></a>2.2 属性包装</h3> 
<p>kotlin 相比 Java 的一个重大改进就是属性的自动封装。</p> 
<h2><a id="3__79"></a>3 函数</h2> 
<h3><a id="31__80"></a>3.1 函数声明</h3> 
<p>kotlin 函数声明使用fun 关键字声明</p> 
<pre><code class="prism language-c">  fun <span class="token function">add</span><span class="token punctuation">(</span>a<span class="token operator">:</span> Int<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        val b <span class="token operator">=</span>a<span class="token operator">+</span><span class="token number">3</span>
    <span class="token punctuation">}</span>
</code></pre> 
<p>如果kotlin 函数没有返回值，则可不声明返回值，不需要像Java 那样使用void关键字。</p> 
<h4><a id="_89"></a>单表达式</h4> 
<pre><code>    fun aaa(a: Int, b: Int): Int = a + b
</code></pre> 
<p>还可以</p> 
<pre><code>    fun aaa(a: Int, b: Int) = a + b
</code></pre> 
<h4><a id="_97"></a>返回值类型</h4> 
<p>与其它语言一样，允许函数没有返回值，其类型是 kotlin.Unit</p> 
<h4><a id="_100"></a>函数类型</h4> 
<p>函数类型非常丰富，大致有以下</p> 
<ul><li>顶级函数<br> 就是直接声明在源程序文件中的函数，而不是被封装有类型内部。</li></ul> 
<pre><code>class Anima{
   override fun toString() ="anima"
}
// 顶级函数与类型声明平级
fun eat(anima: Anima){
   println("animal eat")
}
</code></pre> 
<ul><li>类成员函数<br> 声明在类型内部的函数</li></ul> 
<pre><code>class Anima{
    override fun toString() ="anima"
        ...
    //类成员函数
    fun eat(anima: Anima){
        println("animal eat")
    }
    ....
}
</code></pre> 
<ul><li>对象函数<br> 声明在对象中的函数</li><li>本地函数<br> 本地函数是一种类型特殊的函数，这类函数声明在其它函数内部。</li></ul> 
<h4><a id="_133"></a>函数参数</h4> 
<pre><code>fun main(args: Array&lt;String&gt;) {
    println("Hello word")

    val d = 0x0BAF
    val c = 0b1011001010

    /*
        fun add(a: Int) {
            val b =a+3
        }
        */
......
        // 也可以是包含多个参数，其中一个是不定长参数
fun add(a: Int, vararg t : Int) {
    println("t.size=${t.size}")
    if (t.size &gt; 0) {
        var sum: Int = 0
        for (num in t) {
            sum = sum + num
            println("sum= ${sum}")
        }
    }
}

</code></pre> 
<h4><a id="32__160"></a>3.2 闭包</h4> 
<p>就是局部函数，局部函数也可以读取其它函数内部的数据。</p> 
<pre><code>class  Closure{
    var count = 0
    fun foo() {
        var a = 1
        //闭包        
        fun local() {
            a++
            count++
            //局部函数访问外部宿主资源
            println("a=${a},count=${count}")
        }
    }
}
</code></pre> 
<h4><a id="33__lambda__178"></a>3.3 lambda 表达式</h4> 
<p>就是匿名函数<br> 匿名函数主要用在下面两种地方：</p> 
<ol><li>函数入参</li><li>函数返回值</li></ol> 
<h4><a id="_185"></a></h4> 
<ul><li>函数类型</li></ul> 
<p>使用格式如下：</p> 
<pre><code>var variable:(argType[,...]) -&gt; returnType
</code></pre> 
<p>声明一个Int 类型的变更</p> 
<pre><code>var int : Int
</code></pre> 
<p>将这两种对比，本质上是一样的，唯一不同是变量类型。<br> 再如</p> 
<pre><code>var addFun : (Int,Int) -&gt; Int
</code></pre> 
<pre><code>fun add(a:Int,b:Int):Int{
return a+b
}
</code></pre> 
<ul><li>函数实例化与lambda表达式<br> 普通变量直接调用构造函数便能完成实例化，而函数类型则需要借助于lambda表达式才能完成实例化。</li></ul> 
<pre><code>var  addFun: (Int,Int) -&gt; Int = { a, b -&gt; a + b }
</code></pre> 
<ul><li>函数类型返回<br> 函数类型实例化的函数体内部，不能使用return 关键字进行返回。</li><li>函数类型赋值与调用<br> 函数类型并不是唯一的，入参不同，返回值类型不同，则函数类型便有差别。</li><li>函数类型传递与高阶函数<br> 既然函数类型变量具有普通变量的属性，自然也可以作为参数传递给其他函数能够接受函数类型的变量作为人参，或者返回一个函数类型的函数，专业上称之为“高阶函数”。<br> 可以当作函数进行调用，在调用这种类型的变量时，只需在变量名后面添加括号，并传递对应的实参。<br> 下面这种文法定义了 个接受函数类型作为入参的高阶函数：</li></ul> 
<pre><code>fun advanceFun(a: Int, funcType: (Int, Int) -&gt; Int) { 
funcType(a, 86) 
</code></pre> 
<p>这里声明的 advanceFun（）函数，其第 个人参 funcType 便是 个函数类型 ，其函数类型表明这是一个包含两个 Int 型入参、返回 Int 类型的函数.<br> 下面这种文法定义了一个返回函数类型的高阶函数：</p> 
<pre><code>fun advanceFun(a : Int): (Int, Int) -&gt; Int{ 
return { 
a, b -&gt; 
a + b 
}
}
</code></pre> 
<pre><code>fun main(args: Array&lt;String&gt;) {
    /*声明高阶函数*/
    fun advanceFun(a : Int,funcType : (Int,Int) -&gt; Int){
        funcType(a,3)
    }

    /*声明一个函数变量*/
    var  funcType:(Int,Int) -&gt;Int ={
            a,b -&gt;
        a+b
    }
    /*调用高阶函数*/
    advanceFun(98, funcType)
}
</code></pre> 
<ul><li> <p>高阶函数简写形式<br> 高阶函数不仅声明文法稍显复杂，毕竟突破了大家习以为常的形式，而且在调<br> 时即时 明和使用函数类型变量的文法也会使程序看起来复杂度骤然大增（ 主要是<br> lambda 表达式的结构比较复杂） 为了简化， lambda 文法规定：<br> <em>如果一个高阶函数的最 个人参是函数类型，则在调用该高阶函数时，可以该入参从人参列表中移到入参列表外面，并使用花括号括起来。</em><br> <em>如果高阶函数仅包含 个人参，并且这个人参就是高阶函数类型， 那么使用简化调用形式之后，其入参列表可以为空。</em></p> </li><li> <p>it<br> 当一个函数类型只包含一个入参时，高阶函数可以简化成“it”关键字。</p> </li><li> <p>闭包的连续调用<br> 闭包实现的前提是函数必须返回一个函数类型的结果值，也就是高阶函数。而返回的函数类型的变量，可以是高阶函数内部的局部函数。</p> </li><li> <p>内联函数<br> 就是将函数体直接移到调用者函数内部来执行。</p> </li></ul>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/f8d0c86b993d155adbdda381740548c7/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">matlab遗传算法工具箱</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/9527b03f519354224375ffcc15c1d496/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">Redis的数据淘汰策略</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>