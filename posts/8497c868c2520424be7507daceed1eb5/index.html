<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>吴恩达机器学习（八）—— 机器学习系统的设计 - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="吴恩达机器学习（八）—— 机器学习系统的设计" />
<meta property="og:description" content="机器学习系统的设计 1. 优先处理的工作：垃圾邮件分类例子2. 误差分析3. 偏斜类的误差度量4. 查准率和查全率之间的权衡5. 机器学习的数据 1. 优先处理的工作：垃圾邮件分类例子 在实际的工作过程中，我们应该明白哪些事情要优先处理，接下来我们以一个垃圾邮件分类器算法为例子进行讨论。
为了解决这样一个问题，我们首先要做的决定是如何选择并表达特征向量 x x x。我们可以选择一个由100个最常出现在垃圾邮件中的词所构成的列表，根据这些词是否在邮件中出现来获得我们的特征向量（出现为1，不出现为0），尺寸为100×1。
如何在有限的时间内让我们的垃圾分类器具有高精准度和低错误率？
1. 收集更多的数据，让我们有更多的垃圾邮件和非垃圾邮件样本；
2. 通过邮件的标题来构建一个基于邮件的路由信息的更为复杂的特征，来捕捉到邮件信息的来源并以此来判断邮件是否垃圾邮件；
3. 对邮件的主体部分构建更为复杂的特征（例如，单词“discount”和“discounts”是否应该被视为同一单词，或者是否应该把“deal”和“dealer”视为同一个单词，在这个例子中也可以关注单词首字母的大小写或者通过标点符号来构建复杂的特征）；
4. 为了检测故意出现的拼写错误构建更复杂的算法，例如，“m0rtgage”、“med1cine”、“w4tches”。
在上面这些选项中，我们通常很难决定应该在哪一项上花费时间和精力，但作出明智的选择比随着感觉走要更好。
2. 误差分析 如果我们准备研究机器学习的东西，或者构造机器学习应用程序，构建一个学习算法的推荐方法为：
1. 通过一个简单的算法来快速实现它，而不是设计一个很复杂的系统，即使这个速成的东西不是很完美，然后使用交叉验证集来测试数据；
2. 通过画出相应的学习曲线以及检验误差来找出我们的算法是否有高偏差和高方差的问题或者别的问题，在做出这些分析之后，再来决定是否使用更多的数据训练或者加入更多的特征变量等等。
3. 误差分析：实现比如一个垃圾邮件分类器的时候，人工观察交叉验证集的情况，看一看哪些邮件被算法错误的分类。通过查看这些被错误分类的垃圾邮件和非垃圾邮件，找出经常被错误分类的邮件的共同特征和规律。
总结：
面对实际的机器学习问题，首先要快速选择一个模型并实现它。然后在模型的基础上根据学习曲线和检验误差去优化模型，提高模型泛化能力。最后深入了解和考虑出现问题导致误差的实际原因，提出、验证和改进学习模型。 3. 偏斜类的误差度量 设定某个实数来评价我们的学习算法并衡量它的表现，有了算法的评估和误差度量值后，要注意的是使用一个合适的误差度量值有时会对于我们的学习算法造成非常微妙的影响，这就是偏斜类的问题。
在癌症分类例子中，我们训练Logistic回归模型（ y = 1 y=1 y=1为癌症， y = 0 y=0 y=0为其他），假设使用测试集来检验这个分类模型，发现它只有1%的错误，因此我们99%会做出正确的诊断，这看起来是一个不错的结果。但假设我们发现在测试集中只有0.5%的患者真正患了癌症，那么1%的错误率就不显得那么好了。
function predictCancer(x): return y=0; 上述代码忽略了 x x x，让 y y y总是等于0，因此它总是预测没有人得癌症，这个算法只有0.5%的错误率，甚至比我们之前的得到的1%的错误率更好。这是一个非机器学习的算法，只是预测 y y y总是等于0，这种情况发生在训练集中有非常多的同一种类的样本且只有很少或没有其他类的样本，把这种情况称为偏斜类。
偏斜类：一个类中的样本数与另一个类的样本数相比多很多，通过总是预测 y = 0 y=0 y=0或 y = 1 y=1 y=1，算法可能表现得非常好，因此使用分类误差或者分类精确度来作为评估度量会产生问题。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/8497c868c2520424be7507daceed1eb5/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2021-07-03T19:47:39+08:00" />
<meta property="article:modified_time" content="2021-07-03T19:47:39+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">吴恩达机器学习（八）—— 机器学习系统的设计</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p></p> 
<div class="toc"> 
 <h4>机器学习系统的设计</h4> 
 <ul><li><a href="#1__2" rel="nofollow">1. 优先处理的工作：垃圾邮件分类例子</a></li><li><a href="#2__16" rel="nofollow">2. 误差分析</a></li><li><a href="#3__28" rel="nofollow">3. 偏斜类的误差度量</a></li><li><a href="#4__57" rel="nofollow">4. 查准率和查全率之间的权衡</a></li><li><a href="#5__65" rel="nofollow">5. 机器学习的数据</a></li></ul> 
</div> 
<p></p> 
<h2><a id="1__2"></a>1. 优先处理的工作：垃圾邮件分类例子</h2> 
<p>  在实际的工作过程中，我们应该明白哪些事情要优先处理，接下来我们以一个垃圾邮件分类器算法为例子进行讨论。<br>   为了解决这样一个问题，我们首先要做的决定是如何选择并表达特征向量<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         x 
        
       
      
        x 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.43056em; vertical-align: 0em;"></span><span class="mord mathdefault">x</span></span></span></span></span>。我们可以选择一个由100个最常出现在垃圾邮件中的词所构成的列表，根据这些词是否在邮件中出现来获得我们的特征向量（出现为1，不出现为0），尺寸为100×1。</p> 
<p>  <strong>如何在有限的时间内让我们的垃圾分类器具有高精准度和低错误率？</strong><br>   1. 收集更多的数据，让我们有更多的垃圾邮件和非垃圾邮件样本；<br>   2. 通过邮件的标题来构建一个基于邮件的路由信息的更为复杂的特征，来捕捉到邮件信息的来源并以此来判断邮件是否垃圾邮件；<br>   3. 对邮件的主体部分构建更为复杂的特征（例如，单词“discount”和“discounts”是否应该被视为同一单词，或者是否应该把“deal”和“dealer”视为同一个单词，在这个例子中也可以关注单词首字母的大小写或者通过标点符号来构建复杂的特征）；<br>   4. 为了检测故意出现的拼写错误构建更复杂的算法，例如，“m0rtgage”、“med1cine”、“w4tches”。<br>   在上面这些选项中，我们通常很难决定应该在哪一项上花费时间和精力，但作出明智的选择比随着感觉走要更好。</p> 
<h2><a id="2__16"></a>2. 误差分析</h2> 
<p>  如果我们准备研究机器学习的东西，或者构造机器学习应用程序，构建一个学习算法的推荐方法为：<br>   1. 通过一个简单的算法来快速实现它，而不是设计一个很复杂的系统，即使这个速成的东西不是很完美，然后使用交叉验证集来测试数据；<br>   2. 通过画出相应的学习曲线以及检验误差来找出我们的算法是否有高偏差和高方差的问题或者别的问题，在做出这些分析之后，再来决定是否使用更多的数据训练或者加入更多的特征变量等等。<br>   3. 误差分析：实现比如一个垃圾邮件分类器的时候，人工观察交叉验证集的情况，看一看哪些邮件被算法错误的分类。通过查看这些被错误分类的垃圾邮件和非垃圾邮件，找出经常被错误分类的邮件的共同特征和规律。</p> 
<p><strong>总结</strong>：</p> 
<ul><li>面对实际的机器学习问题，首先要快速选择一个模型并实现它。</li><li>然后在模型的基础上根据学习曲线和检验误差去优化模型，提高模型泛化能力。</li><li>最后深入了解和考虑出现问题导致误差的实际原因，提出、验证和改进学习模型。</li></ul> 
<h2><a id="3__28"></a>3. 偏斜类的误差度量</h2> 
<p>  设定某个实数来评价我们的学习算法并衡量它的表现，有了算法的评估和误差度量值后，要注意的是使用一个合适的误差度量值有时会对于我们的学习算法造成非常微妙的影响，这就是偏斜类的问题。<br>   在癌症分类例子中，我们训练Logistic回归模型（<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         y 
        
       
         = 
        
       
         1 
        
       
      
        y=1 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.625em; vertical-align: -0.19444em;"></span><span class="mord mathdefault" style="margin-right: 0.03588em;">y</span><span class="mspace" style="margin-right: 0.277778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right: 0.277778em;"></span></span><span class="base"><span class="strut" style="height: 0.64444em; vertical-align: 0em;"></span><span class="mord">1</span></span></span></span></span>为癌症，<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         y 
        
       
         = 
        
       
         0 
        
       
      
        y=0 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.625em; vertical-align: -0.19444em;"></span><span class="mord mathdefault" style="margin-right: 0.03588em;">y</span><span class="mspace" style="margin-right: 0.277778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right: 0.277778em;"></span></span><span class="base"><span class="strut" style="height: 0.64444em; vertical-align: 0em;"></span><span class="mord">0</span></span></span></span></span>为其他），假设使用测试集来检验这个分类模型，发现它只有1%的错误，因此我们99%会做出正确的诊断，这看起来是一个不错的结果。但假设我们发现在测试集中只有0.5%的患者真正患了癌症，那么1%的错误率就不显得那么好了。</p> 
<pre><code>function predictCancer(x):
   return y=0;
</code></pre> 
<p>  上述代码忽略了<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         x 
        
       
      
        x 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.43056em; vertical-align: 0em;"></span><span class="mord mathdefault">x</span></span></span></span></span>，让<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         y 
        
       
      
        y 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.625em; vertical-align: -0.19444em;"></span><span class="mord mathdefault" style="margin-right: 0.03588em;">y</span></span></span></span></span>总是等于0，因此它总是预测没有人得癌症，这个算法只有0.5%的错误率，甚至比我们之前的得到的1%的错误率更好。这是一个非机器学习的算法，只是预测 <span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         y 
        
       
      
        y 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.625em; vertical-align: -0.19444em;"></span><span class="mord mathdefault" style="margin-right: 0.03588em;">y</span></span></span></span></span>总是等于0，这种情况发生在训练集中有非常多的同一种类的样本且只有很少或没有其他类的样本，把这种情况称为<strong>偏斜类</strong>。</p> 
<p>  偏斜类：一个类中的样本数与另一个类的样本数相比多很多，通过总是预测<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         y 
        
       
         = 
        
       
         0 
        
       
      
        y=0 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.625em; vertical-align: -0.19444em;"></span><span class="mord mathdefault" style="margin-right: 0.03588em;">y</span><span class="mspace" style="margin-right: 0.277778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right: 0.277778em;"></span></span><span class="base"><span class="strut" style="height: 0.64444em; vertical-align: 0em;"></span><span class="mord">0</span></span></span></span></span>或<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         y 
        
       
         = 
        
       
         1 
        
       
      
        y=1 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.625em; vertical-align: -0.19444em;"></span><span class="mord mathdefault" style="margin-right: 0.03588em;">y</span><span class="mspace" style="margin-right: 0.277778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right: 0.277778em;"></span></span><span class="base"><span class="strut" style="height: 0.64444em; vertical-align: 0em;"></span><span class="mord">1</span></span></span></span></span>，算法可能表现得非常好，因此使用分类误差或者分类精确度来作为评估度量会产生问题。<br>   如果我们有一个偏斜类，用分类精度并不能很好的衡量算法。因为我们可能会获得一个很高的精确度、非常低的错误率，但是我们并不知道我们是否真的提升了分类模型的质量。就像总是预测<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         y 
        
       
         = 
        
       
         0 
        
       
      
        y=0 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.625em; vertical-align: -0.19444em;"></span><span class="mord mathdefault" style="margin-right: 0.03588em;">y</span><span class="mspace" style="margin-right: 0.277778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right: 0.277778em;"></span></span><span class="base"><span class="strut" style="height: 0.64444em; vertical-align: 0em;"></span><span class="mord">0</span></span></span></span></span>并不是一个好的分类模型，但是会将我们的误差降低至更低水平。所以当我们遇到偏斜类问题时，希望有一个不同的误差度量值或不同的评估度量值，例如查准率(Precision)和查全率(Recalll)。</p> 
<p>  据算法的预测结果和实际结果出现的不同情况， 我们分成以下四种：<br>   1. <strong>真阳性（True Positive,TP）</strong>：预测为真，实际为真；<br>   2. <strong>真阴性（True Negative,TN）</strong>：预测为假，实际为假 ；<br>   3. <strong>假阳性（False Positive ,FP）</strong>：预测为真，实际为假 ；<br>   4. <strong>假阴性（False Negative,FN）</strong>：预测为假，实际为真。</p> 
<p><img src="https://images2.imgbox.com/66/1f/Q3mKcQ7T_o.png" alt="在这里插入图片描述"></p> 
<p>  <strong>查准率</strong>：真正预测准确的数量 / 预测是准确的数量。公式为：查准率(Precision)=<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
        
         
         
           T 
          
         
           P 
          
         
         
         
           T 
          
         
           P 
          
         
           + 
          
         
           F 
          
         
           P 
          
         
        
       
      
        \frac{TP}{TP+FP} 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 1.27566em; vertical-align: -0.403331em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.872331em;"><span class="" style="top: -2.655em;"><span class="pstrut" style="height: 3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right: 0.13889em;">T</span><span class="mord mathdefault mtight" style="margin-right: 0.13889em;">P</span><span class="mbin mtight">+</span><span class="mord mathdefault mtight" style="margin-right: 0.13889em;">F</span><span class="mord mathdefault mtight" style="margin-right: 0.13889em;">P</span></span></span></span><span class="" style="top: -3.23em;"><span class="pstrut" style="height: 3em;"></span><span class="frac-line" style="border-bottom-width: 0.04em;"></span></span><span class="" style="top: -3.394em;"><span class="pstrut" style="height: 3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right: 0.13889em;">T</span><span class="mord mathdefault mtight" style="margin-right: 0.13889em;">P</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.403331em;"><span class=""></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></span>。<br>   <strong>查全率</strong>：真正预测准确的数量 / 所有真正准确的数量。公式为：查全率(Recall)=<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
        
         
         
           T 
          
         
           P 
          
         
         
         
           T 
          
         
           P 
          
         
           + 
          
         
           F 
          
         
           N 
          
         
        
       
      
        \frac{TP}{TP+FN} 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 1.27566em; vertical-align: -0.403331em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.872331em;"><span class="" style="top: -2.655em;"><span class="pstrut" style="height: 3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right: 0.13889em;">T</span><span class="mord mathdefault mtight" style="margin-right: 0.13889em;">P</span><span class="mbin mtight">+</span><span class="mord mathdefault mtight" style="margin-right: 0.13889em;">F</span><span class="mord mathdefault mtight" style="margin-right: 0.10903em;">N</span></span></span></span><span class="" style="top: -3.23em;"><span class="pstrut" style="height: 3em;"></span><span class="frac-line" style="border-bottom-width: 0.04em;"></span></span><span class="" style="top: -3.394em;"><span class="pstrut" style="height: 3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right: 0.13889em;">T</span><span class="mord mathdefault mtight" style="margin-right: 0.13889em;">P</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.403331em;"><span class=""></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></span>。</p> 
<p>  通过计算查准率和查全率，我们能更好的知道分类模型到底好不好。如果有一个算法总是预测<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         y 
        
       
         = 
        
       
         0 
        
       
      
        y=0 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.625em; vertical-align: -0.19444em;"></span><span class="mord mathdefault" style="margin-right: 0.03588em;">y</span><span class="mspace" style="margin-right: 0.277778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right: 0.277778em;"></span></span><span class="base"><span class="strut" style="height: 0.64444em; vertical-align: 0em;"></span><span class="mord">0</span></span></span></span></span>，即总是预测没有人患癌症，那么这个分类模型的查全率为0，所以它不是一个好的分类模型。<mark>高查准率和高查全率才可以表示一个模型是好模型</mark>。</p> 
<h2><a id="4__57"></a>4. 查准率和查全率之间的权衡</h2> 
<p>  查准率和查全率是一对矛盾的指标，一般说，当查准率高的时候，查全率一般很低；查全率高时，查准率一般很低。<br>   比如在西瓜书中的经典例子：若我们希望选出的西瓜中好瓜尽可能多，即查准率高，则只挑选最优把握的西瓜，算法挑选出来的西瓜（TP+FP）会减少，相对挑选出的西瓜确实是好瓜（TP）也相应减少，但是分母（TP+FP）减少的更快，所以查准率变大；在查全率公式中，分母（所有好瓜的总数）是不会变的，分子（TP）在减小，所以查全率变小。</p> 
<p>  因此，我们希望有一个帮助我们选择阈值的方法——计算F1值（F1 Score），其计算公式为：<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         F 
        
       
         1 
        
        
        
            
         
         
        
        
        
            
         
         
        
       
         S 
        
       
         c 
        
       
         o 
        
       
         r 
        
       
         e 
        
       
         = 
        
       
         2 
        
        
         
         
           P 
          
         
           R 
          
         
         
         
           P 
          
         
           + 
          
         
           R 
          
         
        
       
      
        F1\ _{} \ _{}Score=2\frac{PR}{P+R} 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.83333em; vertical-align: -0.15em;"></span><span class="mord mathdefault" style="margin-right: 0.13889em;">F</span><span class="mord">1</span><span class="mord"><span class="mspace"> </span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist"><span class="" style="top: -1.85em; margin-right: 0.05em;"><span class="pstrut" style="height: 2em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.15em;"><span class=""></span></span></span></span></span></span><span class="mord"><span class="mspace"> </span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist"><span class="" style="top: -1.85em; margin-right: 0.05em;"><span class="pstrut" style="height: 2em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.15em;"><span class=""></span></span></span></span></span></span><span class="mord mathdefault" style="margin-right: 0.05764em;">S</span><span class="mord mathdefault">c</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right: 0.02778em;">r</span><span class="mord mathdefault">e</span><span class="mspace" style="margin-right: 0.277778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right: 0.277778em;"></span></span><span class="base"><span class="strut" style="height: 1.27566em; vertical-align: -0.403331em;"></span><span class="mord">2</span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.872331em;"><span class="" style="top: -2.655em;"><span class="pstrut" style="height: 3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right: 0.13889em;">P</span><span class="mbin mtight">+</span><span class="mord mathdefault mtight" style="margin-right: 0.00773em;">R</span></span></span></span><span class="" style="top: -3.23em;"><span class="pstrut" style="height: 3em;"></span><span class="frac-line" style="border-bottom-width: 0.04em;"></span></span><span class="" style="top: -3.394em;"><span class="pstrut" style="height: 3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right: 0.13889em;">P</span><span class="mord mathdefault mtight" style="margin-right: 0.00773em;">R</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.403331em;"><span class=""></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></span> 。其中，P为查准率，R为查全率。<br>   F1值会考虑一部分查准率和查全率的平均值，但是它会给查准率和查全率中较低的值更高的权重，它结合了查准率和查全率，并且在实际应用中，F1值越高代表模型拟合效果越好 。</p> 
<h2><a id="5__65"></a>5. 机器学习的数据</h2> 
<p>  事实证明，在一定条件下，得到大量的数据并在某种类型的学习算法中进行训练可以是一种有效的方法来获得一个具有良好性能的学习算法，而这种情况往往出现在这些条件对于我们的问题都成立并且我们能够得到大量数据的情况下。</p> 
<p>  看一个通过机器学习算法来区分常见的易混淆的单词的例子，比如这样的句子：For breakfast I ate __ eggs(to,two,too)，这是一个易混淆的单词的例子。研究员把诸如此类的机器学习问题当做一类监督学习问题，并尝试将其分类，什么样的词在一个英文句子特定的位置才是合适的。<br>   他们用了几种不同的学习算法，一种是感知器(perceptron)，用于逻辑回归上的一个方差；一种是 Winnow算法，类似于回归问题；一种是基于内存的学习算法(Memory-based)；还有一种是朴素贝叶斯算法(Naive Bayes)。这些具体算法的细节并不那么重要，他们所做的就是改变了训练数据集的大小，并尝试将这些学习算法用于不同大小的训练数据集中，得到的结果如图2所示。</p> 
<p><img src="https://images2.imgbox.com/19/c9/cnut2V5w_o.png" alt="在这里插入图片描述"></p> 
<center>
  图2 不同算法随数据量变化的性能曲线图 
</center> 
<br> 
<p>  从图2可以看出，在尝试了许多种不同的算法后发现数据量非常大时，这些不同类型的算法效果都很好。这些趋势非常明显，首先大部分算法都具有相似的性能，其次随着训练数据集的增大，这些算法的性能也都对应地增强了。 事实上，如果我们选择任意一个算法，可能是选择了一个"劣等的"算法，但如果给这个劣等算法更多的数据，那么它可能看上去会比其他算法好，甚至会比"优等算法"更好。<br>   因此这给我们提出了一些可能的条件，如果你有大量的数据，而且你训练了一种带有很多参数的学习算法，那么这将会是一个很好的方式，来提供一个高性能的学习算法。</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/a746825bcf615e760050f192d23a9236/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">Game101现代计算机图形学作业1</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/83d31aa0209abed888deca52042c55eb/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">2021-07-03</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>