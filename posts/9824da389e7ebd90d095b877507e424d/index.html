<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>一文彻底解密Spring 源码之Spring MVC - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="一文彻底解密Spring 源码之Spring MVC" />
<meta property="og:description" content="小白都能看懂的 Spring 源码揭秘之Spring MVC 前言Spring MVC 请求流程Spring MVC 两大阶段初始化HttpServletBean#init()FrameworkServlet#initServletBeanFrameworkServlet#initWebApplicationContextDispatchServlet#onRefreshSpring MVC 九大组件MultipartResolverLocaleResolverThemeResolverHandlerMappingHandlerAdapterHandlerExceptionResolverRequestToViewNameTranslatorViewResolverFlashMapManager 处理请求DispatcherServlet#doDispatchDispatcherServlet#getHandlerAbstractHandlerMapping#getHandlerAbstractHandlerMethodMapping#getHandlerInternalAbstractHandlerMethodMapping#lookupHandlerMethodAbstractHandlerMethodMapping 的初始化AbstractHandlerMethodMapping#initHandlerMethodsAbstractHandlerMethodMapping#detectHandlerMethodsAbstractHandlerMethodMapping#register 总结 前言 对于 Web 应用程序而言，我们从浏览器发起一个请求，请求经过一系列的分发和处理，最终会进入到我们指定的方法之中，这一系列的的具体流程到底是怎么样的呢？
Spring MVC 请求流程 记得在初入职场的时候，面试前经常会背一背 Spring MVC 流程，印象最深的就是一个请求最先会经过 DispatcherServlet 进行分发处理，DispatcherServlet 就是我们 Spring MVC 的入口类，下面就是一个请求的大致流转流程（图片参考自 Spring In Action）：
一个请求过来之后会到达 DispatcherServlet，但是 DispatcherServlet 也并不知道这个请求要去哪里。DispatcherServlet 收到请求之后会去查询处理器映射（HandlerMapping），从而根据浏览器发送过来的 URL 解析出请求最终应该调用哪个控制器。到达对应控制器（Controller）之后，会完成一些逻辑处理，而且在处理完成之后会生成一些返回信息，也就是 Model，然后还需要选择对应的视图名。将模型（Model）和视图（View）传递给对应的视图解析器（View Resolver），视图解析器会将模型和视图进行结合。模型和视图结合之后就会得到一个完整的视图，最终将视图返回前端。 上面就是一个传统的完整的 Spring MVC 流程，为什么要说这是传统的流程呢？因为这个流程是用于前后端没有分离的时候，后台直接返回页面给浏览器进行渲染，而现在大部分应用都是前后端分离，后台直接生成一个 Json 字符串就直接返回前端，不需要经过视图解析器进行处理，也就是说前后端分离之后，流程就简化成了 1-2-3-4-7（其中第四步返回的一般是 Json 格式数据）。
Spring MVC 两大阶段 Spring MVC主要可以分为两大过程，一是初始化，二就是处理请求。初始化的过程主要就是将我们定义好的 RequestMapping 映射路径和 Controller 中的方法进行一一映射存储，这样当收到请求之后就可以处理请求调用对应的方法，从而响应请求。
初始化 初始化过程的入口方法是 DispatchServlet 的 init() 方法，而实际上 DispatchServlet 中并没有这个方法，所以我们就继续寻找父类，会发现 init 方法在其父类（FrameworkServlet）的父类 HttpServletBean 中。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/9824da389e7ebd90d095b877507e424d/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-03-27T17:25:26+08:00" />
<meta property="article:modified_time" content="2022-03-27T17:25:26+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">一文彻底解密Spring 源码之Spring MVC</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p></p> 
<div class="toc"> 
 <h4>小白都能看懂的 Spring 源码揭秘之Spring MVC</h4> 
 <ul><li><a href="#_1" rel="nofollow">前言</a></li><li><a href="#Spring_MVC__5" rel="nofollow">Spring MVC 请求流程</a></li><li><ul><li><a href="#Spring_MVC__19" rel="nofollow">Spring MVC 两大阶段</a></li><li><ul><li><a href="#_23" rel="nofollow">初始化</a></li><li><ul><li><a href="#HttpServletBeaninit_27" rel="nofollow">HttpServletBean#init()</a></li><li><a href="#FrameworkServletinitServletBean_33" rel="nofollow">FrameworkServlet#initServletBean</a></li><li><a href="#FrameworkServletinitWebApplicationContext_38" rel="nofollow">FrameworkServlet#initWebApplicationContext</a></li><li><a href="#DispatchServletonRefresh_44" rel="nofollow">DispatchServlet#onRefresh</a></li><li><a href="#Spring_MVC__49" rel="nofollow">Spring MVC 九大组件</a></li><li><ul><li><a href="#MultipartResolver_51" rel="nofollow">MultipartResolver</a></li><li><a href="#LocaleResolver_55" rel="nofollow">LocaleResolver</a></li><li><a href="#ThemeResolver_59" rel="nofollow">ThemeResolver</a></li><li><a href="#HandlerMapping_63" rel="nofollow">HandlerMapping</a></li><li><a href="#HandlerAdapter_67" rel="nofollow">HandlerAdapter</a></li><li><a href="#HandlerExceptionResolver_71" rel="nofollow">HandlerExceptionResolver</a></li><li><a href="#RequestToViewNameTranslator_75" rel="nofollow">RequestToViewNameTranslator</a></li><li><a href="#ViewResolver_79" rel="nofollow">ViewResolver</a></li><li><a href="#FlashMapManager_83" rel="nofollow">FlashMapManager</a></li></ul> 
    </li></ul> 
    </li><li><a href="#_89" rel="nofollow">处理请求</a></li><li><ul><li><a href="#DispatcherServletdoDispatch_93" rel="nofollow">DispatcherServlet#doDispatch</a></li><li><a href="#DispatcherServletgetHandler_98" rel="nofollow">DispatcherServlet#getHandler</a></li><li><a href="#AbstractHandlerMappinggetHandler_102" rel="nofollow">AbstractHandlerMapping#getHandler</a></li><li><a href="#AbstractHandlerMethodMappinggetHandlerInternal_123" rel="nofollow">AbstractHandlerMethodMapping#getHandlerInternal</a></li><li><a href="#AbstractHandlerMethodMappinglookupHandlerMethod_127" rel="nofollow">AbstractHandlerMethodMapping#lookupHandlerMethod</a></li><li><a href="#AbstractHandlerMethodMapping__138" rel="nofollow">AbstractHandlerMethodMapping 的初始化</a></li><li><a href="#AbstractHandlerMethodMappinginitHandlerMethods_142" rel="nofollow">AbstractHandlerMethodMapping#initHandlerMethods</a></li><li><a href="#AbstractHandlerMethodMappingdetectHandlerMethods_147" rel="nofollow">AbstractHandlerMethodMapping#detectHandlerMethods</a></li><li><a href="#AbstractHandlerMethodMappingregister_152" rel="nofollow">AbstractHandlerMethodMapping#register</a></li></ul> 
   </li></ul> 
  </li></ul> 
  </li><li><a href="#_158" rel="nofollow">总结</a></li></ul> 
</div> 
<p></p> 
<h2><a id="_1"></a>前言</h2> 
<p>对于 <code>Web</code> 应用程序而言，我们从浏览器发起一个请求，请求经过一系列的分发和处理，最终会进入到我们指定的方法之中，这一系列的的具体流程到底是怎么样的呢？</p> 
<h2><a id="Spring_MVC__5"></a>Spring MVC 请求流程</h2> 
<p>记得在初入职场的时候，面试前经常会背一背 <code>Spring MVC</code> 流程，印象最深的就是一个请求最先会经过 <code>DispatcherServlet</code> 进行分发处理，<code>DispatcherServlet</code> 就是我们 <code>Spring MVC</code> 的入口类，下面就是一个请求的大致流转流程（图片参考自 <code>Spring In Action</code>）：</p> 
<p><img src="https://images2.imgbox.com/60/52/nwgGXgNW_o.png" alt="在这里插入图片描述"></p> 
<ol><li>一个请求过来之后会到达 <code>DispatcherServlet</code>，但是 <code>DispatcherServlet</code> 也并不知道这个请求要去哪里。</li><li><code>DispatcherServlet</code> 收到请求之后会去查询处理器映射（HandlerMapping），从而根据浏览器发送过来的 <code>URL</code> 解析出请求最终应该调用哪个控制器。</li><li>到达对应控制器（Controller）之后，会完成一些逻辑处理，而且在处理完成之后会生成一些返回信息，也就是 <code>Model</code>，然后还需要选择对应的视图名。</li><li>将模型（<code>Model</code>）和视图（<code>View</code>）传递给对应的视图解析器（View Resolver），视图解析器会将模型和视图进行结合。</li><li>模型和视图结合之后就会得到一个完整的视图，最终将视图返回前端。</li></ol> 
<p>上面就是一个传统的完整的 <code>Spring MVC</code> 流程，为什么要说这是传统的流程呢？因为这个流程是用于前后端没有分离的时候，后台直接返回页面给浏览器进行渲染，而现在大部分应用都是前后端分离，后台直接生成一个 <code>Json</code> 字符串就直接返回前端，不需要经过视图解析器进行处理，也就是说前后端分离之后，流程就简化成了 <code>1-2-3-4-7</code>（其中第四步返回的一般是 Json 格式数据）。</p> 
<h3><a id="Spring_MVC__19"></a>Spring MVC 两大阶段</h3> 
<p>Spring MVC主要可以分为两大过程，一是初始化，二就是处理请求。初始化的过程主要就是将我们定义好的 <code>RequestMapping</code> 映射路径和 <code>Controller</code> 中的方法进行一一映射存储，这样当收到请求之后就可以处理请求调用对应的方法，从而响应请求。</p> 
<h4><a id="_23"></a>初始化</h4> 
<p>初始化过程的入口方法是 <code>DispatchServlet</code> 的 <code>init()</code> 方法，而实际上 <code>DispatchServlet</code> 中并没有这个方法，所以我们就继续寻找父类，会发现 <code>init</code> 方法在其父类（FrameworkServlet）的父类 <code>HttpServletBean</code> 中。</p> 
<h5><a id="HttpServletBeaninit_27"></a>HttpServletBean#init()</h5> 
<p>在这个方法中，首先会去家在一些 Servlet 相关配置（web.xml），然后会调用 <code>initServletBean()</code> 方法，这个方法是一个空的模板方法，业务逻辑由子类 <code>FrameworkServlet</code> 来实现。</p> 
<p><img src="https://images2.imgbox.com/d2/56/XcmeKZe0_o.png" alt="在这里插入图片描述"></p> 
<h5><a id="FrameworkServletinitServletBean_33"></a>FrameworkServlet#initServletBean</h5> 
<p>这个方法本身没有什么业务逻辑，主要是初始化 <code>WebApplicationContext</code> 对象，<code>WebApplicationContext</code> 继承自 <code>ApplicationContext</code>，主要是用来处理 <code>web</code> 应用的上下文。<br> <img src="https://images2.imgbox.com/e8/90/HSrILXAA_o.png" alt="在这里插入图片描述"></p> 
<h5><a id="FrameworkServletinitWebApplicationContext_38"></a>FrameworkServlet#initWebApplicationContext</h5> 
<p><code>initWebApplicationContext()</code> 方法主要就是为了找到一个上下文，找不到就会创建一个上下文，创建之后，最终会调用方法 <code>configureAndRefreshWebApplicationContext(cwac)</code> 方法，而这个方法最终在设置一些基本容器标识信息之后会去调用 <code>refresh()</code> 方法，也就是<a href="https://blog.csdn.net/zwx900102/article/details/121170478">初始化 <code>ioc</code> 容器</a>。<br> <img src="https://images2.imgbox.com/4d/84/cElwQ396_o.png" alt="在这里插入图片描述"></p> 
<p>当调用 <code>refresh()</code> 方法初始化 <code>ioc</code> 容器之后，最终会调用方法 <code>onRefresh()</code>，这个方法也是一个模板钩子方法，由子类实现，也就是回到了我们 <code>Spring MVC</code> 的入口类 <code>DispatcherServlet</code>。</p> 
<h5><a id="DispatchServletonRefresh_44"></a>DispatchServlet#onRefresh</h5> 
<p><code>onRefresh()</code> 方法就是 <code>Spring MVC</code> 初始化的最后一个步骤，在这个步骤当中会初始化 <code>Spring MVC</code> 流程中可能需要使用到的九大组件。<br> <img src="https://images2.imgbox.com/72/bc/uc0A4IDr_o.png" alt="在这里插入图片描述"></p> 
<h5><a id="Spring_MVC__49"></a>Spring MVC 九大组件</h5> 
<h6><a id="MultipartResolver_51"></a>MultipartResolver</h6> 
<p>这个组件比较熟悉，主要就是用来处理文件上传请求，通过将普通的 <code>Request</code> 对象包装成 <code>MultipartHttpServletRequest</code> 对象来进行处理。</p> 
<h6><a id="LocaleResolver_55"></a>LocaleResolver</h6> 
<p><code>LocaleResolver</code> 用于初始化本地语言环境，其从 <code>Request</code> 对象中解析出当前所处的语言环境，如中国大陆则会解析出 <code>zh-CN</code> 等等，模板解析以及国际化的时候都会用到本地语言环境。</p> 
<h6><a id="ThemeResolver_59"></a>ThemeResolver</h6> 
<p>这个主要是用户主题解析，在 <code>Spring MVC</code> 中，一套主题对应一个 <code>.properties</code> 文件，可以存放和当前主题相关的所有资源，如图片，css样式等。</p> 
<h6><a id="HandlerMapping_63"></a>HandlerMapping</h6> 
<p>用于查找处理器（<code>Handler</code>），比如我们 <code>Controller</code> 中的方法，这个其实最主要就是用来存储 <code>url</code> 和 调用方法的映射关系，存储好映射关系之后，后续有请求进来，就可以知道调用哪个 <code>Controller</code> 中的哪个方法，以及方法的参数是哪些。</p> 
<h6><a id="HandlerAdapter_67"></a>HandlerAdapter</h6> 
<p>这是一个适配器，因为 <code>Spring MVC</code> 中支持很多种 <code>Handler</code>，但是最终将请求交给 <code>Servlet</code> 时，只能是 <code>doService(req,resp)</code> 形式，所以 <code>HandlerAdapter</code> 就是用来适配转换格式的。</p> 
<h6><a id="HandlerExceptionResolver_71"></a>HandlerExceptionResolver</h6> 
<p>这个组件主要是用来处理异常，不过看名字也很明显，这个只会对处理 <code>Handler</code> 时产生的异常进行处理，然后会根据异常设置对应的 <code>ModelAndView</code>，然后交给 <code>Render</code> 渲染成页面。</p> 
<h6><a id="RequestToViewNameTranslator_75"></a>RequestToViewNameTranslator</h6> 
<p>这个主键主要是从 <code>Request</code> 中获取到视图名称。</p> 
<h6><a id="ViewResolver_79"></a>ViewResolver</h6> 
<p>这个组件会依赖于 <code>RequestToViewNameTranslator</code> 组件获取到的视图名称，因为视图名称是字符串格式，所以这里会将字符串格式的视图名称转换成为 <code>View</code> 类型视图，最终经过一系列解析和变量替换等操作返回一个页面到前端。</p> 
<h6><a id="FlashMapManager_83"></a>FlashMapManager</h6> 
<p>这个主键主要是用来管理 <code>FlashMap</code>，那么 <code>FlashMap</code> 又有什么用呢？要明白这个那就不得不提到重定向了，有时候我们提交一个请求的时候会需要重定向，那么假如参数过多或者说我们不想把参数拼接到 <code>url</code> 上（比如敏感数据之类的），这时候怎么办呢？因为参数不拼接在 <code>url</code> 上重定向是无法携带参数的。</p> 
<p><code>FlashMap</code> 就是为了解决这个问题，我们可以在请求发生重定向之前，将参数写入 <code>request</code> 的属性 <code>OUTPUT_FLASH_MAP_ATTRIBUTE</code> 中，这样在重定向之后的 <code>handler</code> 中，<code>Spring</code> 会自动将其设置到 <code>Model</code> 中，这样就可以从 <code>Model</code> 中取到我们传递的参数了。</p> 
<h4><a id="_89"></a>处理请求</h4> 
<p>在九大组件初始化完成之后，<code>Spring MVC</code> 的初始化就完成了，接下来就是接收并处理请求了，那么处理请求的入口在哪里呢？处理请求的入口方法就是 <code>DispatcherServlet</code> 中的 <code>doService</code> 方法，而 <code>doService</code> 方法又会调用 <code>doDispatch</code> 方法。</p> 
<h5><a id="DispatcherServletdoDispatch_93"></a>DispatcherServlet#doDispatch</h5> 
<p><img src="https://images2.imgbox.com/e9/b7/f59EW7w2_o.png" alt="在这里插入图片描述"></p> 
<p>这个方法最关键的就是调用了 <code>getHandler</code> 方法，这个方法就是会获取到前面九大组件中的 <code>HandlerMapping</code>，然后进行反射调用对应的方法完成请求，完成请求之后后续还会经过视图转换之类的一些操作，最终返回 <code>ModelAndView</code>，不过现在都是前后端分离，基本也不需要用到视图模型，在这里我们就不分析后续过程，主要就是分析 <code>HandlerMapping</code> 的初始化和查询过程。</p> 
<h5><a id="DispatcherServletgetHandler_98"></a>DispatcherServlet#getHandler</h5> 
<p>这个方法里面会遍历 <code>handllerMappings</code>，这个 <code>handllerMappings</code> 是一个 <code>List</code> 集合，因为 <code>HandlerMapping</code> 有多重实现，也就是 <code>HandlerMapping</code> 不止一个实现，其最常用的两个实现为 <code>RequestMappingHandlerMapping</code> 和 <code>BeanNameUrlHandlerMapping</code>。<br> <img src="https://images2.imgbox.com/a5/cd/FHo5vdFM_o.png" alt="在这里插入图片描述"></p> 
<h5><a id="AbstractHandlerMappinggetHandler_102"></a>AbstractHandlerMapping#getHandler</h5> 
<p><code>AbstractHandlerMapping</code> 是一个抽象类，其 <code>getHandlerInternal</code> 这个方法也是一个模板方法：</p> 
<p><img src="https://images2.imgbox.com/92/8d/9kfR47Wn_o.png" alt="在这里插入图片描述"><br> <code>getHandlerInternal</code> 方法最终其会调用子类实现，而这里的子类实现会有多个，其中最主要的就是 <code>AbstractHandlerMethodMapping</code> 和 <code>AbstractUrlHandlerMapping</code> 两个抽象类，那么最终到底会调用哪个实现类呢？</p> 
<p>这时候如果拿捏不准我们就可以看一下类图，上面我们提到，<code>HandlerMapper</code> 有两个非常主要的实现类：<code>RequestMappingHandlerMapping</code> 和 <code>BeanNameUrlHandlerMapping</code>。那么我们就分别来看一下这两个类的类图关系：</p> 
<p><img src="https://images2.imgbox.com/ab/dc/mSXtN4l8_o.png" alt="在这里插入图片描述"><br> <img src="https://images2.imgbox.com/c1/50/Ea2wvxKB_o.png" alt="在这里插入图片描述"></p> 
<p>可以看到，这两个实现类的抽象父类正好对应了 <code>AbstractHandlerMapping</code> 的两个子类，所以这时候具体看哪个方法，那就看我们想看哪种类型了。</p> 
<ul><li> <p>RequestMappingHandlerMapping：主要用来存储 <code>RequestMapping</code> 注解相关的控制器和 <code>url</code> 的映射关系。</p> </li><li> <p>BeanNameUrlHandlerMapping：主要用来处理 <code>Bean name</code> 直接以 <code>/</code> 开头的控制器和 <code>url</code> 的映射关系。</p> </li></ul> 
<p>其实除了这两种 <code>HandlerMapping</code> 之外，<code>Spring</code> 中还有其他一些 <code>HandllerMapping</code>，如 <code>SimpleUrlHandlerMapping</code> 等。</p> 
<p>提到的这几种 <code>HandlerMapping</code>，对我们来说最常用，最熟悉的那肯定就是 <code>RequestMappingHandlerMapping</code> ，在这里我们就以这个为例来进行分析，所以我们应该</p> 
<h5><a id="AbstractHandlerMethodMappinggetHandlerInternal_123"></a>AbstractHandlerMethodMapping#getHandlerInternal</h5> 
<p>这个方法本身也没有什么逻辑，其主要的核心查找 <code>Handler</code> 逻辑在 <code>lookupHandlerMethod</code> 方法中，这个方法主要是为了获取一个 <code>HandlerMethod</code> 对象，前面的方法都是 <code>Object</code>，而到这里变成了 <code>HandlerMethod</code> 类型，这是因为 <code>Handler</code> 有各种类型，目前我们已经基本跟到了具体类型之下，所以类型就变成了具体类型，而如果我们看的的另一条分支线，那么返回的就会是其他对象，正是因为支持多种不同类型的 <code>HandlerMapping</code> 对象，所以最终为了统一执行，才会需要在获得 <code>Hanlder</code> 之后，<code>DispatcherServlet</code> 中会再次通过调用 <code>getHandlerAdapter</code> 方法来进一步封装成 <code>HandlerAdapter</code> 对象，才能进行方法的调用<br> <img src="https://images2.imgbox.com/31/cc/yqI5IGL0_o.png" alt="在这里插入图片描述"></p> 
<h5><a id="AbstractHandlerMethodMappinglookupHandlerMethod_127"></a>AbstractHandlerMethodMapping#lookupHandlerMethod</h5> 
<p>这个方法主要会从 <code>mappingRegistry</code> 中获取命中的方法，获取之后还会经过一系列的判断比较判断比较，因为有些 <code>url</code> 会对应多个方法，而方法的请求类型不同，比如一个 <code>GET</code> 方法，一个 <code>POST</code> 方法，或者其他一些属性不相同等等，都会导致最终命中到不同的方法，这些逻辑主要都是在 <code>addMatchingMappings</code> 方法去进一步实现，并最终将命中的结果加入到 <code>matches</code> 集合内。<br> <img src="https://images2.imgbox.com/e2/b1/zcgx6I6v_o.png" alt="在这里插入图片描述"></p> 
<p>在这个方法中，有一个对象非常关键，那就是 <code>mappingRegistry</code>，因为最终我们根据 <code>url</code> 到这里获取到对应的 <code>HandlerMtthod</code>，所以这个对象很关键：</p> 
<p><img src="https://images2.imgbox.com/83/21/hlnTNkc0_o.png" alt="在这里插入图片描述"></p> 
<p>看这个对象其实很明显可以看出来，这个对象其实只是维护了一些 <code>Map</code> 对象，所以我们可以很容易猜测到，一定在某一个地方，将 <code>url</code> 和 <code>HandlerMapping</code> 或者 <code>HandlerMethod</code> 的映射关系存进来了，这时候其实我们可以根据 <code>getMappingsByUrl</code> 方法来进行反推，看看 <code>urlLookup</code> 这个 <code>Map</code> 是什么时候被存入的，结合上面的类图关系，一路反推，很容易就可以找到这个 <code>Map</code> 中的映射关系是 <code>AbstractHandlerMethodMapping</code> 对象的 <code>afterPropertiesSet</code> 方法实现的（<code>AbstractHandlerMethodMapping</code> 实现了 <code>InitializingBean</code> 接口），也就是当这个对象初始化完成之后，我们的 <code>url</code> 和 <code>Handler</code> 映射关系已经存入了 <code>MappingRegistry</code> 对象中的集合 <code>Map</code> 中。</p> 
<h5><a id="AbstractHandlerMethodMapping__138"></a>AbstractHandlerMethodMapping 的初始化</h5> 
<p><code>afterPropertiesSet</code> 方法中并没有任何逻辑，而是直接调用了 <code>initHandlerMethods</code>。</p> 
<h5><a id="AbstractHandlerMethodMappinginitHandlerMethods_142"></a>AbstractHandlerMethodMapping#initHandlerMethods</h5> 
<p><code>initHandlerMethods</code> 方法中，首先还是会从 <code>Spring</code> 的上下文中获取所有的 <code>Bean</code>，然后会进一步从带有 <code>RequestMapping</code> 注解和 <code>Controller</code> 注解中的 <code>Bean</code> 去解析并获得 <code>HandlerMethod</code>。<br> <img src="https://images2.imgbox.com/b9/90/cTF593i9_o.png" alt="在这里插入图片描述"></p> 
<h5><a id="AbstractHandlerMethodMappingdetectHandlerMethods_147"></a>AbstractHandlerMethodMapping#detectHandlerMethods</h5> 
<p>这个方法中，其实就是通过反射获取到 <code>Controller</code> 中的所有方法，然后调用 <code>registerHandlerMethod</code> 方法将相关信息注册到 <code>MappingRegistry</code> 对象中的各种 <code>Map</code> 集合之内：<br> <img src="https://images2.imgbox.com/a5/9b/wUdEtjGp_o.png" alt="在这里插入图片描述"></p> 
<h5><a id="AbstractHandlerMethodMappingregister_152"></a>AbstractHandlerMethodMapping#register</h5> 
<p><code>registerHandlerMethod</code> 方法中会直接调用 <code>AbstractHandlerMethodMapping</code> 对象持有的 <code>mappingRegistry</code> 对象中的 <code>regidter</code> 方法，这里会对 <code>Controller</code> 中方法上的一些元信息进行各种解析，比如参数，路径，请求方式等等，然后会将各种信息注册到对应的 <code>Map</code> 集合中，最终完成了整个初始化。</p> 
<p><img src="https://images2.imgbox.com/f2/4b/d0oEiWeT_o.png" alt="在这里插入图片描述"></p> 
<h2><a id="_158"></a>总结</h2> 
<p>本文重点以 <code>RequestMappingHandlerMapping</code> 为例子分析了在 <code>Spring</code> 当中如何初始化 <code>HandlerMethod</code>，并最终在调用的时候又是如何根据 <code>url</code> 获取到对应的方法并进行执行最终完成整个流程。</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/ed06a242e98c6d953b20b282170a97f2/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">xls批量转换为xlsx格式文件</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/a5f57154a3cca8e2ef908c716b976a3c/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">Oracle Total Recall - FDA（Flashback Data Archives）</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>