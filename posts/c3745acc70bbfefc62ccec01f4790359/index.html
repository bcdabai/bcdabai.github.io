<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>【征服redis3】一文征服redis的jedis客户端 - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="【征服redis3】一文征服redis的jedis客户端" />
<meta property="og:description" content="使用数据库的时候，我们可以用JDBC来实现mysql数据库与java程序之间的通信，为了提高通信效率，我们有了数据库连接池比如druid等等。而我们想通过Java程序控制redis，同样可以借助一些工具来实现，这就是redis客户端，常见的有Jedis、lettuce、redisson等等，这几个工具各有优缺点，而且应用都比较多，所以我们分三篇逐步来看。
Jedis 是一个功能强大、易用性高的 Redis 客户端库，适用于 Java 开发人员在项目中连接和操作 Redis 服务器。接下来，将介绍 Jedis 的使用方法和示例。
目录
1. Jedis介绍与安装测试
2.Jedis的基本操作体验
1.设置和获取字符串类型的键值对
2.判断键是否存在
3.删除键
4.设置键的过期时间
3.Jedis的数据类型操作
1.字符串类型
2.列表类型
3.集合类型
4.哈希类型
5.有序集合类型
4. Jedis 的事务操作
1.开启和提交事务
2.回滚事务
3.监视键
5. Jedis 的发布订阅操作
1.发布消息
2.订阅消息
6. Jedis 的管道操作
7. Jedis 的连接池配置和使用
8. Jedis 的异常处理
1. 处理连接异常
2. 处理命令执行异常：
9.Jedis 的性能优化
1. Jedis介绍与安装测试 Jedis 是一个流行的 Java 编写的 Redis 客户端库，它提供了连接和操作 Redis 服务器的功能。Jedis具有以下特点：
简单易用：Jedis 提供了简洁的 API，方便开发人员使用，减少了连接和操作 Redis 的复杂性。不过呢，简单也意味一些高级不能不支持的，这个与后面的客户端对比就知道了高性能：Jedis 是通过直接与 Redis 服务器进行通信来实现操作的，因此具有较高的性能。支持多种数据类型：Jedis 支持操作 Redis 的各种数据类型，包括字符串、哈希、列表、集合、有序集合等。支持事务和管道：Jedis 提供了事务和管道的支持，可以将多个操作打包成一个原子操作，提高了操作的效率。支持连接池：Jedis 支持连接池，可以复用连接，避免频繁建立和关闭连接的开销，提高了性能。 如果我们想在通过java 来管理redis，可以按照下面的方式进行：" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/c3745acc70bbfefc62ccec01f4790359/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2024-01-16T20:19:02+08:00" />
<meta property="article:modified_time" content="2024-01-16T20:19:02+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">【征服redis3】一文征服redis的jedis客户端</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p>使用数据库的时候，我们可以用JDBC来实现mysql数据库与java程序之间的通信，为了提高通信效率，我们有了数据库连接池比如druid等等。而我们想通过Java程序控制redis，同样可以借助一些工具来实现，这就是redis客户端，常见的有Jedis、lettuce、redisson等等，这几个工具各有优缺点，而且应用都比较多，所以我们分三篇逐步来看。</p> 
<p>Jedis 是一个功能强大、易用性高的 Redis 客户端库，适用于 Java 开发人员在项目中连接和操作 Redis 服务器。接下来，将介绍 Jedis 的使用方法和示例。</p> 
<p id="main-toc"><strong>目录</strong></p> 
<p id="1.%20Jedis%E4%BB%8B%E7%BB%8D%E4%B8%8E%E5%AE%89%E8%A3%85%E6%B5%8B%E8%AF%95-toc" style="margin-left:0px;"><a href="#1.%20Jedis%E4%BB%8B%E7%BB%8D%E4%B8%8E%E5%AE%89%E8%A3%85%E6%B5%8B%E8%AF%95" rel="nofollow">1. Jedis介绍与安装测试</a></p> 
<p id="2.Jedis%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C%E4%BD%93%E9%AA%8C-toc" style="margin-left:0px;"><a href="#2.Jedis%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C%E4%BD%93%E9%AA%8C" rel="nofollow">2.Jedis的基本操作体验</a></p> 
<p id="1.%E8%AE%BE%E7%BD%AE%E5%92%8C%E8%8E%B7%E5%8F%96%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%B1%BB%E5%9E%8B%E7%9A%84%E9%94%AE%E5%80%BC%E5%AF%B9-toc" style="margin-left:40px;"><a href="#1.%E8%AE%BE%E7%BD%AE%E5%92%8C%E8%8E%B7%E5%8F%96%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%B1%BB%E5%9E%8B%E7%9A%84%E9%94%AE%E5%80%BC%E5%AF%B9" rel="nofollow">1.设置和获取字符串类型的键值对</a></p> 
<p id="2.%E5%88%A4%E6%96%AD%E9%94%AE%E6%98%AF%E5%90%A6%E5%AD%98%E5%9C%A8-toc" style="margin-left:40px;"><a href="#2.%E5%88%A4%E6%96%AD%E9%94%AE%E6%98%AF%E5%90%A6%E5%AD%98%E5%9C%A8" rel="nofollow">2.判断键是否存在</a></p> 
<p id="3.%E5%88%A0%E9%99%A4%E9%94%AE-toc" style="margin-left:40px;"><a href="#3.%E5%88%A0%E9%99%A4%E9%94%AE" rel="nofollow">3.删除键</a></p> 
<p id="4.%E8%AE%BE%E7%BD%AE%E9%94%AE%E7%9A%84%E8%BF%87%E6%9C%9F%E6%97%B6%E9%97%B4-toc" style="margin-left:40px;"><a href="#4.%E8%AE%BE%E7%BD%AE%E9%94%AE%E7%9A%84%E8%BF%87%E6%9C%9F%E6%97%B6%E9%97%B4" rel="nofollow">4.设置键的过期时间</a></p> 
<p id="3.Jedis%E7%9A%84%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E6%93%8D%E4%BD%9C-toc" style="margin-left:0px;"><a href="#3.Jedis%E7%9A%84%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E6%93%8D%E4%BD%9C" rel="nofollow">3.Jedis的数据类型操作</a></p> 
<p id="1.%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%B1%BB%E5%9E%8B-toc" style="margin-left:40px;"><a href="#1.%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%B1%BB%E5%9E%8B" rel="nofollow">1.字符串类型</a></p> 
<p id="2.%E5%88%97%E8%A1%A8%E7%B1%BB%E5%9E%8B-toc" style="margin-left:40px;"><a href="#2.%E5%88%97%E8%A1%A8%E7%B1%BB%E5%9E%8B" rel="nofollow">2.列表类型</a></p> 
<p id="3.%E9%9B%86%E5%90%88%E7%B1%BB%E5%9E%8B-toc" style="margin-left:40px;"><a href="#3.%E9%9B%86%E5%90%88%E7%B1%BB%E5%9E%8B" rel="nofollow">3.集合类型</a></p> 
<p id="4.%E5%93%88%E5%B8%8C%E7%B1%BB%E5%9E%8B-toc" style="margin-left:40px;"><a href="#4.%E5%93%88%E5%B8%8C%E7%B1%BB%E5%9E%8B" rel="nofollow">4.哈希类型</a></p> 
<p id="5.%E6%9C%89%E5%BA%8F%E9%9B%86%E5%90%88%E7%B1%BB%E5%9E%8B-toc" style="margin-left:40px;"><a href="#5.%E6%9C%89%E5%BA%8F%E9%9B%86%E5%90%88%E7%B1%BB%E5%9E%8B" rel="nofollow">5.有序集合类型</a></p> 
<p id="4.%20Jedis%20%E7%9A%84%E4%BA%8B%E5%8A%A1%E6%93%8D%E4%BD%9C-toc" style="margin-left:0px;"><a href="#4.%20Jedis%20%E7%9A%84%E4%BA%8B%E5%8A%A1%E6%93%8D%E4%BD%9C" rel="nofollow">4. Jedis 的事务操作</a></p> 
<p id="1.%E5%BC%80%E5%90%AF%E5%92%8C%E6%8F%90%E4%BA%A4%E4%BA%8B%E5%8A%A1-toc" style="margin-left:40px;"><a href="#1.%E5%BC%80%E5%90%AF%E5%92%8C%E6%8F%90%E4%BA%A4%E4%BA%8B%E5%8A%A1" rel="nofollow">1.开启和提交事务</a></p> 
<p id="2.%E5%9B%9E%E6%BB%9A%E4%BA%8B%E5%8A%A1-toc" style="margin-left:40px;"><a href="#2.%E5%9B%9E%E6%BB%9A%E4%BA%8B%E5%8A%A1" rel="nofollow">2.回滚事务</a></p> 
<p id="3.%E7%9B%91%E8%A7%86%E9%94%AE-toc" style="margin-left:40px;"><a href="#3.%E7%9B%91%E8%A7%86%E9%94%AE" rel="nofollow">3.监视键</a></p> 
<p id="5.%20Jedis%20%E7%9A%84%E5%8F%91%E5%B8%83%E8%AE%A2%E9%98%85%E6%93%8D%E4%BD%9C-toc" style="margin-left:0px;"><a href="#5.%20Jedis%20%E7%9A%84%E5%8F%91%E5%B8%83%E8%AE%A2%E9%98%85%E6%93%8D%E4%BD%9C" rel="nofollow">5. Jedis 的发布订阅操作</a></p> 
<p id="1.%E5%8F%91%E5%B8%83%E6%B6%88%E6%81%AF-toc" style="margin-left:40px;"><a href="#1.%E5%8F%91%E5%B8%83%E6%B6%88%E6%81%AF" rel="nofollow">1.发布消息</a></p> 
<p id="2.%E8%AE%A2%E9%98%85%E6%B6%88%E6%81%AF-toc" style="margin-left:40px;"><a href="#2.%E8%AE%A2%E9%98%85%E6%B6%88%E6%81%AF" rel="nofollow">2.订阅消息</a></p> 
<p id="6.%20Jedis%20%E7%9A%84%E7%AE%A1%E9%81%93%E6%93%8D%E4%BD%9C-toc" style="margin-left:0px;"><a href="#6.%20Jedis%20%E7%9A%84%E7%AE%A1%E9%81%93%E6%93%8D%E4%BD%9C" rel="nofollow">6. Jedis 的管道操作</a></p> 
<p id="7.%20Jedis%20%E7%9A%84%E8%BF%9E%E6%8E%A5%E6%B1%A0%E9%85%8D%E7%BD%AE%E5%92%8C%E4%BD%BF%E7%94%A8-toc" style="margin-left:0px;"><a href="#7.%20Jedis%20%E7%9A%84%E8%BF%9E%E6%8E%A5%E6%B1%A0%E9%85%8D%E7%BD%AE%E5%92%8C%E4%BD%BF%E7%94%A8" rel="nofollow">7. Jedis 的连接池配置和使用</a></p> 
<p id="8.%20Jedis%20%E7%9A%84%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86-toc" style="margin-left:0px;"><a href="#8.%20Jedis%20%E7%9A%84%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86" rel="nofollow">8. Jedis 的异常处理</a></p> 
<p id="1.%20%E5%A4%84%E7%90%86%E8%BF%9E%E6%8E%A5%E5%BC%82%E5%B8%B8-toc" style="margin-left:40px;"><a href="#1.%20%E5%A4%84%E7%90%86%E8%BF%9E%E6%8E%A5%E5%BC%82%E5%B8%B8" rel="nofollow">1. 处理连接异常</a></p> 
<p id="2.%20%E5%A4%84%E7%90%86%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C%E5%BC%82%E5%B8%B8%EF%BC%9A-toc" style="margin-left:40px;"><a href="#2.%20%E5%A4%84%E7%90%86%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C%E5%BC%82%E5%B8%B8%EF%BC%9A" rel="nofollow">2. 处理命令执行异常：</a></p> 
<p id="9.Jedis%20%E7%9A%84%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96-toc" style="margin-left:0px;"><a href="#9.Jedis%20%E7%9A%84%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96" rel="nofollow">9.Jedis 的性能优化</a></p> 
<hr id="hr-toc"> 
<p></p> 
<h2 id="1.%20Jedis%E4%BB%8B%E7%BB%8D%E4%B8%8E%E5%AE%89%E8%A3%85%E6%B5%8B%E8%AF%95">1. Jedis介绍与安装测试</h2> 
<p><br> Jedis 是一个流行的 Java 编写的 Redis 客户端库，它提供了连接和操作 Redis 服务器的功能。Jedis具有以下特点：</p> 
<ol><li>简单易用：Jedis 提供了简洁的 API，方便开发人员使用，减少了连接和操作 Redis 的复杂性。不过呢，简单也意味一些高级不能不支持的，这个与后面的客户端对比就知道了</li><li>高性能：Jedis 是通过直接与 Redis 服务器进行通信来实现操作的，因此具有较高的性能。</li><li>支持多种数据类型：Jedis 支持操作 Redis 的各种数据类型，包括字符串、哈希、列表、集合、有序集合等。</li><li>支持事务和管道：Jedis 提供了事务和管道的支持，可以将多个操作打包成一个原子操作，提高了操作的效率。</li><li>支持连接池：Jedis 支持连接池，可以复用连接，避免频繁建立和关闭连接的开销，提高了性能。</li></ol> 
<p>如果我们想在通过java 来管理redis，可以按照下面的方式进行：</p> 
<p><strong>首先，下载 Jedis</strong></p> 
<p>Jedis 的源代码托管在 Github 上，如果想看源码，可以直接从<a href="https://github.com/redis/jedis" title="这里">这里</a>下载。如果要直接使用，可以通过 Maven 或 Gradle 添加 Jedis 的依赖即可。</p> 
<p>在 <code>pom.xml</code> 文件中添加以下内容：</p> 
<pre><code>&lt;dependency&gt;
    &lt;groupId&gt;redis.clients&lt;/groupId&gt;
    &lt;artifactId&gt;jedis&lt;/artifactId&gt;
    &lt;version&gt;2.10.0&lt;/version&gt;
&lt;/dependency&gt;
</code></pre> 
<p>版本一直在更新，Jedis是Java语言的Redis客户端库，它的版本号可以通过查看Jedis的Maven依赖或者JAR包的版本信息来获取。以下是一些常见的Jedis版本号范例：</p> 
<ul><li>Jedis 2.x版本：例如2.10.0、2.9.0等。</li><li>Jedis 3.x版本：例如3.6.0、3.5.2等。</li></ul> 
<p>这里我们使用应用比较多的2.10.0版本。</p> 
<p><strong>然后，我们可以在代码里配置Redis服务器的地址和端口</strong></p> 
<p>在 Java 程序中，需要提供 Redis 服务器的地址和端口，以便 Jedis 能够连接到 Redis。以下是一段示例代码：</p> 
<pre><code>  public static void main(String[] args) {
        Jedis jedis = new Jedis("localhost", 6379);
        // 测试连接
        System.out.println("Connection Successful");
        System.out.println("Server is running: " + jedis.ping());
    }</code></pre> 
<p>然后执行，可以看到如下信息，就说明已经安装成功了:</p> 
<blockquote> 
 <p>Connection Successful<br> Server is running: PONG</p> 
</blockquote> 
<p>在这里，我们创建了一个新的 Jedis 对象，然后提供了 Redis 服务器的地址（“localhost”）和默认端口（6379）。然后，调用 <code>jedis.ping()</code> 来测试与 Redis 服务器的连接。<br> 如果 Redis 服务器需要密码验证，可以在连接时添加密码参数： </p> 
<pre><code>Jedis jedis = new Jedis("localhost", 6379);
jedis.auth("password");
</code></pre> 
<p>使用的时候，将上面的“password” 换成你的 Redis 服务器的密码即可。</p> 
<p>配置完成后，就可以通过 Jedis 连接和操作 Redis 服务器了。在实际工程中，我们会将连接信息写在配置文件里来集中管理，这里为了简单 ，我们直接用程序写死了。</p> 
<p>接下来，将介绍 Jedis 的常用操作方法和示例。</p> 
<h2 id="2.Jedis%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C%E4%BD%93%E9%AA%8C">2.Jedis的基本操作体验</h2> 
<h3 id="1.%E8%AE%BE%E7%BD%AE%E5%92%8C%E8%8E%B7%E5%8F%96%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%B1%BB%E5%9E%8B%E7%9A%84%E9%94%AE%E5%80%BC%E5%AF%B9"><strong>1.设置和获取字符串类型的键值对</strong></h3> 
<p>以下是如何使用 Jedis 的 <code>set</code> 和 <code>get</code> 方法来设置和获取字符串类型的键值对的例子：</p> 
<pre><code>        jedis.set("mykey", "海涛");
        String value = jedis.get("mykey");
        System.out.println("Stored string in redis:: " + value);</code></pre> 
<p>输出结果为：</p> 
<blockquote> 
 <p>Stored string in redis:: 海涛</p> 
</blockquote> 
<h3 id="2.%E5%88%A4%E6%96%AD%E9%94%AE%E6%98%AF%E5%90%A6%E5%AD%98%E5%9C%A8">2.判断键是否存在</h3> 
<p>可以使用 <code>exists</code> 方法来检查一个键是否存在。以下是一个例子：</p> 
<pre><code class="language-java">//        判断是否存在
        boolean keyExists = jedis.exists("mykey");
        System.out.println("Does key 'mykey' exists? " + keyExists);</code></pre> 
<h3 id="3.%E5%88%A0%E9%99%A4%E9%94%AE">3.删除键</h3> 
<p>可以使用 <code>del</code> 方法来删除一个键。以下是一个例子：</p> 
<pre><code class="language-java">jedis.del("mykey");
</code></pre> 
<p>此时如果我们再使用上面的代码判断key是否存在就会发现此时返回的是 false。</p> 
<h3 id="4.%E8%AE%BE%E7%BD%AE%E9%94%AE%E7%9A%84%E8%BF%87%E6%9C%9F%E6%97%B6%E9%97%B4">4.设置键的过期时间</h3> 
<p>可以使用 <code>expire</code> 方法来为一个键设置过期时间（以秒为单位）。以下是一个例子：</p> 
<pre><code>        jedis.set("mykey", "海涛");
        jedis.expire("mykey", 60);  // 这个键将在60秒后过期</code></pre> 
<h2 id="3.Jedis%E7%9A%84%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E6%93%8D%E4%BD%9C">3.Jedis的数据类型操作</h2> 
<p>我们在前面通过redis-cli客户端来操作redis的几种类型，接下来，我们就看一下如何通过jedis来操作这些类型。</p> 
<h3 id="1.%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%B1%BB%E5%9E%8B">1.字符串类型</h3> 
<p>字符串类型是最简单也是最重要的的方式，我们可以直接使用set来设置一个，也可以使用mset来设置多个，例如：</p> 
<pre><code>jedis.set("key", "海涛"); // 设置字符串类型的键值对
String value = jedis.get("key"); // 获取字符串类型的键对应的值

// 批量设置字符串类型的键值对
jedis.mset("key1", "海涛", "key2", "江涛");

// 批量获取字符串类型的键对应的值
List&lt;String&gt; values = jedis.mget("key1", "key2");
</code></pre> 
<p>输出结果：</p> 
<blockquote> 
 <p>value:海涛<br> values=[海涛, 江涛]</p> 
</blockquote> 
<ul><li>2.设置和获取字符串类型的键值对：</li></ul> 
<pre><code>jedis.set("mykey", "myvalue");
String value = jedis.get("mykey");
System.out.println("Stored string in redis:: " + value);
</code></pre> 
<ul><li>3.批量设置和获取键值对：</li></ul> 
<pre><code>jedis.mset("key1", "海涛", "key2", "江涛");
List&lt;String&gt; values = jedis.mget("key1", "key2");
</code></pre> 
<h3 id="2.%E5%88%97%E8%A1%A8%E7%B1%BB%E5%9E%8B">2.列表类型</h3> 
<p>我们可以通过jedis的api接口来调用，名称与命令非常类似：</p> 
<pre><code>    public  static void  testList( Jedis jedis){
        // 添加元素到列表头部和尾部
        jedis.lpush("list", "element1", "element2"); // 头部添加
        jedis.rpush("list", "element3", "element4"); // 尾部添加
        // 获取列表的长度
        Long length = jedis.llen("list");
        System.out.println(length);
       // 获取指定范围内的元素
        List&lt;String&gt; elements = jedis.lrange("list", 0, -1); // 获取所有元素
        System.out.println(elements);
    }</code></pre> 
<ul><li>添加元素到列表头部和尾部：</li></ul> 
<pre><code>jedis.lpush("mylist", "element1", "element2");
jedis.rpush("mylist", "element3");
</code></pre> 
<ul><li>获取列表的长度：</li></ul> 
<pre><code>Long length = jedis.llen("mylist");
</code></pre> 
<ul><li>获取指定范围内的元素：</li></ul> 
<pre><code>List&lt;String&gt; elements = jedis.lrange("mylist", 0, -1);
</code></pre> 
<h3 id="3.%E9%9B%86%E5%90%88%E7%B1%BB%E5%9E%8B">3.集合类型</h3> 
<p>集合类型是一种非常常见的类型，基本使用方式如下：</p> 
<pre><code>    public static void testSet(Jedis jedis) {
        // 添加元素到集合
        jedis.sadd("set", "element1", "element2");
        // 获取集合的大小
        Long size = jedis.scard("set");
        System.out.println("size=" + size);
        // 判断元素是否存在于集合中
        boolean exists = jedis.sismember("set", "element1");
        System.out.println(exists);
    }</code></pre> 
<ul><li>添加元素到集合：</li></ul> 
<pre><code>jedis.sadd("myset", "element1", "element2");
</code></pre> 
<ul><li>获取集合的大小：</li></ul> 
<pre><code>Long size = jedis.scard("myset");
</code></pre> 
<ul><li>判断元素是否存在于集合中：</li></ul> 
<pre><code>boolean exists = jedis.sismember("myset", "element1");
</code></pre> 
<h3 id="4.%E5%93%88%E5%B8%8C%E7%B1%BB%E5%9E%8B">4.哈希类型</h3> 
<p>hash是实现缓存的重要类型，使用jedis操作哈希的代码如下：</p> 
<pre><code>// 设置和获取哈希字段的值
jedis.hset("hash", "field1", "value1");
String value = jedis.hget("hash", "field1");

// 获取哈希中所有字段和值
Map&lt;String, String&gt; hash = jedis.hgetAll("hash");
</code></pre> 
<ul><li>设置和获取哈希字段的值：</li></ul> 
<pre><code>jedis.hset("myhash", "field1", "value1");
String value = jedis.hget("myhash", "field1");
</code></pre> 
<ul><li>获取哈希中所有字段和值：</li></ul> 
<pre><code>Map&lt;String, String&gt; allFieldsAndValues = jedis.hgetAll("myhash");
</code></pre> 
<h3 id="5.%E6%9C%89%E5%BA%8F%E9%9B%86%E5%90%88%E7%B1%BB%E5%9E%8B">5.有序集合类型</h3> 
<p>使用jedis进行有序集合的操作如下：</p> 
<pre><code>// 添加元素到有序集合
jedis.zadd("zset", 1, "member1");
jedis.zadd("zset", 2, "member2");

// 获取有序集合的成员和分数
Set&lt;Tuple&gt; membersWithScores = jedis.zrangeWithScores("zset", 0, -1);

// 根据分数范围获取有序集合的成员
Set&lt;String&gt; membersInRange = jedis.zrangeByScore("zset", 1, 2);
</code></pre> 
<ul><li>添加元素到有序集合：</li></ul> 
<pre><code>jedis.zadd("myzset", 1, "element1");
jedis.zadd("myzset", 2, "element2");
</code></pre> 
<ul><li>获取有序集合的成员和分数：</li></ul> 
<pre><code>Set&lt;String&gt; elements = jedis.zrange("myzset", 0, -1);
</code></pre> 
<ul><li>根据分数范围获取有序集合的成员：</li></ul> 
<pre><code>Set&lt;String&gt; elements = jedis.zrangeByScore("myzset", 1, 2);
</code></pre> 
<h2 id="4.%20Jedis%20%E7%9A%84%E4%BA%8B%E5%8A%A1%E6%93%8D%E4%BD%9C">4. Jedis 的事务操作</h2> 
<p>Jedis是Redis的Java客户端库，它提供了丰富的API来操作Redis数据库。在Jedis中，可以使用事务操作来执行一系列的Redis命令，并保证这些命令的原子性。</p> 
<h3 id="1.%E5%BC%80%E5%90%AF%E5%92%8C%E6%8F%90%E4%BA%A4%E4%BA%8B%E5%8A%A1">1.开启和提交事务</h3> 
<p>在 Jedis 中，可以使用 multi() 方法来开启一个事务，然后使用 exec() 方法来提交事务。在这两个方法之间的所有命令都会被放入事务队列中，等待 exec() 方法的调用。</p> 
<pre><code>Transaction t = jedis.multi();
t.set("foo", "bar");
t.exec();
</code></pre> 
<h3 id="2.%E5%9B%9E%E6%BB%9A%E4%BA%8B%E5%8A%A1">2.回滚事务</h3> 
<p>Jedis 提供了 <code>discard()</code> 方法来回滚事务。注意，只有当在调用 <code>multi()</code> 方法之后，还没有调用 <code>exec()</code> 方法之前，才可以调用 <code>discard()</code> 方法。</p> 
<pre><code>Transaction t = jedis.multi();
t.set("foo", "bar");
t.discard();
</code></pre> 
<h3 id="3.%E7%9B%91%E8%A7%86%E9%94%AE">3.监视键</h3> 
<p><code>watch()</code> 方法可以用来监视一个或多个键，如果在事务执行之前这些键被其他命令所改变，那么事务将被打断。</p> 
<pre><code>jedis.watch("foo");
Transaction t = jedis.multi();
t.set("foo", "bar");
t.exec();
</code></pre> 
<h2 id="5.%20Jedis%20%E7%9A%84%E5%8F%91%E5%B8%83%E8%AE%A2%E9%98%85%E6%93%8D%E4%BD%9C">5. Jedis 的发布订阅操作</h2> 
<p>Jedis是 提供了丰富的功能来与Redis进行交互。其中，发布订阅是Jedis库的一项重要功能，允许客户端在订阅频道时接收发布到频道的消息。</p> 
<h3 id="1.%E5%8F%91%E5%B8%83%E6%B6%88%E6%81%AF">1.发布消息</h3> 
<p>在 Jedis 中，可以使用 publish() 方法来发布消息。第一个参数是频道的名称，第二个参数是消息的内容。</p> 
<pre><code>Jedis jedis = new Jedis("localhost", 6379);
String channel = "myChannel";
String message = "Hello subscribers!";
jedis.publish(channel, message);
jedis.close();
</code></pre> 
<h3 id="2.%E8%AE%A2%E9%98%85%E6%B6%88%E6%81%AF">2.订阅消息</h3> 
<p>订阅消息需要创建一个 <code>JedisPubSub</code> 对象，并重写它的 <code>onMessage()</code> 方法。然后使用 <code>subscribe()</code> 方法来订阅一个或多个频道。</p> 
<pre><code>Jedis jedis = new Jedis("localhost", 6379);
JedisPubSub jedisPubSub = new JedisPubSub() {
    @Override
    public void onMessage(String channel, String message) {
        System.out.println("Received message: " + message + " from channel: " + channel);
    }
};
String channel = "myChannel";
jedis.subscribe(jedisPubSub, channel);
jedis.close();
</code></pre> 
<p>定义了一个JedisPubSub对象，该对象覆盖了onMessage方法，用于处理接收到的消息。然后，指定要订阅的频道名称，并使用subscribe方法进行订阅。</p> 
<p>需要注意的是，subscribe方法是阻塞的，它会一直等待直到接收到消息。因此，在实际应用中，通常会将订阅操作放在单独的线程中进行，以避免阻塞主线程。</p> 
<p>在订阅消息后，如果需要取消订阅，可以使用unsubscribe方法。</p> 
<pre><code>jedis.unsubscribe(jedisPubSub, channel);
</code></pre> 
<h2 id="6.%20Jedis%20%E7%9A%84%E7%AE%A1%E9%81%93%E6%93%8D%E4%BD%9C">6. Jedis 的管道操作</h2> 
<p>Jedis提供了管道（pipeline）操作来批量执行多个命令，以减少网络延迟和提高性能。管道操作允许在客户端一次性发送多个命令到Redis服务器，并在服务器端依次执行这些命令，最后将结果一次性返回给客户端。</p> 
<p>使用Jedis进行管道操作的步骤如下：</p> 
<ol><li>创建Jedis对象：首先，创建一个Jedis对象来与Redis服务器进行通信。</li><li>开启管道：通过调用Jedis对象的pipelined()方法来开启管道。</li><li>执行命令：使用Jedis对象执行需要批量执行的命令。可以使用Jedis对象的各种命令方法，如set()、get()等。</li><li>提交管道：通过调用Jedis对象的sync()方法来提交管道操作。这将一次性将所有命令发送到Redis服务器执行，并返回所有命令的结果。</li><li>关闭Jedis对象：最后，记得关闭Jedis对象以释放资源。在Jedis中，可以使用管道（Pipeline）来批量执行多个命令，以提高命令执行的效率。管道通过将多个命令打包在一起发送到Redis服务器，从而减少了网络I/O的开销。</li></ol> 
<p>使用Jedis管道的简单示例：</p> 
<pre><code>Pipeline pipeline = jedis.pipelined();

for (int i = 0; i &lt; 100; i++) {
    pipeline.set("key" + i, "value" + i);
}

pipeline.sync();
</code></pre> 
<p>创建了一个Pipeline对象，然后连续调用了100次<code>set()</code>方法。调用<code>sync()</code>方法会将之前调用的所有命令一次性发送到Redis服务器。</p> 
<p>管道中的命令不保证原子性，也就是说，如果管道中的某个命令执行失败，不会影响到其他命令的执行。如果需要保证一组命令的原子性，应该使用Redis的事务功能。</p> 
<p>此外，管道中的命令默认是不会立即返回结果的，如果需要获取命令的返回结果，可以使用syncAndReturnAll()方法来替代sync()方法。这将返回一个List，其中包含了管道中每个命令的返回结果。<br> 使用Jedis进行管道操作的示例代码</p> 
<pre><code>Jedis jedis = new Jedis("localhost", 6379);
Pipeline pipeline = jedis.pipelined();

// 执行多个命令
pipeline.set("key1", "value1");
pipeline.get("key1");
pipeline.hset("hashKey", "field1", "value2");

// 提交管道
List&lt;Object&gt; results = pipeline.syncAndReturnAll();

// 处理结果
for (Object result : results) {
    System.out.println(result);
}

// 关闭Jedis对象
jedis.close();
</code></pre> 
<p>创建了一个Jedis对象，并通过调用pipelined()方法开启了管道。执行三个命令：设置一个字符串类型的键值对、获取该键的值，以及设置一个哈希类型的字段值对。最后，通过调用syncAndReturnAll()方法提交管道操作，并返回了所有命令的结果。<br> 可以通过遍历结果列表来处理每个命令的返回值。最后，记得关闭Jedis对象以释放资源。</p> 
<p>使用管道操作可以显著提高性能，特别是在需要批量执行多个命令时。然而，需要注意的是，管道操作是无法使用事务的。如果需要支持事务操作，可以考虑使用Redis的事务功能。</p> 
<h2 id="7.%20Jedis%20%E7%9A%84%E8%BF%9E%E6%8E%A5%E6%B1%A0%E9%85%8D%E7%BD%AE%E5%92%8C%E4%BD%BF%E7%94%A8">7. Jedis 的连接池配置和使用</h2> 
<p>在实际使用中，通常会使用连接池来管理Jedis连接。Jedis的连接池使用Apache Commons Pool2实现。</p> 
<p>基本过程是：</p> 
<p>创建了一个JedisPoolConfig对象，并设置了各种连接池参数。然后使用这个配置对象，以及Redis服务器的地址和端口，创建了一个JedisPool对象。</p> 
<p>在需要使用Jedis连接的地方，使用getResource()方法从连接池中获取一个Jedis连接。这个连接使用完毕后，Jedis会自动将其归还到连接池中。</p> 
<p>注意，在获取Jedis连接时，使用了Java的try-with-resources语句，这样可以确保无论是否发生异常，Jedis连接都会被正确关闭。</p> 
<p>配置和使用Jedis连接池的示例：</p> 
<p>1.配置连接池参数：</p> 
<pre><code>JedisPoolConfig poolConfig = new JedisPoolConfig();
// 最大连接数
poolConfig.setMaxTotal(128);
// 最大空闲连接数
poolConfig.setMaxIdle(64);
// 最小空闲连接数
poolConfig.setMinIdle(10);
// 获取连接时的最大等待毫秒数
poolConfig.setMaxWaitMillis(2000);
// 在获取连接的时候检查有效性
poolConfig.setTestOnBorrow(true);
</code></pre> 
<p>2.创建Jedis连接池：</p> 
<pre><code>JedisPool jedisPool = new JedisPool(poolConfig, "localhost", 6379);
</code></pre> 
<p>从连接池中获取Jedis连接的代码如下：</p> 
<pre><code>try (Jedis jedis = jedisPool.getResource()) {
    // 使用Jedis连接执行命令
    jedis.set("key", "value");
    System.out.println(jedis.get("key"));
} catch (Exception e) {
    // 异常处理
}
</code></pre> 
<h2 id="8.%20Jedis%20%E7%9A%84%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86">8. Jedis 的异常处理</h2> 
<p>处理Jedis连接或命令执行异常的一般方法是使用try/catch块来捕获并处理这些异常。<br> 在使用Jedis时，我们需要对连接异常和命令执行异常进行适当的处理。</p> 
<h3 id="1.%20%E5%A4%84%E7%90%86%E8%BF%9E%E6%8E%A5%E5%BC%82%E5%B8%B8">1. 处理连接异常</h3> 
<p>在创建连接池对象时，可以设置连接超时时间和读写超时时间，以及设置连接失败重试次数。<br> 在获取Jedis连接对象时，可以捕获JedisConnectionException异常来处理连接异常，例如重新获取连接或进行其他操作。<br> 在使用Jedis连接对象进行Redis操作时，如果发生连接异常，可以捕获JedisConnectionException异常，并根据具体情况进行处理，例如重新获取连接或进行其他操作。<br> 示例代码如下：</p> 
<pre><code>JedisPoolConfig config = new JedisPoolConfig();
config.setMaxTotal(100);
config.setMaxIdle(50);
config.setMinIdle(10);
config.setTestOnBorrow(true);
config.setTestOnReturn(true);

JedisPool jedisPool = new JedisPool(config, "localhost", 6379, 5000, "password");

Jedis jedis = null;
try {
    jedis = jedisPool.getResource();
    // 进行Redis操作
} catch (JedisConnectionException e) {
    // 处理连接异常，例如重新获取连接或进行其他操作
} finally {
    if (jedis != null) {
        jedis.close();
    }
}
</code></pre> 
<p>Jedis连接异常通常是由于网络问题或者Redis服务器问题引起的。当尝试获取一个Jedis连接，或者使用一个已经获取的连接进行操作时，都可能触发这种异常。</p> 
<h3 id="2.%20%E5%A4%84%E7%90%86%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C%E5%BC%82%E5%B8%B8%EF%BC%9A">2. 处理命令执行异常：</h3> 
<p>当尝试执行一个无效的Redis命令，或者传递给命令的参数不正确时，Jedis会抛出一个JedisDataException。</p> 
<pre><code>Jedis jedis = new Jedis("localhost", 6379);
try {
    jedis.hset("key", "field", "value");
} catch (JedisDataException e) {
    // 命令执行异常处理
} finally {
    jedis.close();
}
</code></pre> 
<p>如果hset命令的参数不正确，例如key不存在，或者field已经存在，那么会抛出一个JedisDataException。需要捕获并处理这个异常。</p> 
<ol><li>在使用Jedis连接对象执行Redis命令时，可能会发生JedisDataException异常，例如命令格式不正确或参数类型不匹配等。</li><li>在使用Jedis连接对象执行Redis命令时，也可能会发生JedisException异常，例如Redis服务器出现问题或连接被关闭等。</li><li>在捕获这些异常时，可以根据具体情况进行处理，例如打印错误信息、回滚事务或进行其他操作。</li></ol> 
<p>示例代码如下：</p> 
<pre><code>try {
    jedis.set("key", "value");
} catch (JedisDataException e) {
    // 处理命令执行异常，例如命令格式不正确或参数类型不匹配等
} catch (JedisException e) {
    // 处理命令执行异常，例如Redis服务器出现问题或连接被关闭等
}
</code></pre> 
<h2 id="9.Jedis%20%E7%9A%84%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96">9.Jedis 的性能优化</h2> 
<p>使用连接池：在并发环境下，频繁地建立和释放连接会消耗大量的系统资源，影响应用性能。Jedis提供了连接池功能，可以复用已经建立的连接，减少连接的开销。</p> 
<pre><code>JedisPool pool = new JedisPool(new JedisPoolConfig(), "localhost");
Jedis jedis = null;
try {
    jedis = pool.getResource();
    // 使用jedis进行Redis操作
} finally {
    if (jedis != null) {
        jedis.close(); // 实际上是将连接返还给连接池，而不是关闭连接
    }
}
</code></pre> 
<p>批量执行命令：如果需要执行多个Redis命令，那么可以使用Jedis的管道（Pipeline）功能，一次性发送所有命令，然后一次性接收所有结果。这样可以避免每次命令执行都需要进行一次网络通信。</p> 
<pre><code>Jedis jedis = new Jedis("localhost");
Pipeline pipeline = jedis.pipelined();
pipeline.set("key1", "value1");
pipeline.set("key2", "value2");
pipeline.sync();
</code></pre> 
<p>在上述代码中，两个set命令会一次性发送到Redis服务器，然后sync方法会一次性接收两个命令的结果。这样可以避免每次命令执行都需要进行一次网络通信，减少了网络开销。</p> 
<ol><li>使用正确的数据结构和命令：Redis提供了多种数据结构和命令，根据具体的业务需求，选择最合适的数据结构和命令，可以大大提高性能。</li><li>避免长时间操作：对于耗时较长的操作，尽量避免在主线程中执行，可以考虑使用异步处理或者使用多线程处理。</li><li>适当使用持久化：根据业务需求，可以选择适当的持久化策略，例如RDB或者AOF。RDB性能较高，但是可能会丢失最近一段时间的数据；AOF性能较低，但是数据更安全。</li><li>尽量避免使用Keys命令：Keys命令会遍历整个数据库，对性能影响较大。尽量使用Scan命令代替。<br>  </li></ol> 
<p>示例：</p> 
<pre><code>import redis.clients.jedis.Jedis;
import redis.clients.jedis.JedisPool;
import redis.clients.jedis.JedisPoolConfig;
import redis.clients.jedis.Pipeline;

public class JedisExample {
    public static void main(String[] args) {
        // 创建Jedis实例，连接本地Redis
        Jedis jedis = new Jedis("localhost");
        
        // 设置键值
        jedis.set("key", "value");
        // 获取键值
        System.out.println(jedis.get("key"));

        // 使用连接池
        JedisPool pool = new JedisPool(new JedisPoolConfig(), "localhost");
        Jedis jedisFromPool = null;
        try {
            jedisFromPool = pool.getResource();
            // 使用jedisFromPool进行Redis操作
            jedisFromPool.set("key1", "value1");
            System.out.println(jedisFromPool.get("key1"));
        } finally {
            if (jedisFromPool != null) {
                jedisFromPool.close();  // 实际上是将连接返还给连接池，而不是关闭连接
            }
        }

        // 使用Pipeline
        Pipeline pipeline = jedis.pipelined();
        pipeline.set("key2", "value2");
        pipeline.set("key3", "value3");
        pipeline.sync(); // 一次性发送所有命令

        // 关闭Jedis
        jedis.close();
    }
}
</code></pre> 
<p></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/832c001613c5b03f1d117f6d35d03f17/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">基于GPT-4的Coscientist成功完成复杂化学实验，布洛芬配方轻松拿捏，复现诺贝尔化学奖</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/a21d96ff2bf2948e4c9121cb5d7b78d5/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">一文了解数据库，数据仓库，数据湖，数据集市，数据湖仓</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>