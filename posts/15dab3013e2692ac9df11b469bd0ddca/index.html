<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>回 溯 法 - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="回 溯 法" />
<meta property="og:description" content="一、（what？）
二、（why？）
三、（how？）
四、典型例题分析：
例题1：大卖场购物车2——0-1背包问题
问题分析：
算法设计：
图解算法：
伪代码：
double Bound(int i)//计算上界（即已装入物品价值&#43;剩余物品的总价值） { int rp=0; //剩余物品为第i~n种物品 while(i&lt;=n)//依次计算剩余物品的价值 { rp&#43;=v[i]; i&#43;&#43;; } return cp&#43;rp;//返回上界 } void Backtrack(int t) //t表示当前扩展结点在第t层 { if(t&gt;n) //已经到达叶子结点 { for(j=1;j&lt;=n;j&#43;&#43;) { bestx[j]=x[j]; } bestp=cp; //保存当前最优解 return ; } if(cw&#43;w[t]&lt;=W) //如果满足约束条件则搜索左子树 { x[t]=1; cw&#43;=w[t]; cp&#43;=v[t]; Backtrack(t&#43;1); cw-=w[t]; cp-=v[t]; } if(Bound(t&#43;1)&gt;bestp) //如果满足限界条件则搜索右子树 { x[t]=0; Backtrack(t&#43;1); } } 完整代码：
#include&lt;iostream&gt; #include&lt;string&gt; #include&lt;algorithm&gt; #define M 105 using namespace std; int i,j,n,W; //n表示n个物品，W表示购物车的容量 double w[M],v[M];//w[i] 表示第i个物品的重量，v[i] 表示第i个物品的价值 bool x[M]; //x[i]表示第i个物品是否放入购物车 double cw; //当前重量 double cp;//当前价值 double bestp;//当前最优价值 bool bestx[M]; //当前最优解 double Bound(int i)//计算上界（即已装入物品价值，剩余物品的总价值） { int rp=0;//剩余物品为第i~n种物品 while(i&lt;=n)//一次计算剩余物品的价值 { rp&#43;=v[i]; i&#43;&#43;; } return cp&#43;rp;//返回上界 } void Backtrack(int t)//t表示当前扩展点在第t层 { if(t&gt;n)//已经到达叶子结点 { for(j=1;j&lt;=n;j&#43;&#43;) { bestx[j]=x[j]; } bestp=cp;//保存当前最优解 return ; } if(cw&#43;w[i]&lt;=W)//如果满足条件约束搜索左子树 { x[t]=1; cw&#43;=w[t]; cp&#43;=v[t]; Backtrack(t&#43;1); cw-=w[t]; cp-=v[t]; } if(Bound(t&#43;1)&gt;bestp)//如果满足限界条件搜索右子树 { x[t]=0; Backtrack(t&#43;1); } } void Knapsack(double W,int n) { //初始化 cw=0; cp=0; bestp=0; double sumw=0." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/15dab3013e2692ac9df11b469bd0ddca/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-11-18T11:20:07+08:00" />
<meta property="article:modified_time" content="2023-11-18T11:20:07+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">回 溯 法</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p>一、（what？）</p> 
<p>二、（why？）</p> 
<p>三、（how？）</p> 
<p>四、典型例题分析：</p> 
<p>例题1：大卖场购物车2——0-1背包问题</p> 
<p></p> 
<p><img alt="" height="682" src="https://images2.imgbox.com/0d/c3/kRkWq6iE_o.png" width="965"></p> 
<p>问题分析：</p> 
<p><img alt="" height="192" src="https://images2.imgbox.com/6d/11/16Q8S73q_o.png" width="978"></p> 
<p>算法设计：</p> 
<p><img alt="" height="518" src="https://images2.imgbox.com/12/91/hvSzahMn_o.png" width="958"></p> 
<p><img alt="" height="420" src="https://images2.imgbox.com/1e/05/neHlKNg2_o.png" width="1000"></p> 
<p><img alt="" height="777" src="https://images2.imgbox.com/91/0d/zZs0Gbzt_o.png" width="978"></p> 
<p><img alt="" height="742" src="https://images2.imgbox.com/0d/8a/7NyjcoLh_o.png" width="967"></p> 
<p><img alt="" height="367" src="https://images2.imgbox.com/62/1b/PNVZBZ3C_o.png" width="1002"></p> 
<p>图解算法：</p> 
<p> <img alt="" height="1200" src="https://images2.imgbox.com/9a/d0/ydv6srRB_o.jpg" width="1200"></p> 
<p> <img alt="" height="1200" src="https://images2.imgbox.com/e1/70/cdsOlfzS_o.jpg" width="1200"></p> 
<p> <img alt="" height="1200" src="https://images2.imgbox.com/fe/ed/SykDcReP_o.jpg" width="1200"></p> 
<p> <img alt="" height="1200" src="https://images2.imgbox.com/31/86/kNN2Wzc4_o.jpg" width="1200"></p> 
<p> <img alt="" height="1200" src="https://images2.imgbox.com/ec/5d/2Day3Eoi_o.jpg" width="1200"></p> 
<p> <img alt="" height="1200" src="https://images2.imgbox.com/93/91/IMqOEIpi_o.jpg" width="1200"></p> 
<p> <img alt="" height="1200" src="https://images2.imgbox.com/64/1a/h7or6Y9u_o.jpg" width="1200"></p> 
<p> <img alt="" height="1200" src="https://images2.imgbox.com/46/4e/DuOdo6sR_o.jpg" width="1200"></p> 
<p> <img alt="" height="1200" src="https://images2.imgbox.com/66/8d/4zTl7aFx_o.jpg" width="1200"></p> 
<p> <img alt="" height="1200" src="https://images2.imgbox.com/4a/01/xMMOswey_o.jpg" width="1200"></p> 
<p>伪代码：</p> 
<p><img alt="" height="157" src="https://images2.imgbox.com/77/3d/eMxAvxM9_o.png" width="982"></p> 
<pre><code class="language-cpp">double Bound(int i)//计算上界（即已装入物品价值+剩余物品的总价值）
{
     int rp=0; //剩余物品为第i~n种物品
     while(i&lt;=n)//依次计算剩余物品的价值
     {
          rp+=v[i];
          i++;
     }
     return cp+rp;//返回上界
}</code></pre> 
<p> <img alt="" height="333" src="https://images2.imgbox.com/3d/d9/KGq2D9pD_o.png" width="975"></p> 
<pre><code class="language-cpp">void Backtrack(int t)     //t表示当前扩展结点在第t层
{
     if(t&gt;n)              //已经到达叶子结点
     {
          for(j=1;j&lt;=n;j++)
          {
               bestx[j]=x[j];
          }
          bestp=cp;       //保存当前最优解
          return ;
     }
     if(cw+w[t]&lt;=W)       //如果满足约束条件则搜索左子树
     {
          x[t]=1;
          cw+=w[t];
          cp+=v[t];
          Backtrack(t+1);
          cw-=w[t];
          cp-=v[t];
     }
     if(Bound(t+1)&gt;bestp) //如果满足限界条件则搜索右子树
     {
          x[t]=0;
          Backtrack(t+1);
     }
}</code></pre> 
<p> 完整代码：<br>  </p> 
<pre><code class="language-cpp">#include&lt;iostream&gt;
#include&lt;string&gt;
#include&lt;algorithm&gt;
#define M 105 
using namespace std;

int i,j,n,W; //n表示n个物品，W表示购物车的容量
double w[M],v[M];//w[i] 表示第i个物品的重量，v[i] 表示第i个物品的价值
bool x[M]; //x[i]表示第i个物品是否放入购物车
double cw; //当前重量
double cp;//当前价值
double bestp;//当前最优价值
bool bestx[M]; //当前最优解

double Bound(int i)//计算上界（即已装入物品价值，剩余物品的总价值） 
{
	int rp=0;//剩余物品为第i~n种物品 
	while(i&lt;=n)//一次计算剩余物品的价值 
	{
		rp+=v[i];
		i++;
	}
	return cp+rp;//返回上界 
}

void Backtrack(int t)//t表示当前扩展点在第t层 
{
	if(t&gt;n)//已经到达叶子结点
	{
		for(j=1;j&lt;=n;j++)
		{
			bestx[j]=x[j];
		}
		bestp=cp;//保存当前最优解
		return ; 
	 } 
	 if(cw+w[i]&lt;=W)//如果满足条件约束搜索左子树 
	 {
	 	x[t]=1;
	 	cw+=w[t];
	 	cp+=v[t];
	 	Backtrack(t+1);
	 	cw-=w[t];
	 	cp-=v[t];
	 }
	 if(Bound(t+1)&gt;bestp)//如果满足限界条件搜索右子树 
	 {
	 	x[t]=0;
	 	Backtrack(t+1);
	 }
}

void Knapsack(double W,int n)
{
	//初始化
	cw=0;
	cp=0;
	bestp=0;
	double sumw=0.0;
	double sumv=0.0;
	for(i=1;i&lt;=n;i++)
	{
		sumv+=v[i];
		sumw+=w[i];
	}
	if(sumw&lt;=W)
	{
		bestp=sumv;
		cout&lt;&lt;"放入购物车的物品最大价值为："&lt;&lt;bestp&lt;&lt;endl;
        cout&lt;&lt;"所有的物品均放入购物车。";
        return;
	}
	Backtrack(1);
    cout&lt;&lt;"放入购物车的物品最大价值为："&lt;&lt;bestp&lt;&lt;endl;
    cout&lt;&lt;"放入购物车的物品序号为：";
    for(i=1;i&lt;=n;i++) //输出最优解
    {
        if(bestx[i]==1)
        cout&lt;&lt;i&lt;&lt;" ";
    }
    cout&lt;&lt;endl;
}

int main()
{
	cout &lt;&lt; "请输入物品的个数n：";
    cin &gt;&gt; n;
    cout &lt;&lt; "请输入购物车的容量W：";
    cin &gt;&gt; W;
    cout &lt;&lt; "请依次输入每个物品的重量w和价值v，用空格分开：";
    for(i=1;i&lt;=n;i++)
        cin&gt;&gt;w[i]&gt;&gt;v[i];
    Knapsack(W,n);
	return 0;
} 
 
 
 
 </code></pre> 
<p>例题2：</p> 
<p>例题3：</p> 
<p>例题4：</p> 
<p>例题5：</p> 
<p>例题6：</p> 
<p></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/c32fbfd93c6453cf72e1b7a0a8ea5742/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">VUE基础入门</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/5e3e1bab540bc1fcadbac776f4b5c911/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">在linux下如何使用yum命令查看安装了哪些软件包</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>