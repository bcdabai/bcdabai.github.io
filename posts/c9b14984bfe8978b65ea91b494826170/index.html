<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>java_高级_多线程 - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="java_高级_多线程" />
<meta property="og:description" content=" 进程：一个系统中可以“同时”运行多个程序，一个程序就是一个进程 线程：一个程序中可以“同时”运行多个功能，一个功能就是一个线程 一个线程中可以“同时”运行多个其他线程 单核CPU 同一时间只能执行一个程序（一个进程中某个一个线程） 轮转时间片 多线程的创建方式（重要） 2种方式 类的对象就是一个多线程的对象 (1)某个类继承Thread类 (2)某个类实现Runnable接口，并实现其中的run方法 线程的生命周期 多线程的启动不能调用run方法，如果通过调用run方法来执行多线程，这个就是普通方法 启动多线程需要调用Thread类中start方法，start方法会以多线程的方式启动run方法 参照图片理解 多线程的控制 线程的休眠 -- 属于一种阻塞事件，让某个线程休眠一段时间 Thread.sleep(1000);让代码所属方法休眠1000ms 利用Runnable创建线程对象时的问题 如何启动线程？ Runnable r1 = new Runnable(); Thread t1 = new Thread(r1); t1.start(); -- 相当于启动了r1 使用Thread类还是Runnable接口创建多线程类，哪一种方式更好？ Thread类的优势：提供了操作线程的方法，可以直接使用（比如start和stop） Runnable接口的优势： 由于Java是单继承，Runnable不占据父类的位置，可以提供更好扩展性 个人认为Runnable更好，对系统来说提供了更好的扩展性 同步与异步 线程不安全的产生原因 多个线程操作同一个资源时，操作过程中让出CPU执行权，此时数据处于修改不完善的状态， 下一个线程在进行操作时读取了没有修改完善的数据，造成了数据的错误 解决线程安全的主要方法是通过 同步关键字（也被称为锁） -- synchronized synchronized可以修饰 方法和代码块，这样的方法或代码块中的代码，只允许一个线程完整访问后才可以交给下一个线程 同步方法：不明确锁定资源，锁定了整个方法的代码 同步块：可以明确指定锁定的资源，只同步需要同步的部分代码而不是整个方法 推荐使用同步块解决线程不安全的问题 使用了synchronized的代码被称为同步方式 -- 同一时间内某方法只能被一个对象使用 没有使用synchronized的多线程代码被称为异步方式 -- 同一时间内某方法可能被多个对象同时使用 在懒汉式单例中getInstance方法应该是一个线程安全的方法，否则多线程的环境中有可能单例对象被不同线程初始化多次 在Java中对比两种单例模式，个人推荐使用饿汉式单例 死锁 共享资源 A B A&#43;B资源都获得以后才能完成目标 线程1 获得了A资源， 需求B 线程2 获得了B资源， 需求A 程序出现相持局面 -- 死锁 解决死锁：将资源A和B作为一个整体C，将C加锁相当于直接锁定了A和B，不会出现死锁问题了 尽可能的避免出现synchronized代码块嵌套，就有出现死锁的风险 wait和notify wait与sleep的区别？（重要） wait是让访问某个共享资源处于等待状态，wait方法必须在同步块或同步方法中使用 wait方法是继承自Object类 某个线程中，调用了共享资源的wait方法时，该线程会让出CPU的执行权和共享资源的锁 sleep是Thread类中的方法，让调用了该方法的线程处于休眠状态（占着CPU睡觉），不会释放其占有的锁 wait与notify wait和notify都必须在同步块或同步方法中使用，如果不是程序会报异常 wait让调用某个共享资源的线程处于等待状态 notify对调用某个共享资源的线程进行唤醒，等待-&gt;就绪 nofifyAll 对所有等待共享资源的线程同时进行唤醒 多个线程进入就绪 -&gt; 竞争 生产者与消费者模式（了解） 有n个生产线程负责生产某类产品，存入到一个空间中 有n个消费线程负责消费某类产品，从上述空间中取得 空间 -- 共享资源 生产者 -- 负责向共享资源存放内容的线程 消费者 -- 负责从共享资源取出内容的线程 " />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/c9b14984bfe8978b65ea91b494826170/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2017-05-02T18:53:15+08:00" />
<meta property="article:modified_time" content="2017-05-02T18:53:15+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">java_高级_多线程</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    进程：一个系统中可以“同时”运行多个程序，一个程序就是一个进程 
<br> 
<span style="white-space:pre"></span>线程：一个程序中可以“同时”运行多个功能，一个功能就是一个线程 
<br> 
<span style="white-space:pre"></span>     一个线程中可以“同时”运行多个其他线程 
<br> 
<br> 
<br> 
<br> 
<br> 
<span style="white-space:pre"></span>单核CPU  同一时间只能执行一个程序（一个进程中某个一个线程） 
<br> 
<span style="white-space:pre"></span>   轮转时间片 
<br> 
<br> 
<br> 
<br> 
<br>     多线程的创建方式（重要） 
<br> 
<span style="white-space:pre"></span>2种方式  类的对象就是一个多线程的对象 
<br> 
<span style="white-space:pre"></span>(1)某个类继承Thread类         
<span style="white-space:pre"> </span> 
<br> 
<span style="white-space:pre"></span>(2)某个类实现Runnable接口，并实现其中的run方法     
<br> 
<br> 
<br> 
<span style="white-space:pre"></span> 
<br> 
<br> 
<br> 
<br> 
<br>     线程的生命周期     
<br> 
<span style="white-space:pre"></span>多线程的启动不能调用run方法，如果通过调用run方法来执行多线程，这个就是普通方法 
<br> 
<span style="white-space:pre"></span>启动多线程需要调用Thread类中start方法，start方法会以多线程的方式启动run方法 
<br> 
<br> 
<br> 
<span style="white-space:pre"></span>参照图片理解 
<br> 
<br> 
<br> 
<br> 
<br>     多线程的控制 
<br> 
<span style="white-space:pre"></span>线程的休眠  -- 属于一种阻塞事件，让某个线程休眠一段时间 
<br> 
<span style="white-space:pre"></span>Thread.sleep(1000);让代码所属方法休眠1000ms 
<br> 
<br> 
<br> 
<span style="white-space:pre"></span>利用Runnable创建线程对象时的问题 
<br> 
<span style="white-space:pre"></span>如何启动线程？ 
<br> 
<br> 
<br> 
<span style="white-space:pre"></span>  
<span style="white-space:pre"> </span>Runnable r1 = new Runnable(); 
<br> 
<span style="white-space:pre"></span>Thread t1 = new Thread(r1); 
<br> 
<br> 
<br> 
<span style="white-space:pre"></span>t1.start();  -- 相当于启动了r1 
<br> 
<br> 
<br> 
<span style="white-space:pre"></span>使用Thread类还是Runnable接口创建多线程类，哪一种方式更好？ 
<br> 
<br> 
<br> 
<span style="white-space:pre"></span>Thread类的优势：提供了操作线程的方法，可以直接使用（比如start和stop） 
<br> 
<span style="white-space:pre"></span>Runnable接口的优势： 由于Java是单继承，Runnable不占据父类的位置，可以提供更好扩展性 
<br> 
<br> 
<br> 
<span style="white-space:pre"></span>个人认为Runnable更好，对系统来说提供了更好的扩展性 
<br> 
<br> 
<br> 
<br> 
<br>     同步与异步  
<br> 
<br> 
<br> 
<span style="white-space:pre"></span>线程不安全的产生原因 
<br> 
<span style="white-space:pre"></span>多个线程操作同一个资源时，操作过程中让出CPU执行权，此时数据处于修改不完善的状态， 
<br> 
<span style="white-space:pre"></span>下一个线程在进行操作时读取了没有修改完善的数据，造成了数据的错误 
<br> 
<span style="white-space:pre"></span>解决线程安全的主要方法是通过 同步关键字（也被称为锁） -- synchronized 
<br> 
<br> 
<br> 
<span style="white-space:pre"></span>synchronized可以修饰 方法和代码块，这样的方法或代码块中的代码，只允许一个线程完整访问后才可以交给下一个线程 
<br> 
<span style="white-space:pre"></span>同步方法：不明确锁定资源，锁定了整个方法的代码 
<br> 
<span style="white-space:pre"></span>同步块：可以明确指定锁定的资源，只同步需要同步的部分代码而不是整个方法 
<br> 
<br> 
<br> 
<span style="white-space:pre"></span>推荐使用同步块解决线程不安全的问题 
<br> 
<br> 
<br> 
<br> 
<br> 
<span style="white-space:pre"></span>使用了synchronized的代码被称为同步方式    -- 同一时间内某方法只能被一个对象使用 
<br> 
<span style="white-space:pre"></span>没有使用synchronized的多线程代码被称为异步方式   -- 同一时间内某方法可能被多个对象同时使用 
<br> 
<br> 
<br> 
<span style="white-space:pre"></span>在懒汉式单例中getInstance方法应该是一个线程安全的方法，否则多线程的环境中有可能单例对象被不同线程初始化多次   
<br> 
<br> 
<br> 
<span style="white-space:pre"></span>在Java中对比两种单例模式，个人推荐使用饿汉式单例       
<br> 
<br> 
<br> 
<br> 
<br>         死锁 
<br> 
<span style="white-space:pre"></span>共享资源 A B     A+B资源都获得以后才能完成目标 
<br> 
<span style="white-space:pre"></span> 
<br> 
<span style="white-space:pre"></span>线程1 获得了A资源， 需求B 
<br> 
<span style="white-space:pre"></span>线程2 获得了B资源， 需求A   程序出现相持局面 -- 死锁 
<br> 
<br> 
<br> 
<br> 
<br> 
<span style="white-space:pre"></span>解决死锁：将资源A和B作为一个整体C，将C加锁相当于直接锁定了A和B，不会出现死锁问题了 
<br> 
<br> 
<br> 
<span style="white-space:pre"></span>尽可能的避免出现synchronized代码块嵌套，就有出现死锁的风险 
<br> 
<br> 
<br> 
<span style="white-space:pre"></span>wait和notify 
<br> 
<br> 
<br> 
<span style="white-space:pre"></span>wait与sleep的区别？（重要） 
<br> 
<br> 
<br> 
<span style="white-space:pre"></span>wait是让访问某个共享资源处于等待状态，wait方法必须在同步块或同步方法中使用 
<br> 
<span style="white-space:pre"></span>wait方法是继承自Object类 
<br> 
<span style="white-space:pre"></span>某个线程中，调用了共享资源的wait方法时，该线程会让出CPU的执行权和共享资源的锁 
<br> 
<br> 
<br> 
<br> 
<br> 
<span style="white-space:pre"></span>sleep是Thread类中的方法，让调用了该方法的线程处于休眠状态（占着CPU睡觉），不会释放其占有的锁 
<br> 
<br> 
<br> 
<br> 
<br> 
<span style="white-space:pre"></span> 
<br> 
<span style="white-space:pre"></span>wait与notify 
<br> 
<span style="white-space:pre"></span>wait和notify都必须在同步块或同步方法中使用，如果不是程序会报异常 
<br> 
<span style="white-space:pre"></span>wait让调用某个共享资源的线程处于等待状态 
<br> 
<span style="white-space:pre"></span>notify对调用某个共享资源的线程进行唤醒，等待-&gt;就绪 
<br> 
<span style="white-space:pre"></span>nofifyAll 对所有等待共享资源的线程同时进行唤醒   多个线程进入就绪 -&gt; 竞争 
<br> 
<span style="white-space:pre"></span> 
<br> 
<br> 
<br> 
<br> 
<br> 
<span style="white-space:pre"></span>生产者与消费者模式（了解） 
<br> 
<span style="white-space:pre"></span>有n个生产线程负责生产某类产品，存入到一个空间中 
<br> 
<span style="white-space:pre"></span>有n个消费线程负责消费某类产品，从上述空间中取得 
<br> 
<br> 
<br> 
<span style="white-space:pre"></span>空间   --  共享资源 
<br> 
<br> 
<br> 
<span style="white-space:pre"></span>生产者   -- 负责向共享资源存放内容的线程 
<br> 
<span style="white-space:pre"></span>消费者   -- 负责从共享资源取出内容的线程
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/410ff9b413c3a846abb080095119c742/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">饭卡 01背包 &#43; 贪心</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/3b65da26cd0f61dfd43626603b1485ae/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">java_高级_网络编程</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>