<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>CIe系列专题之六：PCIe系统复位方式 - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="CIe系列专题之六：PCIe系统复位方式" />
<meta property="og:description" content="在PCIe Spec中，Reset总共分为两类：Conventional Reset和Function Level Reset.
1. Conventional Reset
从字面上来讲，Conventional Reset是传统的Reset方式。这一类Reset功能是在PCIe Spec 2.0之前的Spec中定义的，所以称为传统的Reset。PCIe设备必须要支持这一类Reset。
Convential Resets包含了三种Resets: Cold Reset，Warm Reset 和 Hot Reset.
另外，还有一个概念: Cold Reset和Warm Reset又被称为Fundamental Reset, Hot Reset被称为Non-Fundamental Reset.
什么是Fundamental Reset呢？
这是PCIe最基本的复位方式，主要通过硬件实现，效果是重置整个设备，对每个状态机、所有硬件逻辑、端口状态和配置寄存器重新初始化。
但是，也会有例外的情况：在某些寄存器中的字段只有在全部电源(包括VCC电源和Vaux备用电源)切断的情况下才会被重置。PCIe Spec给这些固执的字段起了个外号&#34;Sticky Bits&#34;.
一般来说，Fundamental Reset是针对整个系统做Reset，但是有时也可以针对某个单一设备进行重置。
在这里说明一下Fundamental Reset中的Cold Reset和Warm Reset。
Cold Reset: 设备的主电源VCC上电时，就会触发Cold Reset。
Warm Reset: 在VCC不断电的情况下，系统可以触发Warm Reset。比如，电源状态的变化就会触发Warm Reset. 不过，PCIe Spec并没有定义触发Warm Reset的具体方式，这部分可以有系统设计人员自行决定。
另外，在PCIe Spec中，规定了两种触发Fundamental Reset方式。
一是通过PERST#(PCIe Reset)信号控制。
二是在没哟PERST#信号的情况下，通过Power on/off的方式实现。
举个例子，看看PERST#是如何生成的。
系统上电稳定后，有POWERGOOD信号产生(下图红色框所示)。
当系统的南桥芯片(也就是图中的IO控制器ICH)收到POWERGOOD信号后，就会产生PERST#信号(下图绿色部分)，此时会引起Cold Reset。
如果系统可以通过非上电的方式触发PERST#信号，此时会引起Warm Reset。
明白了Fundamental Reset，那Non-Fundamental Reset中的Hot Reset又是什么呢？" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/f22c4b6b63dc1f0c545338aef005ccc6/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-10-01T16:07:37+08:00" />
<meta property="article:modified_time" content="2022-10-01T16:07:37+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">CIe系列专题之六：PCIe系统复位方式</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p>在PCIe Spec中，Reset总共分为两类：Conventional Reset和Function Level Reset.</p> 
<p></p> 
<p><strong>1. Conventional Reset</strong></p> 
<p>从字面上来讲，Conventional Reset是传统的Reset方式。这一类Reset功能是在PCIe Spec 2.0之前的Spec中定义的，所以称为传统的Reset。PCIe设备必须要支持这一类Reset。</p> 
<p></p> 
<p>Convential Resets包含了三种Resets: Cold Reset，Warm Reset 和 Hot Reset.</p> 
<p>另外，还有一个概念: Cold Reset和Warm Reset又被称为Fundamental Reset, Hot Reset被称为Non-Fundamental Reset.</p> 
<p></p> 
<p><strong>什么是Fundamental Reset呢？</strong></p> 
<p>这是PCIe最基本的复位方式，主要通过硬件实现，效果是重置整个设备，对每个状态机、所有硬件逻辑、端口状态和配置寄存器重新初始化。</p> 
<blockquote> 
 <p>但是，也会有例外的情况：在某些寄存器中的字段只有在全部电源(包括VCC电源和Vaux备用电源)切断的情况下才会被重置。PCIe Spec给这些固执的字段起了个外号"Sticky Bits".</p> 
</blockquote> 
<p></p> 
<p>一般来说，Fundamental Reset是针对整个系统做Reset，但是有时也可以针对某个单一设备进行重置。</p> 
<p></p> 
<p>在这里说明一下Fundamental Reset中的Cold Reset和Warm Reset。</p> 
<blockquote> 
 <ul><li> <p><strong>Cold Reset</strong>: 设备的主电源VCC上电时，就会触发Cold Reset。</p> </li><li> <p><strong>Warm Reset</strong>: 在VCC不断电的情况下，系统可以触发Warm Reset。比如，电源状态的变化就会触发Warm Reset. 不过，PCIe Spec并没有定义触发Warm Reset的具体方式，这部分可以有系统设计人员自行决定。</p> </li></ul> 
</blockquote> 
<p></p> 
<p>另外，在PCIe Spec中，规定了两种触发Fundamental Reset方式。</p> 
<blockquote> 
 <ul><li> <p>一是通过PERST#(PCIe Reset)信号控制。</p> </li><li> <p>二是在没哟PERST#信号的情况下，通过Power on/off的方式实现。</p> </li></ul> 
</blockquote> 
<p></p> 
<p>举个例子，看看PERST#是如何生成的。</p> 
<blockquote> 
 <ol><li> <p>系统上电稳定后，有POWERGOOD信号产生(下图红色框所示)。</p> </li><li> <p>当系统的南桥芯片(也就是图中的IO控制器ICH)收到POWERGOOD信号后，就会产生PERST#信号(下图绿色部分)，此时会引起Cold Reset。</p> </li><li> <p>如果系统可以通过非上电的方式触发PERST#信号，此时会引起Warm Reset。</p> </li></ol> 
 <p class="img-center"><img alt="" src="https://images2.imgbox.com/59/29/182Wgbvl_o.jpg"></p> 
</blockquote> 
<p></p> 
<p>明白了Fundamental Reset，<strong>那Non-Fundamental Reset中的Hot Reset又是什么呢？</strong></p> 
<p>与Fundatmental Reset相反，Hot Reset是一种软件控制的复位方式。PCIe设备出现错误时，通常情况下用软件的方式对设备重置。软件可以通过在Bridge control中设置Secondary Bus Reset bit来触发Hot Reset. </p> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/1d/05/SvfngfVX_o.jpg"></p> 
<p></p> 
<p>另外，在PCIe总线中，通过发送TS1序列，并且在TS1序列中设置Hot Reset bit来对下游设备进行Hot Reset(如下图红色框). </p> 
<blockquote> 
 <p>在这个过程中，发送端会持续发送TS1序列至2ms, 接收端在接到2个连续的TS1序列之后进行Hot Reset.</p> 
</blockquote> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/ed/42/6SPEMuAB_o.jpg"></p> 
<p></p> 
<p>同样，举个例子说明一下Hot Reset:</p> 
<blockquote> 
 <ol><li> <p>系统通过软件对Switch A左边端口的Secondary Bus Reset bit置为1(下图红色框)，触发了Hot Reset.</p> </li><li> <p>之后通过发送TS1序列对PCIe链路中的下游设备触发Hot Reset(下图黑色箭头).</p> </li></ol> 
 <p class="img-center"><img alt="" src="https://images2.imgbox.com/d3/b5/gMSXp16Q_o.jpg"></p> 
</blockquote> 
<p></p> 
<p><strong>2. Function Level Reset</strong></p> 
<p>在传统复位方式的基础上，PCIe Sepc 2.0以后开始增加了新的复位方式FLR(Function Level Reset)。前面讲到的传统复位方式(Cold Reset, Warm Reset, Hot Reset)均属于全局复位方式，而FLR的优势则是对局部复位。</p> 
<p></p> 
<p>在PCIe协议中，一个PCIe设备可能包含多个功能模块(Function)，每个功能模块相互对立，共用一个PCIe link。其中，某个功能模块出问题时，虽然可以采用传统复位方式对整个PCIe设备复位，但这个显然不友好，因为其他功能模块可能正在埋头苦干。这就好比如，在一个团体中，一个人犯错了，要团队所有人一起承担，这个肯定会影响团结呀。</p> 
<p></p> 
<p>所以，PCIe深得管理学的精髓，为了不影响团结，FLR允许只对其中出错的功能模块(Function)进行重置，其他功能模块正常工作。</p> 
<p></p> 
<p>不过，FLR复位方式对PCIe设备并不是必须的，在对PCIe设备使用FLR复位之前必须先检查是否支持FLR。这部分可以查看Device Capabilities Register是否将Funcion-Level Reset Capability bit置起。</p> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/bf/63/Kxa1Nn4p_o.jpg"></p> 
<p></p> 
<p>如果PCIe设备支持FLR，那么就可以通过设置Device Control Register中的Function-Level Reset bit触发FLR复位咯~</p> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/72/49/wMiIto00_o.jpg"></p> 
<p></p> 
<p>触发FLR之后，PCIe链路中都有哪些变化呢？</p> 
<p>我们前面提到了，FLR是一个局部复位方式，只对出问题的那个Function起作用。所以说，<strong>FLR只会改变当下Function内部的状态和寄存器的内容</strong>。以下几个方面不会被影响：</p> 
<blockquote> 
 <ul><li> <p>执行FLR的Function所在的<strong>PCIe链路状态</strong>不会改变，因为其他Function也在共用整条PCIe链路；</p> </li><li> <p><strong>Sticky Bits</strong>. 传统复位方式也无法改变Sticky bits,  除非完全断电。</p> </li><li> <p><strong>HwInit Bits</strong>. HwInit bits是硬件初始化的内容，这些值由芯片的配置引脚决定，后者上电复位后从EEPROM中获取。Cold和Warm Reset可以复位这些寄存器，然后从EEPROM中从新获取数据，但是使用FLR方式不能复位这些寄存器。</p> </li><li> <p><strong>与Link相关的寄存器</strong>。比如ASPM，Flow control等相应的寄存器。</p> </li></ul> 
</blockquote> 
<p></p> 
<p>另外，PCIe Sepc规定，某个Function的FLR必须在100ms之后完成。所以，PCIe Spec写了一封倡议书给要使用FLR复位方式的"人们"-软件：</p> 
<blockquote> 
 <p>为了创造一个温馨的FLR工作环境，请做到以下几点：</p> 
 <ul><li> <p>在FLR工作期间，请不要访问对应的Function；</p> </li><li> <p>清除所有的Command Register；</p> </li><li> <p>通过Polling Device Status Register中的Transaction Pending bit来确保之前请求的Compeletion报文已完成，或者确保后续不会再发送Compeletion报文。</p> </li><li> <p>触发FLR之后，请耐心等待至少100ms;</p> </li><li> <p>初始化Function的配置寄存器，让其正常工作。</p> </li></ul> 
</blockquote> 
<p></p> 
<p>在FLR执行的过程中，如果收到TLP或者Compeletions都会被默默的丢弃，而不会向系统报错。</p> 
<p></p> 
<p>举个栗子，看看FLR执行过程，</p> 
<blockquote> 
 <p>1. 如下图，这个PCIe设备中有两个功能模块：Function 0和Function 5. 此时，两个Functions依旧是互不干扰，认真工作，传输TLPs.</p> 
 <p class="img-center"><img alt="" src="https://images2.imgbox.com/b8/48/tOFfWoLO_o.jpg"></p> 
 <p>2. 之后，Function 5出了一些问题，需要做FLR。FLR之后，Function5中的之前的TLPs全部被清除。</p> 
 <p></p> 
 <p class="img-center"><img alt="" src="https://images2.imgbox.com/0b/2d/qy2uyoDW_o.jpg"></p> 
 <p>3. Function 5做FLR，并不影响Function 0，继续TLPs传输。如下图，3个TLPs正常传输完毕。</p> 
 <p></p> 
 <p class="img-center"><img alt="" src="https://images2.imgbox.com/d2/91/uzjZCb92_o.jpg"></p> 
</blockquote>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/f0eaa6a81009560929d8b8815779838d/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">win10调节键盘灵敏度的方法</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/2143702f7aa7ef551faef3a38637d24f/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">springboot&#43;redis&#43;thymeleaf实现集合的数据在前端显示</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>