<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>单页应用优化--懒加载 - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="单页应用优化--懒加载" />
<meta property="og:description" content="单页Web应用（single page web application，SPA）会一次性载入页面资源，利用本地计算能力渲染页面，提高页面切换速度与用户体验。由此带来了首屏加载缓慢耗时的诟病，这也是困扰前端开发工程师的一重大难题。
最近查阅了一些帖子，发现了一个极其强大的方法，其兼容性有待提高~~（但已有相关的的Polyfill方式）
按需加载 // 全部加载 import &#39;ccharts&#39; // 按需加载 只加载需要使用的组件 import &#39;echarts/lib/component/title&#39; import &#39;echarts/lib/component/tooltip&#39; import &#39;echarts/lib/component/legend&#39; import &#39;echarts/lib/chart/bar&#39; 可以减小组件加载的大小，节省网络带宽，从而提高响应速度！
异步加载组件 首先我们可以将应用拆成多个模块组件，然后异步加载组件。配合webpack代码分割使用，达到按需加载的效果（下述只简单陈述，不做详细讲解）。
补充，webpack有三种常用的代码分割方式：
入口起点：使用 entry 配置手动地分离代码。防止重复：使用 CommonsChunkPlugin 去重和分离 chunk。动态导入：通过模块的内联函数调用来分离代码。 // 同步方式 import search from &#39;@/views/search/search.vue&#39; // 异步方式 const search = (resolve) =&gt; require([&#39;@/views/search.vue&#39;], resolve) // ES6异步方式(推荐) const search = () =&gt; import(&#39;@/views/search.vue&#39;) 注意，webpack中需要配置相关信息
output: { path: &#39;/dist&#39;, filename: &#39;js/[name].[chunkhash].js&#39;, chunkFilename:&#39;js/[id].[chunkhash].js&#39; }, 注意，filename决定了bundle的名称。但是此选项不会影响那些「按需加载 chunk」的输出文件。对于这些文件，请使用 output.chunkFilename选项来控制输出。通过 loader 创建的文件也不受影响。在这种情况下，你必须尝试 loader 特定的可用选项。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/a57590b73513b9eae3f32c48d5f7e1ec/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2018-05-02T19:16:53+08:00" />
<meta property="article:modified_time" content="2018-05-02T19:16:53+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">单页应用优化--懒加载</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-light">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <blockquote> 
 <p>单页Web应用（single page web application，SPA）会一次性载入页面资源，利用本地计算能力渲染页面，提高页面切换速度与用户体验。由此带来了首屏加载缓慢耗时的诟病，这也是困扰前端开发工程师的一重大难题。</p> 
</blockquote> 
<p>最近查阅了一些帖子，发现了一个极其强大的方法，其兼容性有待提高~~（但已有相关的的Polyfill方式）</p> 
<h3 id="按需加载">按需加载</h3> 
<pre class="prettyprint"><code class="language-javascript hljs "><span class="hljs-comment">// 全部加载</span>
import <span class="hljs-string">'ccharts'</span>

<span class="hljs-comment">// 按需加载 只加载需要使用的组件</span>
import <span class="hljs-string">'echarts/lib/component/title'</span>
import <span class="hljs-string">'echarts/lib/component/tooltip'</span>
import <span class="hljs-string">'echarts/lib/component/legend'</span>
import <span class="hljs-string">'echarts/lib/chart/bar'</span></code></pre> 
<p>可以减小组件加载的大小，节省网络带宽，从而提高响应速度！</p> 
<h3 id="异步加载组件">异步加载组件</h3> 
<p>首先我们可以将应用拆成多个模块组件，然后异步加载组件。配合<a href="https://doc.webpack-china.org/guides/code-splitting/" rel="nofollow">webpack代码分割</a>使用，达到按需加载的效果（下述只简单陈述，不做详细讲解）。</p> 
<blockquote> 
 <p>补充，webpack有三种常用的代码分割方式：</p> 
 <ul><li>入口起点：使用 <a href="https://doc.webpack-china.org/configuration/entry-context" rel="nofollow"><code>entry</code></a> 配置手动地分离代码。</li><li>防止重复：使用 <a href="https://doc.webpack-china.org/plugins/commons-chunk-plugin" rel="nofollow"><code>CommonsChunkPlugin</code></a> 去重和分离 chunk。</li><li>动态导入：通过模块的内联函数调用来分离代码。</li></ul> 
</blockquote> 
<pre class="prettyprint"><code class="language-javascript hljs "><span class="hljs-comment">// 同步方式</span>
import search from <span class="hljs-string">'@/views/search/search.vue'</span>
<span class="hljs-comment">// 异步方式</span>
<span class="hljs-keyword">const</span> search = (resolve) =&gt; <span class="hljs-built_in">require</span>([<span class="hljs-string">'@/views/search.vue'</span>], resolve)
<span class="hljs-comment">// ES6异步方式(推荐)</span>
<span class="hljs-keyword">const</span> search = () =&gt; import(<span class="hljs-string">'@/views/search.vue'</span>)</code></pre> 
<p><strong>注意，webpack中需要配置相关信息</strong></p> 
<pre class="prettyprint"><code class="language-javascript hljs ">output: {
    path: <span class="hljs-string">'/dist'</span>,
    filename: <span class="hljs-string">'js/[name].[chunkhash].js'</span>, 
    chunkFilename:<span class="hljs-string">'js/[id].[chunkhash].js'</span> 
},</code></pre> 
<blockquote> 
 <p>注意，<code>filename</code>决定了bundle的名称。但是此选项不会影响那些「按需加载 chunk」的输出文件。对于这些文件，请使用 <a href="https://doc.webpack-china.org/configuration/output/#output-chunkfilename" rel="nofollow"><code>output.chunkFilename</code></a>选项来控制输出。通过 loader 创建的文件也不受影响。在这种情况下，你必须尝试 loader 特定的可用选项。</p> 
</blockquote> 
<h3 id="懒加载">懒加载</h3> 
<p>通过监听滚动条来判断是否在可视区域进行加载处理，<code>document.documentElement.clientHeight &gt; dom.getBoundingClientRect().top</code></p> 
<pre class="prettyprint"><code class="language-html hljs "><span class="hljs-tag">&lt;<span class="hljs-title">div</span> <span class="hljs-attribute">class</span>=<span class="hljs-value">"content"</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-title">span</span>&gt;</span>1<span class="hljs-tag">&lt;/<span class="hljs-title">span</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-title">div</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-title">div</span> <span class="hljs-attribute">class</span>=<span class="hljs-value">"content"</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-title">span</span>&gt;</span>2<span class="hljs-tag">&lt;/<span class="hljs-title">span</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-title">div</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-title">div</span> <span class="hljs-attribute">class</span>=<span class="hljs-value">"content"</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-title">span</span>&gt;</span>3<span class="hljs-tag">&lt;/<span class="hljs-title">span</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-title">div</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-title">div</span> <span class="hljs-attribute">class</span>=<span class="hljs-value">"content"</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-title">span</span>&gt;</span>4<span class="hljs-tag">&lt;/<span class="hljs-title">span</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-title">div</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-title">div</span> <span class="hljs-attribute">class</span>=<span class="hljs-value">"content"</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-title">span</span>&gt;</span>5<span class="hljs-tag">&lt;/<span class="hljs-title">span</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-title">div</span>&gt;</span></code></pre> 
<pre class="prettyprint"><code class="language-javascript hljs "><span class="hljs-keyword">const</span> imageAddress = <span class="hljs-string">'../images/'</span>
<span class="hljs-keyword">const</span> viewHeight = document.documentElement.clientHeight <span class="hljs-comment">// 可视区域的高度</span>

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">$</span><span class="hljs-params">(selector)</span> {<!-- --></span>
    <span class="hljs-keyword">return</span> <span class="hljs-built_in">Array</span>.from(document.querySelectorAll(selector))
}

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">lazyload</span> <span class="hljs-params">()</span> {<!-- --></span>
    <span class="hljs-comment">// 获取所有要进行懒加载的图片</span>
    $(<span class="hljs-string">'.content'</span>).forEach(item =&gt; {
        <span class="hljs-keyword">let</span> rect, imgSrc
        <span class="hljs-keyword">let</span> index = item.querySelector(<span class="hljs-string">'span'</span>).innerHTML
        <span class="hljs-comment">// 资源已加载，避免重复加载</span>
        <span class="hljs-keyword">if</span> (item.dataset.src !== <span class="hljs-string">''</span>) <span class="hljs-keyword">return</span>
        rect = item.getBoundingClientRect()
        <span class="hljs-comment">// 图片一进入可视区，动态加载</span>
        <span class="hljs-keyword">if</span> (rect.bottom &gt;= <span class="hljs-number">0</span> &amp;&amp; rect.top &lt; viewHeight) {
            imgSrc = `${imageAddress}${index}.jpg`
            item.dataset.src = imgSrc
            <span class="hljs-keyword">let</span> img = document.createElement(<span class="hljs-string">'img'</span>)
            img.src = imgSrc
            item.appendChild(img)
        }
    })
}
lazyload()
document.addEventListener(<span class="hljs-string">'scroll'</span>, lazyload)</code></pre> 
<p><strong>注意：要对已加载的资源进行标识，防止重复加载！</strong></p> 
<p>该方式通过监听到<code>scroll</code>事件后，调用目标元素（绿色方块）的<a href="https://developer.mozilla.org/en/docs/Web/API/Element/getBoundingClientRect" rel="nofollow"><code>getBoundingClientRect()</code></a>方法，得到它对应于视口信息，再判断是否在视口之内。这种方法的缺点是，由于<code>scroll</code>事件密集发生（当然可以使用节流函数进行相应处理），计算量很大，容易造成性能问题！</p> 
<h3 id="intersectionobserver">IntersectionObserver</h3> 
<p><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/IntersectionObserver" rel="nofollow">IntersectionObserver</a>接口为开发者提供了一种可以异步监听目标元素与其祖先或视窗(viewport)交叉状态的手段。该API 是<strong>异步的(降低了昂贵的DOM和样式查询开销、以及CPU、GPU能源成本)</strong>，不随着目标元素的滚动同步触发，对于理解元素的可见性以及实现DOM内容的预加载和延迟加载非常有用。</p> 
<pre class="prettyprint"><code class="language-javascript hljs ">IntersectionObserver((entries, observer) =&gt;{}, options)
<span class="hljs-comment">// 观察指定目标元素</span>
observer.observe(target);
<span class="hljs-comment">// 停止观察指定目标元素</span>
observer.unobserve(target);
<span class="hljs-comment">// 停止观察全部元素</span>
observer.disconnect();</code></pre> 
<p>entries为IntersectionObserverEntry对象，包含如下属性：</p> 
<blockquote> 
 <ul><li>time：可见性发生变化的时间，毫秒；</li><li>target：被观察的目标元素，DOM节点对象；</li><li>rootBounds：根元素的矩形区域的信息，<code>getBoundingClientRect()</code>方法的返回值，如果没有根元素（即直接相对于视口滚动），则返回<code>null</code>；</li><li>boundingClientRect：目标元素的矩形区域的信息；</li><li>intersectionRect：目标元素与视口（或根元素）的交叉区域的信息；</li><li>intersecttionRatio：目标元素的可见比例；</li></ul> 
</blockquote> 
<p>options为IntersectionObserverInit 对象，包含如下属性：</p> 
<blockquote> 
 <ul><li>root：指定目标元素所在的容器节点（即根元素）；</li><li>rootMargin：用来扩展或缩小<code>rootBounds</code>这个矩形的大小，从而影响<code>intersectionRect</code>交叉区域的大小；</li><li>threshold：决定了什么时候触发回调函数</li></ul> 
</blockquote> 
<pre class="prettyprint"><code class="language-javascript hljs "><span class="hljs-keyword">var</span> io = <span class="hljs-keyword">new</span> IntersectionObserver((entries) =&gt; {
    entries.forEach(entry =&gt; {
        <span class="hljs-keyword">let</span> {target, intersectionRatio} = entry
        console.log(target.tagName, intersectionRatio)
    })
}, {
    threshold: [<span class="hljs-number">0</span>, <span class="hljs-number">0.25</span>, <span class="hljs-number">0.5</span>, <span class="hljs-number">0.75</span>, <span class="hljs-number">1</span>]
})
<span class="hljs-comment">// 监听</span>
io.observe($(<span class="hljs-string">'.target'</span>))</code></pre> 
<p>class名称为‘target’的元素，在可见比例为[0, 0.25, 0.5, 0.75, 1]均会执行相关回调函数！</p> 
<p><strong>实现懒加载：</strong></p> 
<pre class="prettyprint"><code class="language-javascript hljs "><span class="hljs-keyword">var</span> io = <span class="hljs-keyword">new</span> IntersectionObserver((entries) =&gt; {
    entries.forEach(entry =&gt; {
        <span class="hljs-keyword">let</span> {target, intersectionRatio} = entry
        <span class="hljs-comment">// 目标元素的可见比例大于0</span>
        <span class="hljs-keyword">if</span> (intersectionRatio) {
            <span class="hljs-keyword">let</span> index = target.querySelector(<span class="hljs-string">'span'</span>).innerHTML
            <span class="hljs-keyword">let</span> img = document.createElement(<span class="hljs-string">'img'</span>)
            img.src = `${imageAddress}${index}.jpg`
            target.appendChild(img)
            <span class="hljs-comment">// 取消监听，防止重复加载</span>
            io.unobserve(target)
        }
    })
}, {
    threshold: [<span class="hljs-number">0</span>]
})
<span class="hljs-comment">// 监听</span>
$(<span class="hljs-string">'.content'</span>).forEach(element =&gt; {
    io.observe(element)
})</code></pre> 
<p>实例地址：<a href="https://github.com/381510688/practice/blob/master/javascript_test/lazyLoad.html">https://github.com/381510688/practice/blob/master/javascript_test/lazyLoad.html</a></p> 
<h3 id="兼容性">兼容性</h3> 
<p><img src="https://images2.imgbox.com/09/ff/WRKyKF8Y_o.jpg" alt="IntersectionObserver兼容性" title=""> <br> Github上提供了相关的Polyfill方式：<a href="https://github.com/w3c/IntersectionObserver/tree/master/polyfill">IntersectionObserver polyfill</a></p> 
<p><strong>参考地址：</strong></p> 
<ul><li><a href="https://www.w3.org/TR/intersection-observer/" rel="nofollow">https://www.w3.org/TR/intersection-observer/</a></li><li><a href="http://www.ruanyifeng.com/blog/2016/11/intersectionobserver_api.html" rel="nofollow">http://www.ruanyifeng.com/blog/2016/11/intersectionobserver_api.html</a></li><li><a href="https://github.com/xunleif2e/vue-lazy-component">https://github.com/xunleif2e/vue-lazy-component</a></li></ul>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/b7414ee1420a0283d1620bac21830277/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">RandomAccessSource not opened</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/247f17425556fd3cb152877bf4a900fe/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">链表基础知识总结</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>