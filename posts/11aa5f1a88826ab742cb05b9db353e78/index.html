<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>LM优化算法 - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="LM优化算法" />
<meta property="og:description" content="LM算法 理论知识梯度下降高斯牛顿Levenberg–Marquardt 算法框架算法的整体流程求解器update流程说明 算法实现头文件cpp 算法调用 LM优化算法，是一种非线性优化算法，其可以看作是梯度下降和高斯牛顿法的结合。综合了梯度下降对初值不敏感和高斯牛顿在最优值附近收敛速度快的特点。 本人非数学专业，且对算法理解可能不到位，详细的算法推导及各个优化算法之间的关系，非常推荐看METHODS FOR NON-LINEAR LEAST SQUARES PROBLEMS ，其介绍更详细也更专业。
以下简要介绍LM算法，然后给出opencv中有关的实现。
本文代码也是来自opencv相关代码，位置在opencv-master\modules\calib3d\src\calibration.cpp\cvFindExtrinsicCameraParams2()。
当然，有关LM算法的实现，在opencv的usac模块中有更为正式的实现，在该模块中，对许多算法进行了集成和优化，后续再进行研究。
理论知识 对于一个最小二乘问题，有：
F ( x ) = 1 2 ∑ i = 1 m ( f i ( x ) ) 2 f i ( x ) 为 残 差 F(x) = \frac12\sum_{i=1}^m(f_i(x))^2\\ f_i(x) 为残差 F(x)=21​i=1∑m​(fi​(x))2fi​(x)为残差
我们的目的是求解残差f(x)的一组系数，使目标函数（或代价函数）F(x)达到最小值。通常的做法是，给定一个初值x0，优化算法不断的迭代，产生x1,x2,…，最终收敛于X。
因此，在这个收敛的过程中，我们需要两样东西，即方向h和步长α
x k &#43; 1 = x k &#43; α h d h d 即 为 收 敛 的 方 向 α 即 为 收 敛 的 步 长 x_{k&#43;1} = x_k &#43; \alpha h_d \\ h_d即为收敛的方向 \\ \alpha即为收敛的步长 xk&#43;1​=xk​&#43;αhd​hd​即为收敛的方向α即为收敛的步长" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/11aa5f1a88826ab742cb05b9db353e78/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2021-08-07T19:19:00+08:00" />
<meta property="article:modified_time" content="2021-08-07T19:19:00+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">LM优化算法</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p></p> 
<div class="toc"> 
 <h4>LM算法</h4> 
 <ul><li><a href="#_10" rel="nofollow">理论知识</a></li><li><ul><li><ul><li><a href="#_28" rel="nofollow">梯度下降</a></li><li><a href="#_36" rel="nofollow">高斯牛顿</a></li><li><a href="#LevenbergMarquardt_44" rel="nofollow">Levenberg–Marquardt</a></li></ul> 
   </li><li><a href="#_58" rel="nofollow">算法框架</a></li><li><ul><li><a href="#_69" rel="nofollow">算法的整体流程</a></li><li><a href="#update_75" rel="nofollow">求解器update流程</a></li><li><a href="#_82" rel="nofollow">说明</a></li></ul> 
   </li><li><a href="#_88" rel="nofollow">算法实现</a></li><li><ul><li><ul><li><a href="#_92" rel="nofollow">头文件</a></li><li><a href="#cpp_165" rel="nofollow">cpp</a></li></ul> 
   </li></ul> 
   </li><li><a href="#_405" rel="nofollow">算法调用</a></li></ul> 
 </li></ul> 
</div> 
<br> LM优化算法，是一种非线性优化算法，其可以看作是梯度下降和高斯牛顿法的结合。综合了梯度下降对初值不敏感和高斯牛顿在最优值附近收敛速度快的特点。 
<p></p> 
<p>本人非数学专业，且对算法理解可能不到位，详细的算法推导及各个优化算法之间的关系，非常推荐看<strong>METHODS FOR NON-LINEAR LEAST SQUARES PROBLEMS</strong> ，其介绍更详细也更专业。</p> 
<p>以下简要介绍LM算法，然后给出opencv中有关的实现。</p> 
<p>本文代码也是来自opencv相关代码，位置在<code>opencv-master\modules\calib3d\src\calibration.cpp\cvFindExtrinsicCameraParams2()</code>。</p> 
<p>当然，有关LM算法的实现，在opencv的usac模块中有更为正式的实现，在该模块中，对许多算法进行了集成和优化，后续再进行研究。</p> 
<h2><a id="_10"></a>理论知识</h2> 
<p>对于一个最小二乘问题，有：</p> 
<p><span class="katex--display"><span class="katex-display"><span class="katex"><span class="katex-mathml"> 
      
       
        
        
          F 
         
        
          ( 
         
        
          x 
         
        
          ) 
         
        
          = 
         
         
         
           1 
          
         
           2 
          
         
         
         
           ∑ 
          
          
          
            i 
           
          
            = 
           
          
            1 
           
          
         
           m 
          
         
        
          ( 
         
         
         
           f 
          
         
           i 
          
         
        
          ( 
         
        
          x 
         
        
          ) 
         
         
         
           ) 
          
         
           2 
          
         
         
         
         
           f 
          
         
           i 
          
         
        
          ( 
         
        
          x 
         
        
          ) 
         
        
          为 
         
        
          残 
         
        
          差 
         
        
       
         F(x) = \frac12\sum_{i=1}^m(f_i(x))^2\\ f_i(x) 为残差 
        
       
     </span><span class="katex-html"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathdefault" style="margin-right: 0.13889em;">F</span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mclose">)</span><span class="mspace" style="margin-right: 0.277778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right: 0.277778em;"></span></span><span class="base"><span class="strut" style="height: 2.92907em; vertical-align: -1.27767em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 1.32144em;"><span class="" style="top: -2.314em;"><span class="pstrut" style="height: 3em;"></span><span class="mord">2</span></span><span class="" style="top: -3.23em;"><span class="pstrut" style="height: 3em;"></span><span class="frac-line" style="border-bottom-width: 0.04em;"></span></span><span class="" style="top: -3.677em;"><span class="pstrut" style="height: 3em;"></span><span class="mord">1</span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.686em;"><span class=""></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mspace" style="margin-right: 0.166667em;"></span><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 1.6514em;"><span class="" style="top: -1.87233em; margin-left: 0em;"><span class="pstrut" style="height: 3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mrel mtight">=</span><span class="mord mtight">1</span></span></span></span><span class="" style="top: -3.05001em;"><span class="pstrut" style="height: 3.05em;"></span><span class=""><span class="mop op-symbol large-op">∑</span></span></span><span class="" style="top: -4.30001em; margin-left: 0em;"><span class="pstrut" style="height: 3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">m</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 1.27767em;"><span class=""></span></span></span></span></span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault" style="margin-right: 0.10764em;">f</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.311664em;"><span class="" style="top: -2.55em; margin-left: -0.10764em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.15em;"><span class=""></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mclose">)</span><span class="mclose"><span class="mclose">)</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height: 0.864108em;"><span class="" style="top: -3.113em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span><span class="mspace newline"></span><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right: 0.10764em;">f</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.311664em;"><span class="" style="top: -2.55em; margin-left: -0.10764em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.15em;"><span class=""></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mclose">)</span><span class="mord cjk_fallback">为</span><span class="mord cjk_fallback">残</span><span class="mord cjk_fallback">差</span></span></span></span></span></span><br> 我们的目的是求解残差f(x)的一组系数，使目标函数（或代价函数）F(x)达到最小值。通常的做法是，给定一个初值x0，优化算法不断的迭代，产生x1,x2,…，最终收敛于X。</p> 
<p>因此，在这个收敛的过程中，我们需要两样东西，即方向h和步长α<br> <span class="katex--display"><span class="katex-display"><span class="katex"><span class="katex-mathml"> 
      
       
        
         
         
           x 
          
          
          
            k 
           
          
            + 
           
          
            1 
           
          
         
        
          = 
         
         
         
           x 
          
         
           k 
          
         
        
          + 
         
        
          α 
         
         
         
           h 
          
         
           d 
          
         
         
         
         
           h 
          
         
           d 
          
         
        
          即 
         
        
          为 
         
        
          收 
         
        
          敛 
         
        
          的 
         
        
          方 
         
        
          向 
         
         
        
          α 
         
        
          即 
         
        
          为 
         
        
          收 
         
        
          敛 
         
        
          的 
         
        
          步 
         
        
          长 
         
        
       
         x_{k+1} = x_k + \alpha h_d \\ h_d即为收敛的方向 \\ \alpha即为收敛的步长 
        
       
     </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.638891em; vertical-align: -0.208331em;"></span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.336108em;"><span class="" style="top: -2.55em; margin-left: 0em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right: 0.03148em;">k</span><span class="mbin mtight">+</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.208331em;"><span class=""></span></span></span></span></span></span><span class="mspace" style="margin-right: 0.277778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right: 0.277778em;"></span></span><span class="base"><span class="strut" style="height: 0.73333em; vertical-align: -0.15em;"></span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.336108em;"><span class="" style="top: -2.55em; margin-left: 0em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right: 0.03148em;">k</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.15em;"><span class=""></span></span></span></span></span></span><span class="mspace" style="margin-right: 0.222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right: 0.222222em;"></span></span><span class="base"><span class="strut" style="height: 0.84444em; vertical-align: -0.15em;"></span><span class="mord mathdefault" style="margin-right: 0.0037em;">α</span><span class="mord"><span class="mord mathdefault">h</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.336108em;"><span class="" style="top: -2.55em; margin-left: 0em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">d</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.15em;"><span class=""></span></span></span></span></span></span></span><span class="mspace newline"></span><span class="base"><span class="strut" style="height: 0.84444em; vertical-align: -0.15em;"></span><span class="mord"><span class="mord mathdefault">h</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.336108em;"><span class="" style="top: -2.55em; margin-left: 0em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">d</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.15em;"><span class=""></span></span></span></span></span></span><span class="mord cjk_fallback">即</span><span class="mord cjk_fallback">为</span><span class="mord cjk_fallback">收</span><span class="mord cjk_fallback">敛</span><span class="mord cjk_fallback">的</span><span class="mord cjk_fallback">方</span><span class="mord cjk_fallback">向</span></span><span class="mspace newline"></span><span class="base"><span class="strut" style="height: 0.43056em; vertical-align: 0em;"></span><span class="mord mathdefault" style="margin-right: 0.0037em;">α</span><span class="mord cjk_fallback">即</span><span class="mord cjk_fallback">为</span><span class="mord cjk_fallback">收</span><span class="mord cjk_fallback">敛</span><span class="mord cjk_fallback">的</span><span class="mord cjk_fallback">步</span><span class="mord cjk_fallback">长</span></span></span></span></span></span><br> 所以，我们看到的梯度下降、高斯牛顿以及本文说的LM算法，其思想都是一致的。</p> 
<h4><a id="_28"></a>梯度下降</h4> 
<p>这里给出梯度下降的公式，有：<br> <span class="katex--display"><span class="katex-display"><span class="katex"><span class="katex-mathml"> 
      
       
        
         
         
           x 
          
          
          
            k 
           
          
            + 
           
          
            1 
           
          
         
        
          = 
         
         
         
           x 
          
         
           k 
          
         
        
          − 
         
        
          α 
         
         
         
           F 
          
         
           ˙ 
          
         
        
          ( 
         
        
          x 
         
        
          ) 
         
         
         
         
           F 
          
         
           ˙ 
          
         
        
          ( 
         
        
          x 
         
        
          ) 
         
        
          为 
         
        
          F 
         
        
          ( 
         
        
          x 
         
        
          ) 
         
        
          一 
         
        
          阶 
         
        
          导 
         
        
          数 
         
        
       
         x_{k+1} = x_k - \alpha \dot{F}(x) \\ \dot{F}(x)为F(x)一阶导数 
        
       
     </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.638891em; vertical-align: -0.208331em;"></span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.336108em;"><span class="" style="top: -2.55em; margin-left: 0em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right: 0.03148em;">k</span><span class="mbin mtight">+</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.208331em;"><span class=""></span></span></span></span></span></span><span class="mspace" style="margin-right: 0.277778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right: 0.277778em;"></span></span><span class="base"><span class="strut" style="height: 0.73333em; vertical-align: -0.15em;"></span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.336108em;"><span class="" style="top: -2.55em; margin-left: 0em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right: 0.03148em;">k</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.15em;"><span class=""></span></span></span></span></span></span><span class="mspace" style="margin-right: 0.222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right: 0.222222em;"></span></span><span class="base"><span class="strut" style="height: 1.17019em; vertical-align: -0.25em;"></span><span class="mord mathdefault" style="margin-right: 0.0037em;">α</span><span class="mord accent"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height: 0.92019em;"><span class="" style="top: -3em;"><span class="pstrut" style="height: 3em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right: 0.13889em;">F</span></span></span><span class="" style="top: -3.25233em;"><span class="pstrut" style="height: 3em;"></span><span class="accent-body" style="left: -0.05555em;">˙</span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mclose">)</span></span><span class="mspace newline"></span><span class="base"><span class="strut" style="height: 1.17019em; vertical-align: -0.25em;"></span><span class="mord accent"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height: 0.92019em;"><span class="" style="top: -3em;"><span class="pstrut" style="height: 3em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right: 0.13889em;">F</span></span></span><span class="" style="top: -3.25233em;"><span class="pstrut" style="height: 3em;"></span><span class="accent-body" style="left: -0.05555em;">˙</span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mclose">)</span><span class="mord cjk_fallback">为</span><span class="mord mathdefault" style="margin-right: 0.13889em;">F</span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mclose">)</span><span class="mord cjk_fallback">一</span><span class="mord cjk_fallback">阶</span><span class="mord cjk_fallback">导</span><span class="mord cjk_fallback">数</span></span></span></span></span></span></p> 
<h4><a id="_36"></a>高斯牛顿</h4> 
<p>高斯牛顿是在牛顿迭代的基础上，用雅可比矩阵的平方来近似Hessian矩阵，求解起来将会更加高效（大多数情况下，Hessian矩阵太难求）。这样做的缺点就是，要求迭代初值必须在最优解附近，否则以上假设将不成立。这里给出其公式：<br> <span class="katex--display"><span class="katex-display"><span class="katex"><span class="katex-mathml"> 
      
       
        
         
         
           x 
          
          
          
            k 
           
          
            + 
           
          
            1 
           
          
         
        
          = 
         
         
         
           x 
          
         
           k 
          
         
        
          + 
         
        
          α 
         
         
         
           h 
          
          
          
            g 
           
          
            n 
           
          
         
         
         
         
           J 
          
         
           T 
          
         
        
          J 
         
         
         
           h 
          
          
          
            g 
           
          
            n 
           
          
         
        
          = 
         
        
          − 
         
         
         
           J 
          
         
           T 
          
         
        
          f 
         
         
        
       
         x_{k+1} = x_k + \alpha h_{gn} \\ J^TJh_{gn} = -J^Tf \\ 
        
       
     </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.638891em; vertical-align: -0.208331em;"></span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.336108em;"><span class="" style="top: -2.55em; margin-left: 0em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right: 0.03148em;">k</span><span class="mbin mtight">+</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.208331em;"><span class=""></span></span></span></span></span></span><span class="mspace" style="margin-right: 0.277778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right: 0.277778em;"></span></span><span class="base"><span class="strut" style="height: 0.73333em; vertical-align: -0.15em;"></span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.336108em;"><span class="" style="top: -2.55em; margin-left: 0em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right: 0.03148em;">k</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.15em;"><span class=""></span></span></span></span></span></span><span class="mspace" style="margin-right: 0.222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right: 0.222222em;"></span></span><span class="base"><span class="strut" style="height: 0.980548em; vertical-align: -0.286108em;"></span><span class="mord mathdefault" style="margin-right: 0.0037em;">α</span><span class="mord"><span class="mord mathdefault">h</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.151392em;"><span class="" style="top: -2.55em; margin-left: 0em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right: 0.03588em;">g</span><span class="mord mathdefault mtight">n</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.286108em;"><span class=""></span></span></span></span></span></span></span><span class="mspace newline"></span><span class="base"><span class="strut" style="height: 1.17744em; vertical-align: -0.286108em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right: 0.09618em;">J</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height: 0.891331em;"><span class="" style="top: -3.113em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right: 0.13889em;">T</span></span></span></span></span></span></span></span><span class="mord mathdefault" style="margin-right: 0.09618em;">J</span><span class="mord"><span class="mord mathdefault">h</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.151392em;"><span class="" style="top: -2.55em; margin-left: 0em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right: 0.03588em;">g</span><span class="mord mathdefault mtight">n</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.286108em;"><span class=""></span></span></span></span></span></span><span class="mspace" style="margin-right: 0.277778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right: 0.277778em;"></span></span><span class="base"><span class="strut" style="height: 1.08577em; vertical-align: -0.19444em;"></span><span class="mord">−</span><span class="mord"><span class="mord mathdefault" style="margin-right: 0.09618em;">J</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height: 0.891331em;"><span class="" style="top: -3.113em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right: 0.13889em;">T</span></span></span></span></span></span></span></span><span class="mord mathdefault" style="margin-right: 0.10764em;">f</span></span><span class="mspace newline"></span></span></span></span></span></p> 
<h4><a id="LevenbergMarquardt_44"></a>Levenberg–Marquardt</h4> 
<p>给出其公式：<br> <span class="katex--display"><span class="katex-display"><span class="katex"><span class="katex-mathml"> 
      
       
        
         
         
           x 
          
          
          
            k 
           
          
            + 
           
          
            1 
           
          
         
        
          = 
         
         
         
           x 
          
         
           k 
          
         
        
          + 
         
        
          α 
         
         
         
           h 
          
          
          
            l 
           
          
            m 
           
          
         
         
        
          ( 
         
         
         
           J 
          
         
           T 
          
         
        
          J 
         
        
          + 
         
        
          μ 
         
        
          I 
         
        
          ) 
         
         
         
           h 
          
          
          
            l 
           
          
            m 
           
          
         
        
          = 
         
        
          − 
         
         
         
           J 
          
         
           T 
          
         
        
          f 
         
        
       
         x_{k+1} = x_k + \alpha h_{lm} \\ (J^TJ + \mu I)h_{lm} = -J^Tf 
        
       
     </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.638891em; vertical-align: -0.208331em;"></span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.336108em;"><span class="" style="top: -2.55em; margin-left: 0em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right: 0.03148em;">k</span><span class="mbin mtight">+</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.208331em;"><span class=""></span></span></span></span></span></span><span class="mspace" style="margin-right: 0.277778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right: 0.277778em;"></span></span><span class="base"><span class="strut" style="height: 0.73333em; vertical-align: -0.15em;"></span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.336108em;"><span class="" style="top: -2.55em; margin-left: 0em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right: 0.03148em;">k</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.15em;"><span class=""></span></span></span></span></span></span><span class="mspace" style="margin-right: 0.222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right: 0.222222em;"></span></span><span class="base"><span class="strut" style="height: 0.84444em; vertical-align: -0.15em;"></span><span class="mord mathdefault" style="margin-right: 0.0037em;">α</span><span class="mord"><span class="mord mathdefault">h</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.336108em;"><span class="" style="top: -2.55em; margin-left: 0em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right: 0.01968em;">l</span><span class="mord mathdefault mtight">m</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.15em;"><span class=""></span></span></span></span></span></span></span><span class="mspace newline"></span><span class="base"><span class="strut" style="height: 1.14133em; vertical-align: -0.25em;"></span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault" style="margin-right: 0.09618em;">J</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height: 0.891331em;"><span class="" style="top: -3.113em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right: 0.13889em;">T</span></span></span></span></span></span></span></span><span class="mord mathdefault" style="margin-right: 0.09618em;">J</span><span class="mspace" style="margin-right: 0.222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right: 0.222222em;"></span></span><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathdefault">μ</span><span class="mord mathdefault" style="margin-right: 0.07847em;">I</span><span class="mclose">)</span><span class="mord"><span class="mord mathdefault">h</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.336108em;"><span class="" style="top: -2.55em; margin-left: 0em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right: 0.01968em;">l</span><span class="mord mathdefault mtight">m</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.15em;"><span class=""></span></span></span></span></span></span><span class="mspace" style="margin-right: 0.277778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right: 0.277778em;"></span></span><span class="base"><span class="strut" style="height: 1.08577em; vertical-align: -0.19444em;"></span><span class="mord">−</span><span class="mord"><span class="mord mathdefault" style="margin-right: 0.09618em;">J</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height: 0.891331em;"><span class="" style="top: -3.113em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right: 0.13889em;">T</span></span></span></span></span></span></span></span><span class="mord mathdefault" style="margin-right: 0.10764em;">f</span></span></span></span></span></span><br> 在有些情况下，JtJ不可逆，导致高斯牛顿无法使用。LM通过将JtJ加上一个μI（I为单位阵），保证了正规方程的左侧一定可逆。</p> 
<p>在算法实际的应用中，通过调节μ的大小，可以使算法在梯度下降和高斯牛顿两者之间切换，如：</p> 
<ul><li>使用较大的μ值，算法可以看作梯度下降，适合当前优化位置距离最优解较远的情况</li><li>使用较小的μ值，算法可以看作高斯牛顿，适合当前优化位置接近最优解。</li></ul> 
<h3><a id="_58"></a>算法框架</h3> 
<p>LM算法通过求解正规方程，得到每次迭代的步长和方向。因此，算法的主要目的是求解正规方程左右侧的项，然后通过SVD分解即可得到参数更新的步长及方向，即：</p> 
<ul><li>JtJ - 雅可比矩阵的转置与其自己相乘</li><li>JErr - 雅可比矩阵的转置与残差矩阵（向量）相乘</li></ul> 
<p>算法框架在外部计算雅可比矩阵和残差矩阵，然后在算法内部通过求解正规方程，得到每次参数更新的步长及方向。</p> 
<p>然后利用更新的参数，在外部计算残差，然后判断残差是否朝着收敛方向进行。</p> 
<h4><a id="_69"></a>算法的整体流程</h4> 
<p><img src="https://images2.imgbox.com/04/ff/xQWy3Ysl_o.png" alt="在这里插入图片描述"></p> 
<h4><a id="update_75"></a>求解器update流程</h4> 
<p>求解器updata()内部根据不同的状态进行相应的计算，具体流程如下：</p> 
<p><img src="https://images2.imgbox.com/44/1d/V77JAcis_o.png" alt="在这里插入图片描述"></p> 
<h4><a id="_82"></a>说明</h4> 
<ul><li>J表示雅可比矩阵</li><li>err表示残差矩阵</li><li>求解器内外同步表示求解器内部和外部相应的参数指向相同，便于在求解器外部进行雅可比矩阵和残差矩阵的计算</li></ul> 
<h3><a id="_88"></a>算法实现</h3> 
<p>算法的实现主要步骤都体现在上述流程图中。</p> 
<h5><a id="_92"></a>头文件</h5> 
<pre><code class="prism language-C++">#pragma once

#include &lt;iostream&gt;

#include "opencv2/core/types_c.h"
#include "opencv2/core/core_c.h"

using namespace cv;

struct Iteration
{
	int iters = 0;
	TermCriteria criteria = TermCriteria(0, 0, 0);
	int lamda_lg10 = 0;

};

class LevMarq
{
public:
	LevMarq();
	LevMarq(int nparams, int nerrs,
		TermCriteria criteria = TermCriteria(TermCriteria::EPS + TermCriteria::COUNT, 30, DBL_EPSILON), bool completeSymmFlag = false);
	~LevMarq();

	void clear();

	void initParam(Mat params);

	void init(int nparams, int nerrs,
		TermCriteria criteria = TermCriteria(TermCriteria::EPS + TermCriteria::COUNT, 30, DBL_EPSILON), bool completeSymmFlag = false);

	bool update(const CvMat*&amp; params, CvMat*&amp; J, CvMat*&amp; err);

	void step();

private:
	double m_lambda_lg10;

	enum {
		DONE,
		START,
		CALC_J,
		CHECK_ERR
	};

	int m_state;
	TermCriteria m_criteria;
	int m_iters;
	bool m_complete_symm_flag;
	double m_err_norm, m_prev_err_norm;
	int m_solver_method;

	const double m_log10 = log(10.);

	Ptr&lt;CvMat&gt; m_mask;
	Ptr&lt;CvMat&gt; m_params;
	Ptr&lt;CvMat&gt; m_prev_params;

	Ptr&lt;CvMat&gt; m_JtJ;
	Ptr&lt;CvMat&gt; m_JtErr;
	Ptr&lt;CvMat&gt; m_J;
	Ptr&lt;CvMat&gt; m_Err;

	Ptr&lt;CvMat&gt; m_avl_JtJ;
	Ptr&lt;CvMat&gt; m_avl_JtErr;
	Ptr&lt;CvMat&gt; m_avl_params;
};
</code></pre> 
<h5><a id="cpp_165"></a>cpp</h5> 
<pre><code class="prism language-C++">#include "LevMarq.h"

static void subMatrix(const cv::Mat&amp; src, cv::Mat&amp; dst, const std::vector&lt;uchar&gt;&amp; cols,
	const std::vector&lt;uchar&gt;&amp; rows) {
	int nonzeros_cols = cv::countNonZero(cols);
	cv::Mat tmp(src.rows, nonzeros_cols, CV_64FC1);

	for (int i = 0, j = 0; i &lt; (int)cols.size(); i++)
	{
		if (cols[i])
		{
			src.col(i).copyTo(tmp.col(j++));
		}
	}

	int nonzeros_rows = cv::countNonZero(rows);
	dst.create(nonzeros_rows, nonzeros_cols, CV_64FC1);
	for (int i = 0, j = 0; i &lt; (int)rows.size(); i++)
	{
		if (rows[i])
		{
			tmp.row(i).copyTo(dst.row(j++));
		}
	}
}

LevMarq::LevMarq()
{
	// only do some init
	m_lambda_lg10 = 0;
	m_state = DONE;
	m_criteria = TermCriteria(0, 0, 0);
	m_iters = 0;
	m_complete_symm_flag = false;
	m_err_norm = m_prev_err_norm = DBL_MAX;
	m_solver_method = DECOMP_SVD;
}

LevMarq::LevMarq(int nparams, int nerrs, TermCriteria criteria, bool completeSymmFlag)
{
	init(nparams, nerrs, criteria, completeSymmFlag);
}

LevMarq::~LevMarq()
{
	clear();
}

void LevMarq::clear()
{
	m_mask.release();
	m_params.release();
	m_prev_params.release();

	m_JtJ.release();
	m_JtErr.release();
	m_J.release();
	m_Err.release();

	m_avl_JtJ.release();
	m_avl_JtErr.release();
	m_avl_params.release();
}

void LevMarq::initParam(Mat params)
{
	if (params.empty())
		return;

	double* data = m_params-&gt;data.db;
	assert(params.cols == 1, "params dim must be N*1");
	for (int i = 0; i &lt; params.rows; i++)
	{
		data[i] = params.at&lt;double&gt;(i, 0);
	}
}

/// &lt;summary&gt;
/// create some mat used for store related
/// &lt;/summary&gt;
/// &lt;param name="nparams"&gt;the nums of parameters to be optimized&lt;/param&gt;
/// &lt;param name="nerrs"&gt;the nums of residual function&lt;/param&gt;
/// &lt;param name="criteria"&gt;condition of convergence &lt;/param&gt;
/// &lt;param name="completeSymmFlag"&gt;&lt;/param&gt;
void LevMarq::init(int nparams, int nerrs, TermCriteria criteria, bool completeSymmFlag)
{
	if (!m_params || m_params-&gt;rows != nparams || nerrs != (m_Err ? m_Err-&gt;rows : 0))
		clear();

	m_mask.reset(cvCreateMat(nparams, 1, CV_8U));
	cvSet(m_mask, cvScalarAll(1));
	m_prev_params.reset(cvCreateMat(nparams, 1, CV_64F));
	m_params.reset(cvCreateMat(nparams, 1, CV_64F));
	m_JtJ.reset(cvCreateMat(nparams, nparams, CV_64F));
	m_JtErr.reset(cvCreateMat(nparams, 1, CV_64F));

	if (nerrs &gt; 0)
	{
		m_J.reset(cvCreateMat(nerrs, nparams, CV_64F));
		m_Err.reset(cvCreateMat(nerrs, 1, CV_64F));
	}

	m_err_norm = m_prev_err_norm = DBL_MAX;
	m_lambda_lg10 = -3;
	m_criteria = criteria;
	if (m_criteria.type &amp; TermCriteria::COUNT)
	{
		m_criteria.maxCount = MIN(MAX(m_criteria.maxCount, 1), 100000);
	}
	else
	{
		m_criteria.maxCount = 30;
	}
	if (m_criteria.type &amp; TermCriteria::EPS)
	{
		m_criteria.epsilon = MAX(m_criteria.epsilon, 0);
	}
	else
	{
		m_criteria.epsilon = DBL_EPSILON;
	}
	m_state = START;
	m_iters = 0;
	m_complete_symm_flag = completeSymmFlag;
	m_solver_method = DECOMP_SVD;
}

bool LevMarq::update(const CvMat*&amp; params, CvMat*&amp; J, CvMat*&amp; err)
{
	J = err = 0;
	assert(!m_Err.empty());
	if (m_state == DONE)
	{
		params = m_params;
		return false;
	}
	if (m_state == START)
	{
		params = m_params;
		cvZero(m_J);
		cvZero(m_Err);
		J = m_J;
		err = m_Err;
		m_state = CALC_J;
		return true;
	}
	if (m_state == CALC_J)
	{
		cvMulTransposed(m_J, m_JtJ, 1);
		cvGEMM(m_J, m_Err, 1, 0, 0, m_JtErr, CV_GEMM_A_T);
		cvCopy(m_params, m_prev_params);
		step();

		if (m_iters == 0)
		{
			m_prev_err_norm = cvNorm(m_Err, 0, CV_L2);
		}
		params = m_params;
		cvZero(m_Err);
		err = m_Err;
		m_state = CHECK_ERR;
		return true;
	}

	assert(m_state == CHECK_ERR);
	m_err_norm = cvNorm(m_Err, 0, CV_L2);
	if (m_err_norm &gt; m_prev_err_norm)
	{
		if (++m_lambda_lg10 &lt;= 16)
		{
			step();

			params = m_params;
			cvZero(m_Err);
			err = m_Err;
			m_state = CHECK_ERR;
			return true;
		}
	}

	m_lambda_lg10 = MAX(m_lambda_lg10 - 1, -16);
	if (++m_iters &gt;= m_criteria.maxCount ||
		cvNorm(m_params, m_prev_params, CV_RELATIVE_L2) &lt;= m_criteria.epsilon)
	{
		std::cout &lt;&lt; "criteria.epsilon: " &lt;&lt; cvNorm(m_params, m_prev_params, CV_RELATIVE_L2) &lt;&lt; std::endl;
		params = m_params;
		m_state = DONE;
		return true;
	}
	params = m_params;
	m_prev_err_norm = m_err_norm;
	cvZero(m_J);
	cvZero(m_Err);
	J = m_J;
	err = m_Err;
	m_state = CALC_J;
	return true;
}

void LevMarq::step()
{
	double miu = exp(m_lambda_lg10 * m_log10);
	int _nparams = m_params-&gt;rows;

	Mat _JtJ = cvarrToMat(m_JtJ);
	Mat _mask = cvarrToMat(m_mask);

	int _avl_nparams = countNonZero(_mask);
	if (!m_avl_JtJ || m_avl_JtJ-&gt;rows != _avl_nparams)
	{
		m_avl_JtJ.reset(cvCreateMat(_avl_nparams, _avl_nparams, CV_64F));
		m_avl_JtErr.reset(cvCreateMat(_avl_nparams, 1, CV_64F));
		m_avl_params.reset(cvCreateMat(_avl_nparams, 1, CV_64F));
	}

	Mat _avl_JtJ = cvarrToMat(m_avl_JtJ);
	Mat _avl_JtErr = cvarrToMat(m_avl_JtErr);
	Mat_&lt;double&gt; _avl_params = cvarrToMat(m_avl_params);

	subMatrix(cvarrToMat(m_JtErr), _avl_JtErr, std::vector&lt;uchar&gt;(1, 1), _mask);
	subMatrix(_JtJ, _avl_JtJ, _mask, _mask);

	if (!m_Err)
		completeSymm(_avl_JtErr, m_complete_symm_flag);

	_avl_JtJ.diag() *= 1.0 + miu;
	std::cout &lt;&lt; miu &lt;&lt; std::endl;
	solve(_avl_JtJ, _avl_JtErr, _avl_params, m_solver_method);

	int j = 0;
	for (int i = 0; i &lt; _nparams; i++)
	{
		m_params-&gt;data.db[i] = m_prev_params-&gt;data.db[i] - (m_mask-&gt;data.ptr[i] ? _avl_params(j++) : 0);
	}
}
</code></pre> 
<h3><a id="_405"></a>算法调用</h3> 
<pre><code class="prism language-C++">double param[opt_num] = { 0,0 }; // k1 p1
CvMat _param = cvMat(opt_num, 1, CV_64F, param);
CvTermCriteria criteria = cvTermCriteria(CV_TERMCRIT_EPS + CV_TERMCRIT_ITER, 10000, DBL_EPSILON);
myCvLevMarq solver(opt_num, total, criteria);
solver.initParam(distCoffes.rowRange(Range(0,2)));

int cnt = 0;
for (;;)
{
    const CvMat* __param = 0;
    CvMat* J = 0, * err = 0;
    bool proceed = solver.update(__param, J, err);
    cvCopy(__param, &amp;_param); // 将优化的变量保存下来
    if (!proceed || !err)
        break;

    if (J)
    {
        // 计算雅可比矩阵和残差矩阵
    }
    else
    {
        //残差矩阵
    }
}
</code></pre>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/ec6338d7fdd90422e33baf3005de47bf/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">微信小程序点击事件</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/cec28c2747ff0b5f7486b91326d2dde2/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">图的深度优先（递归、栈实现）&amp;广度优先（队列）</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>