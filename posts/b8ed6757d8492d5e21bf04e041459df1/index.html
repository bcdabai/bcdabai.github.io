<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>数据结构 | 顺序表的基本实现 - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="数据结构 | 顺序表的基本实现" />
<meta property="og:description" content="学习教材：《数据结构——从概念到C&#43;&#43;实现》
分类专栏：数据结构与算法(C&#43;&#43;)
文章目录
前言
正文
1 顺序表概述
1.1 线性表的逻辑结构
1.2 线性表的顺序存储结构
2 顺序表实现
前言 最近刚在学习《数据结构与算法》，单纯地跟课、看书觉得并不能很好的掌握好这些知识点，所以决定尝试将学习的知识点归纳总结，也将其进行代码实现，强化对知识点的理解。即作为笔记、实践，又作为我的思路分享。因为初学，难免有不正确、不恰当之处，敬请指正！
正文 1 顺序表概述 线性表（linear list）简称表，是 n（ n≥0）个数据元素的有限序列，跟据存储结构的不同可以分为顺序表和链表。
线性表的顺序存储结构为顺序表（sequential list），其基本思路使用一段地址连续的存储单元依次存储线性表的数据元素，具有随机存取（random access）结构。
2 顺序表实现 先定义出顺序表类，成员变量实现顺序表存储结构，成员函数实现线性表的基本操作。由于线性表的数据元素类型不确定，采用C&#43;&#43;的模板机制，定义出模板类SeqList（本文类模板中的成员函数均使用类内声明、类外定义）。
// Sequential List const int MaxSize = 100; // 规定顺序表最多可以接受多少元素，可以跟据实际情况修改 template&lt;class DataType&gt; // 定义模板类SeqList class SeqList { public: // 建立空的顺序表 SeqList(); // 建立长度为length的顺序表 SeqList(DataType arr[],int length); // 析构函数 ~SeqList() {}; // 按位查找元素 DataType Get(int i); // 按值查找元素，返回元素序号 int Locate(DataType x); // 插入操作，在第i个位置插入值为x的元素 void Insert(int i, DataType x); // 删除操作，删除第i个元素 DataType Delect(int i); // 判断是否为空表 int Empty(); // 遍历操作，按序号依次输出各元素 void PrintList(); // 返回线性表长度 int Length(); private: DataType m_Arr[MaxSize]; int m_length; }; 2." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/b8ed6757d8492d5e21bf04e041459df1/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-07-24T13:07:57+08:00" />
<meta property="article:modified_time" content="2023-07-24T13:07:57+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">数据结构 | 顺序表的基本实现</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <blockquote> 
 <p>学习教材：《数据结构——从概念到C++实现》</p> 
 <p>分类专栏：数据结构与算法(C++)</p> 
</blockquote> 
<p id="main-toc"><strong>文章目录</strong></p> 
<p id="%E5%89%8D%E8%A8%80-toc" style="margin-left:0px;"><a href="#%E5%89%8D%E8%A8%80" rel="nofollow">前言</a></p> 
<p id="%E6%AD%A3%E6%96%87-toc" style="margin-left:0px;"><a href="#%E6%AD%A3%E6%96%87" rel="nofollow">正文</a></p> 
<p id="1%20%E9%A1%BA%E5%BA%8F%E8%A1%A8%E6%A6%82%E8%BF%B0-toc" style="margin-left:40px;"><a href="#1%20%E9%A1%BA%E5%BA%8F%E8%A1%A8%E6%A6%82%E8%BF%B0" rel="nofollow">1 顺序表概述</a></p> 
<p id="1.1%20%E7%BA%BF%E6%80%A7%E8%A1%A8%E7%9A%84%E9%80%BB%E8%BE%91%E7%BB%93%E6%9E%84-toc" style="margin-left:80px;"><a href="#1.1%20%E7%BA%BF%E6%80%A7%E8%A1%A8%E7%9A%84%E9%80%BB%E8%BE%91%E7%BB%93%E6%9E%84" rel="nofollow">1.1 线性表的逻辑结构</a></p> 
<p id="1.2%20%E7%BA%BF%E6%80%A7%E8%A1%A8%E7%9A%84%E9%A1%BA%E5%BA%8F%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84-toc" style="margin-left:80px;"><a href="#1.2%20%E7%BA%BF%E6%80%A7%E8%A1%A8%E7%9A%84%E9%A1%BA%E5%BA%8F%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84" rel="nofollow">1.2 线性表的顺序存储结构</a></p> 
<p id="2%20%E9%A1%BA%E5%BA%8F%E8%A1%A8%E5%AE%9E%E7%8E%B0-toc" style="margin-left:40px;"><a href="#2%20%E9%A1%BA%E5%BA%8F%E8%A1%A8%E5%AE%9E%E7%8E%B0" rel="nofollow">2 顺序表实现</a></p> 
<hr id="hr-toc"> 
<p></p> 
<h2 id="%E5%89%8D%E8%A8%80">前言</h2> 
<p>        最近刚在学习《数据结构与算法》，单纯地跟课、看书觉得并不能很好的掌握好这些知识点，所以决定尝试将学习的知识点归纳总结，也将其进行代码实现，强化对知识点的理解。即作为笔记、实践，又作为我的思路分享。因为初学，难免有不正确、不恰当之处，敬请指正！</p> 
<h2 id="%E6%AD%A3%E6%96%87"><strong>正文</strong></h2> 
<h3 id="1%20%E9%A1%BA%E5%BA%8F%E8%A1%A8%E6%A6%82%E8%BF%B0">1 顺序表概述</h3> 
<p>        线性表（linear list）简称表，是 n（ n≥0）个数据元素的<strong>有限</strong>序列，跟据存储结构的不同可以分为<strong>顺序表</strong>和<strong>链表</strong>。</p> 
<p>        线性表的顺序存储结构为<strong>顺序表</strong>（sequential list），其基本思路使用一段地址连续的存储单元依次存储线性表的数据元素，具有<strong>随机存取</strong>（random access）结构。</p> 
<h3 id="2%20%E9%A1%BA%E5%BA%8F%E8%A1%A8%E5%AE%9E%E7%8E%B0">2 顺序表实现</h3> 
<p>        先定义出顺序表类，成员变量实现顺序表存储结构，成员函数实现线性表的基本操作。由于线性表的数据元素类型不确定，采用C++的模板机制，定义出模板类SeqList（本文类模板中的成员函数均使用类内声明、类外定义）。</p> 
<pre><code class="language-cpp">// Sequential List
const int MaxSize = 100; // 规定顺序表最多可以接受多少元素，可以跟据实际情况修改
template&lt;class DataType&gt; // 定义模板类SeqList
class SeqList
{
public:
	// 建立空的顺序表
	SeqList(); 
	// 建立长度为length的顺序表
	SeqList(DataType arr[],int length);
	// 析构函数
	~SeqList() {};
	// 按位查找元素
	DataType Get(int i);
	// 按值查找元素，返回元素序号
	int Locate(DataType x);
	// 插入操作，在第i个位置插入值为x的元素
	void Insert(int i, DataType x);
	// 删除操作，删除第i个元素
	DataType Delect(int i);
	// 判断是否为空表
	int Empty();
	// 遍历操作，按序号依次输出各元素
	void PrintList();
	// 返回线性表长度
	int Length();

private:
	DataType m_Arr[MaxSize];
	int m_length;
};
</code></pre> 
<h4>2.1 建立空的顺序表</h4> 
<p>        在顺序表类中，成员函数m_length用于记录顺序表的长度，因此在建立空的顺序表时，只需要使用无参构造函数，将实例化对象的m_length置为0即可。</p> 
<pre><code class="language-cpp">// 建立空的顺序表
template&lt;class DataType&gt;
SeqList&lt;DataType&gt;::SeqList()
{
	this-&gt;m_length = 0;
}</code></pre> 
<h4>2.2 建立指定长度的顺序表</h4> 
<p>        建立指定长度的顺序表，需要给定的数据元素传入到顺序表中，并将传入元素个数作为顺序表的长度。将给定的数据元素存放在数组arr[ ]中，并将给定元素个数一并传入。通过使用有参构造函数，传入数组arr[ ]以及顺序表长度。</p> 
<p>        同时，为避免传入的给定数据元素个数超出前面设定的MaxSize导致程序异常，使用<strong>throw</strong>关键字来显式地抛出异常。</p> 
<pre><code class="language-cpp">// 建立长度为length的顺序表
template&lt;class DataType&gt;
SeqList&lt;DataType&gt;::SeqList(DataType arr[], int length)
{
	if (length &gt; MaxSize) throw"参数非法";
	for (int i = 0; i &lt; length; i++)
	{
		this-&gt;m_Arr[i] = arr[i];
	}
	this-&gt;m_length = length;
}</code></pre> 
<h4>2.3 析构函数</h4> 
<p>        顺序表时静态存储分配，在顺序表变量退出作用域时，自动释放改变了所占内存单元，故无须销毁，析构函数为空即可。</p> 
<h4>2.4 按位查找元素</h4> 
<p>        顺序表中第 i 个元素在数组中下标为 i-1 的位置，因此使用顺序表人员实现按位查找。</p> 
<pre><code class="language-cpp">// 按位查找元素
template&lt;class DataType&gt;
DataType SeqList&lt;DataType&gt;::Get(int i)
{
	if (i &gt; this-&gt;m_length || i &lt; 1) throw"参数非法";
	else return this-&gt;m_Arr[i - 1];
}</code></pre> 
<h4>2.5 按值查找元素</h4> 
<p>        在顺序表中按值操作，需要对顺序表中的元素依次进行比较，如果查到到相应的值，则将元素的序号（不是数组下标）返回；否则返回0，即查找失败。</p> 
<pre><code class="language-cpp">// 按值查找元素，返回元素序号
template&lt;class DataType&gt;
int SeqList&lt;DataType&gt;::Locate(DataType x)
{
	for (int i = 0; i &lt; this-&gt;m_length; i++)
	{
		if (this-&gt;m_Arr[i] == x)
			return (i + 1);
	}
	return 0;
}</code></pre> 
<h4>2.6 插入操作</h4> 
<p>        插入操作时，在表的第 i 个位置插入值为 x 的元素，将原有的第 i-1 个位置上的元素依次往后移动，使长度为 n 的顺序表的长度变为 n+1。</p> 
<p>        且为避免输入的 i 不符合要求（即不满足 1 ≤ i ≤ m_length），使用<strong>throw</strong>关键字来显式地抛出异常。</p> 
<pre><code class="language-cpp">// 插入操作，在第i个位置插入值为x的元素
template&lt;class DataType&gt;
void SeqList&lt;DataType&gt;::Insert(int i, DataType x)
{
	if (this-&gt;m_length == MaxSize) throw"上溢";
	if (i&lt;1 || i&gt;this-&gt;m_length) throw"插入位置错误";
	for (int j = this-&gt;m_length; j &gt;= i; j--)
	{
		this-&gt;m_Arr[j] = this-&gt;m_Arr[j - 1];
	}
	this-&gt;m_Arr[i - 1] = x;
	this-&gt;m_length++;
}</code></pre> 
<h4>2.7 删除操作</h4> 
<p>        删除操作时将表的第 i 个元素删除，使长度为 n 的顺序表变成长度为 n-1 的顺序表，且返回删除的元素的值。操作逻辑上，即将第i个元素删除后，后面的元素依次提到前面一个空出的位置上；顺序表长度也做了减1处理。</p> 
<p>        且为避免输入的 i 不符合要求（即不满足 1 ≤ i ≤ m_length），使用<strong>throw</strong>关键字来显式地抛出异常。</p> 
<pre><code class="language-cpp">template&lt;class DataType&gt;
DataType SeqList&lt;DataType&gt;::Delect(int i)
{
	DataType x;
	if (this-&gt;m_length == 0) throw"上溢";
	if (i&lt;1 || i&gt;this-&gt;m_length) throw"删除位置错误";
	x = this-&gt;m_Arr[i - 1];
	for (int j = i; j &lt; this-&gt;m_length; j++)
	{
		this-&gt;m_Arr[j - 1] = this-&gt;m_Arr[j];
	}
	this-&gt;m_length--;
	return x;
}</code></pre> 
<h4>2.8 判断空表</h4> 
<p>        顺序表类成员变量 m_length 中存储着顺序表的长度，判断空表操作只需判断长度 m_length 为0即可。</p> 
<pre><code class="language-cpp">// 判断是否为空表
template&lt;class DataType&gt;
int SeqList&lt;DataType&gt;::Empty()
{
	if (this-&gt;m_length != 0)
		return 1;
	else return 0;
}</code></pre> 
<h4>2.9 遍历操作</h4> 
<p>        在顺序表中，遍历操作即按下标一次输出各元素，因此使用循环语句实现。</p> 
<pre><code class="language-cpp">// 遍历操作，按序号依次输出各元素
template&lt;class DataType&gt;
void SeqList&lt;DataType&gt;::PrintList()
{
	for (int i = 0; i &lt; this-&gt;m_length; i++)
	{
		cout &lt;&lt; this-&gt;m_Arr[i] &lt;&lt; " " ;
	}
	cout &lt;&lt; endl;
}</code></pre> 
<h4>2.10 返回顺序表长度</h4> 
<p>        如判断空表中所述，返回顺序表长度同样只需返回成员函数 m_length 的值即可。</p> 
<pre><code class="language-cpp">template&lt;class DataType&gt;
int SeqList&lt;DataType&gt;::Length()
{
	return this-&gt;m_length;
}
</code></pre> 
<h3>3 全部代码</h3> 
<pre><code class="language-cpp">#pragma once
#include&lt;iostream&gt;
#include&lt;string&gt;
using namespace std;

// Sequential List
// 规定顺序表最多可以接受多少元素
const int MaxSize = 100;
template&lt;class DataType&gt; // 定义模板类SeqList
class SeqList
{
public:
	// 建立空的顺序表
	SeqList(); 
	// 建立长度为length的顺序表
	SeqList(DataType arr[],int length);
	// 析构函数
	~SeqList() {};
	// 按位查找元素
	DataType Get(int i);
	// 按值查找元素，返回元素序号
	int Locate(DataType x);
	// 插入操作，在第i个位置插入值为x的元素
	void Insert(int i, DataType x);
	// 删除操作，删除第i个元素
	DataType Delect(int i);
	// 判断是否为空表
	int Empty();
	// 遍历操作，按序号依次输出各元素
	void PrintList();
	// 返回线性表长度
	int Length();

private:
	DataType m_Arr[MaxSize];
	int m_length;
};

// 建立空的顺序表
template&lt;class DataType&gt;
SeqList&lt;DataType&gt;::SeqList()
{
	this-&gt;m_length = 0;
}

// 建立长度为length的顺序表
template&lt;class DataType&gt;
SeqList&lt;DataType&gt;::SeqList(DataType arr[], int length)
{
	if (length &gt; MaxSize) throw"参数非法";
	for (int i = 0; i &lt; length; i++)
	{
		this-&gt;m_Arr[i] = arr[i];
	}
	this-&gt;m_length = length;
}

// 按位查找元素
template&lt;class DataType&gt;
DataType SeqList&lt;DataType&gt;::Get(int i)
{
	if (i &gt; MaxSize || i &lt; 1) throw"参数非法";
	else return this-&gt;m_Arr[i - 1];
}

// 按值查找元素，返回元素序号
template&lt;class DataType&gt;
int SeqList&lt;DataType&gt;::Locate(DataType x)
{
	for (int i = 0; i &lt; this-&gt;m_length; i++)
	{
		if (this-&gt;m_Arr[i] == x)
			return (i + 1);
	}
	return 0;
}

// 插入操作，在第i个位置插入值为x的元素
template&lt;class DataType&gt;
void SeqList&lt;DataType&gt;::Insert(int i, DataType x)
{
	if (this-&gt;m_length == MaxSize) throw"上溢";
	if (i&lt;1 || i&gt;this-&gt;m_length) throw"插入位置错误";
	for (int j = this-&gt;m_length; j &gt;= i; j--)
	{
		this-&gt;m_Arr[j] = this-&gt;m_Arr[j - 1];
	}
	this-&gt;m_Arr[i - 1] = x;
	this-&gt;m_length++;
}

// 删除操作，删除第i个元素
template&lt;class DataType&gt;
DataType SeqList&lt;DataType&gt;::Delect(int i)
{
	DataType x;
	if (this-&gt;m_length == 0) throw"上溢";
	if (i&lt;1 || i&gt;this-&gt;m_length) throw"删除位置错误";
	x = this-&gt;m_Arr[i - 1];
	for (int j = i; j &lt; this-&gt;m_length; j++)
	{
		this-&gt;m_Arr[j - 1] = this-&gt;m_Arr[j];
	}
	this-&gt;m_length--;
	return x;
}
 
// 判断是否为空表
template&lt;class DataType&gt;
int SeqList&lt;DataType&gt;::Empty()
{
	if (this-&gt;m_length != 0)
		return 1;
	else return 0;
}

// 遍历操作，按序号依次输出各元素
template&lt;class DataType&gt;
void SeqList&lt;DataType&gt;::PrintList()
{
	for (int i = 0; i &lt; this-&gt;m_length; i++)
	{
		cout &lt;&lt; this-&gt;m_Arr[i] &lt;&lt; " " ;
	}
	cout &lt;&lt; endl;
}

template&lt;class DataType&gt;
int SeqList&lt;DataType&gt;::Length()
{
	return this-&gt;m_length;
}


// 测试代码
/*void test01()
{
	int r[5] = { 1,2,3,4,5 };
	SeqList&lt;int&gt; s(r, 5);
	cout &lt;&lt; "当前线性表的数据为： ";
	s.PrintList();

	cout &lt;&lt; "插入数据中......" &lt;&lt; endl;

	s.Insert(3, 7);
	cout &lt;&lt; "当前线性表的长度为：" &lt;&lt; s.Length() &lt;&lt; endl;
	cout &lt;&lt; "当前线性表的数据为： ";
	s.PrintList();

	int num = 0;
	cout &lt;&lt; "请输入查找的数据：" &lt;&lt; endl;
	cin &gt;&gt; num;
	int i = s.Locate(num);
	if (i == 0)cout &lt;&lt; "查找失败！！" &lt;&lt; endl;
	else cout &lt;&lt; "元素：" &lt;&lt; num &lt;&lt; "的位置为：" &lt;&lt; i &lt;&lt; endl;
	
	cout &lt;&lt; "请输入查找元素的序号：" &lt;&lt; endl;
	cin &gt;&gt; num;
	cout &lt;&lt; "第" &lt;&lt; num &lt;&lt; "个元素为：" &lt;&lt; s.Get(num) &lt;&lt; endl;

	cout &lt;&lt; "请输入要删除的元素序号：" &lt;&lt; endl;
	cin &gt;&gt; num;
	i = s.Delect(num);
	cout &lt;&lt; "删除的元素为：" &lt;&lt; i &lt;&lt; "，删除后线性表的数据为：" &lt;&lt; endl;
	s.PrintList();
}*/

int main()
{
	// test01(); // 测试代码
	return 0;
}</code></pre> 
<blockquote> 
 <p>初学数据结构与算法，若有不正确之处，敬请指正啦~</p> 
</blockquote>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/08fc8271723339fe182fe8c01bdb16df/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">【LeetCode热题100】打卡第43天：会议室II&amp;完全平方数</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/0584d6f94df1d064868c082124d78a71/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">SPI协议</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>