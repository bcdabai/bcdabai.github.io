<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>基于stm32f103的LM6029-12864液晶屏开发（代码资源地址在最后） - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="基于stm32f103的LM6029-12864液晶屏开发（代码资源地址在最后）" />
<meta property="og:description" content="《《《《《正文》》》》》
《前言》
本文主要介绍128x64点阵液晶屏的开发，本文是基于拓普微LM6029AC液晶模块显示屏开发的，兼容12864cog HFG12864-438液晶屏，驱动芯片为ST7565R ；通信串口采用4SPI；
《液晶模块》
首先来区别液晶模块和驱动芯片；
驱动芯片：其实我在《数码管是如何亮起来的？跟液晶屏又有什么关系？》这篇文章提过，因为128x64的com口以及seg口过多，如果使用单片机IO口直接驱动太费IO资源，二来IO口驱动能力也未必够；因此设计一款专门驱动128x64的芯片，这样使用spi等串口由单片机控制来实现对液晶屏的控制；
而液晶屏加驱动芯片以及一些必要的外围电路，留出单片机与驱动芯片的通信口的组合模块我们称为液晶模块；
《开发手册获取》
对于软件开发来讲，我们一般不太需要过多了解驱动芯片的手册，驱动芯片的手册更全面，也因此很多不是软件的知识，当然多了解总没错，往往只需要了解模块的开发手册，其实模块手册往往包含在驱动芯片手册里；只是模块手册写得已经足够软件开发的；
而模块手册，个人觉得只需了解下面几部分:
1、模块对外的接口定义
2、模块的命令
3、通信方式
驱动芯片手册 和 模块手册资源在最后下载；
1）通信方式：一般通信方式会有多种选择，往往通过硬件的IO电平组合来实现，我选择4SPI，需要P/S脚拉低；
对应实际模块需要焊接如下图：
传输时序：
黑色箭头的意思就是SCL由低拉高的时候，传输数据；
2）接口定义：这里唯一需要注意的就是当使用4SPI时，SCL为D6引脚，SI为D7引脚；RES是用来复位操作的，就是拉低一段时间，一般10ms，在驱动手册里有；CS1是片选；RS是控制传输的是命令数据还是显示数据；还有BLA背光控制脚；
3）模块命令：这个一般模块手册有；没有去找驱动手册；这个是总的命令表格，详细的我们在后面开发介绍；
《硬件接口》
使用stm32f103c8t6芯片，引脚接线如下：
《软件开发》
1）开发环境：这个自己解决！可参考以下文章
《STM32F103软件环境搭建（KEIL）》
2）SysTick延时函数：（网上到处都是）
《一文透析SYSTICK的寄存器》参考本文；
void Delay_Init(void);void Delay_us(uint32_t nus);void Delay_ms(uint32_t nms); 3）LCD驱动口初始化函数：
/**********硬件接口:BAL CS1 RST SID SCLK RS PA0 PA3 PA4 PA2 PA1 PA5********************/ /******************************************************************************* 函 数：* 功 能：LCD12864引脚初始化* 参 数：无* 返回值：无* 备 注：无*******************************************************************************/void LCD_GPIO_Init(void){ GPIO_InitTypeDef GPIO_InitStruct; RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA|RCC_APB2Periph_GPIOB,ENABLE); GPIO_InitStruct.GPIO_Pin = GPIO_Pin_5|GPIO_Pin_4|GPIO_Pin_3|GPIO_Pin_2|GPIO_Pin_1|GPIO_Pin_0; GPIO_InitStruct.GPIO_Mode=GPIO_Mode_Out_PP; //推挽输出 GPIO_InitStruct." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/08dd0a54b7436f20ef282e97b0d09eb9/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2021-11-05T10:17:49+08:00" />
<meta property="article:modified_time" content="2021-11-05T10:17:49+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">基于stm32f103的LM6029-12864液晶屏开发（代码资源地址在最后）</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p style="text-align:center;"><img alt="图片" src="https://images2.imgbox.com/80/c8/KQaPaqEb_o.png"></p> 
<hr> 
<p><strong>《《《《《正文》》》》》</strong></p> 
<hr> 
<p></p> 
<p><strong>《前言》</strong></p> 
<p><strong>本文主要介绍128x64点阵液晶屏的开发，本文是基于拓普微LM6029AC液晶模块显示屏开发的，兼容12864cog HFG12864-438液晶屏，驱动芯片为ST7565R ；通信串口采用4SPI；</strong></p> 
<p></p> 
<hr> 
<p></p> 
<p><strong><strong>《液晶模块》</strong></strong></p> 
<p><strong>首先来区别液晶模块和驱动芯片；</strong></p> 
<p><strong>驱动芯片：其实我在《</strong><a href="http://mp.weixin.qq.com/s?__biz=MzIzMDI2MjA2NA==&amp;mid=2247484864&amp;idx=1&amp;sn=aae663d38e393a0e6a8e3850c7e95b43&amp;chksm=e8b7519fdfc0d8894f50d626b1cd2cc770668172ea7f720b00589e2d5f9435c2689de5095994&amp;scene=21#wechat_redirect" rel="nofollow" title="数码管是如何亮起来的？跟液晶屏又有什么关系？">数码管是如何亮起来的？跟液晶屏又有什么关系？</a><strong>》这篇文章提过，因为128x64的com口以及seg口过多，如果使用单片机IO口直接驱动太费IO资源，二来IO口驱动能力也未必够；因此设计一款专门驱动128x64的芯片，这样使用spi等串口由单片机控制来实现对液晶屏的控制；</strong></p> 
<p><strong>而液晶屏加驱动芯片以及一些必要的外围电路，留出单片机与驱动芯片的通信口的组合模块我们称为液晶模块；</strong></p> 
<hr> 
<p></p> 
<p><strong><strong><strong>《开发手册获取》</strong></strong></strong></p> 
<p><strong>对于软件开发来讲，我们一般不太需要过多了解驱动芯片的手册，驱动芯片的手册更全面，也因此很多不是软件的知识，当然多了解总没错，往往只需要了解模块的开发手册，其实模块手册往往包含在驱动芯片手册里；只是模块手册写得已经足够软件开发的；</strong></p> 
<p><strong>而模块手册，个人觉得只需了解下面几部分:</strong></p> 
<p><strong>1、模块对外的接口定义</strong></p> 
<p><strong>2、模块的命令</strong></p> 
<p><strong>3、通信方式</strong></p> 
<p> </p> 
<p><strong>驱动芯片手册 和 模块手册资源在最后下载；</strong></p> 
<p></p> 
<p>1）通信方式：一般通信方式会有多种选择，往往通过硬件的IO电平组合来实现，我选择4SPI，需要P/S脚拉低；</p> 
<p style="text-align:center;"><img alt="图片" src="https://images2.imgbox.com/ce/a2/h5m08syj_o.png"></p> 
<p>对应实际模块需要焊接如下图：</p> 
<p style="text-align:center;"><img alt="图片" src="https://images2.imgbox.com/98/57/y239CKtB_o.png"></p> 
<p><br> 传输时序：</p> 
<p style="text-align:center;"><img alt="图片" src="https://images2.imgbox.com/9e/b9/85A00hUv_o.png"></p> 
<p>黑色箭头的意思就是SCL由低拉高的时候，传输数据；</p> 
<p></p> 
<p>2）接口定义：这里唯一需要注意的就是当使用4SPI时，SCL为D6引脚，SI为D7引脚；RES是用来复位操作的，就是拉低一段时间，一般10ms，在驱动手册里有；CS1是片选；RS是控制传输的是命令数据还是显示数据；还有BLA背光控制脚；</p> 
<p style="text-align:center;"><img alt="图片" src="https://images2.imgbox.com/52/94/fJRP5U6Q_o.png"></p> 
<p></p> 
<p>3）模块命令：这个一般模块手册有；没有去找驱动手册；这个是总的命令表格，详细的我们在后面开发介绍；</p> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/cf/1d/dS4rhnhm_o.png"></p> 
<p></p> 
<p> </p> 
<p><strong><strong><strong><strong>《硬件接口》</strong></strong></strong></strong></p> 
<p>使用stm32f103c8t6芯片，引脚接线如下：</p> 
<p style="text-align:center;"><img alt="图片" src="https://images2.imgbox.com/85/08/nisVB7RR_o.png"></p> 
<p></p> 
<hr> 
<p></p> 
<p><strong><strong><strong><strong>《软件开发》</strong></strong></strong></strong></p> 
<p style="text-align:center;"><img alt="图片" src="https://images2.imgbox.com/79/d7/0Nd0gMNj_o.png"></p> 
<p></p> 
<p>1）开发环境：这个自己解决！可参考以下文章</p> 
<p>《<a href="http://mp.weixin.qq.com/s?__biz=MzIzMDI2MjA2NA==&amp;mid=2247484536&amp;idx=2&amp;sn=7f94794b1c14ba922580c2e3a3817d88&amp;chksm=e8b75027dfc0d931d79f0d50e073e73dd3e751b80af3350835b0a449748ab6ac66eeada76909&amp;scene=21#wechat_redirect" rel="nofollow" title="STM32F103软件环境搭建（KEIL）">STM32F103软件环境搭建（KEIL）</a>》</p> 
<p></p> 
<p>2）SysTick延时函数：（网上到处都是）</p> 
<p>《<a href="http://mp.weixin.qq.com/s?__biz=MzIzMDI2MjA2NA==&amp;mid=2247484892&amp;idx=1&amp;sn=881c267bec385c0483cf70a63dd7743b&amp;chksm=e8b75183dfc0d895385264509c72fd113a3a1a86177549f5d59f48098ef5306496b906b015af&amp;scene=21#wechat_redirect" rel="nofollow" title="一文透析SYSTICK的寄存器">一文透析SYSTICK的寄存器</a>》参考本文；</p> 
<pre><code>void Delay_Init(void);</code><code>void Delay_us(uint32_t nus);</code><code>void Delay_ms(uint32_t nms);</code></pre> 
<p>3）LCD驱动口初始化函数：</p> 
<pre><code>/**********</code><code>硬件接口:</code><code>BAL  CS1  RST  SID   SCLK   RS</code>
<code>PA0  PA3  PA4  PA2   PA1    PA5</code><code>********************/</code>
<code>/******************************************************************************</code><code>* 函  数：</code><code>* 功  能：LCD12864引脚初始化</code><code>* 参  数：无</code><code>* 返回值：无</code><code>* 备  注：无</code><code>*******************************************************************************/</code><code>void LCD_GPIO_Init(void)</code><code>{<!-- --></code><code>  GPIO_InitTypeDef GPIO_InitStruct; </code><code>  </code><code>  RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA|RCC_APB2Periph_GPIOB,ENABLE);</code><code>  </code><code>  GPIO_InitStruct.GPIO_Pin = GPIO_Pin_5|GPIO_Pin_4|GPIO_Pin_3|GPIO_Pin_2|GPIO_Pin_1|GPIO_Pin_0;</code><code>  GPIO_InitStruct.GPIO_Mode=GPIO_Mode_Out_PP;       //推挽输出</code><code>  GPIO_InitStruct.GPIO_Speed=GPIO_Speed_50MHz;  </code><code>  GPIO_Init(GPIOA,&amp;GPIO_InitStruct);</code><code>}</code></pre> 
<p>并宏定义IO电平的操作函数：</p> 
<pre><code>/******************************************************************************</code><code>* 函  数：</code><code>* 功  能：IO口操作宏定义</code><code>* 参  数：电平：Bit_RESET表示输出低；Bit_SET表示输出高；</code><code>* 返回值：无</code><code>* 备  注：无</code><code>*******************************************************************************/</code>
<code>#define  BLA(x)  GPIO_WriteBit(GPIOA,GPIO_Pin_0,x)</code><code>#define  CS1(x)  GPIO_WriteBit(GPIOA,GPIO_Pin_3,x)</code><code>#define  RST(x)  GPIO_WriteBit(GPIOA,GPIO_Pin_4,x)</code><code>#define  SID(x)  GPIO_WriteBit(GPIOA,GPIO_Pin_2,x)</code><code>#define  SCLK(x) GPIO_WriteBit(GPIOA,GPIO_Pin_1,x)</code><code>#define  RS(x)   GPIO_WriteBit(GPIOA,GPIO_Pin_5,x)</code></pre> 
<p>4）4SPI发送8bit数据函数</p> 
<pre><code>/******************************************************************************</code><code>* 函  数：</code><code>* 功  能：LCD12864的4SPI发送8bit数据函数</code><code>* 参  数：数据</code><code>* 返回值：无</code><code>* 备  注：无</code><code>*******************************************************************************/</code><code>void SendByte(uint8_t dat)</code><code>{<!-- --></code><code>  uint8_t i; </code><code>  for(i = 0;i &lt; 8;i++)</code><code>  {<!-- --></code><code>    if((dat &lt;&lt; i) &amp; 0x80)  //0x80(1000 0000)  只会保留最高位</code><code>    {<!-- --></code><code>      SID(Bit_SET);           // 引脚输出高电平，代表发送1</code><code>    }</code><code>    else</code><code>    {<!-- --></code><code>      SID(Bit_RESET);         // 引脚输出低电平，代表发送0</code><code>    }</code>
<code>    SCLK(Bit_RESET);   //时钟线置低  允许SID变化</code><code>    Delay_us(5); //延时使数据写入</code><code>    SCLK(Bit_SET);   //拉高时钟，让从机读SID</code><code>  }   </code><code>}</code></pre> 
<p>5）写命令函数</p> 
<pre><code>/******************************************************************************</code><code>* 函  数：</code><code>* 功  能：LCD12864写命令函数</code><code>* 参  数：数据</code><code>* 返回值：无</code><code>* 备  注：无</code><code>*******************************************************************************/</code><code>void Lcd_WriteCmd(uint8_t cmd)</code><code>{<!-- --></code><code>  RS(Bit_RESET); //拉低表示命令</code><code>  Delay_ms(1);</code><code>  SendByte(cmd);</code><code>}</code></pre> 
<p>6）写数据函数</p> 
<pre><code>/******************************************************************************</code><code>* 函  数：</code><code>* 功  能：LCD12864写数据函数</code><code>* 参  数：数据</code><code>* 返回值：无</code><code>* 备  注：无</code><code>*******************************************************************************/</code><code>void Lcd_WriteData(uint8_t data)</code><code>{<!-- --></code><code>  RS(Bit_SET);//拉高表示数据</code><code>  Delay_ms(1);</code><code>  SendByte(data);</code><code>}</code></pre> 
<p>7）LCD12864初始化函数</p> 
<pre><code>/******************************************************************************</code><code>* 函  数：</code><code>* 功  能：LCD12864初始化函数</code><code>* 参  数：数据</code><code>* 返回值：无</code><code>* 备  注：无</code><code>*******************************************************************************/</code><code>void HFG12864_Init(void)</code><code>{<!-- --></code><code>  BLA(Bit_SET);   //打开背光</code><code>  CS1(Bit_RESET); //使能片选</code><code>  SID(Bit_SET);   //释放SID</code><code>  SCLK(Bit_SET);   //释放SCLK</code><code>  RST(Bit_RESET); //复位LCD</code><code>  Delay_ms(100);</code><code>  RST(Bit_SET);</code><code>  </code><code>  Lcd_WriteCmd(0xa0); //seg方向选择</code>
<code>  Lcd_WriteCmd(0xc8); //com方向选择</code>
<code>  Lcd_WriteCmd(0xa2); //偏压比设置</code><code>  Lcd_WriteCmd(0x2C);</code><code>  Lcd_WriteCmd(0x2e);</code>
<code>  Lcd_WriteCmd(0x2f);</code><code>  Lcd_WriteCmd(0xa6);</code><code>  Lcd_WriteCmd(0x24);</code><code>  Lcd_WriteCmd(0x81); //对比度电流量设置</code><code>  </code><code>  Lcd_WriteCmd(0x20); //对比度电流量设置</code><code>  //Delay_ms(100);</code><code>  Lcd_WriteCmd(0xAF); //开显示</code>
<code>  //Lcd_WriteCmd(0xa5); //开显示</code><code>  //Delay_ms(10);</code><code>}</code></pre> 
<p>8）设置显示页函数</p> 
<pre><code>/******************************************************************************</code><code>* 函  数：</code><code>* 功  能：设置显示页函数</code><code>* 参  数：页数</code><code>* 返回值：无</code><code>* 备  注：无</code><code>*******************************************************************************/</code><code>void HFG12864_SetPage(uint8_t page)</code><code>{<!-- --></code><code>  page = page&amp;0x0F;</code><code>  page = page|0xB0;</code><code>  Lcd_WriteCmd(page);</code><code>}</code></pre> 
<p>9）设置显示列函数</p> 
<pre><code>/******************************************************************************</code><code>* 函  数：</code><code>* 功  能：设置显示列函数</code><code>* 参  数：列数</code><code>* 返回值：无</code><code>* 备  注：无</code><code>*******************************************************************************/</code><code>void HFG12864_SetColumn(uint8_t column)</code><code>{<!-- --></code><code>  uint8_t tmp;</code><code>  tmp = column;</code><code>  </code><code>  column = column&amp;0x0F;</code><code>  column = column|0x00;</code><code>  Lcd_WriteCmd(column);</code><code>  tmp = tmp&gt;&gt;4;</code><code>  column = tmp&amp;0x0F;</code><code>  column = column|0x10;</code><code>  Lcd_WriteCmd(column);</code><code>}</code></pre> 
<p>10）清屏函数</p> 
<pre><code>/******************************************************************************</code><code>* 函  数：</code><code>* 功  能：清屏函数</code><code>* 参  数：无</code><code>* 返回值：无</code><code>* 备  注：无</code><code>*******************************************************************************/</code><code>void HFG12864_ClearScr(void)</code><code>{<!-- --></code><code>  uint8_t i,j;</code><code>  for(i=0;i&lt;8;i++)</code><code>  {<!-- --></code><code>    HFG12864_SetPage(i);</code><code>    HFG12864_SetColumn(0);</code><code>    </code><code>    for(j=0;j&lt;128;j++)</code><code>    {<!-- --></code><code>      Lcd_WriteData(0x00);</code><code>    }</code><code>  }</code><code>}</code></pre> 
<p></p> 
<p><strong><strong><strong><strong><strong>《测试效果》</strong></strong></strong></strong></strong></p> 
<p>我把清屏函数数据改为0x0f；</p> 
<p>效果如下：</p> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/9d/2e/GbF1two5_o.png"></p> 
<p> </p> 
<p><strong>资源获取：</strong></p> 
<p>链接：https://pan.baidu.com/s/1ZHrAEaiJ6g7Z6Rb7UHLpgw </p> 
<p><strong>关注公众号，发送1234获取提取码；</strong></p> 
<p></p> 
<p><strong>《《《《《END》》》》》</strong></p> 
<p style="text-align:center;"><img alt="图片" src="https://images2.imgbox.com/be/49/zcpliDAr_o.png"></p> 
<p> </p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/e73354e71543d84f7213c9ff71d6175b/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">el-input 首尾不能为空格的校验</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/16b387f63fb659bd0143f069d3baf2eb/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">pix2pix解析以及pytorch实现</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>