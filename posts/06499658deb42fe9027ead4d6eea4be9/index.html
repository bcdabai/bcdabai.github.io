<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>PyTorch深度学习入门 - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="PyTorch深度学习入门" />
<meta property="og:description" content="目录
Python学习中的两大法宝函数（也可用于PyTorch）
理解Package结构及法宝函数的作用
实战运用两大法宝函数
PyCharm及Jupyter使用及对比
PyTorch加载数据
Dataset类代码实战
TensorBoard的使用 1、TensorBoard的安装
2、add_scalar()的使用(常用来绘制train/val loss)​编辑
3、add_image()的使用(常用来观察训练结果)
Transforms的使用 1、transforms用于对图形进行变换
2、常见的Transforms
1）transforms.ToTensor()
2）transforms.Composes（）
3）transforms.Normalize（）
4）transforms.Resize（）
4）transforms.RandomCrop（）
torchvision中的数据集使用
DataLoader的使用
神经网络的基本骨架：nn.Module的使用
卷积操作
神经网络-卷积层
神经网络-最大池化的使用
神经网络-非线性激活
神经网络-线性层及其他层介绍
神经网络-搭建小实战和Sequential的使用
损失函数与反向传播
优化器
现有网络模型的使用及修改
网络模型的保存与读取
完整的模型训练套路
利用GPU训练
方式一：
方式二：
完整的模型验证（测试，demo）套路
看看开源项目
Python学习中的两大法宝函数（也可用于PyTorch） 理解Package结构及法宝函数的作用 1.名称是pytorch的package
2、法宝函数
实战运用两大法宝函数 dir（）
help（）
eg.dir（torch）
help（torch.cuda.is_avaliable()）注意：没有这个括号！
PyCharm及Jupyter使用及对比 pycharm控制台：回车——运行，shift&#43;回车——换行
Jupyter：回车——换行，shift&#43;回车——运行
PyTorch加载数据 数据集的组成形式：
（1）文件夹名称为这个文件夹内所有图片所对应的lable
（2）图片和lable对应两个文件夹
（3）图片的名称为这张图片所对应的lable
读取数据：
Dataset类代码实战 python控制台
Dataset类代码实战见read_data.python文件
TensorBoard的使用 1、TensorBoard的安装 图像变换，即transform的使用。想要演示transform结果，运行完一个对应的方法，需要展示这个图像，就需要用到TensorBoard，探究不同阶段模型的输出。
用help（）可以查看这个类SummaryWriter，在PyCharm中可以按Ctrl，然后点击SummaryWriter去查看
2、add_scalar()的使用(常用来绘制train/val loss)
from tensorboardX import SummaryWriter #从这个工具包（tensorboardX）导入这个类（SummaryWriter） writer = SummaryWriter(&#34;" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/06499658deb42fe9027ead4d6eea4be9/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-11-24T14:19:44+08:00" />
<meta property="article:modified_time" content="2023-11-24T14:19:44+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">PyTorch深度学习入门</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p id="main-toc"><strong>目录</strong></p> 
<p id="Python%E5%AD%A6%E4%B9%A0%E4%B8%AD%E7%9A%84%E4%B8%A4%E5%A4%A7%E6%B3%95%E5%AE%9D%E5%87%BD%E6%95%B0%EF%BC%88%E4%B9%9F%E5%8F%AF%E7%94%A8%E4%BA%8EPyTorch%EF%BC%89-toc" style="margin-left:0px;"><a href="#Python%E5%AD%A6%E4%B9%A0%E4%B8%AD%E7%9A%84%E4%B8%A4%E5%A4%A7%E6%B3%95%E5%AE%9D%E5%87%BD%E6%95%B0%EF%BC%88%E4%B9%9F%E5%8F%AF%E7%94%A8%E4%BA%8EPyTorch%EF%BC%89" rel="nofollow">Python学习中的两大法宝函数（也可用于PyTorch）</a></p> 
<p id="%E7%90%86%E8%A7%A3Package%E7%BB%93%E6%9E%84%E5%8F%8A%E6%B3%95%E5%AE%9D%E5%87%BD%E6%95%B0%E7%9A%84%E4%BD%9C%E7%94%A8-toc" style="margin-left:40px;"><a href="#%E7%90%86%E8%A7%A3Package%E7%BB%93%E6%9E%84%E5%8F%8A%E6%B3%95%E5%AE%9D%E5%87%BD%E6%95%B0%E7%9A%84%E4%BD%9C%E7%94%A8" rel="nofollow">理解Package结构及法宝函数的作用</a></p> 
<p id="%E5%AE%9E%E6%88%98%E8%BF%90%E7%94%A8%E4%B8%A4%E5%A4%A7%E6%B3%95%E5%AE%9D%E5%87%BD%E6%95%B0-toc" style="margin-left:40px;"><a href="#%E5%AE%9E%E6%88%98%E8%BF%90%E7%94%A8%E4%B8%A4%E5%A4%A7%E6%B3%95%E5%AE%9D%E5%87%BD%E6%95%B0" rel="nofollow">实战运用两大法宝函数</a></p> 
<p id="PyCharm%E5%8F%8AJupyter%E4%BD%BF%E7%94%A8%E5%8F%8A%E5%AF%B9%E6%AF%94-toc" style="margin-left:0px;"><a href="#PyCharm%E5%8F%8AJupyter%E4%BD%BF%E7%94%A8%E5%8F%8A%E5%AF%B9%E6%AF%94" rel="nofollow">PyCharm及Jupyter使用及对比</a></p> 
<p id="PyTorch%E5%8A%A0%E8%BD%BD%E6%95%B0%E6%8D%AE-toc" style="margin-left:0px;"><a href="#PyTorch%E5%8A%A0%E8%BD%BD%E6%95%B0%E6%8D%AE" rel="nofollow">PyTorch加载数据</a></p> 
<p id="Dataset%E7%B1%BB%E4%BB%A3%E7%A0%81%E5%AE%9E%E6%88%98-toc" style="margin-left:0px;"><a href="#Dataset%E7%B1%BB%E4%BB%A3%E7%A0%81%E5%AE%9E%E6%88%98" rel="nofollow">Dataset类代码实战</a></p> 
<p id="TensorBoard%E7%9A%84%E4%BD%BF%E7%94%A8%C2%A0-toc" style="margin-left:0px;"><a href="#TensorBoard%E7%9A%84%E4%BD%BF%E7%94%A8%C2%A0" rel="nofollow">TensorBoard的使用 </a></p> 
<p id="1%E3%80%81TensorBoard%E7%9A%84%E5%AE%89%E8%A3%85-toc" style="margin-left:40px;"><a href="#1%E3%80%81TensorBoard%E7%9A%84%E5%AE%89%E8%A3%85" rel="nofollow">1、TensorBoard的安装</a></p> 
<p id="2%E3%80%81add_scalar()%E7%9A%84%E4%BD%BF%E7%94%A8(%E5%B8%B8%E7%94%A8%E6%9D%A5%E7%BB%98%E5%88%B6train%2Fval%20loss)%E2%80%8B%E7%BC%96%E8%BE%91-toc" style="margin-left:40px;"><a href="#2%E3%80%81add_scalar%28%29%E7%9A%84%E4%BD%BF%E7%94%A8%28%E5%B8%B8%E7%94%A8%E6%9D%A5%E7%BB%98%E5%88%B6train%2Fval%20loss%29%E2%80%8B%E7%BC%96%E8%BE%91" rel="nofollow">2、add_scalar()的使用(常用来绘制train/val loss)​编辑</a></p> 
<p id="3%E3%80%81add_image()%E7%9A%84%E4%BD%BF%E7%94%A8(%E5%B8%B8%E7%94%A8%E6%9D%A5%E8%A7%82%E5%AF%9F%E8%AE%AD%E7%BB%83%E7%BB%93%E6%9E%9C)-toc" style="margin-left:40px;"><a href="#3%E3%80%81add_image%28%29%E7%9A%84%E4%BD%BF%E7%94%A8%28%E5%B8%B8%E7%94%A8%E6%9D%A5%E8%A7%82%E5%AF%9F%E8%AE%AD%E7%BB%83%E7%BB%93%E6%9E%9C%29" rel="nofollow">3、add_image()的使用(常用来观察训练结果)</a></p> 
<p id="Transforms%E7%9A%84%E4%BD%BF%E7%94%A8%C2%A0-toc" style="margin-left:0px;"><a href="#Transforms%E7%9A%84%E4%BD%BF%E7%94%A8%C2%A0" rel="nofollow">Transforms的使用 </a></p> 
<p id="1%E3%80%81transforms%E7%94%A8%E4%BA%8E%E5%AF%B9%E5%9B%BE%E5%BD%A2%E8%BF%9B%E8%A1%8C%E5%8F%98%E6%8D%A2-toc" style="margin-left:40px;"><a href="#1%E3%80%81transforms%E7%94%A8%E4%BA%8E%E5%AF%B9%E5%9B%BE%E5%BD%A2%E8%BF%9B%E8%A1%8C%E5%8F%98%E6%8D%A2" rel="nofollow">1、transforms用于对图形进行变换</a></p> 
<p id="2%E3%80%81%E5%B8%B8%E8%A7%81%E7%9A%84Transforms-toc" style="margin-left:40px;"><a href="#2%E3%80%81%E5%B8%B8%E8%A7%81%E7%9A%84Transforms" rel="nofollow">2、常见的Transforms</a></p> 
<p id="1%EF%BC%89transforms.ToTensor()-toc" style="margin-left:80px;"><a href="#1%EF%BC%89transforms.ToTensor%28%29" rel="nofollow">1）transforms.ToTensor()</a></p> 
<p id="2%EF%BC%89transforms.Composes%EF%BC%88%EF%BC%89-toc" style="margin-left:80px;"><a href="#2%EF%BC%89transforms.Composes%EF%BC%88%EF%BC%89" rel="nofollow">2）transforms.Composes（）</a></p> 
<p id="3%EF%BC%89transforms.Normalize%EF%BC%88%EF%BC%89-toc" style="margin-left:80px;"><a href="#3%EF%BC%89transforms.Normalize%EF%BC%88%EF%BC%89" rel="nofollow">3）transforms.Normalize（）</a></p> 
<p id="4%EF%BC%89transforms.Resize%EF%BC%88%EF%BC%89-toc" style="margin-left:80px;"><a href="#4%EF%BC%89transforms.Resize%EF%BC%88%EF%BC%89" rel="nofollow">4）transforms.Resize（）</a></p> 
<p id="4%EF%BC%89transforms.RandomCrop%EF%BC%88%EF%BC%89-toc" style="margin-left:80px;"><a href="#4%EF%BC%89transforms.RandomCrop%EF%BC%88%EF%BC%89" rel="nofollow">4）transforms.RandomCrop（）</a></p> 
<p id="torchvision%E4%B8%AD%E7%9A%84%E6%95%B0%E6%8D%AE%E9%9B%86%E4%BD%BF%E7%94%A8-toc" style="margin-left:0px;"><a href="#torchvision%E4%B8%AD%E7%9A%84%E6%95%B0%E6%8D%AE%E9%9B%86%E4%BD%BF%E7%94%A8" rel="nofollow">torchvision中的数据集使用</a></p> 
<p id="DataLoader%E7%9A%84%E4%BD%BF%E7%94%A8-toc" style="margin-left:0px;"><a href="#DataLoader%E7%9A%84%E4%BD%BF%E7%94%A8" rel="nofollow">DataLoader的使用</a></p> 
<p id="%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E7%9A%84%E5%9F%BA%E6%9C%AC%E9%AA%A8%E6%9E%B6%EF%BC%9Ann.Module%E7%9A%84%E4%BD%BF%E7%94%A8-toc" style="margin-left:0px;"><a href="#%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E7%9A%84%E5%9F%BA%E6%9C%AC%E9%AA%A8%E6%9E%B6%EF%BC%9Ann.Module%E7%9A%84%E4%BD%BF%E7%94%A8" rel="nofollow">神经网络的基本骨架：nn.Module的使用</a></p> 
<p id="%E5%8D%B7%E7%A7%AF%E6%93%8D%E4%BD%9C-toc" style="margin-left:0px;"><a href="#%E5%8D%B7%E7%A7%AF%E6%93%8D%E4%BD%9C" rel="nofollow">卷积操作</a></p> 
<p id="%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C-%E5%8D%B7%E7%A7%AF%E5%B1%82-toc" style="margin-left:0px;"><a href="#%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C-%E5%8D%B7%E7%A7%AF%E5%B1%82" rel="nofollow">神经网络-卷积层</a></p> 
<p id="%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C-%E6%9C%80%E5%A4%A7%E6%B1%A0%E5%8C%96%E7%9A%84%E4%BD%BF%E7%94%A8-toc" style="margin-left:0px;"><a href="#%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C-%E6%9C%80%E5%A4%A7%E6%B1%A0%E5%8C%96%E7%9A%84%E4%BD%BF%E7%94%A8" rel="nofollow">神经网络-最大池化的使用</a></p> 
<p id="%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C-%E9%9D%9E%E7%BA%BF%E6%80%A7%E6%BF%80%E6%B4%BB-toc" style="margin-left:0px;"><a href="#%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C-%E9%9D%9E%E7%BA%BF%E6%80%A7%E6%BF%80%E6%B4%BB" rel="nofollow">神经网络-非线性激活</a></p> 
<p id="%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C-%E7%BA%BF%E6%80%A7%E5%B1%82%E5%8F%8A%E5%85%B6%E4%BB%96%E5%B1%82%E4%BB%8B%E7%BB%8D-toc" style="margin-left:0px;"><a href="#%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C-%E7%BA%BF%E6%80%A7%E5%B1%82%E5%8F%8A%E5%85%B6%E4%BB%96%E5%B1%82%E4%BB%8B%E7%BB%8D" rel="nofollow">神经网络-线性层及其他层介绍</a></p> 
<p id="%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C-%E6%90%AD%E5%BB%BA%E5%B0%8F%E5%AE%9E%E6%88%98%E5%92%8CSequential%E7%9A%84%E4%BD%BF%E7%94%A8-toc" style="margin-left:0px;"><a href="#%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C-%E6%90%AD%E5%BB%BA%E5%B0%8F%E5%AE%9E%E6%88%98%E5%92%8CSequential%E7%9A%84%E4%BD%BF%E7%94%A8" rel="nofollow">神经网络-搭建小实战和Sequential的使用</a></p> 
<p id="%E6%8D%9F%E5%A4%B1%E5%87%BD%E6%95%B0%E4%B8%8E%E5%8F%8D%E5%90%91%E4%BC%A0%E6%92%AD-toc" style="margin-left:0px;"><a href="#%E6%8D%9F%E5%A4%B1%E5%87%BD%E6%95%B0%E4%B8%8E%E5%8F%8D%E5%90%91%E4%BC%A0%E6%92%AD" rel="nofollow">损失函数与反向传播</a></p> 
<p id="%E4%BC%98%E5%8C%96%E5%99%A8-toc" style="margin-left:0px;"><a href="#%E4%BC%98%E5%8C%96%E5%99%A8" rel="nofollow">优化器</a></p> 
<p id="%E7%8E%B0%E6%9C%89%E7%BD%91%E7%BB%9C%E6%A8%A1%E5%9E%8B%E7%9A%84%E4%BD%BF%E7%94%A8%E5%8F%8A%E4%BF%AE%E6%94%B9-toc" style="margin-left:0px;"><a href="#%E7%8E%B0%E6%9C%89%E7%BD%91%E7%BB%9C%E6%A8%A1%E5%9E%8B%E7%9A%84%E4%BD%BF%E7%94%A8%E5%8F%8A%E4%BF%AE%E6%94%B9" rel="nofollow">现有网络模型的使用及修改</a></p> 
<p id="%E7%BD%91%E7%BB%9C%E6%A8%A1%E5%9E%8B%E7%9A%84%E4%BF%9D%E5%AD%98%E4%B8%8E%E8%AF%BB%E5%8F%96-toc" style="margin-left:0px;"><a href="#%E7%BD%91%E7%BB%9C%E6%A8%A1%E5%9E%8B%E7%9A%84%E4%BF%9D%E5%AD%98%E4%B8%8E%E8%AF%BB%E5%8F%96" rel="nofollow">网络模型的保存与读取</a></p> 
<p id="%E5%AE%8C%E6%95%B4%E7%9A%84%E6%A8%A1%E5%9E%8B%E8%AE%AD%E7%BB%83%E5%A5%97%E8%B7%AF-toc" style="margin-left:0px;"><a href="#%E5%AE%8C%E6%95%B4%E7%9A%84%E6%A8%A1%E5%9E%8B%E8%AE%AD%E7%BB%83%E5%A5%97%E8%B7%AF" rel="nofollow">完整的模型训练套路</a></p> 
<p id="%E5%88%A9%E7%94%A8GPU%E8%AE%AD%E7%BB%83-toc" style="margin-left:0px;"><a href="#%E5%88%A9%E7%94%A8GPU%E8%AE%AD%E7%BB%83" rel="nofollow">利用GPU训练</a></p> 
<p id="%E6%96%B9%E5%BC%8F%E4%B8%80%EF%BC%9A-toc" style="margin-left:40px;"><a href="#%E6%96%B9%E5%BC%8F%E4%B8%80%EF%BC%9A" rel="nofollow">方式一：</a></p> 
<p id="%E6%96%B9%E5%BC%8F%E4%BA%8C%EF%BC%9A-toc" style="margin-left:40px;"><a href="#%E6%96%B9%E5%BC%8F%E4%BA%8C%EF%BC%9A" rel="nofollow">方式二：</a></p> 
<p id="%E5%AE%8C%E6%95%B4%E7%9A%84%E6%A8%A1%E5%9E%8B%E9%AA%8C%E8%AF%81%EF%BC%88%E6%B5%8B%E8%AF%95%EF%BC%8Cdemo%EF%BC%89%E5%A5%97%E8%B7%AF-toc" style="margin-left:0px;"><a href="#%E5%AE%8C%E6%95%B4%E7%9A%84%E6%A8%A1%E5%9E%8B%E9%AA%8C%E8%AF%81%EF%BC%88%E6%B5%8B%E8%AF%95%EF%BC%8Cdemo%EF%BC%89%E5%A5%97%E8%B7%AF" rel="nofollow">完整的模型验证（测试，demo）套路</a></p> 
<p id="%E7%9C%8B%E7%9C%8B%E5%BC%80%E6%BA%90%E9%A1%B9%E7%9B%AE-toc" style="margin-left:0px;"><a href="#%E7%9C%8B%E7%9C%8B%E5%BC%80%E6%BA%90%E9%A1%B9%E7%9B%AE" rel="nofollow">看看开源项目</a></p> 
<p></p> 
<h2 id="Python%E5%AD%A6%E4%B9%A0%E4%B8%AD%E7%9A%84%E4%B8%A4%E5%A4%A7%E6%B3%95%E5%AE%9D%E5%87%BD%E6%95%B0%EF%BC%88%E4%B9%9F%E5%8F%AF%E7%94%A8%E4%BA%8EPyTorch%EF%BC%89" style="background-color:transparent;">Python学习中的两大法宝函数（也可用于PyTorch）</h2> 
<h3 id="%E7%90%86%E8%A7%A3Package%E7%BB%93%E6%9E%84%E5%8F%8A%E6%B3%95%E5%AE%9D%E5%87%BD%E6%95%B0%E7%9A%84%E4%BD%9C%E7%94%A8">理解Package结构及法宝函数的作用</h3> 
<p>1.名称是pytorch的package</p> 
<p><img alt="" height="170" src="https://images2.imgbox.com/2b/9d/fiXt5o6M_o.png" width="259"></p> 
<p>2、法宝函数</p> 
<p><img alt="" height="277" src="https://images2.imgbox.com/3b/47/Jt3BJqp7_o.png" width="626"></p> 
<h3 id="%E5%AE%9E%E6%88%98%E8%BF%90%E7%94%A8%E4%B8%A4%E5%A4%A7%E6%B3%95%E5%AE%9D%E5%87%BD%E6%95%B0">实战运用两大法宝函数</h3> 
<p>dir（）</p> 
<p>help（）</p> 
<p>eg.dir（torch）</p> 
<p>help（torch.cuda.is_avaliable<span style="background-color:#fe2c24;">()</span>）注意：没有这个括号！</p> 
<p><img alt="" height="124" src="https://images2.imgbox.com/3a/b8/XDln3tdR_o.png" width="575"></p> 
<h2 id="PyCharm%E5%8F%8AJupyter%E4%BD%BF%E7%94%A8%E5%8F%8A%E5%AF%B9%E6%AF%94">PyCharm及Jupyter使用及对比</h2> 
<p>pycharm控制台：回车——运行，shift+回车——换行</p> 
<p>Jupyter：回车——换行，shift+回车——运行</p> 
<p><img alt="" height="549" src="https://images2.imgbox.com/ac/22/JinDNF4E_o.png" width="1148"></p> 
<h2 id="PyTorch%E5%8A%A0%E8%BD%BD%E6%95%B0%E6%8D%AE">PyTorch加载数据</h2> 
<p>数据集的组成形式：</p> 
<p>（1）文件夹名称为这个文件夹内所有图片所对应的lable</p> 
<p>（2）图片和lable对应两个文件夹</p> 
<p>（3）图片的名称为这张图片所对应的lable</p> 
<p>读取数据：</p> 
<p><img alt="" height="458" src="https://images2.imgbox.com/64/47/gIMIKqJr_o.png" width="926"></p> 
<h2 id="Dataset%E7%B1%BB%E4%BB%A3%E7%A0%81%E5%AE%9E%E6%88%98">Dataset类代码实战</h2> 
<p>python控制台</p> 
<p><img alt="" height="194" src="https://images2.imgbox.com/24/40/ng1fU0jN_o.png" width="647"></p> 
<p><img alt="" height="159" src="https://images2.imgbox.com/4b/3b/eSd3tDaY_o.png" width="505"></p> 
<p><img alt="" height="94" src="https://images2.imgbox.com/c7/1a/GP09QQlg_o.png" width="420"></p> 
<p><img alt="" height="105" src="https://images2.imgbox.com/e5/cc/xey5k4wq_o.png" width="262"></p> 
<p>Dataset类代码实战见read_data.python文件</p> 
<p><img alt="" height="104" src="https://images2.imgbox.com/7e/3b/azkirMgm_o.png" width="293"></p> 
<h2 id="TensorBoard%E7%9A%84%E4%BD%BF%E7%94%A8%C2%A0">TensorBoard的使用 </h2> 
<h3 id="1%E3%80%81TensorBoard%E7%9A%84%E5%AE%89%E8%A3%85">1、TensorBoard的安装</h3> 
<p>图像变换，即transform的使用。想要演示transform结果，运行完一个对应的方法，需要展示这个图像，就需要用到TensorBoard，探究不同阶段模型的输出。</p> 
<p><img alt="" height="39" src="https://images2.imgbox.com/52/cc/9doLDlFo_o.png" width="503"></p> 
<p>用help（）可以查看这个类SummaryWriter，在PyCharm中可以按Ctrl，然后点击SummaryWriter去查看</p> 
<p><img alt="" height="85" src="https://images2.imgbox.com/06/59/phoYqIEm_o.png" width="547"></p> 
<p><img alt="" height="196" src="https://images2.imgbox.com/1c/d6/Wvay0fbD_o.png" width="531"></p> 
<h3 id="2%E3%80%81add_scalar()%E7%9A%84%E4%BD%BF%E7%94%A8(%E5%B8%B8%E7%94%A8%E6%9D%A5%E7%BB%98%E5%88%B6train%2Fval%20loss)%E2%80%8B%E7%BC%96%E8%BE%91">2、add_scalar()的使用(常用来绘制train/val loss)<br><img alt="" height="117" src="https://images2.imgbox.com/d5/d4/tFgavPFq_o.png" width="563"></h3> 
<pre><code class="language-python">from tensorboardX import SummaryWriter
#从这个工具包（tensorboardX）导入这个类（SummaryWriter）

writer = SummaryWriter("logs") #将对应的事件文件储存在log文件夹中

# writer.add_image()
for i in range(100):
    writer.add_scalar("y=x", i, i) #可以用tab键进行缩进
    
writer.close()</code></pre> 
<p>新开一个窗口显示：改函数变量，重命名tag。原窗口显示另一个函数：改函数变量。打开查看logs文件：在python终端输入tensorboard --logdir=logs，也可以指定端口名输入tensorboard --logdir=logs --port=6007</p> 
<h3 id="3%E3%80%81add_image()%E7%9A%84%E4%BD%BF%E7%94%A8(%E5%B8%B8%E7%94%A8%E6%9D%A5%E8%A7%82%E5%AF%9F%E8%AE%AD%E7%BB%83%E7%BB%93%E6%9E%9C)">3、add_image()的使用(常用来观察训练结果)</h3> 
<p><img alt="" height="281" src="https://images2.imgbox.com/a5/a5/54EtA2Xs_o.png" width="947"></p> 
<p>python控制台：</p> 
<p><img alt="" height="38" src="https://images2.imgbox.com/7f/43/Jn5qJMB8_o.png" width="683"></p> 
<p><img alt="" height="118" src="https://images2.imgbox.com/2d/da/G94DUvSq_o.png" width="442"></p> 
<p><img alt="" height="55" src="https://images2.imgbox.com/e2/0b/bDDVJPbJ_o.png" width="692"></p> 
<p><img alt="" height="118" src="https://images2.imgbox.com/c6/1f/UFVv5XzE_o.png" width="343"></p> 
<p>add_image()默认图像shape：<img alt="" height="23" src="https://images2.imgbox.com/10/58/8a0K2JTr_o.png" width="230"></p> 
<p>如果输入shape是<img alt="" height="21" src="https://images2.imgbox.com/c8/e4/XwKnnySU_o.png" width="119">，需要设置<img alt="" height="38" src="https://images2.imgbox.com/9c/ce/rk9QGHAO_o.png" width="541"></p> 
<p>新开一个窗口显示：改路径，重命名tag。原窗口显示另一张图片：改路径，改步数（global_step，即第三个参数）。打开查看logs文件：在python终端输入tensorboard --logdir=logs。</p> 
<p>通过这种方式，我们可以很直观的训练当中给model提供了那些数据，或者相对model进行测试时可以看每一阶段的输出结果。</p> 
<h2 id="Transforms%E7%9A%84%E4%BD%BF%E7%94%A8%C2%A0">Transforms的使用 </h2> 
<h3 id="1%E3%80%81transforms%E7%94%A8%E4%BA%8E%E5%AF%B9%E5%9B%BE%E5%BD%A2%E8%BF%9B%E8%A1%8C%E5%8F%98%E6%8D%A2">1、transforms用于对图形进行变换</h3> 
<p>即transforms.py文件（工具箱）里有很多定义的类（工具）</p> 
<p class="img-center"><img alt="" height="383" src="https://images2.imgbox.com/6e/75/zkfZ41Rl_o.png" width="547"></p> 
<p><img alt="" height="129" src="https://images2.imgbox.com/41/c9/RblYQ0ZR_o.png" width="568"></p> 
<p>内置函数_ _ call _ _的作用：</p> 
<p><img alt="" height="180" src="https://images2.imgbox.com/dc/25/jCWUo59V_o.png" width="304"></p> 
<h3 id="2%E3%80%81%E5%B8%B8%E8%A7%81%E7%9A%84Transforms">2、常见的Transforms</h3> 
<h4 id="1%EF%BC%89transforms.ToTensor()">1）transforms.ToTensor()</h4> 
<p>定义：</p> 
<p><img alt="" height="69" src="https://images2.imgbox.com/9c/34/YExErJZy_o.png" width="618"></p> 
<p>PIL Image的读取：</p> 
<p><img alt="" height="97" src="https://images2.imgbox.com/70/e7/8faqzc0S_o.png" width="588"></p> 
<p>numpy.ndarray的读取：</p> 
<p><img alt="" height="40" src="https://images2.imgbox.com/94/ef/BEyD0yGa_o.png" width="215"></p> 
<p>使用：</p> 
<p><img alt="" height="69" src="https://images2.imgbox.com/24/19/7rO1JlE3_o.png" width="323"></p> 
<h4 id="2%EF%BC%89transforms.Composes%EF%BC%88%EF%BC%89">2）transforms.Composes（）</h4> 
<p>定义：</p> 
<p><img alt="" height="77" src="https://images2.imgbox.com/c6/cf/HFSfMiRr_o.png" width="445"></p> 
<p><img alt="" height="191" src="https://images2.imgbox.com/47/b3/dRtSzFdJ_o.png" width="548"></p> 
<p><img alt="" height="204" src="https://images2.imgbox.com/c7/0b/mEl1nZfv_o.png" width="455"></p> 
<p>使用：后一个参数的输入与前一个参数的输出必须匹配</p> 
<p><img alt="" height="139" src="https://images2.imgbox.com/c8/13/97uwTTk6_o.png" width="748"></p> 
<h4 id="3%EF%BC%89transforms.Normalize%EF%BC%88%EF%BC%89">3）transforms.Normalize（）</h4> 
<p>定义：</p> 
<p><img alt="" height="231" src="https://images2.imgbox.com/ef/37/mnsdiIg5_o.png" width="821"></p> 
<p>使用：</p> 
<p><img alt="" height="97" src="https://images2.imgbox.com/06/6a/Qwi3IdeL_o.png" width="530"></p> 
<p>输出：<img alt="" height="38" src="https://images2.imgbox.com/7a/7c/SsoNWyPZ_o.png" width="123"></p> 
<p><img alt="" height="159" src="https://images2.imgbox.com/19/0c/zTrhgV3k_o.png" width="667"></p> 
<h4 id="4%EF%BC%89transforms.Resize%EF%BC%88%EF%BC%89">4）transforms.Resize（）</h4> 
<p>定义：</p> 
<p><img alt="" height="232" src="https://images2.imgbox.com/8d/d7/4t61VfUa_o.png" width="666"></p> 
<p>使用：<img alt="" height="92" src="https://images2.imgbox.com/44/83/HhA5KNAq_o.png" width="327"></p> 
<p>输出：<img alt="" height="42" src="https://images2.imgbox.com/04/69/jGAIraei_o.png" width="463"></p> 
<h4 id="4%EF%BC%89transforms.RandomCrop%EF%BC%88%EF%BC%89">4）transforms.RandomCrop（）</h4> 
<p>定义：</p> 
<p><img alt="" height="250" src="https://images2.imgbox.com/97/5c/AaBlrk7e_o.png" width="716"></p> 
<p>使用：</p> 
<p><img alt="" height="124" src="https://images2.imgbox.com/91/70/HwYhdXGd_o.png" width="526"></p> 
<h2 id="torchvision%E4%B8%AD%E7%9A%84%E6%95%B0%E6%8D%AE%E9%9B%86%E4%BD%BF%E7%94%A8">torchvision中的数据集使用</h2> 
<p>之前使用transforms对单个图片进行处理，但真正使用transforms要对数据集中的每一个图片进行处理。这节讲如何将transforms与数据集结合在一起，以及标准数据集如何下载组织查看使用。</p> 
<p>pytorch官方文档：</p> 
<p><img alt="" height="352" src="https://images2.imgbox.com/6b/8a/dT3T5ZZ0_o.png" width="381"><img alt="" height="300" src="https://images2.imgbox.com/96/25/LNi2MKGP_o.png" width="214"></p> 
<p>有的数据集没有显示下载地址，如何查看：按住ctrl键，鼠标点击CIFAR10，url路径就是下载链接</p> 
<p><img alt="" height="41" src="https://images2.imgbox.com/0a/1a/suno7thg_o.png" width="648"></p> 
<p>代码实战：</p> 
<pre><code class="language-python">import torchvision
from tensorboardX import SummaryWriter

dataset_transform = torchvision.transforms.Compose([
    torchvision.transforms.ToTensor()
])
train_set = torchvision.datasets.CIFAR10(root="./dataset_", transform=dataset_transform,train=True, download=True)
test_set = torchvision.datasets.CIFAR10(root="./dataset_", transform=dataset_transform,train=False, download=True)

# print(test_set[0])
# print(test_set.classes)
#
# img,target = test_set[0]
# print(img)
# print(target)
# print(test_set.classes[target])
# img.show()

writer = SummaryWriter("p10")
for i in range(10):
    img,target = test_set[i]
    writer.add_image("test_set",img,i)

writer.close()
</code></pre> 
<h2 id="DataLoader%E7%9A%84%E4%BD%BF%E7%94%A8">DataLoader的使用</h2> 
<p><img alt="" height="151" src="https://images2.imgbox.com/1c/8d/1rd9omTl_o.png" width="299"></p> 
<p>自定义的dataset：告诉程序数据集在什么地方，第一张数据是什么，第二张数据是什么，dataset总共有多少张数据。</p> 
<p><img alt="" height="572" src="https://images2.imgbox.com/d4/7f/qmqZz9dO_o.png" width="1013"><img alt="" height="320" src="https://images2.imgbox.com/87/27/5574tQxA_o.png" width="316"><img alt="" height="346" src="https://images2.imgbox.com/62/49/uhliokGR_o.png" width="258"></p> 
<p> 按住ctrl键，鼠标点击CIFAR10，找到_ _getitem_ _可以知道其返回值</p> 
<p><img alt="" height="709" src="https://images2.imgbox.com/0b/85/cWBY6lIJ_o.png" width="819"></p> 
<p>代码实战：</p> 
<p><img alt="" height="306" src="https://images2.imgbox.com/ea/20/oeWHK7kp_o.png" width="307"></p> 
<p>输出结果为：</p> 
<p><img alt="" height="138" src="https://images2.imgbox.com/ba/0c/Tkbza4Fd_o.png" width="329"></p> 
<p>第一个batch的第一张图片标签为2，而test_set【0】的标签为3，可知DataLoader的采样方式为随机采样。</p> 
<p><img alt="" height="302" src="https://images2.imgbox.com/74/0d/4XpfHyTb_o.png" width="533"></p> 
<p>代码实战：</p> 
<pre><code class="language-python">import torchvision
from torch.utils.data import DataLoader
from tensorboardX import SummaryWriter

test_data = torchvision.datasets.CIFAR10("./dataset_", train=False, transform=torchvision.transforms.ToTensor())

test_loader = DataLoader(dataset=test_data, batch_size=64, shuffle=False, num_workers=0, drop_last=True)

# 测试数据集中第一张图片及target
img, target = test_data[0]
print(img.shape)
print(target)
print(len(test_data))

writer = SummaryWriter("p11")
for epoch in range(2):
        step=0
        for data in test_loader:
                imgs,targets = data
                # print(imgs.shape)
                # print(targets)
                writer.add_images("Epoch: {}".format(epoch), imgs, step)
                step=step+1

writer.close()
</code></pre> 
<h2 id="%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E7%9A%84%E5%9F%BA%E6%9C%AC%E9%AA%A8%E6%9E%B6%EF%BC%9Ann.Module%E7%9A%84%E4%BD%BF%E7%94%A8">神经网络的基本骨架：nn.Module的使用</h2> 
<p><img alt="" height="594" src="https://images2.imgbox.com/62/30/mHtlJVQv_o.png" width="483"></p> 
<p><img alt="" height="437" src="https://images2.imgbox.com/e8/08/aQdFrrwr_o.png" width="557"></p> 
<p><img alt="" height="516" src="https://images2.imgbox.com/1c/59/4D0XtApE_o.png" width="736"></p> 
<h2 id="%E5%8D%B7%E7%A7%AF%E6%93%8D%E4%BD%9C">卷积操作</h2> 
<p><img alt="" height="150" src="https://images2.imgbox.com/fa/d4/3c4QwSM2_o.png" width="759"></p> 
<p><img alt="" height="327" src="https://images2.imgbox.com/f9/e8/8gcuPm0a_o.png" width="691"></p> 
<p><img alt="" height="445" src="https://images2.imgbox.com/10/6e/kBehPRMD_o.png" width="781"></p> 
<p>代码实战：</p> 
<pre><code class="language-python">import torch
import torch.nn.functional as F

input = torch.tensor([[1, 2, 0, 3, 1],
                      [0, 1, 2, 3, 1],
                      [1, 2, 1, 0, 0],
                      [5, 2, 3, 1, 1],
                      [2, 1, 0, 1, 1]])

kernel = torch.tensor([[1, 2, 1],
                       [0, 1, 0],
                       [2, 1, 0]])

input = torch.reshape(input, (1, 1, 5, 5))
kernel = torch.reshape(kernel, (1, 1, 3, 3))

print(input.shape)
print(kernel.shape)

output = F.conv2d(input, kernel, stride=1)
print(output)

output2 = F.conv2d(input, kernel, stride=2)
print(output2)

output3 = F.conv2d(input, kernel, stride=1, padding=1)
print(output3)</code></pre> 
<p>输出：</p> 
<pre><code class="language-python">torch.Size([1, 1, 5, 5])
torch.Size([1, 1, 3, 3])
tensor([[[[10, 12, 12],
          [18, 16, 16],
          [13,  9,  3]]]])
tensor([[[[10, 12],
          [13,  3]]]])
tensor([[[[ 1,  3,  4, 10,  8],
          [ 5, 10, 12, 12,  6],
          [ 7, 18, 16, 16,  8],
          [11, 13,  9,  3,  4],
          [14, 13,  9,  7,  4]]]])</code></pre> 
<h2 id="%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C-%E5%8D%B7%E7%A7%AF%E5%B1%82">神经网络-卷积层</h2> 
<p><img alt="" height="273" src="https://images2.imgbox.com/91/86/uPRVmYOI_o.png" width="384"></p> 
<p><img alt="" height="244" src="https://images2.imgbox.com/f6/4c/oprD5Ggq_o.png" width="720"></p> 
<p><img alt="" height="156" src="https://images2.imgbox.com/5b/b2/ISFgcEKf_o.png" width="605"></p> 
<p><img alt="" height="202" src="https://images2.imgbox.com/ae/af/e6hnTYYM_o.png" width="570"></p> 
<p><img alt="" height="388" src="https://images2.imgbox.com/9b/f5/kKz1ZmhH_o.png" width="685"></p> 
<p>dilation：用于空洞卷积，默认值为1</p> 
<p><img alt="" height="188" src="https://images2.imgbox.com/dd/7e/fF1EagIz_o.png" width="229"></p> 
<p>groups：用于分组卷积，默认值为1</p> 
<p><img alt="" height="551" src="https://images2.imgbox.com/0c/a2/6DMulQyW_o.png" width="1028"></p> 
<p>代码实战：</p> 
<pre><code class="language-python">import torch
import torchvision
from torch import nn
from torch.nn import Conv2d
from torch.utils.data import DataLoader

dataset = torchvision.datasets.CIFAR10("./dataset_",train=False,transform=torchvision.transforms.ToTensor(),
                                       download=True)
dataloader = DataLoader(dataset,batch_size=64)

class Mengyuan(nn.Module):
    def __init__(self):
        super(Mengyuan, self).__init__()
        self.conv1 = Conv2d(in_channels=3,out_channels=6,kernel_size=3,stride=1,padding=0)

    def forward(self,x):
        x = self.conv1(x)
        return x

mengyuan = Mengyuan()
print(mengyuan)</code></pre> 
<p>输出：</p> 
<p><img alt="" height="125" src="https://images2.imgbox.com/0a/24/7EhJRNBd_o.png" width="892"></p> 
<p>代码实战：</p> 
<pre><code class="language-python">import torch
import torchvision
from tensorboardX import SummaryWriter
from torch import nn
from torch.nn import Conv2d
from torch.utils.data import DataLoader

dataset = torchvision.datasets.CIFAR10("./dataset_",train=False,transform=torchvision.transforms.ToTensor(),
                                       download=True)
dataloader = DataLoader(dataset,batch_size=64)

class Mengyuan(nn.Module):
    def __init__(self):
        super(Mengyuan, self).__init__()
        self.conv1 = Conv2d(in_channels=3,out_channels=6,kernel_size=3,stride=1,padding=0)

    def forward(self,x):
        x = self.conv1(x)
        return x

mengyuan = Mengyuan()
#print(mengyuan)
writer = SummaryWriter("./nn")
step = 0
for data in dataloader:
    imgs,targets = data
    output = mengyuan(imgs)
    print(imgs.shape) #torch.Size([64,3,32,32])
    writer.add_images("input",imgs,step)
    print(output.shape) #torch.Size([64,6,30,30])
    # torch.Size([64, 6, 30, 30])  -&gt; [xxx, 3, 30, 30]

    output = torch.reshape(output,(-1,3,30,30))
    writer.add_images("output",output,step)

    step = step+1

writer.close()</code></pre> 
<p>输出：</p> 
<p><img alt="" height="161" src="https://images2.imgbox.com/32/13/YBjTXo3e_o.png" width="384"></p> 
<p><img alt="" height="600" src="https://images2.imgbox.com/63/68/MiHYoOZE_o.png" width="177"></p> 
<h2 id="%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C-%E6%9C%80%E5%A4%A7%E6%B1%A0%E5%8C%96%E7%9A%84%E4%BD%BF%E7%94%A8">神经网络-最大池化的使用</h2> 
<p><img alt="" height="131" src="https://images2.imgbox.com/52/7e/lrwI0dqe_o.png" width="237"></p> 
<p><img alt="" height="534" src="https://images2.imgbox.com/d0/7f/vxl94L9n_o.png" width="704"></p> 
<p><img alt="" height="128" src="https://images2.imgbox.com/97/54/Ktuo1KEq_o.png" width="603"></p> 
<p><img alt="" height="333" src="https://images2.imgbox.com/c0/a0/gEx6tBV3_o.png" width="687"></p> 
<p><img alt="" height="144" src="https://images2.imgbox.com/c7/4d/aJt6ycv1_o.png" width="433"></p> 
<p><img alt="" height="348" src="https://images2.imgbox.com/76/0a/80WYYYaX_o.png" width="757"></p> 
<p>代码实战：</p> 
<pre><code class="language-python">import torch
from torch import nn
from torch.nn import MaxPool2d

input = torch.tensor([[1, 2, 0, 3, 1],
                      [0, 1, 2, 3, 1],
                      [1, 2, 1, 0, 0],
                      [5, 2, 3, 1, 1],
                      [2, 1, 0, 1, 1]],dtype=torch.float32)
input = torch.reshape(input,(1,1,5,5))
print(input.shape)

class Mengyuan(nn.Module):
    def __init__(self):
        super(Mengyuan, self).__init__()
        self.maxpool1 = MaxPool2d(kernel_size=3,ceil_mode=True)

    def forward(self,input):
        output = self.maxpool1(input)
        return output

mengyuan = Mengyuan()
output = mengyuan(input)
print(output)</code></pre> 
<p>输出：</p> 
<p><img alt="" height="107" src="https://images2.imgbox.com/ed/a7/xn4z8CwT_o.png" width="277"></p> 
<p>代码实战：</p> 
<pre><code class="language-python">import torch
import torchvision
from tensorboardX import SummaryWriter
from torch import nn
from torch.nn import MaxPool2d
from torch.utils.data import DataLoader

# input = torch.tensor([[1, 2, 0, 3, 1],
#                       [0, 1, 2, 3, 1],
#                       [1, 2, 1, 0, 0],
#                       [5, 2, 3, 1, 1],
#                       [2, 1, 0, 1, 1]],dtype=torch.float32)
# input = torch.reshape(input,(1,1,5,5))
# print(input.shape)


dataset = torchvision.datasets.CIFAR10("./dataset_", train=False, download=True,
                                       transform=torchvision.transforms.ToTensor())

dataloader = DataLoader(dataset, batch_size=64)

class Mengyuan(nn.Module):
    def __init__(self):
        super(Mengyuan, self).__init__()
        self.maxpool1 = MaxPool2d(kernel_size=3,ceil_mode=True)

    def forward(self,input):
        output = self.maxpool1(input)
        return output

mengyuan = Mengyuan()
# output = mengyuan(input)
# print(output)

writer = SummaryWriter("./logs_maxpool")
step = 0

for data in dataloader:
    imgs, targets = data
    writer.add_images("input", imgs, step)
    output = mengyuan(imgs)
    writer.add_images("output", output, step)
    step = step + 1

writer.close()</code></pre> 
<p>输出：</p> 
<p><img alt="" height="979" src="https://images2.imgbox.com/6f/d0/MBLViPdd_o.png" width="428"></p> 
<h2 id="%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C-%E9%9D%9E%E7%BA%BF%E6%80%A7%E6%BF%80%E6%B4%BB">神经网络-非线性激活</h2> 
<p><img alt="" height="222" src="https://images2.imgbox.com/f0/bd/t0kOYaBJ_o.png" width="396"></p> 
<p><img alt="" height="72" src="https://images2.imgbox.com/e4/a6/lRRyUhS0_o.png" width="702"></p> 
<p><img alt="" height="953" src="https://images2.imgbox.com/2a/a9/7Otmc8iQ_o.png" width="762"></p> 
<p><img alt="" height="59" src="https://images2.imgbox.com/5e/c2/qSryQDPm_o.png" width="653"></p> 
<p><img alt="" height="880" src="https://images2.imgbox.com/82/17/41wNKHYK_o.png" width="751"></p> 
<p><img alt="" height="100" src="https://images2.imgbox.com/d8/80/CQQVYcrr_o.png" width="699"></p> 
<p>代码实战：</p> 
<p><img alt="" height="418" src="https://images2.imgbox.com/51/e8/5rDaf1st_o.png" width="330"></p> 
<p>输出：</p> 
<p><img alt="" height="67" src="https://images2.imgbox.com/9b/5f/gFoQf0v0_o.png" width="199"></p> 
<p>代码实战：</p> 
<pre><code class="language-python">import torch
import torchvision
from torch import nn
from torch.nn import ReLU, Sigmoid
from torch.utils.data import DataLoader
from tensorboardX import SummaryWriter

input = torch.tensor([[1, -0.5],
                      [-1, 3]])

input = torch.reshape(input, (-1, 1, 2, 2))
print(input.shape)

dataset = torchvision.datasets.CIFAR10("./dataset_", train=False, download=True,
                                       transform=torchvision.transforms.ToTensor())

dataloader = DataLoader(dataset, batch_size=64)

class Mengyuan(nn.Module):
    def __init__(self):
        super(Mengyuan, self).__init__()
        self.relu1 = ReLU()
        self.sigmoid1 = Sigmoid()

    def forward(self, input):
        output = self.sigmoid1(input)
        return output

mengyuan = Mengyuan()

writer = SummaryWriter("./logs_sigmoid")
step = 0
for data in dataloader:
    imgs, targets = data
    writer.add_images("input", imgs, global_step=step)
    output = mengyuan(imgs)
    writer.add_images("output", output, step)
    step += 1

writer.close()</code></pre> 
<p>输出：</p> 
<p><img alt="" height="1009" src="https://images2.imgbox.com/74/ad/nPkawDB2_o.png" width="417"></p> 
<h2 id="%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C-%E7%BA%BF%E6%80%A7%E5%B1%82%E5%8F%8A%E5%85%B6%E4%BB%96%E5%B1%82%E4%BB%8B%E7%BB%8D">神经网络-线性层及其他层介绍</h2> 
<p><img alt="" height="249" src="https://images2.imgbox.com/c6/86/XfFPJBZ0_o.png" width="396"></p> 
<p>正则化：加快神经网络的训练速度</p> 
<p><img alt="" height="125" src="https://images2.imgbox.com/90/ab/JZmRbyzI_o.png" width="711"></p> 
<p><img alt="" height="761" src="https://images2.imgbox.com/58/ff/Hg792OJe_o.png" width="695"></p> 
<p><img alt="" height="479" src="https://images2.imgbox.com/2e/97/bUecv5ro_o.png" width="716"></p> 
<p><img alt="" height="289" src="https://images2.imgbox.com/e3/68/yrfLRYp4_o.png" width="645"></p> 
<p><img alt="" height="144" src="https://images2.imgbox.com/45/3d/e28piJej_o.png" width="642"></p> 
<p><img alt="" height="158" src="https://images2.imgbox.com/bf/f4/YvZGhBNx_o.png" width="738"></p> 
<p>代码实战：</p> 
<p><img alt="" height="225" src="https://images2.imgbox.com/f4/ea/F6pMgUNG_o.png" width="594"></p> 
<p>输出：</p> 
<p><img alt="" height="84" src="https://images2.imgbox.com/eb/27/uJPxG8nJ_o.png" width="215"></p> 
<p><img alt="" height="566" src="https://images2.imgbox.com/13/ee/4tFBilS6_o.png" width="652"></p> 
<p>代码实战：</p> 
<pre><code class="language-python">import torch
import torchvision
from torch import nn
from torch.nn import Linear
from torch.utils.data import DataLoader

dataset = torchvision.datasets.CIFAR10("./dataset_", train=False, download=True,
                                       transform=torchvision.transforms.ToTensor())

dataloader = DataLoader(dataset, batch_size=64)

class Tudui(nn.Module):
    def __init__(self):
        super(Tudui, self).__init__()
        self.linear1 = Linear(196608, 10)

    def forward(self, input):
        output = self.linear1(input)
        return output

tudui = Tudui()

for data in dataloader:
    imgs, targets = data
    print(imgs.shape)
    output = torch.flatten(imgs)
    print(output.shape)
    output = tudui(output)
    print(output.shape)</code></pre> 
<p>输出：</p> 
<p><img alt="" height="134" src="https://images2.imgbox.com/9d/85/SV1s5gcW_o.png" width="419"></p> 
<h2 id="%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C-%E6%90%AD%E5%BB%BA%E5%B0%8F%E5%AE%9E%E6%88%98%E5%92%8CSequential%E7%9A%84%E4%BD%BF%E7%94%A8">神经网络-搭建小实战和Sequential的使用</h2> 
<p><img alt="" height="463" src="https://images2.imgbox.com/13/04/zR5hsRIL_o.png" width="673"></p> 
<p><img alt="" height="357" src="https://images2.imgbox.com/3d/65/Z0PwdKNI_o.png" width="877"></p> 
<p>搭建网络，代码实战：</p> 
<pre><code class="language-python">class Tudui(nn.Module):
    def __init__(self):
        super(Tudui, self).__init__()
        self.model1 = Sequential(
            Conv2d(3, 32, 5, padding=2),
            MaxPool2d(2),
            Conv2d(32, 32, 5, padding=2),
            MaxPool2d(2),
            Conv2d(32, 64, 5, padding=2),
            MaxPool2d(2),
            Flatten(),
            Linear(1024, 64),
            Linear(64, 10)
        )

    def forward(self, x):
        x = self.model1(x)
        return x

tudui = Tudui()
print(tudui)</code></pre> 
<p>输出：</p> 
<p><img alt="" height="385" src="https://images2.imgbox.com/00/85/4L0SEMuG_o.png" width="856"></p> 
<p>检验网络是否搭建正确，代码实战：</p> 
<p><img alt="" height="102" src="https://images2.imgbox.com/19/6d/42Rx1LWU_o.png" width="590"></p> 
<p>输出：</p> 
<p><img alt="" height="40" src="https://images2.imgbox.com/9b/fb/2fB4LYjE_o.png" width="439"></p> 
<p>符合上图CIFAR 10的模型，网络搭建正确。</p> 
<p>tensorboard显示网络结构，代码实战：</p> 
<p><img alt="" height="111" src="https://images2.imgbox.com/ac/63/ImwbgRfx_o.png" width="388"></p> 
<p>输出：</p> 
<p><img alt="" height="531" src="https://images2.imgbox.com/a9/ba/uYhuJDrT_o.png" width="351"></p> 
<p>将数据集输入网络，代码实战：</p> 
<pre><code class="language-python">import torchvision
from torch import nn
from torch.nn import Sequential, Conv2d, MaxPool2d, Flatten, Linear
from torch.utils.data import DataLoader

dataset = torchvision.datasets.CIFAR10("./dataset_", train=False, transform=torchvision.transforms.ToTensor(),
                                       download=True)

dataloader = DataLoader(dataset, batch_size=1)

class Tudui(nn.Module):
    def __init__(self):
        super(Tudui, self).__init__()
        self.model1 = Sequential(
            Conv2d(3, 32, 5, padding=2),
            MaxPool2d(2),
            Conv2d(32, 32, 5, padding=2),
            MaxPool2d(2),
            Conv2d(32, 64, 5, padding=2),
            MaxPool2d(2),
            Flatten(),
            Linear(1024, 64),
            Linear(64, 10)
        )

    def forward(self, x):
        x = self.model1(x)
        return x


# loss = nn.CrossEntropyLoss()
tudui = Tudui()
for data in dataloader:
    imgs, targets = data
    outputs = tudui(imgs)
    print(outputs)
    print(targets)
#     result_loss = loss(outputs, targets)
#     print("ok")
</code></pre> 
<p>输出：</p> 
<p><img alt="" height="137" src="https://images2.imgbox.com/91/bd/cfsQ6PX1_o.png" width="807"></p> 
<h2 id="%E6%8D%9F%E5%A4%B1%E5%87%BD%E6%95%B0%E4%B8%8E%E5%8F%8D%E5%90%91%E4%BC%A0%E6%92%AD" style="background-color:transparent;">损失函数与反向传播</h2> 
<p><img alt="" height="432" src="https://images2.imgbox.com/44/e7/YPNzG6lC_o.png" width="398"></p> 
<p><img alt="" height="241" src="https://images2.imgbox.com/62/72/OIkHAiEe_o.png" width="298"></p> 
<p><strong>L1LOSSS：（绝对值之差）</strong></p> 
<p><img alt="" height="143" src="https://images2.imgbox.com/3d/56/p0RNMHnT_o.png" width="573"></p> 
<p>代码实战：</p> 
<p><img alt="" height="229" src="https://images2.imgbox.com/21/ce/QrlleNR9_o.png" width="334"></p> 
<p>输出：</p> 
<p><img alt="" height="29" src="https://images2.imgbox.com/44/fb/6WePlG68_o.png" width="90"></p> 
<p><strong>MSELOSS：（均方差）</strong></p> 
<p><img alt="" height="123" src="https://images2.imgbox.com/e3/a0/L0Na39fK_o.png" width="447"></p> 
<p>代码实战：</p> 
<p><img alt="" height="321" src="https://images2.imgbox.com/9b/29/LrND1COn_o.png" width="337"></p> 
<p>输出：</p> 
<p><img alt="" height="23" src="https://images2.imgbox.com/d3/ec/HscCc99K_o.png" width="111"></p> 
<p><strong>CROSSENTROPYLOSS：（交叉熵）</strong></p> 
<p><img alt="" height="486" src="https://images2.imgbox.com/6f/12/yCsNtP8M_o.png" width="968"></p> 
<p><img alt="" height="181" src="https://images2.imgbox.com/b8/bc/wUtm45FO_o.png" width="618"></p> 
<p><img alt="" height="40" src="https://images2.imgbox.com/f9/73/3qRBto2X_o.png" width="422"></p> 
<p>代码实战：</p> 
<p><img alt="" height="115" src="https://images2.imgbox.com/c6/ae/PlyeKSSf_o.png" width="239"></p> 
<p>输出：</p> 
<p><img alt="" height="27" src="https://images2.imgbox.com/ef/2a/KBZa9XEe_o.png" width="96"></p> 
<p>利用CROSSENTROPYLOSS（交叉熵）优化网络，代码实战：</p> 
<pre><code class="language-python">import torchvision
from torch import nn
from torch.nn import Sequential, Conv2d, MaxPool2d, Flatten, Linear
from torch.utils.data import DataLoader

dataset = torchvision.datasets.CIFAR10("./dataset_", train=False, transform=torchvision.transforms.ToTensor(),
                                       download=True)

dataloader = DataLoader(dataset, batch_size=1)

class Tudui(nn.Module):
    def __init__(self):
        super(Tudui, self).__init__()
        self.model1 = Sequential(
            Conv2d(3, 32, 5, padding=2),
            MaxPool2d(2),
            Conv2d(32, 32, 5, padding=2),
            MaxPool2d(2),
            Conv2d(32, 64, 5, padding=2),
            MaxPool2d(2),
            Flatten(),
            Linear(1024, 64),
            Linear(64, 10)
        )

    def forward(self, x):
        x = self.model1(x)
        return x


loss = nn.CrossEntropyLoss()
tudui = Tudui()
for data in dataloader:
    imgs, targets = data
    outputs = tudui(imgs)
    # print(outputs)
    # print(targets)
    result_loss = loss(outputs, targets)
    print(result_loss)
</code></pre> 
<p>输出：（神经网络的输出和真实值之间的误差值）</p> 
<p><img alt="" height="72" src="https://images2.imgbox.com/45/ba/n1axGpR8_o.png" width="449"></p> 
<p><strong>反向传播：</strong></p> 
<p>没有用反向传播前：</p> 
<p><img alt="" height="29" src="https://images2.imgbox.com/f4/ba/NMzw6oZW_o.png" width="182"></p> 
<p>运行反向传播：</p> 
<p><img alt="" height="64" src="https://images2.imgbox.com/a9/5c/qwesoM9E_o.png" width="368"></p> 
<p>运行反向传播：</p> 
<p><img alt="" height="23" src="https://images2.imgbox.com/92/78/7mo7DiCk_o.png" width="649"></p> 
<p>选择合适的优化器，利用梯度对神经网络的参数进行更新。</p> 
<h2 id="%E4%BC%98%E5%8C%96%E5%99%A8">优化器</h2> 
<p><img alt="" height="210" src="https://images2.imgbox.com/56/be/BxfaEXOD_o.png" width="191"></p> 
<p><img alt="" height="381" src="https://images2.imgbox.com/39/25/W6oesPo2_o.png" width="757"></p> 
<p><img alt="" height="397" src="https://images2.imgbox.com/e7/e0/5jZ1Z0T4_o.png" width="720"></p> 
<p>代码实战：（学习速率：太大，模型训练起来很不稳定，太小，模型训练慢；所以开始用大一点的学习速率去训练，后期用小一点的学习速率去训练）</p> 
<pre><code class="language-python">import torch
import torchvision
from torch import nn
from torch.nn import Sequential, Conv2d, MaxPool2d, Flatten, Linear
from torch.optim.lr_scheduler import StepLR
from torch.utils.data import DataLoader

dataset = torchvision.datasets.CIFAR10("./dataset_", train=False, transform=torchvision.transforms.ToTensor(),
                                       download=True)

dataloader = DataLoader(dataset, batch_size=1)

class Tudui(nn.Module):
    def __init__(self):
        super(Tudui, self).__init__()
        self.model1 = Sequential(
            Conv2d(3, 32, 5, padding=2),
            MaxPool2d(2),
            Conv2d(32, 32, 5, padding=2),
            MaxPool2d(2),
            Conv2d(32, 64, 5, padding=2),
            MaxPool2d(2),
            Flatten(),
            Linear(1024, 64),
            Linear(64, 10)
        )

    def forward(self, x):
        x = self.model1(x)
        return x


loss = nn.CrossEntropyLoss()
tudui = Tudui()
optim = torch.optim.SGD(tudui.parameters(), lr=0.01)
for epoch in range(20):
    running_loss = 0.0
    for data in dataloader:
            imgs, targets = data
            outputs = tudui(imgs)
            result_loss = loss(outputs, targets)
            optim.zero_grad() #梯度参数设为0
            result_loss.backward() #求每个节点的梯度
            optim.step() #利用梯度进行优化
            running_loss = running_loss + result_loss #求每一轮的误差总和
    print(running_loss)
</code></pre> 
<p>输出：</p> 
<p><img alt="" height="36" src="https://images2.imgbox.com/26/4f/9Ap5Erky_o.png" width="432"></p> 
<h2 id="%E7%8E%B0%E6%9C%89%E7%BD%91%E7%BB%9C%E6%A8%A1%E5%9E%8B%E7%9A%84%E4%BD%BF%E7%94%A8%E5%8F%8A%E4%BF%AE%E6%94%B9" style="background-color:transparent;">现有网络模型的使用及修改</h2> 
<p><img alt="" height="349" src="https://images2.imgbox.com/a7/75/bo1vF2bq_o.png" width="212"></p> 
<p><img alt="" height="103" src="https://images2.imgbox.com/08/d3/Oybplo20_o.png" width="216"></p> 
<p>代码实战：</p> 
<pre><code class="language-python">import torchvision

# train_data = torchvision.datasets.ImageNet("../data_image_net", split='train', download=True,
#                                            transform=torchvision.transforms.ToTensor())
from torch import nn

vgg16_false = torchvision.models.vgg16(pretrained=False) #网络权重为初始化参数
vgg16_true = torchvision.models.vgg16(pretrained=True)  #网络在imagenet数据集上预训练达到理想效果的权重

print(vgg16_true)

train_data = torchvision.datasets.CIFAR10('./dataset', train=True, transform=torchvision.transforms.ToTensor(),
                                          download=True) #CIFAR10数据集是10个类，VGG网络最后输出是1000，所以需要修改网络

vgg16_true.classifier.add_module('add_linear', nn.Linear(1000, 10)) #最后增加一个线性层
print(vgg16_true)

print(vgg16_false)
vgg16_false.classifier[6] = nn.Linear(4096, 10) #修改最后一层
print(vgg16_false)


</code></pre> 
<h2 id="%E7%BD%91%E7%BB%9C%E6%A8%A1%E5%9E%8B%E7%9A%84%E4%BF%9D%E5%AD%98%E4%B8%8E%E8%AF%BB%E5%8F%96" style="background-color:transparent;">网络模型的保存与读取</h2> 
<p><strong>保存方式一：</strong>（既保存模型结构又保存模型参数）</p> 
<p><img alt="" height="105" src="https://images2.imgbox.com/4f/13/4NCsnPWF_o.png" width="522"></p> 
<p>输出将模型保存到左侧项目文件中，与该py文件同级</p> 
<p><img alt="" height="23" src="https://images2.imgbox.com/76/9f/iDuQTD60_o.png" width="133"></p> 
<p>读取模型：</p> 
<p><img alt="" height="101" src="https://images2.imgbox.com/d4/1d/G2f1ij38_o.png" width="408"></p> 
<p><img alt="" height="354" src="https://images2.imgbox.com/ea/60/r9MUfbPP_o.png" width="528"></p> 
<p><img alt="" height="350" src="https://images2.imgbox.com/f2/83/iTwtcjE6_o.png" width="546"></p> 
<p>解决：实际上不需要将模型复制过来，<span style="background-color:#ffd900;">将模型定义保存在一个文件中（同级），然后</span></p> 
<p><span style="background-color:#ffd900;">from 模型文件名import   *</span></p> 
<p><img alt="" height="39" src="https://images2.imgbox.com/fb/e2/5hOSeHhX_o.png" width="256"></p> 
<p><strong>保存方式二：</strong>（只保存模型参数）</p> 
<p><img alt="" height="73" src="https://images2.imgbox.com/81/b6/AcKWcrXd_o.png" width="518"></p> 
<p>输出将模型保存到左侧项目文件中，与该py文件同级</p> 
<p>读取模型：</p> 
<p><img alt="" height="168" src="https://images2.imgbox.com/fe/76/WFkou5NU_o.png" width="559"></p> 
<p>tips：查看文件大小</p> 
<p><img alt="" height="425" src="https://images2.imgbox.com/e5/a1/dgtCwy0M_o.png" width="305"></p> 
<p><img alt="" height="77" src="https://images2.imgbox.com/d0/09/2X2yWiNP_o.png" width="295"></p> 
<h2 id="%E5%AE%8C%E6%95%B4%E7%9A%84%E6%A8%A1%E5%9E%8B%E8%AE%AD%E7%BB%83%E5%A5%97%E8%B7%AF" style="background-color:transparent;">完整的模型训练套路</h2> 
<p><strong>创建并检验神经网络：</strong>同级，单独的文件夹</p> 
<p><img alt="" height="21" src="https://images2.imgbox.com/a2/96/dta41Qtt_o.png" width="84"></p> 
<pre><code class="language-python">import torch
from torch import nn

# 搭建神经网络
class Tudui(nn.Module):
    def __init__(self):
        super(Tudui, self).__init__()
        self.model = nn.Sequential(
            nn.Conv2d(3, 32, 5, 1, 2),
            nn.MaxPool2d(2),
            nn.Conv2d(32, 32, 5, 1, 2),
            nn.MaxPool2d(2),
            nn.Conv2d(32, 64, 5, 1, 2),
            nn.MaxPool2d(2),
            nn.Flatten(),
            nn.Linear(64*4*4, 64),
            nn.Linear(64, 10)
        )

    def forward(self, x):
        x = self.model(x)
        return x

#检验
if __name__ == '__main__':
    tudui = Tudui()
    input = torch.ones((64, 3, 32, 32))
    output = tudui(input)
    print(output.shape)</code></pre> 
<p><strong>训练网络：</strong></p> 
<p>首先引入创建的网络（同级）</p> 
<p><img alt="" height="36" src="https://images2.imgbox.com/92/f6/Xan7RC43_o.png" width="205"></p> 
<p>argmax：</p> 
<p><img alt="" height="471" src="https://images2.imgbox.com/da/e5/y3u91Idu_o.png" width="357"></p> 
<p>代码实战：</p> 
<p><img alt="" height="163" src="https://images2.imgbox.com/60/3e/KhdkL8lO_o.png" width="237"></p> 
<p>输出：</p> 
<p><img alt="" height="37" src="https://images2.imgbox.com/f6/52/jgS65SwM_o.png" width="106"></p> 
<p>train（）、eval（）：</p> 
<p><img alt="" height="224" src="https://images2.imgbox.com/13/37/EEaXXiXp_o.png" width="1126"></p> 
<p><img alt="" height="211" src="https://images2.imgbox.com/eb/dd/XfYS6G3M_o.png" width="1141"></p> 
<p>训练网络代码实战：</p> 
<pre><code class="language-python"># -*- coding: utf-8 -*-
# 作者：小土堆
# 公众号：土堆碎念

import torchvision
from torch.utils.tensorboard import SummaryWriter

from model import *
# 准备数据集
from torch import nn
from torch.utils.data import DataLoader

train_data = torchvision.datasets.CIFAR10(root="../data", train=True, transform=torchvision.transforms.ToTensor(),
                                          download=True)
test_data = torchvision.datasets.CIFAR10(root="../data", train=False, transform=torchvision.transforms.ToTensor(),
                                         download=True)

# length 长度
train_data_size = len(train_data)
test_data_size = len(test_data)
# 如果train_data_size=10, 训练数据集的长度为：10
print("训练数据集的长度为：{}".format(train_data_size))
print("测试数据集的长度为：{}".format(test_data_size))


# 利用 DataLoader 来加载数据集
train_dataloader = DataLoader(train_data, batch_size=64)
test_dataloader = DataLoader(test_data, batch_size=64)

# 创建网络模型
tudui = Tudui()

# 损失函数
loss_fn = nn.CrossEntropyLoss()

# 优化器
# learning_rate = 0.01
# 1e-2=1 x (10)^(-2) = 1 /100 = 0.01
learning_rate = 1e-2
optimizer = torch.optim.SGD(tudui.parameters(), lr=learning_rate)

# 设置训练网络的一些参数
# 记录训练的次数
total_train_step = 0
# 记录测试的次数
total_test_step = 0
# 训练的轮数
epoch = 10

# 添加tensorboard
writer = SummaryWriter("../logs_train")

for i in range(epoch):
    print("-------第 {} 轮训练开始-------".format(i+1))

    # 训练步骤开始
    tudui.train()
    for data in train_dataloader:
        imgs, targets = data
        outputs = tudui(imgs)
        loss = loss_fn(outputs, targets)

        # 优化器优化模型
        optimizer.zero_grad()
        loss.backward()
        optimizer.step()

        total_train_step = total_train_step + 1
        if total_train_step % 100 == 0:
            print("训练次数：{}, Loss: {}".format(total_train_step, loss.item()))
            writer.add_scalar("train_loss", loss.item(), total_train_step)

    # 测试步骤开始
    tudui.eval()
    total_test_loss = 0
    total_accuracy = 0
    with torch.no_grad():  #不计算梯度，只需要测试模型，不需要利用梯度去优化
        for data in test_dataloader:
            imgs, targets = data
            outputs = tudui(imgs)
            loss = loss_fn(outputs, targets)
            total_test_loss = total_test_loss + loss.item()
            accuracy = (outputs.argmax(1) == targets).sum()
            total_accuracy = total_accuracy + accuracy

    print("整体测试集上的Loss: {}".format(total_test_loss))
    print("整体测试集上的正确率: {}".format(total_accuracy/test_data_size))
    writer.add_scalar("test_loss", total_test_loss, total_test_step)
    writer.add_scalar("test_accuracy", total_accuracy/test_data_size, total_test_step)
    total_test_step = total_test_step + 1

    torch.save(tudui, "tudui_{}.pth".format(i))
    print("模型已保存")

writer.close()
</code></pre> 
<p>输出：</p> 
<p><img alt="" height="109" src="https://images2.imgbox.com/5b/e8/2CdMk1Ji_o.png" width="269"></p> 
<h2 id="%E5%88%A9%E7%94%A8GPU%E8%AE%AD%E7%BB%83">利用GPU训练</h2> 
<h3 id="%E6%96%B9%E5%BC%8F%E4%B8%80%EF%BC%9A">方式一：</h3> 
<p><img alt="" height="136" src="https://images2.imgbox.com/9f/6d/iDPhzPL1_o.png" width="200"></p> 
<p>终端输入nvidia-smi，会出现GPU的信息</p> 
<p><img alt="" height="126" src="https://images2.imgbox.com/bb/06/iJICM3gH_o.png" width="624"></p> 
<p>代码实战：</p> 
<pre><code class="language-python"># -*- coding: utf-8 -*-
# 作者：小土堆
# 公众号：土堆碎念
import torch
import torchvision
from torch.utils.tensorboard import SummaryWriter

# from model import *
# 准备数据集
from torch import nn
from torch.utils.data import DataLoader

train_data = torchvision.datasets.CIFAR10(root="../data", train=True, transform=torchvision.transforms.ToTensor(),
                                          download=True)
test_data = torchvision.datasets.CIFAR10(root="../data", train=False, transform=torchvision.transforms.ToTensor(),
                                         download=True)

# length 长度
train_data_size = len(train_data)
test_data_size = len(test_data)
# 如果train_data_size=10, 训练数据集的长度为：10
print("训练数据集的长度为：{}".format(train_data_size))
print("测试数据集的长度为：{}".format(test_data_size))


# 利用 DataLoader 来加载数据集
train_dataloader = DataLoader(train_data, batch_size=64)
test_dataloader = DataLoader(test_data, batch_size=64)

# 创建网络模型
class Tudui(nn.Module):
    def __init__(self):
        super(Tudui, self).__init__()
        self.model = nn.Sequential(
            nn.Conv2d(3, 32, 5, 1, 2),
            nn.MaxPool2d(2),
            nn.Conv2d(32, 32, 5, 1, 2),
            nn.MaxPool2d(2),
            nn.Conv2d(32, 64, 5, 1, 2),
            nn.MaxPool2d(2),
            nn.Flatten(),
            nn.Linear(64*4*4, 64),
            nn.Linear(64, 10)
        )

    def forward(self, x):
        x = self.model(x)
        return x
tudui = Tudui()
if torch.cuda.is_available():
    tudui = tudui.cuda()

# 损失函数
loss_fn = nn.CrossEntropyLoss()
if torch.cuda.is_available():
    loss_fn = loss_fn.cuda()
# 优化器
# learning_rate = 0.01
# 1e-2=1 x (10)^(-2) = 1 /100 = 0.01
learning_rate = 1e-2
optimizer = torch.optim.SGD(tudui.parameters(), lr=learning_rate)

# 设置训练网络的一些参数
# 记录训练的次数
total_train_step = 0
# 记录测试的次数
total_test_step = 0
# 训练的轮数
epoch = 10

# 添加tensorboard
writer = SummaryWriter("../logs_train")

for i in range(epoch):
    print("-------第 {} 轮训练开始-------".format(i+1))

    # 训练步骤开始
    tudui.train()
    for data in train_dataloader:
        imgs, targets = data
        if torch.cuda.is_available():
            imgs = imgs.cuda()
            targets = targets.cuda()
        outputs = tudui(imgs)
        loss = loss_fn(outputs, targets)

        # 优化器优化模型
        optimizer.zero_grad()
        loss.backward()
        optimizer.step()

        total_train_step = total_train_step + 1
        if total_train_step % 100 == 0:
            print("训练次数：{}, Loss: {}".format(total_train_step, loss.item()))
            writer.add_scalar("train_loss", loss.item(), total_train_step)

    # 测试步骤开始
    tudui.eval()
    total_test_loss = 0
    total_accuracy = 0
    with torch.no_grad():
        for data in test_dataloader:
            imgs, targets = data
            if torch.cuda.is_available():
                imgs = imgs.cuda()
                targets = targets.cuda()
            outputs = tudui(imgs)
            loss = loss_fn(outputs, targets)
            total_test_loss = total_test_loss + loss.item()
            accuracy = (outputs.argmax(1) == targets).sum()
            total_accuracy = total_accuracy + accuracy

    print("整体测试集上的Loss: {}".format(total_test_loss))
    print("整体测试集上的正确率: {}".format(total_accuracy/test_data_size))
    writer.add_scalar("test_loss", total_test_loss, total_test_step)
    writer.add_scalar("test_accuracy", total_accuracy/test_data_size, total_test_step)
    total_test_step = total_test_step + 1

    torch.save(tudui, "tudui_{}.pth".format(i))
    print("模型已保存")

writer.close()
</code></pre> 
<p>输出：</p> 
<p><img alt="" height="132" src="https://images2.imgbox.com/f0/50/sLAfN4yy_o.png" width="281"></p> 
<h3 id="%E6%96%B9%E5%BC%8F%E4%BA%8C%EF%BC%9A">方式二：</h3> 
<p><img alt="" height="191" src="https://images2.imgbox.com/ea/d3/8G3soBYf_o.png" width="283"></p> 
<p>代码实战：</p> 
<pre><code class="language-python"># -*- coding: utf-8 -*-
# 作者：小土堆
# 公众号：土堆碎念
import torch
import torchvision
from torch.utils.tensorboard import SummaryWriter

# from model import *
# 准备数据集
from torch import nn
from torch.utils.data import DataLoader

# 定义训练的设备
device = torch.device("cuda")

train_data = torchvision.datasets.CIFAR10(root="../data", train=True, transform=torchvision.transforms.ToTensor(),
                                          download=True)
test_data = torchvision.datasets.CIFAR10(root="../data", train=False, transform=torchvision.transforms.ToTensor(),
                                         download=True)

# length 长度
train_data_size = len(train_data)
test_data_size = len(test_data)
# 如果train_data_size=10, 训练数据集的长度为：10
print("训练数据集的长度为：{}".format(train_data_size))
print("测试数据集的长度为：{}".format(test_data_size))


# 利用 DataLoader 来加载数据集
train_dataloader = DataLoader(train_data, batch_size=64)
test_dataloader = DataLoader(test_data, batch_size=64)

# 创建网络模型
class Tudui(nn.Module):
    def __init__(self):
        super(Tudui, self).__init__()
        self.model = nn.Sequential(
            nn.Conv2d(3, 32, 5, 1, 2),
            nn.MaxPool2d(2),
            nn.Conv2d(32, 32, 5, 1, 2),
            nn.MaxPool2d(2),
            nn.Conv2d(32, 64, 5, 1, 2),
            nn.MaxPool2d(2),
            nn.Flatten(),
            nn.Linear(64*4*4, 64),
            nn.Linear(64, 10)
        )

    def forward(self, x):
        x = self.model(x)
        return x
tudui = Tudui()
tudui = tudui.to(device)

# 损失函数
loss_fn = nn.CrossEntropyLoss()
loss_fn = loss_fn.to(device)
# 优化器
# learning_rate = 0.01
# 1e-2=1 x (10)^(-2) = 1 /100 = 0.01
learning_rate = 1e-2
optimizer = torch.optim.SGD(tudui.parameters(), lr=learning_rate)

# 设置训练网络的一些参数
# 记录训练的次数
total_train_step = 0
# 记录测试的次数
total_test_step = 0
# 训练的轮数
epoch = 10

# 添加tensorboard
writer = SummaryWriter("../logs_train")

for i in range(epoch):
    print("-------第 {} 轮训练开始-------".format(i+1))

    # 训练步骤开始
    tudui.train()
    for data in train_dataloader:
        imgs, targets = data
        imgs = imgs.to(device)
        targets = targets.to(device)
        outputs = tudui(imgs)
        loss = loss_fn(outputs, targets)

        # 优化器优化模型
        optimizer.zero_grad()
        loss.backward()
        optimizer.step()

        total_train_step = total_train_step + 1
        if total_train_step % 100 == 0:
            print("训练次数：{}, Loss: {}".format(total_train_step, loss.item()))
            writer.add_scalar("train_loss", loss.item(), total_train_step)

    # 测试步骤开始
    tudui.eval()
    total_test_loss = 0
    total_accuracy = 0
    with torch.no_grad():
        for data in test_dataloader:
            imgs, targets = data
            imgs = imgs.to(device)
            targets = targets.to(device)
            outputs = tudui(imgs)
            loss = loss_fn(outputs, targets)
            total_test_loss = total_test_loss + loss.item()
            accuracy = (outputs.argmax(1) == targets).sum()
            total_accuracy = total_accuracy + accuracy

    print("整体测试集上的Loss: {}".format(total_test_loss))
    print("整体测试集上的正确率: {}".format(total_accuracy/test_data_size))
    writer.add_scalar("test_loss", total_test_loss, total_test_step)
    writer.add_scalar("test_accuracy", total_accuracy/test_data_size, total_test_step)
    total_test_step = total_test_step + 1

    torch.save(tudui, "tudui_{}.pth".format(i))
    print("模型已保存")

writer.close()
</code></pre> 
<h2 id="%E5%AE%8C%E6%95%B4%E7%9A%84%E6%A8%A1%E5%9E%8B%E9%AA%8C%E8%AF%81%EF%BC%88%E6%B5%8B%E8%AF%95%EF%BC%8Cdemo%EF%BC%89%E5%A5%97%E8%B7%AF">完整的模型验证（测试，demo）套路</h2> 
<p>路径：</p> 
<p><img alt="" height="608" src="https://images2.imgbox.com/4a/52/5qwKRIur_o.png" width="324"></p> 
<p>一个点：当前同级目录，两个点：返回上一级目录</p> 
<p><img alt="" height="643" src="https://images2.imgbox.com/79/c0/t0aZ8NKg_o.png" width="611"></p> 
<p><img alt="" height="502" src="https://images2.imgbox.com/85/e6/FJ4m7edV_o.png" width="991"></p> 
<p></p> 
<p>代码实战：</p> 
<pre><code class="language-python"># -*- coding: utf-8 -*-
# 作者：小土堆
# 公众号：土堆碎念
import torch
import torchvision
from PIL import Image
from torch import nn

image_path = "../imgs/airplane.png"
image = Image.open(image_path)
print(image)
image = image.convert('RGB')
transform = torchvision.transforms.Compose([torchvision.transforms.Resize((32, 32)),
                                            torchvision.transforms.ToTensor()])

image = transform(image)
print(image.shape)

class Tudui(nn.Module):
    def __init__(self):
        super(Tudui, self).__init__()
        self.model = nn.Sequential(
            nn.Conv2d(3, 32, 5, 1, 2),
            nn.MaxPool2d(2),
            nn.Conv2d(32, 32, 5, 1, 2),
            nn.MaxPool2d(2),
            nn.Conv2d(32, 64, 5, 1, 2),
            nn.MaxPool2d(2),
            nn.Flatten(),
            nn.Linear(64*4*4, 64),
            nn.Linear(64, 10)
        )

    def forward(self, x):
        x = self.model(x)
        return x

model = torch.load("tudui_29_gpu.pth", map_location=torch.device('cpu')) #同一级目录下，直接写文件名表示路径
print(model)
image = torch.reshape(image, (1, 3, 32, 32))
model.eval()  #不要忘记这步
with torch.no_grad(): #不要忘记这步，节约计算开销
    output = model(image)
print(output)

print(output.argmax(1))
</code></pre> 
<p>输出：</p> 
<p><img alt="" height="57" src="https://images2.imgbox.com/e0/4e/CdV2sp9C_o.png" width="461"></p> 
<p>查看类别：</p> 
<p><img alt="" height="232" src="https://images2.imgbox.com/72/d8/Ozcxy1hH_o.png" width="646"></p> 
<h2 id="%E7%9C%8B%E7%9C%8B%E5%BC%80%E6%BA%90%E9%A1%B9%E7%9B%AE" style="background-color:transparent;">看看开源项目</h2> 
<p><img alt="" height="645" src="https://images2.imgbox.com/03/f3/JiOEF9e7_o.png" width="974"></p> 
<p><img alt="" height="155" src="https://images2.imgbox.com/3b/2f/qvhydk8Y_o.png" width="1136"></p> 
<p>所以资料均来自<a class="link-info" href="https://www.bilibili.com/video/BV1hE411t7RN/?spm_id_from=333.337.search-card.all.click" rel="nofollow" title="小土堆b站视频">小土堆b站视频</a>，请关注b站up主：我是土堆</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/37a80208eef0b50252d766442e60d219/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">MediaPipe - 02.人脸识别</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/ac7aabcbd69e5ca15900635b1bf2bea5/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">Java 8 lambda的一个编译bug</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>