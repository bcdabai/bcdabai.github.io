<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>数据结构 | 栈（顺序栈&#43;链栈）的基本实现 - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="数据结构 | 栈（顺序栈&#43;链栈）的基本实现" />
<meta property="og:description" content="学习教材：王红梅《数据结构——从概念到C&#43;&#43;实现》、严蔚敏《数据结构》
学习课程：青岛大学王卓《数据结构与算法基础》
分类专栏：数据结构与算法(C&#43;&#43;)
目录
前言
正文
1.栈的介绍
1.1 栈的概述
1.2 栈的特点
2.栈的基本实现及设计
2.1 顺序栈设计
2.1.1 数据类型设计
2.1.2 算法设计
（1）构造函数
（2）析构函数
（3）入栈操作
（4）创建指定长度的顺序栈
（5）判空操作
（6）出栈操作
（7）取出栈顶元素（不删除）
（8）输出顺序栈长度
（9）遍历打印顺序栈当前元素
2.2 链栈设计
2.2.1 数据类型设计
2.2.2 算法设计
（1）构造函数
（2）析构函数
（3）入栈操作
（4）创建指定长度的链栈
（5）出栈操作
（6）输出链栈长度
（7）判空操作
（8）取出栈顶元素（不删除）
（9）遍历打印链栈当前元素
2.3 菜单设计
2.3.1 主页面菜单设计
2.3.2 二级页面菜单设计
3.全部代码(分文件编写)
SeqStack.h
SeqStack.cpp
LinkedStack.h
LinkedStack.cpp
my_Menu.h
my_Menu.cpp
main.cpp
前言 最近刚在学习《数据结构与算法》，单纯地跟课、看书觉得并不能很好的掌握好这些知识点，所以决定尝试将学习的知识点归纳总结，也将其进行代码实现，强化对知识点的理解。即作为笔记、实践，又作为我的思路分享。因为初学，难免有不正确、不恰当之处，敬请指正！
正文 1.栈的介绍 1.1 栈的概述 栈（stack）是限定仅在表的一端进行插入和删除操作的线性表，允许插入和删除的一端称为栈顶（stack top），另一端为栈底（stack bottom），不含任何数据元素的栈称为空栈。跟据存储结构的不同，栈同样可以分为顺序栈和链栈两种。
1.2 栈的特点 栈可以理解为一种功能受限的线性表，因此栈中的元素同样具有线性关系。但因为其只能通过一端进行元素的插入和删除，入栈、出栈具有顺序性，因此栈还具有“后进先出”的特性。
举个简单的例子：一把枪我们填入子弹后，如果要将最底下（也就是最先放入）的子弹取出来的话，我们需要把在它之后填入的子弹按照顺序取出，即“后进先出”。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/1e330e99a55f43fd8dad0c5ef7c0fc55/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-10-28T14:00:55+08:00" />
<meta property="article:modified_time" content="2023-10-28T14:00:55+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">数据结构 | 栈（顺序栈&#43;链栈）的基本实现</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <blockquote> 
 <p>学习教材：王红梅<strong>《数据结构——从概念到C++实现》、</strong>严蔚敏《<strong>数据结构</strong>》</p> 
 <p>学习课程：青岛大学王卓<strong>《数据结构与算法基础》</strong></p> 
 <p>分类专栏：数据结构与算法(C++)</p> 
</blockquote> 
<p id="main-toc"><strong>目录</strong></p> 
<p id="%E5%89%8D%E8%A8%80-toc" style="margin-left:0px;"><a href="#%E5%89%8D%E8%A8%80" rel="nofollow">前言</a></p> 
<p id="%E6%AD%A3%E6%96%87-toc" style="margin-left:0px;"><a href="#%E6%AD%A3%E6%96%87" rel="nofollow">正文</a></p> 
<p id="1.%E6%A0%88%E7%9A%84%E6%A6%82%E8%BF%B0-toc" style="margin-left:40px;"><a href="#1.%E6%A0%88%E7%9A%84%E6%A6%82%E8%BF%B0" rel="nofollow">1.栈的介绍</a></p> 
<p id="1.1%20%E6%A0%88%E7%9A%84%E6%A6%82%E8%BF%B0-toc" style="margin-left:80px;"><a href="#1.1%20%E6%A0%88%E7%9A%84%E6%A6%82%E8%BF%B0" rel="nofollow">1.1 栈的概述</a></p> 
<p id="1.2%20%E6%A0%88%E7%9A%84%E7%89%B9%E7%82%B9-toc" style="margin-left:80px;"><a href="#1.2%20%E6%A0%88%E7%9A%84%E7%89%B9%E7%82%B9" rel="nofollow">1.2 栈的特点</a></p> 
<p id="2.%E6%A0%88%E7%9A%84%E5%9F%BA%E6%9C%AC%E5%AE%9E%E7%8E%B0%E5%8F%8A%E8%AE%BE%E8%AE%A1-toc" style="margin-left:40px;"><a href="#2.%E6%A0%88%E7%9A%84%E5%9F%BA%E6%9C%AC%E5%AE%9E%E7%8E%B0%E5%8F%8A%E8%AE%BE%E8%AE%A1" rel="nofollow">2.栈的基本实现及设计</a></p> 
<p id="2.1%20%E9%A1%BA%E5%BA%8F%E6%A0%88%E8%AE%BE%E8%AE%A1-toc" style="margin-left:80px;"><a href="#2.1%20%E9%A1%BA%E5%BA%8F%E6%A0%88%E8%AE%BE%E8%AE%A1" rel="nofollow">2.1 顺序栈设计</a></p> 
<p id="2.1.1%20%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E8%AE%BE%E8%AE%A1-toc" style="margin-left:120px;"><a href="#2.1.1%20%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E8%AE%BE%E8%AE%A1" rel="nofollow">2.1.1 数据类型设计</a></p> 
<p id="2.1.2%20%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1-toc" style="margin-left:120px;"><a href="#2.1.2%20%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1" rel="nofollow">2.1.2 算法设计</a></p> 
<p id="%EF%BC%881%EF%BC%89%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0-toc" style="margin-left:160px;"><a href="#%EF%BC%881%EF%BC%89%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0" rel="nofollow">（1）构造函数</a></p> 
<p id="%EF%BC%882%EF%BC%89%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0-toc" style="margin-left:160px;"><a href="#%EF%BC%882%EF%BC%89%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0" rel="nofollow">（2）析构函数</a></p> 
<p id="%EF%BC%883%EF%BC%89%E5%88%9B%E5%BB%BA%E6%8C%87%E5%AE%9A%E9%95%BF%E5%BA%A6%E7%9A%84%E9%A1%BA%E5%BA%8F%E6%A0%88-toc" style="margin-left:120px;"><a href="#%EF%BC%883%EF%BC%89%E5%88%9B%E5%BB%BA%E6%8C%87%E5%AE%9A%E9%95%BF%E5%BA%A6%E7%9A%84%E9%A1%BA%E5%BA%8F%E6%A0%88" rel="nofollow">（3）入栈操作</a></p> 
<p id="%EF%BC%884%EF%BC%89%E5%85%A5%E6%A0%88%E6%93%8D%E4%BD%9C-toc" style="margin-left:120px;"><a href="#%EF%BC%884%EF%BC%89%E5%85%A5%E6%A0%88%E6%93%8D%E4%BD%9C" rel="nofollow">（4）创建指定长度的顺序栈</a></p> 
<p id="%EF%BC%885%EF%BC%89%E5%88%A4%E7%A9%BA%E6%93%8D%E4%BD%9C-toc" style="margin-left:160px;"><a href="#%EF%BC%885%EF%BC%89%E5%88%A4%E7%A9%BA%E6%93%8D%E4%BD%9C" rel="nofollow">（5）判空操作</a></p> 
<p id="%EF%BC%885%EF%BC%89%E5%87%BA%E6%A0%88%E6%93%8D%E4%BD%9C-toc" style="margin-left:120px;"><a href="#%EF%BC%885%EF%BC%89%E5%87%BA%E6%A0%88%E6%93%8D%E4%BD%9C" rel="nofollow">（6）出栈操作</a></p> 
<p id="%EF%BC%887%EF%BC%89%E5%8F%96%E5%87%BA%E6%A0%88%E9%A1%B6%E5%85%83%E7%B4%A0%EF%BC%88%E4%B8%8D%E5%88%A0%E9%99%A4%EF%BC%89-toc" style="margin-left:120px;"><a href="#%EF%BC%887%EF%BC%89%E5%8F%96%E5%87%BA%E6%A0%88%E9%A1%B6%E5%85%83%E7%B4%A0%EF%BC%88%E4%B8%8D%E5%88%A0%E9%99%A4%EF%BC%89" rel="nofollow">（7）取出栈顶元素（不删除）</a></p> 
<p id="%EF%BC%888%EF%BC%89%E8%BE%93%E5%87%BA%E9%A1%BA%E5%BA%8F%E6%A0%88%E9%95%BF%E5%BA%A6-toc" style="margin-left:120px;"><a href="#%EF%BC%888%EF%BC%89%E8%BE%93%E5%87%BA%E9%A1%BA%E5%BA%8F%E6%A0%88%E9%95%BF%E5%BA%A6" rel="nofollow">（8）输出顺序栈长度</a></p> 
<p id="%EF%BC%889%EF%BC%89%E9%81%8D%E5%8E%86%E6%89%93%E5%8D%B0%E9%A1%BA%E5%BA%8F%E6%A0%88%E5%BD%93%E5%89%8D%E5%85%83%E7%B4%A0-toc" style="margin-left:120px;"><a href="#%EF%BC%889%EF%BC%89%E9%81%8D%E5%8E%86%E6%89%93%E5%8D%B0%E9%A1%BA%E5%BA%8F%E6%A0%88%E5%BD%93%E5%89%8D%E5%85%83%E7%B4%A0" rel="nofollow">（9）遍历打印顺序栈当前元素</a></p> 
<p id="2.2%20%E9%93%BE%E6%A0%88%E8%AE%BE%E8%AE%A1-toc" style="margin-left:80px;"><a href="#2.2%20%E9%93%BE%E6%A0%88%E8%AE%BE%E8%AE%A1" rel="nofollow">2.2 链栈设计</a></p> 
<p id="2.2.1%20%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E8%AE%BE%E8%AE%A1-toc" style="margin-left:120px;"><a href="#2.2.1%20%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E8%AE%BE%E8%AE%A1" rel="nofollow">2.2.1 数据类型设计</a></p> 
<p id="2.2.2%20%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1-toc" style="margin-left:120px;"><a href="#2.2.2%20%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1" rel="nofollow">2.2.2 算法设计</a></p> 
<p id="%EF%BC%881%EF%BC%89%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0-toc" style="margin-left:160px;"><a href="#%EF%BC%881%EF%BC%89%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0" rel="nofollow">（1）构造函数</a></p> 
<p id="%EF%BC%882%EF%BC%89%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0-toc" style="margin-left:160px;"><a href="#%EF%BC%882%EF%BC%89%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0" rel="nofollow">（2）析构函数</a></p> 
<p id="%EF%BC%883%EF%BC%89%E5%85%A5%E6%A0%88%E6%93%8D%E4%BD%9C-toc" style="margin-left:120px;"><a href="#%EF%BC%883%EF%BC%89%E5%85%A5%E6%A0%88%E6%93%8D%E4%BD%9C" rel="nofollow">（3）入栈操作</a></p> 
<p id="%EF%BC%884%EF%BC%89%E5%88%9B%E5%BB%BA%E6%8C%87%E5%AE%9A%E9%95%BF%E5%BA%A6%E7%9A%84%E9%93%BE%E6%A0%88-toc" style="margin-left:120px;"><a href="#%EF%BC%884%EF%BC%89%E5%88%9B%E5%BB%BA%E6%8C%87%E5%AE%9A%E9%95%BF%E5%BA%A6%E7%9A%84%E9%93%BE%E6%A0%88" rel="nofollow">（4）创建指定长度的链栈</a></p> 
<p id="%EF%BC%885%EF%BC%89%E5%87%BA%E6%A0%88%E6%93%8D%E4%BD%9C-toc" style="margin-left:120px;"><a href="#%EF%BC%885%EF%BC%89%E5%87%BA%E6%A0%88%E6%93%8D%E4%BD%9C" rel="nofollow">（5）出栈操作</a></p> 
<p id="%EF%BC%886%EF%BC%89%E5%88%A4%E7%A9%BA%E6%93%8D%E4%BD%9C-toc" style="margin-left:120px;"><a href="#%EF%BC%886%EF%BC%89%E5%88%A4%E7%A9%BA%E6%93%8D%E4%BD%9C" rel="nofollow">（6）输出链栈长度</a></p> 
<p id="%EF%BC%887%EF%BC%89%E5%88%A4%E7%A9%BA%E6%93%8D%E4%BD%9C-toc" style="margin-left:120px;"><a href="#%EF%BC%887%EF%BC%89%E5%88%A4%E7%A9%BA%E6%93%8D%E4%BD%9C" rel="nofollow">（7）判空操作</a></p> 
<p id="%EF%BC%888%EF%BC%89%E5%8F%96%E5%87%BA%E6%A0%88%E9%A1%B6%E5%85%83%E7%B4%A0%EF%BC%88%E4%B8%8D%E5%88%A0%E9%99%A4%EF%BC%89-toc" style="margin-left:120px;"><a href="#%EF%BC%888%EF%BC%89%E5%8F%96%E5%87%BA%E6%A0%88%E9%A1%B6%E5%85%83%E7%B4%A0%EF%BC%88%E4%B8%8D%E5%88%A0%E9%99%A4%EF%BC%89" rel="nofollow">（8）取出栈顶元素（不删除）</a></p> 
<p id="%EF%BC%889%EF%BC%89%E9%81%8D%E5%8E%86%E6%89%93%E5%8D%B0%E9%93%BE%E6%A0%88%E5%BD%93%E5%89%8D%E5%85%83%E7%B4%A0-toc" style="margin-left:120px;"><a href="#%EF%BC%889%EF%BC%89%E9%81%8D%E5%8E%86%E6%89%93%E5%8D%B0%E9%93%BE%E6%A0%88%E5%BD%93%E5%89%8D%E5%85%83%E7%B4%A0" rel="nofollow">（9）遍历打印链栈当前元素</a></p> 
<p id="2.3%20%E8%8F%9C%E5%8D%95%E8%AE%BE%E8%AE%A1-toc" style="margin-left:80px;"><a href="#2.3%20%E8%8F%9C%E5%8D%95%E8%AE%BE%E8%AE%A1" rel="nofollow">2.3 菜单设计</a></p> 
<p id="2.3.1%20%E4%B8%BB%E9%A1%B5%E9%9D%A2%E8%8F%9C%E5%8D%95%E8%AE%BE%E8%AE%A1-toc" style="margin-left:120px;"><a href="#2.3.1%20%E4%B8%BB%E9%A1%B5%E9%9D%A2%E8%8F%9C%E5%8D%95%E8%AE%BE%E8%AE%A1" rel="nofollow">2.3.1 主页面菜单设计</a></p> 
<p id="2.3.2%20%E4%BA%8C%E7%BA%A7%E9%A1%B5%E9%9D%A2%E8%8F%9C%E5%8D%95%E8%AE%BE%E8%AE%A1-toc" style="margin-left:120px;"><a href="#2.3.2%20%E4%BA%8C%E7%BA%A7%E9%A1%B5%E9%9D%A2%E8%8F%9C%E5%8D%95%E8%AE%BE%E8%AE%A1" rel="nofollow">2.3.2 二级页面菜单设计</a></p> 
<p id="3.%E5%85%A8%E9%83%A8%E4%BB%A3%E7%A0%81-toc" style="margin-left:40px;"><a href="#3.%E5%85%A8%E9%83%A8%E4%BB%A3%E7%A0%81" rel="nofollow">3.全部代码(分文件编写)</a></p> 
<p id="SeqStack.h-toc" style="margin-left:80px;"><a href="#SeqStack.h" rel="nofollow">SeqStack.h</a></p> 
<p id="SeqStack.cpp-toc" style="margin-left:80px;"><a href="#SeqStack.cpp" rel="nofollow">SeqStack.cpp</a></p> 
<p id="LinkedStack.h-toc" style="margin-left:80px;"><a href="#LinkedStack.h" rel="nofollow">LinkedStack.h</a></p> 
<p id="LinkedStack.cpp-toc" style="margin-left:80px;"><a href="#LinkedStack.cpp" rel="nofollow">LinkedStack.cpp</a></p> 
<p id="my_Menu.h-toc" style="margin-left:80px;"><a href="#my_Menu.h" rel="nofollow">my_Menu.h</a></p> 
<p id="my_Menu.cpp-toc" style="margin-left:80px;"><a href="#my_Menu.cpp" rel="nofollow">my_Menu.cpp</a></p> 
<p id="main.cpp-toc" style="margin-left:80px;"><a href="#main.cpp" rel="nofollow">main.cpp</a></p> 
<hr id="hr-toc"> 
<p></p> 
<h2 id="%E5%89%8D%E8%A8%80">前言</h2> 
<p>        最近刚在学习《数据结构与算法》，单纯地跟课、看书觉得并不能很好的掌握好这些知识点，所以决定尝试将学习的知识点归纳总结，也将其进行代码实现，强化对知识点的理解。即作为笔记、实践，又作为我的思路分享。因为初学，难免有不正确、不恰当之处，敬请指正！</p> 
<h2 id="%E6%AD%A3%E6%96%87">正文</h2> 
<h3 id="1.%E6%A0%88%E7%9A%84%E6%A6%82%E8%BF%B0">1.栈的介绍</h3> 
<h4 id="1.1%20%E6%A0%88%E7%9A%84%E6%A6%82%E8%BF%B0">1.1 栈的概述</h4> 
<p>        <strong>栈</strong>（stack）是限定仅在表的一端进行插入和删除操作的线性表，允许插入和删除的一端称为<strong>栈顶</strong>（stack top），另一端为<strong>栈底</strong>（stack bottom），不含任何数据元素的栈称为空栈。跟据存储结构的不同，栈同样可以分为顺序栈和链栈两种。</p> 
<h4 id="1.2%20%E6%A0%88%E7%9A%84%E7%89%B9%E7%82%B9">1.2 栈的特点</h4> 
<p>        栈可以理解为一种功能受限的线性表，因此栈中的元素同样具有<strong>线性关系</strong>。但因为其只能通过一端进行元素的插入和删除，入栈、出栈具有顺序性，因此栈还具有“<strong>后进先出”</strong>的特性。</p> 
<p>        举个简单的例子：一把枪我们填入子弹后，如果要将最底下（也就是最先放入）的子弹取出来的话，我们需要把在它之后填入的子弹按照顺序取出，即“后进先出”。</p> 
<h3 id="2.%E6%A0%88%E7%9A%84%E5%9F%BA%E6%9C%AC%E5%AE%9E%E7%8E%B0%E5%8F%8A%E8%AE%BE%E8%AE%A1">2.栈的基本实现及设计</h3> 
<h4 id="2.1%20%E9%A1%BA%E5%BA%8F%E6%A0%88%E8%AE%BE%E8%AE%A1">2.1 顺序栈设计</h4> 
<h5 id="2.1.1%20%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E8%AE%BE%E8%AE%A1">2.1.1 数据类型设计</h5> 
<p>        首先定义一个模板类SeqStack，其成员变量有两个，一个是存储数据的数组data，一个是存储顺序栈栈顶元素序号的变量top，为保证数据的安全性，均将权限设为私有。为实现数据的一系列操作，又创建了相应的成员函数，将其权限设置为公有，作为成员变量的接口，供测试者使用。</p> 
<pre><code class="language-cpp">#define MAXSIZE 100 // 顺序栈最多可以存储多少个元素，可按要求更改

template&lt;typename DataType&gt;
class SeqStack
{
public:
	SeqStack();						// 构造函数，初始化一个空栈
	~SeqStack() {};					// 析构函数
	void CreateSeqStack();
	void Push(DataType x); 			// 入栈操作，将元素x入栈
	DataType Pop();					// 出栈操作，将栈顶元素弹出，并返回弹出的元素值
	DataType GetTop();				// 取出栈顶元素（并不删除）
	int Length();					// 求顺序栈长度
	int Empty();					// 判空操作
	void PrintStack();			    // 遍历打印，按照出栈顺序打印

private:
	DataType data[MAXSIZE];         // 存储元素的数据
	int top;                        // 存储栈顶元素的下标
};</code></pre> 
<h5 id="2.1.2%20%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1">2.1.2 算法设计</h5> 
<h6 id="%EF%BC%881%EF%BC%89%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0">（1）构造函数</h6> 
<p>        即将顺序栈进行初始化，只需将栈顶指针top置为-1即可。</p> 
<pre><code class="language-cpp">template&lt;typename DataType&gt;
SeqStack&lt;DataType&gt;::SeqStack()
{
	this-&gt;top = -1;
}</code></pre> 
<h6 id="%EF%BC%882%EF%BC%89%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0">（2）析构函数</h6> 
<p>        顺序栈为静态存储分配，在顺序栈变量退出作用域时，将自动释放顺序栈所占存储空间，因此无须销毁，析构函数为空。</p> 
<h5 id="%EF%BC%883%EF%BC%89%E5%88%9B%E5%BB%BA%E6%8C%87%E5%AE%9A%E9%95%BF%E5%BA%A6%E7%9A%84%E9%A1%BA%E5%BA%8F%E6%A0%88">（3）入栈操作</h5> 
<p>       首先应判断栈是否为满，即top+1是否等于 MAXSIZE 。若未满， 在栈中插入元素n只需要将栈顶位置加1，然后在data[top]的位置填入元素x。</p> 
<pre><code class="language-cpp">template&lt;typename DataType&gt;
void SeqStack&lt;DataType&gt;::Push(DataType x)
{
	if (this-&gt;top+1 == MAXSIZE) throw"上溢";
	this-&gt;data[top + 1] = x;
	this-&gt;top++;
}</code></pre> 
<h5 id="%EF%BC%884%EF%BC%89%E5%85%A5%E6%A0%88%E6%93%8D%E4%BD%9C">（4）创建指定长度的顺序栈</h5> 
<p>        创建长度为n的顺序栈，即按照输入顺序，对一个空栈进行n次入栈。</p> 
<pre><code class="language-cpp">template&lt;typename DataType&gt;
void SeqStack&lt;DataType&gt;::CreateSeqStack()
{
	int num, value;
	cout &lt;&lt; "请输入要入栈的元素个数：";
	cin &gt;&gt; num;
	cout &lt;&lt; "请输入要入栈的元素数值：";
	for (int i = 0; i &lt; num; i++)
	{
		cin &gt;&gt; value;
		this-&gt;data[i] = value;
		this-&gt;top++;
	}
}</code></pre> 
<h6 id="%EF%BC%885%EF%BC%89%E5%88%A4%E7%A9%BA%E6%93%8D%E4%BD%9C">（5）判空操作</h6> 
<p>        判空操作只需要判断顺序栈类成员函数top是否等于-1，即 this-&gt;top==-1。</p> 
<pre><code class="language-cpp">template&lt;typename DataType&gt;
int SeqStack&lt;DataType&gt;::Empty()
{
	if (this-&gt;top==-1)		
		return 1;
	else
		return 0;
}</code></pre> 
<h5 id="%EF%BC%885%EF%BC%89%E5%87%BA%E6%A0%88%E6%93%8D%E4%BD%9C">（6）出栈操作</h5> 
<p>        将一个元素从顺序栈中删除，即出栈，首先应判断栈是否为空，即this-&gt;Empty（）是否等于1。若栈非空，出栈操作只需取出栈顶元素，然后top再减1。</p> 
<pre><code class="language-cpp">template&lt;typename DataType&gt;
DataType SeqStack&lt;DataType&gt;::Pop()
{
	DataType y;
	if (this-&gt;Empty() == 1) throw"下溢";
	y = this-&gt;data[top];
	this-&gt;top--;
	return y;
}</code></pre> 
<h5 id="%EF%BC%887%EF%BC%89%E5%8F%96%E5%87%BA%E6%A0%88%E9%A1%B6%E5%85%83%E7%B4%A0%EF%BC%88%E4%B8%8D%E5%88%A0%E9%99%A4%EF%BC%89">（7）取出栈顶元素（不删除）</h5> 
<p>        取栈顶元素只是将top位置的栈顶元素取出并返回，并不改变栈本身。</p> 
<pre><code class="language-cpp">template&lt;typename DataType&gt;
DataType SeqStack&lt;DataType&gt;::GetTop()
{
	DataType y;
	if (this-&gt;Length() == 0) throw"下溢";
	// if (this-&gt;Empty == 1) throw"下溢";
	y = this-&gt;data[top];
	return y;

}</code></pre> 
<h5 id="%EF%BC%888%EF%BC%89%E8%BE%93%E5%87%BA%E9%A1%BA%E5%BA%8F%E6%A0%88%E9%95%BF%E5%BA%A6">（8）输出顺序栈长度</h5> 
<p>        输出顺序栈的长度，就是将top加1后再返回。</p> 
<pre><code class="language-cpp">template&lt;typename DataType&gt;
int SeqStack&lt;DataType&gt;::Length()
{
	return this-&gt;top+1;
}</code></pre> 
<h5 id="%EF%BC%889%EF%BC%89%E9%81%8D%E5%8E%86%E6%89%93%E5%8D%B0%E9%A1%BA%E5%BA%8F%E6%A0%88%E5%BD%93%E5%89%8D%E5%85%83%E7%B4%A0">（9）遍历打印顺序栈当前元素</h5> 
<p>        通过前面所写的Length()，得到顺序栈的长度，使用循环，从栈底开始遍历打印。</p> 
<pre><code class="language-cpp">template&lt;typename datatype&gt;
void SeqStack&lt;datatype&gt;::PrintStack()
{
	int length = this-&gt;Length();

	if (length &gt; 0)
	{
		for (int i = 0; i &lt; length; i++)
			cout &lt;&lt;this-&gt;data[i] &lt;&lt; " ";
		cout &lt;&lt; endl;
	}
	else
		cout &lt;&lt; "顺序栈为空" &lt;&lt; endl;
}</code></pre> 
<h4 id="2.2%20%E9%93%BE%E6%A0%88%E8%AE%BE%E8%AE%A1">2.2 链栈设计</h4> 
<h5 id="2.2.1%20%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E8%AE%BE%E8%AE%A1">2.2.1 数据类型设计</h5> 
<p style="margin-left:0;text-align:justify;">        首先使用结构体创建LinkedNode数据类型，定义了结点，包括指针域next和数据域data。随后定义链栈类LinkedStack，其成员变量为LinkedNode类型的指针top，为保证数据的安全性，将权限设为私有。为实现数据的一系列操作，又创建了相应的成员函数，将其权限设置为公有，作为成员变量的接口，供测试者使用。</p> 
<pre><code class="language-cpp">// 定义了LinkNode结点
template&lt;typename DataType&gt;
struct LinkNode {
	DataType data;//数据域
	LinkNode&lt;DataType&gt;* next;//指针域 
};

template&lt;typename DataType&gt;
class LinkedStack
{
public:
	LinkedStack() { top = NULL; }		// 构造函数，初始化一个空栈
	~LinkedStack();					// 析构函数
	void CreateLinkedStack();
	void Push(DataType x); 			    // 入栈操作，将元素x入栈
	DataType Pop();					    // 出栈操作，将栈顶元素弹出，并返回弹出的元素值
	DataType GetTop();				    // 取出栈顶元素（并不删除）
	int Length();					    // 求顺序栈长度
	int Empty();					    // 判空操作
	void PrintStack();		            // 遍历打印，按照出栈顺序打印

private:
	LinkNode&lt;DataType&gt;* top;
};
</code></pre> 
<h5 id="2.2.2%20%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1" style="margin-left:0px;text-align:justify;">2.2.2 算法设计</h5> 
<h6>（1）构造函数</h6> 
<p>        链栈不带头结点，初始化一个空链栈只需将栈顶指针top置空。</p> 
<pre><code class="language-cpp">template&lt;typename DataType&gt;
LinkedStack&lt;DataType&gt;::LinkedStack()
 { 
    top = NULL; 
}</code></pre> 
<h6>（2）析构函数</h6> 
<p>        链栈为动态存储分配，在链栈变量退出作用域前要释放链栈的存储空间。</p> 
<pre><code class="language-cpp">template&lt;typename DataType&gt;
LinkedStack&lt;DataType&gt;::~LinkedStack()
{
	LinkNode&lt;DataType&gt;* p = top;
	while (this-&gt;top)
	{
		top = top-&gt;next;
		delete p;
		p = top;
	}
}</code></pre> 
<h5 id="%EF%BC%883%EF%BC%89%E5%85%A5%E6%A0%88%E6%93%8D%E4%BD%9C">（3）入栈操作</h5> 
<p>        链栈的插入只需处理栈顶的情况，先申请一个新结点s，在其数据域中存入入栈元素、指针域存入top的地址，再使top=s。</p> 
<pre><code class="language-cpp">template&lt;typename DataType&gt;
void LinkedStack&lt;DataType&gt;::Push(DataType x)
{
	// 申请一个数据域为x的结点s
	LinkNode&lt;DataType&gt;* s = new LinkNode&lt;DataType&gt;;
	if (!s)
	{
		cout &lt;&lt; "分配内存失败";
		return;
	}
	s-&gt;data = x;
	s-&gt;next = top;
	top = s;
}</code></pre> 
<h5 id="%EF%BC%884%EF%BC%89%E5%88%9B%E5%BB%BA%E6%8C%87%E5%AE%9A%E9%95%BF%E5%BA%A6%E7%9A%84%E9%93%BE%E6%A0%88">（4）创建指定长度的链栈</h5> 
<p>        创建长度为n的链栈，即按照输入顺序，对一个空链栈进行n次入栈。</p> 
<pre><code class="language-cpp">template&lt;typename DataType&gt;
void LinkedStack&lt;DataType&gt;::CreateLinkedStack()
{
	this-&gt;top = nullptr;
	LinkNode&lt;DataType&gt;* s = nullptr;

	int num, value;
	cout &lt;&lt; "请输入要创建的链栈长度：";
	cin &gt;&gt; num;
	cout &lt;&lt; "请输入入栈的元素数值：";

	for (int i = 0; i &lt; num; i++) 
	{
		cin &gt;&gt; value;
		LinkNode&lt;DataType&gt;* newNode = new LinkNode&lt;DataType&gt;;
		newNode-&gt;data = value;
		newNode-&gt;next = top;
		top = newNode;
	}
}</code></pre> 
<h5>（5）出栈操作</h5> 
<p>        链栈的删除操作只需处理栈顶的情况，创建一个临时结点temp，使temp=top，将栈顶元素取出，随后使top=top-&gt;next，使栈顶指针top指向下一结点。将temp的数据域取出存于新定义的变量y中，随后释放结点temp（原栈顶元素）。</p> 
<pre><code class="language-cpp">template&lt;typename DataType&gt;
DataType LinkedStack&lt;DataType&gt;::Pop()
{
	if (this-&gt;Empty() == 1) throw"下溢";

	LinkNode&lt;DataType&gt;* temp = top;
	top = top-&gt;next;
	int y = temp-&gt;data;
	delete temp;
	return y;
}</code></pre> 
<h5 id="%EF%BC%886%EF%BC%89%E5%88%A4%E7%A9%BA%E6%93%8D%E4%BD%9C">（6）输出链栈长度</h5> 
<p>        定义了变量length用于计数，在循环中遍历链栈，直至到栈底元素为止，判定的依据为结点的next域为空。</p> 
<pre><code class="language-cpp">template&lt;typename DataType&gt;
int LinkedStack&lt;DataType&gt;::Length()
{
	int length = 0;
	LinkNode&lt;DataType&gt;* current = this-&gt;top;
	while (current != nullptr) {
		current = current-&gt;next;
		length++;
	}
	return length;
}</code></pre> 
<h5 id="%EF%BC%887%EF%BC%89%E5%88%A4%E7%A9%BA%E6%93%8D%E4%BD%9C">（7）判空操作</h5> 
<p>        使用前面所写的Length()函数进行判空。</p> 
<pre><code class="language-cpp">template&lt;typename DataType&gt;
int LinkedStack&lt;DataType&gt;::Empty()
{
	if (this-&gt;Length() == 0)
	{
		return 1;
	}
	else
		return 0;
}</code></pre> 
<h5 id="%EF%BC%888%EF%BC%89%E5%8F%96%E5%87%BA%E6%A0%88%E9%A1%B6%E5%85%83%E7%B4%A0%EF%BC%88%E4%B8%8D%E5%88%A0%E9%99%A4%EF%BC%89">（8）取出栈顶元素（不删除）</h5> 
<p>        取栈顶元素只需返回栈顶指针top所指结点的数据域，并不修改栈顶指针。</p> 
<pre><code class="language-cpp">template&lt;typename DataType&gt;
DataType LinkedStack&lt;DataType&gt;::GetTop()
{
	if (this-&gt;Empty() == 1) throw"下溢";

	return top-&gt;data;
}</code></pre> 
<h5 id="%EF%BC%889%EF%BC%89%E9%81%8D%E5%8E%86%E6%89%93%E5%8D%B0%E9%93%BE%E6%A0%88%E5%BD%93%E5%89%8D%E5%85%83%E7%B4%A0">（9）遍历打印链栈当前元素</h5> 
<pre><code class="language-cpp">template&lt;typename DataType&gt;
void LinkedStack&lt;DataType&gt;::PrintStack()
{
	LinkNode&lt;DataType&gt;* current = this-&gt;top;

	cout &lt;&lt; "当前链表中的元素为：";
	while (current != nullptr) {
		cout &lt;&lt; current-&gt;data &lt;&lt; " ";
		current = current-&gt;next;
	}
	cout &lt;&lt; endl;
}</code></pre> 
<h4 id="2.3%20%E8%8F%9C%E5%8D%95%E8%AE%BE%E8%AE%A1">2.3 菜单设计</h4> 
<h5 id="2.3.1%20%E4%B8%BB%E9%A1%B5%E9%9D%A2%E8%8F%9C%E5%8D%95%E8%AE%BE%E8%AE%A1">2.3.1 主页面菜单设计</h5> 
<p>        主页面菜单（即一级菜单）使用switch-case语句实现。先定义一个choice_one变量，将输入的数值存入，通过判断choice_one来进入不同二级页面或退出。</p> 
<pre><code class="language-cpp">int choice_one;
	choice_one = -1;
	while (choice_one != 0)
	{
		cout &lt;&lt; "栈示例：" &lt;&lt; endl;
		cout &lt;&lt; "1. 顺序栈功能实现" &lt;&lt; endl;
		cout &lt;&lt; "2. 链栈功能实现" &lt;&lt; endl;
		cout &lt;&lt; "0. 退出" &lt;&lt; endl;
		cout &lt;&lt; "请选择:" &lt;&lt; endl;
		cin &gt;&gt; choice_one;
		system("cls");

		switch (choice_one)
		{
		case 1:// 
			SeqStackMenu();
			system("pause");
			system("cls");
			break;

		case 2:// 
			LinkedStackMenu();
			system("pause");
			system("cls");
			break;

		case 0: // 0.退出
			cout &lt;&lt; "欢迎下次使用！" &lt;&lt; endl;
			system("pause");
			return 0;
			break;

		default:
			cout &lt;&lt; "非法输入，请重新选择！" &lt;&lt; endl;
			system("pause");
			system("cls");
			break;

		}
	}</code></pre> 
<h5 id="2.3.2%20%E4%BA%8C%E7%BA%A7%E9%A1%B5%E9%9D%A2%E8%8F%9C%E5%8D%95%E8%AE%BE%E8%AE%A1">2.3.2 二级页面菜单设计</h5> 
<p>       因为二级菜单内容较多，并未和一级菜单写在一个文件中，而是采取了分文件编写的思想，创建了my_menu.cpp和My_menu.h，将二级菜单存入其中。顺序栈和链栈的功能菜单分别写成函数，然后再直接在一级菜单中进行调用。为区分开，二级菜单定义了新的变量choice_two，用来存储二级菜单的选择数值。</p> 
<pre><code class="language-cpp">// 顺序栈的功能菜单
void SeqStackMenu()
{
	SeqStack&lt;int&gt; Seq;
	/* 注意重置choice_two的值，否则将会再次进入会变为0，无法开始循环 */
	int choice_two = -1;

	while (choice_two)
	{
		cout &lt;&lt; "顺序栈示例：" &lt;&lt; endl;
		cout &lt;&lt; "1. 创建指定长度的顺序栈" &lt;&lt; endl;
		cout &lt;&lt; "2. 将指定元素入栈" &lt;&lt; endl;
		cout &lt;&lt; "3. 弹出栈顶元素" &lt;&lt; endl;
		cout &lt;&lt; "4. 输出栈顶元素数值" &lt;&lt; endl;
		cout &lt;&lt; "5. 输出顺序栈的长度" &lt;&lt; endl;
		cout &lt;&lt; "6. 遍历打印顺序栈" &lt;&lt; endl;
		cout &lt;&lt; "0. 返回上一级菜单" &lt;&lt; endl;
		cout &lt;&lt; "请选择:" &lt;&lt; endl;
		cin &gt;&gt; choice_two;

		switch (choice_two)
		{
		case 1:
			try
			{
				Seq.CreateSeqStack();
				cout &lt;&lt; "顺序栈的元素为:(从栈底开始遍历)" &lt;&lt; endl;
				Seq.PrintStack();
				system("pause");
				system("cls");
				break;
			}
			catch (const char* s)
			{
				cout &lt;&lt; s &lt;&lt; endl;
				system("pause");
				system("cls");
				break;
			}
		case 2:
			try
			{
				int value;
				cout &lt;&lt; "请输入将要入栈的元素数值" &lt;&lt; endl;
				cin &gt;&gt; value;
				Seq.Push(value);
				cout &lt;&lt; "顺序栈的元素为:(从栈底开始遍历)" &lt;&lt; endl;
				Seq.PrintStack();
				system("pause");
				system("cls");
				break;
			}
			catch (const char* s)
			{
				cout &lt;&lt; s &lt;&lt; endl;
				system("pause");
				system("cls");
				break;
			}
		case 3:
			try
			{
				int value = Seq.Pop();
				cout &lt;&lt; "弹出的栈顶元素的数值为：" &lt;&lt; value &lt;&lt; endl;
				system("pause");
				system("cls");
				break;
			}
			catch (const char* s)
			{
				cout &lt;&lt; s &lt;&lt; endl;
				system("pause");
				system("cls");
				break;
			}
		case 4:
			try
			{
				cout &lt;&lt; "当前顺序栈的栈顶元素数值为：" &lt;&lt; Seq.GetTop() &lt;&lt; endl;
				system("pause");
				system("cls");
				break;
			}
			catch (const char* s)
			{
				cout &lt;&lt; s &lt;&lt; endl;
				system("pause");
				system("cls");
				break;
			}
		case 5:
			try
			{
				cout &lt;&lt; "当前顺序栈的长度为：" &lt;&lt; Seq.Length() &lt;&lt; endl;
				system("pause");
				system("cls");
				break;
			}
			catch (const char* s)
			{
				cout &lt;&lt; s &lt;&lt; endl;
				system("pause");
				system("cls");
				break;
			}
		case 6:
			try
			{
				cout &lt;&lt; "当前顺序栈的元素为:(从栈底开始遍历)" &lt;&lt; endl;
				Seq.PrintStack();
				system("pause");
				system("cls");
				break;
			}
			catch (const char* s)
			{
				cout &lt;&lt; s &lt;&lt; endl;
				system("pause");
				system("cls");
				break;
			}
		case 0:
			cout &lt;&lt; "退出顺序栈功能菜单！" &lt;&lt; endl;
			break;

		default:
			cout &lt;&lt; "非法输入，请重新选择！" &lt;&lt; endl;
			system("pause");
			system("cls");
			break;
		}
	}
}


// 链栈的功能菜单
void LinkedStackMenu()
{
	LinkedStack&lt;int&gt; Link;
	int choice_two = -1;

	while (choice_two)
	{
		cout &lt;&lt; "链栈示例：" &lt;&lt; endl;
		cout &lt;&lt; "1. 创建指定长度的链栈" &lt;&lt; endl;
		cout &lt;&lt; "2. 将指定元素入栈" &lt;&lt; endl;
		cout &lt;&lt; "3. 弹出栈顶元素" &lt;&lt; endl;
		cout &lt;&lt; "4. 输出栈顶元素数值" &lt;&lt; endl;
		cout &lt;&lt; "5. 输出链栈的长度" &lt;&lt; endl;
		cout &lt;&lt; "6. 遍历打印链栈" &lt;&lt; endl;
		cout &lt;&lt; "0. 返回上一级菜单" &lt;&lt; endl;
		cout &lt;&lt; "请选择:" &lt;&lt; endl;
		cin &gt;&gt; choice_two;

		switch(choice_two)
		{
		case 1:
			try
			{
				Link.CreateLinkedStack();
				Link.PrintStack();
				system("pause");
				system("cls");
				break;
			}
			catch (const char* s)
			{
				cout &lt;&lt; s &lt;&lt; endl;
				system("pause");
				system("cls");
				break;
			}
		case 2:
			try
			{
				int value;
				cout &lt;&lt; "请输入将入栈的元素数值：";
				cin &gt;&gt; value;
				Link.Push(value);
				Link.PrintStack();
				system("pause");
				system("cls");
				break;
			}
			catch (const char* s)
			{
				cout &lt;&lt; s &lt;&lt; endl;
				system("pause");
				system("cls");
				break;
			}
		case 3:
			try
			{
				int value = Link.Pop();
				cout &lt;&lt; "弹出的栈顶元素数值为：" &lt;&lt; value &lt;&lt; endl;
				system("pause");
				system("cls");
				break;
			}
			catch (const char* s)
			{
				cout &lt;&lt; s &lt;&lt; endl;
				system("pause");
				system("cls");
				break;
			}
		case 4:
			try
			{
				cout &lt;&lt; "栈顶元素的数值为：" &lt;&lt; Link.GetTop() &lt;&lt; endl;
				system("pause");
				system("cls");
				break;
			}
			catch (const char* s)
			{
				cout &lt;&lt; s &lt;&lt; endl;
				system("pause");
				system("cls");
				break;
			}
		case 5:
			try
			{
				int length = Link.Length();
				cout &lt;&lt; "当前链表的长度为：" &lt;&lt; length &lt;&lt; endl;
				system("pause");
				system("cls");
				break;
			}
			catch (const char* s)
			{
				cout &lt;&lt; s &lt;&lt; endl;
				system("pause");
				system("cls");
				break;
			}
		case 6:
			try
			{
				Link.PrintStack();
				system("pause");
				system("cls");
				break;
			}
			catch (const char* s)
			{
				cout &lt;&lt; s &lt;&lt; endl;
				system("pause");
				system("cls");
				break;
			}
		case 0:
			cout &lt;&lt; "退出链栈功能菜单！" &lt;&lt; endl;
			break;

		default:
			cout &lt;&lt; "非法输入，请重新选择！" &lt;&lt; endl;
			system("pause");
			system("cls");
			break;
		}
	}

}</code></pre> 
<h3 id="3.%E5%85%A8%E9%83%A8%E4%BB%A3%E7%A0%81">3.全部代码(分文件编写)</h3> 
<h4 id="SeqStack.h">SeqStack.h</h4> 
<pre><code class="language-cpp">#pragma once
#include&lt;iostream&gt;
using namespace std;

#ifndef SeqStack_H
#define SeqStack_H


#define MAXSIZE 100 // 顺序栈最多可以存储多少个元素，可按要求更改

template&lt;typename DataType&gt;
class SeqStack
{
public:
	SeqStack();						// 构造函数，初始化一个空栈
	~SeqStack() {};					// 析构函数
	void CreateSeqStack();
	void Push(DataType x); 			// 入栈操作，将元素x入栈
	DataType Pop();					// 出栈操作，将栈顶元素弹出，并返回弹出的元素值
	DataType GetTop();				// 取出栈顶元素（并不删除）
	int Length();					// 求顺序栈长度
	int Empty();					// 判空操作
	void PrintStack();			// 遍历打印，按照出栈顺序打印

private:
	DataType data[MAXSIZE];
	int top;
};


#endif</code></pre> 
<h4 id="SeqStack.cpp">SeqStack.cpp</h4> 
<pre><code class="language-cpp">#include "SeqStack.h"

//*****************************************************
//函数名：SeqStack
//函数功能：构造函数，初始化一个空栈
//输入参数：
//	无
//输出参数：
//	无
//******************************************************
template&lt;typename DataType&gt;
SeqStack&lt;DataType&gt;::SeqStack()
{
	this-&gt;top = -1;
}

//*****************************************************
//函数名：CreateSeqStack
//函数功能：创建一个指定长度的顺序栈
//输入参数：
//	无
//输出参数：
//	无
//******************************************************
template&lt;typename DataType&gt;
void SeqStack&lt;DataType&gt;::CreateSeqStack()
{
	int num, value;
	cout &lt;&lt; "请输入要入栈的元素个数：";
	cin &gt;&gt; num;
	cout &lt;&lt; "请输入要入栈的元素数值：";
	for (int i = 0; i &lt; num; i++)
	{
		cin &gt;&gt; value;
		this-&gt;data[i] = value;
		this-&gt;top++;
	}
}

//*****************************************************
//函数名：Push
//函数功能：入栈操作，将元素x入栈
//输入参数：
//	DataType,x,即将入栈的元素数值
//输出参数：
//	无
//******************************************************
template&lt;typename DataType&gt;
void SeqStack&lt;DataType&gt;::Push(DataType x)
{
	if (this-&gt;top+1 == MAXSIZE) throw"上溢";
	this-&gt;data[top + 1] = x;
	this-&gt;top++;
}

//*****************************************************
//函数名：Pop
//函数功能：出栈操作，将栈顶元素弹出，并返回弹出的元素值
//输入参数：
//	无
//输出参数：
//	DataType,弹出元素的数值
//******************************************************
template&lt;typename DataType&gt;
DataType SeqStack&lt;DataType&gt;::Pop()
{
	DataType y;
	if (this-&gt;Empty() == 1) throw"下溢";
	y = this-&gt;data[top];
	this-&gt;top--;
	return y;
}

//*****************************************************
//函数名：GetTop
//函数功能：取出栈顶元素（并不删除）
//输入参数：
//	无
//输出参数：
//	DataType,栈顶元素的数值
//******************************************************
template&lt;typename DataType&gt;
DataType SeqStack&lt;DataType&gt;::GetTop()
{
	DataType y;
	if (this-&gt;Length() == 0) throw"下溢";
	// if (this-&gt;Empty == 1) throw"下溢";
	y = this-&gt;data[top];
	return y;

}

//*****************************************************
//函数名：Length
//函数功能：输出栈的长度
//输入参数：
//	无
//输出参数：
//	int,栈的长度
//******************************************************
template&lt;typename DataType&gt;
int SeqStack&lt;DataType&gt;::Length()
{
	return this-&gt;top+1;
}

//*****************************************************
//函数名：Empty
//函数功能：判断栈是否为空
//输入参数：
//	无
//输出参数：
//	1，代表栈为空；0，代表栈非空
//******************************************************
template&lt;typename DataType&gt;
int SeqStack&lt;DataType&gt;::Empty()
{
	if (this-&gt;top==-1)		
		return 1;
	else
		return 0;
}

//*****************************************************
//函数名：PrintStack
//函数功能：遍历打印栈
//输入参数：
//	无
//输出参数：
//	无
//******************************************************
template&lt;typename datatype&gt;
void SeqStack&lt;datatype&gt;::PrintStack()
{
	int length = this-&gt;Length();

	if (length &gt; 0)
	{
		for (int i = 0; i &lt; length; i++)
			cout &lt;&lt;this-&gt;data[i] &lt;&lt; " ";
		cout &lt;&lt; endl;
	}
	else
		cout &lt;&lt; "顺序栈为空" &lt;&lt; endl;
}</code></pre> 
<h4 id="LinkedStack.h">LinkedStack.h</h4> 
<pre><code class="language-cpp">#pragma once
#include&lt;iostream&gt;
using namespace std;

#ifndef LinkedStack_H
#define LinkedStack_H

template&lt;typename DataType&gt;
struct LinkNode {
	DataType data;//数据域
	LinkNode&lt;DataType&gt;* next;//指针域 
};

template&lt;typename DataType&gt;
class LinkedStack
{
public:
	LinkedStack() { top = NULL; }		// 构造函数，初始化一个空栈
	~LinkedStack();					// 析构函数
	void CreateLinkedStack();
	void Push(DataType x); 			    // 入栈操作，将元素x入栈
	DataType Pop();					    // 出栈操作，将栈顶元素弹出，并返回弹出的元素值
	DataType GetTop();				    // 取出栈顶元素（并不删除）
	int Length();					    // 求顺序栈长度
	int Empty();					    // 判空操作
	void PrintStack();		            // 遍历打印，按照出栈顺序打印

private:
	LinkNode&lt;DataType&gt;* top;
};


#endif</code></pre> 
<h4 id="LinkedStack.cpp">LinkedStack.cpp</h4> 
<pre><code class="language-cpp">#include "LinkedStack.h"

// 析构函数
template&lt;typename DataType&gt;
LinkedStack&lt;DataType&gt;::~LinkedStack()
{
	LinkNode&lt;DataType&gt;* p = top;
	while (this-&gt;top)
	{
		top = top-&gt;next;
		delete p;
		p = top;
	}
}

//*****************************************************
//函数名：CreateLinkedStack
//函数功能：创建一个指定长度的链栈
//输入参数：
//	无
//输出参数：
//	无
//******************************************************
template&lt;typename DataType&gt;
void LinkedStack&lt;DataType&gt;::CreateLinkedStack()
{
	this-&gt;top = nullptr;
	LinkNode&lt;DataType&gt;* s = nullptr;

	int num, value;
	cout &lt;&lt; "请输入要创建的链栈长度：";
	cin &gt;&gt; num;
	cout &lt;&lt; "请输入入栈的元素数值：";

	for (int i = 0; i &lt; num; i++) 
	{
		cin &gt;&gt; value;
		LinkNode&lt;DataType&gt;* newNode = new LinkNode&lt;DataType&gt;;
		newNode-&gt;data = value;
		newNode-&gt;next = top;
		top = newNode;
	}
}

//*****************************************************
//函数名：Push
//函数功能：入栈操作，将元素x入栈
//输入参数：
//	DataType,x,即将入栈的元素数值
//输出参数：
//	无
//******************************************************
template&lt;typename DataType&gt;
void LinkedStack&lt;DataType&gt;::Push(DataType x)
{
	// 申请一个数据域为x的结点s
	LinkNode&lt;DataType&gt;* s = new LinkNode&lt;DataType&gt;;
	if (!s)
	{
		cout &lt;&lt; "分配内存失败";
		return;
	}
	s-&gt;data = x;
	s-&gt;next = top;
	top = s;
}

//*****************************************************
//函数名：Pop
//函数功能：出栈操作，将栈顶元素弹出，并返回弹出的元素值
//输入参数：
//	无
//输出参数：
//	DataType,弹出元素的数值
//******************************************************
template&lt;typename DataType&gt;
DataType LinkedStack&lt;DataType&gt;::Pop()
{
	if (this-&gt;Empty() == 1) throw"下溢";

	LinkNode&lt;DataType&gt;* temp = top;
	top = top-&gt;next;
	int y = temp-&gt;data;
	delete temp;
	return y;
}

//*****************************************************
//函数名：GetTop
//函数功能：取出栈顶元素（并不删除）
//输入参数：
//	无
//输出参数：
//	DataType,栈顶元素的数值
//******************************************************
template&lt;typename DataType&gt;
DataType LinkedStack&lt;DataType&gt;::GetTop()
{
	if (this-&gt;Empty() == 1) throw"下溢";

	return top-&gt;data;
}

//*****************************************************
//函数名：Empty
//函数功能：判断栈是否为空
//输入参数：
//	无
//输出参数：
//	1，代表栈为空；0，代表栈非空
//******************************************************
template&lt;typename DataType&gt;
int LinkedStack&lt;DataType&gt;::Empty()
{
	if (this-&gt;Length() == 0)
	{
		return 1;
	}
	else
		return 0;
}

//*****************************************************
//函数名：Length
//函数功能：输出栈的长度
//输入参数：
//	无
//输出参数：
//	int,栈的长度
//******************************************************
template&lt;typename DataType&gt;
int LinkedStack&lt;DataType&gt;::Length()
{
	int length = 0;
	LinkNode&lt;DataType&gt;* current = this-&gt;top;
	while (current != nullptr) {
		current = current-&gt;next;
		length++;
	}
	return length;
}

//*****************************************************
//函数名：PrintStack
//函数功能：遍历打印栈
//输入参数：
//	无
//输出参数：
//	无
//******************************************************
template&lt;typename DataType&gt;
void LinkedStack&lt;DataType&gt;::PrintStack()
{
	LinkNode&lt;DataType&gt;* current = this-&gt;top;

	cout &lt;&lt; "当前链表中的元素为：";
	while (current != nullptr) {
		cout &lt;&lt; current-&gt;data &lt;&lt; " ";
		current = current-&gt;next;
	}
	cout &lt;&lt; endl;
}</code></pre> 
<h4 id="my_Menu.h">my_Menu.h</h4> 
<pre><code class="language-cpp">#pragma once
#include&lt;iostream&gt;
using namespace std;

#ifndef my_Menu_H
#define my_Menu_H

void SeqStackMenu();
void LinkedStackMenu();


#endif</code></pre> 
<h4 id="my_Menu.cpp">my_Menu.cpp</h4> 
<pre><code class="language-cpp">#include "my_Menu.h"
#include "SeqStack.cpp"
#include "LinkedStack.cpp"


//*****************************************************
//函数名：SeqStackMenu
//函数功能：顺序栈的功能菜单
//输入参数：
//	无
//输出参数：
//	无
//******************************************************
void SeqStackMenu()
{
	SeqStack&lt;int&gt; Seq;
	/* 注意重置choice_two的值，否则将会再次进入会变为0，无法开始循环 */
	int choice_two = -1;

	while (choice_two)
	{
		cout &lt;&lt; "顺序栈示例：" &lt;&lt; endl;
		cout &lt;&lt; "1. 创建指定长度的顺序栈" &lt;&lt; endl;
		cout &lt;&lt; "2. 将指定元素入栈" &lt;&lt; endl;
		cout &lt;&lt; "3. 弹出栈顶元素" &lt;&lt; endl;
		cout &lt;&lt; "4. 输出栈顶元素数值" &lt;&lt; endl;
		cout &lt;&lt; "5. 输出顺序栈的长度" &lt;&lt; endl;
		cout &lt;&lt; "6. 遍历打印顺序栈" &lt;&lt; endl;
		cout &lt;&lt; "0. 返回上一级菜单" &lt;&lt; endl;
		cout &lt;&lt; "请选择:" &lt;&lt; endl;
		cin &gt;&gt; choice_two;

		switch (choice_two)
		{
		case 1:
			try
			{
				Seq.CreateSeqStack();
				cout &lt;&lt; "顺序栈的元素为:(从栈底开始遍历)" &lt;&lt; endl;
				Seq.PrintStack();
				system("pause");
				system("cls");
				break;
			}
			catch (const char* s)
			{
				cout &lt;&lt; s &lt;&lt; endl;
				system("pause");
				system("cls");
				break;
			}
		case 2:
			try
			{
				int value;
				cout &lt;&lt; "请输入将要入栈的元素数值" &lt;&lt; endl;
				cin &gt;&gt; value;
				Seq.Push(value);
				cout &lt;&lt; "顺序栈的元素为:(从栈底开始遍历)" &lt;&lt; endl;
				Seq.PrintStack();
				system("pause");
				system("cls");
				break;
			}
			catch (const char* s)
			{
				cout &lt;&lt; s &lt;&lt; endl;
				system("pause");
				system("cls");
				break;
			}
		case 3:
			try
			{
				int value = Seq.Pop();
				cout &lt;&lt; "弹出的栈顶元素的数值为：" &lt;&lt; value &lt;&lt; endl;
				system("pause");
				system("cls");
				break;
			}
			catch (const char* s)
			{
				cout &lt;&lt; s &lt;&lt; endl;
				system("pause");
				system("cls");
				break;
			}
		case 4:
			try
			{
				cout &lt;&lt; "当前顺序栈的栈顶元素数值为：" &lt;&lt; Seq.GetTop() &lt;&lt; endl;
				system("pause");
				system("cls");
				break;
			}
			catch (const char* s)
			{
				cout &lt;&lt; s &lt;&lt; endl;
				system("pause");
				system("cls");
				break;
			}
		case 5:
			try
			{
				cout &lt;&lt; "当前顺序栈的长度为：" &lt;&lt; Seq.Length() &lt;&lt; endl;
				system("pause");
				system("cls");
				break;
			}
			catch (const char* s)
			{
				cout &lt;&lt; s &lt;&lt; endl;
				system("pause");
				system("cls");
				break;
			}
		case 6:
			try
			{
				cout &lt;&lt; "当前顺序栈的元素为:(从栈底开始遍历)" &lt;&lt; endl;
				Seq.PrintStack();
				system("pause");
				system("cls");
				break;
			}
			catch (const char* s)
			{
				cout &lt;&lt; s &lt;&lt; endl;
				system("pause");
				system("cls");
				break;
			}
		case 0:
			cout &lt;&lt; "退出顺序栈功能菜单！" &lt;&lt; endl;
			break;

		default:
			cout &lt;&lt; "非法输入，请重新选择！" &lt;&lt; endl;
			system("pause");
			system("cls");
			break;
		}
	}
}


//*****************************************************
//函数名：LinkedStackMenu
//函数功能：链栈的功能菜单
//输入参数：
//	无
//输出参数：
//	无
//******************************************************
void LinkedStackMenu()
{
	LinkedStack&lt;int&gt; Link;
	int choice_two = -1;

	while (choice_two)
	{
		cout &lt;&lt; "链栈示例：" &lt;&lt; endl;
		cout &lt;&lt; "1. 创建指定长度的链栈" &lt;&lt; endl;
		cout &lt;&lt; "2. 将指定元素入栈" &lt;&lt; endl;
		cout &lt;&lt; "3. 弹出栈顶元素" &lt;&lt; endl;
		cout &lt;&lt; "4. 输出栈顶元素数值" &lt;&lt; endl;
		cout &lt;&lt; "5. 输出链栈的长度" &lt;&lt; endl;
		cout &lt;&lt; "6. 遍历打印链栈" &lt;&lt; endl;
		cout &lt;&lt; "0. 返回上一级菜单" &lt;&lt; endl;
		cout &lt;&lt; "请选择:" &lt;&lt; endl;
		cin &gt;&gt; choice_two;

		switch(choice_two)
		{
		case 1:
			try
			{
				Link.CreateLinkedStack();
				Link.PrintStack();
				system("pause");
				system("cls");
				break;
			}
			catch (const char* s)
			{
				cout &lt;&lt; s &lt;&lt; endl;
				system("pause");
				system("cls");
				break;
			}
		case 2:
			try
			{
				int value;
				cout &lt;&lt; "请输入将入栈的元素数值：";
				cin &gt;&gt; value;
				Link.Push(value);
				Link.PrintStack();
				system("pause");
				system("cls");
				break;
			}
			catch (const char* s)
			{
				cout &lt;&lt; s &lt;&lt; endl;
				system("pause");
				system("cls");
				break;
			}
		case 3:
			try
			{
				int value = Link.Pop();
				cout &lt;&lt; "弹出的栈顶元素数值为：" &lt;&lt; value &lt;&lt; endl;
				system("pause");
				system("cls");
				break;
			}
			catch (const char* s)
			{
				cout &lt;&lt; s &lt;&lt; endl;
				system("pause");
				system("cls");
				break;
			}
		case 4:
			try
			{
				cout &lt;&lt; "栈顶元素的数值为：" &lt;&lt; Link.GetTop() &lt;&lt; endl;
				system("pause");
				system("cls");
				break;
			}
			catch (const char* s)
			{
				cout &lt;&lt; s &lt;&lt; endl;
				system("pause");
				system("cls");
				break;
			}
		case 5:
			try
			{
				int length = Link.Length();
				cout &lt;&lt; "当前链表的长度为：" &lt;&lt; length &lt;&lt; endl;
				system("pause");
				system("cls");
				break;
			}
			catch (const char* s)
			{
				cout &lt;&lt; s &lt;&lt; endl;
				system("pause");
				system("cls");
				break;
			}
		case 6:
			try
			{
				Link.PrintStack();
				system("pause");
				system("cls");
				break;
			}
			catch (const char* s)
			{
				cout &lt;&lt; s &lt;&lt; endl;
				system("pause");
				system("cls");
				break;
			}
		case 0:
			cout &lt;&lt; "退出链栈功能菜单！" &lt;&lt; endl;
			break;

		default:
			cout &lt;&lt; "非法输入，请重新选择！" &lt;&lt; endl;
			system("pause");
			system("cls");
			break;
		}
	}

}</code></pre> 
<h4 id="main.cpp">main.cpp</h4> 
<pre><code class="language-cpp">#include&lt;iostream&gt;
#include "SeqStack.cpp"
#include "LinkedStack.cpp"
#include "my_Menu.h"
using namespace std;

int main()
{
	int choice_one;
	choice_one = -1;
	while (choice_one != 0)
	{
		cout &lt;&lt; "栈示例：" &lt;&lt; endl;
		cout &lt;&lt; "1. 顺序栈功能实现" &lt;&lt; endl;
		cout &lt;&lt; "2. 链栈功能实现" &lt;&lt; endl;
		cout &lt;&lt; "0. 退出" &lt;&lt; endl;
		cout &lt;&lt; "请选择:" &lt;&lt; endl;
		cin &gt;&gt; choice_one;
		system("cls");

		switch (choice_one)
		{
		case 1:// 
			SeqStackMenu();
			system("pause");
			system("cls");
			break;

		case 2:// 
			LinkedStackMenu();
			system("pause");
			system("cls");
			break;

		case 0: // 0.退出
			cout &lt;&lt; "欢迎下次使用！" &lt;&lt; endl;
			system("pause");
			return 0;
			break;

		default:
			cout &lt;&lt; "非法输入，请重新选择！" &lt;&lt; endl;
			system("pause");
			system("cls");
			break;

		}
	}

	system("plase");
	return 0;
}</code></pre> 
<blockquote> 
 <p>初学数据结构与算法，若有不正确之处，敬请指正啦~</p> 
</blockquote>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/0b8bade28cf8eb459e8bb3d13ebd3013/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">【路径规划】基于matlab粒子群优化蚁群算法最短路径规划【含Matlab源码 076期】</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/001c06a0c30a6c067c1ad523b7076fdb/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">CVE-2019-0708（远程桌面服务RCE）漏洞复现（超详细Getshell）</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>