<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>个人笔记：ESP8266发送POST请求调用API的一种方法——以TinywebDB的增删改查为例 - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="个人笔记：ESP8266发送POST请求调用API的一种方法——以TinywebDB的增删改查为例" />
<meta property="og:description" content="目录
前言：
TinyWebDB
代码讲解
整体代码
前言： 硬件：ESP8266主板、数据线
编译器：Arduino IDE
需要的库：&lt;ESP8266WiFi.h&gt; &lt;ArduinoJson.h&gt;
TinyWebDB TinyWebDB是一个非关系型数据库，它的数据结构是键值对（Key-Value）结构。在TinyWebDB中，每个数据项都有一个键和一个对应的值，键值对之间没有固定的关系，可以随时添加、删除和修改。TinyWebDB的数据库结构可以简单地表示为：
{
&#34;key1&#34;: &#34;value1&#34;,
&#34;key2&#34;: &#34;value2&#34;,
&#34;key3&#34;: &#34;value3&#34;,
...
}
其中，&#34;key1&#34;、&#34;key2&#34;、&#34;key3&#34;等表示键名，&#34;value1&#34;、&#34;value2&#34;、&#34;value3&#34;等表示对应的值。这种数据结构非常简单，但也非常灵活，可以存储各种不同类型的数据，包括字符串、数字、布尔值等。
在TinyWebDB中，每个数据项的键名是唯一的，如果添加了重复的键名，后面的键值会覆盖前面的键值。这种设计可以保证数据的唯一性和正确性。同时，由于TinyWebDB的数据结构非常简单，因此可以很方便地进行数据的查询、修改和删除操作。
总的来说，TinyWebDB的数据库结构非常简单，由键值对组成，这种设计具有灵活性和高效性，非常适合存储小规模的数据。TinyWebDB本是用于APP Inventor中的网络微数据库，但由于其简洁、轻量且免费，所以在此项目中被用来作为POST请求的操作对象。
以下是TinyWebDB服务器的网址，可以自行注册登录使用：
TinyWebDB服务器 - APPInventor网络微数据库http://tinywebdb.appinventor.space/
注册并登录后记住以下信息：
API地址：http://tinywebdb.appinventor.space/api
用户名（user）：your_username
密钥（secret）：your_secret
以及各种操作与各种参数要求。
代码讲解 首先是库的导入：
#include &lt;ESP8266WiFi.h&gt; #include &lt;ArduinoJson.h&gt; 该段代码使用了ESP8266WiFi和ArduinoJson两个库。
其中ESP8266WiFi库用于连接Wi-Fi网络，ArduinoJson库用于解析JSON格式的数据。
以及一些字段的定义：
const char* ssid = &#34;Wifi_ID&#34;; const char* password = &#34;Wifi_password&#34;; const char* host = &#34;tinywebdb.appinventor.space&#34;; // TinyWebDB的API地址 const int httpPort = 80; String user = &#34;" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/63230d7a09a03cc541f49f494e9298fa/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-03-31T15:14:52+08:00" />
<meta property="article:modified_time" content="2023-03-31T15:14:52+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">个人笔记：ESP8266发送POST请求调用API的一种方法——以TinywebDB的增删改查为例</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p id="main-toc"><strong>目录</strong></p> 
<p id="-toc" style="margin-left:40px;"></p> 
<p id="%E5%89%8D%E8%A8%80%EF%BC%9A-toc" style="margin-left:40px;"><a href="#%E5%89%8D%E8%A8%80%EF%BC%9A" rel="nofollow">前言：</a></p> 
<p id="TinyWebDB-toc" style="margin-left:40px;"><a href="#TinyWebDB" rel="nofollow">TinyWebDB</a></p> 
<p id="%E4%BB%A3%E7%A0%81%E8%AE%B2%E8%A7%A3-toc" style="margin-left:40px;"><a href="#%E4%BB%A3%E7%A0%81%E8%AE%B2%E8%A7%A3" rel="nofollow">代码讲解</a></p> 
<p id="%E6%95%B4%E4%BD%93%E4%BB%A3%E7%A0%81-toc" style="margin-left:40px;"><a href="#%E6%95%B4%E4%BD%93%E4%BB%A3%E7%A0%81" rel="nofollow">整体代码</a></p> 
<hr id="hr-toc"> 
<p></p> 
<h3 id="%E5%89%8D%E8%A8%80%EF%BC%9A">前言：</h3> 
<p>硬件：ESP8266主板、数据线</p> 
<p>编译器：Arduino IDE</p> 
<p>需要的库：&lt;ESP8266WiFi.h&gt;  &lt;ArduinoJson.h&gt;</p> 
<h3 id="TinyWebDB">TinyWebDB</h3> 
<p style="margin-left:.0001pt;text-align:justify;">        TinyWebDB是一个非关系型数据库，它的数据结构是键值对（Key-Value）结构。在TinyWebDB中，每个数据项都有一个键和一个对应的值，键值对之间没有固定的关系，可以随时添加、删除和修改。TinyWebDB的数据库结构可以简单地表示为：</p> 
<blockquote> 
 <p style="margin-left:.0001pt;text-align:justify;">{<!-- --></p> 
 <p style="margin-left:.0001pt;text-align:justify;">  "key1": "value1",</p> 
 <p style="margin-left:.0001pt;text-align:justify;">  "key2": "value2",</p> 
 <p style="margin-left:.0001pt;text-align:justify;">  "key3": "value3",</p> 
 <p style="margin-left:.0001pt;text-align:justify;">  ...</p> 
 <p style="margin-left:.0001pt;text-align:justify;">}</p> 
</blockquote> 
<p style="margin-left:.0001pt;text-align:justify;">        其中，"key1"、"key2"、"key3"等表示键名，"value1"、"value2"、"value3"等表示对应的值。这种数据结构非常简单，但也非常灵活，可以存储各种不同类型的数据，包括字符串、数字、布尔值等。</p> 
<p style="margin-left:.0001pt;text-align:justify;">        在TinyWebDB中，每个数据项的键名是唯一的，如果添加了重复的键名，后面的键值会覆盖前面的键值。这种设计可以保证数据的唯一性和正确性。同时，由于TinyWebDB的数据结构非常简单，因此可以很方便地进行数据的查询、修改和删除操作。</p> 
<p style="margin-left:.0001pt;text-align:justify;">        总的来说，TinyWebDB的数据库结构非常简单，由键值对组成，这种设计具有灵活性和高效性，非常适合存储小规模的数据。TinyWebDB本是用于APP Inventor中的网络微数据库，但由于其简洁、轻量<s>且免费</s>，所以在此项目中被用来作为POST请求的操作对象。</p> 
<p style="margin-left:.0001pt;text-align:justify;">以下是TinyWebDB服务器的网址，可以自行注册登录使用：</p> 
<p style="margin-left:.0001pt;text-align:justify;"><a class="has-card" href="http://tinywebdb.appinventor.space/" rel="nofollow" title="TinyWebDB服务器 - APPInventor网络微数据库"><span class="link-card-box"><span class="link-title">TinyWebDB服务器 - APPInventor网络微数据库</span><span class="link-link"><img alt="" class="link-link-icon" src="https://images2.imgbox.com/5e/f1/c4SG98Hz_o.png">http://tinywebdb.appinventor.space/</span></span></a></p> 
<p style="margin-left:.0001pt;text-align:justify;">        注册并登录后记住以下信息：</p> 
<p style="margin-left:.0001pt;text-align:justify;">                API地址：http://tinywebdb.appinventor.space/api</p> 
<p style="margin-left:.0001pt;text-align:justify;">                用户名（user）：your_username</p> 
<p style="margin-left:.0001pt;text-align:justify;">                密钥（secret）：your_secret</p> 
<p style="margin-left:.0001pt;text-align:justify;">                以及各种操作与各种参数要求。</p> 
<h3 id="%E4%BB%A3%E7%A0%81%E8%AE%B2%E8%A7%A3" style="margin-left:.0001pt;text-align:justify;">代码讲解</h3> 
<p><strong>首先是库的导入：</strong></p> 
<pre><code class="language-cpp">#include &lt;ESP8266WiFi.h&gt;
#include &lt;ArduinoJson.h&gt;</code></pre> 
<p>        该段代码使用了ESP8266WiFi和ArduinoJson两个库。</p> 
<p>        其中ESP8266WiFi库用于连接Wi-Fi网络，ArduinoJson库用于解析JSON格式的数据。</p> 
<p><strong>以及一些字段的定义：</strong></p> 
<pre><code class="language-cpp">const char* ssid = "Wifi_ID";
const char* password = "Wifi_password";

const char* host = "tinywebdb.appinventor.space"; // TinyWebDB的API地址
const int httpPort = 80;

String user = "your_username";
String secret = "your_secret";</code></pre> 
<p>        其中的 "Wifi_ID";  "Wifi_password";  "your_username";  "your_secret";要填入对应的字段。</p> 
<p>        分别对应的是你的Wifi名称、Wifi密码、TinyWebDB用户名（user）以及密钥（secret）</p> 
<p>        /*应该不会看不懂吧*/</p> 
<p><strong>接着是setup函数的内容</strong></p> 
<pre><code class="language-cpp">void setup() {
  Serial.begin(9600);
  delay(1000);
  WiFi.begin(ssid, password);
  delay(2000);
  Serial.print("Connecting to WiFi ");
  Serial.print(ssid);
  while (WiFi.status() != WL_CONNECTED) {
    delay(1000);
    Serial.print(".");
  }
  Serial.println(" ");
  Serial.print("Connected to WiFi: ");
  Serial.println(ssid);
  Serial.println(" ");
  Serial.print("Select your action (update/ get/ delate/ count/ search/ show): ");
}</code></pre> 
<p>        这里除了一些必要的代码外，还做了一些串口端的文字提示内容，如果不需要可以直接删除。</p> 
<p>        实际效果如下图： </p> 
<div class="img-center"> 
 <figure class="image"> 
  <img alt="" src="https://images2.imgbox.com/cc/b0/kjR0nYdh_o.png"> 
  <figcaption>
    个人认为应该在一切有人机交互的地方加入合理的设计 
  </figcaption> 
 </figure> 
</div> 
<p></p> 
<p><strong> 然后是loop函数的内容</strong></p> 
<pre><code class="language-cpp">void loop() {
  if (Serial.available()) {
    String input = Serial.readStringUntil('\n');
    Serial.println(input);
    input.trim();
    if (input == "update"){updateValue();}           //添加或更新
    else if (input == "get"){getValue();}            //读取
    else if (input == "delete"){deleteValue();}      //删除
    else if (input == "count"){countValues();}       //计数
    else if (input == "search"){searchValues();}     //查询
    else if (input == "show"){showDB();}             //显示全部（100条为上限）
    else {
      Serial.println("Invalid command.");            //非法指令
    }
    Serial.print("\nSelect your action (update/ get/ delate/ count/ search/ show): ");
  }
}</code></pre> 
<p>        通过六种不同的串口输入会有六种对应的操作，总体来说就是增删改查，我们会通过六个不同的函数来实现各自的功能。</p> 
<p>        这里还会涉及到一些关于串口字符串读取与判断的语句，在此不多讲，关于串口通信如有必要会专门写一篇。</p> 
<p>        在六种函数中，updateValue、deleteValue大多数情况下是不需要返回值的，而其他的函数都会有JSON格式的返回值，其中有countValues这种我们需要提取一个字符串+一个整型值的，也有searchValues、getValue以及showDB这种我们需要提取一(多)个字符串+一(多)个对应字符串的情况，所以我们将从updateValue()、searchValues()、countValues()三个函数的角度进行讲解。</p> 
<p>⭐<strong>updateValue操作函数</strong></p> 
<pre><code class="language-cpp">void updateValue(){
  String tag, value;
  Serial.print("Enter tag: ");
  while (!Serial.available()) {}
  tag = Serial.readStringUntil('\n');
  Serial.println(tag);
  tag.trim();
  Serial.print("Enter value: ");
  while (!Serial.available()) {}
  value = Serial.readStringUntil('\n');
  Serial.println(value);
  value.trim();
  if (tag.length() &gt; 0 &amp;&amp; value.length() &gt; 0) {
    // 发送POST请求
    WiFiClient client;
    if (!client.connect(host, httpPort)) {
      Serial.println("connection failed");
      return;
    }
    String url = "/api?user=" + user + "&amp;secret=" + secret + "&amp;action=update&amp;tag=" + tag + "&amp;value=" + value;
    Serial.print("Sending HTTP request to TinyWebDB: ");
    Serial.println(url);
    client.print(String("POST ") + url + " HTTP/1.1\r\n" +
                 "Host: " + host + "\r\n" +
                 "Connection: close\r\n\r\n");
    Serial.println("Server response:");
    Serial.println(" ");
    while (client.connected()) {
      String line = client.readStringUntil('\n');
      Serial.println(line);
      if (line == "\r") {
        break;
      }
    }
    Serial.println("Update Done.");
  }
}</code></pre> 
<p>        通过询问需要添加条目的tag以及value（也就是键名和对应的值），发送对应的POST请求。</p> 
<p>        在这一段中，该代码首先创建了一个WiFiClient对象client，然后使用client.connect()方法连接到指定的主机和端口。如果连接失败，则输出“connection failed”并返回。</p> 
<p style="margin-left:.0001pt;text-align:justify;">        接下来，该代码构造了一个URL，并使用client.print()方法发送HTTP请求。</p> 
<p style="margin-left:.0001pt;text-align:justify;">        其中，HTTP请求的第一行为“POST URL HTTP/1.1”，表示使用POST方法发送请求。请求头中包含了主机名、连接方式和空行。</p> 
<p style="margin-left:.0001pt;text-align:justify;">        发送完请求后，该代码使用client.readStringUntil()方法读取响应数据，并在读到空行时停止。</p> 
<p style="margin-left:.0001pt;text-align:justify;">        最终，响应数据被存储在line字符串变量中。</p> 
<p style="margin-left:.0001pt;text-align:justify;">        需要注意的是，输出的内容是可以通过注释掉对应的Serial.println()进行筛选的，例如我自己在使用时是不会显示line中的响应数据的，此处为了展示所以保留，但在后续的函数中将不再显示。</p> 
<p style="margin-left:.0001pt;">        实际效果如下图： </p> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/da/00/saMMFaE3_o.png"></p> 
<p>         而此时我的数据库中就多了这么一条数据：</p> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/4f/2e/RZXmPMNk_o.png"></p> 
<p> ⭐<strong>searchValues操作函数</strong></p> 
<pre><code class="language-cpp">void searchValues(){
  String no, count;
  Serial.print("Search from NO: ");
  while (!Serial.available()) {}
  no = Serial.readStringUntil('\n');
  Serial.println(no);
  no.trim();
  Serial.print("Total count: ");
  while (!Serial.available()) {}
  count = Serial.readStringUntil('\n');
  Serial.println(count);
  count.trim();
  if (no.length() &gt; 0 &amp;&amp; count.length() &gt; 0) {
    // 发送POST请求
    WiFiClient client;
    if (!client.connect(host, httpPort)) {
      Serial.println("connection failed");
      return;
    }
    String url = "/api?user=" + user + "&amp;secret=" + secret + "&amp;action=search&amp;no=" + no + "&amp;count=" + count;
    Serial.print("Sending HTTP request to TinyWebDB: ");
    Serial.println(url);
    client.print(String("POST ") + url + " HTTP/1.1\r\n" +
                 "Host: " + host + "\r\n" +
                 "Connection: close\r\n\r\n");
    // 等待服务器响应
    while (!client.available()) {
      delay(1);
    }
    // 读取服务器响应
    String response = "";
    while (client.available()) {
      String line = client.readStringUntil('\r');
      response += line;
    }

    //Serial.println(response);
    int start = response.indexOf("{");
    int end = response.lastIndexOf("}") + 1;
    // Extract JSON data
    String json = response.substring(start, end);
    // 解析JSON数据
    DynamicJsonDocument doc(1024);
    deserializeJson(doc, json);
    JsonObject obj = doc.as&lt;JsonObject&gt;();
    Serial.println("Search Result:");
    for (JsonPair pair : obj) {
      String tag = pair.key().c_str();
      //float value = pair.value().as&lt;float&gt;();
      String value = pair.value().as&lt;String&gt;();
      Serial.print("Tag: ");
      Serial.print(tag);
      Serial.print("   Content: ");
      Serial.println(value);
    }
  }
}</code></pre> 
<p>        其中与updateValue函数结构重复的部分就不再进行说明。</p> 
<p>        需要说明的是对返回值中JSON数据的提取和处理。</p> 
<p>        先定义了起始和结束位置的变量start和end，然后通过response字符串中的indexOf()和lastIndexOf()函数找到JSON数据的起始和结束位置。</p> 
<p>        接着，通过substring()函数获取JSON数据的字符串形式，存储在json变量中。</p> 
<p>        然后，使用deserializeJson()函数将json解析成DynamicJsonDocument类型的对象doc。</p> 
<p>        接下来，将doc转化成JsonObject类型的对象obj，通过遍历obj中的每一个元素，获取每个元素的key和value并输出。</p> 
<p>        需要注意的是这里，如果你的数据库中所有的value值都是数字，那么你可以通过float value = pair.value().as&lt;float&gt;();直接提取出浮点型或者通过int value = pair.value().as&lt;int&gt;();直接提取出整型，但大多数情况下我不推荐这么做，因为数据在上传时并没有对value的类型做出任何要求，那么在读取时应当认为它有可能是字符串类型，否则会有意外的读取错误的情况发生。</p> 
<blockquote> 
 <p>      //float value = pair.value().as&lt;float&gt;();<br>       String value = pair.value().as&lt;String&gt;();</p> 
</blockquote> 
<p>        这一点在countValues函数中有所体现。</p> 
<p> ⭐<strong>countValues操作函数</strong></p> 
<pre><code class="language-cpp">void countValues(){
  // 发送POST请求
  WiFiClient client;
  if (!client.connect(host, httpPort)) {
    Serial.println("connection failed");
    return;
  }
  String url = "/api?user=" + user + "&amp;secret=" + secret + "&amp;action=count";
  Serial.print("Sending HTTP request to TinyWebDB: ");
  Serial.println(url);
  client.print(String("POST ") + url + " HTTP/1.1\r\n" +
               "Host: " + host + "\r\n" +
               "Connection: close\r\n\r\n");
  // 等待服务器响应
  while (!client.available()) {
    delay(1);
  }
  // 读取服务器响应
  String response = "";
  while (client.available()) {
    String line = client.readStringUntil('\r');
    response += line;
  }
  //Serial.println(response);
  int start = response.indexOf("{");
  int end = response.lastIndexOf("}") + 1;
  // Extract JSON data
  String json = response.substring(start, end);
  // 解析JSON数据
  DynamicJsonDocument doc(1024);
  deserializeJson(doc, json);
  JsonObject obj = doc.as&lt;JsonObject&gt;();
  Serial.print("Count Result: ");
  for (JsonPair pair : obj) {
    String count = pair.key().c_str();
    int value = pair.value().as&lt;int&gt;();
    //Serial.print("Count: ");
    //Serial.print(count);
    //Serial.print("   Value: ");
    Serial.println(value);
  }
}</code></pre> 
<p>        与前两个函数类似的部分就不再赘述。</p> 
<p>        可以看到，由于countValues操作返回的value是数据的总条目数，而数据的总条目数必然是一个整数，所以我在提取元素时便直接将这里的value作为整型变量（int）进行操作了。</p> 
<p>        这种对于JSON数据的处理方式也可以灵活运用于Arduino IDE编程中的其他地方。</p> 
<h3 id="%E6%95%B4%E4%BD%93%E4%BB%A3%E7%A0%81">整体代码</h3> 
<pre><code class="language-cpp">#include &lt;ESP8266WiFi.h&gt;
#include &lt;ArduinoJson.h&gt;

const char* ssid = "Wifi_ID";
const char* password = "Wifi_password";

const char* host = "tinywebdb.appinventor.space"; // TinyWebDB的API地址
const int httpPort = 80;

String user = "your_username";
String secret = "your_secret";

void setup() {
  Serial.begin(9600);
  delay(1000);
  WiFi.begin(ssid, password);
  delay(2000);
  Serial.print("Connecting to WiFi ");
  Serial.print(ssid);
  while (WiFi.status() != WL_CONNECTED) {
    delay(1000);
    Serial.print(".");
  }
  Serial.println(" ");
  Serial.print("Connected to WiFi: ");
  Serial.println(ssid);
  Serial.println(" ");
  Serial.print("Select your action (update/ get/ delate/ count/ search/ show): ");
}
void loop() {
  if (Serial.available()) {
    String input = Serial.readStringUntil('\n');
    Serial.println(input);
    input.trim();
    if (input == "update") {
      updateValue();
    }
    else if (input == "get") {
      getValue();
    }
    else if (input == "delete") {
      deleteValue();
    }
    else if (input == "count") {
      countValues();
    }
    else if (input == "search") {
      searchValues();
    }
    else if (input == "show") {
      showDB();
    }
    else {
      Serial.println("Invalid command.");
    }
    Serial.print("\nSelect your action (update/ get/ delate/ count/ search/ show): ");
  }
}

void updateValue(){
  String tag, value;
  Serial.print("Enter tag: ");
  while (!Serial.available()) {}
  tag = Serial.readStringUntil('\n');
  Serial.println(tag);
  tag.trim();
  Serial.print("Enter value: ");
  while (!Serial.available()) {}
  value = Serial.readStringUntil('\n');
  Serial.println(value);
  value.trim();
  if (tag.length() &gt; 0 &amp;&amp; value.length() &gt; 0) {
    // 发送POST请求
    WiFiClient client;
    if (!client.connect(host, httpPort)) {
      Serial.println("connection failed");
      return;
    }
    String url = "/api?user=" + user + "&amp;secret=" + secret + "&amp;action=update&amp;tag=" + tag + "&amp;value=" + value;
    Serial.print("Sending HTTP request to TinyWebDB: ");
    Serial.println(url);
    client.print(String("POST ") + url + " HTTP/1.1\r\n" +
                 "Host: " + host + "\r\n" +
                 "Connection: close\r\n\r\n");
    //Serial.println("Server response:");
    //Serial.println(" ");
    while (client.connected()) {
      String line = client.readStringUntil('\n');
      //Serial.println(line);
      if (line == "\r") {
        break;
      }
    }
    Serial.println("Update Done.");
  }
}

void getValue(){
  String tag;
  Serial.print("Enter tag: ");
  while (!Serial.available()) {}
  tag = Serial.readStringUntil('\n');
  Serial.println(tag);
  tag.trim();
  if (tag.length() &gt; 0) {
    // 发送POST请求
    WiFiClient client;
    if (!client.connect(host, httpPort)) {
      Serial.println("connection failed");
      return;
    }
    String url = "/api?user=" + user + "&amp;secret=" + secret + "&amp;action=get&amp;tag=" + tag;
    Serial.print("Sending HTTP request to TinyWebDB: ");
    Serial.println(url);
    client.print(String("POST ") + url + " HTTP/1.1\r\n" +
                 "Host: " + host + "\r\n" +
                 "Connection: close\r\n\r\n");
    // 等待服务器响应
    while (!client.available()) {
      delay(1);
    }
    // 读取服务器响应
    String response = "";
    while (client.available()) {
      String line = client.readStringUntil('\r');
      response += line;
    }
    //Serial.println(response);
    int start = response.indexOf("{");
    int end = response.lastIndexOf("}") + 1;
    // Extract JSON data
    String json = response.substring(start, end);
    // 解析JSON数据
    DynamicJsonDocument doc(1024);
    deserializeJson(doc, json);
    JsonObject obj = doc.as&lt;JsonObject&gt;();
    Serial.println("Get Result:");
    for (JsonPair pair : obj) {
      String tag = pair.key().c_str();
      //float value = pair.value().as&lt;float&gt;();
      String value = pair.value().as&lt;String&gt;();
      Serial.print("Tag: ");
      Serial.print(tag);
      Serial.print("   Content: ");
      Serial.println(value);
    }
  }
}

void deleteValue(){
  String tag;
  Serial.print("Enter tag: ");
  while (!Serial.available()) {}
  tag = Serial.readStringUntil('\n');
  Serial.println(tag);
  tag.trim();
  if (tag.length()) {
    // 发送POST请求
    WiFiClient client;
    if (!client.connect(host, httpPort)) {
      Serial.println("connection failed");
      return;
    }
    String url = "/api?user=" + user + "&amp;secret=" + secret + "&amp;action=delete&amp;tag=" + tag;
    Serial.println("Sending HTTP request to TinyWebDB: ");
    Serial.println(url);
    client.print(String("POST ") + url + " HTTP/1.1\r\n" +
                 "Host: " + host + "\r\n" +
                 "Connection: close\r\n\r\n");
    //Serial.println("Server response:");
    //Serial.println(" ");
    while (client.connected()) {
      String line = client.readStringUntil('\n');
      //Serial.println(line);
      if (line == "\r") {
        break;
      }
    }
    Serial.println("Delate Done.");
  }
}

void countValues(){
  // 发送POST请求
  WiFiClient client;
  if (!client.connect(host, httpPort)) {
    Serial.println("connection failed");
    return;
  }
  String url = "/api?user=" + user + "&amp;secret=" + secret + "&amp;action=count";
  Serial.print("Sending HTTP request to TinyWebDB: ");
  Serial.println(url);
  client.print(String("POST ") + url + " HTTP/1.1\r\n" +
               "Host: " + host + "\r\n" +
               "Connection: close\r\n\r\n");
  // 等待服务器响应
  while (!client.available()) {
    delay(1);
  }
  // 读取服务器响应
  String response = "";
  while (client.available()) {
    String line = client.readStringUntil('\r');
    response += line;
  }
  //Serial.println(response);
  int start = response.indexOf("{");
  int end = response.lastIndexOf("}") + 1;
  // Extract JSON data
  String json = response.substring(start, end);
  // 解析JSON数据
  DynamicJsonDocument doc(1024);
  deserializeJson(doc, json);
  JsonObject obj = doc.as&lt;JsonObject&gt;();
  Serial.print("Count Result: ");
  for (JsonPair pair : obj) {
    String count = pair.key().c_str();
    int value = pair.value().as&lt;int&gt;();
    //Serial.print("Count: ");
    //Serial.print(count);
    //Serial.print("   Value: ");
    Serial.println(value);
  }
}

void searchValues(){
  String no, count;
  Serial.print("Search from NO: ");
  while (!Serial.available()) {}
  no = Serial.readStringUntil('\n');
  Serial.println(no);
  no.trim();
  Serial.print("Total count: ");
  while (!Serial.available()) {}
  count = Serial.readStringUntil('\n');
  Serial.println(count);
  count.trim();
  if (no.length() &gt; 0 &amp;&amp; count.length() &gt; 0) {
    // 发送POST请求
    WiFiClient client;
    if (!client.connect(host, httpPort)) {
      Serial.println("connection failed");
      return;
    }
    String url = "/api?user=" + user + "&amp;secret=" + secret + "&amp;action=search&amp;no=" + no + "&amp;count=" + count;
    Serial.print("Sending HTTP request to TinyWebDB: ");
    Serial.println(url);
    client.print(String("POST ") + url + " HTTP/1.1\r\n" +
                 "Host: " + host + "\r\n" +
                 "Connection: close\r\n\r\n");
    // 等待服务器响应
    while (!client.available()) {
      delay(1);
    }
    // 读取服务器响应
    String response = "";
    while (client.available()) {
      String line = client.readStringUntil('\r');
      response += line;
    }

    //Serial.println(response);
    int start = response.indexOf("{");
    int end = response.lastIndexOf("}") + 1;
    // Extract JSON data
    String json = response.substring(start, end);
    // 解析JSON数据
    DynamicJsonDocument doc(1024);
    deserializeJson(doc, json);
    JsonObject obj = doc.as&lt;JsonObject&gt;();
    Serial.println("Search Result:");
    for (JsonPair pair : obj) {
      String tag = pair.key().c_str();
      //float value = pair.value().as&lt;float&gt;();
      String value = pair.value().as&lt;String&gt;();
      Serial.print("Tag: ");
      Serial.print(tag);
      Serial.print("   Content: ");
      Serial.println(value);
    }
  }
}

void showDB(){
  // 发送POST请求
  WiFiClient client;
  if (!client.connect(host, httpPort)) {
    Serial.println("connection failed");
    return;
  }
  String url = "/api?user=" + user + "&amp;secret=" + secret + "&amp;action=search&amp;no=1&amp;count=100";
  //Serial.print("Sending HTTP request to TinyWebDB: ");
  //Serial.println(url);
  Serial.println("Searching...");
  client.print(String("POST ") + url + " HTTP/1.1\r\n" +
               "Host: " + host + "\r\n" +
               "Connection: close\r\n\r\n");
  // 等待服务器响应
  while (!client.available()) {
    delay(1);
  }
  // 读取服务器响应
  String response = "";
  while (client.available()) {
    String line = client.readStringUntil('\r');
    response += line;
  }

  //Serial.println(response);
  int start = response.indexOf("{");
  int end = response.lastIndexOf("}") + 1;
  // Extract JSON data
  String json = response.substring(start, end);
  // 解析JSON数据
  DynamicJsonDocument doc(1024);
  deserializeJson(doc, json);
  JsonObject obj = doc.as&lt;JsonObject&gt;();
  Serial.println("Search Result:");
  for (JsonPair pair : obj) {
    String tag = pair.key().c_str();
    //float value = pair.value().as&lt;float&gt;();
    String value = pair.value().as&lt;String&gt;();
    Serial.print("Tag: ");
    Serial.print(tag);
    Serial.print("   Content: ");
    Serial.println(value);
  }
}</code></pre> 
<p><strong>连续操作演示</strong></p> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/b8/ae/VqTjGhpg_o.png"></p> 
<p></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/0dcea2221974e5d9292d007cfc10f9c9/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">基于GitLab&#43;Docker&#43;K8S的持续集成和交付</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/9a757a8bfe71d9036d8e2ffe93ea6319/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">Kepware里一些特殊驱动说明</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>