<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Perl语言哈希的运用 - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Perl语言哈希的运用" />
<meta property="og:description" content="什么是哈希？
哈希是一种数据结构，它和数组的相似之处在于可以容纳任意多的值并能按需取用，而它和数组的不同在于索引方式，数组是以数字来索引，哈希则以名字来索引。也就是说，哈希的索引值，此处称为键( key )，并不是数字、而是任意唯一的字符串。
键总会被转换为字符串
哈希的值可以是数字、字符串、undef，或是这些类型的组合。
哈希的键则必须全部是唯一的字符串。
为何使用哈希？
事实上只要问题中带有&#34;找出重复&#34;、“唯一”、“交叉引用”、&#34;查表&#34;之类的字眼，实现时就很有可能会用到哈希。
访问哈希元素 $hash{$some_key}
（1）在挑选哈希名的时候，最好使得哈希名和键之间能放进去一个 “for” 字。
比如&#34;family_name for fred是flintstone&#34;，因此把哈希命名为family_name能清晰地反映出键和值之间的关系。
my %family_name; $family_name{&#39;fred&#39;} = &#39;flintstone&#39;; $family_name{&#39;barney&#39;} = &#39;rubble&#39;; foreach my $person (qw&lt; fred barney&gt;){ print &#34;I&#39;ve heard of $person $family_name{$person}.\n&#34;; } （2）哈希键可以是任意的表达式：
$foo = &#39;bar&#39;; print &#34;barney =&gt; $family_name{ $foo . &#39;ney&#39;}&#34;; （3）若对某个已存在的哈希元素赋值，就会覆盖之前的值：
$family_name{&#39;fred&#39;} = &#39;astaire&#39;; print &#34;fred =&gt; $family_name{&#39;fred&#39;}.\n&#34;; （4）哈希元素会因赋值而诞生：
$family_name{&#39;wilma&#39;} = &#39;flintstone&#39;; $family_name{&#39;betty&#39;} = $family_name{&#39;barney&#39;}; my @family_name = %family_name; print &#34;" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/2d3f4a7cc9271223b4adb392709bbe7f/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-11-22T21:48:59+08:00" />
<meta property="article:modified_time" content="2022-11-22T21:48:59+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Perl语言哈希的运用</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <ul><li> <p>什么是哈希？<br> 哈希是一种数据结构，它和数组的相似之处在于可以容纳任意多的值并能按需取用，而它和数组的不同在于索引方式，数组是以数字来索引，哈希则以名字来索引。也就是说，哈希的索引值，此处称为键( <code>key</code> )，并不是数字、而是任意唯一的字符串。<br> 键总会被转换为字符串<br> 哈希的值可以是数字、字符串、<code>undef</code>，或是这些类型的组合。<br> 哈希的键则必须全部是唯一的字符串。</p> </li><li> <p>为何使用哈希？<br> 事实上只要问题中带有"找出重复"、“唯一”、“交叉引用”、"查表"之类的字眼，实现时就很有可能会用到哈希。</p> </li><li> <p>访问哈希元素 <code>$hash{$some_key}</code></p> </li></ul> 
<p>（1）在挑选哈希名的时候，最好使得哈希名和键之间能放进去一个 “for” 字。<br> 比如"family_name for fred是flintstone"，因此把哈希命名为family_name能清晰地反映出键和值之间的关系。</p> 
<pre><code class="prism language-pl">my %family_name;
$family_name{'fred'} = 'flintstone';
$family_name{'barney'} = 'rubble';
foreach my $person (qw&lt; fred barney&gt;){
        print "I've heard of $person $family_name{$person}.\n";
}
</code></pre> 
<center> 
</center> 
<p><img src="https://images2.imgbox.com/80/1b/Jt5tXPmu_o.png" alt="在这里插入图片描述"></p> 
<p>（2）哈希键可以是任意的表达式：</p> 
<pre><code class="prism language-pl">$foo = 'bar';
print "barney =&gt; $family_name{ $foo . 'ney'}";
</code></pre> 
<center> 
</center> 
<p><img src="https://images2.imgbox.com/5b/d1/DHcbsSUu_o.png" alt="在这里插入图片描述"></p> 
<p>（3）若对某个已存在的哈希元素赋值，就会覆盖之前的值：</p> 
<pre><code class="prism language-pl">$family_name{'fred'} = 'astaire';
print "fred =&gt; $family_name{'fred'}.\n";
</code></pre> 
<center> 
</center> 
<p><img src="https://images2.imgbox.com/80/af/JQ0kEcgz_o.png" alt="在这里插入图片描述"></p> 
<p>（4）哈希元素会因赋值而诞生：</p> 
<pre><code class="prism language-pl">$family_name{'wilma'} = 'flintstone';
$family_name{'betty'} = $family_name{'barney'};
my @family_name = %family_name;
print "@family_name\n";
</code></pre> 
<center> 
</center> 
<p><img src="https://images2.imgbox.com/f7/ee/6F4ksTBe_o.png" alt="在这里插入图片描述"></p> 
<p>（5）访问哈希表里不存在的值会得到 <code>undef</code></p> 
<ul><li>访问整个哈希<br> 要指代整个哈希，可以用百分号( <code>%</code> )作为前缀。<br> 哈希可以转换为列表，反之亦然。对哈希赋值时，列表中的元素应该为键-值对；展开（unwinding）哈希时，即将哈希变成键-值对列表，得到的键-值对不一定是按照当初赋值时的顺序展开。因此选择使用哈希的场合，要么元素存储顺序无关紧要，要么可以容易地在元素输出时进行排序。当然，即使键-值对的顺序被打乱，列表里的每个键还是会"黏着"相应的值。</li></ul> 
<pre><code class="prism language-pl">my %some_hash;
%some_hash = ('foo',35,'bar',12.4,2.5,'hello','wilma',1.72e30,'betty',"bye\n");
my @any_array = %some_hash;
print "@any_array\n";
</code></pre> 
<center> 
</center> 
<p><img src="https://images2.imgbox.com/7c/53/cOuvng7I_o.png" alt="在这里插入图片描述"></p> 
<ul><li> <p>哈希赋值<br> （1）用一般的赋值语法来复制哈希：<code>my %new_hash = %some_hash;</code><br> （2）建立一个反序的哈希：<code>my %inverse_hash = reverse %any_hash;</code><br> 只能在哈希值不重复的情况下使用，否则就会导致重复的键。</p> </li><li> <p>胖箭头<br> 对Perl而言，<code>=&gt;</code>是逗号的另一种写法，即在任何需要逗号( <code>,</code> )的地方都可以用胖箭头( <code>=&gt;</code> )代替。<br> 胖箭头左边的任何裸宇（一连串的字母、数字和下划线，但不得以数字开头）都会自动加上引号，因此胖箭头左边的裸字不需要加引号。<br> 另外，在作为哈希键使用时如果花括号内只有裸字时，则两边的引号也可以省略。</p> </li></ul> 
<pre><code class="prism language-pl">my %last_name = (
        'fred' =&gt; 'flintstone' ,
        'dino' =&gt; undef ,
        'barney' =&gt; 'rubble' ,
        'betty' =&gt; 'rubble',    #请注意，列表结尾有一个额外的逗号，这种写法不但无伤大雅，而且便于维护。
);

my %last_name = (
        fred =&gt; 'flintstone' ,
        dino =&gt; undef ,
        barney =&gt; 'rubble' ,
        betty =&gt; 'rubble',
);  #使用胖箭头的时候可以省略键的引号，左边的部分会被自动引起
    #当然，也不是所有情况都可以这么做，因为哈希的键可以是任意形式的字符串，
    #所以要是某个键的内容含有Perl的操作符，就会偏离我们的预想甚至编译出错
</code></pre> 
<ul><li>哈希函数</li><li><code>keys</code> 和 <code>values</code> 函数</li></ul> 
<p>（1）<code>keys</code> 函数能返回哈希的键列表，而<code>values</code> 函数能返回对应的值列表。如果哈希没有任何成员，则两个函数都返回空列表。只要在取得键与取得值这两个动作之间不修改哈希，则返回的键列表和值列表的顺序是一致的。</p> 
<pre><code class="prism language-pl">my @k = keys %some_hash;
my @v = values %some_hash;
</code></pre> 
<p>（2）在标量上下文中，这两个函数都会返回哈希中元素（键-值对）的个数。</p> 
<pre><code class="prism language-pl">my $count1 = keys %some_hash;
my $count2 = values %some_hash;

print "k = @k\n" .
"v = @v\n" .
"count1 = $count1\n" .
"count2 = $count2\n";
</code></pre> 
<p>（3）把哈希当成布尔表达式来判断真假（少见）：只要哈希中至少有一个键-值对，就返回真</p> 
<pre><code class="prism language-pl">if (%some_hash) {
        print "That was a true value! \n" ;
}else{
        print "That was a false value! \n" ;
}
</code></pre> 
<center> 
</center> 
<p><img src="https://images2.imgbox.com/7d/be/fxPBzmfH_o.png" alt="在这里插入图片描述"><br> <img src="https://images2.imgbox.com/62/8c/aXgp3usd_o.png" alt="在这里插入图片描述"></p> 
<ul><li><code>each</code>函数（该函数的详细运行过程请看书本 P125 ）</li></ul> 
<p>（1）实际使用时，唯一适合使用 <code>each</code> 的地方就是在 <code>while</code> 循环中：</p> 
<pre><code class="prism language-pl">while ( ($key,$value) = each %some_hash ){
        printf "%10s =&gt; %-10s\n",$key,$value;
}
</code></pre> 
<center> 
</center> 
<p><img src="https://images2.imgbox.com/31/d6/WrM6wLyL_o.png" alt="在这里插入图片描述"></p> 
<p>（2）假如你需要依次处理哈希，只要对键排序就行了。方法如下所示：</p> 
<pre><code class="prism language-pl">foreach $key (sort keys %some_hash) {
        printf "%10s =&gt; %-10s\n",$key,$some_hash{$key};
}
</code></pre> 
<center> 
</center> 
<p><img src="https://images2.imgbox.com/08/62/wdwcmS49_o.png" alt="在这里插入图片描述"></p> 
<ul><li> <p>哈希的典型应用</p> </li><li> <p><code>exists</code> 函数<br> 若要检查哈希中是否存在某个键，可以使用 <code>exists</code> 函数，它能返回真或假，分别表示键存在与否，和键对应的值无关：</p> </li><li> <p><code>delete</code> 函数<br> <code>delete</code> 函数能从哈希中删除指定的键及其相对应的值。假如没有这样的键，它就会直接结束，而不会出现任何警告或错误信息。</p> </li><li> <p>哈希元素内插<br> 可以将单一哈希元素内插到双引号引起的字符串中，就和你想要的一样：（但这种方式不支持内插整个哈希）</p> </li></ul> 
<pre><code class="prism language-pl">my %some_hash = (
        fred =&gt; 'flintstone' ,
        dino =&gt; undef ,
        barney =&gt; 'rubble' ,
        betty =&gt; 'rubble',
        july =&gt; '0',
);
foreach $key (sort keys %some_hash) {
        if ($some_hash{$key}) { #两种判断，两种结果，看截图
        #if (exists $some_hash{$key}) {
                print "$key has $some_hash{$key} items\n";
        }
}
</code></pre> 
<p><img src="https://images2.imgbox.com/6c/ab/TQwCf8vG_o.png" alt="在这里插入图片描述"></p> 
<ul><li><code>%ENV</code> 哈希<br> 访问Perl程序外的任意环境变量<br> <code>print "PWD is $ENV{PWD}\n";</code></li></ul>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/0ae147c481f3565614eeb9df9be6f3ae/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">搭建一个基于 Markdown的文档编辑框架 - vue3 - vuepress （下）</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/f9b088fa9049212f06747df26652eb87/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">技术领导力学习之道</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>