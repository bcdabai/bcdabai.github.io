<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>内存分配—new，malloc，calloc - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="内存分配—new，malloc，calloc" />
<meta property="og:description" content="一。关于内存
1、内存分配方式
内存分配方式有三种：
（1）从静态存储区域分配。内存在程序编译的时候就已经分配好，这块内存在程序的整个运行期间都存在
。例如全局变量，static变量。
（2）在栈上创建。在执行函数时，函数内局部变量的存储单元都可以在栈上创建，函数执行结束时这些存
储单元自动被释放。栈内存分配运算内置于处理器的指令集中，效率很高，但是分配的内存容量有限。
（3） 从堆上分配，亦称动态内存分配。程序在运行的时候用malloc或new申请任意多少的内存，程序员自
己负责在何时用free或delete释放内存。动态内存的生存期由我们决定，使用非常灵活，但问题也最多。
2.内存使用错误
发生内存错误是件非常麻烦的事情。编译器不能自动发现这些错误，通常是在程序运行时才能捕捉到。
而这些错误大多没有明显的症状，时隐时现，增加了改错的难度。有时用户怒气冲冲地把你找来，程序却没
发生任何问题，你一走，错误又发作了。 常见的内存错误及其对策如下：
* 内存分配未成功，却使用了它。
编程新手常犯这种错误，因为他们没有意识到内存分配会不成功。常用解决办法是，在使用内存之前检查
指针是否为NULL。如果是用malloc或new来申请内存，应该用if(p==NULL) 或if(p!=NULL)进行防错处理。
* 内存分配虽然成功，但是尚未初始化就引用它。
犯这种错误主要有两个起因：一是没有初始化的观念；二是误以为内存的缺省初值全为零，导致引用初值
错误（例如数组）。 内存的缺省初值究竟是什么并没有统一的标准，尽管有些时候为零值，我们宁可信其无不
可信其有。所以无论用何种方式创建数组，都别忘了赋初值，即便是赋零值也不可省略，不要嫌麻烦。
* 内存分配成功并且已经初始化，但操作越过了内存的边界。
例如在使用数组时经常发生下标“多1”或者“少1”的操作。特别是在for循环语句中，循环次数很容易搞
错，导致数组操作越界。
* 忘记了释放内存，造成内存泄露。
含有这种错误的函数每被调用一次就丢失一块内存。刚开始时系统的内存充足，你看不到错误。终有一次
程序突然死掉，系统出现提示：内存耗尽。
动态内存的申请与释放必须配对，程序中malloc与free的使用次数一定要相同，否则肯定有错误
（new/delete同理）。
* 释放了内存却继续使用它。
有三种情况：
（1）程序中的对象调用关系过于复杂，实在难以搞清楚某个对象究竟是否已经释放了内存，此时应该重新
设计数据结构，从根本上解决对象管理的混乱局面。
（2）函数的return语句写错了，注意不要返回指向“栈内存”的“指针”或者“引用”，因为该内存在函
数体结束时被自动销毁。
（3）使用free或delete释放了内存后，没有将指针设置为NULL。导致产生“野指针”。
【规则1】用malloc或new申请内存之后，应该立即检查指针值是否为NULL。防止使用指针值为NULL的内存
【规则2】不要忘记为数组和动态内存赋初值。防止将未被初始化的内存作为右值使用。
【规则3】避免数组或指针的下标越界，特别要当心发生“多1”或者“少1”操作。
【规则4】动态内存的申请与释放必须配对，防止内存泄漏。
【规则5】用free或delete释放了内存之后，立即将指针设置为NULL，防止产生“野指针”。
二. 详解new，malloc，GlobalAlloc
1. new new和delete运算符用于动态分配和撤销内存的运算符
new用法:
1&gt; 开辟单变量地址空间
1)new int; //开辟一个存放数组的存储空间,返回一个指向该存储空间的地址.int *a = new int 即为将一个int类型的地址赋值给整型指针a. 2)int *a = new int(5) 作用同上,但是同时将整数赋值为5" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/d08c13fefacebb36d24eaa3dc68205ed/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2014-11-08T22:07:00+08:00" />
<meta property="article:modified_time" content="2014-11-08T22:07:00+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">内存分配—new，malloc，calloc</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p> 一。关于内存<br> 　1、内存分配方式<br> 　　内存分配方式有三种：<br> 　　（1）从静态存储区域分配。内存在程序编译的时候就已经分配好，这块内存在程序的整个运行期间都存在<br> 。例如全局变量，static变量。<br> 　　（2）在栈上创建。在执行函数时，函数内局部变量的存储单元都可以在栈上创建，函数执行结束时这些存<br> 储单元自动被释放。栈内存分配运算内置于处理器的指令集中，效率很高，但是分配的内存容量有限。<br> 　　（3） 从堆上分配，亦称动态内存分配。程序在运行的时候用malloc或new申请任意多少的内存，程序员自<br> 己负责在何时用free或delete释放内存。动态内存的生存期由我们决定，使用非常灵活，但问题也最多。<br>    2.内存使用错误<br>      　发生内存错误是件非常麻烦的事情。编译器不能自动发现这些错误，通常是在程序运行时才能捕捉到。<br> 而这些错误大多没有明显的症状，时隐时现，增加了改错的难度。有时用户怒气冲冲地把你找来，程序却没<br> 发生任何问题，你一走，错误又发作了。 常见的内存错误及其对策如下：<br>        * 内存分配未成功，却使用了它。<br> 　　编程新手常犯这种错误，因为他们没有意识到内存分配会不成功。常用解决办法是，在使用内存之前检查<br> 指针是否为NULL。如果是用malloc或new来申请内存，应该用if(p==NULL) 或if(p!=NULL)进行防错处理。<br> 　　* 内存分配虽然成功，但是尚未初始化就引用它。<br> 　　犯这种错误主要有两个起因：一是没有初始化的观念；二是误以为内存的缺省初值全为零，导致引用初值<br> 错误（例如数组）。 内存的缺省初值究竟是什么并没有统一的标准，尽管有些时候为零值，我们宁可信其无不<br> 可信其有。所以无论用何种方式创建数组，都别忘了赋初值，即便是赋零值也不可省略，不要嫌麻烦。<br> 　　* 内存分配成功并且已经初始化，但操作越过了内存的边界。</p> 
<p>　　例如在使用数组时经常发生下标“多1”或者“少1”的操作。特别是在for循环语句中，循环次数很容易搞<br> 错，导致数组操作越界。</p> 
<p>　　* 忘记了释放内存，造成内存泄露。</p> 
<p>　　含有这种错误的函数每被调用一次就丢失一块内存。刚开始时系统的内存充足，你看不到错误。终有一次</p> 
<p>程序突然死掉，系统出现提示：内存耗尽。</p> 
<p>　　动态内存的申请与释放必须配对，程序中malloc与free的使用次数一定要相同，否则肯定有错误</p> 
<p>（new/delete同理）。</p> 
<p>　　* 释放了内存却继续使用它。<br> 　<br> 　　有三种情况：</p> 
<p>　　（1）程序中的对象调用关系过于复杂，实在难以搞清楚某个对象究竟是否已经释放了内存，此时应该重新</p> 
<p>设计数据结构，从根本上解决对象管理的混乱局面。</p> 
<p>　　（2）函数的return语句写错了，注意不要返回指向“栈内存”的“指针”或者“引用”，因为该内存在函</p> 
<p>数体结束时被自动销毁。</p> 
<p>　　（3）使用free或delete释放了内存后，没有将指针设置为NULL。导致产生“野指针”。</p> 
<p>　　【规则1】用malloc或new申请内存之后，应该立即检查指针值是否为NULL。防止使用指针值为NULL的内存</p> 
<p>　　【规则2】不要忘记为数组和动态内存赋初值。防止将未被初始化的内存作为右值使用。</p> 
<p>　　【规则3】避免数组或指针的下标越界，特别要当心发生“多1”或者“少1”操作。</p> 
<p>　　【规则4】动态内存的申请与释放必须配对，防止内存泄漏。</p> 
<p>　　【规则5】用free或delete释放了内存之后，立即将指针设置为NULL，防止产生“野指针”。</p> 
<p> <br> 二. 详解new，malloc，GlobalAlloc<br>  1.  new </p> 
<p>  new和delete运算符用于动态分配和撤销内存的运算符</p> 
<p>new用法:</p> 
<p>          1&gt;     开辟单变量地址空间</p> 
<p>               1)new int;  //开辟一个存放数组的存储空间,返回一个指向该存储空间的地址.int *a = new </p> 
<p>int 即为将一个int类型的地址赋值给整型指针a.  </p> 
<p>               2)int *a = new int(5) 作用同上,但是同时将整数赋值为5</p> 
<p>          2&gt;    开辟数组空间</p> 
<p>               一维: int *a = new int[100];开辟一个大小为100的整型数组空间</p> 
<p>         一般用法: new 类型 [初值]</p> 
<p>delete用法:</p> 
<p>          1&gt; int *a = new int;</p> 
<p>               delete a;   //释放单个int的空间</p> 
<p>          2&gt;int *a = new int[5];</p> 
<p>               delete [] a; //释放int数组空间</p> 
<p>          要访问new所开辟的结构体空间,无法直接通过变量名进行,只能通过赋值的指针进行访问.</p> 
<p>          用new和delete可以动态开辟,撤销地址空间.在编程序时,若用完一个变量(一般是暂时存储的数组),</p> 
<p>下次需要再用,但却又想省去重新初始化的功夫,可以在每次开始使用时开辟一个空间,在用完后撤销它.</p> 
<p>2.  malloc<br>   原型：extern void *malloc(unsigned int num_bytes); <br> 　　用法：＃i nclude &lt;malloc.h&gt;或＃i nclude &lt;stdlib.h&gt; <br> 　　功能：分配长度为num_bytes字节的内存块 <br> 　　说明：如果分配成功则返回指向被分配内存的指针，否则返回空指针NULL。 <br> 　　当内存不再使用时，应使用free()函数将内存块释放。 <br> 　　malloc的语法是：指针名=（数据类型*）malloc（长度）,（数据类型*）表示指针. <br> 说明：malloc 向系统申请分配指定size个字节的内存空间。返回类型是 void* 类型。void* 表示未确定类型</p> 
<p>的指针。C,C++规定，void* 类型可以强制转换为任何其它类型的指针。</p> 
<p>malloc（）函数的工作机制 <br> 　　malloc函数的实质体现在，它有一个将可用的内存块连接为一个长长的列表的所谓空闲链表。调用malloc</p> 
<p>函数时，它沿连接表寻找一个大到足以满足用户请求所需要的内存块。然后，将该内存块一分为二（一块的大</p> 
<p>小与用户请求的大小相等，另一块的大小就是剩下的字节）。接下来，将分配给用户的那块内存传给用户，并</p> 
<p>将剩下的那块（如果有的话）返回到连接表上。调用free函数时，它将用户释放的内存块连接到空闲链上。到</p> 
<p>最后，空闲链会被切成很多的小内存片段，如果这时用户申请一个大的内存片段，那么空闲链上可能没有可以</p> 
<p>满足用户要求的片段了。于是，malloc函数请求延时，并开始在空闲链上翻箱倒柜地检查各内存片段，对它们</p> 
<p>进行整理，将相邻的小空闲块合并成较大的内存块。<br>  <br> 和new的不同<br> 从函数声明上可以看出。malloc 和 new 至少有两个不同: new 返回指定类型的指针，并且可以自动计算所需</p> 
<p>要大小。比如：<br> int *p;<br> p = new int; //返回类型为int* 类型(整数型指针)，分配大小为 sizeof(int);<br> 或：<br> int* parr;<br> parr = new int [100]; //返回类型为 int* 类型(整数型指针)，分配大小为 sizeof(int) * 100;<br> 而 malloc 则必须由我们计算要字节数，并且在返回后强行转换为实际类型的指针。<br> int* p;<br> p = (int *) malloc (sizeof(int));<br> 第一、malloc 函数返回的是 void * 类型，如果你写成：p = malloc (sizeof(int)); 则程序无法通过编译，</p> 
<p>报错：“不能将 void* 赋值给 int * 类型变量”。所以必须通过 (int *) 来将强制转换。<br> 第二、函数的实参为 sizeof(int) ，用于指明一个整型数据需要的大小。如果你写成：<br> int* p = (int *) malloc (1);<br> 代码也能通过编译，但事实上只分配了1个字节大小的内存空间，当你往里头存入一个整数，就会有3个字节无</p> 
<p>家可归，而直接“住进邻居家”！造成的结果是后面的内存中原有数据内容全部被清空。</p> 
<p><br> </p> 
<p>3.</p> 
<div class="para">
  函数名： calloc 
</div> 
<div class="para">
  函数原型：void *calloc(size_t n, size_t size)； 
</div> 
<div class="para">
  功 能： 在内存的动态存储区中分配n个长度为size的连续空间，函数返回一个指向分配起始地址的指针；如果分配不成功，返回NULL。 
 <br> 
 <div class="para">
   用 法: void *calloc(size_t n, size_t size)； 
 </div> 
 <div class="para">
   一般使用后要使用 free(起始地址的指针) 对内存进行释放，不然内存申请过多会影响计算机的性能，以至于得重启电脑。如果使用过后不清零，还可以使用指针对该块内存进行访问。 
 </div> 
 <div class="para">
   头文件：stdlib.h或malloc.h 
 </div> 
 <br> 
 <div class="para"> 
  <span style="color:#FF0000">跟malloc的区别：</span> 
 </div> 
 <div class="para">
   calloc在动态分配完内存后，自动初始化该内存空间为零，而malloc不初始化，里边数据是随机的垃圾数据。 
 </div> 
 <br> 
</div> 
<br> 
<p></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/c2677ff61ddee4101a715c1b5ddc79b2/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">【二分图|推理&#43;最大匹配】POJ-1043 What&#39;s In A Name?</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/dacab6f579102cc71c75a6c948b2db9d/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">Sublime Text 3显示输出控制台（show output panel）</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>