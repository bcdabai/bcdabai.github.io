<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>bash脚本编写教程 - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="bash脚本编写教程" />
<meta property="og:description" content="这部教程是我在网上找到比较经典的BASH中文教程，对新手学习bash脚本，bash编程的好文章。
建立一个脚本
Linux中有好多中不同的shell，但是通常我们使用bash (bourne again shell) 进行shell编程，因为bash是免费的并且很容易使用。所以在本文中笔者所提供的脚本都是使用bash(但是在大多数情况下，这些脚本同样可以在 bash的大姐，bourne shell中运行)。
如同其他语言一样，通过我们使用任意一种文字编辑器，比如nedit、kedit、emacs、vi
等来编写我们的shell程序。
程序必须以下面的行开始(必须方在文件的第一行)：
#!/bin/sh
符号#!用来告诉系统它后面的参数是用来执行该文件的程序。在这个例子中我们使用/bin/sh来执行程序。
当编辑好脚本时，如果要执行该脚本，还必须使其可执行。
要使脚本可执行：
chmod &#43;x filename
然后，您可以通过输入： ./filename 来执行您的脚本。
注释
在进行shell编程时，以#开头的句子表示注释，直到这一行的结束。我们真诚地建议您在程序中使用注释。如果您使用了注释，那么即使相当长的时间内没有使用该脚本，您也能在很短的时间内明白该脚本的作用及工作原理。
变量
在其他编程语言中您必须使用变量。在shell编程中，所有的变量都由字符串组成，并且您不需要对变量进行声明。要赋值给一个变量，您可以这样写：
变量名=值
取出变量值可以加一个美元符号($)在变量前面：
#!/bin/sh
#对变量赋值：
a=&#34;hello world&#34;
# 现在打印变量a的内容：
echo &#34;A is:&#34;
echo $a
在您的编辑器中输入以上内容，然后将其保存为一个文件first。之后执行chmod &#43;x first
使其可执行，最后输入./first执行该脚本。
这个脚本将会输出：
A is:
hello world
有时候变量名很容易与其他文字混淆，比如：
num=2
echo &#34;this is the $numnd&#34;
这并不会打印出&#34;this is the 2nd&#34;，而仅仅打印&#34;this is the &#34;，因为shell会去搜索变量numnd的值，但是这个变量时没有值的。可以使用花括号来告诉shell我们要打印的是num变量：
num=2
echo &#34;this is the ${num}nd&#34;
这将打印： this is the 2nd" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/072c8103857c5227cd87ed7da3325736/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-04-01T22:26:17+08:00" />
<meta property="article:modified_time" content="2023-04-01T22:26:17+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">bash脚本编写教程</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p> </p> 
<p>这部教程是我在网上找到比较经典的BASH中文教程，对新手学习bash脚本，bash编程的好文章。<br><br><strong>建立一个脚本</strong></p> 
<p><br> Linux中有好多中不同的shell，但是通常我们使用bash (bourne again shell) 进行shell编程，因为bash是免费的并且很容易使用。所以在本文中笔者所提供的脚本都是使用bash(但是在大多数情况下，这些脚本同样可以在 bash的大姐，bourne shell中运行)。<br> 如同其他语言一样，通过我们使用任意一种文字编辑器，比如nedit、kedit、emacs、vi<br> 等来编写我们的shell程序。<br> 程序必须以下面的行开始(必须方在文件的第一行)：<br><em>#!/bin/sh</em><br> 符号#!用来告诉系统它后面的参数是用来执行该文件的程序。在这个例子中我们使用/bin/sh来执行程序。<br> 当编辑好脚本时，如果要执行该脚本，还必须使其可执行。<br> 要使脚本<strong>可执行：</strong><br> chmod +x filename<br> 然后，您可以通过输入： ./filename 来执行您的脚本。<br><br><strong>注释</strong><br> 在进行shell编程时，以#开头的句子表示注释，直到这一行的结束。我们真诚地建议您在程序中使用注释。如果您使用了注释，那么即使相当长的时间内没有使用该脚本，您也能在很短的时间内明白该脚本的作用及工作原理。<br><br><strong>变量</strong><br> 在其他编程语言中您必须使用变量。在shell编程中，所有的变量都由字符串组成，并且您不需要对变量进行声明。要赋值给一个变量，您可以这样写：<br> 变量名=值<br> 取出变量值可以加一个美元符号($)在变量前面：<br> #!/bin/sh<br> #对变量赋值：<br> a="hello world"<br> # 现在打印变量a的内容：<br> echo "A is:"<br> echo $a<br> 在您的编辑器中输入以上内容，然后将其保存为一个文件first。之后执行chmod +x first<br> 使其可执行，最后输入./first执行该脚本。<br> 这个脚本将会输出：<br> A is:<br> hello world<br> 有时候变量名很容易与其他文字混淆，比如：<br> num=2<br> echo "this is the $numnd"<br> 这并不会打印出"this is the 2nd"，而仅仅打印"this is the "，因为shell会去搜索变量numnd的值，但是这个变量时没有值的。可以使用花括号来告诉shell我们要打印的是num变量：<br> num=2<br> echo "this is the ${num}nd"<br> 这将打印： this is the 2nd<br> 有许多变量是系统自动设定的，这将在后面使用这些变量时进行讨论。如果您需要处理数学表达式，那么您需要使用诸如expr等程序(见下面)。除了一般的仅在程序内有效的shell变量以外，还有环境变量。由export关键字处理过的变量叫做环境变量。我们不对环境变量进行讨论，因为通常情况下仅仅在登录脚本中使用环境变量。<br><br><strong>Shell命令和流程控制</strong><br> 在shell脚本中可以使用三类命令：<br> 1)Unix 命令:<br> 虽然在shell脚本中可以使用任意的unix命令，但是还是由一些相对更常用的命令。这些命令通常是用来进行文件和文字操作的。<br> 常用命令语法及功能<br> echo "some text": 将文字内容打印在屏幕上<br> ls: 文件列表<br> wc –l filewc -w filewc -c file: 计算文件行数计算文件中的单词数计算文件中的字符数<br> cp sourcefile destfile: 文件拷贝<br> mv oldname newname : 重命名文件或移动文件<br> rm file: 删除文件<br> grep 'pattern' file: 在文件内搜索字符串比如：grep 'searchstring' file.txt<br> cut -b colnum file: 指定欲显示的文件内容范围，并将它们输出到标准输出设备比如：输出每行第5个到第9个字符cut -b5-9 file.txt千万不要和cat命令混淆，这是两个完全不同的命令<br> cat file.txt: 输出文件内容到标准输出设备(屏幕)上<br> file somefile: 得到文件类型<br> read var: 提示用户输入，并将输入赋值给变量<br> sort file.txt: 对file.txt文件中的行进行排序<br> uniq: 删除文本文件中出现的行列比如： sort file.txt | uniq<br> expr: 进行数学运算Example: add 2 and 3expr 2 "+" 3<br> find: 搜索文件比如：根据文件名搜索find . -name filename -print<br> tee: 将数据输出到标准输出设备(屏幕) 和文件比如：somecommand | tee outfile<br> basename file: 返回不包含路径的文件名比如： basename /bin/tux将返回 tux<br> dirname file: 返回文件所在路径比如：dirname /bin/tux将返回 /bin<br> head file: 打印文本文件开头几行<br> tail file : 打印文本文件末尾几行<br> sed: Sed是一个基本的查找替换程序。可以从标准输入(比如命令管道)读入文本，并将结果输出到标准输出(屏幕)。该命令采用正则表达式(见参考)进行搜索。 不要和shell中的通配符相混淆。比如：将linuxfocus 替换为 LinuxFocus ：cat text.file | sed 's/linuxfocus/LinuxFocus/' &gt; newtext.file<br> awk: awk 用来从文本文件中提取字段。缺省地，字段分割符是空格，可以使用-F指定其他分割符。cat file.txt | awk -F, '{print $1 "," $3 }'这里我们使用，作为字段分割符，同时打印第一个和第三个字段。如果该文件内容如下： Adam Bor, 34, IndiaKerry Miller, 22, USA命令输出结果为：Adam Bor, IndiaKerry Miller, USA<br> 2) 概念: 管道, 重定向和 backtick<br> 这些不是系统命令，但是他们真的很重要。<br> 管道 (|) 将一个命令的输出作为另外一个命令的输入。<br> grep "hello" file.txt | wc -l<br> 在file.txt中搜索包含有”hello”的行并计算其行数。<br> 在这里grep命令的输出作为wc命令的输入。当然您可以使用多个命令。<br> 重定向：将命令的结果输出到文件，而不是标准输出(屏幕)。<br> &gt; 写入文件并覆盖旧文件<br> &gt;&gt; 加到文件的尾部，保留旧文件内容。<br><br><strong>反短斜线</strong><br> 使用反短斜线可以将一个命令的输出作为另外一个命令的一个命令行参数。<br> 命令：find . -mtime -1 -type f -print<br> 用来查找过去24小时(-mtime –2则表示过去48小时)内修改过的文件。如果您想将所有查找到的文件打一个包，则可以使用以下脚本：<br> #!/bin/sh<br> # The ticks are backticks (`) not normal quotes ('):<br> tar -zcvf lastmod.tar.gz `find . -mtime -1 -type f -print`<br> 3) 流程控制<br> "if" 表达式 如果条件为真则执行then后面的部分：<br> if ....; then<br> ....<br> elif ....; then<br> ....<br> else<br> ....<br> fi<br> 大多数情况下，可以使用测试命令来对条件进行测试。比如可以比较字符串、判断文件是否存在及是否可读等等…<br> 通常用" [ ] "来表示条件测试。注意这里的空格很重要。要确保方括号的空格。<br> [ -f "somefile" ] ：判断是否是一个文件<br> [ -x "/bin/ls" ] ：判断/bin/ls是否存在并有可执行权限<br> [ -n "$var" ] ：判断$var变量是否有值<br> [ "$a" = "$b" ] ：判断$a和$b是否相等<br> 执行man test可以查看所有测试表达式可以比较和判断的类型。<br> 直接执行以下脚本：<br> #!/bin/sh<br> if [ "$SHELL" = "/bin/bash" ]; then<br> echo "your login shell is the bash (bourne again shell)"<br> else<br> echo "your login shell is not bash but $SHELL"<br> fi<br> 变量$SHELL包含了登录shell的名称，我们和/bin/bash进行了比较。<br><br><strong>快捷操作符</strong><br> 熟悉C语言的朋友可能会很喜欢下面的表达式：<br> [ -f "/etc/shadow" ] &amp;&amp; echo "This computer uses shadow passwors"<br> 这里 &amp;&amp; 就是一个快捷操作符，如果左边的表达式为真则执行右边的语句。您也可以认为是逻辑运算中的与操作。上例中表示如果/etc/shadow文件存在则打印” This computer uses shadow passwors”。同样或操作(||)在shell编程中也是可用的。这里有个例子：<br> #!/bin/sh<br> mailfolder=/var/spool/mail/james<br> [ -r "$mailfolder" ]' '{ echo "Can not read $mailfolder" ; exit 1; }<br> echo "$mailfolder has mail from:"<br> grep "^From " $mailfolder<br> 该脚本首先判断mailfolder是否可读。如果可读则打印该文件中的"From" 一行。如果不可读则或操作生效，打印错误信息后脚本退出。这里有个问题，那就是我们必须有两个命令：<br> -打印错误信息<br> -退出程序<br> 我们使用花括号以匿名函数的形式将两个命令放到一起作为一个命令使用。一般函数将在下文提及。不用与和或操作符，我们也可以用if表达式作任何事情，但是使用与或操作符会更便利很多。<br> case表达式可以用来匹配一个给定的字符串，而不是数字。<br> case ... in<br> ...) do something here ;;<br> esac<br> 让我们看一个例子。 file命令可以辨别出一个给定文件的文件类型，比如：<br> file lf.gz<br> 这将返回：<br> lf.gz: gzip compressed data, deflated, original filename,<br> last modified: Mon Aug 27 23:09:18 2001, os: Unix<br> 我们利用这一点写了一个叫做smartzip的脚本，该脚本可以自动解压bzip2, gzip 和zip 类型的压缩文件：<br> #!/bin/sh<br> ftype=`file "$1"`<br> case "$ftype" in<br> "$1: Zip archive"*)<br> unzip "$1" ;;<br> "$1: gzip compressed"*)<br> gunzip "$1" ;;<br> "$1: bzip2 compressed"*)<br> bunzip2 "$1" ;;<br> *) error "File $1 can not be uncompressed with smartzip";;<br> esac<br> 您可能注意到我们在这里使用了一个特殊的变量$1。该变量包含了传递给该程序的第一个参数值。也就是说，当我们运行：<br> smartzip articles.zip<br> $1 就是字符串 articles.zip<br> select 表达式是一种bash的扩展应用，尤其擅长于交互式使用。用户可以从一组不同的值中进行选择。<br> select var in ... ; do<br> break<br> done<br> .... now $var can be used ....<br> 下面是一个例子：<br> #!/bin/sh<br> echo "What is your favourite OS?"<br> select var in "Linux" "Gnu Hurd" "Free BSD" "Other"; do<br> break<br> done<br> echo "You have selected $var"<br> 下面是该脚本运行的结果：<br> What is your favourite OS?<br> 1) Linux<br> 2) Gnu Hurd<br> 3) Free BSD<br> 4) Other<br> #? 1<br> You have selected Linux<br> 您也可以在shell中使用如下的loop表达式：<br> while ...; do<br> ....<br> done<br> while-loop 将运行直到表达式测试为真。will run while the expression that we test for is true. 关键字"break" 用来跳出循环。而关键字”continue”用来不执行余下的部分而直接跳到下一个循环。<br> for-loop表达式查看一个字符串列表 (字符串用空格分隔) 然后将其赋给一个变量：<br> for var in ....; do<br> ....<br> done<br> 在下面的例子中，将分别打印ABC到屏幕上：<br> #!/bin/sh<br> for var in A B C ; do<br> echo "var is $var"<br> done<br> 下面是一个更为有用的脚本showrpm，其功能是打印一些RPM包的统计信息：<br> #!/bin/sh<br> # list a content summary of a number of RPM packages<br> # USAGE: showrpm rpmfile1 rpmfile2 ...<br> # EXAMPLE: showrpm /cdrom/RedHat/RPMS/*.rpm<br> for rpmpackage in $*; do<br> if [ -r "$rpmpackage" ];then<br> echo "=============== $rpmpackage =============="<br> rpm -qi -p $rpmpackage<br> else<br> echo "ERROR: cannot read file $rpmpackage"<br> fi<br> done<br> 这里出现了第二个特殊的变量$*，该变量包含了所有输入的命令行参数值。如果您运行showrpm openssh.rpm w3m.rpm webgrep.rpm<br> 此时 $* 包含了 3 个字符串，即openssh.rpm, w3m.rpm and webgrep.rpm.<br><br><strong>引号</strong><br> 在向程序传递任何参数之前，程序会扩展通配符和变量。这里所谓扩展的意思是程序会把通配符(比如*)替换成合适的文件名，它变量替换成变量值。为了防 止程序作这种替换，您可以使用引号：让我们来看一个例子，假设在当前目录下有一些文件，两个jpg文件， mail.jpg 和tux.jpg。<br><br> #!/bin/sh<br> echo *.jpg<br> 这将打印出"mail.jpg tux.jpg"的结果。<br> 引号 (单引号和双引号) 将防止这种通配符扩展：<br> #!/bin/sh<br> echo "*.jpg"<br> echo '*.jpg'<br> 这将打印"*.jpg" 两次。<br> 单引号更严格一些。它可以防止任何变量扩展。双引号可以防止通配符扩展但允许变量扩展。<br> #!/bin/sh<br> echo $SHELL<br> echo "$SHELL"<br> echo '$SHELL'<br> 运行结果为：<br> /bin/bash<br> /bin/bash<br> $SHELL<br> 最后，还有一种防止这种扩展的方法，那就是使用转义字符——反斜杆：<br> echo *.jpg<br> echo $SHELL<br> 这将输出：<br> *.jpg<br> $SHELL<br><br> Here documents<br> 当要将几行文字传递给一个命令时，here documents(译者注：目前还没有见到过对该词适合的翻译)一种不错的方法。对每个脚本写一段帮助性的文字是很有用的，此时如果我们四有那个 here documents就不必用echo函数一行行输出。 一个 "Here document" 以 &lt;&lt; 开头，后面接上一个字符串，这个字符串还必须出现在here document的末尾。下面是一个例子，在该例子中，我们对多个文件进行重命名，并且使用here documents打印帮助：<br> #!/bin/sh<br> # we have less than 3 arguments. Print the help text:<br> if [ $# -lt 3 ] ; then<br> cat &lt;<br> ren -- renames a number of files using sed regular expressions<br> USAGE: ren 'regexp' 'replacement' files...<br> EXAMPLE: rename all *.HTM files in *.html:<br> ren 'HTM$' 'html' *.HTM<br> HELP<br> exit 0<br> fi<br> OLD="$1"<br> NEW="$2"<br> # The shift command removes one argument from the list of<br> # command line arguments.<br> shift<br> shift<br> # $* contains now all the files:<br> for file in $*; do<br> if [ -f "$file" ] ; then<br> newfile=`echo "$file" | sed "s/${OLD}/${NEW}/g"`<br> if [ -f "$newfile" ]; then<br> echo "ERROR: $newfile exists already"<br> else<br> echo "renaming $file to $newfile ..."<br> mv "$file" "$newfile"<br> fi<br> fi<br> done<br> 这是一个复杂一些的例子。让我们详细讨论一下。第一个if表达式判断输入命令行参数是否小于3个 (特殊变量$# 表示包含参数的个数) 。如果输入参数小于3个，则将帮助文字传递给cat命令，然后由cat命令将其打印在屏幕上。打印帮助文字后程序退出。如果输入参数等于或大于3个，我们 就将第一个参数赋值给变量OLD，第二个参数赋值给变量NEW。下一步，我们使用shift命令将第一个和第二个参数从参数列表中删除，这样原来的第三个 参数就成为参数列表$*的第一个参数。然后我们开始循环，命令行参数列表被一个接一个地被赋值给变量$file。接着我们判断该文件是否存在，如果存在则 通过sed命令搜索和替换来产生新的文件名。然后将反短斜线内命令结果赋值给newfile。这样我们就达到了我们的目的：得到了旧文件名和新文件名。然 后使用mv命令进行重命名。<br><br><strong>函数</strong><br> 如果您写了一些稍微复杂一些的程序，您就会发现在程序中可能在几个地方使用了相同的代码，并且您也会发现，如果我们使用了函数，会方便很多。一个函数是这个样子的：<br> functionname()<br> {<!-- --><br> # inside the body $1 is the first argument given to the function<br> # $2 the second ...<br> body<br> }</p> 
<p><br> 您需要在每个程序的开始对函数进行声明。<br><br> 下面是一个叫做xtitlebar的脚本，使用这个脚本您可以改变终端窗口的名称。这里使用了一个叫做help的函数。正如您可以看到的那样，这个定义的函数被使用了两次。<br> #!/bin/sh<br> # vim: set sw=4 ts=4 et:<br> help(){<!-- --><br> cat &lt;<br> xtitlebar -- change the name of an xterm, gnome-terminal or kde konsole<br> USAGE: xtitlebar [-h] "string_for_titelbar"<br> OPTIONS: -h help text<br> EXAMPLE: xtitlebar "cvs"<br> HELP<br> exit 0<br> }<br> # in case of error or if -h is given we call the function help:<br> [ -z "$1" ] &amp;&amp; help<br> [ "$1" = "-h" ] &amp;&amp; help<br> # send the escape sequence to change the xterm titelbar:<br> echo -e "33]0;$107"<br> #<br> 在脚本中提供帮助是一种很好的编程习惯，这样方便其他用户(和您)使用和理解脚本。<br><br> 命令行参数<br> 我们已经见过$* 和 $1, $2 ... $9 等特殊变量，这些特殊变量包含了用户从命令行输入的参数。迄今为止，我们仅仅了解了一些简单的命令行语法(比如一些强制性的参数和查看帮助的-h选项)。 但是在编写更复杂的程序时，您可能会发现您需要更多的自定义的选项。通常的惯例是在所有可选的参数之前加一个减号，后面再加上参数值 (比如文件名)。<br> 有好多方法可以实现对输入参数的分析，但是下面的使用case表达式的例子无遗是一个不错的方法。<br> #!/bin/sh<br> help(){<!-- --><br> cat &lt;<br> This is a generic command line parser demo.<br> USAGE EXAMPLE: cmdparser -l hello -f -- -somefile1 somefile2<br> HELP<br> exit 0<br> }<br> while [ -n "$1" ]; do<br> case $1 in<br> -h) help;shift 1;; # function help is called<br> -f) opt_f=1;shift 1;; # variable opt_f is set<br> -l) opt_l=$2;shift 2;; # -l takes an argument -&gt; shift by 2<br> --) shift;break;; # end of options<br> -*) echo "error: no such option $1. -h for help";exit 1;;<br> *) break;;<br> esac<br> done<br><br> echo "opt_f is $opt_f"<br> echo "opt_l is $opt_l"<br> echo "first arg is $1"<br> echo "2nd arg is $2"<br> 您可以这样运行该脚本：<br> cmdparser -l hello -f -- -somefile1 somefile2<br> 返回的结果是：<br> opt_f is 1<br> opt_l is hello<br> first arg is -somefile1<br> 2nd arg is somefile2<br> 这个脚本是如何工作的呢？脚本首先在所有输入命令行参数中进行循环，将输入参数与case表达式进行比较，如果匹配则设置一个变量并且移除该参数。根据unix系统的惯例，首先输入的应该是包含减号的参数。<br><br> 实例<br> 一般编程步骤<br> 现在我们来讨论编写一个脚本的一般步骤。任何优秀的脚本都应该具有帮助和输入参数。并且写一个伪脚本(framework.sh)，该脚本包含了大多数脚本都需要的框架结构，是一个非常不错的主意。这时候，在写一个新的脚本时我们只需要执行一下copy命令：cp framework.sh myscript<br> 然后再插入自己的函数。<br> 让我们再看两个例子：<br> 二进制到十进制的转换<br> 脚本 b2d 将二进制数 (比如 1101) 转换为相应的十进制数。这也是一个用expr命令进行数学运算的例子：<br> #!/bin/sh<br> # vim: set sw=4 ts=4 et:<br> help(){<!-- --><br> cat &lt;<br> b2h -- convert binary to decimal<br> USAGE: b2h [-h] binarynum<br> OPTIONS: -h help text<br> EXAMPLE: b2h 111010<br> will return 58<br> HELP<br> exit 0<br> }<br> error(){<!-- --><br> # print an error and exit<br> echo "$1"<br> exit 1<br> }<br> lastchar(){<!-- --><br> # return the last character of a string in $rval<br> if [ -z "$1" ]; then<br> # empty string<br> rval=""<br> return<br> fi<br> # wc puts some space behind the output this is why we need sed:<br> numofchar=`echo -n "$1" | wc -c | sed 's/ //g' `<br> # now cut out the last char<br> rval=`echo -n "$1" | cut -b $numofchar`<br> }<br><br> chop(){<!-- --><br> # remove the last character in string and return it in $rval<br> if [ -z "$1" ]; then<br> # empty string<br> rval=""<br> return<br> fi<br> # wc puts some space behind the output this is why we need sed:<br> numofchar=`echo -n "$1" | wc -c | sed 's/ //g' `<br> if [ "$numofchar" = "1" ]; then<br> # only one char in string<br> rval=""<br> return<br> fi<br> numofcharminus1=`expr $numofchar "-" 1`<br> # now cut all but the last char:<br> rval=`echo -n "$1" | cut -b 0-${numofcharminus1}`<br> }<br> while [ -n "$1" ]; do<br> case $1 in<br> -h) help;shift 1;; # function help is called<br> --) shift;break;; # end of options<br> -*) error "error: no such option $1. -h for help";;<br> *) break;;<br> esac<br> done<br> # The main program<br> sum=0<br> weight=1<br> # one arg must be given:<br> [ -z "$1" ] &amp;&amp; help<br> binnum="$1"<br> binnumorig="$1"<br><br> while [ -n "$binnum" ]; do<br> lastchar "$binnum"<br> if [ "$rval" = "1" ]; then<br> sum=`expr "$weight" "+" "$sum"`<br> fi<br> # remove the last position in $binnum<br> chop "$binnum"<br> binnum="$rval"<br> weight=`expr "$weight" "*" 2`<br> done<br> echo "binary $binnumorig is decimal $sum"<br> #<br> 该脚本使用的算法是利用十进制和二进制数权值 (1,2,4,8,16,..)，比如二进制"10"可以这样转换成十进制：<br> 0 * 1 + 1 * 2 = 2<br> 为了得到单个的二进制数我们是用了lastchar 函数。该函数使用wc –c计算字符个数，然后使用cut命令取出末尾一个字符。Chop函数的功能则是移除最后一个字符。<br> 文件循环程序<br> 或许您是想将所有发出的邮件保存到一个文件中的人们中的一员，但是在过了几个月以后，这个文件可能会变得很大以至于使对该文件的访问速度变慢。下面的脚 本rotatefile 可以解决这个问题。这个脚本可以重命名邮件保存文件(假设为outmail)为outmail.1，而对于outmail.1就变成了outmail.2 等等等等...<br> #!/bin/sh<br> # vim: set sw=4 ts=4 et:<br> ver="0.1"<br> help(){<!-- --><br> cat &lt;<br> rotatefile -- rotate the file name<br><br> USAGE: rotatefile [-h] filename<br><br> OPTIONS: -h help text<br> EXAMPLE: rotatefile out<br> This will e.g rename out.2 to out.3, out.1 to out.2, out to out.1<br> and create an empty out-file<br> The max number is 10<br> version $ver<br> HELP<br> exit 0<br> }<br><br> error(){<!-- --><br> echo "$1"<br> exit 1<br> }<br> while [ -n "$1" ]; do<br> case $1 in<br> -h) help;shift 1;;<br> --) break;;<br> -*) echo "error: no such option $1. -h for help";exit 1;;<br> *) break;;<br> esac<br> done<br> # input check:<br> if [ -z "$1" ] ; then<br> error "ERROR: you must specify a file, use -h for help"<br> fi<br> filen="$1"<br> # rename any .1 , .2 etc file:<br> for n in 9 8 7 6 5 4 3 2 1; do<br> if [ -f "$filen.$n" ]; then<br> p=`expr $n + 1`<br> echo "mv $filen.$n $filen.$p"<br> mv $filen.$n $filen.$p<br> fi<br> done<br> # rename the original file:<br> if [ -f "$filen" ]; then<br> echo "mv $filen $filen.1"<br> mv $filen $filen.1<br> fi<br> echo touch $filen<br> touch $filen<br> 这个脚本是如何工作的呢？在检测用户提供了一个文件名以后，我们进行一个9到1的循环。文件9被命名为10，文件8重命名为9等等。循环完成之后，我们将原始文件命名为文件1同时建立一个与原始文件同名的空文件。<br><br> 调试<br> 最简单的调试命令当然是使用echo命令。您可以使用echo在任何怀疑出错的地方打印任何变量值。这也是绝大多数的shell程序员要花费80%的时间来调试程序的原因。Shell程序的好处在于不需要重新编译，插入一个echo命令也不需要多少时间。<br> shell也有一个真实的调试模式。如果在脚本"strangescript" 中有错误，您可以这样来进行调试：<br> sh -x strangescript<br> 这将执行该脚本并显示所有变量的值。<br> shell还有一个不需要执行脚本只是检查语法的模式。可以这样使用：<br> sh -n your_script<br> 这将返回所有语法错误。<br> 我们希望您现在可以开始写您自己的shell脚本，希望您玩得开心。<br><br> 基于linux的环境变量的定制<br> 1、引言<br> 在linux系统下，如果你下载并安装了应用程序，很有可能在键入它的名称时出现“command not found”的提示内容。如果每次都到安装目标文件夹内，找到可执行文件来进行操作就太繁琐了。这涉及到环境变量PATH的设置问题，而PATH的设置也是在linux下定制环境变量的一个组成部分。<br><br> 2、变量简介<br> Linux是一个多用户的操作系统。每个用户登录系统后，都会有一个专用的运行环境。通常每个用户默认的环境都是相同的，这个默认环境实际上就是一组环境变量的定义。用户可以对自己的运行环境进行定制，其方法就是修改相应的系统环境变量。<br><br> 3、定制环境变量<br> 环境变量是和Shell紧密相关的，用户登录系统后就启动了一个Shell。对于Linux来说一般是bash，但也可以重新设定或切换到其它的Shell。根据发行版本的情况，bash有两个基本的系统级配置文件：/etc/bashrc和/etc/profile。这些配置文件包含两组不同的变量：shell变量和环境变量。前者只是在特定的shell中固定(如bash)，后者在不同shell中固定。很明显，shell变量是局部的，而环境变量是全局的。环境变量是通过Shell命令来设置的，设置好的环境变量又可以被所有当前用户所运行的程序所使用。对于bash这个Shell程序来说，可以通过变量名来访问相应的环境变量，通过export来设置环境变量。下面通过几个实例来说明。<br><br> 3.1 使用命令echo显示环境变量<br> #本例使用echo显示常见的变量HOME<br><br> $ echo $HOME <br> /home/lqm<br><br> 3.2 设置一个新的环境变量<br> $ export HELLO=”Hello!”<br> $ echo $HELLO<br> Hello!<br><br> 3.3 使用env命令显示所有的环境变量<br> $ env<br><br> SSH_AGENT_PID=1875<br> HOSTNAME=lqm<br> SHELL=/bin/bash<br> TERM=xterm<br> HISTSIZE=1000<br> ……<br><br> 3.4  使用set命令显示所有本地定义的Shell变量<br> $ set<br> BASH=/bin/bash<br> ……<br><br> 3.5  使用unset命令来清除环境变量<br> $ export TEST=”test”      #增加一个环境变量TEST<br> $ env | grep TEST           #此命令有输出，证明环境变量TEST已经存在了<br><br> TEST=test<br> $ unset $TEST                #删除环境变量TEST<br> $ env | grep TEST           #此命令无输出，证明环境变量TEST已经存在了<br><br> 3.6  使用readonly命令设置只读变量<br> 如果使用了readonly命令的话，变量就不可以被修改或清除了。示例如下：<br><br> $ export TEST="Test..."                                        #增加一个环境变量TEST<br> $ readonly TEST                                                   #将环境变量TEST设为只读<br> $ unset TEST                                                        #会发现此变量不能被删除<br> -bash: unset: TEST: cannot unset: readonly variable<br> $ TEST="New"                                                     #会发现此变量不能被修改<br> -bash: TEST: readonly variable<br><br> 3.7  用C程序来访问和设置环境变量<br> 对于C程序的用户来说，可以使用下列三个函数来设置或访问一个环境变量。<br> getenv()访问一个环境变量。输入参数是需要访问的变量名字，返回值是一个字符串。如果所访问的环境变量不存在，则会返回NULL。<br> setenv()在程序里面设置某个环境变量的函数。<br> unsetenv()清除某个特定的环境变量的函数。<br> 另外，还有一个指针变量environ，它指向的是包含所有的环境变量的一个列表。下面的程序可以打印出当前运行环境里面的所有环境变量：<br><br> #include<br> extern char**environ;<br> int main (){<!-- --><br><br> char**var;<br> for (var =environ;*var !=NULL;++var)<br> printf ("%s \n ",*var);<br> return 0;<br> }<br><br> 3.8  通过修改环境变量定义文件来修改环境变量。<br> 需要注意的是，一般情况下，这仅仅对于普通用户适用，避免修改根用户的环境定义文件，因为那样可能会造成潜在的危险。<br><br> $cd                               #到用户根目录下<br> $ls -a                            #查看所有文件，包含隐藏的文件<br> $vi .bash_profile                 #修改环境变量定义文件<br> 然后编辑你的PATH声明，其格式为：<br> PATH=$PATH::::------:<br> 你可以自己加上指定的路径，中间用冒号隔开。环境变量更改后，在用户下次登陆时生效，如果想立刻生效，则可执行下面的语句：$source .bash_profile<br> 需要注意的是，最好不要把当前路径”./”放到PATH里，这样可能会受到意想不到的攻击。完成后，可以通过$ echo $PATH查看当前的搜索路径。这样定制后，就可以避免频繁的启动位于shell搜索的路径之外的程序了。<br><br><strong>4、总结</strong><br> 通过以上的设置，你可以有一个比较方便有效的环境来提高你的工作效率了。</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/b0472ac6b448e48e819b847480474142/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">第三、四章 面向对象 （第三次作业）</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/47908f4d2844cc5673931b03b966759d/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">PCB模块化设计19——光口模块PCB布局布线设计规范</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>